---
title: 1、告警规则配置
---
## 📚 目录

1. [告警规则基础概念](#1-告警规则基础概念)
2. [rule_files配置详解](#2-rule_files配置详解)
3. [告警规则语法结构](#3-告警规则语法结构)
4. [告警表达式编写技巧](#4-告警表达式编写技巧)
5. [for持续时间设置策略](#5-for持续时间设置策略)
6. [告警级别设计与实践](#6-告警级别设计与实践)
7. [告警标签与注解配置](#7-告警标签与注解配置)
8. [规则文件组织最佳实践](#8-规则文件组织最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚨 告警规则基础概念


### 1.1 什么是Prometheus告警规则

🎯 **简单理解**：告警规则就像家里的"烟雾报警器"

```
现实生活中的报警器：
烟雾探测器 → 检测到烟雾 → 发出警报声 → 提醒主人处理

Prometheus告警系统：
监控指标 → 触发阈值条件 → 生成告警事件 → 通知运维人员
```

**🔸 告警规则的核心作用**
- **主动发现问题**：不用人工盯着监控面板，系统自动发现异常
- **及时响应处理**：问题出现时立即通知相关人员
- **分级处理机制**：不同严重程度的问题分别处理
- **历史记录追踪**：记录所有告警事件，便于分析和改进

### 1.2 告警规则工作流程

**📋 从监控到通知的完整流程**

```
完整告警流程图：
Prometheus收集指标 
       ↓
   评估告警规则
       ↓
   触发告警条件？ ——→ [否] 继续监控
       ↓ [是]
   等待持续时间(for)
       ↓
   持续时间到达？ ——→ [否] 重新评估  
       ↓ [是]
   生成告警事件
       ↓
   发送到Alertmanager
       ↓
   Alertmanager处理路由
       ↓
   发送通知(邮件/短信/钉钉等)
```

### 1.3 告警规则与录制规则的区别

**🔍 两种规则类型对比**

| 特性 | **告警规则(Alert Rules)** | **录制规则(Recording Rules)** |
|------|-------------------------|------------------------------|
| 🔸 **主要用途** | `发现问题，触发通知` | `预计算复杂查询，提升性能` |
| 🔸 **输出结果** | `告警事件` | `新的时间序列数据` |
| 🔸 **触发条件** | `满足阈值条件` | `定时执行计算` |
| 🔸 **使用场景** | `异常监控` | `复杂指标预计算` |

**💡 简单记忆方法**
- **告警规则**：像"保安"，发现问题就报警
- **录制规则**：像"会计"，定期计算汇总数据

---

## 2. 📁 rule_files配置详解


### 2.1 prometheus.yml中的rule_files配置

**⚙️ 告诉Prometheus去哪里找告警规则**

在Prometheus主配置文件中指定规则文件位置：

```yaml
# prometheus.yml 配置示例
global:
  scrape_interval: 15s
  evaluation_interval: 15s  # 告警规则评估间隔

rule_files:
  - "rules/*.yml"           # 加载rules目录下所有yml文件
  - "alerts/cpu.yml"        # 加载特定的CPU告警规则
  - "alerts/memory.yml"     # 加载内存相关告警规则
  - "alerts/disk.yml"       # 加载磁盘相关告警规则
```

**🔸 配置路径的几种方式**
- **相对路径**：相对于prometheus.yml文件的位置
- **绝对路径**：完整的文件系统路径
- **通配符**：使用*匹配多个文件
- **目录匹配**：使用/**递归匹配子目录

### 2.2 规则文件加载验证

**✅ 确保规则文件正确加载**

检查规则是否正确加载的方法：

```bash
# 1. 重启Prometheus前先验证配置
./promtool check config prometheus.yml

# 2. 检查规则文件语法
./promtool check rules alerts/*.yml

# 3. 查看Prometheus日志
tail -f /var/log/prometheus.log | grep -i rule

# 4. 通过Web界面检查
# 访问 http://prometheus:9090/rules
# 可以看到所有加载的规则状态
```

**🚨 常见加载问题排查**
- **文件路径错误**：检查路径是否正确，注意相对路径和绝对路径
- **文件权限问题**：确保Prometheus进程有读取权限
- **YAML语法错误**：使用工具验证YAML格式
- **规则语法错误**：检查PromQL表达式是否正确

### 2.3 热重载配置

**🔄 不重启更新规则配置**

实现规则文件的热重载：

```bash
# 方法1：发送SIGHUP信号
kill -HUP `pgrep prometheus`

# 方法2：使用HTTP API
curl -X POST http://localhost:9090/-/reload

# 方法3：设置启动参数支持热重载
./prometheus --config.file=prometheus.yml --web.enable-lifecycle
```

---

## 3. 📖 告警规则语法结构


### 3.1 基本语法结构

**📋 告警规则的标准格式**

每个告警规则的基本结构：

```yaml
groups:                    # 规则组
  - name: example-alerts   # 组名称
    rules:                 # 规则列表
    - alert: HighCPUUsage  # 告警名称
      expr: |              # PromQL表达式
        100 - (avg by(instance) 
        (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
      for: 5m              # 持续时间
      labels:              # 告警标签
        severity: warning
        service: system
      annotations:         # 告警注解
        summary: "CPU使用率过高"
        description: "实例 {{ $labels.instance }} CPU使用率超过80%"
```

### 3.2 各字段详细说明

**🔍 理解每个字段的作用**

**groups（规则组）**
- **作用**：将相关的规则组织在一起，便于管理
- **好处**：同一组的规则会一起评估，提高效率

**alert（告警名称）**
- **作用**：给这个告警起一个唯一的名字
- **命名建议**：使用有意义的名称，如HighCPUUsage、DiskSpaceLow

**expr（表达式）**
- **作用**：定义什么情况下触发告警
- **语言**：使用PromQL查询语言编写
- **返回值**：必须返回数值，大于0表示触发告警

**for（持续时间）**
- **作用**：条件满足多长时间后才真正触发告警
- **目的**：避免因为短暂波动产生误报

**labels（标签）**
- **作用**：给告警添加分类标签
- **用途**：Alertmanager根据标签进行路由分组

**annotations（注解）**
- **作用**：提供告警的详细描述信息
- **用途**：显示在告警通知中，帮助理解问题

### 3.3 多条件复合告警

**🔗 组合多个条件的告警**

复杂场景的告警规则示例：

```yaml
groups:
  - name: complex-alerts
    rules:
    # 复合条件：CPU高且内存也高
    - alert: SystemOverload
      expr: |
        (
          (100 - (avg by(instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)) > 80
        ) 
        and 
        (
          (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 80
        )
      for: 3m
      labels:
        severity: critical
        category: performance
      annotations:
        summary: "系统负载过高"
        description: "实例 {{ $labels.instance }} 同时出现CPU({{ $value }}%)和内存使用率过高"

    # 条件范围告警：磁盘使用率在不同阈值有不同级别
    - alert: DiskSpaceWarning
      expr: |
        (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 75
        and
        (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 <= 90
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "磁盘空间不足警告"
        description: "{{ $labels.instance }} 的 {{ $labels.mountpoint }} 磁盘使用率达到 {{ $value }}%"

    - alert: DiskSpaceCritical  
      expr: |
        (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 90
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "磁盘空间严重不足"
        description: "{{ $labels.instance }} 的 {{ $labels.mountpoint }} 磁盘使用率达到 {{ $value }}%，请立即处理"
```

---

## 4. 💡 告警表达式编写技巧


### 4.1 常用告警表达式模式

**📊 实用的PromQL表达式模板**

**CPU使用率告警**
```yaml
# 简单版本：整体CPU使用率
expr: 100 - (avg(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80

# 按实例分组版本：每个服务器单独计算
expr: 100 - (avg by(instance)(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80

# 排除特定模式：排除iowait的CPU
expr: |
  100 - (avg by(instance)(
    irate(node_cpu_seconds_total{mode=~"idle|iowait"}[5m])
  ) * 100) > 80
```

**内存使用率告警**
```yaml
# 可用内存百分比
expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 85

# 内存使用超过具体数值（如剩余内存少于2GB）
expr: node_memory_MemAvailable_bytes < 2*1024*1024*1024
```

**磁盘相关告警**
```yaml
# 磁盘使用率
expr: (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 90

# 磁盘IO等待时间过长
expr: irate(node_cpu_seconds_total{mode="iowait"}[5m]) * 100 > 20

# 磁盘剩余空间少于5GB
expr: node_filesystem_avail_bytes < 5*1024*1024*1024
```

### 4.2 网络和服务可用性告警

**🌐 网络和服务监控表达式**

**服务可用性检查**
```yaml
# HTTP服务是否可访问
expr: up{job="web-servers"} == 0

# HTTP响应时间过长
expr: histogram_quantile(0.95, http_request_duration_seconds_bucket) > 2

# HTTP错误率过高
expr: |
  (
    sum(rate(http_requests_total{status=~"5.."}[5m])) 
    / 
    sum(rate(http_requests_total[5m]))
  ) * 100 > 5
```

**网络连接告警**
```yaml
# TCP连接数过多
expr: node_netstat_Tcp_CurrEstab > 1000

# 网络丢包率过高
expr: |
  (
    increase(node_network_receive_drop_total[5m]) + 
    increase(node_network_transmit_drop_total[5m])
  ) > 10
```

### 4.3 数据库和中间件告警

**🗄️ 常见基础组件监控**

**MySQL数据库告警**
```yaml
# MySQL连接数过多
expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections * 100 > 80

# MySQL慢查询增长
expr: increase(mysql_global_status_slow_queries[5m]) > 10

# MySQL复制延迟
expr: mysql_slave_lag_seconds > 30
```

**Redis缓存告警**  
```yaml
# Redis内存使用率
expr: redis_memory_used_bytes / redis_memory_max_bytes * 100 > 90

# Redis连接数过多
expr: redis_connected_clients > 100

# Redis命中率过低
expr: |
  (
    redis_keyspace_hits_total / 
    (redis_keyspace_hits_total + redis_keyspace_misses_total)
  ) * 100 < 80
```

### 4.4 表达式优化技巧

**⚡ 提高查询性能的方法**

**🔸 使用rate而不是increase**
```yaml
# 推荐：使用rate计算每秒速率
expr: rate(http_requests_total[5m]) > 10

# 不推荐：increase需要除以时间窗口
expr: increase(http_requests_total[5m]) / 300 > 10
```

**🔸 合理选择时间窗口**
```yaml
# 短时间窗口：适合快速变化的指标
expr: rate(cpu_usage[1m]) > 0.8

# 长时间窗口：适合平滑波动的指标  
expr: avg_over_time(memory_usage[10m]) > 0.8
```

**🔸 使用标签筛选减少数据量**
```yaml
# 好：先筛选再计算
expr: avg(cpu_usage{env="production",region="us-east"}) > 0.8

# 不好：全量计算再筛选
expr: avg(cpu_usage) > 0.8 and env="production"
```

---

## 5. ⏰ for持续时间设置策略


### 5.1 for参数的重要性

**🎯 为什么需要持续时间判断**

```
没有for参数的问题：
网络瞬间波动 → 立即触发告警 → 发送通知 → 问题自己恢复 → 产生误报

有for参数的好处：
网络瞬间波动 → 满足条件但等待 → 问题自己恢复 → 不发送告警 → 避免误报
持续性问题 → 满足条件并等待 → 持续时间到达 → 发送告警 → 准确报警
```

**🔸 for参数的作用机制**
- **防止误报**：过滤掉短暂的异常波动
- **确认问题**：确保问题确实存在且持续
- **减少噪音**：避免频繁的告警通知
- **提高准确性**：只对真正的问题发出告警

### 5.2 不同场景的持续时间设置

**📊 根据监控对象选择合适的时间**

| 监控对象 | **建议持续时间** | **设置理由** | **示例场景** |
|---------|----------------|-------------|-------------|
| 🔸 **CPU使用率** | `3-5分钟` | `CPU波动较频繁` | `临时任务导致短期高CPU` |
| 🔸 **内存使用率** | `2-3分钟` | `内存变化相对稳定` | `内存泄漏逐步增长` |
| 🔸 **磁盘空间** | `10-15分钟` | `磁盘空间变化缓慢` | `日志文件缓慢增长` |
| 🔸 **服务可用性** | `30秒-1分钟` | `服务中断需要快速响应` | `Web服务无法访问` |
| 🔸 **网络延迟** | `2-3分钟` | `网络可能有短暂抖动` | `网络拥塞临时影响` |
| 🔸 **数据库连接** | `1-2分钟` | `连接数变化较快` | `业务高峰期连接激增` |

### 5.3 实际配置示例

**⚙️ 不同类型告警的for设置**

```yaml
groups:
  - name: system-alerts
    rules:
    # 服务可用性：快速响应
    - alert: ServiceDown
      expr: up{job="web-service"} == 0
      for: 30s  # 服务不可用30秒就告警
      labels:
        severity: critical
      annotations:
        summary: "服务不可用"

    # CPU使用率：中等响应
    - alert: HighCPU
      expr: cpu_usage > 80
      for: 5m   # CPU持续5分钟高于80%才告警
      labels:
        severity: warning
      annotations:
        summary: "CPU使用率过高"

    # 磁盘空间：慢响应
    - alert: DiskSpaceLow
      expr: disk_usage > 90
      for: 15m  # 磁盘使用率持续15分钟高于90%才告警
      labels:
        severity: warning
      annotations:
        summary: "磁盘空间不足"

    # 数据库性能：快速响应
    - alert: DatabaseSlowQuery
      expr: mysql_slow_queries > 10
      for: 1m   # 慢查询持续1分钟超过10个就告警
      labels:
        severity: warning
      annotations:
        summary: "数据库慢查询过多"
```

### 5.4 动态调整策略

**🔄 根据实际情况优化for参数**

**📈 监控告警效果调整**
```yaml
# 初始设置：保守一些，避免误报
- alert: APIResponseTime
  expr: api_response_time > 2
  for: 10m  # 开始设置较长时间
  
# 观察一段时间后调整：
# 如果发现问题都能持续5分钟以上，可以调短
- alert: APIResponseTime
  expr: api_response_time > 2
  for: 5m   # 调整为5分钟

# 如果发现经常误报，可以调长
- alert: APIResponseTime
  expr: api_response_time > 2
  for: 15m  # 调整为15分钟
```

**🎯 分级告警的for设置**
```yaml
# 同一个指标的不同级别告警
- alert: HighCPUWarning
  expr: cpu_usage > 70
  for: 10m    # warning级别可以等待长一点
  labels:
    severity: warning

- alert: HighCPUCritical
  expr: cpu_usage > 90
  for: 2m     # critical级别需要快速响应
  labels:
    severity: critical
```

---

## 6. 🚦 告警级别设计与实践


### 6.1 标准告警级别体系

**📊 建立清晰的告警分级标准**

```
告警级别金字塔：
                Critical (严重)
                    ↑
               Warning (警告) 
                    ↑
                Info (信息)
                    ↑
               Debug (调试)

处理优先级：Critical > Warning > Info > Debug
```

**🔸 各级别的定义和特点**

| 级别 | **中文名称** | **响应时间** | **影响范围** | **处理方式** |
|------|-------------|-------------|-------------|-------------|
| 🔴 **Critical** | `严重告警` | `5分钟内` | `业务中断` | `立即处理` |
| 🟡 **Warning** | `警告告警` | `30分钟内` | `性能下降` | `及时关注` |
| 🔵 **Info** | `信息告警` | `工作时间内` | `状态变化` | `了解即可` |
| ⚪ **Debug** | `调试信息` | `可忽略` | `技术细节` | `开发调试` |

### 6.2 Critical级别告警设计

**🚨 最高优先级的告警场景**

Critical级别告警应该满足以下条件：
- **业务直接受影响**：用户无法正常使用服务
- **需要立即处理**：不处理会造成更大损失
- **影响范围较大**：多个用户或核心功能受影响

```yaml
groups:
  - name: critical-alerts
    rules:
    # 服务完全不可用
    - alert: ServiceCompletelyDown
      expr: up{job="web-service"} == 0
      for: 1m
      labels:
        severity: critical
        urgency: immediate
      annotations:
        summary: "核心服务不可用"
        description: "{{ $labels.job }} 服务完全无法访问，业务受到严重影响"
        runbook_url: "https://wiki.company.com/runbook/service-down"

    # 数据库连接失败
    - alert: DatabaseConnectionFailed
      expr: mysql_up == 0
      for: 30s
      labels:
        severity: critical
        component: database
      annotations:
        summary: "数据库连接失败"
        description: "无法连接到MySQL数据库，所有依赖数据库的功能将无法使用"

    # 磁盘空间极度不足
    - alert: DiskSpaceExtremeleLow
      expr: (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 95
      for: 5m
      labels:
        severity: critical
        resource: disk
      annotations:
        summary: "磁盘空间极度不足"
        description: "{{ $labels.instance }} 磁盘使用率达到 {{ $value }}%，系统可能无法正常写入"
```

### 6.3 Warning级别告警设计

**⚠️ 需要关注但不紧急的告警**

Warning级别告警特点：
- **潜在问题**：可能导致未来的严重问题
- **性能影响**：影响系统性能但不影响功能
- **预警作用**：提前发现趋势性问题

```yaml
groups:
  - name: warning-alerts
    rules:
    # CPU使用率较高
    - alert: HighCPUUsage
      expr: (100 - (avg by(instance)(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)) > 80
      for: 5m
      labels:
        severity: warning
        component: system
      annotations:
        summary: "CPU使用率偏高"
        description: "{{ $labels.instance }} CPU使用率达到 {{ $value }}%，建议检查是否有异常进程"

    # 内存使用率较高
    - alert: HighMemoryUsage
      expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 80
      for: 10m
      labels:
        severity: warning
        component: system
      annotations:
        summary: "内存使用率偏高"
        description: "{{ $labels.instance }} 内存使用率达到 {{ $value }}%"

    # API响应时间较慢
    - alert: SlowAPIResponse
      expr: histogram_quantile(0.95, http_request_duration_seconds_bucket) > 2
      for: 5m
      labels:
        severity: warning
        component: api
      annotations:
        summary: "API响应时间较慢"
        description: "95%的API请求响应时间超过2秒，当前值：{{ $value }}秒"
```

### 6.4 Info级别告警设计

**ℹ️ 信息性告警配置**

Info级别告警用于：
- **状态变化通知**：系统状态的正常变化
- **维护操作提醒**：计划性的操作通知
- **趋势信息**：长期趋势的提醒

```yaml
groups:
  - name: info-alerts
    rules:
    # 服务重启通知
    - alert: ServiceRestarted
      expr: changes(process_start_time_seconds[10m]) > 0
      for: 1m
      labels:
        severity: info
        type: notification
      annotations:
        summary: "服务已重启"
        description: "{{ $labels.job }} 服务在过去10分钟内重启过"

    # 磁盘空间增长提醒
    - alert: DiskSpaceGrowingFast
      expr: predict_linear(node_filesystem_avail_bytes[2h], 24*3600) < 0
      for: 30m
      labels:
        severity: info
        type: prediction
      annotations:
        summary: "磁盘空间增长较快"
        description: "按当前趋势，{{ $labels.instance }} 的磁盘将在24小时内用完"

    # 新版本部署通知
    - alert: NewVersionDeployed
      expr: changes(application_version[5m]) > 0
      for: 1m
      labels:
        severity: info
        type: deployment
      annotations:
        summary: "应用版本更新"
        description: "应用已更新到新版本：{{ $labels.version }}"
```

---

## 7. 🏷️ 告警标签与注解配置


### 7.1 标签(Labels)的作用和设计

**🏷️ 标签是告警的"身份证"**

标签的主要作用：
- **分类管理**：按不同维度对告警进行分类
- **路由控制**：Alertmanager根据标签决定通知方式
- **聚合分组**：相同标签的告警可以合并处理
- **查询过滤**：可以根据标签快速查找特定告警

**🔸 常用标签设计模式**
```yaml
labels:
  # 严重程度标签
  severity: critical|warning|info
  
  # 组件分类标签
  component: database|web|api|cache
  
  # 环境标签
  environment: production|staging|development
  
  # 团队责任标签
  team: backend|frontend|devops|dba
  
  # 业务线标签
  service: user-service|order-service|payment-service
  
  # 地理位置标签
  region: us-east|us-west|eu-central
  
  # 紧急程度标签
  urgency: immediate|high|medium|low
```

### 7.2 实用标签配置示例

**⚙️ 真实场景的标签设计**

```yaml
groups:
  - name: comprehensive-labels
    rules:
    # 数据库告警：多维度标签
    - alert: DatabaseHighConnections
      expr: mysql_global_status_threads_connected > 100
      for: 5m
      labels:
        severity: warning          # 严重程度
        component: database        # 组件类型
        service: mysql            # 具体服务
        team: dba                 # 负责团队
        environment: production   # 环境
        region: "{{ $labels.region }}"    # 继承原有标签
        action_required: monitor  # 需要的动作
      annotations:
        summary: "MySQL连接数过多"
        description: "MySQL当前连接数：{{ $value }}，超过阈值100"

    # Web服务告警：业务相关标签
    - alert: WebServiceSlowResponse
      expr: histogram_quantile(0.95, http_request_duration_seconds_bucket) > 3
      for: 3m
      labels:
        severity: warning
        component: web
        service: "{{ $labels.service }}"   # 动态服务名
        team: backend
        impact: user_experience    # 影响类型
        priority: high            # 优先级
        escalation_path: L2       # 升级路径
      annotations:
        summary: "Web服务响应缓慢"
        description: "服务 {{ $labels.service }} 95%响应时间超过3秒：{{ $value }}s"

    # 基础设施告警：资源相关标签
    - alert: HighCPUUsage
      expr: (100 - (avg by(instance)(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)) > 85
      for: 5m
      labels:
        severity: warning
        component: infrastructure
        resource_type: cpu
        team: sre
        host: "{{ $labels.instance }}"    # 主机标识
        auto_scale: enabled       # 是否支持自动扩容
        cost_impact: medium       # 成本影响
      annotations:
        summary: "服务器CPU使用率过高"
        description: "主机 {{ $labels.instance }} CPU使用率：{{ $value }}%"
```

### 7.3 注解(Annotations)的设计技巧

**📝 让告警信息更丰富和实用**

注解的设计原则：
- **清晰描述问题**：让人一眼看出是什么问题
- **提供上下文信息**：包含相关的数值和时间
- **给出处理建议**：告诉收到告警的人该怎么办
- **包含有用链接**：指向相关文档或工具

**🔸 注解字段的标准设计**
```yaml
annotations:
  # 基础信息字段
  summary: "简短的问题描述"                    # 一句话概括问题
  description: "详细的问题描述和上下文"         # 具体的问题描述
  
  # 处理相关字段
  runbook_url: "https://wiki.com/runbook"     # 处理手册链接
  dashboard_url: "https://grafana.com/d/xxx"  # 相关监控面板
  solution: "建议的解决方案"                   # 处理建议
  
  # 业务影响字段
  impact: "对业务的影响描述"                   # 业务影响
  affected_users: "受影响的用户范围"           # 影响范围
  
  # 技术细节字段
  current_value: "{{ $value }}"              # 当前值
  threshold: "阈值信息"                       # 触发阈值
  trend: "变化趋势描述"                       # 趋势分析
```

### 7.4 动态注解内容生成

**🎯 使用模板变量让注解更智能**

```yaml
groups:
  - name: dynamic-annotations
    rules:
    # 使用模板变量的丰富注解
    - alert: DiskSpaceAlert
      expr: (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 80
      for: 10m
      labels:
        severity: warning
        team: sre
      annotations:
        summary: "磁盘空间不足警告"
        description: |
          主机：{{ $labels.instance }}
          挂载点：{{ $labels.mountpoint }}
          当前使用率：{{ printf "%.2f" $value }}%
          总空间：{{ with query "node_filesystem_size_bytes{instance=\"" }}{{ . | first | value | humanize1024 }}B{{ end }}
          剩余空间：{{ with query "node_filesystem_avail_bytes{instance=\"" }}{{ . | first | value | humanize1024 }}B{{ end }}
          
        runbook_url: "https://wiki.company.com/disk-cleanup"
        dashboard_url: "https://grafana.company.com/d/disk-monitoring?var-instance={{ $labels.instance }}"
        solution: |
          1. 检查大文件：du -sh /* | sort -hr | head -10
          2. 清理日志：journalctl --vacuum-time=7d
          3. 清理临时文件：rm -rf /tmp/* /var/tmp/*
        impact: "可能影响应用日志写入和临时文件创建"

    # 带计算的动态注解
    - alert: MemoryPressure
      expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 85
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "内存压力告警"
        description: |
          主机：{{ $labels.instance }}
          内存使用率：{{ printf "%.1f" $value }}%
          总内存：{{ with query "node_memory_MemTotal_bytes{instance=\"" }}{{ . | first | value | humanize1024 }}B{{ end }}
          可用内存：{{ with query "node_memory_MemAvailable_bytes{instance=\"" }}{{ . | first | value | humanize1024 }}B{{ end }}
          
          进程Top5内存使用：
          {{ range query "topk(5, process_memory_bytes{instance=\"" }}
          - {{ .Labels.process }}: {{ .Value | humanize1024 }}B
          {{ end }}
          
        current_value: "{{ printf "%.1f" $value }}%"
        threshold: "85%"
        trend: "{{ if gt $value 90 }}急剧上升{{ else if gt $value 87 }}持续上升{{ else }}缓慢上升{{ end }}"
```

---

## 8. 📂 规则文件组织最佳实践


### 8.1 文件结构设计原则

**🏗️ 构建清晰的规则文件架构**

**🔸 按功能模块组织**
```
alerts/
├── infrastructure/           # 基础设施告警
│   ├── cpu.yml              # CPU相关告警
│   ├── memory.yml           # 内存相关告警
│   ├── disk.yml             # 磁盘相关告警
│   └── network.yml          # 网络相关告警
├── applications/            # 应用程序告警
│   ├── web-services.yml     # Web服务告警
│   ├── databases.yml        # 数据库告警
│   ├── cache.yml            # 缓存服务告警
│   └── message-queue.yml    # 消息队列告警
├── business/                # 业务逻辑告警
│   ├── user-activity.yml    # 用户活动监控
│   ├── order-processing.yml # 订单处理监控
│   └── payment-system.yml   # 支付系统监控
└── sla/                     # SLA相关告警
    ├── availability.yml     # 可用性监控
    ├── performance.yml      # 性能监控
    └── error-rate.yml       # 错误率监控
```

**🔸 按环境分离**
```
alerts/
├── production/              # 生产环境告警
│   ├── critical.yml         # 严重告警
│   ├── warning.yml          # 警告告警
│   └── info.yml             # 信息告警
├── staging/                 # 测试环境告警
│   └── validation.yml       # 验证性告警
└── development/             # 开发环境告警
    └── debug.yml            # 调试告警
```

### 8.2 规则命名规范

**📝 建立一致的命名标准**

**🔸 告警名称命名规范**
```yaml
# 命名格式：[组件][问题类型][严重程度]
# 示例：
- alert: WebServiceHighLatency     # Web服务高延迟
- alert: DatabaseConnectionHigh    # 数据库连接数高
- alert: DiskSpaceCritical        # 磁盘空间严重不足
- alert: APIErrorRateWarning      # API错误率警告

# 命名原则：
# 1. 使用PascalCase（首字母大写）
# 2. 名称要描述性强，一看就知道是什么问题
# 3. 避免缩写，除非是广泛认知的（如API、CPU、DB）
# 4. 包含严重程度信息（Critical、Warning、Info）
```

**🔸 规则组命名规范**
```yaml
# 格式：组件-功能-环境
groups:
  - name: web-server-performance-prod     # Web服务器性能-生产环境
  - name: database-availability-staging   # 数据库可用性-测试环境
  - name: infrastructure-resources-all    # 基础设施资源-所有环境
```

### 8.3 完整的规则文件示例

**📋 标准化的规则文件模板**

```yaml
# infrastructure/cpu.yml
# CPU相关告警规则
# 维护人：SRE团队
# 最后更新：2024-01-15

groups:
  - name: cpu-monitoring-production
    interval: 30s                    # 评估间隔
    rules:
    # CPU使用率警告
    - alert: CPUUsageWarning
      expr: |
        (
          100 - (avg by(instance, job) 
          (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
        ) > 75
      for: 5m
      labels:
        severity: warning
        component: infrastructure
        resource: cpu
        team: sre
        environment: production
        runbook: cpu-high-usage
      annotations:
        summary: "CPU使用率较高"
        description: |
          实例：{{ $labels.instance }}
          作业：{{ $labels.job }}
          当前CPU使用率：{{ printf "%.2f" $value }}%
          
          这表明系统负载较高，建议检查：
          1. 是否有异常进程占用CPU
          2. 是否需要扩容处理能力
          3. 是否有定时任务在执行
        
        runbook_url: "https://wiki.company.com/runbooks/cpu-high-usage"
        dashboard_url: "https://grafana.company.com/d/cpu/cpu-monitoring?var-instance={{ $labels.instance }}"
        current_value: "{{ printf "%.2f" $value }}%"
        threshold: "75%"

    # CPU使用率严重告警
    - alert: CPUUsageCritical
      expr: |
        (
          100 - (avg by(instance, job) 
          (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
        ) > 90
      for: 2m
      labels:
        severity: critical
        component: infrastructure
        resource: cpu
        team: sre
        environment: production
        urgency: immediate
        runbook: cpu-critical-usage
      annotations:
        summary: "CPU使用率严重过高"
        description: |
          ⚠️ 紧急：实例 {{ $labels.instance }} CPU使用率达到 {{ printf "%.2f" $value }}%
          
          立即处理步骤：
          1. 登录服务器检查进程：top -o %CPU
          2. 检查是否可以终止异常进程
          3. 考虑临时扩容或负载转移
          4. 联系相关应用团队确认是否正常
          
        runbook_url: "https://wiki.company.com/runbooks/cpu-critical-usage"
        escalation_contact: "sre-oncall@company.com"
        current_value: "{{ printf "%.2f" $value }}%"
        threshold: "90%"
        impact: "可能导致服务响应缓慢或不可用"

  - name: cpu-monitoring-staging
    interval: 60s                    # 测试环境可以放宽检查间隔
    rules:
    # 测试环境的CPU告警阈值可以更宽松
    - alert: CPUUsageHighStaging
      expr: |
        (
          100 - (avg by(instance, job) 
          (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
        ) > 85
      for: 10m                       # 测试环境等待时间可以更长
      labels:
        severity: info               # 测试环境告警级别较低
        component: infrastructure
        resource: cpu
        team: sre
        environment: staging
      annotations:
        summary: "测试环境CPU使用率较高"
        description: "测试环境 {{ $labels.instance }} CPU使用率：{{ printf "%.2f" $value }}%"
```

### 8.4 规则文件版本管理

**🔄 规则文件的变更管理**

**🔸 使用Git管理规则文件**
```bash
# 规则文件Git仓库结构
prometheus-rules/
├── .gitignore
├── README.md
├── CHANGELOG.md
├── rules/
│   ├── production/
│   ├── staging/
│   └── development/
├── scripts/
│   ├── validate-rules.sh
│   ├── deploy-rules.sh
│   └── test-rules.sh
└── docs/
    ├── rule-conventions.md
    └── troubleshooting.md
```

**🔸 规则变更工作流程**
```bash
#!/bin/bash
# deploy-rules.sh - 规则部署脚本

set -e

echo "1. 验证规则文件语法..."
./promtool check rules rules/**/*.yml

echo "2. 运行规则测试..."
./scripts/test-rules.sh

echo "3. 备份当前规则..."
cp -r /etc/prometheus/rules /etc/prometheus/rules.backup.$(date +%Y%m%d_%H%M%S)

echo "4. 部署新规则..."
cp -r rules/* /etc/prometheus/rules/

echo "5. 重新加载Prometheus配置..."
curl -X POST http://localhost:9090/-/reload

echo "6. 验证规则加载状态..."
sleep 5
curl -s http://localhost:9090/api/v1/rules | jq '.data.groups | length'

echo "规则部署完成!"
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 告警规则本质：自动化的问题发现和通知机制
🔸 规则文件配置：通过rule_files指定规则位置，支持热重载
🔸 语法结构：groups->rules->alert/expr/for/labels/annotations
🔸 表达式编写：使用PromQL编写条件判断，返回值>0触发告警
🔸 持续时间：for参数防止误报，不同类型问题需不同等待时间
🔸 告警分级：critical/warning/info三级体系，对应不同响应要求
🔸 标签注解：labels用于分类路由，annotations提供详细信息
🔸 文件组织：按功能、环境、团队等维度合理组织规则文件
```

### 9.2 关键理解要点


**🔹 告警规则设计的核心思路**
```
问题驱动：
- 先明确要解决什么问题
- 再设计对应的监控规则
- 避免为了告警而告警

用户体验：
- 告警要准确（避免误报）
- 信息要完整（便于处理）
- 分级要合理（不同紧急程度）

运维效率：
- 规则要易于维护
- 文件要组织清晰
- 变更要有流程控制
```

**🔹 告警表达式的编写技巧**
```
性能优化：
- 使用rate()而不是increase()
- 合理选择时间窗口大小
- 利用标签筛选减少计算量

准确性提升：
- 使用by()进行分组聚合
- 考虑数据的周期性特征
- 结合多个指标综合判断

可维护性：
- 使用有意义的变量名
- 添加适当的注释说明
- 避免过于复杂的表达式
```

**🔹 for参数的设置策略**
```
快速响应场景（30s-2m）：
- 服务可用性检查
- 关键业务流程监控
- 安全相关事件

稳定判断场景（3m-10m）：
- 资源使用率监控
- 性能指标监控
- 常规系统监控

趋势分析场景（10m+）：
- 容量规划相关
- 长期趋势监控
- 预测性告警
```

### 9.3 实际应用价值


**🎯 生产环境应用场景**
- **电商平台**：订单处理异常、支付系统故障、库存不足告警
- **金融系统**：交易延迟、风控触发、资金异常流动监控
- **内容平台**：用户访问异常、内容分发失败、存储空间不足
- **SaaS服务**：租户资源超限、API调用异常、数据同步失败

**🔧 运维实践建议**
- **渐进优化**：从基础告警开始，逐步完善复杂场景
- **持续调优**：根据实际效果调整阈值和持续时间
- **文档完善**：建立完整的告警处理手册和故障排查指南
- **团队培训**：确保团队成员理解告警规则和处理流程

**📈 发展趋势**
- **智能化告警**：基于机器学习的动态阈值调整
- **AIOps集成**：告警与自动化运维工具深度结合
- **多云监控**：跨云平台的统一告警管理
- **业务监控**：从技术监控向业务价值监控扩展

**核心记忆口诀**：
- 告警规则像警卫，发现问题就通知
- 表达式要写准，for时间防误报
- 分级标签要清晰，注解信息要详细
- 文件组织要合理，版本管理要规范