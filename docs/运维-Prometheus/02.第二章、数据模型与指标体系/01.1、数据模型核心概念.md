---
title: 1、数据模型核心概念
---
## 📚 目录

1. [什么是Prometheus数据模型](#1-什么是prometheus数据模型)
2. [时间序列核心概念](#2-时间序列核心概念)
3. [指标名称设计规范](#3-指标名称设计规范)
4. [标签系统详解](#4-标签系统详解)
5. [样本与时间戳机制](#5-样本与时间戳机制)
6. [数据存储格式](#6-数据存储格式)
7. [高基数问题与解决方案](#7-高基数问题与解决方案)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 什么是Prometheus数据模型


### 1.1 数据模型的本质


💡 **通俗理解**：想象Prometheus就像一个超级记账本，专门记录各种系统的"体检数据"

```
现实生活中的体检：               Prometheus监控：
体重：65kg (2024-01-15 09:00)   → cpu_usage: 75% (timestamp: 1642204800)
血压：120/80 (2024-01-15 09:05) → memory_used: 8GB (timestamp: 1642205100)
心率：72次/分 (2024-01-15 09:10) → disk_io: 1024MB/s (timestamp: 1642205400)
```

🔸 **核心作用**：
- **统一标准**：所有监控数据都按照同一套规则存储
- **时间追踪**：每个数据都带有精确的时间戳
- **多维度**：可以从不同角度查看同一个指标
- **高效查询**：支持复杂的数据分析和告警

### 1.2 数据模型的四大核心组件


| 组件 | **作用** | **生活类比** |
|------|----------|-------------|
| 🏷️ **指标名称** | `标识这是什么数据` | `体重、血压、心率` |
| 🔖 **标签** | `描述数据的具体属性` | `哪个人、哪家医院、哪个科室` |
| 📊 **数值** | `具体的测量结果` | `65kg、120/80、72次/分` |
| ⏰ **时间戳** | `记录测量的时间` | `2024-01-15 09:00` |

---

## 2. ⏱️ 时间序列核心概念


### 2.1 什么是时间序列


🔸 **定义**：时间序列就是按时间顺序排列的一系列数据点

**生活中的时间序列**：
```
你的体重变化：
1月1日: 70kg
1月8日: 69.5kg  
1月15日: 69kg
1月22日: 68.5kg
1月29日: 68kg

这就是一个时间序列！
```

**Prometheus中的时间序列**：
```
服务器CPU使用率：
2024-01-15 10:00:00 → 45%
2024-01-15 10:01:00 → 52%  
2024-01-15 10:02:00 → 48%
2024-01-15 10:03:00 → 61%
2024-01-15 10:04:00 → 55%
```

### 2.2 时间序列的唯一性


⚡ **重要原则**：每个时间序列都由"指标名称+标签组合"唯一标识

```
时间序列标识示例：

序列1: cpu_usage{server="web01", env="prod"}
序列2: cpu_usage{server="web02", env="prod"}  
序列3: cpu_usage{server="web01", env="test"}

虽然都是cpu_usage，但标签不同，所以是3个不同的时间序列！
```

### 2.3 时间序列的数据结构


```
时间序列 = 指标名称{标签1=值1, 标签2=值2, ...}

实际例子：
http_requests_total{method="GET", status="200", handler="/api/users"}
│                   │                                              │
│                   └─ 标签组合(Labels)                           │
└─ 指标名称(Metric Name)                                          │

对应的数据点：
时间戳: 1642204800, 数值: 1250
时间戳: 1642204860, 数值: 1267  
时间戳: 1642204920, 数值: 1284
```

---

## 3. 📝 指标名称设计规范


### 3.1 指标名称的命名原则


🎯 **核心原则**：指标名称要**见名知意**，让人一看就知道这是什么数据

#### 📋 命名规范详解


**✅ 正确命名示例**：
```
cpu_usage_percent          ← 清楚表达：CPU使用率百分比
memory_used_bytes         ← 清楚表达：内存使用量(字节)
http_requests_total       ← 清楚表达：HTTP请求总数
database_connections_active ← 清楚表达：数据库活跃连接数
```

**❌ 错误命名示例**：
```
data                      ← 太模糊，不知道是什么数据
info                      ← 太宽泛，没有具体含义
status                    ← 不明确，什么的状态？
count                     ← 计数什么？
```

### 3.2 指标类型后缀规范


| 后缀 | **含义** | **示例** | **说明** |
|------|----------|----------|----------|
| `_total` | **累积计数器** | `http_requests_total` | `总请求数，只增不减` |
| `_count` | **事件计数** | `errors_count` | `错误次数统计` |
| `_bytes` | **字节单位** | `memory_used_bytes` | `内存使用量` |
| `_seconds` | **时间单位** | `request_duration_seconds` | `请求耗时` |
| `_percent` | **百分比** | `cpu_usage_percent` | `CPU使用率` |
| `_ratio` | **比率** | `cache_hit_ratio` | `缓存命中率` |

### 3.3 分层命名结构


🏗️ **推荐结构**：`系统组件_具体功能_单位`

```
Web服务器监控指标：
├── nginx_requests_total          ← Nginx总请求数
├── nginx_connections_active      ← Nginx活跃连接数  
├── nginx_response_time_seconds   ← Nginx响应时间
└── nginx_error_rate_percent      ← Nginx错误率

数据库监控指标：
├── mysql_queries_total           ← MySQL查询总数
├── mysql_connections_active      ← MySQL活跃连接
├── mysql_slow_queries_total      ← MySQL慢查询总数
└── mysql_buffer_pool_usage_percent ← MySQL缓冲池使用率
```

---

## 4. 🏷️ 标签系统详解


### 4.1 标签的作用和价值


💡 **标签就像是给数据贴的"便签纸"**，用来描述这个数据的各种属性

**生活类比**：
```
体检报告上的信息：
姓名：张三           ← 对应标签 name="zhangsan"
年龄：30岁          ← 对应标签 age="30"  
科室：内科          ← 对应标签 department="internal"
医院：人民医院       ← 对应标签 hospital="people_hospital"
体重：65kg          ← 这是实际的指标数值
```

### 4.2 标签的设计原则


#### 🎯 高质量标签设计


**✅ 好的标签设计**：
```
http_requests_total{
    method="GET",           ← 请求方法
    status="200",           ← 响应状态码  
    handler="/api/users",   ← 请求路径
    server="web01"          ← 服务器标识
}

为什么好？
- 每个标签都有明确含义
- 标签值相对稳定，不会无限增长
- 便于分组统计和过滤查询
```

**❌ 糟糕的标签设计**：
```
http_requests_total{
    user_id="12345",        ← 用户ID会有成千上万个
    request_id="abc123",    ← 请求ID每次都不同
    timestamp="1642204800", ← 时间戳本身就是时间维度
    full_url="http://..."   ← 完整URL变化太多
}

为什么不好？
- 标签值太多，会产生海量时间序列
- 每个请求都创建新的时间序列
- 查询性能会急剧下降
```

### 4.3 标签基数控制


⚠️ **基数问题**：标签值的所有可能组合数量

```
标签基数计算：

场景1（合理基数）：
method: [GET, POST, PUT, DELETE]           ← 4个值
status: [200, 400, 404, 500]              ← 4个值  
server: [web01, web02, web03]             ← 3个值
总基数: 4 × 4 × 3 = 48 个时间序列 ✅

场景2（基数爆炸）：  
method: [GET, POST, PUT, DELETE]           ← 4个值
user_id: [1, 2, 3, ..., 100000]          ← 10万个值
request_id: [唯一ID]                      ← 无限个值
总基数: 4 × 100000 × ∞ = 无限 ❌
```

#### 📊 基数控制策略


| 策略 | **说明** | **示例** |
|------|----------|----------|
| **分类聚合** | `将具体值归类到有限集合` | `用户ID → 用户类型(vip/normal)` |
| **范围分组** | `将连续值分组` | `具体年龄 → 年龄段(20-30/30-40)` |
| **移除详细信息** | `去掉变化频繁的标签` | `去掉request_id, session_id等` |
| **采样策略** | `只保留部分标签值` | `只监控重要用户的详细数据` |

---

## 5. 📊 样本与时间戳机制


### 5.1 样本的构成


🔸 **样本（Sample）**：就是某个时刻测量到的具体数值

```
样本的组成部分：

时间戳(Timestamp) + 数值(Value) = 一个样本

例子：
样本1: 1642204800 → 75.5    (2024-01-15 10:00:00, CPU使用率75.5%)
样本2: 1642204860 → 78.2    (2024-01-15 10:01:00, CPU使用率78.2%)  
样本3: 1642204920 → 72.1    (2024-01-15 10:02:00, CPU使用率72.1%)
```

### 5.2 时间戳格式


⏰ **时间戳规范**：Prometheus使用Unix时间戳，精确到毫秒

```
时间戳转换示例：

人类可读时间: 2024-01-15 10:00:00
Unix时间戳:   1642204800000 (毫秒)
                      ^^^^ 
                      毫秒部分

计算方法：
从1970年1月1日 00:00:00 UTC 开始的毫秒数
```

### 5.3 数据收集频率


📈 **采集间隔设计**：

```
采集频率选择指南：

🚨 关键业务指标: 15-30秒
   - API响应时间
   - 数据库连接数
   - 支付成功率

⚡ 一般性能指标: 1-2分钟  
   - CPU使用率
   - 内存使用量
   - 磁盘IO

📊 长期趋势指标: 5-15分钟
   - 日活用户数
   - 存储空间使用
   - 成本统计
```

### 5.4 数据点存储特性


```
存储特性说明：

时间序列数据：cpu_usage{server="web01"}

存储结构：
┌─────────────┬─────────┐
│   时间戳     │   数值   │
├─────────────┼─────────┤
│ 1642204800  │   45.2  │ ← 10:00:00
│ 1642204860  │   52.1  │ ← 10:01:00  
│ 1642204920  │   48.7  │ ← 10:02:00
│ 1642204980  │   61.3  │ ← 10:03:00
└─────────────┴─────────┘

特点：
✓ 按时间顺序存储
✓ 支持高效范围查询  
✓ 自动数据压缩
✓ 支持数据过期清理
```

---

## 6. 💾 数据存储格式


### 6.1 存储架构概览


```
Prometheus存储层次：

内存层 (最近2小时)
├── 最新数据缓存
├── 快速查询响应
└── 待写入磁盘队列

磁盘层 (历史数据)  
├── 时间分片存储 (2小时一个块)
├── 数据压缩存储
└── 索引文件加速查询

长期存储 (可选)
├── 远程存储系统
├── 对象存储 (S3/OSS)
└── 数据仓库集成
```

### 6.2 时间分片机制


🗂️ **数据分块存储**：Prometheus将数据按时间切分成小块存储

```
时间分片示例 (每块2小时)：

Block 1: 08:00-10:00
├── cpu_usage{server="web01"} → [样本1, 样本2, ...]
├── memory_used{server="web01"} → [样本1, 样本2, ...]  
└── disk_io{server="web01"} → [样本1, 样本2, ...]

Block 2: 10:00-12:00  
├── cpu_usage{server="web01"} → [样本1, 样本2, ...]
├── memory_used{server="web01"} → [样本1, 样本2, ...]
└── disk_io{server="web01"} → [样本1, 样本2, ...]

优势：
✓ 查询时只需读取相关时间块
✓ 可以并行压缩和查询
✓ 方便数据备份和恢复
✓ 支持数据过期自动清理
```

### 6.3 数据压缩策略


📦 **压缩技术**：

| 压缩方式 | **适用场景** | **压缩率** | **说明** |
|----------|-------------|-----------|----------|
| **时间戳压缩** | `所有时间序列` | `80-90%` | `利用时间规律性压缩` |
| **数值压缩** | `变化缓慢的指标` | `60-80%` | `相邻数值差异压缩` |
| **标签压缩** | `重复标签值` | `70-85%` | `标签字典化存储` |
| **块级压缩** | `历史数据` | `85-95%` | `整个数据块压缩` |

---

## 7. ⚠️ 高基数问题与解决方案


### 7.1 什么是高基数问题


💥 **高基数陷阱**：当标签值的组合数量过多时，会导致系统性能急剧下降

**问题演示**：
```
正常情况 (低基数)：
http_requests{method, status, path}
- method: 4种 (GET/POST/PUT/DELETE)  
- status: 5种 (200/400/404/500/503)
- path: 10种 (主要API路径)
总数: 4 × 5 × 10 = 200 个时间序列 ✅

问题情况 (高基数)：
http_requests{method, status, path, user_id}  
- method: 4种
- status: 5种  
- path: 10种
- user_id: 100万种
总数: 4 × 5 × 10 × 1000000 = 2亿 个时间序列 💥
```

### 7.2 高基数的危害


🚨 **性能影响**：

```
资源消耗对比：

低基数场景 (1000个时间序列)：
├── 内存使用: ~100MB
├── 查询响应: <100ms  
├── 写入性能: >10000 样本/秒
└── 存储空间: ~1GB/月

高基数场景 (100万个时间序列)：
├── 内存使用: ~10GB+  💥
├── 查询响应: >10秒   💥
├── 写入性能: <1000 样本/秒 💥  
└── 存储空间: ~100GB/月 💥
```

### 7.3 解决方案策略


#### 🛠️ 策略1：标签值归类


```java
// ❌ 错误做法：直接使用用户ID
http_requests_total{user_id="12345"}
http_requests_total{user_id="12346"} 
http_requests_total{user_id="12347"}
// ... 100万个不同的时间序列

// ✅ 正确做法：按用户类型分类
http_requests_total{user_type="premium"}
http_requests_total{user_type="normal"}  
http_requests_total{user_type="trial"}
// 只有3个时间序列
```

#### 🛠️ 策略2：分层监控


```
分层监控策略：

全局层面 (低基数)：
├── 总体请求量
├── 平均响应时间  
├── 错误率统计
└── 系统资源使用

重点关注 (中基数)：
├── 重要API详细监控
├── VIP用户行为分析
├── 关键业务流程
└── 异常模式识别

详细诊断 (按需采集)：
├── 单个用户请求链路
├── 具体错误详情
├── 性能瓶颈分析  
└── 临时问题排查
```

#### 🛠️ 策略3：采样和聚合


```yaml
# 采样配置示例
scrape_configs:
  - job_name: 'high-detail-monitoring'
    static_configs:
      - targets: ['app:8080']
    scrape_interval: 15s
    params:
      sample_rate: ['0.1']  # 只采集10%的详细数据
      
  - job_name: 'summary-monitoring'  
    static_configs:
      - targets: ['app:8080'] 
    scrape_interval: 60s
    # 只收集聚合后的汇总指标
```

### 7.4 基数监控和告警


📊 **基数健康检查**：

```
监控指标设置：

prometheus_tsdb_symbol_table_size_bytes  ← 标签符号表大小
prometheus_tsdb_series_max_cardinality   ← 最大基数数量
prometheus_config_last_reload_successful ← 配置重载是否成功

告警规则：
- 基数增长超过50% → 警告
- 基数超过100万 → 严重告警  
- 内存使用超过80% → 紧急告警
- 查询响应超过5秒 → 性能告警
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的概念


```
🎯 四大核心组件：
├── 指标名称：描述这是什么数据
├── 标签：描述数据的各种属性
├── 数值：具体的测量结果  
└── 时间戳：记录测量的时间

🔍 关键理解：
├── 时间序列 = 指标名称 + 标签组合
├── 每个时间序列都是唯一的
├── 标签设计直接影响系统性能
└── 基数控制是成功的关键
```

### 8.2 设计原则清单


| 原则 | **说明** | **检查点** |
|------|----------|-----------|
| 📝 **命名规范** | `指标名称要见名知意` | `☐ 包含系统组件` `☐ 包含功能描述` `☐ 包含单位后缀` |
| 🏷️ **标签设计** | `标签值要有限且稳定` | `☐ 避免高基数标签` `☐ 去除唯一性标识` `☐ 分类聚合细节` |
| ⏰ **采集频率** | `根据重要性调整间隔` | `☐ 关键指标15-30秒` `☐ 一般指标1-2分钟` `☐ 趋势指标5-15分钟` |
| 📊 **基数控制** | `监控时间序列数量` | `☐ 单个指标<1万序列` `☐ 总体<100万序列` `☐ 设置基数告警` |

### 8.3 常见错误避免


⚠️ **高风险操作**：
```
❌ 把用户ID做标签     → 基数爆炸
❌ 把请求ID做标签     → 内存耗尽  
❌ 把完整URL做标签    → 查询变慢
❌ 采集间隔太频繁     → 存储压力大
❌ 标签值不做限制     → 系统崩溃
```

✅ **正确做法**：
```
✓ 用户类型替代用户ID   → 可控基数
✓ 路径模式替代完整URL → 有限组合
✓ 状态码分类合并       → 降低复杂度  
✓ 合理设置采集频率     → 平衡性能
✓ 定期检查基数增长     → 预防问题
```

### 8.4 学习检查清单


📋 **掌握程度自测**：

**🌟 基础理解** (必须掌握)：
- ☐ 能解释什么是时间序列
- ☐ 明白指标名称的命名规范  
- ☐ 理解标签的作用和设计原则
- ☐ 知道基数问题的危害

**🔥 进阶应用** (实践必备)：
- ☐ 能设计合理的监控指标
- ☐ 会控制标签基数
- ☐ 能识别高基数风险
- ☐ 会配置采集策略

**💀 高级优化** (深入掌握)：
- ☐ 能优化存储性能
- ☐ 会设计分层监控
- ☐ 能处理大规模场景
- ☐ 会进行容量规划

**记忆口诀**：
> 指标标签样本时间戳，四大组件要记牢  
> 基数控制是关键，标签设计不能糟  
> 命名规范见名意，采集频率要合理  
> 时间序列唯一性，监控系统才稳妥