---
title: 5、Summary摘要统计
---
## 📚 目录

1. [Summary指标类型概述](#1-Summary指标类型概述)
2. [Summary的工作原理](#2-Summary的工作原理)
3. [Summary与Histogram对比](#3-Summary与Histogram对比)
4. [Summary的适用场景](#4-Summary的适用场景)
5. [性能影响与选择建议](#5-性能影响与选择建议)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📊 Summary指标类型概述


### 1.1 什么是Summary指标


**通俗理解**：Summary就像是一个"智能统计器"，它能帮你自动计算一组数据的摘要信息。

```
简单比喻：
想象你是班主任，要统计全班同学的考试成绩
- 你不仅要知道平均分
- 还想知道有多少人及格（分位数）
- 总共考了多少次试
- Summary就是帮你自动完成这些统计的工具
```

**🔸 Summary的核心特征**
- **自动摘要**：无需手动设置区间，自动计算统计摘要
- **分位数计算**：直接提供50%、95%、99%等分位数
- **客户端处理**：在应用程序端直接计算，减少服务器压力
- **内存高效**：使用流式算法，不存储所有原始数据

### 1.2 Summary指标的组成部分


**📋 Summary输出的指标项**
```
# 假设有一个名为 http_request_duration 的 Summary 指标

http_request_duration{quantile="0.5"}  0.05    # 50%的请求在0.05秒内完成
http_request_duration{quantile="0.9"}  0.1     # 90%的请求在0.1秒内完成  
http_request_duration{quantile="0.99"} 0.2     # 99%的请求在0.2秒内完成
http_request_duration_sum               157.3   # 所有请求总耗时
http_request_duration_count             1024    # 总请求次数
```

**💡 每个部分的含义**
- **quantile标签**：分位数值，告诉你有多少比例的数据在这个值以下
- **_sum后缀**：所有观测值的总和
- **_count后缀**：观测值的总数量

### 1.3 Summary的数学原理


**🔢 分位数的通俗解释**
```
考试成绩分位数示例：
假设班级100人考试成绩从低到高排列

50%分位数(中位数) = 第50名的成绩
90%分位数        = 第90名的成绩  
99%分位数        = 第99名的成绩

实际含义：
- 50%分位数是80分 → 一半学生得分在80分以下
- 90%分位数是90分 → 90%学生得分在90分以下
- 99%分位数是95分 → 99%学生得分在95分以下
```

---

## 2. ⚙️ Summary的工作原理


### 2.1 客户端分位数计算


**🔸 计算流程**
```
数据流向：
原始数据 → 客户端应用 → Summary算法 → 分位数结果 → Prometheus

详细过程：
1. 应用程序产生监控数据（如响应时间）
2. Summary在客户端使用流式算法计算
3. 定期输出分位数、总和、计数
4. Prometheus抓取这些预计算结果
```

**💭 为什么在客户端计算**
- **实时性**：不需要等待Prometheus计算，结果立即可用
- **准确性**：基于完整的原始数据计算，不受采样影响
- **资源分配**：计算压力分散到各个客户端，而不是集中在监控服务器

### 2.2 流式算法机制


**🌊 流式处理的优势**
```
传统方式的问题：
存储所有数据 → 占用大量内存 → 定期排序计算 → 资源消耗大

Summary的流式算法：
数据来一个处理一个 → 只保留必要信息 → 实时更新统计 → 内存占用小
```

**⚡ 内存使用对比**
```
场景：监控100万次HTTP请求的响应时间

传统方式：
存储100万个数值 → 约4MB内存（每个4字节）

Summary流式算法：
只保留分位数估算器 → 约几KB内存
压缩比：1000:1
```

### 2.3 分位数估算精度


**📊 精度与性能的平衡**
```
分位数配置示例：
objectives:
  0.5: 0.01    # 50%分位数，误差范围±1%
  0.9: 0.01    # 90%分位数，误差范围±1%
  0.99: 0.001  # 99%分位数，误差范围±0.1%

含义说明：
如果真实的99%分位数是100ms
那么Summary报告的值在99.9ms-100.1ms之间
```

**🎯 精度设置建议**
- **常用分位数**：0.5, 0.9, 0.95, 0.99
- **误差容忍**：一般设置0.01（1%误差）
- **关键分位数**：99%分位数可设置更高精度

---

## 3. ⚖️ Summary与Histogram对比


### 3.1 核心区别分析


| 对比维度 | **Summary** | **Histogram** |
|---------|-------------|---------------|
| **🔢 计算位置** | `客户端预计算分位数` | `服务端根据桶计算分位数` |
| **📊 数据存储** | `分位数+总和+计数` | `各个桶的计数+总和+计数` |
| **⚡ 查询性能** | `直接读取，速度快` | `需要计算，相对较慢` |
| **🎯 精度** | `高精度，基于全量数据` | `精度取决于桶的划分` |
| **📈 灵活性** | `分位数固定，无法改变` | `可计算任意分位数` |
| **💾 网络传输** | `数据量小` | `数据量较大` |

### 3.2 适用场景对比


**🔸 Summary更适合的场景**
```
✅ 分位数需求明确且固定
   示例：只关心95%和99%的响应时间

✅ 对精度要求高
   示例：金融交易延迟监控

✅ 客户端资源充足
   示例：服务器应用，不是嵌入式设备

✅ 网络带宽有限
   示例：跨地域数据传输
```

**🔸 Histogram更适合的场景**
```
✅ 分位数需求可能变化
   示例：开发阶段不确定关注哪些分位数

✅ 需要灵活的聚合计算
   示例：计算多个服务的整体分位数

✅ 客户端资源受限
   示例：移动应用、IoT设备

✅ 需要SLA监控
   示例：计算超过阈值的请求比例
```

### 3.3 实际选择示例


**🌐 Web服务响应时间监控**
```
业务需求：监控API响应时间的95%和99%分位数
数据特点：请求量大，对精度要求高
推荐选择：Summary

理由：
- 分位数需求明确（95%、99%）
- 客户端计算能力充足
- 高精度要求（基于全量数据）
- 减少网络传输开销
```

**📱 移动应用性能监控**
```
业务需求：监控应用启动时间，需要灵活分析
数据特点：客户端资源有限，分析需求可能变化
推荐选择：Histogram

理由：
- 客户端资源有限（手机、平板）
- 分析需求可能随版本变化
- 需要计算不同版本的聚合数据
- 可以根据用户反馈调整监控重点
```

---

## 4. 🎯 Summary的适用场景


### 4.1 理想使用场景


**⚡ 高频率监控场景**
```
典型应用：HTTP API响应时间监控

痛点：
- 每秒处理1000个请求
- 需要实时了解服务性能
- 关心95%用户的体验

Summary解决方案：
✓ 客户端实时计算分位数
✓ 低延迟获取性能指标  
✓ 准确反映用户体验
```

**🔒 精度敏感场景**
```
典型应用：支付系统延迟监控

业务要求：
- 99%的支付在100ms内完成
- 误差不能超过1ms
- 需要基于全量数据统计

Summary优势：
✓ 基于完整数据计算
✓ 可配置高精度要求
✓ 避免采样导致的偏差
```

### 4.2 具体应用示例


**🌐 微服务监控**
```go
// Go语言示例：监控HTTP请求耗时
var (
    httpDuration = prometheus.NewSummaryVec(
        prometheus.SummaryOpts{
            Name: "http_request_duration_seconds",
            Help: "HTTP请求耗时分布",
            Objectives: map[float64]float64{
                0.5:  0.01,  // 50%分位数，1%误差
                0.9:  0.01,  // 90%分位数，1%误差  
                0.99: 0.001, // 99%分位数，0.1%误差
            },
        },
        []string{"method", "endpoint"},
    )
)

// 使用示例
timer := prometheus.NewTimer(httpDuration.WithLabelValues("GET", "/api/users"))
// 处理请求...
timer.ObserveDuration() // 自动记录耗时
```

**📊 数据库查询监控**
```
监控目标：数据库查询响应时间
关键指标：
- 50%分位数：大部分查询的性能
- 95%分位数：性能目标线
- 99%分位数：异常检测线

实际效果：
http_query_duration{quantile="0.5"}  0.002   # 一半查询2ms内完成
http_query_duration{quantile="0.95"} 0.01    # 95%查询10ms内完成
http_query_duration{quantile="0.99"} 0.05    # 99%查询50ms内完成
http_query_duration_sum              45.2    # 总耗时45.2秒
http_query_duration_count            10000   # 总查询次数1万次
```

### 4.3 不适合的场景


**❌ 需要灵活聚合的场景**
```
问题场景：
需要计算多个服务实例的整体分位数

Summary的限制：
- 各实例独立计算分位数
- 无法简单相加得到整体分位数
- 需要原始数据才能准确聚合

解决方案：
使用Histogram代替Summary
```

**❌ 分位数需求不明确的场景**
```
问题场景：
开发阶段，不确定需要关注哪些分位数

Summary的限制：
- 分位数在客户端代码中固定
- 修改需要重新发布应用
- 无法临时调整监控重点

解决方案：
先用Histogram探索，确定需求后再考虑Summary
```

---

## 5. 📈 性能影响与选择建议


### 5.1 性能影响分析


**💾 内存消耗对比**
```
场景：监控100万次操作的耗时数据

Summary内存使用：
- 分位数估算器：约2-5KB（取决于精度设置）
- 总和计数器：8字节
- 标签组合：按实际标签数量计算
总计：通常小于10KB

Histogram内存使用（假设10个桶）：
- 10个桶计数器：80字节
- 总和计数器：8字节  
- 标签组合：按实际标签数量计算
总计：通常小于1KB

结论：Histogram内存效率更高
```

**⚡ CPU消耗对比**
```
Summary CPU开销：
- 每次观测需要更新分位数估算器
- 计算复杂度相对较高
- 适合中等频率的监控

Histogram CPU开销：
- 每次观测只需要找到对应桶并递增
- 计算复杂度很低
- 适合高频监控

建议：
监控频率 > 1万次/秒 → 优先考虑Histogram
监控频率 < 1000次/秒 → Summary和Histogram都可以
```

### 5.2 网络传输效率


**📡 数据传输量对比**
```
Summary输出（3个分位数）：
http_duration{quantile="0.5"}  0.05
http_duration{quantile="0.9"}  0.1  
http_duration{quantile="0.99"} 0.2
http_duration_sum              157.3
http_duration_count            1024
总计：5行数据

Histogram输出（10个桶）：
http_duration_bucket{le="0.01"} 100
http_duration_bucket{le="0.02"} 200
...（8个桶）...
http_duration_bucket{le="+Inf"} 1024
http_duration_sum               157.3
http_duration_count             1024
总计：12行数据

结论：Summary传输效率更高
```

### 5.3 选择决策树


**🎯 选择流程图**
```
开始选择
    ↓
分位数需求明确且固定？
    ↓ 是           ↓ 否
对精度要求高？    选择Histogram
    ↓ 是    ↓ 否
客户端资源充足？  考虑Histogram
    ↓ 是    ↓ 否
选择Summary   选择Histogram
```

**📋 详细选择建议**

> **🚀 优先选择Summary的情况**
> - 分位数需求明确（如固定关注95%、99%）
> - 对精度要求很高（金融、支付等场景）
> - 客户端有充足的计算资源
> - 网络带宽有限制
> - 监控频率适中（1000次/秒以下）

> **⚠️ 优先选择Histogram的情况**
> - 分位数需求可能变化
> - 需要灵活的聚合计算
> - 客户端资源受限
> - 监控频率很高（1万次/秒以上）
> - 需要SLA监控（计算超时比例）

> **💡 实践建议**
> - 新项目建议先用Histogram探索需求
> - 生产环境稳定后可考虑迁移到Summary
> - 同一系统可以混合使用两种类型
> - 定期评估和调整监控策略

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 Summary本质：客户端预计算分位数的监控指标类型
🔸 核心优势：高精度、低传输量、实时性好
🔸 主要限制：分位数固定、难以聚合、客户端开销大
🔸 输出格式：分位数标签 + _sum + _count
🔸 适用场景：分位数需求明确且对精度要求高的监控
```

### 6.2 关键理解要点


**🔹 Summary vs Histogram的本质区别**
```
Summary = 预计算的便利性 + 高精度
Histogram = 灵活性 + 低开销

选择原则：
- 明确且稳定的需求 → Summary
- 灵活且变化的需求 → Histogram
```

**🔹 分位数的实际意义**
```
分位数不是平均值：
- 平均值会被极值影响
- 分位数直接反映用户体验
- 95%分位数 = 95%用户的实际体验
```

**🔹 性能权衡考虑**
```
Summary的代价：
- 客户端CPU和内存开销
- 分位数配置的固化
- 聚合计算的复杂性

Summary的收益：
- 高精度的分位数计算
- 减少网络传输开销
- 实时的监控反馈
```

### 6.3 实际应用指导


**🎯 使用建议**
- **开发阶段**：用Histogram探索监控需求
- **生产阶段**：根据稳定需求选择Summary
- **高频场景**：优先考虑Histogram
- **精度要求**：选择Summary并合理设置误差范围

**⚠️ 常见误区**
- 不要把Summary当作万能解决方案
- 不要在客户端资源受限时强行使用Summary
- 不要尝试对Summary结果进行简单的数学聚合
- 不要忽视Summary对应用程序性能的影响

**🔧 最佳实践**
- 合理设置分位数和精度要求
- 监控Summary自身的资源消耗
- 定期评估监控策略的有效性
- 文档化分位数选择的业务逻辑

**核心记忆**：
- Summary是预计算的分位数统计工具
- 在客户端计算，传输摘要结果
- 精度高但灵活性差，适合明确固定的需求
- 选择时要权衡精度、性能和灵活性