---
title: 3、Gauge仪表盘指标
---
## 📚 目录

1. [Gauge指标基础概念](#1-Gauge指标基础概念)
2. [Gauge的核心特性](#2-Gauge的核心特性)
3. [瞬时值监控原理](#3-瞬时值监控原理)
4. [增减操作方法详解](#4-增减操作方法详解)
5. [常见应用场景](#5-常见应用场景)
6. [与Counter指标的关键区别](#6-与Counter指标的关键区别)
7. [最佳实践与使用建议](#7-最佳实践与使用建议)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 Gauge指标基础概念


### 1.1 什么是Gauge指标


**简单理解**：Gauge就像汽车的**仪表盘**，显示当前状态的实时数值

> 💡 **通俗解释**：想象你在看汽车仪表盘上的油表、水温表，它们显示的是**当前这一刻**的真实状态，这就是Gauge指标的本质

```
现实生活中的Gauge：
🌡️ 温度计 → 显示当前温度
⛽ 油表   → 显示当前油量
📊 股价   → 显示当前价格
💾 内存   → 显示当前使用量
```

### 1.2 Gauge在监控中的作用


**核心作用**：监控**可变化的瞬时值**，这些值可以增加、减少，或保持不变

```
监控系统中的Gauge应用：
📈 CPU使用率     → 0%-100%之间波动
💿 磁盘使用量     → 随文件增删变化  
🌐 在线用户数     → 用户登录登出影响
🔧 活跃连接数     → 连接建立断开影响
```

### 1.3 Gauge指标的数学特性


**关键特征**：
- **可增可减**：数值可以上升或下降
- **瞬时快照**：反映采集时刻的真实状态
- **无累积性**：不是累加值，而是当前值

```
Gauge值变化示例：
时间轴: 10:00  10:01  10:02  10:03  10:04
CPU使用率: 30%   →  45%   →  20%   →  60%   →  35%
          ↑      ↑      ↓      ↑      ↓
        可增可减，反映真实状态变化
```

---

## 2. ⚙️ Gauge的核心特性


### 2.1 瞬时性特征


**瞬时性含义**：Gauge反映的是**采集那一刻的准确状态**

```
瞬时性对比理解：
❌ 错误理解：过去一段时间的总和
✅ 正确理解：此时此刻的精确数值

例如内存使用量：
- 不是"今天总共用了多少内存"
- 而是"现在正在使用多少内存"
```

### 2.2 可变性特征


**可变性含义**：同一个指标的值可以**自由增减变化**

| 时间点 | **内存使用量** | **变化趋势** | **说明** |
|--------|---------------|-------------|---------|
| `09:00` | `2.5GB` | `基准值` | `系统启动后的内存状态` |
| `09:30` | `4.2GB` | `↗️ 增加` | `启动了更多应用程序` |
| `10:00` | `3.8GB` | `↘️ 减少` | `关闭了部分程序` |
| `10:30` | `5.1GB` | `↗️ 增加` | `运行大型数据处理任务` |
| `11:00` | `2.9GB` | `↘️ 减少` | `任务完成，释放内存` |

### 2.3 状态反映特征


**状态反映**：Gauge直接反映**系统或业务的当前状态**

```
不同类型的状态反映：

🖥️ 系统资源状态：
- CPU利用率：当前处理器繁忙程度
- 内存使用率：当前内存占用情况
- 磁盘空间：当前可用存储空间

👥 业务运行状态：
- 在线用户数：当前登录的用户数量
- 订单队列长度：当前待处理订单数
- 数据库连接数：当前活跃的数据库连接
```

---

## 3. 📊 瞬时值监控原理


### 3.1 采集机制原理


**采集原理**：Prometheus定期**抓取**目标系统的当前状态值

```
采集流程图示：
监控目标 ←--[定期抓取]--← Prometheus服务器
    |                        |
    |                        |
当前状态值               存储时序数据
(瞬时快照)                (带时间戳)

时间轴示例：
10:00:00 → CPU: 25%
10:00:15 → CPU: 30%  
10:00:30 → CPU: 28%
10:00:45 → CPU: 35%
```

### 3.2 时序存储机制


**存储原理**：每次采集的瞬时值都会**加上时间戳**形成时序数据

```
时序数据结构：
指标名称{标签} 数值 时间戳

实际存储示例：
memory_usage{instance="server01"} 2.5 1640995200000
memory_usage{instance="server01"} 4.2 1640995215000  
memory_usage{instance="server01"} 3.8 1640995230000

解读：
- memory_usage：指标名称
- {instance="server01"}：标签标识具体服务器
- 2.5, 4.2, 3.8：不同时刻的内存使用量(GB)
- 时间戳：记录采集的具体时间
```

### 3.3 查询与展示原理


**查询机制**：可以查询**任意时刻**的瞬时值或**时间范围**内的变化趋势

> 🎯 **核心理解**：Gauge让我们能够"回到过去"查看任意时刻的系统状态

```
查询示例说明：

1️⃣ 查询当前瞬时值：
memory_usage{instance="server01"}
→ 返回：最新采集的内存使用量

2️⃣ 查询历史瞬时值：
memory_usage{instance="server01"}[1h]  
→ 返回：过去1小时内所有采集点的数值

3️⃣ 查询特定时刻：
memory_usage{instance="server01"} @ 1640995200
→ 返回：指定时间戳的内存使用量
```

---

## 4. 🔧 增减操作方法详解


### 4.1 基本操作方式


**操作特点**：Gauge支持**直接设置值**、**增加值**、**减少值**三种操作

```go
// Go语言中的Gauge操作示例
import "github.com/prometheus/client_golang/prometheus"

// 创建Gauge指标
var memoryUsage = prometheus.NewGauge(prometheus.GaugeOpts{
    Name: "memory_usage_bytes",
    Help: "当前内存使用量",
})

// 三种基本操作：
memoryUsage.Set(2500000000)    // 直接设置为2.5GB
memoryUsage.Add(500000000)     // 增加500MB  
memoryUsage.Sub(200000000)     // 减少200MB
```

### 4.2 直接设置值（Set）


**使用场景**：当你知道**准确的当前值**时使用

```
Set操作的典型应用：

📊 定期采集系统指标：
- 每15秒读取一次CPU使用率
- 每30秒读取一次内存使用量
- 每分钟读取一次磁盘使用情况

💡 代码逻辑示例：
func updateSystemMetrics() {
    // 获取当前CPU使用率
    cpuPercent := getCurrentCPUUsage()
    cpuGauge.Set(cpuPercent)
    
    // 获取当前内存使用量
    memBytes := getCurrentMemoryUsage()
    memoryGauge.Set(float64(memBytes))
}
```

### 4.3 增加值（Add）


**使用场景**：当某个**事件发生**导致数值增加时使用

```
Add操作的典型应用：

👥 用户登录事件：
func onUserLogin() {
    onlineUserGauge.Add(1)  // 在线用户数+1
}

📦 任务队列增加：
func addTaskToQueue() {
    queueLengthGauge.Add(1)  // 队列长度+1
}

🔗 新连接建立：
func onNewConnection() {
    activeConnectionsGauge.Add(1)  // 活跃连接数+1
}
```

### 4.4 减少值（Sub）


**使用场景**：当某个**事件结束**导致数值减少时使用

```
Sub操作的典型应用：

👋 用户登出事件：
func onUserLogout() {
    onlineUserGauge.Sub(1)  // 在线用户数-1
}

✅ 任务完成处理：
func onTaskCompleted() {
    queueLengthGauge.Sub(1)  // 队列长度-1
}

🔌 连接断开：
func onConnectionClosed() {
    activeConnectionsGauge.Sub(1)  // 活跃连接数-1
}
```

### 4.5 操作的原子性保证


> ⚠️ **重要提醒**：Gauge的操作是**原子性**的，多个goroutine同时操作是安全的

```
并发安全示例：
// 多个goroutine同时操作同一个Gauge是安全的
go func() {
    for {
        onlineUserGauge.Add(1)  // 用户登录
        time.Sleep(time.Second)
    }
}()

go func() {
    for {
        onlineUserGauge.Sub(1)  // 用户登出
        time.Sleep(time.Second * 2)
    }
}()
```

---

## 5. 🎯 常见应用场景


### 5.1 系统资源监控


**CPU使用率监控**
```
指标含义：当前CPU的繁忙程度百分比
实际应用：
- 负载均衡决策依据
- 自动扩缩容触发条件
- 性能问题排查指标

配置示例：
# CPU使用率超过80%告警
cpu_usage_percent > 80
```

**内存使用监控**
```
指标含义：当前内存的占用情况
监控维度：
- 总内存使用量 (字节)
- 内存使用率 (百分比)  
- 可用内存量 (字节)

告警策略：
# 可用内存少于1GB时告警
available_memory_bytes < 1073741824
```

**磁盘空间监控**
```
指标含义：当前磁盘的使用情况
关键指标：
- 磁盘使用率
- 剩余空间大小
- inode使用率

实用查询：
# 磁盘使用率超过85%的服务器
disk_usage_percent{mountpoint="/"} > 85
```

### 5.2 应用性能监控


**数据库连接池监控**

| 指标名称 | **含义** | **正常范围** | **告警阈值** |
|---------|---------|-------------|-------------|
| `active_connections` | `当前活跃连接数` | `10-50` | `> 80` |
| `idle_connections` | `空闲连接数` | `5-20` | `< 2` |
| `max_connections` | `最大连接数限制` | `100` | `固定值` |
| `connection_usage_rate` | `连接使用率` | `10%-60%` | `> 90%` |

**缓存命中率监控**
```
指标含义：缓存系统的效率指标
计算公式：命中率 = 命中次数 / (命中次数 + 未命中次数) * 100%

监控价值：
✅ 高命中率(>90%)：缓存配置合理
⚠️ 中命中率(70%-90%)：需要优化缓存策略
🚨 低命中率(<70%)：缓存几乎无效，需要重新设计
```

### 5.3 业务指标监控


**在线用户数监控**
```
业务价值：
- 了解系统实时负载
- 验证营销活动效果
- 容量规划参考依据

实现方式：
用户登录 → onlineUsers.Add(1)
用户登出 → onlineUsers.Sub(1)  
会话超时 → onlineUsers.Sub(1)
```

**订单处理队列监控**
```
业务含义：当前待处理的订单数量
监控意义：
- 队列长度过长：处理能力不足
- 队列为空：系统空闲或订单缺失
- 队列波动大：业务负载不稳定

告警设置：
# 队列积压超过1000个订单
order_queue_length > 1000
```

### 5.4 网络与服务监控


**API响应时间监控**
```
指标说明：API接口的响应延迟
监控维度：
- 平均响应时间
- 95%分位响应时间  
- 99%分位响应时间

性能标准：
🟢 优秀: < 100ms
🟡 良好: 100ms - 500ms  
🟠 一般: 500ms - 1s
🔴 较差: > 1s
```

**TCP连接状态监控**
```
连接状态分类：
- ESTABLISHED: 已建立的连接
- LISTEN: 监听状态的端口
- TIME_WAIT: 等待关闭的连接
- CLOSE_WAIT: 等待关闭的连接

异常识别：
# TIME_WAIT连接过多可能表示连接没有正确复用
tcp_connections{state="TIME_WAIT"} > 1000
```

---

## 6. 🔄 与Counter指标的关键区别


### 6.1 核心概念对比


```
生活化对比理解：

Counter (计数器) = 汽车里程表
🚗 特点：只能增加，永不减少
📈 用途：记录"总共发生了多少次"

Gauge (仪表盘) = 汽车速度表  
🎯 特点：可增可减，反映当前状态
📊 用途：显示"现在是什么状态"
```

### 6.2 详细特性对比


| 特性维度 | **Counter** | **Gauge** |
|---------|------------|-----------|
| **数值变化** | `只能递增(或重置为0)` | `可增可减可不变` |
| **业务含义** | `累积计数/统计总量` | `瞬时状态/当前数值` |
| **重启影响** | `重置为0，需要计算增长率` | `重新采集当前值，无影响` |
| **查询方式** | `通常使用rate()函数` | `直接查询原始值` |
| **典型应用** | `HTTP请求总数、错误总数` | `CPU使用率、内存使用量` |

### 6.3 使用场景区分


**Counter适用场景（累积性指标）**
```
📊 网站访问统计：
http_requests_total{path="/api/users"} 

🚨 错误计数统计：
error_count_total{type="database_error"}

💰 销售额统计：
sales_total_amount{product="laptop"}

特点：这些指标关心的是"总共有多少"
```

**Gauge适用场景（状态性指标）**
```
🖥️ 系统状态监控：
cpu_usage_percent{instance="server01"}

👥 实时用户数：
online_users{service="web_app"}

📦 队列长度：
task_queue_length{queue="email_sending"}

特点：这些指标关心的是"现在是多少"
```

### 6.4 查询语法差异


**Counter查询模式**
```
# Counter通常需要计算变化率
rate(http_requests_total[5m])  # 每秒请求增长率
increase(http_requests_total[1h])  # 1小时内请求增量

原因：Counter的原始值（累积总数）通常意义不大
有意义的是：增长速度和时间段内的增量
```

**Gauge查询模式**
```
# Gauge直接查询原始值就很有意义
cpu_usage_percent  # 当前CPU使用率
avg_over_time(cpu_usage_percent[1h])  # 1小时平均CPU使用率

原因：Gauge的当前值直接反映系统状态
有意义的是：当前值、平均值、最大值、最小值
```

### 6.5 选择指标类型的决策树


```
选择指标类型的思考流程：

🤔 这个指标反映的是什么？
    |
    ├─ 累积性的总量（如：总访问次数）
    │   └─ 选择 Counter
    │
    └─ 当前的状态（如：当前用户数）
        └─ 选择 Gauge

🤔 这个数值会减少吗？
    |
    ├─ 不会减少（只增不减）
    │   └─ 选择 Counter  
    │
    └─ 会增减变化
        └─ 选择 Gauge

🤔 重启后这个指标怎么处理？
    |
    ├─ 重置为0，重新开始计数
    │   └─ 选择 Counter
    │
    └─ 重新采集当前真实值
        └─ 选择 Gauge
```

---

## 7. 🎯 最佳实践与使用建议


### 7.1 命名规范建议


**Gauge指标命名规范**
```
基本格式：[namespace_]<metric_name>[_unit]

✅ 推荐命名：
memory_usage_bytes        # 内存使用量（字节）
cpu_usage_percent         # CPU使用率（百分比）
disk_free_space_bytes     # 磁盘可用空间（字节）
active_connections_count  # 活跃连接数（个数）

❌ 不推荐命名：
mem                      # 太简略，不清楚含义
cpu                      # 没有说明是什么维度的CPU指标  
disk_space               # 没有说明是已用还是可用
connections              # 没有说明是什么类型的连接
```

**单位标识建议**
```
常用单位后缀：
- _bytes：字节数
- _percent：百分比
- _count：计数
- _seconds：秒数
- _ratio：比率（0-1之间）

示例应用：
database_size_bytes{db="users"}
response_time_seconds{endpoint="/api/login"}  
cache_hit_ratio{cache="redis"}
```

### 7.2 标签设计原则


**合理使用标签**
```go
✅ 好的标签设计：
memory_usage_bytes{
    instance="server01",     # 实例标识
    component="application", # 组件类型
    env="production"        # 环境标识
}

❌ 避免的标签设计：
memory_usage_bytes{
    instance="server01",
    timestamp="1640995200",  # ❌ 时间戳不应该作为标签
    value="high"            # ❌ 数值的描述不应该作为标签
}
```

**标签基数控制**
> ⚠️ **重要警告**：标签组合的基数（唯一组合数量）不要过高，否则会导致存储和查询性能问题

```
基数计算示例：
指标：http_requests{method, status, endpoint}

假设取值：
- method: GET, POST, PUT, DELETE (4个值)
- status: 200, 404, 500 (3个值)  
- endpoint: 如果有1000个不同的API端点

总基数 = 4 × 3 × 1000 = 12,000个时序

建议：将endpoint标签改为endpoint_type来降低基数
```

### 7.3 采集频率设置


**不同类型指标的采集频率建议**

| 指标类型 | **建议采集间隔** | **理由说明** |
|---------|-----------------|-------------|
| `系统资源` | `15-30秒` | `变化相对较快，需要及时发现问题` |
| `应用性能` | `30-60秒` | `变化适中，过于频繁采集意义不大` |
| `业务指标` | `1-5分钟` | `变化相对较慢，关注趋势即可` |
| `网络状态` | `30秒` | `网络状况变化较快` |

**采集频率权衡考虑**
```
🚀 高频率采集的好处：
- 能更快发现问题
- 数据精度更高
- 短期异常不会被遗漏

⚠️ 高频率采集的代价：
- 增加存储成本
- 增加网络开销  
- 增加目标系统负载

💡 最佳实践：
根据指标的重要性和变化频率来设置合适的采集间隔
```

### 7.4 告警规则设计


**阈值设置原则**
```yaml
# CPU使用率告警规则示例
groups:
- name: system_alerts
  rules:
  - alert: HighCPUUsage
    expr: cpu_usage_percent > 80
    for: 5m  # 持续5分钟才触发告警，避免短期波动
    labels:
      severity: warning
    annotations:
      summary: "CPU使用率过高"
      description: "{{ $labels.instance }} CPU使用率为 {{ $value }}%"
```

**多级告警策略**
```
🟡 警告级别 (Warning)：
- CPU使用率 > 70%
- 内存使用率 > 80%
- 磁盘使用率 > 80%

🟠 紧急级别 (Critical)：
- CPU使用率 > 90%
- 内存使用率 > 95%
- 磁盘使用率 > 95%

🔴 灾难级别 (Disaster)：
- CPU使用率 > 98%
- 可用内存 < 100MB
- 磁盘剩余空间 < 1GB
```

### 7.5 性能优化建议


**减少指标基数**
```
优化前：
http_response_time{method, status, endpoint, user_id}
# user_id会导致极高的基数

优化后：  
http_response_time{method, status, endpoint_category}
# 将具体endpoint归类为category，大幅降低基数
```

**合理聚合数据**
```
# 使用recording rule预聚合常用查询
groups:
- name: node_exporter_rules
  interval: 30s
  rules:
  - record: instance:cpu_usage:rate5m
    expr: 100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) by (instance) * 100)
```

**存储优化**
```
# 设置合理的retention时间
prometheus_config:
  global:
    retention_time: 15d  # 保留15天数据
    retention_size: 50GB # 限制存储大小
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Gauge本质：反映当前状态的瞬时值，就像汽车仪表盘
🔸 核心特性：可增可减可不变，直接反映真实状态
🔸 与Counter区别：Counter累积计数，Gauge当前状态
🔸 操作方法：Set(设置)、Add(增加)、Sub(减少)
🔸 应用场景：系统资源、应用性能、业务状态监控
```

### 8.2 关键理解要点


**🔹 何时选择Gauge**
```
判断标准：
✅ 如果关心"现在是什么状态" → 选择Gauge
❌ 如果关心"总共发生了多少次" → 选择Counter

实例对比：
- 当前在线用户数 → Gauge（状态）
- 累计注册用户数 → Counter（累积）
- 当前内存使用量 → Gauge（状态）  
- 总处理请求数 → Counter（累积）
```

**🔹 瞬时值的含义**
```
深入理解：
- 瞬时值不是平均值，是采集时刻的精确状态
- 每次采集都是一个独立的快照
- 连续的瞬时值组成了状态变化的时序图
```

**🔹 操作的原子性**
```
并发安全：
- Gauge的所有操作都是线程安全的
- 多个goroutine可以同时操作同一个Gauge
- 不需要额外的锁机制
```

### 8.3 实际应用指导


**选择指标类型的快速决策**
```
问自己三个问题：
1. 这个值会减少吗？会 → Gauge，不会 → Counter
2. 我关心当前值还是累积值？当前 → Gauge，累积 → Counter  
3. 系统重启后怎么处理？重新采集 → Gauge，重新计数 → Counter
```

**常见应用模式**
```
🖥️ 系统监控：CPU、内存、磁盘 → 用Set定期更新
👥 用户状态：登录+1，登出-1 → 用Add/Sub事件驱动
📊 业务指标：订单队列、连接池 → 结合业务逻辑更新
⚡ 性能指标：响应时间、吞吐量 → 定期采集设置
```

**避免常见误区**
```
❌ 误区1：把累积性指标当作Gauge
❌ 误区2：Gauge标签基数过高
❌ 误区3：采集频率设置不当
❌ 误区4：告警阈值设置不合理
❌ 误区5：指标命名不规范
```

### 8.4 学习进阶路径


**下一步学习建议**
- 学习Histogram和Summary指标类型
- 掌握PromQL查询语言
- 了解Grafana可视化展示
- 学习告警规则编写
- 实践指标设计模式

**核心记忆**：
- Gauge像仪表盘，显示当前状态瞬时值
- 可增可减可不变，直接反映真实情况
- 系统资源用Set更新，业务事件用Add/Sub
- 合理设计标签，控制基数，优化性能