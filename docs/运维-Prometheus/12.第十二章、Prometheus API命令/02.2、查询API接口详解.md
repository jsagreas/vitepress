---
title: 2、查询API接口详解
---
## 📚 目录

1. [API基础概念与作用](#1-API基础概念与作用)
2. [瞬时查询接口详解](#2-瞬时查询接口详解)
3. [范围查询接口详解](#3-范围查询接口详解)
4. [查询参数详细说明](#4-查询参数详细说明)
5. [响应数据结构解析](#5-响应数据结构解析)
6. [查询优化与最佳实践](#6-查询优化与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌐 API基础概念与作用


### 1.1 什么是Prometheus API


**通俗理解**：想象Prometheus就像一个智能的数据库管家，而API就是我们和这个管家交流的"对话接口"。

```
生活类比：
就像你问智能音箱 → "今天天气怎么样？"
Prometheus API → "现在CPU使用率是多少？"

都是通过标准化的问答方式获取信息
```

**🔸 核心作用**
- **数据查询**：从Prometheus中获取监控数据
- **实时获取**：支持当前时刻和历史时间段的数据
- **标准接口**：RESTful API，所有编程语言都能调用
- **灵活查询**：支持复杂的查询条件和数据处理

### 1.2 API的基本工作流程


```
用户/程序 → HTTP请求 → Prometheus API → 查询引擎 → 时序数据库 → 返回结果

实际例子：
浏览器访问：http://localhost:9090/api/v1/query?query=up
↓
Prometheus接收请求，解析查询条件
↓
在数据库中查找所有"up"指标的当前值
↓
返回JSON格式的结果给浏览器
```

### 1.3 API的两大核心接口


| 接口类型 | **用途说明** | **生活类比** |
|---------|-------------|-------------|
| **瞬时查询** | `获取某个时刻的数据快照` | `问现在几点了` |
| **范围查询** | `获取一段时间内的数据变化` | `问这周的天气变化` |

---

## 2. ⚡ 瞬时查询接口详解


### 2.1 接口基本信息


**🔸 接口地址**：`/api/v1/query`
**🔸 请求方法**：`GET` 或 `POST`
**🔸 核心作用**：获取指定时刻的监控数据

```
通俗解释：
瞬时查询就像拍照，咔嚓一下，记录当前这一瞬间的状态
比如：现在CPU使用率是85%，内存使用了4.2GB
```

### 2.2 基本使用示例


```bash
# 最简单的查询 - 获取当前所有服务的运行状态
curl "http://localhost:9090/api/v1/query?query=up"

# 查询特定服务的CPU使用率
curl "http://localhost:9090/api/v1/query?query=cpu_usage_percent"

# 查询指定时间点的数据
curl "http://localhost:9090/api/v1/query?query=up&time=1695369600"
```

### 2.3 关键参数详解


**📋 必需参数**

**`query`** - 查询表达式
```
作用：告诉Prometheus你要查什么数据
类比：就像在搜索引擎里输入关键词

示例：
query=up                    # 查询所有服务状态
query=cpu_usage_percent     # 查询CPU使用率
query=memory_used_bytes     # 查询内存使用量
```

**📋 可选参数**

**`time`** - 指定查询时间点
```
作用：查询某个历史时刻的数据，不指定就是查询当前时刻
格式：Unix时间戳（秒）或 RFC3339格式

示例：
time=1695369600                    # Unix时间戳
time=2023-09-22T10:00:00Z         # RFC3339格式
```

**`timeout`** - 查询超时时间
```
作用：设置查询的最长等待时间，避免查询卡死
默认：通常为30秒
格式：时间字符串

示例：
timeout=30s     # 30秒超时
timeout=2m      # 2分钟超时
```

### 2.4 实际应用场景


**🎯 常见使用场景**

```
✅ 服务健康检查
GET /api/v1/query?query=up{job="web-server"}
→ 检查web服务器是否在线

✅ 实时性能监控
GET /api/v1/query?query=cpu_usage_percent{instance="server-01"}
→ 查看server-01的当前CPU使用率

✅ 告警状态查询
GET /api/v1/query?query=alertmanager_alerts{state="firing"}
→ 查看当前正在触发的告警

✅ 资源使用情况
GET /api/v1/query?query=node_memory_MemAvailable_bytes
→ 查看服务器可用内存
```

---

## 3. 📊 范围查询接口详解


### 3.1 接口基本信息


**🔸 接口地址**：`/api/v1/query_range`
**🔸 请求方法**：`GET` 或 `POST`
**🔸 核心作用**：获取一段时间内的数据变化趋势

```
通俗解释：
范围查询就像拍摄视频，记录一段时间内数据的变化过程
比如：查看过去1小时CPU使用率的变化曲线
```

### 3.2 基本使用示例


```bash
# 查询过去1小时的CPU使用率变化
curl "http://localhost:9090/api/v1/query_range?query=cpu_usage_percent&start=2023-09-22T09:00:00Z&end=2023-09-22T10:00:00Z&step=30s"

# 查询最近24小时的内存使用趋势
curl "http://localhost:9090/api/v1/query_range?query=memory_used_bytes&start=2023-09-21T10:00:00Z&end=2023-09-22T10:00:00Z&step=5m"
```

### 3.3 关键参数详解


**📋 必需参数**

**`query`** - 查询表达式（同瞬时查询）

**`start`** - 开始时间
```
作用：指定查询时间范围的起点
格式：Unix时间戳或RFC3339格式

示例：
start=1695369600              # Unix时间戳
start=2023-09-22T09:00:00Z   # RFC3339格式
```

**`end`** - 结束时间
```
作用：指定查询时间范围的终点
格式：同start参数

示例：
end=1695373200              # Unix时间戳
end=2023-09-22T10:00:00Z   # RFC3339格式
```

**`step`** - 采样步长
```
作用：指定数据点之间的时间间隔
类比：就像设置视频的帧率，step越小数据越详细

示例：
step=30s    # 每30秒一个数据点
step=1m     # 每1分钟一个数据点
step=5m     # 每5分钟一个数据点
```

**📋 可选参数**

**`timeout`** - 查询超时时间（同瞬时查询）

### 3.4 step参数的重要性


```
step参数选择指导：

短期监控（几分钟到几小时）：
step=15s 或 30s → 精细监控，适合故障排查

中期监控（几小时到1天）：
step=1m 或 5m → 平衡详细度和性能

长期监控（几天到几周）：
step=1h 或更大 → 趋势分析，减少数据量

实际影响：
查询1小时数据，step=30s → 120个数据点
查询1小时数据，step=5m  → 12个数据点
```

### 3.5 时间范围选择最佳实践


**⏰ 合理的时间范围规划**

```
实时监控界面：
时间范围：最近15分钟到1小时
step：15s-1m
目的：快速发现问题

故障排查分析：
时间范围：故障前后几小时
step：30s-2m
目的：详细分析问题原因

趋势分析报告：
时间范围：几天到几周
step：1h-1d
目的：了解长期趋势

容量规划：
时间范围：几个月
step：1d或更大
目的：预测资源需求
```

---

## 4. 🔧 查询参数详细说明


### 4.1 时间参数格式标准


**📅 支持的时间格式**

| 格式类型 | **示例** | **说明** | **适用场景** |
|---------|---------|---------|-------------|
| **Unix时间戳** | `1695369600` | `秒级时间戳` | `程序调用` |
| **RFC3339** | `2023-09-22T10:00:00Z` | `标准时间格式` | `人工调试` |
| **相对时间** | `now-1h` | `相对当前时间` | `动态查询` |

**🕐 相对时间表达式**
```
now        # 当前时间
now-1h     # 1小时前
now-1d     # 1天前
now-1w     # 1周前
now-30m    # 30分钟前

实际使用：
start=now-2h&end=now-1h    # 查询1小时前到2小时前的数据
start=now-1d&end=now       # 查询最近24小时的数据
```

### 4.2 timeout参数配置建议


**⏱️ 超时时间设置指导**

```
查询复杂度评估：

简单查询（单个指标）：
timeout=10s-30s
示例：query=up

中等复杂查询（聚合计算）：
timeout=30s-60s
示例：query=sum(cpu_usage_percent) by (instance)

复杂查询（多表join、长时间范围）：
timeout=60s-300s
示例：查询一周的数据并进行复杂计算

注意事项：
- 超时时间太短：查询可能失败
- 超时时间太长：影响用户体验
- 建议根据实际环境测试确定合适值
```

### 4.3 查询表达式类型


**📝 常见查询表达式分类**

```
基础指标查询：
up                           # 服务存活状态
cpu_usage_percent           # CPU使用率
memory_used_bytes          # 内存使用量

标签过滤查询：
up{job="prometheus"}        # 特定job的存活状态
cpu_usage_percent{instance="server-01"}  # 特定服务器的CPU

聚合计算查询：
sum(cpu_usage_percent)      # 所有服务器CPU使用率总和
avg(memory_used_bytes)      # 平均内存使用量
max(disk_usage_percent)     # 最大磁盘使用率

时间函数查询：
rate(http_requests_total[5m])        # 5分钟内的请求速率
increase(errors_total[1h])           # 1小时内错误数增长
```

---

## 5. 📦 响应数据结构解析


### 5.1 标准响应格式


**🔸 HTTP响应结构**
```json
{
  "status": "success",
  "data": {
    "resultType": "vector",
    "result": [...]
  }
}
```

**字段含义说明**：
- **`status`**：请求状态，`success`表示成功，`error`表示失败
- **`data`**：实际数据内容
- **`resultType`**：结果类型，决定了数据的组织方式

### 5.2 resultType结果类型详解


**📊 两种主要结果类型**

| 结果类型 | **瞬时查询** | **范围查询** | **数据特点** |
|---------|-------------|-------------|-------------|
| **vector** | `✅ 常见` | `❌ 不适用` | `当前时刻的多个数据点` |
| **matrix** | `❌ 不适用` | `✅ 常见` | `时间序列数据矩阵` |

### 5.3 vector类型数据结构


**瞬时查询的典型返回格式**：
```json
{
  "status": "success",
  "data": {
    "resultType": "vector",
    "result": [
      {
        "metric": {
          "instance": "localhost:9090",
          "job": "prometheus"
        },
        "value": [1695369600, "1"]
      },
      {
        "metric": {
          "instance": "localhost:8080",
          "job": "web-server"
        },
        "value": [1695369600, "0.85"]
      }
    ]
  }
}
```

**🔍 数据结构解析**：
```
metric: 指标的标签信息（类似数据的"身份证"）
  ├─ instance: 数据来源实例
  ├─ job: 监控作业名称
  └─ 其他自定义标签...

value: [时间戳, 数值]
  ├─ 第一个元素：Unix时间戳
  └─ 第二个元素：指标数值（字符串格式）
```

### 5.4 matrix类型数据结构


**范围查询的典型返回格式**：
```json
{
  "status": "success",
  "data": {
    "resultType": "matrix",
    "result": [
      {
        "metric": {
          "instance": "localhost:9090",
          "job": "prometheus"
        },
        "values": [
          [1695369600, "0.85"],
          [1695369630, "0.87"],
          [1695369660, "0.82"]
        ]
      }
    ]
  }
}
```

**🔍 数据结构解析**：
```
values: 时间序列数据点数组
  ├─ [时间戳1, 数值1]
  ├─ [时间戳2, 数值2]
  ├─ [时间戳3, 数值3]
  └─ ...

每个时间点的数据按时间顺序排列
数值以字符串形式返回，需要转换为数字使用
```

### 5.5 错误响应处理


**❌ 错误响应格式**：
```json
{
  "status": "error",
  "errorType": "bad_data",
  "error": "invalid parameter 'query': parse error at char 5: unexpected character: '!'"
}
```

**常见错误类型**：
```
bad_data: 查询语法错误或参数错误
timeout: 查询超时
execution: 查询执行过程中出错
internal: 服务器内部错误

处理建议：
1. 检查查询语法是否正确
2. 验证时间参数格式
3. 适当增加timeout时间
4. 简化复杂查询
```

---

## 6. 🚀 查询优化与最佳实践


### 6.1 查询性能优化策略


**⚡ 性能优化核心原则**

```
原则1：合理设置时间范围
❌ 避免：查询过长时间范围（如几个月的详细数据）
✅ 推荐：根据实际需求选择合适的时间窗口

原则2：适当调整step步长
❌ 避免：step过小导致数据点过多
✅ 推荐：平衡数据精度和查询性能

原则3：使用标签过滤
❌ 避免：查询所有实例的数据再过滤
✅ 推荐：在查询中直接指定标签条件
```

**📈 具体优化技巧**

```bash
# 不推荐：查询所有数据再筛选
curl "http://localhost:9090/api/v1/query?query=cpu_usage_percent"

# 推荐：直接在查询中指定条件
curl "http://localhost:9090/api/v1/query?query=cpu_usage_percent{instance='server-01'}"

# 不推荐：step过小的长时间查询
curl "http://localhost:9090/api/v1/query_range?query=cpu_usage_percent&start=now-7d&end=now&step=15s"

# 推荐：合理的step设置
curl "http://localhost:9090/api/v1/query_range?query=cpu_usage_percent&start=now-7d&end=now&step=1h"
```

### 6.2 并发查询控制


**🔀 并发查询最佳实践**

```
并发限制建议：
- 单个客户端：同时不超过10个查询
- 所有客户端：根据Prometheus服务器性能调整
- 查询队列：避免查询堆积

实现方式：
1. 客户端实现连接池限制
2. 设置合理的timeout时间
3. 实现查询重试机制
4. 监控查询响应时间
```

### 6.3 分页查询处理


**📄 大数据量查询分页策略**

由于Prometheus API不直接支持分页，处理大量数据时可以采用以下策略：

```
时间分片策略：
将长时间范围分割为多个较短的时间段

# 示例：查询7天数据，分成7个1天的查询
for day in range(7):
    start_time = now - (day + 1) * 24 * 3600
    end_time = now - day * 24 * 3600
    query_data(start_time, end_time)

标签分片策略：
对于多实例查询，可以按实例分别查询

# 示例：分别查询每个服务器的数据
instances = ["server-01", "server-02", "server-03"]
for instance in instances:
    query = f"cpu_usage_percent{{instance='{instance}'}}"
    query_data(query)
```

### 6.4 查询结果缓存策略


**💾 缓存优化建议**

```
适合缓存的查询：
✅ 历史数据查询（数据不会变化）
✅ 聚合统计查询（计算成本高）
✅ 频繁访问的仪表板数据

不适合缓存的查询：
❌ 实时监控数据
❌ 告警状态查询
❌ 一次性查询

缓存策略：
- 根据查询时间范围设置不同的缓存时间
- 历史数据可以长期缓存
- 近期数据设置较短的缓存时间
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 两大查询接口：瞬时查询获取当前状态，范围查询获取趋势变化
🔸 关键参数理解：query指定查什么，time/start/end指定什么时候，step控制精度
🔸 响应数据格式：vector是瞬时数据点，matrix是时间序列数据
🔸 性能优化原则：合理设置时间范围，适当调整step，使用标签过滤
```

### 7.2 关键理解要点


**🔹 瞬时查询 vs 范围查询的选择**
```
瞬时查询适用场景：
- 当前状态检查（服务是否在线）
- 实时数值获取（当前CPU使用率）
- 告警状态查询
- 单点数据验证

范围查询适用场景：
- 趋势分析（性能变化趋势）
- 图表绘制（监控大屏）
- 容量规划（历史数据分析）
- 故障回溯（问题发生时的数据变化）
```

**🔹 step参数的影响**
```
step设置的权衡：
- step太小：数据精细但查询慢，数据量大
- step太大：查询快但可能丢失重要变化
- 最佳实践：根据监控需求和时间范围合理选择
```

**🔹 时间参数的灵活性**
```
时间参数选择：
- 精确时间：使用Unix时间戳或RFC3339格式
- 相对时间：使用now-1h这类表达式，适合动态查询
- 业务需求：根据监控场景选择合适的时间窗口
```

### 7.3 实际应用价值


**🎯 监控场景应用**
- **实时监控**：使用瞬时查询获取当前系统状态
- **性能分析**：使用范围查询分析系统性能趋势
- **故障排查**：通过时间范围查询定位问题发生时间
- **容量规划**：通过历史数据分析预测未来资源需求

**🔧 开发实践**
- **API集成**：在监控系统中集成Prometheus查询接口
- **自动化运维**：通过API实现自动化监控和告警
- **数据可视化**：为Grafana等工具提供数据源
- **性能调优**：根据查询性能优化监控策略

**🚨 注意事项**
- 查询语法正确性：错误的PromQL语法会导致查询失败
- 时间参数格式：确保时间格式符合API要求
- 性能考虑：大时间范围查询可能影响Prometheus性能
- 错误处理：实现适当的错误处理和重试机制

**核心记忆**：
- 瞬时查询看现在，范围查询看趋势
- query写什么查什么，time参数定时间
- step控制精度，timeout防卡死
- vector是点数据，matrix是线数据
- 优化查询提性能，标签过滤很关键