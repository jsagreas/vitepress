---
title: 5、告警规则API接口
---
## 📚 目录

1. [告警规则API基础概念](#1-告警规则API基础概念)
2. [规则状态查询接口](#2-规则状态查询接口)
3. [活跃告警查询接口](#3-活跃告警查询接口)
4. [告警规则管理实战](#4-告警规则管理实战)
5. [告警调试与优化技巧](#5-告警调试与优化技巧)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🚨 告警规则API基础概念


### 1.1 什么是告警规则API


**🔍 通俗理解**
想象你是一个工厂的安全员，需要实时监控各种设备的运行状态。告警规则API就像是你的"监控仪表盘"，可以：
- 查看所有的安全规则是否正常工作
- 了解当前有哪些设备在报警
- 检查规则的执行情况和历史记录

```
现实场景类比：
智能家居安防系统 ←→ Prometheus告警系统
├─ 门窗传感器规则    ←→ CPU使用率规则
├─ 烟雾报警规则      ←→ 内存使用率规则  
├─ 温度监控规则      ←→ 磁盘空间规则
└─ 报警状态查询      ←→ 告警API查询
```

**📋 核心作用**
- **规则监控**：检查告警规则是否正常运行
- **状态查询**：了解当前活跃的告警信息
- **历史追溯**：查看告警的触发和恢复历史
- **配置验证**：确认规则配置是否正确

### 1.2 告警API的两大核心接口


```
Prometheus告警API架构：
┌─────────────────────────────────┐
│        Prometheus Server        │
├─────────────────────────────────┤
│  /api/v1/rules   规则查询接口    │ ← 查看所有告警规则状态
├─────────────────────────────────┤  
│  /api/v1/alerts  告警查询接口    │ ← 查看当前活跃告警
└─────────────────────────────────┘
```

**🔸 两个接口的区别**：
- **`/api/v1/rules`**：查看规则本身（规则配置、状态、执行情况）
- **`/api/v1/alerts`**：查看告警结果（当前正在报警的事件）

---

## 2. 📊 规则状态查询接口


### 2.1 基础规则查询


**🎯 接口地址**：`GET /api/v1/rules`

**💡 通俗解释**
这个接口就像是查看"规则清单"，告诉你：
- 有哪些监控规则在运行
- 每个规则的当前状态如何
- 规则最后一次执行是什么时候

**📝 基础查询示例**
```bash
# 获取所有规则信息
curl http://localhost:9090/api/v1/rules

# 只获取特定规则组
curl "http://localhost:9090/api/v1/rules?type=alert"
```

### 2.2 规则信息详解


**🔍 返回数据结构解析**
```json
{
  "status": "success",
  "data": {
    "groups": [
      {
        "name": "web-server-alerts",        // 规则组名称
        "file": "/etc/prometheus/rules.yml", // 规则文件路径
        "interval": 30,                     // 评估间隔（秒）
        "lastEvaluation": "2025-09-21T10:30:00Z", // 最后评估时间
        "evaluationTime": 0.15,             // 评估耗时（秒）
        "rules": [
          {
            "name": "HighCPUUsage",          // 规则名称
            "query": "cpu_usage > 80",       // PromQL查询
            "duration": 300,                 // 持续时间（秒）
            "health": "ok",                  // 规则健康状态
            "evaluationTime": 0.05,          // 单个规则评估时间
            "lastEvaluation": "2025-09-21T10:30:00Z",
            "state": "firing",               // 当前状态：inactive/pending/firing
            "activeAt": "2025-09-21T10:25:00Z", // 开始活跃时间
            "value": "85.5"                  // 当前查询结果值
          }
        ]
      }
    ]
  }
}
```

**🔑 关键字段含义**：

| 字段 | **含义** | **通俗解释** |
|------|----------|-------------|
| `health` | 规则健康状态 | `ok`=正常，`err`=有错误 |
| `state` | 规则当前状态 | `inactive`=未触发，`pending`=即将触发，`firing`=正在告警 |
| `evaluationTime` | 评估耗时 | 执行这个规则花了多长时间 |
| `activeAt` | 开始活跃时间 | 规则开始满足条件的时间 |

### 2.3 过滤和查询技巧


**🎯 按规则类型过滤**
```bash
# 只查看告警规则（不包括记录规则）
curl "http://localhost:9090/api/v1/rules?type=alert"

# 只查看记录规则
curl "http://localhost:9090/api/v1/rules?type=record"
```

**🔍 实用查询场景**：

> 💡 **场景1：检查规则健康状态**
> 
> 目的：找出配置错误的规则
> ```bash
> curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | select(.health != "ok")'
> ```

> ⚡ **场景2：查看高耗时规则**
> 
> 目的：找出影响性能的规则
> ```bash
> curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | select(.evaluationTime > 1)'
> ```

---

## 3. 🔥 活跃告警查询接口


### 3.1 基础告警查询


**🎯 接口地址**：`GET /api/v1/alerts`

**💡 通俗解释**
这个接口就像是查看"当前报警列表"，显示：
- 现在有哪些系统在报警
- 每个报警的详细信息
- 报警的严重程度和状态

**📝 基础查询示例**
```bash
# 获取所有活跃告警
curl http://localhost:9090/api/v1/alerts

# 获取特定状态的告警
curl "http://localhost:9090/api/v1/alerts?state=firing"
```

### 3.2 告警信息详解


**🔍 返回数据结构解析**
```json
{
  "status": "success", 
  "data": {
    "alerts": [
      {
        "labels": {
          "alertname": "HighCPUUsage",      // 告警名称
          "instance": "web-server-01:9100", // 实例标识
          "job": "node-exporter",           // 任务名称
          "severity": "warning"             // 严重程度
        },
        "annotations": {
          "summary": "CPU使用率过高",        // 告警摘要
          "description": "CPU使用率已达到85.5%，超过80%阈值" // 详细描述
        },
        "state": "firing",                  // 告警状态
        "activeAt": "2025-09-21T10:25:00Z", // 开始时间
        "value": "85.5"                     // 触发值
      }
    ]
  }
}
```

**🔑 告警状态说明**：

```
告警状态生命周期：
inactive ──→ pending ──→ firing ──→ inactive
   ↑                                    ↓
   └────────── 条件恢复正常 ←──────────────┘

📍 状态详解：
• inactive：条件不满足，无告警
• pending：条件满足但还在持续时间内等待
• firing：条件满足且超过持续时间，正式告警
```

### 3.3 告警过滤查询


**🎯 按状态过滤**
```bash
# 只查看正在告警的
curl "http://localhost:9090/api/v1/alerts?state=firing"

# 只查看等待中的告警  
curl "http://localhost:9090/api/v1/alerts?state=pending"
```

**🔍 按标签过滤**
```bash
# 查看特定实例的告警
curl "http://localhost:9090/api/v1/alerts" | jq '.data.alerts[] | select(.labels.instance == "web-server-01:9100")'

# 查看高严重级别告警
curl "http://localhost:9090/api/v1/alerts" | jq '.data.alerts[] | select(.labels.severity == "critical")'
```

---

## 4. 🛠 告警规则管理实战


### 4.1 规则配置验证


**💡 验证思路**
在修改告警规则后，通过API检查配置是否正确，避免规则失效。

**📋 验证步骤**：

> 🔧 **步骤1：检查规则语法**
> ```bash
> # 检查所有规则的健康状态
> curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | {name: .name, health: .health, lastError: .lastError}'
> ```

> 🔍 **步骤2：查看规则执行情况**
> ```bash
> # 检查规则评估时间，发现性能问题
> curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | {name: .name, evaluationTime: .evaluationTime} | select(.evaluationTime > 0.5)'
> ```

**⚠️ 常见问题排查**：

| 问题现象 | **可能原因** | **解决方法** |
|---------|-------------|-------------|
| `health: "err"` | PromQL语法错误 | 检查查询语句是否正确 |
| `evaluationTime` 很大 | 查询复杂度过高 | 优化PromQL查询 |
| `lastEvaluation` 过旧 | 规则没有执行 | 检查规则文件是否加载 |

### 4.2 规则性能监控


**📊 性能指标解读**
```bash
# 获取规则组性能统计
curl "http://localhost:9090/api/v1/rules" | jq '
.data.groups[] | {
  group: .name,
  interval: .interval,
  evaluationTime: .evaluationTime,
  rulesCount: (.rules | length),
  avgRuleTime: ((.evaluationTime / (.rules | length)) | round)
}'
```

**🎯 性能优化建议**：

> ⚡ **优化技巧1：调整评估间隔**
> 
> 不是所有规则都需要30秒评估一次
> ```yaml
> groups:
> - name: critical-alerts
>   interval: 15s    # 关键告警，频繁检查
> - name: info-alerts  
>   interval: 60s    # 一般告警，降低频率
> ```

> 🔍 **优化技巧2：简化PromQL查询**
> 
> 复杂的查询会拖慢整体性能
> ```promql
> # 避免：复杂的多重聚合
> avg(rate(cpu_usage[5m])) by (instance) > 0.8
> 
> # 推荐：简单直接的查询
> cpu_usage > 80
> ```

### 4.3 规则文件热更新


**🔄 更新流程**
```bash
# 1. 修改规则文件后，通知Prometheus重新加载
curl -X POST http://localhost:9090/-/reload

# 2. 验证更新是否成功
curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[] | {name: .name, file: .file, lastEvaluation: .lastEvaluation}'

# 3. 检查是否有新的错误
curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | select(.health != "ok")'
```

---

## 5. 🔧 告警调试与优化技巧


### 5.1 告警测试方法


**🧪 测试思路**
在生产环境上线前，验证告警规则是否按预期工作。

**📝 测试步骤**：

> 🔍 **方法1：查看规则当前值**
> ```bash
> # 查看规则的实时计算结果
> curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | {name: .name, query: .query, value: .value, state: .state}'
> ```

> ⚡ **方法2：模拟告警条件**
> ```bash
> # 先在PromQL界面测试查询
> curl "http://localhost:9090/api/v1/query?query=cpu_usage%20%3E%2080"
> 
> # 然后检查规则是否正确触发
> curl "http://localhost:9090/api/v1/alerts" | jq '.data.alerts[] | select(.labels.alertname == "HighCPUUsage")'
> ```

### 5.2 告警静默状态管理


**🔇 静默机制理解**
有时需要临时屏蔽某些告警，比如计划维护期间。

**📋 查看静默状态**：
```bash
# 注意：静默功能通常由Alertmanager管理，不是Prometheus直接提供
# 但可以通过Prometheus查看告警是否被抑制

# 查看所有告警的完整信息
curl "http://localhost:9090/api/v1/alerts" | jq '.data.alerts[] | {
  alertname: .labels.alertname,
  instance: .labels.instance, 
  state: .state,
  activeAt: .activeAt
}'
```

### 5.3 告警历史追溯


**📚 历史查询技巧**
虽然API不直接提供历史告警，但可以通过一些方法获取历史信息。

**🔍 间接查询方法**：

> 💡 **方法1：使用ALERTS指标**
> ```bash
> # 查询过去24小时的告警状态
> curl "http://localhost:9090/api/v1/query?query=ALERTS%7B24h%7D"
> 
> # 查询特定告警的历史
> curl "http://localhost:9090/api/v1/query_range?query=ALERTS%7Balertname%3D%22HighCPUUsage%22%7D&start=2025-09-20T00:00:00Z&end=2025-09-21T00:00:00Z&step=3600s"
> ```

> 📊 **方法2：结合规则状态分析**
> ```bash
> # 分析规则的活跃时间，了解告警持续情况
> curl "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | select(.state == "firing") | {
>   name: .name,
>   activeAt: .activeAt,
>   value: .value,
>   duration: .duration
> }'
> ```

### 5.4 性能调优实战


**⚡ 常见性能问题**

| 问题 | **症状** | **解决方案** |
|------|---------|-------------|
| 规则评估慢 | `evaluationTime > 1s` | 优化PromQL，减少数据范围 |
| 告警风暴 | 大量相似告警同时触发 | 添加聚合规则，减少重复告警 |
| 资源消耗高 | CPU/内存使用率高 | 调整评估间隔，合并规则组 |

**🔧 优化实践**：

> 🎯 **优化实例：减少告警噪音**
> ```yaml
> # 原始规则：过于敏感
> - alert: HighCPUUsage
>   expr: cpu_usage > 70
>   for: 1m
> 
> # 优化后：提高阈值，增加持续时间
> - alert: HighCPUUsage  
>   expr: cpu_usage > 80
>   for: 5m
>   labels:
>     severity: warning
>   annotations:
>     summary: "CPU使用率持续过高"
>     description: "{{ $labels.instance }} CPU使用率 {{ $value }}% 已超过80%超过5分钟"
> ```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 两大核心API：
• /api/v1/rules  - 查看规则状态和配置
• /api/v1/alerts - 查看当前活跃告警

🔸 规则状态理解：
• health: ok/err - 规则配置是否正确
• state: inactive/pending/firing - 规则当前状态

🔸 告警生命周期：
• inactive → pending → firing → inactive

🔸 关键监控指标：
• evaluationTime - 规则执行性能
• activeAt - 告警开始时间
• value - 当前触发值
```

### 6.2 实用技能要点


**🔹 日常监控技能**
```bash
# 快速检查告警状态
curl localhost:9090/api/v1/alerts | jq '.data.alerts | length'

# 检查规则健康状态  
curl localhost:9090/api/v1/rules | jq '.data.groups[].rules[] | select(.health != "ok")'

# 查看性能较差的规则
curl localhost:9090/api/v1/rules | jq '.data.groups[].rules[] | select(.evaluationTime > 0.5)'
```

**🔹 故障排查技能**
- 规则不触发 → 检查PromQL语法和数据源
- 告警太频繁 → 调整阈值和持续时间  
- 性能影响 → 优化查询复杂度和评估间隔

**🔹 优化管理技能**
- 定期检查规则性能指标
- 合理设置告警阈值避免噪音
- 使用标签和注释提高告警可读性

### 6.3 最佳实践建议


**🎯 告警规则设计原则**
- **可操作性**：每个告警都应该有明确的处理步骤
- **相关性**：告警应该反映真正需要关注的问题
- **及时性**：平衡检测速度和资源消耗
- **可读性**：使用清晰的命名和描述

**📊 监控体系建议**
- 建立多层次告警：critical → warning → info
- 设置合理的评估间隔：关键指标15-30s，一般指标60s
- 定期回顾和优化告警规则
- 结合Grafana面板可视化告警状态

**🧠 核心记忆口诀**：
```
规则状态先查health，告警列表看state
性能监控evaluation，历史追溯用ALERTS
测试验证很重要，优化调整不能少
```

**核心学习要点**：
- 告警API是监控运维的重要工具，要熟练掌握基础查询方法
- 理解告警状态转换机制，有助于快速定位问题
- 重视规则性能监控，避免影响Prometheus整体性能  
- 结合实际业务场景，设计合适的告警阈值和规则