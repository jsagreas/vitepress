---
title: 3、元数据API接口
---
## 📚 目录

1. [元数据API概述](#1-元数据API概述)
2. [标签名称查询接口](#2-标签名称查询接口)
3. [标签值查询接口](#3-标签值查询接口)
4. [时间序列查询接口](#4-时间序列查询接口)
5. [指标元数据接口](#5-指标元数据接口)
6. [实战应用场景](#6-实战应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 元数据API概述


### 1.1 什么是元数据API


**📋 简单理解**：
元数据API就像是Prometheus的"目录查询系统"，帮你快速找到：
- 有哪些监控指标
- 每个指标有哪些标签
- 标签都有什么值
- 指标的详细信息

```
类比理解：
就像图书馆的索引系统
📚 图书馆 = Prometheus数据库
🏷️ 书籍分类 = 指标标签
📖 具体书名 = 指标名称
📝 书籍简介 = 指标元数据
```

### 1.2 为什么需要元数据API


**🎯 核心作用**：
```
数据探索：不知道有什么指标时，先查目录
标签发现：了解某个指标有哪些维度
值域查询：某个标签都有哪些可能的值
指标理解：这个指标是干什么用的
```

**💡 实际场景**：
- **运维新人**：不熟悉系统，先看看都监控了什么
- **Dashboard制作**：需要知道标签的所有可能值做下拉选择
- **告警规则**：确认标签值是否存在
- **数据清理**：找出不再使用的指标

---

## 2. 🏷️ 标签名称查询接口


### 2.1 基本语法


**🔸 接口地址**：`/api/v1/label_names`

```bash
# 最简单的用法
curl "http://localhost:9090/api/v1/label_names"
```

**📊 返回结果示例**：
```json
{
  "status": "success",
  "data": [
    "__name__",
    "instance", 
    "job",
    "cpu",
    "device",
    "fstype",
    "mountpoint"
  ]
}
```

### 2.2 时间范围过滤


**🕐 添加时间过滤**：
```bash
# 查询最近1小时内出现过的标签名
curl "http://localhost:9090/api/v1/label_names?start=2024-01-01T10:00:00Z&end=2024-01-01T11:00:00Z"
```

**💭 什么时候用时间过滤**：
- 某些标签可能是临时的（如动态创建的容器）
- 你只关心最近一段时间的监控数据
- 避免看到已经不存在的历史标签

### 2.3 匹配过滤器


**🎯 按指标过滤标签**：
```bash
# 只看CPU相关指标的标签
curl "http://localhost:9090/api/v1/label_names?match[]=up&match[]=cpu_usage_total"
```

┌─ 实用技巧 ────────────────┐
│ **什么是match[]参数？**   │
│ 指定特定的指标名称，只返回│
│ 这些指标使用过的标签名   │
│ 避免看到无关的标签信息   │
└───────────────────────────┘

---

## 3. 📈 标签值查询接口


### 3.1 基本用法


**🔸 接口地址**：`/api/v1/label_values/{label_name}`

```bash
# 查看job标签的所有可能值
curl "http://localhost:9090/api/v1/label_values/job"
```

**📊 返回结果**：
```json
{
  "status": "success", 
  "data": [
    "prometheus",
    "node_exporter", 
    "blackbox_exporter",
    "mysql_exporter"
  ]
}
```

### 3.2 常用标签值查询


**🔍 实用查询示例**：

```bash
# 查看所有监控的实例
curl "http://localhost:9090/api/v1/label_values/instance"

# 查看所有指标名称  
curl "http://localhost:9090/api/v1/label_values/__name__"

# 查看所有设备名称
curl "http://localhost:9090/api/v1/label_values/device"
```

### 3.3 组合过滤查询


**🎯 精确查询**：
```bash
# 只看node_exporter任务的instance值
curl "http://localhost:9090/api/v1/label_values/instance?match[]=up{job=\"node_exporter\"}"
```

**🔗 关联查询思路**：
```
第一步：curl "/api/v1/label_values/job"
      ↓ 发现有node_exporter
第二步：curl "/api/v1/label_values/instance?match[]=up{job=\"node_exporter\"}"  
      ↓ 看这个job下有哪些机器
第三步：针对具体机器做更详细的监控
```

---

## 4. 📊 时间序列查询接口


### 4.1 接口基础


**🔸 接口地址**：`/api/v1/series`

**简单理解**：
这个接口告诉你"具体有哪些时间序列"，每个时间序列就是一条监控数据线。

```bash
# 查看所有时间序列（数据量可能很大！）
curl "http://localhost:9090/api/v1/series"
```

### 4.2 实用查询方式


**🎯 按指标查询**：
```bash
# 查看CPU使用率相关的所有时间序列
curl "http://localhost:9090/api/v1/series?match[]=cpu_usage_idle"
```

**📊 返回结果示例**：
```json
{
  "status": "success",
  "data": [
    {
      "__name__": "cpu_usage_idle",
      "cpu": "cpu0", 
      "instance": "localhost:9100",
      "job": "node_exporter"
    },
    {
      "__name__": "cpu_usage_idle", 
      "cpu": "cpu1",
      "instance": "localhost:9100", 
      "job": "node_exporter"
    }
  ]
}
```

### 4.3 高级过滤技巧


**🔍 多条件组合**：
```bash
# 查看特定实例的特定指标
curl "http://localhost:9090/api/v1/series?match[]=up{instance=\"localhost:9100\"}"

# 查看多个指标的时间序列
curl "http://localhost:9090/api/v1/series?match[]=cpu_usage_idle&match[]=memory_usage"
```

**⏰ 时间范围限制**：
```bash
# 查看最近1小时的时间序列
curl "http://localhost:9090/api/v1/series?match[]=up&start=$(date -d '1 hour ago' --iso-8601)&end=$(date --iso-8601)"
```

💡 **实用建议**：
- 总是加上`match[]`参数，避免返回所有数据
- 对于大集群，加上时间范围限制
- 用这个接口了解数据的"形状"和维度

---

## 5. 📋 指标元数据接口


### 5.1 接口说明


**🔸 接口地址**：`/api/v1/metadata`

**核心作用**：
获取指标的详细信息，包括：
- 指标类型（counter、gauge、histogram等）
- 帮助信息（这个指标是干什么的）
- 单位信息

```bash
# 查看所有指标的元数据
curl "http://localhost:9090/api/v1/metadata"
```

### 5.2 按指标查询


**🎯 查看特定指标信息**：
```bash
# 查看up指标的详细信息
curl "http://localhost:9090/api/v1/metadata?metric=up"
```

**📊 返回结果**：
```json
{
  "status": "success",
  "data": {
    "up": [
      {
        "type": "gauge",
        "help": "1 if the instance is healthy, 0 otherwise",
        "unit": ""
      }
    ]
  }
}
```

### 5.3 理解指标类型


**📈 常见指标类型**：

| 类型 | **含义** | **例子** | **用途** |
|------|----------|----------|----------|
| `counter` | 只增不减的计数器 | `http_requests_total` | 累计请求数 |
| `gauge` | 可增可减的测量值 | `memory_usage` | 内存使用率 |
| `histogram` | 分布统计 | `http_duration_seconds` | 响应时间分布 |
| `summary` | 摘要统计 | `rpc_duration_quantile` | 分位数统计 |

┌─ 新手提示 ────────────────┐
│ **为什么要关心指标类型？** │
│ • counter：知道要用rate() │
│ • gauge：可以直接使用     │  
│ • histogram：需要特殊函数 │
│ 类型决定了如何正确使用！  │
└───────────────────────────┘

---

## 6. 🚀 实战应用场景


### 6.1 数据探索工作流


**🔍 标准探索流程**：

```
第一步：了解全貌
GET /api/v1/label_names
→ 看看都有哪些标签维度

第二步：查看任务类型  
GET /api/v1/label_values/job
→ 了解监控了哪些服务

第三步：选定目标查看实例
GET /api/v1/label_values/instance?match[]=up{job="node_exporter"}
→ 看看这个服务有哪些实例

第四步：了解指标详情
GET /api/v1/metadata?metric=cpu_usage_total
→ 确认指标类型和含义

第五步：查看具体时间序列
GET /api/v1/series?match[]=cpu_usage_total{job="node_exporter"}
→ 了解数据的完整维度
```

### 6.2 Dashboard开发场景


**📊 动态下拉框数据**：

```bash
# 为Grafana面板获取job列表
curl "http://localhost:9090/api/v1/label_values/job" | jq -r '.data[]'

# 为下拉框获取实例列表  
curl "http://localhost:9090/api/v1/label_values/instance?match[]=up{job=\"$job\"}"

# 获取磁盘设备列表
curl "http://localhost:9090/api/v1/label_values/device?match[]=disk_usage{job=\"node_exporter\"}"
```

### 6.3 监控巡检场景


**🔍 健康检查脚本示例**：

```bash
#!/bin/bash
# 检查是否有新的监控目标上线

echo "=== 当前监控的任务 ==="
curl -s "http://localhost:9090/api/v1/label_values/job" | jq -r '.data[]'

echo "=== 各任务的实例数量 ==="
for job in $(curl -s "http://localhost:9090/api/v1/label_values/job" | jq -r '.data[]'); do
  count=$(curl -s "http://localhost:9090/api/v1/label_values/instance?match[]=up{job=\"$job\"}" | jq '.data | length')
  echo "$job: $count 个实例"
done

echo "=== 检查是否有down的实例 ==="
curl -s "http://localhost:9090/api/v1/series?match[]=up{job!=\"\"}" | jq -r '.data[] | select(.up != "1") | .instance'
```

### 6.4 告警规则开发


**⚠️ 验证标签值存在性**：

```bash
# 在写告警规则前，先确认标签值是否存在
curl "http://localhost:9090/api/v1/label_values/severity" | grep -q "critical"
if [ $? -eq 0 ]; then
  echo "可以使用severity=\"critical\"标签"
else  
  echo "警告：没有发现critical级别的告警"
fi
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 元数据API：Prometheus的"目录查询系统"
🔸 标签名查询：了解有哪些监控维度
🔸 标签值查询：某个维度有哪些具体值  
🔸 时间序列查询：具体的监控数据线有哪些
🔸 指标元数据：指标的类型和含义信息
```

### 7.2 核心接口速查


| 接口 | **用途** | **示例** |
|------|----------|----------|
| `/api/v1/label_names` | 查询所有标签名 | `job, instance, cpu` |
| `/api/v1/label_values/{label}` | 查询标签的所有值 | `node_exporter, mysql` |
| `/api/v1/series` | 查询时间序列组合 | 具体的监控数据线 |
| `/api/v1/metadata` | 查询指标元信息 | 类型、帮助信息 |

### 7.3 实用技巧总结


**🎯 查询优化**：
```
始终使用match[]参数：避免返回过多数据
合理设置时间范围：关注有效时间段  
逐步缩小范围：先大范围再精确查询
结合使用多个接口：获得完整的数据视图
```

**💡 最佳实践**：
- **数据探索**：按照标准工作流逐步深入
- **脚本开发**：用jq工具处理JSON返回结果
- **Dashboard开发**：为动态组件提供数据源
- **运维巡检**：定期检查监控覆盖情况

**🔧 常见问题解决**：
```
问题：返回数据太多
解决：使用match[]参数过滤

问题：找不到某个标签  
解决：检查是否在指定时间范围内存在

问题：不知道指标含义
解决：使用metadata接口查看帮助信息

问题：不确定标签值格式
解决：先用label_values接口查看示例
```

### 7.4 学习建议


**🎓 新手学习路径**：
1. **先理解概念**：知道元数据API是干什么的
2. **动手练习**：在自己的Prometheus上试试每个接口
3. **结合实际**：用于实际的监控场景
4. **深入应用**：开发脚本和自动化工具

**🔍 进阶方向**：
- 结合PromQL使用这些接口
- 开发监控数据的自动发现工具
- 集成到CI/CD流程中做监控检查
- 构建动态的监控Dashboard

**核心记忆**：
- 元数据API是数据探索的入口
- 标签查询帮助理解数据维度  
- 时间序列查询看到数据全貌
- 指标元数据确保正确使用
- 组合使用效果最好