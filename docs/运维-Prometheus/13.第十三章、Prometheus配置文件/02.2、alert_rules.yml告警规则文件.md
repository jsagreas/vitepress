---
title: 2、alert_rules.yml告警规则文件
---
## 📚 目录

1. [什么是告警规则文件](#1-什么是告警规则文件)
2. [规则文件基本结构](#2-规则文件基本结构)
3. [告警规则详解](#3-告警规则详解)
4. [记录规则详解](#4-记录规则详解)
5. [规则组织与管理](#5-规则组织与管理)
6. [实战案例解析](#6-实战案例解析)
7. [最佳实践指南](#7-最佳实践指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔔 什么是告警规则文件


### 1.1 通俗理解告警规则


想象一下，**Prometheus就像一个24小时不休息的监控员**，它需要知道什么时候该"报警"。告警规则文件就是给这个监控员的**"工作手册"**，告诉它：

```
🏠 类比生活场景：
家庭安防系统 → Prometheus监控系统
安防规则设置 → 告警规则文件  
触发报警条件 → 指标异常阈值
报警通知方式 → 告警发送渠道
```

### 1.2 告警规则的核心作用


**🎯 核心功能**
- **自动监测**：持续检查系统指标是否正常
- **智能判断**：根据预设条件决定是否告警
- **及时通知**：第一时间告知运维人员异常情况
- **分级处理**：根据严重程度采取不同响应策略

### 1.3 为什么需要告警规则


> 💡 **新手提示**
> 
> 没有告警规则的监控系统，就像**只有眼睛没有大脑的守卫**——能看到数据，但不知道什么时候该采取行动！

**实际价值体现**：
- ⚡ **事前预警**：问题还没严重就提前通知
- 🎯 **精准定位**：快速找到出问题的具体服务
- 📱 **多渠道通知**：邮件、短信、微信等方式通知
- 📊 **数据留存**：记录告警历史，便于分析趋势

---

## 2. 📋 规则文件基本结构


### 2.1 文件整体架构


告警规则文件采用**YAML格式**，就像搭积木一样层层组织：

```
📁 规则文件结构图
└── alert_rules.yml
    ├── 🏷️ groups (规则组列表)
    │   ├── 📝 name (组名称)  
    │   ├── ⏱️ interval (检查间隔)
    │   └── 📋 rules (规则列表)
    │       ├── 🚨 alert规则 (告警类型)
    │       └── 📊 record规则 (记录类型)
    └── 🔧 其他配置项
```

### 2.2 最简单的规则文件示例


```yaml
# 这就是一个完整的告警规则文件！
groups:                           # 规则组的开始
  - name: "basic-alerts"          # 给这组规则起个名字
    rules:                        # 开始定义具体规则
      - alert: HighCPUUsage       # 告警名称
        expr: cpu_usage > 80      # 什么情况下告警
        for: 5m                   # 持续多久才告警
        labels:                   # 给告警贴标签
          severity: warning       # 严重程度
        annotations:              # 告警的详细信息
          summary: "CPU使用率过高"
```

### 2.3 关键字段速览表


| 🔑 关键字段 | 📝 作用说明 | 💡 通俗理解 |
|------------|-------------|-------------|
| `groups` | 规则分组容器 | 把相关规则放在一个文件夹里 |
| `name` | 组名称标识 | 给文件夹起个好记的名字 |
| `interval` | 检查时间间隔 | 多久检查一次（默认1分钟） |
| `rules` | 具体规则列表 | 文件夹里的具体文件 |
| `alert` | 告警规则名称 | 告警的身份证号 |
| `record` | 记录规则名称 | 数据记录的身份证号 |

---

## 3. 🚨 告警规则详解


### 3.1 告警规则的基本组成


每个告警规则就像一份**"监控作业指导书"**，包含以下核心要素：

```
🎯 告警规则构成要素
┌─────────────────────────────────┐
│  alert: 告警名称 (必填)          │
│  ├── expr: 触发条件 (必填)       │  
│  ├── for: 持续时间 (可选)        │
│  ├── labels: 标签信息 (可选)     │
│  └── annotations: 注释信息 (可选) │
└─────────────────────────────────┘
```

### 3.2 `expr`表达式详解


**`expr`是告警的"大脑"**，决定什么时候该响起警报：

**🔍 常见表达式类型**

```yaml
# 1️⃣ 简单阈值判断
expr: cpu_usage > 80                    # CPU超过80%就告警

# 2️⃣ 时间窗口聚合  
expr: avg_over_time(cpu_usage[5m]) > 70 # 5分钟平均CPU超过70%

# 3️⃣ 多条件组合
expr: cpu_usage > 80 and memory_usage > 90  # CPU和内存都高才告警

# 4️⃣ 实例离线检测
expr: up == 0                           # 服务下线检测
```

> ⚠️ **新手注意**
> 
> `expr`表达式使用的是**PromQL查询语言**，就像SQL是查询数据库的语言一样，PromQL是查询监控数据的专用语言。

### 3.3 `for`持续时间的重要性


**为什么需要`for`？** 避免"狼来了"的假警报！

```
🕐 时间持续原理图示：

情况1: 没有for参数
CPU飙升 → 立即告警 → 可能是瞬间抖动

情况2: 设置for: 5m  
CPU飙升 → 等待5分钟 → 确认持续异常 → 发送告警

推荐设置：
├── 严重故障: for: 1m   (快速响应)
├── 一般告警: for: 5m   (避免误报)  
├── 趋势预警: for: 15m  (长期观察)
└── 容量规划: for: 1h   (长期趋势)
```

### 3.4 `labels`标签系统


标签就像给告警贴的**"分类标签"**，帮助快速识别和处理：

```yaml
labels:
  severity: critical        # 🔴 严重程度
  team: backend            # 👥 负责团队  
  service: user-api        # 🔧 相关服务
  environment: production  # 🌍 环境标识
  priority: P1             # ⭐ 优先级别
```

**🏷️ 常用标签分类体系**

| 标签类型 | 可选值 | 用途说明 |
|---------|--------|----------|
| `severity` | `critical` `warning` `info` | 🚦 **严重程度分级** |
| `team` | `backend` `frontend` `devops` | 👥 **责任团队划分** |
| `service` | `user-api` `order-service` | 🔧 **服务模块标识** |
| `environment` | `prod` `staging` `dev` | 🌍 **环境区分** |

### 3.5 `annotations`注释信息


注释信息是告警的**"说明书"**，告诉接收者发生了什么、如何处理：

```yaml
annotations:
  summary: "{{ $labels.instance }}服务CPU使用率过高"
  description: |
    当前CPU使用率: {{ $value }}%
    触发阈值: 80%
    持续时间: 5分钟
    影响范围: 用户登录可能变慢
  runbook_url: "https://wiki.company.com/runbook/high-cpu"
  dashboard_url: "http://grafana.company.com/d/cpu-dashboard"
```

**📝 注释字段详解**

| 字段名 | 作用 | 示例 |
|--------|------|------|
| `summary` | 📋 简短摘要 | "服务CPU使用率过高" |
| `description` | 📖 详细描述 | 包含具体数值、影响范围等 |
| `runbook_url` | 🔗 处理手册链接 | 指向解决方案文档 |
| `dashboard_url` | 📊 监控面板链接 | 快速跳转到相关图表 |

---

## 4. 📊 记录规则详解


### 4.1 什么是记录规则


**记录规则就像"数据预处理器"**，把复杂的计算提前做好，存起来备用：

```
🔄 记录规则工作流程：
原始数据 → 复杂计算 → 预计算结果 → 存储为新指标 → 快速查询使用

举例说明：
每次都计算"5分钟CPU平均值" ❌ (慢)
预先算好存成"cpu_avg_5m"指标 ✅ (快)
```

### 4.2 记录规则语法结构


```yaml
- record: cpu_usage_avg_5m              # 新指标名称
  expr: avg_over_time(cpu_usage[5m])    # 计算表达式  
  labels:                               # 附加标签
    aggregation: "5m_avg"
```

### 4.3 记录规则命名规范


**🎯 推荐命名格式**：`指标名_聚合方式_时间窗口`

```yaml
# ✅ 好的命名示例
- record: http_requests_rate_5m         # HTTP请求5分钟速率
- record: cpu_usage_avg_1h              # CPU使用率1小时平均
- record: memory_usage_max_15m          # 内存使用率15分钟最大值
- record: disk_io_sum_10m               # 磁盘IO 10分钟总和

# ❌ 不好的命名示例  
- record: my_metric                     # 太模糊
- record: cpu                           # 太简单
- record: very_long_metric_name_that_nobody_understands  # 太复杂
```

### 4.4 记录规则实用案例


**💡 实际应用场景**

```yaml
# 🎯 场景1: 服务可用性计算
- record: service_availability_5m
  expr: |
    (
      sum(rate(http_requests_total{status!~"5.."}[5m])) 
      / 
      sum(rate(http_requests_total[5m]))
    ) * 100

# 🎯 场景2: 资源使用趋势
- record: resource_usage_trend_1h  
  expr: |
    (
      avg_over_time(cpu_usage[1h]) + 
      avg_over_time(memory_usage[1h])
    ) / 2
```

---

## 5. 🗂️ 规则组织与管理


### 5.1 规则分组策略


**按业务维度分组** - 就像整理衣柜一样，把相关的放在一起：

```
📁 分组组织结构示例：
├── 📋 基础设施告警组
│   ├── 服务器硬件告警
│   ├── 网络连接告警  
│   └── 存储空间告警
├── 📋 应用服务告警组
│   ├── API响应时间告警
│   ├── 数据库连接告警
│   └── 缓存命中率告警
└── 📋 业务指标告警组
    ├── 用户注册量告警
    ├── 订单转化率告警
    └── 支付成功率告警
```

### 5.2 分组配置示例


```yaml
groups:
  # 🏗️ 基础设施监控组
  - name: "infrastructure-alerts"
    interval: 30s                    # 基础设施检查频率高一些
    rules:
      - alert: ServerDown
        expr: up == 0
        for: 1m                      # 服务器下线快速告警
        
  # 🔧 应用服务监控组      
  - name: "application-alerts"  
    interval: 1m                     # 应用层检查频率中等
    rules:
      - alert: HighResponseTime
        expr: http_request_duration > 2
        for: 5m                      # 响应慢可以容忍一会儿
        
  # 📊 业务指标监控组
  - name: "business-alerts"
    interval: 5m                     # 业务指标检查频率低一些  
    rules:
      - alert: LowConversionRate
        expr: conversion_rate < 0.05
        for: 15m                     # 业务指标变化较慢
```

### 5.3 告警级别设计


**🚦 三级告警体系** - 像交通信号灯一样简单明了：

| 级别 | 标识 | 响应时间 | 通知方式 | 典型场景 |
|------|------|----------|----------|----------|
| 🔴 **Critical** | P1 | 5分钟内 | 电话+短信+邮件 | 服务完全不可用 |
| 🟡 **Warning** | P2 | 30分钟内 | 短信+邮件 | 性能下降但可用 |
| 🔵 **Info** | P3 | 2小时内 | 仅邮件 | 趋势预警 |

```yaml
# 🔴 Critical级别示例
- alert: ServiceDown
  expr: up == 0
  for: 1m
  labels:
    severity: critical
    priority: P1
    
# 🟡 Warning级别示例    
- alert: HighCPUUsage
  expr: cpu_usage > 80
  for: 5m
  labels:
    severity: warning  
    priority: P2
    
# 🔵 Info级别示例
- alert: DiskSpaceTrend
  expr: disk_usage > 70
  for: 30m
  labels:
    severity: info
    priority: P3
```

---

## 6. 🎯 实战案例解析


### 6.1 完整的Web服务监控规则


```yaml
groups:
  - name: "web-service-monitoring"
    interval: 30s
    rules:
      # 📊 记录规则：预计算常用指标
      - record: http_request_rate_5m
        expr: rate(http_requests_total[5m])
        labels:
          aggregation: "5m_rate"
          
      - record: http_error_rate_5m  
        expr: |
          rate(http_requests_total{status=~"4..|5.."}[5m]) 
          / 
          rate(http_requests_total[5m])
        labels:
          aggregation: "5m_error_rate"
      
      # 🚨 告警规则：基于预计算指标告警
      - alert: HighErrorRate
        expr: http_error_rate_5m > 0.05
        for: 2m
        labels:
          severity: critical
          team: backend
          service: web-api
        annotations:
          summary: "Web服务错误率过高"
          description: |
            当前错误率: {{ $value | humanizePercentage }}
            触发阈值: 5%
            建议检查: 应用日志、数据库连接
          runbook_url: "https://wiki.company.com/high-error-rate"
          
      - alert: HighResponseTime  
        expr: histogram_quantile(0.95, http_request_duration_seconds_bucket) > 2
        for: 5m
        labels:
          severity: warning
          team: backend
          service: web-api
        annotations:
          summary: "Web服务响应时间过长"
          description: |
            95分位响应时间: {{ $value }}秒
            触发阈值: 2秒
            可能影响: 用户体验下降
```

### 6.2 数据库监控规则案例


```yaml
groups:
  - name: "database-monitoring"
    interval: 1m
    rules:
      # 🔴 Critical级别：数据库连接
      - alert: DatabaseDown
        expr: mysql_up == 0
        for: 30s
        labels:
          severity: critical
          team: dba
          service: mysql
        annotations:
          summary: "数据库服务不可用"
          description: |
            数据库实例: {{ $labels.instance }}
            状态: 连接失败
            紧急程度: 立即处理
          
      # 🟡 Warning级别：连接数过多    
      - alert: TooManyConnections
        expr: mysql_global_status_threads_connected > 80
        for: 5m  
        labels:
          severity: warning
          team: dba
          service: mysql
        annotations:
          summary: "数据库连接数过多"
          description: |
            当前连接数: {{ $value }}
            最大连接数: {{ mysql_global_variables_max_connections }}
            使用率: {{ $value | humanizePercentage }}
```

### 6.3 系统资源监控规则


```yaml
groups:
  - name: "system-resources"
    interval: 1m
    rules:
      # 📊 预计算系统负载
      - record: system_load_normalized
        expr: node_load1 / on(instance) node_cpu_count
        labels:
          metric_type: "load_average"
          
      # 🚨 CPU使用率告警
      - alert: HighCPUUsage
        expr: 100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 85
        for: 5m
        labels:
          severity: warning
          team: ops
          resource: cpu
        annotations:
          summary: "{{ $labels.instance }} CPU使用率过高"
          description: |
            当前CPU使用率: {{ $value | printf "%.1f" }}%
            持续时间: 5分钟以上
            建议操作: 检查进程占用情况
            
      # 🚨 内存使用率告警      
      - alert: HighMemoryUsage
        expr: |
          (
            1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)
          ) * 100 > 90
        for: 5m
        labels:
          severity: critical
          team: ops  
          resource: memory
        annotations:
          summary: "{{ $labels.instance }} 内存使用率过高"
          description: |
            当前内存使用率: {{ $value | printf "%.1f" }}%
            可用内存: {{ with query "node_memory_MemAvailable_bytes" }}{{ . | first | value | humanize1024 }}B{{ end }}
            总内存: {{ with query "node_memory_MemTotal_bytes" }}{{ . | first | value | humanize1024 }}B{{ end }}
```

---

## 7. 💡 最佳实践指南


### 7.1 规则命名最佳实践


**🎯 统一命名规范**

```yaml
# ✅ 推荐的命名格式
告警规则: [Service][Component][Issue][Severity]
记录规则: [metric]_[aggregation]_[time_window]

# 具体示例
- alert: WebApiHighErrorRateCritical      # Web API高错误率严重告警
- alert: DatabaseConnectionCountWarning   # 数据库连接数警告  
- record: cpu_usage_avg_5m               # CPU使用率5分钟平均值
- record: http_requests_rate_1h          # HTTP请求1小时速率
```

### 7.2 表达式编写技巧


**⚡ 性能优化原则**

```yaml
# ✅ 好的表达式 - 简洁高效
expr: rate(http_requests_total[5m]) > 100

# ❌ 避免的表达式 - 复杂低效  
expr: |
  sum(
    rate(
      http_requests_total{
        status!="404",
        status!="500", 
        method!="OPTIONS"
      }[5m]
    )
  ) by (instance) > 100
```

**🔍 表达式调试技巧**

```
💡 调试步骤：
1️⃣ 在Prometheus Web UI中测试表达式
2️⃣ 检查返回的时间序列数量
3️⃣ 验证标签选择器是否正确
4️⃣ 确认时间窗口设置合理
5️⃣ 测试不同时间点的表达式结果
```

### 7.3 告警收敛策略


**📱 避免告警风暴**

```yaml
# 🎯 使用标签进行告警分组
labels:
  alert_group: "web-service"     # 同组告警可以合并通知
  team: "backend"                # 发送给特定团队
  severity: "warning"            # 相同级别可以批量处理

# 🎯 设置合理的for时间  
for: 5m                         # 避免瞬时抖动引起的误报

# 🎯 使用inhibit_rules抑制低级别告警
# 当Critical告警触发时，自动抑制Warning告警
```

### 7.4 文档化规范


```yaml
annotations:
  # 📝 必需信息
  summary: "简洁明了的一句话描述"
  description: |
    详细描述包含：
    - 当前状态和触发值
    - 可能的影响范围  
    - 初步排查方向
    
  # 🔗 辅助链接  
  runbook_url: "详细处理手册链接"
  dashboard_url: "相关监控面板链接"
  doc_url: "技术文档链接"
  
  # 👥 联系信息
  oncall_team: "值班团队名称"
  escalation_policy: "升级策略"
```

### 7.5 测试与验证


**🧪 规则测试流程**

```
📋 测试检查清单：
├── ✅ 语法检查: promtool check rules alert_rules.yml
├── ✅ 表达式验证: 在Prometheus UI中运行
├── ✅ 阈值测试: 模拟异常情况触发告警
├── ✅ 通知测试: 确认告警能正确发送
├── ✅ 文档检查: 确认runbook链接有效
└── ✅ 团队确认: 相关团队确认告警接收配置
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 告警规则文件：Prometheus的"工作手册"，定义何时告警
🔸 groups分组：按业务或系统维度组织规则
🔸 alert告警规则：定义异常检测和通知逻辑
🔸 record记录规则：预计算复杂指标，提升查询性能
🔸 表达式expr：使用PromQL定义触发条件
🔸 持续时间for：避免瞬时抖动造成的误报
🔸 标签labels：告警分类和路由的重要依据
🔸 注释annotations：告警的详细说明和处理指导
```

### 8.2 关键理解要点


**🔹 告警设计哲学**
```
宁可漏报，不要误报：
- 合理设置for时间，避免瞬时抖动
- 选择合适的阈值，基于历史数据分析
- 分级告警，避免"狼来了"效应

快速定位，快速恢复：
- 丰富的标签信息帮助快速定位
- 详细的注释提供处理指导  
- runbook链接指向具体解决方案
```

**🔹 规则组织原则**
```
按业务分组：相关的规则放在一起
按团队分工：不同团队负责不同规则组
按严重程度：Critical规则检查频率更高
按系统架构：基础设施、应用、业务三层分离
```

**🔹 性能优化要点**
```
记录规则预计算：复杂查询提前算好存起来
合理设置检查间隔：不是越频繁越好
优化表达式：避免过于复杂的PromQL
标签选择器：精确匹配减少计算量
```

### 8.3 实际应用价值


- **🔍 故障预防**：通过趋势告警提前发现问题
- **⚡ 快速响应**：自动告警缩短故障发现时间
- **👥 团队协作**：清晰的责任划分和处理流程
- **📊 数据驱动**：基于历史数据优化告警阈值
- **🔧 运维自动化**：结合告警处理实现自动修复

### 8.4 新手学习路径


```
🎯 建议学习顺序：
1️⃣ 理解告警规则的基本概念和作用
2️⃣ 学习YAML语法和基本的文件结构  
3️⃣ 掌握简单的PromQL表达式编写
4️⃣ 实践编写基础的CPU、内存告警规则
5️⃣ 学习标签和注释的最佳实践
6️⃣ 掌握记录规则的使用场景
7️⃣ 设计完整的业务监控告警体系
```

**💡 新手友好提示**：
- 从简单的阈值告警开始，逐步学习复杂表达式
- 多参考开源项目的规则文件，学习最佳实践
- 在测试环境充分验证后再应用到生产环境
- 建立告警文档，记录每个规则的设计思路

**核心记忆口诀**：
```
告警规则像手册，教会系统何时喊
分组管理有条理，标签注释要齐全
表达式里藏智慧，for时间防误判
测试验证不可少，文档完善好习惯
```