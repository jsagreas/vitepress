---
title: 2、Node-Exporter系统监控
---
## 📚 目录

1. [Node Exporter基础认知](#1-node-exporter基础认知)
2. [安装部署实战](#2-安装部署实战)
3. [系统指标深度解析](#3-系统指标深度解析)
4. [收集器配置管理](#4-收集器配置管理)
5. [高级配置与优化](#5-高级配置与优化)
6. [故障排查与最佳实践](#6-故障排查与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 Node Exporter基础认知


### 1.1 什么是Node Exporter


**通俗解释**：Node Exporter就像是服务器的"体检医生"，它负责定期检查服务器的各项"健康指标"，然后把这些数据提供给Prometheus进行分析。

```
简单类比：
医生体检 ≈ Node Exporter
├─ 测量血压 ≈ 检查CPU使用率
├─ 检查心率 ≈ 监控内存状态
├─ 化验血液 ≈ 分析磁盘空间
└─ 健康报告 ≈ 指标数据输出

都是为了了解"被检查对象"的健康状况
```

**核心作用**：
- 🔍 **数据收集员**：专门负责收集Linux/Unix系统的各种运行数据
- 📊 **指标提供者**：将收集到的数据转换成Prometheus能理解的格式
- 🔄 **持续监控**：7×24小时不间断地监控系统状态

### 1.2 Node Exporter在监控体系中的位置


```
监控架构图：
┌──────────────┐    ┌─────────────┐    ┌──────────────┐
│  被监控服务器  │    │ Prometheus  │    │   Grafana    │
│              │    │   Server    │    │   Dashboard  │
│ ┌──────────┐ │    │             │    │              │
│ │Node      │ │───▶│ 数据采集     │───▶│  图表展示     │
│ │Exporter  │ │    │ 数据存储     │    │  告警通知     │
│ └──────────┘ │    │ 规则计算     │    │              │
└──────────────┘    └─────────────┘    └──────────────┘
     数据源              数据处理            数据展示
```

### 1.3 Node Exporter的工作原理


**工作流程**：
1. **启动运行**：作为守护进程在后台运行
2. **定期采集**：按设定间隔收集系统指标
3. **数据暴露**：通过HTTP接口提供指标数据
4. **等待拉取**：Prometheus主动来获取数据

```
数据流向：
系统内核 → Node Exporter → HTTP接口 → Prometheus
   ↓           ↓              ↓           ↓
真实数据    格式转换      网络传输     数据存储
```

> 💡 **关键理解**：Node Exporter不会主动推送数据，而是等待Prometheus来"拉取"数据，这种模式叫做Pull模式。

---

## 2. ⚙️ 安装部署实战


### 2.1 下载与准备


**获取Node Exporter**：

```bash
# 1. 下载最新版本
wget https://github.com/prometheus/node_exporter/releases/download/v1.6.1/node_exporter-1.6.1.linux-amd64.tar.gz

# 2. 解压文件
tar xf node_exporter-1.6.1.linux-amd64.tar.gz

# 3. 移动到系统目录
sudo cp node_exporter-1.6.1.linux-amd64/node_exporter /usr/local/bin/
```

### 2.2 创建系统用户


**为什么需要专用用户**：出于安全考虑，我们不希望Node Exporter以root权限运行。

```bash
# 创建专用用户（不能登录系统）
sudo useradd --no-create-home --shell /bin/false node_exporter

# 设置文件权限
sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter
```

### 2.3 systemd服务配置


**创建服务文件**：让Node Exporter能够开机自启动和后台运行。

```bash
# 创建服务配置文件
sudo nano /etc/systemd/system/node_exporter.service
```

**服务配置内容**：

```ini
[Unit]
Description=Node Exporter
Documentation=https://prometheus.io/docs/guides/node-exporter/
Wants=network-online.target
After=network-online.target

[Service]
User=node_exporter
Group=node_exporter
Type=simple
Restart=on-failure
ExecStart=/usr/local/bin/node_exporter \
    --web.listen-address=0.0.0.0:9100 \
    --path.rootfs=/host

[Install]
WantedBy=multi-user.target
```

**配置说明**：
- `--web.listen-address=0.0.0.0:9100`：监听所有网卡的9100端口
- `--path.rootfs=/host`：在容器环境中指定根文件系统路径
- `Restart=on-failure`：出错时自动重启

### 2.4 启动与验证


```bash
# 重载systemd配置
sudo systemctl daemon-reload

# 启动服务
sudo systemctl start node_exporter

# 设置开机自启
sudo systemctl enable node_exporter

# 检查运行状态
sudo systemctl status node_exporter
```

**验证服务是否正常**：

```bash
# 检查端口是否开放
ss -tlnp | grep 9100

# 测试指标获取
curl http://localhost:9100/metrics | head -20
```

> ✅ **成功标志**：能够看到大量以`node_`开头的指标数据输出。

---

## 3. 📊 系统指标深度解析


### 3.1 CPU使用率指标


**CPU指标概述**：Node Exporter收集的CPU数据非常详细，包括各种工作模式的时间统计。

**核心指标解读**：

| 指标名称 | **含义说明** | **实际应用** |
|---------|-------------|-------------|
| `node_cpu_seconds_total{mode="idle"}` | `CPU空闲时间` | `值越高说明CPU越空闲` |
| `node_cpu_seconds_total{mode="user"}` | `用户程序使用CPU时间` | `应用程序繁忙程度` |
| `node_cpu_seconds_total{mode="system"}` | `系统内核使用CPU时间` | `系统调用频繁程度` |
| `node_cpu_seconds_total{mode="iowait"}` | `等待IO操作的时间` | `磁盘瓶颈检测` |

**CPU使用率计算方法**：

```
CPU使用率公式：
使用率 = (总时间 - 空闲时间) / 总时间 × 100%

在Prometheus中的查询：
100 - (avg(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
```

### 3.2 内存使用情况


**内存指标详解**：

```
内存使用分布图：
┌─────────────────────────────────────┐ 总内存
│ ┌─────────────┐ ┌─────────────────┐ │
│ │   已使用     │ │      可用        │ │
│ │             │ │                 │ │
│ │ ┌─────────┐ │ │ ┌─────┐ ┌─────┐ │ │
│ │ │ 应用程序 │ │ │ │缓存 │ │空闲 │ │ │
│ │ └─────────┘ │ │ └─────┘ └─────┘ │ │
│ └─────────────┘ └─────────────────┘ │
└─────────────────────────────────────┘
```

**关键内存指标**：

```bash
# 总内存
node_memory_MemTotal_bytes

# 可用内存
node_memory_MemAvailable_bytes

# 缓存内存
node_memory_Cached_bytes

# 缓冲区内存
node_memory_Buffers_bytes
```

**内存使用率计算**：

```
内存使用率 = (总内存 - 可用内存) / 总内存 × 100%

Prometheus查询：
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100
```

> 🔍 **重要提示**：Linux系统的"可用内存"不等于"空闲内存"，因为缓存和缓冲区在需要时可以释放给应用程序使用。

### 3.3 磁盘空间监控


**磁盘指标体系**：

```
磁盘监控层次：
┌─ 文件系统层面 ─┐  ┌─ 磁盘设备层面 ─┐
│               │  │               │
│ 空间使用率     │  │ 读写速度       │
│ 可用空间      │  │ IO等待时间     │
│ inode使用率   │  │ 设备利用率     │
└───────────────┘  └───────────────┘
```

**文件系统指标**：

| 指标 | **说明** | **告警阈值建议** |
|------|---------|-----------------|
| `node_filesystem_size_bytes` | `文件系统总大小` | `参考值` |
| `node_filesystem_free_bytes` | `可用空间大小` | `< 总空间的10%` |
| `node_filesystem_avail_bytes` | `普通用户可用空间` | `< 总空间的5%` |

**磁盘IO指标**：

```bash
# 磁盘读写次数
node_disk_reads_completed_total
node_disk_writes_completed_total

# 磁盘读写字节数
node_disk_read_bytes_total
node_disk_written_bytes_total

# IO操作时间
node_disk_io_time_seconds_total
```

### 3.4 网络接口统计


**网络监控视角**：

```
网络流量监控：
┌─────────────┐    ┌─────────────┐
│   接收流量   │    │   发送流量   │
│             │    │             │
│ ┌─────────┐ │    │ ┌─────────┐ │
│ │ 字节数   │ │    │ │ 字节数   │ │
│ │ 包数量   │ │    │ │ 包数量   │ │
│ │ 错误数   │ │    │ │ 错误数   │ │
│ │ 丢包数   │ │    │ │ 丢包数   │ │
│ └─────────┘ │    │ └─────────┘ │
└─────────────┘    └─────────────┘
```

**网络接口指标**：

```bash
# 接收数据
node_network_receive_bytes_total{device="eth0"}
node_network_receive_packets_total{device="eth0"}

# 发送数据
node_network_transmit_bytes_total{device="eth0"}
node_network_transmit_packets_total{device="eth0"}

# 错误统计
node_network_receive_errs_total{device="eth0"}
node_network_transmit_errs_total{device="eth0"}
```

### 3.5 负载平均值与系统运行时间


**负载平均值解读**：

> 📖 **概念解释**：负载平均值表示系统在特定时间段内平均有多少个进程在等待CPU资源或等待IO操作完成。

```bash
# 1分钟负载平均值
node_load1

# 5分钟负载平均值  
node_load5

# 15分钟负载平均值
node_load15
```

**负载评估标准**：
- **单核CPU**：负载1.0表示CPU完全使用
- **四核CPU**：负载4.0表示CPU完全使用
- **经验法则**：负载超过CPU核数的70%需要关注

**系统运行时间**：

```bash
# 系统启动后运行的秒数
node_boot_time_seconds

# 计算运行天数
(time() - node_boot_time_seconds) / 86400
```

---

## 4. 🔧 收集器配置管理


### 4.1 收集器概念理解


**什么是收集器**：收集器就像是Node Exporter的"专业检查员"，每个收集器负责检查系统的特定方面。

```
收集器工作分工：
┌─ CPU收集器 ─┐  ┌─ 内存收集器 ─┐  ┌─ 磁盘收集器 ─┐
│            │  │             │  │             │
│ 检查CPU使用 │  │ 检查内存状态 │  │ 检查磁盘状态 │
│ 各核心状态  │  │ 缓存情况    │  │ IO性能      │
│ 频率信息   │  │ 交换分区    │  │ 文件系统    │
└────────────┘  └─────────────┘  └─────────────┘
```

### 4.2 查看可用收集器


```bash
# 查看所有可用的收集器
/usr/local/bin/node_exporter --help | grep collector

# 查看默认启用的收集器
/usr/local/bin/node_exporter --help | grep "Enabled by default"
```

**默认启用的核心收集器**：
- `cpu`：CPU使用情况
- `diskstats`：磁盘IO统计
- `filesystem`：文件系统使用情况
- `loadavg`：负载平均值
- `meminfo`：内存信息
- `netdev`：网络设备统计
- `time`：系统时间
- `uname`：系统信息

### 4.3 禁用不需要的收集器


**为什么要禁用收集器**：
- 🎯 **减少资源消耗**：不收集不需要的指标
- 🚀 **提高性能**：降低CPU和内存使用
- 🔒 **增强安全性**：避免暴露敏感信息

```bash
# 禁用特定收集器
--collector.disable-defaults \
--collector.cpu \
--collector.meminfo \
--collector.diskstats

# 示例：只监控基础指标
ExecStart=/usr/local/bin/node_exporter \
    --collector.disable-defaults \
    --collector.cpu \
    --collector.meminfo \
    --collector.filesystem \
    --collector.loadavg
```

### 4.4 启用额外收集器


**常用可选收集器**：

| 收集器名称 | **功能说明** | **使用场景** |
|-----------|-------------|-------------|
| `systemd` | `systemd服务状态` | `监控系统服务健康状态` |
| `processes` | `进程统计信息` | `监控进程数量和状态` |
| `tcpstat` | `TCP连接统计` | `网络连接监控` |
| `hwmon` | `硬件温度传感器` | `服务器温度监控` |

```bash
# 启用systemd收集器
--collector.systemd

# 启用进程收集器
--collector.processes

# 启用硬件监控
--collector.hwmon
```

### 4.5 textfile收集器：自定义指标


**textfile收集器原理**：允许你将自定义指标写入文本文件，Node Exporter会自动读取并暴露这些指标。

```bash
# 启用textfile收集器
--collector.textfile.directory=/var/lib/node_exporter/textfile_collector
```

**创建自定义指标示例**：

```bash
# 创建目录
sudo mkdir -p /var/lib/node_exporter/textfile_collector

# 创建自定义指标文件
cat > /var/lib/node_exporter/textfile_collector/my_metrics.prom << EOF
# HELP my_custom_metric 自定义业务指标
# TYPE my_custom_metric gauge
my_custom_metric{service="web"} 42
my_custom_metric{service="api"} 37
EOF
```

> 🔧 **实践技巧**：textfile收集器特别适合监控脚本执行结果、业务指标或其他自定义数据。

---

## 5. 🚀 高级配置与优化


### 5.1 启动参数详解


**完整启动参数示例**：

```bash
ExecStart=/usr/local/bin/node_exporter \
    --web.listen-address=0.0.0.0:9100 \
    --web.telemetry-path=/metrics \
    --log.level=info \
    --collector.textfile.directory=/var/lib/node_exporter \
    --collector.filesystem.ignored-mount-points="^/(dev|proc|sys|var/lib/docker/.+)($|/)" \
    --collector.filesystem.ignored-fs-types="^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
```

**参数说明**：

| 参数 | **作用** | **建议值** |
|------|---------|-----------|
| `--web.listen-address` | `监听地址和端口` | `0.0.0.0:9100` |
| `--web.telemetry-path` | `指标获取路径` | `/metrics` |
| `--log.level` | `日志级别` | `info` |
| `--collector.filesystem.ignored-mount-points` | `忽略的挂载点` | `排除临时文件系统` |

### 5.2 文件系统过滤配置


**为什么需要过滤**：系统中有很多虚拟文件系统，监控它们没有意义还会增加负担。

```bash
# 忽略虚拟文件系统
--collector.filesystem.ignored-fs-types="^(autofs|binfmt_misc|cgroup|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|mqueue|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tracefs)$"

# 忽略特定挂载点
--collector.filesystem.ignored-mount-points="^/(dev|proc|sys|var/lib/docker/.+)($|/)"
```

### 5.3 安全配置建议


**基础安全措施**：

```bash
# 1. 使用专用用户
User=node_exporter
Group=node_exporter

# 2. 限制文件访问权限
sudo chmod 755 /usr/local/bin/node_exporter
sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter

# 3. 配置防火墙
sudo ufw allow from 192.168.1.0/24 to any port 9100
```

**网络安全考虑**：

```nginx
# 使用nginx代理保护Node Exporter
server {
    listen 9100;
    location /metrics {
        proxy_pass http://127.0.0.1:9101;
        allow 192.168.1.0/24;  # 只允许内网访问
        deny all;
    }
}
```

### 5.4 性能调优参数


**资源限制设置**：

```ini
[Service]
# 限制内存使用
MemoryLimit=128M

# 限制CPU使用
CPUQuota=50%

# 限制文件描述符
LimitNOFILE=8192
```

**监控频率优化**：

```bash
# 降低采集频率（如果性能要求不高）
--web.max-requests=40
--web.timeout-offset=1s
```

---

## 6. 🔍 故障排查与最佳实践


### 6.1 常见问题诊断


**问题排查流程**：

```
故障排查步骤：
┌─ 1. 检查服务状态 ─┐
│                  │
│ systemctl status │──→ 服务是否运行？
│                  │
└──────────────────┘
           │
           ▼
┌─ 2. 检查端口监听 ─┐
│                  │
│ ss -tlnp | grep  │──→ 端口是否开放？
│      9100        │
└──────────────────┘
           │
           ▼
┌─ 3. 检查指标输出 ─┐
│                  │
│ curl localhost:  │──→ 能否获取指标？
│    9100/metrics  │
└──────────────────┘
           │
           ▼
┌─ 4. 检查日志信息 ─┐
│                  │
│ journalctl -u    │──→ 有什么错误信息？
│ node_exporter    │
└──────────────────┘
```

### 6.2 典型故障及解决方案


**故障案例1：服务无法启动**

```bash
# 症状：systemctl start失败
# 检查命令
sudo journalctl -u node_exporter -f

# 常见原因和解决方案
1. 端口被占用
   - 检查：ss -tlnp | grep 9100
   - 解决：kill占用进程或更换端口

2. 权限不足
   - 检查：文件权限和用户配置
   - 解决：chown node_exporter:node_exporter /usr/local/bin/node_exporter

3. 启动参数错误
   - 检查：service文件中的ExecStart行
   - 解决：修正参数语法
```

**故障案例2：指标数据异常**

```bash
# 症状：某些指标值不正确或缺失
# 排查方法

1. 检查收集器状态
curl localhost:9100/metrics | grep collector_

2. 验证特定指标
curl localhost:9100/metrics | grep node_cpu

3. 检查文件系统权限
ls -la /proc/
ls -la /sys/
```

### 6.3 监控Node Exporter本身


**监控指标**：

```bash
# Node Exporter的运行状态
node_exporter_build_info

# 指标采集耗时
node_scrape_collector_duration_seconds

# 指标采集成功状态
node_scrape_collector_success
```

**健康检查脚本**：

```bash
#!/bin/bash
# node_exporter健康检查

ENDPOINT="http://localhost:9100/metrics"
TIMEOUT=10

# 检查HTTP响应
if curl -s --max-time $TIMEOUT $ENDPOINT > /dev/null; then
    echo "✅ Node Exporter健康状态：正常"
    exit 0
else
    echo "❌ Node Exporter健康状态：异常"
    exit 1
fi
```

### 6.4 最佳实践建议


**部署建议**：

```yaml
# 最佳实践清单
部署环境：
  ✅ 使用专用用户运行
  ✅ 配置systemd自动重启
  ✅ 设置资源限制
  ✅ 配置日志轮转

网络配置：
  ✅ 限制访问来源IP
  ✅ 使用内网通信
  ✅ 配置防火墙规则
  ✅ 考虑使用TLS加密

监控配置：
  ✅ 只启用需要的收集器
  ✅ 过滤不必要的文件系统
  ✅ 设置合理的采集频率
  ✅ 配置告警规则

运维管理：
  ✅ 定期检查服务状态
  ✅ 监控资源使用情况
  ✅ 备份配置文件
  ✅ 建立故障应急预案
```

**性能基准测试**：

```bash
# 测试Node Exporter性能影响
# 运行前
top -p $(pgrep node_exporter)

# 压力测试
for i in {1..100}; do
    curl -s http://localhost:9100/metrics > /dev/null &
done
wait

# 检查资源使用情况
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Node Exporter本质：系统监控数据收集器，Prometheus监控体系的数据源
🔸 工作原理：通过HTTP接口暴露系统指标，采用Pull模式被动提供数据
🔸 核心指标：CPU、内存、磁盘、网络、负载等系统级监控数据
🔸 收集器机制：模块化设计，可灵活启用/禁用不同的数据收集功能
🔸 部署方式：systemd服务管理，专用用户运行，确保安全性和稳定性
```

### 7.2 关键理解要点


**🔹 为什么选择Node Exporter**
```
优势特点：
- 专业性：专门为系统监控设计，指标覆盖全面
- 稳定性：社区维护成熟，生产环境验证充分
- 标准化：遵循Prometheus指标格式规范
- 轻量级：资源消耗低，对系统性能影响最小
```

**🔹 收集器管理策略**
```
实用原则：
- 按需启用：只收集业务需要的指标数据
- 性能优先：禁用不必要的收集器减少资源消耗
- 安全考虑：避免暴露敏感系统信息
- 扩展性：通过textfile收集器实现自定义监控
```

**🔹 部署配置要点**
```
关键配置：
- 用户权限：使用专用用户，遵循最小权限原则
- 网络安全：限制访问来源，使用内网通信
- 服务管理：systemd管理，自动重启和开机启动
- 参数调优：根据环境特点优化启动参数
```

### 7.3 实际应用价值


**🎯 生产环境应用**
- **基础监控**：构建完整的服务器监控体系
- **容量规划**：基于历史数据进行资源规划
- **故障预警**：及时发现系统异常和性能瓶颈
- **性能优化**：通过监控数据指导系统调优

**🔧 运维实践价值**
- **标准化监控**：统一的指标格式和采集方式
- **自动化运维**：结合告警规则实现故障自动发现
- **可视化展示**：配合Grafana实现直观的监控大屏
- **历史分析**：长期数据存储支持趋势分析

**🚀 扩展应用场景**
- **云原生环境**：Kubernetes集群节点监控
- **混合云监控**：跨平台统一监控方案
- **边缘计算**：轻量级监控部署
- **DevOps流程**：CI/CD过程中的性能监控

### 7.4 学习进阶路径


```
学习路线图：
┌─ 基础掌握 ─┐    ┌─ 进阶应用 ─┐    ┌─ 高级优化 ─┐
│           │    │           │    │           │
│ 安装部署   │───▶│ 指标分析   │───▶│ 性能调优   │
│ 基础配置   │    │ 告警配置   │    │ 自定义开发 │
│ 故障排查   │    │ 集群监控   │    │ 架构设计   │
└───────────┘    └───────────┘    └───────────┘
```

**核心记忆口诀**：
- Node Exporter系统监控的数据源，HTTP接口暴露指标供采集
- 收集器模块各司其职，按需启用节约资源
- 专用用户systemd管理，安全稳定是关键
- 指标含义要理解透彻，故障排查有章法

> 🎓 **学习建议**：先熟练掌握基础部署和常用指标，再深入学习高级配置和性能优化，最后结合实际业务场景进行自定义扩展。