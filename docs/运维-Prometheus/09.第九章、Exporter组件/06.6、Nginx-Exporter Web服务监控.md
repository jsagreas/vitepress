---
title: 6、Nginx-Exporter Web服务监控
---
## 📚 目录

1. [Nginx Exporter基础概念](#1-nginx-exporter基础概念)
2. [环境准备与安装配置](#2-环境准备与安装配置)
3. [基础指标监控实现](#3-基础指标监控实现)
4. [高级监控功能配置](#4-高级监控功能配置)
5. [告警策略与运维实践](#5-告警策略与运维实践)
6. [故障排查与性能优化](#6-故障排查与性能优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌐 Nginx Exporter基础概念


### 1.1 什么是Nginx Exporter


**简单理解**：Nginx Exporter就像是给Nginx装了一个"体检设备"，专门用来收集Nginx的各种运行数据。

```
想象一下：
医生给病人体检 → 测量血压、心率、体温等指标
Nginx Exporter → 收集请求数、响应时间、连接数等指标

目的都是：了解当前的"健康状况"
```

**🔸 核心作用**
- **数据收集器**：从Nginx收集各种性能指标
- **格式转换器**：将Nginx数据转换成Prometheus能理解的格式
- **监控桥梁**：连接Nginx和监控系统的中间件

### 1.2 为什么需要监控Nginx


**实际场景理解**：
```
网站突然变慢了！用户投诉页面打不开！
运维人员需要快速定位问题：

❓ 是服务器处理不过来了吗？  → 查看请求量
❓ 是某个页面出错了吗？      → 查看状态码分布  
❓ 是网络连接有问题吗？      → 查看连接数
❓ 是后端服务挂了吗？        → 查看上游服务器状态

没有监控 = 盲人摸象，有了监控 = 一目了然
```

### 1.3 Nginx Exporter的工作原理


**数据流向图解**：
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌───────────┐
│  用户请求   │───▶│    Nginx     │───▶│   Exporter  │───▶│Prometheus │
│            │    │  (产生指标)   │    │ (收集转换)   │    │ (存储分析) │
└─────────────┘    └──────────────┘    └─────────────┘    └───────────┘
                          │                    ▲
                          │                    │
                          ▼                    │
                   ┌──────────────┐            │
                   │ stub_status  │────────────┘
                   │   模块       │
                   └──────────────┘
```

**工作步骤解析**：
1. **Nginx接收请求** → 正常处理用户访问
2. **产生统计数据** → stub_status模块记录各种指标
3. **Exporter访问** → 定期从stub_status获取数据
4. **格式转换** → 转换成Prometheus格式
5. **数据暴露** → 通过HTTP接口提供给Prometheus

---

## 2. 🔧 环境准备与安装配置


### 2.1 Nginx stub_status模块启用


**什么是stub_status模块**：
> 💡 **通俗解释**：stub_status就像Nginx的"仪表盘"，显示当前的运行状态信息

**检查模块是否已安装**：
```bash
# 检查Nginx是否包含stub_status模块
nginx -V 2>&1 | grep -o with-http_stub_status_module

# 如果有输出说明已安装，没有输出需要重新编译
```

**配置stub_status端点**：
```nginx
# 在nginx.conf中添加状态监控端点
server {
    listen 8080;
    server_name localhost;
    
    location /nginx_status {
        stub_status on;
        access_log off;        # 关闭访问日志
        allow 127.0.0.1;       # 只允许本地访问
        allow ::1;
        deny all;              # 拒绝其他IP访问
    }
}
```

**验证配置效果**：
```bash
# 重载Nginx配置
nginx -s reload

# 测试状态页面
curl http://localhost:8080/nginx_status
```

**状态页面输出解读**：
```
Active connections: 2 
server accepts handled requests
 16630 16630 31070 
Reading: 0 Writing: 1 Waiting: 1
```

| 指标 | **含义** | **说明** |
|------|---------|---------|
| `Active connections` | `当前活跃连接数` | `正在处理的连接总数` |
| `accepts` | `接受连接总数` | `从启动到现在接受的连接数` |
| `handled` | `处理连接总数` | `成功处理的连接数` |
| `requests` | `请求总数` | `处理的请求总数` |
| `Reading` | `读取请求中` | `正在读取请求头的连接数` |
| `Writing` | `发送响应中` | `正在发送响应的连接数` |
| `Waiting` | `保持连接中` | `空闲的keep-alive连接数` |

### 2.2 nginx-prometheus-exporter安装


**下载安装Exporter**：
```bash
# 下载最新版本的nginx-prometheus-exporter
wget https://github.com/nginxinc/nginx-prometheus-exporter/releases/download/v0.11.0/nginx-prometheus-exporter_0.11.0_linux_amd64.tar.gz

# 解压安装
tar -zxvf nginx-prometheus-exporter_0.11.0_linux_amd64.tar.gz
sudo mv nginx-prometheus-exporter /usr/local/bin/

# 添加执行权限
chmod +x /usr/local/bin/nginx-prometheus-exporter
```

**创建系统服务**：
```bash
# 创建systemd服务文件
sudo tee /etc/systemd/system/nginx-exporter.service << EOF
[Unit]
Description=Nginx Prometheus Exporter
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/nginx-prometheus-exporter \\
    -nginx.scrape-uri=http://localhost:8080/nginx_status \\
    -web.listen-address=:9113
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF
```

**启动和验证服务**：
```bash
# 启动服务
sudo systemctl daemon-reload
sudo systemctl enable nginx-exporter
sudo systemctl start nginx-exporter

# 检查服务状态
sudo systemctl status nginx-exporter

# 验证指标数据
curl http://localhost:9113/metrics | grep nginx
```

### 2.3 配置Prometheus抓取


**在prometheus.yml中添加抓取配置**：
```yaml
scrape_configs:
  - job_name: 'nginx'
    static_configs:
      - targets: ['localhost:9113']
    scrape_interval: 15s
    metrics_path: /metrics
    scrape_timeout: 10s
```

---

## 3. 📊 基础指标监控实现


### 3.1 连接相关指标


**核心连接指标说明**：

| 指标名称 | **含义** | **用途** |
|---------|---------|---------|
| `nginx_connections_active` | `当前活跃连接数` | `判断服务器负载情况` |
| `nginx_connections_accepted_total` | `接受连接总数` | `统计服务使用量` |
| `nginx_connections_handled_total` | `处理连接总数` | `检查连接处理能力` |
| `nginx_connections_reading` | `读取请求连接数` | `网络IO性能指标` |
| `nginx_connections_writing` | `发送响应连接数` | `响应处理性能` |
| `nginx_connections_waiting` | `等待连接数` | `Keep-Alive连接池状态` |

**连接状态分析图解**：
```
连接生命周期：
客户端请求 ──┐
            │
            ▼
     ┌─────────────┐
     │   Reading   │  正在读取请求
     │  (读取阶段)  │
     └─────────────┘
            │
            ▼
     ┌─────────────┐
     │ Processing  │  处理请求逻辑
     │  (处理阶段)  │
     └─────────────┘
            │
            ▼
     ┌─────────────┐
     │   Writing   │  发送响应数据
     │  (写入阶段)  │
     └─────────────┘
            │
            ▼
     ┌─────────────┐
     │   Waiting   │  Keep-Alive等待
     │  (等待阶段)  │
     └─────────────┘
```

### 3.2 请求相关指标


**核心请求指标**：
- `nginx_http_requests_total` - 请求总数
- `nginx_http_request_duration_seconds` - 请求处理时间

**请求量监控查询示例**：
```promql
# 每秒请求数(QPS)
rate(nginx_http_requests_total[5m])

# 每分钟请求数
rate(nginx_http_requests_total[5m]) * 60

# 请求数突增检测
increase(nginx_http_requests_total[5m]) > 1000
```

**请求趋势分析**：
```
请求量变化图示：
     请求/秒
        ▲
    100 │     ╭─╮
        │    ╱   ╲
     50 │   ╱     ╲
        │  ╱       ╲
      0 ├─╱─────────╲──────▶ 时间
        8:00    12:00    18:00

分析要点：
• 正常业务高峰：12点左右
• 异常流量：突然的尖峰
• 基线流量：平时的稳定水平
```

### 3.3 性能基准建立


**建立监控基准的步骤**：

1️⃣ **收集基准数据**（观察1-2周）
```promql
# 平均活跃连接数
avg_over_time(nginx_connections_active[24h])

# 平均请求速率
avg_over_time(rate(nginx_http_requests_total[5m])[24h])
```

2️⃣ **确定正常范围**
```
基准值示例：
- 活跃连接数：正常 < 100，告警 > 200
- QPS：正常 < 50，告警 > 100  
- 响应时间：正常 < 100ms，告警 > 500ms
```

3️⃣ **设置合理阈值**
> ⚠️ **注意**：阈值设置要基于实际业务情况，不能一刀切

---

## 4. 🚀 高级监控功能配置


### 4.1 nginx_vts_exporter高级监控


**VTS模块的优势**：
> 💡 **通俗解释**：如果说stub_status是"简易体检"，那么VTS就是"全面体检报告"

**安装nginx-module-vts**：
```bash
# 如果使用包管理器安装的Nginx，可能需要重新编译
./configure --add-module=/path/to/nginx-module-vts
make && make install
```

**VTS模块配置**：
```nginx
http {
    vhost_traffic_status_zone;
    
    server {
        listen 80;
        server_name example.com;
        
        location /status {
            vhost_traffic_status_display;
            vhost_traffic_status_display_format html;
        }
        
        location /status/format/json {
            vhost_traffic_status_display;
            vhost_traffic_status_display_format json;
        }
    }
}
```

### 4.2 状态码分布监控


**HTTP状态码分类理解**：
```
状态码分类：
┌─────────┬──────────────┬──────────────┐
│ 状态码   │     含义      │     说明     │
├─────────┼──────────────┼──────────────┤
│ 2xx     │   成功响应    │   正常请求   │
│ 3xx     │   重定向      │   页面跳转   │  
│ 4xx     │   客户端错误  │   请求有误   │
│ 5xx     │   服务器错误  │   服务故障   │
└─────────┴──────────────┴──────────────┘
```

**状态码监控查询**：
```promql
# 错误率计算
rate(nginx_http_requests_total{status=~"4..|5.."}[5m]) / 
rate(nginx_http_requests_total[5m]) * 100

# 成功率计算  
rate(nginx_http_requests_total{status=~"2.."}[5m]) /
rate(nginx_http_requests_total[5m]) * 100
```

### 4.3 上游服务器监控


**上游服务器状态配置**：
```nginx
upstream backend {
    server backend1.example.com:8080;
    server backend2.example.com:8080;
    server backend3.example.com:8080 backup;
}

server {
    location / {
        proxy_pass http://backend;
        
        # 健康检查相关
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
    }
    
    location /upstream_status {
        upstream_status;
        access_log off;
        allow 127.0.0.1;
        deny all;
    }
}
```

**负载均衡监控指标**：
```
上游服务器健康状态：
┌──────────┬──────────┬──────────┬──────────┐
│ 服务器   │   状态   │ 权重     │ 失败次数 │
├──────────┼──────────┼──────────┼──────────┤
│backend1  │   up     │    1     │    0     │
│backend2  │   up     │    1     │    2     │
│backend3  │  backup  │    1     │    0     │
└──────────┴──────────┴──────────┴──────────┘
```

### 4.4 SSL证书监控


**SSL证书过期检测**：
```bash
# 检查证书过期时间的脚本
#!/bin/bash
DOMAIN="example.com"
EXPIRY_DATE=$(echo | openssl s_client -servername $DOMAIN -connect $DOMAIN:443 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2)
EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s)
CURRENT_EPOCH=$(date +%s)
DAYS_LEFT=$(( ($EXPIRY_EPOCH - $CURRENT_EPOCH) / 86400 ))

echo "ssl_cert_days_left{domain=\"$DOMAIN\"} $DAYS_LEFT"
```

---

## 5. 🚨 告警策略与运维实践


### 5.1 关键告警规则配置


**服务可用性告警**：
```yaml
groups:
  - name: nginx_alerts
    rules:
      # Nginx服务宕机
      - alert: NginxDown
        expr: up{job="nginx"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Nginx服务不可用"
          description: "Nginx已宕机超过1分钟"

      # 活跃连接数过高
      - alert: NginxHighConnections
        expr: nginx_connections_active > 200
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Nginx连接数过高"
          description: "当前活跃连接数: {{ $value }}"
```

**性能告警规则**：
```yaml
      # 错误率过高
      - alert: NginxHighErrorRate
        expr: |
          (
            rate(nginx_http_requests_total{status=~"5.."}[5m]) /
            rate(nginx_http_requests_total[5m])
          ) * 100 > 5
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "Nginx错误率过高"
          description: "5xx错误率: {{ $value }}%"

      # 请求量异常增长
      - alert: NginxRequestSpike
        expr: |
          rate(nginx_http_requests_total[5m]) > 
          avg_over_time(rate(nginx_http_requests_total[5m])[24h]) * 3
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Nginx请求量异常增长"
```

### 5.2 告警级别划分


**告警严重级别定义**：

| 级别 | **触发条件** | **响应时间** | **处理方式** |
|------|-------------|-------------|-------------|
| `🔴 Critical` | `服务完全不可用` | `立即响应` | `电话+短信通知` |
| `🟡 Warning` | `性能下降但可用` | `15分钟内` | `邮件+IM通知` |
| `🔵 Info` | `状态变化通知` | `非紧急` | `日志记录` |

### 5.3 容量规划数据收集


**关键容量指标**：
```promql
# 并发连接容量评估
max_over_time(nginx_connections_active[24h])

# 带宽使用趋势
rate(nginx_http_request_size_bytes_sum[5m]) + 
rate(nginx_http_response_size_bytes_sum[5m])

# 请求量增长趋势
increase(nginx_http_requests_total[24h])
```

**容量规划决策表**：
```
资源使用率评估：
┌────────────┬────────────┬────────────┬──────────┐
│    指标    │  当前值    │  阈值      │  状态    │
├────────────┼────────────┼────────────┼──────────┤
│ 连接数     │    150     │    200     │  正常    │
│ CPU使用率  │    60%     │    80%     │  正常    │
│ 内存使用率 │    45%     │    70%     │  正常    │
│ 网络带宽   │   50Mbps   │  100Mbps   │  正常    │
└────────────┴────────────┴────────────┴──────────┘

扩容建议：
• 连接数接近阈值 → 考虑增加worker进程
• CPU使用率过高 → 考虑硬件升级或负载均衡
• 带宽不足 → 考虑CDN或带宽升级
```

---

## 6. 🔍 故障排查与性能优化


### 6.1 常见问题诊断


**连接数异常排查**：
```bash
# 查看当前连接状态
ss -tuln | grep :80

# 查看连接数详情
netstat -an | grep :80 | wc -l

# 检查文件描述符限制
ulimit -n

# 查看Nginx worker进程数
ps aux | grep nginx
```

**性能问题排查流程**：
```
性能问题排查步骤：
1️⃣ 检查基础指标
   ├─ 连接数是否正常
   ├─ 错误率是否过高  
   └─ 响应时间是否异常

2️⃣ 分析访问模式
   ├─ 请求量是否突增
   ├─ 是否有异常IP
   └─ URL访问分布

3️⃣ 检查系统资源
   ├─ CPU使用率
   ├─ 内存使用率
   └─ 磁盘IO状态

4️⃣ 检查上游服务
   ├─ 后端服务状态
   ├─ 数据库连接
   └─ 第三方API响应
```

### 6.2 性能优化建议


**Nginx性能调优参数**：
```nginx
# worker进程优化
worker_processes auto;
worker_connections 1024;

# 连接处理优化
keepalive_timeout 65;
keepalive_requests 100;

# 缓冲区优化
client_body_buffer_size 128k;
client_header_buffer_size 32k;
large_client_header_buffers 4 32k;

# 压缩优化
gzip on;
gzip_comp_level 6;
gzip_types text/plain text/css application/json application/javascript;
```

**监控数据驱动的优化**：
```promql
# 识别慢请求
histogram_quantile(0.95, rate(nginx_http_request_duration_seconds_bucket[5m]))

# 找出高频访问路径
topk(10, rate(nginx_http_requests_total[5m]))

# 分析错误分布
sum by (status) (rate(nginx_http_requests_total[5m]))
```

### 6.3 日志分析集成


**日志格式配置**：
```nginx
log_format json_analytics escape=json
'{'
  '"time":"$time_iso8601",'
  '"remote_addr":"$remote_addr",'
  '"request":"$request",'
  '"status":"$status",'
  '"request_time":"$request_time",'
  '"upstream_response_time":"$upstream_response_time",'
  '"body_bytes_sent":"$body_bytes_sent"'
'}';

access_log /var/log/nginx/access.log json_analytics;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 Nginx Exporter本质：将Nginx状态数据转换为Prometheus格式的中间件
🔸 stub_status模块：Nginx内置的状态信息模块，提供基础监控数据
🔸 核心监控指标：连接数、请求量、状态码分布、响应时间
🔸 告警策略：基于业务特点设置合理的告警阈值和级别
🔸 性能优化：通过监控数据指导Nginx参数调优
```

### 7.2 关键理解要点


**🔹 为什么要监控Nginx**
```
业务价值：
• 快速发现问题：第一时间知道服务异常
• 定位故障原因：通过指标数据快速分析
• 容量规划：基于历史数据预测资源需求
• 性能优化：发现瓶颈并针对性改进
```

**🔹 监控指标的实际意义**
```
指标含义理解：
• 活跃连接数 → 当前服务器负载程度
• 请求速率 → 业务繁忙程度
• 错误率 → 服务质量状况
• 响应时间 → 用户体验水平
```

**🔹 告警设置的平衡点**
```
告警策略平衡：
过敏感 → 告警疲劳，真正问题被忽视
过迟钝 → 问题发现太晚，影响业务
合理设置 → 基于历史数据，结合业务特点
```

### 7.3 实际应用场景


**🎯 日常运维场景**
- **故障排查**：通过监控快速定位问题根因
- **容量规划**：基于趋势数据制定扩容计划
- **性能优化**：发现性能瓶颈并改进配置
- **业务分析**：了解用户访问模式和业务特点

**🔧 配置实践要点**
- **循序渐进**：从基础监控开始，逐步完善
- **贴近业务**：告警阈值要符合实际业务特点
- **持续改进**：定期回顾和调整监控策略
- **文档记录**：维护监控配置和处理流程文档

### 7.4 学习进阶路径


```
学习路径建议：
1️⃣ 基础搭建
   ├─ 熟练配置stub_status
   ├─ 掌握基础Exporter安装
   └─ 理解核心监控指标

2️⃣ 功能完善  
   ├─ 配置高级监控功能
   ├─ 设置合理告警规则
   └─ 集成日志分析

3️⃣ 深度应用
   ├─ 性能调优实践
   ├─ 故障排查经验
   └─ 容量规划能力
```

**核心记忆**：
- Nginx Exporter让Web服务监控变得简单直观
- 从基础指标开始，逐步建立完整的监控体系
- 监控的目标是发现问题、分析原因、指导优化
- 合理的告警策略比复杂的功能更重要