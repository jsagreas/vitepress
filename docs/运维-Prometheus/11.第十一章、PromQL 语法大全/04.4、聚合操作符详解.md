---
title: 4、聚合操作符详解
---
## 📚 目录


1. [聚合操作符基础概念](#1-聚合操作符基础概念)
2. [基础数值聚合操作](#2-基础数值聚合操作)
3. [计数类聚合操作](#3-计数类聚合操作)
4. [分组聚合控制](#4-分组聚合控制)
5. [排序类聚合操作](#5-排序类聚合操作)
6. [统计类聚合操作](#6-统计类聚合操作)
7. [聚合维度控制技巧](#7-聚合维度控制技巧)
8. [实战应用场景](#8-实战应用场景)
9. [核心要点总结](#9-核心要点总结)

---

# 🎯 **学习导航**


**前置知识**：需要了解基础PromQL语法、时间序列概念 → **当前内容**：聚合操作符 → **后续学习**：建议学习函数操作和告警规则

⏱️ **预计学习时间**：本章预计45分钟 | 实践练习30分钟

🏷️ **知识标签**：`#PromQL核心` `#聚合计算` `#监控必备`

---

## 1. 📊 聚合操作符基础概念



### 1.1 什么是聚合操作符



**🔸 通俗理解**
想象你是班主任要统计班级成绩：
- **原始数据**：每个学生的各科分数（就像各个服务器的监控数据）
- **聚合操作**：计算班级平均分、最高分、总分（就像计算集群的平均CPU、最大内存等）
- **分组统计**：按文理科分别计算（就像按服务类型分组统计）

**🎯 核心作用**
```
聚合操作符的本质：把多个数据点合并成一个结果
目的：从海量监控数据中提取有意义的统计信息
好处：化繁为简，快速了解系统整体状况
```

### 1.2 聚合操作的工作原理



**🔍 数据处理流程**
```
原始时间序列数据：
cpu_usage{server="web1", env="prod"} = 80
cpu_usage{server="web2", env="prod"} = 70  
cpu_usage{server="web3", env="prod"} = 90
cpu_usage{server="db1", env="prod"} = 60

应用聚合操作 avg()：
avg(cpu_usage) = (80+70+90+60)/4 = 75

结果：得到整个环境的平均CPU使用率
```

### 1.3 聚合操作符分类概览



| **类别** | **操作符** | **作用** | **常用场景** |
|---------|-----------|---------|-------------|
| **🔢 数值计算** | `sum, avg, max, min` | 基础数学运算 | 资源使用统计 |
| **📊 计数统计** | `count, count_values` | 计数和分布 | 实例数量统计 |
| **🎯 排序筛选** | `topk, bottomk` | 取前N名/后N名 | 找出问题节点 |
| **📈 统计分析** | `quantile, stddev` | 分位数、标准差 | 性能分析 |
| **🏷️ 分组控制** | `by, without` | 分组维度控制 | 多维度分析 |

---

## 2. 🔢 基础数值聚合操作



### 2.1 sum - 求和聚合



**💡 通俗解释**
就像计算所有服务器的总CPU使用量，把各个数值加起来。

**基础用法**
```promql
# 计算所有服务器的总CPU使用率

sum(cpu_usage)

# 结果示例：如果有3台服务器分别是80%、70%、90%

# sum结果 = 80 + 70 + 90 = 240

```

**实际应用场景**
- **总流量统计**：`sum(network_bytes_total)` - 计算集群总网络流量
- **总内存使用**：`sum(memory_usage_bytes)` - 计算所有服务器内存总用量
- **请求总数**：`sum(http_requests_total)` - 计算API总请求数

### 2.2 avg - 平均值聚合



**💡 通俗解释**
计算平均值，就像算班级平均成绩一样，适合了解整体水平。

**基础语法**
```promql
# 计算平均CPU使用率

avg(cpu_usage)

# 计算平均响应时间

avg(http_request_duration_seconds)
```

**⚠️ 使用注意事项**
- 平均值会**掩盖极端值**：一台服务器100%CPU，另一台0%，平均50%看起来正常
- 适合**趋势分析**，不适合发现**个别问题**

### 2.3 max/min - 最值聚合



**💡 实用价值**
- **max**：找出最严重的问题，比如哪台服务器CPU最高
- **min**：找出最轻负载的资源，比如哪台服务器最空闲

```promql
# 找出CPU使用率最高的值

max(cpu_usage)

# 找出内存使用最少的值  

min(memory_usage_bytes)

# 找出响应时间最长的请求

max(http_request_duration_seconds)
```

**🎯 实战应用**
- **容量规划**：`max(memory_usage_bytes)` 了解峰值内存需求
- **性能调优**：`max(http_request_duration_seconds)` 发现最慢的请求
- **故障排查**：`max(error_rate)` 找出错误率最高的服务

---

## 3. 📊 计数类聚合操作



### 3.1 count - 计数聚合



**💡 通俗理解**
统计有多少个数据点，就像点人数一样简单直接。

**基础用法**
```promql
# 统计有多少台服务器在线

count(up == 1)

# 统计有多少个服务实例

count(cpu_usage)

# 统计错误状态的服务数量

count(http_status_code == 500)
```

**🔍 实际应用场景**
- **服务发现**：了解集群规模大小
- **健康检查**：统计正常/异常服务数量
- **容量管理**：监控实例扩缩容情况

### 3.2 count_values - 值计数



**💡 独特价值**
不是简单计数，而是统计每个**具体数值**出现了多少次，类似做问卷调查的统计。

```promql
# 统计不同HTTP状态码各自出现的次数

count_values("status", http_status_code)

# 结果示例：

# {status="200"} 150  (状态码200出现了150次)

# {status="404"} 20   (状态码404出现了20次)  

# {status="500"} 5    (状态码500出现了5次)

```

**🎯 使用场景**
- **状态分布分析**：了解各种状态码的分布情况
- **版本统计**：统计不同软件版本的使用情况
- **配置分析**：分析不同配置项的分布

---

## 4. 🏷️ 分组聚合控制



### 4.1 by - 分组聚合



**💡 核心概念**
`by`就像Excel中的分组功能，按照指定的标签把数据分类统计。

**语法结构**
```promql
聚合函数(指标) by (标签1, 标签2, ...)
```

**实用示例**
```promql
# 按服务器分组，计算每台服务器的平均CPU

avg(cpu_usage) by (instance)

# 按环境分组，计算每个环境的总请求数

sum(http_requests_total) by (env)

# 按服务类型和环境分组

sum(memory_usage_bytes) by (service, env)
```

**📊 分组结果示例**
```
原始数据：
cpu_usage{instance="web1", env="prod"} = 80
cpu_usage{instance="web2", env="prod"} = 70
cpu_usage{instance="db1", env="test"} = 60

执行：sum(cpu_usage) by (env)

结果：
{env="prod"} 150    (web1+web2 = 80+70)
{env="test"} 60     (只有db1)
```

### 4.2 without - 排除分组



**💡 反向思维**
`without`与`by`相反，指定要**排除**的标签，保留其他所有标签。

```promql
# 排除instance标签，按其他标签分组

sum(http_requests_total) without (instance)

# 排除多个标签

avg(cpu_usage) without (instance, job)
```

**🎯 使用技巧**
- 当你想保留大部分标签，只排除少数几个时，用`without`更简洁
- 当你只想保留少数几个标签时，用`by`更明确

---

## 5. 🎯 排序类聚合操作



### 5.1 topk - 取前N名



**💡 实际用途**
找出"排行榜前N名"，比如CPU使用率最高的5台服务器。

```promql
# 找出CPU使用率最高的5台服务器

topk(5, cpu_usage)

# 找出请求量最大的3个API接口

topk(3, sum(http_requests_total) by (endpoint))

# 找出内存使用最多的10个容器

topk(10, container_memory_usage_bytes)
```

**🔍 结果解读**
```
执行：topk(3, cpu_usage)

可能的结果：
cpu_usage{instance="web3"} = 95
cpu_usage{instance="web1"} = 87  
cpu_usage{instance="db2"} = 82
```

### 5.2 bottomk - 取后N名



**💡 实际价值**
找出"表现最差的N个"，适合发现低利用率资源或异常情况。

```promql
# 找出CPU使用率最低的3台服务器

bottomk(3, cpu_usage)

# 找出响应时间最短的5个接口

bottomk(5, avg(http_request_duration_seconds) by (endpoint))
```

**🎯 应用场景**
- **资源优化**：找出利用率低的服务器，考虑回收
- **异常检测**：某些服务CPU突然变成0可能是故障
- **性能对比**：找出最快的接口作为性能基准

---

## 6. 📈 统计类聚合操作



### 6.1 quantile - 分位数计算



**💡 通俗解释**
分位数就像考试排名，90分位数意思是"90%的人都比这个分数低"。

**基础语法**
```promql
# 计算CPU使用率的95分位数

quantile(0.95, cpu_usage)

# 计算响应时间的50分位数（中位数）

quantile(0.5, http_request_duration_seconds)

# 计算内存使用的99分位数

quantile(0.99, memory_usage_bytes)
```

**📊 分位数含义对照表**

| **分位数** | **含义** | **适用场景** |
|-----------|---------|-------------|
| `0.5` (50%) | 中位数，一半高一半低 | 了解典型水平 |
| `0.95` (95%) | 95%的值都比这个低 | 发现异常峰值 |
| `0.99` (99%) | 99%的值都比这个低 | 极端情况分析 |

### 6.2 stddev/stdvar - 标准差和方差



**💡 实际意义**
- **标准差**：衡量数据的"离散程度"，值越大说明差异越大
- **方差**：标准差的平方，数学计算中常用

```promql
# 计算CPU使用率的标准差

stddev(cpu_usage)

# 计算响应时间的方差

stdvar(http_request_duration_seconds)
```

**🎯 应用价值**
- **标准差高**：服务器负载不均衡，需要优化
- **标准差低**：负载分布比较均匀，系统稳定

---

## 7. 🎛️ 聚合维度控制技巧



### 7.1 多维度分组策略



**🔸 单维度分组**
```promql
# 按环境分组

sum(cpu_usage) by (env)
# 结果：prod环境总CPU、test环境总CPU

```

**🔸 多维度分组**
```promql
# 按环境和服务类型分组

sum(cpu_usage) by (env, service)
# 结果：prod-web、prod-db、test-web、test-db的CPU

```

**🔸 分组聚合组合**
```promql
# 先按服务分组求平均，再求总体最大值

max(avg(cpu_usage) by (service))
```

### 7.2 维度控制最佳实践



**🎯 选择合适的分组策略**

```
场景1：监控整体资源使用
推荐：sum(memory_usage) by (env)
理由：按环境分组，便于环境间对比

场景2：发现问题服务器  
推荐：topk(5, cpu_usage)
理由：直接找出问题点，无需分组

场景3：服务性能分析
推荐：avg(response_time) by (service, env)
理由：按服务和环境双维度分析
```

### 7.3 常见分组维度



| **维度标签** | **用途** | **示例** |
|-------------|---------|---------|
| `instance` | 按具体服务器分组 | 找出问题机器 |
| `service` | 按服务类型分组 | 对比不同服务 |
| `env` | 按环境分组 | 生产/测试环境对比 |
| `job` | 按监控任务分组 | 不同采集任务分析 |

---

## 8. 🚀 实战应用场景



### 8.1 服务器监控场景



**📊 CPU使用率监控**
```promql
# 监控场景：CPU告警和分析


# 1. 整体平均CPU使用率

avg(cpu_usage)

# 2. 各环境CPU使用情况对比  

avg(cpu_usage) by (env)

# 3. 找出CPU最高的5台服务器

topk(5, cpu_usage)

# 4. CPU使用率95分位数（发现异常）

quantile(0.95, cpu_usage)
```

**🧠 分析思路**
1. 先看**整体平均**了解大致情况
2. 再看**环境分组**对比生产测试环境  
3. 用**topk**找出具体问题服务器
4. 用**分位数**发现是否有异常峰值

### 8.2 应用性能监控



**🌐 HTTP请求监控**
```promql
# API性能全面分析


# 1. 总请求量统计

sum(rate(http_requests_total[5m]))

# 2. 各API接口请求量排行

topk(10, sum(rate(http_requests_total[5m])) by (endpoint))

# 3. 平均响应时间

avg(http_request_duration_seconds)

# 4. 响应时间95分位数

quantile(0.95, http_request_duration_seconds)

# 5. 错误率统计

sum(rate(http_requests_total{status=~"5.."}[5m])) / 
sum(rate(http_requests_total[5m]))
```

### 8.3 容器集群监控



**🐳 Kubernetes监控示例**
```promql
# 容器资源监控


# 1. 各命名空间内存使用总量

sum(container_memory_usage_bytes) by (namespace)

# 2. 内存使用最高的10个Pod

topk(10, container_memory_usage_bytes)

# 3. 各节点的Pod数量统计

count(container_memory_usage_bytes) by (node)

# 4. CPU使用率分布情况

count_values("cpu_range", 
  round(rate(container_cpu_usage_seconds_total[5m]) * 100))
```

---

## 9. 📋 核心要点总结



### 9.1 必须掌握的核心概念



```
🔸 聚合操作本质：把多个时间序列合并成一个统计结果
🔸 分组控制：by指定保留标签，without指定排除标签
🔸 数值聚合：sum求和、avg平均、max/min最值
🔸 排序聚合：topk前N名、bottomk后N名
🔸 统计聚合：quantile分位数、count计数
🔸 维度控制：合理选择分组维度，平衡细节和概览
```

### 9.2 关键理解要点



**🔹 聚合操作的价值**
```
原始监控数据：海量、分散、难以理解
聚合后的结果：简洁、聚焦、易于决策

就像从"学生个人成绩单"到"班级统计报告"
```

**🔹 分组聚合的威力**
```
无分组：只能看到整体情况
有分组：能够多维度对比分析
分组选择：决定了分析的颗粒度和视角
```

**🔹 聚合操作符的选择**
```
关注总量 → 用sum
关注平均 → 用avg  
找问题点 → 用max/topk
看分布 → 用quantile
数数量 → 用count
```

### 9.3 实战应用指导



**🎯 监控告警设计**
- **基础告警**：使用avg/max检测异常值
- **趋势告警**：使用sum监控总量变化
- **排行告警**：使用topk关注最差的几个

**📊 仪表板设计**
- **概览页面**：显示整体平均值和总量
- **详情页面**：按维度分组展示具体情况
- **排行页面**：显示topk/bottomk结果

### 9.4 学习检查清单



- [ ] 理解聚合操作的基本概念和作用
- [ ] 掌握sum、avg、max、min的使用
- [ ] 会使用by和without进行分组控制
- [ ] 能够使用topk/bottomk找出极值
- [ ] 了解quantile分位数的含义和用法
- [ ] 会根据监控场景选择合适的聚合操作

**🔑 核心记忆技巧**
> **数值四剑客**：sum求和、avg平均、max最大、min最小
> **分组二选一**：by保留、without排除  
> **排序找极值**：topk最高、bottomk最低
> **统计看分布**：quantile分位数、count计总数

**💡 学习建议**
- 多在Prometheus界面中实际操作练习
- 结合具体的监控场景理解各个操作符
- 重点掌握分组聚合，这是最常用也最实用的功能