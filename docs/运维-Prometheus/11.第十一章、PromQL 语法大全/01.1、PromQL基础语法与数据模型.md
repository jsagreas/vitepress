---
title: 1、PromQL基础语法与数据模型
---
## 📚 目录

1. [Prometheus数据模型基础](#1-prometheus数据模型基础)
2. [时间序列的核心概念](#2-时间序列的核心概念)
3. [指标名称与标签系统](#3-指标名称与标签系统)
4. [PromQL的四种数据类型](#4-promql的四种数据类型)
5. [基础查询语法结构](#5-基础查询语法结构)
6. [标签匹配器详解](#6-标签匹配器详解)
7. [数据类型转换机制](#7-数据类型转换机制)
8. [实际应用示例](#8-实际应用示例)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🏗️ Prometheus数据模型基础


### 1.1 什么是Prometheus


**🔸 简单理解**
```
Prometheus就像一个专业的"数据收集员"：
- 定期去各个系统"问问情况"（采集监控数据）
- 把收集到的信息按时间顺序记录下来
- 当你想了解系统状态时，可以随时查询这些记录

就像医生定期测量病人的血压、心率一样
Prometheus定期收集服务器的CPU、内存、网络等状态
```

### 1.2 为什么需要时间序列数据


**💡 生活中的例子**
```
想象你在记录每天的天气：
日期        温度    湿度    风速
2024-01-01  15°C   60%    5m/s
2024-01-02  18°C   55%    3m/s  
2024-01-03  12°C   70%    8m/s

这就是时间序列数据的雏形：
- 有时间戳（什么时候）
- 有数值（具体数据）
- 有标识（什么指标）
```

### 1.3 Prometheus数据模型结构


```
Prometheus数据模型架构：

应用程序/系统
       ↓ 暴露指标
   监控端点(Endpoint)
       ↓ 采集数据  
   Prometheus服务器
       ↓ 存储数据
   时间序列数据库
       ↓ 查询分析
     PromQL查询
       ↓ 展示结果
   Grafana等可视化工具

核心理念：一切皆指标，指标皆时间序列
```

---

## 2. ⏰ 时间序列的核心概念


### 2.1 时间序列是什么


**🔸 通俗解释**
```
时间序列就像一个"数据日记本"：
- 每一页记录一个时间点的数据
- 按时间顺序排列
- 可以回看历史，分析趋势

例如记录服务器CPU使用率：
时间            CPU使用率
14:00:00        15.2%
14:00:15        18.6%  
14:00:30        22.1%
14:00:45        19.8%
```

### 2.2 时间序列的唯一标识


**🏷️ 标识规则**
```
每个时间序列都有唯一的"身份证"：

指标名称 + 标签组合 = 唯一时间序列

示例：
http_requests_total{method="GET", status="200", instance="web1"}
http_requests_total{method="GET", status="200", instance="web2"}  
http_requests_total{method="POST", status="200", instance="web1"}

虽然指标名称相同，但标签不同，所以是3个不同的时间序列
```

### 2.3 数据点的组成


**📊 数据点结构**
```
每个数据点包含两部分：
timestamp：时间戳（什么时候）
value：数值（具体数据）

格式：[timestamp, value]
示例：[1640995200, 85.6]
含义：在时间戳1640995200时，数值是85.6

就像体温记录：
[上午9点, 36.5°C]
[中午12点, 36.8°C]
[下午3点, 37.1°C]
```

---

## 3. 🏷️ 指标名称与标签系统


### 3.1 指标名称的作用


**🔸 指标名称规则**
```
指标名称就像"文件夹名称"，告诉我们这是什么类型的数据：

好的指标名称：
✅ cpu_usage_percent        # CPU使用率
✅ memory_usage_bytes       # 内存使用量
✅ http_requests_total      # HTTP请求总数
✅ database_connections     # 数据库连接数

不好的指标名称：
❌ data                     # 太模糊
❌ server_info             # 不明确
❌ status                  # 不具体
```

**💡 命名约定**
```
推荐的命名模式：
- 使用小写字母和下划线
- 以应用或功能开头：http_, mysql_, redis_
- 以单位或类型结尾：_total, _bytes, _seconds
- 描述要测量的内容：requests, errors, duration
```

### 3.2 标签系统详解


**🏷️ 标签的作用**
```
标签就像"属性标签"，用来细分同一类指标：

基础指标：http_requests_total
加上标签：
http_requests_total{method="GET"}      # GET请求
http_requests_total{method="POST"}     # POST请求
http_requests_total{status="200"}      # 成功请求
http_requests_total{status="404"}      # 404错误
```

**🔧 标签最佳实践**
```
好的标签设计：
✅ {instance="web-server-1"}     # 具体实例
✅ {environment="production"}    # 环境标识
✅ {version="v1.2.3"}           # 版本信息
✅ {region="us-east-1"}         # 地理位置

避免的标签设计：
❌ {user_id="12345"}            # 高基数标签
❌ {request_id="abc-def"}       # 唯一值标签
❌ {timestamp="1640995200"}     # 时间相关标签
```

### 3.3 标签基数问题


**⚠️ 重要概念：标签基数**
```
标签基数 = 标签值的数量

低基数（好）：
- environment: production, staging, development (3个值)
- method: GET, POST, PUT, DELETE (4个值)
- status: 200, 404, 500 (有限个值)

高基数（危险）：
- user_id: 可能有百万个不同用户
- ip_address: 可能有无数个IP
- session_id: 每次访问都不同

高基数会导致：
- 存储空间激增
- 查询性能下降
- 内存占用过大
```

---

## 4. 📊 PromQL的四种数据类型


### 4.1 瞬时向量（Instant Vector）


**🔸 最常用的数据类型**
```
瞬时向量就像"现在的快照"：
- 每个时间序列只有一个当前值
- 最新的数据点

示例查询：cpu_usage_percent
返回结果：
cpu_usage_percent{instance="server1"} 15.2
cpu_usage_percent{instance="server2"} 28.6
cpu_usage_percent{instance="server3"} 12.8

就像问"现在各个服务器的CPU使用率是多少？"
```

### 4.2 范围向量（Range Vector）


**📈 时间段数据**
```
范围向量就像"一段时间的记录"：
- 每个时间序列包含一段时间内的多个值
- 用于计算趋势和变化率

示例查询：cpu_usage_percent[5m]
返回结果：
cpu_usage_percent{instance="server1"}
15.2 @1640995200
14.8 @1640995215  
16.1 @1640995230
15.9 @1640995245

就像问"过去5分钟各个服务器的CPU使用率变化"
```

**⏰ 时间范围表示法**
| 表示法 | 含义 | 示例用途 |
|--------|------|----------|
| `[1m]` | 1分钟 | 短期波动分析 |
| `[5m]` | 5分钟 | 常用监控间隔 |
| `[1h]` | 1小时 | 趋势分析 |
| `[1d]` | 1天 | 日度对比 |
| `[1w]` | 1周 | 周期性分析 |

### 4.3 标量（Scalar）


**🔢 单个数值**
```
标量就是一个简单的数字：
- 没有标签
- 没有时间序列信息
- 通常用于计算和比较

示例：
- 100         # 纯数字
- 0.5         # 小数
- time()      # 当前时间戳函数返回标量
```

### 4.4 字符串（String）


**📝 文本值**
```
字符串在PromQL中用途有限：
- 主要用于标签匹配
- 不能直接用于数学运算

示例：
"production"     # 环境名称
"GET"           # HTTP方法
"error"         # 状态描述
```

---

## 5. 📝 基础查询语法结构


### 5.1 最简单的查询


**🔸 指标名称查询**
```
最基本的查询就是直接输入指标名称：

up
# 查询所有实例的存活状态

cpu_usage_percent  
# 查询所有实例的CPU使用率

memory_usage_bytes
# 查询所有实例的内存使用量
```

### 5.2 带标签过滤的查询


**🏷️ 标签选择器**
```
在指标名称后面加上标签条件：

up{instance="localhost:9090"}
# 只查询特定实例的存活状态

cpu_usage_percent{environment="production"}
# 只查询生产环境的CPU使用率

http_requests_total{method="GET", status="200"}  
# 查询GET方法且状态码为200的请求数
```

### 5.3 查询语法的组成部分


```
PromQL查询语法结构：

指标名称{标签选择器}[时间范围] offset 时间偏移

完整示例：
cpu_usage_percent{instance="server1",environment="prod"}[5m] offset 1h

解释：
- cpu_usage_percent：指标名称
- {instance="server1",environment="prod"}：标签过滤
- [5m]：获取过去5分钟的数据
- offset 1h：时间偏移，获取1小时前的数据
```

---

## 6. 🎯 标签匹配器详解


### 6.1 等值匹配（=）


**🔸 精确匹配**
```
使用等号进行精确匹配：

http_requests_total{method="GET"}
# method标签必须等于"GET"

cpu_usage_percent{instance="server1"}  
# instance标签必须等于"server1"

up{job="prometheus"}
# job标签必须等于"prometheus"
```

### 6.2 不等值匹配（!=）


**❌ 排除匹配**
```
使用不等号排除特定值：

http_requests_total{status!="200"}
# 排除状态码为200的请求

cpu_usage_percent{environment!="test"}
# 排除测试环境的数据

up{instance!="localhost:9090"}
# 排除本地实例
```

### 6.3 正则表达式匹配（=~）


**🔍 模式匹配**
```
使用正则表达式进行模式匹配：

http_requests_total{instance=~"web.*"}
# 匹配所有以"web"开头的实例

cpu_usage_percent{environment=~"prod|staging"}  
# 匹配生产环境或预发环境

up{job=~".*server.*"}
# 匹配job名称中包含"server"的所有任务
```

**📋 常用正则表达式模式**
| 模式 | 含义 | 示例 |
|------|------|------|
| `.*` | 匹配任意字符 | `=~"web.*"` 匹配web开头 |
| `a|b` | 匹配a或b | `=~"prod|test"` 匹配prod或test |
| `^abc` | 以abc开头 | `=~"^api"` 以api开头 |
| `abc$` | 以abc结尾 | `=~"server$"` 以server结尾 |

### 6.4 正则表达式不匹配（!~）


**🚫 模式排除**
```
排除符合正则表达式的值：

http_requests_total{instance!~"test.*"}
# 排除所有以"test"开头的实例

cpu_usage_percent{environment!~"dev|test"}
# 排除开发和测试环境

up{job!~".*backup.*"}  
# 排除job名称中包含"backup"的任务
```

### 6.5 多重标签匹配


**🔗 组合条件**
```
可以同时使用多个标签条件：

http_requests_total{
  method="GET",
  status="200", 
  instance=~"web.*"
}
# 同时满足：GET方法、200状态、web开头的实例

cpu_usage_percent{
  environment="production",
  region!="us-west",
  instance!~".*test.*"
}
# 生产环境、非美西地区、实例名不包含test
```

---

## 7. 🔄 数据类型转换机制


### 7.1 自动类型转换


**🔸 PromQL的智能转换**
```
PromQL会在需要时自动转换数据类型：

瞬时向量 → 标量：
- 当瞬时向量只包含一个时间序列时
- 函数需要标量参数时

范围向量 → 瞬时向量：
- 通过聚合函数：rate(), increase(), avg_over_time()
- 不能直接转换，必须通过函数
```

### 7.2 类型转换函数


**🔧 常用转换函数**
```
scalar() 函数：
- 将单值瞬时向量转换为标量
- 如果向量包含多个值，返回NaN

示例：
scalar(up{instance="localhost:9090"})
# 如果该实例存在且唯一，返回其值（0或1）
# 如果有多个实例或不存在，返回NaN
```

### 7.3 类型兼容性规则


**📋 运算兼容性**
| 左操作数 | 右操作数 | 结果类型 | 示例 |
|----------|----------|----------|------|
| 瞬时向量 | 标量 | 瞬时向量 | `cpu_usage * 100` |
| 瞬时向量 | 瞬时向量 | 瞬时向量 | `memory_used / memory_total` |
| 标量 | 标量 | 标量 | `60 * 60` |
| 范围向量 | - | 需要函数 | `rate(requests[5m])` |

### 7.4 常见类型错误


**❌ 避免的错误用法**
```
错误示例：
cpu_usage[5m] > 80
# 范围向量不能直接比较

正确用法：
avg_over_time(cpu_usage[5m]) > 80  
# 先用函数转换为瞬时向量

错误示例：
rate(cpu_usage)
# rate函数需要范围向量参数

正确用法：
rate(cpu_usage[5m])
# 提供范围向量参数
```

---

## 8. 💼 实际应用示例


### 8.1 系统监控查询


**🖥️ 基础系统指标**
```
CPU使用率查询：
cpu_usage_percent{instance="web-server-1"}

内存使用率查询：
(memory_used_bytes / memory_total_bytes) * 100

磁盘使用率查询：
disk_usage_percent{mountpoint="/", instance=~"web-.*"}

网络流量查询：
network_receive_bytes{device="eth0"}
```

### 8.2 应用监控查询


**🌐 Web应用指标**
```
HTTP请求总数：
http_requests_total

成功请求比例：
http_requests_total{status="200"} / 
http_requests_total * 100

错误率查询：
http_requests_total{status=~"5.*"} / 
http_requests_total * 100

响应时间查询：
http_request_duration_seconds{quantile="0.95"}
```

### 8.3 业务监控查询


**📊 业务指标示例**
```
在线用户数：
online_users_total{environment="production"}

订单数量：
orders_total{status="completed"}

支付成功率：
payment_success_total / payment_attempts_total * 100

数据库连接数：
database_connections{database="user_db"}
```

### 8.4 复杂查询示例


**🔍 组合查询**
```
查询过去5分钟平均CPU使用率超过80%的服务器：
avg_over_time(cpu_usage_percent[5m]) > 80

查询生产环境中内存使用率最高的3台服务器：
topk(3, memory_usage_percent{environment="production"})

查询HTTP 5xx错误率超过1%的服务：
(
  sum(rate(http_requests_total{status=~"5.*"}[5m])) by (service) /
  sum(rate(http_requests_total[5m])) by (service)
) * 100 > 1
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 时间序列：按时间顺序排列的数据点集合
🔸 指标名称：标识数据类型的名称，如cpu_usage_percent
🔸 标签：用于细分和过滤时间序列的键值对
🔸 瞬时向量：最新时间点的数据快照
🔸 范围向量：一段时间内的数据集合
🔸 标签匹配：通过标签条件过滤时间序列
```

### 9.2 关键理解要点


**🔹 数据模型的核心逻辑**
```
理解层次：
1. 指标名称确定数据类型
2. 标签组合确定具体的时间序列
3. 时间戳确定数据点的时间
4. 数值确定具体的测量值

记忆要点：
- 一个指标可以有多个时间序列
- 每个时间序列由标签组合唯一标识
- 查询时先选择指标，再用标签过滤
```

**🔹 查询语法的基本规律**
```
语法模式：
指标名称{标签条件}[时间范围]

使用原则：
- 简单查询：只用指标名称
- 精确查询：添加等值标签匹配
- 模糊查询：使用正则表达式匹配
- 历史查询：添加时间范围和偏移
```

### 9.3 实践建议


**💡 新手学习路径**
```
第一步：理解概念
✅ 明确时间序列的含义
✅ 理解指标和标签的关系
✅ 掌握四种数据类型的区别

第二步：练习基础查询
✅ 直接查询指标名称
✅ 使用标签进行过滤
✅ 尝试不同的匹配器

第三步：实际应用
✅ 查询系统监控指标
✅ 分析应用性能数据
✅ 编写业务监控查询
```

**🔧 常见问题预防**
```
避免高基数标签：
❌ 不要用用户ID、IP地址等唯一值作为标签
✅ 使用环境、地区、服务名等有限值标签

注意数据类型：
❌ 不要对范围向量直接运算
✅ 先用函数转换为瞬时向量

合理使用正则：
❌ 避免过于复杂的正则表达式
✅ 优先使用简单的等值匹配
```

### 9.4 学习验证清单


```
自我检查项目：

基础概念理解：
□ 能解释什么是时间序列
□ 知道指标名称和标签的作用
□ 理解四种数据类型的区别

查询语法掌握：
□ 能写出基本的指标查询
□ 会使用各种标签匹配器
□ 理解时间范围的作用

实际应用能力：
□ 能查询常见的系统指标
□ 会分析监控数据的含义
□ 能发现异常的监控数值
```

**核心记忆要点**：
- Prometheus用时间序列存储所有监控数据
- 指标名称+标签组合=唯一时间序列
- PromQL四种数据类型各有用途
- 标签匹配器是查询过滤的核心工具
- 理解数据模型是学好PromQL的基础