---
title: 8、实战查询模式与最佳实践
---
## 📚 目录

1. [系统资源监控查询](#1-系统资源监控查询)
2. [应用性能监控查询](#2-应用性能监控查询)
3. [业务指标监控查询](#3-业务指标监控查询)
4. [告警规则查询模式](#4-告警规则查询模式)
5. [查询性能优化最佳实践](#5-查询性能优化最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 💻 系统资源监控查询


### 1.1 CPU使用率计算模式


**🔸 什么是CPU使用率监控**
CPU使用率就像是查看你的电脑有多忙碌。想象CPU是一个工人，使用率就是这个工人的忙碌程度，0%表示完全空闲，100%表示忙得不可开交。

**💡 核心计算原理**
```
CPU使用率计算思路：
总时间 - 空闲时间 = 忙碌时间
忙碌时间 ÷ 总时间 × 100% = CPU使用率
```

**⚡ 实战查询模式**

**基础CPU使用率计算：**
```promql
# 计算CPU总体使用率（排除idle空闲时间）
100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
```

**按节点分别计算CPU使用率：**
```promql
# 每个服务器的CPU使用率
100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
```

**🎯 实用场景示例**
```
监控目标：Web服务器集群CPU使用情况
查询意图：当CPU超过80%时需要扩容
实际应用：设置告警阈值，自动化运维决策
```

### 1.2 内存使用率监控


**🔸 内存监控的含义**
内存使用率就像是查看你的书桌有多满。可用内存是空余的桌面空间，已用内存是已经放置的物品。

**📊 内存计算公式**
```
内存使用率 = (总内存 - 可用内存) ÷ 总内存 × 100%
可用内存 = 空闲内存 + 缓存 + 缓冲区
```

**实战查询模式：**

**系统可用内存百分比：**
```promql
# 计算可用内存百分比
(node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100
```

**内存使用率计算：**
```promql
# 内存使用率（更精确的计算）
100 - ((node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100)
```

**🎯 监控要点**
```
正常状态：内存使用率 < 80%
注意状态：内存使用率 80-90%
危险状态：内存使用率 > 90%
```

### 1.3 磁盘使用率监控


**🔸 磁盘监控重要性**
磁盘使用率像是查看你的硬盘还有多少空间。磁盘满了，系统就无法正常工作，就像房间满了就没地方放东西一样。

**实战查询模式：**

**磁盘使用率计算：**
```promql
# 磁盘使用率百分比
100 - ((node_filesystem_avail_bytes / node_filesystem_size_bytes) * 100)
```

**排除特殊文件系统的磁盘监控：**
```promql
# 只监控真实的磁盘分区（排除临时文件系统）
100 - ((node_filesystem_avail_bytes{fstype!~"tmpfs|fuse.lxcfs"} / 
        node_filesystem_size_bytes{fstype!~"tmpfs|fuse.lxcfs"}) * 100)
```

### 1.4 网络流量速率计算


**🔸 网络流量监控概念**
网络流量速率就像是监控水管里水的流速。我们需要知道每秒钟有多少数据通过网络接口。

**实战查询模式：**

**网络接收速率（下载速度）：**
```promql
# 每秒接收的字节数（转换为MB/s）
rate(node_network_receive_bytes_total[5m]) / 1024 / 1024
```

**网络发送速率（上传速度）：**
```promql
# 每秒发送的字节数（转换为MB/s）
rate(node_network_transmit_bytes_total[5m]) / 1024 / 1024
```

**网络总流量速率：**
```promql
# 上传+下载的总速率
(rate(node_network_receive_bytes_total[5m]) + 
 rate(node_network_transmit_bytes_total[5m])) / 1024 / 1024
```

---

## 2. 🚀 应用性能监控查询


### 2.1 HTTP请求速率统计


**🔸 HTTP请求速率含义**
HTTP请求速率就是统计网站每秒钟处理多少个用户访问。就像统计商店每分钟有多少顾客进门一样。

**实战查询模式：**

**总体HTTP请求速率（QPS）：**
```promql
# 每秒HTTP请求数量
sum(rate(http_requests_total[5m]))
```

**按状态码分类的请求速率：**
```promql
# 按HTTP状态码分组的请求速率
sum by (status) (rate(http_requests_total[5m]))
```

**按接口路径分类的请求速率：**
```promql
# 最繁忙的API接口
topk(10, sum by (path) (rate(http_requests_total[5m])))
```

### 2.2 错误率与成功率计算


**🔸 错误率监控重要性**
错误率就像是统计生产线上的次品率。错误率高说明系统有问题，需要及时处理。

**📊 错误率计算公式**
```
错误率 = 错误请求数 ÷ 总请求数 × 100%
成功率 = 成功请求数 ÷ 总请求数 × 100%
```

**实战查询模式：**

**HTTP错误率计算：**
```promql
# 计算5xx错误率（服务器内部错误）
sum(rate(http_requests_total{status=~"5.."}[5m])) / 
sum(rate(http_requests_total[5m])) * 100
```

**成功率计算：**
```promql
# 计算2xx成功率
sum(rate(http_requests_total{status=~"2.."}[5m])) / 
sum(rate(http_requests_total[5m])) * 100
```

**🎯 监控标准参考**
| 服务等级 | 成功率要求 | 错误率上限 | 监控建议 |
|---------|-----------|-----------|----------|
| **高可用** | `≥ 99.9%` | `< 0.1%` | 严格监控，立即告警 |
| **标准** | `≥ 99%` | `< 1%` | 正常监控，快速响应 |
| **一般** | `≥ 95%` | `< 5%` | 基础监控，定期检查 |

### 2.3 响应时间分位数分析


**🔸 响应时间分位数含义**
响应时间分位数就像是统计考试成绩分布。95分位数表示95%的请求响应时间都在这个值以下。

**实战查询模式：**

**响应时间95分位数：**
```promql
# 95%的请求响应时间都在这个值以下
histogram_quantile(0.95, 
  sum by (le) (rate(http_request_duration_seconds_bucket[5m])))
```

**多分位数对比分析：**
```promql
# 50%、90%、95%、99%分位数对比
histogram_quantile(0.50, sum by (le) (rate(http_request_duration_seconds_bucket[5m]))) and
histogram_quantile(0.90, sum by (le) (rate(http_request_duration_seconds_bucket[5m]))) and  
histogram_quantile(0.95, sum by (le) (rate(http_request_duration_seconds_bucket[5m]))) and
histogram_quantile(0.99, sum by (le) (rate(http_request_duration_seconds_bucket[5m])))
```

**🎯 分位数分析技巧**
```
P50（中位数）：一半用户的体验水平
P90：大多数用户的体验水平  
P95：优秀体验的基准线
P99：极端情况下的体验
```

### 2.4 延迟分布分析


**实战查询模式：**

**平均响应时间：**
```promql
# 计算平均响应时间
sum(rate(http_request_duration_seconds_sum[5m])) /
sum(rate(http_request_duration_seconds_count[5m]))
```

**超时请求比例：**
```promql
# 超过2秒的请求比例
sum(rate(http_request_duration_seconds_bucket{le="2"}[5m])) /
sum(rate(http_request_duration_seconds_count[5m])) * 100
```

---

## 3. 📈 业务指标监控查询


### 3.1 服务可用性计算


**🔸 可用性概念理解**
服务可用性就像是商店的营业时间比例。如果一天24小时中有23小时正常营业，可用性就是95.8%。

**实战查询模式：**

**基于健康检查的可用性：**
```promql
# 计算服务可用性百分比
avg(up) * 100
```

**基于成功请求的可用性：**
```promql
# 基于HTTP成功率的可用性
sum(rate(http_requests_total{status=~"[23].."}[5m])) /
sum(rate(http_requests_total[5m])) * 100
```

### 3.2 QPS查询每秒请求数


**🔸 QPS的业务意义**
QPS（Queries Per Second）表示系统每秒能处理多少个请求，就像是收银台每分钟能服务多少个顾客。

**实战查询模式：**

**实时QPS计算：**
```promql
# 当前每秒请求数
sum(rate(http_requests_total[1m]))
```

**峰值QPS分析：**
```promql
# 过去24小时的QPS峰值
max_over_time(sum(rate(http_requests_total[5m]))[24h:])
```

**🎯 QPS性能参考**
```
个人博客：    10-100 QPS
企业官网：    100-1,000 QPS  
电商平台：    1,000-10,000 QPS
大型网站：    10,000+ QPS
```

---

## 4. 🚨 告警规则查询模式


### 4.1 告警规则设计原则


**🔸 告警规则的作用**
告警规则就像是安装在家里的烟雾报警器，当发现异常情况时自动通知我们。

**⚡ 告警规则最佳实践**

**CPU使用率告警：**
```yaml
# CPU使用率超过80%持续5分钟
- alert: HighCPUUsage
  expr: 100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "CPU使用率过高"
    description: "CPU使用率已达到{{ $value }}%"
```

**内存使用率告警：**
```yaml
# 内存使用率超过90%
- alert: HighMemoryUsage  
  expr: 100 - ((node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100) > 90
  for: 2m
  labels:
    severity: critical
```

**HTTP错误率告警：**
```yaml
# 5分钟内错误率超过5%
- alert: HighErrorRate
  expr: sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) * 100 > 5
  for: 5m
```

### 4.2 告警级别分类


**📊 告警严重程度分级**
| 级别 | 含义 | 响应时间 | 典型场景 |
|------|------|----------|----------|
| **Critical** | `严重` | `立即处理` | 服务完全不可用 |
| **Warning** | `警告` | `30分钟内` | 性能下降但可用 |
| **Info** | `信息` | `工作时间内` | 轻微异常或提醒 |

---

## 5. ⚡ 查询性能优化最佳实践


### 5.1 查询性能优化技巧


**🔸 为什么需要优化查询**
查询优化就像是优化开车路线，选择更高效的路径可以更快到达目的地，减少等待时间。

**💡 核心优化原则**

**1. 合理选择时间范围：**
```promql
# 推荐：使用合适的时间窗口
rate(http_requests_total[5m])

# 避免：时间窗口过大造成计算压力
rate(http_requests_total[1h])  # 通常不必要
```

**2. 有效使用标签过滤：**
```promql
# 推荐：在查询开始就过滤
http_requests_total{service="api", status="200"}

# 避免：查询后再过滤
http_requests_total and on() http_requests_total{service="api"}
```

**3. 避免高基数标签：**
```promql
# 推荐：使用低基数标签分组
sum by (status) (rate(http_requests_total[5m]))

# 避免：使用高基数标签（如用户ID）
sum by (user_id) (rate(http_requests_total[5m]))  # 可能有百万个用户
```

### 5.2 常见查询错误避免


**🚨 常见错误与解决方案**

**错误1：忘记使用rate()函数**
```promql
# 错误：直接使用counter值
http_requests_total

# 正确：使用rate计算速率  
rate(http_requests_total[5m])
```

**错误2：时间窗口选择不当**
```promql
# 错误：窗口太小，数据波动大
rate(http_requests_total[30s])

# 正确：窗口适中，数据平稳
rate(http_requests_total[5m])
```

**错误3：标签不匹配**
```promql
# 错误：标签不匹配的运算
cpu_usage + memory_usage  # 不同instance的数据无法匹配

# 正确：确保标签匹配
cpu_usage + on(instance) memory_usage
```

### 5.3 仪表板查询优化


**🎯 仪表板优化建议**

**1. 查询频率优化：**
```
实时监控：    15-30秒刷新
历史分析：    1-5分钟刷新  
长期趋势：    5-15分钟刷新
```

**2. 数据聚合优化：**
```promql
# 推荐：先聚合再展示
sum by (cluster) (rate(http_requests_total[5m]))

# 避免：展示过多时间序列
rate(http_requests_total[5m])  # 可能返回数千条序列
```

**3. 查询缓存利用：**
```
相同查询：    复用结果，减少计算
时间对齐：    使用整分钟时间点
批量查询：    合并多个相关查询
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心查询模式


```
🔸 系统监控：CPU、内存、磁盘、网络的标准计算公式
🔸 应用监控：QPS、错误率、响应时间的分析方法
🔸 业务监控：可用性、成功率、分位数的计算技巧
🔸 告警规则：合理的阈值设置和告警级别分类
🔸 性能优化：查询效率和准确性的平衡技巧
```

### 6.2 关键理解要点


**🔹 监控查询的核心思维**
```
目标导向：先明确监控目的，再设计查询
数据理解：理解指标含义，选择合适的聚合方式
时间维度：考虑数据的时效性和历史趋势
标签利用：充分利用标签进行分组和过滤
```

**🔹 实战应用技巧**
```
由简到复：从基础查询开始，逐步添加复杂逻辑
测试验证：在生产环境使用前充分测试查询结果
文档记录：为复杂查询添加注释说明
持续优化：根据实际使用情况调整查询和告警
```

### 6.3 实际应用价值


**💡 监控体系建设**
- **基础监控**：建立完整的系统资源监控
- **应用监控**：构建应用性能监控体系
- **业务监控**：设计关键业务指标监控
- **告警体系**：建立分级告警和处理流程

**🎯 运维效率提升**
- **问题发现**：及时发现系统和应用异常
- **根因分析**：通过监控数据快速定位问题
- **容量规划**：基于历史数据进行资源规划
- **性能优化**：识别性能瓶颈，指导优化方向

**🔧 实践建议**
- **渐进式部署**：从核心指标开始，逐步完善监控
- **团队协作**：开发和运维团队共同设计监控指标
- **持续改进**：定期回顾和优化监控规则
- **知识分享**：建立监控知识库和最佳实践文档

**核心记忆**：
- 监控查询以业务目标为导向，先理解再查询
- 系统监控重点关注资源使用率和可用性
- 应用监控重点关注性能指标和错误率
- 告警规则要平衡敏感性和稳定性
- 查询优化要兼顾准确性和性能