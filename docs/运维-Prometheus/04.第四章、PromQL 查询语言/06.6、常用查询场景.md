---
title: 6、常用查询场景
---
## 📚 目录

1. [CPU 利用率计算](#1-CPU-利用率计算)
2. [内存使用率查询](#2-内存使用率查询)
3. [磁盘 IO 监控](#3-磁盘-IO-监控)
4. [网络流量统计](#4-网络流量统计)
5. [请求成功率计算](#5-请求成功率计算)
6. [响应延迟分析](#6-响应延迟分析)
7. [错误率监控](#7-错误率监控)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔥 CPU 利用率计算


### 1.1 什么是CPU利用率监控


**简单理解**：想象你的电脑CPU就像一个工人，CPU利用率就是这个工人的忙碌程度。0%表示完全闲着，100%表示忙得不可开交。

```
CPU状态就像工人的工作状态：
😴 idle     → 闲着没事做
🏃 user     → 在干正经工作（用户程序）
👨‍💼 system  → 在处理管理工作（系统任务）
⏳ iowait   → 等待其他人送材料（等待磁盘IO）
```

### 1.2 基础CPU利用率查询


**🔸 单个实例CPU使用率**
```promql
# 计算最近1分钟的CPU使用率
100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[1m])) * 100)
```

**理解这个公式**：
- `node_cpu_seconds_total{mode="idle"}` → 获取CPU空闲时间
- `rate(...[1m])` → 计算1分钟内的变化率（每秒增长多少）
- `avg by (instance)` → 按机器分组取平均值
- `100 - ...` → 用100%减去空闲率，得到使用率

**🔸 所有CPU核心的平均使用率**
```promql
# 获取整个集群的CPU平均使用率
avg(100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[1m])) * 100))
```

### 1.3 更细粒度的CPU监控


**💡 分别监控不同类型的CPU使用**
```promql
# 用户程序占用的CPU
avg by (instance) (rate(node_cpu_seconds_total{mode="user"}[1m])) * 100

# 系统内核占用的CPU  
avg by (instance) (rate(node_cpu_seconds_total{mode="system"}[1m])) * 100

# 等待IO的时间占比
avg by (instance) (rate(node_cpu_seconds_total{mode="iowait"}[1m])) * 100
```

**什么时候用这些查询**：
- **user高**：可能有程序在大量计算
- **system高**：可能系统负载重，或者有很多系统调用
- **iowait高**：可能磁盘太慢，程序在等数据

### 1.4 CPU告警的典型场景


| 告警场景 | **查询语句** | **含义解释** |
|---------|-------------|-------------|
| 🔴 **CPU过高** | `cpu_usage > 80` | CPU使用率超过80%，服务器可能过载 |
| 🟡 **CPU持续偏高** | `cpu_usage > 60 for 5m` | CPU连续5分钟超过60%，需要关注 |
| 🟠 **IO等待过多** | `iowait > 30` | 超过30%时间在等IO，磁盘可能有问题 |

---

## 2. 💾 内存使用率查询


### 2.1 内存监控的基本概念


**内存就像你的桌子**：
- **总内存**：桌子的总面积
- **已用内存**：桌子上放东西占用的面积  
- **可用内存**：桌子上还能放东西的面积
- **缓存**：临时放在桌子边缘，需要时能快速拿到的东西

```
Linux内存使用情况示意：
┌─────────────────────────────────────┐
│ 总内存 (Total Memory)                │
├─────────────┬───────────┬───────────┤
│  应用程序    │   缓存     │   空闲    │
│  (Used)     │ (Cache)   │  (Free)   │
└─────────────┴───────────┴───────────┘
```

### 2.2 基础内存使用率查询


**🔸 简单的内存使用率**
```promql
# 计算内存使用率（百分比）
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100
```

**为什么这样算**：
- `MemTotal` 是总内存大小
- `MemAvailable` 是真正可用的内存（包括可以释放的缓存）
- 用1减去可用率，就得到使用率

**🔸 更精确的内存计算**
```promql
# 排除缓存和缓冲区的实际使用内存
((node_memory_MemTotal_bytes - node_memory_MemFree_bytes - node_memory_Buffers_bytes - node_memory_Cached_bytes) / node_memory_MemTotal_bytes) * 100
```

### 2.3 内存相关的重要指标


**📊 内存状态分解查询**
```promql
# 总内存大小（GB）
node_memory_MemTotal_bytes / 1024 / 1024 / 1024

# 真正空闲的内存（GB）
node_memory_MemFree_bytes / 1024 / 1024 / 1024

# 用作缓存的内存（GB）  
node_memory_Cached_bytes / 1024 / 1024 / 1024

# 交换分区使用情况
(node_memory_SwapTotal_bytes - node_memory_SwapFree_bytes) / node_memory_SwapTotal_bytes * 100
```

### 2.4 内存告警场景


> **💡 理解内存告警的关键**
> 
> 内存和CPU不同，内存满了程序就会崩溃或者变得极慢。所以内存告警比CPU告警更紧急。

| 严重程度 | **阈值** | **说明** |
|---------|---------|---------|
| 🟢 **正常** | `< 70%` | 内存使用健康，无需担心 |
| 🟡 **注意** | `70-85%` | 需要关注，但还不紧急 |
| 🟠 **警告** | `85-95%` | 比较危险，应该处理 |
| 🔴 **紧急** | `> 95%` | 非常危险，可能影响服务 |

---

## 3. 💿 磁盘 IO 监控


### 3.1 磁盘IO监控的意义


**磁盘IO就像高速公路的车流量**：
- **读取**：从磁盘拿数据，就像从仓库运货出来
- **写入**：往磁盘存数据，就像往仓库运货进去
- **IOPS**：每秒能处理多少次读写操作
- **带宽**：每秒能传输多少数据

```
磁盘IO流程示意：
程序 ←→ [内存缓存] ←→ [磁盘存储]
      ↑             ↑
   快速访问      相对较慢
```

### 3.2 磁盘IO基础查询


**🔸 磁盘读写速率**
```promql
# 磁盘读取速率（每秒字节数）
rate(node_disk_read_bytes_total[1m])

# 磁盘写入速率（每秒字节数）  
rate(node_disk_written_bytes_total[1m])

# 转换为易读的MB/s
rate(node_disk_read_bytes_total[1m]) / 1024 / 1024
```

**🔸 磁盘IOPS统计**
```promql
# 每秒读操作次数
rate(node_disk_reads_completed_total[1m])

# 每秒写操作次数
rate(node_disk_writes_completed_total[1m])

# 总IOPS
rate(node_disk_reads_completed_total[1m]) + rate(node_disk_writes_completed_total[1m])
```

### 3.3 磁盘性能分析


**⚡ 磁盘利用率和延迟**
```promql
# 磁盘利用率（百分比）
rate(node_disk_io_time_seconds_total[1m]) * 100

# 平均读延迟（毫秒）
rate(node_disk_read_time_seconds_total[1m]) / rate(node_disk_reads_completed_total[1m]) * 1000

# 平均写延迟（毫秒）
rate(node_disk_write_time_seconds_total[1m]) / rate(node_disk_writes_completed_total[1m]) * 1000
```

**理解延迟指标**：
- **<5ms**：SSD表现很好
- **5-10ms**：正常范围
- **>20ms**：可能有性能问题
- **>100ms**：严重性能问题

### 3.4 磁盘空间监控


**📊 磁盘空间使用率**
```promql
# 磁盘空间使用率
(1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100

# 剩余空间（GB）
node_filesystem_avail_bytes / 1024 / 1024 / 1024

# 按挂载点查看使用率
(1 - (node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"})) * 100
```

---

## 4. 🌐 网络流量统计


### 4.1 网络监控基础概念


**网络就像水管系统**：
- **入口流量**：从外面流进来的水
- **出口流量**：往外面流出去的水
- **带宽**：水管的粗细，决定最大流量
- **错误包**：水管里的杂质

```
网络流量方向示意：
外网 ──[入口流量]──> 服务器 ──[出口流量]──> 外网
     ←──[响应流量]──         ←──[请求流量]──
```

### 4.2 基础网络流量查询


**🔸 网络接收和发送速率**
```promql
# 网络接收速率（字节/秒）
rate(node_network_receive_bytes_total[1m])

# 网络发送速率（字节/秒）
rate(node_network_transmit_bytes_total[1m])

# 转换为Mbps (兆位每秒)
rate(node_network_receive_bytes_total[1m]) * 8 / 1024 / 1024
```

**🔸 网络包统计**
```promql
# 接收包速率（包/秒）
rate(node_network_receive_packets_total[1m])

# 发送包速率（包/秒）
rate(node_network_transmit_packets_total[1m])
```

### 4.3 网络错误监控


**⚠️ 网络错误和丢包**
```promql
# 接收错误率
rate(node_network_receive_errs_total[1m]) / rate(node_network_receive_packets_total[1m]) * 100

# 发送错误率  
rate(node_network_transmit_errs_total[1m]) / rate(node_network_transmit_packets_total[1m]) * 100

# 丢包率
rate(node_network_receive_drop_total[1m]) / rate(node_network_receive_packets_total[1m]) * 100
```

**错误率含义**：
- **0-0.01%**：网络状况很好
- **0.01-0.1%**：可以接受的范围
- **>0.1%**：可能有网络问题
- **>1%**：网络状况很差

### 4.4 网络接口监控


**📡 按网络接口分别监控**
```promql
# 指定网卡的流量
rate(node_network_receive_bytes_total{device="eth0"}[1m])

# 排除本地回环接口
rate(node_network_receive_bytes_total{device!="lo"}[1m])

# 网络接口状态
node_network_up{device!="lo"}
```

---

## 5. ✅ 请求成功率计算


### 5.1 成功率监控的重要性


**成功率就像餐厅的服务质量**：
- **100%成功**：每个客人都满意而归
- **90%成功**：10个客人中有1个不满意
- **50%成功**：一半客人不满意，餐厅要倒闭了

```
HTTP状态码分类：
┌─────────────────┬─────────────────┐
│   成功请求      │    失败请求      │
├─────────────────┼─────────────────┤
│ 2xx (成功)      │ 4xx (客户端错误) │
│ 200 OK          │ 400 Bad Request │
│ 201 Created     │ 404 Not Found   │
│ 204 No Content  │ 401 Unauthorized│
├─────────────────┼─────────────────┤
│                 │ 5xx (服务器错误) │
│                 │ 500 Server Error│
│                 │ 503 Unavailable │
└─────────────────┴─────────────────┘
```

### 5.2 HTTP请求成功率查询


**🔸 基础成功率计算**
```promql
# HTTP请求总体成功率
sum(rate(http_requests_total{status=~"2.."}[1m])) / sum(rate(http_requests_total[1m])) * 100
```

**理解这个查询**：
- `status=~"2.."` 表示所有2开头的状态码（成功）
- `sum(rate(...[1m]))` 计算每秒的请求速率然后求和
- 成功请求除以总请求得到成功率

**🔸 按服务分别计算成功率**
```promql
# 每个服务的成功率
sum(rate(http_requests_total{status=~"2.."}[1m])) by (service) / sum(rate(http_requests_total[1m])) by (service) * 100
```

### 5.3 不同维度的成功率分析


**📊 按状态码类型分析**
```promql
# 4xx错误率（客户端问题）
sum(rate(http_requests_total{status=~"4.."}[1m])) / sum(rate(http_requests_total[1m])) * 100

# 5xx错误率（服务器问题）
sum(rate(http_requests_total{status=~"5.."}[1m])) / sum(rate(http_requests_total[1m])) * 100

# 超时错误率
sum(rate(http_requests_total{status="408"}[1m])) / sum(rate(http_requests_total[1m])) * 100
```

### 5.4 成功率告警设置


> **🎯 成功率告警的黄金法则**
> 
> - **>99.9%**：优秀服务
> - **99-99.9%**：良好服务  
> - **95-99%**：需要改进
> - **<95%**：用户体验很差

| 告警级别 | **成功率阈值** | **持续时间** | **处理优先级** |
|---------|---------------|-------------|---------------|
| 🟡 **警告** | `< 99%` | `2分钟` | 需要关注 |
| 🟠 **紧急** | `< 95%` | `1分钟` | 立即处理 |
| 🔴 **严重** | `< 90%` | `30秒` | 紧急响应 |

---

## 6. ⏱️ 响应延迟分析


### 6.1 什么是响应延迟


**延迟就像排队等餐**：
- **平均延迟**：所有人平均等了多久
- **P95延迟**：95%的人等餐时间都在这个数字以内
- **P99延迟**：99%的人等餐时间都在这个数字以内

```
延迟分布示意图：
用户数量
  ↑
  │     ╭─╮
  │   ╭─╯   ╰─╮    
  │ ╭─╯       ╰─╮
  └─╯───────────╰──→ 响应时间
   快  平均 P95 P99 很慢
```

**为什么P95、P99比平均值重要**：
- 平均值会被极值"拉偏"
- P95告诉你大部分用户的真实体验
- P99帮你发现系统的"坏情况"

### 6.2 基础延迟查询


**🔸 平均响应时间**
```promql
# HTTP请求平均延迟（秒）
rate(http_request_duration_seconds_sum[1m]) / rate(http_request_duration_seconds_count[1m])

# 转换为毫秒
rate(http_request_duration_seconds_sum[1m]) / rate(http_request_duration_seconds_count[1m]) * 1000
```

**🔸 分位数延迟查询**
```promql
# P95延迟（95%的请求都在这个时间内完成）
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[1m]))

# P99延迟（99%的请求都在这个时间内完成）
histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[1m]))

# P50延迟（中位数，一半请求的延迟）
histogram_quantile(0.50, rate(http_request_duration_seconds_bucket[1m]))
```

### 6.3 延迟分析的不同维度


**📈 按服务和接口分析**
```promql
# 每个服务的P95延迟
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[1m])) by (service, le))

# 每个API端点的延迟
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[1m])) by (endpoint, le))

# 按HTTP方法分析
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[1m])) by (method, le))
```

### 6.4 延迟告警的设置标准


**⏰ 不同服务类型的延迟标准**

| 服务类型 | **P95标准** | **P99标准** | **用户感知** |
|---------|------------|------------|-------------|
| **API接口** | `< 200ms` | `< 500ms` | 响应迅速 |
| **页面加载** | `< 500ms` | `< 1s` | 体验良好 |
| **数据库查询** | `< 100ms` | `< 200ms` | 性能优秀 |
| **文件上传** | `< 2s` | `< 5s` | 可以接受 |

---

## 7. 🚨 错误率监控


### 7.1 错误率监控的全景图


**错误就像餐厅的服务问题**：
- **应用错误**：厨师做菜失败
- **基础设施错误**：停电、断网
- **依赖服务错误**：供应商出问题
- **用户错误**：客人点了不存在的菜

```
错误分类体系：
┌─────────────────────────────────────┐
│             全部错误                 │
├─────────────────┬───────────────────┤
│   应用层错误     │   基础设施错误     │
├─────────────────┼───────────────────┤
│ • 代码bug       │ • 服务器宕机       │
│ • 逻辑错误       │ • 网络故障        │
│ • 数据问题       │ • 磁盘满了        │
├─────────────────┼───────────────────┤
│   依赖服务错误   │   用户输入错误     │
│ • 数据库连接失败  │ • 参数不正确      │
│ • 第三方API故障  │ • 权限不足        │
└─────────────────┴───────────────────┘
```

### 7.2 HTTP错误率监控


**🔸 按错误类型分类**
```promql
# 4xx错误率（用户问题）
sum(rate(http_requests_total{status=~"4.."}[1m])) / sum(rate(http_requests_total[1m])) * 100

# 5xx错误率（服务器问题）  
sum(rate(http_requests_total{status=~"5.."}[1m])) / sum(rate(http_requests_total[1m])) * 100

# 具体错误码监控
sum(rate(http_requests_total{status="500"}[1m])) / sum(rate(http_requests_total[1m])) * 100
```

**🔸 应用程序错误监控**
```promql
# 应用程序异常率
rate(application_exceptions_total[1m])

# 数据库连接错误
rate(database_connection_errors_total[1m])

# 超时错误
rate(request_timeout_total[1m])
```

### 7.3 错误率的黄金指标


**📊 SRE的错误率黄金标准**

| 错误类型 | **可接受范围** | **需要关注** | **紧急处理** |
|---------|---------------|-------------|-------------|
| **总体错误率** | `< 0.1%` | `0.1-1%` | `> 1%` |
| **5xx错误率** | `< 0.01%` | `0.01-0.1%` | `> 0.1%` |
| **超时错误** | `< 0.05%` | `0.05-0.5%` | `> 0.5%` |

### 7.4 错误趋势分析


**📈 错误增长趋势监控**
```promql
# 错误率增长趋势（与1小时前对比）
(sum(rate(http_requests_total{status=~"5.."}[1m])) / sum(rate(http_requests_total[1m]))) /
(sum(rate(http_requests_total{status=~"5.."}[1m] offset 1h)) / sum(rate(http_requests_total[1m] offset 1h)))

# 错误数量激增检测
increase(http_requests_total{status=~"5.."}[5m]) > 100
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的查询模式


```
🔸 CPU监控：理解不同CPU模式的含义，重点关注总体使用率
🔸 内存监控：区分真实使用和缓存，关注可用内存
🔸 磁盘IO：监控IOPS、带宽、延迟三个维度
🔸 网络流量：注意入出流量平衡，关注错误率
🔸 成功率：以业务视角看服务质量
🔸 延迟分析：P95/P99比平均值更重要
🔸 错误监控：分类处理不同类型的错误
```

### 8.2 监控查询的实用技巧


**🔹 查询优化建议**：
```
时间窗口选择：
• 实时告警：1-5分钟窗口
• 趋势分析：1小时窗口  
• 历史对比：1天窗口

聚合方式选择：
• avg：适合CPU、内存使用率
• sum：适合请求量、错误数
• max：适合延迟峰值监控
```

**🔹 告警设置原则**：
```
分级告警：
🟡 Warning  → 需要关注，但不紧急
🟠 Critical → 影响服务，需要处理  
🔴 Emergency → 严重影响，立即响应

避免告警风暴：
• 设置合理的时间窗口
• 使用抑制和分组规则
• 区分症状告警和原因告警
```

### 8.3 实际应用建议


**🎯 建立监控体系的步骤**：

1. **基础设施监控**：CPU、内存、磁盘、网络
2. **应用性能监控**：请求量、延迟、错误率  
3. **业务指标监控**：转化率、活跃用户等
4. **告警规则设置**：分级告警，避免疲劳
5. **监控面板搭建**：可视化展示，便于分析

**💡 监控查询的核心思维**：
- **以用户体验为中心**：关注用户感受到的性能
- **分层监控**：从基础设施到业务指标
- **趋势大于绝对值**：关注变化趋势和异常
- **可操作性**：监控结果要能指导具体行动

**记忆要点**：
- 监控不是为了收集数据，而是为了发现问题
- 好的查询能够快速定位问题根因
- 告警要准确，减少误报和漏报
- 持续优化查询性能，避免监控系统成为负担