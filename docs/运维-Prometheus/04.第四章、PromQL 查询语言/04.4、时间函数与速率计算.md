---
title: 4、时间函数与速率计算
---
## 📚 目录

1. [时间函数与速率计算概述](#1-时间函数与速率计算概述)
2. [rate()平均速率计算](#2-rate平均速率计算)
3. [irate()瞬时速率计算](#3-irate瞬时速率计算)
4. [increase()增量计算](#4-increase增量计算)
5. [delta()差值计算](#5-delta差值计算)
6. [time()时间函数](#6-time时间函数)
7. [计算精度与误差处理](#7-计算精度与误差处理)
8. [实战应用场景](#8-实战应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. ⏰ 时间函数与速率计算概述


### 1.1 什么是时间函数


**简单理解**：时间函数就是用来计算"变化速度"的工具。

```
日常例子理解：
汽车仪表盘显示：时速80公里/小时
这就是"速率" - 表示单位时间内的变化量

Prometheus中：
- CPU使用量从100增加到200 → 增量是100
- 如果这个变化发生在1分钟内 → 速率是100/分钟
- 如果发生在2分钟内 → 速率是50/分钟
```

### 1.2 为什么需要时间函数


**核心作用**：

🔸 **监控变化趋势**
```
原始数据：网站访问总数
1000 → 1100 → 1250 → 1300

看不出什么问题对吧？

通过速率计算：
第1分钟：100次/分钟（正常）
第2分钟：150次/分钟（增长）
第3分钟：50次/分钟（突然下降！需要关注）
```

🔸 **性能分析**
- **QPS计算**：每秒处理多少请求
- **错误率**：每分钟出现多少错误
- **资源消耗**：CPU、内存、磁盘的使用变化

### 1.3 时间函数分类


```
Prometheus时间函数家族：

📈 速率类（最常用）：
├── rate()     → 平均速率，适合看趋势
└── irate()    → 瞬时速率，适合看突发

📊 增量类：
├── increase() → 总增量，看累计变化
└── delta()    → 差值，看数值变化

⏱️ 时间类：
└── time()     → 当前时间戳
```

---

## 2. 📈 rate()平均速率计算


### 2.1 rate()函数基本概念


**定义**：`rate()`计算指定时间范围内的**平均变化速率**

**语法格式**：
```promql
rate(metric_name[time_range])
```

**通俗解释**：
```
rate()就像计算平均车速：
- 从A地到B地，总共100公里
- 用了2小时
- 平均速度 = 100公里 ÷ 2小时 = 50公里/小时

rate()做的事情：
- 看指标在时间段内的总变化
- 除以时间长度
- 得到平均每秒的变化量
```

### 2.2 rate()工作原理


**计算步骤图解**：
```
时间轴：    t1      t2      t3      t4      t5
指标值：   100 →   150 →   200 →   180 →   250

rate(metric[4m]) 计算过程：
1️⃣ 取最新值：250（t5时刻）
2️⃣ 取最早值：150（t2时刻，4分钟前）
3️⃣ 计算差值：250 - 150 = 100
4️⃣ 计算时间：t5 - t2 = 4分钟 = 240秒
5️⃣ 得出速率：100 ÷ 240 = 0.42/秒
```

💡 **重要提醒**：
- rate()会自动处理**计数器重置**问题
- 如果检测到值突然变小，会认为是重置，从0开始计算

### 2.3 rate()使用场景


| 监控场景 | **PromQL示例** | **含义说明** |
|---------|-------------|-------------|
| **HTTP请求速率** | `rate(http_requests_total[5m])` | `每秒平均请求数` |
| **错误发生速率** | `rate(http_errors_total[5m])` | `每秒平均错误数` |
| **网络流量** | `rate(network_bytes_total[1m])` | `每秒平均字节数` |
| **磁盘I/O** | `rate(disk_reads_total[2m])` | `每秒平均读取次数` |

### 2.4 rate()实战示例


**场景**：监控API接口的QPS（每秒查询数）

```promql
# 基础查询：计算5分钟内的平均QPS
rate(api_requests_total[5m])

# 按接口分组：不同接口的QPS
rate(api_requests_total[5m]) by (endpoint)

# 过滤特定状态：只看成功请求的QPS
rate(api_requests_total{status="200"}[5m])

# 计算错误率：错误请求占总请求的比例
rate(api_requests_total{status!="200"}[5m]) / 
rate(api_requests_total[5m]) * 100
```

**结果解读**：
```
查询结果：0.5
含义：最近5分钟，平均每秒处理0.5个请求
等价于：每分钟30个请求，每小时1800个请求
```

---

## 3. ⚡ irate()瞬时速率计算


### 3.1 irate()与rate()的区别


**核心区别**：

```
rate()  → 就像看"平均车速"
irate() → 就像看"瞬时车速"

实际例子：
从北京到上海，8小时车程：
- rate()：总里程÷总时间 = 平均时速
- irate()：看最后5分钟的速度变化

时间： 0h    2h    4h    6h    8h
速度： 80 → 100 → 60 → 90 → 120

rate(8h)：  平均90公里/小时
irate()：   当前120公里/小时（更能反映当前状态）
```

### 3.2 irate()工作原理


**计算方式**：
```
irate()只看最近的两个数据点：

时间轴：  ...  t3      t4      t5    ← 当前时刻
指标值：  ... 200 →   180 →   250

irate() 计算：
🎯 只用最后两个点：t4(180) 和 t5(250)
📊 计算变化：250 - 180 = 70
⏱️ 计算时间：t5 - t4 = 15秒（假设）
📈 瞬时速率：70 ÷ 15 = 4.67/秒
```

### 3.3 何时使用irate()


✅ **适用场景**：
- **告警触发**：需要快速响应突发情况
- **实时监控**：关注当前瞬时状态
- **调试问题**：查看最新的性能表现

❌ **不适用场景**：
- **长期趋势分析**：应该用rate()
- **容量规划**：需要看平均值
- **报表统计**：需要稳定的平均数据

### 3.4 irate()实战示例


```promql
# 监控CPU使用率突增
irate(cpu_usage_total[2m])

# 检测网络流量突发
irate(network_bytes_total[1m])

# API响应时间突然变慢
irate(api_duration_seconds_total[30s])
```

**告警规则示例**：
```yaml
# 基于irate()的告警：检测QPS突然下降
- alert: QPSDropAlert
  expr: irate(api_requests_total[2m]) < 0.1
  for: 1m
  annotations:
    summary: "API请求量突然下降"
    description: "当前QPS: {{ $value }}/秒"
```

---

## 4. 📊 increase()增量计算


### 4.1 increase()基本概念


**定义**：`increase()`计算指定时间范围内的**总增量**

**与rate()关系**：
```
increase() = rate() × 时间长度（秒）

例子：
rate(requests[5m]) = 2/秒
increase(requests[5m]) = 2 × 300秒 = 600个请求

换句话说：
increase() 告诉你"总共增加了多少"
rate()     告诉你"平均每秒增加多少"
```

### 4.2 increase()使用场景


**典型应用**：

🔸 **统计总量**
```promql
# 过去1小时总共处理了多少请求
increase(api_requests_total[1h])

# 过去24小时总共发生了多少错误
increase(error_count_total[24h])

# 过去1天用户访问了多少次
increase(page_views_total[1d])
```

🔸 **业务报表**
```promql
# 今日订单总数
increase(orders_total[1d])

# 本周新注册用户数
increase(user_registrations_total[7d])

# 本月销售额增长
increase(sales_amount_total[30d])
```

### 4.3 increase()实战示例


**场景**：生成业务日报

```promql
# 今日各接口调用总次数
increase(api_requests_total[24h]) by (endpoint)

# 各微服务今日处理的总请求数
sum(increase(service_requests_total[24h])) by (service_name)

# 今日错误总数及错误率
increase(service_errors_total[24h]) / 
increase(service_requests_total[24h]) * 100
```

**查询结果示例**：
```
endpoint="/api/users"     → 15000次
endpoint="/api/orders"    → 8500次  
endpoint="/api/products"  → 12000次

含义：今天这三个接口分别被调用了相应次数
```

---

## 5. 🔄 delta()差值计算


### 5.1 delta()与increase()的区别


**核心差异**：

```
increase() → 专门用于计数器（只增不减的指标）
delta()    → 用于仪表盘（可增可减的指标）

实际例子：

计数器类型（用increase）：
- 网站访问总数：只会增加，不会减少
- 订单总数：只会增加
- 错误发生次数：只会增加

仪表盘类型（用delta）：
- CPU使用率：会上下波动
- 内存使用量：会增减变化
- 在线用户数：会增减变化
```

### 5.2 delta()使用场景


**典型应用**：

🔸 **资源使用变化**
```promql
# CPU使用率在过去5分钟的变化
delta(cpu_usage_percent[5m])

# 内存使用量在过去10分钟的变化
delta(memory_usage_bytes[10m])

# 磁盘可用空间的变化趋势
delta(disk_free_bytes[1h])
```

🔸 **业务指标波动**
```promql
# 在线用户数的变化
delta(online_users_count[15m])

# 库存数量的变化
delta(inventory_quantity[30m])

# 数据库连接数的变化
delta(db_connections_active[5m])
```

### 5.3 delta()结果解读


```promql
# 查询：内存使用量5分钟内的变化
delta(memory_usage_bytes[5m])

可能的结果：
+1048576    → 内存增加了1MB
-2097152    → 内存减少了2MB
0           → 内存使用量没有变化
```

**⚠️ 注意事项**：
- 正值表示**增加**
- 负值表示**减少**  
- 零值表示**无变化**

---

## 6. 🕐 time()时间函数


### 6.1 time()函数基本用法


**定义**：`time()`返回当前的Unix时间戳（秒）

```promql
# 基本用法
time()

# 返回结果示例
1706172600  # 对应：2024-01-25 10:30:00 UTC
```

### 6.2 time()实际应用


**常见用途**：

🔸 **计算运行时长**
```promql
# 服务运行了多长时间（秒）
time() - process_start_time_seconds

# 转换为小时
(time() - process_start_time_seconds) / 3600

# 转换为天数
(time() - process_start_time_seconds) / 86400
```

🔸 **时间条件过滤**
```promql
# 只在工作时间（9-18点）监控
api_requests_total and on() (hour(time()) >= 9 and hour(time()) < 18)

# 只在周末监控
api_requests_total and on() (day_of_week(time()) == 0 or day_of_week(time()) == 6)
```

🔸 **基于时间的计算**
```promql
# 每小时重置的计数器
api_requests_total - api_requests_total offset 1h
```

### 6.3 时间函数组合使用


```promql
# 计算服务可用率（基于时间窗口）
(
  time() - (
    last_over_time(up{job="api-server"}[24h] == 0) * 
    time()
  )
) / 86400 * 100
```

---

## 7. 🎯 计算精度与误差处理


### 7.1 时间窗口选择原则


**基本原则**：

📏 **窗口长度指导**：
```
告警监控    → 1-5分钟   （快速响应）
性能分析    → 5-15分钟  （平衡精度与响应）
趋势观察    → 15分钟-1小时（看长期趋势）
容量规划    → 1小时-1天  （平滑长期波动）
```

⚠️ **常见误区**：
```
❌ 窗口太短：数据噪音大，容易误报
rate(metric[30s]) → 可能受瞬时波动影响

❌ 窗口太长：响应迟钝，错过重要问题  
rate(metric[2h])  → 问题发生1小时后才能察觉

✅ 合适窗口：根据监控目标选择
rate(metric[5m])  → 大多数场景的平衡选择
```

### 7.2 数据精度影响因素


**采集频率 vs 查询窗口**：

```
采集间隔：15秒
查询窗口：5分钟

数据点数量：5分钟 ÷ 15秒 = 20个数据点

影响因素：
🔸 采集频率高 → 精度高，但存储成本大
🔸 窗口时间长 → 平滑性好，但响应慢
🔸 数据点少   → 可能有较大误差
```

**精度提升建议**：
- **关键指标**：提高采集频率（5-15秒）
- **一般指标**：标准采集频率（15-30秒）
- **历史数据**：可以降采样存储

### 7.3 处理计数器重置


**重置检测机制**：

```
正常情况：
时间： t1   t2   t3   t4   t5
数值： 100→ 150→ 200→ 250→ 300
增量：  +50  +50  +50  +50

重置情况：
时间： t1   t2   t3   t4   t5  
数值： 100→ 150→ 200→ 50 → 100
增量：  +50  +50  +?   +50

rate()会自动处理：
实际计算：200 → 50 → 100
检测重置：50 < 200（重置了！）
正确结果：(100 - 0) + (200 - 150) = 150
```

### 7.4 误差控制策略


**常用方法**：

🔸 **多时间窗口对比**
```promql
# 同时查看不同时间窗口
rate(metric[1m])   # 短期趋势
rate(metric[5m])   # 中期趋势  
rate(metric[15m])  # 长期趋势
```

🔸 **移动平均平滑**
```promql
# 5分钟移动平均
avg_over_time(rate(metric[1m])[5m:])
```

🔸 **阈值范围设置**
```yaml
# 告警规则：使用范围而非精确值
- alert: HighErrorRate
  expr: rate(errors_total[5m]) > 0.1    # 而非 == 0.1
  for: 2m  # 持续2分钟才告警，避免瞬时抖动
```

---

## 8. 🛠️ 实战应用场景


### 8.1 Web服务监控


**完整监控体系**：

```promql
# 📊 QPS监控（每秒请求数）
rate(http_requests_total[5m]) by (method, status)

# 📈 错误率监控
rate(http_requests_total{status=~"5.."}[5m]) / 
rate(http_requests_total[5m]) * 100

# ⚡ 响应时间监控
rate(http_request_duration_seconds_sum[5m]) / 
rate(http_request_duration_seconds_count[5m])

# 📋 今日请求总量统计
increase(http_requests_total[24h]) by (service)
```

**监控大屏展示**：
```
┌─────────────────────────────────────────┐
│             Web服务监控大屏              │
├─────────────────┬───────────────────────┤
│   当前QPS       │      错误率           │
│   🔥 128/秒     │      ❌ 0.05%        │
├─────────────────┼───────────────────────┤
│   平均响应时间   │      今日总请求       │
│   ⚡ 245ms      │      📊 2.1M         │
└─────────────────┴───────────────────────┘
```

### 8.2 系统资源监控


```promql
# 🖥️ CPU使用率变化趋势
delta(cpu_usage_percent[10m])

# 💾 内存增长速率  
rate(memory_usage_bytes[5m])

# 💿 磁盘I/O速率
rate(disk_io_bytes_total[1m]) by (device, direction)

# 🌐 网络流量速率
rate(network_bytes_total[2m]) by (interface, direction)
```

### 8.3 业务指标监控


```promql
# 💰 订单创建速率
rate(orders_created_total[10m])

# 👥 用户注册速率  
rate(user_registrations_total[1h])

# 💸 收入增长速率
rate(revenue_total[1d])

# 📦 库存变化监控
delta(inventory_quantity[30m]) by (product_id)
```

### 8.4 告警规则实战


```yaml
groups:
- name: api_monitoring
  rules:
  # 🚨 QPS突然下降告警
  - alert: QPSDropped
    expr: irate(api_requests_total[2m]) < 0.5
    for: 3m
    labels:
      severity: warning
    annotations:
      summary: "API请求量下降"
      description: "当前QPS: {{ $value }}/秒，低于正常水平"

  # 🔥 错误率过高告警  
  - alert: HighErrorRate
    expr: |
      rate(api_requests_total{status=~"5.."}[5m]) / 
      rate(api_requests_total[5m]) * 100 > 5
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "API错误率过高"
      description: "错误率: {{ $value }}%，超过5%阈值"

  # 📈 QPS异常增长告警
  - alert: QPSSpike  
    expr: irate(api_requests_total[1m]) > 50
    for: 1m
    labels:
      severity: warning
    annotations:
      summary: "API请求量激增"
      description: "当前QPS: {{ $value }}/秒，可能有异常流量"
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 时间函数作用：计算指标随时间的变化，用于监控性能和趋势
🔸 rate()：平均速率，适合趋势分析和长期监控
🔸 irate()：瞬时速率，适合实时监控和快速告警
🔸 increase()：总增量，适合统计和报表生成
🔸 delta()：差值计算，适合可变指标的变化分析
🔸 time()：时间戳，用于时间相关的计算和过滤
```

### 9.2 关键理解要点


**🔹 函数选择策略**：
```
监控告警场景 → 优选irate()，快速响应
趋势分析场景 → 优选rate()，平滑稳定
统计报表场景 → 优选increase()，看总量
资源变化场景 → 优选delta()，看波动
```

**🔹 时间窗口选择**：
```
实时监控 → 1-3分钟窗口
性能分析 → 5-15分钟窗口  
趋势观察 → 15分钟-1小时窗口
容量规划 → 1小时-1天窗口
```

**🔹 精度与性能平衡**：
```
关键业务指标 → 高精度（短采集间隔）
一般监控指标 → 标准精度
历史存储数据 → 可降采样
```

### 9.3 实战应用指南


**🎯 监控体系构建**：
- **基础层**：系统资源监控（CPU、内存、磁盘、网络）
- **应用层**：Web服务监控（QPS、错误率、响应时间）
- **业务层**：业务指标监控（订单、用户、收入）

**📊 大屏展示建议**：
- **实时指标**：使用irate()显示当前状态
- **趋势图表**：使用rate()显示平滑趋势
- **统计数据**：使用increase()显示累计数据

**🚨 告警配置原则**：
- **紧急告警**：使用irate()快速检测
- **趋势告警**：使用rate()避免误报
- **阈值设置**：基于历史数据确定合理范围
- **持续时间**：避免瞬时抖动造成误报

### 9.4 常见问题与解决


**❓ 常见问题**：

| 问题现象 | **可能原因** | **解决方案** |
|---------|-------------|-------------|
| `数据突然为0` | `服务重启，计数器重置` | `使用increase()，会自动处理重置` |
| `速率计算不准` | `时间窗口选择不当` | `根据监控目标调整窗口大小` |
| `告警频繁误报` | `使用irate()过于敏感` | `改用rate()或增加持续时间判断` |
| `趋势不够平滑` | `采集频率过低` | `提高关键指标的采集频率` |

**✅ 最佳实践**：
- **分层监控**：不同层次使用不同时间函数
- **多维度观察**：同时关注瞬时值和平均值
- **历史对比**：使用offset查看同期历史数据
- **合理告警**：避免过于敏感的告警阈值

**核心记忆要点**：
- **rate()看趋势**，**irate()看当前**，**increase()看总量**
- **时间窗口要合适**，**太短太长都不行**
- **告警要稳定**，**避免误报扰民**
- **监控要分层**，**系统应用业务全覆盖**