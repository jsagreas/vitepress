---
title: 3、聚合函数应用
---
## 📚 目录

1. [聚合函数概述](#1-聚合函数概述)
2. [基础聚合函数详解](#2-基础聚合函数详解)
3. [分组聚合操作](#3-分组聚合操作)
4. [排序与统计函数](#4-排序与统计函数)
5. [高级统计分析](#5-高级统计分析)
6. [聚合优化策略](#6-聚合优化策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 聚合函数概述


### 1.1 什么是聚合函数


**通俗理解**：聚合函数就像是数据的"总结器"，它能把很多个数据点合并成一个有意义的结果。

```
想象一个班级考试：
原始数据：张三85分，李四92分，王五78分，赵六96分...
聚合结果：
- 平均分：87.75分 (avg函数)
- 最高分：96分 (max函数)  
- 总人数：30人 (count函数)
- 及格人数：28人 (count函数配合条件)
```

**在监控中的作用**：
- **数据汇总**：把分散的监控数据整合成关键指标
- **趋势分析**：从大量数据中提取有用信息
- **告警判断**：计算阈值用于告警触发
- **资源统计**：统计集群整体资源使用情况

### 1.2 聚合函数的工作原理


**基本概念**：聚合函数操作的是"向量"，也就是一组时间序列数据。

```
监控数据示例：
http_requests_total{instance="web1", job="api"} 1000
http_requests_total{instance="web2", job="api"} 1200  
http_requests_total{instance="web3", job="api"} 800

聚合操作：
sum() → 3000 (三台服务器请求总数)
avg() → 1000 (平均每台处理的请求)
max() → 1200 (最忙的服务器请求数)
```

### 1.3 聚合函数的分类


| 类型 | **函数** | **作用** | **常用场景** |
|------|---------|---------|-------------|
| 🔢 **数值计算** | `sum`, `avg`, `max`, `min` | `基础数学运算` | `资源使用率、请求统计` |
| 📊 **计数统计** | `count`, `count_values` | `数量统计` | `实例数量、状态统计` |
| 🏆 **排序选择** | `topk`, `bottomk` | `排序取值` | `找出最忙/最闲的服务器` |
| 📈 **分位统计** | `quantile` | `分位数计算` | `响应时间分析` |
| 🔬 **高级统计** | `stddev`, `stdvar` | `统计分析` | `性能稳定性分析` |

---

## 2. ⚡ 基础聚合函数详解


### 2.1 sum求和函数


**作用**：把所有数值加起来，获得总量。

```promql
# 计算所有服务器的总请求数
sum(http_requests_total)

# 实际场景示例
原始数据：
http_requests_total{instance="web1"} 1000
http_requests_total{instance="web2"} 1500
http_requests_total{instance="web3"} 800

结果：3300
```

**实际应用场景**：
- **总流量统计**：所有服务器的请求总数
- **资源使用总量**：集群CPU使用总量
- **错误数量统计**：所有服务的错误总数

### 2.2 avg平均值函数


**作用**：计算所有数值的平均值，了解整体水平。

```promql
# 计算平均CPU使用率
avg(cpu_usage_percent)

# 实际场景示例
原始数据：
cpu_usage_percent{instance="web1"} 60%
cpu_usage_percent{instance="web2"} 80% 
cpu_usage_percent{instance="web3"} 40%

结果：60% (平均CPU使用率)
```

**使用技巧**：
- 平均值容易被极端值影响
- 配合max/min一起看更有意义
- 适合了解整体负载水平

### 2.3 max/min最值函数


**max作用**：找出最大值，发现瓶颈和异常。

```promql
# 找出最高的内存使用率
max(memory_usage_percent)

# 找出响应时间最长的请求
max(http_request_duration_seconds)
```

**min作用**：找出最小值，发现空闲资源。

```promql
# 找出最低的磁盘使用率
min(disk_usage_percent)

# 找出最少的连接数
min(active_connections)
```

### 2.4 count计数函数


**作用**：统计有多少个数据点，常用于统计实例数量。

```promql
# 统计在线服务器数量
count(up == 1)

# 统计高CPU使用率的服务器数量
count(cpu_usage_percent > 80)
```

**实际应用场景**：
```
健康检查：
up{instance="web1"} 1  # 在线
up{instance="web2"} 1  # 在线  
up{instance="web3"} 0  # 离线

count(up == 1) → 2 (在线服务器数)
count(up == 0) → 1 (离线服务器数)
```

---

## 3. 🔗 分组聚合操作


### 3.1 by分组聚合


**核心概念**：`by`关键字用于指定按哪些标签进行分组，相同标签值的数据会被聚合在一起。

```promql
# 按job分组计算每个服务的总请求数
sum(http_requests_total) by (job)
```

**工作原理图示**：
```
原始数据：
http_requests_total{job="api", instance="web1"} 1000
http_requests_total{job="api", instance="web2"} 1200
http_requests_total{job="web", instance="web3"} 800
http_requests_total{job="web", instance="web4"} 600

按job分组聚合：
┌─────────────────────────────────┐
│ job="api"组：1000 + 1200 = 2200 │
│ job="web"组：800 + 600 = 1400   │
└─────────────────────────────────┘

结果：
{job="api"} 2200
{job="web"} 1400
```

### 3.2 without排除聚合


**核心概念**：`without`关键字表示忽略指定的标签，按其余标签分组。

```promql
# 忽略instance标签，按其他标签分组
sum(http_requests_total) without (instance)
```

**by vs without对比**：
```
原始数据：
metric{job="api", method="GET", instance="web1"} 100
metric{job="api", method="GET", instance="web2"} 200
metric{job="api", method="POST", instance="web1"} 50

使用by(job, method)：
{job="api", method="GET"} 300
{job="api", method="POST"} 50

使用without(instance)：  
{job="api", method="GET"} 300  # 同样的结果
{job="api", method="POST"} 50  # instance被忽略了
```

### 3.3 多维度分组实例


**按地区和服务类型分组**：
```promql
# 计算每个地区每种服务类型的平均响应时间
avg(http_request_duration_seconds) by (region, service_type)
```

**实际场景示例**：
```
原始数据：
http_request_duration_seconds{region="beijing", service_type="api", instance="web1"} 0.1
http_request_duration_seconds{region="beijing", service_type="api", instance="web2"} 0.2
http_request_duration_seconds{region="shanghai", service_type="web", instance="web3"} 0.15

分组结果：
{region="beijing", service_type="api"} 0.15
{region="shanghai", service_type="web"} 0.15
```

---

## 4. 🏆 排序与统计函数


### 4.1 topk最高排名


**作用**：找出数值最大的k个结果，用于发现热点和瓶颈。

```promql
# 找出CPU使用率最高的3台服务器
topk(3, cpu_usage_percent)

# 找出请求量最大的5个接口
topk(5, sum(http_requests_total) by (endpoint))
```

**实际应用示例**：
```
原始数据：
cpu_usage_percent{instance="web1"} 45%
cpu_usage_percent{instance="web2"} 78% 
cpu_usage_percent{instance="web3"} 92%
cpu_usage_percent{instance="web4"} 56%
cpu_usage_percent{instance="web5"} 89%

topk(3, cpu_usage_percent) 结果：
{instance="web3"} 92%  # 第1名
{instance="web5"} 89%  # 第2名  
{instance="web2"} 78%  # 第3名
```

### 4.2 bottomk最低排名


**作用**：找出数值最小的k个结果，用于发现空闲资源。

```promql
# 找出负载最轻的3台服务器
bottomk(3, cpu_usage_percent)

# 找出连接数最少的数据库实例
bottomk(2, mysql_active_connections)
```

### 4.3 count_values值计数


**作用**：统计每个数值出现的次数，用于分布分析。

```promql
# 统计不同HTTP状态码的数量
count_values("status_code", http_response_status)
```

**应用场景示例**：
```
原始数据：
http_response_status{instance="web1"} 200
http_response_status{instance="web2"} 200
http_response_status{instance="web3"} 404
http_response_status{instance="web4"} 500

count_values结果：
{status_code="200"} 2  # 状态码200出现2次
{status_code="404"} 1  # 状态码404出现1次
{status_code="500"} 1  # 状态码500出现1次
```

---

## 5. 📈 高级统计分析


### 5.1 quantile分位数函数


**通俗理解**：分位数就像是"排队位置"，告诉你数据的分布情况。

```
想象100个人排队：
- 50%分位数(中位数)：第50个人的位置
- 90%分位数：第90个人的位置  
- 95%分位数：第95个人的位置
```

```promql
# 计算响应时间的90分位数
quantile(0.9, http_request_duration_seconds)

# 按服务分组计算95分位数
quantile(0.95, http_request_duration_seconds) by (service)
```

**分位数的实际意义**：
- **50%分位数**：一半请求的响应时间都在这个值以下
- **90%分位数**：90%请求的响应时间都在这个值以下
- **99%分位数**：99%请求的响应时间都在这个值以下

### 5.2 histogram_quantile直方图分位数


**使用场景**：当你的指标是histogram类型时使用。

```promql
# 从直方图计算P95响应时间
histogram_quantile(0.95, 
  sum(rate(http_request_duration_seconds_bucket[5m])) by (le)
)
```

**直方图分位数的优势**：
- 更准确的分位数计算
- 适合大量数据的统计分析
- 支持时间范围查询

### 5.3 stddev标准差函数


**通俗理解**：标准差衡量数据的"散乱程度"，数值越大说明数据越不稳定。

```promql
# 计算CPU使用率的标准差
stddev(cpu_usage_percent)

# 按服务计算响应时间的标准差
stddev(http_request_duration_seconds) by (service)
```

**标准差的含义**：
- **标准差小**：数据集中，性能稳定
- **标准差大**：数据分散，性能不稳定

**实际应用**：
```
服务A响应时间：[100ms, 105ms, 98ms, 102ms]  # 标准差小，稳定
服务B响应时间：[50ms, 200ms, 80ms, 300ms]   # 标准差大，不稳定
```

---

## 6. ⚡ 聚合优化策略


### 6.1 查询性能优化


**选择合适的聚合级别**：
```promql
# ❌ 低效：先聚合再过滤
sum(cpu_usage_percent) > 80

# ✅ 高效：先过滤再聚合  
sum(cpu_usage_percent{job="web"})
```

**使用时间范围聚合**：
```promql
# 使用rate函数配合聚合
sum(rate(http_requests_total[5m])) by (job)

# 避免直接聚合counter类型
# ❌ sum(http_requests_total)  
# ✅ sum(rate(http_requests_total[5m]))
```

### 6.2 分组策略优化


**合理选择分组维度**：
```promql
# ❌ 过度分组，结果太细碎
avg(cpu_usage_percent) by (instance, core, thread)

# ✅ 适度分组，结果有意义
avg(cpu_usage_percent) by (instance)
```

**使用recording rules预计算**：
```yaml
# 在Prometheus配置中定义
groups:
  - name: aggregation_rules
    rules:
    - record: job:cpu_usage:avg
      expr: avg(cpu_usage_percent) by (job)
    
    - record: instance:http_requests:rate5m  
      expr: sum(rate(http_requests_total[5m])) by (instance)
```

### 6.3 常见性能陷阱


**避免高基数聚合**：
```promql
# ❌ 高基数标签会导致性能问题
sum(metric) by (user_id)  # 如果有百万用户

# ✅ 使用合适的聚合粒度
sum(metric) by (user_type)  # 按用户类型聚合
```

**处理缺失数据**：
```promql
# 使用or运算符处理缺失值
avg(cpu_usage_percent) or 0

# 使用absent函数检测缺失
absent(up{job="web"})
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 基础聚合：sum求总量、avg看平均、max/min找极值、count数数量
🔸 分组聚合：by指定分组、without排除标签、支持多维度分组
🔸 排序统计：topk找最大、bottomk找最小、quantile看分布
🔸 高级统计：histogram_quantile处理直方图、stddev看稳定性
🔸 性能优化：合理分组、预计算规则、避免高基数
```

### 7.2 关键理解要点


**🔹 聚合函数的本质**
```
数据处理流程：
原始时间序列 → 聚合计算 → 结果向量

关键理解：
- 聚合是"多对一"的数据变换
- 分组决定了聚合的粒度  
- 选择合适的聚合函数很重要
```

**🔹 分组的重要性**
```
无分组：所有数据聚合成一个值
有分组：按标签分类聚合，保留业务含义

实际应用：
- 按服务分组：了解每个服务的情况
- 按地区分组：了解不同地区的表现
- 按时间分组：了解时间趋势
```

**🔹 选择合适的聚合函数**
```
场景导向选择：
资源使用 → sum(总量)、avg(平均)、max(峰值)
性能分析 → quantile(分位数)、stddev(稳定性)  
容量规划 → topk(热点)、bottomk(空闲)
健康监控 → count(实例数)、absent(缺失检测)
```

### 7.3 实际应用指南


**📊 监控看板常用聚合**
```
系统监控：
- 总CPU使用率：avg(cpu_usage_percent)
- 内存使用峰值：max(memory_usage_percent)  
- 磁盘使用分布：quantile(0.9, disk_usage_percent)

应用监控：
- 总请求量：sum(rate(http_requests_total[5m]))
- 平均响应时间：avg(http_request_duration_seconds)
- 错误率：sum(rate(http_errors_total[5m])) / sum(rate(http_requests_total[5m]))
```

**🚨 告警规则常用聚合**
```
资源告警：
- 高CPU使用：avg(cpu_usage_percent) by (instance) > 80
- 磁盘空间不足：min(disk_free_bytes) by (instance) < 1000000000

应用告警：  
- 响应时间异常：quantile(0.95, http_request_duration_seconds) > 2
- 错误率过高：rate(http_errors_total[5m]) / rate(http_requests_total[5m]) > 0.1
```

**💡 最佳实践建议**
- 根据业务需求选择合适的聚合粒度
- 使用recording rules预计算常用聚合
- 结合多个聚合函数全面了解数据特征
- 定期检查和优化聚合查询性能

**核心记忆**：
- 聚合是监控数据分析的核心工具
- 分组让聚合结果更有业务意义
- 选择合适的函数比复杂的查询更重要
- 性能优化从合理设计开始