---
title: 1、PromQL基础语法
---
## 📚 目录

1. [PromQL是什么](#1-PromQL是什么)
2. [即时向量查询](#2-即时向量查询)
3. [范围向量查询](#3-范围向量查询)
4. [标签选择器语法](#4-标签选择器语法)
5. [时间区间表达式](#5-时间区间表达式)
6. [offset时间偏移](#6-offset时间偏移)
7. [查询优化技巧](#7-查询优化技巧)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 PromQL是什么


### 1.1 简单理解PromQL


**什么是PromQL？**
PromQL（Prometheus Query Language）就是**Prometheus的专用查询语言**，就像SQL是数据库的查询语言一样。

```
简单类比：
SQL   →  数据库查询语言  →  SELECT * FROM users
PromQL →  监控数据查询语言 →  cpu_usage{job="web"}
```

**为什么需要PromQL？**
- 监控数据和普通数据不同，它有**时间维度**
- 需要查询"过去5分钟的平均CPU使用率"这样的问题
- 普通SQL无法很好地处理时间序列数据

### 1.2 PromQL的作用


**🎯 核心功能**
```
数据查询：从Prometheus中获取监控数据
数据计算：计算平均值、增长率、百分比等
数据过滤：按照条件筛选特定的监控指标
图表展示：为Grafana等工具提供数据源
告警规则：编写告警条件判断
```

**💡 实际应用场景**
- **性能监控**：查看服务器CPU、内存使用情况
- **业务监控**：统计网站访问量、订单数量
- **告警设置**：当错误率超过5%时发送告警
- **容量规划**：分析资源使用趋势

### 1.3 PromQL数据类型


**📊 四种数据类型**
```
┌─────────────────┐
│   即时向量       │ ← 某个时刻的数据点
│ (Instant Vector)│   例：当前CPU使用率
├─────────────────┤
│   范围向量       │ ← 一段时间的数据序列  
│ (Range Vector)  │   例：过去5分钟的CPU数据
├─────────────────┤
│   标量           │ ← 单个数值
│ (Scalar)        │   例：数字 0.95
├─────────────────┤
│   字符串         │ ← 文本值（很少使用）
│ (String)        │   例：字符串 "hello"
└─────────────────┘
```

---

## 2. ⚡ 即时向量查询


### 2.1 什么是即时向量


**🔸 通俗理解**
即时向量就是**某个时刻的监控数据快照**，就像给监控系统拍了张照片。

```
想象场景：
现在是下午3点，你想知道：
- 服务器A的CPU使用率是多少？
- 服务器B的内存使用率是多少？
- 网站的当前访问量是多少？

这些都是"即时向量"查询！
```

### 2.2 基本查询语法


**📝 最简单的查询**
```promql
# 查询CPU使用率
cpu_usage

# 查询内存使用率  
memory_usage

# 查询HTTP请求数
http_requests_total
```

**🎯 查询结果示例**
```
cpu_usage{instance="server1", job="web"} 0.75
cpu_usage{instance="server2", job="web"} 0.82
cpu_usage{instance="server3", job="api"} 0.45
```

这个结果告诉我们：
- server1的CPU使用率是75%
- server2的CPU使用率是82%  
- server3的CPU使用率是45%

### 2.3 带标签的查询


**🏷️ 标签的作用**
标签就像是**给数据贴的标记**，用来区分不同的服务器、应用等。

```promql
# 查询特定服务器的CPU
cpu_usage{instance="server1"}

# 查询web服务的CPU
cpu_usage{job="web"}

# 查询特定服务器的特定服务
cpu_usage{instance="server1", job="web"}
```

**💡 实际应用示例**
```promql
# 生产环境的错误率
error_rate{environment="production"}

# 北京机房的服务器负载
server_load{datacenter="beijing"}

# 用户服务的响应时间
response_time{service="user-service"}
```

---

## 3. 📈 范围向量查询


### 3.1 什么是范围向量


**🔸 通俗理解**
范围向量就是**一段时间内的监控数据序列**，就像看一段时间的监控录像。

```
场景对比：
即时向量：现在CPU使用率是多少？（拍照片）
范围向量：过去5分钟CPU使用率的变化？（看录像）
```

### 3.2 时间范围语法


**⏰ 时间单位表示**
```
s = 秒   (seconds)
m = 分钟 (minutes)  
h = 小时 (hours)
d = 天   (days)
w = 周   (weeks)
y = 年   (years)
```

**📝 范围查询语法**
```promql
# 过去5分钟的CPU数据
cpu_usage[5m]

# 过去1小时的内存数据
memory_usage[1h]

# 过去1天的请求数据
http_requests[1d]

# 过去30分钟的错误率
error_rate[30m]
```

### 3.3 范围向量的应用


**📊 查询结果示例**
```
cpu_usage{instance="server1"}[5m] =
1609459200 0.75  ← 5分钟前
1609459260 0.78  ← 4分钟前  
1609459320 0.82  ← 3分钟前
1609459380 0.79  ← 2分钟前
1609459440 0.76  ← 1分钟前
1609459500 0.73  ← 现在
```

**💡 常用计算场景**
```promql
# 计算过去5分钟的平均CPU使用率
avg_over_time(cpu_usage[5m])

# 计算过去1小时的最大内存使用率
max_over_time(memory_usage[1h])

# 计算过去10分钟的请求增长率
rate(http_requests_total[10m])
```

---

## 4. 🏷️ 标签选择器语法


### 4.1 标签选择器的作用


**🔸 什么是标签选择器**
标签选择器就是**用来筛选数据的条件**，就像在商店里按照标签找商品。

```
生活类比：
在服装店找衣服：
- 颜色=红色
- 尺寸=M
- 品牌=Nike

在Prometheus找数据：
- instance="server1"  
- job="web"
- environment="production"
```

### 4.2 四种匹配操作符


**📋 操作符详解**

| 操作符 | 含义 | 示例 | 说明 |
|--------|------|------|------|
| `=` | **完全匹配** | `job="web"` | job标签的值必须是"web" |
| `!=` | **不等于** | `job!="test"` | job标签的值不能是"test" |
| `=~` | **正则匹配** | `instance=~"server.*"` | instance以"server"开头 |
| `!~` | **正则不匹配** | `instance!~"test.*"` | instance不以"test"开头 |

### 4.3 实际应用示例


**🎯 基础筛选**
```promql
# 只查询生产环境的数据
cpu_usage{environment="production"}

# 排除测试环境的数据  
cpu_usage{environment!="test"}

# 查询多个条件
cpu_usage{environment="production", job="web"}
```

**🔍 正则表达式筛选**
```promql
# 查询所有web服务器（web1, web2, web3...）
cpu_usage{instance=~"web.*"}

# 查询北京和上海的机房数据
cpu_usage{datacenter=~"beijing|shanghai"}

# 排除所有测试服务器
cpu_usage{instance!~"test.*"}
```

**💡 复杂条件组合**
```promql
# 生产环境的web服务，但不包括备份服务器
cpu_usage{
  environment="production",
  job="web", 
  instance!~".*backup.*"
}

# API服务的错误率，只看核心服务
error_rate{
  service=~"user-api|order-api|payment-api",
  environment="production"
}
```

---

## 5. ⏱️ 时间区间表达式


### 5.1 时间区间的重要性


**🔸 为什么需要时间区间**
监控数据都是按时间存储的，指定时间区间可以：
- **精确查询**：获取特定时间段的数据
- **性能优化**：避免查询过多数据
- **趋势分析**：对比不同时间段的数据

### 5.2 时间单位详解


**📅 支持的时间单位**
```
基础单位：
s   → 秒    (1s = 1秒)
m   → 分钟  (1m = 60秒)
h   → 小时  (1h = 3600秒)
d   → 天    (1d = 24小时)
w   → 周    (1w = 7天)
y   → 年    (1y = 365天)

组合使用：
1h30m  → 1小时30分钟
2d12h  → 2天12小时
1w3d   → 1周3天
```

### 5.3 常用时间区间


**⚡ 性能监控场景**
```promql
# 实时监控（最近1分钟）
cpu_usage[1m]

# 短期分析（最近5分钟）
memory_usage[5m]

# 中期观察（最近1小时）
disk_usage[1h]

# 长期趋势（最近1天）
network_traffic[1d]
```

**📊 业务监控场景**
```promql
# 接口响应时间（最近10分钟）
api_response_time[10m]

# 订单量统计（最近1小时）
order_count[1h]

# 用户活跃度（最近1天）
user_activity[1d]

# 收入趋势（最近1周）
revenue[1w]
```

### 5.4 时间区间选择原则


**🎯 选择建议**

```
实时告警：    1m - 5m   (快速发现问题)
性能分析：    5m - 30m  (分析性能波动)
容量规划：    1h - 1d   (了解使用趋势)
历史对比：    1d - 1w   (长期趋势分析)
```

**⚠️ 注意事项**
- 时间区间太短：数据点太少，不够准确
- 时间区间太长：查询慢，数据量大
- 根据实际需求选择合适的区间

---

## 6. ⏰ offset时间偏移


### 6.1 什么是时间偏移


**🔸 通俗理解**
offset就是**时间机器**，让你查询"过去某个时间点的数据"。

```
现实场景：
现在是下午3点，我想知道：
- 1小时前（下午2点）的CPU使用率
- 昨天同一时间（昨天下午3点）的访问量
- 1周前的服务器负载情况

这就需要用到 offset！
```

### 6.2 offset语法结构


**📝 基本语法**
```promql
# 语法格式
metric_name{labels} offset duration

# 实际示例
cpu_usage offset 1h        # 1小时前的CPU使用率
memory_usage offset 1d     # 1天前的内存使用率
http_requests offset 1w    # 1周前的请求数
```

### 6.3 实际应用场景


**📊 对比分析**
```promql
# 当前CPU使用率
cpu_usage

# 1小时前的CPU使用率
cpu_usage offset 1h

# 昨天同一时间的CPU使用率
cpu_usage offset 1d
```

**💡 增长率计算**
```promql
# 计算相比1小时前的增长
(http_requests_total - http_requests_total offset 1h) 
/ http_requests_total offset 1h * 100

# 计算相比昨天的变化率
(order_count - order_count offset 1d) 
/ order_count offset 1d * 100
```

### 6.4 offset与范围查询结合


**🔄 组合使用**
```promql
# 1小时前的5分钟CPU数据
cpu_usage[5m] offset 1h

# 昨天同一时间的10分钟响应时间
response_time[10m] offset 1d

# 1周前的1小时请求量数据  
http_requests[1h] offset 1w
```

**📈 实用监控场景**
```promql
# 对比今天和昨天的平均响应时间
avg_over_time(response_time[1h]) 
vs 
avg_over_time(response_time[1h] offset 1d)

# 对比这周和上周的错误率
rate(error_count[1w]) 
vs 
rate(error_count[1w] offset 1w)
```

---

## 7. 🚀 查询优化技巧


### 7.1 为什么需要优化


**🔸 优化的重要性**
- **查询速度**：快速获取监控数据
- **系统性能**：减少Prometheus负载
- **用户体验**：提高Grafana图表加载速度
- **资源节省**：降低CPU和内存使用

### 7.2 标签过滤优化


**🎯 优化原则**
```
❌ 错误做法：先查询所有数据，再过滤
✅ 正确做法：先过滤标签，再查询数据
```

**📝 优化示例**
```promql
# ❌ 低效查询：查询所有数据再计算
rate(http_requests_total[5m])

# ✅ 高效查询：先过滤再计算
rate(http_requests_total{job="web", status="200"}[5m])

# ❌ 低效：使用正则表达式
cpu_usage{instance=~".*"}

# ✅ 高效：精确匹配
cpu_usage{instance="server1"}
```

### 7.3 时间范围优化


**⏱️ 时间区间选择**
```promql
# ❌ 过长时间区间（查询慢）
cpu_usage[1d]

# ✅ 合适时间区间
cpu_usage[5m]

# ❌ 过短时间区间（数据不准确）
rate(http_requests_total[30s])

# ✅ 适当时间区间（通常用5倍于scrape间隔）
rate(http_requests_total[5m])
```

### 7.4 聚合函数优化


**📊 聚合优化技巧**
```promql
# ❌ 低效：先聚合再过滤
avg(cpu_usage) by (job)

# ✅ 高效：先过滤再聚合
avg(cpu_usage{environment="production"}) by (job)

# ✅ 使用合适的聚合维度
sum(rate(http_requests_total[5m])) by (job, instance)
```

### 7.5 实用优化清单


**📋 优化检查清单**

```
🔍 标签过滤：
✅ 尽可能使用精确匹配（=）
✅ 避免过度使用正则表达式（=~）
✅ 先过滤再计算

⏰ 时间范围：
✅ 根据数据精度选择合适区间
✅ 避免查询过长时间段
✅ rate函数建议用5倍scrape间隔

📊 查询结构：
✅ 先过滤后聚合
✅ 使用合适的聚合维度
✅ 避免不必要的复杂计算

🎯 监控最佳实践：
✅ 查询结果限制在1000个序列内
✅ 避免高基数标签（如用户ID）
✅ 定期清理无用的指标
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 PromQL本质：Prometheus专用的时间序列数据查询语言
🔸 四种数据类型：即时向量、范围向量、标量、字符串
🔸 基本查询：metric_name{label="value"}[time_range] offset duration
🔸 标签选择器：=、!=、=~、!~ 四种匹配方式
🔸 时间表达式：s、m、h、d、w、y 六种时间单位
🔸 时间偏移：offset用于查询历史时间点的数据
```

### 8.2 关键理解要点


**🔹 即时向量 vs 范围向量**
```
即时向量：某个时刻的数据快照
- cpu_usage → 当前CPU使用率
- 用于：实时监控、当前状态查看

范围向量：一段时间的数据序列  
- cpu_usage[5m] → 过去5分钟的CPU数据
- 用于：趋势分析、计算函数输入
```

**🔹 标签的作用和重要性**
```
标签作用：
- 区分不同服务器、应用、环境
- 实现精确的数据过滤
- 支持多维度数据分析

使用原则：
- 尽量使用精确匹配（=）
- 避免高基数标签
- 先过滤后查询
```

**🔹 时间相关概念**
```
时间区间：[5m] 查询数据的时间范围
时间偏移：offset 1h 查询过去的数据
选择原则：根据监控场景选择合适时长
```

### 8.3 实际应用指南


**📊 监控场景对应**
```
实时监控：
- cpu_usage
- memory_usage  
- response_time

趋势分析：
- cpu_usage[1h]
- rate(http_requests_total[5m])
- avg_over_time(response_time[30m])

对比分析：
- cpu_usage vs cpu_usage offset 1d
- 今日访问量 vs 昨日访问量
- 本周错误率 vs 上周错误率

告警规则：
- cpu_usage > 0.8
- rate(error_count[5m]) > 0.05
- avg_over_time(response_time[10m]) > 1
```

**🎯 学习路径建议**
```
第一步：掌握基本查询语法
- 理解即时向量和范围向量
- 学会使用标签过滤
- 熟悉时间区间表达式

第二步：学习实用技巧
- 掌握offset时间偏移
- 了解查询优化方法
- 学会组合不同语法

第三步：实际应用练习
- 编写监控查询
- 优化查询性能
- 结合业务场景使用
```

**核心记忆要点**：
- PromQL是专门查询时间序列数据的语言
- 通过标签精确筛选，通过时间区间控制范围
- 即时向量看现状，范围向量看趋势
- offset回看历史，优化提升性能