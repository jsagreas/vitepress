---
title: 5、高级查询技巧
---
## 📚 目录

1. [子查询语法详解](#1-子查询语法详解)
2. [向量匹配操作](#2-向量匹配操作)
3. [on/ignoring关键字](#3-onignoring关键字)
4. [group_left/group_right](#4-group_leftgroup_right)
5. [正则表达式匹配](#5-正则表达式匹配)
6. [复杂查询优化](#6-复杂查询优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 子查询语法详解


### 1.1 什么是子查询


**简单理解**：子查询就是在一个查询里面再嵌套另一个查询，就像俄罗斯套娃一样。

```
普通查询：查询CPU使用率
子查询：查询"过去5分钟内每分钟的平均CPU使用率"的最大值
```

**为什么需要子查询**：
- 🎯 **时间窗口分析**：分析一段时间内的数据变化趋势
- 🎯 **复杂计算**：需要先计算中间结果，再基于中间结果计算
- 🎯 **多层聚合**：比如求"每小时平均值"的"每日最大值"

### 1.2 子查询基本语法


**语法格式**：
```promql
<查询表达式>[<时间范围>:<分辨率>]
```

**参数解释**：
- **查询表达式**：普通的PromQL查询
- **时间范围**：要查询多长时间的数据（如`5m`表示5分钟）
- **分辨率**：每隔多长时间取一个数据点（如`1m`表示每分钟一个点）

### 1.3 实际应用示例


**📊 示例1：查询5分钟内CPU使用率的变化趋势**
```promql
# 获取过去5分钟内，每30秒的CPU使用率
rate(cpu_usage_total[1m])[5m:30s]
```

**含义解释**：
- `rate(cpu_usage_total[1m])`：计算CPU使用率
- `[5m:30s]`：取过去5分钟的数据，每30秒一个数据点
- 结果：得到10个数据点（5分钟÷30秒=10）

**📊 示例2：查询1小时内每5分钟的平均请求数**
```promql
# 先计算每5分钟的平均请求数，然后查看1小时内的趋势
avg_over_time(http_requests_total[5m])[1h:5m]
```

**实用场景**：
- ✅ 分析系统性能在一段时间内的波动
- ✅ 检测是否存在周期性问题
- ✅ 为告警规则提供更精准的数据基础

---

## 2. 🔄 向量匹配操作


### 2.1 向量匹配的本质


**通俗解释**：向量匹配就是告诉Prometheus"如何把两组数据正确地对应起来进行计算"。

```
就像班级考试：
语文成绩：张三85分，李四90分，王五78分
数学成绩：张三92分，李四88分，王五95分

要计算总分，必须确保"张三的语文"对应"张三的数学"
这就是向量匹配要解决的问题
```

### 2.2 匹配类型详解


**🔸 一对一匹配（One-to-One）**

最常见的匹配方式，每条记录都有唯一的对应关系。

```promql
# 计算CPU使用率
cpu_usage / cpu_total
```

**匹配原理**：
```
cpu_usage{instance="server1", cpu="0"} = 80
cpu_total{instance="server1", cpu="0"} = 100
→ 结果：{instance="server1", cpu="0"} = 0.8

cpu_usage{instance="server2", cpu="0"} = 60  
cpu_total{instance="server2", cpu="0"} = 100
→ 结果：{instance="server2", cpu="0"} = 0.6
```

**🔸 一对多匹配（One-to-Many）**

一条记录对应多条记录，需要使用`group_left`。

```promql
# 计算每个实例的网络流量占总流量的比例
network_bytes by (instance) / on() group_left sum(network_bytes)
```

**🔸 多对一匹配（Many-to-One）**

多条记录对应一条记录，需要使用`group_right`。

### 2.3 匹配失败的常见问题


**❌ 问题：标签不匹配**
```promql
# 错误示例
memory_used{instance="web1", type="app"} / memory_total{instance="web1"}
```

**原因**：`memory_used`有`type`标签，但`memory_total`没有，导致匹配失败。

**✅ 解决方案**：
```promql
# 忽略type标签进行匹配
memory_used / ignoring(type) memory_total
```

---

## 3. 🎯 on/ignoring关键字


### 3.1 on关键字：指定匹配标签


**作用**：告诉Prometheus"只根据这些标签进行匹配，其他标签忽略"。

**语法**：`on(标签1, 标签2, ...)`

### 3.2 实际应用场景


**📊 场景1：按实例匹配，忽略其他标签**
```promql
# 只根据instance标签匹配，忽略其他所有标签
cpu_usage / on(instance) cpu_limit
```

**匹配过程演示**：
```
# 数据源1
cpu_usage{instance="web1", core="0", mode="user"} = 30
cpu_usage{instance="web1", core="1", mode="user"} = 25
cpu_usage{instance="web2", core="0", mode="system"} = 40

# 数据源2  
cpu_limit{instance="web1"} = 100
cpu_limit{instance="web2"} = 100

# 匹配结果
{instance="web1"} = (30+25) / 100 = 0.55
{instance="web2"} = 40 / 100 = 0.4
```

### 3.3 ignoring关键字：忽略指定标签


**作用**：告诉Prometheus"除了这些标签，其他标签都要完全匹配"。

**语法**：`ignoring(标签1, 标签2, ...)`

**📊 场景2：忽略临时标签**
```promql
# 忽略job标签，其他标签必须完全匹配
http_requests / ignoring(job) http_requests_total
```

### 3.4 on vs ignoring 选择指南


| 使用场景 | 推荐选择 | 原因 |
|---------|---------|------|
| **标签很多，只关心少数几个** | `on(关键标签)` | 明确指定匹配条件 |
| **标签较少，只想忽略个别标签** | `ignoring(干扰标签)` | 保持大部分匹配逻辑 |
| **跨不同数据源匹配** | `on(公共标签)` | 确保匹配的稳定性 |

---

## 4. 🔗 group_left/group_right


### 4.1 什么时候需要group操作


**问题场景**：当两个数据集的标签数量不同时，无法直接匹配。

```
实际例子：
服务器监控数据：{instance="web1", cpu="0", mode="user"}
服务器信息数据：{instance="web1", hostname="frontend-01", zone="us-west"}

想要查询：每个服务器在哪个区域的CPU使用率最高？
```

### 4.2 group_left详解


**含义**：允许"左边"的数据集有更多标签。

**基本语法**：
```promql
多标签数据 / on(公共标签) group_left(保留标签) 少标签数据
```

**📊 实际示例**：
```promql
# 计算每个实例在各区域的CPU使用率
cpu_usage 
/ on(instance) group_left(zone, hostname) 
server_info
```

**匹配过程**：
```
# 左边数据（多标签）
cpu_usage{instance="web1", cpu="0"} = 80
cpu_usage{instance="web1", cpu="1"} = 75

# 右边数据（少标签）
server_info{instance="web1", zone="us-west", hostname="frontend"} = 1

# 结果：保留左边的标签 + group_left指定的右边标签
{instance="web1", cpu="0", zone="us-west", hostname="frontend"} = 80
{instance="web1", cpu="1", zone="us-west", hostname="frontend"} = 75
```

### 4.3 group_right详解


**含义**：允许"右边"的数据集有更多标签。

```promql
# 计算区域内服务器的资源利用率
zone_capacity 
/ on(zone) group_right(instance, hostname) 
server_usage
```

### 4.4 最佳实践


**✅ 推荐做法**：
- 优先使用`group_left`（更直观）
- 明确指定要保留的标签
- 先测试小数据集，确认匹配逻辑

**❌ 常见错误**：
```promql
# 错误：忘记指定保留的标签
cpu_usage / on(instance) group_left server_info

# 正确：明确指定要保留的标签  
cpu_usage / on(instance) group_left(zone) server_info
```

---

## 5. 🔤 正则表达式匹配


### 5.1 正则匹配的应用场景


**为什么需要正则匹配**：
- 🎯 **批量筛选**：一次性选择多个相似的标签值
- 🎯 **模糊匹配**：不需要记住完整的标签名
- 🎯 **动态查询**：根据模式而不是具体值进行查询

### 5.2 基本正则操作符


**🔸 `=~` 正则匹配**
```promql
# 查询所有web服务器的CPU使用率
cpu_usage{instance=~"web.*"}
```

**🔸 `!~` 正则不匹配**
```promql
# 查询除了test环境外的所有服务器
cpu_usage{instance!~".*test.*"}
```

### 5.3 实用正则表达式模式


**📊 常用模式示例**：

```promql
# 1. 多个具体值匹配
http_requests{method=~"GET|POST|PUT"}

# 2. 环境筛选
memory_usage{env=~"prod|staging"}

# 3. 服务器编号匹配
disk_usage{instance=~"web[0-9]+"}

# 4. 排除特定模式
network_traffic{interface!~"lo|docker.*"}

# 5. 复杂组合匹配
app_requests{
  service=~"user-service.*",
  version!~".*beta.*",
  region=~"us-.*|eu-.*"
}
```

### 5.4 正则表达式最佳实践


**性能优化**：
```promql
# ✅ 好的做法：先用精确匹配缩小范围
{job="web-server", instance=~"prod-web[0-9]+"}

# ❌ 避免：过于宽泛的正则
{instance=~".*"}
```

**可读性提升**：
```promql
# ✅ 清晰的模式
{environment=~"production|staging"}

# ❌ 复杂难懂的模式  
{instance=~"^(?!.*test).*web.*[0-9]{2}$"}
```

---

## 6. ⚡ 复杂查询优化


### 6.1 查询性能问题诊断


**🔍 常见性能瓶颈**：
- **时间范围过大**：查询跨度太长导致数据量激增
- **标签过滤不足**：没有充分利用标签缩小查询范围
- **函数嵌套过深**：复杂的计算逻辑影响执行效率

### 6.2 优化策略详解


**🚀 策略1：缩小查询范围**

```promql
# ❌ 低效查询
sum(rate(http_requests_total[1h])) by (service)

# ✅ 优化后
sum(rate(http_requests_total{job="web-server"}[5m])) by (service)
```

**优化要点**：
- 使用具体的标签筛选（如`job="web-server"`）
- 合理选择时间窗口（通常5-15分钟足够）
- 避免不必要的长时间聚合

**🚀 策略2：合理使用聚合函数**

```promql
# ❌ 先聚合再筛选（低效）
sum(cpu_usage) by (instance) > 0.8

# ✅ 先筛选再聚合（高效）
sum(cpu_usage{instance=~"prod.*"}) by (instance) > 0.8
```

### 6.3 复杂查询分解技巧


**📊 示例：监控服务健康度**

**复杂需求**：计算每个服务在过去1小时内的平均成功率，并标注所属区域信息。

**❌ 一次性复杂查询**：
```promql
sum(rate(http_requests_total{status!~"5.."}[1h])) by (service) 
/ on(service) group_left(zone) 
sum(rate(http_requests_total[1h])) by (service) 
* on(service) group_left(zone) 
service_info
```

**✅ 分步骤查询**：

第一步：计算成功请求率
```promql
success_rate = sum(rate(http_requests_total{status!~"5.."}[5m])) by (service)
```

第二步：计算总请求率
```promql
total_rate = sum(rate(http_requests_total[5m])) by (service)
```

第三步：计算成功率并添加区域信息
```promql
(success_rate / total_rate) * on(service) group_left(zone) service_info
```

### 6.4 查询调试技巧


**🔧 调试步骤**：

1. **验证基础指标**：
```promql
# 先确认数据是否存在
http_requests_total{job="web-server"}
```

2. **逐步增加复杂度**：
```promql
# 第一步：基础rate计算
rate(http_requests_total[5m])

# 第二步：添加聚合
sum(rate(http_requests_total[5m])) by (service)

# 第三步：添加筛选条件
sum(rate(http_requests_total{status="200"}[5m])) by (service)
```

3. **检查结果合理性**：
   - 数值范围是否正常
   - 时间序列数量是否符合预期
   - 标签组合是否正确

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 子查询：查询中嵌套查询，用于时间窗口分析
🔸 向量匹配：控制两组数据如何正确对应计算
🔸 on/ignoring：精确控制标签匹配逻辑
🔸 group_left/right：处理标签数量不同的匹配场景
🔸 正则表达式：灵活的模式匹配和批量筛选
🔸 查询优化：提升性能和可维护性的实用技巧
```

### 7.2 关键技能对照表


| 技能 | **掌握标准** | **实际应用** |
|------|-------------|-------------|
| 🎯 **子查询** | `能写出[5m:1m]格式查询` | `分析趋势变化，检测异常模式` |
| 🔄 **向量匹配** | `理解一对一、一对多匹配` | `关联不同数据源计算比率` |
| 🎯 **标签控制** | `熟练使用on/ignoring` | `处理标签不一致的匹配问题` |
| 🔗 **group操作** | `正确使用group_left/right` | `保留额外标签信息` |
| 🔤 **正则匹配** | `掌握=~和!~操作符` | `批量筛选和模糊匹配` |
| ⚡ **性能优化** | `能诊断和优化慢查询` | `保证监控系统稳定运行` |

### 7.3 学习进阶路径


**🎯 阶段1：基础掌握**
- [x] 理解子查询的语法和用途
- [x] 掌握基本的向量匹配概念
- [x] 学会使用on/ignoring关键字

**🎯 阶段2：实践应用**
- [ ] 能够处理复杂的标签匹配场景
- [ ] 熟练使用正则表达式筛选数据
- [ ] 掌握group_left/right的使用时机

**🎯 阶段3：性能优化**
- [ ] 能够识别和优化慢查询
- [ ] 理解查询执行计划
- [ ] 掌握复杂查询的分解技巧

### 7.4 常见问题速查


**❓ 子查询结果为空？**
- 检查时间范围是否合理
- 确认分辨率设置是否过细
- 验证基础查询是否有数据

**❓ 向量匹配失败？**
- 检查两边数据的标签是否对应
- 使用`on()`或`ignoring()`调整匹配逻辑
- 考虑是否需要group_left/right

**❓ 正则表达式不生效？**
- 确认使用`=~`而不是`=`
- 检查正则语法是否正确
- 测试简单模式后再增加复杂度

**❓ 查询速度太慢？**
- 添加更多标签筛选条件
- 减少时间范围
- 考虑使用recording rules预计算

### 7.5 实战建议


**🛠️ 开发环境实践**：
1. 从简单查询开始，逐步增加复杂度
2. 每个新概念都要实际操作验证
3. 保存有用的查询模板备用
4. 定期review和优化现有查询

**📊 生产环境应用**：
1. 先在测试环境验证复杂查询
2. 监控查询性能，设置合理超时
3. 建立查询规范和最佳实践文档
4. 定期清理不再使用的复杂查询

**核心记忆**：
- PromQL高级特性让复杂监控成为可能
- 合理的标签匹配是查询成功的关键
- 性能优化要从查询设计开始考虑
- 复杂查询要分步调试，确保每步正确