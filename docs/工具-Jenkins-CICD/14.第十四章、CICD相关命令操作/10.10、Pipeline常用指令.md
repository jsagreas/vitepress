---
title: 10、Pipeline常用指令
---
## 📚 目录

1. [Pipeline指令概述](#1-pipeline指令概述)
2. [代码检出指令checkout](#2-代码检出指令checkout)
3. [命令执行指令sh-bat](#3-命令执行指令sh-bat)
4. [信息输出指令echo](#4-信息输出指令echo)
5. [目录操作指令dir](#5-目录操作指令dir)
6. [脚本块指令script](#6-脚本块指令script)
7. [报告发布指令publishHTML](#7-报告发布指令publishhtml)
8. [产物存档指令archiveArtifacts](#8-产物存档指令archiveartifacts)
9. [工作空间清理指令cleanWs](#9-工作空间清理指令cleanws)
10. [指令组合实战案例](#10-指令组合实战案例)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 Pipeline指令概述


### 1.1 什么是Pipeline指令


**简单理解**：Pipeline指令就像是给Jenkins发送的**"命令清单"**，告诉它该做什么事情。

```
就像你给朋友发微信：
"帮我去超市买点东西"     → 这是一个指令
"先买牛奶，再买面包"     → 这是具体的执行步骤
"买完发个照片给我"       → 这是结果反馈

Jenkins Pipeline指令也是这样：
checkout → "去代码仓库拿代码"
sh → "执行这个命令"
echo → "打印这个信息"
```

### 1.2 指令的基本分类


**📋 按功能分类**：

| 分类 | **作用** | **常用指令** | **比喻** |
|-----|---------|-------------|---------|
| 🔄 **代码相关** | `获取和管理代码` | `checkout` | `去仓库取货` |
| ⚡ **执行相关** | `运行命令和脚本` | `sh, bat, script` | `按说明书操作` |
| 📢 **输出相关** | `显示信息和日志` | `echo` | `汇报进度` |
| 📁 **文件相关** | `管理文件和目录` | `dir, archiveArtifacts` | `整理物品` |
| 📊 **发布相关** | `发布结果和报告` | `publishHTML` | `展示成果` |
| 🧹 **清理相关** | `清理工作环境` | `cleanWs` | `收拾现场` |

### 1.3 指令的执行环境


**🏠 工作空间概念**：
```
Jenkins工作空间就像你的临时办公桌：

物理位置：/var/jenkins_home/workspace/你的项目名/
作用：
• 存放从代码仓库下载的代码
• 执行各种构建命令
• 临时存储构建过程中的文件
• 最终产出构建结果

特点：
• 每个Job都有独立的工作空间
• 构建完成后可以选择清理
• 支持多个构建同时进行（不同目录）
```

---

## 2. 📥 代码检出指令checkout


### 2.1 checkout指令的作用


**💡 通俗解释**：`checkout`就像是**"去仓库取货"**，把代码从Git仓库下载到Jenkins的工作空间。

**🔸 核心作用**：
- 从Git仓库拉取最新代码
- 指定拉取特定分支或标签
- 处理代码下载过程中的各种情况

### 2.2 基本用法


**📝 最简单的用法**：
```groovy
pipeline {
    agent any
    stages {
        stage('获取代码') {
            steps {
                // 自动检出当前分支的代码
                checkout scm
            }
        }
    }
}
```

> **💭 理解要点**：`scm`是"Source Code Management"的缩写，表示源码管理。Jenkins会自动从项目配置的代码仓库获取代码。

### 2.3 高级用法配置


**🔧 指定分支和仓库**：
```groovy
stage('获取指定分支代码') {
    steps {
        checkout([
            $class: 'GitSCM',
            branches: [[name: '*/main']],  // 指定分支
            userRemoteConfigs: [[
                url: 'https://github.com/your-repo.git',
                credentialsId: 'your-git-credentials'  // 凭证ID
            ]]
        ])
    }
}
```

**📊 参数说明**：

| 参数 | **含义** | **示例** | **作用** |
|-----|---------|---------|---------|
| `branches` | `要拉取的分支` | `*/main, */develop` | `指定具体分支` |
| `url` | `Git仓库地址` | `https://github.com/xxx.git` | `代码来源` |
| `credentialsId` | `访问凭证` | `github-token` | `身份验证` |

### 2.4 实际应用场景


**🎯 多分支构建策略**：
```groovy
script {
    // 根据不同分支采用不同策略
    if (env.BRANCH_NAME == 'main') {
        echo "生产分支，进行完整构建"
        checkout scm
    } else if (env.BRANCH_NAME.startsWith('feature/')) {
        echo "功能分支，进行快速验证"
        checkout scm
    }
}
```

**⚠️ 常见问题处理**：
```groovy
stage('安全代码检出') {
    steps {
        script {
            try {
                checkout scm
                echo "代码检出成功"
            } catch (Exception e) {
                echo "代码检出失败: ${e.getMessage()}"
                error("构建终止")
            }
        }
    }
}
```

---

## 3. 💻 命令执行指令sh/bat


### 3.1 sh和bat的区别


**🔸 简单区别**：
- **`sh`**：在Linux/Mac系统上执行Shell命令
- **`bat`**：在Windows系统上执行批处理命令

```
类比理解：
sh   → 像在Linux终端输入命令
bat  → 像在Windows命令提示符输入命令

选择原则：
• Jenkins运行在Linux → 用sh
• Jenkins运行在Windows → 用bat
• 大部分企业环境 → 用sh
```

### 3.2 sh指令基本用法


**📝 单行命令**：
```groovy
stage('执行构建') {
    steps {
        sh 'npm install'                    // 安装依赖
        sh 'npm run build'                  // 执行构建
        sh 'ls -la'                        // 查看文件列表
    }
}
```

**📝 多行命令**：
```groovy
stage('复杂构建脚本') {
    steps {
        sh '''
            echo "开始构建前的准备工作"
            node --version
            npm --version
            npm install
            npm run test
            npm run build
            echo "构建完成"
        '''
    }
}
```

> **💡 提示**：三个单引号`'''`可以写多行Shell命令，非常适合复杂的构建脚本。

### 3.3 命令执行的高级技巧


**🔸 获取命令执行结果**：
```groovy
stage('获取构建信息') {
    steps {
        script {
            // 获取Git提交ID
            def commitId = sh(
                script: 'git rev-parse HEAD',
                returnStdout: true
            ).trim()
            echo "当前提交ID: ${commitId}"
            
            // 获取构建时间
            def buildTime = sh(
                script: 'date +"%Y-%m-%d %H:%M:%S"',
                returnStdout: true
            ).trim()
            echo "构建时间: ${buildTime}"
        }
    }
}
```

**🔸 条件执行命令**：
```groovy
stage('环境检查') {
    steps {
        script {
            // 检查Node.js是否安装
            def nodeExists = sh(
                script: 'which node',
                returnStatus: true
            )
            
            if (nodeExists == 0) {
                echo "Node.js已安装"
                sh 'node --version'
            } else {
                echo "Node.js未安装，开始安装..."
                sh 'curl -sL https://rpm.nodesource.com/setup_16.x | bash -'
            }
        }
    }
}
```

### 3.4 错误处理和日志


**⚠️ 处理命令失败**：
```groovy
stage('安全执行命令') {
    steps {
        script {
            try {
                sh 'npm test'
            } catch (Exception e) {
                echo "测试失败，但继续构建"
                echo "错误信息: ${e.getMessage()}"
                // 可以选择继续或者终止
                currentBuild.result = 'UNSTABLE'
            }
        }
    }
}
```

---

## 4. 📢 信息输出指令echo


### 4.1 echo指令的作用


**💡 简单理解**：`echo`就像是给Jenkins的**"汇报员"**，把重要信息显示在构建日志中。

**🔸 主要用途**：
- 显示构建进度信息
- 输出调试信息
- 展示变量值
- 记录重要的构建节点

### 4.2 基本使用方法


**📝 简单信息输出**：
```groovy
stage('信息展示') {
    steps {
        echo "开始执行构建任务"
        echo "当前构建号: ${BUILD_NUMBER}"
        echo "构建分支: ${BRANCH_NAME}"
        echo "============================"
    }
}
```

**📝 变量和表达式输出**：
```groovy
stage('动态信息') {
    steps {
        script {
            def projectName = "我的项目"
            def buildTime = new Date().format("yyyy-MM-dd HH:mm:ss")
            
            echo "项目名称: ${projectName}"
            echo "构建时间: ${buildTime}"
            echo "工作目录: ${WORKSPACE}"
            echo "Jenkins地址: ${JENKINS_URL}"
        }
    }
}
```

### 4.3 格式化输出技巧


**🎨 美化输出格式**：
```groovy
stage('格式化信息展示') {
    steps {
        echo """
        ================================
        🚀 Jenkins 构建信息
        ================================
        📦 项目名称: ${JOB_NAME}
        🏷️  构建编号: ${BUILD_NUMBER}
        🌿 代码分支: ${BRANCH_NAME}
        ⏰ 构建时间: ${new Date().format("yyyy-MM-dd HH:mm:ss")}
        📁 工作目录: ${WORKSPACE}
        ================================
        """
    }
}
```

**📊 条件输出**：
```groovy
stage('智能信息提示') {
    steps {
        script {
            if (env.BRANCH_NAME == 'main') {
                echo "🔥 正在构建生产环境版本"
            } else if (env.BRANCH_NAME.startsWith('feature/')) {
                echo "🧪 正在构建功能分支版本"
            } else {
                echo "📝 正在构建开发版本"
            }
            
            // 根据构建结果输出不同信息
            echo "当前构建状态检查..."
            def buildStatus = currentBuild.currentResult ?: 'SUCCESS'
            echo "构建状态: ${buildStatus}"
        }
    }
}
```

---

## 5. 📁 目录操作指令dir


### 5.1 dir指令的作用


**💡 通俗解释**：`dir`指令就像是**"切换工作场所"**，让后续的命令在指定目录中执行。

**🔸 核心概念**：
```
类比理解：
你在家里(根目录) → dir('厨房') → 现在在厨房做饭
                → dir('书房') → 现在在书房工作

Jenkins工作空间：
/workspace/project/ → dir('frontend') → 进入前端目录
                   → dir('backend')  → 进入后端目录
```

### 5.2 基本用法


**📝 简单目录切换**：
```groovy
stage('前端构建') {
    steps {
        dir('frontend') {
            echo "当前在前端目录"
            sh 'npm install'
            sh 'npm run build'
        }
    }
}

stage('后端构建') {
    steps {
        dir('backend') {
            echo "当前在后端目录"
            sh 'mvn clean package'
        }
    }
}
```

**📝 嵌套目录操作**：
```groovy
stage('多层目录构建') {
    steps {
        dir('projects') {
            dir('web-app') {
                echo "在 projects/web-app 目录中"
                sh 'ls -la'
                
                dir('src') {
                    echo "在 projects/web-app/src 目录中"
                    sh 'find . -name "*.js"'
                }
            }
        }
    }
}
```

### 5.3 实际应用场景


**🏗️ 微服务项目构建**：
```groovy
pipeline {
    agent any
    stages {
        stage('获取代码') {
            steps {
                checkout scm
            }
        }
        
        stage('用户服务构建') {
            steps {
                dir('user-service') {
                    echo "🚀 构建用户服务..."
                    sh 'mvn clean package'
                    archiveArtifacts artifacts: 'target/*.jar'
                }
            }
        }
        
        stage('订单服务构建') {
            steps {
                dir('order-service') {
                    echo "🚀 构建订单服务..."
                    sh 'mvn clean package'
                    archiveArtifacts artifacts: 'target/*.jar'
                }
            }
        }
        
        stage('前端构建') {
            steps {
                dir('web-frontend') {
                    echo "🚀 构建前端应用..."
                    sh 'npm install'
                    sh 'npm run build'
                    archiveArtifacts artifacts: 'dist/**'
                }
            }
        }
    }
}
```

**⚡ 目录检查和创建**：
```groovy
stage('智能目录管理') {
    steps {
        script {
            // 检查目录是否存在
            if (fileExists('build')) {
                dir('build') {
                    echo "build目录存在，清理旧文件"
                    sh 'rm -rf *'
                }
            } else {
                echo "创建build目录"
                sh 'mkdir -p build'
            }
            
            dir('build') {
                echo "在build目录中执行构建"
                sh 'cmake ..'
                sh 'make'
            }
        }
    }
}
```

---

## 6. 🔧 脚本块指令script


### 6.1 script块的作用


**💡 简单理解**：`script`块就像是Pipeline中的**"编程区域"**，可以写复杂的逻辑代码。

**🔸 为什么需要script块**：
```
声明式Pipeline的限制：
• 只能使用预定义的指令
• 不能写复杂的if-else逻辑
• 不能定义复杂的变量操作

script块的能力：
• 可以写任意Groovy代码
• 支持复杂的条件判断
• 可以定义函数和变量
• 能处理复杂的业务逻辑
```

### 6.2 基本用法


**📝 简单逻辑判断**：
```groovy
stage('智能构建') {
    steps {
        script {
            def buildType = params.BUILD_TYPE ?: 'development'
            
            if (buildType == 'production') {
                echo "🔥 生产环境构建"
                sh 'npm run build:prod'
            } else if (buildType == 'testing') {
                echo "🧪 测试环境构建"
                sh 'npm run build:test'
            } else {
                echo "🛠️ 开发环境构建"
                sh 'npm run build:dev'
            }
        }
    }
}
```

**📝 变量和函数定义**：
```groovy
stage('复杂脚本逻辑') {
    steps {
        script {
            // 定义变量
            def projectVersion = "1.0.${BUILD_NUMBER}"
            def buildTime = new Date().format("yyyy-MM-dd HH:mm:ss")
            
            // 定义函数
            def sendNotification(message) {
                echo "📢 通知: ${message}"
                // 这里可以集成钉钉、企微等通知
            }
            
            // 使用变量和函数
            echo "项目版本: ${projectVersion}"
            sendNotification("开始构建版本 ${projectVersion}")
            
            // 复杂条件判断
            try {
                sh 'npm test'
                sendNotification("✅ 测试通过")
            } catch (Exception e) {
                sendNotification("❌ 测试失败: ${e.getMessage()}")
                throw e
            }
        }
    }
}
```

### 6.3 高级应用场景


**🔄 动态Pipeline生成**：
```groovy
stage('动态构建多个项目') {
    steps {
        script {
            def projects = ['frontend', 'backend', 'mobile']
            def builds = [:]
            
            // 动态生成并行构建任务
            projects.each { project ->
                builds[project] = {
                    dir(project) {
                        echo "🚀 构建 ${project} 项目"
                        if (project == 'frontend') {
                            sh 'npm install && npm run build'
                        } else if (project == 'backend') {
                            sh 'mvn clean package'
                        } else if (project == 'mobile') {
                            sh 'flutter build apk'
                        }
                    }
                }
            }
            
            // 并行执行所有构建
            parallel builds
        }
    }
}
```

**📊 构建状态管理**：
```groovy
stage('构建状态跟踪') {
    steps {
        script {
            def buildSteps = [
                '代码检出': false,
                '依赖安装': false,
                '代码编译': false,
                '单元测试': false,
                '打包部署': false
            ]
            
            try {
                // 代码检出
                checkout scm
                buildSteps['代码检出'] = true
                echo "✅ 代码检出完成"
                
                // 依赖安装
                sh 'npm install'
                buildSteps['依赖安装'] = true
                echo "✅ 依赖安装完成"
                
                // 代码编译
                sh 'npm run build'
                buildSteps['代码编译'] = true
                echo "✅ 代码编译完成"
                
                // 单元测试
                sh 'npm test'
                buildSteps['单元测试'] = true
                echo "✅ 单元测试完成"
                
            } catch (Exception e) {
                echo "❌ 构建失败"
                buildSteps.each { step, status ->
                    echo "${status ? '✅' : '❌'} ${step}"
                }
                throw e
            }
        }
    }
}
```

---

## 7. 📊 报告发布指令publishHTML


### 7.1 publishHTML的作用


**💡 通俗解释**：`publishHTML`就像是**"成果展示厅"**，把构建产生的HTML报告漂亮地展示在Jenkins界面上。

**🔸 常见报告类型**：
- 📊 **测试覆盖率报告**：显示代码测试覆盖情况
- 🧪 **单元测试报告**：展示测试结果详情
- 📈 **性能测试报告**：显示应用性能指标
- 📋 **代码质量报告**：展示代码规范检查结果

### 7.2 基本用法


**📝 发布测试报告**：
```groovy
stage('发布测试报告') {
    steps {
        // 执行测试并生成报告
        sh 'npm test -- --coverage'
        
        // 发布HTML报告
        publishHTML([
            allowMissing: false,          // 报告文件不存在时是否允许
            alwaysLinkToLastBuild: true,  // 总是链接到最新构建
            keepAll: true,                // 保留所有构建的报告
            reportDir: 'coverage',        // 报告所在目录
            reportFiles: 'index.html',    // 报告文件名
            reportName: '测试覆盖率报告'     // 在Jenkins中显示的名称
        ])
    }
}
```

**📝 发布多个报告**：
```groovy
stage('发布多种报告') {
    steps {
        // 生成各种报告
        sh 'npm run test:coverage'
        sh 'npm run lint:report'
        sh 'npm run docs:build'
        
        // 发布测试覆盖率报告
        publishHTML([
            allowMissing: false,
            alwaysLinkToLastBuild: true,
            keepAll: true,
            reportDir: 'coverage',
            reportFiles: 'index.html',
            reportName: '📊 测试覆盖率报告'
        ])
        
        // 发布代码规范检查报告
        publishHTML([
            allowMissing: false,
            alwaysLinkToLastBuild: true,
            keepAll: true,
            reportDir: 'lint-results',
            reportFiles: 'report.html',
            reportName: '📋 代码规范报告'
        ])
        
        // 发布API文档
        publishHTML([
            allowMissing: false,
            alwaysLinkToLastBuild: true,
            keepAll: true,
            reportDir: 'docs/build',
            reportFiles: 'index.html',
            reportName: '📚 API文档'
        ])
    }
}
```

### 7.3 参数详解


**📊 参数说明表**：

| 参数 | **类型** | **作用** | **示例** |
|-----|---------|---------|---------|
| `allowMissing` | `boolean` | `报告不存在时是否继续` | `false(必须存在)` |
| `alwaysLinkToLastBuild` | `boolean` | `是否总是链接最新构建` | `true(推荐)` |
| `keepAll` | `boolean` | `是否保留历史报告` | `true(便于对比)` |
| `reportDir` | `string` | `报告文件所在目录` | `'coverage'` |
| `reportFiles` | `string` | `报告入口文件` | `'index.html'` |
| `reportName` | `string` | `Jenkins中显示名称` | `'测试报告'` |

### 7.4 实际应用案例


**🏗️ 完整的前端项目报告发布**：
```groovy
stage('前端构建与报告') {
    steps {
        script {
            try {
                echo "📦 安装依赖..."
                sh 'npm ci'
                
                echo "🧪 执行单元测试..."
                sh 'npm run test:unit -- --coverage --reporter=html'
                
                echo "🔍 执行代码检查..."
                sh 'npm run lint -- --format html --output-file lint-report.html'
                
                echo "📊 执行性能测试..."
                sh 'npm run test:performance'
                
                echo "🚀 构建生产版本..."
                sh 'npm run build'
                
            } catch (Exception e) {
                echo "❌ 构建过程出现错误: ${e.getMessage()}"
                throw e
            } finally {
                // 无论成功失败都发布报告
                publishHTML([
                    allowMissing: true,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: 'coverage',
                    reportFiles: 'index.html',
                    reportName: '📊 单元测试覆盖率'
                ])
                
                publishHTML([
                    allowMissing: true,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: '.',
                    reportFiles: 'lint-report.html',
                    reportName: '📋 代码质量检查'
                ])
                
                if (fileExists('performance-report/index.html')) {
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'performance-report',
                        reportFiles: 'index.html',
                        reportName: '⚡ 性能测试报告'
                    ])
                }
            }
        }
    }
}
```

---

## 8. 📦 产物存档指令archiveArtifacts


### 8.1 archiveArtifacts的作用


**💡 通俗解释**：`archiveArtifacts`就像是**"保险箱"**，把构建产生的重要文件永久保存起来，方便以后下载使用。

**🔸 什么是构建产物**：
```
构建产物就是构建过程的"成果"：

前端项目：
• dist/ 目录下的静态文件
• 压缩后的CSS、JS文件
• 生成的HTML页面

后端项目：
• JAR包、WAR包
• Docker镜像文件
• 配置文件

移动应用：
• APK安装包
• IPA安装包
• 符号表文件
```

### 8.2 基本用法


**📝 存档单个文件**：
```groovy
stage('构建并存档') {
    steps {
        // 执行构建
        sh 'mvn clean package'
        
        // 存档JAR文件
        archiveArtifacts artifacts: 'target/*.jar'
    }
}
```

**📝 存档多种文件**：
```groovy
stage('前端构建存档') {
    steps {
        sh 'npm run build'
        
        // 存档多种构建产物
        archiveArtifacts artifacts: '''
            dist/**/*,
            package.json,
            README.md
        '''
    }
}
```

### 8.3 高级配置选项


**🔧 完整配置示例**：
```groovy
stage('智能产物存档') {
    steps {
        script {
            // 构建项目
            sh 'npm run build'
            
            // 检查构建产物是否存在
            if (fileExists('dist')) {
                archiveArtifacts([
                    artifacts: 'dist/**/*',              // 要存档的文件
                    allowEmptyArchive: false,             // 不允许空存档
                    fingerprint: true,                    // 生成文件指纹
                    onlyIfSuccessful: true,              // 只有成功时才存档
                    excludes: '**/*.tmp,**/*.log'        // 排除临时文件
                ])
                echo "✅ 构建产物存档成功"
            } else {
                echo "⚠️ 未找到构建产物，跳过存档"
            }
        }
    }
}
```

**📊 参数详解**：

| 参数 | **作用** | **示例** | **建议值** |
|-----|---------|---------|-----------|
| `artifacts` | `指定要存档的文件` | `'target/*.jar'` | `根据项目类型` |
| `allowEmptyArchive` | `允许空存档` | `false` | `false` |
| `fingerprint` | `生成文件指纹` | `true` | `true` |
| `onlyIfSuccessful` | `仅成功时存档` | `true` | `true` |
| `excludes` | `排除文件` | `'**/*.log'` | `排除日志临时文件` |

### 8.4 实际应用场景


**🏗️ 多环境构建存档**：
```groovy
pipeline {
    agent any
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['development', 'testing', 'production'],
            description: '选择构建环境'
        )
    }
    
    stages {
        stage('环境构建') {
            steps {
                script {
                    def env = params.ENVIRONMENT
                    echo "🚀 构建 ${env} 环境版本"
                    
                    // 根据环境执行不同构建
                    if (env == 'production') {
                        sh 'npm run build:prod'
                    } else if (env == 'testing') {
                        sh 'npm run build:test'
                    } else {
                        sh 'npm run build:dev'
                    }
                    
                    // 创建版本信息文件
                    sh """
                        echo "构建环境: ${env}" > build-info.txt
                        echo "构建时间: \$(date)" >> build-info.txt
                        echo "构建编号: ${BUILD_NUMBER}" >> build-info.txt
                        echo "Git提交: \$(git rev-parse HEAD)" >> build-info.txt
                    """
                    
                    // 存档构建产物
                    archiveArtifacts([
                        artifacts: """
                            dist/**/*,
                            build-info.txt,
                            package.json
                        """,
                        fingerprint: true,
                        onlyIfSuccessful: true
                    ])
                    
                    echo "✅ ${env} 环境构建产物存档完成"
                }
            }
        }
    }
}
```

**🔄 版本化存档管理**：
```groovy
stage('版本化存档') {
    steps {
        script {
            def version = "v1.0.${BUILD_NUMBER}"
            def timestamp = new Date().format("yyyyMMdd-HHmmss")
            
            // 构建
            sh 'mvn clean package'
            
            // 重命名产物文件
            sh """
                cd target
                for jar in *.jar; do
                    mv "\$jar" "${version}-${timestamp}-\$jar"
                done
            """
            
            // 存档带版本号的产物
            archiveArtifacts([
                artifacts: "target/${version}-${timestamp}-*.jar",
                fingerprint: true,
                allowEmptyArchive: false
            ])
            
            echo "✅ 版本 ${version} 构建产物存档完成"
        }
    }
}
```

---

## 9. 🧹 工作空间清理指令cleanWs


### 9.1 cleanWs的作用


**💡 通俗解释**：`cleanWs`就像是**"大扫除"**，把Jenkins工作空间里的文件清理干净，为下次构建做准备。

**🔸 为什么需要清理工作空间**：
```
工作空间问题：
• 文件越积越多，占用磁盘空间
• 旧文件可能影响新构建
• 构建环境不干净，可能出现奇怪问题
• 敏感信息需要及时清理

清理的好处：
• 确保每次构建环境干净
• 节省磁盘空间
• 提高构建可靠性
• 保护敏感信息
```

### 9.2 基本用法


**📝 最简单的清理**：
```groovy
pipeline {
    agent any
    stages {
        stage('构建') {
            steps {
                checkout scm
                sh 'npm install'
                sh 'npm run build'
            }
        }
    }
    post {
        always {
            // 构建完成后总是清理工作空间
            cleanWs()
        }
    }
}
```

**📝 有选择的清理**：
```groovy
stage('智能清理') {
    steps {
        script {
            // 根据构建结果决定是否清理
            if (currentBuild.result == 'SUCCESS') {
                echo "✅ 构建成功，清理工作空间"
                cleanWs()
            } else {
                echo "❌ 构建失败，保留文件用于调试"
                echo "工作空间保留在: ${WORKSPACE}"
            }
        }
    }
}
```

### 9.3 高级清理配置


**🔧 保留特定文件**：
```groovy
post {
    always {
        cleanWs([
            cleanWhenNotBuilt: false,           // 未构建时不清理
            deleteDirs: true,                   // 删除目录
            disableDeferredWipeout: true,       // 禁用延迟清理
            notFailBuild: true,                 // 清理失败不影响构建结果
            patterns: [
                [pattern: 'logs/**', type: 'EXCLUDE'],      // 保留日志
                [pattern: '*.tmp', type: 'INCLUDE'],        // 删除临时文件
                [pattern: 'node_modules/**', type: 'INCLUDE'] // 删除依赖
            ]
        ])
    }
}
```

**📊 清理配置参数**：

| 参数 | **作用** | **默认值** | **建议** |
|-----|---------|-----------|---------|
| `cleanWhenNotBuilt` | `未构建时是否清理` | `true` | `false` |
| `deleteDirs` | `是否删除目录` | `true` | `true` |
| `disableDeferredWipeout` | `禁用延迟清理` | `false` | `true` |
| `notFailBuild` | `清理失败不影响构建` | `true` | `true` |
| `patterns` | `清理模式规则` | `[]` | `按需配置` |

### 9.4 清理策略最佳实践


**🎯 分阶段清理策略**：
```groovy
pipeline {
    agent any
    
    stages {
        stage('预清理') {
            steps {
                script {
                    echo "🧹 清理上次构建残留文件"
                    // 清理特定文件，但保留缓存
                    cleanWs([
                        patterns: [
                            [pattern: 'dist/**', type: 'INCLUDE'],
                            [pattern: 'build/**', type: 'INCLUDE'],
                            [pattern: '*.log', type: 'INCLUDE']
                        ]
                    ])
                }
            }
        }
        
        stage('构建') {
            steps {
                checkout scm
                sh 'npm ci --cache .npm'  // 使用缓存
                sh 'npm run build'
            }
        }
        
        stage('测试') {
            steps {
                sh 'npm test'
            }
        }
    }
    
    post {
        success {
            echo "✅ 构建成功，保留构建产物"
            cleanWs([
                patterns: [
                    [pattern: 'dist/**', type: 'EXCLUDE'],      // 保留构建产物
                    [pattern: '.npm/**', type: 'EXCLUDE'],      // 保留npm缓存
                    [pattern: 'node_modules/**', type: 'INCLUDE'] // 删除依赖
                ]
            ])
        }
        failure {
            echo "❌ 构建失败，保留所有文件用于调试"
            // 不清理，便于调试
        }
        always {
            echo "📊 当前工作空间使用情况:"
            sh 'du -sh * 2>/dev/null || echo "工作空间已清理"'
        }
    }
}
```

**💾 磁盘空间监控清理**：
```groovy
stage('智能磁盘管理') {
    steps {
        script {
            // 检查磁盘使用情况
            def diskUsage = sh(
                script: "df ${WORKSPACE} | tail -1 | awk '{print \$5}' | sed 's/%//'",
                returnStdout: true
            ).trim() as Integer
            
            echo "当前磁盘使用率: ${diskUsage}%"
            
            if (diskUsage > 80) {
                echo "🚨 磁盘空间不足，执行深度清理"
                cleanWs([
                    deleteDirs: true,
                    patterns: [
                        [pattern: '**/.git/**', type: 'INCLUDE'],
                        [pattern: '**/node_modules/**', type: 'INCLUDE'],
                        [pattern: '**/target/**', type: 'INCLUDE']
                    ]
                ])
            } else if (diskUsage > 60) {
                echo "⚠️ 磁盘使用率较高，清理临时文件"
                cleanWs([
                    patterns: [
                        [pattern: '**/*.tmp', type: 'INCLUDE'],
                        [pattern: '**/*.log', type: 'INCLUDE'],
                        [pattern: '**/temp/**', type: 'INCLUDE']
                    ]
                ])
            } else {
                echo "✅ 磁盘空间充足，保持当前状态"
            }
        }
    }
}
```

---

## 10. 🔧 指令组合实战案例


### 10.1 完整的前端项目Pipeline


**🚀 React项目完整构建流程**：
```groovy
pipeline {
    agent any
    
    parameters {
        choice(
            name: 'DEPLOY_ENV',
            choices: ['development', 'testing', 'production'],
            description: '选择部署环境'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: '是否跳过测试'
        )
    }
    
    environment {
        NODE_VERSION = '16'
        PROJECT_NAME = 'my-react-app'
    }
    
    stages {
        stage('🧹 环境准备') {
            steps {
                script {
                    echo """
                    ================================
                    🚀 开始构建 ${PROJECT_NAME}
                    ================================
                    📦 构建环境: ${params.DEPLOY_ENV}
                    🏷️  构建编号: ${BUILD_NUMBER}
                    🌿 代码分支: ${BRANCH_NAME}
                    ⏰ 构建时间: ${new Date().format("yyyy-MM-dd HH:mm:ss")}
                    ================================
                    """
                    
                    // 预清理
                    cleanWs([
                        patterns: [
                            [pattern: 'dist/**', type: 'INCLUDE'],
                            [pattern: 'coverage/**', type: 'INCLUDE']
                        ]
                    ])
                }
            }
        }
        
        stage('📥 代码检出') {
            steps {
                script {
                    try {
                        echo "📥 正在获取代码..."
                        checkout scm
                        
                        // 显示代码信息
                        def commitId = sh(
                            script: 'git rev-parse HEAD',
                            returnStdout: true
                        ).trim()
                        def commitMsg = sh(
                            script: 'git log -1 --pretty=%B',
                            returnStdout: true
                        ).trim()
                        
                        echo "Git提交ID: ${commitId.take(8)}"
                        echo "提交信息: ${commitMsg}"
                        
                    } catch (Exception e) {
                        echo "❌ 代码检出失败: ${e.getMessage()}"
                        error("构建终止")
                    }
                }
            }
        }
        
        stage('📦 依赖安装') {
            steps {
                script {
                    echo "📦 安装项目依赖..."
                    
                    // 检查package.json是否存在
                    if (!fileExists('package.json')) {
                        error("❌ 未找到package.json文件")
                    }
                    
                    // 使用缓存安装依赖
                    sh '''
                        echo "Node.js版本信息:"
                        node --version
                        npm --version
                        
                        echo "清理npm缓存..."
                        npm cache clean --force
                        
                        echo "安装依赖..."
                        npm ci --prefer-offline
                    '''
                    
                    echo "✅ 依赖安装完成"
                }
            }
        }
        
        stage('🧪 代码测试') {
            when {
                not { params.SKIP_TESTS }
            }
            steps {
                script {
                    echo "🧪 执行代码测试..."
                    
                    try {
                        // 执行lint检查
                        sh 'npm run lint'
                        echo "✅ 代码规范检查通过"
                        
                        // 执行单元测试
                        sh 'npm run test -- --coverage --watchAll=false'
                        echo "✅ 单元测试通过"
                        
                    } catch (Exception e) {
                        echo "❌ 测试失败: ${e.getMessage()}"
                        currentBuild.result = 'UNSTABLE'
                        // 可以选择继续构建或终止
                    } finally {
                        // 发布测试报告（无论测试是否成功）
                        if (fileExists('coverage/lcov-report/index.html')) {
                            publishHTML([
                                allowMissing: false,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'coverage/lcov-report',
                                reportFiles: 'index.html',
                                reportName: '📊 测试覆盖率报告'
                            ])
                        }
                    }
                }
            }
        }
        
        stage('🏗️ 项目构建') {
            steps {
                script {
                    def buildCmd = "npm run build"
                    
                    // 根据环境选择构建命令
                    switch(params.DEPLOY_ENV) {
                        case 'production':
                            buildCmd = "npm run build:prod"
                            echo "🔥 构建生产环境版本"
                            break
                        case 'testing':
                            buildCmd = "npm run build:test"
                            echo "🧪 构建测试环境版本"
                            break
                        default:
                            buildCmd = "npm run build:dev"
                            echo "🛠️ 构建开发环境版本"
                    }
                    
                    // 执行构建
                    sh buildCmd
                    
                    // 检查构建产物
                    if (fileExists('dist')) {
                        sh 'ls -la dist/'
                        echo "✅ 项目构建完成"
                    } else {
                        error("❌ 构建失败，未找到dist目录")
                    }
                }
            }
        }
        
        stage('📊 构建分析') {
            steps {
                script {
                    echo "📊 分析构建产物..."
                    
                    // 分析打包大小
                    sh '''
                        echo "构建产物大小分析:"
                        du -sh dist/
                        echo "详细文件列表:"
                        find dist/ -type f -exec ls -lh {} \\; | sort -k5 -hr | head -10
                    '''
                    
                    // 生成构建信息
                    sh """
                        cat > dist/build-info.json << EOF
{
  "buildNumber": "${BUILD_NUMBER}",
  "buildTime": "${new Date().format('yyyy-MM-dd HH:mm:ss')}",
  "environment": "${params.DEPLOY_ENV}",
  "branch": "${BRANCH_NAME}",
  "commit": "\$(git rev-parse HEAD)",
  "version": "1.0.${BUILD_NUMBER}"
}
EOF
                    """
                }
            }
        }
        
        stage('📦 产物存档') {
            steps {
                script {
                    echo "📦 存档构建产物..."
                    
                    // 存档构建产物
                    archiveArtifacts([
                        artifacts: '''
                            dist/**/*,
                            package.json,
                            package-lock.json
                        ''',
                        fingerprint: true,
                        onlyIfSuccessful: true,
                        allowEmptyArchive: false
                    ])
                    
                    echo "✅ 构建产物存档完成"
                }
            }
        }
        
        stage('🚀 部署通知') {
            steps {
                script {
                    def deployUrl = ""
                    switch(params.DEPLOY_ENV) {
                        case 'production':
                            deployUrl = "https://prod.example.com"
                            break
                        case 'testing':
                            deployUrl = "https://test.example.com"
                            break
                        default:
                            deployUrl = "https://dev.example.com"
                    }
                    
                    echo """
                    ================================
                    🎉 构建完成通知
                    ================================
                    📦 项目名称: ${PROJECT_NAME}
                    🏷️  构建版本: 1.0.${BUILD_NUMBER}
                    🌍 部署环境: ${params.DEPLOY_ENV}
                    🔗 访问地址: ${deployUrl}
                    ⏰ 完成时间: ${new Date().format("yyyy-MM-dd HH:mm:ss")}
                    ================================
                    """
                }
            }
        }
    }
    
    post {
        success {
            echo "🎉 构建成功完成！"
            // 这里可以添加成功通知，如发送邮件、钉钉消息等
        }
        failure {
            echo "❌ 构建失败，保留工作空间用于调试"
            echo "调试路径: ${WORKSPACE}"
        }
        always {
            script {
                // 根据构建结果决定清理策略
                if (currentBuild.result == 'SUCCESS') {
                    echo "✅ 构建成功，执行清理"
                    cleanWs([
                        patterns: [
                            [pattern: 'node_modules/**', type: 'INCLUDE'],
                            [pattern: '.npm/**', type: 'EXCLUDE']
                        ]
                    ])
                } else {
                    echo "⚠️ 构建异常，保留文件用于调试"
                }
                
                // 显示工作空间状态
                sh 'echo "最终工作空间状态:" && ls -la || echo "工作空间已清理"'
            }
        }
    }
}
```

### 10.2 微服务项目构建案例


**🏗️ Java微服务项目Pipeline**：
```groovy
pipeline {
    agent any
    
    environment {
        MAVEN_OPTS = '-Xmx1024m'
        JAVA_HOME = '/usr/lib/jvm/java-11-openjdk'
    }
    
    stages {
        stage('🏗️ 微服务构建') {
            parallel {
                stage('用户服务') {
                    steps {
                        dir('user-service') {
                            echo "🚀 构建用户服务..."
                            sh 'mvn clean package -DskipTests'
                            
                            script {
                                if (fileExists('target/*.jar')) {
                                    archiveArtifacts artifacts: 'target/*.jar'
                                    echo "✅ 用户服务构建完成"
                                }
                            }
                        }
                    }
                }
                
                stage('订单服务') {
                    steps {
                        dir('order-service') {
                            echo "🚀 构建订单服务..."
                            sh 'mvn clean package -DskipTests'
                            
                            script {
                                if (fileExists('target/*.jar')) {
                                    archiveArtifacts artifacts: 'target/*.jar'
                                    echo "✅ 订单服务构建完成"
                                }
                            }
                        }
                    }
                }
                
                stage('网关服务') {
                    steps {
                        dir('gateway-service') {
                            echo "🚀 构建网关服务..."
                            sh 'mvn clean package -DskipTests'
                            
                            script {
                                if (fileExists('target/*.jar')) {
                                    archiveArtifacts artifacts: 'target/*.jar'
                                    echo "✅ 网关服务构建完成"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        stage('📊 集成测试报告') {
            steps {
                script {
                    echo "📊 收集各服务测试报告..."
                    
                    // 合并所有服务的测试报告
                    def services = ['user-service', 'order-service', 'gateway-service']
                    
                    services.each { service ->
                        dir(service) {
                            if (fileExists('target/site/jacoco/index.html')) {
                                publishHTML([
                                    allowMissing: true,
                                    alwaysLinkToLastBuild: true,
                                    keepAll: true,
                                    reportDir: 'target/site/jacoco',
                                    reportFiles: 'index.html',
                                    reportName: "📊 ${service} 测试覆盖率"
                                ])
                            }
                        }
                    }
                }
            }
        }
    }
}
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 Pipeline指令本质：给Jenkins发送的操作命令清单
🔸 工作空间概念：每个Job的临时工作目录
🔸 指令分类：代码、执行、输出、文件、发布、清理六大类
🔸 组合使用：多个指令配合完成复杂的CI/CD流程
🔸 错误处理：try-catch机制保证流水线稳定性
```

### 11.2 关键理解要点


**🔹 指令执行顺序的重要性**
```
正确顺序：
1. 环境准备(cleanWs) → 2. 代码检出(checkout) 
3. 命令执行(sh/bat) → 4. 结果发布(publishHTML/archiveArtifacts)
5. 环境清理(cleanWs)

错误示例：
先执行构建命令 → 再检出代码 ❌
构建失败后仍然存档产物 ❌
```

**🔹 工作目录的概念**
```
理解要点：
• dir指令改变当前工作目录
• 每个dir块内的命令在指定目录执行
• dir块结束后自动返回上级目录
• 嵌套dir支持多层目录操作
```

**🔹 错误处理策略**
```
防御性编程：
• 检查文件是否存在：fileExists()
• 捕获异常：try-catch
• 设置构建状态：currentBuild.result
• 条件执行：when指令
```

### 11.3 实际应用价值


**🎯 项目类型适配**：
- **前端项目**：checkout → npm install → npm test → npm build → archiveArtifacts
- **后端项目**：checkout → mvn compile → mvn test → mvn package → archiveArtifacts  
- **微服务项目**：并行构建多个服务，统一发布报告
- **移动应用**：checkout → gradle build → 签名打包 → 发布到应用商店

**🔧 运维最佳实践**：
- **构建前清理**：确保环境干净
- **构建后存档**：保留重要产物
- **失败时保留**：便于问题调试
- **成功时清理**：节省磁盘空间

**📊 监控和通知**：
- **进度汇报**：echo显示关键节点
- **状态检查**：script块实现复杂逻辑
- **报告发布**：publishHTML展示结果
- **通知集成**：结合钉钉、邮件等

### 11.4 学习建议


**📚 学习路径**：
1. **基础指令**：先掌握checkout、sh、echo三个核心指令
2. **文件操作**：学会dir、archiveArtifacts管理文件
3. **高级特性**：掌握script块编写复杂逻辑
4. **实战练习**：从简单项目开始，逐步增加复杂度

**💡 记忆技巧**：
```
Pipeline指令记忆口诀：
"checkout取代码，sh来执行命令
echo显示信息，dir切换目录  
script写逻辑，publishHTML发报告
archiveArtifacts存产物，cleanWs来清理"
```

**⚠️ 常见误区**：
- ❌ 过度使用代码块：简单逻辑不需要复杂实现
- ❌ 忽略错误处理：没有try-catch导致流水线中断
- ❌ 不合理的清理策略：误删重要文件或占用过多空间
- ❌ 硬编码配置：应该使用参数和环境变量

**核心记住**：
- Pipeline指令是CI/CD的基础工具
- 正确的指令组合决定了流水线的可靠性
- 通过实际项目练习才能真正掌握
- 错误处理和清理策略同样重要