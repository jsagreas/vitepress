---
title: 24、凭据管理
---
## 📚 目录

1. [凭据管理基本概念](#1-凭据管理基本概念)
2. [凭据类型详解](#2-凭据类型详解)
3. [SSH密钥管理实战](#3-SSH密钥管理实战)
4. [用户名密码存储策略](#4-用户名密码存储策略)
5. [API Token管理](#5-API-Token管理)
6. [证书文件管理](#6-证书文件管理)
7. [凭据作用域与安全策略](#7-凭据作用域与安全策略)
8. [凭据轮换与最佳实践](#8-凭据轮换与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 凭据管理基本概念


### 1.1 什么是Jenkins凭据管理


**简单理解**：Jenkins凭据管理就像一个**超级保险箱**，专门存放各种"钥匙"。

```
现实生活中的钥匙：
🏠 家门钥匙 → 开家门
🚗 车钥匙   → 开汽车
🏢 办公室钥匙 → 进办公室

Jenkins中的"钥匙"（凭据）：
🔑 SSH密钥    → 连接服务器
🔑 用户名密码  → 登录系统
🔑 API Token  → 调用接口
🔑 证书文件   → 安全认证
```

### 1.2 为什么需要凭据管理


**核心问题**：在CI/CD流程中，Jenkins需要访问各种系统：

```
Jenkins工作流程中的认证需求：
                                            
代码仓库 ←--[Git凭据]--→ Jenkins ←--[服务器SSH]--→ 部署服务器
   ↓                        ↓                    ↓
需要用户名密码           需要存储凭据         需要SSH密钥
或SSH密钥              安全访问各系统        进行部署操作
```

**传统做法的问题**：
- ❌ 把密码写在脚本里 → **极不安全**
- ❌ 每个人都知道密码 → **权限混乱**  
- ❌ 密码泄露难追踪 → **安全隐患**

**Jenkins凭据管理的优势**：
- ✅ **集中存储** → 统一管理所有认证信息
- ✅ **加密保护** → 密码加密存储，防止泄露
- ✅ **权限控制** → 不同人员看到不同凭据
- ✅ **审计追踪** → 记录谁使用了什么凭据

### 1.3 凭据管理的核心原理


**安全原理图示**：
```
┌─────────────────────────────────────────┐
│           Jenkins凭据存储层              │
├─────────────────────────────────────────┤
│  🔒 加密存储区                          │
│  ├── SSH密钥（AES加密）                 │
│  ├── 密码（不可逆加密）                 │  
│  ├── Token（散列存储）                  │
│  └── 证书（安全容器）                   │
├─────────────────────────────────────────┤
│  🛡️ 权限控制层                         │
│  ├── 全局凭据（管理员可见）              │
│  ├── 项目凭据（项目组可见）              │
│  └── 用户凭据（个人可见）                │
├─────────────────────────────────────────┤
│  📊 审计日志层                          │
│  ├── 使用记录                           │
│  ├── 访问时间                           │
│  └── 操作用户                           │
└─────────────────────────────────────────┘
```

---

## 2. 🗂️ 凭据类型详解


### 2.1 凭据类型总览


Jenkins支持多种凭据类型，每种都有特定用途：

| **凭据类型** | **用途说明** | **应用场景** | **安全级别** |
|-------------|-------------|-------------|-------------|
| **用户名+密码** | `最基础的认证方式` | `数据库连接、Web登录` | 🟡 中等 |
| **SSH密钥** | `无密码安全连接` | `Git克隆、服务器部署` | 🟢 高 |
| **Secret Text** | `单个秘密文本` | `API密钥、Token` | 🟢 高 |
| **Secret File** | `秘密文件` | `证书文件、配置文件` | 🟢 高 |
| **Certificate** | `数字证书` | `HTTPS连接、代码签名` | 🔵 极高 |

### 2.2 选择凭据类型的决策树


```
需要认证吗？
      ↓ 是
   什么类型的认证？
      ↓
  ┌─────┴─────┐
  ↓           ↓
简单登录    高安全连接
  ↓           ↓
用户名密码   SSH密钥/证书
  ↓           ↓
Web系统     Git/服务器
数据库连接   代码部署
```

### 2.3 凭据命名规范


**好的命名实践**：
```
推荐命名格式：
🔸 [环境]-[系统]-[用途]

示例：
✅ prod-mysql-readonly     → 生产环境MySQL只读用户
✅ dev-git-deploy-key      → 开发环境Git部署密钥  
✅ staging-api-token       → 测试环境API令牌
✅ prod-ssl-certificate    → 生产环境SSL证书
```

**避免的命名**：
```
❌ password123             → 含义不明
❌ key1                    → 过于简单
❌ 张三的密码              → 不专业
❌ temp-test               → 临时性质不明确
```

---

## 3. 🔑 SSH密钥管理实战


### 3.1 SSH密钥基础知识


**SSH密钥原理**：想象SSH密钥就像一把**特殊的钥匙和锁**的组合：

```
SSH密钥认证过程：
                                                
客户端（Jenkins）              服务器（Git/部署服务器）
      ↓                              ↓
  🔑 私钥                        🔒 公钥
（保密，像钥匙）               （公开，像锁眼）
      ↓                              ↓
   用私钥签名      ----消息---->    用公钥验证
      ↓                              ↓
   "我是合法用户"                 "验证通过，允许访问"
```

**SSH密钥的优势**：
- ✅ **无需密码** → 自动化友好
- ✅ **高度安全** → 私钥不在网络传输
- ✅ **可追踪性** → 每个密钥都有唯一标识
- ✅ **易于管理** → 可以随时撤销权限

### 3.2 创建SSH凭据步骤


**操作路径**：`Jenkins管理` → `管理凭据` → `系统` → `全局凭据` → `添加凭据`

**配置详解**：
```
凭据配置表单：
┌─────────────────────────────────────┐
│ 类型：SSH Username with private key │
├─────────────────────────────────────┤
│ 范围：[全局 ▼]                     │
│ ID：dev-git-deploy-key              │
│ 描述：开发环境Git部署密钥           │
│ 用户名：git                         │
│ 私钥：[直接输入/文件上传/Jenkins管理] │
│ 密码短语：[如果私钥有密码保护]       │
└─────────────────────────────────────┘
```

**私钥输入方式选择**：

| **方式** | **适用场景** | **安全性** | **操作难度** |
|---------|-------------|-----------|-------------|
| **直接输入** | `开发测试环境` | 🟡 中等 | 🟢 简单 |
| **文件上传** | `有现成密钥文件` | 🟢 较高 | 🟡 中等 |
| **Jenkins生成** | `新建专用密钥` | 🔵 高 | 🟢 简单 |

### 3.3 SSH密钥最佳实践


**密钥生成建议**：
```bash
# 生成高强度SSH密钥（推荐）
ssh-keygen -t ed25519 -C "jenkins-deploy@company.com"

# 传统RSA密钥（兼容性好）
ssh-keygen -t rsa -b 4096 -C "jenkins-deploy@company.com"
```

**密钥管理策略**：
```
环境隔离策略：
📂 开发环境
  └── 🔑 dev-git-key        → 只能访问开发仓库
📂 测试环境  
  └── 🔑 staging-git-key    → 只能访问测试仓库
📂 生产环境
  └── 🔑 prod-git-key       → 只能访问生产仓库

权限最小化原则：
🔸 部署密钥 → 只读权限，不能推送代码
🔸 CI密钥   → 克隆权限，执行部署脚本
🔸 备份密钥 → 应急使用，严格审批
```

---

## 4. 👤 用户名密码存储策略


### 4.1 用户名密码凭据概述


**适用场景**：
- 🔸 **数据库连接** → MySQL、PostgreSQL等
- 🔸 **API认证** → 需要用户名密码的REST API
- 🔸 **应用服务** → 中间件、监控系统登录
- 🔸 **云服务认证** → 部分云平台的基础认证

### 4.2 创建用户名密码凭据


**配置参数详解**：
```
用户名密码凭据配置：
┌─────────────────────────────────────┐
│ 类型：Username with password        │
├─────────────────────────────────────┤
│ 范围：全局/系统/项目                │
│ ID：prod-mysql-app-user             │
│ 描述：生产环境MySQL应用用户          │
│ 用户名：app_user                    │
│ 密码：[强密码，自动加密存储]         │
└─────────────────────────────────────┘
```

**在Pipeline中使用**：
```groovy
pipeline {
    agent any
    stages {
        stage('数据库操作') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'prod-mysql-app-user',
                        usernameVariable: 'DB_USER',
                        passwordVariable: 'DB_PASS'
                    )
                ]) {
                    sh '''
                        # 密码会自动注入到环境变量，脚本中不显示明文
                        mysql -h ${DB_HOST} -u ${DB_USER} -p${DB_PASS} -e "SELECT VERSION();"
                    '''
                }
            }
        }
    }
}
```

### 4.3 密码安全策略


**密码复杂度要求**：
```
密码强度标准：
✅ 长度：至少12位字符
✅ 组合：大小写字母+数字+特殊符号
✅ 唯一性：每个系统使用不同密码
✅ 时效性：定期更换（建议3-6个月）

示例强密码：
🔸 MyApp2024#Prod!    → 应用专用密码
🔸 DB$ecure2024@Srv   → 数据库专用密码
🔸 API#Key2024&Auth   → API专用密码
```

**密码轮换流程**：
```
定期密码更换流程：
第1步：生成新密码
  ↓
第2步：在目标系统更新密码
  ↓  
第3步：在Jenkins更新凭据
  ↓
第4步：测试新凭据可用性
  ↓
第5步：记录更换日志
```

---

## 5. 🎫 API Token管理


### 5.1 API Token基础概念


**Token认证原理**：API Token就像一张**临时通行证**，有特定的权限和有效期。

```
Token认证流程：
                                            
应用程序              API服务器
   ↓                    ↓
发送请求+Token    →    验证Token
   ↓                    ↓
等待响应          ←    返回数据/拒绝访问

Token的特点：
🔸 无状态：服务器不存储会话信息
🔸 有期限：可以设置过期时间
🔸 可撤销：随时可以禁用Token
🔸 权限明确：可以限制访问范围
```

### 5.2 Token凭据创建与使用


**创建Secret Text凭据存储Token**：
```
Secret Text凭据配置：
┌─────────────────────────────────────┐
│ 类型：Secret text                   │
├─────────────────────────────────────┤
│ 范围：全局                          │
│ Secret：ghp_xxxxxxxxxxxxxxxxxxxx     │
│ ID：github-api-token                │
│ 描述：GitHub API访问令牌            │
└─────────────────────────────────────┘
```

**在Pipeline中使用Token**：
```groovy
pipeline {
    agent any
    stages {
        stage('调用GitHub API') {
            steps {
                withCredentials([
                    string(credentialsId: 'github-api-token', variable: 'GITHUB_TOKEN')
                ]) {
                    sh '''
                        # 使用Token调用GitHub API
                        curl -H "Authorization: token $GITHUB_TOKEN" \
                             https://api.github.com/user
                    '''
                }
            }
        }
    }
}
```

### 5.3 常见API Token类型


**主流服务的Token管理**：

| **服务商** | **Token名称** | **获取方式** | **权限设置** |
|-----------|-------------|-------------|-------------|
| **GitHub** | `Personal Access Token` | `Settings→Developer→Tokens` | 🔸 可细粒度控制权限 |
| **GitLab** | `Project Access Token` | `Project→Settings→Tokens` | 🔸 项目级别权限 |
| **Docker Hub** | `Access Token` | `Account→Security→Tokens` | 🔸 仓库推拉权限 |
| **AWS** | `Access Key` | `IAM→Users→Keys` | 🔸 服务级别权限 |

**Token安全最佳实践**：
```
Token管理规范：
🔸 最小权限：只授予必要的访问权限
🔸 定期轮换：建议每3-6个月更换
🔸 环境隔离：开发/测试/生产使用不同Token
🔸 监控使用：记录Token使用情况
🔸 及时撤销：不再使用时立即删除
```

---

## 6. 📜 证书文件管理


### 6.1 证书文件基本概念


**数字证书作用**：数字证书就像**官方身份证**，证明你的身份和权限。

```
证书认证过程：
                                                
客户端                     服务器
  ↓                         ↓
出示证书      ----HTTPS---->  验证证书
  ↓                         ↓
"我是合法客户端"            "证书有效，建立安全连接"
  ↓                         ↓
开始加密通信   <-----------   返回加密响应
```

**证书类型与用途**：
- 🔸 **SSL/TLS证书** → HTTPS网站访问
- 🔸 **客户端证书** → 双向SSL认证  
- 🔸 **代码签名证书** → 软件包签名
- 🔸 **CA根证书** → 信任链建立

### 6.2 证书凭据配置


**Secret File方式存储证书**：
```
Secret File凭据配置：
┌─────────────────────────────────────┐
│ 类型：Secret file                   │
├─────────────────────────────────────┤
│ 文件：选择证书文件（.p12/.jks/.pem） │
│ ID：prod-ssl-certificate            │
│ 描述：生产环境SSL客户端证书          │
└─────────────────────────────────────┘
```

**Certificate方式存储**：
```
Certificate凭据配置：
┌─────────────────────────────────────┐
│ 类型：Certificate                   │
├─────────────────────────────────────┤
│ 证书：[上传.p12/.jks文件]           │
│ 密码：证书文件密码                  │
│ ID：code-signing-cert               │
│ 描述：代码签名证书                  │
└─────────────────────────────────────┘
```

### 6.3 证书在Pipeline中的使用


**使用SSL证书示例**：
```groovy
pipeline {
    agent any
    stages {
        stage('使用证书访问API') {
            steps {
                withCredentials([
                    file(credentialsId: 'prod-ssl-certificate', variable: 'CERT_FILE')
                ]) {
                    sh '''
                        # 使用证书文件进行HTTPS请求
                        curl --cert $CERT_FILE \
                             --cert-type P12 \
                             --cert-pass "password" \
                             https://secure-api.company.com/status
                    '''
                }
            }
        }
    }
}
```

**证书管理最佳实践**：
```
证书生命周期管理：
📅 获取证书
  ↓
📅 安装配置
  ↓  
📅 定期检查有效期
  ↓
📅 提前30天续期
  ↓
📅 更新Jenkins凭据
  ↓
📅 测试新证书
  ↓
📅 清理旧证书
```

---

## 7. 🛡️ 凭据作用域与安全策略


### 7.1 凭据作用域详解


**作用域概念**：作用域就像**访问权限的圈子**，决定谁能看到和使用凭据。

```
Jenkins凭据作用域层级：
                                                
         全局范围（Global）
              ↓
        系统范围（System）  
              ↓
        项目范围（Project）
              ↓  
        用户范围（User）

权限从上到下逐级收窄
```

### 7.2 作用域详细说明


| **作用域** | **可见性** | **使用场景** | **权限级别** |
|-----------|-----------|-------------|-------------|
| **Global** | `所有项目和用户` | `公共资源连接` | 🔴 最高 |
| **System** | `Jenkins系统级任务` | `插件配置、全局设置` | 🟠 高 |
| **Project** | `特定项目组` | `项目专用资源` | 🟡 中等 |
| **User** | `个人专用` | `个人开发环境` | 🟢 低 |

### 7.3 权限控制策略


**基于角色的权限分配**：
```
角色权限矩阵：
                     
角色类型        凭据创建  凭据查看  凭据使用  凭据删除
───────────────────────────────────────────────
🔸 系统管理员     ✅       ✅       ✅       ✅
🔸 项目经理       ✅       ✅       ✅       ❌  
🔸 开发人员       ❌       ✅       ✅       ❌
🔸 测试人员       ❌       ❌       ✅       ❌
🔸 实习生         ❌       ❌       ❌       ❌
```

**权限配置步骤**：
```
权限设置路径：
Jenkins管理 → 管理用户 → 全局安全配置
    ↓
授权策略 → 基于项目的矩阵授权策略
    ↓
配置用户/组权限：
• Overall/Administer     → 系统管理员
• Credentials/Create     → 凭据创建权限
• Credentials/View       → 凭据查看权限
• Credentials/Use        → 凭据使用权限
```

### 7.4 安全策略配置


**凭据安全加固措施**：
```
安全配置清单：
✅ 启用CSRF保护
✅ 配置代理兼容性
✅ 设置会话超时
✅ 限制脚本执行权限
✅ 启用审计日志
✅ 定期权限审查
✅ 密码复杂度策略
✅ 登录失败锁定
```

**监控与审计**：
```groovy
// 凭据使用监控脚本示例
pipeline {
    agent any
    stages {
        stage('审计检查') {
            steps {
                script {
                    // 记录凭据使用日志
                    def timestamp = new Date().format('yyyy-MM-dd HH:mm:ss')
                    def user = env.BUILD_USER_ID ?: 'system'
                    def credId = 'prod-mysql-app-user'
                    
                    echo "审计日志: ${timestamp} - 用户 ${user} 使用了凭据 ${credId}"
                }
            }
        }
    }
}
```

---

## 8. 🔄 凭据轮换与最佳实践


### 8.1 凭据轮换策略


**为什么需要轮换**：凭据轮换就像**定期换锁**，即使有人拿到了旧钥匙也无法进入。

```
凭据轮换的驱动因素：
🔸 时间驱动    → 定期更换（3-6个月）
🔸 事件驱动    → 人员离职、安全事件
🔸 合规要求    → 企业安全政策
🔸 风险评估    → 高风险凭据优先轮换
```

### 8.2 自动化轮换方案


**轮换流程设计**：
```
自动化凭据轮换流程：
                                                
第1步：生成新凭据
   ↓
第2步：在目标系统更新
   ↓
第3步：更新Jenkins凭据
   ↓
第4步：测试新凭据可用性
   ↓
第5步：停用旧凭据
   ↓
第6步：记录轮换日志
```

**Pipeline实现凭据轮换**：
```groovy
pipeline {
    agent any
    parameters {
        choice(
            name: 'ROTATION_TYPE',
            choices: ['SSH_KEY', 'PASSWORD', 'API_TOKEN'],
            description: '选择要轮换的凭据类型'
        )
    }
    
    stages {
        stage('凭据轮换') {
            steps {
                script {
                    switch(params.ROTATION_TYPE) {
                        case 'SSH_KEY':
                            rotateSSHKey()
                            break
                        case 'PASSWORD':
                            rotatePassword()
                            break
                        case 'API_TOKEN':
                            rotateAPIToken()
                            break
                    }
                }
            }
        }
        
        stage('验证新凭据') {
            steps {
                script {
                    validateNewCredentials()
                }
            }
        }
    }
    
    post {
        success {
            // 发送轮换成功通知
            emailext(
                subject: "凭据轮换成功 - ${params.ROTATION_TYPE}",
                body: "凭据已成功轮换并验证通过",
                to: "security-team@company.com"
            )
        }
    }
}
```

### 8.3 凭据管理最佳实践


**生产环境凭据管理规范**：

```
分层管理策略：
┌─────────────────────────────────────┐
│           🔴 生产环境               │
│  • 最高安全级别                     │
│  • 严格访问控制                     │
│  • 完整审计日志                     │
├─────────────────────────────────────┤
│           🟡 测试环境               │
│  • 中等安全级别                     │
│  • 开发团队可访问                   │
│  • 基础监控日志                     │
├─────────────────────────────────────┤
│           🟢 开发环境               │
│  • 基础安全级别                     │
│  • 开发人员自主管理                 │
│  • 简化流程                         │
└─────────────────────────────────────┘
```

**凭据命名与文档规范**：
```
标准化凭据信息：
🔸 ID命名：   [环境]-[系统]-[用途]-[版本]
🔸 描述内容： 详细说明用途、权限、负责人
🔸 创建日期： 记录创建和最后更新时间  
🔸 到期日期： 设置合理的有效期
🔸 负责人：   指定凭据管理责任人
🔸 使用范围： 明确可使用的项目/团队

示例文档：
ID: prod-mysql-readonly-v2024q1
描述: 生产环境MySQL只读用户凭据，用于数据分析和报表生成
创建: 2024-01-15
到期: 2024-04-15  
负责人: 张三（数据库管理员）
权限: SELECT, SHOW VIEW
使用项目: 数据分析项目、月度报表任务
```

### 8.4 故障处理与应急预案


**凭据故障处理流程**：
```
故障类型分析：
🔸 凭据过期    → 立即轮换，更新Jenkins
🔸 权限不足    → 检查目标系统权限设置
🔸 凭据泄露    → 紧急撤销，生成新凭据
🔸 系统故障    → 启用备用凭据
```

**应急响应预案**：
```groovy
pipeline {
    agent any
    
    stages {
        stage('凭据健康检查') {
            steps {
                script {
                    // 检查关键凭据可用性
                    def criticalCreds = [
                        'prod-database-user',
                        'prod-deploy-key', 
                        'prod-api-token'
                    ]
                    
                    criticalCreds.each { credId ->
                        try {
                            // 测试凭据可用性
                            withCredentials([...]) {
                                // 执行连接测试
                            }
                            echo "✅ 凭据 ${credId} 状态正常"
                        } catch (Exception e) {
                            // 发送告警
                            error "❌ 凭据 ${credId} 验证失败: ${e.message}"
                        }
                    }
                }
            }
        }
    }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 凭据管理本质：安全存储和使用各种认证信息的机制
🔸 凭据类型选择：根据使用场景选择合适的凭据类型
🔸 权限控制：基于最小权限原则分配凭据访问权限
🔸 安全策略：加密存储、定期轮换、审计追踪
🔸 自动化集成：在CI/CD流程中安全使用凭据
```

### 9.2 关键操作要点


**🔹 凭据创建和使用**
```
创建流程：
1. 确定凭据类型和用途
2. 设置合适的作用域
3. 配置安全的ID和描述
4. 在Pipeline中正确引用

使用原则：
• 使用withCredentials包装
• 避免在日志中暴露凭据
• 及时清理临时文件
• 监控使用情况
```

**🔹 安全管理策略**
```
安全原则：
• 最小权限：只给必要的访问权限
• 定期轮换：避免凭据长期有效
• 环境隔离：不同环境使用不同凭据
• 审计监控：记录所有使用活动

应急处理：
• 建立凭据故障检测机制
• 准备备用凭据方案
• 制定快速响应流程
• 定期演练应急预案
```

### 9.3 实际应用指导


**生产环境最佳实践**：
- **凭据分类管理**：按环境、系统、用途分类
- **权限严格控制**：实施基于角色的访问控制
- **定期安全审查**：检查凭据使用情况和权限分配
- **自动化监控**：建立凭据健康检查机制
- **合规性保障**：满足企业安全政策要求

**团队协作规范**：
- **统一命名规范**：便于团队成员理解和查找
- **文档完善维护**：记录凭据用途、权限、负责人
- **知识传承机制**：新员工培训和老员工交接
- **问题响应流程**：快速处理凭据相关问题

**核心记忆要点**：
- 凭据管理是CI/CD安全的基石，必须重视
- 不同类型凭据有不同的使用场景和安全特性
- 权限控制和定期轮换是安全管理的两大支柱
- 自动化和监控能大大提升凭据管理效率
- 应急预案和故障处理能力是生产环境必备