---
title: 17、容器化部署实战
---
## 📚 目录

1. [容器化部署概述](#1-容器化部署概述)
2. [Docker镜像构建实战](#2-Docker镜像构建实战)
3. [Dockerfile编写规范与最佳实践](#3-Dockerfile编写规范与最佳实践)
4. [镜像仓库管理](#4-镜像仓库管理)
5. [容器运行与部署](#5-容器运行与部署)
6. [Docker Compose编排实战](#6-Docker-Compose编排实战)
7. [容器监控与维护](#7-容器监控与维护)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🐳 容器化部署概述


### 1.1 什么是容器化部署


**简单理解**：把你的应用程序连同它需要的所有东西（代码、依赖、配置）打包成一个"集装箱"，这个集装箱可以在任何支持Docker的环境中运行。

```
传统部署方式：
开发机器 ✓ → 测试机器 ❌ (缺少依赖)
原因：环境不一致，"在我机器上能跑"

容器化部署方式：
开发机器 ✓ → 测试机器 ✓ → 生产机器 ✓
原因：环境一致，连同环境一起打包
```

### 1.2 为什么要容器化部署


**🎯 核心价值**
- **环境一致性**：开发、测试、生产环境完全相同
- **快速部署**：几秒钟启动一个应用实例
- **资源高效**：比虚拟机更轻量，占用资源更少
- **易于扩展**：需要更多实例时，快速复制启动
- **版本管理**：像管理代码一样管理应用部署

### 1.3 Jenkins中的容器化部署流程


```
代码提交 → Jenkins检测 → 构建Docker镜像 → 推送到仓库 → 部署到环境

详细流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  代码仓库   │───▶│   Jenkins   │───▶│  Docker仓库  │
│   (Git)     │    │  构建镜像   │    │ (Registry)   │
└─────────────┘    └─────────────┘    └─────────────┘
                           │                    │
                           ▼                    ▼
                   ┌─────────────┐    ┌─────────────┐
                   │  构建日志   │    │  目标服务器  │
                   │   监控      │    │  拉取&部署   │
                   └─────────────┘    └─────────────┘
```

---

## 2. 🏗️ Docker镜像构建实战


### 2.1 镜像构建基本概念


**什么是Docker镜像？**
> 💡 **生活类比**：把Docker镜像想象成一个"应用程序模板"，就像做饭的菜谱一样。菜谱告诉你需要什么食材、怎么做，Docker镜像告诉容器需要什么环境、怎么运行。

**镜像 vs 容器的关系**
```
镜像(Image) = 类(Class)     → 静态模板，不能直接使用
容器(Container) = 对象(Object) → 运行实例，实际工作的

一个镜像可以创建多个容器：
Web应用镜像 → 容器1(8080端口) + 容器2(8081端口) + 容器3(8082端口)
```

### 2.2 Jenkins中构建镜像的Pipeline配置


**基础镜像构建Pipeline**

```groovy
pipeline {
    agent any
    
    environment {
        DOCKER_IMAGE = "myapp"
        DOCKER_TAG = "${BUILD_NUMBER}"
        REGISTRY_URL = "harbor.company.com"
    }
    
    stages {
        stage('📦 构建Docker镜像') {
            steps {
                script {
                    // 构建镜像
                    def image = docker.build("${DOCKER_IMAGE}:${DOCKER_TAG}")
                    
                    // 也可以用shell命令
                    sh """
                        docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
                        docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
                    """
                }
            }
        }
    }
}
```

### 2.3 构建过程详解


**🔍 构建步骤解析**

**步骤①**：**读取Dockerfile**
- Jenkins在项目根目录找到Dockerfile文件
- 解析其中的指令，准备构建环境

**步骤②**：**分层构建**
```
Dockerfile每一行指令 = 一个镜像层
FROM ubuntu:20.04     → 基础层
RUN apt-get update    → 更新层  
COPY . /app          → 应用层
CMD ["java", "-jar"]  → 启动层

好处：修改代码只重建应用层，其他层复用 ⚡
```

**步骤③**：**生成镜像ID**
- 构建完成后生成唯一的镜像ID
- 可以给镜像打标签(tag)方便管理

### 2.4 常见构建问题与解决


**❗ 问题1：构建速度慢**
```bash
# 原因：每次都重新下载依赖
# 解决：合理安排Dockerfile层次，把变化少的放前面

# ❌ 错误做法
COPY . /app
RUN npm install

# ✅ 正确做法  
COPY package.json /app/
RUN npm install    # 这层会被缓存
COPY . /app        # 只有代码变化时才重建这层
```

**❗ 问题2：镜像过大**
```bash
# 查看镜像大小
docker images

# 解决方案：
# 1. 使用alpine等轻量级基础镜像
# 2. 清理构建缓存
# 3. 使用多阶段构建
```

---

## 3. 📋 Dockerfile编写规范与最佳实践


### 3.1 Dockerfile基础结构


**标准Dockerfile模板**

```dockerfile
# 1. 基础镜像选择
FROM openjdk:11-jre-slim

# 2. 维护者信息
LABEL maintainer="your-email@company.com"
LABEL version="1.0"
LABEL description="Spring Boot应用"

# 3. 环境变量设置
ENV APP_HOME=/app
ENV JAVA_OPTS="-Xms512m -Xmx1024m"

# 4. 工作目录
WORKDIR $APP_HOME

# 5. 复制文件
COPY target/myapp.jar app.jar

# 6. 暴露端口
EXPOSE 8080

# 7. 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s \
    CMD curl -f http://localhost:8080/health || exit 1

# 8. 启动命令
CMD ["java", "-jar", "/app/app.jar"]
```

### 3.2 不同语言的Dockerfile实践


**🔸 Java Spring Boot应用**

```dockerfile
# 多阶段构建 - 构建阶段
FROM maven:3.8-openjdk-11 AS builder
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:download-sources
COPY src ./src
RUN mvn clean package -DskipTests

# 运行阶段
FROM openjdk:11-jre-slim
RUN groupadd -r appuser && useradd -r -g appuser appuser
WORKDIR /app
COPY --from=builder /build/target/app.jar .
RUN chown appuser:appuser app.jar
USER appuser
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
```

**🔸 Node.js应用**

```dockerfile
FROM node:16-alpine
WORKDIR /app

# 只复制package文件，利用Docker缓存
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# 复制应用代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
USER nodejs

EXPOSE 3000
CMD ["node", "server.js"]
```

**🔸 Python Django应用**

```dockerfile
FROM python:3.9-slim

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN python manage.py collectstatic --noinput

EXPOSE 8000
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "myproject.wsgi:application"]
```

### 3.3 Dockerfile最佳实践规范


**✅ 推荐做法**

| **实践项目** | **具体做法** | **原因说明** |
|-------------|-------------|-------------|
| **基础镜像选择** | `使用官方、标签明确的镜像` | `FROM node:16-alpine` |
| **层次优化** | `变化频率低的指令放前面` | `利用Docker缓存机制` |
| **用户安全** | `使用非root用户运行` | `减少安全风险` |
| **文件复制** | `先复制依赖文件，再复制代码` | `提高构建效率` |
| **清理缓存** | `及时清理包管理器缓存` | `减小镜像体积` |

**❌ 避免做法**

```dockerfile
# ❌ 不要这样做
FROM ubuntu:latest              # 标签不明确
RUN apt-get update
RUN apt-get install python3    # 分开执行，增加层数
RUN apt-get install pip3       
COPY . /app                     # 代码变化会重建所有层
RUN pip3 install -r requirements.txt

# ✅ 应该这样做  
FROM python:3.9-slim           # 标签明确
RUN apt-get update && \        # 合并指令，减少层数
    apt-get install -y python3 pip3 && \
    rm -rf /var/lib/apt/lists/*  # 清理缓存
COPY requirements.txt /app/    # 先复制依赖文件
RUN pip3 install -r /app/requirements.txt
COPY . /app                    # 最后复制代码
```

### 3.4 多阶段构建深度解析


**为什么需要多阶段构建？**

```
传统单阶段构建问题：
┌─────────────────────────────┐
│  最终镜像包含：              │
│  ├── 源代码                 │
│  ├── 编译工具 (Maven/Gradle) │  ← 运行时不需要，浪费空间
│  ├── 编译缓存               │  ← 运行时不需要，浪费空间  
│  └── 编译后的应用           │
└─────────────────────────────┘

多阶段构建解决方案：
阶段1(构建)：源码 + 编译工具 → 编译后文件
阶段2(运行)：只要编译后文件 + 运行环境
```

**多阶段构建实例**

```dockerfile
# === 构建阶段 ===
FROM maven:3.8-openjdk-11 AS build-stage
WORKDIR /build
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# === 运行阶段 ===  
FROM openjdk:11-jre-slim AS runtime-stage
WORKDIR /app
# 只复制构建阶段的jar文件，不要构建工具
COPY --from=build-stage /build/target/app.jar .
CMD ["java", "-jar", "app.jar"]

# 结果：最终镜像只有JRE + JAR文件，体积小很多
```

---

## 4. 🏪 镜像仓库管理


### 4.1 什么是镜像仓库


**概念理解**
> 💡 **类比说明**：镜像仓库就像一个"应用商店"，你可以把自己制作的应用"上架"(push)，也可以"下载"(pull)别人的应用。

```
镜像仓库的作用：
┌─────────────┐    push     ┌─────────────┐    pull     ┌─────────────┐
│   开发环境   │ ──────────▶ │  镜像仓库   │ ──────────▶ │  生产环境   │
│ 构建镜像    │             │ (Registry)  │             │ 运行容器    │
└─────────────┘             └─────────────┘             └─────────────┘
```

### 4.2 常用镜像仓库类型


**🔸 公共仓库**
- **Docker Hub**：最大的公共镜像仓库
- **阿里云镜像**：国内访问速度快
- **腾讯云镜像**：企业级服务

**🔸 私有仓库**
- **Harbor**：企业级开源仓库，功能丰富
- **Registry**：Docker官方简单仓库
- **云厂商私有仓库**：各云平台提供的服务

### 4.3 Jenkins推送镜像到仓库


**配置Docker Hub推送**

```groovy
pipeline {
    agent any
    
    environment {
        DOCKER_HUB_REPO = "username/myapp"
        DOCKER_HUB_CREDENTIALS = credentials('docker-hub-token')
    }
    
    stages {
        stage('🏗️ 构建镜像') {
            steps {
                script {
                    def image = docker.build("${DOCKER_HUB_REPO}:${BUILD_NUMBER}")
                }
            }
        }
        
        stage('📤 推送到Docker Hub') {
            steps {
                script {
                    docker.withRegistry('https://index.docker.io/v1/', 'docker-hub-credentials') {
                        def image = docker.image("${DOCKER_HUB_REPO}:${BUILD_NUMBER}")
                        image.push()
                        image.push("latest")  // 同时推送latest标签
                    }
                }
            }
        }
    }
}
```

**配置私有Harbor仓库推送**

```groovy
stage('📤 推送到Harbor') {
    steps {
        script {
            // Harbor仓库地址
            def harborUrl = "harbor.company.com"
            def project = "myproject"
            def imageName = "${harborUrl}/${project}/myapp:${BUILD_NUMBER}"
            
            // 重新标记镜像
            sh "docker tag myapp:${BUILD_NUMBER} ${imageName}"
            
            // 登录并推送
            withCredentials([usernamePassword(credentialsId: 'harbor-credentials', 
                           usernameVariable: 'HARBOR_USER', 
                           passwordVariable: 'HARBOR_PASS')]) {
                sh """
                    echo \$HARBOR_PASS | docker login ${harborUrl} -u \$HARBOR_USER --password-stdin
                    docker push ${imageName}
                """
            }
        }
    }
}
```

### 4.4 镜像版本管理策略


**📋 标签管理最佳实践**

| **标签类型** | **格式示例** | **用途说明** |
|-------------|-------------|-------------|
| **构建版本** | `v1.2.3-build-123` | `具体构建版本，可追溯` |
| **Git标签** | `v1.2.3-abc1234` | `Git提交哈希，精确定位` |
| **环境标签** | `v1.2.3-dev/test/prod` | `不同环境的版本` |
| **时间标签** | `v1.2.3-20240921` | `按日期管理版本` |
| **滚动标签** | `latest/stable` | `始终指向最新版本` |

**实际应用示例**

```bash
# 同一个镜像可以有多个标签
docker tag myapp:build-123 myapp:v1.2.3
docker tag myapp:build-123 myapp:latest
docker tag myapp:build-123 myapp:stable

# 推送时同时推送多个标签
docker push myapp:build-123
docker push myapp:v1.2.3  
docker push myapp:latest
```

---

## 5. 🚀 容器运行与部署


### 5.1 容器基础运行命令


**简单启动容器**

```bash
# 基础运行命令
docker run -d --name myapp-container -p 8080:8080 myapp:latest

# 命令解析：
# -d          → 后台运行(detached)
# --name      → 给容器起个名字，方便管理
# -p 8080:8080 → 端口映射：主机8080端口→容器8080端口
# myapp:latest → 使用的镜像名称和标签
```

**带环境变量的启动**

```bash
docker run -d \
  --name myapp-container \
  -p 8080:8080 \
  -e SPRING_PROFILES_ACTIVE=prod \
  -e DATABASE_URL=mysql://db:3306/myapp \
  -v /logs:/app/logs \
  myapp:latest

# 参数说明：
# -e  → 设置环境变量
# -v  → 挂载目录：主机目录:容器目录
```

### 5.2 Jenkins自动化部署Pipeline


**基础部署Pipeline**

```groovy
pipeline {
    agent any
    
    environment {
        IMAGE_NAME = "myapp"
        CONTAINER_NAME = "myapp-prod"
        HOST_PORT = "8080"
        CONTAINER_PORT = "8080"
    }
    
    stages {
        stage('🛑 停止旧容器') {
            steps {
                script {
                    sh """
                        # 停止并删除旧容器（如果存在）
                        docker stop ${CONTAINER_NAME} || true
                        docker rm ${CONTAINER_NAME} || true
                    """
                }
            }
        }
        
        stage('📥 拉取最新镜像') {
            steps {
                sh "docker pull ${IMAGE_NAME}:latest"
            }
        }
        
        stage('🚀 启动新容器') {
            steps {
                sh """
                    docker run -d \
                        --name ${CONTAINER_NAME} \
                        -p ${HOST_PORT}:${CONTAINER_PORT} \
                        -e SPRING_PROFILES_ACTIVE=prod \
                        --restart=unless-stopped \
                        ${IMAGE_NAME}:latest
                """
            }
        }
        
        stage('✅ 健康检查') {
            steps {
                script {
                    timeout(time: 5, unit: 'MINUTES') {
                        waitUntil {
                            script {
                                def response = sh(
                                    script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:${HOST_PORT}/health",
                                    returnStdout: true
                                ).trim()
                                return response == "200"
                            }
                        }
                    }
                    echo "✅ 应用启动成功，健康检查通过"
                }
            }
        }
    }
}
```

### 5.3 零停机部署策略


**🔸 蓝绿部署**

```
蓝绿部署原理：
┌─────────────┐              ┌─────────────┐
│   蓝环境    │              │   绿环境    │
│  (当前版本)  │              │  (新版本)   │
│   v1.0     │              │   v1.1     │
└─────────────┘              └─────────────┘
       ▲                            ▲
       │                            │
   用户流量                     测试通过后
                               切换流量到绿环境
```

**蓝绿部署Jenkins实现**

```groovy
stage('🔄 蓝绿部署') {
    steps {
        script {
            // 确定当前运行的是蓝还是绿
            def currentColor = sh(
                script: "docker ps --filter 'name=myapp-' --format '{{.Names}}' | head -1",
                returnStdout: true
            ).trim()
            
            def newColor = currentColor.contains('blue') ? 'green' : 'blue'
            def newContainerName = "myapp-${newColor}"
            def newPort = newColor == 'blue' ? '8080' : '8081'
            
            echo "当前运行: ${currentColor}, 新部署: ${newColor}"
            
            // 启动新版本容器
            sh """
                docker run -d \
                    --name ${newContainerName} \
                    -p ${newPort}:8080 \
                    ${IMAGE_NAME}:latest
            """
            
            // 等待新容器就绪
            sleep 30
            
            // 切换负载均衡器指向新容器
            sh "echo '切换到新版本容器: ${newContainerName}'"
            
            // 停止旧容器
            if (currentColor) {
                sh "docker stop ${currentColor} && docker rm ${currentColor}"
            }
        }
    }
}
```

**🔸 滚动更新**

```groovy
stage('📱 滚动更新') {
    steps {
        script {
            def instances = ['myapp-1', 'myapp-2', 'myapp-3']
            
            for (instance in instances) {
                echo "更新实例: ${instance}"
                
                // 从负载均衡器移除
                sh "echo '从负载均衡器移除 ${instance}'"
                
                // 停止旧容器
                sh "docker stop ${instance} || true"
                sh "docker rm ${instance} || true"
                
                // 启动新容器
                sh """
                    docker run -d \
                        --name ${instance} \
                        -p 808${instances.indexOf(instance)}:8080 \
                        ${IMAGE_NAME}:latest
                """
                
                // 健康检查
                timeout(time: 2, unit: 'MINUTES') {
                    waitUntil {
                        script {
                            def health = sh(
                                script: "curl -s http://localhost:808${instances.indexOf(instance)}/health",
                                returnStatus: true
                            )
                            return health == 0
                        }
                    }
                }
                
                // 加回负载均衡器
                sh "echo '将 ${instance} 加回负载均衡器'"
                
                echo "✅ ${instance} 更新完成"
            }
        }
    }
}
```

---

## 6. 📦 Docker Compose编排实战


### 6.1 什么是Docker Compose


**简单理解**
> 💡 **类比说明**：如果说Docker是"单间公寓"，那么Docker Compose就是"整栋公寓楼的管理员"。它可以同时管理多个相关的容器，让它们协同工作。

```
单容器 vs 多容器应用：

单体应用：
┌─────────────────┐
│     Web应用     │
│ (包含所有功能)   │
└─────────────────┘

微服务应用：
┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐
│  Web  │  │ API   │  │ 数据库 │  │ Redis │
│ 前端  │  │ 后端  │  │ MySQL │  │ 缓存  │
└───────┘  └───────┘  └───────┘  └───────┘
    ↑          ↑          ↑          ↑
    ↓──────────┼──────────┼──────────┘
           Docker Compose统一管理
```

### 6.2 Docker Compose文件编写


**基础compose文件结构**

```yaml
version: '3.8'

services:
  # Web应用服务
  web:
    build: .                    # 使用当前目录的Dockerfile构建
    ports:
      - "8080:8080"            # 端口映射
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DATABASE_URL=mysql://db:3306/myapp
    depends_on:
      - db                     # 依赖数据库服务
      - redis
    volumes:
      - ./logs:/app/logs       # 挂载日志目录

  # MySQL数据库服务  
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: myapp
      MYSQL_USER: appuser
      MYSQL_PASSWORD: apppassword
    volumes:
      - mysql_data:/var/lib/mysql    # 数据持久化
    ports:
      - "3306:3306"

  # Redis缓存服务
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  mysql_data:                  # 定义数据卷
  redis_data:
```

### 6.3 Jenkins中使用Docker Compose


**Compose部署Pipeline**

```groovy
pipeline {
    agent any
    
    environment {
        COMPOSE_PROJECT_NAME = "myapp"
    }
    
    stages {
        stage('📋 准备Compose环境') {
            steps {
                // 创建环境变量文件
                writeFile file: '.env', text: """
                    APP_VERSION=${BUILD_NUMBER}
                    DB_PASSWORD=\${DB_PASSWORD}
                    REDIS_PASSWORD=\${REDIS_PASSWORD}
                """
            }
        }
        
        stage('🛑 停止旧服务') {
            steps {
                sh '''
                    # 停止并删除旧的服务
                    docker-compose down --remove-orphans
                    
                    # 清理悬挂的镜像
                    docker image prune -f
                '''
            }
        }
        
        stage('🚀 启动新服务') {
            steps {
                sh '''
                    # 拉取最新镜像
                    docker-compose pull
                    
                    # 启动所有服务
                    docker-compose up -d
                    
                    # 显示服务状态
                    docker-compose ps
                '''
            }
        }
        
        stage('🏥 服务健康检查') {
            steps {
                script {
                    def services = ['web', 'db', 'redis']
                    
                    for (service in services) {
                        timeout(time: 3, unit: 'MINUTES') {
                            waitUntil {
                                script {
                                    def status = sh(
                                        script: "docker-compose ps -q ${service} | xargs docker inspect --format='{{.State.Health.Status}}' || echo 'unhealthy'",
                                        returnStdout: true
                                    ).trim()
                                    
                                    echo "${service} 状态: ${status}"
                                    return status == 'healthy' || status == 'running'
                                }
                            }
                        }
                    }
                    echo "✅ 所有服务启动成功"
                }
            }
        }
    }
    
    post {
        failure {
            // 部署失败时查看日志
            sh '''
                echo "=== 部署失败，查看服务日志 ==="
                docker-compose logs --tail=50
            '''
        }
    }
}
```

### 6.4 Compose高级特性


**🔸 环境变量管理**

```yaml
# docker-compose.yml
version: '3.8'
services:
  web:
    image: myapp:${APP_VERSION:-latest}
    environment:
      - DATABASE_URL=mysql://db:3306/${DB_NAME}
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
    env_file:
      - .env                   # 从文件读取环境变量
```

```bash
# .env文件内容
APP_VERSION=1.2.3
DB_NAME=myapp_prod
JWT_SECRET=your-secret-key
```

**🔸 网络配置**

```yaml
version: '3.8'
services:
  web:
    networks:
      - frontend
      - backend
      
  db:
    networks:
      - backend              # 数据库只在后端网络

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true           # 内部网络，增加安全性
```

**🔸 资源限制**

```yaml
services:
  web:
    deploy:
      resources:
        limits:
          cpus: '1.0'         # 限制CPU使用
          memory: 1G          # 限制内存使用
        reservations:
          cpus: '0.5'         # 预留CPU
          memory: 512M        # 预留内存
```

---

## 7. 📊 容器监控与维护


### 7.1 容器健康检查


**什么是健康检查？**
> 💡 **类比说明**：健康检查就像给应用做"体检"，定期检查应用是否还"活着"并且"工作正常"。如果发现问题，可以自动重启或告警。

**在Dockerfile中定义健康检查**

```dockerfile
# HTTP健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# 自定义脚本检查
HEALTHCHECK --interval=30s --timeout=10s \
    CMD /app/health-check.sh

# 参数说明：
# --interval=30s   → 每30秒检查一次
# --timeout=10s    → 单次检查超时时间
# --start-period=60s → 容器启动60秒后开始检查
# --retries=3      → 连续失败3次才认为不健康
```

**健康检查脚本示例**

```bash
#!/bin/bash
# health-check.sh

# 检查进程是否存在
if ! pgrep -f "java.*myapp.jar" > /dev/null; then
    echo "应用进程不存在"
    exit 1
fi

# 检查HTTP接口
if ! curl -f http://localhost:8080/health > /dev/null 2>&1; then
    echo "健康检查接口无响应"
    exit 1
fi

# 检查数据库连接
if ! curl -f http://localhost:8080/db-check > /dev/null 2>&1; then
    echo "数据库连接异常"
    exit 1
fi

echo "健康检查通过"
exit 0
```

### 7.2 容器日志管理


**查看容器日志**

```bash
# 查看实时日志
docker logs -f myapp-container

# 查看最近100行日志
docker logs --tail 100 myapp-container

# 查看特定时间段的日志
docker logs --since "2024-09-21T10:00:00" --until "2024-09-21T11:00:00" myapp-container
```

**Jenkins中的日志收集**

```groovy
stage('📝 收集应用日志') {
    steps {
        script {
            // 等待应用启动
            sleep 30
            
            // 收集应用日志
            sh '''
                echo "=== 应用启动日志 ==="
                docker logs --tail 100 myapp-container
                
                echo "=== 系统资源使用 ==="
                docker stats --no-stream myapp-container
            '''
            
            // 保存日志到Jenkins
            sh '''
                docker logs myapp-container > application.log 2>&1
            '''
            
            // 归档日志文件
            archiveArtifacts artifacts: 'application.log', allowEmptyArchive: true
        }
    }
}
```

**配置日志驱动**

```yaml
# docker-compose.yml
services:
  web:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"        # 单个日志文件最大10MB
        max-file: "3"          # 最多保留3个日志文件
```

### 7.3 容器资源监控


**基础资源监控命令**

```bash
# 查看容器资源使用情况
docker stats

# 查看特定容器资源使用
docker stats myapp-container

# 输出结果说明：
# CPU %     → CPU使用百分比
# MEM USAGE → 内存使用量
# MEM %     → 内存使用百分比  
# NET I/O   → 网络读写流量
# BLOCK I/O → 磁盘读写流量
```

**Jenkins中的资源监控**

```groovy
stage('📊 资源监控') {
    steps {
        script {
            // 获取容器资源使用情况
            def stats = sh(
                script: "docker stats --no-stream --format 'table {{.Container}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.MemPerc}}' myapp-container",
                returnStdout: true
            ).trim()
            
            echo "容器资源使用情况："
            echo stats
            
            // 检查资源使用是否超标
            def memPercent = sh(
                script: "docker stats --no-stream --format '{{.MemPerc}}' myapp-container | sed 's/%//'",
                returnStdout: true
            ).trim() as Float
            
            if (memPercent > 80) {
                currentBuild.result = 'UNSTABLE'
                echo "⚠️ 警告：内存使用率过高 (${memPercent}%)"
            }
        }
    }
}
```

### 7.4 容器故障处理


**常见故障诊断步骤**

```bash
# 1. 检查容器状态
docker ps -a

# 2. 查看容器详细信息
docker inspect myapp-container

# 3. 查看容器日志
docker logs myapp-container

# 4. 进入容器排查
docker exec -it myapp-container /bin/bash

# 5. 检查资源使用
docker stats myapp-container
```

**自动故障恢复Pipeline**

```groovy
pipeline {
    agent any
    
    triggers {
        cron('*/5 * * * *')  // 每5分钟检查一次
    }
    
    stages {
        stage('🔍 健康检查') {
            steps {
                script {
                    def containers = ['myapp-web', 'myapp-api', 'myapp-worker']
                    
                    for (container in containers) {
                        def isHealthy = sh(
                            script: "docker inspect --format='{{.State.Health.Status}}' ${container} 2>/dev/null || echo 'not-found'",
                            returnStdout: true
                        ).trim()
                        
                        echo "${container} 健康状态: ${isHealthy}"
                        
                        if (isHealthy == 'unhealthy' || isHealthy == 'not-found') {
                            echo "⚠️ 发现异常容器: ${container}"
                            
                            // 尝试重启容器
                            sh """
                                echo "重启容器: ${container}"
                                docker restart ${container} || docker run -d --name ${container} myapp:latest
                            """
                            
                            // 发送告警通知
                            emailext (
                                subject: "容器异常告警: ${container}",
                                body: "容器 ${container} 状态异常，已自动重启",
                                to: "ops@company.com"
                            )
                        }
                    }
                }
            }
        }
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 容器化核心价值：环境一致性、快速部署、资源高效
🔸 镜像vs容器关系：镜像是模板，容器是运行实例  
🔸 Dockerfile最佳实践：分层构建、多阶段构建、安全用户
🔸 镜像仓库管理：版本标签策略、推送拉取流程
🔸 Docker Compose：多容器应用编排，统一管理
🔸 监控与维护：健康检查、日志管理、资源监控
```

### 8.2 关键理解要点


**🔹 为什么容器化这么重要**
```
解决的核心问题：
- "在我机器上能跑" → 环境一致性保证
- 部署复杂慢 → 快速标准化部署  
- 资源浪费 → 轻量级高效资源利用
- 扩展困难 → 弹性伸缩能力
```

**🔹 Dockerfile编写的关键原则**
```
效率优化：
- 合理安排层次：变化少的在前，变化多的在后
- 利用缓存机制：只重建有变化的层
- 多阶段构建：构建环境和运行环境分离

安全考虑：
- 使用非root用户运行应用
- 及时清理敏感信息和缓存
- 选择安全的基础镜像
```

**🔹 部署策略的选择**
```
蓝绿部署：
- 适用：对稳定性要求极高的场景
- 优点：快速回滚，零停机
- 缺点：需要双倍资源

滚动更新：
- 适用：资源有限的场景
- 优点：资源利用率高
- 缺点：更新时间较长
```

### 8.3 实际应用指导


**🎯 新手上手路径**
①️⃣ **从单容器开始**：先学会构建和运行单个容器
②️⃣ **掌握Dockerfile**：写出高效、安全的镜像构建文件
③️⃣ **学习仓库管理**：理解镜像的版本管理和分发
④️⃣ **进阶多容器**：使用Docker Compose管理复杂应用
⑤️⃣ **集成CI/CD**：将容器化融入Jenkins流水线

**🛠️ 实践建议**
- **从简单应用开始**：先容器化静态网站或简单API
- **逐步增加复杂度**：逐渐加入数据库、缓存等组件
- **重视安全实践**：从一开始就养成安全的习惯
- **做好监控运维**：部署后的监控和维护同样重要

**⚠️ 常见陷阱**
- **镜像体积过大**：注意清理构建缓存和无用文件
- **数据丢失风险**：重要数据一定要持久化到数据卷
- **网络配置错误**：理解容器间网络通信机制
- **资源限制不当**：合理设置CPU和内存限制

### 8.4 进阶发展方向


**🚀 技术进阶路线**
```
容器基础 → K8s编排 → 服务网格 → 云原生架构

具体学习路径：
1. Docker容器技术深入
2. Kubernetes集群管理
3. Helm包管理工具
4. Istio服务网格
5. 云原生应用开发
```

**📊 监控运维进阶**
```
基础监控 → 全链路监控 → 智能运维

技术栈发展：
1. Docker基础监控
2. Prometheus + Grafana
3. ELK/EFK日志分析
4. Jaeger链路追踪
5. AI运维和自动化
```

**核心记忆口诀**：
> 🐳 容器化部署好处多，环境一致部署快  
> 📋 Dockerfile分层写，缓存利用效率高  
> 🏪 镜像仓库版本管，推送拉取要规范  
> 📦 Compose编排多服务，统一管理真方便  
> 📊 监控日志不能少，故障处理要及时