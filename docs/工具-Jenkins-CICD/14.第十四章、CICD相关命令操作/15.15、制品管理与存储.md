---
title: 15、制品管理与存储
---
## 📚 目录

1. [制品管理基础概念](#1-制品管理基础概念)
2. [构建产物归档](#2-构建产物归档)
3. [Nexus仓库集成](#3-nexus仓库集成)
4. [Docker镜像构建与推送](#4-docker镜像构建与推送)
5. [版本号管理策略](#5-版本号管理策略)
6. [制品下载与配置](#6-制品下载与配置)
7. [存储空间管理](#7-存储空间管理)
8. [制品清理策略](#8-制品清理策略)
9. [制品安全扫描](#9-制品安全扫描)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📦 制品管理基础概念


### 1.1 什么是制品(Artifact)


**🔸 通俗理解**
> 制品就像工厂生产的成品，是我们代码经过编译、构建后产生的**最终可用产物**

```
日常生活类比：
面包师傅 → 揉面 → 发酵 → 烘烤 → 🍞面包(制品)
程序员   → 写代码 → 编译 → 构建 → 📦软件包(制品)
```

**🔸 制品的本质**
- **输入**：源代码 + 依赖库 + 配置文件
- **过程**：编译 + 打包 + 测试
- **输出**：可直接部署使用的文件

### 1.2 常见制品类型


| 制品类型 | **说明** | **实际例子** | **使用场景** |
|---------|---------|-------------|-------------|
| 🗂️ **JAR包** | `Java应用打包文件` | `myapp-1.0.jar` | `Java Web应用` |
| 🐳 **Docker镜像** | `容器化应用包` | `myapp:v1.0` | `微服务部署` |
| 📱 **APK文件** | `Android安装包` | `myapp-v1.0.apk` | `移动应用发布` |
| 🌐 **静态资源** | `前端构建产物` | `dist.zip` | `网站部署` |
| 📋 **配置文件** | `部署配置` | `config.yaml` | `环境配置` |

### 1.3 为什么需要制品管理


**🎯 核心价值**

```
问题场景：
开发：我这里运行正常啊！
测试：怎么我这边有bug？
运维：生产环境怎么又出错了？

根本原因：每次构建的产物不一致！
```

**制品管理解决的痛点**：
- ✅ **版本追溯**：能准确知道某个版本包含哪些代码
- ✅ **环境一致性**：测试环境和生产环境使用相同制品
- ✅ **快速回滚**：问题版本可以立即回退到上个稳定版本
- ✅ **团队协作**：所有人使用相同的构建产物

---

## 2. 📁 构建产物归档


### 2.1 什么是产物归档


**🔸 简单理解**
> 就像把重要文件放进保险柜，把构建好的制品安全存储起来

```
构建流程：
源代码 → 编译 → 测试 → 📦打包 → 🗄️归档存储
                              ↑
                        这一步很关键！
```

### 2.2 Jenkins中的归档配置


**🔧 基础归档设置**

在Jenkins项目配置中：

**Post-build Actions(构建后操作)** → **Archive the artifacts(归档制品)**

```
归档路径配置示例：
target/*.jar          # Java项目的jar包
dist/**/*             # 前端项目的发布目录
build/libs/*.war      # Gradle项目的war包
*.apk                 # Android项目的安装包
```

**📊 归档配置最佳实践**

```
推荐配置：
✅ 只归档必要文件：避免存储临时文件
✅ 使用通配符：target/*.jar 而不是具体文件名
✅ 分类存储：按文件类型或环境分目录
✅ 设置保留策略：避免存储空间爆满

避免归档：
❌ 源代码文件(.java, .js)
❌ 临时编译文件(.class, .o)
❌ 日志文件(.log)
❌ 缓存目录(node_modules, .gradle)
```

### 2.3 Pipeline中的归档


```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                // 构建应用
                sh 'mvn clean package'
            }
        }
    }
    post {
        success {
            // 构建成功后归档制品
            archiveArtifacts artifacts: 'target/*.jar', 
                           fingerprint: true,
                           allowEmptyArchive: false
        }
    }
}
```

**参数说明**：
- `artifacts`: 要归档的文件路径
- `fingerprint`: 生成文件指纹(用于追踪)
- `allowEmptyArchive`: 是否允许空归档

---

## 3. 🏛️ Nexus仓库集成


### 3.1 什么是Nexus仓库


**🔸 生活化理解**
> Nexus就像一个**超级仓库**，专门存放各种软件包

```
现实世界类比：
京东仓库 → 存放各种商品 → 用户下单 → 快递配送
Nexus仓库 → 存放软件包 → 项目需要 → 自动下载
```

**🏗️ Nexus仓库架构**

```
                    Nexus Repository Manager
                    ┌─────────────────────────┐
公网Maven中央仓库 → │  Proxy Repository      │ ← 代理仓库
                    │  (缓存外部依赖)        │
                    ├─────────────────────────┤
Jenkins构建产物 →   │  Hosted Repository     │ ← 本地仓库
                    │  (存储内部制品)        │
                    ├─────────────────────────┤
开发者/部署工具 ←   │  Group Repository      │ ← 聚合仓库
                    │  (统一入口)            │
                    └─────────────────────────┘
```

### 3.2 Nexus集成配置


**🔧 第一步：安装Nexus插件**

Jenkins管理 → 插件管理 → 搜索"Nexus Artifact Uploader"

**🔧 第二步：配置Nexus服务器**

Jenkins管理 → 全局工具配置 → Nexus Repository Manager Servers

```
配置项说明：
- Server ID: nexus-server (自定义标识)
- Server URL: http://nexus.company.com:8081
- Credentials: nexus账号密码
```

**🔧 第三步：Pipeline中上传制品**

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'mvn clean package'
            }
        }
        stage('Upload to Nexus') {
            steps {
                nexusArtifactUploader(
                    nexusVersion: 'nexus3',
                    protocol: 'http',
                    nexusUrl: 'nexus.company.com:8081',
                    groupId: 'com.company',
                    version: '${BUILD_NUMBER}',
                    repository: 'maven-releases',
                    credentialsId: 'nexus-credentials',
                    artifacts: [
                        [artifactId: 'myapp',
                         classifier: '',
                         file: 'target/myapp.jar',
                         type: 'jar']
                    ]
                )
            }
        }
    }
}
```

### 3.3 版本管理策略


**📋 版本号规范**

| 版本类型 | **格式示例** | **说明** | **Nexus仓库** |
|---------|-------------|---------|--------------|
| 🚀 **正式版本** | `1.0.0, 2.1.3` | `生产环境使用` | `maven-releases` |
| 🧪 **快照版本** | `1.0.0-SNAPSHOT` | `开发测试使用` | `maven-snapshots` |
| 🏷️ **候选版本** | `1.0.0-RC1` | `预发布版本` | `maven-staging` |

---

## 4. 🐳 Docker镜像构建与推送


### 4.1 Docker镜像是什么


**🔸 通俗解释**
> Docker镜像就像**标准化的集装箱**，把应用和运行环境打包在一起

```
传统部署 vs Docker部署：

传统方式：
应用A → 需要Java8 + Tomcat8 + MySQL5.7
应用B → 需要Java11 + Nginx + Redis
服务器 → 🤯 环境冲突，配置复杂

Docker方式：
应用A → 🐳 镜像A (包含所有依赖)
应用B → 🐳 镜像B (包含所有依赖)  
服务器 → 😊 直接运行，环境隔离
```

### 4.2 Docker镜像构建


**📋 Dockerfile示例**

```dockerfile
# 基础镜像(就像毛坯房)
FROM openjdk:8-jre-alpine

# 设置工作目录(选择房间)
WORKDIR /app

# 复制应用文件(搬家具)
COPY target/myapp.jar app.jar

# 暴露端口(开门)
EXPOSE 8080

# 启动命令(入住)
CMD ["java", "-jar", "app.jar"]
```

**🔧 Jenkins Pipeline构建镜像**

```groovy
pipeline {
    agent any
    stages {
        stage('Build App') {
            steps {
                sh 'mvn clean package'
            }
        }
        stage('Build Docker Image') {
            steps {
                script {
                    // 构建镜像
                    def image = docker.build("myapp:${BUILD_NUMBER}")
                    
                    // 推送到仓库
                    docker.withRegistry('https://registry.company.com', 'docker-credentials') {
                        image.push()
                        image.push("latest")  // 同时打上latest标签
                    }
                }
            }
        }
    }
}
```

### 4.3 镜像版本管理


**🏷️ 标签策略**

```
推荐的标签方案：
myapp:1.0.0          # 语义化版本号
myapp:v1.0.0-20230921 # 版本号+日期
myapp:latest         # 最新稳定版
myapp:dev            # 开发版本
myapp:staging        # 测试版本
```

**⚠️ 注意事项**

> 🔴 **重要提醒**：不要在生产环境使用`latest`标签！
> 
> **原因**：`latest`标签会变化，无法确保部署的一致性

---

## 5. 🏷️ 版本号管理策略


### 5.1 语义化版本控制


**🔸 什么是语义化版本**

```
版本格式：主版本.次版本.修订版本
示例：1.2.3

主版本(1)：重大变更，可能不兼容老版本
次版本(2)：新功能，向后兼容
修订版本(3)：bug修复，向后兼容
```

**🎯 实际应用场景**

```
场景举例：
电商系统 v1.0.0 → 基础购物功能
电商系统 v1.1.0 → 新增积分功能(兼容老版本)
电商系统 v1.1.1 → 修复支付bug(兼容)
电商系统 v2.0.0 → 重构架构(可能不兼容v1.x)
```

### 5.2 Jenkins中的版本号生成


**🔧 方法一：使用构建号**

```groovy
pipeline {
    agent any
    environment {
        VERSION = "1.0.${BUILD_NUMBER}"
    }
    stages {
        stage('Build') {
            steps {
                echo "构建版本: ${VERSION}"
                sh "mvn versions:set -DnewVersion=${VERSION}"
                sh "mvn clean package"
            }
        }
    }
}
```

**🔧 方法二：Git标签版本**

```groovy
script {
    def gitTag = sh(script: "git describe --tags --abbrev=0", returnStdout: true).trim()
    def version = gitTag ?: "1.0.${BUILD_NUMBER}"
    env.VERSION = version
}
```

**🔧 方法三：时间戳版本**

```groovy
script {
    def timestamp = new Date().format("yyyyMMdd-HHmm")
    env.VERSION = "1.0.0-${timestamp}"
}
```

### 5.3 版本号最佳实践


**📊 不同环境的版本策略**

| 环境 | **版本格式** | **示例** | **说明** |
|-----|-------------|---------|---------|
| 🧪 **开发环境** | `主.次.修订-dev-构建号` | `1.0.0-dev-123` | `频繁变更` |
| 🔬 **测试环境** | `主.次.修订-rc.候选号` | `1.0.0-rc.1` | `候选版本` |
| 🚀 **生产环境** | `主.次.修订` | `1.0.0` | `正式版本` |

---

## 6. ⬇️ 制品下载与配置


### 6.1 制品下载场景


**🎯 常见下载需求**

```
场景1：部署团队需要最新版本
场景2：测试团队需要特定版本
场景3：紧急回滚需要历史版本
场景4：其他项目依赖当前制品
```

### 6.2 Jenkins中的制品下载


**🔧 从其他Job下载制品**

```groovy
pipeline {
    agent any
    stages {
        stage('Download Artifacts') {
            steps {
                // 从upstream-job下载制品
                copyArtifacts(
                    projectName: 'upstream-job',
                    selector: specific('${BUILD_NUMBER}'),
                    target: 'downloaded-artifacts/'
                )
            }
        }
        stage('Deploy') {
            steps {
                sh 'cp downloaded-artifacts/*.jar /opt/app/'
                sh 'systemctl restart myapp'
            }
        }
    }
}
```

**🔧 从外部仓库下载**

```groovy
stage('Download from Nexus') {
    steps {
        sh '''
            wget -O myapp.jar \
            "http://nexus.company.com:8081/repository/maven-releases/com/company/myapp/1.0.0/myapp-1.0.0.jar"
        '''
    }
}
```

### 6.3 制品分发策略


**📡 分发架构设计**

```
                     Jenkins Master
                           │
                    ┌──────┼──────┐
                    │      │      │
               Development │ Testing │ Production
                    │      │      │
               myapp-dev   │ myapp-test │ myapp-prod
               v1.0.0-dev  │ v1.0.0-rc1 │ v1.0.0
```

---

## 7. 💾 存储空间管理


### 7.1 存储空间问题


**🔸 常见问题**
> 制品越积越多，服务器存储空间不够用了！

```
问题现象：
磁盘使用率：95% ⚠️
Jenkins报错：No space left on device
构建失败：无法写入新文件
```

### 7.2 存储优化策略


**🗂️ 制品保留策略配置**

在Jenkins项目配置中：

**General** → **Discard old builds(丢弃旧的构建)**

```
推荐配置：
保留构建数量：30个
保留构建天数：90天
保留制品数量：10个  ← 重点配置
保留制品天数：30天
```

**📊 存储优化技巧**

| 策略 | **方法** | **效果** | **风险** |
|-----|---------|---------|---------|
| 🗑️ **定期清理** | `自动删除旧制品` | `节省空间` | `可能误删重要版本` |
| 🗜️ **压缩存储** | `zip打包制品` | `减少50%空间` | `下载时需解压` |
| ☁️ **外部存储** | `上传到云存储` | `无限扩展` | `网络依赖` |
| 🎯 **分层存储** | `重要版本本地，其他远程` | `平衡效率和空间` | `管理复杂` |

### 7.3 自动清理脚本


```groovy
pipeline {
    agent any
    stages {
        stage('Cleanup Old Artifacts') {
            steps {
                script {
                    // 清理30天前的制品
                    sh '''
                        find /var/lib/jenkins/jobs/*/builds/*/archive \
                        -type f -mtime +30 -delete
                    '''
                }
            }
        }
    }
}
```

---

## 8. 🧹 制品清理策略


### 8.1 清理策略设计


**🎯 清理原则**

```
保留重要版本：
✅ 当前生产版本
✅ 最近3个稳定版本  
✅ 主要里程碑版本(1.0.0, 2.0.0)

定期清理：
🗑️ 开发版本：保留7天
🗑️ 测试版本：保留30天
🗑️ 失败构建：保留3天
```

### 8.2 自动化清理实现


**🔧 基于时间的清理**

```groovy
def cleanupStrategy = [
    'dev': 7,      // 开发版本保留7天
    'test': 30,    // 测试版本保留30天
    'prod': 365    // 生产版本保留1年
]

cleanupStrategy.each { env, days ->
    sh "find /artifacts/${env} -type f -mtime +${days} -delete"
}
```

**🔧 基于数量的清理**

```groovy
// 每个分支只保留最新10个版本
sh '''
    for branch in dev test master; do
        ls -t /artifacts/${branch}/*.jar | tail -n +11 | xargs rm -f
    done
'''
```

### 8.3 智能清理策略


**🧠 保护重要版本**

```groovy
// 获取生产环境正在使用的版本
def prodVersion = sh(
    script: "kubectl get deployment myapp -o jsonpath='{.spec.template.spec.containers[0].image}'",
    returnStdout: true
).trim().split(':')[1]

// 保护该版本不被清理
sh "touch /artifacts/protect/${prodVersion}.jar"
```

---

## 9. 🔒 制品安全扫描


### 9.1 为什么需要安全扫描


**🔸 安全风险**
> 制品可能包含安全漏洞，就像食品需要安全检测一样

```
常见安全问题：
🔴 依赖库漏洞：使用了有安全问题的第三方库
🔴 敏感信息泄露：代码中包含密码、密钥
🔴 恶意代码：被植入病毒或后门
🔴 配置错误：不安全的默认配置
```

### 9.2 安全扫描工具集成


**🔧 SonarQube代码质量扫描**

```groovy
stage('Code Quality Scan') {
    steps {
        withSonarQubeEnv('sonarqube-server') {
            sh 'mvn sonar:sonar'
        }
        
        // 等待质量门结果
        timeout(time: 10, unit: 'MINUTES') {
            waitForQualityGate abortPipeline: true
        }
    }
}
```

**🔧 OWASP依赖检查**

```groovy
stage('Security Scan') {
    steps {
        // 安装OWASP插件后使用
        dependencyCheck additionalArguments: '--format XML --format HTML', 
                       odcInstallation: 'dependency-check'
        
        dependencyCheckPublisher pattern: 'dependency-check-report.xml'
    }
}
```

### 9.3 镜像安全扫描


**🐳 Docker镜像漏洞扫描**

```groovy
stage('Container Security Scan') {
    steps {
        script {
            // 使用Trivy扫描镜像
            sh '''
                trivy image --format json --output trivy-report.json myapp:${BUILD_NUMBER}
                trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:${BUILD_NUMBER}
            '''
        }
    }
    post {
        always {
            archiveArtifacts artifacts: 'trivy-report.json'
        }
    }
}
```

### 9.4 安全扫描结果处理


**📊 扫描结果分析**

| 严重级别 | **处理方式** | **示例** |
|---------|-------------|---------|
| 🔴 **严重** | `阻止部署` | `已知远程代码执行漏洞` |
| 🟡 **中等** | `警告但允许部署` | `信息泄露风险` |
| 🟢 **轻微** | `记录日志` | `代码质量问题` |

```groovy
script {
    def scanResult = readJSON file: 'security-scan.json'
    def criticalVulns = scanResult.vulnerabilities.findAll { 
        it.severity == 'CRITICAL' 
    }
    
    if (criticalVulns.size() > 0) {
        error "发现严重安全漏洞，停止部署！"
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 制品管理：构建产物的存储、分发、版本控制
🔸 归档策略：选择性保存重要制品，节省存储空间
🔸 版本管理：语义化版本号，环境标签区分
🔸 安全扫描：确保制品安全性，防范安全风险
🔸 存储优化：平衡保留需求和存储成本
```

### 10.2 关键理解要点


**🔹 制品管理的价值**
```
一致性保障：
- 所有环境使用相同构建产物
- 消除"我这里能跑"的问题
- 确保部署的可重复性

版本可追溯：
- 快速定位问题版本
- 支持紧急回滚
- 变更历史清晰可查
```

**🔹 存储策略的平衡**
```
保留 vs 清理：
- 重要版本长期保留
- 开发版本及时清理
- 基于使用频率分层存储

本地 vs 远程：
- 常用制品本地存储
- 历史版本远程归档
- 根据网络条件选择
```

### 10.3 实践操作要点


**✅ 推荐做法**：
- 建立清晰的版本命名规范
- 配置合适的制品保留策略
- 集成安全扫描到CI/CD流程
- 定期监控存储空间使用

**❌ 避免问题**：
- 不要保留所有构建制品
- 不要在生产环境使用latest标签
- 不要忽略安全扫描结果
- 不要让存储空间爆满

**🎯 学习检查清单**：
- [ ] 能配置Jenkins制品归档
- [ ] 会集成Nexus仓库上传下载
- [ ] 理解Docker镜像构建推送
- [ ] 掌握版本号管理策略
- [ ] 了解安全扫描的重要性

**🧠 记忆要点**：
- 制品管理 = 版本一致性 + 快速回滚
- 存储策略 = 重要保留 + 定期清理  
- 安全扫描 = 质量保障 + 风险防控
- 版本管理 = 语义化 + 环境区分

**核心记忆口诀**：
> 制品管理保一致，版本清晰好追溯
> 存储优化省空间，安全扫描防风险