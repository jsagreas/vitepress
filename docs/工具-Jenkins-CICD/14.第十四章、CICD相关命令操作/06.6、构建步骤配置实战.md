---
title: 6、构建步骤配置实战
---
## 📚 目录

1. [构建步骤基础概念](#1-构建步骤基础概念)
2. [Shell脚本构建步骤](#2-Shell脚本构建步骤)
3. [环境变量的使用](#3-环境变量的使用)
4. [构建工具集成](#4-构建工具集成)
5. [编译与测试配置](#5-编译与测试配置)
6. [构建产物处理](#6-构建产物处理)
7. [高级构建特性](#7-高级构建特性)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ 构建步骤基础概念


### 1.1 什么是构建步骤


**简单理解**：构建步骤就像做菜的步骤一样，告诉Jenkins一步一步该做什么

```
做菜的步骤：              Jenkins构建步骤：
1. 洗菜                  1. 拉取代码
2. 切菜                  2. 编译代码  
3. 炒菜                  3. 运行测试
4. 装盘                  4. 打包部署

每一步都有明确的操作，按顺序执行
```

**专业定义**：构建步骤(Build Steps)是Jenkins任务中定义的一系列自动化操作指令，用于完成代码的编译、测试、打包等工作。

### 1.2 构建步骤的分类


**🔸 按执行方式分类**
```
脚本类构建步骤：
├── Shell脚本 (Linux/Mac)
├── Windows批处理
└── PowerShell脚本

工具类构建步骤：
├── Maven构建
├── Gradle构建  
├── Ant构建
└── Docker命令

插件类构建步骤：
├── 邮件发送
├── 文件操作
└── 代码质量检查
```

### 1.3 构建步骤的执行流程


```
任务触发
    ↓
准备工作空间
    ↓
执行构建步骤1 ── 成功 ──→ 执行构建步骤2
    ↓                        ↓
   失败                    成功继续
    ↓                        ↓
标记任务失败              完成所有步骤
    ↓                        ↓
停止执行                  标记任务成功
```

**关键理解**：
- 🔸 **顺序执行**：步骤按添加顺序依次执行
- 🔸 **失败停止**：任一步骤失败，后续步骤不再执行
- 🔸 **环境隔离**：每个步骤在相同的工作空间中执行

---

## 2. 💻 Shell脚本构建步骤


### 2.1 Shell脚本的基本使用


**什么是Shell脚本构建步骤**：就是让Jenkins执行Linux命令，就像你在终端里敲命令一样。

**📋 添加Shell构建步骤**
```
任务配置页面 → 构建 → 增加构建步骤 → Execute shell
```

**基础示例**：
```bash
# 简单的Hello World
echo "开始构建任务..."
echo "当前时间: $(date)"
echo "当前用户: $(whoami)"
echo "工作目录: $(pwd)"
```

### 2.2 常用Shell命令实战


**🔸 文件操作命令**
```bash
# 查看文件列表
ls -la

# 创建目录
mkdir -p build/output

# 复制文件
cp src/config.json build/

# 删除临时文件
rm -rf temp/
find . -name "*.tmp" -delete
```

**🔸 项目构建命令**
```bash
# 前端项目构建
npm install
npm run build

# 后端项目构建
mvn clean compile
mvn package -DskipTests

# Python项目
pip install -r requirements.txt
python setup.py build
```

### 2.3 Shell脚本最佳实践


**💡 错误处理**
```bash
# 设置严格模式：任何命令失败就停止
set -e

# 检查命令是否存在
if ! command -v npm &> /dev/null; then
    echo "错误：npm 未安装"
    exit 1
fi

# 检查文件是否存在
if [ ! -f "package.json" ]; then
    echo "错误：找不到 package.json"
    exit 1
fi
```

**⚠️ 常见陷阱避免**
```bash
# ❌ 错误做法：不检查命令结果
npm install
npm run build

# ✅ 正确做法：检查每步是否成功
npm install || { echo "npm install 失败"; exit 1; }
npm run build || { echo "构建失败"; exit 1; }
```

---

## 3. 🔧 环境变量的使用


### 3.1 什么是环境变量


**通俗理解**：环境变量就像是Jenkins给你准备的"小纸条"，上面写着各种有用的信息，比如任务名称、构建编号等。

**实际作用**：让你的构建脚本能够获取Jenkins运行时的各种信息，实现动态配置。

### 3.2 Jenkins内置环境变量


**🔸 最常用的内置变量**

| 变量名 | 含义 | 示例值 |
|--------|------|--------|
| `$JOB_NAME` | 任务名称 | `my-web-app` |
| `$BUILD_NUMBER` | 构建编号 | `123` |
| `$WORKSPACE` | 工作空间路径 | `/var/jenkins_home/workspace/my-app` |
| `$BUILD_URL` | 构建页面URL | `http://jenkins.com/job/my-app/123/` |
| `$GIT_COMMIT` | Git提交哈希 | `a1b2c3d4e5f6...` |
| `$GIT_BRANCH` | Git分支名 | `origin/main` |

**实际使用示例**：
```bash
# 在构建过程中打印基本信息
echo "=== 构建信息 ==="
echo "项目名称: $JOB_NAME"
echo "构建编号: $BUILD_NUMBER" 
echo "Git分支: $GIT_BRANCH"
echo "Git提交: $GIT_COMMIT"

# 使用变量创建版本号
VERSION="$JOB_NAME-$BUILD_NUMBER"
echo "生成版本号: $VERSION"
```

### 3.3 自定义环境变量


**🔸 在任务中设置环境变量**
```
任务配置 → 构建环境 → 勾选"Set environment variables"
```

**设置示例**：
```
NODE_ENV=production
API_URL=https://api.example.com
VERSION=1.2.3
```

**在脚本中使用**：
```bash
# 使用自定义环境变量
echo "运行环境: $NODE_ENV"
echo "API地址: $API_URL"

# 根据环境选择不同配置
if [ "$NODE_ENV" = "production" ]; then
    echo "使用生产环境配置"
    cp config/prod.json config/app.json
else
    echo "使用开发环境配置"
    cp config/dev.json config/app.json
fi
```

### 3.4 环境变量实战技巧


**🎯 动态文件命名**
```bash
# 使用时间戳和构建号命名
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
ARTIFACT_NAME="${JOB_NAME}_${BUILD_NUMBER}_${TIMESTAMP}.zip"

# 打包文件
zip -r "$ARTIFACT_NAME" build/
echo "生成构建产物: $ARTIFACT_NAME"
```

**🎯 条件构建逻辑**
```bash
# 根据分支执行不同操作
case "$GIT_BRANCH" in
    "origin/main")
        echo "主分支构建，执行完整测试"
        npm run test:full
        ;;
    "origin/develop")
        echo "开发分支构建，执行快速测试"
        npm run test:unit
        ;;
    *)
        echo "特性分支构建，跳过测试"
        ;;
esac
```

---

## 4. 🛠️ 构建工具集成


### 4.1 Maven构建集成


**什么是Maven**：Maven是Java项目的"自动化管家"，帮你管理依赖、编译代码、运行测试、打包程序。

**🔸 添加Maven构建步骤**
```
构建 → 增加构建步骤 → Invoke top-level Maven targets
```

**基础配置**：
```
Maven版本: (选择已安装的Maven版本)
Goals: clean compile package
Advanced Project Options: (通常保持默认)
```

**常用Maven命令组合**：

| 目标组合 | 作用说明 | 适用场景 |
|----------|----------|----------|
| `clean compile` | 清理并编译 | 🟢 快速验证代码 |
| `clean test` | 清理、编译、测试 | 🟡 代码提交前检查 |
| `clean package` | 完整构建打包 | 🔴 发布准备 |
| `clean install` | 构建并安装到本地仓库 | 🔴 多模块项目 |

### 4.2 Gradle构建集成


**什么是Gradle**：Gradle是更现代的构建工具，比Maven更灵活，Android项目特别喜欢用它。

**🔸 Shell方式执行Gradle**
```bash
# 确保Gradle wrapper可执行
chmod +x gradlew

# 执行构建任务
./gradlew clean build

# 只编译不测试
./gradlew clean compileJava

# 生成测试报告
./gradlew test jacocoTestReport
```

**实际项目示例**：
```bash
echo "开始Gradle构建..."

# 显示Gradle版本
./gradlew --version

# 清理并构建
./gradlew clean build --info

# 检查构建结果
if [ -f "build/libs/*.jar" ]; then
    echo "✅ JAR文件构建成功"
    ls -la build/libs/
else
    echo "❌ JAR文件构建失败"
    exit 1
fi
```

### 4.3 Node.js项目构建


**前端项目构建流程**：
```bash
# 检查Node.js环境
echo "Node.js版本: $(node --version)"
echo "npm版本: $(npm --version)"

# 安装依赖（使用缓存加速）
npm ci  # 比npm install更适合CI环境

# 代码检查
npm run lint

# 运行测试
npm run test

# 构建生产版本
npm run build

# 检查构建输出
if [ -d "dist" ]; then
    echo "✅ 前端构建成功"
    du -sh dist/
else
    echo "❌ 前端构建失败"
    exit 1
fi
```

---

## 5. ⚡ 编译与测试配置


### 5.1 编译配置最佳实践


**🔸 多语言编译示例**

**Java项目编译**：
```bash
# 设置Java环境
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk
export PATH=$JAVA_HOME/bin:$PATH

# 显示Java版本
java -version

# Maven编译
mvn clean compile -DskipTests=true

# 检查编译结果
if [ $? -eq 0 ]; then
    echo "✅ Java编译成功"
else
    echo "❌ Java编译失败"
    exit 1
fi
```

**Python项目编译**：
```bash
# 创建虚拟环境
python3 -m venv venv
source venv/bin/activate

# 升级pip
pip install --upgrade pip

# 安装依赖
pip install -r requirements.txt

# 代码风格检查
flake8 src/

# 类型检查
mypy src/
```

### 5.2 测试执行配置


**🔸 分层测试策略**

```
测试金字塔：
    /\
   /  \ ← E2E测试 (少量，慢)
  /____\
 /      \ ← 集成测试 (适量，中速)  
/________\
单元测试 ← (大量，快速)
```

**实际测试配置**：
```bash
echo "=== 开始测试阶段 ==="

# 单元测试 (快速反馈)
echo "运行单元测试..."
npm run test:unit || { echo "单元测试失败"; exit 1; }

# 集成测试 (仅在主分支)
if [ "$GIT_BRANCH" = "origin/main" ]; then
    echo "运行集成测试..."
    npm run test:integration
fi

# 代码覆盖率检查
npm run test:coverage
COVERAGE=$(cat coverage/coverage-summary.json | jq '.total.lines.pct')
echo "代码覆盖率: $COVERAGE%"

if (( $(echo "$COVERAGE < 80" | bc -l) )); then
    echo "⚠️ 代码覆盖率低于80%"
fi
```

### 5.3 测试结果处理


**🔸 测试报告收集**
```bash
# 生成JUnit格式测试报告
npm run test -- --reporter=junit --outputFile=test-results.xml

# 生成HTML测试报告  
npm run test:report

# 收集测试产物
mkdir -p reports
cp test-results.xml reports/
cp -r coverage/ reports/
cp -r test-results.html reports/

echo "测试报告已保存到 reports/ 目录"
```

---

## 6. 📦 构建产物处理


### 6.1 什么是构建产物


**通俗理解**：构建产物就是你的代码经过编译、打包后生成的"成品"，比如：
- 🔸 **前端项目**：打包后的HTML、CSS、JS文件
- 🔸 **Java项目**：编译好的JAR或WAR文件  
- 🔸 **移动应用**：APK或IPA安装包
- 🔸 **Docker项目**：Docker镜像

### 6.2 构建产物归档


**🔸 在Jenkins中归档文件**
```
构建后操作 → 增加构建后操作步骤 → Archive the artifacts
```

**归档配置示例**：
```
Files to archive: dist/**, *.jar, reports/**
Exclude: **/*.log, **/node_modules/**
```

**Shell脚本归档**：
```bash
# 创建归档目录
mkdir -p archives

# 收集不同类型的产物
if [ -d "dist" ]; then
    # 前端构建产物
    tar -czf archives/frontend-${BUILD_NUMBER}.tar.gz dist/
fi

if [ -f "target/*.jar" ]; then
    # Java构建产物
    cp target/*.jar archives/
fi

if [ -d "build/reports" ]; then
    # 测试报告
    cp -r build/reports archives/
fi

echo "构建产物已收集到 archives/ 目录"
ls -la archives/
```

### 6.3 构建产物版本管理


**🎯 语义化版本命名**
```bash
# 从Git标签获取版本
if git describe --tags --exact-match HEAD 2>/dev/null; then
    VERSION=$(git describe --tags --exact-match HEAD)
else
    VERSION="1.0.0-${BUILD_NUMBER}"
fi

# 生成带版本号的产物
JAR_NAME="myapp-${VERSION}.jar"
cp target/myapp.jar "artifacts/${JAR_NAME}"

echo "生成版本化产物: ${JAR_NAME}"
```

**🎯 多环境产物管理**
```bash
# 根据分支生成不同后缀的产物
case "$GIT_BRANCH" in
    "origin/main")
        SUFFIX="release"
        ;;
    "origin/develop")  
        SUFFIX="snapshot"
        ;;
    *)
        SUFFIX="feature"
        ;;
esac

ARTIFACT_NAME="myapp-${VERSION}-${SUFFIX}.jar"
cp target/myapp.jar "artifacts/${ARTIFACT_NAME}"
```

---

## 7. 🚀 高级构建特性


### 7.1 条件构建逻辑


**什么是条件构建**：就是让Jenkins根据不同情况执行不同的构建步骤，比如测试分支只做基础检查，生产分支做完整测试。

**🔸 基于分支的条件构建**
```bash
# 获取分支名（去掉origin/前缀）
BRANCH_NAME=${GIT_BRANCH#origin/}
echo "当前分支: $BRANCH_NAME"

case "$BRANCH_NAME" in
    "main")
        echo "🔴 生产分支构建"
        npm run build:prod
        npm run test:full
        npm run deploy:staging
        ;;
    "develop")
        echo "🟡 开发分支构建"  
        npm run build:dev
        npm run test:unit
        ;;
    "feature/"*)
        echo "🟢 特性分支构建"
        npm run lint
        npm run test:unit
        ;;
    *)
        echo "🔵 其他分支，执行基础检查"
        npm run lint
        ;;
esac
```

**🔸 基于时间的条件构建**
```bash
# 获取当前小时
HOUR=$(date +%H)

if [ "$HOUR" -ge 9 ] && [ "$HOUR" -le 18 ]; then
    echo "工作时间构建，执行快速测试"
    npm run test:quick
else
    echo "非工作时间构建，执行完整测试"
    npm run test:full
fi
```

### 7.2 并行构建配置


**为什么需要并行构建**：当项目变大后，串行执行所有步骤会很慢。并行构建就是同时执行多个独立的任务，提高效率。

**🔸 简单并行实现**
```bash
echo "开始并行构建..."

# 后台执行多个任务
{
    echo "任务1: 代码检查"
    npm run lint > lint.log 2>&1
    echo "代码检查完成"
} &

{
    echo "任务2: 单元测试"  
    npm run test:unit > test.log 2>&1
    echo "单元测试完成"
} &

{
    echo "任务3: 依赖检查"
    npm audit > audit.log 2>&1  
    echo "依赖检查完成"
} &

# 等待所有后台任务完成
wait

echo "✅ 所有并行任务已完成"

# 检查结果
if grep -q "FAIL" test.log; then
    echo "❌ 测试失败"
    exit 1
fi
```

### 7.3 构建缓存优化


**什么是构建缓存**：就是把上次构建的一些结果保存起来，下次构建时可以重复使用，节省时间。

**🔸 npm缓存优化**
```bash
# 设置npm缓存目录
NPM_CACHE_DIR="$WORKSPACE/.npm-cache"
mkdir -p "$NPM_CACHE_DIR"

# 使用缓存安装依赖
npm ci --cache "$NPM_CACHE_DIR" --prefer-offline

# 显示缓存统计
echo "npm缓存使用情况:"
npm cache verify --cache "$NPM_CACHE_DIR"
```

**🔸 Maven本地仓库缓存**
```bash
# 设置Maven本地仓库位置  
MAVEN_REPO="$WORKSPACE/.m2/repository"
mkdir -p "$MAVEN_REPO"

# 使用本地仓库构建
mvn clean package -Dmaven.repo.local="$MAVEN_REPO"

echo "Maven仓库大小: $(du -sh $MAVEN_REPO)"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基础概念


```
🔸 构建步骤本质：告诉Jenkins按顺序执行的自动化操作
🔸 Shell脚本：最灵活的构建方式，像在终端敲命令
🔸 环境变量：Jenkins提供的运行时信息，实现动态配置
🔸 构建工具：Maven/Gradle等专业工具的集成使用
🔸 构建产物：代码经过处理后生成的最终"成品"
```

### 8.2 关键操作技能


**🔹 Shell脚本编写**
```
✅ 基础命令：ls、cp、rm、mkdir等文件操作
✅ 错误处理：使用set -e和条件判断
✅ 变量使用：$BUILD_NUMBER、$GIT_BRANCH等
✅ 流程控制：if-else、case语句
```

**🔹 构建工具使用**
```
Maven项目：
- clean compile: 清理编译
- clean package: 完整打包  
- clean test: 运行测试

Node.js项目:
- npm ci: CI环境安装依赖
- npm run build: 构建项目
- npm run test: 运行测试
```

**🔹 环境变量活用**
```
常用内置变量：
- $JOB_NAME: 获取任务名称
- $BUILD_NUMBER: 获取构建编号
- $GIT_BRANCH: 获取Git分支
- $WORKSPACE: 获取工作目录

实用技巧：
- 动态命名：${JOB_NAME}_${BUILD_NUMBER}.zip
- 条件执行：根据分支执行不同逻辑
- 版本管理：结合Git信息生成版本号
```

### 8.3 实战最佳实践


**🎯 构建脚本编写原则**
```
1. 设置严格模式：set -e (命令失败就停止)
2. 检查依赖：确认必要工具已安装
3. 显示关键信息：打印版本、分支、时间等
4. 错误处理：每个重要步骤都要检查结果
5. 清理资源：构建完成后清理临时文件
```

**🎯 性能优化策略**
```
缓存利用：
- npm cache: 缓存node_modules依赖
- Maven local repo: 缓存Java依赖包
- Docker layer cache: 缓存Docker镜像层

并行执行：
- 代码检查、测试、构建可以并行
- 使用&符号后台执行，wait等待完成

条件构建：
- 特性分支只做基础检查
- 主分支做完整测试和部署
- 根据时间决定测试深度
```

**🎯 常见问题避免**
```
❌ 权限问题：记得chmod +x给脚本执行权限
❌ 路径问题：使用绝对路径或相对于$WORKSPACE的路径
❌ 环境差异：在脚本中明确指定工具版本
❌ 资源泄露：及时清理临时文件和进程
❌ 错误忽略：不要忽略命令的返回值
```

### 8.4 学习进阶路径


```
初级阶段 🟢：
├── 掌握基础Shell命令
├── 理解环境变量概念
├── 配置简单的编译步骤
└── 学会查看构建日志

中级阶段 🟡：
├── 编写复杂构建脚本
├── 集成多种构建工具
├── 实现条件构建逻辑
└── 优化构建性能

高级阶段 🔴：
├── 设计并行构建策略
├── 实现智能缓存机制
├── 集成代码质量检查
└── 构建自动化测试流水线
```

**核心记忆口诀**：
- 构建步骤如做菜，一步一步不能乱
- Shell脚本是基础，环境变量很重要
- 错误检查要到位，构建产物要收好
- 条件并行提效率，缓存优化节时间