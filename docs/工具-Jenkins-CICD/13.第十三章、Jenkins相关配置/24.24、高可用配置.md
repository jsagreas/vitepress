---
title: 24、高可用配置
---
## 📚 目录

1. [高可用基本概念](#1-高可用基本概念)
2. [主从配置架构](#2-主从配置架构)
3. [负载均衡配置](#3-负载均衡配置)
4. [故障转移配置](#4-故障转移配置)
5. [集群配置参数](#5-集群配置参数)
6. [共享存储配置](#6-共享存储配置)
7. [数据同步配置](#7-数据同步配置)
8. [健康检查配置](#8-健康检查配置)
9. [自动故障恢复配置](#9-自动故障恢复配置)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 高可用基本概念


### 1.1 什么是高可用

**高可用（High Availability，HA）**：简单说就是让Jenkins服务**几乎不会停机**，即使某个服务器出问题了，系统还能正常工作。

```
传统单机模式的问题：
服务器故障 → Jenkins停止工作 → 所有构建任务停止 → 开发团队无法工作

高可用模式的优势：
主服务器故障 → 自动切换到备用服务器 → 构建任务继续执行 → 开发不受影响
```

### 1.2 高可用的核心目标

**🔸 可用性保障**
- **99.9%可用性**：一年停机时间不超过8.76小时
- **99.99%可用性**：一年停机时间不超过52.56分钟
- **零计划内停机**：升级维护时用户无感知

**🔸 业务连续性**
- **构建任务不中断**：正在执行的任务能够完成
- **数据不丢失**：配置、构建历史、工件完整保存
- **服务快速恢复**：故障后几分钟内恢复服务

### 1.3 高可用的实现思路

```
冗余设计思路：
┌─────────────┐    ┌─────────────┐
│   主Jenkins  │ ←→ │  备Jenkins   │
│   (Active)  │    │ (Standby)   │
└─────────────┘    └─────────────┘
       ↑                   ↑
       └───── 共享存储 ──────┘
         (配置、数据、工件)

用户访问 → 负载均衡器 → 健康的Jenkins实例
```

---

## 2. 🏗️ 主从配置架构


### 2.1 主从架构基本概念

**主从架构**：一个**主服务器**（Master）负责调度管理，多个**从服务器**（Agent/Slave）负责执行具体的构建任务。

```
Jenkins主从架构示意图：
                    ┌──────────────┐
                    │  Jenkins主节点 │ ←── 用户访问入口
                    │   (Master)   │ ←── 任务调度中心
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │Agent节点1│       │Agent节点2│       │Agent节点3│
   │ Linux构建│       │Windows构建│      │ macOS构建│
   └─────────┘       └─────────┘       └─────────┘
```

### 2.2 主节点职责

**🔸 任务调度管理**
- **接收构建请求**：用户提交的构建任务
- **分配执行节点**：根据标签和资源情况选择合适的Agent
- **监控执行状态**：跟踪任务进度和结果
- **结果收集整理**：汇总构建日志和产物

**🔸 系统配置管理**
- **插件管理**：安装、更新、配置插件
- **用户权限管理**：认证、授权、角色分配
- **系统配置**：全局配置、工具配置、环境变量

### 2.3 从节点配置

**基本配置参数**：
```properties
# 节点基本信息
节点名称: build-agent-01
描述: Linux构建节点
执行器数量: 4
远程工作目录: /home/jenkins/workspace
标签: linux java maven docker

# 连接配置
启动方式: 通过SSH启动agent
主机: 192.168.1.100
凭据: jenkins-ssh-key
主机密钥验证策略: 已知主机文件验证策略
```

**🔧 SSH连接配置示例**：
```bash
# 1. 在主节点生成SSH密钥
ssh-keygen -t rsa -b 4096 -C "jenkins@company.com"

# 2. 将公钥复制到从节点
ssh-copy-id -i ~/.ssh/id_rsa.pub jenkins@192.168.1.100

# 3. 在Jenkins中添加SSH凭据
# 管理Jenkins → 凭据 → 添加凭据
# 类型：SSH Username with private key
# 用户名：jenkins
# 私钥：直接输入或从文件选择
```

### 2.4 标签与任务分配

**标签的作用**：让Jenkins知道哪些节点适合执行什么类型的任务。

```
标签配置示例：
┌─────────────┬──────────────┬────────────────┐
│    节点     │     标签     │   适用任务     │
├─────────────┼──────────────┼────────────────┤
│ agent-linux │ linux maven  │ Java项目构建   │
│ agent-win   │ windows .net │ .NET项目构建   │
│ agent-mac   │ macos ios    │ iOS应用构建    │
│ agent-docker│ docker k8s   │ 容器化部署     │
└─────────────┴──────────────┴────────────────┘
```

**Pipeline中使用标签**：
```groovy
pipeline {
    agent {
        label 'linux && maven'  // 选择有linux和maven标签的节点
    }
    stages {
        stage('Build') {
            steps {
                sh 'mvn clean package'
            }
        }
    }
}
```

---

## 3. ⚖️ 负载均衡配置


### 3.1 负载均衡的目的

**负载均衡**：把用户的访问请求**均匀分配**到多个Jenkins实例上，避免单个实例压力过大。

```
没有负载均衡的问题：
所有用户 → 单个Jenkins → 服务器压力大 → 响应慢甚至宕机

有负载均衡的优势：
      ┌→ Jenkins实例1 (处理30%请求)
用户 → 负载均衡器 ┼→ Jenkins实例2 (处理40%请求)
      └→ Jenkins实例3 (处理30%请求)
```

### 3.2 Nginx负载均衡配置

**🔧 Nginx配置示例**：
```nginx
# /etc/nginx/sites-available/jenkins
upstream jenkins_cluster {
    # 定义后端Jenkins实例
    server 192.168.1.101:8080 weight=3 max_fails=3 fail_timeout=30s;
    server 192.168.1.102:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 192.168.1.103:8080 weight=1 backup;  # 备用节点
}

server {
    listen 80;
    server_name jenkins.company.com;
    
    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl;
    server_name jenkins.company.com;
    
    # SSL配置
    ssl_certificate /etc/ssl/certs/jenkins.crt;
    ssl_certificate_key /etc/ssl/private/jenkins.key;
    
    location / {
        proxy_pass http://jenkins_cluster;
        
        # 保持会话粘性（重要！）
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket支持（Jenkins需要）
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # 超时配置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
```

### 3.3 会话粘性问题

**会话粘性**：确保同一个用户的请求始终被分配到同一个Jenkins实例。

**⚠️ 为什么需要会话粘性**：
- Jenkins的登录会话存储在服务器内存中
- 如果用户请求被分配到不同实例，会导致需要重复登录
- 构建过程中的临时数据可能丢失

**🔧 实现会话粘性**：
```nginx
upstream jenkins_cluster {
    # 使用ip_hash确保同一IP访问同一实例
    ip_hash;
    server 192.168.1.101:8080;
    server 192.168.1.102:8080;
    server 192.168.1.103:8080;
}
```

---

## 4. 🔄 故障转移配置


### 4.1 故障转移基本概念

**故障转移（Failover）**：当主服务器出现故障时，系统**自动切换**到备用服务器，保证服务不中断。

```
故障转移过程：
正常状态：  用户 → 主Jenkins → 正常服务
故障发生：  主Jenkins故障 → 健康检查失败
自动切换：  用户 → 备用Jenkins → 服务恢复
故障恢复：  主Jenkins修复 → 可选择切回主节点
```

### 4.2 主备模式配置

**主备切换原理**：
- **主节点**（Active）：正常提供服务
- **备节点**（Standby）：待机状态，定期同步数据
- **共享存储**：两节点共享配置和数据
- **虚拟IP**：用户访问的统一入口

```
主备架构图：
  ┌─────────────┐      ┌─────────────┐
  │   主节点     │      │   备节点     │
  │  (Active)   │ ←──→ │ (Standby)   │
  │ 192.168.1.101│      │192.168.1.102│
  └──────┬──────┘      └──────┬──────┘
         │                    │
         └────── 共享存储 ──────┘
               (NFS/SAN)
              ↑
         虚拟IP: 192.168.1.100
```

### 4.3 Keepalived配置

**🔧 主节点Keepalived配置**：
```bash
# /etc/keepalived/keepalived.conf (主节点)
vrrp_script check_jenkins {
    script "/usr/local/bin/check_jenkins.sh"
    interval 5        # 每5秒检查一次
    timeout 3         # 3秒超时
    fall 2           # 连续2次失败认为故障
    rise 2           # 连续2次成功认为恢复
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 150      # 主节点优先级高
    advert_int 1
    
    authentication {
        auth_type PASS
        auth_pass jenkins2024
    }
    
    virtual_ipaddress {
        192.168.1.100/24  # 虚拟IP
    }
    
    track_script {
        check_jenkins
    }
    
    notify_master "/usr/local/bin/jenkins_master.sh"
    notify_backup "/usr/local/bin/jenkins_backup.sh"
}
```

**🔧 Jenkins健康检查脚本**：
```bash
#!/bin/bash
# /usr/local/bin/check_jenkins.sh
JENKINS_URL="http://localhost:8080"
TIMEOUT=10

# 检查Jenkins是否响应
curl -f -s --max-time $TIMEOUT "$JENKINS_URL/login" > /dev/null 2>&1

if [ $? -eq 0 ]; then
    # Jenkins正常
    exit 0
else
    # Jenkins异常
    logger "Jenkins health check failed"
    exit 1
fi
```

---

## 5. 🔧 集群配置参数


### 5.1 Jenkins集群核心参数

**系统级配置参数**：

| 参数名称 | 默认值 | 推荐值 | 说明 |
|---------|--------|--------|------|
| `jenkins.model.Jenkins.slaveAgentPort` | 随机 | `50000` | Agent连接端口 |
| `hudson.slaves.NodeProvisioner.initialDelay` | 5000 | `1000` | 节点供应延迟(ms) |
| `hudson.slaves.ChannelPinger.pingInterval` | 300 | `60` | 心跳检测间隔(秒) |
| `hudson.remoting.Launcher.pingInterval` | 240 | `60` | 连接ping间隔(秒) |
| `hudson.slaves.WorkspaceList` | - | `/tmp/workspace` | 工作空间列表 |

### 5.2 JVM参数优化

**主节点JVM配置**：
```bash
# /etc/default/jenkins
JAVA_ARGS="-Xms2g -Xmx4g \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:+UseStringDeduplication \
  -XX:+DisableExplicitGC \
  -Djava.awt.headless=true \
  -Djenkins.install.runSetupWizard=false \
  -Dhudson.slaves.NodeProvisioner.initialDelay=1000 \
  -Dhudson.slaves.ChannelPinger.pingInterval=60 \
  -Djava.net.preferIPv4Stack=true"
```

**参数说明**：
- **`-Xms2g -Xmx4g`**：设置初始和最大堆内存为2G和4G
- **`-XX:+UseG1GC`**：使用G1垃圾收集器，适合大内存应用
- **`-XX:MaxGCPauseMillis=200`**：限制GC暂停时间为200毫秒
- **`-Djenkins.install.runSetupWizard=false`**：跳过初始安装向导

### 5.3 网络配置参数

**网络连接优化**：
```properties
# Jenkins系统配置
hudson.slaves.ChannelPinger.pingInterval=60
hudson.slaves.ChannelPinger.pingTimeoutSeconds=30
hudson.remoting.Launcher.pingInterval=60
hudson.remoting.Launcher.pingTimeoutSeconds=30
hudson.TcpSlaveAgentListener.hostName=jenkins.company.com
hudson.TcpSlaveAgentListener.port=50000
```

---

## 6. 💾 共享存储配置


### 6.1 共享存储的作用

**共享存储**：让多个Jenkins实例能够访问**相同的数据**，包括配置、构建历史、工件等。

```
共享存储架构：
┌─────────────┐    ┌─────────────┐
│  Jenkins A  │    │  Jenkins B  │
└──────┬──────┘    └──────┬──────┘
       │                  │
       └────── NFS ────────┘
              存储服务器
        /var/lib/jenkins
```

### 6.2 NFS共享存储配置

**🔧 NFS服务器配置**：
```bash
# 1. 安装NFS服务
sudo apt-get install nfs-kernel-server

# 2. 创建共享目录
sudo mkdir -p /export/jenkins
sudo chown jenkins:jenkins /export/jenkins
sudo chmod 755 /export/jenkins

# 3. 配置NFS导出
# /etc/exports
/export/jenkins 192.168.1.0/24(rw,sync,no_subtree_check,no_root_squash)

# 4. 重启NFS服务
sudo systemctl restart nfs-kernel-server
sudo exportfs -a
```

**🔧 客户端挂载配置**：
```bash
# 在每个Jenkins节点上
# 1. 安装NFS客户端
sudo apt-get install nfs-common

# 2. 创建挂载点
sudo mkdir -p /var/lib/jenkins

# 3. 挂载NFS
sudo mount -t nfs 192.168.1.200:/export/jenkins /var/lib/jenkins

# 4. 设置开机自动挂载
# /etc/fstab
192.168.1.200:/export/jenkins /var/lib/jenkins nfs defaults,_netdev 0 0
```

### 6.3 存储性能优化

**NFS性能调优参数**：
```bash
# 高性能挂载选项
sudo mount -t nfs \
  -o rsize=32768,wsize=32768,hard,intr,timeo=600,retrans=2 \
  192.168.1.200:/export/jenkins /var/lib/jenkins
```

**参数说明**：
- **`rsize=32768`**：读取块大小32KB，提高读取性能
- **`wsize=32768`**：写入块大小32KB，提高写入性能
- **`hard`**：硬挂载，网络故障时会重试而不是返回错误
- **`timeo=600`**：超时时间60秒
- **`retrans=2`**：重传次数2次

---

## 7. 🔄 数据同步配置


### 7.1 数据同步的必要性

**为什么需要数据同步**：
- **配置一致性**：确保所有节点的Jenkins配置相同
- **构建历史**：让用户在任何节点都能看到完整的构建历史
- **插件同步**：保证所有节点安装相同版本的插件
- **用户数据**：用户配置、权限设置等保持一致

### 7.2 实时同步方案

**🔧 rsync + inotify实时同步**：
```bash
#!/bin/bash
# /usr/local/bin/jenkins_sync.sh
SOURCE_DIR="/var/lib/jenkins/"
TARGET_HOST="192.168.1.102"
TARGET_DIR="/var/lib/jenkins/"
EXCLUDE_FILE="/etc/jenkins/rsync_exclude.txt"

# 排除不需要同步的文件
cat > $EXCLUDE_FILE << EOF
logs/
workspace/
builds/*/log
builds/*/archive
temp/
.temp
*.tmp
EOF

# 实时监控并同步
inotifywait -mr --timefmt '%d/%m/%y %H:%M' --format '%T %w %f %e' \
  --exclude '(logs|workspace|\.tmp)' \
  -e modify,create,delete,move $SOURCE_DIR | \
while read DATE TIME DIR FILE EVENT; do
  echo "$DATE $TIME: $DIR$FILE was $EVENT"
  
  # 执行同步
  rsync -avz --delete \
    --exclude-from=$EXCLUDE_FILE \
    $SOURCE_DIR \
    jenkins@$TARGET_HOST:$TARGET_DIR
done
```

### 7.3 定期同步策略

**🕐 定时同步脚本**：
```bash
#!/bin/bash
# /usr/local/bin/jenkins_backup_sync.sh

# 配置参数
JENKINS_HOME="/var/lib/jenkins"
BACKUP_HOST="192.168.1.103"
BACKUP_DIR="/backup/jenkins"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建配置备份
tar -czf /tmp/jenkins_config_$DATE.tar.gz \
  --exclude='workspace' \
  --exclude='builds' \
  --exclude='logs' \
  $JENKINS_HOME/config.xml \
  $JENKINS_HOME/jobs/ \
  $JENKINS_HOME/users/ \
  $JENKINS_HOME/plugins/ \
  $JENKINS_HOME/secrets/

# 同步到备份服务器
scp /tmp/jenkins_config_$DATE.tar.gz \
  jenkins@$BACKUP_HOST:$BACKUP_DIR/

# 清理本地临时文件
rm -f /tmp/jenkins_config_$DATE.tar.gz

# 保留最近7天的备份
ssh jenkins@$BACKUP_HOST \
  "find $BACKUP_DIR -name 'jenkins_config_*.tar.gz' -mtime +7 -delete"
```

**设置定时任务**：
```bash
# 添加到crontab
# 每天凌晨2点执行完整备份同步
0 2 * * * /usr/local/bin/jenkins_backup_sync.sh

# 每小时执行增量同步
0 * * * * /usr/local/bin/jenkins_sync.sh
```

---

## 8. 🔍 健康检查配置


### 8.1 健康检查的重要性

**健康检查**：定期检测Jenkins服务的**运行状态**，及时发现问题并采取措施。

```
健康检查层次：
┌─────────────┐
│  应用层检查  │ ← Jenkins API响应、登录页面
├─────────────┤
│  服务层检查  │ ← Java进程、端口监听
├─────────────┤
│  系统层检查  │ ← CPU、内存、磁盘
└─────────────┘
```

### 8.2 多层级健康检查

**🔧 综合健康检查脚本**：
```bash
#!/bin/bash
# /usr/local/bin/jenkins_health_check.sh

JENKINS_URL="http://localhost:8080"
LOG_FILE="/var/log/jenkins_health.log"
ALERT_EMAIL="admin@company.com"

# 函数：记录日志
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 函数：发送告警
send_alert() {
    echo "$1" | mail -s "Jenkins健康检查告警" $ALERT_EMAIL
    log_message "ALERT: $1"
}

# 1. 检查Java进程
check_java_process() {
    if ! pgrep -f "jenkins.war" > /dev/null; then
        send_alert "Jenkins Java进程未运行"
        return 1
    fi
    return 0
}

# 2. 检查端口监听
check_port() {
    if ! netstat -ln | grep ":8080" > /dev/null; then
        send_alert "Jenkins端口8080未监听"
        return 1
    fi
    return 0
}

# 3. 检查HTTP响应
check_http_response() {
    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $JENKINS_URL/login)
    if [ "$HTTP_CODE" != "200" ]; then
        send_alert "Jenkins HTTP响应异常: $HTTP_CODE"
        return 1
    fi
    return 0
}

# 4. 检查系统资源
check_system_resources() {
    # 检查CPU使用率
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    if (( $(echo "$CPU_USAGE > 90" | bc -l) )); then
        send_alert "CPU使用率过高: ${CPU_USAGE}%"
    fi
    
    # 检查内存使用率
    MEM_USAGE=$(free | grep Mem | awk '{printf "%.1f", $3/$2 * 100.0}')
    if (( $(echo "$MEM_USAGE > 90" | bc -l) )); then
        send_alert "内存使用率过高: ${MEM_USAGE}%"
    fi
    
    # 检查磁盘使用率
    DISK_USAGE=$(df -h /var/lib/jenkins | awk 'NR==2 {print $5}' | cut -d'%' -f1)
    if [ "$DISK_USAGE" -gt 85 ]; then
        send_alert "磁盘使用率过高: ${DISK_USAGE}%"
    fi
}

# 5. 检查Agent连接状态
check_agents() {
    OFFLINE_AGENTS=$(curl -s "$JENKINS_URL/computer/api/json" | \
        jq -r '.computer[] | select(.offline==true) | .displayName' | \
        grep -v "master" || true)
    
    if [ -n "$OFFLINE_AGENTS" ]; then
        send_alert "发现离线Agent: $OFFLINE_AGENTS"
    fi
}

# 执行所有检查
main() {
    log_message "开始健康检查"
    
    check_java_process
    check_port  
    check_http_response
    check_system_resources
    check_agents
    
    log_message "健康检查完成"
}

main
```

### 8.3 监控告警配置

**🔧 Prometheus + Grafana监控**：
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'jenkins'
    static_configs:
      - targets: ['jenkins.company.com:8080']
    metrics_path: '/prometheus'
    scrape_interval: 30s

rule_files:
  - "jenkins_alerts.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

**告警规则配置**：
```yaml
# jenkins_alerts.yml
groups:
  - name: jenkins
    rules:
      - alert: JenkinsDown
        expr: up{job="jenkins"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Jenkins实例宕机"
          description: "Jenkins实例 {{ $labels.instance }} 已宕机超过5分钟"
      
      - alert: JenkinsDiskSpaceHigh
        expr: (node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes > 0.85
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Jenkins磁盘空间不足"
          description: "磁盘使用率超过85%"
```

---

## 9. 🔧 自动故障恢复配置


### 9.1 自动恢复机制

**自动故障恢复**：当检测到故障时，系统**自动执行修复操作**，无需人工干预。

```
自动恢复流程：
故障检测 → 判断故障类型 → 执行恢复策略 → 验证恢复结果 → 记录日志
     ↓
  如果恢复失败 → 升级告警 → 人工介入
```

### 9.2 服务自动重启

**🔧 systemd自动重启配置**：
```ini
# /etc/systemd/system/jenkins.service
[Unit]
Description=Jenkins Automation Server
Documentation=https://jenkins.io/doc/
After=network.target

[Service]
Type=notify
User=jenkins
Group=jenkins
ExecStart=/usr/bin/java -jar /usr/share/jenkins/jenkins.war
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process

# 自动重启配置
Restart=always
RestartSec=30
StartLimitInterval=300
StartLimitBurst=5

# 环境变量
Environment=JENKINS_HOME=/var/lib/jenkins
Environment=JAVA_OPTS=-Xmx2g

[Install]
WantedBy=multi-user.target
```

**重启策略说明**：
- **`Restart=always`**：无论什么原因退出都自动重启
- **`RestartSec=30`**：重启前等待30秒
- **`StartLimitBurst=5`**：5分钟内最多重启5次
- **`StartLimitInterval=300`**：限制时间窗口为300秒

### 9.3 智能故障恢复脚本

**🔧 综合恢复脚本**：
```bash
#!/bin/bash
# /usr/local/bin/jenkins_auto_recovery.sh

JENKINS_HOME="/var/lib/jenkins"
JENKINS_USER="jenkins"
LOG_FILE="/var/log/jenkins_recovery.log"
BACKUP_DIR="/backup/jenkins"

# 记录恢复日志
log_recovery() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 1. 检查并修复文件权限
fix_permissions() {
    log_recovery "检查文件权限"
    chown -R $JENKINS_USER:$JENKINS_USER $JENKINS_HOME
    chmod -R 755 $JENKINS_HOME
    log_recovery "文件权限修复完成"
}

# 2. 清理临时文件
cleanup_temp_files() {
    log_recovery "清理临时文件"
    find $JENKINS_HOME -name "*.tmp" -delete
    find $JENKINS_HOME -name "*.lock" -delete
    find $JENKINS_HOME/workspace -name ".git/index.lock" -delete
    log_recovery "临时文件清理完成"
}

# 3. 检查磁盘空间并清理
cleanup_disk_space() {
    DISK_USAGE=$(df -h $JENKINS_HOME | awk 'NR==2 {print $5}' | cut -d'%' -f1)
    if [ "$DISK_USAGE" -gt 85 ]; then
        log_recovery "磁盘空间不足，开始清理"
        
        # 清理旧的构建日志
        find $JENKINS_HOME/jobs/*/builds -name "log" -mtime +30 -delete
        
        # 清理workspace中的临时文件
        find $JENKINS_HOME/workspace -name "target" -type d -exec rm -rf {} + 2>/dev/null
        find $JENKINS_HOME/workspace -name "node_modules" -type d -exec rm -rf {} + 2>/dev/null
        
        log_recovery "磁盘清理完成"
    fi
}

# 4. 修复配置文件
repair_config() {
    CONFIG_FILE="$JENKINS_HOME/config.xml"
    if [ ! -f "$CONFIG_FILE" ] || ! xmllint --noout "$CONFIG_FILE" 2>/dev/null; then
        log_recovery "配置文件损坏，尝试恢复"
        
        # 从备份恢复
        LATEST_BACKUP=$(ls -t $BACKUP_DIR/jenkins_config_*.tar.gz | head -1)
        if [ -n "$LATEST_BACKUP" ]; then
            tar -xzf "$LATEST_BACKUP" -C /tmp/
            cp /tmp/var/lib/jenkins/config.xml "$CONFIG_FILE"
            fix_permissions
            log_recovery "配置文件从备份恢复"
        fi
    fi
}

# 5. 重启Jenkins服务
restart_jenkins() {
    log_recovery "重启Jenkins服务"
    systemctl stop jenkins
    sleep 10
    systemctl start jenkins
    
    # 等待服务启动
    for i in {1..30}; do
        if curl -f -s http://localhost:8080/login > /dev/null; then
            log_recovery "Jenkins服务重启成功"
            return 0
        fi
        sleep 10
    done
    
    log_recovery "Jenkins服务重启失败"
    return 1
}

# 主恢复流程
main() {
    log_recovery "=== 开始自动故障恢复 ==="
    
    # 检查Jenkins是否真的有问题
    if curl -f -s http://localhost:8080/login > /dev/null; then
        log_recovery "Jenkins运行正常，无需恢复"
        exit 0
    fi
    
    # 执行恢复步骤
    cleanup_temp_files
    fix_permissions
    cleanup_disk_space
    repair_config
    
    # 尝试重启服务
    if restart_jenkins; then
        log_recovery "=== 自动故障恢复成功 ==="
        
        # 发送成功通知
        echo "Jenkins自动故障恢复成功" | \
            mail -s "Jenkins恢复通知" admin@company.com
    else
        log_recovery "=== 自动故障恢复失败，需要人工介入 ==="
        
        # 发送失败告警
        echo "Jenkins自动故障恢复失败，请立即检查" | \
            mail -s "Jenkins恢复失败告警" admin@company.com
        exit 1
    fi
}

main
```

### 9.4 监控触发恢复

**结合监控系统触发恢复**：
```bash
# /usr/local/bin/jenkins_monitor_trigger.sh
#!/bin/bash

# 健康检查失败时自动触发恢复
if ! /usr/local/bin/jenkins_health_check.sh; then
    echo "检测到Jenkins故障，启动自动恢复"
    /usr/local/bin/jenkins_auto_recovery.sh
fi
```

**定时任务配置**：
```bash
# 每5分钟检查一次，故障时自动恢复
*/5 * * * * /usr/local/bin/jenkins_monitor_trigger.sh
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念

```
🔸 高可用本质：通过冗余设计确保服务连续性，避免单点故障
🔸 主从架构：Master负责调度管理，Agent负责执行构建任务
🔸 负载均衡：分散用户请求，需要注意会话粘性问题
🔸 故障转移：主备切换，使用虚拟IP和共享存储实现
🔸 共享存储：多实例共享数据，确保配置和历史的一致性
🔸 健康检查：多层级监控，及时发现和定位问题
🔸 自动恢复：无人值守的故障修复，提高系统可靠性
```

### 10.2 关键理解要点


**🔹 高可用不是简单的冗余**
```
正确理解：
- 需要统一的数据存储
- 需要负载均衡分发
- 需要健康检查机制
- 需要自动故障切换

避免误区：
- 仅仅部署多个实例不等于高可用
- 数据不同步会导致用户体验不一致
- 没有监控的高可用是伪高可用
```

**🔹 会话粘性的重要性**
```
为什么需要：
- Jenkins登录状态存储在服务器内存
- 构建过程中有临时状态数据
- WebSocket连接需要保持在同一实例

实现方式：
- IP哈希：简单但不够灵活
- Cookie粘性：更精确但复杂
- 共享会话：理想但实现成本高
```

**🔹 监控的层次性**
```
监控层次：
- 基础设施层：CPU、内存、磁盘、网络
- 应用层：Java进程、端口、HTTP响应
- 业务层：构建任务、Agent状态、用户体验

告警策略：
- 关键指标：立即告警
- 预警指标：提前通知
- 趋势分析：定期报告
```

### 10.3 实际应用建议


**🎯 部署规模建议**
```
小团队 (< 50人)：
- 主备模式：2台服务器
- 简单NFS共享存储
- 基础监控告警

中等团队 (50-200人)：
- 负载均衡 + 3个实例
- 高性能共享存储
- 完整监控体系

大型团队 (> 200人)：
- 多数据中心部署
- 专业存储解决方案
- 7×24小时监控运维
```

**🔧 运维最佳实践**
```
日常维护：
- 定期备份配置和数据
- 监控磁盘空间使用
- 更新插件和系统补丁
- 清理构建历史和日志

故障预防：
- 设置合理的资源告警阈值
- 定期演练故障切换流程
- 保持备份的有效性验证
- 文档化运维操作流程

性能优化：
- 根据负载调整JVM参数
- 优化网络和存储配置
- 合理分配Agent资源
- 定期分析性能瓶颈
```

**核心记忆**：
- 高可用 = 冗余 + 监控 + 自动化
- 主从分离，负载均衡，故障切换
- 共享存储保数据，健康检查防故障
- 自动恢复减运维，监控告警全覆盖