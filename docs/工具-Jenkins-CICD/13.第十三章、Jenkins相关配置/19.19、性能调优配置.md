---
title: 19、性能调优配置
---
## 📚 目录

1. [Jenkins性能调优概述](#1-Jenkins性能调优概述)
2. [JVM性能参数调优](#2-JVM性能参数调优)
3. [内存使用优化配置](#3-内存使用优化配置)
4. [垃圾回收优化设置](#4-垃圾回收优化设置)
5. [线程池配置参数](#5-线程池配置参数)
6. [数据库连接池配置](#6-数据库连接池配置)
7. [缓存配置优化](#7-缓存配置优化)
8. [网络超时配置](#8-网络超时配置)
9. [并发限制配置](#9-并发限制配置)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🚀 Jenkins性能调优概述


### 1.1 什么是Jenkins性能调优


**通俗理解**：就像给汽车做保养调校一样，Jenkins性能调优就是对Jenkins服务器进行各种设置调整，让它跑得更快、更稳定、更省资源。

```
未调优的Jenkins：          调优后的Jenkins：
🐌 构建慢，经常卡住          🚀 构建快速，运行流畅
💾 内存占用高，容易崩溃       📊 内存使用合理，稳定运行
⏱️ 响应慢，用户体验差        ⚡ 响应迅速，体验良好
```

### 1.2 为什么需要性能调优


**现实场景**：
- **小团队初期**：几个人，几个项目，默认配置够用
- **团队扩大后**：几十人，几十个项目，开始变慢
- **大型团队**：上百人，上百个项目，不调优就崩溃

**调优的好处**：
```
🎯 构建速度提升 → 开发效率提高
📈 系统稳定性 → 减少停机时间  
💰 资源利用率 → 节省服务器成本
👥 用户体验 → 团队工作更顺畅
```

### 1.3 性能调优的核心思路


**三个层面的优化**：
```
硬件层面：CPU、内存、磁盘、网络
软件层面：JVM、数据库、缓存
应用层面：Jenkins配置、插件、Pipeline
```

**优化策略矩阵**：

| 优化目标 | **主要手段** | **预期效果** | **实施难度** |
|---------|------------|-------------|-------------|
| 🚀 **构建速度** | `并行构建、缓存优化` | `50-80%提升` | `中等` |
| 💾 **内存使用** | `JVM调优、清理插件` | `30-50%降低` | `简单` |
| ⚡ **响应速度** | `线程池、数据库优化` | `明显改善` | `中等` |
| 🔄 **并发能力** | `线程配置、资源限制` | `支持更多用户` | `复杂` |

---

## 2. ☕ JVM性能参数调优


### 2.1 JVM调优基础概念


**什么是JVM**：
Jenkins是用Java开发的，JVM就是Java虚拟机，负责运行Jenkins程序。调优JVM就像给汽车调校发动机一样重要。

**JVM内存结构简图**：
```
┌─────────────────────────────────────┐
│           JVM 内存空间              │
├─────────────────┬───────────────────┤
│   堆内存 (Heap)  │  非堆内存 (Non-Heap) │
│                │                   │
│  ┌─────────────┐│  ┌─────────────────┐│
│  │新生代(Young)││  │方法区(MetaSpace) ││
│  │ Eden + S0/S1││  │                 ││
│  └─────────────┘│  └─────────────────┘│
│  ┌─────────────┐│  ┌─────────────────┐│
│  │老年代(Old)  ││  │程序计数器等     ││
│  │             ││  │                 ││
│  └─────────────┘│  └─────────────────┘│
└─────────────────┴───────────────────┘
```

### 2.2 核心JVM参数配置


**基础内存参数**：

```bash
# Jenkins启动脚本中的JVM参数
export JAVA_OPTS="-Xms2g -Xmx4g -XX:NewRatio=1:3"
```

**参数详解**：
- `🔸 -Xms2g`：**初始堆内存2GB** → 启动时就分配，避免动态扩展
- `🔸 -Xmx4g`：**最大堆内存4GB** → 防止内存溢出
- `🔸 -XX:NewRatio=1:3`：**新生代与老年代比例** → 1:3比例适合大多数场景

### 2.3 实际配置示例


**小型团队配置** (10人以下)：
```bash
JAVA_OPTS="-Xms1g -Xmx2g 
           -XX:NewRatio=1:2 
           -Djava.awt.headless=true
           -Dfile.encoding=UTF-8"
```

**中型团队配置** (10-50人)：
```bash
JAVA_OPTS="-Xms2g -Xmx4g 
           -XX:NewRatio=1:3
           -XX:MaxMetaspaceSize=512m
           -Djava.awt.headless=true"
```

**大型团队配置** (50人以上)：
```bash
JAVA_OPTS="-Xms4g -Xmx8g 
           -XX:NewRatio=1:3
           -XX:MaxMetaspaceSize=1g
           -XX:+UseG1GC
           -Djava.awt.headless=true"
```

### 2.4 JVM参数配置位置


**不同系统的配置方法**：

```
Windows系统：
在 jenkins.xml 文件中修改 <arguments> 标签

Linux系统：
在 /etc/default/jenkins 文件中设置 JAVA_OPTS

Docker容器：
在启动命令中添加环境变量
docker run -e JAVA_OPTS="-Xms2g -Xmx4g" jenkins/jenkins
```

---

## 3. 💾 内存使用优化配置


### 3.1 内存使用监控与分析


**内存使用情况检查**：

进入Jenkins管理页面，查看内存使用状态：
```
管理Jenkins → 系统信息 → 内存使用情况
或者
管理Jenkins → 脚本命令行 → 运行内存检查脚本
```

**内存使用分析图**：
```
内存使用状态图：
┌────────────────────────────────────┐
│ 总内存: 8GB                        │
├────────────────────────────────────┤
│ ████████████████░░░░ 80% (6.4GB)   │ ← 堆内存使用
│ ██████████░░░░░░░░░░ 50% (2.0GB)   │ ← 非堆内存使用
│ ██████░░░░░░░░░░░░░░ 30% (2.4GB)   │ ← 系统可用内存
└────────────────────────────────────┘

🚨 警告：超过85%需要调优
✅ 正常：60%-80%之间
🎯 最佳：50%-70%之间
```

### 3.2 内存泄漏常见原因


**插件相关问题**：
```
常见内存泄漏源：
🔸 插件版本不兼容 → 卸载或更新插件
🔸 插件过多未使用 → 清理不必要的插件
🔸 插件配置错误 → 重新配置插件参数
🔸 日志记录过多 → 调整日志级别
```

### 3.3 内存优化实用技巧


**定期清理策略**：

| 清理内容 | **清理频率** | **操作方法** | **节省内存** |
|---------|------------|-------------|-------------|
| 🗂️ **构建历史** | `每周` | `设置保留天数限制` | `100-500MB` |
| 📝 **日志文件** | `每月` | `日志轮转配置` | `50-200MB` |
| 🔌 **无用插件** | `季度` | `插件管理界面卸载` | `20-100MB` |
| 💿 **工作空间** | `每月` | `自动清理脚本` | `200MB-2GB` |

**配置自动清理**：
```groovy
// 在Jenkins脚本命令行中运行
// 清理超过30天的构建记录
Jenkins.instance.getAllItems(Job.class).each { job ->
  if (job.builds.size() > 30) {
    job.builds[30..-1].each { build ->
      build.delete()
    }
  }
}
```

---

## 4. 🗑️ 垃圾回收优化设置


### 4.1 垃圾回收基础概念


**什么是垃圾回收**：
就像家里需要定期扔垃圾一样，JVM也需要定期清理不用的内存对象。垃圾回收器(GC)就是负责这个工作的"清洁工"。

**垃圾回收过程示意**：
```
GC工作过程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│程序运行中    │ →  │GC开始清理    │ →  │内存释放完成  │
│内存逐渐占满  │    │暂停应用程序  │    │应用程序恢复  │
└─────────────┘    └─────────────┘    └─────────────┘
      ↑                   ↓                   ↓
   正常运行            短暂卡顿            继续运行
```

### 4.2 垃圾回收器选择


**常用垃圾回收器对比**：

| GC类型 | **适用场景** | **优点** | **缺点** | **推荐度** |
|--------|------------|---------|---------|-----------|
| 🔸 **Serial GC** | `小型应用` | `简单稳定` | `单线程，慢` | `⭐⭐` |
| 🔸 **Parallel GC** | `中型应用` | `多线程，快` | `停顿时间长` | `⭐⭐⭐` |
| 🔸 **G1 GC** | `大型应用` | `低延迟` | `复杂配置` | `⭐⭐⭐⭐` |
| 🔸 **ZGC** | `超大应用` | `极低延迟` | `内存要求高` | `⭐⭐⭐` |

### 4.3 G1GC配置示例


**推荐的G1GC配置**：
```bash
# 适合大多数Jenkins环境的G1GC配置
JAVA_OPTS="-XX:+UseG1GC
           -XX:MaxGCPauseMillis=200
           -XX:G1HeapRegionSize=16m
           -XX:G1NewSizePercent=30
           -XX:G1MaxNewSizePercent=40
           -XX:+G1UseAdaptiveIHOP"
```

**参数含义解释**：
- `🎯 MaxGCPauseMillis=200`：**最大暂停时间200毫秒** → 用户几乎感觉不到卡顿
- `📦 G1HeapRegionSize=16m`：**每个内存区域16MB** → 适合Jenkins的内存使用模式
- `🆕 G1NewSizePercent=30`：**新生代占30%** → 适合频繁创建对象的场景

### 4.4 GC日志配置与分析


**开启GC日志**：
```bash
# 添加GC日志参数
JAVA_OPTS="$JAVA_OPTS 
           -Xloggc:/var/log/jenkins/gc.log
           -XX:+PrintGC
           -XX:+PrintGCDetails
           -XX:+PrintGCTimeStamps
           -XX:+UseGCLogFileRotation
           -XX:NumberOfGCLogFiles=5
           -XX:GCLogFileSize=10M"
```

**GC日志分析要点**：
```
关注指标：
🔸 GC频率 → 每分钟不超过1-2次
🔸 暂停时间 → 单次不超过200ms
🔸 内存回收率 → 每次回收50%以上
🔸 Full GC频率 → 每小时不超过1次
```

---

## 5. 🏊 线程池配置参数


### 5.1 线程池基础概念


**什么是线程池**：
就像银行的服务窗口一样，线程池就是Jenkins处理任务的"工作窗口"。窗口太少，客户排队等待；窗口太多，浪费资源。

**Jenkins线程池示意图**：
```
Jenkins任务处理流程：
┌─────────────┐   ┌─────────────────────┐   ┌─────────────┐
│  用户提交   │ → │     任务队列        │ → │  构建执行   │
│  构建任务   │   │  ┌─┐┌─┐┌─┐┌─┐     │   │   完成      │
└─────────────┘   │  └─┘└─┘└─┘└─┘     │   └─────────────┘
                  └──────────┬──────────┘
                            ↓
                  ┌─────────────────────┐
                  │     线程池          │
                  │ [线程1][线程2][线程3] │
                  │ [线程4][线程5][线程6] │
                  └─────────────────────┘
```

### 5.2 Executor数量配置


**什么是Executor**：
Executor就是Jenkins的"工作线程"，每个Executor可以同时运行一个构建任务。

**Executor数量设置原则**：

```
计算公式：
🔸 CPU密集型任务：Executor数 = CPU核心数
🔸 IO密集型任务：Executor数 = CPU核心数 × 2
🔸 混合型任务：Executor数 = CPU核心数 × 1.5

实际示例：
8核CPU服务器 → 推荐8-12个Executor
16核CPU服务器 → 推荐12-20个Executor
```

**配置路径**：
```
Jenkins管理 → 节点管理 → 主节点配置 → 执行器数量
```

### 5.3 Agent线程池优化


**Master-Agent架构优化**：

| 节点类型 | **推荐配置** | **适用场景** | **注意事项** |
|---------|------------|-------------|-------------|
| 🏠 **Master节点** | `2-4个Executor` | `管理任务，轻量构建` | `不要跑重型任务` |
| 🔨 **构建Agent** | `4-8个Executor` | `代码编译构建` | `根据CPU核心数调整` |
| 🧪 **测试Agent** | `2-6个Executor` | `自动化测试` | `考虑并发测试限制` |
| 🚀 **部署Agent** | `1-2个Executor` | `生产环境部署` | `避免并发部署冲突` |

### 5.4 线程池监控与调优


**监控关键指标**：
```
队列状态监控：
┌────────────────────────────────────┐
│ 构建队列状态                        │
├────────────────────────────────────┤
│ 等待中：██████░░░░ 6个任务          │
│ 执行中：████████░░ 8个任务          │  
│ 空闲中：██░░░░░░░░ 2个Executor      │
└────────────────────────────────────┘

🚨 警告：等待队列 > 10个任务
⚠️ 注意：等待队列 > 5个任务  
✅ 正常：等待队列 < 3个任务
```

**调优建议**：
```
🔸 队列经常满员 → 增加Executor数量
🔸 CPU使用率低 → 可能Executor过多
🔸 内存使用高 → 减少并发任务数
🔸 IO等待多 → 优化存储和网络
```

---

## 6. 🗄️ 数据库连接池配置


### 6.1 数据库连接池概念


**为什么需要连接池**：
就像共享单车一样，数据库连接池管理着一堆数据库连接，需要时借用，用完归还，避免频繁创建销毁连接的开销。

**连接池工作原理**：
```
连接池工作流程：
┌─────────────┐   ┌─────────────────────┐   ┌─────────────┐
│ Jenkins应用 │ → │      连接池          │ → │   数据库    │
│  需要查询   │   │  ┌─┐┌─┐┌─┐┌─┐      │   │   MySQL     │
└─────────────┘   │  │√││√││×││×│      │   └─────────────┘
                  │  └─┘└─┘└─┘└─┘      │
                  │ 可用 可用 占用 占用  │
                  └─────────────────────┘
```

### 6.2 Jenkins数据库配置


**默认H2数据库问题**：
Jenkins默认使用H2嵌入式数据库，小团队够用，但大团队会遇到性能瓶颈。

**数据库选择建议**：

| 团队规模 | **推荐数据库** | **原因** | **配置复杂度** |
|---------|--------------|---------|---------------|
| 🏠 **10人以下** | `H2数据库` | `简单，免维护` | `⭐` |
| 🏢 **10-50人** | `PostgreSQL` | `性能好，稳定` | `⭐⭐⭐` |
| 🏭 **50人以上** | `MySQL集群` | `高可用，可扩展` | `⭐⭐⭐⭐` |

### 6.3 MySQL连接池配置


**推荐的MySQL连接池配置**：
```xml
<!-- jenkins.xml 中的数据库配置 -->
<datasource>
  <driver>com.mysql.cj.jdbc.Driver</driver>
  <url>jdbc:mysql://localhost:3306/jenkins</url>
  <username>jenkins</username>
  <password>your_password</password>
  
  <!-- 连接池参数 -->
  <initialSize>5</initialSize>
  <maxActive>20</maxActive>
  <maxIdle>10</maxIdle>
  <minIdle>5</minIdle>
  <maxWait>30000</maxWait>
</datasource>
```

**参数详解**：
- `🔸 initialSize=5`：**启动时创建5个连接** → 避免冷启动延迟
- `🔸 maxActive=20`：**最大20个连接** → 控制数据库负载
- `🔸 maxWait=30000`：**等待30秒超时** → 避免无限等待

### 6.4 连接池监控


**监控关键指标**：
```bash
# 检查数据库连接状态
SHOW PROCESSLIST;

# 检查连接池使用情况
SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE DB = 'jenkins';
```

**性能调优建议**：
```
🔸 连接经常不够 → 增加maxActive
🔸 连接创建频繁 → 增加minIdle  
🔸 数据库负载高 → 减少maxActive
🔸 响应时间长 → 检查SQL语句优化
```

---

## 7. 🚀 缓存配置优化


### 7.1 Jenkins缓存机制


**缓存的作用**：
就像浏览器缓存网页一样，Jenkins缓存可以把经常用到的数据保存在内存中，下次直接使用，不用重新计算或查询。

**Jenkins缓存类型**：
```
Jenkins缓存层次结构：
┌─────────────────────────────────────┐
│             用户界面                 │
├─────────────────────────────────────┤
│ 📄 页面缓存 → 构建历史、项目列表     │
├─────────────────────────────────────┤  
│ 🔧 配置缓存 → 插件设置、系统配置     │
├─────────────────────────────────────┤
│ 📊 数据缓存 → 统计信息、报告数据     │
├─────────────────────────────────────┤
│ 🗂️ 工件缓存 → 构建产物、依赖包      │
└─────────────────────────────────────┘
```

### 7.2 工作空间缓存优化


**什么是工作空间**：
每个Jenkins项目都有一个工作空间(Workspace)，用来存放源代码、编译结果等文件。

**工作空间缓存策略**：

```groovy
pipeline {
    agent any
    options {
        // 保留工作空间，加速后续构建
        skipDefaultCheckout false
        // 设置构建保留策略
        buildDiscarder(logRotator(
            numToKeepStr: '10',
            daysToKeepStr: '30'
        ))
    }
    stages {
        stage('缓存依赖') {
            steps {
                // 使用缓存插件缓存Maven依赖
                cache(maxCacheSize: 250, caches: [
                    arbitraryFileCache(
                        path: '.m2/repository',
                        includes: '**/*',
                        fingerprinting: true
                    )
                ]) {
                    sh 'mvn clean compile'
                }
            }
        }
    }
}
```

### 7.3 Maven依赖缓存


**Maven本地仓库配置**：
```xml
<!-- settings.xml 配置 -->
<settings>
    <localRepository>/var/jenkins_home/.m2/repository</localRepository>
    <mirrors>
        <mirror>
            <id>aliyun</id>
            <mirrorOf>central</mirrorOf>
            <url>https://maven.aliyun.com/repository/central</url>
        </mirror>
    </mirrors>
</settings>
```

**缓存效果对比**：

| 构建阶段 | **无缓存耗时** | **有缓存耗时** | **提升效果** |
|---------|--------------|--------------|-------------|
| 🔽 **依赖下载** | `5-10分钟` | `10-30秒` | `90%+提升` |
| 🔨 **代码编译** | `2-5分钟` | `1-2分钟` | `50%提升` |
| 🧪 **单元测试** | `3-8分钟` | `2-5分钟` | `30%提升` |
| 📦 **打包部署** | `1-3分钟` | `30秒-1分钟` | `60%提升` |

### 7.4 Docker镜像缓存


**Docker构建缓存配置**：
```dockerfile
# 多阶段构建，利用Docker层缓存
FROM maven:3.8-openjdk-11 AS builder
COPY pom.xml .
# 先下载依赖，利用Docker层缓存
RUN mvn dependency:go-offline

COPY src ./src
RUN mvn package -DskipTests

FROM openjdk:11-jre-slim
COPY --from=builder target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

---

## 8. ⏰ 网络超时配置


### 8.1 网络超时问题


**常见超时场景**：
```
Jenkins网络超时场景：
┌─────────────────┐   网络请求   ┌─────────────────┐
│   Jenkins       │ ──────────→ │   Git仓库       │
│   服务器        │ ←────────── │   (GitHub等)    │
└─────────────────┘   可能超时   └─────────────────┘
        │                              ↑
        │ 构建任务                      │ 代码拉取超时
        ↓                              │
┌─────────────────┐   API调用    ┌─────────────────┐
│   构建节点      │ ──────────→ │   外部API       │
│   (Agent)       │ ←────────── │   (测试服务等)  │
└─────────────────┘   响应超时   └─────────────────┘
```

### 8.2 Git操作超时配置


**Git克隆超时设置**：
```groovy
pipeline {
    agent any
    options {
        // 设置全局超时
        timeout(time: 30, unit: 'MINUTES')
    }
    stages {
        stage('代码检出') {
            steps {
                script {
                    // 自定义Git超时设置
                    checkout([
                        $class: 'GitSCM',
                        timeout: 10, // 10分钟超时
                        userRemoteConfigs: [[
                            url: 'https://github.com/your/repo.git'
                        ]]
                    ])
                }
            }
        }
    }
}
```

### 8.3 HTTP请求超时配置


**Jenkins系统级别超时设置**：
```bash
# 在JAVA_OPTS中添加网络超时参数
JAVA_OPTS="$JAVA_OPTS 
           -Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Shanghai
           -Dhudson.model.DirectoryBrowserSupport.CSP=
           -Dhudson.remoting.ClassFilter=com.cloudbees.**
           -Djava.net.preferIPv4Stack=true
           -Dsun.net.useExclusiveBind=false
           -Dcom.sun.management.jmxremote.port=9999
           -Dhudson.DNSMultiCast.disabled=true
           
           # 网络超时设置
           -Dsun.net.client.defaultConnectTimeout=60000
           -Dsun.net.client.defaultReadTimeout=120000"
```

### 8.4 超时配置最佳实践


**分层超时策略**：

| 操作类型 | **建议超时时间** | **配置位置** | **失败处理** |
|---------|----------------|-------------|-------------|
| 🔽 **Git克隆** | `5-10分钟` | `Pipeline配置` | `重试3次` |
| 🌐 **HTTP请求** | `30-60秒` | `系统参数` | `自动重试` |
| 🔨 **构建任务** | `15-60分钟` | `项目配置` | `邮件通知` |
| 🧪 **测试执行** | `10-30分钟` | `测试配置` | `保存日志` |

**智能重试配置**：
```groovy
pipeline {
    agent any
    stages {
        stage('智能重试示例') {
            steps {
                retry(3) {
                    script {
                        try {
                            // 可能失败的网络操作
                            sh 'curl -f --max-time 30 https://api.example.com'
                        } catch (Exception e) {
                            echo "重试中，错误: ${e.getMessage()}"
                            sleep(time: 10, unit: 'SECONDS') // 等待10秒后重试
                            throw e
                        }
                    }
                }
            }
        }
    }
}
```

---

## 9. 🚦 并发限制配置


### 9.1 并发控制的重要性


**为什么需要并发控制**：
就像控制车流量避免交通堵塞一样，Jenkins也需要控制并发任务数量，避免系统过载。

**并发问题示意图**：
```
无并发控制的问题：
┌─────────────────────────────────────┐
│ 同时运行20个构建任务                 │
├─────────────────────────────────────┤
│ CPU: ████████████████████████ 100%  │ ← 系统卡死
│ 内存: ███████████████████████ 95%   │ ← 内存不足  
│ 磁盘: ██████████████████████ 90%    │ ← IO瓶颈
└─────────────────────────────────────┘

有并发控制的效果：
┌─────────────────────────────────────┐
│ 同时运行8个构建任务                  │
├─────────────────────────────────────┤
│ CPU: ████████████░░░░░░░░░░░ 60%    │ ← 资源合理
│ 内存: ██████████░░░░░░░░░░░░ 50%    │ ← 运行稳定
│ 磁盘: ████████░░░░░░░░░░░░░░ 40%    │ ← 响应快速  
└─────────────────────────────────────┘
```

### 9.2 全局并发限制


**系统级别并发控制**：
```
Jenkins管理 → 系统配置 → 执行器数量设置

推荐配置：
🔸 Master节点：2-4个执行器
🔸 Agent节点：根据CPU核心数设置
🔸 总并发数：不超过 CPU核心数 × 1.5
```

### 9.3 项目级别并发控制


**Pipeline并发控制**：
```groovy
pipeline {
    agent any
    options {
        // 禁止同一项目并发构建
        disableConcurrentBuilds()
        
        // 或者使用资源锁定
        lock(resource: 'deployment-server')
    }
    stages {
        stage('构建') {
            steps {
                echo '开始构建...'
            }
        }
        stage('部署') {
            steps {
                // 使用资源锁定，避免并发部署
                lock('production-deployment') {
                    echo '部署到生产环境...'
                    sh 'deploy.sh'
                }
            }
        }
    }
}
```

### 9.4 资源锁定插件配置


**Lockable Resources插件使用**：

```groovy
// 配置可锁定资源
pipeline {
    agent any
    stages {
        stage('并发控制示例') {
            steps {
                script {
                    // 锁定特定资源
                    lock(label: 'database-server', quantity: 1) {
                        echo '独占访问数据库服务器'
                        sh 'run-database-migration.sh'
                    }
                    
                    // 锁定多个资源
                    lock(label: 'test-environment', quantity: 2) {
                        parallel {
                            '测试环境1': {
                                sh 'run-tests-env1.sh'
                            }
                            '测试环境2': {
                                sh 'run-tests-env2.sh'
                            }
                        }
                    }
                }
            }
        }
    }
}
```

### 9.5 并发监控与调优


**并发情况监控**：

```bash
# 监控Jenkins负载的脚本
#!/bin/bash
echo "=== Jenkins并发监控 ==="
echo "当前时间: $(date)"
echo "运行中的构建:"

# 检查正在运行的Jenkins进程
ps aux | grep jenkins | grep -v grep

# 检查系统负载
echo "系统负载: $(uptime)"

# 检查内存使用
echo "内存使用: $(free -h)"

# 检查磁盘IO
echo "磁盘IO: $(iostat -x 1 1)"
```

**并发调优建议**：

| 监控指标 | **正常范围** | **异常表现** | **调优建议** |
|---------|-------------|-------------|-------------|
| 🖥️ **CPU使用率** | `60-80%` | `持续>90%` | `减少并发数` |
| 💾 **内存使用率** | `50-70%` | `持续>85%` | `增加内存或减少并发` |
| 💿 **磁盘IO等待** | `<20%` | `持续>50%` | `优化存储或限制IO密集任务` |
| 🌐 **网络延迟** | `<100ms` | `>500ms` | `检查网络配置` |

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🎯 性能调优本质：让Jenkins跑得更快、更稳定、更省资源
🔧 JVM调优：内存设置、垃圾回收器选择是基础
💾 内存优化：定期清理、合理配置、监控使用情况  
🏊 线程池：根据硬件配置和任务特点设置Executor数量
🗄️ 数据库：大团队需要考虑从H2迁移到MySQL/PostgreSQL
🚀 缓存策略：工作空间、依赖包、Docker镜像缓存
⏰ 超时配置：网络不稳定环境下的必要保护措施
🚦 并发控制：避免系统过载的重要手段
```

### 10.2 关键配置建议


**小团队配置** (10人以下)：
```
✅ JVM: -Xms1g -Xmx2g
✅ Executor: 4-6个
✅ 数据库: H2默认
✅ 并发: 不超过4个
✅ 缓存: 基础工作空间保留
```

**中型团队配置** (10-50人)：
```
✅ JVM: -Xms2g -Xmx4g + G1GC
✅ Executor: 8-12个
✅ 数据库: PostgreSQL + 连接池
✅ 并发: 不超过8个
✅ 缓存: Maven + Docker缓存
```

**大型团队配置** (50人以上)：
```
✅ JVM: -Xms4g -Xmx8g + G1GC调优
✅ Executor: 主从分布式架构
✅ 数据库: MySQL集群
✅ 并发: 资源锁定 + 智能调度
✅ 缓存: 全方位缓存策略
```

### 10.3 性能调优最佳实践


**🔸 循序渐进原则**
```
第一步：基础JVM参数调优 → 立竿见影的效果
第二步：线程池和并发优化 → 提升系统吞吐量
第三步：缓存和数据库优化 → 进一步提升性能
第四步：监控和自动化调优 → 持续优化
```

**🔸 监控驱动调优**
```
📊 建立监控体系 → 了解系统瓶颈
📈 收集性能数据 → 分析优化方向  
🎯 针对性调优 → 解决具体问题
🔄 持续监控验证 → 确保优化效果
```

### 10.4 常见问题与解决方案


**🚨 构建慢、经常超时**
```
🔍 检查：JVM内存设置、网络配置
🔧 解决：增加内存、设置合理超时、优化网络
```

**🚨 系统经常卡死、重启**  
```
🔍 检查：并发数设置、内存泄漏、GC配置
🔧 解决：限制并发、清理插件、调优GC参数
```

**🚨 资源使用率低、响应慢**
```
🔍 检查：线程池配置、数据库连接、缓存策略
🔧 解决：调整Executor数量、优化数据库、启用缓存
```

### 10.5 学习建议


**🎯 新手学习路径**
```
1️⃣ 先理解基本概念 → JVM、线程池、并发等
2️⃣ 从简单配置开始 → JVM内存参数调优
3️⃣ 逐步增加复杂度 → 数据库、缓存、监控
4️⃣ 实践验证效果 → 对比调优前后的性能
```

**💡 实践建议**
```
🔸 小步快跑：一次只调一个参数，观察效果
🔸 做好备份：调优前备份配置文件
🔸 性能测试：用实际工作负载测试效果
🔸 文档记录：记录每次调优的参数和效果
```

**核心记忆口诀**：
```
Jenkins调优有门道，内存线程要设好
缓存数据库连接池，超时并发别忘了  
监控数据指方向，循序渐进效果佳
小步快跑做测试，稳定性能双提升
```