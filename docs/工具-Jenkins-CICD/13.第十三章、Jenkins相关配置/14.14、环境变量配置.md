---
title: 14、环境变量配置
---
## 📚 目录

1. [环境变量基础概念](#1-环境变量基础概念)
2. [全局环境变量设置](#2-全局环境变量设置)
3. [节点特定环境变量](#3-节点特定环境变量)
4. [任务级环境变量配置](#4-任务级环境变量配置)
5. [动态环境变量生成](#5-动态环境变量生成)
6. [环境变量注入配置](#6-环境变量注入配置)
7. [敏感信息环境变量](#7-敏感信息环境变量)
8. [环境变量优先级与作用域](#8-环境变量优先级与作用域)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 环境变量基础概念


### 1.1 什么是环境变量


**通俗理解**：
环境变量就像是一本通讯录，存储着程序运行时需要的各种信息。想象一下，你的手机里存着朋友的电话号码，程序也需要存储一些"联系方式"——比如数据库地址、API密钥等。

```
生活中的例子：
你的家庭地址 = HOME=/Users/张三
你的工作地点 = WORKPLACE=/公司/开发部
你的银行卡号 = BANK_ACCOUNT=****（敏感信息）

程序中的例子：
数据库地址 = DATABASE_URL=mysql://localhost:3306
API端点 = API_ENDPOINT=https://api.example.com
版本信息 = APP_VERSION=1.2.3
```

### 1.2 为什么需要环境变量


**核心价值**：
- **配置分离**：代码和配置信息分开，代码更干净
- **环境适配**：开发环境和生产环境用不同配置
- **安全保护**：敏感信息不直接写在代码里
- **灵活部署**：同一套代码在不同环境运行

**实际场景对比**：
```
❌ 不好的做法：
代码里写死：String dbUrl = "mysql://prod-server:3306";
问题：换环境要改代码，密码暴露

✅ 好的做法：
代码里读取：String dbUrl = System.getenv("DATABASE_URL");
配置：在Jenkins中设置 DATABASE_URL=mysql://prod-server:3306
优势：换环境只改配置，代码不动
```

### 1.3 Jenkins中环境变量的特点


**Jenkins环境变量的独特之处**：
```
普通程序：环境变量存在操作系统中
Jenkins：环境变量分多个层次
├── 系统级：整个Jenkins服务器
├── 节点级：特定构建机器
├── 任务级：单个Job
└── 构建级：单次构建
```

---

## 2. ⚙️ 全局环境变量设置


### 2.1 全局环境变量概念


**通俗解释**：
全局环境变量就像公司的总机电话，所有部门都能用。在Jenkins中，全局环境变量对所有任务、所有节点都生效。

### 2.2 设置全局环境变量


**操作步骤**：
1. 进入Jenkins主页
2. 点击 **"Manage Jenkins"** （管理Jenkins）
3. 选择 **"Configure System"** （系统配置）
4. 找到 **"Global Properties"** 部分
5. 勾选 **"Environment Variables"**
6. 添加变量

**配置示例**：
```
变量名：COMPANY_NAME
变量值：我的公司

变量名：DEFAULT_BRANCH  
变量值：master

变量名：NOTIFICATION_EMAIL
变量值：admin@company.com
```

### 2.3 全局变量的使用场景


**适合的场景**：
- **公司信息**：公司名称、联系方式等
- **通用配置**：默认分支、通用路径等
- **共享资源**：共享存储路径、公共API地址

**使用示例**：
```bash
# 在构建脚本中使用
echo "构建公司：$COMPANY_NAME"
echo "使用分支：$DEFAULT_BRANCH"

# 在Pipeline中使用
pipeline {
    agent any
    stages {
        stage('Info') {
            steps {
                echo "公司：${COMPANY_NAME}"
                echo "邮箱：${NOTIFICATION_EMAIL}"
            }
        }
    }
}
```

### 2.4 全局变量管理技巧


**最佳实践**：
```
命名规范：
✅ 好的命名：COMPANY_NAME, DEFAULT_BRANCH
❌ 不好的命名：name, branch, x

分类建议：
📁 基础信息：COMPANY_*, ORG_*
📁 通用配置：DEFAULT_*, GLOBAL_*
📁 资源路径：SHARE_*, COMMON_*
```

**注意事项**：
- 全局变量影响所有任务，修改需谨慎
- 敏感信息不建议设为全局变量
- 变量名要清晰，避免冲突

---

## 3. 🖥️ 节点特定环境变量


### 3.1 节点环境变量概念


**通俗理解**：
节点环境变量就像每个办公室的专属工具。比如开发部有开发工具，测试部有测试工具，每个节点（构建机器）也有自己专属的配置。

```
办公室类比：
开发办公室：有开发服务器、代码库访问权限
测试办公室：有测试环境、测试数据库
生产办公室：有生产服务器、监控系统

Jenkins节点：
开发节点：JAVA_HOME=/opt/java8, MAVEN_HOME=/opt/maven
测试节点：SELENIUM_HOME=/opt/selenium, TEST_DB=test-db
生产节点：PROD_CONFIG=/etc/prod, MONITORING=enabled
```

### 3.2 配置节点环境变量


**操作步骤**：
1. 进入 **"Manage Jenkins"** → **"Manage Nodes and Clouds"**
2. 选择要配置的节点
3. 点击 **"Configure"** （配置）
4. 找到 **"Node Properties"** 部分
5. 添加 **"Environment Variables"**
6. 设置变量

**配置示例**：
```
Linux构建节点：
SHELL_TYPE=bash
BUILD_TOOLS=/usr/local/bin
TEMP_DIR=/tmp/jenkins-builds

Windows构建节点：  
SHELL_TYPE=cmd
BUILD_TOOLS=C:\BuildTools
TEMP_DIR=C:\Temp\jenkins-builds

Docker构建节点：
DOCKER_HOST=unix:///var/run/docker.sock
REGISTRY_URL=registry.company.com
```

### 3.3 节点变量的典型应用


| **场景分类** | **变量示例** | **用途说明** |
|-------------|-------------|-------------|
| 🔧 **工具路径** | `JAVA_HOME`, `MAVEN_HOME` | 指定各种开发工具的安装位置 |
| 🗂️ **工作目录** | `WORKSPACE_ROOT`, `TEMP_DIR` | 定义构建工作的目录结构 |
| 🌍 **环境标识** | `ENV_TYPE=dev/test/prod` | 标识当前节点的环境类型 |
| 🔌 **连接配置** | `DB_HOST`, `API_ENDPOINT` | 连接到对应环境的服务 |

### 3.4 节点变量管理策略


**分环境管理**：
```
开发节点组：
├── dev-node-01: ENV=development, DB=dev-db
├── dev-node-02: ENV=development, DB=dev-db  
└── 共同特点：快速构建，详细日志

测试节点组：
├── test-node-01: ENV=testing, DB=test-db
├── test-node-02: ENV=testing, DB=test-db
└── 共同特点：完整测试，性能监控

生产节点组：
├── prod-node-01: ENV=production, DB=prod-db
└── 共同特点：严格权限，监控告警
```

---

## 4. 📋 任务级环境变量配置


### 4.1 任务环境变量概念


**通俗理解**：
任务环境变量就像每个项目的专属工具箱。同一个人（节点）可以做不同的项目，每个项目需要不同的工具和配置。

### 4.2 Freestyle项目环境变量


**配置方式**：
1. 进入具体Job配置页面
2. 找到 **"Build Environment"** 部分
3. 勾选 **"Set environment variables"**
4. 添加变量

**实用配置示例**：
```
前端项目：
NODE_VERSION=16.14.0
BUILD_ENV=production
OUTPUT_DIR=dist
CDN_URL=https://cdn.company.com

后端项目：
JAVA_OPTS=-Xmx2g -Xms1g
SPRING_PROFILES=prod
DB_POOL_SIZE=20
LOG_LEVEL=info

移动端项目：
ANDROID_SDK=/opt/android-sdk
BUILD_TYPE=release
SIGN_KEY_PATH=/keys/release.keystore
```

### 4.3 Pipeline项目环境变量


**Pipeline语法**：
```groovy
pipeline {
    agent any
    
    // 方式1：environment块（推荐）
    environment {
        APP_NAME = 'my-application'
        VERSION = '1.0.0'
        BUILD_NUMBER = "${BUILD_NUMBER}"
        DEPLOY_ENV = 'production'
    }
    
    stages {
        stage('Build') {
            // 方式2：stage级别环境变量
            environment {
                COMPILE_FLAGS = '-O2 -Wall'
            }
            steps {
                echo "构建应用：${APP_NAME} 版本：${VERSION}"
                echo "编译参数：${COMPILE_FLAGS}"
            }
        }
        
        stage('Deploy') {
            steps {
                // 方式3：步骤中设置
                script {
                    env.DEPLOY_TIME = new Date().format('yyyy-MM-dd HH:mm:ss')
                }
                echo "部署时间：${DEPLOY_TIME}"
            }
        }
    }
}
```

### 4.4 任务变量的实际应用


**版本管理场景**：
```groovy
environment {
    // 基础信息
    APP_NAME = 'user-service'
    
    // 版本控制
    MAJOR_VERSION = '2'
    MINOR_VERSION = '1'
    PATCH_VERSION = '0'
    FULL_VERSION = "${MAJOR_VERSION}.${MINOR_VERSION}.${PATCH_VERSION}"
    
    // 构建信息
    BUILD_TAG = "${FULL_VERSION}-${BUILD_NUMBER}"
    DOCKER_TAG = "${APP_NAME}:${BUILD_TAG}"
}
```

**多环境部署场景**：
```groovy
pipeline {
    agent any
    
    parameters {
        choice(name: 'DEPLOY_ENV', 
               choices: ['dev', 'test', 'prod'], 
               description: '选择部署环境')
    }
    
    environment {
        // 根据参数设置环境变量
        CONFIG_FILE = credentials("config-${params.DEPLOY_ENV}")
        DB_URL = "${params.DEPLOY_ENV == 'prod' ? 'prod-db.company.com' : 'test-db.company.com'}"
    }
    
    stages {
        stage('Deploy') {
            steps {
                echo "部署到：${params.DEPLOY_ENV}"
                echo "数据库：${DB_URL}"
                echo "配置文件：${CONFIG_FILE}"
            }
        }
    }
}
```

---

## 5. 🔄 动态环境变量生成


### 5.1 动态变量概念


**通俗理解**：
动态环境变量就像临时便签，在构建过程中根据情况临时生成。比如根据Git分支决定部署环境，根据时间戳生成唯一标识。

### 5.2 常见动态变量生成


**时间戳相关**：
```groovy
pipeline {
    agent any
    
    stages {
        stage('Generate Variables') {
            steps {
                script {
                    // 生成时间戳
                    env.BUILD_TIMESTAMP = new Date().format('yyyyMMdd-HHmmss')
                    env.BUILD_DATE = new Date().format('yyyy-MM-dd')
                    env.BUILD_TIME = new Date().format('HH:mm:ss')
                    
                    // 生成唯一ID
                    env.UNIQUE_ID = UUID.randomUUID().toString().substring(0, 8)
                    env.BUILD_ID = "${env.BUILD_DATE}-${env.UNIQUE_ID}"
                }
                
                echo "构建时间戳：${BUILD_TIMESTAMP}"
                echo "构建ID：${BUILD_ID}"
            }
        }
    }
}
```

**Git信息动态获取**：
```groovy
script {
    // 获取Git信息
    env.GIT_BRANCH = sh(returnStdout: true, script: 'git rev-parse --abbrev-ref HEAD').trim()
    env.GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
    env.GIT_SHORT_COMMIT = env.GIT_COMMIT.substring(0, 7)
    
    // 根据分支决定环境
    if (env.GIT_BRANCH == 'master') {
        env.DEPLOY_ENV = 'production'
        env.DB_CONFIG = 'prod-config'
    } else if (env.GIT_BRANCH == 'develop') {
        env.DEPLOY_ENV = 'development'  
        env.DB_CONFIG = 'dev-config'
    } else {
        env.DEPLOY_ENV = 'feature'
        env.DB_CONFIG = 'test-config'
    }
}
```

### 5.3 条件化变量设置


**智能环境判断**：
```groovy
pipeline {
    agent any
    
    stages {
        stage('Smart Config') {
            steps {
                script {
                    // 判断是否为工作日
                    def calendar = Calendar.getInstance()
                    def dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK)
                    env.IS_WEEKDAY = (dayOfWeek >= Calendar.MONDAY && dayOfWeek <= Calendar.FRIDAY).toString()
                    
                    // 根据构建触发方式设置
                    if (currentBuild.getBuildCauses('hudson.triggers.TimerTrigger$TimerTriggerCause')) {
                        env.BUILD_TYPE = 'scheduled'
                        env.NOTIFICATION_LEVEL = 'low'
                    } else if (currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')) {
                        env.BUILD_TYPE = 'manual'
                        env.NOTIFICATION_LEVEL = 'high'
                    } else {
                        env.BUILD_TYPE = 'triggered'
                        env.NOTIFICATION_LEVEL = 'medium'
                    }
                    
                    // 设置构建策略
                    if (env.IS_WEEKDAY == 'true' && env.BUILD_TYPE == 'scheduled') {
                        env.RUN_TESTS = 'full'
                        env.DEPLOY_ENABLED = 'true'
                    } else {
                        env.RUN_TESTS = 'basic'
                        env.DEPLOY_ENABLED = 'false'
                    }
                }
                
                echo "构建类型：${BUILD_TYPE}"
                echo "测试级别：${RUN_TESTS}"
                echo "是否部署：${DEPLOY_ENABLED}"
            }
        }
    }
}
```

### 5.4 动态变量的高级应用


**版本号自动递增**：
```groovy
script {
    // 读取当前版本
    def currentVersion = readFile('version.txt').trim()
    def versionParts = currentVersion.split('\\.')
    
    // 自动递增
    def major = versionParts[0] as Integer
    def minor = versionParts[1] as Integer  
    def patch = versionParts[2] as Integer
    
    // 根据分支决定递增策略
    if (env.GIT_BRANCH == 'master') {
        minor++  // 主分支递增次版本号
        patch = 0
    } else {
        patch++  // 其他分支递增补丁版本号
    }
    
    env.NEW_VERSION = "${major}.${minor}.${patch}"
    env.DOCKER_TAG = "myapp:${NEW_VERSION}"
    
    // 写回文件
    writeFile file: 'version.txt', text: env.NEW_VERSION
}
```

---

## 6. 💉 环境变量注入配置


### 6.1 环境变量注入概念


**通俗理解**：
环境变量注入就像给程序"打针"，把外部的配置信息注入到构建过程中。Jenkins提供了多种"注射器"来完成这个工作。

### 6.2 EnvInject插件使用


**插件安装**：
1. **"Manage Jenkins"** → **"Manage Plugins"**
2. 搜索 **"Environment Injector"**
3. 安装并重启Jenkins

**基本注入配置**：
```
Properties Content（属性内容）：
APP_NAME=user-service
VERSION=2.1.0
BUILD_ENV=production
DATABASE_URL=mysql://prod-db:3306/userdb

Properties File Path（属性文件路径）：
./config/build.properties
```

**属性文件示例** (`config/build.properties`)：
```properties
# 应用基本信息
app.name=user-service
app.version=2.1.0
app.description=用户管理服务

# 环境配置
env.type=production
env.database.host=prod-db.company.com
env.database.port=3306
env.database.name=userdb

# 构建配置
build.java.version=11
build.maven.profile=prod
build.skip.tests=false

# 部署配置
deploy.target.host=prod-server-01
deploy.target.port=8080
deploy.health.check.url=/health
```

### 6.3 高级注入技巧


**条件注入**：
```groovy
pipeline {
    agent any
    
    stages {
        stage('Inject Variables') {
            steps {
                script {
                    // 根据分支注入不同配置
                    if (env.BRANCH_NAME == 'master') {
                        // 生产环境配置注入
                        def props = [
                            'ENV_TYPE=production',
                            'DB_HOST=prod-db.company.com',
                            'CACHE_SIZE=1024',
                            'LOG_LEVEL=warn'
                        ]
                        props.each { prop ->
                            def (key, value) = prop.split('=')
                            env."${key}" = value
                        }
                    } else if (env.BRANCH_NAME == 'develop') {
                        // 开发环境配置注入
                        def props = [
                            'ENV_TYPE=development',
                            'DB_HOST=dev-db.company.com', 
                            'CACHE_SIZE=256',
                            'LOG_LEVEL=debug'
                        ]
                        props.each { prop ->
                            def (key, value) = prop.split('=')
                            env."${key}" = value
                        }
                    }
                }
                
                echo "环境类型：${ENV_TYPE}"
                echo "数据库：${DB_HOST}"
                echo "缓存大小：${CACHE_SIZE}"
            }
        }
    }
}
```

**外部文件注入**：
```groovy
stage('Load Config') {
    steps {
        script {
            // 从外部API获取配置
            def configUrl = "http://config-server/api/config/${env.BRANCH_NAME}"
            def response = httpRequest configUrl
            def config = readJSON text: response.content
            
            // 注入到环境变量
            config.each { key, value ->
                env."CONFIG_${key.toUpperCase()}" = value.toString()
            }
            
            // 从数据库获取配置（示例）
            def dbConfig = sh(
                returnStdout: true,
                script: "mysql -h config-db -e 'SELECT key_name, value FROM config WHERE env=\"${env.BRANCH_NAME}\"'"
            ).trim()
            
            // 解析并注入
            dbConfig.split('\n').each { line ->
                if (line.contains('\t')) {
                    def (key, value) = line.split('\t')
                    env."DB_${key.toUpperCase()}" = value
                }
            }
        }
    }
}
```

### 6.4 注入时机控制


**构建阶段注入时机**：
```
┌─────────────────┐
│   构建开始       │
├─────────────────┤
│ 1.全局变量加载   │ ← 系统级、节点级变量
├─────────────────┤
│ 2.任务变量设置   │ ← Job配置的environment块
├─────────────────┤  
│ 3.参数变量注入   │ ← 构建参数、用户输入
├─────────────────┤
│ 4.动态变量生成   │ ← 脚本生成、条件判断
├─────────────────┤
│ 5.外部配置注入   │ ← 文件、API、数据库
├─────────────────┤
│   开始构建       │
└─────────────────┘
```

---

## 7. 🔒 敏感信息环境变量


### 7.1 敏感信息处理原则


**通俗理解**：
敏感信息就像银行卡密码，不能随便给别人看。Jenkins提供了专门的"保险箱"来存储这些重要信息。

**敏感信息分类**：
```
🔐 认证信息：
├── 数据库密码
├── API密钥
├── 服务账号
└── 访问令牌

🔐 配置信息：
├── 生产环境配置
├── 第三方服务配置  
├── 证书和密钥文件
└── 加密参数

🔐 业务信息：
├── 客户数据连接
├── 商业机密配置
├── 内部服务地址
└── 监控告警配置
```

### 7.2 Jenkins Credentials系统


**创建凭据**：
1. **"Manage Jenkins"** → **"Manage Credentials"**
2. 选择适当的域（通常是Global）
3. 点击 **"Add Credentials"**
4. 选择凭据类型

**凭据类型选择**：
```
📝 Username with password：
用途：数据库连接、服务账号
示例：DB_USER + DB_PASSWORD

🗝️ Secret text：
用途：API密钥、访问令牌
示例：API_KEY, ACCESS_TOKEN

📄 Secret file：
用途：证书文件、配置文件
示例：SSL证书、密钥文件

🔗 SSH Username with private key：
用途：Git仓库访问、服务器连接
示例：Git拉取、远程部署
```

### 7.3 Pipeline中使用凭据


**基本使用方法**：
```groovy
pipeline {
    agent any
    
    environment {
        // 使用凭据ID获取敏感信息
        DB_CREDENTIALS = credentials('database-credentials')
        API_KEY = credentials('third-party-api-key')
        CONFIG_FILE = credentials('production-config')
    }
    
    stages {
        stage('Database Connection') {
            steps {
                script {
                    // 用户名密码类型凭据
                    // Jenkins自动创建 DB_CREDENTIALS_USR 和 DB_CREDENTIALS_PSW
                    echo "连接用户：${DB_CREDENTIALS_USR}"
                    // 密码不会在日志中显示，被自动隐藏
                    
                    // 使用凭据连接数据库
                    sh """
                        mysql -h prod-db.company.com \
                              -u ${DB_CREDENTIALS_USR} \
                              -p${DB_CREDENTIALS_PSW} \
                              -e "SELECT COUNT(*) FROM users;"
                    """
                }
            }
        }
        
        stage('API Call') {
            steps {
                script {
                    // Secret text类型凭据
                    sh """
                        curl -H "Authorization: Bearer ${API_KEY}" \
                             https://api.third-party.com/data
                    """
                }
            }
        }
        
        stage('Deploy with Config') {
            steps {
                script {
                    // Secret file类型凭据
                    // Jenkins会将文件内容保存到临时位置
                    sh """
                        # 复制配置文件到应用目录
                        cp ${CONFIG_FILE} ./app/config/production.yml
                        
                        # 启动应用
                        ./deploy.sh --config ./app/config/production.yml
                    """
                }
            }
        }
    }
}
```

### 7.4 凭据使用最佳实践


**命名规范**：
```
推荐命名格式：
✅ database-prod-credentials
✅ api-key-third-party-service
✅ ssh-key-production-server
✅ config-file-prod-environment

不推荐命名：
❌ db-pass
❌ key1
❌ secret
❌ config
```

**权限控制**：
```
凭据使用权限分级：
┌─────────────────┐
│   管理员级       │ ← 可以查看、修改所有凭据
├─────────────────┤
│   项目管理级     │ ← 可以在特定项目中使用凭据
├─────────────────┤  
│   开发者级       │ ← 只能在授权项目中使用
├─────────────────┤
│   构建级         │ ← 只能在构建过程中自动使用
└─────────────────┘
```

### 7.5 敏感信息保护技巧


**日志保护**：
```groovy
pipeline {
    agent any
    
    stages {
        stage('Secure Processing') {
            steps {
                script {
                    // 使用wrap块保护敏感输出
                    wrap([$class: 'MaskPasswordsBuildWrapper', 
                          varPasswordPairs: [
                              [var: 'SENSITIVE_DATA', password: env.API_KEY]
                          ]]) {
                        
                        echo "处理敏感数据：${SENSITIVE_DATA}"
                        // 敏感内容会在日志中显示为 ****
                    }
                    
                    // 手动清理敏感变量
                    env.TEMP_PASSWORD = null
                    env.API_KEY = null
                }
            }
        }
    }
}
```

**环境隔离**：
```groovy
script {
    // 生产环境额外检查
    if (env.DEPLOY_ENV == 'production') {
        // 确认操作者权限
        def userInput = input(
            message: '确认部署到生产环境？',
            parameters: [
                password(defaultValue: '', 
                        description: '请输入生产环境部署密码',
                        name: 'DEPLOY_PASSWORD')
            ]
        )
        
        // 验证密码
        if (userInput != env.PRODUCTION_DEPLOY_PASSWORD) {
            error('生产环境部署密码错误')
        }
    }
}
```

---

## 8. 📊 环境变量优先级与作用域


### 8.1 优先级规则理解


**通俗比喻**：
环境变量的优先级就像穿衣服的顺序：最外层的衣服遮盖里层的。Jenkins中，最"具体"的设置会覆盖最"通用"的设置。

### 8.2 优先级层次结构


**优先级从高到低**：
```
┌─────────────────┐  优先级: ⭐⭐⭐⭐⭐
│  步骤内设置      │  影响范围: 单个步骤
├─────────────────┤
│  Stage环境变量   │  优先级: ⭐⭐⭐⭐
├─────────────────┤  影响范围: 单个阶段
│  Pipeline环境变量│  优先级: ⭐⭐⭐
├─────────────────┤  影响范围: 整个Pipeline
│  Job配置变量     │  优先级: ⭐⭐
├─────────────────┤  影响范围: 单个任务
│  节点环境变量    │  优先级: ⭐
├─────────────────┤  影响范围: 特定节点
│  全局环境变量    │  优先级: 基础
└─────────────────┘  影响范围: 整个Jenkins
```

### 8.3 优先级实例演示


**变量覆盖示例**：
```groovy
pipeline {
    agent any
    
    // Pipeline级别：优先级⭐⭐⭐
    environment {
        APP_VERSION = '2.0.0'
        LOG_LEVEL = 'info'
        DATABASE_POOL = '10'
    }
    
    stages {
        stage('Development Build') {
            // Stage级别：优先级⭐⭐⭐⭐
            environment {
                LOG_LEVEL = 'debug'     // 覆盖Pipeline级别
                DATABASE_POOL = '5'     // 覆盖Pipeline级别
                DEV_MODE = 'true'       // 新增变量
            }
            
            steps {
                echo "开发构建配置："
                echo "应用版本：${APP_VERSION}"      // 来自Pipeline级别
                echo "日志级别：${LOG_LEVEL}"       // 来自Stage级别（debug）
                echo "连接池大小：${DATABASE_POOL}"  // 来自Stage级别（5）
                echo "开发模式：${DEV_MODE}"        // 来自Stage级别
                
                script {
                    // 步骤级别：优先级⭐⭐⭐⭐⭐
                    env.LOG_LEVEL = 'trace'     // 覆盖Stage级别
                    env.TEMP_DIR = '/tmp/dev'   // 新增变量
                }
                
                echo "步骤内配置："
                echo "日志级别：${LOG_LEVEL}"       // 现在是trace
                echo "临时目录：${TEMP_DIR}"        // 新增的变量
            }
        }
        
        stage('Production Build') {
            // 新的Stage，重新应用Pipeline级别设置
            steps {
                echo "生产构建配置："
                echo "应用版本：${APP_VERSION}"      // 来自Pipeline级别
                echo "日志级别：${LOG_LEVEL}"       // 恢复到Pipeline级别（info）
                echo "连接池大小：${DATABASE_POOL}"  // 恢复到Pipeline级别（10）
                // echo "开发模式：${DEV_MODE}"     // 这里会报错，变量不存在
            }
        }
    }
}
```

### 8.4 作用域范围详解


**变量作用域图示**：
```
全局作用域：
├── 全局环境变量（所有Job可见）
└── 节点环境变量（特定节点的所有Job可见）

Job作用域：
├── Job配置变量（整个Job执行期间可见）
└── Pipeline环境变量（整个Pipeline可见）

局部作用域：
├── Stage环境变量（Stage执行期间可见）
├── 步骤内变量（单个步骤内可见）
└── 条件块变量（if/else块内可见）

时间作用域：
├── 构建期变量（构建开始到结束）
├── 会话期变量（Jenkins会话期间）
└── 持久化变量（重启后仍然存在）
```

### 8.5 作用域管理实践


**变量生命周期管理**：
```groovy
pipeline {
    agent any
    
    // 持久变量：整个Pipeline生命周期
    environment {
        BUILD_ID = "${BUILD_NUMBER}-${new Date().format('yyyyMMdd')}"
        PERSISTENT_CONFIG = 'production'
    }
    
    stages {
        stage('Initialization') {
            steps {
                script {
                    // 初始化阶段设置的变量
                    env.INIT_TIME = new Date().toString()
                    env.WORKSPACE_SETUP = 'completed'
                    
                    // 临时变量，用完即清理
                    def tempApiKey = readFile('temp-key.txt').trim()
                    env.TEMP_API_KEY = tempApiKey
                }
                
                echo "初始化完成：${INIT_TIME}"
            }
        }
        
        stage('Processing') {
            environment {
                // Stage级临时变量
                PROCESSING_MODE = 'batch'
                TEMP_OUTPUT_DIR = '/tmp/processing'
            }
            
            steps {
                echo "处理模式：${PROCESSING_MODE}"
                echo "使用临时API密钥进行处理..."
                
                script {
                    // 使用完立即清理敏感信息
                    sh "process-data.sh --api-key ${TEMP_API_KEY}"
                    env.TEMP_API_KEY = null  // 清理敏感变量
                }
            }
        }
        
        stage('Cleanup') {
            steps {
                script {
                    // 清理所有临时变量
                    env.TEMP_OUTPUT_DIR = null
                    env.PROCESSING_MODE = null
                    
                    // 保留重要信息用于后续阶段
                    env.FINAL_STATUS = 'success'
                    env.COMPLETION_TIME = new Date().toString()
                }
                
                echo "构建完成：${COMPLETION_TIME}"
                echo "最终状态：${FINAL_STATUS}"
            }
        }
    }
    
    post {
        always {
            script {
                // 在post块中，所有Pipeline变量仍然可用
                echo "构建ID：${BUILD_ID}"
                echo "初始化时间：${INIT_TIME}"
                echo "完成时间：${COMPLETION_TIME}"
                
                // 最终清理
                env.TEMP_API_KEY = null
                env.INIT_TIME = null
            }
        }
    }
}
```

### 8.6 作用域冲突解决


**变量名冲突处理**：
```groovy
pipeline {
    agent any
    
    environment {
        CONFIG_PATH = '/global/config'  // 全局配置路径
    }
    
    stages {
        stage('Local Override') {
            environment {
                CONFIG_PATH = '/local/config'  // 局部覆盖
            }
            
            steps {
                script {
                    // 方法1：明确引用不同层级的变量
                    def globalConfig = env.getProperty('CONFIG_PATH', '/global/config')
                    def localConfig = env.CONFIG_PATH  // 当前作用域的值
                    
                    echo "全局配置：${globalConfig}"
                    echo "局部配置：${localConfig}"
                    
                    // 方法2：使用不同的变量名避免冲突
                    env.GLOBAL_CONFIG_PATH = '/global/config'
                    env.LOCAL_CONFIG_PATH = '/local/config'
                    env.CURRENT_CONFIG_PATH = env.LOCAL_CONFIG_PATH
                    
                    // 方法3：条件性变量设置
                    if (env.BRANCH_NAME == 'master') {
                        env.ACTIVE_CONFIG = env.GLOBAL_CONFIG_PATH
                    } else {
                        env.ACTIVE_CONFIG = env.LOCAL_CONFIG_PATH
                    }
                }
                
                echo "激活配置：${ACTIVE_CONFIG}"
            }
        }
    }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 环境变量本质：程序运行时的配置信息载体
🔸 分层管理：全局→节点→任务→阶段→步骤的层次结构
🔸 优先级规则：越具体的设置优先级越高
🔸 敏感信息：使用Credentials系统安全管理
🔸 动态生成：根据条件和上下文自动创建变量
🔸 作用域控制：变量的可见性和生命周期管理
```

### 9.2 关键理解要点


**🔹 为什么需要环境变量**
```
配置分离：代码与配置解耦，提高灵活性
环境适配：同一代码适应不同运行环境
安全保护：敏感信息不暴露在代码中
运维便利：无需修改代码即可调整配置
```

**🔹 如何选择合适的层级**
```
全局变量：公司级别的通用信息
节点变量：特定构建环境的工具配置
任务变量：项目特定的配置信息
阶段变量：特定构建步骤的临时配置
```

**🔹 敏感信息处理原则**
```
最小权限：只给必要的权限访问敏感信息
及时清理：使用完立即清理敏感变量
权限控制：合理设置凭据的访问权限
日志保护：避免敏感信息在日志中泄露
```

### 9.3 实际应用指导


**🎯 常见应用场景**
- **多环境部署**：开发/测试/生产环境的配置切换
- **版本管理**：自动生成版本号和构建标识
- **权限控制**：不同环境的访问权限管理
- **监控集成**：构建信息的收集和上报
- **通知配置**：根据环境和结果发送通知

**🔧 配置建议**
```
命名规范：
• 使用大写字母和下划线
• 包含模块或环境前缀
• 避免使用系统保留名称

分类管理：
• 基础信息：APP_*, PROJECT_*
• 环境配置：ENV_*, DEPLOY_*
• 工具路径：TOOL_*, BIN_*
• 敏感信息：使用Credentials系统
```

**⚠️ 常见陷阱**
```
变量覆盖：注意不同层级的变量优先级
作用域混乱：明确变量的可见范围
敏感信息泄露：避免在日志中暴露密码
命名冲突：使用清晰的命名规范
```

### 9.4 进阶技巧


**🚀 高级应用**
```
动态配置：根据分支、时间、触发方式动态设置
条件注入：智能判断环境并注入相应配置
外部集成：从配置中心、数据库获取配置
版本控制：自动管理和更新版本信息
```

**📊 监控和调试**
```
变量追踪：记录变量的设置和修改历史
调试输出：在关键节点输出变量状态
权限审计：定期检查敏感信息的访问权限
性能优化：避免过多的动态变量生成
```

### 9.5 最佳实践总结


**核心原则**：
- **安全第一**：敏感信息必须使用Credentials系统
- **清晰明确**：变量命名要见名知意
- **最小权限**：只在需要的范围内设置变量
- **及时清理**：不需要的变量要及时清理

**实用技巧**：
- 建立团队的变量命名规范
- 定期清理不再使用的变量
- 文档化重要的环境变量配置
- 设置必要的权限控制和审计

**记忆口诀**：
```
环境变量层次清，全局节点到任务
敏感信息要保护，凭据系统是首选
优先级别要记牢，具体覆盖更通用
动态生成很灵活，条件判断巧应用
```