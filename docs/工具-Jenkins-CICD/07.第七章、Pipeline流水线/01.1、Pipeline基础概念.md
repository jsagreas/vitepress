---
title: 1、Pipeline基础概念
---
## 📚 目录

1. [Pipeline是什么 - 白话解释](#1-Pipeline是什么-白话解释)
2. [Pipeline的两种写法对比](#2-Pipeline的两种写法对比)
3. [Jenkinsfile文件管理](#3-Jenkinsfile文件管理)
4. [Pipeline语法基础入门](#4-Pipeline语法基础入门)
5. [Stage阶段概念详解](#5-Stage阶段概念详解)
6. [Step步骤概念详解](#6-Step步骤概念详解)
7. [实战案例演示](#7-实战案例演示)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 Pipeline是什么 - 白话解释


### 1.1 什么是Pipeline？


**用大白话说**：Pipeline就像是一条**自动化的生产流水线**，把软件从代码变成可以使用的产品。

```
就像工厂生产手机的流水线：
原材料 → 组装 → 测试 → 包装 → 出厂

软件开发的Pipeline：
源代码 → 编译 → 测试 → 打包 → 部署
```

### 1.2 为什么要用Pipeline？


> 💡 **核心优势**：把原本需要人工重复做的事情，变成自动化执行

**传统方式的痛点**：
- ❌ 开发写完代码，手动打包
- ❌ 手动上传到服务器
- ❌ 手动重启服务
- ❌ 容易出错，效率低下

**Pipeline的好处**：
- ✅ **自动化**：一键完成所有步骤
- ✅ **标准化**：每次都按相同流程执行
- ✅ **可视化**：能看到每个步骤的执行情况
- ✅ **可重复**：随时可以重新执行

### 1.3 Pipeline的核心理念


```
传统开发流程：
开发 → 手工部署 → 发现问题 → 修复 → 再次手工部署

Pipeline流程：
开发 → 提交代码 → 自动构建 → 自动测试 → 自动部署
```

**关键理解**：Pipeline就是把**手工操作**变成**自动化脚本**，让机器代替人来做重复性工作。

---

## 2. 🔄 Pipeline的两种写法对比


### 2.1 声明式Pipeline（推荐新手使用）


**特点**：结构化、易读、规范

```groovy
pipeline {
    agent any
    stages {
        stage('构建') {
            steps {
                echo '正在构建项目...'
            }
        }
        stage('测试') {
            steps {
                echo '正在运行测试...'
            }
        }
    }
}
```

**优势对比表**：

| 特性 | 声明式Pipeline | 脚本式Pipeline |
|------|---------------|---------------|
| **学习难度** | ⭐⭐ 容易 | ⭐⭐⭐⭐ 困难 |
| **语法结构** | 固定格式，规范 | 自由编写，灵活 |
| **错误提示** | 清晰明确 | 需要经验判断 |
| **适用人群** | 🔰 新手推荐 | 🔧 高级用户 |

### 2.2 脚本式Pipeline（高级用法）


**特点**：灵活、自由、需要更多编程知识

```groovy
node {
    stage('构建') {
        echo '正在构建项目...'
    }
    stage('测试') {
        echo '正在运行测试...'
    }
}
```

### 2.3 选择建议


> 🎯 **新手建议**：先学声明式Pipeline，掌握基本概念后再考虑脚本式

**选择原则**：
- 🔰 **新手入门**：声明式Pipeline
- 🔧 **复杂逻辑**：脚本式Pipeline  
- 📚 **团队协作**：声明式Pipeline（统一规范）

---

## 3. 📁 Jenkinsfile文件管理


### 3.1 什么是Jenkinsfile？


**通俗解释**：Jenkinsfile就是一个**剧本文件**，告诉Jenkins应该按什么步骤来执行任务。

```
就像做菜的菜谱：
1. 准备食材
2. 清洗切配
3. 下锅炒制
4. 装盘上菜

Jenkinsfile就是软件部署的"菜谱"
```

### 3.2 Jenkinsfile的两种管理方式


#### 🏠 方式一：存放在代码仓库中（推荐）


**优势**：
- ✅ **版本管理**：和代码一起管理，有历史记录
- ✅ **团队共享**：所有人都能看到和修改
- ✅ **分支管理**：不同分支可以有不同的Pipeline

**文件位置**：
```
项目根目录/
├── src/                 ← 源代码
├── README.md
└── Jenkinsfile         ← Pipeline脚本
```

#### 🔧 方式二：直接在Jenkins界面编写


**适用场景**：
- 🔰 **学习测试**：快速验证想法
- 🛠️ **临时任务**：一次性的简单任务

### 3.3 文件命名规范


| 文件名 | 用途说明 |
|--------|----------|
| `Jenkinsfile` | 默认主Pipeline文件 |
| `Jenkinsfile.dev` | 开发环境Pipeline |
| `Jenkinsfile.prod` | 生产环境Pipeline |

---

## 4. 📝 Pipeline语法基础入门


### 4.1 声明式Pipeline基本结构


```
Pipeline结构就像盖房子：
┌─────────────────────┐
│   pipeline { }      │ ← 房子的地基（必须有）
│  ┌─────────────────┐│
│  │   agent any     ││ ← 选择工人（在哪台机器上干活）
│  └─────────────────┘│
│  ┌─────────────────┐│
│  │   stages { }    ││ ← 施工阶段（具体要做什么）
│  └─────────────────┘│
└─────────────────────┘
```

### 4.2 核心关键词解释


**🏗️ pipeline**：
- **含义**：整个Pipeline的最外层容器
- **作用**：告诉Jenkins这是一个声明式Pipeline

**🤖 agent**：
- **含义**：指定在哪台机器上执行任务
- **常用选项**：
  - `agent any` - 任意可用的机器
  - `agent none` - 不指定，在stages中单独指定

**🏢 stages**：
- **含义**：包含所有执行阶段的容器
- **作用**：组织和管理多个stage

### 4.3 最简单的Pipeline示例


```groovy
pipeline {
    agent any           // 在任意机器上执行
    stages {           // 开始定义执行阶段
        stage('打招呼') {  // 第一个阶段：打招呼
            steps {
                echo '你好，这是我的第一个Pipeline!'
            }
        }
    }
}
```

**执行效果**：
```
运行结果：
[Pipeline] Start of Pipeline
[Pipeline] echo
你好，这是我的第一个Pipeline!
[Pipeline] End of Pipeline
```

---

## 5. 🎭 Stage阶段概念详解


### 5.1 什么是Stage？


**通俗理解**：Stage就是**工作阶段**，把一个大任务分解成若干个小阶段。

```
软件发布就像演出：
第一幕：准备道具    → stage('准备环境')
第二幕：正式演出    → stage('构建代码')  
第三幕：观众反馈    → stage('运行测试')
第四幕：谢幕收场    → stage('部署上线')
```

### 5.2 Stage的作用和好处


**🎯 主要作用**：
- **任务分解**：把复杂工作分成简单步骤
- **进度跟踪**：能看到执行到哪个阶段了
- **问题定位**：出错时能快速找到是哪个阶段有问题
- **并行执行**：某些阶段可以同时进行

### 5.3 Stage的语法结构


```groovy
stage('阶段名称') {
    steps {
        // 具体要执行的步骤
        echo '这个阶段要做的事情'
    }
}
```

### 5.4 常见的Stage划分模式


**🔄 标准软件发布流程**：

```groovy
pipeline {
    agent any
    stages {
        stage('📦 准备环境') {
            steps {
                echo '检查构建环境，安装依赖'
            }
        }
        
        stage('🔨 编译构建') {
            steps {
                echo '编译源代码，生成可执行文件'
            }
        }
        
        stage('🧪 运行测试') {
            steps {
                echo '执行单元测试，确保代码质量'
            }
        }
        
        stage('📋 代码检查') {
            steps {
                echo '检查代码规范，扫描安全漏洞'
            }
        }
        
        stage('🚀 部署发布') {
            steps {
                echo '部署到服务器，启动服务'
            }
        }
    }
}
```

### 5.5 Stage执行状态说明


| 状态图标 | 状态名称 | 含义说明 |
|---------|---------|----------|
| ✅ | **SUCCESS** | 阶段执行成功 |
| ❌ | **FAILURE** | 阶段执行失败 |
| ⏸️ | **UNSTABLE** | 执行完成但有警告 |
| ⏹️ | **ABORTED** | 手动停止或超时 |
| 🔄 | **RUNNING** | 正在执行中 |

---

## 6. 👣 Step步骤概念详解


### 6.1 什么是Step？


**形象比喻**：如果Stage是一道菜，那么Step就是做这道菜的具体动作。

```
做西红柿炒蛋这道菜(Stage)：
Step 1: 打鸡蛋
Step 2: 切西红柿  
Step 3: 热锅放油
Step 4: 炒鸡蛋
Step 5: 炒西红柿
Step 6: 调味装盘
```

### 6.2 Steps的语法结构


```groovy
stage('阶段名称') {
    steps {
        // Step 1
        echo '第一个步骤'
        
        // Step 2  
        sh 'ls -la'
        
        // Step 3
        script {
            def message = "动态生成的消息"
            echo message
        }
    }
}
```

### 6.3 常用的Step类型


#### 📢 基础输出Steps


```groovy
steps {
    echo '打印简单消息'
    
    script {
        println '打印详细信息'
        echo "当前时间: ${new Date()}"
    }
}
```

#### 🔧 Shell命令Steps


```groovy
steps {
    // Linux/Mac系统使用sh
    sh 'echo "在Linux上执行命令"'
    sh 'ls -la'
    
    // Windows系统使用bat
    bat 'echo "在Windows上执行命令"'
    bat 'dir'
}
```

#### 📁 文件操作Steps


```groovy
steps {
    // 读取文件
    script {
        def content = readFile('README.md')
        echo "文件内容: ${content}"
    }
    
    // 写入文件
    writeFile file: 'output.txt', text: '构建完成'
    
    // 检查文件是否存在
    script {
        if (fileExists('package.json')) {
            echo '这是一个Node.js项目'
        }
    }
}
```

### 6.4 Step执行的特点


**🔄 顺序执行**：
- Steps按照写的顺序**从上到下**执行
- 前一个Step失败，后面的Steps不会执行
- 所有Steps成功，整个Stage才算成功

**⚠️ 错误处理**：
```groovy
steps {
    echo '开始执行'
    
    // 即使这个命令失败，也继续执行后面的步骤
    script {
        try {
            sh 'exit 1'  // 故意失败的命令
        } catch (Exception e) {
            echo "命令失败了，但我们继续: ${e.getMessage()}"
        }
    }
    
    echo '继续执行后面的步骤'
}
```

---

## 7. 🚀 实战案例演示


### 7.1 案例背景介绍


**场景描述**：为一个简单的Web项目创建CI/CD Pipeline

**项目结构**：
```
my-web-project/
├── src/
│   └── index.html
├── package.json
├── Jenkinsfile
└── README.md
```

### 7.2 完整Pipeline实战代码


```groovy
pipeline {
    agent any
    
    // 定义环境变量
    environment {
        PROJECT_NAME = 'my-web-project'
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
    }
    
    stages {
        stage('🔍 环境检查') {
            steps {
                echo "开始构建项目: ${PROJECT_NAME}"
                echo "构建编号: ${BUILD_NUMBER}"
                
                // 检查Node.js环境
                sh 'node --version'
                sh 'npm --version'
            }
        }
        
        stage('📦 安装依赖') {
            steps {
                echo '正在安装项目依赖...'
                sh 'npm install'
                echo '依赖安装完成!'
            }
        }
        
        stage('🔨 构建项目') {
            steps {
                echo '开始构建项目...'
                sh 'npm run build'
                
                // 检查构建结果
                script {
                    if (fileExists('dist/index.html')) {
                        echo '✅ 构建成功！'
                    } else {
                        error '❌ 构建失败，未找到输出文件'
                    }
                }
            }
        }
        
        stage('🧪 运行测试') {
            steps {
                echo '开始运行测试...'
                sh 'npm test'
                echo '测试完成!'
            }
        }
        
        stage('🚀 部署应用') {
            steps {
                echo '开始部署应用...'
                
                script {
                    // 模拟部署过程
                    sh 'cp -r dist/* /var/www/html/'
                    echo '🎉 部署成功！应用已上线'
                }
            }
        }
    }
    
    // 构建后的操作
    post {
        always {
            echo 'Pipeline执行完成，开始清理工作...'
        }
        success {
            echo '🎉 恭喜！Pipeline执行成功'
        }
        failure {
            echo '❌ Pipeline执行失败，请检查日志'
        }
    }
}
```

### 7.3 执行流程图示


```
Pipeline执行流程：

开始
  ↓
🔍 环境检查  ← 检查Node.js、npm版本
  ↓
📦 安装依赖  ← 执行npm install
  ↓  
🔨 构建项目  ← 执行npm run build
  ↓
🧪 运行测试  ← 执行npm test  
  ↓
🚀 部署应用  ← 复制文件到web目录
  ↓
🎉 完成
```

### 7.4 关键知识点解析


**🌍 environment环境变量**：
- **作用**：定义在整个Pipeline中都可以使用的变量
- **使用方式**：`${变量名}` 或 `env.变量名`

**🔧 script脚本块**：
- **作用**：在声明式Pipeline中写复杂逻辑
- **用法**：可以使用Groovy语言的所有特性

**📋 post构建后操作**：
- **always**：无论成功失败都执行
- **success**：只有成功时执行  
- **failure**：只有失败时执行

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


> 💡 **Pipeline核心理念**：把手工操作变成自动化脚本，让机器代替人做重复性工作

**🔸 Pipeline定义**：自动化的软件交付流水线
**🔸 两种写法**：声明式（新手推荐）vs 脚本式（高级用法）
**🔸 Jenkinsfile**：Pipeline的"剧本文件"，建议放在代码仓库中
**🔸 Stage阶段**：把大任务分解成小阶段，便于管理和跟踪
**🔸 Step步骤**：每个阶段中的具体执行动作

### 8.2 学习要点记忆


**🎯 Pipeline = 流水线**
```
就像工厂生产线：
原材料 → 加工 → 检验 → 包装 → 出厂
代  码 → 构建 → 测试 → 打包 → 部署
```

**🏗️ 基本结构记忆**
```groovy
pipeline {              // 房子的地基
    agent any           // 选择工人
    stages {           // 施工阶段
        stage('阶段1') {  // 具体工作
            steps {     // 详细步骤
                echo '做什么事'
            }
        }
    }
}
```

### 8.3 实践应用指导


**🔰 新手建议**：
1. **从简单开始**：先写一个只有echo的Pipeline
2. **逐步添加**：每次只增加一个新功能
3. **多看日志**：执行失败时仔细看错误信息
4. **模仿学习**：参考现有的Jenkinsfile模板

**📚 进阶学习路径**：
1. 掌握基本语法 → 学会写简单Pipeline
2. 了解常用Steps → 能处理常见任务
3. 学习条件判断 → 处理复杂业务逻辑  
4. 掌握并行执行 → 提高执行效率
5. 学会错误处理 → 增强Pipeline稳定性

**💡 关键理解**：
- Pipeline不是魔法，是把手工步骤写成脚本
- 出错很正常，看日志找原因是关键技能
- 从简单开始，逐步完善比一次写复杂更可靠

### 8.4 常见问题快速解答


**❓ Q: 声明式和脚本式Pipeline该选哪个？**
**💡 A**: 新手选声明式，语法规范易学；高级用户根据需求选择

**❓ Q: Jenkinsfile放在哪里好？**  
**💡 A**: 建议放在代码仓库根目录，便于版本管理和团队协作

**❓ Q: Stage应该怎么划分？**
**💡 A**: 按照软件发布流程划分：准备→构建→测试→部署

**❓ Q: Pipeline执行失败怎么办？**
**💡 A**: 查看Jenkins控制台日志，找到报错的Stage和Step，针对性解决

**核心记忆口诀**：
- Pipeline是流水线，自动化来帮你忙
- Stage分阶段执行，Step步骤要跟上  
- 声明式适合新手，脚本式功能强
- Jenkinsfile放代码库，版本管理不会忘