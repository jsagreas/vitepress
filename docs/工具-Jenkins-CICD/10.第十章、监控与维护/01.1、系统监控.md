---
title: 1、系统监控
---
## 📚 目录

1. [Jenkins监控概述](#1-jenkins监控概述)
2. [系统资源监控](#2-系统资源监控)
3. [构建性能监控](#3-构建性能监控)
4. [队列状态监控](#4-队列状态监控)
5. [节点状态监控](#5-节点状态监控)
6. [监控指标配置](#6-监控指标配置)
7. [告警阈值设置](#7-告警阈值设置)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 Jenkins监控概述


### 1.1 为什么需要监控Jenkins？


**简单理解**：就像我们开车需要看仪表盘一样，Jenkins作为CI/CD的"引擎"，也需要监控来确保正常运行。

```
日常工作场景对比：

没有监控的Jenkins：
❌ 构建突然失败了，不知道原因
❌ 系统变慢了，不知道瓶颈在哪
❌ 磁盘满了，任务无法执行
❌ 出问题才发现，影响开发进度

有监控的Jenkins：
✅ 提前发现资源不足
✅ 构建趋势一目了然  
✅ 性能问题及时优化
✅ 故障快速定位解决
```

### 1.2 Jenkins监控的核心目标


**🎯 监控四大目标**：
- **可用性**：Jenkins系统是否正常运行
- **性能**：构建速度和系统响应是否正常
- **容量**：资源使用情况，是否需要扩容
- **稳定性**：系统是否稳定，故障频率如何

### 1.3 监控架构全景图


```
Jenkins监控体系架构：

┌─────────────────────────────────────────────────────┐
│                 监控展示层                           │
│  📊 Grafana仪表板  📈 Jenkins原生页面  📱 告警通知    │
└─────────────────┬───────────────────────────────────┘
                  │
┌─────────────────┴───────────────────────────────────┐
│                 数据收集层                           │
│  🔍 Prometheus  📊 InfluxDB  📝 日志收集  📋 内置监控 │
└─────────────────┬───────────────────────────────────┘
                  │
┌─────────────────┴───────────────────────────────────┐
│                Jenkins系统层                        │
│  🖥️ Master节点   👥 Agent节点   🔧 插件系统          │
└─────────────────────────────────────────────────────┘
```

---

## 2. 🖥️ 系统资源监控


### 2.1 CPU使用率监控


**什么是CPU监控**：就像监控汽车发动机转速一样，CPU监控告诉我们Jenkins的"大脑"工作强度。

**🔸 关键指标解释**：
```
CPU使用率指标：

系统CPU使用率：
• 含义：整个服务器的CPU忙碌程度
• 正常范围：< 70%
• 告警阈值：> 80%（持续5分钟）
• 危险阈值：> 90%（可能影响响应）

Jenkins进程CPU：
• 含义：Jenkins程序本身占用的CPU
• 正常范围：< 50%
• 异常情况：突然飙升可能是插件问题

CPU负载（Load Average）：
• 含义：系统排队等待处理的任务数
• 计算方式：1分钟/5分钟/15分钟平均值
• 理想状态：小于CPU核心数
```

**💡 实际监控配置**：
```bash
# 查看当前CPU使用情况
top -p $(pgrep -f jenkins)

# 监控Jenkins进程CPU
ps aux | grep jenkins | grep -v grep

# 系统负载查看
uptime
```

### 2.2 内存使用监控


**通俗理解**：内存就像桌面空间，东西放太多就会影响工作效率，Jenkins也一样。

**🔸 内存监控要点**：

| 监控项目 | **含义说明** | **正常范围** | **告警条件** |
|---------|-------------|-------------|-------------|
| 🧠 **总内存使用** | `系统整体内存占用` | `< 80%` | `> 85%持续10分钟` |
| ☕ **JVM堆内存** | `Jenkins程序可用内存` | `< 75%` | `> 85%或频繁GC` |
| 📊 **堆外内存** | `JVM堆外使用的内存` | `< 2GB` | `持续增长不回收` |
| 💾 **可用内存** | `系统剩余可用内存` | `> 2GB` | `< 1GB且持续下降` |

**⚠️ 常见内存问题**：
```
内存泄漏识别：
症状：内存使用持续上升，重启后恢复
原因：某些插件或配置导致内存无法释放
解决：分析堆转储文件，定位问题插件

内存不足影响：
- 构建任务失败
- 页面响应缓慢
- Jenkins频繁重启
- 系统整体卡顿
```

### 2.3 磁盘空间监控


**为什么重要**：磁盘满了Jenkins就无法工作，就像仓库满了无法继续存货一样。

**🔸 磁盘监控策略**：
```
关键目录监控：

Jenkins主目录（JENKINS_HOME）：
├─ 存储内容：配置、插件、构建历史
├─ 监控重点：总使用量、增长趋势
├─ 告警阈值：> 80%使用率
└─ 清理策略：定期清理旧构建记录

构建工作空间（workspace）：
├─ 存储内容：源码检出、编译产物
├─ 监控重点：单个项目空间占用
├─ 告警阈值：单项目 > 10GB
└─ 清理策略：构建完成后自动清理

系统临时目录（/tmp）：
├─ 存储内容：临时文件、解压包
├─ 监控重点：是否有残留文件
├─ 告警阈值：> 5GB
└─ 清理策略：每日自动清理
```

**📊 磁盘监控脚本示例**：
```bash
#!/bin/bash
# Jenkins磁盘监控脚本

# 检查Jenkins主目录使用率
JENKINS_HOME_USAGE=$(df $JENKINS_HOME | tail -1 | awk '{print $5}' | sed 's/%//')

if [ $JENKINS_HOME_USAGE -gt 80 ]; then
    echo "⚠️ 警告：Jenkins主目录使用率 ${JENKINS_HOME_USAGE}%"
    # 可以发送告警通知
fi

# 检查大文件
find $JENKINS_HOME -size +1G -type f | head -10
```

---

## 3. ⏱️ 构建性能监控


### 3.1 构建时间分析


**简单理解**：监控构建时间就像监控快递配送时间，帮我们发现哪个环节可以优化。

**🔸 构建时间监控维度**：

```
时间监控分解：

总构建时间：
┌─ 源码检出时间 ─┐
├─ 依赖下载时间 ─┤
├─ 编译构建时间 ─┤  ← 各环节时间分析
├─ 测试执行时间 ─┤
└─ 部署发布时间 ─┘

关键指标：
• 平均构建时间：过去30天的平均值
• 构建时间趋势：是否在逐步增长
• 超时构建次数：超过预期时间的构建
• 最快/最慢构建：极值分析
```

**💡 性能瓶颈识别**：
```
常见性能问题：

网络瓶颈：
- 源码下载慢 → 检查网络带宽
- 依赖下载慢 → 配置本地镜像源

资源瓶颈：
- 编译慢 → 增加CPU核心数
- 测试慢 → 并行执行测试

配置问题：
- 插件冲突 → 禁用不必要插件
- 配置不当 → 优化JVM参数
```

### 3.2 构建成功率监控


**通俗解释**：构建成功率就像生产线的合格率，反映系统的稳定性。

**📊 成功率监控指标**：

| 时间维度 | **监控指标** | **健康标准** | **需要关注** |
|---------|-------------|-------------|-------------|
| 📅 **日构建成功率** | `当日成功构建/总构建` | `> 95%` | `< 90%需要调查` |
| 📊 **周构建成功率** | `本周成功构建/总构建` | `> 90%` | `< 85%需要优化` |
| 📈 **项目成功率** | `单项目成功/失败比例` | `> 85%` | `< 80%项目有问题` |
| 🔄 **重试成功率** | `重试后成功的比例` | `< 20%` | `> 30%环境不稳定` |

### 3.3 构建队列分析


**什么是构建队列**：就像银行排队一样，当任务多于可用资源时，就会排队等待。

**🔸 队列监控要点**：
```
队列状态指标：

队列长度：
• 含义：等待执行的任务数量
• 正常状态：< 5个任务
• 告警条件：> 10个任务持续30分钟
• 影响：开发反馈延迟

等待时间：
• 含义：任务从提交到开始执行的时间
• 正常范围：< 5分钟
• 告警条件：> 15分钟
• 优化方案：增加Agent节点

执行者利用率：
• 含义：可用执行器的使用比例
• 理想状态：70-85%
• 过低：资源浪费
• 过高：队列积压
```

---

## 4. 📋 队列状态监控


### 4.1 队列管理原理


**形象比喻**：Jenkins队列就像餐厅的排号系统，合理管理才能提高效率。

```
Jenkins队列工作流程：

开发提交代码
      ↓
  触发构建任务
      ↓
┌─────────────┐
│   构建队列   │ ← 如果没有空闲执行器，任务在这里等待
│  [任务1]    │
│  [任务2]    │   
│  [任务3]    │
└─────────────┘
      ↓
  分配给执行器
      ↓
    开始构建
```

### 4.2 队列监控指标


**🔸 关键监控数据**：

**队列长度变化**：
```
正常队列模式：
时间    队列长度    说明
09:00      2       早高峰开始
10:00      5       提交增多  
11:00      3       逐步消化
12:00      1       午餐时间回落

异常队列模式：
时间    队列长度    说明  
09:00      3       正常开始
10:00      8       快速积压
11:00     15       持续增长 ← 需要关注
12:00     20       严重积压 ← 需要处理
```

**💡 队列优化策略**：
```
队列积压解决方案：

短期解决：
1. 重启卡住的构建任务
2. 临时增加执行器数量
3. 取消不重要的定时任务

长期优化：
1. 增加Agent节点
2. 优化构建脚本效率
3. 合理配置任务优先级
4. 实施构建分离策略
```

### 4.3 队列阻塞问题


**什么是队列阻塞**：某些任务长时间占用执行器，导致其他任务无法执行。

**⚠️ 常见阻塞场景**：
```
典型阻塞情况：

长时间测试：
- 问题：集成测试运行2小时
- 影响：阻塞其他快速构建
- 解决：独立测试环境

资源竞争：
- 问题：多个任务争抢数据库
- 影响：构建相互等待
- 解决：资源隔离配置

节点故障：
- 问题：Agent节点无响应
- 影响：分配的任务卡死
- 解决：健康检查自动重启
```

---

## 5. 🖥️ 节点状态监控


### 5.1 节点健康状态


**节点概念解释**：Jenkins节点就像工厂的生产线，Master是管理中心，Agent是具体干活的工人。

**🔸 节点架构理解**：
```
Jenkins节点架构：

          📱 Master节点（管理者）
          ├─ 接收构建请求
          ├─ 调度任务分配  
          ├─ 监控Agent状态
          └─ 收集构建结果
                 │
        ┌────────┼────────┐
        │        │        │
   🔧 Agent1  🔧 Agent2  🔧 Agent3
   （Linux）  （Windows） （MacOS）
   └─执行构建  └─执行构建  └─执行构建
```

### 5.2 节点监控指标


**📊 节点状态监控表**：

| 监控维度 | **正常状态** | **警告状态** | **异常状态** | **处理方案** |
|---------|-------------|-------------|-------------|-------------|
| 🟢 **连接状态** | `在线(Online)` | `连接不稳定` | `离线(Offline)` | `检查网络和重启` |
| 💾 **磁盘空间** | `< 80%使用` | `80-90%使用` | `> 90%使用` | `清理空间或扩容` |
| 🧠 **内存使用** | `< 75%使用` | `75-85%使用` | `> 85%使用` | `重启Agent或加内存` |
| ⚡ **响应时间** | `< 5秒` | `5-10秒` | `> 10秒` | `检查性能瓶颈` |
| 🔄 **执行器状态** | `空闲可用` | `全部忙碌` | `卡死不响应` | `重启或增加执行器` |

### 5.3 节点自动化管理


**为什么需要自动化**：手动管理节点就像手动巡检设备，效率低且容易遗漏。

**🔧 自动化监控脚本**：
```bash
#!/bin/bash
# Jenkins节点健康检查脚本

check_node_health() {
    local node_name=$1
    
    # 检查节点在线状态
    online_status=$(curl -s "${JENKINS_URL}/computer/${node_name}/api/json" | jq '.offline')
    
    if [ "$online_status" = "true" ]; then
        echo "❌ 节点 $node_name 离线"
        # 尝试重新连接
        reconnect_node $node_name
    else
        echo "✅ 节点 $node_name 在线"
    fi
}

# 批量检查所有节点
for node in $(get_all_nodes); do
    check_node_health $node
done
```

**💡 节点故障自愈机制**：
```
自动故障处理流程：

检测到节点离线
        ↓
   尝试自动重连（最多3次）
        ↓
      重连失败？
    ↙        ↘
  Yes         No
   ↓          ↓
发送告警通知   恢复正常
   ↓
标记节点维护状态
   ↓
将任务转移到其他节点
```

---

## 6. 📊 监控指标配置


### 6.1 监控指标体系


**监控指标分层理解**：就像体检有不同的检查项目，Jenkins监控也要分层分类。

```
Jenkins监控指标金字塔：

           🔺 业务指标（最重要）
          /                    \
    📈 部署频率              🚀 交付质量
    ⏱️ 部署时长              📊 构建成功率
         \                    /
          📊 应用层指标（核心）
         /                    \
    🔧 构建性能              👥 用户体验  
    📋 队列状态              ⚡ 响应时间
         \                    /
          🖥️ 系统层指标（基础）
         /                    \
    💾 资源使用              🌐 网络状态
    🔄 服务可用性            📈 性能趋势
```

### 6.2 关键指标配置


**🎯 核心指标配置清单**：

**系统可用性指标**：
```yaml
# 系统可用性监控配置
availability_metrics:
  jenkins_service:
    endpoint: "${JENKINS_URL}/api/json"
    check_interval: "30s"
    timeout: "10s"
    expected_status: 200
    
  database_connection:
    check_interval: "60s"
    timeout: "5s"
    retry_count: 3
    
  node_connectivity:
    check_interval: "120s"
    offline_threshold: "300s"  # 5分钟离线告警
```

**性能指标配置**：
```yaml
# 性能监控指标
performance_metrics:
  build_duration:
    collection_interval: "build_complete"
    aggregation: ["avg", "p95", "p99"]
    time_window: "24h"
    
  queue_length:
    collection_interval: "60s"
    threshold_warning: 10
    threshold_critical: 20
    
  cpu_usage:
    collection_interval: "30s"
    threshold_warning: 70
    threshold_critical: 85
```

### 6.3 自定义监控配置


**为什么需要自定义**：每个团队的工作模式不同，需要针对性的监控指标。

**💡 业务相关监控示例**：
```groovy
// Jenkins Pipeline中的自定义监控
pipeline {
    agent any
    
    stages {
        stage('构建监控') {
            steps {
                script {
                    // 记录构建开始时间
                    def startTime = System.currentTimeMillis()
                    
                    // 执行构建
                    sh 'mvn clean package'
                    
                    // 计算构建时长
                    def duration = System.currentTimeMillis() - startTime
                    
                    // 发送监控数据
                    sendMetric("build.duration", duration, [
                        project: env.JOB_NAME,
                        branch: env.BRANCH_NAME
                    ])
                }
            }
        }
    }
}
```

---

## 7. 🚨 告警阈值设置


### 7.1 告警策略设计


**告警设计原则**：好的告警就像好的保安，既不能漏掉问题，也不能误报扰民。

**🔸 告警级别分类**：
```
告警严重程度分级：

🔴 紧急告警（Critical）：
- 触发条件：系统完全不可用
- 响应时间：立即处理（5分钟内）
- 通知方式：电话 + 短信 + 邮件
- 示例：Jenkins服务宕机

🟡 警告告警（Warning）：
- 触发条件：性能下降但仍可用
- 响应时间：1小时内处理
- 通知方式：邮件 + 即时消息
- 示例：构建队列积压

🟢 信息告警（Info）：
- 触发条件：需要关注的趋势
- 响应时间：24小时内处理
- 通知方式：邮件汇总
- 示例：磁盘使用率上升趋势
```

### 7.2 阈值设置最佳实践


**阈值设置技巧**：合理的阈值既要敏感又要稳定，避免"狼来了"效应。

**📊 常用阈值配置表**：

| 监控项目 | **Warning阈值** | **Critical阈值** | **持续时间** | **设置理由** |
|---------|----------------|-----------------|-------------|-------------|
| 🧠 **CPU使用率** | `70%` | `85%` | `5分钟` | `给处理留出缓冲时间` |
| 💾 **内存使用率** | `75%` | `90%` | `10分钟` | `内存释放需要时间` |
| 💽 **磁盘使用率** | `80%` | `95%` | `即时` | `磁盘满会立即影响` |
| 📋 **队列长度** | `10个任务` | `20个任务` | `15分钟` | `短暂积压可接受` |
| ⏱️ **构建时长** | `平均时长1.5倍` | `平均时长2倍` | `单次` | `异常构建需立即关注` |

### 7.3 告警通知配置


**通知渠道配置**：不同紧急程度用不同通知方式，确保关键信息及时传达。

**💬 多渠道告警配置**：
```yaml
# 告警通知配置示例
alert_channels:
  email:
    smtp_server: "smtp.company.com"
    recipients:
      - "devops@company.com"
      - "dev-team@company.com"
    
  slack:
    webhook_url: "https://hooks.slack.com/..."
    channel: "#jenkins-alerts"
    
  sms:
    provider: "aliyun_sms"
    phone_numbers:
      - "+86138****1234"  # 运维负责人
    
  wechat:
    corp_id: "wx123456"
    app_secret: "secret123"
    agent_id: 1000001
```

**🔄 告警升级机制**：
```
告警升级流程：

问题发生
    ↓
发送首次告警 → 一线工程师
    ↓
15分钟未确认？
    ↓
升级告警 → 团队负责人
    ↓  
30分钟未解决？
    ↓
紧急告警 → 技术总监
```

### 7.4 告警降噪策略


**为什么需要降噪**：过多的告警会让人麻木，真正的问题反而被忽略。

**🔇 降噪技术措施**：
```
告警合并策略：

时间窗口合并：
- 5分钟内相同类型告警只发送一次
- 避免告警风暴

条件组合判断：
- CPU + 内存同时超阈值才告警
- 单一指标可能是误报

智能阈值：
- 基于历史数据动态调整
- 工作时间和非工作时间不同阈值

告警抑制：
- 维护期间自动停止告警
- 已知问题期间临时抑制
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的监控概念


```
🔸 监控目的：确保Jenkins系统稳定、高效运行
🔸 监控层次：系统层 → 应用层 → 业务层，逐层深入
🔸 监控指标：可用性、性能、容量、质量四个维度
🔸 告警原则：分级处理，多渠道通知，避免告警疲劳
🔸 自动化：从被动监控到主动预警，提高运维效率
```

### 8.2 关键监控指标记忆


**🧠 核心指标速记**：
```
系统资源监控（基础）：
- CPU使用率 < 70%（警告）< 85%（严重）
- 内存使用率 < 75%（警告）< 90%（严重）  
- 磁盘使用率 < 80%（警告）< 95%（严重）

构建性能监控（核心）：
- 构建成功率 > 90%（健康）< 85%（需关注）
- 平均构建时长：不超过历史平均值1.5倍
- 队列长度 < 10个（正常）> 20个（告警）

节点状态监控（重要）：
- 节点在线率 > 95%
- 响应时间 < 5秒
- 执行器利用率 70-85%（最佳）
```

### 8.3 实际应用建议


**🎯 监控实施步骤**：
```
第一阶段：基础监控
✅ 部署系统资源监控
✅ 配置基本告警阈值
✅ 建立告警通知机制

第二阶段：性能监控
✅ 实施构建性能分析
✅ 配置队列状态监控
✅ 优化告警策略

第三阶段：智能监控
✅ 引入趋势分析
✅ 实现预测性告警
✅ 建立自动化响应
```

**💡 运维最佳实践**：
```
日常运维要点：
1. 每日检查监控仪表板
2. 每周分析性能趋势报告
3. 每月优化告警阈值设置
4. 定期review和清理监控数据

故障响应流程：
1. 快速定位问题范围
2. 评估影响和紧急程度
3. 实施临时解决方案
4. 深入分析根本原因
5. 制定长期优化计划
```

### 8.4 监控成熟度评估


**📊 团队监控能力自检**：
```
初级水平（⭐）：
□ 有基本的系统监控
□ 能及时发现明显故障
□ 有简单的告警通知

中级水平（⭐⭐）：
□ 监控指标全面覆盖
□ 告警策略合理有效
□ 能快速定位问题

高级水平（⭐⭐⭐）：
□ 具备预测性监控能力
□ 自动化程度高
□ 监控驱动的持续优化
```

**核心记忆口诀**：
- 监控在先预警及时，分层分级避免疲劳
- 系统应用业务三层，指标阈值要合理
- 自动化程度越高越好，持续优化是关键
- 故障响应要有流程，复盘改进不可少

> 💡 **新手提醒**：监控不是目的，而是保障Jenkins稳定运行的手段。开始时不要追求完美，先建立基础监控，再逐步完善和优化。最重要的是形成监控意识和故障响应的良好习惯！