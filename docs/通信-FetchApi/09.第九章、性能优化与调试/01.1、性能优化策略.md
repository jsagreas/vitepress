---
title: 1、性能优化策略
---
## 📚 目录

1. [性能优化基本原则](#1-性能优化基本原则)
2. [请求合并策略](#2-请求合并策略)
3. [缓存策略设计](#3-缓存策略设计)
4. [请求去重处理](#4-请求去重处理)
5. [并发请求控制](#5-并发请求控制)
6. [预加载与懒加载](#6-预加载与懒加载)
7. [CDN加速应用](#7-CDN加速应用)
8. [性能监控基础](#8-性能监控基础)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 性能优化基本原则


### 1.1 性能优化的本质


**什么是性能优化？**
简单来说，就是让你的网页加载更快，用户体验更好。就像开车一样，我们要选择最短路径、避开堵车、减少不必要的停靠。

> 💡 **核心思想**：减少请求数量，缩小请求体积，加快响应速度

### 1.2 性能问题的常见表现


```
用户感受到的问题：
🐌 页面加载慢     → 等待时间长
🔄 界面卡顿       → 操作不流畅  
📱 移动端耗电快   → 电量消耗大
💸 流量消耗多     → 费用增加
```

### 1.3 优化的三个基本方向


**📊 性能优化策略图**
```
性能优化
├── 减少请求
│   ├── 请求合并
│   ├── 图片合并
│   └── 文件压缩
├── 提高速度
│   ├── 缓存策略
│   ├── CDN加速
│   └── 并发控制
└── 智能加载
    ├── 预加载
    ├── 懒加载
    └── 分页加载
```

---

## 2. 🔗 请求合并策略


### 2.1 什么是请求合并


**简单理解**：原本需要发送10次快递，现在打包成1次发送。减少了网络往返次数，提高了效率。

> 📖 **概念**：将多个小请求合并成一个大请求，减少网络开销

### 2.2 合并策略的应用场景


**典型场景示例**：
```javascript
// ❌ 不好的做法：多次请求
async function loadUserInfo() {
    const profile = await fetch('/api/user/profile');
    const avatar = await fetch('/api/user/avatar');
    const settings = await fetch('/api/user/settings');
    // 发了3次请求
}

// ✅ 好的做法：合并请求
async function loadUserInfo() {
    const userInfo = await fetch('/api/user/complete');
    // 只发1次请求，后端返回完整信息
}
```

### 2.3 实际合并技术


**🔧 批量请求实现**
```javascript
class RequestBatcher {
    constructor() {
        this.queue = [];
        this.timer = null;
    }
    
    // 添加请求到队列
    addRequest(url) {
        this.queue.push(url);
        
        // 100ms后统一发送
        if (!this.timer) {
            this.timer = setTimeout(() => {
                this.sendBatch();
            }, 100);
        }
    }
    
    // 批量发送
    sendBatch() {
        if (this.queue.length > 0) {
            // 将多个URL合并成一个请求
            fetch('/api/batch', {
                method: 'POST',
                body: JSON.stringify({ urls: this.queue })
            });
            
            this.queue = [];
            this.timer = null;
        }
    }
}
```

> ⚠️ **注意**：合并请求适合读取操作，写入操作要谨慎使用

---

## 3. 💾 缓存策略设计


### 3.1 缓存的基本概念


**生活中的缓存**：就像在家里囤货，常用的东西提前买好放着，需要时直接拿，不用每次都跑超市。

> 💡 **核心作用**：把经常用的数据存起来，下次直接用，不用重新请求

### 3.2 缓存的层次结构


```
缓存层次图：
浏览器端
├── 内存缓存 (最快，容量小)
├── 磁盘缓存 (较快，容量大)
└── 本地存储 (localStorage/sessionStorage)
        ↓
    网络请求
        ↓
服务器端
├── CDN缓存
├── 反向代理缓存
└── 数据库缓存
```

### 3.3 简单的缓存实现


**🔧 基础缓存代码**
```javascript
class SimpleCache {
    constructor() {
        this.cache = new Map();
        this.maxAge = 5 * 60 * 1000; // 5分钟过期
    }
    
    // 获取缓存
    get(key) {
        const item = this.cache.get(key);
        if (!item) return null;
        
        // 检查是否过期
        if (Date.now() > item.expireTime) {
            this.cache.delete(key);
            return null;
        }
        
        return item.data;
    }
    
    // 设置缓存
    set(key, data) {
        this.cache.set(key, {
            data: data,
            expireTime: Date.now() + this.maxAge
        });
    }
}

// 使用示例
const cache = new SimpleCache();

async function fetchWithCache(url) {
    // 先检查缓存
    let data = cache.get(url);
    if (data) {
        console.log('从缓存获取');
        return data;
    }
    
    // 缓存没有，发请求
    const response = await fetch(url);
    data = await response.json();
    
    // 存入缓存
    cache.set(url, data);
    return data;
}
```

### 3.4 缓存策略选择


| 数据类型 | **缓存时间** | **策略** | **说明** |
|---------|-------------|---------|----------|
| 🏞️ **静态资源** | `长期缓存` | `文件指纹` | `图片、CSS等不常变化` |
| 📊 **用户数据** | `短期缓存` | `5-10分钟` | `个人信息、设置等` |
| 📰 **新闻列表** | `中期缓存` | `30分钟` | `内容更新不频繁` |
| 💰 **价格信息** | `不缓存` | `实时获取` | `变化频繁，要求准确` |

---

## 4. 🔄 请求去重处理


### 4.1 什么是请求去重


**生活例子**：你在电梯里连续按了3次楼层按钮，电梯不会傻到跑3趟，它知道你要去的是同一层楼。

> 📖 **概念**：防止相同的请求被重复发送，避免浪费资源

### 4.2 去重的典型场景


```
常见重复请求场景：
👆 用户快速点击按钮
🔄 组件重复渲染触发请求
📱 网络不稳定导致重试
🎯 相同数据的并发请求
```

### 4.3 去重实现方案


**🔧 简单去重实现**
```javascript
class RequestDeduplicator {
    constructor() {
        this.pendingRequests = new Map();
    }
    
    async request(url, options = {}) {
        // 生成请求的唯一标识
        const key = this.generateKey(url, options);
        
        // 如果相同请求正在进行，返回相同的Promise
        if (this.pendingRequests.has(key)) {
            console.log('请求去重:', url);
            return this.pendingRequests.get(key);
        }
        
        // 发起新请求
        const promise = fetch(url, options)
            .then(response => response.json())
            .finally(() => {
                // 请求完成后清除
                this.pendingRequests.delete(key);
            });
        
        // 存储进行中的请求
        this.pendingRequests.set(key, promise);
        return promise;
    }
    
    generateKey(url, options) {
        return `${options.method || 'GET'}_${url}_${JSON.stringify(options.body || {})}`;
    }
}

// 使用示例
const deduplicator = new RequestDeduplicator();

// 这3个请求会被去重为1个
deduplicator.request('/api/user/info');
deduplicator.request('/api/user/info');  // 去重
deduplicator.request('/api/user/info');  // 去重
```

> ⚠️ **注意**：去重主要用于读取请求，写入请求要谨慎

---

## 5. ⚡ 并发请求控制


### 5.1 并发控制的必要性


**为什么要控制并发？**
就像高速公路有车道限制一样，同时发送太多请求会造成"网络拥堵"，反而变慢。

> 💡 **核心目标**：在不阻塞浏览器的前提下，合理利用网络资源

### 5.2 并发问题的表现


```
并发过多的问题：
🌐 浏览器连接数限制（通常6-8个）
🔥 服务器压力过大
📱 移动设备性能下降
⚠️ 请求超时增加
```

### 5.3 并发控制实现


**🔧 并发队列管理**
```javascript
class ConcurrencyController {
    constructor(maxConcurrency = 6) {
        this.maxConcurrency = maxConcurrency;
        this.running = 0;
        this.queue = [];
    }
    
    async request(url, options = {}) {
        return new Promise((resolve, reject) => {
            // 添加到队列
            this.queue.push({
                url,
                options,
                resolve,
                reject
            });
            
            this.processQueue();
        });
    }
    
    async processQueue() {
        // 如果达到并发限制或队列为空，不处理
        if (this.running >= this.maxConcurrency || this.queue.length === 0) {
            return;
        }
        
        const task = this.queue.shift();
        this.running++;
        
        try {
            const response = await fetch(task.url, task.options);
            const data = await response.json();
            task.resolve(data);
        } catch (error) {
            task.reject(error);
        } finally {
            this.running--;
            this.processQueue(); // 处理下一个
        }
    }
}

// 使用示例
const controller = new ConcurrencyController(3); // 最多3个并发

// 发送10个请求，但只会同时进行3个
for (let i = 0; i < 10; i++) {
    controller.request(`/api/data/${i}`);
}
```

### 5.4 并发数量建议


| 设备类型 | **建议并发数** | **说明** |
|---------|---------------|----------|
| 🖥️ **桌面浏览器** | `6-8个` | `浏览器默认限制` |
| 📱 **移动设备** | `3-4个` | `性能和电量考虑` |
| 🔗 **API请求** | `2-3个` | `避免服务器压力` |
| 📁 **文件上传** | `1-2个` | `带宽和稳定性考虑` |

---

## 6. 🚀 预加载与懒加载


### 6.1 预加载的概念


**什么是预加载？**
就像看电视剧时，下一集在后台提前缓冲好，点击时立即播放。

> 💡 **核心思想**：提前加载用户可能需要的内容

### 6.2 预加载的实现


**🔧 简单预加载**
```javascript
class Preloader {
    constructor() {
        this.preloadCache = new Map();
    }
    
    // 预加载数据
    preload(url) {
        if (this.preloadCache.has(url)) return;
        
        fetch(url)
            .then(response => response.json())
            .then(data => {
                this.preloadCache.set(url, data);
                console.log('预加载完成:', url);
            });
    }
    
    // 获取数据（优先从预加载缓存）
    async get(url) {
        if (this.preloadCache.has(url)) {
            const data = this.preloadCache.get(url);
            this.preloadCache.delete(url); // 使用后清除
            return data;
        }
        
        // 没有预加载，正常请求
        const response = await fetch(url);
        return response.json();
    }
}

// 使用示例
const preloader = new Preloader();

// 在用户浏览首页时，预加载第二页
preloader.preload('/api/products?page=2');

// 用户点击翻页时，立即获得数据
const data = await preloader.get('/api/products?page=2');
```

### 6.3 懒加载的概念


**什么是懒加载？**
就像快递到付，只有在真正需要时才去取货，节省了存储空间。

> 💡 **核心思想**：只在需要时才加载内容，节省资源

### 6.4 懒加载实现


**🔧 图片懒加载示例**
```javascript
class ImageLazyLoader {
    constructor() {
        this.observer = new IntersectionObserver(this.handleIntersection.bind(this));
    }
    
    // 观察图片元素
    observe(imgElement) {
        imgElement.dataset.originalSrc = imgElement.src;
        imgElement.src = ''; // 暂时清空
        this.observer.observe(imgElement);
    }
    
    // 当图片进入视窗时加载
    handleIntersection(entries) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.originalSrc;
                this.observer.unobserve(img);
            }
        });
    }
}

// 使用示例
const lazyLoader = new ImageLazyLoader();
document.querySelectorAll('img[data-lazy]').forEach(img => {
    lazyLoader.observe(img);
});
```

---

## 7. 🌐 CDN加速应用


### 7.1 CDN的基本概念


**什么是CDN？**
想象你在北京，要买广州的特产。CDN就像在北京开了个分店，你就近购买，速度更快。

> 📖 **CDN全称**：Content Delivery Network（内容分发网络）

### 7.2 CDN的工作原理


```
CDN工作流程：
用户(北京) ──→ 就近CDN节点(北京) ──→ 快速获取内容
     ↑                                      ↓
     └─────── 无需访问 ──────┐        ┌─────┘
                            ↓        ↓
                    原始服务器(广州)
```

### 7.3 CDN的应用场景


**典型使用场景**：
```javascript
// ❌ 直接从服务器加载（慢）
<img src="https://myserver.com/images/logo.png">

// ✅ 通过CDN加载（快）
<img src="https://cdn.mysite.com/images/logo.png">

// 常见CDN资源
const cdnResources = {
    images: 'https://img-cdn.mysite.com',
    videos: 'https://video-cdn.mysite.com',
    scripts: 'https://js-cdn.mysite.com'
};
```

### 7.4 CDN使用最佳实践


| 资源类型 | **CDN策略** | **缓存时间** | **说明** |
|---------|------------|-------------|----------|
| 🖼️ **图片** | `必须使用` | `1年` | `体积大，访问频繁` |
| 📱 **CSS/JS** | `强烈推荐` | `1个月` | `减少服务器压力` |
| 📹 **视频** | `必须使用` | `6个月` | `体积超大，必须分发` |
| 📄 **HTML** | `谨慎使用` | `很短` | `内容变化频繁` |

---

## 8. 📊 性能监控基础


### 8.1 为什么需要监控


**监控的重要性**：
就像开车要看仪表盘，网站也需要"仪表盘"来了解运行状况。

> 💡 **核心目标**：及时发现问题，持续改进性能

### 8.2 关键性能指标


```
主要监控指标：
⏱️ 响应时间      → 请求从发出到完成的时间
📊 成功率        → 请求成功的比例
🔢 并发数        → 同时进行的请求数量
📈 吞吐量        → 单位时间处理的请求数
💾 缓存命中率    → 从缓存获取数据的比例
```

### 8.3 简单的性能监控


**🔧 基础监控实现**
```javascript
class PerformanceMonitor {
    constructor() {
        this.metrics = {
            requests: 0,
            errors: 0,
            totalTime: 0
        };
    }
    
    async monitoredFetch(url, options = {}) {
        const startTime = Date.now();
        this.metrics.requests++;
        
        try {
            const response = await fetch(url, options);
            
            if (!response.ok) {
                this.metrics.errors++;
            }
            
            return response;
        } catch (error) {
            this.metrics.errors++;
            throw error;
        } finally {
            const endTime = Date.now();
            this.metrics.totalTime += (endTime - startTime);
            this.logMetrics();
        }
    }
    
    logMetrics() {
        const avgTime = this.metrics.totalTime / this.metrics.requests;
        const errorRate = this.metrics.errors / this.metrics.requests;
        
        console.log(`性能指标:`, {
            平均响应时间: `${avgTime.toFixed(2)}ms`,
            错误率: `${(errorRate * 100).toFixed(2)}%`,
            总请求数: this.metrics.requests
        });
    }
}

// 使用示例
const monitor = new PerformanceMonitor();
await monitor.monitoredFetch('/api/data');
```

### 8.4 监控数据的应用


**📈 性能优化循环**
```
数据收集 → 问题发现 → 优化改进 → 效果验证
    ↑                                    ↓
    └──────────── 持续监控 ────────────────┘
```

> ⚠️ **注意**：监控本身也会消耗资源，要适度使用

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 性能优化本质：让网页更快，用户体验更好
🔸 请求合并：多个小请求打包成一个大请求
🔸 缓存策略：把常用数据存起来，避免重复请求
🔸 请求去重：防止相同请求重复发送
🔸 并发控制：合理控制同时进行的请求数量
🔸 预加载：提前加载可能需要的内容
🔸 懒加载：只在需要时才加载内容
🔸 CDN加速：就近获取资源，提高速度
🔸 性能监控：持续观察和改进网站性能
```

### 9.2 关键理解要点


**🔹 优化策略的选择原则**
```
数据特点决定策略：
- 静态不变的 → 长期缓存 + CDN
- 经常变化的 → 实时请求
- 大文件资源 → 懒加载 + CDN
- 小数据请求 → 合并请求
```

**🔹 性能优化的优先级**
```
优化效果排序：
1. 🥇 缓存策略 → 最大效果提升
2. 🥈 CDN使用 → 显著速度提升  
3. 🥉 请求合并 → 减少网络开销
4. 📊 并发控制 → 稳定性提升
5. 🔍 监控优化 → 持续改进
```

**🔹 常见优化误区**
```
❌ 过度优化：为了优化而优化
❌ 盲目缓存：缓存所有数据
❌ 忽略监控：不看效果如何
✅ 针对性优化：解决实际问题
✅ 合理缓存：根据数据特点
✅ 持续监控：数据驱动优化
```

### 9.3 实际应用指导


**📊 不同场景的优化重点**

| 应用类型 | **主要优化策略** | **重点关注** |
|---------|----------------|-------------|
| 📰 **新闻网站** | `图片CDN + 懒加载` | `首屏加载速度` |
| 🛒 **电商平台** | `商品缓存 + 预加载` | `用户体验流畅` |
| 📱 **移动应用** | `请求合并 + 并发控制` | `流量和电量` |
| 🎮 **在线游戏** | `实时请求 + 去重` | `数据实时性` |

**🔧 实施步骤建议**
```
第一步：添加性能监控
第二步：识别性能瓶颈
第三步：选择合适策略
第四步：分步骤实施
第五步：验证优化效果
第六步：持续监控改进
```

**核心记忆**：
- 性能优化像整理房间，东西放对地方就快
- 缓存是你的"小仓库"，常用的东西提前准备
- 合并请求像拼车，一起走更省时省力
- 监控是你的"体检"，定期看看身体状况