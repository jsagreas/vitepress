---
title: 2、拦截器与中间件
---
## 📚 目录

1. [拦截器是什么？为什么需要？](#1-拦截器是什么？为什么需要？)
2. [请求拦截器 - 发请求前的预处理](#2-请求拦截器---发请求前的预处理)
3. [响应拦截器 - 收到数据后的统一处理](#3-响应拦截器---收到数据后的统一处理)
4. [中间件模式 - 让功能像积木一样组合](#4-中间件模式---让功能像积木一样组合)
5. [实战封装 - 打造自己的fetch工具](#5-实战封装---打造自己的fetch工具)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🤔 拦截器是什么？为什么需要？


### 1.1 生活中的拦截器概念


> **拦截器就像是流水线上的检查站**：每个产品经过时都要检查、贴标签、质检等，最后才到用户手里。

```
真实开发中的痛点：

❌ 没有拦截器的情况：
每个请求都要手动：
- 添加token认证
- 处理错误  
- 记录日志
- 格式化数据

✅ 有拦截器的情况：
写一次规则，自动处理：
- 自动添加认证头
- 统一错误处理
- 自动记录日志
- 统一数据格式
```

### 1.2 拦截器的工作原理


```
请求拦截器工作流程：

你的代码发起请求
      ↓
  [请求拦截器] ← 在这里统一处理：添加token、设置headers等
      ↓
   发送到服务器
      ↓
  [响应拦截器] ← 在这里统一处理：错误处理、数据格式化等
      ↓
  返回给你的代码
```

**🎯 核心价值**：
- **减少重复代码** - 写一次，到处用
- **统一标准** - 所有请求都遵循同样的规则
- **方便维护** - 修改一处，全项目生效
- **提高效率** - 专注业务逻辑，不用操心基础设置

---

## 2. 📤 请求拦截器 - 发请求前的预处理


### 2.1 最简单的请求拦截器


**💡 核心思想**：在发送请求前，先"拦截"下来做一些处理

```javascript
// 简单的请求拦截器 - 自动添加token
function requestInterceptor(url, options = {}) {
    // 获取用户token（通常从localStorage或cookie）
    const token = localStorage.getItem('token');
    
    // 如果有token，自动添加到请求头
    if (token) {
        options.headers = {
            'Authorization': `Bearer ${token}`,
            ...options.headers  // 保留原有的headers
        };
    }
    
    return { url, options };
}

// 使用示例
function myFetch(url, options) {
    // 先经过拦截器处理
    const { url: newUrl, options: newOptions } = requestInterceptor(url, options);
    
    // 再发送真正的请求
    return fetch(newUrl, newOptions);
}

// 现在每个请求都会自动带上token
myFetch('/api/user/profile')
    .then(res => res.json())
    .then(data => console.log(data));
```

### 2.2 实用的请求拦截器功能


**🔧 常见的请求预处理需求**：

```javascript
// 功能丰富的请求拦截器
function advancedRequestInterceptor(url, options = {}) {
    // 1. 自动添加基础URL
    if (!url.startsWith('http')) {
        url = 'https://api.example.com' + url;
    }
    
    // 2. 设置默认请求头
    options.headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        ...options.headers
    };
    
    // 3. 自动添加认证token
    const token = localStorage.getItem('token');
    if (token) {
        options.headers['Authorization'] = `Bearer ${token}`;
    }
    
    // 4. 请求日志记录
    console.log(`🚀 发起请求: ${options.method || 'GET'} ${url}`);
    console.log('📦 请求参数:', options.body);
    
    // 5. 自动处理POST数据格式
    if (options.body && typeof options.body === 'object') {
        options.body = JSON.stringify(options.body);
    }
    
    return { url, options };
}
```

### 2.3 统一认证头处理


**🔑 认证是最常见的需求**：

```javascript
// 专门处理认证的拦截器
class AuthInterceptor {
    constructor() {
        this.token = null;
        this.refreshToken = null;
    }
    
    // 设置token
    setToken(token, refreshToken) {
        this.token = token;
        this.refreshToken = refreshToken;
        // 保存到本地存储
        localStorage.setItem('token', token);
        localStorage.setItem('refreshToken', refreshToken);
    }
    
    // 获取token
    getToken() {
        if (!this.token) {
            this.token = localStorage.getItem('token');
        }
        return this.token;
    }
    
    // 拦截请求，添加认证头
    interceptRequest(url, options = {}) {
        const token = this.getToken();
        
        if (token) {
            options.headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
        }
        
        return { url, options };
    }
}

// 使用示例
const authInterceptor = new AuthInterceptor();

// 用户登录后设置token
authInterceptor.setToken('your-jwt-token-here');

// 每次请求自动带上认证头
function authenticatedFetch(url, options) {
    const { url: newUrl, options: newOptions } = authInterceptor.interceptRequest(url, options);
    return fetch(newUrl, newOptions);
}
```

---

## 3. 📥 响应拦截器 - 收到数据后的统一处理


### 3.1 响应拦截器的基本概念


**💡 核心思想**：服务器返回数据后，先"拦截"下来统一处理，再交给具体的业务代码

```javascript
// 简单的响应拦截器
async function responseInterceptor(response) {
    // 1. 记录响应日志
    console.log(`✅ 收到响应: ${response.status} ${response.url}`);
    
    // 2. 统一处理HTTP错误
    if (!response.ok) {
        console.error(`❌ 请求失败: ${response.status} ${response.statusText}`);
        throw new Error(`HTTP Error: ${response.status}`);
    }
    
    // 3. 自动解析JSON
    const data = await response.json();
    
    // 4. 处理业务层面的错误
    if (data.code !== 200) {
        console.error('❌ 业务错误:', data.message);
        throw new Error(data.message);
    }
    
    // 5. 返回真正的数据
    return data.data;
}

// 使用示例
async function myFetch(url, options) {
    const response = await fetch(url, options);
    return responseInterceptor(response);
}

// 现在所有请求都会自动处理错误和解析数据
myFetch('/api/user/list')
    .then(users => {
        // 直接得到用户列表，不用担心错误处理
        console.log('用户列表:', users);
    })
    .catch(error => {
        // 统一的错误处理
        alert('请求失败: ' + error.message);
    });
```

### 3.2 智能的错误处理拦截器


**🛡️ 让错误处理更智能**：

```javascript
// 智能错误处理拦截器
class ErrorHandler {
    constructor() {
        this.errorMessages = {
            400: '请求参数错误',
            401: '请重新登录',
            403: '没有权限访问',
            404: '请求的资源不存在',
            500: '服务器内部错误',
            502: '网关错误',
            503: '服务不可用'
        };
    }
    
    async handleResponse(response) {
        // HTTP状态码错误
        if (!response.ok) {
            const message = this.errorMessages[response.status] || '请求失败';
            
            // 401需要特殊处理 - 跳转到登录页
            if (response.status === 401) {
                this.redirectToLogin();
            }
            
            throw new Error(message);
        }
        
        // 尝试解析JSON
        let data;
        try {
            data = await response.json();
        } catch (e) {
            // 如果不是JSON格式，直接返回文本
            return response.text();
        }
        
        // 业务层面的错误处理
        if (data.success === false || data.code !== 200) {
            throw new Error(data.message || '操作失败');
        }
        
        return data;
    }
    
    redirectToLogin() {
        // 清除本地token
        localStorage.removeItem('token');
        // 跳转到登录页
        window.location.href = '/login';
    }
}

const errorHandler = new ErrorHandler();

// 使用错误处理拦截器
async function safeFetch(url, options) {
    const response = await fetch(url, options);
    return errorHandler.handleResponse(response);
}
```

### 3.3 数据格式化拦截器


**📊 让数据格式更统一**：

```javascript
// 数据格式化拦截器
class DataFormatter {
    // 格式化日期字段
    formatDates(obj) {
        if (!obj || typeof obj !== 'object') return obj;
        
        for (let key in obj) {
            if (key.includes('time') || key.includes('date')) {
                obj[key] = new Date(obj[key]).toLocaleString();
            }
        }
        return obj;
    }
    
    // 格式化数字字段
    formatNumbers(obj) {
        if (!obj || typeof obj !== 'object') return obj;
        
        for (let key in obj) {
            if (key.includes('price') || key.includes('amount')) {
                obj[key] = parseFloat(obj[key]).toFixed(2);
            }
        }
        return obj;
    }
    
    // 处理响应数据
    async formatResponse(response) {
        let data = await response.json();
        
        // 如果是数组，处理每一项
        if (Array.isArray(data)) {
            data = data.map(item => {
                item = this.formatDates(item);
                item = this.formatNumbers(item);
                return item;
            });
        } else {
            data = this.formatDates(data);
            data = this.formatNumbers(data);
        }
        
        return data;
    }
}
```

---

## 4. 🔧 中间件模式 - 让功能像积木一样组合


### 4.1 中间件模式的概念


**💡 中间件就像洋葱**：一层一层包装处理，每一层都有自己的职责

```
中间件模式的工作原理：

请求 → [认证中间件] → [日志中间件] → [缓存中间件] → fetch → 响应
      ←              ←              ←               ←
```

**🎯 核心优势**：
- **功能解耦** - 每个中间件只负责一件事
- **灵活组合** - 需要什么功能就加什么中间件
- **易于测试** - 每个中间件可以单独测试
- **代码复用** - 中间件可以在不同项目中使用

### 4.2 简单的中间件实现


```javascript
// 中间件管理器
class MiddlewareManager {
    constructor() {
        this.middlewares = [];
    }
    
    // 添加中间件
    use(middleware) {
        this.middlewares.push(middleware);
        return this; // 支持链式调用
    }
    
    // 执行所有中间件
    async execute(url, options) {
        let context = { url, options };
        
        // 依次执行每个中间件
        for (let middleware of this.middlewares) {
            context = await middleware(context);
        }
        
        return context;
    }
}

// 定义几个中间件
const authMiddleware = (context) => {
    const token = localStorage.getItem('token');
    if (token) {
        context.options.headers = {
            ...context.options.headers,
            'Authorization': `Bearer ${token}`
        };
    }
    return context;
};

const logMiddleware = (context) => {
    console.log(`📡 请求: ${context.options.method || 'GET'} ${context.url}`);
    return context;
};

const baseUrlMiddleware = (context) => {
    if (!context.url.startsWith('http')) {
        context.url = 'https://api.example.com' + context.url;
    }
    return context;
};

// 使用中间件
const middlewareManager = new MiddlewareManager();
middlewareManager
    .use(baseUrlMiddleware)
    .use(authMiddleware)
    .use(logMiddleware);

// 增强版的fetch
async function enhancedFetch(url, options = {}) {
    // 执行所有中间件
    const context = await middlewareManager.execute(url, options);
    
    // 发送真正的请求
    return fetch(context.url, context.options);
}
```

### 4.3 实用的中间件集合


```javascript
// 常用中间件集合
const Middlewares = {
    // 基础URL中间件
    baseUrl: (baseUrl) => (context) => {
        if (!context.url.startsWith('http')) {
            context.url = baseUrl + context.url;
        }
        return context;
    },
    
    // 超时控制中间件
    timeout: (ms) => (context) => {
        const controller = new AbortController();
        
        setTimeout(() => {
            controller.abort();
        }, ms);
        
        context.options.signal = controller.signal;
        return context;
    },
    
    // 重试中间件
    retry: (maxRetries) => async (context) => {
        context.retryCount = 0;
        context.maxRetries = maxRetries;
        return context;
    },
    
    // 缓存中间件（简单版）
    cache: () => {
        const cache = new Map();
        
        return async (context) => {
            const key = context.url + JSON.stringify(context.options);
            
            // 如果是GET请求且有缓存，直接返回
            if (!context.options.method || context.options.method === 'GET') {
                if (cache.has(key)) {
                    console.log('📦 使用缓存数据');
                    context.cachedResponse = cache.get(key);
                    return context;
                }
            }
            
            // 记录这次请求，用于缓存响应
            context.cacheKey = key;
            context.cache = cache;
            return context;
        };
    }
};

// 使用预定义的中间件
const api = new MiddlewareManager();
api.use(Middlewares.baseUrl('https://api.example.com'))
   .use(Middlewares.timeout(5000))
   .use(Middlewares.cache())
   .use(authMiddleware);
```

---

## 5. 🛠️ 实战封装 - 打造自己的fetch工具


### 5.1 完整的fetch封装类


```javascript
// 完整的API客户端
class ApiClient {
    constructor(baseUrl = '') {
        this.baseUrl = baseUrl;
        this.middlewares = [];
        this.defaultOptions = {
            headers: {
                'Content-Type': 'application/json'
            }
        };
    }
    
    // 添加中间件
    use(middleware) {
        this.middlewares.push(middleware);
        return this;
    }
    
    // 设置默认配置
    setDefaults(options) {
        this.defaultOptions = { ...this.defaultOptions, ...options };
        return this;
    }
    
    // 核心请求方法
    async request(url, options = {}) {
        // 合并默认配置
        options = { ...this.defaultOptions, ...options };
        
        // 处理完整URL
        if (!url.startsWith('http')) {
            url = this.baseUrl + url;
        }
        
        // 执行请求拦截器
        let context = { url, options };
        for (let middleware of this.middlewares) {
            context = await middleware(context);
            
            // 如果中间件返回了缓存响应，直接返回
            if (context.cachedResponse) {
                return context.cachedResponse;
            }
        }
        
        try {
            // 发送请求
            const response = await fetch(context.url, context.options);
            
            // 执行响应拦截器
            const result = await this.handleResponse(response);
            
            // 如果有缓存配置，保存到缓存
            if (context.cache && context.cacheKey) {
                context.cache.set(context.cacheKey, result);
            }
            
            return result;
            
        } catch (error) {
            console.error('❌ 请求失败:', error.message);
            throw error;
        }
    }
    
    // 响应处理
    async handleResponse(response) {
        if (!response.ok) {
            const error = await response.text();
            throw new Error(`HTTP ${response.status}: ${error}`);
        }
        
        const contentType = response.headers.get('content-type');
        
        if (contentType && contentType.includes('application/json')) {
            return response.json();
        }
        
        return response.text();
    }
    
    // 便捷方法
    get(url, options = {}) {
        return this.request(url, { ...options, method: 'GET' });
    }
    
    post(url, data, options = {}) {
        return this.request(url, {
            ...options,
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
    
    put(url, data, options = {}) {
        return this.request(url, {
            ...options,
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
    
    delete(url, options = {}) {
        return this.request(url, { ...options, method: 'DELETE' });
    }
}
```

### 5.2 实际使用示例


```javascript
// 创建API客户端实例
const api = new ApiClient('https://api.example.com');

// 添加认证中间件
api.use((context) => {
    const token = localStorage.getItem('token');
    if (token) {
        context.options.headers = {
            ...context.options.headers,
            'Authorization': `Bearer ${token}`
        };
    }
    return context;
});

// 添加日志中间件
api.use((context) => {
    console.log(`🚀 ${context.options.method || 'GET'} ${context.url}`);
    return context;
});

// 现在可以很方便地使用了
async function fetchUserProfile() {
    try {
        const user = await api.get('/user/profile');
        console.log('用户信息:', user);
        return user;
    } catch (error) {
        console.error('获取用户信息失败:', error.message);
    }
}

async function updateUser(userData) {
    try {
        const result = await api.put('/user/profile', userData);
        console.log('更新成功:', result);
        return result;
    } catch (error) {
        console.error('更新失败:', error.message);
    }
}

// 使用示例
fetchUserProfile();
updateUser({ name: '张三', email: 'zhangsan@example.com' });
```

### 5.3 支持链式调用和async/await


```javascript
// 支持多种调用方式的API客户端
class FlexibleApiClient extends ApiClient {
    // 创建请求构建器，支持链式调用
    create(url) {
        return new RequestBuilder(this, url);
    }
}

class RequestBuilder {
    constructor(client, url) {
        this.client = client;
        this.url = url;
        this.options = {};
    }
    
    // 设置请求头
    headers(headers) {
        this.options.headers = { ...this.options.headers, ...headers };
        return this;
    }
    
    // 设置请求体
    body(data) {
        this.options.body = JSON.stringify(data);
        return this;
    }
    
    // 设置查询参数
    query(params) {
        const url = new URL(this.url, this.client.baseUrl);
        Object.keys(params).forEach(key => {
            url.searchParams.append(key, params[key]);
        });
        this.url = url.toString();
        return this;
    }
    
    // 执行GET请求
    get() {
        return this.client.request(this.url, { ...this.options, method: 'GET' });
    }
    
    // 执行POST请求
    post(data) {
        if (data) {
            this.body(data);
        }
        return this.client.request(this.url, { ...this.options, method: 'POST' });
    }
    
    // 执行PUT请求
    put(data) {
        if (data) {
            this.body(data);
        }
        return this.client.request(this.url, { ...this.options, method: 'PUT' });
    }
    
    // 执行DELETE请求
    delete() {
        return this.client.request(this.url, { ...this.options, method: 'DELETE' });
    }
}

// 使用示例 - 链式调用
const api = new FlexibleApiClient('https://api.example.com');

// 方式1：链式调用
api.create('/users')
   .query({ page: 1, limit: 10 })
   .headers({ 'Custom-Header': 'value' })
   .get()
   .then(users => console.log(users));

// 方式2：async/await
async function getUsers() {
    const users = await api.create('/users')
                           .query({ page: 1, limit: 10 })
                           .get();
    return users;
}

// 方式3：传统方式
api.get('/users?page=1&limit=10')
   .then(users => console.log(users));
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 拦截器本质：在请求发送前/响应返回后进行统一处理
🔸 请求拦截器：主要用于添加认证、设置公共参数、日志记录
🔸 响应拦截器：主要用于错误处理、数据格式化、状态码处理
🔸 中间件模式：将功能拆分成独立的模块，可自由组合
🔸 封装价值：减少重复代码，提高开发效率，统一处理标准
```

### 6.2 关键理解要点


**🔹 拦截器 vs 中间件的区别**
```
拦截器：更像是钩子函数，在特定时机执行
中间件：更像是管道处理，数据经过每一层处理

拦截器侧重：统一处理、自动化
中间件侧重：功能模块化、灵活组合
```

**🔹 什么时候使用拦截器**
```
✅ 适用场景：
- 每个请求都需要添加token
- 统一的错误处理逻辑
- 请求日志记录
- 数据格式标准化

❌ 不适用场景：
- 只有个别请求需要的特殊处理
- 业务逻辑相关的数据处理
- 复杂的条件判断逻辑
```

**🔹 实际开发中的最佳实践**
```
1. 保持拦截器功能单一：一个拦截器只做一件事
2. 避免过度封装：不要为了封装而封装
3. 错误处理要友好：给用户清晰的错误提示
4. 性能考虑：避免在拦截器中做耗时操作
5. 可配置化：重要参数应该可以配置
```

### 6.3 实际应用价值


**💼 企业开发实战**
- **团队协作**：统一的请求处理标准，减少沟通成本
- **代码质量**：减少重复代码，提高代码复用性
- **维护效率**：集中处理公共逻辑，修改一处全局生效
- **用户体验**：统一的错误处理和加载状态管理

**🚀 个人技能提升**
- **架构思维**：学会用模块化思维解决问题
- **设计模式**：掌握拦截器和中间件两种重要模式
- **工程化**：理解前端工程化中的基础设施建设
- **问题解决**：提高解决跨域、认证等常见问题的能力

### 6.4 常见问题与解决方案


**⚠️ 新手容易踩的坑**
```
1. 拦截器中的异步处理：记得用async/await
2. 请求头的合并：不要覆盖原有的headers
3. 错误处理的层级：区分HTTP错误和业务错误
4. 内存泄漏：及时清理定时器和事件监听
```

**💡 调试技巧**
```
1. 在拦截器中添加console.log查看数据流
2. 使用浏览器Network面板查看实际请求
3. 单独测试每个中间件的功能
4. 逐步添加中间件，定位问题
```

**核心记忆口诀**：
```
拦截器像守门员，统一处理是关键
请求拦截加头信息，响应拦截处理错误
中间件像积木块，自由组合功能多
封装一次到处用，提升效率真不错
```