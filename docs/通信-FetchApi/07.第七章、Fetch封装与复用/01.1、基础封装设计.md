---
title: 1、基础封装设计
---
## 📚 目录

1. [为什么要封装Fetch](#1-为什么要封装Fetch)
2. [封装设计的基本原则](#2-封装设计的基本原则)
3. [基础封装函数实现](#3-基础封装函数实现)
4. [通用配置的抽取](#4-通用配置的抽取)
5. [简化调用方式设计](#5-简化调用方式设计)
6. [封装的好处与注意事项](#6-封装的好处与注意事项)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 为什么要封装Fetch


### 1.1 原生Fetch的痛点


**🔸 重复代码太多**
```javascript
// 每次请求都要写这么多重复代码
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({name: 'john'})
})
.then(response => {
  if (!response.ok) {
    throw new Error('请求失败');
  }
  return response.json();
})
.then(data => console.log(data))
.catch(error => console.error(error));

// 另一个请求又要重复写一遍...
fetch('/api/products', {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer token123'
  }
})
.then(response => response.json())
// ...又是同样的处理逻辑
```

**🔸 配置管理混乱**
```
问题分析：
❌ 每个请求都要单独配置headers
❌ 基础URL要反复写
❌ 错误处理逻辑到处重复
❌ 没有统一的数据格式处理
❌ 团队成员写法不一致
```

### 1.2 封装解决的核心问题


**💡 简单理解：就像做菜一样**
```
不封装 = 每次做菜都要：
  ① 准备锅碗瓢盆
  ② 洗菜切菜
  ③ 调料一样样加
  ④ 收拾厨房

封装后 = 有了万能调料包：
  ① 直接下锅炒
  ② 自动调味
  ③ 省时省力
```

**🎯 封装的核心价值**
- **消除重复**：写一次代码，到处使用
- **统一标准**：团队用同样的方式发请求
- **简化调用**：复杂逻辑变成简单调用
- **易于维护**：改一个地方，全项目生效

---

## 2. 📐 封装设计的基本原则


### 2.1 设计原则总览


**🔸 核心设计思想**
```
简单易用原则：
  使用者不需要了解内部复杂逻辑
  只关心："我要请求什么数据"

一致性原则：
  所有请求用统一的方式调用
  返回格式保持一致

可配置原则：
  常用配置有默认值
  特殊需求可以自定义
```

### 2.2 封装层次设计


```
封装层次图：
┌─────────────────────────┐
│     业务调用层           │ ← getUserList()
├─────────────────────────┤
│     方法封装层           │ ← get(), post()
├─────────────────────────┤
│     基础封装层           │ ← request()
├─────────────────────────┤
│     原生Fetch层          │ ← fetch()
└─────────────────────────┘

层次说明：
🔹 基础封装层：处理通用逻辑（错误、格式化等）
🔹 方法封装层：按HTTP方法分类（GET、POST等）
🔹 业务调用层：具体业务接口（获取用户、商品等）
```

### 2.3 参数设计原则


**🎯 参数优先级**
```javascript
参数合并顺序（后者覆盖前者）：
默认配置 → 全局配置 → 当前请求配置

示例理解：
1. 默认配置：所有请求都带Content-Type
2. 全局配置：项目中都带Authorization
3. 当前配置：这次请求特殊的header
```

---

## 3. 🔧 基础封装函数实现


### 3.1 最简单的封装


**🔸 第一步：抽取基础request函数**
```javascript
// 基础封装 - 解决重复代码问题
function request(url, options = {}) {
  // 设置默认配置
  const defaultOptions = {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json'
    }
  };
  
  // 合并配置（用户配置覆盖默认配置）
  const finalOptions = {
    ...defaultOptions,
    ...options,
    headers: {
      ...defaultOptions.headers,
      ...options.headers
    }
  };
  
  // 发起请求
  return fetch(url, finalOptions)
    .then(response => {
      // 统一处理响应状态
      if (!response.ok) {
        throw new Error(`请求失败: ${response.status}`);
      }
      return response.json();
    });
}
```

**💡 使用对比**
```javascript
// ❌ 原来的写法（重复且复杂）
fetch('/api/users', {
  method: 'GET',
  headers: {'Content-Type': 'application/json'}
})
.then(response => {
  if (!response.ok) throw new Error('失败');
  return response.json();
});

// ✅ 封装后的写法（简洁明了）
request('/api/users');
```

### 3.2 支持动态参数配置


**🔸 灵活的参数设计**
```javascript
function request(url, options = {}) {
  const {
    method = 'GET',
    data = null,
    headers = {},
    ...otherOptions
  } = options;
  
  // 构建请求配置
  const config = {
    method,
    headers: {
      'Content-Type': 'application/json',
      ...headers  // 用户自定义headers会覆盖默认的
    },
    ...otherOptions
  };
  
  // 如果有数据需要发送
  if (data) {
    if (method === 'GET') {
      // GET请求把数据转为查询参数
      const params = new URLSearchParams(data);
      url += (url.includes('?') ? '&' : '?') + params;
    } else {
      // POST等请求把数据放在body中
      config.body = JSON.stringify(data);
    }
  }
  
  return fetch(url, config)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    });
}
```

**🎯 实际使用示例**
```javascript
// GET请求 - 自动转查询参数
request('/api/users', {
  method: 'GET',
  data: { page: 1, size: 10 }
});
// 实际请求：/api/users?page=1&size=10

// POST请求 - 自动转JSON
request('/api/users', {
  method: 'POST',
  data: { name: 'john', age: 25 }
});
// body: {"name":"john","age":25}

// 自定义headers
request('/api/users', {
  headers: {
    'Authorization': 'Bearer token123'
  }
});
```

---

## 4. 🎛️ 通用配置的抽取


### 4.1 全局配置管理


**🔸 配置对象设计**
```javascript
// 全局配置对象
const apiConfig = {
  // 基础URL配置
  baseURL: 'https://api.example.com',
  
  // 默认请求头
  defaultHeaders: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  },
  
  // 超时设置
  timeout: 10000,
  
  // 错误处理配置
  errorHandler: {
    showError: true,
    logError: true
  }
};

// 设置全局配置的函数
function setGlobalConfig(config) {
  Object.assign(apiConfig, config);
}
```

**💡 配置使用方法**
```javascript
// 项目初始化时设置全局配置
setGlobalConfig({
  baseURL: 'https://myapi.com/v1',
  defaultHeaders: {
    'Authorization': 'Bearer ' + getToken()
  }
});

// 之后所有请求都会自动使用这些配置
request('/users');  // 实际请求：https://myapi.com/v1/users
```

### 4.2 智能URL处理


**🔸 自动拼接基础URL**
```javascript
function buildFullURL(url) {
  // 如果已经是完整URL，直接返回
  if (url.startsWith('http://') || url.startsWith('https://')) {
    return url;
  }
  
  // 否则拼接基础URL
  const baseURL = apiConfig.baseURL || '';
  
  // 处理URL拼接的斜杠问题
  if (baseURL.endsWith('/') && url.startsWith('/')) {
    return baseURL + url.slice(1);  // 去掉重复的斜杠
  }
  
  if (!baseURL.endsWith('/') && !url.startsWith('/')) {
    return baseURL + '/' + url;     // 补充缺失的斜杠
  }
  
  return baseURL + url;
}

// 使用示例
console.log(buildFullURL('/users'));     // https://api.com/users
console.log(buildFullURL('users'));      // https://api.com/users  
console.log(buildFullURL('http://other.com/api')); // http://other.com/api
```

### 4.3 请求头智能合并


**🔸 三层配置合并**
```javascript
function mergeHeaders(globalHeaders, requestHeaders) {
  return {
    ...apiConfig.defaultHeaders,  // 1. 系统默认
    ...globalHeaders,             // 2. 全局配置
    ...requestHeaders             // 3. 当前请求（优先级最高）
  };
}

// 实际效果演示
/*
系统默认：{'Content-Type': 'application/json'}
全局配置：{'Authorization': 'Bearer token123'}
当前请求：{'Content-Type': 'text/plain'}

最终结果：{
  'Content-Type': 'text/plain',     ← 当前请求覆盖了默认值
  'Authorization': 'Bearer token123' ← 保留全局配置
}
*/
```

---

## 5. 🚀 简化调用方式设计


### 5.1 按HTTP方法分类封装


**🔸 常用方法快捷函数**
```javascript
// 基于request函数创建快捷方法
const api = {
  // GET请求 - 获取数据
  get(url, params = {}) {
    return request(url, {
      method: 'GET',
      data: params
    });
  },
  
  // POST请求 - 创建数据
  post(url, data = {}) {
    return request(url, {
      method: 'POST',
      data: data
    });
  },
  
  // PUT请求 - 更新数据
  put(url, data = {}) {
    return request(url, {
      method: 'PUT',
      data: data
    });
  },
  
  // DELETE请求 - 删除数据
  delete(url) {
    return request(url, {
      method: 'DELETE'
    });
  }
};
```

**🎯 调用对比**
```javascript
// ❌ 原来的写法
request('/users', {method: 'GET', data: {page: 1}});
request('/users', {method: 'POST', data: {name: 'john'}});

// ✅ 简化后的写法
api.get('/users', {page: 1});
api.post('/users', {name: 'john'});
```

### 5.2 业务接口封装


**🔸 按业务模块分组**
```javascript
// 用户相关接口
const userAPI = {
  // 获取用户列表
  getList(params) {
    return api.get('/users', params);
  },
  
  // 获取单个用户
  getById(id) {
    return api.get(`/users/${id}`);
  },
  
  // 创建用户
  create(userData) {
    return api.post('/users', userData);
  },
  
  // 更新用户
  update(id, userData) {
    return api.put(`/users/${id}`, userData);
  },
  
  // 删除用户
  delete(id) {
    return api.delete(`/users/${id}`);
  }
};

// 商品相关接口
const productAPI = {
  getList: (params) => api.get('/products', params),
  getById: (id) => api.get(`/products/${id}`),
  // ... 其他方法
};
```

**💡 业务调用示例**
```javascript
// 组件中使用 - 语义清晰
async function loadUserData() {
  try {
    // 获取用户列表
    const users = await userAPI.getList({page: 1, size: 10});
    
    // 获取具体用户信息
    const user = await userAPI.getById(123);
    
    console.log('用户数据:', users, user);
  } catch (error) {
    console.error('加载失败:', error.message);
  }
}
```

---

## 6. ✅ 封装的好处与注意事项


### 6.1 封装带来的好处


**🎯 开发效率提升**
```
代码对比：

❌ 没有封装（每次20行代码）：
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  body: JSON.stringify(data)
})
.then(response => {
  if (!response.ok) throw new Error('失败');
  return response.json();
})
.then(data => handleSuccess(data))
.catch(error => handleError(error));

✅ 有封装（1行代码）：
userAPI.create(data).then(handleSuccess).catch(handleError);

效率提升：20倍！
```

**🔧 维护性提升**
```
场景：需要给所有接口添加新的请求头

❌ 没有封装：
  需要修改项目中100+个fetch调用

✅ 有封装：
  只需要修改封装函数中的1行代码
  全项目自动生效
```

### 6.2 团队协作优势


**📋 统一开发规范**
```
团队效益：

一致性：
  ✓ 所有人用相同方式发请求
  ✓ 错误处理逻辑统一
  ✓ 代码风格保持一致

协作性：
  ✓ 新人快速上手
  ✓ 代码审查更容易
  ✓ 项目交接更顺畅

可扩展性：
  ✓ 添加新功能只改一个地方
  ✓ 接口变更影响范围可控
```

### 6.3 注意事项与最佳实践


**⚠️ 封装注意事项**
```
适度封装原则：
  ✓ 解决实际问题，不要过度设计
  ✓ 保持简单易用，避免复杂配置
  ✓ 考虑项目规模，小项目简单封装即可

灵活性保持：
  ✓ 保留原生fetch的能力
  ✓ 特殊需求能够自定义
  ✓ 不要限制住开发者的手脚

版本兼容性：
  ✓ 接口变更要考虑向后兼容
  ✓ 提供版本升级指南
  ✓ 逐步弃用旧接口，不要突然删除
```

**🎯 最佳实践建议**
```javascript
// ✓ 好的封装：简单直观
api.get('/users');
api.post('/users', userData);

// ❌ 过度封装：复杂难懂  
api.request({
  endpoint: 'users',
  method: 'GET',
  transform: 'auto',
  cache: 'smart',
  retry: {count: 3, delay: 1000}
});
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 封装目的：消除重复代码，统一开发规范，提升开发效率
🔸 设计原则：简单易用、一致性、可配置性
🔸 封装层次：基础层 → 方法层 → 业务层
🔸 配置管理：默认配置 → 全局配置 → 请求配置
🔸 核心价值：代码复用、团队协作、维护便利
```

### 7.2 关键理解要点


**🔹 为什么要封装**
```
本质问题：原生fetch使用繁琐，重复代码多
解决方案：提取公共逻辑，简化调用方式
核心收益：开发效率提升，代码质量提高
```

**🔹 如何设计封装**
```
设计思路：从使用者角度出发，让调用更简单
技术要点：参数合并、配置分层、方法分类
实现关键：保持灵活性，避免过度封装
```

**🔹 封装的价值体现**
```
个人层面：写代码更快，出错更少
团队层面：规范统一，协作更顺畅  
项目层面：维护成本低，扩展性好
```

### 7.3 实际应用指导


**🎯 封装设计建议**
- **从简单开始**：先解决最常见的重复问题
- **逐步完善**：根据实际需求增加功能
- **保持克制**：不要一次性设计得太复杂
- **文档完善**：让团队成员知道怎么用

**🔧 使用最佳实践**
- **统一调用**：团队统一使用封装后的接口
- **合理配置**：全局配置常用参数，特殊需求单独设置
- **错误处理**：在封装层统一处理常见错误
- **持续优化**：根据使用反馈不断改进封装函数

**核心记忆**：
- 封装就是把复杂的变简单，重复的变复用
- 好的封装让开发者专注业务逻辑，而不是技术细节  
- 设计封装要站在使用者角度，追求简洁易用
- 封装不是一次性工程，需要在使用中不断完善