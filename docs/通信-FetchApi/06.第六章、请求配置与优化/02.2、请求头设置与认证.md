---
title: 2、请求头设置与认证
---
## 📚 目录

1. [什么是请求头](#1-什么是请求头)
2. [常用请求头的设置](#2-常用请求头的设置)
3. [认证头的设置](#3-认证头的设置)
4. [JWT Token的实际应用](#4-JWT-Token的实际应用)
5. [Token存储与自动化](#5-Token存储与自动化)
6. [实战案例：用户认证](#6-实战案例用户认证)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 什么是请求头


### 1.1 请求头的本质


**通俗理解：请求头就像是快递包裹上的标签**

```
普通快递包裹标签：              HTTP请求头：
┌─────────────────────┐        ┌─────────────────────┐
│ 收件人：张三         │        │ Content-Type: JSON   │
│ 寄件人：李四         │        │ Authorization: Token │
│ 物品：图书          │        │ Accept: application  │
│ 重要程度：普通       │        │ User-Agent: Chrome   │
└─────────────────────┘        └─────────────────────┘

告诉快递员如何处理包裹          告诉服务器如何处理请求
```

### 1.2 为什么需要请求头


💡 **核心作用**：
- **身份识别** - 告诉服务器"我是谁"
- **数据格式** - 告诉服务器"我发送的是什么格式"
- **权限验证** - 证明"我有访问权限"
- **浏览器信息** - 说明"我用的什么浏览器"

### 1.3 headers 属性的基本用法


```javascript
// 最简单的请求头设置
fetch('/api/data', {
  headers: {
    'Content-Type': 'application/json'
  }
})
```

💡 **理解要点**：
- `headers` 是一个对象，里面放各种"标签"
- 每个标签都是 `键: 值` 的格式
- 服务器读取这些标签来决定如何处理请求

---

## 2. 📋 常用请求头的设置


### 2.1 Content-Type：告诉服务器数据格式


**Content-Type 就像是告诉厨师你送来的是什么食材**

| Content-Type 类型 | 含义 | 什么时候用 |
|-------------------|------|------------|
| `application/json` | JSON格式数据 | 发送对象、数组等结构化数据 |
| `application/x-www-form-urlencoded` | 表单格式 | 模拟HTML表单提交 |
| `multipart/form-data` | 文件上传格式 | 上传图片、文件等 |
| `text/plain` | 纯文本 | 发送简单文本 |

### 2.2 实际应用示例


**📤 发送JSON数据**
```javascript
// 向服务器发送用户信息
const userData = {
  name: '张三',
  age: 25,
  email: 'zhangsan@email.com'
}

fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'  // 告诉服务器：我发的是JSON
  },
  body: JSON.stringify(userData)  // 把对象转成JSON字符串
})
```

**📝 发送表单数据**
```javascript
// 模拟表单提交
const formData = new URLSearchParams()
formData.append('username', '张三')
formData.append('password', '123456')

fetch('/api/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: formData
})
```

### 2.3 Accept：告诉服务器你想要什么格式


```javascript
fetch('/api/data', {
  headers: {
    'Accept': 'application/json'  // 我希望服务器返回JSON格式
  }
})
```

💡 **生活类比**：就像去餐厅点餐时说"我要中式炒饭"，告诉服务员你想要什么。

---

## 3. 🔐 认证头的设置


### 3.1 什么是认证头


**认证头就像是门禁卡或会员卡**

```
现实生活中：                    网络请求中：
┌─────────────────┐            ┌─────────────────────┐
│    员工卡       │            │ Authorization: xxx   │
│ 姓名：张三      │            │ Bearer eyJ0eXAi...   │
│ 部门：技术部    │            │                     │
│ 权限：可进实验室 │            │ 证明我有访问权限      │
└─────────────────┘            └─────────────────────┘
```

### 3.2 Authorization 头的设置


**🔑 最常用的认证方式：Bearer Token**

```javascript
// 设置认证头
fetch('/api/user/profile', {
  headers: {
    'Authorization': 'Bearer eyJ0eXAiOiJKV1QiLCJhbGc...'
  }
})
```

**🔍 格式解析**：
- `Bearer` - 认证类型（就像说"这是员工卡"）
- `eyJ0eXAi...` - 实际的token（具体的卡号）

### 3.3 不同认证方式对比


```javascript
// 1. Bearer Token（最常用）
headers: {
  'Authorization': 'Bearer ' + token
}

// 2. Basic认证（用户名密码）
headers: {
  'Authorization': 'Basic ' + btoa('username:password')
}

// 3. 自定义token头
headers: {
  'X-Auth-Token': token,
  'X-API-Key': apiKey
}
```

---

## 4. 🎫 JWT Token的实际应用


### 4.1 什么是JWT Token


**JWT就像是一张特殊的"通行证"**

```
普通门票：                      JWT Token：
┌─────────────────┐            ┌─────────────────────────┐
│   电影票        │            │ eyJ0eXAiOiJKV1QiLCJhbGc │
│ 座位：A12       │            │ 包含：用户ID、权限、过期时间 │
│ 场次：晚上8点   │            │ 自带验证信息，无需查库    │
│ 有效期：今天    │            │ 服务器可直接验证真伪      │
└─────────────────┘            └─────────────────────────┘
```

### 4.2 JWT Token的获取和使用流程


```
用户登录流程：
┌─────────┐  1.登录  ┌─────────┐  2.验证  ┌─────────┐
│  前端   │ -------> │  服务器 │ -------> │ 数据库  │
│         │          │         │          │         │
│         │ <------- │         │ <------- │         │
└─────────┘ 3.返回token └─────────┘ 验证成功 └─────────┘

后续请求：
┌─────────┐  带token ┌─────────┐  验证token ┌─────────┐
│  前端   │ -------> │  服务器 │ ---------> │  业务   │
│         │          │         │            │  处理   │
│         │ <------- │         │ <--------- │         │
└─────────┘  返回数据 └─────────┘   返回结果  └─────────┘
```

### 4.3 实际登录和使用示例


```javascript
// 步骤1：用户登录获取token
async function login(username, password) {
  try {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        username: username,
        password: password
      })
    })
    
    const data = await response.json()
    
    if (response.ok) {
      // 登录成功，保存token
      localStorage.setItem('token', data.token)
      console.log('登录成功！')
      return data.token
    } else {
      throw new Error(data.message || '登录失败')
    }
  } catch (error) {
    console.error('登录出错：', error.message)
  }
}

// 步骤2：使用token请求用户资料
async function getUserProfile() {
  const token = localStorage.getItem('token')
  
  if (!token) {
    console.log('请先登录')
    return
  }
  
  try {
    const response = await fetch('/api/user/profile', {
      headers: {
        'Authorization': `Bearer ${token}`  // 带上认证头
      }
    })
    
    if (response.ok) {
      const userProfile = await response.json()
      console.log('用户资料：', userProfile)
      return userProfile
    } else {
      throw new Error('获取用户资料失败')
    }
  } catch (error) {
    console.error('请求出错：', error.message)
  }
}
```

---

## 5. 💾 Token存储与自动化


### 5.1 Token存储方案对比


| 存储方式 | 特点 | 适用场景 | 注意事项 |
|---------|------|----------|----------|
| **localStorage** | 永久保存，关闭浏览器不丢失 | 长期登录 | 注意安全性 |
| **sessionStorage** | 关闭浏览器就清除 | 临时登录 | 更安全但不便利 |
| **内存变量** | 刷新页面就丢失 | 测试环境 | 用户体验差 |

### 5.2 localStorage vs sessionStorage 实际对比


```javascript
// localStorage：像把东西放在家里的保险箱
localStorage.setItem('token', 'abc123')  // 一直保存
localStorage.getItem('token')            // 随时可以拿到

// sessionStorage：像把东西放在口袋里
sessionStorage.setItem('token', 'abc123')  // 关浏览器就没了
sessionStorage.getItem('token')            // 只在当前会话有效
```

### 5.3 自动添加认证头的方法


**🚀 创建一个智能的fetch函数**

```javascript
// 封装带认证的请求函数
function authFetch(url, options = {}) {
  // 获取保存的token
  const token = localStorage.getItem('token')
  
  // 如果有token，自动添加到请求头
  if (token) {
    options.headers = {
      ...options.headers,  // 保留原有的头
      'Authorization': `Bearer ${token}`  // 添加认证头
    }
  }
  
  return fetch(url, options)
}

// 使用起来很简单，不用每次都写Authorization
authFetch('/api/user/profile')  // 自动带token
authFetch('/api/data', {        // 也可以加其他配置
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({name: '张三'})
})
```

### 5.4 Token过期的处理策略


```javascript
// 智能处理token过期
async function smartAuthFetch(url, options = {}) {
  const token = localStorage.getItem('token')
  
  if (token) {
    options.headers = {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  }
  
  const response = await fetch(url, options)
  
  // 如果返回401，说明token过期了
  if (response.status === 401) {
    console.log('登录已过期，请重新登录')
    localStorage.removeItem('token')  // 清除过期token
    // 跳转到登录页
    window.location.href = '/login'
    return
  }
  
  return response
}
```

---

## 6. 🎯 实战案例：用户认证


### 6.1 完整的用户认证流程


```javascript
// 用户认证管理类
class AuthManager {
  constructor() {
    this.tokenKey = 'user_token'
  }
  
  // 登录
  async login(username, password) {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ username, password })
      })
      
      const result = await response.json()
      
      if (response.ok) {
        // 保存token
        this.saveToken(result.token)
        console.log('✅ 登录成功')
        return true
      } else {
        console.error('❌ 登录失败：', result.message)
        return false
      }
    } catch (error) {
      console.error('❌ 网络错误：', error.message)
      return false
    }
  }
  
  // 保存token
  saveToken(token) {
    localStorage.setItem(this.tokenKey, token)
  }
  
  // 获取token
  getToken() {
    return localStorage.getItem(this.tokenKey)
  }
  
  // 检查是否已登录
  isLoggedIn() {
    return !!this.getToken()
  }
  
  // 退出登录
  logout() {
    localStorage.removeItem(this.tokenKey)
    console.log('✅ 已退出登录')
  }
  
  // 带认证的请求
  async authRequest(url, options = {}) {
    const token = this.getToken()
    
    if (!token) {
      console.error('❌ 未登录，请先登录')
      return null
    }
    
    // 添加认证头
    options.headers = {
      ...options.headers,
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
    
    try {
      const response = await fetch(url, options)
      
      if (response.status === 401) {
        console.error('❌ 登录已过期')
        this.logout()
        return null
      }
      
      return response
    } catch (error) {
      console.error('❌ 请求失败：', error.message)
      return null
    }
  }
}
```

### 6.2 实际使用示例


```javascript
// 创建认证管理器
const auth = new AuthManager()

// 使用示例
async function example() {
  // 1. 用户登录
  const loginSuccess = await auth.login('zhangsan', '123456')
  
  if (loginSuccess) {
    // 2. 获取用户资料
    const response = await auth.authRequest('/api/user/profile')
    if (response && response.ok) {
      const profile = await response.json()
      console.log('👤 用户资料：', profile)
    }
    
    // 3. 更新用户信息
    const updateResponse = await auth.authRequest('/api/user/update', {
      method: 'PUT',
      body: JSON.stringify({
        name: '张三',
        email: 'zhangsan@example.com'
      })
    })
    
    if (updateResponse && updateResponse.ok) {
      console.log('✅ 信息更新成功')
    }
  }
}
```

### 6.3 常见的请求头组合


```javascript
// 📱 移动端API请求
const mobileHeaders = {
  'Content-Type': 'application/json',
  'Authorization': `Bearer ${token}`,
  'User-Agent': 'MyApp/1.0',
  'X-Platform': 'mobile'
}

// 🌐 Web端API请求  
const webHeaders = {
  'Content-Type': 'application/json',
  'Authorization': `Bearer ${token}`,
  'X-Requested-With': 'XMLHttpRequest'
}

// 📁 文件上传请求
const uploadHeaders = {
  'Authorization': `Bearer ${token}`
  // 注意：上传文件时不要设置Content-Type，让浏览器自动设置
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 请求头本质：给HTTP请求贴标签，告诉服务器如何处理
🔸 Content-Type：说明发送的数据格式（JSON、表单、文件等）
🔸 Authorization：身份验证，证明你有访问权限
🔸 Bearer Token：最常用的认证方式，像一张电子通行证
🔸 JWT：包含用户信息的智能token，自带验证功能
```

### 7.2 关键理解要点


**🔹 请求头的作用机制**
```
理解要点：
- 请求头 = 快递标签，告诉服务器如何处理
- 必须设置正确的Content-Type，否则服务器无法解析
- Authorization是身份证，没有就无法访问受保护的资源
```

**🔹 Token的生命周期管理**
```
完整流程：
1. 登录 → 获取token
2. 存储 → localStorage/sessionStorage
3. 使用 → 每次请求带上Authorization头
4. 过期 → 检测401状态码，重新登录
5. 退出 → 清除存储的token
```

**🔹 常见错误和解决方案**
```
❌ 忘记设置Content-Type → 服务器无法解析数据
✅ 根据数据类型设置正确的Content-Type

❌ token格式错误 → 认证失败
✅ 使用标准格式：Bearer + 空格 + token

❌ token过期未处理 → 用户体验差
✅ 监听401状态码，自动跳转登录
```

### 7.3 实际应用价值


**🎯 业务场景应用**
- **用户系统**：登录认证、个人资料管理
- **权限控制**：不同用户访问不同接口
- **API调用**：第三方服务集成认证
- **文件操作**：上传下载权限验证

**🔧 开发实践**
- **封装请求**：创建统一的认证请求函数
- **错误处理**：优雅处理token过期和网络异常
- **安全存储**：选择合适的token存储方案
- **用户体验**：自动重试和友好的错误提示

**💡 最佳实践口诀**：
```
请求头要设对，Content-Type不能少
Bearer Token带好，Authorization少不了
localStorage存储，sessionStorage更安全
封装函数用，错误处理要跟上
```

**核心记忆**：
- 请求头像快递标签，告诉服务器怎么处理
- Authorization是身份证，Bearer Token是通行证
- 登录得到token，请求都要带着它
- 401表示过期，清除token重登录