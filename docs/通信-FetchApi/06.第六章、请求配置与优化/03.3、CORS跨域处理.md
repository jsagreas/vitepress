---
title: 3、CORS跨域处理
---
## 📚 目录

1. [什么是跨域问题](#1-什么是跨域问题)
2. [同源策略详解](#2-同源策略详解)
3. [CORS解决方案](#3-CORS解决方案)
4. [Fetch中的CORS配置](#4-Fetch中的CORS配置)
5. [简单请求vs复杂请求](#5-简单请求vs复杂请求)
6. [credentials配置详解](#6-credentials配置详解)
7. [预检请求处理](#7-预检请求处理)
8. [跨域错误调试](#8-跨域错误调试)
9. [实际应用案例](#9-实际应用案例)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🚫 什么是跨域问题


### 1.1 生活中的类比理解


想象一下，你在家里想要隔壁邻居家的东西，你不能直接翻墙过去拿，需要敲门得到允许才行。**跨域问题就是浏览器的这种"安全门禁"机制**。

```
你的网站：http://localhost:3000     （你的家）
目标API：https://api.weather.com    （邻居家）
浏览器：🚫 "不行！你们不是一家人，不能随便拿东西！"
```

### 1.2 什么时候会遇到跨域


**简单说：当你的网页想要请求另一个域名的数据时，就会遇到跨域问题。**

```javascript
// 这会产生跨域问题！
// 你的网站在 localhost:3000
fetch('https://api.github.com/users') 
  .then(response => response.json())
  .catch(error => {
    console.log('跨域错误:', error);
    // 典型错误：Access to fetch has been blocked by CORS policy
  });
```

> 💡 **新手提示**  
> 跨域只存在于浏览器中！如果你用 Node.js 或 Postman 测试，不会有跨域问题。

---

## 2. 🔒 同源策略详解


### 2.1 什么叫"同源"


**同源就是"三个相同"**：协议、域名、端口都一样，就像住在同一栋楼的同一层。

```
判断同源的三要素：
┌─────────────────────────────────────┐
│ https://www.example.com:443/api     │
│   ↑         ↑            ↑         │
│ 协议      域名         端口         │
└─────────────────────────────────────┘
```

### 2.2 同源判断实例


| 当前页面 | 目标地址 | 是否同源 | 原因 |
|---------|---------|----------|------|
| `http://localhost:3000` | `http://localhost:3000/api` | ✅ **同源** | 三要素完全相同 |
| `http://localhost:3000` | `http://localhost:8080/api` | ❌ **跨域** | 端口不同 (3000 vs 8080) |
| `http://localhost:3000` | `https://localhost:3000/api` | ❌ **跨域** | 协议不同 (http vs https) |
| `http://localhost:3000` | `http://127.0.0.1:3000/api` | ❌ **跨域** | 域名不同 (localhost vs 127.0.0.1) |

### 2.3 为什么需要同源策略


**保护用户安全**，防止恶意网站偷取你的隐私数据。

```
恶意场景举例：
你登录了银行网站 bank.com
然后访问了恶意网站 evil.com
如果没有同源策略：
evil.com 可以偷偷向 bank.com 发请求
获取你的银行账户信息！

有了同源策略：
浏览器会阻止这种跨域请求 🛡️
```

---

## 3. 🌐 CORS解决方案


### 3.1 CORS是什么


**CORS** = **跨源资源共享** (Cross-Origin Resource Sharing)

**通俗理解**：这是浏览器和服务器之间的"通行证"机制。服务器说"我允许这个网站访问我"，浏览器才会放行。

```
工作流程：
1. 你的网站：我想要那边的数据
2. 浏览器：先问问人家同意不同意
3. 目标服务器：同意！这是我的通行证 (CORS头)
4. 浏览器：好的，放行！
```

### 3.2 CORS的核心思想


```
传统：浏览器默认阻止所有跨域请求
CORS：服务器主动声明"我允许哪些网站访问我"
```

---

## 4. 🔧 Fetch中的CORS配置


### 4.1 mode配置选项


**mode** 告诉浏览器你想怎么处理跨域：

```javascript
// mode 的三种选择：
fetch(url, {
  mode: 'cors',        // 默认：允许跨域，需要服务器配合
  mode: 'same-origin', // 严格：只允许同源请求
  mode: 'no-cors'      // 宽松：发送请求但可能拿不到完整响应
});
```

### 4.2 实际配置示例


```javascript
// 👍 推荐：明确指定 CORS 模式
fetch('https://api.example.com/data', {
  method: 'GET',
  mode: 'cors',  // 明确声明要跨域
  headers: {
    'Content-Type': 'application/json'
  }
})
.then(response => {
  if (!response.ok) {
    throw new Error('请求失败');
  }
  return response.json();
})
.catch(error => {
  console.log('错误:', error.message);
});
```

### 4.3 mode选项详细说明


| 模式 | 含义 | 使用场景 | 注意事项 |
|------|------|----------|----------|
| `cors` | 允许跨域请求 | **最常用**，请求第三方API | 需要服务器支持CORS |
| `same-origin` | 只允许同源 | 安全要求高的内部API | 跨域直接报错 |
| `no-cors` | 不透明请求 | 只发送请求，不关心响应 | **很少使用** |

---

## 5. 🔄 简单请求vs复杂请求


### 5.1 简单请求的条件


**简单请求**就像"绿色通道"，满足条件的请求可以直接发送：

```
简单请求的三个条件：
✅ 请求方法：GET、POST、HEAD
✅ 请求头只能是：Accept、Accept-Language、Content-Language、Content-Type
✅ Content-Type 只能是：text/plain、multipart/form-data、application/x-www-form-urlencoded
```

### 5.2 简单请求示例


```javascript
// ✅ 这是简单请求
fetch('https://api.example.com/users', {
  method: 'GET',  // ✅ 简单方法
  mode: 'cors'
  // ✅ 没有自定义头
});

// ✅ 这也是简单请求
fetch('https://api.example.com/login', {
  method: 'POST',  // ✅ 简单方法
  mode: 'cors',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'  // ✅ 简单类型
  },
  body: 'username=john&password=123'
});
```

### 5.3 复杂请求示例


```javascript
// ❌ 这是复杂请求（会触发预检）
fetch('https://api.example.com/users', {
  method: 'PUT',  // ❌ 不是简单方法
  mode: 'cors',
  headers: {
    'Content-Type': 'application/json',  // ✅ 这个是简单的
    'Authorization': 'Bearer token123'   // ❌ 自定义头，不简单了
  },
  body: JSON.stringify({name: 'John'})
});
```

### 5.4 区别总结


| 类型 | 特点 | 浏览器行为 | 性能 |
|------|------|------------|------|
| **简单请求** | 满足基本条件 | 直接发送 | ✅ **更快** |
| **复杂请求** | 有自定义内容 | 先发预检，再发正式请求 | ⚠️ **多一次请求** |

---

## 6. 🍪 credentials配置详解


### 6.1 credentials是什么


**credentials** 控制是否在跨域请求中携带认证信息（Cookie、Session等）。

**通俗理解**：就像你去别的商店购物，要不要带上你的会员卡。

### 6.2 三种配置选项


```javascript
fetch(url, {
  credentials: 'omit',         // 不带任何认证信息
  credentials: 'same-origin',  // 只在同源时带认证信息 (默认)
  credentials: 'include'       // 总是带认证信息
});
```

### 6.3 实际应用场景


```javascript
// 场景1：登录后访问用户信息 (需要携带cookie)
fetch('https://api.mysite.com/profile', {
  method: 'GET',
  mode: 'cors',
  credentials: 'include',  // 👈 携带登录cookie
})
.then(response => response.json())
.then(data => console.log('用户信息:', data));

// 场景2：访问公开API (不需要认证)
fetch('https://api.weather.com/current', {
  method: 'GET',
  mode: 'cors',
  credentials: 'omit'  // 👈 不携带任何认证信息
})
.then(response => response.json())
.then(data => console.log('天气数据:', data));
```

### 6.4 credentials配置对比


| 配置 | 含义 | 使用场景 | 安全性 |
|------|------|----------|--------|
| `omit` | 不携带认证信息 | 公开API调用 | ✅ **最安全** |
| `same-origin` | 同源才携带 | 默认配置 | ⚖️ **平衡** |
| `include` | 总是携带 | 需要登录状态的跨域API | ⚠️ **需谨慎** |

> ⚠️ **安全提醒**  
> 使用 `credentials: 'include'` 时，服务器必须明确允许，否则请求会失败！

---

## 7. 🔍 预检请求处理


### 7.1 什么是预检请求


**预检请求**就像"探路兵"，在发送正式请求之前，先问问服务器"我能这样请求吗？"

```
预检流程：
浏览器：我想用PUT方法发送JSON数据，可以吗？  (OPTIONS请求)
服务器：可以！我支持PUT、POST、GET方法        (预检响应)
浏览器：好的，那我发正式请求了               (实际请求)
```

### 7.2 预检请求的触发条件


**当请求是"复杂请求"时，浏览器会自动发送预检请求：**

```javascript
// 这会触发预检请求
fetch('https://api.example.com/users/123', {
  method: 'DELETE',  // ❌ 不是简单方法
  mode: 'cors',
  headers: {
    'Authorization': 'Bearer token123'  // ❌ 自定义头
  }
});

/*
浏览器会先发送：
OPTIONS /users/123 HTTP/1.1
Host: api.example.com
Access-Control-Request-Method: DELETE
Access-Control-Request-Headers: authorization
*/
```

### 7.3 预检请求示例


```javascript
// 开发者工具中你会看到两个请求：

// 1. 预检请求 (OPTIONS) - 自动发送
// Request:
// OPTIONS /api/users HTTP/1.1
// Access-Control-Request-Method: PUT
// Access-Control-Request-Headers: content-type,authorization

// 2. 正式请求 (PUT) - 预检通过后发送
// PUT /api/users HTTP/1.1
// Content-Type: application/json
// Authorization: Bearer token123
```

### 7.4 处理预检请求的注意事项


> 📝 **开发提示**  
> 1. 预检请求是浏览器自动发送的，你无法控制
> 2. 预检失败时，正式请求不会发送
> 3. 预检响应可以被缓存，减少重复请求

---

## 8. 🐛 跨域错误调试


### 8.1 常见错误信息


```javascript
// 典型的跨域错误信息：
"Access to fetch at 'https://api.example.com' from origin 'http://localhost:3000' 
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present 
on the requested resource."
```

**翻译成人话**：目标服务器没有说"我允许你的网站访问我"。

### 8.2 错误排查步骤


```
🔍 排查清单：
□ 1. 确认是否真的跨域了？(检查协议、域名、端口)
□ 2. 服务器是否设置了 CORS 头？
□ 3. 请求是否是复杂请求？(检查预检请求)
□ 4. credentials 配置是否正确？
□ 5. 服务器是否允许当前请求方法？
```

### 8.3 调试技巧


```javascript
// 1. 先用简单请求测试
fetch('https://api.example.com/test', {
  method: 'GET',  // 简单方法
  mode: 'cors'
  // 不加任何自定义头
})
.then(response => {
  console.log('简单请求成功！');
  return response.json();
})
.catch(error => {
  console.log('连简单请求都失败:', error);
});

// 2. 检查响应头
fetch(url)
.then(response => {
  console.log('CORS相关响应头:');
  console.log('Access-Control-Allow-Origin:', 
    response.headers.get('Access-Control-Allow-Origin'));
  console.log('Access-Control-Allow-Methods:', 
    response.headers.get('Access-Control-Allow-Methods'));
});
```

### 8.4 开发环境解决方案


**开发时的临时解决方案**：

<details>
<summary>🔧 点击查看开发环境解决方案</summary>

```javascript
// 方案1: 开发服务器代理 (推荐)
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'https://api.example.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
}

// 方案2: 使用CORS扩展 (仅开发)
// Chrome扩展：CORS Unblock

// 方案3: 启动无安全检查的浏览器 (不推荐)
// chrome --disable-web-security --user-data-dir=/tmp
```

</details>

---

## 9. 🌍 实际应用案例


### 9.1 获取天气API数据


```javascript
// 调用第三方天气API
async function getWeather(city) {
  try {
    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=YOUR_KEY`, {
      method: 'GET',
      mode: 'cors',              // 允许跨域
      credentials: 'omit'        // 不需要认证信息
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('获取天气失败:', error);
    throw error;
  }
}

// 使用
getWeather('Beijing')
  .then(data => console.log('北京天气:', data))
  .catch(error => console.log('错误:', error.message));
```

### 9.2 跨域发送用户数据


```javascript
// 向另一个域的服务器发送用户数据
async function updateUserProfile(userData) {
  try {
    const response = await fetch('https://api.myapp.com/user/profile', {
      method: 'PUT',
      mode: 'cors',
      credentials: 'include',    // 携带登录cookie
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'  // 这会触发预检请求
      },
      body: JSON.stringify(userData)
    });
    
    if (!response.ok) {
      throw new Error('更新失败');
    }
    
    return await response.json();
  } catch (error) {
    console.error('更新用户信息失败:', error);
    throw error;
  }
}

// 使用
updateUserProfile({ name: '张三', age: 25 })
  .then(result => console.log('更新成功:', result))
  .catch(error => console.log('更新失败:', error.message));
```

### 9.3 服务端CORS配置示例


```javascript
// Node.js + Express 服务器配置
app.use((req, res, next) => {
  // 允许的来源
  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
  
  // 允许的方法
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  
  // 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  
  // 允许携带认证信息
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // 预检请求的缓存时间
  res.header('Access-Control-Max-Age', '86400');
  
  // 处理预检请求
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});
```

---

## 10. 📋 核心要点总结


### 10.1 必须理解的概念


```
🔸 跨域问题：浏览器的安全机制，不同源之间的请求限制
🔸 同源策略：协议、域名、端口三者相同才算同源
🔸 CORS机制：服务器主动允许跨域访问的解决方案
🔸 简单vs复杂：决定是否需要预检请求的关键区别
🔸 credentials：控制是否携带认证信息的重要配置
```

### 10.2 实用配置模板


```javascript
// 📌 通用跨域请求模板
const corsRequest = async (url, options = {}) => {
  const defaultOptions = {
    mode: 'cors',           // 允许跨域
    credentials: 'omit',    // 默认不携带认证信息
    headers: {
      'Content-Type': 'application/json'
    }
  };
  
  try {
    const response = await fetch(url, { ...defaultOptions, ...options });
    
    if (!response.ok) {
      throw new Error(`请求失败: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('跨域请求错误:', error);
    throw error;
  }
};
```

### 10.3 最佳实践建议


> ✅ **推荐做法**
> - 明确设置 `mode: 'cors'`
> - 根据需要配置 `credentials`
> - 优先使用简单请求减少预检开销
> - 开发环境使用代理解决跨域

> ⚠️ **注意事项**
> - CORS是服务器控制的，前端只能配合
> - 预检请求无法避免，但可以缓存
> - `credentials: 'include'` 需要服务器明确支持

> ❌ **避免做法**
> - 生产环境关闭浏览器安全检查
> - 盲目复制配置不理解含义
> - 忽略CORS错误信息的调试价值

### 10.4 记忆口诀


```
跨域问题浏览器管，同源三要素要记全
CORS服务器来配合，mode设置要明确
简单复杂有区别，预检请求自动发
credentials控制认证，include需要服务器许可
错误调试有技巧，开发代理最实用
```

**核心理解**：
- 🌐 跨域是浏览器的安全保护，不是bug
- 🤝 CORS需要前后端配合，单方面无法解决  
- 🔧 开发环境用代理，生产环境靠服务器配置
- 🎯 理解原理比记住配置更重要