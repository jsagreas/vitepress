---
title: 2、基础语法与Promise基础
---
## 📚 目录

1. [什么是Fetch API](#1-什么是Fetch-API)
2. [核心语法结构详解](#2-核心语法结构详解)
3. [Promise对象深度理解](#3-Promise对象深度理解)
4. [Request和Response对象概念](#4-Request和Response对象概念)
5. [链式调用结构详解](#5-链式调用结构详解)
6. [常用请求方式概览](#6-常用请求方式概览)
7. [与传统写法对比](#7-与传统写法对比)
8. [初学者常见错误](#8-初学者常见错误)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 什么是Fetch API


### 1.1 通俗理解Fetch


> **💡 简单理解**：Fetch就像是你派一个"信使"去服务器取数据，这个信使很聪明，能告诉你任务的进展情况

```
现实场景类比：
你让朋友帮你从商店买东西
👤 你 ────发请求───▶ 🏪 商店
   ◀───返回商品─────

编程中的Fetch：
浏览器 ────fetch请求───▶ 服务器
      ◀────返回数据────
```

**🔸 Fetch的核心作用**
- `发送网络请求`：向服务器要数据
- `获取响应结果`：拿到服务器返回的内容
- `处理异步操作`：不会阻塞页面运行

### 1.2 为什么需要Fetch


**传统问题**：
```javascript
// 老式写法 - XMLHttpRequest (很繁琐)
var xhr = new XMLHttpRequest();
xhr.open('GET', '/api/users');
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var data = JSON.parse(xhr.responseText);
    console.log(data);
  }
}
xhr.send();
```

**Fetch解决方案**：
```javascript
// 现代写法 - Fetch (简洁明了)
fetch('/api/users')
  .then(response => response.json())
  .then(data => console.log(data));
```

---

## 2. 🔧 核心语法结构详解


### 2.1 基础语法格式


**🎯 最简单的语法**
```javascript
fetch(网址)
```

**🎯 完整语法结构**
```javascript
fetch(url, options)
  .then(response => {
    // 处理响应
  })
  .catch(error => {
    // 处理错误
  });
```

### 2.2 参数详细说明


**📋 url参数 (必需)**
```javascript
// 绝对路径
fetch('https://api.example.com/users')

// 相对路径  
fetch('/api/users')

// 带参数的URL
fetch('/api/users?page=1&limit=10')
```

**📋 options参数 (可选)**
```javascript
fetch('/api/users', {
  method: 'GET',        // 请求方法
  headers: {            // 请求头
    'Content-Type': 'application/json'
  },
  body: null           // 请求体 (GET请求通常为null)
})
```

### 2.3 语法结构图解


```
fetch() 函数调用结构：

┌─────────────────────────────────────┐
│  fetch(url, options)                │
├─────────────────────────────────────┤
│  ↓ 返回                             │
│  Promise<Response>                  │
├─────────────────────────────────────┤
│  ↓ .then() 处理                     │
│  处理响应数据                        │
├─────────────────────────────────────┤
│  ↓ .catch() 处理                    │
│  处理错误情况                        │
└─────────────────────────────────────┘
```

---

## 3. 🎁 Promise对象深度理解


### 3.1 什么是Promise


> **💡 生活化理解**：Promise就像一张"欠条"，代表一个"将来会给你结果"的承诺

```
Promise的三种状态：
┌─────────────┐
│   pending   │ ← 进行中（还在等结果）
│  (等待中)    │
└─────────────┘
       │
   ┌───────┴───────┐
   ▼               ▼
┌─────────┐   ┌─────────┐
│fulfilled │   │rejected │
│(成功了)  │   │(失败了)  │
└─────────┘   └─────────┘
```

### 3.2 Promise在Fetch中的应用


**🔸 Fetch返回的Promise**
```javascript
const promise = fetch('/api/users');
console.log(promise); // Promise对象

// Promise会根据网络请求结果变成fulfilled或rejected
```

**🔸 Promise状态变化过程**
```javascript
// 1️⃣ 发起请求时 - pending状态
const fetchPromise = fetch('/api/users');

// 2️⃣ 请求成功时 - fulfilled状态
fetchPromise.then(response => {
  console.log('请求成功！', response);
});

// 3️⃣ 请求失败时 - rejected状态  
fetchPromise.catch(error => {
  console.log('请求失败！', error);
});
```

### 3.3 为什么使用Promise


| **对比项目** | **传统回调** | **Promise方式** |
|-------------|-------------|----------------|
| **代码结构** | 嵌套回调地狱 | 链式调用，清晰 |
| **错误处理** | 每层都要处理 | 统一catch处理 |
| **可读性** | 难以理解 | 逻辑清晰 |
| **维护性** | 难以维护 | 容易扩展 |

---

## 4. 📦 Request和Response对象概念


### 4.1 Request对象 (请求对象)


> **💡 理解**：Request就像一个"快递包裹"，包含了你要发送给服务器的所有信息

**🔸 Request包含什么**
```javascript
// 创建Request对象
const request = new Request('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: 'John' })
});

// Request对象包含：
// - 请求地址 (url)
// - 请求方法 (method) 
// - 请求头 (headers)
// - 请求体 (body)
```

### 4.2 Response对象 (响应对象)


> **💡 理解**：Response就像服务器给你的"回执单"，告诉你请求结果和返回的数据

**🔸 Response包含什么**
```javascript
fetch('/api/users')
  .then(response => {
    console.log(response.status);    // 状态码: 200, 404, 500等
    console.log(response.ok);        // 是否成功: true/false
    console.log(response.headers);   // 响应头信息
    return response.json();          // 解析JSON数据
  });
```

### 4.3 Request与Response的关系


```
请求响应流程图：

客户端                           服务器
   │                              │
   │─────── Request对象 ────────▶  │
   │     (包含请求信息)             │
   │                              │ 处理请求
   │                              │
   │ ◀────── Response对象 ─────────│
   │     (包含响应结果)             │
   │                              │
```

---

## 5. 🔗 链式调用结构详解


### 5.1 什么是链式调用


> **💡 理解**：链式调用就像"流水线作业"，一步接一步，每一步的结果传给下一步

**🔸 基本链式结构**
```javascript
fetch('/api/users')           // 第1步：发送请求
  .then(response => {         // 第2步：处理响应
    return response.json();   // 返回解析后的数据
  })
  .then(data => {            // 第3步：使用数据
    console.log(data);
  })
  .catch(error => {          // 错误处理：任何一步出错都会到这里
    console.log('出错了:', error);
  });
```

### 5.2 链式调用的执行顺序


```
执行流程图：

┌─────────────┐
│ fetch()     │ ── 发起请求
└─────────────┘
       │
       ▼
┌─────────────┐
│ .then(第1个) │ ── 处理Response对象
└─────────────┘
       │
       ▼
┌─────────────┐
│ .then(第2个) │ ── 处理解析后的数据
└─────────────┘
       │
       ▼
┌─────────────┐
│ .catch()    │ ── 捕获任何错误
└─────────────┘
```

### 5.3 .then()方法详解


**🎯 .then()的作用**
- 接收上一步的结果
- 对结果进行处理
- 返回新的值给下一步

```javascript
fetch('/api/users')
  .then(response => {
    // response是fetch返回的Response对象
    console.log('状态码:', response.status);
    
    // 必须return，否则下一个.then()收到undefined
    return response.json();
  })
  .then(users => {
    // users是上一步return的结果
    console.log('用户列表:', users);
    
    // 可以继续return给下一个.then()
    return users.filter(user => user.active);
  })
  .then(activeUsers => {
    console.log('活跃用户:', activeUsers);
  });
```

### 5.4 .catch()方法详解


**🎯 .catch()的作用**
- 捕获链式调用中任何一步的错误
- 提供统一的错误处理机制

```javascript
fetch('/api/users')
  .then(response => {
    if (!response.ok) {
      throw new Error('网络请求失败');
    }
    return response.json();
  })
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    // 捕获所有可能的错误：
    // - 网络错误
    // - JSON解析错误  
    // - 手动抛出的错误
    console.log('发生错误:', error.message);
  });
```

---

## 6. 🚀 常用请求方式概览


### 6.1 HTTP请求方法基础概念


> **💡 理解**：HTTP请求方法就像不同的"办事方式"，每种方式有不同的用途

```
生活化类比：
GET    → 去图书馆"查阅"资料 (只看不改)
POST   → 向银行"提交"开户申请 (创建新的)
PUT    → "更新"你的个人资料 (全部替换)
DELETE → "删除"不需要的文件 (移除数据)
```

### 6.2 GET请求 - 获取数据


**🔸 什么时候用GET**
- 获取用户列表
- 查看商品详情
- 读取文章内容

```javascript
// 最简单的GET请求
fetch('/api/users')
  .then(response => response.json())
  .then(users => console.log(users));

// 带参数的GET请求
fetch('/api/users?page=1&limit=10')
  .then(response => response.json())
  .then(data => console.log(data));
```

### 6.3 POST请求 - 创建数据


**🔸 什么时候用POST**
- 用户注册
- 发表评论
- 上传文件

```javascript
// POST请求创建新用户
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: '张三',
    email: 'zhangsan@example.com'
  })
})
.then(response => response.json())
.then(result => console.log('创建成功:', result));
```

### 6.4 PUT请求 - 更新数据


**🔸 什么时候用PUT**
- 修改用户信息
- 更新文章内容
- 编辑商品详情

```javascript
// PUT请求更新用户信息
fetch('/api/users/123', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: '李四',
    email: 'lisi@example.com'
  })
})
.then(response => response.json())
.then(result => console.log('更新成功:', result));
```

### 6.5 DELETE请求 - 删除数据


**🔸 什么时候用DELETE**
- 删除用户账号
- 移除购物车商品
- 删除评论

```javascript
// DELETE请求删除用户
fetch('/api/users/123', {
  method: 'DELETE'
})
.then(response => {
  if (response.ok) {
    console.log('删除成功');
  }
});
```

### 6.6 请求方法对比表


| **方法** | **用途** | **有请求体** | **幂等性** | **常见场景** |
|---------|---------|-------------|-----------|-------------|
| `GET` | 获取数据 | ❌ 无 | ✅ 是 | 查看列表、详情 |
| `POST` | 创建数据 | ✅ 有 | ❌ 否 | 注册、发表内容 |
| `PUT` | 更新数据 | ✅ 有 | ✅ 是 | 修改资料、编辑 |
| `DELETE` | 删除数据 | ❌ 无 | ✅ 是 | 删除记录、取消 |

> **📝 幂等性**：多次执行同样的操作，结果都一样

---

## 7. ⚖️ 与传统写法对比


### 7.1 XMLHttpRequest vs Fetch


**❌ 传统XMLHttpRequest写法**
```javascript
// 复杂繁琐的写法
function getData() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', '/api/users');
  
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var data = JSON.parse(xhr.responseText);
        console.log(data);
      } else {
        console.log('请求失败');
      }
    }
  };
  
  xhr.onerror = function() {
    console.log('网络错误');
  };
  
  xhr.send();
}
```

**✅ 现代Fetch写法**
```javascript
// 简洁清晰的写法
function getData() {
  fetch('/api/users')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.log('请求失败:', error));
}
```

### 7.2 回调地狱 vs Promise链


**❌ 回调地狱问题**
```javascript
// 多层嵌套，难以阅读
getUserInfo(userId, function(user) {
  getOrderList(user.id, function(orders) {
    getOrderDetails(orders[0].id, function(details) {
      console.log(details);
    });
  });
});
```

**✅ Promise链式调用**
```javascript
// 扁平化结构，逻辑清晰
fetch(`/api/users/${userId}`)
  .then(response => response.json())
  .then(user => fetch(`/api/orders?userId=${user.id}`))
  .then(response => response.json())
  .then(orders => fetch(`/api/orders/${orders[0].id}`))
  .then(response => response.json())
  .then(details => console.log(details));
```

---

## 8. ⚠️ 初学者常见错误


### 8.1 忘记处理Promise


**❌ 错误写法**
```javascript
// 这样写拿不到数据！
const data = fetch('/api/users');
console.log(data); // 输出: Promise对象，不是数据
```

**✅ 正确写法**
```javascript
// 必须用.then()处理Promise
fetch('/api/users')
  .then(response => response.json())
  .then(data => {
    console.log(data); // 这里才是真正的数据
  });
```

### 8.2 忘记检查响应状态


**❌ 错误写法**
```javascript
fetch('/api/users')
  .then(response => response.json()) // 可能报错！
  .then(data => console.log(data));
```

**✅ 正确写法**
```javascript
fetch('/api/users')
  .then(response => {
    if (!response.ok) {
      throw new Error('请求失败');
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.log(error));
```

### 8.3 忘记return中间结果


**❌ 错误写法**
```javascript
fetch('/api/users')
  .then(response => {
    response.json(); // 忘记return！
  })
  .then(data => {
    console.log(data); // undefined
  });
```

**✅ 正确写法**
```javascript
fetch('/api/users')
  .then(response => {
    return response.json(); // 必须return
  })
  .then(data => {
    console.log(data); // 正确的数据
  });
```

### 8.4 混淆异步和同步


**❌ 错误理解**
```javascript
// 认为这里会等待请求完成
fetch('/api/users');
console.log('请求完成'); // 其实请求还在进行中
```

**✅ 正确理解**
```javascript
// 理解异步执行顺序
console.log('1. 开始请求');

fetch('/api/users')
  .then(data => {
    console.log('3. 请求完成，收到数据');
  });

console.log('2. 请求已发出，继续执行其他代码');

// 输出顺序: 1 → 2 → 3
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Fetch本质：现代浏览器的网络请求工具，基于Promise
🔸 基本语法：fetch(url, options).then().catch()
🔸 返回值：Promise<Response>，需要.then()处理
🔸 链式调用：每个.then()处理上一步结果，return给下一步
🔸 错误处理：用.catch()统一捕获所有错误
🔸 请求方法：GET查询、POST创建、PUT更新、DELETE删除
```

### 9.2 关键理解要点


**🔹 Promise的作用**
```
理解要点：
- Promise是"承诺"，代表未来会有结果
- fetch()立即返回Promise，不会阻塞代码执行
- 用.then()等待Promise完成并处理结果
- 用.catch()处理Promise被拒绝的情况
```

**🔹 链式调用的本质**
```
核心原理：
- 每个.then()都返回新的Promise
- 可以无限连接.then()形成处理链
- return的值会传递给下一个.then()
- 任何一环出错都会跳到.catch()
```

**🔹 异步操作的特点**
```
重要认知：
- fetch是异步的，不会等待结果
- 代码会继续执行，结果稍后通过.then()处理
- 不能用同步思维理解异步代码
- 所有数据处理都要在.then()内部进行
```

### 9.3 实际应用指导


**🎯 选择请求方法的原则**
- **查看数据** → GET请求
- **创建内容** → POST请求  
- **修改信息** → PUT请求
- **删除数据** → DELETE请求

**🎯 编写Fetch代码的步骤**
1. **确定请求地址和方法**
2. **设置必要的请求头和请求体**
3. **处理响应状态和数据解析**
4. **添加错误处理机制**

**🎯 调试Fetch请求的方法**
- 在浏览器开发者工具查看Network面板
- 用console.log输出中间结果
- 检查响应状态码和错误信息

**核心记忆**：
- Fetch发请求，Promise管结果
- 链式调用处理好，错误捕获别忘了
- GET查看POST创建，PUT更新DELETE删
- 异步思维要培养，同步等待行不通