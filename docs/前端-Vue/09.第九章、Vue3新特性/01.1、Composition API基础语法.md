---
title: 1、Composition API基础语法
---
## 📚 目录

1. [什么是Composition API](#1-什么是composition-api)
2. [setup()函数详解](#2-setup函数详解)
3. [响应式数据创建](#3-响应式数据创建)
4. [响应式转换工具](#4-响应式转换工具)
5. [计算属性与监听器](#5-计算属性与监听器)
6. [生命周期钩子新写法](#6-生命周期钩子新写法)
7. [组合式API对比选项式API](#7-组合式api对比选项式api)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 什么是Composition API


### 1.1 简单理解Composition API


**通俗解释**：Composition API就像是把Vue组件的逻辑重新组织的新方法

```
想象一下整理房间：

选项式API（Vue2的方式）：
- 所有衣服放一个柜子
- 所有书放一个书架  
- 所有电子产品放一个抽屉

组合式API（Vue3的新方式）：
- 工作相关的物品放一起（衣服+书+电脑）
- 娱乐相关的物品放一起（游戏+音响+休闲书）
- 按用途分类，更好管理
```

### 1.2 为什么需要Composition API


**解决的核心问题**：

```
📊 传统选项式API的问题：
┌─────────────────────┐
│      一个组件       │
├─────────────────────┤
│ data: {             │  ← 数据分散在各个选项里
│   userInfo,         │
│   orderList         │
│ }                   │
├─────────────────────┤
│ methods: {          │  ← 方法分散在各个选项里
│   getUserInfo,      │
│   getOrderList      │
│ }                   │
├─────────────────────┤
│ computed: {...}     │  ← 计算属性又在别的地方
│ watch: {...}        │  ← 监听器也在别的地方
└─────────────────────┘

相关的逻辑被分散在不同地方，维护困难！
```

**Composition API的优势**：
- ✅ **逻辑聚合**：相关逻辑写在一起，更好维护
- ✅ **代码复用**：可以把逻辑提取成函数复用
- ✅ **类型支持**：更好的TypeScript支持
- ✅ **灵活组织**：可以按功能模块组织代码

---

## 2. 🔧 setup()函数详解


### 2.1 setup函数是什么


**简单理解**：setup是Composition API的"入口大门"，所有的组合式逻辑都在这里开始

```vue
<script>
export default {
  // setup就是新的"主角"
  setup() {
    // 在这里写所有的逻辑
    console.log('组件开始准备了！')
    
    // 返回的数据可以在模板中使用
    return {
      message: 'Hello Vue3!'
    }
  }
}
</script>
```

### 2.2 setup函数的执行时机


**执行顺序**：
```
1️⃣ 组件创建之前 setup()执行
2️⃣ 执行完setup() 
3️⃣ 才执行 beforeCreate
4️⃣ 再执行 created
```

> 💡 **记忆技巧**：setup比所有生命周期都早，它是"开路先锋"

### 2.3 setup的参数


```vue
<script>
export default {
  setup(props, context) {
    // props: 父组件传来的数据
    console.log(props.title) // 可以访问props
    
    // context: 上下文对象，包含3个重要属性
    const { emit, slots, attrs } = context
    
    // emit: 向父组件发送事件
    emit('update:modelValue', newValue)
    
    // slots: 插槽内容
    console.log(slots.default)
    
    // attrs: 非props的属性
    console.log(attrs.class)
  }
}
</script>
```

### 2.4 setup语法糖（推荐写法）


```vue
<!-- 传统写法 -->
<script>
export default {
  setup() {
    const count = ref(0)
    return { count }
  }
}
</script>

<!-- 语法糖写法（更简洁） -->
<script setup>
const count = ref(0)
// 不需要return，自动暴露给模板
</script>
```

> 🔥 **推荐使用**：`<script setup>` 语法糖，代码更简洁

---

## 3. 📦 响应式数据创建


### 3.1 ref() - 基本类型响应式


**什么是ref**：把普通数据包装成响应式数据的工具

```vue
<template>
  <!-- 模板中直接使用，不需要.value -->
  <p>{{ count }}</p>
  <button @click="increment">点击+1</button>
</template>

<script setup>
import { ref } from 'vue'

// 基本类型用ref包装
const count = ref(0)        // 数字
const message = ref('hi')   // 字符串  
const isShow = ref(true)    // 布尔值

// 在JavaScript中需要.value访问
function increment() {
  count.value++  // 注意：需要.value
}
</script>
```

**ref的核心特点**：
- 🔸 **JavaScript中**：需要用 `.value` 访问和修改
- 🔸 **模板中**：直接使用，Vue自动解包
- 🔸 **适用场景**：基本类型数据（数字、字符串、布尔值等）

### 3.2 reactive() - 对象响应式


**什么是reactive**：直接把整个对象变成响应式的工具

```vue
<template>
  <div>
    <p>用户：{{ user.name }}</p>
    <p>年龄：{{ user.age }}</p>
    <button @click="updateUser">更新用户</button>
  </div>
</template>

<script setup>
import { reactive } from 'vue'

// 对象用reactive包装
const user = reactive({
  name: '张三',
  age: 25,
  hobbies: ['篮球', '音乐']
})

function updateUser() {
  // 直接修改，不需要.value
  user.age++
  user.hobbies.push('阅读')
}
</script>
```

**reactive的核心特点**：
- 🔸 **直接访问**：不需要 `.value`，直接操作对象属性
- 🔸 **深度响应式**：对象内部嵌套的数据也是响应式的
- 🔸 **适用场景**：对象、数组等复杂数据类型

### 3.3 ref vs reactive 选择指南


| 数据类型 | **推荐使用** | **访问方式** | **示例** |
|---------|------------|-------------|---------|
| 🔢 **数字** | `ref()` | `.value` | `const count = ref(0)` |
| 📝 **字符串** | `ref()` | `.value` | `const name = ref('张三')` |
| ✅ **布尔值** | `ref()` | `.value` | `const isShow = ref(true)` |
| 📦 **对象** | `reactive()` | `直接访问` | `const user = reactive({...})` |
| 📋 **数组** | `reactive()` | `直接访问` | `const list = reactive([])` |

> 💡 **记忆技巧**：简单数据用ref，复杂数据用reactive

---

## 4. 🔄 响应式转换工具


### 4.1 toRefs() - 解构响应式对象


**问题场景**：想要解构reactive对象，但丢失响应式

```vue
<script setup>
import { reactive, toRefs } from 'vue'

const user = reactive({
  name: '张三',
  age: 25
})

// ❌ 错误做法：直接解构，丢失响应式
// const { name, age } = user

// ✅ 正确做法：使用toRefs转换后再解构
const { name, age } = toRefs(user)

// 现在name和age都是ref类型，保持响应式
function updateName() {
  name.value = '李四'  // 需要.value访问
}
</script>
```

**toRefs的作用**：
- 🔸 把reactive对象的每个属性转换为ref
- 🔸 转换后可以安全解构，不丢失响应式
- 🔸 解构出来的变量需要用`.value`访问

### 4.2 toRef() - 单个属性转换


**使用场景**：只需要转换对象中的某个属性

```vue
<script setup>
import { reactive, toRef } from 'vue'

const user = reactive({
  name: '张三',
  age: 25,
  email: 'zhangsan@example.com'
})

// 只转换name属性
const name = toRef(user, 'name')

function updateName() {
  name.value = '李四'  // 修改后原对象也会更新
  console.log(user.name) // 输出：李四
}
</script>
```

**toRef vs toRefs**：
```
toRef()：   转换对象中的单个属性
toRefs()：  转换对象中的所有属性

选择建议：
- 只需要几个属性 → 用 toRef()
- 需要所有属性 → 用 toRefs()
```

---

## 5. ⚡ 计算属性与监听器


### 5.1 computed() - 组合式计算属性


**简单理解**：根据其他数据自动计算出新数据，数据变化时自动重新计算

```vue
<template>
  <div>
    <p>商品价格：{{ price }}</p>
    <p>商品数量：{{ quantity }}</p>
    <!-- 总价会自动计算 -->
    <p>总价：{{ totalPrice }}</p>
    
    <button @click="price += 10">涨价</button>
    <button @click="quantity++">加购</button>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const price = ref(100)
const quantity = ref(2)

// 计算属性：依赖的数据变化时自动重新计算
const totalPrice = computed(() => {
  console.log('重新计算总价') // 只在依赖变化时执行
  return price.value * quantity.value
})
</script>
```

**计算属性的特点**：
- ✅ **自动依赖收集**：Vue自动知道依赖哪些数据
- ✅ **缓存结果**：依赖不变时不重复计算
- ✅ **响应式结果**：计算结果也是响应式的

### 5.2 watch() - 精确监听


**使用场景**：当某些数据变化时，执行特定操作

```vue
<script setup>
import { ref, watch } from 'vue'

const keyword = ref('')
const userList = ref([])

// 监听搜索关键词变化
watch(keyword, (newKeyword, oldKeyword) => {
  console.log(`搜索词从"${oldKeyword}"变为"${newKeyword}"`)
  
  // 执行搜索操作
  searchUsers(newKeyword)
})

// 监听多个数据源
watch([keyword, userList], ([newKeyword, newList], [oldKeyword, oldList]) => {
  console.log('关键词或用户列表发生了变化')
})

function searchUsers(keyword) {
  // 模拟搜索API调用
  console.log('正在搜索用户...', keyword)
}
</script>
```

### 5.3 watchEffect() - 自动监听


**简单理解**：自动监听函数内用到的所有响应式数据

```vue
<script setup>
import { ref, watchEffect } from 'vue'

const count = ref(0)
const name = ref('张三')

// 自动监听函数内使用的所有响应式数据
watchEffect(() => {
  console.log(`${name.value}的计数是${count.value}`)
  
  // 当count或name变化时，这个函数会自动重新执行
})

// 等价于：
// watch([count, name], () => {
//   console.log(`${name.value}的计数是${count.value}`)
// })
</script>
```

**watch vs watchEffect**：

| 特性 | **watch()** | **watchEffect()** |
|------|------------|------------------|
| 🎯 **监听目标** | 明确指定要监听的数据 | 自动监听函数内使用的数据 |
| 📋 **参数** | 提供新值、旧值 | 无参数 |
| ⚡ **执行时机** | 数据变化后执行 | 立即执行一次，然后数据变化时执行 |
| 🎚️ **控制性** | 精确控制 | 更加简洁 |

---

## 6. 🔄 生命周期钩子新写法


### 6.1 生命周期钩子变化


**Vue2 vs Vue3 生命周期对比**：

```
Vue2选项式API          Vue3组合式API
─────────────────    ─────────────────
beforeCreate         setup() (替代)
created             setup() (替代)
beforeMount         onBeforeMount()
mounted             onMounted()
beforeUpdate        onBeforeUpdate()
updated             onUpdated()
beforeUnmount       onBeforeUnmount()
unmounted           onUnmounted()
```

### 6.2 组合式生命周期钩子使用


```vue
<script setup>
import { 
  ref, 
  onMounted, 
  onUpdated, 
  onBeforeUnmount 
} from 'vue'

const count = ref(0)
const timer = ref(null)

// 组件挂载后执行
onMounted(() => {
  console.log('组件已挂载，可以访问DOM了')
  
  // 启动定时器
  timer.value = setInterval(() => {
    count.value++
  }, 1000)
})

// 组件更新后执行
onUpdated(() => {
  console.log('组件已更新，DOM已重新渲染')
})

// 组件卸载前执行
onBeforeUnmount(() => {
  console.log('组件即将卸载，清理资源')
  
  // 清除定时器
  if (timer.value) {
    clearInterval(timer.value)
  }
})
</script>
```

### 6.3 生命周期钩子的优势


**多次调用**：可以多次调用同一个生命周期钩子

```vue
<script setup>
import { onMounted } from 'vue'

// 第一个onMounted - 初始化用户数据
onMounted(() => {
  console.log('初始化用户数据')
  initUserData()
})

// 第二个onMounted - 初始化图表
onMounted(() => {
  console.log('初始化图表')
  initChart()
})

// 所有的onMounted都会执行，按顺序调用
</script>
```

> 💡 **优势**：可以把不同功能的初始化逻辑分开写，代码更清晰

---

## 7. ⚖️ 组合式API对比选项式API


### 7.1 代码组织方式对比


**选项式API（Vue2风格）**：
```vue
<script>
export default {
  data() {
    return {
      // 用户相关数据
      user: {},
      
      // 订单相关数据  
      orders: []
    }
  },
  
  computed: {
    // 用户相关计算属性
    userDisplayName() { ... },
    
    // 订单相关计算属性
    totalOrders() { ... }
  },
  
  methods: {
    // 用户相关方法
    fetchUser() { ... },
    updateUser() { ... },
    
    // 订单相关方法
    fetchOrders() { ... },
    createOrder() { ... }
  },
  
  mounted() {
    this.fetchUser()
    this.fetchOrders()
  }
}
</script>
```

**组合式API（Vue3推荐）**：
```vue
<script setup>
// 用户相关逻辑聚合在一起
const { user, userDisplayName, fetchUser, updateUser } = useUser()

// 订单相关逻辑聚合在一起  
const { orders, totalOrders, fetchOrders, createOrder } = useOrders()

onMounted(() => {
  fetchUser()
  fetchOrders()
})
</script>
```

### 7.2 逻辑复用对比


**选项式API的复用（Mixin方式）**：
```javascript
// ❌ Mixin方式的问题
const userMixin = {
  data() {
    return { user: {} }
  },
  methods: {
    fetchUser() { ... }
  }
}

// 问题：数据来源不明确，容易命名冲突
```

**组合式API的复用（Composable方式）**：
```javascript
// ✅ Composable方式：清晰明确
function useUser() {
  const user = ref({})
  
  const fetchUser = () => {
    // 获取用户逻辑
  }
  
  return { user, fetchUser }
}

// 使用时很清楚数据来源
const { user, fetchUser } = useUser()
```

### 7.3 选择建议


| 场景 | **推荐方案** | **理由** |
|------|------------|---------|
| 🔰 **新项目** | Composition API | 更好的逻辑组织和复用 |
| 🔄 **旧项目迁移** | 渐进式迁移 | 可以混用，逐步迁移 |
| 👥 **团队新手多** | Options API | 学习成本更低 |
| 🏗️ **复杂业务组件** | Composition API | 更好的逻辑聚合 |
| 📦 **工具库开发** | Composition API | 更好的复用性 |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Composition API：Vue3新的逻辑组织方式，让相关逻辑聚合在一起
🔸 setup()函数：组合式API的入口，比所有生命周期都早执行
🔸 ref()：包装基本类型数据为响应式，需要.value访问
🔸 reactive()：直接让对象变成响应式，不需要.value
🔸 computed()：根据依赖数据自动计算，有缓存机制
🔸 watch/watchEffect：监听数据变化，执行副作用操作
```

### 8.2 关键理解要点


**🔹 响应式数据的选择**
```
记忆口诀：
- 简单数据用ref，复杂数据用reactive
- JavaScript中ref要.value，模板中自动解包
- reactive直接用，toRefs可解构
```

**🔹 监听器的选择**
```
使用建议：
- 需要新旧值对比 → watch()
- 简单的依赖追踪 → watchEffect()  
- 精确控制监听 → watch()
- 自动依赖收集 → watchEffect()
```

**🔹 代码组织思路**
```
组合式API的核心思想：
按功能逻辑分组 > 按选项类型分组
相关的数据、计算属性、方法写在一起
可以提取为独立的composable函数复用
```

### 8.3 实际应用建议


- ✅ **渐进式采用**：新组件用Composition API，旧组件保持不变
- ✅ **先学基础**：掌握ref、reactive、computed、watch基本用法
- ✅ **后学进阶**：学会提取composable函数，实现逻辑复用
- ✅ **注意性能**：合理使用computed缓存，避免不必要的监听

### 8.4 常见误区避免


```
❌ 忘记.value访问ref数据
❌ 过度使用reactive包装基本类型
❌ 直接解构reactive对象丢失响应式
❌ 在setup外部调用组合式API
❌ 混淆watch和watchEffect的使用场景
```

**核心记忆**：
- Composition API让逻辑更聚合，代码更清晰
- setup是入口，ref包基础，reactive包对象
- computed自动算，watch来监听，生命周期换个写法
- 按功能分组胜过按类型分组，复用逻辑更简单