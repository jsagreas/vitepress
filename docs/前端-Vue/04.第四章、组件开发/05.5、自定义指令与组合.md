---
title: 5、自定义指令与组合
---
## 📚 目录

1. [自定义指令基础概念](#1-自定义指令基础概念)
2. [指令钩子函数详解](#2-指令钩子函数详解)
3. [Vue2混入(mixins)](#3-vue2混入mixins)
4. [Vue3组合式函数(composables)](#4-vue3组合式函数composables)
5. [组件逻辑复用策略](#5-组件逻辑复用策略)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 自定义指令基础概念


### 1.1 什么是自定义指令


**简单理解**：自定义指令就是你自己创造的`v-`开头的特殊属性，用来操作DOM元素。

```
内置指令 → Vue给你准备好的: v-if、v-show、v-model
自定义指令 → 你自己创造的: v-focus、v-color、v-drag

就像：
<input v-model="name">     ← Vue内置的
<input v-focus>           ← 你自定义的
```

**作用场景**：
- 🎯 **DOM操作** - 直接操作DOM元素
- 🎯 **功能扩展** - 给元素添加特殊行为
- 🎯 **代码复用** - 把重复的DOM操作封装起来

### 1.2 为什么需要自定义指令


**现实问题**：
```javascript
// 每个输入框都要手动聚焦，代码重复
mounted() {
  this.$refs.nameInput.focus();
  this.$refs.ageInput.focus();
  this.$refs.emailInput.focus();
}
```

**解决方案**：
```javascript
// 创建一个聚焦指令，哪里需要哪里用
<input v-focus>
<input v-focus>
<input v-focus>
```

### 1.3 自定义指令的两种注册方式


**全局注册** - 整个应用都能用：
```javascript
// Vue2写法
Vue.directive('focus', {
  inserted(el) {
    el.focus();
  }
});

// Vue3写法
app.directive('focus', {
  mounted(el) {
    el.focus();
  }
});
```

**局部注册** - 只在当前组件用：
```javascript
// 组件内部定义
export default {
  directives: {
    focus: {
      mounted(el) {
        el.focus();
      }
    }
  }
}
```

### 1.4 指令的基本使用


**基础用法**：
```html
<!-- 无参数 -->
<input v-focus>

<!-- 带参数 -->
<div v-color="'red'">红色文字</div>

<!-- 带修饰符 -->
<div v-drag.limit>可拖拽，但有限制</div>
```

---

## 2. ⚙️ 指令钩子函数详解


### 2.1 什么是钩子函数


**通俗理解**：钩子函数就是在特定时机自动执行的函数，就像"闹钟"在设定时间响铃。

```
元素生命周期：创建 → 插入 → 更新 → 移除
钩子函数时机：  ↓     ↓     ↓     ↓
               创建时  插入时  更新时  销毁时
```

### 2.2 Vue2钩子函数


| 钩子名称 | **触发时机** | **常用场景** |
|---------|-------------|-------------|
| `bind` | 指令第一次绑定到元素时 | 初始化设置 |
| `inserted` | 元素插入到DOM时 | DOM操作、事件绑定 |
| `update` | 元素更新时 | 响应数据变化 |
| `componentUpdated` | 组件更新完成后 | 更新后的DOM操作 |
| `unbind` | 指令解绑时 | 清理工作 |

**实用示例**：
```javascript
Vue.directive('highlight', {
  bind(el, binding) {
    // 第一次绑定时设置样式
    console.log('指令绑定了');
  },
  inserted(el, binding) {
    // 插入DOM后执行
    el.style.backgroundColor = binding.value;
  },
  update(el, binding) {
    // 数据更新时执行
    el.style.backgroundColor = binding.value;
  }
});
```

### 2.3 Vue3钩子函数


| 钩子名称 | **触发时机** | **对应Vue2** |
|---------|-------------|-------------|
| `created` | 元素创建时 | 新增 |
| `beforeMount` | 挂载前 | bind |
| `mounted` | 挂载后 | inserted |
| `beforeUpdate` | 更新前 | 新增 |
| `updated` | 更新后 | componentUpdated |
| `beforeUnmount` | 卸载前 | 新增 |
| `unmounted` | 卸载后 | unbind |

**Vue3示例**：
```javascript
app.directive('highlight', {
  mounted(el, binding) {
    el.style.backgroundColor = binding.value;
  },
  updated(el, binding) {
    el.style.backgroundColor = binding.value;
  }
});
```

### 2.4 钩子函数参数详解


**参数说明**：
```javascript
directive('example', {
  mounted(el, binding, vnode, prevVnode) {
    // el: 指令绑定的DOM元素
    // binding: 指令信息对象
    // vnode: 当前虚拟节点
    // prevVnode: 上一个虚拟节点
  }
});
```

**binding对象包含**：
```javascript
// <div v-example:arg.mod1.mod2="value">
{
  value: 'value',      // 指令的值
  oldValue: undefined, // 上一个值
  arg: 'arg',          // 参数
  modifiers: {         // 修饰符
    mod1: true,
    mod2: true
  },
  instance: vm,        // 组件实例
  dir: {...}          // 指令定义对象
}
```

---

## 3. 🔀 Vue2混入(mixins)


### 3.1 什么是mixins


**简单理解**：mixins就像"调料包"，把常用的功能打包好，哪个组件需要就"撒"进去。

```
组件A需要：登录检查 + 权限验证
组件B需要：登录检查 + 数据加载
组件C需要：登录检查 + 权限验证 + 数据加载

mixins解决：
登录检查mixin → 各个组件都能用
权限验证mixin → 需要的组件用
数据加载mixin → 需要的组件用
```

### 3.2 mixins基本用法


**创建mixin**：
```javascript
// userMixin.js
export const userMixin = {
  data() {
    return {
      userInfo: null
    };
  },
  methods: {
    checkLogin() {
      if (!this.userInfo) {
        this.$router.push('/login');
      }
    },
    getUserInfo() {
      // 获取用户信息的逻辑
      return this.$http.get('/user/info');
    }
  },
  created() {
    this.checkLogin();
  }
};
```

**使用mixin**：
```javascript
// 组件中使用
import { userMixin } from './mixins/userMixin';

export default {
  mixins: [userMixin],
  data() {
    return {
      pageData: []
    };
  },
  methods: {
    loadData() {
      // 可以直接使用mixin中的方法
      this.checkLogin();
      // 组件自己的逻辑
    }
  }
};
```

### 3.3 mixins的合并策略


**数据合并规则**：
```javascript
// mixin中的data
data() {
  return {
    name: '来自mixin',
    age: 18
  };
}

// 组件中的data
data() {
  return {
    name: '来自组件',
    city: '北京'
  };
}

// 最终结果（组件的优先级更高）
{
  name: '来自组件',  // 组件覆盖mixin
  age: 18,          // 来自mixin
  city: '北京'      // 来自组件
}
```

**生命周期合并**：
```javascript
// mixin中的created
created() {
  console.log('mixin created');
}

// 组件中的created
created() {
  console.log('component created');
}

// 执行顺序：都会执行，mixin先执行
// 输出：
// mixin created
// component created
```

### 3.4 mixins的问题


**命名冲突**：
```javascript
// 多个mixin有同名方法，容易混乱
mixins: [userMixin, dataMixin, authMixin]
// 如果都有同名方法，不知道用的是哪个
```

**依赖不明确**：
```javascript
// 组件中使用了方法，但不知道来自哪个mixin
this.checkAuth(); // 这个方法从哪来的？
```

---

## 4. 🚀 Vue3组合式函数(composables)


### 4.1 什么是组合式函数


**简单理解**：composables就是把逻辑封装成函数，需要时调用，比mixins更清晰。

```
mixins → 神秘的调料包，不知道里面有什么
composables → 透明的工具箱，清楚每个工具的作用

使用对比：
// mixins
mixins: [userMixin]  // 不知道注入了什么

// composables  
const { userInfo, checkLogin } = useUser(); // 清楚得到了什么
```

### 4.2 创建组合式函数


**基础示例** - 用户逻辑封装：
```javascript
// composables/useUser.js
import { ref, onMounted } from 'vue';

export function useUser() {
  // 响应式数据
  const userInfo = ref(null);
  const loading = ref(false);
  
  // 方法
  const login = async (username, password) => {
    loading.value = true;
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify({ username, password })
      });
      userInfo.value = await response.json();
    } finally {
      loading.value = false;
    }
  };
  
  const logout = () => {
    userInfo.value = null;
  };
  
  // 生命周期
  onMounted(() => {
    // 自动获取用户信息
    const token = localStorage.getItem('token');
    if (token) {
      // 获取用户信息逻辑
    }
  });
  
  // 返回需要的数据和方法
  return {
    userInfo,
    loading,
    login,
    logout
  };
}
```

**在组件中使用**：
```vue
<template>
  <div>
    <div v-if="loading">加载中...</div>
    <div v-else-if="userInfo">
      欢迎, {{ userInfo.name }}!
      <button @click="logout">退出</button>
    </div>
    <button v-else @click="showLogin">登录</button>
  </div>
</template>

<script setup>
import { useUser } from '@/composables/useUser';

// 使用组合式函数
const { userInfo, loading, login, logout } = useUser();

const showLogin = () => {
  // 显示登录弹窗逻辑
};
</script>
```

### 4.3 常用组合式函数模式


**计数器逻辑**：
```javascript
// composables/useCounter.js
import { ref } from 'vue';

export function useCounter(initialValue = 0) {
  const count = ref(initialValue);
  
  const increment = () => count.value++;
  const decrement = () => count.value--;
  const reset = () => count.value = initialValue;
  
  return {
    count,
    increment,
    decrement,
    reset
  };
}
```

**本地存储逻辑**：
```javascript
// composables/useLocalStorage.js
import { ref, watch } from 'vue';

export function useLocalStorage(key, defaultValue) {
  // 从localStorage读取初始值
  const storedValue = localStorage.getItem(key);
  const initialValue = storedValue ? JSON.parse(storedValue) : defaultValue;
  
  const value = ref(initialValue);
  
  // 监听变化，自动保存到localStorage
  watch(value, (newValue) => {
    localStorage.setItem(key, JSON.stringify(newValue));
  }, { deep: true });
  
  return value;
}
```

### 4.4 组合式函数的优势


**清晰的依赖关系**：
```javascript
// 一目了然知道使用了什么
const { userInfo, login } = useUser();
const { count, increment } = useCounter();
const theme = useLocalStorage('theme', 'light');
```

**更好的TypeScript支持**：
```typescript
// 类型推导更准确
const { userInfo } = useUser(); // userInfo自动推导出类型
```

**更灵活的组合**：
```javascript
// 可以根据需要组合不同逻辑
const userLogic = useUser();
const counterLogic = useCounter();
// 只用需要的部分
```

---

## 5. 🔄 组件逻辑复用策略


### 5.1 复用策略对比


| 方案 | **Vue版本** | **优点** | **缺点** | **适用场景** |
|------|------------|---------|---------|-------------|
| **mixins** | Vue2主要 | 简单易用 | 命名冲突、来源不明 | 简单逻辑复用 |
| **composables** | Vue3推荐 | 清晰明确、类型友好 | 需要学习成本 | 复杂逻辑复用 |
| **自定义指令** | 都支持 | DOM操作专业 | 只能操作DOM | DOM相关操作 |

### 5.2 选择指导原则


**使用自定义指令的场景**：
```javascript
✅ DOM操作：聚焦、拖拽、懒加载
✅ 样式控制：颜色、尺寸、动画
✅ 事件绑定：点击外部、长按、滚动

❌ 业务逻辑：用户管理、数据处理
❌ 状态管理：复杂数据状态
```

**使用mixins的场景**（Vue2）：
```javascript
✅ 简单工具方法
✅ 通用生命周期逻辑
✅ 少量数据共享

❌ 复杂业务逻辑
❌ 多个mixins组合
❌ 需要清晰依赖关系
```

**使用composables的场景**（Vue3）：
```javascript
✅ 复杂业务逻辑
✅ 状态管理
✅ 需要清晰依赖
✅ TypeScript项目

❌ 简单DOM操作（用指令更好）
```

### 5.3 实际应用示例


**表单验证逻辑复用**：
```javascript
// composables/useFormValidation.js
import { ref, computed } from 'vue';

export function useFormValidation(rules) {
  const errors = ref({});
  const values = ref({});
  
  const isValid = computed(() => {
    return Object.keys(errors.value).length === 0;
  });
  
  const validate = (field, value) => {
    const rule = rules[field];
    if (rule && !rule.test(value)) {
      errors.value[field] = rule.message;
    } else {
      delete errors.value[field];
    }
  };
  
  return {
    errors,
    values,
    isValid,
    validate
  };
}
```

**使用示例**：
```vue
<script setup>
import { useFormValidation } from '@/composables/useFormValidation';

const rules = {
  email: {
    test: (value) => /\S+@\S+\.\S+/.test(value),
    message: '请输入有效邮箱'
  }
};

const { errors, validate, isValid } = useFormValidation(rules);

const handleInput = (field, value) => {
  validate(field, value);
};
</script>
```

### 5.4 迁移建议


**从Vue2到Vue3的迁移**：
```
步骤1：识别现有mixins
步骤2：分析逻辑职责
步骤3：重构为composables
步骤4：测试功能完整性

迁移优先级：
🔥 高优先级：复杂业务逻辑mixins
🟡 中优先级：工具方法mixins  
🟢 低优先级：简单样式mixins
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 自定义指令：专门用于DOM操作的特殊属性
🔸 指令钩子：在元素生命周期特定时机执行的函数
🔸 mixins：Vue2中的逻辑复用方案，像调料包
🔸 composables：Vue3中的逻辑复用方案，更清晰透明
🔸 复用策略：根据场景选择合适的复用方式
```

### 6.2 关键理解要点


**🔹 什么时候用什么**：
```
DOM操作 → 自定义指令
业务逻辑复用 → composables（Vue3）或 mixins（Vue2）
简单工具方法 → 全局方法或工具函数
```

**🔹 Vue2到Vue3的变化**：
```
mixins的问题：
- 命名冲突风险
- 依赖关系不明确
- 来源追踪困难

composables的优势：  
- 明确的依赖关系
- 更好的类型推导
- 灵活的组合方式
```

**🔹 设计原则**：
```
单一职责：每个复用逻辑只做一件事
明确接口：清楚地定义输入和输出
易于测试：逻辑独立，便于单元测试
```

### 6.3 实际应用价值


- **代码复用**：避免重复编写相同逻辑
- **维护性**：集中管理通用功能
- **可测试性**：独立的逻辑更容易测试
- **团队协作**：统一的复用模式便于协作

### 6.4 最佳实践建议


```
自定义指令：
✅ 命名清晰：v-focus、v-drag
✅ 功能单一：一个指令只做一件事
✅ 参数验证：检查传入参数的有效性

组合式函数：
✅ 以"use"开头命名：useUser、useCounter
✅ 返回对象：便于解构和重命名
✅ 文档完善：说明输入输出和使用场景
```

**核心记忆**：
- 指令管DOM，组合管逻辑
- Vue3用composables，Vue2用mixins
- 复用要清晰，依赖要明确
- 选对工具，事半功倍