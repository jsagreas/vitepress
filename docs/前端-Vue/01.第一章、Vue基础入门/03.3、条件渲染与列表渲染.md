---
title: 3、条件渲染与列表渲染
---
## 📚 目录

1. [条件渲染基础概念](#1-条件渲染基础概念)
2. [v-if指令详解](#2-v-if指令详解)
3. [v-show与v-if的区别](#3-v-show与v-if的区别)
4. [条件渲染最佳实践](#4-条件渲染最佳实践)
5. [列表渲染基础](#5-列表渲染基础)
6. [key属性的重要性](#6-key属性的重要性)
7. [列表渲染性能优化](#7-列表渲染性能优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 条件渲染基础概念


### 1.1 什么是条件渲染


**简单理解**：条件渲染就是**根据某个条件决定是否显示某个元素**，就像日常生活中的开关一样。

```
生活中的例子：
如果天气下雨 → 显示雨伞
如果用户登录 → 显示用户信息
如果购物车为空 → 显示"购物车为空"提示
```

**核心作用**：
- 🎯 **动态控制**：根据数据变化显示或隐藏内容
- 🚀 **用户体验**：让页面根据状态智能变化
- 💡 **逻辑清晰**：把显示逻辑写在模板里

---

## 2. 🔀 v-if指令详解


### 2.1 基础用法


**v-if的含义**：如果条件为真，就渲染这个元素；否则完全不渲染。

```vue
<template>
  <div>
    <!-- 最简单的条件渲染 -->
    <p v-if="isLoggedIn">欢迎回来！</p>
    
    <!-- 条件为假时显示 -->
    <p v-else>请先登录</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isLoggedIn: false  // 控制登录状态
    }
  }
}
</script>
```

**工作原理图解**：
```
数据状态：isLoggedIn = true
         ↓
    DOM中渲染：<p>欢迎回来！</p>

数据状态：isLoggedIn = false  
         ↓
    DOM中渲染：<p>请先登录</p>
```

### 2.2 多重条件判断


**v-else-if的使用**：处理多种情况，就像编程中的if-else if-else。

```vue
<template>
  <div>
    <!-- 根据用户类型显示不同内容 -->
    <div v-if="userType === 'admin'">
      🔧 管理员面板
    </div>
    <div v-else-if="userType === 'user'">
      👤 用户面板  
    </div>
    <div v-else-if="userType === 'guest'">
      🎯 游客模式
    </div>
    <div v-else>
      ❓ 未知用户类型
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      userType: 'user'  // 可以是：admin、user、guest
    }
  }
}
</script>
```

### 2.3 在template上使用v-if


**解决问题**：当需要同时控制多个元素时，可以用`<template>`作为包装器。

```vue
<template>
  <div>
    <!-- 同时控制多个元素的显示 -->
    <template v-if="showUserInfo">
      <h3>用户信息</h3>
      <p>姓名：张三</p>
      <p>邮箱：zhangsan@example.com</p>
    </template>
    
    <button @click="toggleUserInfo">
      {{ showUserInfo ? '隐藏' : '显示' }}用户信息
    </button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      showUserInfo: false
    }
  },
  methods: {
    toggleUserInfo() {
      this.showUserInfo = !this.showUserInfo
    }
  }
}
</script>
```

> 💡 **为什么用template**：`<template>`不会在最终的DOM中出现，只是用来包装元素的"隐形容器"。

---

## 3. ⚡ v-show与v-if的区别


### 3.1 基本区别


**核心差异**：
- **v-if**：真正的条件渲染，条件为假时**完全不渲染**到DOM
- **v-show**：总是渲染到DOM，只是用CSS的`display`属性**控制显示隐藏**

```vue
<template>
  <div>
    <!-- v-if：条件为假时不存在于DOM中 -->
    <p v-if="showWithIf">使用v-if显示</p>
    
    <!-- v-show：条件为假时存在于DOM但不可见 -->
    <p v-show="showWithShow">使用v-show显示</p>
  </div>
</template>
```

**DOM渲染结果对比**：
```html
<!-- 当条件为false时的DOM结果 -->

<!-- v-if为false：完全没有这个元素 -->
<div>
  <!-- 这里什么都没有 -->
  <p style="display: none;">使用v-show显示</p>
</div>

<!-- v-show为false：元素存在但隐藏 -->
<div>
  <p style="display: none;">使用v-show显示</p>
</div>
```

### 3.2 性能对比表格


| 对比项目 | **v-if** | **v-show** | **使用建议** |
|---------|----------|------------|-------------|
| **初始渲染** | 条件为假时开销更低 | 总是有渲染开销 | 初始条件很可能为假用v-if |
| **切换开销** | 每次都要创建/销毁元素 | 只是改变CSS样式 | 频繁切换用v-show |
| **DOM存在** | 条件为假时不存在 | 始终存在于DOM | 需要用CSS选择器时用v-show |
| **适用场景** | 条件很少改变 | 频繁切换显示隐藏 | 根据切换频率选择 |

### 3.3 实际应用场景


```vue
<template>
  <div>
    <!-- 场景1：用户权限检查 - 用v-if -->
    <!-- 一般登录后不会频繁改变权限 -->
    <div v-if="user.isAdmin">
      管理员操作面板
    </div>
    
    <!-- 场景2：tab切换 - 用v-show -->
    <!-- 用户会频繁切换tab -->
    <div v-show="activeTab === 'profile'">个人信息</div>
    <div v-show="activeTab === 'settings'">设置</div>
    
    <!-- 场景3：模态框 - 用v-show -->
    <!-- 用户会频繁打开关闭 -->
    <div class="modal" v-show="showModal">
      模态框内容
    </div>
  </div>
</template>
```

> ⚠️ **重要提醒**：v-show不支持`<template>`元素，也不支持v-else。

---

## 4. 🎯 条件渲染最佳实践


### 4.1 避免v-if与v-for同时使用


**错误示例**：
```vue
<!-- ❌ 不推荐：v-for与v-if同时使用 -->
<li v-for="user in users" v-if="user.isActive" :key="user.id">
  {{ user.name }}
</li>
```

**正确做法**：
```vue
<!-- ✅ 推荐：使用计算属性过滤 -->
<li v-for="user in activeUsers" :key="user.id">
  {{ user.name }}
</li>

<script>
export default {
  data() {
    return {
      users: [
        { id: 1, name: '张三', isActive: true },
        { id: 2, name: '李四', isActive: false }
      ]
    }
  },
  computed: {
    // 提前过滤出活跃用户
    activeUsers() {
      return this.users.filter(user => user.isActive)
    }
  }
}
</script>
```

> 💡 **为什么这样做**：v-for的优先级比v-if高，会导致v-if在每个循环中重复执行，影响性能。

### 4.2 使用key保证元素的唯一性


```vue
<template>
  <div>
    <!-- ✅ 为条件渲染的元素添加key -->
    <input v-if="loginType === 'username'" 
           key="username" 
           placeholder="请输入用户名">
    <input v-else 
           key="email" 
           placeholder="请输入邮箱">
    
    <button @click="toggleLoginType">
      切换到{{ loginType === 'username' ? '邮箱' : '用户名' }}登录
    </button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      loginType: 'username'
    }
  },
  methods: {
    toggleLoginType() {
      this.loginType = this.loginType === 'username' ? 'email' : 'username'
    }
  }
}
</script>
```

> 🔑 **key的作用**：确保Vue不会复用之前的input元素，避免输入内容残留的问题。

---

## 5. 📋 列表渲染基础


### 5.1 什么是列表渲染


**简单理解**：列表渲染就是**把数组中的数据一个个显示出来**，就像把购物清单的每一项都写出来。

```
现实例子：
购物清单：['苹果', '香蕉', '橙子']
         ↓ 渲染成
页面显示：• 苹果
         • 香蕉  
         • 橙子
```

### 5.2 基础数组渲染


```vue
<template>
  <div>
    <h3>水果清单</h3>
    <!-- 遍历数组，item是每个元素，index是索引 -->
    <ul>
      <li v-for="(item, index) in fruits" :key="index">
        {{ index + 1 }}. {{ item }}
      </li>
    </ul>
  </div>
</template>

<script>
export default {
  data() {
    return {
      fruits: ['苹果', '香蕉', '橙子', '葡萄']
    }
  }
}
</script>
```

**语法解释**：
```
v-for="(item, index) in fruits"
        ↑      ↑         ↑
      当前项  索引号   数据源
```

### 5.3 对象数组渲染


**更实际的例子**：渲染用户列表
```vue
<template>
  <div>
    <h3>用户列表</h3>
    <div v-for="user in users" :key="user.id" class="user-card">
      <h4>{{ user.name }}</h4>
      <p>年龄：{{ user.age }}岁</p>
      <p>邮箱：{{ user.email }}</p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      users: [
        { id: 1, name: '张三', age: 25, email: 'zhangsan@example.com' },
        { id: 2, name: '李四', age: 30, email: 'lisi@example.com' },
        { id: 3, name: '王五', age: 28, email: 'wangwu@example.com' }
      ]
    }
  }
}
</script>

<style>
.user-card {
  border: 1px solid #ddd;
  padding: 10px;
  margin: 10px 0;
  border-radius: 5px;
}
</style>
```

### 5.4 渲染对象的属性


```vue
<template>
  <div>
    <h3>个人信息</h3>
    <!-- 遍历对象的属性 -->
    <ul>
      <li v-for="(value, key) in userInfo" :key="key">
        <strong>{{ key }}:</strong> {{ value }}
      </li>
    </ul>
  </div>
</template>

<script>
export default {
  data() {
    return {
      userInfo: {
        姓名: '张三',
        年龄: 25,
        职业: '程序员',
        城市: '北京'
      }
    }
  }
}
</script>
```

---

## 6. 🔑 key属性的重要性


### 6.1 为什么需要key


**核心问题**：Vue怎么知道列表中哪些元素是新的、哪些是旧的、哪些被删除了？

```
原始列表：[A, B, C]
新列表：  [A, X, B, C]

没有key：Vue可能认为B变成了X，C变成了B，然后在末尾添加C
有key：  Vue知道X是新插入的，B和C只是位置变了
```

### 6.2 错误的key使用


```vue
<!-- ❌ 错误：使用index作为key -->
<div v-for="(item, index) in list" :key="index">
  {{ item.name }}
  <input type="text" />
</div>
```

**问题演示**：
```
初始状态：
[0] 张三 [输入框：张三的备注]
[1] 李四 [输入框：李四的备注]  
[2] 王五 [输入框：王五的备注]

删除李四后（使用index作key）：
[0] 张三 [输入框：张三的备注] ✓ 
[1] 王五 [输入框：李四的备注] ❌ 输入框内容错了！
```

### 6.3 正确的key使用


```vue
<!-- ✅ 正确：使用唯一ID作为key -->
<div v-for="item in list" :key="item.id">
  {{ item.name }}
  <input type="text" v-model="item.note" />
</div>

<script>
export default {
  data() {
    return {
      list: [
        { id: 1, name: '张三', note: '' },
        { id: 2, name: '李四', note: '' },
        { id: 3, name: '王五', note: '' }
      ]
    }
  }
}
</script>
```

### 6.4 key的选择原则


> **🎯 选择key的黄金法则**
> 
> ✅ **使用稳定、唯一、可预测的值**
> - 数据库ID
> - 唯一的字符串标识
> - 业务相关的唯一编号
>
> ❌ **避免使用不稳定的值**  
> - 数组索引（当列表会变化时）
> - 随机数
> - 时间戳

---

## 7. 🚀 列表渲染性能优化


### 7.1 避免不必要的重新渲染


```vue
<template>
  <div>
    <!-- ✅ 使用computed过滤，避免在模板中计算 -->
    <div v-for="item in filteredItems" :key="item.id">
      {{ item.name }} - {{ item.price }}
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      items: [
        { id: 1, name: '商品A', price: 100, category: 'electronics' },
        { id: 2, name: '商品B', price: 200, category: 'clothing' }
      ],
      selectedCategory: 'electronics'
    }
  },
  computed: {
    // 计算属性会缓存结果，只有依赖变化时才重新计算
    filteredItems() {
      return this.items.filter(item => 
        item.category === this.selectedCategory
      )
    }
  }
}
</script>
```

### 7.2 大列表优化技巧


```vue
<template>
  <div>
    <!-- 对于大列表，考虑分页显示 -->
    <div v-for="item in currentPageItems" :key="item.id">
      {{ item.name }}
    </div>
    
    <!-- 简单的分页控制 -->
    <button @click="prevPage" :disabled="currentPage === 1">
      上一页
    </button>
    <span>第 {{ currentPage }} 页</span>
    <button @click="nextPage" :disabled="currentPage === totalPages">
      下一页
    </button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      allItems: [], // 所有数据
      currentPage: 1,
      pageSize: 10
    }
  },
  computed: {
    // 当前页显示的数据
    currentPageItems() {
      const start = (this.currentPage - 1) * this.pageSize
      const end = start + this.pageSize
      return this.allItems.slice(start, end)
    },
    totalPages() {
      return Math.ceil(this.allItems.length / this.pageSize)
    }
  },
  methods: {
    nextPage() {
      if (this.currentPage < this.totalPages) {
        this.currentPage++
      }
    },
    prevPage() {
      if (this.currentPage > 1) {
        this.currentPage--
      }
    }
  }
}
</script>
```

---

## 8. 📋 核心要点总结


### 8.1 条件渲染核心要点


```
🔸 v-if：真正的条件渲染，条件为假时不存在于DOM
🔸 v-show：只控制CSS显示隐藏，元素始终在DOM中
🔸 选择原则：频繁切换用v-show，很少改变用v-if
🔸 避免v-if与v-for同时使用，用计算属性代替
🔸 为条件渲染元素添加key确保唯一性
```

### 8.2 列表渲染核心要点


```
🔸 v-for：遍历数组、对象，生成重复的DOM元素
🔸 语法：(item, index) in array 或 (value, key) in object
🔸 key属性：必须唯一且稳定，不要用index（列表会变化时）
🔸 性能优化：使用计算属性过滤，大列表考虑分页
🔸 避免在模板中进行复杂计算
```

### 8.3 最佳实践速查


> **✅ 推荐做法**
> - 条件渲染用计算属性判断复杂逻辑
> - key使用数据的唯一ID
> - 大列表使用虚拟滚动或分页
> - 把过滤逻辑写在computed中
>
> **❌ 避免做法**
> - v-if和v-for同时使用
> - 用数组索引作为key（动态列表）
> - 在模板中写复杂的条件判断
> - 忘记为列表元素添加key

### 8.4 常见问题解决


<details>
<summary>🤔 为什么切换条件时input的值没有清空？</summary>

**原因**：Vue复用了相同的DOM元素
**解决**：为不同条件的元素添加不同的key

```vue
<input v-if="type === 'text'" key="text-input" />
<input v-else key="email-input" />
```
</details>

<details>
<summary>🤔 列表更新后为什么输入框的值乱了？</summary>

**原因**：使用数组索引作为key导致Vue无法正确追踪元素
**解决**：使用数据的唯一标识作为key

```vue
<div v-for="item in list" :key="item.id">
```
</details>

**记忆口诀**：
- 条件渲染选对方法：频繁切换show，偶尔改变if
- 列表渲染记住key：唯一稳定是关键
- 性能优化用计算：复杂逻辑放computed
- 避免同时用指令：if和for要分离