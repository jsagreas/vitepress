---
title: 6、计算属性与监听器
---
## 📚 目录

1. [计算属性基础概念](#1-计算属性基础概念)
2. [computed与methods的本质区别](#2-computed与methods的本质区别)
3. [计算属性的缓存机制](#3-计算属性的缓存机制)
4. [watch监听器详解](#4-watch监听器详解)
5. [watchEffect立即执行监听](#5-watcheffect立即执行监听)
6. [深度监听与立即监听](#6-深度监听与立即监听)
7. [实际应用场景对比](#7-实际应用场景对比)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧮 计算属性基础概念


### 1.1 什么是计算属性


**🔸 通俗理解**
计算属性就像是一个**聪明的计算器**，它会根据你提供的数据自动计算出结果，而且只有当数据真正发生变化时才会重新计算。

```javascript
// 想象一个购物车场景
data() {
  return {
    price: 100,        // 商品价格
    quantity: 2        // 商品数量
  }
},
computed: {
  // 总价会根据价格和数量自动计算
  totalPrice() {
    return this.price * this.quantity
  }
}
```

**🔸 核心特点**
- **自动计算**: 依赖的数据变了，结果自动更新
- **智能缓存**: 依赖没变时，直接返回上次的结果
- **简化模板**: 复杂逻辑不用写在模板里

### 1.2 为什么需要计算属性


**❌ 不用计算属性的问题**
```vue
<template>
  <!-- 模板里写复杂逻辑，难读难维护 -->
  <p>总价: {{ price * quantity + (price * quantity * 0.1) }}</p>
  <p>折扣后: {{ price * quantity + (price * quantity * 0.1) }}</p>
</template>
```

**✅ 使用计算属性的好处**
```vue
<template>
  <!-- 模板简洁清晰 -->
  <p>总价: {{ finalPrice }}</p>
  <p>折扣后: {{ finalPrice }}</p>
</template>

<script>
export default {
  computed: {
    finalPrice() {
      // 逻辑集中在这里，清晰易懂
      return this.price * this.quantity * 1.1
    }
  }
}
</script>
```

---

## 2. ⚖️ computed与methods的本质区别


### 2.1 执行方式对比


**🔸 methods方法**
```javascript
methods: {
  getTotalPrice() {
    console.log('methods被调用了!')
    return this.price * this.quantity
  }
}

// 模板中每次使用都会执行
// {{ getTotalPrice() }}  ← 每次都调用
// {{ getTotalPrice() }}  ← 又调用一次
```

**🔸 computed计算属性**
```javascript
computed: {
  totalPrice() {
    console.log('computed被调用了!')
    return this.price * this.quantity
  }
}

// 模板中多次使用只计算一次
// {{ totalPrice }}  ← 第一次计算
// {{ totalPrice }}  ← 直接返回缓存结果
```

### 2.2 实际测试对比


```vue
<template>
  <div>
    <p>价格: {{ price }}</p>
    <p>数量: {{ quantity }}</p>
    
    <!-- methods: 每次都执行 -->
    <p>总价(方法1): {{ getTotalPrice() }}</p>
    <p>总价(方法2): {{ getTotalPrice() }}</p>
    
    <!-- computed: 只执行一次 -->
    <p>总价(计算1): {{ totalPrice }}</p>
    <p>总价(计算2): {{ totalPrice }}</p>
    
    <button @click="price += 10">涨价</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      price: 100,
      quantity: 2
    }
  },
  methods: {
    getTotalPrice() {
      console.log('methods执行了')  // 会打印4次
      return this.price * this.quantity
    }
  },
  computed: {
    totalPrice() {
      console.log('computed执行了')  // 只打印1次
      return this.price * this.quantity
    }
  }
}
</script>
```

### 2.3 何时使用哪种方式


| 场景 | **使用方式** | **原因** |
|------|------------|---------|
| 🧮 **数据计算** | `computed` | `需要缓存，提高性能` |
| 🎯 **用户操作** | `methods` | `每次都要执行，如点击事件` |
| 📊 **格式化显示** | `computed` | `显示内容相同时无需重算` |
| 🔄 **API调用** | `methods` | `每次调用都要发送请求` |

---

## 3. 🧠 计算属性的缓存机制


### 3.1 缓存的工作原理


**🔸 依赖收集过程**
```
第一次访问计算属性时:
1. Vue记录这个计算属性用了哪些数据
2. 把这些数据叫做"依赖"
3. 给每个依赖装上"监控器"
4. 计算结果并缓存起来
```

**🔸 缓存更新机制**
```
当依赖数据发生变化时:
1. 监控器发现变化
2. 标记计算属性"过期"
3. 下次访问时重新计算
4. 更新缓存结果
```

### 3.2 缓存实例演示


```javascript
export default {
  data() {
    return {
      firstName: '张',
      lastName: '三',
      age: 25,
      city: '北京'
    }
  },
  computed: {
    fullName() {
      console.log('fullName重新计算了')
      // 只依赖 firstName 和 lastName
      return this.firstName + this.lastName
    }
  },
  methods: {
    changeAge() {
      this.age += 1  // 改变age不会触发fullName重算
    },
    changeName() {
      this.firstName = '李'  // 改变firstName会触发重算
    }
  }
}
```

> 💡 **理解要点**  
> 计算属性很聪明，它只关心自己"用到"的数据。如果你改变的数据它没用到，就不会重新计算。

### 3.3 性能对比示例


```javascript
// 假设有1000条数据需要过滤
computed: {
  expensiveList() {
    console.log('开始计算...')
    return this.items.filter(item => item.price > 100)
  }
}

// 在模板中多次使用
// {{ expensiveList.length }}     ← 只计算一次
// {{ expensiveList[0] }}         ← 使用缓存
// {{ expensiveList.slice(0,5) }} ← 使用缓存
```

---

## 4. 👀 watch监听器详解


### 4.1 watch的基本概念


**🔸 什么是watch**
watch就像是一个**专门的观察员**，它盯着某个数据，一旦这个数据发生变化，就立即执行你指定的操作。

```javascript
export default {
  data() {
    return {
      searchText: '',
      userList: []
    }
  },
  watch: {
    // 监听搜索框内容变化
    searchText(newValue, oldValue) {
      console.log(`搜索内容从 "${oldValue}" 变成了 "${newValue}"`)
      this.searchUsers(newValue)  // 执行搜索
    }
  },
  methods: {
    searchUsers(keyword) {
      // 模拟搜索用户
      console.log('正在搜索:', keyword)
    }
  }
}
```

### 4.2 watch与computed的区别


**🔸 computed：一对多**
```javascript
// 一个计算属性可以依赖多个数据
computed: {
  fullInfo() {
    // 依赖多个数据源
    return `${this.name} - ${this.age}岁 - ${this.city}`
  }
}
```

**🔸 watch：一对一**
```javascript
// 一个监听器只盯着一个数据
watch: {
  name(newVal) {
    console.log('姓名变了:', newVal)
  },
  age(newVal) {
    console.log('年龄变了:', newVal)
  }
}
```

### 4.3 watch的典型应用场景


**🔸 场景1：搜索防抖**
```javascript
watch: {
  searchKeyword(newKeyword) {
    // 清除之前的定时器
    clearTimeout(this.searchTimer)
    
    // 设置新的定时器，500ms后执行搜索
    this.searchTimer = setTimeout(() => {
      this.performSearch(newKeyword)
    }, 500)
  }
}
```

**🔸 场景2：数据同步**
```javascript
watch: {
  userId(newUserId) {
    if (newUserId) {
      // 用户ID变了，重新获取用户信息
      this.fetchUserProfile(newUserId)
    }
  }
}
```

---

## 5. ⚡ watchEffect立即执行监听


### 5.1 watchEffect的特点


**🔸 与watch的区别**
```javascript
// 普通watch：需要指定监听的数据
watch: {
  count(newVal) {
    console.log('count变了:', newVal)
  }
}

// watchEffect：自动追踪依赖
watchEffect(() => {
  // 这里用到什么数据，就自动监听什么数据
  console.log('当前计数:', this.count)
  console.log('当前用户:', this.user.name)
})
```

**🔸 立即执行特性**
```javascript
export default {
  data() {
    return {
      message: 'Hello'
    }
  },
  created() {
    // watchEffect会立即执行一次，然后监听变化
    watchEffect(() => {
      console.log('消息内容:', this.message)
    })
    // 立即输出: "消息内容: Hello"
  }
}
```

### 5.2 实际应用示例


```javascript
import { watchEffect } from 'vue'

export default {
  data() {
    return {
      user: { id: 1, name: '张三' },
      settings: { theme: 'light' }
    }
  },
  mounted() {
    // 自动监听多个相关数据
    watchEffect(() => {
      // 保存用户偏好到本地存储
      localStorage.setItem('userPreference', JSON.stringify({
        userId: this.user.id,
        theme: this.settings.theme
      }))
    })
  }
}
```

---

## 6. 🔍 深度监听与立即监听


### 6.1 深度监听(deep)


**🔸 问题场景**
```javascript
data() {
  return {
    user: {
      name: '张三',
      profile: {
        age: 25,
        city: '北京'
      }
    }
  }
},
watch: {
  // 普通监听：只能监听到user对象本身的替换
  user(newVal) {
    console.log('user变了')  // 改变user.name时不会触发
  }
}
```

**🔸 深度监听解决方案**
```javascript
watch: {
  user: {
    handler(newVal, oldVal) {
      console.log('用户信息发生了变化')
    },
    deep: true  // 开启深度监听
  }
}

// 现在这些变化都能监听到：
// this.user.name = '李四'
// this.user.profile.age = 26
// this.user.profile.city = '上海'
```

### 6.2 立即监听(immediate)


**🔸 默认行为**
```javascript
watch: {
  username(newVal) {
    console.log('用户名变了:', newVal)
  }
}
// 只有当username真正改变时才会执行
```

**🔸 立即执行**
```javascript
watch: {
  username: {
    handler(newVal) {
      console.log('当前用户名:', newVal)
    },
    immediate: true  // 组件创建时立即执行一次
  }
}
// 组件加载时就会立即执行一次，然后监听变化
```

### 6.3 组合使用示例


```javascript
export default {
  data() {
    return {
      userSettings: {
        theme: 'light',
        language: 'zh-CN',
        notifications: {
          email: true,
          sms: false
        }
      }
    }
  },
  watch: {
    userSettings: {
      // 处理函数
      handler(newSettings) {
        // 保存设置到服务器
        this.saveSettingsToServer(newSettings)
      },
      deep: true,      // 深度监听所有嵌套属性
      immediate: true  // 组件加载时立即保存一次
    }
  }
}
```

---

## 7. 🎯 实际应用场景对比


### 7.1 购物车总价计算


**✅ 使用computed**
```javascript
// 购物车商品总价 - 适合用computed
computed: {
  cartTotal() {
    return this.cartItems.reduce((total, item) => {
      return total + item.price * item.quantity
    }, 0)
  },
  
  cartCount() {
    return this.cartItems.length
  }
}
```

### 7.2 搜索功能实现


**✅ 使用watch**
```javascript
// 搜索关键词监听 - 适合用watch
watch: {
  searchKeyword(newKeyword) {
    if (newKeyword.trim()) {
      // 有输入内容时才搜索
      this.performSearch(newKeyword)
    } else {
      // 清空搜索结果
      this.searchResults = []
    }
  }
}
```

### 7.3 表单验证场景


**✅ 组合使用**
```javascript
export default {
  data() {
    return {
      email: '',
      password: '',
      confirmPassword: ''
    }
  },
  computed: {
    // 计算属性：判断表单是否有效
    isFormValid() {
      return this.isEmailValid && 
             this.isPasswordValid && 
             this.isPasswordMatch
    },
    
    isEmailValid() {
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(this.email)
    },
    
    isPasswordValid() {
      return this.password.length >= 6
    },
    
    isPasswordMatch() {
      return this.password === this.confirmPassword
    }
  },
  watch: {
    // 监听器：显示实时提示
    email(newEmail) {
      if (newEmail && !this.isEmailValid) {
        this.showError('邮箱格式不正确')
      }
    },
    
    confirmPassword(newConfirm) {
      if (newConfirm && !this.isPasswordMatch) {
        this.showError('两次密码不一致')
      }
    }
  }
}
```

---

## 8. 📋 核心要点总结


### 8.1 快速选择指南


```
🧮 需要计算结果 → computed
👀 需要监听变化 → watch  
⚡ 需要立即执行 → watchEffect
🔍 需要深度监听 → watch + deep
🚀 需要立即监听 → watch + immediate
```

### 8.2 记忆口诀


> 🧠 **记忆要点**  
> - **computed像计算器**：依赖变化才计算，结果会缓存
> - **watch像观察员**：专门盯着一个数据的变化  
> - **methods像工具**：每次调用都执行，不会缓存

### 8.3 最佳实践建议


**🔸 性能优化原则**
- 能用computed就不用methods
- 复杂计算优先考虑computed
- 副作用操作使用watch

**🔸 代码可读性原则**  
- 计算属性名要见名知意
- 监听器逻辑要简单清晰
- 避免在计算属性中修改数据

**🔸 维护性原则**
- 一个计算属性只做一件事
- 监听器中避免复杂的嵌套逻辑
- 合理使用deep和immediate选项

> 💡 **核心理解**  
> computed、watch、watchEffect都是Vue帮我们管理数据变化的工具，选择合适的工具能让代码更高效、更易维护。关键是理解它们的特点，在合适的场景使用合适的工具。