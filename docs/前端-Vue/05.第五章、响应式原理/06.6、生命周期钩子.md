---
title: 6、生命周期钩子
---
## 📚 目录

1. [生命周期概念理解](#1-生命周期概念理解)
2. [挂载阶段钩子](#2-挂载阶段钩子)
3. [更新阶段钩子](#3-更新阶段钩子)
4. [卸载阶段钩子](#4-卸载阶段钩子)
5. [组合式API生命周期](#5-组合式API生命周期)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌱 生命周期概念理解


### 1.1 什么是生命周期


**🔸 简单理解**
```
生命周期就像人的一生：出生 → 成长 → 工作 → 退休 → 离世
Vue组件也有类似过程：创建 → 挂载 → 更新 → 销毁
```

生命周期钩子就是Vue在组件各个关键时刻提供的"通知机制"，让你可以在合适的时机执行特定的代码。

**💡 为什么需要生命周期**
- **数据初始化**：组件创建时获取数据
- **DOM操作**：页面渲染完成后操作元素
- **资源清理**：组件销毁时清理定时器、事件监听
- **性能优化**：在合适时机执行耗时操作

### 1.2 生命周期全貌图示


```
组件生命周期流程：

开始
  ↓
创建阶段 ────────── setup() [组合式API]
  ↓
挂载前 ──────────── beforeMount
  ↓
📱 渲染到页面
  ↓
挂载完成 ─────────── mounted ← 🎯 最常用
  ↓
┌─→ 数据变化 ─────── beforeUpdate
│    ↓
│  📱 重新渲染
│    ↓
└── 更新完成 ─────── updated
  ↓
准备销毁 ─────────── beforeUnmount
  ↓
📱 清理资源
  ↓
销毁完成 ─────────── unmounted
  ↓
结束
```

---

## 2. 📦 挂载阶段钩子


### 2.1 beforeMount - 挂载前


**🔸 触发时机**：组件即将挂载到页面，但还没有真正渲染

```vue
<script>
export default {
  beforeMount() {
    console.log('即将挂载到页面')
    console.log('此时还无法访问DOM元素')
    // ❌ 这里获取不到DOM元素
    console.log(this.$refs.myDiv) // undefined
  }
}
</script>
```

**💡 实际用途**
- 很少使用，因为这时DOM还没生成
- 可以做一些最后的数据准备工作

### 2.2 mounted - 挂载完成 ⭐⭐⭐⭐⭐


**🔸 触发时机**：组件已经挂载到页面，DOM元素已经存在

```vue
<template>
  <div ref="myDiv">我是一个div</div>
  <canvas ref="myCanvas"></canvas>
</template>

<script>
export default {
  mounted() {
    // ✅ 可以安全访问DOM元素
    console.log(this.$refs.myDiv) // 获取到div元素
    
    // ✅ 适合做DOM操作
    this.$refs.myDiv.style.color = 'red'
    
    // ✅ 适合初始化第三方库
    this.initChart()
  },
  
  methods: {
    initChart() {
      // 初始化图表库
      const canvas = this.$refs.myCanvas
      // ... 图表初始化代码
    }
  }
}
</script>
```

**🎯 最常用的生命周期钩子**
- **获取数据**：调用API获取页面数据
- **DOM操作**：操作页面元素
- **第三方库初始化**：初始化图表、地图等
- **事件监听**：添加window、document事件

**📚 实用示例**
```vue
<script>
export default {
  data() {
    return {
      userList: []
    }
  },
  
  async mounted() {
    // 1. 获取数据
    this.userList = await this.fetchUsers()
    
    // 2. 添加事件监听
    window.addEventListener('resize', this.handleResize)
    
    // 3. 初始化插件
    this.$nextTick(() => {
      // 确保DOM完全渲染后再操作
      this.initPlugin()
    })
  },
  
  methods: {
    async fetchUsers() {
      const response = await fetch('/api/users')
      return response.json()
    },
    
    handleResize() {
      console.log('窗口大小改变了')
    },
    
    initPlugin() {
      // 初始化第三方插件
    }
  }
}
</script>
```

---

## 3. 🔄 更新阶段钩子


### 3.1 beforeUpdate - 更新前


**🔸 触发时机**：数据改变后，DOM重新渲染前

```vue
<template>
  <div>{{ count }}</div>
  <button @click="count++">增加</button>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  
  beforeUpdate() {
    console.log('数据即将更新')
    console.log('新数据：', this.count)
    console.log('但DOM还是旧的')
  }
}
</script>
```

**💡 使用场景**
- 在DOM更新前获取旧的DOM状态
- 比较少用，因为大多数情况用watch更合适

### 3.2 updated - 更新完成


**🔸 触发时机**：数据改变后，DOM重新渲染完成

```vue
<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  
  updated() {
    console.log('DOM已更新完成')
    console.log('现在可以安全操作新的DOM了')
  }
}
</script>
```

**⚠️ 注意事项**
```vue
<script>
export default {
  updated() {
    // ❌ 危险：可能造成无限循环
    // this.count++ // 这会触发新的更新，然后又进入updated
    
    // ✅ 安全：条件性更新
    if (this.shouldUpdate) {
      this.count++
      this.shouldUpdate = false
    }
  }
}
</script>
```

---

## 4. 💀 卸载阶段钩子


### 4.1 beforeUnmount - 卸载前


**🔸 触发时机**：组件即将被销毁，但还可以正常使用

```vue
<script>
export default {
  beforeUnmount() {
    console.log('组件即将被销毁')
    console.log('但现在还可以访问所有数据和方法')
    
    // ✅ 适合做确认操作
    if (this.hasUnsavedData) {
      const confirmed = confirm('有未保存的数据，确定离开吗？')
      if (!confirmed) {
        // 可以阻止路由跳转等操作
      }
    }
  }
}
</script>
```

### 4.2 unmounted - 卸载完成 ⭐⭐⭐⭐⭐


**🔸 触发时机**：组件已经完全销毁

```vue
<script>
export default {
  data() {
    return {
      timer: null
    }
  },
  
  mounted() {
    // 创建定时器
    this.timer = setInterval(() => {
      console.log('定时执行')
    }, 1000)
    
    // 添加事件监听
    window.addEventListener('scroll', this.handleScroll)
  },
  
  unmounted() {
    // 🎯 重要：清理资源，防止内存泄漏
    
    // 1. 清理定时器
    if (this.timer) {
      clearInterval(this.timer)
      this.timer = null
    }
    
    // 2. 移除事件监听
    window.removeEventListener('scroll', this.handleScroll)
    
    // 3. 取消网络请求
    if (this.cancelToken) {
      this.cancelToken.cancel('组件已销毁')
    }
    
    console.log('组件已完全销毁，资源已清理')
  },
  
  methods: {
    handleScroll() {
      console.log('页面滚动')
    }
  }
}
</script>
```

**🚨 为什么要清理资源**
```
不清理的后果：
❌ 定时器继续执行 → 内存泄漏
❌ 事件监听仍存在 → 报错 + 内存泄漏  
❌ 网络请求继续 → 可能报错

清理后的效果：
✅ 内存及时释放
✅ 避免报错
✅ 性能更好
```

---

## 5. 🔧 组合式API生命周期


### 5.1 对应关系表


| 选项式API | 组合式API | 说明 |
|-----------|-----------|------|
| `beforeMount` | `onBeforeMount` | 挂载前 |
| `mounted` | `onMounted` | 挂载完成 ⭐ |
| `beforeUpdate` | `onBeforeUpdate` | 更新前 |
| `updated` | `onUpdated` | 更新完成 |
| `beforeUnmount` | `onBeforeUnmount` | 卸载前 |
| `unmounted` | `onUnmounted` | 卸载完成 ⭐ |

### 5.2 组合式API写法


```vue
<template>
  <div>{{ count }}</div>
  <button @click="increment">增加</button>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const count = ref(0)
let timer = null

// 🎯 mounted 等价写法
onMounted(() => {
  console.log('组件已挂载')
  
  // 获取数据
  fetchData()
  
  // 创建定时器
  timer = setInterval(() => {
    console.log('定时器执行')
  }, 1000)
})

// 🎯 unmounted 等价写法
onUnmounted(() => {
  console.log('组件即将销毁')
  
  // 清理定时器
  if (timer) {
    clearInterval(timer)
    timer = null
  }
})

const increment = () => {
  count.value++
}

const fetchData = async () => {
  // 获取数据逻辑
}
</script>
```

### 5.3 多个生命周期钩子


```vue
<script setup>
import { onMounted, onUnmounted } from 'vue'

// ✅ 可以多次调用同一个生命周期钩子
onMounted(() => {
  console.log('第一个mounted')
  initCharts()
})

onMounted(() => {
  console.log('第二个mounted')
  fetchUserData()
})

onMounted(() => {
  console.log('第三个mounted')
  setupEventListeners()
})

// 它们会按顺序执行
</script>
```

---

## 6. 🎯 实际应用场景


### 6.1 数据获取最佳实践


```vue
<template>
  <div v-if="loading">加载中...</div>
  <div v-else-if="error">{{ error }}</div>
  <div v-else>
    <h1>用户列表</h1>
    <ul>
      <li v-for="user in users" :key="user.id">
        {{ user.name }}
      </li>
    </ul>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const users = ref([])
const loading = ref(true)
const error = ref('')

onMounted(async () => {
  try {
    loading.value = true
    const response = await fetch('/api/users')
    
    if (!response.ok) {
      throw new Error('获取数据失败')
    }
    
    users.value = await response.json()
  } catch (err) {
    error.value = err.message
  } finally {
    loading.value = false
  }
})
</script>
```

### 6.2 DOM操作示例


```vue
<template>
  <div ref="container" class="chart-container"></div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const container = ref(null)
let chart = null

onMounted(() => {
  // 确保DOM元素存在后再初始化图表
  if (container.value) {
    initChart()
  }
})

onUnmounted(() => {
  // 清理图表资源
  if (chart) {
    chart.destroy()
    chart = null
  }
})

const initChart = () => {
  // 假设使用某个图表库
  chart = new ChartLibrary(container.value, {
    type: 'line',
    data: [1, 2, 3, 4, 5]
  })
}
</script>
```

### 6.3 事件监听管理


```vue
<script setup>
import { onMounted, onUnmounted } from 'vue'

onMounted(() => {
  // 添加各种事件监听
  window.addEventListener('resize', handleResize)
  window.addEventListener('scroll', handleScroll)
  document.addEventListener('keydown', handleKeydown)
})

onUnmounted(() => {
  // 移除所有事件监听
  window.removeEventListener('resize', handleResize)
  window.removeEventListener('scroll', handleScroll)
  document.removeEventListener('keydown', handleKeydown)
})

const handleResize = () => {
  console.log('窗口大小改变')
}

const handleScroll = () => {
  console.log('页面滚动')
}

const handleKeydown = (event) => {
  if (event.key === 'Escape') {
    console.log('按下了ESC键')
  }
}
</script>
```

### 6.4 定时器管理


```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const currentTime = ref(new Date())
let timer = null

onMounted(() => {
  // 每秒更新时间
  timer = setInterval(() => {
    currentTime.value = new Date()
  }, 1000)
})

onUnmounted(() => {
  // 清理定时器
  if (timer) {
    clearInterval(timer)
    timer = null
  }
})
</script>

<template>
  <div>当前时间：{{ currentTime.toLocaleTimeString() }}</div>
</template>
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 生命周期本质：Vue组件从创建到销毁的完整过程
🔸 关键时机：mounted(DOM就绪) 和 unmounted(资源清理)
🔸 核心作用：在合适的时机执行合适的代码
🔸 资源管理：创建时初始化，销毁时清理
🔸 API对应：选项式API vs 组合式API的对应关系
```

### 7.2 最重要的两个钩子


**🎯 mounted - 组件就绪**
```
什么时候用：
✅ 获取页面数据
✅ DOM操作
✅ 初始化第三方库
✅ 添加事件监听
✅ 启动定时器

记忆要点：页面准备好了，可以放心操作
```

**🎯 unmounted - 资源清理**
```
什么时候用：
✅ 清理定时器
✅ 移除事件监听
✅ 取消网络请求
✅ 销毁第三方库实例
✅ 释放内存资源

记忆要点：组件要销毁了，必须清理干净
```

### 7.3 使用原则


**📌 基本原则**
- **成对使用**：在mounted中创建的，在unmounted中清理
- **条件判断**：操作前先判断资源是否存在
- **及时清理**：防止内存泄漏和错误

**⚠️ 常见错误**
```
❌ 只创建不清理：定时器、事件监听器泄漏
❌ 在错误时机操作：beforeMount时操作DOM
❌ updated中修改数据：可能造成无限循环
❌ 忘记清理网络请求：组件销毁后仍然执行回调
```

### 7.4 记忆口诀


```
🎵 生命周期记忆歌：
创建完成可操作，mounted时机刚刚好
数据获取DOM操作，第三方库来初始化
更新前后要谨慎，updated容易死循环
销毁之前做清理，定时事件要移除
资源管理很重要，成对使用不能忘
```

**核心记忆**：
- **mounted = 可以开始干活了**
- **unmounted = 必须收拾干净**
- **配对使用，有借有还**