---
title: 3、计算属性与方法
---
## 📚 目录

1. [计算属性基础概念](#1-计算属性基础概念)
2. [computed()基本使用](#2-computed基本使用)
3. [计算属性缓存机制](#3-计算属性缓存机制)
4. [computed vs methods 核心区别](#4-computed-vs-methods-核心区别)
5. [可写计算属性](#5-可写计算属性)
6. [性能优化与最佳实践](#6-性能优化与最佳实践)
7. [使用场景指南](#7-使用场景指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💡 计算属性基础概念


### 1.1 什么是计算属性


**简单理解**：计算属性就像Excel中的公式，当依赖的数据变化时，结果会自动重新计算。

```
想象一个购物车场景：
原始数据：商品价格、数量
计算属性：总价 = 价格 × 数量

当价格或数量变化时，总价自动更新
```

**核心特点**：
- 🎯 **基于依赖**：依赖其他数据计算得出
- ⚡ **自动更新**：依赖变化时自动重新计算
- 💾 **智能缓存**：依赖不变时使用缓存结果
- 📖 **声明式**：描述"是什么"而不是"怎么做"

### 1.2 为什么需要计算属性


**解决的问题**：
```javascript
// ❌ 模板中写复杂逻辑 - 难以维护
<template>
  <div>{{ user.firstName + ' ' + user.lastName }}</div>
  <div>{{ items.filter(item => item.active).length }}</div>
</template>

// ✅ 使用计算属性 - 简洁清晰
<template>
  <div>{{ fullName }}</div>
  <div>{{ activeItemsCount }}</div>
</template>
```

**带来的好处**：
- 🧹 **模板简洁**：复杂逻辑从模板中抽离
- 🔄 **代码复用**：可在多处使用同一计算逻辑
- 🚀 **性能优化**：缓存机制避免重复计算
- 🐛 **易于调试**：逻辑集中，便于排查问题

---

## 2. 🔧 computed()基本使用


### 2.1 基础语法


```javascript
import { ref, computed } from 'vue'

export default {
  setup() {
    // 响应式数据
    const firstName = ref('张')
    const lastName = ref('三')
    
    // 计算属性
    const fullName = computed(() => {
      return firstName.value + lastName.value
    })
    
    return {
      firstName,
      lastName,
      fullName  // 在模板中可直接使用
    }
  }
}
```

### 2.2 实际应用示例


**购物车总价计算**：
```javascript
// 购物车组件
import { ref, computed } from 'vue'

export default {
  setup() {
    const items = ref([
      { name: '苹果', price: 10, quantity: 2 },
      { name: '香蕉', price: 8, quantity: 3 }
    ])
    
    // 计算总价
    const totalPrice = computed(() => {
      return items.value.reduce((total, item) => {
        return total + (item.price * item.quantity)
      }, 0)
    })
    
    // 计算商品总数
    const totalCount = computed(() => {
      return items.value.reduce((count, item) => {
        return count + item.quantity
      }, 0)
    })
    
    return { items, totalPrice, totalCount }
  }
}
```

**模板使用**：
```html
<template>
  <div class="shopping-cart">
    <div v-for="item in items" :key="item.name">
      {{ item.name }}: ¥{{ item.price }} × {{ item.quantity }}
    </div>
    <div class="summary">
      <p>总数量: {{ totalCount }}件</p>
      <p>总价格: ¥{{ totalPrice }}</p>
    </div>
  </div>
</template>
```

### 2.3 常见应用场景


```javascript
// 1. 数据格式化
const formattedDate = computed(() => {
  return new Date(timestamp.value).toLocaleDateString()
})

// 2. 数据过滤
const activeUsers = computed(() => {
  return users.value.filter(user => user.status === 'active')
})

// 3. 数据转换
const userOptions = computed(() => {
  return users.value.map(user => ({
    label: user.name,
    value: user.id
  }))
})

// 4. 条件判断
const canSubmit = computed(() => {
  return form.value.name && form.value.email && form.value.phone
})
```

---

## 3. 💾 计算属性缓存机制


### 3.1 缓存工作原理


**核心机制**：计算属性会记住依赖的值，只有依赖发生变化时才重新计算。

```javascript
// 演示缓存机制
const count = ref(0)
const expensiveValue = computed(() => {
  console.log('正在计算...') // 只有count变化时才会打印
  
  // 模拟复杂计算
  let result = 0
  for (let i = 0; i < 1000000; i++) {
    result += Math.random()
  }
  return result + count.value
})
```

**缓存流程图**：
```
第一次访问计算属性：
计算属性 → 检查依赖 → 执行计算函数 → 缓存结果 → 返回结果

后续访问（依赖未变）：
计算属性 → 检查依赖 → 发现无变化 → 直接返回缓存 → 返回结果

依赖发生变化：
依赖变化 → 标记缓存失效 → 下次访问重新计算 → 更新缓存 → 返回新结果
```

### 3.2 缓存优势演示


```javascript
// 对比：计算属性 vs 方法调用
export default {
  setup() {
    const items = ref([/* 大量数据 */])
    
    // 计算属性 - 有缓存
    const filteredItems = computed(() => {
      console.log('计算属性执行了') // 依赖不变时不会重复执行
      return items.value.filter(item => item.active)
    })
    
    // 方法 - 无缓存
    const getFilteredItems = () => {
      console.log('方法执行了') // 每次调用都会执行
      return items.value.filter(item => item.active)
    }
    
    return { filteredItems, getFilteredItems }
  }
}
```

```html
<!-- 模板中多次使用 -->
<template>
  <div>
    <!-- 计算属性：只计算一次，后续直接用缓存 -->
    <p>活跃商品数量: {{ filteredItems.length }}</p>
    <ul>
      <li v-for="item in filteredItems" :key="item.id">
        {{ item.name }}
      </li>
    </ul>
    
    <!-- 方法：每次都要重新计算 -->
    <p>活跃商品数量: {{ getFilteredItems().length }}</p>
    <ul>
      <li v-for="item in getFilteredItems()" :key="item.id">
        {{ item.name }}
      </li>
    </ul>
  </div>
</template>
```

---

## 4. ⚔️ computed vs methods 核心区别


### 4.1 功能对比表


| 特性 | **computed 计算属性** | **methods 方法** |
|------|---------------------|-----------------|
| **缓存机制** | ✅ 有缓存，依赖不变时直接返回缓存 | ❌ 无缓存，每次调用都执行 |
| **使用方式** | `{{ computedName }}` | `{{ methodName() }}` |
| **更新时机** | 依赖变化时自动更新 | 手动调用时执行 |
| **适用场景** | 基于现有数据计算新值 | 处理事件、执行操作 |
| **性能影响** | 高性能，适合复杂计算 | 可能影响性能，适合简单操作 |

### 4.2 实际对比示例


```javascript
export default {
  setup() {
    const numbers = ref([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    
    // 计算属性 - 计算偶数的和
    const evenSum = computed(() => {
      console.log('计算属性：计算偶数和')
      return numbers.value
        .filter(n => n % 2 === 0)
        .reduce((sum, n) => sum + n, 0)
    })
    
    // 方法 - 计算偶数的和
    const getEvenSum = () => {
      console.log('方法：计算偶数和')
      return numbers.value
        .filter(n => n % 2 === 0)
        .reduce((sum, n) => sum + n, 0)
    }
    
    // 方法 - 添加新数字（适合用方法）
    const addNumber = () => {
      const newNum = Math.floor(Math.random() * 100)
      numbers.value.push(newNum)
    }
    
    return { numbers, evenSum, getEvenSum, addNumber }
  }
}
```

```html
<template>
  <div>
    <!-- 计算属性：多次使用只计算一次 -->
    <p>偶数和（计算属性）: {{ evenSum }}</p>
    <p>偶数和翻倍: {{ evenSum * 2 }}</p>
    
    <!-- 方法：每次调用都重新计算 -->
    <p>偶数和（方法）: {{ getEvenSum() }}</p>
    <p>偶数和翻倍: {{ getEvenSum() * 2 }}</p>
    
    <!-- 事件处理：必须用方法 -->
    <button @click="addNumber">添加随机数</button>
  </div>
</template>
```

### 4.3 选择指南


```
🎯 选择计算属性 computed 的场景：
✅ 基于现有数据计算新值
✅ 需要在模板中多次使用
✅ 计算逻辑相对复杂
✅ 希望自动响应数据变化
✅ 关注性能优化

🎯 选择方法 methods 的场景：
✅ 处理用户交互事件
✅ 执行某个操作或动作
✅ 需要传递参数
✅ 需要手动控制执行时机
✅ 一次性操作
```

---

## 5. 📝 可写计算属性


### 5.1 基本概念


**可写计算属性**：不仅可以读取值，还可以设置值的计算属性。

```javascript
// 基本语法
const computedValue = computed({
  get() {
    // 读取时的逻辑
    return '计算的值'
  },
  set(newValue) {
    // 设置时的逻辑
    console.log('设置新值:', newValue)
  }
})
```

### 5.2 实际应用示例


**全名编辑器**：
```javascript
import { ref, computed } from 'vue'

export default {
  setup() {
    const firstName = ref('张')
    const lastName = ref('三')
    
    // 可读写的全名计算属性
    const fullName = computed({
      // 读取时：拼接姓和名
      get() {
        return firstName.value + lastName.value
      },
      // 设置时：分割全名为姓和名
      set(newValue) {
        if (newValue.length >= 2) {
          firstName.value = newValue.charAt(0)
          lastName.value = newValue.slice(1)
        }
      }
    })
    
    return { firstName, lastName, fullName }
  }
}
```

```html
<template>
  <div>
    <p>姓: {{ firstName }}</p>
    <p>名: {{ lastName }}</p>
    
    <!-- 可以直接编辑全名 -->
    <input v-model="fullName" placeholder="输入全名">
    
    <!-- 显示完整姓名 -->
    <p>全名: {{ fullName }}</p>
  </div>
</template>
```

**表单数据转换**：
```javascript
// 处理表单中的数字输入
const price = ref(0)

const priceText = computed({
  get() {
    return price.value.toString()
  },
  set(newValue) {
    const numValue = parseFloat(newValue)
    if (!isNaN(numValue)) {
      price.value = numValue
    }
  }
})
```

### 5.3 使用注意事项


> **⚠️ 重要提示**：
> - setter应该避免直接修改计算属性本身
> - setter中的操作应该修改相关的响应式数据
> - 避免在setter中产生副作用（如网络请求）

```javascript
// ❌ 错误用法 - 在setter中产生副作用
const badComputed = computed({
  get() { return someValue.value },
  set(newValue) {
    // 不要在这里发送网络请求
    api.updateValue(newValue)
  }
})

// ✅ 正确用法 - 只修改相关数据
const goodComputed = computed({
  get() { return someValue.value },
  set(newValue) {
    someValue.value = newValue
  }
})
```

---

## 6. 🚀 性能优化与最佳实践


### 6.1 避免在计算属性中产生副作用


```javascript
// ❌ 错误：在计算属性中产生副作用
const badComputed = computed(() => {
  console.log('这会在每次依赖变化时执行') // 副作用
  localStorage.setItem('data', someValue.value) // 副作用
  return someValue.value.toUpperCase()
})

// ✅ 正确：纯函数，无副作用
const goodComputed = computed(() => {
  return someValue.value.toUpperCase()
})
```

### 6.2 合理拆分复杂计算


```javascript
// ❌ 一个复杂的计算属性
const complexComputed = computed(() => {
  const filtered = data.value.filter(item => item.active)
  const sorted = filtered.sort((a, b) => a.order - b.order)
  const grouped = sorted.reduce((groups, item) => {
    // 复杂的分组逻辑...
  }, {})
  return grouped
})

// ✅ 拆分为多个简单的计算属性
const activeItems = computed(() => {
  return data.value.filter(item => item.active)
})

const sortedItems = computed(() => {
  return activeItems.value.sort((a, b) => a.order - b.order)
})

const groupedItems = computed(() => {
  return sortedItems.value.reduce((groups, item) => {
    // 分组逻辑...
  }, {})
})
```

### 6.3 避免不必要的响应式转换


```javascript
// ❌ 在计算属性中创建新的响应式对象
const badComputed = computed(() => {
  return reactive({
    count: count.value,
    double: count.value * 2
  })
})

// ✅ 返回普通对象
const goodComputed = computed(() => {
  return {
    count: count.value,
    double: count.value * 2
  }
})
```

### 6.4 性能监控技巧


```javascript
// 开发环境下监控计算属性性能
const expensiveComputed = computed(() => {
  const start = performance.now()
  
  // 复杂计算逻辑
  const result = heavyCalculation(data.value)
  
  const end = performance.now()
  if (process.env.NODE_ENV === 'development') {
    console.log(`计算耗时: ${end - start}ms`)
  }
  
  return result
})
```

---

## 7. 🎯 使用场景指南


### 7.1 数据展示场景


```javascript
// 列表统计信息
const listStats = computed(() => {
  const total = items.value.length
  const completed = items.value.filter(item => item.completed).length
  const pending = total - completed
  
  return { total, completed, pending }
})

// 数据格式化
const formattedUser = computed(() => {
  const user = userInfo.value
  return {
    ...user,
    fullName: `${user.firstName} ${user.lastName}`,
    formattedPhone: formatPhone(user.phone),
    joinDate: formatDate(user.createdAt)
  }
})
```

### 7.2 表单验证场景


```javascript
// 表单验证状态
const validationState = computed(() => {
  const form = formData.value
  const errors = {}
  
  if (!form.email) {
    errors.email = '邮箱不能为空'
  } else if (!isValidEmail(form.email)) {
    errors.email = '邮箱格式不正确'
  }
  
  if (!form.password || form.password.length < 6) {
    errors.password = '密码至少6位'
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  }
})

// 提交按钮状态
const canSubmit = computed(() => {
  return validationState.value.isValid && !isSubmitting.value
})
```

### 7.3 条件渲染场景


```javascript
// 用户权限判断
const userPermissions = computed(() => {
  const user = currentUser.value
  if (!user) return {}
  
  return {
    canEdit: user.role === 'admin' || user.role === 'editor',
    canDelete: user.role === 'admin',
    canView: true
  }
})

// UI状态计算
const uiState = computed(() => {
  return {
    showLoading: isLoading.value && !hasError.value,
    showError: hasError.value,
    showEmpty: !isLoading.value && !hasError.value && items.value.length === 0,
    showContent: !isLoading.value && !hasError.value && items.value.length > 0
  }
})
```

### 7.4 场景选择总结


```
📊 数据处理类：
✅ 数据过滤、排序、分组
✅ 统计计算（总数、平均值等）
✅ 数据格式化和转换
✅ 多个数据源的合并

🎨 UI状态类：
✅ 组件显示/隐藏逻辑
✅ CSS类名的动态生成
✅ 表单验证状态
✅ 权限判断

🔄 数据联动类：
✅ 级联选择器的选项
✅ 主从表关联数据
✅ 搜索结果过滤
✅ 购物车计算
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 计算属性本质：基于依赖数据的自动计算和缓存
🔸 缓存机制：依赖不变时使用缓存，变化时重新计算
🔸 computed vs methods：缓存 vs 实时，声明 vs 命令
🔸 可写计算属性：支持 get/set 的双向数据绑定
🔸 性能优化：避免副作用，合理拆分，监控性能
```

### 8.2 关键理解要点


**🔹 计算属性的本质**：
```
计算属性 = 数据 + 计算逻辑 + 自动缓存
- 不是存储数据，而是计算数据
- 依赖追踪确保准确更新
- 缓存机制保证高性能
```

**🔹 何时使用计算属性**：
```
当你需要：
✅ 基于现有数据生成新数据
✅ 在模板中多次使用相同计算结果
✅ 自动响应数据变化
✅ 优化复杂计算的性能
```

**🔹 设计原则**：
```
单一职责：一个计算属性只做一件事
纯函数：无副作用，相同输入产生相同输出
语义清晰：名称能清楚表达计算的含义
性能友好：避免过度复杂的计算逻辑
```

### 8.3 实际应用价值


- **数据驱动**：让数据自动驱动界面更新，减少手动操作
- **代码简洁**：将复杂逻辑从模板中抽离，提高可读性
- **性能优化**：智能缓存避免重复计算，提升应用性能
- **维护友好**：集中管理计算逻辑，便于调试和修改

### 8.4 记忆口诀


```
计算属性很智能，依赖变化才计算
缓存机制保性能，模板简洁更美观
get读取set修改，双向绑定真方便
避免副作用陷阱，纯函数思想记心间
```

**核心记忆**：
- 计算属性是"聪明的公式"，会自动计算和缓存
- methods是"工具函数"，每次调用都执行
- 优先使用computed处理数据计算，用methods处理用户操作
- 可写计算属性让复杂数据绑定变得简单