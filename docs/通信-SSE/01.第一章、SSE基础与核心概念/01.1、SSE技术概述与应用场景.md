---
title: 1、SSE技术概述与应用场景
---
## 📚 目录

1. [SSE是什么：从生活场景说起](#1-SSE是什么从生活场景说起)
2. [SSE的工作原理：单向实时通信](#2-SSE的工作原理单向实时通信)
3. [与其他技术对比：为什么选择SSE](#3-与其他技术对比为什么选择SSE)
4. [SSE典型应用场景详解](#4-SSE典型应用场景详解)
5. [浏览器支持与优势局限](#5-浏览器支持与优势局限)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🏠 SSE是什么：从生活场景说起


### 1.1 用生活场景理解SSE


> **生活中的类比**：想象你订阅了一个新闻推送服务，电视台会主动把最新新闻推送到你的手机上，你不需要反复刷新去查看，新闻一有更新就自动出现在你面前。

**SSE就是这样的技术**：
- **全名**：`Server-Sent Events`（服务器发送事件）
- **本质**：服务器主动向客户端推送信息的技术
- **特点**：客户端只需要"订阅"一次，服务器就会持续推送最新数据

```
传统方式（像传统看报纸）：
你 → 问服务器："有新消息吗？"
服务器 → "没有"
（过一会儿）
你 → 又问："现在有新消息吗？"
服务器 → "还是没有"
...反复询问，很累

SSE方式（像订阅推送服务）：
你 → 对服务器说："我想订阅消息推送"
服务器 → "好的，我会主动告诉你"
（有新消息时）
服务器 → 主动推送："嘿！有新消息了！"
你 → 自动收到，无需询问
```

### 1.2 SSE的核心特点


**🔸 单向通信**
- **含义**：只有服务器向客户端发送信息，客户端不能通过SSE向服务器发送
- **类比**：像收音机，只能接收电台广播，不能对电台说话
- **适用场景**：当你只需要接收信息，不需要频繁向服务器发送数据时

**🔸 实时推送**
- **含义**：一旦有新数据，服务器立即推送，不需要等客户端请求
- **优势**：信息传达及时，用户体验好

**🔸 浏览器原生支持**
- **含义**：不需要额外安装插件，现代浏览器都内置支持
- **好处**：开发简单，兼容性好

**🔸 自动重连**
- **含义**：如果连接中断，浏览器会自动尝试重新连接
- **好处**：网络不稳定时也能保持服务

---

## 2. ⚡ SSE的工作原理：单向实时通信


### 2.1 SSE通信流程图


```
SSE通信过程：

客户端                           服务器
   |                              |
   |---[1] 建立SSE连接------------>|
   |   GET /events               |
   |                             |
   |<--[2] 建立长连接响应---------|
   |   Content-Type: text/event-stream
   |                             |
   |<--[3] 推送数据1-------------|
   |   data: 消息内容1           |
   |                             |
   |<--[4] 推送数据2-------------|
   |   data: 消息内容2           |
   |                             |
   |<--[5] 持续推送数据----------|
   |   ...                       |
```

### 2.2 SSE连接建立过程


**步骤①：客户端发起订阅**
```javascript
// 客户端代码（非常简单）
const eventSource = new EventSource('/events');

// 这一行代码就建立了SSE连接
// 告诉服务器："我要订阅你的消息推送"
```

**步骤②：服务器建立长连接**
```javascript
// 服务器响应（Node.js示例）
app.get('/events', (req, res) => {
  // 设置特殊的响应头，告诉浏览器这是SSE连接
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',  // 关键：SSE专用类型
    'Cache-Control': 'no-cache',          // 不缓存
    'Connection': 'keep-alive'            // 保持连接
  });
  
  // 连接建立成功，可以开始推送数据
});
```

**步骤③：服务器推送数据**
```javascript
// 服务器推送消息的格式
res.write('data: 这是推送的消息内容\n\n');

// 特殊格式解释：
// data: 后面跟消息内容
// \n\n 表示一条消息结束
```

### 2.3 SSE数据格式详解


**🔸 基本数据格式**
```
data: 这是一条简单消息

data: 这是一条
data: 多行消息

```

**🔸 带事件类型的格式**
```
event: notification
data: 你有新的通知

event: update  
data: 数据已更新
```

**🔸 带ID的格式（用于断线重连）**
```
id: 123
event: message
data: 带编号的消息
```

> **💡 理解要点**：这些格式看起来简单，但正是这种简单让SSE易于理解和使用。每条消息都以`\n\n`结尾，浏览器看到这个标记就知道"一条完整消息收到了"。

---

## 3. 🔄 与其他技术对比：为什么选择SSE


### 3.1 四种实时通信技术对比


```
实时通信技术对比图：

传统Ajax轮询：
客户端 ──请求──> 服务器
       <──响应──
（等待一段时间）
客户端 ──请求──> 服务器
       <──响应──
（不断重复...）

长轮询：
客户端 ──长时间等待的请求──> 服务器（等待数据）
       <──有数据时才响应────

WebSocket：
客户端 ⟷ 双向通信 ⟷ 服务器
（可以互相发送消息）

SSE：
客户端 <══单向推送═══ 服务器
（只接收，不发送）
```

### 3.2 详细技术对比


| **技术方案** | **通信方式** | **实现复杂度** | **服务器压力** | **适用场景** |
|-------------|-------------|---------------|---------------|-------------|
| **Ajax轮询** | `客户端反复请求` | 🟢 简单 | 🔴 很高 | `更新不频繁的场景` |
| **长轮询** | `客户端等待响应` | 🟡 中等 | 🟡 中等 | `更新较频繁的场景` |
| **WebSocket** | `双向实时通信` | 🔴 复杂 | 🟢 较低 | `需要双向交互的场景` |
| **SSE** | `服务器单向推送` | 🟢 简单 | 🟢 较低 | `只需接收推送的场景` |

### 3.3 为什么选择SSE？


**✅ 选择SSE的场景**：
- **实时通知**：新消息提醒、系统通知
- **数据监控**：股票价格、服务器状态
- **内容更新**：新闻推送、评论更新
- **进度追踪**：文件上传进度、任务处理状态

```javascript
// SSE适合的典型场景示例
const eventSource = new EventSource('/stock-price');

eventSource.onmessage = function(event) {
  const price = JSON.parse(event.data);
  document.getElementById('price').textContent = price.value;
};

// 股票价格一变化，页面立即更新
// 用户不需要刷新页面，不需要点击按钮
```

**❌ 不适合SSE的场景**：
- **聊天应用**：需要用户发送消息（双向通信）→ 用WebSocket
- **游戏应用**：需要频繁双向交互 → 用WebSocket  
- **文件上传**：需要发送大量数据到服务器 → 用普通HTTP

> **🎯 决策原则**：如果你的应用主要是"服务器推送信息给客户端"，那SSE就是最佳选择。如果需要"客户端频繁发送信息给服务器"，那选择WebSocket。

---

## 4. 📱 SSE典型应用场景详解


### 4.1 实时通知系统


**📢 场景描述**：
用户在使用网站时，有新消息、新评论或系统通知时，页面右上角立即显示提醒。

```javascript
// 前端实现
const eventSource = new EventSource('/notifications');

eventSource.addEventListener('notification', function(event) {
  const notification = JSON.parse(event.data);
  
  // 显示通知
  showNotification(notification.title, notification.message);
});

function showNotification(title, message) {
  // 创建通知弹窗
  const notificationDiv = document.createElement('div');
  notificationDiv.innerHTML = `<h4>${title}</h4><p>${message}</p>`;
  document.getElementById('notifications').appendChild(notificationDiv);
}
```

```javascript
// 后端实现（Node.js）
app.get('/notifications', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache'
  });
  
  // 模拟新通知产生
  setInterval(() => {
    const notification = {
      title: '新消息',
      message: '你收到了一条新消息',
      time: new Date().toLocaleTimeString()
    };
    
    res.write(`event: notification\n`);
    res.write(`data: ${JSON.stringify(notification)}\n\n`);
  }, 10000); // 每10秒推送一次
});
```

**💡 为什么用SSE**：
- 通知是单向的（服务器推送给用户）
- 需要实时性（有通知立即显示）
- 实现简单（不需要复杂的双向通信）

### 4.2 实时数据监控


**📊 场景描述**：
监控服务器CPU使用率、内存占用等指标，数据变化时图表实时更新。

```javascript
// 前端监控面板
const eventSource = new EventSource('/system-stats');

eventSource.onmessage = function(event) {
  const stats = JSON.parse(event.data);
  
  // 更新图表
  updateCPUChart(stats.cpu);
  updateMemoryChart(stats.memory);
  updateDiskChart(stats.disk);
};

function updateCPUChart(cpuUsage) {
  document.getElementById('cpu-usage').textContent = cpuUsage + '%';
  document.getElementById('cpu-bar').style.width = cpuUsage + '%';
}
```

```javascript
// 后端数据收集
app.get('/system-stats', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache'
  });
  
  // 每5秒推送一次系统状态
  setInterval(() => {
    const stats = {
      cpu: Math.floor(Math.random() * 100),      // 模拟CPU使用率
      memory: Math.floor(Math.random() * 100),   // 模拟内存使用率
      disk: Math.floor(Math.random() * 100),     // 模拟磁盘使用率
      timestamp: new Date().toISOString()
    };
    
    res.write(`data: ${JSON.stringify(stats)}\n\n`);
  }, 5000);
});
```

### 4.3 实时日志查看


**📝 场景描述**：
开发者需要实时查看服务器日志，新的日志条目产生时立即显示在网页上。

```javascript
// 前端日志查看器
const eventSource = new EventSource('/logs');

eventSource.onmessage = function(event) {
  const logEntry = JSON.parse(event.data);
  
  const logDiv = document.createElement('div');
  logDiv.className = `log-entry ${logEntry.level}`;
  logDiv.innerHTML = `
    <span class="timestamp">${logEntry.timestamp}</span>
    <span class="level">[${logEntry.level}]</span>
    <span class="message">${logEntry.message}</span>
  `;
  
  document.getElementById('log-container').appendChild(logDiv);
};
```

**🔧 为什么这些场景适合SSE**：
- **单向数据流**：都是服务器向客户端推送信息
- **实时性要求**：数据变化需要立即反映在界面上
- **持续连接**：需要保持长时间连接以接收持续更新
- **实现简单**：不需要复杂的握手协议或双向通信

---

## 5. 🌐 浏览器支持与优势局限


### 5.1 浏览器兼容性现状


**✅ 支持情况**：

| **浏览器** | **支持版本** | **支持程度** | **注意事项** |
|-----------|-------------|-------------|-------------|
| **Chrome** | `6+` | 🟢 完全支持 | `最佳性能` |
| **Firefox** | `6+` | 🟢 完全支持 | `稳定可靠` |
| **Safari** | `5+` | 🟢 完全支持 | `iOS Safari也支持` |
| **Edge** | `12+` | 🟢 完全支持 | `替代IE的现代浏览器` |
| **IE** | `❌` | 🔴 不支持 | `需要polyfill` |

> **💡 实际情况**：现在IE已经退出历史舞台，SSE的兼容性已经不是问题。移动端浏览器也都支持得很好。

### 5.2 SSE的核心优势


**🚀 优势分析**：

```
SSE优势总览：

┌─────────────────────────────────────────┐
│              SSE核心优势                │
├─────────────────────────────────────────┤
│ 🟢 实现简单    │ 📱 浏览器原生支持      │
│ 🟢 自动重连    │ ⚡ 实时性好           │  
│ 🟢 服务器压力小 │ 🔄 HTTP协议兼容      │
└─────────────────────────────────────────┘
```

**详细优势说明**：

- **🟢 实现极简**
```javascript
// 客户端只需一行代码
const eventSource = new EventSource('/events');
eventSource.onmessage = (event) => console.log(event.data);
```

- **🔄 自动重连**
```javascript
// 连接断开时浏览器自动重连，开发者无需处理
eventSource.onerror = function() {
  console.log('连接出错，浏览器会自动重连');
};
```

- **📡 服务器压力小**：一个连接可以推送无限多条消息，不像Ajax轮询那样需要不断建立新连接

### 5.3 SSE的局限性


**⚠️ 需要了解的限制**：

**🔸 单向通信限制**
```javascript
// SSE只能接收，不能发送
eventSource.send("消息"); // ❌ 这样是不行的

// 如果需要发送数据，还是要用传统Ajax
fetch('/api/send-message', {
  method: 'POST',
  body: JSON.stringify({message: "用户回复"})
});
```

**🔸 连接数限制**
- 浏览器对同一域名的SSE连接有数量限制（通常6个）
- 解决方案：合理设计，一个页面通常只需要一个SSE连接

**🔸 数据格式限制**
- 只能发送文本数据
- 需要发送复杂数据时要进行JSON序列化

```javascript
// 服务器发送复杂数据
const data = {
  user: "张三",
  message: "Hello",
  timestamp: new Date()
};
res.write(`data: ${JSON.stringify(data)}\n\n`);

// 客户端接收并解析
eventSource.onmessage = function(event) {
  const data = JSON.parse(event.data); // 需要手动解析JSON
};
```

### 5.4 SSE vs WebSocket 实际选择建议


**🎯 决策流程图**：

```
需要实时通信？
       │
       ├─ 是 → 需要客户端向服务器发送消息？
       │              │
       │              ├─ 是 → 选择 WebSocket
       │              │
       │              └─ 否 → 选择 SSE
       │
       └─ 否 → 使用普通 Ajax
```

**💡 实际建议**：
- **新手入门**：先学SSE，概念简单，容易理解
- **简单推送**：通知、监控、日志等单向推送场景用SSE
- **复杂交互**：聊天、游戏、协作编辑等双向交互用WebSocket
- **偶尔更新**：数据更新不频繁就用Ajax轮询

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 SSE本质：服务器主动向客户端推送数据的技术
🔸 核心特点：单向通信、实时推送、自动重连、浏览器原生支持
🔸 工作原理：建立长连接，服务器持续推送，客户端被动接收
🔸 数据格式：data: 消息内容\n\n 的简单文本格式
🔸 典型场景：实时通知、数据监控、日志查看、进度跟踪
🔸 技术选择：单向推送用SSE，双向交互用WebSocket
```

### 6.2 关键理解要点


**🔹 SSE的定位理解**
```
SSE不是万能的实时通信解决方案
它是"服务器向客户端单向推送"的最佳选择
简单、稳定、够用
```

**🔹 实际使用的思维模式**
```
不要把SSE想得太复杂
就像订阅推送服务一样
客户端："我要订阅"
服务器："好的，有消息我告诉你"
就这么简单
```

**🔹 与其他技术的区别**
```
Ajax轮询：我反复问你
长轮询：我等着你告诉我  
WebSocket：我们互相聊天
SSE：你主动告诉我
```

### 6.3 实际应用价值


**💼 开发实践**
- **快速原型**：需要实时推送时，SSE是最快的实现方案
- **系统监控**：服务器状态、性能指标的实时展示
- **用户体验**：通知推送、进度更新等提升用户体验
- **成本控制**：相比WebSocket，SSE的服务器资源消耗更小

**🎯 学习建议**
- **先理解概念**：明白SSE是做什么的，解决什么问题
- **动手实践**：写一个简单的通知推送功能
- **对比学习**：了解与WebSocket、Ajax的区别和适用场景
- **深入应用**：在实际项目中寻找SSE的应用机会

### 6.4 常见误区提醒


**⚠️ 新手常见误解**
```
❌ 误解："SSE可以双向通信"
✅ 正确："SSE只能单向推送，需要双向通信用WebSocket"

❌ 误解："SSE很复杂，难以掌握"  
✅ 正确："SSE是最简单的实时推送方案"

❌ 误解："SSE适合所有实时场景"
✅ 正确："SSE适合单向推送场景，双向交互场景用其他技术"
```

**💡 最佳心态**
```
把SSE当作一个专用工具
它不能解决所有问题
但在它擅长的领域，它是最佳选择
简单、稳定、够用就是它的价值
```

**核心记忆口诀**：
```
服务器主动来推送，单向通信是特长
实时通知和监控，SSE技术帮你忙  
浏览器原生就支持，实现简单不复杂
选择技术看场景，够用简单就最佳
```