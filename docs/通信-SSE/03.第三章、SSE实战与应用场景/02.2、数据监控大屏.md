---
title: 2、数据监控大屏
---
## 📚 目录

1. [项目概述与核心概念](#1-项目概述与核心概念)
2. [实时数据采集架构设计](#2-实时数据采集架构设计)
3. [多指标数据推送策略](#3-多指标数据推送策略)
4. [图表库集成与实时更新](#4-图表库集成与实时更新)
5. [数据缓存策略设计](#5-数据缓存策略设计)
6. [推送频率控制算法](#6-推送频率控制算法)
7. [大屏性能优化技术](#7-大屏性能优化技术)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 项目概述与核心概念


### 1.1 什么是数据监控大屏


**通俗理解**：就像银行、商场里经常看到的那些大显示屏，实时显示各种数据指标

```
实际场景举例：
🏢 公司营销大屏：实时显示订单数、销售额、用户访问量
🏥 医院监护大屏：病人生命体征、设备状态、病房占用率  
🏭 工厂监控大屏：生产线状态、产量、设备温度、故障报警
📊 股票交易大屏：股价波动、成交量、市场指数
```

### 1.2 为什么用SSE而不是其他方案


**核心优势对比**：

| 方案类型 | **适用场景** | **优劣势** |
|---------|-------------|-----------|
| 🔄 **轮询请求** | `简单场景` | `实现简单，但消耗资源大，延迟高` |
| 🔌 **WebSocket** | `双向交互多` | `功能强大，但复杂度高，资源消耗大` |
| ⚡ **SSE** | `单向数据推送` | `简单高效，自动重连，完美适合监控大屏` |

**SSE的天然优势**：
```
✅ 浏览器原生支持，不需要额外库
✅ 自动断线重连，网络波动不影响
✅ 服务器单向推送，正好符合大屏需求
✅ 资源消耗小，可以同时支持很多客户端
✅ 实现简单，维护成本低
```

### 1.3 监控大屏的核心要素


**必备功能清单**：
```
🔸 实时数据展示：数据一有变化立即更新
🔸 多图表支持：柱状图、折线图、仪表盘、地图等
🔸 响应式布局：适配不同尺寸的显示屏
🔸 数据缓存：避免网络问题导致界面空白
🔸 性能优化：确保长时间运行不卡顿
🔸 异常处理：网络断开、数据异常的友好提示
```

---

## 2. 🏗️ 实时数据采集架构设计


### 2.1 整体架构流程图


```
数据源层          处理层              推送层            展示层
┌─────────┐    ┌─────────┐    ┌─────────────┐    ┌─────────┐
│ 数据库  │    │         │    │             │    │         │
│ MySQL   │───▶│  数据   │───▶│   SSE服务   │───▶│ 大屏页面 │
├─────────┤    │  采集   │    │             │    │         │
│  Redis  │───▶│  服务   │───▶│  实时推送   │───▶│图表更新 │
├─────────┤    │         │    │             │    │         │
│ 外部API │───▶│ (定时)  │    │ (长连接)    │    │ (前端)  │
├─────────┤    │         │    │             │    │         │
│ 日志文件│───▶│         │    │             │    │         │
└─────────┘    └─────────┘    └─────────────┘    └─────────┘
```

### 2.2 数据采集服务设计


**核心思路**：把各种数据源的数据统一收集，然后推送给大屏

```javascript
// 数据采集服务示例
class DataCollector {
    constructor() {
        this.dataCache = new Map(); // 缓存最新数据
        this.subscribers = []; // SSE连接列表
    }
    
    // 启动数据采集
    start() {
        // 每5秒采集一次数据
        setInterval(() => {
            this.collectAllData();
        }, 5000);
    }
    
    // 采集所有数据
    async collectAllData() {
        try {
            // 采集销售数据
            const salesData = await this.getSalesData();
            // 采集用户数据  
            const userData = await this.getUserData();
            // 采集系统状态
            const systemData = await this.getSystemData();
            
            // 组合所有数据
            const allData = {
                timestamp: Date.now(),
                sales: salesData,
                users: userData, 
                system: systemData
            };
            
            // 推送给所有大屏
            this.pushToAllScreens(allData);
        } catch (error) {
            console.error('数据采集失败:', error);
        }
    }
}
```

### 2.3 数据源适配器模式


**为什么需要适配器**：不同数据源的数据格式不一样，需要统一处理

```javascript
// 不同数据源的适配器
class DatabaseAdapter {
    // 从数据库获取销售数据
    async getSalesData() {
        const result = await db.query(`
            SELECT COUNT(*) as orderCount, 
                   SUM(amount) as totalAmount 
            FROM orders 
            WHERE DATE(created_at) = CURDATE()
        `);
        return {
            todayOrders: result[0].orderCount,
            todayRevenue: result[0].totalAmount
        };
    }
}

class RedisAdapter {
    // 从Redis获取在线用户数
    async getOnlineUsers() {
        const count = await redis.scard('online_users');
        return { onlineCount: count };
    }
}

class APIAdapter {
    // 从外部API获取天气数据
    async getWeatherData() {
        const response = await fetch('http://api.weather.com/current');
        const data = await response.json();
        return {
            temperature: data.temperature,
            humidity: data.humidity
        };
    }
}
```

---

## 3. 📊 多指标数据推送策略


### 3.1 什么是多指标数据推送


**简单理解**：一个监控大屏通常要显示很多不同的数据，比如销售额、订单数、用户数等，这些就是不同的指标

### 3.2 推送策略设计


**核心问题**：这些指标更新频率不同，有些需要实时更新，有些可以慢一点

```
指标分类与推送频率：

🔴 实时指标 (每1-3秒更新)：
   - 在线用户数
   - 实时订单数
   - 系统CPU/内存使用率
   
🟡 准实时指标 (每10-30秒更新)：
   - 今日销售额
   - 页面访问量
   - 库存数量
   
🟢 周期性指标 (每1-5分钟更新)：
   - 月度统计数据
   - 用户地域分布
   - 商品热门排行
```

### 3.3 分级推送实现


```javascript
// 分级推送策略
class MetricsManager {
    constructor() {
        // 不同级别的数据更新间隔
        this.intervals = {
            realtime: 3000,    // 3秒
            neartime: 15000,   // 15秒  
            periodic: 60000    // 60秒
        };
        
        this.metrics = {
            realtime: ['onlineUsers', 'currentOrders', 'systemStatus'],
            neartime: ['todayRevenue', 'pageViews', 'inventory'], 
            periodic: ['monthlyStats', 'userDistribution', 'topProducts']
        };
    }
    
    // 启动分级推送
    startPush() {
        // 实时指标推送
        setInterval(() => {
            this.pushMetrics('realtime');
        }, this.intervals.realtime);
        
        // 准实时指标推送
        setInterval(() => {
            this.pushMetrics('neartime');
        }, this.intervals.neartime);
        
        // 周期性指标推送
        setInterval(() => {
            this.pushMetrics('periodic');
        }, this.intervals.periodic);
    }
    
    // 推送指定级别的指标
    async pushMetrics(level) {
        const metricsToUpdate = this.metrics[level];
        const data = {};
        
        for (const metric of metricsToUpdate) {
            data[metric] = await this.getMetricValue(metric);
        }
        
        // 推送数据，包含级别信息
        this.broadcast({
            type: 'metrics_update',
            level: level,
            data: data,
            timestamp: Date.now()
        });
    }
}
```

### 3.4 智能推送优化


**核心思路**：数据变化大的时候多推送，变化小的时候少推送

```javascript
class SmartPusher {
    constructor() {
        this.lastValues = new Map(); // 记录上次的值
        this.thresholds = {
            // 变化阈值：超过这个比例才推送
            onlineUsers: 0.05,    // 5%变化
            revenue: 0.02,        // 2%变化
            pageViews: 0.1        // 10%变化
        };
    }
    
    // 智能判断是否需要推送
    shouldPush(metricName, newValue) {
        const lastValue = this.lastValues.get(metricName);
        
        if (!lastValue) {
            // 第一次，肯定要推送
            this.lastValues.set(metricName, newValue);
            return true;
        }
        
        // 计算变化比例
        const changeRatio = Math.abs(newValue - lastValue) / lastValue;
        const threshold = this.thresholds[metricName] || 0.05;
        
        if (changeRatio >= threshold) {
            this.lastValues.set(metricName, newValue);
            return true; // 变化够大，需要推送
        }
        
        return false; // 变化太小，不推送
    }
}
```

---

## 4. 📈 图表库集成与实时更新


### 4.1 主流图表库选择


**Chart.js vs ECharts 对比**：

| 特性 | **Chart.js** | **ECharts** |
|-----|-------------|-------------|
| 🎯 **易用性** | `简单易学，配置简洁` | `功能丰富，配置复杂` |
| 📊 **图表类型** | `基础图表够用` | `图表类型非常丰富` |
| 🚀 **性能** | `中等，适合中小数据量` | `优秀，适合大数据量` |
| 🎨 **自定义** | `有限的自定义能力` | `高度自定义` |
| 📱 **响应式** | `良好的响应式支持` | `需要手动处理` |

**选择建议**：
- 🟢 **简单项目**：用Chart.js，快速上手
- 🟡 **复杂项目**：用ECharts，功能强大
- 🔴 **大数据量**：首选ECharts

### 4.2 Chart.js实时更新实现


```javascript
// Chart.js实时更新示例
class ChartManager {
    constructor() {
        this.charts = new Map(); // 存储所有图表实例
        this.initSSE(); // 初始化SSE连接
    }
    
    // 创建销售额图表
    createSalesChart() {
        const ctx = document.getElementById('salesChart').getContext('2d');
        
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [], // 时间标签
                datasets: [{
                    label: '实时销售额',
                    data: [],
                    borderColor: '#4CAF50',
                    backgroundColor: 'rgba(76, 175, 80, 0.1)',
                    tension: 0.4 // 平滑曲线
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '销售额(元)'
                        }
                    }
                },
                // 图表动画配置
                animation: {
                    duration: 500 // 更新动画时长
                }
            }
        });
        
        this.charts.set('sales', chart);
        return chart;
    }
    
    // 更新图表数据
    updateChart(chartName, newData) {
        const chart = this.charts.get(chartName);
        if (!chart) return;
        
        const now = new Date().toLocaleTimeString();
        
        // 添加新数据点
        chart.data.labels.push(now);
        chart.data.datasets[0].data.push(newData.value);
        
        // 保持最近20个数据点，删除旧数据
        if (chart.data.labels.length > 20) {
            chart.data.labels.shift();
            chart.data.datasets[0].data.shift();
        }
        
        // 刷新图表显示
        chart.update('none'); // 'none'表示无动画更新，性能更好
    }
    
    // SSE数据处理
    initSSE() {
        const eventSource = new EventSource('/dashboard-stream');
        
        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            
            // 根据数据类型更新对应图表
            if (data.sales) {
                this.updateChart('sales', data.sales);
            }
            if (data.orders) {
                this.updateChart('orders', data.orders);
            }
        };
    }
}
```

### 4.3 ECharts实时更新实现


```javascript
// ECharts实时更新示例
class EChartsManager {
    constructor() {
        this.charts = new Map();
        this.initSSE();
    }
    
    // 创建仪表盘图表
    createGaugeChart() {
        const chart = echarts.init(document.getElementById('cpuChart'));
        
        const option = {
            title: {
                text: 'CPU使用率',
                left: 'center',
                textStyle: { color: '#fff' }
            },
            series: [{
                type: 'gauge',
                min: 0,
                max: 100,
                axisLine: {
                    lineStyle: {
                        color: [[0.3, '#67C23A'], [0.7, '#E6A23C'], [1, '#F56C6C']],
                        width: 30
                    }
                },
                detail: {
                    formatter: '{value}%',
                    fontSize: 20,
                    color: '#fff'
                },
                data: [{
                    value: 0,
                    name: 'CPU'
                }]
            }]
        };
        
        chart.setOption(option);
        this.charts.set('cpu', chart);
    }
    
    // 更新仪表盘数据
    updateGauge(chartName, value) {
        const chart = this.charts.get(chartName);
        if (!chart) return;
        
        // ECharts更新数据的方式
        chart.setOption({
            series: [{
                data: [{ value: value, name: 'CPU' }]
            }]
        });
    }
}
```

---

## 5. 🗄️ 数据缓存策略设计


### 5.1 为什么需要数据缓存


**实际问题场景**：
```
😵 网络断开：大屏突然显示空白，用户体验很差
🐌 数据源故障：数据库宕机，但大屏还要继续显示
⚡ 性能优化：避免频繁请求相同数据
🔄 平滑过渡：新旧数据之间的自然切换
```

### 5.2 多层缓存架构


```
缓存层级架构：

前端缓存层     服务端缓存层      数据源层
┌─────────┐    ┌─────────┐    ┌─────────┐
│浏览器   │    │ Redis   │    │ MySQL   │
│本地缓存 │◄──▶│ 缓存    │◄──▶│ 数据库  │
│(内存)   │    │(5分钟)  │    │         │
└─────────┘    └─────────┘    └─────────┘
     ▲              ▲              ▲
     │              │              │
   实时更新        定期更新        原始数据
```

### 5.3 前端缓存实现


```javascript
// 前端数据缓存管理器
class DataCache {
    constructor() {
        this.cache = new Map(); // 内存缓存
        this.cacheTimeout = 30000; // 30秒过期
        this.fallbackData = {}; // 兜底数据
    }
    
    // 设置缓存数据
    set(key, data) {
        this.cache.set(key, {
            data: data,
            timestamp: Date.now(),
            expires: Date.now() + this.cacheTimeout
        });
        
        // 同时存储到本地存储作为兜底
        try {
            localStorage.setItem(`dashboard_${key}`, JSON.stringify(data));
        } catch (e) {
            console.warn('localStorage存储失败');
        }
    }
    
    // 获取缓存数据
    get(key) {
        const cached = this.cache.get(key);
        
        // 检查缓存是否过期
        if (cached && cached.expires > Date.now()) {
            return cached.data; // 返回有效缓存
        }
        
        // 缓存过期，尝试获取兜底数据
        try {
            const fallback = localStorage.getItem(`dashboard_${key}`);
            if (fallback) {
                console.warn(`使用兜底数据: ${key}`);
                return JSON.parse(fallback);
            }
        } catch (e) {
            console.error('兜底数据解析失败');
        }
        
        return null; // 没有可用数据
    }
    
    // 预热缓存：提前加载重要数据
    async warmup() {
        const criticalMetrics = ['onlineUsers', 'todayRevenue', 'systemStatus'];
        
        for (const metric of criticalMetrics) {
            try {
                const data = await this.fetchMetricData(metric);
                this.set(metric, data);
            } catch (error) {
                console.error(`预热缓存失败: ${metric}`, error);
            }
        }
    }
}
```

### 5.4 智能缓存更新策略


```javascript
// 智能缓存更新
class SmartCacheUpdater {
    constructor(cache) {
        this.cache = cache;
        this.updateStrategies = {
            // 不同指标的更新策略
            onlineUsers: { priority: 'high', maxAge: 5000 },    // 5秒
            todayRevenue: { priority: 'medium', maxAge: 15000 }, // 15秒
            monthlyStats: { priority: 'low', maxAge: 300000 }   // 5分钟
        };
    }
    
    // 根据优先级更新缓存
    updateByPriority(newData) {
        Object.keys(newData).forEach(key => {
            const strategy = this.updateStrategies[key];
            if (!strategy) return;
            
            const cached = this.cache.get(key);
            const now = Date.now();
            
            // 高优先级数据：立即更新
            if (strategy.priority === 'high') {
                this.cache.set(key, newData[key]);
                return;
            }
            
            // 中低优先级：检查时间间隔
            if (!cached || (now - cached.timestamp) > strategy.maxAge) {
                this.cache.set(key, newData[key]);
            }
        });
    }
}
```

---

## 6. ⚡ 推送频率控制算法


### 6.1 为什么要控制推送频率


**实际问题**：
```
🚫 推送太频繁：浏览器卡顿，用户看花眼
🐌 推送太慢：数据不够实时，失去监控意义
🔋 资源浪费：无意义的推送消耗服务器和网络资源
👥 多客户端：不同大屏可能需要不同的推送频率
```

### 6.2 自适应频率控制算法


```javascript
// 自适应推送频率控制器
class AdaptivePushController {
    constructor() {
        this.clientConnections = new Map(); // 客户端连接信息
        this.baseInterval = 5000; // 基础推送间隔5秒
        this.maxInterval = 60000; // 最大间隔60秒
        this.minInterval = 1000;  // 最小间隔1秒
    }
    
    // 注册客户端
    registerClient(clientId, preferences = {}) {
        this.clientConnections.set(clientId, {
            id: clientId,
            lastPushTime: 0,
            currentInterval: this.baseInterval,
            dataChangeCount: 0, // 数据变化次数
            priority: preferences.priority || 'normal', // 优先级
            screenSize: preferences.screenSize || 'large' // 屏幕大小
        });
    }
    
    // 计算推送间隔
    calculateInterval(clientId, dataVolatility) {
        const client = this.clientConnections.get(clientId);
        if (!client) return this.baseInterval;
        
        let interval = this.baseInterval;
        
        // 根据数据变化频率调整
        if (dataVolatility > 0.8) {
            interval = this.minInterval; // 数据变化大，推送快
        } else if (dataVolatility < 0.2) {
            interval = this.maxInterval; // 数据变化小，推送慢
        } else {
            // 线性调整
            interval = this.baseInterval + (this.maxInterval - this.baseInterval) * (1 - dataVolatility);
        }
        
        // 根据客户端优先级调整
        if (client.priority === 'high') {
            interval *= 0.5; // 高优先级客户端推送更频繁
        } else if (client.priority === 'low') {
            interval *= 2; // 低优先级客户端推送较慢
        }
        
        // 根据屏幕大小调整
        if (client.screenSize === 'small') {
            interval *= 1.5; // 小屏幕推送较慢
        }
        
        // 确保在合理范围内
        interval = Math.max(this.minInterval, Math.min(this.maxInterval, interval));
        
        // 更新客户端配置
        client.currentInterval = interval;
        return interval;
    }
    
    // 判断是否需要推送
    shouldPush(clientId, currentData) {
        const client = this.clientConnections.get(clientId);
        if (!client) return false;
        
        const now = Date.now();
        const timeSinceLastPush = now - client.lastPushTime;
        
        // 计算数据变化程度
        const volatility = this.calculateDataVolatility(currentData);
        const requiredInterval = this.calculateInterval(clientId, volatility);
        
        if (timeSinceLastPush >= requiredInterval) {
            client.lastPushTime = now;
            return true;
        }
        
        return false;
    }
    
    // 计算数据变化程度
    calculateDataVolatility(data) {
        // 简化算法：基于数据变化次数
        const changeCount = this.countDataChanges(data);
        return Math.min(changeCount / 10, 1); // 标准化到0-1
    }
}
```

### 6.3 流量控制算法


```javascript
// 流量控制器：防止推送过载
class TrafficController {
    constructor() {
        this.maxConcurrentPush = 100; // 最大并发推送数
        this.currentPushCount = 0;
        this.pushQueue = []; // 推送队列
        this.rateLimiter = new Map(); // 频率限制器
    }
    
    // 令牌桶算法限制推送频率
    async requestPush(clientId, data) {
        const bucket = this.getRateLimiterBucket(clientId);
        
        if (!bucket.hasToken()) {
            // 没有令牌，加入队列等待
            return new Promise((resolve) => {
                this.pushQueue.push({ clientId, data, resolve });
            });
        }
        
        // 有令牌，可以立即推送
        bucket.consumeToken();
        return this.executePush(clientId, data);
    }
    
    // 获取客户端的令牌桶
    getRateLimiterBucket(clientId) {
        if (!this.rateLimiter.has(clientId)) {
            this.rateLimiter.set(clientId, new TokenBucket(10, 2)); // 容量10，每秒补充2个
        }
        return this.rateLimiter.get(clientId);
    }
    
    // 执行推送
    async executePush(clientId, data) {
        if (this.currentPushCount >= this.maxConcurrentPush) {
            throw new Error('推送服务过载');
        }
        
        this.currentPushCount++;
        
        try {
            await this.sendToClient(clientId, data);
        } finally {
            this.currentPushCount--;
            this.processQueue(); // 处理排队的推送
        }
    }
}

// 令牌桶实现
class TokenBucket {
    constructor(capacity, refillRate) {
        this.capacity = capacity; // 桶容量
        this.tokens = capacity;   // 当前令牌数
        this.refillRate = refillRate; // 每秒补充令牌数
        this.lastRefill = Date.now();
        
        // 定期补充令牌
        setInterval(() => this.refill(), 1000);
    }
    
    // 补充令牌
    refill() {
        const now = Date.now();
        const timePassed = (now - this.lastRefill) / 1000;
        this.tokens = Math.min(this.capacity, this.tokens + timePassed * this.refillRate);
        this.lastRefill = now;
    }
    
    // 检查是否有令牌
    hasToken() {
        this.refill(); // 先补充令牌
        return this.tokens >= 1;
    }
    
    // 消费令牌
    consumeToken() {
        if (this.hasToken()) {
            this.tokens -= 1;
            return true;
        }
        return false;
    }
}
```

---

## 7. 🚀 大屏性能优化技术


### 7.1 性能问题的常见表现


**用户体验问题**：
```
😵 页面卡顿：图表更新时页面卡住
🔥 内存泄漏：长时间运行后内存占用越来越大
🐌 加载缓慢：初次打开大屏很慢
💔 连接断开：SSE连接不稳定，频繁断开重连
🎨 动画卡顿：图表动画不流畅
```

### 7.2 前端性能优化策略


```javascript
// 性能优化管理器
class PerformanceOptimizer {
    constructor() {
        this.frameRate = 60; // 目标帧率
        this.updateQueue = []; // 更新队列
        this.isUpdating = false; // 防止重复更新
        this.memoryMonitor = new MemoryMonitor();
    }
    
    // 批量更新：避免频繁DOM操作
    batchUpdate(updates) {
        this.updateQueue.push(...updates);
        
        if (!this.isUpdating) {
            this.isUpdating = true;
            // 使用requestAnimationFrame优化动画
            requestAnimationFrame(() => {
                this.processUpdateQueue();
                this.isUpdating = false;
            });
        }
    }
    
    // 处理更新队列
    processUpdateQueue() {
        const startTime = performance.now();
        const maxProcessTime = 16; // 16ms内完成，保证60fps
        
        while (this.updateQueue.length > 0 && 
               (performance.now() - startTime) < maxProcessTime) {
            const update = this.updateQueue.shift();
            this.executeUpdate(update);
        }
        
        // 如果还有未处理的更新，下一帧继续
        if (this.updateQueue.length > 0) {
            requestAnimationFrame(() => this.processUpdateQueue());
        }
    }
    
    // 虚拟滚动：大量数据展示优化
    createVirtualList(container, data, itemHeight) {
        const containerHeight = container.offsetHeight;
        const visibleCount = Math.ceil(containerHeight / itemHeight) + 2; // 多渲染2个防止空白
        
        let scrollTop = 0;
        
        // 滚动事件处理（节流）
        const onScroll = this.throttle((e) => {
            scrollTop = e.target.scrollTop;
            this.renderVisibleItems();
        }, 16); // 60fps
        
        const renderVisibleItems = () => {
            const startIndex = Math.floor(scrollTop / itemHeight);
            const endIndex = Math.min(startIndex + visibleCount, data.length);
            
            // 只渲染可见区域的DOM
            const fragment = document.createDocumentFragment();
            for (let i = startIndex; i < endIndex; i++) {
                const item = this.createListItem(data[i], i * itemHeight);
                fragment.appendChild(item);
            }
            
            // 更新容器内容
            container.innerHTML = '';
            container.appendChild(fragment);
        };
        
        container.addEventListener('scroll', onScroll);
        renderVisibleItems(); // 初始渲染
    }
    
    // 事件节流：减少事件处理频率
    throttle(func, delay) {
        let timeout = null;
        return function (...args) {
            if (!timeout) {
                timeout = setTimeout(() => {
                    func.apply(this, args);
                    timeout = null;
                }, delay);
            }
        };
    }
}
```

### 7.3 内存管理与垃圾回收


```javascript
// 内存监控器
class MemoryMonitor {
    constructor() {
        this.memoryThreshold = 100 * 1024 * 1024; // 100MB阈值
        this.cleanupTasks = [];
        this.startMonitoring();
    }
    
    // 开始内存监控
    startMonitoring() {
        setInterval(() => {
            this.checkMemoryUsage();
        }, 30000); // 每30秒检查一次
    }
    
    // 检查内存使用情况
    checkMemoryUsage() {
        if (performance.memory) {
            const used = performance.memory.usedJSHeapSize;
            const limit = performance.memory.jsHeapSizeLimit;
            const usage = used / limit;
            
            console.log(`内存使用率: ${(usage * 100).toFixed(2)}%`);
            
            if (used > this.memoryThreshold || usage > 0.8) {
                console.warn('内存使用过高，执行清理');
                this.performCleanup();
            }
        }
    }
    
    // 执行内存清理
    performCleanup() {
        // 执行注册的清理任务
        this.cleanupTasks.forEach(task => {
            try {
                task();
            } catch (error) {
                console.error('清理任务失败:', error);
            }
        });
        
        // 强制垃圾回收（仅在开发环境）
        if (window.gc && typeof window.gc === 'function') {
            window.gc();
        }
    }
    
    // 注册清理任务
    registerCleanupTask(task) {
        this.cleanupTasks.push(task);
    }
}

// 图表内存清理示例
class ChartMemoryManager {
    constructor() {
        this.charts = new Map();
        this.maxDataPoints = 50; // 最大数据点数量
    }
    
    // 清理图表数据
    cleanupChartData() {
        this.charts.forEach((chart, name) => {
            if (chart.data && chart.data.labels) {
                // 保留最近的数据点
                if (chart.data.labels.length > this.maxDataPoints) {
                    const excess = chart.data.labels.length - this.maxDataPoints;
                    chart.data.labels.splice(0, excess);
                    
                    chart.data.datasets.forEach(dataset => {
                        dataset.data.splice(0, excess);
                    });
                    
                    chart.update('none'); // 无动画更新
                }
            }
        });
    }
    
    // 销毁图表释放内存
    destroyChart(chartName) {
        const chart = this.charts.get(chartName);
        if (chart) {
            chart.destroy(); // Chart.js的销毁方法
            this.charts.delete(chartName);
        }
    }
}
```

### 7.4 网络连接优化


```javascript
// SSE连接优化管理器
class SSEConnectionManager {
    constructor() {
        this.eventSource = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000; // 初始重连延迟
        this.heartbeatInterval = 30000; // 心跳间隔
        this.lastHeartbeat = Date.now();
    }
    
    // 建立连接
    connect(url) {
        try {
            this.eventSource = new EventSource(url);
            this.setupEventHandlers();
            this.startHeartbeat();
            this.reconnectAttempts = 0; // 重置重连次数
        } catch (error) {
            console.error('SSE连接失败:', error);
            this.scheduleReconnect();
        }
    }
    
    // 设置事件处理器
    setupEventHandlers() {
        this.eventSource.onopen = () => {
            console.log('SSE连接已建立');
            this.reconnectDelay = 1000; // 重置延迟
        };
        
        this.eventSource.onmessage = (event) => {
            this.lastHeartbeat = Date.now();
            this.handleMessage(event);
        };
        
        this.eventSource.onerror = (error) => {
            console.error('SSE连接错误:', error);
            this.eventSource.close();
            this.scheduleReconnect();
        };
    }
    
    // 智能重连
    scheduleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('达到最大重连次数，停止重连');
            return;
        }
        
        this.reconnectAttempts++;
        
        // 指数退避算法
        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
        
        setTimeout(() => {
            console.log(`第${this.reconnectAttempts}次重连`);
            this.connect('/dashboard-stream');
        }, delay);
    }
    
    // 心跳检测
    startHeartbeat() {
        setInterval(() => {
            const now = Date.now();
            if (now - this.lastHeartbeat > this.heartbeatInterval * 2) {
                console.warn('心跳超时，重建连接');
                this.eventSource.close();
                this.scheduleReconnect();
            }
        }, this.heartbeatInterval);
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的关键概念


```
🔸 数据监控大屏：实时展示各种业务指标的可视化界面
🔸 实时数据采集：从多个数据源收集信息并统一处理
🔸 多指标推送：根据不同指标的重要性设定不同的推送频率
🔸 图表实时更新：让图表能够流畅地显示最新数据
🔸 数据缓存：保证网络问题时大屏依然能显示信息
🔸 推送频率控制：避免推送过频导致性能问题
🔸 性能优化：确保大屏长期稳定运行
```

### 8.2 技术选择指导原则


**🔹 什么时候用SSE**
```
✅ 适合场景：
- 服务器向客户端单向推送数据
- 需要实时性但不需要客户端主动发送数据
- 希望实现简单，维护成本低
- 需要自动重连功能

❌ 不适合场景：
- 需要双向实时通信（用WebSocket）
- 对实时性要求极高（毫秒级，用WebSocket）
- 数据量特别大（考虑优化或分批推送）
```

**🔹 图表库选择**
```
Chart.js：适合简单项目，学习成本低
ECharts：适合复杂项目，功能丰富
选择标准：项目复杂度、数据量大小、自定义需求
```

**🔹 缓存策略**
```
前端缓存：提高用户体验，处理网络问题
服务端缓存：减轻数据源压力
多层缓存：兼顾性能和数据一致性
```

### 8.3 实际开发注意事项


**🔧 开发建议**
```
1. 先实现基本功能，再优化性能
2. 重视异常处理，网络问题要有友好提示
3. 监控内存使用，防止长时间运行后卡顿
4. 测试不同网络环境下的表现
5. 考虑不同尺寸屏幕的适配
```

**⚠️ 常见坑点**
```
- 忘记清理事件监听器导致内存泄漏
- 图表数据点越积越多导致性能下降
- 推送频率过高导致浏览器卡顿
- 网络断开时没有友好的用户提示
- 数据源异常时大屏显示空白
```

### 8.4 项目实施路线图


**🗺️ 开发步骤**
```
第一步：搭建基础架构
- 建立SSE连接
- 创建基本的图表显示
- 实现简单的数据推送

第二步：完善数据处理
- 添加多数据源适配
- 实现数据缓存机制
- 优化推送频率控制

第三步：性能优化
- 内存管理优化
- 网络连接优化
- 图表性能调优

第四步：用户体验提升
- 异常处理完善
- 响应式布局优化
- 交互体验改进
```

**核心记忆**：
- SSE天生适合监控大屏的单向数据推送需求
- 缓存是保证用户体验的关键，要多层次设计
- 推送频率要智能控制，既保证实时性又避免卡顿
- 性能优化是长期运行的必要条件，不是可选项
- 异常处理决定了用户体验的下限，必须重视