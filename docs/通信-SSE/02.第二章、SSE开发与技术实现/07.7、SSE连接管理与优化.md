---
title: 7、SSE连接管理与优化
---
## 📚 目录

1. [SSE连接管理基础概念](#1-sse连接管理基础概念)
2. [连接池设计与原理](#2-连接池设计与原理)
3. [连接状态追踪与监控](#3-连接状态追踪与监控)
4. [连接数限制与处理](#4-连接数限制与处理)
5. [连接超时管理机制](#5-连接超时管理机制)
6. [内存泄漏防护措施](#6-内存泄漏防护措施)
7. [僵尸连接检测与清理](#7-僵尸连接检测与清理)
8. [主动断开连接策略](#8-主动断开连接策略)
9. [连接监控与告警](#9-连接监控与告警)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌐 SSE连接管理基础概念


### 1.1 什么是SSE连接管理


**🔸 简单理解**
SSE连接管理就像**管理一家餐厅的客人**：
- 餐厅有**有限的座位**（服务器有连接数限制）
- 需要**记录哪些客人在用餐**（追踪连接状态）
- **久坐不点餐的客人要处理**（清理无效连接）
- **高峰期要排队管理**（连接池设计）

```
传统HTTP请求：              SSE长连接：
客户端 → 服务器              客户端 ←→ 服务器
客户端 ← 服务器              |   保持连接    |
连接关闭                    |   持续推送    |
                           |   需要管理    |
```

### 1.2 为什么需要连接管理


**🎯 核心问题**
```
问题1：连接数爆炸
- 每个用户占用一个长连接
- 1万用户 = 1万个连接
- 服务器承受不了

问题2：内存泄漏
- 连接对象占用内存
- 客户端异常断开，服务器不知道
- 内存越占越多

问题3：资源浪费
- 僵尸连接占用资源
- 无效连接消耗CPU
- 网络带宽被占用
```

**💡 管理的价值**
- **提高性能**：合理分配资源
- **保证稳定**：防止系统崩溃
- **节约成本**：减少服务器压力

---

## 2. 🏗️ 连接池设计与原理


### 2.1 连接池是什么


**🔸 通俗理解**
连接池就像**停车场管理**：
- **有固定车位数**（最大连接数）
- **记录哪些车位被占用**（连接状态追踪）
- **车位满了要排队**（超出限制的处理）
- **定期检查僵尸车**（清理无效连接）

```
连接池结构示意：
┌─────────────────────────┐
│      SSE连接池管理       │
├─────────────────────────┤
│ 活跃连接: [用户1,用户2]  │
│ 等待队列: [用户3,用户4]  │  
│ 最大连接: 1000          │
│ 当前连接: 2             │
│ 可用连接: 998           │
└─────────────────────────┘
```

### 2.2 连接池设计原则


**🎯 核心设计思路**

**原则1: 限制总量**
```javascript
const SSE_MAX_CONNECTIONS = 1000; // 最大连接数
const connections = new Map();     // 存储所有连接

// 检查是否可以建立新连接
function canCreateConnection() {
    return connections.size < SSE_MAX_CONNECTIONS;
}
```

**原则2: 分类管理**
```javascript
const connectionManager = {
    active: new Map(),    // 活跃连接
    pending: new Set(),   // 等待连接
    closed: new Set()     // 已关闭连接
};
```

**原则3: 生命周期管理**
```javascript
class SSEConnection {
    constructor(userId, response) {
        this.userId = userId;
        this.response = response;
        this.createTime = Date.now();
        this.lastActivity = Date.now();
        this.isActive = true;
    }
}
```

### 2.3 连接池实现示例


```javascript
class SSEConnectionPool {
    constructor(maxConnections = 1000) {
        this.maxConnections = maxConnections;
        this.connections = new Map(); // userId -> connection
        this.stats = {
            total: 0,
            active: 0,
            created: 0,
            destroyed: 0
        };
    }
    
    // 创建新连接
    createConnection(userId, response) {
        // 检查连接数限制
        if (this.connections.size >= this.maxConnections) {
            throw new Error('连接数已达上限');
        }
        
        const connection = new SSEConnection(userId, response);
        this.connections.set(userId, connection);
        this.stats.active++;
        
        console.log(`用户 ${userId} 连接已建立，当前连接数: ${this.connections.size}`);
        return connection;
    }
    
    // 移除连接
    removeConnection(userId) {
        const connection = this.connections.get(userId);
        if (connection) {
            connection.isActive = false;
            this.connections.delete(userId);
            this.stats.active--;
            console.log(`用户 ${userId} 连接已移除`);
        }
    }
}
```

---

## 3. 📊 连接状态追踪与监控


### 3.1 连接状态是什么


**🔸 简单理解**
连接状态就像**追踪快递包裹**：
- **已发出**（连接建立）
- **运输中**（数据传输）
- **已签收**（客户端接收）
- **异常**（连接断开）

```
连接状态生命周期：
创建 → 活跃 → 空闲 → 断开
 ↓      ↓      ↓      ↓
建立   传输   等待   清理
```

### 3.2 状态追踪方法


**📌 核心状态信息**
```javascript
class ConnectionState {
    constructor() {
        this.status = 'CONNECTING';  // 连接状态
        this.createTime = Date.now(); // 创建时间
        this.lastActivity = Date.now(); // 最后活动时间
        this.messageCount = 0;       // 消息发送数量
        this.errorCount = 0;         // 错误次数
    }
}
```

**⚡ 状态更新机制**
```javascript
function updateConnectionState(userId, action) {
    const connection = connections.get(userId);
    if (!connection) return;
    
    connection.lastActivity = Date.now();
    
    switch(action) {
        case 'message':
            connection.messageCount++;
            connection.status = 'ACTIVE';
            break;
        case 'error':
            connection.errorCount++;
            if (connection.errorCount > 3) {
                connection.status = 'ERROR';
            }
            break;
        case 'close':
            connection.status = 'CLOSED';
            break;
    }
}
```

### 3.3 监控实现示例


```javascript
class ConnectionMonitor {
    constructor() {
        this.connections = new Map();
        this.startMonitoring();
    }
    
    // 开始监控
    startMonitoring() {
        setInterval(() => {
            this.checkConnectionHealth();
        }, 30000); // 每30秒检查一次
    }
    
    // 检查连接健康状态
    checkConnectionHealth() {
        const now = Date.now();
        const timeout = 5 * 60 * 1000; // 5分钟超时
        
        for (let [userId, connection] of this.connections) {
            const inactive = now - connection.lastActivity;
            
            if (inactive > timeout) {
                console.log(`用户 ${userId} 连接超时，准备清理`);
                this.markForCleanup(userId);
            }
        }
    }
}
```

---

## 4. 🚦 连接数限制与处理


### 4.1 为什么要限制连接数


**🎯 核心原因**
想象一个**电影院**：
- **座位有限**（服务器资源有限）
- **超卖会出事**（连接过多服务器崩溃）
- **需要排队系统**（等待机制）

```
无限制的后果：
用户数增长 → 连接数暴增 → 内存耗尽 → 服务器崩溃

有限制的好处：
超出限制 → 进入等待 → 有连接释放 → 继续处理
```

### 4.2 限制策略


**策略1: 硬限制**
```javascript
const MAX_CONNECTIONS = 1000;

function handleNewConnection(userId, response) {
    if (connections.size >= MAX_CONNECTIONS) {
        // 直接拒绝
        response.status(503).json({
            error: '服务器连接已满，请稍后重试'
        });
        return;
    }
    
    // 建立连接
    createSSEConnection(userId, response);
}
```

**策略2: 等待队列**
```javascript
class ConnectionQueue {
    constructor(maxConnections = 1000) {
        this.maxConnections = maxConnections;
        this.active = new Map();      // 活跃连接
        this.waiting = new Queue();   // 等待队列
    }
    
    addConnection(userId, response) {
        if (this.active.size < this.maxConnections) {
            // 直接建立连接
            this.createConnection(userId, response);
        } else {
            // 加入等待队列
            this.waiting.enqueue({ userId, response, timestamp: Date.now() });
            response.write('data: {"type":"waiting","message":"排队中..."}\n\n');
        }
    }
    
    // 有连接释放时，处理等待队列
    onConnectionClosed() {
        if (!this.waiting.isEmpty()) {
            const next = this.waiting.dequeue();
            this.createConnection(next.userId, next.response);
        }
    }
}
```

### 4.3 分级限制处理


**🔸 VIP用户优先**
```javascript
function getConnectionPriority(userId) {
    // 根据用户类型分配优先级
    if (isVIPUser(userId)) return 'HIGH';
    if (isPremiumUser(userId)) return 'MEDIUM';
    return 'LOW';
}

function handleConnectionByPriority(userId, response) {
    const priority = getConnectionPriority(userId);
    
    if (connections.size >= MAX_CONNECTIONS) {
        if (priority === 'HIGH') {
            // VIP用户可以挤掉低优先级连接
            kickLowPriorityConnection();
        } else {
            // 普通用户进入等待队列
            addToWaitingQueue(userId, response);
        }
    }
}
```

---

## 5. ⏰ 连接超时管理机制


### 5.1 超时管理是什么


**🔸 通俗理解**
超时管理就像**图书馆的借书制度**：
- **有借书期限**（连接有存活时间）
- **到期要提醒**（超时警告）
- **过期要收回**（强制断开连接）

```
超时类型：
┌─────────────┬─────────────┬─────────────┐
│  连接超时    │   空闲超时   │   响应超时   │
├─────────────┼─────────────┼─────────────┤
│ 总连接时间   │ 无活动时间   │ 消息响应时间 │
│ 2小时       │ 30分钟      │ 30秒        │
└─────────────┴─────────────┴─────────────┘
```

### 5.2 超时设置策略


**📝 超时配置**
```javascript
const TIMEOUT_CONFIG = {
    CONNECTION_TIMEOUT: 2 * 60 * 60 * 1000,  // 连接总时长: 2小时
    IDLE_TIMEOUT: 30 * 60 * 1000,            // 空闲超时: 30分钟
    HEARTBEAT_INTERVAL: 30 * 1000,            // 心跳间隔: 30秒
    HEARTBEAT_TIMEOUT: 60 * 1000              // 心跳超时: 60秒
};
```

**⚡ 超时检测机制**
```javascript
class TimeoutManager {
    constructor() {
        this.timers = new Map(); // 存储每个连接的定时器
        this.startTimeoutCheck();
    }
    
    // 设置连接超时
    setConnectionTimeout(userId) {
        const timer = setTimeout(() => {
            console.log(`用户 ${userId} 连接超时`);
            this.handleTimeout(userId, 'CONNECTION_TIMEOUT');
        }, TIMEOUT_CONFIG.CONNECTION_TIMEOUT);
        
        this.timers.set(userId, timer);
    }
    
    // 重置空闲超时
    resetIdleTimeout(userId) {
        const existingTimer = this.timers.get(`idle_${userId}`);
        if (existingTimer) {
            clearTimeout(existingTimer);
        }
        
        const timer = setTimeout(() => {
            console.log(`用户 ${userId} 空闲超时`);
            this.handleTimeout(userId, 'IDLE_TIMEOUT');
        }, TIMEOUT_CONFIG.IDLE_TIMEOUT);
        
        this.timers.set(`idle_${userId}`, timer);
    }
    
    // 处理超时
    handleTimeout(userId, type) {
        const connection = connections.get(userId);
        if (connection) {
            console.log(`连接超时: ${userId}, 类型: ${type}`);
            this.closeConnection(userId);
        }
    }
}
```

### 5.3 心跳机制


**💗 心跳保活**
```javascript
class HeartbeatManager {
    constructor() {
        this.heartbeats = new Map(); // 记录每个连接的心跳状态
        this.startHeartbeat();
    }
    
    // 启动心跳检测
    startHeartbeat() {
        setInterval(() => {
            this.sendHeartbeat();
        }, TIMEOUT_CONFIG.HEARTBEAT_INTERVAL);
        
        setInterval(() => {
            this.checkHeartbeatResponse();
        }, TIMEOUT_CONFIG.HEARTBEAT_TIMEOUT);
    }
    
    // 发送心跳
    sendHeartbeat() {
        for (let [userId, connection] of connections) {
            if (connection.isActive) {
                // 发送心跳消息
                connection.response.write('data: {"type":"heartbeat","timestamp":' + Date.now() + '}\n\n');
                
                // 标记等待心跳响应
                this.heartbeats.set(userId, {
                    sent: Date.now(),
                    responded: false
                });
            }
        }
    }
    
    // 处理心跳响应
    onHeartbeatResponse(userId) {
        const heartbeat = this.heartbeats.get(userId);
        if (heartbeat) {
            heartbeat.responded = true;
            heartbeat.responseTime = Date.now();
        }
    }
}
```

---

## 6. 🛡️ 内存泄漏防护措施


### 6.1 内存泄漏是什么


**🔸 通俗理解**
内存泄漏就像**水龙头没关紧**：
- **水一直流**（内存不断占用）
- **水缸会溢出**（内存耗尽）
- **需要及时关闭**（清理无用对象）

```
内存泄漏的常见原因：
1. 连接对象没有及时清理
2. 事件监听器没有移除
3. 定时器没有清除
4. 循环引用导致无法回收
```

### 6.2 防护策略


**策略1: 及时清理连接对象**
```javascript
class SSEConnection {
    constructor(userId, response) {
        this.userId = userId;
        this.response = response;
        this.timers = new Set();    // 记录所有定时器
        this.listeners = new Set(); // 记录所有监听器
    }
    
    // 添加定时器（自动记录）
    addTimer(timer) {
        this.timers.add(timer);
        return timer;
    }
    
    // 清理所有资源
    cleanup() {
        // 清理定时器
        for (let timer of this.timers) {
            clearTimeout(timer);
            clearInterval(timer);
        }
        this.timers.clear();
        
        // 移除事件监听器
        for (let listener of this.listeners) {
            listener.remove();
        }
        this.listeners.clear();
        
        // 关闭响应流
        if (!this.response.finished) {
            this.response.end();
        }
        
        // 清空引用
        this.response = null;
        this.userId = null;
    }
}
```

**策略2: 定期内存检查**
```javascript
class MemoryMonitor {
    constructor() {
        this.startMemoryMonitoring();
    }
    
    startMemoryMonitoring() {
        setInterval(() => {
            const memUsage = process.memoryUsage();
            const memUsageMB = {
                rss: Math.round(memUsage.rss / 1024 / 1024),
                heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
                heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024)
            };
            
            console.log('内存使用情况:', memUsageMB);
            
            // 内存使用超过阈值时告警
            if (memUsageMB.heapUsed > 500) { // 500MB
                console.warn('内存使用量过高，开始清理');
                this.forceCleanup();
            }
        }, 60000); // 每分钟检查一次
    }
    
    forceCleanup() {
        // 强制垃圾回收（需要启动参数 --expose-gc）
        if (global.gc) {
            global.gc();
        }
        
        // 清理长时间无活动的连接
        this.cleanupInactiveConnections();
    }
}
```

### 6.3 最佳实践


**💡 防护要点**
```javascript
// 1. 使用弱引用避免循环引用
const connectionRefs = new WeakMap();

// 2. 设置对象为null释放引用
connection.cleanup = function() {
    this.response = null;
    this.data = null;
    this.timers = null;
};

// 3. 监控内存使用趋势
function checkMemoryTrend() {
    const usage = process.memoryUsage();
    if (usage.heapUsed > lastUsage * 1.5) {
        console.warn('内存使用量异常增长');
    }
    lastUsage = usage.heapUsed;
}
```

---

## 7. 🧹 僵尸连接检测与清理


### 7.1 什么是僵尸连接


**🔸 通俗理解**
僵尸连接就像**餐厅里的空桌子**：
- **客人已经走了**（客户端断开）
- **但桌子还被占着**（服务器不知道）
- **影响其他客人用餐**（占用服务器资源）

```
僵尸连接的产生：
客户端异常断开 → 服务器未感知 → 连接对象残留 → 资源浪费

正常流程：
客户端断开 → 发送断开信号 → 服务器清理 → 释放资源
```

### 7.2 僵尸连接检测


**🔍 检测方法**
```javascript
class ZombieDetector {
    constructor() {
        this.suspiciousConnections = new Set();
        this.startDetection();
    }
    
    startDetection() {
        setInterval(() => {
            this.detectZombieConnections();
        }, 60000); // 每分钟检测一次
    }
    
    detectZombieConnections() {
        const now = Date.now();
        const zombieThreshold = 10 * 60 * 1000; // 10分钟无响应
        
        for (let [userId, connection] of connections) {
            const inactiveTime = now - connection.lastActivity;
            
            if (inactiveTime > zombieThreshold) {
                // 怀疑是僵尸连接，进行探测
                this.probeConnection(userId, connection);
            }
        }
    }
    
    // 探测连接是否还活着
    probeConnection(userId, connection) {
        try {
            // 发送探测消息
            connection.response.write('data: {"type":"probe","timestamp":' + Date.now() + '}\n\n');
            
            // 标记为可疑连接
            this.suspiciousConnections.add(userId);
            
            // 30秒后检查是否有响应
            setTimeout(() => {
                this.checkProbeResponse(userId);
            }, 30000);
            
        } catch (error) {
            // 写入失败，确定是僵尸连接
            console.log(`发现僵尸连接: ${userId}`);
            this.markAsZombie(userId);
        }
    }
    
    checkProbeResponse(userId) {
        if (this.suspiciousConnections.has(userId)) {
            // 没有响应，确定是僵尸连接
            console.log(`确认僵尸连接: ${userId}`);
            this.markAsZombie(userId);
        }
    }
    
    markAsZombie(userId) {
        this.suspiciousConnections.delete(userId);
        this.cleanupZombieConnection(userId);
    }
}
```

### 7.3 清理机制


**🧹 自动清理**
```javascript
class ConnectionCleaner {
    constructor() {
        this.cleanupQueue = [];
        this.startCleanup();
    }
    
    startCleanup() {
        setInterval(() => {
            this.processCleanupQueue();
        }, 30000); // 每30秒处理一次清理队列
    }
    
    // 添加到清理队列
    scheduleCleanup(userId, reason) {
        this.cleanupQueue.push({
            userId,
            reason,
            timestamp: Date.now()
        });
    }
    
    // 处理清理队列
    processCleanupQueue() {
        while (this.cleanupQueue.length > 0) {
            const item = this.cleanupQueue.shift();
            this.cleanupConnection(item.userId, item.reason);
        }
    }
    
    // 清理连接
    cleanupConnection(userId, reason) {
        const connection = connections.get(userId);
        if (!connection) return;
        
        console.log(`清理连接: ${userId}, 原因: ${reason}`);
        
        try {
            // 发送关闭消息
            connection.response.write('data: {"type":"close","reason":"' + reason + '"}\n\n');
            connection.response.end();
        } catch (error) {
            // 忽略写入错误
        }
        
        // 清理资源
        connection.cleanup();
        connections.delete(userId);
        
        // 更新统计
        connectionStats.active--;
        connectionStats.cleaned++;
    }
}
```

---

## 8. 🔌 主动断开连接策略


### 8.1 何时需要主动断开


**🎯 断开场景**
```
1. 用户注销登录 → 主动断开
2. 权限变更 → 重新验证
3. 服务维护 → 优雅关闭
4. 资源不足 → 选择性断开
5. 异常情况 → 强制断开
```

### 8.2 断开策略


**策略1: 优雅断开**
```javascript
class GracefulDisconnection {
    // 优雅断开连接
    gracefulDisconnect(userId, reason, delayMs = 5000) {
        const connection = connections.get(userId);
        if (!connection) return;
        
        // 发送断开通知
        const message = {
            type: 'disconnect_notice',
            reason: reason,
            delay: delayMs,
            timestamp: Date.now()
        };
        
        connection.response.write('data: ' + JSON.stringify(message) + '\n\n');
        
        // 延迟断开，给客户端处理时间
        setTimeout(() => {
            this.forceDisconnect(userId);
        }, delayMs);
    }
    
    // 强制断开连接
    forceDisconnect(userId) {
        const connection = connections.get(userId);
        if (connection) {
            connection.cleanup();
            connections.delete(userId);
            console.log(`强制断开连接: ${userId}`);
        }
    }
}
```

**策略2: 批量断开**
```javascript
// 服务器维护时批量断开
function batchDisconnect(reason = '服务器维护') {
    console.log(`开始批量断开连接，原因: ${reason}`);
    
    const disconnectPromises = [];
    
    for (let [userId, connection] of connections) {
        const promise = new Promise((resolve) => {
            // 发送维护通知
            const message = {
                type: 'maintenance',
                reason: reason,
                timestamp: Date.now()
            };
            
            try {
                connection.response.write('data: ' + JSON.stringify(message) + '\n\n');
                connection.response.end();
            } catch (error) {
                // 忽略写入错误
            }
            
            connection.cleanup();
            resolve();
        });
        
        disconnectPromises.push(promise);
    }
    
    // 等待所有连接断开
    Promise.all(disconnectPromises).then(() => {
        connections.clear();
        console.log('所有连接已断开');
    });
}
```

---

## 9. 📊 连接监控与告警


### 9.1 监控指标


**📈 关键指标**
```javascript
class ConnectionMetrics {
    constructor() {
        this.metrics = {
            totalConnections: 0,      // 总连接数
            activeConnections: 0,     // 活跃连接数
            peakConnections: 0,       // 峰值连接数
            avgConnectionDuration: 0, // 平均连接时长
            messagesSent: 0,          // 发送消息数
            errorsCount: 0,           // 错误次数
            reconnections: 0          // 重连次数
        };
        
        this.startMetricsCollection();
    }
    
    // 收集指标
    collectMetrics() {
        this.metrics.activeConnections = connections.size;
        this.metrics.peakConnections = Math.max(
            this.metrics.peakConnections, 
            connections.size
        );
        
        // 计算平均连接时长
        let totalDuration = 0;
        const now = Date.now();
        
        for (let connection of connections.values()) {
            totalDuration += now - connection.createTime;
        }
        
        if (connections.size > 0) {
            this.metrics.avgConnectionDuration = totalDuration / connections.size;
        }
    }
}
```

### 9.2 告警机制


**🚨 告警规则**
```javascript
class ConnectionAlerts {
    constructor() {
        this.alertRules = {
            maxConnections: 800,      // 连接数告警阈值
            memoryUsage: 512,         // 内存使用告警(MB)
            errorRate: 0.05,          // 错误率告警(5%)
            avgResponseTime: 1000     // 响应时间告警(ms)
        };
        
        this.startAlerting();
    }
    
    checkAlerts() {
        const metrics = connectionMetrics.getMetrics();
        
        // 连接数告警
        if (metrics.activeConnections > this.alertRules.maxConnections) {
            this.sendAlert('CONNECTION_LIMIT', {
                current: metrics.activeConnections,
                limit: this.alertRules.maxConnections
            });
        }
        
        // 内存使用告警
        const memUsage = process.memoryUsage().heapUsed / 1024 / 1024;
        if (memUsage > this.alertRules.memoryUsage) {
            this.sendAlert('MEMORY_HIGH', {
                current: memUsage,
                limit: this.alertRules.memoryUsage
            });
        }
        
        // 错误率告警
        const errorRate = metrics.errorsCount / metrics.totalConnections;
        if (errorRate > this.alertRules.errorRate) {
            this.sendAlert('ERROR_RATE_HIGH', {
                current: errorRate,
                limit: this.alertRules.errorRate
            });
        }
    }
    
    sendAlert(type, data) {
        console.error(`🚨 告警: ${type}`, data);
        // 这里可以接入邮件、短信、钉钉等告警系统
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 连接池管理：限制最大连接数，合理分配资源
🔸 状态追踪：实时监控连接状态，及时发现问题  
🔸 超时处理：设置合理超时时间，自动清理过期连接
🔸 内存防护：及时清理对象引用，防止内存泄漏
🔸 僵尸检测：主动探测失效连接，保持系统健康
🔸 优雅断开：给客户端处理时间，避免数据丢失
```

### 10.2 关键理解要点


**🔹 连接管理的本质**
- **资源有限**：服务器承载能力有上限
- **状态维护**：需要跟踪每个连接的生命周期  
- **主动清理**：不能被动等待，要主动维护

**🔹 性能优化策略**
- **分级处理**：VIP用户优先，普通用户排队
- **批量操作**：定期批量清理，提高效率
- **预警机制**：提前发现问题，避免系统崩溃

**🔹 实践要点**
```
设计原则：
✅ 防御式编程：假设一切都会出错
✅ 优雅降级：资源不足时有备选方案
✅ 监控告警：问题要能及时发现
✅ 自动恢复：尽量减少人工干预
```

### 10.3 实际应用场景


**📱 直播弹幕系统**
- 万人同时在线，需要连接池管理
- 用户频繁进出，需要快速清理连接
- VIP用户优先，普通用户可以排队

**📢 消息推送平台** 
- 大量长连接，内存管理很关键
- 用户可能随时断网，僵尸连接检测必须
- 推送消息要及时，连接状态监控重要

**🎮 实时游戏**
- 延迟敏感，超时设置要精确
- 掉线重连频繁，连接状态追踪复杂
- 作弊检测需要主动断开机制

**核心记忆**：
- SSE连接管理就像管理餐厅客人
- 有限资源需要合理分配和监控  
- 及时清理无效连接保持系统健康
- 监控告警机制确保服务稳定可靠