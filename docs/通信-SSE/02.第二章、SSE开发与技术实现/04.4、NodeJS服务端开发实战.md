---
title: 4、NodeJS服务端开发实战
---
## 📚 目录

1. [SSE服务端开发概述](#1-SSE服务端开发概述)
2. [响应头设置详解](#2-响应头设置详解)
3. [数据发送格式要求](#3-数据发送格式要求)
4. [Node.js原生实现](#4-Node.js原生实现)
5. [Express框架集成](#5-Express框架集成)
6. [实战案例与应用](#6-实战案例与应用)
7. [连接管理与优化](#7-连接管理与优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 SSE服务端开发概述


### 1.1 什么是SSE服务端


**通俗理解**：
SSE服务端就像一个"广播电台"，它不断地向连接的客户端（浏览器）推送消息，而客户端就像收音机一样接收这些消息。

```
传统请求模式：
客户端 ──请求──> 服务端
客户端 <──响应── 服务端

SSE推送模式：
客户端 ──连接──> 服务端
客户端 <──消息1── 服务端
客户端 <──消息2── 服务端
客户端 <──消息3── 服务端
```

### 1.2 SSE服务端的核心任务


> 💡 **核心职责**：SSE服务端主要做三件事
> - **建立长连接**：让客户端能够持续连接不断开
> - **推送消息**：按照特定格式发送数据给客户端
> - **管理连接**：处理客户端的连接和断开

### 1.3 为什么选择Node.js


**Node.js的优势**：
- ✅ **单线程非阻塞**：天然适合处理大量长连接
- ✅ **内置HTTP模块**：无需复杂配置就能搭建SSE服务
- ✅ **轻量高效**：比传统服务器更省资源

---

## 2. 🔧 响应头设置详解


### 2.1 必需的响应头


**核心三要素**：
```javascript
// 这三个响应头是SSE的"身份证"
'Content-Type': 'text/event-stream'     // 告诉浏览器这是事件流
'Cache-Control': 'no-cache'             // 不要缓存数据
'Connection': 'keep-alive'              // 保持连接不断开
```

### 2.2 每个响应头的含义


**Content-Type: text/event-stream**
> 💡 **含义**：这就像给数据包贴上"实时消息"的标签，告诉浏览器用SSE方式处理这些数据

**Cache-Control: no-cache**  
> 💡 **含义**：告诉浏览器"这些消息都是最新的，不要缓存旧消息"，确保每次都能收到最新数据

**Connection: keep-alive**
> 💡 **含义**：告诉浏览器"这个连接要一直保持，不要关闭"，这样才能持续接收消息

### 2.3 可选的响应头


```javascript
// 解决跨域问题（如果需要）
'Access-Control-Allow-Origin': '*'              // 允许所有域名访问
'Access-Control-Allow-Headers': 'Cache-Control' // 允许的请求头
```

---

## 3. 📝 数据发送格式要求


### 3.1 SSE数据格式规则


**基本格式**：
```
data: 你的消息内容\n\n
```

> ⚠️ **重要**：每条消息**必须**以`\n\n`（两个换行符）结尾，这是SSE协议的硬性规定

### 3.2 为什么必须是\n\n结尾


**通俗解释**：
- `\n\n` 就像句号，告诉浏览器"这条消息说完了"
- 如果没有`\n\n`，浏览器会一直等待，认为消息还没说完
- 这是SSE协议的"语法规则"，不遵守就收不到消息

### 3.3 消息格式示例


```javascript
// ✅ 正确格式
'data: Hello World\n\n'                    // 简单文本
'data: {"name":"张三","age":25}\n\n'       // JSON数据
'data: 当前时间: 2024-08-07 10:30:00\n\n' // 带时间信息

// ❌ 错误格式
'data: Hello World\n'     // 只有一个\n，浏览器收不到
'Hello World\n\n'         // 缺少data:前缀，浏览器忽略
```

### 3.4 res.write()的具体意义


**res.write()是什么**：
> 💡 **简单理解**：`res.write()`就像用水管往外送水，可以一次次地发送数据，而不是一次性发完

```javascript
// 传统的一次性响应
res.send('Hello')  // 发送完就关闭连接

// SSE的持续响应  
res.write('data: 消息1\n\n')  // 发送第一条消息，连接保持
res.write('data: 消息2\n\n')  // 发送第二条消息，连接保持
res.write('data: 消息3\n\n')  // 发送第三条消息，连接保持
```

---

## 4. ⚡ Node.js原生实现


### 4.1 原生HTTP模块实现SSE


```javascript
const http = require('http');

// 创建HTTP服务器
const server = http.createServer((req, res) => {
    // 只处理SSE请求
    if (req.url === '/events') {
        
        // 步骤1: 设置SSE响应头
        res.writeHead(200, {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*'
        });

        // 步骤2: 立即发送响应头
        res.flushHeaders();

        // 步骤3: 发送欢迎消息
        res.write('data: 连接成功\n\n');

        // 步骤4: 每2秒发送一条消息
        const timer = setInterval(() => {
            const now = new Date().toLocaleTimeString();
            res.write(`data: 当前时间: ${now}\n\n`);
        }, 2000);

        // 步骤5: 处理客户端断开
        req.on('close', () => {
            clearInterval(timer);
            console.log('客户端断开连接');
        });
    }
});

server.listen(3000, () => {
    console.log('SSE服务器启动在端口3000');
});
```

### 4.2 核心步骤解释


**res.flushHeaders()的作用**：
> 💡 **含义**：立即发送响应头给客户端，让浏览器知道这是SSE连接，不要等待完整响应

**定时器的应用**：
```javascript
// 每隔一定时间推送消息
setInterval(() => {
    // 推送逻辑
}, 间隔时间);
```

**连接断开处理**：
```javascript
// 监听客户端断开事件
req.on('close', () => {
    // 清理资源，避免内存泄漏
    clearInterval(timer);
});
```

---

## 5. 🚀 Express框架集成


### 5.1 Express基础集成


```javascript
const express = require('express');
const app = express();

// SSE路由
app.get('/events', (req, res) => {
    // 设置SSE响应头
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');

    // 发送初始消息
    res.write('data: Express SSE连接成功\n\n');

    // 定时推送
    const interval = setInterval(() => {
        const data = {
            message: '来自Express的消息',
            timestamp: Date.now()
        };
        res.write(`data: ${JSON.stringify(data)}\n\n`);
    }, 3000);

    // 清理资源
    req.on('close', () => {
        clearInterval(interval);
    });
});

app.listen(3000);
```

### 5.2 数据序列化与发送机制


**JSON数据处理**：
```javascript
// 发送复杂数据的标准做法
function sendSSEData(res, data) {
    // 步骤1: 将数据转换为JSON字符串
    const jsonString = JSON.stringify(data);
    
    // 步骤2: 按SSE格式发送
    res.write(`data: ${jsonString}\n\n`);
}

// 使用示例
const userData = {
    id: 1,
    name: '张三',
    status: '在线'
};
sendSSEData(res, userData);
```

### 5.3 Express中间件封装


```javascript
// 封装SSE中间件
function setupSSE(req, res, next) {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');
    
    // 添加便捷方法
    res.sendSSE = function(data) {
        this.write(`data: ${JSON.stringify(data)}\n\n`);
    };
    
    next();
}

// 使用中间件
app.get('/events', setupSSE, (req, res) => {
    res.sendSSE({ message: '连接成功' });
    
    setInterval(() => {
        res.sendSSE({ 
            message: '定时消息',
            time: new Date().toISOString()
        });
    }, 2000);
});
```

---

## 6. 💡 实战案例与应用


### 6.1 延迟推送模拟实战


```javascript
// 模拟订单处理进度推送
app.get('/order-progress/:orderId', (req, res) => {
    const orderId = req.params.orderId;
    
    // 设置SSE头
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // 模拟处理步骤
    const steps = [
        { step: 1, message: '订单确认中...', progress: 20 },
        { step: 2, message: '商品出库中...', progress: 40 },
        { step: 3, message: '物流配送中...', progress: 70 },
        { step: 4, message: '订单完成', progress: 100 }
    ];

    let currentStep = 0;

    // 立即发送开始消息
    res.write(`data: ${JSON.stringify({
        orderId: orderId,
        message: '开始处理订单',
        progress: 0
    })}\n\n`);

    // 模拟延迟推送
    const processOrder = () => {
        if (currentStep < steps.length) {
            const stepData = {
                orderId: orderId,
                ...steps[currentStep]
            };
            
            res.write(`data: ${JSON.stringify(stepData)}\n\n`);
            currentStep++;
            
            // 每步间隔2-5秒（模拟真实处理时间）
            const delay = Math.random() * 3000 + 2000;
            setTimeout(processOrder, delay);
        } else {
            // 处理完成，关闭连接
            res.end();
        }
    };

    // 开始处理
    setTimeout(processOrder, 1000);
    
    // 处理客户端断开
    req.on('close', () => {
        console.log(`订单${orderId}的SSE连接断开`);
    });
});
```

### 6.2 简单服务端推送计时器


```javascript
// 全局计时器推送
app.get('/timer', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    let seconds = 0;
    
    // 每秒推送一次
    const timer = setInterval(() => {
        seconds++;
        res.write(`data: ${JSON.stringify({
            type: 'timer',
            seconds: seconds,
            message: `已运行${seconds}秒`
        })}\n\n`);
    }, 1000);

    // 连接断开时清理
    req.on('close', () => {
        clearInterval(timer);
        console.log('计时器SSE连接断开');
    });
});
```

---

## 7. 🔗 连接管理与优化


### 7.1 客户端连接池管理


```javascript
// 连接池管理
class SSEConnectionManager {
    constructor() {
        this.connections = new Map(); // 存储所有连接
    }

    // 添加连接
    addConnection(id, res) {
        this.connections.set(id, {
            response: res,
            connectedAt: Date.now()
        });
        console.log(`连接${id}已建立，当前连接数：${this.connections.size}`);
    }

    // 移除连接
    removeConnection(id) {
        if (this.connections.has(id)) {
            this.connections.delete(id);
            console.log(`连接${id}已断开，当前连接数：${this.connections.size}`);
        }
    }

    // 广播消息给所有连接
    broadcast(data) {
        const message = `data: ${JSON.stringify(data)}\n\n`;
        
        this.connections.forEach((conn, id) => {
            try {
                conn.response.write(message);
            } catch (error) {
                console.log(`向连接${id}发送消息失败，移除连接`);
                this.removeConnection(id);
            }
        });
    }

    // 获取连接状态
    getStatus() {
        return {
            totalConnections: this.connections.size,
            connections: Array.from(this.connections.keys())
        };
    }
}

// 使用连接管理器
const manager = new SSEConnectionManager();

app.get('/events', (req, res) => {
    const connectionId = Date.now() + Math.random(); // 生成唯一ID
    
    // 设置响应头
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // 添加到连接池
    manager.addConnection(connectionId, res);

    // 发送欢迎消息
    res.write(`data: ${JSON.stringify({
        type: 'welcome',
        connectionId: connectionId,
        message: '连接成功'
    })}\n\n`);

    // 处理断开连接
    req.on('close', () => {
        manager.removeConnection(connectionId);
    });
});

// 广播接口
app.post('/broadcast', express.json(), (req, res) => {
    const { message } = req.body;
    manager.broadcast({
        type: 'broadcast',
        message: message,
        timestamp: Date.now()
    });
    
    res.json({ 
        success: true, 
        sentTo: manager.getStatus().totalConnections 
    });
});
```

### 7.2 路由设计模式与最佳实践


```javascript
// 按功能模块组织SSE路由
const sseRouter = express.Router();

// 通用SSE设置中间件
sseRouter.use((req, res, next) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');
    
    // 添加便捷发送方法
    res.sendEvent = function(eventType, data) {
        this.write(`event: ${eventType}\ndata: ${JSON.stringify(data)}\n\n`);
    };
    
    next();
});

// 系统状态推送
sseRouter.get('/system-status', (req, res) => {
    const sendStatus = () => {
        res.sendEvent('status', {
            cpu: Math.random() * 100,
            memory: Math.random() * 100,
            timestamp: Date.now()
        });
    };
    
    const interval = setInterval(sendStatus, 5000);
    req.on('close', () => clearInterval(interval));
});

// 用户活动推送
sseRouter.get('/user-activity', (req, res) => {
    // 模拟用户活动
    const activities = ['登录', '浏览', '购买', '评论', '分享'];
    
    const sendActivity = () => {
        const activity = activities[Math.floor(Math.random() * activities.length)];
        res.sendEvent('user-activity', {
            user: `用户${Math.floor(Math.random() * 1000)}`,
            activity: activity,
            timestamp: Date.now()
        });
    };
    
    const interval = setInterval(sendActivity, 3000);
    req.on('close', () => clearInterval(interval));
});

// 挂载SSE路由
app.use('/sse', sseRouter);
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 响应头设置：Content-Type、Cache-Control、Connection三要素
🔸 数据格式：data: 内容\n\n 的固定格式
🔸 res.write()：持续发送数据的关键方法
🔸 连接管理：监听close事件，及时清理资源
🔸 定时推送：使用setInterval实现周期性消息发送
```

### 8.2 关键理解要点


**🔹 SSE的本质**
> SSE就是服务器保持一个HTTP连接不关闭，然后不断地往这个连接里写数据

**🔹 为什么要用\n\n**
> 这是SSE协议的"标点符号"，告诉浏览器一条消息结束了，可以触发事件了

**🔹 res.write()vs res.send()**
```
res.send()：一次性发送完就关闭连接
res.write()：可以多次发送，保持连接开启
```

### 8.3 开发最佳实践


**✅ 必做事项**：
- 总是设置正确的SSE响应头
- 每条消息都要以`\n\n`结尾
- 监听客户端断开事件，清理定时器
- 使用连接池管理大量连接

**❌ 避免错误**：
- 不要忘记设置`Content-Type: text/event-stream`
- 不要在消息末尾省略`\n\n`
- 不要忘记清理定时器，避免内存泄漏
- 不要在生产环境中无限制地创建连接

### 8.4 性能优化建议


> 💡 **优化要点**：
> - **连接数限制**：避免单个服务器承载过多SSE连接
> - **消息频率控制**：根据实际需求调整推送频率
> - **数据压缩**：大量数据可以考虑压缩后发送
> - **错误处理**：完善的异常捕获和连接恢复机制

**核心记忆**：
- SSE服务端 = HTTP长连接 + 特定格式推送
- 三个响应头 + data: 内容\n\n = 完整SSE实现
- res.write()持续推送，req.on('close')清理资源
- Express中间件封装，连接池统一管理