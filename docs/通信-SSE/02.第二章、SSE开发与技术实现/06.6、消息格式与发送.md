---
title: 6、消息格式与发送
---
## 📚 目录

1. [简单消息：data字段的具体使用](#1-简单消息data字段的具体使用)
2. [多行消息处理机制](#2-多行消息处理机制)
3. [自定义事件类型：event字段详解](#3-自定义事件类型event字段详解)
4. [消息ID：id字段用途与实现](#4-消息IDid字段用途与实现)
5. [重连间隔：retry字段配置](#5-重连间隔retry字段配置)
6. [心跳消息机制设计](#6-心跳消息机制设计)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📝 简单消息：data字段的具体使用


### 1.1 什么是SSE的简单消息


**通俗理解**：就像发短信一样，`data`字段就是消息的"内容部分"，是你真正想发给前端的数据。

```
想象一下发短信：
📱 短信内容：今天天气不错
💻 SSE消息：data: 今天天气不错

短信有内容，SSE消息也有内容，data就是内容载体
```

### 1.2 data字段的基本格式


**🔸 标准格式**
```
data: 你要发送的内容\n\n
```

**重要理解**：
- `data:` 是固定开头，告诉浏览器"这是消息内容"
- 冒号后面跟一个空格（可选但建议加上）
- 内容可以是文本、JSON、数字等
- `\n\n` 是两个换行符，表示"这条消息发送完了"

### 1.3 实际使用示例


**🔧 服务端发送简单消息**
```javascript
// Node.js 服务端代码
app.get('/events', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  
  // 发送简单文本消息
  res.write('data: Hello World\n\n');
  
  // 发送数字消息
  res.write('data: 123\n\n');
  
  // 发送JSON消息（最常用）
  res.write('data: {"message": "用户登录", "time": "14:30"}\n\n');
});
```

**💻 前端接收消息**
```javascript
const eventSource = new EventSource('/events');

eventSource.onmessage = function(event) {
  console.log('收到消息：', event.data);
  // 输出：Hello World
  // 输出：123  
  // 输出：{"message": "用户登录", "time": "14:30"}
};
```

### 1.4 data字段的实际应用场景


**📊 常见使用场景**
```
💬 聊天消息：data: {"user": "张三", "msg": "大家好"}
📈 股票价格：data: {"stock": "AAPL", "price": 150.25}
⚠️ 系统通知：data: {"type": "warning", "text": "系统将在5分钟后维护"}
📊 实时数据：data: {"cpu": 65, "memory": 78, "disk": 45}
```

---

## 2. 📄 多行消息处理机制


### 2.1 为什么需要多行消息


**实际问题**：有时候你要发送的内容很长，或者包含换行符，一行写不下怎么办？

```
比如要发送这样的内容：
用户评论：
这是第一行内容
这是第二行内容
总共三行

如果强行写在一行里会很乱很长
```

### 2.2 多行消息的写法


**🔸 多个data字段拼接**
```javascript
// 服务端发送多行消息
res.write('data: 用户评论：\n');
res.write('data: 这是第一行内容\n');  
res.write('data: 这是第二行内容\n');
res.write('data: 总共三行\n');
res.write('\n');  // 最后的空行表示消息结束
```

**🔸 前端接收的结果**
```javascript
eventSource.onmessage = function(event) {
  console.log(event.data);
  // 输出：
  // 用户评论：
  // 这是第一行内容  
  // 这是第二行内容
  // 总共三行
};
```

### 2.3 多行消息的处理规律


**📋 处理规则**
```
规则很简单：
1. 每个 data: 后面的内容算一行
2. 多个连续的 data: 会自动用换行符连接  
3. 遇到空行（\n\n）时，把前面的内容合并发送给前端
```

**💡 实际示例对比**
```javascript
// 方式1：单行发送
res.write('data: {"name":"张三","age":25,"city":"北京"}\n\n');

// 方式2：多行发送（结果一样）
res.write('data: {\n');
res.write('data:   "name": "张三",\n');
res.write('data:   "age": 25,\n'); 
res.write('data:   "city": "北京"\n');
res.write('data: }\n');
res.write('\n');
```

### 2.4 多行消息的实际用途


**📝 典型应用场景**
- **📄 长文本内容**：文章、评论、日志信息
- **🔧 代码片段**：发送格式化的代码内容
- **📊 结构化数据**：美化的JSON格式
- **📋 列表数据**：逐行发送列表项

---

## 3. 🎯 自定义事件类型：event字段详解


### 3.1 什么是事件类型


**通俗理解**：就像给消息贴标签一样，告诉前端"这是什么类型的消息"

```
生活中的例子：
📧 邮件有不同类型：工作邮件、垃圾邮件、重要邮件
💻 SSE消息也有类型：用户消息、系统通知、错误提醒

event字段就是用来标记消息类型的
```

### 3.2 event字段的基本用法


**🔸 标准格式**
```
event: 事件类型名称\n
data: 消息内容\n\n
```

**关键理解**：
- `event:` 在 `data:` 前面，先告诉类型，再发内容
- 事件类型名称是你自己定义的，可以是任何字符串
- 如果不写event字段，默认类型是 `message`

### 3.3 服务端发送不同类型的事件


**🔧 服务端代码示例**
```javascript
app.get('/events', (req, res) => {
  // 设置SSE响应头
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache'
  });
  
  // 发送用户消息事件
  res.write('event: userMessage\n');
  res.write('data: {"user": "张三", "text": "大家好"}\n\n');
  
  // 发送系统通知事件
  res.write('event: systemNotice\n');
  res.write('data: {"msg": "系统将在10分钟后重启"}\n\n');
  
  // 发送错误事件
  res.write('event: error\n');
  res.write('data: {"code": 500, "msg": "服务器内部错误"}\n\n');
  
  // 默认消息事件（不写event字段）
  res.write('data: 这是默认类型的消息\n\n');
});
```

### 3.4 前端监听不同类型的事件


**💻 前端监听代码**
```javascript
const eventSource = new EventSource('/events');

// 监听用户消息事件
eventSource.addEventListener('userMessage', function(event) {
  const data = JSON.parse(event.data);
  console.log('收到用户消息：', data.user, data.text);
  // 可以更新聊天界面
});

// 监听系统通知事件
eventSource.addEventListener('systemNotice', function(event) {
  const data = JSON.parse(event.data);
  console.log('系统通知：', data.msg);
  // 可以显示顶部通知条
});

// 监听错误事件
eventSource.addEventListener('error', function(event) {
  const data = JSON.parse(event.data);
  console.log('发生错误：', data.code, data.msg);
  // 可以显示错误提示
});

// 监听默认消息（onmessage）
eventSource.onmessage = function(event) {
  console.log('默认消息：', event.data);
};
```

### 3.5 事件类型的实际应用


**🎯 实际业务场景**
```javascript
// 电商网站的不同事件类型
event: newOrder        // 新订单通知
event: stockWarning    // 库存警告
event: userOnline      // 用户上线
event: paymentSuccess  // 支付成功
event: systemMaintain  // 系统维护

// 社交应用的事件类型  
event: newComment      // 新评论
event: newLike         // 新点赞
event: newFollower     // 新关注者
event: privateMessage  // 私信
```

---

## 4. 🆔 消息ID：id字段用途与实现


### 4.1 消息ID是做什么的


**通俗理解**：每条消息都有一个身份证号，断线重连时浏览器可以告诉服务器"我最后收到的是第几条消息，从那里开始补发"

```
生活场景类比：
📺 看电视剧时停电了，恢复后你想从断点继续看
📱 聊天时网络断了，重连后你想看到断线期间的消息

id字段就是为了解决这种"断点续传"的问题
```

### 4.2 id字段的基本格式


**🔸 标准格式**
```
id: 消息的唯一标识\n
event: 事件类型\n  
data: 消息内容\n\n
```

**重要理解**：
- `id:` 后面跟的是这条消息的唯一标识
- 通常用数字、时间戳、UUID等作为ID
- ID要保证唯一性和递增性

### 4.3 服务端实现消息ID


**🔧 简单递增ID示例**
```javascript
let messageId = 0;  // 消息计数器

app.get('/events', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache'
  });
  
  // 定时发送带ID的消息
  const timer = setInterval(() => {
    messageId++;
    
    res.write(`id: ${messageId}\n`);
    res.write('event: update\n');
    res.write(`data: {"msg": "第${messageId}条消息", "time": "${new Date()}"}\n\n`);
  }, 2000);
  
  // 客户端断开时清理定时器
  req.on('close', () => {
    clearInterval(timer);
  });
});
```

### 4.4 断线重连时的ID处理


**🔄 重连机制工作原理**
```
1. 浏览器记住最后收到的消息ID
2. 断线重连时，浏览器发送 Last-Event-ID 请求头
3. 服务器根据这个ID，从对应位置开始发送消息
```

**🔧 服务端处理重连ID**
```javascript
app.get('/events', (req, res) => {
  // 获取客户端最后收到的消息ID
  const lastEventId = req.headers['last-event-id'];
  let startId = lastEventId ? parseInt(lastEventId) : 0;
  
  console.log('客户端最后收到的消息ID：', lastEventId);
  
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache'
  });
  
  // 从断点位置开始发送
  const timer = setInterval(() => {
    startId++;
    res.write(`id: ${startId}\n`);
    res.write(`data: 消息${startId}，重连成功！\n\n`);
  }, 1000);
});
```

### 4.5 消息ID的实际价值


**💡 解决的实际问题**
- **📶 网络不稳定**：移动设备网络经常断断续续
- **💻 页面刷新**：用户刷新页面后不丢失消息
- **🔄 自动重连**：程序异常重启后自动恢复
- **📊 数据完整性**：确保重要消息不遗漏

---

## 5. ⏱️ 重连间隔：retry字段配置


### 5.1 什么是重连间隔


**通俗理解**：当连接断开时，浏览器等多长时间再尝试重新连接

```
生活中的例子：
📞 打电话占线，等5秒再拨
🚪 敲门没人应答，等10秒再敲
💻 SSE连接断了，等几秒再重连

retry字段就是告诉浏览器"等多久再重连"
```

### 5.2 retry字段的基本用法


**🔸 标准格式**
```
retry: 重连间隔毫秒数\n
data: 消息内容\n\n
```

**重要理解**：
- `retry:` 后面跟的是毫秒数（1秒 = 1000毫秒）
- 这个设置会影响后续所有的重连尝试
- 如果不设置，浏览器默认3秒重连

### 5.3 服务端设置重连间隔


**🔧 基本设置示例**
```javascript
app.get('/events', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache'
  });
  
  // 设置重连间隔为5秒
  res.write('retry: 5000\n');
  res.write('data: 连接已建立，如果断线将在5秒后重连\n\n');
  
  // 发送正常消息
  let count = 0;
  const timer = setInterval(() => {
    count++;
    res.write(`data: 第${count}条消息\n\n`);
  }, 2000);
});
```

### 5.4 根据情况动态调整重连间隔


**🎯 智能重连策略**
```javascript
app.get('/events', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream'
  });
  
  // 根据服务器负载调整重连间隔
  const serverLoad = getServerLoad(); // 假设的获取负载函数
  
  if (serverLoad > 80) {
    // 服务器负载高，延长重连间隔
    res.write('retry: 10000\n');
    res.write('data: {"msg": "服务器负载较高，重连间隔设为10秒"}\n\n');
  } else if (serverLoad > 50) {
    // 中等负载
    res.write('retry: 5000\n'); 
    res.write('data: {"msg": "正常负载，重连间隔5秒"}\n\n');
  } else {
    // 低负载，快速重连
    res.write('retry: 2000\n');
    res.write('data: {"msg": "服务器空闲，重连间隔2秒"}\n\n');
  }
});
```

### 5.5 重连间隔的最佳实践


**⚖️ 平衡考虑因素**
```
太短的问题：
❌ 服务器压力大（频繁连接）
❌ 浪费网络资源
❌ 可能被当作攻击

太长的问题：  
❌ 用户体验差（等待时间长）
❌ 消息延迟严重
❌ 实时性下降

推荐设置：
✅ 正常情况：3-5秒
✅ 服务器忙：8-15秒  
✅ 网络差：20-30秒
```

---

## 6. 💓 心跳消息机制设计


### 6.1 什么是心跳消息


**通俗理解**：就像医院监控病人心跳一样，定期发送简单消息检查连接是否还活着

```
医院场景：
💓 心电图：嘀...嘀...嘀...（证明病人活着）

网络场景：  
💻 心跳消息：ping...ping...ping...（证明连接活着）

如果长时间没心跳，就知道出问题了
```

### 6.2 为什么需要心跳消息


**🔸 解决的实际问题**
- **🕰️ 长时间无消息**：如果半小时没有业务消息，连接可能被中断
- **🔥 防火墙超时**：很多防火墙会关闭长时间无活动的连接
- **📱 移动网络**：手机网络经常在无活动时断开连接
- **🔍 连接检测**：及时发现连接异常

### 6.3 实现简单的心跳机制


**🔧 服务端心跳实现**
```javascript
app.get('/events', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache'
  });
  
  // 心跳定时器（每30秒发送一次）
  const heartbeatTimer = setInterval(() => {
    res.write('event: heartbeat\n');
    res.write(`data: {"type": "ping", "time": "${new Date()}"}\n\n`);
  }, 30000);
  
  // 业务消息定时器
  let msgCount = 0;
  const messageTimer = setInterval(() => {
    msgCount++;
    res.write('event: message\n');
    res.write(`data: {"msg": "业务消息${msgCount}"}\n\n`);
  }, 60000); // 每分钟发一条业务消息
  
  // 清理定时器
  req.on('close', () => {
    clearInterval(heartbeatTimer);
    clearInterval(messageTimer);
  });
});
```

**💻 前端心跳处理**
```javascript
const eventSource = new EventSource('/events');

// 记录最后收到消息的时间
let lastHeartbeat = Date.now();

// 监听心跳消息
eventSource.addEventListener('heartbeat', function(event) {
  lastHeartbeat = Date.now();
  console.log('💓 收到心跳，连接正常');
});

// 监听业务消息
eventSource.addEventListener('message', function(event) {
  const data = JSON.parse(event.data);
  console.log('📨 业务消息：', data.msg);
});

// 检查心跳超时（每分钟检查一次）
setInterval(() => {
  const timeSinceLastHeartbeat = Date.now() - lastHeartbeat;
  if (timeSinceLastHeartbeat > 60000) { // 超过1分钟没收到心跳
    console.warn('⚠️ 心跳超时，连接可能异常');
    // 可以显示连接状态提示
  }
}, 60000);
```

### 6.4 智能心跳策略


**🧠 优化的心跳机制**
```javascript
class SmartHeartbeat {
  constructor() {
    this.lastActivityTime = Date.now();
    this.heartbeatInterval = 30000; // 默认30秒
  }
  
  // 有业务消息时重置心跳计时
  onBusinessMessage() {
    this.lastActivityTime = Date.now();
  }
  
  // 智能心跳：只在必要时发送
  startHeartbeat(res) {
    setInterval(() => {
      const timeSinceLastActivity = Date.now() - this.lastActivityTime;
      
      // 如果超过心跳间隔没有活动，发送心跳
      if (timeSinceLastActivity >= this.heartbeatInterval) {
        res.write('event: heartbeat\n');
        res.write('data: ping\n\n');
        this.lastActivityTime = Date.now();
      }
    }, 10000); // 每10秒检查一次
  }
}
```

### 6.5 心跳消息的最佳实践


**📋 设计建议**
```
心跳频率：
✅ 一般应用：30-60秒
✅ 重要应用：15-30秒  
✅ 移动端：60-120秒（省电）

心跳内容：
✅ 简单文本：data: ping
✅ 带时间戳：data: {"heartbeat": 1642781234567}
✅ 状态信息：data: {"status": "ok", "users": 1250}

优化策略：
✅ 有业务消息时不发心跳（避免冗余）
✅ 根据网络状况动态调整频率
✅ 客户端也要监控心跳超时
✅ 心跳失败时及时重连
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 data字段：消息的实际内容，支持单行和多行格式
🔸 event字段：自定义事件类型，让前端分类处理不同消息
🔸 id字段：消息唯一标识，支持断线重连和消息补发
🔸 retry字段：设置重连间隔，平衡性能和用户体验  
🔸 心跳机制：保持连接活跃，及时发现连接异常
```

### 7.2 关键理解要点


**🔹 消息格式的设计哲学**
```
简单明确：
- 每个字段都有明确含义和用途
- 格式统一，便于解析和处理
- 支持扩展，满足不同业务需求

实用导向：
- 解决实际网络通信中的常见问题
- 考虑了断线重连、消息丢失等场景
- 平衡了性能和功能需求
```

**🔹 字段组合使用策略**
```
基础消息：只用data字段
分类消息：data + event字段
可靠消息：data + event + id字段  
完整消息：data + event + id + retry字段
保活连接：定期发送心跳消息
```

### 7.3 实际应用指导


**🎯 消息设计建议**
- **📝 内容设计**：使用JSON格式便于前端处理
- **🏷️ 类型规划**：提前设计好事件类型体系
- **🆔 ID策略**：使用递增数字或时间戳作为ID
- **⏱️ 重连控制**：根据业务重要性设置合适间隔
- **💓 心跳设计**：平衡网络开销和连接可靠性

**🔧 开发实践要点**
```
服务端实现：
✅ 正确设置Content-Type和响应头
✅ 合理使用各个字段组合  
✅ 实现优雅的连接管理和清理
✅ 考虑服务器性能和并发数

前端实现：
✅ 针对不同事件类型分别处理
✅ 监控连接状态和心跳情况
✅ 处理重连和异常情况
✅ 提供良好的用户体验反馈
```

**核心记忆口诀**：
- data承载内容，event区分类型
- id支持重连，retry控制间隔  
- 心跳保活连，格式要规范
- 字段巧组合，通信更可靠