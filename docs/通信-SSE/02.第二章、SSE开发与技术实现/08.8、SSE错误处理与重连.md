---
title: 8、SSE错误处理与重连
---
## 📚 目录

1. [错误处理基础概念](#1-错误处理基础概念)
2. [网络异常捕获机制](#2-网络异常捕获机制)
3. [服务端错误响应处理](#3-服务端错误响应处理)
4. [自动重连机制实现](#4-自动重连机制实现)
5. [重连间隔策略设计](#5-重连间隔策略设计)
6. [手动重连控制方法](#6-手动重连控制方法)
7. [完整错误处理方案](#7-完整错误处理方案)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 错误处理基础概念


### 1.1 什么是SSE错误处理


**简单理解**：SSE连接就像打电话，电话可能会断线、对方忙线、信号不好，我们需要处理这些情况。

```
正常情况：客户端 ←→ 服务器 (持续通信)
异常情况：客户端 ✗   服务器 (连接中断)
处理方案：客户端 ⟲   服务器 (自动重连)
```

### 1.2 常见的SSE错误类型


**🔸 网络层面的错误**
- **网络中断**：用户网络断开，就像手机没信号
- **服务器宕机**：服务器停止工作，就像对方关机
- **超时错误**：连接太久没响应，就像电话没人接

**🔸 应用层面的错误**  
- **权限问题**：没有访问权限，就像拨错号码
- **服务器内部错误**：服务器程序出错，就像对方电话故障
- **数据格式错误**：收到的数据有问题

### 1.3 错误处理的重要性


```
为什么需要错误处理？

用户体验：
没有错误处理 → 连接断开就彻底断了 → 用户看不到新消息
有错误处理   → 自动重连恢复通信   → 用户无感知继续使用

系统稳定性：
网络不稳定 → 频繁断连 → 需要自动重连保持服务
服务器重启 → 连接中断 → 需要重新建立连接
```

---

## 2. 🚫 网络异常捕获机制


### 2.1 SSE的错误事件监听


**核心概念**：SSE提供了专门的错误事件，就像电话有"线路故障"的提示音。

```javascript
const eventSource = new EventSource('/api/sse');

// 监听错误事件 - 就像监听电话的故障提示
eventSource.onerror = function(event) {
    console.log('连接出错了：', event);
    
    // 检查连接状态
    if (eventSource.readyState === EventSource.CLOSED) {
        console.log('连接已经关闭');
    } else if (eventSource.readyState === EventSource.CONNECTING) {
        console.log('正在重新连接...');
    }
};
```

### 2.2 连接状态的含义


**🔸 三种连接状态**
```javascript
// EventSource的三种状态
CONNECTING = 0  // 正在连接 - 就像正在拨号
OPEN = 1        // 连接成功 - 就像电话接通了
CLOSED = 2      // 连接关闭 - 就像电话挂断了

// 实际使用
function checkConnectionStatus() {
    switch(eventSource.readyState) {
        case EventSource.CONNECTING:
            console.log('📞 正在连接服务器...');
            break;
        case EventSource.OPEN:
            console.log('✅ 连接成功，可以接收消息');
            break;
        case EventSource.CLOSED:
            console.log('❌ 连接已断开');
            break;
    }
}
```

### 2.3 网络异常的识别


**如何判断是什么类型的错误**：

```javascript
eventSource.onerror = function(event) {
    // 通过连接状态判断错误类型
    if (eventSource.readyState === EventSource.CLOSED) {
        // 永久性错误 - 就像对方关机了
        console.log('🚫 连接被永久关闭，可能是服务器错误');
        handlePermanentError();
    } else {
        // 临时性错误 - 就像信号不好，稍后会自动重连
        console.log('⚠️ 网络临时中断，浏览器会自动重连');
        handleTemporaryError();
    }
};

function handleTemporaryError() {
    // 显示"网络不稳定，正在重连..."的提示
    showReconnectingMessage();
}

function handlePermanentError() {
    // 显示"连接失败，请刷新页面"的提示
    showErrorMessage();
}
```

---

## 3. 🔧 服务端错误响应处理


### 3.1 HTTP状态码的处理


**核心理解**：服务器会返回不同的错误代码，就像不同的忙音有不同含义。

```javascript
// 监听连接打开事件
eventSource.onopen = function(event) {
    console.log('✅ 连接建立成功');
};

// 错误处理 - 根据不同情况采取不同策略
eventSource.onerror = function(event) {
    // 获取HTTP状态码（如果可用）
    const status = event.target.status || 'unknown';
    
    switch(status) {
        case 401:
            console.log('🔐 权限不足，请先登录');
            redirectToLogin();
            break;
        case 403:
            console.log('🚫 访问被拒绝，请检查权限');
            showPermissionError();
            break;
        case 404:
            console.log('❓ 接口不存在，请检查URL');
            showNotFoundError();
            break;
        case 500:
            console.log('💥 服务器内部错误，稍后重试');
            scheduleReconnect();
            break;
        default:
            console.log('⚠️ 未知错误，尝试重连');
            scheduleReconnect();
    }
};
```

### 3.2 服务端错误消息处理


**服务器可以发送错误信息**：

```javascript
// 服务器端发送错误信息
eventSource.addEventListener('error-message', function(event) {
    const errorData = JSON.parse(event.data);
    
    switch(errorData.type) {
        case 'AUTH_EXPIRED':
            console.log('🔑 登录已过期，请重新登录');
            handleAuthExpired();
            break;
        case 'RATE_LIMIT':
            console.log('⏱️ 请求过于频繁，请稍后再试');
            handleRateLimit();
            break;
        case 'SERVER_MAINTENANCE':
            console.log('🔧 服务器维护中，请稍后再试');
            handleMaintenance();
            break;
    }
});

function handleAuthExpired() {
    // 关闭当前连接
    eventSource.close();
    // 跳转到登录页面
    window.location.href = '/login';
}
```

---

## 4. 🔄 自动重连机制实现


### 4.1 浏览器的自动重连


**重要概念**：浏览器会自动重连，但我们需要控制这个过程。

```javascript
class SSEManager {
    constructor(url) {
        this.url = url;
        this.reconnectAttempts = 0;        // 重连尝试次数
        this.maxReconnectAttempts = 5;     // 最大重连次数
        this.isManuallyDisconnected = false; // 是否手动断开
    }
    
    connect() {
        // 如果手动断开，不要自动重连
        if (this.isManuallyDisconnected) {
            return;
        }
        
        console.log(`📞 尝试连接... (第${this.reconnectAttempts + 1}次)`);
        
        this.eventSource = new EventSource(this.url);
        
        this.eventSource.onopen = () => {
            console.log('✅ 连接成功');
            this.reconnectAttempts = 0; // 连接成功，重置计数
        };
        
        this.eventSource.onerror = () => {
            if (this.eventSource.readyState === EventSource.CLOSED) {
                this.handleReconnect();
            }
        };
    }
    
    handleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.log('🚫 重连次数已达上限，停止重连');
            this.showManualReconnectButton();
            return;
        }
        
        this.reconnectAttempts++;
        console.log(`🔄 将在3秒后重连... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        
        setTimeout(() => {
            this.connect();
        }, 3000);
    }
}
```

### 4.2 智能重连策略


**指数退避算法**：重连间隔逐渐增加，就像敲门被拒绝后，等待时间越来越长。

```javascript
class SmartSSEManager {
    constructor(url) {
        this.url = url;
        this.reconnectAttempts = 0;
        this.baseDelay = 1000;  // 基础延迟1秒
        this.maxDelay = 30000;  // 最大延迟30秒
    }
    
    // 计算重连延迟 - 指数增长
    calculateDelay() {
        // 1秒 → 2秒 → 4秒 → 8秒 → 16秒 → 30秒(最大)
        const delay = Math.min(
            this.baseDelay * Math.pow(2, this.reconnectAttempts),
            this.maxDelay
        );
        return delay;
    }
    
    handleReconnect() {
        const delay = this.calculateDelay();
        this.reconnectAttempts++;
        
        console.log(`⏰ ${delay/1000}秒后重连...`);
        
        this.reconnectTimer = setTimeout(() => {
            this.connect();
        }, delay);
    }
    
    // 手动重连 - 立即重连
    manualReconnect() {
        console.log('🔄 手动重连...');
        clearTimeout(this.reconnectTimer); // 取消自动重连
        this.reconnectAttempts = 0;        // 重置计数
        this.connect();
    }
}
```

---

## 5. ⏱️ 重连间隔策略设计


### 5.1 不同的重连策略对比


| 策略类型 | **间隔规律** | **优点** | **缺点** | **适用场景** |
|---------|-------------|---------|---------|-------------|
| 🔄 **固定间隔** | `每3秒重连` | `简单可预测` | `可能浪费资源` | `网络稳定环境` |
| 📈 **指数退避** | `1→2→4→8秒` | `减少服务器压力` | `恢复较慢` | `一般网络环境` |
| 🎯 **线性增加** | `1→2→3→4秒` | `渐进式增加` | `增长较慢` | `轻度网络问题` |
| 🔀 **随机间隔** | `1-5秒随机` | `避免同时重连` | `不可预测` | `高并发场景` |

### 5.2 实用的重连策略实现


```javascript
class ReconnectionStrategy {
    constructor(type = 'exponential') {
        this.type = type;
        this.attempts = 0;
        this.baseDelay = 1000;
        this.maxDelay = 30000;
    }
    
    getDelay() {
        switch(this.type) {
            case 'fixed':
                // 固定3秒间隔
                return 3000;
                
            case 'linear':
                // 线性增长：1秒、2秒、3秒...
                return Math.min(this.baseDelay * (this.attempts + 1), this.maxDelay);
                
            case 'exponential':
                // 指数增长：1秒、2秒、4秒、8秒...
                return Math.min(this.baseDelay * Math.pow(2, this.attempts), this.maxDelay);
                
            case 'random':
                // 随机间隔：1-5秒之间随机
                return Math.random() * 4000 + 1000;
                
            default:
                return this.baseDelay;
        }
    }
    
    // 重连成功后重置
    reset() {
        this.attempts = 0;
    }
    
    // 增加尝试次数
    increment() {
        this.attempts++;
    }
}

// 使用示例
const strategy = new ReconnectionStrategy('exponential');

function scheduleReconnect() {
    const delay = strategy.getDelay();
    strategy.increment();
    
    console.log(`⏰ ${delay/1000}秒后重连 (第${strategy.attempts}次尝试)`);
    
    setTimeout(() => {
        connect();
    }, delay);
}
```

### 5.3 网络状态感知的重连


**根据网络状态调整策略**：

```javascript
class NetworkAwareSSE {
    constructor(url) {
        this.url = url;
        this.isOnline = navigator.onLine;
        
        // 监听网络状态变化
        window.addEventListener('online', () => {
            console.log('🌐 网络已恢复，立即重连');
            this.isOnline = true;
            this.immediateReconnect();
        });
        
        window.addEventListener('offline', () => {
            console.log('📶 网络已断开，暂停重连');
            this.isOnline = false;
            this.pauseReconnection();
        });
    }
    
    handleReconnect() {
        if (!this.isOnline) {
            console.log('📵 网络断开中，等待网络恢复...');
            return;
        }
        
        // 网络正常时才进行重连
        this.scheduleReconnect();
    }
    
    immediateReconnect() {
        // 网络恢复时立即重连
        this.reconnectAttempts = 0;
        this.connect();
    }
}
```

---

## 6. 🎮 手动重连控制方法


### 6.1 用户控制界面


**给用户重连的控制权**：

```javascript
class UserControlledSSE {
    constructor(url) {
        this.url = url;
        this.isAutoReconnect = true;  // 默认开启自动重连
        this.createControlUI();
    }
    
    createControlUI() {
        // 创建控制按钮
        const controlPanel = document.createElement('div');
        controlPanel.innerHTML = `
            <div class="sse-control-panel">
                <span class="connection-status">🔴 未连接</span>
                <button id="connect-btn">连接</button>
                <button id="disconnect-btn">断开</button>
                <label>
                    <input type="checkbox" id="auto-reconnect" checked>
                    自动重连
                </label>
            </div>
        `;
        
        document.body.appendChild(controlPanel);
        this.bindEvents();
    }
    
    bindEvents() {
        // 手动连接
        document.getElementById('connect-btn').onclick = () => {
            this.manualConnect();
        };
        
        // 手动断开
        document.getElementById('disconnect-btn').onclick = () => {
            this.manualDisconnect();
        };
        
        // 自动重连开关
        document.getElementById('auto-reconnect').onchange = (e) => {
            this.isAutoReconnect = e.target.checked;
            console.log(this.isAutoReconnect ? '✅ 已开启自动重连' : '❌ 已关闭自动重连');
        };
    }
    
    manualConnect() {
        console.log('👆 用户手动连接');
        this.reconnectAttempts = 0;
        this.connect();
    }
    
    manualDisconnect() {
        console.log('👆 用户手动断开');
        this.isManuallyDisconnected = true;
        if (this.eventSource) {
            this.eventSource.close();
        }
        this.updateConnectionStatus('🔴 已断开');
    }
    
    updateConnectionStatus(status) {
        const statusElement = document.querySelector('.connection-status');
        if (statusElement) {
            statusElement.textContent = status;
        }
    }
}
```

### 6.2 重连提示与用户交互


```javascript
class InteractiveSSE {
    showReconnectDialog() {
        // 显示重连选择对话框
        const userChoice = confirm(
            '连接已断开。\n\n' +
            '点击"确定"立即重连\n' + 
            '点击"取消"稍后手动连接'
        );
        
        if (userChoice) {
            this.immediateReconnect();
        } else {
            this.showReconnectButton();
        }
    }
    
    showReconnectButton() {
        // 显示重连按钮
        const reconnectBtn = document.createElement('button');
        reconnectBtn.textContent = '🔄 点击重连';
        reconnectBtn.className = 'reconnect-button';
        reconnectBtn.onclick = () => {
            this.manualReconnect();
            reconnectBtn.remove(); // 移除按钮
        };
        
        document.body.appendChild(reconnectBtn);
    }
    
    showConnectionToast(message, type = 'info') {
        // 显示连接状态提示
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // 3秒后自动移除
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
}
```

---

## 7. 🔧 完整错误处理方案


### 7.1 综合错误处理类


```javascript
class RobustSSE {
    constructor(url, options = {}) {
        this.url = url;
        this.options = {
            maxReconnectAttempts: 10,
            reconnectStrategy: 'exponential',
            autoReconnect: true,
            ...options
        };
        
        this.reconnectAttempts = 0;
        this.eventSource = null;
        this.isManuallyDisconnected = false;
        this.listeners = {};
        
        this.init();
    }
    
    init() {
        this.connect();
        this.setupNetworkListeners();
    }
    
    connect() {
        if (this.isManuallyDisconnected) return;
        
        try {
            console.log('🔌 尝试建立连接...');
            
            this.eventSource = new EventSource(this.url);
            this.setupEventListeners();
            
        } catch (error) {
            console.error('❌ 连接创建失败:', error);
            this.handleError('CONNECTION_FAILED', error);
        }
    }
    
    setupEventListeners() {
        // 连接成功
        this.eventSource.onopen = () => {
            console.log('✅ 连接建立成功');
            this.reconnectAttempts = 0;
            this.emit('connected');
        };
        
        // 接收消息
        this.eventSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.emit('message', data);
            } catch (error) {
                console.warn('⚠️ 消息解析失败:', event.data);
                this.emit('message', event.data);
            }
        };
        
        // 错误处理
        this.eventSource.onerror = (event) => {
            console.log('❌ 连接发生错误');
            
            if (this.eventSource.readyState === EventSource.CLOSED) {
                this.emit('disconnected');
                this.handleReconnection();
            } else {
                this.emit('error', event);
            }
        };
    }
    
    handleReconnection() {
        if (!this.options.autoReconnect || this.isManuallyDisconnected) {
            return;
        }
        
        if (this.reconnectAttempts >= this.options.maxReconnectAttempts) {
            console.log('🚫 达到最大重连次数，停止重连');
            this.emit('maxReconnectReached');
            return;
        }
        
        const delay = this.calculateReconnectDelay();
        this.reconnectAttempts++;
        
        console.log(`🔄 ${delay/1000}秒后重连 (${this.reconnectAttempts}/${this.options.maxReconnectAttempts})`);
        
        this.reconnectTimer = setTimeout(() => {
            this.connect();
        }, delay);
    }
    
    calculateReconnectDelay() {
        const base = 1000;
        const max = 30000;
        
        switch(this.options.reconnectStrategy) {
            case 'fixed':
                return 3000;
            case 'linear':
                return Math.min(base * this.reconnectAttempts, max);
            case 'exponential':
            default:
                return Math.min(base * Math.pow(2, this.reconnectAttempts - 1), max);
        }
    }
    
    // 事件系统
    on(event, callback) {
        if (!this.listeners[event]) {
            this.listeners[event] = [];
        }
        this.listeners[event].push(callback);
    }
    
    emit(event, data) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(callback => callback(data));
        }
    }
    
    // 手动控制方法
    manualReconnect() {
        console.log('🔄 手动重连...');
        clearTimeout(this.reconnectTimer);
        this.reconnectAttempts = 0;
        this.isManuallyDisconnected = false;
        this.connect();
    }
    
    disconnect() {
        console.log('🔌 手动断开连接');
        this.isManuallyDisconnected = true;
        clearTimeout(this.reconnectTimer);
        
        if (this.eventSource) {
            this.eventSource.close();
        }
        
        this.emit('manualDisconnect');
    }
}
```

### 7.2 实际使用示例


```javascript
// 创建SSE连接
const sse = new RobustSSE('/api/sse', {
    maxReconnectAttempts: 5,
    reconnectStrategy: 'exponential',
    autoReconnect: true
});

// 监听连接事件
sse.on('connected', () => {
    console.log('🎉 连接成功！');
    showStatus('已连接', 'success');
});

sse.on('disconnected', () => {
    console.log('📵 连接断开');
    showStatus('连接断开', 'warning');
});

sse.on('message', (data) => {
    console.log('📨 收到消息:', data);
    displayMessage(data);
});

sse.on('maxReconnectReached', () => {
    console.log('🚫 重连失败，请检查网络');
    showManualReconnectButton();
});

// 页面控制按钮
function showManualReconnectButton() {
    const btn = document.createElement('button');
    btn.textContent = '🔄 点击重连';
    btn.onclick = () => {
        sse.manualReconnect();
        btn.remove();
    };
    document.body.appendChild(btn);
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 错误类型：网络中断、服务器错误、权限问题
🔸 连接状态：CONNECTING、OPEN、CLOSED三种状态
🔸 自动重连：浏览器自动重连，但需要我们控制
🔸 重连策略：固定间隔、指数退避、线性增长等
🔸 用户控制：给用户手动重连的能力
🔸 状态提示：让用户知道当前连接状态
```

### 8.2 关键理解要点


**🔹 错误处理的本质**
```
核心思路：
- 网络不可靠是常态，断线重连是必需功能
- 不同错误需要不同处理策略
- 用户体验比技术实现更重要

实现原则：
- 自动处理常见错误
- 给用户必要的控制权
- 提供清晰的状态反馈
```

**🔹 重连策略的选择**
```
网络环境良好：使用固定间隔重连
网络环境一般：使用指数退避算法  
服务器压力大：使用随机间隔避免同时重连
用户体验优先：结合网络状态感知
```

**🔹 用户体验设计**
```
静默处理：网络抖动等临时问题自动处理
用户感知：长时间断线要告知用户
用户控制：提供手动重连的选项
状态反馈：实时显示连接状态
```

### 8.3 实际应用建议


**🎯 基础错误处理**
- 监听`onerror`事件捕获所有错误
- 检查`readyState`判断错误类型
- 实现基本的自动重连机制

**🎯 进阶错误处理**  
- 使用指数退避算法控制重连间隔
- 限制最大重连次数防止无限重连
- 监听网络状态优化重连时机

**🎯 用户体验优化**
- 提供连接状态的可视化反馈
- 给用户手动重连的控制选项
- 在合适时机显示错误提示信息

### 8.4 常见问题解决


```
Q: 为什么连接总是断开？
A: 检查服务器keep-alive设置，确保定期发送心跳消息

Q: 重连太频繁怎么办？
A: 使用指数退避算法，逐渐增加重连间隔

Q: 用户手动断开后自动重连了？
A: 设置手动断开标记，阻止自动重连

Q: 重连时用户不知道发生什么？
A: 添加连接状态提示，让用户了解当前状态
```

**核心记忆**：
- SSE错误处理像电话故障处理，需要识别故障类型
- 自动重连要智能，不能盲目频繁重试
- 用户体验最重要，要给用户控制权和状态反馈
- 网络不稳定是常态，错误处理是必需功能