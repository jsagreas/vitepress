---
title: 1、错误处理与状态码
---
## 📚 目录

1. [错误处理基础概念](#1-错误处理基础概念)
2. [gRPC状态码详解](#2-grpc状态码详解)
3. [错误的创建与解析](#3-错误的创建与解析)
4. [自定义错误处理](#4-自定义错误处理)
5. [客户端重试策略](#5-客户端重试策略)
6. [超时与取消机制](#6-超时与取消机制)
7. [实战应用场景](#7-实战应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 错误处理基础概念


### 1.1 为什么需要错误处理？


在网络通信中，各种问题随时可能发生：

```
客户端 ----请求----> 服务器
   ↑                  ↓
网络断了？           服务器挂了？
参数错误？           数据库连不上？
权限不够？           处理超时了？
```

> 💡 **核心理念**：gRPC的错误处理就像生活中的"错误代码"，比如HTTP的404、500一样，告诉你到底出了什么问题

### 1.2 gRPC错误处理的特点


**🔸 统一的错误体系**
```
不同编程语言，同样的错误代码
Java的INVALID_ARGUMENT = Go的INVALID_ARGUMENT = Python的INVALID_ARGUMENT
```

**🔸 丰富的错误信息**
- **状态码**：告诉你错误类型（比如"找不到"、"权限不够"）
- **错误消息**：具体描述问题（比如"用户ID不存在"）
- **错误详情**：额外的结构化信息

---

## 2. 📋 gRPC状态码详解


### 2.1 核心状态码分类


gRPC有16个标准状态码，就像生活中不同类型的问题：

#### ✅ **成功类**

| 状态码 | 含义 | 生活比喻 | 使用场景 |
|-------|------|---------|----------|
| `OK` | 成功 | 任务完成✅ | 请求正常处理完成 |

#### ❌ **客户端错误类**（客户端的问题）

| 状态码 | 含义 | 生活比喻 | 使用场景 |
|-------|------|---------|----------|
| `INVALID_ARGUMENT` | 参数错误 | 你填错表格了📝 | 请求参数格式错误、必填字段缺失 |
| `NOT_FOUND` | 找不到 | 你要的东西不存在🔍 | 用户ID不存在、资源已删除 |
| `ALREADY_EXISTS` | 已存在 | 重复创建了📂 | 用户名已注册、重复提交 |
| `PERMISSION_DENIED` | 权限不够 | 你没权限进入🚫 | 用户未登录、权限不足 |
| `UNAUTHENTICATED` | 未认证 | 你没证明身份🔐 | Token过期、未登录 |

#### 🔧 **服务端错误类**（服务器的问题）

| 状态码 | 含义 | 生活比喻 | 使用场景 |
|-------|------|---------|----------|
| `INTERNAL` | 内部错误 | 服务器出Bug了💥 | 代码异常、数据库错误 |
| `UNAVAILABLE` | 服务不可用 | 店铺关门了🏪 | 服务器宕机、维护中 |
| `DEADLINE_EXCEEDED` | 超时 | 处理太慢了⏰ | 请求处理超时 |

#### 🔄 **其他类**

| 状态码 | 含义 | 生活比喻 | 使用场景 |
|-------|------|---------|----------|
| `CANCELLED` | 取消了 | 你不想要了❌ | 客户端主动取消请求 |
| `UNKNOWN` | 未知错误 | 不知道咋回事🤷 | 无法分类的异常 |

### 2.2 状态码选择指南


```
选择状态码的思路：

🤔 问题出在哪？
├─ 客户端问题
│  ├─ 参数有问题 → INVALID_ARGUMENT
│  ├─ 权限有问题 → PERMISSION_DENIED
│  └─ 资源不存在 → NOT_FOUND
│
└─ 服务端问题
   ├─ 代码出错了 → INTERNAL
   ├─ 处理太慢了 → DEADLINE_EXCEEDED
   └─ 服务挂了   → UNAVAILABLE
```

---

## 3. 🛠️ 错误的创建与解析


### 3.1 服务端：创建错误


#### 🔸 基础错误创建


```go
import (
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// 方式1：简单创建错误
func (s *userService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    if req.UserId == "" {
        // 创建"参数错误"的错误
        return nil, status.Error(codes.InvalidArgument, "用户ID不能为空")
    }
    
    user := findUserInDB(req.UserId)
    if user == nil {
        // 创建"找不到"的错误
        return nil, status.Error(codes.NotFound, "用户不存在")
    }
    
    return user, nil
}
```

#### 🔸 带格式化的错误


```go
// 方式2：格式化错误消息
func (s *userService) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.User, error) {
    if req.User.Age < 0 || req.User.Age > 150 {
        // 格式化错误消息
        return nil, status.Errorf(codes.InvalidArgument, 
            "年龄 %d 不合法，应该在 0-150 之间", req.User.Age)
    }
    
    // 模拟数据库错误
    if dbError := updateUserInDB(req.User); dbError != nil {
        return nil, status.Error(codes.Internal, "数据库更新失败")
    }
    
    return req.User, nil
}
```

### 3.2 客户端：解析错误


```go
import (
    "google.golang.org/grpc/status"
)

func main() {
    client := pb.NewUserServiceClient(conn)
    
    // 调用服务
    user, err := client.GetUser(context.Background(), &pb.GetUserRequest{
        UserId: "",  // 故意传空值
    })
    
    if err != nil {
        // 解析gRPC错误
        if grpcErr, ok := status.FromError(err); ok {
            switch grpcErr.Code() {
            case codes.InvalidArgument:
                fmt.Printf("参数错误：%s\n", grpcErr.Message())
                // 输出：参数错误：用户ID不能为空
                
            case codes.NotFound:
                fmt.Printf("用户不存在：%s\n", grpcErr.Message())
                
            case codes.Internal:
                fmt.Printf("服务器内部错误：%s\n", grpcErr.Message())
                
            default:
                fmt.Printf("其他错误：%s\n", grpcErr.Message())
            }
        } else {
            fmt.Printf("非gRPC错误：%v\n", err)
        }
        return
    }
    
    fmt.Printf("获取用户成功：%v\n", user)
}
```

### 3.3 错误处理流程图


```
服务端处理请求流程：

请求到达 → 参数检查 → 业务逻辑处理 → 返回结果
    ↓           ↓            ↓           ↓
   OK      有问题？      出错了？      正常
    ↓           ↓            ↓           ↓
  继续处理  返回错误码   返回错误码   返回数据
             ↓            ↓
        InvalidArgument  Internal
```

---

## 4. 🎯 自定义错误处理


### 4.1 添加错误详情


有时候简单的错误消息不够，需要更多信息：

```go
import (
    "google.golang.org/genproto/googleapis/rpc/errdetails"
    "google.golang.org/grpc/status"
)

func (s *userService) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.User, error) {
    // 验证多个字段
    violations := []string{}
    
    if req.User.Name == "" {
        violations = append(violations, "姓名不能为空")
    }
    if req.User.Email == "" {
        violations = append(violations, "邮箱不能为空")
    }
    if req.User.Age < 18 {
        violations = append(violations, "年龄必须大于18岁")
    }
    
    if len(violations) > 0 {
        // 创建详细错误信息
        st := status.New(codes.InvalidArgument, "请求参数验证失败")
        
        // 添加详细的验证错误
        badRequest := &errdetails.BadRequest{}
        for _, violation := range violations {
            badRequest.FieldViolations = append(badRequest.FieldViolations, 
                &errdetails.BadRequest_FieldViolation{
                    Description: violation,
                })
        }
        
        st, _ = st.WithDetails(badRequest)
        return nil, st.Err()
    }
    
    // 正常创建用户
    return createUserInDB(req.User), nil
}
```

### 4.2 上下文错误传递


错误可以携带上下文信息，帮助调试：

```go
func (s *userService) GetUserProfile(ctx context.Context, req *pb.GetUserRequest) (*pb.UserProfile, error) {
    // 获取用户基本信息
    user, err := s.getUserFromDB(req.UserId)
    if err != nil {
        // 包装错误，添加上下文
        return nil, status.Errorf(codes.Internal, 
            "获取用户基本信息失败 [用户ID: %s]: %v", req.UserId, err)
    }
    
    // 获取用户权限
    permissions, err := s.getUserPermissions(req.UserId)
    if err != nil {
        return nil, status.Errorf(codes.Internal, 
            "获取用户权限失败 [用户ID: %s]: %v", req.UserId, err)
    }
    
    return &pb.UserProfile{
        User: user,
        Permissions: permissions,
    }, nil
}
```

---

## 5. 🔄 客户端重试策略


### 5.1 哪些错误可以重试？


> 💡 **重试原则**：只重试"可能成功"的错误

```
可以重试的错误：
✅ UNAVAILABLE     - 服务暂时不可用
✅ DEADLINE_EXCEEDED - 超时了，可能下次会快点
✅ INTERNAL        - 服务器内部错误（可能是临时的）

不应该重试的错误：
❌ INVALID_ARGUMENT  - 参数错误，重试也没用
❌ NOT_FOUND        - 找不到，重试也找不到
❌ PERMISSION_DENIED - 权限不够，重试也没权限
```

### 5.2 简单重试实现


```go
func callWithRetry(client pb.UserServiceClient, req *pb.GetUserRequest) (*pb.User, error) {
    maxRetries := 3
    baseDelay := time.Millisecond * 100
    
    for attempt := 0; attempt <= maxRetries; attempt++ {
        user, err := client.GetUser(context.Background(), req)
        
        if err == nil {
            return user, nil  // 成功了
        }
        
        // 检查是否应该重试
        if grpcErr, ok := status.FromError(err); ok {
            switch grpcErr.Code() {
            case codes.Unavailable, codes.Internal, codes.DeadlineExceeded:
                if attempt < maxRetries {
                    // 指数退避：等待时间逐渐增长
                    delay := baseDelay * time.Duration(1<<attempt)  // 100ms, 200ms, 400ms
                    fmt.Printf("第%d次重试，等待%v...\n", attempt+1, delay)
                    time.Sleep(delay)
                    continue
                }
            default:
                // 不可重试的错误，直接返回
                return nil, err
            }
        }
        
        // 超过最大重试次数
        return nil, fmt.Errorf("重试%d次后仍然失败: %v", maxRetries, err)
    }
    
    return nil, err
}
```

### 5.3 智能重试策略


```go
type RetryConfig struct {
    MaxRetries    int
    BaseDelay     time.Duration
    MaxDelay      time.Duration
    RetryableCodes map[codes.Code]bool
}

func NewRetryConfig() *RetryConfig {
    return &RetryConfig{
        MaxRetries: 3,
        BaseDelay:  100 * time.Millisecond,
        MaxDelay:   5 * time.Second,
        RetryableCodes: map[codes.Code]bool{
            codes.Unavailable:       true,
            codes.Internal:          true,
            codes.DeadlineExceeded:  true,
        },
    }
}

func (c *RetryConfig) ShouldRetry(err error) bool {
    if grpcErr, ok := status.FromError(err); ok {
        return c.RetryableCodes[grpcErr.Code()]
    }
    return false
}
```

---

## 6. ⏰ 超时与取消机制


### 6.1 设置请求超时


**🔸 为什么需要超时？**
- 防止请求无限等待
- 提高系统响应性
- 避免资源浪费

```go
func callWithTimeout() {
    conn, _ := grpc.Dial("localhost:8080", grpc.WithInsecure())
    client := pb.NewUserServiceClient(conn)
    
    // 设置5秒超时
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()  // 记得释放资源
    
    user, err := client.GetUser(ctx, &pb.GetUserRequest{UserId: "123"})
    if err != nil {
        if grpcErr, ok := status.FromError(err); ok {
            if grpcErr.Code() == codes.DeadlineExceeded {
                fmt.Println("请求超时了，服务器响应太慢")
                return
            }
        }
        fmt.Printf("其他错误: %v\n", err)
        return
    }
    
    fmt.Printf("获取用户成功: %v\n", user)
}
```

### 6.2 主动取消请求


```go
func callWithCancel() {
    ctx, cancel := context.WithCancel(context.Background())
    
    // 模拟用户5秒后不想等了
    go func() {
        time.Sleep(5 * time.Second)
        fmt.Println("用户不想等了，取消请求")
        cancel()
    }()
    
    client := pb.NewUserServiceClient(conn)
    user, err := client.GetUser(ctx, &pb.GetUserRequest{UserId: "123"})
    
    if err != nil {
        if grpcErr, ok := status.FromError(err); ok {
            if grpcErr.Code() == codes.Cancelled {
                fmt.Println("请求被取消了")
                return
            }
        }
    }
    
    fmt.Printf("获取用户成功: %v\n", user)
}
```

### 6.3 服务端检查取消状态


```go
func (s *userService) LongRunningTask(ctx context.Context, req *pb.TaskRequest) (*pb.TaskResponse, error) {
    for i := 0; i < 100; i++ {
        // 检查客户端是否取消了请求
        select {
        case <-ctx.Done():
            // 客户端取消了或超时了
            return nil, status.Error(codes.Cancelled, "任务被取消")
        default:
            // 继续处理
        }
        
        // 模拟耗时操作
        time.Sleep(100 * time.Millisecond)
        fmt.Printf("处理进度: %d%%\n", i)
    }
    
    return &pb.TaskResponse{Result: "任务完成"}, nil
}
```

---

## 7. 🚀 实战应用场景


### 7.1 用户认证场景


```go
func (s *authService) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) {
    // 参数验证
    if req.Username == "" {
        return nil, status.Error(codes.InvalidArgument, "用户名不能为空")
    }
    if req.Password == "" {
        return nil, status.Error(codes.InvalidArgument, "密码不能为空")
    }
    
    // 查找用户
    user := s.findUser(req.Username)
    if user == nil {
        return nil, status.Error(codes.NotFound, "用户不存在")
    }
    
    // 验证密码
    if !s.verifyPassword(user, req.Password) {
        return nil, status.Error(codes.Unauthenticated, "密码错误")
    }
    
    // 检查用户状态
    if user.Status == "locked" {
        return nil, status.Error(codes.PermissionDenied, "账户已被锁定")
    }
    
    // 生成Token
    token, err := s.generateToken(user)
    if err != nil {
        return nil, status.Error(codes.Internal, "生成登录凭证失败")
    }
    
    return &pb.LoginResponse{
        Token: token,
        User:  user,
    }, nil
}
```

### 7.2 数据库操作场景


```go
func (s *orderService) CreateOrder(ctx context.Context, req *pb.CreateOrderRequest) (*pb.Order, error) {
    // 检查商品是否存在
    product, err := s.getProduct(req.ProductId)
    if err != nil {
        if errors.Is(err, ErrProductNotFound) {
            return nil, status.Error(codes.NotFound, "商品不存在")
        }
        return nil, status.Error(codes.Internal, "查询商品信息失败")
    }
    
    // 检查库存
    if product.Stock < req.Quantity {
        return nil, status.Errorf(codes.FailedPrecondition, 
            "库存不足，当前库存：%d，需要：%d", product.Stock, req.Quantity)
    }
    
    // 检查用户权限
    if !s.hasPermission(ctx, "create_order") {
        return nil, status.Error(codes.PermissionDenied, "没有创建订单的权限")
    }
    
    // 创建订单（事务操作）
    order, err := s.createOrderInDB(ctx, req)
    if err != nil {
        if errors.Is(err, ErrDuplicateOrder) {
            return nil, status.Error(codes.AlreadyExists, "订单已存在")
        }
        return nil, status.Error(codes.Internal, "创建订单失败")
    }
    
    return order, nil
}
```

### 7.3 客户端完整错误处理


```go
func handleUserOperation() {
    client := pb.NewUserServiceClient(conn)
    
    // 创建用户
    user, err := client.CreateUser(context.Background(), &pb.CreateUserRequest{
        User: &pb.User{
            Name:  "张三",
            Email: "zhangsan@example.com",
            Age:   25,
        },
    })
    
    if err != nil {
        grpcErr, ok := status.FromError(err)
        if !ok {
            fmt.Printf("网络错误: %v\n", err)
            return
        }
        
        switch grpcErr.Code() {
        case codes.InvalidArgument:
            fmt.Printf("❌ 输入有误: %s\n", grpcErr.Message())
            fmt.Println("请检查用户信息是否完整且格式正确")
            
        case codes.AlreadyExists:
            fmt.Printf("⚠️ 用户已存在: %s\n", grpcErr.Message())
            fmt.Println("建议：使用其他邮箱或直接登录")
            
        case codes.PermissionDenied:
            fmt.Printf("🚫 权限不足: %s\n", grpcErr.Message())
            fmt.Println("请联系管理员获取创建用户的权限")
            
        case codes.Internal:
            fmt.Printf("💥 服务器错误: %s\n", grpcErr.Message())
            fmt.Println("建议：稍后重试或联系客服")
            
        case codes.Unavailable:
            fmt.Printf("🔧 服务暂不可用: %s\n", grpcErr.Message())
            fmt.Println("建议：检查网络连接或稍后重试")
            
        default:
            fmt.Printf("🤷 未知错误: %s\n", grpcErr.Message())
        }
        return
    }
    
    fmt.Printf("✅ 用户创建成功: %v\n", user)
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 状态码系统：16个标准状态码，分为成功、客户端错误、服务端错误
🔸 错误创建：status.Error()简单创建，status.Errorf()格式化创建
🔸 错误解析：status.FromError()解析gRPC错误，获取状态码和消息
🔸 重试策略：只重试可恢复的错误，使用指数退避算法
🔸 超时机制：context.WithTimeout()设置超时，防止无限等待
🔸 取消机制：context.WithCancel()主动取消，节省资源
```

### 8.2 状态码选择指南


> 🎯 **记忆口诀**：客户端错误客户改，服务端错误服务改

```
客户端问题（4xx类似）：
- 参数不对 → InvalidArgument
- 找不到   → NotFound  
- 没权限   → PermissionDenied
- 重复了   → AlreadyExists

服务端问题（5xx类似）：
- 代码出错 → Internal
- 服务挂了 → Unavailable  
- 处理慢了 → DeadlineExceeded
```

### 8.3 最佳实践


**🔹 服务端最佳实践**
```
✅ 明确错误类型：选择合适的状态码
✅ 提供有用信息：错误消息要帮助调试
✅ 支持取消检查：长时间操作要检查ctx.Done()
✅ 记录错误日志：方便问题排查
```

**🔹 客户端最佳实践**
```
✅ 解析gRPC错误：使用status.FromError()
✅ 区分错误类型：根据状态码决定处理策略
✅ 合理重试：只重试可恢复的错误
✅ 设置超时：避免无限等待
✅ 用户友好提示：将技术错误转为用户易懂的信息
```

**🔹 错误处理流程**
```
1. 服务端：验证输入 → 处理业务 → 返回结果/错误
2. 客户端：发送请求 → 检查错误 → 重试/提示用户
3. 监控：记录错误率 → 分析错误类型 → 优化系统
```

### 8.4 实际应用价值


- **用户体验**：提供清晰的错误提示，用户知道怎么修正
- **系统稳定**：合理的重试和超时机制，避免雪崩效应  
- **问题排查**：详细的错误信息和上下文，快速定位问题
- **服务治理**：统一的错误处理规范，提升代码质量

**核心记忆**：
- gRPC错误就像生活中的问题分类，清楚说明出了什么事
- 状态码选择有规律：客户端问题客户改，服务端问题服务改  
- 重试要智能：只重试可能成功的，不要死磕到底
- 超时是必须：防止无限等待，及时释放资源