---
title: 3ã€è®¤è¯æˆæƒä¸å®‰å…¨æœºåˆ¶
---
## ğŸ“š ç›®å½•

1. [gRPCå®‰å…¨æ¦‚è¿°](#1-grpcå®‰å…¨æ¦‚è¿°)
2. [TLS/SSLä¼ è¾“åŠ å¯†](#2-tls-sslä¼ è¾“åŠ å¯†)
3. [è¯ä¹¦é…ç½®è¯¦è§£](#3-è¯ä¹¦é…ç½®è¯¦è§£)
4. [Tokenè®¤è¯æœºåˆ¶](#4-tokenè®¤è¯æœºåˆ¶)
5. [è‡ªå®šä¹‰è®¤è¯å®ç°](#5-è‡ªå®šä¹‰è®¤è¯å®ç°)
6. [metadataè®¤è¯ä¼ é€’](#6-metadataè®¤è¯ä¼ é€’)
7. [æ‹¦æˆªå™¨æƒé™æ ¡éªŒ](#7-æ‹¦æˆªå™¨æƒé™æ ¡éªŒ)
8. [å¼€å‘è°ƒè¯•æ¨¡å¼](#8-å¼€å‘è°ƒè¯•æ¨¡å¼)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ”’ gRPCå®‰å…¨æ¦‚è¿°


### 1.1 ä¸ºä»€ä¹ˆéœ€è¦å®‰å…¨æœºåˆ¶


**ç°å®é—®é¢˜**ï¼š
```
æ²¡æœ‰å®‰å…¨é˜²æŠ¤çš„é€šä¿¡å°±åƒï¼š
ğŸ“± æ‰‹æœºé€šè¯è¢«çªƒå¬
ğŸ’³ é“¶è¡Œå¡å¯†ç è¢«å·çœ‹
ğŸ“¦ å¿«é€’åŒ…è£¹è¢«æ‹†å¼€

gRPCé»˜è®¤ä¹Ÿæ˜¯æ˜æ–‡ä¼ è¾“ï¼Œéœ€è¦åŠ å¯†ä¿æŠ¤
```

**gRPCå®‰å…¨ä½“ç³»**ï¼š
```
ä¼ è¾“å±‚å®‰å…¨ â† TLS/SSLåŠ å¯†é€šé“
    â†“
è®¤è¯å±‚å®‰å…¨ â† èº«ä»½éªŒè¯ï¼ˆTokenã€JWTç­‰ï¼‰
    â†“  
æˆæƒå±‚å®‰å…¨ â† æƒé™æ§åˆ¶ï¼ˆæ‹¦æˆªå™¨æ ¡éªŒï¼‰
    â†“
åº”ç”¨å±‚å®‰å…¨ â† ä¸šåŠ¡é€»è¾‘éªŒè¯
```

### 1.2 å®‰å…¨æœºåˆ¶åˆ†ç±»


| å®‰å…¨å±‚é¢ | **ä½œç”¨** | **å®ç°æ–¹å¼** | **ä¿æŠ¤èŒƒå›´** |
|---------|---------|-------------|-------------|
| ğŸ” **ä¼ è¾“åŠ å¯†** | `æ•°æ®ä¼ è¾“åŠ å¯†` | `TLS/SSLè¯ä¹¦` | `é˜²æ­¢æ•°æ®è¢«çªƒå¬` |
| ğŸ« **èº«ä»½è®¤è¯** | `éªŒè¯å®¢æˆ·ç«¯èº«ä»½` | `Tokenã€JWTã€è¯ä¹¦` | `ç¡®ä¿è®¿é—®è€…åˆæ³•` |
| ğŸšª **æƒé™æ§åˆ¶** | `æ§åˆ¶è®¿é—®èŒƒå›´` | `æ‹¦æˆªå™¨ã€RBAC` | `é™åˆ¶æ“ä½œæƒé™` |
| ğŸ›¡ï¸ **æ•°æ®å®Œæ•´æ€§** | `é˜²æ­¢æ•°æ®ç¯¡æ”¹` | `æ•°å­—ç­¾åã€Hash` | `ç¡®ä¿æ•°æ®æœªè¢«ä¿®æ”¹` |

### 1.3 å®‰å…¨å¨èƒä¸é˜²æŠ¤


**å¸¸è§å¨èƒ**ï¼š
```
ğŸ•µï¸ çªƒå¬æ”»å‡» â†’ TLSåŠ å¯†è§£å†³
ğŸ­ èº«ä»½ä¼ªé€  â†’ è®¤è¯æœºåˆ¶è§£å†³  
ğŸ”§ æ•°æ®ç¯¡æ”¹ â†’ æ•°å­—ç­¾åè§£å†³
ğŸšª æœªæˆæƒè®¿é—® â†’ æƒé™æ§åˆ¶è§£å†³
```

---

## 2. ğŸ” TLS/SSLä¼ è¾“åŠ å¯†


### 2.1 TLSåŸºæœ¬æ¦‚å¿µ


**ä»€ä¹ˆæ˜¯TLSï¼Ÿ**
```
TLS (Transport Layer Security) = ä¼ è¾“å±‚å®‰å…¨åè®®
å°±åƒç»™æ•°æ®åŒ…è£¹åŠ ä¸Šå¯†ç é”ï¼Œåªæœ‰æœ‰é’¥åŒ™çš„äººæ‰èƒ½æ‰“å¼€

æ˜æ–‡é€šä¿¡ï¼š  å®¢æˆ·ç«¯ ----[hello world]----> æœåŠ¡ç«¯
TLSåŠ å¯†ï¼š   å®¢æˆ·ç«¯ ----[!@#$%^&*()]----> æœåŠ¡ç«¯
           (åˆ«äººçœ‹åˆ°çš„)              (æœåŠ¡ç«¯è§£å¯†åçœ‹åˆ°hello world)
```

### 2.2 å•å‘è®¤è¯ vs åŒå‘è®¤è¯


**å•å‘è®¤è¯ï¼ˆå¸¸ç”¨ï¼‰**ï¼š
```
åªéªŒè¯æœåŠ¡ç«¯èº«ä»½ï¼Œå°±åƒè®¿é—®é“¶è¡Œç½‘ç«™

å®¢æˆ·ç«¯ â†--[æˆ‘æ˜¯çœŸçš„é“¶è¡Œ]--è¯ä¹¦-- æœåŠ¡ç«¯
      â†‘                        â†‘
   éªŒè¯æœåŠ¡ç«¯èº«ä»½              æä¾›èº«ä»½è¯æ˜

ä½¿ç”¨åœºæ™¯ï¼šç½‘ç«™HTTPSã€APPè°ƒç”¨API
```

**åŒå‘è®¤è¯ï¼ˆé«˜å®‰å…¨ï¼‰**ï¼š
```
äº’ç›¸éªŒè¯èº«ä»½ï¼Œå°±åƒä¸¤ä¸ªé“¶è¡Œä¹‹é—´çš„è½¬è´¦

å®¢æˆ·ç«¯ â†--[æˆ‘æ˜¯Aé“¶è¡Œ]--è¯ä¹¦-- æœåŠ¡ç«¯
      â†“                   â†‘
   è¯ä¹¦--[æˆ‘æ˜¯Bé“¶è¡Œ]-->  éªŒè¯åŒæ–¹èº«ä»½

ä½¿ç”¨åœºæ™¯ï¼šé“¶è¡Œé—´é€šä¿¡ã€æ”¿åºœç³»ç»Ÿ
```

### 2.3 å•å‘è®¤è¯å®ç°


**ğŸ”§ æœåŠ¡ç«¯é…ç½®**ï¼š
```go
// ç”ŸæˆæœåŠ¡ç«¯TLSå‡­æ®
creds, err := credentials.NewServerTLSFromFile(
    "server.crt",  // æœåŠ¡ç«¯è¯ä¹¦æ–‡ä»¶
    "server.key",  // æœåŠ¡ç«¯ç§é’¥æ–‡ä»¶
)
if err != nil {
    log.Fatal("åŠ è½½TLSè¯ä¹¦å¤±è´¥:", err)
}

// åˆ›å»ºå®‰å…¨çš„gRPCæœåŠ¡å™¨
server := grpc.NewServer(grpc.Creds(creds))
```

**ğŸ”§ å®¢æˆ·ç«¯é…ç½®**ï¼š
```go
// å®¢æˆ·ç«¯éªŒè¯æœåŠ¡ç«¯è¯ä¹¦
creds, err := credentials.NewClientTLSFromFile(
    "server.crt",     // æœåŠ¡ç«¯è¯ä¹¦ï¼ˆç”¨äºéªŒè¯ï¼‰
    "localhost",      // æœåŠ¡ç«¯åŸŸå
)

// å»ºç«‹å®‰å…¨è¿æ¥
conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(creds))
```

### 2.4 åŒå‘è®¤è¯å®ç°


**ğŸ”§ æœåŠ¡ç«¯é…ç½®**ï¼š
```go
// åŠ è½½æœåŠ¡ç«¯è¯ä¹¦
cert, err := tls.LoadX509KeyPair("server.crt", "server.key")

// åŠ è½½å®¢æˆ·ç«¯CAè¯ä¹¦ï¼ˆç”¨äºéªŒè¯å®¢æˆ·ç«¯ï¼‰
clientCA, err := ioutil.ReadFile("client-ca.crt")
clientCertPool := x509.NewCertPool()
clientCertPool.AppendCertsFromPEM(clientCA)

// é…ç½®åŒå‘è®¤è¯
config := &tls.Config{
    Certificates: []tls.Certificate{cert},           // æœåŠ¡ç«¯è¯ä¹¦
    ClientAuth:   tls.RequireAndVerifyClientCert,    // è¦æ±‚å®¢æˆ·ç«¯è¯ä¹¦
    ClientCAs:    clientCertPool,                    // éªŒè¯å®¢æˆ·ç«¯çš„CA
}

creds := credentials.NewTLS(config)
server := grpc.NewServer(grpc.Creds(creds))
```

**ğŸ”§ å®¢æˆ·ç«¯é…ç½®**ï¼š
```go
// åŠ è½½å®¢æˆ·ç«¯è¯ä¹¦
clientCert, err := tls.LoadX509KeyPair("client.crt", "client.key")

// é…ç½®å®¢æˆ·ç«¯
config := &tls.Config{
    Certificates: []tls.Certificate{clientCert},  // å®¢æˆ·ç«¯è¯ä¹¦
    ServerName:   "localhost",                    // æœåŠ¡ç«¯åŸŸå
}

creds := credentials.NewTLS(config)
conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(creds))
```

---

## 3. ğŸ“œ è¯ä¹¦é…ç½®è¯¦è§£


### 3.1 è¯ä¹¦æ˜¯ä»€ä¹ˆ


**è¯ä¹¦å°±åƒèº«ä»½è¯**ï¼š
```
ç°å®èº«ä»½è¯ï¼š     æ•°å­—è¯ä¹¦ï¼š
å§“å: å¼ ä¸‰       æœåŠ¡å: api.example.com
èº«ä»½è¯å·: xxx    å…¬é’¥: xxx  
å‘è¯æœºå…³: å…¬å®‰å±€  ç­¾å‘æœºæ„: CAæœºæ„
æœ‰æ•ˆæœŸ: 20å¹´     æœ‰æ•ˆæœŸ: 1å¹´
```

### 3.2 è¯ä¹¦æ–‡ä»¶ç±»å‹


| æ–‡ä»¶ç±»å‹ | **ç”¨é€”** | **å†…å®¹** | **ä¸¾ä¾‹** |
|---------|---------|---------|---------|
| ğŸ“„ **.crt** | `è¯ä¹¦æ–‡ä»¶` | `å…¬é’¥+èº«ä»½ä¿¡æ¯` | `server.crt` |
| ğŸ”‘ **.key** | `ç§é’¥æ–‡ä»¶` | `ç§é’¥æ•°æ®` | `server.key` |
| ğŸ“‹ **.pem** | `é€šç”¨æ ¼å¼` | `è¯ä¹¦æˆ–ç§é’¥` | `bundle.pem` |
| ğŸ“¦ **.p12** | `è¯ä¹¦åŒ…` | `è¯ä¹¦+ç§é’¥æ‰“åŒ…` | `client.p12` |

### 3.3 ç”Ÿæˆæµ‹è¯•è¯ä¹¦


**ğŸ“ åˆ›å»ºè¯ä¹¦è„šæœ¬**ï¼š
```bash
#!/bin/bash
# ç”Ÿæˆæµ‹è¯•ç”¨çš„è‡ªç­¾åè¯ä¹¦

# 1. ç”Ÿæˆç§é’¥
openssl genrsa -out server.key 2048

# 2. ç”Ÿæˆè¯ä¹¦ç­¾åè¯·æ±‚
openssl req -new -key server.key -out server.csr \
    -subj "/C=CN/ST=Beijing/L=Beijing/O=MyCompany/CN=localhost"

# 3. ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
openssl x509 -req -in server.csr -signkey server.key \
    -out server.crt -days 365
```

### 3.4 è¯ä¹¦é…ç½®æœ€ä½³å®è·µ


**ğŸ”§ è¯ä¹¦è·¯å¾„ç®¡ç†**ï¼š
```go
type TLSConfig struct {
    CertDir    string  // è¯ä¹¦ç›®å½•
    ServerCert string  // æœåŠ¡ç«¯è¯ä¹¦
    ServerKey  string  // æœåŠ¡ç«¯ç§é’¥
    ClientCA   string  // å®¢æˆ·ç«¯CA
}

func LoadTLSConfig() *TLSConfig {
    return &TLSConfig{
        CertDir:    "./certs",
        ServerCert: "server.crt",
        ServerKey:  "server.key", 
        ClientCA:   "client-ca.crt",
    }
}

func (c *TLSConfig) GetServerCreds() (credentials.TransportCredentials, error) {
    certFile := filepath.Join(c.CertDir, c.ServerCert)
    keyFile := filepath.Join(c.CertDir, c.ServerKey)
    
    return credentials.NewServerTLSFromFile(certFile, keyFile)
}
```

---

## 4. ğŸ« Tokenè®¤è¯æœºåˆ¶


### 4.1 Tokenè®¤è¯æ¦‚å¿µ


**ä»€ä¹ˆæ˜¯Tokenï¼Ÿ**
```
Tokenå°±åƒæ¸¸ä¹å›­çš„æ‰‹ç¯ï¼š

è´­ç¥¨ â†’ è·å¾—æ‰‹ç¯(Token) â†’ å‡­æ‰‹ç¯è¿›å…¥å„ä¸ªé¡¹ç›®
ç™»å½• â†’ è·å¾—Token      â†’ å‡­Tokenè°ƒç”¨å„ä¸ªAPI

ç‰¹ç‚¹ï¼š
âœ… ä¸€æ¬¡è·å–ï¼Œå¤šæ¬¡ä½¿ç”¨
âœ… æœ‰æ—¶æ•ˆæ€§
âœ… åŒ…å«ç”¨æˆ·ä¿¡æ¯
```

### 4.2 JWT Tokenè¯¦è§£


**JWTç»“æ„**ï¼š
```
JWT = Header.Payload.Signature
     â†“        â†“        â†“
   ç®—æ³•ä¿¡æ¯  ç”¨æˆ·æ•°æ®   æ•°å­—ç­¾å

ç¤ºä¾‹ï¼š
eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.xxx
    â†‘              â†‘               â†‘
  Header         Payload       Signature
```

**ğŸ”§ JWTç”Ÿæˆç¤ºä¾‹**ï¼š
```go
import "github.com/golang-jwt/jwt/v4"

type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

func GenerateJWT(userID, username string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte("your-secret-key"))
}
```

### 4.3 API Keyè®¤è¯


**API Keyç‰¹ç‚¹**ï¼š
```
æ›´ç®€å•çš„è®¤è¯æ–¹å¼ï¼š

API Key: abc123def456
ä½¿ç”¨æ–¹å¼: åœ¨è¯·æ±‚å¤´æˆ–metadataä¸­æºå¸¦
é€‚ç”¨åœºæ™¯: æœåŠ¡é—´è°ƒç”¨ã€ç¬¬ä¸‰æ–¹é›†æˆ
```

**ğŸ”§ API Keyå®ç°**ï¼š
```go
type APIKeyAuth struct {
    Key string
}

func (a APIKeyAuth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
    return map[string]string{
        "api-key": a.Key,
    }, nil
}

func (a APIKeyAuth) RequireTransportSecurity() bool {
    return true  // è¦æ±‚ä½¿ç”¨TLS
}

// å®¢æˆ·ç«¯ä½¿ç”¨
conn, err := grpc.Dial("localhost:8080", 
    grpc.WithTransportCredentials(creds),
    grpc.WithPerRPCCredentials(APIKeyAuth{Key: "your-api-key"}),
)
```

---

## 5. ğŸ” è‡ªå®šä¹‰è®¤è¯å®ç°


### 5.1 è®¤è¯æ¥å£æ¦‚è¿°


**gRPCè®¤è¯æ¥å£**ï¼š
```
credentials.PerRPCCredentials æ¥å£ï¼š

type PerRPCCredentials interface {
    // è·å–è®¤è¯ä¿¡æ¯ï¼Œæ¯æ¬¡RPCè°ƒç”¨æ—¶æ‰§è¡Œ
    GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
    
    // æ˜¯å¦è¦æ±‚TLSä¼ è¾“
    RequireTransportSecurity() bool
}
```

### 5.2 è‡ªå®šä¹‰Tokenè®¤è¯


**ğŸ”§ å®ç°è‡ªå®šä¹‰è®¤è¯**ï¼š
```go
type CustomAuth struct {
    Token    string
    Username string
}

func (c CustomAuth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
    return map[string]string{
        "authorization": "Bearer " + c.Token,
        "user-agent":    "grpc-client-v1.0",
        "username":      c.Username,
    }, nil
}

func (c CustomAuth) RequireTransportSecurity() bool {
    return true  // å¼ºåˆ¶ä½¿ç”¨TLS
}

// ä½¿ç”¨ç¤ºä¾‹
auth := CustomAuth{
    Token:    "your-jwt-token",
    Username: "admin",
}

conn, err := grpc.Dial("localhost:8080",
    grpc.WithTransportCredentials(creds),
    grpc.WithPerRPCCredentials(auth),
)
```

### 5.3 åŠ¨æ€Tokenåˆ·æ–°


**ğŸ”„ è‡ªåŠ¨åˆ·æ–°Token**ï¼š
```go
type RefreshableAuth struct {
    mu          sync.RWMutex
    token       string
    refreshFunc func() (string, error)
    lastRefresh time.Time
    ttl         time.Duration
}

func (r *RefreshableAuth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
    r.mu.RLock()
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°
    if time.Since(r.lastRefresh) > r.ttl {
        r.mu.RUnlock()
        r.mu.Lock()
        
        // åŒé‡æ£€æŸ¥
        if time.Since(r.lastRefresh) > r.ttl {
            newToken, err := r.refreshFunc()
            if err != nil {
                r.mu.Unlock()
                return nil, fmt.Errorf("åˆ·æ–°tokenå¤±è´¥: %v", err)
            }
            r.token = newToken
            r.lastRefresh = time.Now()
        }
        r.mu.Unlock()
        r.mu.RLock()
    }
    
    token := r.token
    r.mu.RUnlock()
    
    return map[string]string{
        "authorization": "Bearer " + token,
    }, nil
}
```

---

## 6. ğŸ“¤ metadataè®¤è¯ä¼ é€’


### 6.1 metadataæ¦‚å¿µ


**ä»€ä¹ˆæ˜¯metadataï¼Ÿ**
```
metadataå°±åƒå¿«é€’åŒ…è£¹çš„æ ‡ç­¾ï¼š

åŒ…è£¹å†…å®¹ â† gRPCè¯·æ±‚æ•°æ®
åŒ…è£¹æ ‡ç­¾ â† metadataï¼ˆè®¤è¯ä¿¡æ¯ã€è¿½è¸ªIDç­‰ï¼‰

HTTPå¯¹æ¯”ï¼š
HTTP Header   â†â†’   gRPC Metadata
Content-Type  â†â†’   content-type
Authorization â†â†’   authorization
```

### 6.2 å®¢æˆ·ç«¯å‘é€è®¤è¯ä¿¡æ¯


**ğŸ”§ é€šè¿‡metadataä¼ é€’è®¤è¯**ï¼š
```go
import "google.golang.org/grpc/metadata"

func CallWithAuth(client pb.UserServiceClient) {
    // åˆ›å»ºå¸¦è®¤è¯ä¿¡æ¯çš„context
    md := metadata.Pairs(
        "authorization", "Bearer your-jwt-token",
        "user-id", "12345",
        "request-id", uuid.New().String(),
    )
    
    ctx := metadata.NewOutgoingContext(context.Background(), md)
    
    // å‘èµ·è°ƒç”¨
    resp, err := client.GetUser(ctx, &pb.GetUserRequest{
        UserId: "12345",
    })
}
```

**ğŸ”§ ä¾¿æ·çš„è®¤è¯å‡½æ•°**ï¼š
```go
func WithAuth(ctx context.Context, token string) context.Context {
    md := metadata.Pairs("authorization", "Bearer "+token)
    return metadata.NewOutgoingContext(ctx, md)
}

// ä½¿ç”¨
ctx := WithAuth(context.Background(), "your-token")
resp, err := client.GetUser(ctx, req)
```

### 6.3 æœåŠ¡ç«¯æ¥æ”¶è®¤è¯ä¿¡æ¯


**ğŸ”§ ä»metadataæå–è®¤è¯**ï¼š
```go
func extractToken(ctx context.Context) (string, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return "", fmt.Errorf("æ— æ³•è·å–metadata")
    }
    
    values := md.Get("authorization")
    if len(values) == 0 {
        return "", fmt.Errorf("ç¼ºå°‘authorization header")
    }
    
    auth := values[0]
    if !strings.HasPrefix(auth, "Bearer ") {
        return "", fmt.Errorf("æ— æ•ˆçš„authorizationæ ¼å¼")
    }
    
    return strings.TrimPrefix(auth, "Bearer "), nil
}

// åœ¨æœåŠ¡æ–¹æ³•ä¸­ä½¿ç”¨
func (s *UserService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    token, err := extractToken(ctx)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, err.Error())
    }
    
    // éªŒè¯token
    userID, err := validateToken(token)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "æ— æ•ˆtoken")
    }
    
    // å¤„ç†ä¸šåŠ¡é€»è¾‘...
}
```

---

## 7. ğŸ›¡ï¸ æ‹¦æˆªå™¨æƒé™æ ¡éªŒ


### 7.1 æ‹¦æˆªå™¨æ¦‚å¿µ


**æ‹¦æˆªå™¨å°±åƒå®‰æ£€é—¨**ï¼š
```
æœºåœºå®‰æ£€æµç¨‹ï¼š         gRPCæ‹¦æˆªå™¨ï¼š
                      
ä¹˜å®¢ â†’ å®‰æ£€é—¨ â†’ ç™»æœº     è¯·æ±‚ â†’ æ‹¦æˆªå™¨ â†’ æœåŠ¡æ–¹æ³•
       â†“                     â†“
   èº«ä»½éªŒè¯              æƒé™æ ¡éªŒ
   å®‰å…¨æ£€æŸ¥              æ—¥å¿—è®°å½•
   è¡Œææ‰«æ              å‚æ•°éªŒè¯
```

### 7.2 ä¸€å…ƒæ‹¦æˆªå™¨è®¤è¯


**ğŸ”§ æœåŠ¡ç«¯è®¤è¯æ‹¦æˆªå™¨**ï¼š
```go
func AuthUnaryInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    // 1. æå–è®¤è¯ä¿¡æ¯
    token, err := extractToken(ctx)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "è®¤è¯å¤±è´¥: "+err.Error())
    }
    
    // 2. éªŒè¯token
    claims, err := validateJWT(token)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "tokenæ— æ•ˆ")
    }
    
    // 3. æ£€æŸ¥æƒé™
    if !hasPermission(claims.UserID, info.FullMethod) {
        return nil, status.Error(codes.PermissionDenied, "æƒé™ä¸è¶³")
    }
    
    // 4. å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°context
    ctx = context.WithValue(ctx, "user_id", claims.UserID)
    ctx = context.WithValue(ctx, "username", claims.Username)
    
    // 5. ç»§ç»­æ‰§è¡ŒåŸæ–¹æ³•
    return handler(ctx, req)
}

// æ³¨å†Œæ‹¦æˆªå™¨
server := grpc.NewServer(
    grpc.UnaryInterceptor(AuthUnaryInterceptor),
)
```

### 7.3 æµå¼æ‹¦æˆªå™¨è®¤è¯


**ğŸ”§ æµå¼è®¤è¯æ‹¦æˆªå™¨**ï¼š
```go
func AuthStreamInterceptor(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
    // è®¤è¯é€»è¾‘
    token, err := extractToken(ss.Context())
    if err != nil {
        return status.Error(codes.Unauthenticated, "è®¤è¯å¤±è´¥")
    }
    
    claims, err := validateJWT(token)
    if err != nil {
        return status.Error(codes.Unauthenticated, "tokenæ— æ•ˆ")
    }
    
    // åŒ…è£…ServerStreamï¼Œæ·»åŠ ç”¨æˆ·ä¿¡æ¯
    wrappedStream := &AuthServerStream{
        ServerStream: ss,
        userID:       claims.UserID,
    }
    
    return handler(srv, wrappedStream)
}

type AuthServerStream struct {
    grpc.ServerStream
    userID string
}

func (s *AuthServerStream) Context() context.Context {
    ctx := s.ServerStream.Context()
    return context.WithValue(ctx, "user_id", s.userID)
}
```

### 7.4 æƒé™æ§åˆ¶å®ç°


**ğŸ”§ åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶**ï¼š
```go
type Permission struct {
    Service string   // æœåŠ¡å
    Method  string   // æ–¹æ³•å
    Roles   []string // å…è®¸çš„è§’è‰²
}

var permissions = []Permission{
    {Service: "UserService", Method: "GetUser", Roles: []string{"user", "admin"}},
    {Service: "UserService", Method: "DeleteUser", Roles: []string{"admin"}},
    {Service: "OrderService", Method: "CreateOrder", Roles: []string{"user", "admin"}},
}

func hasPermission(userID, fullMethod string) bool {
    // 1. è·å–ç”¨æˆ·è§’è‰²
    userRoles := getUserRoles(userID)
    
    // 2. è§£ææ–¹æ³•å
    parts := strings.Split(fullMethod, "/")
    if len(parts) != 3 {
        return false
    }
    service := parts[1]
    method := parts[2]
    
    // 3. æ£€æŸ¥æƒé™
    for _, perm := range permissions {
        if perm.Service == service && perm.Method == method {
            for _, userRole := range userRoles {
                for _, allowedRole := range perm.Roles {
                    if userRole == allowedRole {
                        return true
                    }
                }
            }
            return false
        }
    }
    
    return false  // é»˜è®¤æ‹’ç»
}
```

---

## 8. ğŸ”§ å¼€å‘è°ƒè¯•æ¨¡å¼


### 8.1 insecureè¿æ¥


**ä»€ä¹ˆæ—¶å€™ä½¿ç”¨insecureï¼Ÿ**
```
âœ… æœ¬åœ°å¼€å‘æµ‹è¯•
âœ… å†…ç½‘ç¯å¢ƒï¼ˆå·²æœ‰å…¶ä»–å®‰å…¨æªæ–½ï¼‰
âœ… æ€§èƒ½æµ‹è¯•ï¼ˆé¿å…åŠ å¯†å¼€é”€ï¼‰

âŒ ç”Ÿäº§ç¯å¢ƒ
âŒ å…¬ç½‘é€šä¿¡
âŒ æ•æ„Ÿæ•°æ®ä¼ è¾“
```

**ğŸ”§ å®¢æˆ·ç«¯insecureè¿æ¥**ï¼š
```go
// ä¸å®‰å…¨è¿æ¥ï¼ˆä»…å¼€å‘ä½¿ç”¨ï¼‰
conn, err := grpc.Dial("localhost:8080", grpc.WithInsecure())

// æ–°ç‰ˆæœ¬å†™æ³•
conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(insecure.NewCredentials()))
```

### 8.2 ç¯å¢ƒé…ç½®ç®¡ç†


**ğŸ”§ é…ç½®æ–‡ä»¶ç®¡ç†**ï¼š
```go
type Config struct {
    Server struct {
        Port     int    `yaml:"port"`
        TLSEnabled bool `yaml:"tls_enabled"`
        CertFile string `yaml:"cert_file"`
        KeyFile  string `yaml:"key_file"`
    } `yaml:"server"`
    
    Auth struct {
        Enabled   bool   `yaml:"enabled"`
        JWTSecret string `yaml:"jwt_secret"`
    } `yaml:"auth"`
}

func NewServer(config *Config) *grpc.Server {
    var opts []grpc.ServerOption
    
    // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦å¯ç”¨TLS
    if config.Server.TLSEnabled {
        creds, err := credentials.NewServerTLSFromFile(
            config.Server.CertFile,
            config.Server.KeyFile,
        )
        if err != nil {
            log.Fatal("TLSé…ç½®å¤±è´¥:", err)
        }
        opts = append(opts, grpc.Creds(creds))
    }
    
    // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦å¯ç”¨è®¤è¯
    if config.Auth.Enabled {
        opts = append(opts, grpc.UnaryInterceptor(AuthUnaryInterceptor))
    }
    
    return grpc.NewServer(opts...)
}
```

### 8.3 è°ƒè¯•å·¥å…·


**ğŸ”§ è®¤è¯è°ƒè¯•è¾…åŠ©**ï¼š
```go
func DebugMetadata(ctx context.Context) {
    if md, ok := metadata.FromIncomingContext(ctx); ok {
        fmt.Println("=== æ¥æ”¶åˆ°çš„Metadata ===")
        for k, v := range md {
            fmt.Printf("%s: %v\n", k, v)
        }
        fmt.Println("======================")
    }
}

// åœ¨æœåŠ¡æ–¹æ³•ä¸­ä½¿ç”¨
func (s *UserService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    if os.Getenv("DEBUG") == "true" {
        DebugMetadata(ctx)
    }
    // ... ä¸šåŠ¡é€»è¾‘
}
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ¦‚å¿µ


```
ğŸ”¸ TLS/SSLï¼šä¼ è¾“å±‚åŠ å¯†ï¼Œä¿æŠ¤æ•°æ®ä¼ è¾“å®‰å…¨
ğŸ”¸ å•å‘è®¤è¯ï¼šåªéªŒè¯æœåŠ¡ç«¯èº«ä»½ï¼ˆå¸¸ç”¨ï¼‰
ğŸ”¸ åŒå‘è®¤è¯ï¼šäº’ç›¸éªŒè¯èº«ä»½ï¼ˆé«˜å®‰å…¨åœºæ™¯ï¼‰
ğŸ”¸ Tokenè®¤è¯ï¼šé€šè¿‡ä»¤ç‰ŒéªŒè¯èº«ä»½ï¼ˆJWTã€API Keyï¼‰
ğŸ”¸ metadataï¼šæºå¸¦è®¤è¯ä¿¡æ¯çš„å®¹å™¨
ğŸ”¸ æ‹¦æˆªå™¨ï¼šç»Ÿä¸€çš„è®¤è¯å’Œæˆæƒå…¥å£
```

### 9.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ è®¤è¯vsæˆæƒ**ï¼š
```
è®¤è¯(Authentication)ï¼šä½ æ˜¯è°ï¼Ÿ
- éªŒè¯èº«ä»½çœŸå®æ€§
- é€šè¿‡ç”¨æˆ·åå¯†ç ã€è¯ä¹¦ã€Tokenç­‰

æˆæƒ(Authorization)ï¼šä½ èƒ½åšä»€ä¹ˆï¼Ÿ
- éªŒè¯æ“ä½œæƒé™
- é€šè¿‡è§’è‰²ã€æƒé™åˆ—è¡¨ç­‰
```

**ğŸ”¹ å®‰å…¨å±‚æ¬¡**ï¼š
```
ä¼ è¾“å®‰å…¨ â†’ TLSåŠ å¯†é€šé“
èº«ä»½å®‰å…¨ â†’ Token/è¯ä¹¦è®¤è¯  
æƒé™å®‰å…¨ â†’ æ‹¦æˆªå™¨æ ¡éªŒ
æ•°æ®å®‰å…¨ â†’ ä¸šåŠ¡é€»è¾‘éªŒè¯
```

**ğŸ”¹ è¯ä¹¦ç®¡ç†**ï¼š
```
å¼€å‘ç¯å¢ƒï¼šè‡ªç­¾åè¯ä¹¦ï¼Œinsecureè¿æ¥
æµ‹è¯•ç¯å¢ƒï¼šå†…éƒ¨CAç­¾å‘è¯ä¹¦
ç”Ÿäº§ç¯å¢ƒï¼šæƒå¨CAç­¾å‘è¯ä¹¦ï¼Œä¸¥æ ¼éªŒè¯
```

### 9.3 æœ€ä½³å®è·µ


**ğŸ›¡ï¸ å®‰å…¨é…ç½®å»ºè®®**ï¼š
```
âœ… ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨TLS
âœ… Tokenè®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´
âœ… ä½¿ç”¨æ‹¦æˆªå™¨ç»Ÿä¸€è®¤è¯é€»è¾‘
âœ… è®°å½•è®¤è¯å¤±è´¥çš„å®¡è®¡æ—¥å¿—
âœ… å®šæœŸè½®æ¢å¯†é’¥å’Œè¯ä¹¦
```

**âš ï¸ å¸¸è§é™·é˜±**ï¼š
```
âŒ åœ¨æ—¥å¿—ä¸­æ‰“å°æ•æ„Ÿä¿¡æ¯ï¼ˆTokenã€å¯†ç ï¼‰
âŒ ç¡¬ç¼–ç å¯†é’¥å’Œè¯ä¹¦è·¯å¾„
âŒ å¿½ç•¥è¯ä¹¦æœ‰æ•ˆæœŸç®¡ç†
âŒ åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨insecureè¿æ¥
âŒ è®¤è¯ä¿¡æ¯é€šè¿‡URLå‚æ•°ä¼ é€’
```

### 9.4 å®é™…åº”ç”¨åœºæ™¯


- **å¾®æœåŠ¡æ¶æ„**ï¼šæœåŠ¡é—´è®¤è¯ï¼Œç»Ÿä¸€èº«ä»½ç®¡ç†
- **APIç½‘å…³**ï¼šç»Ÿä¸€è®¤è¯å…¥å£ï¼ŒTokenç®¡ç†
- **ä¼ä¸šç³»ç»Ÿ**ï¼šåŒå‘è¯ä¹¦è®¤è¯ï¼Œä¸¥æ ¼æƒé™æ§åˆ¶
- **ç§»åŠ¨åº”ç”¨**ï¼šJWT Tokenè®¤è¯ï¼Œè‡ªåŠ¨åˆ·æ–°æœºåˆ¶
- **ç¬¬ä¸‰æ–¹é›†æˆ**ï¼šAPI Keyè®¤è¯ï¼Œè®¿é—®æ§åˆ¶

**æ ¸å¿ƒè®°å¿†**ï¼š
- TLSä¿æŠ¤ä¼ è¾“é€šé“ï¼ŒTokenéªŒè¯è®¿é—®èº«ä»½
- metadataä¼ é€’è®¤è¯ä¿¡æ¯ï¼Œæ‹¦æˆªå™¨ç»Ÿä¸€æ ¡éªŒ
- å¼€å‘å¯ç”¨insecureï¼Œç”Ÿäº§å¿…é¡»ç”¨TLS
- è®¤è¯è§£å†³"ä½ æ˜¯è°"ï¼Œæˆæƒè§£å†³"èƒ½åšå•¥"