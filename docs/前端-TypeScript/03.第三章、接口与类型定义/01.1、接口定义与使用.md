---
title: 1、接口定义与使用
---
## 📚 目录

1. [接口的本质理解](#1-接口的本质理解)
2. [interface基础语法](#2-interface基础语法)
3. [可选属性与只读属性](#3-可选属性与只读属性)
4. [函数接口定义](#4-函数接口定义)
5. [索引签名与动态属性](#5-索引签名与动态属性)
6. [接口继承与扩展](#6-接口继承与扩展)
7. [接口合并机制](#7-接口合并机制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 接口的本质理解


### 1.1 什么是接口


**通俗理解**：接口就像是一张**合同**或**规格书**，规定了对象应该有哪些属性和方法。

```
生活中的例子：
手机接口规格 = {
  品牌: string,
  型号: string,
  屏幕尺寸: number,
  打电话(): void,
  发短信(): void
}

任何符合这个规格的都算是手机！
```

**核心作用**：
- ✅ **约束对象结构**：规定对象必须有哪些属性
- ✅ **代码提示**：编辑器知道对象有什么属性，提供智能提示
- ✅ **类型检查**：TypeScript 帮你检查对象是否符合接口要求
- ✅ **团队协作**：大家按照同一个"合同"写代码

### 1.2 接口 vs 普通对象


```typescript
// ❌ 没有接口：不知道 user 对象应该有什么属性
const user = {
  name: "张三",
  age: 25
}

// ✅ 有接口：清楚知道 User 对象的结构
interface User {
  name: string;
  age: number;
}

const user: User = {
  name: "张三",
  age: 25
}
```

---

## 2. 📝 interface基础语法


### 2.1 基本定义方式


```typescript
// 最简单的接口定义
interface Person {
  name: string;
  age: number;
}

// 使用接口
const person: Person = {
  name: "李四",
  age: 30
}
```

### 2.2 接口命名规范


```typescript
// ✅ 推荐：首字母大写，语义清晰
interface User { }
interface UserProfile { }
interface ApiResponse { }

// ❌ 不推荐
interface user { }        // 首字母小写
interface IUser { }       // 匈牙利命名法过时了
interface userInfo { }    // 驼峰但首字母小写
```

### 2.3 多种属性类型


```typescript
interface Product {
  id: number;           // 数字类型
  name: string;         // 字符串类型
  price: number;        // 价格
  inStock: boolean;     // 是否有库存
  tags: string[];       // 标签数组
  category: {           // 嵌套对象
    id: number;
    name: string;
  };
}
```

---

## 3. ⚙️ 可选属性与只读属性


### 3.1 可选属性：? 修饰符


**问题**：有些属性不是必须的，比如用户的头像、电话号码等。

```typescript
interface User {
  name: string;        // 必须有
  age: number;         // 必须有
  avatar?: string;     // 可选：可能有头像，也可能没有
  phone?: string;      // 可选：可能有电话，也可能没有
}

// ✅ 这些都是合法的
const user1: User = {
  name: "张三",
  age: 25
  // 没有 avatar 和 phone 也可以
}

const user2: User = {
  name: "李四", 
  age: 30,
  avatar: "avatar.jpg"
  // 只有 avatar，没有 phone 也可以
}
```

### 3.2 只读属性：readonly 修饰符


**用途**：有些属性一旦设置就不能修改，比如用户ID、创建时间等。

```typescript
interface User {
  readonly id: string;        // 只读：不能修改
  readonly createdAt: Date;   // 只读：创建时间
  name: string;               // 可修改
  age: number;                // 可修改
}

const user: User = {
  id: "user001",
  createdAt: new Date(),
  name: "张三",
  age: 25
}

// ✅ 可以修改普通属性
user.name = "李四";
user.age = 30;

// ❌ 不能修改只读属性
user.id = "user002";         // 报错！
user.createdAt = new Date(); // 报错！
```

### 3.3 属性修饰符组合


```typescript
interface Article {
  readonly id: string;          // 只读 + 必须
  readonly createdAt: Date;     // 只读 + 必须
  title: string;                // 必须
  content?: string;             // 可选
  readonly publishedAt?: Date;  // 只读 + 可选
}
```

---

## 4. 🔧 函数接口定义


### 4.1 函数类型接口


**问题**：如何约束函数的参数和返回值类型？

```typescript
// 定义函数接口
interface Calculator {
  (a: number, b: number): number;
}

// 实现函数
const add: Calculator = (x, y) => {
  return x + y;
}

const multiply: Calculator = (x, y) => {
  return x * y;
}

// 使用
console.log(add(2, 3));      // 5
console.log(multiply(4, 5)); // 20
```

### 4.2 对象中的方法定义


```typescript
interface User {
  name: string;
  age: number;
  
  // 方法定义方式1：函数类型
  greet(): string;
  
  // 方法定义方式2：属性 + 函数类型
  say: (message: string) => void;
  
  // 方法定义方式3：带参数的方法
  updateAge(newAge: number): void;
}

const user: User = {
  name: "张三",
  age: 25,
  
  greet() {
    return `Hello, I'm ${this.name}`;
  },
  
  say: (message) => {
    console.log(message);
  },
  
  updateAge(newAge) {
    this.age = newAge;
  }
}
```

### 4.3 复杂函数接口


```typescript
// API 请求函数接口
interface ApiFunction {
  <T>(url: string, data?: any): Promise<T>;
}

// 事件处理函数接口  
interface EventHandler {
  (event: {
    type: string;
    target: any;
    timestamp: number;
  }): void;
}
```

---

## 5. 📚 索引签名与动态属性


### 5.1 什么是索引签名


**问题**：有时候我们不知道对象会有哪些属性名，但知道属性类型。

```typescript
// 用户配置对象：不知道有哪些配置项，但知道都是字符串值
interface UserConfig {
  [key: string]: string;
}

const config: UserConfig = {
  theme: "dark",
  language: "zh-CN", 
  fontSize: "14px",
  // 可以随意添加更多字符串类型的属性
  backgroundColor: "white"
}
```

### 5.2 常见索引签名类型


```typescript
// 字符串索引
interface StringMap {
  [key: string]: string;
}

// 数字索引  
interface NumberArray {
  [index: number]: number;
}

// 混合类型索引
interface MixedData {
  [key: string]: string | number | boolean;
}

const data: MixedData = {
  name: "张三",      // string
  age: 25,          // number
  isActive: true    // boolean
}
```

### 5.3 索引签名 + 确定属性


```typescript
interface User {
  // 确定的属性
  id: string;
  name: string;
  
  // 动态属性：其他任意属性都是字符串
  [key: string]: string;
}

const user: User = {
  id: "001",
  name: "张三",
  phone: "13800138000",    // 动态属性
  email: "zhang@qq.com",   // 动态属性
  address: "北京市"        // 动态属性
}
```

### 5.4 实际应用场景


```typescript
// 表单数据
interface FormData {
  [fieldName: string]: string | number | boolean;
}

// API 响应
interface ApiResponse {
  code: number;
  message: string;
  data: {
    [key: string]: any;  // 数据部分结构不确定
  };
}

// 本地存储
interface LocalStorage {
  [key: string]: string;
}
```

---

## 6. 🔗 接口继承与扩展


### 6.1 基本继承语法


**理解**：就像儿子继承父亲的财产一样，子接口继承父接口的所有属性。

```typescript
// 基础接口：动物
interface Animal {
  name: string;
  age: number;
}

// 继承接口：狗（继承了动物的所有属性）
interface Dog extends Animal {
  breed: string;    // 新增：品种
  bark(): void;     // 新增：叫的方法
}

const myDog: Dog = {
  name: "旺财",      // 继承自 Animal
  age: 3,           // 继承自 Animal  
  breed: "哈士奇",   // Dog 新增的
  bark() {          // Dog 新增的
    console.log("汪汪汪");
  }
}
```

### 6.2 多继承


```typescript
// 接口1：可以飞的
interface Flyable {
  fly(): void;
  altitude: number;
}

// 接口2：可以游泳的
interface Swimmable {
  swim(): void;
  depth: number;
}

// 多继承：鸭子既能飞又能游泳
interface Duck extends Flyable, Swimmable {
  quack(): void;
}

const duck: Duck = {
  fly() { console.log("飞翔中..."); },
  altitude: 100,
  swim() { console.log("游泳中..."); },
  depth: 5,
  quack() { console.log("嘎嘎嘎"); }
}
```

### 6.3 继承中的属性覆盖


```typescript
interface Vehicle {
  brand: string;
  speed: number;
}

interface Car extends Vehicle {
  // 可以让类型更具体
  speed: 60 | 80 | 100;  // 限制为特定速度
  doors: number;
}

const car: Car = {
  brand: "奔驰",
  speed: 80,        // 必须是 60、80、100 中的一个
  doors: 4
}
```

---

## 7. 🔄 接口合并机制


### 7.1 什么是接口合并


**理解**：当你定义了多个同名接口时，TypeScript 会自动把它们合并成一个。

```typescript
// 第一次定义 User 接口
interface User {
  name: string;
  age: number;
}

// 第二次定义 User 接口（同名）
interface User {
  email: string;
  phone?: string;
}

// TypeScript 自动合并为：
// interface User {
//   name: string;
//   age: number;
//   email: string;
//   phone?: string;
// }

const user: User = {
  name: "张三",
  age: 25,
  email: "zhang@qq.com",   // 必须有，来自第二个定义
  phone: "13800138000"     // 可选，来自第二个定义
}
```

### 7.2 接口合并的实际用途


**扩展第三方库的类型**：

```typescript
// 假设第三方库定义了 Window 接口
interface Window {
  document: Document;
}

// 我们可以扩展它，添加自己的属性
interface Window {
  myCustomProperty: string;
  myCustomMethod(): void;
}

// 现在 window 对象就有了我们添加的属性
window.myCustomProperty = "hello";
window.myCustomMethod = () => console.log("自定义方法");
```

### 7.3 接口合并注意事项


```typescript
interface Config {
  timeout: number;
}

interface Config {
  timeout: string;  // ❌ 错误！同名属性类型冲突
}

// ✅ 正确的做法：保持同名属性类型一致
interface Config {
  timeout: number;  // 类型一致
  retries: number;  // 新增属性
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的概念


```
🔸 接口本质：对象结构的"合同"，规定对象应该有什么属性
🔸 基础语法：interface 名称 { 属性: 类型; }
🔸 可选属性：属性名? 表示可有可无
🔸 只读属性：readonly 属性名 表示不能修改
🔸 函数接口：约束函数的参数和返回值类型
🔸 索引签名：[key: string]: 类型 表示动态属性
🔸 接口继承：extends 复用其他接口的属性
🔸 接口合并：同名接口自动合并
```

### 8.2 实际应用指南


**什么时候用接口**：
- ✅ **定义对象结构**：用户信息、商品信息、配置对象等
- ✅ **约束函数类型**：API 函数、事件处理函数等  
- ✅ **组件 Props**：React/Vue 组件的属性类型
- ✅ **API 数据格式**：接口返回的数据结构

**接口设计原则**：
- 🎯 **语义清晰**：接口名要能表达其用途
- 🎯 **属性合理**：必须的用必选，可能没有的用可选
- 🎯 **类型准确**：string、number、boolean 要准确
- 🎯 **适度抽象**：不要过度设计，够用就好

### 8.3 常见应用模式


```typescript
// 模式1：基础数据接口
interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
}

// 模式2：API 响应接口
interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// 模式3：组件 Props 接口
interface ButtonProps {
  text: string;
  onClick: () => void;
  disabled?: boolean;
  type?: 'primary' | 'secondary';
}

// 模式4：配置对象接口
interface AppConfig {
  apiUrl: string;
  timeout: number;
  [key: string]: any;  // 其他配置项
}
```

**核心记忆**：
- 接口就像合同，规定对象的结构
- ? 表示可选，readonly 表示只读
- extends 继承父接口的所有属性  
- 同名接口会自动合并
- 多用接口，少用 any，代码更安全