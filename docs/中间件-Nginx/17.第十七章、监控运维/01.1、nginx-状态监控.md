---
title: 1、nginx-状态监控
---
## 📚 目录

1. [什么是Nginx状态监控](#1-什么是nginx状态监控)
2. [stub_status模块详解](#2-stub_status模块详解)
3. [连接状态统计解读](#3-连接状态统计解读)
4. [监控配置与实践](#4-监控配置与实践)
5. [数据收集与可视化](#5-数据收集与可视化)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 什么是Nginx状态监控


### 1.1 监控的重要性


想象一下，你开了一家餐厅，但从来不知道：
- 今天来了多少客人？
- 有多少客人在排队等位？
- 服务员是不是太忙了？
- 哪个时间段最繁忙？

**这就是没有监控的Nginx服务器** - 你不知道它的运行状况！

**🎯 监控解决的核心问题：**
```
运维困惑：
❓ 服务器负载高不高？
❓ 有多少用户在访问？
❓ 哪些页面最受欢迎？
❓ 什么时候需要扩容？

监控回答：
✅ 实时连接数和请求量
✅ 服务器处理能力状况
✅ 访问模式和趋势分析
✅ 性能瓶颈及时发现
```

### 1.2 Nginx监控的核心价值


**📊 就像汽车仪表盘一样重要：**
```
汽车仪表盘              Nginx监控面板
┌─────────────┐        ┌─────────────────┐
│ 速度: 80km/h │        │ 当前连接: 245   │
│ 油量: ▓▓▓░░ │        │ 请求量: 1.2k/s  │
│ 水温: 正常   │        │ 处理状态: 正常  │
│ 转速: 2000rpm│        │ 错误率: 0.01%   │
└─────────────┘        └─────────────────┘

没有仪表盘 = 盲开车      没有监控 = 盲运维
```

**🔸 监控带来的好处：**
- **及时发现问题**：服务异常第一时间知道
- **性能优化指导**：基于数据做决策
- **容量规划**：知道什么时候需要扩容
- **故障排查**：快速定位问题根源

---

## 2. 🛠️ stub_status模块详解


### 2.1 什么是stub_status模块


**简单理解：** `stub_status`就像是Nginx内置的"体检报告生成器"

**🔸 核心作用：**
```
Nginx内部运行状态
        ↓
   stub_status模块
        ↓
   生成状态报告
        ↓
   通过HTTP页面展示
```

**📋 模块提供的信息：**
- 当前活跃连接数
- 总共处理的连接数
- 总共处理的请求数
- 当前读写等待状态

### 2.2 检查模块是否可用


**首先确认模块已编译：**
```bash
# 检查Nginx编译选项
nginx -V 2>&1 | grep -o with-http_stub_status_module

# 如果有输出，说明模块可用
# 如果没有输出，需要重新编译Nginx
```

**🔸 大部分现代Nginx都默认包含此模块**

### 2.3 基础配置示例


**最简单的配置：**
```nginx
server {
    listen 80;
    server_name localhost;
    
    # 状态监控页面
    location /nginx_status {
        stub_status on;           # 启用状态页面
        access_log off;          # 不记录访问日志
        allow 127.0.0.1;         # 只允许本机访问
        deny all;                # 拒绝其他IP
    }
}
```

**🔒 安全配置说明：**
```
为什么要限制访问？
• 状态信息属于敏感数据
• 可能暴露服务器负载情况
• 被恶意利用进行攻击分析

安全措施：
• 限制访问IP（白名单）
• 设置访问密码
• 使用内网地址
• 关闭访问日志记录
```

---

## 3. 📈 连接状态统计解读


### 3.1 状态页面内容解析


**访问状态页面看到的内容：**
```
Active connections: 291 
server accepts handled requests
 16630948 16630948 31070465 
Reading: 6 Writing: 179 Waiting: 106 
```

**🔍 逐行详细解释：**

### 3.2 Active connections详解


```
Active connections: 291
```

**含义：** 当前正在处理的连接数

**生活化理解：**
```
想象一个银行营业厅：
• Active connections = 正在办业务的客户数量
• 包括正在排队、正在办理、刚办完还没走的客户
• 数字越大说明银行越繁忙
```

**🎯 重要指标意义：**
- **正常情况**：数值相对稳定，有一定波动
- **异常情况**：突然暴增可能是攻击或故障
- **优化参考**：长期过高需要考虑扩容

### 3.3 三个核心统计数据


```
server accepts handled requests
 16630948 16630948 31070465
```

**📊 数据解读表：**

| 位置 | 名称 | 含义 | 生活化比喻 |
|------|------|------|-----------|
| **第1个** | `accepts` | 总共接受的连接数 | 银行开业以来接待的客户总数 |
| **第2个** | `handled` | 总共处理的连接数 | 银行实际服务的客户总数 |
| **第3个** | `requests` | 总共处理的请求数 | 银行处理的业务总笔数 |

**🔸 关键关系分析：**
```
健康状态判断：
accepts = handled  →  正常（所有连接都被处理）
accepts > handled  →  异常（有连接被拒绝）

请求效率分析：
requests ÷ handled = 平均每个连接的请求数
例：31070465 ÷ 16630948 ≈ 1.87 个请求/连接
```

### 3.4 当前连接状态分布


```
Reading: 6 Writing: 179 Waiting: 106
```

**🔍 状态详细说明：**

**Reading（读取中）：**
```
含义：Nginx正在读取客户端请求头
类比：服务员正在听客户点菜
特点：
• 通常数值较小
• 持续时间很短
• 数值过大可能是慢攻击
```

**Writing（写入中）：**
```
含义：Nginx正在向客户端发送响应
类比：服务员正在上菜给客户
特点：
• 通常是最大的数值
• 包括发送静态文件、动态内容
• 数值大说明有大量数据传输
```

**Waiting（等待中）：**
```
含义：保持连接但暂时空闲的连接
类比：客户吃完饭还坐在桌子旁聊天
特点：
• 长连接特征（Keep-Alive）
• 可以复用处理新请求
• 数值过大可能需要调整超时设置
```

### 3.5 数据计算验证


**验证公式：**
```
Active connections = Reading + Writing + Waiting

验证示例：
291 = 6 + 179 + 106 = 291 ✓

如果不相等，说明数据获取时有瞬间变化
```

---

## 4. ⚙️ 监控配置与实践


### 4.1 生产环境安全配置


**完整的安全配置示例：**
```nginx
upstream backend {
    server 127.0.0.1:8080;
    server 127.0.0.1:8081;
}

server {
    listen 80;
    server_name monitor.example.com;
    
    # 基础认证配置
    location /nginx_status {
        stub_status on;
        access_log off;
        
        # IP白名单（多个管理员IP）
        allow 192.168.1.100;    # 运维主机
        allow 192.168.1.101;    # 监控服务器
        allow 10.0.0.0/8;       # 内网段
        deny all;
        
        # HTTP基础认证
        auth_basic "Nginx Status";
        auth_basic_user_file /etc/nginx/passwd;
    }
    
    # 扩展状态信息
    location /nginx_info {
        stub_status on;
        access_log off;
        allow 127.0.0.1;
        deny all;
        
        # 添加响应头方便监控系统识别
        add_header Content-Type text/plain;
        add_header Cache-Control no-cache;
    }
}
```

**🔐 创建密码文件：**
```bash
# 安装htpasswd工具
sudo apt-get install apache2-utils  # Ubuntu/Debian
sudo yum install httpd-tools         # CentOS/RHEL

# 创建密码文件
sudo htpasswd -c /etc/nginx/passwd admin
# 输入密码：输入你想设置的密码

# 添加更多用户
sudo htpasswd /etc/nginx/passwd monitor
```

### 4.2 多样化状态展示


**JSON格式输出配置：**
```nginx
location /nginx_status/json {
    stub_status on;
    access_log off;
    allow 192.168.1.0/24;
    deny all;
    
    # 通过Lua脚本转换为JSON（需要lua模块）
    content_by_lua_block {
        local status = ngx.location.capture("/nginx_status")
        -- JSON格式化代码
        ngx.header.content_type = "application/json"
        ngx.say('{"status": "ok", "data": "' .. status.body .. '"}')
    }
}
```

**自定义格式化页面：**
```nginx
location /status-page {
    stub_status on;
    access_log off;
    allow 127.0.0.1;
    deny all;
    
    # 添加HTML样式
    add_before_body /status-header.html;
    add_after_body /status-footer.html;
}
```

### 4.3 监控数据自动化收集


**脚本监控示例：**
```bash
#!/bin/bash
# nginx_monitor.sh - Nginx状态监控脚本

# 配置参数
NGINX_STATUS_URL="http://localhost/nginx_status"
LOG_FILE="/var/log/nginx_monitoring.log"
ALERT_THRESHOLD=1000

# 获取状态数据
get_nginx_status() {
    curl -s "$NGINX_STATUS_URL" 2>/dev/null
}

# 解析状态数据
parse_status() {
    local status_data="$1"
    
    # 提取活跃连接数
    ACTIVE_CONN=$(echo "$status_data" | grep "Active connections" | awk '{print $3}')
    
    # 提取三个主要数字
    STATS_LINE=$(echo "$status_data" | grep -E "^[[:space:]]*[0-9]")
    ACCEPTS=$(echo $STATS_LINE | awk '{print $1}')
    HANDLED=$(echo $STATS_LINE | awk '{print $2}')
    REQUESTS=$(echo $STATS_LINE | awk '{print $3}')
    
    # 提取读写等待状态
    RWW_LINE=$(echo "$status_data" | grep "Reading")
    READING=$(echo $RWW_LINE | awk '{print $2}')
    WRITING=$(echo $RWW_LINE | awk '{print $4}')
    WAITING=$(echo $RWW_LINE | awk '{print $6}')
}

# 记录监控数据
log_status() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "$timestamp,Active:$ACTIVE_CONN,Reading:$READING,Writing:$WRITING,Waiting:$WAITING" >> "$LOG_FILE"
}

# 告警检查
check_alerts() {
    if [ "$ACTIVE_CONN" -gt "$ALERT_THRESHOLD" ]; then
        echo "Alert: High connection count: $ACTIVE_CONN" | mail -s "Nginx Alert" admin@example.com
    fi
}

# 主程序
main() {
    STATUS_DATA=$(get_nginx_status)
    
    if [ $? -eq 0 ] && [ -n "$STATUS_DATA" ]; then
        parse_status "$STATUS_DATA"
        log_status
        check_alerts
    else
        echo "Error: Failed to get Nginx status" >> "$LOG_FILE"
    fi
}

# 执行监控
main
```

**🕐 定时任务配置：**
```bash
# 编辑crontab
crontab -e

# 每分钟执行一次监控
* * * * * /path/to/nginx_monitor.sh

# 每5分钟详细检查
*/5 * * * * /path/to/nginx_detailed_check.sh
```

---

## 5. 📊 数据收集与可视化


### 5.1 监控数据的价值


**数据告诉我们什么：**
```
短期监控（分钟级）：
• 实时性能状况
• 即时问题发现
• 突发流量识别

中期监控（小时级）：
• 业务高峰时段
• 用户访问模式
• 系统负载趋势

长期监控（天/周级）：
• 容量规划依据
• 性能优化效果
• 业务增长趋势
```

### 5.2 简单图表展示


**使用文本图表展示趋势：**
```
连接数趋势（最近24小时）：
时间    00  04  08  12  16  20  24
连接数  ▁▁  ▁▂  ▃▅  ▆█  ▇▆  ▄▂  ▁▁
       低   低  中等  高峰  较高  中等  低

请求处理能力：
Reading: ██░░░░░░░░ 20%  (正常)
Writing: ████████░░ 80%  (较高)
Waiting: ███░░░░░░░ 30%  (正常)
```

**状态健康度评估：**
```
┌─────────────────────────────────┐
│           系统健康度             │
├─────────────────────────────────┤
│ 连接处理率: 100%  ✅            │
│ 平均响应时间: 50ms ✅           │
│ 错误率: 0.01% ✅                │
│ 连接复用率: 1.87 ✅             │
│                                 │
│ 整体状态: 健康 😊                │
└─────────────────────────────────┘
```

### 5.3 与外部监控系统集成


**Prometheus监控集成：**
```bash
# nginx-prometheus-exporter配置
./nginx-prometheus-exporter \
  -nginx.scrape-uri=http://localhost/nginx_status \
  -web.listen-address=:9113
```

**监控数据格式化输出：**
```bash
#!/bin/bash
# 输出Prometheus格式数据

curl -s http://localhost/nginx_status | awk '
/Active connections/ { print "nginx_connections_active " $3 }
/server accepts handled requests/ { getline; print "nginx_connections_accepted " $1; print "nginx_connections_handled " $2; print "nginx_http_requests_total " $3 }
/Reading/ { print "nginx_connections_reading " $2; print "nginx_connections_writing " $4; print "nginx_connections_waiting " $6 }
'
```

### 5.4 性能基准对比


**不同负载下的典型数值：**

| 场景类型 | Active连接 | Reading | Writing | Waiting | 特征 |
|----------|------------|---------|---------|---------|------|
| **轻负载** | 50-200 | 1-5 | 10-50 | 30-150 | 正常业务访问 |
| **中负载** | 200-500 | 5-15 | 50-200 | 100-300 | 业务高峰期 |
| **重负载** | 500-1000 | 15-30 | 200-500 | 200-500 | 促销活动期 |
| **异常** | >1000 | >50 | >500 | >1000 | 可能遭受攻击 |

**🎯 性能调优参考：**
```
优化建议：
Writing数值过高：
• 检查静态文件缓存
• 启用gzip压缩
• 优化网络带宽

Waiting数值过高：
• 调整keepalive_timeout
• 检查长连接配置
• 评估连接池设置

Reading数值异常：
• 可能存在慢速攻击
• 检查request超时设置
• 分析请求来源
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 stub_status模块：Nginx内置的状态监控工具
🔸 Active connections：当前正在处理的连接总数
🔸 三大统计数据：accepts、handled、requests的含义
🔸 连接状态：Reading、Writing、Waiting的区别
🔸 安全配置：监控页面的访问控制和权限管理
🔸 数据解读：如何通过数字判断服务器健康状况
```

### 6.2 关键理解要点


**🔹 监控的本质意义**
```
监控不是目的，而是手段：
• 及时发现问题 → 减少故障时间
• 性能数据分析 → 指导优化方向
• 容量规划依据 → 避免资源浪费
• 用户体验保障 → 提升服务质量
```

**🔹 数据解读的智慧**
```
单个数据意义有限，组合分析更有价值：
• accepts = handled → 连接处理正常
• requests/handled → 连接复用效率
• Reading过高 → 可能的安全威胁
• Writing过高 → 传输瓶颈或大文件
• Waiting过高 → 长连接配置需调整
```

**🔹 监控配置的平衡**
```
安全性 vs 便捷性：
• 过于严格：影响监控效率
• 过于宽松：存在安全风险
• 最佳实践：内网开放，外网严控

监控频率的选择：
• 过于频繁：增加服务器负担
• 过于稀疏：错过关键信息
• 建议频率：1-5分钟间隔
```

### 6.3 实际应用价值


**运维实践指导：**
- **日常监控**：建立数据基线，识别异常模式
- **性能调优**：基于监控数据优化配置参数
- **容量规划**：预测业务增长的资源需求
- **故障诊断**：快速定位问题发生的时间和原因

**业务价值体现：**
- **用户体验**：确保服务稳定可用
- **成本控制**：避免过度或不足的资源配置
- **决策支持**：为技术和业务决策提供数据依据

### 6.4 学习建议


**🔸 实践步骤：**
1. **基础配置**：先搭建简单的状态页面
2. **数据理解**：观察不同时段的数据变化
3. **安全加固**：配置适当的访问控制
4. **自动化**：编写脚本实现数据收集
5. **可视化**：接入图表系统展示趋势

**🔸 进阶方向：**
- 学习更高级的监控工具（如Prometheus）
- 掌握日志分析和指标相关性
- 了解分布式监控和集群状态
- 研究自动化运维和告警机制

**核心记忆口诀：**
```
stub_status开启状态页，安全配置不能差
Active总数要关注，三大数据析健康
Reading Writing Waiting清，组合分析见真情
监控数据指方向，运维决策有依据
```