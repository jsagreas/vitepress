---
title: 1、nginx-代理缓存
---
## 📚 目录

1. [代理缓存基础概念](#1-代理缓存基础概念)
2. [缓存配置核心指令](#2-缓存配置核心指令)
3. [缓存键设计与管理](#3-缓存键设计与管理)
4. [缓存时间控制策略](#4-缓存时间控制策略)
5. [缓存清理与维护](#5-缓存清理与维护)
6. [缓存性能优化](#6-缓存性能优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 代理缓存基础概念


### 1.1 什么是代理缓存

**简单理解**：代理缓存就像是在你和后端服务器之间放了一个"聪明的仓库"

```
没有缓存的情况：
用户请求 → Nginx → 后端服务器 → 数据库
每次都要走完整流程，很慢！

有缓存的情况：
用户请求 → Nginx缓存 ← 直接返回（快！）
         ↓ 缓存没有时
         后端服务器 → 数据库
```

**核心作用**：
- **加速响应**：常用内容直接从缓存返回，不用等后端处理
- **减轻负载**：后端服务器压力大大减少
- **节省带宽**：减少重复数据传输

### 1.2 缓存工作原理

**生活类比**：就像超市的库存管理
- 🏪 **热销商品**：放在显眼位置，拿取方便（热点内容缓存）
- 📦 **仓库备货**：提前准备，避免缺货（预缓存策略）
- 🗑️ **过期清理**：定期清理过期商品（缓存过期机制）

```
Nginx缓存机制：
1. 用户请求到达
2. 检查是否有缓存
3. 缓存命中 → 直接返回
4. 缓存未命中 → 请求后端 → 缓存结果 → 返回用户
```

### 1.3 缓存的优势与局限


**🔸 优势**
- **性能提升**：响应时间从秒级降到毫秒级
- **成本节约**：减少服务器资源消耗
- **用户体验**：页面加载速度明显提升

**🔸 局限性**
- **数据一致性**：缓存可能不是最新数据
- **存储占用**：需要额外的磁盘空间
- **管理复杂**：需要合理的缓存策略

---

## 2. ⚙️ 缓存配置核心指令


### 2.1 基础缓存区域配置


**`proxy_cache_path` 指令详解**

```nginx
# 在http块中定义缓存区域
http {
    # 基础缓存配置
    proxy_cache_path /var/cache/nginx/proxy
                     levels=1:2
                     keys_zone=my_cache:10m
                     max_size=1g
                     inactive=60m
                     use_temp_path=off;
}
```

**🔸 参数详细说明**

| 参数 | 含义 | 通俗解释 | 推荐值 |
|------|------|----------|--------|
| `/var/cache/nginx/proxy` | 缓存文件存储路径 | 缓存文件放在哪个文件夹 | 独立分区路径 |
| `levels=1:2` | 目录层级结构 | 避免单个文件夹文件过多 | `1:2` 或 `2:2` |
| `keys_zone=my_cache:10m` | 内存区域名称和大小 | 用10MB内存记录缓存索引 | 根据缓存数量调整 |
| `max_size=1g` | 最大缓存大小 | 缓存文件总大小不超过1GB | 根据磁盘空间设置 |
| `inactive=60m` | 非活跃清理时间 | 60分钟未访问就删除 | 根据访问模式调整 |

### 2.2 服务器块中启用缓存


```nginx
server {
    listen 80;
    server_name example.com;
    
    location /api/ {
        # 启用缓存
        proxy_cache my_cache;
        
        # 基本代理设置
        proxy_pass http://backend_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # 缓存相关头部
        add_header X-Cache-Status $upstream_cache_status;
    }
}
```

**🔸 缓存状态说明**
- **MISS**：缓存未命中，从后端获取
- **HIT**：缓存命中，直接返回
- **EXPIRED**：缓存过期，重新获取
- **BYPASS**：跳过缓存

### 2.3 后端服务器组配置


```nginx
upstream backend_servers {
    server 192.168.1.10:8080 weight=3;
    server 192.168.1.11:8080 weight=2;
    server 192.168.1.12:8080 backup;
    
    # 连接保持
    keepalive 32;
}
```

---

## 3. 🔑 缓存键设计与管理


### 3.1 缓存键的重要性

**理解缓存键**：就像给每个缓存文件起个独特的名字

```nginx
# 默认缓存键
proxy_cache_key $scheme$proxy_host$request_uri;

# 自定义缓存键示例
proxy_cache_key $scheme$proxy_host$uri$is_args$args$http_user_agent;
```

**🔸 缓存键组成要素**
- **$scheme**：http或https
- **$proxy_host**：代理的主机名
- **$request_uri**：完整的请求URI
- **$args**：查询参数

### 3.2 智能缓存键设计


```nginx
location /api/user/ {
    # 用户相关API，包含用户ID
    proxy_cache_key $scheme$proxy_host$uri$arg_user_id;
    proxy_cache my_cache;
    proxy_pass http://backend_servers;
}

location /api/public/ {
    # 公共API，忽略某些参数
    proxy_cache_key $scheme$proxy_host$uri$arg_page$arg_size;
    proxy_cache my_cache;
    proxy_pass http://backend_servers;
}

location /static/ {
    # 静态资源，简单缓存键
    proxy_cache_key $scheme$proxy_host$uri;
    proxy_cache my_cache;
    proxy_pass http://backend_servers;
}
```

### 3.3 缓存键优化策略


**💡 设计原则**
- **唯一性**：确保不同内容有不同的键
- **稳定性**：相同内容应该有相同的键
- **简洁性**：避免包含不必要的变量

```nginx
# 避免过于复杂的缓存键
# 错误示例
proxy_cache_key $scheme$proxy_host$uri$args$http_accept$http_user_agent$request_time;

# 正确示例
proxy_cache_key $scheme$proxy_host$uri$arg_id$arg_type;
```

---

## 4. ⏰ 缓存时间控制策略


### 4.1 基础时间设置


```nginx
location /api/ {
    proxy_cache my_cache;
    
    # 不同状态码的缓存时间
    proxy_cache_valid 200 302 10m;    # 成功响应缓存10分钟
    proxy_cache_valid 404 1m;         # 404错误缓存1分钟
    proxy_cache_valid any 5m;         # 其他状态码缓存5分钟
    
    proxy_pass http://backend_servers;
}
```

**🔸 时间设置技巧**

| 内容类型 | 推荐缓存时间 | 原因 |
|----------|-------------|------|
| **静态资源** | 1小时-1天 | 不经常变化 |
| **API数据** | 5-30分钟 | 需要相对实时 |
| **用户信息** | 1-5分钟 | 变化较频繁 |
| **错误页面** | 1-3分钟 | 避免错误放大 |

### 4.2 动态缓存时间


```nginx
location /api/news/ {
    proxy_cache my_cache;
    
    # 根据后端响应头决定缓存时间
    proxy_cache_valid 200 1h;
    
    # 如果后端设置了Cache-Control，优先使用
    proxy_cache_revalidate on;
    
    proxy_pass http://backend_servers;
}
```

### 4.3 特殊情况处理


```nginx
location /api/urgent/ {
    proxy_cache my_cache;
    
    # 短缓存时间，但允许过期内容
    proxy_cache_valid 200 30s;
    
    # 如果后端不可用，使用过期缓存
    proxy_cache_use_stale error timeout http_500 http_502 http_503;
    
    proxy_pass http://backend_servers;
}
```

**🔸 `proxy_cache_use_stale` 参数说明**
- **error**：连接错误时使用过期缓存
- **timeout**：连接超时时使用过期缓存
- **http_500/502/503**：服务器错误时使用过期缓存

---

## 5. 🧹 缓存清理与维护


### 5.1 手动缓存清理


**使用PURGE方法清理缓存**

```nginx
# 配置清理接口
location ~ /purge(/.*) {
    # 限制访问来源
    allow 127.0.0.1;
    allow 192.168.1.0/24;
    deny all;
    
    # 清理指定缓存
    proxy_cache_purge my_cache $scheme$proxy_host$1;
}
```

**🔸 清理缓存示例**
```bash
# 清理特定API缓存
curl -X PURGE http://localhost/purge/api/user/123

# 清理静态资源缓存
curl -X PURGE http://localhost/purge/static/css/style.css
```

### 5.2 自动缓存清理


```nginx
http {
    # 缓存目录配置
    proxy_cache_path /var/cache/nginx/proxy
                     levels=1:2
                     keys_zone=my_cache:10m
                     max_size=1g
                     inactive=60m          # 60分钟未访问自动删除
                     manager_files=100     # 每次清理检查100个文件
                     manager_threshold=200ms; # 清理过程最多200ms
}
```

### 5.3 缓存监控脚本


```bash
#!/bin/bash
# 缓存状态监控脚本

CACHE_DIR="/var/cache/nginx/proxy"
CACHE_SIZE=$(du -sh $CACHE_DIR | cut -f1)
FILE_COUNT=$(find $CACHE_DIR -type f | wc -l)

echo "缓存目录: $CACHE_DIR"
echo "缓存大小: $CACHE_SIZE"
echo "文件数量: $FILE_COUNT"

# 检查缓存命中率
echo "缓存命中率统计:"
grep "X-Cache-Status" /var/log/nginx/access.log | \
awk '{print $NF}' | sort | uniq -c
```

---

## 6. 🚀 缓存性能优化


### 6.1 缓存分层策略


```nginx
# 不同内容使用不同缓存区域
http {
    # 静态资源缓存（大容量，长时间）
    proxy_cache_path /var/cache/nginx/static
                     levels=2:2
                     keys_zone=static_cache:50m
                     max_size=5g
                     inactive=1d;
    
    # API数据缓存（中等容量，短时间）
    proxy_cache_path /var/cache/nginx/api
                     levels=1:2
                     keys_zone=api_cache:20m
                     max_size=1g
                     inactive=1h;
    
    # 动态内容缓存（小容量，极短时间）
    proxy_cache_path /var/cache/nginx/dynamic
                     levels=1:1
                     keys_zone=dynamic_cache:10m
                     max_size=500m
                     inactive=10m;
}

server {
    # 静态资源
    location ~* \.(jpg|jpeg|png|gif|css|js|woff2)$ {
        proxy_cache static_cache;
        proxy_cache_valid 200 1d;
        proxy_pass http://backend_servers;
    }
    
    # API接口
    location /api/ {
        proxy_cache api_cache;
        proxy_cache_valid 200 30m;
        proxy_pass http://backend_servers;
    }
    
    # 动态页面
    location / {
        proxy_cache dynamic_cache;
        proxy_cache_valid 200 5m;
        proxy_pass http://backend_servers;
    }
}
```

### 6.2 缓存预热策略


```nginx
location /cache-warmup {
    # 限制访问
    allow 127.0.0.1;
    deny all;
    
    # 预热脚本接口
    content_by_lua_block {
        -- Lua脚本实现缓存预热
        local urls = {
            "/api/popular-products",
            "/api/hot-news",
            "/api/user-recommendations"
        }
        
        for _, url in ipairs(urls) do
            ngx.location.capture(url)
        end
        
        ngx.say("Cache warmed up successfully")
    }
}
```

### 6.3 智能缓存更新


```nginx
location /api/update/ {
    # 更新操作时清理相关缓存
    proxy_cache my_cache;
    
    # POST/PUT/DELETE请求不缓存
    proxy_cache_methods GET HEAD;
    
    # 根据请求方法决定是否清理缓存
    if ($request_method = POST) {
        set $cache_purge 1;
    }
    
    proxy_pass http://backend_servers;
}
```

---

## 7. 📊 缓存命中率监控


### 7.1 日志配置


```nginx
# 自定义日志格式
log_format cache_log '$remote_addr - $remote_user [$time_local] '
                     '"$request" $status $body_bytes_sent '
                     '"$http_referer" "$http_user_agent" '
                     'cache_status:$upstream_cache_status '
                     'cache_time:$upstream_response_time';

# 应用到服务器
server {
    access_log /var/log/nginx/cache_access.log cache_log;
    
    location / {
        proxy_cache my_cache;
        add_header X-Cache-Status $upstream_cache_status;
        proxy_pass http://backend_servers;
    }
}
```

### 7.2 命中率分析


```bash
#!/bin/bash
# 缓存命中率分析脚本

LOG_FILE="/var/log/nginx/cache_access.log"

echo "=== 缓存命中率统计 ==="
echo "时间范围: 最近1000条请求"

# 统计各种缓存状态
echo -e "\n缓存状态分布:"
tail -1000 $LOG_FILE | grep -o "cache_status:[A-Z]*" | \
cut -d: -f2 | sort | uniq -c | \
awk '{
    total += $1
    status[$2] = $1
}
END {
    for (s in status) {
        printf "%-10s: %6d (%5.1f%%)\n", s, status[s], status[s]/total*100
    }
    printf "%-10s: %6d\n", "总计", total
}'

# 计算命中率
HIT_RATE=$(tail -1000 $LOG_FILE | grep -o "cache_status:[A-Z]*" | \
cut -d: -f2 | awk '
/HIT/ { hit++ }
{ total++ }
END { if (total > 0) print hit/total*100; else print 0 }')

echo -e "\n总体命中率: ${HIT_RATE}%"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 代理缓存本质：在Nginx和后端间建立缓存层，提升响应速度
🔸 配置三要素：缓存路径(proxy_cache_path)、缓存区域、缓存启用
🔸 缓存键设计：决定什么内容被缓存为同一份，影响命中率
🔸 时间控制策略：不同内容类型需要不同的缓存时间
🔸 清理维护机制：手动清理和自动清理相结合
🔸 性能监控：通过命中率判断缓存效果
```

### 8.2 关键理解要点


**🔹 缓存是把双刃剑**
```
优势：极大提升性能，减少后端压力
风险：可能返回过期数据，需要平衡实时性和性能
策略：根据业务特点制定合适的缓存策略
```

**🔹 缓存键设计原则**
```
唯一性：不同内容必须有不同的键
稳定性：相同内容必须有相同的键
简洁性：避免包含无关变量
实用性：考虑实际业务场景
```

**🔹 时间设置策略**
```
静态资源：长时间缓存（小时/天级别）
动态数据：短时间缓存（分钟级别）
用户相关：极短缓存（秒/分钟级别）
错误页面：很短缓存（避免错误放大）
```

### 8.3 实际应用场景


**🎯 电商网站应用**
- **商品图片**：缓存1天，提升浏览速度
- **商品信息**：缓存30分钟，平衡实时性和性能
- **购物车数据**：缓存5分钟，保证用户体验
- **订单状态**：不缓存，保证数据准确性

**🎯 新闻网站应用**
- **新闻列表**：缓存15分钟，快速加载
- **新闻详情**：缓存1小时，减少数据库压力
- **评论数据**：缓存5分钟，平衡互动性和性能
- **用户信息**：缓存2分钟，保证登录状态

### 8.4 最佳实践建议


**💡 配置建议**
```
1. 分层缓存：不同类型内容使用不同缓存区域
2. 合理容量：根据服务器资源设置缓存大小
3. 监控完善：建立完整的缓存监控体系
4. 清理策略：自动清理+手动清理相结合
5. 测试验证：上线前充分测试缓存效果
```

**⚠️ 常见陷阱**
```
缓存键设计不当：导致缓存命中率低
缓存时间过长：返回过期数据
缓存空间不足：频繁清理影响性能
忽略监控：无法及时发现问题
```

**🎯 性能优化要点**
```
1. 命中率目标：争取达到80%以上
2. 响应时间：缓存命中应在10ms以内
3. 存储效率：定期清理无效缓存
4. 预热策略：重要内容提前缓存
5. 更新机制：内容更新时及时清理相关缓存
```

**核心记忆**：
- 代理缓存是提升网站性能的重要手段
- 合理的缓存策略需要平衡性能和数据实时性
- 缓存键设计和时间控制是配置的核心
- 监控和维护是保证缓存效果的关键