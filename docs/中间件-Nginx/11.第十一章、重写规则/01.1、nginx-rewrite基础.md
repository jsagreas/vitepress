---
title: 1、nginx-rewrite基础
---
## 📚 目录

1. [什么是URL重写](#1-什么是URL重写)
2. [rewrite指令基础语法](#2-rewrite指令基础语法)
3. [重写标志flag详解](#3-重写标志flag详解)
4. [last和break的关键区别](#4-last和break的关键区别)
5. [redirect和permanent重定向](#5-redirect和permanent重定向)
6. [重写规则执行顺序](#6-重写规则执行顺序)
7. [调试重写规则](#7-调试重写规则)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 什么是URL重写


### 1.1 URL重写的本质含义


**🔸 简单理解**
```
URL重写就像给网址"改名"或"换地址"
用户访问A网址，实际上服务器处理的是B网址
```

**💡 生活类比**
> **💭 生活类比**
> 
> URL重写就像邮局的"信件转发服务"：
> - 你搬家了，但还有人往老地址寄信
> - 邮局看到老地址，自动转发到新地址
> - 寄信人不知道转发过程，但信件正常送达

### 1.2 为什么需要URL重写


**🎯 实际应用场景**
```
搜索引擎友好：
旧URL: /product.php?id=123&category=phone
新URL: /products/phone/iphone-15

用户体验优化：
旧URL: /user/profile.jsp?uid=456
新URL: /user/456/profile

网站改版迁移：
旧系统: /old-shop/items.asp?pid=789
新系统: /shop/items/789
```

**✅ 重写的核心作用**
- **用户友好**：URL更简洁易记
- **SEO优化**：搜索引擎更容易理解
- **向后兼容**：老链接继续可用
- **统一管理**：集中处理URL规则

### 1.3 Nginx重写vs其他方案


**🔍 技术对比**

| 方案类型 | **实现方式** | **性能** | **灵活性** | **维护性** |
|---------|------------|---------|-----------|-----------|
| **Nginx重写** | `服务器层面处理` | `极高` | `很强` | `集中管理` |
| **Apache重写** | `.htaccess文件` | `较高` | `强` | `分散配置` |
| **应用层重写** | `程序代码处理` | `一般` | `最强` | `代码耦合` |

---

## 2. 📝 rewrite指令基础语法


### 2.1 基本语法结构


**🔸 标准格式**
```nginx
rewrite 正则表达式 替换内容 [标志];
```

**📋 语法组成部分**
```
组成要素：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│  rewrite    │ 正则表达式   │  替换内容    │   标志      │
├─────────────┼─────────────┼─────────────┼─────────────┤
│  关键字     │ 匹配模式     │  新的URL     │  处理方式    │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

### 2.2 正则表达式基础


**🔤 常用正则符号**
```
基础符号：
^        : 开头匹配
$        : 结尾匹配
.        : 任意单个字符
*        : 前面字符出现0次或多次
+        : 前面字符出现1次或多次
?        : 前面字符出现0次或1次
()       : 分组捕获
[]       : 字符类匹配
```

**💡 实用示例**
```nginx
# 匹配数字ID
^/user/([0-9]+)$
# 解释：以/user/开头，后面跟一个或多个数字，然后结束

# 匹配文件扩展名
^/files/(.+)\.(jpg|png|gif)$
# 解释：/files/开头，任意文件名，扩展名是jpg、png或gif

# 匹配可选路径
^/shop(/.*)?$
# 解释：以/shop开头，后面可以跟任意路径或什么都不跟
```

### 2.3 替换内容详解


**🔄 变量替换**
```nginx
# 使用捕获组
rewrite ^/user/([0-9]+)$ /profile.php?id=$1;

# 使用多个捕获组
rewrite ^/product/([^/]+)/([0-9]+)$ /show.php?category=$1&id=$2;

# 使用内置变量
rewrite ^/old-path$ /new-path?from=$request_uri;
```

**📌 常用内置变量**
```
$1, $2, $3...  : 正则捕获组
$request_uri    : 完整的原始请求URI
$uri           : 当前请求的URI
$args          : 查询字符串参数
$host          : 请求的主机名
$scheme        : 协议(http/https)
```

---

## 3. 🏷️ 重写标志flag详解


### 3.1 四个核心标志


**🔸 标志类型总览**
```
last      : 完成重写，继续匹配新URI
break     : 完成重写，停止匹配
redirect  : 临时重定向(302)
permanent : 永久重定向(301)
```

### 3.2 last标志详解


**💡 last标志的工作机制**
```nginx
location /test {
    rewrite ^/test/(.*)$ /new/$1 last;
    return 404;  # 这行不会执行
}

location /new {
    try_files $uri $uri/ =404;
}
```

**🔍 执行流程**
```
用户请求: /test/hello
     ↓
应用重写: /new/hello (带last标志)
     ↓
重新开始: 查找匹配/new/hello的location
     ↓
找到location: /new
     ↓
处理请求: 在/new块中处理
```

### 3.3 break标志详解


**💡 break标志的工作机制**
```nginx
location /api {
    rewrite ^/api/v1/(.*)$ /api/v2/$1 break;
    proxy_pass http://backend;
}
```

**🔍 执行流程**
```
用户请求: /api/v1/users
     ↓
应用重写: /api/v2/users (带break标志)
     ↓
停止重写: 不再查找其他location
     ↓
继续处理: 在当前location中继续执行proxy_pass
```

---

## 4. ⚡ last和break的关键区别


### 4.1 直观对比理解


**📊 核心区别对比**

| 特性 | **last** | **break** |
|------|----------|-----------|
| **重写后行为** | `重新开始location匹配` | `在当前location继续` |
| **查找新location** | `会重新查找` | `不会重新查找` |
| **适用场景** | `需要匹配其他location` | `在当前location处理` |
| **性能影响** | `略低(重新匹配)` | `更高(直接处理)` |

### 4.2 实战案例对比


**🔸 案例1：使用last的场景**
```nginx
# 需要重新匹配location的情况
location /old {
    rewrite ^/old/(.*)$ /new/$1 last;
}

location /new {
    root /var/www/html;
    try_files $uri $uri/ =404;
}
```

**🔍 执行过程**
```
请求 /old/page.html
 ↓ (last重写)
重写为 /new/page.html
 ↓ (重新查找location)
匹配到 location /new
 ↓
在/new location中处理请求
```

**🔸 案例2：使用break的场景**
```nginx
location /api {
    # 重写API版本，但继续在当前location处理
    rewrite ^/api/v1/(.*)$ /api/v2/$1 break;
    proxy_pass http://backend_server;
}
```

**🔍 执行过程**
```
请求 /api/v1/users
 ↓ (break重写)
重写为 /api/v2/users
 ↓ (停止重写，继续当前location)
执行 proxy_pass，转发到后端
```

### 4.3 选择标志的判断原则


**🎯 决策流程图**
```
需要重写URL？
     ↓ 是
重写后需要匹配其他location？
     ↓ 是              ↓ 否
   使用 last         使用 break
```

**💡 实用选择建议**
- **静态文件重写** → 用`last`（需要重新查找静态文件location）
- **API路径重写** → 用`break`（在当前location代理到后端）
- **跨location跳转** → 用`last`
- **当前location内处理** → 用`break`

---

## 5. 🔗 redirect和permanent重定向


### 5.1 重定向的基本概念


**🔸 重定向 vs 重写**
```
内部重写(last/break):
客户端 → 请求/old → Nginx内部处理 → 返回内容
用户看到: /old (地址栏不变)

外部重定向(redirect/permanent):
客户端 → 请求/old → Nginx返回30x → 客户端请求/new
用户看到: /new (地址栏改变)
```

### 5.2 redirect临时重定向(302)


**🔸 基本用法**
```nginx
# 临时重定向示例
location /temporary-sale {
    rewrite ^/temporary-sale$ /current-offers redirect;
}
```

**📊 临时重定向特点**
```
HTTP状态码: 302 Found
浏览器行为: 地址栏显示新URL
搜索引擎: 不会转移权重，保持原URL收录
使用场景: 临时性的页面跳转
```

### 5.3 permanent永久重定向(301)


**🔸 基本用法**
```nginx
# 永久重定向示例
location /old-blog {
    rewrite ^/old-blog(.*)$ /blog$1 permanent;
}
```

**📊 永久重定向特点**
```
HTTP状态码: 301 Moved Permanently
浏览器行为: 地址栏显示新URL，缓存重定向
搜索引擎: 转移权重到新URL，更新收录
使用场景: 永久性的URL变更
```

### 5.4 重定向最佳实践


**🎯 选择原则**

| 场景类型 | **推荐方案** | **原因** |
|---------|------------|----------|
| **网站改版** | `permanent` | `权重转移，SEO友好` |
| **临时维护** | `redirect` | `维护完成后恢复` |
| **A/B测试** | `redirect` | `测试结束可能回滚` |
| **域名更换** | `permanent` | `永久性变更` |

**⚠️ 重要提醒**
> **⚠️ 重定向注意事项**
> 
> - 永久重定向要慎重，一旦设置影响SEO
> - 避免重定向链（A→B→C），影响性能
> - 重定向前确认目标URL存在且正确

---

## 6. 🔄 重写规则执行顺序


### 6.1 执行顺序基本原理


**🔸 Nginx处理阶段**
```
请求处理流程：
1. server级别rewrite
2. location匹配
3. location级别rewrite
4. 其他指令执行
```

**📋 详细执行步骤**
```
阶段1: 接收请求
  ↓
阶段2: server块中的rewrite指令
  ↓
阶段3: 查找匹配的location
  ↓
阶段4: location块中的rewrite指令
  ↓
阶段5: 执行其他指令(try_files, proxy_pass等)
```

### 6.2 实际执行示例


**🔸 配置示例**
```nginx
server {
    listen 80;
    server_name example.com;
    
    # 第1步：server级别重写
    rewrite ^/step1$ /step2 last;
    
    location /step2 {
        # 第2步：location级别重写
        rewrite ^/step2$ /final break;
        
        # 第3步：其他指令
        try_files $uri $uri/ =404;
    }
}
```

**🔍 执行流程追踪**
```
请求: GET /step1
  ↓ (server级rewrite)
重写为: /step2 (last标志，重新查找location)
  ↓ (匹配location /step2)
进入location: /step2
  ↓ (location级rewrite)
重写为: /final (break标志，停止重写)
  ↓ (执行其他指令)
执行: try_files $uri $uri/ =404
```

### 6.3 多重写规则处理


**🔸 同一location内多个rewrite**
```nginx
location /multi {
    rewrite ^/multi/old$ /multi/new break;
    rewrite ^/multi/test$ /multi/result break;
    return 200 "Final content";
}
```

**📝 处理规则**
- 按书写顺序依次执行
- 遇到last/break/redirect/permanent就停止
- 没有标志的rewrite会继续执行下一条

---

## 7. 🔧 调试重写规则


### 7.1 开启重写日志


**🔸 配置重写日志**
```nginx
# 在http块或server块中添加
error_log /var/log/nginx/rewrite.log notice;
rewrite_log on;
```

**📋 日志级别说明**
```
日志级别：
- notice: 显示重写过程
- debug: 显示详细调试信息(需要编译时启用debug)
- error: 只显示错误信息
```

### 7.2 实用调试技巧


**🔸 添加调试返回**
```nginx
location /debug {
    rewrite ^/debug/(.*)$ /result/$1 break;
    
    # 调试：返回重写后的URI
    add_header X-Rewritten-URI $uri;
    return 200 "URI: $uri, Args: $args";
}
```

**🔸 使用return测试**
```nginx
location /test {
    # 临时替换rewrite，直接返回结果测试
    # rewrite ^/test/(.*)$ /new/$1 last;
    return 200 "Would rewrite to: /new/$1";
}
```

### 7.3 常见问题排查


**❌ 常见错误及解决**

**问题1：重写无效果**
```nginx
# 错误写法
location /api {
    rewrite /api/(.*)$ /v2/$1 last;  # 缺少^开头标记
}

# 正确写法  
location /api {
    rewrite ^/api/(.*)$ /v2/$1 last;
}
```

**问题2：无限循环重写**
```nginx
# 错误写法 - 会造成循环
location /loop {
    rewrite ^/loop$ /loop/index last;  # 会重新匹配/loop
}

# 正确写法
location /loop {
    rewrite ^/loop$ /loop/index break;  # 或者用更精确的匹配
}
```

**🔍 调试检查清单**
```
📋 重写调试步骤：
□ 检查正则表达式是否正确
□ 确认标志flag使用恰当
□ 查看error日志中的重写信息
□ 使用return临时测试重写逻辑
□ 检查是否存在重写循环
□ 验证目标URL是否存在
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 URL重写本质：在服务器内部改变请求处理路径
🔸 rewrite语法：rewrite 正则 替换 [标志]
🔸 四个标志：last(重新匹配) break(停止重写) redirect(302) permanent(301)
🔸 执行顺序：server级 → location匹配 → location级 → 其他指令
🔸 调试方法：开启rewrite_log，使用return测试
```

### 8.2 关键理解要点


**🔹 last vs break的选择**
```
判断原则：
- 重写后需要其他location处理 → last
- 重写后在当前location处理 → break
- 静态文件重写 → last
- API代理重写 → break
```

**🔹 重定向的合理使用**
```
使用场景：
- 永久性URL变更 → permanent (301)
- 临时性跳转 → redirect (302)  
- 需要用户看到新URL → 用重定向
- 内部处理不改变地址栏 → 用重写
```

**🔹 重写规则优化**
```
最佳实践：
- 正则尽量精确，避免过度匹配
- 合理使用标志，避免不必要的重新匹配
- 开启日志调试，及时发现问题
- 避免重写循环，注意匹配条件
```

### 8.3 实际应用价值


**🎯 典型应用场景**
- **网站SEO优化**：动态URL转为静态友好URL
- **API版本管理**：v1 API透明升级到 v2
- **网站架构重构**：保持老链接继续可用
- **移动端适配**：根据设备类型重写到不同页面

**🔧 运维实践要点**
- **测试环境验证**：重写规则上线前充分测试
- **日志监控**：关注重写日志，及时发现异常
- **性能考虑**：避免复杂正则和过度重写
- **文档记录**：重写规则要有清晰的注释说明

**💡 核心记忆技巧**
```
重写规则记忆口诀：
"last重新找location，break当前就停止"
"redirect地址栏会变，permanent权重转移"
"server先于location，顺序执行不乱套"
```

**🎓 学习建议**
- 从简单的重写规则开始练习
- 理解每个标志的具体作用和使用场景
- 多做实验，观察不同配置的效果差异
- 结合实际项目需求设计重写规则