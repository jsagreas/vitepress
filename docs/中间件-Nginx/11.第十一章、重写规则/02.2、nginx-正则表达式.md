---
title: 2、nginx-正则表达式
---
## 📚 目录

1. [正则表达式基础概念](#1-正则表达式基础概念)
2. [Nginx中的正则语法](#2-nginx中的正则语法)
3. [捕获组与变量引用](#3-捕获组与变量引用)
4. [常用正则模式详解](#4-常用正则模式详解)
5. [正则性能优化](#5-正则性能优化)
6. [调试与测试工具](#6-调试与测试工具)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 正则表达式基础概念


### 1.1 什么是正则表达式


**简单理解**：正则表达式就像是一个"文本搜索的魔法公式"

```
想象一下：
- 你要在一本电话簿里找所有138开头的手机号
- 手工一个个找 → 太累了！
- 用正则表达式 → 写个"搜索公式"：^138\d{8}$
- 一下子就能找到所有符合条件的号码

正则表达式 = 用特殊符号描述文本模式的语言
```

**核心作用**：
- **匹配**：判断文本是否符合某种模式
- **提取**：从文本中取出需要的部分
- **替换**：把符合模式的文本换成别的内容

### 1.2 在Nginx中的应用场景


**实际应用举例**：

```
场景1：手机端和PC端分别处理
用户访问：www.example.com
- 如果是手机浏览器 → 跳转到 m.example.com
- 如果是PC浏览器 → 正常显示

场景2：URL美化
用户看到：/product/123/detail
实际处理：/index.php?type=product&id=123&action=detail

场景3：防盗链
允许：从本站或百度来的图片请求
拒绝：直接输入图片地址访问
```

### 1.3 正则vs普通字符串匹配


| 对比项 | **普通字符串** | **正则表达式** |
|--------|---------------|---------------|
| **匹配方式** | `完全相等` | `模式匹配` |
| **灵活性** | `固定内容` | `可变内容` |
| **应用场景** | `精确匹配` | `模糊匹配` |
| **学习成本** | `简单` | `需要学习` |

**生活类比**：
```
普通字符串匹配 = 找名字叫"张三"的人
正则表达式匹配 = 找姓"张"的所有人
```

---

## 2. 🔧 Nginx中的正则语法


### 2.1 基本字符匹配


**字面字符**：直接写出来的字符
```nginx
# 匹配 /hello 这个确切路径
location /hello {
    return 200 "Hello World";
}
```

**特殊字符（元字符）**：有特殊含义的符号
```
. 点号 → 匹配任意一个字符（除了换行）
* 星号 → 前面的字符重复0次或多次  
+ 加号 → 前面的字符重复1次或多次
? 问号 → 前面的字符0次或1次
^ 开头 → 字符串开始位置
$ 结尾 → 字符串结束位置
```

### 2.2 字符类和范围


**字符类**：用方括号定义一组可选字符
```nginx
# 匹配 /image1, /image2, /image3 等
location ~ ^/image[0-9] {
    root /var/www/images;
}

# 匹配 /user/a, /user/b, /user/c
location ~ ^/user/[abc] {
    proxy_pass http://backend;
}
```

**常用字符类**：
```
[0-9]   → 任意数字，等同于 \d
[a-z]   → 小写字母
[A-Z]   → 大写字母  
[a-zA-Z] → 任意字母
[^0-9]  → 非数字字符
```

### 2.3 预定义字符类


```
\d → 数字字符 [0-9]
\w → 单词字符 [a-zA-Z0-9_]  
\s → 空白字符（空格、制表符等）
\D → 非数字字符
\W → 非单词字符
\S → 非空白字符
```

**实际应用**：
```nginx
# 匹配用户ID（纯数字）
location ~ ^/user/\d+/?$ {
    proxy_pass http://user_service;
}

# 匹配文件名（字母数字下划线）
location ~ ^/files/\w+\.(jpg|png|gif)$ {
    expires 7d;
}
```

### 2.4 数量修饰符


**精确控制重复次数**：
```
{n}     → 恰好n次
{n,}    → 至少n次
{n,m}   → n到m次之间
*       → {0,} 零次或多次
+       → {1,} 一次或多次  
?       → {0,1} 零次或一次
```

**实用示例**：
```nginx
# 手机号格式：1开头，第二位3-9，总共11位
location ~ ^/sms/1[3-9]\d{9}$ {
    proxy_pass http://sms_service;
}

# 验证码：4-6位数字
location ~ ^/verify/\d{4,6}$ {
    proxy_pass http://verify_service;
}
```

### 2.5 分组和选择


**分组**：用圆括号把多个字符当作一个整体
```nginx
# (jpg|png|gif) 表示jpg或png或gif其中之一
location ~ \.(jpg|png|gif)$ {
    expires 30d;
    add_header Cache-Control "public, immutable";
}
```

**选择符**：用 | 表示"或者"
```nginx
# 匹配管理员或用户路径
location ~ ^/(admin|user)/ {
    auth_basic "Protected Area";
    auth_basic_user_file /etc/nginx/.htpasswd;
}
```

---

## 3. 🎪 捕获组与变量引用


### 3.1 什么是捕获组


**简单理解**：捕获组就像是"记住一部分匹配内容的小盒子"

```
比如网址：/product/123/detail
如果用正则：/product/(\d+)/detail
那么(\d+)就是捕获组，会把"123"记住
然后你就可以在其他地方使用这个"123"
```

**语法规则**：
- **圆括号**创建捕获组：`(pattern)`
- **自动编号**：从左到右，从1开始编号
- **$1, $2, $3**：在nginx中引用捕获的内容

### 3.2 基础捕获示例


```nginx
# 将 /old/123 重定向到 /new/123
location ~ ^/old/(\d+)$ {
    return 301 /new/$1;
}

# 说明：
# ^/old/     → 匹配以"/old/"开始  
# (\d+)      → 捕获一个或多个数字，存入$1
# $          → 匹配字符串结尾
# $1         → 引用第一个捕获组的内容
```

**工作过程图示**：
```
请求URL: /old/456
          ↓
正则匹配: ^/old/(\d+)$
          |     |
          |     └─ 捕获组1: "456"
          └─ 固定部分
          ↓
结果: return 301 /new/456;
```

### 3.3 多重捕获组


```nginx
# 捕获用户ID和操作类型
# URL: /api/user/123/edit
location ~ ^/api/user/(\d+)/(edit|view|delete)$ {
    proxy_pass http://backend/user.php?id=$1&action=$2;
}

# 捕获过程：
# $1 = "123"    (用户ID)
# $2 = "edit"   (操作类型)
# 最终转发: http://backend/user.php?id=123&action=edit
```

### 3.4 嵌套捕获组


**理解嵌套**：大盒子里放小盒子
```nginx
# 匹配日期格式：2023-12-25
location ~ ^/archive/((20\d{2})-(\d{2})-(\d{2}))/ {
    # $1 = "2023-12-25" (完整日期)
    # $2 = "2023"       (年份)  
    # $3 = "12"         (月份)
    # $4 = "25"         (日期)
    
    proxy_pass http://archive/$2/$3/$4/;
}
```

### 3.5 非捕获组


**什么时候用**：只想分组，不想捕获内容
```nginx
# (?:pattern) 表示非捕获组
location ~ ^/(?:image|photo|pic)/(\w+)$ {
    # 只捕获文件名，不捕获image/photo/pic
    try_files /media/$1 =404;
}
```

### 3.6 变量引用的注意事项


**作用域限制**：
```nginx
server {
    # ❌ 错误：$1在这里无效
    set $test $1;
    
    location ~ ^/user/(\d+)$ {
        # ✅ 正确：$1在这里有效
        proxy_pass http://backend/user/$1;
    }
}
```

**变量传递**：
```nginx
location ~ ^/product/(\d+)$ {
    set $product_id $1;
    
    # 传递给其他location
    proxy_pass http://backend;
    proxy_set_header X-Product-ID $product_id;
}
```

---

## 4. 📖 常用正则模式详解


### 4.1 URL路径匹配模式


**静态资源匹配**：
```nginx
# 图片文件
location ~ \.(jpg|jpeg|png|gif|webp|svg)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}

# CSS和JS文件  
location ~ \.(css|js)$ {
    expires 1M;
    gzip on;
}

# 字体文件
location ~ \.(ttf|woff|woff2|eot)$ {
    expires 1y;
    add_header Access-Control-Allow-Origin "*";
}
```

**API接口匹配**：
```nginx
# RESTful API模式
location ~ ^/api/v(\d+)/users/(\d+)$ {
    # $1 = API版本号
    # $2 = 用户ID
    proxy_pass http://api_backend/v$1/user.php?id=$2;
}

# 分页接口
location ~ ^/api/posts/page/(\d+)/?$ {
    proxy_pass http://backend/posts.php?page=$1;
}
```

### 4.2 移动端检测模式


**User-Agent检测**：
```nginx
# 移动设备检测
location / {
    if ($http_user_agent ~ "(Mobile|Android|iPhone|iPad)") {
        return 301 https://m.example.com$request_uri;
    }
    
    try_files $uri $uri/ /index.html;
}

# 微信浏览器检测
location / {
    if ($http_user_agent ~ "MicroMessenger") {
        proxy_pass http://wechat_backend;
        break;
    }
}
```

### 4.3 文件扩展名匹配


**精确匹配**：
```nginx
# 只允许特定图片格式
location ~ ^/upload/.*\.(jpg|png|gif)$ {
    root /var/www/uploads;
}

# 禁止访问源码文件
location ~ \.(php|asp|jsp|py)$ {
    return 403;
}
```

**忽略大小写**：
```nginx
# ~* 表示忽略大小写匹配
location ~* \.(jpg|jpeg|png|gif)$ {
    # JPG, jpg, Jpg 都能匹配
    expires 30d;
}
```

### 4.4 参数验证模式


**数字验证**：
```nginx
# 用户ID必须是正整数
location ~ ^/user/([1-9]\d*)/?$ {
    proxy_pass http://backend/user.php?id=$1;
}

# 页码验证（1-9999）
location ~ ^/list/page/([1-9]\d{0,3})/?$ {
    proxy_pass http://backend/list.php?page=$1;
}
```

**字符串验证**：
```nginx
# 用户名格式：字母开头，字母数字下划线，3-20位
location ~ ^/profile/([a-zA-Z][a-zA-Z0-9_]{2,19})/?$ {
    proxy_pass http://backend/profile.php?username=$1;
}
```

### 4.5 时间日期模式


**日期格式**：
```nginx
# YYYY-MM-DD格式
location ~ ^/archive/(20\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])/ {
    # $1 = 年份
    # $2 = 月份  
    # $3 = 日期
    root /var/www/archive/$1/$2;
}

# 年月格式：2023/12
location ~ ^/blog/(\d{4})/(\d{2})/?$ {
    try_files /blog/$1-$2.html =404;
}
```

### 4.6 防盗链模式


**简单防盗链**：
```nginx
location ~* \.(jpg|png|gif)$ {
    valid_referers none blocked *.example.com example.com;
    if ($invalid_referer) {
        return 403;
    }
}
```

**高级防盗链**：
```nginx
location ~* \.(jpg|png|gif)$ {
    if ($http_referer !~ "^https?://(www\.)?example\.com") {
        return 403 "Hotlinking not allowed";
    }
}
```

---

## 5. ⚡ 正则性能优化


### 5.1 性能影响因素


**为什么要关心性能**：
```
每个请求都要经过正则匹配
高并发网站每秒几万个请求
如果正则写得慢，服务器就卡住了

就像收费站：
- 好的正则 = 快速通道，车辆快速通过
- 差的正则 = 拥堵路口，大家都要等
```

**主要性能因素**：
- **回溯**：正则引擎走弯路
- **贪婪匹配**：尽可能多匹配字符
- **复杂嵌套**：多层分组嵌套
- **位置顺序**：常用规则放前面

### 5.2 回溯问题与解决


**什么是回溯**：
```
想象正则引擎是个迷路的人：
- 走到死胡同就要退回来重新找路
- 退回来的过程就叫"回溯"
- 回溯太多就很慢

例子：正则 ^(a+)+b$ 匹配 "aaaaaaaaac"
引擎会尝试很多种组合方式，最后发现匹配不上
这个过程很耗时
```

**避免回溯的方法**：
```nginx
# ❌ 容易回溯的写法
location ~ ^(.+)+/(.+)$ {
    # (.+)+ 这种嵌套容易导致回溯
}

# ✅ 优化后的写法
location ~ ^([^/]+)/(.+)$ {
    # [^/]+ 明确指定不包含斜杠，避免回溯
}
```

### 5.3 贪婪与非贪婪匹配


**贪婪匹配**：默认尽可能多匹配
```nginx
# 贪婪匹配示例
location ~ ^/(.+)/admin$ {
    # 对于 /a/b/c/admin
    # .+ 会匹配 "a/b/c"（尽可能长）
}
```

**非贪婪匹配**：加 ? 表示尽可能少匹配
```nginx
# 非贪婪匹配
location ~ ^/(.+?)/admin/ {
    # 对于 /a/admin/test
    # .+? 只匹配 "a"（尽可能短）
}
```

### 5.4 匹配顺序优化


**按频率排序**：把最常匹配的放前面
```nginx
# ✅ 优化：常用的放前面
location ~ \.(jpg|png|gif)$ {
    # 图片请求最多，放最前面
}

location ~ \.(css|js)$ {
    # 样式脚本其次
}

location ~ \.(pdf|doc|zip)$ {
    # 下载文件较少，放后面
}
```

### 5.5 编译优化技巧


**使用具体字符代替通配符**：
```nginx
# ❌ 慢：用点号匹配任意字符
location ~ ^/api/.*/status$ {
}

# ✅ 快：明确指定允许的字符
location ~ ^/api/[a-z0-9_]+/status$ {
}
```

**避免不必要的捕获**：
```nginx
# ❌ 不必要的捕获
location ~ ^/static/(.*\.(css|js))$ {
    expires 1y;
}

# ✅ 只捕获需要的部分
location ~ ^/static/.*\.(css|js)$ {
    expires 1y;
}
```

### 5.6 性能测试建议


**简单测试方法**：
```bash
# 使用ab工具测试
ab -n 1000 -c 10 http://yourdomain.com/test-url

# 观察nginx访问日志中的响应时间
tail -f /var/log/nginx/access.log
```

**监控指标**：
- **响应时间**：请求处理时间
- **CPU使用率**：正则计算消耗
- **内存使用**：复杂正则的内存开销

---

## 6. 🔍 调试与测试工具


### 6.1 Nginx配置测试


**基本语法检查**：
```bash
# 检查配置文件语法
sudo nginx -t

# 检查指定配置文件
sudo nginx -t -c /path/to/nginx.conf

# 显示详细错误信息
sudo nginx -T
```

**配置重载**：
```bash
# 重新加载配置（不中断服务）
sudo nginx -s reload

# 查看nginx进程
ps aux | grep nginx
```

### 6.2 正则表达式在线测试


**推荐在线工具**：
- **regex101.com**：功能最强大
- **regexr.com**：界面友好
- **regexpal.com**：简单易用

**测试流程**：
```
1. 把你的正则表达式粘贴到工具中
2. 输入测试字符串
3. 查看匹配结果和捕获组
4. 调整正则表达式直到满意
5. 复制到nginx配置中
```

### 6.3 日志调试技巧


**开启调试日志**：
```nginx
# 在http块中添加
error_log /var/log/nginx/debug.log debug;

# 在server块中添加  
access_log /var/log/nginx/access.log combined;
```

**添加调试信息**：
```nginx
location ~ ^/api/(\d+)$ {
    # 记录捕获的变量
    access_log /var/log/nginx/api.log 
               "$time_local $request $1";
    
    proxy_pass http://backend/api.php?id=$1;
}
```

### 6.4 实时测试方法


**使用curl测试**：
```bash
# 测试基本匹配
curl -I http://yourdomain.com/api/123

# 测试User-Agent匹配
curl -H "User-Agent: Mobile" http://yourdomain.com/

# 测试Referer匹配
curl -H "Referer: http://google.com" http://yourdomain.com/image.jpg
```

**浏览器测试**：
```
1. 打开浏览器开发者工具
2. 访问测试URL
3. 查看Network标签中的响应
4. 检查是否按预期重定向或处理
```

### 6.5 常见错误排查


**正则不匹配**：
```nginx
# 检查步骤：
# 1. 确认正则语法正确
# 2. 检查特殊字符是否需要转义
# 3. 验证测试URL格式
# 4. 查看nginx错误日志

# 调试技巧：先用简单正则测试
location ~ ^/test {
    return 200 "matched";
}
```

**变量引用错误**：
```nginx
# 常见问题：变量作用域
location ~ ^/user/(\d+)$ {
    set $user_id $1;  # ✅ 正确：先保存到变量
    
    # ❌ 错误：在if中直接使用$1可能有问题
    if ($arg_debug = "1") {
        proxy_pass http://debug/user/$user_id;  # ✅ 使用保存的变量
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 正则表达式：用特殊符号描述文本模式的语言
🔸 捕获组：用圆括号创建，可以引用匹配的内容
🔸 元字符：. * + ? ^ $ [] {} () | 等有特殊含义的字符
🔸 变量引用：$1 $2 $3 引用捕获组的内容
🔸 匹配修饰符：~ 区分大小写，~* 忽略大小写
```

### 7.2 关键语法速查


**基础语法**：
```
.       → 任意字符（除换行）
\d      → 数字 [0-9]
\w      → 单词字符 [a-zA-Z0-9_]
\s      → 空白字符
+       → 一次或多次
*       → 零次或多次
?       → 零次或一次
^       → 开始位置
$       → 结束位置
[]      → 字符类
()      → 捕获组
|       → 或者
```

**数量修饰符**：
```
{n}     → 恰好n次
{n,}    → 至少n次  
{n,m}   → n到m次
```

### 7.3 实用模式库


**URL匹配**：
```nginx
# 数字ID
^/user/(\d+)$

# 字母数字组合
^/product/([a-zA-Z0-9_-]+)$

# 日期格式
^/archive/(\d{4})/(\d{2})/(\d{2})$

# 文件扩展名
\.(jpg|png|gif|css|js)$
```

**参数验证**：
```nginx
# 手机号
^1[3-9]\d{9}$

# 邮箱简单验证  
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

# 用户名（字母开头，3-20位）
^[a-zA-Z][a-zA-Z0-9_]{2,19}$
```

### 7.4 性能优化要点


**优化原则**：
- **明确指定**：用 `[^/]+` 代替 `.+`
- **避免嵌套**：减少 `(.+)+` 这样的写法
- **合理排序**：常用规则放前面
- **适度捕获**：只捕获需要的部分

### 7.5 调试流程


**标准调试步骤**：
```
1. 在线工具测试正则语法
2. nginx -t 检查配置语法
3. 简单URL测试基本匹配
4. 查看nginx日志确认结果
5. 逐步增加复杂度
```

### 7.6 常见陷阱


**要特别注意**：
- **转义字符**：在nginx中某些字符需要转义
- **变量作用域**：$1 $2 只在对应location中有效
- **贪婪匹配**：默认会尽可能多匹配
- **大小写敏感**：~ 和 ~* 的区别
- **匹配顺序**：nginx按配置顺序匹配，第一个匹配的生效

**核心记忆口诀**：
- 正则匹配有模式，圆括号里把内容抓
- 美元符号来引用，一二三四不会差  
- 性能优化很重要，明确字符少回溯
- 测试调试要仔细，在线工具来帮忙