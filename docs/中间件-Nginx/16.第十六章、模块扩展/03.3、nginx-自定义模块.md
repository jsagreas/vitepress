---
title: 3、nginx-自定义模块
---
## 📚 目录

1. [模块开发基础概念](#1-模块开发基础概念)
2. [Nginx模块结构详解](#2-Nginx模块结构详解)
3. [编译集成方法](#3-编译集成方法)
4. [配置指令开发](#4-配置指令开发)
5. [钩子函数机制](#5-钩子函数机制)
6. [调试测试方法](#6-调试测试方法)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🚀 模块开发基础概念


### 1.1 什么是Nginx模块


**通俗理解**：就像给手机安装APP一样，Nginx模块就是给Nginx"安装功能包"

```
生活中的类比：
基础手机 + 微信APP = 聊天功能
基础手机 + 相机APP = 拍照功能
基础手机 + 地图APP = 导航功能

Nginx也是这样：
基础Nginx + HTTP模块 = 处理网页请求
基础Nginx + SSL模块 = 支持HTTPS加密
基础Nginx + 自定义模块 = 你想要的特殊功能
```

**🔍 核心作用**：
- **功能扩展**：给Nginx添加新的处理能力
- **逻辑定制**：实现特定的业务需求
- **性能优化**：用C语言实现高效处理
- **系统集成**：与其他系统无缝对接

### 1.2 为什么要开发自定义模块


**💼 实际需求场景**：
```
场景1：特殊认证需求
问题：公司有自己的用户系统，需要特殊的认证方式
解决：开发认证模块，直接在Nginx层面验证用户

场景2：日志格式定制
问题：需要特殊格式的访问日志，便于数据分析
解决：开发日志模块，按需要的格式记录信息

场景3：请求过滤处理
问题：需要根据复杂规则过滤请求
解决：开发过滤模块，实现精确的请求控制
```

**🎯 开发价值**：
- **性能优势**：C语言编写，执行效率极高
- **深度集成**：与Nginx核心深度融合
- **灵活定制**：完全按照需求设计功能
- **维护便利**：模块化设计，便于升级维护

### 1.3 模块开发的难度层次


```
📊 难度等级：
🟢 配置调整：修改nginx.conf配置文件
🟡 脚本扩展：使用Lua脚本添加功能  
🟠 模块定制：开发简单的自定义模块
🔴 核心开发：修改Nginx核心代码

我们重点学习：🟠 模块定制层面
```

---

## 2. 🏗️ Nginx模块结构详解


### 2.1 模块的基本组成


**📋 模块就像一个完整的"功能包"**：

```
模块包含的内容：
┌─────────────────────┐
│  配置指令定义        │ ← 告诉Nginx这个模块有哪些配置项
├─────────────────────┤
│  处理函数实现        │ ← 具体的功能代码
├─────────────────────┤
│  钩子函数注册        │ ← 告诉Nginx什么时候调用这些功能
├─────────────────────┤
│  模块元信息          │ ← 模块的名称、版本等基本信息
└─────────────────────┘
```

### 2.2 模块类型分类


**🔍 按功能分类**：
```
HTTP模块：处理HTTP请求
├── 内容处理模块：修改响应内容
├── 认证模块：用户身份验证
├── 访问控制模块：IP访问限制
└── 日志模块：记录访问信息

过滤模块：处理响应数据
├── 压缩过滤：gzip压缩
├── 内容过滤：敏感词过滤
└── 格式转换：数据格式处理

核心模块：底层功能支持
├── 事件模块：网络事件处理
├── 配置模块：配置文件解析
└── 错误模块：错误处理机制
```

### 2.3 模块代码基本结构


**💻 最简单的模块框架**：
```c
// 第一步：包含必要的头文件
#include <ngx_config.h>
#include <ngx_core.h>
#include <ngx_http.h>

// 第二步：定义配置结构
typedef struct {
    ngx_str_t  output_words;  // 存储配置参数
} ngx_http_hello_loc_conf_t;

// 第三步：声明处理函数
static ngx_int_t ngx_http_hello_handler(ngx_http_request_t *r);

// 第四步：定义配置指令
static ngx_command_t ngx_http_hello_commands[] = {
    {
        ngx_string("hello_string"),           // 指令名称
        NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,   // 指令类型
        ngx_conf_set_str_slot,               // 处理函数
        NGX_HTTP_LOC_CONF_OFFSET,            // 配置偏移
        offsetof(ngx_http_hello_loc_conf_t, output_words),
        NULL
    },
    ngx_null_command
};

// 第五步：模块上下文
static ngx_http_module_t ngx_http_hello_module_ctx = {
    NULL,                          // preconfiguration
    NULL,                          // postconfiguration
    NULL,                          // create main configuration
    NULL,                          // init main configuration
    NULL,                          // create server configuration
    NULL,                          // merge server configuration
    ngx_http_hello_create_loc_conf, // create location configuration
    ngx_http_hello_merge_loc_conf   // merge location configuration
};

// 第六步：模块定义
ngx_module_t ngx_http_hello_module = {
    NGX_MODULE_V1,
    &ngx_http_hello_module_ctx,    // module context
    ngx_http_hello_commands,       // module directives
    NGX_HTTP_MODULE,               // module type
    NULL,                          // init master
    NULL,                          // init module
    NULL,                          // init process
    NULL,                          // init thread
    NULL,                          // exit thread
    NULL,                          // exit process
    NULL,                          // exit master
    NGX_MODULE_V1_PADDING
};
```

**🧠 理解要点**：
- **配置结构**：就像定义一个"设置表单"
- **处理函数**：实际干活的代码
- **指令定义**：告诉Nginx如何识别配置
- **模块信息**：模块的"身份证"

---

## 3. 🔧 编译集成方法


### 3.1 编译方式对比


```
📊 三种编译方式：

静态编译：
优点：性能最好，启动快速
缺点：需要重新编译整个Nginx
适用：生产环境，功能稳定

动态编译：
优点：可以随时加载卸载模块
缺点：性能略低，配置复杂
适用：开发测试，功能变化频繁

源码集成：
优点：与Nginx核心深度整合
缺点：维护成本高，升级困难
适用：核心功能模块
```

### 3.2 静态编译集成步骤


**📝 完整编译流程**：

```bash
# 第一步：准备模块代码
mkdir /usr/local/src/ngx_http_hello_module
cd /usr/local/src/ngx_http_hello_module

# 创建config文件
cat > config << 'EOF'
ngx_module_type=HTTP
ngx_module_name=ngx_http_hello_module
ngx_module_srcs="$ngx_addon_dir/ngx_http_hello_module.c"
. auto/module
ngx_addon_name=$ngx_module_name
EOF

# 第二步：下载Nginx源码
wget http://nginx.org/download/nginx-1.24.0.tar.gz
tar -zxf nginx-1.24.0.tar.gz
cd nginx-1.24.0

# 第三步：配置编译选项
./configure \
  --prefix=/usr/local/nginx \
  --add-module=/usr/local/src/ngx_http_hello_module

# 第四步：编译安装
make && make install
```

### 3.3 动态模块编译


**🚀 动态模块的优势**：

```bash
# 编译为动态模块
./configure \
  --prefix=/usr/local/nginx \
  --add-dynamic-module=/path/to/module

# 编译后会生成.so文件
make modules

# 在nginx.conf中加载
load_module modules/ngx_http_hello_module.so;
```

**💡 使用建议**：
- **开发阶段**：使用动态模块，便于调试
- **生产环境**：使用静态编译，性能更好
- **功能测试**：动态加载，不影响主服务

---

## 4. ⚙️ 配置指令开发


### 4.1 指令类型详解


**📋 指令的作用范围**：

```
指令上下文类型：
┌─────────────────┐
│ NGX_MAIN_CONF   │ ← 主配置段（全局有效）
├─────────────────┤
│ NGX_HTTP_CONF   │ ← HTTP配置段
├─────────────────┤  
│ NGX_HTTP_SRV_CONF│ ← Server配置段
├─────────────────┤
│ NGX_HTTP_LOC_CONF│ ← Location配置段
└─────────────────┘

参数数量类型：
NGX_CONF_NOARGS  ← 无参数指令
NGX_CONF_TAKE1   ← 接受1个参数
NGX_CONF_TAKE2   ← 接受2个参数
NGX_CONF_1MORE   ← 接受1个或多个参数
```

### 4.2 实际指令开发示例


**🔧 开发一个简单的配置指令**：

```c
// 定义配置结构
typedef struct {
    ngx_str_t  message;     // 消息内容
    ngx_flag_t enabled;     // 启用开关
    ngx_uint_t count;       // 计数器
} ngx_http_demo_loc_conf_t;

// 配置指令数组
static ngx_command_t ngx_http_demo_commands[] = {
    // 字符串参数指令
    {
        ngx_string("demo_message"),
        NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
        ngx_conf_set_str_slot,
        NGX_HTTP_LOC_CONF_OFFSET,
        offsetof(ngx_http_demo_loc_conf_t, message),
        NULL
    },
    
    // 开关类型指令
    {
        ngx_string("demo_enabled"),
        NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
        ngx_conf_set_flag_slot,
        NGX_HTTP_LOC_CONF_OFFSET,
        offsetof(ngx_http_demo_loc_conf_t, enabled),
        NULL
    },
    
    // 数字参数指令
    {
        ngx_string("demo_count"),
        NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
        ngx_conf_set_num_slot,
        NGX_HTTP_LOC_CONF_OFFSET,
        offsetof(ngx_http_demo_loc_conf_t, count),
        NULL
    },
    
    ngx_null_command
};
```

**📝 配置文件使用示例**：
```nginx
# 在nginx.conf中的使用方式
location /demo {
    demo_message "Hello from custom module!";
    demo_enabled on;
    demo_count 10;
}
```

### 4.3 配置验证和默认值


**✅ 配置创建和合并函数**：

```c
// 创建location配置
static void *
ngx_http_demo_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_demo_loc_conf_t *conf;
    
    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_demo_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }
    
    // 设置默认值
    conf->enabled = NGX_CONF_UNSET;
    conf->count = NGX_CONF_UNSET_UINT;
    
    return conf;
}

// 合并配置（子配置继承父配置）
static char *
ngx_http_demo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_demo_loc_conf_t *prev = parent;
    ngx_http_demo_loc_conf_t *conf = child;
    
    ngx_conf_merge_str_value(conf->message, prev->message, "Default Message");
    ngx_conf_merge_value(conf->enabled, prev->enabled, 1);
    ngx_conf_merge_uint_value(conf->count, prev->count, 100);
    
    return NGX_CONF_OK;
}
```

---

## 5. 🎣 钩子函数机制


### 5.1 HTTP请求处理流程


**🔄 请求的完整生命周期**：

```
HTTP请求处理流程：
客户端请求 → 接收阶段 → 解析阶段 → 处理阶段 → 响应阶段
    ↓           ↓         ↓         ↓         ↓
  连接建立    读取数据   解析协议   业务处理   发送响应

每个阶段都有对应的钩子：
┌─────────────────┐
│ NGX_HTTP_POST_READ_PHASE      │ ← 读取请求头后
├─────────────────┤
│ NGX_HTTP_SERVER_REWRITE_PHASE │ ← server段重写
├─────────────────┤
│ NGX_HTTP_FIND_CONFIG_PHASE    │ ← 查找location配置
├─────────────────┤
│ NGX_HTTP_REWRITE_PHASE        │ ← location段重写
├─────────────────┤
│ NGX_HTTP_ACCESS_PHASE         │ ← 访问控制检查
├─────────────────┤
│ NGX_HTTP_CONTENT_PHASE        │ ← 内容生成处理
├─────────────────┤
│ NGX_HTTP_LOG_PHASE            │ ← 访问日志记录
└─────────────────┘
```

### 5.2 注册处理器函数


**🔗 将模块处理函数挂接到请求流程**：

```c
// 模块后配置函数（在这里注册处理器）
static ngx_int_t
ngx_http_demo_postconfiguration(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;
    
    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);
    
    // 在内容处理阶段注册处理器
    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }
    
    *h = ngx_http_demo_handler;  // 指向我们的处理函数
    
    return NGX_OK;
}

// 更新模块上下文，添加postconfiguration
static ngx_http_module_t ngx_http_demo_module_ctx = {
    NULL,                               /* preconfiguration */
    ngx_http_demo_postconfiguration,    /* postconfiguration */
    // ... 其他回调函数
};
```

### 5.3 编写处理器函数


**🔨 实际的业务处理逻辑**：

```c
static ngx_int_t
ngx_http_demo_handler(ngx_http_request_t *r)
{
    ngx_http_demo_loc_conf_t *dlcf;
    ngx_buf_t                *b;
    ngx_chain_t              out;
    
    // 获取配置
    dlcf = ngx_http_get_module_loc_conf(r, ngx_http_demo_module);
    
    // 检查是否启用
    if (!dlcf->enabled) {
        return NGX_DECLINED;  // 不处理，交给下一个处理器
    }
    
    // 只处理GET和HEAD请求
    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
        return NGX_HTTP_NOT_ALLOWED;
    }
    
    // 设置响应头
    r->headers_out.content_type_len = sizeof("text/plain") - 1;
    ngx_str_set(&r->headers_out.content_type, "text/plain");
    r->headers_out.status = NGX_HTTP_OK;
    
    // 创建响应内容
    b = ngx_pcalloc(r->pool, sizeof(ngx_buf_t));
    out.buf = b;
    out.next = NULL;
    
    // 设置响应数据
    b->pos = dlcf->message.data;
    b->last = dlcf->message.data + dlcf->message.len;
    b->memory = 1;
    b->last_buf = 1;
    
    // 发送响应头
    ngx_http_send_header(r);
    
    // 发送响应体
    return ngx_http_output_filter(r, &out);
}
```

**🧠 理解要点**：
- **返回值含义**：NGX_OK继续，NGX_DECLINED跳过，NGX_ERROR错误
- **内存管理**：使用请求池分配内存，自动回收
- **响应格式**：设置正确的Content-Type和状态码

---

## 6. 🐛 调试测试方法


### 6.1 编译时调试技巧


**🔍 编译问题排查**：

```bash
# 启用调试信息编译
./configure --add-module=/path/to/module --with-debug

# 查看详细编译日志
make 2>&1 | tee build.log

# 常见编译错误及解决：
错误：undefined reference to 'ngx_xxx'
解决：检查头文件包含和函数名拼写

错误：conflicting types for 'ngx_xxx'
解决：检查函数声明和定义是否一致

错误：module 'ngx_xxx' is not found
解决：检查config文件和模块路径
```

### 6.2 运行时调试方法


**📊 调试信息收集**：

```c
// 在代码中添加调试日志
ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
              "demo module: processing request for URI: %V", &r->uri);

// 错误日志记录
ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
              "demo module: configuration error");

// 变量值检查
ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
              "demo module: message=%V, enabled=%d, count=%d",
              &dlcf->message, dlcf->enabled, dlcf->count);
```

**🛠️ 配置调试环境**：

```nginx
# nginx.conf中启用调试
error_log /var/log/nginx/debug.log debug;

# 启用核心dump
worker_rlimit_core 500M;
working_directory /tmp;

# 测试location
location /debug {
    demo_message "Debug Test Message";
    demo_enabled on;
    demo_count 99;
}
```

### 6.3 功能测试验证


**✅ 测试用例设计**：

```bash
# 基本功能测试
curl -v http://localhost/debug

# 配置参数测试
curl -s http://localhost/debug | grep "Debug Test Message"

# 错误处理测试
curl -X POST http://localhost/debug  # 应该返回405

# 性能压力测试
ab -n 1000 -c 10 http://localhost/debug

# 内存泄漏检测
valgrind --tool=memcheck --leak-check=full nginx -g 'daemon off;'
```

**📋 测试检查清单**：
- [ ] 配置指令是否正确解析
- [ ] 默认值是否正确设置
- [ ] 错误情况是否正确处理
- [ ] 内存是否正确管理
- [ ] 性能是否满足要求

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 模块本质：给Nginx添加功能的代码包
🔸 模块结构：配置指令 + 处理函数 + 钩子注册 + 元信息
🔸 编译方式：静态编译（性能好）vs 动态编译（灵活性好）
🔸 钩子机制：在请求处理的不同阶段插入自定义逻辑
🔸 配置系统：定义指令、设置默认值、验证参数
```

### 7.2 关键理解要点


**🔹 模块开发的价值**
```
为什么开发模块：
- 性能优势：C语言实现，比脚本快很多
- 深度集成：与Nginx核心无缝结合
- 功能定制：完全按需求设计
- 维护方便：模块化设计，便于管理
```

**🔹 开发难度层次**
```
学习路径：
初级：理解现有模块的配置和使用
中级：修改简单模块，添加配置选项
高级：开发完整功能模块，性能优化
专家：深度定制，修改核心逻辑
```

**🔹 实践应用建议**
```
开发策略：
- 先用现有模块：能满足需求就不自己开发
- 再考虑脚本：Lua脚本可以解决大部分需求
- 最后开发模块：确实需要高性能或深度集成时
```

### 7.3 实际应用价值


**💼 企业级应用场景**：
- **认证授权**：集成企业内部用户系统
- **安全防护**：实现复杂的攻击检测和防护
- **性能监控**：收集详细的性能指标数据
- **业务逻辑**：在代理层实现业务规则

**🚀 学习成长路径**：
1. **基础阶段**：理解Nginx架构和现有模块
2. **实践阶段**：修改简单模块，添加功能
3. **提升阶段**：开发完整模块，解决实际问题
4. **专家阶段**：性能优化，架构设计

### 7.4 注意事项和最佳实践


**⚠️ 开发注意事项**：
```
内存管理：
- 使用Nginx内存池，避免内存泄漏
- 注意指针有效性，避免悬空指针

错误处理：
- 完善的错误检查和处理逻辑
- 合适的错误码返回

性能考虑：
- 避免阻塞操作，保持异步特性
- 合理使用缓存，减少重复计算

安全考虑：
- 输入验证，防止注入攻击
- 资源限制，防止耗尽系统资源
```

**🎯 最佳实践建议**：
- **循序渐进**：从简单模块开始，逐步深入
- **参考学习**：研究现有优秀模块的实现
- **充分测试**：功能测试、性能测试、安全测试
- **文档完整**：代码注释、使用说明、配置示例

**核心记忆口诀**：
```
模块开发记住四步骤：
结构定义配置清，钩子注册处理精
编译集成测试验，调试完善保性能
```

### 7.5 进阶学习方向


**📚 深入学习建议**：
- **源码研读**：深入理解Nginx核心架构
- **性能优化**：学习高性能编程技巧
- **生产实践**：在实际项目中应用和优化
- **社区参与**：贡献开源模块，与同行交流

模块开发是Nginx进阶的重要技能，掌握后可以让你在Web服务器领域游刃有余，解决各种复杂的业务需求！