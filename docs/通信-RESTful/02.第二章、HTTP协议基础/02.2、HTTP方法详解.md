---
title: 2、HTTP方法详解
---
## 📚 目录

1. [HTTP方法概述](#1-HTTP方法概述)
2. [核心HTTP方法详解](#2-核心HTTP方法详解)
3. [幂等性与安全性](#3-幂等性与安全性)
4. [方法对比与选择](#4-方法对比与选择)
5. [开发中的常见问题](#5-开发中的常见问题)
6. [最佳实践指南](#6-最佳实践指南)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌐 HTTP方法概述


### 1.1 什么是HTTP方法？


HTTP方法就像是你对服务器说话的**动词**，告诉服务器你想做什么操作。

```
想象成日常对话：
"给我看看那本书"     → GET（获取）
"帮我写个便条"       → POST（创建）
"把这个改成那样"     → PUT（更新）
"删掉这个东西"       → DELETE（删除）
```

### 1.2 HTTP方法分类


```
常用方法（核心必知）：
┌─────────┬──────────┬──────────────┐
│  方法   │   用途   │    说明      │
├─────────┼──────────┼──────────────┤
│  GET    │  获取    │ 拿数据看看   │
│  POST   │  创建    │ 新建个东西   │
│  PUT    │  更新    │ 整个替换掉   │
│  PATCH  │  修改    │ 改一部分     │
│  DELETE │  删除    │ 删掉这个     │
└─────────┴──────────┴──────────────┘

辅助方法（了解即可）：
- HEAD：只要头信息，不要内容
- OPTIONS：问问服务器支持什么操作
```

---

## 2. 📋 核心HTTP方法详解


### 2.1 GET方法 - "给我看看"


**🔸 基本概念**
GET就是"获取"的意思，就像你去图书馆借书，只是看看，不会改变书本身。

```http
GET /api/users/123 HTTP/1.1
Host: example.com

↓ 服务器回应

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com"
}
```

**💡 GET的特点**
- **只读操作**：只获取数据，不修改任何东西
- **可以缓存**：浏览器可以把结果存起来，下次直接用
- **参数在URL里**：`/api/users?page=1&size=10`
- **可以收藏**：URL可以加书签

> 💡 **生活例子**：就像在商店橱窗外看商品，只看不买，不会影响商品本身

### 2.2 POST方法 - "帮我新建个"


**🔸 基本概念**
POST是"投递、发送"的意思，就像往邮箱里投信，会产生新的东西。

```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "李四",
  "email": "lisi@example.com"
}

↓ 服务器回应

HTTP/1.1 201 Created
Location: /api/users/124
Content-Type: application/json

{
  "id": 124,
  "name": "李四",
  "email": "lisi@example.com"
}
```

**💡 POST的特点**
- **创建新资源**：每次调用都会产生新的东西
- **数据在请求体里**：不会在URL中暴露敏感信息
- **不能缓存**：每次都要重新处理
- **不可重复**：重复提交会创建多个资源

> 💡 **生活例子**：就像往银行存钱，每次存都会增加你的余额

### 2.3 PUT方法 - "整个替换掉"


**🔸 基本概念**
PUT是"放置、替换"的意思，就像重新写一份文档，把原来的完全替换掉。

```http
PUT /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "id": 123,
  "name": "张三",
  "email": "zhangsan_new@example.com",
  "phone": "13800138000"
}

↓ 服务器回应

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "张三",
  "email": "zhangsan_new@example.com",
  "phone": "13800138000"
}
```

**💡 PUT的特点**
- **整体替换**：提供完整的资源信息
- **可重复执行**：多次执行结果一样
- **必须指定ID**：通常在URL中指定要更新的资源

> 💡 **生活例子**：就像重新装修房子，把原来的装修全部拆掉重新来

### 2.4 PATCH方法 - "改一部分"


**🔸 基本概念**
PATCH是"补丁、修补"的意思，就像给衣服打补丁，只改需要改的地方。

```http
PATCH /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "email": "zhangsan_new@example.com"
}

↓ 服务器回应

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "张三",          ← 没变
  "email": "zhangsan_new@example.com",  ← 只改了这个
  "phone": "13800138000"   ← 没变
}
```

**💡 PATCH的特点**
- **部分更新**：只提供要修改的字段
- **节省带宽**：不需要传输完整数据
- **灵活性高**：可以只改一个字段

> 💡 **生活例子**：就像给手机贴个新的屏幕保护膜，其他部分不动

### 2.5 DELETE方法 - "删掉这个"


**🔸 基本概念**
DELETE就是"删除"的意思，就像把东西扔进垃圾桶。

```http
DELETE /api/users/123 HTTP/1.1
Host: example.com

↓ 服务器回应

HTTP/1.1 204 No Content
```

**💡 DELETE的特点**
- **删除资源**：把指定的资源移除
- **可重复执行**：删除已删除的资源不会报错
- **通常无响应体**：删除成功一般返回空内容

> 💡 **生活例子**：就像把文件拖到回收站，文件就没了

### 2.6 HEAD方法 - "只要信息不要内容"


**🔸 基本概念**
HEAD就像GET，但只要"头部信息"，不要具体内容。

```http
HEAD /api/users/123 HTTP/1.1
Host: example.com

↓ 服务器回应（只有头部，没有body）

HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 85
Last-Modified: Mon, 08 Jan 2025 10:30:00 GMT
```

> 💡 **生活例子**：就像问快递员"我的包裹到了吗？"，不需要看包裹内容

### 2.7 OPTIONS方法 - "你支持什么操作？"


**🔸 基本概念**
OPTIONS是"选项"的意思，用来询问服务器支持哪些操作。

```http
OPTIONS /api/users/123 HTTP/1.1
Host: example.com

↓ 服务器回应

HTTP/1.1 200 OK
Allow: GET, PUT, PATCH, DELETE
Access-Control-Allow-Methods: GET, PUT, PATCH, DELETE
```

> 💡 **生活例子**：就像问餐厅"你们有什么菜？"，先了解有什么选择

---

## 3. ⚖️ 幂等性与安全性


### 3.1 什么是安全性？


**🔸 安全性定义**
安全的HTTP方法就是**"只看不动"**的方法，不会改变服务器上的任何数据。

```
安全方法：
✅ GET     - 只是获取数据，不修改
✅ HEAD    - 只获取元信息，不修改
✅ OPTIONS - 只询问支持的方法，不修改

非安全方法：
❌ POST   - 会创建新数据
❌ PUT    - 会修改数据
❌ PATCH  - 会修改数据
❌ DELETE - 会删除数据
```

> 💡 **简单记忆**：如果多次执行不会"弄坏"任何东西，就是安全的

### 3.2 什么是幂等性？


**🔸 幂等性定义**
幂等的意思是**"做一次和做很多次结果一样"**。

```
生活中的幂等例子：
- 开灯：已经开着的灯再按开关还是开着 ✅
- 关电视：已经关着的电视再关还是关着 ✅
- 往杯子里倒水：每次倒都会增加水量 ❌
```

**🔸 HTTP方法的幂等性**

```
幂等方法：
✅ GET    - 获取同一个资源多次，结果一样
✅ PUT    - 用同样数据更新多次，结果一样
✅ DELETE - 删除同一个资源多次，结果一样（都是没有）
✅ HEAD   - 获取元信息多次，结果一样

非幂等方法：
❌ POST  - 每次都会创建新资源
❌ PATCH - 取决于具体实现（通常非幂等）
```

### 3.3 为什么要理解幂等性？


**🔸 实际应用场景**

```
网络重试：
用户点击"提交订单" → 网络卡了 → 用户又点了一次
如果用POST：可能创建两个订单 😱
如果设计成幂等：多次点击只创建一个订单 😊

API设计：
幂等的API可以安全地重试
非幂等的API需要额外的防重复机制
```

---

## 4. 📊 方法对比与选择


### 4.1 核心方法对比表


| 方法 | **用途** | **安全性** | **幂等性** | **常见场景** |
|------|---------|-----------|-----------|-------------|
| `GET` | **获取资源** | `✅ 安全` | `✅ 幂等` | `查看用户信息、商品列表` |
| `POST` | **创建资源** | `❌ 非安全` | `❌ 非幂等` | `注册用户、提交订单` |
| `PUT` | **替换资源** | `❌ 非安全` | `✅ 幂等` | `更新用户完整信息` |
| `PATCH` | **部分更新** | `❌ 非安全` | `❌ 非幂等` | `修改用户邮箱` |
| `DELETE` | **删除资源** | `❌ 非安全` | `✅ 幂等` | `删除用户账号` |

### 4.2 PATCH vs PUT 详细对比


**🔸 核心区别**

```
PUT - 完全替换：
原数据：{"name": "张三", "age": 25, "email": "old@test.com"}
PUT请求：{"name": "张三", "age": 26, "email": "new@test.com"}
结果：  {"name": "张三", "age": 26, "email": "new@test.com"}
说明：必须提供完整数据，相当于重新创建

PATCH - 部分修改：
原数据：{"name": "张三", "age": 25, "email": "old@test.com"}
PATCH请求：{"email": "new@test.com"}
结果：   {"name": "张三", "age": 25, "email": "new@test.com"}
说明：只提供要修改的字段，其他保持不变
```

**🔸 选择指南**

```
使用PUT的场景：
✅ 有完整的资源数据
✅ 需要确保数据一致性
✅ 替换整个资源内容

使用PATCH的场景：
✅ 只修改部分字段
✅ 节省网络带宽
✅ 字段很多但只改少数几个
```

### 4.3 实际选择流程图


```
开始
  ↓
需要获取数据？ ──Yes──→ 使用GET
  ↓ No
需要创建新资源？ ──Yes──→ 使用POST
  ↓ No
需要删除资源？ ──Yes──→ 使用DELETE
  ↓ No
需要更新资源？ ──Yes──→ 有完整数据？ ──Yes──→ 使用PUT
  ↓                      ↓ No
其他操作？               使用PATCH
  ↓
使用对应方法
```

---

## 5. 🚨 开发中的常见问题


### 5.1 POST和PUT的混用问题


**❌ 错误做法**
```http
// 错误：用POST做更新操作
POST /api/users/123/update
{
  "email": "new@test.com"
}

// 问题：语义不清晰，不符合REST规范
```

**✅ 正确做法**
```http
// 正确：用PUT做完整更新
PUT /api/users/123
{
  "id": 123,
  "name": "张三",
  "email": "new@test.com",
  "phone": "13800138000"
}

// 或者用PATCH做部分更新
PATCH /api/users/123
{
  "email": "new@test.com"
}
```

### 5.2 GET方法的误用


**❌ 错误做法**
```http
// 错误：用GET做删除操作
GET /api/users/123/delete

// 问题：违反了GET的安全性原则
```

**✅ 正确做法**
```http
// 正确：用DELETE做删除操作
DELETE /api/users/123
```

### 5.3 幂等性设计错误


**❌ 错误的PATCH实现**
```javascript
// 错误：每次调用都累加
PATCH /api/users/123
{
  "loginCount": "+1"  // 每次都加1，非幂等
}
```

**✅ 正确的PATCH实现**
```javascript
// 正确：设置绝对值
PATCH /api/users/123
{
  "loginCount": 10  // 设置为具体值，相对幂等
}
```

### 5.4 缺少幂等性保护


**🔸 问题场景**
```
用户提交表单 → 网络慢 → 用户重复点击 → 创建多条重复数据
```

**🔸 解决方案**
```javascript
// 方案1：前端防重复提交
let isSubmitting = false;
function submitForm() {
  if (isSubmitting) return;
  isSubmitting = true;
  // 提交请求...
}

// 方案2：服务端幂等性设计
POST /api/orders
{
  "idempotencyKey": "uuid-12345",  // 幂等性键
  "productId": 123,
  "quantity": 1
}
```

---

## 6. 🎯 最佳实践指南


### 6.1 方法选择最佳实践


**🔸 RESTful URL设计**
```http
✅ 好的设计：
GET    /api/users           # 获取用户列表
GET    /api/users/123       # 获取特定用户
POST   /api/users           # 创建新用户
PUT    /api/users/123       # 更新用户（完整）
PATCH  /api/users/123       # 更新用户（部分）
DELETE /api/users/123       # 删除用户

❌ 不好的设计：
GET /api/getUsers           # 动词冗余
POST /api/users/123/update  # 语义混乱
GET /api/deleteUser?id=123  # 方法错误
```

### 6.2 响应状态码最佳实践


```http
GET 成功：200 OK
POST 创建成功：201 Created
PUT 更新成功：200 OK
PATCH 更新成功：200 OK
DELETE 删除成功：204 No Content

错误情况：
400 Bad Request      # 请求格式错误
401 Unauthorized     # 未授权
403 Forbidden        # 禁止访问
404 Not Found        # 资源不存在
500 Internal Error   # 服务器内部错误
```

### 6.3 安全性考虑


> ⚠️ **注意**：敏感操作（创建、更新、删除）不要用GET

```http
❌ 危险：
GET /api/users/123/delete  # GET应该是安全的

✅ 安全：
DELETE /api/users/123      # 用正确的方法
```

### 6.4 幂等性设计建议


**🔸 设计幂等的API**
```javascript
// 创建订单时使用客户端生成的ID
PUT /api/orders/order-uuid-12345
{
  "products": [...],
  "totalAmount": 100
}

// 多次调用只会创建一个订单
```

**🔸 处理非幂等操作**
```javascript
// 使用幂等性键
POST /api/payments
Headers: Idempotency-Key: payment-uuid-67890
{
  "amount": 100,
  "orderId": "order-123"
}

// 相同key的重复请求返回相同结果
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 HTTP方法本质：告诉服务器你想做什么的"动词"
🔸 核心方法：GET(获取)、POST(创建)、PUT(替换)、PATCH(修改)、DELETE(删除)
🔸 安全性：GET、HEAD不会改变服务器数据
🔸 幂等性：GET、PUT、DELETE做多次和做一次结果一样
🔸 语义区别：PUT是完全替换，PATCH是部分修改
```

### 7.2 关键理解要点


**🔹 方法选择的核心原则**
```
问自己三个问题：
1. 我要做什么？（获取、创建、更新、删除）
2. 是否会改变数据？（安全性）
3. 重复操作有没有副作用？（幂等性）
```

**🔹 PUT vs PATCH的选择**
```
简单判断：
- 有完整数据 → 用PUT
- 只改部分字段 → 用PATCH
- 要求幂等性 → 优选PUT
```

**🔹 幂等性的重要意义**
```
实际价值：
- 网络重试安全
- 防止重复操作
- 系统更稳定
- 用户体验更好
```

### 7.3 实际应用指导


- **API设计**：选择正确的HTTP方法表达操作语义
- **前端开发**：根据操作类型选择对应方法
- **错误处理**：理解方法特性，设计合理的重试机制
- **性能优化**：利用GET的缓存特性，避免不必要的数据传输
- **安全考虑**：敏感操作不使用GET方法

**核心记忆口诀**：
- GET获取要安全，POST创建每次新
- PUT替换要完整，PATCH修改改一点
- DELETE删除可重复，幂等安全要记清