---
title: 2、常见攻击防护
---
## 📚 目录

1. [安全防护概述](#1-安全防护概述)
2. [SQL注入防护](#2-sql注入防护)
3. [XSS攻击防护](#3-xss攻击防护)
4. [CSRF攻击防护](#4-csrf攻击防护)
5. [重放攻击防护](#5-重放攻击防护)
6. [暴力破解防护](#6-暴力破解防护)
7. [DDoS防护](#7-ddos防护)
8. [CORS与跨域安全](#8-cors与跨域安全)
9. [参数校验与防注入](#9-参数校验与防注入)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🛡️ 安全防护概述


### 1.1 为什么需要安全防护


**🎯 现实场景理解**
想象你的API就像是一家银行的柜台：
- 客户来办业务（用户发请求）
- 柜员处理业务（服务器处理请求）
- 但总有些坏人想搞破坏（黑客攻击）

```
正常用户请求：
客户端 → [安全检查] → API服务器 → 数据库
   ↓         ✅           ↓        ↓
取款1000元   身份验证     处理请求   扣除余额

恶意攻击请求：
黑客 → [安全检查] → API服务器 → 数据库
  ↓       ❌         ↓        ↓
注入代码   拦截阻止    拒绝处理   数据安全
```

### 1.2 常见攻击类型速览


| 攻击类型 | **简单理解** | **危害** | **防护难度** |
|---------|------------|---------|-------------|
| 🔍 **SQL注入** | `恶意SQL代码混入查询` | `数据泄露、删除` | `⭐⭐` |
| 🕷️ **XSS攻击** | `网页植入恶意脚本` | `盗取用户信息` | `⭐⭐⭐` |
| 🎭 **CSRF攻击** | `伪造用户身份请求` | `非法操作账户` | `⭐⭐⭐` |
| 🔄 **重放攻击** | `重复发送旧请求` | `重复扣费操作` | `⭐⭐` |
| 🔨 **暴力破解** | `疯狂尝试密码` | `账户被盗取` | `⭐` |
| 🌊 **DDoS攻击** | `大量请求压垮服务` | `服务不可用` | `⭐⭐⭐⭐` |

---

## 2. 💉 SQL注入防护


### 2.1 什么是SQL注入


**🔍 通俗解释**
SQL注入就像是在银行柜台，坏人偷偷在你的取款单上加了几个字，让银行误以为你要做别的操作。

**💡 攻击原理示意**
```
正常查询：
用户输入：张三
SQL语句：SELECT * FROM users WHERE name = '张三'
结果：查询张三的信息 ✅

SQL注入攻击：
用户输入：张三'; DROP TABLE users; --
SQL语句：SELECT * FROM users WHERE name = '张三'; DROP TABLE users; --'
结果：先查询张三，然后删除整个用户表！ ❌
```

### 2.2 参数化查询防护


**🛡️ 防护原理**
参数化查询就像给SQL语句戴上"安全套"，让用户输入只能当作数据，不能当作代码执行。

**✅ 正确防护示例**
```java
// ❌ 危险的字符串拼接
String sql = "SELECT * FROM users WHERE name = '" + userName + "'";

// ✅ 安全的参数化查询
String sql = "SELECT * FROM users WHERE name = ?";
PreparedStatement stmt = connection.prepareStatement(sql);
stmt.setString(1, userName);  // 自动转义特殊字符
```

**🔧 各语言实现对比**

| 语言 | **不安全写法** | **安全写法** |
|------|-------------|-------------|
| **Java** | `"SELECT * FROM users WHERE id=" + id` | `PreparedStatement` |
| **Python** | `f"SELECT * FROM users WHERE id={id}"` | `cursor.execute(sql, (id,))` |
| **Node.js** | `"SELECT * FROM users WHERE id=" + id` | `db.query(sql, [id])` |

### 2.3 防护要点


> **💡 核心记忆**
> - **永远不要**直接拼接用户输入到SQL语句中
> - **始终使用**参数化查询或ORM框架
> - **定期检查**代码中是否存在字符串拼接SQL

---

## 3. 🕷️ XSS攻击防护


### 3.1 什么是XSS攻击


**🔍 通俗解释**
XSS攻击就像是有人在你经常看的网页上偷偷贴了一张"病毒贴纸"，当你看到这个网页时，病毒就自动运行了。

**🎭 攻击场景演示**
```
正常用户评论：
用户输入：这个商品很好用！
页面显示：<p>这个商品很好用！</p>

XSS攻击评论：
用户输入：商品不错<script>alert('你被攻击了')</script>
页面显示：<p>商品不错<script>alert('你被攻击了')</script></p>
结果：所有访问这个页面的用户都会看到弹窗 ❌
```

### 3.2 输出转义防护


**🛡️ 防护原理**
输出转义就是把用户输入的"危险字符"变成"安全字符"，让浏览器把它们当作普通文字显示，而不是当作代码执行。

**🔄 字符转义对照表**
```
危险字符 → 安全字符
<        → &lt;
>        → &gt;
"        → &quot;
'        → &#x27;
&        → &amp;
```

**✅ 实际防护代码**
```javascript
// ❌ 危险的直接输出
document.innerHTML = userInput;

// ✅ 安全的转义输出
function escapeHtml(text) {
    return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#x27;");
}
document.innerHTML = escapeHtml(userInput);
```

### 3.3 XSS防护策略


**🎯 多层防护策略**
```
输入阶段：
用户输入 → 格式校验 → 长度限制 → 存储

处理阶段：
读取数据 → 内容过滤 → 转义处理 → 输出

输出阶段：
HTML转义 → CSP策略 → 浏览器显示
```

> **⚡ 实用技巧**
> - 使用现成的转义库，别自己写
> - 对**所有**用户输入都要转义，包括URL参数
> - 设置CSP（内容安全策略）头部

---

## 4. 🎭 CSRF攻击防护


### 4.1 什么是CSRF攻击


**🔍 通俗解释**
CSRF攻击就像是有人冒充你的身份去银行转账。银行认为是你本人来的（因为有你的身份证），但实际上是坏人拿着你的身份证来的。

**🎬 攻击流程示意**
```
正常转账流程：
你 → 登录银行网站 → 获得身份令牌 → 发起转账请求 → 转账成功

CSRF攻击流程：
你 → 登录银行网站 → 获得身份令牌
                    ↓
恶意网站 → 偷偷用你的令牌 → 发起转账请求 → 你的钱被转走
```

### 4.2 Token验证防护


**🛡️ 防护原理**
Token验证就像是银行给你一个随机密码，每次操作都要提供这个密码。恶意网站猜不到这个密码，所以无法冒充你。

**🔐 实现步骤**
```
第1步：用户登录时生成CSRF Token
GET /login
响应：Set-Cookie: csrf_token=abc123random

第2步：表单中包含Token
<form action="/transfer" method="POST">
    <input type="hidden" name="csrf_token" value="abc123random">
    <input name="amount" value="1000">
    <button type="submit">转账</button>
</form>

第3步：服务器验证Token
POST /transfer
检查：请求中的token === 用户会话中的token
```

**✅ 代码实现示例**
```javascript
// 生成CSRF Token
function generateToken() {
    return Math.random().toString(36).substring(2, 15);
}

// 验证CSRF Token
function verifyToken(req) {
    const sessionToken = req.session.csrfToken;
    const requestToken = req.body.csrf_token;
    
    if (!sessionToken || sessionToken !== requestToken) {
        throw new Error('CSRF Token验证失败');
    }
}
```

### 4.3 其他防护措施


**🔒 额外防护层**
- **SameSite Cookie**：限制Cookie跨站发送
- **Referer检查**：验证请求来源
- **双Cookie验证**：使用两个Cookie相互验证

---

## 5. 🔄 重放攻击防护


### 5.1 什么是重放攻击


**🔍 通俗解释**
重放攻击就像是录音机，坏人录下了你说话的声音，然后一遍遍重复播放，让别人误以为你一直在说同样的话。

**📹 攻击场景示例**
```
正常支付流程：
你 → 发起支付请求 → 扣款1000元 → 支付成功

重放攻击：
坏人 → 截获你的支付请求 → 重复发送N次 → 你被扣款N×1000元
```

### 5.2 时间戳防护


**⏰ 防护原理**
给每个请求加上"有效期"，过期的请求就不处理，就像超市的打折券有使用期限一样。

**✅ 实现方法**
```javascript
// 客户端：添加时间戳
const request = {
    userId: 123,
    amount: 1000,
    timestamp: Date.now()  // 当前时间戳
};

// 服务端：验证时间戳
function validateTimestamp(timestamp) {
    const now = Date.now();
    const fiveMinutes = 5 * 60 * 1000;
    
    if (now - timestamp > fiveMinutes) {
        throw new Error('请求已过期');
    }
}
```

### 5.3 Nonce随机值防护


**🎲 防护原理**
Nonce就是"只用一次的随机数"，每个请求都有独特的标识，用过的就不能再用，就像电影票一样，用过就作废。

**🔢 实现示例**
```javascript
// 生成唯一Nonce
function generateNonce() {
    return Date.now() + '_' + Math.random().toString(36);
}

// 服务端记录使用过的Nonce
const usedNonces = new Set();

function validateNonce(nonce) {
    if (usedNonces.has(nonce)) {
        throw new Error('请求重复');
    }
    usedNonces.add(nonce);
    
    // 定期清理过期的Nonce
    setTimeout(() => usedNonces.delete(nonce), 300000);
}
```

---

## 6. 🔨 暴力破解防护


### 6.1 什么是暴力破解


**🔍 通俗解释**
暴力破解就像是坏人站在你家门口，疯狂尝试各种密码组合来开门锁，直到试出正确密码为止。

**🔓 攻击模式**
```
密码字典攻击：
尝试常用密码：123456 → password → 111111 → 生日 → ...

穷举攻击：
系统性尝试：aaa → aab → aac → ... → zzz

社工攻击：
基于个人信息：姓名+生日 → 手机号 → 身份证号 → ...
```

### 6.2 账户锁定防护


**🔒 锁定策略**
就像银行ATM机一样，密码输错3次就吞卡，我们也可以让账户"冷静一下"。

**⚙️ 实现逻辑**
```javascript
const loginAttempts = new Map();

function checkLoginAttempts(username) {
    const attempts = loginAttempts.get(username) || 0;
    
    if (attempts >= 5) {
        const lockTime = 30 * 60 * 1000; // 锁定30分钟
        throw new Error(`账户已锁定，请${lockTime/60000}分钟后重试`);
    }
    
    return attempts;
}

function recordFailedLogin(username) {
    const attempts = loginAttempts.get(username) || 0;
    loginAttempts.set(username, attempts + 1);
}
```

### 6.3 验证码防护


**🧩 验证码机制**
验证码就像是"机器人检测器"，让真人很容易通过，但让机器很难通过。

**📊 验证码类型对比**

| 类型 | **难度** | **用户体验** | **安全性** | **适用场景** |
|------|---------|-------------|-----------|-------------|
| 🔢 **数字验证码** | `⭐` | `⭐⭐⭐⭐⭐` | `⭐⭐` | `短信验证` |
| 🔤 **字母验证码** | `⭐⭐` | `⭐⭐⭐⭐` | `⭐⭐⭐` | `一般登录` |
| 🧮 **计算验证码** | `⭐⭐` | `⭐⭐⭐` | `⭐⭐⭐` | `评论发布` |
| 🖼️ **图片验证码** | `⭐⭐⭐` | `⭐⭐` | `⭐⭐⭐⭐` | `重要操作` |

---

## 7. 🌊 DDoS防护


### 7.1 什么是DDoS攻击


**🔍 通俗解释**
DDoS攻击就像是一群人故意堵在商店门口，让真正的顾客进不去买东西，最后商店被迫关门。

**📈 攻击规模示意**
```
正常访问量：
时间: 00:00  01:00  02:00  03:00
访问: ████   ██     █      ██     (平稳)

DDoS攻击：
时间: 00:00  01:00  02:00  03:00  
访问: ████   ████████████████████   (突然暴增)
结果: 服务器承受不了，网站崩溃
```

### 7.2 限流防护


**🚥 限流策略**
限流就像是在商店门口安排保安，控制同时进入的人数，防止拥挤踩踏。

**⚙️ 限流算法对比**

```
令牌桶算法：
┌─────────────┐    每秒产生10个令牌
│ 令牌桶(10)  │ ← 令牌生成器
└─────────────┘
       ↓ 
    请求获取令牌
    有令牌→处理请求
    无令牌→拒绝请求

滑动窗口算法：
时间窗口: [00:00-00:01] 允许100个请求
请求计数: 已处理95个，还能处理5个
新请求来了→检查计数→决定是否处理
```

**✅ 简单限流实现**
```javascript
const requestCounts = new Map();

function rateLimit(ip, maxRequests = 100, timeWindow = 60000) {
    const now = Date.now();
    const windowStart = now - timeWindow;
    
    // 获取该IP的请求记录
    const requests = requestCounts.get(ip) || [];
    
    // 清理过期请求
    const validRequests = requests.filter(time => time > windowStart);
    
    if (validRequests.length >= maxRequests) {
        throw new Error('请求过于频繁，请稍后重试');
    }
    
    // 记录本次请求
    validRequests.push(now);
    requestCounts.set(ip, validRequests);
}
```

### 7.3 黑名单防护


**🚫 IP黑名单机制**
把确认的攻击IP地址拉入黑名单，就像是给坏人拍照，下次见到直接拒绝入内。

**🔍 检测策略**
- **频率检测**：同一IP短时间内大量请求
- **行为检测**：异常的访问模式
- **地理检测**：来自异常地区的请求

---

## 8. 🌐 CORS与跨域安全


### 8.1 什么是CORS


**🔍 通俗解释**
CORS就像是海关检查，浏览器充当海关，决定哪些"外国"网站可以访问"本国"的资源。

**🌍 跨域场景示例**
```
同源访问（允许）：
https://www.example.com/page1 访问 https://www.example.com/api
↑ 同协议、同域名、同端口 ✅

跨域访问（需要CORS）：
https://www.app.com 访问 https://api.example.com
↑ 不同域名 ❌ 需要特殊许可
```

### 8.2 CORS配置


**⚙️ 基本配置说明**
```javascript
// 允许指定域名访问
res.header('Access-Control-Allow-Origin', 'https://trusted-site.com');

// 允许的HTTP方法
res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');

// 允许的请求头
res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');

// 是否允许携带Cookie
res.header('Access-Control-Allow-Credentials', true);
```

**🎯 安全配置原则**
> **⚠️ 安全提醒**
> - **绝不要**设置 `Access-Control-Allow-Origin: *` 同时允许携带凭据
> - **明确指定**可信任的域名
> - **最小权限**原则，只开放必要的方法和头部

---

## 9. ✅ 参数校验与防注入


### 9.1 为什么需要参数校验


**🔍 实际问题**
用户输入就像是"潘多拉的盒子"，里面什么都可能有：
- 正常数据：`{"name": "张三", "age": 25}`
- 异常数据：`{"name": "<script>alert('xss')</script>", "age": "abc"}`
- 恶意数据：`{"name": "'; DROP TABLE users; --", "age": -999}`

### 9.2 输入校验策略


**📋 校验层次结构**
```
第1层：格式校验
数据类型 → 必填项 → 长度范围 → 格式正则

第2层：业务校验  
逻辑合理性 → 权限检查 → 重复检查

第3层：安全校验
SQL注入 → XSS攻击 → 文件上传 → 危险字符
```

**✅ 实用校验规则**
```javascript
const validationRules = {
    // 用户名：3-20位字母数字下划线
    username: /^[a-zA-Z0-9_]{3,20}$/,
    
    // 邮箱：标准邮箱格式
    email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    
    // 手机号：11位数字
    phone: /^1[3-9]\d{9}$/,
    
    // 金额：最多2位小数的正数
    amount: /^\d+(\.\d{1,2})?$/
};

function validateInput(data, rules) {
    for (let field in rules) {
        const value = data[field];
        if (!rules[field].test(value)) {
            throw new Error(`${field} 格式不正确`);
        }
    }
}
```

### 9.3 接口防注入建议


**🛡️ 防护清单**

| 防护点 | **检查内容** | **处理方式** |
|-------|-------------|-------------|
| 🔍 **输入校验** | `数据类型、长度、格式` | `拒绝不合法输入` |
| 🧹 **数据清理** | `去除危险字符` | `转义或删除` |
| 🔒 **权限校验** | `用户操作权限` | `拒绝越权访问` |
| 📝 **日志记录** | `异常请求记录` | `便于追踪分析` |

**⚡ 实用技巧**
> **💡 最佳实践**
> - 在**控制器层**进行格式校验
> - 在**业务层**进行逻辑校验
> - 在**数据层**进行最终安全检查
> - **记录**所有校验失败的请求

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的安全概念


```
🔸 SQL注入：恶意SQL代码混入查询，用参数化查询防护
🔸 XSS攻击：网页植入恶意脚本，用输出转义防护  
🔸 CSRF攻击：伪造用户身份请求，用Token验证防护
🔸 重放攻击：重复发送旧请求，用时间戳+Nonce防护
🔸 暴力破解：疯狂尝试密码，用限制+验证码防护
🔸 DDoS攻击：大量请求压垮服务，用限流+黑名单防护
```

### 10.2 防护优先级


**🔥 高优先级（必须做）**
- ✅ **参数化查询** - 防SQL注入
- ✅ **输出转义** - 防XSS攻击
- ✅ **CSRF Token** - 防伪造请求
- ✅ **输入校验** - 防各种注入

**🟡 中优先级（建议做）**
- ⚡ **请求限流** - 防暴力攻击
- ⚡ **访问日志** - 便于追踪
- ⚡ **CORS配置** - 控制跨域

**🟢 低优先级（有条件做）**
- 💡 **IP白名单** - 高安全场景
- 💡 **加密传输** - 敏感数据
- 💡 **WAF防火墙** - 大型应用

### 10.3 实际应用指导


**🎯 新手入门建议**
1. **先做基础防护**：参数化查询、输出转义
2. **再加访问控制**：登录校验、权限检查
3. **最后优化体验**：友好错误提示、限流策略

**🔧 开发实践要点**
- **不要相信**任何用户输入
- **多层防护**胜过单点防护
- **定期检查**代码中的安全漏洞
- **及时更新**依赖库的安全补丁

**💭 安全思维培养**
> **核心原则：防患于未然**
> 
> 安全不是事后补救，而是事前预防。就像健康体检一样，要定期检查，及时发现问题，防止小问题变成大麻烦。

**🎯 记忆口诀**
```
参数校验在门口，SQL注入被拦住
输出转义防XSS，CSRF令牌要记住  
限流防护挡攻击，日志记录好追查
安全防护层层设，用户数据才安全
```