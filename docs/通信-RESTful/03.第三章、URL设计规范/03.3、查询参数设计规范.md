---
title: 3、查询参数设计规范
---
## 📚 目录

1. [查询参数基础概念](#1-查询参数基础概念)
2. [路径参数vs查询参数](#2-路径参数vs查询参数)
3. [分页参数设计](#3-分页参数设计)
4. [排序参数设计](#4-排序参数设计)
5. [过滤参数设计](#5-过滤参数设计)
6. [搜索参数设计](#6-搜索参数设计)
7. [字段选择参数](#7-字段选择参数)
8. [参数命名与一致性](#8-参数命名与一致性)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔗 查询参数基础概念


### 1.1 什么是查询参数


**🔸 简单理解**：查询参数就是URL中问号`?`后面的键值对，用来告诉服务器你想要什么样的数据。

```
基础URL示例：
https://api.example.com/users?page=1&size=10&status=active

解析：
- 基础地址：https://api.example.com/users
- 查询参数：page=1（第1页）、size=10（每页10条）、status=active（只要激活用户）
```

**💡 生活类比**：
就像去餐厅点菜时的要求：
- 基础菜品：牛肉面（基础URL）
- 特殊要求：不要辣、多加面、打包（查询参数）

### 1.2 查询参数的作用


```
核心作用：
🔸 筛选数据：只获取满足条件的数据
🔸 排序数据：按照指定方式排列
🔸 分页获取：分批获取大量数据
🔸 搜索内容：根据关键词查找
🔸 定制响应：只返回需要的字段
```

---

## 2. 🚪 路径参数vs查询参数


### 2.1 两者的区别


**路径参数（Path Variable）**：URL路径中的一部分，用来标识**具体的资源**

**查询参数（Query Parameter）**：URL中问号后的参数，用来**筛选或修饰资源**

```
对比示例：

路径参数：
GET /users/123        ← 123是路径参数，获取ID为123的用户
GET /users/123/orders ← 获取用户123的所有订单

查询参数：
GET /users?age=25           ← age=25是查询参数，筛选25岁的用户
GET /users?status=active    ← 筛选激活状态的用户
GET /users/123/orders?status=pending ← 获取用户123的待处理订单
```

### 2.2 使用场景对比


| 参数类型 | **使用场景** | **举例说明** | **特点** |
|---------|-------------|-------------|---------|
| 🎯 **路径参数** | `标识具体资源` | `GET /users/123` | `必需的，唯一标识` |
| 🔍 **查询参数** | `筛选、排序、分页` | `GET /users?age=25` | `可选的，条件过滤` |

### 2.3 设计原则


**🔸 路径参数使用原则**：
```
✅ 正确使用：
GET /users/123          （获取特定用户）
GET /orders/456         （获取特定订单）
GET /users/123/profile  （获取用户档案）

❌ 错误使用：
GET /users?id=123       （应该用路径参数）
GET /search?type=user   （搜索应该用查询参数）
```

**🔸 查询参数使用原则**：
```
✅ 正确使用：
GET /users?status=active&age=25    （筛选条件）
GET /users?page=1&size=10          （分页参数）
GET /users?sort=name&order=asc     （排序参数）

❌ 错误使用：
GET /users/active                  （状态不是具体资源标识）
GET /123/user                      （ID应该在合适位置）
```

---

## 3. 📖 分页参数设计


### 3.1 为什么需要分页


**🔸 现实问题**：
- 数据量太大：用户表可能有几万条记录
- 网络传输：一次性传输会很慢
- 用户体验：页面加载时间过长
- 服务器负载：查询和传输压力大

**💡 生活类比**：
就像看书一样，不会一次性把整本书的内容都显示在一页上，而是分成一页一页来看。

### 3.2 两种分页方式


#### 🔸 方式一：页码分页（Page-Based）


```
参数设计：
?page=1&size=20

含义解释：
- page：第几页（从1开始）
- size：每页多少条数据

示例：
GET /users?page=1&size=20    ← 第1页，每页20条
GET /users?page=2&size=20    ← 第2页，每页20条
GET /users?page=3&size=10    ← 第3页，每页10条
```

**优点**：直观易懂，用户容易理解
**缺点**：深分页性能差（翻到第1000页会很慢）

#### 🔸 方式二：偏移分页（Offset-Based）


```
参数设计：
?offset=0&limit=20

含义解释：
- offset：跳过多少条数据（从0开始）
- limit：最多返回多少条数据

示例：
GET /users?offset=0&limit=20   ← 跳过0条，返回20条（第1-20条）
GET /users?offset=20&limit=20  ← 跳过20条，返回20条（第21-40条）
GET /users?offset=40&limit=10  ← 跳过40条，返回10条（第41-50条）
```

**优点**：更灵活，可以精确控制数据范围
**缺点**：用户理解成本稍高

### 3.3 分页参数对比


| 分页方式 | **参数** | **计算方式** | **适用场景** |
|---------|---------|-------------|-------------|
| 📄 **页码分页** | `page + size` | `offset = (page-1) × size` | `用户界面分页` |
| 📊 **偏移分页** | `offset + limit` | `直接使用offset` | `API接口，精确控制` |

### 3.4 默认值设计


```
合理的默认值：

不提供分页参数时：
GET /users  ← 默认返回第1页，每页20条

等同于：
GET /users?page=1&size=20
或
GET /users?offset=0&limit=20

推荐默认值：
- 默认页码：1
- 默认页大小：10-50条（根据数据类型调整）
- 最大页大小：100条（防止一次请求太多数据）
```

### 3.5 响应格式设计


```json
{
  "data": [
    {"id": 1, "name": "张三"},
    {"id": 2, "name": "李四"}
  ],
  "pagination": {
    "page": 1,
    "size": 20,
    "total": 150,
    "totalPages": 8,
    "hasNext": true,
    "hasPrev": false
  }
}
```

---

## 4. 🔀 排序参数设计


### 4.1 为什么需要排序


**🔸 用户需求**：
- 按时间排序：最新的内容优先
- 按价格排序：从低到高或从高到低
- 按名称排序：字母顺序排列
- 按热度排序：最受欢迎的优先

### 4.2 单字段排序


#### 🔸 方式一：分离式参数


```
参数设计：
?sort=字段名&order=排序方向

示例：
GET /users?sort=name&order=asc     ← 按姓名升序
GET /users?sort=age&order=desc     ← 按年龄降序
GET /users?sort=createTime&order=desc  ← 按创建时间降序

参数含义：
- sort：要排序的字段名
- order：排序方向（asc升序/desc降序）
```

#### 🔸 方式二：组合式参数


```
参数设计：
?sort=字段名,排序方向

示例：
GET /users?sort=name,asc          ← 按姓名升序
GET /users?sort=age,desc          ← 按年龄降序
GET /users?sort=createTime,desc   ← 按创建时间降序

优点：参数更简洁
缺点：需要解析组合参数
```

### 4.3 多字段排序


```
实际场景：先按部门排序，相同部门内再按工资排序

方式一：多个sort参数
GET /users?sort=department,asc&sort=salary,desc

方式二：逗号分隔
GET /users?sort=department,asc,salary,desc

方式三：分号分隔
GET /users?sort=department,asc;salary,desc

推荐方式：
GET /users?sort=department,asc&sort=salary,desc
```

### 4.4 默认排序


```
设计原则：
1. 提供合理的默认排序
2. 用户友好的排序顺序
3. 性能友好的排序字段

常见默认排序：
GET /users              ← 默认按ID升序
GET /articles           ← 默认按发布时间降序（最新的在前）
GET /products           ← 默认按销量降序（热门的在前）
```

---

## 5. 🔍 过滤参数设计


### 5.1 过滤参数的作用


**🔸 核心目标**：从大量数据中筛选出符合条件的数据

**💡 生活类比**：
就像在购物网站上筛选商品：
- 选择品牌：`brand=苹果`
- 选择价格区间：`price_min=1000&price_max=5000`
- 选择颜色：`color=黑色`

### 5.2 精确匹配过滤


```
基础用法：
GET /users?status=active           ← 筛选激活状态的用户
GET /users?department=技术部        ← 筛选技术部的用户
GET /products?category=手机         ← 筛选手机类商品

多条件组合：
GET /users?status=active&department=技术部&age=25
含义：同时满足三个条件的用户

参数含义：
- 直接用字段名作为参数名
- 参数值就是要匹配的值
- 多个条件默认是"AND"关系
```

### 5.3 模糊搜索过滤


```
模糊匹配设计：
GET /users?name_like=张            ← 姓名包含"张"的用户
GET /users?email_like=gmail        ← 邮箱包含"gmail"的用户

参数命名规范：
- 字段名 + _like：模糊匹配
- 字段名 + _contains：包含匹配
- 字段名 + _startswith：以...开头
- 字段名 + _endswith：以...结尾
```

### 5.4 范围查询过滤


```
数值范围：
GET /users?age_min=18&age_max=65    ← 年龄在18-65岁之间
GET /products?price_min=100&price_max=1000  ← 价格在100-1000之间

日期范围：
GET /orders?date_from=2023-01-01&date_to=2023-12-31  ← 2023年的订单
GET /articles?created_after=2023-06-01  ← 6月1日之后创建的文章

参数命名规范：
- 字段名_min/字段名_max：数值范围
- 字段名_from/字段名_to：时间范围
- 字段名_after/字段名_before：时间点比较
```

### 5.5 数组值过滤


```
单选值：
GET /users?status=active

多选值：
GET /users?status=active,pending    ← 状态是active或pending的用户
GET /products?category=手机,电脑     ← 分类是手机或电脑的商品

参数解析：
- 逗号分隔表示"OR"关系
- 相当于SQL中的 WHERE status IN ('active', 'pending')
```

---

## 6. 🔎 搜索参数设计


### 6.1 搜索参数的特点


**🔸 搜索vs过滤的区别**：
- **过滤**：精确的条件筛选（status=active）
- **搜索**：模糊的关键词匹配（搜索"手机"可能匹配标题、描述等多个字段）

### 6.2 通用搜索参数


```
方式一：q参数（最常用）
GET /users?q=张三              ← 搜索包含"张三"的用户
GET /articles?q=Vue教程         ← 搜索包含"Vue教程"的文章
GET /products?q=iPhone         ← 搜索包含"iPhone"的商品

方式二：search参数
GET /users?search=张三
GET /articles?search=Vue教程

方式三：keyword参数
GET /users?keyword=张三
GET /articles?keyword=Vue教程

推荐：使用q参数，简洁通用
```

### 6.3 搜索范围设计


```
全文搜索：
GET /articles?q=Vue教程         ← 在所有字段中搜索

指定字段搜索：
GET /users?name=张三            ← 只在姓名字段搜索
GET /articles?title=Vue教程      ← 只在标题字段搜索

搜索组合：
GET /articles?q=Vue&category=教程  ← 全文搜索"Vue"且分类是"教程"
```

### 6.4 搜索与其他参数组合


```
搜索 + 分页：
GET /articles?q=Vue教程&page=1&size=10

搜索 + 排序：
GET /articles?q=Vue教程&sort=createTime,desc  ← 搜索后按时间排序

搜索 + 过滤：
GET /articles?q=Vue&status=published&category=前端  ← 搜索已发布的前端Vue文章

完整示例：
GET /articles?q=Vue教程&status=published&sort=createTime,desc&page=1&size=10
含义：搜索已发布的"Vue教程"相关文章，按时间降序排序，返回第1页每页10条
```

---

## 7. 📋 字段选择参数


### 7.1 为什么需要字段选择


**🔸 实际问题**：
- 节省流量：移动端不需要所有字段
- 提升性能：减少数据传输时间
- 精确需求：前端可能只需要特定字段

**💡 生活类比**：
就像填表时选择需要的信息：
- 完整信息：姓名、年龄、地址、电话、邮箱、工作...
- 简要信息：只要姓名和电话

### 7.2 字段选择设计


```
基础用法：
GET /users?fields=id,name,email     ← 只返回ID、姓名、邮箱
GET /users?fields=id,name           ← 只返回ID、姓名
GET /articles?fields=id,title,summary  ← 只返回ID、标题、摘要

参数解析：
- fields：要返回的字段列表
- 逗号分隔多个字段
- 不指定则返回所有字段
```

### 7.3 响应对比


```json
不使用字段选择：
GET /users

返回：
{
  "data": [
    {
      "id": 1,
      "name": "张三",
      "email": "zhangsan@example.com",
      "phone": "13888888888",
      "address": "北京市朝阳区...",
      "birthday": "1990-01-01",
      "createTime": "2023-01-01T10:00:00Z",
      "updateTime": "2023-06-01T15:30:00Z"
    }
  ]
}

使用字段选择：
GET /users?fields=id,name,email

返回：
{
  "data": [
    {
      "id": 1,
      "name": "张三", 
      "email": "zhangsan@example.com"
    }
  ]
}
```

### 7.4 字段选择的高级用法


```
嵌套字段选择：
GET /users?fields=id,name,profile.avatar,profile.bio
含义：返回用户的ID、姓名，以及资料中的头像和简介

字段排除：
GET /users?exclude=password,salt,token
含义：返回除了密码、盐值、令牌之外的所有字段

注意：字段选择和字段排除通常选择其中一种方式，避免混用
```

---

## 8. 🏷️ 参数命名与一致性


### 8.1 命名原则


**🔸 核心原则**：
- **简洁明了**：参数名要清楚表达含义
- **保持一致**：整个API使用统一的命名规范
- **易于理解**：新手也能快速理解参数作用

```
✅ 好的命名：
page, size, sort, order          ← 简洁明了
status, category, type           ← 语义清晰
created_after, price_min         ← 含义明确

❌ 不好的命名：
p, s, st, ord                    ← 过于简洁，不明确
pageNumber, pageSize             ← 冗余，不简洁
createdAfterTime                 ← 过于冗长
```

### 8.2 统一的参数规范


#### 🔸 分页参数统一


```
推荐方案：
?page=1&size=20     ← 简洁，易懂

备选方案：
?offset=0&limit=20  ← 更精确，但稍复杂

一致性要求：
全站统一使用一种方案，不要混用
```

#### 🔸 排序参数统一


```
推荐方案：
?sort=name&order=asc    ← 分离式，清晰

备选方案：
?sort=name,asc          ← 组合式，简洁

一致性要求：
所有排序都使用相同的格式
```

#### 🔸 过滤参数统一


```
基础过滤：
?status=active          ← 直接用字段名

范围过滤：
?age_min=18&age_max=65  ← 统一使用_min/_max后缀

模糊搜索：
?name_like=张           ← 统一使用_like后缀

时间过滤：
?created_after=2023-01-01  ← 统一使用_after/_before后缀
```

### 8.3 默认值设计原则


```
用户友好的默认值：

分页默认值：
- 不指定page：默认第1页
- 不指定size：默认20条（平衡性能和用户体验）
- 最大size限制：100条（防止滥用）

排序默认值：
- 用户数据：按ID升序（稳定排序）
- 文章数据：按发布时间降序（最新优先）
- 商品数据：按销量降序（热门优先）

过滤默认值：
- 状态过滤：默认显示正常状态数据
- 权限过滤：默认只显示用户有权限的数据
```

### 8.4 参数组合示例


```
实际业务场景：电商商品列表

完整参数组合：
GET /products?
    category=手机&           ← 过滤：手机分类
    brand=苹果&              ← 过滤：苹果品牌
    price_min=1000&         ← 过滤：最低价格1000
    price_max=8000&         ← 过滤：最高价格8000
    q=iPhone&               ← 搜索：包含iPhone
    sort=price&             ← 排序：按价格
    order=asc&              ← 排序：升序
    page=1&                 ← 分页：第1页
    size=20&                ← 分页：每页20条
    fields=id,name,price,image  ← 字段选择：只返回基本信息

语义：搜索1000-8000元价位的苹果iPhone手机，按价格升序排列，第1页显示20条，只返回基本信息
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 查询参数本质：URL中?后的键值对，用于筛选和定制API响应
🔸 路径参数vs查询参数：路径参数标识资源，查询参数筛选资源
🔸 五大参数类型：分页、排序、过滤、搜索、字段选择
🔸 命名一致性：整个API使用统一的参数命名和格式规范
🔸 默认值设计：提供用户友好且性能友好的默认参数值
```

### 9.2 参数设计速查表


| 参数类型 | **常用参数** | **示例** | **作用** |
|---------|-------------|---------|---------|
| 🔸 **分页参数** | `page, size` | `?page=1&size=20` | `分批获取数据` |
| 🔸 **排序参数** | `sort, order` | `?sort=name&order=asc` | `指定数据排序` |
| 🔸 **过滤参数** | `字段名=值` | `?status=active&age_min=18` | `条件筛选数据` |
| 🔸 **搜索参数** | `q, search` | `?q=关键词` | `关键词搜索` |
| 🔸 **字段选择** | `fields` | `?fields=id,name,email` | `控制返回字段` |

### 9.3 设计最佳实践


**🔹 参数命名最佳实践**：
```
✅ 推荐做法：
- 使用简洁明了的英文单词
- 保持全站参数命名一致
- 范围过滤使用_min/_max后缀
- 时间过滤使用_after/_before后缀
- 模糊搜索使用_like后缀

❌ 避免做法：
- 使用过于简洁的缩写（如p代表page）
- 不同接口使用不同的参数名
- 参数名过于冗长
- 使用中文或特殊字符
```

**🔹 默认值设计原则**：
```
用户体验优先：
- 分页默认size=20（不会太少也不会太多）
- 排序默认按用户最关心的字段
- 过滤默认显示最常用的数据状态

性能友好：
- 限制最大页大小（如max_size=100）
- 默认排序使用有索引的字段
- 避免默认查询全部数据
```

**🔹 参数组合使用技巧**：
```
业务场景驱动：
1. 先确定业务需求（用户要查什么数据）
2. 再设计参数组合（需要哪些筛选条件）
3. 最后优化性能（合理的默认值和限制）

示例：用户管理页面
GET /users?status=active&department=技术部&sort=createTime,desc&page=1&size=20

含义：查询技术部的激活用户，按创建时间降序排列，第1页显示20条
```

### 9.4 常见错误避免


```
❌ 常见设计错误：

1. 路径参数和查询参数混用：
   错误：GET /users?id=123
   正确：GET /users/123

2. 参数命名不一致：
   错误：/users?pageNum=1, /orders?page=1
   正确：统一使用page=1

3. 缺少默认值：
   错误：不提供参数时返回所有数据
   正确：提供合理的默认分页和排序

4. 参数过于复杂：
   错误：?filter={"status":"active","age":{"$gt":18}}
   正确：?status=active&age_min=18

5. 缺少参数限制：
   错误：允许?size=99999999
   正确：限制最大size=100
```

**核心记忆**：
- 查询参数是API的"遥控器"，让客户端精确控制想要的数据
- 路径参数定位资源，查询参数筛选资源，两者分工明确
- 好的参数设计要平衡：简洁性、一致性、易用性、性能
- 分页、排序、过滤、搜索、字段选择是五大核心参数类型