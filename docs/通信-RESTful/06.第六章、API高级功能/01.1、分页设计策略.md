---
title: 1、分页设计策略
---
## 📚 目录

1. [什么是API分页](#1-什么是API分页)
2. [为什么需要分页](#2-为什么需要分页)
3. [三种分页方式详解](#3-三种分页方式详解)
4. [分页参数标准化](#4-分页参数标准化)
5. [分页响应格式设计](#5-分页响应格式设计)
6. [性能优化考虑](#6-性能优化考虑)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 什么是API分页


### 1.1 分页的本质

**简单理解**：分页就像翻书一样，把大量数据分成一页一页展示，而不是一次性全部显示。

```
想象你在看一本1000页的书：
❌ 不分页：一次性看完1000页 → 累死人
✅ 分页：每次看10页 → 轻松愉快

API分页也是同样道理：
❌ 不分页：一次性返回10万条数据 → 服务器和用户都崩溃
✅ 分页：每次返回20条数据 → 大家都开心
```

### 1.2 分页在日常生活中的例子

```
📱 微信朋友圈：滑到底部自动加载更多
🛒 淘宝商品列表：第1页、第2页、第3页...
📧 邮件列表：每页显示50封邮件
📺 视频网站：每页显示24个视频
```

### 1.3 API分页的工作原理

```
客户端请求：我要看第2页的用户数据，每页20条
服务器响应：好的，这是第21-40条用户数据

简单对话：
客户端：GET /users?page=2&size=20
服务器：返回第21-40条用户数据 + 总数信息
```

---

## 2. 💡 为什么需要分页


### 2.1 服务器压力问题

**问题场景**：假设有10万个用户数据
```
❌ 不分页的后果：
- 服务器：要查询10万条数据 → CPU累死
- 网络：要传输10万条数据 → 带宽爆炸  
- 客户端：要接收10万条数据 → 内存爆炸
- 用户：要等很久才能看到数据 → 体验极差

✅ 分页的好处：
- 服务器：只查询20条数据 → 轻松愉快
- 网络：只传输20条数据 → 秒传
- 客户端：只处理20条数据 → 流畅运行
- 用户：立即看到数据 → 体验很棒
```

### 2.2 用户体验问题

```
真实场景对比：

📱 手机淘宝商品列表：
❌ 一次性加载1万个商品 → 手机卡死
✅ 每次加载20个商品 → 流畅滑动

💻 后台管理系统用户列表：
❌ 一次性显示10万用户 → 页面卡顿
✅ 分页显示，每页50个 → 操作顺滑
```

### 2.3 资源消耗对比

| 方式 | **数据库查询** | **内存占用** | **网络传输** | **页面响应** |
|------|-------------|------------|------------|------------|
| **不分页** | `10万条记录` | `~100MB` | `~50MB` | `10-30秒` |
| **分页(20条)** | `20条记录` | `~200KB` | `~100KB` | `0.1-0.5秒` |

---

## 3. 📖 三种分页方式详解


## 3.1 📄 Page分页（页码方式）


### 基本概念

**最容易理解的分页方式**：就像书的页码，第1页、第2页、第3页...

```
用户思维：我要看第3页的数据
API参数：page=3&size=20
实际含义：跳过前40条，取接下来20条数据
```

### 实际示例

```http
GET /api/users?page=1&size=20
# 返回第1-20条用户

GET /api/users?page=2&size=20  
# 返回第21-40条用户

GET /api/users?page=3&size=20
# 返回第41-60条用户
```

```json
// 响应示例
{
  "data": [
    {"id": 21, "name": "张三", "email": "zhang@example.com"},
    {"id": 22, "name": "李四", "email": "li@example.com"}
    // ... 共20条数据
  ],
  "pagination": {
    "current_page": 2,    // 当前第2页
    "per_page": 20,       // 每页20条
    "total": 1000,        // 总共1000条
    "total_pages": 50     // 总共50页
  }
}
```

### 优点与缺点

```
✅ 优点：
- 用户容易理解（就像书的页码）
- 可以跳转到任意页面
- 适合表格形式的数据展示

❌ 缺点：
- 深分页性能差（查看第1000页很慢）
- 数据实时变化时可能看到重复内容
```

## 3.2 📍 Offset分页（偏移量方式）


### 基本概念

**程序员喜欢的方式**：直接告诉数据库"跳过多少条，取多少条"

```
用户请求：我要从第40条开始，取20条数据
API参数：offset=40&limit=20
数据库查询：LIMIT 20 OFFSET 40
```

### 实际示例

```http
GET /api/users?offset=0&limit=20
# 跳过0条，取前20条（第1-20条）

GET /api/users?offset=20&limit=20
# 跳过20条，取接下来20条（第21-40条）

GET /api/users?offset=40&limit=20  
# 跳过40条，取接下来20条（第41-60条）
```

```json
// 响应示例
{
  "data": [
    {"id": 41, "name": "王五", "email": "wang@example.com"},
    {"id": 42, "name": "赵六", "email": "zhao@example.com"}
    // ... 共20条数据
  ],
  "pagination": {
    "offset": 40,         // 当前偏移量
    "limit": 20,          // 每次取20条
    "total": 1000,        // 总数据量
    "has_next": true      // 是否还有下一页
  }
}
```

### Page和Offset的关系

```
它们本质上是一回事，只是表达方式不同：

Page方式：page=3, size=20
转换为Offset：offset=(3-1)*20=40, limit=20

Offset方式：offset=40, limit=20  
转换为Page：page=40/20+1=3, size=20
```

## 3.3 🎯 Cursor分页（游标方式）


### 基本概念

**最先进的分页方式**：使用一个"游标"（通常是ID）作为分页的标记点

```
思路：不用页码，用具体的数据标识
- 第一次：给我前20条数据
- 第二次：给我ID大于40的前20条数据  
- 第三次：给我ID大于60的前20条数据
```

### 为什么需要Cursor分页？

```
场景：微信朋友圈实时更新

❌ 用Page分页的问题：
- 你在看第2页时，有人发了新朋友圈
- 所有数据往后挪一位
- 你翻到第3页时，可能看到重复内容

✅ 用Cursor分页的好处：
- 基于具体的朋友圈ID分页
- 不管有多少新内容，都不会重复
```

### 实际示例

```http
GET /api/posts?limit=20
# 第一次请求，获取最新20条

GET /api/posts?cursor=post_40&limit=20
# 第二次请求，获取post_40之后的20条

GET /api/posts?cursor=post_60&limit=20
# 第三次请求，获取post_60之后的20条
```

```json
// 第一次响应
{
  "data": [
    {"id": "post_1", "content": "最新动态", "created_at": "2025-01-01"},
    {"id": "post_2", "content": "第二条", "created_at": "2025-01-02"}
    // ... 共20条
  ],
  "pagination": {
    "next_cursor": "post_20",    // 下一页的游标
    "has_next": true             // 是否有下一页
  }
}
```

### 三种分页方式对比

| 方式 | **适用场景** | **性能** | **实时性** | **复杂度** |
|------|------------|---------|-----------|-----------|
| **Page分页** | `表格数据、管理后台` | `中等` | `一般` | `简单` |
| **Offset分页** | `API开发、程序对接` | `中等` | `一般` | `简单` |
| **Cursor分页** | `实时流、社交媒体` | `优秀` | `很好` | `较复杂` |

---

## 4. 📋 分页参数标准化


### 4.1 常用参数名称对照

```
📄 Page分页参数：
✅ 推荐：page, size
✅ 常见：page, limit  
✅ 也用：page, per_page

📍 Offset分页参数：
✅ 推荐：offset, limit
✅ 常见：skip, take
✅ 也用：start, count

🎯 Cursor分页参数：
✅ 推荐：cursor, limit
✅ 常见：after, before
✅ 也用：next_token, page_token
```

### 4.2 参数默认值设置

```http
# 智能默认值
GET /api/users
# 等同于 GET /api/users?page=1&size=20

GET /api/users?page=2
# 等同于 GET /api/users?page=2&size=20

GET /api/users?size=50
# 等同于 GET /api/users?page=1&size=50
```

### 4.3 参数验证规则

```
🔍 常见验证：
- page >= 1 （页码从1开始）
- size: 1-100 （每页数量限制）
- offset >= 0 （偏移量非负数）

⚠️ 边界处理：
- page=0 → 自动修正为 page=1
- size=0 → 自动修正为 size=20（默认值）
- size>100 → 自动修正为 size=100（最大值）
```

---

## 5. 📊 分页响应格式设计


### 5.1 标准响应结构

```json
{
  "success": true,           // 请求是否成功
  "data": [...],            // 实际数据数组
  "pagination": {...},      // 分页信息
  "message": "查询成功"      // 提示信息
}
```

### 5.2 详细分页信息

```json
// Page分页响应格式
{
  "data": [...],
  "pagination": {
    "current_page": 2,        // 当前页码
    "per_page": 20,          // 每页数量
    "total": 1000,           // 总数据量
    "total_pages": 50,       // 总页数
    "has_prev": true,        // 是否有上一页
    "has_next": true,        // 是否有下一页
    "prev_page": 1,          // 上一页页码
    "next_page": 3           // 下一页页码
  }
}
```

```json
// Cursor分页响应格式
{
  "data": [...],
  "pagination": {
    "cursor": "current_cursor",    // 当前游标
    "next_cursor": "next_cursor",  // 下一页游标  
    "prev_cursor": "prev_cursor",  // 上一页游标
    "has_next": true,              // 是否有下一页
    "has_prev": false,             // 是否有上一页
    "limit": 20                    // 每页数量
  }
}
```

### 5.3 简化响应格式

```json
// 适合移动端的简化格式
{
  "data": [...],
  "has_more": true,          // 是否还有更多数据
  "next_page_url": "/api/users?page=3&size=20"  // 下一页完整URL
}
```

---

## 6. ⚡ 性能优化考虑


### 6.1 深分页性能问题

**什么是深分页？**
```
浅分页：page=1, 2, 3...     → 很快
深分页：page=1000, 2000... → 很慢

为什么深分页慢？
数据库需要：
1. 先查出前19980条数据（page=1000, size=20）
2. 然后扔掉前19980条
3. 只返回接下来的20条
4. 白做了大量无用功
```

### 6.2 深分页优化策略

```
🚀 策略1：限制最大页数
if (page > 100) {
  return error("最多只能查看前100页");
}

🚀 策略2：改用Cursor分页
// 不基于页码，基于数据ID
GET /api/users?after_id=1980&limit=20

🚀 策略3：缓存热点数据
// 把前几页的数据缓存起来
GET /api/users?page=1  → 从缓存读取（毫秒级）
GET /api/users?page=50 → 从数据库读取（秒级）
```

### 6.3 数据库优化技巧

```sql
-- ❌ 慢查询（深分页）
SELECT * FROM users ORDER BY id LIMIT 20 OFFSET 19980;

-- ✅ 快查询（使用索引）
SELECT * FROM users WHERE id > 1980 ORDER BY id LIMIT 20;

-- ✅ 更快查询（覆盖索引）
SELECT id, name, email FROM users WHERE id > 1980 ORDER BY id LIMIT 20;
```

### 6.4 前端优化建议

```javascript
// ✅ 虚拟滚动（只渲染可见部分）
<VirtualList 
  :items="userList"
  :item-height="50"
  :visible-count="20"
/>

// ✅ 懒加载（滚动到底部再加载）
function onScroll() {
  if (isBottom() && hasMore) {
    loadNextPage();
  }
}

// ✅ 防抖处理（避免频繁请求）
const debouncedLoad = debounce(loadNextPage, 300);
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念

```
🔸 分页本质：把大量数据分批次展示，提升性能和体验
🔸 三种方式：Page分页（页码）、Offset分页（偏移量）、Cursor分页（游标）
🔸 参数标准：page/size、offset/limit、cursor/limit
🔸 响应格式：data + pagination信息
🔸 性能问题：深分页要避免，推荐使用限制或Cursor分页
```

### 7.2 选择分页方式的建议

```
📄 选择Page分页：
✅ 管理后台的数据表格
✅ 需要跳转到指定页面
✅ 数据相对稳定

📍 选择Offset分页：  
✅ API接口开发
✅ 程序间数据对接
✅ 需要精确控制数据范围

🎯 选择Cursor分页：
✅ 实时数据流（朋友圈、微博）
✅ 数据频繁更新
✅ 需要避免重复和遗漏
```

### 7.3 实际开发最佳实践

```
🔧 参数设计：
- 提供合理的默认值（page=1, size=20）
- 限制每页最大数量（size<=100）
- 提供参数验证和边界处理

📊 响应设计：
- 包含完整的分页信息
- 提供has_next/has_prev判断
- 考虑移动端的简化格式

⚡ 性能优化：
- 限制最大页数或使用Cursor分页
- 对热点数据进行缓存
- 前端实现虚拟滚动和懒加载
```

### 7.4 常见问题避坑指南

```
❌ 常见错误：
- 不限制每页数量，用户可以请求10万条数据
- 深分页没有优化，第1000页查询超时
- 分页信息不完整，前端无法正确显示

✅ 正确做法：
- 设置size上限，保护服务器资源
- 限制最大页数或改用Cursor分页
- 提供完整的分页元信息
```

**核心记忆**：
- 分页如翻书，一页一页看轻松
- 三种方式各有用，按需选择最合适  
- 深分页要避免，性能优化是关键
- 响应格式要标准，前端展示才方便