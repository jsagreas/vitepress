---
title: 4、分页过滤排序设计
---
## 📚 目录

1. [分页设计规范](#1-分页设计规范)
2. [过滤参数设计](#2-过滤参数设计)
3. [排序参数设计](#3-排序参数设计)
4. [搜索功能实现](#4-搜索功能实现)
5. [组合查询应用](#5-组合查询应用)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📄 分页设计规范


### 1.1 为什么需要分页


**现实问题**：想象你在网购平台搜索商品，如果一次性加载10万个商品，会怎样？

```
问题场景：
用户搜索 "手机" → 返回50000个结果
├─ 前端：页面卡死，无法滚动
├─ 网络：传输数据太大，加载很慢  
├─ 后端：内存占用过高，服务器压力大
└─ 数据库：查询时间长，影响其他用户
```

**分页解决方案**：就像翻书一样，一页一页地看内容

```
分页效果：
第1页：显示 1-20 个商品 ✅ 快速加载
第2页：显示 21-40 个商品 ✅ 按需获取
第3页：显示 41-60 个商品 ✅ 减少压力
```

### 1.2 分页参数设计


**🎯 核心分页参数**

| 参数名 | 含义 | 示例 | 说明 |
|--------|------|------|------|
| `page` | **页码** | `page=2` | 第几页（从1开始） |
| `size` | **每页数量** | `size=20` | 每页显示多少条 |
| `offset` | **偏移量** | `offset=40` | 跳过多少条记录 |
| `limit` | **限制数量** | `limit=20` | 最多返回多少条 |

**💡 两种常见设计方案**

```bash
# 方案1：页码方式（推荐）
GET /api/products?page=2&size=20
# 含义：获取第2页，每页20个商品

# 方案2：偏移量方式
GET /api/products?offset=20&limit=20  
# 含义：跳过前20个，取接下来的20个
```

**🔧 参数换算关系**
```
页码转偏移量：offset = (page - 1) × size
偏移量转页码：page = offset ÷ size + 1

示例：
第3页，每页10条 → offset = (3-1) × 10 = 20
偏移量30，每页10条 → page = 30 ÷ 10 + 1 = 4
```

### 1.3 分页响应格式


**📊 标准响应结构**

```json
{
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "price": 5999
    },
    {
      "id": 2, 
      "name": "华为P60",
      "price": 4999
    }
  ],
  "pagination": {
    "total": 156,           // 总记录数
    "current_page": 2,      // 当前页码
    "total_pages": 8,       // 总页数
    "page_size": 20,        // 每页数量
    "has_next": true,       // 是否有下一页
    "has_prev": true        // 是否有上一页
  }
}
```

**📋 响应字段说明**

```
total: 156          → 数据库中总共有156条商品
current_page: 2     → 当前返回的是第2页  
total_pages: 8      → 总共需要8页才能显示完（156÷20=7.8，向上取整=8）
page_size: 20       → 每页显示20条商品
has_next: true      → 还有第3页可以查看
has_prev: true      → 可以回到第1页
```

### 1.4 分页实际应用


**🌐 请求示例**
```bash
# 获取商品列表第1页
GET /api/products?page=1&size=10

# 获取用户订单第3页  
GET /api/users/123/orders?page=3&size=5

# 获取文章列表第2页
GET /api/articles?page=2&size=15
```

**⚙️ 后端处理逻辑**
```python
# Python示例（简化版）
def get_products(page=1, size=20):
    # 计算偏移量
    offset = (page - 1) * size
    
    # 查询总数
    total = db.query("SELECT COUNT(*) FROM products").fetchone()[0]
    
    # 查询当前页数据
    products = db.query(
        "SELECT * FROM products LIMIT ? OFFSET ?", 
        [size, offset]
    ).fetchall()
    
    # 计算总页数
    total_pages = math.ceil(total / size)
    
    return {
        "data": products,
        "pagination": {
            "total": total,
            "current_page": page,
            "total_pages": total_pages,
            "page_size": size,
            "has_next": page < total_pages,
            "has_prev": page > 1
        }
    }
```

---

## 2. 🔍 过滤参数设计


### 2.1 什么是过滤


**简单理解**：过滤就像在购物网站上筛选商品

```
淘宝筛选场景：
所有手机 (10000个)
├─ 品牌：苹果 → 剩下2000个
├─ 价格：3000-6000元 → 剩下800个  
├─ 颜色：黑色 → 剩下200个
└─ 状态：有库存 → 剩下150个

最终显示：符合所有条件的150个手机
```

### 2.2 基础过滤参数


**🎯 等值过滤（最常用）**
```bash
# 按状态过滤
GET /api/products?status=active
# 含义：只要状态为"active"的商品

# 按分类过滤  
GET /api/products?category=phone
# 含义：只要分类为"手机"的商品

# 按品牌过滤
GET /api/products?brand=apple
# 含义：只要苹果品牌的商品
```

**🔢 范围过滤（数值比较）**
```bash
# 价格大于等于1000
GET /api/products?price_gte=1000

# 价格小于等于5000  
GET /api/products?price_lte=5000

# 价格在1000-5000之间
GET /api/products?price_gte=1000&price_lte=5000

# 创建时间大于某个日期
GET /api/articles?created_at_gte=2024-01-01
```

**📝 过滤操作符规范**

| 操作符 | 含义 | 示例 | 说明 |
|--------|------|------|------|
| `_eq` | **等于** | `status_eq=active` | 状态等于active |
| `_ne` | **不等于** | `status_ne=deleted` | 状态不是deleted |
| `_gt` | **大于** | `price_gt=100` | 价格大于100 |
| `_gte` | **大于等于** | `price_gte=100` | 价格大于等于100 |
| `_lt` | **小于** | `price_lt=1000` | 价格小于1000 |
| `_lte` | **小于等于** | `price_lte=1000` | 价格小于等于1000 |
| `_in` | **包含于** | `status_in=active,pending` | 状态是active或pending |
| `_like` | **模糊匹配** | `name_like=iPhone` | 名称包含iPhone |

### 2.3 多条件过滤


**🔗 组合过滤（AND关系）**
```bash
# 所有条件都要满足
GET /api/products?category=phone&brand=apple&price_gte=3000&status=active

解释：
- category=phone     → 必须是手机分类
- brand=apple        → 必须是苹果品牌  
- price_gte=3000     → 价格必须≥3000元
- status=active      → 状态必须是active

结果：同时满足以上4个条件的商品
```

**📝 数组值过滤（OR关系）**
```bash
# 多个值中的任意一个
GET /api/products?brand_in=apple,samsung,huawei
# 含义：品牌是苹果、三星或华为的商品

GET /api/articles?status_in=published,featured  
# 含义：状态是已发布或精选的文章
```

### 2.4 过滤实际示例


**🛒 电商商品过滤**
```bash
# 筛选3000-8000元的苹果手机，有库存的
GET /api/products?category=phone&brand=apple&price_gte=3000&price_lte=8000&stock_gt=0

# 返回数据
{
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "brand": "apple", 
      "category": "phone",
      "price": 5999,
      "stock": 50,
      "status": "active"
    }
  ],
  "total": 12
}
```

**📰 文章列表过滤**
```bash
# 查找技术分类、已发布、最近30天的文章
GET /api/articles?category=tech&status=published&created_at_gte=2024-12-01

# 后端SQL转换（示例）
SELECT * FROM articles 
WHERE category = 'tech' 
  AND status = 'published' 
  AND created_at >= '2024-12-01'
```

---

## 3. 📊 排序参数设计


### 3.1 为什么需要排序


**生活场景**：在购物网站上，你会按什么顺序查看商品？

```
用户需求场景：
看手机时 → 按价格从低到高排序（省钱）
看销量时 → 按销量从高到低排序（选爆款）  
看评价时 → 按评分从高到低排序（选好货）
看时间时 → 按发布时间排序（看新品）
```

### 3.2 单字段排序


**📋 基本排序语法**
```bash
# 按价格升序（从低到高）
GET /api/products?sort=price&order=asc

# 按价格降序（从高到低）  
GET /api/products?sort=price&order=desc

# 按创建时间降序（最新的在前面）
GET /api/articles?sort=created_at&order=desc
```

**🎯 排序参数说明**

| 参数 | 含义 | 可选值 | 示例 |
|------|------|--------|------|
| `sort` | **排序字段** | 字段名 | `sort=price` |
| `order` | **排序方向** | `asc`/`desc` | `order=desc` |

```
asc  = ascending  = 升序 = 从小到大 = ↗️
desc = descending = 降序 = 从大到小 = ↘️

示例理解：
price asc  → 99, 199, 299, 399 (便宜的在前)
price desc → 399, 299, 199, 99 (贵的在前)
```

### 3.3 多字段排序


**🔗 排序优先级**

就像整理扑克牌：先按花色分组，再按点数排序

```bash
# 先按分类排序，分类相同的再按价格排序
GET /api/products?sort=category,asc;price,desc

解释：
1. 首先按 category 升序排列（A-Z）
2. 分类相同的商品，按 price 降序排列（贵的在前）

结果示例：
分类A: 手机
  - iPhone 15 Pro: 8999元
  - iPhone 15: 5999元  
  - 小米14: 3999元
分类B: 电脑  
  - MacBook Pro: 15999元
  - MacBook Air: 8999元
```

**📝 多字段排序格式**
```bash
# 格式1：分号分隔
sort=field1,order1;field2,order2

# 格式2：多个参数
sort[]=field1,order1&sort[]=field2,order2

# 实际例子
GET /api/products?sort=category,asc;price,desc;created_at,desc
```

### 3.4 常见排序场景


**🛍️ 电商商品排序**
```bash
# 按销量降序（热门商品在前）
GET /api/products?sort=sales&order=desc

# 按评分降序（好评商品在前）
GET /api/products?sort=rating&order=desc

# 按价格升序（便宜的在前）  
GET /api/products?sort=price&order=asc

# 综合排序：先按销量，再按评分，最后按价格
GET /api/products?sort=sales,desc;rating,desc;price,asc
```

**📰 文章排序**
```bash
# 按发布时间降序（最新文章在前）
GET /api/articles?sort=published_at&order=desc

# 按浏览量降序（热门文章在前）
GET /api/articles?sort=views&order=desc

# 按评论数降序（讨论热烈的在前）
GET /api/articles?sort=comments_count&order=desc
```

---

## 4. 🔍 搜索功能实现


### 4.1 什么是搜索


**简单理解**：搜索就像在图书馆找书

```
图书馆找书场景：
输入关键词 "JavaScript"
├─ 书名包含 "JavaScript" 的书
├─ 作者名包含 "JavaScript" 的书  
├─ 简介包含 "JavaScript" 的书
└─ 标签包含 "JavaScript" 的书

搜索结果：所有相关的书都能找到
```

### 4.2 基础搜索设计


**🔍 关键词搜索**
```bash
# 搜索包含关键词的商品
GET /api/products?q=iPhone
# 含义：搜索名称、描述中包含"iPhone"的商品

# 搜索文章
GET /api/articles?q=Vue.js
# 含义：搜索标题、内容中包含"Vue.js"的文章

# 搜索用户
GET /api/users?q=张三
# 含义：搜索用户名、邮箱中包含"张三"的用户
```

**📝 `q` 参数设计规范**

```
q = query = 查询关键词

设计要点：
✅ 参数名简短易记（q 比 keyword 更简洁）
✅ 支持模糊匹配（部分匹配即可）  
✅ 忽略大小写（iPhone = iphone = IPHONE）
✅ 支持空格分词（"iPhone 15" 拆分为 "iPhone" 和 "15"）
```

### 4.3 多字段搜索


**🎯 搜索范围设计**

```bash
# 在商品的多个字段中搜索
GET /api/products?q=苹果

# 后端搜索逻辑
WHERE name LIKE '%苹果%'           -- 商品名称
   OR description LIKE '%苹果%'    -- 商品描述  
   OR brand LIKE '%苹果%'          -- 品牌名称
   OR tags LIKE '%苹果%'           -- 标签
```

**📊 搜索字段权重**

不同字段的重要性不同，可以设置权重：

```
搜索权重设计：
┌─────────────┬──────┬─────────────┐
│   字段名    │ 权重 │    说明     │
├─────────────┼──────┼─────────────┤
│ name        │ 10   │ 标题最重要  │
│ brand       │ 8    │ 品牌很重要  │
│ description │ 5    │ 描述一般    │
│ tags        │ 3    │ 标签次要    │
└─────────────┴──────┴─────────────┘

搜索结果按权重排序，匹配标题的排在前面
```

### 4.4 搜索优化技巧


**🚀 提升搜索体验**

```bash
# 1. 支持空格分词
GET /api/products?q=苹果 手机
# 等价于：(name LIKE '%苹果%' OR name LIKE '%手机%')

# 2. 支持引号精确匹配  
GET /api/products?q="iPhone 15"
# 等价于：name LIKE '%iPhone 15%' （不分词）

# 3. 支持排除关键词
GET /api/products?q=手机 -华为  
# 等价于：name LIKE '%手机%' AND name NOT LIKE '%华为%'
```

**⚡ 搜索性能优化**

```sql
-- 为搜索字段创建索引
CREATE INDEX idx_product_name ON products(name);
CREATE INDEX idx_product_brand ON products(brand);

-- 使用全文搜索索引（MySQL）
ALTER TABLE products ADD FULLTEXT(name, description);
SELECT * FROM products WHERE MATCH(name, description) AGAINST('苹果手机');
```

---

## 5. 🎯 组合查询应用


### 5.1 完整查询示例


**🛒 电商场景：用户找手机**

```bash
# 用户需求：
# - 搜索"苹果手机"  
# - 价格3000-8000元
# - 有库存
# - 按价格从低到高排序
# - 查看第2页，每页10个

GET /api/products?q=苹果手机&category=phone&price_gte=3000&price_lte=8000&stock_gt=0&sort=price&order=asc&page=2&size=10
```

**📊 URL参数解析**

```
参数解析：
┌─────────────┬─────────────┬─────────────────┐
│    参数     │     值      │      含义       │
├─────────────┼─────────────┼─────────────────┤
│ q           │ 苹果手机    │ 搜索关键词      │
│ category    │ phone       │ 手机分类        │  
│ price_gte   │ 3000        │ 价格≥3000元     │
│ price_lte   │ 8000        │ 价格≤8000元     │
│ stock_gt    │ 0           │ 库存>0          │
│ sort        │ price       │ 按价格排序      │
│ order       │ asc         │ 升序排列        │
│ page        │ 2           │ 第2页           │
│ size        │ 10          │ 每页10条        │
└─────────────┴─────────────┴─────────────────┘
```

### 5.2 后端处理流程


**⚙️ 查询构建流程**

```
后端处理步骤：
1️⃣ 解析查询参数
2️⃣ 构建WHERE条件  
3️⃣ 添加ORDER BY排序
4️⃣ 计算分页OFFSET  
5️⃣ 执行SQL查询
6️⃣ 格式化响应数据
```

**🔧 SQL构建示例**

```sql
-- 1. 基础查询
SELECT * FROM products

-- 2. 添加搜索条件
WHERE (name LIKE '%苹果%' OR name LIKE '%手机%' 
       OR description LIKE '%苹果%' OR description LIKE '%手机%')

-- 3. 添加过滤条件  
AND category = 'phone'
AND price >= 3000
AND price <= 8000  
AND stock > 0

-- 4. 添加排序
ORDER BY price ASC

-- 5. 添加分页
LIMIT 10 OFFSET 10;  -- 第2页，每页10条
```

### 5.3 响应数据格式


**📋 完整响应示例**

```json
{
  "data": [
    {
      "id": 15,
      "name": "iPhone 13 苹果手机",
      "category": "phone",
      "brand": "apple",
      "price": 4999,
      "stock": 25,
      "description": "苹果iPhone13手机，性能强劲"
    },
    {
      "id": 23,
      "name": "iPhone 14 苹果手机", 
      "category": "phone",
      "brand": "apple",
      "price": 5999,
      "stock": 18,
      "description": "最新苹果手机，拍照升级"
    }
  ],
  "pagination": {
    "total": 45,          // 符合条件的总数
    "current_page": 2,    // 当前页码
    "total_pages": 5,     // 总页数  
    "page_size": 10,      // 每页数量
    "has_next": true,     // 还有下一页
    "has_prev": true      // 有上一页
  },
  "query": {
    "keyword": "苹果手机",
    "filters": {
      "category": "phone",
      "price_range": "3000-8000",
      "in_stock": true
    },
    "sort": "price_asc"
  }
}
```

### 5.4 前端交互设计


**🎨 用户界面元素**

```
搜索页面布局：
┌─────────────────────────────────────┐
│  🔍 [苹果手机_____________] [搜索]   │
├─────────────────────────────────────┤
│ 筛选条件：                          │
│ 分类：[手机▼] 品牌：[苹果▼]        │  
│ 价格：[3000] - [8000]              │
│ □ 仅显示有库存                     │
├─────────────────────────────────────┤
│ 排序：[价格升序▼]   找到45个结果   │
├─────────────────────────────────────┤
│ [商品1] [商品2] [商品3] ...        │
│                                     │
│ [上一页] [1] [2] [3] [4] [5] [下一页] │
└─────────────────────────────────────┘
```

**📱 移动端适配**

```javascript
// 前端URL构建示例
function buildSearchUrl(params) {
  const url = new URLSearchParams();
  
  if (params.keyword) url.append('q', params.keyword);
  if (params.category) url.append('category', params.category);
  if (params.minPrice) url.append('price_gte', params.minPrice);
  if (params.maxPrice) url.append('price_lte', params.maxPrice);
  if (params.inStock) url.append('stock_gt', '0');
  if (params.sortField) url.append('sort', params.sortField);
  if (params.sortOrder) url.append('order', params.sortOrder);
  url.append('page', params.page || 1);
  url.append('size', params.size || 20);
  
  return `/api/products?${url.toString()}`;
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 分页设计：page/size参数，标准响应格式，计算总页数
🔸 过滤功能：等值过滤、范围过滤、操作符规范(_gte, _lte等)
🔸 排序机制：单字段排序、多字段排序、asc/desc方向
🔸 搜索实现：q参数模糊匹配、多字段搜索、关键词分析
🔸 组合查询：分页+过滤+排序+搜索的综合应用
```

### 6.2 关键理解要点


**🔹 分页的本质**
```
核心目的：
- 减少网络传输量（一次只传20条，不传2万条）
- 提升用户体验（快速加载，避免页面卡顿）  
- 降低服务器压力（减少内存占用和CPU消耗）
- 优化数据库性能（LIMIT查询比全表扫描快）
```

**🔹 过滤的价值**
```
实际作用：
- 精准查找：从海量数据中找到目标内容
- 减少结果集：过滤后的数据更容易浏览
- 提升效率：避免翻页查找特定条件的数据
- 改善体验：用户能快速找到想要的内容
```

**🔹 URL设计原则**
```
设计要点：
✅ 参数名简洁明了（q比keyword好，page比page_number好）
✅ 参数值易于理解（asc/desc比1/0好）
✅ 支持组合使用（可以同时分页、过滤、排序）
✅ 向后兼容（新增参数不影响旧的API调用）
```

### 6.3 最佳实践建议


**🚀 性能优化**
```
数据库层面：
- 为常用过滤字段创建索引
- 为排序字段创建索引  
- 使用LIMIT避免全表扫描
- 考虑使用Redis缓存热门查询

接口设计：
- 设置合理的分页大小限制（如最大100条）
- 提供默认排序规则  
- 对搜索关键词进行SQL注入防护
- 返回查询执行时间供调试使用
```

**📱 用户体验**
```
前端交互：
- 提供搜索建议和自动补全
- 显示筛选条件的选中状态
- 支持URL书签和分享
- 提供清空筛选的快捷操作

错误处理：
- 搜索无结果时给出建议
- 参数错误时返回友好提示
- 分页超出范围时自动跳转到最后一页
```

**🔧 开发规范**
```
API设计：
- 统一的参数命名规范
- 一致的响应数据格式
- 完善的接口文档和示例
- 支持接口版本管理

代码实现：
- 参数校验和类型转换  
- SQL注入防护
- 查询性能监控
- 错误日志记录
```

**核心记忆**：
- 分页让大数据变小块，用户体验更流畅
- 过滤帮用户精准查找，从万里挑一变轻松
- 排序让结果有秩序，想要的内容排前面  
- 搜索如同智能助手，关键词匹配全覆盖
- 组合查询最实用，一个接口满足多需求