---
title: 2、JWT Token详解
---
## 📚 目录

1. [Token是什么？](#1-Token是什么)
2. [JWT基础概念](#2-JWT基础概念)
3. [JWT结构详解](#3-JWT结构详解)
4. [JWT工作流程](#4-JWT工作流程)
5. [Access Token与Refresh Token](#5-Access-Token与Refresh-Token)
6. [Token的安全存储与使用](#6-Token的安全存储与使用)
7. [JWT优势与局限性](#7-JWT优势与局限性)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎫 Token是什么？


### 1.1 通俗理解Token

**简单比喻**：Token就像是**进入景区的门票**或者**电影院的入场券**

```
现实生活中：
你买票 → 拿到门票 → 凭门票进入 → 工作人员验票 → 允许进入

Web系统中：
你登录 → 获得Token → 凭Token访问 → 服务器验证 → 允许访问
```

### 1.2 Token的核心作用

- **身份证明**：证明"你是谁"
- **权限凭证**：证明"你能做什么"
- **临时通行证**：有有效期，过期就失效

> 💡 **简单理解**：Token就是服务器给你的一个"临时身份证"，拿着它就能证明自己的身份

### 1.3 Token vs 传统Session

```
传统Session方式：
用户 → 登录 → 服务器创建Session → 返回SessionID → 存储到Cookie

Token方式：
用户 → 登录 → 服务器生成Token → 返回Token → 前端自己存储
```

**核心区别**：
- **Session**：服务器记住你（有状态）
- **Token**：你自己带着身份证（无状态）

---

## 2. 🔑 JWT基础概念


### 2.1 什么是JWT

**JWT全称**：JSON Web Token（JSON网络令牌）

> 📖 **通俗解释**：JWT就是一种特殊格式的Token，像是一张"电子身份证"，上面写着你的身份信息，还有防伪签名

### 2.2 JWT的特点

```
🔹 自包含：Token里就包含了用户信息，不需要查数据库
🔹 无状态：服务器不需要记住任何信息
🔹 可验证：有数字签名，能防止被篡改
🔹 跨平台：JSON格式，任何编程语言都能处理
```

### 2.3 JWT长什么样？

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywibmFtZSI6IuW8oOS4iSIsImV4cCI6MTY0MDk5NTIwMH0.7HgJbBdJOQ8bKjlGJhU6_mRd2v7pQRh8rJtUi1zYvXg
```

看起来像乱码？其实它有固定的结构！

---

## 3. 🏗️ JWT结构详解


### 3.1 JWT三部分结构

JWT由三部分组成，用 `.` 分隔：

```
Header.Payload.Signature
 头部   载荷    签名
```

```
JWT结构图示：
┌─────────────┬─────────────┬─────────────┐
│   Header    │   Payload   │  Signature  │
│    头部     │    载荷     │    签名     │
├─────────────┼─────────────┼─────────────┤
│  算法信息   │  用户数据   │  防篡改     │
│  Token类型  │  过期时间   │  验证签名   │
└─────────────┴─────────────┴─────────────┘
```

### 3.2 Header（头部）详解

**作用**：说明这是什么类型的Token，用什么算法加密

```json
// Header原始内容
{
  "alg": "HS256",    // 签名算法：HMAC SHA256
  "typ": "JWT"       // Token类型：JWT
}

// Base64编码后：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

> 💡 **通俗理解**：Header就像是信封上的标记，告诉收件人"这是什么类型的信件"

### 3.3 Payload（载荷）详解

**作用**：存放实际的用户信息和Token信息

```json
// Payload原始内容
{
  "userId": 123,           // 用户ID
  "name": "张三",          // 用户姓名  
  "role": "admin",         // 用户角色
  "iat": 1640908800,       // 签发时间
  "exp": 1640995200        // 过期时间
}

// Base64编码后：eyJ1c2VySWQiOjEyMywibmFtZSI6IuW8oOS4iSIsImV4cCI6MTY0MDk5NTIwMH0
```

**常用字段说明**：
- `userId`：用户唯一标识
- `exp`（expire）：过期时间
- `iat`（issued at）：签发时间
- `iss`（issuer）：签发者

> ⚠️ **重要提醒**：Payload是Base64编码，**不是加密**！任何人都能解码看到内容，所以不要放密码等敏感信息

### 3.4 Signature（签名）详解

**作用**：防止Token被篡改，确保数据完整性

```javascript
// 签名生成过程
const header = base64(Header)
const payload = base64(Payload)  
const secret = "你的密钥"

const signature = HMAC_SHA256(header + "." + payload, secret)
```

```
签名验证流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  接收Token  │ →  │  重新计算   │ →  │  对比签名   │
│             │    │    签名     │    │             │
└─────────────┘    └─────────────┘    └─────────────┘
                                           │
                                      ┌─────▼─────┐
                                      │  验证结果  │
                                      │  ✅ 通过   │
                                      │  ❌ 失败   │
                                      └───────────┘
```

> 🔒 **安全关键**：只有知道密钥的服务器才能生成正确的签名，这保证了Token的真实性

---

## 4. ⚡ JWT工作流程


### 4.1 完整认证流程

```
用户登录流程：
客户端                     服务器
   │                        │
   │─────[1]登录请求─────────►│ 
   │  (用户名+密码)           │
   │                        │──[2]验证用户信息
   │                        │
   │◄────[3]返回JWT─────────│ 
   │                        │
   │──[4]存储Token──────────│
   
后续API请求：
客户端                     服务器  
   │                        │
   │─────[1]API请求─────────►│
   │ Header: Authorization   │──[2]验证JWT签名
   │ Bearer eyJhbG...        │
   │                        │──[3]解析用户信息
   │◄────[4]返回数据────────│
```

### 4.2 HTTP请求头格式

```http
GET /api/users HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json
```

**格式说明**：
- 固定前缀：`Bearer ` （注意后面有空格）
- 完整Token：直接拼接在Bearer后面

### 4.3 前端代码示例

```javascript
// 登录获取Token
async function login(username, password) {
  const response = await fetch('/api/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password })
  });
  
  const data = await response.json();
  const token = data.token;
  
  // 存储Token（后面会详细讲存储方式）
  localStorage.setItem('token', token);
}

// 使用Token访问API
async function getUserInfo() {
  const token = localStorage.getItem('token');
  
  const response = await fetch('/api/user', {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  
  return response.json();
}
```

---

## 5. 🔄 Access Token与Refresh Token


### 5.1 为什么需要两种Token？

**问题场景**：如果JWT过期时间太长，被盗用风险大；太短，用户频繁登录体验差

**解决方案**：双Token机制

```
双Token机制：
┌─────────────────┐  ┌─────────────────┐
│  Access Token   │  │ Refresh Token   │
│   (短期有效)     │  │   (长期有效)     │
├─────────────────┤  ├─────────────────┤
│ • 15-30分钟     │  │ • 7-30天        │
│ • 访问API       │  │ • 刷新Token     │
│ • 存储在内存    │  │ • 安全存储      │
└─────────────────┘  └─────────────────┘
```

### 5.2 Token刷新流程

```
Token刷新机制：
客户端                     服务器
   │                        │
   │─────[1]API请求─────────►│
   │ Access Token过期        │──[2]检查Token
   │                        │
   │◄────[3]401错误────────│ (Token过期)
   │                        │
   │─────[4]刷新请求────────►│
   │ Refresh Token          │──[5]验证Refresh Token
   │                        │
   │◄──[6]新的Access Token──│
   │                        │
   │─────[7]重试API─────────►│ 
   │ 新Access Token         │──[8]成功处理
   │                        │
   │◄────[9]返回数据────────│
```

### 5.3 双Token使用示例

```javascript
// Token管理器
class TokenManager {
  // 获取访问令牌
  getAccessToken() {
    return localStorage.getItem('accessToken');
  }
  
  // 获取刷新令牌
  getRefreshToken() {
    return localStorage.getItem('refreshToken');
  }
  
  // 刷新Token
  async refreshToken() {
    const refreshToken = this.getRefreshToken();
    
    const response = await fetch('/api/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken })
    });
    
    const data = await response.json();
    localStorage.setItem('accessToken', data.accessToken);
    
    return data.accessToken;
  }
  
  // 自动处理Token过期的请求
  async apiRequest(url, options = {}) {
    let token = this.getAccessToken();
    
    // 第一次请求
    let response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });
    
    // 如果Token过期，自动刷新
    if (response.status === 401) {
      token = await this.refreshToken();
      
      // 重试请求
      response = await fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        }
      });
    }
    
    return response;
  }
}
```

---

## 6. 🔒 Token的安全存储与使用


### 6.1 Token存储方式对比

| 存储方式 | **安全性** | **便利性** | **适用场景** |
|---------|-----------|-----------|-------------|
| `内存变量` | `⭐⭐⭐⭐⭐` | `⭐⭐` | `高安全要求` |
| `sessionStorage` | `⭐⭐⭐⭐` | `⭐⭐⭐` | `单页面应用` |
| `localStorage` | `⭐⭐⭐` | `⭐⭐⭐⭐⭐` | `一般Web应用` |
| `Cookie` | `⭐⭐⭐⭐` | `⭐⭐⭐⭐` | `需要自动发送` |

### 6.2 推荐存储策略

```javascript
// 推荐方案：分级存储
class SecureTokenStorage {
  constructor() {
    this.accessToken = null; // 内存存储（最安全）
  }
  
  // 设置Token
  setTokens(accessToken, refreshToken) {
    // Access Token存内存（安全）
    this.accessToken = accessToken;
    
    // Refresh Token存储到安全的地方
    this.setRefreshToken(refreshToken);
  }
  
  // 安全存储Refresh Token
  setRefreshToken(refreshToken) {
    // 方案1：localStorage（简单）
    localStorage.setItem('refreshToken', refreshToken);
    
    // 方案2：HttpOnly Cookie（更安全，需要后端配合）
    // 由服务器设置HttpOnly Cookie
  }
  
  // 获取Access Token
  getAccessToken() {
    return this.accessToken;
  }
  
  // 页面刷新时恢复Access Token
  async restoreSession() {
    const refreshToken = localStorage.getItem('refreshToken');
    if (refreshToken) {
      // 使用refresh token获取新的access token
      await this.refreshAccessToken();
    }
  }
}
```

### 6.3 安全使用注意事项

> ⚠️ **重要安全提醒**

```
✅ 应该做的：
• Access Token存储在内存中
• 设置合理的过期时间（15-30分钟）
• 使用HTTPS传输
• 实现自动刷新机制
• 退出登录时清除所有Token

❌ 不应该做的：
• 不要在JWT中存储密码
• 不要在URL参数中传递Token
• 不要使用过长的过期时间
• 不要忽略Token的验证
• 不要在控制台打印Token
```

---

## 7. ⚖️ JWT优势与局限性


### 7.1 JWT的优势

```
🔹 无状态特性
• 服务器不需要存储会话信息
• 水平扩展容易，任何服务器都能验证

🔹 跨域友好  
• 不依赖Cookie，避免CSRF攻击
• 移动APP、微信小程序都能使用

🔹 性能优秀
• 不需要查询数据库验证身份
• 减少服务器存储压力

🔹 信息自包含
• Token中包含用户信息
• 减少数据库查询次数
```

### 7.2 JWT的局限性

```
❌ 无法主动撤销
• Token一旦签发就有效，无法中途取消
• 解决：设置短过期时间 + Refresh Token

❌ 信息泄露风险
• Payload只是Base64编码，不是加密
• 解决：不在Token中存储敏感信息

❌ Token体积较大
• 包含较多信息，每次请求都要传输
• 解决：只包含必要信息，压缩传输

❌ 时间同步问题
• 依赖服务器时间验证过期
• 解决：使用NTP时间同步
```

### 7.3 JWT vs Session对比

| 特性 | **JWT** | **Session** |
|-----|---------|-------------|
| `状态` | `无状态` | `有状态` |
| `扩展性` | `⭐⭐⭐⭐⭐` | `⭐⭐⭐` |
| `安全性` | `⭐⭐⭐⭐` | `⭐⭐⭐⭐⭐` |
| `性能` | `⭐⭐⭐⭐⭐` | `⭐⭐⭐⭐` |
| `撤销能力` | `❌` | `✅` |
| `跨域支持` | `✅` | `⭐⭐⭐` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的概念

```
🔸 Token本质：像是临时身份证，证明"你是谁"和"你能做什么"
🔸 JWT结构：Header.Payload.Signature三部分，用点号分隔
🔸 工作原理：登录获取Token → 请求携带Token → 服务器验证签名
🔸 双Token机制：Access Token短期使用，Refresh Token长期刷新
🔸 安全存储：Access Token存内存，Refresh Token安全存储
```

### 8.2 关键理解要点

**🔹 为什么需要JWT？**
```
传统方式的问题：
• Session需要服务器存储，难以扩展
• Cookie有跨域限制
• 移动端支持不友好

JWT的解决：
• 无状态，易扩展
• 不依赖Cookie，跨域友好
• 标准格式，通用性强
```

**🔹 JWT安全性的核心**
```
关键点：
• 签名防篡改：确保Token没被修改
• 过期时间：防止长期滥用
• 不存敏感信息：Payload可被解码
• HTTPS传输：防止Token泄露
```

### 8.3 实际使用建议

```
最佳实践：
✅ Access Token设置15-30分钟过期
✅ Refresh Token设置7-30天过期  
✅ 实现自动刷新机制，用户无感知
✅ 退出登录时清除所有Token
✅ 使用HTTPS保护Token传输

常见误区：
❌ 把JWT当成万能的，忽略其局限性
❌ 在Payload中存储密码等敏感信息
❌ 设置过长的过期时间
❌ 不处理Token过期的情况
❌ 明文存储Refresh Token
```

### 8.4 学习路径建议

```
学习顺序：
1️⃣ 理解Token的基本概念和作用
2️⃣ 掌握JWT的结构和工作原理
3️⃣ 学会双Token机制的使用
4️⃣ 了解安全存储和最佳实践
5️⃣ 在实际项目中应用和优化
```

**核心记忆**：
- Token是临时身份证，JWT是标准格式
- 三段结构防篡改，双Token机制保安全
- 无状态易扩展，但无法主动撤销
- 安全存储是关键，HTTPS传输保护好