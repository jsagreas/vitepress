---
title: 6、依赖管理最佳实践
---
## 📚 目录

1. [dependencyManagement统一管理](#1-dependencyManagement统一管理)
2. [版本统一管理策略](#2-版本统一管理策略)
3. [BOM材料清单](#3-BOM材料清单)
4. [依赖升级策略](#4-依赖升级策略)
5. [安全依赖管理](#5-安全依赖管理)
6. [许可证管理](#6-许可证管理)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 dependencyManagement统一管理


### 1.1 什么是dependencyManagement


**🔸 通俗理解**
想象你是一个大家庭的家长，有很多孩子（子项目），你需要给每个孩子买同样品牌的鞋子。如果每个孩子自己去买，可能买到不同型号、不同价格的鞋子。但如果你（父项目）统一规定："我们家只买Nike，型号Air Max，价格500元"，然后孩子们按需选择是否要这双鞋，这样既统一了标准，又避免了混乱。

**💡 技术含义**
`dependencyManagement` 就是Maven中的"家长角色"，它在父项目中**统一声明依赖的版本和配置**，但**不强制子项目使用**。子项目如果需要某个依赖，只需要声明groupId和artifactId，版本会自动继承。

### 1.2 为什么需要dependencyManagement


**❌ 没有统一管理的问题**：
```
项目A使用：Spring Boot 2.5.0
项目B使用：Spring Boot 2.7.0  
项目C使用：Spring Boot 3.0.0

结果：版本冲突、API不兼容、维护困难
```

**✅ 使用统一管理的好处**：
```
父项目统一规定：Spring Boot 2.7.0
所有子项目自动使用相同版本

结果：版本一致、兼容性好、维护简单
```

### 1.3 dependencyManagement基本用法


**🏗️ 父项目配置示例**

```xml
<!-- 父项目的pom.xml -->
<dependencyManagement>
    <dependencies>
        <!-- 统一管理Spring Boot版本 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>2.7.0</version>
        </dependency>
        
        <!-- 统一管理MySQL驱动版本 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.33</version>
        </dependency>
        
        <!-- 统一管理测试框架版本 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**👶 子项目使用示例**

```xml
<!-- 子项目的pom.xml -->
<dependencies>
    <!-- 只需声明需要的依赖，版本自动继承 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <!-- 不需要写version，自动使用父项目中的2.7.0 -->
    </dependency>
    
    <!-- 如果不需要MySQL，就不写这个依赖 -->
    <!-- 如果需要，也是自动继承版本 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
</dependencies>
```

### 1.4 dependencyManagement vs dependencies区别


| 🆚 **对比维度** | **dependencyManagement** | **dependencies** |
|-----------------|---------------------------|-------------------|
| 🎯 **作用** | 版本管理，不实际引入 | 实际引入依赖 |
| 📦 **继承性** | 可被子项目继承 | 强制被子项目继承 |
| ⚖️ **灵活性** | 子项目可选择使用 | 子项目必须使用 |
| 💡 **使用场景** | 父项目统一管理 | 具体项目需要依赖 |

**🧠 记忆口诀**：
"dependencyManagement管版本，dependencies真引用"

---

## 2. 📋 版本统一管理策略


### 2.1 使用属性统一版本号


**🔧 问题场景**
假设你的项目使用Spring全家桶，包括Spring Core、Spring Web、Spring Data等，如果每个依赖都单独写版本号：

```xml
<!-- 不好的做法：版本号分散 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>5.3.21</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.3.21</version>  <!-- 版本号重复 -->
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.21</version>  <!-- 版本号重复 -->
</dependency>
```

如果要升级Spring版本，需要改很多地方，容易出错。

**✅ 解决方案：使用properties统一管理**

```xml
<!-- 父项目pom.xml -->
<properties>
    <!-- 定义版本号变量 -->
    <spring.version>5.3.21</spring.version>
    <mysql.version>8.0.33</mysql.version>
    <junit.version>4.13.2</junit.version>
    <lombok.version>1.18.24</lombok.version>
</properties>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>${spring.version}</version>  <!-- 使用变量 -->
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>${spring.version}</version>  <!-- 使用变量 -->
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql.version}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**🎯 优势分析**：
- **维护简单**：升级版本只需修改一个地方
- **避免错误**：不会出现版本不一致的问题
- **清晰明了**：所有版本号集中在properties中

### 2.2 版本号命名规范


**📏 推荐命名规范**：
```xml
<properties>
    <!-- 格式：框架名.version -->
    <spring.version>5.3.21</spring.version>
    <spring.boot.version>2.7.0</spring.boot.version>
    <mybatis.version>3.5.10</mybatis.version>
    
    <!-- 数据库相关 -->
    <mysql.version>8.0.33</mysql.version>
    <h2.version>2.1.214</h2.version>
    
    <!-- 工具类相关 -->
    <lombok.version>1.18.24</lombok.version>
    <gson.version>2.9.0</gson.version>
    
    <!-- 测试相关 -->
    <junit.version>4.13.2</junit.version>
    <mockito.version>4.6.1</mockito.version>
</properties>
```

### 2.3 版本选择策略


**🎯 版本选择原则**：

| 📊 **版本类型** | **特点** | **适用场景** | **示例** |
|-----------------|----------|---------------|----------|
| 🟢 **稳定版(Stable)** | 经过充分测试，bug较少 | 生产环境首选 | `2.7.0` |
| 🟡 **候选版(RC)** | 接近稳定，功能完整 | 测试环境验证 | `2.8.0-RC1` |
| 🟠 **测试版(Beta)** | 新功能测试，可能有bug | 开发环境尝试 | `3.0.0-BETA` |
| 🔴 **快照版(SNAPSHOT)** | 开发中版本，频繁变更 | 内部开发使用 | `3.1.0-SNAPSHOT` |

**💡 实用建议**：
- **生产环境**：只使用稳定版，如 `2.7.0`、`1.18.24`
- **开发环境**：可以适当尝试RC版本，体验新功能
- **避免使用**：SNAPSHOT版本，因为内容可能随时变化

---

## 3. 📦 BOM材料清单


### 3.1 什么是BOM


**🔸 生活类比**
BOM就像是购买家具套装的"配套清单"。比如你买一套客厅家具，商家会给你一个清单：沙发+茶几+电视柜+地毯，这些物品的颜色、风格、尺寸都是匹配的。BOM在Maven中就是这样一个"配套清单"，确保所有相关的依赖版本都是兼容的。

**💡 技术定义**
BOM（Bill Of Materials，材料清单）是一种特殊的POM文件，它只包含`dependencyManagement`，不包含实际代码。它的作用是**统一管理一组相关依赖的版本**，确保这些依赖之间的兼容性。

### 3.2 为什么需要BOM


**❌ 没有BOM的混乱情况**：
```
你的项目中：
Spring Core: 5.3.21
Spring Web: 5.2.15    ← 版本不匹配
Spring Data: 5.4.0    ← 版本不匹配

结果：运行时出现各种奇怪错误
```

**✅ 使用BOM的整齐情况**：
```
导入Spring BOM后：
Spring Core: 5.3.21
Spring Web: 5.3.21    ← 版本统一
Spring Data: 5.3.21   ← 版本统一

结果：所有组件版本协调，运行稳定
```

### 3.3 使用现成的BOM


**🌟 常用的官方BOM**：

```xml
<dependencyManagement>
    <dependencies>
        <!-- Spring Boot BOM：管理Spring Boot全家桶版本 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.7.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- Spring Cloud BOM：管理Spring Cloud版本 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2021.0.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- JUnit BOM：管理JUnit 5全家桶 -->
        <dependency>
            <groupId>org.junit</groupId>
            <artifactId>junit-bom</artifactId>
            <version>5.8.2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**🔑 关键配置说明**：
- `<type>pom</type>`：表示这是一个POM类型的依赖，不是JAR包
- `<scope>import</scope>`：表示导入这个POM中的dependencyManagement

### 3.4 自定义BOM


**🏗️ 创建企业级BOM示例**：

```xml
<!-- company-bom项目的pom.xml -->
<groupId>com.company</groupId>
<artifactId>company-bom</artifactId>
<version>1.0.0</version>
<packaging>pom</packaging>

<properties>
    <spring.boot.version>2.7.0</spring.boot.version>
    <mysql.version>8.0.33</mysql.version>
    <redis.version>3.0.5</redis.version>
</properties>

<dependencyManagement>
    <dependencies>
        <!-- 导入Spring Boot BOM -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring.boot.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- 企业定制的依赖版本 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-redis</artifactId>
            <version>${redis.version}</version>
        </dependency>
        
        <!-- 企业内部工具包 -->
        <dependency>
            <groupId>com.company</groupId>
            <artifactId>common-utils</artifactId>
            <version>2.1.0</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**👨‍👩‍👧‍👦 项目中使用企业BOM**：
```xml
<!-- 业务项目的pom.xml -->
<dependencyManagement>
    <dependencies>
        <!-- 一次性导入企业标准配置 -->
        <dependency>
            <groupId>com.company</groupId>
            <artifactId>company-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### 3.5 BOM最佳实践


**🎯 BOM设计原则**：

```
🔹 单一职责：每个BOM管理特定技术栈
   - spring-bom: 管理Spring相关
   - database-bom: 管理数据库相关
   - test-bom: 管理测试相关

🔹 版本兼容：确保BOM内所有版本都经过兼容性测试

🔹 定期更新：跟随主流技术栈的稳定版本更新

🔹 文档完善：提供BOM包含的依赖列表和版本说明
```

**📊 BOM使用效果对比**：

| 🆚 **维度** | **使用BOM前** | **使用BOM后** |
|-------------|---------------|---------------|
| ⏰ **配置时间** | 2-3小时调试版本冲突 | 5分钟导入BOM |
| 🐛 **版本冲突** | 经常出现，难以排查 | 极少出现，兼容性好 |
| 🔄 **版本升级** | 需要逐个依赖调整 | 只需升级BOM版本 |
| 👥 **团队协作** | 每个人配置不同 | 全团队配置统一 |

---

## 4. 🚀 依赖升级策略


### 4.1 依赖升级的必要性


**💡 为什么要升级依赖**

升级依赖就像给汽车做保养，看起来车还能开，但不保养就会出问题：

```
🔧 功能改进：新版本提供更好用的功能
🛡️ 安全补丁：修复已知的安全漏洞
🐛 Bug修复：解决旧版本的问题
⚡ 性能优化：运行更快，占用更少资源
🔄 兼容性：与其他组件更好地协作
```

### 4.2 升级前的准备工作


**📋 升级检查清单**：

```
✅ 查看当前版本：了解现在使用的版本
✅ 查看目标版本：确定要升级到的版本
✅ 阅读升级文档：重点关注Breaking Changes（不兼容变更）
✅ 检查依赖关系：确保其他依赖也兼容新版本
✅ 备份代码：准备回滚方案
✅ 准备测试：制定测试计划
```

**🔍 版本信息查看工具**：

```bash
# 查看项目当前所有依赖版本
mvn dependency:list

# 查看依赖树，了解传递依赖
mvn dependency:tree

# 检查是否有更新版本可用
mvn versions:display-dependency-updates
```

### 4.3 渐进式升级策略


**🎯 升级策略选择**：

| 📊 **升级类型** | **风险等级** | **升级建议** | **示例** |
|-----------------|--------------|--------------|----------|
| 🟢 **补丁升级** | 低 | 可直接升级 | `2.7.0 → 2.7.1` |
| 🟡 **次版本升级** | 中 | 谨慎测试后升级 | `2.7.1 → 2.8.0` |
| 🔴 **主版本升级** | 高 | 充分评估后升级 | `2.8.0 → 3.0.0` |

**🔄 渐进式升级步骤**：

```
Step 1 🧪 → 在开发环境先试验
Step 2 🔍 → 运行完整测试套件  
Step 3 🚀 → 在测试环境部署
Step 4 ✅ → 在预生产环境验证
Step 5 🎯 → 最后在生产环境发布
```

### 4.4 升级过程管理


**📝 升级执行步骤**：

```xml
<!-- 1. 先在properties中修改版本号 -->
<properties>
    <!-- 从旧版本 -->
    <spring.boot.version>2.6.0</spring.boot.version>
    <!-- 升级到新版本 -->
    <spring.boot.version>2.7.0</spring.boot.version>
</properties>
```

```bash
# 2. 重新下载依赖
mvn clean compile

# 3. 运行测试
mvn test

# 4. 检查是否有冲突
mvn dependency:tree
```

**⚠️ 常见升级问题及解决**：

```
问题1：API不兼容
现象：编译错误，提示方法不存在
解决：查看升级文档，更新代码调用方式

问题2：配置项变更
现象：应用启动失败，配置无法识别
解决：更新配置文件，使用新的配置格式

问题3：传递依赖冲突
现象：运行时出现ClassNotFoundException
解决：使用<exclusions>排除冲突的传递依赖
```

### 4.5 自动化升级工具


**🛠️ Maven版本管理插件**：

```xml
<!-- 在pom.xml中添加版本插件 -->
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>versions-maven-plugin</artifactId>
    <version>2.11.0</version>
</plugin>
```

**🔧 常用升级命令**：

```bash
# 查看所有可更新的依赖
mvn versions:display-dependency-updates

# 查看可更新的插件
mvn versions:display-plugin-updates

# 自动升级到最新版本（谨慎使用）
mvn versions:use-latest-versions

# 升级到下一个发布版本
mvn versions:use-next-releases
```

---

## 5. 🛡️ 安全依赖管理


### 5.1 依赖安全的重要性


**🚨 安全威胁实例**

依赖安全就像家里的门锁，你可能觉得自己的代码很安全，但如果使用了有漏洞的第三方库，就像给小偷留了一把钥匙：

```
真实案例：
2021年log4j漏洞（CVE-2021-44228）
影响：全球数百万应用受到攻击威胁
原因：log4j库存在远程代码执行漏洞
教训：第三方依赖的安全性至关重要
```

### 5.2 安全漏洞检测


**🔍 Maven安全检查插件**：

```xml
<!-- OWASP依赖检查插件 -->
<plugin>
    <groupId>org.owasp</groupId>
    <artifactId>dependency-check-maven</artifactId>
    <version>7.1.1</version>
    <configuration>
        <!-- 生成HTML报告 -->
        <format>HTML</format>
        <!-- 设置严重级别阈值 -->
        <failBuildOnCVSS>7</failBuildOnCVSS>
    </configuration>
</plugin>
```

**🔧 安全检查命令**：

```bash
# 执行安全漏洞扫描
mvn org.owasp:dependency-check-maven:check

# 查看安全报告（会生成target/dependency-check-report.html）
```

### 5.3 安全漏洞处理


**📋 漏洞处理流程**：

```
Step 1 🔍 → 识别漏洞依赖
Step 2 📖 → 了解漏洞详情和影响范围
Step 3 🔄 → 寻找修复方案（升级版本）
Step 4 🧪 → 在测试环境验证修复
Step 5 🚀 → 紧急发布修复版本
```

**💊 漏洞修复示例**：

```xml
<!-- 发现问题：使用了有漏洞的log4j版本 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.14.0</version>  <!-- 存在安全漏洞 -->
</dependency>

<!-- 修复方案：升级到安全版本 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.17.0</version>  <!-- 安全版本 -->
</dependency>
```

### 5.4 安全管理最佳实践


**🎯 安全管理策略**：

```
🔹 定期扫描：每周或每次发布前执行安全扫描

🔹 及时更新：关注安全公告，及时升级有漏洞的依赖

🔹 最小权限：只引入必要的依赖，避免过度依赖

🔹 来源可信：优先使用知名的、维护良好的开源项目

🔹 版本固定：不要使用LATEST或SNAPSHOT版本

🔹 监控告警：建立安全漏洞监控和告警机制
```

**📊 依赖风险评估**：

| 🎯 **风险因素** | **低风险** | **中风险** | **高风险** |
|-----------------|------------|------------|------------|
| 📅 **更新频率** | 定期更新 | 偶尔更新 | 长期未更新 |
| 👥 **社区活跃度** | 活跃 | 一般 | 不活跃 |
| 🏢 **维护者** | 知名组织 | 个人维护 | 匿名维护 |
| 🔍 **历史漏洞** | 很少 | 偶尔出现 | 经常出现 |

---

## 6. 📄 许可证管理


### 6.1 为什么要关注许可证


**💡 许可证的重要性**

许可证就像软件的"使用说明书"，告诉你这个软件可以怎么用、不能怎么用：

```
就像借书一样：
🔹 有些书只能在图书馆看（限制使用）
🔹 有些书可以借回家看（允许使用）
🔹 有些书可以复印（允许复制）
🔹 有些书必须注明出处（要求署名）
```

**⚠️ 许可证风险**：
- **法律风险**：使用不当可能面临版权诉讼
- **商业风险**：某些许可证禁止商业使用
- **合规风险**：企业需要遵守许可证条款

### 6.2 常见开源许可证类型


**📋 主要许可证特点**：

| 📜 **许可证类型** | **商业使用** | **修改代码** | **分发要求** | **典型项目** |
|-------------------|--------------|--------------|--------------|--------------|
| 🟢 **Apache 2.0** | ✅ 允许 | ✅ 允许 | 保留版权声明 | Spring、Hadoop |
| 🟢 **MIT** | ✅ 允许 | ✅ 允许 | 保留版权声明 | jQuery、React |
| 🟡 **LGPL** | ✅ 允许 | ✅ 允许 | 开源修改部分 | MySQL客户端 |
| 🔴 **GPL** | ✅ 允许 | ✅ 允许 | 整个项目开源 | Linux、MySQL服务端 |
| 🟠 **BSD** | ✅ 允许 | ✅ 允许 | 保留版权声明 | FreeBSD |

**🧠 记忆技巧**：
- **绿色（宽松）**：Apache、MIT、BSD - 商业友好
- **黄色（中等）**：LGPL - 部分开源要求
- **红色（严格）**：GPL - 全部开源要求

### 6.3 许可证检查工具


**🔍 Maven许可证插件**：

```xml
<!-- 许可证检查插件 -->
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>license-maven-plugin</artifactId>
    <version>2.0.0</version>
    <configuration>
        <!-- 生成许可证报告 -->
        <fileTemplate>/org/codehaus/mojo/license/third-party-file-groupByLicense.ftl</fileTemplate>
        <useMissingFile>true</useMissingFile>
        <missingFile>src/license/THIRD-PARTY.properties</missingFile>
    </configuration>
</plugin>
```

**📋 生成许可证报告**：

```bash
# 生成第三方依赖许可证报告
mvn license:add-third-party

# 检查许可证冲突
mvn license:check-third-party
```

### 6.4 许可证管理策略


**🎯 企业许可证管理流程**：

```
Step 1 📋 → 制定许可证白名单（允许使用的许可证）
Step 2 🚫 → 制定许可证黑名单（禁止使用的许可证）
Step 3 🔍 → 在CI/CD中集成许可证检查
Step 4 📊 → 定期生成许可证合规报告
Step 5 ⚖️ → 法务团队审核高风险许可证
```

**✅ 许可证白名单示例**：

```xml
<!-- 允许的许可证列表 -->
<configuration>
    <includedLicenses>
        <includedLicense>Apache License, Version 2.0</includedLicense>
        <includedLicense>MIT License</includedLicense>
        <includedLicense>BSD License</includedLicense>
        <includedLicense>Eclipse Public License</includedLicense>
    </includedLicenses>
</configuration>
```

**❌ 许可证黑名单示例**：

```xml
<!-- 禁止的许可证列表 -->
<configuration>
    <excludedLicenses>
        <excludedLicense>GNU General Public License (GPL)</excludedLicense>
        <excludedLicense>GNU Affero General Public License</excludedLicense>
        <!-- 商业软件禁止的许可证 -->
    </excludedLicenses>
</configuration>
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 dependencyManagement：父项目统一管理版本，子项目继承使用
🔸 BOM材料清单：一套兼容的依赖版本组合，避免版本冲突
🔸 版本属性管理：使用properties统一管理版本号
🔸 安全依赖：定期扫描和修复依赖中的安全漏洞
🔸 许可证合规：了解和遵守开源软件的使用许可
```

### 7.2 关键理解要点


**🔹 dependencyManagement的本质**
```
不是强制继承，而是版本建议：
- 父项目：我建议用Spring Boot 2.7.0版本
- 子项目：我需要Spring Boot（版本听你的）
- 结果：子项目自动使用2.7.0版本
```

**🔹 BOM的价值**
```
解决版本兼容性问题：
- 没有BOM：各个依赖版本可能不匹配，运行出错
- 使用BOM：一套经过测试的版本组合，稳定可靠
```

**🔹 安全管理的重要性**
```
第三方依赖是安全短板：
- 自己的代码很安全
- 但依赖库有漏洞
- 整个应用就不安全
```

### 7.3 实际应用价值


**💼 企业级应用场景**：
- **微服务架构**：统一管理所有服务的依赖版本
- **团队协作**：确保所有开发者使用相同的依赖版本
- **版本升级**：一次修改，全项目生效
- **安全合规**：满足企业安全和法律要求

**🛠️ 实践操作建议**：
- **小项目**：使用properties管理版本即可
- **大项目**：建议创建企业BOM统一管理
- **生产环境**：必须进行安全扫描和许可证检查

### 7.4 避免常见误区


**❌ 错误做法 vs ✅ 正确做法**：

```
❌ 每个子项目都写版本号 → ✅ 在父项目统一管理版本
❌ 使用LATEST或SNAPSHOT → ✅ 使用明确的稳定版本号
❌ 忽略安全漏洞警告 → ✅ 及时修复依赖安全问题
❌ 不关注许可证类型 → ✅ 检查许可证合规性
❌ 一次性大版本升级 → ✅ 渐进式小步快跑升级
```

**🧠 记忆口诀**：
```
"父管版本子继承，BOM统一好轻松
安全扫描不能少，许可合规要记牢
升级谨慎小步走，依赖管理无烦恼"
```

### 7.5 学习检查点


**✅ 掌握检验标准**：
- **基础级**：能配置dependencyManagement和properties
- **应用级**：能使用和创建BOM，进行版本升级
- **进阶级**：能进行安全扫描和许可证管理
- **专家级**：能设计企业级依赖管理策略

**🎯 实践建议**：
1. 先在小项目中练习使用dependencyManagement
2. 尝试使用Spring Boot BOM等现成的BOM
3. 学会使用security和license检查插件
4. 在实际项目中建立依赖升级流程

**核心价值**：掌握依赖管理最佳实践，能够构建稳定、安全、可维护的企业级应用系统。