---
title: 6、依赖范围详解
---
## 📚 目录

1. [依赖范围基本概念](#1-依赖范围基本概念)
2. [六大依赖范围详解](#2-六大依赖范围详解)
3. [依赖范围的实际应用](#3-依赖范围的实际应用)
4. [依赖范围选择指南](#4-依赖范围选择指南)
5. [常见问题与注意事项](#5-常见问题与注意事项)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 依赖范围基本概念


### 1.1 什么是依赖范围


**简单理解**：依赖范围就像是给你的项目中每个外部库"发通行证"，决定它们在什么时候、什么地方可以被使用。

> 💡 **通俗解释**
> 
> 想象你在盖房子，需要各种工具：
> - 有些工具从开工到完工都要用（锤子、螺丝刀）
> - 有些工具只在建造时用，住进去就不需要了（脚手架）  
> - 有些工具只在测试房子质量时用（检测仪器）

Maven的依赖范围就是这个道理，**不同的库在项目的不同阶段发挥作用**。

### 1.2 为什么需要依赖范围


**核心作用**：
- 🎯 **精确控制**：决定依赖在哪个阶段可用
- 💾 **优化打包**：避免将不必要的jar包打进最终产品
- 🚀 **提升性能**：减小应用程序体积，加快启动速度
- 🔧 **环境适配**：不同环境使用不同的依赖版本

### 1.3 依赖范围的工作原理


```
项目生命周期阶段：
编译期 → 测试期 → 运行期 → 打包期

不同范围的依赖在不同阶段的可见性：
compile   : ✅ ✅ ✅ ✅  (全程可用)
provided  : ✅ ✅ ❌ ❌  (编译测试可用，运行时不打包)
runtime   : ❌ ✅ ✅ ✅  (运行测试可用，编译时不可见)
test      : ❌ ✅ ❌ ❌  (仅测试可用)
system    : ✅ ✅ ❌ ❌  (类似provided，但指定本地路径)
import    : ❌ ❌ ❌ ❌  (仅用于导入依赖管理)
```

---

## 2. 📋 六大依赖范围详解


### 2.1 compile范围 - 默认全能选手


**🔸 核心特点**
```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
    <!-- 不写scope，默认就是compile -->
    <scope>compile</scope>
</dependency>
```

**含义解释**：
- **默认范围**：不指定scope时就是compile
- **全生命周期**：编译、测试、运行都可以使用
- **会被打包**：最终的jar/war包会包含这个依赖
- **传递性强**：会传递给依赖这个项目的其他项目

**适用场景**：
- ✅ **核心业务库**：Spring框架、MyBatis等
- ✅ **工具类库**：Apache Commons、Guava等
- ✅ **日志框架**：Logback、SLF4J等

> ⭐ **记忆技巧**
> 
> compile = 编译器，编译器需要的东西，运行时肯定也需要

### 2.2 provided范围 - 环境已提供


**🔸 核心特点**
```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
</dependency>
```

**含义解释**：
- **编译需要**：写代码时必须要有，否则编译报错
- **运行时排除**：打包时不包含，因为运行环境已经有了
- **测试可用**：单元测试时可以使用
- **不传递**：不会传递给其他依赖此项目的项目

**典型应用场景**：

| 场景 | 库名 | 原因说明 |
|------|------|----------|
| **Web容器API** | `servlet-api` | Tomcat容器已经提供 |
| **JEE环境** | `javaee-api` | 应用服务器已包含 |
| **Android开发** | `android.jar` | Android系统已提供 |
| **IDE插件开发** | `idea-sdk` | IDE环境已包含 |

**实际例子**：
```
开发Web应用时：
1. 写代码需要 HttpServletRequest 类 → 需要 servlet-api
2. 部署到Tomcat时，Tomcat自带 servlet-api → 不能重复包含
3. 如果打包时包含了，可能导致版本冲突

解决方案：使用 provided 范围
```

> 💡 **记忆技巧**
> 
> provided = 已提供，就像住酒店，酒店已经提供了床单被子，你就不用自己带了

### 2.3 runtime范围 - 运行时专用


**🔸 核心特点**
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
    <scope>runtime</scope>
</dependency>
```

**含义解释**：
- **编译不需要**：写代码时不直接使用，编译期不可见
- **运行时必需**：程序运行时必须要有
- **会被打包**：最终产品中包含此依赖
- **测试可用**：集成测试时可以使用

**典型应用场景**：

| 类型 | 示例 | 为什么用runtime |
|------|------|----------------|
| **数据库驱动** | MySQL、PostgreSQL驱动 | 代码中不直接import驱动类，通过JDBC URL动态加载 |
| **日志实现** | logback-classic | 代码中只用SLF4J接口，具体实现运行时加载 |
| **JSON解析器** | jackson-databind | 通过Spring自动配置，代码中不直接使用 |

**详细举例**：
```
使用MySQL的典型流程：
1. 代码中写：Class.forName("com.mysql.cj.jdbc.Driver")
2. 编译时：编译器不需要知道Driver具体实现
3. 运行时：JVM动态加载mysql-connector-java.jar中的Driver类
4. 如果runtime时没有这个jar → ClassNotFoundException
```

> 💡 **记忆技巧**
> 
> runtime = 跑步时间，写代码时不需要跑鞋，真正跑步时才需要

### 2.4 test范围 - 测试专属


**🔸 核心特点**
```xml
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <scope>test</scope>
</dependency>
```

**含义解释**：
- **仅测试阶段**：只有执行测试时才可用
- **不会打包**：最终产品中不包含
- **不传递**：其他项目依赖时获取不到这些测试依赖
- **存放路径**：通常测试代码在`src/test/java`目录下

**常见测试依赖**：

| 测试框架 | 用途说明 |
|----------|----------|
| **JUnit** | 单元测试框架，写@Test方法 |
| **Mockito** | 模拟对象框架，创建mock对象 |
| **TestNG** | 另一个测试框架，功能比JUnit更强 |
| **Spring-test** | Spring测试支持，@MockBean等 |
| **H2 Database** | 内存数据库，测试时替代真实数据库 |

**项目结构对应**：
```
src/
├── main/java/          ← compile, provided, runtime 依赖可用
│   └── UserService.java
└── test/java/          ← test 依赖额外可用
    └── UserServiceTest.java  ← 这里能用JUnit
```

> ⚠️ **新手常见错误**
> 
> 把JUnit的scope设为compile，导致最终jar包很大且包含不必要的测试框架

### 2.5 system范围 - 系统本地依赖


**🔸 核心特点**
```xml
<dependency>
    <groupId>com.custom</groupId>
    <artifactId>custom-lib</artifactId>
    <version>1.0</version>
    <scope>system</scope>
    <systemPath>${project.basedir}/lib/custom-lib.jar</systemPath>
</dependency>
```

**含义解释**：
- **本地路径**：依赖必须通过systemPath指定具体的文件路径
- **类似provided**：编译和测试时可用，打包时不包含
- **不推荐使用**：Maven官方不推荐，可能在未来版本中移除
- **移植性差**：不同机器上的路径可能不同

**为什么不推荐**：
- 🚫 **路径依赖**：换台电脑可能找不到jar包
- 🚫 **难以管理**：无法享受Maven依赖管理的便利
- 🚫 **团队协作困难**：其他开发者可能缺少这个jar文件

**更好的替代方案**：
```xml
<!-- 推荐：将jar安装到本地仓库 -->
<!-- 命令：mvn install:install-file -DgroupId=com.custom -DartifactId=custom-lib -Dversion=1.0 -Dpackaging=jar -Dfile=custom-lib.jar -->

<dependency>
    <groupId>com.custom</groupId>
    <artifactId>custom-lib</artifactId>
    <version>1.0</version>
</dependency>
```

### 2.6 import范围 - 依赖管理导入


**🔸 核心特点**
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.7.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**含义解释**：
- **仅用于`<dependencyManagement>`**：不能在普通dependencies中使用
- **类型必须是pom**：只能导入pom类型的依赖
- **版本管理**：导入其他项目的依赖版本定义
- **不实际引入**：本身不添加任何jar包到项目中

**实际应用场景**：
```
Spring Boot项目中：
1. spring-boot-dependencies.pom 定义了几百个常用库的版本
2. 使用 import 导入这些版本定义
3. 项目中使用这些库时不用指定版本号
4. 避免版本冲突，确保兼容性
```

**效果对比**：
```xml
<!-- 导入后，可以不指定版本 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <!-- 版本号从导入的BOM中获取 -->
</dependency>
```

> 💡 **记忆技巧**
> 
> import = 导入，就像导入Excel模板，只要格式和规则，不要具体数据

---

## 3. 🚀 依赖范围的实际应用


### 3.1 Spring Boot Web项目依赖范围实战


```xml
<!-- 典型的Spring Boot Web项目依赖配置 -->
<dependencies>
    <!-- ✅ compile: 核心框架 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <!-- 默认compile，编译运行都需要 -->
    </dependency>
    
    <!-- ✅ provided: Web容器API -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-tomcat</artifactId>
        <scope>provided</scope>
        <!-- 部署到外部Tomcat时不需要内嵌Tomcat -->
    </dependency>
    
    <!-- ✅ runtime: 数据库驱动 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
        <!-- 编译时不直接使用，运行时动态加载 -->
    </dependency>
    
    <!-- ✅ test: 测试框架 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <!-- 只在测试时需要 -->
    </dependency>
</dependencies>
```

### 3.2 依赖范围对打包的影响


**打包结果对比**：
```
假设项目有以下依赖：
- spring-core (compile)     → 大小：1.2MB
- servlet-api (provided)    → 大小：0.3MB  
- mysql-driver (runtime)    → 大小：2.1MB
- junit (test)             → 大小：0.8MB

最终war/jar包中包含：
✅ spring-core.jar     (1.2MB)
❌ servlet-api.jar     (不包含)
✅ mysql-driver.jar    (2.1MB)  
❌ junit.jar          (不包含)

总大小：3.3MB (而不是4.4MB)
```

### 3.3 不同部署环境的范围策略


| 部署方式 | servlet-api范围 | 原因 |
|----------|----------------|------|
| **内嵌Tomcat** (Spring Boot jar) | `compile` | jar包需要包含Tomcat |
| **外部Tomcat** (传统war) | `provided` | Tomcat已提供servlet-api |
| **Docker容器** | `compile` | 容器中需要完整依赖 |

---

## 4. 🎯 依赖范围选择指南


### 4.1 选择流程图


```
开始选择依赖范围
        ↓
    这个依赖仅用于测试？
        ↓ 是              ↓ 否
    使用 test          编译时需要使用？
                          ↓ 是              ↓ 否
                      运行时需要？        使用 runtime
                      ↓ 是      ↓ 否
                  运行环境     使用
                  已提供？    provided
                  ↓ 是  ↓ 否
              使用        使用
            provided    compile
```

### 4.2 快速判断表


| 问题 | compile | provided | runtime | test |
|------|---------|----------|---------|------|
| 编译时需要？ | ✅ | ✅ | ❌ | ❌ |
| 测试时需要？ | ✅ | ✅ | ✅ | ✅ |
| 运行时需要？ | ✅ | ❌ | ✅ | ❌ |
| 打包时包含？ | ✅ | ❌ | ✅ | ❌ |

### 4.3 常见库的推荐范围


**🔸 Web开发常用库**
```xml
<!-- 框架核心 → compile -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <scope>compile</scope> <!-- 或不写，默认compile -->
</dependency>

<!-- Servlet API → provided -->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <scope>provided</scope>
</dependency>

<!-- 数据库驱动 → runtime -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- 测试框架 → test -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <scope>test</scope>
</dependency>
```

---

## 5. ⚠️ 常见问题与注意事项


### 5.1 新手常见错误


**❌ 错误1：测试框架使用compile范围**
```xml
<!-- 错误写法 -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <scope>compile</scope> <!-- ❌ 会打包到生产环境 -->
</dependency>

<!-- 正确写法 -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <scope>test</scope> <!-- ✅ 只在测试时使用 -->
</dependency>
```

**❌ 错误2：数据库驱动使用compile范围**
```xml
<!-- 可以工作，但不是最佳实践 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>compile</scope> <!-- ❌ 编译期不需要 -->
</dependency>

<!-- 更合适的写法 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope> <!-- ✅ 运行时加载 -->
</dependency>
```

### 5.2 版本冲突问题


**问题场景**：
```
项目依赖：servlet-api (provided)
容器提供：servlet-api 3.1
项目期望：servlet-api 4.0

结果：运行时使用容器提供的3.1版本，可能出现兼容性问题
```

**解决方案**：
- 📋 **确认容器版本**：了解目标部署环境的API版本
- 🔧 **统一版本管理**：使用与容器相同的API版本开发
- 🧪 **充分测试**：在目标环境中进行集成测试

### 5.3 依赖传递注意事项


**传递规则**：
```
A项目依赖B项目，B项目有以下依赖：
- spring-core (compile)    → A项目可以使用
- servlet-api (provided)   → A项目获取不到
- mysql-driver (runtime)   → A项目可以使用  
- junit (test)            → A项目获取不到
```

> 💡 **传递性记忆法则**
> 
> 只有compile和runtime范围的依赖会传递给依赖方

---

## 6. 📋 核心要点总结


### 6.1 六大范围速记


| 范围 | **使用场合** | **记忆口诀** |
|------|-------------|-------------|
| **compile** | `默认选择，全程可用` | `编译运行都要用` |
| **provided** | `容器环境已提供` | `环境有了我不带` |
| **runtime** | `运行时动态加载` | `跑起来才需要` |
| **test** | `仅测试阶段使用` | `测试专用不打包` |
| **system** | `本地系统文件` | `不推荐，少用为好` |
| **import** | `导入版本管理` | `只要规则不要包` |

### 6.2 选择依赖范围的关键问题


**🔸 三个核心判断**：
1. **编译时需要吗？** → 需要就不是runtime，不需要就不是compile/provided
2. **运行时需要吗？** → 需要就不是provided/test，不需要就不是compile/runtime  
3. **仅测试使用吗？** → 是就用test，不是就考虑其他范围

**🔸 实用建议**：
- 🎯 **从严选择**：能用更严格的范围就不用宽松的
- 📦 **考虑打包**：生产环境不需要的依赖避免使用compile
- 🔄 **遵循约定**：相同类型的库使用相同的范围约定
- 🧪 **充分测试**：不同范围配置下都要测试应用是否正常

### 6.3 最佳实践总结


> 💎 **黄金法则**
> 
> - **能用provided不用compile** - 避免与环境冲突
> - **能用runtime不用compile** - 减少编译时耦合  
> - **测试依赖必用test** - 保持生产环境纯净
> - **避免使用system** - 保证项目可移植性

**记住：正确的依赖范围 = 更小的包体积 + 更少的冲突 + 更清晰的架构** 🎯