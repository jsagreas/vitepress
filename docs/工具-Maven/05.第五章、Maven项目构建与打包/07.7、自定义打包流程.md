---
title: 7、自定义打包流程
---
## 📚 目录

1. [什么是自定义打包流程](#1-什么是自定义打包流程)
2. [Assembly插件基础概念](#2-Assembly插件基础概念)
3. [Assembly描述符详解](#3-Assembly描述符详解)
4. [自定义打包格式实战](#4-自定义打包格式实战)
5. [文件集合与目录映射](#5-文件集合与目录映射)
6. [权限设置与输出控制](#6-权限设置与输出控制)
7. [实际应用场景](#7-实际应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 什么是自定义打包流程


### 1.1 为什么需要自定义打包


**🤔 思考一个场景**：
```
你开发了一个Web应用，需要部署到服务器：
📁 默认Maven打包只给你一个jar文件
📁 但你还需要：配置文件、启动脚本、文档、依赖库...
📁 如果手动收集这些文件 → 容易出错，效率低

自定义打包就是为了解决这个问题！
```

**💡 自定义打包的本质**：
- **定制化**：按你的需求组织文件和目录结构
- **自动化**：一个命令就把所有需要的文件打包好
- **标准化**：团队成员都用相同的打包规则

### 1.2 自定义打包能做什么


**🎁 打包结果示例**：
```
传统JAR包：
myapp.jar  (只有编译后的class文件)

自定义打包后：
myapp-distribution.tar.gz
├── bin/
│   ├── startup.sh      ← 启动脚本
│   └── shutdown.sh     ← 停止脚本
├── lib/
│   ├── myapp.jar       ← 主程序
│   └── dependencies/   ← 所有依赖库
├── config/
│   ├── application.yml ← 配置文件
│   └── logback.xml     ← 日志配置
├── docs/
│   └── README.txt      ← 说明文档
└── logs/               ← 日志目录(空目录)
```

**⭐ 核心价值**：
- 🚀 **一键部署**：下载包后直接运行，不需要额外配置
- 🔧 **环境独立**：所有依赖都在包里，不依赖服务器环境
- 📋 **标准结构**：统一的目录结构，便于运维管理

---

## 2. 🛠️ Assembly插件基础概念


### 2.1 什么是Assembly插件


**📋 简单理解**：
Assembly插件就是Maven的"高级打包工具"，可以把你指定的文件按照你的要求组织成各种格式的包。

**🔧 核心组件**：
```
Assembly插件 = 插件本身 + 描述符文件

插件本身：负责执行打包动作
描述符文件：告诉插件"怎么打包"
```

### 2.2 插件配置基础


**pom.xml中的基本配置**：
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-assembly-plugin</artifactId>
            <version>3.4.2</version>
            <configuration>
                <!-- 描述符文件位置 -->
                <descriptors>
                    <descriptor>src/assembly/distribution.xml</descriptor>
                </descriptors>
                <!-- 输出文件名不包含assembly id -->
                <appendAssemblyId>false</appendAssemblyId>
            </configuration>
            <executions>
                <execution>
                    <id>make-assembly</id>
                    <phase>package</phase>
                    <goals>
                        <goal>single</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

**📖 配置说明**：
- `descriptors`：指定描述符文件路径
- `appendAssemblyId`：是否在文件名后添加assembly ID
- `execution`：在package阶段自动执行打包

### 2.3 执行打包命令


**💻 命令行操作**：
```bash
# 执行打包
mvn clean package

# 只执行assembly打包
mvn assembly:single

# 跳过测试直接打包
mvn clean package -DskipTests
```

**✅ 成功标志**：
```
[INFO] Building tar: /project/target/myapp-1.0.tar.gz
[INFO] Building zip: /project/target/myapp-1.0.zip
[INFO] BUILD SUCCESS
```

---

## 3. 📝 Assembly描述符详解


### 3.1 描述符文件结构


Assembly描述符是一个XML文件，告诉Maven如何组织和打包你的文件。

**🏗️ 基本结构**：
```xml
<assembly>
    <!-- 基本信息 -->
    <id>distribution</id>
    <formats>
        <format>tar.gz</format>
        <format>zip</format>
    </formats>
    
    <!-- 是否包含根目录 -->
    <includeBaseDirectory>false</includeBaseDirectory>
    
    <!-- 文件集合定义 -->
    <fileSets>
        <!-- 具体的文件集合配置 -->
    </fileSets>
    
    <!-- 依赖处理 -->
    <dependencySets>
        <!-- 依赖库的处理配置 -->
    </dependencySets>
</assembly>
```

### 3.2 格式类型详解


**📦 支持的打包格式**：

| 格式 | 说明 | 适用场景 | 优缺点 |
|------|------|----------|---------|
| **tar.gz** | 压缩的tar包 | Linux服务器部署 | ✅ 压缩率高，保留权限<br/>❌ Windows支持差 |
| **zip** | 标准zip文件 | Windows环境 | ✅ 通用性好<br/>❌ 不保留文件权限 |
| **jar** | Java归档文件 | 可执行jar包 | ✅ 直接运行<br/>❌ 结构固定 |
| **war** | Web应用包 | Web服务器部署 | ✅ 标准格式<br/>❌ 仅适用web应用 |

**💡 实际选择建议**：
- **跨平台部署**：同时生成tar.gz和zip
- **Linux服务器**：优先选择tar.gz
- **开发测试**：使用zip方便查看

### 3.3 includeBaseDirectory详解


这个配置决定了包的根目录结构：

**🔸 includeBaseDirectory=true（默认）**：
```
myapp-1.0.tar.gz
└── myapp-1.0/          ← 自动创建根目录
    ├── bin/
    ├── lib/
    └── config/
```

**🔸 includeBaseDirectory=false**：
```
myapp-1.0.tar.gz
├── bin/                ← 直接是你配置的目录
├── lib/
└── config/
```

**🎯 选择建议**：
- **发布给最终用户**：设为true，便于识别版本
- **自动化部署**：设为false，便于脚本处理

---

## 4. 🎨 自定义打包格式实战


### 4.1 创建一个完整的分发包


**目标**：创建一个包含应用程序、依赖、配置和脚本的完整分发包。

**📁 项目结构**：
```
src/
├── main/java/          ← Java源代码
├── main/resources/     ← 资源文件
├── assembly/           ← assembly描述符
│   └── distribution.xml
└── scripts/            ← 启动脚本
    ├── startup.sh
    └── shutdown.sh
```

### 4.2 编写完整的描述符


**src/assembly/distribution.xml**：
```xml
<assembly>
    <id>distribution</id>
    <formats>
        <format>tar.gz</format>
        <format>zip</format>
    </formats>
    
    <includeBaseDirectory>true</includeBaseDirectory>
    
    <!-- 主程序JAR包 -->
    <fileSets>
        <fileSet>
            <directory>target</directory>
            <outputDirectory>lib</outputDirectory>
            <includes>
                <include>*.jar</include>
            </includes>
            <excludes>
                <exclude>*-sources.jar</exclude>
                <exclude>*-tests.jar</exclude>
            </excludes>
        </fileSet>
        
        <!-- 配置文件 -->
        <fileSet>
            <directory>src/main/resources</directory>
            <outputDirectory>config</outputDirectory>
            <includes>
                <include>*.yml</include>
                <include>*.xml</include>
                <include>*.properties</include>
            </includes>
        </fileSet>
        
        <!-- 启动脚本 -->
        <fileSet>
            <directory>src/scripts</directory>
            <outputDirectory>bin</outputDirectory>
            <fileMode>0755</fileMode>
            <lineEnding>unix</lineEnding>
        </fileSet>
        
        <!-- 文档 -->
        <fileSet>
            <directory>.</directory>
            <outputDirectory>docs</outputDirectory>
            <includes>
                <include>README*</include>
                <include>*.md</include>
            </includes>
        </fileSet>
    </fileSets>
    
    <!-- 依赖库 -->
    <dependencySets>
        <dependencySet>
            <outputDirectory>lib/dependencies</outputDirectory>
            <useProjectArtifact>false</useProjectArtifact>
            <unpack>false</unpack>
            <scope>runtime</scope>
        </dependencySet>
    </dependencySets>
</assembly>
```

### 4.3 创建启动脚本


**src/scripts/startup.sh**：
```bash
#!/bin/bash

# 获取脚本所在目录
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
APP_HOME="$( dirname "$SCRIPT_DIR" )"

# 设置类路径
CLASSPATH="$APP_HOME/lib/*:$APP_HOME/lib/dependencies/*:$APP_HOME/config"

# 启动应用
java -cp "$CLASSPATH" com.example.MainApplication "$@"
```

**🔍 脚本说明**：
- 自动检测应用路径
- 设置完整的类路径
- 支持传递命令行参数

---

## 5. 📂 文件集合与目录映射


### 5.1 fileSet详细配置


fileSet是描述符中最重要的部分，控制哪些文件被包含以及如何组织。

**🔧 完整配置选项**：
```xml
<fileSet>
    <!-- 源目录：从哪里取文件 -->
    <directory>src/main/resources</directory>
    
    <!-- 目标目录：放到包的哪个位置 -->
    <outputDirectory>config</outputDirectory>
    
    <!-- 包含哪些文件 -->
    <includes>
        <include>**/*.properties</include>
        <include>**/*.yml</include>
        <include>application-*.xml</include>
    </includes>
    
    <!-- 排除哪些文件 -->
    <excludes>
        <exclude>**/*.tmp</exclude>
        <exclude>**/test-*</exclude>
    </excludes>
    
    <!-- 是否过滤文件内容（替换变量） -->
    <filtered>true</filtered>
    
    <!-- 文件权限（Unix/Linux） -->
    <fileMode>0644</fileMode>
    
    <!-- 目录权限 -->
    <directoryMode>0755</directoryMode>
    
    <!-- 行结束符转换 -->
    <lineEnding>unix</lineEnding>
</fileSet>
```

### 5.2 路径匹配规则


**🎯 通配符规则**：

| 模式 | 含义 | 示例 |
|------|------|------|
| `*` | 匹配单层目录下的文件 | `*.jar` → myapp.jar |
| `**` | 匹配多层目录 | `**/*.properties` → 所有.properties文件 |
| `?` | 匹配单个字符 | `log?.xml` → log1.xml, logA.xml |
| `[abc]` | 匹配括号内任一字符 | `log[123].xml` → log1.xml |

**📋 实际示例**：
```xml
<!-- 包含所有配置文件，但排除测试配置 -->
<includes>
    <include>**/*.properties</include>
    <include>**/*.yml</include>
    <include>**/*.xml</include>
</includes>
<excludes>
    <exclude>**/test-*</exclude>
    <exclude>**/*-test.*</exclude>
</excludes>
```

### 5.3 目录映射技巧


**🗂️ 扁平化目录结构**：
```xml
<!-- 将不同源目录的文件放到同一目标目录 -->
<fileSet>
    <directory>src/main/resources/config</directory>
    <outputDirectory>config</outputDirectory>
</fileSet>
<fileSet>
    <directory>src/main/resources/templates</directory>
    <outputDirectory>config</outputDirectory>
</fileSet>
```

**📁 保持目录结构**：
```xml
<!-- 保持源目录的完整结构 -->
<fileSet>
    <directory>src/main/webapp</directory>
    <outputDirectory>webapp</outputDirectory>
    <!-- 不指定includes/excludes会复制整个目录 -->
</fileSet>
```

---

## 6. 🔐 权限设置与输出控制


### 6.1 文件权限详解


在Linux/Unix系统中，文件权限非常重要，特别是脚本文件。

**🔢 权限数字含义**：
```
权限表示：0755
第1位(0): 特殊权限，通常为0
第2位(7): 所有者权限 (读4+写2+执行1=7)
第3位(5): 群组权限 (读4+执行1=5)  
第4位(5): 其他用户权限 (读4+执行1=5)

常用权限设置：
0755: 脚本文件（所有者可读写执行，其他可读执行）
0644: 配置文件（所有者可读写，其他只读）
0600: 敏感文件（只有所有者可读写）
```

**📋 实际配置示例**：
```xml
<!-- 可执行脚本 -->
<fileSet>
    <directory>src/scripts</directory>
    <outputDirectory>bin</outputDirectory>
    <fileMode>0755</fileMode>
    <includes>
        <include>*.sh</include>
    </includes>
</fileSet>

<!-- 配置文件 -->
<fileSet>
    <directory>src/main/resources</directory>
    <outputDirectory>config</outputDirectory>
    <fileMode>0644</fileMode>
    <includes>
        <include>*.properties</include>
    </includes>
</fileSet>

<!-- 敏感配置（如密码文件） -->
<fileSet>
    <directory>src/main/resources/secure</directory>
    <outputDirectory>config/secure</outputDirectory>
    <fileMode>0600</fileMode>
    <directoryMode>0700</directoryMode>
</fileSet>
```

### 6.2 输出文件名控制


**🏷️ 文件名生成规则**：
```
默认格式：{artifactId}-{version}-{assemblyId}.{format}
例如：myapp-1.0.0-distribution.tar.gz

控制选项：
appendAssemblyId=false → myapp-1.0.0.tar.gz
finalName设置 → 完全自定义名称
```

**⚙️ POM配置示例**：
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-assembly-plugin</artifactId>
    <configuration>
        <!-- 自定义输出文件名 -->
        <finalName>myapp-release</finalName>
        <!-- 不添加assembly ID -->
        <appendAssemblyId>false</appendAssemblyId>
        <!-- 结果：myapp-release.tar.gz -->
    </configuration>
</plugin>
```

### 6.3 多环境配置支持


**🌍 不同环境的打包策略**：
```xml
<!-- 开发环境描述符 -->
<assembly>
    <id>dev</id>
    <fileSets>
        <fileSet>
            <directory>src/main/resources/dev</directory>
            <outputDirectory>config</outputDirectory>
        </fileSet>
    </fileSets>
</assembly>

<!-- 生产环境描述符 -->
<assembly>
    <id>prod</id>
    <fileSets>
        <fileSet>
            <directory>src/main/resources/prod</directory>
            <outputDirectory>config</outputDirectory>
        </fileSet>
    </fileSets>
</assembly>
```

**💻 打包命令**：
```bash
# 打包开发环境
mvn clean package -Denv=dev

# 打包生产环境  
mvn clean package -Denv=prod
```

---

## 7. 🚀 实际应用场景


### 7.1 微服务应用打包


**场景**：Spring Boot应用需要包含配置、依赖和启动脚本。

**📦 目标结构**：
```
microservice-app/
├── app/
│   └── microservice.jar          ← 应用主程序
├── lib/
│   └── [所有依赖jar文件]          ← 依赖库
├── config/
│   ├── application.yml           ← 应用配置
│   ├── logback-spring.xml        ← 日志配置
│   └── bootstrap.yml             ← 启动配置
├── bin/
│   ├── start.sh                  ← 启动脚本
│   ├── stop.sh                   ← 停止脚本
│   └── status.sh                 ← 状态检查
├── logs/                         ← 日志目录
└── data/                         ← 数据目录
```

**🔧 描述符配置**：
```xml
<assembly>
    <id>microservice</id>
    <formats>
        <format>tar.gz</format>
    </formats>
    
    <fileSets>
        <!-- 主程序 -->
        <fileSet>
            <directory>target</directory>
            <outputDirectory>app</outputDirectory>
            <includes>
                <include>microservice-*.jar</include>
            </includes>
            <excludes>
                <exclude>*-sources.jar</exclude>
            </excludes>
        </fileSet>
        
        <!-- 脚本文件 -->
        <fileSet>
            <directory>src/assembly/scripts</directory>
            <outputDirectory>bin</outputDirectory>
            <fileMode>0755</fileMode>
            <lineEnding>unix</lineEnding>
        </fileSet>
        
        <!-- 创建空目录 -->
        <fileSet>
            <directory>src/assembly/empty-dirs/logs</directory>
            <outputDirectory>logs</outputDirectory>
            <excludes>
                <exclude>*</exclude>
            </excludes>
        </fileSet>
    </fileSets>
    
    <!-- 依赖库 -->
    <dependencySets>
        <dependencySet>
            <outputDirectory>lib</outputDirectory>
            <useProjectArtifact>false</useProjectArtifact>
        </dependencySet>
    </dependencySets>
</assembly>
```

### 7.2 前端资源打包


**场景**：Vue/React项目需要将构建产物、服务器配置、文档一起打包。

**🎨 描述符示例**：
```xml
<assembly>
    <id>webapp</id>
    <formats>
        <format>tar.gz</format>
    </formats>
    
    <fileSets>
        <!-- 构建后的前端文件 -->
        <fileSet>
            <directory>dist</directory>
            <outputDirectory>static</outputDirectory>
        </fileSet>
        
        <!-- Nginx配置 -->
        <fileSet>
            <directory>nginx</directory>
            <outputDirectory>conf</outputDirectory>
            <includes>
                <include>*.conf</include>
            </includes>
        </fileSet>
        
        <!-- 部署文档 -->
        <fileSet>
            <directory>docs</directory>
            <outputDirectory>docs</outputDirectory>
            <includes>
                <include>deployment.md</include>
                <include>configuration.md</include>
            </includes>
        </fileSet>
    </fileSets>
</assembly>
```

### 7.3 数据库迁移包


**场景**：包含SQL脚本、迁移工具、配置文件的数据库升级包。

**💾 实现思路**：
```xml
<assembly>
    <id>db-migration</id>
    <formats>
        <format>zip</format>
    </formats>
    
    <fileSets>
        <!-- SQL迁移脚本 -->
        <fileSet>
            <directory>src/main/resources/db/migration</directory>
            <outputDirectory>sql</outputDirectory>
            <includes>
                <include>**/*.sql</include>
            </includes>
        </fileSet>
        
        <!-- 迁移工具 -->
        <fileSet>
            <directory>tools</directory>
            <outputDirectory>tools</outputDirectory>
            <fileMode>0755</fileMode>
        </fileSet>
    </fileSets>
    
    <!-- 依赖的数据库驱动 -->
    <dependencySets>
        <dependencySet>
            <outputDirectory>lib</outputDirectory>
            <includes>
                <include>mysql:mysql-connector-java</include>
                <include>org.postgresql:postgresql</include>
            </includes>
        </dependencySet>
    </dependencySets>
</assembly>
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🎯 自定义打包 = Maven Assembly插件 + 描述符文件
🎯 描述符文件 = XML格式，定义"打包规则"  
🎯 fileSet = 控制哪些文件打包到哪里
🎯 dependencySet = 控制依赖库如何处理
🎯 权限设置 = Linux/Unix环境下的文件执行权限
```

### 8.2 关键配置要点


**🔸 插件配置记忆要点**：
```
pom.xml配置三要素：
1. 插件版本 (maven-assembly-plugin)
2. 描述符位置 (descriptors)  
3. 执行绑定 (executions)
```

**🔸 描述符文件记忆要点**：
```
描述符五大块：
1. 基本信息 (id, formats)
2. 文件集合 (fileSets) 
3. 依赖处理 (dependencySets)
4. 权限控制 (fileMode, directoryMode)
5. 输出控制 (includeBaseDirectory)
```

### 8.3 实际应用价值


**💼 业务价值**：
- **🚀 部署效率提升**：一键打包，标准化部署
- **🔧 运维成本降低**：统一的目录结构和启动方式
- **📦 交付质量保证**：避免手动打包的遗漏和错误
- **🌍 环境适配能力**：支持多环境配置和跨平台部署

**🎓 学习路径建议**：
```
新手入门路线：
1. 理解基本概念 → 为什么需要自定义打包
2. 学会插件配置 → pom.xml中的基础配置  
3. 掌握描述符编写 → fileSet和dependencySet
4. 实践权限设置 → Linux环境的文件权限
5. 多场景应用 → 微服务、前端、数据库等场景
```

**🔑 核心记忆口诀**：
- Assembly插件来帮忙，描述符文件定规章
- fileSet管文件，dependencySet管依赖项
- 权限设置很重要，0755脚本能执行  
- 打包一次到处跑，部署运维都轻松

**⚠️ 常见注意事项**：
- 🔸 脚本文件记得设置执行权限(0755)
- 🔸 敏感配置文件权限要限制(0600)
- 🔸 路径分隔符在不同系统要注意
- 🔸 依赖传递要检查，避免版本冲突