---
title: 2、类型系统定义
---
## 📚 目录

1. [类型系统概述](#1-类型系统概述)
2. [标量类型详解](#2-标量类型详解)
3. [对象类型深入理解](#3-对象类型深入理解)
4. [输入类型与参数处理](#4-输入类型与参数处理)
5. [枚举类型应用](#5-枚举类型应用)
6. [列表与非空类型](#6-列表与非空类型)
7. [接口与联合类型](#7-接口与联合类型)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 类型系统概述


### 1.1 什么是GraphQL类型系统


**通俗理解**：类型系统就像是**数据的身份证**，告诉GraphQL每个数据长什么样、能做什么操作。

```
现实对比：
就像填表格时的要求：
- 姓名：必须是文字
- 年龄：必须是数字  
- 性别：只能选男/女
- 爱好：可以选多个

GraphQL类型系统做的就是这件事！
```

**🔸 核心作用**
- **数据约束**：规定什么样的数据是合法的
- **错误预防**：在查询前就能发现类型错误
- **自动验证**：GraphQL会自动检查数据是否符合类型要求
- **开发提示**：IDE能提供智能提示和自动补全

### 1.2 类型系统的组成


```
GraphQL类型家族图：

基础类型
├── 标量类型 (Scalar)     → 最基本的数据：字符串、数字等
├── 对象类型 (Object)     → 复杂数据结构：用户信息、商品信息等
├── 输入类型 (Input)      → 专门用来接收参数的类型
├── 枚举类型 (Enum)       → 固定选项：性别、状态等
└── 修饰类型
    ├── 列表类型 [Type]   → 数组形式的数据
    ├── 非空类型 Type!    → 必须有值，不能为null
    └── 高级类型
        ├── 接口 Interface → 定义共同特征
        └── 联合 Union     → 多种可能的类型
```

---

## 2. 📝 标量类型详解


### 2.1 内置标量类型


**🔸 理解标量类型**
标量类型就是**不能再拆分的最小数据单位**，就像原子一样。

```graphql
# GraphQL内置的5种标量类型
type User {
  name: String        # 文本：张三、Hello World
  age: Int           # 整数：18、100、-5
  height: Float      # 小数：1.75、3.14
  isActive: Boolean  # 布尔：true或false
  userId: ID         # 标识符：user_123、UUID等
}
```

| 类型 | **用途** | **示例值** | **说明** |
|------|---------|-----------|----------|
| `String` | 文本数据 | `"张三"`, `"Hello"` | 用UTF-8编码，支持中文 |
| `Int` | 整数 | `18`, `-5`, `1000` | 32位有符号整数 |
| `Float` | 小数 | `3.14`, `1.75` | 双精度浮点数 |
| `Boolean` | 真假值 | `true`, `false` | 只有两个可能值 |
| `ID` | 唯一标识 | `"user_123"`, `"UUID"` | 字符串格式，但语义上是ID |

### 2.2 自定义标量类型


**🎯 为什么需要自定义标量**
有时候内置类型不够用，比如日期、邮箱、电话号码等有特殊格式要求的数据。

```graphql
# 定义自定义标量类型
scalar DateTime    # 日期时间：2024-01-15T10:30:00Z
scalar Email       # 邮箱：user@example.com
scalar Phone       # 电话：+86-13812345678
scalar JSON        # JSON数据

type User {
  name: String
  email: Email         # 不是普通字符串，必须是邮箱格式
  phone: Phone         # 必须是电话号码格式
  createdAt: DateTime  # 日期时间格式
  metadata: JSON       # 可以存储任意JSON数据
}
```

**💡 自定义标量的好处**
- **格式验证**：自动检查邮箱、电话格式是否正确
- **类型安全**：避免把电话号码当普通字符串处理
- **语义清晰**：一眼就知道这个字段是什么类型的数据

---

## 3. 🏗️ 对象类型深入理解


### 3.1 什么是对象类型


**通俗理解**：对象类型就像是**数据的模板**，定义一个复杂事物有哪些属性。

```
现实对比：
一个人的信息包括：
├── 姓名 (文字)
├── 年龄 (数字)  
├── 地址 (复杂信息)
│   ├── 省份
│   ├── 城市
│   └── 详细地址
└── 朋友列表 (其他人的信息)

对象类型做的就是这种**结构化描述**！
```

### 3.2 对象类型定义


```graphql
# 定义一个用户对象类型
type User {
  id: ID!              # 用户唯一标识，不能为空
  name: String!        # 用户姓名，必须有值
  email: String        # 邮箱，可选字段
  age: Int             # 年龄，可选
  isActive: Boolean!   # 是否激活，必须指定
  
  # 复杂字段：关联到其他对象
  profile: UserProfile # 用户详细资料
  posts: [Post]        # 用户发布的文章列表
  friends: [User]      # 朋友列表（循环引用）
}

# 用户详细资料
type UserProfile {
  bio: String          # 个人简介
  avatar: String       # 头像URL
  location: String     # 所在地
  website: String      # 个人网站
}

# 文章类型
type Post {
  id: ID!
  title: String!
  content: String!
  author: User!        # 文章作者，反向关联到User
  createdAt: DateTime
}
```

### 3.3 对象类型的特点


**🔸 字段组合**
```
对象类型 = 多个字段的组合包装

User对象包含：
┌─ 基础信息：id, name, email
├─ 数值信息：age  
├─ 状态信息：isActive
└─ 关联信息：profile, posts, friends

每个字段都有自己的类型！
```

**🔸 嵌套结构**
对象类型可以**无限嵌套**，构成复杂的数据结构：
```
User → UserProfile → Address → Country → ...
```

**🔸 循环引用**
对象类型可以引用自己或互相引用：
```graphql
type User {
  friends: [User]      # 用户的朋友还是用户
}

type Post {
  author: User         # 文章属于用户
}

type User {
  posts: [Post]        # 用户有多篇文章
}
```

---

## 4. 📥 输入类型与参数处理


### 4.1 输入类型的概念


**🔸 为什么需要输入类型**
```
问题场景：
查询时我们用 User 类型接收数据
但创建用户时，我们需要发送数据给服务器

发送的数据和接收的数据结构可能不完全一样：
- 创建用户时不需要ID（服务器自动生成）
- 创建用户时密码是必需的
- 创建用户时不需要关联的复杂对象
```

**输入类型就是专门用来接收参数的数据结构**，类似于表单。

### 4.2 输入类型定义


```graphql
# 输出类型：用于返回数据给客户端
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post]        # 复杂关联数据
  createdAt: DateTime
}

# 输入类型：用于接收客户端参数
input CreateUserInput {
  name: String!        # 必须提供姓名
  email: String!       # 必须提供邮箱
  password: String!    # 必须提供密码（输出时不包含密码）
  bio: String          # 可选的个人简介
}

input UpdateUserInput {
  name: String         # 更新时都是可选的
  email: String
  bio: String
  # 注意：没有密码字段，密码单独更新
}

# 在查询中使用输入类型
type Mutation {
  createUser(input: CreateUserInput!): User
  updateUser(id: ID!, input: UpdateUserInput!): User
}
```

### 4.3 复合参数结构与嵌套输入


**🎯 处理复杂参数**
有时候参数本身就很复杂，需要嵌套结构：

```graphql
# 地址输入类型
input AddressInput {
  street: String!
  city: String!
  province: String!
  zipCode: String
  country: String = "中国"  # 默认值
}

# 复合的用户创建输入
input CreateUserWithAddressInput {
  # 基础信息
  name: String!
  email: String!
  password: String!
  
  # 嵌套的地址信息
  address: AddressInput!
  
  # 列表类型的输入
  hobbies: [String!]     # 爱好列表，每个元素不能为空
  phoneNumbers: [String] # 电话号码列表，可以为空
}

# 使用示例
type Mutation {
  createUserWithAddress(input: CreateUserWithAddressInput!): User
}
```

**📝 客户端调用示例**
```javascript
// 客户端发送的数据结构
const userData = {
  name: "张三",
  email: "zhangsan@example.com", 
  password: "securePassword123",
  address: {
    street: "中关村大街1号",
    city: "北京市",
    province: "北京市",
    zipCode: "100000"
    // country使用默认值"中国"
  },
  hobbies: ["编程", "阅读", "游戏"],
  phoneNumbers: ["13812345678", "01012345678"]
}
```

### 4.4 Input与Object Type的区别


> 💡 **核心区别**：Object Type用于**输出**，Input Type用于**输入**

| 特性 | **Object Type** | **Input Type** |
|------|----------------|----------------|
| **用途** | 返回数据给客户端 | 接收客户端参数 |
| **字段类型** | 可以是任意类型 | 只能是标量、枚举、Input类型 |
| **复杂关联** | ✅ 可以关联其他Object | ❌ 不能关联Object类型 |
| **字段解析** | ✅ 可以有resolver函数 | ❌ 纯数据结构 |
| **循环引用** | ✅ 支持 | ❌ 不支持 |

**❌ 错误示例**
```graphql
# 错误：Input类型不能包含Object类型字段
input CreatePostInput {
  title: String!
  author: User        # ❌ 错误！不能直接引用Object类型
}
```

**✅ 正确示例**
```graphql
# 正确：使用ID或基础类型
input CreatePostInput {
  title: String!
  authorId: ID!       # ✅ 正确！使用ID引用用户
}

# 或者创建专门的输入类型
input AuthorInput {
  id: ID!
  name: String!
}

input CreatePostInput {
  title: String!
  author: AuthorInput  # ✅ 正确！使用Input类型
}
```

---

## 5. 🏷️ 枚举类型应用


### 5.1 枚举类型的概念


**通俗理解**：枚举类型就像是**单选题的选项**，只能从预定义的几个值中选择一个。

```
现实对比：
性别选择：只能选 [男, 女, 其他]
订单状态：只能选 [待付款, 已付款, 已发货, 已完成, 已取消]
文章类型：只能选 [技术, 生活, 随笔, 转载]

枚举类型保证了数据的**一致性**和**可控性**！
```

### 5.2 枚举类型定义


```graphql
# 用户状态枚举
enum UserStatus {
  ACTIVE         # 激活状态
  INACTIVE       # 未激活
  SUSPENDED      # 暂停使用
  DELETED        # 已删除
}

# 文章分类枚举
enum PostCategory {
  TECH           # 技术文章
  LIFESTYLE      # 生活随笔  
  TUTORIAL       # 教程指南
  NEWS           # 新闻资讯
}

# 排序方向枚举
enum SortDirection {
  ASC            # 升序
  DESC           # 降序
}

# 在类型中使用枚举
type User {
  id: ID!
  name: String!
  status: UserStatus!    # 只能是枚举中定义的值
}

type Post {
  id: ID!
  title: String!
  category: PostCategory! # 必须指定分类
}
```

### 5.3 枚举类型的优势


**🔸 数据一致性**
```graphql
# 使用枚举前：字符串值容易出错
type Post {
  status: String  # 可能出现：pending、Pending、PENDING、待审核...
}

# 使用枚举后：值严格限制
enum PostStatus {
  DRAFT     # 草稿
  PENDING   # 待审核
  PUBLISHED # 已发布
  ARCHIVED  # 已归档
}

type Post {
  status: PostStatus!  # 只能是上面4个值中的一个
}
```

**🔸 查询和参数使用**
```graphql
# 查询时使用枚举
query GetUsers {
  users(status: ACTIVE) {  # 枚举值不需要引号
    id
    name
    status
  }
}

# 作为输入参数
input CreatePostInput {
  title: String!
  category: PostCategory!      # 强制指定分类
  sortDirection: SortDirection # 可选的排序方向
}

type Query {
  posts(
    category: PostCategory     # 按分类筛选
    sortBy: SortDirection      # 排序方向
  ): [Post]
}
```

### 5.4 枚举类型最佳实践


**🔸 命名规范**
```graphql
# ✅ 推荐：使用大写字母和下划线
enum OrderStatus {
  PENDING_PAYMENT    # 待付款
  PAYMENT_CONFIRMED  # 已确认付款  
  SHIPPED           # 已发货
  DELIVERED         # 已送达
  CANCELLED         # 已取消
}

# ❌ 不推荐：使用小写或混合大小写
enum orderStatus {
  pending_payment   # 不够清晰
  paymentConfirmed  # 风格不一致
}
```

---

## 6. 📋 列表与非空类型


### 6.1 非空类型(NonNull)的理解


**通俗理解**：非空类型就是**必填项**，告诉GraphQL这个字段必须有值，不能是`null`。

```
现实对比：
表单填写：
├── 姓名: [必填] ← 对应 String!
├── 年龄: [可选] ← 对应 Int  
├── 邮箱: [必填] ← 对应 String!
└── 备注: [可选] ← 对应 String

感叹号(!)就是"必填"标记！
```

### 6.2 非空类型语法


```graphql
type User {
  # 基础非空类型
  id: ID!           # 必须有值，不能为null
  name: String!     # 必须有值
  email: String     # 可以为null
  age: Int          # 可以为null
  
  # 复杂类型的非空
  profile: UserProfile!  # profile对象不能为null
  posts: [Post]!         # posts列表不能为null（但可以是空列表[]）
}
```

**🔸 非空的含义**
```
String!  = 必须是字符串，不能是null，但可以是空字符串""
Int!     = 必须是整数，不能是null，但可以是0
[Post]!  = 必须是数组，不能是null，但可以是空数组[]
```

### 6.3 列表类型(Lists)详解


**通俗理解**：列表类型就是**数组**，表示一个字段可以包含多个值。

```graphql
type User {
  # 基础列表类型
  hobbies: [String]         # 字符串数组，整个数组可以为null
  phoneNumbers: [String!]   # 数组中的每个元素不能为null
  friends: [User]!          # 数组本身不能为null，但元素可以为null
  tags: [String!]!          # 数组不能为null，元素也不能为null
}
```

### 6.4 列表类型组合技巧


**🔸 四种组合方式**

| 写法 | **含义** | **可能的值** | **应用场景** |
|------|---------|-------------|-------------|
| `[String]` | 可选数组，可选元素 | `null`, `[]`, `["a", null, "c"]` | 不重要的标签列表 |
| `[String]!` | 必需数组，可选元素 | `[]`, `["a", null, "c"]` | 评论列表（可以没评论） |
| `[String!]` | 可选数组，必需元素 | `null`, `[]`, `["a", "b", "c"]` | 分类标签（要么没有，要么都有效） |
| `[String!]!` | 必需数组，必需元素 | `[]`, `["a", "b", "c"]` | 用户权限列表（必须明确） |

**🔸 实际应用示例**
```graphql
type Article {
  id: ID!
  title: String!
  
  # 文章标签：可以没有标签，但有标签时不能为空
  tags: [String!]          
  # 可能值：null, [], ["技术", "前端"]
  
  # 评论列表：必须有评论数组，但可以为空数组
  comments: [Comment]!     
  # 可能值：[], [comment1, comment2]
  
  # 作者列表：多作者文章，每个作者都必须有效
  authors: [User!]!        
  # 可能值：[user1], [user1, user2]，不能为null或包含null元素
}
```

### 6.5 类型组合使用技巧


**🔸 嵌套列表**
```graphql
type Category {
  name: String!
  # 每个分类下有多个子分类，每个子分类有多个文章
  subcategories: [[Post!]!]!
  #               └─┘ └┘ └┘
  #                │  │  │
  #                │  │  └─ 子分类数组不能为null
  #                │  └─ 每篇文章不能为null  
  #                └─ 文章列表不能为null
}
```

**🔸 条件非空**
```graphql
type User {
  id: ID!
  email: String!
  
  # 根据用户类型决定是否必需
  companyName: String      # 个人用户可以为null
  employeeId: String       # 企业用户时不能为null（业务逻辑层处理）
}

# 更好的做法：使用Union类型
union User = PersonalUser | BusinessUser

type PersonalUser {
  id: ID!
  email: String!
  nickname: String
}

type BusinessUser {
  id: ID!
  email: String!
  companyName: String!     # 企业用户必须有公司名
  employeeId: String!      # 企业用户必须有员工ID
}
```

---

## 7. 🔗 接口与联合类型


### 7.1 接口(Interface)类型


**通俗理解**：接口类型就像是**合同**，规定了实现者必须具备哪些共同特征。

```
现实对比：
所有的"交通工具"都有共同特征：
├── 都能移动
├── 都有载客能力
└── 都有品牌

但具体实现不同：
├── 汽车：有4个轮子，使用汽油
├── 飞机：有机翼，使用航空燃油
└── 船只：有船体，使用柴油

接口定义共同特征，具体类型实现细节！
```

### 7.2 接口定义与实现


```graphql
# 定义接口：所有媒体内容的共同特征
interface MediaContent {
  id: ID!
  title: String!
  createdAt: DateTime!
  author: User!
  viewCount: Int!
}

# 实现接口：文章类型
type Article implements MediaContent {
  # 必须实现接口中的所有字段
  id: ID!
  title: String!
  createdAt: DateTime!
  author: User!
  viewCount: Int!
  
  # 可以添加自己特有的字段
  content: String!
  category: ArticleCategory!
  tags: [String!]
}

# 实现接口：视频类型
type Video implements MediaContent {
  # 实现接口字段
  id: ID!
  title: String!
  createdAt: DateTime!
  author: User!
  viewCount: Int!
  
  # 视频特有字段
  duration: Int!           # 时长（秒）
  videoUrl: String!        # 视频地址
  thumbnail: String        # 缩略图
  resolution: VideoQuality # 分辨率
}

enum VideoQuality {
  HD_720P
  HD_1080P
  HD_4K
}
```

### 7.3 接口的查询使用


```graphql
# 查询所有媒体内容（文章+视频）
query GetAllMedia {
  allMediaContent {
    # 接口字段：所有类型都有
    id
    title
    createdAt
    author {
      name
    }
    viewCount
    
    # 类型特定字段：需要用片段
    ... on Article {
      content
      tags
      category
    }
    
    ... on Video {
      duration
      videoUrl
      thumbnail
      resolution
    }
  }
}
```

### 7.4 联合(Union)类型


**通俗理解**：联合类型就像是**多选一**，一个字段可能是几种不同类型中的任意一种。

```
现实对比：
搜索结果可能包含：
├── 用户信息
├── 文章内容
├── 商品信息
└── 视频内容

每种结果的结构完全不同，但都是"搜索结果"！
联合类型就是处理这种"可能是A，也可能是B"的情况。
```

### 7.5 联合类型定义


```graphql
# 定义联合类型：搜索结果可能的类型
union SearchResult = User | Article | Video | Product

# 各个具体类型
type User {
  id: ID!
  name: String!
  email: String!
  avatar: String
}

type Article {
  id: ID!
  title: String!
  content: String!
  author: User!
}

type Video {
  id: ID!
  title: String!
  duration: Int!
  videoUrl: String!
}

type Product {
  id: ID!
  name: String!
  price: Float!
  category: String!
}

# 使用联合类型
type Query {
  search(keyword: String!): [SearchResult!]!
}
```

### 7.6 联合类型的查询


```graphql
# 查询搜索结果
query SearchContent($keyword: String!) {
  search(keyword: $keyword) {
    # 必须使用片段来获取具体类型的字段
    ... on User {
      __typename    # GraphQL内置字段，返回实际类型名
      id
      name
      avatar
    }
    
    ... on Article {
      __typename
      id
      title
      author {
        name
      }
    }
    
    ... on Video {
      __typename
      id
      title
      duration
      thumbnail
    }
    
    ... on Product {
      __typename
      id
      name
      price
    }
  }
}
```

**📋 返回结果示例**
```json
{
  "data": {
    "search": [
      {
        "__typename": "User",
        "id": "user_1",
        "name": "张三",
        "avatar": "avatar.jpg"
      },
      {
        "__typename": "Article", 
        "id": "article_1",
        "title": "GraphQL入门教程",
        "author": {
          "name": "李四"
        }
      },
      {
        "__typename": "Video",
        "id": "video_1", 
        "title": "GraphQL实战视频",
        "duration": 1800,
        "thumbnail": "thumb.jpg"
      }
    ]
  }
}
```

### 7.7 Interface vs Union 对比


> 💡 **核心区别**：Interface强调**共同特征**，Union强调**类型选择**

| 特性 | **Interface** | **Union** |
|------|--------------|-----------|
| **关系** | 有共同字段的"is-a"关系 | 完全不同的"或者"关系 |
| **共同字段** | ✅ 必须有共同字段 | ❌ 可以完全没有共同字段 |
| **查询方式** | 可以直接查询共同字段 | 必须用片段查询所有字段 |
| **使用场景** | 相似类型的抽象 | 完全不同类型的组合 |

**🔸 选择建议**
```graphql
# 适合用Interface：有共同特征
interface Animal {
  name: String!
  age: Int!
}

type Dog implements Animal { ... }
type Cat implements Animal { ... }

# 适合用Union：完全不同的类型
union NotificationContent = TextMessage | ImageMessage | SystemAlert
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 类型系统本质：为数据定义"身份证"，确保数据格式正确
🔸 标量类型：最基础的数据单位，5种内置 + 自定义扩展
🔸 对象类型：复杂数据结构的模板，可嵌套、可循环引用
🔸 输入类型：专门接收参数，与输出类型分离设计
🔸 枚举类型：固定选项的单选题，保证数据一致性
🔸 列表与非空：控制数据的可选性和数组结构
🔸 接口与联合：处理多态和类型选择的高级特性
```

### 8.2 关键理解要点


**🔹 输入输出分离的设计哲学**
```
为什么要分离？
输出类型：展示给用户，包含完整信息和关联数据
输入类型：接收参数，只包含需要的字段，避免复杂嵌套

这种设计让API更清晰、更安全！
```

**🔹 非空类型的实际意义**
```
Type!  = 承诺这个字段一定有值
[Type] = 数组可能为null，元素可能为null  
[Type]! = 数组一定存在，但可能是空数组
[Type!]! = 数组一定存在，元素一定有值

合理使用非空约束，让API更可靠！
```

**🔹 何时使用Interface vs Union**
```
Interface：当类型有明显共同特征时
- 所有媒体内容：都有标题、作者、创建时间
- 所有用户：都有ID、姓名、邮箱

Union：当类型完全不同但需要统一处理时  
- 搜索结果：可能是用户、文章、商品...
- 通知内容：可能是文字、图片、系统消息...
```

### 8.3 实际应用价值


**🎯 业务场景应用**
- **电商系统**：商品类型(接口) + 具体商品(实现) + 订单状态(枚举)
- **内容管理**：媒体内容(联合) + 文章分类(枚举) + 用户输入(Input类型)
- **社交平台**：用户关系(列表) + 内容类型(接口) + 隐私设置(枚举)

**🔧 开发实践**
- **类型安全**：编译时就能发现数据结构错误
- **自动验证**：GraphQL自动检查数据格式
- **智能提示**：IDE能根据类型定义提供代码补全
- **文档生成**：类型定义就是活的API文档

**核心记忆**：
- 类型系统是GraphQL的核心，定义数据的"形状"
- 输入输出分离，让API设计更清晰合理
- 非空和列表组合使用，精确控制数据约束
- 接口抽象共性，联合处理选择，各有所长