---
title: 2、客户端开发
---
## 📚 目录

1. [HTTP请求方式](#1-HTTP请求方式)
2. [补充:请求体结构与请求头设置](#2-补充请求体结构与请求头设置)
3. [补充:使用curl、Postman、fetch测试](#3-补充使用curl、Postman、fetch测试)
4. [Apollo Client使用](#4-Apollo-Client使用)
5. [补充:客户端库选择标准](#5-补充客户端库选择标准)
6. [useQuery与useMutation](#6-useQuery与useMutation)
7. [变量传递与缓存策略](#7-变量传递与缓存策略)
8. [补充:Apollo Devtools使用](#8-补充Apollo-Devtools使用)
9. [错误处理与调试](#9-错误处理与调试)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌐 HTTP请求方式


### 1.1 GraphQL请求的本质


> 💡 **核心理解**：GraphQL并不是什么神秘的协议，它本质上就是通过HTTP发送请求，只是请求的内容和格式有特定的规则。

**GraphQL请求就像点菜**：
```
传统REST API点菜：
- GET /users/1        (只能要整个用户信息)
- GET /users/1/posts  (还要单独要文章)
- GET /posts/1/comments (再单独要评论)

GraphQL点菜：
- 一次请求说清楚："我要用户1的姓名、邮箱，还要他的前3篇文章标题"
- 服务器按需返回，一次搞定
```

### 1.2 GraphQL的HTTP特点


**🔸 统一使用POST方法**
```
为什么都用POST？
- GET有URL长度限制，复杂查询会超长
- POST可以把查询放在请求体里，无长度限制
- 即使是查询操作，也用POST发送
```

**🔸 固定的端点地址**
```
传统REST：
/api/users     (用户相关)
/api/posts     (文章相关)
/api/comments  (评论相关)

GraphQL：
/graphql       (所有操作都走这一个地址)
```

### 1.3 请求流程图示


```
客户端                    GraphQL服务器
   |                           |
   |--[POST /graphql]--------->|
   |   请求体包含查询语句        |
   |                           |
   |                           |--解析查询
   |                           |--执行查询  
   |                           |--组装数据
   |                           |
   |<--[JSON响应]---------------|
   |   返回所需的精确数据        |
```

---

## 2. 📋 补充:请求体结构与请求头设置


### 2.1 标准请求体结构


**🔸 请求体就是一个JSON对象，包含3个关键字段**：

```json
{
  "query": "查询语句(必须)",
  "variables": "变量对象(可选)",
  "operationName": "操作名称(可选)"
}
```

### 2.2 具体示例解释


**简单查询请求**：
```json
{
  "query": "query { users { id name email } }"
}
```
> 📝 **理解**：就像在说"请给我所有用户的id、姓名、邮箱"

**带变量的查询请求**：
```json
{
  "query": "query GetUser($id: ID!) { user(id: $id) { name email } }",
  "variables": {
    "id": "123"
  }
}
```
> 📝 **理解**：就像在说"请给我id为123的用户的姓名和邮箱，其中123是个变量"

### 2.3 必需的请求头


**🔧 标准请求头设置**：
```http
Content-Type: application/json
Accept: application/json
```

**带认证的请求头**：
```http
Content-Type: application/json
Accept: application/json
Authorization: Bearer your-jwt-token
```

> ⚠️ **注意**：Content-Type必须是`application/json`，因为GraphQL请求体是JSON格式

### 2.4 请求头作用说明


| 请求头 | 作用 | 是否必需 |
|--------|------|----------|
| `Content-Type: application/json` | 告诉服务器请求体是JSON格式 | ✅ **必需** |
| `Accept: application/json` | 告诉服务器希望返回JSON格式 | 🔸 **推荐** |
| `Authorization` | 身份认证信息 | 🔹 **按需** |

---

## 3. 🧪 补充:使用curl、Postman、fetch测试


### 3.1 curl命令测试


**🔸 最基础的GraphQL请求**：
```bash
curl -X POST http://localhost:4000/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{ users { id name } }"}'
```

**🔸 带变量的请求**：
```bash
curl -X POST http://localhost:4000/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query GetUser($id: ID!) { user(id: $id) { name email } }",
    "variables": {"id": "123"}
  }'
```

> 💡 **小技巧**：可以先把JSON放到文件里，然后用`curl -d @query.json`的方式发送

### 3.2 Postman测试步骤


**📝 Postman设置步骤**：

1. **请求方法**：选择`POST`
2. **URL地址**：输入`http://localhost:4000/graphql`
3. **请求头设置**：
   - Key: `Content-Type`, Value: `application/json`
4. **请求体设置**：
   - 选择`raw`
   - 选择`JSON`格式
   - 输入GraphQL查询

**示例请求体**：
```json
{
  "query": "query { users { id name email createdAt } }"
}
```

> 🎯 **Postman优势**：可视化界面，方便测试和调试，支持保存请求历史

### 3.3 JavaScript fetch测试


**🔸 基础fetch请求**：
```javascript
// 简单查询
fetch('http://localhost:4000/graphql', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    query: `
      query {
        users {
          id
          name
          email
        }
      }
    `
  })
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('错误:', error));
```

**🔸 带变量的fetch请求**：
```javascript
// 带变量的查询
const getUser = async (userId) => {
  try {
    const response = await fetch('http://localhost:4000/graphql', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        query: `
          query GetUser($id: ID!) {
            user(id: $id) {
              id
              name
              email
            }
          }
        `,
        variables: { id: userId }
      })
    });
    
    const result = await response.json();
    return result.data;
  } catch (error) {
    console.error('请求失败:', error);
  }
};

// 使用
getUser('123').then(user => console.log(user));
```

### 3.4 测试工具对比


| 工具 | 优势 | 适用场景 | 学习成本 |
|------|------|----------|----------|
| **curl** | 命令行，脚本化，跨平台 | 快速测试，CI/CD | ⭐⭐ |
| **Postman** | 可视化，功能丰富，团队协作 | 开发调试，API文档 | ⭐⭐⭐ |
| **fetch** | 编程灵活，集成方便 | 前端开发，自动化 | ⭐⭐⭐⭐ |

---

## 4. 🚀 Apollo Client使用


### 4.1 什么是Apollo Client


> 💡 **通俗理解**：Apollo Client就像是GraphQL的"翻译员"和"管家"，它帮你把复杂的GraphQL操作变成简单易用的JavaScript函数，还自动处理缓存、错误等琐事。

**Apollo Client的作用**：
```
普通方式：
你要自己写fetch → 自己处理错误 → 自己管理数据 → 自己更新界面

使用Apollo Client：
你只需要写查询语句 → Apollo自动发请求 → 自动处理错误 → 自动缓存数据 → 自动更新界面
```

### 4.2 安装和基础配置


**🔧 安装Apollo Client**：
```bash
npm install @apollo/client graphql
```

**🔧 基础配置**：
```javascript
// apolloClient.js
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';

// 创建Apollo客户端
const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql', // GraphQL服务器地址
  cache: new InMemoryCache() // 内存缓存
});

// 在React应用中使用
function App() {
  return (
    <ApolloProvider client={client}>
      {/* 你的组件 */}
    </ApolloProvider>
  );
}
```

> 📝 **理解**：`ApolloProvider`就像是给整个应用装了一个"GraphQL环境"，任何子组件都可以使用GraphQL功能

### 4.3 Apollo Client核心概念


**🔸 Client**: 客户端实例，负责发送请求
**🔸 Cache**: 缓存系统，自动存储查询结果
**🔸 Provider**: React组件，提供GraphQL功能给子组件

```
React应用结构：
    App
     |
ApolloProvider (提供GraphQL能力)
     |
  各种组件 (可以使用useQuery、useMutation等)
```

---

## 5. 📊 补充:客户端库选择标准


### 5.1 主流GraphQL客户端库对比


| 客户端库 | 特点 | 适用场景 | 学习曲线 |
|----------|------|----------|----------|
| **Apollo Client** | 功能最全，生态丰富，缓存强大 | 中大型项目，React应用 | ⭐⭐⭐ |
| **Relay** | Facebook出品，性能极高，较复杂 | 大型项目，性能要求极高 | ⭐⭐⭐⭐⭐ |
| **urql** | 轻量级，简单易用，可扩展 | 中小型项目，追求简洁 | ⭐⭐ |
| **graphql-request** | 最轻量，仅发请求 | 小项目，Node.js服务端 | ⭐ |

### 5.2 选择标准


**🎯 项目规模考虑**：
```
小项目 (< 10个查询):
→ graphql-request 够用了

中型项目 (10-50个查询):
→ urql 简单好用

大型项目 (> 50个查询):
→ Apollo Client 功能全面
```

**🎯 技术栈考虑**：
- **React**: Apollo Client 或 urql
- **Vue**: Apollo Client (Vue版) 或 urql  
- **Node.js**: graphql-request
- **React Native**: Apollo Client

**🎯 功能需求考虑**：
- **需要强大缓存**: Apollo Client
- **需要离线支持**: Apollo Client
- **需要实时订阅**: Apollo Client 或 urql
- **只需简单查询**: graphql-request

> 🔥 **新手建议**：从Apollo Client开始学，它功能最全，文档最好，社区最大

---

## 6. 🔄 useQuery与useMutation


### 6.1 useQuery - 查询数据


> 💡 **通俗理解**：`useQuery`就像是"问问题"，你问服务器要数据，它自动帮你获取并管理这些数据。

**🔸 基础使用**：
```javascript
import { useQuery, gql } from '@apollo/client';

// 定义查询
const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

// 在组件中使用
function UserList() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return <p>加载中...</p>;
  if (error) return <p>出错了: {error.message}</p>;

  return (
    <ul>
      {data.users.map(user => (
        <li key={user.id}>{user.name} - {user.email}</li>
      ))}
    </ul>
  );
}
```

**🔸 useQuery返回的三个关键状态**：
- `loading`: 是否正在加载 (true/false)
- `error`: 是否有错误 (null 或错误对象)
- `data`: 查询到的数据 (undefined 或数据对象)

> 📝 **理解**：这三个状态覆盖了请求的所有可能情况，你只需要根据这些状态渲染不同的界面

### 6.2 useMutation - 修改数据


> 💡 **通俗理解**：`useMutation`就像是"做操作"，比如添加用户、删除文章、更新信息等，它不会自动执行，需要你手动触发。

**🔸 基础使用**：
```javascript
import { useMutation, gql } from '@apollo/client';

// 定义变更操作
const ADD_USER = gql`
  mutation AddUser($name: String!, $email: String!) {
    addUser(name: $name, email: $email) {
      id
      name
      email
    }
  }
`;

function AddUserForm() {
  const [addUser, { loading, error }] = useMutation(ADD_USER);

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const { data } = await addUser({
        variables: {
          name: 'John Doe',
          email: 'john@example.com'
        }
      });
      console.log('添加成功:', data.addUser);
    } catch (err) {
      console.error('添加失败:', err);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit" disabled={loading}>
        {loading ? '添加中...' : '添加用户'}
      </button>
      {error && <p>错误: {error.message}</p>}
    </form>
  );
}
```

### 6.3 useQuery vs useMutation 对比


| 特点 | useQuery | useMutation |
|------|----------|-------------|
| **何时执行** | 组件加载时自动执行 | 手动调用才执行 |
| **用途** | 获取数据 (查询) | 修改数据 (增删改) |
| **返回值** | `{ loading, error, data }` | `[mutateFunction, { loading, error, data }]` |
| **是否缓存** | ✅ 自动缓存 | ❌ 不缓存 |

---

## 7. 🎯 变量传递与缓存策略


### 7.1 变量传递详解


> 💡 **为什么需要变量**：就像函数需要参数一样，GraphQL查询也经常需要参数，比如"获取指定id的用户"、"获取第2页的文章"等。

**🔸 在useQuery中使用变量**：
```javascript
const GET_USER = gql`
  query GetUser($userId: ID!) {
    user(id: $userId) {
      id
      name
      email
      posts {
        title
      }
    }
  }
`;

function UserProfile({ userId }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { userId } // 传递变量
  });

  // 处理渲染...
}
```

**🔸 在useMutation中使用变量**：
```javascript
const UPDATE_USER = gql`
  mutation UpdateUser($id: ID!, $name: String, $email: String) {
    updateUser(id: $id, name: $name, email: $email) {
      id
      name
      email
    }
  }
`;

function EditUser({ userId }) {
  const [updateUser] = useMutation(UPDATE_USER);
  
  const handleUpdate = () => {
    updateUser({
      variables: {
        id: userId,
        name: '新名字',
        email: '新邮箱@example.com'
      }
    });
  };
}
```

### 7.2 缓存策略详解


> 💡 **缓存的作用**：就像浏览器缓存网页一样，Apollo Client会自动缓存查询结果，下次同样的查询直接从缓存返回，不需要重新请求服务器。

**🔸 默认缓存行为**：
```javascript
// 第一次查询 - 从服务器获取
const { data } = useQuery(GET_USERS);

// 同样的查询 - 直接从缓存返回，瞬间显示
const { data } = useQuery(GET_USERS);
```

**🔸 常用缓存策略**：

```javascript
const { loading, error, data } = useQuery(GET_USERS, {
  fetchPolicy: 'cache-first' // 优先使用缓存
});

// 所有可用的策略：
// 'cache-first'     - 优先缓存，没有缓存才请求服务器 (默认)
// 'cache-only'      - 只用缓存，永不请求服务器
// 'network-only'    - 只请求服务器，不使用缓存
// 'no-cache'        - 不使用缓存，也不存储结果
// 'cache-and-network' - 同时使用缓存和网络，以网络结果为准
```

### 7.3 缓存策略选择指南


| 策略 | 使用场景 | 优点 | 缺点 |
|------|----------|------|------|
| `cache-first` | 一般情况，数据不经常变化 | 🚀 速度快，减少请求 | 可能显示过期数据 |
| `network-only` | 数据经常变化，需要最新 | ✅ 数据总是最新 | 🐌 每次都要等待网络 |
| `cache-and-network` | 既要速度又要新数据 | 🎯 快速显示 + 自动更新 | 会产生两次渲染 |

> 🎯 **新手建议**：大多数情况下用默认的`cache-first`就够了

---

## 8. 🛠️ 补充:Apollo Devtools使用


### 8.1 什么是Apollo Devtools


> 💡 **通俗理解**：Apollo Devtools就像是给GraphQL开发装了一个"X光机"，让你能看到所有的查询、变更、缓存状态，是调试GraphQL应用必备的工具。

**🔸 主要功能**：
- 查看所有GraphQL操作
- 实时监控缓存状态  
- 手动执行查询和变更
- 查看网络请求详情
- 调试性能问题

### 8.2 安装和启用


**📦 浏览器扩展安装**：
1. Chrome商店搜索"Apollo Client Developer Tools"
2. 点击"添加至Chrome"
3. 打开包含Apollo Client的网页
4. 按F12开启开发者工具
5. 找到"Apollo"标签页

**🔧 应用端配置**：
```javascript
const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
  connectToDevTools: true // 确保开启开发者工具连接
});
```

### 8.3 核心功能介绍


**🔍 查询面板（Queries）**：
```
功能：查看所有执行过的查询
信息：查询语句、变量、执行时间、结果
用途：调试查询是否正确执行
```

**💾 缓存面板（Cache）**：
```
功能：查看Apollo Client缓存的所有数据
信息：缓存的数据结构、字段值
用途：确认数据是否正确缓存
```

**🔄 变更面板（Mutations）**：
```
功能：查看所有执行过的变更操作
信息：变更语句、变量、执行结果
用途：调试数据修改是否成功
```

### 8.4 实用调试技巧


**🎯 快速定位问题**：
1. **查询没返回数据**：检查Queries面板的错误信息
2. **界面没更新**：检查Cache面板的缓存状态
3. **变更没生效**：检查Mutations面板的执行结果

**🎯 性能分析**：
- 查看查询执行时间
- 识别重复和不必要的查询
- 分析缓存命中率

> 🔥 **专业提示**：开发GraphQL应用时，始终保持Apollo Devtools打开，它能帮你快速发现和解决99%的问题

---

## 9. ⚠️ 错误处理与调试


### 9.1 GraphQL错误类型


> 💡 **理解GraphQL错误**：GraphQL的错误处理和普通HTTP API有点不同，即使查询部分失败，HTTP状态码也可能是200，真正的错误信息在响应体里。

**🔸 GraphQL错误结构**：
```json
{
  "data": {
    "user": null
  },
  "errors": [
    {
      "message": "用户不存在",
      "locations": [{"line": 2, "column": 3}],
      "path": ["user"],
      "extensions": {
        "code": "USER_NOT_FOUND"
      }
    }
  ]
}
```

**🔸 常见错误类型**：
- **语法错误**：GraphQL查询语法不正确
- **验证错误**：查询结构不符合Schema
- **执行错误**：服务器执行查询时出错
- **网络错误**：网络连接问题

### 9.2 useQuery错误处理


**🔧 基础错误处理**：
```javascript
function UserList() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return <div>加载中...</div>;
  
  if (error) {
    console.error('查询错误:', error);
    return (
      <div>
        <h3>出错了！</h3>
        <p>{error.message}</p>
        {/* 显示具体错误信息 */}
        {error.graphQLErrors.map(({ message }, i) => (
          <p key={i}>GraphQL错误: {message}</p>
        ))}
        {error.networkError && (
          <p>网络错误: {error.networkError.message}</p>
        )}
      </div>
    );
  }

  return (
    <ul>
      {data.users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 9.3 useMutation错误处理


**🔧 变更操作错误处理**：
```javascript
function AddUserForm() {
  const [addUser, { loading, error }] = useMutation(ADD_USER);
  const [feedback, setFeedback] = useState('');

  const handleSubmit = async (formData) => {
    try {
      const { data } = await addUser({
        variables: formData
      });
      setFeedback('用户添加成功！');
    } catch (err) {
      console.error('添加用户失败:', err);
      
      // 区分不同类型的错误
      if (err.networkError) {
        setFeedback('网络连接失败，请检查网络');
      } else if (err.graphQLErrors?.length > 0) {
        setFeedback(`服务器错误: ${err.graphQLErrors[0].message}`);
      } else {
        setFeedback('未知错误，请稍后重试');
      }
    }
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        {/* 表单内容 */}
        <button type="submit" disabled={loading}>
          {loading ? '添加中...' : '添加用户'}
        </button>
      </form>
      
      {feedback && <p>{feedback}</p>}
      {error && <p style={{color: 'red'}}>错误: {error.message}</p>}
    </div>
  );
}
```

### 9.4 全局错误处理


**🔧 在Apollo Client中设置全局错误处理**：
```javascript
import { ApolloClient, from, HttpLink } from '@apollo/client';
import { onError } from '@apollo/client/link/error';

// 错误处理链接
const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) => {
      console.error(
        `GraphQL错误: Message: ${message}, Location: ${locations}, Path: ${path}`
      );
      
      // 可以在这里做全局错误处理，比如显示通知
      showErrorNotification(message);
    });
  }

  if (networkError) {
    console.error(`网络错误: ${networkError}`);
    
    // 处理特定的网络错误
    if (networkError.statusCode === 401) {
      // 未授权，跳转登录页
      window.location.href = '/login';
    }
  }
});

// HTTP链接
const httpLink = new HttpLink({
  uri: 'http://localhost:4000/graphql'
});

// 创建客户端，组合错误处理和HTTP链接
const client = new ApolloClient({
  link: from([errorLink, httpLink]),
  cache: new InMemoryCache()
});
```

### 9.5 调试最佳实践


**🎯 调试步骤指南**：

1. **检查网络**：打开浏览器开发者工具的Network标签
2. **查看Apollo Devtools**：确认查询和变更是否正确执行
3. **检查控制台**：查看JavaScript错误信息
4. **验证查询语句**：在GraphQL Playground中单独测试查询

**🔍 常见问题排查**：

```
问题：查询没有返回数据
排查：
1. 检查查询语句语法是否正确
2. 确认服务器地址是否正确
3. 查看Network面板的响应内容

问题：变更操作没有生效  
排查：
1. 检查变更语句和变量是否正确
2. 确认权限是否足够
3. 查看服务器端错误日志

问题：缓存数据不更新
排查：
1. 检查缓存策略设置
2. 考虑手动清除缓存
3. 使用refetch强制重新获取
```

> 🔥 **调试金句**：90%的GraphQL问题都能通过Apollo Devtools快速定位，剩下10%需要检查网络和服务器端

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 GraphQL客户端请求本质：通过HTTP POST发送JSON格式的查询语句
🔸 Apollo Client作用：简化GraphQL操作，自动处理缓存和错误
🔸 useQuery：用于查询数据，自动执行，返回loading/error/data
🔸 useMutation：用于修改数据，手动执行，返回执行函数和状态
🔸 变量传递：通过variables对象传递查询参数
🔸 缓存策略：控制何时使用缓存，何时请求服务器
```

### 10.2 关键理解要点


**🔹 GraphQL vs REST的客户端差异**：
```
REST客户端：
- 多个端点，每个返回固定结构
- 需要多次请求拼接数据
- 缓存相对简单

GraphQL客户端：
- 单个端点，按需返回数据
- 一次请求获取所需数据
- 智能缓存，自动规范化
```

**🔹 为什么选择Apollo Client**：
```
原始fetch方式：
- 需要手写请求逻辑
- 需要手动管理缓存
- 需要手动处理错误
- 需要手动更新界面

Apollo Client方式：
- 声明式查询，自动执行
- 智能缓存，自动更新
- 统一错误处理
- 自动更新React组件
```

**🔹 缓存的重要性**：
```
没有缓存：
- 每次查询都要等待网络请求
- 用户体验差，加载慢
- 服务器压力大

有了缓存：
- 相同查询瞬间返回
- 用户体验好，响应快
- 减少服务器压力
```

### 10.3 实践应用指导


**🎯 新手学习路径**：
1. 先用curl/Postman理解GraphQL HTTP请求
2. 学会配置Apollo Client基础环境  
3. 掌握useQuery查询数据
4. 掌握useMutation修改数据
5. 理解变量传递和缓存策略
6. 学会使用Apollo Devtools调试
7. 掌握错误处理最佳实践

**🎯 开发最佳实践**：
- ✅ 始终使用Apollo Devtools进行调试
- ✅ 合理选择缓存策略，一般用默认的cache-first
- ✅ 编写完整的错误处理逻辑
- ✅ 使用变量而不是拼接字符串构建查询
- ✅ 在useMutation后考虑更新缓存或重新查询

**🎯 常见错误避免**：
- ❌ 忘记设置Content-Type为application/json
- ❌ 在useMutation中直接修改缓存数据
- ❌ 不处理loading和error状态
- ❌ 过度使用network-only策略影响性能

### 10.4 进阶学习方向


```
掌握基础后可以学习：
🔸 订阅(Subscriptions)：实时数据更新
🔸 本地状态管理：用Apollo管理应用状态
🔸 离线功能：Apollo支持的离线缓存
🔸 性能优化：查询分片、延迟加载等
🔸 测试：如何测试GraphQL组件
```

**核心记忆要点**：
- GraphQL客户端开发的核心是理解查询-缓存-更新的循环
- Apollo Client让复杂的GraphQL操作变成简单的React Hook
- 良好的错误处理和调试习惯是GraphQL开发的关键
- 缓存策略的选择直接影响用户体验和应用性能