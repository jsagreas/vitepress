---
title: 1、同源策略与跨域安全机制
---
## 📚 目录

1. [同源策略基础概念](#1-同源策略基础概念)
2. [同源策略详细定义与判断](#2-同源策略详细定义与判断)
3. [跨域行为触发场景](#3-跨域行为触发场景)
4. [传统跨域解决方案](#4-传统跨域解决方案)
5. [PostMessage跨窗口通信](#5-postmessage跨窗口通信)
6. [document.domain机制](#6-documentdomain机制)
7. [跨域存储限制](#7-跨域存储限制)
8. [iframe跨域安全防护](#8-iframe跨域安全防护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ 同源策略基础概念


### 1.1 什么是同源策略？


**简单理解**：同源策略就像小区的门禁系统，只有住在同一栋楼（同源）的住户才能互相串门，不同楼栋的住户不能随意进入。

**正式定义**：同源策略（Same-Origin Policy，SOP）是浏览器最重要的安全机制，**限制一个源的文档或脚本如何与另一个源的资源进行交互**。

```
🏠 现实类比
小区A栋 ← → 小区A栋  ✅ 可以互相访问
小区A栋 ← → 小区B栋  ❌ 禁止直接访问
小区A栋 ← → 隔壁小区  ❌ 完全禁止访问
```

### 1.2 同源策略的安全意义


**🔐 核心安全价值**
```
防止恶意网站：
攻击网站 evil.com 不能读取 bank.com 的用户数据

保护用户隐私：
购物网站 shop.com 不能访问 email.com 的邮件内容

阻止CSRF攻击：
恶意网站不能冒用用户身份向其他网站发送请求
```

**💡 通俗举例**
```
场景：你在网银页面 https://bank.com 登录
风险：同时打开了恶意网站 https://evil.com

没有同源策略：
evil.com 可以读取 bank.com 的页面内容
evil.com 可以获取你的账户余额
evil.com 可以冒充你进行转账操作

有了同源策略：
evil.com 被浏览器阻止，无法访问 bank.com
你的银行信息得到保护 ✅
```

---

## 2. 📏 同源策略详细定义与判断


### 2.1 "源"的三要素


**🔑 源 = 协议 + 域名 + 端口**

```
URL解析示例：
https://www.example.com:443/path/to/page

协议：https://
域名：www.example.com
端口：443（HTTPS默认端口）
路径：/path/to/page （不影响同源判断）
```

### 2.2 同源判断规则


**✅ 同源要求：三要素必须完全一致**

| 对比URL | 协议 | 域名 | 端口 | 结果 | 原因 |
|---------|------|------|------|------|------|
| `https://example.com:443` | ✅ | ✅ | ✅ | **同源** | 完全一致 |
| `http://example.com:80` | ❌ | ✅ | ❌ | **跨域** | 协议和端口不同 |
| `https://api.example.com:443` | ✅ | ❌ | ✅ | **跨域** | 子域名不同 |
| `https://example.com:8080` | ✅ | ✅ | ❌ | **跨域** | 端口不同 |

### 2.3 常见误区澄清


**❓ 容易搞错的情况**

```javascript
// 基准网站：https://www.example.com

// ❌ 这些都是跨域，不是同源！
'https://example.com'          // 缺少 www 子域名
'https://www.example.com:8080' // 端口不同
'http://www.example.com'       // 协议不同
'https://api.example.com'      // 子域名不同

// ✅ 这些是同源
'https://www.example.com/api'     // 路径不影响
'https://www.example.com?id=123'  // 查询参数不影响
'https://www.example.com#section' // 锚点不影响
```

**💡 记忆要点**
- **路径、查询参数、锚点**：不影响同源判断
- **子域名**：`www.example.com` 和 `api.example.com` 是不同源
- **默认端口**：HTTP默认80，HTTPS默认443，可以省略但仍然存在

---

## 3. 🚫 跨域行为触发场景


### 3.1 Ajax请求跨域


**最常见的跨域场景**

```javascript
// 当前页面：https://www.example.com
// 发起跨域请求

// ❌ 跨域请求会被浏览器阻止
fetch('https://api.other.com/data')
  .then(response => response.json())
  .catch(error => {
    console.log('跨域错误：', error);
    // CORS policy错误
  });

// 浏览器控制台错误信息：
// Access to fetch at 'https://api.other.com/data' 
// from origin 'https://www.example.com' has been blocked by CORS policy
```

### 3.2 Cookie跨域访问


**Cookie的同源限制**

```javascript
// 网站A：https://site-a.com
document.cookie = 'userToken=abc123; path=/';

// 网站B：https://site-b.com  
// ❌ 无法读取网站A的Cookie
console.log(document.cookie); // 读不到 userToken

// 💡 这保护了用户的登录状态不被其他网站窃取
```

### 3.3 iframe跨域访问


**父子页面跨域限制**

```html
<!-- 父页面：https://parent.com -->
<iframe src="https://child.com/page.html" id="childFrame"></iframe>

<script>
// ❌ 跨域无法访问iframe内容
const iframe = document.getElementById('childFrame');
try {
  const childDoc = iframe.contentDocument; // null
  const childWindow = iframe.contentWindow.document; // 报错
} catch (error) {
  console.log('跨域访问被阻止');
}
</script>
```

### 3.4 跨域触发的具体表现


**🔍 浏览器如何阻止跨域**

```
请求发送流程：

1️⃣ JavaScript发起跨域请求
   ↓
2️⃣ 浏览器检查目标URL是否同源
   ↓
3️⃣ 发现跨域，但仍然发送请求（简单请求）
   ↓  
4️⃣ 服务器正常响应
   ↓
5️⃣ 浏览器接收响应，检查CORS头
   ↓
6️⃣ 没有合适的CORS头，阻止JavaScript获取响应

关键理解：请求已经发送了，但响应被浏览器拦截！
```

---

## 4. 🔧 传统跨域解决方案


### 4.1 JSONP原理解析


**📖 JSONP工作机制**

JSONP利用了`<script>`标签不受同源策略限制的特点。

```html
<!-- 基本原理：script标签可以跨域加载 -->
<script src="https://api.other.com/data?callback=handleData"></script>

<script>
// 定义回调函数
function handleData(data) {
  console.log('接收到数据：', data);
}
</script>
```

**💻 JSONP完整示例**

```javascript
// 客户端代码
function jsonp(url, callback) {
  // 1. 创建script标签
  const script = document.createElement('script');
  
  // 2. 生成唯一回调函数名
  const callbackName = 'jsonp_callback_' + Date.now();
  
  // 3. 在全局定义回调函数
  window[callbackName] = function(data) {
    callback(data);
    // 清理：删除script标签和回调函数
    document.head.removeChild(script);
    delete window[callbackName];
  };
  
  // 4. 设置src，触发请求
  script.src = url + '?callback=' + callbackName;
  document.head.appendChild(script);
}

// 使用示例
jsonp('https://api.other.com/user', function(data) {
  console.log('用户信息：', data);
});
```

```javascript
// 服务器端响应（Node.js示例）
app.get('/user', (req, res) => {
  const callback = req.query.callback;
  const userData = { name: '张三', age: 25 };
  
  // 返回JavaScript代码，调用回调函数
  res.send(`${callback}(${JSON.stringify(userData)})`);
});

// 实际返回内容：
// jsonp_callback_1234567890({"name":"张三","age":25})
```

**⚠️ JSONP安全风险**
```
🔸 只支持GET请求
🔸 容易受到XSS攻击
🔸 无法设置请求头
🔸 错误处理困难
🔸 服务端必须支持JSONP格式
```

### 4.2 代理服务器方案


**🔄 代理转发原理**

```
客户端跨域问题：
浏览器 → 直接请求其他域名 → ❌ 被同源策略阻止

代理解决方案：
浏览器 → 同源代理服务器 → 代理转发到目标服务器 → ✅ 成功
```

**💻 Nginx代理配置**

```nginx
server {
  listen 80;
  server_name www.example.com;
  
  # 页面服务
  location / {
    root /var/www/html;
  }
  
  # API代理，解决跨域
  location /api/ {
    proxy_pass https://api.other.com/;
    proxy_set_header Host api.other.com;
    proxy_set_header Origin https://api.other.com;
  }
}
```

**前端调用方式**
```javascript
// 原本的跨域请求：
// fetch('https://api.other.com/user') // ❌ 跨域

// 通过代理的同源请求：
fetch('/api/user') // ✅ 同源，由Nginx转发到api.other.com
  .then(response => response.json())
  .then(data => console.log(data));
```

### 4.3 反向代理原理


**🏗️ 反向代理架构**

```
传统架构：
前端(example.com) → 直接请求 → API服务器(api.other.com) ❌

反向代理架构：
前端(example.com) → 代理服务器(example.com/api) → API服务器 ✅
                   ↑
                  同源请求
```

**优势对比**
```
🔸 前端视角：所有请求都是同源
🔸 服务端：无需修改现有API
🔸 安全性：隐藏真实API服务器地址
🔸 缓存：可在代理层添加缓存
🔸 负载均衡：可代理到多个后端服务器
```

---

## 5. 📬 PostMessage跨窗口通信


### 5.1 PostMessage基本原理


**🔗 跨窗口安全通信**

PostMessage提供了一种安全的跨域通信方式，允许不同源的窗口之间传递消息。

```
通信场景：
父窗口(parent.com) ←→ 子窗口(child.com)
主窗口(main.com) ←→ 弹出窗口(popup.com)
iframe(iframe.com) ←→ 父页面(parent.com)
```

### 5.2 PostMessage基本用法


**💻 发送消息**

```javascript
// 父页面：https://parent.com
const iframe = document.getElementById('childFrame');

// 向iframe发送消息
iframe.contentWindow.postMessage(
  { type: 'greeting', message: 'Hello from parent!' }, // 数据
  'https://child.com' // 目标源，安全检查
);

// 向弹出窗口发送消息  
const popup = window.open('https://popup.com/page.html');
popup.postMessage(
  { user: 'zhangsan', token: 'abc123' },
  'https://popup.com'
);
```

**👂 接收消息**

```javascript
// 子页面：https://child.com
window.addEventListener('message', function(event) {
  // 🔒 安全检查：验证消息来源
  if (event.origin !== 'https://parent.com') {
    console.log('拒绝来自未知源的消息：', event.origin);
    return;
  }
  
  // 处理消息
  console.log('收到父页面消息：', event.data);
  
  // 回复消息
  event.source.postMessage(
    { type: 'reply', message: 'Hello from child!' },
    event.origin
  );
});
```

### 5.3 PostMessage安全实践


**🔐 Origin验证的重要性**

```javascript
// ❌ 危险：不验证消息来源
window.addEventListener('message', function(event) {
  // 任何网站都可以发送消息，存在安全风险
  localStorage.setItem('userToken', event.data.token);
});

// ✅ 安全：严格验证消息来源
window.addEventListener('message', function(event) {
  // 白名单验证
  const allowedOrigins = [
    'https://trusted-parent.com',
    'https://api.myapp.com'
  ];
  
  if (!allowedOrigins.includes(event.origin)) {
    console.warn('拒绝未授权源的消息：', event.origin);
    return;
  }
  
  // 安全处理消息
  handleTrustedMessage(event.data);
});
```

**📋 PostMessage事件属性**

```javascript
window.addEventListener('message', function(event) {
  console.log('消息数据：', event.data);      // 传递的数据
  console.log('来源域名：', event.origin);    // 发送者的源
  console.log('来源窗口：', event.source);    // 发送者的window对象
  console.log('最后事件ID：', event.lastEventId); // 可选
});
```

---

## 6. 🌐 document.domain机制


### 6.1 domain松散设置原理


**📖 什么是document.domain**

document.domain允许**同一主域名下的不同子域名**之间进行通信。

```
适用场景：
www.example.com ←→ api.example.com   ✅ 同主域名
blog.example.com ←→ shop.example.com ✅ 同主域名

不适用场景：
example.com ←→ other.com ❌ 不同主域名
```

### 6.2 使用方法和限制


**💻 基本用法**

```javascript
// 在 www.example.com 页面中
console.log(document.domain); // "www.example.com"

// 设置为主域名
document.domain = 'example.com';
console.log(document.domain); // "example.com"

// 现在可以与其他子域名通信了
```

```javascript
// 在 api.example.com 页面中  
document.domain = 'example.com'; // 必须两边都设置

// iframe通信示例
// 父页面：www.example.com
document.domain = 'example.com';
const iframe = document.getElementById('apiFrame');
// 现在可以访问iframe内容
const iframeDoc = iframe.contentDocument; // ✅ 成功访问
```

**⚠️ 使用限制**

```javascript
// ✅ 允许的设置：
// 当前域名：sub.example.com
document.domain = 'example.com'; // 可以设置为父域名

// ❌ 禁止的设置：
document.domain = 'other.com';     // 不能设置为其他域名
document.domain = 'sub.example.com'; // 不能设置为子域名（如果当前是example.com）
document.domain = 'evil.com';      // 绝对禁止
```

### 6.3 安全风险和注意事项


**🚨 安全风险分析**

```
风险1：域名控制权风险
如果攻击者控制了同主域名下的任一子域名，
就可以访问设置了document.domain的其他子域名

风险2：Cookie共享风险  
设置document.domain后，Cookie可能被共享，
存在敏感信息泄露风险

风险3：XSS攻击扩散
一个子域名的XSS攻击可能影响其他子域名
```

**💡 最佳实践**

```javascript
// 1. 只在必要时使用
if (needCrossDomainCommunication) {
  document.domain = 'example.com';
}

// 2. 验证通信内容
window.addEventListener('message', function(event) {
  if (event.origin.endsWith('.example.com')) {
    // 验证消息格式和内容
    if (isValidMessage(event.data)) {
      handleMessage(event.data);
    }
  }
});

// 3. 避免敏感操作
// 不要在设置document.domain的页面处理敏感数据
```

---

## 7. 💾 跨域存储限制


### 7.1 Web存储的同源限制


**🗄️ 存储类型和限制**

浏览器的存储机制都严格遵循同源策略：

```
存储类型对比：
┌─────────────────┬─────────────┬─────────────┐
│    存储类型     │   作用域    │   持久性    │
├─────────────────┼─────────────┼─────────────┤
│ localStorage    │    同源     │   持久存储  │
│ sessionStorage  │  同源+标签  │   会话存储  │
│ IndexedDB       │    同源     │   持久存储  │
│ WebSQL          │    同源     │   已废弃    │
│ Cookie          │  域名+路径  │  可设置过期 │
└─────────────────┴─────────────┴─────────────┘
```

### 7.2 LocalStorage跨域限制


**💻 实际测试示例**

```javascript
// 网站A：https://site-a.com
localStorage.setItem('userInfo', JSON.stringify({
  name: '张三',
  email: 'zhangsan@example.com'
}));
console.log('A网站存储完成');

// 网站B：https://site-b.com  
const userInfo = localStorage.getItem('userInfo');
console.log(userInfo); // null - 无法访问A网站的数据

// 即使是子域名也不行
// 主站：https://example.com
// 子站：https://api.example.com - 也无法访问主站数据
```

**🔒 安全意义**

```
保护用户隐私：
购物网站存储的购买记录，社交网站无法访问

防止数据泄露：
银行网站的用户信息，其他网站无法获取

避免恶意操作：
恶意网站无法修改或删除其他网站的存储数据
```

### 7.3 SessionStorage特殊性


**🏷️ 更严格的限制**

```javascript
// SessionStorage不仅限制同源，还限制同一标签页

// 标签页1：https://example.com
sessionStorage.setItem('tabData', 'tab1-data');

// 标签页2：https://example.com（新开标签页）
const data = sessionStorage.getItem('tabData');
console.log(data); // null - 即使同源也无法访问

// 只有同一标签页内的页面跳转才能共享sessionStorage
```

### 7.4 IndexedDB跨域限制


**🗃️ 数据库级别的同源限制**

```javascript
// 网站A：https://site-a.com
const request = indexedDB.open('MyDatabase', 1);
request.onsuccess = function(event) {
  const db = event.target.result;
  // 创建数据存储
};

// 网站B：https://site-b.com
const request2 = indexedDB.open('MyDatabase', 1);
// 这会创建一个全新的数据库，与网站A的数据库完全独立
```

---

## 8. 🖼️ iframe跨域安全防护


### 8.1 iframe嵌入风险


**🎯 常见攻击场景**

```
点击劫持攻击（Clickjacking）：
恶意网站通过透明iframe嵌入目标网站
用户以为在点击恶意网站按钮
实际在操作被嵌入的目标网站

iframe注入攻击：
恶意网站嵌入受害网站
通过iframe进行钓鱼或信息窃取
```

### 8.2 X-Frame-Options防护


**🛡️ 服务器端防护**

```javascript
// Node.js/Express示例
app.use((req, res, next) => {
  // 禁止被任何网站嵌入
  res.setHeader('X-Frame-Options', 'DENY');
  
  // 或者只允许同源嵌入
  res.setHeader('X-Frame-Options', 'SAMEORIGIN');
  
  // 或者只允许特定网站嵌入
  res.setHeader('X-Frame-Options', 'ALLOW-FROM https://trusted.com');
  
  next();
});
```

**📊 X-Frame-Options选项对比**

| 选项值 | 含义 | 使用场景 |
|--------|------|----------|
| `DENY` | 禁止任何网站嵌入 | 银行、支付等敏感网站 |
| `SAMEORIGIN` | 只允许同源嵌入 | 一般网站的iframe使用 |
| `ALLOW-FROM uri` | 只允许指定网站嵌入 | 授权合作网站嵌入 |

### 8.3 CSP frame-ancestors指令


**🔧 更灵活的现代防护**

```javascript
// Content-Security-Policy响应头
app.use((req, res, next) => {
  // 禁止任何网站嵌入
  res.setHeader("Content-Security-Policy", "frame-ancestors 'none'");
  
  // 只允许同源嵌入
  res.setHeader("Content-Security-Policy", "frame-ancestors 'self'");
  
  // 允许多个特定网站嵌入
  res.setHeader("Content-Security-Policy", 
    "frame-ancestors https://trusted1.com https://trusted2.com");
  
  next();
});
```

**💡 CSP vs X-Frame-Options**

```
CSP frame-ancestors优势：
✅ 支持多个允许的源
✅ 支持通配符匹配
✅ 更现代的标准
✅ 更灵活的配置

X-Frame-Options限制：
❌ 只能指定一个ALLOW-FROM源
❌ 较老的标准
❌ 配置相对简单但不够灵活
```

### 8.4 iframe sandbox属性


**🏖️ 客户端沙箱限制**

```html
<!-- 基本沙箱：禁用所有危险功能 -->
<iframe src="https://untrusted.com" sandbox></iframe>

<!-- 选择性允许功能 -->
<iframe src="https://content.com" 
        sandbox="allow-scripts allow-same-origin">
</iframe>

<!-- 常用sandbox选项 -->
<iframe src="https://app.com" 
        sandbox="allow-scripts 
                 allow-forms 
                 allow-popups 
                 allow-same-origin">
</iframe>
```

**📋 sandbox属性详解**

| 属性值 | 功能说明 | 安全影响 |
|--------|----------|----------|
| `allow-scripts` | 允许执行JavaScript | ⚠️ 谨慎使用 |
| `allow-forms` | 允许表单提交 | 📝 表单功能 |
| `allow-same-origin` | 保持同源性质 | 🔗 DOM访问 |
| `allow-popups` | 允许弹出窗口 | 📱 新窗口功能 |
| `allow-top-navigation` | 允许导航父页面 | 🔄 页面跳转 |

**⚠️ sandbox安全注意事项**

```html
<!-- ❌ 危险组合：允许脚本+同源 -->
<iframe sandbox="allow-scripts allow-same-origin" 
        src="https://untrusted.com">
</iframe>
<!-- 这等于没有沙箱限制！ -->

<!-- ✅ 安全做法：按需最小化权限 -->
<iframe sandbox="allow-forms" 
        src="https://form-only.com">
</iframe>
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 同源策略SOP：浏览器安全基石，限制跨域资源访问
🔸 源的定义：协议+域名+端口三要素必须完全一致
🔸 跨域触发：Ajax请求、Cookie访问、iframe操作、存储访问
🔸 传统解决方案：JSONP、代理转发、反向代理各有优缺点  
🔸 现代通信：PostMessage提供安全的跨域通信能力
🔸 存储限制：所有Web存储都严格遵循同源策略
🔸 iframe防护：X-Frame-Options、CSP、sandbox多重保护
```

### 9.2 关键理解要点


**🔹 同源策略的核心价值**
```
安全边界：
- 防止恶意网站窃取用户数据
- 阻止跨站请求伪造(CSRF)攻击  
- 保护用户隐私和敏感信息

技术实现：
- 浏览器在JavaScript层面强制执行
- 网络请求可能发送，但响应被拦截
- 不影响CSS、图片等资源的加载
```

**🔹 跨域解决方案的选择**
```
JSONP：
✅ 兼容性好，实现简单
❌ 只支持GET，安全风险高
🎯 适用于简单的数据获取

代理转发：
✅ 完全解决跨域，支持所有HTTP方法
❌ 需要服务器配置，增加延迟
🎯 适用于企业应用和复杂场景

PostMessage：
✅ 安全可控，官方标准
❌ 只适用于窗口间通信
🎯 适用于iframe和弹窗通信
```

**🔹 安全防护的层次**
```
浏览器层：同源策略自动防护
服务器层：X-Frame-Options、CSP配置
应用层：Origin验证、内容验证
用户层：避免可疑网站，保持警惕
```

### 9.3 实际应用指导


**🎯 开发实践建议**

```javascript
// 1. 跨域请求的错误处理
fetch('https://api.other.com/data')
  .catch(error => {
    if (error.message.includes('CORS')) {
      console.log('跨域请求被阻止，考虑使用代理或CORS配置');
    }
  });

// 2. PostMessage的安全使用
window.addEventListener('message', (event) => {
  // 始终验证消息来源
  if (!trustedOrigins.includes(event.origin)) return;
  
  // 验证消息格式
  if (typeof event.data === 'object' && event.data.type) {
    handleMessage(event.data);
  }
});

// 3. iframe嵌入的安全考虑
const iframe = document.createElement('iframe');
iframe.src = 'https://trusted-content.com';
iframe.sandbox = 'allow-scripts allow-forms'; // 最小权限
document.body.appendChild(iframe);
```

**🛡️ 安全检查清单**

```
前端安全：
☑️ 验证所有跨域通信的Origin
☑️ 使用HTTPS避免中间人攻击
☑️ 避免在URL中传递敏感信息
☑️ 实施CSP策略防范XSS

后端安全：
☑️ 正确配置CORS头部
☑️ 设置X-Frame-Options防止嵌入
☑️ 验证Referer和Origin头
☑️ 实施CSRF token保护

部署安全：
☑️ 使用反向代理隐藏真实服务器
☑️ 配置防火墙规则
☑️ 定期更新服务器软件
☑️ 监控异常访问日志
```

### 9.4 学习进阶路径


**📈 知识扩展方向**

```
基础巩固：
🔸 深入理解HTTP协议和浏览器工作原理
🔸 学习CORS详细配置和预检请求
🔸 掌握各种Web存储API的使用

进阶学习：
🔸 Content Security Policy (CSP) 详细配置
🔸 Subresource Integrity (SRI) 资源完整性
🔸 Feature Policy 和 Permissions Policy

实战应用：
🔸 微前端架构中的跨域通信
🔸 第三方组件集成的安全方案
🔸 企业级API网关的跨域配置
```

**🎓 记忆口诀**
```
同源三要素，协议域名端口号
跨域有风险，安全需谨慎  
JSONP虽简单，安全隐患多
代理最靠谱，配置稍复杂
PostMessage好，验证不能少
iframe要防护，沙箱是法宝
```

**核心记忆**：
- 同源策略是浏览器安全的基石，三要素缺一不可
- 跨域不是错误，而是安全机制的正常表现
- 每种跨域解决方案都有适用场景和安全考量
- 安全防护需要多层配合，从浏览器到服务器全覆盖