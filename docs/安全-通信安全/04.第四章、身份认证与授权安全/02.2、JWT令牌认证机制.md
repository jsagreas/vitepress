---
title: 2、JWT令牌认证机制
---
## 📚 目录

1. [JWT基础概念与原理](#1-JWT基础概念与原理)
2. [JWT结构深度解析](#2-JWT结构深度解析)
3. [JWT通信传递流程](#3-JWT通信传递流程)
4. [JWT签名验证机制](#4-JWT签名验证机制)
5. [JWT安全使用策略](#5-JWT安全使用策略)
6. [Token存储与安全问题](#6-Token存储与安全问题)
7. [刷新令牌设计机制](#7-刷新令牌设计机制)
8. [JWT攻击防护策略](#8-JWT攻击防护策略)
9. [JWT vs Session对比](#9-JWT-vs-Session对比)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔐 JWT基础概念与原理


### 1.1 什么是JWT


**JWT（JSON Web Token）**：一种用于身份认证的开放标准，就像**电子身份证**一样。

> 💡 **通俗理解**：
> 
> 想象你去游乐园，传统方式是每次玩项目都要出示门票，管理员查验后才能进入。
> 
> JWT就像是一个**智能手环**，里面包含了你的身份信息和权限，每次直接扫描就能通过，不需要反复验证。

**核心特点**：
- ✅ **无状态**：服务器不需要存储用户信息
- ✅ **自包含**：Token本身就包含了所有必要信息
- ✅ **可传递**：可以在不同系统间安全传递
- ✅ **防伪造**：通过签名机制防止篡改

### 1.2 为什么需要JWT


**传统Session认证的问题**：

```
问题场景：
用户登录 → 服务器创建Session → 存储到内存/数据库
用户请求 → 携带SessionID → 服务器查找Session → 验证身份

痛点：
❌ 服务器需要存储大量Session数据
❌ 多服务器需要Session共享
❌ 移动端APP不便处理Cookie
❌ 微服务架构下Session同步复杂
```

**JWT解决方案**：

```
JWT流程：
用户登录 → 服务器生成JWT → 返回给客户端
用户请求 → 携带JWT → 服务器直接验证签名 → 获取用户信息

优势：
✅ 服务器无需存储用户状态
✅ 天然支持分布式架构
✅ 移动端友好
✅ 微服务间轻松传递
```

### 1.3 JWT工作原理


**基本工作流程**：

```
┌─────────────┐    1.登录请求     ┌─────────────┐
│   客户端    │ ──────────────→ │   服务器    │
│            │                 │            │
│            │ ←────────────── │            │
│            │   2.返回JWT      │            │
└─────────────┘                 └─────────────┘
      │                               │
      │ 3.携带JWT访问资源              │
      ▼                               ▼
┌─────────────┐    JWT请求      ┌─────────────┐
│   客户端    │ ──────────────→ │   服务器    │
│            │                 │            │
│            │ ←────────────── │  验证JWT   │
│            │   4.返回资源     │  获取用户信息│
└─────────────┘                 └─────────────┘
```

---

## 2. 📋 JWT结构深度解析


### 2.1 JWT三部分结构


JWT由三部分组成，用**点号（.）**分隔：

```
Header.Payload.Signature
```

**实际JWT示例**：
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

让我们把它拆开来看：

```
Header：   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
Payload：  eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
Signature：SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### 2.2 Header（头部）详解


**作用**：描述JWT的基本信息，就像**信封上的标识**。

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**字段说明**：
- **`alg`**：签名算法，告诉接收方用什么方法验证
- **`typ`**：Token类型，固定为"JWT"

**Base64编码后**：`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

> 💡 **为什么用Base64编码**？
> 
> 因为JWT需要在HTTP头部传输，Base64确保只包含URL安全的字符（字母、数字、-、_）

### 2.3 Payload（载荷）详解


**作用**：存储实际的用户信息和声明，就像**信件的内容**。

```json
{
  "sub": "1234567890",    // 主题（用户ID）
  "name": "John Doe",     // 用户名
  "iat": 1516239022,      // 签发时间
  "exp": 1516242622,      // 过期时间
  "role": "admin"         // 用户角色
}
```

**标准声明（Claims）**：
- **`sub`**（Subject）：主题，通常是用户ID
- **`iat`**（Issued At）：签发时间戳
- **`exp`**（Expiration）：过期时间戳
- **`iss`**（Issuer）：签发方
- **`aud`**（Audience）：接收方

**自定义声明**：
```json
{
  "userId": 12345,
  "username": "john_doe",
  "role": "admin",
  "permissions": ["read", "write"]
}
```

> ⚠️ **安全提醒**：
> 
> Payload是Base64编码的，**任何人都能解码查看**！
> 
> 千万不要在这里放密码、信用卡号等敏感信息！

### 2.4 Signature（签名）详解


**作用**：确保JWT没有被篡改，就像**信件的封印**。

**签名生成过程**：

```
1. 准备数据：
   data = base64(header) + "." + base64(payload)

2. 使用密钥签名：
   signature = HMAC-SHA256(data, secret_key)

3. Base64编码：
   final_signature = base64(signature)
```

**具体示例**：
```javascript
// 1. 准备要签名的数据
const data = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ";

// 2. 使用密钥签名
const secret = "your-256-bit-secret";
const signature = HMAC_SHA256(data, secret);

// 3. Base64编码
const finalSignature = base64URLEncode(signature);
```

---

## 3. 🔄 JWT通信传递流程


### 3.1 完整认证流程


```
第一步：用户登录
┌─────────────┐                    ┌─────────────┐
│   用户      │  用户名/密码        │   服务器    │
│            │ ─────────────────→ │            │
│            │                    │ 验证凭据    │
│            │       JWT          │ 生成JWT     │
│            │ ←───────────────── │            │
└─────────────┘                    └─────────────┘

第二步：访问受保护资源
┌─────────────┐                    ┌─────────────┐
│   客户端    │  Authorization:     │   服务器    │
│            │  Bearer <JWT>       │            │
│            │ ─────────────────→ │ 验证JWT     │
│            │                    │ 解析用户信息 │
│            │    受保护资源       │ 返回数据    │
│            │ ←───────────────── │            │
└─────────────┘                    └─────────────┘
```

### 3.2 HTTP头部传递方式


**标准Authorization头部**：
```http
GET /api/user/profile HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**JavaScript客户端示例**：
```javascript
// 存储JWT
localStorage.setItem('token', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...');

// 发送请求
fetch('/api/user/profile', {
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
})
.then(response => response.json())
.then(data => console.log(data));
```

### 3.3 服务器验证流程


**后端验证步骤**：

```
1. 提取Token：从Authorization头部获取JWT
   ↓
2. 分割Token：按点号分割成三部分
   ↓
3. 验证签名：使用相同密钥重新计算签名
   ↓
4. 检查过期：验证exp时间戳
   ↓
5. 解析载荷：获取用户信息
   ↓
6. 返回结果：允许访问或拒绝请求
```

**Node.js验证示例**：
```javascript
const jwt = require('jsonwebtoken');

function verifyToken(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: '缺少Token' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // 将用户信息附加到请求对象
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Token无效' });
  }
}
```

---

## 4. 🔒 JWT签名验证机制


### 4.1 HS256算法（对称加密）


**HMAC-SHA256**：使用**共享密钥**进行签名验证。

```
签名过程：
┌─────────────┐    共享密钥     ┌─────────────┐
│   客户端    │ ←─────────────→ │   服务器    │
│            │                │            │
│ 用密钥签名  │                │ 用密钥验证  │
└─────────────┘                └─────────────┘
```

**特点**：
- ✅ **速度快**：计算效率高
- ✅ **实现简单**：只需要一个密钥
- ❌ **密钥共享**：所有服务都需要相同密钥
- ❌ **无法授权**：任何知道密钥的人都能签发Token

**使用场景**：单体应用或小型微服务架构

### 4.2 RS256算法（非对称加密）


**RSA-SHA256**：使用**公私钥对**进行签名验证。

```
签名过程：
┌─────────────┐                ┌─────────────┐
│ 认证服务器  │   私钥签名      │ 资源服务器  │
│            │ ──────────────→│            │
│ 私钥签名    │                │ 公钥验证    │
└─────────────┘                └─────────────┘
      │                               │
      │          分发公钥              │
      └─────────────────────────────→ │
```

**特点**：
- ✅ **安全性高**：私钥只在认证服务器，公钥可以公开
- ✅ **职责分离**：签发和验证职责明确
- ✅ **适合分布式**：多个服务可以独立验证
- ❌ **计算慢**：RSA算法计算量大

**使用场景**：大型分布式系统、微服务架构

### 4.3 算法选择对比


| 特性 | **HS256** | **RS256** |
|------|-----------|-----------|
| **算法类型** | `对称加密` | `非对称加密` |
| **密钥管理** | `单一共享密钥` | `公私钥对` |
| **性能** | `🔥 快速` | `⚡ 较慢` |
| **安全性** | `🔒 中等` | `🔐 高` |
| **适用场景** | `小型应用` | `分布式系统` |
| **密钥分发** | `需要安全分发` | `公钥可公开` |

### 4.4 防伪验证流程


**完整验证流程**：

```
接收JWT
    ↓
检查格式（三部分，点号分割）
    ↓
解析Header（获取算法信息）
    ↓
验证签名
    ├─ HS256：用共享密钥验证
    └─ RS256：用公钥验证
    ↓
检查时间戳
    ├─ iat：签发时间合理性
    └─ exp：是否已过期
    ↓
解析Payload（获取用户信息）
    ↓
验证成功，允许访问
```

---

## 5. 🛡️ JWT安全使用策略


### 5.1 Token传递安全


**✅ 推荐方式**：
```http
Authorization: Bearer <JWT>
```

**❌ 不推荐方式**：
```http
GET /api/users?token=<JWT>  # URL参数容易泄露
Cookie: token=<JWT>         # 容易CSRF攻击
```

### 5.2 过期时间策略


**访问Token（短期）**：
```javascript
{
  "exp": Math.floor(Date.now() / 1000) + (15 * 60), // 15分钟
  "type": "access"
}
```

**刷新Token（长期）**：
```javascript
{
  "exp": Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60), // 7天
  "type": "refresh"
}
```

> 💡 **时间设置原则**：
> 
> - **访问Token**：短一些（15-30分钟），减少被盗用风险
> - **刷新Token**：长一些（7-30天），减少用户登录频率

### 5.3 敏感信息处理


**❌ 绝对不要放入JWT**：
- 密码
- 信用卡号
- 身份证号
- 个人隐私信息

**✅ 可以放入JWT**：
- 用户ID
- 用户名
- 角色信息
- 权限标识
- 非敏感配置

**安全载荷示例**：
```json
{
  "sub": "12345",
  "username": "john_doe",
  "role": "user",
  "permissions": ["read_profile", "edit_profile"],
  "iat": 1516239022,
  "exp": 1516242622
}
```

---

## 6. 💾 Token存储与安全问题


### 6.1 存储方式对比


| 存储方式 | **安全性** | **便利性** | **适用场景** | **风险** |
|----------|-----------|-----------|-------------|---------|
| **LocalStorage** | `🔴 低` | `🟢 高` | `单页面应用` | `XSS攻击` |
| **SessionStorage** | `🟡 中` | `🟢 高` | `临时会话` | `XSS攻击` |
| **Cookie** | `🟢 高` | `🟡 中` | `传统网站` | `CSRF攻击` |
| **内存存储** | `🟢 高` | `🔴 低` | `安全要求高` | `刷新丢失` |

### 6.2 LocalStorage存储


**使用方式**：
```javascript
// 存储Token
localStorage.setItem('accessToken', jwt);

// 读取Token
const token = localStorage.getItem('accessToken');

// 删除Token
localStorage.removeItem('accessToken');
```

**安全风险**：
- **XSS攻击**：恶意脚本可以读取LocalStorage
- **持久化**：即使关闭浏览器也不会清除

**防护措施**：
```javascript
// 1. CSP策略防止XSS
// Content-Security-Policy: script-src 'self'

// 2. 输入验证和输出编码
function sanitizeInput(input) {
  return input.replace(/[<>]/g, '');
}
```

### 6.3 Cookie存储


**安全Cookie设置**：
```javascript
// 设置安全Cookie
document.cookie = `token=${jwt}; HttpOnly; Secure; SameSite=Strict; Max-Age=3600`;
```

**属性说明**：
- **`HttpOnly`**：防止JavaScript访问，避免XSS
- **`Secure`**：只在HTTPS下传输
- **`SameSite=Strict`**：防止CSRF攻击
- **`Max-Age`**：设置过期时间

### 6.4 最佳存储实践


**💎 推荐方案**：

```javascript
class TokenManager {
  // 访问Token存储在内存（安全）
  static accessToken = null;
  
  // 刷新Token存储在HttpOnly Cookie（安全）
  static setTokens(accessToken, refreshToken) {
    // 内存存储访问Token
    this.accessToken = accessToken;
    
    // Cookie存储刷新Token
    document.cookie = `refreshToken=${refreshToken}; HttpOnly; Secure; SameSite=Strict`;
  }
  
  static getAccessToken() {
    return this.accessToken;
  }
  
  static clearTokens() {
    this.accessToken = null;
    document.cookie = 'refreshToken=; expires=Thu, 01 Jan 1970 00:00:00 GMT';
  }
}
```

---

## 7. 🔄 刷新令牌设计机制


### 7.1 双Token机制


**为什么需要双Token**？

> 💡 **类比理解**：
> 
> - **访问Token**：像门禁卡，有效期短（15分钟），丢了影响小
> - **刷新Token**：像身份证，有效期长（7天），可以重新办门禁卡

**流程设计**：

```
1. 用户登录
   ↓
2. 服务器返回：访问Token(15分钟) + 刷新Token(7天)
   ↓
3. 客户端用访问Token请求资源
   ↓
4. 访问Token过期
   ↓
5. 用刷新Token获取新的访问Token
   ↓
6. 继续访问资源
```

### 7.2 自动刷新机制


**前端自动刷新实现**：

```javascript
class AuthService {
  constructor() {
    this.accessToken = null;
    this.refreshToken = null;
    this.refreshPromise = null;
  }
  
  // 请求拦截器
  async request(url, options = {}) {
    // 检查Token是否即将过期
    if (this.isTokenExpiringSoon()) {
      await this.refreshAccessToken();
    }
    
    return fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${this.accessToken}`
      }
    });
  }
  
  // 检查Token是否即将过期（提前5分钟刷新）
  isTokenExpiringSoon() {
    if (!this.accessToken) return true;
    
    const payload = JSON.parse(atob(this.accessToken.split('.')[1]));
    const expiryTime = payload.exp * 1000;
    const now = Date.now();
    
    return (expiryTime - now) < 5 * 60 * 1000; // 5分钟
  }
  
  // 刷新访问Token
  async refreshAccessToken() {
    // 防止并发刷新
    if (this.refreshPromise) {
      return this.refreshPromise;
    }
    
    this.refreshPromise = fetch('/api/auth/refresh', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.refreshToken}`
      }
    })
    .then(response => response.json())
    .then(data => {
      this.accessToken = data.accessToken;
      this.refreshToken = data.refreshToken; // 可选：轮换刷新Token
    })
    .finally(() => {
      this.refreshPromise = null;
    });
    
    return this.refreshPromise;
  }
}
```

### 7.3 刷新Token轮换


**安全轮换机制**：

```
每次刷新时：
1. 使用旧的刷新Token
2. 生成新的访问Token + 新的刷新Token
3. 使旧的刷新Token失效
4. 返回新的Token对
```

**后端实现示例**：
```javascript
app.post('/api/auth/refresh', async (req, res) => {
  const oldRefreshToken = req.headers.authorization?.split(' ')[1];
  
  try {
    // 验证旧刷新Token
    const decoded = jwt.verify(oldRefreshToken, REFRESH_SECRET);
    
    // 检查Token是否已被撤销
    if (await isTokenRevoked(oldRefreshToken)) {
      return res.status(401).json({ error: 'Token已撤销' });
    }
    
    // 生成新Token对
    const newAccessToken = generateAccessToken(decoded.userId);
    const newRefreshToken = generateRefreshToken(decoded.userId);
    
    // 撤销旧刷新Token
    await revokeToken(oldRefreshToken);
    
    // 返回新Token对
    res.json({
      accessToken: newAccessToken,
      refreshToken: newRefreshToken
    });
  } catch (error) {
    res.status(401).json({ error: 'Token无效' });
  }
});
```

---

## 8. ⚔️ JWT攻击防护策略


### 8.1 None算法攻击


**攻击原理**：攻击者修改Header中的算法为"none"，绕过签名验证。

**恶意JWT示例**：
```json
// Header
{
  "alg": "none",
  "typ": "JWT"
}

// Payload（攻击者伪造管理员身份）
{
  "sub": "12345",
  "role": "admin",
  "exp": 9999999999
}

// Signature（空字符串）
""
```

**防护措施**：
```javascript
// ❌ 错误的验证代码
function verifyToken(token) {
  const [header, payload, signature] = token.split('.');
  const decodedHeader = JSON.parse(atob(header));
  
  // 危险：直接信任Header中的算法
  if (decodedHeader.alg === 'none') {
    return JSON.parse(atob(payload)); // 被攻击！
  }
}

// ✅ 正确的防护代码
function verifyToken(token) {
  const allowedAlgorithms = ['HS256', 'RS256']; // 白名单
  
  try {
    const decoded = jwt.verify(token, secret, {
      algorithms: allowedAlgorithms // 明确指定允许的算法
    });
    return decoded;
  } catch (error) {
    throw new Error('Token验证失败');
  }
}
```

### 8.2 密钥猜测攻击


**攻击方式**：攻击者尝试猜测或暴力破解签名密钥。

**防护策略**：
```javascript
// ✅ 强密钥生成
const crypto = require('crypto');

// 生成256位随机密钥
const secret = crypto.randomBytes(32).toString('hex');

// 或使用更长的密钥
const strongSecret = 'your-very-long-and-complex-secret-key-with-at-least-256-bits';
```

**密钥管理最佳实践**：
- 🔑 **长度**：至少256位（32字节）
- 🔑 **复杂性**：包含字母、数字、特殊字符
- 🔑 **随机性**：使用加密安全的随机数生成器
- 🔑 **保密性**：存储在环境变量或密钥管理系统中

### 8.3 Token泄露防护


**常见泄露场景**：
- 📱 **移动端**：应用被逆向工程
- 🌐 **Web端**：XSS攻击窃取
- 📋 **日志**：错误日志暴露Token
- 🔗 **URL**：Token作为参数传递

**防护措施**：

```javascript
// 1. 日志脱敏
function logRequest(req) {
  const sanitizedHeaders = { ...req.headers };
  if (sanitizedHeaders.authorization) {
    sanitizedHeaders.authorization = 'Bearer ***';
  }
  console.log('Request:', sanitizedHeaders);
}

// 2. 定期轮换密钥
const keyRotation = {
  current: 'key-v2',
  previous: 'key-v1', // 保留上一个密钥用于验证旧Token
  
  verify(token) {
    try {
      return jwt.verify(token, this.current);
    } catch (error) {
      // 尝试用旧密钥验证
      return jwt.verify(token, this.previous);
    }
  }
};

// 3. Token黑名单
const blacklistedTokens = new Set();

function revokeToken(token) {
  blacklistedTokens.add(token);
}

function isTokenRevoked(token) {
  return blacklistedTokens.has(token);
}
```

### 8.4 重放攻击防护


**防护策略**：

```javascript
// 1. 添加随机数（nonce）
function generateToken(userId) {
  return jwt.sign({
    sub: userId,
    jti: crypto.randomUUID(), // JWT ID，每个Token唯一
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600
  }, secret);
}

// 2. 验证时检查Token唯一性
const usedTokens = new Set();

function verifyToken(token) {
  const decoded = jwt.verify(token, secret);
  
  // 检查Token是否已被使用
  if (usedTokens.has(decoded.jti)) {
    throw new Error('Token已被使用');
  }
  
  usedTokens.add(decoded.jti);
  return decoded;
}
```

---

## 9. ⚖️ JWT vs Session对比


### 9.1 有状态vs无状态认证


**Session（有状态）**：

```
用户登录
    ↓
服务器创建Session → 存储到内存/数据库
    ↓
返回SessionID给客户端
    ↓
客户端每次请求携带SessionID
    ↓
服务器查找Session获取用户信息
```

**JWT（无状态）**：

```
用户登录
    ↓
服务器生成JWT（包含用户信息）
    ↓
返回JWT给客户端
    ↓
客户端每次请求携带JWT
    ↓
服务器解析JWT直接获取用户信息
```

### 9.2 详细对比分析


| 特性 | **Session** | **JWT** |
|------|------------|---------|
| **存储位置** | `服务器端` | `客户端` |
| **状态管理** | `有状态` | `无状态` |
| **扩展性** | `需要Session共享` | `天然支持分布式` |
| **性能** | `需要查询存储` | `直接解析，但Token较大` |
| **安全性** | `服务器控制，较安全` | `客户端存储，需要额外防护` |
| **撤销能力** | `立即生效` | `需要黑名单机制` |
| **移动端支持** | `依赖Cookie，支持差` | `HTTP头部，支持好` |
| **网络传输** | `只传输SessionID` | `传输完整Token` |

### 9.3 适用场景选择


**选择Session的场景**：
```
✅ 传统Web应用（主要使用Cookie）
✅ 安全要求极高的系统
✅ 需要频繁撤销用户权限
✅ 单体应用架构
✅ 服务器资源充足
```

**选择JWT的场景**：
```
✅ 微服务架构
✅ 移动端应用
✅ 单页面应用（SPA）
✅ 跨域场景较多
✅ 分布式系统
✅ 减少数据库查询
```

### 9.4 混合使用策略


**最佳实践**：根据场景混合使用

```javascript
// 敏感操作使用Session
app.post('/api/transfer-money', sessionAuth, (req, res) => {
  // 资金转账等敏感操作
});

// 一般接口使用JWT
app.get('/api/user/profile', jwtAuth, (req, res) => {
  // 获取用户信息等一般操作
});

// 移动端API全部使用JWT
app.use('/api/mobile/*', jwtAuth);

// Web端混合使用
app.use('/web/admin/*', sessionAuth);  // 管理后台
app.use('/web/api/*', jwtAuth);        // 前端API
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 JWT本质：无状态的身份认证令牌，包含用户信息和签名
🔸 三部分结构：Header（算法信息）+ Payload（用户数据）+ Signature（防篡改签名）
🔸 工作原理：客户端携带JWT，服务器验证签名并解析用户信息
🔸 签名机制：HS256（对称）适合小型应用，RS256（非对称）适合分布式
🔸 安全策略：短期访问Token + 长期刷新Token + 安全存储
```

### 10.2 关键安全要点


**🔹 绝对不要犯的错误**：
```
❌ 在JWT中存储密码等敏感信息
❌ 使用弱密钥或允许none算法
❌ 将JWT作为URL参数传递
❌ 设置过长的过期时间
❌ 忽略Token的撤销机制
```

**🔹 必须遵守的安全原则**：
```
✅ 使用HTTPS传输JWT
✅ 设置合理的过期时间
✅ 实现Token刷新机制
✅ 建立Token黑名单机制
✅ 定期轮换签名密钥
```

### 10.3 实际应用指导


**选择JWT的关键因素**：
- 🎯 **应用架构**：分布式系统更适合JWT
- 🎯 **客户端类型**：移动端更适合JWT
- 🎯 **安全要求**：高安全场景需要额外防护
- 🎯 **性能要求**：减少数据库查询选择JWT

**JWT最佳实践总结**：
- 💎 **双Token设计**：访问Token短期 + 刷新Token长期
- 💎 **安全存储**：敏感Token用HttpOnly Cookie，访问Token用内存
- 💎 **自动刷新**：前端检测过期并自动刷新
- 💎 **防护策略**：算法白名单 + 强密钥 + Token黑名单

**核心记忆要点**：
- JWT是无状态认证的现代解决方案
- 三部分结构各司其职，签名确保安全
- 合理设计双Token机制是关键
- 安全使用比便利性更重要