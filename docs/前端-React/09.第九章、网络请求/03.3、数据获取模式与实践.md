---
title: 3、数据获取模式与实践
---
## 📚 目录

1. [数据获取基础概念](#1-数据获取基础概念)
2. [传统数据获取的问题](#2-传统数据获取的问题)
3. [React Query详解](#3-React-Query详解)
4. [SWR使用指南](#4-SWR使用指南)
5. [数据缓存策略详解](#5-数据缓存策略详解)
6. [高级数据获取模式](#6-高级数据获取模式)
7. [性能优化实践](#7-性能优化实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📡 数据获取基础概念


### 1.1 什么是数据获取


> **通俗理解**：数据获取就像从图书馆借书，你的React应用（读者）需要从服务器（图书馆）获取数据（书籍）来显示给用户。但是这个过程需要处理很多问题：书是否还在、借阅排队、书籍更新等。

**🔸 数据获取的本质**
```
用户操作 ──→ 发送请求 ──→ 等待响应 ──→ 处理数据 ──→ 更新界面
    ↓           ↓           ↓           ↓           ↓
点击按钮      调用API      显示加载     解析结果     重新渲染
页面加载      网络传输     loading状态   错误处理     用户看到数据
```

### 1.2 数据获取的基本需求


**💡 我们需要处理的问题：**
- **加载状态**：告诉用户数据正在获取中
- **错误处理**：网络失败时怎么办
- **数据缓存**：避免重复获取相同数据
- **数据更新**：什么时候重新获取最新数据
- **用户体验**：让等待过程不那么痛苦

```javascript
// 基本的数据获取需求示例
function UserProfile({ userId }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  // 这些都是我们需要管理的状态
  // 实际项目中会更复杂...
}
```

---

## 2. ❌ 传统数据获取的问题


### 2.1 使用useEffect获取数据的痛点


> **问题比喻**：用useEffect获取数据就像每次想看书都要跑一趟图书馆，不能记住之前借过什么书，也不知道书的内容是否已经过期。

```javascript
// 传统方式的复杂性
function UserList() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    let cancelled = false

    async function fetchUsers() {
      try {
        setLoading(true)
        const response = await fetch('/api/users')
        const data = await response.json()
        
        if (!cancelled) {
          setUsers(data)
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message)
        }
      } finally {
        if (!cancelled) {
          setLoading(false)
        }
      }
    }

    fetchUsers()

    return () => {
      cancelled = true  // 防止内存泄漏
    }
  }, [])

  // 大量重复的状态管理代码...
}
```

### 2.2 传统方式的具体问题


**🔸 重复代码问题**
```
每个组件都需要写：
├─ loading状态管理
├─ error状态管理
├─ 数据状态管理
├─ useEffect逻辑
├─ 清理函数
└─ 错误边界处理

结果：代码重复，维护困难
```

**🔸 缓存问题**
- **重复请求**：每次组件加载都重新获取数据
- **数据过期**：不知道什么时候数据需要更新
- **内存浪费**：同样的数据在多个地方存储

**🔸 用户体验问题**
- **加载闪烁**：频繁的loading状态切换
- **数据不一致**：不同组件显示不同版本的数据
- **性能低下**：不必要的网络请求

---

## 3. 🚀 React Query详解


### 3.1 什么是React Query


> **通俗比喻**：React Query就像一个智能的图书管理员，它会记住你借过什么书、书的内容什么时候更新、哪些书很热门需要提前准备，让你获取数据变得轻松愉快。

**🎯 React Query的核心价值**
```
React Query = 数据获取 + 缓存管理 + 状态同步 + 用户体验优化

解决的问题：
├─ 自动缓存数据
├─ 后台更新数据
├─ 智能重试机制
├─ 乐观更新
└─ 无限滚动支持
```

### 3.2 React Query基本使用


```javascript
import { useQuery } from '@tanstack/react-query'

// 简单到令人惊讶的数据获取
function UserProfile({ userId }) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId],           // 数据的唯一标识
    queryFn: () => fetchUser(userId),     // 获取数据的函数
    staleTime: 5 * 60 * 1000,            // 5分钟内不重新获取
  })

  if (isLoading) return <div>加载中...</div>
  if (error) return <div>出错了: {error.message}</div>
  
  return <div>用户名: {user.name}</div>
}

// 获取数据的函数
async function fetchUser(userId) {
  const response = await fetch(`/api/users/${userId}`)
  if (!response.ok) throw new Error('获取用户失败')
  return response.json()
}
```

### 3.3 React Query的智能缓存


**🧠 缓存工作原理**

> **形象理解**：React Query的缓存就像你的手机相册，会自动保存照片（数据），当你再次查看时立即显示，同时在后台检查是否有更新版本。

```
缓存生命周期：

第一次请求 ──→ 发送网络请求 ──→ 缓存数据 ──→ 显示给用户
     ↓              ↓             ↓           ↓
  无缓存数据       获取最新数据     保存到内存     立即可用

第二次请求 ──→ 立即显示缓存 ──→ 后台检查更新 ──→ 自动更新界面
     ↓              ↓             ↓             ↓
  有缓存数据       用户立即看到     静默获取新数据   无感知更新
```

**⚡ 缓存配置选项**

```javascript
const { data } = useQuery({
  queryKey: ['posts'],
  queryFn: fetchPosts,
  
  // 缓存配置
  staleTime: 5 * 60 * 1000,      // 5分钟内认为数据是新鲜的
  cacheTime: 10 * 60 * 1000,     // 10分钟后清除缓存
  refetchOnWindowFocus: true,     // 窗口获得焦点时重新获取
  refetchOnReconnect: true,       // 网络重连时重新获取
})
```

### 3.4 重新获取数据的策略


**🔄 自动重新获取**

```javascript
function PostList() {
  const { data, refetch } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
    
    // 自动重新获取的时机
    refetchOnWindowFocus: true,     // 用户回到页面时
    refetchOnReconnect: true,       // 网络重连时
    refetchInterval: 30000,         // 每30秒自动刷新
  })

  return (
    <div>
      <button onClick={() => refetch()}>
        手动刷新
      </button>
      {/* 显示文章列表 */}
    </div>
  )
}
```

> **💡 重新获取的智能之处**：React Query会根据数据的使用情况智能决定何时重新获取，用户正在查看的数据会更频繁地更新，不常用的数据则减少更新频率。

---

## 4. 🌊 SWR使用指南


### 4.1 什么是SWR


> **SWR含义**：Stale-While-Revalidate（过期时重新验证）- 先显示缓存的数据，同时在后台获取最新数据，获取完成后自动更新界面。

**🔸 SWR的设计哲学**
```
SWR策略：快速响应 + 数据新鲜

用户请求数据 ──→ 立即显示缓存 ──→ 后台获取最新 ──→ 静默更新界面
      ↓              ↓               ↓              ↓
   无等待时间       用户立即看到       保证数据准确     体验流畅
   提升用户体验     降低感知延迟       后台更新       无感知刷新
```

### 4.2 SWR基本使用


```javascript
import useSWR from 'swr'

// 简洁的数据获取
function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher)

  if (error) return <div>加载失败</div>
  if (isLoading) return <div>加载中...</div>
  
  return <div>你好 {data.name}!</div>
}

// 数据获取函数
const fetcher = (url) => fetch(url).then(res => res.json())
```

### 4.3 SWR的高级特性


**🔸 全局配置**

```javascript
import { SWRConfig } from 'swr'

function App() {
  return (
    <SWRConfig 
      value={{
        fetcher: (url) => fetch(url).then(res => res.json()),
        refreshInterval: 3000,          // 3秒自动刷新
        revalidateOnFocus: true,        // 焦点时重新验证
      }}
    >
      <Profile />
    </SWRConfig>
  )
}
```

**🔸 条件请求**

```javascript
function User({ userId }) {
  // 只有userId存在时才发送请求
  const { data } = useSWR(
    userId ? `/api/user/${userId}` : null,
    fetcher
  )
  
  return data ? <div>{data.name}</div> : <div>请选择用户</div>
}
```

### 4.4 React Query vs SWR对比


| **特性** | **React Query** | **SWR** |
|---------|----------------|---------|
| **学习难度** | `中等（功能丰富）` | `简单（API简洁）` |
| **包大小** | `较大（功能全面）` | `较小（轻量级）` |
| **缓存策略** | `复杂可配置` | `简单直观` |
| **开发者工具** | `强大的DevTools` | `基础调试信息` |
| **社区支持** | `非常活跃` | `稳定发展` |

> **💡 选择建议**：
> - **SWR**：适合快速开发、简单项目、团队新手较多
> - **React Query**：适合复杂应用、需要精细控制、团队经验丰富

---

## 5. 💾 数据缓存策略详解


### 5.1 缓存的基本概念


> **生活比喻**：数据缓存就像你的书桌抽屉，把常用的东西放在手边，需要时立即拿到，而不用每次都去远处的柜子里找。

**🔸 缓存的三个层次**
```
缓存层次结构：

内存缓存 ──→ 最快访问，应用重启后丢失
    ↓
本地存储 ──→ 持久化存储，但容量有限
    ↓
网络请求 ──→ 最慢但最准确，获取最新数据
```

### 5.2 缓存策略类型


**🎯 常见缓存策略**

```javascript
// 1. Cache First - 缓存优先
const { data } = useQuery({
  queryKey: ['static-data'],
  queryFn: fetchStaticData,
  staleTime: Infinity,        // 永远不过期
  cacheTime: Infinity,        // 永远不清除
})

// 2. Network First - 网络优先
const { data } = useQuery({
  queryKey: ['real-time-data'],
  queryFn: fetchRealTimeData,
  staleTime: 0,               // 立即过期
  refetchInterval: 1000,      // 1秒刷新一次
})

// 3. Stale While Revalidate - SWR策略
const { data } = useQuery({
  queryKey: ['user-data'],
  queryFn: fetchUserData,
  staleTime: 5 * 60 * 1000,   // 5分钟后过期
  refetchOnWindowFocus: true,  // 窗口焦点时更新
})
```

### 5.3 智能缓存配置


**⚡ 根据数据特性选择策略**

| **数据类型** | **更新频率** | **缓存策略** | **配置建议** |
|-------------|-------------|-------------|-------------|
| **用户信息** | `偶尔变化` | `中等缓存` | `staleTime: 10分钟` |
| **商品列表** | `经常变化` | `短缓存` | `staleTime: 1分钟` |
| **系统配置** | `很少变化` | `长缓存` | `staleTime: 1小时` |
| **实时数据** | `持续变化` | `无缓存` | `staleTime: 0` |

```javascript
// 智能缓存配置示例
function useOptimizedQuery(queryKey, queryFn, dataType) {
  const cacheConfig = {
    'user': { staleTime: 10 * 60 * 1000 },     // 用户数据10分钟
    'product': { staleTime: 1 * 60 * 1000 },   // 商品数据1分钟
    'config': { staleTime: 60 * 60 * 1000 },   // 配置数据1小时
    'realtime': { staleTime: 0 },              // 实时数据不缓存
  }

  return useQuery({
    queryKey,
    queryFn,
    ...cacheConfig[dataType]
  })
}
```

### 5.4 缓存失效与更新


**🔄 主动更新缓存**

```javascript
import { useQueryClient } from '@tanstack/react-query'

function UserProfile() {
  const queryClient = useQueryClient()

  const updateUser = async (userData) => {
    // 乐观更新 - 立即更新界面
    queryClient.setQueryData(['user'], userData)
    
    try {
      // 发送请求到服务器
      await updateUserAPI(userData)
    } catch (error) {
      // 失败时回滚数据
      queryClient.invalidateQueries(['user'])
    }
  }

  const refreshUser = () => {
    // 强制重新获取数据
    queryClient.invalidateQueries(['user'])
  }

  return (
    <div>
      <button onClick={refreshUser}>刷新用户信息</button>
      {/* 用户信息显示 */}
    </div>
  )
}
```

---

## 6. 🎭 高级数据获取模式


### 6.1 请求去重


> **问题场景**：多个组件同时需要相同数据时，避免发送重复的网络请求。

```javascript
// 问题：重复请求
function App() {
  return (
    <div>
      <UserProfile userId="123" />  {/* 请求用户数据 */}
      <UserAvatar userId="123" />   {/* 又请求相同用户数据 */}
      <UserPosts userId="123" />    {/* 再次请求相同用户数据 */}
    </div>
  )
}

// 解决：React Query自动去重
function UserProfile({ userId }) {
  const { data } = useQuery({
    queryKey: ['user', userId],     // 相同的queryKey
    queryFn: () => fetchUser(userId)
  })
  // 只会发送一次请求，三个组件共享结果
}
```

**💡 去重原理：**
```
请求去重机制：

组件A请求数据 ──→ 发送网络请求 ──→ 等待响应
      ↓                              ↓
组件B请求相同数据 ──→ 加入等待队列 ──→ 共享结果
      ↓                              ↓
组件C请求相同数据 ──→ 加入等待队列 ──→ 共享结果

结果：1次网络请求，3个组件都得到数据
```

### 6.2 乐观更新


> **概念解释**：乐观更新就像网购时的"立即显示购买成功"，先假设操作会成功并更新界面，如果失败再回滚。

```javascript
function PostLike({ postId }) {
  const queryClient = useQueryClient()
  
  const likeMutation = useMutation({
    mutationFn: likePost,
    
    // 乐观更新
    onMutate: async (postId) => {
      // 取消正在进行的查询
      await queryClient.cancelQueries(['post', postId])
      
      // 保存当前数据作为回滚备份
      const previousData = queryClient.getQueryData(['post', postId])
      
      // 乐观更新界面
      queryClient.setQueryData(['post', postId], old => ({
        ...old,
        likes: old.likes + 1,
        isLiked: true
      }))
      
      return { previousData }
    },
    
    // 失败时回滚
    onError: (err, postId, context) => {
      queryClient.setQueryData(['post', postId], context.previousData)
    },
    
    // 最终同步服务器数据
    onSettled: (postId) => {
      queryClient.invalidateQueries(['post', postId])
    }
  })

  return (
    <button onClick={() => likeMutation.mutate(postId)}>
      ❤️ 点赞
    </button>
  )
}
```

### 6.3 无限滚动实现


> **使用场景**：社交媒体的信息流、商品列表等需要分页加载的场景。

```javascript
function PostList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: ({ pageParam = 1 }) => fetchPosts(pageParam),
    getNextPageParam: (lastPage, pages) => {
      // 判断是否还有下一页
      return lastPage.hasMore ? pages.length + 1 : undefined
    }
  })

  return (
    <div>
      {/* 显示所有页面的数据 */}
      {data?.pages.map((page, i) => (
        <div key={i}>
          {page.posts.map(post => (
            <PostItem key={post.id} post={post} />
          ))}
        </div>
      ))}
      
      {/* 加载更多按钮 */}
      {hasNextPage && (
        <button 
          onClick={() => fetchNextPage()}
          disabled={isFetchingNextPage}
        >
          {isFetchingNextPage ? '加载中...' : '加载更多'}
        </button>
      )}
    </div>
  )
}
```

**🔄 无限滚动的工作流程：**
```
无限滚动机制：

用户滚动到底部 ──→ 自动触发加载 ──→ 获取下一页数据 ──→ 追加到现有列表
        ↓                ↓               ↓              ↓
    检测滚动位置        调用fetchNextPage    发送分页请求     更新界面显示
    判断是否接近底部     带上页码参数         返回新数据       用户继续浏览
```

---

## 7. ⚡ 性能优化实践


### 7.1 减少不必要的请求


**🎯 优化策略总览**

```javascript
// 1. 条件请求 - 只在需要时请求
function UserProfile({ userId }) {
  const { data } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    enabled: !!userId,  // 只有userId存在时才请求
  })
}

// 2. 依赖请求 - 按顺序执行
function UserPosts({ userId }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId)
  })
  
  const { data: posts } = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => fetchUserPosts(user.id),
    enabled: !!user?.id,  // 等用户数据加载完再请求文章
  })
}

// 3. 预加载 - 提前准备数据
function ProductList() {
  const queryClient = useQueryClient()
  
  const handleMouseEnter = (productId) => {
    // 鼠标悬停时预加载产品详情
    queryClient.prefetchQuery({
      queryKey: ['product', productId],
      queryFn: () => fetchProduct(productId)
    })
  }
}
```

### 7.2 智能重试机制


```javascript
const { data } = useQuery({
  queryKey: ['sensitive-data'],
  queryFn: fetchSensitiveData,
  
  // 智能重试配置
  retry: (failureCount, error) => {
    // 404错误不重试
    if (error?.status === 404) return false
    
    // 最多重试3次
    return failureCount < 3
  },
  
  retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000)
  // 指数退避：1s, 2s, 4s, 8s...最多30s
})
```

### 7.3 数据预取策略


**🚀 提升用户体验的预取技巧**

```javascript
function HomePage() {
  const queryClient = useQueryClient()
  
  useEffect(() => {
    // 页面加载时预取常用数据
    queryClient.prefetchQuery({
      queryKey: ['user-profile'],
      queryFn: fetchUserProfile,
      staleTime: 10 * 60 * 1000  // 10分钟有效
    })
    
    // 预取导航相关数据
    queryClient.prefetchQuery({
      queryKey: ['navigation-menu'],
      queryFn: fetchNavigationMenu
    })
  }, [])

  return <div>首页内容</div>
}
```

| **预取时机** | **使用场景** | **实现方式** |
|-------------|-------------|-------------|
| **页面加载时** | `常用数据预取` | `useEffect + prefetch` |
| **用户交互时** | `鼠标悬停预取` | `onMouseEnter + prefetch` |
| **路由变化前** | `页面跳转预取` | `路由守卫 + prefetch` |
| **空闲时间** | `后台预取` | `requestIdleCallback` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 数据获取本质：从服务器获取数据并在界面显示的完整流程
🔸 传统方式问题：重复代码、缓存缺失、用户体验差
🔸 React Query/SWR：现代化数据获取库，自动处理缓存和状态
🔸 缓存策略：根据数据特性选择合适的缓存配置
🔸 高级模式：请求去重、乐观更新、无限滚动
🔸 性能优化：条件请求、智能重试、数据预取
🔸 重新获取：自动刷新、手动刷新、条件刷新
```

### 8.2 关键理解要点


**🔹 为什么需要专门的数据获取库**
```
解决痛点：
├─ 避免重复的状态管理代码
├─ 提供智能的缓存机制
├─ 优化用户体验和性能
├─ 处理复杂的数据同步场景
└─ 减少开发者的心智负担
```

**🔹 缓存策略的选择原则**
```
数据特性决定缓存策略：
├─ 静态数据：长时间缓存
├─ 用户数据：中等时间缓存
├─ 实时数据：短时间缓存或不缓存
├─ 关键数据：保守缓存策略
└─ 辅助数据：激进缓存策略
```

**🔹 性能优化的核心思路**
```
减少不必要的网络请求：
├─ 智能缓存避免重复请求
├─ 请求去重合并相同请求
├─ 条件请求只在需要时发送
├─ 预取策略提前准备数据
└─ 乐观更新提升响应速度
```

### 8.3 实际应用指导


**💼 技术选择建议：**
- **小项目/学习**：从SWR开始，API简洁易懂
- **中大型项目**：使用React Query，功能强大
- **现有项目改造**：逐步引入，替换useEffect数据获取

**🎯 最佳实践原则：**
- **查询键设计**：使用数组形式，包含所有依赖参数
- **错误处理**：提供友好的错误界面和重试机制
- **加载状态**：给用户明确的反馈，避免空白页面
- **缓存配置**：根据数据特性合理设置缓存时间

**🔧 调试技巧：**
- **React Query DevTools**：可视化查看缓存状态
- **网络面板**：检查实际的网络请求
- **性能监控**：关注首屏加载时间和用户交互响应

**核心记忆口诀**：
```
数据获取有套路，缓存管理是核心
Query和SWR二选一，告别useEffect苦
智能重试保稳定，乐观更新体验优
预取数据提性能，去重机制省流量
```