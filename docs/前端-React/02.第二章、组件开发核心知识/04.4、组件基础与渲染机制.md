---
title: 4、组件基础与渲染机制
---
## 📚 目录

1. [组件入门：第一个函数组件](#1-组件入门第一个函数组件)
2. [组件嵌套与组件树](#2-组件嵌套与组件树)
3. [渲染机制：React 17 vs React 18](#3-渲染机制react-17-vs-react-18)
4. [虚拟DOM：React的核心原理](#4-虚拟domreact的核心原理)
5. [组件渲染流程与更新机制](#5-组件渲染流程与更新机制)
6. [React严格模式](#6-react严格模式)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🚀 组件入门：第一个函数组件


### 1.1 什么是组件？


> 💡 **通俗理解**：组件就像搭积木的小方块，每个小方块都有自己的功能，可以组合成复杂的界面

**组件的本质**：
- 就是一个**JavaScript函数**
- 这个函数**返回JSX**（看起来像HTML的代码）
- 可以**重复使用**、**组合拼装**

```javascript
// 🎯 最简单的组件 - 就是一个返回JSX的函数
function Welcome() {
  return <h1>你好，这是我的第一个组件！</h1>;
}
```

### 1.2 JSX是什么？


> 📖 **概念**：JSX = JavaScript + XML，让你在JavaScript中写类似HTML的代码

**为什么要用JSX？**
```javascript
// ❌ 不用JSX - 很麻烦
function Welcome() {
  return React.createElement('h1', null, '你好世界');
}

// ✅ 用JSX - 直观易懂
function Welcome() {
  return <h1>你好世界</h1>;
}
```

### 1.3 创建组件的规则


> ⚠️ **重要规则**：
> - 组件名必须**大写字母开头**（React靠这个区分组件和普通HTML标签）
> - 函数必须**返回JSX**
> - 一个组件只能**返回一个根元素**

```javascript
// ✅ 正确写法
function MyComponent() {
  return (
    <div>
      <h1>标题</h1>
      <p>内容</p>
    </div>
  );
}

// ❌ 错误写法 - 返回了多个根元素
function WrongComponent() {
  return (
    <h1>标题</h1>
    <p>内容</p>  // 这样会报错
  );
}
```

---

## 2. 🌳 组件嵌套与组件树


### 2.1 组件嵌套的概念


> 💡 **通俗理解**：就像俄罗斯套娃，大组件里面套小组件，小组件里面还可以套更小的组件

```
页面组件树结构：
        App
       /   \
   Header   Main
    |      /   \
   Logo  Content Footer
```

### 2.2 实际组件嵌套示例


```javascript
// 📁 小组件 - 按钮
function Button() {
  return <button>点击我</button>;
}

// 📁 小组件 - 标题
function Title() {
  return <h1>欢迎使用React</h1>;
}

// 📁 大组件 - 把小组件组合起来
function App() {
  return (
    <div>
      <Title />     {/* 使用标题组件 */}
      <Button />    {/* 使用按钮组件 */}
      <Button />    {/* 可以多次使用 */}
    </div>
  );
}
```

### 2.3 组件树的好处


```
🎯 组件化的核心优势：

┌─ 复用性 ─────────────────┐
│ 写一次，到处使用         │
│ Button组件可以用100次    │
└─────────────────────────┘

┌─ 维护性 ─────────────────┐
│ 修改一个组件，全局生效   │
│ 只需要改Button组件的代码 │
└─────────────────────────┘

┌─ 协作性 ─────────────────┐
│ 不同人开发不同组件       │
│ 像搭积木一样组装页面     │
└─────────────────────────┘
```

---

## 3. 🔄 渲染机制：React 17 vs React 18


### 3.1 React 17的渲染方式


> 📖 **概念**：ReactDOM.render 是把React组件"画"到网页上的工具

```javascript
// React 17 的渲染方式
import ReactDOM from 'react-dom';

function App() {
  return <h1>Hello React 17</h1>;
}

// 把App组件渲染到id为'root'的DOM元素中
ReactDOM.render(<App />, document.getElementById('root'));
```

**渲染过程图解：**
```
JavaScript代码 → ReactDOM.render → 浏览器页面
     App组件   →   渲染引擎     →   显示内容
```

### 3.2 React 18的新渲染方式


> 🚀 **升级**：React 18引入了createRoot，支持并发渲染（性能更好）

```javascript
// React 18 的新渲染方式
import { createRoot } from 'react-dom/client';

function App() {
  return <h1>Hello React 18</h1>;
}

// 先创建根节点，再渲染
const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

### 3.3 两种方式的对比


| 特性 | **React 17** | **React 18** |
|------|-------------|-------------|
| 🔧 **API方式** | `ReactDOM.render()` | `createRoot().render()` |
| ⚡ **性能** | `同步渲染` | `并发渲染（更快）` |
| 🔄 **更新** | `阻塞式更新` | `可中断更新` |
| 📱 **用户体验** | `可能卡顿` | `更流畅` |

> 💡 **简单理解**：React 18就像升级版的渲染引擎，能让页面更流畅

---

## 4. 🎭 虚拟DOM：React的核心原理


### 4.1 什么是虚拟DOM？


> 💡 **通俗解释**：虚拟DOM就是用JavaScript对象来"模拟"真实的HTML结构

**为什么需要虚拟DOM？**
```
问题：直接操作真实DOM很慢
解决：先在内存中用JS对象"演练"，再一次性更新真实DOM

就像：
🎬 拍电影先写剧本（虚拟DOM）
📺 再根据剧本拍摄（真实DOM）
```

### 4.2 虚拟DOM的结构


```javascript
// JSX代码
<div className="container">
  <h1>标题</h1>
  <p>内容</p>
</div>

// 对应的虚拟DOM（JavaScript对象）
{
  type: 'div',
  props: {
    className: 'container',
    children: [
      {
        type: 'h1',
        props: { children: '标题' }
      },
      {
        type: 'p', 
        props: { children: '内容' }
      }
    ]
  }
}
```

### 4.3 虚拟DOM的工作流程


```
虚拟DOM工作原理：

步骤1: 写JSX代码
      ↓
步骤2: React把JSX转成虚拟DOM
      ↓
步骤3: 虚拟DOM对比（找不同）
      ↓ 
步骤4: 只更新变化的部分到真实DOM
```

**流程图示：**
```
旧虚拟DOM  ←→  新虚拟DOM
    ↓             ↓
  对比差异（Diff算法）
    ↓
只更新变化部分 → 真实DOM → 浏览器显示
```

---

## 5. 🔄 组件渲染流程与更新机制


### 5.1 初次渲染流程


> 📖 **概念**：初次渲染就是第一次把组件显示到页面上

```
初次渲染的完整流程：

组件代码 → 创建虚拟DOM → 生成真实DOM → 插入页面
   App   →   JS对象    →   HTML元素  →  用户看到
```

### 5.2 更新渲染流程


> 🔄 **重点**：当数据变化时，React会重新渲染组件

```javascript
// 当状态改变时的渲染流程
function Counter() {
  const [count, setCount] = useState(0);
  
  // 点击按钮 → count变化 → 触发重新渲染
  return (
    <div>
      <p>计数：{count}</p>
      <button onClick={() => setCount(count + 1)}>
        点击+1
      </button>
    </div>
  );
}
```

**更新流程图：**
```
状态改变 → 重新执行组件函数 → 生成新虚拟DOM → Diff对比 → 更新真实DOM
   ↑                                                    ↓
   └──────────────── 用户看到更新后的页面 ←──────────────────┘
```

### 5.3 Diff算法简介


> 💡 **通俗理解**：Diff算法就是"找不同"的算法，专门找出新旧虚拟DOM的差异

**Diff算法的三个核心规则：**

```
🔸 只比较同层级
   不会跨层级比较，提高效率
   
🔸 不同类型直接替换
   <div> 变成 <span>，直接替换整个子树
   
🔸 同类型对比属性
   只更新变化的属性，保留其他属性
```

### 5.4 批量更新机制


> ⚡ **性能优化**：React会把多个更新"打包"一起处理，避免频繁渲染

```javascript
function BatchDemo() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  function handleClick() {
    setCount(1);      // 更新1
    setCount(2);      // 更新2  
    setName('张三');   // 更新3
    
    // React会把这3个更新打包成1次渲染
    // 而不是渲染3次
  }
  
  return <div>批量更新示例</div>;
}
```

---

## 6. 🔍 React严格模式


### 6.1 什么是严格模式？


> 🛡️ **概念**：React.StrictMode是开发时的"安全检查工具"，帮你发现潜在问题

```javascript
// 使用严格模式包裹组件
import { StrictMode } from 'react';

function App() {
  return (
    <StrictMode>
      <MyComponent />
    </StrictMode>
  );
}
```

### 6.2 严格模式的作用


> ⚠️ **注意**：严格模式只在开发环境生效，打包后自动失效

**严格模式会帮你检查：**

```
┌─ 检查项目 ──────────────────┐
│ ✅ 不安全的生命周期方法      │
│ ✅ 过时的API使用           │
│ ✅ 意外的副作用            │
│ ✅ 不推荐的findDOMNode     │
│ ✅ 废弃的context API      │
└────────────────────────────┘
```

### 6.3 严格模式的"双重渲染"


> 💡 **重要特性**：严格模式会故意执行组件两次，帮你发现副作用问题

```javascript
function MyComponent() {
  console.log('组件渲染了'); // 严格模式下会打印两次
  
  return <div>我的组件</div>;
}

// 开发环境下的控制台输出：
// 组件渲染了
// 组件渲染了  ← 严格模式故意执行两次
```

**为什么要双重渲染？**
- 帮你发现**不纯净的函数**
- 确保组件多次执行结果一致
- 提前发现潜在的bug

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 组件本质：返回JSX的JavaScript函数
🔸 JSX语法：在JS中写HTML的语法糖
🔸 组件嵌套：大组件包含小组件，形成组件树
🔸 渲染机制：React 17用render，React 18用createRoot  
🔸 虚拟DOM：用JS对象模拟DOM，提高性能
🔸 Diff算法：找出新旧虚拟DOM的差异，最小化更新
🔸 批量更新：多个状态更新合并成一次渲染
🔸 严格模式：开发时的检查工具，帮助发现问题
```

### 7.2 关键理解要点


**🔹 组件化思想**
```
把复杂界面拆分成小组件：
- 每个组件只负责一个功能
- 组件可以重复使用
- 像搭积木一样组装页面
```

**🔹 虚拟DOM的价值**
```
为什么比直接操作DOM快？
- 在内存中操作JS对象很快
- 批量更新减少DOM操作次数
- Diff算法只更新必要的部分
```

**🔹 React的核心哲学**
```
数据驱动视图：
状态变化 → 触发重新渲染 → 更新界面
不需要手动操作DOM
```

### 7.3 学习进度检查


**✅ 基础掌握要求：**
- [ ] 能写出简单的函数组件
- [ ] 理解JSX语法规则
- [ ] 会使用React 18的createRoot
- [ ] 明白虚拟DOM的基本概念
- [ ] 了解组件嵌套的方式

**🚀 进阶理解目标：**
- [ ] 深入理解Diff算法原理
- [ ] 掌握批量更新机制
- [ ] 熟练使用严格模式调试
- [ ] 能解释React渲染流程

### 7.4 实践建议


> 🎯 **学习方法**：
> 1. **多写代码**：理论+实践才能真正掌握
> 2. **观察渲染**：用React DevTools查看组件树
> 3. **对比版本**：试试React 17和18的不同
> 4. **开启严格模式**：养成好的开发习惯

**核心记忆**：
- 组件就是返回JSX的函数
- 虚拟DOM让React更新更快
- 状态变化自动触发重新渲染
- 严格模式是开发好帮手