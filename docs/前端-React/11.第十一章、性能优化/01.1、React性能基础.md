---
title: 1、React性能基础
---
## 📚 目录

1. [React性能优化概述](#1-React性能优化概述)
2. [什么是不必要的重新渲染](#2-什么是不必要的重新渲染)
3. [React.memo组件缓存机制](#3-React-memo组件缓存机制)
4. [虚拟DOM的性能特点](#4-虚拟DOM的性能特点)
5. [PureComponent与浅比较](#5-PureComponent与浅比较)
6. [组件拆分策略](#6-组件拆分策略)
7. [性能优化时机选择](#7-性能优化时机选择)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 React性能优化概述


### 1.1 为什么要关心性能


**日常问题场景：**
```
用户体验问题：
✅ 页面加载慢，用户等待时间长
✅ 输入框输入时卡顿，用户感觉不流畅
✅ 列表滚动时掉帧，影响交互体验
✅ 手机端运行缓慢，功耗增加
```

**性能优化的核心目标：**
- 🚀 **提升用户体验** - 让应用响应更快速
- 💾 **节省资源消耗** - 减少CPU和内存占用
- 📱 **移动端友好** - 在低性能设备上也能流畅运行
- ⚡ **优化加载速度** - 缩短首屏时间

### 1.2 React性能问题的根源


**问题本质：** React默认情况下，父组件更新时会让所有子组件也重新渲染

```
简单比喻：
就像一个大家庭，爸爸换了件衣服，
结果全家人都要重新打扮一遍，
这显然是浪费的！

我们希望的是：
只有需要改变的人才重新打扮，
其他人保持原样就好。
```

**性能消耗发生在哪里：**
```
1. 组件重新计算 ← 不必要的逻辑执行
2. 虚拟DOM对比 ← 额外的对比计算  
3. 真实DOM更新 ← 最昂贵的操作
```

---

## 2. ⚠️ 什么是不必要的重新渲染


### 2.1 重新渲染的触发条件


**React什么时候会重新渲染组件：**
```
📌 状态(state)发生变化
📌 接收的属性(props)发生变化  
📌 父组件重新渲染
📌 Context值发生变化
```

### 2.2 问题示例演示


**经典的性能浪费场景：**
```jsx
// 父组件
function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        点击次数: {count}
      </button>
      
      {/* 这些组件完全不需要重新渲染！ */}
      <Header />           {/* 静态头部 */}
      <UserProfile />      {/* 用户信息 */}
      <Footer />          {/* 静态底部 */}
    </div>
  );
}
```

**问题分析：**
```
当用户点击按钮时发生了什么：

1. count状态变化 → App组件重新渲染 ✅ (必要的)
2. Header重新渲染 ❌ (不必要，因为它没有变化)
3. UserProfile重新渲染 ❌ (不必要，用户信息没变)  
4. Footer重新渲染 ❌ (不必要，底部内容没变)

结果：1次有用的更新，3次无用的浪费！
```

### 2.3 如何识别不必要的渲染


**使用React开发工具检测：**
```
步骤1️⃣：安装React Developer Tools浏览器插件
步骤2️⃣：打开开发者工具，找到"Profiler"标签
步骤3️⃣：录制用户操作，查看哪些组件在重新渲染
步骤4️⃣：分析是否真的需要这些渲染
```

**简单的日志检测方法：**
```jsx
function MyComponent(props) {
  console.log('MyComponent渲染了！', props);
  return <div>组件内容</div>;
}

// 如果控制台频繁输出这条日志，
// 说明组件可能在不必要地重新渲染
```

---

## 3. 🧠 React.memo组件缓存机制


### 3.1 React.memo是什么


**通俗解释：**
```
React.memo就像一个"记忆高手"：

第一次见到某个props时：
"我记住这个样子了" → 正常渲染组件

下次遇到相同的props时：  
"咦，这个我见过！" → 直接返回之前的结果

只有props真的变了：
"这次不一样了" → 重新渲染组件
```

### 3.2 基本使用方法


**语法格式：**
```jsx
// 方式1：包装现有组件
const MyComponent = React.memo(function MyComponent(props) {
  return <div>{props.name}</div>;
});

// 方式2：直接定义
const MyComponent = React.memo((props) => {
  return <div>{props.name}</div>;
});
```

**实际应用示例：**
```jsx
// 优化前：每次父组件更新都会重新渲染
function UserCard({ user }) {
  console.log('UserCard渲染了');
  return (
    <div className="user-card">
      <img src={user.avatar} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}

// 优化后：只有user属性变化时才重新渲染
const UserCard = React.memo(function UserCard({ user }) {
  console.log('UserCard渲染了');
  return (
    <div className="user-card">
      <img src={user.avatar} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
});
```

### 3.3 自定义比较函数


**什么时候需要自定义比较：**
```jsx
// 问题场景：深层对象比较
const UserCard = React.memo(function UserCard({ user, settings }) {
  return <div>用户信息</div>;
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return prevProps.user.id === nextProps.user.id &&
         prevProps.settings.theme === nextProps.settings.theme;
});
```

**注意事项：**
> ⚠️ **重要提醒**
> 
> 自定义比较函数返回`true`表示"props相同，不需要重新渲染"
> 返回`false`表示"props不同，需要重新渲染"
> 这和shouldComponentUpdate是相反的！

---

## 4. 🌟 虚拟DOM的性能特点


### 4.1 虚拟DOM是如何工作的


**虚拟DOM工作流程：**
```
真实场景类比：
虚拟DOM = 建筑设计图纸
真实DOM = 实际建筑

工作流程：
1. 修改设计图纸 (更新虚拟DOM) ← 很快
2. 对比新旧图纸 (Diff算法) ← 比较快  
3. 找出差异部分 (找到变化) ← 比较快
4. 只修改建筑的差异部分 (更新真实DOM) ← 最慢但最少
```

**虚拟DOM性能优势：**
```
传统方式 vs React方式

传统jQuery方式：
用户操作 → 直接操作DOM → 浏览器重绘重排
         (每次操作都很慢)

React方式：  
用户操作 → 更新虚拟DOM → 批量对比 → 最小化DOM更新
         (快)        (快)      (慢但最少)
```

### 4.2 批量更新机制


**React的智能批量处理：**
```jsx
function handleClick() {
  // 在React中，这些状态更新会被批量处理
  setCount(count + 1);      // 不会立即渲染
  setName('新名字');         // 不会立即渲染  
  setEmail('new@email.com'); // 不会立即渲染
  
  // React会把这3个更新合并成1次渲染
}

// 相当于：
// 收集所有更新 → 一次性处理 → 一次DOM更新
```

**为什么批量更新更快：**
```
不使用批量更新：
更新1 → DOM操作1 → 重绘1
更新2 → DOM操作2 → 重绘2  
更新3 → DOM操作3 → 重绘3
总计：3次DOM操作，3次重绘

使用批量更新：
更新1 + 更新2 + 更新3 → 一次DOM操作 → 一次重绘
总计：1次DOM操作，1次重绘
```

### 4.3 渲染性能分析


**性能消耗对比：**

| 操作类型 | 相对耗时 | 说明 |
|---------|---------|------|
| JavaScript计算 | ⭐ | 很快 |
| 虚拟DOM对比 | ⭐⭐ | 较快 |
| 真实DOM更新 | ⭐⭐⭐⭐⭐ | 很慢 |
| 浏览器重绘重排 | ⭐⭐⭐⭐⭐⭐ | 最慢 |

**优化策略：**
```
🎯 减少不必要的组件渲染 (减少JS计算)
🎯 减少虚拟DOM对比次数 (使用memo)
🎯 减少真实DOM操作 (React自动优化)
🎯 减少重绘重排 (合理使用CSS)
```

---

## 5. 🔄 PureComponent与浅比较


### 5.1 什么是PureComponent


**PureComponent的作用：**
```
PureComponent = Component + 自动浅比较

普通组件：
每次父组件更新 → 子组件就重新渲染

PureComponent：  
父组件更新 → 检查props和state是否变化 → 变化了才重新渲染
```

**类组件中的使用：**
```jsx
// 普通组件
class UserCard extends Component {
  render() {
    return <div>{this.props.user.name}</div>;
  }
}

// PureComponent (自动优化)
class UserCard extends PureComponent {
  render() {
    return <div>{this.props.user.name}</div>;
  }
}
```

### 5.2 什么是浅比较


**浅比较vs深比较的区别：**
```jsx
// 示例数据
const user1 = { name: '张三', age: 25 };
const user2 = { name: '张三', age: 25 };
const user3 = user1;

// 浅比较 (PureComponent和React.memo默认行为)
user1 === user2  // false (不同对象引用)
user1 === user3  // true  (相同引用)

// 深比较 (需要自定义实现)  
deepEqual(user1, user2)  // true (内容相同)
```

**浅比较的局限性：**
```jsx
// 问题场景
function App() {
  const [user, setUser] = useState({ name: '张三', age: 25 });
  
  const handleUpdateAge = () => {
    // ❌ 错误：直接修改对象
    user.age = 26;
    setUser(user);  // 浅比较认为没变化！
    
    // ✅ 正确：创建新对象  
    setUser({ ...user, age: 26 });  // 浅比较能检测到变化
  };
  
  return <UserCard user={user} />;  // PureComponent包装的组件
}
```

### 5.3 useMemo结合使用


**解决复杂数据的比较问题：**
```jsx
function UserList({ users, filter }) {
  // 使用useMemo避免每次都创建新的数组
  const filteredUsers = useMemo(() => {
    return users.filter(user => user.name.includes(filter));
  }, [users, filter]);  // 只有users或filter变化时才重新计算
  
  return (
    <div>
      {filteredUsers.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

**useMemo的使用场景：**
```
✅ 计算结果需要传递给子组件时
✅ 复杂的数据转换或过滤操作
✅ 避免在每次渲染时创建新对象/数组

❌ 简单的计算(如基本运算)
❌ 依赖项频繁变化的场景
```

---

## 6. 🧩 组件拆分策略


### 6.1 为什么要拆分组件


**拆分组件的核心好处：**
```
性能角度：
🚀 减少重新渲染的范围
🚀 让变化局部化，不影响其他部分
🚀 更容易使用React.memo优化

维护角度：
📝 代码更清晰，职责单一
📝 更容易测试和调试
📝 更好的代码复用性
```

### 6.2 拆分策略与原则


**拆分原则：**
```
原则1️⃣：按变化频率拆分
  频繁变化的部分 → 独立组件
  稳定不变的部分 → 独立组件

原则2️⃣：按功能职责拆分  
  每个组件只负责一件事
  
原则3️⃣：按数据依赖拆分
  使用相同数据的部分 → 放在一起
  使用不同数据的部分 → 分开
```

**实际拆分示例：**
```jsx
// ❌ 拆分前：一个大组件
function Dashboard() {
  const [userInfo, setUserInfo] = useState({});
  const [todos, setTodos] = useState([]);
  const [weather, setWeather] = useState({});
  
  return (
    <div>
      {/* 用户信息 - 很少变化 */}
      <div className="user-section">
        <img src={userInfo.avatar} />
        <h2>{userInfo.name}</h2>
      </div>
      
      {/* 待办列表 - 频繁变化 */}
      <div className="todos-section">
        {todos.map(todo => (
          <div key={todo.id}>{todo.text}</div>
        ))}
      </div>
      
      {/* 天气信息 - 偶尔变化 */}
      <div className="weather-section">
        <span>{weather.temperature}°C</span>
        <span>{weather.description}</span>
      </div>
    </div>
  );
}

// ✅ 拆分后：多个小组件
function Dashboard() {
  const [userInfo, setUserInfo] = useState({});
  const [todos, setTodos] = useState([]);
  const [weather, setWeather] = useState({});
  
  return (
    <div>
      <UserSection user={userInfo} />     {/* 很少变化，可用memo */}
      <TodosList todos={todos} />         {/* 频繁变化 */}
      <WeatherSection weather={weather} /> {/* 偶尔变化，可用memo */}
    </div>
  );
}

// 各自独立，互不影响
const UserSection = React.memo(({ user }) => (
  <div className="user-section">
    <img src={user.avatar} />
    <h2>{user.name}</h2>
  </div>
));

const WeatherSection = React.memo(({ weather }) => (
  <div className="weather-section">
    <span>{weather.temperature}°C</span>
    <span>{weather.description}</span>
  </div>
));
```

### 6.3 key属性优化


**key的作用机制：**
```jsx
// ❌ 没有key或key不稳定
{users.map((user, index) => (
  <UserCard key={index} user={user} />  // 用index做key有问题
))}

// ✅ 使用稳定唯一的key
{users.map(user => (
  <UserCard key={user.id} user={user} />  // 用唯一ID做key
))}
```

**key优化的重要性：**
```
场景：在列表开头插入新项目

使用index做key：
旧：[A, B, C]   key: [0, 1, 2]
新：[X, A, B, C] key: [0, 1, 2, 3]

React认为：
- key=0: A→X (需要更新)
- key=1: B→A (需要更新)  
- key=2: C→B (需要更新)
- key=3: 新增C (需要创建)
结果：4次操作！

使用ID做key：
旧：[A, B, C]   key: [a, b, c]
新：[X, A, B, C] key: [x, a, b, c]

React认为：
- key=x: 新增X (需要创建)
- key=a,b,c: 位置移动 (很快)
结果：1次创建 + 3次移动！
```

---

## 7. ⏰ 性能优化时机选择


### 7.1 什么时候需要优化


**优化时机判断：**
```
🔍 先测量，再优化
  ↓
用户是否感觉到卡顿？
  ↓ Yes
使用Performance工具分析
  ↓
找到真正的性能瓶颈
  ↓  
针对性优化
  ↓
再次测量验证效果
```

**不需要过早优化的情况：**
```
❌ 组件很简单，渲染很快
❌ 用户交互不频繁
❌ 数据量很小
❌ 页面加载后基本不变化

✅ 需要优化的信号：
- 输入时有明显延迟
- 滚动时掉帧卡顿
- 点击按钮响应慢
- 移动端发热严重
```

### 7.2 性能优化检查清单


**基础检查清单：**
```
□ 是否有不必要的重新渲染？
□ 列表组件是否使用了正确的key？
□ 是否有复杂计算可以用useMemo缓存？
□ 是否有函数可以用useCallback缓存？
□ 静态组件是否使用了React.memo？
□ 是否避免了在render中创建新对象？
```

**进阶检查清单：**
```
□ 图片是否进行了懒加载？
□ 长列表是否使用了虚拟滚动？
□ 是否进行了代码分割？
□ 是否使用了Web Workers处理复杂计算？
□ 是否优化了网络请求？
```

### 7.3 性能测试方法


**简单的性能测试：**
```jsx
// 渲染时间测试
function MyComponent() {
  const startTime = performance.now();
  
  useEffect(() => {
    const endTime = performance.now();
    console.log(`组件渲染耗时: ${endTime - startTime}ms`);
  });
  
  return <div>组件内容</div>;
}

// 重渲染次数统计
function MyComponent(props) {
  const renderCount = useRef(0);
  renderCount.current += 1;
  
  console.log(`组件渲染次数: ${renderCount.current}`);
  
  return <div>组件内容</div>;
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 性能问题根源：不必要的重新渲染
🔸 React.memo：组件缓存机制，props相同时跳过渲染
🔸 虚拟DOM：批量更新，减少真实DOM操作
🔸 浅比较：比较引用而非内容，需要注意对象不可变性
🔸 组件拆分：按变化频率和功能职责拆分
🔸 优化时机：先测量再优化，避免过早优化
```

### 8.2 关键理解要点


**🔹 性能优化的核心思路**
```
目标：减少不必要的工作
方法：
1. 减少重新渲染的组件数量 (memo)
2. 减少重新渲染的频率 (合理拆分)
3. 减少每次渲染的工作量 (useMemo)
```

**🔹 React.memo使用要点**
```
适用场景：
✅ 纯展示组件
✅ props变化不频繁的组件
✅ 渲染成本较高的组件

不适用场景：
❌ props频繁变化的组件  
❌ 很简单的组件
❌ 已经很快的组件
```

**🔹 组件拆分的智慧**
```
拆分原则：
- 变化的部分独立出来
- 稳定的部分独立出来
- 让影响范围最小化

记忆口诀：
"变化隔离，稳定缓存，影响最小"
```

### 8.3 实际应用指导


**性能优化步骤：**
```
步骤1️⃣：发现问题 (用户反馈 + 性能工具)
步骤2️⃣：定位瓶颈 (React DevTools Profiler)  
步骤3️⃣：选择方案 (memo/useMemo/拆分)
步骤4️⃣：实施优化 (逐步优化，小步快跑)
步骤5️⃣：验证效果 (再次测量，对比数据)
```

**常用优化模式：**
```jsx
// 模式1：静态组件缓存
const Header = React.memo(() => <header>网站头部</header>);

// 模式2：复杂计算缓存  
const expensiveValue = useMemo(() => 
  computeExpensiveValue(data), [data]
);

// 模式3：回调函数缓存
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);

// 模式4：组件拆分
function App() {
  return (
    <>
      <StaticHeader />     {/* 静态部分 */}
      <DynamicContent />   {/* 动态部分 */}
      <StaticFooter />     {/* 静态部分 */}
    </>
  );
}
```

**核心记忆要点：**
- React性能优化的本质是减少不必要的工作
- React.memo是最基础也是最重要的优化工具
- 组件拆分是性能优化的基础策略
- 先测量再优化，避免过早优化
- 性能优化要循序渐进，小步快跑