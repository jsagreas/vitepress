---
title: 1、条件渲染写法大全
---
## 📚 目录

1. [条件渲染的基本概念](#1-条件渲染的基本概念)
2. [基础条件渲染方法](#2-基础条件渲染方法)
3. [高级条件渲染技巧](#3-高级条件渲染技巧)
4. [渲染规则深度解析](#4-渲染规则深度解析)
5. [性能优化与最佳实践](#5-性能优化与最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 条件渲染的基本概念


### 1.1 什么是条件渲染


**简单理解**：就像我们生活中的"如果...那么..."一样
```
生活中：如果下雨，就带伞
React中：如果用户登录了，就显示欢迎页面
```

**`[核心概念]`** 条件渲染就是**根据不同情况决定显示什么内容**，让页面变得智能和动态。

### 1.2 为什么需要条件渲染


想象一个登录网站的场景：
```
用户状态图示：
┌─────────────┐    登录成功    ┌─────────────┐
│  未登录状态  │ ──────────→  │  已登录状态  │
│ 显示登录框   │              │ 显示用户信息 │
└─────────────┘              └─────────────┘
```

**实际需求场景**：
- 🔐 **权限控制** - 登录用户看到完整功能，游客只能看部分内容
- 📱 **响应式显示** - 手机显示简化菜单，电脑显示完整导航
- ⚡ **加载状态** - 数据加载时显示转圈，加载完显示内容
- ❌ **错误处理** - 正常时显示内容，出错时显示错误信息

### 1.3 条件渲染的本质


**`[重要API]`** 在React中，条件渲染就是**让JavaScript的条件语句控制JSX的显示**

```jsx
// 基本思路
function App() {
  const isLoggedIn = true; // 这是条件
  
  return (
    <div>
      {isLoggedIn ? <h1>欢迎回来！</h1> : <h1>请先登录</h1>}
    </div>
  );
}
```

---

## 2. 🔧 基础条件渲染方法


### 2.1 if/else 语句渲染


**适用场景**：逻辑复杂，需要多行代码处理的情况

```jsx
function UserGreeting({ user }) {
  // 方法1：return分支
  if (user.isVip) {
    return <h1>🌟 VIP用户：{user.name}</h1>;
  }
  
  if (user.isLogin) {
    return <h1>👋 你好：{user.name}</h1>;
  }
  
  return <h1>🔐 请先登录</h1>;
}
```

**优势**：
- ✅ 逻辑清晰，容易理解
- ✅ 适合复杂的多分支判断
- ✅ 每个分支可以有独立的处理逻辑

### 2.2 三元运算符（? :）渲染


**适用场景**：简单的二选一情况

```jsx
function MessageBox({ hasNewMessage }) {
  return (
    <div>
      {hasNewMessage ? (
        <span style={{color: 'red'}}>📩 您有新消息</span>
      ) : (
        <span style={{color: 'gray'}}>📭 暂无新消息</span>
      )}
    </div>
  );
}
```

**记忆技巧**：`条件 ? 真的显示这个 : 假的显示那个`

### 2.3 逻辑与（&&）操作符渲染


**适用场景**：只在某个条件为真时才显示，否则什么都不显示

```jsx
function NotificationBadge({ count }) {
  return (
    <div>
      <span>消息</span>
      {count > 0 && <span className="badge">{count}</span>}
    </div>
  );
}
```

**工作原理**：
```
count > 0 && <组件>
│
├─ 如果 count > 0 为 true → 显示组件
└─ 如果 count > 0 为 false → 什么都不显示
```

### 2.4 逻辑或（||）操作符渲染


**适用场景**：提供默认值或备选内容

```jsx
function UserAvatar({ user }) {
  return (
    <div>
      <img src={user.avatar || '/default-avatar.png'} />
      <span>{user.name || '匿名用户'}</span>
    </div>
  );
}
```

**理解要点**：`原值 || 备选值` - 如果原值存在就用原值，不存在就用备选值

---

## 3. 🚀 高级条件渲染技巧


### 3.1 可选链（?.）与空值处理


**问题场景**：当数据还没加载完成时避免报错

```jsx
function UserProfile({ userData }) {
  return (
    <div>
      {/* ❌ 危险写法：如果userData是null会报错 */}
      {/* <h1>{userData.profile.name}</h1> */}
      
      {/* ✅ 安全写法：使用可选链 */}
      <h1>{userData?.profile?.name || '用户名加载中...'}</h1>
      
      {/* 显示头像，如果没有就显示默认图片 */}
      <img src={userData?.profile?.avatar || '/loading.gif'} />
    </div>
  );
}
```

**可选链工作流程**：
```
userData?.profile?.name
│
├─ userData存在吗？
│  ├─ 是 → 检查profile存在吗？
│  │  ├─ 是 → 检查name存在吗？
│  │  │  ├─ 是 → 返回name的值
│  │  │  └─ 否 → 返回undefined
│  │  └─ 否 → 返回undefined
│  └─ 否 → 返回undefined
```

### 3.2 多条件渲染


**场景**：根据用户状态显示不同的界面

```jsx
function Dashboard({ user }) {
  // 渲染函数，让逻辑更清晰
  const renderUserStatus = () => {
    if (!user) return <div>🔄 加载中...</div>;
    if (user.isBanned) return <div>❌ 账户已被封禁</div>;
    if (!user.isVerified) return <div>📧 请先验证邮箱</div>;
    if (user.isVip) return <div>👑 VIP专享功能</div>;
    return <div>👤 普通用户面板</div>;
  };

  return (
    <div className="dashboard">
      <h1>用户中心</h1>
      {renderUserStatus()}
    </div>
  );
}
```

### 3.3 动态组件选择


**场景**：根据类型显示不同的组件

```jsx
function MediaViewer({ mediaType, src }) {
  // 组件映射表
  const MediaComponents = {
    image: ({ src }) => <img src={src} alt="图片" />,
    video: ({ src }) => <video src={src} controls />,
    audio: ({ src }) => <audio src={src} controls />
  };
  
  // 动态选择组件
  const SelectedComponent = MediaComponents[mediaType];
  
  return (
    <div>
      {SelectedComponent ? (
        <SelectedComponent src={src} />
      ) : (
        <div>⚠️ 不支持的媒体类型</div>
      )}
    </div>
  );
}
```

### 3.4 阻止组件渲染


**概念**：让组件完全不显示在页面上

```jsx
function AlertMessage({ show, message, type }) {
  // 如果不需要显示，直接返回null
  if (!show) return null;
  
  return (
    <div className={`alert alert-${type}`}>
      {message}
    </div>
  );
}
```

**`[重要概念]`** 返回 `null` 的组件**完全不会渲染**，就像它不存在一样。

---

## 4. 📋 渲染规则深度解析


### 4.1 真假值的渲染规则


React对不同类型值的渲染处理：

| 值的类型 | **是否渲染** | **显示结果** | **说明** |
|---------|-------------|-------------|---------|
| `true` | ❌ | 无显示 | 布尔值true不渲染 |
| `false` | ❌ | 无显示 | 布尔值false不渲染 |
| `null` | ❌ | 无显示 | null值不渲染 |
| `undefined` | ❌ | 无显示 | undefined不渲染 |
| `0` | ✅ | `0` | **注意：数字0会显示** |
| `""` | ❌ | 无显示 | 空字符串不渲染 |
| `"hello"` | ✅ | `hello` | 非空字符串正常渲染 |
| `[]` | ❌ | 无显示 | 空数组不渲染 |
| `[1,2,3]` | ✅ | `123` | 数组会拼接显示 |

### 4.2 常见渲染陷阱


**陷阱1：数字0的意外显示**
```jsx
function BadgeCounter({ count }) {
  return (
    <div>
      {/* ❌ 当count为0时，会显示"0" */}
      {count && <span className="badge">{count}</span>}
      
      {/* ✅ 正确写法：明确检查大于0 */}
      {count > 0 && <span className="badge">{count}</span>}
    </div>
  );
}
```

**陷阱2：空数组的处理**
```jsx
function TodoList({ todos }) {
  return (
    <div>
      {/* ❌ 空数组时什么都不显示，用户会困惑 */}
      {todos.length && <ul>{todos.map(todo => <li key={todo.id}>{todo.text}</li>)}</ul>}
      
      {/* ✅ 正确写法：给用户明确提示 */}
      {todos.length > 0 ? (
        <ul>{todos.map(todo => <li key={todo.id}>{todo.text}</li>)}</ul>
      ) : (
        <p>📝 还没有待办事项，来添加第一个吧！</p>
      )}
    </div>
  );
}
```

### 4.3 条件样式类


**概念**：根据条件动态添加CSS类名
```jsx
function Button({ isPrimary, isDisabled, children }) {
  // 动态构建类名
  const buttonClass = [
    'btn',
    isPrimary && 'btn-primary',
    isDisabled && 'btn-disabled'
  ].filter(Boolean).join(' ');
  
  return (
    <button className={buttonClass} disabled={isDisabled}>
      {children}
    </button>
  );
}
```

**类名构建过程**：
```
假设 isPrimary=true, isDisabled=false
│
├─ ['btn', true && 'btn-primary', false && 'btn-disabled']
├─ ['btn', 'btn-primary', false]
├─ filter(Boolean) → ['btn', 'btn-primary']
└─ join(' ') → 'btn btn-primary'
```

---

## 5. ⚡ 性能优化与最佳实践


### 5.1 条件渲染的性能考虑


**性能对比分析**：

| 渲染方式 | **性能影响** | **适用场景** | **说明** |
|---------|-------------|-------------|---------|
| `condition && <Component />` | 🟢 最佳 | 简单显示/隐藏 | 条件为假时完全不创建组件 |
| `condition ? <A /> : <B />` | 🟡 中等 | 二选一场景 | 总是创建一个组件 |
| `condition ? <A /> : null` | 🟢 很好 | 可选显示 | 等同于&&操作符 |
| `<div style={{display: condition ? 'block' : 'none'}}>` | 🔴 较差 | 保持DOM结构 | 组件始终存在，只是隐藏 |

**`[性能影响]`** 条件渲染比CSS隐藏更高效，因为**不渲染的组件不会消耗任何资源**。

### 5.2 最佳实践指南


**✅ 推荐做法**：

1. **条件提前判断**
```jsx
function UserDashboard({ user }) {
  // ✅ 早期返回，避免嵌套
  if (!user) {
    return <div>请先登录</div>;
  }
  
  return (
    <div>
      <h1>欢迎，{user.name}</h1>
      {/* 复杂的用户界面 */}
    </div>
  );
}
```

2. **逻辑封装到函数**
```jsx
function OrderStatus({ order }) {
  const getStatusDisplay = () => {
    switch (order.status) {
      case 'pending': return <span style={{color: 'orange'}}>⏳ 待处理</span>;
      case 'shipped': return <span style={{color: 'blue'}}>🚚 已发货</span>;
      case 'delivered': return <span style={{color: 'green'}}>✅ 已送达</span>;
      default: return <span style={{color: 'gray'}}>❓ 状态未知</span>;
    }
  };
  
  return <div>{getStatusDisplay()}</div>;
}
```

**❌ 避免的做法**：

```jsx
// ❌ 避免过深的嵌套
{user && user.profile && user.profile.settings && user.profile.settings.theme && (
  <div>主题设置</div>
)}

// ✅ 使用可选链简化
{user?.profile?.settings?.theme && <div>主题设置</div>}
```

### 5.3 语义清晰性建议


**让代码像人话一样易懂**：

```jsx
function ProductCard({ product, user }) {
  const canShowPrice = user?.isLoggedIn;
  const hasDiscount = product.discount > 0;
  const isOutOfStock = product.stock === 0;
  
  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      
      {canShowPrice && (
        <div className="price-section">
          <span className="price">${product.price}</span>
          {hasDiscount && (
            <span className="discount">-{product.discount}%</span>
          )}
        </div>
      )}
      
      {isOutOfStock ? (
        <button disabled>😞 缺货中</button>
      ) : (
        <button>🛒 加入购物车</button>
      )}
    </div>
  );
}
```

**`[语义清晰性建议]`** 用**有意义的变量名**替代直接的条件判断，让代码自解释。

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 条件渲染本质：用JavaScript条件语句控制JSX显示
🔸 基础方法：if/else、三元运算符、逻辑与&&、逻辑或||
🔸 安全处理：可选链?.避免访问不存在属性的错误
🔸 渲染规则：null、undefined、false不显示，数字0会显示
🔸 性能优化：条件渲染比CSS隐藏更高效
```

### 6.2 关键理解要点


**🔹 什么时候用什么方法**
```
简单的显示/隐藏 → 使用 &&
二选一的情况 → 使用 ? :
复杂的多分支 → 使用 if/else
提供默认值 → 使用 ||
安全访问属性 → 使用 ?.
```

**🔹 渲染规则记忆法**
```
会显示的：字符串、数字、JSX元素、数组
不显示的：true、false、null、undefined、空字符串、空数组
特别注意：数字0会显示！
```

**🔹 性能优化思路**
```
条件为假时完全不创建组件 > CSS隐藏组件
早期返回 > 深度嵌套判断
语义化变量名 > 复杂条件表达式
```

### 6.3 实际应用价值


**🎯 典型应用场景**
- **用户权限控制** - 根据登录状态显示不同内容
- **加载状态管理** - 数据加载时显示loading，完成后显示内容  
- **错误处理** - 出错时显示错误信息，正常时显示主要内容
- **响应式布局** - 不同屏幕尺寸显示不同组件
- **功能开关** - 根据配置动态开启/关闭功能

**🔧 开发实践要点**
- 优先考虑用户体验，给出明确的状态提示
- 保持条件逻辑的简洁和可读性
- 合理使用性能优化，避免不必要的组件创建
- 注意边界情况的处理，特别是空值和异常状态

**核心记忆**：
- 条件渲染让界面智能化，根据情况显示内容
- 掌握基础语法，理解渲染规则，注意性能优化
- 代码要语义清晰，让人一看就懂在做什么判断