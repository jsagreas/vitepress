---
title: 7、服务质量等级QoS
---
## 📚 目录

1. [QoS服务质量概念入门](#1-QoS服务质量概念入门)
2. [三种QoS等级详解](#2-三种QoS等级详解)
3. [QoS分类规则与判断](#3-QoS分类规则与判断)
4. [资源驱逐策略机制](#4-资源驱逐策略机制)
5. [优先级调度与实战配置](#5-优先级调度与实战配置)
6. [QoS最佳实践指南](#6-QoS最佳实践指南)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 QoS服务质量概念入门


### 1.1 什么是QoS服务质量


**通俗理解**：想象一下医院的急诊科分级制度

```
医院急诊分级：              Kubernetes QoS分级：
急危重症 → 优先处理          Guaranteed → 最高保障
一般病症 → 按序等待          Burstable → 弹性保障  
轻微症状 → 排队候诊          BestEffort → 尽力服务

核心思想：根据重要程度分配资源，确保关键任务优先
```

**📋 QoS的核心作用**
- **资源分配**：告诉Kubernetes哪些Pod更重要
- **驱逐决策**：资源紧张时优先删除哪些Pod
- **调度优化**：优先为重要Pod分配好资源
- **性能保障**：确保关键应用获得足够资源

### 1.2 为什么需要QoS


**🔸 没有QoS的问题**
```
资源混乱场景：
┌─────────────────┐
│ 关键业务应用     │ ← 可能被挤掉资源
├─────────────────┤
│ 测试环境应用     │ ← 占用大量资源
├─────────────────┤
│ 日志收集应用     │ ← 消耗过多内存
└─────────────────┘

后果：重要应用反而跑不好，不重要的应用浪费资源
```

**✅ 有了QoS的效果**
```
资源有序分配：
┌─────────────────┐
│ 核心业务Pod     │ ← Guaranteed 优先保障
├─────────────────┤  
│ 普通应用Pod     │ ← Burstable 按需分配
├─────────────────┤
│ 临时任务Pod     │ ← BestEffort 剩余资源
└─────────────────┘

结果：重要的先保证，不重要的用剩余资源
```

### 1.3 QoS的工作原理


**🔧 基本机制**
1. **Pod创建时**：Kubernetes根据资源配置自动分配QoS等级
2. **调度时**：优先级高的Pod优先选择好节点
3. **运行时**：监控资源使用情况
4. **资源紧张时**：按QoS等级决定驱逐顺序

---

## 2. 📊 三种QoS等级详解


### 2.1 Guaranteed - 保证级别


**🏆 最高等级：资源完全保障**

**特点说明**：
- **资源保证**：CPU和内存完全预留，不会被抢占
- **性能稳定**：运行性能最稳定，不会因资源竞争影响
- **驱逐优先级**：最后被驱逐，除非超出限制才可能被删除

**配置要求**：
```yaml
# Guaranteed等级的Pod配置
apiVersion: v1
kind: Pod
metadata:
  name: guaranteed-pod
spec:
  containers:
  - name: app
    image: nginx
    resources:
      # 关键：requests和limits必须完全相等
      requests:
        memory: "1Gi"     # 申请1GB内存
        cpu: "500m"       # 申请0.5个CPU核心
      limits:
        memory: "1Gi"     # 限制1GB内存（与requests相同）
        cpu: "500m"       # 限制0.5个CPU核心（与requests相同）
```

**📝 生活类比**
> 就像银行VIP客户，有专门的理财经理和独立办公室，服务质量完全有保障

### 2.2 Burstable - 突发级别


**⚡ 中等等级：弹性资源保障**

**特点说明**：
- **基础保障**：有最低资源保证（requests）
- **弹性扩展**：可以使用超出requests的资源（到limits为止）
- **适度风险**：可能因资源竞争被限制或驱逐

**配置示例**：
```yaml
# Burstable等级的Pod配置
apiVersion: v1
kind: Pod
metadata:
  name: burstable-pod
spec:
  containers:
  - name: app
    image: nginx
    resources:
      # 有requests保底，limits更高允许突发
      requests:
        memory: "512Mi"   # 保证最少512MB内存
        cpu: "250m"       # 保证最少0.25个CPU核心
      limits:
        memory: "2Gi"     # 最多可用2GB内存
        cpu: "1000m"      # 最多可用1个CPU核心
```

**📈 使用场景**
```
适合场景：
🔸 Web应用 - 平时资源需求稳定，高峰期需要更多资源
🔸 数据处理 - 处理量不固定，需要弹性伸缩
🔸 微服务 - 大部分时间低负载，偶尔需要更多资源

实际效果：
平时使用：requests资源（512MB内存）
高峰期：可扩展到limits资源（2GB内存）
```

### 2.3 BestEffort - 尽力而为级别


**🎲 最低等级：使用剩余资源**

**特点说明**：
- **无资源保证**：不预留任何资源
- **使用剩余**：只能使用其他Pod不用的资源
- **首先驱逐**：资源不足时第一批被删除

**配置示例**：
```yaml
# BestEffort等级的Pod配置
apiVersion: v1
kind: Pod
metadata:
  name: besteffort-pod
spec:
  containers:
  - name: app
    image: nginx
    # 关键：完全不设置resources
    # 既没有requests也没有limits
```

**🎯 适用场景**
```
适合场景：
🔸 测试环境 - 不需要性能保障
🔸 批处理任务 - 可以慢慢跑，不着急
🔸 日志收集 - 丢一些数据也没关系
🔸 实验性应用 - 临时测试用

风险提醒：
⚠️ 可能随时被删除
⚠️ 性能不稳定
⚠️ 不适合生产环境关键应用
```

### 2.4 QoS等级对比表


| QoS等级 | **资源配置** | **资源保障** | **驱逐优先级** | **适用场景** |
|---------|------------|-------------|---------------|-------------|
| 🏆 **Guaranteed** | `requests = limits` | `完全保障` | `最低（最后被驱逐）` | `关键业务应用` |
| ⚡ **Burstable** | `requests < limits` | `基础保障+弹性` | `中等` | `一般业务应用` |
| 🎲 **BestEffort** | `无resources配置` | `无保障` | `最高（第一批驱逐）` | `测试、批处理任务` |

---

## 3. 🔍 QoS分类规则与判断


### 3.1 自动分类规则


**📋 Kubernetes自动判断逻辑**

```
QoS分类决策树：
                Pod创建
                   ↓
           是否设置了resources？
           /              \
        是                  否
         ↓                  ↓
    所有容器的requests      BestEffort
    和limits都相等？        等级
    /            \
  是              否
   ↓              ↓
Guaranteed      Burstable
  等级            等级
```

### 3.2 具体判断规则详解


**🔸 Guaranteed等级判断**
```yaml
# 规则：所有容器必须同时满足
# 1. 设置了CPU和内存的requests和limits
# 2. CPU的requests等于limits
# 3. 内存的requests等于limits

# 正确的Guaranteed配置
containers:
- name: web
  resources:
    requests:
      memory: "1Gi"
      cpu: "500m"
    limits:
      memory: "1Gi"    # 必须与requests相等
      cpu: "500m"      # 必须与requests相等
```

**🔸 BestEffort等级判断**
```yaml
# 规则：所有容器都不设置任何resources

# 正确的BestEffort配置
containers:
- name: web
  image: nginx
  # 完全不写resources部分
```

**🔸 Burstable等级判断**
```yaml
# 规则：不满足Guaranteed和BestEffort的都是Burstable

# 情况1：只设置requests
containers:
- name: web
  resources:
    requests:
      memory: "512Mi"
      cpu: "250m"
    # 不设置limits

# 情况2：requests小于limits
containers:
- name: web
  resources:
    requests:
      memory: "512Mi"
      cpu: "250m"
    limits:
      memory: "2Gi"      # 大于requests
      cpu: "1000m"       # 大于requests
```

### 3.3 查看Pod的QoS等级


**🔧 命令行查看方法**

```bash
# 查看Pod详细信息，找到QoS Class字段
kubectl describe pod <pod-name>

# 输出示例：
# Name:         my-app
# Namespace:    default
# ...
# QoS Class:    Burstable    ← 这里显示QoS等级
# ...
```

**📊 批量查看多个Pod的QoS**
```bash
# 使用自定义列显示Pod名称和QoS等级
kubectl get pods -o custom-columns=NAME:.metadata.name,QOS:.status.qosClass

# 输出示例：
# NAME          QOS
# web-app       Burstable
# db-server     Guaranteed  
# test-job      BestEffort
```

---

## 4. 🚨 资源驱逐策略机制


### 4.1 什么是Pod驱逐


**通俗解释**：就像公交车超载时，司机会请一些乘客下车

```
资源不足场景：
节点内存使用率 > 85%
              ↓
    Kubernetes开始驱逐Pod
              ↓
    释放内存给重要Pod使用
```

**驱逐触发条件**：
- **内存不足**：节点内存使用超过阈值
- **磁盘不足**：节点存储空间不够
- **进程数过多**：运行的进程超过限制

### 4.2 驱逐顺序规则


**📊 驱逐优先级排序**

```
驱逐顺序（从高到低）：
1. BestEffort Pod           ← 第一批被驱逐
   └─ 超出requests最多的先驱逐
   
2. Burstable Pod           ← 第二批被驱逐
   └─ 超出requests比例最大的先驱逐
   
3. Guaranteed Pod          ← 最后被驱逐
   └─ 只有超出limits才会被驱逐
```

**实际驱逐示例**：
```
当前节点状态：
┌─────────────────────────────────┐
│ 节点内存：8GB，已使用7.5GB      │
├─────────────────────────────────┤
│ Pod A (BestEffort)   使用500MB  │ ← 第一个被驱逐
│ Pod B (Burstable)    使用1.5GB  │ ← 第二个被驱逐  
│ Pod C (Guaranteed)   使用1GB    │ ← 保留
└─────────────────────────────────┘
```

### 4.3 驱逐过程详解


**🔄 完整驱逐流程**

```
步骤1：监控资源状态
kubelet每10秒检查一次资源使用情况

步骤2：判断是否需要驱逐
内存使用 > 驱逐阈值（默认85%）

步骤3：选择驱逐目标
按QoS等级和资源超用情况排序

步骤4：发送SIGTERM信号
给Pod 30秒时间优雅关闭

步骤5：强制终止
超时后发送SIGKILL强制删除

步骤6：释放资源
Pod被删除，释放占用的资源
```

**⚠️ 驱逐注意事项**
- 驱逐是**删除Pod**，不是重启
- 被驱逐的Pod需要控制器（如Deployment）重新创建
- 无状态应用影响小，有状态应用要小心数据丢失

---

## 5. 🎯 优先级调度与实战配置


### 5.1 优先级调度概念


**基本原理**：给Pod设置优先级数字，数字越大越优先

```
优先级调度场景：
高优先级Pod (100) → 优先分配到好节点
中优先级Pod (50)  → 分配到普通节点  
低优先级Pod (10)  → 分配到剩余节点

甚至可以驱逐低优先级Pod给高优先级Pod让位
```

### 5.2 创建优先级类


**📝 定义优先级类**
```yaml
# 创建高优先级类
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000              # 优先级数值，越大越优先
globalDefault: false     # 是否作为默认优先级
description: "高优先级，用于关键业务应用"
```

```yaml
# 创建普通优先级类  
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: normal-priority
value: 500
description: "普通优先级，用于一般业务应用"
```

### 5.3 为Pod配置优先级


**🔧 在Pod中使用优先级**
```yaml
# 高优先级Pod配置
apiVersion: v1
kind: Pod
metadata:
  name: important-app
spec:
  # 指定使用的优先级类
  priorityClassName: high-priority
  containers:
  - name: app
    image: nginx
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "1Gi"  
        cpu: "500m"
```

### 5.4 QoS与优先级结合使用


**💡 最佳实践组合**

| 应用类型 | **QoS等级** | **优先级** | **配置建议** |
|---------|------------|-----------|-------------|
| 🔥 **核心业务** | `Guaranteed` | `高(800-1000)` | `关键应用，资源和调度都保障` |
| ⚡ **重要应用** | `Burstable` | `中高(500-800)` | `重要但可容忍一定波动` |
| 📊 **一般应用** | `Burstable` | `普通(100-500)` | `日常业务应用` |
| 🧪 **测试环境** | `BestEffort` | `低(0-100)` | `可被随时驱逐` |

**完整配置示例**：
```yaml
# 核心业务Pod - 最高保障
apiVersion: apps/v1
kind: Deployment
metadata:
  name: core-business
spec:
  replicas: 3
  selector:
    matchLabels:
      app: core-business
  template:
    metadata:
      labels:
        app: core-business
    spec:
      priorityClassName: high-priority    # 高优先级
      containers:
      - name: app
        image: core-app:v1.0
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "2Gi"     # Guaranteed QoS
            cpu: "1000m"
```

---

## 6. 📚 QoS最佳实践指南


### 6.1 生产环境配置建议


**🏢 企业级应用分级策略**

```
业务应用分级：
┌─────────────────────────────────────┐
│ 第一级：核心交易系统                 │
│ QoS: Guaranteed + 高优先级          │
│ 特点：绝不能中断，性能要求极高       │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐  
│ 第二级：重要业务系统                 │
│ QoS: Burstable + 中高优先级         │
│ 特点：允许短暂波动，但要快速恢复     │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ 第三级：辅助系统                    │  
│ QoS: Burstable + 普通优先级         │
│ 特点：可容忍一定延迟和中断          │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│ 第四级：测试和工具                  │
│ QoS: BestEffort + 低优先级          │
│ 特点：可随时停止，不影响业务        │
└─────────────────────────────────────┘
```

### 6.2 资源配置经验值


**💻 常见应用的资源配置**

```yaml
# Web应用（中等负载）
resources:
  requests:
    memory: "512Mi"
    cpu: "250m"
  limits:
    memory: "1Gi"
    cpu: "500m"

# 数据库（高资源需求）  
resources:
  requests:
    memory: "2Gi"
    cpu: "1000m"
  limits:
    memory: "4Gi"
    cpu: "2000m"

# 日志收集（低资源需求）
resources:
  requests:
    memory: "128Mi"
    cpu: "100m"
  limits:
    memory: "256Mi"
    cpu: "200m"
```

### 6.3 监控和调优


**📊 关键监控指标**

```bash
# 查看节点资源使用情况
kubectl top nodes

# 查看Pod资源使用情况  
kubectl top pods

# 查看特定Pod的资源详情
kubectl describe pod <pod-name> | grep -A 10 "QoS Class"
```

**🔧 性能调优建议**
- **定期检查**：每周检查Pod的实际资源使用情况
- **适度冗余**：requests设置为平均使用量的1.2-1.5倍
- **合理limits**：limits设置为峰值使用量的1.1-1.2倍
- **压力测试**：定期进行负载测试验证配置是否合理

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 QoS三等级：Guaranteed > Burstable > BestEffort
🔸 自动分类：Kubernetes根据resources配置自动分配等级  
🔸 驱逐顺序：BestEffort先驱逐，Guaranteed最后驱逐
🔸 优先级调度：可通过PriorityClass设置Pod调度优先级
🔸 资源保障：等级越高，资源保障越强，性能越稳定
```

### 7.2 关键理解要点


**🔹 QoS的实际意义**
```
不仅是资源分配的问题：
- 业务连续性保障
- 系统稳定性提升  
- 资源利用率优化
- 运维管理简化
```

**🔹 配置选择原则**
```
核心业务：Guaranteed + 高优先级
- 数据库、支付系统、用户认证等

重要业务：Burstable + 中优先级  
- Web应用、API服务、消息队列等

辅助功能：BestEffort + 低优先级
- 日志收集、监控工具、测试应用等
```

**🔹 常见误区避免**
```
❌ 所有Pod都设置Guaranteed（浪费资源）
❌ 不设置任何QoS（缺乏保障）
❌ 忽视优先级配置（调度不合理）
❌ 不监控实际使用情况（配置不准确）
```

### 7.3 实际应用价值


**🎯 生产环境收益**
- **故障减少**：关键应用优先保障，减少因资源不足导致的故障
- **性能提升**：合理的资源分配让应用性能更稳定
- **成本优化**：避免资源浪费，提高集群整体利用率
- **运维简化**：自动化的资源管理减少人工干预

**🔧 运维实践建议**
- 建立应用分级制度，明确各级应用的QoS要求
- 定期review和调整资源配置，优化性能和成本
- 配置完善的监控告警，及时发现资源问题
- 进行定期的故障演练，验证QoS配置的有效性

**核心记忆**：
- QoS就是Kubernetes的资源保障等级制度
- 三个等级对应不同的资源保障强度
- 合理配置QoS可以让集群更稳定高效
- 核心业务用Guaranteed，一般业务用Burstable，测试用BestEffort