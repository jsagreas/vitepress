---
title: 5、Pod优先级调度
---
## 📚 目录

1. [Pod优先级调度基础概念](#1-Pod优先级调度基础概念)
2. [PriorityClass优先级类详解](#2-PriorityClass优先级类详解)
3. [抢占式调度机制](#3-抢占式调度机制)
4. [优先级调度实践配置](#4-优先级调度实践配置)
5. [调度队列管理与算法](#5-调度队列管理与算法)
6. [生产环境最佳实践](#6-生产环境最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 Pod优先级调度基础概念


### 1.1 什么是Pod优先级调度


**🔸 通俗理解**
```
想象一下医院的急诊科：
- 普通感冒患者 → 普通优先级Pod
- 发烧患者     → 中等优先级Pod  
- 心脏病发作   → 高优先级Pod
- 生命垂危     → 最高优先级Pod

医生会优先处理生命垂危的患者，这就是优先级调度！
```

**💡 核心概念**
- **优先级调度**：让Kubernetes优先调度重要的Pod
- **资源竞争**：当集群资源不足时，重要Pod优先获得资源
- **抢占机制**：高优先级Pod可以"踢掉"低优先级Pod来获得资源

### 1.2 为什么需要优先级调度


**🚨 实际问题场景**
```
生产环境常见问题：
┌─────────────────────────────────┐
│ 集群资源有限情况下：              │
│                                 │
│ 关键业务Pod → 等待资源 😰        │
│ 测试环境Pod → 占用大量资源 😎     │
│ 日志收集Pod → 抢占CPU 🤖         │
│ 监控告警Pod → 无法启动 💥        │
└─────────────────────────────────┘
```

**✅ 优先级调度解决方案**
- **🔥 关键业务**：最高优先级，保证可用性
- **⚡ 核心服务**：高优先级，快速调度
- **💡 辅助工具**：中等优先级，平衡资源
- **🧪 测试环境**：低优先级，可被抢占

### 1.3 优先级调度的工作原理


**📊 调度决策流程**
```
Pod提交 → 检查优先级 → 加入调度队列 → 节点匹配 → 资源分配
   ↓           ↓           ↓           ↓         ↓
用户创建    读取Priority  按优先级排序  节点过滤   成功调度
   ↓           ↓           ↓           ↓         ↓
YAML文件   PriorityClass  高优先级优先  资源检查   Pod运行
```

---

## 2. 🏷️ PriorityClass优先级类详解


### 2.1 PriorityClass基本概念


**🔸 什么是PriorityClass**
> PriorityClass就像给Pod发放的"VIP卡"，决定了Pod在集群中的优先级等级

**💻 基础PriorityClass示例**
```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000              # 优先级数值，越大优先级越高
globalDefault: false     # 是否为全局默认优先级
description: "高优先级类，用于关键业务服务"
```

### 2.2 优先级数值体系设计


**📈 推荐的优先级分层**
```
优先级范围设计：
┌─────────────────┬──────────┬─────────────┐
│   业务类型      │ 优先级值  │   使用场景   │
├─────────────────┼──────────┼─────────────┤
│ 🚨 系统关键     │ 2000+    │ DNS/网络组件 │
│ 🔥 核心业务     │ 1000-1999│ 主要应用服务 │
│ ⚡ 重要服务     │ 500-999  │ 数据库/缓存  │
│ 💡 一般服务     │ 100-499  │ 普通Web应用  │
│ 🧪 测试/开发    │ 0-99     │ 测试环境    │
│ 📊 批处理任务   │ 负数     │ 数据分析    │
└─────────────────┴──────────┴─────────────┘
```

**⚠️ 重要注意事项**
> 系统保留优先级：Kubernetes系统组件使用优先级值 > 10^9，普通用户应避免使用过高数值

### 2.3 创建不同级别的PriorityClass


**🏆 系统级别优先级类**
```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: system-cluster-critical
value: 2000000000
globalDefault: false
description: "系统关键组件，如DNS、网络插件"
```

**💼 业务级别优先级类**
```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: business-critical
value: 1500
globalDefault: false
description: "业务关键服务，需要保证高可用性"
---
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: business-normal
value: 800
globalDefault: true    # 设为默认优先级
description: "普通业务服务的默认优先级"
---
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: development-low
value: 100
globalDefault: false
description: "开发测试环境，可被抢占"
```

### 2.4 优先级继承机制


**🔄 优先级传递规则**
```
优先级继承链：
PriorityClass → Pod → Container
     ↓            ↓       ↓
   定义优先级   继承优先级  执行优先级

示例说明：
1. PriorityClass "high-priority" value: 1000
2. Pod使用该PriorityClass
3. Pod内所有Container都具有1000优先级
```

---

## 3. ⚔️ 抢占式调度机制


### 3.1 抢占调度基本原理


**🎯 抢占机制解释**
```
抢占调度就像"加塞儿"：
┌────────────────────────────────────┐
│ 原始情况：                          │
│ 节点A: [低优先级Pod1][低优先级Pod2] │
│ 节点B: [已满]                      │
│                                    │
│ 高优先级Pod来了：                   │
│ ↓ 抢占发生                         │
│ 节点A: [高优先级Pod][低优先级Pod2] │ 
│ 节点B: [已满]                      │
│ 被驱逐: 低优先级Pod1 → Pending    │
└────────────────────────────────────┘
```

### 3.2 抢占决策算法详解


**🧠 抢占决策流程**
```
高优先级Pod调度失败
         ↓
    寻找可抢占节点
         ↓
    评估抢占成本
         ↓
┌─────────────────┐
│ 抢占成本计算：   │
│ • 被驱逐Pod数量  │
│ • 被驱逐Pod优先级 │
│ • 资源释放量     │
│ • 亲和性影响     │
└─────────────────┘
         ↓
    选择最佳节点
         ↓
    执行Pod驱逐
         ↓
    调度高优先级Pod
```

### 3.3 抢占策略配置


**⚙️ 抢占行为控制**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: high-priority-pod
spec:
  priorityClassName: business-critical
  preemptionPolicy: PreemptLowerPriority  # 抢占策略
  containers:
  - name: app
    image: nginx
    resources:
      requests:
        cpu: 500m
        memory: 512Mi
```

**📋 抢占策略选项**
| 策略值 | 行为说明 | 适用场景 |
|--------|----------|----------|
| `PreemptLowerPriority` | 抢占低优先级Pod | 🔥 关键业务 |
| `Never` | 永不抢占其他Pod | 💡 友好服务 |

### 3.4 抢占保护机制


**🛡️ 防止过度抢占**
```yaml
# 设置Pod中断预算保护
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: critical-app-pdb
spec:
  minAvailable: 2      # 至少保持2个副本运行
  selector:
    matchLabels:
      app: critical-service
```

---

## 4. 🔧 优先级调度实践配置


### 4.1 为Pod设置优先级


**📝 在Pod中指定优先级**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-server
  labels:
    app: web-server
spec:
  priorityClassName: business-critical    # 指定优先级类
  containers:
  - name: nginx
    image: nginx:1.21
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi
```

**🚀 在Deployment中设置优先级**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: critical-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: critical-app
  template:
    metadata:
      labels:
        app: critical-app
    spec:
      priorityClassName: business-critical  # 所有Pod都使用此优先级
      containers:
      - name: app
        image: myapp:v1.0
        resources:
          requests:
            cpu: 300m
            memory: 512Mi
```

### 4.2 不同工作负载的优先级设置


**💾 数据库服务（高优先级）**
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql-primary
spec:
  replicas: 1
  serviceName: mysql
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      priorityClassName: business-critical  # 数据库必须高优先级
      containers:
      - name: mysql
        image: mysql:8.0
        resources:
          requests:
            cpu: 1000m
            memory: 2Gi
```

**🧪 测试环境（低优先级）**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
  namespace: testing
spec:
  replicas: 2
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
    spec:
      priorityClassName: development-low   # 测试环境低优先级
      containers:
      - name: app
        image: test-app:latest
```

### 4.3 批处理任务优先级管理


**📊 Job任务优先级设置**
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: data-processing
spec:
  template:
    spec:
      priorityClassName: batch-processing  # 批处理专用优先级
      containers:
      - name: processor
        image: data-processor:v1.0
        resources:
          requests:
            cpu: 2000m
            memory: 4Gi
      restartPolicy: Never
---
# 批处理专用优先级类（负数，最低优先级）
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: batch-processing
value: -100
description: "批处理任务，可以被任何其他Pod抢占"
```

---

## 5. 📋 调度队列管理与算法


### 5.1 调度队列工作原理


**🚶‍♂️ 调度队列结构**
```
Kubernetes调度器队列系统：
┌─────────────────────────────────────┐
│            调度队列                  │
├─────────────────────────────────────┤
│ 🔥 高优先级队列 (Priority: 1500)    │
│ ├─ Pod-A (business-critical)        │
│ ├─ Pod-B (database-high)           │
│ └─ Pod-C (api-server)              │
├─────────────────────────────────────┤
│ ⚡ 中优先级队列 (Priority: 800)     │
│ ├─ Pod-D (web-service)             │
│ └─ Pod-E (cache-service)           │
├─────────────────────────────────────┤
│ 💡 低优先级队列 (Priority: 100)    │
│ ├─ Pod-F (test-app)                │
│ └─ Pod-G (log-collector)           │
└─────────────────────────────────────┘
```

**⏱️ 调度时序说明**
1. 调度器从高优先级队列开始处理
2. 同优先级内按提交时间排序（FIFO）
3. 高优先级Pod调度完成后，才处理低优先级

### 5.2 调度决策算法


**🎯 节点选择算法流程**
```
Pod调度决策过程：
Pod提交 → 过滤节点 → 节点打分 → 选择最佳节点
   ↓         ↓         ↓          ↓
读取优先级  资源检查   优先级权重   绑定Pod
   ↓         ↓         ↓          ↓
加入队列    亲和性     负载均衡    调度成功

节点打分权重：
• 优先级分数：40%
• 资源利用率：30% 
• 亲和性匹配：20%
• 其他因素：10%
```

### 5.3 调度性能优化


**⚡ 调度器配置优化**
```yaml
apiVersion: kubescheduler.config.k8s.io/v1beta3
kind: KubeSchedulerConfiguration
profiles:
- schedulerName: default-scheduler
  plugins:
    score:
      enabled:
      - name: PrioritySort           # 启用优先级排序
      - name: NodeResourcesFit       # 节点资源匹配
  pluginConfig:
  - name: PrioritySort
    args:
      weight: 100                    # 优先级权重最高
```

---

## 6. 🎯 生产环境最佳实践


### 6.1 优先级体系设计最佳实践


**🏗️ 企业级优先级架构**
```
推荐的5层优先级体系：
┌─────────────────────────────────────┐
│ 🚨 系统关键层 (2000-2999)           │
│ ├─ kube-system组件                  │
│ ├─ 网络插件 (CNI)                  │
│ └─ DNS服务                         │
├─────────────────────────────────────┤
│ 🔥 业务关键层 (1000-1999)           │
│ ├─ 核心API服务                     │
│ ├─ 主数据库                       │
│ └─ 支付系统                       │
├─────────────────────────────────────┤
│ ⚡ 业务重要层 (500-999)             │
│ ├─ Web前端                        │
│ ├─ 缓存服务                       │
│ └─ 消息队列                       │
├─────────────────────────────────────┤
│ 💡 业务一般层 (100-499)             │
│ ├─ 日志收集                       │
│ ├─ 监控告警                       │
│ └─ 辅助工具                       │
├─────────────────────────────────────┤
│ 🧪 测试开发层 (0-99)               │
│ ├─ 测试环境                       │
│ ├─ 开发调试                       │
│ └─ 实验性功能                     │
└─────────────────────────────────────┘
```

### 6.2 资源竞争处理策略


**📊 混合工作负载管理**
```yaml
# 生产环境配置示例
---
# 核心服务：不可抢占
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payment-service
spec:
  template:
    spec:
      priorityClassName: business-critical
      containers:
      - name: payment
        resources:
          requests:
            cpu: 1000m      # 保证资源
            memory: 1Gi
          limits:
            cpu: 2000m      # 限制资源
            memory: 2Gi
---
# 批处理：可抢占，低优先级
apiVersion: batch/v1
kind: Job
metadata:
  name: daily-report
spec:
  template:
    spec:
      priorityClassName: batch-low
      containers:
      - name: report
        resources:
          requests:
            cpu: 100m       # 最小需求
            memory: 256Mi
          limits:
            cpu: 4000m      # 空闲时可用更多
            memory: 8Gi
```

### 6.3 监控和告警配置


**📈 优先级调度监控指标**
```yaml
# Prometheus监控规则示例
groups:
- name: priority-scheduling
  rules:
  - alert: HighPriorityPodPending
    expr: kube_pod_status_phase{phase="Pending"} * on(pod) kube_pod_spec_priority_class_name{priority_class_name="business-critical"} > 0
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "高优先级Pod调度失败"
      description: "Pod {{ $labels.pod }} 优先级为 business-critical，但调度超过2分钟"
  
  - alert: LowPriorityPodEvicted
    expr: increase(kube_pod_container_status_restarts_total[5m]) > 3
    labels:
      severity: warning
    annotations:
      summary: "低优先级Pod频繁重启"
      description: "可能由于抢占导致的频繁重启"
```

### 6.4 故障排查指南


**🔍 常见问题诊断**
```bash
# 1. 查看Pod优先级设置
kubectl get pods -o custom-columns=NAME:.metadata.name,PRIORITY:.spec.priority,PRIORITY_CLASS:.spec.priorityClassName

# 2. 检查调度队列状态
kubectl get events --sort-by='.firstTimestamp' | grep -i preempt

# 3. 查看节点资源使用情况
kubectl describe nodes | grep -A 5 "Allocated resources"

# 4. 检查PriorityClass配置
kubectl get priorityclass -o wide
```

**⚠️ 故障处理步骤**
```
调度失败排查流程：
1. 检查优先级配置是否正确
2. 确认集群资源是否充足
3. 查看是否存在节点亲和性限制
4. 检查是否有PodDisruptionBudget阻止抢占
5. 验证资源请求是否合理
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🎯 优先级调度核心要点**
- **PriorityClass**：定义优先级等级的资源对象
- **抢占机制**：高优先级Pod可以驱逐低优先级Pod
- **调度队列**：按优先级排序的Pod等待队列
- **资源保障**：关键工作负载的资源优先分配
- **成本权衡**：抢占决策基于多个因素综合评估

### 7.2 关键实践原则


**💡 设计原则**
```
🔸 分层设计：建立清晰的优先级层次体系
🔸 合理设值：避免优先级数值过于集中
🔸 业务导向：根据业务重要性设置优先级
🔸 资源匹配：优先级与资源请求要匹配
🔸 监控告警：建立完善的监控体系
```

### 7.3 生产环境应用指导


**📊 应用场景总结**
| 场景类型 | 优先级设置 | 抢占策略 | 适用服务 |
|----------|------------|----------|----------|
| 🚨 系统服务 | 2000+ | 总是抢占 | DNS、网络组件 |
| 🔥 核心业务 | 1000-1999 | 抢占低优先级 | API、数据库 |
| ⚡ 重要服务 | 500-999 | 适度抢占 | Web、缓存 |
| 💡 一般服务 | 100-499 | 很少抢占 | 日志、监控 |
| 🧪 测试开发 | 0-99 | 从不抢占 | 测试环境 |

**🧠 记忆要诀**
- **优先级数值**：越高越重要，系统>业务>测试
- **抢占原理**：高欺负低，同级论先后
- **设计原则**：分层清晰，业务导向，监控完善
- **生产实践**：核心保障，测试让路，资源均衡

**🎯 关键成功要素**
1. **合理的优先级体系设计**
2. **准确的业务重要性评估**  
3. **完善的监控告警机制**
4. **定期的配置优化调整**
5. **充足的集群资源规划**