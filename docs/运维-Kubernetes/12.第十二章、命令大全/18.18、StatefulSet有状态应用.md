---
title: 18、StatefulSet有状态应用
---
## 📚 目录

1. [StatefulSet基础概念](#1-StatefulSet基础概念)
2. [核心特性深度理解](#2-核心特性深度理解)
3. [创建和管理命令](#3-创建和管理命令)
4. [扩缩容操作实践](#4-扩缩容操作实践)
5. [更新策略详解](#5-更新策略详解)
6. [存储管理实战](#6-存储管理实战)
7. [故障排查与运维](#7-故障排查与运维)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ StatefulSet基础概念


### 1.1 什么是StatefulSet


**📖 通俗解释**：
StatefulSet就像是给每个员工都分配了固定工位和专用文件柜的公司部门。每个员工（Pod）都有：
- **固定的姓名牌**（固定的网络标识）
- **专属的文件柜**（持久化存储）
- **有序的座位号**（有序的启动和停止）

```
普通办公室（Deployment）：      有序办公室（StatefulSet）：
员工A  员工B  员工C             员工-0  员工-1  员工-2
 📁     📁     📁              📁固定   📁固定   📁固定
随意调换座位                      按序号排列，不能随意调换
```

**🔸 核心定义**：
StatefulSet是Kubernetes中专门用于管理**有状态应用**的控制器，它为每个Pod提供：
- **稳定的网络标识符**
- **有序的部署和扩缩容**
- **持久化的存储**

### 1.2 为什么需要StatefulSet


**💡 问题背景**：
想象你在管理一个数据库集群，如果用普通的Deployment：

```
问题场景：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 数据库Pod-1 │    │ 数据库Pod-2 │    │ 数据库Pod-3 │
│  随机名字   │    │  随机名字   │    │  随机名字   │
│  随机IP     │    │  随机IP     │    │  随机IP     │
│ 数据丢失    │    │ 数据丢失    │    │ 数据丢失    │
└─────────────┘    └─────────────┘    └─────────────┘

问题：
❌ 重启后名字和IP会变
❌ 无法区分主从关系  
❌ 数据无法持久保存
❌ 无法按顺序启动
```

**✅ StatefulSet解决方案**：

```
StatefulSet场景：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 数据库-0    │    │ 数据库-1    │    │ 数据库-2    │
│ 固定名字    │    │ 固定名字    │    │ 固定名字    │
│ 稳定网络    │    │ 稳定网络    │    │ 稳定网络    │
│ 持久存储    │    │ 持久存储    │    │ 持久存储    │
└─────────────┘    └─────────────┘    └─────────────┘
      主库              从库1            从库2
```

### 1.3 适用场景


**🎯 典型应用场景**：

| 应用类型 | **使用原因** | **具体例子** |
|---------|------------|-------------|
| **数据库** | `需要稳定的网络标识和数据持久化` | `MySQL主从、MongoDB副本集` |
| **消息队列** | `需要有序启动和稳定的存储` | `Kafka集群、RabbitMQ集群` |
| **分布式存储** | `节点间需要稳定的网络关系` | `Ceph、GlusterFS` |
| **有状态缓存** | `需要持久化缓存数据` | `Redis集群、Memcached集群` |

**⚠️ 不适用场景**：
- **无状态Web应用** → 用Deployment更合适
- **批处理任务** → 用Job更合适  
- **临时计算任务** → 用Pod更合适

---

## 2. ⭐ 核心特性深度理解


### 2.1 稳定的网络标识


**🌐 网络标识规则**：
StatefulSet中的每个Pod都有固定的DNS名称格式：

```
Pod DNS格式：
$(statefulset-name)-$(ordinal).$(service-name).$(namespace).svc.cluster.local

具体示例：
mysql-0.mysql-service.default.svc.cluster.local
mysql-1.mysql-service.default.svc.cluster.local
mysql-2.mysql-service.default.svc.cluster.local
```

**💻 实践验证命令**：
```bash
# 创建StatefulSet后验证网络标识
kubectl get pods -o wide
kubectl exec -it mysql-0 -- nslookup mysql-0.mysql-service
```

### 2.2 有序部署和终止


**🔄 启动顺序**：
StatefulSet的Pod按照编号顺序启动和停止：

```
启动过程：
第1步：mysql-0 创建并运行 ✅
         ↓
第2步：mysql-1 创建并运行 ✅  
         ↓
第3步：mysql-2 创建并运行 ✅

停止过程（相反顺序）：
第1步：mysql-2 停止并删除 ❌
         ↓
第2步：mysql-1 停止并删除 ❌
         ↓  
第3步：mysql-0 停止并删除 ❌
```

**💡 为什么要有序**：
- **数据库主从**：主库必须先启动，从库才能连接
- **选举机制**：分布式系统需要按顺序选举leader
- **依赖关系**：某些Pod可能依赖前面的Pod

### 2.3 持久化存储卷


**📦 存储特性**：

```
存储生命周期：
Pod生命周期：  [创建] → [运行] → [删除] → [重建]
                ↓       ↓       ↓       ↓
存储生命周期： [创建] → [使用] → [保留] → [复用]

重点：Pod删除后，存储卷不会删除！
```

**🗂️ 存储卷命名规则**：
```
PVC命名格式：
$(volumeClaimTemplate.name)-$(statefulset-name)-$(ordinal)

示例：
data-mysql-0  # mysql-0的数据卷
data-mysql-1  # mysql-1的数据卷  
data-mysql-2  # mysql-2的数据卷
```

---

## 3. 🚀 创建和管理命令


### 3.1 创建StatefulSet


**📝 基础创建命令**：
```bash
# 从YAML文件创建StatefulSet
kubectl create -f statefulset.yaml

# 或者使用apply（推荐，支持更新）
kubectl apply -f statefulset.yaml
```

**📄 StatefulSet配置示例**：
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql-service  # 必须指定Headless Service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "password123"
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:  # 存储卷模板
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

**🔧 必需的Headless Service**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  clusterIP: None  # 这里设置为None才是Headless Service
  selector:
    app: mysql
  ports:
  - port: 3306
```

### 3.2 查看StatefulSet状态


**📊 基础查看命令**：
```bash
# 列出所有StatefulSet
kubectl get statefulsets
kubectl get sts  # 简写形式

# 查看特定StatefulSet详细信息
kubectl describe statefulset mysql

# 实时监控StatefulSet状态
kubectl get statefulsets -w
```

**💡 状态字段解释**：
```bash
# 输出示例：
NAME    READY   AGE
mysql   2/3     5m30s

解释：
READY: 2/3  表示期望3个Pod，目前2个已就绪
AGE: 5m30s  表示StatefulSet创建了5分30秒
```

### 3.3 查看StatefulSet管理的Pod


**📋 Pod查看命令**：
```bash
# 查看StatefulSet管理的所有Pod
kubectl get pods -l app=mysql

# 按名称排序显示（推荐）
kubectl get pods -l app=mysql -o name --sort-by=.metadata.name

# 查看Pod详细信息
kubectl describe pod mysql-0
```

**🔍 Pod状态含义**：
```bash
# 输出示例：
NAME      READY   STATUS    RESTARTS   AGE
mysql-0   1/1     Running   0          10m
mysql-1   1/1     Running   0          8m
mysql-2   0/1     Pending   0          2m

状态解释：
Running - Pod正常运行
Pending - Pod正在等待调度或拉取镜像
ContainerCreating - Pod正在创建容器
```

---

## 4. 📈 扩缩容操作实践


### 4.1 扩容StatefulSet


**⬆️ 扩容命令**：
```bash
# 扩容到5个副本
kubectl scale statefulset mysql --replicas=5

# 验证扩容结果
kubectl get statefulsets mysql
kubectl get pods -l app=mysql
```

**📊 扩容过程分析**：
```
扩容过程（从3个扩到5个）：
当前状态: mysql-0, mysql-1, mysql-2 ✅
           ↓
第1步：   创建 mysql-3 ⏳ 
           ↓ (等待mysql-3完全就绪)
第2步：   创建 mysql-4 ⏳
           ↓
最终状态: mysql-0, mysql-1, mysql-2, mysql-3, mysql-4 ✅

特点：按顺序逐个创建，确保每个Pod完全就绪后再创建下一个
```

### 4.2 缩容StatefulSet


**⬇️ 缩容命令**：
```bash
# 缩容到2个副本
kubectl scale statefulset mysql --replicas=2

# 验证缩容结果  
kubectl get statefulsets mysql
kubectl get pods -l app=mysql
```

**⚠️ 缩容注意事项**：
```
缩容过程（从5个缩到2个）：
当前状态: mysql-0, mysql-1, mysql-2, mysql-3, mysql-4 ✅
           ↓
第1步：   删除 mysql-4 ❌
           ↓ (等待mysql-4完全删除)
第2步：   删除 mysql-3 ❌  
           ↓
第3步：   删除 mysql-2 ❌
           ↓
最终状态: mysql-0, mysql-1 ✅

重要：PVC不会自动删除！数据仍然保留
```

### 4.3 检查扩缩容状态


**🔍 状态检查命令**：
```bash
# 查看StatefulSet滚动更新状态
kubectl rollout status statefulset/mysql

# 查看事件日志
kubectl get events --sort-by=.metadata.creationTimestamp

# 查看特定Pod的详细日志
kubectl logs mysql-0 -f
```

**📈 监控扩缩容进度**：
```bash
# 实时监控Pod变化
watch kubectl get pods -l app=mysql

# 监控StatefulSet状态变化
watch kubectl get statefulsets mysql
```

---

## 5. 🔄 更新策略详解


### 5.1 滚动更新策略


**🔄 默认更新方式**：
StatefulSet默认使用`RollingUpdate`策略，按照**逆序**更新Pod：

```
更新过程（5个Pod的情况）：
初始状态: mysql-0(v1), mysql-1(v1), mysql-2(v1), mysql-3(v1), mysql-4(v1)
           ↓
第1步：   mysql-4 更新为 v2 ⏳
           ↓ (等待mysql-4完全就绪)
第2步：   mysql-3 更新为 v2 ⏳
           ↓
... 依次进行
           ↓ 
最终状态: mysql-0(v2), mysql-1(v2), mysql-2(v2), mysql-3(v2), mysql-4(v2) ✅
```

**💻 更新配置命令**：
```bash
# 更新StatefulSet镜像
kubectl set image statefulset/mysql mysql=mysql:8.0.28

# 或者直接编辑StatefulSet
kubectl edit statefulset mysql

# 查看更新状态
kubectl rollout status statefulset/mysql
```

### 5.2 分区更新策略


**🎯 分区更新概念**：
分区更新允许你**只更新部分Pod**，这对于金丝雀发布或灰度更新非常有用。

**🔧 设置分区更新**：
```bash
# 设置分区为2（只更新序号>=2的Pod）
kubectl patch statefulset mysql -p '{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":2}}}}'

# 验证分区设置
kubectl describe statefulset mysql | grep -A5 "Update Strategy"
```

**📊 分区更新效果**：
```
分区设置为2的更新效果：
更新前: mysql-0(v1), mysql-1(v1), mysql-2(v1), mysql-3(v1), mysql-4(v1)
          ↓
更新后: mysql-0(v1), mysql-1(v1), mysql-2(v2), mysql-3(v2), mysql-4(v2)
        └─────不更新─────┘    └─────────更新─────────┘
         序号 < 2            序号 >= 2

用途：测试新版本是否正常工作
```

### 5.3 OnDelete更新策略


**⏸️ 手动更新模式**：
```bash
# 设置为OnDelete策略
kubectl patch statefulset mysql -p '{"spec":{"updateStrategy":{"type":"OnDelete"}}}'
```

**🔧 OnDelete更新流程**：
```
OnDelete策略特点：
1. 更新StatefulSet后，现有Pod不会自动更新
2. 只有手动删除Pod后，才会用新配置重建
3. 完全由管理员控制更新时机

手动更新命令：
kubectl delete pod mysql-4  # 删除后会用新配置重建
kubectl delete pod mysql-3  # 按需删除更新
```

---

## 6. 💾 存储管理实战


### 6.1 查看存储卷


**📦 存储卷查看命令**：
```bash
# 查看StatefulSet关联的PVC
kubectl get pvc -l app=mysql

# 查看PV状态
kubectl get pv

# 查看存储类
kubectl get storageclass
```

**📊 存储状态解读**：
```bash
# PVC输出示例：
NAME           STATUS   VOLUME                     CAPACITY   AGE
data-mysql-0   Bound    pvc-12345-abcd-ef67-890    10Gi      15m
data-mysql-1   Bound    pvc-23456-bcde-f678-901    10Gi      13m
data-mysql-2   Bound    pvc-34567-cdef-g789-012    10Gi      11m

解释：
STATUS: Bound     表示PVC已绑定到PV
VOLUME: pvc-xxx   表示对应的PV名称
CAPACITY: 10Gi    表示存储容量
```

### 6.2 存储卷扩容


**📈 存储扩容步骤**：
```bash
# 1. 检查StorageClass是否支持扩容
kubectl describe storageclass standard | grep "AllowVolumeExpansion"

# 2. 更新PVC请求容量
kubectl patch pvc data-mysql-0 -p '{"spec":{"resources":{"requests":{"storage":"20Gi"}}}}'

# 3. 重启Pod以应用新容量（某些存储需要）
kubectl delete pod mysql-0
```

### 6.3 存储卷清理


**🗑️ 存储清理注意事项**：

> **⚠️ 重要警告**：删除StatefulSet时，PVC和数据**不会**自动删除！

```bash
# 删除StatefulSet（PVC保留）
kubectl delete statefulset mysql

# 查看残留的PVC
kubectl get pvc -l app=mysql

# 手动删除PVC（数据将永久丢失！）
kubectl delete pvc -l app=mysql

# 或者删除特定PVC
kubectl delete pvc data-mysql-0
```

**💡 存储保留策略**：
```yaml
# StatefulSet配置中的保留策略
spec:
  persistentVolumeClaimRetentionPolicy:
    whenDeleted: Retain    # 删除时保留PVC
    whenScaled: Retain     # 缩容时保留PVC
```

---

## 7. 🔧 故障排查与运维


### 7.1 常见问题诊断


**❓ Pod一直处于Pending状态**：
```bash
# 诊断命令
kubectl describe pod mysql-0 | grep -A10 "Events"

# 常见原因和解决方法
原因1: 存储卷无法创建
解决: kubectl get pvc  # 检查PVC状态
     kubectl describe pvc data-mysql-0

原因2: 节点资源不足  
解决: kubectl describe nodes
     kubectl top nodes

原因3: 镜像拉取失败
解决: kubectl logs mysql-0 -c mysql
```

**❓ StatefulSet更新卡住**：
```bash
# 检查更新状态
kubectl rollout status statefulset/mysql --timeout=300s

# 查看更新历史
kubectl rollout history statefulset/mysql

# 如果需要回滚
kubectl rollout undo statefulset/mysql
```

### 7.2 强制操作命令


**⚡ 紧急故障处理**：
```bash
# 强制删除Pod（谨慎使用！）
kubectl delete pods -l app=mysql --grace-period=0 --force

# 强制重启StatefulSet
kubectl rollout restart statefulset/mysql

# 紧急情况下绕过有序性删除
kubectl delete pod mysql-2 --grace-period=0 --force
kubectl delete pod mysql-1 --grace-period=0 --force  
kubectl delete pod mysql-0 --grace-period=0 --force
```

> **⚠️ 警告**：强制操作可能导致数据不一致，仅在紧急情况下使用！

### 7.3 监控和日志


**📊 监控命令集合**：
```bash
# 实时监控所有相关资源
watch 'kubectl get statefulsets,pods,pvc -l app=mysql'

# 查看资源使用情况
kubectl top pods -l app=mysql

# 获取详细的事件信息
kubectl get events --field-selector involvedObject.name=mysql-0 --sort-by='.lastTimestamp'

# 查看Pod日志（持续监控）
kubectl logs mysql-0 -f --tail=50
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基础概念


```
🔸 StatefulSet本质：管理有状态应用的专用控制器
🔸 三大特性：稳定网络标识、有序部署、持久化存储  
🔸 适用场景：数据库、消息队列、分布式存储系统
🔸 命名规律：$(name)-$(ordinal) 格式，从0开始编号
🔸 存储特点：PVC与Pod生命周期独立，数据持久保存
```

### 8.2 关键操作命令汇总


| **操作类别** | **核心命令** | **作用说明** |
|-------------|-------------|-------------|
| **创建管理** | `kubectl create -f statefulset.yaml` | `创建StatefulSet` |
| **状态查看** | `kubectl get statefulsets` | `列出所有StatefulSet` |
| **详细信息** | `kubectl describe statefulset [name]` | `查看详细配置和状态` |
| **扩缩容** | `kubectl scale statefulset [name] --replicas=[number]` | `调整副本数量` |
| **更新操作** | `kubectl set image statefulset/[name] [container]=[image]` | `更新容器镜像` |
| **分区更新** | `kubectl patch statefulset [name] -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":N}}}}'` | `设置分区更新策略` |
| **存储查看** | `kubectl get pvc -l app=[name]` | `查看持久化存储` |
| **Pod管理** | `kubectl get pods -l app=[name] --sort-by=.metadata.name` | `查看有序Pod列表` |

### 8.3 实战应用要点


**🎯 部署规划建议**：
```
资源规划：
- CPU/内存：根据应用需求预估，留出30%余量
- 存储容量：考虑数据增长，建议预留50%空间  
- 副本数量：奇数个副本利于选举和容错

网络配置：
- 必须创建Headless Service
- DNS名称格式要记住并在应用中使用
- 考虑Service端口和Pod端口的映射

更新策略：
- 生产环境推荐使用分区更新
- 重要系统使用OnDelete手动控制
- 测试环境可以使用默认的RollingUpdate
```

**💡 运维最佳实践**：
```
日常维护：
✅ 定期检查存储使用情况
✅ 监控Pod启动顺序和时间
✅ 备份重要的持久化数据
✅ 测试扩缩容和更新流程

故障预防：
✅ 设置适当的资源限制和请求
✅ 配置健康检查和探针
✅ 准备紧急情况的故障恢复方案
✅ 建立监控告警机制

性能优化：
✅ 使用SSD存储提高性能
✅ 调整Pod分布避免单点故障  
✅ 根据负载调整副本数量
✅ 优化容器启动时间
```

### 8.4 与其他控制器对比


| **特性对比** | **StatefulSet** | **Deployment** | **DaemonSet** |
|-------------|---------------|---------------|--------------|
| **网络标识** | `固定DNS名称` | `随机名称` | `节点固定` |
| **存储** | `持久化PVC` | `临时存储` | `节点存储` |
| **启动顺序** | `有序启动停止` | `并行启动停止` | `节点启动` |
| **适用场景** | `数据库、缓存` | `无状态应用` | `监控、日志` |
| **扩缩容** | `逐个有序` | `并行快速` | `跟随节点` |

**核心记忆要点**：
- StatefulSet = **稳定身份** + **有序管理** + **持久存储**
- 编号从0开始，按顺序创建，逆序删除
- PVC独立于Pod生命周期，删除StatefulSet数据不丢失
- 适合数据库、消息队列等需要稳定状态的应用
- 更新和扩缩容都遵循有序原则，确保应用稳定性