---
title: 35、DaemonSet守护进程管理
---
## 📚 目录

1. [DaemonSet基础概念](#1-daemonset基础概念)
2. [DaemonSet创建与查看](#2-daemonset创建与查看)
3. [DaemonSet更新与回滚](#3-daemonset更新与回滚)
4. [DaemonSet监控与调试](#4-daemonset监控与调试)
5. [DaemonSet高级配置](#5-daemonset高级配置)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🛡️ DaemonSet基础概念


### 1.1 什么是DaemonSet


**💡 通俗理解**：DaemonSet就像给每个服务器都派驻一个"守护神"

```
传统服务器管理：           Kubernetes DaemonSet：
服务器A: 需要日志收集       节点A: 自动运行日志收集Pod
服务器B: 需要日志收集       节点B: 自动运行日志收集Pod  
服务器C: 需要日志收集       节点C: 自动运行日志收集Pod

手动部署 → 繁琐易错        自动保证 → 简单可靠
```

**🔸 核心定义**：
- **DaemonSet**：确保每个Node节点都运行一个Pod副本
- **守护进程**：像系统服务一样，在后台持续运行
- **自动管理**：新节点加入时自动部署，节点删除时自动清理

### 1.2 DaemonSet典型应用场景


**🎯 常见用途**：

```
📊 系统监控类：
• 节点监控Agent (如Prometheus Node Exporter)
• 性能数据收集 (如Datadog Agent)
• 资源使用统计

📝 日志收集类：
• 日志收集Agent (如Fluentd、Filebeat)
• 审计日志收集
• 应用日志转发

🌐 网络服务类：
• 网络代理 (如kube-proxy)
• 服务网格 (如Istio sidecar)
• 网络插件

🔒 安全扫描类：
• 漏洞扫描Agent
• 安全策略执行
• 合规性检查
```

### 1.3 DaemonSet vs Deployment对比


| 特性 | **DaemonSet** | **Deployment** |
|------|---------------|----------------|
| 🎯 **部署策略** | `每个节点一个Pod` | `指定副本数量` |
| 📍 **调度方式** | `节点绑定，不可迁移` | `灵活调度，可迁移` |
| 🔄 **扩缩容** | `跟随节点数量变化` | `手动或自动扩缩容` |
| 🎨 **适用场景** | `系统级服务、监控` | `业务应用、微服务` |
| ⚖️ **负载均衡** | `不适用` | `支持负载均衡` |

---

## 2. 👀 DaemonSet创建与查看


### 2.1 查看DaemonSet基础命令


**🔍 核心查看命令**：

```bash
# 查看所有DaemonSet（完整形式）
kubectl get daemonsets

# 查看DaemonSet（简写形式）
kubectl get ds

# 查看指定命名空间的DaemonSet
kubectl get ds -n kube-system

# 查看所有命名空间的DaemonSet
kubectl get ds --all-namespaces
```

**📊 输出结果解读**：
```
NAME              DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR
fluentd-logger    3         3         3       3            3           <none>
node-exporter     3         3         2       3            2           <none>

字段说明：
DESIRED    - 期望运行的Pod数量（通常等于节点数）
CURRENT    - 当前运行的Pod数量
READY      - 就绪状态的Pod数量
UP-TO-DATE - 更新到最新版本的Pod数量
AVAILABLE  - 可用的Pod数量
```

### 2.2 查看DaemonSet详细信息


```bash
# 查看DaemonSet详细描述
kubectl describe daemonset fluentd-logger

# 查看DaemonSet的YAML配置
kubectl get ds fluentd-logger -o yaml

# 查看DaemonSet的JSON格式信息
kubectl get ds fluentd-logger -o json
```

**💡 describe输出重点关注**：
```
Events部分 - 了解创建和更新过程
Pods Status - 查看Pod运行状态
Update Strategy - 了解更新策略设置
```

### 2.3 创建DaemonSet示例


**🔧 简单DaemonSet配置**：

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-logger
  labels:
    app: node-logger
spec:
  selector:
    matchLabels:
      app: node-logger
  template:
    metadata:
      labels:
        app: node-logger
    spec:
      containers:
      - name: logger
        image: busybox:1.35
        command: ['sh', '-c', 'while true; do echo "$(date): Node logging..."; sleep 30; done']
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
```

**📝 创建和验证**：
```bash
# 创建DaemonSet
kubectl apply -f node-logger.yaml

# 验证创建结果
kubectl get ds node-logger
kubectl get pods -l app=node-logger -o wide
```

---

## 3. 🔄 DaemonSet更新与回滚


### 3.1 DaemonSet更新策略


**⚙️ 更新策略类型**：

```
RollingUpdate（滚动更新）- 默认策略：
• 逐个节点更新Pod
• 确保服务连续性
• 可控制更新速度

OnDelete（删除时更新）：
• 手动删除Pod后才更新
• 更精确的控制
• 适合关键系统服务
```

### 3.2 查看和管理更新过程


```bash
# 查看DaemonSet更新状态
kubectl rollout status daemonset/node-logger

# 查看更新历史记录
kubectl rollout history daemonset/node-logger

# 查看特定版本的详细信息
kubectl rollout history daemonset/node-logger --revision=2
```

**📈 更新状态输出示例**：
```
Waiting for daemon set "node-logger" rollout to finish: 1 out of 3 new pods have been updated...
Waiting for daemon set "node-logger" rollout to finish: 2 out of 3 new pods have been updated...
daemon set "node-logger" successfully rolled out

状态说明：
• 显示更新进度
• 实时反映Pod更新情况
• 完成时给出成功提示
```

### 3.3 执行DaemonSet更新


**🔧 镜像更新命令**：

```bash
# 更新DaemonSet镜像（推荐方式）
kubectl set image daemonset/node-logger logger=busybox:1.36

# 使用patch方式更新
kubectl patch daemonset node-logger -p '{"spec":{"template":{"spec":{"containers":[{"name":"logger","image":"busybox:1.36"}]}}}}'

# 编辑DaemonSet配置
kubectl edit daemonset node-logger
```

**⚡ 配置更新策略**：
```bash
# 设置滚动更新策略
kubectl patch daemonset node-logger -p '{
  "spec": {
    "updateStrategy": {
      "type": "RollingUpdate",
      "rollingUpdate": {
        "maxUnavailable": 1
      }
    }
  }
}'
```

### 3.4 DaemonSet回滚操作


```bash
# 回滚到上一个版本
kubectl rollout undo daemonset/node-logger

# 回滚到指定版本
kubectl rollout undo daemonset/node-logger --to-revision=1

# 验证回滚结果
kubectl rollout status daemonset/node-logger
kubectl get pods -l app=node-logger --show-labels
```

**🔍 回滚验证方法**：
```bash
# 检查Pod镜像版本
kubectl describe pods -l app=node-logger | grep Image:

# 检查更新历史
kubectl rollout history daemonset/node-logger
```

---

## 4. 📊 DaemonSet监控与调试


### 4.1 查看DaemonSet Pod分布


```bash
# 查看DaemonSet Pod在各节点的分布
kubectl get pods -l app=node-logger -o wide

# 按节点分组显示Pod
kubectl get pods -l app=node-logger -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName,STATUS:.status.phase

# 查看Pod详细信息
kubectl describe pods -l app=node-logger
```

**📍 节点分布示例**：
```
NAME                NODE           STATUS
node-logger-abc123  worker-node1   Running
node-logger-def456  worker-node2   Running  
node-logger-ghi789  worker-node3   Pending

分析要点：
✅ Running - 正常运行
⏳ Pending - 可能资源不足或调度问题
❌ Failed  - 需要查看Pod日志排查
```

### 4.2 DaemonSet故障排查


**🔍 常见问题排查步骤**：

```bash
# 1. 检查DaemonSet状态
kubectl get ds node-logger
kubectl describe ds node-logger

# 2. 检查Pod状态和事件
kubectl get pods -l app=node-logger
kubectl describe pods -l app=node-logger

# 3. 查看Pod日志
kubectl logs -l app=node-logger --tail=50

# 4. 检查节点资源
kubectl describe nodes
kubectl top nodes  # 需要metrics-server
```

**⚠️ 常见问题及解决**：

| 问题现象 | **可能原因** | **解决方法** |
|----------|-------------|-------------|
| `Pod一直Pending` | `节点资源不足` | `检查CPU/内存限制` |
| `Pod启动失败` | `镜像拉取失败` | `检查镜像名称和网络` |
| `部分节点无Pod` | `节点污点或选择器` | `检查nodeSelector和tolerations` |

### 4.3 查看DaemonSet事件和日志


```bash
# 查看DaemonSet相关事件
kubectl get events --field-selector involvedObject.name=node-logger

# 查看特定时间范围的事件
kubectl get events --field-selector involvedObject.name=node-logger --sort-by='.lastTimestamp'

# 实时查看Pod日志
kubectl logs -f -l app=node-logger

# 查看多个Pod的聚合日志
kubectl logs -l app=node-logger --tail=10 --prefix=true
```

---

## 5. ⚙️ DaemonSet高级配置


### 5.1 节点选择和调度控制


**🎯 节点选择器配置**：

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: gpu-monitor
spec:
  selector:
    matchLabels:
      app: gpu-monitor
  template:
    metadata:
      labels:
        app: gpu-monitor
    spec:
      nodeSelector:
        gpu: "true"  # 只在有GPU的节点运行
      containers:
      - name: monitor
        image: gpu-monitor:latest
```

**🔧 应用节点选择器**：
```bash
# 给节点添加标签
kubectl label nodes worker-node1 gpu=true
kubectl label nodes worker-node2 gpu=true

# 创建DaemonSet
kubectl apply -f gpu-monitor.yaml

# 验证只在指定节点运行
kubectl get pods -l app=gpu-monitor -o wide
```

### 5.2 容忍度配置（Tolerations）


**🛡️ 污点容忍配置**：

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: system-monitor
spec:
  selector:
    matchLabels:
      app: system-monitor
  template:
    metadata:
      labels:
        app: system-monitor
    spec:
      tolerations:
      - key: "node-role.kubernetes.io/control-plane"
        operator: "Exists"
        effect: "NoSchedule"  # 容忍master节点污点
      - key: "node.kubernetes.io/disk-pressure"
        operator: "Exists"
        effect: "NoSchedule"  # 容忍磁盘压力污点
      containers:
      - name: monitor
        image: system-monitor:latest
```

### 5.3 资源限制和优先级


**⚡ 资源和优先级配置**：

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: critical-logger
spec:
  selector:
    matchLabels:
      app: critical-logger
  template:
    metadata:
      labels:
        app: critical-logger
    spec:
      priorityClassName: system-node-critical  # 系统级优先级
      containers:
      - name: logger
        image: logger:stable
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        securityContext:
          privileged: true  # 需要特权访问
```

### 5.4 DaemonSet删除和清理


```bash
# 删除DaemonSet（同时删除所有Pod）
kubectl delete daemonset node-logger

# 删除DaemonSet但保留Pod（少用）
kubectl delete daemonset node-logger --cascade=orphan

# 批量删除多个DaemonSet
kubectl delete ds -l environment=test

# 强制删除卡住的DaemonSet
kubectl delete ds node-logger --force --grace-period=0
```

**🧹 清理验证**：
```bash
# 确认DaemonSet已删除
kubectl get ds node-logger

# 确认相关Pod已清理
kubectl get pods -l app=node-logger

# 检查是否有残留资源
kubectl get all -l app=node-logger
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心命令


```bash
🔍 查看命令：
kubectl get daemonsets / kubectl get ds
kubectl describe daemonset [name]
kubectl get pods -l app=[name] -o wide

🔄 更新命令：
kubectl set image daemonset/[name] [container]=[image]
kubectl rollout status daemonset/[name]
kubectl rollout history daemonset/[name]
kubectl rollout undo daemonset/[name]

⚙️ 管理命令：
kubectl patch daemonset [name] -p '[json-patch]'
kubectl delete daemonset [name]
kubectl edit daemonset [name]
```

### 6.2 关键理解要点


**🔹 DaemonSet的本质**：
```
核心概念：每个节点一个Pod的守护进程
应用场景：系统监控、日志收集、网络代理
管理特点：随节点增减自动调整副本数
```

**🔹 更新策略选择**：
```
RollingUpdate：
✅ 适合大多数场景
✅ 自动滚动更新
⚠️ 短暂服务中断

OnDelete：
✅ 手动控制更新时机
✅ 无自动更新风险
⚠️ 需要手动删除Pod触发更新
```

**🔹 故障排查思路**：
```
1. 检查DaemonSet状态 → kubectl get ds
2. 查看Pod分布情况 → kubectl get pods -o wide
3. 分析Pod启动事件 → kubectl describe pods
4. 检查应用日志 → kubectl logs
5. 验证节点资源 → kubectl describe nodes
```

### 6.3 实际应用指导


**💡 最佳实践建议**：

- **📊 监控类DaemonSet**：设置合理的资源限制，避免影响业务Pod
- **📝 日志类DaemonSet**：配置持久化存储，防止数据丢失
- **🔒 安全类DaemonSet**：使用高优先级，确保关键安全功能
- **🌐 网络类DaemonSet**：注意容忍度配置，包括master节点

**🎯 命令使用技巧**：

```bash
# 快速检查所有DaemonSet状态
kubectl get ds -o wide --all-namespaces

# 监控DaemonSet更新过程
watch kubectl get ds [name]

# 批量查看DaemonSet Pod日志
kubectl logs -l app=[name] --tail=20 --prefix=true

# 一键重启DaemonSet（通过标注触发）
kubectl patch ds [name] -p '{"spec":{"template":{"metadata":{"annotations":{"kubectl.kubernetes.io/restartedAt":"'$(date +%Y-%m-%dT%H:%M:%S%z)'"}}}}}'
```

**核心记忆口诀**：
> **DaemonSet守护每节点，系统服务它最行**  
> **get ds查状态，describe看详情**  
> **set image能更新，rollout管版本**  
> **故障排查有步骤，日志事件是关键**