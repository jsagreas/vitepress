---
title: 14、Secret密钥管理
---
## 📚 目录

1. [Secret基础概念](#1-Secret基础概念)
2. [创建Secret的多种方式](#2-创建Secret的多种方式)
3. [Secret的类型详解](#3-Secret的类型详解)
4. [查看和管理Secret](#4-查看和管理Secret)
5. [Secret在Pod中的使用](#5-Secret在Pod中的使用)
6. [Secret更新和维护](#6-Secret更新和维护)
7. [最佳实践与安全建议](#7-最佳实践与安全建议)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔒 Secret基础概念


### 1.1 什么是Secret

**简单理解**：Secret就是Kubernetes用来存储敏感信息的专门容器，比如密码、密钥、证书等不能明文显示的数据。

> 💡 **形象比喻**：
> 如果ConfigMap是公开的便利贴，那么Secret就是上锁的保险箱
> - ConfigMap：存储配置信息，谁都能看
> - Secret：存储敏感数据，需要特殊权限才能访问

### 1.2 为什么需要Secret

**现实场景问题**：
```
❌ 不安全的做法：
- 把数据库密码写在代码里
- 把API密钥放在配置文件中
- 证书文件直接放在镜像里

✅ 使用Secret的好处：
- 敏感数据与应用代码分离
- 数据自动base64编码存储
- 访问权限可控
- 支持数据加密
```

### 1.3 Secret的工作原理

```
应用程序请求敏感数据流程：

开发者                   Kubernetes集群                Pod应用
   |                          |                        |
   |--[1]创建Secret----------->|                        |
   |   kubectl create secret  |--[2]存储到etcd-------->|
   |                          |   (base64编码)         |
   |                          |                        |
   |--[3]创建Pod引用Secret---->|                        |
   |                          |--[4]挂载Secret数据---->|
   |                          |   (自动解码)           |
   |                          |                        |--[5]读取敏感数据
   |                          |                        |   正常使用
```

---

## 2. 🛠️ 创建Secret的多种方式


### 2.1 通用Secret（generic）- 最常用的方式


#### 🔸 通过字面值创建

```bash
# 创建包含用户名和密码的Secret
kubectl create secret generic mysecret \
  --from-literal=username=admin \
  --from-literal=password=123456
```

**命令解析**：
- `generic`：通用类型，适合大多数场景
- `mysecret`：Secret的名字，你可以自定义
- `--from-literal`：直接在命令行指定键值对
- `username=admin`：键是username，值是admin

#### 🔸 通过文件创建

```bash
# 先准备文件
echo -n 'admin' > username.txt
echo -n '123456' > password.txt

# 从文件创建Secret
kubectl create secret generic mysecret \
  --from-file=username.txt \
  --from-file=password.txt
```

**说明**：
- `--from-file`：从文件读取内容作为value
- 文件名自动成为key（如username.txt → username）
- 可以用`--from-file=key=filename`指定自定义key

#### 🔸 从整个目录创建

```bash
# 假设有一个包含多个配置文件的目录
mkdir myapp-secrets
echo -n 'admin' > myapp-secrets/username
echo -n '123456' > myapp-secrets/password
echo -n 'localhost:3306' > myapp-secrets/host

# 从目录创建Secret
kubectl create secret generic myapp-secret --from-file=myapp-secrets/
```

### 2.2 Docker仓库Secret（docker-registry）


**使用场景**：当你需要从私有Docker仓库拉取镜像时

```bash
# 创建Docker仓库认证Secret
kubectl create secret docker-registry myregistry-secret \
  --docker-server=registry.example.com \
  --docker-username=myuser \
  --docker-password=mypassword \
  --docker-email=user@example.com
```

**参数说明**：
- `--docker-server`：Docker仓库地址
- `--docker-username`：仓库用户名
- `--docker-password`：仓库密码
- `--docker-email`：注册邮箱（可选）

### 2.3 TLS证书Secret


**使用场景**：为HTTPS服务配置SSL/TLS证书

```bash
# 创建TLS Secret
kubectl create secret tls my-tls-secret \
  --cert=certificate.crt \
  --key=private.key
```

**前提条件**：需要先有证书文件
- `certificate.crt`：SSL证书文件
- `private.key`：私钥文件

---

## 3. 📋 Secret的类型详解


### 3.1 Secret类型对比表


| 类型 | **用途** | **常见场景** | **特点** |
|------|---------|-------------|----------|
| `Opaque` | **通用数据** | `数据库密码、API密钥` | `默认类型，最灵活` |
| `kubernetes.io/dockerconfigjson` | **Docker认证** | `私有镜像仓库` | `专门格式，自动识别` |
| `kubernetes.io/tls` | **TLS证书** | `HTTPS服务` | `包含证书和私钥` |
| `kubernetes.io/ssh-auth` | **SSH密钥** | `Git仓库访问` | `SSH私钥认证` |
| `kubernetes.io/basic-auth` | **基础认证** | `HTTP基础认证` | `用户名密码对` |

### 3.2 查看Secret类型

```bash
# 查看所有Secret及其类型
kubectl get secrets

# 输出示例：
# NAME              TYPE                             DATA   AGE
# mysecret          Opaque                           2      5m
# myregistry        kubernetes.io/dockerconfigjson   1      3m
# my-tls-secret     kubernetes.io/tls               2      2m
```

---

## 4. 🔍 查看和管理Secret


### 4.1 基本查看命令


#### 🔸 列出所有Secret

```bash
# 简单列表
kubectl get secrets

# 显示更多信息
kubectl get secrets -o wide

# 显示所有命名空间的Secret
kubectl get secrets --all-namespaces
```

#### 🔸 查看Secret详细信息

```bash
# 查看Secret的详细描述
kubectl describe secret mysecret

# 输出示例解读：
# Name:         mysecret          ← Secret名称
# Namespace:    default           ← 所在命名空间
# Type:         Opaque            ← Secret类型
# Data                            ← 数据内容
# ====
# password:  6 bytes             ← key: password，值长度6字节
# username:  5 bytes             ← key: username，值长度5字节
```

### 4.2 查看Secret实际数据


#### 🔸 查看编码后的数据

```bash
# 以YAML格式显示（数据是base64编码的）
kubectl get secret mysecret -o yaml

# 只看data字段
kubectl get secret mysecret -o jsonpath='{.data}'
```

#### 🔸 解码Secret数据（重要！）

```bash
# 解码特定的key
kubectl get secret mysecret -o jsonpath='{.data.username}' | base64 --decode

# 解码密码
kubectl get secret mysecret -o jsonpath='{.data.password}' | base64 --decode

# 一次性查看所有解码后的数据
kubectl get secret mysecret -o json | jq -r '.data | to_entries[] | "\(.key): \(.value | @base64d)"'
```

> ⚠️ **重要提醒**：
> Secret中的数据都是base64编码存储的，查看时需要解码才能看到真实内容

### 4.3 删除Secret

```bash
# 删除单个Secret
kubectl delete secret mysecret

# 删除多个Secret
kubectl delete secret secret1 secret2 secret3

# 强制删除
kubectl delete secret mysecret --force --grace-period=0
```

---

## 5. 🏗️ Secret在Pod中的使用


### 5.1 作为环境变量使用


**YAML配置示例**：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-env-pod
spec:
  containers:
  - name: myapp
    image: nginx
    env:
    - name: DB_USERNAME          # 容器内的环境变量名
      valueFrom:
        secretKeyRef:
          name: mysecret         # Secret名称
          key: username          # Secret中的key
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: password
```

**使用方式**：在容器内通过环境变量访问
```bash
# 容器内可以这样获取
echo $DB_USERNAME    # 输出：admin
echo $DB_PASSWORD    # 输出：123456
```

### 5.2 作为文件挂载使用


**YAML配置示例**：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-volume-pod
spec:
  containers:
  - name: myapp
    image: nginx
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secrets    # 容器内的挂载路径
      readOnly: true
  volumes:
  - name: secret-volume
    secret:
      secretName: mysecret       # 引用的Secret名称
```

**挂载结果**：
```
容器内文件结构：
/etc/secrets/
├── username    # 文件内容：admin
└── password    # 文件内容：123456
```

### 5.3 Docker仓库Secret的使用


**YAML配置示例**：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-image-pod
spec:
  containers:
  - name: myapp
    image: registry.example.com/myapp:latest
  imagePullSecrets:              # 指定拉取镜像用的Secret
  - name: myregistry-secret
```

---

## 6. 🔄 Secret更新和维护


### 6.1 更新Secret数据


#### 🔸 使用patch命令更新

```bash
# 更新密码字段（注意要先base64编码）
kubectl patch secret mysecret -p='{"data":{"password":"'$(echo -n "new-password" | base64)'"}}'

# 添加新的字段
kubectl patch secret mysecret -p='{"data":{"email":"'$(echo -n "user@example.com" | base64)'"}}'
```

**操作步骤详解**：
1. `echo -n "new-password"`：输出新密码（-n表示不换行）
2. `| base64`：进行base64编码
3. `$(...)`：命令替换，获取编码结果
4. `kubectl patch`：更新Secret

#### 🔸 通过编辑更新

```bash
# 直接编辑Secret（会打开默认编辑器）
kubectl edit secret mysecret

# 在编辑器中修改data字段的值（记得要base64编码）
```

### 6.2 重建Secret

```bash
# 删除旧的Secret
kubectl delete secret mysecret

# 创建新的Secret
kubectl create secret generic mysecret \
  --from-literal=username=newuser \
  --from-literal=password=newpassword
```

### 6.3 从现有Secret创建副本

```bash
# 导出现有Secret（去除敏感信息）
kubectl get secret mysecret -o yaml > mysecret-backup.yaml

# 编辑文件，修改名称和数据
# 然后创建新Secret
kubectl apply -f mysecret-backup.yaml
```

---

## 7. 🛡️ 最佳实践与安全建议


### 7.1 安全最佳实践


#### 🔸 权限控制

```yaml
# 使用RBAC限制Secret访问权限
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]      # 只允许读取，不允许修改
```

#### 🔸 命名空间隔离

```bash
# 在不同命名空间创建Secret，实现数据隔离
kubectl create namespace production
kubectl create secret generic prod-secret \
  --namespace=production \
  --from-literal=db-password=prod-password
```

### 7.2 使用建议


> 💡 **最佳实践建议**：

**✅ 推荐做法**：
- 使用专门的命名空间管理Secret
- 定期轮换敏感数据
- 使用外部密钥管理系统（如HashiCorp Vault）
- 限制Secret的访问权限
- 在CI/CD中自动化Secret管理

**❌ 避免做法**：
- 不要在Git仓库中提交Secret的YAML文件
- 不要在日志中输出Secret内容  
- 不要给所有人Secret的访问权限
- 不要在容器镜像中硬编码敏感数据

### 7.3 Secret与ConfigMap的选择


```
什么时候用Secret：                什么时候用ConfigMap：
🔒 密码、密钥                     📄 应用配置参数
🔒 SSL/TLS证书                   📄 环境变量
🔒 Docker仓库认证                📄 配置文件内容  
🔒 数据库连接字符串               📄 特性开关
🔒 API令牌                       📄 日志级别
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Secret本质：专门存储敏感数据的Kubernetes对象
🔸 数据编码：所有数据都以base64格式存储
🔸 三大类型：generic（通用）、docker-registry（镜像仓库）、tls（证书）
🔸 使用方式：环境变量、文件挂载、镜像拉取认证
🔸 安全原则：权限最小化、命名空间隔离、定期轮换
```

### 8.2 关键命令速查表


| 操作类型 | **命令示例** | **说明** |
|---------|-------------|----------|
| **创建通用Secret** | `kubectl create secret generic name --from-literal=key=value` | `最常用的创建方式` |
| **创建Docker Secret** | `kubectl create secret docker-registry name --docker-server=...` | `私有镜像仓库认证` |
| **查看Secret列表** | `kubectl get secrets` | `列出当前命名空间所有Secret` |
| **查看详细信息** | `kubectl describe secret name` | `显示Secret的元数据信息` |
| **解码查看数据** | `kubectl get secret name -o jsonpath='{.data.key}' \| base64 --decode` | `查看真实的敏感数据` |
| **更新Secret** | `kubectl patch secret name -p='{"data":{"key":"'$(echo -n "value" \| base64)'"}}'` | `更新指定字段的值` |

### 8.3 实际应用场景


**🎯 典型使用场景**：
- **微服务应用**：数据库密码、Redis密钥、第三方API密钥
- **CI/CD流水线**：Docker镜像仓库认证、Git仓库访问密钥
- **Web应用**：HTTPS证书、JWT签名密钥、OAuth密钥
- **监控系统**：监控工具的认证信息、告警通知密钥

**🔧 运维实践**：
- **开发环境**：使用简单的from-literal创建方式
- **测试环境**：通过文件批量创建Secret
- **生产环境**：结合外部密钥管理系统，实现自动轮换
- **多环境管理**：使用命名空间隔离不同环境的Secret

**核心记忆要点**：
- Secret = 上锁的保险箱，存储敏感数据
- 数据自动base64编码，查看时要解码
- 三种类型覆盖大部分场景：generic、docker-registry、tls
- 两种使用方式：环境变量简单直接，文件挂载更灵活
- 安全第一：权限控制、定期轮换、避免泄露