---
title: 6、StatefulSet有状态应用
---
## 📚 目录

1. [StatefulSet核心概念理解](#1-StatefulSet核心概念理解)
2. [有状态vs无状态应用](#2-有状态vs无状态应用)  
3. [StatefulSet工作机制](#3-StatefulSet工作机制)
4. [持久化身份标识](#4-持久化身份标识)
5. [稳定网络标识符](#5-稳定网络标识符)
6. [存储卷模板配置](#6-存储卷模板配置)
7. [有状态应用场景实践](#7-有状态应用场景实践)
8. [升级策略详解](#8-升级策略详解)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 StatefulSet核心概念理解


### 1.1 什么是StatefulSet


> 💡 **通俗理解**：如果说Deployment像是工厂流水线（每个产品都一样），那么StatefulSet就像是学校班级（每个学生都有固定的学号和座位）

**StatefulSet定义**：
```
StatefulSet = Stateful（有状态的） + Set（集合）
专门用来管理有状态应用的Kubernetes控制器
每个Pod都有固定的身份标识，就像每个学生都有学号一样
```

### 1.2 为什么需要StatefulSet


**现实场景类比**：
```
🏪 便利店（无状态）：
- 每个收银员都一样，可以随意替换
- 顾客不在乎是哪个收银员服务
- 收银员之间没有固定的关系

🏥 医院（有状态）：
- 每个医生有专门的科室和病历
- 病人需要找特定的医生
- 医生之间有主任-副主任的层级关系
```

**技术对比**：

| 特性 | **Deployment (无状态)** | **StatefulSet (有状态)** |
|------|----------------------|------------------------|
| **Pod身份** | `随机名称` | `固定名称（app-0, app-1）` |
| **启动顺序** | `同时启动` | `按顺序启动` |
| **网络标识** | `随机IP` | `固定域名` |
| **存储** | `共享或无需存储` | `每个Pod独立存储` |

### 1.3 StatefulSet适用场景


**💼 典型应用场景**：
- **数据库集群**：MySQL主从、MongoDB副本集
- **消息队列**：Kafka、RabbitMQ集群  
- **分布式存储**：Elasticsearch、Redis集群
- **有序处理系统**：需要按特定顺序处理的应用

---

## 2. ⚖️ 有状态vs无状态应用


### 2.1 无状态应用特点


**🔄 无状态应用就像自动售货机**：
```
特点：
✅ 每次交互都是独立的
✅ 不保存上次交互的信息
✅ 任何实例都能处理任何请求
✅ 可以随意增加或减少实例

举例：
- 静态网站服务器
- API网关
- 图片处理服务
```

### 2.2 有状态应用特点


**📚 有状态应用就像图书管理员**：
```
特点：
⭐ 每个实例都有独特的身份
⭐ 需要记住之前的操作状态
⭐ 实例之间可能有依赖关系
⭐ 数据通常需要持久化保存

举例：
- 数据库（需要保存数据）
- 文件系统（需要记住文件位置）
- 游戏服务器（需要记住玩家状态）
```

### 2.3 状态管理对比图


```
无状态应用架构：
┌─────────┐    ┌─────────┐    ┌─────────┐
│  Web-1  │    │  Web-2  │    │  Web-3  │
│ (随机名) │    │ (随机名) │    │ (随机名) │
└─────────┘    └─────────┘    └─────────┘
      ↑              ↑              ↑
      └──────────────┼──────────────┘
                共享存储/无存储

有状态应用架构：
┌─────────┐    ┌─────────┐    ┌─────────┐
│  DB-0   │    │  DB-1   │    │  DB-2   │
│ (主库)  │────│ (从库1) │────│ (从库2) │
└─────────┘    └─────────┘    └─────────┘
      │              │              │
┌─────────┐    ┌─────────┐    ┌─────────┐
│ 存储卷0  │    │ 存储卷1  │    │ 存储卷2  │
└─────────┘    └─────────┘    └─────────┘
```

---

## 3. ⚙️ StatefulSet工作机制


### 3.1 有序部署删除机制


**🎭 就像剧院里演员按顺序上台表演**：

**部署顺序**：
```
启动过程：
第1步：创建 app-0，等待就绪
第2步：app-0 就绪后，创建 app-1，等待就绪  
第3步：app-1 就绪后，创建 app-2，等待就绪
...

为什么要有序？
- 主从数据库：主库必须先启动
- 集群选主：第一个Pod通常是Leader
- 依赖关系：后面的Pod可能依赖前面的
```

**删除顺序**：
```
删除过程（反向进行）：
第1步：删除 app-2，等待完全删除
第2步：删除 app-1，等待完全删除
第3步：删除 app-0

为什么反向删除？
- 保护数据：从库先删，主库最后删
- 避免脑裂：确保集群正常收缩
- 优雅关闭：给每个Pod充分时间保存状态
```

### 3.2 Pod生命周期管理


**📋 StatefulSet管理流程图**：
```
用户创建StatefulSet
         ↓
    创建Headless Service
         ↓
    按顺序创建Pod
         ↓
┌─────────────────────┐
│   Pod-0 启动中      │
│   等待就绪...       │
└─────────────────────┘
         ↓
┌─────────────────────┐
│   Pod-0 就绪        │
│   开始创建Pod-1     │
└─────────────────────┘
         ↓
┌─────────────────────┐
│   Pod-1 启动中      │
│   等待就绪...       │
└─────────────────────┘
```

### 3.3 基础StatefulSet配置


```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql-cluster
spec:
  # 服务名称，用于DNS解析
  serviceName: "mysql-headless"
  # 副本数量
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
```

> ⚠️ **重要提醒**：serviceName必须指向一个Headless Service，这是StatefulSet正常工作的前提

---

## 4. 🏷️ 持久化身份标识


### 4.1 固定Pod命名规则


**🏫 就像学校里学生的学号系统**：

```
命名规则：{StatefulSet名称}-{序号}

示例：
StatefulSet名称：mysql-cluster
生成的Pod名称：
- mysql-cluster-0  (第1个，通常是主节点)
- mysql-cluster-1  (第2个)
- mysql-cluster-2  (第3个)

特点：
✅ 序号从0开始
✅ 序号永远不变
✅ Pod重建后名称保持不变
✅ 可以通过名称预测Pod身份
```

### 4.2 身份标识的重要性


**💡 为什么身份标识这么重要？**

**场景1：数据库主从配置**
```
mysql-cluster-0：主库配置
- 接收写请求
- 同步数据给从库
- 配置文件：master.cnf

mysql-cluster-1：从库配置  
- 只处理读请求
- 从主库同步数据
- 配置文件：slave.cnf
```

**场景2：Kafka集群**
```
kafka-0：Broker ID = 0
kafka-1：Broker ID = 1  
kafka-2：Broker ID = 2

每个Broker需要知道自己的ID来：
- 参与集群选举
- 管理分区副本
- 处理客户端路由
```

### 4.3 身份标识实践示例


```yaml
# 在Pod中获取自己的身份信息
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web-app
spec:
  serviceName: "web-service"
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: app
        image: nginx
        env:
        # 通过环境变量获取Pod名称
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        # 从Pod名称中提取序号
        - name: POD_INDEX  
          value: "$(POD_NAME##*-)"
```

> 💡 **小技巧**：可以在应用代码中读取环境变量POD_NAME来判断自己的角色和配置

---

## 5. 🌐 稳定网络标识符


### 5.1 Headless Service概念


**🏠 就像给每个房间都分配固定门牌号**：

```
普通Service：
客户端 → Service → 随机选择Pod
结果：不知道连接到哪个Pod

Headless Service：
客户端 → 直接连接指定Pod
结果：可以精确连接到特定Pod
```

**Headless Service配置**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-headless
spec:
  # clusterIP设为None就是Headless Service
  clusterIP: None
  selector:
    app: mysql
  ports:
  - port: 3306
```

### 5.2 DNS域名解析机制


**📞 每个Pod都有固定的"电话号码"**：

```
DNS命名规则：
{Pod名称}.{Service名称}.{命名空间}.svc.cluster.local

实际示例：
mysql-cluster-0.mysql-headless.default.svc.cluster.local
mysql-cluster-1.mysql-headless.default.svc.cluster.local
mysql-cluster-2.mysql-headless.default.svc.cluster.local

简化访问（在同一命名空间）：
mysql-cluster-0.mysql-headless
mysql-cluster-1.mysql-headless  
mysql-cluster-2.mysql-headless
```

### 5.3 网络标识符应用场景


**🎯 实际应用举例**：

**MySQL主从配置**：
```bash
# 从库连接主库
mysql --host=mysql-cluster-0.mysql-headless \
      --user=replication \
      --password=xxx

# 应用连接读库
mysql --host=mysql-cluster-1.mysql-headless \
      --user=app \
      --password=xxx
```

**Kafka集群发现**：
```properties
# Kafka配置文件
bootstrap.servers=kafka-0.kafka-headless:9092,kafka-1.kafka-headless:9092,kafka-2.kafka-headless:9092
```

**Redis集群配置**：
```bash
# Redis集群节点发现
redis-cli --cluster create \
  redis-0.redis-headless:6379 \
  redis-1.redis-headless:6379 \
  redis-2.redis-headless:6379
```

> 🔍 **关键理解**：有了稳定的网络标识符，集群内的服务就可以通过固定域名相互发现和通信

---

## 6. 💾 存储卷模板配置


### 6.1 volumeClaimTemplates概念


**📦 就像给每个学生分配独立的储物柜**：

```
普通Deployment：
所有Pod共享同一个存储卷，就像大家共用一个储物柜

StatefulSet：
每个Pod都有独立的存储卷，就像每人有自己的储物柜
而且即使Pod重建，储物柜里的东西还在
```

### 6.2 存储卷模板语法


```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql-cluster
spec:
  serviceName: "mysql-headless"
  replicas: 3
  template:
    # Pod模板配置...
  # 存储卷模板配置
  volumeClaimTemplates:
  - metadata:
      name: mysql-data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      # 存储类名称
      storageClassName: "fast-ssd"
      resources:
        requests:
          storage: 100Gi
```

**自动创建的PVC名称规则**：
```
{volumeClaimTemplates名称}-{StatefulSet名称}-{序号}

实际生成：
mysql-data-mysql-cluster-0
mysql-data-mysql-cluster-1  
mysql-data-mysql-cluster-2
```

### 6.3 存储卷生命周期管理


**🔄 存储卷的完整生命周期**：

```
创建阶段：
StatefulSet创建 → 自动创建PVC → 绑定PV → Pod挂载

使用阶段：
Pod写入数据 → 数据持久化到PV → Pod重启数据不丢失

删除阶段：
删除StatefulSet → Pod被删除 → PVC保留 → 数据保留

手动清理：
kubectl delete pvc mysql-data-mysql-cluster-0
kubectl delete pvc mysql-data-mysql-cluster-1
kubectl delete pvc mysql-data-mysql-cluster-2
```

> ⚠️ **重要警告**：删除StatefulSet不会自动删除PVC，这是为了保护数据安全

### 6.4 存储配置最佳实践


**📋 配置建议**：

| 应用类型 | **存储类型** | **访问模式** | **容量建议** |
|---------|-------------|-------------|-------------|
| **MySQL数据库** | `SSD` | `ReadWriteOnce` | `100Gi+` |
| **MongoDB** | `SSD` | `ReadWriteOnce` | `500Gi+` |
| **Elasticsearch** | `高性能SSD` | `ReadWriteOnce` | `1Ti+` |
| **Redis** | `内存+SSD` | `ReadWriteOnce` | `32Gi+` |

```yaml
# 高性能数据库配置示例
volumeClaimTemplates:
- metadata:
    name: db-data
  spec:
    accessModes: [ "ReadWriteOnce" ]
    storageClassName: "high-performance-ssd"
    resources:
      requests:
        storage: 500Gi
```

---

## 7. 🎬 有状态应用场景实践


### 7.1 MySQL主从集群部署


**🏗️ 完整的MySQL主从集群示例**：

```yaml
# Headless Service
apiVersion: v1
kind: Service
metadata:
  name: mysql-headless
spec:
  clusterIP: None
  selector:
    app: mysql
  ports:
  - port: 3306

---
# StatefulSet配置
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql-headless
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "rootpassword"
        # 根据Pod序号设置不同角色
        - name: POD_INDEX
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
        # 启动脚本：根据序号配置主从
        command:
        - /bin/bash
        - -c
        - |
          if [[ $POD_INDEX == *"-0" ]]; then
            # 主库配置
            echo "设置为主库"
          else  
            # 从库配置
            echo "设置为从库，连接mysql-0.mysql-headless"
          fi
          docker-entrypoint.sh mysqld
  volumeClaimTemplates:
  - metadata:
      name: mysql-data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 100Gi
```

### 7.2 Redis集群部署


**⚡ Redis Cluster配置示例**：

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
spec:
  serviceName: redis-headless
  replicas: 6  # Redis集群至少需要3主3从
  selector:
    matchLabels:
      app: redis-cluster
  template:
    metadata:
      labels:
        app: redis-cluster
    spec:
      containers:
      - name: redis
        image: redis:7.0-alpine
        ports:
        - containerPort: 6379
        - containerPort: 16379  # 集群总线端口
        command:
        - redis-server
        - /etc/redis/redis.conf
        - --cluster-enabled 
        - --yes
        - --cluster-config-file
        - /data/nodes.conf
        volumeMounts:
        - name: redis-data
          mountPath: /data
  volumeClaimTemplates:
  - metadata:
      name: redis-data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 20Gi
```

### 7.3 MongoDB副本集部署


**🍃 MongoDB ReplicaSet配置**：

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
spec:
  serviceName: mongodb-headless
  replicas: 3
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:6.0
        ports:
        - containerPort: 27017
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          value: admin
        - name: MONGO_INITDB_ROOT_PASSWORD
          value: password
        volumeMounts:
        - name: mongodb-data
          mountPath: /data/db
        # 初始化副本集
        lifecycle:
          postStart:
            exec:
              command:
              - /bin/bash
              - -c
              - |
                sleep 10
                if [[ $(hostname) == *"-0" ]]; then
                  mongo admin --eval '
                    rs.initiate({
                      _id: "rs0",
                      members: [
                        {_id: 0, host: "mongodb-0.mongodb-headless:27017"},
                        {_id: 1, host: "mongodb-1.mongodb-headless:27017"},  
                        {_id: 2, host: "mongodb-2.mongodb-headless:27017"}
                      ]
                    })'
                fi
  volumeClaimTemplates:
  - metadata:
      name: mongodb-data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 200Gi
```

> 💡 **实践技巧**：通过lifecycle hooks在Pod启动后执行初始化脚本，自动配置集群关系

---

## 8. 🔄 升级策略详解


### 8.1 升级策略类型


**🎯 StatefulSet支持的升级策略**：

| 策略类型 | **特点** | **适用场景** |
|---------|---------|-------------|
| **RollingUpdate** | `逐个更新，保证服务连续` | `大多数生产环境` |
| **OnDelete** | `手动控制更新时机` | `需要精确控制的场景` |

### 8.2 滚动更新机制


**🔄 RollingUpdate策略详解**：

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql-cluster
spec:
  # 升级策略配置
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      # 分区更新：只更新序号大于等于partition的Pod
      partition: 0
```

**滚动更新过程**：
```
更新顺序（从最大序号开始）：
第1步：更新 mysql-cluster-2
第2步：等待 mysql-cluster-2 就绪
第3步：更新 mysql-cluster-1  
第4步：等待 mysql-cluster-1 就绪
第5步：更新 mysql-cluster-0
第6步：等待 mysql-cluster-0 就绪

为什么从大序号开始？
- 保护主节点：通常0号是主节点，最后更新
- 减少影响：从库先更新，对服务影响小
- 验证机制：可以在更新主节点前验证从库是否正常
```

### 8.3 分区更新策略


**🎯 partition参数的妙用**：

```yaml
# 金丝雀部署：只更新部分Pod
updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    partition: 2  # 只更新序号>=2的Pod
```

**分区更新场景**：
```
原始状态：mysql-0, mysql-1, mysql-2 (都是v1.0)
设置 partition: 2

更新结果：
mysql-0: v1.0 (未更新)
mysql-1: v1.0 (未更新)  
mysql-2: v2.0 (已更新)

验证mysql-2正常后，设置partition: 1
mysql-0: v1.0 (未更新)
mysql-1: v2.0 (已更新)
mysql-2: v2.0 (已更新)

最后设置partition: 0，完成全部更新
mysql-0: v2.0 (已更新)
mysql-1: v2.0 (已更新)
mysql-2: v2.0 (已更新)
```

### 8.4 OnDelete策略


**⚡ 手动控制更新时机**：

```yaml
updateStrategy:
  type: OnDelete
```

**使用场景**：
```bash
# 1. 修改StatefulSet配置
kubectl apply -f statefulset.yaml

# 2. 此时Pod不会自动更新，需要手动删除
kubectl delete pod mysql-cluster-2
# Kubernetes会用新配置重建Pod

# 3. 验证新Pod正常后，再删除下一个
kubectl delete pod mysql-cluster-1

# 4. 最后删除主节点Pod
kubectl delete pod mysql-cluster-0
```

> 💡 **使用建议**：生产环境建议使用RollingUpdate，测试环境可以使用OnDelete进行精确控制

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🎯 StatefulSet本质：管理有状态应用的专用控制器
🔢 身份标识：每个Pod都有固定的名称和序号
🌐 网络标识：通过Headless Service提供稳定DNS名称
💾 独立存储：每个Pod都有专属的持久化存储卷
⏰有序管理：按序启动、按序删除、按序更新
🔄 状态保持：Pod重建后身份和数据都保持不变
```

### 9.2 关键理解要点


**🔹 何时使用StatefulSet**
```
✅ 需要固定身份标识的应用
✅ 需要持久化存储的应用
✅ 需要有序部署和删除的应用
✅ 需要稳定网络标识符的应用
✅ 集群类应用（数据库、消息队列等）

❌ 简单的Web应用用Deployment就够了
❌ 无状态服务不需要StatefulSet
❌ 不需要持久化的应用
```

**🔹 StatefulSet vs Deployment对比**
```
选择原则：
- 有状态、需持久化 → StatefulSet
- 无状态、可随意扩缩 → Deployment  
- 需要固定身份 → StatefulSet
- 随机身份即可 → Deployment
```

**🔹 存储管理要点**
```
重要理解：
- PVC不会随StatefulSet删除而删除
- 每个Pod都有独立的存储卷
- 存储卷名称有固定规则
- 选择合适的StorageClass很重要
```

### 9.3 实践应用指导


**📊 常见有状态应用部署要点**：

| 应用类型 | **关键配置** | **特别注意** |
|---------|-------------|-------------|
| **MySQL集群** | `配置主从关系，读写分离` | `主库(0号)最后删除` |
| **MongoDB副本集** | `初始化副本集配置` | `选举机制需要奇数个节点` |
| **Redis集群** | `集群模式配置，槽位分配` | `至少6个节点(3主3从)` |
| **Kafka集群** | `Broker ID配置，ZK连接` | `有序启动，broker.id不能冲突` |

**🛠️ 部署最佳实践**
```
部署前准备：
1. 创建Headless Service
2. 准备好StorageClass
3. 配置适当的资源限制
4. 准备初始化脚本

部署后验证：
1. 检查Pod按序启动
2. 验证DNS解析正常
3. 确认存储卷绑定成功
4. 测试应用功能正常

维护注意事项：
1. 更新时使用滚动策略
2. 删除前备份重要数据
3. 监控存储空间使用
4. 定期检查集群健康状态
```

### 9.4 故障排查指南


**🔍 常见问题及解决方法**：

**Pod一直处于Pending状态**：
```bash
# 检查PVC是否绑定成功
kubectl get pvc

# 检查StorageClass是否存在
kubectl get storageclass

# 查看Pod详细信息
kubectl describe pod <pod-name>
```

**Pod启动顺序不正确**：
```bash
# 检查StatefulSet状态
kubectl get statefulset

# 查看StatefulSet详细信息
kubectl describe statefulset <statefulset-name>
```

**网络访问异常**：
```bash
# 检查Headless Service
kubectl get service <service-name>

# 测试DNS解析
kubectl run test-pod --image=busybox -it --rm -- nslookup <pod-name>.<service-name>
```

**核心记忆口诀**：
- StatefulSet管有状态，固定身份不会变
- 按序启动按序删，网络存储都稳定  
- 主从集群数据库，消息队列都适用
- 升级策略要谨慎，数据安全第一位