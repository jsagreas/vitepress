---
title: 5、Deployment部署管理
---
## 📚 目录

1. [Deployment基础概念](#1-deployment基础概念)
2. [声明式部署原理](#2-声明式部署原理)
3. [滚动更新策略详解](#3-滚动更新策略详解)
4. [重建更新策略](#4-重建更新策略)
5. [更新参数配置](#5-更新参数配置)
6. [版本历史管理](#6-版本历史管理)
7. [版本回滚操作](#7-版本回滚操作)
8. [暂停恢复更新](#8-暂停恢复更新)
9. [扩缩容操作](#9-扩缩容操作)
10. [实战操作指南](#10-实战操作指南)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🚀 Deployment基础概念


### 1.1 什么是Deployment


**简单理解**：Deployment就像是你的**应用部署管家**，帮你管理应用的整个生命周期。

```
传统部署方式：                 Kubernetes Deployment：
手动启动服务器 ————————————→    声明期望状态
手动更新应用   ————————————→    自动滚动更新  
手动扩容缩容   ————————————→    自动伸缩管理
手动故障恢复   ————————————→    自动故障修复
```

**🔸 核心作用**
- **管理Pod**：确保指定数量的Pod始终运行
- **版本控制**：管理应用的不同版本
- **更新策略**：控制如何升级应用
- **回滚能力**：出问题时快速回到之前版本

### 1.2 Deployment的工作层次


```
Deployment (部署控制器)
    ↓ 管理
ReplicaSet (副本控制器)  
    ↓ 管理
Pod (应用实例)
    ↓ 包含
Container (容器)
```

**💡 层次关系说明**
- **Deployment**：最高层，定义部署策略和期望状态
- **ReplicaSet**：中间层，确保Pod副本数量正确
- **Pod**：实际运行层，包含你的应用容器

> ⚠️ **重要理解**：你通常只需要关心Deployment层面，下面的ReplicaSet和Pod都由Kubernetes自动管理

### 1.3 为什么要用Deployment


**🔸 传统方式的问题**
```
❌ 手动操作：容易出错，效率低
❌ 无版本控制：更新失败难以回滚  
❌ 停机更新：服务中断，用户体验差
❌ 扩容困难：需要手动配置每个实例
```

**🔸 Deployment的优势**
```
✅ 声明式配置：告诉它你要什么，它帮你实现
✅ 自动化管理：无需手动干预
✅ 零停机更新：滚动更新保证服务不中断
✅ 一键回滚：出问题立即恢复
✅ 弹性伸缩：根据需要自动调整实例数量
```

---

## 2. 📝 声明式部署原理


### 2.1 什么是声明式部署


**通俗解释**：声明式部署就像是**餐厅点菜**

```
命令式（传统方式）：           声明式（Kubernetes方式）：
"先洗菜"                      "我要一份宫保鸡丁"
"再切菜"           VS         
"然后炒菜"                    厨师自己决定具体怎么做
"最后装盘"
```

**🔸 核心理念**
- **期望状态**：你只需要说明想要的最终结果
- **现实状态**：Kubernetes观察当前实际情况
- **自动调谐**：系统自动让现实接近期望

### 2.2 声明式配置文件


```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3                    # 期望：运行3个副本
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.20        # 期望：使用nginx 1.20镜像
        ports:
        - containerPort: 80
```

**💡 配置文件说明**
- `replicas: 3`：告诉Kubernetes你要3个nginx实例
- `image: nginx:1.20`：指定使用的镜像版本
- 其他细节Kubernetes自动处理

### 2.3 声明式vs命令式对比


| 方面 | **命令式** | **声明式** |
|------|------------|------------|
| 思维方式 | "怎么做" | "要什么" |
| 配置方式 | `kubectl run nginx` | YAML配置文件 |
| 版本管理 | ❌ 难以追踪 | ✅ Git管理配置 |
| 重复执行 | ❌ 可能出错 | ✅ 幂等性保证 |
| 团队协作 | ❌ 难以共享 | ✅ 代码化配置 |

---

## 3. 🔄 滚动更新策略详解


### 3.1 什么是滚动更新


**生活比喻**：滚动更新就像**轮班换岗**

```
旧版本服务员：👨‍💼👨‍💼👨‍💼     新版本服务员：👩‍💼👩‍💼👩‍💼

第1步：👨‍💼👨‍💼👨‍💼 + 👩‍💼        (新增1个新版本)
第2步：👨‍💼👨‍💼 + 👩‍💼👩‍💼        (再换1个)  
第3步：👨‍💼 + 👩‍💼👩‍💼👩‍💼        (继续替换)
第4步：👩‍💼👩‍💼👩‍💼              (完全替换)
```

**🔸 核心特点**
- **渐进式替换**：一个一个慢慢替换，不是全部一起换
- **保证可用性**：始终有服务在运行，用户感受不到中断
- **可控速度**：可以控制替换的快慢

### 3.2 滚动更新配置


```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 6
  strategy:
    type: RollingUpdate              # 指定滚动更新策略
    rollingUpdate:
      maxSurge: 2                    # 更新时最多可以多出2个Pod
      maxUnavailable: 1              # 更新时最多允许1个Pod不可用
  template:
    spec:
      containers:
      - name: nginx
        image: nginx:1.21            # 新版本镜像
```

**💡 参数解释**
- `maxSurge: 2`：更新时可以临时多创建2个Pod（总数可达8个）
- `maxUnavailable: 1`：更新时最多允许1个Pod不工作（最少5个可用）

### 3.3 滚动更新流程演示


```
假设有6个Pod，更新nginx从1.20到1.21：

初始状态：[1.20] [1.20] [1.20] [1.20] [1.20] [1.20]  (6个运行)

步骤1：   [1.20] [1.20] [1.20] [1.20] [1.20] [1.20] [1.21] [1.21]  (新增2个)
步骤2：   [1.20] [1.20] [1.20] [1.20] [停止] [停止] [1.21] [1.21]  (停止2个旧的)
步骤3：   [1.20] [1.20] [1.20] [1.20] [1.21] [1.21] [1.21] [1.21]  (启动2个新的)
步骤4：   [停止] [停止] [1.20] [1.20] [1.21] [1.21] [1.21] [1.21]  (继续替换)
步骤5：   [1.21] [1.21] [1.20] [1.20] [1.21] [1.21] [1.21] [1.21]  (启动新的)
步骤6：   [1.21] [1.21] [停止] [停止] [1.21] [1.21] [1.21] [1.21]  (停止剩余旧的)
结果：   [1.21] [1.21] [1.21] [1.21] [1.21] [1.21]  (全部更新完成)
```

> ✅ **关键优势**：整个过程中始终有足够的Pod在服务用户请求

---

## 4. 🔄 重建更新策略


### 4.1 什么是重建策略


**生活比喻**：重建策略就像**装修房子**

```
滚动更新 = 边住边装修：        重建更新 = 搬出去重装：
👥————————————————→👥          👥————→❌————→👥
(始终有人住)                  (暂时没人住)
```

**🔸 工作过程**
1. **先停止**所有旧版本Pod
2. **等待完全停止**后，再启动新版本Pod
3. **全部替换**，没有中间状态

### 4.2 重建策略配置


```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  strategy:
    type: Recreate                   # 重建策略
  template:
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
```

### 4.3 重建vs滚动更新对比


| 对比维度 | **滚动更新** | **重建策略** |
|----------|--------------|--------------|
| **服务可用性** | ✅ 无中断 | ❌ 有中断 |
| **更新速度** | ⚡ 较慢 | ⚡ 很快 |
| **资源占用** | 📊 更多（临时） | 📊 更少 |
| **适用场景** | 🌐 Web服务 | 💾 数据库迁移 |
| **风险控制** | ✅ 渐进式 | ❌ 一次性 |

### 4.4 什么时候用重建策略


**🔸 适合场景**
```
✅ 数据库升级：需要数据迁移，不能同时运行新旧版本
✅ 有状态服务：多个实例可能冲突  
✅ 资源限制：集群资源不足，无法同时运行新旧版本
✅ 测试环境：可以容忍短暂中断
```

**🔸 不适合场景**
```
❌ 生产环境Web服务：用户体验差
❌ 高可用要求：不能容忍服务中断
❌ 微服务架构：会影响整个服务链
```

---

## 5. ⚙️ 更新参数配置


### 5.1 maxSurge参数详解


**通俗理解**：maxSurge就是**临时加班人员数量**

```yaml
spec:
  replicas: 10
  strategy:
    rollingUpdate:
      maxSurge: 25%                  # 可以是百分比
      # maxSurge: 3                  # 也可以是绝对数字
```

**🔸 参数计算**
- `maxSurge: 25%`：10个Pod的25% = 2.5，向上取整 = 3
- 更新时最多可以有：10 + 3 = 13个Pod同时运行

**💡 实际影响**
```
maxSurge越大：
✅ 更新越快（并行度高）
❌ 资源消耗越多（临时多出很多Pod）

maxSurge越小：  
✅ 资源消耗少
❌ 更新越慢（并行度低）
```

### 5.2 maxUnavailable参数详解


**通俗理解**：maxUnavailable就是**允许请假的人数**

```yaml
spec:
  replicas: 10  
  strategy:
    rollingUpdate:
      maxUnavailable: 2              # 允许2个Pod不可用
      # maxUnavailable: 20%          # 也可以用百分比
```

**🔸 参数计算**
- `maxUnavailable: 2`：更新时可以停止2个旧Pod
- 保证至少有：10 - 2 = 8个Pod在运行

**💡 实际影响**
```
maxUnavailable越大：
✅ 更新越快（可以同时停止更多旧Pod）
❌ 可用性风险（运行的Pod变少）

maxUnavailable越小：
✅ 可用性更好（始终保持更多Pod运行）  
❌ 更新越慢（只能少量替换）
```

### 5.3 参数组合策略


**🔸 保守策略**（适合生产环境）
```yaml
rollingUpdate:
  maxSurge: 1
  maxUnavailable: 0
```
- 特点：**绝对不中断**服务，但更新很慢
- 适用：关键业务系统

**🔸 平衡策略**（最常用）
```yaml  
rollingUpdate:
  maxSurge: 25%
  maxUnavailable: 25%
```
- 特点：**速度和稳定性**兼顾
- 适用：一般Web应用

**🔸 激进策略**（适合测试环境）
```yaml
rollingUpdate:
  maxSurge: 100%
  maxUnavailable: 50%
```
- 特点：**更新很快**，但资源消耗大
- 适用：开发测试环境

> ⚠️ **注意**：maxSurge和maxUnavailable不能同时为0

---

## 6. 📚 版本历史管理


### 6.1 什么是版本历史


**生活比喻**：版本历史就像**文档修改记录**

```
Word文档修改历史：              Deployment版本历史：
版本1: 初稿                    版本1: nginx:1.18
版本2: 修改标题                版本2: nginx:1.19  
版本3: 添加内容                版本3: nginx:1.20
版本4: 修正错误                版本4: nginx:1.21
```

**🔸 核心功能**
- **记录变更**：每次更新都会产生新的版本记录
- **追踪历史**：可以查看所有历史版本
- **支持回滚**：出问题时可以回到任意历史版本

### 6.2 查看部署历史


```bash
# 查看Deployment的滚动更新历史
kubectl rollout history deployment/nginx-deployment

# 输出示例：
REVISION  CHANGE-CAUSE
1         <none>
2         kubectl set image deployment/nginx-deployment nginx=nginx:1.19
3         kubectl set image deployment/nginx-deployment nginx=nginx:1.20  
4         kubectl set image deployment/nginx-deployment nginx=nginx:1.21
```

**💡 命令说明**
- `REVISION`：版本号，每次更新递增
- `CHANGE-CAUSE`：变更原因（需要手动添加注释）

### 6.3 添加变更记录


```bash
# 方法1：更新时添加注释
kubectl set image deployment/nginx-deployment nginx=nginx:1.22 \
  --record=true

# 方法2：在配置文件中添加注释
kubectl apply -f deployment.yaml \
  --record=true

# 方法3：使用注解
kubectl annotate deployment/nginx-deployment \
  kubernetes.io/change-cause="更新到nginx 1.22版本"
```

### 6.4 版本保留策略


```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  revisionHistoryLimit: 10           # 保留10个历史版本
  # 其他配置...
```

**🔸 参数说明**
- **默认值**：10个版本
- **建议值**：5-15个（根据实际需要）
- **影响**：版本过多会占用etcd存储空间

> 💡 **最佳实践**：生产环境建议保留10-15个版本，测试环境可以保留5个

---

## 7. ↩️ 版本回滚操作


### 7.1 什么是版本回滚


**生活比喻**：版本回滚就像**撤销操作**

```
Word文档：Ctrl+Z撤销            Kubernetes：kubectl rollout undo
文档回到上一个状态             应用回到上一个版本

游戏存档：读取之前的存档         部署回滚：恢复到之前的配置
```

**🔸 回滚场景**
- **新版本有Bug**：功能异常，影响用户使用
- **性能问题**：新版本比旧版本慢很多
- **兼容性问题**：与其他服务不兼容
- **配置错误**：部署配置有误

### 7.2 快速回滚操作


```bash
# 回滚到上一个版本（最常用）
kubectl rollout undo deployment/nginx-deployment

# 查看回滚状态
kubectl rollout status deployment/nginx-deployment

# 验证回滚结果
kubectl get pods
```

**💡 操作说明**
- `undo`：撤销最近的一次更新
- **自动执行**：Kubernetes自动处理回滚过程
- **滚动回滚**：同样使用滚动更新策略，保证服务不中断

### 7.3 回滚到指定版本


```bash
# 先查看历史版本
kubectl rollout history deployment/nginx-deployment

# 查看特定版本的详细信息
kubectl rollout history deployment/nginx-deployment --revision=2

# 回滚到指定版本
kubectl rollout undo deployment/nginx-deployment --to-revision=2
```

**🔸 版本选择技巧**
```
--to-revision=1    # 回滚到第1个版本（最初版本）
--to-revision=3    # 回滚到第3个版本  
不指定revision      # 回滚到上一个版本（最常用）
```

### 7.4 回滚验证流程


```bash
# 第1步：执行回滚
kubectl rollout undo deployment/nginx-deployment

# 第2步：查看回滚进度
kubectl rollout status deployment/nginx-deployment
# 等待输出：deployment "nginx-deployment" successfully rolled out

# 第3步：验证Pod状态
kubectl get pods -l app=nginx

# 第4步：验证镜像版本
kubectl describe deployment nginx-deployment | grep Image

# 第5步：测试应用功能
curl http://your-service-ip
```

> ✅ **回滚优势**：通常比正常更新更快，因为镜像可能已经在节点上缓存了

---

## 8. ⏸️ 暂停恢复更新


### 8.1 为什么要暂停更新


**生活比喻**：暂停更新就像**红绿灯控制**

```
道路施工：                     Deployment更新：
🚧 暂停通行（观察情况）        ⏸️ 暂停更新（观察Pod状态）
✅ 恢复通行（确认安全）        ▶️ 恢复更新（确认正常）
```

**🔸 使用场景**
- **分步验证**：更新一部分Pod后，先验证功能是否正常
- **问题诊断**：发现异常时暂停更新，避免影响扩大
- **资源控制**：暂时暂停，等待集群资源充足
- **审批流程**：等待人工确认后再继续

### 8.2 暂停更新操作


```bash
# 开始一个更新（但立即暂停观察）
kubectl set image deployment/nginx-deployment nginx=nginx:1.22
kubectl rollout pause deployment/nginx-deployment

# 查看当前状态
kubectl rollout status deployment/nginx-deployment
# 输出：Waiting for deployment "nginx-deployment" rollout to finish: 1 out of 3 new replicas have been updated...

# 查看Pod状态（会看到新旧版本混合）
kubectl get pods -l app=nginx
```

**💡 暂停后的状态**
- **部分更新**：只有部分Pod更新到新版本
- **混合运行**：新旧版本Pod同时存在
- **等待恢复**：更新进程暂停，等待手动恢复

### 8.3 验证和恢复更新


```bash
# 第1步：验证新版本Pod
kubectl logs -l app=nginx,version=new    # 查看新版本日志
kubectl exec -it new-pod -- nginx -t     # 测试配置是否正确

# 第2步：测试服务功能  
curl http://service-ip/health             # 健康检查
curl http://service-ip/api/test          # 功能测试

# 第3步：如果正常，恢复更新
kubectl rollout resume deployment/nginx-deployment

# 第4步：如果异常，直接回滚
kubectl rollout undo deployment/nginx-deployment
```

### 8.4 暂停更新的完整流程


```
更新流程控制示例：

1. 开始更新并立即暂停：
   kubectl set image deployment/nginx nginx=nginx:1.22
   kubectl rollout pause deployment/nginx

2. 观察状态（假设3个副本）：
   [旧版本] [旧版本] [新版本]    # 只更新了1个

3. 验证新版本：
   kubectl logs new-pod                   # 检查日志
   curl http://new-pod-ip/health          # 测试功能

4. 决策分支：
   ✅ 如果正常 → kubectl rollout resume deployment/nginx
   ❌ 如果异常 → kubectl rollout undo deployment/nginx
```

> 💡 **最佳实践**：重要的生产环境更新建议使用暂停策略，分阶段验证

---

## 9. 📈 扩缩容操作


### 9.1 什么是扩缩容


**生活比喻**：扩缩容就像**调整服务员数量**

```
餐厅管理：                     Kubernetes扩缩容：
客人多了 → 多叫几个服务员      访问量大 → 增加Pod数量（扩容）
客人少了 → 让部分服务员下班    访问量小 → 减少Pod数量（缩容）
```

**🔸 核心概念**
- **扩容（Scale Out）**：增加Pod副本数量
- **缩容（Scale In）**：减少Pod副本数量  
- **水平扩展**：通过增加实例数量提升性能
- **自动调整**：根据负载自动伸缩

### 9.2 手动扩缩容操作


```bash
# 方法1：使用kubectl scale命令
kubectl scale deployment/nginx-deployment --replicas=5

# 方法2：修改YAML文件
kubectl patch deployment nginx-deployment -p '{"spec":{"replicas":8}}'

# 方法3：编辑Deployment配置
kubectl edit deployment nginx-deployment
# 找到 replicas: 3，修改为 replicas: 10，保存退出
```

**💡 查看扩缩容过程**
```bash
# 实时观察Pod创建过程
kubectl get pods -w -l app=nginx

# 查看扩缩容状态
kubectl rollout status deployment/nginx-deployment
```

### 9.3 扩缩容实际演示


```
假设原有3个Pod，扩容到6个：

初始状态：
[Pod-1] [Pod-2] [Pod-3]

执行命令：kubectl scale deployment/nginx-deployment --replicas=6

扩容过程：
[Pod-1] [Pod-2] [Pod-3] [创建中] [创建中] [创建中]
    ↓
[Pod-1] [Pod-2] [Pod-3] [Pod-4] [Pod-5] [Pod-6]

缩容到2个的过程：
[Pod-1] [Pod-2] [Pod-3] [Pod-4] [Pod-5] [Pod-6]
    ↓
[Pod-1] [Pod-2] [终止中] [终止中] [终止中] [终止中]  
    ↓
[Pod-1] [Pod-2]
```

### 9.4 扩缩容策略考虑


**🔸 扩容考虑因素**
```
✅ 集群资源充足：CPU、内存、存储够用
✅ 网络负载均衡：流量能够分配到新Pod
✅ 数据库连接：数据库能承受更多连接
✅ 许可证限制：软件授权是否支持更多实例
```

**🔸 缩容考虑因素**
```
⚠️ 请求处理中：等待当前请求处理完成
⚠️ 会话保持：用户会话可能丢失
⚠️ 数据备份：有状态服务需要数据备份
⚠️ 最小副本数：至少保留1个副本运行
```

### 9.5 扩缩容最佳实践


```yaml
# Deployment配置示例
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 3                    # 初始副本数
  template:
    spec:
      containers:
      - name: web
        image: my-web-app:1.0
        resources:
          requests:              # 资源请求（用于调度）
            cpu: 100m
            memory: 128Mi
          limits:                # 资源限制（防止超用）
            cpu: 500m  
            memory: 512Mi
        readinessProbe:          # 就绪检查（新Pod何时接收流量）
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
        livenessProbe:           # 存活检查（Pod是否健康）
          httpGet:
            path: /health
            port: 8080
          periodSeconds: 10
```

---

## 10. 🛠️ 实战操作指南


### 10.1 创建Deployment完整流程


```bash
# 第1步：创建部署配置文件
cat > nginx-deployment.yaml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.20
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
EOF

# 第2步：应用配置
kubectl apply -f nginx-deployment.yaml --record=true

# 第3步：验证创建结果
kubectl get deployments
kubectl get replicasets  
kubectl get pods -l app=nginx
```

### 10.2 完整更新流程示例


```bash
# 场景：将nginx从1.20更新到1.21

# 第1步：查看当前状态
kubectl get deployments nginx-deployment
kubectl rollout history deployment/nginx-deployment

# 第2步：执行更新
kubectl set image deployment/nginx-deployment nginx=nginx:1.21 --record=true

# 第3步：观察更新过程  
kubectl rollout status deployment/nginx-deployment
kubectl get pods -l app=nginx -w    # 实时观察Pod变化

# 第4步：验证更新结果
kubectl describe deployment nginx-deployment | grep Image
curl http://service-ip    # 测试服务功能

# 第5步：如果发现问题，立即回滚
kubectl rollout undo deployment/nginx-deployment
```

### 10.3 生产环境更新策略


```bash
# 生产环境谨慎更新流程

# 第1步：在测试环境验证新版本
kubectl apply -f nginx-deployment-test.yaml -n test

# 第2步：生产环境开始更新并立即暂停
kubectl set image deployment/nginx-deployment nginx=nginx:1.21 --record=true
kubectl rollout pause deployment/nginx-deployment

# 第3步：观察部分更新的Pod
kubectl get pods -l app=nginx
kubectl logs -l app=nginx,pod-template-hash=新版本hash

# 第4步：验证新版本功能
curl http://new-pod-ip/health
curl http://new-pod-ip/api/status

# 第5步：监控指标（CPU、内存、错误率）
kubectl top pods -l app=nginx
# 查看监控系统（如Prometheus）

# 第6步：决策
# 如果一切正常：
kubectl rollout resume deployment/nginx-deployment
# 如果发现问题：
kubectl rollout undo deployment/nginx-deployment
```

### 10.4 常见问题诊断


```bash
# 问题1：Pod无法启动
kubectl describe pod pod-name
kubectl logs pod-name

# 问题2：更新卡住不动
kubectl rollout status deployment/nginx-deployment
kubectl get events --sort-by=.metadata.creationTimestamp

# 问题3：服务访问异常
kubectl get svc nginx-service
kubectl describe svc nginx-service
kubectl get endpoints nginx-service

# 问题4：资源不足
kubectl describe nodes
kubectl top nodes
kubectl top pods
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 Deployment本质：应用部署的管家，管理整个生命周期
🔸 声明式部署：告诉Kubernetes你要什么，不用管怎么实现
🔸 滚动更新：渐进式替换，保证服务不中断
🔸 版本管理：记录历史，支持快速回滚
🔸 扩缩容：根据负载调整Pod数量
```

### 11.2 关键操作命令速查


| 操作类型 | **命令** | **说明** |
|----------|----------|----------|
| **创建部署** | `kubectl apply -f deploy.yaml` | 声明式创建 |
| **查看状态** | `kubectl get deployments` | 查看所有部署 |
| **更新镜像** | `kubectl set image deploy/名称 容器=镜像` | 滚动更新 |
| **查看历史** | `kubectl rollout history deploy/名称` | 版本历史 |
| **回滚版本** | `kubectl rollout undo deploy/名称` | 快速回滚 |
| **暂停更新** | `kubectl rollout pause deploy/名称` | 暂停更新 |
| **恢复更新** | `kubectl rollout resume deploy/名称` | 恢复更新 |
| **扩缩容** | `kubectl scale deploy/名称 --replicas=数量` | 调整副本 |

### 11.3 实际应用指导


**🔸 新手使用建议**
```
✅ 从简单配置开始：先掌握基本的replicas、image配置
✅ 使用YAML文件：避免命令行配置，便于版本管理
✅ 添加资源限制：防止Pod消耗过多资源
✅ 配置健康检查：确保Pod真正可用才接收流量
✅ 测试环境练习：先在测试环境熟悉所有操作
```

**🔸 生产环境最佳实践**
```
🎯 保守的更新策略：maxSurge=25%, maxUnavailable=25%
🎯 保留足够历史版本：revisionHistoryLimit=10
🎯 使用暂停更新：重要更新分阶段验证
🎯 监控和告警：配置Pod、资源、错误率监控
🎯 快速回滚预案：出问题立即回滚，事后分析
```

### 11.4 学习路线建议


```
第1阶段：理解概念
→ Deployment、ReplicaSet、Pod的关系
→ 声明式vs命令式的区别

第2阶段：基础操作  
→ 创建、更新、删除Deployment
→ 查看状态、日志、描述信息

第3阶段：更新策略
→ 掌握滚动更新和重建策略
→ 理解maxSurge和maxUnavailable参数

第4阶段：版本管理
→ 查看历史版本，执行回滚操作
→ 使用暂停恢复功能

第5阶段：生产实践
→ 结合监控系统，制定更新策略
→ 制定故障应急预案
```

**核心记忆**：
- Deployment是Kubernetes中管理应用部署的核心工具
- 声明式配置让你专注于"要什么"而不是"怎么做"  
- 滚动更新保证服务零中断，版本管理支持快速回滚
- 掌握基本操作命令，理解更新策略参数含义
- 生产环境要谨慎操作，测试环境多练习