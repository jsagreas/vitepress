---
title: 5、服务网格集成
---
## 📚 目录

1. [什么是服务网格](#1-什么是服务网格)
2. [Istio核心架构详解](#2-Istio核心架构详解)
3. [Sidecar代理注入机制](#3-Sidecar代理注入机制)
4. [流量管理规则配置](#4-流量管理规则配置)
5. [安全策略配置实战](#5-安全策略配置实战)
6. [可观测性增强功能](#6-可观测性增强功能)
7. [服务治理核心能力](#7-服务治理核心能力)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 什么是服务网格


### 1.1 服务网格的本质理解


**🔸 服务网格就是微服务间的"交通管制系统"**

想象一下城市交通：
```
传统方式（没有服务网格）：
汽车A → 直接开到 → 汽车B的位置
问题：找不到路、堵车、事故、迷路

服务网格方式：
汽车A → 交通管制中心 → 最优路径 → 汽车B
优势：统一调度、监控、安全、优化
```

**💡 用大白话解释服务网格**

服务网格就是在每个微服务旁边放一个"**智能助手**"，这个助手负责：
- 📞 **通讯管家**：帮你的服务找到其他服务在哪
- 🛡️ **安全保镖**：检查是否允许访问，加密通信
- 📊 **数据收集员**：记录访问数据，监控性能
- 🚦 **流量指挥员**：控制访问流量，负载均衡

### 1.2 为什么需要服务网格


**🤔 没有服务网格的痛点**

```
传统微服务架构的问题：

服务A代码：
class ServiceA {
    // 业务逻辑
    processOrder() { ... }
    
    // 还要处理这些非业务逻辑：
    - 服务发现：UserService在哪个IP？
    - 负载均衡：调用哪个实例？
    - 重试机制：失败了怎么办？
    - 熔断降级：服务挂了怎么办？
    - 监控日志：调用是否成功？
    - 安全认证：是否有权限？
}

问题：业务代码被非业务逻辑污染了！
```

**✅ 有了服务网格的好处**

```
服务网格架构：

服务A代码：
class ServiceA {
    // 只需要关心业务逻辑
    processOrder() { ... }
    callUserService() { 
        // 直接调用，其他事情Sidecar处理
        return http.get("http://user-service/api/user")
    }
}

Sidecar代理自动处理：
✓ 服务发现
✓ 负载均衡  
✓ 重试熔断
✓ 安全认证
✓ 监控日志
```

### 1.3 服务网格核心概念


| 概念 | **通俗解释** | **技术含义** | **实际作用** |
|------|-------------|-------------|-------------|
| 🏢 **数据面** | `每个服务旁边的助手` | `Sidecar代理` | `处理实际流量转发` |
| 🎛️ **控制面** | `总指挥部` | `管理和配置中心` | `下发策略和配置` |
| 🚀 **Sidecar** | `贴身保镖` | `代理容器` | `拦截所有网络流量` |
| 📋 **策略** | `游戏规则` | `流量管理规则` | `定义如何处理请求` |

---

## 2. 🏗️ Istio核心架构详解


### 2.1 Istio整体架构图解


```
Istio服务网格架构：

┌─────────────────────────────────────────────────────────┐
│                    控制面 (Control Plane)               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Istiod    │  │   Pilot     │  │   Citadel   │     │
│  │ (统一控制器) │  │ (流量管理)   │  │ (安全管理)   │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└─────────────────────┬───────────────────────────────────┘
                      │ 配置下发
                      ▼
┌─────────────────────────────────────────────────────────┐
│                    数据面 (Data Plane)                  │
│                                                         │
│  Pod A               Pod B               Pod C          │
│ ┌─────┬─────┐       ┌─────┬─────┐       ┌─────┬─────┐   │
│ │App  │Envoy│◄─────►│App  │Envoy│◄─────►│App  │Envoy│   │
│ │     │Proxy│       │     │Proxy│       │     │Proxy│   │
│ └─────┴─────┘       └─────┴─────┘       └─────┴─────┘   │
└─────────────────────────────────────────────────────────┘

流量路径：App A → Envoy A → Envoy B → App B
```

### 2.2 Istio核心组件详解


**🎛️ Istiod：大脑中枢**

```
Istiod就像城市的交通管制中心：

功能职责：
├─ 🗺️  服务发现：知道每个服务在哪里
├─ 📋  配置管理：制定流量规则
├─ 🔐  证书管理：颁发安全证书
└─ 📊  遥测数据：收集监控信息

技术实现：
- 监听Kubernetes API
- 将配置转换为Envoy配置
- 通过xDS协议下发给Sidecar
```

**🚀 Envoy：贴身代理**

```
Envoy就像每个服务的专职司机：

核心能力：
├─ 🔀 流量代理：拦截所有进出流量
├─ 🎯 负载均衡：选择最佳目标实例
├─ 🔄 重试机制：失败时自动重试
├─ 🛡️ 安全防护：TLS加密、认证授权
└─ 📈 数据收集：记录访问指标

工作模式：透明代理
- 应用无感知
- 自动拦截网络调用
```

### 2.3 Istio安装和基本配置


**📦 Istio安装步骤**

```bash
# 1. 下载Istio
curl -L https://istio.io/downloadIstio | sh -
cd istio-*
export PATH=$PWD/bin:$PATH

# 2. 安装Istio到Kubernetes
istioctl install --set values.defaultRevision=default -y

# 3. 启用自动注入
kubectl label namespace default istio-injection=enabled

# 4. 验证安装
kubectl get pods -n istio-system
```

**✅ 验证Istio是否正常工作**

```yaml
# 部署示例应用
apiVersion: v1
kind: Service
metadata:
  name: productpage
  labels:
    app: productpage
spec:
  ports:
  - port: 9080
    name: http
  selector:
    app: productpage
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: productpage-v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: productpage
      version: v1
  template:
    metadata:
      labels:
        app: productpage
        version: v1
    spec:
      containers:
      - name: productpage
        image: docker.io/istio/examples-bookinfo-productpage-v1:1.16.2
        ports:
        - containerPort: 9080
```

---

## 3. 💉 Sidecar代理注入机制


### 3.1 什么是Sidecar注入


**🏠 Sidecar模式类比理解**

```
传统单体应用：
┌─────────────────┐
│   一个大房子     │ ← 所有功能都在一起
│ ┌─────────────┐ │
│ │  全部功能   │ │
│ └─────────────┘ │
└─────────────────┘

Sidecar模式：
┌─────────────┐  ┌─────────────┐
│   主房间    │  │   助手房间   │ ← 专门的助手
│ ┌─────────┐ │  │ ┌─────────┐ │
│ │ 业务逻辑│ │  │ │网络代理 │ │
│ └─────────┘ │  │ └─────────┘ │
└─────────────┘  └─────────────┘
     主容器           Sidecar容器
```

**💡 Sidecar注入原理**

```
注入前的Pod：
┌─────────────────┐
│      Pod        │
│  ┌───────────┐  │
│  │    App    │  │ ← 只有应用容器
│  └───────────┘  │
└─────────────────┘

注入后的Pod：
┌─────────────────┐
│      Pod        │
│  ┌───────────┐  │
│  │    App    │  │ ← 应用容器
│  └───────────┘  │
│  ┌───────────┐  │
│  │   Envoy   │  │ ← 自动注入的代理
│  └───────────┘  │
└─────────────────┘
```

### 3.2 注入方式对比


| 注入方式 | **触发条件** | **使用场景** | **优缺点** |
|---------|-------------|-------------|-----------|
| 🤖 **自动注入** | `namespace标签` | `生产环境批量部署` | `方便但难控制` |
| ✋ **手动注入** | `手动执行命令` | `测试环境精确控制` | `灵活但繁琐` |

**🤖 自动注入配置**

```bash
# 为命名空间启用自动注入
kubectl label namespace production istio-injection=enabled

# 查看标签
kubectl get namespace -L istio-injection

# 禁用自动注入
kubectl label namespace production istio-injection-
```

**✋ 手动注入示例**

```bash
# 手动注入Sidecar
istioctl kube-inject -f app.yaml | kubectl apply -f -

# 或者生成注入后的YAML查看
istioctl kube-inject -f app.yaml > app-with-sidecar.yaml
```

### 3.3 注入配置详解


**⚙️ 注入行为控制**

```yaml
# 精细控制注入行为
apiVersion: v1
kind: Pod
metadata:
  name: my-app
  annotations:
    sidecar.istio.io/inject: "true"    # 强制注入
    # sidecar.istio.io/inject: "false" # 强制不注入
spec:
  containers:
  - name: app
    image: my-app:latest
```

**🔧 Sidecar资源配置**

```yaml
apiVersion: v1
kind: Pod  
metadata:
  name: my-app
  annotations:
    sidecar.istio.io/proxyCPU: "100m"      # CPU限制
    sidecar.istio.io/proxyMemory: "128Mi"  # 内存限制
    sidecar.istio.io/logLevel: "info"      # 日志级别
spec:
  containers:
  - name: app
    image: my-app:latest
```

---

## 4. 🚦 流量管理规则配置


### 4.1 流量管理核心概念


**🛣️ 流量管理就像道路规划**

```
没有流量规则：
用户请求 → 随机选择服务实例 → 可能不均衡

有了流量规则：
用户请求 → 按规则分配 → 精确控制
           ├─ 70%到v1版本  
           └─ 30%到v2版本
```

**📋 流量管理资源类型**

| 资源类型 | **作用** | **类比理解** |
|---------|---------|-------------|
| 🌐 **VirtualService** | `定义路由规则` | `导航地图` |
| 🎯 **DestinationRule** | `定义目标策略` | `目的地规则` |
| 🚪 **Gateway** | `定义入口网关` | `大门守卫` |
| 📏 **ServiceEntry** | `添加外部服务` | `通行证` |

### 4.2 VirtualService：路由规则


**🗺️ VirtualService基本用法**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: productpage
spec:
  hosts:
  - productpage                    # 匹配的服务名
  http:
  - match:
    - headers:                     # 根据请求头路由
        end-user:
          exact: jason            # 用户jason走特殊路径
    route:
    - destination:
        host: productpage
        subset: v2               # 路由到v2版本
  - route:
    - destination:
        host: productpage
        subset: v1               # 其他用户走v1版本
```

**🔄 流量分割示例**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews-split
spec:
  hosts:
  - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v1
      weight: 80                 # 80%流量到v1
    - destination:
        host: reviews  
        subset: v2
      weight: 20                 # 20%流量到v2
```

### 4.3 DestinationRule：目标规则


**🎯 DestinationRule配置详解**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: productpage
spec:
  host: productpage
  trafficPolicy:
    loadBalancer:
      simple: LEAST_CONN         # 负载均衡策略
  subsets:                       # 定义服务子集
  - name: v1
    labels:
      version: v1
    trafficPolicy:
      connectionPool:
        tcp:
          maxConnections: 10     # 最大连接数
        http:
          http1MaxPendingRequests: 10  # 最大等待请求
          maxRequestsPerConnection: 2   # 每连接最大请求
  - name: v2  
    labels:
      version: v2
```

### 4.4 Gateway：入口网关


**🚪 Gateway配置示例**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: bookinfo-gateway
spec:
  selector:
    istio: ingressgateway        # 选择入口网关
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - bookinfo.example.com       # 允许的域名
  - port:
      number: 443
      name: https  
      protocol: HTTPS
    tls:
      mode: SIMPLE
      credentialName: bookinfo-secret
    hosts:
    - bookinfo.example.com
```

---

## 5. 🛡️ 安全策略配置实战


### 5.1 Istio安全模型


**🔐 安全防护体系**

```
Istio安全防护层次：

┌─────────────────────────────────────┐
│          身份认证 (Authentication)    │ ← 你是谁？
├─────────────────────────────────────┤
│          授权策略 (Authorization)     │ ← 你能做什么？
├─────────────────────────────────────┤
│          流量加密 (TLS Encryption)    │ ← 数据安全传输
└─────────────────────────────────────┘

就像银行安全系统：
1. 刷身份证（身份认证）
2. 检查权限（授权策略）  
3. 加密通讯（TLS加密）
```

### 5.2 mTLS双向认证


**🤝 mTLS工作原理**

```
传统HTTP通信：
服务A ────── 明文传输 ────── 服务B
        （容易被窃听）

mTLS通信：  
服务A ────── 加密传输 ────── 服务B
       ↑                    ↑
     客户端证书           服务端证书
    （我是A服务）         （我是B服务）
```

**🔧 mTLS配置示例**

```yaml
# 全局启用mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: production
spec:
  mtls:
    mode: STRICT                 # 严格模式，必须mTLS

---
# 目标规则配置mTLS
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: api-server
spec:
  host: api-server
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL         # 使用Istio管理的mTLS
```

### 5.3 授权策略配置


**👮 授权策略就像门禁系统**

```yaml
# 基于角色的访问控制
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: frontend-policy
  namespace: production
spec:
  selector:
    matchLabels:
      app: frontend               # 应用到frontend服务
  rules:
  - from:
    - source:
        principals: 
        - cluster.local/ns/production/sa/web-frontend  # 只允许web-frontend服务账户
  - to:
    - operation:
        methods: ["GET", "POST"]  # 只允许GET和POST方法
  - when:
    - key: source.ip
      values: ["10.0.0.0/8"]     # 只允许内网IP
```

**🚫 拒绝策略示例**

```yaml
# 拒绝特定操作
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-delete
  namespace: production  
spec:
  selector:
    matchLabels:
      app: database
  action: DENY                   # 拒绝动作
  rules:
  - to:
    - operation:
        methods: ["DELETE"]      # 拒绝DELETE操作
```

---

## 6. 📊 可观测性增强功能


### 6.1 可观测性三大支柱


**📈 监控体系全景图**

```
可观测性 = 指标 + 日志 + 链路追踪

┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│    指标     │  │    日志     │  │  链路追踪   │
│  Metrics    │  │    Logs     │  │   Traces    │
├─────────────┤  ├─────────────┤  ├─────────────┤
│• 请求量     │  │• 错误日志   │  │• 请求路径   │
│• 延迟时间   │  │• 访问日志   │  │• 服务依赖   │
│• 错误率     │  │• 系统日志   │  │• 性能瓶颈   │
│• 资源使用   │  │• 业务日志   │  │• 异常定位   │
└─────────────┘  └─────────────┘  └─────────────┘
      ↓              ↓              ↓
   Prometheus      Fluentd        Jaeger
```

### 6.2 Prometheus指标收集


**📊 核心指标说明**

| 指标类型 | **含义** | **示例** | **用途** |
|---------|---------|---------|---------|
| 📈 **Counter** | `累计计数` | `请求总数` | `统计总量` |
| 📏 **Gauge** | `瞬时值` | `当前连接数` | `监控状态` |
| 📊 **Histogram** | `分布统计` | `响应时间分布` | `性能分析` |
| 📉 **Summary** | `摘要统计` | `响应时间百分位` | `趋势分析` |

**⚙️ Prometheus配置示例**

```yaml
# 启用Prometheus指标收集
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: control-plane
spec:
  values:
    telemetry:
      v2:
        enabled: true
        prometheus:
          configOverride:
            metric_relabeling_configs:
            - source_labels: [__name__]
              regex: 'istio_(request|response)_.*'
              target_label: __tmp_istio_metric
            - source_labels: [__tmp_istio_metric, __name__]
              regex: '(.*);(.*)'
              target_label: __name__
              replacement: '${2}'
```

### 6.3 分布式链路追踪


**🕸️ 链路追踪工作原理**

```
一个用户请求的完整链路：

用户请求
    ↓
┌─────────┐    ┌─────────┐    ┌─────────┐
│ Gateway │ -> │Frontend │ -> │   API   │
└─────────┘    └─────────┘    └─────────┘
    Span1         Span2         Span3
      ↓             ↓             ↓
┌─────────────────────────────────────────┐
│              Trace ID                   │ ← 完整请求链路
│  Span1 -> Span2 -> Span3              │
│   5ms     20ms     100ms               │
└─────────────────────────────────────────┘
```

**🔧 Jaeger集成配置**

```yaml
# 启用Jaeger追踪
apiVersion: v1
kind: ConfigMap
metadata:
  name: istio-tracing
  namespace: istio-system
data:
  mesh: |
    defaultConfig:
      proxyStatsMatcher:
        inclusionRegex: '.*outlier_detection.*'
      tracing:
        sampling: 100.0           # 采样率100%
        zipkin:
          address: jaeger-collector.istio-system:9411
```

---

## 7. ⚙️ 服务治理核心能力


### 7.1 熔断器配置


**⚡ 熔断器工作原理**

```
熔断器状态机：

正常状态 ──────────────┐
    │                  │
    │ 错误率超阈值      │ 一定时间后尝试
    ▼                  │
半开状态               │
    │                  │
    │ 请求成功          │
    ▼                  │
断开状态 ──────────────┘

就像家里的电闸：
- 正常用电：开关闭合
- 电流过大：自动跳闸  
- 恢复正常：重新合闸
```

**🔧 熔断器配置示例**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: circuit-breaker
spec:
  host: api-service
  trafficPolicy:
    outlierDetection:
      consecutiveErrors: 3        # 连续3次错误
      interval: 30s              # 检查间隔30秒  
      baseEjectionTime: 30s      # 熔断时间30秒
      maxEjectionPercent: 50     # 最多熔断50%实例
    connectionPool:
      tcp:
        maxConnections: 10       # 最大连接数
      http:
        http1MaxPendingRequests: 10  # 最大排队请求
        maxRequestsPerConnection: 2   # 每连接最大请求数
        maxRetries: 3            # 最大重试次数
```

### 7.2 超时和重试策略


**⏱️ 超时重试配置**

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: timeout-retry
spec:
  hosts:
  - payment-service
  http:
  - route:
    - destination:
        host: payment-service
    timeout: 10s                 # 请求超时10秒
    retries:
      attempts: 3                # 最多重试3次
      perTryTimeout: 3s          # 每次重试超时3秒
      retryOn: gateway-error,connect-failure,refused-stream
```

### 7.3 负载均衡策略


**⚖️ 负载均衡算法对比**

| 算法 | **工作方式** | **适用场景** | **优缺点** |
|------|-------------|-------------|-----------|
| 🔄 **ROUND_ROBIN** | `轮流分配` | `服务器性能相同` | `简单均匀，但不考虑负载` |
| 🎯 **LEAST_CONN** | `连接数最少` | `长连接服务` | `考虑实际负载，计算开销大` |
| 🎲 **RANDOM** | `随机选择` | `无状态服务` | `简单快速，分布可能不均` |
| 📍 **PASSTHROUGH** | `透传不处理` | `特殊需求` | `保持原有行为` |

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: load-balancer-config
spec:
  host: web-service
  trafficPolicy:
    loadBalancer:
      simple: LEAST_CONN         # 使用最少连接算法
  subsets:
  - name: v1
    labels:
      version: v1
    trafficPolicy:
      loadBalancer:
        consistentHash:           # 一致性哈希
          httpHeaderName: "user-id"  # 根据user-id哈希
```

### 7.4 金丝雀部署实战


**🐤 金丝雀部署策略**

```
金丝雀部署流程：

第1阶段：5%新版本
┌──────┐    5% │ ┌──────┐
│ 用户 │ ────►  │ v2   │ (新版本)
└──────┘   95% │ └──────┘
              ▼ │ ┌──────┐  
                │ │ v1   │ (旧版本)
                │ └──────┘

第2阶段：观察指标，逐步增加
第3阶段：100%切换到新版本
```

**📋 金丝雀部署配置**

```yaml
# 第一步：创建新版本Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-v2
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myapp
      version: v2
  template:
    metadata:
      labels:
        app: myapp  
        version: v2
    spec:
      containers:
      - name: app
        image: myapp:v2.0

---
# 第二步：配置流量分割
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: canary-deployment
spec:
  hosts:
  - myapp
  http:
  - route:
    - destination:
        host: myapp
        subset: v1
      weight: 95              # 95%流量到旧版本
    - destination:
        host: myapp
        subset: v2  
      weight: 5               # 5%流量到新版本
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 服务网格本质：微服务通信的基础设施层
🔸 Sidecar模式：为每个服务配备专职代理
🔸 控制面数据面：统一管控 + 分布式执行
🔸 流量管理：精确控制服务间通信行为  
🔸 安全防护：身份认证 + 授权策略 + 通信加密
🔸 可观测性：指标 + 日志 + 链路追踪
🔸 服务治理：熔断 + 重试 + 负载均衡 + 金丝雀
```

### 8.2 关键理解要点


**🔹 服务网格解决的根本问题**
```
问题本质：
微服务架构下，服务间通信复杂度指数增长
每个服务都要处理非业务逻辑的通信问题

解决方案：  
将通信逻辑从业务代码中分离出来
通过Sidecar代理统一处理
```

**🔹 Istio的核心价值**
```
业务价值：
- 让开发专注业务逻辑，不关心通信细节
- 统一的流量管理和安全策略
- 全面的服务监控和故障排查

技术价值：
- 零侵入：不修改应用代码
- 渐进式：可以逐步接入现有系统
- 标准化：统一的配置和管理方式
```

**🔹 什么时候使用服务网格**
```
适用场景：
✅ 微服务数量多（>10个）
✅ 服务间调用复杂
✅ 需要细粒度流量控制  
✅ 安全合规要求高
✅ 需要详细的服务监控

不适用场景：
❌ 单体应用或服务数量少
❌ 简单的服务调用关系
❌ 对性能要求极致（增加了proxy开销）
❌ 团队技术能力不足
```

### 8.3 实际应用指导


**🚀 Istio接入最佳实践**

```
分阶段接入策略：
第1阶段：选择1-2个非核心服务试点
第2阶段：验证功能，积累经验  
第3阶段：逐步扩展到更多服务
第4阶段：全面接入核心服务

技术准备：
- 充分理解Kubernetes基础
- 掌握YAML配置编写
- 建立监控和日志体系
- 制定回滚和应急预案
```

**🔧 配置管理建议**

```
配置原则：
1. 渐进式：先简单配置，再复杂策略
2. 可观测：所有策略都要有监控指标
3. 可回滚：保留配置版本，支持快速回滚
4. 自动化：使用GitOps管理配置变更

常见陷阱：
- 过早优化：一开始就配置复杂的流量策略
- 忽略监控：没有验证策略是否生效
- 配置混乱：多个VirtualService冲突
- 缺少文档：配置缺乏清楚的说明注释
```

### 8.4 故障排查指南


**🔍 常见问题诊断**

```
问题1：Sidecar注入失败
排查步骤：
kubectl get pods → 检查Pod状态
kubectl describe pod → 查看事件信息  
kubectl logs → 查看容器日志

问题2：流量规则不生效
排查步骤：
istioctl proxy-config routes → 检查路由配置
istioctl proxy-status → 检查配置同步状态
kubectl get virtualservice → 验证规则配置

问题3：mTLS认证失败
排查步骤：  
istioctl authn tls-check → 检查TLS配置
kubectl get peerauthentication → 验证认证策略
istioctl proxy-config secret → 检查证书状态
```

**核心记忆**：
- 服务网格是微服务通信的基础设施
- Sidecar代理让应用专注业务逻辑  
- Istio提供流量管理、安全、可观测性
- 渐进式接入，先试点再扩展
- 配置要简单清晰，有监控有回滚