---
title: 15、集群自动伸缩配置
---
## 📚 目录

1. [什么是集群自动伸缩](#1-什么是集群自动伸缩)
2. [三种自动伸缩类型详解](#2-三种自动伸缩类型详解)
3. [Cluster Autoscaler集群伸缩器](#3-cluster-autoscaler集群伸缩器)
4. [HPA水平Pod自动伸缩](#4-hpa水平pod自动伸缩)
5. [VPA垂直Pod自动伸缩](#5-vpa垂直pod自动伸缩)
6. [实际应用场景与最佳实践](#6-实际应用场景与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 什么是集群自动伸缩


### 1.1 通俗理解自动伸缩


**简单比喻**：想象你经营一家餐厅，客流量时多时少
- **客人多了**：需要增加服务员和桌子（扩容）
- **客人少了**：减少服务员和桌子节省成本（缩容）
- **自动管理**：不用老板时刻盯着，系统自动调节

```
传统方式：                     自动伸缩方式：
老板手工安排 ────┐             系统自动监控
              │               ┌─────────────┐
        ┌─────▼─────┐          │  监控指标   │
        │  固定资源  │          │ CPU/内存   │
        │           │   VS     │   请求量   │
        │  容易浪费  │          └──────┬──────┘
        │  或不够用  │                 │
        └───────────┘          ┌──────▼──────┐
                              │  自动调整   │
                              │  资源大小   │
                              └─────────────┘
```

### 1.2 为什么需要自动伸缩


**解决的核心问题**：
- 🎯 **资源利用率低**：固定资源配置无法适应变化
- ⚡ **响应速度慢**：人工调整太慢，错过最佳时机  
- 💰 **成本浪费**：资源闲置或过度配置
- 🔄 **运维负担重**：需要24小时人工监控调整

**实际应用场景**：
- **电商网站**：双11流量暴增，平时流量较小
- **游戏服务**：晚上用户多，凌晨用户少
- **数据处理**：批处理任务需要临时大量资源

---

## 2. 📊 三种自动伸缩类型详解


Kubernetes提供三种不同维度的自动伸缩：

```
集群层面（节点数量）     Pod层面（实例数量）     容器层面（资源配置）
        │                       │                        │
┌───────▼──────┐      ┌─────────▼────────┐      ┌─────────▼────────┐
│Cluster       │      │Horizontal Pod    │      │Vertical Pod      │
│Autoscaler    │      │Autoscaler (HPA)  │      │Autoscaler (VPA)  │
│              │      │                  │      │                  │
│增减物理节点   │      │增减Pod副本数     │      │调整CPU/内存配置  │
│             │      │                  │      │                  │
└──────────────┘      └──────────────────┘      └──────────────────┘
```

### 2.1 三种伸缩的区别与联系


| 类型 | **作用对象** | **调整什么** | **解决问题** | **响应速度** |
|------|-------------|-------------|-------------|-------------|
| 🏢 **CA** | `集群节点` | `增减物理机器` | `节点资源不足` | `慢(2-5分钟)` |
| ↔️ **HPA** | `Pod副本` | `增减实例数量` | `应用负载变化` | `快(30秒-1分钟)` |
| ↕️ **VPA** | `Pod资源` | `调整CPU/内存` | `资源配置不当` | `中(重启生效)` |

**工作顺序理解**：
```
1️⃣ HPA先响应：发现CPU使用率高，增加Pod副本
2️⃣ 如果节点资源不够：CA介入，增加新节点
3️⃣ VPA在后台：持续优化每个Pod的资源配置
```

---

## 3. 🏢 Cluster Autoscaler集群伸缩器


### 3.1 什么是Cluster Autoscaler


**通俗解释**：Cluster Autoscaler（CA）就像是公司的**人事部门**
- 发现工作量大，现有员工忙不过来 → **招聘新员工**（增加节点）
- 发现员工太多，很多人没事干 → **裁员节省成本**（删除节点）

**工作原理**：
```
监控集群状态
      ↓
  发现Pod无法调度 ────→ 扩容：增加新节点
      ↓
  发现节点利用率低 ───→ 缩容：删除空闲节点
```

### 3.2 核心配置参数详解


#### 🎯 节点范围配置


**`--nodes`** 参数：
```bash
# 格式：最小节点数:最大节点数:节点组名称
--nodes=2:10:my-node-group
```

**通俗理解**：
- **最小2个节点**：无论多闲，至少保持2台机器运行
- **最大10个节点**：再忙也不能超过10台机器（防止成本失控）
- **节点组**：指定哪一类机器可以自动管理

#### ⚙️ 缩容控制参数


**`--scale-down-enabled=true`**：
```yaml
# 含义：允许自动删除不需要的节点
# true: 可以缩容（推荐）
# false: 只能扩容，不能缩容
```

**`--scale-down-delay-after-add=10m`**：
```yaml
# 含义：新增节点后，等待10分钟才考虑缩容
# 原因：新节点需要时间预热，避免刚加就删
```

**`--scale-down-unneeded-time=10m`**：
```yaml
# 含义：节点空闲10分钟后才标记为"不需要"
# 避免：频繁增删节点造成震荡
```

#### 🛡️ 保护性参数


**`--skip-nodes-with-local-storage=true`**：
```yaml
# 含义：跳过有本地存储的节点，不删除它们
# 原因：删除会丢失本地数据，非常危险
```

**`--skip-nodes-with-system-pods=true`**：
```yaml
# 含义：跳过运行系统Pod的节点
# 原因：系统Pod很重要，不能随便删除节点
```

### 3.3 完整配置示例


```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cluster-autoscaler
  namespace: kube-system
spec:
  template:
    spec:
      containers:
      - name: cluster-autoscaler
        image: k8s.gcr.io/autoscaling/cluster-autoscaler:v1.21.0
        command:
        - ./cluster-autoscaler
        - --v=4
        - --stderrthreshold=info
        - --cloud-provider=aws           # 云服务商
        - --skip-nodes-with-local-storage=true
        - --skip-nodes-with-system-pods=true
        - --scale-down-enabled=true
        - --scale-down-delay-after-add=10m
        - --scale-down-unneeded-time=10m
        - --max-node-provision-time=15m
        - --nodes=2:10:my-asg-name      # 最关键的配置
```

---

## 4. ↔️ HPA水平Pod自动伸缩


### 4.1 什么是HPA


**通俗解释**：HPA（Horizontal Pod Autoscaler）就像是**外卖平台的派单系统**
- 订单多了 → **多派几个骑手**（增加Pod副本）
- 订单少了 → **让部分骑手休息**（减少Pod副本）
- 骑手能力不变，就是数量在变

**与CA的区别**：
```
HPA关注：应用层面
─────────────────
🍕 订单多 → 多派骑手
🍕 订单少 → 减少骑手

CA关注：基础设施层面  
─────────────────────
🏪 骑手太多机器不够 → 买新电脑
🏪 电脑太多没人用 → 卖掉一些
```

### 4.2 核心配置参数详解


#### 📊 副本数量控制


**`minReplicas`和`maxReplicas`**：
```yaml
minReplicas: 2    # 最少保持2个Pod运行
maxReplicas: 10   # 最多不超过10个Pod
```

**实际意义**：
- **最小值**：保证服务可用性，即使没有流量也要保持基本服务
- **最大值**：防止扩容失控，保护集群资源

#### 🎯 目标CPU使用率


**`targetCPUUtilizationPercentage`**：
```yaml
targetCPUUtilizationPercentage: 70
# 含义：保持每个Pod的CPU使用率在70%左右
```

**工作逻辑**：
```
当前CPU使用率90% ────→ 超过目标70% ────→ 增加Pod
当前CPU使用率40% ────→ 低于目标70% ────→ 减少Pod
当前CPU使用率70% ────→ 符合目标     ────→ 不变
```

#### 🔗 伸缩目标配置


**`scaleTargetRef`**：
```yaml
scaleTargetRef:
  apiVersion: apps/v1
  kind: Deployment      # 要伸缩的对象类型
  name: my-app          # 要伸缩的应用名称
```

**通俗理解**：告诉HPA"你要管理哪个应用"

### 4.3 完整HPA配置示例


```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2                    # 最少2个副本
  maxReplicas: 10                   # 最多10个副本
  metrics:                          # 监控指标
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70      # CPU目标使用率70%
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization  
        averageUtilization: 80      # 内存目标使用率80%
```

### 4.4 多指标配置详解


**`metrics`配置**支持多种指标：

```yaml
metrics:
# CPU指标
- type: Resource
  resource:
    name: cpu
    target:
      type: Utilization
      averageUtilization: 70

# 内存指标  
- type: Resource
  resource:
    name: memory
    target:
      type: Utilization
      averageUtilization: 80

# 自定义指标（如QPS）
- type: Pods
  pods:
    metric:
      name: http_requests_per_second
    target:
      type: AverageValue
      averageValue: "100"
```

---

## 5. ↕️ VPA垂直Pod自动伸缩


### 5.1 什么是VPA


**通俗解释**：VPA（Vertical Pod Autoscaler）就像是**个人健身教练**
- 发现你体能不够 → **增加训练强度**（增加CPU/内存配置）
- 发现你过度训练 → **减少训练量**（减少资源配置）
- 人数不变，但每个人的能力在调整

**与HPA的区别**：
```
HPA水平伸缩：                VPA垂直伸缩：
┌─────┐ ┌─────┐ ┌─────┐      ┌─────────────┐
│ 1核 │ │ 1核 │ │ 1核 │      │    4核      │
│512M │ │512M │ │512M │  VS  │    2GB      │
└─────┘ └─────┘ └─────┘      └─────────────┘
  更多实例                     更强实例
```

### 5.2 VPA工作模式


VPA有三种工作模式：

| 模式 | **含义** | **操作** | **适用场景** |
|------|---------|---------|-------------|
| 📊 **Off** | `只观察不动作` | `只记录建议值` | `测试阶段` |
| 🔄 **Auto** | `自动调整` | `重启Pod应用新配置` | `生产环境` |
| 📋 **Initial** | `仅初始化时调整` | `只影响新创建的Pod` | `渐进式更新` |

### 5.3 VPA配置示例


```yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: my-app-vpa
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  updatePolicy:
    updateMode: "Auto"              # 自动模式
  resourcePolicy:
    containerPolicies:
    - containerName: my-container
      minAllowed:                   # 最小资源限制
        cpu: 100m
        memory: 128Mi
      maxAllowed:                   # 最大资源限制
        cpu: 2
        memory: 4Gi
```

---

## 6. 🎯 实际应用场景与最佳实践


### 6.1 三种伸缩的协同工作


**真实场景：电商秒杀活动**

```
时间轴：秒杀前 → 秒杀中 → 秒杀后
       │        │        │
   ┌───▼───┐ ┌──▼───┐ ┌───▼───┐
   │正常   │ │高峰  │ │恢复   │
   │状态   │ │状态  │ │状态   │
   └───────┘ └──────┘ └───────┘
```

**第1阶段：准备期**
- 🔧 **VPA作用**：根据历史数据优化每个Pod的CPU/内存配置
- 📊 **当前状态**：2个Pod，每个2核4GB内存

**第2阶段：高峰期**
- ⚡ **HPA快速响应**：检测到CPU使用率飙升，30秒内扩容到6个Pod
- 🏢 **CA随后介入**：发现节点资源不足，3分钟内新增2个节点
- 📈 **最终结果**：6个Pod分布在4个节点上

**第3阶段：恢复期**  
- ⚡ **HPA先缩容**：流量下降，逐步减少到2个Pod
- 🏢 **CA后缩容**：10分钟后删除空闲节点
- 🔧 **VPA持续优化**：根据本次数据调整未来的资源配置

### 6.2 配置最佳实践


#### ⚠️ 避免配置冲突


```yaml
# ❌ 错误：HPA和VPA同时管理CPU
HPA: targetCPUUtilizationPercentage: 70
VPA: 同时调整CPU配置
# 结果：两个系统互相干扰

# ✅ 正确：分工合作
HPA: 管理CPU指标，控制副本数
VPA: 管理内存指标，优化资源配置
```

#### 🎯 合理设置阈值


```yaml
# HPA配置建议
minReplicas: 2          # 保证高可用
maxReplicas: 50         # 根据业务需求设置上限
targetCPU: 70%          # 70%是经验最佳值

# CA配置建议  
nodes: 3:20:node-group  # 预留足够缓冲
scale-down-delay: 10m   # 避免频繁缩容
```

#### 📊 监控和告警


**关键监控指标**：
- **HPA响应时间**：从触发到扩容完成的时间
- **CA节点利用率**：避免过度配置或资源不足
- **VPA推荐准确性**：实际使用与推荐值的差异

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🏢 Cluster Autoscaler：管理集群节点数量
   ├── 扩容：Pod无法调度时增加节点
   ├── 缩容：节点长时间空闲时删除
   └── 配置：nodes、scale-down参数

↔️ HPA水平伸缩：管理Pod副本数量  
   ├── 监控：CPU/内存使用率
   ├── 动作：增减Pod实例
   └── 配置：min/max副本数、目标使用率

↕️ VPA垂直伸缩：管理Pod资源配置
   ├── 分析：历史资源使用数据
   ├── 建议：优化CPU/内存配置
   └── 模式：观察、自动、初始化
```

### 7.2 关键配置参数速查


| 参数类型 | **参数名** | **作用** | **推荐值** |
|---------|-----------|---------|-----------|
| 🏢 **CA节点** | `--nodes` | `节点数量范围` | `3:20:group-name` |
| 🏢 **CA缩容** | `--scale-down-delay-after-add` | `新增后缩容延迟` | `10m` |
| ↔️ **HPA副本** | `minReplicas/maxReplicas` | `副本数范围` | `2/50` |
| ↔️ **HPA目标** | `targetCPUUtilizationPercentage` | `CPU目标使用率` | `70%` |
| ↕️ **VPA模式** | `updateMode` | `更新模式` | `Auto` |

### 7.3 实际应用指导


**选择策略**：
- 🚀 **快速响应**：优先配置HPA（秒级响应）
- 💰 **成本优化**：配置CA和VPA（长期优化）
- 🛡️ **稳定性**：设置合理的min/max范围

**常见误区**：
- ❌ **过度依赖自动伸缩**：基础配置仍然重要
- ❌ **忽略监控**：自动化需要监控验证效果
- ❌ **配置冲突**：HPA和VPA不要管理相同指标

**新手建议**：
1. 🎯 **先学HPA**：最容易理解和配置
2. 🏢 **再学CA**：理解节点管理概念  
3. ↕️ **最后VPA**：需要更多运维经验

**核心记忆**：
- **HPA管数量**：Pod多了少了
- **VPA管配置**：每个Pod要多少资源
- **CA管节点**：集群机器够不够用
- **三者配合**：实现真正的自动化运维