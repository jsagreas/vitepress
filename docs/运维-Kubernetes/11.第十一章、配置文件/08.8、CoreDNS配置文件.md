---
title: 8、CoreDNS配置文件
---
## 📚 目录

1. [CoreDNS基础概念](#1-CoreDNS基础概念)
2. [Corefile配置文件详解](#2-Corefile配置文件详解)
3. [核心插件配置说明](#3-核心插件配置说明)
4. [DNS解析工作原理](#4-DNS解析工作原理)
5. [常用配置场景](#5-常用配置场景)
6. [故障排查与优化](#6-故障排查与优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌐 CoreDNS基础概念


### 1.1 什么是CoreDNS


**简单理解**：CoreDNS就像是Kubernetes集群中的"电话簿"，专门负责把服务名称转换成具体的IP地址。

```
想象场景：
你要打电话给"小明"，但手机需要的是具体号码
CoreDNS = 电话簿，帮你找到小明的真实号码

Kubernetes中：
Pod要访问"nginx-service"
CoreDNS帮忙找到nginx-service的真实IP地址
```

**🔸 CoreDNS的作用**
- **域名解析**：把service名称转换为IP地址
- **服务发现**：让Pod能够通过名称找到其他服务
- **集群内通信**：实现Pod之间的相互访问

### 1.2 CoreDNS在K8s中的位置


```
集群架构图：
┌─────────────────────────────────────┐
│           Kubernetes集群             │
├─────────────────────────────────────┤
│  Pod A          Pod B          Pod C │
│    │              │              │   │
│    └──────────────┼──────────────┘   │
│                   │                  │
│            ┌─────────────┐            │
│            │   CoreDNS   │            │
│            │  (kube-dns) │            │
│            └─────────────┘            │
└─────────────────────────────────────────┘
```

**核心理解**：
- CoreDNS作为Pod运行在集群中
- 每个Pod都配置使用CoreDNS作为DNS服务器
- 所有域名查询都会经过CoreDNS处理

### 1.3 cluster.local域名体系


**🔸 集群域名规则**
```
完整域名格式：
<service-name>.<namespace>.svc.cluster.local

实际例子：
nginx-service.default.svc.cluster.local
│      │         │    │      │
服务名  命名空间   服务  集群域名
```

**简化访问方式**：
- **同命名空间**：直接使用`nginx-service`
- **跨命名空间**：使用`nginx-service.default`
- **完整域名**：`nginx-service.default.svc.cluster.local`

---

## 2. 📋 Corefile配置文件详解


### 2.1 Corefile文件位置和作用


**配置文件路径**：`/etc/coredns/Corefile`

**🔸 Corefile是什么**
- CoreDNS的**核心配置文件**
- 决定DNS查询如何处理
- 定义各种插件的工作方式

### 2.2 基础配置结构解析


```bash
# 典型的Corefile配置示例
.:53 {
    errors
    health {
        lameduck 5s
    }
    ready
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        pods insecure
        fallthrough in-addr.arpa ip6.arpa
        ttl 30
    }
    prometheus :9153
    forward . /etc/resolv.conf {
        max_concurrent 1000
    }
    cache 30
    loop
    reload
    loadbalance
}
```

**🔸 配置结构说明**
```
.:53 {
    # 监听所有域名的53端口请求
    # 大括号内是具体的处理插件配置
}
```

### 2.3 配置语法基础


**监听配置格式**：
```
格式：<域名>:<端口> { 插件配置 }
示例：
.:53          - 监听所有域名的53端口
example.com:53 - 只处理example.com域名
```

**插件配置顺序**：
- ⚠️ **顺序很重要**：插件按照配置顺序执行
- **常用顺序**：errors → health → kubernetes → forward → cache

---

## 3. 🔧 核心插件配置说明


### 3.1 kubernetes插件 - 集群域名解析


```bash
kubernetes cluster.local in-addr.arpa ip6.arpa {
    pods insecure
    fallthrough in-addr.arpa ip6.arpa
    ttl 30
}
```

**🔸 参数详解**
- **`cluster.local`**：集群的根域名
- **`in-addr.arpa`**：IPv4反向解析域
- **`ip6.arpa`**：IPv6反向解析域

**pods配置选项**：
```
pods insecure    - 允许解析Pod的域名（不验证）
pods verified    - 验证Pod存在后才解析
pods disabled    - 禁用Pod域名解析
```

**实际应用场景**：
```
Service解析：nginx-service.default.svc.cluster.local
Pod解析：10-244-1-5.default.pod.cluster.local
```

### 3.2 forward插件 - 上游DNS转发


```bash
forward . /etc/resolv.conf {
    max_concurrent 1000
}
```

**🔸 转发机制**
- **作用**：把集群外部域名转发给上游DNS
- **`/etc/resolv.conf`**：使用宿主机的DNS配置
- **`max_concurrent`**：限制并发查询数量

**转发流程示意**：
```
Pod查询google.com
    ↓
CoreDNS检查不是集群域名
    ↓ 
转发给上游DNS（如8.8.8.8）
    ↓
返回结果给Pod
```

### 3.3 cache插件 - DNS缓存


```bash
cache 30
```

**🔸 缓存机制**
- **缓存时间**：30秒（可调整）
- **作用**：减少重复查询，提高响应速度
- **缓存内容**：成功和失败的查询结果都会缓存

**缓存工作原理**：
```
第一次查询：nginx-service → 查询K8s API → 缓存结果
后续查询：nginx-service → 直接返回缓存结果（30秒内）
```

### 3.4 健康检查插件


**health插件**：
```bash
health {
    lameduck 5s
}
```
- **作用**：提供健康检查接口
- **`lameduck`**：优雅关闭时间

**ready插件**：
```bash
ready
```
- **作用**：就绪状态检查
- **用途**：K8s用来判断CoreDNS是否准备好

### 3.5 监控和日志插件


**prometheus插件**：
```bash
prometheus :9153
```
- **作用**：暴露监控指标
- **端口**：9153端口提供metrics

**errors和log插件**：
```bash
errors          # 记录错误日志
log             # 记录所有查询日志（调试用）
```

### 3.6 其他重要插件


**loop插件**：
```bash
loop
```
- **作用**：检测DNS查询循环
- **功能**：防止无限循环查询

**reload插件**：
```bash
reload
```
- **作用**：自动重新加载配置文件
- **触发**：检测到Corefile变化时自动重载

**loadbalance插件**：
```bash
loadbalance
```
- **作用**：对多个DNS记录进行负载均衡
- **方式**：随机返回其中一个记录

---

## 4. 🔄 DNS解析工作原理


### 4.1 集群内域名解析流程


```
Pod发起DNS查询流程：
┌─────────┐     ┌─────────────┐     ┌─────────────────┐
│   Pod   │────▶│   CoreDNS   │────▶│ Kubernetes API  │
│ 查询请求 │     │  域名解析   │     │   获取Service   │
└─────────┘     └─────────────┘     └─────────────────┘
     ▲                   │                     │
     │                   ▼                     │
     └─────────────  返回IP地址  ◀──────────────┘
```

**详细步骤解析**：

① **Pod发起查询**
```bash
# Pod内部执行
nslookup nginx-service
```

② **CoreDNS接收查询**
- 检查是否为集群内域名
- 根据kubernetes插件配置处理

③ **查询Kubernetes API**
- 获取Service的Endpoint信息
- 找到对应的Pod IP地址

④ **返回解析结果**
- 将IP地址返回给查询的Pod
- 同时缓存查询结果

### 4.2 外部域名解析流程


```
外部域名查询流程：
┌─────────┐     ┌─────────────┐     ┌─────────────────┐
│   Pod   │────▶│   CoreDNS   │────▶│  上游DNS服务器   │
│查询google.com│  │ forward转发 │     │  (8.8.8.8等)   │
└─────────┘     └─────────────┘     └─────────────────┘
     ▲                   │                     │
     │                   ▼                     │
     └─────────────  返回IP地址  ◀──────────────┘
```

### 4.3 autopath自动路径解析


**autopath插件作用**：
```bash
autopath @kubernetes
```

**简化查询过程**：
```
Pod查询：nginx-service
自动尝试路径：
1. nginx-service.default.svc.cluster.local
2. nginx-service.svc.cluster.local  
3. nginx-service.cluster.local
4. nginx-service
```

---

## 5. 🛠️ 常用配置场景


### 5.1 标准生产环境配置


```bash
.:53 {
    errors
    health {
        lameduck 5s
    }
    ready
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        pods insecure
        fallthrough in-addr.arpa ip6.arpa
        ttl 30
    }
    prometheus :9153
    forward . /etc/resolv.conf {
        max_concurrent 1000
    }
    cache 30
    loop
    reload
    loadbalance
}
```

### 5.2 调试配置（开发环境）


```bash
.:53 {
    errors
    log    # 开启详细日志
    health
    ready
    kubernetes cluster.local {
        pods insecure
        ttl 5     # 缩短TTL便于调试
    }
    forward . 8.8.8.8 8.8.4.4  # 使用指定DNS
    cache 5   # 缩短缓存时间
    reload
}
```

### 5.3 自定义域名配置


```bash
# 为特定域名配置不同处理
company.local:53 {
    file /etc/coredns/company.local.zone
}

.:53 {
    # 默认配置
    kubernetes cluster.local
    forward . /etc/resolv.conf
}
```

---

## 6. 🔍 故障排查与优化


### 6.1 常见DNS问题排查


**DNS解析失败排查步骤**：

① **检查CoreDNS Pod状态**
```bash
kubectl get pods -n kube-system -l k8s-app=kube-dns
```

② **查看CoreDNS日志**
```bash
kubectl logs -n kube-system -l k8s-app=kube-dns
```

③ **验证DNS配置**
```bash
# 进入Pod验证DNS设置
kubectl exec -it <pod-name> -- cat /etc/resolv.conf
```

### 6.2 性能优化配置


**缓存优化**：
```bash
cache 300    # 增加缓存时间到5分钟
```

**并发优化**：
```bash
forward . /etc/resolv.conf {
    max_concurrent 1000    # 增加并发查询数
    expire 10s            # 设置查询超时时间
}
```

**资源限制优化**：
```yaml
# CoreDNS Deployment资源配置
resources:
  limits:
    cpu: 100m
    memory: 128Mi
  requests:
    cpu: 100m
    memory: 128Mi
```

### 6.3 监控指标说明


**重要监控指标**：
- **`coredns_dns_requests_total`**：DNS请求总数
- **`coredns_dns_responses_total`**：DNS响应总数
- **`coredns_cache_hits_total`**：缓存命中次数
- **`coredns_forward_requests_total`**：转发请求次数

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的概念


```
🔸 CoreDNS作用：Kubernetes集群的DNS服务器，负责域名解析
🔸 Corefile配置：/etc/coredns/Corefile是核心配置文件
🔸 cluster.local：集群默认域名，所有服务都在此域下
🔸 插件机制：通过不同插件实现不同功能
🔸 解析流程：集群内查询K8s API，集群外转发上游DNS
```

### 7.2 关键配置理解


**🔹 kubernetes插件**
```
作用：处理集群内Service和Pod的域名解析
配置：kubernetes cluster.local
重要：pods insecure允许Pod域名解析
```

**🔹 forward插件**
```
作用：转发集群外域名查询到上游DNS
配置：forward . /etc/resolv.conf
用途：让集群能访问外部网站
```

**🔹 cache插件**
```
作用：缓存DNS查询结果提高性能
配置：cache 30（秒）
优化：根据需求调整缓存时间
```

### 7.3 实际应用要点


**域名访问规则**：
- **同命名空间**：直接用服务名 `nginx-service`
- **跨命名空间**：加命名空间 `nginx-service.default`
- **完整域名**：`nginx-service.default.svc.cluster.local`

**排查问题思路**：
① 检查CoreDNS Pod是否正常
② 查看CoreDNS日志确认错误
③ 验证Pod的DNS配置是否正确
④ 测试域名解析是否工作

**性能优化建议**：
- 合理设置缓存时间（cache）
- 调整并发查询限制（max_concurrent）
- 监控DNS查询指标
- 根据集群规模调整资源限制

**核心记忆**：
- CoreDNS是集群的"电话簿"，负责把服务名转成IP
- Corefile配置决定DNS如何工作
- kubernetes插件处理集群内，forward处理集群外
- 缓存和监控是性能优化的关键