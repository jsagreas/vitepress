---
title: 5、PersistentVolumeClaim存储声明
---
## 📚 目录

1. [PVC基础概念理解](#1-PVC基础概念理解)
2. [存储需求声明方式](#2-存储需求声明方式)
3. [卷绑定匹配机制](#3-卷绑定匹配机制)
4. [存储类选择器](#4-存储类选择器)
5. [PVC状态管理](#5-PVC状态管理)
6. [动态与静态供应](#6-动态与静态供应)
7. [实际操作演示](#7-实际操作演示)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 PVC基础概念理解


### 1.1 什么是PVC


> **💡 通俗理解**
> 
> PVC就像是你向物业**申请存储空间的申请单**。你不用关心具体给你哪个仓库，只需要在申请单上写清楚：我需要多大空间、什么类型的存储、什么访问权限。物业会根据你的需求分配合适的仓库给你。

**🔸 核心定义**
```
PVC (PersistentVolumeClaim) = 持久卷声明
作用：向Kubernetes集群申请存储资源
本质：一份"我需要什么样存储"的申请表
```

**📋 生活类比**
```
┌─ 💭 租房类比 ─────────────┐
│ PVC = 租房需求单           │
│ "我要：2室1厅、50平米、    │
│  地铁附近、租金3000内"     │
│                            │
│ 房东(K8s) 根据需求单       │
│ 匹配合适的房子(PV)给你     │
└────────────────────────────┘
```

### 1.2 PVC解决什么问题


**🎯 核心问题**
```
应用开发者的困扰：
❌ 我不知道集群有哪些存储设备
❌ 我不想关心存储的技术细节  
❌ 我只想说"给我10GB空间就行"
❌ 不同环境的存储配置太复杂

PVC的解决方案：
✅ 申请式使用：我只说需求，不管具体实现
✅ 抽象化存储：统一的申请接口
✅ 自动匹配：系统自动找合适的存储
✅ 环境无关：同样的申请在不同环境都能工作
```

### 1.3 PVC与PV的关系


**🔗 配对关系图**
```
Pod需要存储
     ↓
   使用PVC
     ↓
   PVC申请存储 ──────→ 匹配合适的PV
     ↓                    ↓
   绑定成功           PV提供实际存储
     ↓                    ↓
Pod通过PVC ←────────── 使用PV的存储空间
```

**📊 对比理解**

| 角色 | **PVC (申请方)** | **PV (供应方)** |
|------|-----------------|----------------|
| **性质** | `需求申请单` | `实际存储资源` |
| **创建者** | `应用开发者` | `集群管理员` |
| **内容** | `我要什么样的存储` | `我能提供什么存储` |
| **生命周期** | `跟随Pod应用` | `独立于Pod` |

---

## 2. 📝 存储需求声明方式


### 2.1 基本声明结构


**🎯 PVC申请单的必填项**
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc-claim        # PVC的名字
spec:
  accessModes:              # 访问方式
  - ReadWriteOnce          # 单节点读写
  resources:
    requests:
      storage: 10Gi         # 需要10GB存储空间
```

> **💡 理解要点**
> 
> 这就像填写一份申请表：
> - `name`: 这份申请的编号
> - `accessModes`: 我要什么样的使用权限
> - `storage`: 我要多大的空间

### 2.2 访问模式详解


**🔐 三种访问权限**
```
ReadWriteOnce (RWO):
┌─ 独占读写 ─────────────┐
│ • 只能被一个节点挂载   │
│ • 该节点可读可写       │  
│ • 适合：数据库存储     │
└────────────────────────┘

ReadOnlyMany (ROX):  
┌─ 多节点只读 ───────────┐
│ • 多个节点同时挂载     │
│ • 所有节点只能读       │
│ • 适合：配置文件共享   │
└────────────────────────┘

ReadWriteMany (RWX):
┌─ 多节点读写 ───────────┐  
│ • 多个节点同时挂载     │
│ • 所有节点可读可写     │
│ • 适合：共享文件系统   │
└────────────────────────┘
```

**🎯 如何选择访问模式**
```
我的应用场景：
数据库应用     → RWO (独占，避免数据冲突)
静态网站资源   → ROX (多个副本共享读取)  
日志收集系统   → RWX (多节点写入日志)
缓存系统      → RWO (单实例高性能)
```

### 2.3 存储容量声明


**📏 容量规格说明**
```yaml
resources:
  requests:
    storage: 10Gi      # 最少需要10GB
  limits:              # 可选：最大使用量
    storage: 20Gi      # 最多使用20GB  
```

**💾 容量单位对照**
```
常用单位：
• Gi = 1024³ 字节 (二进制)
• GB = 1000³ 字节 (十进制)  
• Mi = 1024² 字节
• MB = 1000² 字节

实际建议：
小文件存储：1-10Gi
数据库存储：20-100Gi  
大数据处理：100Gi-1Ti
日志存储：50-200Gi
```

### 2.4 完整的PVC声明示例


```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: webapp-storage-claim
  labels:
    app: webapp
spec:
  # 访问模式：单节点读写
  accessModes:
    - ReadWriteOnce
  
  # 存储需求：至少需要20GB
  resources:
    requests:
      storage: 20Gi
  
  # 可选：指定存储类
  storageClassName: fast-ssd
  
  # 可选：选择器 (用于匹配特定PV)
  selector:
    matchLabels:
      environment: production
```

---

## 3. 🔄 卷绑定匹配机制


### 3.1 绑定过程详解


> **🔍 深入理解**
> 
> PVC绑定就像相亲配对：你的需求单(PVC) 需要找到合适的对象(PV)。系统会根据你的条件进行自动匹配。

**🎯 匹配流程图**
```
创建PVC申请
    ↓
检查现有PV资源
    ↓
┌─匹配条件检查────────┐
│ ✓ 容量是否满足     │
│ ✓ 访问模式是否兼容 │  
│ ✓ 存储类是否匹配   │
│ ✓ 标签选择器是否符合│
└────────────────────┘
    ↓
找到合适PV ──→ 绑定成功 ──→ PVC状态: Bound
    ↓                         
找不到合适PV ──→ 等待状态 ──→ PVC状态: Pending
```

### 3.2 匹配规则详解


**📋 必须匹配的条件**
```
1. 存储容量匹配：
   PV容量 >= PVC请求容量
   
2. 访问模式兼容：  
   PV支持的模式 包含 PVC需要的模式
   
3. 存储类匹配：
   PV的存储类 = PVC指定的存储类
   (或都为空，表示默认存储类)
```

**🔍 匹配示例分析**
```
PVC需求：
- 容量：10Gi
- 访问模式：ReadWriteOnce  
- 存储类：fast-ssd

候选PV1：
- 容量：20Gi ✅        (大于等于10Gi)
- 访问模式：RWO ✅     (支持ReadWriteOnce)
- 存储类：fast-ssd ✅  (完全匹配)
→ 匹配成功！

候选PV2：  
- 容量：5Gi ❌         (小于10Gi)
- 访问模式：RWO ✅
- 存储类：fast-ssd ✅  
→ 容量不足，匹配失败

候选PV3：
- 容量：15Gi ✅
- 访问模式：ROX ❌      (只读模式，不支持RWO)
- 存储类：fast-ssd ✅
→ 访问模式不兼容，匹配失败
```

### 3.3 绑定策略


**⚖️ 最优匹配原则**
```
当有多个PV都满足条件时，选择策略：

1. 容量最接近原则：
   优先选择容量最小但满足需求的PV
   (避免资源浪费)

2. 标签匹配优先：
   有选择器标签的PVC，优先匹配对应标签的PV

3. 创建时间优先：  
   其他条件相同时，优先绑定创建时间较早的PV
```

---

## 4. 🏷️ 存储类选择器


### 4.1 存储类的作用


> **💡 理解存储类**
> 
> 存储类就像酒店的**房型分类**：经济型、商务型、豪华型。每种房型有不同的设施和价格。PVC申请时可以指定要哪种"房型"的存储。

**🏨 存储类分类示例**
```
fast-ssd:        高性能SSD存储
├─ 适合：数据库、缓存
├─ 特点：速度快、价格高
└─ IOPS：>10000

standard-hdd:    标准机械硬盘
├─ 适合：文件存储、备份  
├─ 特点：容量大、价格低
└─ IOPS：<1000

network-storage: 网络存储
├─ 适合：共享文件系统
├─ 特点：多节点访问
└─ 延迟：较高但可共享
```

### 4.2 在PVC中使用存储类


**📝 指定存储类的方法**
```yaml
# 方法1：明确指定存储类
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: db-storage-claim
spec:
  storageClassName: fast-ssd    # 明确要求fast-ssd类型
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 50Gi

---
# 方法2：使用默认存储类  
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-storage-claim
spec:
  # 不指定storageClassName，使用集群默认存储类
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
      
---
# 方法3：不使用存储类 (静态绑定)
apiVersion: v1  
kind: PersistentVolumeClaim
metadata:
  name: static-storage-claim
spec:
  storageClassName: ""          # 空字符串表示不使用存储类
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### 4.3 存储类选择策略


**🎯 根据应用选择存储类**
```
数据库应用：
└─ 选择：fast-ssd
└─ 原因：需要高IOPS和低延迟

Web应用静态资源：
└─ 选择：standard-hdd  
└─ 原因：主要是读操作，对速度要求不高

日志收集系统：
└─ 选择：large-capacity
└─ 原因：需要大容量，写入频繁但查询少

临时数据处理：
└─ 选择：fast-local
└─ 原因：需要高速度，但数据不需要持久化
```

---

## 5. 📊 PVC状态管理


### 5.1 PVC生命周期状态


**🔄 状态转换图**
```
创建PVC
    ↓
  Pending ──────┐
(等待绑定)      │
    ↓          │ 找不到合适PV
  Bound         │ 
(绑定成功) ←────┘
    ↓
  InUse     
(正在使用)
    ↓
 Released
(已释放)
    ↓
  Deleted
(已删除)
```

### 5.2 各状态详细说明


**📋 状态详解**

**Pending（等待中）**
```
含义：PVC已创建，但还没找到合适的PV绑定
原因：
• 没有满足条件的PV可用
• 存储类配置问题  
• 资源不足

排查方法：
kubectl describe pvc <pvc-name>
kubectl get pv  # 查看可用PV
```

**Bound（已绑定）**  
```
含义：PVC成功绑定到一个PV
特点：
• PV和PVC一一对应  
• 可以被Pod使用
• PV被独占，其他PVC无法使用

查看绑定信息：
kubectl get pvc <pvc-name> -o wide
```

**InUse（使用中）**
```
含义：PVC正在被Pod使用  
特点：
• Pod已挂载这个PVC
• 无法删除正在使用的PVC
• 数据正在读写中

查看使用情况：
kubectl get pods --field-selector spec.volumes[*].persistentVolumeClaim.claimName=<pvc-name>
```

### 5.3 PVC状态监控


**🔍 状态检查命令**
```bash
# 查看PVC状态
kubectl get pvc

# 详细状态信息
kubectl describe pvc <pvc-name>

# 实时监控状态变化  
kubectl get pvc -w

# 查看PVC和对应PV的绑定关系
kubectl get pvc,pv
```

**📊 状态输出示例**
```
NAME        STATUS   VOLUME     CAPACITY   ACCESS MODES   STORAGECLASS
my-pvc      Bound    pv-001     10Gi       RWO            fast-ssd
app-pvc     Pending              20Gi       RWO            standard
log-pvc     Bound    pv-002     50Gi       RWX            network-storage
```

---

## 6. ⚡ 动态与静态供应


### 6.1 静态供应模式


> **💡 静态供应理解**
> 
> 静态供应就像**预先准备好的仓库**：管理员提前创建好各种规格的PV，用户申请时从现有PV中选择合适的。

**🏪 静态供应流程**
```
集群管理员                    应用开发者
     ↓                           ↓
提前创建多个PV              创建PVC申请存储
(各种规格的存储)                 ↓
     ↓                    系统自动匹配现有PV
预备好存储资源              ↓
     ↓                    绑定成功，开始使用
等待PVC申请
```

**📝 静态供应配置示例**
```yaml
# 管理员预先创建PV
apiVersion: v1
kind: PersistentVolume  
metadata:
  name: static-pv-1
spec:
  capacity:
    storage: 20Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/static-pv-1
  storageClassName: ""    # 空字符串表示静态供应

---
# 开发者创建PVC
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: static-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 15Gi        # 15Gi < 20Gi，可以匹配
  storageClassName: ""     # 同样使用空字符串
```

### 6.2 动态供应模式


> **💡 动态供应理解**  
> 
> 动态供应就像**按需定制服务**：用户提出需求，系统自动创建符合要求的存储资源，就像网购时现做现发。

**🚀 动态供应流程**
```
应用开发者创建PVC
       ↓
系统检查存储类配置
       ↓  
调用存储提供商API
       ↓
自动创建匹配的PV
       ↓
PVC与新PV自动绑定
       ↓
Pod可以立即使用
```

**⚙️ 动态供应配置示例**
```yaml
# 存储类配置（管理员创建）
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
provisioner: kubernetes.io/aws-ebs    # 使用AWS EBS
parameters:
  type: gp2                           # EBS类型
  zones: us-west-2a,us-west-2b       # 可用区
reclaimPolicy: Delete                 # 删除策略

---  
# PVC申请（开发者创建）
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: dynamic-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 30Gi
  storageClassName: fast-ssd          # 指定存储类
```

### 6.3 两种模式对比


**📊 对比分析**

| 特性 | **静态供应** | **动态供应** |
|------|-------------|-------------|
| **管理复杂度** | `需要预先规划PV` | `自动化创建` |
| **资源利用率** | `可能有资源浪费` | `按需分配，利用率高` |
| **响应速度** | `立即可用` | `需要创建时间` |
| **灵活性** | `规格固定` | `完全按需定制` |
| **适用场景** | `小规模，可预测需求` | `大规模，动态需求` |

**🎯 选择建议**
```
使用静态供应的场景：
• 小型集群，存储需求相对固定
• 需要精确控制存储位置和配置  
• 使用特殊存储设备
• 测试和开发环境

使用动态供应的场景：
• 大型集群，存储需求多样化
• 云环境，支持自动扩容
• 生产环境，需要高可用
• 应用部署频繁变化
```

---

## 7. 🛠️ 实际操作演示


### 7.1 创建第一个PVC


**📝 基础PVC创建**
```yaml
# webapp-pvc.yaml
apiVersion: v1  
kind: PersistentVolumeClaim
metadata:
  name: webapp-storage
  labels:
    app: webapp
spec:
  accessModes:
    - ReadWriteOnce      # 单节点读写
  resources:
    requests:
      storage: 10Gi      # 需要10GB存储
  storageClassName: standard  # 使用标准存储类
```

**🔧 执行创建命令**
```bash
# 创建PVC
kubectl apply -f webapp-pvc.yaml

# 查看创建结果
kubectl get pvc webapp-storage

# 查看详细信息
kubectl describe pvc webapp-storage
```

### 7.2 在Pod中使用PVC


**📦 Pod配置示例**
```yaml
# webapp-pod.yaml
apiVersion: v1
kind: Pod  
metadata:
  name: webapp-pod
spec:
  containers:
  - name: webapp
    image: nginx:latest
    volumeMounts:
    - name: storage-volume    # 卷名称
      mountPath: /usr/share/nginx/html  # 挂载路径
      
  volumes:
  - name: storage-volume      # 定义卷
    persistentVolumeClaim:
      claimName: webapp-storage    # 引用PVC名称
```

**🚀 部署和验证**
```bash
# 部署Pod
kubectl apply -f webapp-pod.yaml

# 检查Pod状态
kubectl get pod webapp-pod

# 进入Pod验证存储挂载
kubectl exec -it webapp-pod -- df -h

# 测试写入数据  
kubectl exec -it webapp-pod -- bash -c "echo 'Hello PVC' > /usr/share/nginx/html/index.html"
```

### 7.3 多Pod共享存储示例


**🔗 ReadWriteMany模式PVC**
```yaml
# shared-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim  
metadata:
  name: shared-storage
spec:
  accessModes:
    - ReadWriteMany     # 多节点读写
  resources:
    requests:
      storage: 20Gi
  storageClassName: nfs-storage   # 使用支持RWX的存储类
```

**👥 多个Pod使用共享存储**
```yaml
# multi-pod.yaml  
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shared-app
spec:
  replicas: 3           # 3个Pod副本
  selector:
    matchLabels:
      app: shared-app
  template:
    metadata:
      labels:
        app: shared-app
    spec:
      containers:
      - name: app
        image: busybox
        command: ['sleep', '3600']
        volumeMounts:
        - name: shared-volume
          mountPath: /shared-data
          
      volumes:
      - name: shared-volume
        persistentVolumeClaim:
          claimName: shared-storage    # 多个Pod共享同一个PVC
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```  
🔸 PVC本质：向K8s申请存储资源的申请单
🔸 绑定机制：PVC会自动匹配合适的PV进行绑定  
🔸 访问模式：RWO(独占)、ROX(共享只读)、RWX(共享读写)
🔸 存储类：定义存储的类型和特性，支持动态供应
🔸 状态管理：Pending → Bound → InUse → Released
🔸 供应模式：静态供应(预创建PV) vs 动态供应(自动创建PV)
```

### 8.2 关键理解要点


**🔹 PVC的设计哲学**
```
抽象化存储使用：
• 应用不需要知道底层存储细节
• 通过申请单的方式标准化存储需求  
• 实现存储的动态分配和管理
• 支持多种存储后端的统一接口
```

**🔹 绑定匹配的重要性**
```  
自动匹配机制：
• 根据容量、访问模式、存储类等条件匹配
• 一旦绑定，PV和PVC形成一对一关系
• 绑定关系在PVC删除前保持稳定
• 支持标签选择器进行精确匹配
```

**🔹 存储类的价值**
```
分类管理存储：
• 不同性能等级的存储分开管理
• 支持动态供应，按需创建存储
• 简化应用的存储配置
• 提供存储的服务化能力
```

### 8.3 实际应用指导


**🎯 PVC使用最佳实践**

**容量规划：**
```
• 数据库：预留30-50%增长空间
• 日志系统：根据日志量和保留周期计算  
• 临时存储：够用即可，避免资源浪费
• 共享存储：考虑并发访问的空间需求
```

**访问模式选择：**
```
• 数据库、缓存：使用RWO，避免数据冲突
• 配置文件、静态资源：使用ROX，提高效率
• 日志收集、共享工作区：使用RWX，支持协作
• 大部分应用：RWO是最安全的选择
```

**存储类规划：**
```
• 生产环境：使用高性能存储类
• 开发测试：使用标准存储类节省成本
• 临时数据：使用本地存储提高性能  
• 备份数据：使用低成本存储类
```

### 8.4 常见问题解决


**🔧 PVC Pending问题**
```
排查步骤：
1. 检查是否有满足条件的PV：kubectl get pv
2. 检查存储类配置：kubectl get storageclass
3. 检查容量和访问模式是否匹配  
4. 查看详细错误信息：kubectl describe pvc <name>
```

**🔧 PVC删除失败**
```  
可能原因：
• PVC正在被Pod使用
• PV的回收策略问题
• 存储后端删除失败

解决方法：
• 先删除使用PVC的Pod
• 检查PV的reclaimPolicy设置
• 手动清理存储后端资源
```

**核心记忆方法：**
```
🧠 记忆口诀：
"PVC申请单，声明我需要
容量模式存储类，绑定匹配不能少  
静态动态两模式，按需选择最重要
状态管理要关注，问题排查有技巧"
```

---

**🎯 学习成果检验**

完成本章学习后，你应该能够：
- [ ] 理解PVC的本质和作用
- [ ] 会创建各种类型的PVC  
- [ ] 掌握PVC与PV的绑定机制
- [ ] 能够选择合适的存储类
- [ ] 会监控和管理PVC状态
- [ ] 理解动态和静态供应的区别
- [ ] 能够排查PVC相关问题

**💡 下一步学习**
掌握了PVC后，建议继续学习：
- PV持久卷的创建和管理
- StorageClass存储类的配置
- 不同存储后端的集成方案  
- 数据备份和恢复策略