---
title: 6、Ingress流量入口管理
---
## 📚 目录

1. [Ingress入口资源概念](#1-ingress入口资源概念)
2. [Ingress Controller控制器](#2-ingress-controller控制器)
3. [基于域名路由规则](#3-基于域名路由规则)
4. [基于路径路由规则](#4-基于路径路由规则)
5. [TLS SSL证书配置](#5-tls-ssl证书配置)
6. [后端服务映射](#6-后端服务映射)
7. [路径重写规则](#7-路径重写规则)
8. [负载均衡算法选择](#8-负载均衡算法选择)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 Ingress入口资源概念


### 1.1 什么是Ingress


📍 **难度等级**：🟡 中级 - 需要理解  
📍 **重要程度**：⭐⭐⭐ 核心必会

**🔸 通俗理解**
```
想象一下：
你家小区有很多栋楼，每栋楼有很多住户
如果快递员要送包裹，他需要：
1. 先到小区门口（集群入口）
2. 看包裹上的地址（域名/路径）
3. 找到对应的楼栋和房间（后端服务）

Ingress就像是小区的"智能门卫系统"：
- 根据包裹地址自动分发到正确的住户
- 管理小区的访问规则
- 处理安全认证（门禁卡）
```

**🔸 技术定义**
```
Ingress是什么：
• Kubernetes的API资源对象
• 管理集群外部到内部服务的HTTP/HTTPS访问
• 提供负载均衡、SSL终止、基于名称的虚拟主机功能

简单说就是：
外部流量 → Ingress → 内部服务
它是进入集群的"智能大门"
```

### 1.2 为什么需要Ingress


**❓ 常见问题**：

**Q: 为什么不直接用Service暴露服务？**
**A:** 让我们对比一下就明白了

| 🆚 **对比方面** | **Service方式** | **Ingress方式** |
|-----------------|-----------------|------------------|
| 🌐 **域名支持** | 不支持域名路由 | 支持多域名管理 |
| 🛣️ **路径路由** | 无法基于路径分发 | 支持路径规则 |
| 🔒 **SSL处理** | 需要服务自己处理 | 统一SSL终止 |
| 💰 **成本** | 每个服务需要LoadBalancer | 多服务共享一个入口 |
| 🔧 **管理复杂度** | 分散管理 | 集中管理 |

**💡 实际场景举例**：
```
没有Ingress的困扰：
- 电商网站需要暴露：商品服务、用户服务、订单服务
- 每个都需要独立的LoadBalancer IP
- 用户需要记住3个不同的访问地址
- SSL证书需要在每个服务上单独配置

有了Ingress的便利：
- 只需要一个域名：shop.example.com
- 不同路径访问不同服务：
  /products → 商品服务
  /users → 用户服务
  /orders → 订单服务
- 统一的SSL证书管理
```

### 1.3 Ingress工作原理


**🔄 工作流程**：
```
Step 1 🚀 用户访问 https://api.example.com/users
  ↓
Step 2 ⚙️ DNS解析到Ingress Controller的IP
  ↓  
Step 3 🔍 Ingress Controller检查规则
  ↓
Step 4 📋 根据域名+路径匹配后端服务
  ↓
Step 5 ✅ 转发请求到对应的Service和Pod
```

**🗺️ 整体架构图**：
```
              Internet
                 |
        [Load Balancer/NodePort]
                 |
         +---------------+
         | Ingress       |
         | Controller    | ← 实际处理流量的组件
         +---------------+
                 |
         +---------------+
         | Ingress       | ← 配置规则的资源对象
         | Resource      |
         +---------------+
                 |
    +------------+------------+
    |                         |
[Service A]             [Service B]
    |                         |
[Pod Pod Pod]           [Pod Pod Pod]
```

---

## 2. 🎮 Ingress Controller控制器


### 2.1 Controller是什么


📍 **理解层次**：
```
Level 1: Ingress Controller是实际干活的工具
Level 2: Ingress资源只是配置规则的清单
Level 3: 两者配合才能实现流量管理
Level 4: 不同Controller有不同特性和优势
```

**🔸 形象类比**
```
如果把Ingress比作"交通规则手册"：
- 里面写着：红灯停、绿灯行、遇到救护车让行

那么Ingress Controller就是"交警"：
- 实际执行交通规则
- 指挥车辆按规则通行
- 处理突发情况

没有交警，规则手册只是一张纸
没有规则，交警不知道怎么指挥
```

### 2.2 常见Controller类型


**🎯 主流Controller对比**：

| Controller类型 | 🏃‍♂️ **性能** | 🔧 **易用性** | 🎯 **特色功能** |
|----------------|---------------|---------------|-----------------|
| **Nginx Ingress** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 功能全面，社区活跃 |
| **Traefik** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 自动服务发现，dashboard友好 |
| **HAProxy** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 高性能，企业级特性 |
| **Istio Gateway** | ⭐⭐⭐ | ⭐⭐ | 服务网格集成 |

**💼 选择建议**：
> 🏢 **企业生产环境**：推荐Nginx Ingress，稳定可靠
> 🚀 **快速开发测试**：推荐Traefik，配置简单
> 📈 **高性能需求**：推荐HAProxy
> 🌐 **微服务架构**：考虑Istio Gateway

### 2.3 安装Nginx Ingress Controller


**🔧 最简单的安装方式**：
```bash
# 方法1：使用官方manifest（推荐新手）
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml

# 检查安装状态
kubectl get pods -n ingress-nginx
kubectl get svc -n ingress-nginx
```

**✅ 安装成功的标志**：
```
NAME                                        READY   STATUS
ingress-nginx-controller-xxx                1/1     Running
ingress-nginx-admission-create-xxx          0/1     Completed
ingress-nginx-admission-patch-xxx           0/1     Completed
```

**🔍 验证Controller功能**：
```bash
# 查看Controller日志
kubectl logs -n ingress-nginx deployment/ingress-nginx-controller

# 检查Controller配置
kubectl describe configmap -n ingress-nginx ingress-nginx-controller
```

---

## 3. 🏷️ 基于域名路由规则


### 3.1 域名路由基础概念


**🔸 什么是域名路由**
```
通俗解释：
就像邮局按收件人地址分拣邮件一样
Ingress按访问域名把请求分发到不同服务

例如：
api.company.com → API服务
web.company.com → 前端服务  
admin.company.com → 管理后台
```

### 3.2 单域名配置示例


**🚀 最简单的域名路由**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: simple-domain-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: api.example.com          # 指定域名
    http:
      paths:
      - path: /                    # 根路径
        pathType: Prefix
        backend:
          service:
            name: api-service      # 后端服务名
            port:
              number: 80           # 服务端口
```

**💡 配置解读**：
- `host: api.example.com` - 当用户访问这个域名时
- `path: /` - 所有路径（根路径及子路径）
- `backend.service.name` - 转发到名为api-service的服务
- `port.number: 80` - 服务的80端口

### 3.3 多域名配置实战


**🎯 实际业务场景**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: multi-domain-ingress
spec:
  rules:
  # 前端网站
  - host: www.mystore.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
              
  # API接口
  - host: api.mystore.com  
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: backend-api
            port:
              number: 8080
              
  # 管理后台  
  - host: admin.mystore.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: admin-panel
            port:
              number: 3000
```

**📊 路由效果**：
```
用户访问 www.mystore.com → frontend-service:80
用户访问 api.mystore.com → backend-api:8080  
用户访问 admin.mystore.com → admin-panel:3000
```

### 3.4 域名配置注意事项


**⚠️ 常见配置问题**：

❌ **错误示例** vs ✅ **正确配置**：
```yaml
# ❌ 错误：忘记配置DNS
host: myapp.local  # DNS无法解析

# ✅ 正确：使用可解析域名或配置hosts
host: myapp.example.com

# ❌ 错误：重复的host配置
- host: api.com
- host: api.com  # 冲突！

# ✅ 正确：不同域名或用path区分
- host: api.com
- host: api-v2.com
```

**🔧 本地测试技巧**：
```bash
# 修改本地hosts文件进行测试
# Windows: C:\Windows\System32\drivers\etc\hosts  
# Linux/Mac: /etc/hosts

# 添加这些行：
192.168.1.100 api.example.com
192.168.1.100 web.example.com
192.168.1.100 admin.example.com

# 其中192.168.1.100是你的Ingress Controller IP
```

---

## 4. 🛣️ 基于路径路由规则


### 4.1 路径路由概念


**🔸 路径路由是什么**
```
形象比喻：
一个大商场里有很多店铺：
- /food → 美食广场
- /clothes → 服装区  
- /electronics → 电子产品区

路径路由就是根据访问路径，
把用户引导到不同的"店铺"（服务）
```

**🎯 pathType类型详解**：

| PathType | **匹配方式** | **示例** | **实际匹配** |
|----------|-------------|----------|--------------|
| **Exact** | 精确匹配 | `/api` | 只匹配 `/api` |
| **Prefix** | 前缀匹配 | `/api` | 匹配 `/api`, `/api/users`, `/api/v1/data` |
| **ImplementationSpecific** | 由Controller决定 | 根据具体Controller实现 | 通常等同于Prefix |

### 4.2 基础路径路由配置


**🚀 单域名多路径示例**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-based-ingress
spec:
  rules:
  - host: myapp.com
    http:
      paths:
      # API接口路径
      - path: /api                 
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 8080
              
      # 静态文件路径          
      - path: /static
        pathType: Prefix  
        backend:
          service:
            name: static-service
            port:
              number: 80
              
      # 默认前端页面（最后配置）
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
```

**💡 配置要点**：
- 更具体的路径要写在前面
- `/` 通配路径要写在最后
- pathType选择Prefix还是Exact要根据需求

### 4.3 复杂路径路由场景


**🎯 微服务架构路由**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: microservices-ingress
spec:
  rules:
  - host: api.company.com
    http:
      paths:
      # 用户服务
      - path: /users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 8080
              
      # 订单服务      
      - path: /orders
        pathType: Prefix
        backend:
          service:
            name: order-service
            port:
              number: 8080
              
      # 支付服务
      - path: /payments
        pathType: Prefix
        backend:
          service:
            name: payment-service
            port:
              number: 8080
              
      # 产品服务  
      - path: /products
        pathType: Prefix
        backend:
          service:
            name: product-service
            port:
              number: 8080
```

**📊 路由结果**：
```
GET api.company.com/users/profile → user-service
POST api.company.com/orders/create → order-service  
GET api.company.com/payments/status → payment-service
GET api.company.com/products/list → product-service
```

### 4.4 路径匹配优先级


**🔍 优先级规则**：
```yaml
# 优先级从高到低的示例
paths:
- path: /api/v2/users        # 最具体 - 优先级最高
  pathType: Exact
- path: /api/v2             # 较具体  
  pathType: Prefix
- path: /api                # 一般具体
  pathType: Prefix  
- path: /                   # 最不具体 - 优先级最低
  pathType: Prefix
```

**⚠️ 配置陷阱**：
```yaml
# ❌ 错误顺序：通配路径在前面
- path: /              # 这会拦截所有请求！
  pathType: Prefix
- path: /api          # 永远不会被匹配到
  pathType: Prefix

# ✅ 正确顺序：具体路径在前
- path: /api          
  pathType: Prefix
- path: /             # 兜底路由放最后
  pathType: Prefix  
```

---

## 5. 🔒 TLS SSL证书配置


### 5.1 SSL/TLS基础概念


📍 **重要程度**：⭐⭐⭐ 生产环境必备

**🔸 SSL/TLS是什么**
```
通俗理解：
就像给信件加密封一样
- HTTP：明信片，内容谁都能看到
- HTTPS：密封信件，只有收件人能看到内容

SSL/TLS的作用：
1. 加密传输：保护数据不被窃听
2. 身份验证：确认网站身份真实
3. 数据完整性：防止内容被篡改
```

### 5.2 证书准备和配置


**🔧 获取SSL证书的方式**：

| 证书类型 | 🏃‍♂️ **获取难度** | 💰 **成本** | 🎯 **适用场景** |
|----------|------------------|-------------|-----------------|
| **自签证书** | ⭐ | 免费 | 开发测试 |
| **Let's Encrypt** | ⭐⭐ | 免费 | 个人项目、小企业 |
| **商业证书** | ⭐⭐⭐ | 付费 | 企业生产环境 |

**🚀 创建自签证书（测试用）**：
```bash
# 生成私钥
openssl genrsa -out tls.key 2048

# 生成证书
openssl req -new -x509 -key tls.key -out tls.crt -days 365 -subj "/CN=myapp.example.com"

# 创建Kubernetes Secret
kubectl create secret tls myapp-tls --cert=tls.crt --key=tls.key
```

### 5.3 Ingress SSL配置


**🔒 基础SSL配置**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ssl-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    # 强制重定向到HTTPS
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  # TLS配置部分
  tls:
  - hosts:
    - myapp.example.com        # 证书保护的域名
    secretName: myapp-tls      # 证书Secret名称
    
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

**💡 配置说明**：
- `tls.hosts` - 指定需要SSL保护的域名
- `secretName` - 包含证书和私钥的Secret名称
- `ssl-redirect` - 自动将HTTP请求重定向到HTTPS

### 5.4 多域名SSL配置


**🎯 多域名证书配置**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: multi-ssl-ingress
spec:
  tls:
  # 第一个域名的证书
  - hosts:
    - api.mystore.com
    secretName: api-tls-secret
    
  # 第二个域名的证书  
  - hosts:
    - admin.mystore.com
    secretName: admin-tls-secret
    
  rules:
  # API域名规则
  - host: api.mystore.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 8080
              
  # 管理域名规则
  - host: admin.mystore.com  
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: admin-service
            port:
              number: 3000
```

### 5.5 Let's Encrypt自动证书


**🤖 使用cert-manager自动申请证书**：
```yaml
# 安装cert-manager (一次性设置)
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml

# 创建Let's Encrypt颁发者
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: your-email@example.com     # 你的邮箱
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        ingress:
          class: nginx
```

**🔄 自动证书Ingress配置**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: auto-tls-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    # 指定证书颁发者
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - myapp.example.com
    secretName: myapp-auto-tls    # cert-manager会自动创建
    
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

**✅ 证书申请过程**：
```
Step 1 🚀 部署Ingress配置
  ↓
Step 2 🤖 cert-manager检测到需要证书
  ↓  
Step 3 📋 向Let's Encrypt申请证书
  ↓
Step 4 ✅ 自动验证域名所有权
  ↓
Step 5 🔒 证书生成并自动续期
```

---

## 6. 🔗 后端服务映射


### 6.1 服务映射基础概念


**🔸 什么是后端服务映射**
```
简单理解：
就像快递配送的最后一步
- 快递到了小区（Ingress）
- 根据门牌号找到具体住户（Service）  
- 把包裹送到住户手中（Pod）

映射过程：
Ingress规则 → Service名称 → Service标签选择器 → Pod
```

### 6.2 基础服务映射


**🚀 最简单的映射配置**：
```yaml
# 先有Service
apiVersion: v1
kind: Service  
metadata:
  name: web-app-service
spec:
  selector:
    app: web-app        # 选择带有这个标签的Pod
  ports:
  - port: 80           # Service端口
    targetPort: 8080   # Pod内应用端口
    
---
# 再有Ingress映射
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-app-ingress
spec:
  rules:
  - host: webapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-app-service    # 对应上面的Service名称
            port:
              number: 80             # 对应Service的port
```

**🔍 映射关系链**：
```
用户请求 → Ingress → Service → Pod

具体流程：
webapp.example.com → web-app-ingress → web-app-service → app=web-app的Pod们
```

### 6.3 多服务映射实战


**🎯 电商网站服务映射示例**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ecommerce-ingress
spec:
  rules:
  - host: shop.example.com
    http:
      paths:
      # 商品展示服务
      - path: /products
        pathType: Prefix
        backend:
          service:
            name: product-service
            port:
              number: 80
              
      # 用户服务      
      - path: /api/users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 8080
              
      # 订单服务
      - path: /api/orders  
        pathType: Prefix
        backend:
          service:
            name: order-service
            port:
              number: 8080
              
      # 支付服务
      - path: /api/payments
        pathType: Prefix
        backend:
          service:
            name: payment-service
            port:
              number: 8080
              
      # 前端静态文件
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
```

### 6.4 Service配置要点


**⚠️ Service配置注意事项**：

✅ **正确的Service配置**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  selector:
    app: api-app           # 确保Pod有对应标签
    version: v1
  ports:
  - name: http            # 端口命名
    port: 80              # Service暴露端口
    targetPort: 8080      # Pod内应用端口
    protocol: TCP
  type: ClusterIP         # Ingress通常用ClusterIP
```

❌ **常见错误配置**：
```yaml
# 错误1：selector选择器不匹配
selector:
  app: wrong-name         # Pod标签是api-app，这里写错了

# 错误2：端口配置错误  
ports:
- port: 80
  targetPort: 3000        # Pod实际监听8080，这里写错了

# 错误3：使用了错误的Service类型
type: NodePort            # Ingress应该用ClusterIP
```

### 6.5 健康检查和服务发现


**🔍 验证服务映射是否正确**：
```bash
# 1. 检查Service是否创建
kubectl get svc

# 2. 检查Service对应的Endpoints
kubectl get endpoints api-service

# 3. 查看Endpoints详情
kubectl describe endpoints api-service

# 4. 测试Service连接性
kubectl run test-pod --image=curlimages/curl --rm -it -- /bin/sh
curl http://api-service.default.svc.cluster.local:80
```

**✅ 健康的服务映射标志**：
```bash
# Endpoints应该显示Pod IP和端口
NAME          ENDPOINTS                         AGE
api-service   10.244.1.10:8080,10.244.1.11:8080   5m

# 如果Endpoints为空，说明：
# 1. Service的selector不匹配任何Pod
# 2. Pod没有就绪（readiness probe失败）
# 3. Pod没有监听目标端口
```

---

## 7. 🔄 路径重写规则


### 7.1 路径重写概念


**🔸 什么是路径重写**
```
形象比喻：
就像翻译官一样
- 用户说："我要去/shop/products"  
- 翻译官对后端服务说："用户要访问/products"
- 后端服务处理/products请求
- 结果返回给用户

为什么需要重写：
- 用户看到的路径 vs 服务实际的路径可能不同
- 多个服务共享同一个域名时需要路径隔离
- 服务迁移时保持向后兼容
```

### 7.2 基础重写规则


**🚀 简单的路径重写**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-rewrite-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    # 关键配置：路径重写
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /api/v1(/|$)(.*)    # 正则表达式捕获
        pathType: Prefix
        backend:
          service:
            name: backend-service
            port:
              number: 8080
```

**💡 重写规则解释**：
```
用户访问：api.example.com/api/v1/users
匹配规则：/api/v1(/|$)(.*)
捕获组：
  $1 = / (第一个括号)
  $2 = users (第二个括号)
重写目标：/$2
最终请求：backend-service:8080/users
```

### 7.3 实际应用场景


**🎯 微服务API版本管理**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-versioning-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  rules:
  - host: api.company.com
    http:
      paths:
      # v1 API重写
      - path: /api/v1(/|$)(.*)
        pathType: Prefix  
        backend:
          service:
            name: api-v1-service
            port:
              number: 8080
              
      # v2 API重写      
      - path: /api/v2(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: api-v2-service  
            port:
              number: 8080
```

**📊 重写效果**：
```
用户请求 → 实际转发

/api/v1/users → api-v1-service:8080/users
/api/v1/orders → api-v1-service:8080/orders  
/api/v2/users → api-v2-service:8080/users
/api/v2/payments → api-v2-service:8080/payments
```

### 7.4 复杂重写场景


**🔧 多层路径重写**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: complex-rewrite-ingress
  annotations:
    # 复杂重写规则
    nginx.ingress.kubernetes.io/rewrite-target: /api/$2
spec:
  rules:
  - host: app.example.com
    http:
      paths:
      # 将 /services/xxx 重写为 /api/xxx
      - path: /services(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: microservice
            port:
              number: 8080
```

**🎯 实际重写示例**：
```
用户访问：app.example.com/services/users/profile
正则匹配：/services(/|$)(.*)
捕获结果：$1="/", $2="users/profile"  
重写目标：/api/$2
最终请求：microservice:8080/api/users/profile
```

### 7.5 重写规则调试


**🔍 调试重写规则的方法**：

```bash
# 1. 查看Ingress配置是否正确
kubectl describe ingress complex-rewrite-ingress

# 2. 查看nginx配置文件
kubectl exec -n ingress-nginx deployment/ingress-nginx-controller -- cat /etc/nginx/nginx.conf | grep rewrite

# 3. 查看Controller日志
kubectl logs -n ingress-nginx deployment/ingress-nginx-controller -f

# 4. 使用curl测试重写效果
curl -H "Host: app.example.com" http://INGRESS_IP/services/test
```

**⚠️ 常见重写错误**：

❌ **错误的正则表达式**：
```yaml
# 错误：正则语法错误
path: /api/v1(/.*)      # 缺少$符号
rewrite-target: /$1

# 正确：完整的正则表达式  
path: /api/v1(/|$)(.*)  # 包含结束符号
rewrite-target: /$2
```

❌ **捕获组不匹配**：
```yaml
# 错误：使用了不存在的捕获组
path: /api(/|$)(.*)     # 只有2个捕获组
rewrite-target: /$3     # 引用了第3个捕获组（不存在）

# 正确：捕获组对应  
path: /api(/|$)(.*)     
rewrite-target: /$2     # 使用存在的捕获组
```

---

## 8. ⚖️ 负载均衡算法选择


### 8.1 负载均衡基础


📍 **重要程度**：⭐⭐⭐ 性能优化核心

**🔸 什么是负载均衡**
```
生活中的例子：
银行有多个窗口服务客户
- 如果所有人都排一个窗口 → 效率低下
- 如果合理分配到各个窗口 → 大家都快

负载均衡就是"智能分配"：
把用户请求合理分配到多个后端Pod
让每个Pod都不会过载，整体性能最优
```

### 8.2 常见负载均衡算法


**🎯 算法对比表**：

| 算法类型 | **工作方式** | **适用场景** | **优缺点** |
|----------|-------------|-------------|-----------|
| **轮询(Round Robin)** | 依次分配请求 | 后端服务器性能相近 | 简单公平，但不考虑实际负载 |
| **加权轮询** | 根据权重分配 | 服务器性能不同 | 考虑服务器差异，配置稍复杂 |
| **最少连接** | 分配给连接数最少的服务器 | 长连接较多 | 适合持久连接，需要状态跟踪 |
| **IP哈希** | 根据客户端IP计算 | 需要会话保持 | 保证同一客户端访问同一服务器 |
| **随机** | 随机选择服务器 | 简单场景 | 实现简单，长期看比较均匀 |

### 8.3 Nginx Ingress负载均衡配置


**🚀 默认负载均衡（轮询）**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: default-lb-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    # 默认就是轮询，可以不写
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service    # 这个Service后面有多个Pod
            port:
              number: 80
```

**⚖️ 加权负载均衡**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress  
metadata:
  name: weighted-lb-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    # 配置上游负载均衡算法
    nginx.ingress.kubernetes.io/upstream-hash-by: "$request_uri"
    # 配置权重分配
    nginx.ingress.kubernetes.io/configuration-snippet: |
      upstream_conf {
        least_conn;  # 使用最少连接算法
      }
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
```

### 8.4 会话保持配置


**🔗 基于Cookie的会话保持**：
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: session-affinity-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    # 启用会话保持
    nginx.ingress.kubernetes.io/affinity: "cookie"
    # Cookie名称
    nginx.ingress.kubernetes.io/affinity-cookie-name: "server-id"  
    # Cookie过期时间
    nginx.ingress.kubernetes.io/affinity-cookie-expires: "3600"
    # Cookie路径
    nginx.ingress.kubernetes.io/affinity-cookie-path: "/"
spec:
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

**💡 会话保持原理**：
```
第一次访问：
用户请求 → Ingress分配到Pod A → 设置Cookie "server-id=pod-a"

后续访问：  
用户请求(带Cookie) → Ingress识别Cookie → 继续路由到Pod A
```

### 8.5 Service级别负载均衡


**🔧 Service层面的负载均衡**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  selector:
    app: api-app
  ports:
  - port: 80
    targetPort: 8080
  # Service级别的会话保持
  sessionAffinity: ClientIP         # 基于客户端IP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 3600          # 会话超时时间
```

**🎯 两层负载均衡**：
```
外部请求 → Ingress负载均衡 → Service负载均衡 → Pod

Ingress层：处理域名路径路由，SSL终止
Service层：Pod级别的负载分发，健康检查
```

### 8.6 负载均衡监控与调优


**📊 监控负载分布**：
```bash
# 查看Service的Endpoints
kubectl get endpoints api-service -o wide

# 查看Pod的请求分布（需要监控系统）
kubectl top pods -l app=api-app

# 查看Ingress Controller日志
kubectl logs -n ingress-nginx deployment/ingress-nginx-controller | grep "api.example.com"
```

**⚡ 性能调优建议**：
```yaml
# 针对高并发场景的优化
metadata:
  annotations:
    # 增加upstream keepalive连接
    nginx.ingress.kubernetes.io/upstream-keepalive-connections: "100"
    # 设置upstream keepalive超时
    nginx.ingress.kubernetes.io/upstream-keepalive-timeout: "60"
    # 配置proxy buffer
    nginx.ingress.kubernetes.io/proxy-buffer-size: "16k"
```

**🔍 性能测试验证**：
```bash
# 使用ab进行负载测试
ab -n 10000 -c 100 http://api.example.com/

# 使用curl验证会话保持
curl -c cookies.txt http://app.example.com/login
curl -b cookies.txt http://app.example.com/profile  # 应该路由到同一个Pod
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Ingress本质：集群的智能网关，管理外部到内部的HTTP/HTTPS流量
🔸 Controller作用：实际执行流量转发的工具，Ingress只是配置规则
🔸 域名路由：根据访问域名分发到不同服务
🔸 路径路由：根据URL路径分发到不同服务  
🔸 SSL终止：在Ingress层统一处理HTTPS加解密
🔸 服务映射：Ingress → Service → Pod的完整链路
🔸 路径重写：修改传递给后端服务的URL路径
🔸 负载均衡：在多个Pod间合理分配请求负载
```

### 9.2 关键理解要点


**🔹 Ingress vs Service的区别**
```
Service：
- 集群内部的服务发现和负载均衡
- 4层（传输层）负载均衡  
- 基于IP和端口

Ingress：
- 集群外部到内部的HTTP/HTTPS访问
- 7层（应用层）负载均衡
- 基于域名和路径
- 可以处理SSL、路径重写等高级功能
```

**🔹 配置优先级的理解**
```
路径匹配优先级：
具体路径 > 模糊路径
Exact > Prefix  
长路径 > 短路径

配置建议：
1. 把最具体的规则写在前面
2. 通配规则（如 / ）写在最后  
3. 相同路径的不同域名分开配置
```

### 9.3 实际应用价值


**💼 实战应用场景**：
- **微服务网关**：为微服务集群提供统一入口
- **多环境管理**：dev.app.com、test.app.com、prod.app.com
- **API版本管理**：/api/v1、/api/v2路由到不同服务版本
- **SSL统一管理**：在Ingress层统一处理证书和HTTPS
- **流量控制**：基于域名、路径进行流量分发和限制

**🔧 运维最佳实践**：
- **监控告警**：监控Ingress Controller状态和响应时间
- **证书管理**：使用cert-manager自动化SSL证书管理
- **安全配置**：配置适当的安全头和访问控制
- **性能调优**：根据业务特点选择合适的负载均衡算法
- **故障恢复**：配置健康检查和故障转移机制

### 9.4 学习检查点


✅ **基础掌握检查**：
- [ ] 能解释Ingress和Ingress Controller的区别
- [ ] 能配置基本的域名路由规则
- [ ] 能配置基本的路径路由规则
- [ ] 理解SSL证书在Kubernetes中的配置方法

✅ **进阶应用检查**：  
- [ ] 能设计复杂的多域名多路径路由方案
- [ ] 能配置路径重写解决服务路径不匹配问题
- [ ] 能选择合适的负载均衡算法
- [ ] 能排查Ingress相关的连接问题

✅ **生产实践检查**：
- [ ] 能设计高可用的Ingress架构
- [ ] 能配置自动化的SSL证书管理
- [ ] 能进行Ingress性能调优
- [ ] 能建立Ingress监控和告警体系

**🧠 记忆口诀**：
```
"域名路径巧分发，SSL证书保安全
Controller是实干家，负载均衡不简单  
重写规则解路径，服务映射要对应
生产环境重监控，高可用性是关键"
```

**核心记忆**：
- Ingress = 集群的智能门卫 + 流量分发器
- Controller = 实际干活的工具，Ingress = 配置规则的清单  
- 域名路由 + 路径路由 = 灵活的流量分发策略
- SSL终止 + 路径重写 + 负载均衡 = 完整的网关功能
- 理解原理 + 实践配置 + 监控调优 = 生产级应用能力