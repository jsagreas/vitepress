---
title: 7、容器网络模型CNI
---
## 📚 目录

1. [容器网络基础概念](#1-容器网络基础概念)
2. [CNI网络接口规范详解](#2-CNI网络接口规范详解)
3. [Pod网络通信模型](#3-Pod网络通信模型)
4. [主流网络插件对比](#4-主流网络插件对比)
5. [Flannel网络插件实战](#5-Flannel网络插件实战)
6. [Calico网络插件实战](#6-Calico网络插件实战)
7. [网络故障排查与优化](#7-网络故障排查与优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 容器网络基础概念


### 1.1 什么是容器网络


**🔸 简单理解**
```
想象一下住宿舍的场景：
每个宿舍房间 = 一个Pod
整栋宿舍楼   = 一个Node节点
宿舍楼之间   = 不同Node之间

问题：不同宿舍楼的同学怎么互相联系？
解决：需要一个统一的通信系统（网络）
```

**🔹 容器网络的本质**
- **隔离性**：每个容器都有自己的网络空间，就像每个房间有自己的门牌号
- **连通性**：容器之间需要能够互相通信，就像宿舍同学之间要能打电话
- **透明性**：应用不需要知道网络的复杂细节，就像打电话不需要知道电话线怎么布的

### 1.2 网络命名空间隔离


**🏠 什么是网络命名空间**
```
网络命名空间 = 一个独立的网络世界

每个命名空间都有：
- 自己的网络接口（网卡）
- 自己的IP地址
- 自己的路由表
- 自己的防火墙规则

就像每个房间都有自己的：
- 门和窗（接口）
- 地址（IP）
- 出行路线（路由）
- 安全规则（防火墙）
```

**💡 隔离的好处**
```
安全性：
容器A的网络问题不会影响容器B
就像一个房间漏水不会影响其他房间

灵活性：
每个容器可以有相同的端口号
就像每个房间都可以有自己的"1号床位"

管理性：
可以单独管理每个容器的网络
就像可以单独管理每个房间的用电
```

### 1.3 Kubernetes网络挑战


**🎯 K8s面临的网络难题**

**问题1：Pod之间通信**
```
场景：前端Pod要访问后端Pod
挑战：它们可能在不同的Node上
解决：需要一个统一的网络方案

就像：北京的同学要给上海的同学寄信
需要：全国统一的邮政系统
```

**问题2：Service发现**
```
场景：Pod重启后IP会变化
挑战：其他Pod怎么找到新的IP？
解决：需要一个"电话本"（Service）

就像：朋友换了手机号
需要：通讯录自动更新
```

**问题3：外部访问**
```
场景：用户要访问集群内的应用
挑战：外部网络和内部网络不同
解决：需要网关和负载均衡

就像：外地客人要进入小区
需要：门卫和导航系统
```

---

## 2. 🔧 CNI网络接口规范详解


### 2.1 CNI是什么


**🔸 CNI全称**：Container Network Interface（容器网络接口）

**📋 通俗理解**
```
CNI就像是：手机的充电接口标准

统一标准的好处：
- 任何符合标准的充电器都能用
- 换手机时充电器可以继续用
- 第三方可以生产兼容充电器

CNI的好处：
- 任何符合CNI的网络插件都能用
- 换网络方案时Pod不需要改动
- 第三方可以开发网络插件
```

### 2.2 CNI规范核心内容


**🔹 CNI的职责**
```
1. IP地址分配
   - 给每个Pod分配唯一的IP
   - 就像给每个房间分配门牌号

2. 网络连接建立
   - 建立Pod与网络的连接
   - 就像给房间接上网线

3. 路由配置
   - 配置数据包的传输路径
   - 就像设置快递的配送路线

4. 网络清理
   - Pod删除时清理网络资源
   - 就像退房时断开网线
```

### 2.3 CNI工作流程


**⚡ CNI插件调用过程**
```
Pod创建流程：

1. kubelet收到创建Pod的请求
   ↓
2. kubelet创建Pod的网络命名空间
   ↓  
3. kubelet调用CNI插件
   ↓
4. CNI插件分配IP并配置网络
   ↓
5. Pod可以正常通信

就像入住宿舍的流程：
申请住宿 → 分配房间 → 接通网络 → 开始生活
```

**🔧 CNI命令格式**
```bash
# CNI插件接收的基本信息
{
  "command": "ADD",           # 操作类型（添加网络）
  "containerID": "abc123",    # 容器ID
  "networkName": "mynet",     # 网络名称
  "podIP": "10.244.1.10"     # 分配的IP地址
}

# 就像酒店登记信息：
# 操作：入住
# 客人ID：身份证号
# 房间类型：标准间
# 房间号：1010
```

---

## 3. 🏗️ Pod网络通信模型


### 3.1 K8s网络通信要求


**📜 Kubernetes网络三大铁律**

**铁律1：Pod可以直接通信**
```
要求：任意两个Pod都能直接互相访问
不需要：NAT（网络地址转换）
就像：宿舍里每个房间都能直接给其他房间打电话
不用：通过总机转接
```

**铁律2：Node和Pod可以直接通信**
```
要求：Node节点可以直接访问Pod
不需要：代理或转发
就像：宿管可以直接敲任何房间的门
不用：通过其他同学传话
```

**铁律3：Pod看到的IP就是别人看到的IP**
```
要求：Pod的IP地址全局唯一且一致
不允许：内外网IP不同
就像：你的学号在整个学校都是唯一的
不能：在不同教学楼有不同学号
```

### 3.2 Pod网络通信场景


**🔄 四种主要通信场景**

**场景1：同Pod内容器通信**
```
通信方式：localhost + 端口
网络共享：共用网络命名空间

实例：
容器A：localhost:8080
容器B：localhost:3000
通信：直接通过localhost访问

就像：室友之间说话，直接开口就行
```

**场景2：同Node上Pod间通信**
```
通信路径：Pod1 → veth → 网桥 → veth → Pod2
网络设备：虚拟网桥连接

示意图：
Pod1(10.244.1.10) ←→ [网桥] ←→ Pod2(10.244.1.11)

就像：同楼层房间通过走廊相连
```

**场景3：跨Node的Pod通信**
```
通信路径：Pod1 → Node1网络 → 集群网络 → Node2网络 → Pod2
关键技术：隧道、路由、覆盖网络

示意图：
Node1                    Node2
Pod1 → [隧道] ← → [隧道] → Pod2

就像：不同城市的朋友通过互联网聊天
```

**场景4：Pod与外部通信**
```
出站：Pod → Service → 外部
入站：外部 → Ingress/NodePort → Pod

就像：住宿生要点外卖
出去：通过校门到外面
进来：外卖员通过登记进校
```

### 3.3 网络地址分配


**📍 IP地址规划**
```
集群级别：
- 集群CIDR：10.244.0.0/16 (整个集群的IP池)
- Service CIDR：10.96.0.0/12 (Service的IP池)

节点级别：
- Node1：10.244.1.0/24 (节点1的Pod IP池)
- Node2：10.244.2.0/24 (节点2的Pod IP池)

Pod级别：
- Pod-1：10.244.1.10
- Pod-2：10.244.1.11
```

**💡 地址分配策略**
```
分层分配：
就像电话号码的分配
- 国家代码：86 (中国)
- 城市代码：010 (北京)  
- 具体号码：12345678

K8s地址分配：
- 集群标识：10.244
- 节点标识：1, 2, 3...
- Pod标识：具体IP
```

---

## 4. 📊 主流网络插件对比


### 4.1 网络插件分类


**🔍 按实现方式分类**

| 类型 | **工作原理** | **典型代表** | **适用场景** |
|------|-------------|-------------|-------------|
| **Overlay网络** | `在现有网络上建立虚拟网络` | `Flannel VXLAN, Calico IPIP` | `跨云、复杂网络环境` |
| **路由网络** | `通过路由表进行转发` | `Calico BGP, Flannel host-gw` | `同一网络环境，性能要求高` |
| **Underlay网络** | `直接使用物理网络` | `Macvlan, SR-IOV` | `高性能、低延迟要求` |

**📋 通俗理解**
```
Overlay（覆盖网络）：
就像在现有的公路上建设高架桥
- 不影响原有交通
- 可以跨越复杂地形
- 稍微增加通行时间

路由网络：
就像设置交通指示牌
- 告诉车辆走哪条路
- 效率高，延迟低
- 需要统一的道路系统

Underlay（底层网络）：
就像直接使用高速公路
- 性能最好
- 需要特殊的网络环境
```

### 4.2 主流插件详细对比


**⚖️ 核心特性对比**

| 插件 | **部署难度** | **性能** | **功能特性** | **社区活跃度** |
|------|-------------|---------|-------------|---------------|
| **Flannel** | `⭐⭐⭐⭐⭐ 极简` | `⭐⭐⭐☆☆ 中等` | `基础网络功能` | `⭐⭐⭐⭐☆ 很好` |
| **Calico** | `⭐⭐⭐☆☆ 中等` | `⭐⭐⭐⭐☆ 很好` | `网络策略+安全` | `⭐⭐⭐⭐⭐ 极佳` |
| **Cilium** | `⭐⭐☆☆☆ 复杂` | `⭐⭐⭐⭐⭐ 极佳` | `eBPF+可观测性` | `⭐⭐⭐⭐☆ 很好` |
| **Weave** | `⭐⭐⭐⭐☆ 简单` | `⭐⭐⭐☆☆ 中等` | `自动发现+加密` | `⭐⭐⭐☆☆ 一般` |

**🎯 选择建议**
```
新手学习推荐：
Flannel → 配置简单，容易理解基本概念

生产环境推荐：
Calico → 功能完善，性能稳定，社区活跃

高性能场景：
Cilium → 基于eBPF，性能最佳，功能先进

特殊需求：
- 需要加密：Weave
- 云环境：云厂商CNI插件
- 高安全：Calico + NetworkPolicy
```

---

## 5. 🚀 Flannel网络插件实战


### 5.1 Flannel核心原理


**🔸 Flannel是什么**
```
Flannel = 为每个Node分配子网的简单网络方案

核心思想：
给每台机器分配一个独立的IP段
就像给每栋楼分配不同的房间号段

楼A：1001-1099
楼B：1101-1199  
楼C：1201-1299

Node1：10.244.1.0/24 (10.244.1.1-254)
Node2：10.244.2.0/24 (10.244.2.1-254)
Node3：10.244.3.0/24 (10.244.3.1-254)
```

### 5.2 Flannel工作模式


**⚡ VXLAN模式（推荐）**
```
工作原理：创建虚拟隧道传输数据

数据传输过程：
Pod1发出数据包 → Flannel封装 → 通过隧道传输 → 对端解封装 → 到达Pod2

就像：寄包裹的过程
原包裹 → 装进邮政袋 → 运输 → 取出邮政袋 → 收到包裹

优点：跨网络环境，配置简单
缺点：有一定的封装开销
```

**🔧 Host-Gateway模式**
```
工作原理：直接配置主机路由

路由示例：
目标：10.244.2.0/24，网关：Node2的IP
意思：要访问Node2上的Pod，直接发给Node2

就像：小区内部导航
去2号楼，直接走到2号楼下即可

优点：性能好，无封装开销
缺点：要求所有Node在同一网段
```

### 5.3 Flannel部署实战


**📦 快速部署步骤**

**步骤1：下载配置文件**
```bash
# 下载官方配置
wget https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml

# 检查配置内容
grep -A 5 -B 5 "10.244.0.0/16" kube-flannel.yml
```

**步骤2：修改网络配置**
```yaml
# 在ConfigMap中确认网络配置
data:
  cni-conf.json: |
    {
      "name": "cbr0",
      "type": "flannel",
      "delegate": {
        "hairpinMode": true,
        "isDefaultGateway": true
      }
    }
  net-conf.json: |
    {
      "Network": "10.244.0.0/16",
      "Backend": {
        "Type": "vxlan"
      }
    }
```

**步骤3：部署Flannel**
```bash
# 应用配置
kubectl apply -f kube-flannel.yml

# 检查部署状态
kubectl get pods -n kube-system | grep flannel
kubectl get nodes -o wide
```

**🔍 验证网络连通性**
```bash
# 创建测试Pod
kubectl run test-pod-1 --image=busybox --command -- sleep 3600
kubectl run test-pod-2 --image=busybox --command -- sleep 3600

# 获取Pod IP
kubectl get pods -o wide

# 测试连通性
kubectl exec test-pod-1 -- ping <test-pod-2-ip>

# 查看路由信息
kubectl exec test-pod-1 -- route -n
```

---

## 6. 🔒 Calico网络插件实战


### 6.1 Calico核心特性


**🎯 Calico的优势**
```
1. 纯三层网络
   - 不需要隧道封装
   - 每个Pod都是真实的IP
   - 就像每个房间都有真实的门牌号

2. BGP路由协议  
   - 自动学习和传播路由
   - 就像GPS自动更新最佳路线

3. 网络策略支持
   - 精细的访问控制
   - 就像门禁系统控制进出权限

4. 高性能
   - 无封装开销
   - 接近原生网络性能
```

### 6.2 Calico工作原理


**📡 BGP路由学习**
```
BGP工作过程：

1. 每个Node运行BGP客户端
2. Node之间交换路由信息
3. 自动学习Pod IP的访问路径

实际效果：
Node1知道：要访问10.244.2.x，发给Node2
Node2知道：要访问10.244.1.x，发给Node1
Node3知道：要访问10.244.1.x，发给Node1

就像：快递员知道每个小区的送达路线
```

**🔍 数据包转发流程**
```
跨Node通信流程：

Pod1(10.244.1.10) 发送数据到 Pod2(10.244.2.20)
      ↓
检查路由表：10.244.2.0/24 via Node2
      ↓  
直接发送到Node2网卡
      ↓
Node2接收并转发给Pod2

无需隧道封装，直接IP路由！
```

### 6.3 Calico部署实战


**📦 Calico安装步骤**

**步骤1：下载配置文件**
```bash
# 下载Calico配置
curl https://docs.projectcalico.org/manifests/calico.yaml -O

# 检查CIDR配置(确保与集群一致)
grep -A 1 -B 1 CALICO_IPV4POOL_CIDR calico.yaml
```

**步骤2：修改配置（如需要）**
```yaml
# 在calico.yaml中找到并修改
- name: CALICO_IPV4POOL_CIDR
  value: "10.244.0.0/16"  # 确保与集群CIDR一致

# 选择网络模式
- name: CALICO_IPV4POOL_IPIP
  value: "Always"         # Always|CrossSubnet|Never
```

**步骤3：部署Calico**
```bash
# 部署Calico
kubectl apply -f calico.yaml

# 等待Pod就绪
kubectl get pods -n kube-system | grep calico

# 检查Node状态
kubectl get nodes
```

### 6.4 网络策略实战


**🔐 NetworkPolicy基础**
```yaml
# 示例：拒绝所有入站流量
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  podSelector: {}  # 选择所有Pod
  policyTypes:
  - Ingress        # 控制入站流量
```

**🎯 实用策略示例**
```yaml
# 只允许特定标签的Pod访问数据库
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-app-to-db
spec:
  podSelector:
    matchLabels:
      app: database
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 3306
```

**✅ 验证策略效果**
```bash
# 创建测试Pod
kubectl run db --image=nginx --labels="app=database"
kubectl run app --image=busybox --labels="app=frontend" -- sleep 3600
kubectl run hacker --image=busybox -- sleep 3600

# 测试连通性
kubectl exec app -- wget -qO- http://db-pod-ip    # 应该成功
kubectl exec hacker -- wget -qO- http://db-pod-ip # 应该失败
```

---

## 7. 🔧 网络故障排查与优化


### 7.1 常见网络问题


**❌ 问题1：Pod无法启动**
```
症状：Pod一直处于ContainerCreating状态

排查命令：
kubectl describe pod <pod-name>
kubectl logs -n kube-system <cni-pod>

常见原因：
- CNI插件未正确安装
- 网络配置冲突
- IP地址池耗尽

就像：房间分配出了问题
- 没有可用房间了
- 房管系统故障
- 房间号码冲突
```

**❌ 问题2：Pod间无法通信**
```
症状：ping不通，服务无法访问

排查步骤：
1. 检查Pod IP分配
   kubectl get pods -o wide

2. 测试网络连通性
   kubectl exec pod1 -- ping pod2-ip

3. 检查路由配置
   kubectl exec pod1 -- route -n

4. 检查NetworkPolicy
   kubectl get networkpolicy
```

### 7.2 网络诊断工具


**🔍 诊断命令合集**
```bash
# 查看网络插件状态
kubectl get pods -n kube-system | grep -E "(flannel|calico|cilium)"

# 检查Node网络配置
kubectl get nodes -o yaml | grep podCIDR

# 查看网络接口
ip addr show
ip route show

# 测试DNS解析
kubectl exec pod -- nslookup kubernetes.default

# 检查网络策略
kubectl get networkpolicy --all-namespaces
```

**🔧 网络调试Pod**
```yaml
# 创建网络调试Pod
apiVersion: v1
kind: Pod
metadata:
  name: network-debug
spec:
  containers:
  - name: debug
    image: nicolaka/netshoot
    command: ["/bin/bash"]
    args: ["-c", "sleep 3600"]
```

### 7.3 性能优化建议


**⚡ 网络性能优化**
```
1. 选择合适的CNI插件
   - 高性能需求：Calico BGP模式
   - 简单环境：Flannel host-gateway模式
   - 复杂环境：Calico IPIP模式

2. 调整网络参数
   - 增大接收缓冲区
   - 优化TCP参数
   - 启用网卡多队列

3. 合理规划网络
   - 避免跨AZ通信
   - 使用亲和性调度
   - 优化Service类型选择
```

**📊 性能监控指标**
```
关键监控项：
- 网络延迟：ping延迟，应用响应时间
- 网络带宽：入站/出站流量
- 丢包率：重传率，错误包数量
- 连接数：活跃连接，TIME_WAIT状态

监控工具：
- Prometheus + Grafana
- kubectl top pods
- iftop, nethogs
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 CNI规范：容器网络的统一标准，像手机充电接口
🔸 网络模型：Pod直接通信，无NAT转换，全局IP一致  
🔸 网络插件：Flannel简单易用，Calico功能强大
🔸 通信场景：同Pod、同Node、跨Node、对外四种场景
🔸 故障排查：从Pod状态到网络连通性逐步诊断
```

### 8.2 关键理解要点


**🔹 网络插件选择策略**
```
学习阶段：
Flannel → 简单直观，容易理解原理

生产环境：
Calico → 性能好，功能全，社区活跃

特殊需求：
- 高性能：Cilium (eBPF)
- 安全要求高：Calico + NetworkPolicy
- 云环境：云厂商提供的CNI
```

**🔹 网络故障排查思路**
```
分层排查法：
1. Pod层：检查Pod状态和IP分配
2. Node层：检查路由和网络接口
3. 集群层：检查CNI插件和配置
4. 应用层：检查Service和Ingress

就像修网络故障：
先查设备 → 再查线路 → 最后查配置
```

**🔹 网络安全最佳实践**
```
默认拒绝原则：
- 创建deny-all策略作为基线
- 只开放必要的访问权限
- 定期审查网络策略

分层防护：
- 网络层：NetworkPolicy控制流量
- 传输层：TLS加密通信
- 应用层：认证和授权
```

### 8.3 实际应用价值


- **运维管理**：理解网络原理，快速定位网络问题
- **架构设计**：选择合适的网络方案，优化应用性能
- **安全防护**：使用网络策略，实现微分段安全
- **性能优化**：基于网络特性，优化应用部署策略

**🎯 学习建议**：
- **动手实践**：在测试环境部署不同的CNI插件
- **对比分析**：比较不同插件的性能和特性
- **问题导向**：遇到网络问题时深入分析原因
- **持续学习**：关注网络技术发展趋势

**核心记忆口诀**：
- CNI统一标准接口，插件实现各有特色
- Pod直连全局IP，三层网络性能好
- Flannel简单易上手，Calico功能更全面  
- 网络故障分层查，从下到上不遗漏