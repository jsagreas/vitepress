---
title: 3、异常类型系统
---
## 📚 目录

1. [异常系统概述](#1-异常系统概述)
2. [异常类继承层次](#2-异常类继承层次)
3. [BaseException基类详解](#3-baseexception基类详解)
4. [Exception标准异常](#4-exception标准异常)
5. [系统异常类型](#5-系统异常类型)
6. [运行时异常类型](#6-运行时异常类型)
7. [内置异常详解](#7-内置异常详解)
8. [异常分类策略](#8-异常分类策略)
9. [异常选择原则](#9-异常选择原则)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🐍 异常系统概述


### 1.1 什么是异常类型系统


**简单理解**：异常类型系统就像是一个**错误分类管理器**，把各种可能出现的错误按照类型整理归类，让我们能够准确识别和处理不同的问题。

```
生活中的例子：
医院科室分类：
- 内科 → 处理内部疾病
- 外科 → 处理外伤问题  
- 眼科 → 处理视力问题

Python异常分类：
- ValueError → 处理值错误
- TypeError → 处理类型错误
- FileNotFoundError → 处理文件找不到
```

### 1.2 为什么需要异常类型系统


**🎯 核心作用**：
- **精确识别**：知道具体是什么类型的错误
- **针对处理**：根据错误类型采取相应措施
- **代码健壮**：让程序能优雅地处理各种意外情况
- **调试方便**：快速定位问题所在

```python
# 没有异常分类的世界（想象一下）
try:
    result = int("abc")
except:
    print("出错了")  # 但不知道是什么错误

# 有异常分类的好处
try:
    result = int("abc")
except ValueError:
    print("输入的不是有效数字")  # 知道具体问题
except TypeError:
    print("输入的类型不对")
```

### 1.3 异常系统的设计理念


**🔸 层次化设计**：
- 像家族族谱一样，有祖先、父母、子女关系
- 越具体的异常，越靠近"族谱"底部
- 越通用的异常，越靠近"族谱"顶部

**🔸 继承机制**：
- 子异常自动拥有父异常的所有特性
- 可以用父异常来捕获子异常
- 提供了灵活的处理方式

---

## 2. 🌳 异常类继承层次


### 2.1 完整的异常家族树


```
异常继承关系图：

BaseException                    ← 异常界的"始祖"
 ├── SystemExit                  ← 程序退出异常
 ├── KeyboardInterrupt           ← 键盘中断（Ctrl+C）
 ├── GeneratorExit               ← 生成器退出
 └── Exception                   ← 标准异常"族长"
      ├── StopIteration          ← 迭代结束
      ├── StopAsyncIteration     ← 异步迭代结束
      ├── ArithmeticError        ← 算术错误家族
      │    ├── OverflowError     ← 数值溢出
      │    ├── ZeroDivisionError ← 除零错误
      │    └── FloatingPointError← 浮点数错误
      ├── BufferError            ← 缓冲区错误
      ├── LookupError            ← 查找错误家族
      │    ├── IndexError        ← 索引超出范围
      │    └── KeyError          ← 字典键不存在
      ├── AssertionError         ← 断言失败
      ├── AttributeError         ← 属性错误
      ├── EOFError               ← 文件结束错误
      ├── ImportError            ← 导入错误家族
      │    └── ModuleNotFoundError ← 模块找不到
      ├── RuntimeError           ← 运行时错误家族
      │    ├── NotImplementedError ← 功能未实现
      │    └── RecursionError    ← 递归过深
      ├── SyntaxError            ← 语法错误家族
      │    └── IndentationError  ← 缩进错误
      │         └── TabError     ← Tab缩进错误
      ├── SystemError            ← 系统错误
      ├── TypeError              ← 类型错误
      ├── ValueError             ← 值错误家族
      │    └── UnicodeError      ← Unicode编码错误
      └── OSError                ← 操作系统错误家族
           ├── FileNotFoundError ← 文件找不到
           ├── PermissionError   ← 权限错误
           └── ConnectionError   ← 连接错误
```

### 2.2 家族关系的实际意义


**👨‍👩‍👧‍👦 继承关系例子**：

```python
# 捕获"父异常"会同时捕获所有"子异常"
try:
    numbers = [1, 2, 3]
    print(numbers[10])  # IndexError
except LookupError:  # 父异常
    print("查找相关的错误")  # 能捕获IndexError

try:
    result = 10 / 0  # ZeroDivisionError
except ArithmeticError:  # 父异常
    print("数学计算错误")  # 能捕获ZeroDivisionError
```

**🔍 查看异常的家族关系**：

```python
# 查看异常的父类
print(IndexError.__bases__)  # (<class 'LookupError'>,)
print(LookupError.__bases__)  # (<class 'Exception'>,)

# 查看异常的所有祖先
print(IndexError.__mro__)
# (<class 'IndexError'>, <class 'LookupError'>, 
#  <class 'Exception'>, <class 'BaseException'>, <class 'object'>)
```

---

## 3. 🏛️ BaseException基类详解


### 3.1 BaseException是什么


**简单理解**：`BaseException`就是**异常界的大祖宗**，所有异常都是它的后代。就像人类都有共同祖先一样，所有Python异常都继承自BaseException。

### 3.2 BaseException的特殊地位


**🔸 为什么不直接继承Exception**：

```python
# BaseException的直接子类有特殊用途
BaseException
├── SystemExit      # 程序正常退出，不应该被普通异常处理捕获
├── KeyboardInterrupt  # 用户中断（Ctrl+C），应该能够终止程序
├── GeneratorExit   # 生成器清理，系统内部使用
└── Exception      # 普通程序异常，我们主要处理的
```

**⚠️ 重要区别**：

```python
# 不推荐：捕获BaseException会拦截系统退出
try:
    exit()  # 想要退出程序
except BaseException:
    print("被拦截了！程序无法正常退出")

# 推荐：只捕获Exception
try:
    some_operation()
except Exception:
    print("处理程序错误，但不阻止系统退出")
```

### 3.3 BaseException的核心属性


```python
class BaseException:
    """所有异常的基类"""
    
    def __init__(self, *args):
        self.args = args  # 存储异常参数
    
    def __str__(self):
        # 异常的字符串表示
        return str(self.args[0]) if self.args else ''
    
    def __repr__(self):
        # 异常的正式表示
        return f"{self.__class__.__name__}{self.args!r}"
```

**实际使用示例**：

```python
# 创建异常实例
error = ValueError("输入的数字无效")
print(error.args)      # ('输入的数字无效',)
print(str(error))      # 输入的数字无效
print(repr(error))     # ValueError('输入的数字无效')

# 多个参数的异常
error = OSError(2, "文件不存在", "test.txt")
print(error.args)      # (2, '文件不存在', 'test.txt')
```

---

## 4. 🎯 Exception标准异常


### 4.1 Exception的重要性


**简单理解**：`Exception`是我们**日常编程中最常处理的异常类型**，它是所有"程序级别"异常的父类。就像Exception是"异常王国的国王"，管理着我们程序中可能遇到的各种错误。

### 4.2 Exception vs BaseException对比


| 特征 | **BaseException** | **Exception** |
|------|------------------|---------------|
| **职责** | `系统级异常管理` | `程序级异常管理` |
| **包含范围** | `所有异常` | `程序运行异常` |
| **捕获建议** | `通常不直接捕获` | `日常开发主要捕获` |
| **典型场景** | `系统退出、中断` | `业务逻辑错误` |

```python
# Exception的主要作用
try:
    # 各种可能的程序错误
    user_input = input("输入一个数字: ")
    number = int(user_input)  # 可能ValueError
    result = 10 / number      # 可能ZeroDivisionError
    data = [1, 2, 3]
    print(data[number])       # 可能IndexError
    
except Exception as e:
    print(f"程序出现错误: {e}")
    print(f"错误类型: {type(e).__name__}")
```

### 4.3 Exception的子类分类


**🔸 按错误来源分类**：

```
输入输出错误：
├── ValueError      # 值不合适
├── TypeError       # 类型不对
└── KeyError        # 键不存在

运算相关错误：
├── ZeroDivisionError   # 除零
├── OverflowError       # 溢出
└── FloatingPointError  # 浮点运算

系统交互错误：
├── FileNotFoundError   # 文件找不到
├── PermissionError     # 权限不够
└── ConnectionError     # 连接问题
```

---

## 5. 🔧 系统异常类型


### 5.1 什么是系统异常


**简单理解**：系统异常是**Python解释器和操作系统交互时可能出现的错误**，通常涉及文件操作、网络连接、系统资源等。

### 5.2 主要系统异常类型


#### 🗂️ OSError家族


**核心理解**：`OSError`是**操作系统相关错误的大家长**，所有与系统交互出现的问题都归它管。

```python
# OSError的常见子类型
import os

# FileNotFoundError - 文件找不到
try:
    with open("不存在的文件.txt", "r") as f:
        content = f.read()
except FileNotFoundError:
    print("文件不存在")

# PermissionError - 权限不足  
try:
    with open("/root/system.log", "w") as f:
        f.write("test")
except PermissionError:
    print("没有写入权限")

# IsADirectoryError - 试图当文件操作目录
try:
    with open("/home", "r") as f:
        content = f.read()
except IsADirectoryError:
    print("这是一个目录，不是文件")
```

#### 🌐 ConnectionError家族


```python
import requests

# ConnectionError的实际应用
try:
    response = requests.get("http://不存在的网站.com", timeout=5)
except ConnectionError:
    print("网络连接失败")
except TimeoutError:
    print("连接超时")
```

### 5.3 系统异常的错误码


```python
import errno

try:
    os.open("不存在的文件.txt", os.O_RDONLY)
except OSError as e:
    print(f"错误码: {e.errno}")
    print(f"错误信息: {e.strerror}")
    
    # 根据错误码判断具体问题
    if e.errno == errno.ENOENT:
        print("文件或目录不存在")
    elif e.errno == errno.EACCES:
        print("权限被拒绝")
```

---

## 6. ⚡ 运行时异常类型


### 6.1 什么是运行时异常


**通俗解释**：运行时异常是**程序运行过程中可能出现的各种逻辑错误**，代码语法没问题，但执行时出现了意料之外的情况。

### 6.2 常见运行时异常详解


#### 🔢 算术运算异常


```python
# ZeroDivisionError - 除零错误
def safe_divide(a, b):
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        return "不能除以零"

print(safe_divide(10, 2))   # 5.0
print(safe_divide(10, 0))   # 不能除以零

# OverflowError - 数值溢出（在特定情况下）
import math
try:
    result = math.exp(1000)  # e的1000次方
except OverflowError:
    print("数值过大，导致溢出")
```

#### 📋 查找访问异常


```python
# IndexError - 索引超出范围
data = [1, 2, 3, 4, 5]
try:
    print(data[10])  # 索引10不存在
except IndexError:
    print("索引超出列表范围")

# KeyError - 字典键不存在
student = {"name": "张三", "age": 20}
try:
    grade = student["grade"]  # 键不存在
except KeyError:
    print("该学生没有成绩记录")

# AttributeError - 属性不存在
try:
    result = "hello".append("world")  # 字符串没有append方法
except AttributeError:
    print("字符串对象没有append属性")
```

#### 🏷️ 类型和值异常


```python
# TypeError - 类型错误
try:
    result = "hello" + 123  # 字符串不能直接和数字相加
except TypeError:
    print("类型不匹配，不能进行运算")

# ValueError - 值错误
try:
    number = int("abc")  # "abc"不能转换为整数
except ValueError:
    print("输入的字符串不是有效数字")

try:
    import math
    result = math.sqrt(-1)  # 负数不能开平方根
except ValueError:
    print("负数不能计算平方根")
```

### 6.3 运行时异常的预防策略


```python
# 防御性编程示例
def robust_function(data, index, key):
    """健壮的函数示例"""
    
    # 检查数据类型
    if not isinstance(data, (list, dict)):
        raise TypeError("data必须是列表或字典")
    
    if isinstance(data, list):
        # 检查索引范围
        if not (0 <= index < len(data)):
            raise IndexError(f"索引{index}超出范围[0, {len(data)-1}]")
        return data[index]
    
    elif isinstance(data, dict):
        # 检查键是否存在
        if key not in data:
            raise KeyError(f"键'{key}'不存在")
        return data[key]
```

---

## 7. 📖 内置异常详解


### 7.1 最常见的内置异常


#### ✨ ValueError详解


**含义**：传入了正确类型但不合适的值

```python
# ValueError的典型场景
scenarios = {
    "数字转换": lambda: int("12.5"),        # 小数格式不能直接转整数
    "数学运算": lambda: math.sqrt(-1),      # 负数开方
    "日期解析": lambda: datetime.strptime("2023-13-01", "%Y-%m-%d"),  # 13月
    "列表查找": lambda: [1,2,3].index(5),   # 查找不存在的元素
}

for name, func in scenarios.items():
    try:
        func()
    except ValueError as e:
        print(f"{name}: {e}")
```

#### 🔤 TypeError详解


**含义**：使用了错误的数据类型

```python
# TypeError的典型场景
def demonstrate_type_errors():
    
    # 1. 不支持的运算
    try:
        result = "hello" - "world"
    except TypeError:
        print("字符串不支持减法运算")
    
    # 2. 错误的参数类型
    try:
        len(123)  # len()期望可迭代对象
    except TypeError:
        print("len()不能用于整数")
    
    # 3. 不可调用的对象
    try:
        number = 42
        result = number()  # 整数不能像函数一样调用
    except TypeError:
        print("整数对象不可调用")

demonstrate_type_errors()
```

#### 🗝️ AttributeError详解


**含义**：对象没有指定的属性或方法

```python
# AttributeError的常见情况
class Student:
    def __init__(self, name):
        self.name = name
    
    def study(self):
        return f"{self.name} is studying"

student = Student("小明")

try:
    # 访问不存在的属性
    print(student.age)
except AttributeError:
    print("学生对象没有age属性")

try:
    # 调用不存在的方法
    student.fly()
except AttributeError:
    print("学生对象没有fly方法")

# 字符串常见的AttributeError
text = "hello"
try:
    text.append("world")  # 字符串没有append方法
except AttributeError:
    print("字符串对象没有append方法")
```

### 7.2 语法相关异常


#### 📝 SyntaxError家族


```python
# SyntaxError在运行时通常不会遇到，因为代码无法执行
# 但在动态执行代码时可能遇到

try:
    exec("if True print('hello')")  # 缺少冒号
except SyntaxError:
    print("语法错误：if语句缺少冒号")

try:
    compile("def func(\n    pass", "<string>", "exec")
except SyntaxError:
    print("语法错误：函数定义不完整")

# IndentationError - 缩进错误
code_with_indent_error = """
def test():
print("缩进错误")
"""

try:
    exec(code_with_indent_error)
except IndentationError:
    print("缩进错误：函数体需要缩进")
```

### 7.3 导入相关异常


```python
# ImportError和ModuleNotFoundError
try:
    import 不存在的模块
except ModuleNotFoundError:
    print("模块找不到")

try:
    from os import 不存在的函数
except ImportError:
    print("无法从模块导入指定内容")

# 条件导入的实用模式
try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False
    print("NumPy未安装，将使用原生Python实现")

def array_sum(data):
    if HAS_NUMPY:
        return np.sum(data)
    else:
        return sum(data)
```

---

## 8. 🎨 异常分类策略


### 8.1 按异常性质分类


```
异常严重程度分类：

🔴 致命异常 (Critical)
├── SystemExit          # 程序退出
├── KeyboardInterrupt   # 用户中断
└── MemoryError         # 内存不足

🟡 业务异常 (Business)  
├── ValueError          # 业务数据错误
├── TypeError           # 业务类型错误
└── CustomBusinessError # 自定义业务异常

🟢 可恢复异常 (Recoverable)
├── FileNotFoundError   # 文件操作错误
├── ConnectionError     # 网络连接错误
└── TimeoutError        # 超时错误

🔵 逻辑异常 (Logic)
├── IndexError          # 索引错误
├── KeyError           # 键错误
└── AttributeError     # 属性错误
```

### 8.2 按异常来源分类


```python
# 按来源分类异常处理
def comprehensive_error_handling():
    
    # 用户输入异常
    try:
        user_input = input("请输入数字: ")
        number = float(user_input)
    except ValueError:
        print("🔴 用户输入错误：请输入有效数字")
        return
    
    # 系统资源异常
    try:
        with open("data.txt", "r") as f:
            data = f.read()
    except FileNotFoundError:
        print("🟡 系统资源错误：数据文件不存在")
        return
    except PermissionError:
        print("🟡 系统权限错误：无法读取文件")
        return
    
    # 网络通信异常
    try:
        import requests
        response = requests.get("https://api.example.com/data")
    except ConnectionError:
        print("🔵 网络连接错误：无法连接到服务器")
        return
    except TimeoutError:
        print("🔵 网络超时错误：请求超时")
        return
    
    # 数据处理异常
    try:
        result = number / 0
    except ZeroDivisionError:
        print("🟢 计算逻辑错误：除数不能为零")
        return
```

### 8.3 异常处理的优先级策略


```python
def exception_priority_demo():
    """异常处理优先级示例"""
    
    try:
        # 可能出现多种异常的操作
        data = {"numbers": [1, 2, 3]}
        key = input("输入键名: ")
        index = int(input("输入索引: "))
        result = data[key][index] / 0
        
    # 优先级1: 最具体的异常
    except ZeroDivisionError:
        print("🔴 最高优先级：除零错误")
        
    except IndexError:
        print("🟡 高优先级：索引超出范围")
        
    except KeyError:
        print("🟡 高优先级：键不存在")
        
    except ValueError:
        print("🟢 中优先级：输入值格式错误")
        
    except TypeError:
        print("🔵 中优先级：类型不匹配")
        
    # 优先级2: 中等范围的异常
    except LookupError:
        print("🟣 中等优先级：查找相关错误")
        
    # 优先级3: 最通用的异常
    except Exception:
        print("⚪ 最低优先级：其他未知错误")
```

---

## 9. 🎯 异常选择原则


### 9.1 选择合适异常类型的指导原则


#### 📋 异常选择决策树


```
异常选择流程：

1. 是否是系统级问题？
   ├── 是 → 使用OSError家族
   └── 否 → 继续判断

2. 是否是数据类型问题？
   ├── 是 → 使用TypeError
   └── 否 → 继续判断

3. 是否是数据值问题？
   ├── 是 → 使用ValueError
   └── 否 → 继续判断

4. 是否是查找访问问题？
   ├── 是 → 使用LookupError家族
   │       ├── 索引问题 → IndexError
   │       └── 键问题 → KeyError
   └── 否 → 继续判断

5. 是否是属性方法问题？
   ├── 是 → 使用AttributeError
   └── 否 → 使用RuntimeError或自定义异常
```

### 9.2 实际场景中的异常选择


```python
# 场景1: 输入验证函数
def validate_age(age):
    """年龄验证函数"""
    
    # 类型检查
    if not isinstance(age, (int, float)):
        raise TypeError(f"年龄必须是数字，不能是{type(age).__name__}")
    
    # 值范围检查
    if age < 0:
        raise ValueError("年龄不能为负数")
    
    if age > 150:
        raise ValueError("年龄不能超过150岁")
    
    return True

# 场景2: 文件处理函数
def read_config_file(filename):
    """配置文件读取函数"""
    
    # 文件存在性检查
    if not os.path.exists(filename):
        raise FileNotFoundError(f"配置文件 {filename} 不存在")
    
    # 权限检查
    if not os.access(filename, os.R_OK):
        raise PermissionError(f"没有权限读取文件 {filename}")
    
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()
    except UnicodeDecodeError:
        raise ValueError(f"文件 {filename} 编码格式不正确")
    
    return content

# 场景3: 数据库连接函数
def connect_database(host, port, username, password):
    """数据库连接函数"""
    
    # 参数类型检查
    if not isinstance(port, int):
        raise TypeError("端口号必须是整数")
    
    # 参数值检查
    if not (1 <= port <= 65535):
        raise ValueError("端口号必须在1-65535范围内")
    
    if not username:
        raise ValueError("用户名不能为空")
    
    try:
        # 模拟连接数据库
        connection = create_connection(host, port, username, password)
    except socket.timeout:
        raise TimeoutError(f"连接数据库超时：{host}:{port}")
    except socket.gaierror:
        raise ConnectionError(f"无法解析主机名：{host}")
    
    return connection
```

### 9.3 自定义异常的使用时机


```python
# 何时创建自定义异常
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
    
    def withdraw(self, amount):
        # 使用内置异常处理基本问题
        if not isinstance(amount, (int, float)):
            raise TypeError("取款金额必须是数字")
        
        if amount <= 0:
            raise ValueError("取款金额必须大于0")
        
        # 使用自定义异常处理业务逻辑
        if amount > self.balance:
            raise InsufficientFundsError(
                f"余额不足：当前余额{self.balance}，尝试取款{amount}"
            )
        
        self.balance -= amount
        return self.balance

# 自定义异常类
class InsufficientFundsError(Exception):
    """余额不足异常"""
    def __init__(self, message, balance=None, requested_amount=None):
        super().__init__(message)
        self.balance = balance
        self.requested_amount = requested_amount

# 使用示例
account = BankAccount(100)
try:
    account.withdraw(150)
except TypeError:
    print("输入类型错误")
except ValueError:
    print("输入值错误") 
except InsufficientFundsError as e:
    print(f"业务错误：{e}")
```

### 9.4 异常链的使用


```python
# 异常链：保留原始异常信息的同时抛出新异常
def parse_user_data(data_string):
    """解析用户数据"""
    try:
        # 尝试解析JSON
        import json
        data = json.loads(data_string)
        
        # 验证必要字段
        if 'name' not in data:
            raise ValueError("缺少name字段")
        
        return data
        
    except json.JSONDecodeError as e:
        # 使用 raise...from 保留原始异常
        raise ValueError(f"用户数据格式无效") from e
    
    except Exception as e:
        # 通用异常处理
        raise RuntimeError(f"解析用户数据时发生未知错误") from e

# 使用异常链
try:
    result = parse_user_data('{"invalid": json}')
except ValueError as e:
    print(f"业务错误: {e}")
    print(f"原始错误: {e.__cause__}")
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 异常继承体系：BaseException → Exception → 具体异常类
🔸 异常分类理解：系统异常、运行时异常、业务异常
🔸 常用异常类型：ValueError、TypeError、KeyError、IndexError等
🔸 异常选择原则：根据错误性质选择合适的异常类型
🔸 异常处理策略：从具体到通用的捕获顺序
```

### 10.2 关键理解要点


**🔹 异常继承的意义**：
- **代码复用**：子异常自动拥有父异常的特性
- **灵活捕获**：可以用父异常捕获所有子异常
- **层次管理**：提供了从通用到具体的错误分类

**🔹 BaseException vs Exception**：
- **BaseException**：系统级异常，包含程序退出、中断等
- **Exception**：程序级异常，日常开发主要处理的类型
- **建议**：一般只捕获Exception，让系统异常正常工作

**🔹 异常选择的核心思路**：
```
选择原则：
1. 优先使用内置异常
2. 根据错误性质选择类型
3. 从具体到通用的顺序
4. 业务特殊需求才自定义
```

### 10.3 实际应用指导


**💡 日常开发建议**：

```python
# ✅ 好的异常处理模式
def robust_function(data):
    try:
        # 具体的业务逻辑
        result = process_data(data)
        return result
        
    except ValueError:
        # 处理值相关错误
        logging.error("数据值错误")
        raise
        
    except TypeError:
        # 处理类型相关错误
        logging.error("数据类型错误")
        raise
        
    except Exception:
        # 处理其他未预期错误
        logging.error("未知错误", exc_info=True)
        raise

# ❌ 避免的模式
def bad_function(data):
    try:
        return process_data(data)
    except:  # 太宽泛，会掩盖问题
        return None
```

**🔧 调试技巧**：

```python
# 查看异常的完整信息
import traceback

try:
    # 可能出错的代码
    problematic_operation()
except Exception as e:
    # 打印异常类型
    print(f"异常类型: {type(e).__name__}")
    
    # 打印异常消息
    print(f"异常消息: {str(e)}")
    
    # 打印完整的调用栈
    traceback.print_exc()
    
    # 查看异常的继承链
    print(f"异常继承链: {type(e).__mro__}")
```

### 10.4 记忆要点


**🎯 异常体系记忆口诀**：
- BaseException是祖宗，Exception是族长
- ValueError值不对，TypeError类型错
- KeyError键不在，IndexError越界了
- FileNotFound文件无，PermissionError权限缺
- 从具体到通用，异常捕获有序列

**🔍 异常选择记忆法**：
- **看类型选TypeError**，**看值选ValueError**
- **看访问选LookupError**，**看文件选OSError**
- **看属性选AttributeError**，**看业务选自定义**

**核心原则**：
- 异常体系有层次，继承关系要理解
- 选择异常看性质，处理顺序从具体到通用
- 系统异常不要拦，程序异常要处理
- 自定义异常慎使用，内置异常够大部分需求