---
title: 6、继承机制详解
---
## 📚 目录

1. [继承的概念与作用](#1-继承的概念与作用)
2. [单继承语法详解](#2-单继承语法详解)
3. [父类与子类关系](#3-父类与子类关系)
4. [继承属性与方法](#4-继承属性与方法)
5. [super()函数的使用](#5-super函数的使用)
6. [方法解析顺序MRO](#6-方法解析顺序mro)
7. [方法重写与扩展](#7-方法重写与扩展)
8. [构造函数继承](#8-构造函数继承)
9. [继承设计原则](#9-继承设计原则)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 继承的概念与作用


### 1.1 什么是继承


**简单理解**：继承就像现实生活中的"传承"概念

```
现实生活中的继承：
父亲的财产 → 儿子继承 → 儿子拥有父亲的财产
父亲的技能 → 儿子学习 → 儿子掌握父亲的技能

编程中的继承：
父类的属性 → 子类继承 → 子类拥有父类的属性  
父类的方法 → 子类继承 → 子类掌握父类的方法
```

> 💡 **通俗比喻**
> 
> 把类想象成一个"模具"，继承就是用一个已有的模具来制作新模具。新模具不仅有原模具的所有功能，还可以添加自己独特的功能。

### 1.2 继承的核心作用


**🔸 代码复用**
- 避免重复编写相同的代码
- 一次编写，多处使用

**🔸 功能扩展**  
- 在原有功能基础上添加新功能
- 保持原有功能不变

**🔸 统一接口**
- 多个相关类可以有统一的操作方式
- 便于管理和维护

### 1.3 继承的生活实例


```
动物分类系统：

动物(Animal)
├── 哺乳动物(Mammal)
│   ├── 狗(Dog)
│   ├── 猫(Cat)
│   └── 人(Human)
├── 鸟类(Bird)
│   ├── 鹰(Eagle)
│   └── 鸽子(Pigeon)
└── 鱼类(Fish)
    ├── 鲨鱼(Shark)
    └── 金鱼(Goldfish)

所有动物都有：呼吸、进食、移动
哺乳动物额外有：哺乳、体温恒定
狗额外有：汪汪叫、摇尾巴
```

---

## 2. 📝 单继承语法详解


### 2.1 基本语法格式


```python
# 父类（基类/超类）
class 父类名:
    # 父类的属性和方法
    pass

# 子类（派生类）
class 子类名(父类名):
    # 子类的属性和方法
    pass
```

### 2.2 第一个继承示例


让我们从最简单的例子开始：

```python
# 父类：动物
class Animal:
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        print(f"{self.name} 正在进食")
    
    def sleep(self):
        print(f"{self.name} 正在睡觉")

# 子类：狗
class Dog(Animal):  # Dog继承自Animal
    def bark(self):  # 狗特有的方法
        print(f"{self.name} 汪汪叫")

# 使用示例
my_dog = Dog("旺财")
my_dog.eat()    # 继承自父类的方法
my_dog.sleep()  # 继承自父类的方法  
my_dog.bark()   # 子类自己的方法
```

**输出结果：**
```
旺财 正在进食
旺财 正在睡觉
旺财 汪汪叫
```

> ⚠️ **新手注意**
> 
> 注意语法中的小括号 `class Dog(Animal)`，这里的括号是告诉Python："Dog这个类要继承Animal类的所有功能"

### 2.3 继承语法要点


| 组成部分 | 说明 | 示例 |
|---------|------|------|
| **父类** | 被继承的类 | `Animal` |
| **子类** | 继承其他类的类 | `Dog(Animal)` |
| **括号** | 表示继承关系 | `(Animal)` |
| **自有方法** | 子类独有的功能 | `bark()` |

---

## 3. 👨‍👦 父类与子类关系


### 3.1 关系特点


**🔸 is-a 关系**
```python
class Vehicle:  # 交通工具
    pass

class Car(Vehicle):  # 汽车
    pass

# Car is a Vehicle (汽车是一种交通工具) ✅
# Vehicle is a Car (交通工具是一种汽车) ❌
```

**🔸 继承的方向性**
```
父类 ← 子类继承父类
Animal ← Dog继承Animal

父类不知道子类的存在
子类完全了解父类的功能
```

### 3.2 类型检查


Python提供了检查继承关系的函数：

```python
class Animal:
    pass

class Dog(Animal):
    pass

my_dog = Dog()

# isinstance() - 检查对象是否是某个类的实例
print(isinstance(my_dog, Dog))     # True
print(isinstance(my_dog, Animal))  # True (因为继承关系)
print(isinstance(my_dog, str))     # False

# issubclass() - 检查类之间的继承关系
print(issubclass(Dog, Animal))     # True
print(issubclass(Animal, Dog))     # False
```

### 3.3 继承层次示例


```python
# 三层继承结构
class Animal:
    def breathe(self):
        print("呼吸")

class Mammal(Animal):  # 哺乳动物继承动物
    def feed_milk(self):
        print("哺乳")

class Dog(Mammal):     # 狗继承哺乳动物
    def bark(self):
        print("汪汪叫")

# 狗拥有所有祖先的能力
my_dog = Dog()
my_dog.breathe()    # 来自Animal
my_dog.feed_milk()  # 来自Mammal  
my_dog.bark()       # 来自Dog自己
```

---

## 4. 🎁 继承属性与方法


### 4.1 属性继承机制


**子类自动获得父类的所有属性**：

```python
class Person:
    def __init__(self, name, age):
        self.name = name        # 实例属性
        self.age = age          # 实例属性
        self.species = "智人"    # 实例属性
    
    country = "地球"            # 类属性

class Student(Person):
    def __init__(self, name, age, student_id):
        # 需要手动调用父类构造函数
        super().__init__(name, age)
        self.student_id = student_id  # 子类新增属性

# 使用示例
student = Student("小明", 18, "2024001")
print(f"姓名: {student.name}")        # 继承自父类
print(f"年龄: {student.age}")         # 继承自父类  
print(f"物种: {student.species}")     # 继承自父类
print(f"星球: {student.country}")     # 继承自父类
print(f"学号: {student.student_id}")  # 子类自有
```

### 4.2 方法继承机制


**子类自动获得父类的所有方法**：

```python
class Calculator:
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a - b

class ScientificCalculator(Calculator):
    def power(self, base, exponent):
        return base ** exponent
    
    def square_root(self, number):
        return number ** 0.5

# 科学计算器既有基础功能，又有高级功能
calc = ScientificCalculator()
print(calc.add(5, 3))         # 8 (继承的方法)
print(calc.subtract(10, 4))   # 6 (继承的方法)
print(calc.power(2, 3))       # 8 (自有的方法)
print(calc.square_root(16))   # 4.0 (自有的方法)
```

### 4.3 继承的可见性


**🔸 公有属性/方法**：子类完全继承
```python
class Parent:
    def public_method(self):
        return "公有方法"

class Child(Parent):
    pass

child = Child()
print(child.public_method())  # 可以访问
```

**🔸 私有属性/方法**：子类不能直接访问
```python
class Parent:
    def __init__(self):
        self.__private_attr = "私有属性"
    
    def __private_method(self):
        return "私有方法"

class Child(Parent):
    def test_access(self):
        # print(self.__private_attr)    # ❌ 报错
        # print(self.__private_method()) # ❌ 报错
        print("无法访问父类私有成员")

child = Child()
child.test_access()
```

---

## 5. 🚀 super()函数的使用


### 5.1 super()的作用


> 💡 **通俗理解**
> 
> `super()` 就像一个"传话筒"，它帮助子类和父类进行沟通。当子类想要使用父类的方法时，就通过`super()`来调用。

**super()的核心功能**：
- 🎯 调用父类的方法
- 🎯 访问父类的属性
- 🎯 在继承链中正确传递调用

### 5.2 super()基本用法


```python
class Animal:
    def __init__(self, name, species):
        self.name = name
        self.species = species
        print(f"动物 {name} 创建完成")
    
    def introduce(self):
        print(f"我是 {self.name}，是一只 {self.species}")

class Dog(Animal):
    def __init__(self, name, breed):
        # 调用父类的构造函数
        super().__init__(name, "犬科动物")
        self.breed = breed
        print(f"狗狗 {name} 创建完成")
    
    def introduce(self):
        # 先调用父类的介绍方法
        super().introduce()
        # 再添加子类特有的信息
        print(f"我是 {self.breed} 品种")

# 使用示例
my_dog = Dog("旺财", "金毛")
my_dog.introduce()
```

**输出结果**：
```
动物 旺财 创建完成
狗狗 旺财 创建完成
我是 旺财，是一只 犬科动物
我是 金毛 品种
```

### 5.3 super()的常见使用场景


**场景1：构造函数中使用**
```python
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        self.is_running = False

class Car(Vehicle):
    def __init__(self, brand, model, fuel_type):
        super().__init__(brand, model)  # 调用父类构造函数
        self.fuel_type = fuel_type      # 添加子类特有属性
```

**场景2：方法扩展中使用**
```python
class Employee:
    def work(self):
        print("员工正在工作")

class Developer(Employee):
    def work(self):
        super().work()              # 先执行父类的工作
        print("正在编写代码")        # 再执行自己特有的工作

dev = Developer()
dev.work()
# 输出：
# 员工正在工作
# 正在编写代码
```

### 5.4 不使用super()的后果


```python
class Parent:
    def __init__(self, value):
        self.value = value
        print("父类初始化完成")

class Child(Parent):
    def __init__(self, value, extra):
        # 错误示例：不调用父类构造函数
        # super().__init__(value)  # 忘记调用
        self.extra = extra

# 问题：子类对象缺少父类的属性
child = Child(10, "额外数据")
print(child.extra)    # 正常
# print(child.value)  # ❌ 报错：AttributeError
```

> ⚠️ **重要提醒**
> 
> 在子类的 `__init__` 方法中，几乎总是需要调用 `super().__init__()`，否则父类的初始化代码不会执行。

---

## 6. 🔍 方法解析顺序MRO


### 6.1 什么是MRO


**MRO (Method Resolution Order)** = 方法解析顺序

> 💡 **生活比喻**
> 
> 想象你在找一本书，你会按照一定的顺序去找：先在自己房间找，再去客厅找，最后去书房找。MRO就是Python找方法时的"搜索顺序"。

**MRO的作用**：
- 🎯 决定调用哪个类的方法
- 🎯 避免方法调用的混乱
- 🎯 确保继承的一致性

### 6.2 单继承的MRO


```python
class A:
    def method(self):
        print("A的方法")

class B(A):
    def method(self):
        print("B的方法")

class C(B):
    def method(self):
        print("C的方法")

# 查看MRO
print(C.__mro__)
# 输出：(<class 'C'>, <class 'B'>, <class 'A'>, <class 'object'>)

c = C()
c.method()  # 输出：C的方法

# MRO搜索顺序：C → B → A → object
```

### 6.3 MRO搜索过程演示


```python
class Animal:
    def speak(self):
        print("动物发出声音")

class Dog(Animal):
    def speak(self):
        print("狗汪汪叫")

class Puppy(Dog):
    pass  # 没有重写speak方法

puppy = Puppy()
puppy.speak()  # 输出：狗汪汪叫

# MRO搜索过程：
# 1. 在Puppy类中找speak方法 → 没找到
# 2. 在Dog类中找speak方法 → 找到了！调用
# 3. 不再继续搜索Animal类
```

### 6.4 查看类的MRO


Python提供了多种方式查看MRO：

```python
class A: pass
class B(A): pass  
class C(B): pass

# 方式1：使用 __mro__ 属性
print(C.__mro__)

# 方式2：使用 mro() 方法
print(C.mro())

# 方式3：使用 help() 函数
help(C)  # 会显示详细的继承信息
```

### 6.5 MRO的实际应用


```python
class Logger:
    def log(self, message):
        print(f"[LOG] {message}")

class TimestampLogger(Logger):
    def log(self, message):
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        super().log(f"{timestamp} - {message}")

class FileLogger(TimestampLogger):
    def log(self, message):
        super().log(message)
        # 同时写入文件（这里简化为print）
        print(f"[写入文件] {message}")

# MRO: FileLogger → TimestampLogger → Logger → object
logger = FileLogger()
logger.log("系统启动")

# 执行流程：
# 1. FileLogger.log() 调用 super().log()
# 2. TimestampLogger.log() 添加时间戳，调用 super().log()  
# 3. Logger.log() 打印日志
# 4. 返回到 TimestampLogger.log() 完成
# 5. 返回到 FileLogger.log() 写入文件
```

---

## 7. 🔄 方法重写与扩展


### 7.1 什么是方法重写


**方法重写(Override)**：子类重新定义父类中已有的方法

> 💡 **生活比喻**
> 
> 就像学习开车，你父亲教你的是基础驾驶方法，但你可能会根据自己的习惯"重写"某些操作步骤，比如调整座椅的方式。

### 7.2 完全重写示例


```python
class Animal:
    def move(self):
        print("动物在移动")

class Fish(Animal):
    def move(self):  # 完全重写父类方法
        print("鱼在水中游泳")

class Bird(Animal):
    def move(self):  # 完全重写父类方法  
        print("鸟在天空飞翔")

# 测试重写效果
animals = [Animal(), Fish(), Bird()]
for animal in animals:
    animal.move()

# 输出：
# 动物在移动
# 鱼在水中游泳  
# 鸟在天空飞翔
```

### 7.3 扩展式重写


扩展式重写：保留父类功能，同时添加新功能

```python
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    def work(self):
        print(f"{self.name} 正在工作")
    
    def get_info(self):
        return f"员工：{self.name}，薪资：{self.salary}"

class Manager(Employee):
    def __init__(self, name, salary, team_size):
        super().__init__(name, salary)  # 保留父类初始化
        self.team_size = team_size      # 添加新属性
    
    def work(self):
        super().work()                  # 保留父类工作方式
        print(f"{self.name} 还在管理 {self.team_size} 人的团队")  # 添加管理工作
    
    def get_info(self):
        base_info = super().get_info()  # 获取父类信息
        return f"{base_info}，管理团队：{self.team_size}人"  # 扩展信息

# 使用示例
manager = Manager("张三", 15000, 5)
manager.work()
print(manager.get_info())

# 输出：
# 张三 正在工作
# 张三 还在管理 5 人的团队
# 员工：张三，薪资：15000，管理团队：5人
```

### 7.4 方法重写的时机选择


| 重写方式 | 使用场景 | 示例 |
|---------|---------|------|
| **完全重写** | 子类需要完全不同的行为 | 鱼的移动方式 vs 鸟的移动方式 |
| **扩展重写** | 子类在父类基础上增加功能 | 管理员工在普通工作基础上增加管理工作 |
| **不重写** | 父类方法完全适用于子类 | 所有员工都需要的基础信息管理 |

### 7.5 重写注意事项


**🔸 保持方法签名一致**
```python
class Parent:
    def method(self, param1, param2):
        pass

class Child(Parent):
    # ✅ 正确：保持相同的参数
    def method(self, param1, param2):
        pass
    
    # ❌ 错误：改变了参数数量
    # def method(self, param1, param2, param3):
    #     pass
```

**🔸 考虑调用父类方法**
```python
class Parent:
    def important_method(self):
        # 一些重要的初始化或清理工作
        print("父类的重要处理")

class Child(Parent):
    def important_method(self):
        # 建议先调用父类方法，确保重要工作被执行
        super().important_method()
        # 然后添加子类的处理
        print("子类的额外处理")
```

---

## 8. 🏗️ 构造函数继承


### 8.1 构造函数继承的基本规则


> ⚠️ **重要概念**
> 
> Python中的构造函数 `__init__` **不会自动继承**！子类必须显式调用父类的构造函数。

### 8.2 没有自定义构造函数的情况


```python
class Animal:
    def __init__(self, name):
        self.name = name
        print(f"动物 {name} 被创建")

class Dog(Animal):
    pass  # 没有自定义 __init__

# Python会自动使用父类的构造函数
dog = Dog("旺财")  # 正常工作
print(dog.name)    # 旺财
```

### 8.3 子类有自定义构造函数的情况


```python
class Animal:
    def __init__(self, name, species):
        self.name = name
        self.species = species
        print(f"动物初始化：{name}")

class Dog(Animal):
    def __init__(self, name, breed, age):
        # 必须显式调用父类构造函数
        super().__init__(name, "犬科")
        # 添加子类特有的属性
        self.breed = breed
        self.age = age
        print(f"狗狗初始化：{name}")

dog = Dog("旺财", "金毛", 3)
print(f"姓名：{dog.name}")
print(f"品种：{dog.breed}")
print(f"年龄：{dog.age}")
```

### 8.4 多层继承的构造函数


```python
class Animal:
    def __init__(self, name):
        self.name = name
        print("1. 动物类初始化")

class Mammal(Animal):
    def __init__(self, name, body_temp):
        super().__init__(name)
        self.body_temp = body_temp
        print("2. 哺乳动物类初始化")

class Dog(Mammal):
    def __init__(self, name, breed):
        super().__init__(name, 37.5)  # 狗的正常体温
        self.breed = breed
        print("3. 狗类初始化")

# 创建对象时的初始化顺序
dog = Dog("旺财", "金毛")

# 输出顺序：
# 1. 动物类初始化
# 2. 哺乳动物类初始化  
# 3. 狗类初始化
```

### 8.5 构造函数继承的最佳实践


**🎯 实践1：总是调用父类构造函数**
```python
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        self.mileage = 0

class Car(Vehicle):
    def __init__(self, brand, model, fuel_type):
        super().__init__(brand, model)  # ✅ 总是调用
        self.fuel_type = fuel_type
```

**🎯 实践2：合理安排初始化顺序**
```python
class BankAccount:
    def __init__(self, account_number, balance):
        self.account_number = account_number
        self.balance = balance
        self.is_active = True

class SavingsAccount(BankAccount):
    def __init__(self, account_number, balance, interest_rate):
        # 1. 先调用父类构造函数，确保基础属性设置
        super().__init__(account_number, balance)
        # 2. 再设置子类特有属性
        self.interest_rate = interest_rate
        # 3. 最后进行子类特有的初始化操作
        self._calculate_monthly_interest()
    
    def _calculate_monthly_interest(self):
        self.monthly_interest = self.balance * self.interest_rate / 12
```

### 8.6 常见的构造函数错误


**❌ 错误1：忘记调用父类构造函数**
```python
class Parent:
    def __init__(self, important_value):
        self.important_value = important_value

class Child(Parent):
    def __init__(self, child_value):
        # 忘记调用 super().__init__()
        self.child_value = child_value

child = Child("test")
# print(child.important_value)  # ❌ 报错：没有这个属性
```

**❌ 错误2：调用顺序错误**
```python
class Parent:
    def __init__(self, value):
        self.value = value

class Child(Parent):
    def __init__(self, value, extra):
        self.extra = extra
        super().__init__(value)  # ❌ 应该先调用父类构造函数
        # 如果父类构造函数中需要使用self.extra，就会出错
```

---

## 9. 📐 继承设计原则


### 9.1 里氏替换原则


**核心思想**：子类对象应该能够替换父类对象，而不影响程序的正确性

> 💡 **通俗理解**
> 
> 如果你写了一个函数接受"动物"参数，那么无论传入"狗"、"猫"还是"鸟"，函数都应该能正常工作。

```python
# 符合里氏替换原则的设计
class Shape:
    def area(self):
        raise NotImplementedError("子类必须实现area方法")

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2

# 可以替换使用
def print_area(shape):  # 接受任何Shape类型
    print(f"面积：{shape.area()}")

shapes = [Rectangle(5, 3), Circle(4)]
for shape in shapes:
    print_area(shape)  # 都能正常工作
```

### 9.2 单一职责原则


**核心思想**：每个类应该只有一个改变的理由

```python
# ❌ 违反单一职责原则
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    def calculate_pay(self):
        # 薪资计算逻辑
        return self.salary
    
    def save_to_database(self):
        # 数据库操作逻辑
        print(f"保存员工 {self.name} 到数据库")
    
    def generate_report(self):
        # 报表生成逻辑
        print(f"生成员工 {self.name} 的报表")

# ✅ 符合单一职责原则
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    def calculate_pay(self):
        return self.salary

class EmployeeDatabase:
    def save_employee(self, employee):
        print(f"保存员工 {employee.name} 到数据库")

class EmployeeReporter:
    def generate_report(self, employee):
        print(f"生成员工 {employee.name} 的报表")
```

### 9.3 开闭原则


**核心思想**：对扩展开放，对修改封闭

```python
# 基础的图形绘制系统
class Shape:
    def draw(self):
        raise NotImplementedError

class Circle(Shape):
    def draw(self):
        print("绘制圆形")

class Rectangle(Shape):
    def draw(self):
        print("绘制矩形")

class DrawingApp:
    def __init__(self):
        self.shapes = []
    
    def add_shape(self, shape):
        self.shapes.append(shape)
    
    def draw_all(self):
        for shape in self.shapes:
            shape.draw()

# 扩展：添加新的图形类型（不需要修改现有代码）
class Triangle(Shape):
    def draw(self):
        print("绘制三角形")

# 使用
app = DrawingApp()
app.add_shape(Circle())
app.add_shape(Rectangle())
app.add_shape(Triangle())  # 新增的图形
app.draw_all()
```

### 9.4 继承 vs 组合


**何时使用继承**：
- ✅ 存在明确的"is-a"关系
- ✅ 子类是父类的特殊化
- ✅ 需要利用多态性

**何时使用组合**：
- ✅ 存在"has-a"关系
- ✅ 需要灵活的功能组合
- ✅ 避免深层继承链

```python
# 继承示例：狗是动物
class Animal:
    def breathe(self):
        print("呼吸")

class Dog(Animal):  # Dog is an Animal
    def bark(self):
        print("汪汪叫")

# 组合示例：汽车有引擎
class Engine:
    def start(self):
        print("引擎启动")

class Car:  # Car has an Engine
    def __init__(self):
        self.engine = Engine()  # 组合关系
    
    def start(self):
        self.engine.start()
        print("汽车启动")
```

### 9.5 继承深度控制


**🎯 建议**：继承层次不要超过3-4层

```python
# ✅ 合理的继承深度
class Animal:           # 第1层
    pass

class Mammal(Animal):   # 第2层
    pass

class Dog(Mammal):      # 第3层
    pass

# ❌ 过深的继承（不推荐）
class Animal:
    pass
class Vertebrate(Animal):
    pass
class Mammal(Vertebrate):
    pass
class Carnivore(Mammal):
    pass
class Canine(Carnivore):
    pass
class Dog(Canine):      # 第6层，太深了！
    pass
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 继承概念：子类自动获得父类的属性和方法
🔸 语法格式：class 子类名(父类名)
🔸 super()函数：调用父类的方法
🔸 方法重写：子类重新定义父类方法
🔸 构造函数：子类必须显式调用父类构造函数
🔸 MRO：方法解析顺序，决定调用哪个类的方法
```

### 10.2 关键理解要点


**🔹 继承的本质**
```
继承 = 代码复用 + 功能扩展
• 避免重复编写相同代码
• 在原有基础上添加新功能
• 保持代码的一致性和可维护性
```

**🔹 super()的重要性**
```
super() = 子类与父类的沟通桥梁
• 确保父类的初始化代码执行
• 正确调用父类的方法
• 支持多重继承的正确解析
```

**🔹 方法重写的策略**
```
重写方式选择：
• 完全重写：需要完全不同的行为
• 扩展重写：在父类基础上增加功能  
• 不重写：父类方法完全适用
```

### 10.3 实际应用指导


**✅ 设计继承时要考虑**
- 是否存在真正的"is-a"关系
- 子类是否是父类的特殊化
- 是否需要多态性支持
- 继承层次是否合理（不超过3-4层）

**✅ 编写代码时要注意**
- 子类构造函数中调用`super().__init__()`
- 重写方法时考虑是否需要调用父类方法
- 保持方法签名的一致性
- 遵循里氏替换原则

**✅ 常见应用场景**
- **GUI开发**：各种控件继承基础控件类
- **游戏开发**：各种角色继承基础角色类
- **Web开发**：各种视图继承基础视图类
- **数据处理**：各种处理器继承基础处理器类

### 10.4 记忆要点


> 🧠 **继承记忆口诀**
> 
> *子承父业传家宝，super调用不能少*  
> *重写方法要慎重，MRO顺序要记清*  
> *is-a关系用继承，has-a关系用组合*

**核心记忆**：
- 继承是面向对象编程的核心特性之一
- 合理使用继承可以大大提高代码的复用性和可维护性
- super()是继承中最重要的工具，必须熟练掌握
- 设计继承关系时要遵循面向对象设计原则