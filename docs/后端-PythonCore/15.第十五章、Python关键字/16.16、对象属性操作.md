---
title: 16、对象属性操作
---
## 📚 目录

1. [什么是对象属性操作](#1-什么是对象属性操作)
2. [getattr - 获取属性的安全方式](#2-getattr-获取属性的安全方式)
3. [setattr - 动态设置属性](#3-setattr-动态设置属性)
4. [hasattr - 检查属性是否存在](#4-hasattr-检查属性是否存在)
5. [delattr - 删除属性](#5-delattr-删除属性)
6. [dir - 查看对象所有属性](#6-dir-查看对象所有属性)
7. [vars - 获取对象属性字典](#7-vars-获取对象属性字典)
8. [callable - 检查对象是否可调用](#8-callable-检查对象是否可调用)
9. [实际应用场景与最佳实践](#9-实际应用场景与最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 什么是对象属性操作


### 1.1 概念理解

**什么是属性？**
简单来说，属性就是对象身上的"特征"或"能力"。就像人有姓名、年龄、身高等特征一样，Python对象也有各种属性。

```
生活中的例子：           Python中的例子：
人：                     字符串对象：
├─ 姓名（属性）          ├─ upper（方法属性）
├─ 年龄（属性）          ├─ lower（方法属性）
└─ 说话（方法）          └─ split（方法属性）
```

**为什么需要属性操作？**
有时候我们需要：
- 📝 **动态获取**：不知道属性名，但需要获取属性值
- 🔧 **安全访问**：属性可能不存在，需要防止程序崩溃
- ⚡ **批量处理**：同时处理多个属性
- 🎯 **运行时修改**：程序运行过程中添加或修改属性

### 1.2 基础语法对比


| 操作类型 | **直接访问** | **函数方式** | **适用场景** |
|---------|------------|-------------|-------------|
| 🔍 **获取属性** | `obj.name` | `getattr(obj, 'name')` | `属性名是变量时` |
| 🔧 **设置属性** | `obj.name = value` | `setattr(obj, 'name', value)` | `动态设置属性时` |
| ❓ **检查属性** | `'name' in dir(obj)` | `hasattr(obj, 'name')` | `安全检查时` |
| 🗑️ **删除属性** | `del obj.name` | `delattr(obj, 'name')` | `动态删除时` |

---

## 2. 🔍 getattr - 获取属性的安全方式


### 2.1 基本用法

**getattr的作用**：安全地获取对象的属性，即使属性不存在也不会报错。

```python
# 基本语法
getattr(对象, '属性名', 默认值)
```

> 💡 **通俗理解**  
> `getattr`就像一个"礼貌的服务员"，你要什么东西，如果有就给你，没有就给你个替代品，绝不会对你发脾气（不会报错）。

### 2.2 实用示例


**基础使用**：
```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

student = Student("小明", 18)

# 普通方式获取属性
print(student.name)  # 输出: 小明

# 使用getattr获取属性
name = getattr(student, 'name')
print(name)  # 输出: 小明

# 获取不存在的属性，提供默认值
score = getattr(student, 'score', 0)
print(score)  # 输出: 0（因为score属性不存在）
```

**动态属性名**：
```python
class Product:
    def __init__(self):
        self.price = 100
        self.discount = 0.8
        self.stock = 50

product = Product()

# 根据用户输入动态获取属性
attr_name = input("请输入要查询的属性（price/discount/stock）：")
value = getattr(product, attr_name, "属性不存在")
print(f"{attr_name}: {value}")
```

### 2.3 高级应用


**批量获取属性**：
```python
class Car:
    def __init__(self):
        self.brand = "Toyota"
        self.model = "Camry"
        self.year = 2023
        self.color = "白色"

car = Car()

# 要检查的属性列表
attributes = ['brand', 'model', 'year', 'color', 'price']

print("车辆信息：")
for attr in attributes:
    value = getattr(car, attr, "未设置")
    print(f"  {attr}: {value}")
```

> ⚠️ **注意事项**  
> - 第三个参数（默认值）是可选的
> - 如果不提供默认值且属性不存在，会抛出`AttributeError`
> - 属性名必须是字符串类型

---

## 3. 🔧 setattr - 动态设置属性


### 3.1 基本概念

**setattr的作用**：动态地给对象添加或修改属性，特别适合属性名不确定的情况。

```python
# 基本语法
setattr(对象, '属性名', 属性值)
```

> 💡 **通俗理解**  
> `setattr`像一个"万能贴标签机"，你说贴什么标签、贴什么内容，它都能帮你贴上去。

### 3.2 实用示例


**基础使用**：
```python
class Person:
    def __init__(self, name):
        self.name = name

person = Person("张三")

# 普通方式设置属性
person.age = 25

# 使用setattr设置属性
setattr(person, 'city', '北京')
setattr(person, 'job', '程序员')

print(f"姓名: {person.name}")
print(f"年龄: {person.age}")
print(f"城市: {person.city}")
print(f"职业: {person.job}")
```

**动态配置对象**：
```python
class Config:
    pass

config = Config()

# 从字典动态设置配置项
settings = {
    'host': 'localhost',
    'port': 8080,
    'debug': True,
    'timeout': 30
}

for key, value in settings.items():
    setattr(config, key, value)

print(f"服务器配置：{config.host}:{config.port}")
print(f"调试模式：{config.debug}")
```

### 3.3 实际应用场景


**数据库模型动态赋值**：
```python
class User:
    def __init__(self):
        pass
    
    def from_dict(self, data):
        """从字典数据创建用户对象"""
        for key, value in data.items():
            setattr(self, key, value)
        return self

# 模拟从数据库获取的数据
user_data = {
    'id': 1,
    'username': 'admin',
    'email': 'admin@example.com',
    'is_active': True
}

user = User().from_dict(user_data)
print(f"用户名: {user.username}")
print(f"邮箱: {user.email}")
```

---

## 4. ❓ hasattr - 检查属性是否存在


### 4.1 基本概念

**hasattr的作用**：检查对象是否具有指定的属性，返回`True`或`False`。

```python
# 基本语法
hasattr(对象, '属性名')  # 返回 True 或 False
```

> 💡 **通俗理解**  
> `hasattr`像一个"侦探"，帮你查看某个对象是否有你要找的"特征"，给你明确的"有"或"没有"的答案。

### 4.2 实用示例


**基础使用**：
```python
class Animal:
    def __init__(self, name):
        self.name = name
        self.age = 1
    
    def speak(self):
        return "动物叫声"

animal = Animal("小狗")

# 检查各种属性是否存在
print(hasattr(animal, 'name'))     # True
print(hasattr(animal, 'age'))      # True  
print(hasattr(animal, 'speak'))    # True（方法也是属性）
print(hasattr(animal, 'color'))    # False
```

**安全的属性访问**：
```python
class Student:
    def __init__(self, name):
        self.name = name
    
    def get_grade(self):
        return getattr(self, 'grade', '未评分')

students = [
    Student("小明"),
    Student("小红")
]

# 给第一个学生设置成绩
students[0].grade = "A"

# 安全地显示所有学生信息
for student in students:
    print(f"学生: {student.name}")
    if hasattr(student, 'grade'):
        print(f"  成绩: {student.grade}")
    else:
        print("  成绩: 暂未评分")
```

### 4.3 与其他检查方式的对比


```
检查方式对比：

方式1 - hasattr（推荐）：
✅ 简洁明了
✅ 不会抛出异常
✅ 包括方法和属性

方式2 - try/except：
🔸 代码较长
🔸 需要处理异常
✅ 可以获取具体错误信息

方式3 - in dir()：
🔸 性能较低（需要获取所有属性）
✅ 可以看到所有属性列表
```

---

## 5. 🗑️ delattr - 删除属性


### 5.1 基本概念

**delattr的作用**：动态删除对象的属性，特别适合属性名不确定的情况。

```python
# 基本语法
delattr(对象, '属性名')
```

> 💡 **通俗理解**  
> `delattr`像一个"橡皮擦"，可以把对象身上的某个"标签"擦掉，让对象"忘记"这个特征。

### 5.2 实用示例


**基础使用**：
```python
class TempData:
    def __init__(self):
        self.cache = "临时数据"
        self.timestamp = "2023-01-01"
        self.user_session = "abc123"

data = TempData()
print("删除前的属性：", dir(data))

# 清理临时属性
if hasattr(data, 'cache'):
    delattr(data, 'cache')

if hasattr(data, 'user_session'):
    delattr(data, 'user_session')

print("删除后还有：", hasattr(data, 'cache'))      # False
print("时间戳保留：", hasattr(data, 'timestamp'))   # True
```

**批量清理属性**：
```python
class UserProfile:
    def __init__(self):
        self.name = "用户"
        self.temp_token = "临时令牌"
        self.cache_data = "缓存"
        self.debug_info = "调试信息"
        self.permanent_id = "永久ID"

profile = UserProfile()

# 需要清理的临时属性
temp_attrs = ['temp_token', 'cache_data', 'debug_info']

print("清理前的属性数量：", len([attr for attr in dir(profile) if not attr.startswith('_')]))

for attr in temp_attrs:
    if hasattr(profile, attr):
        delattr(profile, attr)
        print(f"已删除: {attr}")

print("清理后保留的属性：")
for attr in dir(profile):
    if not attr.startswith('_'):  # 跳过内置属性
        print(f"  {attr}: {getattr(profile, attr)}")
```

> ⚠️ **注意事项**  
> - 删除不存在的属性会抛出`AttributeError`
> - 建议先用`hasattr`检查再删除
> - 无法删除类的方法和内置属性

---

## 6. 📋 dir - 查看对象所有属性


### 6.1 基本概念

**dir的作用**：获取对象所有属性和方法的名称列表，是探索对象能力的重要工具。

```python
# 基本语法
dir(对象)  # 返回属性名称的列表
```

> 💡 **通俗理解**  
> `dir`像一个"物品清单员"，把对象所有的"特征"和"能力"都列出来给你看，让你一目了然。

### 6.2 实用示例


**基础使用**：
```python
class Calculator:
    def __init__(self):
        self.result = 0
        self.history = []
    
    def add(self, x):
        self.result += x
        return self.result
    
    def clear(self):
        self.result = 0

calc = Calculator()

print("计算器的所有属性和方法：")
all_attrs = dir(calc)

# 分类显示
user_attrs = [attr for attr in all_attrs if not attr.startswith('_')]
builtin_attrs = [attr for attr in all_attrs if attr.startswith('_')]

print(f"自定义属性和方法 ({len(user_attrs)}个)：")
for attr in user_attrs:
    print(f"  - {attr}")

print(f"\n内置属性 ({len(builtin_attrs)}个)：")
print(f"  {builtin_attrs[:3]}... (还有{len(builtin_attrs)-3}个)")
```

**探索未知对象**：
```python
# 探索字符串对象有什么能力
text = "Hello World"

print("字符串对象的能力探索：")
string_methods = [method for method in dir(text) if not method.startswith('_')]

# 按功能分类（简化版）
transform_methods = [m for m in string_methods if any(word in m for word in ['upper', 'lower', 'title', 'strip'])]
search_methods = [m for m in string_methods if any(word in m for word in ['find', 'index', 'count'])]
split_methods = [m for m in string_methods if any(word in m for word in ['split', 'join', 'replace'])]

print(f"变换类方法: {transform_methods}")
print(f"搜索类方法: {search_methods}")
print(f"分割类方法: {split_methods}")
```

### 6.3 高级用法


**动态属性过滤**：
```python
class DataProcessor:
    def __init__(self):
        self.input_data = []
        self.output_data = []
        self.config_timeout = 30
        self.config_retry = 3
        self.temp_cache = {}
    
    def process(self): pass
    def validate(self): pass
    def cleanup(self): pass

processor = DataProcessor()

# 按前缀分类属性
def classify_attributes(obj):
    all_attrs = dir(obj)
    classification = {
        'config': [],
        'temp': [],
        'data': [],
        'methods': [],
        'other': []
    }
    
    for attr in all_attrs:
        if attr.startswith('_'):
            continue
            
        if attr.startswith('config'):
            classification['config'].append(attr)
        elif attr.startswith('temp'):
            classification['temp'].append(attr)
        elif attr.endswith('data'):
            classification['data'].append(attr)
        elif callable(getattr(obj, attr)):
            classification['methods'].append(attr)
        else:
            classification['other'].append(attr)
    
    return classification

attrs = classify_attributes(processor)
for category, items in attrs.items():
    if items:
        print(f"{category.upper()}: {items}")
```

---

## 7. 📖 vars - 获取对象属性字典


### 7.1 基本概念

**vars的作用**：返回对象的属性字典，只包含实例属性，不包括方法。

```python
# 基本语法
vars(对象)  # 返回 {'属性名': 属性值} 的字典
```

> 💡 **通俗理解**  
> `vars`像一个"档案管理员"，把对象的所有"个人信息"整理成一个档案袋（字典），方便你查看和管理。

### 7.2 实用示例


**基础使用**：
```python
class Employee:
    def __init__(self, name, position, salary):
        self.name = name
        self.position = position
        self.salary = salary
        self.department = "技术部"
    
    def work(self):
        return f"{self.name}正在工作"

emp = Employee("李四", "工程师", 8000)

# 获取员工的所有属性信息
employee_info = vars(emp)
print("员工信息：")
for key, value in employee_info.items():
    print(f"  {key}: {value}")

# 注意：vars()不包含方法
print(f"\nvars()结果: {employee_info}")
print(f"是否包含work方法: {'work' in employee_info}")  # False
```

**对比dir()和vars()**：
```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price
        self.stock = 100
    
    def sell(self): pass

product = Product("笔记本", 5000)

print("dir()的结果（包含所有）：")
dir_result = [attr for attr in dir(product) if not attr.startswith('_')]
print(f"  {dir_result}")

print("\nvars()的结果（仅实例属性）：")
vars_result = vars(product)
print(f"  {vars_result}")

print(f"\n差异分析：")
print(f"  dir包含方法: {'sell' in dir_result}")
print(f"  vars包含方法: {'sell' in vars_result}")
```

### 7.3 实际应用


**对象序列化准备**：
```python
class UserAccount:
    def __init__(self, username, email):
        self.username = username
        self.email = email
        self.created_time = "2023-01-01"
        self.last_login = None
        self.is_active = True
    
    def login(self): pass
    def logout(self): pass

user = UserAccount("admin", "admin@example.com")

# 准备保存到数据库的数据
user_data = vars(user)
print("准备保存的用户数据：")
for field, value in user_data.items():
    print(f"  {field}: {value}")

# 可以直接用于JSON序列化
import json
json_data = json.dumps(user_data, ensure_ascii=False, indent=2)
print(f"\nJSON格式：\n{json_data}")
```

---

## 8. 🔧 callable - 检查对象是否可调用


### 8.1 基本概念

**callable的作用**：检查对象是否可以像函数一样被调用（是否有`()`操作）。

```python
# 基本语法
callable(对象)  # 返回 True 或 False
```

> 💡 **通俗理解**  
> `callable`像一个"能力检测器"，检查某个东西是否"可以执行"，就像检查一个按钮是否可以按一样。

### 8.2 什么是可调用对象


```
可调用对象类型：

✅ 函数 (function)
✅ 方法 (method)  
✅ 类 (class)
✅ 实现了__call__的对象
✅ 内置函数 (len, print等)

❌ 普通变量
❌ 字符串、数字
❌ 列表、字典等
```

### 8.3 实用示例


**基础检测**：
```python
def hello():
    return "Hello!"

class Calculator:
    def add(self, x, y):
        return x + y

calc = Calculator()
name = "张三"
number = 42

print("可调用性检测：")
print(f"函数hello: {callable(hello)}")           # True
print(f"方法calc.add: {callable(calc.add)}")     # True  
print(f"类Calculator: {callable(Calculator)}")   # True
print(f"字符串name: {callable(name)}")           # False
print(f"数字number: {callable(number)}")         # False
print(f"内置函数len: {callable(len)}")           # True
```

**动态函数调用**：
```python
class MathOperations:
    def add(self, x, y):
        return x + y
    
    def multiply(self, x, y):
        return x * y
    
    def divide(self, x, y):
        return x / y if y != 0 else "除数不能为0"

math_ops = MathOperations()

# 用户选择操作
operations = ['add', 'multiply', 'divide', 'invalid_op']

for op_name in operations:
    if hasattr(math_ops, op_name):
        operation = getattr(math_ops, op_name)
        if callable(operation):
            result = operation(10, 5)
            print(f"{op_name}(10, 5) = {result}")
        else:
            print(f"{op_name} 不是可调用的方法")
    else:
        print(f"{op_name} 方法不存在")
```

### 8.4 高级应用


**实现可调用的类**：
```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor
    
    def __call__(self, value):
        """让对象可以像函数一样调用"""
        return value * self.factor

# 创建一个"乘以3"的函数对象
multiply_by_3 = Multiplier(3)

print(f"multiply_by_3是否可调用: {callable(multiply_by_3)}")  # True
print(f"multiply_by_3(10) = {multiply_by_3(10)}")           # 30

# 检验它确实可以像函数一样使用
numbers = [1, 2, 3, 4, 5]
result = list(map(multiply_by_3, numbers))
print(f"批量处理结果: {result}")  # [3, 6, 9, 12, 15]
```

---

## 9. 🚀 实际应用场景与最佳实践


### 9.1 配置管理系统


```python
class AppConfig:
    def __init__(self):
        # 默认配置
        self.debug = False
        self.host = 'localhost'
        self.port = 8080
    
    def load_from_dict(self, config_dict):
        """从字典加载配置"""
        for key, value in config_dict.items():
            if hasattr(self, key):
                setattr(self, key, value)
                print(f"✅ 更新配置: {key} = {value}")
            else:
                print(f"⚠️ 未知配置项: {key}")
    
    def get_all_configs(self):
        """获取所有配置"""
        return {k: v for k, v in vars(self).items() if not k.startswith('_')}
    
    def reset_to_defaults(self):
        """重置为默认配置"""
        defaults = {'debug': False, 'host': 'localhost', 'port': 8080}
        for key, value in defaults.items():
            setattr(self, key, value)

# 使用示例
config = AppConfig()

# 从文件或环境变量加载配置
user_config = {
    'debug': True,
    'port': 9000,
    'unknown_setting': 'test'  # 这个会被忽略
}

config.load_from_dict(user_config)
print(f"\n当前配置: {config.get_all_configs()}")
```

### 9.2 数据验证器


```python
class DataValidator:
    def __init__(self, data):
        self.data = data
        self.errors = []
    
    def validate_required_fields(self, required_fields):
        """验证必需字段"""
        for field in required_fields:
            if not hasattr(self.data, field):
                self.errors.append(f"缺少必需字段: {field}")
            elif getattr(self.data, field) is None:
                self.errors.append(f"字段不能为空: {field}")
    
    def validate_field_types(self, type_rules):
        """验证字段类型"""
        for field, expected_type in type_rules.items():
            if hasattr(self.data, field):
                value = getattr(self.data, field)
                if not isinstance(value, expected_type):
                    self.errors.append(f"字段类型错误: {field} 应该是 {expected_type.__name__}")
    
    def is_valid(self):
        return len(self.errors) == 0

# 使用示例
class UserData:
    def __init__(self):
        self.name = "张三"
        self.age = "25"  # 故意设置错误类型
        # 缺少email字段

user_data = UserData()
validator = DataValidator(user_data)

# 设置验证规则
validator.validate_required_fields(['name', 'email', 'age'])
validator.validate_field_types({'name': str, 'age': int})

if validator.is_valid():
    print("✅ 数据验证通过")
else:
    print("❌ 数据验证失败：")
    for error in validator.errors:
        print(f"  - {error}")
```

### 9.3 动态API调用器


```python
class APIClient:
    def __init__(self):
        self.base_url = "https://api.example.com"
    
    def get_users(self):
        return "获取用户列表"
    
    def create_user(self, data):
        return f"创建用户: {data}"
    
    def update_user(self, user_id, data):
        return f"更新用户 {user_id}: {data}"
    
    def call_api(self, method_name, *args, **kwargs):
        """动态调用API方法"""
        if hasattr(self, method_name):
            method = getattr(self, method_name)
            if callable(method):
                try:
                    return method(*args, **kwargs)
                except Exception as e:
                    return f"调用失败: {e}"
            else:
                return f"错误: {method_name} 不是可调用的方法"
        else:
            return f"错误: API方法 {method_name} 不存在"

# 使用示例
api = APIClient()

# 动态调用不同的API方法
requests = [
    ('get_users',),
    ('create_user', {'name': '新用户'}),
    ('update_user', 123, {'name': '更新后的用户'}),
    ('delete_user',),  # 不存在的方法
]

for request in requests:
    method_name = request[0]
    args = request[1:] if len(request) > 1 else ()
    result = api.call_api(method_name, *args)
    print(f"{method_name}: {result}")
```

### 9.4 最佳实践总结


> 📋 **使用建议**

**1. 安全第一**
```python
# ✅ 推荐：先检查再操作
if hasattr(obj, 'attr_name'):
    value = getattr(obj, 'attr_name')

# ❌ 避免：直接访问可能不存在的属性
# value = obj.attr_name  # 可能报错
```

**2. 提供默认值**
```python
# ✅ 推荐：总是提供合理的默认值
value = getattr(obj, 'optional_attr', '默认值')

# ❌ 避免：不提供默认值，可能导致异常
# value = getattr(obj, 'optional_attr')
```

**3. 合理使用工具**
```python
# 不同场景选择不同工具：
# hasattr() - 快速检查属性是否存在
# getattr() - 安全获取属性值
# dir() - 探索对象能力
# vars() - 获取实例属性字典
# callable() - 检查是否可调用
```

---

## 10. 📋 核心要点总结


### 10.1 七大函数对比表


| 函数 | **作用** | **返回值** | **主要用途** | **注意事项** |
|------|---------|-----------|-------------|-------------|
| 🔍 **getattr** | `获取属性值` | `属性值或默认值` | `安全获取属性` | `建议提供默认值` |
| 🔧 **setattr** | `设置属性值` | `None` | `动态设置属性` | `属性名必须是字符串` |
| ❓ **hasattr** | `检查属性存在` | `True/False` | `属性存在性检查` | `包括方法和属性` |
| 🗑️ **delattr** | `删除属性` | `None` | `动态删除属性` | `先检查存在性` |
| 📋 **dir** | `列出所有属性` | `属性名列表` | `探索对象能力` | `包含内置属性` |
| 📖 **vars** | `获取属性字典` | `属性字典` | `序列化准备` | `仅实例属性` |
| 🔧 **callable** | `检查可调用性` | `True/False` | `动态函数调用` | `函数、方法、类都可调用` |

### 10.2 应用场景速查


```
🎯 常见应用场景：

配置管理 → getattr + setattr + hasattr
数据验证 → hasattr + getattr + callable  
对象探索 → dir + vars + callable
动态调用 → hasattr + getattr + callable
属性清理 → hasattr + delattr
序列化   → vars + getattr
```

### 10.3 记忆口诀


> 💡 **记忆口诀**  
> **get取值set赋值，has检查del删除**  
> **dir列出vars字典，callable能否调用**  
> **动态操作靠这些，属性管理不用愁**

### 10.4 核心要点


**🔸 安全性原则**
- 操作前先检查（`hasattr`）
- 提供默认值（`getattr`的第三个参数）
- 异常处理（try-except）

**🔸 效率考虑**
- `hasattr`比`try-except`更快
- `vars`比`dir`更精确（仅实例属性）
- `getattr`比直接访问更安全

**🔸 实际应用**
- 配置管理：动态设置和获取配置项
- 数据验证：检查对象的完整性
- API设计：实现灵活的接口调用
- 序列化：准备对象数据进行保存

**🔸 常见陷阱**
- 忘记检查属性是否存在
- 混淆`dir()`和`vars()`的区别  
- 不理解`callable()`的含义
- 删除属性时不检查存在性

这七个函数是Python中处理对象属性的核心工具，掌握它们可以让你的代码更加灵活和安全！