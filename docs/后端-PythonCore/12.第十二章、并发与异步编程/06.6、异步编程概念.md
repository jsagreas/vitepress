---
title: 6、异步编程概念
---
## 📚 目录

1. [异步编程基本概念](#1-异步编程基本概念)
2. [事件循环原理](#2-事件循环原理)
3. [协程与异步函数](#3-协程与异步函数)
4. [async/await语法详解](#4-async-await语法详解)
5. [异步上下文管理器](#5-异步上下文管理器)
6. [异步迭代器](#6-异步迭代器)
7. [异步生成器](#7-异步生成器)
8. [异步编程的优势](#8-异步编程的优势)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔄 异步编程基本概念


### 1.1 什么是异步编程


**🎯 生活化理解**
```
想象你在厨房做饭：

同步方式（排队做事）：
煮饭 → 等30分钟 → 炒菜 → 等10分钟 → 做汤 → 等15分钟
总时间：55分钟

异步方式（同时进行）：
开始煮饭 → 立即开始炒菜 → 立即开始做汤 → 等待最长的完成
总时间：30分钟（最长的任务时间）
```

**💡 编程中的对比**
```
同步编程：一行代码执行完，才执行下一行
异步编程：不等待耗时操作完成，先去做其他事情
```

### 1.2 为什么需要异步编程


**🚫 同步编程的问题**
```
网络请求示例：
请求网站A → 等待2秒 → 请求网站B → 等待3秒 → 请求网站C → 等待1秒
总耗时：6秒

问题：大部分时间在"等待"，CPU闲着没事干
```

**✅ 异步编程的解决方案**
```
同时发起三个请求：
发起请求A、B、C → 等待最慢的完成
总耗时：3秒（最长的请求时间）

优势：充分利用等待时间，提高程序效率
```

### 1.3 异步编程的核心思想


**🔑 核心理念**
```
不要傻等，去做其他有意义的事情

传统思维：做完A再做B
异步思维：启动A的同时启动B，谁先完成就处理谁
```

**📊 适用场景对比**

| 场景类型 | **是否适合异步** | **原因说明** |
|---------|----------------|-------------|
| **网络请求** | ✅ 非常适合 | 等待时间长，可以同时处理多个请求 |
| **文件读写** | ✅ 适合 | IO操作有等待时间 |
| **数学计算** | ❌ 不适合 | CPU密集型，没有等待时间 |
| **数据库查询** | ✅ 适合 | 查询有延迟，可以并发处理 |

---

## 2. ⚙️ 事件循环原理


### 2.1 什么是事件循环


**🎠 生活化类比**
```
事件循环就像游乐园的旋转木马：

🎪 旋转木马（事件循环）不停地转
🎠 每个木马（任务）按顺序上马
⏰ 转一圈检查一次哪些任务完成了
✅ 完成的任务下马，新任务上马

关键特点：
- 永远在转（循环运行）
- 按顺序处理（不会乱）
- 及时响应（一圈就检查一次）
```

**🔄 事件循环工作流程**
```
事件循环的一天：

1. 早上醒来 → 检查待办事项
2. 执行能做的事 → 跳过需要等待的事
3. 等待事件完成 → 比如等外卖送达
4. 处理完成的事 → 外卖到了就去取
5. 重复步骤1 → 直到所有事情做完

编程对应：
待办事项 = 任务队列
能做的事 = 立即可执行的任务
等待事件 = IO操作（网络、文件等）
处理完成 = 回调函数执行
```

### 2.2 事件循环的内部机制


**🏗️ 核心组件**
```
事件循环 = 任务调度器 + 事件监听器

任务调度器：
┌─────────────────┐
│   待执行队列     │ ← 排队等候的任务
├─────────────────┤
│   正在执行       │ ← 当前运行的任务
├─────────────────┤
│   已完成队列     │ ← 处理结果的任务
└─────────────────┘

事件监听器：
┌─────────────────┐
│   网络事件       │ ← 监听网络响应
├─────────────────┤
│   文件事件       │ ← 监听文件读写
├─────────────────┤
│   定时器事件     │ ← 监听时间到期
└─────────────────┘
```

### 2.3 简单的事件循环示例


```python
import asyncio

# 创建和运行事件循环的基本方式
async def simple_task():
    print("任务开始")
    await asyncio.sleep(1)  # 模拟等待1秒
    print("任务完成")

# 方式1：Python 3.7+ 推荐方式
asyncio.run(simple_task())

# 方式2：手动管理事件循环
loop = asyncio.get_event_loop()
loop.run_until_complete(simple_task())
loop.close()
```

---

## 3. 🤝 协程与异步函数


### 3.1 什么是协程


**🎭 协程的生活化理解**
```
协程就像"可以暂停的函数"：

普通函数（一口气跑完）：
def 做饭():
    切菜() → 炒菜() → 装盘() → 结束

协程函数（可以中途休息）：
async def 做饭():
    切菜() 
    → yield "切菜完成，可以去做其他事"
    炒菜()
    → yield "炒菜完成，可以去做其他事" 
    装盘()
    → 结束

关键特点：
- 可以暂停：遇到 await 就暂停
- 可以恢复：等待完成后继续执行
- 不阻塞：暂停时让其他协程运行
```

**🔄 协程的执行过程**
```
协程生命周期：

创建阶段：async def 定义 → 创建协程对象
启动阶段：await 调用 → 开始执行
暂停阶段：遇到 await → 让出控制权
恢复阶段：等待完成 → 继续执行
结束阶段：函数返回 → 协程结束

图解：
[创建] → [启动] → [执行] → [暂停] → [等待] → [恢复] → [结束]
   ↑                          ↓              ↑
   └── 协程对象 ───────── await ──┘       其他协程运行
```

### 3.2 异步函数的定义和特点


**📝 基本语法**
```python
# 异步函数定义：在 def 前加 async
async def 异步函数名():
    # 函数体
    return 结果

# 调用异步函数：使用 await
result = await 异步函数名()
```

**🎯 异步函数的核心特点**
```
1. 声明方式：async def（不是普通的 def）
2. 调用方式：await 调用（不能直接调用）
3. 返回类型：协程对象（不是直接的结果）
4. 执行环境：必须在事件循环中运行
```

### 3.3 协程的实际应用示例


```python
import asyncio
import time

# 模拟网络请求的异步函数
async def fetch_data(name, delay):
    print(f"开始获取 {name} 的数据...")
    await asyncio.sleep(delay)  # 模拟网络延迟
    print(f"{name} 数据获取完成！")
    return f"{name} 的数据"

# 同时处理多个请求
async def main():
    print("开始处理多个请求...")
    start_time = time.time()
    
    # 并发执行多个协程
    results = await asyncio.gather(
        fetch_data("用户信息", 2),
        fetch_data("订单数据", 3),
        fetch_data("商品列表", 1)
    )
    
    end_time = time.time()
    print(f"所有数据获取完成，耗时: {end_time - start_time:.1f}秒")
    return results

# 运行主程序
if __name__ == "__main__":
    asyncio.run(main())
```

---

## 4. 🔤 async/await语法详解


### 4.1 async关键字详解


**🏷️ async的作用**
```
async 就像给函数贴上"异步标签"：

普通函数：
def 普通函数():
    return "我是普通函数"

异步函数：
async def 异步函数():
    return "我是异步函数"

区别：
- 普通函数：直接返回结果
- 异步函数：返回协程对象，需要用 await 获取结果
```

**⚠️ 常见误区**
```python
# ❌ 错误用法：直接调用异步函数
async def get_data():
    return "数据"

result = get_data()  # 这样得到的是协程对象，不是"数据"
print(result)  # 输出：<coroutine object get_data at 0x...>

# ✅ 正确用法：使用 await 调用
async def main():
    result = await get_data()  # 这样才能得到"数据"
    print(result)  # 输出：数据

asyncio.run(main())
```

### 4.2 await关键字详解


**⏸️ await的作用机制**
```
await 就像"暂停键"：

当程序执行到 await 时：
1. 暂停当前协程
2. 等待目标操作完成
3. 获取操作结果
4. 继续执行后面的代码

类比：
await = "等一下，让我等这个事情完成"
```

**🎯 await的使用规则**
```python
# await 只能用在 async 函数内部
async def correct_usage():
    result = await some_async_function()  # ✅ 正确
    return result

def wrong_usage():
    result = await some_async_function()  # ❌ 错误：普通函数不能用 await
    return result

# await 只能等待"可等待对象"
async def demo():
    await asyncio.sleep(1)     # ✅ 可以等待
    await some_async_func()    # ✅ 可以等待
    await "字符串"              # ❌ 错误：字符串不能等待
```

### 4.3 async/await组合使用模式


**📋 常用模式总结**

```python
import asyncio

# 模式1：基础异步函数
async def basic_async():
    await asyncio.sleep(1)
    return "完成"

# 模式2：异步函数调用异步函数
async def call_other_async():
    result = await basic_async()
    return f"结果：{result}"

# 模式3：并发执行多个异步任务
async def concurrent_tasks():
    # 同时启动多个任务，等待全部完成
    results = await asyncio.gather(
        basic_async(),
        call_other_async(),
        asyncio.sleep(2)
    )
    return results

# 模式4：有条件的异步执行
async def conditional_async(should_wait):
    if should_wait:
        await asyncio.sleep(1)
        return "等待后的结果"
    return "立即返回的结果"
```

**🔄 执行流程图示**
```
async/await 执行流程：

程序启动
    ↓
调用 async 函数
    ↓
执行到 await ──→ 暂停当前协程 ──→ 执行其他协程
    ↓                                    ↓
等待操作完成 ←──────────────────────────────┘
    ↓
获取结果继续执行
    ↓
函数结束返回结果
```

---

## 5. 🚪 异步上下文管理器


### 5.1 什么是异步上下文管理器


**🏠 生活化理解**
```
上下文管理器就像"自动门卫"：

普通上下文管理器（同步门卫）：
with open("文件.txt") as f:
    # 门卫立即开门
    content = f.read()
    # 门卫立即关门

异步上下文管理器（异步门卫）：
async with aiofiles.open("文件.txt") as f:
    # 门卫可能需要等一下才开门
    content = await f.read()
    # 门卫可能需要等一下才关门

特点：
- 开门/关门可能需要等待
- 等待期间不阻塞其他操作
- 保证资源正确管理
```

### 5.2 异步上下文管理器的语法


**📝 基本语法对比**
```python
# 同步版本
with resource_manager() as resource:
    # 使用资源
    result = resource.do_something()

# 异步版本  
async with async_resource_manager() as resource:
    # 使用资源（可能需要 await）
    result = await resource.do_something_async()
```

### 5.3 实际应用示例


**🌐 异步HTTP客户端示例**
```python
import aiohttp
import asyncio

async def fetch_multiple_urls():
    urls = [
        "https://httpbin.org/delay/1",
        "https://httpbin.org/delay/2", 
        "https://httpbin.org/delay/3"
    ]
    
    # 异步HTTP会话管理
    async with aiohttp.ClientSession() as session:
        tasks = []
        for url in urls:
            task = fetch_url(session, url)
            tasks.append(task)
        
        # 并发执行所有请求
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url(session, url):
    print(f"开始请求: {url}")
    async with session.get(url) as response:
        data = await response.json()
        print(f"完成请求: {url}")
        return data

# 运行示例
asyncio.run(fetch_multiple_urls())
```

### 5.4 自定义异步上下文管理器


```python
class AsyncDatabaseConnection:
    async def __aenter__(self):
        print("正在连接数据库...")
        await asyncio.sleep(0.5)  # 模拟连接耗时
        print("数据库连接成功！")
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("正在关闭数据库连接...")
        await asyncio.sleep(0.3)  # 模拟关闭耗时
        print("数据库连接已关闭！")
    
    async def query(self, sql):
        print(f"执行查询: {sql}")
        await asyncio.sleep(1)  # 模拟查询耗时
        return f"查询结果: {sql}"

# 使用自定义异步上下文管理器
async def database_demo():
    async with AsyncDatabaseConnection() as db:
        result1 = await db.query("SELECT * FROM users")
        result2 = await db.query("SELECT * FROM orders")
        return [result1, result2]

asyncio.run(database_demo())
```

---

## 6. 🔄 异步迭代器


### 6.1 什么是异步迭代器


**📚 迭代器的对比理解**
```
普通迭代器（同步翻书）：
for page in book:
    content = page.read()  # 立即读取
    print(content)

异步迭代器（在线读书）：
async for page in online_book:
    content = await page.download()  # 可能需要等待下载
    print(content)

区别：
- 普通迭代器：每次都能立即获取数据
- 异步迭代器：每次可能需要等待才能获取数据
```

### 6.2 异步迭代器的语法


**📝 基本语法**
```python
# 同步迭代
for item in iterable:
    process(item)

# 异步迭代
async for item in async_iterable:
    await process_async(item)
```

### 6.3 实际应用示例


**🌊 模拟数据流处理**
```python
import asyncio

class AsyncDataStream:
    def __init__(self, data_list):
        self.data_list = data_list
        self.index = 0
    
    def __aiter__(self):
        return self
    
    async def __anext__(self):
        if self.index >= len(self.data_list):
            raise StopAsyncIteration
        
        # 模拟异步获取数据
        await asyncio.sleep(0.5)
        data = self.data_list[self.index]
        self.index += 1
        print(f"获取到数据: {data}")
        return data

# 使用异步迭代器
async def process_data_stream():
    data_stream = AsyncDataStream(["数据1", "数据2", "数据3", "数据4"])
    
    print("开始处理数据流...")
    async for data in data_stream:
        # 处理每个数据项
        print(f"处理中: {data}")
        await asyncio.sleep(0.2)  # 模拟处理时间
    
    print("数据流处理完成！")

asyncio.run(process_data_stream())
```

**📁 异步文件处理示例**
```python
import aiofiles

async def process_large_file(filename):
    print(f"开始处理文件: {filename}")
    line_count = 0
    
    # 异步打开文件
    async with aiofiles.open(filename, 'r', encoding='utf-8') as file:
        # 异步迭代文件的每一行
        async for line in file:
            line_count += 1
            # 模拟处理每一行
            if line_count % 1000 == 0:
                print(f"已处理 {line_count} 行")
            
            # 在处理大文件时，偶尔让出控制权
            if line_count % 100 == 0:
                await asyncio.sleep(0.001)
    
    print(f"文件处理完成，总共 {line_count} 行")

# 并发处理多个文件
async def process_multiple_files():
    files = ["file1.txt", "file2.txt", "file3.txt"]
    await asyncio.gather(*[process_large_file(f) for f in files])
```

---

## 7. 🎲 异步生成器


### 7.1 什么是异步生成器


**🏭 生成器的生动比喻**
```
普通生成器（本地工厂）：
def 生产线():
    for i in range(5):
        产品 = 制造(i)  # 立即制造
        yield 产品

异步生成器（在线工厂）：
async def 在线生产线():
    for i in range(5):
        产品 = await 在线制造(i)  # 可能需要等待原料
        yield 产品

特点：
- 普通生成器：按需立即生产
- 异步生成器：按需等待生产
- 都是懒加载：只在需要时才生产下一个
```

### 7.2 异步生成器的定义和使用


**📝 基本语法**
```python
# 定义异步生成器：async def + yield
async def async_generator():
    for i in range(3):
        await asyncio.sleep(1)  # 模拟异步操作
        yield f"第{i+1}个数据"

# 使用异步生成器：async for
async def use_async_generator():
    async for data in async_generator():
        print(f"收到: {data}")
```

### 7.3 实际应用示例


**📊 异步数据分批处理**
```python
import asyncio

async def fetch_batch_data(batch_size=3):
    """模拟分批获取数据的异步生成器"""
    total_data = list(range(1, 16))  # 模拟15个数据
    
    for i in range(0, len(total_data), batch_size):
        batch = total_data[i:i + batch_size]
        
        print(f"正在获取第 {i//batch_size + 1} 批数据...")
        await asyncio.sleep(1)  # 模拟网络请求延迟
        
        print(f"获取到一批数据: {batch}")
        yield batch

async def process_data_in_batches():
    print("开始分批处理数据...")
    
    batch_count = 0
    total_items = 0
    
    # 使用异步生成器逐批处理数据
    async for batch in fetch_batch_data():
        batch_count += 1
        total_items += len(batch)
        
        print(f"正在处理第 {batch_count} 批数据...")
        
        # 模拟处理每个数据项
        for item in batch:
            await asyncio.sleep(0.1)  # 模拟处理时间
            print(f"  处理数据项: {item}")
        
        print(f"第 {batch_count} 批处理完成\n")
    
    print(f"所有数据处理完成！总共处理了 {total_items} 个数据项")

asyncio.run(process_data_in_batches())
```

**🌐 实时数据流模拟**
```python
import asyncio
import random

async def realtime_sensor_data():
    """模拟实时传感器数据流"""
    sensor_id = 1
    
    while True:
        # 模拟传感器读取延迟
        await asyncio.sleep(random.uniform(0.5, 2.0))
        
        # 生成模拟传感器数据
        temperature = round(random.uniform(20.0, 30.0), 1)
        humidity = round(random.uniform(40.0, 80.0), 1)
        
        sensor_data = {
            'sensor_id': sensor_id,
            'temperature': temperature,
            'humidity': humidity,
            'timestamp': asyncio.get_event_loop().time()
        }
        
        yield sensor_data

async def monitor_sensors():
    """监控传感器数据"""
    print("开始监控传感器数据...")
    data_count = 0
    
    async for data in realtime_sensor_data():
        data_count += 1
        print(f"接收到第 {data_count} 条数据: "
              f"温度={data['temperature']}°C, "
              f"湿度={data['humidity']}%")
        
        # 模拟数据处理
        if data['temperature'] > 28.0:
            print("⚠️  温度告警：温度过高！")
        
        # 为了演示，只处理前10条数据
        if data_count >= 10:
            print("监控结束")
            break

asyncio.run(monitor_sensors())
```

---

## 8. 🚀 异步编程的优势


### 8.1 性能优势对比


**⏱️ 执行时间对比**
```
场景：处理3个网络请求，每个耗时2秒

同步方式：
请求1 (2秒) → 请求2 (2秒) → 请求3 (2秒) = 总耗时6秒

异步方式：
同时发起请求1、2、3 → 等待最慢的完成 = 总耗时2秒

性能提升：3倍效率提升！
```

**📊 资源利用率对比**
```
同步编程的问题：
┌─────────────────────────────────────┐
│ CPU: ████░░░░░░░░░░░░░░░░░░░░░░░░░░ │ 15% 利用率
│ 网络: ░░░░████░░░░████░░░░████░░░░ │ 断断续续
│ 内存: ██████████████████████████ │ 持续占用
└─────────────────────────────────────┘

异步编程的改善：
┌─────────────────────────────────────┐
│ CPU: ████████████████████████████ │ 85% 利用率
│ 网络: ████████████████████████████ │ 充分利用
│ 内存: ████████████░░░░░░░░░░░░░░░░ │ 高效利用
└─────────────────────────────────────┘
```

### 8.2 实际性能测试


```python
import asyncio
import aiohttp
import requests
import time

# 同步版本：一个一个请求
def sync_fetch_all():
    urls = [
        "https://httpbin.org/delay/2",
        "https://httpbin.org/delay/2", 
        "https://httpbin.org/delay/2"
    ]
    
    start_time = time.time()
    results = []
    
    for url in urls:
        response = requests.get(url)
        results.append(response.status_code)
    
    end_time = time.time()
    print(f"同步方式耗时: {end_time - start_time:.1f}秒")
    return results

# 异步版本：同时发起请求
async def async_fetch_all():
    urls = [
        "https://httpbin.org/delay/2",
        "https://httpbin.org/delay/2",
        "https://httpbin.org/delay/2"
    ]
    
    start_time = time.time()
    
    async with aiohttp.ClientSession() as session:
        tasks = [session.get(url) for url in urls]
        responses = await asyncio.gather(*tasks)
        results = [resp.status for resp in responses]
    
    end_time = time.time()
    print(f"异步方式耗时: {end_time - start_time:.1f}秒")
    return results

# 性能对比测试
def performance_comparison():
    print("=== 性能对比测试 ===")
    
    # 测试同步方式
    print("测试同步方式...")
    sync_results = sync_fetch_all()
    
    # 测试异步方式  
    print("测试异步方式...")
    async_results = asyncio.run(async_fetch_all())
    
    print(f"结果对比 - 同步: {sync_results}, 异步: {async_results}")

# performance_comparison()  # 取消注释运行测试
```

### 8.3 异步编程的应用场景


**🎯 最适合的场景**
```
高并发Web服务：
✅ 处理大量用户请求
✅ 数据库查询优化
✅ 外部API调用
✅ 文件上传下载

爬虫程序：
✅ 并发抓取网页
✅ 批量数据处理
✅ 避免IP被封

实时系统：
✅ 聊天应用
✅ 游戏服务器
✅ 数据监控
✅ 消息推送
```

**❌ 不适合的场景**
```
CPU密集型任务：
❌ 复杂数学计算
❌ 图像视频处理
❌ 数据分析计算
❌ 机器学习训练

原因：这些任务本身就占满CPU，没有等待时间
建议：使用多进程而不是异步
```

### 8.4 选择异步编程的判断标准


**🤔 判断流程图**
```
开始评估
    ↓
你的程序有很多等待时间吗？
    ├─ 是 → 有网络请求、文件IO、数据库查询等？
    │      ├─ 是 → ✅ 适合异步编程
    │      └─ 否 → 继续评估
    └─ 否 → 主要是计算任务？
           ├─ 是 → ❌ 不适合异步，考虑多进程
           └─ 否 → 普通同步编程即可
```

**📋 决策对照表**

| 场景特征 | **异步编程** | **同步编程** | **多进程** |
|---------|-------------|-------------|-----------|
| **大量IO等待** | ✅ 最优选择 | ❌ 效率低 | ⚠️ 资源浪费 |
| **CPU密集计算** | ❌ 无效果 | ⚠️ 单核限制 | ✅ 最优选择 |
| **混合场景** | ✅ 较好 | ❌ 效率一般 | ⚠️ 复杂度高 |
| **简单任务** | ⚠️ 过度设计 | ✅ 简单直接 | ❌ 杀鸡用牛刀 |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 异步编程本质：不要傻等，充分利用等待时间
🔸 事件循环：异步程序的调度中心，负责任务协调
🔸 协程：可以暂停和恢复的特殊函数
🔸 async/await：定义和调用异步函数的关键语法
🔸 异步上下文：资源管理的异步版本
🔸 异步迭代：逐个处理异步数据的方式
🔸 异步生成器：按需产生异步数据的工具
```

### 9.2 关键理解要点


**🔹 异步编程的思维转换**
```
同步思维：做完A再做B
异步思维：启动A和B，谁先完成处理谁

同步比喻：排队买菜，一个一个来
异步比喻：同时向多个摊位下单，谁先做好拿谁的
```

**🔹 async/await的正确理解**
```
async = "这是一个可以暂停的函数"
await = "在这里暂停，等待结果"

记忆要点：
- async 函数返回协程对象，不是直接结果
- await 只能在 async 函数内使用
- await 会暂停当前协程，让其他协程运行
```

**🔹 何时使用异步编程**
```
有大量等待时间 + 需要高并发 = 适合异步

判断标准：
✅ 网络请求多 → 异步优势明显
✅ 文件操作多 → 异步有帮助  
❌ 纯计算任务 → 异步无用
❌ 简单脚本 → 过度设计
```

### 9.3 实战应用指南


**💼 常见应用模式**
```python
# 模式1：并发处理多个任务
async def concurrent_pattern():
    results = await asyncio.gather(
        task1(), task2(), task3()
    )
    return results

# 模式2：异步资源管理
async def resource_pattern():
    async with async_resource() as resource:
        return await resource.process()

# 模式3：异步数据流处理
async def stream_pattern():
    async for item in async_data_stream():
        await process(item)
```

**🔧 最佳实践**
```
代码组织：
- 把IO操作改成异步版本
- 使用 asyncio.gather() 并发执行
- 合理使用异步上下文管理器

性能优化：
- 避免在异步函数中调用同步阻塞操作
- 使用连接池减少连接开销
- 适当控制并发数量避免过载

错误处理：
- 异步操作也要有超时机制
- 使用 try/except 处理异步异常
- 考虑部分失败的处理策略
```

### 9.4 学习进阶路线


**📚 学习路径**
```
基础阶段（当前）：
✅ 理解异步编程概念
✅ 掌握 async/await 语法
✅ 学会基本的异步操作

进阶阶段：
🎯 学习 asyncio 标准库
🎯 掌握异步HTTP客户端（aiohttp）
🎯 了解异步数据库操作
🎯 学习异步队列和锁

高级阶段：
🚀 异步Web框架（FastAPI、aiohttp）
🚀 异步微服务架构
🚀 性能调优和监控
🚀 异步测试方法
```

**⚠️ 常见陷阱提醒**
```
1. 忘记使用 await
   错误：result = async_func()
   正确：result = await async_func()

2. 在普通函数中使用 await
   错误：def func(): await something()
   正确：async def func(): await something()

3. 异步函数中调用阻塞操作
   错误：async def func(): time.sleep(1)
   正确：async def func(): await asyncio.sleep(1)

4. 不处理异步异常
   建议：使用 try/except 包围 await 操作
```

**核心记忆口诀**：
- 异步编程不傻等，IO等待最适合
- async定义await调用，事件循环来协调
- 上下文管理资源好，迭代生成按需要
- 并发处理效率高，合适场景是关键