---
title: 1、调试技巧与开发工具
---
## 📚 目录

1. [WebSocket错误码详解](#1-WebSocket错误码详解)
2. [浏览器开发者工具调试](#2-浏览器开发者工具调试)
3. [连接状态监控与诊断](#3-连接状态监控与诊断)
4. [专业调试工具推荐](#4-专业调试工具推荐)
5. [日志打印最佳实践](#5-日志打印最佳实践)
6. [服务端错误处理方式](#6-服务端错误处理方式)
7. [连接问题排查方法](#7-连接问题排查方法)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚨 WebSocket错误码详解


### 1.1 什么是WebSocket错误码


WebSocket错误码就像**快递失败的原因代码**一样，告诉我们连接为什么会出问题。

```
就像快递：
- 1000：正常签收（正常关闭）
- 1001：收件人搬家（服务器重启）
- 1006：包裹丢失（网络异常断开）
```

### 1.2 常见错误码含义


#### 🔸 1000 - 正常关闭

```javascript
// 这是最好的情况，连接正常结束
ws.close(1000, "任务完成，正常关闭");

// 什么时候出现：
// - 用户主动关闭页面
// - 程序正常结束连接
// - 聊天室退出登录
```

**通俗理解**：就像打完电话后正常挂断，双方都知道通话结束了。

#### 🔸 1001 - 服务端离开

```javascript
// 服务器要重启或维护时会发送这个码
ws.close(1001, "服务器维护中");

// 什么时候出现：
// - 服务器重启升级
// - 服务器主动断开连接
// - 后端程序崩溃重启
```

**通俗理解**：就像店铺要关门维护，老板提前通知顾客"我们要暂停营业了"。

#### 🔸 1006 - 异常断开（最常见）

```javascript
// 注意：1006是浏览器自动设置的，不能手动发送
// 常见触发场景
ws.onclose = function(event) {
    if (event.code === 1006) {
        console.log("连接异常断开，可能是网络问题");
    }
};
```

**通俗理解**：就像打电话时突然断线，不知道是信号差还是对方手机没电了。

### 1.3 错误码快速判断表


| 错误码 | **含义** | **原因** | **解决方案** |
|--------|----------|----------|--------------|
| `1000` | **正常关闭** | `程序主动关闭` | `无需处理` |
| `1001` | **服务端离开** | `服务器重启/维护` | `稍后重连` |
| `1006` | **异常断开** | `网络问题/服务器崩溃` | `立即重连` |
| `1002` | **协议错误** | `数据格式不对` | `检查发送数据` |
| `1003` | **不支持的数据** | `发送了错误类型数据` | `检查消息格式` |

---

## 2. 🔧 浏览器开发者工具调试


### 2.1 打开WebSocket调试面板


**步骤很简单**：
1. 按 `F12` 打开开发者工具
2. 点击 `Network`（网络）标签
3. 找到 `WS`（WebSocket）筛选按钮

```
浏览器调试面板：
┌─────────────────────────────────┐
│ Elements Console Sources Network│
│                          ↑      │
│                        点这里    │
├─────────────────────────────────┤
│ All Fetch/XHR JS CSS Img WS    │
│                         ↑       │
│                       点这里     │
└─────────────────────────────────┘
```

### 2.2 查看连接状态


**连接状态一目了然**：

```
连接列表显示：
名称              状态        类型
localhost:3000   101 (握手成功)  websocket
chat.example.com 连接中...      websocket  
api.test.com     已断开         websocket
```

**状态含义**：
- `101 Switching Protocols`：握手成功，连接建立 ✅
- `连接中...`：正在尝试连接
- `已断开`：连接已经关闭

### 2.3 实时消息监控


点击具体连接后，可以看到：

```
消息面板：
┌─────────────────────────────────┐
│ Headers  Messages  Timing      │
│           ↑                     │
│         点这里看消息             │
├─────────────────────────────────┤
│ ↑ {"type":"login","user":"张三"}  │
│ ↓ {"type":"welcome","msg":"欢迎"} │
│ ↑ {"type":"chat","msg":"你好"}    │
│ ↓ {"type":"chat","msg":"收到"}    │
└─────────────────────────────────┘
```

**符号含义**：
- `↑`：向服务器发送的消息
- `↓`：从服务器接收的消息

### 2.4 检查握手信息


在 `Headers` 标签可以看到连接建立的详细信息：

```
请求头：
Upgrade: websocket
Connection: Upgrade  
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==

响应头：
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

**通俗理解**：这就像是双方的"暗号对接"，确认彼此都支持WebSocket通信。

---

## 3. 📊 连接状态监控与诊断


### 3.1 连接状态的4个阶段


```
连接生命周期：
准备连接 → 正在连接 → 连接成功 → 连接关闭
  CONNECTING → OPEN → CLOSING → CLOSED
     0         1       2         3
```

### 3.2 实时状态检查代码


```javascript
function checkConnectionStatus(ws) {
    const states = {
        0: "正在连接...",
        1: "连接已建立 ✅",
        2: "正在关闭...",
        3: "连接已关闭 ❌"
    };
    
    console.log(`当前状态：${states[ws.readyState]}`);
    
    // 每秒检查一次连接状态
    const timer = setInterval(() => {
        console.log(`连接状态：${states[ws.readyState]}`);
        
        // 连接关闭后停止检查
        if (ws.readyState === 3) {
            clearInterval(timer);
        }
    }, 1000);
}
```

### 3.3 连接健康检测（心跳检测）


**为什么需要心跳检测**？
就像医生测脉搏一样，定期发送小消息确认连接还活着。

```javascript
class WebSocketManager {
    constructor(url) {
        this.ws = new WebSocket(url);
        this.heartbeatInterval = null;
        this.setupHeartbeat();
    }
    
    // 设置心跳检测
    setupHeartbeat() {
        this.ws.onopen = () => {
            console.log("连接建立，开始心跳检测");
            
            // 每30秒发送一次心跳
            this.heartbeatInterval = setInterval(() => {
                if (this.ws.readyState === 1) {
                    this.ws.send(JSON.stringify({type: 'ping'}));
                    console.log("💗 发送心跳");
                }
            }, 30000);
        };
        
        this.ws.onclose = () => {
            console.log("连接关闭，停止心跳");
            clearInterval(this.heartbeatInterval);
        };
        
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'pong') {
                console.log("💗 收到心跳回应");
            }
        };
    }
}
```

---

## 4. 🛠️ 专业调试工具推荐


### 4.1 Chrome DevTools WebSocket面板


**最方便的调试工具**，无需安装额外软件：

```
优势：
✅ 实时查看消息收发
✅ 查看连接握手详情  
✅ 监控连接状态变化
✅ 支持消息过滤搜索
✅ 完全免费
```

**使用技巧**：
- 可以在消息上右键复制内容
- 支持按消息类型筛选
- 时间戳显示精确到毫秒

### 4.2 Postman WebSocket测试


**专业接口测试工具**：

```
使用步骤：
1. 打开Postman
2. 新建请求 → 选择WebSocket
3. 输入ws://localhost:3000
4. 点击Connect连接
5. 在消息框发送测试数据
```

**适用场景**：
- 测试WebSocket API
- 模拟客户端发送各种消息
- 批量测试不同参数

### 4.3 VS Code插件推荐


#### 🔸 WebSocket King

```
功能特点：
- 在VS Code内直接测试WebSocket
- 支持多个连接同时调试
- 可保存测试用例
- 语法高亮显示消息内容
```

#### 🔸 REST Client

```javascript
// 在.http文件中直接写WebSocket测试
##

GET ws://localhost:3000
Upgrade: websocket
Connection: Upgrade

// 发送消息
{"type": "chat", "message": "Hello WebSocket!"}
```

### 4.4 在线WebSocket测试工具


**websocket.org Echo Test**：
- 网址：`ws://echo.websocket.org/`
- 功能：发送什么消息就回复什么消息
- 用途：测试基本连接和消息收发

---

## 5. 📝 日志打印最佳实践


### 5.1 日志分级策略


```javascript
class WebSocketLogger {
    constructor(debugMode = false) {
        this.debugMode = debugMode;
    }
    
    // 信息日志 - 正常操作
    info(message, data = null) {
        console.log(`[WS-INFO] ${message}`, data || '');
    }
    
    // 警告日志 - 需要注意但不影响功能
    warn(message, data = null) {
        console.warn(`[WS-WARN] ${message}`, data || '');
    }
    
    // 错误日志 - 影响功能的问题
    error(message, error = null) {
        console.error(`[WS-ERROR] ${message}`, error || '');
    }
    
    // 调试日志 - 开发时的详细信息
    debug(message, data = null) {
        if (this.debugMode) {
            console.log(`[WS-DEBUG] ${message}`, data || '');
        }
    }
}
```

### 5.2 实用日志记录模板


```javascript
const logger = new WebSocketLogger(true);

const ws = new WebSocket('ws://localhost:3000');

ws.onopen = (event) => {
    logger.info('WebSocket连接建立成功');
    logger.debug('连接事件详情', event);
};

ws.onmessage = (event) => {
    logger.info('收到消息', event.data);
    
    try {
        const data = JSON.parse(event.data);
        logger.debug('解析后的消息', data);
    } catch (err) {
        logger.warn('消息解析失败，可能不是JSON格式', event.data);
    }
};

ws.onerror = (error) => {
    logger.error('WebSocket发生错误', error);
};

ws.onclose = (event) => {
    logger.info(`连接关闭，代码：${event.code}，原因：${event.reason}`);
    
    if (event.code === 1006) {
        logger.warn('连接异常断开，可能需要重连');
    }
};
```

### 5.3 生产环境日志建议


**生产环境要谨慎**，不要暴露敏感信息：

```javascript
// ❌ 错误做法 - 可能泄露用户信息
console.log('用户登录', {username: 'zhangsan', password: '123456'});

// ✅ 正确做法 - 只记录必要信息  
console.log('用户登录成功', {userId: 'user_001', timestamp: Date.now()});
```

---

## 6. 🔧 服务端错误处理方式


### 6.1 Node.js服务端错误处理


```javascript
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
    console.log('新客户端连接');
    
    // 处理客户端消息
    ws.on('message', (message) => {
        try {
            const data = JSON.parse(message);
            console.log('收到消息:', data);
            
            // 处理不同类型的消息
            handleMessage(ws, data);
            
        } catch (error) {
            console.error('消息解析失败:', error);
            
            // 发送错误提示给客户端
            ws.send(JSON.stringify({
                type: 'error',
                message: '消息格式不正确'
            }));
        }
    });
    
    // 处理连接错误
    ws.on('error', (error) => {
        console.error('WebSocket错误:', error);
    });
    
    // 处理连接关闭
    ws.on('close', (code, reason) => {
        console.log(`客户端断开连接: ${code} - ${reason}`);
    });
});

function handleMessage(ws, data) {
    switch(data.type) {
        case 'chat':
            // 转发聊天消息
            broadcastMessage(data);
            break;
        case 'ping':
            // 回应心跳
            ws.send(JSON.stringify({type: 'pong'}));
            break;
        default:
            ws.send(JSON.stringify({
                type: 'error', 
                message: '不支持的消息类型'
            }));
    }
}
```

### 6.2 常见服务端问题处理


#### 🔸 内存泄漏预防

```javascript
// 记录所有连接，便于管理
const clients = new Set();

wss.on('connection', (ws) => {
    clients.add(ws);
    
    ws.on('close', () => {
        clients.delete(ws);  // 重要：连接关闭时要移除
        console.log(`当前连接数: ${clients.size}`);
    });
});
```

#### 🔸 消息发送异常处理

```javascript
function safeSend(ws, message) {
    try {
        if (ws.readyState === WebSocket.OPEN) {
            ws.send(message);
        } else {
            console.log('连接未开启，消息发送失败');
        }
    } catch (error) {
        console.error('消息发送异常:', error);
    }
}
```

---

## 7. 🔍 连接问题排查方法


### 7.1 断开连接原因分析


**连接断开就像手机通话中断**，可能的原因：

```
网络问题分析流程：
用户反映连接断开
        ↓
1. 检查错误码是什么？
   ├─ 1000：正常关闭
   ├─ 1001：服务器重启  
   └─ 1006：异常断开 ← 最需要排查
        ↓
2. 检查网络环境
   ├─ WiFi信号强度
   ├─ 运营商网络稳定性
   └─ 防火墙/代理设置
        ↓  
3. 检查服务器状态
   ├─ 服务器是否正常运行
   ├─ 服务器资源使用情况
   └─ 服务器日志错误信息
```

### 7.2 连接存活性检测


**如何判断连接是否还活着**？

```javascript
class ConnectionMonitor {
    constructor(ws) {
        this.ws = ws;
        this.lastPongTime = Date.now();
        this.checkInterval = null;
    }
    
    startMonitoring() {
        // 每10秒发送心跳
        this.checkInterval = setInterval(() => {
            this.sendPing();
        }, 10000);
        
        // 监听心跳回应
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'pong') {
                this.lastPongTime = Date.now();
            }
        };
        
        // 每20秒检查是否收到心跳回应
        setInterval(() => {
            this.checkConnection();
        }, 20000);
    }
    
    sendPing() {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({type: 'ping'}));
        }
    }
    
    checkConnection() {
        const now = Date.now();
        const timeSinceLastPong = now - this.lastPongTime;
        
        if (timeSinceLastPong > 30000) {  // 30秒没收到回应
            console.warn('连接可能已死，准备重连');
            this.reconnect();
        }
    }
    
    reconnect() {
        this.ws.close();
        // 重新建立连接的逻辑...
    }
}
```

### 7.3 断点调试技巧


**在关键位置设置断点**：

```javascript
const ws = new WebSocket('ws://localhost:3000');

ws.onopen = (event) => {
    debugger;  // 在这里设置断点，检查连接建立
    console.log('连接建立');
};

ws.onmessage = (event) => {
    debugger;  // 在这里检查收到的消息内容
    const data = JSON.parse(event.data);
    
    // 检查消息处理逻辑是否正确
    if (data.type === 'chat') {
        debugger;  // 专门调试聊天消息处理
        displayMessage(data.message);
    }
};

ws.onerror = (error) => {
    debugger;  // 错误发生时暂停，查看错误详情
    console.error('WebSocket错误:', error);
};
```

### 7.4 常见问题快速诊断


| 问题现象 | **可能原因** | **排查方法** | **解决方案** |
|----------|-------------|--------------|-------------|
| `连接一直pending` | `服务器未启动` | `ping服务器地址` | `启动WebSocket服务` |
| `握手失败101` | `协议不匹配` | `检查URL协议(ws/wss)` | `修正协议类型` |
| `频繁断开重连` | `网络不稳定` | `检查网络环境` | `增加重连间隔` |
| `消息发送失败` | `连接已关闭` | `检查readyState` | `重新建立连接` |
| `服务器无响应` | `服务器处理异常` | `查看服务器日志` | `修复服务端代码` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的调试技能


```
🔸 错误码识别：1000正常，1001重启，1006异常
🔸 浏览器调试：F12→Network→WS查看连接和消息
🔸 连接监控：实时检查连接状态和消息收发
🔸 日志记录：分级记录，生产环境注意信息安全
🔸 问题排查：从错误码开始，逐步缩小问题范围
```

### 8.2 调试工具使用优先级


**新手推荐使用顺序**：
1. **Chrome DevTools**：最基础，必须掌握
2. **console.log日志**：简单直接，快速定位
3. **Postman**：专业测试，模拟各种场景  
4. **VS Code插件**：开发集成，提高效率

### 8.3 生产环境注意事项


```
安全考虑：
❌ 不要在日志中记录密码、令牌等敏感信息
❌ 不要在生产环境开启详细调试日志
✅ 使用日志级别控制，生产环境只记录错误和警告
✅ 定期清理日志文件，避免磁盘空间不足
```

### 8.4 实战调试流程


**遇到WebSocket问题时的标准流程**：
1. **看错误码**：确定问题类型（网络/协议/服务器）
2. **查浏览器控制台**：看详细错误信息
3. **检查Network面板**：确认连接状态和消息
4. **查看服务器日志**：确认服务端是否有异常
5. **逐步排查**：从简单到复杂，缩小问题范围

### 8.5 提升调试效率的建议


```
养成好习惯：
✅ 代码中加入适当的日志记录
✅ 使用有意义的错误提示信息
✅ 建立标准的错误处理流程
✅ 定期测试各种异常情况
✅ 保存常用的调试代码片段
```

**核心记忆**：
- WebSocket调试就像医生看病，先看症状（错误码），再查原因（日志和网络），最后对症下药（修复问题）
- 浏览器F12是最好的朋友，Network面板的WS标签是WebSocket调试的主战场
- 心跳检测是连接健康的体温计，定期测量才能及时发现问题