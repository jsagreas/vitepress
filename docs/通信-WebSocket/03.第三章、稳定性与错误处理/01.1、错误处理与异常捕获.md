---
title: 1、错误处理与异常捕获
---
## 📚 目录

1. [WebSocket错误处理概述](#1-websocket错误处理概述)
2. [常见错误类型详解](#2-常见错误类型详解)
3. [错误监听与捕获机制](#3-错误监听与捕获机制)
4. [连接关闭状态码解析](#4-连接关闭状态码解析)
5. [自动重连机制实现](#5-自动重连机制实现)
6. [心跳检测机制](#6-心跳检测机制)
7. [完整的稳定性方案](#7-完整的稳定性方案)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚨 WebSocket错误处理概述


### 1.1 为什么需要错误处理


> 💡 **通俗理解**：WebSocket就像打电话，通话过程中可能出现信号差、对方挂机、网络中断等问题，我们需要提前准备好应对方案。

WebSocket在实际使用中会遇到各种问题：

```
网络环境复杂：
用户从WiFi → 4G → 地铁无信号 → 重新连接

服务器状态变化：
服务器重启、维护、过载 → 连接中断

客户端状态变化：
浏览器最小化、切换页面、电脑休眠 → 连接暂停
```

### 1.2 错误处理的重要性


**❌ 没有错误处理的后果**：
- 连接断开后用户无感知
- 消息发送失败无提示
- 页面卡死或功能异常
- 用户体验极差

**✅ 完善错误处理的好处**：
- 自动恢复连接
- 友好的错误提示
- 保证功能稳定性
- 提升用户体验

### 1.3 错误处理的基本思路


```
错误处理三步走：
1. 监听错误 → 知道出了什么问题
2. 分析错误 → 判断错误原因和严重程度  
3. 处理错误 → 重连、提示、降级等
```

---

## 2. 🔍 常见错误类型详解


### 2.1 网络连接失败


> 💡 **通俗理解**：就像拨电话时听到"您拨打的号码暂时无法接通"

**产生原因**：
- 网络断开（WiFi断线、手机没信号）
- 服务器地址错误
- 防火墙阻拦
- DNS解析失败

**识别特征**：
```javascript
// 连接建立时就失败，会触发onerror
const ws = new WebSocket('ws://wrong-address:8080');
ws.onerror = function(error) {
    console.log('连接失败：', error);
    // 错误信息通常比较简单，不会有具体原因
};
```

### 2.2 服务器断开连接


> 💡 **通俗理解**：就像通话过程中对方突然挂机

**产生原因**：
- 服务器重启或维护
- 服务器过载主动断开连接
- 超时无活动被服务器踢出
- 服务器程序异常崩溃

**识别特征**：
```javascript
ws.onclose = function(event) {
    console.log('连接关闭，代码：', event.code);
    // code 1001: 服务器主动关闭
    // code 1006: 连接异常中断
};
```

### 2.3 消息发送失败


> 💡 **通俗理解**：就像说话时发现对方已经挂机了

**产生原因**：
- 连接已断开但还在发送消息
- 消息格式错误
- 消息太大超过限制

**识别特征**：
```javascript
// 发送消息前检查连接状态
if (ws.readyState === WebSocket.OPEN) {
    ws.send('hello');
} else {
    console.log('连接未就绪，无法发送消息');
    // 可以将消息存储，等重连后再发送
}
```

### 2.4 握手失败


> 💡 **通俗理解**：就像打电话时对方拒接

**产生原因**：
- 服务器不支持WebSocket协议
- 协议版本不匹配
- 认证失败（需要token但未提供）

**识别特征**：
```javascript
// 握手失败会立即触发onerror和onclose
ws.onerror = function(error) {
    console.log('握手失败');
};
ws.onclose = function(event) {
    if (event.code === 1002) {
        console.log('协议错误导致连接关闭');
    }
};
```

---

## 3. 👂 错误监听与捕获机制


### 3.1 onerror事件监听


> 💡 **通俗理解**：`onerror`就像手机的"通话失败"提示音

```javascript
const ws = new WebSocket('ws://localhost:8080');

// 监听错误事件
ws.onerror = function(error) {
    console.error('WebSocket发生错误：', error);
    
    // 根据错误类型进行不同处理
    if (error.type === 'error') {
        showUserMessage('连接出现问题，正在尝试重连...');
        // 启动重连机制
        startReconnect();
    }
};

// 显示用户提示的简单函数
function showUserMessage(message) {
    // 可以用弹窗、顶部横幅等方式提示用户
    console.log('提示用户：', message);
}
```

### 3.2 错误信息的局限性


> ⚠️ **注意**：浏览器的WebSocket错误信息很有限，主要出于安全考虑

```javascript
ws.onerror = function(error) {
    // 错误对象包含的信息很少
    console.log(error.type);      // 通常是 "error"
    console.log(error.target);    // WebSocket对象本身
    // 没有具体错误原因，需要结合其他事件判断
};
```

### 3.3 最佳实践：错误处理策略


```javascript
class WebSocketManager {
    constructor(url) {
        this.url = url;
        this.ws = null;
        this.reconnectCount = 0;
        this.maxReconnectCount = 5;
        this.isManualClose = false; // 是否主动关闭
    }
    
    connect() {
        try {
            this.ws = new WebSocket(this.url);
            this.bindEvents();
        } catch (error) {
            console.error('创建WebSocket失败：', error);
            this.handleError('CREATE_FAILED');
        }
    }
    
    bindEvents() {
        this.ws.onerror = (error) => {
            console.error('WebSocket错误：', error);
            this.handleError('CONNECTION_ERROR');
        };
        
        this.ws.onclose = (event) => {
            console.log('连接关闭：', event.code, event.reason);
            if (!this.isManualClose) {
                this.handleError('CONNECTION_CLOSED', event.code);
            }
        };
    }
    
    handleError(errorType, errorCode) {
        // 统一的错误处理入口
        switch (errorType) {
            case 'CONNECTION_ERROR':
                showUserMessage('网络连接异常，正在重连...');
                this.startReconnect();
                break;
            case 'CONNECTION_CLOSED':
                this.handleConnectionClosed(errorCode);
                break;
            case 'CREATE_FAILED':
                showUserMessage('连接创建失败，请检查网络');
                break;
        }
    }
}
```

---

## 4. 🏷️ 连接关闭状态码解析


### 4.1 状态码的含义


> 💡 **通俗理解**：状态码就像挂机时的提示音，告诉你为什么断线了

WebSocket关闭时会提供一个状态码，帮助我们判断断线原因：

```
状态码分类：
1000-1999：标准状态码（协议定义）
3000-3999：框架/库自定义状态码  
4000-4999：应用自定义状态码
```

### 4.2 常见状态码详解


| 状态码 | 名称 | 含义 | 应对策略 |
|--------|------|------|----------|
| **1000** | `正常关闭` | 连接正常结束 | 无需处理 |
| **1001** | `端点离开` | 服务器关闭或刷新页面 | 可以尝试重连 |
| **1002** | `协议错误` | 数据格式错误 | 检查消息格式 |
| **1003** | `数据类型错误` | 不支持的数据类型 | 检查发送内容 |
| **1006** | `连接异常关闭` | 网络中断或异常 | 立即重连 |
| **1011** | `服务器错误` | 服务器内部错误 | 稍后重连 |

### 4.3 状态码处理实践


```javascript
ws.onclose = function(event) {
    const code = event.code;
    const reason = event.reason || '未知原因';
    
    console.log(`连接关闭：${code} - ${reason}`);
    
    // 根据状态码决定处理策略
    switch (code) {
        case 1000:
            // 正常关闭，无需处理
            showUserMessage('连接已正常关闭');
            break;
            
        case 1001:
            // 端点离开，可能是服务器重启
            showUserMessage('服务器重启中，正在重连...');
            setTimeout(() => this.reconnect(), 3000);
            break;
            
        case 1006:
            // 异常关闭，立即重连
            showUserMessage('网络异常，正在重连...');
            this.reconnect();
            break;
            
        case 1002:
        case 1003:
            // 协议或数据错误，不要重连
            showUserMessage('数据格式错误，请联系开发者');
            break;
            
        default:
            // 其他错误，尝试重连
            if (code >= 1011) {
                showUserMessage('服务器错误，稍后重连...');
                setTimeout(() => this.reconnect(), 5000);
            }
    }
};
```

### 4.4 自定义关闭码


```javascript
// 主动关闭连接时提供状态码和原因
ws.close(1000, '用户手动断开');

// 不同场景的自定义关闭
function closeConnection(reason) {
    switch (reason) {
        case 'user_logout':
            ws.close(4000, '用户登出');
            break;
        case 'page_unload':
            ws.close(4001, '页面关闭');
            break;
        case 'token_expired':
            ws.close(4002, 'Token过期');
            break;
    }
}
```

---

## 5. 🔄 自动重连机制实现


### 5.1 重连机制的必要性


> 💡 **通俗理解**：重连就像电话断了自动回拨，让通话能够持续

**为什么需要自动重连**：
- 网络波动导致的临时断线
- 服务器重启后自动恢复
- 提升用户体验，无需手动刷新

**重连策略设计**：
```
重连策略考虑因素：
1. 重连间隔 → 太快浪费资源，太慢影响体验
2. 重连次数 → 避免无限重连
3. 退避算法 → 逐渐增加间隔时间
4. 用户感知 → 提供重连状态提示
```

### 5.2 基础重连实现


```javascript
class ReconnectingWebSocket {
    constructor(url, options = {}) {
        this.url = url;
        this.options = {
            maxReconnectAttempts: 5,     // 最大重连次数
            reconnectInterval: 3000,     // 重连间隔(ms)
            maxReconnectInterval: 30000, // 最大重连间隔
            ...options
        };
        
        this.reconnectCount = 0;
        this.isManualClose = false;
        this.reconnectTimer = null;
        
        this.connect();
    }
    
    connect() {
        console.log('开始连接WebSocket...');
        
        this.ws = new WebSocket(this.url);
        this.bindEvents();
    }
    
    bindEvents() {
        this.ws.onopen = () => {
            console.log('WebSocket连接成功');
            this.reconnectCount = 0; // 重置重连计数
            this.onopen && this.onopen();
        };
        
        this.ws.onclose = (event) => {
            console.log('WebSocket连接关闭：', event.code);
            
            if (!this.isManualClose) {
                this.startReconnect();
            }
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket错误：', error);
        };
        
        this.ws.onmessage = (event) => {
            this.onmessage && this.onmessage(event);
        };
    }
    
    startReconnect() {
        // 检查是否超过最大重连次数
        if (this.reconnectCount >= this.options.maxReconnectAttempts) {
            console.log('超过最大重连次数，停止重连');
            this.onerror && this.onerror('MAX_RECONNECT_EXCEEDED');
            return;
        }
        
        // 计算重连间隔（指数退避）
        const interval = Math.min(
            this.options.reconnectInterval * Math.pow(2, this.reconnectCount),
            this.options.maxReconnectInterval
        );
        
        console.log(`${interval/1000}秒后尝试第${this.reconnectCount + 1}次重连`);
        
        this.reconnectTimer = setTimeout(() => {
            this.reconnectCount++;
            this.connect();
        }, interval);
    }
    
    // 手动关闭连接
    close() {
        this.isManualClose = true;
        clearTimeout(this.reconnectTimer);
        this.ws && this.ws.close();
    }
    
    // 发送消息
    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(data);
        } else {
            console.warn('WebSocket未连接，消息发送失败');
            // 可以将消息存储到队列，连接后再发送
        }
    }
}
```

### 5.3 智能重连策略


```javascript
// 根据断线原因决定是否重连
function shouldReconnect(closeCode) {
    const noReconnectCodes = [
        1000, // 正常关闭
        1002, // 协议错误
        1003, // 数据类型错误
        4000, // 自定义：用户主动断开
        4001, // 自定义：认证失败
    ];
    
    return !noReconnectCodes.includes(closeCode);
}

// 使用示例
this.ws.onclose = (event) => {
    if (shouldReconnect(event.code)) {
        this.startReconnect();
    } else {
        console.log('根据关闭码判断，不需要重连');
    }
};
```

### 5.4 用户友好的重连提示


```javascript
class UserFriendlyWebSocket extends ReconnectingWebSocket {
    startReconnect() {
        super.startReconnect();
        
        // 显示重连状态
        this.showReconnectStatus();
    }
    
    showReconnectStatus() {
        const messages = [
            '网络连接中断，正在重连...',
            '重连中，请稍候...',
            '网络不稳定，继续尝试重连...',
            '连接困难，正在努力重连...',
            '网络异常，即将停止重连...'
        ];
        
        const messageIndex = Math.min(this.reconnectCount, messages.length - 1);
        const message = messages[messageIndex];
        
        // 显示给用户（可以用toast、状态栏等方式）
        showUserNotification(message, 'warning');
    }
}
```

---

## 6. 💓 心跳检测机制


### 6.1 心跳检测的作用


> 💡 **通俗理解**：心跳检测就像通话中的"喂，你还在吗？"，确保连接还活着

**心跳检测解决的问题**：
- **检测死连接**：连接看起来正常但实际已断开
- **保持连接活跃**：防止因长时间无数据被关闭
- **及时发现断线**：比等到发送消息失败更早发现问题

```
心跳检测原理：
客户端                    服务器
   |                        |
   |----[ping]------------->|
   |<---[pong]--------------|
   |                        |
   定时发送ping消息
   等待pong响应
   超时则认为连接异常
```

### 6.2 基础心跳实现


```javascript
class HeartbeatWebSocket {
    constructor(url) {
        this.url = url;
        this.ws = null;
        
        // 心跳配置
        this.heartbeatInterval = 30000; // 30秒发送一次心跳
        this.heartbeatTimeout = 5000;   // 5秒内必须收到pong
        this.heartbeatTimer = null;
        this.heartbeatTimeoutTimer = null;
        
        this.connect();
    }
    
    connect() {
        this.ws = new WebSocket(this.url);
        
        this.ws.onopen = () => {
            console.log('连接成功，开始心跳');
            this.startHeartbeat();
        };
        
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            
            // 处理pong响应
            if (data.type === 'pong') {
                console.log('收到心跳响应');
                this.clearHeartbeatTimeout();
                return;
            }
            
            // 处理其他消息
            this.handleMessage(data);
        };
        
        this.ws.onclose = () => {
            console.log('连接关闭，停止心跳');
            this.stopHeartbeat();
        };
    }
    
    startHeartbeat() {
        this.heartbeatTimer = setInterval(() => {
            this.sendHeartbeat();
        }, this.heartbeatInterval);
    }
    
    sendHeartbeat() {
        if (this.ws.readyState === WebSocket.OPEN) {
            console.log('发送心跳');
            this.ws.send(JSON.stringify({ type: 'ping' }));
            
            // 设置心跳超时检测
            this.heartbeatTimeoutTimer = setTimeout(() => {
                console.log('心跳超时，连接可能已断开');
                this.handleHeartbeatTimeout();
            }, this.heartbeatTimeout);
        }
    }
    
    clearHeartbeatTimeout() {
        if (this.heartbeatTimeoutTimer) {
            clearTimeout(this.heartbeatTimeoutTimer);
            this.heartbeatTimeoutTimer = null;
        }
    }
    
    handleHeartbeatTimeout() {
        console.log('心跳检测失败，主动关闭连接并重连');
        this.ws.close();
        // 触发重连机制
        this.reconnect();
    }
    
    stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
        this.clearHeartbeatTimeout();
    }
}
```

### 6.3 智能心跳策略


```javascript
// 根据页面状态调整心跳频率
class SmartHeartbeatWebSocket extends HeartbeatWebSocket {
    constructor(url) {
        super(url);
        this.isPageVisible = true;
        this.bindVisibilityEvents();
    }
    
    bindVisibilityEvents() {
        // 监听页面可见性变化
        document.addEventListener('visibilitychange', () => {
            this.isPageVisible = !document.hidden;
            this.adjustHeartbeatInterval();
        });
    }
    
    adjustHeartbeatInterval() {
        if (this.isPageVisible) {
            // 页面可见时，正常心跳频率
            this.heartbeatInterval = 30000;
            console.log('页面可见，使用正常心跳频率');
        } else {
            // 页面隐藏时，降低心跳频率节省资源
            this.heartbeatInterval = 60000;
            console.log('页面隐藏，降低心跳频率');
        }
        
        // 重新启动心跳定时器
        this.stopHeartbeat();
        this.startHeartbeat();
    }
}
```

### 6.4 服务器端心跳配合


> 📝 **注意**：心跳检测需要服务器配合，服务器收到ping要回复pong

```javascript
// Node.js服务器端示例
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
    console.log('新连接建立');
    
    ws.on('message', (message) => {
        try {
            const data = JSON.parse(message);
            
            // 处理心跳ping消息
            if (data.type === 'ping') {
                console.log('收到心跳ping，回复pong');
                ws.send(JSON.stringify({ type: 'pong' }));
                return;
            }
            
            // 处理其他消息
            handleOtherMessage(data);
            
        } catch (error) {
            console.error('消息解析失败：', error);
        }
    });
});
```

---

## 7. 🛡️ 完整的稳定性方案


### 7.1 综合稳定性类实现


```javascript
class StableWebSocket {
    constructor(url, options = {}) {
        this.url = url;
        this.options = {
            // 重连配置
            maxReconnectAttempts: 5,
            reconnectInterval: 3000,
            maxReconnectInterval: 30000,
            
            // 心跳配置
            heartbeatInterval: 30000,
            heartbeatTimeout: 5000,
            
            // 消息队列配置
            enableMessageQueue: true,
            maxQueueSize: 100,
            
            ...options
        };
        
        // 状态管理
        this.reconnectCount = 0;
        this.isManualClose = false;
        this.connectionState = 'DISCONNECTED'; // CONNECTING, CONNECTED, DISCONNECTED, RECONNECTING
        
        // 定时器管理
        this.reconnectTimer = null;
        this.heartbeatTimer = null;
        this.heartbeatTimeoutTimer = null;
        
        // 消息队列
        this.messageQueue = [];
        
        // 事件回调
        this.eventHandlers = {};
        
        this.connect();
    }
    
    // 连接管理
    connect() {
        this.connectionState = 'CONNECTING';
        this.emit('stateChange', 'CONNECTING');
        
        try {
            this.ws = new WebSocket(this.url);
            this.bindWebSocketEvents();
        } catch (error) {
            console.error('WebSocket创建失败：', error);
            this.handleConnectionError();
        }
    }
    
    bindWebSocketEvents() {
        this.ws.onopen = () => {
            console.log('WebSocket连接成功');
            this.connectionState = 'CONNECTED';
            this.reconnectCount = 0;
            
            this.emit('stateChange', 'CONNECTED');
            this.emit('open');
            
            this.startHeartbeat();
            this.sendQueuedMessages();
        };
        
        this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket错误：', error);
            this.emit('error', error);
        };
        
        this.ws.onclose = (event) => {
            console.log('WebSocket关闭：', event.code, event.reason);
            this.connectionState = 'DISCONNECTED';
            
            this.stopHeartbeat();
            this.emit('close', event);
            
            if (!this.isManualClose && this.shouldReconnect(event.code)) {
                this.startReconnect();
            }
        };
    }
    
    // 消息处理
    handleMessage(rawData) {
        try {
            const data = JSON.parse(rawData);
            
            // 处理心跳响应
            if (data.type === 'pong') {
                this.handlePongMessage();
                return;
            }
            
            // 触发消息事件
            this.emit('message', data);
            
        } catch (error) {
            console.error('消息解析失败：', error);
            // 对于非JSON消息，直接传递原始数据
            this.emit('message', rawData);
        }
    }
    
    // 发送消息（带队列功能）
    send(data) {
        const message = typeof data === 'string' ? data : JSON.stringify(data);
        
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(message);
            console.log('消息发送成功');
        } else {
            console.log('连接未就绪，消息加入队列');
            
            if (this.options.enableMessageQueue) {
                this.addToQueue(message);
            } else {
                this.emit('sendFailed', data);
            }
        }
    }
    
    addToQueue(message) {
        if (this.messageQueue.length >= this.options.maxQueueSize) {
            console.warn('消息队列已满，移除最早的消息');
            this.messageQueue.shift();
        }
        this.messageQueue.push(message);
    }
    
    sendQueuedMessages() {
        if (this.messageQueue.length > 0) {
            console.log(`发送队列中的${this.messageQueue.length}条消息`);
            
            while (this.messageQueue.length > 0 && this.ws.readyState === WebSocket.OPEN) {
                const message = this.messageQueue.shift();
                this.ws.send(message);
            }
        }
    }
    
    // 重连机制
    startReconnect() {
        this.connectionState = 'RECONNECTING';
        this.emit('stateChange', 'RECONNECTING');
        
        if (this.reconnectCount >= this.options.maxReconnectAttempts) {
            console.log('达到最大重连次数');
            this.emit('maxReconnectExceeded');
            return;
        }
        
        const interval = Math.min(
            this.options.reconnectInterval * Math.pow(2, this.reconnectCount),
            this.options.maxReconnectInterval
        );
        
        console.log(`${interval/1000}秒后进行第${this.reconnectCount + 1}次重连`);
        
        this.reconnectTimer = setTimeout(() => {
            this.reconnectCount++;
            this.emit('reconnectAttempt', this.reconnectCount);
            this.connect();
        }, interval);
    }
    
    shouldReconnect(closeCode) {
        const noReconnectCodes = [1000, 1002, 1003, 4000];
        return !noReconnectCodes.includes(closeCode);
    }
    
    // 心跳检测
    startHeartbeat() {
        if (!this.options.heartbeatInterval) return;
        
        this.heartbeatTimer = setInterval(() => {
            this.sendPing();
        }, this.options.heartbeatInterval);
    }
    
    sendPing() {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
            
            this.heartbeatTimeoutTimer = setTimeout(() => {
                console.log('心跳超时，主动断开连接');
                this.ws.close();
            }, this.options.heartbeatTimeout);
        }
    }
    
    handlePongMessage() {
        console.log('收到心跳响应');
        if (this.heartbeatTimeoutTimer) {
            clearTimeout(this.heartbeatTimeoutTimer);
            this.heartbeatTimeoutTimer = null;
        }
    }
    
    stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
        if (this.heartbeatTimeoutTimer) {
            clearTimeout(this.heartbeatTimeoutTimer);
            this.heartbeatTimeoutTimer = null;
        }
    }
    
    // 事件系统
    on(event, handler) {
        if (!this.eventHandlers[event]) {
            this.eventHandlers[event] = [];
        }
        this.eventHandlers[event].push(handler);
    }
    
    emit(event, data) {
        if (this.eventHandlers[event]) {
            this.eventHandlers[event].forEach(handler => {
                try {
                    handler(data);
                } catch (error) {
                    console.error('事件处理器执行失败：', error);
                }
            });
        }
    }
    
    // 手动关闭
    close() {
        this.isManualClose = true;
        
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
        }
        
        this.stopHeartbeat();
        
        if (this.ws) {
            this.ws.close(1000, '手动关闭');
        }
    }
    
    // 获取连接状态
    getState() {
        return this.connectionState;
    }
    
    // 获取统计信息
    getStats() {
        return {
            reconnectCount: this.reconnectCount,
            queueSize: this.messageQueue.length,
            state: this.connectionState,
            isConnected: this.ws && this.ws.readyState === WebSocket.OPEN
        };
    }
}
```

### 7.2 使用示例


```javascript
// 创建稳定的WebSocket连接
const stableWs = new StableWebSocket('ws://localhost:8080', {
    maxReconnectAttempts: 3,
    reconnectInterval: 2000,
    heartbeatInterval: 20000,
    enableMessageQueue: true
});

// 监听各种事件
stableWs.on('open', () => {
    console.log('连接建立成功');
    showUserMessage('连接成功', 'success');
});

stableWs.on('message', (data) => {
    console.log('收到消息：', data);
    handleIncomingMessage(data);
});

stableWs.on('stateChange', (state) => {
    console.log('连接状态变化：', state);
    updateConnectionStatus(state);
});

stableWs.on('reconnectAttempt', (count) => {
    showUserMessage(`正在进行第${count}次重连...`, 'info');
});

stableWs.on('maxReconnectExceeded', () => {
    showUserMessage('连接失败，请检查网络后刷新页面', 'error');
});

// 发送消息
function sendMessage(content) {
    stableWs.send({
        type: 'chat',
        content: content,
        timestamp: Date.now()
    });
}

// 页面卸载时正确关闭连接
window.addEventListener('beforeunload', () => {
    stableWs.close();
});
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 错误类型：网络失败、服务器断开、消息发送失败、握手失败
🔸 监听机制：onerror捕获错误、onclose分析关闭原因
🔸 状态码含义：1000正常、1001离开、1006异常、其他错误码
🔸 重连策略：指数退避、最大次数限制、智能判断
🔸 心跳检测：ping-pong机制、超时检测、保持连接活跃
🔸 消息队列：断线时暂存消息、重连后补发
```

### 8.2 关键理解要点


**🔹 错误处理的核心思想**
```
三步走策略：
1. 监听错误 → 及时发现问题
2. 分析错误 → 判断错误类型和严重程度  
3. 处理错误 → 重连、提示、降级等应对措施
```

**🔹 重连机制的设计原则**
```
平衡考虑：
- 重连太快 → 浪费资源，可能被服务器拒绝
- 重连太慢 → 影响用户体验
- 无限重连 → 可能永远连不上
- 指数退避 → 逐步增加间隔，给服务器恢复时间
```

**🔹 心跳检测的作用机制**
```
解决的问题：
- 检测死连接 → 连接看起来正常但实际已断开
- 保持活跃 → 防止长时间无数据被服务器关闭
- 及时发现 → 比发送业务消息失败更早发现断线
```

### 8.3 实际应用指导


**最佳实践checklist**：
- ✅ 为所有WebSocket连接添加错误处理
- ✅ 根据关闭状态码决定是否重连
- ✅ 实现指数退避的重连策略
- ✅ 添加心跳检测机制
- ✅ 提供用户友好的连接状态提示
- ✅ 实现消息队列避免消息丢失
- ✅ 页面卸载时正确关闭连接

**常见错误避免**：
- ❌ 忽略错误处理，连接断开后无响应
- ❌ 无限制重连，造成资源浪费
- ❌ 没有用户提示，用户不知道连接状态
- ❌ 心跳频率过高，浪费带宽
- ❌ 不处理页面隐藏时的连接状态

**性能优化建议**：
- 🚀 页面不可见时降低心跳频率
- 🚀 根据网络状况调整重连策略
- 🚀 合理设置消息队列大小
- 🚀 避免频繁的连接创建和销毁

**核心记忆口诀**：
```
WebSocket要稳定，错误处理是关键
监听error和close，状态码里找答案
重连机制要智能，指数退避防雪崩
心跳检测保活跃，ping-pong及时响
消息队列防丢失，用户提示体验佳
```