---
title: 3、心跳检测机制详解
---
## 📚 目录

1. [为什么需要心跳机制](#1-为什么需要心跳机制)
2. [心跳检测基本原理](#2-心跳检测基本原理)
3. [客户端心跳实现](#3-客户端心跳实现)
4. [服务端心跳响应](#4-服务端心跳响应)
5. [Ping/Pong标准机制](#5-ping-pong标准机制)
6. [连接状态判断与处理](#6-连接状态判断与处理)
7. [断线重连策略](#7-断线重连策略)
8. [最佳实践总结](#8-最佳实践总结)

---

## 1. 💔 为什么需要心跳机制


### 1.1 网络连接的"假死"问题


> 💡 **通俗解释**：想象你和朋友打电话，突然没声音了，你不知道是他挂了电话还是信号断了，这就是"假死"状态。

**常见的连接断开场景**：
```
用户场景                    实际情况
────────────────────────────────────────
🏠 用户关闭浏览器标签页      → 连接正常断开
📱 手机切换到后台           → 连接可能断开
🚇 进入地铁没信号           → 网络中断
🔌 路由器重启               → 网络设备重置
💻 电脑休眠                 → 系统暂停连接
```

### 1.2 WebSocket连接的特殊性


**TCP连接的"看不见"特点**：
- **单纯的TCP连接**：就像两个人拿着电话话筒，但不说话
- **无声状态**：如果双方都不主动发消息，就不知道对方是否还在
- **系统层面**：操作系统可能认为连接还是好的，实际上网络已经断了

```
正常状态 vs 假死状态对比：

正常连接：
客户端 ←─→ 服务端  ✅ 数据能正常传输

假死连接：
客户端 ←─✗─→ 服务端  ❌ 看似连接，实际断开
      (网络中断但双方不知道)
```

### 1.3 不使用心跳的问题


> ⚠️ **现实场景**：在线聊天室中，用户网络断了但服务器还认为他在线，继续给他推送消息，白白浪费资源。

**具体问题表现**：

| 问题场景 | **影响** | **用户体验** |
|---------|----------|-------------|
| 🔇 **静默断线** | `服务器继续推送消息` | `用户收不到，以为系统坏了` |
| 📱 **移动设备休眠** | `连接假死，消息丢失` | `重新打开APP没有新消息` |
| 🌐 **网络切换** | `旧连接没释放，新连接建不上` | `页面卡死，需要刷新` |
| 💾 **服务器资源浪费** | `维护大量无效连接` | `系统变慢，影响其他用户` |

---

## 2. 💓 心跳检测基本原理


### 2.1 什么是心跳检测


> 📖 **概念**：心跳检测就像医生听心跳一样，定期检查连接是否还"活着"。

**心跳机制的核心思想**：
```
客户端每隔一段时间主动发个"我还在"的消息
服务端收到后回复"我知道了"
如果长时间没有回复，就认为连接断了
```

### 2.2 心跳检测工作流程


```
心跳检测完整流程：

客户端                           服务端
   |                               |
   |──[1] 定时发送PING────────────→|
   |                            检查连接
   |                               |
   |←─────────[2] 回复PONG─────────|
   |                               |
   |──[3] 收到PONG，连接正常───→继续通信
   |                               |
   |──[4] 超时没收到PONG──────→连接断开
   |                               |
   |──[5] 执行重连逻辑        服务端清理资源
```

### 2.3 心跳检测的核心要素


**🔸 心跳间隔时间**：
- **太短**：浪费带宽，增加服务器负担
- **太长**：发现断线太慢，用户体验差
- **建议**：30秒-60秒之间

**🔸 超时等待时间**：
- **定义**：发送心跳后最多等多久
- **建议**：5-10秒
- **超时处理**：认为连接断开，开始重连

**🔸 重连机制**：
- **立即重连**：可能因为同样的网络问题继续失败
- **延迟重连**：给网络一点恢复时间
- **重连限制**：避免无限重连消耗资源

---

## 3. 📤 客户端心跳实现


### 3.1 基本心跳发送逻辑


> 🔧 **实践**：客户端就像一个负责任的员工，定时向老板汇报"我还在工作"。

```javascript
class WebSocketClient {
    constructor(url) {
        this.url = url;
        this.ws = null;
        this.heartbeatTimer = null; // 心跳定时器
        this.heartbeatInterval = 30000; // 30秒发一次心跳
        this.heartbeatTimeout = 10000; // 10秒等待超时
        this.isHeartbeatAlive = true; // 心跳是否正常
    }
    
    // 连接WebSocket
    connect() {
        this.ws = new WebSocket(this.url);
        
        this.ws.onopen = () => {
            console.log('连接成功，开始心跳检测');
            this.startHeartbeat(); // 开启心跳
        };
        
        this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
        };
        
        this.ws.onclose = () => {
            console.log('连接断开，停止心跳');
            this.stopHeartbeat();
        };
    }
}
```

### 3.2 心跳定时发送机制


```javascript
// 开启心跳检测
startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
        this.sendHeartbeat();
    }, this.heartbeatInterval);
}

// 发送心跳消息
sendHeartbeat() {
    if (this.ws.readyState === WebSocket.OPEN) {
        console.log('💓 发送心跳检测');
        
        // 标记等待心跳回复
        this.isHeartbeatAlive = false;
        
        // 发送ping消息
        this.ws.send(JSON.stringify({
            type: 'ping',
            timestamp: Date.now()
        }));
        
        // 设置超时检测
        this.checkHeartbeatTimeout();
    }
}

// 检查心跳超时
checkHeartbeatTimeout() {
    setTimeout(() => {
        if (!this.isHeartbeatAlive) {
            console.log('💔 心跳超时，连接可能断开');
            this.handleConnectionLost();
        }
    }, this.heartbeatTimeout);
}
```

### 3.3 心跳间隔时间设置策略


> 💡 **经验**：就像体检一样，身体好的人可以一年检查一次，有问题的需要频繁检查。

**不同场景的心跳间隔**：

| 应用场景 | **推荐间隔** | **原因** |
|---------|-------------|---------|
| 🎮 **在线游戏** | `10-15秒` | `实时性要求高，需要快速发现断线` |
| 💬 **即时聊天** | `30秒` | `平衡实时性和资源消耗` |
| 📈 **股票行情** | `15-20秒` | `数据重要，但更新频率适中` |
| 📰 **新闻推送** | `60秒` | `实时性要求不高` |
| 🏢 **企业内部系统** | `45秒` | `稳定网络环境，间隔可以长一些` |

```javascript
// 动态调整心跳间隔
class AdaptiveHeartbeat {
    constructor() {
        this.failCount = 0; // 失败次数
        this.baseInterval = 30000; // 基础间隔30秒
    }
    
    // 根据网络状况调整间隔
    adjustInterval() {
        if (this.failCount === 0) {
            return this.baseInterval; // 网络正常
        } else if (this.failCount < 3) {
            return this.baseInterval * 0.5; // 网络不稳定，加快检测
        } else {
            return this.baseInterval * 2; // 网络很差，减少频率
        }
    }
}
```

---

## 4. 📥 服务端心跳响应


### 4.1 服务端pong消息处理


> 🔧 **实践**：服务端就像一个接电话的客服，听到客户说"你好"就回复"你好，我在"。

```javascript
// Node.js WebSocket服务端示例
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
    console.log('新客户端连接');
    
    // 为每个连接设置心跳状态
    ws.isAlive = true;
    ws.lastHeartbeat = Date.now();
    
    ws.on('message', (data) => {
        try {
            const message = JSON.parse(data);
            
            if (message.type === 'ping') {
                // 收到客户端心跳，立即回复pong
                console.log('💓 收到心跳，回复pong');
                
                ws.send(JSON.stringify({
                    type: 'pong',
                    timestamp: Date.now(),
                    serverTime: new Date().toISOString()
                }));
                
                // 更新连接状态
                ws.isAlive = true;
                ws.lastHeartbeat = Date.now();
            } else {
                // 处理其他业务消息
                handleBusinessMessage(ws, message);
            }
        } catch (error) {
            console.log('消息格式错误:', error);
        }
    });
});
```

### 4.2 服务端心跳超时检测


```javascript
// 定期检查所有连接的心跳状态
function checkClientHeartbeat() {
    const now = Date.now();
    const timeoutLimit = 90000; // 90秒超时
    
    wss.clients.forEach((ws) => {
        if (ws.readyState === WebSocket.OPEN) {
            const timeSinceLastHeartbeat = now - ws.lastHeartbeat;
            
            if (timeSinceLastHeartbeat > timeoutLimit) {
                console.log('💔 客户端心跳超时，主动断开连接');
                ws.isAlive = false;
                ws.terminate(); // 强制关闭连接
            }
        }
    });
}

// 每30秒检查一次所有连接
setInterval(checkClientHeartbeat, 30000);
```

### 4.3 服务端资源清理


> ⚠️ **重要**：就像清理房间一样，要及时清理断开的连接，否则会堆积太多垃圾。

```javascript
// 连接断开时的清理工作
ws.on('close', () => {
    console.log('客户端断开连接，清理资源');
    
    // 清理用户状态
    removeUserFromOnlineList(ws.userId);
    
    // 通知其他客户端用户下线
    broadcastUserOffline(ws.userId);
    
    // 清理相关定时器
    if (ws.heartbeatChecker) {
        clearInterval(ws.heartbeatChecker);
    }
});

// 优雅关闭服务时清理所有连接
process.on('SIGTERM', () => {
    console.log('服务器关闭，断开所有连接');
    
    wss.clients.forEach((ws) => {
        if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'server_shutdown',
                message: '服务器维护中，请稍后重连'
            }));
            ws.close();
        }
    });
});
```

---

## 5. 🏓 Ping/Pong标准机制


### 5.1 WebSocket标准的Ping/Pong


> 📖 **概念**：WebSocket协议本身就内置了ping/pong机制，就像内置的"验证码"系统。

**协议层面的Ping/Pong**：
```
WebSocket帧类型：
┌─────────────┬──────────────────┐
│  帧类型      │  用途            │
├─────────────┼──────────────────┤
│  0x8        │  关闭帧          │
│  0x9        │  Ping帧          │
│  0xA        │  Pong帧          │  
│  0x1        │  文本帧          │
│  0x2        │  二进制帧        │
└─────────────┴──────────────────┘
```

### 5.2 浏览器自动Ping/Pong处理


```javascript
// 浏览器会自动处理ping/pong帧，我们通常感知不到
const ws = new WebSocket('ws://localhost:8080');

// 这些事件可以监听连接状态变化
ws.addEventListener('open', () => {
    console.log('连接打开');
    // 浏览器会自动处理服务端发来的ping帧
    // 并自动回复pong帧
});

ws.addEventListener('error', (error) => {
    console.log('连接错误:', error);
    // 如果ping/pong失败，可能触发错误事件
});
```

### 5.3 应用层心跳 vs 协议层心跳


> 💡 **区别**：就像快递一样，协议层心跳检查"路通不通"，应用层心跳检查"人在不在"。

**两种心跳机制对比**：

| 特性 | **协议层Ping/Pong** | **应用层心跳** |
|------|-------------------|---------------|
| 📡 **检测内容** | `网络连接是否通畅` | `应用程序是否正常运行` |
| 🔧 **实现方式** | `WebSocket协议自带` | `自己编写JSON消息` |
| 🎯 **检测精度** | `只知道连接通断` | `可以检测业务逻辑状态` |
| 💻 **浏览器支持** | `自动处理，不可控` | `完全可控，可自定义` |
| 🚀 **性能开销** | `较小，二进制帧` | `较大，JSON文本` |

```javascript
// 应用层心跳：更灵活，可以携带业务信息
const heartbeatMessage = {
    type: 'ping',
    userId: '12345',
    timestamp: Date.now(),
    extra: {
        batteryLevel: '80%',
        networkType: 'wifi'
    }
};

// 协议层心跳：浏览器自动处理，开发者无法直接控制
// 但可以通过某些方式间接触发
ws.ping(); // 这个方法在浏览器中通常不可用
```

---

## 6. 🔍 连接状态判断与处理


### 6.1 连接状态的准确判断


> 🎯 **关键**：就像判断一个人是否真的在听你说话，不只是看他点头，还要看他的回应。

**WebSocket连接状态详解**：
```javascript
// WebSocket状态常量
const CONNECTION_STATE = {
    CONNECTING: 0,  // 正在连接
    OPEN: 1,        // 连接已打开
    CLOSING: 2,     // 正在关闭
    CLOSED: 3       // 已关闭
};

// 检查连接的真实状态
function checkRealConnectionState(ws) {
    console.log(`连接状态码: ${ws.readyState}`);
    
    switch(ws.readyState) {
        case WebSocket.CONNECTING:
            return '🔄 正在连接中...';
        case WebSocket.OPEN:
            return '✅ 连接已打开';
        case WebSocket.CLOSING:
            return '⏳ 正在关闭连接...';
        case WebSocket.CLOSED:
            return '❌ 连接已关闭';
        default:
            return '❓ 未知状态';
    }
}
```

### 6.2 连接活跃状态判断


```javascript
class ConnectionManager {
    constructor(ws) {
        this.ws = ws;
        this.lastActivity = Date.now();
        this.isReallyConnected = false;
    }
    
    // 综合判断连接是否真正可用
    isConnectionHealthy() {
        const now = Date.now();
        const timeSinceLastActivity = now - this.lastActivity;
        
        // 多重检查
        const checks = {
            // 1. WebSocket状态检查
            stateOK: this.ws.readyState === WebSocket.OPEN,
            
            // 2. 最近是否有活动
            recentActivity: timeSinceLastActivity < 120000, // 2分钟内
            
            // 3. 心跳是否正常
            heartbeatOK: this.isReallyConnected,
            
            // 4. 网络状态检查（如果支持）
            networkOnline: navigator.onLine !== false
        };
        
        console.log('连接健康度检查:', checks);
        
        // 所有检查都通过才认为连接健康
        return Object.values(checks).every(check => check === true);
    }
    
    // 更新活动时间
    updateActivity() {
        this.lastActivity = Date.now();
        this.isReallyConnected = true;
    }
}
```

### 6.3 连接中断的处理策略


> 🔧 **实践**：当发现连接有问题时，要像医生一样，先诊断问题，再对症下药。

```javascript
class ConnectionHandler {
    constructor() {
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000; // 初始延迟1秒
    }
    
    // 连接中断时的处理流程
    handleConnectionLost() {
        console.log('💔 检测到连接中断');
        
        // 1. 立即停止发送新消息
        this.stopSending();
        
        // 2. 清理定时器
        this.cleanupTimers();
        
        // 3. 通知用户连接状态
        this.notifyConnectionLost();
        
        // 4. 开始重连流程
        this.startReconnect();
    }
    
    // 停止发送消息
    stopSending() {
        this.canSend = false;
        console.log('🚫 暂停发送消息');
    }
    
    // 通知用户连接状态
    notifyConnectionLost() {
        // 显示用户友好的提示
        this.showConnectionStatus('⚠️ 连接中断，正在重连...');
        
        // 可以显示离线模式提示
        this.enableOfflineMode();
    }
    
    showConnectionStatus(message) {
        // 实际项目中可以是Toast提示或状态栏
        console.log(`状态提示: ${message}`);
        
        // 示例：更新页面状态
        const statusElement = document.getElementById('connection-status');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.className = 'status-warning';
        }
    }
}
```

---

## 7. 🔄 断线重连策略


### 7.1 简易重连逻辑实现


> 💡 **策略**：重连就像敲门一样，第一次没人开门就等一下再敲，连续敲太多次就放弃。

```javascript
class ReconnectManager {
    constructor(url) {
        this.url = url;
        this.reconnectAttempts = 0;
        this.maxAttempts = 5;
        this.baseDelay = 1000; // 基础延迟1秒
        this.maxDelay = 30000; // 最大延迟30秒
        this.isReconnecting = false;
    }
    
    // 开始重连流程
    async startReconnect() {
        if (this.isReconnecting) {
            console.log('已经在重连中，跳过');
            return;
        }
        
        this.isReconnecting = true;
        
        while (this.reconnectAttempts < this.maxAttempts) {
            this.reconnectAttempts++;
            
            const delay = this.calculateDelay();
            console.log(`🔄 第${this.reconnectAttempts}次重连，${delay/1000}秒后开始...`);
            
            // 等待指定时间
            await this.sleep(delay);
            
            try {
                const success = await this.attemptReconnect();
                if (success) {
                    console.log('✅ 重连成功！');
                    this.resetReconnectState();
                    return;
                }
            } catch (error) {
                console.log(`❌ 第${this.reconnectAttempts}次重连失败:`, error.message);
            }
        }
        
        // 所有重连尝试都失败
        console.log('💔 重连失败，请检查网络后手动刷新页面');
        this.handleReconnectFailed();
    }
    
    // 计算延迟时间（指数退避算法）
    calculateDelay() {
        // 延迟时间：1秒、2秒、4秒、8秒、16秒...最多30秒
        const exponentialDelay = this.baseDelay * Math.pow(2, this.reconnectAttempts - 1);
        return Math.min(exponentialDelay, this.maxDelay);
    }
    
    // 等待指定时间
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // 尝试重新连接
    attemptReconnect() {
        return new Promise((resolve, reject) => {
            const ws = new WebSocket(this.url);
            
            const timeout = setTimeout(() => {
                ws.close();
                reject(new Error('连接超时'));
            }, 5000); // 5秒连接超时
            
            ws.onopen = () => {
                clearTimeout(timeout);
                this.ws = ws;
                resolve(true);
            };
            
            ws.onerror = (error) => {
                clearTimeout(timeout);
                reject(error);
            };
        });
    }
}
```

### 7.2 智能重连策略


```javascript
class SmartReconnect {
    constructor() {
        this.networkType = this.detectNetworkType();
        this.reconnectStrategy = this.getStrategyByNetwork();
    }
    
    // 检测网络类型
    detectNetworkType() {
        if ('connection' in navigator) {
            return navigator.connection.effectiveType; // '4g', '3g', '2g', 'slow-2g'
        }
        return 'unknown';
    }
    
    // 根据网络类型选择重连策略
    getStrategyByNetwork() {
        const strategies = {
            '4g': {
                maxAttempts: 10,
                baseDelay: 500,
                maxDelay: 5000
            },
            '3g': {
                maxAttempts: 8,
                baseDelay: 1000,
                maxDelay: 10000
            },
            '2g': {
                maxAttempts: 5,
                baseDelay: 2000,
                maxDelay: 20000
            },
            'slow-2g': {
                maxAttempts: 3,
                baseDelay: 5000,
                maxDelay: 30000
            },
            'unknown': {
                maxAttempts: 5,
                baseDelay: 1000,
                maxDelay: 15000
            }
        };
        
        return strategies[this.networkType] || strategies['unknown'];
    }
    
    // 监听网络状态变化
    setupNetworkMonitoring() {
        window.addEventListener('online', () => {
            console.log('🌐 网络恢复，立即尝试重连');
            this.reconnectAttempts = 0; // 重置重连次数
            this.startReconnect();
        });
        
        window.addEventListener('offline', () => {
            console.log('📵 网络断开，停止重连');
            this.isReconnecting = false;
        });
    }
}
```

### 7.3 重连失败的优雅处理


> ⚠️ **用户体验**：当所有重连尝试都失败时，要给用户明确的指引，而不是让他们干等。

```javascript
// 重连完全失败时的处理
handleReconnectFailed() {
    this.isReconnecting = false;
    
    // 显示用户友好的错误信息
    this.showReconnectFailedDialog();
    
    // 切换到离线模式
    this.enableOfflineMode();
    
    // 提供手动重连选项
    this.addManualReconnectButton();
}

showReconnectFailedDialog() {
    const message = `
    🚫 连接已断开
    
    可能的原因：
    • 网络连接不稳定
    • 服务器维护中
    • 防火墙阻止连接
    
    建议操作：
    1. 检查网络连接
    2. 刷新页面重试
    3. 联系技术支持
    `;
    
    console.log(message);
    
    // 实际项目中可以用模态框显示
    alert('连接失败，请检查网络后刷新页面');
}

// 启用离线模式
enableOfflineMode() {
    console.log('🔌 启用离线模式');
    
    // 禁用需要网络的功能
    this.disableNetworkFeatures();
    
    // 显示离线提示
    this.showOfflineBanner();
    
    // 缓存用户操作，等恢复连接后同步
    this.enableOfflineCache();
}

// 添加手动重连按钮
addManualReconnectButton() {
    const button = document.createElement('button');
    button.textContent = '🔄 手动重连';
    button.onclick = () => {
        this.reconnectAttempts = 0; // 重置计数
        this.startReconnect();
    };
    
    // 添加到页面适当位置
    document.body.appendChild(button);
}
```

---

## 8. 🎯 最佳实践总结


### 8.1 心跳机制核心要点


> 📋 **检查清单**：确保你的WebSocket心跳机制包含这些要点

<details>
<summary>🔍 点击展开完整检查清单</summary>

**✅ 客户端实现检查**：
- [ ] 连接成功后立即启动心跳定时器
- [ ] 心跳间隔设置合理（30-60秒）
- [ ] 心跳超时检测机制（5-10秒）
- [ ] 心跳失败时停止发送业务消息
- [ ] 连接断开时清理心跳定时器

**✅ 服务端实现检查**：
- [ ] 正确响应客户端心跳请求
- [ ] 定期检查客户端心跳超时
- [ ] 超时客户端及时清理资源
- [ ] 服务关闭时优雅断开所有连接

**✅ 重连机制检查**：
- [ ] 指数退避算法避免频繁重连
- [ ] 重连次数限制防止无限重连
- [ ] 网络状态监听自动触发重连
- [ ] 重连失败时用户友好提示

</details>

### 8.2 不同场景的心跳配置建议


| 应用类型 | **心跳间隔** | **超时时间** | **重连次数** | **特殊配置** |
|---------|-------------|-------------|-------------|-------------|
| 🎮 **实时游戏** | `15秒` | `5秒` | `10次` | `快速重连，网络优化优先` |
| 💬 **即时通讯** | `30秒` | `10秒` | `8次` | `离线消息缓存` |
| 📈 **金融行情** | `20秒` | `8秒` | `15次` | `数据完整性校验` |
| 🏢 **企业应用** | `45秒` | `15秒` | `5次` | `错误日志详细记录` |
| 📱 **移动应用** | `60秒` | `20秒` | `6次` | `省电模式适配` |

### 8.3 性能优化建议


**🚀 减少资源消耗**：
```javascript
// 优化心跳消息大小
const optimizedHeartbeat = {
    t: 'p', // type: ping (使用短字段名)
    ts: Date.now() // timestamp (只发送必要信息)
};

// 避免在心跳中携带大量数据
// ❌ 错误示例：心跳消息太大
const badHeartbeat = {
    type: 'ping',
    timestamp: Date.now(),
    userInfo: { /* 大量用户数据 */ },
    systemInfo: { /* 大量系统信息 */ }
};

// ✅ 正确示例：心跳消息精简
const goodHeartbeat = {
    type: 'ping',
    timestamp: Date.now()
};
```

**💾 内存管理**：
```javascript
// 正确清理定时器
class WebSocketManager {
    disconnect() {
        // 清理心跳定时器
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
        
        // 清理超时检测定时器
        if (this.timeoutTimer) {
            clearTimeout(this.timeoutTimer);
            this.timeoutTimer = null;
        }
        
        // 关闭WebSocket连接
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    }
}
```

### 8.4 常见错误避免


> ⚠️ **注意**：这些是新手最容易犯的错误，一定要避免！

**❌ 常见错误示例**：

| 错误类型 | **错误做法** | **正确做法** |
|---------|-------------|-------------|
| 🔄 **无限重连** | `没有重连次数限制` | `设置最大重连次数` |
| ⏰ **心跳过频** | `每秒都发心跳` | `30-60秒发一次` |
| 💾 **资源泄露** | `断开时不清理定时器` | `及时清理所有定时器` |
| 🔍 **状态判断** | `只看readyState` | `结合心跳响应判断` |
| 👤 **用户体验** | `静默失败不提示` | `友好的状态提示` |

### 8.5 监控与调试


```javascript
// 心跳状态监控
class HeartbeatMonitor {
    constructor() {
        this.stats = {
            totalPings: 0,
            successfulPongs: 0,
            failedPings: 0,
            avgResponseTime: 0
        };
    }
    
    // 记录心跳统计
    recordHeartbeat(success, responseTime = 0) {
        this.stats.totalPings++;
        
        if (success) {
            this.stats.successfulPongs++;
            this.updateAvgResponseTime(responseTime);
        } else {
            this.stats.failedPings++;
        }
        
        // 输出统计信息
        this.logStats();
    }
    
    // 获取连接质量评分
    getConnectionQuality() {
        const successRate = this.stats.successfulPongs / this.stats.totalPings;
        const avgTime = this.stats.avgResponseTime;
        
        if (successRate > 0.95 && avgTime < 1000) return '🟢 优秀';
        if (successRate > 0.85 && avgTime < 3000) return '🟡 良好';
        if (successRate > 0.70) return '🟠 一般';
        return '🔴 较差';
    }
}
```

---

## 🎯 核心要点记忆


**心跳检测三要素**：
1. **📤 定时发送** - 客户端主动发ping
2. **📥 及时回复** - 服务端立即回pong  
3. **⏰ 超时处理** - 没收到回复就重连

**重连策略三原则**：
1. **⏳ 延迟重连** - 不要立即重连
2. **🔢 限制次数** - 避免无限重连
3. **👤 用户友好** - 失败时给出明确提示

**性能优化三重点**：
1. **💾 资源清理** - 及时清理定时器和连接
2. **📊 消息精简** - 心跳消息尽量小
3. **🎯 智能间隔** - 根据场景调整心跳频率