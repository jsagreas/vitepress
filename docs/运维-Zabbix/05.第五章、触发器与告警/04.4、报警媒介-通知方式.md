---
title: 4、报警媒介-通知方式
---
## 📚 目录

1. [报警媒介基本概念](#1-报警媒介基本概念)
2. [邮件通知配置](#2-邮件通知配置)
3. [短信网关集成](#3-短信网关集成)
4. [微信企业号集成](#4-微信企业号集成)
5. [钉钉机器人集成](#5-钉钉机器人集成)
6. [Slack集成配置](#6-slack集成配置)
7. [Webhook自定义通知](#7-webhook自定义通知)
8. [脚本执行通知](#8-脚本执行通知)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔔 报警媒介基本概念


### 1.1 什么是报警媒介


> **💡 通俗理解**
> 报警媒介就像是"送信的邮递员"，当Zabbix发现问题时，需要通过不同的"邮递员"把消息送到你手里

**📋 核心定义**
```
报警媒介（Alert Media）：Zabbix向外发送通知的渠道和方式
作用：将监控告警信息传递给相关负责人
目标：确保问题能及时被发现和处理
```

### 1.2 报警媒介的工作流程


```
问题发生流程：
监控项异常 → 触发器激活 → 动作执行 → 媒介类型选择 → 发送通知 → 用户接收

具体示例：
服务器CPU过高 → 触发器报警 → 执行通知动作 → 选择邮件媒介 → 发送邮件 → 运维人员收到
```

### 1.3 常见媒介类型对比


| 媒介类型 | **即时性** | **可靠性** | **成本** | **适用场景** |
|---------|-----------|-----------|---------|-------------|
| 📧 **邮件** | `中等` | `高` | `免费` | `详细报告、非紧急通知` |
| 📱 **短信** | `很高` | `很高` | `付费` | `紧急故障、关键告警` |
| 💬 **微信/钉钉** | `高` | `高` | `免费` | `团队协作、日常通知` |
| 🔗 **Webhook** | `很高` | `中等` | `免费` | `系统集成、自动化处理` |

---

## 2. 📧 邮件通知配置


### 2.1 邮件媒介基本原理


**🔸 邮件发送原理**
```
Zabbix服务器 → SMTP服务器 → 邮箱服务商 → 用户邮箱

就像寄信过程：
写信（Zabbix生成通知） → 投递邮筒（SMTP发送） → 邮局处理 → 收信人收到
```

### 2.2 配置SMTP邮件服务


**📋 配置步骤：**

1. **进入媒介类型配置**
   - 管理 → 媒介类型 → Email

2. **基本SMTP配置**
```
SMTP服务器：smtp.gmail.com
SMTP端口：587（TLS）或 465（SSL）
用户名：your-email@gmail.com  
密码：应用专用密码（不是登录密码）
发件人：zabbix@company.com
```

3. **常见邮箱服务器配置**

| 邮箱服务商 | **SMTP服务器** | **端口** | **加密方式** |
|-----------|---------------|---------|-------------|
| **Gmail** | `smtp.gmail.com` | `587` | `TLS` |
| **QQ邮箱** | `smtp.qq.com` | `587` | `TLS` |
| **163邮箱** | `smtp.163.com` | `994` | `SSL` |
| **企业邮箱** | `smtp.exmail.qq.com` | `587` | `TLS` |

### 2.3 邮件模板自定义


**📝 邮件内容模板**
```
主题模板：
{ALERT.SEVERITY}: {HOST.NAME} - {TRIGGER.NAME}

内容模板：
问题详情：{TRIGGER.NAME}
主机名称：{HOST.NAME}
问题严重性：{ALERT.SEVERITY}
发生时间：{ALERT.DATE} {ALERT.TIME}
当前值：{ITEM.LASTVALUE}
问题描述：{TRIGGER.DESCRIPTION}
```

> **⚠️ 注意事项**
> Gmail等邮箱需要开启"两步验证"并生成"应用专用密码"，不能直接使用登录密码

---

## 3. 📱 短信网关集成


### 3.1 短信通知的重要性


**🎯 为什么需要短信通知**
- **即时性强**：短信几乎瞬间到达
- **覆盖面广**：不依赖网络，任何手机都能收到
- **重要性高**：适合紧急故障通知

### 3.2 短信网关选择


**🔸 常见短信服务商**
- **阿里云短信**：价格便宜，稳定性好
- **腾讯云短信**：集成简单，速度快
- **华为云短信**：企业级服务
- **亿美短信**：老牌服务商

### 3.3 短信网关配置实例


**📋 以阿里云短信为例：**

1. **申请短信服务**
   - 开通阿里云短信服务
   - 申请短信模板和签名
   - 获取AccessKey ID和Secret

2. **Zabbix脚本配置**
```bash
#!/bin/bash
# 阿里云短信发送脚本

PHONE=$1      # 手机号
SUBJECT=$2    # 短信主题  
MESSAGE=$3    # 短信内容

# 调用阿里云短信API
python3 /usr/local/zabbix/scripts/send_sms.py \
  --phone "$PHONE" \
  --message "$MESSAGE"
```

3. **Python发送脚本示例**
```python
# 简化的短信发送示例
import requests

def send_sms(phone, message):
    # 调用短信服务API
    url = "https://dysmsapi.aliyuncs.com/"
    params = {
        'PhoneNumbers': phone,
        'TemplateCode': 'SMS_123456789',
        'TemplateParam': '{"content":"' + message + '"}'
    }
    response = requests.post(url, params=params)
    return response.status_code == 200
```

---

## 4. 💬 微信企业号集成


### 4.1 微信企业号的优势


**🔸 为什么选择微信企业号**
- **零成本**：企业号免费使用
- **高到达率**：微信打开率很高
- **支持富文本**：可以发送图片、链接
- **群组通知**：支持部门群发

### 4.2 微信企业号配置步骤


**📋 配置流程：**

1. **注册企业微信**
   - 访问work.weixin.qq.com
   - 注册企业账号
   - 创建应用获取配置信息

2. **获取关键信息**
```
企业ID（CorpId）：在"我的企业"中查看
应用Secret：在"应用管理"中查看  
AgentId：应用的唯一标识
部门ID：接收消息的部门编号
```

3. **Zabbix配置微信媒介**
```bash
#!/bin/bash
# 微信企业号发送脚本

USER=$1       # 用户ID
SUBJECT=$2    # 消息标题
MESSAGE=$3    # 消息内容

# 调用微信发送脚本
python3 /usr/local/zabbix/scripts/wechat_send.py \
  --user "$USER" \
  --title "$SUBJECT" \
  --content "$MESSAGE"
```

### 4.3 微信发送脚本实现


```python
# 微信企业号发送脚本示例
import requests
import json

class WeChatBot:
    def __init__(self, corpid, secret, agentid):
        self.corpid = corpid
        self.secret = secret  
        self.agentid = agentid
        self.token = self.get_token()
    
    def get_token(self):
        """获取访问token"""
        url = f"https://qyapi.weixin.qq.com/cgi-bin/gettoken"
        params = {'corpid': self.corpid, 'corpsecret': self.secret}
        response = requests.get(url, params=params)
        return response.json()['access_token']
    
    def send_message(self, user, message):
        """发送文本消息"""
        url = f"https://qyapi.weixin.qq.com/cgi-bin/message/send"
        data = {
            'touser': user,
            'msgtype': 'text',
            'agentid': self.agentid,
            'text': {'content': message}
        }
        requests.post(url, params={'access_token': self.token}, 
                     json=data)
```

---

## 5. 🤖 钉钉机器人集成


### 5.1 钉钉机器人的特点


**🔸 钉钉机器人优势**
- **简单易用**：只需要一个Webhook地址
- **支持Markdown**：可以发送格式化消息
- **@功能**：可以@特定人员
- **免费使用**：企业内部免费

### 5.2 创建钉钉机器人


**📋 操作步骤：**

1. **在钉钉群中添加机器人**
   - 群设置 → 智能群助手 → 添加机器人
   - 选择"自定义"机器人
   - 设置安全设置（关键词或IP白名单）

2. **获取Webhook地址**
```
示例地址：
https://oapi.dingtalk.com/robot/send?access_token=xxxxx

安全设置：
- 关键词：zabbix、告警、监控
- IP地址：Zabbix服务器IP
- 加签：使用密钥签名（推荐）
```

### 5.3 钉钉消息发送脚本


```python
# 钉钉机器人发送脚本
import requests
import json
import time
import hmac
import hashlib
import base64
import urllib.parse

class DingTalkBot:
    def __init__(self, webhook_url, secret=None):
        self.webhook_url = webhook_url
        self.secret = secret
    
    def send_text_message(self, message, at_mobiles=None):
        """发送文本消息"""
        # 如果配置了加签，生成签名
        if self.secret:
            timestamp = str(round(time.time() * 1000))
            sign = self._generate_sign(timestamp)
            url = f"{self.webhook_url}&timestamp={timestamp}&sign={sign}"
        else:
            url = self.webhook_url
        
        data = {
            "msgtype": "text",
            "text": {"content": message},
            "at": {"atMobiles": at_mobiles or []}
        }
        
        response = requests.post(url, json=data)
        return response.json()
    
    def _generate_sign(self, timestamp):
        """生成签名"""
        string_to_sign = f"{timestamp}\n{self.secret}"
        hmac_code = hmac.new(
            self.secret.encode('utf-8'),
            string_to_sign.encode('utf-8'),
            digestmod=hashlib.sha256
        ).digest()
        sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
        return sign
```

### 5.4 钉钉Markdown消息模板


```python
def send_alert_markdown(self, alert_data):
    """发送告警的Markdown消息"""
    message = f"""
# Zabbix监控告警
---
**主机名称：** {alert_data['hostname']}
**告警级别：** {alert_data['severity']}
**告警内容：** {alert_data['trigger_name']}
**当前值：** {alert_data['current_value']}
**告警时间：** {alert_data['alert_time']}

> 请相关人员及时处理！
    """
    
    data = {
        "msgtype": "markdown",
        "markdown": {
            "title": "Zabbix监控告警",
            "text": message
        }
    }
    
    requests.post(self.webhook_url, json=data)
```

---

## 6. 🔗 Slack集成配置


### 6.1 Slack集成概述


**🔸 Slack的优势**
- **国际化工具**：适合跨国团队
- **丰富的集成**：支持各种第三方服务
- **强大的搜索**：历史消息搜索功能
- **工作流自动化**：可以触发其他动作

### 6.2 Slack Webhook配置


**📋 配置步骤：**

1. **创建Slack应用**
   - 访问api.slack.com/apps
   - 创建新应用
   - 启用Incoming Webhooks

2. **获取Webhook URL**
```
示例URL：
https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX
```

3. **Slack发送脚本**
```python
import requests
import json

def send_slack_message(webhook_url, message, channel=None):
    """发送Slack消息"""
    data = {
        "text": message,
        "username": "Zabbix Bot",
        "icon_emoji": ":warning:"
    }
    
    if channel:
        data["channel"] = channel
    
    response = requests.post(webhook_url, json=data)
    return response.status_code == 200
```

### 6.3 Slack富文本消息


```python
def send_slack_alert(webhook_url, alert_info):
    """发送格式化的告警消息"""
    
    # 根据严重程度设置颜色
    color_map = {
        "Critical": "danger",    # 红色
        "High": "warning",       # 黄色
        "Average": "good",       # 绿色
        "Information": "#36a64f" # 自定义绿色
    }
    
    attachment = {
        "color": color_map.get(alert_info['severity'], "warning"),
        "title": f"Zabbix Alert: {alert_info['trigger_name']}",
        "fields": [
            {
                "title": "Host",
                "value": alert_info['hostname'],
                "short": True
            },
            {
                "title": "Severity", 
                "value": alert_info['severity'],
                "short": True
            },
            {
                "title": "Current Value",
                "value": alert_info['current_value'],
                "short": False
            }
        ],
        "footer": "Zabbix Monitoring",
        "ts": int(time.time())
    }
    
    data = {
        "text": "New monitoring alert detected!",
        "attachments": [attachment]
    }
    
    requests.post(webhook_url, json=data)
```

---

## 7. 🔧 Webhook自定义通知


### 7.1 Webhook通知原理


**🔸 什么是Webhook**
```
简单理解：Webhook就像"自动回电话"
当Zabbix发现问题时，自动向指定网址发送数据
接收方可以根据这些数据做任何想做的事情
```

### 7.2 Webhook配置方法


**📋 Zabbix内置Webhook配置：**

1. **创建媒介类型**
   - 管理 → 媒介类型 → 创建媒介类型
   - 类型：Webhook
   - 脚本名：webhook
   - 参数：配置URL和认证信息

2. **Webhook参数配置**
```javascript
// Webhook脚本示例
var params = JSON.parse(value);
var request = new HttpRequest();

// 设置请求头
request.addHeader('Content-Type: application/json');
request.addHeader('Authorization: Bearer YOUR_TOKEN');

// 构造发送数据
var data = {
    "alert_type": "zabbix",
    "hostname": params.hostname,
    "severity": params.severity,
    "message": params.message,
    "timestamp": Date.now()
};

// 发送POST请求
var response = request.post(params.webhook_url, JSON.stringify(data));

return response;
```

### 7.3 自定义Webhook接收端


```python
# Flask接收Webhook示例
from flask import Flask, request, jsonify
import json

app = Flask(__name__)

@app.route('/webhook/zabbix', methods=['POST'])
def receive_zabbix_alert():
    """接收Zabbix Webhook通知"""
    try:
        # 获取JSON数据
        alert_data = request.get_json()
        
        # 处理告警数据
        process_alert(alert_data)
        
        return jsonify({"status": "success"}), 200
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def process_alert(alert_data):
    """处理告警数据"""
    # 可以在这里做任何事情：
    # - 写入数据库
    # - 发送到其他系统
    # - 触发自动化脚本
    # - 集成第三方服务
    
    print(f"收到告警: {alert_data['hostname']} - {alert_data['message']}")
    
    # 示例：严重告警自动创建工单
    if alert_data['severity'] == 'Critical':
        create_ticket(alert_data)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

---

## 8. 📜 脚本执行通知


### 8.1 脚本通知的灵活性


**🔸 脚本通知的优势**
- **完全自定义**：可以实现任何想要的功能
- **本地处理**：不依赖外部服务
- **集成能力强**：可以调用系统命令或其他程序
- **成本为零**：无需第三方服务费用

### 8.2 脚本通知配置


**📋 配置步骤：**

1. **脚本存放位置**
```bash
# Zabbix脚本目录（可在配置文件中查看）
默认位置：/usr/lib/zabbix/alertscripts/

# 脚本权限设置
chmod +x /usr/lib/zabbix/alertscripts/custom_alert.sh
chown zabbix:zabbix /usr/lib/zabbix/alertscripts/custom_alert.sh
```

2. **创建媒介类型**
   - 管理 → 媒介类型 → 创建媒介类型
   - 类型：脚本
   - 脚本名称：custom_alert.sh
   - 脚本参数：{ALERT.SENDTO} {ALERT.SUBJECT} {ALERT.MESSAGE}

### 8.3 多功能告警脚本示例


```bash
#!/bin/bash
# 多功能告警脚本示例

SENDTO=$1        # 接收者
SUBJECT=$2       # 主题
MESSAGE=$3       # 消息内容

# 日志记录函数
log_alert() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> /var/log/zabbix_alerts.log
}

# 解析告警级别
get_severity() {
    if [[ "$SUBJECT" == *"Critical"* ]]; then
        echo "critical"
    elif [[ "$SUBJECT" == *"High"* ]]; then
        echo "high"
    else
        echo "normal"
    fi
}

# 主处理逻辑
main() {
    SEVERITY=$(get_severity)
    log_alert "收到告警: $SUBJECT"
    
    case $SEVERITY in
        "critical")
            # 严重告警：多渠道通知
            send_sms "$SENDTO" "$MESSAGE"
            send_email "$SENDTO" "$SUBJECT" "$MESSAGE"
            send_wechat "$SENDTO" "$MESSAGE"
            ;;
        "high")
            # 高级告警：邮件+微信
            send_email "$SENDTO" "$SUBJECT" "$MESSAGE"
            send_wechat "$SENDTO" "$MESSAGE"
            ;;
        *)
            # 普通告警：仅邮件
            send_email "$SENDTO" "$SUBJECT" "$MESSAGE"
            ;;
    esac
    
    log_alert "告警处理完成"
}

# 发送短信函数
send_sms() {
    local phone=$1
    local message=$2
    # 调用短信接口
    python3 /opt/scripts/send_sms.py --phone "$phone" --message "$message"
}

# 发送邮件函数  
send_email() {
    local email=$1
    local subject=$2
    local message=$3
    # 使用系统mail命令
    echo "$message" | mail -s "$subject" "$email"
}

# 发送微信函数
send_wechat() {
    local user=$1
    local message=$2
    # 调用微信接口
    python3 /opt/scripts/send_wechat.py --user "$user" --message "$message"
}

# 执行主函数
main
```

### 8.4 告警脚本最佳实践


**🔸 脚本编写建议**

1. **错误处理**
```bash
# 添加错误检查
if ! command -v python3 &> /dev/null; then
    echo "错误：Python3未安装" >&2
    exit 1
fi

# 检查参数
if [ $# -ne 3 ]; then
    echo "用法: $0 <接收者> <主题> <消息>" >&2
    exit 1
fi
```

2. **日志记录**
```bash
# 详细日志
LOG_FILE="/var/log/zabbix_custom_alerts.log"
echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] 开始处理告警" >> "$LOG_FILE"
echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] 接收者: $SENDTO" >> "$LOG_FILE"
echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] 主题: $SUBJECT" >> "$LOG_FILE"
```

3. **性能优化**
```bash
# 异步执行，避免阻塞
send_notifications() {
    send_email "$1" "$2" "$3" &
    send_wechat "$1" "$3" &
    wait  # 等待所有后台任务完成
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 报警媒介本质：Zabbix向外发送通知的"邮递员"
🔸 媒介类型选择：根据紧急程度和成本选择合适的通知方式
🔸 配置原理：理解SMTP、API、Webhook等不同技术的基本原理
🔸 安全考虑：保护好各种密钥、Token和认证信息
🔸 测试验证：每种媒介都要充分测试确保能正常工作
```

### 9.2 各种媒介的适用场景


**🔹 媒介选择策略**
```
紧急故障（Critical）：
首选：短信 + 电话
备选：微信/钉钉
原因：即时性最强，覆盖面最广

重要告警（High）：
首选：微信/钉钉 + 邮件  
备选：Slack
原因：平衡即时性和详细信息

一般通知（Normal）：
首选：邮件
备选：群组聊天工具
原因：详细信息，便于存档查阅

系统集成：
首选：Webhook + 脚本
原因：可以触发自动化流程
```

**🔹 配置最佳实践**
```
多渠道冗余：
- 重要告警配置多个媒介
- 避免单点故障
- 确保消息能够送达

分级通知：
- 不同级别使用不同媒介
- 避免消息轰炸
- 提高处理效率

测试机制：
- 定期测试所有媒介
- 模拟各种故障场景
- 验证通知的及时性和准确性
```

### 9.3 实际应用建议


**🎯 企业级配置建议**
- **小团队**：微信群 + 邮件，简单够用
- **中型企业**：钉钉 + 短信 + 邮件，覆盖全面
- **大型企业**：多媒介 + Webhook集成，专业完整
- **国际化团队**：Slack + 邮件，跨地区协作

**⚡ 常见问题解决**
- **邮件发送失败**：检查SMTP配置和认证方式
- **微信收不到**：确认企业号配置和用户关联
- **短信成本高**：设置合理的告警级别和频率限制
- **消息过多**：优化触发器，减少噪音告警

**核心记忆要点**：
- 报警媒介是监控系统的"最后一公里"
- 选择合适的媒介类型比配置技巧更重要
- 测试、测试、再测试，确保关键时刻不掉链子
- 安全第一，保护好所有的认证信息