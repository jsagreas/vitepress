---
title: 2、低级发现-LLD
---
## 📚 目录

1. [LLD基础概念](#1-LLD基础概念)
2. [LLD工作原理](#2-LLD工作原理)
3. [发现规则配置详解](#3-发现规则配置详解)
4. [JSON数据格式要求](#4-JSON数据格式要求)
5. [文件系统自动发现](#5-文件系统自动发现)
6. [网络接口自动发现](#6-网络接口自动发现)
7. [自定义发现脚本](#7-自定义发现脚本)
8. [动态监控项管理](#8-动态监控项管理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 LLD基础概念


### 1.1 什么是LLD？


**🎯 通俗理解**：
想象你是一个网管，要监控公司所有电脑的硬盘使用情况。传统方式是每台电脑手动添加监控项，如果有100台电脑就要配置100次。但LLD（Low-Level Discovery）就像一个"智能助手"，它能自动发现每台电脑有哪些硬盘，然后自动为每个硬盘创建监控项。

**📋 官方定义**：
LLD（Low-Level Discovery，低级发现）是Zabbix的一个高级功能，能够自动发现监控对象并为其创建监控项、触发器和图形。

**🌟 核心价值**：
- **自动化**：无需手动为每个对象创建监控
- **动态性**：当新对象出现时自动添加监控
- **一致性**：所有同类对象使用相同的监控规则
- **省时省力**：大幅减少配置工作量

### 1.2 LLD解决的问题


**🚫 传统监控痛点**：
```
场景：监控服务器的所有网卡流量
传统方式：
1. 手动查看服务器有哪些网卡（eth0, eth1, eth2...）
2. 为每个网卡手动创建监控项
3. 如果网卡变化，需要手动调整配置
4. 多台服务器需要重复上述步骤

问题：
- 工作量大，容易出错
- 配置不一致
- 难以适应动态变化
- 维护成本高
```

**✅ LLD自动化解决**：
```
LLD方式：
1. 配置一个"网卡发现规则"
2. 系统自动发现所有网卡
3. 自动为每个网卡创建相同的监控项
4. 网卡变化时自动更新

优势：
- 一次配置，自动应用
- 配置标准化
- 动态适应变化
- 大幅降低维护成本
```

### 1.3 LLD适用场景


**🎯 典型应用场景**：

| 场景类型 | **具体示例** | **监控对象** |
|---------|------------|-------------|
| 🗄️ **文件系统** | `磁盘分区监控` | `/dev/sda1, /dev/sda2, /home, /var` |
| 🌐 **网络接口** | `网卡流量监控` | `eth0, eth1, wlan0, docker0` |
| 💾 **数据库** | `MySQL数据库监控` | `database1, database2, database3` |
| 🔄 **进程服务** | `系统服务监控` | `httpd, mysqld, nginx, docker` |
| ☁️ **虚拟化** | `Docker容器监控` | `container1, container2, web-app` |

---

## 2. ⚙️ LLD工作原理


### 2.1 LLD工作流程


**🔄 完整工作流程**：
```
第一步：发现阶段
执行发现脚本/命令 → 获取JSON格式数据 → 解析发现的对象

第二步：创建阶段  
根据发现的对象 → 使用预设模板 → 自动创建监控项/触发器

第三步：更新阶段
定期重新发现 → 对比现有配置 → 添加新对象/删除失效对象

第四步：监控阶段
正常监控运行 → 收集数据 → 触发告警
```

**📊 流程图示**：
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  执行发现    │───▶│  解析JSON   │───▶│  创建监控项  │
│    脚本      │    │    数据     │    │   触发器    │
└─────────────┘    └─────────────┘    └─────────────┘
       ▲                                      │
       │              定期执行                 │
       └──────────────────────────────────────┘
```

### 2.2 关键组件说明


**🔧 LLD核心组件**：

**发现规则（Discovery Rule）**：
- **作用**：定义如何发现监控对象
- **类型**：脚本、SNMP、数据库查询等
- **频率**：设定多久执行一次发现

**监控项原型（Item Prototype）**：
- **作用**：定义发现的每个对象要创建什么监控项
- **特点**：使用宏变量代表动态对象
- **示例**：`vfs.fs.size[{#FSNAME}]` 其中 `{#FSNAME}` 是发现的文件系统名

**触发器原型（Trigger Prototype）**：
- **作用**：为每个发现的对象创建告警规则
- **示例**：`{host:vfs.fs.pused[{#FSNAME}].last()}>90` 表示磁盘使用率超过90%告警

### 2.3 LLD与普通监控的区别


**📋 对比说明**：

| 特性 | **普通监控** | **LLD监控** |
|------|-------------|------------|
| **配置方式** | `手动逐个配置` | `自动批量创建` |
| **适应性** | `静态固定` | `动态适应变化` |
| **维护成本** | `高，需要人工干预` | `低，自动维护` |
| **一致性** | `容易不一致` | `完全一致` |
| **扩展性** | `难以扩展` | `易于扩展` |

---

## 3. 🛠️ 发现规则配置详解


### 3.1 创建发现规则


**📍 配置路径**：`配置 → 主机 → 发现规则 → 创建发现规则`

**🔸 基本配置项**：

```
名称：文件系统发现
类型：Zabbix代理（主动式）
键值：vfs.fs.discovery
更新间隔：1h（每小时检查一次）
保留丢失资源的时间：7d（7天后删除消失的对象）
```

**💡 配置说明**：

**名称**：
- **含义**：发现规则的显示名称
- **建议**：使用描述性名称，如"文件系统发现"、"网卡发现"
- **示例**：`"MySQL数据库发现"` 比 `"db_discovery"` 更直观

**键值（Key）**：
- **含义**：执行发现的监控项键值
- **内置键值**：Zabbix提供了常用的内置发现键值
- **自定义键值**：可以使用自定义脚本的键值

**更新间隔**：
- **含义**：多久执行一次发现
- **建议**：根据对象变化频率设定
- **示例**：文件系统变化不频繁，可以设为1小时或更长

### 3.2 常用内置发现键值


**🔧 系统内置LLD键值**：

| 键值 | **发现对象** | **说明** |
|------|-------------|---------|
| `vfs.fs.discovery` | **文件系统** | `发现所有挂载的文件系统` |
| `net.if.discovery` | **网络接口** | `发现所有网络接口` |
| `system.cpu.discovery` | **CPU核心** | `发现所有CPU核心` |
| `vm.memory.discovery` | **内存信息** | `发现内存相关信息` |

**📋 实际使用示例**：
```
文件系统发现：
键值：vfs.fs.discovery
返回：所有挂载点信息（/, /home, /var等）

网络接口发现：
键值：net.if.discovery  
返回：所有网卡信息（eth0, eth1, lo等）
```

### 3.3 过滤器配置


**🎯 为什么需要过滤器**：
发现规则可能返回很多对象，但我们不需要监控所有对象。比如发现所有文件系统时，可能不需要监控临时文件系统或虚拟文件系统。

**🔧 过滤器类型**：

**正则表达式过滤**：
```
宏：{#FSTYPE}
正则表达式：^(ext4|xfs|ntfs)$
含义：只监控ext4、xfs、ntfs类型的文件系统
```

**多条件过滤**：
```
条件1：{#FSNAME} 匹配 ^/.*
条件2：{#FSTYPE} 不匹配 ^(tmpfs|devtmpfs|proc)$
含义：只监控根目录下的真实文件系统
```

**💡 过滤器配置建议**：
- **包含重要对象**：确保需要监控的对象不被过滤掉
- **排除无用对象**：过滤掉临时、虚拟、不重要的对象
- **测试过滤规则**：配置后验证过滤效果是否符合预期

---

## 4. 📄 JSON数据格式要求


### 4.1 LLD JSON格式标准


**📋 基本格式要求**：
LLD发现脚本必须返回特定格式的JSON数据，Zabbix才能正确解析。

**🔸 标准JSON结构**：
```json
{
    "data": [
        {
            "{#MACRO1}": "value1",
            "{#MACRO2}": "value2"
        },
        {
            "{#MACRO1}": "value3", 
            "{#MACRO2}": "value4"
        }
    ]
}
```

**💡 格式说明**：
- **外层结构**：必须有一个名为 `"data"` 的数组
- **宏变量**：使用 `{#MACRONAME}` 格式定义宏
- **唯一标识**：每个对象需要有唯一标识符

### 4.2 文件系统发现JSON示例


**📁 实际返回示例**：
```json
{
    "data": [
        {
            "{#FSNAME}": "/",
            "{#FSTYPE}": "ext4",
            "{#FSOPTIONS}": "rw,relatime"
        },
        {
            "{#FSNAME}": "/home",
            "{#FSTYPE}": "ext4", 
            "{#FSOPTIONS}": "rw,relatime"
        },
        {
            "{#FSNAME}": "/var",
            "{#FSTYPE}": "xfs",
            "{#FSOPTIONS}": "rw,relatime"
        }
    ]
}
```

**🔧 宏变量说明**：
- `{#FSNAME}`：文件系统挂载点路径
- `{#FSTYPE}`：文件系统类型
- `{#FSOPTIONS}`：挂载选项

### 4.3 网络接口发现JSON示例


**🌐 网卡发现返回**：
```json
{
    "data": [
        {
            "{#IFNAME}": "eth0",
            "{#IFALIAS}": "主网卡",
            "{#IFTYPE}": "6"
        },
        {
            "{#IFNAME}": "eth1", 
            "{#IFALIAS}": "备用网卡",
            "{#IFTYPE}": "6"
        },
        {
            "{#IFNAME}": "lo",
            "{#IFALIAS}": "环回接口", 
            "{#IFTYPE}": "24"
        }
    ]
}
```

**🔧 宏变量含义**：
- `{#IFNAME}`：网络接口名称
- `{#IFALIAS}`：接口别名描述
- `{#IFTYPE}`：接口类型（6=以太网，24=环回）

### 4.4 JSON格式常见错误


**❌ 常见格式错误**：

**错误1：缺少data数组**
```json
// 错误格式
[
    {"{#FSNAME}": "/"}
]

// 正确格式  
{
    "data": [
        {"{#FSNAME}": "/"}
    ]
}
```

**错误2：宏变量格式错误**
```json
// 错误：缺少#号
{"FSNAME": "/"}

// 正确：必须使用{#MACRO}格式
{"{#FSNAME}": "/"}
```

---

## 5. 💾 文件系统自动发现


### 5.1 文件系统发现配置


**🎯 应用场景**：
自动监控服务器所有文件系统的磁盘使用率、可用空间、I/O性能等指标。

**📍 配置步骤**：

**步骤1：创建发现规则**
```
名称：文件系统发现
键值：vfs.fs.discovery
更新间隔：3600（1小时）
保留丢失资源：604800（7天）
```

**步骤2：配置过滤器**
```
宏：{#FSTYPE}
正则表达式：^(ext[234]|xfs|ntfs|btrfs)$
作用：只监控常见的真实文件系统类型
```

**步骤3：排除临时文件系统**
```
宏：{#FSNAME}
正则表达式：^/(proc|sys|dev|run|tmp)
操作：不匹配
作用：排除系统虚拟文件系统
```

### 5.2 文件系统监控项原型


**📊 常用监控项原型**：

**磁盘使用率监控**：
```
名称：磁盘使用率 {#FSNAME}
键值：vfs.fs.pused[{#FSNAME}]
数据类型：数字（浮点）
单位：%
更新间隔：300（5分钟）
```

**可用空间监控**：
```
名称：可用磁盘空间 {#FSNAME}
键值：vfs.fs.size[{#FSNAME},free]
数据类型：数字（无符号）
单位：B
更新间隔：300
```

**总空间监控**：
```
名称：总磁盘空间 {#FSNAME}  
键值：vfs.fs.size[{#FSNAME},total]
数据类型：数字（无符号）
单位：B
更新间隔：3600（1小时，变化不频繁）
```

### 5.3 文件系统触发器原型


**⚠️ 常用告警规则**：

**磁盘空间不足告警**：
```yaml
名称: 磁盘使用率过高 {#FSNAME}
表达式: {host:vfs.fs.pused[{#FSNAME}].last()}>90
严重性: 高
描述: 文件系统 {#FSNAME} 使用率已达到 {ITEM.LASTVALUE}%
```

**磁盘空间严重不足**：
```yaml
名称: 磁盘空间严重不足 {#FSNAME}
表达式: {host:vfs.fs.pused[{#FSNAME}].last()}>95
严重性: 灾难  
描述: 文件系统 {#FSNAME} 使用率已达到 {ITEM.LASTVALUE}%，请立即清理
```

**💡 告警阈值建议**：
- **警告级别**：80% - 提醒注意
- **高级别**：90% - 需要处理  
- **灾难级别**：95% - 紧急处理

---

## 6. 🌐 网络接口自动发现


### 6.1 网络接口发现配置


**🎯 监控目标**：
自动监控所有网络接口的流量、错误包、丢包率等网络性能指标。

**📍 发现规则配置**：

**基础配置**：
```
名称：网络接口发现
键值：net.if.discovery
更新间隔：3600（1小时）
保留丢失资源：86400（1天）
```

**接口类型过滤**：
```
宏：{#IFTYPE}
正则表达式：^(6|71)$
说明：6=以太网，71=WiFi，只监控这两种类型
```

**接口状态过滤**：
```
宏：{#IFNAME}
正则表达式：^lo$
操作：不匹配
说明：排除环回接口lo
```

### 6.2 网络接口监控项原型


**📈 网络流量监控**：

**入站流量**：
```
名称：网卡入站流量 {#IFNAME}
键值：net.if.in[{#IFNAME}]
数据类型：数字（无符号）
单位：bps
更新间隔：60（1分钟）
预处理：变化率（每秒）
```

**出站流量**：
```
名称：网卡出站流量 {#IFNAME}
键值：net.if.out[{#IFNAME}]
数据类型：数字（无符号）
单位：bps
更新间隔：60
预处理：变化率（每秒）
```

**🔧 网络错误监控**：

**入站错误包**：
```
名称：网卡入站错误 {#IFNAME}
键值：net.if.in[{#IFNAME},errors]
数据类型：数字（无符号）
单位：包/秒
预处理：变化率（每秒）
```

### 6.3 网络接口触发器原型


**⚠️ 网络告警规则**：

**网卡流量过高**：
```yaml
名称: 网卡 {#IFNAME} 入站流量过高
表达式: {host:net.if.in[{#IFNAME}].last()}>100M
严重性: 警告
描述: 网卡 {#IFNAME} 入站流量 {ITEM.LASTVALUE} 超过100Mbps
```

**网络错误率高**：
```yaml
名称: 网卡 {#IFNAME} 错误率高  
表达式: {host:net.if.in[{#IFNAME},errors].avg(5m)}>10
严重性: 高
描述: 网卡 {#IFNAME} 5分钟平均错误包数超过10个/秒
```

**💡 网络监控最佳实践**：
- **带宽阈值**：根据实际带宽设置告警阈值
- **错误率监控**：关注错误包和丢包情况
- **趋势分析**：使用图形展示流量趋势

---

## 7. 📜 自定义发现脚本


### 7.1 自定义脚本基础


**🎯 使用场景**：
当内置的LLD功能无法满足需求时，可以编写自定义脚本来发现特定的监控对象。

**📋 脚本要求**：
- **输出格式**：必须输出标准JSON格式
- **执行权限**：脚本需要有执行权限
- **错误处理**：要有基本的错误处理机制
- **性能考虑**：避免脚本执行时间过长

### 7.2 Docker容器发现脚本示例


**🐳 脚本目标**：发现系统中运行的Docker容器

**脚本内容**：
```bash
#!/bin/bash

# Docker容器发现脚本
# 返回所有运行中的容器信息

containers=$(docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}" | tail -n +2)

# 开始构建JSON
echo "{"
echo "  \"data\": ["

first=true
while IFS=$'\t' read -r name image status; do
    if [ "$first" = true ]; then
        first=false
    else
        echo "    ,"
    fi
    
    echo "    {"
    echo "      \"{#CONTAINER_NAME}\": \"$name\","
    echo "      \"{#CONTAINER_IMAGE}\": \"$image\","
    echo "      \"{#CONTAINER_STATUS}\": \"$status\""
    echo -n "    }"
done <<< "$containers"

echo
echo "  ]"
echo "}"
```

**📍 脚本部署**：
```bash
# 1. 保存脚本到指定目录
sudo cp docker_discovery.sh /etc/zabbix/scripts/

# 2. 设置执行权限
sudo chmod +x /etc/zabbix/scripts/docker_discovery.sh

# 3. 配置Zabbix Agent
echo "UserParameter=docker.discovery,/etc/zabbix/scripts/docker_discovery.sh" >> /etc/zabbix/zabbix_agentd.conf

# 4. 重启Zabbix Agent
sudo systemctl restart zabbix-agent
```

### 7.3 MySQL数据库发现脚本


**💾 监控目标**：发现MySQL实例中的所有数据库

**脚本示例**：
```bash
#!/bin/bash

# MySQL数据库发现脚本
# 需要预先配置数据库连接信息

MYSQL_USER="monitor_user"
MYSQL_PASS="monitor_pass"
MYSQL_HOST="localhost"

# 查询所有数据库（排除系统数据库）
databases=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "
    SHOW DATABASES;" 2>/dev/null | 
    grep -v -E '^(Database|information_schema|performance_schema|mysql|sys)$')

echo "{"
echo "  \"data\": ["

first=true
for db in $databases; do
    if [ "$first" = true ]; then
        first=false
    else
        echo "    ,"
    fi
    
    # 获取数据库大小
    size=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "
        SELECT ROUND(SUM(data_length + index_length), 0) 
        FROM information_schema.tables 
        WHERE table_schema='$db';" 2>/dev/null | tail -n 1)
    
    echo "    {"
    echo "      \"{#DB_NAME}\": \"$db\","
    echo "      \"{#DB_SIZE}\": \"${size:-0}\""
    echo -n "    }"
done

echo
echo "  ]"
echo "}"
```

### 7.4 脚本调试技巧


**🔧 调试方法**：

**本地测试**：
```bash
# 直接执行脚本查看输出
/etc/zabbix/scripts/docker_discovery.sh

# 验证JSON格式是否正确
/etc/zabbix/scripts/docker_discovery.sh | python -m json.tool
```

**Zabbix测试**：
```bash
# 使用zabbix_get工具测试
zabbix_get -s 目标主机IP -k docker.discovery

# 在Zabbix前端测试监控项
配置 → 主机 → 监控项 → 测试
```

**⚠️ 常见问题**：
- **权限问题**：确保脚本有执行权限
- **路径问题**：使用绝对路径调用命令
- **格式问题**：严格检查JSON格式
- **性能问题**：避免脚本执行时间过长

---

## 8. 🔄 动态监控项管理


### 8.1 监控项生命周期


**🔄 自动管理流程**：

```
发现新对象 → 自动创建监控项 → 正常数据收集 → 对象消失 → 保留期内数据 → 自动删除
```

**📋 生命周期阶段**：

**创建阶段**：
- 发现规则检测到新对象
- 根据监控项原型自动创建具体监控项
- 开始数据收集

**运行阶段**：
- 正常收集监控数据
- 触发器检查告警条件
- 数据存储和展示

**清理阶段**：
- 对象不再被发现
- 进入保留期（可配置）
- 保留期结束后自动删除

### 8.2 保留期配置策略


**⏰ 保留期设置建议**：

| 对象类型 | **建议保留期** | **原因说明** |
|---------|---------------|-------------|
| **文件系统** | `7天` | `文件系统变化不频繁，7天足够确认` |
| **网络接口** | `1天` | `网卡状态变化较快，1天即可` |
| **数据库** | `3天` | `数据库创建删除不算频繁` |
| **容器服务** | `1小时` | `容器启停非常频繁，短保留期` |

**💡 保留期原则**：
- **变化频繁的对象**：设置较短保留期
- **重要对象**：设置较长保留期，避免误删除
- **临时对象**：设置很短保留期，及时清理

### 8.3 LLD性能优化


**⚡ 优化策略**：

**发现频率优化**：
```
静态对象（文件系统）：1-6小时
半动态对象（数据库）：30分钟-1小时  
动态对象（容器）：5-15分钟
```

**过滤器优化**：
```
# 使用正则表达式排除不需要的对象
{#FSTYPE} 不匹配 ^(tmpfs|devtmpfs|proc|sys)$

# 减少发现的对象数量
{#IFNAME} 匹配 ^(eth|en|wl).*
```

**脚本性能优化**：
```bash
# 避免多次数据库连接
# 使用缓存减少外部调用
# 设置脚本超时时间
```

**📊 监控LLD性能**：
- **发现执行时间**：监控发现脚本执行耗时
- **创建对象数量**：跟踪每次发现创建的对象数
- **系统资源使用**：监控LLD对系统性能的影响

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 LLD本质：自动发现并创建监控对象的高级功能
🔸 工作原理：发现→解析→创建→管理的完整流程
🔸 JSON格式：严格的data数组和宏变量格式要求
🔸 原型概念：监控项原型和触发器原型的模板作用
🔸 生命周期：从创建到删除的完整管理过程
```

### 9.2 关键理解要点


**🔹 LLD的核心价值**
```
自动化：
- 解放人工配置工作
- 标准化监控配置
- 适应动态环境变化

一致性：
- 所有同类对象使用相同监控规则
- 避免配置遗漏和错误
- 便于批量管理和维护
```

**🔹 配置关键点**
```
发现规则：
- 选择合适的发现间隔
- 配置有效的过滤器
- 设置合理的保留期

原型设计：
- 使用描述性的名称模板
- 设置合适的监控间隔
- 配置有意义的告警阈值
```

**🔹 最佳实践原则**
```
性能考虑：
- 避免过于频繁的发现
- 使用过滤器减少无用对象
- 优化自定义脚本性能

维护友好：
- 使用清晰的命名规范
- 配置合理的保留期
- 定期检查LLD效果
```

### 9.3 实际应用建议


**🎯 应用场景选择**：
- **大量同类对象**：优先考虑使用LLD
- **动态变化环境**：LLD是最佳选择
- **标准化监控**：使用LLD确保一致性
- **减少维护工作**：LLD大幅降低工作量

**⚠️ 注意事项**：
- **测试充分**：新建LLD规则要充分测试
- **监控影响**：关注LLD对系统性能的影响
- **权限管理**：确保发现脚本有适当权限
- **错误处理**：编写健壮的自定义脚本

**🚀 进阶应用**：
- **多层发现**：结合多个LLD规则实现复杂发现
- **条件发现**：根据不同条件使用不同发现策略
- **集成发现**：与外部系统集成实现高级发现

**核心记忆要点**：
- LLD = 自动发现 + 批量创建 + 动态管理
- JSON格式必须严格按照data数组规范
- 原型是模板，宏变量是占位符
- 合理配置发现间隔和保留期很重要
- 过滤器是控制发现范围的关键工具