---
title: 4ã€Pythonå¼€å‘å®è·µ
---
## ğŸ“š ç›®å½•

1. [pikaå®¢æˆ·ç«¯åŸºç¡€ä½¿ç”¨](#1-pikaå®¢æˆ·ç«¯åŸºç¡€ä½¿ç”¨)
2. [å¼‚æ­¥å¤„ç†æ¨¡å¼è¯¦è§£](#2-å¼‚æ­¥å¤„ç†æ¨¡å¼è¯¦è§£)
3. [è¿æ¥ç®¡ç†ç­–ç•¥](#3-è¿æ¥ç®¡ç†ç­–ç•¥)
4. [é”™è¯¯å¤„ç†æœºåˆ¶](#4-é”™è¯¯å¤„ç†æœºåˆ¶)
5. [æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#5-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
6. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#6-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ pikaå®¢æˆ·ç«¯åŸºç¡€ä½¿ç”¨


### 1.1 ä»€ä¹ˆæ˜¯pikaå®¢æˆ·ç«¯


**pikaç®€å•ç†è§£**ï¼š
pikaå°±æ˜¯Pythonè¯­è¨€ä¸“é—¨ç”¨æ¥å’ŒRabbitMQå¯¹è¯çš„å·¥å…·åŒ…ï¼Œå°±åƒä½ ç”¨å¾®ä¿¡å’Œæœ‹å‹èŠå¤©éœ€è¦å¾®ä¿¡APPä¸€æ ·ï¼ŒPythonç¨‹åºæƒ³è¦å’ŒRabbitMQé€šä¿¡å°±éœ€è¦pikaè¿™ä¸ª"ç¿»è¯‘å®˜"ã€‚

```
ç°å®ç”Ÿæ´»ç±»æ¯”ï¼š
ä½ ï¼ˆPythonç¨‹åºï¼‰ â†’ æ‰‹æœºAPPï¼ˆpikaå®¢æˆ·ç«¯ï¼‰ â†’ ç½‘ç»œï¼ˆæ¶ˆæ¯é˜Ÿåˆ—ï¼‰ â†’ æœ‹å‹çš„æ‰‹æœºï¼ˆå…¶ä»–æœåŠ¡ï¼‰

æŠ€æœ¯å±‚é¢ï¼š
Pythonåº”ç”¨ â†’ pikaåº“ â†’ AMQPåè®® â†’ RabbitMQæœåŠ¡å™¨ â†’ æ¶ˆè´¹è€…åº”ç”¨
```

**pikaçš„æ ¸å¿ƒä½œç”¨**ï¼š
- **è¿æ¥å»ºç«‹**ï¼šå¸®ä½ çš„ç¨‹åºè¿ä¸ŠRabbitMQæœåŠ¡å™¨
- **æ¶ˆæ¯å‘é€**ï¼šæŠŠä½ çš„æ•°æ®åŒ…è£…æˆæ¶ˆæ¯å‘å‡ºå»
- **æ¶ˆæ¯æ¥æ”¶**ï¼šæ¥æ”¶åˆ«äººå‘æ¥çš„æ¶ˆæ¯å¹¶è§£åŒ…
- **é˜Ÿåˆ—ç®¡ç†**ï¼šåˆ›å»ºã€åˆ é™¤ã€é…ç½®æ¶ˆæ¯é˜Ÿåˆ—

### 1.2 å®‰è£…å’ŒåŸºæœ¬è¿æ¥


**å®‰è£…pika**ï¼š
```bash
pip install pika
```

**å»ºç«‹åŸºæœ¬è¿æ¥**ï¼š
```python
import pika

# æœ€ç®€å•çš„è¿æ¥æ–¹å¼ - è¿æ¥æœ¬åœ°RabbitMQ
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

print("æˆåŠŸè¿æ¥åˆ°RabbitMQï¼")
```

> ğŸ’¡ **æ–°æ‰‹ç†è§£**ï¼š`BlockingConnection`æ„æ€æ˜¯"é˜»å¡å¼è¿æ¥"ï¼Œç®€å•è¯´å°±æ˜¯ç¨‹åºä¼šç­‰å¾…æ“ä½œå®Œæˆæ‰ç»§ç»­ï¼Œé€‚åˆåˆå­¦è€…ç†è§£å’Œè°ƒè¯•ã€‚

### 1.3 å‘é€æ¶ˆæ¯çš„åŸºæœ¬æµç¨‹


**å®Œæ•´çš„å‘é€æ¶ˆæ¯ç¤ºä¾‹**ï¼š

```python
import pika

def send_simple_message():
    # ç¬¬1æ­¥ï¼šå»ºç«‹è¿æ¥
    connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
    channel = connection.channel()
    
    # ç¬¬2æ­¥ï¼šå£°æ˜é˜Ÿåˆ—ï¼ˆç¡®ä¿é˜Ÿåˆ—å­˜åœ¨ï¼‰
    channel.queue_declare(queue='hello')
    
    # ç¬¬3æ­¥ï¼šå‘é€æ¶ˆæ¯
    channel.basic_publish(
        exchange='',      # ä½¿ç”¨é»˜è®¤äº¤æ¢æœº
        routing_key='hello',  # é˜Ÿåˆ—åç§°
        body='Hello World!'   # æ¶ˆæ¯å†…å®¹
    )
    
    print("æ¶ˆæ¯å·²å‘é€ï¼")
    
    # ç¬¬4æ­¥ï¼šå…³é—­è¿æ¥
    connection.close()

# è°ƒç”¨å‡½æ•°å‘é€æ¶ˆæ¯
send_simple_message()
```

**æµç¨‹å›¾è§£**ï¼š
```
Pythonç¨‹åº
    â†“ 1. å»ºç«‹è¿æ¥
RabbitMQæœåŠ¡å™¨
    â†“ 2. å£°æ˜é˜Ÿåˆ—
åˆ›å»ºhelloé˜Ÿåˆ—
    â†“ 3. å‘é€æ¶ˆæ¯
æ¶ˆæ¯æ”¾å…¥helloé˜Ÿåˆ—
    â†“ 4. å…³é—­è¿æ¥
é‡Šæ”¾èµ„æº
```

### 1.4 æ¥æ”¶æ¶ˆæ¯çš„åŸºæœ¬æµç¨‹


```python
import pika

def receive_messages():
    # å»ºç«‹è¿æ¥
    connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
    channel = connection.channel()
    
    # ç¡®ä¿é˜Ÿåˆ—å­˜åœ¨
    channel.queue_declare(queue='hello')
    
    # å®šä¹‰å¤„ç†æ¶ˆæ¯çš„å‡½æ•°
    def callback(ch, method, properties, body):
        print(f"æ”¶åˆ°æ¶ˆæ¯: {body.decode()}")
        # æ‰‹åŠ¨ç¡®è®¤æ¶ˆæ¯å·²å¤„ç†
        ch.basic_ack(delivery_tag=method.delivery_tag)
    
    # è®¾ç½®æ¶ˆè´¹è€…
    channel.basic_consume(
        queue='hello',
        on_message_callback=callback
    )
    
    print("ç­‰å¾…æ¶ˆæ¯ä¸­... æŒ‰ CTRL+C é€€å‡º")
    
    try:
        # å¼€å§‹ç›‘å¬æ¶ˆæ¯
        channel.start_consuming()
    except KeyboardInterrupt:
        # ç”¨æˆ·æŒ‰ CTRL+C æ—¶ä¼˜é›…é€€å‡º
        channel.stop_consuming()
        connection.close()
        print("å·²åœæ­¢ç›‘å¬æ¶ˆæ¯")

# å¯åŠ¨æ¶ˆæ¯æ¥æ”¶
receive_messages()
```

> ğŸ¯ **å…³é”®ç†è§£**ï¼š`callback`å‡½æ•°å°±æ˜¯"å›è°ƒå‡½æ•°"ï¼Œæ„æ€æ˜¯å½“æœ‰æ¶ˆæ¯åˆ°è¾¾æ—¶ï¼ŒRabbitMQä¼šè‡ªåŠ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥å¤„ç†æ¶ˆæ¯ï¼Œå°±åƒé—¨é“ƒå“äº†ä½ å»å¼€é—¨ä¸€æ ·ã€‚

---

## 2. âš¡ å¼‚æ­¥å¤„ç†æ¨¡å¼è¯¦è§£


### 2.1 ä»€ä¹ˆæ˜¯å¼‚æ­¥å¤„ç†


**ç”Ÿæ´»ä¸­çš„å¼‚æ­¥vsåŒæ­¥**ï¼š
```
åŒæ­¥æ¨¡å¼ï¼ˆå µå¡å¼ï¼‰ï¼š
ä½ æ‰“ç”µè¯ â†’ ç­‰å¯¹æ–¹æ¥å¬ â†’ è¯´å®Œè¯ â†’ æŒ‚ç”µè¯ â†’ æ‰èƒ½åšå…¶ä»–äº‹

å¼‚æ­¥æ¨¡å¼ï¼ˆéé˜»å¡å¼ï¼‰ï¼š
ä½ å‘å¾®ä¿¡ â†’ ç«‹å³å»åšå…¶ä»–äº‹ â†’ æœ‰å›å¤æ—¶æ”¶åˆ°é€šçŸ¥ â†’ æœ‰ç©ºæ—¶æŸ¥çœ‹å›å¤
```

**åœ¨RabbitMQä¸­çš„å¼‚æ­¥å¤„ç†**ï¼š
- **åŒæ­¥**ï¼šå‘é€æ¶ˆæ¯åå¿…é¡»ç­‰å¾…ç¡®è®¤æ‰èƒ½ç»§ç»­
- **å¼‚æ­¥**ï¼šå‘é€æ¶ˆæ¯åç«‹å³ç»§ç»­å¤„ç†å…¶ä»–ä»»åŠ¡

### 2.2 ä½¿ç”¨å¼‚æ­¥è¿æ¥


**SelectConnectionå¼‚æ­¥æ¨¡å¼**ï¼š

```python
import pika
import asyncio
from pika.adapters.asyncio_connection import AsyncioConnection

class AsyncRabbitMQ:
    def __init__(self):
        self.connection = None
        self.channel = None
    
    async def connect(self):
        """å¼‚æ­¥è¿æ¥åˆ°RabbitMQ"""
        # åˆ›å»ºå¼‚æ­¥è¿æ¥
        self.connection = await AsyncioConnection.create_connection(
            pika.ConnectionParameters('localhost')
        )
        self.channel = await self.connection.channel()
        print("å¼‚æ­¥è¿æ¥å»ºç«‹æˆåŠŸï¼")
    
    async def send_message(self, queue_name, message):
        """å¼‚æ­¥å‘é€æ¶ˆæ¯"""
        # å£°æ˜é˜Ÿåˆ—
        await self.channel.queue_declare(queue=queue_name)
        
        # å‘é€æ¶ˆæ¯
        await self.channel.basic_publish(
            exchange='',
            routing_key=queue_name,
            body=message
        )
        print(f"å¼‚æ­¥å‘é€æ¶ˆæ¯: {message}")

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    rabbit = AsyncRabbitMQ()
    await rabbit.connect()
    
    # å¯ä»¥åŒæ—¶å‘é€å¤šæ¡æ¶ˆæ¯è€Œä¸ç”¨ç­‰å¾…
    await rabbit.send_message('queue1', 'Message 1')
    await rabbit.send_message('queue2', 'Message 2')
    await rabbit.send_message('queue3', 'Message 3')

# è¿è¡Œå¼‚æ­¥ç¨‹åº
asyncio.run(main())
```

### 2.3 å¼‚æ­¥vsåŒæ­¥æ€§èƒ½å¯¹æ¯”


| å¤„ç†æ¨¡å¼ | **é€‚ç”¨åœºæ™¯** | **ä¼˜åŠ¿** | **åŠ£åŠ¿** |
|---------|------------|---------|---------|
| ğŸŒ **åŒæ­¥æ¨¡å¼** | `ç®€å•åº”ç”¨ã€å­¦ä¹ é˜¶æ®µ` | `ä»£ç ç®€å•ã€æ˜“ç†è§£ã€æ˜“è°ƒè¯•` | `æ€§èƒ½è¾ƒä½ã€é˜»å¡ç­‰å¾…` |
| âš¡ **å¼‚æ­¥æ¨¡å¼** | `é«˜å¹¶å‘ã€é«˜æ€§èƒ½åº”ç”¨` | `æ€§èƒ½ä¼˜ç§€ã€éé˜»å¡å¤„ç†` | `ä»£ç å¤æ‚ã€è°ƒè¯•å›°éš¾` |

**æ€§èƒ½å·®å¼‚ç¤ºä¾‹**ï¼š
```
åŒæ­¥æ¨¡å¼å¤„ç†1000æ¡æ¶ˆæ¯ï¼š
æ¶ˆæ¯1 â†’ ç­‰å¾…ç¡®è®¤ â†’ æ¶ˆæ¯2 â†’ ç­‰å¾…ç¡®è®¤ â†’ ... â†’ æ€»è€—æ—¶: 10ç§’

å¼‚æ­¥æ¨¡å¼å¤„ç†1000æ¡æ¶ˆæ¯ï¼š
æ¶ˆæ¯1ã€2ã€3...1000 åŒæ—¶å‘é€ â†’ å¹¶è¡Œå¤„ç† â†’ æ€»è€—æ—¶: 2ç§’
```

### 2.4 å®é™…é¡¹ç›®ä¸­çš„å¼‚æ­¥åº”ç”¨


```python
import asyncio
import pika

class OrderProcessor:
    """è®¢å•å¤„ç†ç³»ç»Ÿ - å¼‚æ­¥ç‰ˆæœ¬"""
    
    def __init__(self):
        self.connection = None
        self.channel = None
    
    async def setup(self):
        """åˆå§‹åŒ–è¿æ¥"""
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters('localhost')
        )
        self.channel = self.connection.channel()
        
        # å£°æ˜å¤šä¸ªé˜Ÿåˆ—
        self.channel.queue_declare(queue='order_created')
        self.channel.queue_declare(queue='payment_processing')
        self.channel.queue_declare(queue='shipping_notification')
    
    async def process_order(self, order_data):
        """å¼‚æ­¥å¤„ç†è®¢å•æµç¨‹"""
        order_id = order_data['order_id']
        
        # å¹¶è¡Œå¤„ç†å¤šä¸ªæ­¥éª¤
        tasks = [
            self.send_order_created(order_id),
            self.process_payment(order_id),
            self.prepare_shipping(order_id)
        ]
        
        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        await asyncio.gather(*tasks)
        print(f"è®¢å• {order_id} å¤„ç†å®Œæˆï¼")
    
    async def send_order_created(self, order_id):
        """å‘é€è®¢å•åˆ›å»ºé€šçŸ¥"""
        await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        self.channel.basic_publish(
            exchange='',
            routing_key='order_created',
            body=f'Order {order_id} created'
        )
        print(f"âœ… è®¢å• {order_id} åˆ›å»ºé€šçŸ¥å·²å‘é€")
    
    async def process_payment(self, order_id):
        """å¤„ç†æ”¯ä»˜"""
        await asyncio.sleep(0.2)  # æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
        self.channel.basic_publish(
            exchange='',
            routing_key='payment_processing',
            body=f'Payment for order {order_id}'
        )
        print(f"ğŸ’³ è®¢å• {order_id} æ”¯ä»˜å¤„ç†ä¸­")
    
    async def prepare_shipping(self, order_id):
        """å‡†å¤‡å‘è´§"""
        await asyncio.sleep(0.15)  # æ¨¡æ‹Ÿå‘è´§å‡†å¤‡
        self.channel.basic_publish(
            exchange='',
            routing_key='shipping_notification',
            body=f'Shipping order {order_id}'
        )
        print(f"ğŸ“¦ è®¢å• {order_id} å‘è´§å‡†å¤‡")

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    processor = OrderProcessor()
    await processor.setup()
    
    # å¤„ç†å¤šä¸ªè®¢å•
    orders = [
        {'order_id': '001'},
        {'order_id': '002'},
        {'order_id': '003'}
    ]
    
    # å¹¶è¡Œå¤„ç†æ‰€æœ‰è®¢å•
    tasks = [processor.process_order(order) for order in orders]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

---

## 3. ğŸ”— è¿æ¥ç®¡ç†ç­–ç•¥


### 3.1 è¿æ¥å’Œé€šé“çš„å…³ç³»ç†è§£


**ç”¨é¤å…æ¯”å–»è¿æ¥ç®¡ç†**ï¼š
```
RabbitMQæœåŠ¡å™¨ = é¤å…
Connectionï¼ˆè¿æ¥ï¼‰ = é¤å…å¤§é—¨
Channelï¼ˆé€šé“ï¼‰ = é¤å…é‡Œçš„å„ä¸ªé¤æ¡Œ

ä¸€ä¸ªé¤å…ï¼ˆæœåŠ¡å™¨ï¼‰æœ‰ä¸€ä¸ªå¤§é—¨ï¼ˆè¿æ¥ï¼‰
å¤§é—¨é‡Œé¢æœ‰å¾ˆå¤šé¤æ¡Œï¼ˆé€šé“ï¼‰
æ¯ä¸ªé¤æ¡Œå¯ä»¥ç‹¬ç«‹ç‚¹èœï¼ˆå‘é€æ¶ˆæ¯ï¼‰
```

**æŠ€æœ¯å±‚é¢çš„å…³ç³»**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        RabbitMQæœåŠ¡å™¨            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         Connection          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚Channel1 â”‚ â”‚Channel2 â”‚   â”‚ â”‚
â”‚  â”‚  â”‚         â”‚ â”‚         â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 è¿æ¥æ± ç®¡ç†


**ä¸ºä»€ä¹ˆéœ€è¦è¿æ¥æ± **ï¼š
- åˆ›å»ºè¿æ¥å¾ˆ**è€—æ—¶**ï¼ˆç±»ä¼¼å¼€è½¦æ‰¾åœè½¦ä½ï¼‰
- é¢‘ç¹åˆ›å»ºè¿æ¥**æµªè´¹èµ„æº**ï¼ˆç±»ä¼¼æ¯æ¬¡å‡ºé—¨éƒ½è¦é‡æ–°ä¹°è½¦ï¼‰
- è¿æ¥æ•°é‡**æœ‰é™åˆ¶**ï¼ˆæœåŠ¡å™¨æ‰¿å—èƒ½åŠ›æœ‰é™ï¼‰

**ç®€å•è¿æ¥æ± å®ç°**ï¼š

```python
import pika
import threading
import queue
import time

class ConnectionPool:
    """RabbitMQè¿æ¥æ± ç®¡ç†å™¨"""
    
    def __init__(self, max_connections=10):
        self.max_connections = max_connections
        self.connections = queue.Queue(maxsize=max_connections)
        self.lock = threading.Lock()
        self._create_initial_connections()
    
    def _create_initial_connections(self):
        """åˆ›å»ºåˆå§‹è¿æ¥"""
        for _ in range(self.max_connections):
            connection = pika.BlockingConnection(
                pika.ConnectionParameters('localhost')
            )
            self.connections.put(connection)
        print(f"è¿æ¥æ± åˆå§‹åŒ–å®Œæˆï¼Œåˆ›å»ºäº† {self.max_connections} ä¸ªè¿æ¥")
    
    def get_connection(self):
        """è·å–ä¸€ä¸ªè¿æ¥"""
        try:
            # ç­‰å¾…æœ€å¤š5ç§’è·å–è¿æ¥
            connection = self.connections.get(timeout=5)
            return connection
        except queue.Empty:
            raise Exception("è¿æ¥æ± å·²æ»¡ï¼Œæ— æ³•è·å–è¿æ¥")
    
    def return_connection(self, connection):
        """å½’è¿˜è¿æ¥åˆ°æ± ä¸­"""
        if connection and not connection.is_closed:
            self.connections.put(connection)
        else:
            # è¿æ¥å·²æ–­å¼€ï¼Œåˆ›å»ºæ–°è¿æ¥
            new_connection = pika.BlockingConnection(
                pika.ConnectionParameters('localhost')
            )
            self.connections.put(new_connection)
    
    def close_all(self):
        """å…³é—­æ‰€æœ‰è¿æ¥"""
        while not self.connections.empty():
            connection = self.connections.get()
            connection.close()
        print("è¿æ¥æ± å·²å…³é—­")

# ä½¿ç”¨è¿æ¥æ± çš„æ¶ˆæ¯å‘é€å™¨
class PooledSender:
    def __init__(self, connection_pool):
        self.pool = connection_pool
    
    def send_message(self, queue_name, message):
        """ä½¿ç”¨è¿æ¥æ± å‘é€æ¶ˆæ¯"""
        connection = None
        try:
            # ä»æ± ä¸­è·å–è¿æ¥
            connection = self.pool.get_connection()
            channel = connection.channel()
            
            # å£°æ˜é˜Ÿåˆ—å¹¶å‘é€æ¶ˆæ¯
            channel.queue_declare(queue=queue_name)
            channel.basic_publish(
                exchange='',
                routing_key=queue_name,
                body=message
            )
            print(f"æ¶ˆæ¯å·²å‘é€: {message}")
            
        except Exception as e:
            print(f"å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
        finally:
            # æ— è®ºæˆåŠŸå¤±è´¥éƒ½è¦å½’è¿˜è¿æ¥
            if connection:
                self.pool.return_connection(connection)

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # åˆ›å»ºè¿æ¥æ± 
    pool = ConnectionPool(max_connections=5)
    sender = PooledSender(pool)
    
    # æ¨¡æ‹Ÿé«˜å¹¶å‘å‘é€æ¶ˆæ¯
    import concurrent.futures
    
    def send_batch_messages():
        for i in range(10):
            sender.send_message('test_queue', f'Message {i}')
            time.sleep(0.1)
    
    # åˆ›å»ºå¤šä¸ªçº¿ç¨‹åŒæ—¶å‘é€æ¶ˆæ¯
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        futures = [executor.submit(send_batch_messages) for _ in range(3)]
        
        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        for future in concurrent.futures.as_completed(futures):
            future.result()
    
    # æ¸…ç†èµ„æº
    pool.close_all()

if __name__ == "__main__":
    main()
```

### 3.3 è¿æ¥é‡è¿æœºåˆ¶


**ä¸ºä»€ä¹ˆéœ€è¦é‡è¿**ï¼š
- ç½‘ç»œå¯èƒ½**ä¸´æ—¶æ–­å¼€**ï¼ˆå°±åƒæ‰‹æœºä¿¡å·ä¸å¥½ï¼‰
- RabbitMQæœåŠ¡å™¨å¯èƒ½**é‡å¯ç»´æŠ¤**
- é•¿æ—¶é—´ä¸æ´»åŠ¨è¿æ¥å¯èƒ½è¢«**è‡ªåŠ¨å…³é—­**

```python
import pika
import time
import logging

class ReliableConnection:
    """å¸¦é‡è¿æœºåˆ¶çš„å¯é è¿æ¥"""
    
    def __init__(self, max_retries=5, retry_delay=2):
        self.connection = None
        self.channel = None
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.is_connected = False
    
    def connect(self):
        """è¿æ¥åˆ°RabbitMQï¼Œæ”¯æŒé‡è¯•"""
        for attempt in range(self.max_retries):
            try:
                print(f"å°è¯•è¿æ¥ RabbitMQ (ç¬¬ {attempt + 1} æ¬¡)...")
                
                self.connection = pika.BlockingConnection(
                    pika.ConnectionParameters(
                        host='localhost',
                        heartbeat=600,  # å¿ƒè·³æ£€æµ‹
                        blocked_connection_timeout=300  # é˜»å¡è¶…æ—¶
                    )
                )
                self.channel = self.connection.channel()
                self.is_connected = True
                print("âœ… RabbitMQè¿æ¥æˆåŠŸï¼")
                return True
                
            except Exception as e:
                print(f"âŒ è¿æ¥å¤±è´¥: {e}")
                if attempt < self.max_retries - 1:
                    print(f"ç­‰å¾… {self.retry_delay} ç§’åé‡è¯•...")
                    time.sleep(self.retry_delay)
                    self.retry_delay *= 2  # æŒ‡æ•°é€€é¿
                else:
                    print("ğŸš¨ è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè¿æ¥å¤±è´¥")
                    return False
    
    def send_message_with_retry(self, queue_name, message):
        """å‘é€æ¶ˆæ¯ï¼Œå¤±è´¥æ—¶è‡ªåŠ¨é‡è¿"""
        if not self.is_connected:
            if not self.connect():
                raise Exception("æ— æ³•å»ºç«‹è¿æ¥")
        
        try:
            # å°è¯•å‘é€æ¶ˆæ¯
            self.channel.queue_declare(queue=queue_name, durable=True)
            self.channel.basic_publish(
                exchange='',
                routing_key=queue_name,
                body=message,
                properties=pika.BasicProperties(delivery_mode=2)  # æŒä¹…åŒ–
            )
            print(f"âœ… æ¶ˆæ¯å‘é€æˆåŠŸ: {message}")
            
        except Exception as e:
            print(f"âŒ å‘é€å¤±è´¥ï¼Œå°è¯•é‡è¿: {e}")
            self.is_connected = False
            
            # é‡æ–°è¿æ¥å¹¶å†æ¬¡å°è¯•
            if self.connect():
                self.channel.queue_declare(queue=queue_name, durable=True)
                self.channel.basic_publish(
                    exchange='',
                    routing_key=queue_name,
                    body=message,
                    properties=pika.BasicProperties(delivery_mode=2)
                )
                print(f"âœ… é‡è¿åå‘é€æˆåŠŸ: {message}")
            else:
                raise Exception("é‡è¿å¤±è´¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯")
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.connection and not self.connection.is_closed:
            self.connection.close()
            self.is_connected = False
            print("è¿æ¥å·²å…³é—­")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    reliable_conn = ReliableConnection()
    
    try:
        # å‘é€ä¸€äº›æµ‹è¯•æ¶ˆæ¯
        for i in range(5):
            reliable_conn.send_message_with_retry(
                'reliable_queue', 
                f'å¯é æ¶ˆæ¯ {i+1}'
            )
            time.sleep(1)
            
    except Exception as e:
        print(f"ç¨‹åºé”™è¯¯: {e}")
    finally:
        reliable_conn.close()

if __name__ == "__main__":
    main()
```

---

## 4. ğŸ›¡ï¸ é”™è¯¯å¤„ç†æœºåˆ¶


### 4.1 å¸¸è§é”™è¯¯ç±»å‹ç†è§£


**RabbitMQå¼€å‘ä¸­çš„å¸¸è§é”™è¯¯**ï¼š
```
ğŸ”Œ è¿æ¥é”™è¯¯ï¼š
- æœåŠ¡å™¨æœªå¯åŠ¨ â†’ å°±åƒæ‰“ç”µè¯å¯¹æ–¹æ‰‹æœºå…³æœº
- ç½‘ç»œä¸é€š â†’ å°±åƒæ²¡æœ‰ç½‘ç»œä¿¡å·
- è®¤è¯å¤±è´¥ â†’ å°±åƒå¯†ç è¾“é”™äº†

ğŸ“® æ¶ˆæ¯é”™è¯¯ï¼š
- é˜Ÿåˆ—ä¸å­˜åœ¨ â†’ å°±åƒå¯„ä¿¡åˆ°ä¸å­˜åœ¨çš„åœ°å€
- æ¶ˆæ¯å¤ªå¤§ â†’ å°±åƒåŒ…è£¹è¶…é‡è¢«æ‹’æ”¶
- æ ¼å¼é”™è¯¯ â†’ å°±åƒå‘é€äº†ä¹±ç 

âš™ï¸ é…ç½®é”™è¯¯ï¼š
- å‚æ•°è®¾ç½®é”™è¯¯ â†’ å°±åƒæ‹¨é”™äº†ç”µè¯å·ç 
- æƒé™ä¸è¶³ â†’ å°±åƒæ²¡æœ‰å¼€é—¨é’¥åŒ™
```

### 4.2 å®Œæ•´çš„é”™è¯¯å¤„ç†ç¤ºä¾‹


```python
import pika
import json
import logging
from enum import Enum

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ErrorType(Enum):
    """é”™è¯¯ç±»å‹æšä¸¾"""
    CONNECTION_ERROR = "è¿æ¥é”™è¯¯"
    CHANNEL_ERROR = "é€šé“é”™è¯¯"
    MESSAGE_ERROR = "æ¶ˆæ¯é”™è¯¯"
    QUEUE_ERROR = "é˜Ÿåˆ—é”™è¯¯"

class RabbitMQHandler:
    """å¸¦å®Œæ•´é”™è¯¯å¤„ç†çš„RabbitMQå¤„ç†å™¨"""
    
    def __init__(self):
        self.connection = None
        self.channel = None
        self.error_stats = {
            'connection_errors': 0,
            'message_errors': 0,
            'total_messages': 0
        }
    
    def safe_connect(self):
        """å®‰å…¨è¿æ¥æ–¹æ³•"""
        try:
            self.connection = pika.BlockingConnection(
                pika.ConnectionParameters(
                    host='localhost',
                    port=5672,
                    virtual_host='/',
                    credentials=pika.PlainCredentials('guest', 'guest'),
                    heartbeat=600
                )
            )
            self.channel = self.connection.channel()
            logger.info("âœ… RabbitMQè¿æ¥å»ºç«‹æˆåŠŸ")
            return True
            
        except pika.exceptions.AMQPConnectionError as e:
            logger.error(f"âŒ AMQPè¿æ¥é”™è¯¯: {e}")
            self.error_stats['connection_errors'] += 1
            return False
            
        except pika.exceptions.ProbableAuthenticationError as e:
            logger.error(f"âŒ è®¤è¯å¤±è´¥: {e}")
            return False
            
        except Exception as e:
            logger.error(f"âŒ æœªçŸ¥è¿æ¥é”™è¯¯: {e}")
            return False
    
    def safe_send_message(self, queue_name, message_data):
        """å®‰å…¨å‘é€æ¶ˆæ¯æ–¹æ³•"""
        if not self.connection or self.connection.is_closed:
            if not self.safe_connect():
                return False
        
        try:
            # ç¡®ä¿æ¶ˆæ¯æ˜¯æœ‰æ•ˆçš„JSON
            if isinstance(message_data, dict):
                message_body = json.dumps(message_data, ensure_ascii=False)
            else:
                message_body = str(message_data)
            
            # å£°æ˜é˜Ÿåˆ—ï¼ˆç¡®ä¿é˜Ÿåˆ—å­˜åœ¨ï¼‰
            self.channel.queue_declare(
                queue=queue_name, 
                durable=True,  # é˜Ÿåˆ—æŒä¹…åŒ–
                arguments={'x-max-length': 10000}  # é˜Ÿåˆ—æœ€å¤§é•¿åº¦
            )
            
            # å‘é€æ¶ˆæ¯
            self.channel.basic_publish(
                exchange='',
                routing_key=queue_name,
                body=message_body,
                properties=pika.BasicProperties(
                    delivery_mode=2,  # æ¶ˆæ¯æŒä¹…åŒ–
                    content_type='application/json',
                    timestamp=int(time.time())
                )
            )
            
            self.error_stats['total_messages'] += 1
            logger.info(f"âœ… æ¶ˆæ¯å‘é€æˆåŠŸåˆ°é˜Ÿåˆ— '{queue_name}'")
            return True
            
        except pika.exceptions.AMQPChannelError as e:
            logger.error(f"âŒ é€šé“é”™è¯¯: {e}")
            self._handle_channel_error()
            return False
            
        except pika.exceptions.UnroutableError as e:
            logger.error(f"âŒ æ¶ˆæ¯æ— æ³•è·¯ç”±: {e}")
            self.error_stats['message_errors'] += 1
            return False
            
        except json.JSONEncodeError as e:
            logger.error(f"âŒ JSONç¼–ç é”™è¯¯: {e}")
            return False
            
        except Exception as e:
            logger.error(f"âŒ å‘é€æ¶ˆæ¯æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
            self.error_stats['message_errors'] += 1
            return False
    
    def safe_consume_messages(self, queue_name, callback_function):
        """å®‰å…¨æ¶ˆè´¹æ¶ˆæ¯æ–¹æ³•"""
        if not self.connection or self.connection.is_closed:
            if not self.safe_connect():
                return False
        
        try:
            # å£°æ˜é˜Ÿåˆ—
            self.channel.queue_declare(queue=queue_name, durable=True)
            
            # åŒ…è£…å›è°ƒå‡½æ•°ï¼Œå¢åŠ é”™è¯¯å¤„ç†
            def safe_callback(ch, method, properties, body):
                try:
                    # å°è¯•è§£æJSONæ¶ˆæ¯
                    try:
                        message_data = json.loads(body.decode('utf-8'))
                    except json.JSONDecodeError:
                        message_data = body.decode('utf-8')
                    
                    # è°ƒç”¨ç”¨æˆ·å®šä¹‰çš„å¤„ç†å‡½æ•°
                    result = callback_function(message_data)
                    
                    # æ ¹æ®å¤„ç†ç»“æœå†³å®šæ˜¯å¦ç¡®è®¤æ¶ˆæ¯
                    if result:
                        ch.basic_ack(delivery_tag=method.delivery_tag)
                        logger.info("âœ… æ¶ˆæ¯å¤„ç†æˆåŠŸå¹¶å·²ç¡®è®¤")
                    else:
                        ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)
                        logger.warning("âš ï¸ æ¶ˆæ¯å¤„ç†å¤±è´¥ï¼Œå·²é‡æ–°å…¥é˜Ÿ")
                        
                except Exception as e:
                    logger.error(f"âŒ æ¶ˆæ¯å¤„ç†å›è°ƒå‡ºé”™: {e}")
                    # å¤„ç†å¤±è´¥ï¼Œæ‹’ç»æ¶ˆæ¯ä½†ä¸é‡æ–°å…¥é˜Ÿï¼ˆé¿å…æ­»å¾ªç¯ï¼‰
                    ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
            
            # è®¾ç½®æ¶ˆè´¹è€…
            self.channel.basic_qos(prefetch_count=1)  # ä¸€æ¬¡åªå¤„ç†ä¸€æ¡æ¶ˆæ¯
            self.channel.basic_consume(
                queue=queue_name,
                on_message_callback=safe_callback
            )
            
            logger.info(f"ğŸ¯ å¼€å§‹ç›‘å¬é˜Ÿåˆ— '{queue_name}'ï¼ŒæŒ‰ CTRL+C åœæ­¢")
            self.channel.start_consuming()
            
        except KeyboardInterrupt:
            logger.info("â¹ï¸ ç”¨æˆ·ä¸­æ–­ï¼Œåœæ­¢æ¶ˆè´¹æ¶ˆæ¯")
            self.channel.stop_consuming()
            
        except pika.exceptions.AMQPChannelError as e:
            logger.error(f"âŒ æ¶ˆè´¹æ¶ˆæ¯æ—¶é€šé“é”™è¯¯: {e}")
            return False
            
        except Exception as e:
            logger.error(f"âŒ æ¶ˆè´¹æ¶ˆæ¯æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
            return False
        
        return True
    
    def _handle_channel_error(self):
        """å¤„ç†é€šé“é”™è¯¯"""
        try:
            if self.channel and not self.channel.is_closed:
                self.channel.close()
        except:
            pass
        
        # é‡æ–°åˆ›å»ºé€šé“
        if self.connection and not self.connection.is_closed:
            self.channel = self.connection.channel()
            logger.info("ğŸ”„ é€šé“å·²é‡æ–°åˆ›å»º")
    
    def get_error_stats(self):
        """è·å–é”™è¯¯ç»Ÿè®¡ä¿¡æ¯"""
        success_rate = 0
        if self.error_stats['total_messages'] > 0:
            success_count = (self.error_stats['total_messages'] - 
                           self.error_stats['message_errors'])
            success_rate = (success_count / self.error_stats['total_messages']) * 100
        
        return {
            'æ€»æ¶ˆæ¯æ•°': self.error_stats['total_messages'],
            'è¿æ¥é”™è¯¯æ•°': self.error_stats['connection_errors'],
            'æ¶ˆæ¯é”™è¯¯æ•°': self.error_stats['message_errors'],
            'æˆåŠŸç‡': f"{success_rate:.2f}%"
        }
    
    def close(self):
        """å®‰å…¨å…³é—­è¿æ¥"""
        try:
            if self.channel and not self.channel.is_closed:
                self.channel.close()
            if self.connection and not self.connection.is_closed:
                self.connection.close()
            logger.info("ğŸ”Œ è¿æ¥å·²å®‰å…¨å…³é—­")
        except Exception as e:
            logger.error(f"å…³é—­è¿æ¥æ—¶å‡ºé”™: {e}")

# ä½¿ç”¨ç¤ºä¾‹
def message_processor(message_data):
    """æ¶ˆæ¯å¤„ç†å‡½æ•°ç¤ºä¾‹"""
    try:
        print(f"å¤„ç†æ¶ˆæ¯: {message_data}")
        
        # æ¨¡æ‹Ÿå¤„ç†é€»è¾‘
        if isinstance(message_data, dict) and 'error' in message_data:
            raise ValueError("æ¶ˆæ¯åŒ…å«é”™è¯¯æ ‡è®°")
        
        # å¤„ç†æˆåŠŸ
        return True
        
    except Exception as e:
        print(f"å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™: {e}")
        return False

def main():
    handler = RabbitMQHandler()
    
    try:
        # å‘é€ä¸€äº›æµ‹è¯•æ¶ˆæ¯
        test_messages = [
            {'type': 'order', 'id': 1, 'amount': 100},
            {'type': 'payment', 'id': 2, 'status': 'success'},
            {'type': 'error', 'message': 'è¿™ä¼šå¯¼è‡´å¤„ç†å¤±è´¥'},  # æ•…æ„çš„é”™è¯¯æ¶ˆæ¯
            'Simple text message',
        ]
        
        for msg in test_messages:
            handler.safe_send_message('test_queue', msg)
            time.sleep(0.5)
        
        # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        stats = handler.get_error_stats()
        print(f"\nğŸ“Š ç»Ÿè®¡ä¿¡æ¯: {stats}")
        
        # æ¶ˆè´¹æ¶ˆæ¯ï¼ˆå–æ¶ˆæ³¨é‡Šä¸‹é¢çš„ä»£ç æ¥æµ‹è¯•æ¶ˆè´¹ï¼‰
        # handler.safe_consume_messages('test_queue', message_processor)
        
    except Exception as e:
        logger.error(f"ä¸»ç¨‹åºé”™è¯¯: {e}")
    finally:
        handler.close()

if __name__ == "__main__":
    import time
    main()
```

---

## 5. ğŸš€ æ€§èƒ½ä¼˜åŒ–æŠ€å·§


### 5.1 æ¶ˆæ¯æ‰¹é‡å¤„ç†


**ä¸ºä»€ä¹ˆéœ€è¦æ‰¹é‡å¤„ç†**ï¼š
```
å•æ¡å‘é€æ¨¡å¼ï¼š
å‘é€1æ¡ â†’ ç­‰å¾…ç¡®è®¤ â†’ å‘é€1æ¡ â†’ ç­‰å¾…ç¡®è®¤ â†’ ... (æ…¢)

æ‰¹é‡å‘é€æ¨¡å¼ï¼š
å‘é€100æ¡ â†’ ä¸€æ¬¡ç¡®è®¤ â†’ å‘é€100æ¡ â†’ ä¸€æ¬¡ç¡®è®¤ â†’ ... (å¿«)

å°±åƒåç”µæ¢¯ï¼š
å•äººæ¨¡å¼ï¼šæ¯ä¸ªäººå•ç‹¬åç”µæ¢¯ï¼ˆæ•ˆç‡ä½ï¼‰
æ‰¹é‡æ¨¡å¼ï¼šç­‰äººæ»¡äº†å†å¼€ç”µæ¢¯ï¼ˆæ•ˆç‡é«˜ï¼‰
```

```python
import pika
import time
import json

class BatchProcessor:
    """æ‰¹é‡æ¶ˆæ¯å¤„ç†å™¨"""
    
    def __init__(self, batch_size=100, flush_interval=5):
        self.connection = None
        self.channel = None
        self.batch_size = batch_size  # æ‰¹é‡å¤§å°
        self.flush_interval = flush_interval  # å¼ºåˆ¶åˆ·æ–°é—´éš”ï¼ˆç§’ï¼‰
        self.message_buffer = []  # æ¶ˆæ¯ç¼“å†²åŒº
        self.last_flush_time = time.time()
        
    def connect(self):
        """å»ºç«‹è¿æ¥"""
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters('localhost')
        )
        self.channel = self.connection.channel()
        
        # å¼€å¯å‘å¸ƒç¡®è®¤æ¨¡å¼
        self.channel.confirm_delivery()
        print("æ‰¹é‡å¤„ç†å™¨å·²å¯åŠ¨")
    
    def add_message(self, queue_name, message_data):
        """æ·»åŠ æ¶ˆæ¯åˆ°æ‰¹é‡é˜Ÿåˆ—"""
        message_info = {
            'queue': queue_name,
            'body': json.dumps(message_data) if isinstance(message_data, dict) else str(message_data),
            'timestamp': time.time()
        }
        
        self.message_buffer.append(message_info)
        print(f"ğŸ“ æ¶ˆæ¯å·²åŠ å…¥æ‰¹é‡é˜Ÿåˆ— (å½“å‰ç¼“å†²: {len(self.message_buffer)}/{self.batch_size})")
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°
        self._check_and_flush()
    
    def _check_and_flush(self):
        """æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°ç¼“å†²åŒº"""
        current_time = time.time()
        should_flush = (
            len(self.message_buffer) >= self.batch_size or  # è¾¾åˆ°æ‰¹é‡å¤§å°
            (current_time - self.last_flush_time) >= self.flush_interval  # è¶…è¿‡æ—¶é—´é—´éš”
        )
        
        if should_flush and self.message_buffer:
            self.flush_messages()
    
    def flush_messages(self):
        """æ‰¹é‡å‘é€æ‰€æœ‰ç¼“å†²çš„æ¶ˆæ¯"""
        if not self.message_buffer:
            return
        
        start_time = time.time()
        sent_count = 0
        
        try:
            # æŒ‰é˜Ÿåˆ—åˆ†ç»„æ¶ˆæ¯
            queue_groups = {}
            for msg in self.message_buffer:
                queue_name = msg['queue']
                if queue_name not in queue_groups:
                    queue_groups[queue_name] = []
                queue_groups[queue_name].append(msg)
            
            # æ‰¹é‡å‘é€æ¯ä¸ªé˜Ÿåˆ—çš„æ¶ˆæ¯
            for queue_name, messages in queue_groups.items():
                # å£°æ˜é˜Ÿåˆ—
                self.channel.queue_declare(queue=queue_name, durable=True)
                
                # æ‰¹é‡å‘é€
                for msg in messages:
                    self.channel.basic_publish(
                        exchange='',
                        routing_key=queue_name,
                        body=msg['body'],
                        properties=pika.BasicProperties(
                            delivery_mode=2,  # æŒä¹…åŒ–
                            timestamp=int(msg['timestamp'])
                        )
                    )
                    sent_count += 1
            
            # æ¸…ç©ºç¼“å†²åŒº
            self.message_buffer.clear()
            self.last_flush_time = time.time()
            
            elapsed_time = time.time() - start_time
            rate = sent_count / elapsed_time if elapsed_time > 0 else 0
            
            print(f"âœ… æ‰¹é‡å‘é€å®Œæˆ: {sent_count} æ¡æ¶ˆæ¯ï¼Œè€—æ—¶ {elapsed_time:.3f} ç§’ï¼Œé€Ÿç‡ {rate:.1f} æ¶ˆæ¯/ç§’")
            
        except Exception as e:
            print(f"âŒ æ‰¹é‡å‘é€å¤±è´¥: {e}")
            # å‘é€å¤±è´¥ï¼Œä¿ç•™æ¶ˆæ¯ä»¥ä¾¿é‡è¯•
            # è¿™é‡Œå¯ä»¥æ·»åŠ é‡è¯•é€»è¾‘
    
    def close(self):
        """å…³é—­å¤„ç†å™¨"""
        # å‘é€å‰©ä½™æ¶ˆæ¯
        self.flush_messages()
        
        if self.connection and not self.connection.is_closed:
            self.connection.close()
        print("æ‰¹é‡å¤„ç†å™¨å·²å…³é—­")

# æ€§èƒ½æµ‹è¯•ç¤ºä¾‹
def performance_test():
    """æ€§èƒ½æµ‹è¯•ï¼šæ¯”è¾ƒæ‰¹é‡vså•æ¡å‘é€"""
    
    print("ğŸ å¼€å§‹æ€§èƒ½æµ‹è¯•...")
    
    # æµ‹è¯•æ•°æ®
    test_messages = [
        {'id': i, 'data': f'Test message {i}', 'type': 'performance_test'}
        for i in range(1000)
    ]
    
    # å•æ¡å‘é€æµ‹è¯•
    print("\nğŸ“Š æµ‹è¯•1: å•æ¡å‘é€æ¨¡å¼")
    start_time = time.time()
    
    connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
    channel = connection.channel()
    channel.queue_declare(queue='single_test', durable=True)
    
    for msg in test_messages:
        channel.basic_publish(
            exchange='',
            routing_key='single_test',
            body=json.dumps(msg),
            properties=pika.BasicProperties(delivery_mode=2)
        )
    
    connection.close()
    single_time = time.time() - start_time
    single_rate = len(test_messages) / single_time
    
    print(f"å•æ¡å‘é€: {len(test_messages)} æ¡æ¶ˆæ¯ï¼Œè€—æ—¶ {single_time:.3f} ç§’ï¼Œé€Ÿç‡ {single_rate:.1f} æ¶ˆæ¯/ç§’")
    
    # æ‰¹é‡å‘é€æµ‹è¯•
    print("\nğŸ“Š æµ‹è¯•2: æ‰¹é‡å‘é€æ¨¡å¼")
    start_time = time.time()
    
    batch_processor = BatchProcessor(batch_size=50)
    batch_processor.connect()
    
    for msg in test_messages:
        batch_processor.add_message('batch_test', msg)
    
    batch_processor.close()
    batch_time = time.time() - start_time
    batch_rate = len(test_messages) / batch_time
    
    print(f"æ‰¹é‡å‘é€: {len(test_messages)} æ¡æ¶ˆæ¯ï¼Œè€—æ—¶ {batch_time:.3f} ç§’ï¼Œé€Ÿç‡ {batch_rate:.1f} æ¶ˆæ¯/ç§’")
    
    # æ€§èƒ½å¯¹æ¯”
    improvement = (single_time - batch_time) / single_time * 100
    print(f"\nğŸ“ˆ æ€§èƒ½æå‡: {improvement:.1f}%ï¼Œæ‰¹é‡æ¨¡å¼æ¯”å•æ¡æ¨¡å¼å¿« {batch_rate/single_rate:.1f} å€")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # åˆ›å»ºæ‰¹é‡å¤„ç†å™¨
    processor = BatchProcessor(batch_size=10, flush_interval=3)
    processor.connect()
    
    try:
        # æ¨¡æ‹Ÿæ·»åŠ æ¶ˆæ¯
        for i in range(25):
            message_data = {
                'order_id': f'ORDER_{i:03d}',
                'amount': (i + 1) * 10,
                'status': 'pending'
            }
            processor.add_message('order_queue', message_data)
            time.sleep(0.2)  # æ¨¡æ‹Ÿæ¶ˆæ¯äº§ç”Ÿé—´éš”
        
        print("\næ‰€æœ‰æ¶ˆæ¯å·²æ·»åŠ ï¼Œç­‰å¾…æœ€ç»ˆåˆ·æ–°...")
        time.sleep(2)  # ç­‰å¾…è‡ªåŠ¨åˆ·æ–°
        
    except KeyboardInterrupt:
        print("\nç”¨æˆ·ä¸­æ–­")
    finally:
        processor.close()

if __name__ == "__main__":
    # è¿è¡Œæ­£å¸¸ç¤ºä¾‹
    main()
    
    # è¿è¡Œæ€§èƒ½æµ‹è¯•ï¼ˆå–æ¶ˆæ³¨é‡Šä¸‹è¡Œï¼‰
    # performance_test()
```

### 5.2 è¿æ¥å¤ç”¨å’Œé€šé“ç®¡ç†


```python
import threading
import queue
import time
from contextlib import contextmanager

class ChannelManager:
    """é€šé“ç®¡ç†å™¨ - å®ç°è¿æ¥å¤ç”¨"""
    
    def __init__(self, max_channels=20):
        self.connection = None
        self.channel_pool = queue.Queue(maxsize=max_channels)
        self.max_channels = max_channels
        self.lock = threading.Lock()
        self._initialize()
    
    def _initialize(self):
        """åˆå§‹åŒ–è¿æ¥å’Œé€šé“æ± """
        # åˆ›å»ºå•ä¸ªè¿æ¥
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                heartbeat=600,
                blocked_connection_timeout=300
            )
        )
        
        # åˆ›å»ºé€šé“æ± 
        for _ in range(self.max_channels):
            channel = self.connection.channel()
            self.channel_pool.put(channel)
        
        print(f"âœ… é€šé“ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œåˆ›å»ºäº† {self.max_channels} ä¸ªé€šé“")
    
    @contextmanager
    def get_channel(self):
        """è·å–é€šé“çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        channel = None
        try:
            # è·å–é€šé“ï¼ˆæœ€å¤šç­‰å¾…5ç§’ï¼‰
            channel = self.channel_pool.get(timeout=5)
            yield channel
        except queue.Empty:
            raise Exception("é€šé“æ± å·²è€—å°½ï¼Œè¯·ç¨åé‡è¯•")
        finally:
            # ç¡®ä¿é€šé“è¢«å½’è¿˜
            if channel and not channel.is_closed:
                self.channel_pool.put(channel)
    
    def send_message_efficient(self, queue_name, message):
        """é«˜æ•ˆå‘é€æ¶ˆæ¯"""
        with self.get_channel() as channel:
            channel.queue_declare(queue=queue_name, durable=True)
            channel.basic_publish(
                exchange='',
                routing_key=queue_name,
                body=message,
                properties=pika.BasicProperties(delivery_mode=2)
            )
    
    def close(self):
        """å…³é—­ç®¡ç†å™¨"""
        # æ¸…ç©ºé€šé“æ± 
        while not self.channel_pool.empty():
            try:
                channel = self.channel_pool.get_nowait()
                if not channel.is_closed:
                    channel.close()
            except queue.Empty:
                break
        
        # å…³é—­è¿æ¥
        if self.connection and not self.connection.is_closed:
            self.connection.close()
        
        print("é€šé“ç®¡ç†å™¨å·²å…³é—­")

# å¤šçº¿ç¨‹ä½¿ç”¨ç¤ºä¾‹
def worker_thread(manager, thread_id, message_count):
    """å·¥ä½œçº¿ç¨‹å‡½æ•°"""
    for i in range(message_count):
        try:
            message = f"Thread-{thread_id} Message-{i+1}"
            manager.send_message_efficient('worker_queue', message)
            print(f"ğŸ§µ çº¿ç¨‹{thread_id}: å·²å‘é€æ¶ˆæ¯ {i+1}/{message_count}")
            time.sleep(0.1)
        except Exception as e:
            print(f"âŒ çº¿ç¨‹{thread_id}å‘é€å¤±è´¥: {e}")

def test_concurrent_sending():
    """æµ‹è¯•å¹¶å‘å‘é€"""
    manager = ChannelManager(max_channels=10)
    
    try:
        # åˆ›å»ºå¤šä¸ªçº¿ç¨‹
        threads = []
        thread_count = 5
        messages_per_thread = 20
        
        print(f"ğŸš€ å¯åŠ¨ {thread_count} ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹å‘é€ {messages_per_thread} æ¡æ¶ˆæ¯")
        
        start_time = time.time()
        
        for i in range(thread_count):
            thread = threading.Thread(
                target=worker_thread,
                args=(manager, i+1, messages_per_thread)
            )
            threads.append(thread)
            thread.start()
        
        # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for thread in threads:
            thread.join()
        
        total_time = time.time() - start_time
        total_messages = thread_count * messages_per_thread
        rate = total_messages / total_time
        
        print(f"âœ… å¹¶å‘æµ‹è¯•å®Œæˆ:")
        print(f"   æ€»æ¶ˆæ¯æ•°: {total_messages}")
        print(f"   æ€»è€—æ—¶: {total_time:.3f} ç§’")
        print(f"   å‘é€é€Ÿç‡: {rate:.1f} æ¶ˆæ¯/ç§’")
        
    finally:
        manager.close()

if __name__ == "__main__":
    test_concurrent_sending()
```

### 5.3 æ¶ˆæ¯é¢„å–å’Œç¡®è®¤ä¼˜åŒ–


| ä¼˜åŒ–ç­–ç•¥ | **ä½œç”¨** | **é€‚ç”¨åœºæ™¯** | **æ³¨æ„äº‹é¡¹** |
|---------|---------|-------------|-------------|
| ğŸ¯ **é¢„å–æ§åˆ¶** | `æ§åˆ¶æœªç¡®è®¤æ¶ˆæ¯æ•°é‡` | `é˜²æ­¢æ¶ˆè´¹è€…è¿‡è½½` | `æ ¹æ®å¤„ç†èƒ½åŠ›è®¾ç½®` |
| âš¡ **æ‰¹é‡ç¡®è®¤** | `å‡å°‘ç½‘ç»œå¾€è¿”æ¬¡æ•°` | `é«˜ååé‡åœºæ™¯` | `å¯èƒ½ä¸¢å¤±æ¶ˆæ¯ç²¾åº¦` |
| ğŸ”„ **æ‰‹åŠ¨ç¡®è®¤** | `ç¡®ä¿æ¶ˆæ¯ä¸ä¸¢å¤±` | `é‡è¦ä¸šåŠ¡æ¶ˆæ¯` | `å¢åŠ ä»£ç å¤æ‚åº¦` |
| ğŸ“¦ **æ¶ˆæ¯æŒä¹…åŒ–** | `é˜²æ­¢æœåŠ¡å™¨é‡å¯ä¸¢æ¶ˆæ¯` | `å…³é”®ä¸šåŠ¡æ•°æ®` | `å½±å“æ€§èƒ½` |

```python
class OptimizedConsumer:
    """ä¼˜åŒ–çš„æ¶ˆæ¯æ¶ˆè´¹è€…"""
    
    def __init__(self, prefetch_count=10):
        self.connection = None
        self.channel = None
        self.prefetch_count = prefetch_count
        self.processing_stats = {
            'processed': 0,
            'failed': 0,
            'start_time': time.time()
        }
    
    def setup(self):
        """è®¾ç½®ä¼˜åŒ–çš„æ¶ˆè´¹è€…"""
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters('localhost')
        )
        self.channel = self.connection.channel()
        
        # å…³é”®ä¼˜åŒ–ï¼šè®¾ç½®é¢„å–æ•°é‡
        self.channel.basic_qos(prefetch_count=self.prefetch_count)
        
        print(f"âœ… æ¶ˆè´¹è€…è®¾ç½®å®Œæˆï¼Œé¢„å–æ•°é‡: {self.prefetch_count}")
    
    def process_message(self, ch, method, properties, body):
        """ä¼˜åŒ–çš„æ¶ˆæ¯å¤„ç†"""
        start_time = time.time()
        
        try:
            # è§£ææ¶ˆæ¯
            message_data = json.loads(body.decode('utf-8'))
            
            # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†ï¼ˆå¯èƒ½è€—æ—¶ï¼‰
            process_time = message_data.get('process_time', 0.1)
            time.sleep(process_time)
            
            # å¤„ç†æˆåŠŸ
            ch.basic_ack(delivery_tag=method.delivery_tag)
            self.processing_stats['processed'] += 1
            
            elapsed = time.time() - start_time
            print(f"âœ… æ¶ˆæ¯å¤„ç†æˆåŠŸï¼Œè€—æ—¶ {elapsed:.3f} ç§’")
            
        except Exception as e:
            # å¤„ç†å¤±è´¥
            ch.basic_nack(
                delivery_tag=method.delivery_tag,
                requeue=True  # é‡æ–°å…¥é˜Ÿé‡è¯•
            )
            self.processing_stats['failed'] += 1
            print(f"âŒ æ¶ˆæ¯å¤„ç†å¤±è´¥: {e}")
    
    def start_consuming(self, queue_name):
        """å¼€å§‹æ¶ˆè´¹æ¶ˆæ¯"""
        self.channel.queue_declare(queue=queue_name, durable=True)
        self.channel.basic_consume(
            queue=queue_name,
            on_message_callback=self.process_message
        )
        
        print(f"ğŸ¯ å¼€å§‹æ¶ˆè´¹é˜Ÿåˆ— '{queue_name}'")
        try:
            self.channel.start_consuming()
        except KeyboardInterrupt:
            print("\nâ¹ï¸ åœæ­¢æ¶ˆè´¹")
            self.channel.stop_consuming()
            self.print_stats()
    
    def print_stats(self):
        """æ‰“å°ç»Ÿè®¡ä¿¡æ¯"""
        total_time = time.time() - self.processing_stats['start_time']
        total_processed = self.processing_stats['processed']
        rate = total_processed / total_time if total_time > 0 else 0
        
        print(f"\nğŸ“Š æ¶ˆè´¹ç»Ÿè®¡:")
        print(f"   å¤„ç†æˆåŠŸ: {self.processing_stats['processed']}")
        print(f"   å¤„ç†å¤±è´¥: {self.processing_stats['failed']}")
        print(f"   æ€»è€—æ—¶: {total_time:.3f} ç§’")
        print(f"   å¤„ç†é€Ÿç‡: {rate:.1f} æ¶ˆæ¯/ç§’")
    
    def close(self):
        """å…³é—­æ¶ˆè´¹è€…"""
        if self.connection and not self.connection.is_closed:
            self.connection.close()
```

---

## 6. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 6.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ pikaå®¢æˆ·ç«¯ï¼šPythonä¸RabbitMQé€šä¿¡çš„æ¡¥æ¢å·¥å…·
ğŸ”¸ å¼‚æ­¥å¤„ç†ï¼šæå‡æ€§èƒ½çš„å…³é”®æŠ€æœ¯ï¼Œé€‚åˆé«˜å¹¶å‘åœºæ™¯
ğŸ”¸ è¿æ¥ç®¡ç†ï¼šåˆç†å¤ç”¨è¿æ¥ï¼Œé¿å…èµ„æºæµªè´¹
ğŸ”¸ é”™è¯¯å¤„ç†ï¼šä¿è¯ç¨‹åºç¨³å®šæ€§çš„é‡è¦æœºåˆ¶
ğŸ”¸ æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡å¤„ç†ã€è¿æ¥å¤ç”¨ã€é¢„å–æ§åˆ¶ç­‰æŠ€å·§
```

### 6.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä»€ä¹ˆæ—¶å€™é€‰æ‹©åŒæ­¥vså¼‚æ­¥**
```
é€‰æ‹©åŒæ­¥æ¨¡å¼ï¼š
- åˆå­¦é˜¶æ®µï¼Œæ³¨é‡ç†è§£å’Œè°ƒè¯•
- ç®€å•åº”ç”¨ï¼Œæ¶ˆæ¯é‡ä¸å¤§
- é¡ºåºå¤„ç†å¾ˆé‡è¦çš„åœºæ™¯

é€‰æ‹©å¼‚æ­¥æ¨¡å¼ï¼š
- é«˜å¹¶å‘ã€é«˜æ€§èƒ½è¦æ±‚
- å¤§é‡æ¶ˆæ¯éœ€è¦å¤„ç†
- ç³»ç»Ÿèµ„æºéœ€è¦å……åˆ†åˆ©ç”¨
```

**ğŸ”¹ è¿æ¥å’Œé€šé“çš„æœ€ä½³å®è·µ**
```
è¿æ¥ï¼ˆConnectionï¼‰ï¼š
- åº”ç”¨çº§åˆ«å…±äº«ï¼Œä¸è¦é¢‘ç¹åˆ›å»º
- éœ€è¦å®ç°é‡è¿æœºåˆ¶
- ç›‘æ§è¿æ¥çŠ¶æ€

é€šé“ï¼ˆChannelï¼‰ï¼š
- çº¿ç¨‹çº§åˆ«ä½¿ç”¨ï¼Œå¯ä»¥åˆ›å»ºå¤šä¸ª
- å‡ºé”™æ—¶éœ€è¦é‡æ–°åˆ›å»º
- è®¾ç½®åˆç†çš„é¢„å–æ•°é‡
```

**ğŸ”¹ é”™è¯¯å¤„ç†çš„å±‚æ¬¡**
```
è¿æ¥å±‚é”™è¯¯ï¼šç½‘ç»œã€è®¤è¯ã€æœåŠ¡å™¨çŠ¶æ€
æ¶ˆæ¯å±‚é”™è¯¯ï¼šæ ¼å¼ã€å¤§å°ã€è·¯ç”±é—®é¢˜
ä¸šåŠ¡å±‚é”™è¯¯ï¼šå¤„ç†é€»è¾‘ã€æ•°æ®éªŒè¯é—®é¢˜
```

### 6.3 å®é™…å¼€å‘å»ºè®®


**ğŸ“ ä»£ç ç»„ç»‡å»ºè®®**ï¼š
- åˆ›å»ºä¸“é—¨çš„RabbitMQå·¥å…·ç±»
- ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- é…ç½®åŒ–è¿æ¥å‚æ•°
- å®ç°ä¼˜é›…çš„å…³é—­æœºåˆ¶

**ğŸ¯ æ€§èƒ½ä¼˜åŒ–ä¼˜å…ˆçº§**ï¼š
1. **è¿æ¥å¤ç”¨** - æœ€åŸºç¡€çš„ä¼˜åŒ–
2. **æ‰¹é‡å¤„ç†** - æ˜¾è‘—æå‡ååé‡
3. **é¢„å–æ§åˆ¶** - å¹³è¡¡å†…å­˜å’Œæ€§èƒ½
4. **å¼‚æ­¥å¤„ç†** - åº”å¯¹é«˜å¹¶å‘åœºæ™¯

**âš ï¸ å¸¸è§é™·é˜±é¿å…**ï¼š
- ä¸è¦åœ¨æ¯æ¬¡å‘é€æ¶ˆæ¯æ—¶éƒ½åˆ›å»ºæ–°è¿æ¥
- ä¸è¦å¿½ç•¥é”™è¯¯å¤„ç†å’Œé‡è¿æœºåˆ¶
- ä¸è¦è®¾ç½®è¿‡å¤§çš„é¢„å–æ•°é‡
- ä¸è¦å¿˜è®°æ­£ç¡®å…³é—­è¿æ¥å’Œé€šé“

**æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
- pikaè¿æ¥è¦å¤ç”¨ï¼Œå¼‚æ­¥å¤„ç†æ€§èƒ½ä¼˜
- é”™è¯¯å¤„ç†è¦å®Œå–„ï¼Œæ‰¹é‡å‘é€æ•ˆç‡é«˜
- é€šé“ç®¡ç†è¦åˆç†ï¼Œé¢„å–æ§åˆ¶é˜²è¿‡è½½