---
title: 5ã€Goè¯­è¨€å¼€å‘
---
## ğŸ“š ç›®å½•

1. [Goå®¢æˆ·ç«¯åŸºç¡€å…¥é—¨](#1-Goå®¢æˆ·ç«¯åŸºç¡€å…¥é—¨)
2. [amqp091-goå®¢æˆ·ç«¯è¯¦è§£](#2-amqp091-goå®¢æˆ·ç«¯è¯¦è§£)
3. [è¿æ¥ç®¡ç†ä¸è¿æ¥æ± ](#3-è¿æ¥ç®¡ç†ä¸è¿æ¥æ± )
4. [å¹¶å‘æ¨¡å¼è®¾è®¡](#4-å¹¶å‘æ¨¡å¼è®¾è®¡)
5. [Contextä¸Šä¸‹æ–‡ä½¿ç”¨](#5-Contextä¸Šä¸‹æ–‡ä½¿ç”¨)
6. [é”™è¯¯å¤„ç†ç­–ç•¥](#6-é”™è¯¯å¤„ç†ç­–ç•¥)
7. [ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ](#7-ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸš€ Goå®¢æˆ·ç«¯åŸºç¡€å…¥é—¨


### 1.1 ä¸ºä»€ä¹ˆé€‰æ‹©Goå¼€å‘RabbitMQåº”ç”¨


**Goè¯­è¨€çš„å¤©ç„¶ä¼˜åŠ¿**ï¼š
```
ğŸ”¸ å¹¶å‘åŸç”Ÿæ”¯æŒï¼šgoroutineè½»é‡çº§åç¨‹ï¼Œå¤©ç„¶é€‚åˆæ¶ˆæ¯å¤„ç†
ğŸ”¸ æ€§èƒ½ä¼˜ç§€ï¼šç¼–è¯‘å‹è¯­è¨€ï¼Œè¿è¡Œæ•ˆç‡é«˜
ğŸ”¸ ç®€æ´è¯­æ³•ï¼šä»£ç æ¸…æ™°æ˜“ç»´æŠ¤
ğŸ”¸ ä¸°å¯Œç”Ÿæ€ï¼šå®Œå–„çš„RabbitMQå®¢æˆ·ç«¯åº“
```

> ğŸ’¡ **æ ¸å¿ƒç†è§£**ï¼šGoè¯­è¨€çš„å¹¶å‘ç‰¹æ€§ä¸RabbitMQçš„å¼‚æ­¥æ¶ˆæ¯å¤„ç†æ¨¡å¼å®Œç¾å¥‘åˆï¼Œèƒ½å¤Ÿé«˜æ•ˆå¤„ç†å¤§é‡å¹¶å‘çš„æ¶ˆæ¯ç”Ÿäº§å’Œæ¶ˆè´¹ä»»åŠ¡ã€‚

### 1.2 ç¯å¢ƒå‡†å¤‡


**å®‰è£…ä¾èµ–åŒ…**ï¼š
```bash
# å®‰è£…å®˜æ–¹æ¨èçš„amqp091-goå®¢æˆ·ç«¯
go mod init rabbitmq-demo
go get github.com/rabbitmq/amqp091-go
```

**åŸºæœ¬é¡¹ç›®ç»“æ„**ï¼š
```
rabbitmq-demo/
â”œâ”€â”€ main.go           # ä¸»ç¨‹åºå…¥å£
â”œâ”€â”€ config/           # é…ç½®ç®¡ç†
â”œâ”€â”€ producer/         # ç”Ÿäº§è€…ç›¸å…³
â”œâ”€â”€ consumer/         # æ¶ˆè´¹è€…ç›¸å…³
â”œâ”€â”€ connection/       # è¿æ¥ç®¡ç†
â””â”€â”€ utils/           # å·¥å…·å‡½æ•°
```

### 1.3 å¿«é€Ÿä¸Šæ‰‹ç¤ºä¾‹


**æœ€ç®€å•çš„å‘é€æ¶ˆæ¯**ï¼š
```go
package main

import (
    "log"
    amqp "github.com/rabbitmq/amqp091-go"
)

func main() {
    // 1. å»ºç«‹è¿æ¥
    conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
    if err != nil {
        log.Fatal("è¿æ¥å¤±è´¥:", err)
    }
    defer conn.Close()
    
    // 2. åˆ›å»ºä¿¡é“
    ch, err := conn.Channel()
    if err != nil {
        log.Fatal("åˆ›å»ºä¿¡é“å¤±è´¥:", err)
    }
    defer ch.Close()
    
    // 3. å£°æ˜é˜Ÿåˆ—
    queue, err := ch.QueueDeclare(
        "hello",    // é˜Ÿåˆ—å
        false,      // æ˜¯å¦æŒä¹…åŒ–
        false,      // æ˜¯å¦è‡ªåŠ¨åˆ é™¤
        false,      // æ˜¯å¦ç‹¬å 
        false,      // æ˜¯å¦é˜»å¡ç­‰å¾…
        nil,        // é¢å¤–å‚æ•°
    )
    if err != nil {
        log.Fatal("å£°æ˜é˜Ÿåˆ—å¤±è´¥:", err)
    }
    
    // 4. å‘é€æ¶ˆæ¯
    message := "Hello RabbitMQ!"
    err = ch.Publish(
        "",           // exchange
        queue.Name,   // routing key
        false,        // mandatory
        false,        // immediate
        amqp.Publishing{
            ContentType: "text/plain",
            Body:        []byte(message),
        })
    
    if err != nil {
        log.Fatal("å‘é€æ¶ˆæ¯å¤±è´¥:", err)
    }
    
    log.Printf("æ¶ˆæ¯å‘é€æˆåŠŸ: %s", message)
}
```

---

## 2. ğŸ“¦ amqp091-goå®¢æˆ·ç«¯è¯¦è§£


### 2.1 å®¢æˆ·ç«¯åº“ä»‹ç»


**amqp091-goç‰¹ç‚¹**ï¼š
```
ğŸ”¸ å®˜æ–¹ç»´æŠ¤ï¼šRabbitMQå®˜æ–¹ç»´æŠ¤çš„Goå®¢æˆ·ç«¯
ğŸ”¸ AMQP 0.9.1ï¼šå®Œæ•´æ”¯æŒAMQP 0.9.1åè®®
ğŸ”¸ çº¿ç¨‹å®‰å…¨ï¼šæ”¯æŒå¹¶å‘ä½¿ç”¨
ğŸ”¸ åŠŸèƒ½å®Œæ•´ï¼šæ”¯æŒæ‰€æœ‰RabbitMQç‰¹æ€§
```

> âš ï¸ **æ³¨æ„**ï¼šè¿™ä¸ªåº“æ›¿ä»£äº†ä¹‹å‰çš„`streadway/amqp`ï¼Œæ˜¯ç›®å‰å®˜æ–¹æ¨èçš„Goå®¢æˆ·ç«¯ã€‚

### 2.2 æ ¸å¿ƒå¯¹è±¡è¯¦è§£


**Connectionï¼ˆè¿æ¥ï¼‰**ï¼š
```go
// Connectionä»£è¡¨ä¸RabbitMQæœåŠ¡å™¨çš„TCPè¿æ¥
type Connection struct {
    // å†…éƒ¨å­—æ®µï¼Œä¸ç›´æ¥æ“ä½œ
}

// è¿æ¥é…ç½®
config := amqp.Config{
    Heartbeat: 10 * time.Second,  // å¿ƒè·³é—´éš”
    Locale:    "en_US",           // åœ°åŒºè®¾ç½®
}

conn, err := amqp.DialConfig("amqp://localhost:5672/", config)
```

**Channelï¼ˆä¿¡é“ï¼‰**ï¼š
```go
// Channelæ˜¯åœ¨è¿æ¥ä¸Šçš„è™šæ‹Ÿè¿æ¥
// å¤§éƒ¨åˆ†AMQPæ“ä½œéƒ½åœ¨ä¿¡é“ä¸Šè¿›è¡Œ
ch, err := conn.Channel()

// ä¿¡é“é…ç½®
err = ch.Qos(
    10,    // prefetchCountï¼šé¢„å–æ¶ˆæ¯æ•°
    0,     // prefetchSizeï¼šé¢„å–å¤§å°(0è¡¨ç¤ºæ— é™åˆ¶)
    false, // globalï¼šæ˜¯å¦å…¨å±€è®¾ç½®
)
```

### 2.3 æ¶ˆæ¯å‘å¸ƒè¯¦è§£


**åŸºç¡€å‘å¸ƒ**ï¼š
```go
func PublishMessage(ch *amqp.Channel, exchange, routingKey string, body []byte) error {
    return ch.Publish(
        exchange,     // äº¤æ¢æœºåç§°
        routingKey,   // è·¯ç”±é”®
        false,        // mandatoryï¼šæ— æ³•è·¯ç”±æ—¶æ˜¯å¦è¿”å›
        false,        // immediateï¼šæ— æ¶ˆè´¹è€…æ—¶æ˜¯å¦è¿”å›
        amqp.Publishing{
            Headers:         amqp.Table{},           // æ¶ˆæ¯å¤´
            ContentType:     "application/json",     // å†…å®¹ç±»å‹
            ContentEncoding: "",                     // å†…å®¹ç¼–ç 
            Body:            body,                   // æ¶ˆæ¯ä½“
            DeliveryMode:    amqp.Persistent,        // æŒä¹…åŒ–æ¨¡å¼
            Priority:        0,                      // ä¼˜å…ˆçº§
            Timestamp:       time.Now(),             // æ—¶é—´æˆ³
        })
}
```

**é«˜çº§å‘å¸ƒé€‰é¡¹**ï¼š
```go
// å¸¦ç¡®è®¤çš„å‘å¸ƒ
func PublishWithConfirm(ch *amqp.Channel, exchange, routingKey string, body []byte) error {
    // å¼€å¯å‘å¸ƒç¡®è®¤
    if err := ch.Confirm(false); err != nil {
        return err
    }
    
    // ç›‘å¬ç¡®è®¤
    confirms := ch.NotifyPublish(make(chan amqp.Confirmation, 1))
    
    // å‘å¸ƒæ¶ˆæ¯
    if err := ch.Publish(exchange, routingKey, false, false,
        amqp.Publishing{
            ContentType:  "application/json",
            Body:         body,
            DeliveryMode: amqp.Persistent,
        }); err != nil {
        return err
    }
    
    // ç­‰å¾…ç¡®è®¤
    select {
    case confirm := <-confirms:
        if confirm.Ack {
            log.Println("æ¶ˆæ¯å‘å¸ƒç¡®è®¤æˆåŠŸ")
            return nil
        } else {
            return fmt.Errorf("æ¶ˆæ¯å‘å¸ƒè¢«æ‹’ç»")
        }
    case <-time.After(5 * time.Second):
        return fmt.Errorf("ç­‰å¾…ç¡®è®¤è¶…æ—¶")
    }
}
```

### 2.4 æ¶ˆæ¯æ¶ˆè´¹è¯¦è§£


**åŸºç¡€æ¶ˆè´¹**ï¼š
```go
func ConsumeMessages(ch *amqp.Channel, queueName string) error {
    messages, err := ch.Consume(
        queueName, // é˜Ÿåˆ—å
        "",        // æ¶ˆè´¹è€…æ ‡ç­¾ï¼ˆç©ºå­—ç¬¦ä¸²è¡¨ç¤ºè‡ªåŠ¨ç”Ÿæˆï¼‰
        true,      // è‡ªåŠ¨ç¡®è®¤
        false,     // ç‹¬å 
        false,     // no-local
        false,     // no-wait
        nil,       // å‚æ•°
    )
    if err != nil {
        return err
    }
    
    // å¤„ç†æ¶ˆæ¯
    for message := range messages {
        log.Printf("æ”¶åˆ°æ¶ˆæ¯: %s", message.Body)
        // è¿™é‡Œå¤„ç†å…·ä½“çš„ä¸šåŠ¡é€»è¾‘
    }
    
    return nil
}
```

**æ‰‹åŠ¨ç¡®è®¤æ¶ˆè´¹**ï¼š
```go
func ConsumeWithManualAck(ch *amqp.Channel, queueName string) error {
    messages, err := ch.Consume(
        queueName, // é˜Ÿåˆ—å
        "",        // æ¶ˆè´¹è€…æ ‡ç­¾
        false,     // æ‰‹åŠ¨ç¡®è®¤
        false,     // ç‹¬å 
        false,     // no-local
        false,     // no-wait
        nil,       // å‚æ•°
    )
    if err != nil {
        return err
    }
    
    for message := range messages {
        // å¤„ç†æ¶ˆæ¯
        if err := processMessage(message.Body); err != nil {
            log.Printf("å¤„ç†æ¶ˆæ¯å¤±è´¥: %v", err)
            // æ‹’ç»æ¶ˆæ¯ï¼Œé‡æ–°å…¥é˜Ÿ
            message.Nack(false, true)
        } else {
            // ç¡®è®¤æ¶ˆæ¯
            message.Ack(false)
            log.Printf("æ¶ˆæ¯å¤„ç†æˆåŠŸ: %s", message.Body)
        }
    }
    
    return nil
}
```

---

## 3. ğŸ”— è¿æ¥ç®¡ç†ä¸è¿æ¥æ± 


### 3.1 è¿æ¥ç®¡ç†çš„é‡è¦æ€§


**ä¸ºä»€ä¹ˆéœ€è¦è¿æ¥ç®¡ç†**ï¼š
```
ğŸ”¸ èµ„æºå®è´µï¼šTCPè¿æ¥æ˜¯æœ‰é™èµ„æº
ğŸ”¸ æˆæœ¬é«˜æ˜‚ï¼šå»ºç«‹è¿æ¥éœ€è¦ç½‘ç»œå¼€é”€å’Œè®¤è¯è¿‡ç¨‹
ğŸ”¸ ç¨³å®šæ€§ï¼šéœ€è¦å¤„ç†è¿æ¥æ–­å¼€å’Œé‡è¿
ğŸ”¸ æ€§èƒ½ä¼˜åŒ–ï¼šå¤ç”¨è¿æ¥æé«˜æ•ˆç‡
```

> ğŸ’¡ **æ ¸å¿ƒç†è§£**ï¼šä¸€ä¸ªåº”ç”¨ç¨‹åºé€šå¸¸åªéœ€è¦ä¸€ä¸ªåˆ°RabbitMQçš„è¿æ¥ï¼Œä½†å¯ä»¥æœ‰å¤šä¸ªä¿¡é“ã€‚ä¿¡é“æ˜¯è½»é‡çº§çš„ï¼Œå¯ä»¥æ ¹æ®éœ€è¦åˆ›å»ºå’Œå…³é—­ã€‚

### 3.2 ç®€å•è¿æ¥ç®¡ç†


**å•ä¾‹è¿æ¥ç®¡ç†å™¨**ï¼š
```go
package connection

import (
    "sync"
    "time"
    amqp "github.com/rabbitmq/amqp091-go"
)

type Manager struct {
    conn *amqp.Connection
    mu   sync.RWMutex
    url  string
}

var instance *Manager
var once sync.Once

// è·å–è¿æ¥ç®¡ç†å™¨å•ä¾‹
func GetManager(url string) *Manager {
    once.Do(func() {
        instance = &Manager{url: url}
    })
    return instance
}

// è·å–è¿æ¥
func (m *Manager) GetConnection() (*amqp.Connection, error) {
    m.mu.RLock()
    if m.conn != nil && !m.conn.IsClosed() {
        conn := m.conn
        m.mu.RUnlock()
        return conn, nil
    }
    m.mu.RUnlock()
    
    m.mu.Lock()
    defer m.mu.Unlock()
    
    // åŒé‡æ£€æŸ¥
    if m.conn != nil && !m.conn.IsClosed() {
        return m.conn, nil
    }
    
    // åˆ›å»ºæ–°è¿æ¥
    var err error
    m.conn, err = amqp.Dial(m.url)
    return m.conn, err
}

// å…³é—­è¿æ¥
func (m *Manager) Close() error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    if m.conn != nil && !m.conn.IsClosed() {
        return m.conn.Close()
    }
    return nil
}
```

### 3.3 è¿æ¥æ± å®ç°


**é«˜çº§è¿æ¥æ± **ï¼š
```go
package connection

import (
    "fmt"
    "sync"
    "time"
    amqp "github.com/rabbitmq/amqp091-go"
)

type Pool struct {
    connections chan *amqp.Connection
    factory     func() (*amqp.Connection, error)
    maxOpen     int
    numOpen     int
    mu          sync.Mutex
}

// åˆ›å»ºè¿æ¥æ± 
func NewPool(url string, maxOpen int) *Pool {
    return &Pool{
        connections: make(chan *amqp.Connection, maxOpen),
        maxOpen:     maxOpen,
        factory: func() (*amqp.Connection, error) {
            return amqp.Dial(url)
        },
    }
}

// è·å–è¿æ¥
func (p *Pool) Get() (*amqp.Connection, error) {
    select {
    case conn := <-p.connections:
        if conn.IsClosed() {
            return p.newConnection()
        }
        return conn, nil
    default:
        return p.newConnection()
    }
}

// å½’è¿˜è¿æ¥
func (p *Pool) Put(conn *amqp.Connection) {
    if conn.IsClosed() {
        p.mu.Lock()
        p.numOpen--
        p.mu.Unlock()
        return
    }
    
    select {
    case p.connections <- conn:
    default:
        // è¿æ¥æ± å·²æ»¡ï¼Œå…³é—­è¿æ¥
        conn.Close()
        p.mu.Lock()
        p.numOpen--
        p.mu.Unlock()
    }
}

// åˆ›å»ºæ–°è¿æ¥
func (p *Pool) newConnection() (*amqp.Connection, error) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    if p.numOpen >= p.maxOpen {
        return nil, fmt.Errorf("è¿æ¥æ± å·²æ»¡")
    }
    
    conn, err := p.factory()
    if err != nil {
        return nil, err
    }
    
    p.numOpen++
    return conn, nil
}
```

### 3.4 è‡ªåŠ¨é‡è¿æœºåˆ¶


**å¸¦é‡è¿çš„è¿æ¥ç®¡ç†å™¨**ï¼š
```go
type ReconnectManager struct {
    url            string
    conn           *amqp.Connection
    notifyClose    chan *amqp.Error
    isConnected    bool
    mu             sync.RWMutex
    reconnectDelay time.Duration
}

func NewReconnectManager(url string) *ReconnectManager {
    return &ReconnectManager{
        url:            url,
        reconnectDelay: 5 * time.Second,
    }
}

// è¿æ¥å¹¶å¯åŠ¨è‡ªåŠ¨é‡è¿
func (r *ReconnectManager) Connect() error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    var err error
    r.conn, err = amqp.Dial(r.url)
    if err != nil {
        return err
    }
    
    r.isConnected = true
    r.notifyClose = make(chan *amqp.Error)
    r.conn.NotifyClose(r.notifyClose)
    
    // å¯åŠ¨é‡è¿ç›‘å¬
    go r.handleReconnect()
    
    return nil
}

// å¤„ç†é‡è¿
func (r *ReconnectManager) handleReconnect() {
    for {
        select {
        case err := <-r.notifyClose:
            if err != nil {
                log.Printf("è¿æ¥æ–­å¼€: %v", err)
                r.mu.Lock()
                r.isConnected = false
                r.mu.Unlock()
                
                // å°è¯•é‡è¿
                for {
                    log.Println("å°è¯•é‡æ–°è¿æ¥...")
                    if err := r.reconnect(); err != nil {
                        log.Printf("é‡è¿å¤±è´¥: %v", err)
                        time.Sleep(r.reconnectDelay)
                        continue
                    }
                    log.Println("é‡è¿æˆåŠŸ")
                    break
                }
            }
        }
    }
}

// é‡è¿é€»è¾‘
func (r *ReconnectManager) reconnect() error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    var err error
    r.conn, err = amqp.Dial(r.url)
    if err != nil {
        return err
    }
    
    r.isConnected = true
    r.notifyClose = make(chan *amqp.Error)
    r.conn.NotifyClose(r.notifyClose)
    
    return nil
}
```

---

## 4. âš¡ å¹¶å‘æ¨¡å¼è®¾è®¡


### 4.1 Goå¹¶å‘åŸºç¡€æ¦‚å¿µ


**Goroutineçš„ç‰¹ç‚¹**ï¼š
```
ğŸ”¸ è½»é‡çº§ï¼šæ¯ä¸ªgoroutineåªå ç”¨å‡ KBå†…å­˜
ğŸ”¸ å¿«é€Ÿåˆ›å»ºï¼šåˆ›å»ºé€Ÿåº¦æ¯”çº¿ç¨‹å¿«100å€
ğŸ”¸ é€šä¿¡æœºåˆ¶ï¼šé€šè¿‡channelè¿›è¡Œå®‰å…¨é€šä¿¡
ğŸ”¸ è°ƒåº¦é«˜æ•ˆï¼šGoè¿è¡Œæ—¶è‡ªåŠ¨è°ƒåº¦
```

> ğŸ’¡ **æ ¸å¿ƒç†è§£**ï¼šåœ¨RabbitMQåº”ç”¨ä¸­ï¼Œé€šå¸¸ä¸ºæ¯ä¸ªæ¶ˆè´¹è€…åˆ›å»ºç‹¬ç«‹çš„goroutineï¼Œä¸ºæ¯ä¸ªå‘å¸ƒæ“ä½œåˆ›å»ºgoroutineï¼Œå®ç°é«˜å¹¶å‘å¤„ç†ã€‚

### 4.2 ç”Ÿäº§è€…å¹¶å‘æ¨¡å¼


**å¹¶å‘å‘å¸ƒæ¶ˆæ¯**ï¼š
```go
package producer

import (
    "context"
    "sync"
    "time"
    amqp "github.com/rabbitmq/amqp091-go"
)

type Producer struct {
    conn    *amqp.Connection
    workers int
    queue   chan Message
}

type Message struct {
    Exchange   string
    RoutingKey string
    Body       []byte
}

// åˆ›å»ºç”Ÿäº§è€…
func NewProducer(conn *amqp.Connection, workers int) *Producer {
    return &Producer{
        conn:    conn,
        workers: workers,
        queue:   make(chan Message, 1000), // ç¼“å†²é˜Ÿåˆ—
    }
}

// å¯åŠ¨ç”Ÿäº§è€…
func (p *Producer) Start(ctx context.Context) {
    var wg sync.WaitGroup
    
    // å¯åŠ¨å¤šä¸ªå·¥ä½œåç¨‹
    for i := 0; i < p.workers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            p.worker(ctx, workerID)
        }(i)
    }
    
    // ç­‰å¾…æ‰€æœ‰å·¥ä½œåç¨‹ç»“æŸ
    wg.Wait()
}

// å·¥ä½œåç¨‹
func (p *Producer) worker(ctx context.Context, workerID int) {
    // æ¯ä¸ªå·¥ä½œåç¨‹åˆ›å»ºè‡ªå·±çš„ä¿¡é“
    ch, err := p.conn.Channel()
    if err != nil {
        log.Printf("å·¥ä½œåç¨‹%dåˆ›å»ºä¿¡é“å¤±è´¥: %v", workerID, err)
        return
    }
    defer ch.Close()
    
    log.Printf("ç”Ÿäº§è€…å·¥ä½œåç¨‹%då¯åŠ¨", workerID)
    
    for {
        select {
        case msg := <-p.queue:
            // å‘å¸ƒæ¶ˆæ¯
            if err := ch.Publish(
                msg.Exchange,
                msg.RoutingKey,
                false,
                false,
                amqp.Publishing{
                    ContentType:  "application/json",
                    Body:         msg.Body,
                    DeliveryMode: amqp.Persistent,
                    Timestamp:    time.Now(),
                },
            ); err != nil {
                log.Printf("å·¥ä½œåç¨‹%då‘å¸ƒæ¶ˆæ¯å¤±è´¥: %v", workerID, err)
            } else {
                log.Printf("å·¥ä½œåç¨‹%då‘å¸ƒæ¶ˆæ¯æˆåŠŸ", workerID)
            }
            
        case <-ctx.Done():
            log.Printf("ç”Ÿäº§è€…å·¥ä½œåç¨‹%dåœæ­¢", workerID)
            return
        }
    }
}

// å¼‚æ­¥å‘é€æ¶ˆæ¯
func (p *Producer) SendAsync(exchange, routingKey string, body []byte) error {
    select {
    case p.queue <- Message{
        Exchange:   exchange,
        RoutingKey: routingKey,
        Body:       body,
    }:
        return nil
    default:
        return fmt.Errorf("æ¶ˆæ¯é˜Ÿåˆ—å·²æ»¡")
    }
}
```

### 4.3 æ¶ˆè´¹è€…å¹¶å‘æ¨¡å¼


**å¹¶å‘æ¶ˆè´¹æ¶ˆæ¯**ï¼š
```go
package consumer

import (
    "context"
    "sync"
    amqp "github.com/rabbitmq/amqp091-go"
)

type Consumer struct {
    conn      *amqp.Connection
    queueName string
    workers   int
    handler   MessageHandler
}

type MessageHandler func([]byte) error

// åˆ›å»ºæ¶ˆè´¹è€…
func NewConsumer(conn *amqp.Connection, queueName string, workers int, handler MessageHandler) *Consumer {
    return &Consumer{
        conn:      conn,
        queueName: queueName,
        workers:   workers,
        handler:   handler,
    }
}

// å¯åŠ¨æ¶ˆè´¹è€…
func (c *Consumer) Start(ctx context.Context) error {
    var wg sync.WaitGroup
    
    // å¯åŠ¨å¤šä¸ªæ¶ˆè´¹åç¨‹
    for i := 0; i < c.workers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            if err := c.worker(ctx, workerID); err != nil {
                log.Printf("æ¶ˆè´¹è€…å·¥ä½œåç¨‹%dé”™è¯¯: %v", workerID, err)
            }
        }(i)
    }
    
    wg.Wait()
    return nil
}

// æ¶ˆè´¹å·¥ä½œåç¨‹
func (c *Consumer) worker(ctx context.Context, workerID int) error {
    // æ¯ä¸ªå·¥ä½œåç¨‹åˆ›å»ºè‡ªå·±çš„ä¿¡é“
    ch, err := c.conn.Channel()
    if err != nil {
        return fmt.Errorf("åˆ›å»ºä¿¡é“å¤±è´¥: %w", err)
    }
    defer ch.Close()
    
    // è®¾ç½®QoS
    if err := ch.Qos(1, 0, false); err != nil {
        return fmt.Errorf("è®¾ç½®QoSå¤±è´¥: %w", err)
    }
    
    // å¼€å§‹æ¶ˆè´¹
    messages, err := ch.Consume(
        c.queueName,
        fmt.Sprintf("consumer-%d", workerID),
        false, // æ‰‹åŠ¨ç¡®è®¤
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return fmt.Errorf("å¼€å§‹æ¶ˆè´¹å¤±è´¥: %w", err)
    }
    
    log.Printf("æ¶ˆè´¹è€…å·¥ä½œåç¨‹%då¯åŠ¨", workerID)
    
    for {
        select {
        case msg := <-messages:
            // å¤„ç†æ¶ˆæ¯
            if err := c.handler(msg.Body); err != nil {
                log.Printf("å·¥ä½œåç¨‹%då¤„ç†æ¶ˆæ¯å¤±è´¥: %v", workerID, err)
                msg.Nack(false, true) // æ‹’ç»å¹¶é‡æ–°å…¥é˜Ÿ
            } else {
                msg.Ack(false) // ç¡®è®¤æ¶ˆæ¯
                log.Printf("å·¥ä½œåç¨‹%då¤„ç†æ¶ˆæ¯æˆåŠŸ", workerID)
            }
            
        case <-ctx.Done():
            log.Printf("æ¶ˆè´¹è€…å·¥ä½œåç¨‹%dåœæ­¢", workerID)
            return nil
        }
    }
}
```

### 4.4 å·¥ä½œæ± æ¨¡å¼


**æ¶ˆæ¯å¤„ç†å·¥ä½œæ± **ï¼š
```go
type WorkerPool struct {
    workers    int
    jobQueue   chan Job
    workerPool chan chan Job
    quit       chan bool
}

type Job struct {
    Message amqp.Delivery
    Handler MessageHandler
}

// åˆ›å»ºå·¥ä½œæ± 
func NewWorkerPool(workers int, queueSize int) *WorkerPool {
    return &WorkerPool{
        workers:    workers,
        jobQueue:   make(chan Job, queueSize),
        workerPool: make(chan chan Job, workers),
        quit:       make(chan bool),
    }
}

// å¯åŠ¨å·¥ä½œæ± 
func (wp *WorkerPool) Start() {
    // å¯åŠ¨å·¥ä½œè€…
    for i := 0; i < wp.workers; i++ {
        worker := NewWorker(wp.workerPool)
        worker.Start()
    }
    
    // å¯åŠ¨åˆ†å‘å™¨
    go wp.dispatch()
}

// åˆ†å‘ä»»åŠ¡
func (wp *WorkerPool) dispatch() {
    for {
        select {
        case job := <-wp.jobQueue:
            // è·å–å¯ç”¨çš„å·¥ä½œè€…
            jobChannel := <-wp.workerPool
            // åˆ†å‘ä»»åŠ¡
            jobChannel <- job
            
        case <-wp.quit:
            return
        }
    }
}

// æäº¤ä»»åŠ¡
func (wp *WorkerPool) Submit(job Job) {
    wp.jobQueue <- job
}
```

---

## 5. ğŸ¯ Contextä¸Šä¸‹æ–‡ä½¿ç”¨


### 5.1 ContextåŸºç¡€æ¦‚å¿µ


**Contextçš„ä½œç”¨**ï¼š
```
ğŸ”¸ å–æ¶ˆä¿¡å·ï¼šä¼˜é›…åœ°åœæ­¢goroutine
ğŸ”¸ è¶…æ—¶æ§åˆ¶ï¼šé˜²æ­¢æ“ä½œæ— é™ç­‰å¾…
ğŸ”¸ æˆªæ­¢æ—¶é—´ï¼šè®¾ç½®æ“ä½œçš„æœ€åæœŸé™
ğŸ”¸ ä¼ é€’å€¼ï¼šåœ¨è°ƒç”¨é“¾ä¸­ä¼ é€’è¯·æ±‚çº§åˆ«çš„æ•°æ®
```

> ğŸ’¡ **æ ¸å¿ƒç†è§£**ï¼šContextæ˜¯Goè¯­è¨€ä¸­å¤„ç†å¹¶å‘å’Œè¶…æ—¶çš„æ ‡å‡†æ–¹å¼ï¼Œåœ¨RabbitMQåº”ç”¨ä¸­ç”¨äºæ§åˆ¶æ¶ˆè´¹è€…çš„ç”Ÿå‘½å‘¨æœŸå’Œæ“ä½œè¶…æ—¶ã€‚

### 5.2 Contextåœ¨æ¶ˆè´¹è€…ä¸­çš„ä½¿ç”¨


**å¸¦è¶…æ—¶çš„æ¶ˆè´¹è€…**ï¼š
```go
func ConsumeWithTimeout(conn *amqp.Connection, queueName string, timeout time.Duration) error {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„Context
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    ch, err := conn.Channel()
    if err != nil {
        return err
    }
    defer ch.Close()
    
    messages, err := ch.Consume(
        queueName,
        "",
        false, // æ‰‹åŠ¨ç¡®è®¤
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    for {
        select {
        case msg := <-messages:
            // å¤„ç†æ¶ˆæ¯
            if err := processMessage(ctx, msg.Body); err != nil {
                log.Printf("å¤„ç†æ¶ˆæ¯å¤±è´¥: %v", err)
                msg.Nack(false, true)
            } else {
                msg.Ack(false)
            }
            
        case <-ctx.Done():
            log.Println("æ¶ˆè´¹è€…è¶…æ—¶é€€å‡º")
            return ctx.Err()
        }
    }
}
```

### 5.3 Contextåœ¨ç”Ÿäº§è€…ä¸­çš„ä½¿ç”¨


**å¸¦å–æ¶ˆçš„å‘å¸ƒæ“ä½œ**ï¼š
```go
func PublishWithContext(ctx context.Context, ch *amqp.Channel, exchange, routingKey string, body []byte) error {
    // åˆ›å»ºä¸€ä¸ªå®Œæˆä¿¡å·
    done := make(chan error, 1)
    
    // åœ¨goroutineä¸­æ‰§è¡Œå‘å¸ƒæ“ä½œ
    go func() {
        err := ch.Publish(
            exchange,
            routingKey,
            false,
            false,
            amqp.Publishing{
                ContentType: "application/json",
                Body:        body,
            },
        )
        done <- err
    }()
    
    // ç­‰å¾…å®Œæˆæˆ–å–æ¶ˆ
    select {
    case err := <-done:
        return err
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

### 5.4 ä¼˜é›…å…³é—­æ¨¡å¼


**ä¼˜é›…å…³é—­æ¶ˆè´¹è€…æœåŠ¡**ï¼š
```go
type Service struct {
    consumers []*Consumer
    cancel    context.CancelFunc
}

func NewService() *Service {
    return &Service{
        consumers: make([]*Consumer, 0),
    }
}

// å¯åŠ¨æœåŠ¡
func (s *Service) Start() error {
    ctx, cancel := context.WithCancel(context.Background())
    s.cancel = cancel
    
    var wg sync.WaitGroup
    
    // å¯åŠ¨æ‰€æœ‰æ¶ˆè´¹è€…
    for _, consumer := range s.consumers {
        wg.Add(1)
        go func(c *Consumer) {
            defer wg.Done()
            if err := c.Start(ctx); err != nil {
                log.Printf("æ¶ˆè´¹è€…å¯åŠ¨å¤±è´¥: %v", err)
            }
        }(consumer)
    }
    
    // ç›‘å¬ç³»ç»Ÿä¿¡å·
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    
    // ç­‰å¾…å…³é—­ä¿¡å·
    <-sigChan
    log.Println("æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­...")
    
    // å‘é€å–æ¶ˆä¿¡å·
    cancel()
    
    // ç­‰å¾…æ‰€æœ‰æ¶ˆè´¹è€…åœæ­¢
    wg.Wait()
    log.Println("æ‰€æœ‰æ¶ˆè´¹è€…å·²åœæ­¢")
    
    return nil
}

// åœæ­¢æœåŠ¡
func (s *Service) Stop() {
    if s.cancel != nil {
        s.cancel()
    }
}
```

---

## 6. ğŸ›¡ï¸ é”™è¯¯å¤„ç†ç­–ç•¥


### 6.1 é”™è¯¯åˆ†ç±»ä¸å¤„ç†


**RabbitMQé”™è¯¯ç±»å‹**ï¼š
```
ğŸ”¸ è¿æ¥é”™è¯¯ï¼šç½‘ç»œæ–­å¼€ã€è®¤è¯å¤±è´¥
ğŸ”¸ ä¿¡é“é”™è¯¯ï¼šä¿¡é“å…³é—­ã€åè®®é”™è¯¯
ğŸ”¸ å‘å¸ƒé”™è¯¯ï¼šäº¤æ¢æœºä¸å­˜åœ¨ã€è·¯ç”±å¤±è´¥
ğŸ”¸ æ¶ˆè´¹é”™è¯¯ï¼šé˜Ÿåˆ—ä¸å­˜åœ¨ã€æ¶ˆè´¹å¤±è´¥
ğŸ”¸ ä¸šåŠ¡é”™è¯¯ï¼šæ¶ˆæ¯å¤„ç†å¤±è´¥
```

### 6.2 è¿æ¥é”™è¯¯å¤„ç†


**è¿æ¥é”™è¯¯ç›‘å¬å’Œå¤„ç†**ï¼š
```go
type ConnectionHandler struct {
    conn        *amqp.Connection
    notifyClose chan *amqp.Error
    isReady     bool
    mu          sync.RWMutex
}

func NewConnectionHandler(url string) (*ConnectionHandler, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }
    
    handler := &ConnectionHandler{
        conn:    conn,
        isReady: true,
    }
    
    handler.handleConnectionErrors()
    return handler, nil
}

// å¤„ç†è¿æ¥é”™è¯¯
func (h *ConnectionHandler) handleConnectionErrors() {
    h.notifyClose = make(chan *amqp.Error)
    h.conn.NotifyClose(h.notifyClose)
    
    go func() {
        err := <-h.notifyClose
        if err != nil {
            log.Printf("è¿æ¥å…³é—­: %v", err)
            h.mu.Lock()
            h.isReady = false
            h.mu.Unlock()
            
            // è¿™é‡Œå¯ä»¥è§¦å‘é‡è¿é€»è¾‘
            h.reconnect()
        }
    }()
}

// å®‰å…¨è·å–è¿æ¥
func (h *ConnectionHandler) GetConnection() (*amqp.Connection, error) {
    h.mu.RLock()
    defer h.mu.RUnlock()
    
    if !h.isReady {
        return nil, fmt.Errorf("è¿æ¥ä¸å¯ç”¨")
    }
    
    return h.conn, nil
}
```

### 6.3 æ¶ˆè´¹é”™è¯¯å¤„ç†ç­–ç•¥


**å¤šå±‚æ¬¡é”™è¯¯å¤„ç†**ï¼š
```go
type ErrorHandler struct {
    maxRetries   int
    retryDelay   time.Duration
    deadLetter   string
}

func NewErrorHandler(maxRetries int, retryDelay time.Duration, deadLetter string) *ErrorHandler {
    return &ErrorHandler{
        maxRetries: maxRetries,
        retryDelay: retryDelay,
        deadLetter: deadLetter,
    }
}

// å¤„ç†æ¶ˆè´¹é”™è¯¯
func (eh *ErrorHandler) HandleError(delivery amqp.Delivery, err error) {
    // è·å–é‡è¯•æ¬¡æ•°
    retryCount := eh.getRetryCount(delivery)
    
    log.Printf("æ¶ˆæ¯å¤„ç†å¤±è´¥ (é‡è¯• %d/%d): %v", retryCount, eh.maxRetries, err)
    
    if retryCount >= eh.maxRetries {
        // è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
        eh.sendToDeadLetter(delivery)
        delivery.Ack(false)
    } else {
        // å¢åŠ é‡è¯•æ¬¡æ•°å¹¶é‡æ–°å…¥é˜Ÿ
        eh.incrementRetryCount(delivery)
        
        // å»¶è¿Ÿé‡è¯•
        time.Sleep(eh.retryDelay)
        delivery.Nack(false, true)
    }
}

// è·å–é‡è¯•æ¬¡æ•°
func (eh *ErrorHandler) getRetryCount(delivery amqp.Delivery) int {
    if delivery.Headers == nil {
        return 0
    }
    
    if count, ok := delivery.Headers["x-retry-count"].(int32); ok {
        return int(count)
    }
    
    return 0
}

// å¢åŠ é‡è¯•æ¬¡æ•°
func (eh *ErrorHandler) incrementRetryCount(delivery amqp.Delivery) {
    if delivery.Headers == nil {
        delivery.Headers = amqp.Table{}
    }
    
    retryCount := eh.getRetryCount(delivery)
    delivery.Headers["x-retry-count"] = int32(retryCount + 1)
}
```

### 6.4 å‘å¸ƒé”™è¯¯å¤„ç†


**å‘å¸ƒç¡®è®¤é”™è¯¯å¤„ç†**ï¼š
```go
type PublishHandler struct {
    ch       *amqp.Channel
    confirms chan amqp.Confirmation
    errors   chan *amqp.Error
}

func NewPublishHandler(ch *amqp.Channel) (*PublishHandler, error) {
    if err := ch.Confirm(false); err != nil {
        return nil, err
    }
    
    handler := &PublishHandler{
        ch:       ch,
        confirms: make(chan amqp.Confirmation, 100),
        errors:   make(chan *amqp.Error, 10),
    }
    
    ch.NotifyPublish(handler.confirms)
    ch.NotifyReturn(handler.errors)
    
    go handler.handleConfirms()
    go handler.handleErrors()
    
    return handler, nil
}

// å¤„ç†å‘å¸ƒç¡®è®¤
func (ph *PublishHandler) handleConfirms() {
    for confirm := range ph.confirms {
        if !confirm.Ack {
            log.Printf("æ¶ˆæ¯å‘å¸ƒè¢«æ‹’ç»: DeliveryTag=%d", confirm.DeliveryTag)
            // è¿™é‡Œå¯ä»¥å®ç°é‡å‘é€»è¾‘
        }
    }
}

// å¤„ç†å‘å¸ƒé”™è¯¯
func (ph *PublishHandler) handleErrors() {
    for err := range ph.errors {
        log.Printf("å‘å¸ƒè¿”å›é”™è¯¯: %v", err)
        // è¿™é‡Œå¯ä»¥å®ç°é”™è¯¯æ¢å¤é€»è¾‘
    }
}
```

---

## 7. ğŸ­ ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ


### 7.1 é…ç½®ç®¡ç†


**ç¯å¢ƒé…ç½®ç»“æ„**ï¼š
```go
type Config struct {
    RabbitMQ struct {
        URL          string        `yaml:"url"`
        MaxConns     int           `yaml:"max_conns"`
        Heartbeat    time.Duration `yaml:"heartbeat"`
        Locale       string        `yaml:"locale"`
    } `yaml:"rabbitmq"`
    
    Producer struct {
        Workers      int           `yaml:"workers"`
        QueueSize    int           `yaml:"queue_size"`
        Confirm      bool          `yaml:"confirm"`
        Timeout      time.Duration `yaml:"timeout"`
    } `yaml:"producer"`
    
    Consumer struct {
        Workers      int           `yaml:"workers"`
        PrefetchCount int          `yaml:"prefetch_count"`
        AutoAck      bool          `yaml:"auto_ack"`
        MaxRetries   int           `yaml:"max_retries"`
    } `yaml:"consumer"`
}

// åŠ è½½é…ç½®
func LoadConfig(filename string) (*Config, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    
    var config Config
    if err := yaml.Unmarshal(data, &config); err != nil {
        return nil, err
    }
    
    return &config, nil
}
```

### 7.2 ç›‘æ§å’ŒæŒ‡æ ‡


**æ€§èƒ½ç›‘æ§**ï¼š
```go
type Metrics struct {
    MessagesPublished   int64
    MessagesConsumed    int64
    ProcessingErrors    int64
    ConnectionErrors    int64
    mu                  sync.RWMutex
}

func (m *Metrics) IncrementPublished() {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.MessagesPublished++
}

func (m *Metrics) IncrementConsumed() {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.MessagesConsumed++
}

func (m *Metrics) IncrementErrors() {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.ProcessingErrors++
}

// è·å–ç»Ÿè®¡ä¿¡æ¯
func (m *Metrics) GetStats() map[string]int64 {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    return map[string]int64{
        "messages_published": m.MessagesPublished,
        "messages_consumed":  m.MessagesConsumed,
        "processing_errors":  m.ProcessingErrors,
        "connection_errors":  m.ConnectionErrors,
    }
}

// å¯åŠ¨æŒ‡æ ‡æ”¶é›†
func (m *Metrics) StartCollection(interval time.Duration) {
    ticker := time.NewTicker(interval)
    go func() {
        for range ticker.C {
            stats := m.GetStats()
            log.Printf("Metrics: %+v", stats)
        }
    }()
}
```

### 7.3 æ—¥å¿—è®°å½•


**ç»“æ„åŒ–æ—¥å¿—**ï¼š
```go
import (
    "github.com/sirupsen/logrus"
)

func setupLogging() {
    logrus.SetFormatter(&logrus.JSONFormatter{})
    logrus.SetLevel(logrus.InfoLevel)
}

func LogMessagePublished(exchange, routingKey string, size int) {
    logrus.WithFields(logrus.Fields{
        "action":      "message_published",
        "exchange":    exchange,
        "routing_key": routingKey,
        "size":        size,
        "timestamp":   time.Now(),
    }).Info("Message published successfully")
}

func LogMessageConsumed(queue string, size int, processingTime time.Duration) {
    logrus.WithFields(logrus.Fields{
        "action":          "message_consumed",
        "queue":           queue,
        "size":            size,
        "processing_time": processingTime.String(),
        "timestamp":       time.Now(),
    }).Info("Message consumed successfully")
}

func LogError(action string, err error, context map[string]interface{}) {
    fields := logrus.Fields{
        "action":    action,
        "error":     err.Error(),
        "timestamp": time.Now(),
    }
    
    for k, v := range context {
        fields[k] = v
    }
    
    logrus.WithFields(fields).Error("Operation failed")
}
```

### 7.4 å¥åº·æ£€æŸ¥


**æœåŠ¡å¥åº·æ£€æŸ¥**ï¼š
```go
type HealthChecker struct {
    conn *amqp.Connection
}

func NewHealthChecker(conn *amqp.Connection) *HealthChecker {
    return &HealthChecker{conn: conn}
}

// æ£€æŸ¥è¿æ¥å¥åº·çŠ¶æ€
func (hc *HealthChecker) CheckConnection() error {
    if hc.conn.IsClosed() {
        return fmt.Errorf("è¿æ¥å·²å…³é—­")
    }
    
    // å°è¯•åˆ›å»ºä¿¡é“æ¥æµ‹è¯•è¿æ¥
    ch, err := hc.conn.Channel()
    if err != nil {
        return fmt.Errorf("æ— æ³•åˆ›å»ºä¿¡é“: %w", err)
    }
    ch.Close()
    
    return nil
}

// HTTPå¥åº·æ£€æŸ¥ç«¯ç‚¹
func (hc *HealthChecker) HealthHandler(w http.ResponseWriter, r *http.Request) {
    if err := hc.CheckConnection(); err != nil {
        w.WriteHeader(http.StatusServiceUnavailable)
        json.NewEncoder(w).Encode(map[string]string{
            "status": "unhealthy",
            "error":  err.Error(),
        })
        return
    }
    
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{
        "status": "healthy",
    })
}
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ å®¢æˆ·ç«¯é€‰æ‹©ï¼šä½¿ç”¨å®˜æ–¹ç»´æŠ¤çš„amqp091-goå®¢æˆ·ç«¯
ğŸ”¸ è¿æ¥ç®¡ç†ï¼šä¸€ä¸ªåº”ç”¨ä¸€ä¸ªè¿æ¥ï¼ŒæŒ‰éœ€åˆ›å»ºä¿¡é“
ğŸ”¸ å¹¶å‘è®¾è®¡ï¼šåˆ©ç”¨goroutineå®ç°é«˜å¹¶å‘æ¶ˆæ¯å¤„ç†
ğŸ”¸ Contextä½¿ç”¨ï¼šæ§åˆ¶è¶…æ—¶å’Œä¼˜é›…å…³é—­
ğŸ”¸ é”™è¯¯å¤„ç†ï¼šåˆ†å±‚å¤„ç†å„ç§ç±»å‹çš„é”™è¯¯
ğŸ”¸ ç”Ÿäº§å®è·µï¼šé…ç½®ç®¡ç†ã€ç›‘æ§ã€æ—¥å¿—ã€å¥åº·æ£€æŸ¥
```

### 8.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ è¿æ¥å’Œä¿¡é“çš„å…³ç³»**ï¼š
```
ç†è§£è¦ç‚¹ï¼š
- è¿æ¥æ˜¯æ˜‚è´µçš„èµ„æºï¼Œåº”è¯¥å¤ç”¨
- ä¿¡é“æ˜¯è½»é‡çº§çš„ï¼Œå¯ä»¥æŒ‰éœ€åˆ›å»º
- æ¯ä¸ªgoroutineåº”è¯¥æœ‰è‡ªå·±çš„ä¿¡é“
- ä¿¡é“ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä¸è¦åœ¨å¤šä¸ªgoroutineé—´å…±äº«
```

**ğŸ”¹ å¹¶å‘å¤„ç†çš„æœ€ä½³å®è·µ**ï¼š
```
è®¾è®¡åŸåˆ™ï¼š
- ç”Ÿäº§è€…ï¼šä½¿ç”¨å·¥ä½œæ± æ¨¡å¼ï¼Œæ§åˆ¶å¹¶å‘æ•°é‡
- æ¶ˆè´¹è€…ï¼šæ¯ä¸ªé˜Ÿåˆ—å¯åŠ¨å¤šä¸ªæ¶ˆè´¹è€…goroutine
- é”™è¯¯éš”ç¦»ï¼šå•ä¸ªæ¶ˆæ¯å¤„ç†é”™è¯¯ä¸å½±å“å…¶ä»–æ¶ˆæ¯
- ä¼˜é›…å…³é—­ï¼šä½¿ç”¨Contextæ§åˆ¶æœåŠ¡ç”Ÿå‘½å‘¨æœŸ
```

**ğŸ”¹ é”™è¯¯å¤„ç†ç­–ç•¥**ï¼š
```
åˆ†å±‚å¤„ç†ï¼š
- è¿æ¥çº§é”™è¯¯ï¼šè‡ªåŠ¨é‡è¿
- ä¿¡é“çº§é”™è¯¯ï¼šé‡æ–°åˆ›å»ºä¿¡é“
- æ¶ˆæ¯çº§é”™è¯¯ï¼šé‡è¯•æˆ–æ­»ä¿¡é˜Ÿåˆ—
- ä¸šåŠ¡çº§é”™è¯¯ï¼šè®°å½•æ—¥å¿—ï¼Œæ‹’ç»æ¶ˆæ¯
```

### 8.3 å®é™…åº”ç”¨ä»·å€¼


**âœ… é«˜æ€§èƒ½åœºæ™¯**ï¼š
- åˆ©ç”¨Goçš„å¹¶å‘ç‰¹æ€§å¤„ç†å¤§é‡æ¶ˆæ¯
- è¿æ¥æ± å‡å°‘è¿æ¥å¼€é”€
- å¼‚æ­¥å¤„ç†æé«˜ååé‡

**âœ… å¯é æ€§ä¿è¯**ï¼š
- è‡ªåŠ¨é‡è¿æœºåˆ¶ä¿è¯æœåŠ¡ç¨³å®š
- é”™è¯¯åˆ†ç±»å¤„ç†å‡å°‘æ¶ˆæ¯ä¸¢å¤±
- å¥åº·æ£€æŸ¥åŠæ—¶å‘ç°é—®é¢˜

**âœ… ç”Ÿäº§éƒ¨ç½²**ï¼š
- é…ç½®åŒ–ç®¡ç†é€‚åº”ä¸åŒç¯å¢ƒ
- ç»“æ„åŒ–æ—¥å¿—ä¾¿äºé—®é¢˜æ’æŸ¥
- ç›‘æ§æŒ‡æ ‡æ”¯æŒè¿ç»´å†³ç­–

**æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
```
Goå†™RabbitMQï¼Œå¹¶å‘æ˜¯ç‹é“
ä¸€è¿æ¥å¤šä¿¡é“ï¼Œgoroutineè¦å·§ç”¨
Contextæ§ç”Ÿå‘½ï¼Œé”™è¯¯åˆ†å±‚å¤„ç†
ç›‘æ§é…ç½®å…¨ï¼Œç”Ÿäº§æ— çƒ¦æ¼
```