---
title: 6ã€Node.jså¼€å‘
---
## ğŸ“š ç›®å½•

1. [Node.jså®¢æˆ·ç«¯æ¦‚è¿°](#1-nodejså®¢æˆ·ç«¯æ¦‚è¿°)
2. [amqplibå®¢æˆ·ç«¯è¯¦è§£](#2-amqplibå®¢æˆ·ç«¯è¯¦è§£)
3. [Promiseä¸async/awaitæ”¯æŒ](#3-promiseä¸asyncawaitæ”¯æŒ)
4. [äº‹ä»¶é©±åŠ¨å¼€å‘æ¨¡å¼](#4-äº‹ä»¶é©±åŠ¨å¼€å‘æ¨¡å¼)
5. [å†…å­˜ç®¡ç†ä¸ä¼˜åŒ–](#5-å†…å­˜ç®¡ç†ä¸ä¼˜åŒ–)
6. [æ€§èƒ½ç›‘æ§å®è·µ](#6-æ€§èƒ½ç›‘æ§å®è·µ)
7. [å®æˆ˜é¡¹ç›®æ¡ˆä¾‹](#7-å®æˆ˜é¡¹ç›®æ¡ˆä¾‹)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸŒŸ Node.jså®¢æˆ·ç«¯æ¦‚è¿°


### 1.1 ä»€ä¹ˆæ˜¯RabbitMQ Node.jså®¢æˆ·ç«¯


**é€šä¿—ç†è§£**ï¼šå°±åƒä½ è¦å’Œå¤–å›½äººèŠå¤©éœ€è¦ç¿»è¯‘å®˜ä¸€æ ·ï¼ŒNode.jsç¨‹åºæƒ³è¦å’ŒRabbitMQ"å¯¹è¯"ï¼Œå°±éœ€è¦ä¸€ä¸ªä¸“é—¨çš„"ç¿»è¯‘å®˜" - è¿™å°±æ˜¯RabbitMQçš„Node.jså®¢æˆ·ç«¯ã€‚

**æ ¸å¿ƒä½œç”¨**ï¼š
```
Node.jsåº”ç”¨ â†â†’ Node.jså®¢æˆ·ç«¯ â†â†’ RabbitMQæœåŠ¡å™¨

Node.jså®¢æˆ·ç«¯çš„èŒè´£ï¼š
â€¢ å»ºç«‹è¿æ¥ï¼šå¸®ä½ çš„ç¨‹åºè¿ä¸ŠRabbitMQ
â€¢ ç¿»è¯‘åè®®ï¼šæŠŠä½ çš„JavaScriptä»£ç ç¿»è¯‘æˆRabbitMQèƒ½æ‡‚çš„AMQPåè®®
â€¢ ç®¡ç†èµ„æºï¼šå¸®ä½ ç®¡ç†è¿æ¥ã€é€šé“ç­‰èµ„æº
â€¢ å¤„ç†å¼‚å¸¸ï¼šå‡ºé”™æ—¶å‘Šè¯‰ä½ å“ªé‡Œæœ‰é—®é¢˜
```

### 1.2 ä¸»æµNode.jså®¢æˆ·ç«¯å¯¹æ¯”


| å®¢æˆ·ç«¯åº“ | **ç‰¹ç‚¹** | **é€‚ç”¨åœºæ™¯** | **å­¦ä¹ éš¾åº¦** |
|---------|---------|-------------|-------------|
| ğŸš€ **amqplib** | `å®˜æ–¹æ¨èï¼ŒåŠŸèƒ½å®Œæ•´` | `ç”Ÿäº§ç¯å¢ƒï¼Œä¼ä¸šé¡¹ç›®` | `â­â­â­â˜†â˜†` |
| ğŸ“¦ **amqp-connection-manager** | `è¿æ¥ç®¡ç†å¢å¼º` | `é«˜å¯ç”¨åœºæ™¯` | `â­â­â­â­â˜†` |
| âš¡ **rhea** | `AMQP 1.0ä¸“ç”¨` | `ç‰¹å®šåè®®éœ€æ±‚` | `â­â­â­â­â­` |

> ğŸ’¡ **æ–°æ‰‹å»ºè®®**ï¼šç›´æ¥é€‰æ‹© `amqplib`ï¼Œå®ƒæ˜¯å®˜æ–¹æ¨èçš„ï¼Œæ–‡æ¡£æœ€å…¨ï¼Œç¤¾åŒºæœ€æ´»è·ƒã€‚

### 1.3 Node.jsä¸RabbitMQçš„å¤©ç„¶ä¼˜åŠ¿


**ä¸ºä»€ä¹ˆNode.jsé€‚åˆæ¶ˆæ¯é˜Ÿåˆ—å¼€å‘ï¼Ÿ**

```
Node.jsç‰¹ç‚¹                    RabbitMQä¼˜åŠ¿
     |                            |
å¼‚æ­¥éé˜»å¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º å¤©ç„¶é€‚åˆæ¶ˆæ¯å¤„ç†
äº‹ä»¶é©±åŠ¨   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º å®Œç¾åŒ¹é…æ¶ˆæ¯ç›‘å¬
å•çº¿ç¨‹æ¨¡å‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º é¿å…å¹¶å‘ç«äº‰é—®é¢˜
è½»é‡é«˜æ•ˆ   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º é™ä½èµ„æºæ¶ˆè€—
```

**å®é™…åº”ç”¨åœºæ™¯**ï¼š
- **Webåº”ç”¨**ï¼šå¤„ç†ç”¨æˆ·è¯·æ±‚çš„å¼‚æ­¥ä»»åŠ¡
- **å¾®æœåŠ¡**ï¼šæœåŠ¡é—´çš„æ¶ˆæ¯é€šä¿¡
- **å®æ—¶ç³»ç»Ÿ**ï¼šèŠå¤©åº”ç”¨ã€é€šçŸ¥ç³»ç»Ÿ
- **æ•°æ®å¤„ç†**ï¼šæ—¥å¿—æ”¶é›†ã€æ•°æ®åˆ†æ

---

## 2. ğŸ“¦ amqplibå®¢æˆ·ç«¯è¯¦è§£


### 2.1 amqplibæ˜¯ä»€ä¹ˆ


**ç®€å•ç†è§£**ï¼šamqplibå°±æ˜¯ä¸€ä¸ªnpmåŒ…ï¼Œä¸“é—¨ç”¨æ¥è®©Node.jsç¨‹åºå’ŒRabbitMQ"è¯´è¯"çš„å·¥å…·åŒ…ã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- âœ… **Promiseæ”¯æŒ**ï¼šæ”¯æŒç°ä»£å¼‚æ­¥ç¼–ç¨‹
- âœ… **å›è°ƒå…¼å®¹**ï¼šå…¼å®¹ä¼ ç»Ÿå›è°ƒæ¨¡å¼  
- âœ… **ç±»å‹å®‰å…¨**ï¼šæä¾›TypeScriptå®šä¹‰
- âœ… **åŠŸèƒ½å®Œæ•´**ï¼šæ”¯æŒæ‰€æœ‰AMQP 0.9.1ç‰¹æ€§

### 2.2 å®‰è£…ä¸åŸºæœ¬é…ç½®


**å®‰è£…æ­¥éª¤**ï¼š
```bash
# å®‰è£…æ ¸å¿ƒåº“
npm install amqplib

# å®‰è£…ç±»å‹å®šä¹‰ï¼ˆTypeScripté¡¹ç›®ï¼‰
npm install @types/amqplib --save-dev
```

**åŸºæœ¬è¿æ¥é…ç½®**ï¼š
```javascript
// ğŸ“ config/rabbitmq.js
const amqp = require('amqplib');

// è¿æ¥é…ç½®
const RABBITMQ_CONFIG = {
  protocol: 'amqp',
  hostname: 'localhost',
  port: 5672,
  username: 'guest',
  password: 'guest',
  vhost: '/',
  // è¿æ¥é€‰é¡¹
  heartbeat: 60,
  connection_timeout: 60000
};

module.exports = { RABBITMQ_CONFIG };
```

### 2.3 è¿æ¥ä¸é€šé“ç®¡ç†


**è¿æ¥ç®¡ç†æœ€ä½³å®è·µ**ï¼š

```javascript
// ğŸ“ utils/rabbitmq-manager.js
class RabbitMQManager {
  constructor() {
    this.connection = null;
    this.channel = null;
  }

  // å»ºç«‹è¿æ¥
  async connect() {
    try {
      console.log('ğŸ”Œ æ­£åœ¨è¿æ¥RabbitMQ...');
      this.connection = await amqp.connect(RABBITMQ_CONFIG);
      this.channel = await this.connection.createChannel();
      
      console.log('âœ… RabbitMQè¿æ¥æˆåŠŸ');
      
      // ç›‘å¬è¿æ¥äº‹ä»¶
      this.setupEventListeners();
      
      return this.channel;
    } catch (error) {
      console.error('âŒ RabbitMQè¿æ¥å¤±è´¥:', error.message);
      throw error;
    }
  }

  // è®¾ç½®äº‹ä»¶ç›‘å¬
  setupEventListeners() {
    this.connection.on('error', (err) => {
      console.error('ğŸš¨ è¿æ¥é”™è¯¯:', err.message);
    });

    this.connection.on('close', () => {
      console.warn('âš ï¸ è¿æ¥å·²å…³é—­');
    });
  }

  // ä¼˜é›…å…³é—­
  async close() {
    if (this.channel) {
      await this.channel.close();
    }
    if (this.connection) {
      await this.connection.close();
    }
    console.log('ğŸ” RabbitMQè¿æ¥å·²å…³é—­');
  }
}

module.exports = new RabbitMQManager();
```

> âš ï¸ **é‡è¦æé†’**ï¼šä¸€ä¸ªåº”ç”¨é€šå¸¸åªéœ€è¦ä¸€ä¸ªè¿æ¥ï¼Œä½†å¯ä»¥æœ‰å¤šä¸ªé€šé“ã€‚é€šé“æ˜¯è½»é‡çº§çš„ï¼Œè¿æ¥æ˜¯é‡é‡çº§çš„ã€‚

### 2.4 é˜Ÿåˆ—å’Œäº¤æ¢æœºæ“ä½œ


**å£°æ˜é˜Ÿåˆ—å’Œäº¤æ¢æœº**ï¼š

```javascript
// ğŸ“ services/queue-service.js
class QueueService {
  constructor(channel) {
    this.channel = channel;
  }

  // å£°æ˜é˜Ÿåˆ—
  async declareQueue(queueName, options = {}) {
    const defaultOptions = {
      durable: true,    // é˜Ÿåˆ—æŒä¹…åŒ–
      exclusive: false, // éç‹¬å 
      autoDelete: false // ä¸è‡ªåŠ¨åˆ é™¤
    };

    const queueOptions = { ...defaultOptions, ...options };
    
    try {
      const result = await this.channel.assertQueue(queueName, queueOptions);
      console.log(`ğŸ“¬ é˜Ÿåˆ— "${queueName}" å£°æ˜æˆåŠŸ`);
      return result;
    } catch (error) {
      console.error(`âŒ é˜Ÿåˆ—å£°æ˜å¤±è´¥:`, error.message);
      throw error;
    }
  }

  // å£°æ˜äº¤æ¢æœº
  async declareExchange(exchangeName, type = 'direct', options = {}) {
    const defaultOptions = {
      durable: true,
      autoDelete: false
    };

    const exchangeOptions = { ...defaultOptions, ...options };

    try {
      await this.channel.assertExchange(exchangeName, type, exchangeOptions);
      console.log(`ğŸ”„ äº¤æ¢æœº "${exchangeName}" (${type}) å£°æ˜æˆåŠŸ`);
    } catch (error) {
      console.error(`âŒ äº¤æ¢æœºå£°æ˜å¤±è´¥:`, error.message);
      throw error;
    }
  }

  // ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢æœº
  async bindQueue(queueName, exchangeName, routingKey = '') {
    try {
      await this.channel.bindQueue(queueName, exchangeName, routingKey);
      console.log(`ğŸ”— é˜Ÿåˆ—ç»‘å®š: ${queueName} â† ${exchangeName} (${routingKey})`);
    } catch (error) {
      console.error(`âŒ é˜Ÿåˆ—ç»‘å®šå¤±è´¥:`, error.message);
      throw error;
    }
  }
}
```

---

## 3. ğŸ¯ Promiseä¸async/awaitæ”¯æŒ


### 3.1 ä¸ºä»€ä¹ˆéœ€è¦Promiseæ”¯æŒ


**ä¼ ç»Ÿå›è°ƒçš„é—®é¢˜**ï¼š
```javascript
// âŒ å›è°ƒåœ°ç‹±ç¤ºä¾‹
connection.createChannel((err, channel) => {
  if (err) throw err;
  
  channel.assertQueue('task_queue', (err, ok) => {
    if (err) throw err;
    
    channel.sendToQueue('task_queue', Buffer.from('Hello'), (err) => {
      if (err) throw err;
      console.log('æ¶ˆæ¯å‘é€æˆåŠŸ');
    });
  });
});
```

**Promiseçš„ä¼˜åŠ¿**ï¼š
```javascript
// âœ… Promiseé“¾å¼è°ƒç”¨
connection.createChannel()
  .then(channel => channel.assertQueue('task_queue'))
  .then(() => channel.sendToQueue('task_queue', Buffer.from('Hello')))
  .then(() => console.log('æ¶ˆæ¯å‘é€æˆåŠŸ'))
  .catch(err => console.error('æ“ä½œå¤±è´¥:', err));
```

### 3.2 async/awaitæœ€ä½³å®è·µ


**ç°ä»£å¼‚æ­¥æ¶ˆæ¯å‘é€**ï¼š

```javascript
// ğŸ“ services/message-producer.js
class MessageProducer {
  constructor(channel) {
    this.channel = channel;
  }

  // å‘é€ç®€å•æ¶ˆæ¯
  async sendMessage(queueName, message, options = {}) {
    try {
      // ç¡®ä¿é˜Ÿåˆ—å­˜åœ¨
      await this.channel.assertQueue(queueName, { durable: true });
      
      // å‡†å¤‡æ¶ˆæ¯
      const messageBuffer = Buffer.from(JSON.stringify(message));
      const sendOptions = {
        persistent: true, // æ¶ˆæ¯æŒä¹…åŒ–
        ...options
      };

      // å‘é€æ¶ˆæ¯
      const success = this.channel.sendToQueue(queueName, messageBuffer, sendOptions);
      
      if (success) {
        console.log(`ğŸ“¤ æ¶ˆæ¯å‘é€æˆåŠŸ: ${queueName}`);
        return true;
      } else {
        console.warn(`âš ï¸ æ¶ˆæ¯å¯èƒ½æœªå‘é€: ${queueName}`);
        return false;
      }
    } catch (error) {
      console.error(`âŒ å‘é€æ¶ˆæ¯å¤±è´¥:`, error.message);
      throw error;
    }
  }

  // æ‰¹é‡å‘é€æ¶ˆæ¯
  async sendBatchMessages(queueName, messages) {
    const results = [];
    
    for (const message of messages) {
      try {
        const result = await this.sendMessage(queueName, message);
        results.push({ success: result, message });
      } catch (error) {
        results.push({ success: false, message, error: error.message });
      }
    }

    const successCount = results.filter(r => r.success).length;
    console.log(`ğŸ“Š æ‰¹é‡å‘é€å®Œæˆ: ${successCount}/${messages.length}`);
    
    return results;
  }
}
```

**å¼‚æ­¥æ¶ˆæ¯æ¶ˆè´¹**ï¼š

```javascript
// ğŸ“ services/message-consumer.js
class MessageConsumer {
  constructor(channel) {
    this.channel = channel;
  }

  // æ¶ˆè´¹æ¶ˆæ¯
  async consumeMessages(queueName, processor, options = {}) {
    try {
      // ç¡®ä¿é˜Ÿåˆ—å­˜åœ¨
      await this.channel.assertQueue(queueName, { durable: true });
      
      // è®¾ç½®æœåŠ¡è´¨é‡
      await this.channel.prefetch(1); // ä¸€æ¬¡åªå¤„ç†ä¸€æ¡æ¶ˆæ¯

      console.log(`ğŸ‘‚ å¼€å§‹ç›‘å¬é˜Ÿåˆ—: ${queueName}`);

      // å¼€å§‹æ¶ˆè´¹
      await this.channel.consume(queueName, async (msg) => {
        if (msg) {
          try {
            // è§£ææ¶ˆæ¯
            const content = JSON.parse(msg.content.toString());
            console.log(`ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯:`, content);

            // å¤„ç†æ¶ˆæ¯
            await processor(content, msg);

            // ç¡®è®¤æ¶ˆæ¯
            this.channel.ack(msg);
            console.log(`âœ… æ¶ˆæ¯å¤„ç†å®Œæˆ`);

          } catch (error) {
            console.error(`âŒ æ¶ˆæ¯å¤„ç†å¤±è´¥:`, error.message);
            
            // æ‹’ç»æ¶ˆæ¯å¹¶é‡æ–°æ’é˜Ÿ
            this.channel.nack(msg, false, true);
          }
        }
      }, options);

    } catch (error) {
      console.error(`âŒ æ¶ˆè´¹æ¶ˆæ¯å¤±è´¥:`, error.message);
      throw error;
    }
  }
}
```

### 3.3 é”™è¯¯å¤„ç†ç­–ç•¥


**å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶**ï¼š

```javascript
// ğŸ“ utils/error-handler.js
class RabbitMQErrorHandler {
  static async handleAsyncOperation(operation, context = '') {
    try {
      return await operation();
    } catch (error) {
      console.error(`âŒ ${context} æ“ä½œå¤±è´¥:`, {
        message: error.message,
        code: error.code,
        stack: error.stack
      });

      // æ ¹æ®é”™è¯¯ç±»å‹è¿›è¡Œä¸åŒå¤„ç†
      if (error.code === 'ECONNREFUSED') {
        console.log('ğŸ”„ è¿æ¥è¢«æ‹’ç»ï¼Œå°è¯•é‡è¿...');
        // å®ç°é‡è¿é€»è¾‘
      } else if (error.code === 'ENOTFOUND') {
        console.log('ğŸŒ DNSè§£æå¤±è´¥ï¼Œæ£€æŸ¥ä¸»æœºå...');
      }

      throw error;
    }
  }

  static setupGlobalErrorHandlers() {
    // å¤„ç†æœªæ•è·çš„Promiseæ‹’ç»
    process.on('unhandledRejection', (reason, promise) => {
      console.error('ğŸš¨ æœªå¤„ç†çš„Promiseæ‹’ç»:', reason);
    });

    // å¤„ç†æœªæ•è·çš„å¼‚å¸¸
    process.on('uncaughtException', (error) => {
      console.error('ğŸš¨ æœªæ•è·çš„å¼‚å¸¸:', error);
      process.exit(1);
    });
  }
}
```

---

## 4. âš¡ äº‹ä»¶é©±åŠ¨å¼€å‘æ¨¡å¼


### 4.1 ä»€ä¹ˆæ˜¯äº‹ä»¶é©±åŠ¨æ¨¡å¼


**é€šä¿—è§£é‡Š**ï¼šæƒ³è±¡ä½ åœ¨é¤å…ç‚¹é¤ï¼Œä½ ä¸éœ€è¦ä¸€ç›´ç›¯ç€å¨æˆ¿ï¼Œè€Œæ˜¯ç‚¹å®Œé¤ååšè‡ªå·±çš„äº‹ï¼Œç­‰æœåŠ¡å‘˜å«å·æ—¶å†å»å–é¤ã€‚äº‹ä»¶é©±åŠ¨å°±æ˜¯è¿™æ · - ç¨‹åºä¸ç”¨ä¸€ç›´ç­‰å¾…ï¼Œè€Œæ˜¯åœ¨äº‹ä»¶å‘ç”Ÿæ—¶è‡ªåŠ¨å“åº”ã€‚

**Node.jsäº‹ä»¶é©±åŠ¨æ¶æ„**ï¼š
```
                Node.jsäº‹ä»¶å¾ªç¯
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚             â”‚
   Timer Phase    I/O Phase    Close Phase
        â”‚             â”‚             â”‚
    å®šæ—¶å™¨äº‹ä»¶      I/Oäº‹ä»¶       å…³é—­äº‹ä»¶
        â”‚             â”‚             â”‚
    setTimeout      æ–‡ä»¶è¯»å†™      è¿æ¥å…³é—­
    setInterval     ç½‘ç»œè¯·æ±‚      Socketå…³é—­
```

### 4.2 RabbitMQäº‹ä»¶ç›‘å¬


**è¿æ¥äº‹ä»¶ç›‘å¬**ï¼š

```javascript
// ğŸ“ services/event-manager.js
class RabbitMQEventManager {
  constructor(connection, channel) {
    this.connection = connection;
    this.channel = channel;
    this.setupConnectionEvents();
    this.setupChannelEvents();
  }

  // è®¾ç½®è¿æ¥äº‹ä»¶
  setupConnectionEvents() {
    this.connection.on('connect', () => {
      console.log('ğŸ”— RabbitMQè¿æ¥å»ºç«‹');
    });

    this.connection.on('error', (error) => {
      console.error('âŒ è¿æ¥é”™è¯¯:', error.message);
      this.handleConnectionError(error);
    });

    this.connection.on('close', () => {
      console.warn('âš ï¸ è¿æ¥å…³é—­');
      this.handleConnectionClose();
    });

    this.connection.on('blocked', (reason) => {
      console.warn('ğŸš« è¿æ¥è¢«é˜»å¡:', reason);
    });

    this.connection.on('unblocked', () => {
      console.log('âœ… è¿æ¥è§£é™¤é˜»å¡');
    });
  }

  // è®¾ç½®é€šé“äº‹ä»¶
  setupChannelEvents() {
    this.channel.on('error', (error) => {
      console.error('âŒ é€šé“é”™è¯¯:', error.message);
    });

    this.channel.on('close', () => {
      console.warn('âš ï¸ é€šé“å…³é—­');
    });

    this.channel.on('return', (message) => {
      console.warn('ğŸ“® æ¶ˆæ¯è¢«é€€å›:', {
        exchange: message.fields.exchange,
        routingKey: message.fields.routingKey,
        replyText: message.properties.replyText
      });
    });
  }

  // å¤„ç†è¿æ¥é”™è¯¯
  handleConnectionError(error) {
    if (error.code === 'ECONNREFUSED') {
      console.log('ğŸ”„ å°è¯•é‡æ–°è¿æ¥...');
      setTimeout(() => {
        this.reconnect();
      }, 5000);
    }
  }

  // å¤„ç†è¿æ¥å…³é—­
  handleConnectionClose() {
    console.log('ğŸ”„ è¿æ¥æ„å¤–å…³é—­ï¼Œå‡†å¤‡é‡è¿...');
    setTimeout(() => {
      this.reconnect();
    }, 3000);
  }

  // é‡è¿é€»è¾‘
  async reconnect() {
    try {
      console.log('ğŸ”„ æ­£åœ¨é‡æ–°è¿æ¥...');
      // é‡æ–°å»ºç«‹è¿æ¥çš„é€»è¾‘
      await this.connection.close();
      // è¿™é‡Œåº”è¯¥è°ƒç”¨ä¸»è¿æ¥ç®¡ç†å™¨çš„é‡è¿æ–¹æ³•
    } catch (error) {
      console.error('âŒ é‡è¿å¤±è´¥:', error.message);
    }
  }
}
```

### 4.3 è‡ªå®šä¹‰äº‹ä»¶ç³»ç»Ÿ


**åˆ›å»ºæ¶ˆæ¯äº‹ä»¶å‘å°„å™¨**ï¼š

```javascript
// ğŸ“ services/message-event-emitter.js
const EventEmitter = require('events');

class MessageEventEmitter extends EventEmitter {
  constructor() {
    super();
    this.messageStats = {
      sent: 0,
      received: 0,
      errors: 0
    };
  }

  // å‘å°„æ¶ˆæ¯å‘é€äº‹ä»¶
  emitMessageSent(queueName, message) {
    this.messageStats.sent++;
    this.emit('message:sent', {
      queue: queueName,
      message,
      timestamp: new Date(),
      total: this.messageStats.sent
    });
  }

  // å‘å°„æ¶ˆæ¯æ¥æ”¶äº‹ä»¶
  emitMessageReceived(queueName, message) {
    this.messageStats.received++;
    this.emit('message:received', {
      queue: queueName,
      message,
      timestamp: new Date(),
      total: this.messageStats.received
    });
  }

  // å‘å°„é”™è¯¯äº‹ä»¶
  emitError(error, context) {
    this.messageStats.errors++;
    this.emit('error', {
      error,
      context,
      timestamp: new Date(),
      total: this.messageStats.errors
    });
  }

  // è·å–ç»Ÿè®¡ä¿¡æ¯
  getStats() {
    return { ...this.messageStats };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const messageEvents = new MessageEventEmitter();

// ç›‘å¬äº‹ä»¶
messageEvents.on('message:sent', (data) => {
  console.log(`ğŸ“¤ æ¶ˆæ¯å·²å‘é€åˆ° ${data.queue}, æ€»è®¡: ${data.total}`);
});

messageEvents.on('message:received', (data) => {
  console.log(`ğŸ“¨ ä» ${data.queue} æ¥æ”¶æ¶ˆæ¯, æ€»è®¡: ${data.total}`);
});

messageEvents.on('error', (data) => {
  console.error(`âŒ é”™è¯¯å‘ç”Ÿåœ¨ ${data.context}:`, data.error.message);
});

module.exports = messageEvents;
```

### 4.4 å®æ—¶æ¶ˆæ¯å¤„ç†


**åŸºäºäº‹ä»¶çš„å®æ—¶æ¶ˆæ¯ç³»ç»Ÿ**ï¼š

```javascript
// ğŸ“ services/realtime-processor.js
class RealtimeMessageProcessor {
  constructor(channel, eventEmitter) {
    this.channel = channel;
    this.events = eventEmitter;
    this.processors = new Map();
  }

  // æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
  registerProcessor(messageType, processor) {
    this.processors.set(messageType, processor);
    console.log(`ğŸ“ æ³¨å†Œå¤„ç†å™¨: ${messageType}`);
  }

  // å¯åŠ¨å®æ—¶å¤„ç†
  async startRealtime(queueName) {
    await this.channel.assertQueue(queueName, { durable: true });
    
    console.log(`ğŸš€ å¯åŠ¨å®æ—¶å¤„ç†: ${queueName}`);

    await this.channel.consume(queueName, async (msg) => {
      if (msg) {
        try {
          const message = JSON.parse(msg.content.toString());
          const messageType = message.type || 'default';

          // å‘å°„æ¥æ”¶äº‹ä»¶
          this.events.emitMessageReceived(queueName, message);

          // æŸ¥æ‰¾å¯¹åº”çš„å¤„ç†å™¨
          const processor = this.processors.get(messageType);
          
          if (processor) {
            console.log(`âš¡ å¤„ç†æ¶ˆæ¯ç±»å‹: ${messageType}`);
            await processor(message, msg);
          } else {
            console.warn(`âš ï¸ æœªæ‰¾åˆ°å¤„ç†å™¨: ${messageType}`);
          }

          this.channel.ack(msg);

        } catch (error) {
          this.events.emitError(error, `å¤„ç†é˜Ÿåˆ— ${queueName} æ¶ˆæ¯`);
          this.channel.nack(msg, false, true);
        }
      }
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const processor = new RealtimeMessageProcessor(channel, messageEvents);

// æ³¨å†Œä¸åŒç±»å‹çš„å¤„ç†å™¨
processor.registerProcessor('user:signup', async (message) => {
  console.log(`ğŸ‘¤ å¤„ç†ç”¨æˆ·æ³¨å†Œ:`, message.userId);
  // å‘é€æ¬¢è¿é‚®ä»¶ã€åˆå§‹åŒ–ç”¨æˆ·æ•°æ®ç­‰
});

processor.registerProcessor('order:created', async (message) => {
  console.log(`ğŸ›’ å¤„ç†è®¢å•åˆ›å»º:`, message.orderId);
  // åº“å­˜æ£€æŸ¥ã€æ”¯ä»˜å¤„ç†ç­‰
});

processor.registerProcessor('email:send', async (message) => {
  console.log(`ğŸ“§ å‘é€é‚®ä»¶:`, message.to);
  // é‚®ä»¶å‘é€é€»è¾‘
});
```

---

## 5. ğŸ§  å†…å­˜ç®¡ç†ä¸ä¼˜åŒ–


### 5.1 Node.jså†…å­˜ç®¡ç†åŸºç¡€


**å†…å­˜ä½¿ç”¨ç›‘æ§**ï¼š

```javascript
// ğŸ“ utils/memory-monitor.js
class MemoryMonitor {
  constructor(interval = 10000) {
    this.interval = interval;
    this.monitoring = false;
    this.stats = [];
  }

  // å¼€å§‹ç›‘æ§
  start() {
    if (this.monitoring) return;
    
    this.monitoring = true;
    console.log('ğŸ” å¼€å§‹å†…å­˜ç›‘æ§...');

    this.timer = setInterval(() => {
      const usage = process.memoryUsage();
      const timestamp = new Date();
      
      const stat = {
        timestamp,
        rss: this.formatBytes(usage.rss),           // ç‰©ç†å†…å­˜
        heapTotal: this.formatBytes(usage.heapTotal), // å †æ€»å¤§å°
        heapUsed: this.formatBytes(usage.heapUsed),   // å †ä½¿ç”¨é‡
        external: this.formatBytes(usage.external),   // å¤–éƒ¨å†…å­˜
        arrayBuffers: this.formatBytes(usage.arrayBuffers) // æ•°ç»„ç¼“å†²åŒº
      };

      this.stats.push(stat);
      this.logMemoryUsage(stat);
      
      // ä¿ç•™æœ€è¿‘100æ¡è®°å½•
      if (this.stats.length > 100) {
        this.stats = this.stats.slice(-100);
      }

    }, this.interval);
  }

  // åœæ­¢ç›‘æ§
  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.monitoring = false;
      console.log('â¹ï¸ å†…å­˜ç›‘æ§å·²åœæ­¢');
    }
  }

  // æ ¼å¼åŒ–å­—èŠ‚æ•°
  formatBytes(bytes) {
    const mb = bytes / 1024 / 1024;
    return `${mb.toFixed(2)}MB`;
  }

  // è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
  logMemoryUsage(stat) {
    console.log(`ğŸ“Š å†…å­˜ä½¿ç”¨: RSS=${stat.rss}, Heap=${stat.heapUsed}/${stat.heapTotal}`);
    
    // å†…å­˜å‘Šè­¦
    const heapUsedMB = parseFloat(stat.heapUsed);
    if (heapUsedMB > 100) {
      console.warn(`âš ï¸ å†…å­˜ä½¿ç”¨è¾ƒé«˜: ${stat.heapUsed}`);
    }
  }

  // è·å–å†…å­˜ç»Ÿè®¡
  getStats() {
    return this.stats;
  }

  // æ‰‹åŠ¨åƒåœ¾å›æ”¶ï¼ˆä»…åœ¨å¼€å‘ç¯å¢ƒï¼‰
  forceGC() {
    if (global.gc) {
      global.gc();
      console.log('ğŸ§¹ æ‰§è¡Œåƒåœ¾å›æ”¶');
    } else {
      console.warn('âš ï¸ åƒåœ¾å›æ”¶ä¸å¯ç”¨ï¼Œå¯åŠ¨æ—¶æ·»åŠ  --expose-gc å‚æ•°');
    }
  }
}

module.exports = MemoryMonitor;
```

### 5.2 è¿æ¥æ± ç®¡ç†


**è¿æ¥æ± å®ç°**ï¼š

```javascript
// ğŸ“ utils/connection-pool.js
class RabbitMQConnectionPool {
  constructor(config, poolSize = 5) {
    this.config = config;
    this.poolSize = poolSize;
    this.connections = [];
    this.channels = [];
    this.currentIndex = 0;
  }

  // åˆå§‹åŒ–è¿æ¥æ± 
  async initialize() {
    console.log(`ğŸŠ åˆå§‹åŒ–è¿æ¥æ± ï¼Œå¤§å°: ${this.poolSize}`);
    
    for (let i = 0; i < this.poolSize; i++) {
      try {
        const connection = await amqp.connect(this.config);
        const channel = await connection.createChannel();
        
        // è®¾ç½®é€šé“é¢„å–
        await channel.prefetch(10);
        
        this.connections.push(connection);
        this.channels.push(channel);
        
        console.log(`âœ… è¿æ¥ ${i + 1} åˆ›å»ºæˆåŠŸ`);
      } catch (error) {
        console.error(`âŒ è¿æ¥ ${i + 1} åˆ›å»ºå¤±è´¥:`, error.message);
        throw error;
      }
    }
  }

  // è·å–é€šé“ï¼ˆè½®è¯¢æ–¹å¼ï¼‰
  getChannel() {
    const channel = this.channels[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.channels.length;
    return channel;
  }

  // è·å–ç©ºé—²é€šé“
  getIdleChannel() {
    // ç®€å•å®ç°ï¼šè¿”å›ç¬¬ä¸€ä¸ªå¯ç”¨é€šé“
    // å®é™…åº”ç”¨ä¸­å¯ä»¥å®ç°æ›´å¤æ‚çš„è´Ÿè½½å‡è¡¡
    return this.channels.find(channel => !channel._closed) || this.channels[0];
  }

  // å…³é—­è¿æ¥æ± 
  async close() {
    console.log('ğŸ” å…³é—­è¿æ¥æ± ...');
    
    // å…³é—­æ‰€æœ‰é€šé“
    for (const channel of this.channels) {
      try {
        await channel.close();
      } catch (error) {
        console.error('âŒ å…³é—­é€šé“å¤±è´¥:', error.message);
      }
    }

    // å…³é—­æ‰€æœ‰è¿æ¥
    for (const connection of this.connections) {
      try {
        await connection.close();
      } catch (error) {
        console.error('âŒ å…³é—­è¿æ¥å¤±è´¥:', error.message);
      }
    }

    console.log('âœ… è¿æ¥æ± å·²å…³é—­');
  }

  // æ£€æŸ¥è¿æ¥çŠ¶æ€
  checkHealth() {
    const healthStatus = {
      totalConnections: this.connections.length,
      activeConnections: this.connections.filter(conn => !conn._closed).length,
      totalChannels: this.channels.length,
      activeChannels: this.channels.filter(ch => !ch._closed).length
    };

    console.log('ğŸ¥ è¿æ¥æ± å¥åº·çŠ¶æ€:', healthStatus);
    return healthStatus;
  }
}
```

### 5.3 æ¶ˆæ¯ç¼“å†²ä¸æ‰¹å¤„ç†


**æ‰¹é‡æ¶ˆæ¯å¤„ç†**ï¼š

```javascript
// ğŸ“ services/batch-processor.js
class BatchMessageProcessor {
  constructor(channel, options = {}) {
    this.channel = channel;
    this.batchSize = options.batchSize || 10;
    this.timeout = options.timeout || 5000;
    this.messageBuffer = [];
    this.timer = null;
  }

  // æ·»åŠ æ¶ˆæ¯åˆ°ç¼“å†²åŒº
  addMessage(queueName, message) {
    this.messageBuffer.push({ queueName, message, timestamp: Date.now() });
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç«‹å³å¤„ç†
    if (this.messageBuffer.length >= this.batchSize) {
      this.processBatch();
    } else if (!this.timer) {
      // è®¾ç½®è¶…æ—¶å¤„ç†
      this.timer = setTimeout(() => {
        this.processBatch();
      }, this.timeout);
    }
  }

  // å¤„ç†æ‰¹é‡æ¶ˆæ¯
  async processBatch() {
    if (this.messageBuffer.length === 0) return;

    // æ¸…é™¤å®šæ—¶å™¨
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    // è·å–å½“å‰æ‰¹æ¬¡
    const batch = [...this.messageBuffer];
    this.messageBuffer = [];

    console.log(`ğŸ“¦ å¤„ç†æ‰¹æ¬¡æ¶ˆæ¯: ${batch.length} æ¡`);

    // æŒ‰é˜Ÿåˆ—åˆ†ç»„
    const groupedByQueue = batch.reduce((groups, item) => {
      if (!groups[item.queueName]) {
        groups[item.queueName] = [];
      }
      groups[item.queueName].push(item);
      return groups;
    }, {});

    // é€é˜Ÿåˆ—å‘é€
    for (const [queueName, messages] of Object.entries(groupedByQueue)) {
      try {
        await this.sendBatchToQueue(queueName, messages);
      } catch (error) {
        console.error(`âŒ æ‰¹é‡å‘é€å¤±è´¥ ${queueName}:`, error.message);
        
        // é”™è¯¯å¤„ç†ï¼šå¯ä»¥é€‰æ‹©é‡æ–°æ’é˜Ÿæˆ–è®°å½•å¤±è´¥
        this.handleBatchError(queueName, messages, error);
      }
    }
  }

  // å‘é€æ‰¹é‡æ¶ˆæ¯åˆ°æŒ‡å®šé˜Ÿåˆ—
  async sendBatchToQueue(queueName, messages) {
    await this.channel.assertQueue(queueName, { durable: true });

    for (const item of messages) {
      const messageBuffer = Buffer.from(JSON.stringify(item.message));
      this.channel.sendToQueue(queueName, messageBuffer, { persistent: true });
    }

    console.log(`âœ… æ‰¹é‡å‘é€å®Œæˆ: ${queueName} (${messages.length} æ¡)`);
  }

  // å¤„ç†æ‰¹é‡é”™è¯¯
  handleBatchError(queueName, messages, error) {
    console.error(`âŒ æ‰¹é‡å¤„ç†é”™è¯¯ ${queueName}:`, {
      error: error.message,
      messageCount: messages.length,
      firstMessage: messages[0]?.message
    });

    // å¯ä»¥å®ç°é‡è¯•é€»è¾‘æˆ–æ­»ä¿¡é˜Ÿåˆ—
  }

  // å¼ºåˆ¶å¤„ç†å‰©ä½™æ¶ˆæ¯
  async flush() {
    if (this.messageBuffer.length > 0) {
      console.log('ğŸ’¨ å¼ºåˆ¶å¤„ç†å‰©ä½™æ¶ˆæ¯...');
      await this.processBatch();
    }
  }
}
```

### 5.4 å†…å­˜æ³„æ¼é¢„é˜²


**å†…å­˜æ³„æ¼æ£€æµ‹ä¸é¢„é˜²**ï¼š

```javascript
// ğŸ“ utils/memory-leak-detector.js
class MemoryLeakDetector {
  constructor() {
    this.baseline = null;
    this.samples = [];
    this.listeners = new Map();
  }

  // è®¾ç½®åŸºçº¿
  setBaseline() {
    this.baseline = process.memoryUsage();
    console.log('ğŸ“ å†…å­˜åŸºçº¿å·²è®¾ç½®:', this.formatMemory(this.baseline));
  }

  // é‡‡æ ·å†…å­˜ä½¿ç”¨
  sample(label = 'sample') {
    const usage = process.memoryUsage();
    const sample = {
      label,
      timestamp: Date.now(),
      usage,
      heapDelta: this.baseline ? usage.heapUsed - this.baseline.heapUsed : 0
    };

    this.samples.push(sample);
    console.log(`ğŸ“Š å†…å­˜é‡‡æ · [${label}]: ${this.formatMemory(usage)}, å¢é•¿: ${this.formatBytes(sample.heapDelta)}`);

    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼
    this.checkForLeaks();

    return sample;
  }

  // æ£€æŸ¥å†…å­˜æ³„æ¼
  checkForLeaks() {
    if (this.samples.length < 5) return;

    // è·å–æœ€è¿‘5ä¸ªæ ·æœ¬
    const recentSamples = this.samples.slice(-5);
    const growthTrend = recentSamples.map(s => s.heapDelta);

    // æ£€æŸ¥æ˜¯å¦æŒç»­å¢é•¿
    const isGrowing = growthTrend.every((delta, index) => {
      return index === 0 || delta >= growthTrend[index - 1];
    });

    if (isGrowing && growthTrend[growthTrend.length - 1] > 50 * 1024 * 1024) {
      console.warn('ğŸš¨ æ£€æµ‹åˆ°å¯èƒ½çš„å†…å­˜æ³„æ¼ï¼');
      this.reportPotentialLeak(recentSamples);
    }
  }

  // æŠ¥å‘Šæ½œåœ¨æ³„æ¼
  reportPotentialLeak(samples) {
    console.warn('âš ï¸ å†…å­˜æ³„æ¼æŠ¥å‘Š:');
    samples.forEach(sample => {
      console.warn(`  ${sample.label}: +${this.formatBytes(sample.heapDelta)}`);
    });

    // è¾“å‡ºäº‹ä»¶ç›‘å¬å™¨ç»Ÿè®¡
    this.reportEventListeners();
  }

  // ç›‘æ§äº‹ä»¶ç›‘å¬å™¨
  monitorEventListeners(emitter, name) {
    if (!this.listeners.has(name)) {
      this.listeners.set(name, { emitter, name, count: 0 });
    }

    const originalOn = emitter.on.bind(emitter);
    const originalOff = emitter.removeListener.bind(emitter);

    emitter.on = (event, listener) => {
      this.listeners.get(name).count++;
      return originalOn(event, listener);
    };

    emitter.removeListener = (event, listener) => {
      this.listeners.get(name).count--;
      return originalOff(event, listener);
    };
  }

  // æŠ¥å‘Šäº‹ä»¶ç›‘å¬å™¨ç»Ÿè®¡
  reportEventListeners() {
    console.log('ğŸ‘‚ äº‹ä»¶ç›‘å¬å™¨ç»Ÿè®¡:');
    for (const [name, info] of this.listeners) {
      console.log(`  ${name}: ${info.count} ä¸ªç›‘å¬å™¨`);
      
      if (info.count > 50) {
        console.warn(`âš ï¸ ${name} ç›‘å¬å™¨æ•°é‡å¼‚å¸¸: ${info.count}`);
      }
    }
  }

  // æ ¼å¼åŒ–å†…å­˜ä¿¡æ¯
  formatMemory(usage) {
    return `RSS: ${this.formatBytes(usage.rss)}, Heap: ${this.formatBytes(usage.heapUsed)}`;
  }

  formatBytes(bytes) {
    return `${(bytes / 1024 / 1024).toFixed(2)}MB`;
  }
}

module.exports = MemoryLeakDetector;
```

---

## 6. ğŸ“ˆ æ€§èƒ½ç›‘æ§å®è·µ


### 6.1 æ€§èƒ½æŒ‡æ ‡å®šä¹‰


**å…³é”®æ€§èƒ½æŒ‡æ ‡ï¼ˆKPIï¼‰**ï¼š

```javascript
// ğŸ“ monitoring/performance-metrics.js
class PerformanceMetrics {
  constructor() {
    this.metrics = {
      // æ¶ˆæ¯ååé‡
      throughput: {
        messagesPerSecond: 0,
        totalMessages: 0,
        lastCalculated: Date.now()
      },
      
      // å»¶è¿ŸæŒ‡æ ‡
      latency: {
        averageLatency: 0,
        minLatency: Infinity,
        maxLatency: 0,
        samples: []
      },
      
      // é”™è¯¯ç‡
      errorRate: {
        totalErrors: 0,
        totalRequests: 0,
        rate: 0
      },
      
      // è¿æ¥çŠ¶æ€
      connections: {
        active: 0,
        total: 0,
        failed: 0
      }
    };
  }

  // è®°å½•æ¶ˆæ¯å‘é€
  recordMessageSent() {
    this.metrics.throughput.totalMessages++;
    this.calculateThroughput();
  }

  // è®°å½•æ¶ˆæ¯å»¶è¿Ÿ
  recordLatency(latency) {
    const latencyMetrics = this.metrics.latency;
    
    latencyMetrics.samples.push(latency);
    latencyMetrics.minLatency = Math.min(latencyMetrics.minLatency, latency);
    latencyMetrics.maxLatency = Math.max(latencyMetrics.maxLatency, latency);
    
    // è®¡ç®—å¹³å‡å»¶è¿Ÿï¼ˆä¿ç•™æœ€è¿‘100ä¸ªæ ·æœ¬ï¼‰
    if (latencyMetrics.samples.length > 100) {
      latencyMetrics.samples = latencyMetrics.samples.slice(-100);
    }
    
    latencyMetrics.averageLatency = latencyMetrics.samples.reduce((sum, val) => sum + val, 0) / latencyMetrics.samples.length;
  }

  // è®°å½•é”™è¯¯
  recordError() {
    this.metrics.errorRate.totalErrors++;
    this.calculateErrorRate();
  }

  // è®°å½•è¯·æ±‚
  recordRequest() {
    this.metrics.errorRate.totalRequests++;
    this.calculateErrorRate();
  }

  // è®¡ç®—ååé‡
  calculateThroughput() {
    const now = Date.now();
    const timeDiff = (now - this.metrics.throughput.lastCalculated) / 1000;
    
    if (timeDiff >= 1) { // æ¯ç§’è®¡ç®—ä¸€æ¬¡
      this.metrics.throughput.messagesPerSecond = this.metrics.throughput.totalMessages / timeDiff;
      this.metrics.throughput.lastCalculated = now;
    }
  }

  // è®¡ç®—é”™è¯¯ç‡
  calculateErrorRate() {
    const { totalErrors, totalRequests } = this.metrics.errorRate;
    this.metrics.errorRate.rate = totalRequests > 0 ? (totalErrors / totalRequests) * 100 : 0;
  }

  // è·å–æ€§èƒ½æŠ¥å‘Š
  getReport() {
    return {
      timestamp: new Date().toISOString(),
      throughput: `${this.metrics.throughput.messagesPerSecond.toFixed(2)} msg/s`,
      latency: {
        average: `${this.metrics.latency.averageLatency.toFixed(2)}ms`,
        min: `${this.metrics.latency.minLatency}ms`,
        max: `${this.metrics.latency.maxLatency}ms`
      },
      errorRate: `${this.metrics.errorRate.rate.toFixed(2)}%`,
      connections: this.metrics.connections
    };
  }

  // é‡ç½®æŒ‡æ ‡
  reset() {
    this.metrics.throughput.totalMessages = 0;
    this.metrics.throughput.messagesPerSecond = 0;
    this.metrics.latency.samples = [];
    this.metrics.errorRate.totalErrors = 0;
    this.metrics.errorRate.totalRequests = 0;
  }
}
```

### 6.2 å®æ—¶æ€§èƒ½ç›‘æ§


**æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿**ï¼š

```javascript
// ğŸ“ monitoring/performance-dashboard.js
class PerformanceDashboard {
  constructor(metrics, updateInterval = 5000) {
    this.metrics = metrics;
    this.updateInterval = updateInterval;
    this.isRunning = false;
  }

  // å¯åŠ¨ç›‘æ§
  start() {
    if (this.isRunning) return;
    
    this.isRunning = true;
    console.log('ğŸ“Š æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿å¯åŠ¨');
    
    this.timer = setInterval(() => {
      this.displayDashboard();
    }, this.updateInterval);
  }

  // åœæ­¢ç›‘æ§
  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.isRunning = false;
      console.log('â¹ï¸ æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿åœæ­¢');
    }
  }

  // æ˜¾ç¤ºä»ªè¡¨æ¿
  displayDashboard() {
    const report = this.metrics.getReport();
    
    console.clear(); // æ¸…å±ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘        RabbitMQ æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿        â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log(`â•‘ ğŸ“Š ååé‡: ${report.throughput.padEnd(15)} â•‘`);
    console.log(`â•‘ â±ï¸  å¹³å‡å»¶è¿Ÿ: ${report.latency.average.padEnd(12)} â•‘`);
    console.log(`â•‘ ğŸ“ˆ æœ€å°å»¶è¿Ÿ: ${report.latency.min.padEnd(12)} â•‘`);
    console.log(`â•‘ ğŸ“‰ æœ€å¤§å»¶è¿Ÿ: ${report.latency.max.padEnd(12)} â•‘`);
    console.log(`â•‘ âŒ é”™è¯¯ç‡: ${report.errorRate.padEnd(14)} â•‘`);
    console.log(`â•‘ ğŸ”— æ´»è·ƒè¿æ¥: ${report.connections.active.toString().padEnd(11)} â•‘`);
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`â° æ›´æ–°æ—¶é—´: ${report.timestamp}`);
    
    // æ€§èƒ½å‘Šè­¦
    this.checkAlerts(report);
  }

  // æ£€æŸ¥æ€§èƒ½å‘Šè­¦
  checkAlerts(report) {
    const alerts = [];
    
    // å»¶è¿Ÿå‘Šè­¦
    const avgLatency = parseFloat(report.latency.average);
    if (avgLatency > 1000) {
      alerts.push(`ğŸš¨ é«˜å»¶è¿Ÿå‘Šè­¦: ${report.latency.average}`);
    }
    
    // é”™è¯¯ç‡å‘Šè­¦
    const errorRate = parseFloat(report.errorRate);
    if (errorRate > 5) {
      alerts.push(`ğŸš¨ é«˜é”™è¯¯ç‡å‘Šè­¦: ${report.errorRate}`);
    }
    
    // ååé‡å‘Šè­¦
    const throughput = parseFloat(report.throughput);
    if (throughput < 10) {
      alerts.push(`ğŸš¨ ä½ååé‡å‘Šè­¦: ${report.throughput}`);
    }
    
    // æ˜¾ç¤ºå‘Šè­¦
    if (alerts.length > 0) {
      console.log('\nğŸš¨ æ€§èƒ½å‘Šè­¦:');
      alerts.forEach(alert => console.log(`   ${alert}`));
    }
  }

  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generateReport() {
    const report = this.metrics.getReport();
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `performance-report-${timestamp}.json`;
    
    const detailedReport = {
      ...report,
      systemInfo: {
        nodeVersion: process.version,
        platform: process.platform,
        memoryUsage: process.memoryUsage(),
        uptime: process.uptime()
      }
    };
    
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä¿å­˜åˆ°æ–‡ä»¶
    console.log('ğŸ“„ æ€§èƒ½æŠ¥å‘Šç”Ÿæˆ:', JSON.stringify(detailedReport, null, 2));
    
    return detailedReport;
  }
}
```

### 6.3 æ€§èƒ½æµ‹è¯•å·¥å…·


**è´Ÿè½½æµ‹è¯•å·¥å…·**ï¼š

```javascript
// ğŸ“ testing/load-tester.js
class RabbitMQLoadTester {
  constructor(connectionConfig) {
    this.config = connectionConfig;
    this.metrics = new PerformanceMetrics();
    this.isRunning = false;
  }

  // æ¶ˆæ¯å‘é€è´Ÿè½½æµ‹è¯•
  async runSendLoadTest(options = {}) {
    const {
      queueName = 'load_test_queue',
      messageCount = 1000,
      concurrency = 10,
      messageSize = 100
    } = options;

    console.log('ğŸš€ å¼€å§‹æ¶ˆæ¯å‘é€è´Ÿè½½æµ‹è¯•...');
    console.log(`ğŸ“Š æµ‹è¯•å‚æ•°: æ¶ˆæ¯æ•°=${messageCount}, å¹¶å‘=${concurrency}, æ¶ˆæ¯å¤§å°=${messageSize}å­—èŠ‚`);

    const connection = await amqp.connect(this.config);
    const channel = await connection.createChannel();
    await channel.assertQueue(queueName, { durable: true });

    const startTime = Date.now();
    const promises = [];
    
    // ç”Ÿæˆæµ‹è¯•æ¶ˆæ¯
    const testMessage = 'x'.repeat(messageSize);

    // å¹¶å‘å‘é€æ¶ˆæ¯
    for (let i = 0; i < concurrency; i++) {
      const promise = this.sendMessagesWorker(
        channel, 
        queueName, 
        testMessage, 
        Math.floor(messageCount / concurrency)
      );
      promises.push(promise);
    }

    try {
      await Promise.all(promises);
      const endTime = Date.now();
      const duration = (endTime - startTime) / 1000;
      
      console.log('âœ… è´Ÿè½½æµ‹è¯•å®Œæˆ');
      console.log(`ğŸ“Š æµ‹è¯•ç»“æœ: ${messageCount} æ¶ˆæ¯åœ¨ ${duration.toFixed(2)} ç§’å†…å‘é€å®Œæˆ`);
      console.log(`ğŸ“ˆ å¹³å‡ååé‡: ${(messageCount / duration).toFixed(2)} æ¶ˆæ¯/ç§’`);
      
    } catch (error) {
      console.error('âŒ è´Ÿè½½æµ‹è¯•å¤±è´¥:', error.message);
    } finally {
      await channel.close();
      await connection.close();
    }
  }

  // æ¶ˆæ¯å‘é€å·¥ä½œå™¨
  async sendMessagesWorker(channel, queueName, message, count) {
    for (let i = 0; i < count; i++) {
      const startTime = Date.now();
      
      try {
        await channel.sendToQueue(queueName, Buffer.from(message), { persistent: true });
        
        const latency = Date.now() - startTime;
        this.metrics.recordLatency(latency);
        this.metrics.recordMessageSent();
        this.metrics.recordRequest();
        
      } catch (error) {
        this.metrics.recordError();
        console.error(`âŒ å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`);
      }
    }
  }

  // æ¶ˆæ¯æ¶ˆè´¹è´Ÿè½½æµ‹è¯•
  async runConsumeLoadTest(options = {}) {
    const {
      queueName = 'load_test_queue',
      consumerCount = 5,
      testDuration = 30000 // 30ç§’
    } = options;

    console.log('ğŸ”„ å¼€å§‹æ¶ˆæ¯æ¶ˆè´¹è´Ÿè½½æµ‹è¯•...');
    console.log(`ğŸ“Š æµ‹è¯•å‚æ•°: æ¶ˆè´¹è€…æ•°=${consumerCount}, æµ‹è¯•æ—¶é•¿=${testDuration}ms`);

    const connections = [];
    const channels = [];

    // åˆ›å»ºå¤šä¸ªæ¶ˆè´¹è€…
    for (let i = 0; i < consumerCount; i++) {
      const connection = await amqp.connect(this.config);
      const channel = await connection.createChannel();
      await channel.assertQueue(queueName, { durable: true });
      await channel.prefetch(1);

      connections.push(connection);
      channels.push(channel);

      // å¯åŠ¨æ¶ˆè´¹è€…
      this.startConsumer(channel, queueName, i);
    }

    // è¿è¡ŒæŒ‡å®šæ—¶é—´
    await new Promise(resolve => setTimeout(resolve, testDuration));

    // æ¸…ç†èµ„æº
    for (let i = 0; i < channels.length; i++) {
      await channels[i].close();
      await connections[i].close();
    }

    console.log('âœ… æ¶ˆè´¹è´Ÿè½½æµ‹è¯•å®Œæˆ');
    console.log('ğŸ“Š æµ‹è¯•ç»“æœ:', this.metrics.getReport());
  }

  // å¯åŠ¨æ¶ˆè´¹è€…
  startConsumer(channel, queueName, consumerId) {
    channel.consume(queueName, (msg) => {
      if (msg) {
        const startTime = Date.now();
        
        // æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†
        setTimeout(() => {
          const latency = Date.now() - startTime;
          this.metrics.recordLatency(latency);
          this.metrics.recordRequest();
          
          channel.ack(msg);
        }, Math.random() * 10); // éšæœºå¤„ç†æ—¶é—´
      }
    });

    console.log(`ğŸ‘‚ æ¶ˆè´¹è€… ${consumerId} å·²å¯åŠ¨`);
  }
}
```

---

## 7. ğŸš€ å®æˆ˜é¡¹ç›®æ¡ˆä¾‹


### 7.1 ç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ


**è®¢å•å¤„ç†æ¶æ„**ï¼š

```
    ç”¨æˆ·ä¸‹å•           è®¢å•é˜Ÿåˆ—           è®¢å•å¤„ç†å™¨
        â”‚                 â”‚                 â”‚
        â–¼                 â–¼                 â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Webåº”ç”¨  â”‚ â”€â”€â”€â”€â–º â”‚ RabbitMQ â”‚ â”€â”€â”€â”€â–º â”‚ è®¢å•æœåŠ¡ â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚                 â”‚
        â–¼                 â–¼                 â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ æ”¯ä»˜è¯·æ±‚ â”‚ â”€â”€â”€â”€â–º â”‚ æ”¯ä»˜é˜Ÿåˆ— â”‚ â”€â”€â”€â”€â–º â”‚ æ”¯ä»˜æœåŠ¡ â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚                 â”‚
        â–¼                 â–¼                 â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ åº“å­˜æ›´æ–° â”‚ â”€â”€â”€â”€â–º â”‚ åº“å­˜é˜Ÿåˆ— â”‚ â”€â”€â”€â”€â–º â”‚ åº“å­˜æœåŠ¡ â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è®¢å•å¤„ç†å®ç°**ï¼š

```javascript
// ğŸ“ services/order-processing-system.js
class OrderProcessingSystem {
  constructor(channel) {
    this.channel = channel;
    this.queues = {
      orders: 'order.created',
      payments: 'payment.process',
      inventory: 'inventory.update',
      notifications: 'notification.send'
    };
  }

  // åˆå§‹åŒ–ç³»ç»Ÿ
  async initialize() {
    console.log('ğŸª åˆå§‹åŒ–ç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ...');
    
    // å£°æ˜æ‰€æœ‰é˜Ÿåˆ—
    for (const [name, queueName] of Object.entries(this.queues)) {
      await this.channel.assertQueue(queueName, { 
        durable: true,
        arguments: {
          'x-max-retries': 3, // æœ€å¤§é‡è¯•æ¬¡æ•°
          'x-message-ttl': 300000 // æ¶ˆæ¯TTL: 5åˆ†é’Ÿ
        }
      });
      console.log(`âœ… é˜Ÿåˆ— ${name} (${queueName}) åˆå§‹åŒ–å®Œæˆ`);
    }

    // è®¾ç½®æ­»ä¿¡é˜Ÿåˆ—
    await this.setupDeadLetterQueues();
  }

  // è®¾ç½®æ­»ä¿¡é˜Ÿåˆ—
  async setupDeadLetterQueues() {
    const dlxExchange = 'order.dlx';
    await this.channel.assertExchange(dlxExchange, 'direct', { durable: true });

    for (const queueName of Object.values(this.queues)) {
      const dlqName = `${queueName}.dlq`;
      await this.channel.assertQueue(dlqName, { durable: true });
      await this.channel.bindQueue(dlqName, dlxExchange, queueName);
    }

    console.log('â˜ ï¸ æ­»ä¿¡é˜Ÿåˆ—è®¾ç½®å®Œæˆ');
  }

  // å¤„ç†æ–°è®¢å•
  async processNewOrder(orderData) {
    try {
      console.log(`ğŸ“ å¤„ç†æ–°è®¢å•: ${orderData.orderId}`);

      // 1. è®¢å•åŸºç¡€éªŒè¯
      if (!this.validateOrder(orderData)) {
        throw new Error('è®¢å•æ•°æ®éªŒè¯å¤±è´¥');
      }

      // 2. å‘é€åˆ°è®¢å•å¤„ç†é˜Ÿåˆ—
      await this.sendToQueue(this.queues.orders, {
        type: 'order.created',
        orderId: orderData.orderId,
        userId: orderData.userId,
        items: orderData.items,
        totalAmount: orderData.totalAmount,
        timestamp: new Date().toISOString()
      });

      console.log(`âœ… è®¢å• ${orderData.orderId} å·²æäº¤å¤„ç†`);
      return { success: true, orderId: orderData.orderId };

    } catch (error) {
      console.error(`âŒ è®¢å•å¤„ç†å¤±è´¥: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  // å¯åŠ¨è®¢å•æ¶ˆè´¹è€…
  async startOrderConsumer() {
    console.log('ğŸ‘‚ å¯åŠ¨è®¢å•æ¶ˆè´¹è€…...');

    await this.channel.consume(this.queues.orders, async (msg) => {
      if (msg) {
        try {
          const orderData = JSON.parse(msg.content.toString());
          console.log(`ğŸ“¦ å¤„ç†è®¢å•: ${orderData.orderId}`);

          // å¤„ç†è®¢å•é€»è¾‘
          await this.handleOrderCreated(orderData);
          
          this.channel.ack(msg);
        } catch (error) {
          console.error(`âŒ è®¢å•å¤„ç†é”™è¯¯: ${error.message}`);
          this.channel.nack(msg, false, false); // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
        }
      }
    });
  }

  // å¤„ç†è®¢å•åˆ›å»º
  async handleOrderCreated(orderData) {
    // 1. æ£€æŸ¥åº“å­˜
    const inventoryCheck = await this.checkInventory(orderData.items);
    if (!inventoryCheck.available) {
      throw new Error(`åº“å­˜ä¸è¶³: ${inventoryCheck.missingItems.join(', ')}`);
    }

    // 2. å‘é€æ”¯ä»˜å¤„ç†è¯·æ±‚
    await this.sendToQueue(this.queues.payments, {
      type: 'payment.process',
      orderId: orderData.orderId,
      amount: orderData.totalAmount,
      userId: orderData.userId
    });

    // 3. é¢„æ‰£åº“å­˜
    await this.sendToQueue(this.queues.inventory, {
      type: 'inventory.reserve',
      orderId: orderData.orderId,
      items: orderData.items
    });

    console.log(`ğŸ”„ è®¢å• ${orderData.orderId} è¿›å…¥æ”¯ä»˜å’Œåº“å­˜å¤„ç†æµç¨‹`);
  }

  // æ£€æŸ¥åº“å­˜
  async checkInventory(items) {
    // æ¨¡æ‹Ÿåº“å­˜æ£€æŸ¥
    const missingItems = [];
    const availableItems = [];

    for (const item of items) {
      // è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„åº“å­˜æœåŠ¡
      const stock = await this.getItemStock(item.productId);
      
      if (stock >= item.quantity) {
        availableItems.push(item);
      } else {
        missingItems.push(`${item.productName} (éœ€è¦${item.quantity}, åº“å­˜${stock})`);
      }
    }

    return {
      available: missingItems.length === 0,
      availableItems,
      missingItems
    };
  }

  // è·å–å•†å“åº“å­˜ï¼ˆæ¨¡æ‹Ÿï¼‰
  async getItemStock(productId) {
    // æ¨¡æ‹Ÿå¼‚æ­¥åº“å­˜æŸ¥è¯¢
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(Math.floor(Math.random() * 100)); // éšæœºåº“å­˜
      }, 100);
    });
  }

  // å‘é€æ¶ˆæ¯åˆ°é˜Ÿåˆ—
  async sendToQueue(queueName, message) {
    const messageBuffer = Buffer.from(JSON.stringify(message));
    const success = this.channel.sendToQueue(queueName, messageBuffer, {
      persistent: true,
      timestamp: Date.now(),
      messageId: `${message.type}-${Date.now()}-${Math.random()}`
    });

    if (!success) {
      console.warn(`âš ï¸ æ¶ˆæ¯å‘é€å¯èƒ½å¤±è´¥: ${queueName}`);
    }
  }

  // éªŒè¯è®¢å•æ•°æ®
  validateOrder(orderData) {
    const required = ['orderId', 'userId', 'items', 'totalAmount'];
    
    for (const field of required) {
      if (!orderData[field]) {
        console.error(`âŒ ç¼ºå°‘å¿…éœ€å­—æ®µ: ${field}`);
        return false;
      }
    }

    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {
      console.error(`âŒ è®¢å•é¡¹ç›®æ— æ•ˆ`);
      return false;
    }

    return true;
  }
}
```

### 7.2 å®æ—¶é€šçŸ¥ç³»ç»Ÿ


**é€šçŸ¥ç³»ç»Ÿå®ç°**ï¼š

```javascript
// ğŸ“ services/notification-system.js
class NotificationSystem {
  constructor(channel) {
    this.channel = channel;
    this.notificationTypes = {
      email: 'notification.email',
      sms: 'notification.sms',
      push: 'notification.push',
      websocket: 'notification.websocket'
    };
  }

  // åˆå§‹åŒ–é€šçŸ¥ç³»ç»Ÿ
  async initialize() {
    console.log('ğŸ”” åˆå§‹åŒ–é€šçŸ¥ç³»ç»Ÿ...');

    // åˆ›å»ºé€šçŸ¥äº¤æ¢æœº
    await this.channel.assertExchange('notifications', 'topic', { durable: true });

    // åˆ›å»ºä¸åŒç±»å‹çš„é€šçŸ¥é˜Ÿåˆ—
    for (const [type, queueName] of Object.entries(this.notificationTypes)) {
      await this.channel.assertQueue(queueName, { durable: true });
      
      // ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢æœº
      const routingKey = `notification.${type}.*`;
      await this.channel.bindQueue(queueName, 'notifications', routingKey);
      
      console.log(`ğŸ“§ ${type} é€šçŸ¥é˜Ÿåˆ—å·²è®¾ç½®: ${queueName}`);
    }

    // å¯åŠ¨é€šçŸ¥æ¶ˆè´¹è€…
    this.startNotificationConsumers();
  }

  // å‘é€é€šçŸ¥
  async sendNotification(type, recipient, message, priority = 'normal') {
    try {
      const notification = {
        id: this.generateNotificationId(),
        type,
        recipient,
        message,
        priority,
        timestamp: new Date().toISOString(),
        attempts: 0,
        maxAttempts: 3
      };

      const routingKey = `notification.${type}.${priority}`;
      
      await this.channel.publish(
        'notifications',
        routingKey,
        Buffer.from(JSON.stringify(notification)),
        {
          persistent: true,
          priority: priority === 'high' ? 10 : 1
        }
      );

      console.log(`ğŸ“¤ é€šçŸ¥å·²å‘é€: ${type} ç»™ ${recipient}`);
      return notification.id;

    } catch (error) {
      console.error(`âŒ å‘é€é€šçŸ¥å¤±è´¥:`, error.message);
      throw error;
    }
  }

  // å¯åŠ¨é€šçŸ¥æ¶ˆè´¹è€…
  startNotificationConsumers() {
    // é‚®ä»¶é€šçŸ¥æ¶ˆè´¹è€…
    this.startEmailConsumer();
    
    // SMSé€šçŸ¥æ¶ˆè´¹è€…
    this.startSMSConsumer();
    
    // æ¨é€é€šçŸ¥æ¶ˆè´¹è€…
    this.startPushConsumer();
    
    // WebSocketé€šçŸ¥æ¶ˆè´¹è€…
    this.startWebSocketConsumer();
  }

  // é‚®ä»¶é€šçŸ¥æ¶ˆè´¹è€…
  async startEmailConsumer() {
    await this.channel.consume(this.notificationTypes.email, async (msg) => {
      if (msg) {
        try {
          const notification = JSON.parse(msg.content.toString());
          console.log(`ğŸ“§ å¤„ç†é‚®ä»¶é€šçŸ¥: ${notification.recipient}`);
          
          // æ¨¡æ‹Ÿé‚®ä»¶å‘é€
          await this.sendEmail(notification);
          
          this.channel.ack(msg);
          console.log(`âœ… é‚®ä»¶å‘é€æˆåŠŸ: ${notification.recipient}`);
          
        } catch (error) {
          console.error(`âŒ é‚®ä»¶å‘é€å¤±è´¥:`, error.message);
          this.channel.nack(msg, false, true); // é‡æ–°æ’é˜Ÿ
        }
      }
    });
  }

  // SMSé€šçŸ¥æ¶ˆè´¹è€…
  async startSMSConsumer() {
    await this.channel.consume(this.notificationTypes.sms, async (msg) => {
      if (msg) {
        try {
          const notification = JSON.parse(msg.content.toString());
          console.log(`ğŸ“± å¤„ç†SMSé€šçŸ¥: ${notification.recipient}`);
          
          // æ¨¡æ‹ŸSMSå‘é€
          await this.sendSMS(notification);
          
          this.channel.ack(msg);
          console.log(`âœ… SMSå‘é€æˆåŠŸ: ${notification.recipient}`);
          
        } catch (error) {
          console.error(`âŒ SMSå‘é€å¤±è´¥:`, error.message);
          this.channel.nack(msg, false, true);
        }
      }
    });
  }

  // æ¨é€é€šçŸ¥æ¶ˆè´¹è€…
  async startPushConsumer() {
    await this.channel.consume(this.notificationTypes.push, async (msg) => {
      if (msg) {
        try {
          const notification = JSON.parse(msg.content.toString());
          console.log(`ğŸ“² å¤„ç†æ¨é€é€šçŸ¥: ${notification.recipient}`);
          
          // æ¨¡æ‹Ÿæ¨é€å‘é€
          await this.sendPushNotification(notification);
          
          this.channel.ack(msg);
          console.log(`âœ… æ¨é€å‘é€æˆåŠŸ: ${notification.recipient}`);
          
        } catch (error) {
          console.error(`âŒ æ¨é€å‘é€å¤±è´¥:`, error.message);
          this.channel.nack(msg, false, true);
        }
      }
    });
  }

  // WebSocketé€šçŸ¥æ¶ˆè´¹è€…
  async startWebSocketConsumer() {
    await this.channel.consume(this.notificationTypes.websocket, async (msg) => {
      if (msg) {
        try {
          const notification = JSON.parse(msg.content.toString());
          console.log(`ğŸŒ å¤„ç†WebSocketé€šçŸ¥: ${notification.recipient}`);
          
          // æ¨¡æ‹ŸWebSocketå‘é€
          await this.sendWebSocketNotification(notification);
          
          this.channel.ack(msg);
          console.log(`âœ… WebSocketå‘é€æˆåŠŸ: ${notification.recipient}`);
          
        } catch (error) {
          console.error(`âŒ WebSocketå‘é€å¤±è´¥:`, error.message);
          this.channel.nack(msg, false, true);
        }
      }
    });
  }

  // å‘é€é‚®ä»¶ï¼ˆæ¨¡æ‹Ÿï¼‰
  async sendEmail(notification) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.1) { // 90% æˆåŠŸç‡
          resolve();
        } else {
          reject(new Error('é‚®ä»¶æœåŠ¡æš‚æ—¶ä¸å¯ç”¨'));
        }
      }, 1000); // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    });
  }

  // å‘é€SMSï¼ˆæ¨¡æ‹Ÿï¼‰
  async sendSMS(notification) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.05) { // 95% æˆåŠŸç‡
          resolve();
        } else {
          reject(new Error('SMSç½‘å…³é”™è¯¯'));
        }
      }, 500);
    });
  }

  // å‘é€æ¨é€é€šçŸ¥ï¼ˆæ¨¡æ‹Ÿï¼‰
  async sendPushNotification(notification) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.02) { // 98% æˆåŠŸç‡
          resolve();
        } else {
          reject(new Error('æ¨é€æœåŠ¡è¿æ¥å¤±è´¥'));
        }
      }, 300);
    });
  }

  // å‘é€WebSocketé€šçŸ¥ï¼ˆæ¨¡æ‹Ÿï¼‰
  async sendWebSocketNotification(notification) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.01) { // 99% æˆåŠŸç‡
          resolve();
        } else {
          reject(new Error('WebSocketè¿æ¥æ–­å¼€'));
        }
      }, 100);
    });
  }

  // ç”Ÿæˆé€šçŸ¥ID
  generateNotificationId() {
    return `notification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // æ‰¹é‡å‘é€é€šçŸ¥
  async sendBatchNotifications(notifications) {
    const results = [];
    
    for (const notification of notifications) {
      try {
        const id = await this.sendNotification(
          notification.type,
          notification.recipient,
          notification.message,
          notification.priority
        );
        
        results.push({ success: true, id, notification });
      } catch (error) {
        results.push({ success: false, error: error.message, notification });
      }
    }

    const successCount = results.filter(r => r.success).length;
    console.log(`ğŸ“Š æ‰¹é‡é€šçŸ¥å®Œæˆ: ${successCount}/${notifications.length}`);
    
    return results;
  }
}
```

### 7.3 å®Œæ•´åº”ç”¨ç¤ºä¾‹


**ä¸»åº”ç”¨ç¨‹åº**ï¼š

```javascript
// ğŸ“ app.js - å®Œæ•´çš„RabbitMQ Node.jsåº”ç”¨
const amqp = require('amqplib');
const RabbitMQManager = require('./utils/rabbitmq-manager');
const OrderProcessingSystem = require('./services/order-processing-system');
const NotificationSystem = require('./services/notification-system');
const MemoryMonitor = require('./utils/memory-monitor');
const PerformanceMetrics = require('./monitoring/performance-metrics');
const PerformanceDashboard = require('./monitoring/performance-dashboard');

class ECommerceApp {
  constructor() {
    this.rabbitmqManager = null;
    this.orderSystem = null;
    this.notificationSystem = null;
    this.memoryMonitor = new MemoryMonitor();
    this.metrics = new PerformanceMetrics();
    this.dashboard = null;
  }

  // å¯åŠ¨åº”ç”¨
  async start() {
    try {
      console.log('ğŸš€ å¯åŠ¨ç”µå•†åº”ç”¨...');

      // 1. è¿æ¥RabbitMQ
      await this.connectRabbitMQ();

      // 2. åˆå§‹åŒ–å„ä¸ªç³»ç»Ÿ
      await this.initializeSystems();

      // 3. å¯åŠ¨ç›‘æ§
      this.startMonitoring();

      // 4. å¯åŠ¨æ¶ˆè´¹è€…
      await this.startConsumers();

      // 5. æ¨¡æ‹Ÿä¸šåŠ¡æµé‡
      this.simulateTraffic();

      console.log('âœ… åº”ç”¨å¯åŠ¨å®Œæˆ');

    } catch (error) {
      console.error('âŒ åº”ç”¨å¯åŠ¨å¤±è´¥:', error.message);
      process.exit(1);
    }
  }

  // è¿æ¥RabbitMQ
  async connectRabbitMQ() {
    console.log('ğŸ”Œ è¿æ¥RabbitMQ...');
    this.rabbitmqManager = require('./utils/rabbitmq-manager');
    const channel = await this.rabbitmqManager.connect();
    this.channel = channel;
  }

  // åˆå§‹åŒ–ç³»ç»Ÿ
  async initializeSystems() {
    console.log('âš™ï¸ åˆå§‹åŒ–ç³»ç»Ÿç»„ä»¶...');
    
    // åˆå§‹åŒ–è®¢å•ç³»ç»Ÿ
    this.orderSystem = new OrderProcessingSystem(this.channel);
    await this.orderSystem.initialize();

    // åˆå§‹åŒ–é€šçŸ¥ç³»ç»Ÿ
    this.notificationSystem = new NotificationSystem(this.channel);
    await this.notificationSystem.initialize();
  }

  // å¯åŠ¨ç›‘æ§
  startMonitoring() {
    console.log('ğŸ“Š å¯åŠ¨ç›‘æ§ç³»ç»Ÿ...');
    
    // å¯åŠ¨å†…å­˜ç›‘æ§
    this.memoryMonitor.start();
    
    // å¯åŠ¨æ€§èƒ½ä»ªè¡¨æ¿
    this.dashboard = new PerformanceDashboard(this.metrics);
    this.dashboard.start();
  }

  // å¯åŠ¨æ¶ˆè´¹è€…
  async startConsumers() {
    console.log('ğŸ‘‚ å¯åŠ¨æ¶ˆæ¯æ¶ˆè´¹è€…...');
    
    // å¯åŠ¨è®¢å•æ¶ˆè´¹è€…
    await this.orderSystem.startOrderConsumer();
    
    console.log('âœ… æ‰€æœ‰æ¶ˆè´¹è€…å¯åŠ¨å®Œæˆ');
  }

  // æ¨¡æ‹Ÿä¸šåŠ¡æµé‡
  simulateTraffic() {
    console.log('ğŸŒŠ å¼€å§‹æ¨¡æ‹Ÿä¸šåŠ¡æµé‡...');
    
    // æ¯5ç§’åˆ›å»ºä¸€ä¸ªæ–°è®¢å•
    setInterval(async () => {
      try {
        const mockOrder = this.generateMockOrder();
        await this.processOrder(mockOrder);
        
        // å‘é€è®¢å•ç¡®è®¤é€šçŸ¥
        await this.notificationSystem.sendNotification(
          'email',
          mockOrder.userEmail,
          `æ‚¨çš„è®¢å• ${mockOrder.orderId} å·²ç¡®è®¤`,
          'normal'
        );
        
      } catch (error) {
        console.error('âŒ æ¨¡æ‹Ÿæµé‡å¤„ç†å¤±è´¥:', error.message);
      }
    }, 5000);

    // æ¯10ç§’å‘é€ä¸€æ‰¹é€šçŸ¥
    setInterval(async () => {
      const notifications = this.generateMockNotifications();
      await this.notificationSystem.sendBatchNotifications(notifications);
    }, 10000);
  }

  // å¤„ç†è®¢å•
  async processOrder(orderData) {
    const startTime = Date.now();
    
    try {
      const result = await this.orderSystem.processNewOrder(orderData);
      
      const latency = Date.now() - startTime;
      this.metrics.recordLatency(latency);
      this.metrics.recordMessageSent();
      this.metrics.recordRequest();
      
      if (result.success) {
        console.log(`âœ… è®¢å•å¤„ç†æˆåŠŸ: ${result.orderId}`);
      } else {
        this.metrics.recordError();
        console.error(`âŒ è®¢å•å¤„ç†å¤±è´¥: ${result.error}`);
      }
      
      return result;
      
    } catch (error) {
      this.metrics.recordError();
      throw error;
    }
  }

  // ç”Ÿæˆæ¨¡æ‹Ÿè®¢å•
  generateMockOrder() {
    const orderId = `ORDER_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
    const userId = `USER_${Math.floor(Math.random() * 1000)}`;
    
    return {
      orderId,
      userId,
      userEmail: `user${userId}@example.com`,
      items: [
        {
          productId: `PROD_${Math.floor(Math.random() * 100)}`,
          productName: `å•†å“ ${Math.floor(Math.random() * 100)}`,
          quantity: Math.floor(Math.random() * 5) + 1,
          price: Math.floor(Math.random() * 1000) + 100
        }
      ],
      totalAmount: Math.floor(Math.random() * 5000) + 100,
      timestamp: new Date().toISOString()
    };
  }

  // ç”Ÿæˆæ¨¡æ‹Ÿé€šçŸ¥
  generateMockNotifications() {
    const types = ['email', 'sms', 'push', 'websocket'];
    const priorities = ['normal', 'high'];
    const notifications = [];
    
    for (let i = 0; i < 3; i++) {
      notifications.push({
        type: types[Math.floor(Math.random() * types.length)],
        recipient: `user${Math.floor(Math.random() * 100)}@example.com`,
        message: `æ¨¡æ‹Ÿé€šçŸ¥æ¶ˆæ¯ ${Date.now()}`,
        priority: priorities[Math.floor(Math.random() * priorities.length)]
      });
    }
    
    return notifications;
  }

  // ä¼˜é›…å…³é—­
  async shutdown() {
    console.log('ğŸ”„ å¼€å§‹ä¼˜é›…å…³é—­...');
    
    try {
      // åœæ­¢ç›‘æ§
      this.memoryMonitor.stop();
      if (this.dashboard) {
        this.dashboard.stop();
      }
      
      // ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š
      const finalReport = this.dashboard.generateReport();
      console.log('ğŸ“„ æœ€ç»ˆæ€§èƒ½æŠ¥å‘Š:', finalReport);
      
      // å…³é—­RabbitMQè¿æ¥
      await this.rabbitmqManager.close();
      
      console.log('âœ… åº”ç”¨å·²ä¼˜é›…å…³é—­');
      process.exit(0);
      
    } catch (error) {
      console.error('âŒ å…³é—­è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error.message);
      process.exit(1);
    }
  }
}

// å¯åŠ¨åº”ç”¨
const app = new ECommerceApp();

// å¤„ç†é€€å‡ºä¿¡å·
process.on('SIGINT', () => {
  console.log('\nğŸ“¢ æ”¶åˆ°é€€å‡ºä¿¡å·...');
  app.shutdown();
});

process.on('SIGTERM', () => {
  console.log('\nğŸ“¢ æ”¶åˆ°ç»ˆæ­¢ä¿¡å·...');
  app.shutdown();
});

// å¯åŠ¨åº”ç”¨
app.start().catch(error => {
  console.error('ğŸ’¥ åº”ç”¨å¯åŠ¨å¤±è´¥:', error);
  process.exit(1);
});
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„åŸºæœ¬æ¦‚å¿µ


```
ğŸ”¸ amqplibå®¢æˆ·ç«¯ï¼šNode.jsä¸RabbitMQé€šä¿¡çš„æ¡¥æ¢
ğŸ”¸ Promise/asyncæ”¯æŒï¼šç°ä»£å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒ
ğŸ”¸ äº‹ä»¶é©±åŠ¨æ¨¡å¼ï¼šNode.jså¤©ç„¶é€‚åˆæ¶ˆæ¯é˜Ÿåˆ—å¼€å‘
ğŸ”¸ å†…å­˜ç®¡ç†ï¼šé¿å…å†…å­˜æ³„æ¼ï¼Œä¼˜åŒ–æ€§èƒ½
ğŸ”¸ æ€§èƒ½ç›‘æ§ï¼šå®æ—¶æŒæ¡ç³»ç»Ÿè¿è¡ŒçŠ¶æ€
```

### 8.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä¸ºä»€ä¹ˆé€‰æ‹©amqplib**
```
å®˜æ–¹æ”¯æŒï¼š
â€¢ RabbitMQå®˜æ–¹æ¨èçš„Node.jså®¢æˆ·ç«¯
â€¢ åŠŸèƒ½å®Œæ•´ï¼Œæ–‡æ¡£è¯¦ç»†
â€¢ ç¤¾åŒºæ´»è·ƒï¼Œé—®é¢˜å“åº”åŠæ—¶

æŠ€æœ¯ä¼˜åŠ¿ï¼š
â€¢ Promise/asyncåŸç”Ÿæ”¯æŒ
â€¢ TypeScriptç±»å‹å®šä¹‰
â€¢ è¿æ¥æ± å’Œé”™è¯¯å¤„ç†æœºåˆ¶å®Œå–„
```

**ğŸ”¹ å¼‚æ­¥ç¼–ç¨‹æœ€ä½³å®è·µ**
```
Promiseä¼˜åŠ¿ï¼š
â€¢ é¿å…å›è°ƒåœ°ç‹±
â€¢ é”™è¯¯å¤„ç†ç»Ÿä¸€
â€¢ ä»£ç å¯è¯»æ€§å¥½

async/awaitä¼˜åŠ¿ï¼š
â€¢ ä»£ç åƒåŒæ­¥ä¸€æ ·æ˜“è¯»
â€¢ é”™è¯¯å¤„ç†ç”¨try/catch
â€¢ ä¾¿äºè°ƒè¯•å’Œç»´æŠ¤
```

**ğŸ”¹ äº‹ä»¶é©±åŠ¨çš„æ ¸å¿ƒä»·å€¼**
```
éé˜»å¡ç‰¹æ€§ï¼š
â€¢ æ¶ˆæ¯å¤„ç†ä¸é˜»å¡ä¸»çº¿ç¨‹
â€¢ é«˜å¹¶å‘åœºæ™¯ä¸‹æ€§èƒ½ä¼˜ç§€
â€¢ èµ„æºåˆ©ç”¨ç‡é«˜

å¤©ç„¶é€‚é…ï¼š
â€¢ Node.jsäº‹ä»¶å¾ªç¯æœºåˆ¶
â€¢ RabbitMQå¼‚æ­¥æ¶ˆæ¯æ¨¡å¼
â€¢ å®Œç¾çš„æŠ€æœ¯åŒ¹é…
```

### 8.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


**å†…å­˜ç®¡ç†è¦ç‚¹**ï¼š
- âœ… **è¿æ¥å¤ç”¨**ï¼šä½¿ç”¨è¿æ¥æ± é¿å…é¢‘ç¹åˆ›å»ºè¿æ¥
- âœ… **ç›‘æ§å†…å­˜**ï¼šå®šæœŸæ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
- âœ… **åŠæ—¶æ¸…ç†**ï¼šä¸»åŠ¨æ¸…ç†ä¸éœ€è¦çš„ç›‘å¬å™¨
- âœ… **æ‰¹é‡å¤„ç†**ï¼šå‡å°‘å•æ¡æ¶ˆæ¯å¤„ç†å¼€é”€

**æ€§èƒ½ç›‘æ§æŒ‡æ ‡**ï¼š
- ğŸ“Š **ååé‡**ï¼šæ¶ˆæ¯å¤„ç†é€Ÿåº¦
- â±ï¸ **å»¶è¿Ÿ**ï¼šæ¶ˆæ¯å¤„ç†æ—¶é—´
- âŒ **é”™è¯¯ç‡**ï¼šå¤±è´¥æ¯”ä¾‹
- ğŸ”— **è¿æ¥çŠ¶æ€**ï¼šè¿æ¥å¥åº·åº¦

### 8.4 å®é™…åº”ç”¨å»ºè®®


**å¼€å‘ç¯å¢ƒé…ç½®**ï¼š
```bash
# å¯åŠ¨æ—¶æ·»åŠ å†…å­˜ç›‘æ§
node --expose-gc --max-old-space-size=4096 app.js

# å¼€å‘æ—¶å¯ç”¨è°ƒè¯•
DEBUG=amqplib:* node app.js
```

**ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–**ï¼š
```javascript
// ç”Ÿäº§ç¯å¢ƒé…ç½®ç¤ºä¾‹
const productionConfig = {
  // è¿æ¥é…ç½®
  heartbeat: 60,
  connection_timeout: 60000,
  
  // é€šé“é…ç½®
  prefetch: 10,
  
  // é‡è¯•é…ç½®
  maxRetries: 3,
  retryDelay: 5000,
  
  // ç›‘æ§é…ç½®
  enableMetrics: true,
  metricsInterval: 30000
};
```

**å¸¸è§é—®é¢˜è§£å†³**ï¼š

> âš ï¸ **è¿æ¥é¢‘ç¹æ–­å¼€**  
> æ£€æŸ¥ç½‘ç»œç¨³å®šæ€§ï¼Œå¢åŠ å¿ƒè·³é—´éš”ï¼Œå®ç°é‡è¿æœºåˆ¶

> âš ï¸ **å†…å­˜æŒç»­å¢é•¿**  
> æ£€æŸ¥äº‹ä»¶ç›‘å¬å™¨æ³„æ¼ï¼Œå®ç°å†…å­˜ç›‘æ§å‘Šè­¦

> âš ï¸ **æ¶ˆæ¯å¤„ç†ç¼“æ…¢**  
> å¢åŠ æ¶ˆè´¹è€…æ•°é‡ï¼Œä¼˜åŒ–æ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä½¿ç”¨æ‰¹é‡å¤„ç†

> âš ï¸ **æ¶ˆæ¯ä¸¢å¤±**  
> ç¡®ä¿æ¶ˆæ¯æŒä¹…åŒ–ï¼Œæ­£ç¡®å¤„ç†ACK/NACKï¼Œè®¾ç½®æ­»ä¿¡é˜Ÿåˆ—

### 8.5 å­¦ä¹ è·¯å¾„å»ºè®®


**æ–°æ‰‹å…¥é—¨è·¯å¾„**ï¼š
1. **åŸºç¡€è¿æ¥** â†’ å­¦ä¼šå»ºç«‹è¿æ¥å’Œåˆ›å»ºé€šé“
2. **ç®€å•å‘é€** â†’ æŒæ¡åŸºæœ¬çš„æ¶ˆæ¯å‘é€
3. **æ¶ˆæ¯æ¶ˆè´¹** â†’ ç†è§£æ¶ˆè´¹è€…æ¨¡å¼
4. **é”™è¯¯å¤„ç†** â†’ å­¦ä¼šå¤„ç†å„ç§å¼‚å¸¸æƒ…å†µ
5. **æ€§èƒ½ä¼˜åŒ–** â†’ å­¦ä¹ ç›‘æ§å’Œä¼˜åŒ–æŠ€å·§

**è¿›é˜¶å­¦ä¹ é‡ç‚¹**ï¼š
- ğŸš€ **é«˜å¯ç”¨æ¶æ„**ï¼šé›†ç¾¤éƒ¨ç½²ã€æ•…éšœè½¬ç§»
- ğŸ“Š **æ€§èƒ½è°ƒä¼˜**ï¼šè¿æ¥æ± ã€æ‰¹é‡å¤„ç†ã€å†…å­˜ä¼˜åŒ–
- ğŸ”§ **ç›‘æ§è¿ç»´**ï¼šæ—¥å¿—æ”¶é›†ã€æŒ‡æ ‡ç›‘æ§ã€å‘Šè­¦æœºåˆ¶
- ğŸ›¡ï¸ **å®‰å…¨é…ç½®**ï¼šSSL/TLSã€ç”¨æˆ·æƒé™ã€ç½‘ç»œå®‰å…¨

**æ ¸å¿ƒè®°å¿†**ï¼š
- amqplibæ˜¯Node.jsæ“ä½œRabbitMQçš„é¦–é€‰å®¢æˆ·ç«¯
- å¼‚æ­¥ç¼–ç¨‹ç”¨async/awaitï¼Œé¿å…å›è°ƒåœ°ç‹±
- äº‹ä»¶é©±åŠ¨å¤©ç„¶é€‚åˆæ¶ˆæ¯é˜Ÿåˆ—åœºæ™¯
- å†…å­˜ç®¡ç†å’Œæ€§èƒ½ç›‘æ§æ˜¯ç”Ÿäº§ç¯å¢ƒå¿…å¤‡
- å®æˆ˜é¡¹ç›®æ˜¯æŒæ¡æŠ€èƒ½çš„æœ€ä½³æ–¹å¼