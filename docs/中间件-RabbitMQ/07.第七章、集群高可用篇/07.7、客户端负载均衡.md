---
title: 7ã€å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡
---
## ğŸ“š ç›®å½•

1. [ä»€ä¹ˆæ˜¯å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡](#1-ä»€ä¹ˆæ˜¯å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡)
2. [å®¢æˆ·ç«¯è¿æ¥ç­–ç•¥è¯¦è§£](#2-å®¢æˆ·ç«¯è¿æ¥ç­–ç•¥è¯¦è§£)
3. [èŠ‚ç‚¹åˆ—è¡¨é…ç½®å®è·µ](#3-èŠ‚ç‚¹åˆ—è¡¨é…ç½®å®è·µ)
4. [æ•…éšœæ£€æµ‹ä¸è‡ªåŠ¨æ¢å¤](#4-æ•…éšœæ£€æµ‹ä¸è‡ªåŠ¨æ¢å¤)
5. [ä¸åŒSDKçš„è´Ÿè½½å‡è¡¡å®ç°](#5-ä¸åŒSDKçš„è´Ÿè½½å‡è¡¡å®ç°)
6. [æœ€ä½³å®è·µä¸æ€§èƒ½ä¼˜åŒ–](#6-æœ€ä½³å®è·µä¸æ€§èƒ½ä¼˜åŒ–)
7. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#7-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ¯ ä»€ä¹ˆæ˜¯å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡


### 1.1 åŸºæœ¬æ¦‚å¿µç†è§£


**ç®€å•æ¥è¯´**ï¼Œå®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡å°±æ˜¯è®©ä½ çš„åº”ç”¨ç¨‹åºè‡ªå·±å†³å®šè¿æ¥åˆ°RabbitMQé›†ç¾¤ä¸­çš„å“ªä¸ªèŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯ä¾èµ–å¤–éƒ¨çš„è´Ÿè½½å‡è¡¡å™¨ã€‚

```
ä¼ ç»Ÿæ–¹å¼ï¼ˆæœåŠ¡ç«¯è´Ÿè½½å‡è¡¡ï¼‰:
åº”ç”¨ â†’ è´Ÿè½½å‡è¡¡å™¨ â†’ RabbitMQèŠ‚ç‚¹1
              â†’ RabbitMQèŠ‚ç‚¹2  
              â†’ RabbitMQèŠ‚ç‚¹3

å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡æ–¹å¼:
åº”ç”¨å†…ç½®é€»è¾‘ â†’ ç›´æ¥è¿æ¥RabbitMQèŠ‚ç‚¹1
           â†’ ç›´æ¥è¿æ¥RabbitMQèŠ‚ç‚¹2
           â†’ ç›´æ¥è¿æ¥RabbitMQèŠ‚ç‚¹3
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡


**æ ¸å¿ƒåŸå› **ï¼š

ğŸ”¸ **å‡å°‘å•ç‚¹æ•…éšœ**
- ä¸ä¾èµ–é¢å¤–çš„è´Ÿè½½å‡è¡¡å™¨è®¾å¤‡
- é¿å…è´Ÿè½½å‡è¡¡å™¨æˆä¸ºç“¶é¢ˆ
- é™ä½æ•´ä½“æ¶æ„å¤æ‚æ€§

ğŸ”¸ **æé«˜è¿æ¥æ•ˆç‡**
- å‡å°‘ç½‘ç»œè·³è½¬ï¼Œç›´è¿ç›®æ ‡èŠ‚ç‚¹
- é™ä½å»¶è¿Ÿï¼Œæå‡å“åº”é€Ÿåº¦
- èŠ‚çœç½‘ç»œå¸¦å®½å’Œç¡¬ä»¶æˆæœ¬

ğŸ”¸ **å¢å¼ºå®¹é”™èƒ½åŠ›**
- å®¢æˆ·ç«¯å¯ä»¥æ„ŸçŸ¥èŠ‚ç‚¹çŠ¶æ€
- è‡ªåŠ¨å‰”é™¤ä¸å¯ç”¨èŠ‚ç‚¹
- æ”¯æŒæ•…éšœè‡ªåŠ¨åˆ‡æ¢

### 1.3 å·¥ä½œåŸç†ç®€å›¾


```
å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡æµç¨‹ï¼š

[åº”ç”¨å¯åŠ¨] â†’ [è¯»å–èŠ‚ç‚¹åˆ—è¡¨] â†’ [é€‰æ‹©è¿æ¥ç­–ç•¥]
                                    â†“
[å»ºç«‹è¿æ¥] â† [å¥åº·æ£€æŸ¥] â† [èŠ‚ç‚¹é€‰æ‹©ç®—æ³•]
    â†“              â†“              â†“
[å‘é€æ¶ˆæ¯]     [æ•…éšœæ£€æµ‹]     [è½®è¯¢/éšæœº/æƒé‡]
    â†“              â†“              â†“
[æ¥æ”¶å“åº”]     [èŠ‚ç‚¹å‰”é™¤]     [é‡æ–°é€‰æ‹©èŠ‚ç‚¹]
```

---

## 2. âš–ï¸ å®¢æˆ·ç«¯è¿æ¥ç­–ç•¥è¯¦è§£


### 2.1 è¿æ¥ç­–ç•¥ç±»å‹


**RabbitMQå®¢æˆ·ç«¯æ”¯æŒçš„ä¸»è¦è¿æ¥ç­–ç•¥**ï¼š

| ç­–ç•¥ç±»å‹ | **å·¥ä½œæ–¹å¼** | **é€‚ç”¨åœºæ™¯** | **ä¼˜ç¼ºç‚¹** |
|---------|------------|-------------|-----------|
| ğŸ”„ **è½®è¯¢ç­–ç•¥** | `ä¾æ¬¡è¿æ¥æ¯ä¸ªèŠ‚ç‚¹` | `èŠ‚ç‚¹æ€§èƒ½ç›¸è¿‘` | `ç®€å•å…¬å¹³ï¼Œä½†ä¸è€ƒè™‘è´Ÿè½½` |
| ğŸ² **éšæœºç­–ç•¥** | `éšæœºé€‰æ‹©å¯ç”¨èŠ‚ç‚¹` | `å¤§é‡å®¢æˆ·ç«¯è¿æ¥` | `åˆ†å¸ƒå‡åŒ€ï¼Œé¿å…åŒæ—¶è¿æ¥` |
| âš–ï¸ **æƒé‡ç­–ç•¥** | `æŒ‰èŠ‚ç‚¹æƒé‡åˆ†é…è¿æ¥` | `èŠ‚ç‚¹æ€§èƒ½ä¸åŒ` | `çµæ´»é…ç½®ï¼Œå¤æ‚åº¦é«˜` |
| ğŸ“ **å°±è¿‘ç­–ç•¥** | `ä¼˜å…ˆè¿æ¥æœ¬åœ°èŠ‚ç‚¹` | `è·¨åœ°åŸŸéƒ¨ç½²` | `å»¶è¿Ÿæœ€ä½ï¼Œå¯èƒ½è´Ÿè½½ä¸å‡` |

### 2.2 è½®è¯¢ç­–ç•¥è¯¦è§£


**å·¥ä½œåŸç†**ï¼šæŒ‰ç…§èŠ‚ç‚¹åˆ—è¡¨é¡ºåºï¼Œä¾æ¬¡è¿æ¥ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

```python
# Pythonç¤ºä¾‹ï¼šè½®è¯¢è¿æ¥ç­–ç•¥
class RoundRobinStrategy:
    def __init__(self, nodes):
        self.nodes = nodes  # ['node1:5672', 'node2:5672', 'node3:5672']
        self.current_index = 0
    
    def get_next_node(self):
        """è·å–ä¸‹ä¸€ä¸ªè¦è¿æ¥çš„èŠ‚ç‚¹"""
        if not self.nodes:
            return None
            
        node = self.nodes[self.current_index]
        # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¾ªç¯ä½¿ç”¨
        self.current_index = (self.current_index + 1) % len(self.nodes)
        return node

# ä½¿ç”¨ç¤ºä¾‹
strategy = RoundRobinStrategy(['rabbit1:5672', 'rabbit2:5672', 'rabbit3:5672'])
first_connection = strategy.get_next_node()   # rabbit1:5672
second_connection = strategy.get_next_node()  # rabbit2:5672
third_connection = strategy.get_next_node()   # rabbit3:5672
fourth_connection = strategy.get_next_node()  # rabbit1:5672 (å¾ªç¯)
```

**è½®è¯¢ç­–ç•¥çš„ç‰¹ç‚¹**ï¼š
- âœ… **å…¬å¹³åˆ†é…**ï¼šæ¯ä¸ªèŠ‚ç‚¹è·å¾—ç›¸ç­‰çš„è¿æ¥æœºä¼š
- âœ… **å®ç°ç®€å•**ï¼šé€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤
- âŒ **ä¸è€ƒè™‘è´Ÿè½½**ï¼šä¸ç®¡èŠ‚ç‚¹å½“å‰è´Ÿè½½å¦‚ä½•éƒ½ä¼šåˆ†é…
- âŒ **ä¸è€ƒè™‘æ€§èƒ½**ï¼šé«˜æ€§èƒ½å’Œä½æ€§èƒ½èŠ‚ç‚¹è·å¾—ç›¸åŒè¿æ¥æ•°

### 2.3 éšæœºç­–ç•¥è¯¦è§£


**å·¥ä½œåŸç†**ï¼šä»å¯ç”¨èŠ‚ç‚¹åˆ—è¡¨ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªè¿›è¡Œè¿æ¥ã€‚

```java
// Javaç¤ºä¾‹ï¼šéšæœºè¿æ¥ç­–ç•¥
public class RandomStrategy {
    private List<String> nodes;
    private Random random;
    
    public RandomStrategy(List<String> nodes) {
        this.nodes = new ArrayList<>(nodes);
        this.random = new Random();
    }
    
    public String getNextNode() {
        if (nodes.isEmpty()) {
            return null;
        }
        
        // éšæœºé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹
        int index = random.nextInt(nodes.size());
        return nodes.get(index);
    }
    
    // ç§»é™¤ä¸å¯ç”¨èŠ‚ç‚¹
    public void removeNode(String node) {
        nodes.remove(node);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
List<String> nodeList = Arrays.asList("rabbit1:5672", "rabbit2:5672", "rabbit3:5672");
RandomStrategy strategy = new RandomStrategy(nodeList);

String node1 = strategy.getNextNode(); // å¯èƒ½æ˜¯ rabbit2:5672
String node2 = strategy.getNextNode(); // å¯èƒ½æ˜¯ rabbit1:5672
String node3 = strategy.getNextNode(); // å¯èƒ½æ˜¯ rabbit3:5672
```

**éšæœºç­–ç•¥çš„ç‰¹ç‚¹**ï¼š
- âœ… **é¿å…çƒ­ç‚¹**ï¼šå¤šä¸ªå®¢æˆ·ç«¯ä¸ä¼šåŒæ—¶è¿æ¥åŒä¸€èŠ‚ç‚¹
- âœ… **åˆ†å¸ƒå‡åŒ€**ï¼šé•¿æœŸæ¥çœ‹è¿æ¥åˆ†å¸ƒè¶‹äºå‡åŒ€
- âœ… **å®ç°ç®€å•**ï¼šåªéœ€è¦ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨
- âŒ **çŸ­æœŸä¸å‡**ï¼šçŸ­æ—¶é—´å†…å¯èƒ½å‡ºç°åˆ†å¸ƒä¸å‡

### 2.4 æƒé‡ç­–ç•¥è¯¦è§£


**å·¥ä½œåŸç†**ï¼šæ ¹æ®èŠ‚ç‚¹çš„æƒé‡å€¼åˆ†é…è¿æ¥ï¼Œæƒé‡é«˜çš„èŠ‚ç‚¹è·å¾—æ›´å¤šè¿æ¥ã€‚

```python
# Pythonç¤ºä¾‹ï¼šæƒé‡è¿æ¥ç­–ç•¥
import random

class WeightedStrategy:
    def __init__(self, weighted_nodes):
        """
        weighted_nodes: [('rabbit1:5672', 3), ('rabbit2:5672', 2), ('rabbit3:5672', 1)]
        æƒé‡æ¯”ä¾‹ä¸º 3:2:1
        """
        self.weighted_nodes = weighted_nodes
        self.total_weight = sum(weight for _, weight in weighted_nodes)
    
    def get_next_node(self):
        """æŒ‰æƒé‡éšæœºé€‰æ‹©èŠ‚ç‚¹"""
        if not self.weighted_nodes:
            return None
            
        # ç”Ÿæˆ1åˆ°æ€»æƒé‡ä¹‹é—´çš„éšæœºæ•°
        rand_value = random.randint(1, self.total_weight)
        
        # æ ¹æ®æƒé‡èŒƒå›´é€‰æ‹©èŠ‚ç‚¹
        current_weight = 0
        for node, weight in self.weighted_nodes:
            current_weight += weight
            if rand_value <= current_weight:
                return node
        
        # é»˜è®¤è¿”å›ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
        return self.weighted_nodes[0][0]

# ä½¿ç”¨ç¤ºä¾‹
weighted_nodes = [
    ('rabbit1:5672', 50),  # é«˜æ€§èƒ½èŠ‚ç‚¹ï¼Œæƒé‡50
    ('rabbit2:5672', 30),  # ä¸­ç­‰æ€§èƒ½èŠ‚ç‚¹ï¼Œæƒé‡30  
    ('rabbit3:5672', 20)   # ä½æ€§èƒ½èŠ‚ç‚¹ï¼Œæƒé‡20
]

strategy = WeightedStrategy(weighted_nodes)

# rabbit1è·å¾—50%è¿æ¥æœºä¼šï¼Œrabbit2è·å¾—30%ï¼Œrabbit3è·å¾—20%
for i in range(10):
    selected_node = strategy.get_next_node()
    print(f"è¿æ¥ {i+1}: {selected_node}")
```

**æƒé‡ç­–ç•¥çš„ç‰¹ç‚¹**ï¼š
- âœ… **æ€§èƒ½æ„ŸçŸ¥**ï¼šå¯ä»¥æ ¹æ®èŠ‚ç‚¹æ€§èƒ½åˆ†é…è¿æ¥
- âœ… **çµæ´»é…ç½®**ï¼šå¯ä»¥åŠ¨æ€è°ƒæ•´èŠ‚ç‚¹æƒé‡
- âœ… **èµ„æºä¼˜åŒ–**ï¼šå……åˆ†åˆ©ç”¨é«˜æ€§èƒ½èŠ‚ç‚¹
- âŒ **é…ç½®å¤æ‚**ï¼šéœ€è¦äº†è§£å„èŠ‚ç‚¹æ€§èƒ½ç‰¹å¾

---

## 3. ğŸ“‹ èŠ‚ç‚¹åˆ—è¡¨é…ç½®å®è·µ


### 3.1 é™æ€èŠ‚ç‚¹é…ç½®


**æœ€ç®€å•çš„é…ç½®æ–¹å¼**ï¼šåœ¨åº”ç”¨å¯åŠ¨æ—¶æŒ‡å®šå›ºå®šçš„èŠ‚ç‚¹åˆ—è¡¨ã€‚

```yaml
# application.yml é…ç½®ç¤ºä¾‹
rabbitmq:
  cluster:
    nodes:
      - host: rabbit1.example.com
        port: 5672
      - host: rabbit2.example.com  
        port: 5672
      - host: rabbit3.example.com
        port: 5672
    username: admin
    password: password
    virtual-host: /
    strategy: round_robin  # è¿æ¥ç­–ç•¥
```

```python
# Pythoné…ç½®ä»£ç ç¤ºä¾‹
import pika

class RabbitMQConfig:
    def __init__(self):
        # å®šä¹‰é›†ç¾¤èŠ‚ç‚¹åˆ—è¡¨
        self.cluster_nodes = [
            'rabbit1.example.com:5672',
            'rabbit2.example.com:5672', 
            'rabbit3.example.com:5672'
        ]
        
        # è¿æ¥å‚æ•°
        self.credentials = pika.PlainCredentials('admin', 'password')
        self.virtual_host = '/'
        
    def get_connection_parameters(self):
        """è·å–è¿æ¥å‚æ•°åˆ—è¡¨"""
        params_list = []
        
        for node in self.cluster_nodes:
            host, port = node.split(':')
            params = pika.ConnectionParameters(
                host=host,
                port=int(port),
                virtual_host=self.virtual_host,
                credentials=self.credentials,
                heartbeat=60,  # å¿ƒè·³é—´éš”
                socket_timeout=10  # è¿æ¥è¶…æ—¶
            )
            params_list.append(params)
            
        return params_list

# ä½¿ç”¨ç¤ºä¾‹
config = RabbitMQConfig()
connection_params = config.get_connection_parameters()

# åˆ›å»ºè¿æ¥ï¼Œä¼šè‡ªåŠ¨è¿›è¡Œè´Ÿè½½å‡è¡¡
connection = pika.BlockingConnection(connection_params)
```

### 3.2 åŠ¨æ€èŠ‚ç‚¹å‘ç°


**æ›´é«˜çº§çš„é…ç½®æ–¹å¼**ï¼šé€šè¿‡æœåŠ¡å‘ç°æœºåˆ¶åŠ¨æ€è·å–èŠ‚ç‚¹åˆ—è¡¨ã€‚

```python
# åŸºäºConsulçš„åŠ¨æ€èŠ‚ç‚¹å‘ç°ç¤ºä¾‹
import consul
import pika

class DynamicNodeDiscovery:
    def __init__(self, consul_host='localhost', consul_port=8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)
        self.service_name = 'rabbitmq'
        
    def discover_nodes(self):
        """ä»Consulå‘ç°RabbitMQèŠ‚ç‚¹"""
        try:
            # æŸ¥è¯¢å¥åº·çš„RabbitMQæœåŠ¡å®ä¾‹
            _, services = self.consul.health.service(
                self.service_name, 
                passing=True  # åªè¿”å›å¥åº·æ£€æŸ¥é€šè¿‡çš„å®ä¾‹
            )
            
            nodes = []
            for service in services:
                node_info = service['Service']
                node_address = f"{node_info['Address']}:{node_info['Port']}"
                nodes.append(node_address)
                
            return nodes
            
        except Exception as e:
            print(f"èŠ‚ç‚¹å‘ç°å¤±è´¥: {e}")
            # è¿”å›å¤‡ç”¨çš„é™æ€èŠ‚ç‚¹åˆ—è¡¨
            return ['rabbit1:5672', 'rabbit2:5672', 'rabbit3:5672']
    
    def get_connection_parameters(self):
        """è·å–åŠ¨æ€å‘ç°çš„è¿æ¥å‚æ•°"""
        discovered_nodes = self.discover_nodes()
        params_list = []
        
        for node in discovered_nodes:
            host, port = node.split(':')
            params = pika.ConnectionParameters(
                host=host,
                port=int(port),
                credentials=pika.PlainCredentials('admin', 'password'),
                heartbeat=60
            )
            params_list.append(params)
            
        return params_list

# ä½¿ç”¨åŠ¨æ€å‘ç°
discovery = DynamicNodeDiscovery()
connection_params = discovery.get_connection_parameters()
connection = pika.BlockingConnection(connection_params)
```

### 3.3 é…ç½®çš„æœ€ä½³å®è·µ


**æ¨èçš„é…ç½®åŸåˆ™**ï¼š

ğŸ”¸ **èŠ‚ç‚¹æ•°é‡**
```
å°å‹éƒ¨ç½²ï¼š2-3ä¸ªèŠ‚ç‚¹è¶³å¤Ÿ
ä¸­å‹éƒ¨ç½²ï¼š3-5ä¸ªèŠ‚ç‚¹åˆé€‚  
å¤§å‹éƒ¨ç½²ï¼š5-7ä¸ªèŠ‚ç‚¹ï¼Œè¿‡å¤šä¼šå½±å“é›†ç¾¤æ€§èƒ½
```

ğŸ”¸ **ç½‘ç»œé…ç½®**
```python
# æ¨èçš„è¿æ¥å‚æ•°é…ç½®
connection_params = pika.ConnectionParameters(
    host='rabbit1.example.com',
    port=5672,
    virtual_host='/',
    credentials=pika.PlainCredentials('user', 'pass'),
    
    # é‡è¦çš„ç½‘ç»œå‚æ•°
    heartbeat=60,           # å¿ƒè·³é—´éš”ï¼Œæ£€æµ‹è¿æ¥çŠ¶æ€
    socket_timeout=10,      # Socketè¿æ¥è¶…æ—¶
    connection_attempts=3,  # è¿æ¥é‡è¯•æ¬¡æ•°
    retry_delay=2.0,       # é‡è¯•é—´éš”æ—¶é—´
    
    # TCPå‚æ•°ä¼˜åŒ–
    tcp_options={
        'TCP_KEEPINTVL': 60,   # TCPä¿æ´»é—´éš”
        'TCP_KEEPCNT': 3,      # TCPä¿æ´»é‡è¯•æ¬¡æ•°
        'TCP_USER_TIMEOUT': 18000  # ç”¨æˆ·è¶…æ—¶æ—¶é—´
    }
)
```

---

## 4. ğŸ” æ•…éšœæ£€æµ‹ä¸è‡ªåŠ¨æ¢å¤


### 4.1 æ•…éšœæ£€æµ‹æœºåˆ¶


RabbitMQå®¢æˆ·ç«¯é€šè¿‡å¤šç§æ–¹å¼æ£€æµ‹èŠ‚ç‚¹æ•…éšœï¼š

ğŸ”¸ **å¿ƒè·³æ£€æµ‹**
```
å·¥ä½œåŸç†ï¼š
å®¢æˆ·ç«¯ â†â†’ æœåŠ¡ç«¯ å®šæœŸå‘é€å¿ƒè·³åŒ…
å¦‚æœè¿ç»­å‡ ä¸ªå¿ƒè·³å‘¨æœŸæ²¡æœ‰æ”¶åˆ°å“åº”ï¼Œåˆ¤å®šè¿æ¥æ–­å¼€

é»˜è®¤é…ç½®ï¼š
å¿ƒè·³é—´éš”ï¼š60ç§’
è¶…æ—¶åˆ¤å®šï¼š180ç§’ï¼ˆ3ä¸ªå¿ƒè·³å‘¨æœŸï¼‰
```

ğŸ”¸ **è¿æ¥çŠ¶æ€ç›‘æ§**
```python
# Pythonç¤ºä¾‹ï¼šè¿æ¥çŠ¶æ€ç›‘æ§
import pika
import threading
import time

class ConnectionMonitor:
    def __init__(self, connection):
        self.connection = connection
        self.is_monitoring = True
        
    def start_monitoring(self):
        """å¯åŠ¨è¿æ¥çŠ¶æ€ç›‘æ§"""
        monitor_thread = threading.Thread(target=self._monitor_loop)
        monitor_thread.daemon = True
        monitor_thread.start()
        
    def _monitor_loop(self):
        """ç›‘æ§å¾ªç¯"""
        while self.is_monitoring:
            try:
                if self.connection.is_closed:
                    print("âš ï¸ æ£€æµ‹åˆ°è¿æ¥æ–­å¼€ï¼Œå¼€å§‹é‡è¿...")
                    self._handle_disconnect()
                    
                time.sleep(5)  # æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
                
            except Exception as e:
                print(f"ç›‘æ§å¼‚å¸¸: {e}")
                
    def _handle_disconnect(self):
        """å¤„ç†è¿æ¥æ–­å¼€"""
        # è¿™é‡Œå®ç°é‡è¿é€»è¾‘
        self._reconnect()
        
    def _reconnect(self):
        """é‡æ–°è¿æ¥"""
        try:
            # é‡æ–°å»ºç«‹è¿æ¥çš„ä»£ç 
            print("âœ… é‡è¿æˆåŠŸ")
        except Exception as e:
            print(f"âŒ é‡è¿å¤±è´¥: {e}")
```

### 4.2 è‡ªåŠ¨é‡è¿é€»è¾‘


**é‡è¿ç­–ç•¥è®¾è®¡**ï¼š

```python
import time
import random

class AutoReconnectHandler:
    def __init__(self, node_list):
        self.node_list = node_list.copy()
        self.failed_nodes = set()
        self.max_retry_attempts = 3
        self.base_retry_delay = 1.0
        
    def connect_with_retry(self):
        """å¸¦é‡è¯•çš„è¿æ¥é€»è¾‘"""
        available_nodes = [node for node in self.node_list 
                          if node not in self.failed_nodes]
        
        if not available_nodes:
            # æ‰€æœ‰èŠ‚ç‚¹éƒ½å¤±è´¥äº†ï¼Œé‡ç½®å¤±è´¥åˆ—è¡¨å¹¶ç­‰å¾…
            print("ğŸ”„ æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¸å¯ç”¨ï¼Œé‡ç½®çŠ¶æ€å¹¶ç­‰å¾…...")
            self.failed_nodes.clear()
            time.sleep(30)  # ç­‰å¾…30ç§’åé‡è¯•
            available_nodes = self.node_list.copy()
        
        for node in available_nodes:
            if self._try_connect_node(node):
                return True
                
        return False
    
    def _try_connect_node(self, node):
        """å°è¯•è¿æ¥å•ä¸ªèŠ‚ç‚¹"""
        for attempt in range(self.max_retry_attempts):
            try:
                print(f"ğŸ”— å°è¯•è¿æ¥èŠ‚ç‚¹ {node} (ç¬¬{attempt+1}æ¬¡)")
                
                # è¿™é‡Œæ˜¯å®é™…çš„è¿æ¥ä»£ç 
                success = self._do_connect(node)
                
                if success:
                    # è¿æ¥æˆåŠŸï¼Œä»å¤±è´¥åˆ—è¡¨ä¸­ç§»é™¤
                    self.failed_nodes.discard(node)
                    print(f"âœ… æˆåŠŸè¿æ¥åˆ° {node}")
                    return True
                    
            except Exception as e:
                print(f"âŒ è¿æ¥ {node} å¤±è´¥: {e}")
                
                # è®¡ç®—é€€é¿å»¶è¿Ÿæ—¶é—´
                delay = self.base_retry_delay * (2 ** attempt) + random.uniform(0, 1)
                print(f"â±ï¸ {delay:.2f}ç§’åé‡è¯•...")
                time.sleep(delay)
        
        # å¤šæ¬¡é‡è¯•éƒ½å¤±è´¥ï¼Œæ ‡è®°èŠ‚ç‚¹ä¸ºä¸å¯ç”¨
        self.failed_nodes.add(node)
        print(f"ğŸš« èŠ‚ç‚¹ {node} æ ‡è®°ä¸ºä¸å¯ç”¨")
        return False
    
    def _do_connect(self, node):
        """å®é™…çš„è¿æ¥å®ç°"""
        # è¿™é‡Œå®ç°çœŸæ­£çš„RabbitMQè¿æ¥é€»è¾‘
        host, port = node.split(':')
        
        try:
            connection = pika.BlockingConnection(
                pika.ConnectionParameters(
                    host=host,
                    port=int(port),
                    connection_attempts=1,
                    socket_timeout=5
                )
            )
            return True
        except:
            return False
```

### 4.3 æ•…éšœæ¢å¤ç­–ç•¥


**åˆ†çº§æ¢å¤æœºåˆ¶**ï¼š

```
Level 1: è¿æ¥çº§æ¢å¤
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ£€æµ‹åˆ°è¿æ¥æ–­å¼€       â”‚
â”‚ â†“                   â”‚
â”‚ å°è¯•é‡è¿å½“å‰èŠ‚ç‚¹     â”‚
â”‚ â†“                   â”‚
â”‚ æˆåŠŸï¼Ÿâ†’ ç»§ç»­ä½¿ç”¨     â”‚
â”‚ å¤±è´¥ï¼Ÿâ†’ Level 2      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Level 2: èŠ‚ç‚¹çº§æ¢å¤  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å½“å‰èŠ‚ç‚¹ä¸å¯ç”¨       â”‚
â”‚ â†“                   â”‚
â”‚ ä»èŠ‚ç‚¹åˆ—è¡¨é€‰æ‹©æ–°èŠ‚ç‚¹ â”‚
â”‚ â†“                   â”‚
â”‚ æˆåŠŸï¼Ÿâ†’ åˆ‡æ¢èŠ‚ç‚¹     â”‚
â”‚ å¤±è´¥ï¼Ÿâ†’ Level 3      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Level 3: é›†ç¾¤çº§æ¢å¤
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¸å¯ç”¨     â”‚
â”‚ â†“                   â”‚
â”‚ ç­‰å¾…å¹¶é‡æ–°å‘ç°èŠ‚ç‚¹   â”‚
â”‚ â†“                   â”‚
â”‚ ä»Level 1é‡æ–°å¼€å§‹   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. ğŸ› ï¸ ä¸åŒSDKçš„è´Ÿè½½å‡è¡¡å®ç°


### 5.1 Java Spring AMQP


**Spring Bootä¸­çš„é…ç½®**ï¼š

```yaml
# application.yml
spring:
  rabbitmq:
    addresses: rabbit1:5672,rabbit2:5672,rabbit3:5672
    username: admin
    password: password
    virtual-host: /
    connection-timeout: 10s
    
    # è¿æ¥æ± é…ç½®
    listener:
      simple:
        retry:
          enabled: true
          max-attempts: 3
          initial-interval: 1s
```

```java
// Javaä»£ç é…ç½®ç¤ºä¾‹
@Configuration
public class RabbitMQConfig {
    
    @Bean
    public CachingConnectionFactory connectionFactory() {
        CachingConnectionFactory factory = new CachingConnectionFactory();
        
        // è®¾ç½®é›†ç¾¤åœ°å€
        factory.setAddresses("rabbit1:5672,rabbit2:5672,rabbit3:5672");
        factory.setUsername("admin");
        factory.setPassword("password");
        factory.setVirtualHost("/");
        
        // è¿æ¥æ± é…ç½®
        factory.setChannelCacheSize(50);
        factory.setConnectionCacheSize(10);
        
        // æ•…éšœæ¢å¤é…ç½®
        factory.getRabbitConnectionFactory().setAutomaticRecoveryEnabled(true);
        factory.getRabbitConnectionFactory().setNetworkRecoveryInterval(5000);
        
        return factory;
    }
    
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        
        // è®¾ç½®é‡è¯•æœºåˆ¶
        template.setRetryTemplate(retryTemplate());
        
        return template;
    }
    
    @Bean
    public RetryTemplate retryTemplate() {
        RetryTemplate retryTemplate = new RetryTemplate();
        
        // é‡è¯•ç­–ç•¥ï¼šæœ€å¤šé‡è¯•3æ¬¡ï¼Œæ¯æ¬¡é—´éš”1ç§’
        FixedBackOffPolicy backOffPolicy = new FixedBackOffPolicy();
        backOffPolicy.setBackOffPeriod(1000);
        retryTemplate.setBackOffPolicy(backOffPolicy);
        
        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
        retryPolicy.setMaxAttempts(3);
        retryTemplate.setRetryPolicy(retryPolicy);
        
        return retryTemplate;
    }
}
```

### 5.2 Python Pika


**Pikaçš„è´Ÿè½½å‡è¡¡å®ç°**ï¼š

```python
import pika
import random
import time

class PikaLoadBalancer:
    def __init__(self, nodes, credentials=None):
        self.nodes = nodes
        self.credentials = credentials or pika.PlainCredentials('guest', 'guest')
        self.connection = None
        self.current_node_index = 0
        
    def connect(self):
        """è¿æ¥åˆ°é›†ç¾¤"""
        # åˆ›å»ºæ‰€æœ‰èŠ‚ç‚¹çš„è¿æ¥å‚æ•°
        connection_params = []
        
        for node in self.nodes:
            host, port = node.split(':')
            params = pika.ConnectionParameters(
                host=host,
                port=int(port),
                credentials=self.credentials,
                heartbeat=60,
                connection_attempts=1,
                socket_timeout=5
            )
            connection_params.append(params)
        
        try:
            # Pikaä¼šè‡ªåŠ¨è¿›è¡Œè´Ÿè½½å‡è¡¡
            self.connection = pika.BlockingConnection(connection_params)
            print(f"âœ… æˆåŠŸè¿æ¥åˆ°RabbitMQé›†ç¾¤")
            return True
            
        except Exception as e:
            print(f"âŒ è¿æ¥é›†ç¾¤å¤±è´¥: {e}")
            return False
    
    def get_channel(self):
        """è·å–é€šé“"""
        if not self.connection or self.connection.is_closed:
            if not self.connect():
                raise Exception("æ— æ³•è¿æ¥åˆ°RabbitMQé›†ç¾¤")
        
        return self.connection.channel()
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.connection and not self.connection.is_closed:
            self.connection.close()

# ä½¿ç”¨ç¤ºä¾‹
nodes = ['rabbit1:5672', 'rabbit2:5672', 'rabbit3:5672']
credentials = pika.PlainCredentials('admin', 'password')

lb = PikaLoadBalancer(nodes, credentials)

if lb.connect():
    channel = lb.get_channel()
    
    # å‘é€æ¶ˆæ¯
    channel.queue_declare(queue='test_queue', durable=True)
    channel.basic_publish(
        exchange='',
        routing_key='test_queue',
        body='Hello from load balanced connection!'
    )
    
    print("âœ… æ¶ˆæ¯å‘é€æˆåŠŸ")
    lb.close()
```

### 5.3 Node.js amqplib


**Node.jsä¸­çš„è´Ÿè½½å‡è¡¡é…ç½®**ï¼š

```javascript
// Node.js amqplib è´Ÿè½½å‡è¡¡ç¤ºä¾‹
const amqp = require('amqplib');

class NodeRabbitMQLoadBalancer {
    constructor(nodes, options = {}) {
        this.nodes = nodes;
        this.options = {
            username: 'admin',
            password: 'password',
            vhost: '/',
            heartbeat: 60,
            ...options
        };
        this.connection = null;
        this.currentNodeIndex = 0;
    }
    
    async connect() {
        // æ„å»ºè¿æ¥URLåˆ—è¡¨
        const connectionUrls = this.nodes.map(node => {
            const [host, port] = node.split(':');
            return `amqp://${this.options.username}:${this.options.password}@${host}:${port}${this.options.vhost}`;
        });
        
        // å°è¯•è¿æ¥æ¯ä¸ªèŠ‚ç‚¹
        for (let i = 0; i < connectionUrls.length; i++) {
            try {
                console.log(`ğŸ”— å°è¯•è¿æ¥èŠ‚ç‚¹ ${this.nodes[i]}`);
                
                this.connection = await amqp.connect(connectionUrls[i], {
                    heartbeat: this.options.heartbeat
                });
                
                // ç›‘å¬è¿æ¥äº‹ä»¶
                this.connection.on('error', (err) => {
                    console.log(`âŒ è¿æ¥é”™è¯¯: ${err.message}`);
                    this.handleConnectionError();
                });
                
                this.connection.on('close', () => {
                    console.log('ğŸ”Œ è¿æ¥å·²å…³é—­');
                    this.handleConnectionClose();
                });
                
                console.log(`âœ… æˆåŠŸè¿æ¥åˆ° ${this.nodes[i]}`);
                return true;
                
            } catch (error) {
                console.log(`âŒ è¿æ¥ ${this.nodes[i]} å¤±è´¥: ${error.message}`);
                continue;
            }
        }
        
        throw new Error('æ— æ³•è¿æ¥åˆ°ä»»ä½•RabbitMQèŠ‚ç‚¹');
    }
    
    async getChannel() {
        if (!this.connection) {
            await this.connect();
        }
        
        return await this.connection.createChannel();
    }
    
    handleConnectionError() {
        // è¿æ¥é”™è¯¯å¤„ç†é€»è¾‘
        console.log('ğŸ”„ å¼€å§‹é‡è¿...');
        setTimeout(() => {
            this.connect().catch(err => {
                console.log(`é‡è¿å¤±è´¥: ${err.message}`);
            });
        }, 5000);
    }
    
    handleConnectionClose() {
        // è¿æ¥å…³é—­å¤„ç†é€»è¾‘
        this.connection = null;
    }
    
    async close() {
        if (this.connection) {
            await this.connection.close();
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const nodes = ['rabbit1:5672', 'rabbit2:5672', 'rabbit3:5672'];
const lb = new NodeRabbitMQLoadBalancer(nodes);

async function sendMessage() {
    try {
        const channel = await lb.getChannel();
        
        await channel.assertQueue('test_queue', { durable: true });
        
        await channel.sendToQueue('test_queue', 
            Buffer.from('Hello from Node.js load balancer!'),
            { persistent: true }
        );
        
        console.log('âœ… æ¶ˆæ¯å‘é€æˆåŠŸ');
        
        await channel.close();
        await lb.close();
        
    } catch (error) {
        console.log(`âŒ å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`);
    }
}

sendMessage();
```

---

## 6. âš¡ æœ€ä½³å®è·µä¸æ€§èƒ½ä¼˜åŒ–


### 6.1 è¿æ¥æ± ç®¡ç†


**ä¸ºä»€ä¹ˆéœ€è¦è¿æ¥æ± **ï¼š
- RabbitMQè¿æ¥å»ºç«‹æˆæœ¬è¾ƒé«˜
- é¢‘ç¹åˆ›å»º/å…³é—­è¿æ¥å½±å“æ€§èƒ½
- è¿æ¥æ•°è¿‡å¤šä¼šæ¶ˆè€—æœåŠ¡å™¨èµ„æº

```python
# Pythonè¿æ¥æ± å®ç°ç¤ºä¾‹
import pika
import threading
import queue
from contextlib import contextmanager

class RabbitMQConnectionPool:
    def __init__(self, nodes, pool_size=10, max_overflow=5):
        self.nodes = nodes
        self.pool_size = pool_size
        self.max_overflow = max_overflow
        
        # è¿æ¥æ± é˜Ÿåˆ—
        self.pool = queue.Queue(maxsize=pool_size)
        self.overflow_connections = set()
        self.lock = threading.Lock()
        
        # åˆå§‹åŒ–è¿æ¥æ± 
        self._initialize_pool()
    
    def _initialize_pool(self):
        """åˆå§‹åŒ–è¿æ¥æ± """
        connection_params = self._get_connection_params()
        
        for _ in range(self.pool_size):
            try:
                conn = pika.BlockingConnection(connection_params)
                self.pool.put(conn, block=False)
            except:
                # å¦‚æœåˆå§‹åŒ–å¤±è´¥ï¼Œç»§ç»­å°è¯•
                continue
    
    def _get_connection_params(self):
        """è·å–è¿æ¥å‚æ•°"""
        params_list = []
        for node in self.nodes:
            host, port = node.split(':')
            params = pika.ConnectionParameters(
                host=host,
                port=int(port),
                credentials=pika.PlainCredentials('admin', 'password'),
                heartbeat=60
            )
            params_list.append(params)
        return params_list
    
    @contextmanager
    def get_connection(self):
        """è·å–è¿æ¥ï¼ˆä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼‰"""
        connection = None
        is_overflow = False
        
        try:
            # å°è¯•ä»æ± ä¸­è·å–è¿æ¥
            connection = self.pool.get(block=False)
        except queue.Empty:
            # æ± ä¸­æ— å¯ç”¨è¿æ¥ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºæº¢å‡ºè¿æ¥
            with self.lock:
                if len(self.overflow_connections) < self.max_overflow:
                    try:
                        connection = pika.BlockingConnection(self._get_connection_params())
                        self.overflow_connections.add(connection)
                        is_overflow = True
                    except:
                        raise Exception("æ— æ³•åˆ›å»ºæ–°çš„è¿æ¥")
                else:
                    # ç­‰å¾…æ± ä¸­çš„è¿æ¥
                    connection = self.pool.get(block=True, timeout=30)
        
        try:
            # æ£€æŸ¥è¿æ¥æ˜¯å¦å¥åº·
            if connection.is_closed:
                connection = pika.BlockingConnection(self._get_connection_params())
            
            yield connection
            
        finally:
            # å½’è¿˜è¿æ¥
            if connection and not connection.is_closed:
                if is_overflow:
                    with self.lock:
                        self.overflow_connections.discard(connection)
                    connection.close()
                else:
                    try:
                        self.pool.put(connection, block=False)
                    except queue.Full:
                        connection.close()

# ä½¿ç”¨è¿æ¥æ± 
nodes = ['rabbit1:5672', 'rabbit2:5672', 'rabbit3:5672']
pool = RabbitMQConnectionPool(nodes, pool_size=5)

# å‘é€æ¶ˆæ¯ç¤ºä¾‹
def send_message(message):
    with pool.get_connection() as connection:
        channel = connection.channel()
        channel.queue_declare(queue='test_queue', durable=True)
        channel.basic_publish(
            exchange='',
            routing_key='test_queue',
            body=message,
            properties=pika.BasicProperties(delivery_mode=2)  # æŒä¹…åŒ–
        )
        channel.close()

# å¹¶å‘å‘é€æ¶ˆæ¯
import concurrent.futures
import threading

def batch_send_messages():
    messages = [f"æ¶ˆæ¯ {i}" for i in range(100)]
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(send_message, msg) for msg in messages]
        
        for future in concurrent.futures.as_completed(futures):
            try:
                future.result()
            except Exception as e:
                print(f"å‘é€å¤±è´¥: {e}")

batch_send_messages()
```

### 6.2 å¥åº·æ£€æŸ¥æœºåˆ¶


```python
# èŠ‚ç‚¹å¥åº·æ£€æŸ¥å®ç°
import time
import threading
import requests

class NodeHealthChecker:
    def __init__(self, nodes, check_interval=30):
        self.nodes = nodes
        self.check_interval = check_interval
        self.healthy_nodes = set(nodes)
        self.unhealthy_nodes = set()
        self.lock = threading.Lock()
        self.running = True
        
        # å¯åŠ¨å¥åº·æ£€æŸ¥çº¿ç¨‹
        self.health_thread = threading.Thread(target=self._health_check_loop)
        self.health_thread.daemon = True
        self.health_thread.start()
    
    def _health_check_loop(self):
        """å¥åº·æ£€æŸ¥å¾ªç¯"""
        while self.running:
            try:
                self._check_all_nodes()
                time.sleep(self.check_interval)
            except Exception as e:
                print(f"å¥åº·æ£€æŸ¥å¼‚å¸¸: {e}")
                time.sleep(5)
    
    def _check_all_nodes(self):
        """æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹å¥åº·çŠ¶æ€"""
        for node in self.nodes:
            self._check_single_node(node)
    
    def _check_single_node(self, node):
        """æ£€æŸ¥å•ä¸ªèŠ‚ç‚¹"""
        try:
            host, port = node.split(':')
            
            # æ–¹æ³•1ï¼šå°è¯•å»ºç«‹TCPè¿æ¥
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((host, int(port)))
            sock.close()
            
            if result == 0:
                self._mark_node_healthy(node)
            else:
                self._mark_node_unhealthy(node)
                
        except Exception as e:
            print(f"æ£€æŸ¥èŠ‚ç‚¹ {node} å¤±è´¥: {e}")
            self._mark_node_unhealthy(node)
    
    def _mark_node_healthy(self, node):
        """æ ‡è®°èŠ‚ç‚¹ä¸ºå¥åº·"""
        with self.lock:
            if node in self.unhealthy_nodes:
                self.unhealthy_nodes.remove(node)
                self.healthy_nodes.add(node)
                print(f"âœ… èŠ‚ç‚¹ {node} æ¢å¤å¥åº·")
    
    def _mark_node_unhealthy(self, node):
        """æ ‡è®°èŠ‚ç‚¹ä¸ºä¸å¥åº·"""
        with self.lock:
            if node in self.healthy_nodes:
                self.healthy_nodes.remove(node)
                self.unhealthy_nodes.add(node)
                print(f"âŒ èŠ‚ç‚¹ {node} ä¸å¥åº·")
    
    def get_healthy_nodes(self):
        """è·å–å¥åº·èŠ‚ç‚¹åˆ—è¡¨"""
        with self.lock:
            return list(self.healthy_nodes)
    
    def stop(self):
        """åœæ­¢å¥åº·æ£€æŸ¥"""
        self.running = False

# ä½¿ç”¨å¥åº·æ£€æŸ¥å™¨
nodes = ['rabbit1:5672', 'rabbit2:5672', 'rabbit3:5672']
health_checker = NodeHealthChecker(nodes)

# è·å–å¥åº·èŠ‚ç‚¹è¿›è¡Œè¿æ¥
healthy_nodes = health_checker.get_healthy_nodes()
if healthy_nodes:
    print(f"å¯ç”¨èŠ‚ç‚¹: {healthy_nodes}")
else:
    print("âš ï¸ æ²¡æœ‰å¥åº·çš„èŠ‚ç‚¹å¯ç”¨")
```

### 6.3 æ€§èƒ½ç›‘æ§æŒ‡æ ‡


**å…³é”®ç›‘æ§æŒ‡æ ‡**ï¼š

```python
# æ€§èƒ½ç›‘æ§å®ç°
import time
import threading
from collections import defaultdict, deque

class ConnectionMetrics:
    def __init__(self):
        self.metrics = defaultdict(lambda: {
            'connection_count': 0,
            'success_count': 0,
            'failure_count': 0,
            'avg_response_time': 0,
            'response_times': deque(maxlen=100)  # ä¿ç•™æœ€è¿‘100æ¬¡å“åº”æ—¶é—´
        })
        self.lock = threading.Lock()
    
    def record_connection_attempt(self, node):
        """è®°å½•è¿æ¥å°è¯•"""
        with self.lock:
            self.metrics[node]['connection_count'] += 1
    
    def record_success(self, node, response_time):
        """è®°å½•æˆåŠŸè¿æ¥"""
        with self.lock:
            self.metrics[node]['success_count'] += 1
            self.metrics[node]['response_times'].append(response_time)
            self._update_avg_response_time(node)
    
    def record_failure(self, node):
        """è®°å½•è¿æ¥å¤±è´¥"""
        with self.lock:
            self.metrics[node]['failure_count'] += 1
    
    def _update_avg_response_time(self, node):
        """æ›´æ–°å¹³å‡å“åº”æ—¶é—´"""
        response_times = self.metrics[node]['response_times']
        if response_times:
            self.metrics[node]['avg_response_time'] = sum(response_times) / len(response_times)
    
    def get_node_metrics(self, node):
        """è·å–èŠ‚ç‚¹æŒ‡æ ‡"""
        with self.lock:
            return dict(self.metrics[node])
    
    def get_all_metrics(self):
        """è·å–æ‰€æœ‰èŠ‚ç‚¹æŒ‡æ ‡"""
        with self.lock:
            return {node: dict(metrics) for node, metrics in self.metrics.items()}
    
    def calculate_success_rate(self, node):
        """è®¡ç®—æˆåŠŸç‡"""
        metrics = self.get_node_metrics(node)
        total = metrics['success_count'] + metrics['failure_count']
        if total == 0:
            return 0
        return (metrics['success_count'] / total) * 100

# ä½¿ç”¨ç¤ºä¾‹
metrics = ConnectionMetrics()

def connect_with_metrics(node):
    """å¸¦æŒ‡æ ‡è®°å½•çš„è¿æ¥"""
    metrics.record_connection_attempt(node)
    
    start_time = time.time()
    try:
        # è¿™é‡Œæ˜¯å®é™…çš„è¿æ¥ä»£ç 
        # connection = create_connection(node)
        
        # æ¨¡æ‹Ÿè¿æ¥æ—¶é—´
        time.sleep(0.1)
        
        response_time = time.time() - start_time
        metrics.record_success(node, response_time)
        return True
        
    except Exception as e:
        metrics.record_failure(node)
        return False

# æµ‹è¯•å¹¶æŸ¥çœ‹æŒ‡æ ‡
for i in range(10):
    connect_with_metrics('rabbit1:5672')

# æ‰“å°æŒ‡æ ‡
for node in ['rabbit1:5672', 'rabbit2:5672', 'rabbit3:5672']:
    success_rate = metrics.calculate_success_rate(node)
    node_metrics = metrics.get_node_metrics(node)
    
    print(f"èŠ‚ç‚¹ {node}:")
    print(f"  è¿æ¥æ¬¡æ•°: {node_metrics['connection_count']}")
    print(f"  æˆåŠŸç‡: {success_rate:.2f}%")
    print(f"  å¹³å‡å“åº”æ—¶é—´: {node_metrics['avg_response_time']:.3f}ç§’")
    print()
```

---

## 7. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 7.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡ï¼šåº”ç”¨è‡ªå·±é€‰æ‹©è¿æ¥å“ªä¸ªRabbitMQèŠ‚ç‚¹
ğŸ”¸ è¿æ¥ç­–ç•¥ï¼šè½®è¯¢ã€éšæœºã€æƒé‡ã€å°±è¿‘ç­‰ä¸åŒçš„èŠ‚ç‚¹é€‰æ‹©æ–¹å¼  
ğŸ”¸ æ•…éšœæ£€æµ‹ï¼šé€šè¿‡å¿ƒè·³ã€è¿æ¥çŠ¶æ€ç›‘æ§ç­‰æ–¹å¼æ£€æµ‹èŠ‚ç‚¹å¥åº·
ğŸ”¸ è‡ªåŠ¨é‡è¿ï¼šè¿æ¥æ–­å¼€åè‡ªåŠ¨åˆ‡æ¢åˆ°å…¶ä»–å¯ç”¨èŠ‚ç‚¹
ğŸ”¸ è¿æ¥æ± ï¼šå¤ç”¨è¿æ¥å‡å°‘å»ºè¿å¼€é”€ï¼Œæå‡æ€§èƒ½
```

### 7.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä¸ºä»€ä¹ˆé€‰æ‹©å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡**
```
ä¼˜åŠ¿ï¼š
- å‡å°‘æ¶æ„å¤æ‚æ€§ï¼Œä¸éœ€è¦é¢å¤–çš„è´Ÿè½½å‡è¡¡å™¨
- æé«˜æ€§èƒ½ï¼Œå‡å°‘ç½‘ç»œè·³è½¬
- å¢å¼ºå®¹é”™èƒ½åŠ›ï¼Œå®¢æˆ·ç«¯å¯æ„ŸçŸ¥èŠ‚ç‚¹çŠ¶æ€

æƒè¡¡ï¼š
- å¢åŠ å®¢æˆ·ç«¯å¤æ‚æ€§
- éœ€è¦åœ¨æ¯ä¸ªåº”ç”¨ä¸­é…ç½®èŠ‚ç‚¹åˆ—è¡¨
- æ•…éšœåˆ‡æ¢å¯èƒ½ä¸å¦‚ä¸“ä¸šè´Ÿè½½å‡è¡¡å™¨è¿…é€Ÿ
```

**ğŸ”¹ è¿æ¥ç­–ç•¥çš„é€‰æ‹©åŸåˆ™**
```
è½®è¯¢ç­–ç•¥ï¼š
âœ… é€‚ç”¨äºèŠ‚ç‚¹æ€§èƒ½ç›¸è¿‘çš„åœºæ™¯
âœ… å®ç°ç®€å•ï¼Œåˆ†é…å…¬å¹³
âŒ ä¸è€ƒè™‘å®é™…è´Ÿè½½æƒ…å†µ

éšæœºç­–ç•¥ï¼š  
âœ… é€‚ç”¨äºå¤§é‡å®¢æˆ·ç«¯è¿æ¥çš„åœºæ™¯
âœ… é¿å…åŒæ—¶è¿æ¥çƒ­ç‚¹
âŒ çŸ­æœŸå¯èƒ½åˆ†å¸ƒä¸å‡

æƒé‡ç­–ç•¥ï¼š
âœ… é€‚ç”¨äºèŠ‚ç‚¹æ€§èƒ½å·®å¼‚è¾ƒå¤§çš„åœºæ™¯  
âœ… å¯ä»¥å……åˆ†åˆ©ç”¨é«˜æ€§èƒ½èŠ‚ç‚¹
âŒ é…ç½®å¤æ‚ï¼Œéœ€è¦äº†è§£èŠ‚ç‚¹æ€§èƒ½
```

**ğŸ”¹ æ•…éšœæ¢å¤çš„å±‚æ¬¡è®¾è®¡**
```
è¿æ¥çº§ â†’ èŠ‚ç‚¹çº§ â†’ é›†ç¾¤çº§
ä¼˜å…ˆå°è¯•æ¢å¤å½“å‰è¿æ¥
å¤±è´¥ååˆ‡æ¢åˆ°å…¶ä»–èŠ‚ç‚¹
æ‰€æœ‰èŠ‚ç‚¹ä¸å¯ç”¨æ—¶ç­‰å¾…æ¢å¤
```

### 7.3 å®é™…åº”ç”¨ä»·å€¼


- **é«˜å¯ç”¨æ€§**ï¼šé¿å…å•ç‚¹æ•…éšœï¼Œæå‡ç³»ç»Ÿå¯ç”¨æ€§
- **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡è¿æ¥æ± å’Œè´Ÿè½½åˆ†æ•£æå‡æ€§èƒ½  
- **è¿ç»´ç®€åŒ–**ï¼šå‡å°‘å¯¹å¤–éƒ¨è´Ÿè½½å‡è¡¡å™¨çš„ä¾èµ–
- **æˆæœ¬é™ä½**ï¼šä¸éœ€è¦è´­ä¹°ä¸“ä¸šçš„è´Ÿè½½å‡è¡¡è®¾å¤‡
- **æ‰©å±•æ€§**ï¼šå¯ä»¥çµæ´»è°ƒæ•´èŠ‚ç‚¹å’Œç­–ç•¥

### 7.4 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ


**é—®é¢˜1**ï¼šå®¢æˆ·ç«¯å¦‚ä½•çŸ¥é“å“ªäº›èŠ‚ç‚¹å¯ç”¨ï¼Ÿ
```
è§£å†³æ–¹æ¡ˆï¼š
âœ… å¥åº·æ£€æŸ¥æœºåˆ¶å®šæœŸæ£€æµ‹èŠ‚ç‚¹çŠ¶æ€
âœ… è¿æ¥å¤±è´¥æ—¶è‡ªåŠ¨æ ‡è®°èŠ‚ç‚¹ä¸å¯ç”¨
âœ… ç»“åˆæœåŠ¡å‘ç°ï¼ˆå¦‚Consulï¼‰åŠ¨æ€è·å–èŠ‚ç‚¹åˆ—è¡¨
```

**é—®é¢˜2**ï¼šè¿æ¥æ± ä¸­çš„è¿æ¥æ–­å¼€æ€ä¹ˆåŠï¼Ÿ
```
è§£å†³æ–¹æ¡ˆï¼š
âœ… ä»æ± ä¸­è·å–è¿æ¥æ—¶æ£€æŸ¥è¿æ¥çŠ¶æ€
âœ… æ–­å¼€çš„è¿æ¥è‡ªåŠ¨é‡æ–°åˆ›å»º
âœ… è®¾ç½®åˆé€‚çš„å¿ƒè·³é—´éš”æ£€æµ‹è¿æ¥å¥åº·
```

**é—®é¢˜3**ï¼šå¦‚ä½•å¹³è¡¡è´Ÿè½½å‡è¡¡æ•ˆæœå’Œå¤æ‚æ€§ï¼Ÿ
```
å»ºè®®ï¼š
ğŸ“ å°å‹é¡¹ç›®ï¼šä½¿ç”¨ç®€å•çš„è½®è¯¢ç­–ç•¥
ğŸ“ ä¸­å‹é¡¹ç›®ï¼šç»“åˆéšæœºç­–ç•¥å’Œå¥åº·æ£€æŸ¥
ğŸ“ å¤§å‹é¡¹ç›®ï¼šå®ç°æƒé‡ç­–ç•¥å’Œå®Œæ•´çš„ç›‘æ§ä½“ç³»
```

**æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
- å®¢æˆ·ç«¯è´Ÿè½½é€‰èŠ‚ç‚¹ï¼Œç­–ç•¥å¤šæ ·è¦é€‰å¥½
- æ•…éšœæ£€æµ‹å¿ƒè·³ç®¡ï¼Œè‡ªåŠ¨é‡è¿ä¿å¯ç”¨  
- è¿æ¥å¤ç”¨æ€§èƒ½é«˜ï¼Œç›‘æ§æŒ‡æ ‡ä¸èƒ½å°‘
- ç®€å•å¤Ÿç”¨æ˜¯ç‹é“ï¼Œè¿‡åº¦è®¾è®¡è¦é¿å…