---
title: 33、性能监控指标问题
---
## 📚 目录

1. [RabbitMQ基础故障诊断思路](#1-RabbitMQ基础故障诊断思路)
2. [连接与权限问题排查](#2-连接与权限问题排查)
3. [队列阻塞与积压问题](#3-队列阻塞与积压问题)
4. [消息丢失问题诊断](#4-消息丢失问题诊断)
5. [内存与磁盘空间问题](#5-内存与磁盘空间问题)
6. [集群节点故障处理](#6-集群节点故障处理)
7. [性能监控指标解读](#7-性能监控指标解读)
8. [常用排查工具与命令](#8-常用排查工具与命令)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 RabbitMQ基础故障诊断思路


### 1.1 什么是故障诊断思维

🎯 **简单理解**：就像医生看病，先问症状，再找病因，最后开药治疗

```
故障诊断三步法：
第一步：发现问题 - 系统出现什么异常现象？
第二步：定位原因 - 为什么会出现这个问题？
第三步：解决问题 - 如何修复并防止再次发生？

就像修车一样：
发现：车开不动了
定位：是没油了还是引擎坏了？
解决：加油或修引擎
```

**🔸 RabbitMQ常见故障类型**
```
🟢 基础问题：连接不上、权限不够、配置错误
🟡 性能问题：消息堆积、处理缓慢、内存不足
🔴 严重故障：服务宕机、数据丢失、集群分裂
⚫ 网络问题：连接断开、延迟过高、分区故障
```

### 1.2 故障现象的分类识别

**📊 按影响范围分类**

| 故障级别 | **影响范围** | **典型现象** | **紧急程度** | **处理时效** |
|---------|-------------|-------------|-------------|-------------|
| 🔸 **轻微故障** | `单个队列或应用` | `消息延迟、偶发错误` | `一般` | `1-2小时` |
| 🔸 **中等故障** | `多个应用或服务` | `消息积压、连接异常` | `较高` | `30分钟内` |
| 🔸 **严重故障** | `整个系统不可用` | `服务宕机、无法连接` | `紧急` | `10分钟内` |
| 🔸 **灾难故障** | `数据丢失或损坏` | `集群崩溃、数据错乱` | `最高` | `立即处理` |

### 1.3 诊断信息收集清单

**📋 故障发生时需要收集的信息**

```
🎯 基本信息收集：
□ 故障发生时间：具体到分钟
□ 影响的应用：哪些服务受影响
□ 错误现象：用户看到什么异常
□ 最近变更：有没有发布新版本或修改配置

🔧 技术信息收集：
□ RabbitMQ日志：/var/log/rabbitmq/rabbit@hostname.log
□ 系统资源：CPU、内存、磁盘使用率
□ 网络状态：连接数、网络延迟
□ 队列状态：消息数量、消费者数量

💡 快速收集脚本：
# 一键收集故障信息
echo "=== RabbitMQ故障信息收集 ===" > troubleshoot_$(date +%Y%m%d_%H%M).txt
date >> troubleshoot_$(date +%Y%m%d_%H%M).txt
rabbitmqctl status >> troubleshoot_$(date +%Y%m%d_%H%M).txt
rabbitmqctl list_queues >> troubleshoot_$(date +%Y%m%d_%H%M).txt
df -h >> troubleshoot_$(date +%Y%m%d_%H%M).txt
free -h >> troubleshoot_$(date +%Y%m%d_%H%M).txt
```

---

## 2. 🔐 连接与权限问题排查


### 2.1 连接失败问题诊断

🎯 **简单理解**：连接失败就像打电话打不通，可能是号码错了、电话坏了或者对方不在

**🔸 常见连接失败原因**
```
原因排查顺序：

1. 服务状态 - RabbitMQ是否正常运行？
   检查命令：systemctl status rabbitmq-server
   
2. 网络连通 - 网络是否畅通？
   检查命令：telnet rabbitmq-host 5672
   
3. 端口监听 - 端口是否正确监听？
   检查命令：netstat -tlnp | grep 5672
   
4. 防火墙 - 是否被防火墙阻止？
   检查命令：iptables -L | grep 5672
```

**💡 逐步诊断连接问题**
```bash
# 第一步：检查RabbitMQ服务状态
sudo systemctl status rabbitmq-server
# 如果显示"Active: active (running)"表示服务正常

# 第二步：检查端口监听
sudo netstat -tlnp | grep 5672
# 应该看到类似：tcp 0 0 0.0.0.0:5672 0.0.0.0:* LISTEN

# 第三步：测试网络连接
telnet your-rabbitmq-host 5672
# 能连上说明网络正常，连不上检查防火墙

# 第四步：查看详细错误信息
tail -f /var/log/rabbitmq/rabbit@hostname.log
# 实时查看日志中的错误信息
```

### 2.2 权限认证问题

**🔑 用户权限问题的诊断与解决**

```
权限问题的三个层次：

1. 用户不存在
   现象：用户名密码错误
   解决：创建用户或检查用户名

2. 密码错误
   现象：认证失败
   解决：重置密码或检查密码

3. 权限不足
   现象：能登录但操作失败
   解决：分配合适的权限
```

**🛠️ 权限问题解决步骤**
```bash
# 查看现有用户
sudo rabbitmqctl list_users

# 创建新用户（如果用户不存在）
sudo rabbitmqctl add_user myuser mypassword

# 重置用户密码（如果密码错误）
sudo rabbitmqctl change_password myuser newpassword

# 分配用户权限
sudo rabbitmqctl set_permissions -p / myuser ".*" ".*" ".*"
# 参数说明：-p / 表示默认vhost，三个".*"分别表示配置、写入、读取权限

# 设置用户为管理员（可选）
sudo rabbitmqctl set_user_tags myuser administrator
```

### 2.3 虚拟主机问题

**🏠 虚拟主机(vhost)相关问题**

```
vhost问题常见场景：

1. vhost不存在
   错误信息："NOT_ALLOWED - vhost not found"
   解决方法：创建对应的vhost

2. 用户没有vhost权限
   错误信息："ACCESS_REFUSED - access to vhost denied"
   解决方法：给用户分配vhost权限

3. 客户端连接错误的vhost
   错误信息：找不到队列或交换机
   解决方法：检查客户端配置的vhost名称
```

**📝 vhost问题解决示例**
```bash
# 查看所有vhost
sudo rabbitmqctl list_vhosts

# 创建新的vhost
sudo rabbitmqctl add_vhost /myapp

# 给用户分配vhost权限
sudo rabbitmqctl set_permissions -p /myapp myuser ".*" ".*" ".*"

# 查看用户在特定vhost的权限
sudo rabbitmqctl list_permissions -p /myapp
```

---

## 3. 📊 队列阻塞与积压问题


### 3.1 消息积压现象识别

🎯 **简单理解**：消息积压就像高速公路堵车，车辆(消息)进来得快，出去得慢

**🔸 积压问题的预警信号**
```
轻度积压（需要关注）：
- 队列长度持续增长
- 消费速度 < 生产速度
- 消息处理延迟增加

中度积压（需要处理）：
- 队列长度超过预设阈值
- 消费者处理能力不足
- 内存使用率上升

重度积压（紧急处理）：
- 队列长度暴涨
- 系统内存告急
- 消费完全停滞
```

**📈 积压监控指标解读**
```
关键监控指标：

消息发布速率：msg/s
- 正常：稳定在业务预期范围内
- 异常：突然暴涨或降为零

消息消费速率：msg/s  
- 正常：与发布速率基本平衡
- 异常：明显低于发布速率

队列长度：message count
- 正常：维持在较低水平或稳定增减
- 异常：持续增长且增长速度加快

未确认消息数：unacked count
- 正常：保持在合理范围内
- 异常：持续增长，可能有消费者卡死
```

### 3.2 积压原因分析

**🔍 找出积压的根本原因**

```
积压原因分类诊断：

1. 生产者问题
   - 消息发送量突然增大
   - 批量数据导入或处理
   - 业务逻辑异常导致重复发送

2. 消费者问题
   - 消费者进程挂掉或重启
   - 消费逻辑处理时间过长
   - 消费者数量不足

3. 网络问题
   - 网络延迟增加
   - 连接不稳定
   - 带宽不足

4. 系统资源问题
   - 内存不足
   - CPU使用率过高
   - 磁盘I/O瓶颈
```

**🛠️ 积压诊断工具**
```bash
# 查看队列详细信息
rabbitmqctl list_queues name messages consumers

# 查看队列消息速率
rabbitmqctl list_queues name message_stats.publish_details.rate message_stats.deliver_details.rate

# 查看消费者状态
rabbitmqctl list_consumers

# 实时监控队列变化
watch -n 1 'rabbitmqctl list_queues name messages'
```

### 3.3 积压问题解决方案

**⚡ 针对不同原因的解决策略**

```
解决方案选择矩阵：

临时解决方案（快速缓解）：
✅ 增加消费者实例数量
✅ 优化消费者处理逻辑
✅ 临时提高消费者并发度
✅ 清除不重要的历史消息

长期解决方案（根本解决）：
🔧 重新设计队列结构
🔧 实施消息分片策略
🔧 优化消息处理流程
🔧 建立更好的监控预警
```

**💡 紧急处理步骤**
```bash
# 1. 快速增加消费者（临时方案）
# 启动额外的消费者进程
nohup python consumer.py --queue-name myqueue --workers 5 &

# 2. 查看处理缓慢的消费者
rabbitmqctl list_consumers | grep -v delivering

# 3. 如果有卡死的消费者，关闭其连接
rabbitmqctl close_connection "connection_name" "emergency cleanup"

# 4. 临时清除过期消息（谨慎操作）
rabbitmqctl purge_queue queue_name
# 注意：这会删除队列中的所有消息！
```

---

## 4. 📦 消息丢失问题诊断


### 4.1 消息丢失的可能环节

🎯 **简单理解**：消息传递就像寄快递，可能在任何环节丢失

```
消息传递链路图：
生产者 → RabbitMQ → 队列 → 消费者 → 业务处理

可能丢失的环节：
1. 生产者发送失败（网络问题、服务器宕机）
2. RabbitMQ未持久化（服务器重启时丢失）
3. 消费者处理失败（处理异常、进程崩溃）
4. 确认机制失效（ack丢失、重复消费）
```

**🔸 消息丢失的常见场景**
```
场景1：生产者发送失败
原因：网络中断、RabbitMQ服务不可用
现象：消息根本没到达RabbitMQ
解决：使用发送确认机制

场景2：服务器重启时丢失
原因：消息和队列都没有持久化
现象：重启后消息消失
解决：启用消息持久化

场景3：消费者处理异常
原因：业务逻辑错误、异常未处理
现象：消息被消费但处理失败
解决：正确使用ack/nack机制

场景4：重复消费问题
原因：消费者重启或网络问题
现象：同一消息被处理多次
解决：实现幂等性处理
```

### 4.2 持久化配置检查

**💾 确保消息不会因重启丢失**

```bash
# 检查队列持久化设置
rabbitmqctl list_queues name durable

# 检查交换机持久化设置  
rabbitmqctl list_exchanges name durable

# 检查消息持久化配置
# 在应用代码中检查delivery_mode是否设置为2
```

**🔧 持久化配置最佳实践**
```python
# Python示例：正确的持久化配置
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 声明持久化队列
channel.queue_declare(queue='task_queue', durable=True)

# 发送持久化消息
channel.basic_publish(
    exchange='',
    routing_key='task_queue', 
    body='Hello World!',
    properties=pika.BasicProperties(
        delivery_mode=2,  # 消息持久化
    )
)

# 消费者确认机制
def callback(ch, method, properties, body):
    print("Received:", body)
    # 处理消息
    time.sleep(body.count(b'.'))
    # 手动确认
    ch.basic_ack(delivery_tag=method.delivery_tag)

channel.basic_qos(prefetch_count=1)  # 一次只处理一条消息
channel.basic_consume(queue='task_queue', on_message_callback=callback)
```

### 4.3 消息确认机制诊断

**✅ 检查ack/nack机制是否正常工作**

```
确认机制工作原理：

1. 自动确认（auto_ack=True）
   优点：性能高，处理简单
   缺点：可能丢失消息
   适用：允许丢失的场景

2. 手动确认（auto_ack=False）
   优点：可靠性高，不丢消息
   缺点：性能稍低，需要编程处理
   适用：重要消息场景
```

**🛠️ 确认机制问题排查**
```bash
# 查看未确认消息数量
rabbitmqctl list_queues name messages_unacknowledged

# 如果未确认消息持续增长，可能有问题：
# 1. 消费者处理时间过长
# 2. 消费者忘记发送ack
# 3. 消费者进程异常退出

# 查看消费者连接状态
rabbitmqctl list_connections pid state

# 查看详细的消费者信息
rabbitmqctl list_consumers queue_name ack_required prefetch_count
```

---

## 5. 💾 内存与磁盘空间问题


### 5.1 内存使用监控

🎯 **简单理解**：RabbitMQ就像一个仓库，东西太多就会装不下

**🔸 内存使用的组成部分**
```
RabbitMQ内存使用构成：

1. 消息内容（40-60%）
   - 队列中的消息数据
   - 未确认的消息缓存
   
2. 元数据（20-30%）
   - 队列、交换机信息
   - 绑定关系数据
   
3. 连接状态（10-20%）
   - 客户端连接信息
   - 通道状态数据
   
4. 系统开销（10-15%）
   - Erlang虚拟机开销
   - 插件和管理界面
```

**📊 内存监控指标**
```bash
# 查看RabbitMQ内存使用
rabbitmqctl status | grep memory

# 查看详细内存分配
rabbitmqctl eval 'rabbit_vm:memory().'

# 查看系统总内存使用
free -h

# 持续监控内存变化
watch -n 5 'rabbitmqctl status | grep -A 10 memory'
```

### 5.2 内存告警与限制

**⚠️ 内存不足时的系统行为**

```
内存告警机制：

1. 内存告警阈值（默认40%）
   触发条件：可用内存 < 总内存的40%
   系统行为：停止接收新消息，发出告警

2. 内存紧急阈值（通常85%）
   触发条件：内存使用超过85%
   系统行为：开始强制清理内存

3. 内存耗尽（接近100%）
   触发条件：系统内存几乎用完
   系统行为：服务可能崩溃或重启
```

**🛠️ 内存问题解决方案**
```bash
# 查看当前内存告警状态
rabbitmqctl status | grep alarm

# 临时提高内存阈值（应急处理）
rabbitmqctl eval 'vm_memory_monitor:set_vm_memory_high_watermark(0.6).'
# 将阈值从40%提高到60%

# 清理内存的方法：
# 1. 清空不重要的队列
rabbitmqctl purge_queue queue_name

# 2. 关闭无用的连接
rabbitmqctl list_connections name | grep idle
rabbitmqctl close_connection "connection_name" "cleanup"

# 3. 重启RabbitMQ服务（最后手段）
systemctl restart rabbitmq-server
```

### 5.3 磁盘空间管理

**💿 磁盘空间不足的问题与解决**

```
磁盘空间使用场景：

1. 持久化消息存储
   位置：/var/lib/rabbitmq/mnesia/
   内容：持久化队列和消息

2. 日志文件存储
   位置：/var/log/rabbitmq/
   内容：系统日志和错误日志

3. 节点元数据
   位置：/var/lib/rabbitmq/mnesia/
   内容：集群状态、用户信息等
```

**🧹 磁盘空间清理策略**
```bash
# 检查磁盘使用情况
df -h
du -sh /var/lib/rabbitmq/
du -sh /var/log/rabbitmq/

# 清理日志文件
# 1. 压缩旧日志
gzip /var/log/rabbitmq/rabbit@hostname.log.1
gzip /var/log/rabbitmq/rabbit@hostname.log.2

# 2. 删除过期日志（保留最近7天）
find /var/log/rabbitmq/ -name "*.gz" -mtime +7 -delete

# 3. 配置日志轮转
cat > /etc/logrotate.d/rabbitmq << EOF
/var/log/rabbitmq/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 644 rabbitmq rabbitmq
}
EOF

# 设置磁盘空间告警阈值
rabbitmqctl eval 'rabbit_disk_monitor:set_disk_free_limit(2000000000).'
# 设置磁盘剩余空间低于2GB时告警
```

---

## 6. 🌐 集群节点故障处理


### 6.1 集群状态检查

🎯 **简单理解**：集群就像一个团队，需要成员之间相互配合

**🔸 集群健康检查**
```bash
# 查看集群状态
rabbitmqctl cluster_status

# 检查各节点状态
rabbitmqctl eval 'rabbit_mnesia:status().'

# 查看节点间网络连接
rabbitmqctl eval 'rabbit_networking:active_listeners().'

# 检查集群中的队列分布
rabbitmqctl list_queues name slave_pids policy
```

**📊 集群状态解读**
```
正常集群状态特征：
✅ 所有节点都在running_nodes列表中
✅ 没有partitions（网络分区）
✅ disk_nodes包含足够的磁盘节点
✅ 队列在节点间合理分布

异常集群状态特征：
❌ 有节点不在running_nodes中
❌ 出现network_partitions
❌ 只有ram_nodes没有disk_nodes
❌ 队列集中在某个节点上
```

### 6.2 节点故障恢复

**🔧 单个节点故障的处理流程**

```
节点故障恢复步骤：

1. 确认故障节点状态
   检查：节点是否还能ping通
   检查：RabbitMQ进程是否存在
   检查：系统资源是否正常

2. 尝试重启节点
   命令：systemctl restart rabbitmq-server
   检查：是否能重新加入集群

3. 如果无法重启，考虑移除并重新加入
   移除：rabbitmqctl forget_cluster_node rabbit@failed-node
   重新加入：在故障节点上执行join_cluster
```

**💡 节点恢复实操示例**
```bash
# 在正常节点上检查集群状态
rabbitmqctl cluster_status

# 如果发现故障节点，尝试从其他节点移除它
rabbitmqctl forget_cluster_node rabbit@failed-node

# 在故障节点修复后，重新加入集群
# （在故障节点上执行）
systemctl stop rabbitmq-server
rabbitmqctl join_cluster rabbit@running-node
systemctl start rabbitmq-server

# 验证节点重新加入成功
rabbitmqctl cluster_status
```

### 6.3 脑裂问题处理

**🧠 网络分区（脑裂）的识别和处理**

```
脑裂现象识别：

什么是脑裂？
- 网络故障导致集群分裂成多个部分
- 每个部分都认为自己是正确的
- 可能导致数据不一致

脑裂的危害：
- 队列状态不一致
- 消息可能重复或丢失
- 集群无法正常工作
```

**🚨 脑裂处理流程**
```bash
# 1. 识别脑裂状态
rabbitmqctl cluster_status
# 查看partitions字段是否为空

# 2. 选择主分区（通常是包含磁盘节点较多的分区）
# 在主分区的节点上执行：
rabbitmqctl cluster_status

# 3. 重启非主分区的节点
# 在分区节点上依次执行：
systemctl stop rabbitmq-server
systemctl start rabbitmq-server

# 4. 验证脑裂已解决
rabbitmqctl cluster_status | grep partitions
# 应该显示 partitions: []
```

---

## 7. 📈 性能监控指标解读


### 7.1 关键性能指标分类

🎯 **简单理解**：监控指标就像汽车仪表盘，告诉你系统运行是否正常

**🔸 核心监控指标体系**
```
消息流量指标：
📊 消息发布速率（msg/s）- 每秒产生多少消息
📊 消息消费速率（msg/s）- 每秒处理多少消息
📊 队列长度变化 - 消息积压情况
📊 消息确认速率 - 消息处理成功率

系统资源指标：
🖥️ CPU使用率 - 处理器负载情况
💾 内存使用趋势 - 内存占用变化
💿 磁盘I/O性能 - 读写操作效率
🌐 网络流量统计 - 网络带宽使用

连接与会话指标：
🔗 连接数统计 - 客户端连接情况
📡 通道数量 - 消息通道使用情况
👥 消费者数量 - 处理消息的工作者数量
```

### 7.2 消息流量指标解读

**📊 深入理解消息处理性能**

```
消息发布速率分析：

正常模式：
- 发布速率相对稳定
- 在业务预期范围内波动
- 与业务活跃时间相符

异常模式：
- 突然暴增：可能有批量任务或系统异常
- 突然降零：可能生产者故障或网络问题
- 持续高位：可能业务量增长或重复发送

优化建议：
- 发布速率过高：考虑限流或分批处理
- 发布速率不稳：检查生产者逻辑
- 发布速率过低：检查业务逻辑是否正常
```

**💡 性能监控实践**
```bash
# 实时监控消息流量
watch -n 1 'rabbitmqctl list_queues name messages_ready messages_unacknowledged'

# 监控消息速率变化
rabbitmqctl eval '
[{Queue, Props}] = rabbit_amqqueue:info_all(rabbit_misc:r(<<"/">>, queue, <<"my_queue">>), [message_stats]),
{message_stats, Stats} = proplists:lookup(message_stats, Props),
PublishRate = proplists:get_value(publish_details, Stats, []),
DeliverRate = proplists:get_value(deliver_details, Stats, []),
io:format("Publish: ~p, Deliver: ~p~n", [PublishRate, DeliverRate]).
'

# 查看连接统计信息
rabbitmqctl list_connections recv_oct sent_oct
```

### 7.3 资源使用指标分析

**🔍 系统资源健康度评估**

```
CPU使用率分析：
低使用率（0-30%）：
- 系统负载轻，性能良好
- 可能消息量较少

中等使用率（30-70%）：
- 正常业务负载
- 需要持续监控

高使用率（70-90%）：
- 系统压力较大
- 考虑优化或扩容

极高使用率（90%+）：
- 系统瓶颈，影响性能
- 紧急处理需要

内存使用模式：
稳定增长：正常的消息积累
急剧上升：可能有内存泄漏
波动较大：消息处理不均匀
持续高位：需要清理或扩容
```

**📊 资源监控脚本**
```bash
#!/bin/bash
# rabbitmq_monitor.sh

echo "=== RabbitMQ性能监控报告 ==="
echo "时间: $(date)"

# CPU和内存使用
echo "=== 系统资源 ==="
top -b -n1 | grep rabbitmq | head -5

# RabbitMQ特定内存使用
echo "=== RabbitMQ内存使用 ==="
rabbitmqctl status | grep -A 5 memory

# 消息队列状态
echo "=== 队列状态 ==="
rabbitmqctl list_queues name messages consumers | head -10

# 连接统计
echo "=== 连接统计 ==="
echo "总连接数: $(rabbitmqctl list_connections | wc -l)"

# 磁盘使用
echo "=== 磁盘使用 ==="
df -h | grep -E "(rabbitmq|/var)"

echo "=========================="
```

---

## 8. 🛠️ 常用排查工具与命令


### 8.1 基础诊断命令

🎯 **简单理解**：这些命令就像医生的听诊器，帮助快速了解系统状态

**🔧 日常检查命令清单**
```bash
# 🏥 健康检查命令
rabbitmqctl status                    # 查看服务整体状态
rabbitmqctl node_health_check        # 节点健康检查
rabbitmqctl cluster_status           # 集群状态检查

# 📊 业务监控命令  
rabbitmqctl list_queues              # 查看所有队列
rabbitmqctl list_exchanges           # 查看所有交换机
rabbitmqctl list_bindings            # 查看绑定关系
rabbitmqctl list_connections         # 查看客户端连接
rabbitmqctl list_consumers           # 查看消费者状态

# 👥 用户权限命令
rabbitmqctl list_users              # 查看用户列表
rabbitmqctl list_permissions        # 查看权限设置
rabbitmqctl list_vhosts             # 查看虚拟主机
```

### 8.2 高级诊断工具

**🔍 深度问题分析工具**

```bash
# 📝 日志分析工具
tail -f /var/log/rabbitmq/rabbit@hostname.log
# 实时查看RabbitMQ日志

grep ERROR /var/log/rabbitmq/rabbit@hostname.log
# 搜索错误信息

journalctl -u rabbitmq-server -f
# 通过systemd查看服务日志

# 🔬 性能分析工具
rabbitmq-diagnostics status
# 新版本的诊断命令

rabbitmq-diagnostics memory_breakdown
# 详细内存使用分析

rabbitmq-diagnostics check_running
# 检查服务是否正在运行

# 🌐 网络诊断工具
ss -tulpn | grep 5672
# 检查端口监听状态

tcpdump -i any port 5672
# 抓取网络包分析

nmap -p 5672 rabbitmq-host
# 检查端口是否开放
```

### 8.3 故障排查脚本

**🚀 自动化诊断脚本**

```bash
#!/bin/bash
# rabbitmq_health_check.sh
# RabbitMQ全面健康检查脚本

LOGFILE="/tmp/rabbitmq_health_$(date +%Y%m%d_%H%M).log"

echo "RabbitMQ健康检查开始: $(date)" | tee $LOGFILE

# 检查服务状态
echo "=== 服务状态检查 ===" | tee -a $LOGFILE
if systemctl is-active rabbitmq-server >/dev/null 2>&1; then
    echo "✅ RabbitMQ服务正在运行" | tee -a $LOGFILE
else
    echo "❌ RabbitMQ服务未运行" | tee -a $LOGFILE
    exit 1
fi

# 检查端口监听
echo "=== 端口检查 ===" | tee -a $LOGFILE
if netstat -tlnp | grep :5672 >/dev/null 2>&1; then
    echo "✅ 端口5672正在监听" | tee -a $LOGFILE
else
    echo "❌ 端口5672未监听" | tee -a $LOGFILE
fi

# 检查节点健康
echo "=== 节点健康检查 ===" | tee -a $LOGFILE
if rabbitmqctl node_health_check >/dev/null 2>&1; then
    echo "✅ 节点健康状态正常" | tee -a $LOGFILE
else
    echo "❌ 节点健康检查失败" | tee -a $LOGFILE
fi

# 检查内存使用
echo "=== 内存使用检查 ===" | tee -a $LOGFILE
MEMORY_ALARM=$(rabbitmqctl status | grep memory_alarm | grep -o false)
if [ "$MEMORY_ALARM" = "false" ]; then
    echo "✅ 内存使用正常" | tee -a $LOGFILE
else
    echo "⚠️  内存告警状态" | tee -a $LOGFILE
fi

# 检查磁盘空间
echo "=== 磁盘空间检查 ===" | tee -a $LOGFILE
DISK_ALARM=$(rabbitmqctl status | grep disk_free_alarm | grep -o false)
if [ "$DISK_ALARM" = "false" ]; then
    echo "✅ 磁盘空间充足" | tee -a $LOGFILE
else
    echo "⚠️  磁盘空间告警" | tee -a $LOGFILE
fi

# 检查队列积压
echo "=== 队列积压检查 ===" | tee -a $LOGFILE
MAX_QUEUE_SIZE=$(rabbitmqctl list_queues messages | awk '{if($2>max) max=$2} END {print max+0}')
if [ $MAX_QUEUE_SIZE -lt 1000 ]; then
    echo "✅ 队列消息数量正常 (最大: $MAX_QUEUE_SIZE)" | tee -a $LOGFILE
elif [ $MAX_QUEUE_SIZE -lt 10000 ]; then
    echo "⚠️  队列消息较多 (最大: $MAX_QUEUE_SIZE)" | tee -a $LOGFILE
else
    echo "❌ 队列严重积压 (最大: $MAX_QUEUE_SIZE)" | tee -a $LOGFILE
fi

echo "健康检查完成: $(date)" | tee -a $LOGFILE
echo "详细报告已保存到: $LOGFILE"
```

### 8.4 监控集成方案

**📊 与监控系统的集成**

```bash
# Prometheus监控集成
# 启用RabbitMQ Prometheus插件
rabbitmq-plugins enable rabbitmq_prometheus

# Grafana仪表板配置
# 1. 添加Prometheus数据源
# 2. 导入RabbitMQ官方仪表板
# 3. 配置告警规则

# 常用Prometheus查询
# 消息发布速率
rate(rabbitmq_messages_published_total[5m])

# 消息消费速率  
rate(rabbitmq_messages_delivered_total[5m])

# 队列长度
rabbitmq_queue_messages

# 内存使用率
rabbitmq_process_resident_memory_bytes / rabbitmq_process_max_heap_size_bytes
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的故障诊断思路


```
🔸 故障诊断三步法：发现问题→定位原因→解决问题
🔸 信息收集：系统状态、错误日志、资源使用、业务影响
🔸 分层排查：网络→服务→应用→业务逻辑
🔸 优先级处理：按影响范围和紧急程度分类处理
🔸 预防为主：监控预警、定期巡检、容量规划
```

### 9.2 关键问题类型与解决思路


**🔹 连接问题解决思路**
```
系统性排查：
服务状态 → 网络连通 → 端口监听 → 防火墙规则
权限认证 → 用户存在 → 密码正确 → 权限足够
vhost配置 → vhost存在 → 用户权限 → 客户端配置

记忆要点：
- 先查服务再查网络
- 先查权限再查配置
- 日志是最好的朋友
```

**🔹 性能问题解决思路**
```
性能分析维度：
消息流量 → 生产速率vs消费速率
系统资源 → CPU、内存、磁盘、网络
应用逻辑 → 处理时间、并发度、错误率

优化策略：
- 消息积压：增加消费者、优化处理逻辑
- 资源不足：清理资源、扩容硬件
- 网络问题：检查连接、优化配置
```

**🔹 可靠性问题解决思路**
```
消息可靠性保障：
发送确认 → publisher confirms
消息持久化 → durable队列 + persistent消息
消费确认 → manual ack机制
集群容错 → 多节点部署 + 监控告警

防范措施：
- 生产者：确认机制 + 重试策略
- 存储：持久化配置 + 定期备份
- 消费者：幂等处理 + 错误重试
- 集群：健康检查 + 自动恢复
```

### 9.3 实际应用价值


**🎯 生产环境故障处理经验**
- **电商大促**：消息积压处理、性能优化、容量扩展
- **金融交易**：消息可靠性保障、集群故障恢复
- **物联网平台**：连接数管理、网络分区处理
- **微服务架构**：服务间通信故障、依赖关系问题

**🔧 运维最佳实践**
- **预防为主**：完善监控、定期巡检、容量规划
- **快速响应**：故障预案、应急流程、自动化工具
- **持续改进**：故障复盘、流程优化、技能提升
- **团队协作**：责任明确、信息共享、经验传承

**📈 技能发展建议**
- **基础能力**：熟练掌握常用诊断命令和工具
- **分析能力**：培养系统性问题分析思维
- **应急能力**：建立快速故障处理流程
- **预防能力**：建立完善的监控和预警体系

**核心记忆口诀**：
- 故障诊断有套路，三步分析不慌乱
- 连接权限先检查，日志监控是关键  
- 性能问题看指标，资源消息要平衡
- 可靠性靠机制，持久确认加集群
- 预防胜过治疗法，监控预警要在前