---
title: 7ã€RPCè¿œç¨‹è°ƒç”¨æ¨¡å¼
---
## ğŸ“š ç›®å½•

1. [RPCè¿œç¨‹è°ƒç”¨åŸºç¡€æ¦‚å¿µ](#1-RPCè¿œç¨‹è°ƒç”¨åŸºç¡€æ¦‚å¿µ)
2. [RabbitMQä¸­çš„RPCå®ç°åŸç†](#2-RabbitMQä¸­çš„RPCå®ç°åŸç†)
3. [åŒæ­¥è°ƒç”¨å®ç°æœºåˆ¶](#3-åŒæ­¥è°ƒç”¨å®ç°æœºåˆ¶)
4. [Correlation IDæ ¸å¿ƒæœºåˆ¶](#4-Correlation-IDæ ¸å¿ƒæœºåˆ¶)
5. [Reply Toé˜Ÿåˆ—è®¾è®¡](#5-Reply-Toé˜Ÿåˆ—è®¾è®¡)
6. [å›è°ƒé˜Ÿåˆ—æ¶æ„è®¾è®¡](#6-å›è°ƒé˜Ÿåˆ—æ¶æ„è®¾è®¡)
7. [è¶…æ—¶ä¸é”™è¯¯å¤„ç†ç­–ç•¥](#7-è¶…æ—¶ä¸é”™è¯¯å¤„ç†ç­–ç•¥)
8. [å®è·µåº”ç”¨ä¸æ€§èƒ½ä¼˜åŒ–](#8-å®è·µåº”ç”¨ä¸æ€§èƒ½ä¼˜åŒ–)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ”„ RPCè¿œç¨‹è°ƒç”¨åŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯RPCè¿œç¨‹è°ƒç”¨


**é€šä¿—ç†è§£**ï¼šRPCå°±åƒæ‰“ç”µè¯ä¸€æ · - ä½ æ‹¨å·(å‘è¯·æ±‚)ï¼Œç­‰å¯¹æ–¹æ¥å¬(å¤„ç†)ï¼Œç„¶åå¯¹æ–¹å›å¤ä½ (è¿”å›ç»“æœ)ï¼Œæ•´ä¸ªè¿‡ç¨‹ä½ éƒ½åœ¨ç­‰å¾…ã€‚

```
ğŸ  æœ¬åœ°å‡½æ•°è°ƒç”¨ï¼š
result = calculate(10, 20)  // ç›´æ¥è°ƒç”¨ï¼Œç«‹å³è¿”å›30

ğŸ“ è¿œç¨‹å‡½æ•°è°ƒç”¨(RPC)ï¼š
å®¢æˆ·ç«¯                    æœåŠ¡ç«¯
   |------ è¯·æ±‚ ------>      |
   |     calculate(10,20)    |
   |                        |
   |<----- ç»“æœ -------      |
   |        30              |
```

### 1.2 ä¼ ç»ŸRPC vs æ¶ˆæ¯é˜Ÿåˆ—RPC


**ğŸ†š å®ç°æ–¹å¼å¯¹æ¯”**ï¼š

| ç‰¹æ€§ | **ä¼ ç»ŸRPC** | **æ¶ˆæ¯é˜Ÿåˆ—RPC** |
|------|-------------|-----------------|
| **è¿æ¥æ–¹å¼** | `ç›´æ¥TCPè¿æ¥` | `é€šè¿‡æ¶ˆæ¯ä¸­é—´ä»¶` |
| **å¯é æ€§** | `è¿æ¥æ–­å¼€è°ƒç”¨å¤±è´¥` | `æ¶ˆæ¯æŒä¹…åŒ–ä¿è¯å¯é ` |
| **è´Ÿè½½å‡è¡¡** | `éœ€è¦é¢å¤–å®ç°` | `å¤©ç„¶æ”¯æŒå¤šæ¶ˆè´¹è€…` |
| **è§£è€¦ç¨‹åº¦** | `ç´§è€¦åˆ` | `æ¾è€¦åˆ` |
| **å¤æ‚åº¦** | `ç›¸å¯¹ç®€å•` | `éœ€è¦å¤„ç†å¼‚æ­¥æœºåˆ¶` |

### 1.3 ä¸ºä»€ä¹ˆè¦ç”¨RabbitMQåšRPC


**ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿**ï¼š
```
å¯é æ€§ä¿éšœï¼š
âœ… æ¶ˆæ¯æŒä¹…åŒ– - è¯·æ±‚ä¸ä¼šä¸¢å¤±
âœ… è‡ªåŠ¨é‡è¯• - å¤±è´¥æ—¶å¯ä»¥é‡æ–°å¤„ç†
âœ… é›†ç¾¤æ”¯æŒ - å•èŠ‚ç‚¹æ•…éšœä¸å½±å“æœåŠ¡

æ‰©å±•æ€§æ”¯æŒï¼š
âœ… å¤šæ¶ˆè´¹è€… - å¤©ç„¶è´Ÿè½½å‡è¡¡
âœ… é˜Ÿåˆ—è·¯ç”± - æŒ‰ä¸šåŠ¡ç±»å‹åˆ†å‘
âœ… ä¼˜å…ˆçº§é˜Ÿåˆ— - é‡è¦è¯·æ±‚ä¼˜å…ˆå¤„ç†

ç›‘æ§ä¸ç®¡ç†ï¼š
âœ… é˜Ÿåˆ—çŠ¶æ€ - å®æ—¶ç›‘æ§è¯·æ±‚å †ç§¯
âœ… æ¶ˆæ¯è¿½è¸ª - å®Œæ•´çš„è°ƒç”¨é“¾è·¯
âœ… ç®¡ç†ç•Œé¢ - å¯è§†åŒ–è¿ç»´
```

---

## 2. âš™ï¸ RabbitMQä¸­çš„RPCå®ç°åŸç†


### 2.1 RPCé€šä¿¡æ¨¡å‹


**ğŸ“‹ åŸºæœ¬é€šä¿¡æµç¨‹**ï¼š
```
RPCè°ƒç”¨çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼š

å®¢æˆ·ç«¯                    RabbitMQ                    æœåŠ¡ç«¯
   |                        |                          |
   |--[1]å‘é€è¯·æ±‚æ¶ˆæ¯------->|                          |
   |   (å¸¦correlation_id)   |                          |
   |                        |--[2]è·¯ç”±åˆ°è¯·æ±‚é˜Ÿåˆ—------>|
   |                        |                         |
   |                        |<--[3]æ¥æ”¶å¹¶å¤„ç†è¯·æ±‚-----|
   |                        |                         |
   |                        |<--[4]å‘é€å“åº”æ¶ˆæ¯-------|
   |                        |   (å¸¦correlation_id)   |
   |<--[5]æ¥æ”¶å“åº”æ¶ˆæ¯------|                         |
   |                        |                         |
   |--[6]è¿”å›ç»“æœç»™è°ƒç”¨è€…--->|                         |
```

### 2.2 æ ¸å¿ƒç»„ä»¶æ¶æ„


**ğŸ—ï¸ RPCæ¶æ„ç»„æˆéƒ¨åˆ†**ï¼š
```
RPCç³»ç»Ÿæ¶æ„å›¾ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   RPCå®¢æˆ·ç«¯     â”‚    â”‚   RPCæœåŠ¡ç«¯     â”‚
â”‚                 â”‚    â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚è¯·æ±‚ç”Ÿæˆå™¨   â”‚ â”‚    â”‚ â”‚è¯·æ±‚å¤„ç†å™¨   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚å“åº”ç­‰å¾…å™¨   â”‚ â”‚    â”‚ â”‚å“åº”å‘é€å™¨   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                        â”‚
         â””â”€â”€â”€â”€â”€â”€ RabbitMQ â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ è¯·æ±‚é˜Ÿåˆ—    â”‚
              â”‚ å“åº”é˜Ÿåˆ—    â”‚
              â”‚ äº¤æ¢æœº      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 æ¶ˆæ¯æµè½¬æœºåˆ¶


**ğŸ”„ æ¶ˆæ¯åœ¨RabbitMQä¸­çš„æµè½¬**ï¼š
```
è¯·æ±‚æµç¨‹ï¼š
1. å®¢æˆ·ç«¯åˆ›å»ºè¯·æ±‚æ¶ˆæ¯
   â”œâ”€â”€ æ¶ˆæ¯ä½“ï¼šå®é™…çš„è¯·æ±‚æ•°æ®
   â”œâ”€â”€ correlation_idï¼šè¯·æ±‚å”¯ä¸€æ ‡è¯†
   â””â”€â”€ reply_toï¼šå›å¤é˜Ÿåˆ—åç§°

2. å‘é€åˆ°è¯·æ±‚é˜Ÿåˆ—
   â”œâ”€â”€ é€šè¿‡é»˜è®¤äº¤æ¢æœºè·¯ç”±
   â””â”€â”€ æœåŠ¡ç«¯æ¶ˆè´¹è€…æ¥æ”¶

3. æœåŠ¡ç«¯å¤„ç†è¯·æ±‚
   â”œâ”€â”€ è§£æè¯·æ±‚å‚æ•°
   â”œâ”€â”€ æ‰§è¡Œä¸šåŠ¡é€»è¾‘
   â””â”€â”€ ç”Ÿæˆå“åº”æ•°æ®

4. å‘é€å“åº”æ¶ˆæ¯
   â”œâ”€â”€ ä½¿ç”¨åŸè¯·æ±‚çš„correlation_id
   â”œâ”€â”€ å‘é€åˆ°reply_toæŒ‡å®šçš„é˜Ÿåˆ—
   â””â”€â”€ å®¢æˆ·ç«¯æ¥æ”¶å¹¶åŒ¹é…å“åº”
```

---

## 3. ğŸ”„ åŒæ­¥è°ƒç”¨å®ç°æœºåˆ¶


### 3.1 åŒæ­¥è°ƒç”¨çš„æŒ‘æˆ˜


**ğŸ˜Ÿ å¼‚æ­¥ä¸–ç•Œä¸­çš„åŒæ­¥éœ€æ±‚**ï¼š
RabbitMQæœ¬è´¨ä¸Šæ˜¯å¼‚æ­¥çš„ï¼Œä½†æœ‰æ—¶æˆ‘ä»¬éœ€è¦åƒè°ƒç”¨æœ¬åœ°å‡½æ•°ä¸€æ ·åŒæ­¥ç­‰å¾…ç»“æœã€‚è¿™å°±åƒåœ¨"å¼‚æ­¥çš„å¤§æµ·"ä¸­å»ºé€ ä¸€åº§"åŒæ­¥çš„æ¡¥æ¢"ã€‚

```
åŒæ­¥è°ƒç”¨çš„æœ¬è´¨ï¼š
ç”¨æˆ·è°ƒç”¨ â†’ å‘é€æ¶ˆæ¯ â†’ é˜»å¡ç­‰å¾… â†’ æ¥æ”¶å“åº” â†’ è¿”å›ç»“æœ

æŒ‘æˆ˜ï¼š
â“ å¦‚ä½•è®©å¼‚æ­¥çš„æ¶ˆæ¯ä¼ é€’å˜æˆåŒæ­¥çš„å‡½æ•°è°ƒç”¨ï¼Ÿ
â“ å¦‚ä½•ç¡®ä¿å“åº”èƒ½æ­£ç¡®åŒ¹é…åˆ°å¯¹åº”çš„è¯·æ±‚ï¼Ÿ
â“ å¦‚ä½•å¤„ç†è¶…æ—¶å’Œå¼‚å¸¸æƒ…å†µï¼Ÿ
```

### 3.2 é˜»å¡ç­‰å¾…æœºåˆ¶


**â³ å®ç°åŒæ­¥ç­‰å¾…çš„æ–¹æ³•**ï¼š

**æ–¹æ³•ä¸€ï¼šå¾ªç¯ç­‰å¾…**
```python
class RPCClient:
    def __init__(self):
        self.response = None
        self.correlation_id = None
        
    def call(self, message):
        # ç”Ÿæˆå”¯ä¸€ID
        self.correlation_id = str(uuid.uuid4())
        
        # å‘é€è¯·æ±‚
        self.send_request(message, self.correlation_id)
        
        # å¾ªç¯ç­‰å¾…å“åº”
        while self.response is None:
            self.connection.process_data_events(time_limit=1)
            
        result = self.response
        self.response = None  # é‡ç½®çŠ¶æ€
        return result
```

**æ–¹æ³•äºŒï¼šäº‹ä»¶ç­‰å¾…**
```python
import threading

class RPCClient:
    def __init__(self):
        self.pending_requests = {}
        
    def call(self, message, timeout=30):
        correlation_id = str(uuid.uuid4())
        
        # åˆ›å»ºäº‹ä»¶å¯¹è±¡
        event = threading.Event()
        self.pending_requests[correlation_id] = {
            'event': event,
            'result': None
        }
        
        # å‘é€è¯·æ±‚
        self.send_request(message, correlation_id)
        
        # ç­‰å¾…å“åº”ï¼ˆå¸¦è¶…æ—¶ï¼‰
        if event.wait(timeout):
            result = self.pending_requests[correlation_id]['result']
            del self.pending_requests[correlation_id]
            return result
        else:
            del self.pending_requests[correlation_id]
            raise TimeoutError("RPCè°ƒç”¨è¶…æ—¶")
```

### 3.3 çº¿ç¨‹å®‰å…¨è€ƒè™‘


**ğŸ”’ å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„å®‰å…¨æ€§**ï¼š
```
çº¿ç¨‹å®‰å…¨æŒ‘æˆ˜ï¼š
â€¢ å¤šä¸ªçº¿ç¨‹åŒæ—¶å‘èµ·RPCè°ƒç”¨
â€¢ å“åº”å›è°ƒå¯èƒ½åœ¨ä¸åŒçº¿ç¨‹ä¸­æ‰§è¡Œ
â€¢ å…±äº«çŠ¶æ€çš„å¹¶å‘è®¿é—®é—®é¢˜

è§£å†³æ–¹æ¡ˆï¼š
âœ… ä½¿ç”¨çº¿ç¨‹é”ä¿æŠ¤å…±äº«çŠ¶æ€
âœ… æ¯ä¸ªè¯·æ±‚ä½¿ç”¨ç‹¬ç«‹çš„ç­‰å¾…æœºåˆ¶
âœ… åˆç†è®¾è®¡æ•°æ®ç»“æ„é¿å…ç«äº‰
```

---

## 4. ğŸ·ï¸ Correlation IDæ ¸å¿ƒæœºåˆ¶


### 4.1 Correlation IDçš„ä½œç”¨


**ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦Correlation ID**ï¼š
æƒ³è±¡ä¸€ä¸‹é‚®å±€çš„åœºæ™¯ - ä½ å¯„å‡ºå¾ˆå¤šä¿¡ä»¶ï¼Œæ”¶åˆ°å›ä¿¡æ—¶æ€ä¹ˆçŸ¥é“æ˜¯å›å¤å“ªå°ä¿¡çš„ï¼ŸCorrelation IDå°±åƒä¿¡ä»¶ä¸Šçš„"å›æ‰§ç¼–å·"ã€‚

```
æ²¡æœ‰Correlation IDçš„é—®é¢˜ï¼š
å®¢æˆ·ç«¯å‘é€ï¼šè¯·æ±‚Aã€è¯·æ±‚Bã€è¯·æ±‚C
æœåŠ¡ç«¯è¿”å›ï¼šå“åº”1ã€å“åº”2ã€å“åº”3
é—®é¢˜ï¼šä¸çŸ¥é“å“åº”1æ˜¯å¯¹åº”è¯·æ±‚Aè¿˜æ˜¯è¯·æ±‚Bï¼Ÿ

æœ‰Correlation IDçš„è§£å†³ï¼š
è¯·æ±‚A (ID: abc123) â†’ å“åº”1 (ID: abc123) âœ… åŒ¹é…æˆåŠŸ
è¯·æ±‚B (ID: def456) â†’ å“åº”2 (ID: def456) âœ… åŒ¹é…æˆåŠŸ
è¯·æ±‚C (ID: ghi789) â†’ å“åº”3 (ID: ghi789) âœ… åŒ¹é…æˆåŠŸ
```

### 4.2 Correlation IDç”Ÿæˆç­–ç•¥


**ğŸ”¢ ç”Ÿæˆæ–¹æ³•å¯¹æ¯”**ï¼š

| æ–¹æ³• | **ç¤ºä¾‹** | **ä¼˜ç‚¹** | **ç¼ºç‚¹** |
|------|----------|----------|----------|
| **UUID4** | `a1b2c3d4-e5f6...` | `å…¨å±€å”¯ä¸€ï¼Œæ— å†²çª` | `è¾ƒé•¿ï¼Œå ç”¨ç©ºé—´å¤§` |
| **æ—¶é—´æˆ³+éšæœºæ•°** | `20231201_abc123` | `å¯è¯»æ€§å¥½ï¼ŒåŒ…å«æ—¶é—´ä¿¡æ¯` | `å¯èƒ½é‡å¤ï¼ˆæä½æ¦‚ç‡ï¼‰` |
| **åŸå­é€’å¢** | `1, 2, 3, 4...` | `ç®€å•é«˜æ•ˆï¼Œå ç”¨ç©ºé—´å°` | `é‡å¯åé‡ç½®ï¼Œä¸å¤Ÿéšæœº` |
| **çº¿ç¨‹ID+åºå·** | `thread1_001` | `ä¾¿äºè°ƒè¯•å’Œè¿½è¸ª` | `é‡å¯åå¯èƒ½é‡å¤` |

**ğŸ’¡ å®é™…ç”Ÿæˆä»£ç ç¤ºä¾‹**ï¼š
```python
import uuid
import time
import threading

class CorrelationIDGenerator:
    def __init__(self):
        self._counter = 0
        self._lock = threading.Lock()
    
    def uuid_based(self):
        """åŸºäºUUIDçš„IDç”Ÿæˆï¼ˆæ¨èï¼‰"""
        return str(uuid.uuid4())
    
    def timestamp_based(self):
        """åŸºäºæ—¶é—´æˆ³çš„IDç”Ÿæˆ"""
        timestamp = int(time.time() * 1000)  # æ¯«ç§’æ—¶é—´æˆ³
        random_part = uuid.uuid4().hex[:8]
        return f"{timestamp}_{random_part}"
    
    def sequential_based(self):
        """åŸºäºåºå·çš„IDç”Ÿæˆ"""
        with self._lock:
            self._counter += 1
            return f"req_{self._counter:08d}"
```

### 4.3 Correlation IDåŒ¹é…æœºåˆ¶


**ğŸ” å“åº”åŒ¹é…çš„å®ç°**ï¼š
```python
class RPCResponseHandler:
    def __init__(self):
        # å­˜å‚¨å¾…å¤„ç†çš„è¯·æ±‚
        self.pending_requests = {}
        self.lock = threading.Lock()
    
    def register_request(self, correlation_id, callback):
        """æ³¨å†Œè¯·æ±‚å›è°ƒ"""
        with self.lock:
            self.pending_requests[correlation_id] = callback
    
    def handle_response(self, correlation_id, response_data):
        """å¤„ç†å“åº”æ¶ˆæ¯"""
        with self.lock:
            if correlation_id in self.pending_requests:
                callback = self.pending_requests.pop(correlation_id)
                # åœ¨å•ç‹¬çº¿ç¨‹ä¸­å¤„ç†å›è°ƒï¼Œé¿å…é˜»å¡
                threading.Thread(
                    target=callback, 
                    args=(response_data,)
                ).start()
            else:
                print(f"æ”¶åˆ°æœªçŸ¥å“åº”: {correlation_id}")
```

### 4.4 Correlation IDæœ€ä½³å®è·µ


**âœ… ä½¿ç”¨å»ºè®®**ï¼š
```
IDç”ŸæˆåŸåˆ™ï¼š
â€¢ ä¿è¯å”¯ä¸€æ€§ï¼šé¿å…IDå†²çªå¯¼è‡´å“åº”é”™ä¹±
â€¢ ä¾¿äºè°ƒè¯•ï¼šåŒ…å«æœ‰æ„ä¹‰çš„ä¿¡æ¯
â€¢ æ€§èƒ½è€ƒè™‘ï¼šç”Ÿæˆé€Ÿåº¦è¦å¿«
â€¢ å®‰å…¨è€ƒè™‘ï¼šä¸è¦åŒ…å«æ•æ„Ÿä¿¡æ¯

å­˜å‚¨ç®¡ç†ï¼š
â€¢ åŠæ—¶æ¸…ç†è¿‡æœŸçš„ID
â€¢ è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
â€¢ ç›‘æ§æœªåŒ¹é…çš„å“åº”
â€¢ è®°å½•åŒ¹é…å¤±è´¥çš„æƒ…å†µ

é”™è¯¯å¤„ç†ï¼š
â€¢ å¤„ç†é‡å¤IDçš„æƒ…å†µ
â€¢ å¤„ç†å“åº”ä¸¢å¤±çš„æƒ…å†µ
â€¢ å¤„ç†æœåŠ¡ç«¯å¼‚å¸¸çš„æƒ…å†µ
```

---

## 5. ğŸ“« Reply Toé˜Ÿåˆ—è®¾è®¡


### 5.1 Reply Toé˜Ÿåˆ—çš„æ¦‚å¿µ


**ğŸ“® Reply Toé˜Ÿåˆ—å°±åƒä½ çš„é‚®ç®±åœ°å€**ï¼š
å½“ä½ ç»™æœ‹å‹å†™ä¿¡æ—¶ï¼Œä¿¡å°ä¸Šä¸ä»…è¦å†™æœ‹å‹çš„åœ°å€ï¼ˆè¯·æ±‚é˜Ÿåˆ—ï¼‰ï¼Œè¿˜è¦å†™ä½ è‡ªå·±çš„åœ°å€ï¼ˆReply Toé˜Ÿåˆ—ï¼‰ï¼Œè¿™æ ·æœ‹å‹æ‰çŸ¥é“å›ä¿¡å¯„åˆ°å“ªé‡Œã€‚

```
Reply Toé˜Ÿåˆ—çš„ä½œç”¨ï¼š
è¯·æ±‚æ¶ˆæ¯ â†’ [è¯·æ±‚å†…å®¹ + "è¯·å›å¤åˆ°Queue_A"] â†’ æœåŠ¡ç«¯
æœåŠ¡ç«¯   â†’ [å“åº”å†…å®¹] â†’ Queue_A â†’ å®¢æˆ·ç«¯

æµç¨‹å›¾ï¼š
å®¢æˆ·ç«¯åˆ›å»ºä¸´æ—¶é˜Ÿåˆ— â†’ åœ¨è¯·æ±‚ä¸­æŒ‡å®šreply_to â†’ æœåŠ¡ç«¯æ”¶åˆ°è¯·æ±‚
         â†‘                                      â†“
å®¢æˆ·ç«¯ç›‘å¬ä¸´æ—¶é˜Ÿåˆ— â† æœåŠ¡ç«¯å‘é€å“åº”åˆ°reply_toé˜Ÿåˆ—
```

### 5.2 é˜Ÿåˆ—åˆ›å»ºç­–ç•¥


**ğŸ—ï¸ ä¸åŒçš„é˜Ÿåˆ—åˆ›å»ºæ–¹å¼**ï¼š

**ç­–ç•¥ä¸€ï¼šæ¯ä¸ªè¯·æ±‚åˆ›å»ºä¸´æ—¶é˜Ÿåˆ—**
```python
def create_temp_queue_per_request():
    """ä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºä¸´æ—¶é˜Ÿåˆ—"""
    # åˆ›å»ºä¸´æ—¶é˜Ÿåˆ—ï¼ˆæœåŠ¡å™¨è‡ªåŠ¨å‘½åï¼‰
    result = channel.queue_declare(queue='', exclusive=True)
    callback_queue = result.method.queue
    
    return callback_queue

ä¼˜ç‚¹ï¼š
âœ… å®Œå…¨éš”ç¦»ï¼Œæ— ä¸²æ‰°é£é™©
âœ… è‡ªåŠ¨æ¸…ç†ï¼Œæ— å†…å­˜æ³„æ¼

ç¼ºç‚¹ï¼š
âŒ åˆ›å»ºå¼€é”€å¤§
âŒ å¤§é‡å¹¶å‘æ—¶æ€§èƒ½å·®
```

**ç­–ç•¥äºŒï¼šæ¯ä¸ªå®¢æˆ·ç«¯ä¸€ä¸ªæŒä¹…é˜Ÿåˆ—**
```python
class RPCClient:
    def __init__(self, client_id):
        self.client_id = client_id
        # åˆ›å»ºä¸“å±å›è°ƒé˜Ÿåˆ—
        self.callback_queue = f"rpc_callback_{client_id}"
        self.channel.queue_declare(
            queue=self.callback_queue,
            durable=True,  # æŒä¹…åŒ–
            exclusive=False
        )

ä¼˜ç‚¹ï¼š
âœ… é‡ç”¨é˜Ÿåˆ—ï¼Œæ€§èƒ½å¥½
âœ… å¯ä»¥æŒä¹…åŒ–

ç¼ºç‚¹ï¼š
âŒ éœ€è¦ç®¡ç†é˜Ÿåˆ—ç”Ÿå‘½å‘¨æœŸ
âŒ éœ€è¦å¤„ç†æ¶ˆæ¯åˆ†å‘
```

**ç­–ç•¥ä¸‰ï¼šå…±äº«å›è°ƒé˜Ÿåˆ—æ± **
```python
class SharedCallbackPool:
    def __init__(self, pool_size=10):
        self.pool_size = pool_size
        self.queues = []
        self.current_index = 0
        
        # åˆ›å»ºé˜Ÿåˆ—æ± 
        for i in range(pool_size):
            queue_name = f"rpc_callback_pool_{i}"
            self.channel.queue_declare(queue=queue_name, durable=True)
            self.queues.append(queue_name)
    
    def get_callback_queue(self):
        """è½®è¯¢è·å–å›è°ƒé˜Ÿåˆ—"""
        queue = self.queues[self.current_index]
        self.current_index = (self.current_index + 1) % self.pool_size
        return queue
```

### 5.3 é˜Ÿåˆ—å‘½åè§„èŒƒ


**ğŸ“ åˆç†çš„å‘½åç­–ç•¥**ï¼š
```
å‘½ååŸåˆ™ï¼š
â€¢ ä¸šåŠ¡ç›¸å…³ï¼šä½“ç°ä¸šåŠ¡å«ä¹‰
â€¢ ç¯å¢ƒåŒºåˆ†ï¼šåŒºåˆ†å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒ
â€¢ ç‰ˆæœ¬æ§åˆ¶ï¼šæ”¯æŒç‰ˆæœ¬å‡çº§
â€¢ æ˜“äºè¯†åˆ«ï¼šç®¡ç†å‘˜èƒ½å¿«é€Ÿç†è§£

å‘½åç¤ºä¾‹ï¼š
rpc_callback_userservice_v1_prod     # ç”Ÿäº§ç¯å¢ƒç”¨æˆ·æœåŠ¡å›è°ƒé˜Ÿåˆ—
rpc_callback_orderservice_v2_test    # æµ‹è¯•ç¯å¢ƒè®¢å•æœåŠ¡å›è°ƒé˜Ÿåˆ—
rpc_temp_callback_session_abc123     # ä¼šè¯çº§ä¸´æ—¶å›è°ƒé˜Ÿåˆ—

é¿å…çš„å‘½åï¼š
â€¢ è¿‡äºç®€å•ï¼šqueue1, q2, callback
â€¢ åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼šcallback_user123_password
â€¢ è¿‡é•¿éš¾è¯»ï¼švery_long_queue_name_that_is_hard_to_read
```

### 5.4 é˜Ÿåˆ—å±æ€§é…ç½®


**âš™ï¸ å…³é”®é…ç½®å‚æ•°**ï¼š
```python
def create_optimized_callback_queue():
    """åˆ›å»ºä¼˜åŒ–çš„å›è°ƒé˜Ÿåˆ—"""
    return channel.queue_declare(
        queue='',                    # ç©ºå­—ç¬¦ä¸²è®©æœåŠ¡å™¨è‡ªåŠ¨å‘½å
        durable=False,              # éæŒä¹…åŒ–ï¼ˆæé«˜æ€§èƒ½ï¼‰
        exclusive=True,             # ç‹¬å é˜Ÿåˆ—ï¼ˆè¿æ¥æ–­å¼€è‡ªåŠ¨åˆ é™¤ï¼‰
        auto_delete=True,           # è‡ªåŠ¨åˆ é™¤
        arguments={
            'x-max-length': 1000,           # æœ€å¤§æ¶ˆæ¯æ•°
            'x-message-ttl': 60000,         # æ¶ˆæ¯TTLï¼ˆ60ç§’ï¼‰
            'x-max-priority': 10,           # æ”¯æŒä¼˜å…ˆçº§
            'x-queue-mode': 'lazy'          # æ‡’åŠ è½½æ¨¡å¼ï¼ˆèŠ‚çœå†…å­˜ï¼‰
        }
    )

é…ç½®è¯´æ˜ï¼š
durable=False     # é‡å¯ä¸ä¿ç•™ï¼ˆå›è°ƒé˜Ÿåˆ—é€šå¸¸ä¸éœ€è¦æŒä¹…åŒ–ï¼‰
exclusive=True    # ç‹¬å ä½¿ç”¨ï¼ˆé¿å…å…¶ä»–è¿æ¥å¹²æ‰°ï¼‰
auto_delete=True  # è‡ªåŠ¨æ¸…ç†ï¼ˆè¿æ¥æ–­å¼€åè‡ªåŠ¨åˆ é™¤ï¼‰
```

---

## 6. ğŸ”„ å›è°ƒé˜Ÿåˆ—æ¶æ„è®¾è®¡


### 6.1 å›è°ƒå¤„ç†æ¶æ„æ¨¡å¼


**ğŸ—ï¸ æ¶æ„è®¾è®¡é€‰æ‹©**ï¼š

**æ¨¡å¼ä¸€ï¼šå•çº¿ç¨‹è½®è¯¢æ¨¡å¼**
```
æ¶æ„å›¾ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ä¸»çº¿ç¨‹        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚å‘é€è¯·æ±‚   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚è½®è¯¢å“åº”   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚å¤„ç†å›è°ƒ   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹ç‚¹ï¼š
âœ… å®ç°ç®€å•
âœ… æ— å¹¶å‘é—®é¢˜
âŒ æ€§èƒ½æœ‰é™
âŒ é˜»å¡ç­‰å¾…
```

**æ¨¡å¼äºŒï¼šäº‹ä»¶é©±åŠ¨æ¨¡å¼**
```
æ¶æ„å›¾ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è¯·æ±‚çº¿ç¨‹      â”‚    â”‚   å“åº”çº¿ç¨‹      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚å‘é€è¯·æ±‚   â”‚  â”‚    â”‚  â”‚ç›‘å¬é˜Ÿåˆ—   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ç­‰å¾…äº‹ä»¶   â”‚  â”‚    â”‚  â”‚è§¦å‘å›è°ƒ   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                        â”‚
         â””â”€â”€â”€â”€ äº‹ä»¶é€šçŸ¥æœºåˆ¶ â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹ç‚¹ï¼š
âœ… é«˜å¹¶å‘æ”¯æŒ
âœ… å“åº”åŠæ—¶
âŒ å®ç°å¤æ‚
âŒ éœ€è¦çº¿ç¨‹åŒæ­¥
```

### 6.2 å›è°ƒå‡½æ•°è®¾è®¡


**ğŸ“‹ å›è°ƒå‡½æ•°çš„å®ç°æ¨¡å¼**ï¼š
```python
class RPCCallback:
    def __init__(self):
        # å­˜å‚¨å›è°ƒå‡½æ•°
        self.callbacks = {}
        
    def register_callback(self, correlation_id, success_callback, 
                         error_callback=None, timeout_callback=None):
        """æ³¨å†Œå›è°ƒå‡½æ•°"""
        self.callbacks[correlation_id] = {
            'success': success_callback,
            'error': error_callback,
            'timeout': timeout_callback,
            'timestamp': time.time()
        }
    
    def invoke_callback(self, correlation_id, result=None, error=None):
        """è°ƒç”¨å›è°ƒå‡½æ•°"""
        if correlation_id not in self.callbacks:
            print(f"æœªæ‰¾åˆ°å›è°ƒå‡½æ•°: {correlation_id}")
            return
            
        callback_info = self.callbacks.pop(correlation_id)
        
        try:
            if error:
                if callback_info['error']:
                    callback_info['error'](error)
                else:
                    print(f"RPCè°ƒç”¨å‡ºé”™: {error}")
            else:
                if callback_info['success']:
                    callback_info['success'](result)
        except Exception as e:
            print(f"å›è°ƒå‡½æ•°æ‰§è¡Œå‡ºé”™: {e}")
```

### 6.3 å¼‚æ­¥å›è°ƒå¤„ç†


**âš¡ å¼‚æ­¥å¤„ç†æå‡æ€§èƒ½**ï¼š
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncRPCClient:
    def __init__(self):
        self.pending_requests = {}
        self.executor = ThreadPoolExecutor(max_workers=10)
        
    async def call_async(self, message):
        """å¼‚æ­¥RPCè°ƒç”¨"""
        correlation_id = str(uuid.uuid4())
        
        # åˆ›å»ºFutureå¯¹è±¡
        future = asyncio.get_event_loop().create_future()
        self.pending_requests[correlation_id] = future
        
        # å‘é€è¯·æ±‚
        await self.send_request_async(message, correlation_id)
        
        # ç­‰å¾…å“åº”
        return await future
    
    def handle_response(self, correlation_id, response_data):
        """å¤„ç†å“åº”ï¼ˆåœ¨å›è°ƒçº¿ç¨‹ä¸­è°ƒç”¨ï¼‰"""
        if correlation_id in self.pending_requests:
            future = self.pending_requests.pop(correlation_id)
            
            # åœ¨äº‹ä»¶å¾ªç¯ä¸­è®¾ç½®ç»“æœ
            asyncio.get_event_loop().call_soon_threadsafe(
                future.set_result, response_data
            )

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    client = AsyncRPCClient()
    
    # å¹¶å‘å‘é€å¤šä¸ªè¯·æ±‚
    tasks = [
        client.call_async(f"request_{i}")
        for i in range(10)
    ]
    
    # ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
    results = await asyncio.gather(*tasks)
    print(f"æ”¶åˆ° {len(results)} ä¸ªå“åº”")
```

### 6.4 å›è°ƒé˜Ÿåˆ—ç›‘æ§


**ğŸ“Š ç›‘æ§å’Œç®¡ç†å›è°ƒé˜Ÿåˆ—**ï¼š
```python
class CallbackQueueMonitor:
    def __init__(self):
        self.metrics = {
            'total_requests': 0,
            'pending_requests': 0,
            'completed_requests': 0,
            'timeout_requests': 0,
            'error_requests': 0
        }
        
    def record_request(self, correlation_id):
        """è®°å½•æ–°è¯·æ±‚"""
        self.metrics['total_requests'] += 1
        self.metrics['pending_requests'] += 1
        
    def record_response(self, correlation_id, success=True):
        """è®°å½•å“åº”"""
        self.metrics['pending_requests'] -= 1
        if success:
            self.metrics['completed_requests'] += 1
        else:
            self.metrics['error_requests'] += 1
            
    def record_timeout(self, correlation_id):
        """è®°å½•è¶…æ—¶"""
        self.metrics['pending_requests'] -= 1
        self.metrics['timeout_requests'] += 1
        
    def get_statistics(self):
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'success_rate': self.metrics['completed_requests'] / 
                           max(1, self.metrics['total_requests']),
            'timeout_rate': self.metrics['timeout_requests'] / 
                           max(1, self.metrics['total_requests']),
            'pending_count': self.metrics['pending_requests']
        }
```

---

## 7. â±ï¸ è¶…æ—¶ä¸é”™è¯¯å¤„ç†ç­–ç•¥


### 7.1 è¶…æ—¶å¤„ç†çš„é‡è¦æ€§


**ğŸš¨ ä¸ºä»€ä¹ˆéœ€è¦è¶…æ—¶å¤„ç†**ï¼š
æƒ³è±¡ä½ æ‰“ç”µè¯ç»™æœ‹å‹ï¼Œå¦‚æœæœ‹å‹ä¸€ç›´ä¸æ¥ï¼Œä½ ä¸èƒ½æ°¸è¿œç­‰ä¸‹å»ã€‚RPCè°ƒç”¨ä¹Ÿä¸€æ ·ï¼Œæ²¡æœ‰è¶…æ—¶å¤„ç†å°±å¯èƒ½æ°¸è¿œå¡ä½ã€‚

```
è¶…æ—¶åœºæ™¯åˆ†æï¼š
1. ç½‘ç»œæ•…éšœ â†’ è¯·æ±‚æ— æ³•åˆ°è¾¾æœåŠ¡ç«¯
2. æœåŠ¡ç«¯å®•æœº â†’ è¯·æ±‚åˆ°è¾¾ä½†æ— æ³•å¤„ç†
3. å¤„ç†ç¼“æ…¢ â†’ æœåŠ¡ç«¯å¤„ç†æ—¶é—´è¿‡é•¿
4. å“åº”ä¸¢å¤± â†’ å¤„ç†å®Œæˆä½†å“åº”æœªåˆ°è¾¾

æ²¡æœ‰è¶…æ—¶çš„åæœï¼š
âŒ å®¢æˆ·ç«¯æ°¸è¿œç­‰å¾…
âŒ èµ„æºæ— æ³•é‡Šæ”¾
âŒ ç³»ç»Ÿå“åº”èƒ½åŠ›ä¸‹é™
âŒ ç”¨æˆ·ä½“éªŒæå·®
```

### 7.2 è¶…æ—¶æœºåˆ¶å®ç°


**â° å¤šå±‚æ¬¡çš„è¶…æ—¶è®¾è®¡**ï¼š
```python
import time
import threading
from enum import Enum

class TimeoutType(Enum):
    NETWORK = "network"      # ç½‘ç»œè¶…æ—¶
    PROCESSING = "processing" # å¤„ç†è¶…æ—¶
    TOTAL = "total"          # æ€»è¶…æ—¶

class TimeoutManager:
    def __init__(self):
        self.timers = {}
        self.lock = threading.Lock()
        
    def start_timeout(self, correlation_id, timeout_seconds, 
                     timeout_type, callback):
        """å¯åŠ¨è¶…æ—¶è®¡æ—¶å™¨"""
        def timeout_handler():
            with self.lock:
                if correlation_id in self.timers:
                    del self.timers[correlation_id]
                    callback(correlation_id, timeout_type)
        
        timer = threading.Timer(timeout_seconds, timeout_handler)
        
        with self.lock:
            self.timers[correlation_id] = timer
            
        timer.start()
        
    def cancel_timeout(self, correlation_id):
        """å–æ¶ˆè¶…æ—¶è®¡æ—¶å™¨"""
        with self.lock:
            if correlation_id in self.timers:
                timer = self.timers.pop(correlation_id)
                timer.cancel()
                return True
        return False

# ä½¿ç”¨ç¤ºä¾‹
class RPCClientWithTimeout:
    def __init__(self):
        self.timeout_manager = TimeoutManager()
        self.pending_requests = {}
        
    def call_with_timeout(self, message, timeout=30):
        correlation_id = str(uuid.uuid4())
        
        # åˆ›å»ºç­‰å¾…äº‹ä»¶
        event = threading.Event()
        self.pending_requests[correlation_id] = {
            'event': event,
            'result': None,
            'error': None
        }
        
        # å¯åŠ¨è¶…æ—¶è®¡æ—¶å™¨
        self.timeout_manager.start_timeout(
            correlation_id, timeout, TimeoutType.TOTAL,
            self._handle_timeout
        )
        
        # å‘é€è¯·æ±‚
        self.send_request(message, correlation_id)
        
        # ç­‰å¾…å“åº”æˆ–è¶…æ—¶
        if event.wait(timeout):
            # æ”¶åˆ°å“åº”
            self.timeout_manager.cancel_timeout(correlation_id)
            request_info = self.pending_requests.pop(correlation_id)
            
            if request_info['error']:
                raise Exception(request_info['error'])
            return request_info['result']
        else:
            # è¶…æ—¶
            raise TimeoutError(f"RPCè°ƒç”¨è¶…æ—¶: {timeout}ç§’")
    
    def _handle_timeout(self, correlation_id, timeout_type):
        """å¤„ç†è¶…æ—¶"""
        if correlation_id in self.pending_requests:
            request_info = self.pending_requests[correlation_id]
            request_info['error'] = f"è¯·æ±‚è¶…æ—¶: {timeout_type.value}"
            request_info['event'].set()
```

### 7.3 é”™è¯¯åˆ†ç±»ä¸å¤„ç†


**ğŸš¨ é”™è¯¯ç±»å‹åˆ†æ**ï¼š
```
RPCè°ƒç”¨å¯èƒ½çš„é”™è¯¯ç±»å‹ï¼š

ç½‘ç»œå±‚é”™è¯¯ï¼š
â€¢ è¿æ¥å¤±è´¥ â†’ æœåŠ¡ä¸å¯è¾¾
â€¢ å‘é€å¤±è´¥ â†’ ç½‘ç»œä¸­æ–­
â€¢ æ¥æ”¶å¤±è´¥ â†’ è¿æ¥æ–­å¼€

åè®®å±‚é”™è¯¯ï¼š
â€¢ æ¶ˆæ¯æ ¼å¼é”™è¯¯ â†’ åºåˆ—åŒ–é—®é¢˜
â€¢ é˜Ÿåˆ—ä¸å­˜åœ¨ â†’ é…ç½®é”™è¯¯
â€¢ æƒé™ä¸è¶³ â†’ è®¤è¯å¤±è´¥

åº”ç”¨å±‚é”™è¯¯ï¼š
â€¢ ä¸šåŠ¡é€»è¾‘é”™è¯¯ â†’ å‚æ•°éæ³•
â€¢ æœåŠ¡å†…éƒ¨é”™è¯¯ â†’ ä»£ç å¼‚å¸¸
â€¢ èµ„æºä¸è¶³ â†’ å†…å­˜/CPUä¸å¤Ÿ
```

**ğŸ› ï¸ é”™è¯¯å¤„ç†ç­–ç•¥**ï¼š
```python
class RPCErrorHandler:
    def __init__(self):
        self.error_stats = {}
        
    def handle_error(self, correlation_id, error_type, error_message):
        """ç»Ÿä¸€é”™è¯¯å¤„ç†"""
        
        # è®°å½•é”™è¯¯ç»Ÿè®¡
        if error_type not in self.error_stats:
            self.error_stats[error_type] = 0
        self.error_stats[error_type] += 1
        
        # æ ¹æ®é”™è¯¯ç±»å‹å†³å®šå¤„ç†ç­–ç•¥
        if error_type == "timeout":
            return self._handle_timeout_error(correlation_id, error_message)
        elif error_type == "network":
            return self._handle_network_error(correlation_id, error_message)
        elif error_type == "business":
            return self._handle_business_error(correlation_id, error_message)
        else:
            return self._handle_unknown_error(correlation_id, error_message)
    
    def _handle_timeout_error(self, correlation_id, error_message):
        """å¤„ç†è¶…æ—¶é”™è¯¯"""
        print(f"è¯·æ±‚è¶…æ—¶: {correlation_id} - {error_message}")
        # å¯ä»¥å®ç°é‡è¯•é€»è¾‘
        return "RETRY"
    
    def _handle_network_error(self, correlation_id, error_message):
        """å¤„ç†ç½‘ç»œé”™è¯¯"""
        print(f"ç½‘ç»œé”™è¯¯: {correlation_id} - {error_message}")
        # å¯ä»¥å°è¯•é‡æ–°è¿æ¥
        return "RECONNECT"
    
    def _handle_business_error(self, correlation_id, error_message):
        """å¤„ç†ä¸šåŠ¡é”™è¯¯"""
        print(f"ä¸šåŠ¡é”™è¯¯: {correlation_id} - {error_message}")
        # ä¸šåŠ¡é”™è¯¯é€šå¸¸ä¸é‡è¯•
        return "FAIL"
```

### 7.4 é‡è¯•æœºåˆ¶è®¾è®¡


**ğŸ”„ æ™ºèƒ½é‡è¯•ç­–ç•¥**ï¼š
```python
import random
import time

class RetryStrategy:
    def __init__(self, max_retries=3, base_delay=1.0, max_delay=60.0):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay
        
    def should_retry(self, attempt, error_type):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•"""
        if attempt >= self.max_retries:
            return False
            
        # æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¯•
        retry_able_errors = ["timeout", "network", "server_error"]
        return error_type in retry_able_errors
    
    def get_delay(self, attempt):
        """è®¡ç®—é‡è¯•å»¶è¿Ÿï¼ˆæŒ‡æ•°é€€é¿ + éšæœºæŠ–åŠ¨ï¼‰"""
        delay = self.base_delay * (2 ** attempt)
        delay = min(delay, self.max_delay)
        
        # æ·»åŠ éšæœºæŠ–åŠ¨ï¼Œé¿å…é›·ç¾¤æ•ˆåº”
        jitter = delay * 0.1 * random.random()
        return delay + jitter

class RPCClientWithRetry:
    def __init__(self):
        self.retry_strategy = RetryStrategy()
        
    def call_with_retry(self, message):
        """å¸¦é‡è¯•çš„RPCè°ƒç”¨"""
        attempt = 0
        last_error = None
        
        while attempt <= self.retry_strategy.max_retries:
            try:
                return self.call(message)
                
            except Exception as e:
                last_error = e
                error_type = self._classify_error(e)
                
                if self.retry_strategy.should_retry(attempt, error_type):
                    delay = self.retry_strategy.get_delay(attempt)
                    print(f"è¯·æ±‚å¤±è´¥ï¼Œ{delay:.2f}ç§’åé‡è¯• (å°è¯• {attempt + 1}/{self.retry_strategy.max_retries})")
                    time.sleep(delay)
                    attempt += 1
                else:
                    raise e
        
        # é‡è¯•æ¬¡æ•°ç”¨å®Œï¼ŒæŠ›å‡ºæœ€åçš„é”™è¯¯
        raise last_error
    
    def _classify_error(self, error):
        """é”™è¯¯åˆ†ç±»"""
        if isinstance(error, TimeoutError):
            return "timeout"
        elif "connection" in str(error).lower():
            return "network"
        elif "server" in str(error).lower():
            return "server_error"
        else:
            return "unknown"
```

---

## 8. ğŸš€ å®è·µåº”ç”¨ä¸æ€§èƒ½ä¼˜åŒ–


### 8.1 è¿æ¥æ± ä¼˜åŒ–


**ğŸŠ è¿æ¥æ± æå‡æ€§èƒ½**ï¼š
é¢‘ç¹åˆ›å»ºå’Œé”€æ¯è¿æ¥å°±åƒæ¯æ¬¡ç”¨æ°´éƒ½è¦æŒ–äº•ä¸€æ ·æµªè´¹ï¼Œè¿æ¥æ± å°±æ˜¯æå‰å‡†å¤‡å¥½çš„"æ°´äº•ç¾¤"ã€‚

```python
import queue
import threading
from contextlib import contextmanager

class RabbitMQConnectionPool:
    def __init__(self, connection_params, pool_size=10):
        self.connection_params = connection_params
        self.pool_size = pool_size
        self.pool = queue.Queue(maxsize=pool_size)
        self.lock = threading.Lock()
        
        # åˆå§‹åŒ–è¿æ¥æ± 
        self._initialize_pool()
        
    def _initialize_pool(self):
        """åˆå§‹åŒ–è¿æ¥æ± """
        for _ in range(self.pool_size):
            conn = pika.BlockingConnection(self.connection_params)
            self.pool.put(conn)
    
    @contextmanager
    def get_connection(self):
        """è·å–è¿æ¥ï¼ˆä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼‰"""
        connection = None
        try:
            # ä»æ± ä¸­è·å–è¿æ¥
            connection = self.pool.get(timeout=30)
            yield connection
        finally:
            # å½’è¿˜è¿æ¥åˆ°æ± ä¸­
            if connection and not connection.is_closed:
                self.pool.put(connection)
            else:
                # è¿æ¥å·²æ–­å¼€ï¼Œåˆ›å»ºæ–°è¿æ¥
                new_conn = pika.BlockingConnection(self.connection_params)
                self.pool.put(new_conn)

# ä½¿ç”¨ç¤ºä¾‹
class OptimizedRPCClient:
    def __init__(self, connection_pool):
        self.connection_pool = connection_pool
        
    def call(self, message):
        with self.connection_pool.get_connection() as conn:
            channel = conn.channel()
            # æ‰§è¡ŒRPCè°ƒç”¨
            return self._do_rpc_call(channel, message)
```

### 8.2 æ‰¹é‡å¤„ç†ä¼˜åŒ–


**ğŸ“¦ æ‰¹é‡å¤„ç†æå‡ååé‡**ï¼š
```python
class BatchRPCClient:
    def __init__(self, batch_size=10, batch_timeout=1.0):
        self.batch_size = batch_size
        self.batch_timeout = batch_timeout
        self.pending_batch = []
        self.batch_lock = threading.Lock()
        
        # å¯åŠ¨æ‰¹å¤„ç†å®šæ—¶å™¨
        self._start_batch_timer()
        
    def call_batch(self, message):
        """æ·»åŠ åˆ°æ‰¹å¤„ç†é˜Ÿåˆ—"""
        future = threading.Event()
        
        with self.batch_lock:
            self.pending_batch.append({
                'message': message,
                'future': future,
                'result': None
            })
            
            # æ‰¹æ¬¡æ»¡äº†ï¼Œç«‹å³å¤„ç†
            if len(self.pending_batch) >= self.batch_size:
                self._process_batch()
        
        # ç­‰å¾…å¤„ç†ç»“æœ
        future.wait()
        return self._get_result_for_message(message)
    
    def _process_batch(self):
        """å¤„ç†ä¸€æ‰¹è¯·æ±‚"""
        if not self.pending_batch:
            return
            
        batch = self.pending_batch.copy()
        self.pending_batch.clear()
        
        # å‘é€æ‰¹é‡è¯·æ±‚
        batch_request = {
            'requests': [item['message'] for item in batch],
            'batch_id': str(uuid.uuid4())
        }
        
        # å‘é€åˆ°æ”¯æŒæ‰¹å¤„ç†çš„æœåŠ¡ç«¯
        response = self._send_batch_request(batch_request)
        
        # åˆ†å‘ç»“æœç»™å„ä¸ªç­‰å¾…è€…
        for i, item in enumerate(batch):
            item['result'] = response['results'][i]
            item['future'].set()
```

### 8.3 ç¼“å­˜ç­–ç•¥


**ğŸ’¾ ç¼“å­˜å‡å°‘é‡å¤è°ƒç”¨**ï¼š
```python
import time
from functools import wraps

class RPCCache:
    def __init__(self, default_ttl=300):  # 5åˆ†é’Ÿé»˜è®¤TTL
        self.cache = {}
        self.cache_times = {}
        self.default_ttl = default_ttl
        self.lock = threading.Lock()
        
    def get(self, key):
        """è·å–ç¼“å­˜"""
        with self.lock:
            if key in self.cache:
                # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
                if time.time() - self.cache_times[key] < self.default_ttl:
                    return self.cache[key]
                else:
                    # è¿‡æœŸï¼Œåˆ é™¤ç¼“å­˜
                    del self.cache[key]
                    del self.cache_times[key]
            return None
    
    def set(self, key, value):
        """è®¾ç½®ç¼“å­˜"""
        with self.lock:
            self.cache[key] = value
            self.cache_times[key] = time.time()

def rpc_cache(ttl=300):
    """RPCè°ƒç”¨ç¼“å­˜è£…é¥°å™¨"""
    def decorator(func):
        cache = RPCCache(ttl)
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            # ç”Ÿæˆç¼“å­˜é”®
            cache_key = f"{func.__name__}_{hash(str(args) + str(kwargs))}"
            
            # å°è¯•ä»ç¼“å­˜è·å–
            cached_result = cache.get(cache_key)
            if cached_result is not None:
                return cached_result
            
            # ç¼“å­˜æœªå‘½ä¸­ï¼Œæ‰§è¡Œå®é™…è°ƒç”¨
            result = func(*args, **kwargs)
            
            # ç¼“å­˜ç»“æœ
            cache.set(cache_key, result)
            return result
            
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
class CachedRPCClient:
    @rpc_cache(ttl=600)  # ç¼“å­˜10åˆ†é’Ÿ
    def get_user_info(self, user_id):
        """è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆä¼šè¢«ç¼“å­˜ï¼‰"""
        return self.call(f"get_user_{user_id}")
```

### 8.4 æ€§èƒ½ç›‘æ§


**ğŸ“Š å…³é”®æ€§èƒ½æŒ‡æ ‡ç›‘æ§**ï¼š
```python
import time
import statistics

class RPCPerformanceMonitor:
    def __init__(self):
        self.call_times = []
        self.success_count = 0
        self.error_count = 0
        self.timeout_count = 0
        self.start_time = time.time()
        
    def record_call_start(self, correlation_id):
        """è®°å½•è°ƒç”¨å¼€å§‹"""
        return time.time()
    
    def record_call_end(self, correlation_id, start_time, success=True):
        """è®°å½•è°ƒç”¨ç»“æŸ"""
        call_time = time.time() - start_time
        self.call_times.append(call_time)
        
        if success:
            self.success_count += 1
        else:
            self.error_count += 1
    
    def record_timeout(self, correlation_id):
        """è®°å½•è¶…æ—¶"""
        self.timeout_count += 1
    
    def get_statistics(self):
        """è·å–æ€§èƒ½ç»Ÿè®¡"""
        if not self.call_times:
            return {}
            
        total_calls = self.success_count + self.error_count + self.timeout_count
        uptime = time.time() - self.start_time
        
        return {
            'total_calls': total_calls,
            'success_rate': self.success_count / total_calls * 100,
            'error_rate': self.error_count / total_calls * 100,
            'timeout_rate': self.timeout_count / total_calls * 100,
            'avg_response_time': statistics.mean(self.call_times),
            'median_response_time': statistics.median(self.call_times),
            'p95_response_time': statistics.quantiles(self.call_times, n=20)[18],
            'calls_per_second': total_calls / uptime
        }
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ RPCæœ¬è´¨ï¼šå°†å¼‚æ­¥æ¶ˆæ¯ä¼ é€’åŒ…è£…æˆåŒæ­¥å‡½æ•°è°ƒç”¨
ğŸ”¸ Correlation IDï¼šè¯·æ±‚å“åº”åŒ¹é…çš„å”¯ä¸€æ ‡è¯†ç¬¦
ğŸ”¸ Reply Toé˜Ÿåˆ—ï¼šæŒ‡å®šå“åº”æ¶ˆæ¯çš„æ¥æ”¶ä½ç½®
ğŸ”¸ åŒæ­¥ç­‰å¾…ï¼šé€šè¿‡äº‹ä»¶æˆ–è½®è¯¢å®ç°é˜»å¡ç­‰å¾…
ğŸ”¸ è¶…æ—¶å¤„ç†ï¼šé˜²æ­¢æ— é™ç­‰å¾…çš„ä¿æŠ¤æœºåˆ¶
ğŸ”¸ é”™è¯¯å¤„ç†ï¼šåˆ†ç±»å¤„ç†ä¸åŒç±»å‹çš„å¼‚å¸¸æƒ…å†µ
ğŸ”¸ æ€§èƒ½ä¼˜åŒ–ï¼šè¿æ¥æ± ã€æ‰¹å¤„ç†ã€ç¼“å­˜ç­‰ä¼˜åŒ–æ‰‹æ®µ
```

### 9.2 å…³é”®å®ç°è¦ç‚¹


**ğŸ”¹ Correlation IDæœ€ä½³å®è·µ**ï¼š
```
ç”Ÿæˆç­–ç•¥ï¼š
â€¢ ä½¿ç”¨UUID4ä¿è¯å…¨å±€å”¯ä¸€æ€§
â€¢ åŒ…å«æ—¶é—´æˆ³ä¾¿äºè°ƒè¯•
â€¢ é¿å…è¿ç»­æˆ–å¯é¢„æµ‹çš„ID

ç®¡ç†ç­–ç•¥ï¼š
â€¢ åŠæ—¶æ¸…ç†è¿‡æœŸçš„ç­‰å¾…è¯·æ±‚
â€¢ è®¾ç½®åˆç†çš„æ˜ å°„è¡¨å¤§å°é™åˆ¶
â€¢ ç›‘æ§æœªåŒ¹é…çš„å“åº”æ¶ˆæ¯
```

**ğŸ”¹ é˜Ÿåˆ—è®¾è®¡åŸåˆ™**ï¼š
```
Reply Toé˜Ÿåˆ—é€‰æ‹©ï¼š
â€¢ ä¸´æ—¶é˜Ÿåˆ—ï¼šå®Œå…¨éš”ç¦»ï¼Œé€‚åˆå°‘é‡è°ƒç”¨
â€¢ æŒä¹…é˜Ÿåˆ—ï¼šé‡ç”¨é«˜æ•ˆï¼Œé€‚åˆé¢‘ç¹è°ƒç”¨
â€¢ é˜Ÿåˆ—æ± ï¼šå¹³è¡¡æ€§èƒ½å’Œèµ„æºä½¿ç”¨

å±æ€§é…ç½®ï¼š
â€¢ è®¾ç½®é€‚å½“çš„TTLé¿å…æ¶ˆæ¯å †ç§¯
â€¢ ä½¿ç”¨auto_deleteè‡ªåŠ¨æ¸…ç†
â€¢ é…ç½®åˆç†çš„é˜Ÿåˆ—é•¿åº¦é™åˆ¶
```

**ğŸ”¹ è¶…æ—¶ä¸é‡è¯•ç­–ç•¥**ï¼š
```
è¶…æ—¶è®¾ç½®ï¼š
â€¢ ç½‘ç»œè¶…æ—¶ï¼š5-10ç§’
â€¢ å¤„ç†è¶…æ—¶ï¼šæ ¹æ®ä¸šåŠ¡å¤æ‚åº¦è®¾å®š
â€¢ æ€»è¶…æ—¶ï¼šç•¥å¤§äºå¤„ç†è¶…æ—¶

é‡è¯•ç­–ç•¥ï¼š
â€¢ æŒ‡æ•°é€€é¿ï¼šé¿å…é›·ç¾¤æ•ˆåº”
â€¢ æœ€å¤§é‡è¯•æ¬¡æ•°ï¼š3-5æ¬¡
â€¢ é”™è¯¯åˆ†ç±»ï¼šåŒºåˆ†å¯é‡è¯•å’Œä¸å¯é‡è¯•é”™è¯¯
```

### 9.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ’¼ é€‚ç”¨åœºæ™¯**ï¼š
```
âœ… é€‚åˆRPCæ¨¡å¼çš„åœºæ™¯ï¼š
â€¢ éœ€è¦è¿”å›å€¼çš„è¿œç¨‹è°ƒç”¨
â€¢ å¯¹å“åº”æ—¶é—´æœ‰è¦æ±‚çš„æ“ä½œ
â€¢ ä¼ ç»ŸRPCè¿ç§»åˆ°æ¶ˆæ¯é˜Ÿåˆ—
â€¢ éœ€è¦è´Ÿè½½å‡è¡¡çš„æœåŠ¡è°ƒç”¨

âŒ ä¸é€‚åˆRPCæ¨¡å¼çš„åœºæ™¯ï¼š
â€¢ çº¯ç²¹çš„äº‹ä»¶é€šçŸ¥
â€¢ é«˜é¢‘ç‡çš„æ•°æ®æ¨é€
â€¢ ä¸éœ€è¦å“åº”çš„æ“ä½œ
â€¢ å¯¹å»¶è¿Ÿæå…¶æ•æ„Ÿçš„è°ƒç”¨
```

**ğŸ› ï¸ å®ç°å»ºè®®**ï¼š
```
å¼€å‘é˜¶æ®µï¼š
â€¢ å…ˆå®ç°åŸºæœ¬çš„RPCåŠŸèƒ½
â€¢ æ·»åŠ å®Œå–„çš„æ—¥å¿—è®°å½•
â€¢ å®ç°ç®€å•çš„è¶…æ—¶å¤„ç†
â€¢ ç¼–å†™å…¨é¢çš„æµ‹è¯•ç”¨ä¾‹

ç”Ÿäº§é˜¶æ®µï¼š
â€¢ æ·»åŠ æ€§èƒ½ç›‘æ§
â€¢ å®ç°é‡è¯•å’Œç†”æ–­æœºåˆ¶
â€¢ ä¼˜åŒ–è¿æ¥å’Œé˜Ÿåˆ—ç®¡ç†
â€¢ å»ºç«‹è¿ç»´ç›‘æ§ä½“ç³»
```

**ğŸ”§ å¸¸è§é—®é¢˜è§£å†³**ï¼š
```
å“åº”ä¸¢å¤±ï¼š
â€¢ æ£€æŸ¥Reply Toé˜Ÿåˆ—æ˜¯å¦æ­£ç¡®åˆ›å»º
â€¢ éªŒè¯Correlation IDæ˜¯å¦æ­£ç¡®ä¼ é€’
â€¢ ç¡®è®¤æœåŠ¡ç«¯æ˜¯å¦æ­£ç¡®å‘é€å“åº”

æ€§èƒ½é—®é¢˜ï¼š
â€¢ ä½¿ç”¨è¿æ¥æ± å‡å°‘è¿æ¥å¼€é”€
â€¢ å®ç°æ‰¹é‡å¤„ç†æé«˜ååé‡
â€¢ æ·»åŠ ç¼“å­˜å‡å°‘é‡å¤è°ƒç”¨
â€¢ ä¼˜åŒ–åºåˆ—åŒ–å’Œååºåˆ—åŒ–

è¶…æ—¶é¢‘ç¹ï¼š
â€¢ åˆ†ææœåŠ¡ç«¯å¤„ç†æ—¶é—´
â€¢ è°ƒæ•´è¶…æ—¶å‚æ•°è®¾ç½®
â€¢ æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿæƒ…å†µ
â€¢ è€ƒè™‘å¢åŠ æœåŠ¡ç«¯èµ„æº
```

### 9.4 å­¦ä¹ å»ºè®®


**ğŸ“š å­¦ä¹ è·¯å¾„**ï¼š
```
åŸºç¡€é˜¶æ®µï¼š
â€¢ ç†è§£RPCçš„åŸºæœ¬æ¦‚å¿µ
â€¢ æŒæ¡Correlation IDæœºåˆ¶
â€¢ å­¦ä¼šåˆ›å»ºå’Œä½¿ç”¨Reply Toé˜Ÿåˆ—
â€¢ å®ç°ç®€å•çš„åŒæ­¥è°ƒç”¨

è¿›é˜¶é˜¶æ®µï¼š
â€¢ æŒæ¡è¶…æ—¶å’Œé”™è¯¯å¤„ç†
â€¢ å­¦ä¹ æ€§èƒ½ä¼˜åŒ–æŠ€å·§
â€¢ ç†è§£å¹¶å‘å’Œçº¿ç¨‹å®‰å…¨
â€¢ å®ç°é‡è¯•å’Œç†”æ–­æœºåˆ¶

é«˜çº§é˜¶æ®µï¼š
â€¢ è®¾è®¡å¤æ‚çš„RPCæ¡†æ¶
â€¢ å®ç°åˆ†å¸ƒå¼è°ƒç”¨è¿½è¸ª
â€¢ ä¼˜åŒ–æ€§èƒ½å’Œå¯é æ€§
â€¢ æ„å»ºå®Œæ•´çš„è¿ç»´ä½“ç³»
```

**ğŸ§  è®°å¿†è¦ç‚¹**ï¼š
- RPCæ˜¯åŒæ­¥å¤–è¡£ä¸‹çš„å¼‚æ­¥å®ç°
- Correlation IDæ˜¯è¯·æ±‚å“åº”åŒ¹é…çš„å…³é”®
- Reply Toé˜Ÿåˆ—è¦æ ¹æ®ä½¿ç”¨åœºæ™¯åˆç†é€‰æ‹©
- è¶…æ—¶å¤„ç†æ˜¯é¿å…ç³»ç»Ÿå¡æ­»çš„å¿…è¦ä¿æŠ¤
- æ€§èƒ½ä¼˜åŒ–è¦ä»è¿æ¥ã€æ‰¹å¤„ç†ã€ç¼“å­˜å¤šæ–¹é¢å…¥æ‰‹

**æ ¸å¿ƒç†å¿µ**ï¼šRabbitMQçš„RPCæ¨¡å¼è™½ç„¶å¢åŠ äº†å¤æ‚æ€§ï¼Œä½†æä¾›äº†ä¼ ç»ŸRPCæ‰€æ²¡æœ‰çš„å¯é æ€§ã€è´Ÿè½½å‡è¡¡å’Œå¯æ‰©å±•æ€§ã€‚ç†è§£å…¶å®ç°åŸç†ï¼Œæ‰èƒ½åœ¨å®é™…é¡¹ç›®ä¸­ç”¨å¥½è¿™ä¸ªå¼ºå¤§çš„å·¥å…·ï¼