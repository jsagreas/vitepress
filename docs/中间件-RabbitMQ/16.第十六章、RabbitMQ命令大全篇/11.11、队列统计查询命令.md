---
title: 11、队列统计查询命令
---
## 📚 目录

1. [队列统计查询基础概念](#1-队列统计查询基础概念)
2. [消息状态相关统计](#2-消息状态相关统计)
3. [内存和存储统计](#3-内存和存储统计)
4. [性能监控统计](#4-性能监控统计)
5. [实用查询组合技巧](#5-实用查询组合技巧)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 队列统计查询基础概念


### 1.1 什么是队列统计信息


**💡 简单理解**：就像查看你的手机短信一样，队列统计告诉你：
- 📨 有多少条消息还没读（就绪消息）
- 📪 有多少条消息已读但还没删除（未确认消息）
- 📱 消息占了多少内存空间
- 👥 有多少人在看这些消息（消费者数量）

```
队列就像一个邮箱：
┌─────────────────────────┐
│  📬 RabbitMQ队列邮箱    │
├─────────────────────────┤
│ 📨 新邮件(就绪消息)      │
│ 📪 已读邮件(未确认消息)   │
│ 👥 订阅者(消费者)        │
│ 💾 邮箱大小(内存使用)    │
└─────────────────────────┘
```

### 1.2 为什么需要查看统计信息


**🎯 实际作用**：
- **🚨 发现问题**：消息堆积了吗？内存不够了吗？
- **📈 监控性能**：系统运行得怎么样？
- **🔧 优化调整**：需要增加消费者吗？需要清理队列吗？
- **📊 业务分析**：哪个队列最忙？哪个队列可能有问题？

---

## 2. 📨 消息状态相关统计


### 2.1 就绪消息数量查询


**🔸 基本命令**：
```bash
rabbitmqctl list_queues name messages_ready
```

**💭 通俗解释**：
- **就绪消息** = 已经到达队列，等待被消费的消息
- 就像快递到了菜鸟驿站，等你去取

```
队列状态示意：
生产者 → [📦📦📦] 就绪消息 → 消费者
              ↑
           这些就是 messages_ready
```

**📊 实际输出示例**：
```
Listing queues for vhost / ...
order_queue    25
user_queue     0
email_queue    150
```

> 💡 **解读技巧**：
> - `order_queue` 有25条待处理订单
> - `user_queue` 没有待处理用户消息
> - `email_queue` 有150封待发邮件（可能需要关注）

### 2.2 未确认消息数量查询


**🔸 基本命令**：
```bash
rabbitmqctl list_queues name messages_unacknowledged
```

**💭 通俗解释**：
- **未确认消息** = 消费者已接收但还没确认处理完成的消息
- 就像你签收了快递但还没拆开确认商品

```
消息处理流程：
队列 → 消费者接收 → 处理中 → 确认完成
              ↑         ↑
         投递给消费者   未确认状态
```

**⚠️ 重要说明**：
- 如果未确认消息很多，可能消费者处理太慢或出现了故障
- 未确认的消息会一直占用内存

### 2.3 消费者数量查询


**🔸 基本命令**：
```bash
rabbitmqctl list_queues name consumers
```

**💭 通俗解释**：
- 显示有多少个消费者在监听这个队列
- 就像有多少个工人在这个工作台前等活干

```
队列与消费者关系：
    📦 Queue
   /  |  \
  👤 👤 👤  ← 3个消费者
```

**📈 优化建议**：
- 消费者数量 = 0：没人处理消息，消息会堆积
- 消费者数量过多：可能浪费资源
- 合理数量：根据消息处理速度和业务需求调整

---

## 3. 💾 内存和存储统计


### 3.1 队列内存使用查询


**🔸 基本命令**：
```bash
rabbitmqctl list_queues name memory
```

**💭 通俗解释**：
- 显示这个队列占用了多少内存（单位：字节）
- 就像查看某个文件夹占用了多少硬盘空间

**📊 内存使用示例**：
```
Listing queues for vhost / ...
order_queue    1048576    # 约1MB
user_queue     102400     # 约100KB  
email_queue    10485760   # 约10MB
```

> 🔥 **重点关注**：
> - 内存使用突然增大 → 可能消息堆积
> - 某个队列内存过大 → 需要检查消费者是否正常

### 3.2 消息字节数统计


**🔸 基本命令**：
```bash
rabbitmqctl list_queues name message_bytes
```

**💭 通俗解释**：
- 显示队列中所有消息的总字节数
- 就像统计邮箱里所有邮件的总大小

**🔸 就绪消息字节数**：
```bash
rabbitmqctl list_queues name message_bytes_ready
```

**🔸 未确认消息字节数**：
```bash
rabbitmqctl list_queues name message_bytes_unacknowledged
```

**📊 字节数对比表**：

| 统计类型 | **含义** | **用途** |
|---------|---------|----------|
| `message_bytes` | 所有消息总字节数 | 了解队列总数据量 |
| `message_bytes_ready` | 等待处理消息字节数 | 了解待处理数据量 |
| `message_bytes_unacknowledged` | 处理中消息字节数 | 了解正在处理数据量 |

---

## 4. ⏰ 性能监控统计


### 4.1 消息时间戳查询


**🔸 基本命令**：
```bash
rabbitmqctl list_queues name head_message_timestamp
```

**💭 通俗解释**：
- 显示队列中第一条消息的时间戳
- 可以知道最老的消息等了多久

```
队列中的消息：
[📨2024-01-20 09:00] [📨2024-01-20 09:30] [📨2024-01-20 10:00]
      ↑
   head_message_timestamp
```

**🎯 实际应用**：
- 如果时间戳很久远，说明消息处理速度跟不上
- 可以用来监控消息延迟情况

### 4.2 磁盘读写统计


**🔸 磁盘读取次数**：
```bash
rabbitmqctl list_queues name disk_reads
```

**🔸 磁盘写入次数**：
```bash
rabbitmqctl list_queues name disk_writes
```

**💭 通俗解释**：
- **disk_reads**：从硬盘读取数据的次数
- **disk_writes**：向硬盘写入数据的次数

```
内存与磁盘交互：
   💾 内存队列
      ↕️ (读写)
   💿 磁盘存储
```

**📈 性能指标**：
- 读写次数过多 → 内存不足，频繁使用磁盘
- 读写次数很少 → 数据主要在内存中，性能较好

---

## 5. 🔧 实用查询组合技巧


### 5.1 多属性组合查询


**🎯 常用组合查询**：
```bash
# 查看队列基本状态
rabbitmqctl list_queues name messages_ready messages_unacknowledged consumers

# 查看队列内存使用情况  
rabbitmqctl list_queues name memory message_bytes

# 查看队列性能指标
rabbitmqctl list_queues name disk_reads disk_writes head_message_timestamp
```

**📊 组合查询输出示例**：
```
Listing queues for vhost / ...
order_queue     25    5     2     # 25就绪，5未确认，2消费者
user_queue      0     0     1     # 空队列，1个消费者待命
email_queue     150   10    0     # 150堆积，10处理中，无消费者！
```

### 5.2 问题排查技巧


**🚨 发现问题的信号**：

| 问题现象 | **可能原因** | **查询命令** |
|---------|-------------|-------------|
| 就绪消息很多 | 消费者不够或处理太慢 | `list_queues name messages_ready consumers` |
| 未确认消息很多 | 消费者处理异常 | `list_queues name messages_unacknowledged` |
| 内存使用过大 | 消息堆积严重 | `list_queues name memory message_bytes` |
| 磁盘读写频繁 | 内存不足 | `list_queues name disk_reads disk_writes` |

**💡 排查步骤**：
1. **第一步**：查看基本状态 `name messages_ready consumers`
2. **第二步**：如有异常，查看内存使用 `name memory`  
3. **第三步**：分析时间戳了解延迟 `name head_message_timestamp`
4. **第四步**：必要时查看磁盘IO `name disk_reads disk_writes`

### 5.3 监控脚本示例


**🔧 简单监控脚本思路**：
```bash
#!/bin/bash
# 检查队列健康状态

echo "=== 队列基本状态 ==="
rabbitmqctl list_queues name messages_ready consumers

echo -e "\n=== 内存使用情况 ==="  
rabbitmqctl list_queues name memory

echo -e "\n=== 可能的问题队列 ==="
# 这里可以加入更复杂的判断逻辑
```

---

## 6. 📋 核心要点总结


### 6.1 必知必会的统计命令


```
🔸 基础状态：list_queues name messages_ready consumers
🔸 消息统计：list_queues name messages_unacknowledged  
🔸 内存监控：list_queues name memory message_bytes
🔸 性能分析：list_queues name disk_reads disk_writes
🔸 延迟监控：list_queues name head_message_timestamp
```

### 6.2 关键理解要点


**🔹 消息状态的生命周期**：
```
生产 → 就绪(ready) → 投递 → 未确认(unacked) → 确认 → 完成
```

**🔹 内存使用的影响因素**：
- 消息数量多 → 内存使用大
- 单个消息大 → 字节数统计大  
- 消费速度慢 → 内存持续增长

**🔹 性能监控的重点指标**：
- 就绪消息数：反映处理能力是否跟上
- 消费者数量：反映处理资源是否足够
- 内存使用：反映系统负载情况
- 磁盘读写：反映内存是否充足

### 6.3 实际应用建议


**📈 日常监控重点**：
- ✅ 每天检查：`messages_ready` 和 `consumers`
- ✅ 每周检查：`memory` 和 `message_bytes`  
- ✅ 问题排查：`head_message_timestamp` 和磁盘IO

**🎯 优化策略**：
- 就绪消息堆积 → 增加消费者或优化处理逻辑
- 未确认消息过多 → 检查消费者健康状态
- 内存使用过大 → 考虑消息持久化或增加处理能力
- 磁盘IO频繁 → 增加内存或优化消息大小

**🔧 自动化监控**：
- 设置阈值告警（如就绪消息 > 1000）
- 定期生成统计报告
- 结合业务指标分析队列性能

**💡 新手记忆技巧**：
- **ready** = 准备好了，等处理
- **unacknowledged** = 收到了，未确认  
- **consumers** = 有几个工人在干活
- **memory** = 占了多少内存空间
- **timestamp** = 最老消息的生日