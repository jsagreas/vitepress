---
title: 5、集群监控命令
---
## 📚 目录

1. [集群监控命令概述](#1-集群监控命令概述)
2. [集群状态诊断命令](#2-集群状态诊断命令)
3. [队列健康检查命令](#3-队列健康检查命令)
4. [系统性能监控命令](#4-系统性能监控命令)
5. [故障排查辅助命令](#5-故障排查辅助命令)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 集群监控命令概述


### 1.1 什么是集群监控

**简单理解**：就像医生给病人做体检一样，集群监控就是给RabbitMQ"做体检"，看看它运行得健不健康。

```
单机 RabbitMQ：    集群 RabbitMQ：
     🐰               🐰--🐰--🐰
  一台服务器         多台服务器协同工作

监控目的：确保所有"小兔子"都在正常工作！
```

### 1.2 为什么需要监控

**🎯 监控的重要性**：
- **及时发现问题**：像体温计一样，提前发现"发烧"
- **预防系统崩溃**：防止小问题变成大故障
- **性能优化指导**：知道哪里跑得慢，需要优化
- **容量规划**：了解资源使用情况，提前扩容

### 1.3 监控命令分类

```
集群监控命令分类：

🔸 状态检查类：看集群是否正常
🔸 健康诊断类：深入检查具体问题
🔸 性能监控类：查看运行效率
🔸 故障排查类：定位问题根源
```

---

## 2. 🏥 集群状态诊断命令


### 2.1 集群整体状态检查


#### 🔸 rabbitmq-diagnostics cluster_status

**通俗解释**：这就像给整个集群拍个"全身照"，看看集群的整体健康状况。

```bash
# 基础用法 - 查看集群状态
rabbitmq-diagnostics cluster_status

# 指定节点查看
rabbitmq-diagnostics cluster_status -n rabbit@node1
```

**💡 命令输出解读**：
```
Cluster status of node rabbit@server1:
[{nodes,[{disc,[rabbit@server1,rabbit@server2]}]},
 {running_nodes,[rabbit@server1,rabbit@server2]},
 {cluster_name,<<"rabbit@server1">>},
 {partitions,[]}]

翻译成人话：
✅ disc: 磁盘节点（数据会保存到硬盘）
✅ running_nodes: 正在运行的节点
✅ cluster_name: 集群名称
✅ partitions: 网络分区（空表示没问题）
```

**🚨 常见状态解读**：
| 状态 | 含义 | 处理建议 |
|------|------|----------|
| `running_nodes` 完整 | 所有节点正常运行 | ✅ 一切正常 |
| `running_nodes` 不完整 | 有节点离线 | ⚠️ 检查离线节点 |
| `partitions` 非空 | 出现网络分区 | 🚨 需要立即处理 |

### 2.2 关键性检查命令


#### 🔸 rabbitmq-diagnostics check_if_node_is_mirror_sync_critical

**通俗解释**：检查镜像队列同步是否正常。镜像队列就像"数据备份"，这个命令检查备份是否同步。

```bash
# 检查当前节点的镜像同步状态
rabbitmq-diagnostics check_if_node_is_mirror_sync_critical

# 输出示例
node rabbit@server1 is not mirror sync critical
# 翻译：节点不处于镜像同步关键状态（这是好事）
```

**📖 什么是镜像同步关键状态**：
- **正常状态**：数据在多个节点间同步良好
- **关键状态**：同步出现问题，可能导致数据丢失
- **影响**：如果处于关键状态，节点故障可能丢失消息

#### 🔸 rabbitmq-diagnostics check_if_node_is_quorum_critical

**通俗解释**：检查仲裁队列是否正常。仲裁队列是RabbitMQ 3.8+的新特性，比镜像队列更可靠。

```bash
# 检查仲裁队列状态
rabbitmq-diagnostics check_if_node_is_quorum_critical

# 正常输出
node rabbit@server1 is not quorum critical
```

**🤔 仲裁队列 vs 镜像队列**：
```
镜像队列（旧版本）：        仲裁队列（新版本）：
     主节点                      选举机制
    /    \                    节点1 节点2 节点3
  备份1  备份2                 投票决定谁是leader

优势：更可靠，性能更好        缺点：需要RabbitMQ 3.8+
```

---

## 3. 📋 队列健康检查命令


### 3.1 无响应队列检测


#### 🔸 rabbitmq-diagnostics list_unresponsive_queues

**通俗解释**：找出那些"卡住"的队列，就像找出交通堵塞的路段。

```bash
# 列出无响应的队列
rabbitmq-diagnostics list_unresponsive_queues

# 设置超时时间（秒）
rabbitmq-diagnostics list_unresponsive_queues --timeout 30
```

**💡 什么情况下队列会无响应**：
- **消息积压严重**：队列里消息太多，处理不过来
- **消费者故障**：没有程序来取消息
- **网络问题**：节点间通信出现问题
- **资源不足**：内存或磁盘空间不够

**🔧 处理无响应队列**：
```bash
# 1. 先查看队列详情
rabbitmqctl list_queues name messages consumers

# 2. 检查消费者
rabbitmqctl list_consumers

# 3. 如果队列确实有问题，可以考虑清空
rabbitmqctl purge_queue queue_name
```

### 3.2 卡住进程检测


#### 🔸 rabbitmq-diagnostics maybe_stuck

**通俗解释**：检查是否有程序"卡死"了，就像检查是否有程序死循环。

```bash
# 检查可能卡住的进程
rabbitmq-diagnostics maybe_stuck

# 详细输出模式
rabbitmq-diagnostics maybe_stuck --verbose
```

**📊 进程卡住的常见原因**：
```
可能的卡住原因：

🔸 等待锁：进程在等待某个资源
🔸 无限循环：代码逻辑问题导致死循环  
🔸 网络阻塞：等待网络响应时间过长
🔸 磁盘IO慢：硬盘读写速度太慢
```

---

## 4. 📊 系统性能监控命令


### 4.1 系统信息查看


#### 🔸 rabbitmq-diagnostics erlang_version

**通俗解释**：查看RabbitMQ运行平台的版本信息，就像查看手机的操作系统版本。

```bash
# 查看Erlang版本
rabbitmq-diagnostics erlang_version

# 输出示例
25.0.4
```

**💡 为什么要关心Erlang版本**：
- **兼容性**：不同版本功能不同
- **性能**：新版本通常性能更好
- **安全性**：旧版本可能有安全漏洞
- **故障排查**：某些问题只在特定版本出现

#### 🔸 rabbitmq-diagnostics memory_breakdown

**通俗解释**：详细查看内存使用情况，就像查看手机存储空间的详细分布。

```bash
# 查看内存使用分解
rabbitmq-diagnostics memory_breakdown

# 指定节点查看
rabbitmq-diagnostics memory_breakdown -n rabbit@node1
```

**📈 内存使用分解说明**：
```
典型内存分布：

connection_readers: 15.5 MiB (13.82%)    ← 连接读取器
connection_writers: 2.1 MiB (1.87%)      ← 连接写入器  
connection_channels: 8.3 MiB (7.41%)     ← 通道内存
connection_other: 1.2 MiB (1.07%)        ← 其他连接相关
queue_procs: 45.6 MiB (40.71%)          ← 队列进程（最大头）
queue_slave_procs: 12.3 MiB (10.98%)    ← 队列备份进程
plugins: 5.4 MiB (4.82%)                ← 插件占用
other_proc: 15.8 MiB (14.11%)           ← 其他进程
mnesia: 3.2 MiB (2.86%)                 ← 数据库
msg_index: 1.8 MiB (1.61%)              ← 消息索引
other_ets: 0.9 MiB (0.80%)              ← 其他内存表
```

### 4.2 运行时统计


#### 🔸 rabbitmq-diagnostics runtime_thread_stats

**通俗解释**：查看系统线程使用情况，就像查看CPU使用率的详细分布。

```bash
# 查看运行时线程统计
rabbitmq-diagnostics runtime_thread_stats

# 输出示例解读
name                   | current | since_start
-----------------------+---------+------------
async_threads          |     64  |         64
io_threads            |      8  |          8
```

**🧵 线程类型说明**：
- **async_threads**：异步处理线程（处理并发任务）
- **io_threads**：输入输出线程（处理文件和网络IO）
- **scheduler_threads**：调度器线程（任务分配）

---

## 5. 🔧 故障排查辅助命令


### 5.1 系统观察工具


#### 🔸 rabbitmq-diagnostics observer

**通俗解释**：启动系统观察器，就像打开"任务管理器"来实时查看系统状态。

```bash
# 启动观察器（需要图形界面）
rabbitmq-diagnostics observer

# 注意：这个命令需要X11转发或本地桌面环境
```

**⚠️ 使用注意事项**：
- 需要图形界面环境
- 主要用于开发和测试环境
- 生产环境通常使用其他监控工具

### 5.2 高级诊断工具


#### 🔸 rabbitmq-diagnostics binary_heap_dump

**通俗解释**：生成二进制堆转储，就像给系统拍个"内部CT扫描"，用于深度问题分析。

```bash
# 生成堆转储文件
rabbitmq-diagnostics binary_heap_dump /tmp/heap_dump.hprof

# 指定节点
rabbitmq-diagnostics binary_heap_dump /tmp/heap_dump.hprof -n rabbit@node1
```

**🔬 堆转储用途**：
- **内存泄漏分析**：找出内存使用异常的原因
- **性能调优**：分析内存分配模式
- **故障分析**：系统崩溃后的事后分析
- **专业工具**：需要专门的分析工具来查看

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的监控命令


**🔸 日常监控三剑客**：
```bash
# 1. 集群状态总览
rabbitmq-diagnostics cluster_status

# 2. 内存使用分析  
rabbitmq-diagnostics memory_breakdown

# 3. 无响应队列检查
rabbitmq-diagnostics list_unresponsive_queues
```

### 6.2 监控命令使用策略


**📋 监控检查清单**：
```
日常检查（每天）：
☐ cluster_status - 集群整体状态
☐ memory_breakdown - 内存使用情况
☐ list_unresponsive_queues - 队列健康状态

问题排查（出现异常时）：
☐ maybe_stuck - 检查卡住进程
☐ check_if_node_is_mirror_sync_critical - 镜像同步状态
☐ check_if_node_is_quorum_critical - 仲裁队列状态

深度分析（性能问题）：
☐ runtime_thread_stats - 线程使用统计
☐ binary_heap_dump - 堆内存分析
```

### 6.3 监控最佳实践


**🎯 监控建议**：
- **定期检查**：设置定时任务自动执行监控命令
- **告警设置**：配置监控告警，问题及时发现
- **历史记录**：保存监控数据，便于趋势分析
- **文档记录**：记录常见问题和解决方案

**⚠️ 常见监控陷阱**：
```
避免这些错误：

❌ 只看表面数据，不分析原因
❌ 忽略早期警告信号
❌ 监控频率过高，影响性能
❌ 没有制定应急响应计划
```

### 6.4 实际应用场景


**🏢 生产环境监控流程**：
```
1. 每5分钟自动检查集群状态
2. 内存使用率超过80%时告警
3. 发现无响应队列立即通知
4. 每小时保存一次监控快照
5. 每天生成监控报告
```

**🔧 故障处理流程**：
```
发现问题 → 运行诊断命令 → 分析结果 → 制定方案 → 执行修复 → 验证效果
```

**核心记忆**：
- 监控就像体检，预防胜于治疗
- 三个核心命令掌握日常监控
- 问题排查要系统化，不能盲目
- 监控数据要分析，不只是收集