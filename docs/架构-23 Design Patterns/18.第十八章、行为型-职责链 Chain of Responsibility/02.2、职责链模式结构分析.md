---
title: 2、职责链模式结构分析
---
## 📚 目录

1. [职责链模式核心结构](#1-职责链模式核心结构)
2. [抽象处理者接口设计](#2-抽象处理者接口设计)
3. [具体处理者实现详解](#3-具体处理者实现详解)
4. [链式结构构建原理](#4-链式结构构建原理)
5. [请求传递机制分析](#5-请求传递机制分析)
6. [处理结果返回策略](#6-处理结果返回策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔗 职责链模式核心结构


### 1.1 什么是职责链模式


**通俗理解**：职责链模式就像公司里的`审批流程`一样

```
员工请假申请的审批流程：
请假申请 → 直属主管 → 部门经理 → 人事总监 → 总经理

特点：
• 每个环节都有自己的处理权限
• 处理不了的就传给下一级
• 申请人不需要知道具体由谁处理
```

**核心概念**：
- `[处理链条]` - 多个处理者按顺序连接
- `[权限分级]` - 每个处理者有不同的处理能力
- `[自动传递]` - 处理不了就自动传给下一个
- `[解耦合]` - 请求者不需要知道具体处理者

### 1.2 职责链模式的组成结构


**核心角色图解**：
```
请求发起者
    ↓
┌─────────────┐    处理不了    ┌─────────────┐    处理不了    ┌─────────────┐
│  处理者A    │ ────────────→ │  处理者B    │ ────────────→ │  处理者C    │
│ (权限小)    │               │ (权限中)    │               │ (权限大)    │
└─────────────┘               └─────────────┘               └─────────────┘
    ↓ 能处理                     ↓ 能处理                     ↓ 能处理
  返回结果                     返回结果                     返回结果
```

**结构说明**：
- **Handler（抽象处理者）**：定义处理请求的接口
- **ConcreteHandler（具体处理者）**：实际处理请求的类
- **Client（客户端）**：创建链条并发起请求

### 1.3 为什么需要职责链模式


**解决的问题**：

```
传统做法的问题：
if (请求类型 == A) {
    处理者A.handle();
} else if (请求类型 == B) {
    处理者B.handle();
} else if (请求类型 == C) {
    处理者C.handle();
}

问题：
❌ 代码中有大量if-else判断
❌ 增加新的处理者需要修改现有代码
❌ 处理者与请求者紧密耦合
❌ 处理逻辑难以扩展和维护
```

**职责链的优势**：
```
✅ 请求者不需要知道具体处理者
✅ 可以动态添加或删除处理者
✅ 每个处理者职责单一，易于维护
✅ 符合开闭原则，易于扩展
```

---

## 2. 🎯 抽象处理者接口设计


### 2.1 抽象处理者的作用


**核心职责**：
- `[定义接口]` - 规定所有处理者必须实现的方法
- `[维护链条]` - 保存下一个处理者的引用
- `[传递机制]` - 提供将请求传递给下一个处理者的方法

### 2.2 抽象处理者的设计


```java
// 抽象处理者 - 就像公司的通用审批流程模板
public abstract class Handler {
    // 下一个处理者（就像审批流程中的下一级领导）
    protected Handler nextHandler;
    
    // 设置下一个处理者（建立审批链条）
    public void setNext(Handler handler) {
        this.nextHandler = handler;
    }
    
    // 处理请求的抽象方法（每个岗位的具体审批规则不同）
    public abstract void handleRequest(Request request);
}
```

**设计要点解析**：

| 设计元素 | **作用说明** | **类比理解** |
|---------|-------------|-------------|
| `nextHandler` | `保存链条中下一个处理者` | `审批流程中的下一级领导` |
| `setNext()` | `建立处理者之间的连接` | `设定审批流程的顺序` |
| `handleRequest()` | `定义处理请求的规范` | `每个岗位的审批职责` |

### 2.3 请求对象的设计


```java
// 请求对象 - 就像员工提交的申请表
public class Request {
    private String type;        // 请求类型（请假、报销、采购等）
    private double amount;      // 涉及金额
    private String description; // 请求描述
    
    public Request(String type, double amount, String description) {
        this.type = type;
        this.amount = amount;
        this.description = description;
    }
    
    // getter方法...
}
```

**⚠️ 设计注意事项**：
- 请求对象应该包含处理者判断所需的所有信息
- 保持请求对象的`简洁性`，避免包含过多无关信息
- 可以考虑使用`建造者模式`来创建复杂的请求对象

---

## 3. 🏭 具体处理者实现详解


### 3.1 具体处理者的实现模式


**标准实现模板**：
```java
public class ConcreteHandler extends Handler {
    @Override
    public void handleRequest(Request request) {
        if (canHandle(request)) {
            // 在自己权限范围内，直接处理
            process(request);
        } else if (nextHandler != null) {
            // 超出权限，传递给下一个处理者
            nextHandler.handleRequest(request);
        } else {
            // 没有下一个处理者，处理失败
            handleFailure(request);
        }
    }
    
    // 判断是否能处理（每个处理者的核心逻辑）
    protected abstract boolean canHandle(Request request);
    
    // 具体处理逻辑
    protected abstract void process(Request request);
    
    // 处理失败的情况
    protected void handleFailure(Request request) {
        System.out.println("请求无法处理：" + request.getDescription());
    }
}
```

### 3.2 实际处理者示例


**示例：公司审批系统**

```java
// 主管 - 处理1000元以下的申请
class Supervisor extends Handler {
    @Override
    public void handleRequest(Request request) {
        if (request.getAmount() <= 1000) {
            System.out.println("主管审批通过：" + request.getDescription());
        } else if (nextHandler != null) {
            System.out.println("主管权限不足，转交上级处理");
            nextHandler.handleRequest(request);
        }
    }
}

// 经理 - 处理5000元以下的申请
class Manager extends Handler {
    @Override
    public void handleRequest(Request request) {
        if (request.getAmount() <= 5000) {
            System.out.println("经理审批通过：" + request.getDescription());
        } else if (nextHandler != null) {
            System.out.println("经理权限不足，转交上级处理");
            nextHandler.handleRequest(request);
        }
    }
}

// 总监 - 处理10000元以下的申请
class Director extends Handler {
    @Override
    public void handleRequest(Request request) {
        if (request.getAmount() <= 10000) {
            System.out.println("总监审批通过：" + request.getDescription());
        } else {
            System.out.println("总监：金额过大，申请被拒绝");
        }
    }
}
```

**💡 实现要点**：
- 每个处理者都有明确的`处理范围`
- 处理不了的请求会`自动传递`给下一级
- 最后一个处理者要处理`无法处理`的情况

### 3.3 处理者的职责分工


**权限分级示例**：
```
主管权限：
├── 日常用品采购（≤ 1000元）
├── 员工加班申请
└── 简单的报销申请

经理权限：
├── 部门设备采购（≤ 5000元）
├── 员工请假申请
├── 培训费用申请
└── 主管无法处理的事务

总监权限：
├── 重要设备采购（≤ 10000元）
├── 人员招聘申请
├── 预算调整申请
└── 经理无法处理的事务
```

---

## 4. 🔗 链式结构构建原理


### 4.1 链条构建的基本方式


**方式一：手动构建**
```java
public class ChainBuilder {
    public static Handler buildApprovalChain() {
        // 创建各级处理者
        Handler supervisor = new Supervisor();
        Handler manager = new Manager();
        Handler director = new Director();
        
        // 构建链条：主管 → 经理 → 总监
        supervisor.setNext(manager);
        manager.setNext(director);
        
        // 返回链条的第一个处理者
        return supervisor;
    }
}
```

**链条结构图**：
```
请求 → [主管] → [经理] → [总监] → 结束
         ↓       ↓       ↓
      ≤1000   ≤5000   ≤10000
        元      元      元
```

### 4.2 动态链条构建


**方式二：配置化构建**
```java
public class DynamicChainBuilder {
    private Handler firstHandler;
    private Handler lastHandler;
    
    // 添加处理者到链条末尾
    public DynamicChainBuilder addHandler(Handler handler) {
        if (firstHandler == null) {
            firstHandler = handler;
            lastHandler = handler;
        } else {
            lastHandler.setNext(handler);
            lastHandler = handler;
        }
        return this; // 支持链式调用
    }
    
    // 构建完成，返回链条
    public Handler build() {
        return firstHandler;
    }
}
```

**使用示例**：
```java
// 动态构建审批链
Handler approvalChain = new DynamicChainBuilder()
    .addHandler(new Supervisor())
    .addHandler(new Manager())
    .addHandler(new Director())
    .build();
```

**🚀 动态构建的优势**：
- `[灵活配置]` - 可以根据需要调整链条顺序
- `[易于扩展]` - 新增处理者不需要修改现有代码
- `[链式调用]` - 构建过程更加流畅自然

### 4.3 链条构建的注意事项


**⚠️ 常见问题**：

```
问题1：环形链条
处理者A → 处理者B → 处理者A (无限循环)

解决方案：
• 在设置下一个处理者时检查是否会形成环
• 使用访问标记避免重复处理

问题2：链条断裂
处理者A → null (请求丢失)

解决方案：
• 在链条末尾设置默认处理者
• 记录处理失败的请求

问题3：性能问题
链条过长导致处理效率低下

解决方案：
• 将最常用的处理者放在链条前端
• 考虑使用索引快速定位合适的处理者
```

---

## 5. 📨 请求传递机制分析


### 5.1 请求传递的基本流程


**传递流程图**：
```
开始
  ↓
收到请求
  ↓
判断是否能处理？
  ↓        ↓
 能       不能
  ↓        ↓
处理请求   有下一个处理者？
  ↓        ↓        ↓
返回结果   有       没有
          ↓        ↓
      传递给下一个  处理失败
          ↓        ↓
      (递归调用)   返回错误
```

### 5.2 传递机制的实现方式


**递归传递方式**：
```java
public void handleRequest(Request request) {
    if (canHandle(request)) {
        // 自己处理
        process(request);
    } else if (nextHandler != null) {
        // 递归调用下一个处理者
        nextHandler.handleRequest(request);
    } else {
        // 链条末尾，处理失败
        handleFailure(request);
    }
}
```

**迭代传递方式**：
```java
public void handleRequest(Request request) {
    Handler current = this;
    
    while (current != null) {
        if (current.canHandle(request)) {
            current.process(request);
            return; // 处理完成，退出
        }
        current = current.nextHandler; // 移动到下一个处理者
    }
    
    // 所有处理者都无法处理
    handleFailure(request);
}
```

**📊 两种方式对比**：

| 传递方式 | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|-------------|
| `递归方式` | `代码简洁，逻辑清晰` | `链条很长时可能栈溢出` | `链条长度适中的场景` |
| `迭代方式` | `不会栈溢出，性能稳定` | `代码稍复杂` | `链条可能很长的场景` |

### 5.3 请求传递的高级特性


**特性1：中断传递**
```java
public boolean handleRequest(Request request) {
    if (canHandle(request)) {
        process(request);
        return true; // 处理成功，中断传递
    } else if (nextHandler != null) {
        return nextHandler.handleRequest(request);
    }
    return false; // 处理失败
}
```

**特性2：继续传递**
```java
public void handleRequest(Request request) {
    // 自己先处理一部分
    if (canPartiallyHandle(request)) {
        partialProcess(request);
    }
    
    // 继续传递给下一个处理者
    if (nextHandler != null) {
        nextHandler.handleRequest(request);
    }
}
```

**🎯 使用场景说明**：
- `中断传递`：适用于只需一个处理者处理的场景（如审批）
- `继续传递`：适用于需要多个处理者协作的场景（如日志记录）

---

## 6. 🎁 处理结果返回策略


### 6.1 结果返回的不同方式


**方式1：无返回值（单向处理）**
```java
public void handleRequest(Request request) {
    if (canHandle(request)) {
        process(request);
        // 直接处理，不返回结果
    } else if (nextHandler != null) {
        nextHandler.handleRequest(request);
    }
}
```

**适用场景**：`日志记录`、`事件通知`等不需要反馈的场景

**方式2：布尔返回值（成功/失败）**
```java
public boolean handleRequest(Request request) {
    if (canHandle(request)) {
        return process(request); // 返回处理是否成功
    } else if (nextHandler != null) {
        return nextHandler.handleRequest(request);
    }
    return false; // 无法处理
}
```

**适用场景**：`验证检查`、`权限控制`等需要明确成功失败的场景

**方式3：对象返回值（详细结果）**
```java
public class ProcessResult {
    private boolean success;
    private String message;
    private Object data;
    
    // 构造方法和getter/setter...
}

public ProcessResult handleRequest(Request request) {
    if (canHandle(request)) {
        return process(request); // 返回详细处理结果
    } else if (nextHandler != null) {
        return nextHandler.handleRequest(request);
    }
    return new ProcessResult(false, "无法处理请求", null);
}
```

**适用场景**：`业务处理`、`数据转换`等需要详细反馈的场景

### 6.2 结果收集和聚合


**场景：多个处理者都需要处理同一请求**
```java
public class CollectingHandler extends Handler {
    private List<ProcessResult> results = new ArrayList<>();
    
    @Override
    public ProcessResult handleRequest(Request request) {
        // 自己处理
        if (canHandle(request)) {
            ProcessResult myResult = process(request);
            results.add(myResult);
        }
        
        // 继续传递
        if (nextHandler != null) {
            ProcessResult nextResult = nextHandler.handleRequest(request);
            if (nextResult != null) {
                results.add(nextResult);
            }
        }
        
        // 聚合所有结果
        return aggregateResults(results);
    }
    
    private ProcessResult aggregateResults(List<ProcessResult> results) {
        // 将多个结果合并成一个最终结果
        // 具体合并逻辑根据业务需求决定
    }
}
```

### 6.3 异常处理策略


**处理异常的三种策略**：

```java
public ProcessResult handleRequest(Request request) {
    try {
        if (canHandle(request)) {
            return process(request);
        } else if (nextHandler != null) {
            return nextHandler.handleRequest(request);
        }
    } catch (Exception e) {
        // 策略1：抛出异常，中断整个链条
        throw new ProcessException("处理失败", e);
        
        // 策略2：记录异常，继续传递
        log.error("处理异常，继续传递", e);
        if (nextHandler != null) {
            return nextHandler.handleRequest(request);
        }
        
        // 策略3：返回异常结果，不继续传递
        return new ProcessResult(false, "处理异常：" + e.getMessage(), null);
    }
    
    return new ProcessResult(false, "无法处理", null);
}
```

**💡 选择建议**：
- `抛出异常`：用于严重错误，需要立即停止处理
- `记录异常继续`：用于非关键错误，希望其他处理者能够处理
- `返回异常结果`：用于业务异常，需要向调用者报告错误

---

## 7. 📋 核心要点总结


### 7.1 职责链模式的核心结构


```
🔸 抽象处理者：定义处理接口，维护下一个处理者的引用
🔸 具体处理者：实现具体的处理逻辑，判断是否能处理请求
🔸 链式结构：通过nextHandler将多个处理者连接成链条
🔸 请求传递：当前处理者无法处理时，自动传递给下一个
🔸 结果返回：根据业务需要选择合适的结果返回策略
```

### 7.2 关键理解要点


**🔹 职责链的本质**
```
就像公司的审批流程：
• 每个岗位都有自己的权限范围
• 超出权限的申请自动提交给上级
• 申请人不需要知道具体由谁审批
• 可以随时调整审批流程的顺序
```

**🔹 设计的核心思想**
```
解耦合：请求者与处理者分离
可扩展：易于添加新的处理者
单一职责：每个处理者只关心自己能处理的请求
开闭原则：对扩展开放，对修改封闭
```

**🔹 实现的关键点**
```
链条构建：确保处理者正确连接
传递机制：递归或迭代方式传递请求
异常处理：考虑处理失败的各种情况
性能优化：将常用处理者放在链条前端
```

### 7.3 实际应用价值


**🎯 适用场景**：
- **审批流程**：请假、报销、采购等分级审批
- **过滤器链**：Web框架中的请求过滤处理
- **事件处理**：GUI程序中的事件响应机制
- **中间件**：消息处理中的各种中间件组件

**🔧 实践建议**：
- 合理设计处理者的职责边界
- 考虑链条的长度对性能的影响
- 为链条末尾设置默认处理者
- 记录请求的处理轨迹便于调试

**核心记忆**：
- 职责链模式如流水线，每个环节各司其职
- 处理不了就传下去，直到找到合适的处理者
- 请求发起者无需知道具体处理细节
- 灵活组合处理者，易于扩展和维护