---
title: 1、备忘录模式概念原理
---
## 📚 目录

1. [备忘录模式概念原理](#1-备忘录模式概念原理)
2. [核心组成与结构](#2-核心组成与结构)
3. [实现方式详解](#3-实现方式详解)
4. [经典应用场景](#4-经典应用场景)
5. [优缺点分析](#5-优缺点分析)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 备忘录模式概念原理


### 1.1 什么是备忘录模式


**🔸 生活中的类比**
```
想象你在玩游戏时的存档功能：
游戏进行中 → 按F5存档 → 继续游戏 → 挂了 → 按F9读档
关键：存档时保存了游戏的完整状态，读档时能完全恢复
```

**📋 正式定义**
> **备忘录模式（Memento Pattern）**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。

### 1.2 核心思想解析


**🎯 设计目的**
```
主要解决的问题：
• 如何保存对象的历史状态？
• 如何在需要时恢复到之前的状态？
• 如何在不暴露对象内部细节的情况下实现状态管理？

核心理念：
就像照相机拍照片一样，把某一时刻的状态"拍下来"保存起来
需要的时候可以"回到"那个时刻
```

**🔸 为什么需要备忘录模式**
```
实际开发中的常见需求：
📝 文本编辑器的撤销/重做功能
🎮 游戏的存档/读档系统  
💾 数据库的事务回滚机制
🌐 浏览器的前进/后退按钮
📱 手机应用的状态恢复
```

### 1.3 封装性保护机制


**🔒 封装性的重要性**
```
问题场景：
如果直接暴露对象的内部状态 → 外部可以随意修改 → 破坏了封装性

备忘录模式的解决方案：
创建一个专门的"备忘录对象"来存储状态
只有原始对象才能读写备忘录的内容
外部只能存储和传递备忘录，不能修改其内容
```

**💡 保护机制示例**
```
错误做法：
class Editor {
    public String content;     // 直接暴露内容
    public int cursorPos;      // 直接暴露光标位置
}

正确做法：
class Editor {
    private String content;    // 私有状态
    private int cursorPos;     // 私有状态
    
    // 只能通过备忘录来保存/恢复状态
    public Memento createMemento() { ... }
    public void restoreFromMemento(Memento m) { ... }
}
```

---

## 2. 🏗️ 核心组成与结构


### 2.1 三大核心角色


**📊 角色关系图**
```
发起人(Originator)     备忘录(Memento)     管理者(Caretaker)
      |                     |                    |
   创建备忘录 -----------> 存储状态         保存备忘录
      |                     |                    |
   恢复状态   <----------- 提供状态         提供备忘录
```

### 2.2 角色详细说明


**🎭 发起人（Originator）**
```
作用：需要保存状态的原始对象
职责：
• 创建备忘录对象，保存当前状态
• 使用备忘录对象，恢复历史状态
• 决定哪些状态需要保存

生活类比：
就像游戏中的"角色"
• 可以创建存档（保存血量、等级、装备等）
• 可以读取存档（恢复到存档时的状态）
```

**📝 备忘录（Memento）**
```
作用：存储发起人内部状态的对象
职责：
• 存储发起人的状态信息
• 只能被发起人访问，其他对象无法修改
• 保证状态信息的完整性和安全性

生活类比：
就像游戏的"存档文件"
• 记录了游戏的完整状态
• 只有游戏本身能读写这个文件
• 玩家只能保存和加载，不能直接修改
```

**🗃️ 管理者（Caretaker）**
```
作用：负责保存备忘录对象的管理员
职责：
• 保存备忘录对象
• 向发起人提供备忘录对象
• 不能修改或访问备忘录的内容

生活类比：
就像游戏的"存档管理系统"
• 管理多个存档文件
• 可以删除、复制存档文件
• 但不能修改存档文件的内容
```

### 2.3 UML结构图


```
┌─────────────────┐    创建    ┌─────────────────┐
│   Originator    │ ────────→ │    Memento      │
│                 │           │                 │
│ - state         │           │ - state         │
│ + setState()    │           │ + getState()    │
│ + createMem.()  │ ←──恢复─── │ + setState()    │
│ + restoreM.()   │           │                 │
└─────────────────┘           └─────────────────┘
        △                              △
        │ 使用                         │ 保存
        │                              │
┌─────────────────┐           ┌─────────────────┐
│   Caretaker     │───管理───→│   List<Memento> │
│                 │           │                 │
│ + saveState()   │           │                 │
│ + restoreState()│           │                 │
└─────────────────┘           └─────────────────┘
```

---

## 3. 💻 实现方式详解


### 3.1 基础实现示例


让我们用一个**文本编辑器**的例子来理解备忘录模式：

**📝 文本编辑器（发起人）**
```java
// 发起人：文本编辑器
public class TextEditor {
    private String content;        // 文本内容
    private int cursorPosition;    // 光标位置
    
    public TextEditor() {
        this.content = "";
        this.cursorPosition = 0;
    }
    
    // 编辑文本
    public void write(String text) {
        content += text;
        cursorPosition = content.length();
        System.out.println("当前内容: " + content);
    }
    
    // 创建备忘录（保存当前状态）
    public EditorMemento createMemento() {
        return new EditorMemento(content, cursorPosition);
    }
    
    // 从备忘录恢复状态
    public void restoreFromMemento(EditorMemento memento) {
        this.content = memento.getContent();
        this.cursorPosition = memento.getCursorPosition();
        System.out.println("恢复后内容: " + content);
    }
}
```

**💾 编辑器备忘录（备忘录）**
```java
// 备忘录：保存编辑器状态
public class EditorMemento {
    private final String content;        // 保存的文本内容
    private final int cursorPosition;    // 保存的光标位置
    
    // 构造函数（只能由发起人调用）
    public EditorMemento(String content, int cursorPosition) {
        this.content = content;
        this.cursorPosition = cursorPosition;
    }
    
    // 只提供读取方法，不提供修改方法
    public String getContent() {
        return content;
    }
    
    public int getCursorPosition() {
        return cursorPosition;
    }
}
```

**🗂️ 历史记录管理器（管理者）**
```java
// 管理者：历史记录管理
public class HistoryManager {
    private Stack<EditorMemento> history = new Stack<>();
    
    // 保存状态到历史记录
    public void saveState(EditorMemento memento) {
        history.push(memento);
        System.out.println("保存了第" + history.size() + "个历史状态");
    }
    
    // 撤销到上一个状态
    public EditorMemento undo() {
        if (!history.isEmpty()) {
            EditorMemento memento = history.pop();
            System.out.println("撤销到第" + (history.size()) + "个状态");
            return memento;
        }
        System.out.println("没有可撤销的状态");
        return null;
    }
    
    // 检查是否有历史记录
    public boolean hasHistory() {
        return !history.isEmpty();
    }
}
```

### 3.2 使用示例演示


**🎬 完整使用流程**
```java
public class MementoDemo {
    public static void main(String[] args) {
        // 创建文本编辑器和历史管理器
        TextEditor editor = new TextEditor();
        HistoryManager history = new HistoryManager();
        
        // 编辑文本并保存状态
        editor.write("Hello");
        history.saveState(editor.createMemento());  // 保存状态1
        
        editor.write(" World");
        history.saveState(editor.createMemento());  // 保存状态2
        
        editor.write("!");
        // 此时内容是 "Hello World!"
        
        // 执行撤销操作
        EditorMemento lastState = history.undo();
        if (lastState != null) {
            editor.restoreFromMemento(lastState);  // 恢复到 "Hello World"
        }
        
        // 再次撤销
        lastState = history.undo();
        if (lastState != null) {
            editor.restoreFromMemento(lastState);  // 恢复到 "Hello"
        }
    }
}
```

**📤 输出结果**
```
当前内容: Hello
保存了第1个历史状态
当前内容: Hello World
保存了第2个历史状态
当前内容: Hello World!
撤销到第1个状态
恢复后内容: Hello World
撤销到第0个状态
恢复后内容: Hello
```

### 3.3 进阶实现：支持重做功能


**🔄 增强版历史管理器**
```java
public class AdvancedHistoryManager {
    private Stack<EditorMemento> undoStack = new Stack<>();  // 撤销栈
    private Stack<EditorMemento> redoStack = new Stack<>();  // 重做栈
    
    public void saveState(EditorMemento memento) {
        undoStack.push(memento);
        redoStack.clear();  // 新操作清空重做栈
        System.out.println("保存状态，可撤销步数: " + undoStack.size());
    }
    
    public EditorMemento undo() {
        if (!undoStack.isEmpty()) {
            EditorMemento current = undoStack.pop();
            redoStack.push(current);
            System.out.println("撤销操作，可重做步数: " + redoStack.size());
            return undoStack.isEmpty() ? null : undoStack.peek();
        }
        return null;
    }
    
    public EditorMemento redo() {
        if (!redoStack.isEmpty()) {
            EditorMemento memento = redoStack.pop();
            undoStack.push(memento);
            System.out.println("重做操作，可撤销步数: " + undoStack.size());
            return memento;
        }
        return null;
    }
}
```

---

## 4. 🎯 经典应用场景


### 4.1 文本编辑器撤销重做


**📝 应用描述**
```
功能需求：
• 用户在编辑文档时可以撤销之前的操作
• 支持多步撤销和重做
• 不能让用户直接修改历史记录

实现要点：
• 每次用户操作后自动保存状态
• 维护撤销栈和重做栈
• 提供清晰的撤销/重做按钮
```

**💡 实际应用**
- Microsoft Word 的撤销功能
- Visual Studio Code 的编辑历史
- Photoshop 的历史记录面板

### 4.2 游戏存档系统


**🎮 应用描述**
```
功能需求：
• 玩家可以在任意时刻保存游戏进度
• 支持多个存档槽位
• 可以加载之前的存档继续游戏

状态信息包括：
• 角色等级、经验值、血量
• 当前位置、任务进度
• 背包物品、装备信息
```

**🏗️ 简化实现思路**
```java
public class GameCharacter {
    private int level, health, experience;
    private String location;
    
    public GameMemento saveGame() {
        return new GameMemento(level, health, experience, location);
    }
    
    public void loadGame(GameMemento save) {
        this.level = save.getLevel();
        this.health = save.getHealth();
        // 恢复其他状态...
    }
}
```

### 4.3 数据库事务管理


**💾 应用描述**
```
功能需求：
• 在事务执行过程中保存检查点
• 出现错误时可以回滚到检查点
• 保证数据的一致性和完整性

应用举例：
转账操作：
1. 保存初始状态
2. 从账户A扣款
3. 保存中间状态  
4. 向账户B转账
5. 如果失败，回滚到初始状态
```

### 4.4 Web浏览器历史记录


**🌐 应用描述**
```
功能需求：
• 记录用户访问的页面历史
• 支持前进和后退操作
• 维护访问状态和页面信息

实现考虑：
• 页面状态：URL、滚动位置、表单数据
• 历史栈：维护访问顺序
• 内存管理：限制历史记录数量
```

---

## 5. ⚖️ 优缺点分析


### 5.1 主要优点


**✅ 优点详解**

| 优点 | **具体说明** | **实际价值** |
|------|-------------|-------------|
| 🔒 **封装性保护** | `备忘录对象封装了状态信息，外部无法直接访问` | `保护对象内部数据，防止意外修改` |
| 🎯 **职责分离** | `发起人专注业务逻辑，管理者专注状态管理` | `代码结构清晰，易于维护` |
| 🔄 **状态恢复** | `可以精确恢复到历史状态` | `提供撤销、回滚等重要功能` |
| 🧩 **简化复杂度** | `客户端不需要了解状态保存的复杂细节` | `使用简单，降低开发难度` |

**🎯 核心价值体现**
```
用户体验提升：
• 操作失误可以撤销，减少用户焦虑
• 支持实验性操作，增加用户信心
• 提供状态回退，增强软件容错性

开发效率提升：
• 统一的状态管理模式
• 减少状态相关的bug
• 便于添加历史记录功能
```

### 5.2 主要缺点


**❌ 缺点分析**

| 缺点 | **具体影响** | **应对策略** |
|------|-------------|-------------|
| 💾 **内存消耗大** | `每个备忘录都要保存完整状态` | `限制历史记录数量，使用差量保存` |
| ⚡ **性能开销** | `频繁创建备忘录对象影响性能` | `按需保存，避免过度使用` |
| 🔧 **维护复杂** | `状态变化时需要更新备忘录逻辑` | `设计良好的接口，自动化测试` |
| 📈 **管理成本** | `需要管理大量的历史状态` | `实现智能清理策略` |

**⚠️ 使用注意事项**
```
内存管理策略：
• 设置最大历史记录数量（如最多100步撤销）
• 定期清理过期的备忘录对象
• 对大对象使用增量保存而非全量保存

性能优化建议：
• 不是每个操作都需要保存状态
• 可以合并连续的小操作
• 使用延迟保存策略
```

### 5.3 适用场景判断


**🎯 何时使用备忘录模式**

**✅ 适合使用的场景**
```
必须提供撤销功能：
• 文本编辑、图形设计软件
• 游戏存档、数据库事务
• 配置管理、状态机

状态复杂且重要：
• 对象状态包含多个字段
• 状态恢复的准确性要求高
• 需要保护对象封装性
```

**❌ 不适合使用的场景**
```
简单状态管理：
• 只有一两个简单属性的对象
• 状态变化很少的对象
• 不需要历史记录的场景

资源受限环境：
• 内存严重受限的嵌入式系统
• 实时性要求极高的系统
• 状态数据量巨大的系统
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的基本概念


**🔸 模式本质**
```
核心思想：像拍照一样保存对象的状态快照
关键机制：通过备忘录对象实现状态的封装和恢复
主要价值：在不破坏封装性的前提下提供撤销/恢复功能
```

**🔸 三大角色关系**
```
发起人(Originator)：状态的主人，知道如何保存和恢复自己
备忘录(Memento)：状态的容器，只存储不处理
管理者(Caretaker)：状态的管家，负责保管但不能修改
```

### 6.2 关键理解要点


**🔹 封装性保护的重要性**
```
为什么不能直接暴露状态：
• 破坏对象的封装性
• 外部可能不正确地修改状态
• 难以保证状态的一致性和完整性

备忘录如何保护封装性：
• 备忘录只能由发起人创建和读取
• 外部只能传递备忘录，不能修改内容
• 通过接口限制而非访问控制实现保护
```

**🔹 内存管理的平衡艺术**
```
核心矛盾：
功能需求 vs 资源限制

解决策略：
• 智能保存：不是每个操作都保存状态
• 容量限制：设定最大历史记录数量
• 差量保存：只保存变化的部分
• 定期清理：自动删除过期的备忘录
```

### 6.3 实际应用指导


**🎯 设计时的关键决策**
```
何时创建备忘录：
• 用户执行重要操作前
• 系统状态发生关键变化时
• 长时间操作的检查点

如何管理备忘录：
• 使用栈结构实现撤销/重做
• 设置合理的历史记录上限
• 考虑备忘录的生命周期管理
```

**🔧 实现时的最佳实践**
```
代码实现建议：
• 备忘录类设计为不可变对象
• 提供清晰的创建和恢复接口
• 实现合理的异常处理机制
• 考虑序列化和持久化需求

性能优化策略：
• 避免过度频繁的状态保存
• 使用对象池减少内存分配
• 实现延迟加载和懒保存
• 监控内存使用情况
```

### 6.4 与其他模式的关系


**🔗 相关模式对比**
```
命令模式 vs 备忘录模式：
• 命令模式：关注操作的封装和执行
• 备忘录模式：关注状态的保存和恢复
• 可以结合使用：命令携带备忘录实现撤销

原型模式 vs 备忘录模式：
• 原型模式：创建对象的副本
• 备忘录模式：保存对象的状态
• 备忘录可以使用原型模式实现深拷贝
```

### 6.5 学习检查清单


**✅ 掌握度自测**
- [ ] 能说出备忘录模式的三个核心角色及其职责
- [ ] 能解释为什么需要保护备忘录的封装性
- [ ] 能独立实现一个简单的撤销/重做功能
- [ ] 能分析备忘录模式的优缺点和适用场景
- [ ] 能设计合理的内存管理策略

**🧠 记忆锚点**
```
核心类比：备忘录模式就像游戏存档
• 存档(备忘录)保存游戏状态
• 游戏(发起人)创建和读取存档
• 存档管理器(管理者)保管存档文件

一句话精华：
不破坏封装的前提下，给对象拍个"状态快照"，需要时可以"时光倒流"
```

**核心记忆**：
- 备忘录模式提供对象状态的"时间机器"功能
- 三个角色分工明确：创建者、存储者、管理者
- 平衡功能需求与资源消耗是使用关键
- 广泛应用于需要撤销/恢复功能的系统中