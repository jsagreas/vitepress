---
title: 2、代理模式结构分析
---
## 📚 目录

1. [代理模式结构概述](#1-代理模式结构概述)
2. [抽象主题接口设计](#2-抽象主题接口设计)
3. [真实主题实现](#3-真实主题实现)
4. [代理类设计](#4-代理类设计)
5. [客户端调用方式](#5-客户端调用方式)
6. [代理控制机制](#6-代理控制机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏗️ 代理模式结构概述


### 1.1 什么是代理模式结构


**简单理解**：代理模式就像现实生活中的代理人一样，比如房屋中介、律师代理等。

```
现实生活中的代理：
买房者 → 房屋中介 → 房主
客户   → 代理人   → 真实服务提供者

软件设计中的代理：
客户端 → 代理对象 → 真实对象
Client → Proxy    → RealSubject
```

### 1.2 代理模式的核心思想


**🎯 核心理念**：
- **间接访问**：不直接访问目标对象，而是通过代理
- **控制访问**：代理可以控制对真实对象的访问
- **增强功能**：代理可以在访问前后添加额外功能
- **透明性**：客户端感觉像直接使用真实对象一样

### 1.3 代理模式基本结构图


```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Client    │────→│   Subject   │←────│   Proxy     │
│   客户端     │     │ (抽象主题)   │     │   (代理)     │
└─────────────┘     └─────────────┘     └─────────────┘
                            ↑                   │
                            │                   │
                    ┌─────────────┐             │
                    │ RealSubject │←────────────┘
                    │  (真实主题)  │
                    └─────────────┘

关系说明：
• Client 只知道 Subject 接口
• Proxy 和 RealSubject 都实现 Subject
• Proxy 内部持有 RealSubject 的引用
• Client 通过 Proxy 间接访问 RealSubject
```

---

## 2. 📋 抽象主题接口设计


### 2.1 抽象主题的作用


**为什么需要抽象主题**：
- **统一接口**：代理和真实对象使用相同接口
- **透明访问**：客户端不知道访问的是代理还是真实对象
- **可替换性**：代理和真实对象可以互相替换

### 2.2 接口设计原则


**🔸 设计要点**：
```
✅ 接口要简洁明确
✅ 包含核心业务方法
✅ 避免过度设计
✅ 考虑扩展性
```

### 2.3 抽象主题接口示例


```java
/**
 * 抽象主题接口 - 定义代理和真实对象的共同接口
 */
public interface Subject {
    /**
     * 核心业务方法
     * @param request 请求参数
     * @return 处理结果
     */
    String doOperation(String request);
    
    /**
     * 查询方法
     * @return 状态信息
     */
    String getStatus();
}
```

**接口设计说明**：
- `doOperation()` - 核心业务操作方法
- `getStatus()` - 状态查询方法
- 方法签名简单明确，便于实现和使用

### 2.4 接口设计的最佳实践


| 设计原则 | **说明** | **示例** |
|---------|---------|---------|
| 🎯 **单一职责** | `接口功能聚焦，职责明确` | `只定义核心业务方法` |
| 🔧 **接口隔离** | `不强迫实现不需要的方法` | `分离查询和操作接口` |
| 📝 **命名清晰** | `方法名要表达清楚意图` | `doOperation而不是process` |
| 🔄 **便于扩展** | `为未来扩展留出空间` | `使用泛型和参数对象` |

---

## 3. 🏢 真实主题实现


### 3.1 真实主题的职责


**真实主题是什么**：
- **核心业务逻辑**：实现具体的业务功能
- **实际工作者**：真正干活的对象
- **被代理对象**：通过代理来访问的目标

### 3.2 真实主题实现示例


```java
/**
 * 真实主题 - 实现具体业务逻辑
 */
public class RealSubject implements Subject {
    private String name;
    private boolean isWorking = false;
    
    public RealSubject(String name) {
        this.name = name;
    }
    
    @Override
    public String doOperation(String request) {
        // 模拟耗时操作
        isWorking = true;
        
        System.out.println("真实对象 " + name + " 正在处理: " + request);
        
        // 模拟处理时间
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        isWorking = false;
        return "处理完成: " + request;
    }
    
    @Override
    public String getStatus() {
        return name + " 状态: " + (isWorking ? "忙碌中" : "空闲");
    }
}
```

### 3.3 真实主题的特点


**🔸 实现特点**：
```
业务核心：包含核心业务逻辑
资源消耗：可能消耗大量资源（时间、内存、网络等）
创建成本：创建或初始化可能很昂贵
访问限制：可能需要特殊权限或条件
```

### 3.4 真实主题的使用场景


```
常见应用场景：

🔸 远程服务调用
• 网络请求处理
• 数据库操作
• 文件系统访问

🔸 重量级对象
• 大图片加载
• 复杂计算
• 大数据处理

🔸 需要保护的资源
• 敏感数据访问
• 系统资源使用
• 安全操作执行
```

---

## 4. 🛡️ 代理类设计


### 4.1 代理类的核心职责


**代理类的作用**：
- **访问控制**：控制对真实对象的访问
- **功能增强**：在访问前后添加额外功能
- **延迟创建**：需要时才创建真实对象
- **缓存结果**：避免重复调用

### 4.2 代理类基本结构


```java
/**
 * 代理类 - 控制对真实对象的访问
 */
public class SubjectProxy implements Subject {
    private RealSubject realSubject;
    private String targetName;
    private Map<String, String> cache;
    
    public SubjectProxy(String targetName) {
        this.targetName = targetName;
        this.cache = new HashMap<>();
    }
    
    @Override
    public String doOperation(String request) {
        // 前置处理
        if (!checkPermission()) {
            return "访问被拒绝：权限不足";
        }
        
        // 缓存检查
        String cacheKey = "op_" + request;
        if (cache.containsKey(cacheKey)) {
            System.out.println("从缓存返回结果");
            return cache.get(cacheKey);
        }
        
        // 延迟创建真实对象
        if (realSubject == null) {
            System.out.println("创建真实对象: " + targetName);
            realSubject = new RealSubject(targetName);
        }
        
        // 调用真实对象
        String result = realSubject.doOperation(request);
        
        // 后置处理
        cache.put(cacheKey, result);
        logOperation(request, result);
        
        return result;
    }
    
    @Override
    public String getStatus() {
        if (realSubject == null) {
            return targetName + " 状态: 未初始化";
        }
        return realSubject.getStatus();
    }
    
    // 权限检查
    private boolean checkPermission() {
        // 简单的权限检查逻辑
        return true;
    }
    
    // 操作日志
    private void logOperation(String request, String result) {
        System.out.println("日志: 执行了操作 " + request + " -> " + result);
    }
}
```

### 4.3 代理类的控制功能


**🔧 常见控制功能**：

| 控制类型 | **功能说明** | **实现方式** |
|---------|-------------|-------------|
| 🔐 **访问控制** | `检查用户权限和访问条件` | `前置权限验证` |
| ⚡ **性能优化** | `缓存结果，避免重复计算` | `结果缓存机制` |
| 📊 **监控日志** | `记录操作和性能数据` | `前后置日志记录` |
| 🛡️ **安全保护** | `参数验证，异常处理` | `输入验证和异常捕获` |
| ⏱️ **延迟加载** | `需要时才创建真实对象` | `懒汉式对象创建` |

### 4.4 代理类设计模式


```
代理类的几种实现模式：

🔸 保护代理模式：
目的：控制访问权限
实现：添加权限检查逻辑

🔸 虚拟代理模式：
目的：延迟对象创建
实现：懒汉式初始化

🔸 缓存代理模式：
目的：提高访问性能
实现：结果缓存机制

🔸 智能代理模式：
目的：增强对象功能
实现：前后置处理逻辑
```

---

## 5. 👤 客户端调用方式


### 5.1 客户端使用代理的方式


**客户端视角**：
- **透明使用**：不知道使用的是代理还是真实对象
- **统一接口**：通过相同的接口调用
- **简化操作**：不需要关心复杂的创建和管理逻辑

### 5.2 客户端代码示例


```java
/**
 * 客户端 - 使用代理访问服务
 */
public class Client {
    public static void main(String[] args) {
        System.out.println("=== 代理模式演示 ===\n");
        
        // 创建代理对象（客户端不直接创建真实对象）
        Subject service = new SubjectProxy("业务服务");
        
        // 第一次调用 - 会创建真实对象
        System.out.println("--- 第一次调用 ---");
        String result1 = service.doOperation("数据处理");
        System.out.println("结果: " + result1);
        System.out.println();
        
        // 查看状态
        System.out.println("--- 查看状态 ---");
        System.out.println(service.getStatus());
        System.out.println();
        
        // 第二次调用相同请求 - 从缓存返回
        System.out.println("--- 第二次调用(相同请求) ---");
        String result2 = service.doOperation("数据处理");
        System.out.println("结果: " + result2);
        System.out.println();
        
        // 第三次调用不同请求
        System.out.println("--- 第三次调用(不同请求) ---");
        String result3 = service.doOperation("文件上传");
        System.out.println("结果: " + result3);
    }
}
```

### 5.3 客户端调用流程


```
客户端调用流程图：

客户端                  代理对象                真实对象
  |                       |                       |
  |--[1]创建代理---------->|                       |
  |                       |                       |
  |--[2]调用方法---------->|                       |
  |                       |--[3]权限检查          |
  |                       |--[4]缓存检查          |
  |                       |--[5]创建真实对象----->|
  |                       |--[6]调用真实方法----->|
  |                       |<-[7]返回结果----------|
  |                       |--[8]缓存结果          |
  |                       |--[9]记录日志          |
  |<--[10]返回最终结果-----|                       |
```

### 5.4 使用代理的优势


**🌟 客户端获得的好处**：
- **简化使用**：不需要关心复杂的创建过程
- **性能提升**：缓存和延迟加载提高性能
- **安全保障**：代理提供访问控制和验证
- **功能增强**：获得额外的功能（日志、监控等）

---

## 6. ⚙️ 代理控制机制


### 6.1 访问控制机制


**权限控制的实现**：

```java
public class SecurityProxy implements Subject {
    private RealSubject realSubject;
    private String currentUser;
    private Set<String> allowedUsers;
    
    public SecurityProxy(String currentUser) {
        this.currentUser = currentUser;
        this.allowedUsers = Set.of("admin", "user1", "user2");
    }
    
    @Override
    public String doOperation(String request) {
        // 访问控制检查
        if (!hasPermission(currentUser)) {
            return "访问被拒绝: 用户 " + currentUser + " 无权限";
        }
        
        // 敏感操作额外检查
        if (request.contains("delete") && !isAdmin(currentUser)) {
            return "删除操作被拒绝: 需要管理员权限";
        }
        
        // 通过检查，执行实际操作
        if (realSubject == null) {
            realSubject = new RealSubject("安全服务");
        }
        
        return realSubject.doOperation(request);
    }
    
    private boolean hasPermission(String user) {
        return allowedUsers.contains(user);
    }
    
    private boolean isAdmin(String user) {
        return "admin".equals(user);
    }
}
```

### 6.2 缓存控制机制


**智能缓存策略**：

```java
public class CacheProxy implements Subject {
    private RealSubject realSubject;
    private Map<String, CacheEntry> cache;
    private long cacheTimeout = 30000; // 30秒超时
    
    public CacheProxy() {
        this.cache = new HashMap<>();
    }
    
    @Override
    public String doOperation(String request) {
        String cacheKey = generateCacheKey(request);
        
        // 检查缓存
        CacheEntry entry = cache.get(cacheKey);
        if (entry != null && !entry.isExpired()) {
            System.out.println("缓存命中: " + cacheKey);
            return entry.getValue();
        }
        
        // 缓存未命中，调用真实对象
        if (realSubject == null) {
            realSubject = new RealSubject("缓存服务");
        }
        
        String result = realSubject.doOperation(request);
        
        // 存入缓存
        cache.put(cacheKey, new CacheEntry(result, System.currentTimeMillis()));
        System.out.println("结果已缓存: " + cacheKey);
        
        return result;
    }
    
    private String generateCacheKey(String request) {
        return "cache_" + request.hashCode();
    }
    
    // 缓存条目类
    private static class CacheEntry {
        private String value;
        private long timestamp;
        
        public CacheEntry(String value, long timestamp) {
            this.value = value;
            this.timestamp = timestamp;
        }
        
        public boolean isExpired() {
            return System.currentTimeMillis() - timestamp > 30000;
        }
        
        public String getValue() {
            return value;
        }
    }
}
```

### 6.3 延迟加载控制


**懒汉式对象创建**：

```java
public class LazyProxy implements Subject {
    private RealSubject realSubject;
    private String serviceName;
    private boolean isInitialized = false;
    
    public LazyProxy(String serviceName) {
        this.serviceName = serviceName;
        System.out.println("代理对象创建完成，真实对象尚未创建");
    }
    
    @Override
    public String doOperation(String request) {
        // 延迟创建真实对象
        ensureInitialized();
        return realSubject.doOperation(request);
    }
    
    @Override
    public String getStatus() {
        if (!isInitialized) {
            return serviceName + " (未初始化)";
        }
        return realSubject.getStatus();
    }
    
    private void ensureInitialized() {
        if (!isInitialized) {
            System.out.println("首次访问，正在创建真实对象...");
            // 模拟耗时的初始化过程
            realSubject = new RealSubject(serviceName);
            isInitialized = true;
            System.out.println("真实对象创建完成");
        }
    }
}
```

### 6.4 代理控制的组合使用


**多重代理控制**：

```java
/**
 * 综合代理 - 组合多种控制机制
 */
public class ComprehensiveProxy implements Subject {
    private RealSubject realSubject;
    private SecurityProxy securityProxy;
    private CacheProxy cacheProxy;
    private LazyProxy lazyProxy;
    
    public ComprehensiveProxy(String user, String serviceName) {
        // 创建多层代理
        this.lazyProxy = new LazyProxy(serviceName);
        this.cacheProxy = new CacheProxy();
        this.securityProxy = new SecurityProxy(user);
    }
    
    @Override
    public String doOperation(String request) {
        // 安全检查 -> 缓存检查 -> 延迟加载 -> 实际调用
        return securityProxy.doOperation(request);
    }
    
    @Override
    public String getStatus() {
        return lazyProxy.getStatus();
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 代理模式结构要点


```
🔸 四个核心角色：
• 抽象主题(Subject) - 定义统一接口
• 真实主题(RealSubject) - 实现核心业务
• 代理类(Proxy) - 控制访问和增强功能
• 客户端(Client) - 透明使用服务

🔸 三个关键关系：
• 代理和真实对象实现相同接口
• 代理内部持有真实对象引用
• 客户端通过代理间接访问真实对象
```

### 7.2 设计要点记忆


**🎯 核心设计原则**：
- **接口统一**：代理和真实对象使用相同接口
- **透明访问**：客户端感觉不到代理的存在
- **职责分离**：代理负责控制，真实对象负责业务
- **延迟创建**：需要时才创建真实对象

### 7.3 代理控制机制总结


| 控制类型 | **作用** | **适用场景** | **实现要点** |
|---------|---------|-------------|-------------|
| 🔐 **访问控制** | `权限验证和安全保护` | `敏感操作，用户权限管理` | `前置权限检查` |
| ⚡ **性能优化** | `缓存和延迟加载` | `频繁访问，重复计算` | `结果缓存，懒加载` |
| 📊 **功能增强** | `日志和监控` | `系统监控，行为分析` | `前后置处理` |
| 🛡️ **稳定性保障** | `异常处理和降级` | `网络调用，外部依赖` | `异常捕获和重试` |

### 7.4 实际应用指导


**✅ 何时使用代理模式**：
- 需要控制对象的访问权限
- 对象创建成本很高，需要延迟创建
- 需要在访问对象时添加额外功能
- 需要为远程对象提供本地代表

**❌ 何时不适合使用**：
- 简单对象，不需要额外控制
- 性能要求极高，不能容忍额外开销
- 对象生命周期简单，不需要复杂管理

**核心记忆口诀**：
```
代理模式像中介，控制访问添功能
统一接口保透明，延迟创建省资源
权限缓存加日志，安全性能两不误
```