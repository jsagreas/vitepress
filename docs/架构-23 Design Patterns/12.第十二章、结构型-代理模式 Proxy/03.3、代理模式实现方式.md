---
title: 3、代理模式实现方式
---
## 📚 目录

1. [代理模式实现概述](#1-代理模式实现概述)
2. [静态代理实现](#2-静态代理实现)
3. [动态代理实现](#3-动态代理实现)
4. [JDK动态代理详解](#4-JDK动态代理详解)
5. [CGLIB代理技术](#5-CGLIB代理技术)
6. [字节码增强技术](#6-字节码增强技术)
7. [实现方式对比分析](#7-实现方式对比分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 代理模式实现概述


### 1.1 什么是代理模式的实现方式


**通俗理解**：就像生活中的中介一样，代理模式的实现方式就是"如何创建这个中介"的不同方法。

```
生活中的例子：
房产中介 = 代理对象
房东     = 真实对象
租客     = 客户端

创建中介的方式：
方式1：提前安排好的专职中介 (静态代理)
方式2：临时找的万能中介     (动态代理)
```

### 1.2 实现方式分类


**🔸 按创建时机分类**
```
编译时确定：静态代理
运行时生成：动态代理
```

**🔸 按技术手段分类**
```
接口代理：JDK动态代理
类代理：  CGLIB代理
字节码：  ASM、Javassist等
```

### 1.3 各种实现方式的特点对比


| 实现方式 | **创建时机** | **代理目标** | **性能** | **灵活性** |
|---------|------------|-------------|---------|-----------|
| `静态代理` | `编译时` | `接口/类` | `🟢高` | `🔴低` |
| `JDK动态代理` | `运行时` | `接口` | `🟡中` | `🟢高` |
| `CGLIB代理` | `运行时` | `类` | `🟡中` | `🟢高` |
| `字节码增强` | `运行时` | `任意` | `🟢高` | `🟢极高` |

---

## 2. 📝 静态代理实现


### 2.1 静态代理是什么


**简单理解**：静态代理就像**事先约定好的专职助理**，在写代码时就明确知道要代理哪个对象。

```
比如：你有一个专门的司机（代理）
- 这个司机只为你一个人服务
- 司机的工作内容在雇佣时就确定了
- 换个老板就需要重新找司机
```

### 2.2 静态代理实现步骤


**Step ① 定义接口（规范）**
```java
// 定义服务接口 - 就像定义"司机的工作职责"
public interface UserService {
    void login(String username, String password);
    String getUserInfo(String username);
}
```

**Step ② 实现真实对象（实际工作者）**
```java
// 真实服务类 - 就像"实际干活的人"
public class UserServiceImpl implements UserService {
    
    @Override
    public void login(String username, String password) {
        System.out.println("用户登录：" + username);
        // 实际的登录逻辑
    }
    
    @Override
    public String getUserInfo(String username) {
        System.out.println("获取用户信息：" + username);
        return "用户详细信息";
    }
}
```

**Step ③ 创建代理类（中介）**
```java
// 代理类 - 就像"负责任的助理"
public class UserServiceProxy implements UserService {
    private UserService userService;  // 持有真实对象的引用
    
    public UserServiceProxy(UserService userService) {
        this.userService = userService;
    }
    
    @Override
    public void login(String username, String password) {
        // 代理增强：登录前的检查
        System.out.println("🔒 登录前安全检查...");
        
        // 调用真实对象
        userService.login(username, password);
        
        // 代理增强：登录后的日志
        System.out.println("📝 记录登录日志");
    }
    
    @Override
    public String getUserInfo(String username) {
        // 代理增强：权限检查
        if (!checkPermission(username)) {
            return "权限不足";
        }
        
        // 调用真实对象
        return userService.getUserInfo(username);
    }
    
    private boolean checkPermission(String username) {
        // 简单的权限检查逻辑
        return !"guest".equals(username);
    }
}
```

**Step ④ 使用代理**
```java
public class StaticProxyDemo {
    public static void main(String[] args) {
        // 创建真实对象
        UserService realService = new UserServiceImpl();
        
        // 创建代理对象
        UserService proxyService = new UserServiceProxy(realService);
        
        // 通过代理访问服务
        proxyService.login("admin", "123456");
        String info = proxyService.getUserInfo("admin");
        System.out.println(info);
    }
}
```

### 2.3 静态代理的优缺点


**✅ 优点**
```
🔸 简单直观：代码清晰，容易理解
🔸 性能好：编译时确定，没有反射开销
🔸 类型安全：编译期就能发现类型错误
```

**❌ 缺点**
```
🔸 代码冗余：每个接口都需要写一个代理类
🔸 维护困难：接口变化时，代理类也要同步修改
🔸 灵活性差：不能动态地改变代理行为
```

---

## 3. 🚀 动态代理实现


### 3.1 动态代理是什么


**通俗理解**：动态代理就像**万能助理**，在程序运行时临时生成代理对象，一个助理可以代理不同的老板。

```
静态代理 vs 动态代理：

静态代理：
专职司机 → 只能为张三开车
专职秘书 → 只能为李四工作

动态代理：
万能助理 → 可以为任何人服务
          根据需要临时学会不同技能
```

### 3.2 动态代理的工作原理


**核心机制**：
```
运行时字节码生成流程：

Step 1: 分析目标接口
        ↓
Step 2: 动态生成代理类的字节码  
        ↓
Step 3: 加载代理类到JVM
        ↓
Step 4: 创建代理实例
        ↓
Step 5: 拦截方法调用
```

### 3.3 动态代理的两大实现技术


**🔸 JDK动态代理**
```
特点：基于接口实现
原理：生成实现接口的代理类
限制：目标对象必须实现接口
```

**🔸 CGLIB动态代理**
```
特点：基于继承实现  
原理：生成目标类的子类
优势：不需要接口，可以代理普通类
```

---

## 4. 💎 JDK动态代理详解


### 4.1 JDK动态代理工作机制


**核心组件**：
```
Proxy类：         代理工厂，负责生成代理对象
InvocationHandler：调用处理器，定义代理逻辑
Method：          被代理的方法对象
```

**工作流程图**：
```
客户端调用          代理对象          InvocationHandler     真实对象
    |                  |                     |                |
    |--调用方法-------->|                     |                |
    |                  |--invoke()---------->|                |
    |                  |                     |--处理逻辑----->|
    |                  |                     |<--返回结果-----|
    |                  |<--返回结果----------|                |
    |<--返回结果--------|                     |                |
```

### 4.2 JDK动态代理实现步骤


**Step ① 定义调用处理器**
```java
// 通用的调用处理器 - 就像"万能翻译官"
public class ProxyInvocationHandler implements InvocationHandler {
    private Object target;  // 被代理的真实对象
    
    public ProxyInvocationHandler(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) 
            throws Throwable {
        
        // 前置增强
        System.out.println("🔍 方法调用前：" + method.getName());
        long startTime = System.currentTimeMillis();
        
        // 调用真实对象的方法
        Object result = method.invoke(target, args);
        
        // 后置增强
        long endTime = System.currentTimeMillis();
        System.out.println("⏱️ 方法执行耗时：" + (endTime - startTime) + "ms");
        
        return result;
    }
}
```

**Step ② 创建代理工厂**
```java
// 代理工厂类 - 专门负责"生产万能助理"
public class ProxyFactory {
    
    public static <T> T createProxy(T target) {
        return (T) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),    // 类加载器
            target.getClass().getInterfaces(),     // 接口数组
            new ProxyInvocationHandler(target)     // 调用处理器
        );
    }
}
```

**Step ③ 使用动态代理**
```java
public class JDKProxyDemo {
    public static void main(String[] args) {
        // 创建真实对象
        UserService realService = new UserServiceImpl();
        
        // 创建动态代理对象
        UserService proxyService = ProxyFactory.createProxy(realService);
        
        // 使用代理对象
        proxyService.login("admin", "123456");
        String info = proxyService.getUserInfo("admin");
        
        System.out.println("代理对象类型：" + proxyService.getClass().getName());
        // 输出类似：com.sun.proxy.$Proxy0
    }
}
```

### 4.3 JDK动态代理的限制


**⚠️ 重要限制**
```
只能代理接口：目标对象必须实现接口
不能代理类：无法直接代理具体的类
不能代理final方法：final方法无法被重写
```

**为什么有这些限制？**
```
JDK动态代理的原理：
生成的代理类继承了Proxy类，由于Java单继承限制，
只能通过实现接口的方式来代理目标对象。
```

---

## 5. 🛠️ CGLIB代理技术


### 5.1 CGLIB是什么


**CGLIB全称**：Code Generation Library（代码生成库）

**通俗理解**：CGLIB就像一个"克隆专家"，可以克隆任何类并增强其功能。

```
JDK动态代理 vs CGLIB：

JDK动态代理：
- 只能代理有接口的类
- 就像只能为"有合同的员工"安排助理

CGLIB：
- 可以代理任何类（除了final类）
- 就像可以为"任何人"培养一个学徒
```

### 5.2 CGLIB工作原理


**核心机制**：
```
CGLIB代理原理：

1. 分析目标类
   ↓
2. 生成目标类的子类字节码
   ↓  
3. 重写父类的方法
   ↓
4. 在重写的方法中添加代理逻辑
   ↓
5. 创建子类实例作为代理对象
```

**类关系图**：
```
    原始类 (UserService)
         ↑
         |（继承）
    代理类 (UserService$$EnhancerByCGLIB$$12345)
```

### 5.3 CGLIB实现步骤


**Step ① 添加CGLIB依赖**
```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>
```

**Step ② 创建目标类（无需接口）**
```java
// 普通的类，不需要实现接口
public class UserServiceImpl {
    
    public void login(String username, String password) {
        System.out.println("用户登录：" + username);
    }
    
    public String getUserInfo(String username) {
        System.out.println("获取用户信息：" + username);
        return "用户详细信息";
    }
}
```

**Step ③ 实现方法拦截器**
```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

// 方法拦截器 - 就像"学徒的学习指南"
public class CglibMethodInterceptor implements MethodInterceptor {
    
    @Override
    public Object intercept(Object obj, Method method, Object[] args, 
                          MethodProxy proxy) throws Throwable {
        
        // 前置增强
        System.out.println("🔍 CGLIB前置通知：" + method.getName());
        
        // 调用父类方法（原始方法）
        Object result = proxy.invokeSuper(obj, args);
        
        // 后置增强  
        System.out.println("✅ CGLIB后置通知：方法执行完成");
        
        return result;
    }
}
```

**Step ④ 创建CGLIB代理工厂**
```java
import net.sf.cglib.proxy.Enhancer;

// CGLIB代理工厂
public class CglibProxyFactory {
    
    public static <T> T createProxy(Class<T> targetClass) {
        // 创建增强器
        Enhancer enhancer = new Enhancer();
        
        // 设置父类（被代理的类）
        enhancer.setSuperclass(targetClass);
        
        // 设置回调（方法拦截器）
        enhancer.setCallback(new CglibMethodInterceptor());
        
        // 创建代理对象
        return (T) enhancer.create();
    }
}
```

**Step ⑤ 使用CGLIB代理**
```java
public class CglibProxyDemo {
    public static void main(String[] args) {
        // 创建CGLIB代理对象
        UserServiceImpl proxyService = 
            CglibProxyFactory.createProxy(UserServiceImpl.class);
        
        // 使用代理对象
        proxyService.login("admin", "123456");
        String info = proxyService.getUserInfo("admin");
        
        System.out.println("代理对象类型：" + proxyService.getClass().getName());
        // 输出类似：UserServiceImpl$$EnhancerByCGLIB$$12345
    }
}
```

### 5.4 CGLIB的优缺点


**✅ 优点**
```
🔸 无需接口：可以代理普通类
🔸 功能强大：支持各种代理策略
🔸 性能较好：比反射调用快
```

**❌ 缺点**
```
🔸 依赖库：需要额外的CGLIB库
🔸 不能代理final：final类和方法无法代理
🔸 创建开销：代理对象创建时间较长
```

---

## 6. ⚡ 字节码增强技术


### 6.1 字节码增强是什么


**通俗理解**：字节码增强就像"程序改造专家"，直接修改编译后的字节码文件，添加新功能。

```
比喻说明：
源代码     → 房屋设计图
字节码     → 建好的房子  
字节码增强 → 对房子进行装修改造

优势：不需要源代码，直接改造"成品"
```

### 6.2 常用字节码增强工具


**🔸 ASM**
```
特点：底层API，操作字节码指令
优势：性能极高，功能强大
难度：🔴高 - 需要深入了解JVM字节码
```

**🔸 Javassist**  
```
特点：高层API，类似Java语法
优势：简单易用，学习成本低
难度：🟡中 - 有Java基础即可上手
```

**🔸 Byte Buddy**
```
特点：现代化API，链式调用
优势：功能强大且易用
难度：🟢低 - API设计友好
```

### 6.3 Javassist简单示例


**Step ① 添加依赖**
```xml
<dependency>
    <groupId>org.javassist</groupId>
    <artifactId>javassist</artifactId>
    <version>3.28.0-GA</version>
</dependency>
```

**Step ② 字节码增强示例**
```java
import javassist.*;

public class JavassistDemo {
    public static void main(String[] args) throws Exception {
        // 获取类池
        ClassPool pool = ClassPool.getDefault();
        
        // 获取目标类
        CtClass ctClass = pool.get("UserServiceImpl");
        
        // 获取目标方法
        CtMethod method = ctClass.getDeclaredMethod("login");
        
        // 在方法前插入代码
        method.insertBefore("System.out.println(\"🔍 字节码增强：方法调用前\");");
        
        // 在方法后插入代码  
        method.insertAfter("System.out.println(\"✅ 字节码增强：方法调用后\");");
        
        // 将修改后的类转换为Class对象
        Class<?> modifiedClass = ctClass.toClass();
        
        // 创建实例并使用
        Object instance = modifiedClass.newInstance();
        Method loginMethod = modifiedClass.getMethod("login", String.class, String.class);
        loginMethod.invoke(instance, "admin", "123456");
    }
}
```

### 6.4 字节码增强的应用场景


**🎯 实际应用**
```
🔸 AOP框架：Spring AOP的实现原理
🔸 性能监控：方法执行时间统计
🔸 热部署：不重启服务更新代码
🔸 代码插桩：自动添加日志、监控代码
🔸 框架开发：ORM框架的实体增强
```

---

## 7. 📊 实现方式对比分析


### 7.1 性能对比分析


| 实现方式 | **创建耗时** | **调用耗时** | **内存占用** | **适用场景** |
|---------|------------|-------------|-------------|-------------|
| `静态代理` | `🟢极快` | `🟢极快` | `🟢最少` | `固定代理逻辑` |
| `JDK动态代理` | `🟡中等` | `🟡中等` | `🟡中等` | `基于接口的代理` |
| `CGLIB代理` | `🔴较慢` | `🟢较快` | `🟡中等` | `基于类的代理` |
| `字节码增强` | `🔴慢` | `🟢极快` | `🟢少` | `复杂增强逻辑` |

### 7.2 功能特性对比


```
代理目标支持：
├── 静态代理      ✅接口 ✅类 ✅final方法
├── JDK动态代理   ✅接口 ❌类 ❌final方法  
├── CGLIB代理     ✅接口 ✅类 ❌final方法
└── 字节码增强    ✅接口 ✅类 ✅final方法

代理灵活性：
├── 静态代理      🔴低 - 编译时确定
├── JDK动态代理   🟢高 - 运行时生成
├── CGLIB代理     🟢高 - 运行时生成
└── 字节码增强    🟢极高 - 任意修改
```

### 7.3 使用场景选择指南


**🎯 选择策略**

```
选择静态代理 when：
✅ 代理逻辑简单且固定
✅ 对性能要求极高
✅ 代理的接口很少

选择JDK动态代理 when：
✅ 目标对象有接口
✅ 需要通用的代理逻辑
✅ Spring环境（默认选择）

选择CGLIB代理 when：
✅ 目标对象没有接口
✅ 需要代理第三方类
✅ 不能修改目标类

选择字节码增强 when：
✅ 需要复杂的增强逻辑
✅ 对性能要求很高
✅ 需要修改final方法
```

### 7.4 实际项目中的选择


**🏢 Spring框架的选择策略**
```
Spring AOP代理选择逻辑：

if (目标对象实现了接口) {
    使用JDK动态代理;
} else {
    使用CGLIB代理;
}

可以通过配置强制使用CGLIB：
<aop:aspectj-autoproxy proxy-target-class="true"/>
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 静态代理：编译时确定，一对一关系，性能最好
🔸 JDK动态代理：运行时生成，基于接口，通用性强
🔸 CGLIB代理：运行时生成，基于继承，无需接口
🔸 字节码增强：直接修改字节码，功能最强大
```

### 8.2 关键理解要点


**🔹 代理的本质**
```
所有代理实现方式的核心都是：
在不修改原始类的前提下，为其添加额外功能

实现手段不同：
- 静态：手工编写代理类
- 动态：运行时自动生成代理类  
- 字节码：直接修改类的字节码
```

**🔹 性能vs灵活性的权衡**
```
性能：静态代理 > 字节码增强 > CGLIB > JDK动态代理
灵活性：字节码增强 > CGLIB ≈ JDK动态代理 > 静态代理

选择原则：根据实际需求在性能和灵活性之间找平衡
```

**🔹 实际应用建议**
```
企业级开发推荐：
🥇 首选：JDK动态代理（Spring默认）
🥈 次选：CGLIB代理（无接口时）
🥉 特殊场景：字节码增强（性能要求极高）
🏅 简单场景：静态代理（代理逻辑固定）
```

### 8.3 学习建议和最佳实践


**💡 学习路径**
```
Step 1: 掌握静态代理 → 理解代理的基本概念
Step 2: 学习JDK动态代理 → 理解反射和动态生成  
Step 3: 了解CGLIB → 理解继承方式的代理
Step 4: 接触字节码技术 → 理解底层实现原理
```

**🛠️ 实践建议**
```
🔸 多写代码：每种方式都要亲手实现一遍
🔸 性能测试：对比不同方式的性能差异
🔸 源码阅读：研究Spring AOP的实现原理
🔸 实际应用：在项目中应用AOP思想
```

**核心记忆要点**：
- 静态代理编译定，一对一来性能赢
- JDK动态要接口，反射生成很通用  
- CGLIB继承无接口，字节码增强最全能
- 选择策略看场景，性能灵活需平衡