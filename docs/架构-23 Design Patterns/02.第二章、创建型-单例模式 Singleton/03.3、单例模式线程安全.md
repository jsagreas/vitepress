---
title: 3、单例模式线程安全
---
## 📚 目录

1. [多线程问题的发现](#1-多线程问题的发现)
2. [线程安全解决方案](#2-线程安全解决方案)
3. [volatile关键字的作用](#3-volatile关键字的作用)
4. [性能与安全的平衡](#4-性能与安全的平衡)
5. [最佳实践推荐](#5-最佳实践推荐)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🚨 多线程问题的发现


### 1.1 问题场景重现


想象这样一个场景：你在公司里负责管理打印机，按照单例模式的思想，整个公司应该只有一台打印机对象。但是如果多个同事同时去"创建"这台打印机会发生什么？

```
时间线：同时进行
员工A: 检查是否有打印机 → 没有 → 准备创建
员工B: 检查是否有打印机 → 没有 → 准备创建
员工A: 创建打印机对象A
员工B: 创建打印机对象B

结果：公司里出现了两台打印机！
```

### 1.2 代码层面的问题


我们用最简单的单例代码来看这个问题：

```java
public class SimpleSingleton {
    private static SimpleSingleton instance;
    
    public static SimpleSingleton getInstance() {
        if (instance == null) {          // 🚨 危险区域
            instance = new SimpleSingleton();  // 🚨 可能被执行多次
        }
        return instance;
    }
}
```

**🔸 问题分析**
```
线程1执行路径：
1. 检查 instance == null (结果是true)
2. 准备执行 new SimpleSingleton()

线程2执行路径：
1. 在线程1还没完成创建时，也检查 instance == null (结果还是true)
2. 也准备执行 new SimpleSingleton()

最终结果：两个线程都创建了对象，违反了单例原则
```

### 1.3 实际验证


我们用一个简单的测试来证明这个问题：

```java
public class ThreadTest {
    public static void main(String[] args) {
        // 创建10个线程同时获取单例
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                SimpleSingleton singleton = SimpleSingleton.getInstance();
                System.out.println("对象地址: " + singleton.hashCode());
            }).start();
        }
    }
}

// 可能的输出结果：
// 对象地址: 123456789  ← 第一个对象
// 对象地址: 987654321  ← 第二个对象！出现了多个实例
// 对象地址: 123456789
// ...
```

> ⚠️ **重要提醒**  
> 在单线程环境下，简单的单例实现完全没问题。但在多线程环境下，就会出现"竞态条件"，导致创建多个实例。

---

## 2. 🔧 线程安全解决方案


### 2.1 方案一：同步方法（最直接的解决方案）


**🔸 基本思路**：给整个`getInstance()`方法加锁，确保同一时间只有一个线程能执行

```java
public class SynchronizedSingleton {
    private static SynchronizedSingleton instance;
    
    // 关键字synchronized确保同一时间只有一个线程能进入
    public static synchronized SynchronizedSingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
}
```

**🔸 工作原理图解**
```
时间线：
线程1: 进入方法(获得锁) → 检查 → 创建对象 → 返回 → 释放锁
线程2:        等待锁      → 进入方法 → 检查(已不为null) → 直接返回
线程3:           等待锁         → 进入方法 → 检查(已不为null) → 直接返回
```

**🔸 优缺点分析**

✅ **优点**：
- 实现简单，代码易懂
- 100%线程安全
- 不会创建多个实例

❌ **缺点**：
- 每次调用都要获取锁，性能较差
- 即使对象已经创建，后续调用仍需同步

### 2.2 方案二：双重检查锁定（性能与安全兼顾）


**🔸 设计思路**：只在真正需要创建对象时才同步，减少锁的使用

```java
public class DoubleCheckSingleton {
    private static DoubleCheckSingleton instance;
    
    public static DoubleCheckSingleton getInstance() {
        // 第一次检查：如果已经创建，直接返回，无需同步
        if (instance == null) {
            synchronized (DoubleCheckSingleton.class) {
                // 第二次检查：防止多个线程同时通过第一次检查
                if (instance == null) {
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
```

**🔸 为什么需要两次检查？**

让我们用通俗的例子来理解：

```
场景：图书馆里只能有一本特殊的书

第一次检查：
- 目的：避免不必要的排队
- 逻辑：如果书已经在那了，直接拿走，不用排队

第二次检查：
- 目的：防止重复购买
- 逻辑：排队进入书店后，再次确认是否真的需要买书
- 可能性：你排队时，前面的人可能已经买了这本书
```

### 2.3 方案三：静态内部类（推荐方案）


**🔸 设计思路**：利用JVM的类加载机制保证线程安全

```java
public class StaticInnerSingleton {
    
    // 私有静态内部类
    private static class SingletonHolder {
        // 在这里创建单例实例
        private static final StaticInnerSingleton INSTANCE = new StaticInnerSingleton();
    }
    
    // 对外提供获取实例的方法
    public static StaticInnerSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**🔸 为什么这种方式是线程安全的？**

> 💡 **JVM类加载机制**  
> Java虚拟机在加载类时，会确保类的初始化过程是线程安全的。即使多个线程同时访问，JVM也会保证类只被初始化一次。

**工作流程**：
```
1. 调用getInstance()方法
2. 访问SingletonHolder.INSTANCE
3. JVM发现SingletonHolder类还没加载
4. JVM加载SingletonHolder类（线程安全）
5. 执行static代码，创建INSTANCE对象
6. 返回INSTANCE对象

后续调用：直接返回已创建的INSTANCE，无需同步
```

### 2.4 方案四：枚举实现（最安全的方案）


```java
public enum EnumSingleton {
    INSTANCE;
    
    public void doSomething() {
        System.out.println("枚举单例正在工作");
    }
}

// 使用方式
EnumSingleton singleton = EnumSingleton.INSTANCE;
singleton.doSomething();
```

**🔸 枚举的优势**
- 天然线程安全
- 防止反射攻击
- 防止序列化破坏
- 代码最简洁

---

## 3. 🔄 volatile关键字的作用


### 3.1 指令重排序问题


在双重检查锁定中，我们还需要考虑一个隐藏的问题：**指令重排序**

```java
// 这行看似简单的代码
instance = new DoubleCheckSingleton();

// 实际上包含三个步骤：
// 1. 分配内存空间
// 2. 初始化对象
// 3. 将内存地址赋值给instance变量

// 问题：JVM可能会重排序为：
// 1. 分配内存空间
// 3. 将内存地址赋值给instance变量  ← 提前赋值
// 2. 初始化对象                    ← 对象还没初始化完成
```

### 3.2 问题场景


```
时间线：
线程1: 执行new操作 → 分配内存 → 赋值给instance → 正在初始化对象...
线程2: 检查instance != null (true) → 直接返回instance → 使用未完成初始化的对象！
```

### 3.3 volatile的解决方案


```java
public class VolatileSingleton {
    // 添加volatile关键字
    private static volatile VolatileSingleton instance;
    
    public static VolatileSingleton getInstance() {
        if (instance == null) {
            synchronized (VolatileSingleton.class) {
                if (instance == null) {
                    instance = new VolatileSingleton();
                }
            }
        }
        return instance;
    }
}
```

**🔸 volatile的作用**

> 💡 **通俗理解**  
> volatile就像给变量贴了一个"小心轻放"的标签，告诉JVM：
> 1. 不要随意重排序这个变量相关的操作
> 2. 修改后要立即通知所有线程
> 3. 读取时要从主内存读取最新值

---

## 4. ⚖️ 性能与安全的平衡


### 4.1 性能对比分析


| 实现方式 | **线程安全** | **性能** | **复杂度** | **推荐指数** |
|---------|------------|----------|-----------|-------------|
| 🔸 **简单实现** | `❌ 不安全` | `⭐⭐⭐⭐⭐` | `⭐` | `❌ 不推荐` |
| 🔸 **同步方法** | `✅ 安全` | `⭐⭐` | `⭐⭐` | `⭐⭐` |
| 🔸 **双重检查** | `✅ 安全` | `⭐⭐⭐⭐` | `⭐⭐⭐⭐` | `⭐⭐⭐` |
| 🔸 **静态内部类** | `✅ 安全` | `⭐⭐⭐⭐⭐` | `⭐⭐⭐` | `⭐⭐⭐⭐⭐` |
| 🔸 **枚举实现** | `✅ 安全` | `⭐⭐⭐⭐⭐` | `⭐⭐` | `⭐⭐⭐⭐` |

### 4.2 选择建议


**🎯 根据实际需求选择**

```
高性能要求 + 懒加载：
→ 选择静态内部类实现

简单可靠 + 防攻击：
→ 选择枚举实现

学习理解 + 面试准备：
→ 掌握双重检查锁定

快速原型 + 单线程：
→ 简单实现即可
```

### 4.3 实际使用考量


**🔸 业务场景分析**
```
Web应用：通常是多线程环境
→ 必须考虑线程安全

桌面应用：可能是单线程
→ 简单实现就够了

高并发系统：性能要求高
→ 静态内部类是最佳选择

框架开发：安全性第一
→ 枚举实现最可靠
```

---

## 5. 🚀 最佳实践推荐


### 5.1 生产环境推荐实现


```java
/**
 * 🏆 推荐的单例实现方式
 * - 线程安全
 * - 懒加载
 * - 高性能
 * - 代码简洁
 */
public class BestPracticeSingleton {
    
    // 私有构造函数，防止外部创建实例
    private BestPracticeSingleton() {
        // 防止反射攻击
        if (SingletonHolder.INSTANCE != null) {
            throw new RuntimeException("单例对象不能重复创建");
        }
    }
    
    // 静态内部类实现懒加载
    private static class SingletonHolder {
        private static final BestPracticeSingleton INSTANCE = 
            new BestPracticeSingleton();
    }
    
    // 对外提供获取实例的方法
    public static BestPracticeSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    // 业务方法
    public void doWork() {
        System.out.println("单例对象正在工作...");
    }
}
```

### 5.2 使用注意事项


**🔸 构造函数设计**
```java
private BestPracticeSingleton() {
    // ✅ 推荐：添加初始化逻辑
    initializeResources();
    
    // ✅ 推荐：添加防御性代码
    if (SingletonHolder.INSTANCE != null) {
        throw new RuntimeException("不允许重复创建");
    }
}
```

**🔸 序列化处理**
```java
// 如果单例需要序列化，添加这个方法
private Object readResolve() {
    return getInstance();  // 确保反序列化时返回同一个实例
}
```

### 5.3 测试验证


```java
public class SingletonTest {
    public static void main(String[] args) throws InterruptedException {
        // 测试多线程安全性
        testThreadSafety();
        
        // 测试单例特性
        testSingletonProperty();
    }
    
    private static void testThreadSafety() throws InterruptedException {
        Set<Integer> hashCodes = new ConcurrentHashMap<Integer, Boolean>().keySet(ConcurrentHashMap.newKeySet());
        
        // 创建100个线程同时获取单例
        CountDownLatch latch = new CountDownLatch(100);
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                BestPracticeSingleton singleton = BestPracticeSingleton.getInstance();
                hashCodes.add(singleton.hashCode());
                latch.countDown();
            }).start();
        }
        
        latch.await();
        
        // 验证结果：应该只有一个不同的hashCode
        System.out.println("不同实例数量: " + hashCodes.size());
        System.out.println(hashCodes.size() == 1 ? "✅ 线程安全测试通过" : "❌ 线程安全测试失败");
    }
    
    private static void testSingletonProperty() {
        BestPracticeSingleton instance1 = BestPracticeSingleton.getInstance();
        BestPracticeSingleton instance2 = BestPracticeSingleton.getInstance();
        
        System.out.println(instance1 == instance2 ? "✅ 单例特性验证通过" : "❌ 单例特性验证失败");
    }
}
```

---

## 6. 📋 核心要点总结


### 6.1 关键理解要点


**🔸 线程安全问题的本质**
```
多线程同时执行检查代码 → 可能同时发现instance为null → 同时创建对象
解决思路：确保同一时间只有一个线程能执行创建逻辑
```

**🔸 各种解决方案的核心思想**
- **同步方法**: 简单粗暴，每次都加锁
- **双重检查**: 聪明做法，只在需要时加锁  
- **静态内部类**: 利用JVM机制，优雅且高效
- **枚举实现**: 最安全，但使用场景有限

**🔸 volatile的重要性**
```
防止指令重排序 → 确保对象完全初始化后才赋值给instance变量
内存可见性 → 确保一个线程的修改能被其他线程立即看到
```

### 6.2 实际应用建议


**🎯 选择标准**
```
新手学习：从同步方法开始理解
实际项目：优先选择静态内部类
面试准备：重点掌握双重检查锁定
框架开发：考虑枚举实现
```

**🔧 实现要点**
- 私有构造函数防止外部创建
- 考虑序列化和反射攻击
- 添加必要的测试验证
- 选择适合业务场景的实现方式

### 6.3 学习检查清单


- [ ] **理解问题**: 能说出多线程环境下单例的问题
- [ ] **掌握方案**: 知道至少3种线程安全的实现方式
- [ ] **理解volatile**: 明白为什么双重检查需要volatile
- [ ] **会选择**: 能根据场景选择合适的实现方式
- [ ] **能实现**: 可以写出线程安全的单例代码
- [ ] **会测试**: 知道如何验证实现的正确性

> 🎯 **核心记忆**  
> 单例模式在多线程环境下容易出现"竞态条件"，导致创建多个实例。解决方法是通过同步机制确保同一时间只有一个线程能执行创建逻辑。静态内部类是最推荐的实现方式，它结合了懒加载、线程安全和高性能的优点。

**记忆口诀**: "多线程来了要小心，同步机制保安全，静态内部最优雅，枚举实现最可靠"