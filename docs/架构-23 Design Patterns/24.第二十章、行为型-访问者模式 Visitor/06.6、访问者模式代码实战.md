---
title: 6、访问者模式代码实战
---
## 📚 目录

1. [访问者模式基本概念](#1-访问者模式基本概念)
2. [核心角色与结构](#2-核心角色与结构)
3. [工作原理详解](#3-工作原理详解)
4. [实现方式与代码示例](#4-实现方式与代码示例)
5. [典型应用场景](#5-典型应用场景)
6. [优缺点分析](#6-优缺点分析)
7. [与其他模式的关系](#7-与其他模式的关系)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 访问者模式基本概念


### 1.1 什么是访问者模式


**🔸 生活中的例子**
```
想象一个医院体检的场景：
病人（数据结构）需要做各种检查：
• 内科医生（访问者A）→ 听诊、问诊
• 外科医生（访问者B）→ 检查外伤、触诊  
• 眼科医生（访问者C）→ 视力检查、眼底检查

同一个病人，不同的医生有不同的检查方法
这就是访问者模式的核心思想！
```

**📋 正式定义**
> **访问者模式（Visitor Pattern）**：表示一个作用于某对象结构中各元素的操作。它让你在不改变各元素类的前提下定义作用于这些元素的新操作。

**🎯 核心思想**
- **数据与操作分离**：把数据结构和操作逻辑分开
- **双重分派机制**：根据访问者类型和元素类型决定调用哪个方法
- **开放封闭原则**：对扩展开放（新增访问者），对修改封闭（不改元素类）

### 1.2 为什么需要访问者模式


**❗ 传统方式的问题**
```
假设我们有一个文件系统，包含文件和文件夹
如果要添加新功能（比如计算大小、病毒扫描、压缩等）

传统做法：
class File {
    void calculateSize() { ... }      // 功能1
    void virusScan() { ... }          // 功能2  
    void compress() { ... }           // 功能3
    // 每次新增功能都要修改这个类！
}

问题：
• 违反开放封闭原则
• 类变得臃肿
• 职责不清晰
```

**✨ 访问者模式的解决方案**
```
使用访问者模式：
• File类只负责存储文件信息
• SizeCalculatorVisitor专门计算大小
• VirusScanVisitor专门病毒扫描
• CompressVisitor专门压缩

优势：
• 新增功能只需要新增访问者
• 原有类不需要修改
• 每个访问者职责单一
```

---

## 2. 🏗️ 核心角色与结构


### 2.1 角色划分


**访问者模式包含4个核心角色：**

```
📊 角色关系图：
                 Client
                    |
            ┌───────┴───────┐
            ↓               ↓
    ObjectStructure    ConcreteVisitor
            |               ↑
            ↓               |
        Element ────────→ Visitor
            ↑               (接口)
            |
     ConcreteElement
```

### 2.2 各角色详细说明


**🔸 访问者接口（Visitor）**
```java
// 定义访问不同元素类型的方法
interface Visitor {
    void visitFile(File file);           // 访问文件
    void visitDirectory(Directory dir);  // 访问目录
}
```
- **作用**：定义访问各种元素的操作接口
- **特点**：每种元素类型对应一个visit方法

**🔸 具体访问者（ConcreteVisitor）**
```java
// 大小计算访问者
class SizeCalculatorVisitor implements Visitor {
    private long totalSize = 0;
    
    public void visitFile(File file) {
        totalSize += file.getSize();
        System.out.println("文件: " + file.getName() + ", 大小: " + file.getSize());
    }
    
    public void visitDirectory(Directory dir) {
        System.out.println("进入目录: " + dir.getName());
        // 目录本身大小为0
    }
    
    public long getTotalSize() { return totalSize; }
}
```
- **作用**：实现具体的访问操作
- **特点**：每个访问者实现不同的业务逻辑

**🔸 元素接口（Element）**
```java
// 元素接口
interface Element {
    void accept(Visitor visitor);  // 接受访问者
}
```
- **作用**：定义接受访问者的接口
- **特点**：通过accept方法实现双重分派

**🔸 具体元素（ConcreteElement）**
```java
// 文件元素
class File implements Element {
    private String name;
    private long size;
    
    public File(String name, long size) {
        this.name = name;
        this.size = size;
    }
    
    public void accept(Visitor visitor) {
        visitor.visitFile(this);  // 关键：调用访问者的对应方法
    }
    
    // getter方法...
}
```
- **作用**：具体的数据结构
- **特点**：accept方法中调用访问者的对应visit方法

**🔸 对象结构（ObjectStructure）**
```java
// 文件系统结构
class FileSystem {
    private List<Element> elements = new ArrayList<>();
    
    public void addElement(Element element) {
        elements.add(element);
    }
    
    public void accept(Visitor visitor) {
        for (Element element : elements) {
            element.accept(visitor);  // 让每个元素接受访问
        }
    }
}
```
- **作用**：管理元素集合，提供遍历接口
- **特点**：可以是复合结构（如树、列表等）

---

## 3. ⚙️ 工作原理详解


### 3.1 双重分派机制


**🤔 什么是双重分派？**

双重分派是访问者模式的核心机制，它根据**两个对象的类型**来决定调用哪个方法。

```
执行流程解析：
                Client
                  |
                  ↓ 1. 调用
        fileSystem.accept(sizeVisitor)
                  |
                  ↓ 2. 遍历元素
           element.accept(sizeVisitor)
                  |
                  ↓ 3. 第一次分派（根据元素类型）
              file.accept(visitor)
                  |
                  ↓ 4. 第二次分派（根据访问者类型）
          visitor.visitFile(this)
                  |
                  ↓ 5. 执行具体操作
        SizeCalculatorVisitor.visitFile()
```

### 3.2 分派过程详解


**第一次分派**：根据元素的实际类型
```java
// 调用时不知道具体是File还是Directory
element.accept(visitor);

// 运行时根据element的实际类型分派：
// 如果是File → 调用File.accept()
// 如果是Directory → 调用Directory.accept()
```

**第二次分派**：根据访问者的实际类型
```java
// 在File.accept()中
public void accept(Visitor visitor) {
    visitor.visitFile(this);  // 根据visitor的实际类型分派
}

// 运行时根据visitor的实际类型分派：
// 如果是SizeCalculatorVisitor → 调用SizeCalculatorVisitor.visitFile()
// 如果是VirusScanVisitor → 调用VirusScanVisitor.visitFile()
```

**💡 为什么需要双重分派？**
- **单分派的局限**：Java默认只支持单分派（根据一个对象的类型分派）
- **需求复杂性**：我们需要根据"元素类型"和"访问者类型"两个维度来决定行为
- **灵活性要求**：同样的元素，不同的访问者有不同的处理方式

---

## 4. 💻 实现方式与代码示例


### 4.1 完整示例：文件系统分析器


**🔥 重要程度**: ⭐⭐⭐ **必须掌握**

让我们通过一个完整的文件系统例子来理解访问者模式：

```java
// 1. 访问者接口
interface FileSystemVisitor {
    void visitFile(File file);
    void visitDirectory(Directory directory);
}

// 2. 元素接口
interface FileSystemElement {
    void accept(FileSystemVisitor visitor);
}

// 3. 具体元素 - 文件
class File implements FileSystemElement {
    private String name;
    private long size;
    private String type;
    
    public File(String name, long size, String type) {
        this.name = name;
        this.size = size;
        this.type = type;
    }
    
    @Override
    public void accept(FileSystemVisitor visitor) {
        visitor.visitFile(this);  // 关键：双重分派的第二步
    }
    
    // getter methods...
    public String getName() { return name; }
    public long getSize() { return size; }
    public String getType() { return type; }
}

// 4. 具体元素 - 目录
class Directory implements FileSystemElement {
    private String name;
    private List<FileSystemElement> children = new ArrayList<>();
    
    public Directory(String name) {
        this.name = name;
    }
    
    public void addElement(FileSystemElement element) {
        children.add(element);
    }
    
    @Override
    public void accept(FileSystemVisitor visitor) {
        visitor.visitDirectory(this);  // 访问自己
        // 递归访问子元素
        for (FileSystemElement child : children) {
            child.accept(visitor);
        }
    }
    
    public String getName() { return name; }
    public List<FileSystemElement> getChildren() { return children; }
}
```

### 4.2 具体访问者实现


**📊 大小统计访问者**
```java
class SizeCalculatorVisitor implements FileSystemVisitor {
    private long totalSize = 0;
    private int fileCount = 0;
    private int dirCount = 0;
    
    @Override
    public void visitFile(File file) {
        totalSize += file.getSize();
        fileCount++;
        System.out.println("📄 文件: " + file.getName() + 
                          " (" + file.getSize() + " bytes)");
    }
    
    @Override
    public void visitDirectory(Directory directory) {
        dirCount++;
        System.out.println("📁 目录: " + directory.getName());
    }
    
    public void printReport() {
        System.out.println("\n📊 统计报告:");
        System.out.println("总大小: " + totalSize + " bytes");
        System.out.println("文件数: " + fileCount);
        System.out.println("目录数: " + dirCount);
    }
}
```

**🔍 文件类型分析访问者**
```java
class FileTypeAnalyzerVisitor implements FileSystemVisitor {
    private Map<String, Integer> typeCount = new HashMap<>();
    private Map<String, Long> typeSize = new HashMap<>();
    
    @Override
    public void visitFile(File file) {
        String type = file.getType();
        typeCount.put(type, typeCount.getOrDefault(type, 0) + 1);
        typeSize.put(type, typeSize.getOrDefault(type, 0L) + file.getSize());
    }
    
    @Override
    public void visitDirectory(Directory directory) {
        // 目录分析中忽略目录本身
    }
    
    public void printAnalysis() {
        System.out.println("\n🔍 文件类型分析:");
        for (String type : typeCount.keySet()) {
            System.out.println(type + ": " + typeCount.get(type) + 
                             " 个文件, " + typeSize.get(type) + " bytes");
        }
    }
}
```

### 4.3 使用示例


```java
public class VisitorPatternDemo {
    public static void main(String[] args) {
        // 构建文件系统结构
        Directory root = new Directory("根目录");
        Directory docs = new Directory("文档");
        Directory images = new Directory("图片");
        
        // 添加文件
        docs.addElement(new File("readme.txt", 1024, "txt"));
        docs.addElement(new File("manual.pdf", 5120, "pdf"));
        images.addElement(new File("photo1.jpg", 2048, "jpg"));
        images.addElement(new File("photo2.png", 1536, "png"));
        
        root.addElement(docs);
        root.addElement(images);
        root.addElement(new File("config.xml", 512, "xml"));
        
        // 使用不同的访问者
        System.out.println("=== 大小统计 ===");
        SizeCalculatorVisitor sizeVisitor = new SizeCalculatorVisitor();
        root.accept(sizeVisitor);
        sizeVisitor.printReport();
        
        System.out.println("\n=== 类型分析 ===");
        FileTypeAnalyzerVisitor typeVisitor = new FileTypeAnalyzerVisitor();
        root.accept(typeVisitor);
        typeVisitor.printAnalysis();
    }
}
```

**🖥️ 运行结果**
```
=== 大小统计 ===
📁 目录: 根目录
📁 目录: 文档
📄 文件: readme.txt (1024 bytes)
📄 文件: manual.pdf (5120 bytes)
📁 目录: 图片
📄 文件: photo1.jpg (2048 bytes)
📄 文件: photo2.png (1536 bytes)
📄 文件: config.xml (512 bytes)

📊 统计报告:
总大小: 10240 bytes
文件数: 5
目录数: 3

=== 类型分析 ===
🔍 文件类型分析:
txt: 1 个文件, 1024 bytes
pdf: 1 个文件, 5120 bytes
jpg: 1 个文件, 2048 bytes
png: 1 个文件, 1536 bytes
xml: 1 个文件, 512 bytes
```

---

## 5. 🚀 典型应用场景


### 5.1 编译器语法树处理


**📝 场景描述**
编译器需要对抽象语法树（AST）进行多种操作：语法检查、类型检查、代码生成等。

```
AST节点结构：
         表达式
        /   |   \
     变量   运算符  常量
     |      |      |
    name   +,-,*   value
```

**💡 访问者模式应用**
```java
// AST节点接口
interface ASTNode {
    void accept(ASTVisitor visitor);
}

// 具体节点类型
class VariableNode implements ASTNode {
    private String name;
    public void accept(ASTVisitor visitor) { visitor.visitVariable(this); }
}

class NumberNode implements ASTNode {
    private int value;
    public void accept(ASTVisitor visitor) { visitor.visitNumber(this); }
}

// 不同的处理访问者
class TypeCheckVisitor implements ASTVisitor { ... }
class CodeGenVisitor implements ASTVisitor { ... }
class OptimizeVisitor implements ASTVisitor { ... }
```

**🎯 优势**
- **职责分离**：每个访问者专注一种分析
- **易于扩展**：新增分析类型只需新增访问者
- **代码复用**：同一套AST结构支持多种分析

### 5.2 图形图像处理


**📝 场景描述**
图形软件需要对不同图形元素进行渲染、导出、计算面积等操作。

```java
// 图形元素
abstract class Shape {
    abstract void accept(ShapeVisitor visitor);
}

class Circle extends Shape { ... }
class Rectangle extends Shape { ... }
class Triangle extends Shape { ... }

// 不同操作访问者
class RenderVisitor implements ShapeVisitor {
    public void visitCircle(Circle circle) {
        // 绘制圆形的特殊逻辑
    }
}

class AreaCalculatorVisitor implements ShapeVisitor {
    public void visitCircle(Circle circle) {
        // 计算圆面积：π * r²
    }
}

class ExportVisitor implements ShapeVisitor {
    public void visitCircle(Circle circle) {
        // 导出SVG格式的圆形代码
    }
}
```

### 5.3 数据结构遍历


**📝 场景描述**
对复杂数据结构（如树、图）进行不同类型的遍历和处理。

| **应用领域** | **元素类型** | **访问者类型** | **典型操作** |
|-------------|-------------|---------------|-------------|
| 🌐 **网站分析** | 页面、链接、图片 | 性能分析、SEO检查 | 加载时间统计、关键词密度 |
| 📊 **报表系统** | 表格、图表、文本 | 导出、格式化 | PDF导出、Excel导出 |
| 🎮 **游戏引擎** | 精灵、场景、特效 | 渲染、碰撞检测 | 3D渲染、物理计算 |

---

## 6. ⚖️ 优缺点分析


### 6.1 优点详解


**✅ 符合开放封闭原则**
```
💡 新增功能的对比：

传统方式：
Element类 + 新功能 → 修改Element类 ❌

访问者模式：
Element类 + 新访问者 → 不修改Element类 ✅
```

**✅ 操作集中管理**
- **相关操作聚集**：同一类操作的代码集中在一个访问者中
- **易于维护**：修改某种操作只需修改对应访问者
- **职责单一**：每个访问者专注一种操作

**✅ 灵活的数据操作**
```java
// 同样的数据结构，不同的操作逻辑
FileSystem fs = buildFileSystem();

// 统计大小
fs.accept(new SizeCalculatorVisitor());

// 查找特定文件
fs.accept(new FileSearchVisitor("*.java"));

// 生成报告
fs.accept(new ReportGeneratorVisitor());
```

### 6.2 缺点详解


**❌ 新增元素类型困难**
```
问题：如果要添加新的元素类型（比如SymbolicLink），
需要：
1. 修改Visitor接口 → 添加visitSymbolicLink方法
2. 修改所有访问者实现 → 实现新方法
3. 可能影响现有代码

结论：访问者模式适合元素类型稳定的场景
```

**❌ 破坏封装性**
```java
// 访问者需要访问元素的内部数据
class File {
    private String secretInfo;  // 私有信息
    
    public void accept(Visitor visitor) {
        visitor.visitFile(this);
        // 访问者可能需要访问secretInfo
        // 需要提供public getter，破坏封装
    }
}
```

**❌ 复杂的依赖关系**
- **循环依赖**：访问者依赖元素，元素依赖访问者接口
- **理解难度**：双重分派机制增加理解复杂度
- **调试困难**：方法调用链路复杂

### 6.3 适用场景判断


**✅ 推荐使用场景**
- **元素类型稳定**：数据结构的类型相对固定
- **操作经常变化**：需要频繁添加新的操作
- **操作跨多个类**：一个操作需要访问多种元素类型
- **需要执行复杂操作**：操作逻辑复杂，适合独立封装

**❌ 不推荐使用场景**
- **元素类型频繁变化**：经常需要添加新的元素类型
- **操作相对简单**：操作逻辑简单，放在元素类中更合适
- **性能要求极高**：双重分派有额外的方法调用开销
- **团队不熟悉模式**：增加维护成本

---

## 7. 🔗 与其他模式的关系


### 7.1 与迭代器模式


**🤝 协作关系**
```java
// 访问者模式 + 迭代器模式
class CompositeElement {
    private List<Element> children;
    
    public void accept(Visitor visitor) {
        visitor.visitComposite(this);
        
        // 使用迭代器遍历子元素
        Iterator<Element> iter = children.iterator();
        while (iter.hasNext()) {
            iter.next().accept(visitor);
        }
    }
}
```

**📊 对比分析**
| **特点** | **访问者模式** | **迭代器模式** |
|---------|---------------|---------------|
| **目的** | 在不修改类的前提下添加操作 | 提供统一的遍历接口 |
| **关注点** | 操作的多样性 | 遍历的统一性 |
| **使用场景** | 复杂操作，元素类型固定 | 简单遍历，容器类型多样 |

### 7.2 与组合模式


**🤝 天然搭配**
```java
// 组合模式的元素天然适合访问者模式
abstract class Component {
    abstract void accept(Visitor visitor);
}

class Composite extends Component {
    public void accept(Visitor visitor) {
        visitor.visitComposite(this);
        for (Component child : children) {
            child.accept(visitor);  // 递归访问
        }
    }
}
```

### 7.3 与命令模式


**🔄 相似之处**
- **都实现了操作的参数化**：将操作封装成对象
- **都支持撤销操作**：可以记录操作历史
- **都符合开放封闭原则**：容易添加新操作

**🎯 差异对比**
```
命令模式：request → Command → Receiver
• 关注请求的封装和执行
• 支持队列、日志、撤销

访问者模式：Element → accept → Visitor
• 关注对数据结构的操作
• 支持双重分派和类型安全
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔥 重要程度标识**
- 🟢 **基础概念** (必须理解)
- 🟡 **核心机制** (重点掌握)  
- 🔴 **高级应用** (深入理解)

```
🟢 访问者模式定义：在不修改元素类的前提下，定义新的操作
🟢 双重分派：根据访问者类型和元素类型决定调用哪个方法
🟡 四大角色：Visitor、ConcreteVisitor、Element、ConcreteElement
🟡 accept方法：元素接受访问者的关键机制
🔴 开放封闭原则：对扩展开放，对修改封闭
🔴 适用场景判断：元素稳定，操作多变
```

### 8.2 关键理解要点


**🔹 为什么叫"访问者"模式**
```
类比：医生访问病人
• 病人（元素）：提供身体信息，接受检查
• 医生（访问者）：根据专业执行不同检查
• accept机制：病人主动配合医生的检查
• 双重分派：根据医生类型和病人情况决定检查方法
```

**🔹 双重分派的精髓**
```
第一次分派：谁来接受访问？
element.accept(visitor) → 根据element类型分派

第二次分派：如何进行访问？  
visitor.visitXXX(this) → 根据visitor类型分派

结果：既考虑了数据类型，又考虑了操作类型
```

**🔹 设计权衡的智慧**
```
优势：操作扩展性强，职责分离清晰
代价：元素扩展困难，封装性受影响
选择：根据变化频率决定 - 操作变化 vs 数据变化
```

### 8.3 实际应用指导


**🎯 判断是否使用访问者模式**
```
✅ 使用条件（至少满足2-3个）：
- 数据结构相对稳定，不经常添加新类型
- 需要对数据执行很多不同操作
- 操作逻辑复杂，适合独立封装
- 操作之间相互独立，没有强依赖

❌ 避免使用条件：
- 数据结构经常变化
- 操作逻辑很简单
- 性能要求极高
- 团队对模式不熟悉
```

**🛠️ 实现要点检查清单**
```
- [ ] Visitor接口包含所有元素类型的visit方法
- [ ] 每个Element都有accept方法
- [ ] accept方法中调用visitor的对应visit方法
- [ ] 访问者实现都处理了所有元素类型
- [ ] 对象结构提供了遍历机制
```

**📈 进阶学习方向**
- **泛型访问者**：使用Java泛型增强类型安全
- **异步访问者**：支持异步操作的访问者实现
- **函数式访问者**：利用Lambda表达式简化访问者实现
- **访问者模式变体**：Acyclic Visitor等改进版本

### 8.4 记忆技巧


**🧠 核心记忆口诀**
```
访问者来做客，元素把门开
双重分派巧，操作类型猜  
数据结构稳，操作变化快
开放又封闭，扩展不破坏
```

**🔤 关键词联想**
- **Visitor** → 来访者，主动执行操作
- **Accept** → 接受访问，被动配合
- **Double Dispatch** → 双重选择，精确定位
- **Open-Closed** → 开放扩展，封闭修改

**🎯 一句话总结**
访问者模式就像不同专家对同一批数据进行不同分析：数据结构保持不变，分析方法可以随时增加，通过双重分派确保每种数据都能找到对应的专家进行正确处理。