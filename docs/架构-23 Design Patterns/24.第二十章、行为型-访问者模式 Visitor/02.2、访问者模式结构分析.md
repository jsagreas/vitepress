---
title: 2、访问者模式结构分析
---
## 📚 目录


1. [访问者模式整体架构理解](#1-访问者模式整体架构理解)
2. [抽象访问者接口详解](#2-抽象访问者接口详解)
3. [具体访问者实现分析](#3-具体访问者实现分析)
4. [抽象元素接口设计](#4-抽象元素接口设计)
5. [具体元素实现机制](#5-具体元素实现机制)
6. [对象结构类的作用](#6-对象结构类的作用)
7. [结构组件协作关系](#7-结构组件协作关系)
8. [核心要点总结](#8-核心要点总结)

---

# 1. 🏗️ 访问者模式整体架构理解



## 1.1 访问者模式是什么



**通俗理解**：想象一下，你是一个医生，要给不同的病人看病。每个病人的情况不同（有感冒的、发烧的、外伤的），但你作为医生的治疗方法是固定的。访问者模式就像这样 - **你（访问者）去拜访不同的对象（元素），对每种对象执行特定的操作**。

> 💡 **核心思想**  
> 将**操作**和**数据结构**分离，让你可以在不修改数据结构的情况下，定义新的操作方式

## 1.2 解决什么问题



**现实场景举例**：
- 🏪 **商店系统**：同样的商品，会计要算价格，库管要统计数量，销售要看利润
- 📄 **文档系统**：同样的文档，有人要导出PDF，有人要转换格式，有人要统计字数
- 🎮 **游戏系统**：同样的角色，有渲染器要画图，AI要计算，存档系统要保存数据

```
传统做法的问题：
┌─────────────┐
│   商品类     │
├─────────────┤
│ + 计算价格() │  ← 会计需要的方法
│ + 统计数量() │  ← 库管需要的方法  
│ + 看利润()   │  ← 销售需要的方法
└─────────────┘

问题：商品类会越来越臃肿，违背单一职责原则！
```

## 1.3 访问者模式的解决方案



```
访问者模式的解决方案：
┌─────────────┐    ┌─────────────┐
│   商品类     │◄───│  访问者接口  │
├─────────────┤    ├─────────────┤
│ + accept()  │    │ + visit()   │
└─────────────┘    └─────────────┘
                          ▲
              ┌───────────┼───────────┐
    ┌─────────┴──┐ ┌──────┴────┐ ┌───┴──────┐
    │ 会计访问者  │ │库管访问者  │ │销售访问者 │
    │+ visit()   │ │+ visit()  │ │+ visit() │
    └────────────┘ └───────────┘ └──────────┘

每个访问者专门负责自己的业务逻辑！
```

---

# 2. 🔍 抽象访问者接口详解



## 2.1 抽象访问者的职责



**抽象访问者**就像是一个**通用的工作模板**，它定义了所有访问者都必须具备的基本能力。

> 📖 **术语解释**  
> **抽象访问者**：定义了访问不同类型元素的方法签名，但不实现具体逻辑

## 2.2 接口设计原则



**核心设计理念**：
- ✅ **为每种具体元素类型定义一个visit方法**
- ✅ **方法名通常是 `visit(具体元素类型)`**  
- ✅ **使用方法重载来处理不同类型的元素**

```java
// 抽象访问者接口
public interface Visitor {
    // 访问书籍元素
    void visit(Book book);
    
    // 访问音乐元素  
    void visit(Music music);
    
    // 访问电影元素
    void visit(Movie movie);
}
```

## 2.3 为什么要这样设计



**方法重载的好处**：
```
❌ 不好的设计：
public interface Visitor {
    void visitElement(Object element);  // 太泛化，类型不安全
}

✅ 好的设计：
public interface Visitor {
    void visit(Book book);    // 类型明确
    void visit(Music music);  // 编译期检查
    void visit(Movie movie);  // 代码清晰
}
```

> ⚠️ **注意事项**  
> 每增加一种新的元素类型，就需要在抽象访问者中添加对应的visit方法

---

# 3. 🔧 具体访问者实现分析



## 3.1 具体访问者的作用



**具体访问者**就是真正干活的人，每个访问者都有自己的专业技能和处理方式。

## 3.2 实际实现示例



**价格计算访问者**：
```java
public class PriceCalculatorVisitor implements Visitor {
    private double totalPrice = 0;
    
    @Override
    public void visit(Book book) {
        totalPrice += book.getPrice();
        System.out.println("书籍: " + book.getName() + 
                         ", 价格: " + book.getPrice());
    }
    
    @Override
    public void visit(Music music) {
        // 音乐打8折
        double discountPrice = music.getPrice() * 0.8;
        totalPrice += discountPrice;
        System.out.println("音乐: " + music.getName() + 
                         ", 折后价: " + discountPrice);
    }
    
    @Override
    public void visit(Movie movie) {
        totalPrice += movie.getPrice();
        System.out.println("电影: " + movie.getName() + 
                         ", 价格: " + movie.getPrice());
    }
    
    public double getTotalPrice() {
        return totalPrice;
    }
}
```

**信息统计访问者**：
```java
public class InfoStatsVisitor implements Visitor {
    private int bookCount = 0;
    private int musicCount = 0;
    private int movieCount = 0;
    
    @Override
    public void visit(Book book) {
        bookCount++;
        System.out.println("统计书籍: " + book.getName());
    }
    
    @Override
    public void visit(Music music) {
        musicCount++;
        System.out.println("统计音乐: " + music.getName());
    }
    
    @Override
    public void visit(Movie movie) {
        movieCount++;
        System.out.println("统计电影: " + movie.getName());
    }
    
    public void printStats() {
        System.out.println("=== 统计结果 ===");
        System.out.println("书籍数量: " + bookCount);
        System.out.println("音乐数量: " + musicCount);
        System.out.println("电影数量: " + movieCount);
    }
}
```

## 3.3 具体访问者的特点



**关键特征**：
- 🎯 **专业化**：每个访问者专注于特定的业务逻辑
- 🔄 **可扩展**：添加新访问者不影响现有代码
- 📊 **状态管理**：可以在访问过程中维护状态信息

> 💡 **设计提示**  
> 具体访问者通常会有成员变量来存储访问过程中的计算结果或统计信息

---

# 4. 📋 抽象元素接口设计



## 4.1 抽象元素的核心使命



**抽象元素**就像是所有商品的**统一接待标准**，它规定了"任何访问者来了，我都要这样接待"。

> 📖 **术语解释**  
> **抽象元素**：定义了接受访问者访问的接口，通常只有一个accept方法

## 4.2 标准接口设计



```java
public interface Element {
    // 接受访问者的访问
    void accept(Visitor visitor);
}
```

**为什么这么简单？**
- ✅ **职责单一**：元素只负责"接受访问"这一件事
- ✅ **解耦合**：元素不需要知道访问者的具体实现
- ✅ **统一性**：所有元素都用相同的方式接受访问

## 4.3 accept方法的精妙设计



**accept方法内部的经典实现**：
```java
public void accept(Visitor visitor) {
    visitor.visit(this);  // 把自己传给访问者
}
```

**这行代码的威力**：
```
调用流程解析：
1. 客户端：element.accept(visitor)
2. 元素：visitor.visit(this) 
3. 访问者：根据this的实际类型，调用对应的visit方法

这就是传说中的"双重分派"！
```

> 🎯 **核心要点**  
> accept方法实现了对象类型的自动识别和分派，这是访问者模式的核心机制

---

# 5. 🎯 具体元素实现机制



## 5.1 具体元素的双重身份



**具体元素**既是**数据的载体**，也是**访问的接收者**。它们像是有自己特色的商店，既要展示自己的商品，也要按统一标准接待顾客。

## 5.2 典型元素实现



**书籍元素**：
```java
public class Book implements Element {
    private String name;
    private double price;
    private String author;
    
    public Book(String name, double price, String author) {
        this.name = name;
        this.price = price;
        this.author = author;
    }
    
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);  // 关键：传递的是Book类型的this
    }
    
    // 提供数据访问方法
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getAuthor() { return author; }
}
```

**音乐元素**：
```java
public class Music implements Element {
    private String name;
    private double price;
    private String artist;
    private int duration; // 时长（秒）
    
    public Music(String name, double price, String artist, int duration) {
        this.name = name;
        this.price = price;
        this.artist = artist;
        this.duration = duration;
    }
    
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);  // 关键：传递的是Music类型的this
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getArtist() { return artist; }
    public int getDuration() { return duration; }
}
```

## 5.3 双重分派机制详解



**双重分派的魔法过程**：
```
步骤解析：
┌─────────────────────────────────────────────────────────┐
│ 1. book.accept(priceVisitor)                            │
│    ↓                                                    │
│ 2. book内部调用: priceVisitor.visit(this)               │
│    (this是Book类型)                                     │
│    ↓                                                    │
│ 3. Java根据参数类型自动选择:                             │
│    priceVisitor.visit(Book book) 方法                  │
└─────────────────────────────────────────────────────────┘

如果是music.accept(priceVisitor)：
Java会自动选择 priceVisitor.visit(Music music) 方法！
```

> 💡 **理解要点**  
> 每个具体元素的accept方法看起来一样，但传递的`this`类型不同，这是实现自动分派的关键

---

# 6. 🏢 对象结构类的作用



## 6.1 对象结构类是什么



**对象结构类**就像是一个**购物车**或者**展示柜**，它负责管理一堆元素，并且提供统一的访问入口。

> 📖 **术语解释**  
> **对象结构类**：管理元素集合，提供遍历接口，让访问者能够访问所有元素

## 6.2 典型实现方式



```java
public class ShoppingCart {
    private List<Element> elements = new ArrayList<>();
    
    // 添加商品
    public void addElement(Element element) {
        elements.add(element);
    }
    
    // 移除商品
    public void removeElement(Element element) {
        elements.remove(element);
    }
    
    // 接受访问者访问所有商品
    public void accept(Visitor visitor) {
        for (Element element : elements) {
            element.accept(visitor);
        }
    }
    
    // 获取商品数量
    public int size() {
        return elements.size();
    }
}
```

## 6.3 使用示例



```java
public class VisitorPatternDemo {
    public static void main(String[] args) {
        // 创建购物车
        ShoppingCart cart = new ShoppingCart();
        
        // 添加商品
        cart.addElement(new Book("Java编程思想", 89.0, "Bruce Eckel"));
        cart.addElement(new Music("月亮代表我的心", 3.0, "邓丽君", 180));
        cart.addElement(new Movie("阿凡达", 25.0, "詹姆斯·卡梅隆"));
        
        System.out.println("=== 价格计算 ===");
        PriceCalculatorVisitor priceVisitor = new PriceCalculatorVisitor();
        cart.accept(priceVisitor);
        System.out.println("总价: " + priceVisitor.getTotalPrice());
        
        System.out.println("\n=== 信息统计 ===");
        InfoStatsVisitor statsVisitor = new InfoStatsVisitor();
        cart.accept(statsVisitor);
        statsVisitor.printStats();
    }
}
```

## 6.4 对象结构类的设计要点



**设计原则**：
- 🔍 **封装集合操作**：隐藏内部集合实现细节
- 🚀 **提供统一访问**：一次调用处理所有元素
- 📦 **支持增删操作**：动态管理元素集合
- 🔄 **简化客户端**：客户端不需要知道元素遍历逻辑

> ⚠️ **注意事项**  
> 对象结构类不是必需的，但它能让客户端代码更简洁，特别是需要批量处理多个元素时

---

# 7. 🔗 结构组件协作关系



## 7.1 组件关系图



```
访问者模式组件协作关系：

    ┌─────────────┐         ┌─────────────┐
    │   客户端     │────────►│ 对象结构类   │
    └─────────────┘         └─────┬───────┘
           │                      │
           │                      │ 管理
           │ 创建                 │
           ▼                      ▼
    ┌─────────────┐         ┌─────────────┐
    │  具体访问者  │         │  具体元素    │
    └─────┬───────┘         └─────┬───────┘
          │                       │
          │ 实现                  │ 实现
          ▼                       ▼
    ┌─────────────┐         ┌─────────────┐
    │ 抽象访问者   │◄────────┤ 抽象元素     │
    │  接口       │   依赖   │  接口       │
    └─────────────┘         └─────────────┘
```

## 7.2 协作时序图



```
访问过程时序图：

客户端    对象结构    具体元素    具体访问者
  │         │          │          │
  │─────────│          │          │
  │ accept  │          │          │
  │◄────────│          │          │
  │         │──────────│          │
  │         │ accept   │          │
  │         │◄─────────│          │
  │         │          │──────────│
  │         │          │  visit   │
  │         │          │◄─────────│
  │         │          │          │
```

## 7.3 核心交互流程



**完整的访问流程**：

| 步骤 | 参与者 | 动作说明 | 关键点 |
|------|--------|----------|--------|
| **1** | `客户端` | 创建访问者和对象结构 | 🎯 准备阶段 |
| **2** | `客户端` | 调用 `objectStructure.accept(visitor)` | 🚀 启动访问 |
| **3** | `对象结构` | 遍历内部元素，调用 `element.accept(visitor)` | 🔄 分发访问 |
| **4** | `具体元素` | 调用 `visitor.visit(this)` | 🎯 类型分派 |
| **5** | `具体访问者` | 执行对应的visit方法 | ⚡ 业务处理 |
| **6** | `客户端` | 获取访问者的处理结果 | 📊 结果获取 |

## 7.4 依赖关系分析



**依赖方向**：
```
抽象层依赖关系：
抽象访问者 ←→ 抽象元素  (相互依赖)

具体层依赖关系：  
具体访问者 → 抽象访问者  (实现依赖)
具体元素 → 抽象元素      (实现依赖)
具体访问者 → 具体元素    (使用依赖)

管理层依赖关系：
对象结构 → 抽象元素      (聚合依赖)
客户端 → 所有组件        (使用依赖)
```

> 💡 **设计智慧**  
> 抽象访问者和抽象元素的相互依赖是访问者模式的核心，这种设计让两者能够协同工作

---

# 8. 📋 核心要点总结



## 8.1 必须掌握的核心概念



```
🔸 访问者模式本质：将操作与数据结构分离的设计模式
🔸 双重分派机制：通过方法重载实现类型自动识别和分派
🔸 五大组件角色：抽象访问者、具体访问者、抽象元素、具体元素、对象结构
🔸 核心交互流程：accept()调用 → visit()分派 → 业务逻辑执行
🔸 扩展性特点：添加新访问者无需修改元素类，符合开闭原则
```

## 8.2 关键理解要点



**🔹 为什么需要accept方法**
```
关键作用：
- 实现类型识别：元素把自己的实际类型传递给访问者
- 触发分派：让Java的方法重载机制自动选择正确的visit方法
- 保持封装：元素不需要知道访问者的具体实现细节
```

**🔹 双重分派的精妙之处**
```
传统单分派：根据对象类型选择方法
双重分派：根据两个对象的类型选择方法

第一次分派：element.accept(visitor) → 根据element类型
第二次分派：visitor.visit(this) → 根据visitor类型

结果：实现了精确的方法匹配！
```

**🔹 组件职责划分**
```
抽象访问者：定义访问接口标准
具体访问者：实现具体业务逻辑  
抽象元素：定义接受访问标准
具体元素：提供数据和接受访问
对象结构：管理元素集合和统一访问
```

## 8.3 实际应用价值



**适用场景判断**：
- ✅ **稳定的数据结构**：元素类型相对固定，不经常变化
- ✅ **多样的操作需求**：需要对同一组对象执行不同类型的操作
- ✅ **操作复杂性高**：操作逻辑复杂，值得单独抽象出来
- ✅ **扩展性要求**：需要经常添加新的操作类型

**典型应用实例**：
- 🏪 **商场系统**：商品价格计算、库存统计、促销处理
- 📄 **文档处理**：格式转换、内容提取、语法检查
- 🌳 **AST语法树**：代码生成、语法检查、优化分析
- 🎮 **游戏引擎**：渲染处理、物理计算、AI行为

## 8.4 设计注意事项



**优势特点**：
- 🎯 **符合开闭原则**：添加新访问者不影响现有代码
- 🔧 **操作集中化**：相关操作集中在一个访问者中
- 📊 **状态累积**：访问者可以在访问过程中累积状态
- 🔄 **类型安全**：编译期确保类型匹配

**设计权衡**：
- ⚠️ **元素变化成本高**：添加新元素类型需要修改所有访问者
- ⚠️ **循环依赖风险**：抽象访问者与抽象元素相互依赖
- ⚠️ **访问者爆炸**：访问者数量可能会快速增长
- ⚠️ **破坏封装性**：元素需要提供足够的访问接口

## 8.5 学习记忆要点



**核心记忆口诀**：
- 访问者来访问，元素说欢迎
- accept调visit，双重分派行
- 操作独立化，扩展更轻松
- 结构保稳定，功能任意增

**关键代码模板**：
```java
// 元素接口
interface Element {
    void accept(Visitor visitor);
}

// 访问者接口  
interface Visitor {
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
}

// 具体元素
class ConcreteElement implements Element {
    public void accept(Visitor visitor) {
        visitor.visit(this);  // 核心：类型自动分派
    }
}
```

**核心理解**：
- 访问者模式通过双重分派实现了操作与数据的优雅分离
- 理解accept方法的作用是掌握访问者模式的关键
- 适用于数据结构稳定但操作多变的场景
- 是一种高级的设计模式，需要权衡使用场景