---
title: 2、中介者模式结构分析
---
## 📚 目录

1. [中介者模式是什么](#1-中介者模式是什么)
2. [核心组件结构](#2-核心组件结构)
3. [抽象中介者接口](#3-抽象中介者接口)
4. [具体中介者实现](#4-具体中介者实现)
5. [抽象同事类](#5-抽象同事类)
6. [具体同事类实现](#6-具体同事类实现)
7. [通信协调机制](#7-通信协调机制)
8. [实际应用场景](#8-实际应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🤝 中介者模式是什么


### 1.1 现实生活中的中介者


想象一下现实生活中的例子：

```
房产中介的作用：
买房者 ←→ 房产中介 ←→ 卖房者

没有中介时：
买房者需要自己找卖房者
卖房者需要自己找买房者
价格谈判、合同签署都要直接对接

有中介时：
买房者只需要告诉中介需求
卖房者只需要告诉中介房源信息
中介负责匹配和协调所有事宜
```

### 1.2 程序中的中介者概念


**🔸 核心思想**
中介者模式就像现实中的中介一样，**让多个对象不直接相互交流，而是通过一个中间人来协调**。

**💡 简单理解**
- **没有中介者**：对象之间直接对话，关系复杂
- **有中介者**：对象只和中介者对话，关系简单

```
传统方式（混乱）：
A ←→ B
↕ ×  ↕ 
C ←→ D
每个对象都要知道其他对象

中介者方式（清晰）：
  A   B
   \ /
    M（中介者）
   / \
  C   D
所有对象只需要知道中介者
```

### 1.3 解决的核心问题


**🚫 问题场景**
当多个对象需要相互通信时，直接通信会导致：
- **关系复杂**：每个对象都要知道其他对象
- **耦合度高**：修改一个对象影响多个对象
- **维护困难**：添加新对象需要修改多处代码

**✅ 中介者解决方案**
- **统一协调**：所有通信都通过中介者
- **降低耦合**：对象只需要知道中介者
- **易于扩展**：添加新对象只需要注册到中介者

---

## 2. 🏗️ 核心组件结构


### 2.1 整体结构图


```
中介者模式的组成部分：

┌─────────────────────────────────────────────────────────┐
│                    抽象中介者                            │
│  + register(colleague)  注册同事对象                    │
│  + notify(colleague, message)  处理通知                 │
└─────────────────────────────────────────────────────────┘
                            ▲
                            │ 实现
                            │
┌─────────────────────────────────────────────────────────┐
│                    具体中介者                            │
│  - colleagues[]  存储所有同事对象                       │
│  + register(colleague)  具体注册逻辑                    │
│  + notify(colleague, message)  具体协调逻辑             │
└─────────────────────────────────────────────────────────┘
                            ▲
                            │ 持有引用
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼────────┐ ┌────────▼────────┐ ┌───────▼────────┐
│   抽象同事类    │ │   抽象同事类     │ │   抽象同事类    │
│ - mediator     │ │ - mediator      │ │ - mediator     │
│ + send()       │ │ + send()        │ │ + send()       │
│ + receive()    │ │ + receive()     │ │ + receive()    │
└────────────────┘ └─────────────────┘ └────────────────┘
```

### 2.2 四大核心角色


| 角色名称 | 作用说明 | 通俗理解 |
|---------|---------|---------|
| **抽象中介者** | 定义中介者接口 | 中介公司的服务标准 |
| **具体中介者** | 实现协调逻辑 | 具体的房产中介员工 |
| **抽象同事类** | 定义参与者接口 | 参与交易的人的基本要求 |
| **具体同事类** | 实际的参与对象 | 具体的买房者、卖房者 |

### 2.3 工作流程图


```
中介者模式的工作流程：

同事A                  中介者                 同事B
  │                      │                     │
  │──①发送消息─────────→│                     │
  │  "我要买房"           │                     │
  │                      │──②转发处理────────→│
  │                      │  "有人要买房"        │
  │                      │                     │
  │                      │←─③回复消息─────────│
  │                      │  "我有房源"          │
  │←─④转发回复───────────│                     │
  │  "找到房源了"         │                     │
```

---

## 3. 📋 抽象中介者接口


### 3.1 接口设计思路


**🔸 为什么需要抽象接口？**
- **统一标准**：所有中介者都要遵循相同的规范
- **易于扩展**：可以有不同类型的中介者实现
- **面向接口编程**：同事类依赖抽象而不是具体实现

### 3.2 核心方法定义


```java
/**
 * 抽象中介者接口
 * 定义了中介者必须具备的基本能力
 */
public interface Mediator {
    
    /**
     * 注册同事对象到中介者
     * @param colleague 要注册的同事对象
     */
    void register(Colleague colleague);
    
    /**
     * 处理同事对象发送的消息
     * @param from 发送消息的同事对象
     * @param message 消息内容
     */
    void notify(Colleague from, String message);
}
```

### 3.3 方法含义详解


**🔸 register方法**
- **作用**：把参与通信的对象注册到中介者
- **好比**：客户到中介公司登记信息
- **重要性**：只有注册了才能参与通信

**🔸 notify方法**
- **作用**：接收并处理来自同事对象的消息
- **好比**：中介接到客户电话后进行处理
- **核心**：这是整个协调机制的入口

---

## 4. 🎯 具体中介者实现


### 4.1 具体中介者的职责


**💼 主要工作内容**
1. **管理同事对象**：维护所有参与者的列表
2. **消息路由**：决定消息发送给谁
3. **业务协调**：实现具体的协调逻辑
4. **状态维护**：记录必要的状态信息

### 4.2 实现示例


```java
/**
 * 具体中介者实现
 * 以聊天室为例，协调多个用户的消息传递
 */
public class ChatMediator implements Mediator {
    
    // 存储所有注册的同事对象
    private List<Colleague> colleagues;
    
    public ChatMediator() {
        this.colleagues = new ArrayList<>();
    }
    
    @Override
    public void register(Colleague colleague) {
        // 注册新的同事对象
        colleagues.add(colleague);
        System.out.println("用户 " + colleague.getName() + " 加入聊天室");
    }
    
    @Override
    public void notify(Colleague from, String message) {
        // 将消息转发给除发送者之外的所有人
        for (Colleague colleague : colleagues) {
            if (colleague != from) {  // 不发送给自己
                colleague.receive(from.getName() + ": " + message);
            }
        }
    }
    
    // 额外的便利方法
    public void removeColleague(Colleague colleague) {
        colleagues.remove(colleague);
        System.out.println("用户 " + colleague.getName() + " 离开聊天室");
    }
}
```

### 4.3 实现要点分析


**🔸 存储管理**
- 使用集合存储所有同事对象
- 提供增加和删除的方法
- 确保线程安全（如果需要）

**🔸 消息转发逻辑**
- 避免消息发送给自己
- 可以实现不同的转发策略
- 可以添加消息过滤和转换

**⚡ 性能优化提示**
- 对于大量同事对象，考虑使用Map进行快速查找
- 异步处理消息避免阻塞
- 实现消息缓存和重发机制

---

## 5. 👥 抽象同事类


### 5.1 同事类的设计思路


**🔸 为什么叫"同事"？**
- 这些对象都参与同一个协作过程
- 它们地位平等，通过中介者协调
- 就像公司里的同事通过项目经理协调工作

### 5.2 抽象同事类定义


```java
/**
 * 抽象同事类
 * 定义了参与中介者模式的对象的基本行为
 */
public abstract class Colleague {
    
    // 持有中介者的引用
    protected Mediator mediator;
    protected String name;
    
    public Colleague(Mediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
        // 创建时自动注册到中介者
        mediator.register(this);
    }
    
    /**
     * 发送消息的抽象方法
     * 子类实现具体的发送逻辑
     */
    public abstract void send(String message);
    
    /**
     * 接收消息的抽象方法
     * 子类实现具体的接收处理逻辑
     */
    public abstract void receive(String message);
    
    // getter方法
    public String getName() {
        return name;
    }
}
```

### 5.3 设计要点解析


**🔸 持有中介者引用**
- **必要性**：同事对象需要通过中介者发送消息
- **时机**：通常在构造函数中设置
- **注意**：避免循环依赖问题

**🔸 自动注册机制**
- **便利性**：创建对象时自动注册到中介者
- **一致性**：确保所有同事对象都被正确注册
- **可选性**：也可以手动注册以获得更多控制

**🔸 抽象方法设计**
- **send方法**：定义如何发送消息
- **receive方法**：定义如何处理接收到的消息
- **灵活性**：不同类型的同事可以有不同的实现

---

## 6. 🎭 具体同事类实现


### 6.1 具体同事类的职责


**💼 主要功能**
1. **实现发送逻辑**：如何通过中介者发送消息
2. **实现接收逻辑**：如何处理收到的消息
3. **维护自身状态**：保存自己的业务数据
4. **提供业务接口**：暴露给外部调用的方法

### 6.2 实现示例


```java
/**
 * 具体同事类 - 普通用户
 */
public class User extends Colleague {
    
    public User(Mediator mediator, String name) {
        super(mediator, name);
    }
    
    @Override
    public void send(String message) {
        System.out.println(name + " 发送消息: " + message);
        // 通过中介者发送消息
        mediator.notify(this, message);
    }
    
    @Override
    public void receive(String message) {
        System.out.println(name + " 收到消息: " + message);
    }
}

/**
 * 具体同事类 - 管理员用户
 */
public class AdminUser extends Colleague {
    
    public AdminUser(Mediator mediator, String name) {
        super(mediator, name);
    }
    
    @Override
    public void send(String message) {
        System.out.println("【管理员】" + name + " 发送消息: " + message);
        // 管理员消息可能有特殊处理
        mediator.notify(this, "【系统消息】" + message);
    }
    
    @Override
    public void receive(String message) {
        System.out.println("【管理员】" + name + " 收到消息: " + message);
    }
    
    // 管理员特有的功能
    public void broadcast(String announcement) {
        send("重要通知: " + announcement);
    }
}
```

### 6.3 不同实现的对比


| 特性 | 普通用户 | 管理员用户 |
|------|---------|-----------|
| **消息标识** | 普通标识 | 【管理员】标识 |
| **发送权限** | 一般消息 | 系统消息 |
| **特殊功能** | 无 | 广播通知 |
| **显示方式** | 普通显示 | 特殊显示 |

### 6.4 扩展性体现


**🔸 新增同事类型**
可以轻松添加新的同事类型：

```java
// 可以添加更多类型的同事
public class GuestUser extends Colleague {
    // 游客用户：只能接收，不能发送
}

public class VIPUser extends Colleague {
    // VIP用户：消息优先级更高
}
```

---

## 7. 🔄 通信协调机制


### 7.1 通信流程详解


**📊 完整通信时序图**

```
用户A          中介者          用户B          用户C
  │              │              │              │
  │─①send("hello")→│              │              │
  │              │─②notify(A,"hello")→│              │
  │              │              │─③receive()──│  │
  │              │              │              │  │
  │              │─④notify(A,"hello")─────────→│
  │              │              │              │─⑤receive()
  │              │              │              │
```

### 7.2 协调机制的核心特点


**🔸 统一入口**
- 所有消息都通过中介者的`notify`方法处理
- 中介者决定消息的分发策略
- 同事对象不需要知道其他同事的存在

**🔸 灵活路由**
```java
// 中介者可以实现各种路由策略
public void notify(Colleague from, String message) {
    // 策略1：广播给所有人
    // 策略2：只发给特定用户
    // 策略3：根据消息类型分发
    // 策略4：实现群组功能
}
```

### 7.3 协调策略示例


**💡 不同的协调策略**

```java
public class SmartChatMediator implements Mediator {
    
    private Map<String, List<Colleague>> groups;
    
    @Override
    public void notify(Colleague from, String message) {
        // 智能路由策略
        if (message.startsWith("@all")) {
            // 广播消息
            broadcastToAll(from, message);
        } else if (message.startsWith("@")) {
            // 私聊消息
            sendPrivateMessage(from, message);
        } else {
            // 群组消息
            sendToGroup(from, message);
        }
    }
    
    private void broadcastToAll(Colleague from, String message) {
        // 发送给所有用户
    }
    
    private void sendPrivateMessage(Colleague from, String message) {
        // 解析用户名，发送私聊消息
    }
    
    private void sendToGroup(Colleague from, String message) {
        // 发送给同组用户
    }
}
```

---

## 8. 💼 实际应用场景


### 8.1 经典应用场景


**🏢 GUI界面控件协调**

```
对话框中的控件交互：
确定按钮 ←→ 对话框中介者 ←→ 输入框
取消按钮 ←→     ↕     ←→ 下拉列表  
帮助按钮 ←→              ←→ 复选框

当用户操作任何控件时，中介者协调其他控件的状态变化
```

**💬 聊天系统**
- **参与者**：各个用户
- **中介者**：聊天服务器
- **协调内容**：消息转发、用户管理、群组功能

**🎮 游戏系统**
- **参与者**：各个游戏角色
- **中介者**：游戏引擎
- **协调内容**：角色交互、技能效果、状态同步

### 8.2 业务系统应用


**📦 电商系统订单处理**

```java
// 订单处理中介者
public class OrderMediator {
    
    public void processOrder(Order order) {
        // 协调多个子系统
        inventoryService.checkStock(order);      // 库存检查
        paymentService.processPayment(order);    // 支付处理
        shippingService.arrangeShipping(order);  // 安排发货
        notificationService.sendConfirm(order);  // 发送确认
    }
}
```

### 8.3 优势体现


**✅ 降低复杂度**
- 从 n×(n-1) 个关系降低到 n×1 个关系
- 每个对象只需要知道中介者

**✅ 易于维护**
- 修改协调逻辑只需要修改中介者
- 添加新对象不影响现有对象

**✅ 复用性好**
- 同一个中介者可以用于不同的场景
- 协调逻辑可以独立测试

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 中介者模式本质：用一个中间对象协调多个对象之间的交互
🔸 核心组件：抽象中介者、具体中介者、抽象同事类、具体同事类
🔸 通信机制：同事对象通过中介者间接通信，不直接引用
🔸 协调策略：中介者负责实现具体的消息路由和业务协调逻辑
🔸 应用价值：降低对象间耦合度，提高系统的可维护性和扩展性
```

### 9.2 关键理解要点


**🔹 为什么要用中介者模式**
```
解决问题：
- 对象间关系复杂 → 统一协调管理
- 耦合度太高 → 只依赖中介者接口
- 难以扩展 → 新对象只需注册到中介者
```

**🔹 中介者vs直接通信**
```
直接通信：
对象A.method() → 对象B.method()
问题：A必须知道B的存在和接口

中介者通信：
对象A.send() → 中介者.notify() → 对象B.receive()
优势：A和B互不知晓，只知道中介者
```

**🔹 何时使用中介者模式**
```
适用场景：
✅ 多个对象需要复杂交互
✅ 对象间关系难以维护
✅ 需要统一的协调逻辑
✅ 系统需要高度可扩展

不适用场景：
❌ 只有两个对象交互
❌ 交互逻辑非常简单
❌ 性能要求极高（多一层调用）
```

### 9.3 实践应用指导


**🛠️ 实现要点**
- **接口设计**：中介者接口要简洁明确
- **注册机制**：确保所有同事对象都正确注册
- **消息路由**：实现灵活的消息分发策略
- **异常处理**：处理通信过程中的各种异常情况

**⚡ 性能考虑**
- **避免过度集中**：不要让中介者承担过多职责
- **异步处理**：对于大量消息可以考虑异步处理
- **缓存机制**：缓存常用的路由信息提高效率

**🔧 设计技巧**
- **分层中介者**：复杂系统可以设计多层中介者
- **观察者结合**：可以与观察者模式结合使用
- **命令模式结合**：消息可以封装成命令对象

### 9.4 与其他模式的关系


```
中介者模式 vs 观察者模式：
- 中介者：多对多通过中介协调
- 观察者：一对多的依赖关系

中介者模式 vs 外观模式：
- 中介者：双向通信，动态协调
- 外观：单向调用，静态封装

中介者模式 vs 代理模式：
- 中介者：协调多个对象关系
- 代理：控制单个对象访问
```

**核心记忆**：
- 中介者模式像现实中的中介公司
- 多个对象不直接对话，都通过中介者
- 降低耦合度，提高可维护性
- 统一协调，便于扩展和修改