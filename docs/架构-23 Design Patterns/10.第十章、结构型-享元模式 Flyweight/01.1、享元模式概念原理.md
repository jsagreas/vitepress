---
title: 1、享元模式概念原理
---
## 📚 目录

1. [享元模式定义与理解](#1-享元模式定义与理解)
2. [内存优化问题的根源](#2-内存优化问题的根源)
3. [内部状态vs外部状态详解](#3-内部状态vs外部状态详解)
4. [享元模式的核心思想](#4-享元模式的核心思想)
5. [应用场景分析](#5-应用场景分析)
6. [优缺点对比](#6-优缺点对比)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 享元模式定义与理解


### 1.1 什么是享元模式


**简单理解**：享元模式就像是**共享单车**的概念 - 不需要每个人都买一辆自行车，大家可以共享使用相同的单车。

> **享元模式（Flyweight Pattern）**：通过共享技术有效地支持大量细粒度对象的重用，减少系统中对象的数量，从而降低内存消耗。

### 1.2 为什么叫"享元"


```
享元 = 共享 + 元素
┌─────────────────────────────────────┐
│  享：共享，多个地方共同使用           │
│  元：基本元素，最小的组成单位         │
│  合起来：共享基本元素，避免重复创建   │
└─────────────────────────────────────┘
```

### 1.3 生活中的享元模式例子


**📚 图书馆借书系统**
```
不用享元模式：
每个读者要看《Java编程》就买一本 → 浪费钱和空间

使用享元模式：
图书馆只买一本《Java编程》，所有人轮流借阅 → 省钱省空间
```

**🚗 汽车共享**
```
传统方式：每个人都买车 → 大部分时间车闲置
共享方式：一辆车多人使用 → 提高利用率，降低成本
```

---

## 2. 💾 内存优化问题的根源


### 2.1 对象创建带来的内存压力


想象一个**文字处理软件**，需要显示一篇10万字的文档：

```
❌ 没有优化的做法：
每个字符都创建一个对象
'H' → new Character('H', 字体, 大小, 颜色, 位置)
'e' → new Character('e', 字体, 大小, 颜色, 位置)  
'l' → new Character('l', 字体, 大小, 颜色, 位置)
'l' → new Character('l', 字体, 大小, 颜色, 位置)  ← 重复创建
'o' → new Character('o', 字体, 大小, 颜色, 位置)

结果：10万个字符 = 10万个对象 = 巨大内存消耗
```

### 2.2 问题分析


**内存浪费的原因**：
- **重复数据**：相同的字符'l'创建了多个对象
- **冗余属性**：字体、大小等信息在每个对象中都存储一份
- **对象开销**：每个对象都有额外的内存开销

### 2.3 享元模式的解决思路


```
✅ 享元模式的优化：

共享部分（字符本身）：
'H' → 一个Character对象
'e' → 一个Character对象  
'l' → 一个Character对象  ← 所有'l'都用这一个
'o' → 一个Character对象

独立部分（位置信息）：
第1个'l'在位置(100, 200)
第2个'l'在位置(150, 200)

结果：26个字母 = 26个对象 + 位置信息
```

---

## 3. 🔄 内部状态vs外部状态详解


### 3.1 状态分类的核心概念


**内部状态（Internal State）**：
- **定义**：对象本身固有的、不会因使用场景改变的属性
- **特点**：可以被多个对象共享
- **生命周期**：与对象共存亡

**外部状态（External State）**：
- **定义**：根据使用场景变化的属性
- **特点**：不能被共享，需要外部传入
- **生命周期**：使用时临时传入

### 3.2 通俗理解：以文字为例


```
📝 文字显示示例：

一个字符'A'需要这些信息：
┌─────────────────────────────────────┐
│ 字符形状：'A'     ← 内部状态         │
│ 字体类型：宋体    ← 内部状态         │ 
│ 显示位置：(x,y)   ← 外部状态         │
│ 文档ID：doc1      ← 外部状态         │
└─────────────────────────────────────┘

为什么这样分？
• 字符'A'的形状永远不变 → 可以共享
• 字体宋体的样式固定 → 可以共享
• 但每个'A'在文档中的位置不同 → 不能共享
• 每个'A'属于的文档不同 → 不能共享
```

### 3.3 状态分离的实际效果


```
原来的做法：
文档中有1000个'A' → 创建1000个对象

享元模式：
内部状态：1个'A'字符对象（共享）
外部状态：1000个位置信息（分别存储）

内存对比：
原来：1000个完整对象
现在：1个共享对象 + 1000个位置数据
```

### 3.4 判断内部外部状态的方法


**简单判断法**：
```
问自己三个问题：
1. 这个属性会因为使用场景不同而变化吗？
   → 会变化 = 外部状态
   → 不变化 = 内部状态

2. 这个属性可以被多个对象共享吗？
   → 可以共享 = 内部状态  
   → 不能共享 = 外部状态

3. 如果删除这个属性，对象还是原来的对象吗？
   → 还是 = 外部状态
   → 不是 = 内部状态
```

---

## 4. 🧠 享元模式的核心思想


### 4.1 设计理念


**分离关注点**：把对象的属性分为两类
- **本质属性**（内部状态）：定义对象是什么
- **环境属性**（外部状态）：定义对象在哪里用

**共享策略**：
```
核心思想：
┌─────────────────────────────────────┐
│  相同的内容只存储一份                │
│  不同的使用方式分别记录              │
│  = 最大化重用 + 最小化内存占用       │
└─────────────────────────────────────┘
```

### 4.2 享元工厂的作用


**享元工厂**就像一个**对象仓库**：

```
客户端要求：给我一个'A'字符
               ↓
享元工厂检查：仓库里有'A'吗？
               ↓
   有 → 直接返回已有的'A'对象
   没有 → 创建新的'A'对象，存入仓库，然后返回
```

### 4.3 工作流程图


```
客户端使用流程：

客户端                 享元工厂               享元对象
  |                       |                     |
  |--[1]请求享元对象------>|                     |
  |   getFlyweight(key)   |                     |
  |                       |--[2]检查是否存在--->|
  |                       |<-[3]返回已有/新建---|
  |<--[4]返回享元对象------|                     |
  |                       |                     |
  |--[5]调用操作方法--------------------->|     |
  |   operation(外部状态)                 |     |
  |<--[6]返回结果--------------------------|     |
```

---

## 5. 🎯 应用场景分析


### 5.1 典型应用场景


**场景特征**：
- ✅ **大量相似对象**：系统中存在大量相似的对象
- ✅ **内存敏感**：对内存使用有严格要求
- ✅ **状态可分离**：对象状态可以分为内部和外部两部分
- ✅ **外部状态较少**：外部状态相对简单，传递成本低

### 5.2 具体应用实例


**🎮 游戏开发 - 子弹系统**
```
场景：射击游戏中的子弹

内部状态（可共享）：
• 子弹的形状和材质
• 子弹的伤害值
• 子弹的速度

外部状态（不可共享）：
• 子弹当前位置
• 子弹移动方向
• 子弹所属玩家

优化效果：
1000发子弹 → 只需要几种子弹类型的对象
```

**📝 文本编辑器 - 字符处理**
```
场景：Word文档中的文字显示

内部状态：
• 字符本身（'A', 'B', 'C'...）
• 字体信息（宋体、黑体等）
• 字号大小（12pt, 14pt等）

外部状态：
• 字符在文档中的位置
• 字符的颜色（可能每个都不同）
• 所属段落信息

优化效果：
10万字文档 → 几百个字符对象
```

**🌐 网页开发 - 图标系统**
```
场景：网站中的图标显示

内部状态：
• 图标的SVG路径
• 图标的默认样式

外部状态：
• 图标的大小
• 图标的颜色
• 图标在页面中的位置

优化效果：
1000个图标使用 → 只需要加载几十种图标类型
```

### 5.3 不适用场景


**❌ 避免使用享元模式的情况**：
- **对象差异很大**：没有可共享的内部状态
- **外部状态复杂**：传递外部状态的成本很高
- **对象数量少**：内存优化的收益不明显
- **状态频繁变化**：内部状态经常需要修改

---

## 6. ⚖️ 优缺点对比


### 6.1 享元模式的优点


| 优点 | **详细说明** | **实际效果** |
|------|------------|-------------|
| 🔻 **显著减少内存占用** | `通过共享相同对象，大幅降低内存消耗` | `10万对象可能只需要几百个` |
| ⚡ **提高程序性能** | `减少对象创建和垃圾回收的开销` | `程序运行更快，响应更及时` |
| 🎯 **集中管理对象** | `享元工厂统一管理所有享元对象` | `便于控制对象的创建和销毁` |
| 🔄 **高度可重用** | `一个享元对象可以在多个场景中使用` | `提高代码的复用性` |

### 6.2 享元模式的缺点


| 缺点 | **详细说明** | **影响程度** |
|------|------------|-------------|
| 🧩 **增加系统复杂性** | `需要分离内外部状态，设计更复杂` | `中等 - 需要仔细设计` |
| 📊 **外部状态管理负担** | `客户端需要维护和传递外部状态` | `中等 - 增加使用难度` |
| 🔒 **共享对象限制** | `享元对象通常需要设计为不可变` | `低 - 设计时需要注意` |
| 🐛 **调试困难** | `共享对象的状态变化影响多处` | `低 - 主要影响调试` |

### 6.3 使用建议


**✅ 适合使用的情况**：
```
判断标准：
• 系统中有大量相似对象（>1000个）
• 内存使用是关键瓶颈
• 对象的状态可以明确分为内部和外部
• 外部状态传递成本较低
```

**❌ 不建议使用的情况**：
```
避免场景：
• 对象数量很少（<100个）
• 对象之间差异很大
• 外部状态非常复杂
• 系统对内存要求不高
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 享元模式本质：通过共享减少对象数量，优化内存使用
🔸 状态分离原理：内部状态共享，外部状态分别管理
🔸 享元工厂作用：统一管理和提供享元对象
🔸 适用场景特征：大量相似对象 + 内存敏感 + 状态可分离
🔸 主要优势：显著减少内存占用，提高性能
```

### 7.2 关键理解要点


**🔹 享元模式的核心思想**
```
类比理解：
就像图书馆 - 一本书可以被很多人借阅
而不是每个人都去买一本相同的书

技术实现：
一个享元对象可以在多个地方使用
而不是每个地方都创建新对象
```

**🔹 内部状态和外部状态的区别**
```
简单判断：
• 内部状态：定义"这是什么"
• 外部状态：定义"在哪里用"、"怎么用"

实际例子：
字符'A'：
• 内部状态：字符形状（始终是'A'）
• 外部状态：显示位置（每次都不同）
```

**🔹 什么时候使用享元模式**
```
三个关键条件：
1. 有很多相似的对象
2. 内存使用很重要
3. 对象属性可以分为两类

满足这三个条件 → 考虑使用享元模式
```

### 7.3 实际应用价值


**🎯 业务场景应用**
- **游戏开发**：管理大量游戏元素（子弹、粒子效果等）
- **文档处理**：优化文字处理软件的内存使用
- **图形界面**：管理界面中的重复元素
- **数据可视化**：处理大量相似的图表元素

**🔧 技术实现关键**
- **享元工厂**：使用HashMap等结构缓存享元对象
- **状态分离**：明确哪些属性是内部状态，哪些是外部状态
- **不可变设计**：享元对象通常设计为不可变，确保线程安全
- **生命周期管理**：合理控制享元对象的创建和销毁

**💡 设计原则体现**
```
享元模式体现的设计原则：
• 单一职责：享元对象只负责自身的核心功能
• 开闭原则：可以通过增加新的享元类型来扩展
• 组合优于继承：通过组合外部状态来实现不同行为
```

**记忆口诀**：
```
享元模式减内存，内外状态要分清
相同内容共享用，不同场景外部传
大量对象才考虑，简单场景别滥用
```

### 7.4 学习检查点


**☑️ 概念理解检查**
- [ ] 能用自己的话解释什么是享元模式
- [ ] 明确内部状态和外部状态的区别
- [ ] 理解享元工厂的作用和工作原理
- [ ] 知道什么情况下应该使用享元模式

**☑️ 应用能力检查**
- [ ] 能够识别哪些对象适合使用享元模式
- [ ] 会分析对象的状态，分离内部和外部状态
- [ ] 理解享元模式对系统性能的影响
- [ ] 知道享元模式的优缺点和适用场景

**下一步学习方向**：
- 📖 学习享元模式的具体实现代码
- 🔧 练习设计简单的享元模式案例
- 🎯 了解享元模式在实际项目中的应用
- 📊 学习享元模式的性能优化技巧