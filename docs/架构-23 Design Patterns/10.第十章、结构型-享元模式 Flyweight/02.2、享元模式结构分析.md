---
title: 2、享元模式结构分析
---
## 📚 目录

1. [享元模式整体架构](#1-享元模式整体架构)
2. [抽象享元接口设计](#2-抽象享元接口设计)
3. [具体享元实现](#3-具体享元实现)
4. [享元工厂设计](#4-享元工厂设计)
5. [客户端状态管理](#5-客户端状态管理)
6. [共享机制实现](#6-共享机制实现)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏗️ 享元模式整体架构


### 1.1 模式结构图解


```
享元模式结构关系图：

    客户端(Client)
         |
         | 使用
         ↓
   享元工厂(FlyweightFactory) ←──┐
         |                      |
         | 创建和管理              | 共享
         ↓                      |
   抽象享元(Flyweight)          |
         ↑                      |
         | 实现                  |
         |                      |
   具体享元(ConcreteFlyweight) ──┘
```

### 1.2 角色职责分工


| 🎭 角色 | 📋 职责 | 💡 比喻理解 |
|---------|---------|-------------|
| **抽象享元** | `定义享元对象的接口` | 图书馆书籍的通用规范 |
| **具体享元** | `实现享元接口，存储内部状态` | 具体的某本书 |
| **享元工厂** | `创建和管理享元对象` | 图书馆管理员 |
| **客户端** | `维护外部状态，使用享元` | 借书的读者 |

### 1.3 内部状态vs外部状态


**🔍 状态分类理解**

```
以文字处理软件为例：

内部状态（可共享）：
├─ 字体类型：宋体、微软雅黑、Times New Roman
├─ 字体大小：12pt、14pt、16pt  
├─ 字体样式：粗体、斜体、下划线
└─ 颜色信息：黑色、红色、蓝色

外部状态（不可共享）：
├─ 文档位置：第3行第5列
├─ 选中状态：是否被选中
├─ 显示坐标：(x=100, y=200)
└─ 上下文信息：所属段落、所属页面
```

> 💡 **记忆技巧**
> 
> **内部状态**：就像人的DNA，天生固有，可以被多个对象共享
> **外部状态**：就像人的位置，因环境而变，每个对象都不同

---

## 2. 📝 抽象享元接口设计


### 2.1 接口设计原则


**🎯 设计要点**
- ✅ 接受外部状态作为参数
- ✅ 不能依赖具体的外部状态
- ✅ 方法具有通用性
- ✅ 便于具体享元实现

### 2.2 接口定义示例


```java
/**
 * 抽象享元接口 - 文字享元
 * 就像定义"所有文字都应该能做什么"
 */
public interface TextFlyweight {
    
    /**
     * 核心操作方法
     * @param extrinsicState 外部状态（位置、上下文等）
     */
    void display(TextContext extrinsicState);
    
    /**
     * 获取内部状态信息（可选）
     * @return 内部状态描述
     */
    String getIntrinsicState();
}
```

### 2.3 外部状态封装


```java
/**
 * 外部状态封装类
 * 把变化的信息打包，传递给享元对象
 */
public class TextContext {
    private int row;        // 行号
    private int column;     // 列号
    private boolean selected; // 是否选中
    
    // 构造方法
    public TextContext(int row, int column, boolean selected) {
        this.row = row;
        this.column = column;
        this.selected = selected;
    }
    
    // getter方法
    public int getRow() { return row; }
    public int getColumn() { return column; }
    public boolean isSelected() { return selected; }
}
```

> 🔥 **设计关键**
> 
> 抽象享元接口就像是一个"标准协议"，规定了所有享元对象都必须遵守的规则

---

## 3. 🎨 具体享元实现


### 3.1 实现设计思路


**📋 实现步骤**
1. **存储内部状态** - 保存可共享的属性
2. **实现接口方法** - 处理外部状态参数
3. **保证线程安全** - 多个客户端可能同时使用
4. **优化性能** - 避免重复计算

### 3.2 具体享元实现


```java
/**
 * 具体享元实现 - 文字样式享元
 * 就像具体的某种字体样式
 */
public class ConcreteTextFlyweight implements TextFlyweight {
    
    // 内部状态 - 这些属性在对象创建后不会改变
    private final String fontName;    // 字体名称
    private final int fontSize;       // 字体大小  
    private final String fontStyle;   // 字体样式
    private final String color;       // 颜色
    
    /**
     * 构造方法 - 初始化内部状态
     */
    public ConcreteTextFlyweight(String fontName, int fontSize, 
                                String fontStyle, String color) {
        this.fontName = fontName;
        this.fontSize = fontSize;
        this.fontStyle = fontStyle;
        this.color = color;
    }
    
    /**
     * 核心业务方法 - 结合内部状态和外部状态完成操作
     */
    @Override
    public void display(TextContext context) {
        System.out.printf("在位置(%d,%d)显示文字: 字体=%s, 大小=%d, 样式=%s, 颜色=%s%n",
            context.getRow(), context.getColumn(),
            fontName, fontSize, fontStyle, color);
            
        // 根据选中状态决定显示效果
        if (context.isSelected()) {
            System.out.println("  └─ 文字被选中，显示高亮背景");
        }
    }
    
    @Override
    public String getIntrinsicState() {
        return String.format("字体:%s, 大小:%d, 样式:%s, 颜色:%s", 
                           fontName, fontSize, fontStyle, color);
    }
}
```

### 3.3 享元对象特性


**🔍 关键特性分析**

| 特性 | 说明 | 实现方式 |
|------|------|----------|
| **不可变性** | `内部状态创建后不能修改` | 使用final字段 |
| **线程安全** | `多个线程可以同时使用` | 无状态或只读状态 |
| **可复用性** | `相同内部状态的对象可共享` | 工厂模式管理 |
| **轻量级** | `对象占用内存小` | 只存储必要的内部状态 |

---

## 4. 🏭 享元工厂设计


### 4.1 工厂职责分析


**🎯 工厂核心职责**
- 🔧 **创建享元对象** - 按需创建新的享元实例
- 📦 **缓存管理** - 存储已创建的享元对象
- 🔍 **查找复用** - 查找是否有可复用的享元
- 💾 **内存优化** - 控制享元对象的数量

### 4.2 工厂实现模式


```java
/**
 * 享元工厂 - 文字享元工厂
 * 就像图书馆管理员，负责管理所有的书籍
 */
public class TextFlyweightFactory {
    
    // 享元池 - 存储已创建的享元对象
    private static final Map<String, TextFlyweight> flyweightPool = 
        new ConcurrentHashMap<>();
    
    /**
     * 获取享元对象 - 核心方法
     * @param fontName 字体名称
     * @param fontSize 字体大小
     * @param fontStyle 字体样式  
     * @param color 颜色
     * @return 享元对象
     */
    public static TextFlyweight getFlyweight(String fontName, int fontSize,
                                           String fontStyle, String color) {
        
        // 生成唯一键 - 标识内部状态的组合
        String key = generateKey(fontName, fontSize, fontStyle, color);
        
        // 尝试从池中获取
        TextFlyweight flyweight = flyweightPool.get(key);
        
        if (flyweight == null) {
            // 池中没有，创建新的享元对象
            flyweight = new ConcreteTextFlyweight(fontName, fontSize, fontStyle, color);
            flyweightPool.put(key, flyweight);
            
            System.out.println("🆕 创建新享元: " + key);
        } else {
            System.out.println("♻️ 复用享元: " + key);
        }
        
        return flyweight;
    }
    
    /**
     * 生成享元对象的唯一标识
     */
    private static String generateKey(String fontName, int fontSize,
                                    String fontStyle, String color) {
        return String.format("%s_%d_%s_%s", fontName, fontSize, fontStyle, color);
    }
    
    /**
     * 获取享元池状态信息
     */
    public static void printPoolStatus() {
        System.out.println("\n📊 享元池状态:");
        System.out.println("   总数量: " + flyweightPool.size());
        flyweightPool.forEach((key, flyweight) -> 
            System.out.println("   " + key + " -> " + flyweight.getIntrinsicState()));
    }
}
```

### 4.3 工厂设计要点


**🔧 设计考虑**

```
工厂设计要点:

线程安全性:
├─ 使用ConcurrentHashMap
├─ 静态方法避免实例竞争
└─ 享元对象本身线程安全

键值设计:
├─ 唯一性: 相同内部状态生成相同键
├─ 简洁性: 键值不宜过长
└─ 可读性: 便于调试和维护

内存管理:
├─ 合理的缓存策略
├─ 必要时清理无用享元
└─ 监控池的大小
```

---

## 5. 👥 客户端状态管理


### 5.1 客户端职责


**📋 客户端核心任务**
- 🏠 **维护外部状态** - 管理变化的、不可共享的数据
- 🔄 **调用享元对象** - 将外部状态传递给享元
- 📊 **状态组合** - 将内部状态和外部状态结合使用

### 5.2 客户端实现示例


```java
/**
 * 文档编辑器 - 享元模式的客户端
 * 就像使用图书馆的读者
 */
public class DocumentEditor {
    
    // 文档内容 - 每个字符对应一个享元和外部状态
    private List<Character> content = new ArrayList<>();
    private List<TextContext> contexts = new ArrayList<>();
    
    /**
     * 添加字符到文档
     */
    public void addCharacter(char ch, String fontName, int fontSize,
                           String fontStyle, String color,
                           int row, int column) {
        
        // 获取享元对象（内部状态）
        TextFlyweight flyweight = TextFlyweightFactory.getFlyweight(
            fontName, fontSize, fontStyle, color);
        
        // 创建外部状态
        TextContext context = new TextContext(row, column, false);
        
        // 存储字符和对应的状态
        content.add(ch);
        contexts.add(context);
        
        System.out.printf("✏️ 添加字符 '%c' 到位置(%d,%d)%n", ch, row, column);
    }
    
    /**
     * 显示文档内容
     */
    public void displayDocument() {
        System.out.println("\n📄 显示文档内容:");
        
        for (int i = 0; i < content.size(); i++) {
            char ch = content.get(i);
            TextContext context = contexts.get(i);
            
            // 重新获取享元对象并显示
            TextFlyweight flyweight = TextFlyweightFactory.getFlyweight(
                "宋体", 12, "normal", "black"); // 简化示例
            
            System.out.print("字符: " + ch + " ");
            flyweight.display(context);
        }
    }
    
    /**
     * 选中文本
     */
    public void selectText(int startIndex, int endIndex) {
        System.out.printf("\n🎯 选中文本范围: %d - %d%n", startIndex, endIndex);
        
        for (int i = startIndex; i <= endIndex && i < contexts.size(); i++) {
            TextContext oldContext = contexts.get(i);
            // 创建新的选中状态的外部状态对象
            TextContext newContext = new TextContext(
                oldContext.getRow(), oldContext.getColumn(), true);
            contexts.set(i, newContext);
        }
    }
}
```

### 5.3 状态分离的好处


**💡 分离的优势**

```
状态分离带来的好处:

内存效率:
100个字符 × 相同样式 = 1个享元对象 + 100个位置信息
而不是: 100个完整的字符对象

性能提升:
├─ 减少对象创建时间
├─ 降低垃圾回收压力  
└─ 提高缓存命中率

灵活性增强:
├─ 外部状态可以独立变化
├─ 内部状态保持稳定
└─ 便于扩展新的状态类型
```

---

## 6. 🔄 共享机制实现


### 6.1 共享机制原理


**🔧 共享的核心机制**

```
享元共享机制流程:

客户端请求
    ↓
检查工厂池
    ↓
存在? → 是 → 返回现有享元
    ↓
    否
    ↓  
创建新享元 → 加入池中 → 返回新享元
```

### 6.2 共享效果验证


```java
/**
 * 共享机制演示
 */
public class FlyweightDemo {
    
    public static void main(String[] args) {
        
        System.out.println("🚀 享元模式共享机制演示\n");
        
        // 创建多个相同样式的文字享元
        TextFlyweight flyweight1 = TextFlyweightFactory.getFlyweight(
            "宋体", 12, "bold", "black");
        
        TextFlyweight flyweight2 = TextFlyweightFactory.getFlyweight(
            "宋体", 12, "bold", "black");
        
        TextFlyweight flyweight3 = TextFlyweightFactory.getFlyweight(
            "微软雅黑", 14, "normal", "red");
        
        // 验证对象是否为同一个实例
        System.out.println("\n🔍 对象引用比较:");
        System.out.println("flyweight1 == flyweight2: " + (flyweight1 == flyweight2));
        System.out.println("flyweight1 == flyweight3: " + (flyweight1 == flyweight3));
        
        // 显示享元池状态
        TextFlyweightFactory.printPoolStatus();
        
        // 使用享元对象
        System.out.println("\n📝 使用享元对象:");
        flyweight1.display(new TextContext(1, 1, false));
        flyweight2.display(new TextContext(1, 5, true));  // 复用同一享元
        flyweight3.display(new TextContext(2, 1, false));
    }
}
```

### 6.3 共享效果分析


**📊 内存占用对比**

```
传统方式 vs 享元模式内存对比:

传统方式（1000个字符，10种样式）:
┌─────────────────────────────────┐
│ 1000个完整对象                   │
│ 每个对象: 字体+大小+样式+颜色+位置 │  
│ 总内存: 1000 × 100字节 = 100KB  │
└─────────────────────────────────┘

享元模式:
┌─────────────────────────────────┐
│ 10个享元对象: 10 × 50字节 = 0.5KB │
│ 1000个外部状态: 1000×20字节=20KB │
│ 总内存: 20.5KB                  │
│ 节省: 79.5KB (79.5%节省)        │
└─────────────────────────────────┘
```

> ⭐ **性能提升总结**
> 
> - **内存节省**: 节省70-90%的内存占用
> - **创建效率**: 减少重复对象创建时间
> - **缓存友好**: 提高CPU缓存命中率

---

## 7. 📋 核心要点总结


### 7.1 享元模式结构要素


```
🏗️ 享元模式四大角色:

抽象享元(Flyweight):
├─ 定义享元接口
├─ 声明接受外部状态的方法
└─ 保证具体享元的一致性

具体享元(ConcreteFlyweight):  
├─ 实现享元接口
├─ 存储内部状态
├─ 处理外部状态参数
└─ 保证线程安全

享元工厂(FlyweightFactory):
├─ 创建和管理享元对象
├─ 维护享元对象池
├─ 提供享元获取接口
└─ 控制享元数量

客户端(Client):
├─ 维护外部状态
├─ 调用享元对象
└─ 组合内外部状态
```

### 7.2 关键设计原则


**🎯 设计要点**

| 原则 | 说明 | 实现要点 |
|------|------|----------|
| **状态分离** | `内部状态可共享，外部状态独立维护` | 明确划分状态边界 |
| **对象复用** | `相同内部状态的对象只创建一次` | 工厂模式+对象池 |
| **线程安全** | `享元对象必须是线程安全的` | 不可变对象设计 |
| **内存优化** | `减少对象数量，降低内存占用` | 共享机制实现 |

### 7.3 实现检查清单


**✅ 实现要点检查**

- [x] **内部状态确定性** - 内部状态在对象创建后不可变
- [x] **外部状态独立性** - 外部状态与享元对象解耦
- [x] **工厂单例模式** - 享元工厂采用单例或静态方法
- [x] **线程安全保证** - 享元对象和工厂都要线程安全
- [x] **键值设计合理** - 享元池的键值能唯一标识内部状态
- [x] **内存管理策略** - 有必要的清理和监控机制

### 7.4 常见应用场景


**🎯 典型应用**
- **文字处理软件** - 字符的字体样式共享
- **游戏开发** - 相同类型NPC、道具的属性共享  
- **图形界面** - 相同样式的UI组件共享
- **数据库连接池** - 连接对象的复用管理

**核心记忆**：
> 🧠 **享元模式口诀**
> 
> *"内部状态可共享，外部状态分开管；工厂负责来创建，客户端把状态传"*

享元模式通过内外状态分离，实现了对象的高效复用，在需要大量相似对象的场景中能显著减少内存占用和提升性能。