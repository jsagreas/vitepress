---
title: 1、模板方法模式概念原理
---
## 📚 目录

1. [模板方法模式定义](#1-模板方法模式定义)
2. [算法框架固定原理](#2-算法框架固定原理)
3. [可变部分子类实现机制](#3-可变部分子类实现机制)
4. [应用场景深度分析](#4-应用场景深度分析)
5. [优缺点全面对比](#5-优缺点全面对比)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 模板方法模式定义


### 1.1 什么是模板方法模式


**通俗理解**：就像做菜的标准流程一样，每道菜的基本步骤都是固定的（洗菜→切菜→炒菜→装盘），但每个步骤的具体做法可以不同。

```
做菜的通用流程：
准备食材 → 处理食材 → 烹饪加工 → 最终装盘

炒青菜的具体实现：
洗青菜 → 切青菜 → 爆炒青菜 → 装盘上桌

红烧肉的具体实现：
选五花肉 → 切块焯水 → 红烧炖煮 → 装盘上桌
```

### 1.2 正式定义解析


**模板方法模式（Template Method Pattern）**：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**核心要素分解**：
- **🏗️ 算法骨架**：整个流程的框架是固定的
- **🔧 延迟实现**：具体步骤的实现推迟到子类
- **🔒 结构不变**：子类只能改变步骤内容，不能改变步骤顺序
- **♻️ 代码复用**：公共部分在父类中实现

### 1.3 生活中的模板方法


```
考试流程模板：
进入考场 → 检查证件 → 分发试卷 → 开始答题 → 收卷离场

不同考试的具体实现：
语文考试：检查准考证 → 发语文卷 → 写作文答题 → 收卷
数学考试：检查准考证 → 发数学卷 → 计算解题 → 收卷
英语考试：检查准考证 → 发英语卷 → 听力阅读 → 收卷

旅游出行模板：
制定计划 → 准备物品 → 出发旅行 → 游玩体验 → 返回总结

国内游：订酒店 → 带身份证 → 高铁出发 → 景点游览 → 回家休息
出国游：办签证 → 带护照 → 飞机出发 → 异国体验 → 回国倒时差
```

---

## 2. 🏗️ 算法框架固定原理


### 2.1 框架固定的含义


**什么叫"算法骨架固定"**？

```
想象一下装修房子的流程：

固定的装修步骤（算法骨架）：
1. 设计方案
2. 拆除改造  
3. 水电布线
4. 泥瓦工程
5. 木工制作
6. 油漆涂刷
7. 安装设备
8. 软装布置

这个顺序是不能变的！
你不能先刷油漆再做水电，那样就乱套了
```

### 2.2 模板方法的结构组成


**模板方法模式的角色分工**：

```
抽象父类 (AbstractClass)
├── 模板方法 (templateMethod) ← 定义算法骨架，调用各个步骤
├── 具体方法 (concreteMethod) ← 已经实现的公共步骤  
├── 抽象方法 (abstractMethod) ← 子类必须实现的步骤
└── 钩子方法 (hookMethod) ← 子类可选择实现的步骤

具体子类 (ConcreteClass)
└── 实现抽象方法 ← 提供具体的步骤实现
```

### 2.3 控制反转原理


**为什么叫"控制反转"**？

```
传统方式（子类控制流程）：
子类决定：我要先做A，再做B，最后做C

模板方法（父类控制流程）：
父类决定：流程必须是A→B→C，你只需要告诉我A、B、C具体怎么做

这就是"好莱坞原则"：Don't call us, we'll call you
（别找我们，我们会找你）
```

### 2.4 简单代码示例


```java
// 抽象父类：定义做饭的通用流程
abstract class CookingTemplate {
    
    // 模板方法：固定的做饭流程（不能被重写）
    public final void cook() {
        System.out.println("=== 开始做饭 ===");
        prepareIngredients();  // 步骤1：准备食材
        processIngredients();  // 步骤2：处理食材  
        cooking();            // 步骤3：烹饪
        serving();            // 步骤4：装盘
        System.out.println("=== 做饭完成 ===");
    }
    
    // 抽象方法：子类必须实现
    protected abstract void prepareIngredients();
    protected abstract void processIngredients(); 
    protected abstract void cooking();
    
    // 具体方法：公共实现
    protected void serving() {
        System.out.println("装盘上桌");
    }
}

// 具体子类：炒青菜
class VegetableStirFry extends CookingTemplate {
    protected void prepareIngredients() {
        System.out.println("准备青菜、蒜、油");
    }
    
    protected void processIngredients() {
        System.out.println("洗菜、切菜、拍蒜");
    }
    
    protected void cooking() {
        System.out.println("热锅下油，爆炒青菜");
    }
}
```

---

## 3. 🔧 可变部分子类实现机制


### 3.1 三种方法类型详解


**模板方法模式中的方法分类**：

| 方法类型 | **实现位置** | **能否重写** | **作用说明** | **生活类比** |
|---------|------------|-------------|-------------|-------------|
| 🔒 **模板方法** | `父类实现` | `不可重写` | `定义算法流程` | `考试规则流程` |
| ✅ **具体方法** | `父类实现` | `不建议重写` | `公共步骤实现` | `检查证件环节` |
| ❓ **抽象方法** | `子类实现` | `必须重写` | `变化步骤实现` | `答题内容不同` |
| 🎣 **钩子方法** | `父类默认实现` | `可选重写` | `扩展控制点` | `是否需要草稿纸` |

### 3.2 抽象方法 - 必须实现


**抽象方法就像填空题**：框架给你挖了空，你必须填上内容。

```java
// 数据处理模板
abstract class DataProcessor {
    
    public final void processData() {
        loadData();      // 必须实现：数据来源不同
        validateData();  // 必须实现：验证规则不同  
        transformData(); // 必须实现：转换逻辑不同
        saveData();      // 必须实现：存储方式不同
    }
    
    // 这些都是"填空题"，子类必须填上具体内容
    protected abstract void loadData();
    protected abstract void validateData();
    protected abstract void transformData(); 
    protected abstract void saveData();
}

// CSV文件处理器
class CsvProcessor extends DataProcessor {
    protected void loadData() {
        System.out.println("从CSV文件读取数据");
    }
    
    protected void validateData() {
        System.out.println("检查CSV格式是否正确");
    }
    
    // ... 其他方法实现
}

// 数据库处理器  
class DatabaseProcessor extends DataProcessor {
    protected void loadData() {
        System.out.println("从数据库查询数据");
    }
    
    protected void validateData() {
        System.out.println("检查数据完整性约束");
    }
    
    // ... 其他方法实现
}
```

### 3.3 钩子方法 - 可选控制


**钩子方法就像开关**：你可以选择打开或关闭某些功能。

```java
abstract class GameTemplate {
    
    public final void playGame() {
        startGame();
        
        // 钩子方法控制是否显示教程
        if (needTutorial()) {
            showTutorial();
        }
        
        playMainGame();
        
        // 钩子方法控制是否保存进度
        if (needSaveProgress()) {
            saveProgress();
        }
        
        endGame();
    }
    
    // 钩子方法：默认实现，子类可以选择重写
    protected boolean needTutorial() {
        return false;  // 默认不需要教程
    }
    
    protected boolean needSaveProgress() {
        return true;   // 默认保存进度
    }
    
    // 默认的钩子方法实现
    protected void showTutorial() {
        System.out.println("显示游戏教程");
    }
    
    protected void saveProgress() {
        System.out.println("保存游戏进度");
    }
    
    // 抽象方法
    protected abstract void startGame();
    protected abstract void playMainGame();
    protected abstract void endGame();
}

// 新手游戏：需要教程
class BeginnerGame extends GameTemplate {
    protected boolean needTutorial() {
        return true;  // 新手需要教程
    }
    
    protected void startGame() {
        System.out.println("新手游戏开始");
    }
    
    protected void playMainGame() {
        System.out.println("简单模式游戏");
    }
    
    protected void endGame() {
        System.out.println("新手游戏结束");
    }
}
```

### 3.4 方法调用时序图


```
客户端调用流程：
   客户端
      |
      |--[1] 调用 templateMethod()
      |
   父类模板方法
      |
      |--[2] 调用 concreteMethod() ──→ 父类执行
      |
      |--[3] 调用 abstractMethod() ──→ 子类执行
      |
      |--[4] 调用 hookMethod() ───────→ 子类选择性执行
      |
      |--[5] 返回结果
      |
   客户端收到结果
```

---

## 4. 🎪 应用场景深度分析


### 4.1 框架开发场景


**Web框架中的应用**：几乎所有Web框架都使用了模板方法模式。

```
HTTP请求处理流程：

通用处理步骤（框架定义）：
1. 接收HTTP请求
2. 解析请求参数  
3. 权限验证检查
4. 业务逻辑处理  ← 这步交给开发者实现
5. 生成响应结果
6. 返回HTTP响应

Spring MVC示例：
框架帮你处理：接收请求、参数解析、响应生成
你只需要写：Controller中的业务逻辑方法

Servlet示例：
框架帮你处理：HTTP协议解析、线程管理
你只需要重写：doGet()、doPost()方法
```

### 4.2 数据库操作场景


**JDBC Template的典型应用**：

```
数据库操作通用流程：

固定步骤（框架处理）：
1. 获取数据库连接
2. 创建SQL语句
3. 设置参数并执行  ← 具体SQL由你提供
4. 处理结果集      ← 结果处理由你定义  
5. 关闭连接资源

你只需要关心：
- 写什么SQL语句
- 怎么处理查询结果
- 设置什么参数

框架帮你处理：
- 连接管理
- 资源释放  
- 异常处理
- 事务控制
```

### 4.3 算法流程场景


**排序算法的模板方法应用**：

```java
// 排序算法模板
abstract class SortTemplate {
    
    // 模板方法：定义排序的通用流程
    public final void sort(int[] array) {
        if (array.length <= 1) return;
        
        System.out.println("开始排序：" + Arrays.toString(array));
        doSort(array);  // 具体排序算法由子类实现
        System.out.println("排序完成：" + Arrays.toString(array));
    }
    
    // 抽象方法：具体的排序实现
    protected abstract void doSort(int[] array);
}

// 冒泡排序实现
class BubbleSort extends SortTemplate {
    protected void doSort(int[] array) {
        // 冒泡排序的具体实现
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    // 交换元素
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
}

// 选择排序实现
class SelectionSort extends SortTemplate {
    protected void doSort(int[] array) {
        // 选择排序的具体实现
        for (int i = 0; i < array.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            // 交换元素
            int temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
    }
}
```

### 4.4 文件处理场景


**文档处理系统的应用**：

```
文档处理通用流程：

标准处理步骤：
1. 打开文档文件
2. 读取文档内容  ← 不同格式读取方式不同
3. 解析文档结构  ← 解析规则因格式而异
4. 转换文档格式  ← 转换逻辑各不相同
5. 保存处理结果
6. 关闭文档文件

Word文档处理：
读取：使用POI库读取.docx文件
解析：解析段落、表格、图片结构
转换：转为HTML或PDF格式

PDF文档处理：  
读取：使用PDFBox读取.pdf文件
解析：解析页面、文本、图像内容
转换：转为文本或图片格式

Excel文档处理：
读取：使用POI库读取.xlsx文件  
解析：解析工作表、单元格数据
转换：转为CSV或JSON格式
```

### 4.5 选择使用的判断标准


**什么时候使用模板方法模式**？

```
✅ 适合使用的情况：

1. 流程固定，细节可变
   - 有明确的步骤顺序
   - 每个步骤的具体实现可能不同
   
2. 代码复用需求高
   - 多个类有相似的处理流程
   - 公共部分占比较大

3. 控制子类扩展
   - 希望子类只能在特定点进行扩展
   - 防止子类破坏核心流程

❌ 不适合使用的情况：

1. 流程经常变化
   - 步骤顺序不固定
   - 流程差异很大

2. 只有少量公共代码
   - 各个实现差异巨大
   - 公共部分很少

3. 需要灵活的控制流
   - 需要动态改变执行顺序
   - 需要条件性跳过某些步骤
```

---

## 5. ⚖️ 优缺点全面对比


### 5.1 主要优点分析


**🔄 代码复用性强**

```
没有模板方法时：
class WordProcessor {
    public void process() {
        openFile();
        readWordContent();    // 重复代码
        parseWordStructure(); 
        convertWordToPdf();
        saveFile();           // 重复代码
        closeFile();          // 重复代码
    }
}

class ExcelProcessor {
    public void process() {
        openFile();           // 重复代码
        readExcelContent();
        parseExcelStructure();
        convertExcelToCsv();
        saveFile();           // 重复代码  
        closeFile();          // 重复代码
    }
}

使用模板方法后：
abstract class DocumentProcessor {
    public final void process() {
        openFile();     // 公共代码，只写一次
        readContent();  // 子类实现
        parseStructure(); // 子类实现
        convert();      // 子类实现
        saveFile();     // 公共代码，只写一次
        closeFile();    // 公共代码，只写一次
    }
}

代码重复率从60%降低到0%！
```

**🔒 控制流程一致性**

```
好处：防止子类"乱来"

没有模板方法的风险：
class BadGameImplementation {
    public void playGame() {
        endGame();        // 还没开始就结束？
        startGame();      // 顺序错乱
        // 忘记了保存进度
    }
}

有了模板方法的保障：
abstract class GameTemplate {
    public final void playGame() {
        startGame();      // 强制按正确顺序
        playMainGame();   
        saveProgress();   // 强制保存进度
        endGame();        // 最后才能结束
    }
}

子类想改顺序？不可能！因为final修饰符
```

**📈 扩展性好**

```
新增功能很简单：

// 原有的游戏类型
class PuzzleGame extends GameTemplate { ... }
class ActionGame extends GameTemplate { ... }

// 新增RPG游戏，只需实现抽象方法
class RPGGame extends GameTemplate {
    protected void startGame() {
        System.out.println("创建角色，选择职业");
    }
    
    protected void playMainGame() {
        System.out.println("冒险、升级、打怪");
    }
    
    protected void endGame() {
        System.out.println("保存角色数据");
    }
}

新类型游戏：10分钟搞定！
```

### 5.2 主要缺点分析


**📚 代码复杂度增加**

```
简单功能被过度设计：

原本简单的实现：
class SimpleCalculator {
    public int add(int a, int b) {
        return a + b;  // 就这么简单
    }
}

过度使用模板方法：
abstract class CalculatorTemplate {
    public final int calculate(int a, int b) {
        validateInput(a, b);   // 非必要的步骤
        int result = doCalculate(a, b);
        logResult(result);     // 非必要的步骤
        return result;
    }
    
    protected abstract int doCalculate(int a, int b);
    // ... 一堆其他方法
}

class AddCalculator extends CalculatorTemplate {
    protected int doCalculate(int a, int b) {
        return a + b;  // 原本1行代码，现在要写整个类
    }
}

简单事情复杂化了！
```

**🔗 类间耦合度高**

```
父子类紧密绑定：

abstract class StrictTemplate {
    public final void process() {
        step1();  // 子类必须实现
        step2();  // 子类必须实现  
        step3();  // 子类必须实现
        step4();  // 子类必须实现
    }
    
    // 父类定义了太多抽象方法
    protected abstract void step1();
    protected abstract void step2();
    protected abstract void step3();
    protected abstract void step4();
}

// 子类被迫实现所有方法，即使某些不需要
class SimpleChild extends StrictTemplate {
    protected void step1() { /* 实际需要 */ }
    protected void step2() { /* 实际需要 */ }
    protected void step3() { /* 不需要但被迫实现 */ }
    protected void step4() { /* 不需要但被迫实现 */ }
}

子类失去了灵活性！
```

**🔧 维护成本增加**

```
修改父类影响所有子类：

// 父类增加了新步骤
abstract class DocumentTemplate {
    public final void process() {
        openFile();
        readContent();
        parseStructure();
        validateSecurity();  // 新增的步骤
        convert();
        saveFile();
        closeFile();
    }
    
    // 新增的抽象方法
    protected abstract void validateSecurity();
}

// 结果：所有子类都必须修改！
class WordProcessor extends DocumentTemplate {
    // 被迫实现新方法
    protected void validateSecurity() {
        // Word文档可能不需要这个验证
    }
}

class PdfProcessor extends DocumentTemplate {
    // 被迫实现新方法  
    protected void validateSecurity() {
        // PDF处理也被迫加入验证
    }
}

一改父类，全部子类都要改！
```

### 5.3 优缺点对比表


| 方面 | **优点** | **缺点** | **适用场景** |
|------|---------|---------|-------------|
| 📊 **代码复用** | `公共代码只写一次` | `简单功能被复杂化` | `有大量公共逻辑` |
| 🔒 **流程控制** | `保证步骤顺序正确` | `子类失去流程控制权` | `流程固定不变` |
| 🔧 **扩展性** | `新增实现很容易` | `修改父类影响面大` | `经常新增子类` |
| 📚 **维护性** | `集中管理公共逻辑` | `类间耦合度较高` | `团队开发规范` |
| 🎯 **学习成本** | `模式理解相对简单` | `需要理解继承关系` | `团队经验充足` |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 模板方法本质：定义算法骨架，延迟具体实现到子类
🔸 控制反转原理：父类控制流程，子类提供实现
🔸 三种方法类型：模板方法、抽象方法、钩子方法
🔸 适用场景判断：流程固定+细节可变+代码复用需求高
🔸 优缺点权衡：复用性强但耦合度高，需要合理使用
```

### 6.2 关键理解要点


**🔹 模板方法的精髓**

```
核心思想：
- 分离不变与可变：不变的是流程，可变的是实现
- 职责明确分工：父类管流程，子类管细节
- 开闭原则体现：对扩展开放，对修改封闭

记忆口诀：
流程在父类，细节在子类
骨架不能变，血肉可定制
```

**🔹 三种方法的作用**

```
模板方法：总指挥，控制整个流程
抽象方法：填空题，子类必须填写答案  
钩子方法：开关键，子类可选择启用功能

生活类比：
模板方法 = 考试规则（不能变）
抽象方法 = 考试题目（每科不同）
钩子方法 = 是否需要草稿纸（可选）
```

**🔹 使用时机判断**

```
使用模板方法的信号：
✅ 多个类有相似的处理流程
✅ 流程步骤基本固定
✅ 公共代码重复度高
✅ 需要统一控制执行顺序

不使用模板方法的信号：  
❌ 每个实现差异巨大
❌ 流程经常需要变化
❌ 只有很少的公共代码
❌ 需要灵活控制执行流程
```

### 6.3 实际应用建议


**🎯 最佳实践指导**

```
设计建议：
1. 模板方法用final修饰，防止子类破坏流程
2. 抽象方法数量适中，避免子类实现负担过重
3. 合理使用钩子方法，提供必要的扩展点
4. 在父类中提供默认实现，降低子类实现难度

命名建议：
- 模板方法：process()、execute()、run()
- 抽象方法：doXxx()、handleXxx()、processXxx()  
- 钩子方法：isXxx()、needXxx()、shouldXxx()

性能考虑：
- 避免在模板方法中进行复杂计算
- 抽象方法的调用开销通常可以忽略
- 合理使用钩子方法避免不必要的操作
```

**🔧 实战开发技巧**

```java
// 好的模板方法设计
abstract class GoodTemplate {
    
    // 1. final防止重写，保护算法骨架
    public final void process() {
        prepare();
        
        // 2. 钩子方法提供扩展点
        if (needValidation()) {
            validate();
        }
        
        execute();  // 核心逻辑
        cleanup();
    }
    
    // 3. 提供默认实现，减少子类负担
    protected void prepare() {
        System.out.println("默认准备工作");
    }
    
    // 4. 钩子方法有合理的默认值
    protected boolean needValidation() {
        return true;  // 默认需要验证
    }
    
    // 5. 核心抽象方法职责单一
    protected abstract void execute();
    
    // 6. 清理工作提供默认实现
    protected void cleanup() {
        System.out.println("默认清理工作");
    }
}
```

**核心记忆**：
- 模板方法像制作流水线：流程固定，工人可换
- 父类是导演，子类是演员：剧本不变，表演不同
- 开闭原则的最佳体现：扩展新子类，不改原代码
- 控制反转的经典应用：框架调用你，而非你调用框架