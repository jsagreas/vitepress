---
title: 2、工厂方法模式结构分析
---
## 📚 目录

1. [工厂方法模式整体结构](#1-工厂方法模式整体结构)
2. [抽象工厂类详解](#2-抽象工厂类详解)
3. [具体工厂类详解](#3-具体工厂类详解)
4. [抽象产品类详解](#4-抽象产品类详解)
5. [具体产品类详解](#5-具体产品类详解)
6. [UML类图解析](#6-UML类图解析)
7. [四个角色的协作关系](#7-四个角色的协作关系)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ 工厂方法模式整体结构


### 1.1 什么是工厂方法模式的结构


> 💡 **通俗理解**：工厂方法模式就像现实中的生产车间，不同的车间生产不同的产品，但所有车间都遵循相同的生产流程标准。

**🎯 核心思想**：
- 把"创建产品"的工作交给专门的工厂来负责
- 每种产品都有自己专属的工厂
- 所有工厂都遵循统一的生产标准

### 1.2 结构组成的四个角色


```
现实世界类比：

🏭 抽象工厂 = 生产标准规范
   ↓ 定义生产流程
   
🏭 具体工厂 = 实际的生产车间
   (手机工厂、电脑工厂、平板工厂)
   ↓ 生产产品
   
📱 抽象产品 = 电子产品通用标准  
   ↓ 定义产品规格
   
📱 具体产品 = 具体的电子设备
   (iPhone、MacBook、iPad)
```

### 1.3 四角色关系图


```
抽象层面：
┌─────────────────┐    creates    ┌─────────────────┐
│   抽象工厂类     │ ············> │   抽象产品类     │
│ (Factory)       │               │  (Product)      │
└─────────────────┘               └─────────────────┘
         ↑                                 ↑
         │ 继承                            │ 继承
         │                                 │
┌─────────────────┐    creates    ┌─────────────────┐
│   具体工厂类     │ ············> │   具体产品类     │
│(ConcreteFactory)│               │(ConcreteProduct)│
└─────────────────┘               └─────────────────┘

实现层面：
```

---

## 2. 🏭 抽象工厂类详解


### 2.1 抽象工厂的作用和意义


> 🔍 **简单理解**：抽象工厂就像是"生产标准手册"，规定了所有工厂必须遵循的生产流程，但不具体说明生产什么产品。

**🎯 主要职责**：
- **制定标准**：定义工厂必须有的生产方法
- **统一接口**：让所有具体工厂都有相同的使用方式
- **抽象层次**：不关心具体生产什么，只关心怎么生产

### 2.2 抽象工厂的结构特点


```java
// 抽象工厂类的基本结构
public abstract class Factory {
    // 核心方法：创建产品的抽象方法
    public abstract Product createProduct();
    
    // 可选：通用的业务方法
    public void commonOperation() {
        System.out.println("执行通用的工厂操作");
    }
}
```

**🔹 结构要点**：
- **抽象方法**：`createProduct()` - 这是核心，必须让子类实现
- **通用方法**：可以有一些所有工厂都需要的共同操作
- **抽象类**：不能直接创建对象，只能被继承

### 2.3 为什么需要抽象工厂


**🤔 问题思考**：为什么不直接写具体工厂，还要多此一举写个抽象工厂？

**💡 答案解析**：

| 没有抽象工厂的问题 | 有抽象工厂的好处 |
|------------------|----------------|
| 每个工厂接口不统一 | 所有工厂接口一致 |
| 客户端需要了解每个具体工厂 | 客户端只需要知道抽象工厂 |
| 添加新工厂很麻烦 | 添加新工厂很简单 |
| 代码耦合度高 | 代码耦合度低 |

```java
// 举例说明：
// 没有抽象工厂时
AppleFactory appleFactory = new AppleFactory();
iPhone iphone = appleFactory.makePhone(); // 每个工厂方法名可能不同

SamsungFactory samsungFactory = new SamsungFactory();
Galaxy galaxy = samsungFactory.createGalaxy(); // 方法名不统一

// 有抽象工厂时
Factory factory1 = new AppleFactory();
Factory factory2 = new SamsungFactory();
Product phone1 = factory1.createProduct(); // 方法名统一
Product phone2 = factory2.createProduct(); // 使用方式一致
```

---

## 3. 🏭 具体工厂类详解


### 3.1 具体工厂的职责


> 💡 **通俗理解**：具体工厂就像真实的生产车间，比如"苹果手机生产车间"、"三星手机生产车间"，每个车间专门生产自己的产品。

**🎯 主要职责**：
- **实现标准**：按照抽象工厂的标准实现具体的生产方法
- **专业化生产**：每个工厂专门负责一种产品的创建
- **隐藏细节**：把复杂的产品创建过程封装起来

### 3.2 具体工厂的实现方式


```java
// 苹果工厂 - 专门生产苹果产品
public class AppleFactory extends Factory {
    @Override
    public Product createProduct() {
        // 这里可能包含复杂的创建逻辑
        System.out.println("正在生产苹果产品...");
        System.out.println("1. 准备苹果专用材料");
        System.out.println("2. 使用苹果生产工艺");
        System.out.println("3. 进行苹果质量检测");
        
        return new ApplePhone(); // 返回具体的苹果手机
    }
}

// 三星工厂 - 专门生产三星产品  
public class SamsungFactory extends Factory {
    @Override
    public Product createProduct() {
        System.out.println("正在生产三星产品...");
        System.out.println("1. 准备三星专用材料");
        System.out.println("2. 使用三星生产工艺");
        System.out.println("3. 进行三星质量检测");
        
        return new SamsungPhone(); // 返回具体的三星手机
    }
}
```

### 3.3 具体工厂的特点分析


**🔹 核心特点**：

| 特点 | 说明 | 举例 |
|------|------|------|
| **专一性** | 一个工厂只负责一种产品 | 苹果工厂只生产苹果手机 |
| **封装性** | 隐藏产品创建的复杂过程 | 客户不需要知道如何制造手机 |
| **可扩展** | 可以轻松添加新的工厂类型 | 新增华为工厂、小米工厂 |
| **统一接口** | 都继承抽象工厂，使用方式相同 | 所有工厂都有createProduct方法 |

**⚠️ 注意事项**：
- 每个具体工厂类只负责创建一种类型的产品
- 必须实现抽象工厂中定义的所有抽象方法
- 可以在创建产品时加入自己特有的逻辑处理

---

## 4. 📱 抽象产品类详解


### 4.1 抽象产品的作用


> 💡 **通俗理解**：抽象产品就像"产品质量标准"，规定了所有产品必须具备的基本功能，比如所有手机都必须能打电话、发短信。

**🎯 主要职责**：
- **定义规范**：规定所有产品都必须有的基本功能
- **统一接口**：让所有具体产品都有相同的使用方式  
- **抽象层次**：只定义"做什么"，不定义"怎么做"

### 4.2 抽象产品的结构


```java
// 抽象产品类 - 定义所有手机的基本功能
public abstract class Phone {
    protected String brand;    // 品牌
    protected String model;    // 型号
    
    // 抽象方法 - 所有手机都必须实现的功能
    public abstract void call();           // 打电话
    public abstract void sendMessage();    // 发短信
    public abstract void connectWifi();    // 连接WiFi
    
    // 具体方法 - 所有手机都有的通用功能
    public void powerOn() {
        System.out.println(brand + " " + model + " 正在开机...");
    }
    
    public void powerOff() {
        System.out.println(brand + " " + model + " 正在关机...");
    }
    
    // getter和setter方法
    public String getBrand() { return brand; }
    public void setBrand(String brand) { this.brand = brand; }
}
```

### 4.3 抽象产品的设计原则


**🔹 设计要点**：

```
功能分层设计：

必须实现的功能 (抽象方法)
├─ call()         所有手机都必须能打电话
├─ sendMessage()  所有手机都必须能发短信
└─ connectWifi()  所有手机都必须能连WiFi

通用功能 (具体方法)  
├─ powerOn()      开机逻辑都差不多
├─ powerOff()     关机逻辑都差不多
└─ getBrand()     获取品牌信息都一样

个性化功能 (留给子类)
├─ 具体如何打电话  (由具体产品实现)
├─ 具体如何发短信  (由具体产品实现)  
└─ 具体如何连WiFi  (由具体产品实现)
```

---

## 5. 📱 具体产品类详解


### 5.1 具体产品的作用


> 💡 **通俗理解**：具体产品就像真实的商品，比如"iPhone 15"、"Galaxy S24"，它们都遵循手机的基本标准，但每个都有自己独特的特色功能。

**🎯 主要职责**：
- **实现标准**：按照抽象产品的标准实现所有必须的功能
- **个性化定制**：在标准基础上添加自己独特的特色
- **提供服务**：为用户提供实际可用的产品功能

### 5.2 具体产品的实现示例


```java
// 苹果手机 - 具体产品实现
public class ApplePhone extends Phone {
    
    public ApplePhone() {
        this.brand = "Apple";
        this.model = "iPhone 15";
    }
    
    @Override
    public void call() {
        System.out.println("使用苹果iOS系统拨打电话");
        System.out.println("启动FaceTime音频通话");
    }
    
    @Override
    public void sendMessage() {
        System.out.println("使用iMessage发送消息");
        System.out.println("支持表情包和动画效果");
    }
    
    @Override
    public void connectWifi() {
        System.out.println("连接到WiFi网络");
        System.out.println("自动同步到iCloud");
    }
    
    // 苹果手机独有的功能
    public void useSiri() {
        System.out.println("嘿 Siri，今天天气怎么样？");
    }
}

// 三星手机 - 具体产品实现
public class SamsungPhone extends Phone {
    
    public SamsungPhone() {
        this.brand = "Samsung";
        this.model = "Galaxy S24";
    }
    
    @Override
    public void call() {
        System.out.println("使用Android系统拨打电话");
        System.out.println("支持高清语音通话");
    }
    
    @Override
    public void sendMessage() {
        System.out.println("使用Samsung Messages发送消息");
        System.out.println("支持富媒体消息");
    }
    
    @Override
    public void connectWifi() {
        System.out.println("连接到WiFi网络");
        System.out.println("自动备份到Samsung Cloud");
    }
    
    // 三星手机独有的功能
    public void useSPen() {
        System.out.println("使用S Pen进行手写输入");
    }
}
```

### 5.3 具体产品的特点分析


**🔹 实现特点**：

| 方面 | 说明 | ApplePhone示例 | SamsungPhone示例 |
|------|------|---------------|-----------------|
| **基础功能** | 实现抽象产品定义的方法 | iOS拨打电话 | Android拨打电话 |
| **个性特色** | 在基础上添加独特功能 | 使用Siri语音助手 | 使用S Pen手写笔 |
| **品牌标识** | 体现自己的品牌特色 | Apple + iOS生态 | Samsung + Android生态 |
| **用户体验** | 提供差异化的使用体验 | 简洁优雅的交互 | 功能丰富的定制 |

**💪 扩展能力**：
- 可以轻松添加新的手机品牌（华为、小米、OPPO等）
- 每个品牌都可以有自己独特的实现方式
- 不影响其他已有的产品类

---

## 6. 📊 UML类图解析


### 6.1 UML类图整体结构


```
工厂方法模式UML类图：

    ┌─────────────────────┐
    │    <<abstract>>     │
    │       Factory       │
    ├─────────────────────┤
    │ + createProduct()   │
    │   : Product         │
    └─────────────────────┘
              △
              │ (继承)
    ┌─────────┴─────────┐
    │                   │
┌─────────────────┐ ┌─────────────────┐
│ AppleFactory    │ │ SamsungFactory  │
├─────────────────┤ ├─────────────────┤
│+ createProduct()│ │+ createProduct()│
│  : ApplePhone   │ │  : SamsungPhone │
└─────────────────┘ └─────────────────┘
         │                    │
         │creates            │creates
         ▼                    ▼
┌─────────────────┐ ┌─────────────────┐
│   ApplePhone    │ │  SamsungPhone   │
├─────────────────┤ ├─────────────────┤
│+ call()         │ │+ call()         │
│+ sendMessage()  │ │+ sendMessage()  │ 
│+ connectWifi()  │ │+ connectWifi()  │
└─────────────────┘ └─────────────────┘
         △                    △
         │ (继承)            │ (继承)
         └─────────┬─────────┘
                   │
    ┌─────────────────────┐
    │    <<abstract>>     │
    │        Phone        │
    ├─────────────────────┤
    │+ call()            │
    │+ sendMessage()     │
    │+ connectWifi()     │
    │+ powerOn()         │
    │+ powerOff()        │
    └─────────────────────┘
```

### 6.2 类图关系解读


**🔗 关系类型说明**：

| 关系符号 | 关系名称 | 含义 | 示例 |
|---------|---------|------|------|
| `△` | 继承(Inheritance) | "是一个"的关系 | AppleFactory是一个Factory |
| `····>` | 依赖(Dependency) | "使用"的关系 | Factory创建Product |
| `→` | 关联(Association) | "拥有"的关系 | Factory拥有Product |

### 6.3 类图解读要点


> 🔍 **读图技巧**：从上往下看，从抽象到具体，从接口到实现。

**📋 解读步骤**：

1. **抽象层**：Factory和Product定义了标准和规范
2. **实现层**：具体的工厂和产品实现了这些标准
3. **创建关系**：工厂负责创建对应的产品
4. **继承关系**：具体类继承抽象类，获得通用能力

**🎯 核心理解**：
- **垂直关系**：继承关系，子类扩展父类
- **水平关系**：创建关系，工厂创建产品
- **对称结构**：工厂和产品的层次结构是对应的

---

## 7. 🤝 四个角色的协作关系


### 7.1 协作流程图


```
客户端使用工厂方法模式的完整流程：

客户端 Client
    │
    │ 1. 选择工厂类型
    ▼
抽象工厂 Factory
    │
    │ 2. 创建具体工厂实例
    ▼
具体工厂 ConcreteFactory
    │
    │ 3. 调用createProduct()
    ▼
    │ 4. 创建具体产品
    ▼
具体产品 ConcreteProduct
    │
    │ 5. 返回产品给客户端
    ▼
抽象产品 Product
    │
    │ 6. 客户端使用产品功能
    ▼
客户端得到并使用产品
```

### 7.2 协作关系详解


**🔄 具体协作过程**：

```java
// 第1步：客户端选择需要的工厂类型
Factory factory = new AppleFactory(); // 选择苹果工厂

// 第2步：通过工厂创建产品
Product phone = factory.createProduct(); // 工厂创建产品

// 第3步：使用产品的功能
phone.call();           // 打电话
phone.sendMessage();    // 发短信
phone.connectWifi();    // 连接WiFi
```

### 7.3 角色职责分工


**👥 角色分工表**：

| 角色 | 主要职责 | 对外接口 | 对内实现 |
|------|---------|---------|---------|
| **客户端** | 使用产品 | 选择工厂、使用产品 | 不需要了解创建细节 |
| **抽象工厂** | 定义创建标准 | createProduct() | 抽象方法，不实现 |
| **具体工厂** | 实际创建产品 | 继承抽象工厂 | 实现具体创建逻辑 |
| **抽象产品** | 定义产品标准 | 产品功能接口 | 抽象方法，不实现 |
| **具体产品** | 提供实际功能 | 继承抽象产品 | 实现具体功能逻辑 |

**🎯 协作优势**：
- **职责明确**：每个角色都有清晰的分工
- **低耦合**：客户端不直接依赖具体的工厂和产品
- **高内聚**：每个工厂专门负责一种产品的创建
- **易扩展**：添加新的工厂和产品不影响现有代码

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 四个角色分工明确：
  - 抽象工厂：定义创建标准
  - 具体工厂：实现具体创建  
  - 抽象产品：定义产品标准
  - 具体产品：实现具体功能

🔸 两条继承链：
  - 工厂继承链：具体工厂 → 抽象工厂
  - 产品继承链：具体产品 → 抽象产品

🔸 一个创建关系：
  - 具体工厂创建具体产品
  - 一对一的专属关系
```

### 8.2 关键理解要点


**🔹 为什么需要这种结构**：
```
问题：直接new对象有什么不好？
答案：
❌ 客户端耦合具体类，难以扩展
❌ 创建逻辑散落各处，难以维护  
❌ 违反开闭原则，修改影响大

✅ 工厂方法模式的好处：
✅ 客户端只依赖抽象，降低耦合
✅ 创建逻辑集中管理，便于维护
✅ 符合开闭原则，扩展性强
```

**🔹 结构设计的精妙之处**：
```
对称设计：
工厂层次 ←→ 产品层次
抽象工厂 ←→ 抽象产品  
具体工厂 ←→ 具体产品

这种对称设计让整个结构：
📐 结构清晰，容易理解
🔧 便于扩展，添加新类型简单
🎯 职责明确，维护成本低
```

### 8.3 实际应用指导


**💼 何时使用这种结构**：
- ✅ 需要创建一系列相关产品时
- ✅ 产品创建逻辑复杂时  
- ✅ 需要保持代码可扩展性时
- ✅ 客户端不应该依赖具体实现时

**⚠️ 注意事项**：
- 不要为了用设计模式而用，简单场景直接new就好
- 结构会增加代码复杂度，要权衡利弊
- 抽象层设计要稳定，频繁修改会影响所有子类

**核心记忆口诀**：
```
四角色分工明确职责清，
两继承一创建结构整，
抽象定标准具体来实现，
工厂造产品客户用轻松！
```