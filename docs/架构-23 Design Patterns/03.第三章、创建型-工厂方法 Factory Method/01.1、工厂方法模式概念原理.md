---
title: 1、工厂方法模式概念原理
---
## 📚 目录

1. [工厂方法模式定义](#1-工厂方法模式定义)
2. [简单工厂vs工厂方法](#2-简单工厂vs工厂方法)
3. [解决的核心问题](#3-解决的核心问题)
4. [应用场景分析](#4-应用场景分析)
5. [优缺点对比](#5-优缺点对比)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🏭 工厂方法模式定义


### 1.1 什么是工厂方法模式


**💡 通俗理解**
想象一下现实中的工厂，比如手机工厂。苹果有自己的工厂生产iPhone，华为有自己的工厂生产Mate系列。每个工厂都专门负责生产自己品牌的手机，但都遵循"制造手机"这个共同的生产流程。

**🔸 正式定义**
工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它提供了一个创建对象的接口，但让子类决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。

**📋 核心思想**
```
传统方式：我直接告诉你"给我做一个iPhone"
工厂方法：我告诉你"给我做一个手机"，然后苹果工厂自己决定做iPhone，华为工厂自己决定做Mate
```

### 1.2 工厂方法的组成结构


**🏗️ 四个核心角色**

```
抽象工厂(Creator)           抽象产品(Product)
      ↑                          ↑
      |                          |
具体工厂(ConcreteCreator)   具体产品(ConcreteProduct)
```

**角色说明**：
- **抽象工厂**：定义生产产品的标准流程（比如：手机工厂都要有生产线）
- **具体工厂**：具体的生产厂家（比如：苹果工厂、华为工厂）
- **抽象产品**：产品的共同特征（比如：所有手机都能打电话、发短信）
- **具体产品**：实际的产品（比如：iPhone 15、Mate 60）

### 1.3 简单代码示例


```java
// 抽象产品 - 手机的共同特征
abstract class Phone {
    abstract void call();
    abstract void sendMessage();
}

// 具体产品 - iPhone
class iPhone extends Phone {
    void call() { System.out.println("iPhone正在通话..."); }
    void sendMessage() { System.out.println("iPhone发送iMessage..."); }
}

// 具体产品 - 华为手机
class HuaweiPhone extends Phone {
    void call() { System.out.println("华为手机正在通话..."); }
    void sendMessage() { System.out.println("华为手机发送短信..."); }
}

// 抽象工厂 - 手机工厂的生产标准
abstract class PhoneFactory {
    // 这就是工厂方法，让子类决定生产什么手机
    abstract Phone createPhone();
}

// 具体工厂 - 苹果工厂
class AppleFactory extends PhoneFactory {
    Phone createPhone() {
        return new iPhone();  // 苹果工厂专门生产iPhone
    }
}

// 具体工厂 - 华为工厂
class HuaweiFactory extends PhoneFactory {
    Phone createPhone() {
        return new HuaweiPhone();  // 华为工厂专门生产华为手机
    }
}
```

---

## 2. 🔄 简单工厂vs工厂方法


### 2.1 简单工厂的问题


**🚫 简单工厂的局限性**

```java
// 简单工厂 - 一个工厂生产所有产品
class SimplePhoneFactory {
    public static Phone createPhone(String type) {
        if ("iPhone".equals(type)) {
            return new iPhone();
        } else if ("Huawei".equals(type)) {
            return new HuaweiPhone();
        }
        return null;  // 这里有问题！
    }
}
```

**⚠️ 简单工厂的痛点**：
- **违反开闭原则**：每次新增手机品牌，都要修改工厂类
- **职责不明确**：一个工厂负责生产所有品牌的手机
- **难以扩展**：代码耦合度高，维护困难

### 2.2 工厂方法的改进


**✅ 工厂方法的优势**

```
简单工厂模式：
    客户端 → 简单工厂 → 各种产品

工厂方法模式：
    客户端 → 抽象工厂接口
              ↓
    客户端 → 具体工厂A → 产品A
    客户端 → 具体工厂B → 产品B
```

### 2.3 对比表格


| 对比维度 | **简单工厂** | **工厂方法** |
|---------|-------------|-------------|
| **扩展性** | ❌ 新增产品需修改工厂类 | ✅ 新增产品只需新增工厂类 |
| **职责单一** | ❌ 一个工厂负责所有产品 | ✅ 每个工厂专门负责一种产品 |
| **开闭原则** | ❌ 对修改开放 | ✅ 对扩展开放，对修改关闭 |
| **使用复杂度** | 🟡 简单直接 | 🟡 稍微复杂，但更灵活 |
| **适用场景** | 产品种类较少且稳定 | 产品种类多且需要扩展 |

---

## 3. 🎯 解决的核心问题


### 3.1 对象创建的责任分离


**🔸 问题描述**
在没有工厂方法之前，客户端需要直接创建对象：

```java
// 客户端直接创建对象 - 耦合度高
public class Client {
    public void usePhone() {
        Phone phone = new iPhone();  // 直接依赖具体类
        phone.call();
    }
}
```

**💡 工厂方法的解决方案**
```java
// 使用工厂方法 - 降低耦合
public class Client {
    private PhoneFactory factory;
    
    public Client(PhoneFactory factory) {
        this.factory = factory;  // 依赖抽象，不依赖具体
    }
    
    public void usePhone() {
        Phone phone = factory.createPhone();  // 让工厂决定创建什么
        phone.call();
    }
}
```

### 3.2 系统的可扩展性


**📈 扩展新产品的对比**

**传统方式扩展小米手机**：
1. ❌ 修改简单工厂类，添加小米手机的创建逻辑
2. ❌ 可能影响现有代码
3. ❌ 违反开闭原则

**工厂方法扩展小米手机**：
1. ✅ 创建小米手机类
2. ✅ 创建小米工厂类
3. ✅ 不需要修改任何现有代码

```java
// 新增小米手机 - 只需要新增，不需要修改
class XiaomiPhone extends Phone {
    void call() { System.out.println("小米手机正在通话..."); }
    void sendMessage() { System.out.println("小米手机发送短信..."); }
}

class XiaomiFactory extends PhoneFactory {
    Phone createPhone() {
        return new XiaomiPhone();
    }
}
```

### 3.3 代码的可维护性


**🔧 维护性对比**

| 维护场景 | **传统方式** | **工厂方法** |
|---------|-------------|-------------|
| 修改iPhone创建逻辑 | 修改工厂类中的iPhone部分 | 只修改AppleFactory |
| 新增手机品牌 | 修改工厂类添加新分支 | 新增对应的工厂类 |
| 删除某个品牌 | 从工厂类中删除对应代码 | 删除对应的工厂类即可 |

---

## 4. 🚀 应用场景分析


### 4.1 数据库连接示例


**💾 实际应用场景**
不同的项目可能使用不同的数据库，需要灵活切换：

```java
// 抽象数据库连接
abstract class DatabaseConnection {
    abstract void connect();
    abstract void query(String sql);
}

// MySQL连接
class MySQLConnection extends DatabaseConnection {
    void connect() { System.out.println("连接到MySQL数据库"); }
    void query(String sql) { System.out.println("MySQL执行: " + sql); }
}

// PostgreSQL连接
class PostgreSQLConnection extends DatabaseConnection {
    void connect() { System.out.println("连接到PostgreSQL数据库"); }
    void query(String sql) { System.out.println("PostgreSQL执行: " + sql); }
}

// 数据库工厂
abstract class DatabaseFactory {
    abstract DatabaseConnection createConnection();
}

class MySQLFactory extends DatabaseFactory {
    DatabaseConnection createConnection() {
        return new MySQLConnection();
    }
}

class PostgreSQLFactory extends DatabaseFactory {
    DatabaseConnection createConnection() {
        return new PostgreSQLConnection();
    }
}
```

### 4.2 日志记录器示例


**📝 多种日志输出方式**

```
应用场景：系统需要支持多种日志输出方式

文件日志工厂 → 文件日志记录器
控制台日志工厂 → 控制台日志记录器  
数据库日志工厂 → 数据库日志记录器
```

### 4.3 适用场景总结


**✅ 适合使用工厂方法的情况**：
- 🔸 **产品种类较多**：有多种相似但不同的产品需要创建
- 🔸 **需要经常扩展**：产品种类可能会增加
- 🔸 **创建逻辑复杂**：不同产品的创建过程有所不同
- 🔸 **解耦需求强**：希望客户端不直接依赖具体产品类

**❌ 不适合的情况**：
- 🔸 **产品种类很少**：只有1-2种产品，简单工厂就够了
- 🔸 **创建逻辑简单**：只是简单的`new`操作
- 🔸 **不需要扩展**：产品种类基本固定不变

---

## 5. ⚖️ 优缺点对比


### 5.1 工厂方法的优点


**🎯 主要优势**

| 优点 | **具体说明** | **实际好处** |
|------|-------------|-------------|
| **🔧 符合开闭原则** | 对扩展开放，对修改关闭 | 新增产品不影响现有代码 |
| **🎯 单一职责** | 每个工厂只负责创建一种产品 | 代码职责清晰，易于维护 |
| **🔗 降低耦合度** | 客户端不直接依赖具体产品 | 系统更加灵活，易于测试 |
| **📈 易于扩展** | 增加新产品只需新增工厂 | 满足不断变化的业务需求 |

### 5.2 工厂方法的缺点


**⚠️ 潜在问题**

**🔸 类的数量增加**
```
每增加一个产品，就需要增加：
1. 具体产品类
2. 具体工厂类
类的数量成倍增长
```

**🔸 系统复杂度提升**
- 对于简单的对象创建，可能显得过于重量级
- 新手理解起来比直接`new`对象要复杂

**🔸 不适合简单场景**
- 如果只有2-3种产品且不会扩展，简单工厂更合适
- 过度设计可能带来不必要的复杂性

### 5.3 适用性权衡


**🎯 使用建议**

```
选择工厂方法的判断标准：

产品种类 ≥ 3种 ✅
未来可能扩展 ✅  
创建逻辑有差异 ✅
需要解耦 ✅
          ↓
    使用工厂方法

产品种类 ≤ 2种 ❌
基本不会扩展 ❌
创建逻辑简单 ❌
对耦合不敏感 ❌
          ↓
    使用简单工厂或直接创建
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 工厂方法本质**
```
核心思想：让子类决定创建什么对象
设计原则：面向接口编程，而不是面向实现
解决问题：对象创建的灵活性和可扩展性
```

**🔸 与简单工厂的区别**
- **简单工厂**：一个工厂类负责所有产品的创建
- **工厂方法**：每种产品都有专门的工厂类负责创建

**🔸 四个核心角色**
- **抽象工厂**：定义创建产品的接口
- **具体工厂**：实现具体产品的创建
- **抽象产品**：定义产品的共同接口  
- **具体产品**：实际的产品实现

### 6.2 关键理解要点


**🔹 何时使用工厂方法**
```
判断标准：
- 产品种类较多（≥3种）
- 需要频繁扩展新产品
- 希望降低客户端与具体产品的耦合
- 不同产品的创建逻辑有差异
```

**🔹 核心价值**
- **可扩展性**：新增产品类型无需修改现有代码
- **可维护性**：每个工厂职责单一，易于维护
- **灵活性**：客户端可以灵活选择不同的工厂

### 6.3 实际应用指导


**💡 最佳实践**
- 🎯 **先评估复杂度**：简单场景不要过度设计
- 🔧 **考虑未来扩展**：如果确定不会扩展，简单工厂更合适
- 📋 **命名要清晰**：工厂类和产品类的命名要能体现其作用

**🚀 学习建议**
- 从简单的例子开始理解（如手机工厂）
- 多思考现实中的工厂生产模式
- 重点理解"让子类决定"这个核心思想
- 通过对比简单工厂来加深理解

**核心记忆口诀**：
- 工厂方法解耦合，子类决定造什么
- 扩展产品不修改，开闭原则记心上
- 一厂一品职责清，维护起来特别香