---
title: 3、观察者模式实现方式
---
## 📚 目录

1. [推模式与拉模式](#1-推模式与拉模式)
2. [同步通知机制](#2-同步通知机制)
3. [异步通知机制](#3-异步通知机制)
4. [事件总线设计](#4-事件总线设计)
5. [实现方式对比选择](#5-实现方式对比选择)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔄 推模式与拉模式


### 1.1 什么是推模式和拉模式


**通俗理解**：就像订阅杂志一样
- **推模式**：杂志社直接把整本杂志邮寄给你（主动推送全部信息）
- **拉模式**：杂志社只告诉你"新刊到了"，你自己去书店买（被动获取需要的信息）

### 1.2 推模式实现


**🔸 核心特点**
```
推模式 = 主动推送 + 详细数据
被观察者主动把变化的具体数据推送给观察者
```

**💡 推模式示例**
```java
// 推模式：天气站主动推送详细天气信息
class WeatherStation {
    private List<WeatherObserver> observers = new ArrayList<>();
    
    // 天气变化时，主动推送所有数据
    private void notifyObservers(float temperature, float humidity, float pressure) {
        for (WeatherObserver observer : observers) {
            // 推模式：直接传递具体数据
            observer.update(temperature, humidity, pressure);
        }
    }
    
    public void weatherChanged(float temp, float hum, float press) {
        notifyObservers(temp, hum, press);
    }
}

// 观察者接收推送的数据
interface WeatherObserver {
    void update(float temperature, float humidity, float pressure);
}
```

**✅ 推模式优点**
- 观察者实现简单，直接接收数据
- 通知效率高，一次性获得所有信息
- 适合数据量小、变化频繁的场景

**❌ 推模式缺点**
- 传输不需要的数据，造成浪费
- 观察者接口复杂，参数多
- 被观察者需要了解观察者的需求

### 1.3 拉模式实现


**🔸 核心特点**
```
拉模式 = 通知变化 + 主动获取
被观察者只通知"有变化"，观察者主动拉取需要的数据
```

**💡 拉模式示例**
```java
// 拉模式：天气站只通知变化，不传具体数据
class WeatherStation {
    private float temperature, humidity, pressure;
    private List<WeatherObserver> observers = new ArrayList<>();
    
    // 拉模式：只通知变化，不传数据
    private void notifyObservers() {
        for (WeatherObserver observer : observers) {
            observer.update(this); // 传递自己的引用
        }
    }
    
    // 提供获取数据的方法
    public float getTemperature() { return temperature; }
    public float getHumidity() { return humidity; }
    public float getPressure() { return pressure; }
}

// 观察者主动拉取需要的数据
interface WeatherObserver {
    void update(WeatherStation station);
}

class PhoneApp implements WeatherObserver {
    public void update(WeatherStation station) {
        // 拉模式：只获取自己需要的数据
        float temp = station.getTemperature();
        System.out.println("手机显示温度：" + temp + "°C");
    }
}
```

**✅ 拉模式优点**
- 观察者按需获取数据，避免浪费
- 观察者接口简单统一
- 被观察者不需要了解观察者需求

**❌ 拉模式缺点**
- 观察者实现复杂，需要主动获取
- 可能产生多次方法调用
- 数据获取时机需要控制

### 1.4 推拉模式对比


| 对比维度 | **推模式** | **拉模式** | **选择建议** |
|---------|------------|------------|-------------|
| **数据传输** | `主动推送全部数据` | `被动获取需要数据` | `数据量小选推，数据量大选拉` |
| **接口复杂度** | `参数多，接口复杂` | `参数少，接口简单` | `观察者多样化选拉模式` |
| **性能考虑** | `一次传输，效率高` | `按需获取，节省带宽` | `频繁变化选推，偶尔变化选拉` |
| **耦合程度** | `耦合度高` | `耦合度低` | `松耦合选拉模式` |

---

## 2. ⚡ 同步通知机制


### 2.1 什么是同步通知


**通俗理解**：就像排队办事
```
顾客1办事 → 顾客2等待 → 顾客2办事 → 顾客3等待
一个一个来，前面没完成，后面就得等着
```

**🔸 同步通知特点**
- 通知是按顺序进行的
- 前一个观察者处理完，才通知下一个
- 被观察者等待所有观察者处理完成

### 2.2 同步通知实现


**💡 基础同步通知**
```java
class NewsPublisher {
    private List<NewsSubscriber> subscribers = new ArrayList<>();
    
    // 同步通知：一个一个按顺序通知
    public void publishNews(String news) {
        System.out.println("发布新闻：" + news);
        
        for (NewsSubscriber subscriber : subscribers) {
            // 同步调用：等待当前订阅者处理完成
            subscriber.receiveNews(news);
            System.out.println("已通知：" + subscriber.getName());
        }
        
        System.out.println("所有订阅者通知完成");
    }
}

class NewsSubscriber {
    private String name;
    
    public void receiveNews(String news) {
        System.out.println(name + "正在处理新闻...");
        // 模拟处理时间
        try {
            Thread.sleep(1000); // 处理需要1秒
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println(name + "处理完成");
    }
}
```

**🔄 执行流程图示**
```
发布者                观察者1              观察者2              观察者3
   |                     |                   |                   |
   |--[1]通知----------->|                   |                   |
   |                     |--处理中(1秒)--    |                   |
   |<--[2]完成-----------|                   |                   |
   |                     |                   |                   |
   |--[3]通知------------------------->|                   |
   |                     |                   |--处理中(1秒)--    |
   |<--[4]完成--------------------------|                   |
   |                     |                   |                   |
   |--[5]通知-------------------------------------------->|
   |                     |                   |                   |--处理中(1秒)--
   |<--[6]完成--------------------------------------------|
```

### 2.3 同步通知的优缺点


**✅ 同步通知优点**
- **执行顺序可控**：严格按照注册顺序通知
- **状态一致性好**：确保所有观察者都处理完成
- **错误处理简单**：异常可以直接抛出处理
- **调试方便**：执行流程清晰可追踪

**❌ 同步通知缺点**
- **响应速度慢**：总时间 = 所有观察者处理时间之和
- **阻塞风险高**：一个观察者卡住，后面都得等
- **用户体验差**：界面可能出现"假死"现象

**🎯 适用场景**
```
✅ 适合同步通知的情况：
• 观察者处理速度很快（毫秒级）
• 需要严格的执行顺序
• 需要确保所有观察者都执行完成
• 观察者之间有依赖关系

❌ 不适合同步通知的情况：
• 观察者处理耗时较长
• 观察者数量很多
• 对响应速度要求高
• 观察者可能出现异常
```

---

## 3. 🚀 异步通知机制


### 3.1 什么是异步通知


**通俗理解**：就像发微信群消息
```
你发一条消息到群里 → 立即发送完成 → 群友各自什么时候看到随意
不用等所有人都回复，你就可以继续做其他事情
```

**🔸 异步通知特点**
- 通知是并行进行的
- 被观察者发出通知后立即返回
- 观察者在后台独立处理

### 3.2 线程池异步通知


**💡 基于线程池的异步实现**
```java
class AsyncNewsPublisher {
    private List<NewsSubscriber> subscribers = new ArrayList<>();
    // 创建线程池处理异步通知
    private ExecutorService executor = Executors.newFixedThreadPool(5);
    
    // 异步通知：立即返回，后台处理
    public void publishNews(String news) {
        System.out.println("发布新闻：" + news);
        
        for (NewsSubscriber subscriber : subscribers) {
            // 提交到线程池异步执行
            executor.submit(() -> {
                try {
                    subscriber.receiveNews(news);
                    System.out.println("通知完成：" + subscriber.getName());
                } catch (Exception e) {
                    System.err.println("通知失败：" + subscriber.getName() + ", " + e.getMessage());
                }
            });
        }
        
        System.out.println("新闻发布完成（异步处理中）");
    }
    
    // 记得关闭线程池
    public void shutdown() {
        executor.shutdown();
    }
}
```

**🔄 异步执行流程图示**
```
发布者                线程池                观察者1/2/3
   |                     |                      |
   |--[1]提交任务------->|                      |
   |--[2]提交任务------->|                      |
   |--[3]提交任务------->|                      |
   |<--[4]立即返回-------|                      |
   |                     |                      |
   |继续其他工作          |--并行处理----------->|观察者1处理中
   |                     |--并行处理----------->|观察者2处理中  
   |                     |--并行处理----------->|观察者3处理中
```

### 3.3 CompletableFuture异步通知


**💡 使用CompletableFuture的现代异步方式**
```java
class ModernAsyncPublisher {
    private List<NewsSubscriber> subscribers = new ArrayList<>();
    
    public CompletableFuture<Void> publishNews(String news) {
        System.out.println("发布新闻：" + news);
        
        // 创建所有异步任务
        List<CompletableFuture<Void>> futures = subscribers.stream()
            .map(subscriber -> CompletableFuture.runAsync(() -> {
                subscriber.receiveNews(news);
            }))
            .collect(Collectors.toList());
        
        // 等待所有任务完成（可选）
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenRun(() -> System.out.println("所有订阅者通知完成"));
    }
}
```

### 3.4 异步通知的优缺点


**✅ 异步通知优点**
- **响应速度快**：立即返回，不阻塞
- **并行处理**：多个观察者同时工作
- **用户体验好**：界面不会卡顿
- **容错性强**：单个观察者异常不影响其他

**❌ 异步通知缺点**
- **执行顺序不确定**：无法保证处理顺序
- **状态难以控制**：不知道何时全部完成
- **错误处理复杂**：异常处理需要特殊机制
- **资源消耗**：需要额外的线程资源

**🎯 适用场景**
```
✅ 适合异步通知的情况：
• 观察者处理耗时较长
• 观察者数量很多
• 对响应速度要求高
• 观察者之间相互独立

❌ 不适合异步通知的情况：
• 需要严格的执行顺序
• 必须等待所有观察者完成
• 观察者之间有依赖关系
• 系统资源受限
```

---

## 4. 🚌 事件总线设计


### 4.1 什么是事件总线


**通俗理解**：就像城市公交系统
```
乘客不需要知道其他乘客是谁，只要：
1. 在站点等车（订阅事件）
2. 车来了上车（接收通知）
3. 到站下车（处理事件）

事件总线就是这个"公交系统"，负责运送消息
```

**🔸 事件总线核心概念**
- **事件发布者**：发布事件的对象（不知道谁会处理）
- **事件订阅者**：订阅事件的对象（不知道谁发布的）
- **事件总线**：中介者，负责事件的分发和管理
- **事件对象**：传递的具体数据

### 4.2 简单事件总线实现


**💡 基础事件总线设计**
```java
// 事件总线：负责事件的注册、分发和管理
class EventBus {
    // 存储事件类型和订阅者的映射关系
    private Map<Class<?>, List<Object>> subscribers = new ConcurrentHashMap<>();
    
    // 订阅事件：把订阅者加入到指定事件类型的列表中
    public void subscribe(Class<?> eventType, Object subscriber) {
        subscribers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(subscriber);
        System.out.println("订阅成功：" + subscriber.getClass().getSimpleName() + " -> " + eventType.getSimpleName());
    }
    
    // 发布事件：通知所有订阅该事件类型的订阅者
    public void publish(Object event) {
        Class<?> eventType = event.getClass();
        List<Object> eventSubscribers = subscribers.get(eventType);
        
        if (eventSubscribers != null) {
            System.out.println("发布事件：" + eventType.getSimpleName());
            for (Object subscriber : eventSubscribers) {
                notifySubscriber(subscriber, event);
            }
        }
    }
    
    // 通过反射调用订阅者的处理方法
    private void notifySubscriber(Object subscriber, Object event) {
        try {
            Method handleMethod = subscriber.getClass().getMethod("handle", event.getClass());
            handleMethod.invoke(subscriber, event);
        } catch (Exception e) {
            System.err.println("事件处理失败：" + e.getMessage());
        }
    }
}
```

**📝 事件对象定义**
```java
// 用户注册事件
class UserRegisteredEvent {
    private String username;
    private String email;
    private Date registerTime;
    
    public UserRegisteredEvent(String username, String email) {
        this.username = username;
        this.email = email;
        this.registerTime = new Date();
    }
    
    // getter方法...
}

// 订单创建事件  
class OrderCreatedEvent {
    private String orderId;
    private String userId;
    private double amount;
    
    public OrderCreatedEvent(String orderId, String userId, double amount) {
        this.orderId = orderId;
        this.userId = userId;
        this.amount = amount;
    }
    
    // getter方法...
}
```

### 4.3 事件订阅者实现


**💡 不同的事件处理者**
```java
// 邮件服务：处理用户注册事件
class EmailService {
    public void handle(UserRegisteredEvent event) {
        System.out.println("邮件服务：发送欢迎邮件给 " + event.getUsername());
        // 实际的邮件发送逻辑
    }
}

// 积分服务：处理用户注册事件
class PointService {
    public void handle(UserRegisteredEvent event) {
        System.out.println("积分服务：为新用户 " + event.getUsername() + " 赠送100积分");
        // 实际的积分赠送逻辑
    }
}

// 库存服务：处理订单创建事件
class InventoryService {
    public void handle(OrderCreatedEvent event) {
        System.out.println("库存服务：减少订单 " + event.getOrderId() + " 相关商品库存");
        // 实际的库存扣减逻辑
    }
}

// 物流服务：处理订单创建事件
class LogisticsService {
    public void handle(OrderCreatedEvent event) {
        System.out.println("物流服务：为订单 " + event.getOrderId() + " 安排配送");
        // 实际的物流安排逻辑
    }
}
```

### 4.4 事件总线使用示例


**💡 完整使用流程**
```java
public class EventBusExample {
    public static void main(String[] args) {
        // 创建事件总线
        EventBus eventBus = new EventBus();
        
        // 创建各种服务
        EmailService emailService = new EmailService();
        PointService pointService = new PointService();
        InventoryService inventoryService = new InventoryService();
        LogisticsService logisticsService = new LogisticsService();
        
        // 订阅事件：告诉总线谁关心什么事件
        eventBus.subscribe(UserRegisteredEvent.class, emailService);
        eventBus.subscribe(UserRegisteredEvent.class, pointService);
        eventBus.subscribe(OrderCreatedEvent.class, inventoryService);
        eventBus.subscribe(OrderCreatedEvent.class, logisticsService);
        
        System.out.println("=== 模拟用户注册 ===");
        // 发布用户注册事件
        UserRegisteredEvent userEvent = new UserRegisteredEvent("张三", "zhangsan@example.com");
        eventBus.publish(userEvent);
        
        System.out.println("\n=== 模拟订单创建 ===");
        // 发布订单创建事件
        OrderCreatedEvent orderEvent = new OrderCreatedEvent("ORDER-001", "user123", 299.99);
        eventBus.publish(orderEvent);
    }
}
```

### 4.5 事件总线架构图示


```
事件发布者                事件总线                  事件订阅者
    |                        |                        |
    |                   ┌─────────────┐               |
用户服务 ──注册事件──────>│             │──────────────> 邮件服务
    |                   │   事件总线   │──────────────> 积分服务
订单服务 ──创建事件──────>│             │──────────────> 库存服务
    |                   │(事件分发中心)│──────────────> 物流服务
商品服务 ──更新事件──────>│             │──────────────> 通知服务
    |                   └─────────────┘               |
    |                        |                        |
    
特点：
• 发布者和订阅者完全解耦
• 支持一对多的事件分发
• 可以动态添加/移除订阅者
• 事件类型安全
```

### 4.6 事件总线的优势


**✅ 事件总线优点**
- **完全解耦**：发布者和订阅者互不知晓
- **扩展性强**：新增订阅者无需修改现有代码
- **类型安全**：基于事件类型的强类型分发
- **集中管理**：统一的事件分发和订阅管理
- **灵活配置**：可以动态添加或移除订阅关系

**❌ 事件总线缺点**
- **调试困难**：事件流转路径不够直观
- **性能开销**：反射调用和事件分发的开销
- **内存泄漏风险**：订阅者没有正确注销
- **异常传播**：一个订阅者异常可能影响其他

**🎯 适用场景**
```
✅ 适合使用事件总线：
• 微服务架构中的服务间通信
• 复杂业务流程的解耦
• 系统中有大量观察者模式的场景
• 需要动态添加/移除监听器

❌ 不建议使用事件总线：
• 简单的一对一通知
• 对性能要求极高的场景
• 需要严格顺序的事件处理
• 调试和维护要求很高
```

---

## 5. ⚖️ 实现方式对比选择


### 5.1 四种实现方式特点对比


| 实现方式 | **复杂度** | **性能** | **解耦程度** | **扩展性** | **适用场景** |
|---------|------------|----------|-------------|------------|-------------|
| **推模式** | `简单` | `高` | `中等` | `一般` | `数据量小，变化频繁` |
| **拉模式** | `中等` | `中等` | `高` | `好` | `数据量大，按需获取` |
| **同步通知** | `简单` | `低` | `中等` | `一般` | `顺序重要，处理简单` |
| **异步通知** | `复杂` | `高` | `中等` | `好` | `处理耗时，并发要求高` |
| **事件总线** | `复杂` | `中等` | `极高` | `极好` | `复杂系统，动态扩展` |

### 5.2 选择决策树


```
开始选择实现方式
         |
    观察者数量多吗？
    /              \
 多(>10)         少(≤10)
   |               |
需要完全解耦吗？   处理耗时吗？
  /        \       /        \
 是        否      是        否
 |         |       |         |
事件总线   异步通知  异步通知   数据量大吗？
                              /        \
                             是        否
                             |         |
                           拉模式    推模式
```

### 5.3 实际项目选择建议


**🏢 企业级应用系统**
```
推荐：事件总线 + 异步通知
理由：
• 系统复杂，模块间需要高度解耦
• 支持动态扩展和插件化架构
• 便于单元测试和模块替换
```

**📱 移动应用或小型系统**
```
推荐：同步通知 + 推模式
理由：
• 系统规模小，复杂度可控
• 性能要求高，响应速度快
• 开发维护成本低
```

**🌐 Web应用**
```
推荐：异步通知 + 拉模式
理由：
• 用户体验要求高，不能阻塞UI
• 网络传输成本考虑，按需获取数据
• 支持高并发访问
```

**⚡ 实时系统**
```
推荐：同步通知 + 推模式
理由：
• 实时性要求极高
• 数据一致性要求严格
• 可预测的执行时间
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 推拉模式：数据传递方式的选择，影响性能和灵活性
🔸 同步异步：通知时机的选择，影响响应速度和并发性
🔸 事件总线：高级解耦方案，适合复杂系统架构
🔸 实现选择：根据具体需求选择合适的实现方式
```

### 6.2 关键理解要点


**🔹 推拉模式的本质区别**
```
推模式：我给你什么，你就接收什么（主动推送）
拉模式：你要什么，自己来取什么（按需获取）

选择依据：数据量大小和观察者多样性
```

**🔹 同步异步的选择标准**
```
同步：确保执行完成，但响应较慢
异步：快速响应，但状态难控制

选择依据：性能要求和一致性要求的平衡
```

**🔹 事件总线的价值**
```
解决的问题：观察者模式中发布者和订阅者的强耦合
提供的价值：完全解耦、动态扩展、类型安全
```

### 6.3 实际应用指导


**🎯 开发建议**
- **从简单开始**：优先选择推模式+同步通知
- **按需升级**：遇到性能问题再考虑异步
- **复杂系统才用事件总线**：避免过度设计
- **保持一致性**：同一项目中尽量使用统一的实现方式

**⚠️ 常见陷阱**
- **过度设计**：简单场景使用复杂方案
- **内存泄漏**：异步和事件总线要注意资源释放
- **调试困难**：异步和事件总线的问题定位较难
- **性能假象**：异步不一定比同步快，要实际测试

**🔧 最佳实践**
- **接口设计要稳定**：避免频繁修改观察者接口
- **异常处理要完善**：特别是异步场景的异常处理
- **提供配置选项**：让使用者可以选择同步或异步
- **监控和日志**：复杂系统要有完善的监控机制

**核心记忆**：
- 推拉看数据，同异看性能，总线看解耦
- 简单场景简单方案，复杂系统复杂设计
- 性能和一致性往往是矛盾的，需要权衡选择
- 实现方式可以组合使用，不是非此即彼