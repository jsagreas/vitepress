---
title: 2、适配器模式结构分析
---
## 📚 目录

1. [适配器模式基本结构](#1-适配器模式基本结构)
2. [目标接口定义](#2-目标接口定义)
3. [适配器类设计](#3-适配器类设计)
4. [被适配者接口](#4-被适配者接口)
5. [客户端调用方式](#5-客户端调用方式)
6. [适配过程分析](#6-适配过程分析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔌 适配器模式基本结构


### 1.1 什么是适配器模式


**🔸 生活中的适配器**
```
现实生活类比：
手机充电器 ──→ 转换器 ──→ 不同规格插座
   (客户)      (适配器)    (被适配者)

你的手机充电器是三脚插头，但酒店只有两脚插座
这时候你需要一个转换器，把三脚插头转成两脚插头
```

**🔸 编程中的适配器**
> 💡 **核心思想**：让两个不兼容的接口能够协同工作

适配器模式就像一个"翻译官"，它帮助两个"说不同语言"的类进行沟通。

### 1.2 适配器模式的四个核心角色


```
适配器模式角色图：

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   客户端     │───→│  目标接口    │←───│   适配器     │
│  (Client)   │    │  (Target)   │    │ (Adapter)   │
└─────────────┘    └─────────────┘    └─────────────┘
                                              │
                                              ▼
                                    ┌─────────────┐
                                    │  被适配者    │
                                    │ (Adaptee)   │
                                    └─────────────┘
```

**🎯 四个角色说明**：
- **客户端(Client)**：需要使用某个功能的代码
- **目标接口(Target)**：客户端期望使用的接口标准
- **适配器(Adapter)**：负责转换的"翻译官"
- **被适配者(Adaptee)**：已存在但接口不匹配的类

---

## 2. 🎯 目标接口定义


### 2.1 目标接口的作用


**🔸 什么是目标接口**
目标接口就是**客户端希望使用的标准接口**，它定义了客户端期望的方法规范。

> 📝 **通俗理解**：就像你期望所有充电器都是USB接口一样，目标接口定义了统一的"充电标准"

### 2.2 目标接口设计原则


**✅ 设计要点**：
- **简洁明了**：方法命名要清晰易懂
- **职责单一**：一个接口只负责一类功能
- **稳定不变**：一旦定义就不轻易修改

```java
// 目标接口示例：媒体播放器
public interface MediaPlayer {
    void play(String audioType, String fileName);
}
```

**💡 接口设计解析**：
- `play()`方法：播放功能的统一入口
- `audioType`参数：指定音频格式类型
- `fileName`参数：指定要播放的文件名

### 2.3 目标接口的特点


```
目标接口特征：

🔸 客户端友好：
   - 方法命名符合客户端使用习惯
   - 参数设计简单直观
   - 返回值类型明确

🔸 抽象层次合适：
   - 不暴露内部实现细节
   - 提供必要的功能接口
   - 保持适当的灵活性
```

---

## 3. 🔧 适配器类设计


### 3.1 适配器的核心职责


**🔸 适配器的工作原理**
```
适配器工作流程：

客户端调用 ──→ 适配器接收 ──→ 转换调用 ──→ 被适配者执行
    ↓              ↓              ↓              ↓
 统一接口       接口转换        参数转换        实际功能
```

> 💡 **形象比喻**：适配器就像一个"万能插座转换器"，不管什么样的插头都能转换成你需要的接口

### 3.2 适配器类的基本结构


```java
// 适配器类设计示例
public class AudioAdapter implements MediaPlayer {
    // 持有被适配者的引用
    private AdvancedMediaPlayer advancedPlayer;
    
    public AudioAdapter(String audioType) {
        // 根据类型创建对应的被适配者
        if ("vlc".equalsIgnoreCase(audioType)) {
            advancedPlayer = new VlcPlayer();
        } else if ("mp4".equalsIgnoreCase(audioType)) {
            advancedPlayer = new Mp4Player();
        }
    }
    
    @Override
    public void play(String audioType, String fileName) {
        // 接口适配：转换调用
        if ("vlc".equalsIgnoreCase(audioType)) {
            advancedPlayer.playVlc(fileName);
        } else if ("mp4".equalsIgnoreCase(audioType)) {
            advancedPlayer.playMp4(fileName);
        }
    }
}
```

### 3.3 适配器设计的关键点


**🎯 设计要素分析**：

**🔸 组合关系**：
```
适配器 ──包含──→ 被适配者
   ↑                ↓
实现目标接口      调用原有方法
```

**🔸 转换逻辑**：
- **参数转换**：将目标接口的参数转换为被适配者需要的格式
- **方法映射**：将目标接口的方法映射到被适配者的具体方法
- **返回值处理**：将被适配者的返回值转换为目标接口期望的格式

**🔸 错误处理**：
```java
@Override
public void play(String audioType, String fileName) {
    if (advancedPlayer == null) {
        System.out.println("不支持的音频格式: " + audioType);
        return;
    }
    // 执行适配转换...
}
```

---

## 4. 📦 被适配者接口


### 4.1 被适配者的特点


**🔸 什么是被适配者**
被适配者是**已经存在的类**，它有自己的接口标准，但这个标准与客户端期望的不一致。

> 📝 **生活类比**：就像你有一个很好用的欧式插头电器，但中国的插座是国标插头，这个欧式电器就是"被适配者"

### 4.2 被适配者的典型情况


**🔸 常见场景**：
- **第三方库**：功能强大但接口不符合项目规范
- **遗留系统**：老系统的接口无法修改
- **外部服务**：接口标准与内部不统一

```java
// 被适配者接口示例：高级媒体播放器
public interface AdvancedMediaPlayer {
    void playVlc(String fileName);
    void playMp4(String fileName);
}

// 具体的被适配者实现
public class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file: " + fileName);
    }
    
    @Override
    public void playMp4(String fileName) {
        // VLC播放器不支持MP4
    }
}
```

### 4.3 被适配者的设计原则


**✅ 保持独立性**：
```
被适配者特点：

🔸 接口固定：
   - 方法命名可能与目标接口不同
   - 参数格式可能有差异
   - 功能实现已经稳定

🔸 不可修改：
   - 可能是第三方库，无法修改源码
   - 可能是遗留系统，修改风险大
   - 可能被多个地方使用，不能随意改动
```

---

## 5. 👥 客户端调用方式


### 5.1 客户端使用模式


**🔸 客户端的视角**
对于客户端来说，它**只知道目标接口**，完全不需要了解适配器和被适配者的存在。

```java
// 客户端代码示例
public class AudioPlayer implements MediaPlayer {
    private MediaPlayer adapter;
    
    @Override
    public void play(String audioType, String fileName) {
        // 内置支持mp3格式
        if ("mp3".equalsIgnoreCase(audioType)) {
            System.out.println("Playing mp3 file: " + fileName);
        }
        // 通过适配器支持其他格式
        else if ("vlc".equalsIgnoreCase(audioType) || 
                 "mp4".equalsIgnoreCase(audioType)) {
            adapter = new AudioAdapter(audioType);
            adapter.play(audioType, fileName);
        }
        else {
            System.out.println("不支持的格式: " + audioType);
        }
    }
}
```

### 5.2 客户端调用流程


```
客户端调用流程图：

客户端
  │
  │ 调用 play("mp4", "movie.mp4")
  ▼
AudioPlayer
  │
  │ 创建 AudioAdapter("mp4")
  ▼
AudioAdapter
  │
  │ 调用 playMp4("movie.mp4")
  ▼
Mp4Player (被适配者)
  │
  │ 执行实际播放
  ▼
播放完成
```

### 5.3 客户端使用的优势


**🎯 客户端收益**：
- **统一接口**：不管什么格式，都用同一个`play()`方法
- **透明适配**：不需要知道内部如何转换
- **易于扩展**：新增格式支持不影响客户端代码

---

## 6. 🔄 适配过程分析


### 6.1 适配过程详解


**🔸 适配的三个关键步骤**

```
步骤1: 接口对接
┌─────────────┐    ┌─────────────┐
│目标接口方法  │───→│适配器实现    │
│play(type,   │    │play()方法   │
│fileName)    │    │             │
└─────────────┘    └─────────────┘

步骤2: 参数转换
┌─────────────┐    ┌─────────────┐
│通用参数      │───→│特定参数      │
│audioType    │    │针对不同      │
│fileName     │    │播放器的参数  │
└─────────────┘    └─────────────┘

步骤3: 方法映射
┌─────────────┐    ┌─────────────┐
│统一调用      │───→│具体实现      │
│play()       │    │playVlc()    │
│             │    │playMp4()    │
└─────────────┘    └─────────────┘
```

### 6.2 适配过程中的关键转换


**🔸 接口转换示例**：

```java
// 目标接口期望的调用方式
mediaPlayer.play("mp4", "movie.mp4");

// 适配器内部转换过程
public void play(String audioType, String fileName) {
    // 1. 判断音频类型
    if ("mp4".equalsIgnoreCase(audioType)) {
        // 2. 选择对应的被适配者
        // 3. 调用被适配者的特定方法
        advancedPlayer.playMp4(fileName);
    }
}

// 被适配者实际执行的方法
public void playMp4(String fileName) {
    System.out.println("Playing mp4 file: " + fileName);
}
```

### 6.3 适配过程的核心价值


**💎 适配器解决的核心问题**：

```
问题场景：
- 客户端期望：mediaPlayer.play("mp4", "file.mp4")
- 被适配者提供：vlcPlayer.playMp4("file.mp4")
- 接口不匹配：方法名、参数都不一致

适配器解决方案：
- 实现目标接口：满足客户端期望
- 组合被适配者：复用现有功能
- 转换调用：桥接两个不兼容的接口
```

**🎯 适配的本质**：
- **不是修改**：不改变原有类的代码
- **而是包装**：用新接口包装旧功能
- **保持兼容**：新旧系统都能正常工作

---

## 7. 📋 核心要点总结


### 7.1 适配器模式结构要点


```
🔸 四个核心角色：
   ✅ 客户端：使用统一接口的调用方
   ✅ 目标接口：客户端期望的接口标准
   ✅ 适配器：负责转换的中间层
   ✅ 被适配者：已存在但接口不匹配的功能

🔸 三个关键关系：
   ✅ 客户端 依赖 目标接口
   ✅ 适配器 实现 目标接口
   ✅ 适配器 组合 被适配者
```

### 7.2 设计要点记忆


**🎯 设计原则口诀**：
- **目标接口要稳定**：一旦定义不轻易改
- **适配器做转换**：专门负责接口翻译
- **被适配者不动**：保持原有功能不变
- **客户端很简单**：只知道目标接口就够

### 7.3 适配器模式的核心价值


**💡 解决的核心问题**：
- **接口不兼容**：让两个不匹配的接口协同工作
- **代码复用**：不修改原有代码就能复用功能
- **系统集成**：帮助新旧系统、内外系统整合

**⚡ 使用场景**：
- 集成第三方库时接口不匹配
- 新系统需要复用遗留系统功能
- 多个数据源需要统一访问接口

**🔧 实现要点**：
- 适配器通过**组合**而不是继承来实现
- 重点在于**接口转换**而不是功能增强
- 保持**单一职责**：只做接口适配这一件事

**核心记忆**：适配器模式就像万能插座转换器，让不同标准的插头都能插进同一个插座，实现"万物互联"！