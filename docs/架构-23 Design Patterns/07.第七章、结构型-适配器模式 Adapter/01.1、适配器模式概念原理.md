---
title: 1、适配器模式概念原理
---
## 📚 目录

1. [什么是适配器模式](#1-什么是适配器模式)
2. [接口不兼容问题](#2-接口不兼容问题)
3. [对象适配器vs类适配器](#3-对象适配器vs类适配器)
4. [应用场景分析](#4-应用场景分析)
5. [优缺点对比](#5-优缺点对比)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔌 什么是适配器模式


### 1.1 适配器模式的通俗定义


**🎯 生活中的适配器**

想象一下，你有一个三脚插头的电器，但墙上只有两孔插座。这时候你需要什么？**插头转换器**！这个转换器就是现实生活中的适配器。

```
原本情况：
三脚插头 ❌ 两孔插座 (不兼容)

使用适配器后：
三脚插头 → 插头转换器 → 两孔插座 ✅ (兼容了)
```

### 1.2 设计模式中的适配器


**🔸 核心定义**
```
适配器模式（Adapter Pattern）：
让两个不兼容的接口能够协同工作的桥梁

就像现实中的插头转换器一样，
在软件开发中也需要"转换器"来连接不同的接口
```

**💡 通俗理解**

适配器模式就是当你有两个很好用的类，但它们的接口（方法名、参数等）不一样，无法直接配合使用时，你就写一个"翻译官"来帮它们沟通。

### 1.3 适配器模式的结构图


```
客户端需要的接口          实际存在的类
     Target                  Adaptee
   ┌─────────┐             ┌─────────┐
   │ request()│             │specificRequest()│
   └─────────┘             └─────────┘
        ↑                       ↑
        │                       │
        └───── Adapter ─────────┘
              ┌─────────┐
              │ request()│
              │   {     │
              │ adaptee.│
              │specificRequest()│
              │   }     │
              └─────────┘
```

**📝 角色说明**
- **Target（目标接口）**：客户端期望使用的接口
- **Adaptee（被适配者）**：已经存在但接口不兼容的类
- **Adapter（适配器）**：转换器，实现Target接口，内部调用Adaptee

---

## 2. ⚠️ 接口不兼容问题


### 2.1 什么是接口不兼容


**🤔 日常开发中的困扰**

假设你在开发一个音乐播放器，已经有了一个很好用的`MP3Player`类：

```java
// 现有的MP3播放器
class MP3Player {
    public void playMP3(String filename) {
        System.out.println("播放MP3: " + filename);
    }
}
```

现在客户要求支持更多格式，你找到了一个强大的`AdvancedPlayer`类：

```java
// 第三方的高级播放器
class AdvancedPlayer {
    public void playWAV(String filename) {
        System.out.println("播放WAV: " + filename);
    }
    
    public void playFLAC(String filename) {
        System.out.println("播放FLAC: " + filename);
    }
}
```

**❌ 问题出现了**

你的音乐播放器接口是这样的：
```java
interface MediaPlayer {
    void play(String audioType, String filename);
}
```

但是`AdvancedPlayer`的方法名和参数都不一样！这就是典型的**接口不兼容问题**。

### 2.2 不兼容的常见情况


| 不兼容类型 | 具体表现 | 举例说明 |
|-----------|----------|----------|
| **方法名不同** | `play()` vs `execute()` | 音乐播放 vs 视频播放 |
| **参数不同** | `play(String)` vs `play(File, int)` | 简单播放 vs 复杂播放 |
| **返回值不同** | `void` vs `boolean` | 无返回 vs 状态返回 |
| **异常不同** | 不抛异常 vs 抛出检查异常 | 简单处理 vs 严格处理 |

### 2.3 为什么不直接修改源码


**🚫 修改源码的问题**
- 可能是第三方库，**没有源码**
- 修改可能**影响其他使用者**
- 违反了**开闭原则**（对修改封闭）
- **风险太大**，可能引入新bug

**✅ 适配器的优势**
- **不修改现有代码**
- **安全可靠**
- **符合设计原则**
- **容易维护**

---

## 3. 🔄 对象适配器vs类适配器


### 3.1 对象适配器（推荐方式）


**🔸 基本思路**
适配器内部**包含**一个被适配者的实例，通过调用这个实例的方法来完成适配。

```java
// 对象适配器示例
class MediaAdapter implements MediaPlayer {
    private AdvancedPlayer advancedPlayer;  // 包含被适配者
    
    public MediaAdapter(String audioType) {
        if (audioType.equals("wav") || audioType.equals("flac")) {
            advancedPlayer = new AdvancedPlayer();
        }
    }
    
    @Override
    public void play(String audioType, String filename) {
        if (audioType.equals("wav")) {
            advancedPlayer.playWAV(filename);      // 转发调用
        } else if (audioType.equals("flac")) {
            advancedPlayer.playFLAC(filename);     // 转发调用
        }
    }
}
```

**💡 对象适配器特点**
```
优点：
✅ 灵活性高 - 可以适配多个不同的类
✅ 符合组合优于继承原则
✅ 运行时可以动态选择被适配者

缺点：
❌ 需要额外的对象引用
❌ 代码稍微复杂一点
```

### 3.2 类适配器（了解即可）


**🔸 基本思路**
适配器**继承**被适配者类，同时实现目标接口。

```java
// 类适配器示例（Java中需要用接口模拟）
class ClassAdapter extends AdvancedPlayer implements MediaPlayer {
    @Override
    public void play(String audioType, String filename) {
        if (audioType.equals("wav")) {
            super.playWAV(filename);        // 直接调用父类方法
        } else if (audioType.equals("flac")) {
            super.playFLAC(filename);       // 直接调用父类方法
        }
    }
}
```

**⚠️ 类适配器的限制**
- Java不支持多重继承，**使用受限**
- 继承关系固定，**不够灵活**
- 通常**不推荐**使用

### 3.3 两种方式对比


| 比较维度 | 对象适配器 | 类适配器 |
|---------|-----------|----------|
| **实现方式** | 组合（包含） | 继承 |
| **灵活性** | 🟢 高 | 🟡 中 |
| **适配多个类** | 🟢 支持 | 🔴 困难 |
| **Java支持度** | 🟢 完全支持 | 🟡 受限 |
| **推荐程度** | ⭐⭐⭐⭐⭐ | ⭐⭐ |

---

## 4. 🎯 应用场景分析


### 4.1 第三方库集成


**📖 场景描述**
你的项目需要集成一个第三方支付SDK，但它的接口和你系统的支付接口不一致。

```
你的支付接口：
interface PaymentService {
    boolean pay(double amount, String currency);
}

第三方SDK：
class ThirdPartyPayment {
    public void makePayment(BigDecimal money, CurrencyType type);
    public PaymentResult getResult();
}
```

**🔧 适配器解决方案**
```java
class PaymentAdapter implements PaymentService {
    private ThirdPartyPayment thirdPartyPayment;
    
    public PaymentAdapter() {
        this.thirdPartyPayment = new ThirdPartyPayment();
    }
    
    @Override
    public boolean pay(double amount, String currency) {
        // 数据格式转换
        BigDecimal money = BigDecimal.valueOf(amount);
        CurrencyType type = CurrencyType.valueOf(currency);
        
        // 调用第三方方法
        thirdPartyPayment.makePayment(money, type);
        
        // 结果转换
        PaymentResult result = thirdPartyPayment.getResult();
        return result.isSuccess();
    }
}
```

### 4.2 旧系统集成


**📖 场景描述**
公司有个老系统的用户管理模块很稳定，但接口老旧。新系统想复用这个模块。

```
新系统期望的接口：
interface UserService {
    User getUserById(String userId);
    List<User> getAllUsers();
}

老系统的接口：
class LegacyUserManager {
    public UserInfo findUser(int id);
    public UserInfo[] listAllUsers();
}
```

**🔧 适配器解决方案**
```java
class UserServiceAdapter implements UserService {
    private LegacyUserManager legacyManager;
    
    public UserServiceAdapter() {
        this.legacyManager = new LegacyUserManager();
    }
    
    @Override
    public User getUserById(String userId) {
        // ID类型转换：String → int
        int id = Integer.parseInt(userId);
        UserInfo userInfo = legacyManager.findUser(id);
        
        // 对象转换：UserInfo → User
        return convertToUser(userInfo);
    }
    
    @Override
    public List<User> getAllUsers() {
        UserInfo[] userInfos = legacyManager.listAllUsers();
        
        // 数组转换为List，并转换对象类型
        return Arrays.stream(userInfos)
                    .map(this::convertToUser)
                    .collect(Collectors.toList());
    }
    
    private User convertToUser(UserInfo userInfo) {
        // 具体的对象转换逻辑
        return new User(String.valueOf(userInfo.getId()), 
                       userInfo.getName());
    }
}
```

### 4.3 数据格式转换


**📖 场景描述**
你的系统需要对接多个数据源，它们返回的数据格式都不一样。

```
系统统一接口：
interface DataProcessor {
    List<DataRecord> processData(String source);
}

不同的数据源：
- XMLDataSource：返回XML格式
- JSONDataSource：返回JSON格式  
- CSVDataSource：返回CSV格式
```

**🔧 适配器解决方案**
```java
// XML适配器
class XMLDataAdapter implements DataProcessor {
    private XMLDataSource xmlSource;
    
    @Override
    public List<DataRecord> processData(String source) {
        String xmlData = xmlSource.getXMLData(source);
        return parseXMLToRecords(xmlData);
    }
}

// JSON适配器
class JSONDataAdapter implements DataProcessor {
    private JSONDataSource jsonSource;
    
    @Override
    public List<DataRecord> processData(String source) {
        String jsonData = jsonSource.getJSONData(source);
        return parseJSONToRecords(jsonData);
    }
}
```

### 4.4 常见应用领域


| 应用领域 | 具体用途 | 典型例子 |
|---------|----------|----------|
| **框架集成** | 不同框架间的协调 | Spring整合Hibernate |
| **数据库驱动** | 统一数据库访问接口 | JDBC驱动程序 |
| **文件格式** | 不同格式的统一处理 | 文档转换工具 |
| **API网关** | 内外部接口适配 | 微服务网关 |
| **设备驱动** | 硬件设备接口适配 | 打印机驱动 |

---

## 5. ⚖️ 优缺点对比


### 5.1 适配器模式的优点


**✅ 主要优势**

| 优点 | 详细说明 | 实际好处 |
|------|----------|----------|
| **复用现有代码** | 不需要重写已有功能 | 🎯 节省开发时间 |
| **解耦合** | 客户端不直接依赖具体实现 | 🔧 易于维护 |
| **符合开闭原则** | 不修改原有代码 | 🛡️ 降低风险 |
| **提高兼容性** | 让不兼容的类能协同工作 | 🌐 系统集成更容易 |

**💡 具体体现**
```
代码复用：
- 老系统的稳定功能可以继续使用
- 第三方库的强大功能可以直接利用
- 不需要重复造轮子

系统解耦：
- 客户端代码不需要了解具体的适配细节
- 可以随时更换被适配的类
- 接口变更影响范围小
```

### 5.2 适配器模式的缺点


**❌ 潜在问题**

| 缺点 | 详细说明 | 影响程度 |
|------|----------|----------|
| **增加代码复杂度** | 多了一层转换逻辑 | 🟡 中等 |
| **性能略有损失** | 多了一次方法调用 | 🟢 较小 |
| **调试困难** | 多了一层调用栈 | 🟡 中等 |
| **过度使用风险** | 可能滥用导致设计混乱 | 🔴 较大 |

**⚠️ 需要注意的问题**
```
复杂度增加：
- 系统中适配器太多会让人困惑
- 需要维护额外的适配器代码
- 新人理解成本增加

性能考虑：
- 每次调用都要经过适配器
- 在高频调用场景下需要考虑性能
- 通常性能损失可以忽略不计
```

### 5.3 使用建议


**🎯 何时使用适配器模式**
- 需要使用现有类，但接口不符合需求
- 想要复用一些现有的子类，但不可能对每个子类都进行子类化
- 需要在不修改源码的情况下复用第三方库

**🚫 何时不建议使用**
- 如果可以直接修改源码且风险可控
- 系统还在早期设计阶段，可以统一设计接口
- 性能要求极高，不能容忍任何额外开销

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 适配器模式本质：让不兼容的接口能够协同工作的桥梁
🔸 核心作用：在不修改现有代码的前提下，实现接口适配
🔸 实现方式：对象适配器（推荐）和类适配器
🔸 应用场景：第三方库集成、旧系统复用、数据格式转换
🔸 设计原则：符合开闭原则，组合优于继承
```

### 6.2 关键理解要点


**🔹 适配器就是"翻译官"**
```
作用机制：
客户端请求 → 适配器接收 → 转换格式 → 调用被适配者 → 转换结果 → 返回客户端

关键步骤：
1. 接收客户端的标准请求
2. 将请求转换为被适配者能理解的格式
3. 调用被适配者的方法
4. 将结果转换为客户端期望的格式
5. 返回给客户端
```

**🔹 对象适配器vs类适配器**
```
选择原则：
- 优先选择对象适配器（组合）
- 除非特殊情况才考虑类适配器（继承）
- Java环境下类适配器使用受限

记忆方法：
- 对象适配器 = 包含 + 转发
- 类适配器 = 继承 + 重写
```

**🔹 什么时候需要适配器**
```
典型信号：
- "这个库很好用，但接口不匹配"
- "老系统很稳定，但接口老旧"
- "第三方接口和我们的标准不一致"
- "需要统一多个不同数据源的接口"
```

### 6.3 实际应用价值


**🎯 在开发中的作用**
- **系统集成**：快速集成不同来源的组件
- **遗留系统**：让老系统焕发新的生命力
- **第三方库**：轻松使用各种开源库和商业组件
- **接口统一**：为不同的实现提供统一的访问方式

**🔧 最佳实践建议**
- 适配器应该**尽量简单**，只做必要的转换
- **一个适配器通常只适配一个类**
- 在适配器中添加**必要的日志**和**异常处理**
- **文档要清楚**，说明适配的目的和转换逻辑

**核心记忆口诀**：
```
接口不匹配，适配器来帮忙
组合胜继承，转换在中央
第三方集成，旧系统复用
桥梁连两端，翻译解语障
```