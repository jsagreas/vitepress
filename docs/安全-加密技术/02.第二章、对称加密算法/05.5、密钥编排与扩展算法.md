---
title: 5、密钥编排与扩展算法
---
## 📚 目录

1. [密钥编排算法原理](#1-密钥编排算法原理)
2. [AES密钥扩展详解](#2-AES密钥扩展详解)
3. [轮常数的生成](#3-轮常数的生成)
4. [密钥调度的安全性](#4-密钥调度的安全性)
5. [相关密钥攻击防护](#5-相关密钥攻击防护)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔐 密钥编排算法原理


### 1.1 什么是密钥编排


**🎯 简单理解**：密钥编排就像是**把一把钥匙变成很多把不同的钥匙**。

在加密算法中，我们通常只有一个**主密钥**（比如你设置的密码），但加密过程需要在**每一轮**都使用**不同的密钥**。密钥编排算法就负责从这个主密钥**生成出**多个轮密钥。

```
比喻理解：
主密钥 = 一个密码："MyPassword123"
     ↓ (密钥编排算法)
轮密钥 = 第1轮密钥、第2轮密钥、第3轮密钥...

就像用一个万能钥匙，制造出开不同房间门的专用钥匙
```

### 1.2 为什么需要密钥编排


**🤔 核心问题**：为什么不能每轮都用同一个密钥？

```
假设没有密钥编排：
第1轮加密：数据 + 主密钥 = 结果1
第2轮加密：结果1 + 主密钥 = 结果2  
第3轮加密：结果2 + 主密钥 = 结果3

问题：
❌ 容易被破解：攻击者可以通过分析规律找到主密钥
❌ 安全性差：相同的密钥模式容易被识别
❌ 抗攻击能力弱：缺乏随机性和复杂性
```

**✅ 有了密钥编排：**
```
第1轮加密：数据 + 轮密钥1 = 结果1
第2轮加密：结果1 + 轮密钥2 = 结果2
第3轮加密：结果2 + 轮密钥3 = 结果3

优势：
✅ 每轮密钥都不同，增加破解难度
✅ 即使一个轮密钥被破解，其他轮密钥仍然安全
✅ 提供更强的随机性和不可预测性
```

### 1.3 密钥编排的基本流程


```
密钥编排过程：

步骤1：输入主密钥
    主密钥：128位 (16字节)

步骤2：密钥扩展
    通过算法生成更多的密钥材料
    
步骤3：提取轮密钥
    从扩展的密钥材料中提取各轮密钥
    
步骤4：分发使用
    第0轮：轮密钥0 (通常就是主密钥)
    第1轮：轮密钥1
    第2轮：轮密钥2
    ...
    第N轮：轮密钥N
```

---

## 2. 🔧 AES密钥扩展详解


### 2.1 AES密钥扩展概览


**📋 基本信息**：
- **AES-128**：主密钥128位 → 生成11个轮密钥 (每个128位)
- **AES-192**：主密钥192位 → 生成13个轮密钥 (每个128位)  
- **AES-256**：主密钥256位 → 生成15个轮密钥 (每个128位)

> 💡 **为什么轮密钥都是128位**？因为AES的状态矩阵始终是4×4字节=128位

### 2.2 AES-128密钥扩展详细过程


**🔸 第一步：理解数据结构**

```
主密钥表示：
原始密钥：MySecretKey12345  (16字节)
十六进制：4D 79 53 65 63 72 65 74 4B 65 79 31 32 33 34 35

按列排列成4×4矩阵：
+----+----+----+----+
| 4D | 63 | 4B | 32 |  W[0]
| 79 | 72 | 65 | 33 |  W[1]  
| 53 | 65 | 79 | 34 |  W[2]
| 65 | 74 | 31 | 35 |  W[3]
+----+----+----+----+

每一列称为一个"字"(Word)，记作W[0], W[1], W[2], W[3]
```

**🔸 第二步：核心扩展算法**

```
扩展公式：
对于 i ≥ 4：

如果 i % 4 = 0：  // 每4个字的第一个
    W[i] = W[i-4] ⊕ SubWord(RotWord(W[i-1])) ⊕ Rcon[i/4]
    
否则：
    W[i] = W[i-4] ⊕ W[i-1]
```

> 💭 **通俗解释**：
> - **RotWord**：把4字节向左旋转1位 (AB CD EF GH → BC DE FG HA)
> - **SubWord**：对每个字节做S盒替换 (就是AES中的字节替换)
> - **Rcon[i]**：轮常数，提供额外的随机性
> - **⊕**：异或运算

### 2.3 AES密钥扩展实例演示


**🎯 以AES-128为例，计算第5个字W[4]：**

```
已知：
W[0] = [4D, 79, 53, 65]
W[1] = [63, 72, 65, 74]
W[2] = [4B, 65, 79, 31] 
W[3] = [32, 33, 34, 35]

计算W[4] (i=4, i%4=0)：

步骤1：取W[3] = [32, 33, 34, 35]

步骤2：RotWord(W[3])
    [32, 33, 34, 35] → [33, 34, 35, 32]

步骤3：SubWord([33, 34, 35, 32])
    通过S盒查表：
    33 → F6, 34 → 53, 35 → 65, 32 → 19
    结果：[F6, 53, 65, 19]

步骤4：异或轮常数 Rcon[1] = [01, 00, 00, 00]
    [F6, 53, 65, 19] ⊕ [01, 00, 00, 00] = [F7, 53, 65, 19]

步骤5：与W[0]异或
    W[4] = W[0] ⊕ [F7, 53, 65, 19]
         = [4D, 79, 53, 65] ⊕ [F7, 53, 65, 19]
         = [BA, 2A, 36, 7C]
```

### 2.4 简化的代码实现


```python
def aes_key_expansion(key):
    """AES-128密钥扩展算法"""
    
    # S盒 (简化版，实际有256个值)
    S_BOX = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, ...]
    
    # 轮常数
    RCON = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]
    
    def rot_word(word):
        """字循环：左移一个字节"""
        return word[1:] + word[:1]
    
    def sub_word(word):
        """字节替换"""
        return [S_BOX[b] for b in word]
    
    # 初始化：前4个字就是原始密钥
    w = []
    for i in range(4):
        w.append(key[i*4:(i+1)*4])
    
    # 扩展生成后续的字
    for i in range(4, 44):  # AES-128需要44个字
        if i % 4 == 0:
            # 特殊处理：旋转、替换、异或轮常数
            temp = rot_word(w[i-1])
            temp = sub_word(temp)
            temp[0] ^= RCON[i//4 - 1]
            w.append([w[i-4][j] ^ temp[j] for j in range(4)])
        else:
            # 简单异或
            w.append([w[i-4][j] ^ w[i-1][j] for j in range(4)])
    
    # 组合成轮密钥
    round_keys = []
    for round_num in range(11):
        round_key = []
        for j in range(4):
            round_key.extend(w[round_num*4 + j])
        round_keys.append(round_key)
    
    return round_keys
```

---

## 3. 🎲 轮常数的生成


### 3.1 什么是轮常数（Rcon）


**🎯 简单理解**：轮常数就是**每轮密钥扩展时加入的特殊数字**，目的是让每轮生成的密钥都有所不同。

> 💡 **比喻**：就像做菜时每道工序都要加不同的调料，轮常数就是密钥扩展过程中的"调料"

### 3.2 AES轮常数的数学原理


**📋 轮常数定义**：
```
Rcon[i] = [x^(i-1), 0, 0, 0]  (在GF(2^8)有限域中)

其中 x = 0x02，运算在AES的有限域中进行
```

**🔸 实际计算过程**：

```
轮常数计算（有限域乘法）：
Rcon[1] = [0x01, 0x00, 0x00, 0x00]  // x^0 = 1
Rcon[2] = [0x02, 0x00, 0x00, 0x00]  // x^1 = 2  
Rcon[3] = [0x04, 0x00, 0x00, 0x00]  // x^2 = 4
Rcon[4] = [0x08, 0x00, 0x00, 0x00]  // x^3 = 8
Rcon[5] = [0x10, 0x00, 0x00, 0x00]  // x^4 = 16
Rcon[6] = [0x20, 0x00, 0x00, 0x00]  // x^5 = 32
Rcon[7] = [0x40, 0x00, 0x00, 0x00]  // x^6 = 64
Rcon[8] = [0x80, 0x00, 0x00, 0x00]  // x^7 = 128
Rcon[9] = [0x1B, 0x00, 0x00, 0x00]  // x^8 = 27 (在GF(2^8)中)
Rcon[10]= [0x36, 0x00, 0x00, 0x00]  // x^9 = 54 (在GF(2^8)中)
```

> ⚠️ **注意**：当结果超过255时，需要按照AES的不可约多项式 `x^8 + x^4 + x^3 + x + 1` 进行模运算

### 3.3 轮常数的作用


**🎯 核心作用**：

1. **🔸 打破对称性**
```
没有轮常数：
W[4] = W[0] ⊕ 处理后的W[3]
W[8] = W[4] ⊕ 处理后的W[7]

可能出现：W[8] = W[0] (如果处理后的W[3] = 处理后的W[7])
```

2. **🔸 增加随机性**
```
有了轮常数：
W[4] = W[0] ⊕ 处理后的W[3] ⊕ Rcon[1]
W[8] = W[4] ⊕ 处理后的W[7] ⊕ Rcon[2]

由于Rcon[1] ≠ Rcon[2]，保证了W[8] ≠ W[0]
```

3. **🔸 防止相关密钥攻击**
```
如果两个主密钥只相差一个比特：
Key1: 1000 0000 0000 0000
Key2: 1000 0000 0000 0001

轮常数确保它们的轮密钥差异会快速扩散，
不会出现简单的线性关系
```

### 3.4 轮常数生成代码


```python
def generate_rcon(num_rounds):
    """生成AES轮常数"""
    rcon = [[0x01, 0x00, 0x00, 0x00]]  # Rcon[1]
    
    for i in range(1, num_rounds):
        # 在GF(2^8)中计算 x^i
        prev_val = rcon[i-1][0]
        
        # 左移一位 (相当于乘以x)
        next_val = prev_val << 1
        
        # 如果超过了GF(2^8)的范围，需要模约简
        if next_val & 0x100:  # 如果第9位为1
            next_val ^= 0x11B  # 减去不可约多项式
        
        rcon.append([next_val & 0xFF, 0x00, 0x00, 0x00])
    
    return rcon

# 使用示例
rcon_values = generate_rcon(10)
for i, val in enumerate(rcon_values, 1):
    print(f"Rcon[{i}] = {val}")
```

---

## 4. 🛡️ 密钥调度的安全性


### 4.1 密钥调度安全性要求


**🎯 核心安全目标**：

| 安全要求 | **说明** | **实现方式** |
|---------|----------|-------------|
| **🔸 雪崩效应** | `主密钥微小变化导致所有轮密钥大幅变化` | `非线性S盒 + 轮常数` |
| **🔸 不可逆性** | `从轮密钥难以推导出主密钥` | `单向哈希性质` |
| **🔸 独立性** | `各轮密钥之间相关性最小` | `复杂的扩展算法` |
| **🔸 均匀分布** | `轮密钥的比特分布尽可能均匀` | `S盒替换 + 异或运算` |

### 4.2 雪崩效应演示


**🌊 雪崩效应**：主密钥改变1位，应该导致至少50%的轮密钥比特发生变化。

```
测试示例：
原始密钥: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
修改密钥: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01

对比第一轮密钥：
原始轮密钥1: 62 63 63 63 62 63 63 63 62 63 63 63 62 63 63 63
修改轮密钥1: 63 63 63 62 63 63 63 62 63 63 63 62 63 63 63 62

变化的位数: 64位中有32位发生变化 = 50%雪崩效应 ✅
```

### 4.3 抗相关密钥攻击


**🔍 相关密钥攻击**：攻击者故意选择有特定关系的多个密钥，寻找轮密钥之间的关系来破解加密。

**🛡️ AES的防护措施**：

1. **🔸 轮常数的引入**
```
防护原理：
即使主密钥K1和K2只差1位，由于轮常数的存在：
RoundKey1[i] = f(K1, Rcon[i])
RoundKey2[i] = f(K2, Rcon[i])

轮常数确保了两者的差异会在后续轮次中快速扩散
```

2. **🔸 S盒的非线性**
```
线性变换的问题：
如果密钥扩展只用异或和移位，攻击者可以：
K1 ⊕ K2 = ΔK → RoundKey1[i] ⊕ RoundKey2[i] = 可预测的值

S盒的非线性：
S(a) ⊕ S(b) ≠ S(a ⊕ b)  
这样打破了简单的线性关系
```

### 4.4 密钥强度评估


**📊 密钥调度强度指标**：

```
评估标准：

🔸 扩散性 (Diffusion)：
测试方法：改变主密钥1位，统计轮密钥变化比特数
优秀标准：≥50%的比特发生变化

🔸 混淆性 (Confusion)：
测试方法：分析轮密钥与主密钥的统计关系
优秀标准：无明显的线性或统计关系

🔸 周期长度：
测试方法：检查密钥扩展的周期性
优秀标准：周期长度应该足够大

🔸 平衡性：
测试方法：统计轮密钥中0和1的分布
优秀标准：接近50:50的比例
```

---

## 5. ⚔️ 相关密钥攻击防护


### 5.1 什么是相关密钥攻击


**🎯 攻击原理**：攻击者**故意选择**有特定数学关系的多个密钥，通过比较这些密钥产生的加密结果，寻找密钥或算法的漏洞。

```
经典攻击场景：
攻击者选择密钥：
K1 = 1234 5678 9ABC DEF0 1234 5678 9ABC DEF0
K2 = 1234 5678 9ABC DEF1 1234 5678 9ABC DEF0  (只差最后1位)

然后用相同明文加密：
C1 = AES(明文, K1)
C2 = AES(明文, K2)

分析 C1 ⊕ C2 的模式，寻找密钥信息
```

> ⚠️ **注意**：这种攻击在实际应用中较难实施，因为攻击者通常无法任意选择密钥

### 5.2 AES对相关密钥攻击的防护


**🛡️ 主要防护机制**：

1. **🔸 轮常数的不对称性**
```
防护原理：
即使两个主密钥只差1位，轮常数确保：

第i轮：RK1[i] = f(K1) ⊕ Rcon[i]
       RK2[i] = f(K2) ⊕ Rcon[i]

由于Rcon[i]的存在，RK1[i] ⊕ RK2[i]不是简单的线性关系
```

2. **🔸 S盒的非线性混淆**
```
线性系统的弱点：
如果只有异或操作：(K1 ⊕ ΔK) → (RK1 ⊕ Δ)
攻击者可以预测轮密钥的差分

S盒的非线性：
SubBytes(K1) ⊕ SubBytes(K1 ⊕ ΔK) ≠ 可预测值
这样破坏了差分的可预测性
```

3. **🔸 密钥扩展的复杂性**
```
多层混合：
- 字节替换 (SubWord)
- 行移位 (RotWord)  
- 轮常数异或
- 前序密钥异或

这些操作组合在一起，使得相关密钥的影响快速扩散和混淆
```

### 5.3 实际防护建议


**💡 应用层防护**：

1. **🔸 随机密钥生成**
```python
import os
import secrets

def generate_secure_key():
    """生成安全的随机密钥"""
    # 使用密码学安全的随机数生成器
    return secrets.token_bytes(16)  # 128位密钥

# 避免使用有规律的密钥
bad_key = b"1234567812345678"  # ❌ 有规律
good_key = generate_secure_key()  # ✅ 随机生成
```

2. **🔸 密钥派生函数 (KDF)**
```python
from hashlib import pbkdf2_hmac

def derive_key(password, salt):
    """从密码派生密钥"""
    return pbkdf2_hmac(
        'sha256',           # 哈希算法
        password.encode(),  # 原始密码
        salt,              # 盐值
        100000             # 迭代次数
    )[:16]  # 取前16字节作为AES密钥

# 即使密码相似，生成的密钥也会完全不同
password1 = "MyPassword123"
password2 = "MyPassword124"
salt = os.urandom(16)

key1 = derive_key(password1, salt)
key2 = derive_key(password2, salt)
# key1 和 key2 会完全不同
```

3. **🔸 密钥更新策略**
```
定期更新：
- 每日更新会话密钥
- 每月更新主密钥
- 发现安全事件时立即更新

版本控制：
- 保留多个版本的密钥
- 支持密钥回滚
- 记录密钥使用历史
```

### 5.4 相关密钥攻击的局限性


**🎯 为什么这种攻击在实际中很难**：

| 限制因素 | **说明** |
|---------|----------|
| **🔸 密钥控制权** | `攻击者通常无法任意选择加密密钥` |
| **🔸 数据需求** | `需要大量相关密钥的加密数据` |
| **🔸 计算复杂度** | `分析过程需要巨大的计算资源` |
| **🔸 检测风险** | `异常的密钥使用模式容易被发现` |

> 💭 **总结**：相关密钥攻击更多是理论研究，在实际应用中，AES的密钥调度算法提供了足够的安全性

---

## 6. 📋 核心要点总结


### 6.1 必须理解的关键概念


```
🔸 密钥编排本质：从一个主密钥生成多个不同的轮密钥
🔸 扩展算法核心：旋转 + 替换 + 轮常数 + 异或组合
🔸 轮常数作用：提供随机性，防止对称性和周期性
🔸 安全性目标：雪崩效应、不可逆性、独立性、均匀分布
🔸 攻击防护：通过非线性和复杂性抵御相关密钥攻击
```

### 6.2 实际应用要点


**🎯 开发建议**：
- ✅ 使用标准的AES实现，不要自己编写密钥扩展算法
- ✅ 确保密钥来源的随机性，使用密码学安全的随机数生成器
- ✅ 考虑使用密钥派生函数(KDF)增强密钥安全性
- ❌ 避免使用有规律或相关的密钥

**🔧 性能考虑**：
- 密钥扩展通常在加密开始前一次性完成
- 可以预计算轮密钥以提高后续加密速度
- 内存中存储轮密钥时注意安全清理

**🛡️ 安全提醒**：
- 密钥扩展的安全性依赖于主密钥的质量
- 定期更新密钥是最好的安全实践
- 监控异常的密钥使用模式

### 6.3 记忆要点


> 💡 **核心记忆**：
> - 密钥编排 = 一把钥匙变多把钥匙
> - AES扩展 = 旋转、替换、轮常数、异或
> - 轮常数 = 每轮不同的"调料"，防止周期性
> - 安全性 = 雪崩效应 + 非线性混淆
> - 实际应用 = 用标准实现 + 随机密钥 + 定期更新

**🔍 深入理解**：密钥编排算法是对称加密的"幕后英雄"，它确保了即使只有一个主密钥，整个加密过程也能获得足够的复杂性和安全性。理解这个过程有助于更好地使用和配置加密系统。