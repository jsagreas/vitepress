---
title: 4、RSA填充与签名方案
---
## 📚 目录

1. [为什么需要填充方案](#1-为什么需要填充方案)
2. [PKCS#1 v1.5填充方案](#2-pkcs1-v15填充方案)
3. [OAEP填充方案（推荐）](#3-oaep填充方案推荐)
4. [PSS签名方案](#4-pss签名方案)
5. [RSA攻击方法与防护](#5-rsa攻击方法与防护)
6. [实际应用选择指南](#6-实际应用选择指南)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔒 为什么需要填充方案


### 1.1 RSA裸加密的问题


**什么是裸加密**？
裸加密就是直接对原始数据进行RSA运算，不做任何预处理。这样做有很大的安全风险。

```
简单比喻：
裸加密 = 把钱直接放在透明袋子里
填充加密 = 把钱放在密码箱里，再套上伪装外壳
```

**🚨 裸加密的主要问题**：

**确定性加密问题**：
- 相同的明文总是产生相同的密文
- 攻击者可以通过密文判断是否是相同的消息
- 例如：加密"YES"和"NO"，攻击者虽然不知道具体内容，但能判断两次加密的是否相同

**可预测明文攻击**：
- 如果明文空间较小（如"同意"/"拒绝"），攻击者可以枚举所有可能
- 对每种可能进行加密，然后与目标密文对比
- 一旦匹配就破解了密文

**数学攻击风险**：
- 某些特殊数字在RSA运算中存在数学漏洞
- 例如：数字0、1、-1等可能导致安全问题

### 1.2 填充的作用原理


**🛡️ 填充解决的核心问题**：

```
原始流程：明文 → RSA加密 → 密文

填充流程：明文 → 填充处理 → RSA加密 → 密文
         ↑
    加入随机性和结构化数据
```

**填充的三大作用**：
1. **增加随机性**：每次加密相同明文都产生不同密文
2. **扩展长度**：将短消息扩展到密钥长度
3. **增强安全性**：抵御各种数学攻击

---

## 2. 📋 PKCS#1 v1.5填充方案


### 2.1 基本原理


**PKCS#1 v1.5** 是最早的标准化RSA填充方案，虽然现在被认为相对较弱，但仍在很多地方使用。

**🔧 填充结构**：
```
完整填充块格式：
┌──┬──┬─────────────┬──┬─────────────┐
│00│BT│   填充字节   │00│   实际数据   │
└──┴──┴─────────────┴──┴─────────────┘
 1字节  1字节  随机长度   1字节   消息长度

BT = Block Type（块类型）
- 00：私钥操作（不常用）
- 01：私钥操作（签名）
- 02：公钥操作（加密）
```

### 2.2 加密时的填充（BT=02）


**🔐 加密填充步骤**：

1. **检查消息长度**：确保消息不超过密钥长度-11字节
2. **构造填充块**：
   ```
   格式：00 || 02 || 随机字节 || 00 || 消息
   随机字节：至少8个非零随机字节
   ```
3. **生成最终块**：转换为整数进行RSA运算

**💡 实际例子**（假设2048位密钥，256字节）：
```
原始消息："Hello"（5字节）
需要填充：256 - 5 - 3 = 248字节的随机数据

填充结果：
00 02 [241个随机非零字节] 00 48656C6C6F
│  │   │                    │  │
│  │   └─ 随机填充           │  └─ "Hello"的十六进制
│  └─ 加密标识               └─ 分隔符
└─ 起始标识
```

### 2.3 签名时的填充（BT=01）


**✍️ 签名填充步骤**：
```
格式：00 || 01 || FF...FF || 00 || 消息摘要

示例：
00 01 FFFFFFFFFFFF...FF 00 [消息的哈希值]
│  │  │                 │  │
│  │  └─ 全为FF的填充    │  └─ 通常是SHA-256等哈希结果
│  └─ 签名标识          └─ 分隔符
└─ 起始标识
```

### 2.4 PKCS#1 v1.5的优缺点


**✅ 优点**：
- 实现简单，计算开销小
- 兼容性好，广泛支持
- 适合处理较长的消息

**❌ 缺点**：
- 存在填充神谕攻击（Padding Oracle Attack）风险
- 安全性相对较弱
- 填充可预测性较强

**⚠️ 安全建议**：
- 新系统不推荐使用
- 如果必须使用，要确保正确的错误处理
- 配合其他安全措施使用

---

## 3. 🛡️ OAEP填充方案（推荐）


### 3.1 什么是OAEP


**OAEP** = **O**ptimal **A**symmetric **E**ncryption **P**adding（最优非对称加密填充）

**为什么叫"最优"**？
- 在理论上可证明其安全性
- 能抵御自适应选择密文攻击
- 是目前推荐的RSA填充标准

### 3.2 OAEP工作原理


**🔄 OAEP核心思想**：
通过两轮"掩码生成"来增强安全性，让攻击者无法从密文中获取任何有用信息。

**工作流程图**：
```
原始消息 M
    ↓
┌─────────────────────────────────────┐
│ 第一步：准备阶段                     │
└─────────────────────────────────────┘
M + 标签哈希 + 01 + 00...00 = DB
    ↓
生成随机种子 seed
    ↓
┌─────────────────────────────────────┐
│ 第二步：第一轮掩码                   │
└─────────────────────────────────────┘
掩码1 = MGF(seed, DB长度)
掩码DB = DB ⊕ 掩码1
    ↓
┌─────────────────────────────────────┐
│ 第三步：第二轮掩码                   │
└─────────────────────────────────────┘
掩码2 = MGF(掩码DB, seed长度)
掩码seed = seed ⊕ 掩码2
    ↓
最终结果：00 || 掩码seed || 掩码DB
```

### 3.3 详细步骤解析


**📝 第一步：数据准备**
```
DB = 标签哈希 || PS || 01 || M

其中：
- 标签哈希：通常是空字符串的SHA-1哈希（20字节的零）
- PS：填充字符串，全为00的字节
- 01：分隔符，表示消息开始
- M：实际消息
```

**🎭 第二步：掩码生成函数（MGF）**
MGF是一个可以生成任意长度伪随机数据的函数：
```python
def MGF1(seed, length):
    """
    简化版MGF1实现说明
    seed: 种子数据
    length: 需要生成的掩码长度
    """
    # 用哈希函数反复处理seed，生成足够长的掩码
    # 具体实现较复杂，这里只说明原理
    return 生成的掩码数据
```

**🔐 第三步：双重掩码保护**
两轮掩码操作确保：
- 任何一个比特的改变都会影响整个结果
- 即使攻击者知道部分信息，也无法推断其他部分
- 提供可证明的安全性

### 3.4 OAEP的安全优势


**🏆 相比PKCS#1 v1.5的改进**：

| 特性 | PKCS#1 v1.5 | OAEP |
|------|-------------|------|
| **随机性** | 部分随机 | 完全随机化 |
| **安全证明** | ❌ 无理论保证 | ✅ 可证明安全 |
| **抗攻击能力** | ⚠️ 存在已知攻击 | 🛡️ 抗多种攻击 |
| **填充神谕攻击** | ❌ 易受攻击 | ✅ 有效防护 |
| **消息恢复** | ⚠️ 可能泄露信息 | 🔒 信息完全保护 |

**🔍 实际安全效果**：
- **全或无性质**：攻击者要么获得完整消息，要么什么都得不到
- **语义安全**：从密文无法推断明文的任何信息
- **非延展性**：无法在不知道明文的情况下修改密文

---

## 4. ✍️ PSS签名方案


### 4.1 PSS签名的优势


**PSS** = **P**robabilistic **S**ignature **S**cheme（概率签名方案）

**为什么需要PSS**？
传统的RSA签名（PKCS#1 v1.5）是确定性的，相同的消息总是产生相同的签名。PSS引入随机性，每次签名都不同，但验证仍然成功。

**🎯 PSS的核心优势**：
- **可证明安全**：在随机预言模型下可证明安全
- **抗伪造攻击**：即使攻击者收集大量签名也难以伪造
- **更强的安全保证**：比传统方案更可靠

### 4.2 PSS签名流程


**📝 签名生成过程**：

```
消息 M
    ↓
1. 计算消息哈希：mHash = Hash(M)
    ↓
2. 生成随机盐：salt（通常20字节）
    ↓
3. 计算：M' = 00000000 || mHash || salt
    ↓
4. 计算：H = Hash(M')
    ↓
5. 生成掩码：mask = MGF(H, emLen-hLen-1)
    ↓
6. 构造：maskedDB = DB ⊕ mask
    ↓
7. 最终签名块：00 || maskedDB || H || BC
```

**🔍 各部分说明**：
- `00000000`：8个零字节的前缀
- `mHash`：原始消息的哈希值
- `salt`：随机盐值，增加不可预测性
- `H`：综合哈希值
- `BC`：边界字节，通常是0xBC

### 4.3 PSS验证流程


**✅ 验证过程**：

```
收到签名后：
1. 检查签名格式是否正确
2. 提取各个组成部分
3. 重新计算掩码，恢复DB
4. 检查填充结构是否正确
5. 提取盐值，重新计算哈希
6. 对比哈希值是否匹配
```

### 4.4 PSS vs 传统签名对比


```
传统PKCS#1 v1.5签名：
消息 → 哈希 → 填充 → 签名
相同消息总是产生相同签名

PSS签名：
消息 → 哈希 → 加盐 → 掩码 → 签名
相同消息每次产生不同签名（但都能验证通过）
```

**实际效果对比**：
- **安全性**：PSS > PKCS#1 v1.5
- **性能**：PSS ≈ PKCS#1 v1.5（差别很小）
- **兼容性**：PKCS#1 v1.5更广泛，PSS是新标准

---

## 5. ⚔️ RSA攻击方法与防护


### 5.1 常见攻击类型


**🎯 针对填充方案的攻击**：

**填充神谕攻击（Padding Oracle Attack）**
```
攻击原理：
1. 攻击者构造恶意密文
2. 观察解密时的错误信息
3. 根据"填充正确"或"填充错误"的反馈
4. 逐步推断出原始明文

举例说明：
银行系统解密时返回不同错误：
- "填充格式错误" vs "权限不足"
- 攻击者利用这种差异逐步破解
```

**时序攻击（Timing Attack）**
```
攻击原理：
不同的填充验证可能耗时不同
攻击者通过测量响应时间推断信息

防护方法：
- 使用常量时间算法
- 无论验证成功失败，都花费相同时间
```

**选择密文攻击（CCA）**
```
攻击场景：
攻击者能够让系统解密他选择的密文
通过分析解密结果推断目标密文

OAEP的优势：
专门设计来抵御这种攻击
```

### 5.2 实施攻击的条件


**🚨 攻击成功需要的条件**：

1. **获得解密神谕**：
   - 能够让系统解密任意密文
   - 能够观察到解密过程的某些信息

2. **信息泄露渠道**：
   - 错误消息不同
   - 响应时间不同  
   - 其他侧信道信息

3. **多次尝试机会**：
   - 攻击通常需要多轮交互
   - 系统允许重复请求

### 5.3 防护策略


**🛡️ 开发者防护措施**：

**统一错误处理**：
```python
# ❌ 错误的做法 - 泄露填充信息
def decrypt(ciphertext):
    try:
        plaintext = rsa_decrypt(ciphertext)
        if not valid_padding(plaintext):
            raise Exception("填充格式错误")
        return extract_message(plaintext)
    except:
        raise Exception("解密失败")

# ✅ 正确的做法 - 统一错误信息
def decrypt(ciphertext):
    try:
        plaintext = rsa_decrypt(ciphertext)
        if not valid_padding(plaintext):
            return None  # 不透露具体错误原因
        return extract_message(plaintext)
    except:
        return None  # 所有错误都返回相同结果
```

**常量时间实现**：
```python
# 确保验证时间恒定
def constant_time_compare(a, b):
    """
    无论比较结果如何，都花费相同时间
    """
    result = 0
    for x, y in zip(a, b):
        result |= x ^ y
    return result == 0
```

**使用推荐方案**：
- **加密**：优先使用OAEP，避免PKCS#1 v1.5
- **签名**：优先使用PSS，提供更强安全性
- **密钥长度**：至少2048位，推荐3072位或4096位

### 5.4 系统级防护


**🏢 部署层面的防护**：

**网络隔离**：
```
客户端 → 防火墙 → 负载均衡 → 应用服务器 → 加密服务
              ↑
         过滤恶意请求
```

**请求限制**：
- 限制每秒解密请求数量
- 检测异常请求模式
- 实施IP黑名单机制

**监控告警**：
- 记录所有解密请求
- 监控失败率异常
- 设置自动告警机制

---

## 6. 🎯 实际应用选择指南


### 6.1 方案选择决策树


```
需要RSA加密/签名？
    ↓
是新系统还是维护旧系统？
    ↓
┌─────────────┬─────────────┐
│   新系统     │   旧系统     │
└─────────────┴─────────────┘
    ↓               ↓
选择OAEP+PSS    评估升级可能性
    ↓               ↓
实施最佳实践     如果无法升级，加强防护
```

### 6.2 不同场景的推荐方案


**🏦 金融支付系统**：
- **加密**：RSA-OAEP，密钥长度4096位
- **签名**：RSA-PSS，配合SHA-256
- **额外要求**：硬件安全模块(HSM)

**🌐 Web应用TLS/SSL**：
- **推荐**：使用椭圆曲线(ECC)替代RSA
- **如果必须用RSA**：OAEP填充，最小2048位密钥
- **性能考虑**：Session复用减少开销

**📧 电子邮件加密**：
- **标准**：S/MIME或PGP
- **填充**：通常使用OAEP
- **兼容性**：考虑接收方支持情况

**📱 移动应用**：
- **性能优先**：考虑ECC代替RSA
- **如果使用RSA**：2048位+OAEP
- **电池优化**：减少频繁加解密操作

### 6.3 迁移策略


**🔄 从旧方案升级的步骤**：

**第一阶段：兼容性支持**
```
系统同时支持：
- 旧格式解密（PKCS#1 v1.5）
- 新格式加密（OAEP）
逐步迁移客户端
```

**第二阶段：全面升级**
```
所有新操作使用OAEP/PSS
保留旧格式支持（只读）
设置迁移截止时间
```

**第三阶段：完全切换**
```
停止支持旧格式
强制使用新标准
更新所有文档和工具
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的关键概念


```
🔸 填充的必要性：RSA裸加密存在严重安全风险
🔸 PKCS#1 v1.5：早期标准，简单但安全性不足
🔸 OAEP填充：现代推荐标准，可证明安全
🔸 PSS签名：概率签名方案，比传统方案更安全
🔸 攻击防护：正确实现比选择算法更重要
```

### 7.2 实际应用要点


**🔹 选择原则**：
```
新项目：
✅ 加密使用RSA-OAEP
✅ 签名使用RSA-PSS  
✅ 密钥长度≥2048位

旧项目：
⚠️ 评估升级可行性
🛡️ 加强现有方案防护
📊 制定迁移计划
```

**🔹 安全实践**：
```
开发层面：
- 统一错误处理
- 常量时间实现
- 输入验证和限制

部署层面：
- 网络安全防护
- 请求频率限制  
- 实时监控告警
```

**🔹 性能考虑**：
```
RSA相对较慢：
- 适合加密短数据（如AES密钥）
- 不适合加密大文件
- 考虑混合加密方案
```

### 7.3 记忆要点


**🧠 核心记忆口诀**：
```
RSA填充很重要，裸用加密不安全
PKCS老标准，OAEP新推荐
PSS签名强，防攻击要做好
错误处理要统一，时间恒定防泄露
```

**🎯 关键数字记忆**：
- **最小密钥长度**：2048位
- **推荐密钥长度**：3072位或4096位
- **OAEP标签**：通常为空（20字节零）
- **PSS盐长度**：通常20字节（与哈希长度相同）

**⚡ 快速判断标准**：
- 看到"v1.5" → 考虑升级
- 看到"OAEP" → 现代安全标准  
- 看到"PSS" → 推荐签名方案
- 看到"裸RSA" → 立即替换