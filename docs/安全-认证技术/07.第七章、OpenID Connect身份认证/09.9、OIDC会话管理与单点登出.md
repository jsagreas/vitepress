---
title: 9ã€OIDCä¼šè¯ç®¡ç†ä¸å•ç‚¹ç™»å‡º
---
## ğŸ“š ç›®å½•

1. [OIDCä¼šè¯æ¦‚å¿µä¸ç‰¹ç‚¹](#1-OIDCä¼šè¯æ¦‚å¿µä¸ç‰¹ç‚¹)
2. [Session Managementè§„èŒƒ](#2-Session-Managementè§„èŒƒ)
3. [ä¼šè¯çŠ¶æ€ç›‘æ§æœºåˆ¶](#3-ä¼šè¯çŠ¶æ€ç›‘æ§æœºåˆ¶)
4. [RP-Initiated Logoutæ ‡å‡†æµç¨‹](#4-RP-Initiated-Logoutæ ‡å‡†æµç¨‹)
5. [Back-Channel Logoutæœºåˆ¶](#5-Back-Channel-Logoutæœºåˆ¶)
6. [Front-Channel Logoutå®ç°](#6-Front-Channel-Logoutå®ç°)
7. [è·¨åŸŸä¼šè¯åŒæ­¥æ–¹æ¡ˆ](#7-è·¨åŸŸä¼šè¯åŒæ­¥æ–¹æ¡ˆ)
8. [å•ç‚¹ç™»å‡ºåœ¨å¤šåº”ç”¨ä¸­çš„å¤„ç†](#8-å•ç‚¹ç™»å‡ºåœ¨å¤šåº”ç”¨ä¸­çš„å¤„ç†)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ¯ OIDCä¼šè¯æ¦‚å¿µä¸ç‰¹ç‚¹


### 1.1 OIDCä¼šè¯æ˜¯ä»€ä¹ˆ


**ç®€å•ç†è§£**ï¼šå°±åƒä½ åœ¨é“¶è¡ŒåŠä¸šåŠ¡æ—¶æ‹¿åˆ°çš„å·ç ç‰Œï¼Œè®©é“¶è¡ŒçŸ¥é“ä½ æ˜¯è°ã€ä½ åœ¨è¿™é‡ŒåŠä»€ä¹ˆäº‹ã€åŠäº†å¤šä¹…äº†ã€‚

```
ä¼ ç»Ÿç™»å½•ï¼š
ç”¨æˆ· â†’ ç½‘ç«™ â†’ éªŒè¯ç”¨æˆ·åå¯†ç  â†’ åˆ›å»ºä¼šè¯ â†’ è®¿é—®èµ„æº

OIDCä¼šè¯ï¼š
ç”¨æˆ· â†’ åº”ç”¨ â†’ è·³è½¬åˆ°è®¤è¯æœåŠ¡å™¨ â†’ ç™»å½•æˆåŠŸ â†’ è¿”å›ä»¤ç‰Œ â†’ å»ºç«‹ä¼šè¯
     â†“
åŒæ—¶ç®¡ç†ï¼šè®¤è¯æœåŠ¡å™¨ä¼šè¯ + åº”ç”¨ä¼šè¯
```

**ğŸ”¸ OIDCä¼šè¯çš„ä¸‰ä¸ªå±‚æ¬¡**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è®¤è¯æœåŠ¡å™¨     â”‚ â† èº«ä»½æä¾›è€…(OP)çš„ä¼šè¯
â”‚     ä¼šè¯        â”‚   ç®¡ç†ç”¨æˆ·çš„ç™»å½•çŠ¶æ€
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨ä¼šè¯      â”‚ â† å®¢æˆ·ç«¯åº”ç”¨çš„ä¼šè¯
â”‚  (RP Session)   â”‚   ç®¡ç†ç”¨æˆ·åœ¨åº”ç”¨ä¸­çš„çŠ¶æ€
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æµè§ˆå™¨ä¼šè¯     â”‚ â† æµè§ˆå™¨ç«¯çš„ä¼šè¯çŠ¶æ€
â”‚                 â”‚   Cookieã€localStorageç­‰
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 OIDCä¼šè¯ç‰¹ç‚¹


**ğŸ”¹ å¤šå±‚ä¼šè¯ç®¡ç†**
```
é—®é¢˜ï¼šç”¨æˆ·åŒæ—¶åœ¨å¤šä¸ªåº”ç”¨ä¸­ç™»å½•
- é‚®ç®±åº”ç”¨ï¼šå·²ç™»å½•
- æ–‡æ¡£åº”ç”¨ï¼šå·²ç™»å½•  
- èŠå¤©åº”ç”¨ï¼šå·²ç™»å½•
- è®¤è¯æœåŠ¡å™¨ï¼šç®¡ç†æ‰€æœ‰è¿™äº›ä¼šè¯

æŒ‘æˆ˜ï¼šå½“ç”¨æˆ·åœ¨è®¤è¯æœåŠ¡å™¨é€€å‡ºæ—¶ï¼Œå¦‚ä½•é€šçŸ¥æ‰€æœ‰åº”ç”¨ï¼Ÿ
```

**ğŸ”¹ è·¨åŸŸä¼šè¯åè°ƒ**
```
åœºæ™¯ï¼šä¼ä¸šå†…éƒ¨ç³»ç»Ÿ
- mail.company.com   â† é‚®ä»¶ç³»ç»Ÿ
- docs.company.com   â† æ–‡æ¡£ç³»ç»Ÿ
- chat.company.com   â† èŠå¤©ç³»ç»Ÿ
- auth.company.com   â† è®¤è¯æœåŠ¡å™¨

éœ€è¦ï¼šæ‰€æœ‰ç³»ç»Ÿçš„ç™»å½•çŠ¶æ€ä¿æŒä¸€è‡´
```

**ğŸ”¹ å®‰å…¨æ€§è¦æ±‚**
- âœ… **ä¼šè¯åŠ«æŒé˜²æŠ¤**ï¼šé˜²æ­¢ä¼šè¯è¢«æ¶æ„ç›—ç”¨
- âœ… **åŠæ—¶å¤±æ•ˆ**ï¼šç”¨æˆ·é€€å‡ºåç«‹å³æ¸…ç†æ‰€æœ‰ä¼šè¯
- âœ… **çŠ¶æ€åŒæ­¥**ï¼šå„åº”ç”¨é—´ä¼šè¯çŠ¶æ€ä¿æŒä¸€è‡´

---

## 2. ğŸ“‹ Session Managementè§„èŒƒ


### 2.1 ä»€ä¹ˆæ˜¯Session Management


**é€šä¿—è§£é‡Š**ï¼šå°±åƒé…’åº—çš„æˆ¿å¡ç®¡ç†ç³»ç»Ÿï¼Œéœ€è¦çŸ¥é“å®¢äººä»€ä¹ˆæ—¶å€™å…¥ä½ã€ä»€ä¹ˆæ—¶å€™é€€æˆ¿ã€æˆ¿å¡æ˜¯å¦è¿˜æœ‰æ•ˆã€‚

**ğŸ”¸ æ ¸å¿ƒæ¦‚å¿µ**

| æ¦‚å¿µ | è¯´æ˜ | ç±»æ¯” |
|------|------|------|
| **Session State** | ä¼šè¯çŠ¶æ€ | æˆ¿å¡æ˜¯å¦æœ‰æ•ˆ |
| **Session Monitoring** | ä¼šè¯ç›‘æ§ | å®šæœŸæ£€æŸ¥æˆ¿å¡çŠ¶æ€ |
| **Session Termination** | ä¼šè¯ç»ˆæ­¢ | å®¢äººé€€æˆ¿ï¼Œæˆ¿å¡å¤±æ•ˆ |

### 2.2 Session Managementè§„èŒƒå†…å®¹


**ğŸ”¹ ä¼šè¯çŠ¶æ€å®šä¹‰**
```javascript
// ä¼šè¯çŠ¶æ€ç¤ºä¾‹
const sessionState = {
  sub: "user123",                    // ç”¨æˆ·ID
  iss: "https://auth.example.com",   // è®¤è¯æœåŠ¡å™¨
  aud: "myapp",                      // ç›®æ ‡åº”ç”¨
  sid: "session_abc123",             // ä¼šè¯ID
  exp: 1640995200,                   // è¿‡æœŸæ—¶é—´
  iat: 1640991600                    // ç­¾å‘æ—¶é—´
}
```

**ğŸ”¹ ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†**
```
ä¼šè¯åˆ›å»º â†’ ä¼šè¯ç»´æŠ¤ â†’ ä¼šè¯æ£€æŸ¥ â†’ ä¼šè¯ç»ˆæ­¢

1. åˆ›å»ºï¼šç”¨æˆ·ç™»å½•æˆåŠŸæ—¶
2. ç»´æŠ¤ï¼šå®šæœŸåˆ·æ–°ä¼šè¯çŠ¶æ€
3. æ£€æŸ¥ï¼šéªŒè¯ä¼šè¯æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
4. ç»ˆæ­¢ï¼šç”¨æˆ·ä¸»åŠ¨ç™»å‡ºæˆ–è¶…æ—¶
```

### 2.3 è§„èŒƒè¦æ±‚çš„ç«¯ç‚¹


**ğŸ”¸ å¿…éœ€çš„ç«¯ç‚¹**

```
check_session_iframeç«¯ç‚¹ï¼š
https://auth.example.com/connect/checksession

ä½œç”¨ï¼šæä¾›ä¸€ä¸ªiframeé¡µé¢ï¼Œç”¨äºæ£€æŸ¥ä¼šè¯çŠ¶æ€
```

**å®ç°ç¤ºä¾‹**ï¼š
```html
<!-- check_session_iframe é¡µé¢å†…å®¹ -->
<!DOCTYPE html>
<html>
<head>
    <title>Session Check</title>
</head>
<body>
    <script>
        // ç›‘å¬æ¥è‡ªçˆ¶çª—å£çš„æ¶ˆæ¯
        window.addEventListener('message', function(e) {
            if (e.data === 'get_session_state') {
                // æ£€æŸ¥å½“å‰ä¼šè¯çŠ¶æ€
                const sessionState = checkCurrentSession();
                e.source.postMessage(sessionState, e.origin);
            }
        });
        
        function checkCurrentSession() {
            // æ£€æŸ¥ä¼šè¯æ˜¯å¦æœ‰æ•ˆçš„é€»è¾‘
            if (isSessionValid()) {
                return 'unchanged';  // ä¼šè¯æœªå˜åŒ–
            } else {
                return 'changed';    // ä¼šè¯å·²å˜åŒ–
            }
        }
    </script>
</body>
</html>
```

---

## 3. ğŸ“Š ä¼šè¯çŠ¶æ€ç›‘æ§æœºåˆ¶


### 3.1 ä¸ºä»€ä¹ˆéœ€è¦ç›‘æ§


**å®é™…åœºæ™¯**ï¼š
```
ç”¨æˆ·å°æ˜ï¼š
9:00  åœ¨Aåº”ç”¨ä¸­ç™»å½•
9:30  åœ¨Båº”ç”¨ä¸­ç™»å½•  
10:00 åœ¨è®¤è¯æœåŠ¡å™¨ç›´æ¥é€€å‡ºç™»å½•

é—®é¢˜ï¼šAåº”ç”¨å’ŒBåº”ç”¨å¦‚ä½•çŸ¥é“ç”¨æˆ·å·²ç»é€€å‡ºï¼Ÿ
```

**ğŸ”¸ ä¸ç›‘æ§çš„åæœ**
- âŒ ç”¨æˆ·å·²é€€å‡ºï¼Œä½†åº”ç”¨ä»æ˜¾ç¤ºç™»å½•çŠ¶æ€
- âŒ å®‰å…¨é£é™©ï¼šä»–äººå¯èƒ½è®¿é—®ç”¨æˆ·æ•°æ®
- âŒ ç”¨æˆ·ä½“éªŒå·®ï¼šçŠ¶æ€ä¸ä¸€è‡´ï¼Œç”¨æˆ·å›°æƒ‘

### 3.2 ç›‘æ§æœºåˆ¶å®ç°


**ğŸ”¹ è½®è¯¢æ£€æŸ¥æ–¹å¼**

```javascript
// åœ¨å®¢æˆ·ç«¯åº”ç”¨ä¸­å®ç°
class SessionMonitor {
    constructor(checkSessionEndpoint) {
        this.iframe = null;
        this.checkSessionEndpoint = checkSessionEndpoint;
        this.sessionState = null;
        this.checkInterval = null;
    }
    
    // å¼€å§‹ç›‘æ§ä¼šè¯
    startMonitoring() {
        // åˆ›å»ºéšè—çš„iframe
        this.createCheckIframe();
        
        // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡ä¼šè¯çŠ¶æ€
        this.checkInterval = setInterval(() => {
            this.checkSessionState();
        }, 30000);
    }
    
    createCheckIframe() {
        this.iframe = document.createElement('iframe');
        this.iframe.src = this.checkSessionEndpoint;
        this.iframe.style.display = 'none';
        document.body.appendChild(this.iframe);
        
        // ç›‘å¬iframeçš„å“åº”
        window.addEventListener('message', (e) => {
            this.handleSessionStateResponse(e.data);
        });
    }
    
    checkSessionState() {
        // å‘iframeå‘é€æ£€æŸ¥è¯·æ±‚
        this.iframe.contentWindow.postMessage('get_session_state', '*');
    }
    
    handleSessionStateResponse(state) {
        if (state === 'changed' || state === 'error') {
            // ä¼šè¯çŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œéœ€è¦å¤„ç†
            this.handleSessionChange();
        }
        // å¦‚æœæ˜¯'unchanged'ï¼Œç»§ç»­æ­£å¸¸å·¥ä½œ
    }
    
    handleSessionChange() {
        // ä¼šè¯å·²å¤±æ•ˆï¼Œæ¸…ç†æœ¬åœ°çŠ¶æ€
        localStorage.removeItem('access_token');
        localStorage.removeItem('id_token');
        
        // é‡å®šå‘åˆ°ç™»å½•é¡µé¢
        window.location.href = '/login';
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new SessionMonitor('https://auth.example.com/connect/checksession');
monitor.startMonitoring();
```

**ğŸ”¹ äº‹ä»¶é©±åŠ¨æ–¹å¼**

```javascript
// ä½¿ç”¨Broadcast Channel APIè¿›è¡Œå®æ—¶é€šä¿¡
class RealTimeSessionMonitor {
    constructor() {
        this.channel = new BroadcastChannel('session_channel');
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // ç›‘å¬ä¼šè¯å˜åŒ–äº‹ä»¶
        this.channel.addEventListener('message', (event) => {
            if (event.data.type === 'session_ended') {
                this.handleSessionEnd();
            }
        });
        
        // ç›‘å¬å­˜å‚¨å˜åŒ–ï¼ˆç”¨äºè·¨æ ‡ç­¾é¡µé€šä¿¡ï¼‰
        window.addEventListener('storage', (e) => {
            if (e.key === 'session_status' && e.newValue === 'ended') {
                this.handleSessionEnd();
            }
        });
    }
    
    handleSessionEnd() {
        alert('æ‚¨çš„ç™»å½•ä¼šè¯å·²ç»“æŸï¼Œè¯·é‡æ–°ç™»å½•');
        window.location.href = '/login';
    }
}
```

---

## 4. ğŸšª RP-Initiated Logoutæ ‡å‡†æµç¨‹


### 4.1 ä»€ä¹ˆæ˜¯RP-Initiated Logout


**é€šä¿—ç†è§£**ï¼šå°±æ˜¯ç”¨æˆ·åœ¨æŸä¸ªåº”ç”¨ä¸­ç‚¹å‡»"é€€å‡ºç™»å½•"ï¼Œç„¶åè¿™ä¸ªåº”ç”¨é€šçŸ¥è®¤è¯æœåŠ¡å™¨"ç”¨æˆ·è¦é€€å‡ºäº†"ã€‚

```
RP = Relying Party = ä¾èµ–æ–¹ = å®¢æˆ·ç«¯åº”ç”¨

RP-Initiated = ç”±åº”ç”¨å‘èµ·çš„
Logout = ç™»å‡º

å®Œæ•´å«ä¹‰ï¼šç”±å®¢æˆ·ç«¯åº”ç”¨å‘èµ·çš„ç™»å‡ºè¿‡ç¨‹
```

### 4.2 æ ‡å‡†æµç¨‹æ­¥éª¤


**ğŸ”¸ æµç¨‹å›¾ç¤º**
```
ç”¨æˆ·           åº”ç”¨(RP)        è®¤è¯æœåŠ¡å™¨(OP)
 |               |                   |
 |--[1]ç‚¹å‡»é€€å‡º-->|                   |
 |               |--[2]æ„é€ logout_URL->|
 |<--[3]é‡å®šå‘-----|                   |
 |                                   |
 |--[4]è®¿é—®logoutç«¯ç‚¹--------------->|
 |                                   |
 |<--[5]æ˜¾ç¤ºç™»å‡ºç¡®è®¤é¡µé¢---------------|
 |                                   |
 |--[6]ç¡®è®¤ç™»å‡º------------------->|
 |                                   |
 |<--[7]é‡å®šå‘åˆ°post_logout_uri-------|
 |                                   |
 |--[8]è¿”å›åº”ç”¨------------------->|
```

**ğŸ”¹ è¯¦ç»†å®ç°æ­¥éª¤**

**æ­¥éª¤1ï¼šç”¨æˆ·è§¦å‘é€€å‡º**
```javascript
// ç”¨æˆ·ç‚¹å‡»é€€å‡ºæŒ‰é’®
function handleLogout() {
    // æ„é€ é€€å‡ºURL
    const logoutUrl = buildLogoutUrl();
    
    // é‡å®šå‘åˆ°è®¤è¯æœåŠ¡å™¨çš„é€€å‡ºç«¯ç‚¹
    window.location.href = logoutUrl;
}
```

**æ­¥éª¤2ï¼šæ„é€ logout URL**
```javascript
function buildLogoutUrl() {
    const baseUrl = 'https://auth.example.com/connect/endsession';
    const params = new URLSearchParams({
        'id_token_hint': getIdToken(),           // å½“å‰ç”¨æˆ·çš„IDä»¤ç‰Œ
        'post_logout_redirect_uri': 'https://myapp.com/logout-callback',  // é€€å‡ºåå›è·³åœ°å€
        'state': generateRandomState()           // çŠ¶æ€å‚æ•°ï¼Œé˜²æ­¢CSRF
    });
    
    return `${baseUrl}?${params.toString()}`;
}

// è¾…åŠ©å‡½æ•°
function getIdToken() {
    return localStorage.getItem('id_token');
}

function generateRandomState() {
    return Math.random().toString(36).substring(2, 15);
}
```

**æ­¥éª¤3-6ï¼šè®¤è¯æœåŠ¡å™¨å¤„ç†**
```javascript
// è®¤è¯æœåŠ¡å™¨çš„é€€å‡ºç«¯ç‚¹é€»è¾‘ï¼ˆä¼ªä»£ç ï¼‰
app.get('/connect/endsession', (req, res) => {
    const { id_token_hint, post_logout_redirect_uri, state } = req.query;
    
    // éªŒè¯IDä»¤ç‰Œ
    if (isValidIdToken(id_token_hint)) {
        // æ¸…ç†æœåŠ¡å™¨ç«¯ä¼šè¯
        clearServerSession(req.session.user_id);
        
        // æ˜¾ç¤ºé€€å‡ºç¡®è®¤é¡µé¢
        res.render('logout-confirm', {
            post_logout_redirect_uri,
            state
        });
    } else {
        res.status(400).send('Invalid request');
    }
});

// ç”¨æˆ·ç¡®è®¤é€€å‡ºåçš„å¤„ç†
app.post('/connect/logout-confirm', (req, res) => {
    const { post_logout_redirect_uri, state } = req.body;
    
    // æ¸…ç†æ‰€æœ‰ç›¸å…³ä¼šè¯
    cleanupAllSessions();
    
    // é‡å®šå‘å›åº”ç”¨
    const redirectUrl = `${post_logout_redirect_uri}?state=${state}`;
    res.redirect(redirectUrl);
});
```

**æ­¥éª¤7-8ï¼šè¿”å›åº”ç”¨å¤„ç†**
```javascript
// åº”ç”¨çš„é€€å‡ºå›è°ƒå¤„ç†
app.get('/logout-callback', (req, res) => {
    const { state } = req.query;
    
    // éªŒè¯stateå‚æ•°
    if (isValidState(state)) {
        // æ¸…ç†åº”ç”¨æœ¬åœ°çŠ¶æ€
        clearLocalSession();
        
        // æ˜¾ç¤ºé€€å‡ºæˆåŠŸé¡µé¢
        res.render('logout-success', {
            message: 'æ‚¨å·²æˆåŠŸé€€å‡ºç™»å½•'
        });
    } else {
        res.status(400).send('Invalid logout callback');
    }
});

function clearLocalSession() {
    // æ¸…ç†æœ¬åœ°å­˜å‚¨
    // æ³¨æ„ï¼šè¿™é‡Œæ˜¯æœåŠ¡å™¨ç«¯ï¼Œå¦‚æœéœ€è¦æ¸…ç†å®¢æˆ·ç«¯å­˜å‚¨ï¼Œ
    // éœ€è¦åœ¨å‰ç«¯é¡µé¢ä¸­æ‰§è¡Œ
}
```

### 4.3 å‰ç«¯å®Œæ•´ç¤ºä¾‹


```html
<!DOCTYPE html>
<html>
<head>
    <title>åº”ç”¨ç™»å‡ºç¤ºä¾‹</title>
</head>
<body>
    <div id="user-info">
        <p>æ¬¢è¿ï¼Œç”¨æˆ·ï¼</p>
        <button onclick="logout()">é€€å‡ºç™»å½•</button>
    </div>
    
    <script>
        function logout() {
            // æ¸…ç†æœ¬åœ°å­˜å‚¨çš„ä»¤ç‰Œ
            localStorage.removeItem('access_token');
            localStorage.removeItem('id_token');
            localStorage.removeItem('refresh_token');
            
            // æ„é€ é€€å‡ºURL
            const logoutUrl = buildLogoutUrl();
            
            // é€šçŸ¥å…¶ä»–æ ‡ç­¾é¡µç”¨æˆ·å·²é€€å‡º
            broadcastLogout();
            
            // é‡å®šå‘åˆ°è®¤è¯æœåŠ¡å™¨é€€å‡º
            window.location.href = logoutUrl;
        }
        
        function buildLogoutUrl() {
            const config = {
                issuer: 'https://auth.example.com',
                clientId: 'my-app-client',
                redirectUri: 'https://myapp.com/logout-callback'
            };
            
            const params = new URLSearchParams({
                id_token_hint: localStorage.getItem('id_token') || '',
                post_logout_redirect_uri: config.redirectUri,
                state: Date.now().toString() // ç®€å•çš„çŠ¶æ€å€¼
            });
            
            return `${config.issuer}/connect/endsession?${params}`;
        }
        
        function broadcastLogout() {
            // ä½¿ç”¨localStorageäº‹ä»¶é€šçŸ¥å…¶ä»–æ ‡ç­¾é¡µ
            localStorage.setItem('logout_event', Date.now().toString());
            localStorage.removeItem('logout_event');
            
            // ä½¿ç”¨BroadcastChannelï¼ˆç°ä»£æµè§ˆå™¨ï¼‰
            if ('BroadcastChannel' in window) {
                const channel = new BroadcastChannel('auth_channel');
                channel.postMessage({ type: 'logout' });
                channel.close();
            }
        }
        
        // ç›‘å¬å…¶ä»–æ ‡ç­¾é¡µçš„é€€å‡ºäº‹ä»¶
        window.addEventListener('storage', (e) => {
            if (e.key === 'logout_event') {
                // å…¶ä»–æ ‡ç­¾é¡µç”¨æˆ·é€€å‡ºï¼Œå½“å‰é¡µé¢ä¹Ÿéœ€è¦é€€å‡º
                window.location.reload();
            }
        });
    </script>
</body>
</html>
```

---

## 5. ğŸ”„ Back-Channel Logoutæœºåˆ¶


### 5.1 ä»€ä¹ˆæ˜¯Back-Channel Logout


**é€šä¿—ç†è§£**ï¼šå°±åƒé…’åº—çš„å†…éƒ¨é€šçŸ¥ç³»ç»Ÿï¼Œå½“å®¢äººåœ¨å‰å°åŠç†é€€æˆ¿æ—¶ï¼Œå‰å°ä¼šé€šè¿‡å†…éƒ¨ç”µè¯ç›´æ¥é€šçŸ¥å®¢æˆ¿æœåŠ¡ã€é¤å…ç­‰å„ä¸ªéƒ¨é—¨ã€‚

```
Back-Channel = åç«¯é€šé“ = æœåŠ¡å™¨åˆ°æœåŠ¡å™¨çš„ç›´æ¥é€šä¿¡
Front-Channel = å‰ç«¯é€šé“ = é€šè¿‡ç”¨æˆ·æµè§ˆå™¨çš„é€šä¿¡

åŒºåˆ«ï¼š
Front-Channelï¼šè®¤è¯æœåŠ¡å™¨ â†’ ç”¨æˆ·æµè§ˆå™¨ â†’ åº”ç”¨æœåŠ¡å™¨
Back-Channelï¼šè®¤è¯æœåŠ¡å™¨ â†’ ç›´æ¥HTTPè¯·æ±‚ â†’ åº”ç”¨æœåŠ¡å™¨
```

### 5.2 Back-Channel Logoutçš„ä¼˜åŠ¿


**ğŸ”¸ å¯¹æ¯”åˆ†æ**

| ç‰¹æ€§ | Front-Channel | Back-Channel |
|------|---------------|--------------|
| **å¯é æ€§** | ä¾èµ–ç”¨æˆ·æµè§ˆå™¨ | æœåŠ¡å™¨ç›´æ¥é€šä¿¡ |
| **å®æ—¶æ€§** | éœ€è¦ç”¨æˆ·è®¿é—® | ç«‹å³é€šçŸ¥ |
| **å®‰å…¨æ€§** | å¯èƒ½è¢«ç”¨æˆ·ä¸­æ–­ | ä¸ç»è¿‡å®¢æˆ·ç«¯ |
| **å¤æ‚åº¦** | ç›¸å¯¹ç®€å• | éœ€è¦é¢å¤–ç«¯ç‚¹ |

**ğŸ”¹ é€‚ç”¨åœºæ™¯**
```
âœ… ä¼ä¸šçº§åº”ç”¨ï¼šéœ€è¦ä¸¥æ ¼çš„å®‰å…¨æ§åˆ¶
âœ… é‡‘èç³»ç»Ÿï¼šè¦æ±‚ç«‹å³æ¸…ç†ä¼šè¯
âœ… å¤šåº”ç”¨ç¯å¢ƒï¼šéœ€è¦åŒæ­¥ç™»å‡ºæ‰€æœ‰åº”ç”¨
âœ… ç§»åŠ¨åº”ç”¨ï¼šä¸ä¾èµ–æµè§ˆå™¨è¡Œä¸º
```

### 5.3 å®ç°æœºåˆ¶


**ğŸ”¸ æ³¨å†Œlogoutç«¯ç‚¹**

```javascript
// åº”ç”¨éœ€è¦æä¾›ä¸€ä¸ªé€€å‡ºé€šçŸ¥ç«¯ç‚¹
app.post('/backchannel-logout', express.json(), (req, res) => {
    try {
        const logoutToken = req.body.logout_token;
        
        // éªŒè¯logout token
        const payload = verifyLogoutToken(logoutToken);
        
        if (payload) {
            // å¤„ç†ç”¨æˆ·ç™»å‡º
            handleUserLogout(payload.sub, payload.sid);
            res.status(200).send('OK');
        } else {
            res.status(400).send('Invalid logout token');
        }
    } catch (error) {
        console.error('Logout error:', error);
        res.status(500).send('Internal error');
    }
});

function verifyLogoutToken(token) {
    // éªŒè¯JWTæ ¼å¼å’Œç­¾å
    try {
        const decoded = jwt.verify(token, getPublicKey(), {
            issuer: 'https://auth.example.com',
            audience: 'my-app-client'
        });
        
        // Back-channel logout tokençš„ç‰¹æ®Šè¦æ±‚
        if (decoded.nonce) {
            throw new Error('Logout token must not contain nonce');
        }
        
        if (!decoded.events || !decoded.events['http://schemas.openid.net/secevent/risc/event-type/sessions#logout']) {
            throw new Error('Invalid logout event');
        }
        
        return decoded;
    } catch (error) {
        console.error('Token verification failed:', error);
        return null;
    }
}

function handleUserLogout(userId, sessionId) {
    // æ¸…ç†ç”¨æˆ·ä¼šè¯
    sessionStore.destroy(sessionId);
    
    // æ¸…ç†ç”¨æˆ·ç›¸å…³çš„ç¼“å­˜
    cache.delete(`user_${userId}`);
    
    // è®°å½•ç™»å‡ºæ—¥å¿—
    logger.info(`User ${userId} logged out via back-channel`);
    
    // é€šçŸ¥åº”ç”¨å†…éƒ¨å…¶ä»–æœåŠ¡
    notifyInternalServices(userId, 'logout');
}
```

**ğŸ”¸ è®¤è¯æœåŠ¡å™¨ç«¯å®ç°**

```javascript
// è®¤è¯æœåŠ¡å™¨åœ¨ç”¨æˆ·é€€å‡ºæ—¶çš„å¤„ç†
async function processUserLogout(userId, sessionId) {
    try {
        // è·å–è¯¥ç”¨æˆ·çš„æ‰€æœ‰å·²æ³¨å†Œåº”ç”¨
        const registeredApps = await getRegisteredApps(userId);
        
        // ä¸ºæ¯ä¸ªåº”ç”¨å‘é€back-channel logouté€šçŸ¥
        const logoutPromises = registeredApps.map(app => 
            sendBackChannelLogout(app, userId, sessionId)
        );
        
        // å¹¶è¡Œå‘é€æ‰€æœ‰é€šçŸ¥
        await Promise.allSettled(logoutPromises);
        
        // æ¸…ç†è®¤è¯æœåŠ¡å™¨çš„ä¼šè¯
        await clearAuthServerSession(userId, sessionId);
        
    } catch (error) {
        console.error('Logout process failed:', error);
    }
}

async function sendBackChannelLogout(app, userId, sessionId) {
    try {
        // åˆ›å»ºlogout token
        const logoutToken = createLogoutToken(userId, sessionId, app.clientId);
        
        // å‘é€HTTP POSTè¯·æ±‚åˆ°åº”ç”¨çš„logoutç«¯ç‚¹
        const response = await fetch(app.backChannelLogoutUri, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: `logout_token=${logoutToken}`,
            timeout: 5000 // 5ç§’è¶…æ—¶
        });
        
        if (!response.ok) {
            throw new Error(`Logout notification failed: ${response.status}`);
        }
        
        console.log(`Logout notification sent to ${app.name}`);
        
    } catch (error) {
        console.error(`Failed to notify ${app.name}:`, error);
        // è®°å½•å¤±è´¥ï¼Œä½†ä¸å½±å“å…¶ä»–åº”ç”¨çš„é€šçŸ¥
    }
}

function createLogoutToken(userId, sessionId, audience) {
    const payload = {
        iss: 'https://auth.example.com',     // ç­¾å‘è€…
        aud: audience,                        // ç›®æ ‡åº”ç”¨
        sub: userId,                         // ç”¨æˆ·ID
        sid: sessionId,                      // ä¼šè¯ID
        iat: Math.floor(Date.now() / 1000),  // ç­¾å‘æ—¶é—´
        exp: Math.floor(Date.now() / 1000) + 300, // 5åˆ†é’Ÿåè¿‡æœŸ
        jti: generateUniqueId(),             // JWT ID
        events: {
            'http://schemas.openid.net/secevent/risc/event-type/sessions#logout': {}
        }
    };
    
    // æ³¨æ„ï¼šlogout tokenä¸åº”è¯¥åŒ…å«nonceå­—æ®µ
    
    return jwt.sign(payload, getPrivateKey(), { algorithm: 'RS256' });
}
```

### 5.4 é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶


```javascript
class BackChannelLogoutService {
    constructor() {
        this.maxRetries = 3;
        this.retryDelay = 1000; // 1ç§’
    }
    
    async sendLogoutWithRetry(app, userId, sessionId) {
        let attempt = 1;
        
        while (attempt <= this.maxRetries) {
            try {
                await this.sendBackChannelLogout(app, userId, sessionId);
                console.log(`Logout notification succeeded on attempt ${attempt}`);
                return;
                
            } catch (error) {
                console.warn(`Attempt ${attempt} failed:`, error.message);
                
                if (attempt < this.maxRetries) {
                    // æŒ‡æ•°é€€é¿å»¶è¿Ÿ
                    const delay = this.retryDelay * Math.pow(2, attempt - 1);
                    await this.sleep(delay);
                }
                
                attempt++;
            }
        }
        
        // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥ï¼Œè®°å½•é”™è¯¯
        console.error(`Failed to notify ${app.name} after ${this.maxRetries} attempts`);
        
        // å¯ä»¥å°†å¤±è´¥çš„é€šçŸ¥æ”¾å…¥é˜Ÿåˆ—ï¼Œç¨åé‡è¯•
        await this.queueFailedLogout(app, userId, sessionId);
    }
    
    async queueFailedLogout(app, userId, sessionId) {
        // å°†å¤±è´¥çš„ç™»å‡ºé€šçŸ¥åŠ å…¥é‡è¯•é˜Ÿåˆ—
        const task = {
            app,
            userId,
            sessionId,
            timestamp: Date.now(),
            retryCount: 0
        };
        
        await this.addToRetryQueue(task);
    }
    
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

---

## 6. ğŸŒ Front-Channel Logoutå®ç°


### 6.1 Front-Channel Logoutçš„å·¥ä½œåŸç†


**é€šä¿—ç†è§£**ï¼šå°±åƒè€å¸ˆè®©ç­é•¿é€šçŸ¥å„ä¸ªè¯¾ä»£è¡¨"æ”¾å­¦äº†"ï¼Œç­é•¿éœ€è¦ä¸€ä¸ªä¸€ä¸ªå»é€šçŸ¥ï¼Œé€šè¿‡å­¦ç”Ÿä¹‹é—´çš„ä¼ è¯æ¥å®Œæˆã€‚

```
è¿‡ç¨‹ï¼š
1. ç”¨æˆ·åœ¨åº”ç”¨Aä¸­é€€å‡º
2. åº”ç”¨Aé‡å®šå‘åˆ°è®¤è¯æœåŠ¡å™¨
3. è®¤è¯æœåŠ¡å™¨åˆ›å»ºä¸€ä¸ªç‰¹æ®Šé¡µé¢
4. è¿™ä¸ªé¡µé¢åŒ…å«å¤šä¸ªéšè—çš„iframe
5. æ¯ä¸ªiframeæŒ‡å‘å…¶ä»–åº”ç”¨çš„logoutç«¯ç‚¹
6. æµè§ˆå™¨è‡ªåŠ¨åŠ è½½è¿™äº›iframeï¼Œé€šçŸ¥å…¶ä»–åº”ç”¨
```

### 6.2 å®ç°æ­¥éª¤


**ğŸ”¸ è®¤è¯æœåŠ¡å™¨ç«¯å®ç°**

```javascript
// å¤„ç†front-channel logout
app.get('/connect/frontchannel-logout', async (req, res) => {
    const { sid } = req.query; // ä¼šè¯ID
    
    try {
        // è·å–è¯¥ä¼šè¯å…³è”çš„æ‰€æœ‰åº”ç”¨
        const sessionApps = await getSessionApplications(sid);
        
        // ç”Ÿæˆlogouté¡µé¢
        const logoutPage = generateLogoutPage(sessionApps, sid);
        
        res.send(logoutPage);
        
    } catch (error) {
        console.error('Front-channel logout error:', error);
        res.status(500).send('Logout error');
    }
});

function generateLogoutPage(apps, sessionId) {
    // ä¸ºæ¯ä¸ªåº”ç”¨ç”Ÿæˆiframe
    const iframes = apps.map(app => {
        const logoutUrl = `${app.frontChannelLogoutUri}?sid=${sessionId}`;
        return `<iframe src="${logoutUrl}" width="0" height="0" frameborder="0"></iframe>`;
    }).join('\n');
    
    return `
    <!DOCTYPE html>
    <html>
    <head>
        <title>æ­£åœ¨ç™»å‡º...</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                text-align: center; 
                padding: 50px; 
            }
            .spinner {
                border: 4px solid #f3f3f3;
                border-top: 4px solid #3498db;
                border-radius: 50%;
                width: 50px;
                height: 50px;
                animation: spin 2s linear infinite;
                margin: 20px auto;
            }
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>
    <body>
        <h2>æ­£åœ¨é€€å‡ºç™»å½•...</h2>
        <div class="spinner"></div>
        <p>è¯·ç¨å€™ï¼Œæ­£åœ¨æ¸…ç†æ‚¨çš„ç™»å½•çŠ¶æ€</p>
        
        <!-- éšè—çš„iframeï¼Œç”¨äºé€šçŸ¥å„ä¸ªåº”ç”¨ -->
        <div style="display: none;">
            ${iframes}
        </div>
        
        <script>
            let loadedCount = 0;
            const totalApps = ${apps.length};
            
            // ç›‘å¬iframeåŠ è½½å®Œæˆ
            window.addEventListener('message', function(e) {
                if (e.data === 'logout_complete') {
                    loadedCount++;
                    updateProgress();
                }
            });
            
            function updateProgress() {
                const progress = Math.round((loadedCount / totalApps) * 100);
                document.querySelector('p').textContent = 
                    \`æ­£åœ¨æ¸…ç†ç™»å½•çŠ¶æ€... \${progress}%\`;
                
                if (loadedCount >= totalApps) {
                    setTimeout(() => {
                        document.body.innerHTML = 
                            '<h2>âœ… é€€å‡ºæˆåŠŸ</h2><p>æ‚¨å·²æˆåŠŸé€€å‡ºæ‰€æœ‰åº”ç”¨</p>';
                        
                        // 3ç§’åå…³é—­æˆ–é‡å®šå‘
                        setTimeout(() => {
                            window.close();
                        }, 3000);
                    }, 1000);
                }
            }
            
            // è®¾ç½®è¶…æ—¶å¤„ç†
            setTimeout(() => {
                if (loadedCount < totalApps) {
                    document.body.innerHTML = 
                        '<h2>âš ï¸ é€€å‡ºå®Œæˆ</h2><p>éƒ¨åˆ†åº”ç”¨å¯èƒ½æœªå®Œå…¨é€€å‡ºï¼Œå»ºè®®å…³é—­æµè§ˆå™¨</p>';
                }
            }, 10000); // 10ç§’è¶…æ—¶
        </script>
    </body>
    </html>
    `;
}
```

**ğŸ”¸ åº”ç”¨ç«¯Front-Channel Logoutå¤„ç†**

```javascript
// åº”ç”¨çš„front-channel logoutç«¯ç‚¹
app.get('/frontchannel-logout', (req, res) => {
    const { sid, iss } = req.query;
    
    try {
        // éªŒè¯è¯·æ±‚æ¥æº
        if (iss !== 'https://auth.example.com') {
            throw new Error('Invalid issuer');
        }
        
        // æ ¹æ®ä¼šè¯IDæ¸…ç†ç”¨æˆ·ä¼šè¯
        if (sid) {
            clearSessionById(sid);
        }
        
        // è¿”å›ä¸€ä¸ªç®€å•çš„HTMLé¡µé¢ï¼Œé€šçŸ¥çˆ¶é¡µé¢logoutå®Œæˆ
        res.send(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>Logout Complete</title>
        </head>
        <body>
            <script>
                // é€šçŸ¥çˆ¶çª—å£logoutå·²å®Œæˆ
                if (window.parent !== window) {
                    window.parent.postMessage('logout_complete', '*');
                }
                
                // æ¸…ç†æœ¬åœ°å­˜å‚¨ï¼ˆå¦‚æœæ˜¯é€šè¿‡JavaScriptè®¿é—®çš„è¯ï¼‰
                try {
                    localStorage.removeItem('access_token');
                    localStorage.removeItem('id_token');
                    localStorage.removeItem('user_info');
                } catch (e) {
                    // è·¨åŸŸæƒ…å†µä¸‹å¯èƒ½æ— æ³•è®¿é—®localStorage
                    console.log('Cannot access localStorage from iframe');
                }
            </script>
            <p>åº”ç”¨é€€å‡ºå®Œæˆ</p>
        </body>
        </html>
        `);
        
    } catch (error) {
        console.error('Front-channel logout error:', error);
        res.status(400).send('Invalid logout request');
    }
});

function clearSessionById(sessionId) {
    // æ¸…ç†æœåŠ¡å™¨ç«¯ä¼šè¯
    sessionStore.destroy(sessionId);
    
    // æ¸…ç†ç›¸å…³ç¼“å­˜
    cache.delete(`session_${sessionId}`);
    
    // è®°å½•é€€å‡ºæ—¥å¿—
    logger.info(`Session ${sessionId} cleared via front-channel logout`);
}
```

### 6.3 å‰ç«¯åº”ç”¨é›†æˆç¤ºä¾‹


```html
<!DOCTYPE html>
<html>
<head>
    <title>æˆ‘çš„åº”ç”¨</title>
</head>
<body>
    <div id="app">
        <div id="user-section">
            <p>æ¬¢è¿ï¼Œ<span id="username">ç”¨æˆ·</span>ï¼</p>
            <button onclick="initiateLogout()">é€€å‡ºç™»å½•</button>
        </div>
    </div>
    
    <script>
        // æ£€æŸ¥ç”¨æˆ·ç™»å½•çŠ¶æ€
        function checkLoginStatus() {
            const token = localStorage.getItem('access_token');
            if (!token) {
                showLoginButton();
            } else {
                showUserInfo();
            }
        }
        
        // å‘èµ·é€€å‡ºç™»å½•
        function initiateLogout() {
            // æ„é€ front-channel logout URL
            const logoutUrl = buildFrontChannelLogoutUrl();
            
            // åœ¨æ–°çª—å£ä¸­æ‰“å¼€logouté¡µé¢
            const logoutWindow = window.open(
                logoutUrl, 
                'logout', 
                'width=500,height=400,scrollbars=yes,resizable=yes'
            );
            
            // ç›‘å¬logoutå®Œæˆ
            const checkClosed = setInterval(() => {
                if (logoutWindow.closed) {
                    clearInterval(checkClosed);
                    handleLogoutComplete();
                }
            }, 1000);
        }
        
        function buildFrontChannelLogoutUrl() {
            const currentSession = getCurrentSessionId();
            const issuer = 'https://auth.example.com';
            
            return `${issuer}/connect/frontchannel-logout?sid=${currentSession}`;
        }
        
        function handleLogoutComplete() {
            // æ¸…ç†æœ¬åœ°çŠ¶æ€
            localStorage.removeItem('access_token');
            localStorage.removeItem('id_token');
            localStorage.removeItem('user_info');
            
            // æ›´æ–°UI
            showLoginButton();
            
            // æ˜¾ç¤ºé€€å‡ºæˆåŠŸæ¶ˆæ¯
            alert('æ‚¨å·²æˆåŠŸé€€å‡ºç™»å½•ï¼');
        }
        
        // ç›‘å¬æ¥è‡ªå…¶ä»–åº”ç”¨çš„logouté€šçŸ¥
        window.addEventListener('storage', (e) => {
            if (e.key === 'logout_event') {
                // å…¶ä»–æ ‡ç­¾é¡µå‘èµ·äº†é€€å‡ºï¼Œå½“å‰é¡µé¢ä¹Ÿéœ€è¦é€€å‡º
                handleLogoutComplete();
            }
        });
        
        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥ç™»å½•çŠ¶æ€
        window.addEventListener('load', checkLoginStatus);
    </script>
</body>
</html>
```

---

## 7. ğŸ”„ è·¨åŸŸä¼šè¯åŒæ­¥æ–¹æ¡ˆ


### 7.1 è·¨åŸŸä¼šè¯åŒæ­¥çš„æŒ‘æˆ˜


**é—®é¢˜åœºæ™¯**ï¼š
```
ä¼ä¸šå†…éƒ¨ç³»ç»Ÿï¼š
- mail.company.com     â† é‚®ä»¶ç³»ç»Ÿ
- docs.company.com     â† æ–‡æ¡£ç³»ç»Ÿ  
- crm.company.com      â† å®¢æˆ·ç®¡ç†ç³»ç»Ÿ
- auth.company.com     â† è®¤è¯ç³»ç»Ÿ

æŒ‘æˆ˜ï¼š
âŒ ä¸åŒåŸŸåä¹‹é—´æ— æ³•ç›´æ¥å…±äº«Cookie
âŒ localStorageä¸èƒ½è·¨åŸŸè®¿é—®
âŒ ä¼šè¯çŠ¶æ€å˜åŒ–æ— æ³•å®æ—¶åŒæ­¥
```

### 7.2 è§£å†³æ–¹æ¡ˆå¯¹æ¯”


**ğŸ”¸ æ–¹æ¡ˆå¯¹æ¯”è¡¨**

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| **PostMessage** | å®æ—¶é€šä¿¡ï¼Œç®€å• | éœ€è¦çª—å£å¼•ç”¨ | åŒä¸€æµè§ˆå™¨çª—å£ |
| **Broadcast Channel** | ç°ä»£æµè§ˆå™¨åŸç”Ÿæ”¯æŒ | å…¼å®¹æ€§æœ‰é™ | ç°ä»£åº”ç”¨ |
| **SharedWorker** | è·¨æ ‡ç­¾é¡µé€šä¿¡ | å¤æ‚ï¼Œå…¼å®¹æ€§å·® | å¤æ‚åº”ç”¨ |
| **localStorageäº‹ä»¶** | å…¼å®¹æ€§å¥½ | åªèƒ½ä¼ é€’å­—ç¬¦ä¸² | é€šç”¨æ–¹æ¡ˆ |
| **è½®è¯¢æ£€æŸ¥** | ç®€å•å¯é  | å®æ—¶æ€§å·® | ç®€å•åº”ç”¨ |

### 7.3 å®ç°æ–¹æ¡ˆ


**ğŸ”¹ æ–¹æ¡ˆ1ï¼šåŸºäºlocalStorageäº‹ä»¶çš„åŒæ­¥**

```javascript
class CrossDomainSessionSync {
    constructor() {
        this.storageKey = 'session_sync_event';
        this.sessionKey = 'current_session';
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // ç›‘å¬localStorageå˜åŒ–
        window.addEventListener('storage', (e) => {
            if (e.key === this.storageKey) {
                this.handleSyncEvent(e.newValue);
            }
        });
        
        // ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                this.checkSessionStatus();
            }
        });
    }
    
    // å¹¿æ’­ä¼šè¯å˜åŒ–äº‹ä»¶
    broadcastSessionChange(eventType, data) {
        const event = {
            type: eventType,
            data: data,
            timestamp: Date.now(),
            origin: window.location.hostname
        };
        
        // ä½¿ç”¨localStorageäº‹ä»¶æœºåˆ¶å¹¿æ’­
        localStorage.setItem(this.storageKey, JSON.stringify(event));
        localStorage.removeItem(this.storageKey);
        
        // åŒæ—¶ä½¿ç”¨BroadcastChannelï¼ˆå¦‚æœæ”¯æŒï¼‰
        if ('BroadcastChannel' in window) {
            const channel = new BroadcastChannel('session_sync');
            channel.postMessage(event);
            channel.close();
        }
    }
    
    handleSyncEvent(eventData) {
        try {
            const event = JSON.parse(eventData);
            
            switch (event.type) {
                case 'login':
                    this.handleRemoteLogin(event.data);
                    break;
                case 'logout':
                    this.handleRemoteLogout(event.data);
                    break;
                case 'token_refresh':
                    this.handleTokenRefresh(event.data);
                    break;
                case 'session_expired':
                    this.handleSessionExpired(event.data);
                    break;
            }
        } catch (error) {
            console.error('Failed to parse sync event:', error);
        }
    }
    
    handleRemoteLogin(data) {
        // å…¶ä»–åŸŸçš„åº”ç”¨ç™»å½•äº†
        console.log('Remote login detected:', data);
        
        // æ›´æ–°æœ¬åœ°ä¼šè¯çŠ¶æ€
        this.updateLocalSession(data);
        
        // åˆ·æ–°UI
        this.refreshUserInterface();
    }
    
    handleRemoteLogout(data) {
        // å…¶ä»–åŸŸçš„åº”ç”¨é€€å‡ºäº†
        console.log('Remote logout detected:', data);
        
        // æ¸…ç†æœ¬åœ°ä¼šè¯
        this.clearLocalSession();
        
        // é‡å®šå‘åˆ°ç™»å½•é¡µ
        this.redirectToLogin();
    }
    
    updateLocalSession(sessionData) {
        localStorage.setItem('access_token', sessionData.access_token);
        localStorage.setItem('id_token', sessionData.id_token);
        localStorage.setItem('user_info', JSON.stringify(sessionData.user_info));
    }
    
    clearLocalSession() {
        localStorage.removeItem('access_token');
        localStorage.removeItem('id_token');
        localStorage.removeItem('user_info');
    }
    
    // æ£€æŸ¥ä¼šè¯çŠ¶æ€
    checkSessionStatus() {
        const token = localStorage.getItem('access_token');
        if (token && this.isTokenExpired(token)) {
            // ä»¤ç‰Œè¿‡æœŸï¼Œå¹¿æ’­ä¼šè¯è¿‡æœŸäº‹ä»¶
            this.broadcastSessionChange('session_expired', {
                reason: 'token_expired',
                timestamp: Date.now()
            });
        }
    }
    
    isTokenExpired(token) {
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return payload.exp * 1000 < Date.now();
        } catch (error) {
            return true; // è§£æå¤±è´¥è®¤ä¸ºè¿‡æœŸ
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const sessionSync = new CrossDomainSessionSync();

// å½“ç”¨æˆ·ç™»å½•æ—¶
function onUserLogin(tokenData) {
    sessionSync.broadcastSessionChange('login', tokenData);
}

// å½“ç”¨æˆ·é€€å‡ºæ—¶
function onUserLogout() {
    sessionSync.broadcastSessionChange('logout', {
        reason: 'user_initiated',
        timestamp: Date.now()
    });
}
```

**ğŸ”¹ æ–¹æ¡ˆ2ï¼šåŸºäºiframeçš„è·¨åŸŸé€šä¿¡**

```javascript
class IframeCrossDomainSync {
    constructor(authDomain) {
        this.authDomain = authDomain;
        this.iframe = null;
        this.isReady = false;
        this.messageQueue = [];
        
        this.setupIframe();
    }
    
    setupIframe() {
        // åˆ›å»ºéšè—çš„iframeï¼ŒæŒ‡å‘è®¤è¯åŸŸ
        this.iframe = document.createElement('iframe');
        this.iframe.src = `${this.authDomain}/session-sync.html`;
        this.iframe.style.display = 'none';
        document.body.appendChild(this.iframe);
        
        // ç›‘å¬æ¥è‡ªiframeçš„æ¶ˆæ¯
        window.addEventListener('message', (e) => {
            if (e.origin !== this.authDomain) return;
            
            this.handleIframeMessage(e.data);
        });
        
        // iframeåŠ è½½å®Œæˆåå‘é€å‡†å¤‡æ¶ˆæ¯
        this.iframe.onload = () => {
            this.postMessageToIframe({ type: 'ready' });
        };
    }
    
    postMessageToIframe(message) {
        if (this.iframe && this.iframe.contentWindow) {
            this.iframe.contentWindow.postMessage(message, this.authDomain);
        }
    }
    
    handleIframeMessage(message) {
        switch (message.type) {
            case 'ready_ack':
                this.isReady = true;
                this.processMessageQueue();
                break;
                
            case 'session_changed':
                this.handleSessionChange(message.data);
                break;
                
            case 'logout_notification':
                this.handleLogoutNotification(message.data);
                break;
        }
    }
    
    processMessageQueue() {
        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            this.postMessageToIframe(message);
        }
    }
    
    // é€šçŸ¥è®¤è¯åŸŸä¼šè¯å˜åŒ–
    notifySessionChange(eventType, data) {
        const message = {
            type: 'session_event',
            eventType: eventType,
            data: data,
            timestamp: Date.now()
        };
        
        if (this.isReady) {
            this.postMessageToIframe(message);
        } else {
            this.messageQueue.push(message);
        }
    }
    
    handleSessionChange(data) {
        // å¤„ç†æ¥è‡ªè®¤è¯åŸŸçš„ä¼šè¯å˜åŒ–é€šçŸ¥
        console.log('Session change from auth domain:', data);
        
        if (data.eventType === 'logout') {
            this.clearLocalSession();
            window.location.href = '/login';
        } else if (data.eventType === 'login') {
            this.updateLocalSession(data.sessionData);
            this.refreshPage();
        }
    }
}

// è®¤è¯åŸŸçš„session-sync.htmlé¡µé¢
const sessionSyncIframePage = `
<!DOCTYPE html>
<html>
<head>
    <title>Session Sync</title>
</head>
<body>
    <script>
        class SessionSyncManager {
            constructor() {
                this.connectedApps = new Set();
                this.setupMessageListener();
            }
            
            setupMessageListener() {
                window.addEventListener('message', (e) => {
                    this.handleMessage(e);
                });
            }
            
            handleMessage(e) {
                const { type, eventType, data } = e.data;
                
                switch (type) {
                    case 'ready':
                        this.handleAppReady(e.source, e.origin);
                        break;
                        
                    case 'session_event':
                        this.broadcastSessionEvent(eventType, data, e.origin);
                        break;
                }
            }
            
            handleAppReady(source, origin) {
                // è®°å½•è¿æ¥çš„åº”ç”¨
                this.connectedApps.add({ source, origin });
                
                // å‘é€ç¡®è®¤æ¶ˆæ¯
                source.postMessage({ type: 'ready_ack' }, origin);
                
                // å‘é€å½“å‰ä¼šè¯çŠ¶æ€
                const currentSession = this.getCurrentSession();
                if (currentSession) {
                    source.postMessage({
                        type: 'session_changed',
                        data: {
                            eventType: 'sync',
                            sessionData: currentSession
                        }
                    }, origin);
                }
            }
            
            broadcastSessionEvent(eventType, data, excludeOrigin) {
                // å‘æ‰€æœ‰è¿æ¥çš„åº”ç”¨å¹¿æ’­äº‹ä»¶
                this.connectedApps.forEach(app => {
                    if (app.origin !== excludeOrigin) {
                        app.source.postMessage({
                            type: 'session_changed',
                            data: { eventType, data }
                        }, app.origin);
                    }
                });
            }
            
            getCurrentSession() {
                // ä»è®¤è¯åŸŸè·å–å½“å‰ä¼šè¯ä¿¡æ¯
                const token = localStorage.getItem('access_token');
                const userInfo = localStorage.getItem('user_info');
                
                if (token && userInfo) {
                    return {
                        access_token: token,
                        user_info: JSON.parse(userInfo)
                    };
                }
                
                return null;
            }
        }
        
        new SessionSyncManager();
    </script>
</body>
</html>
`;
```

**ğŸ”¹ æ–¹æ¡ˆ3ï¼šåŸºäºWebSocketçš„å®æ—¶åŒæ­¥**

```javascript
class WebSocketSessionSync {
    constructor(wsEndpoint) {
        this.wsEndpoint = wsEndpoint;
        this.ws = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        
        this.connect();
    }
    
    connect() {
        try {
            this.ws = new WebSocket(this.wsEndpoint);
            
            this.ws.onopen = () => {
                console.log('Session sync WebSocket connected');
                this.reconnectAttempts = 0;
                this.authenticate();
            };
            
            this.ws.onmessage = (event) => {
                this.handleMessage(JSON.parse(event.data));
            };
            
            this.ws.onclose = () => {
                console.log('Session sync WebSocket disconnected');
                this.scheduleReconnect();
            };
            
            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
        } catch (error) {
            console.error('Failed to create WebSocket connection:', error);
            this.scheduleReconnect();
        }
    }
    
    authenticate() {
        const token = localStorage.getItem('access_token');
        if (token) {
            this.send({
                type: 'auth',
                token: token
            });
        }
    }
    
    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(data));
        }
    }
    
    handleMessage(message) {
        switch (message.type) {
            case 'session_logout':
                this.handleRemoteLogout(message.data);
                break;
                
            case 'session_update':
                this.handleSessionUpdate(message.data);
                break;
                
            case 'session_expired':
                this.handleSessionExpired(message.data);
                break;
        }
    }
    
    scheduleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            
            setTimeout(() => {
                console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                this.connect();
            }, delay);
        }
    }
    
    // é€šçŸ¥ä¼šè¯å˜åŒ–
    notifyLogout() {
        this.send({
            type: 'logout',
            timestamp: Date.now()
        });
    }
    
    handleRemoteLogout(data) {
        // æ¸…ç†æœ¬åœ°ä¼šè¯
        localStorage.removeItem('access_token');
        localStorage.removeItem('id_token');
        localStorage.removeItem('user_info');
        
        // å…³é—­WebSocketè¿æ¥
        if (this.ws) {
            this.ws.close();
        }
        
        // é‡å®šå‘åˆ°ç™»å½•é¡µ
        alert('æ‚¨çš„è´¦æˆ·å·²åœ¨å…¶ä»–åœ°æ–¹é€€å‡ºç™»å½•');
        window.location.href = '/login';
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const sessionSync = new WebSocketSessionSync('wss://auth.example.com/ws/session-sync');
```

---

## 8. ğŸ¢ å•ç‚¹ç™»å‡ºåœ¨å¤šåº”ç”¨ä¸­çš„å¤„ç†


### 8.1 å¤šåº”ç”¨æ¶æ„ä¸­çš„æŒ‘æˆ˜


**å…¸å‹ä¼ä¸šåœºæ™¯**ï¼š
```
ä¼ä¸šå†…éƒ¨åº”ç”¨ç”Ÿæ€ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  è®¤è¯ä¸­å¿ƒ                            â”‚
â”‚            auth.company.com                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   é‚®ä»¶ç³»ç»Ÿ   â”‚ â”‚   HRç³»ç»Ÿ     â”‚ â”‚   è´¢åŠ¡ç³»ç»Ÿ    â”‚
â”‚  mail.xxx    â”‚ â”‚   hr.xxx     â”‚ â”‚  finance.xxx â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚               â”‚               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   CRMç³»ç»Ÿ    â”‚
                â”‚   crm.xxx    â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**é¢ä¸´çš„é—®é¢˜**ï¼š
- ğŸ”¸ **ç”¨æˆ·åœ¨ä»»ä¸€åº”ç”¨é€€å‡ºï¼Œéœ€è¦åŒæ­¥é€€å‡ºæ‰€æœ‰åº”ç”¨**
- ğŸ”¸ **ä¸åŒåº”ç”¨å¯èƒ½ä½¿ç”¨ä¸åŒçš„æŠ€æœ¯æ ˆ**
- ğŸ”¸ **ç½‘ç»œå»¶è¿Ÿå’Œæ•…éšœå¯¼è‡´çš„åŒæ­¥é—®é¢˜**
- ğŸ”¸ **ç”¨æˆ·ä½“éªŒï¼šé¿å…å¤šæ¬¡è·³è½¬å’Œé•¿æ—¶é—´ç­‰å¾…**

### 8.2 ç»Ÿä¸€ç™»å‡ºç®¡ç†ç­–ç•¥


**ğŸ”¹ ç­–ç•¥1ï¼šä¸­å¿ƒåŒ–ç™»å‡ºç®¡ç†**

```javascript
// è®¤è¯ä¸­å¿ƒçš„ç™»å‡ºç®¡ç†æœåŠ¡
class CentralizedLogoutManager {
    constructor() {
        this.registeredApps = new Map();
        this.activeLogoutSessions = new Map();
        this.config = {
            backChannelTimeout: 5000,    // åç«¯é€šé“è¶…æ—¶æ—¶é—´
            frontChannelTimeout: 10000,  // å‰ç«¯é€šé“è¶…æ—¶æ—¶é—´
            maxRetryAttempts: 3          // æœ€å¤§é‡è¯•æ¬¡æ•°
        };
    }
    
    // æ³¨å†Œåº”ç”¨çš„ç™»å‡ºé…ç½®
    registerApplication(appConfig) {
        this.registeredApps.set(appConfig.clientId, {
            name: appConfig.name,
            clientId: appConfig.clientId,
            backChannelLogoutUri: appConfig.backChannelLogoutUri,
            frontChannelLogoutUri: appConfig.frontChannelLogoutUri,
            logoutMethod: appConfig.logoutMethod || 'back-channel',
            priority: appConfig.priority || 1
        });
    }
    
    // å¤„ç†ç”¨æˆ·ç™»å‡ºè¯·æ±‚
    async processUserLogout(userId, sessionId, initiatingApp) {
        const logoutSession = this.createLogoutSession(userId, sessionId, initiatingApp);
        
        try {
            // è·å–ç”¨æˆ·çš„æ‰€æœ‰æ´»è·ƒåº”ç”¨
            const userApps = await this.getUserActiveApps(userId, sessionId);
            
            // æ ¹æ®ä¼˜å…ˆçº§å’Œæ–¹æ³•åˆ†ç»„åº”ç”¨
            const { backChannelApps, frontChannelApps } = this.categorizeApps(userApps);
            
            // å¹¶è¡Œå¤„ç†back-channel logout
            const backChannelResults = await this.processBackChannelLogouts(
                backChannelApps, userId, sessionId
            );
            
            // å¤„ç†front-channel logout
            const frontChannelResults = await this.processFrontChannelLogouts(
                frontChannelApps, userId, sessionId
            );
            
            // åˆå¹¶ç»“æœ
            const results = [...backChannelResults, ...frontChannelResults];
            
            // æ¸…ç†è®¤è¯ä¸­å¿ƒçš„ä¼šè¯
            await this.clearCentralSession(userId, sessionId);
            
            // è®°å½•ç™»å‡ºç»“æœ
            this.recordLogoutResults(logoutSession, results);
            
            return this.buildLogoutResponse(results);
            
        } catch (error) {
            console.error('Logout process failed:', error);
            throw error;
        }
    }
    
    async processBackChannelLogouts(apps, userId, sessionId) {
        const promises = apps.map(app => 
            this.sendBackChannelLogout(app, userId, sessionId)
                .then(result => ({ app: app.name, success: true, result }))
                .catch(error => ({ app: app.name, success: false, error: error.message }))
        );
        
        return Promise.all(promises);
    }
    
    async sendBackChannelLogout(app, userId, sessionId) {
        let attempt = 1;
        
        while (attempt <= this.config.maxRetryAttempts) {
            try {
                const logoutToken = this.createLogoutToken(userId, sessionId, app.clientId);
                
                const response = await fetch(app.backChannelLogoutUri, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: `logout_token=${logoutToken}`,
                    signal: AbortSignal.timeout(this.config.backChannelTimeout)
                });
                
                if (response.ok) {
                    return { status: 'success', attempts: attempt };
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
            } catch (error) {
                console.warn(`Attempt ${attempt} failed for ${app.name}:`, error.message);
                
                if (attempt < this.config.maxRetryAttempts) {
                    // æŒ‡æ•°é€€é¿
                    await this.sleep(1000 * Math.pow(2, attempt - 1));
                    attempt++;
                } else {
                    throw error;
                }
            }
        }
    }
    
    buildLogoutResponse(results) {
        const successful = results.filter(r => r.success);
        const failed = results.filter(r => !r.success);
        
        return {
            status: failed.length === 0 ? 'success' : 'partial',
            total: results.length,
            successful: successful.length,
            failed: failed.length,
            details: results
        };
    }
}
```

**ğŸ”¹ ç­–ç•¥2ï¼šåº”ç”¨çº§è”ç™»å‡º**

```javascript
// åº”ç”¨ç«¯çš„çº§è”ç™»å‡ºå¤„ç†
class CascadeLogoutHandler {
    constructor(appConfig) {
        this.appConfig = appConfig;
        this.logoutQueue = [];
        this.isProcessing = false;
    }
    
    // å¤„ç†ç™»å‡ºè¯·æ±‚
    async handleLogout(logoutRequest) {
        try {
            // æ¸…ç†æœ¬åº”ç”¨çš„ä¼šè¯
            await this.clearLocalSession(logoutRequest);
            
            // é€šçŸ¥ç›¸å…³è”çš„åº”ç”¨
            if (logoutRequest.cascade && this.appConfig.relatedApps) {
                await this.notifyRelatedApps(logoutRequest);
            }
            
            // è®°å½•ç™»å‡ºäº‹ä»¶
            this.recordLogoutEvent(logoutRequest);
            
        } catch (error) {
            console.error('Logout handling failed:', error);
            throw error;
        }
    }
    
    async notifyRelatedApps(logoutRequest) {
        const notifications = this.appConfig.relatedApps.map(async (relatedApp) => {
            try {
                if (relatedApp.notificationMethod === 'webhook') {
                    return await this.sendWebhookNotification(relatedApp, logoutRequest);
                } else if (relatedApp.notificationMethod === 'message_queue') {
                    return await this.sendQueueMessage(relatedApp, logoutRequest);
                }
            } catch (error) {
                console.error(`Failed to notify ${relatedApp.name}:`, error);
                return { app: relatedApp.name, success: false, error: error.message };
            }
        });
        
        return Promise.allSettled(notifications);
    }
    
    async sendWebhookNotification(app, logoutRequest) {
        const payload = {
            event_type: 'user_logout',
            user_id: logoutRequest.userId,
            session_id: logoutRequest.sessionId,
            timestamp: Date.now(),
            initiating_app: this.appConfig.name
        };
        
        const response = await fetch(app.webhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Webhook-Signature': this.signPayload(payload, app.secret)
            },
            body: JSON.stringify(payload),
            timeout: 5000
        });
        
        if (!response.ok) {
            throw new Error(`Webhook failed: ${response.status}`);
        }
        
        return { app: app.name, success: true };
    }
}
```

### 8.3 ç”¨æˆ·ä½“éªŒä¼˜åŒ–


**ğŸ”¹ è¿›åº¦æŒ‡ç¤ºå’Œåé¦ˆ**

```html
<!DOCTYPE html>
<html>
<head>
    <title>æ­£åœ¨é€€å‡ºç™»å½•</title>
    <style>
        .logout-container {
            max-width: 500px;
            margin: 100px auto;
            padding: 30px;
            text-align: center;
            font-family: Arial, sans-serif;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .app-list {
            text-align: left;
            margin: 20px 0;
        }
        
        .app-item {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .app-pending {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        
        .app-success {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .app-failed {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        
        .status-icon {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="logout-container">
        <h2>æ­£åœ¨é€€å‡ºç™»å½•</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <p id="statusText">æ­£åœ¨æ¸…ç†æ‚¨åœ¨å„ä¸ªåº”ç”¨ä¸­çš„ç™»å½•çŠ¶æ€...</p>
        
        <div class="app-list" id="appList">
            <!-- åŠ¨æ€ç”Ÿæˆåº”ç”¨çŠ¶æ€åˆ—è¡¨ -->
        </div>
        
        <div id="completionMessage" style="display: none;">
            <h3>âœ… é€€å‡ºå®Œæˆ</h3>
            <p>æ‚¨å·²æˆåŠŸé€€å‡ºæ‰€æœ‰åº”ç”¨</p>
            <button onclick="closeWindow()">å…³é—­çª—å£</button>
        </div>
    </div>
    
    <script>
        class LogoutProgressManager {
            constructor() {
                this.apps = [
                    { name: 'é‚®ä»¶ç³»ç»Ÿ', id: 'mail', status: 'pending' },
                    { name: 'HRç³»ç»Ÿ', id: 'hr', status: 'pending' },
                    { name: 'è´¢åŠ¡ç³»ç»Ÿ', id: 'finance', status: 'pending' },
                    { name: 'CRMç³»ç»Ÿ', id: 'crm', status: 'pending' }
                ];
                this.completedCount = 0;
                this.init();
            }
            
            init() {
                this.renderAppList();
                this.startLogoutProcess();
            }
            
            renderAppList() {
                const appList = document.getElementById('appList');
                appList.innerHTML = this.apps.map(app => `
                    <div class="app-item app-${app.status}" id="app-${app.id}">
                        <span>${app.name}</span>
                        <span class="status-icon" id="status-${app.id}">â³</span>
                    </div>
                `).join('');
            }
            
            updateAppStatus(appId, status) {
                const app = this.apps.find(a => a.id === appId);
                if (app) {
                    app.status = status;
                    const appElement = document.getElementById(`app-${appId}`);
                    const statusElement = document.getElementById(`status-${appId}`);
                    
                    appElement.className = `app-item app-${status}`;
                    
                    switch (status) {
                        case 'success':
                            statusElement.textContent = 'âœ…';
                            this.completedCount++;
                            break;
                        case 'failed':
                            statusElement.textContent = 'âŒ';
                            this.completedCount++;
                            break;
                        default:
                            statusElement.textContent = 'â³';
                    }
                    
                    this.updateProgress();
                }
            }
            
            updateProgress() {
                const progress = (this.completedCount / this.apps.length) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                
                if (this.completedCount === this.apps.length) {
                    this.showCompletion();
                }
            }
            
            showCompletion() {
                setTimeout(() => {
                    document.getElementById('statusText').textContent = 'ç™»å‡ºå¤„ç†å®Œæˆ';
                    document.getElementById('completionMessage').style.display = 'block';
                }, 1000);
            }
            
            async startLogoutProcess() {
                // æ¨¡æ‹Ÿç™»å‡ºè¿‡ç¨‹
                const logoutPromises = this.apps.map((app, index) => 
                    this.simulateAppLogout(app.id, (index + 1) * 1000)
                );
                
                await Promise.allSettled(logoutPromises);
            }
            
            async simulateAppLogout(appId, delay) {
                await new Promise(resolve => setTimeout(resolve, delay));
                
                // æ¨¡æ‹ŸéšæœºæˆåŠŸ/å¤±è´¥
                const success = Math.random() > 0.2; // 80%æˆåŠŸç‡
                this.updateAppStatus(appId, success ? 'success' : 'failed');
            }
        }
        
        function closeWindow() {
            window.close();
        }
        
        // å¯åŠ¨ç™»å‡ºè¿›åº¦ç®¡ç†å™¨
        new LogoutProgressManager();
    </script>
</body>
</html>
```

**ğŸ”¹ ç­–ç•¥3ï¼šæ™ºèƒ½é‡è¯•å’Œé™çº§å¤„ç†**

```javascript
class IntelligentLogoutManager {
    constructor() {
        this.retryStrategies = {
            'network_error': { maxRetries: 3, backoffMultiplier: 2 },
            'timeout': { maxRetries: 2, backoffMultiplier: 1.5 },
            'server_error': { maxRetries: 1, backoffMultiplier: 1 },
            'client_error': { maxRetries: 0, backoffMultiplier: 1 }
        };
        
        this.fallbackMethods = new Map();
        this.setupFallbackMethods();
    }
    
    setupFallbackMethods() {
        // ä¸ºä¸åŒç±»å‹çš„åº”ç”¨è®¾ç½®é™çº§æ–¹æ¡ˆ
        this.fallbackMethods.set('web_app', ['back_channel', 'front_channel', 'local_storage']);
        this.fallbackMethods.set('mobile_app', ['push_notification', 'token_revocation']);
        this.fallbackMethods.set('legacy_app', ['database_cleanup', 'scheduled_cleanup']);
    }
    
    async executeLogoutWithFallback(app, userId, sessionId) {
        const methods = this.fallbackMethods.get(app.type) || ['back_channel'];
        
        for (const method of methods) {
            try {
                const result = await this.executeLogoutMethod(method, app, userId, sessionId);
                
                if (result.success) {
                    return {
                        success: true,
                        method: method,
                        result: result
                    };
                }
                
            } catch (error) {
                console.warn(`Method ${method} failed for ${app.name}:`, error.message);
                
                // å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªæ–¹æ³•ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
                if (method !== methods[methods.length - 1]) {
                    await this.sleep(500); // çŸ­æš‚å»¶è¿Ÿ
                    continue;
                }
            }
        }
        
        // æ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥ï¼Œè¿”å›å¤±è´¥ç»“æœ
        return {
            success: false,
            error: 'All fallback methods failed',
            attemptedMethods: methods
        };
    }
    
    async executeLogoutMethod(method, app, userId, sessionId) {
        switch (method) {
            case 'back_channel':
                return await this.backChannelLogout(app, userId, sessionId);
                
            case 'front_channel':
                return await this.frontChannelLogout(app, userId, sessionId);
                
            case 'local_storage':
                return await this.localStorageLogout(app, userId, sessionId);
                
            case 'push_notification':
                return await this.pushNotificationLogout(app, userId, sessionId);
                
            case 'token_revocation':
                return await this.tokenRevocationLogout(app, userId, sessionId);
                
            default:
                throw new Error(`Unknown logout method: ${method}`);
        }
    }
    
    async tokenRevocationLogout(app, userId, sessionId) {
        // æ’¤é”€åº”ç”¨çš„è®¿é—®ä»¤ç‰Œ
        const tokens = await this.getAppTokens(app.clientId, userId);
        
        const revocationPromises = tokens.map(token => 
            this.revokeToken(token)
        );
        
        const results = await Promise.allSettled(revocationPromises);
        const successful = results.filter(r => r.status === 'fulfilled').length;
        
        return {
            success: successful > 0,
            revokedTokens: successful,
            totalTokens: tokens.length
        };
    }
    
    async pushNotificationLogout(app, userId, sessionId) {
        // å‘é€æ¨é€é€šçŸ¥è¦æ±‚åº”ç”¨ç™»å‡º
        const notification = {
            type: 'logout_required',
            userId: userId,
            sessionId: sessionId,
            timestamp: Date.now(),
            reason: 'central_logout'
        };
        
        return await this.sendPushNotification(app.pushEndpoint, notification);
    }
}
```

### 8.4 ç›‘æ§å’Œå®¡è®¡


**ğŸ”¹ ç™»å‡ºäº‹ä»¶ç›‘æ§**

```javascript
class LogoutEventMonitor {
    constructor() {
        this.events = [];
        this.alertThresholds = {
            failureRate: 0.3,          // å¤±è´¥ç‡è¶…è¿‡30%å‘Šè­¦
            responseTime: 10000,        // å“åº”æ—¶é—´è¶…è¿‡10ç§’å‘Šè­¦
            partialFailures: 5         // éƒ¨åˆ†å¤±è´¥æ¬¡æ•°è¶…è¿‡5æ¬¡å‘Šè­¦
        };
    }
    
    recordLogoutEvent(event) {
        const logoutEvent = {
            id: this.generateEventId(),
            timestamp: Date.now(),
            userId: event.userId,
            sessionId: event.sessionId,
            initiatingApp: event.initiatingApp,
            targetApps: event.targetApps,
            results: event.results,
            duration: event.duration,
            success: event.success,
            errors: event.errors || []
        };
        
        this.events.push(logoutEvent);
        this.analyzeEvent(logoutEvent);
        this.persistEvent(logoutEvent);
    }
    
    analyzeEvent(event) {
        // æ£€æŸ¥å¤±è´¥ç‡
        this.checkFailureRate(event);
        
        // æ£€æŸ¥å“åº”æ—¶é—´
        this.checkResponseTime(event);
        
        // æ£€æŸ¥éƒ¨åˆ†å¤±è´¥
        this.checkPartialFailures(event);
        
        // æ£€æŸ¥å¼‚å¸¸æ¨¡å¼
        this.checkAnomalousPatterns(event);
    }
    
    checkFailureRate(event) {
        const recentEvents = this.getRecentEvents(300000); // æœ€è¿‘5åˆ†é’Ÿ
        
        if (recentEvents.length >= 10) {
            const failureRate = recentEvents.filter(e => !e.success).length / recentEvents.length;
            
            if (failureRate > this.alertThresholds.failureRate) {
                this.triggerAlert('high_failure_rate', {
                    failureRate: failureRate,
                    recentEvents: recentEvents.length,
                    timeWindow: '5 minutes'
                });
            }
        }
    }
    
    checkResponseTime(event) {
        if (event.duration > this.alertThresholds.responseTime) {
            this.triggerAlert('slow_logout', {
                duration: event.duration,
                threshold: this.alertThresholds.responseTime,
                event: event
            });
        }
    }
    
    triggerAlert(alertType, data) {
        const alert = {
            type: alertType,
            timestamp: Date.now(),
            severity: this.getAlertSeverity(alertType),
            data: data
        };
        
        console.warn('Logout Alert:', alert);
        
        // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
        this.sendToMonitoring(alert);
        
        // å¦‚æœä¸¥é‡ç¨‹åº¦é«˜ï¼Œå‘é€ç´§æ€¥é€šçŸ¥
        if (alert.severity === 'critical') {
            this.sendUrgentNotification(alert);
        }
    }
    
    generateDashboardReport() {
        const now = Date.now();
        const last24Hours = now - 24 * 60 * 60 * 1000;
        const recentEvents = this.events.filter(e => e.timestamp > last24Hours);
        
        return {
            period: '24 hours',
            totalLogouts: recentEvents.length,
            successfulLogouts: recentEvents.filter(e => e.success).length,
            failedLogouts: recentEvents.filter(e => !e.success).length,
            averageResponseTime: this.calculateAverageResponseTime(recentEvents),
            topFailingApps: this.getTopFailingApps(recentEvents),
            timeDistribution: this.getTimeDistribution(recentEvents),
            errorSummary: this.getErrorSummary(recentEvents)
        };
    }
    
    getTopFailingApps(events) {
        const appFailures = {};
        
        events.forEach(event => {
            if (event.results) {
                event.results.forEach(result => {
                    if (!result.success) {
                        appFailures[result.app] = (appFailures[result.app] || 0) + 1;
                    }
                });
            }
        });
        
        return Object.entries(appFailures)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([app, failures]) => ({ app, failures }));
    }
}
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ OIDCä¼šè¯æœ¬è´¨ï¼šå¤šå±‚ä¼šè¯åè°ƒç®¡ç†ï¼ŒåŒ…å«OPä¼šè¯ã€RPä¼šè¯ã€æµè§ˆå™¨ä¼šè¯
ğŸ”¸ Session Managementï¼šæ ‡å‡†åŒ–çš„ä¼šè¯ç›‘æ§å’Œç®¡ç†è§„èŒƒ
ğŸ”¸ RP-Initiated Logoutï¼šç”±å®¢æˆ·ç«¯åº”ç”¨å‘èµ·çš„æ ‡å‡†ç™»å‡ºæµç¨‹
ğŸ”¸ Back-Channel Logoutï¼šæœåŠ¡å™¨åˆ°æœåŠ¡å™¨çš„ç›´æ¥é€šä¿¡ç™»å‡ºæ–¹å¼
ğŸ”¸ Front-Channel Logoutï¼šé€šè¿‡ç”¨æˆ·æµè§ˆå™¨è¿›è¡Œçš„ç™»å‡ºé€šçŸ¥æ–¹å¼
ğŸ”¸ è·¨åŸŸä¼šè¯åŒæ­¥ï¼šè§£å†³ä¸åŒåŸŸååº”ç”¨é—´çš„ä¼šè¯çŠ¶æ€ä¸€è‡´æ€§
ğŸ”¸ å¤šåº”ç”¨ç™»å‡ºï¼šä¼ä¸šçº§ç¯å¢ƒä¸­çš„ç»Ÿä¸€ç™»å‡ºç®¡ç†
```

### 9.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä¼šè¯ç®¡ç†çš„å¤æ‚æ€§**
```
ç†è§£è¦ç‚¹ï¼š
- OIDCç¯å¢ƒä¸‹ä¼šè¯ä¸æ˜¯å•ä¸€çš„ï¼Œè€Œæ˜¯å¤šå±‚çº§çš„
- è®¤è¯æœåŠ¡å™¨ä¼šè¯ â‰  åº”ç”¨ä¼šè¯ â‰  æµè§ˆå™¨ä¼šè¯
- éœ€è¦åè°ƒå¤šä¸ªç‹¬ç«‹ç³»ç»Ÿçš„çŠ¶æ€ä¸€è‡´æ€§
```

**ğŸ”¹ ç™»å‡ºæ–¹å¼çš„é€‰æ‹©åŸåˆ™**
```
Back-Channel Logouté€‚ç”¨ï¼š
âœ… ä¼ä¸šçº§åº”ç”¨ï¼Œå®‰å…¨è¦æ±‚é«˜
âœ… æœåŠ¡å™¨é—´ç½‘ç»œç¨³å®š
âœ… éœ€è¦å¯é çš„ç™»å‡ºä¿è¯

Front-Channel Logouté€‚ç”¨ï¼š
âœ… ç®€å•çš„Webåº”ç”¨ç¯å¢ƒ
âœ… ä¸è¦æ±‚ç»å¯¹çš„ç™»å‡ºå¯é æ€§
âœ… å¼€å‘å’Œç»´æŠ¤æˆæœ¬æ•æ„Ÿ
```

**ğŸ”¹ è·¨åŸŸåŒæ­¥çš„æŒ‘æˆ˜**
```
æ ¸å¿ƒé—®é¢˜ï¼š
- æµè§ˆå™¨åŒæºç­–ç•¥é™åˆ¶
- ç½‘ç»œå»¶è¿Ÿå’Œæ•…éšœå¤„ç†
- ç”¨æˆ·ä½“éªŒå’ŒæŠ€æœ¯å®ç°çš„å¹³è¡¡

è§£å†³æ€è·¯ï¼š
- å¤šç§æ–¹æ¡ˆç»„åˆä½¿ç”¨
- ä¼˜é›…é™çº§å’Œé”™è¯¯å¤„ç†
- å®æ—¶æ€§ä¸å¯é æ€§çš„æƒè¡¡
```

### 9.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ”¹ æŠ€æœ¯é€‰å‹å»ºè®®**

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | ç†ç”± |
|------|----------|------|
| **ä¼ä¸šå†…ç½‘** | Back-Channel + WebSocket | å¯é æ€§é«˜ï¼Œå®æ—¶æ€§å¥½ |
| **å…¬ç½‘SaaS** | Front-Channel + localStorageäº‹ä»¶ | ç®€å•æ˜“å®ç°ï¼Œå…¼å®¹æ€§å¥½ |
| **æ··åˆæ¶æ„** | å¤šæ–¹æ¡ˆç»„åˆ | ä¸åŒåº”ç”¨ä½¿ç”¨ä¸åŒç­–ç•¥ |
| **ç§»åŠ¨åº”ç”¨** | Pushé€šçŸ¥ + Tokenæ’¤é”€ | é€‚åˆç§»åŠ¨ç«¯ç‰¹ç‚¹ |

**ğŸ”¹ å¼€å‘å®è·µè¦ç‚¹**
```
è®¾è®¡åŸåˆ™ï¼š
- ä¼˜é›…é™çº§ï¼šä¸»æ–¹æ¡ˆå¤±è´¥æ—¶æœ‰å¤‡é€‰æ–¹æ¡ˆ
- ç”¨æˆ·ä½“éªŒï¼šé¿å…é•¿æ—¶é—´ç­‰å¾…å’Œå¤šæ¬¡è·³è½¬  
- é”™è¯¯å¤„ç†ï¼šè¯¦ç»†çš„é”™è¯¯æ—¥å¿—å’Œç›‘æ§
- å®‰å…¨è€ƒè™‘ï¼šé˜²æ­¢ä¼šè¯åŠ«æŒå’Œé‡æ”¾æ”»å‡»

å¸¸è§é™·é˜±ï¼š
âŒ å¿½ç•¥ç½‘ç»œæ•…éšœæƒ…å†µçš„å¤„ç†
âŒ æ²¡æœ‰è€ƒè™‘æµè§ˆå™¨å…¼å®¹æ€§
âŒ ç™»å‡ºæµç¨‹è¿‡äºå¤æ‚ï¼Œå½±å“ç”¨æˆ·ä½“éªŒ
âŒ ç¼ºä¹ç›‘æ§å’Œå®¡è®¡æœºåˆ¶
```

**ğŸ”¹ è¿ç»´ç›‘æ§è¦ç‚¹**
```
å…³é”®æŒ‡æ ‡ï¼š
- ç™»å‡ºæˆåŠŸç‡ï¼šæ•´ä½“å’Œå„åº”ç”¨çš„æˆåŠŸç‡
- å“åº”æ—¶é—´ï¼šä»å‘èµ·åˆ°å®Œæˆçš„è€—æ—¶
- é”™è¯¯åˆ†å¸ƒï¼šå„ç±»é”™è¯¯çš„å‘ç”Ÿé¢‘ç‡
- ç”¨æˆ·æŠ•è¯‰ï¼šç”¨æˆ·å¯¹ç™»å‡ºä½“éªŒçš„åé¦ˆ

å‘Šè­¦è®¾ç½®ï¼š
ğŸš¨ ç™»å‡ºå¤±è´¥ç‡ > 5%
ğŸš¨ å¹³å‡å“åº”æ—¶é—´ > 10ç§’
ğŸš¨ æŸä¸ªåº”ç”¨è¿ç»­å¤±è´¥ > 3æ¬¡
ğŸš¨ çŸ­æ—¶é—´å†…å¤§é‡ç™»å‡ºè¯·æ±‚ï¼ˆå¯èƒ½çš„æ”»å‡»ï¼‰
```

### 9.4 å‘å±•è¶‹åŠ¿


```
æŠ€æœ¯æ¼”è¿›ï¼š
- æ›´æ ‡å‡†åŒ–çš„Session Managementæ‰©å±•
- åŸºäºWebRTCçš„å®æ—¶é€šä¿¡æ–¹æ¡ˆ
- æœºå™¨å­¦ä¹ è¾…åŠ©çš„å¼‚å¸¸æ£€æµ‹
- é›¶ä¿¡ä»»æ¶æ„ä¸‹çš„ä¼šè¯ç®¡ç†

å®‰å…¨å¢å¼ºï¼š
- ä¼šè¯ç»‘å®šæŠ€æœ¯å¢å¼º
- ç”Ÿç‰©ç‰¹å¾è¾…åŠ©éªŒè¯
- åŒºå—é“¾æŠ€æœ¯åº”ç”¨æ¢ç´¢
- é‡å­å®‰å…¨çš„ä¼šè¯ä¿æŠ¤
```

**æ ¸å¿ƒè®°å¿†**ï¼š
- ä¼šè¯ç®¡ç†å¤šå±‚çº§ï¼Œåè°ƒä¸€è‡´æ˜¯å…³é”®
- ç™»å‡ºæ–¹å¼æœ‰å¤šç§ï¼ŒæŒ‰éœ€é€‰æ‹©æœ€åˆé€‚
- è·¨åŸŸåŒæ­¥æœ‰æŒ‘æˆ˜ï¼Œå¤šæ–¹æ¡ˆç»„åˆè§£å†³
- ç”¨æˆ·ä½“éªŒè¦å‹å¥½ï¼Œç›‘æ§å®¡è®¡ä¸å¯å°‘