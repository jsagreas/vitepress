---
title: 7、OIDC用户信息与Scope控制
---
## 📚 目录

1. [UserInfo端点基础概念](#1-userinfo端点基础概念)
2. [UserInfo端点调用方法](#2-userinfo端点调用方法)
3. [标准Scope详解](#3-标准scope详解)
4. [标准Claims说明](#4-标准claims说明)
5. [自定义Claims实践](#5-自定义claims实践)
6. [数据保护策略](#6-数据保护策略)
7. [Bearer Token使用](#7-bearer-token使用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 UserInfo端点基础概念


### 1.1 什么是UserInfo端点


**🔸 通俗理解**
```
想象一下：
你用微信登录了一个购物APP，登录成功后APP想获取你的头像、昵称
这时候APP就需要问微信："这个用户的详细信息是什么？"
UserInfo端点就是微信提供的"查询用户信息"的接口

简单来说：UserInfo端点就是获取用户详细信息的专门接口
```

**💡 核心作用**
- 📱 **信息获取**：获取用户的详细个人信息
- 🔒 **权限控制**：根据授权范围返回相应信息
- 🎯 **标准化**：提供统一的用户信息获取方式

### 1.2 UserInfo端点与ID Token的区别


**🔸 两者对比**
```
ID Token（身份证明）：
- 用途：证明用户是谁
- 内容：基本身份信息
- 获取：登录时直接获得
- 例子：就像身份证，证明你的身份

UserInfo端点（详细档案）：
- 用途：获取用户详细信息
- 内容：丰富的用户资料
- 获取：需要额外请求
- 例子：就像个人档案，包含详细信息
```

**🎯 使用场景对比**

| 场景 | 使用方案 | 原因 |
|------|----------|------|
| 用户登录验证 | **ID Token** | 快速验证身份，信息够用 |
| 完善用户资料 | **UserInfo端点** | 需要详细信息 |
| 显示用户头像 | **UserInfo端点** | 需要picture字段 |
| 权限验证 | **ID Token** | 基本身份信息即可 |

---

## 2. 📡 UserInfo端点调用方法


### 2.1 调用流程图解


```
客户端应用                        认证服务器
    |                                 |
    |--[1]用Access Token请求--------->|
    |   GET /userinfo               |
    |   Authorization: Bearer xxx    |
    |                                 |
    |<--[2]返回用户信息---------------|
    |   {"name": "张三", ...}        |
```

### 2.2 具体调用步骤


**步骤1：准备Access Token**
```javascript
// 首先需要有一个有效的Access Token
const accessToken = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...";
```

**步骤2：发起HTTP请求**
```javascript
// 标准的UserInfo请求
const response = await fetch('https://auth.example.com/userinfo', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  }
});
```

**步骤3：处理响应结果**
```javascript
if (response.ok) {
  const userInfo = await response.json();
  console.log('用户信息:', userInfo);
  // 输出：{
  //   "sub": "12345",
  //   "name": "张三",
  //   "email": "zhangsan@example.com"
  // }
} else {
  console.error('获取用户信息失败:', response.status);
}
```

### 2.3 常见错误处理


**🚨 典型错误场景**

| 错误码 | 含义 | 常见原因 | 解决方案 |
|--------|------|----------|----------|
| **401** | 未授权 | Token无效或过期 | 重新获取Token |
| **403** | 禁止访问 | Token权限不足 | 检查scope权限 |
| **404** | 端点不存在 | URL错误 | 确认UserInfo端点地址 |
| **429** | 请求过频 | 调用太频繁 | 添加请求限流 |

---

## 3. 🎯 标准Scope详解


### 3.1 Scope是什么


**🔸 通俗理解**
```
Scope就像"权限清单"：

比如你去银行办业务，工作人员会问：
"您要办理什么业务？查余额？转账？还是修改个人信息？"

Scope就是告诉认证服务器：
"我的应用需要获取用户的哪些信息？"
```

### 3.2 五大标准Scope详解


#### 🔑 **openid** - 必需的基础权限


**含义**：表明这是一个OpenID Connect请求
```javascript
// 请求示例
scope: "openid"

// 返回的基础信息
{
  "sub": "12345",          // 用户唯一标识
  "iss": "https://auth.com", // 发行方
  "aud": "your-app-id"     // 应用标识
}
```

> 💡 **重要提示**: openid是必须包含的scope，没有它就不是OIDC请求

#### 👤 **profile** - 个人基本信息


**含义**：获取用户的基本个人资料
```javascript
scope: "openid profile"

// 可以获取的信息
{
  "name": "张三",                    // 姓名
  "given_name": "三",               // 名字
  "family_name": "张",              // 姓氏
  "nickname": "小张",               // 昵称
  "picture": "https://avatar.jpg",  // 头像
  "website": "https://blog.com",    // 个人网站
  "gender": "male",                 // 性别
  "birthdate": "1990-01-01",        // 生日
  "locale": "zh-CN",                // 地区语言
  "updated_at": 1234567890          // 信息更新时间
}
```

#### 📧 **email** - 邮箱信息


**含义**：获取用户的邮箱地址
```javascript
scope: "openid email"

// 获取的邮箱信息
{
  "email": "zhangsan@example.com",  // 邮箱地址
  "email_verified": true            // 邮箱是否已验证
}
```

**🎯 实际应用场景**
- ✅ 用户注册时获取邮箱
- ✅ 发送通知邮件
- ✅ 账号找回验证

#### 📍 **address** - 地址信息


**含义**：获取用户的地址信息
```javascript
scope: "openid address"

// 获取的地址信息
{
  "address": {
    "formatted": "北京市朝阳区xxx街道xxx号",    // 格式化地址
    "street_address": "xxx街道xxx号",          // 街道地址
    "locality": "朝阳区",                     // 城市/区域
    "region": "北京市",                       // 省/州
    "postal_code": "100000",                 // 邮编
    "country": "CN"                          // 国家代码
  }
}
```

#### 📱 **phone** - 电话信息


**含义**：获取用户的电话号码
```javascript
scope: "openid phone"

// 获取的电话信息
{
  "phone_number": "+86-13800138000",   // 电话号码
  "phone_number_verified": true       // 电话是否已验证
}
```

### 3.3 Scope组合使用


**🔸 实际应用中的组合**
```javascript
// 社交应用 - 需要基本信息和头像
scope: "openid profile"

// 电商应用 - 需要联系方式和地址
scope: "openid profile email address phone"

// 简单登录 - 只需要身份确认
scope: "openid"

// 企业应用 - 需要邮箱用于通知
scope: "openid profile email"
```

**💡 最佳实践**
- 🎯 **最小化原则**：只请求必需的信息
- 🔒 **隐私保护**：避免过度收集用户数据
- 📝 **明确说明**：告诉用户为什么需要这些信息

---

## 4. 📋 标准Claims说明


### 4.1 Claims是什么


**🔸 通俗理解**
```
Claims就是"信息条目"：

就像你的个人档案表：
- 姓名：张三
- 邮箱：zhangsan@example.com  
- 电话：13800138000

每一项信息就是一个Claim
```

### 4.2 核心Claims详解


#### 👤 **基本身份Claims**


```javascript
// 用户身份相关
{
  "sub": "12345",              // 用户唯一标识符（最重要）
  "name": "张三",              // 完整姓名
  "given_name": "三",          // 名字
  "family_name": "张",         // 姓氏  
  "middle_name": "志",         // 中间名（可选）
  "nickname": "小张",          // 昵称
  "preferred_username": "zhangsan" // 首选用户名
}
```

> 💡 **重点说明**: `sub`是最重要的claim，它是用户在该认证服务器中的唯一标识

#### 🖼️ **外观和展示Claims**


```javascript
// 用户外观和展示信息
{
  "picture": "https://example.com/avatar.jpg", // 头像图片URL
  "website": "https://zhangsan.blog.com",     // 个人网站
  "profile": "https://social.com/zhangsan",   // 个人主页
  "gender": "male",                           // 性别：male/female
  "birthdate": "1990-01-01",                  // 生日（YYYY-MM-DD格式）
  "zoneinfo": "Asia/Shanghai",               // 时区信息
  "locale": "zh-CN"                          // 地区和语言偏好
}
```

#### 📞 **联系方式Claims**


```javascript
// 联系方式相关
{
  "email": "zhangsan@example.com",    // 邮箱地址
  "email_verified": true,             // 邮箱验证状态
  "phone_number": "+86-13800138000",  // 电话号码
  "phone_number_verified": false      // 电话验证状态
}
```

#### 📍 **地址Claims**


```javascript
// 地址信息（address是一个复杂对象）
{
  "address": {
    "formatted": "北京市朝阳区中关村大街1号",  // 完整格式化地址
    "street_address": "中关村大街1号",        // 街道地址
    "locality": "朝阳区",                    // 城市/地区
    "region": "北京市",                     // 省/州
    "postal_code": "100000",               // 邮政编码
    "country": "中国"                      // 国家
  }
}
```

#### ⏰ **时间相关Claims**


```javascript
// 时间戳相关
{
  "updated_at": 1640995200,    // 信息最后更新时间（Unix时间戳）
  "iat": 1640995200,          // Token签发时间
  "exp": 1641001200,          // Token过期时间
  "nbf": 1640995200           // Token生效时间
}
```

### 4.3 Claims的数据类型


**🔸 支持的数据类型**

| 类型 | 说明 | 示例 |
|------|------|------|
| **string** | 字符串 | `"name": "张三"` |
| **boolean** | 布尔值 | `"email_verified": true` |
| **number** | 数字 | `"updated_at": 1640995200` |
| **object** | 对象 | `"address": {...}` |
| **array** | 数组 | `"groups": ["admin", "user"]` |

---

## 5. 🎨 自定义Claims实践


### 5.1 为什么需要自定义Claims


**🔸 标准Claims的局限性**
```
标准Claims只能覆盖基本信息：
✅ 姓名、邮箱、电话等
❌ 用户等级、部门信息、偏好设置等

业务场景需要更多信息：
- 电商系统：会员等级、积分、购买偏好
- 企业系统：部门、职位、权限级别
- 游戏系统：等级、成就、游戏偏好
```

### 5.2 自定义Claims设计原则


**🎯 设计要点**

1. **📛 命名规范**
```javascript
// ✅ 推荐：使用有意义的前缀
{
  "company:department": "技术部",
  "company:position": "高级工程师",
  "company:level": 5
}

// ❌ 不推荐：容易冲突
{
  "department": "技术部",  // 可能与其他服务冲突
  "level": 5
}
```

2. **🔒 隐私考量**
```javascript
// ✅ 合适的自定义Claims
{
  "user_level": "premium",      // 用户等级
  "preferred_theme": "dark",    // 界面偏好
  "notification_enabled": true  // 通知设置
}

// ❌ 避免敏感信息
{
  "salary": 50000,             // 工资信息
  "id_card": "123456789",      // 身份证号
  "bank_account": "6222..."    // 银行账号
}
```

### 5.3 自定义Claims实现示例


**🔸 认证服务器端配置**
```javascript
// 配置自定义Claims映射
const customClaimsMapping = {
  'openid profile company': {
    // 标准Claims
    sub: user.id,
    name: user.full_name,
    email: user.email,
    
    // 自定义Claims
    'company:department': user.department,
    'company:position': user.position,
    'user_level': user.membership_level,
    'last_login': user.last_login_time
  }
};
```

**🔸 客户端获取自定义Claims**
```javascript
// 请求时指定自定义scope
const authUrl = `https://auth.example.com/authorize?
  client_id=your-app&
  scope=openid profile company&  // 包含自定义scope
  response_type=code&
  redirect_uri=https://yourapp.com/callback`;

// 从UserInfo获取自定义信息
const userInfo = await fetch('/userinfo', {
  headers: {
    'Authorization': `Bearer ${accessToken}`
  }
}).then(r => r.json());

console.log('用户部门:', userInfo['company:department']);
console.log('用户等级:', userInfo.user_level);
```

### 5.4 自定义Claims最佳实践


**💡 实用建议**

```javascript
// 1. 按业务模块组织Claims
const userClaims = {
  // 基础信息
  sub: "12345",
  name: "张三",
  
  // 业务相关
  "ecommerce:vip_level": "gold",
  "ecommerce:points": 1500,
  "ecommerce:preferred_category": "electronics",
  
  // 系统偏好
  "ui:theme": "dark",
  "ui:language": "zh-CN",
  "notification:email": true,
  "notification:sms": false
};

// 2. 提供Claims的业务含义
const claimsDescription = {
  "ecommerce:vip_level": "会员等级：bronze/silver/gold/platinum",
  "ui:theme": "界面主题：light/dark/auto",
  "notification:email": "是否接收邮件通知"
};
```

---

## 6. 🛡️ 数据保护策略


### 6.1 最小化信息原则


**🔸 什么是最小化原则**
```
简单理解：只拿你需要的，不拿你不需要的

比如：
一个天气APP只需要获取用户位置来显示天气
就不应该请求用户的邮箱、电话、地址等信息
```

**💡 实施策略**

| 应用类型 | 推荐Scope | 理由 |
|----------|-----------|------|
| **天气应用** | `openid` | 只需要识别用户身份 |
| **社交应用** | `openid profile` | 需要展示用户头像和昵称 |
| **电商应用** | `openid profile email address` | 需要联系和配送信息 |
| **企业应用** | `openid profile email` | 需要用于通知和沟通 |

### 6.2 敏感数据保护策略


**🚨 敏感数据分类**

```javascript
// 🔴 高敏感数据 - 严格保护
const highSensitive = [
  'id_card',          // 身份证号
  'passport',         // 护照号码
  'bank_account',     // 银行账号
  'salary',           // 工资信息
  'medical_info'      // 医疗信息
];

// 🟡 中敏感数据 - 谨慎处理
const mediumSensitive = [
  'phone_number',     // 电话号码
  'address',          // 详细地址
  'birthdate',        // 出生日期
  'real_name'         // 真实姓名
];

// 🟢 低敏感数据 - 相对安全
const lowSensitive = [
  'nickname',         // 昵称
  'avatar',           // 头像
  'theme_preference', // 主题偏好
  'language'          // 语言偏好
];
```

**🔒 保护措施**

1. **数据分级存储**
```javascript
// 不同敏感级别使用不同存储策略
const dataStorage = {
  // 高敏感：加密存储，限制访问
  highSensitive: {
    encryption: 'AES-256',
    access: 'admin-only',
    audit: true
  },
  
  // 中敏感：哈希处理，日志记录
  mediumSensitive: {
    hashing: 'SHA-256',
    access: 'authenticated',
    logging: true
  },
  
  // 低敏感：标准存储
  lowSensitive: {
    storage: 'standard',
    access: 'public'
  }
};
```

2. **Claims过滤机制**
```javascript
// 根据客户端等级过滤Claims
function filterClaimsByClientLevel(claims, clientLevel) {
  const allowedClaims = {
    'basic': ['sub', 'name', 'picture'],
    'standard': ['sub', 'name', 'email', 'picture'],
    'premium': ['sub', 'name', 'email', 'phone_number', 'address']
  };
  
  const allowed = allowedClaims[clientLevel] || allowedClaims['basic'];
  
  return Object.keys(claims)
    .filter(key => allowed.includes(key))
    .reduce((obj, key) => {
      obj[key] = claims[key];
      return obj;
    }, {});
}
```

### 6.3 隐私保护实践


**🎯 用户控制权**

```javascript
// 让用户控制信息共享
const privacySettings = {
  profile: {
    name: { share: true, level: 'public' },
    email: { share: true, level: 'authenticated' },
    phone: { share: false, level: 'private' },
    address: { share: true, level: 'trusted-apps-only' }
  }
};

// 应用请求信息时展示清楚的说明
const consentScreen = {
  requestedScopes: ['openid', 'profile', 'email'],
  purposes: {
    profile: '用于显示您的头像和昵称',
    email: '用于发送重要通知和找回密码',
  },
  dataRetention: '您的信息将保存1年，可随时删除',
  thirdPartySharing: '我们不会与第三方共享您的信息'
};
```

---

## 7. 🎫 Bearer Token使用


### 7.1 什么是Bearer Token


**🔸 通俗理解**
```
Bearer Token就像"通行证"：

想象你去银行办业务：
1. 先在大厅取号（获取Token）
2. 拿着号码牌去窗口（使用Token）
3. 工作人员看到号码牌就知道你有资格办业务

Bearer Token就是这个"号码牌"，证明你有权限访问用户信息
```

**💡 Bearer Token的特点**
- 🎫 **持票人有效**：谁持有Token谁就能使用
- ⏰ **有时间限制**：Token有过期时间
- 🔒 **权限受限**：只能访问授权范围内的信息

### 7.2 在UserInfo调用中的使用


**🔸 标准使用方式**

```javascript
// 1. 标准的Authorization Header
const response = await fetch('https://auth.example.com/userinfo', {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer ' + accessToken,
    'Accept': 'application/json'
  }
});
```

> 💡 **重要提醒**: "Bearer "后面有一个空格，这是标准格式

**🔸 完整调用流程**

```javascript
// 完整的UserInfo获取示例
async function getUserInfo(accessToken) {
  try {
    // 步骤1: 发起请求
    const response = await fetch('https://auth.example.com/userinfo', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'  // 确保获取最新信息
      }
    });
    
    // 步骤2: 检查响应状态
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    // 步骤3: 解析响应数据
    const userInfo = await response.json();
    
    console.log('用户信息获取成功:', userInfo);
    return userInfo;
    
  } catch (error) {
    console.error('获取用户信息失败:', error.message);
    throw error;
  }
}
```

### 7.3 Token安全使用


**🚨 安全注意事项**

1. **Token存储安全**
```javascript
// ✅ 推荐：安全存储
// 浏览器环境：使用httpOnly Cookie
document.cookie = `access_token=${token}; HttpOnly; Secure; SameSite=Strict`;

// 移动应用：使用安全存储
// iOS: Keychain
// Android: EncryptedSharedPreferences

// ❌ 不推荐：不安全的存储
localStorage.setItem('access_token', token);  // 容易被XSS攻击
```

2. **Token传输安全**
```javascript
// ✅ 安全传输
const config = {
  url: 'https://auth.example.com/userinfo',  // 必须使用HTTPS
  headers: {
    'Authorization': `Bearer ${token}`
  }
};

// ❌ 不安全：HTTP传输
// http://auth.example.com/userinfo  // 明文传输，容易被截获
```

3. **Token验证**
```javascript
// 使用前验证Token是否有效
function isTokenValid(token) {
  if (!token) return false;
  
  try {
    // 简单解析JWT格式的Token（仅用于检查格式）
    const parts = token.split('.');
    if (parts.length !== 3) return false;
    
    // 检查payload中的过期时间
    const payload = JSON.parse(atob(parts[1]));
    const now = Math.floor(Date.now() / 1000);
    
    return payload.exp > now;  // 检查是否过期
  } catch (error) {
    return false;
  }
}

// 使用示例
if (isTokenValid(accessToken)) {
  const userInfo = await getUserInfo(accessToken);
} else {
  console.log('Token无效，需要重新获取');
  // 重新进行授权流程
}
```

### 7.4 Token错误处理


**🔧 常见错误及处理**

```javascript
async function getUserInfoWithRetry(accessToken, maxRetries = 3) {
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      const response = await fetch('/userinfo', {
        headers: { 'Authorization': `Bearer ${accessToken}` }
      });
      
      // 根据不同状态码处理
      switch (response.status) {
        case 200:
          return await response.json();
          
        case 401:
          console.log('Token无效或已过期');
          throw new Error('INVALID_TOKEN');
          
        case 403:
          console.log('Token权限不足');
          throw new Error('INSUFFICIENT_SCOPE');
          
        case 429:
          console.log('请求过于频繁，等待重试');
          await new Promise(resolve => setTimeout(resolve, 1000 * (retries + 1)));
          retries++;
          continue;
          
        case 500:
          console.log('服务器错误，稍后重试');
          retries++;
          await new Promise(resolve => setTimeout(resolve, 2000));
          continue;
          
        default:
          throw new Error(`未知错误: ${response.status}`);
      }
    } catch (error) {
      if (retries === maxRetries - 1) {
        throw error;  // 最后一次重试失败，抛出错误
      }
      retries++;
    }
  }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的关键概念


```
🔸 UserInfo端点：获取用户详细信息的标准接口
🔸 标准Scope：openid(必需)、profile、email、address、phone
🔸 标准Claims：用户信息的标准字段，如name、email、picture等
🔸 自定义Claims：业务特定的用户信息字段
🔸 Bearer Token：访问UserInfo端点的认证凭证
🔸 最小化原则：只请求必要的用户信息，保护隐私
```

### 8.2 核心流程理解


**🔄 UserInfo获取流程**
```
1. 应用请求特定Scope的授权
   ↓
2. 用户同意授权，获得Access Token
   ↓
3. 使用Bearer Token调用UserInfo端点
   ↓
4. 获得Scope范围内的用户Claims信息
```

### 8.3 实际应用指导


**🎯 Scope选择建议**

| 应用场景 | 推荐Scope组合 | 获得的信息 |
|----------|---------------|-----------|
| **基础登录** | `openid` | 用户标识 |
| **社交应用** | `openid profile` | 姓名、头像、昵称 |
| **通知系统** | `openid profile email` | 基本信息 + 邮箱 |
| **配送服务** | `openid profile email address phone` | 完整联系信息 |

**🛡️ 安全实践要点**

```
Token安全：
✅ 使用HTTPS传输
✅ 安全存储Token
✅ 验证Token有效性
✅ 处理Token过期

数据保护：
✅ 最小化信息收集
✅ 敏感数据加密存储
✅ 用户控制信息共享
✅ 定期清理过期数据
```

### 8.4 常见问题解答


**❓ 为什么要分离ID Token和UserInfo端点？**
- ID Token：快速身份验证，包含基本信息
- UserInfo：详细信息获取，支持实时更新

**❓ 如何处理用户信息变更？**
- ID Token中的信息是静态的（签发时确定）
- UserInfo端点返回最新的用户信息

**❓ 自定义Claims如何确保兼容性？**
- 使用命名空间前缀避免冲突
- 文档化Claims的含义和用法
- 提供向后兼容性支持

**核心记忆要点**：
- UserInfo端点是获取用户详细信息的标准方式
- Scope控制可获取的信息范围，遵循最小化原则
- Bearer Token是访问凭证，需要安全使用和存储
- 标准Claims满足基本需求，自定义Claims支持业务扩展
- 数据保护和用户隐私是设计时的重要考虑