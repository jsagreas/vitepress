---
title: 9、授权模型与策略引擎
---
## 📚 目录

1. [授权模型对比与选择](#1-授权模型对比与选择)
2. [分层授权架构设计](#2-分层授权架构设计)
3. [策略引擎核心概念](#3-策略引擎核心概念)
4. [Policy管理与治理](#4-policy管理与治理)
5. [领域权限建模实践](#5-领域权限建模实践)
6. [策略存储与动态加载](#6-策略存储与动态加载)
7. [常用工具实战](#7-常用工具实战)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 授权模型对比与选择


### 1.1 RBAC（基于角色的访问控制）


**🔸 核心概念**
RBAC就是**通过角色来管理权限**，简单理解就是：给用户分配角色，给角色分配权限。

```
用户 → 角色 → 权限

例子：
张三（用户）→ 管理员（角色）→ 查看/编辑/删除（权限）
李四（用户）→ 普通员工（角色）→ 查看（权限）
```

**🏗️ RBAC模型结构**
```
┌─────────┐    ┌─────────┐    ┌─────────┐
│  用户    │────│  角色    │────│  权限    │
│ User    │    │ Role    │    │Permission│
└─────────┘    └─────────┘    └─────────┘
     │              │              │
 ┌───────┐      ┌───────┐      ┌───────┐
 │ 张三   │      │管理员  │      │增删改查│
 │ 李四   │      │编辑者  │      │查看    │
 │ 王五   │      │访客    │      │下载    │
 └───────┘      └───────┘      └───────┘
```

**💡 适用场景**
- ✅ **组织结构清晰**：公司有明确的部门和职位
- ✅ **权限相对固定**：不经常变化的权限体系
- ✅ **用户规模中等**：几百到几万用户
- ✅ **业务逻辑简单**：不需要复杂的条件判断

**📝 简单代码示例**
```java
// RBAC权限检查
public boolean checkPermission(String userId, String resource, String action) {
    // 1. 获取用户角色
    List<String> userRoles = getUserRoles(userId);
    
    // 2. 检查角色是否有对应权限
    for (String role : userRoles) {
        if (roleHasPermission(role, resource, action)) {
            return true;
        }
    }
    return false;
}
```

### 1.2 ABAC（基于属性的访问控制）


**🔸 核心概念**
ABAC是**基于各种属性来决定权限**，不是简单的角色，而是考虑用户属性、资源属性、环境属性等。

```
权限决策 = 用户属性 + 资源属性 + 环境属性 + 动作属性

例子：
只有"财务部门"的"经理级别"用户，在"工作时间"内，
可以"查看"标记为"财务数据"的文件
```

**🏗️ ABAC属性维度**
```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│用户属性   │    │资源属性   │    │环境属性   │    │动作属性   │
│Subject   │    │Resource  │    │Environment│   │Action    │
└──────────┘    └──────────┘    └──────────┘    └──────────┘
     │               │               │               │
 ┌───────┐       ┌───────┐       ┌───────┐       ┌───────┐
 │部门    │       │分类    │       │时间    │       │操作    │
 │级别    │       │敏感度  │       │地点    │       │方式    │
 │项目组  │       │所有者  │       │设备    │       │目的    │
 └───────┘       └───────┘       └───────┘       └───────┘
```

**💡 适用场景**
- ✅ **复杂业务规则**：需要多种条件组合判断
- ✅ **动态权限控制**：权限需要根据实时情况变化
- ✅ **精细化管控**：需要到字段级别的权限控制
- ✅ **合规要求高**：金融、医疗等严格合规行业

**📝 策略示例**
```yaml
# ABAC策略示例
policy:
  name: "财务数据访问策略"
  rule: |
    user.department == "finance" AND
    user.level >= "manager" AND
    resource.type == "financial_report" AND
    time.hour >= 9 AND time.hour <= 18
  effect: "allow"
```

### 1.3 ReBAC（基于关系的访问控制）


**🔸 核心概念**
ReBAC是**基于对象之间关系**来决定权限，重点关注"谁和谁有什么关系"。

```
权限 = 用户与资源的关系

例子：
- 文档的创建者可以编辑
- 项目的成员可以查看
- 组织的管理员可以管理下级
```

**🏗️ ReBAC关系图谱**
```
用户关系网络：
     张三(CEO)
       │
   ┌───┴───┐
李四(CTO)  王五(CFO)
   │         │
 赵六      钱七
(开发)    (财务)

权限通过关系传递：
张三 → 管理所有人
李四 → 管理技术团队
王五 → 管理财务团队
```

**💡 适用场景**
- ✅ **社交网络**：基于好友、关注关系的权限
- ✅ **协作平台**：基于项目成员关系的权限
- ✅ **层级组织**：基于上下级关系的权限
- ✅ **内容平台**：基于创作者和内容关系的权限

### 1.4 三种模型对比总结


| 特性 | **RBAC** | **ABAC** | **ReBAC** |
|------|---------|----------|-----------|
| **复杂度** | `🟢 简单` | `🔴 复杂` | `🟡 中等` |
| **灵活性** | `🔴 较低` | `🟢 极高` | `🟡 中等` |
| **性能** | `🟢 很好` | `🔴 较慢` | `🟡 中等` |
| **维护成本** | `🟢 较低` | `🔴 较高` | `🟡 中等` |
| **适用规模** | `中小型` | `大型` | `中型` |
| **学习成本** | `🟢 很低` | `🔴 较高` | `🟡 中等` |

**🎯 选择建议**
- **初创公司/简单业务**：选择 RBAC
- **复杂业务/合规要求**：选择 ABAC  
- **社交/协作平台**：选择 ReBAC

---

## 2. 🏗️ 分层授权架构设计


### 2.1 分层授权的核心思想


**🔸 为什么需要分层**
在微服务架构中，如果每个服务都做完整的权限检查，会导致：
- **性能问题**：每次都要查询完整权限
- **一致性问题**：各服务权限逻辑可能不一致  
- **维护困难**：权限逻辑分散在各个服务中

**💡 分层解决方案**
```
粗粒度检查（网关层）+ 细粒度检查（服务层）

就像公司门禁：
1. 大门：检查是否是公司员工（粗粒度）
2. 各部门门：检查是否有部门权限（细粒度）
```

### 2.2 网关层粗粒度授权


**🔸 网关层职责**
- **身份验证**：确认用户身份（JWT验证）
- **基础授权**：检查用户是否有访问服务的基本权限
- **路由权限**：哪些API路径用户可以访问

**🌐 网关授权流程**
```
客户端请求 → 网关 → 后端服务

网关检查内容：
┌─────────────────┐
│ 1. Token是否有效 │
├─────────────────┤
│ 2. 用户是否激活  │  
├─────────────────┤
│ 3. 是否有服务权限 │
├─────────────────┤
│ 4. API路径权限   │
└─────────────────┘
```

**📝 网关权限配置示例**
```yaml
# API网关权限配置
routes:
  - path: "/api/user/**"
    service: "user-service" 
    auth:
      required: true
      roles: ["user", "admin"]
      
  - path: "/api/admin/**"
    service: "admin-service"
    auth:
      required: true  
      roles: ["admin"]
      permissions: ["admin.read"]
```

### 2.3 服务层细粒度授权


**🔸 服务层职责**
- **业务权限**：具体的业务操作权限
- **数据权限**：用户只能操作自己的数据
- **字段权限**：某些敏感字段的访问控制

**🔧 服务内权限检查**
```java
@RestController
public class OrderController {
    
    @GetMapping("/orders/{orderId}")
    @PreAuthorize("hasPermission(#orderId, 'ORDER', 'READ')")
    public Order getOrder(@PathVariable String orderId) {
        // 业务逻辑
        return orderService.getById(orderId);
    }
    
    @DeleteMapping("/orders/{orderId}")  
    @PreAuthorize("hasRole('ADMIN') or @orderService.isOwner(#orderId, authentication.name)")
    public void deleteOrder(@PathVariable String orderId) {
        orderService.delete(orderId);
    }
}
```

### 2.4 分层授权的协作模式


**🔄 协作流程图**
```
请求流程：
客户端 → 网关 → 服务A → 服务B

权限检查点：
┌─────────┐  粗粒度检查   ┌─────────┐  细粒度检查   ┌─────────┐
│  网关    │ ────────→   │ 服务A    │ ────────→   │ 服务B    │  
└─────────┘              └─────────┘              └─────────┘
     │                        │                        │
  身份+路由权限              业务权限                数据权限
```

**⚡ 性能优化策略**
```
1. 权限缓存：网关缓存用户基本权限信息
2. 权限传递：网关在请求头中传递权限信息
3. 权限合并：避免重复的权限查询
```

**📝 权限传递示例**
```java
// 网关添加权限头
public class AuthGatewayFilter {
    public Mono<Void> filter(ServerWebExchange exchange, 
                             GatewayFilterChain chain) {
        String token = getToken(exchange.getRequest());
        UserInfo user = parseToken(token);
        
        // 将权限信息添加到请求头
        ServerHttpRequest request = exchange.getRequest()
            .mutate()
            .header("X-User-Id", user.getUserId())
            .header("X-User-Roles", String.join(",", user.getRoles()))
            .header("X-User-Permissions", String.join(",", user.getPermissions()))
            .build();
            
        return chain.filter(exchange.mutate().request(request).build());
    }
}
```

---

## 3. 🤖 策略引擎核心概念


### 3.1 什么是策略引擎


**🔸 通俗理解**
策略引擎就像一个**专门的决策机器**，你告诉它规则，它帮你做判断。

```
传统方式：代码中写死权限逻辑
if (user.role == "admin" && resource.type == "sensitive") {
    return true;
}

策略引擎方式：把规则外置
规则文件：admin可以访问所有sensitive资源
引擎：根据规则文件做决策
```

**💡 策略引擎的价值**
- **规则外置**：不用修改代码就能改变权限逻辑
- **统一管理**：所有权限规则集中管理
- **灵活配置**：支持复杂的条件组合
- **易于审计**：权限决策过程可追溯

### 3.2 PDP/PEP 模式详解


**🔸 核心组件解释**

**PDP (Policy Decision Point) - 策略决策点**
```
PDP = 大脑，专门做决策

功能：
- 接收权限询问
- 根据策略规则计算
- 返回允许/拒绝的决定
```

**PEP (Policy Enforcement Point) - 策略执行点**  
```
PEP = 门卫，负责执行

功能：
- 拦截用户请求
- 向PDP询问是否允许
- 根据PDP决策执行放行/拒绝
```

**🏗️ PDP/PEP架构图**
```
┌─────────┐    请求     ┌─────────┐    询问     ┌─────────┐
│  用户    │ ────────→  │  PEP    │ ────────→  │  PDP    │
└─────────┘            │(门卫)    │            │(大脑)    │
                       └─────────┘            └─────────┘
                            │                       │
                            ↓                       ↓
                      ┌─────────┐              ┌─────────┐
                      │执行决策  │              │策略存储  │
                      │允许/拒绝 │              │规则库   │
                      └─────────┘              └─────────┘
```

**📝 交互流程示例**
```java
// PEP 示例（在网关或服务中）
public class PolicyEnforcementPoint {
    private PolicyDecisionPoint pdp;
    
    public boolean authorize(AuthRequest request) {
        // 1. PEP收到授权请求
        // 2. 构造询问信息发给PDP
        DecisionRequest decisionRequest = DecisionRequest.builder()
            .user(request.getUser())
            .resource(request.getResource()) 
            .action(request.getAction())
            .context(request.getContext())
            .build();
            
        // 3. PDP返回决策结果    
        Decision decision = pdp.evaluate(decisionRequest);
        
        // 4. PEP根据结果执行
        return decision.isPermitted();
    }
}
```

### 3.3 OPA/OPAL 基本概念


**🔸 OPA (Open Policy Agent)**
OPA是最流行的开源策略引擎，就像权限界的"瑞士军刀"。

**核心特点：**
- **通用性**：不只是权限，任何策略都能管
- **高性能**：用Go语言写的，速度很快  
- **标准化**：使用Rego语言写策略
- **轻量级**：可以嵌入到任何系统中

**🔸 OPAL (Open Policy Administration Layer)**
OPAL是OPA的管理层，解决OPA缺少的管理功能。

**核心功能：**
```
OPA解决：策略如何执行
OPAL解决：策略如何管理

OPAL = OPA + 策略管理 + 数据同步
```

**🏗️ OPA工作原理**
```
┌─────────┐    JSON请求    ┌─────────┐
│应用系统  │ ───────────→  │  OPA    │
└─────────┘              │引擎     │
                         └─────────┘
                              │
                              ↓ 读取策略
                         ┌─────────┐
                         │ Rego    │
                         │策略文件  │
                         └─────────┘
```

**📝 OPA策略示例**
```rego
# Rego策略语言示例
package example.authz

# 默认拒绝
default allow = false

# 管理员可以做任何事
allow {
    input.user.role == "admin"
}

# 用户只能访问自己的资源
allow {
    input.user.role == "user"
    input.resource.owner == input.user.id
    input.action == "read"
}

# 工作时间内才能访问敏感资源
allow {
    input.resource.type == "sensitive"
    is_work_hours
}

is_work_hours {
    hour := time.clock(time.now_ns())[0]
    hour >= 9
    hour <= 17
}
```

---

## 4. 📋 Policy管理与治理


### 4.1 版本化管理


**🔸 为什么需要版本化**
策略规则就像代码一样，需要版本管理：
- **变更追踪**：知道什么时候改了什么
- **回滚能力**：新策略有问题能快速恢复
- **环境隔离**：开发、测试、生产用不同版本

**📝 策略版本管理示例**
```yaml
# policy-v1.0.yaml
version: "1.0"
name: "user-access-policy"
description: "用户基础访问策略"
created: "2024-01-01T00:00:00Z"
rules:
  - name: "basic-user-access"
    condition: "user.role == 'user'"
    effect: "allow"
    resources: ["profile", "orders"]

---
# policy-v1.1.yaml  
version: "1.1"
name: "user-access-policy" 
description: "增加时间限制"
created: "2024-01-15T00:00:00Z"
parent_version: "1.0"
changes:
  - type: "add"
    description: "增加工作时间限制"
rules:
  - name: "basic-user-access"
    condition: "user.role == 'user' AND is_work_hours()"
    effect: "allow" 
    resources: ["profile", "orders"]
```

### 4.2 灰度发布与回滚


**🔸 策略灰度发布**
新策略不能一上线就全量发布，需要逐步验证。

```
灰度发布流程：
1. 先给1%用户使用新策略
2. 观察监控指标，没问题扩大到10%
3. 逐步扩大到50%，最后100%
```

**🔄 灰度发布架构**
```
┌─────────┐    路由决策    ┌─────────┐
│ 用户请求 │ ──────────→  │灰度控制器│
└─────────┘              └─────────┘
                              │
                    ┌─────────┼─────────┐
                    ↓         ↓         ↓
              ┌─────────┐┌─────────┐┌─────────┐
              │策略v1.0 ││策略v1.1 ││策略v2.0 │
              │  90%   ││   5%   ││   5%   │
              └─────────┘└─────────┘└─────────┘
```

**📝 灰度配置示例**
```yaml
# 策略灰度配置
policy_rollout:
  strategy: "canary"
  versions:
    - version: "v1.0"
      weight: 90
      stable: true
    - version: "v1.1" 
      weight: 5
      canary: true
    - version: "v2.0"
      weight: 5
      experimental: true
  
  rollback_conditions:
    - metric: "error_rate"
      threshold: 0.05
      action: "rollback"
    - metric: "response_time_p95"  
      threshold: 1000
      action: "rollback"
```

### 4.3 审计可追溯


**🔸 权限审计的重要性**
- **合规要求**：很多行业要求权限操作可审计
- **安全分析**：发现异常访问模式  
- **问题排查**：权限问题时能快速定位
- **责任追溯**：明确权限决策的依据

**📊 审计信息记录**
```
每次权限决策记录：
┌─────────────────┐
│ 时间：何时       │
├─────────────────┤  
│ 用户：谁         │
├─────────────────┤
│ 资源：访问什么    │
├─────────────────┤
│ 动作：做什么      │
├─────────────────┤
│ 结果：允许/拒绝   │
├─────────────────┤
│ 依据：哪个策略    │
├─────────────────┤
│ 环境：IP、设备等  │
└─────────────────┘
```

**📝 审计日志示例**
```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req-12345", 
  "user": {
    "id": "user123",
    "role": "manager",
    "department": "finance"
  },
  "resource": {
    "type": "financial_report",
    "id": "report-2024-Q1", 
    "classification": "confidential"
  },
  "action": "download",
  "decision": "allow",
  "policy_version": "v2.1",
  "matched_rules": [
    "finance-manager-access",
    "confidential-data-policy"
  ],
  "context": {
    "ip": "192.168.1.100",
    "user_agent": "Mozilla/5.0...",
    "time_of_day": "work_hours"
  },
  "evaluation_time_ms": 15
}
```

---

## 5. 🎯 领域权限建模实践


### 5.1 资源建模


**🔸 什么是资源**
资源就是系统中需要保护的"东西"，可以是具体的数据，也可以是抽象的功能。

**📋 资源分类与建模**
```
数据资源：
┌─────────────┐
│ 用户信息     │ → /users/{id}
├─────────────┤
│ 订单数据     │ → /orders/{id} 
├─────────────┤
│ 财务报表     │ → /reports/{type}/{id}
├─────────────┤
│ 系统配置     │ → /config/{module}
└─────────────┘

功能资源：
┌─────────────┐
│ 用户管理     │ → user_management
├─────────────┤  
│ 报表生成     │ → report_generation
├─────────────┤
│ 系统监控     │ → system_monitoring
└─────────────┘
```

**💡 资源建模最佳实践**
- **层次化**：按业务模块分层组织
- **标准化**：统一的命名规范
- **可扩展**：预留扩展空间
- **细粒度**：根据业务需要确定粒度

**📝 资源定义示例**
```yaml
# 资源定义配置
resources:
  user:
    type: "data"
    path: "/users/{userId}"
    attributes:
      - name: "department"
        type: "string"
      - name: "level"  
        type: "number"
      - name: "is_active"
        type: "boolean"
        
  financial_report:
    type: "data"
    path: "/reports/financial/{reportId}"
    attributes:
      - name: "classification"
        type: "enum"
        values: ["public", "internal", "confidential", "secret"]
      - name: "quarter"
        type: "string"
      - name: "amount_range"
        type: "enum" 
        values: ["low", "medium", "high"]
```

### 5.2 动作建模


**🔸 标准动作定义**
动作就是用户想要对资源进行的操作，通常遵循CRUD模式。

```
基础动作 (CRUD)：
┌─────────┐
│ Create  │ → 创建新资源
├─────────┤
│ Read    │ → 查看资源内容  
├─────────┤
│ Update  │ → 修改资源内容
├─────────┤  
│ Delete  │ → 删除资源
└─────────┘

扩展动作：
┌─────────┐
│ Execute │ → 执行操作
├─────────┤
│ Approve │ → 审批通过
├─────────┤ 
│ Export  │ → 导出数据
├─────────┤
│ Share   │ → 分享资源
└─────────┘
```

**📝 动作权限矩阵**
```
资源类型      Create  Read   Update  Delete  Export  Approve
用户信息        Admin   All    Owner   Admin    HR     Admin
订单数据        User    Owner  Owner   Admin   Finance  Manager  
财务报表        Finance Finance Finance  CFO    Finance   CFO
系统配置        Admin   Admin  Admin   Super    -      Super
```

### 5.3 条件建模


**🔸 条件的三大维度**

**租户条件（多租户隔离）**
```
示例：
- 用户只能看到自己租户的数据
- 管理员只能管理自己租户的用户
- 数据完全按租户隔离

条件表达：
tenant.id == resource.tenant_id
```

**组织条件（部门权限）**
```
示例：
- 财务部门只能访问财务数据
- HR部门只能管理人员信息  
- 销售部门只能看销售数据

条件表达：
user.department == resource.department OR
user.role == "super_admin"
```

**环境条件（时间、地点、设备）**
```
时间条件：
- 只在工作时间访问敏感资源
- 周末禁止某些操作
- 特定时间段的维护窗口

地点条件：  
- 办公网络内才能访问
- 海外IP限制访问
- VPN连接要求

设备条件：
- 移动端限制某些功能
- 需要可信设备认证
- 设备指纹验证
```

**📝 复合条件示例**
```yaml
# 复杂权限条件配置
conditions:
  financial_data_access:
    description: "财务数据访问条件"
    logic: "AND"
    rules:
      - type: "user_attribute"
        field: "department"
        operator: "equals"
        value: "finance"
        
      - type: "time_range" 
        start_hour: 9
        end_hour: 18
        weekdays_only: true
        
      - type: "resource_attribute"
        field: "classification"
        operator: "in"
        values: ["internal", "confidential"]
        
      - type: "network"
        allowed_networks: 
          - "10.0.0.0/8"
          - "192.168.0.0/16"
```

---

## 6. 💾 策略存储与动态加载


### 6.1 策略存储方案


**🔸 存储选择对比**

**关系数据库存储**
```
优点：
✅ 事务支持，数据一致性好
✅ 复杂查询能力强
✅ 开发者熟悉，维护简单

缺点：  
❌ 性能相对较低
❌ 扩展性有限
❌ 策略格式受限
```

**NoSQL存储**
```
优点：
✅ 性能好，扩展性强
✅ 支持灵活的数据格式  
✅ 适合大规模部署

缺点：
❌ 一致性相对较弱
❌ 复杂查询能力有限
❌ 学习成本高
```

**文件存储**
```
优点：
✅ 配置简单，易于版本控制
✅ 支持Git等版本管理
✅ 人工可读性好

缺点：
❌ 多实例同步复杂
❌ 动态更新困难  
❌ 不适合大规模部署
```

### 6.2 动态加载机制


**🔸 实时更新的重要性**
在微服务环境中，策略需要能够实时更新，不能重启服务。

```
传统方式：策略改变 → 重启服务 → 影响业务
动态加载：策略改变 → 热更新 → 业务无感知
```

**🔄 动态加载架构**
```
策略管理中心 → 消息队列 → 各个服务实例

更新流程：
┌─────────────┐    发布事件    ┌─────────────┐
│ 策略管理中心  │ ──────────→  │  消息队列    │
└─────────────┘              └─────────────┘
                                   │
                           ┌───────┼───────┐
                           ↓       ↓       ↓
                      ┌─────────┐┌─────────┐┌─────────┐
                      │服务实例1││服务实例2││服务实例3│  
                      │更新策略 ││更新策略 ││更新策略 │
                      └─────────┘└─────────┘└─────────┘
```

**📝 动态加载实现示例**
```java
@Component
public class PolicyManager {
    private Map<String, Policy> policyCache = new ConcurrentHashMap<>();
    
    @EventListener
    public void handlePolicyUpdate(PolicyUpdateEvent event) {
        String policyId = event.getPolicyId();
        
        if (event.getType() == EventType.UPDATE) {
            // 更新策略
            Policy newPolicy = loadPolicy(policyId);
            policyCache.put(policyId, newPolicy);
            log.info("策略 {} 已更新", policyId);
            
        } else if (event.getType() == EventType.DELETE) {
            // 删除策略
            policyCache.remove(policyId);
            log.info("策略 {} 已删除", policyId);
        }
        
        // 通知策略引擎刷新
        policyEngine.refreshPolicies(policyCache.values());
    }
    
    // 策略缓存预热
    @PostConstruct
    public void initPolicies() {
        List<Policy> policies = policyRepository.findAll();
        policies.forEach(policy -> 
            policyCache.put(policy.getId(), policy)
        );
        log.info("加载了 {} 个策略", policies.size());
    }
}
```

### 6.3 缓存与性能优化


**🔸 多级缓存策略**
```
L1缓存：应用内存缓存（最快）
L2缓存：Redis分布式缓存（较快）
L3存储：数据库持久化存储（较慢）

查询流程：
内存缓存 → 分布式缓存 → 数据库 → 缓存回写
```

**⚡ 性能优化技巧**
- **预编译策略**：启动时编译策略，运行时直接执行
- **批量加载**：一次加载多个相关策略
- **增量更新**：只更新变化的策略，不是全量替换
- **异步更新**：策略更新不阻塞业务请求

---

## 7. 🛠️ 常用工具实战


### 7.1 OPA (Open Policy Agent) 实战


**🔸 OPA快速开始**

**安装OPA**
```bash
# 下载OPA二进制文件
curl -L -o opa https://github.com/open-policy-agent/opa/releases/download/v0.58.0/opa_linux_amd64
chmod +x opa
```

**📝 编写第一个策略**
```rego
# api_auth.rego
package httpapi.authz

# 导入未来的关键词
import future.keywords.if

# 默认拒绝所有请求
default allow := false

# 允许GET /health 健康检查
allow if {
    input.method == "GET"
    input.path == ["health"]
}

# 只有admin可以访问用户管理API
allow if {
    input.method == "POST"
    input.path[0] == "users"  
    input.user.role == "admin"
}

# 用户只能访问自己的信息
allow if {
    input.method == "GET"
    input.path[0] == "users"
    input.path[1] == input.user.id
}

# 工作时间限制
work_hours if {
    hour := time.clock(time.now_ns())[0]
    hour >= 9
    hour <= 18
}
```

**🚀 在应用中集成OPA**
```java
@Service  
public class OPAAuthorizationService {
    private final OkHttpClient httpClient;
    private final String opaUrl = "http://localhost:8181/v1/data/httpapi/authz/allow";
    
    public boolean isAuthorized(AuthorizationRequest request) {
        try {
            // 构建OPA查询请求
            JsonObject input = new JsonObject();
            input.addProperty("method", request.getMethod());
            input.add("path", gson.toJsonTree(request.getPath()));
            
            JsonObject user = new JsonObject();
            user.addProperty("id", request.getUserId());
            user.addProperty("role", request.getUserRole());
            input.add("user", user);
            
            JsonObject query = new JsonObject();
            query.add("input", input);
            
            // 发送请求到OPA
            RequestBody body = RequestBody.create(
                MediaType.parse("application/json"), 
                query.toString()
            );
            
            Request opaRequest = new Request.Builder()
                .url(opaUrl)
                .post(body)
                .build();
                
            Response response = httpClient.newCall(opaRequest).execute();
            
            if (response.isSuccessful()) {
                JsonObject result = gson.fromJson(response.body().string(), JsonObject.class);
                return result.get("result").getAsBoolean();
            }
            
            return false;
            
        } catch (Exception e) {
            log.error("OPA查询失败", e);
            return false; // 默认拒绝
        }
    }
}
```

### 7.2 Casbin 实战


**🔸 Casbin特点**
Casbin是另一个流行的授权库，特别适合RBAC场景。

**核心概念：**
- **Model**: 定义权限模型（RBAC、ABAC等）
- **Policy**: 具体的权限规则
- **简单易用**: API简洁，学习成本低

**📝 Casbin配置示例**
```ini
# rbac_model.conf - 定义RBAC模型
[request_definition]
r = sub, obj, act

[policy_definition]  
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
```

```csv
# rbac_policy.csv - 权限策略
p, admin, data1, read
p, admin, data1, write  
p, admin, data2, read
p, admin, data2, write

p, alice, data2, read
p, bob, data2, write

g, alice, data_group_admin
g, bob, data_group_admin
```

**🚀 Java中使用Casbin**
```java
@Service
public class CasbinAuthService {
    private Enforcer enforcer;
    
    @PostConstruct
    public void init() {
        // 初始化Casbin
        enforcer = new Enforcer("rbac_model.conf", "rbac_policy.csv");
        
        // 也可以使用数据库适配器
        // JDBCAdapter adapter = new JDBCAdapter("jdbc:mysql://localhost:3306/casbin");
        // enforcer = new Enforcer("rbac_model.conf", adapter);
    }
    
    public boolean checkPermission(String user, String resource, String action) {
        return enforcer.enforce(user, resource, action);
    }
    
    public void addPermission(String user, String resource, String action) {
        enforcer.addPolicy(user, resource, action);
    }
    
    public void addRoleForUser(String user, String role) {
        enforcer.addRoleForUser(user, role);
    }
}
```

### 7.3 工具选择建议


| 特性 | **OPA** | **Casbin** |
|------|---------|------------|
| **学习曲线** | `🔴 陡峭` | `🟢 平缓` |
| **灵活性** | `🟢 极高` | `🟡 中等` |  
| **性能** | `🟢 很好` | `🟢 很好` |
| **社区支持** | `🟢 活跃` | `🟢 活跃` |
| **语言支持** | `多语言` | `多语言` |
| **适用场景** | `复杂策略` | `RBAC为主` |

**🎯 选择建议**
- **复杂业务逻辑**：选择OPA，策略表达能力强
- **快速上手**：选择Casbin，API简单易用
- **标准RBAC**：两者都可以，Casbin更简单
- **云原生环境**：OPA生态更丰富

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 授权模型：RBAC适合简单场景，ABAC适合复杂业务，ReBAC适合关系型应用
🔸 分层授权：网关粗粒度检查 + 服务细粒度检查，提升性能和安全性
🔸 策略引擎：PDP负责决策，PEP负责执行，实现权限逻辑与业务逻辑分离
🔸 策略管理：版本化、灰度发布、审计追溯是企业级应用必备能力
🔸 权限建模：资源、动作、条件三要素，构建完整的权限体系
🔸 动态加载：策略实时更新，业务无感知，是微服务架构的关键需求
🔸 工具选择：OPA适合复杂场景，Casbin适合快速上手，根据需求选择
```

### 8.2 关键理解要点


**🔹 授权模型的选择原则**
```
业务复杂度决定模型选择：
- 简单业务 → RBAC
- 复杂条件 → ABAC  
- 关系驱动 → ReBAC

不要为了技术而技术，够用就好
```

**🔹 分层授权的核心价值**
```
性能与安全的平衡：
- 网关层：快速过滤无效请求
- 服务层：精确的业务权限控制
- 缓存策略：减少重复的权限查询

分工明确，各司其职
```

**🔹 策略引擎的实际价值**
```
不是为了炫技，而是为了：
- 权限逻辑外置，修改不需要改代码
- 统一管理，避免权限逻辑散落各处
- 可审计，满足合规要求
- 可测试，权限逻辑独立验证
```

### 8.3 实际应用建议


**🎯 渐进式实施策略**
```
第一阶段：简单RBAC + 基础分层
第二阶段：引入策略引擎 + 动态加载  
第三阶段：完整的ABAC + 审计体系
第四阶段：AI驱动的智能权限管理

不要一步到位，根据业务发展逐步演进
```

**🔧 工程实践要点**
```
性能考虑：
- 权限信息缓存策略
- 批量权限检查
- 异步权限更新

安全考虑：
- 默认拒绝原则
- 权限最小化原则  
- 定期权限审计

运维考虑：
- 权限变更的灰度发布
- 完整的监控和告警
- 权限问题的快速定位
```

**核心记忆**：
- 授权模型要根据业务复杂度选择，不是越复杂越好
- 分层授权是微服务权限架构的最佳实践
- 策略引擎的价值在于权限逻辑外置和统一管理
- 动态加载和版本管理是企业级应用的必备能力
- 工具选择要考虑团队能力和业务需求，不要盲目追求新技术