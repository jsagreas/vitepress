---
title: 12ã€JWTç”Ÿäº§ç¯å¢ƒå®æˆ˜
---
## ğŸ“š ç›®å½•

1. [JWTç”Ÿäº§ç¯å¢ƒæ ¸å¿ƒæ¦‚å¿µ](#1-JWTç”Ÿäº§ç¯å¢ƒæ ¸å¿ƒæ¦‚å¿µ)
2. [ç”¨æˆ·ç™»å½•æ¥å£å®ç°](#2-ç”¨æˆ·ç™»å½•æ¥å£å®ç°)
3. [JWTç”Ÿæˆä¸ç­¾å‘æœºåˆ¶](#3-JWTç”Ÿæˆä¸ç­¾å‘æœºåˆ¶)
4. [å‰ç«¯Tokenæºå¸¦ä¸è¯·æ±‚](#4-å‰ç«¯Tokenæºå¸¦ä¸è¯·æ±‚)
5. [åˆ·æ–°Tokenæœºåˆ¶å®ç°](#5-åˆ·æ–°Tokenæœºåˆ¶å®ç°)
6. [Tokenæ³¨é”€ä¸ä½œåºŸå¤„ç†](#6-Tokenæ³¨é”€ä¸ä½œåºŸå¤„ç†)
7. [å®Œæ•´å®æˆ˜ç¤ºä¾‹](#7-å®Œæ•´å®æˆ˜ç¤ºä¾‹)
8. [ç”Ÿäº§ç¯å¢ƒé…ç½®è¦ç‚¹](#8-ç”Ÿäº§ç¯å¢ƒé…ç½®è¦ç‚¹)
9. [è´Ÿè½½å‡è¡¡ä¸‹çš„JWTå¤„ç†](#9-è´Ÿè½½å‡è¡¡ä¸‹çš„JWTå¤„ç†)
10. [Tokené»‘åå•å®ç°æ–¹æ¡ˆ](#10-Tokené»‘åå•å®ç°æ–¹æ¡ˆ)
11. [æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–](#11-æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–)
12. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#12-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ¯ JWTç”Ÿäº§ç¯å¢ƒæ ¸å¿ƒæ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯ç”Ÿäº§ç¯å¢ƒä¸‹çš„JWT

åœ¨å®é™…é¡¹ç›®ä¸­ï¼ŒJWTä¸åªæ˜¯ç®€å•çš„Tokenï¼Œå®ƒæ˜¯ä¸€å¥—**å®Œæ•´çš„èº«ä»½è®¤è¯è§£å†³æ–¹æ¡ˆ**ã€‚

> ğŸ’¡ **é€šä¿—ç†è§£**ï¼šå°±åƒé“¶è¡Œå¡ä¸€æ ·ï¼Œä¸ä»…è¦èƒ½è¯æ˜ä½ çš„èº«ä»½ï¼Œè¿˜è¦ä¿è¯å®‰å…¨ã€èƒ½åˆ·æ–°ã€èƒ½æ³¨é”€ï¼Œè€Œä¸”åœ¨å¤šä¸ªé“¶è¡Œç½‘ç‚¹ï¼ˆæœåŠ¡å™¨ï¼‰éƒ½èƒ½ç”¨ã€‚

**ç”Ÿäº§ç¯å¢ƒJWTçš„ç‰¹ç‚¹**ï¼š
- ğŸ” **å®‰å…¨æ€§**ï¼šä¸èƒ½è¢«ä¼ªé€ æˆ–ç¯¡æ”¹
- âš¡ **æ€§èƒ½**ï¼šå¿«é€ŸéªŒè¯ï¼Œä¸é¢‘ç¹æŸ¥æ•°æ®åº“
- ğŸ”„ **å¯åˆ·æ–°**ï¼šTokenè¿‡æœŸå‰è‡ªåŠ¨ç»­æœŸ
- ğŸš« **å¯æ³¨é”€**ï¼šç”¨æˆ·é€€å‡ºæ—¶ç«‹å³å¤±æ•ˆ
- ğŸ“Š **å¯ç›‘æ§**ï¼šèƒ½è¿½è¸ªä½¿ç”¨æƒ…å†µ

### 1.2 JWTåœ¨å®Œæ•´è®¤è¯æµç¨‹ä¸­çš„ä½œç”¨


```
ç”¨æˆ·è®¤è¯å®Œæ•´æµç¨‹ï¼š

æ­¥éª¤1: ç”¨æˆ·ç™»å½•
ç”¨æˆ· â”€â”€â”€[è´¦å·å¯†ç ]â”€â”€â”€> åç«¯éªŒè¯ â”€â”€â”€> ç”ŸæˆJWT

æ­¥éª¤2: æ­£å¸¸è¯·æ±‚  
ç”¨æˆ· â”€â”€â”€[æºå¸¦JWT]â”€â”€â”€> åç«¯éªŒè¯ â”€â”€â”€> è¿”å›æ•°æ®

æ­¥éª¤3: Tokenåˆ·æ–°
ç”¨æˆ· â”€â”€â”€[refreshToken]â”€â”€â”€> åç«¯éªŒè¯ â”€â”€â”€> æ–°JWT

æ­¥éª¤4: ç”¨æˆ·æ³¨é”€
ç”¨æˆ· â”€â”€â”€[æ³¨é”€è¯·æ±‚]â”€â”€â”€> åç«¯å¤„ç† â”€â”€â”€> Tokenå¤±æ•ˆ
```

### 1.3 ç”Ÿäº§ç¯å¢ƒéœ€è¦è§£å†³çš„æ ¸å¿ƒé—®é¢˜


**ğŸ”¸ å®‰å…¨é—®é¢˜**
- Tokenè¢«ç›—ç”¨æ€ä¹ˆåŠï¼Ÿ
- å¦‚ä½•é˜²æ­¢Tokenè¢«ç¯¡æ”¹ï¼Ÿ
- æ•æ„Ÿä¿¡æ¯æ³„éœ²å¦‚ä½•é¿å…ï¼Ÿ

**ğŸ”¸ æ€§èƒ½é—®é¢˜**  
- å¤§é‡ç”¨æˆ·åŒæ—¶éªŒè¯Token
- æ•°æ®åº“æŸ¥è¯¢å‹åŠ›
- å†…å­˜å ç”¨æ§åˆ¶

**ğŸ”¸ å¯ç”¨æ€§é—®é¢˜**
- Tokenè¿‡æœŸå¦‚ä½•æ— æ„Ÿåˆ·æ–°ï¼Ÿ
- ç”¨æˆ·æ³¨é”€å¦‚ä½•ç«‹å³ç”Ÿæ•ˆï¼Ÿ
- å¤šæœåŠ¡å™¨å¦‚ä½•åŒæ­¥çŠ¶æ€ï¼Ÿ

---

## 2. ğŸ‘¤ ç”¨æˆ·ç™»å½•æ¥å£å®ç°


### 2.1 ç™»å½•æ¥å£çš„æ ¸å¿ƒèŒè´£

ç”¨æˆ·ç™»å½•æ¥å£ä¸åªæ˜¯éªŒè¯å¯†ç ï¼Œå®ƒè¦å®Œæˆ**èº«ä»½éªŒè¯ + Tokenç­¾å‘**çš„å®Œæ•´æµç¨‹ã€‚

> ğŸ“– **æ¦‚å¿µè§£é‡Š**ï¼šç™»å½•æ¥å£å°±åƒæœºåœºå®‰æ£€ï¼Œä¸ä»…è¦éªŒè¯ä½ çš„èº«ä»½è¯ï¼Œè¿˜è¦ç»™ä½ å‘ç™»æœºç‰Œï¼ˆJWT Tokenï¼‰ï¼Œè®©ä½ åç»­èƒ½æ­£å¸¸ç™»æœºï¼ˆè®¿é—®å—ä¿æŠ¤çš„æ¥å£ï¼‰ã€‚

### 2.2 Spring Bootç™»å½•æ¥å£å®ç°


```java
@RestController
@RequestMapping("/auth")
public class AuthController {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private JwtTokenUtil jwtUtil;
    
    /**
     * ç”¨æˆ·ç™»å½•æ¥å£
     */
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        
        // 1. éªŒè¯ç”¨æˆ·èº«ä»½
        User user = userService.validateUser(
            request.getUsername(), 
            request.getPassword()
        );
        
        if (user == null) {
            return ResponseEntity.status(401)
                .body(new ApiResponse("ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯"));
        }
        
        // 2. ç”ŸæˆJWT Token
        String accessToken = jwtUtil.generateAccessToken(user);
        String refreshToken = jwtUtil.generateRefreshToken(user);
        
        // 3. è®°å½•ç™»å½•ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
        userService.recordLoginTime(user.getId());
        
        // 4. è¿”å›Tokenä¿¡æ¯
        LoginResponse response = new LoginResponse();
        response.setAccessToken(accessToken);
        response.setRefreshToken(refreshToken);
        response.setTokenType("Bearer");
        response.setExpiresIn(jwtUtil.getAccessTokenExpiration());
        
        return ResponseEntity.ok(response);
    }
}
```

**ğŸ“ è¯·æ±‚å“åº”ç¤ºä¾‹**ï¼š
```javascript
// ç™»å½•è¯·æ±‚
{
  "username": "john@example.com",
  "password": "123456"
}

// ç™»å½•å“åº”
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "tokenType": "Bearer",
  "expiresIn": 3600
}
```

### 2.3 ç”¨æˆ·å¯†ç éªŒè¯çš„å®‰å…¨å®ç°


```java
@Service
public class UserService {
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    /**
     * éªŒè¯ç”¨æˆ·ç™»å½•
     * @param username ç”¨æˆ·å
     * @param rawPassword åŸå§‹å¯†ç ï¼ˆå‰ç«¯ä¼ æ¥çš„ï¼‰
     * @return éªŒè¯æˆåŠŸè¿”å›ç”¨æˆ·å¯¹è±¡ï¼Œå¤±è´¥è¿”å›null
     */
    public User validateUser(String username, String rawPassword) {
        
        // 1. æ ¹æ®ç”¨æˆ·åæŸ¥æ‰¾ç”¨æˆ·
        User user = userRepository.findByUsername(username);
        if (user == null) {
            return null; // ç”¨æˆ·ä¸å­˜åœ¨
        }
        
        // 2. éªŒè¯å¯†ç ï¼ˆé‡è¦ï¼šä½¿ç”¨åŠ å¯†å¯¹æ¯”ï¼‰
        boolean passwordMatches = passwordEncoder.matches(
            rawPassword,           // ç”¨æˆ·è¾“å…¥çš„åŸå§‹å¯†ç 
            user.getPassword()     // æ•°æ®åº“ä¸­çš„åŠ å¯†å¯†ç 
        );
        
        if (!passwordMatches) {
            return null; // å¯†ç é”™è¯¯
        }
        
        // 3. æ£€æŸ¥è´¦æˆ·çŠ¶æ€
        if (!user.isEnabled()) {
            throw new AccountDisabledException("è´¦æˆ·å·²è¢«ç¦ç”¨");
        }
        
        return user;
    }
}
```

> âš ï¸ **å®‰å…¨æé†’**ï¼šå¯†ç ç»å¯¹ä¸èƒ½æ˜æ–‡å­˜å‚¨å’Œä¼ è¾“ï¼å¿…é¡»ä½¿ç”¨BCryptç­‰å®‰å…¨çš„åŠ å¯†ç®—æ³•ã€‚

---

## 3. ğŸ”‘ JWTç”Ÿæˆä¸ç­¾å‘æœºåˆ¶


### 3.1 JWT Tokençš„ä¸¤ç§ç±»å‹

åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨**åŒTokenæœºåˆ¶**ï¼š

> ğŸ’¡ **å½¢è±¡æ¯”å–»**ï¼š
> - **Access Token**ï¼šåƒä¸´æ—¶é€šè¡Œè¯ï¼Œæ—¶é—´çŸ­ï¼ˆ15-30åˆ†é’Ÿï¼‰ï¼Œç”¨äºæ—¥å¸¸è®¿é—®
> - **Refresh Token**ï¼šåƒèº«ä»½è¯ï¼Œæ—¶é—´é•¿ï¼ˆ7-30å¤©ï¼‰ï¼Œä¸“é—¨ç”¨æ¥æ¢æ–°çš„é€šè¡Œè¯

```
åŒTokenå·¥ä½œæœºåˆ¶ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Access Token  â”‚    â”‚  Refresh Token   â”‚
â”‚   æœ‰æ•ˆæœŸ: 30åˆ†é’Ÿ â”‚    â”‚   æœ‰æ•ˆæœŸ: 7å¤©    â”‚
â”‚   ä½œç”¨: è®¿é—®æ¥å£ â”‚    â”‚   ä½œç”¨: åˆ·æ–°Token â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 JWTå·¥å…·ç±»å®ç°


```java
@Component
public class JwtTokenUtil {
    
    // ç­¾åå¯†é’¥ï¼ˆç”Ÿäº§ç¯å¢ƒåº”è¯¥ä»é…ç½®æ–‡ä»¶è¯»å–ï¼‰
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    // Access Tokenæœ‰æ•ˆæœŸï¼ˆ30åˆ†é’Ÿï¼‰
    @Value("${jwt.access-token-expiration:1800000}")
    private int accessTokenExpiration;
    
    // Refresh Tokenæœ‰æ•ˆæœŸï¼ˆ7å¤©ï¼‰  
    @Value("${jwt.refresh-token-expiration:604800000}")
    private int refreshTokenExpiration;
    
    /**
     * ç”Ÿæˆè®¿é—®Token
     */
    public String generateAccessToken(User user) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId());
        claims.put("username", user.getUsername());
        claims.put("roles", user.getRoles()); // ç”¨æˆ·è§’è‰²
        claims.put("tokenType", "access");    // Tokenç±»å‹
        
        return createToken(claims, accessTokenExpiration);
    }
    
    /**
     * ç”Ÿæˆåˆ·æ–°Token
     */
    public String generateRefreshToken(User user) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId());
        claims.put("tokenType", "refresh");   // æ ‡è®°ä¸ºåˆ·æ–°Token
        
        return createToken(claims, refreshTokenExpiration);
    }
    
    /**
     * åˆ›å»ºJWT Tokençš„æ ¸å¿ƒæ–¹æ³•
     */
    private String createToken(Map<String, Object> claims, int expiration) {
        return Jwts.builder()
                .setClaims(claims)                           // è®¾ç½®è½½è·
                .setIssuedAt(new Date())                     // ç­¾å‘æ—¶é—´
                .setExpiration(new Date(System.currentTimeMillis() + expiration)) // è¿‡æœŸæ—¶é—´
                .signWith(SignatureAlgorithm.HS256, jwtSecret) // ç­¾åç®—æ³•å’Œå¯†é’¥
                .compact();                                   // ç”Ÿæˆæœ€ç»ˆçš„JWTå­—ç¬¦ä¸²
    }
}
```

### 3.3 JWTä¸­åº”è¯¥åŒ…å«ä»€ä¹ˆä¿¡æ¯


> ğŸ”§ **å®è·µåŸåˆ™**ï¼šJWTä¸­åªæ”¾**å¿…è¦çš„ã€éæ•æ„Ÿçš„**èº«ä»½æ ‡è¯†ä¿¡æ¯ã€‚

**âœ… æ¨èåŒ…å«çš„ä¿¡æ¯**ï¼š
```json
{
  "userId": 12345,
  "username": "john",  
  "roles": ["user", "admin"],
  "tokenType": "access",
  "iat": 1640995200,
  "exp": 1640998800
}
```

**âŒ ä¸è¦åŒ…å«çš„ä¿¡æ¯**ï¼š
- å¯†ç ï¼ˆå“ªæ€•æ˜¯åŠ å¯†çš„ï¼‰
- é“¶è¡Œå¡å·ç­‰æ•æ„Ÿä¿¡æ¯
- è¿‡å¤šçš„ç”¨æˆ·è¯¦ç»†èµ„æ–™
- ç»å¸¸å˜åŠ¨çš„ä¸šåŠ¡æ•°æ®

---

## 4. ğŸŒ å‰ç«¯Tokenæºå¸¦ä¸è¯·æ±‚


### 4.1 å‰ç«¯å¦‚ä½•å­˜å‚¨å’Œä½¿ç”¨JWT


**Tokenå­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”**ï¼š

| å­˜å‚¨æ–¹å¼ | **å®‰å…¨æ€§** | **ä¾¿åˆ©æ€§** | **é€‚ç”¨åœºæ™¯** |
|---------|-----------|-----------|-------------|
| `localStorage` | â­â­â­ | â­â­â­â­â­ | ä¸€èˆ¬Webåº”ç”¨ |
| `sessionStorage` | â­â­â­ | â­â­â­â­ | å•é¡µé¢åº”ç”¨ |
| `httpOnly Cookie` | â­â­â­â­â­ | â­â­â­ | é«˜å®‰å…¨è¦æ±‚ |
| `å†…å­˜å˜é‡` | â­â­â­â­ | â­â­ | æ•æ„Ÿåº”ç”¨ |

> ğŸ’¡ **æ¨èåšæ³•**ï¼šAccess Tokenå­˜localStorageï¼ŒRefresh Tokenå­˜httpOnly Cookieã€‚

### 4.2 å‰ç«¯å‘é€è¯·æ±‚æºå¸¦Token


**JavaScript/Vueç¤ºä¾‹**ï¼š
```javascript
// 1. å­˜å‚¨Tokenï¼ˆç™»å½•æˆåŠŸåï¼‰
const loginResponse = await fetch('/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ username, password })
});

const tokens = await loginResponse.json();
localStorage.setItem('accessToken', tokens.accessToken);

// 2. å‘é€è¯·æ±‚æ—¶æºå¸¦Token
const apiRequest = async (url, options = {}) => {
  const token = localStorage.getItem('accessToken');
  
  const config = {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,  // æ ‡å‡†Beareræ ¼å¼
      ...options.headers
    }
  };
  
  const response = await fetch(url, config);
  
  // å¦‚æœTokenè¿‡æœŸï¼Œå°è¯•åˆ·æ–°
  if (response.status === 401) {
    await refreshToken();
    // é‡æ–°å‘é€åŸè¯·æ±‚
    return fetch(url, config);
  }
  
  return response;
};

// 3. ä½¿ç”¨ç¤ºä¾‹
const userData = await apiRequest('/api/user/profile');
```

**React Axiosç¤ºä¾‹**ï¼š
```javascript
import axios from 'axios';

// åˆ›å»ºaxioså®ä¾‹
const api = axios.create({
  baseURL: 'http://localhost:8080',
});

// è¯·æ±‚æ‹¦æˆªå™¨ - è‡ªåŠ¨æ·»åŠ Token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// å“åº”æ‹¦æˆªå™¨ - å¤„ç†Tokenè¿‡æœŸ
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // Tokenè¿‡æœŸï¼Œå°è¯•åˆ·æ–°
      await refreshToken();
      // é‡æ–°å‘é€åŸè¯·æ±‚
      return api.request(error.config);
    }
    return Promise.reject(error);
  }
);
```

### 4.3 åç«¯TokenéªŒè¯ä¸­é—´ä»¶


```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtTokenUtil jwtUtil;
    
    @Override
    protected void doFilterInternal(
        HttpServletRequest request, 
        HttpServletResponse response, 
        FilterChain filterChain
    ) throws ServletException, IOException {
        
        // 1. ä»è¯·æ±‚å¤´è·å–Token
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7); // å»æ‰"Bearer "å‰ç¼€
            
            try {
                // 2. éªŒè¯Tokenå¹¶è·å–ç”¨æˆ·ä¿¡æ¯
                Claims claims = jwtUtil.validateToken(token);
                String userId = claims.get("userId", String.class);
                
                // 3. è®¾ç½®å®‰å…¨ä¸Šä¸‹æ–‡ï¼ˆè®©Controllerèƒ½è·å–å½“å‰ç”¨æˆ·ï¼‰
                Authentication auth = new JwtAuthenticationToken(userId, claims);
                SecurityContextHolder.getContext().setAuthentication(auth);
                
            } catch (JwtException e) {
                // Tokenæ— æ•ˆï¼Œè¿”å›401é”™è¯¯
                response.setStatus(HttpStatus.UNAUTHORIZED.value());
                response.getWriter().write("{\"error\":\"Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸ\"}");
                return;
            }
        }
        
        // 4. ç»§ç»­æ‰§è¡Œåç»­è¿‡æ»¤å™¨
        filterChain.doFilter(request, response);
    }
}
```

---

## 5. ğŸ”„ åˆ·æ–°Tokenæœºåˆ¶å®ç°


### 5.1 ä¸ºä»€ä¹ˆéœ€è¦Tokenåˆ·æ–°

**æ ¸å¿ƒé—®é¢˜**ï¼šAccess Tokenè®¾ç½®çŸ­è¿‡æœŸæ—¶é—´æ˜¯ä¸ºäº†å®‰å…¨ï¼Œä½†ç”¨æˆ·ä¸åº”è¯¥é¢‘ç¹é‡æ–°ç™»å½•ã€‚

> ğŸ“– **ç”Ÿæ´»ç±»æ¯”**ï¼šå°±åƒåœè½¦åœºçš„ä¸´æ—¶åœè½¦å¡ï¼Œæ—¶é—´çŸ­æ˜¯ä¸ºäº†å®‰å…¨ç®¡ç†ï¼Œä½†ä½ å¯ä»¥å‡­é•¿æœŸä¼šå‘˜å¡å»æ¢æ–°çš„ä¸´æ—¶å¡ï¼Œè€Œä¸ç”¨æ¯æ¬¡éƒ½é‡æ–°åŠä¼šå‘˜ã€‚

**Tokenåˆ·æ–°çš„å·¥ä½œæµç¨‹**ï¼š
```
æ­£å¸¸æƒ…å†µï¼š
ç”¨æˆ·è¯·æ±‚ â”€â”€â”€[æœ‰æ•ˆToken]â”€â”€â”€> åç«¯ â”€â”€â”€> è¿”å›æ•°æ®

Tokenå³å°†è¿‡æœŸï¼š
ç”¨æˆ·è¯·æ±‚ â”€â”€â”€[å³å°†è¿‡æœŸToken]â”€â”€â”€> åç«¯ â”€â”€â”€> è‡ªåŠ¨åˆ·æ–°Token + è¿”å›æ•°æ®

Tokenå·²è¿‡æœŸï¼š  
ç”¨æˆ·è¯·æ±‚ â”€â”€â”€[è¿‡æœŸToken]â”€â”€â”€> åç«¯ â”€â”€â”€[401é”™è¯¯]â”€â”€â”€> å‰ç«¯ç”¨RefreshTokenæ¢æ–°Token
```

### 5.2 åç«¯Tokenåˆ·æ–°æ¥å£


```java
@RestController
@RequestMapping("/auth")
public class AuthController {
    
    /**
     * åˆ·æ–°Tokenæ¥å£
     */
    @PostMapping("/refresh")
    public ResponseEntity<?> refreshToken(@RequestBody RefreshTokenRequest request) {
        
        String refreshToken = request.getRefreshToken();
        
        try {
            // 1. éªŒè¯Refresh Token
            Claims claims = jwtUtil.validateToken(refreshToken);
            
            // 2. æ£€æŸ¥Tokenç±»å‹
            String tokenType = claims.get("tokenType", String.class);
            if (!"refresh".equals(tokenType)) {
                return ResponseEntity.status(401)
                    .body(new ApiResponse("æ— æ•ˆçš„åˆ·æ–°Token"));
            }
            
            // 3. è·å–ç”¨æˆ·ä¿¡æ¯
            String userId = claims.get("userId", String.class);
            User user = userService.findById(userId);
            
            if (user == null || !user.isEnabled()) {
                return ResponseEntity.status(401)
                    .body(new ApiResponse("ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨"));
            }
            
            // 4. ç”Ÿæˆæ–°çš„Tokenå¯¹
            String newAccessToken = jwtUtil.generateAccessToken(user);
            String newRefreshToken = jwtUtil.generateRefreshToken(user);
            
            // 5. å¯é€‰ï¼šå°†æ—§çš„Refresh TokenåŠ å…¥é»‘åå•
            blacklistService.addToBlacklist(refreshToken);
            
            // 6. è¿”å›æ–°Token
            RefreshTokenResponse response = new RefreshTokenResponse();
            response.setAccessToken(newAccessToken);
            response.setRefreshToken(newRefreshToken);
            response.setTokenType("Bearer");
            response.setExpiresIn(jwtUtil.getAccessTokenExpiration());
            
            return ResponseEntity.ok(response);
            
        } catch (JwtException e) {
            return ResponseEntity.status(401)
                .body(new ApiResponse("åˆ·æ–°Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸ"));
        }
    }
}
```

### 5.3 å‰ç«¯è‡ªåŠ¨Tokenåˆ·æ–°æœºåˆ¶


```javascript
class TokenManager {
    constructor() {
        this.refreshPromise = null; // é˜²æ­¢é‡å¤åˆ·æ–°
    }
    
    // æ£€æŸ¥Tokenæ˜¯å¦å³å°†è¿‡æœŸï¼ˆæå‰5åˆ†é’Ÿåˆ·æ–°ï¼‰
    shouldRefreshToken(token) {
        if (!token) return false;
        
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            const expTime = payload.exp * 1000; // JWT expæ˜¯ç§’ï¼Œè½¬æˆæ¯«ç§’
            const now = Date.now();
            const fiveMinutes = 5 * 60 * 1000;
            
            return (expTime - now) < fiveMinutes; // 5åˆ†é’Ÿå†…è¿‡æœŸ
        } catch (error) {
            return true; // è§£æå¤±è´¥ï¼Œå½“ä½œéœ€è¦åˆ·æ–°
        }
    }
    
    // åˆ·æ–°Token
    async refreshToken() {
        // é¿å…åŒæ—¶å‘èµ·å¤šä¸ªåˆ·æ–°è¯·æ±‚
        if (this.refreshPromise) {
            return this.refreshPromise;
        }
        
        this.refreshPromise = this._doRefreshToken();
        
        try {
            const result = await this.refreshPromise;
            return result;
        } finally {
            this.refreshPromise = null; // æ¸…é™¤Promise
        }
    }
    
    async _doRefreshToken() {
        const refreshToken = localStorage.getItem('refreshToken');
        
        if (!refreshToken) {
            throw new Error('æ²¡æœ‰åˆ·æ–°Tokenï¼Œéœ€è¦é‡æ–°ç™»å½•');
        }
        
        try {
            const response = await fetch('/auth/refresh', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ refreshToken })
            });
            
            if (!response.ok) {
                throw new Error('Tokenåˆ·æ–°å¤±è´¥');
            }
            
            const tokens = await response.json();
            
            // ä¿å­˜æ–°Token
            localStorage.setItem('accessToken', tokens.accessToken);
            localStorage.setItem('refreshToken', tokens.refreshToken);
            
            return tokens.accessToken;
            
        } catch (error) {
            // åˆ·æ–°å¤±è´¥ï¼Œæ¸…é™¤æ‰€æœ‰Tokenï¼Œè·³è½¬ç™»å½•é¡µ
            localStorage.removeItem('accessToken');
            localStorage.removeItem('refreshToken');
            window.location.href = '/login';
            throw error;
        }
    }
}

// å…¨å±€Tokenç®¡ç†å™¨å®ä¾‹
const tokenManager = new TokenManager();
```

---

## 6. ğŸš« Tokenæ³¨é”€ä¸ä½œåºŸå¤„ç†


### 6.1 Tokenæ³¨é”€çš„æŒ‘æˆ˜

**æ ¸å¿ƒé—®é¢˜**ï¼šJWTæ˜¯è‡ªåŒ…å«çš„ï¼Œæ— æ³•åƒä¼ ç»ŸSessioné‚£æ ·åœ¨æœåŠ¡ç«¯ç›´æ¥åˆ é™¤ã€‚

> ğŸ’¡ **å½¢è±¡ç†è§£**ï¼šJWTåƒå·²ç»ç›–äº†ç« çš„è¯ä»¶ï¼Œä¸èƒ½è¿œç¨‹ä½œåºŸï¼Œåªèƒ½ç­‰å®ƒè‡ªç„¶è¿‡æœŸï¼Œæˆ–è€…å»ºç«‹ä¸€ä¸ª"é»‘åå•"ç³»ç»Ÿã€‚

**å¸¸è§çš„Tokenæ³¨é”€æ–¹æ¡ˆ**ï¼š

```
æ–¹æ¡ˆå¯¹æ¯”ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     æ–¹æ¡ˆ        â”‚   å®ç°éš¾åº¦   â”‚   æ€§èƒ½å½±å“   â”‚   å®‰å…¨æ€§     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. çŸ­æœŸè¿‡æœŸ     â”‚   â­â­â­â­â­   â”‚   â­â­â­â­â­   â”‚   â­â­â­     â”‚
â”‚ 2. Tokené»‘åå•  â”‚   â­â­â­     â”‚   â­â­â­     â”‚   â­â­â­â­â­   â”‚
â”‚ 3. ç‰ˆæœ¬å·æœºåˆ¶   â”‚   â­â­â­â­   â”‚   â­â­â­â­   â”‚   â­â­â­â­   â”‚
â”‚ 4. åˆ·æ–°Tokenè½®æ¢â”‚   â­â­     â”‚   â­â­â­â­   â”‚   â­â­â­â­â­   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 ç”¨æˆ·æ³¨é”€æ¥å£å®ç°


```java
@RestController
@RequestMapping("/auth")
public class AuthController {
    
    @Autowired
    private BlacklistService blacklistService;
    
    /**
     * ç”¨æˆ·æ³¨é”€æ¥å£
     */
    @PostMapping("/logout")
    public ResponseEntity<?> logout(HttpServletRequest request) {
        
        // 1. è·å–å½“å‰ç”¨æˆ·çš„Token
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String accessToken = authHeader.substring(7);
            
            try {
                // 2. è§£æTokenè·å–ä¿¡æ¯
                Claims claims = jwtUtil.validateToken(accessToken);
                String userId = claims.get("userId", String.class);
                
                // 3. å°†Access TokenåŠ å…¥é»‘åå•
                blacklistService.addToBlacklist(accessToken);
                
                // 4. è·å–å¹¶ä½œåºŸç”¨æˆ·çš„æ‰€æœ‰Refresh Token
                String refreshTokenFromBody = getRefreshTokenFromRequestBody(request);
                if (refreshTokenFromBody != null) {
                    blacklistService.addToBlacklist(refreshTokenFromBody);
                }
                
                // 5. å¯é€‰ï¼šè®°å½•æ³¨é”€æ—¥å¿—
                auditService.recordLogout(userId);
                
                return ResponseEntity.ok(new ApiResponse("æ³¨é”€æˆåŠŸ"));
                
            } catch (JwtException e) {
                // Tokenå·²ç»æ— æ•ˆï¼Œä½†æ³¨é”€è¯·æ±‚ä»ç„¶æˆåŠŸ
                return ResponseEntity.ok(new ApiResponse("æ³¨é”€æˆåŠŸ"));
            }
        }
        
        return ResponseEntity.badRequest()
            .body(new ApiResponse("æœªæä¾›æœ‰æ•ˆçš„Token"));
    }
    
    /**
     * æ³¨é”€æ‰€æœ‰è®¾å¤‡ä¸Šçš„Token
     */
    @PostMapping("/logout-all")
    public ResponseEntity<?> logoutAll(HttpServletRequest request) {
        
        String userId = getCurrentUserId(request);
        
        // å¢åŠ ç”¨æˆ·çš„Tokenç‰ˆæœ¬å·ï¼Œè®©æ‰€æœ‰æ—§Tokenå¤±æ•ˆ
        userService.incrementTokenVersion(userId);
        
        return ResponseEntity.ok(new ApiResponse("å·²æ³¨é”€æ‰€æœ‰è®¾å¤‡"));
    }
}
```

### 6.3 Tokené»‘åå•æœåŠ¡å®ç°


```java
@Service
public class BlacklistService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String BLACKLIST_PREFIX = "jwt:blacklist:";
    
    /**
     * å°†TokenåŠ å…¥é»‘åå•
     */
    public void addToBlacklist(String token) {
        try {
            // 1. è§£æTokenè·å–è¿‡æœŸæ—¶é—´
            Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
            
            Date expiration = claims.getExpiration();
            
            // 2. è®¡ç®—å‰©ä½™æœ‰æ•ˆæ—¶é—´
            long ttl = expiration.getTime() - System.currentTimeMillis();
            
            if (ttl > 0) {
                // 3. å­˜å…¥Redisï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´ä¸Tokenç›¸åŒ
                String key = BLACKLIST_PREFIX + token;
                redisTemplate.opsForValue().set(key, "blacklisted", ttl, TimeUnit.MILLISECONDS);
            }
            
        } catch (Exception e) {
            log.error("æ·»åŠ Tokenåˆ°é»‘åå•å¤±è´¥: {}", e.getMessage());
        }
    }
    
    /**
     * æ£€æŸ¥Tokenæ˜¯å¦åœ¨é»‘åå•ä¸­
     */
    public boolean isBlacklisted(String token) {
        String key = BLACKLIST_PREFIX + token;
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }
}
```

---

## 7. ğŸ’» å®Œæ•´å®æˆ˜ç¤ºä¾‹


### 7.1 Spring Bootåç«¯å®Œæ•´é…ç½®


**application.ymlé…ç½®**ï¼š
```yaml
# JWTé…ç½®
jwt:
  secret: mySecretKey123456789  # ç”Ÿäº§ç¯å¢ƒåº”è¯¥æ›´å¤æ‚
  access-token-expiration: 1800000   # 30åˆ†é’Ÿï¼ˆæ¯«ç§’ï¼‰
  refresh-token-expiration: 604800000 # 7å¤©ï¼ˆæ¯«ç§’ï¼‰

# Redisé…ç½®ï¼ˆç”¨äºé»‘åå•ï¼‰
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
    timeout: 5000ms
    
# å®‰å…¨é…ç½®
security:
  password:
    bcrypt-strength: 12  # BCryptåŠ å¯†å¼ºåº¦
```

**å®‰å…¨é…ç½®ç±»**ï¼š
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationFilter jwtFilter;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12); // é«˜å¼ºåº¦åŠ å¯†
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        
        http.csrf().disable() // JWTä¸éœ€è¦CSRFä¿æŠ¤
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // æ— çŠ¶æ€
            
            .and()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/login", "/auth/refresh").permitAll() // ç™»å½•æ¥å£æ”¾è¡Œ
                .requestMatchers("/api/admin/**").hasRole("ADMIN")           // ç®¡ç†å‘˜æ¥å£
                .anyRequest().authenticated()                                 // å…¶ä»–æ¥å£éœ€è¦è®¤è¯
            )
            
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class); // æ·»åŠ JWTè¿‡æ»¤å™¨
        
        return http.build();
    }
}
```

### 7.2 Vueå‰ç«¯å®Œæ•´ç¤ºä¾‹


**APIæœåŠ¡å°è£…**ï¼š
```javascript
// api/auth.js
import request from '@/utils/request'

export const authAPI = {
  // ç”¨æˆ·ç™»å½•
  login(loginForm) {
    return request({
      url: '/auth/login',
      method: 'post',
      data: loginForm
    })
  },
  
  // åˆ·æ–°Token
  refreshToken(refreshToken) {
    return request({
      url: '/auth/refresh',
      method: 'post',
      data: { refreshToken }
    })
  },
  
  // ç”¨æˆ·æ³¨é”€
  logout(refreshToken) {
    return request({
      url: '/auth/logout',
      method: 'post',
      data: { refreshToken }
    })
  }
}
```

**VuexçŠ¶æ€ç®¡ç†**ï¼š
```javascript
// store/auth.js
export default {
  namespaced: true,
  
  state: {
    accessToken: localStorage.getItem('accessToken'),
    refreshToken: localStorage.getItem('refreshToken'),
    userInfo: null
  },
  
  mutations: {
    SET_TOKENS(state, tokens) {
      state.accessToken = tokens.accessToken
      state.refreshToken = tokens.refreshToken
      localStorage.setItem('accessToken', tokens.accessToken)
      localStorage.setItem('refreshToken', tokens.refreshToken)
    },
    
    CLEAR_TOKENS(state) {
      state.accessToken = null
      state.refreshToken = null
      state.userInfo = null
      localStorage.removeItem('accessToken')
      localStorage.removeItem('refreshToken')
    }
  },
  
  actions: {
    // ç™»å½•
    async login({ commit }, loginForm) {
      try {
        const response = await authAPI.login(loginForm)
        const tokens = response.data
        
        commit('SET_TOKENS', tokens)
        
        return { success: true }
      } catch (error) {
        return { success: false, message: error.message }
      }
    },
    
    // æ³¨é”€
    async logout({ commit, state }) {
      try {
        await authAPI.logout(state.refreshToken)
      } catch (error) {
        console.error('æ³¨é”€è¯·æ±‚å¤±è´¥:', error)
      } finally {
        commit('CLEAR_TOKENS')
        // è·³è½¬ç™»å½•é¡µ
        this.$router.push('/login')
      }
    }
  },
  
  getters: {
    isAuthenticated: state => !!state.accessToken
  }
}
```

**ç™»å½•ç»„ä»¶**ï¼š
```vue
<template>
  <div class="login-container">
    <el-form ref="loginForm" :model="form" :rules="rules" class="login-form">
      
      <h2 class="title">ç”¨æˆ·ç™»å½•</h2>
      
      <el-form-item prop="username">
        <el-input 
          v-model="form.username" 
          placeholder="ç”¨æˆ·å"
          prefix-icon="el-icon-user"
        />
      </el-form-item>
      
      <el-form-item prop="password">
        <el-input 
          v-model="form.password" 
          type="password"
          placeholder="å¯†ç "
          prefix-icon="el-icon-lock"
          @keyup.enter="handleLogin"
        />
      </el-form-item>
      
      <el-form-item>
        <el-button 
          type="primary" 
          :loading="loading" 
          @click="handleLogin"
          class="login-button"
        >
          {{ loading ? 'ç™»å½•ä¸­...' : 'ç™»å½•' }}
        </el-button>
      </el-form-item>
      
    </el-form>
  </div>
</template>

<script>
import { mapActions } from 'vuex'

export default {
  name: 'Login',
  
  data() {
    return {
      form: {
        username: '',
        password: ''
      },
      rules: {
        username: [
          { required: true, message: 'è¯·è¾“å…¥ç”¨æˆ·å', trigger: 'blur' }
        ],
        password: [
          { required: true, message: 'è¯·è¾“å…¥å¯†ç ', trigger: 'blur' }
        ]
      },
      loading: false
    }
  },
  
  methods: {
    ...mapActions('auth', ['login']),
    
    async handleLogin() {
      try {
        // è¡¨å•éªŒè¯
        await this.$refs.loginForm.validate()
        
        this.loading = true
        
        // å‘èµ·ç™»å½•è¯·æ±‚
        const result = await this.login(this.form)
        
        if (result.success) {
          this.$message.success('ç™»å½•æˆåŠŸ')
          this.$router.push('/dashboard')
        } else {
          this.$message.error(result.message || 'ç™»å½•å¤±è´¥')
        }
        
      } catch (error) {
        console.error('ç™»å½•å¤±è´¥:', error)
      } finally {
        this.loading = false
      }
    }
  }
}
</script>
```

---

## 8. ğŸ”§ ç”Ÿäº§ç¯å¢ƒé…ç½®è¦ç‚¹


### 8.1 å®‰å…¨é…ç½®æœ€ä½³å®è·µ


> âš ï¸ **å®‰å…¨è­¦å‘Š**ï¼šä»¥ä¸‹é…ç½®ç›´æ¥å½±å“ç³»ç»Ÿå®‰å…¨ï¼Œå¿…é¡»ä¸¥æ ¼æ‰§è¡Œï¼

**JWTå¯†é’¥ç®¡ç†**ï¼š
```yaml
# âŒ é”™è¯¯åšæ³•ï¼šç¡¬ç¼–ç å¯†é’¥
jwt:
  secret: "123456"

# âœ… æ­£ç¡®åšæ³•ï¼šç¯å¢ƒå˜é‡
jwt:
  secret: ${JWT_SECRET:default-secret-for-dev-only}
```

```bash
# ç”Ÿäº§ç¯å¢ƒè®¾ç½®ç¯å¢ƒå˜é‡
export JWT_SECRET="your-very-long-random-secret-key-at-least-256-bits"

# æˆ–åœ¨docker-compose.ymlä¸­
environment:
  - JWT_SECRET=your-very-long-random-secret-key-at-least-256-bits
```

**Tokenè¿‡æœŸæ—¶é—´é…ç½®**ï¼š
```yaml
jwt:
  # æ ¹æ®ä¸šåŠ¡éœ€æ±‚è°ƒæ•´
  access-token-expiration: 900000    # 15åˆ†é’Ÿï¼ˆå®‰å…¨æ€§é«˜çš„ç³»ç»Ÿï¼‰
  # access-token-expiration: 3600000  # 1å°æ—¶ï¼ˆä¸€èˆ¬ç³»ç»Ÿï¼‰
  
  refresh-token-expiration: 604800000  # 7å¤©
  # refresh-token-expiration: 2592000000 # 30å¤©ï¼ˆä¾¿åˆ©æ€§è¦æ±‚é«˜çš„ç³»ç»Ÿï¼‰
```

### 8.2 HTTPSå¼ºåˆ¶é…ç½®


```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // å¼ºåˆ¶HTTPS
            .requiresChannel(channel -> 
                channel.requestMatchers(r -> r.getHeader("X-Forwarded-Proto") != null)
                       .requiresSecure())
            
            // å®‰å…¨å¤´é…ç½®
            .headers(headers -> headers
                .frameOptions().deny()                           // é˜²æ­¢ç‚¹å‡»åŠ«æŒ
                .contentTypeOptions().and()                      // é˜²æ­¢MIMEç±»å‹å—…æ¢
                .httpStrictTransportSecurity(hstsConfig -> hstsConfig
                    .maxAgeInSeconds(31536000)                   // HSTSä¸€å¹´
                    .includeSubdomains(true)
                    .preload(true)
                )
            );
            
        return http.build();
    }
}
```

### 8.3 æ—¥å¿—å’Œç›‘æ§é…ç½®


```yaml
logging:
  level:
    com.yourapp.auth: INFO
    org.springframework.security: WARN
  
  # æ—¥å¿—æ–‡ä»¶é…ç½®
  file:
    name: /var/log/app/auth.log
    max-size: 100MB
    max-history: 30

# ç›‘æ§ç«¯ç‚¹
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: when-authorized
```

**å…³é”®å®‰å…¨äº‹ä»¶è®°å½•**ï¼š
```java
@Component
public class SecurityAuditLogger {
    
    private static final Logger securityLogger = LoggerFactory.getLogger("SECURITY");
    
    public void logSuccessfulLogin(String userId, String clientIp) {
        securityLogger.info("LOGIN_SUCCESS - User: {}, IP: {}, Time: {}", 
            userId, clientIp, Instant.now());
    }
    
    public void logFailedLogin(String username, String clientIp, String reason) {
        securityLogger.warn("LOGIN_FAILED - Username: {}, IP: {}, Reason: {}, Time: {}", 
            username, clientIp, reason, Instant.now());
    }
    
    public void logTokenRefresh(String userId, String clientIp) {
        securityLogger.info("TOKEN_REFRESH - User: {}, IP: {}, Time: {}", 
            userId, clientIp, Instant.now());
    }
    
    public void logSuspiciousActivity(String userId, String activity, String details) {
        securityLogger.error("SUSPICIOUS_ACTIVITY - User: {}, Activity: {}, Details: {}, Time: {}", 
            userId, activity, details, Instant.now());
    }
}
```

---

## 9. âš–ï¸ è´Ÿè½½å‡è¡¡ä¸‹çš„JWTå¤„ç†


### 9.1 è´Ÿè½½å‡è¡¡ç¯å¢ƒçš„æŒ‘æˆ˜

åœ¨å¤šæœåŠ¡å™¨ç¯å¢ƒä¸‹ï¼ŒJWTé¢ä¸´çš„ä¸»è¦é—®é¢˜ï¼š

> ğŸ’¡ **å½¢è±¡ç†è§£**ï¼šå°±åƒåœ¨å¤šä¸ªé“¶è¡Œç½‘ç‚¹éƒ½èƒ½ç”¨åŒä¸€å¼ é“¶è¡Œå¡ï¼Œæ‰€æœ‰ç½‘ç‚¹å¿…é¡»èƒ½éªŒè¯è¿™å¼ å¡çš„çœŸä¼ªï¼Œè¿˜è¦åŒæ­¥é»‘åå•ä¿¡æ¯ã€‚

**è´Ÿè½½å‡è¡¡æ¶æ„å›¾**ï¼š
```
                 è´Ÿè½½å‡è¡¡å™¨
                     â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚          â”‚          â”‚
     æœåŠ¡å™¨A      æœåŠ¡å™¨B      æœåŠ¡å™¨C
     â”Œâ”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”
     â”‚Redisâ”‚      â”‚Redisâ”‚      â”‚Redisâ”‚
     â””â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”˜
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               å…±äº«Redisé›†ç¾¤
```

### 9.2 JWTå¯†é’¥åŒæ­¥æ–¹æ¡ˆ


**æ–¹æ¡ˆ1ï¼šå…±äº«å¯†é’¥ï¼ˆæ¨èï¼‰**
```java
@Configuration
public class JwtConfig {
    
    // æ‰€æœ‰æœåŠ¡å™¨ä½¿ç”¨ç›¸åŒçš„JWTå¯†é’¥
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    // å¯†é’¥å¯ä»¥ä»é…ç½®ä¸­å¿ƒè·å–ï¼Œä¿è¯æ‰€æœ‰å®ä¾‹ä¸€è‡´
    @Bean
    public JwtTokenUtil jwtTokenUtil() {
        return new JwtTokenUtil(jwtSecret);
    }
}
```

**æ–¹æ¡ˆ2ï¼šå…¬ç§é’¥å¯¹ï¼ˆé«˜å®‰å…¨è¦æ±‚ï¼‰**
```java
@Configuration
public class JwtAsymmetricConfig {
    
    @Value("${jwt.private-key-path}")
    private String privateKeyPath;
    
    @Value("${jwt.public-key-path}")  
    private String publicKeyPath;
    
    @Bean
    public RSAPrivateKey privateKey() throws Exception {
        // ç­¾å‘Tokenç”¨çš„ç§é’¥ï¼ˆåªæœ‰è®¤è¯æœåŠ¡å™¨æœ‰ï¼‰
        byte[] keyBytes = Files.readAllBytes(Paths.get(privateKeyPath));
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        return (RSAPrivateKey) keyFactory.generatePrivate(spec);
    }
    
    @Bean
    public RSAPublicKey publicKey() throws Exception {
        // éªŒè¯Tokenç”¨çš„å…¬é’¥ï¼ˆæ‰€æœ‰æœåŠ¡å™¨éƒ½æœ‰ï¼‰
        byte[] keyBytes = Files.readAllBytes(Paths.get(publicKeyPath));
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        return (RSAPublicKey) keyFactory.generatePublic(spec);
    }
}
```

### 9.3 å…±äº«é»‘åå•å®ç°


```java
@Service
public class DistributedBlacklistService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String BLACKLIST_PREFIX = "jwt:blacklist:";
    private static final String BLACKLIST_NOTIFY_CHANNEL = "jwt:blacklist:notify";
    
    /**
     * æ·»åŠ Tokenåˆ°åˆ†å¸ƒå¼é»‘åå•
     */
    public void addToBlacklist(String token) {
        try {
            Claims claims = parseToken(token);
            Date expiration = claims.getExpiration();
            long ttl = expiration.getTime() - System.currentTimeMillis();
            
            if (ttl > 0) {
                String key = BLACKLIST_PREFIX + getTokenHash(token);
                
                // 1. æ·»åŠ åˆ°Redis
                redisTemplate.opsForValue().set(key, "blacklisted", ttl, TimeUnit.MILLISECONDS);
                
                // 2. é€šçŸ¥å…¶ä»–æœåŠ¡å™¨èŠ‚ç‚¹
                redisTemplate.convertAndSend(BLACKLIST_NOTIFY_CHANNEL, token);
            }
            
        } catch (Exception e) {
            log.error("æ·»åŠ åˆ†å¸ƒå¼é»‘åå•å¤±è´¥: {}", e.getMessage());
        }
    }
    
    /**
     * æ£€æŸ¥Tokenæ˜¯å¦åœ¨é»‘åå•ä¸­
     */
    public boolean isBlacklisted(String token) {
        String key = BLACKLIST_PREFIX + getTokenHash(token);
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }
    
    /**
     * ç”ŸæˆTokenå“ˆå¸Œå€¼ï¼ˆé¿å…å­˜å‚¨å®Œæ•´Tokenï¼‰
     */
    private String getTokenHash(String token) {
        return DigestUtils.sha256Hex(token);
    }
}
```

### 9.4 Session Sticky vs Stateless

**Session Stickyæ–¹æ¡ˆ**ï¼ˆä¸æ¨èï¼‰ï¼š
```
é—®é¢˜ï¼šç”¨æˆ·è¯·æ±‚å›ºå®šåˆ°ç‰¹å®šæœåŠ¡å™¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”¨æˆ·A   â”‚â”€â”€â”€â†’â”‚ æœåŠ¡å™¨1 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚ ç”¨æˆ·B   â”‚â”€â”€â”€â†’â”‚ æœåŠ¡å™¨2 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç¼ºç‚¹ï¼š
- æœåŠ¡å™¨å®•æœºå½±å“ç‰¹å®šç”¨æˆ·
- è´Ÿè½½å¯èƒ½ä¸å‡è¡¡
- æ‰©å®¹ç¼©å®¹å¤æ‚
```

**Statelessæ–¹æ¡ˆ**ï¼ˆæ¨èï¼‰ï¼š
```
ä¼˜åŠ¿ï¼šç”¨æˆ·è¯·æ±‚å¯ä»¥å‘å¾€ä»»æ„æœåŠ¡å™¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”¨æˆ·A   â”‚â”€â”€â”€â†’â”‚ä»»æ„æœåŠ¡å™¨â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”¨æˆ·B   â”‚â”€â”€â”€â†’â”‚ä»»æ„æœåŠ¡å™¨â”‚  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜ç‚¹ï¼š
- çœŸæ­£çš„æ°´å¹³æ‰©å±•
- é«˜å¯ç”¨æ€§
- è´Ÿè½½å‡è¡¡æ›´çµæ´»
```

---

## 10. ğŸ“‹ Tokené»‘åå•å®ç°æ–¹æ¡ˆ


### 10.1 é»‘åå•æ–¹æ¡ˆå¯¹æ¯”åˆ†æ


| æ–¹æ¡ˆç±»å‹ | **å®ç°å¤æ‚åº¦** | **æ€§èƒ½å½±å“** | **å†…å­˜å ç”¨** | **é€‚ç”¨åœºæ™¯** |
|---------|---------------|-------------|-------------|-------------|
| `Redisé»‘åå•` | â­â­â­ | â­â­â­ | â­â­â­â­ | ä¸­å°å‹ç³»ç»Ÿ |
| `æ•°æ®åº“é»‘åå•` | â­â­ | â­â­ | â­â­â­â­â­ | ç³»ç»Ÿè´Ÿè½½ä½ |
| `å¸ƒéš†è¿‡æ»¤å™¨` | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | å¤§è§„æ¨¡ç³»ç»Ÿ |
| `ç‰ˆæœ¬å·æœºåˆ¶` | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | ç®€å•åœºæ™¯ |

### 10.2 Redisé»‘åå•è¯¦ç»†å®ç°


**åŸºç¡€Redisé»‘åå•**ï¼š
```java
@Service
public class RedisBlacklistService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String BLACKLIST_KEY_PREFIX = "blacklist:token:";
    
    /**
     * æ·»åŠ Tokenåˆ°é»‘åå•
     * @param token JWT Token
     * @param expireTime Tokençš„è¿‡æœŸæ—¶é—´
     */
    public void addToBlacklist(String token, Date expireTime) {
        String key = BLACKLIST_KEY_PREFIX + hashToken(token);
        long ttl = expireTime.getTime() - System.currentTimeMillis();
        
        if (ttl > 0) {
            // è®¾ç½®ä¸Tokenç›¸åŒçš„è¿‡æœŸæ—¶é—´
            redisTemplate.opsForValue().set(key, "1", Duration.ofMillis(ttl));
        }
    }
    
    /**
     * æ£€æŸ¥Tokenæ˜¯å¦åœ¨é»‘åå•ä¸­
     */
    public boolean isTokenBlacklisted(String token) {
        String key = BLACKLIST_KEY_PREFIX + hashToken(token);
        return redisTemplate.hasKey(key);
    }
    
    /**
     * Tokenå“ˆå¸Œå¤„ç†ï¼ˆèŠ‚çœRediså†…å­˜ï¼‰
     */
    private String hashToken(String token) {
        return DigestUtils.sha256Hex(token).substring(0, 16); // å–å‰16ä½
    }
}
```

### 10.3 å¸ƒéš†è¿‡æ»¤å™¨é»‘åå•ï¼ˆé«˜æ€§èƒ½æ–¹æ¡ˆï¼‰


```java
@Service
public class BloomFilterBlacklistService {
    
    private BloomFilter<String> blacklistBloomFilter;
    private final Set<String> exactBlacklist = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void init() {
        // é¢„æœŸ10ä¸‡ä¸ªTokenï¼Œè¯¯åˆ¤ç‡1%
        blacklistBloomFilter = BloomFilter.create(
            Funnels.stringFunnel(Charset.defaultCharset()),
            100000,  // é¢„æœŸå…ƒç´ æ•°é‡
            0.01     // è¯¯åˆ¤ç‡
        );
    }
    
    /**
     * æ·»åŠ åˆ°é»‘åå•
     */
    public void addToBlacklist(String token, Date expireTime) {
        // 1. æ·»åŠ åˆ°å¸ƒéš†è¿‡æ»¤å™¨ï¼ˆå¿«é€Ÿè¿‡æ»¤ï¼‰
        blacklistBloomFilter.put(hashToken(token));
        
        // 2. æ·»åŠ åˆ°ç²¾ç¡®é›†åˆï¼ˆç¡®è®¤é»‘åå•çŠ¶æ€ï¼‰
        String hashedToken = hashToken(token);
        exactBlacklist.add(hashedToken);
        
        // 3. è®¾ç½®å®šæ—¶æ¸…ç†ï¼ˆTokenè¿‡æœŸåä»ç²¾ç¡®é›†åˆä¸­ç§»é™¤ï¼‰
        long delay = expireTime.getTime() - System.currentTimeMillis();
        if (delay > 0) {
            scheduleTokenCleanup(hashedToken, delay);
        }
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­
     */
    public boolean isTokenBlacklisted(String token) {
        String hashedToken = hashToken(token);
        
        // 1. å…ˆç”¨å¸ƒéš†è¿‡æ»¤å™¨å¿«é€Ÿåˆ¤æ–­
        if (!blacklistBloomFilter.mightContain(hashedToken)) {
            return false; // è‚¯å®šä¸åœ¨é»‘åå•ä¸­
        }
        
        // 2. å¸ƒéš†è¿‡æ»¤å™¨è¯´å¯èƒ½å­˜åœ¨ï¼Œå†ç²¾ç¡®æ£€æŸ¥
        return exactBlacklist.contains(hashedToken);
    }
    
    private void scheduleTokenCleanup(String hashedToken, long delayMs) {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.schedule(() -> {
            exactBlacklist.remove(hashedToken);
        }, delayMs, TimeUnit.MILLISECONDS);
    }
}
```

### 10.4 ç‰ˆæœ¬å·æœºåˆ¶ï¼ˆè½»é‡çº§æ–¹æ¡ˆï¼‰


```java
/**
 * ç”¨æˆ·Tokenç‰ˆæœ¬å·æœºåˆ¶
 * åŸç†ï¼šæ¯ä¸ªç”¨æˆ·æœ‰ä¸ªç‰ˆæœ¬å·ï¼Œæ³¨é”€æ—¶ç‰ˆæœ¬å·+1ï¼Œæ—§Tokenéƒ½å¤±æ•ˆ
 */
@Service
public class TokenVersionService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String VERSION_KEY_PREFIX = "user:token:version:";
    
    /**
     * è·å–ç”¨æˆ·å½“å‰Tokenç‰ˆæœ¬å·
     */
    public long getUserTokenVersion(String userId) {
        String key = VERSION_KEY_PREFIX + userId;
        String version = redisTemplate.opsForValue().get(key);
        return version != null ? Long.parseLong(version) : 0L;
    }
    
    /**
     * å¢åŠ ç”¨æˆ·Tokenç‰ˆæœ¬å·ï¼ˆæ³¨é”€æ‰€æœ‰Tokenï¼‰
     */
    public long incrementUserTokenVersion(String userId) {
        String key = VERSION_KEY_PREFIX + userId;
        return redisTemplate.opsForValue().increment(key);
    }
    
    /**
     * éªŒè¯Tokenç‰ˆæœ¬å·æ˜¯å¦æœ‰æ•ˆ
     */
    public boolean isTokenVersionValid(String userId, long tokenVersion) {
        long currentVersion = getUserTokenVersion(userId);
        return tokenVersion >= currentVersion;
    }
}

// åœ¨JWTä¸­åŒ…å«ç‰ˆæœ¬å·
public String generateAccessToken(User user) {
    long tokenVersion = tokenVersionService.getUserTokenVersion(user.getId());
    
    Map<String, Object> claims = new HashMap<>();
    claims.put("userId", user.getId());
    claims.put("username", user.getUsername());
    claims.put("tokenVersion", tokenVersion); // å…³é”®ï¼šåŒ…å«ç‰ˆæœ¬å·
    
    return createToken(claims, accessTokenExpiration);
}

// éªŒè¯Tokenæ—¶æ£€æŸ¥ç‰ˆæœ¬å·
public boolean validateToken(String token) {
    try {
        Claims claims = parseToken(token);
        String userId = claims.get("userId", String.class);
        Long tokenVersion = claims.get("tokenVersion", Long.class);
        
        // æ£€æŸ¥ç‰ˆæœ¬å·æ˜¯å¦æœ‰æ•ˆ
        return tokenVersionService.isTokenVersionValid(userId, tokenVersion);
        
    } catch (Exception e) {
        return false;
    }
}
```

---

## 11. ğŸ“Š æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–


### 11.1 å…³é”®æ€§èƒ½æŒ‡æ ‡ï¼ˆKPIï¼‰


**JWTç³»ç»Ÿéœ€è¦ç›‘æ§çš„æ ¸å¿ƒæŒ‡æ ‡**ï¼š

```
æ€§èƒ½æŒ‡æ ‡ç›‘æ§ä½“ç³»ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ç³»ç»Ÿæ€§èƒ½                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Tokenç”Ÿæˆé€Ÿåº¦: < 50ms                     â”‚
â”‚ â€¢ TokenéªŒè¯é€Ÿåº¦: < 10ms                     â”‚  
â”‚ â€¢ ç™»å½•æ¥å£å“åº”: < 200ms                     â”‚
â”‚ â€¢ åˆ·æ–°Tokenå“åº”: < 100ms                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                ä¸šåŠ¡æŒ‡æ ‡                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ ç™»å½•æˆåŠŸç‡: > 99%                         â”‚
â”‚ â€¢ Tokenåˆ·æ–°æˆåŠŸç‡: > 99.5%                  â”‚
â”‚ â€¢ é»‘åå•å‘½ä¸­ç‡: ç›‘æ§å¼‚å¸¸æƒ…å†µ                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                èµ„æºæ¶ˆè€—                     â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Rediså†…å­˜å ç”¨: ç›‘æ§é»‘åå•å¤§å°             â”‚
â”‚ â€¢ CPUä½¿ç”¨ç‡: JWTè®¡ç®—æ¶ˆè€—                    â”‚
â”‚ â€¢ ç½‘ç»œå¸¦å®½: Tokenä¼ è¾“å¼€é”€                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 11.2 æ€§èƒ½ç›‘æ§å®ç°


```java
@Component
public class JwtPerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Timer tokenGenerationTimer;
    private final Timer tokenValidationTimer;
    private final Counter loginSuccessCounter;
    private final Counter loginFailureCounter;
    
    public JwtPerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // åˆ›å»ºå„ç§ç›‘æ§æŒ‡æ ‡
        this.tokenGenerationTimer = Timer.builder("jwt.token.generation")
            .description("JWT Tokenç”Ÿæˆè€—æ—¶")
            .register(meterRegistry);
            
        this.tokenValidationTimer = Timer.builder("jwt.token.validation")
            .description("JWT TokenéªŒè¯è€—æ—¶")
            .register(meterRegistry);
            
        this.loginSuccessCounter = Counter.builder("jwt.login.success")
            .description("ç™»å½•æˆåŠŸæ¬¡æ•°")
            .register(meterRegistry);
            
        this.loginFailureCounter = Counter.builder("jwt.login.failure")
            .description("ç™»å½•å¤±è´¥æ¬¡æ•°")
            .tag("reason", "invalid_credentials")
            .register(meterRegistry);
    }
    
    /**
     * ç›‘æ§Tokenç”Ÿæˆæ€§èƒ½
     */
    public String monitorTokenGeneration(Supplier<String> tokenGenerator) {
        return tokenGenerationTimer.recordCallable(() -> {
            return tokenGenerator.get();
        });
    }
    
    /**
     * ç›‘æ§TokenéªŒè¯æ€§èƒ½
     */
    public boolean monitorTokenValidation(Supplier<Boolean> validator) {
        return tokenValidationTimer.recordCallable(() -> {
            return validator.get();
        });
    }
    
    /**
     * è®°å½•ç™»å½•ç»“æœ
     */
    public void recordLoginAttempt(boolean success, String failureReason) {
        if (success) {
            loginSuccessCounter.increment();
        } else {
            Counter.builder("jwt.login.failure")
                .tag("reason", failureReason)
                .register(meterRegistry)
                .increment();
        }
    }
}
```

### 11.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


**ğŸš€ Tokenç”Ÿæˆä¼˜åŒ–**ï¼š
```java
@Service
public class OptimizedJwtService {
    
    // 1. é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
    private static final Pattern JWT_PATTERN = Pattern.compile("^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$");
    
    // 2. ç¼“å­˜JWTè§£æå™¨ï¼ˆé¿å…é‡å¤åˆ›å»ºï¼‰
    private final JwtParser jwtParser;
    
    public OptimizedJwtService(@Value("${jwt.secret}") String secret) {
        this.jwtParser = Jwts.parserBuilder()
            .setSigningKey(secret)
            .build();
    }
    
    /**
     * å¿«é€ŸTokenæ ¼å¼éªŒè¯
     */
    public boolean isValidTokenFormat(String token) {
        return token != null && JWT_PATTERN.matcher(token).matches();
    }
    
    /**
     * ä¼˜åŒ–çš„TokenéªŒè¯
     */
    public Claims validateTokenOptimized(String token) {
        // 1. å¿«é€Ÿæ ¼å¼æ£€æŸ¥
        if (!isValidTokenFormat(token)) {
            throw new MalformedJwtException("æ— æ•ˆçš„Tokenæ ¼å¼");
        }
        
        // 2. ä½¿ç”¨ç¼“å­˜çš„è§£æå™¨
        return jwtParser.parseClaimsJws(token).getBody();
    }
}
```

**âš¡ Redisè¿æ¥æ± ä¼˜åŒ–**ï¼š
```java
@Configuration
public class RedisOptimizationConfig {
    
    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        
        // Redisè¿æ¥æ± é…ç½®
        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = 
            new GenericObjectPoolConfig<>();
        
        poolConfig.setMaxTotal(50);        // æœ€å¤§è¿æ¥æ•°
        poolConfig.setMaxIdle(20);         // æœ€å¤§ç©ºé—²è¿æ¥
        poolConfig.setMinIdle(5);          // æœ€å°ç©ºé—²è¿æ¥
        poolConfig.setMaxWaitMillis(3000); // æœ€å¤§ç­‰å¾…æ—¶é—´
        
        // Lettuceå®¢æˆ·ç«¯é…ç½®
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
            .commandTimeout(Duration.ofSeconds(2))     // å‘½ä»¤è¶…æ—¶
            .shutdownTimeout(Duration.ofSeconds(5))    // å…³é—­è¶…æ—¶
            .poolConfig(poolConfig)
            .build();
        
        return new LettuceConnectionFactory(new RedisStandaloneConfiguration("localhost", 6379), clientConfig);
    }
}
```

### 11.4 å†…å­˜ä¼˜åŒ–ç­–ç•¥


```java
/**
 * å†…å­˜é«˜æ•ˆçš„Tokenå­˜å‚¨
 */
@Service
public class MemoryEfficientTokenService {
    
    // ä½¿ç”¨Caffeineæœ¬åœ°ç¼“å­˜å‡å°‘RedisæŸ¥è¯¢
    private final Cache<String, Boolean> localBlacklistCache;
    
    public MemoryEfficientTokenService() {
        this.localBlacklistCache = Caffeine.newBuilder()
            .maximumSize(10000)                          // æœ€å¤§ç¼“å­˜10000ä¸ªToken
            .expireAfterWrite(Duration.ofMinutes(30))    // 30åˆ†é’Ÿåè¿‡æœŸ
            .build();
    }
    
    /**
     * åˆ†å±‚æ£€æŸ¥ï¼šæœ¬åœ°ç¼“å­˜ -> Redis -> æ•°æ®åº“
     */
    public boolean isTokenBlacklisted(String token) {
        String tokenHash = hashToken(token);
        
        // 1. å…ˆæŸ¥æœ¬åœ°ç¼“å­˜
        Boolean cachedResult = localBlacklistCache.getIfPresent(tokenHash);
        if (cachedResult != null) {
            return cachedResult;
        }
        
        // 2. æŸ¥Redis
        boolean isBlacklisted = redisTemplate.hasKey("blacklist:" + tokenHash);
        
        // 3. ç¼“å­˜ç»“æœåˆ°æœ¬åœ°
        localBlacklistCache.put(tokenHash, isBlacklisted);
        
        return isBlacklisted;
    }
    
    /**
     * Tokenå‹ç¼©å­˜å‚¨ï¼ˆèŠ‚çœå†…å­˜ï¼‰
     */
    private String hashToken(String token) {
        // ä½¿ç”¨CRC32ä»£æ›¿SHA256ï¼ˆæ›´å¿«ï¼Œå†…å­˜æ›´å°‘ï¼‰
        CRC32 crc32 = new CRC32();
        crc32.update(token.getBytes());
        return Long.toHexString(crc32.getValue());
    }
}
```

---

## 12. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 12.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ JWTç”Ÿäº§ç¯å¢ƒæœ¬è´¨ï¼šå®Œæ•´çš„èº«ä»½è®¤è¯è§£å†³æ–¹æ¡ˆï¼Œä¸åªæ˜¯ç®€å•Token
ğŸ”¸ åŒTokenæœºåˆ¶ï¼šAccess TokençŸ­æœŸä½¿ç”¨ï¼ŒRefresh Tokené•¿æœŸåˆ·æ–°  
ğŸ”¸ å®‰å…¨ä¸‰è¦ç´ ï¼šTokenç­¾åéªŒè¯ã€HTTPSä¼ è¾“ã€æ•æ„Ÿä¿¡æ¯ä¿æŠ¤
ğŸ”¸ æ³¨é”€æœºåˆ¶ï¼šé»‘åå•ã€ç‰ˆæœ¬å·ã€çŸ­æœŸè¿‡æœŸç­‰å¤šç§æ–¹æ¡ˆ
ğŸ”¸ åˆ†å¸ƒå¼å¤„ç†ï¼šå…±äº«å¯†é’¥ã€åˆ†å¸ƒå¼é»‘åå•ã€æ— çŠ¶æ€è®¾è®¡
```

### 12.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä¸ºä»€ä¹ˆéœ€è¦Refresh Token**
```
æ ¸å¿ƒé—®é¢˜ï¼šAccess TokençŸ­æœŸè¿‡æœŸä¿è¯å®‰å…¨ï¼ŒRefresh Tokené•¿æœŸæœ‰æ•ˆä¿è¯ä¾¿åˆ©æ€§
å®ç°æ•ˆæœï¼šç”¨æˆ·æ— æ„ŸçŸ¥çš„Tokenè‡ªåŠ¨åˆ·æ–°ï¼Œæ—¢å®‰å…¨åˆä¾¿åˆ©
ç±»æ¯”ç†è§£ï¼šAccess Tokenåƒä¸´æ—¶é€šè¡Œè¯ï¼ŒRefresh Tokenåƒèº«ä»½è¯
```

**ğŸ”¹ JWTæ³¨é”€ä¸ºä»€ä¹ˆå¤æ‚**
```
æ ¹æœ¬åŸå› ï¼šJWTæ˜¯è‡ªåŒ…å«çš„ï¼Œæ— æ³•è¿œç¨‹æ’¤é”€
è§£å†³æ€è·¯ï¼šé€šè¿‡é»‘åå•ã€ç‰ˆæœ¬å·ç­‰æœºåˆ¶é—´æ¥å®ç°æ³¨é”€
æƒè¡¡è€ƒè™‘ï¼šå®‰å…¨æ€§ vs æ€§èƒ½ vs å®ç°å¤æ‚åº¦
```

**ğŸ”¹ ç”Ÿäº§ç¯å¢ƒçš„æ ¸å¿ƒæŒ‘æˆ˜**
```
æ€§èƒ½æŒ‘æˆ˜ï¼šå¤§é‡TokenéªŒè¯ã€é»‘åå•æŸ¥è¯¢ã€Redisè¿æ¥æ± ç®¡ç†
å®‰å…¨æŒ‘æˆ˜ï¼šTokenæ³„éœ²ã€å¯†é’¥ç®¡ç†ã€HTTPSå¼ºåˆ¶ã€æ—¥å¿—å®¡è®¡
å¯ç”¨æ€§æŒ‘æˆ˜ï¼šè´Ÿè½½å‡è¡¡ã€æ•…éšœè½¬ç§»ã€æ— çŠ¶æ€è®¾è®¡
è¿ç»´æŒ‘æˆ˜ï¼šç›‘æ§å‘Šè­¦ã€æ€§èƒ½è°ƒä¼˜ã€å®¹é‡è§„åˆ’
```

### 12.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ¯ æŠ€æœ¯é€‰å‹å»ºè®®**
```
å°å‹é¡¹ç›®(<1ä¸‡ç”¨æˆ·)ï¼š
â€¢ ä½¿ç”¨åŸºç¡€JWT + Redisé»‘åå•
â€¢ Access Token: 30åˆ†é’Ÿï¼ŒRefresh Token: 7å¤©
â€¢ å•æœºéƒ¨ç½²ï¼Œç®€å•ç›‘æ§

ä¸­å‹é¡¹ç›®(1ä¸‡-10ä¸‡ç”¨æˆ·)ï¼š
â€¢ åŒTokenæœºåˆ¶ + åˆ†å¸ƒå¼é»‘åå•
â€¢ è´Ÿè½½å‡è¡¡ + Redisé›†ç¾¤
â€¢ è¯¦ç»†ç›‘æ§ + æ€§èƒ½ä¼˜åŒ–

å¤§å‹é¡¹ç›®(>10ä¸‡ç”¨æˆ·)ï¼š
â€¢ å¸ƒéš†è¿‡æ»¤å™¨é»‘åå• + ç‰ˆæœ¬å·æœºåˆ¶
â€¢ å¾®æœåŠ¡æ¶æ„ + å…¬ç§é’¥å¯¹
â€¢ å…¨é¢ç›‘æ§ + è‡ªåŠ¨æ‰©ç¼©å®¹
```

**ğŸ”§ å¼€å‘å®è·µè¦ç‚¹**
```
å®‰å…¨å®è·µï¼š
âœ… JWTå¯†é’¥é•¿åº¦è‡³å°‘256ä½
âœ… å¼ºåˆ¶HTTPSä¼ è¾“
âœ… æ•æ„Ÿä¿¡æ¯ä¸æ”¾Tokenä¸­
âœ… å®æ–½è¯¦ç»†çš„å®‰å…¨å®¡è®¡æ—¥å¿—

æ€§èƒ½å®è·µï¼š
âœ… åˆç†è®¾ç½®Tokenè¿‡æœŸæ—¶é—´
âœ… ä½¿ç”¨è¿æ¥æ± ç®¡ç†Redisè¿æ¥
âœ… å®æ–½å¤šçº§ç¼“å­˜ç­–ç•¥
âœ… ç›‘æ§å…³é”®æ€§èƒ½æŒ‡æ ‡

è¿ç»´å®è·µï¼š
âœ… é…ç½®ä¸­å¿ƒç®¡ç†å¯†é’¥
âœ… ç¯å¢ƒå˜é‡åˆ†ç¦»æ•æ„Ÿé…ç½®
âœ… å®æ–½è“ç»¿éƒ¨ç½²
âœ… å»ºç«‹å‘Šè­¦å’Œåº”æ€¥å“åº”æœºåˆ¶
```

### 12.4 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ


**â“ Tokenè¢«ç›—ç”¨æ€ä¹ˆåŠï¼Ÿ**
```
æ£€æµ‹æœºåˆ¶ï¼š
â€¢ ç›‘æ§å¼‚å¸¸ç™»å½•IPå’Œè®¾å¤‡
â€¢ æ£€æµ‹Tokenä½¿ç”¨é¢‘ç‡å¼‚å¸¸  
â€¢ ç”¨æˆ·è¡Œä¸ºåˆ†æ

åº”å¯¹æªæ–½ï¼š
â€¢ ç«‹å³å°†TokenåŠ å…¥é»‘åå•
â€¢ å¼ºåˆ¶ç”¨æˆ·é‡æ–°ç™»å½•
â€¢ å¯ç”¨å¤šå› å­è®¤è¯
â€¢ å‘é€å®‰å…¨æé†’é€šçŸ¥
```

**â“ Rediså®•æœºå½±å“æ•´ä¸ªè®¤è¯ç³»ç»Ÿï¼Ÿ**
```
è§£å†³æ–¹æ¡ˆï¼š
â€¢ Redisä¸»ä»å¤åˆ¶ + å“¨å…µæ¨¡å¼
â€¢ Redisé›†ç¾¤éƒ¨ç½²
â€¢ æœ¬åœ°ç¼“å­˜ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
â€¢ é™çº§ç­–ç•¥ï¼šçŸ­æœŸå†…è·³è¿‡é»‘åå•æ£€æŸ¥
```

**â“ é«˜å¹¶å‘ä¸‹TokenéªŒè¯æˆä¸ºç“¶é¢ˆï¼Ÿ**
```
ä¼˜åŒ–ç­–ç•¥ï¼š
â€¢ æœ¬åœ°ç¼“å­˜çƒ­ç‚¹TokenéªŒè¯ç»“æœ
â€¢ ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å¿«é€Ÿè¿‡æ»¤
â€¢ TokenéªŒè¯ç»“æœæ‰¹é‡å¤„ç†
â€¢ è€ƒè™‘å¼‚æ­¥éªŒè¯æ¨¡å¼
```

### 12.5 å­¦ä¹ è·¯å¾„å’Œè¿›é˜¶æ–¹å‘


**ğŸ“š åŸºç¡€æŒæ¡é¡ºåº**
```
ç¬¬1æ­¥ï¼šç†è§£JWTåŸºæœ¬ç»“æ„å’ŒåŸç†
ç¬¬2æ­¥ï¼šå®ç°åŸºç¡€çš„ç™»å½•å’ŒTokenéªŒè¯  
ç¬¬3æ­¥ï¼šæ·»åŠ Tokenåˆ·æ–°æœºåˆ¶
ç¬¬4æ­¥ï¼šå®ç°å®‰å…¨çš„æ³¨é”€åŠŸèƒ½
ç¬¬5æ­¥ï¼šå¤„ç†åˆ†å¸ƒå¼ç¯å¢ƒé—®é¢˜
ç¬¬6æ­¥ï¼šæ·»åŠ ç›‘æ§å’Œæ€§èƒ½ä¼˜åŒ–
```

**ğŸš€ è¿›é˜¶å­¦ä¹ æ–¹å‘**
```
OAuth 2.0æ·±å…¥ï¼š
â€¢ å­¦ä¹ å®Œæ•´çš„OAuthæˆæƒæµç¨‹
â€¢ ç†è§£ä¸åŒæˆæƒæ¨¡å¼çš„é€‚ç”¨åœºæ™¯
â€¢ å®è·µç¬¬ä¸‰æ–¹ç™»å½•é›†æˆ

å¾®æœåŠ¡å®‰å…¨ï¼š
â€¢ æœåŠ¡é—´è®¤è¯æˆæƒ
â€¢ APIç½‘å…³é›†æˆ
â€¢ åˆ†å¸ƒå¼ä¼šè¯ç®¡ç†

é›¶ä¿¡ä»»å®‰å…¨ï¼š
â€¢ æŒç»­éªŒè¯æ¨¡å‹
â€¢ è®¾å¤‡æŒ‡çº¹è¯†åˆ«
â€¢ è¡Œä¸ºåˆ†æç³»ç»Ÿ
```

**ğŸ’¡ å®æˆ˜ç»ƒä¹ å»ºè®®**
```
åˆçº§ç»ƒä¹ ï¼š
â€¢ å®ç°ä¸€ä¸ªå®Œæ•´çš„ç”¨æˆ·ç™»å½•ç³»ç»Ÿ
â€¢ é›†æˆVue/Reactå‰ç«¯å’ŒSpring Bootåç«¯
â€¢ æ·»åŠ åŸºç¡€çš„Tokenåˆ·æ–°åŠŸèƒ½

ä¸­çº§ç»ƒä¹ ï¼š
â€¢ å®ç°åˆ†å¸ƒå¼Tokené»‘åå•
â€¢ æ·»åŠ è¯¦ç»†çš„å®‰å…¨å®¡è®¡æ—¥å¿—
â€¢ é›†æˆRedisé›†ç¾¤å’Œè´Ÿè½½å‡è¡¡

é«˜çº§ç»ƒä¹ ï¼š
â€¢ å®ç°åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶(RBAC)
â€¢ é›†æˆOAuth 2.0ç¬¬ä¸‰æ–¹ç™»å½•
â€¢ å®ç°é›¶åœæœºçš„å¯†é’¥è½®æ¢æœºåˆ¶
```

### 12.6 ç”Ÿäº§ç¯å¢ƒæ£€æŸ¥æ¸…å•


> ğŸ“‹ **ä¸Šçº¿å‰å¿…æ£€é¡¹ç›®**ï¼š

**ğŸ”’ å®‰å…¨æ£€æŸ¥**
- [ ] JWTå¯†é’¥é•¿åº¦>=256ä½ä¸”éšæœºç”Ÿæˆ
- [ ] å¼ºåˆ¶HTTPSï¼Œç¦ç”¨HTTP
- [ ] Tokenä¸­ä¸åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼ˆå¯†ç ã€é“¶è¡Œå¡ç­‰ï¼‰
- [ ] å®æ–½å®‰å…¨å¤´é…ç½®ï¼ˆHSTSã€CSPç­‰ï¼‰
- [ ] é…ç½®è¯¦ç»†çš„å®‰å…¨å®¡è®¡æ—¥å¿—

**âš¡ æ€§èƒ½æ£€æŸ¥**
- [ ] Tokenè¿‡æœŸæ—¶é—´åˆç†è®¾ç½®
- [ ] Redisè¿æ¥æ± å‚æ•°ä¼˜åŒ–
- [ ] å®æ–½æœ¬åœ°ç¼“å­˜å‡å°‘Rediså‹åŠ›
- [ ] ç›‘æ§å…³é”®æ€§èƒ½æŒ‡æ ‡
- [ ] å‹åŠ›æµ‹è¯•éªŒè¯æ€§èƒ½è¡¨ç°

**ğŸ› ï¸ å¯ç”¨æ€§æ£€æŸ¥**
- [ ] å®ç°ä¼˜é›…çš„Tokenåˆ·æ–°æœºåˆ¶
- [ ] Redisé«˜å¯ç”¨éƒ¨ç½²ï¼ˆä¸»ä»/é›†ç¾¤ï¼‰
- [ ] å®æ–½é™çº§ç­–ç•¥åº”å¯¹ä¾èµ–æ•…éšœ
- [ ] é…ç½®ç›‘æ§å‘Šè­¦
- [ ] å‡†å¤‡åº”æ€¥å“åº”é¢„æ¡ˆ

**ğŸ”§ è¿ç»´æ£€æŸ¥**
- [ ] æ•æ„Ÿé…ç½®é€šè¿‡ç¯å¢ƒå˜é‡ç®¡ç†
- [ ] æ—¥å¿—æ ¼å¼æ ‡å‡†åŒ–ï¼Œä¾¿äºåˆ†æ
- [ ] å®æ–½è“ç»¿éƒ¨ç½²æˆ–æ»šåŠ¨æ›´æ–°
- [ ] é…ç½®è‡ªåŠ¨åŒ–å¤‡ä»½æœºåˆ¶
- [ ] æ–‡æ¡£å®Œæ•´ï¼ŒåŒ…å«æ•…éšœå¤„ç†æ‰‹å†Œ

**æ ¸å¿ƒè®°å¿†**ï¼š
- JWTç”Ÿäº§ç¯å¢ƒæ˜¯å®Œæ•´è®¤è¯æ–¹æ¡ˆï¼Œä¸åªæ˜¯ç®€å•Token
- åŒTokenæœºåˆ¶å¹³è¡¡å®‰å…¨æ€§å’Œç”¨æˆ·ä½“éªŒ
- é»‘åå•æœºåˆ¶è§£å†³JWTæ— æ³•æ’¤é”€çš„é—®é¢˜
- åˆ†å¸ƒå¼ç¯å¢ƒéœ€è¦å…±äº«çŠ¶æ€å’Œæ— çŠ¶æ€è®¾è®¡
- å®‰å…¨ã€æ€§èƒ½ã€å¯ç”¨æ€§ä¸‰è€…éœ€è¦ç»¼åˆè€ƒè™‘å’Œå¹³è¡¡