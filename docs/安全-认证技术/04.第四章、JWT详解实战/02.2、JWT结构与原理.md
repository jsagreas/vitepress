---
title: 2、JWT结构与原理
---
## 📚 目录

1. [JWT是什么](#1-jwt是什么)
2. [JWT三部分结构详解](#2-jwt三部分结构详解)
3. [JWT工作原理与流程](#3-jwt工作原理与流程)
4. [JWT生成与解析过程](#4-jwt生成与解析过程)
5. [JWT校验流程详解](#5-jwt校验流程详解)
6. [JWT实际应用示例](#6-jwt实际应用示例)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 JWT是什么


### 1.1 通俗理解JWT

**JWT简单来说就是一个"电子身份证"**

```
现实生活中的身份证：
┌─────────────────────────┐
│ 姓名：张三              │
│ 性别：男                │
│ 身份证号：123456...     │
│ 发证机关：XX市公安局    │ ← 权威机构发放
│ 有效期：2030.01.01      │
│ [防伪标识]              │ ← 防止伪造
└─────────────────────────┘

JWT电子身份证：
Header.Payload.Signature
 ↑      ↑        ↑
证件类型 个人信息  防伪签名
```

### 1.2 JWT的核心作用

```
🎫 身份认证：证明"你是谁"
✅ 信息传递：安全传递用户信息
🔒 防止伪造：通过签名验证真伪
⚡ 无状态：服务器不需要存储会话
```

### 1.3 为什么需要JWT

**传统Session的问题：**
```
用户登录 → 服务器创建Session → 存储到内存/数据库
问题：
❌ 服务器需要存储Session（占用内存）
❌ 集群环境下Session共享复杂
❌ 移动端支持不友好

JWT的优势：
✅ 服务器无状态（不需要存储）
✅ 跨服务器使用（分布式友好）
✅ 移动端友好（HTTP Header传输）
```

---

## 2. 🧩 JWT三部分结构详解


### 2.1 JWT整体结构

```
完整的JWT格式：
Header.Payload.Signature

真实示例：
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

拆分后：
Header:    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
Payload:   eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
Signature: SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### 2.2 Header（头部）- "证件类型"

**Header就是说明"这是什么类型的证件"**

```json
{
  "alg": "HS256",    // 签名算法：这个证件用什么方式防伪
  "typ": "JWT"       // 令牌类型：这是JWT类型的证件
}
```

**Header详细解释：**
- `alg`**（算法）**：就像身份证用什么防伪技术，JWT用什么签名算法
  - `HS256`：用密码加密的方式（对称加密）
  - `RS256`：用公钥私钥加密的方式（非对称加密）
- `typ`**（类型）**：固定写"JWT"，表明这是JWT令牌

### 2.3 Payload（载荷）- "个人信息"

**Payload就是"身份证上的个人信息"**

```json
{
  "sub": "1234567890",        // 用户ID（像身份证号）
  "name": "张三",              // 用户姓名
  "role": "admin",            // 用户角色
  "iat": 1516239022,          // 签发时间（什么时候办的证）
  "exp": 1516325422           // 过期时间（证件有效期）
}
```

**Payload包含三种声明：**

**🔸 注册声明（标准字段）**
```
sub (subject)：用户ID，证件主人
iat (issued at)：签发时间
exp (expires)：过期时间
iss (issuer)：签发者，谁发的证
aud (audience)：接收者，给谁用的证
```

**🔸 公共声明（公开信息）**
```
name：姓名
email：邮箱
role：角色
permissions：权限列表
```

**🔸 私有声明（自定义信息）**
```
userId：用户ID
companyId：公司ID  
department：部门
```

### 2.4 Signature（签名）- "防伪标识"

**Signature就是"防伪印章"，防止别人伪造**

```javascript
// 签名生成过程（简化理解）
let header64 = base64encode(header)         // 把头部信息编码
let payload64 = base64encode(payload)       // 把个人信息编码
let data = header64 + "." + payload64       // 拼接起来
let signature = HMACSHA256(data, secret)    // 用密钥加密生成签名

// 最终JWT
jwt = header64 + "." + payload64 + "." + signature
```

**签名的作用：**
- 🔒 **防止篡改**：如果有人修改了信息，签名就对不上了
- ✅ **验证真伪**：只有知道密钥的服务器才能验证签名
- 🛡️ **保证完整性**：确保JWT内容没有被修改

---

## 3. ⚙️ JWT工作原理与流程


### 3.1 JWT完整工作流程

```
用户端                    服务器端                   资源服务器
  │                          │                          │
  │ 1. 用户登录               │                          │
  │ ─────────────────────────→│                          │
  │   username: admin        │                          │
  │   password: 123456       │                          │
  │                          │ 2. 验证用户信息           │
  │                          │    查询数据库            │
  │                          │    ✅ 验证成功           │
  │                          │                          │
  │                          │ 3. 生成JWT               │
  │                          │    Header + Payload      │
  │                          │    + Signature           │
  │ 4. 返回JWT                │                          │
  │ ←─────────────────────────│                          │
  │   token: eyJhbGc...      │                          │
  │                          │                          │
  │ 5. 存储JWT                │                          │
  │    (localStorage)        │                          │
  │                          │                          │
  │ 6. 请求资源                                         │
  │ ─────────────────────────────────────────────────→│
  │   Authorization: Bearer eyJhbGc...                 │
  │                          │                          │
  │                          │                          │ 7. 验证JWT
  │                          │                          │    解析+验签
  │                          │                          │    ✅ 有效
  │                          │                          │
  │ 8. 返回资源                                         │
  │ ←─────────────────────────────────────────────────│
  │   { data: "用户数据" }                             │
```

### 3.2 登录认证流程详解

```
📝 步骤1：用户提交登录信息
用户输入：用户名 admin，密码 123456
发送到：POST /login

🔍 步骤2：服务器验证
验证用户名密码是否正确
查询数据库中的用户信息

🎫 步骤3：生成JWT
如果验证成功，服务器生成JWT：
- Header：指定签名算法
- Payload：放入用户信息
- Signature：用密钥签名防伪

📤 步骤4：返回JWT
服务器返回JWT给客户端
客户端保存JWT（通常存localStorage）

🔑 步骤5：后续请求携带JWT
客户端每次请求都携带JWT
放在HTTP Header中：Authorization: Bearer <token>

✅ 步骤6：服务器验证JWT
服务器收到请求后验证JWT：
- 检查签名是否有效
- 检查是否过期
- 获取用户信息
```

---

## 4. 🔨 JWT生成与解析过程


### 4.1 JWT生成过程（编码）

```javascript
// 步骤1：准备Header
const header = {
  alg: "HS256",    // 使用HMAC SHA256算法
  typ: "JWT"       // 类型是JWT
}

// 步骤2：准备Payload
const payload = {
  userId: 123,                    // 用户ID
  username: "admin",              // 用户名
  role: "admin",                  // 角色
  iat: Math.floor(Date.now() / 1000),        // 当前时间
  exp: Math.floor(Date.now() / 1000) + 3600  // 1小时后过期
}

// 步骤3：Base64编码
const headerBase64 = base64UrlEncode(JSON.stringify(header))
const payloadBase64 = base64UrlEncode(JSON.stringify(payload))

// 步骤4：生成签名
const data = headerBase64 + "." + payloadBase64
const signature = HMACSHA256(data, "your-secret-key")
const signatureBase64 = base64UrlEncode(signature)

// 步骤5：拼接成完整JWT
const jwt = headerBase64 + "." + payloadBase64 + "." + signatureBase64
```

**生成示例代码：**
```javascript
// 使用Node.js生成JWT
const jwt = require('jsonwebtoken');

function generateJWT(userInfo) {
  const secret = 'my-secret-key';  // 密钥（实际项目要保密）
  
  const payload = {
    userId: userInfo.id,
    username: userInfo.username,
    role: userInfo.role
  };
  
  const options = {
    expiresIn: '1h'  // 1小时后过期
  };
  
  return jwt.sign(payload, secret, options);
}

// 使用示例
const user = { id: 123, username: 'admin', role: 'admin' };
const token = generateJWT(user);
console.log(token);
// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQi...
```

### 4.2 JWT解析过程（解码）

```javascript
// JWT解析步骤
function parseJWT(token) {
  // 步骤1：分割JWT
  const parts = token.split('.');
  if (parts.length !== 3) {
    throw new Error('JWT格式错误');
  }
  
  // 步骤2：解码各部分
  const header = JSON.parse(base64UrlDecode(parts[0]));
  const payload = JSON.parse(base64UrlDecode(parts[1]));
  const signature = parts[2];
  
  // 步骤3：验证签名
  const data = parts[0] + '.' + parts[1];
  const expectedSignature = HMACSHA256(data, 'your-secret-key');
  
  if (signature !== base64UrlEncode(expectedSignature)) {
    throw new Error('JWT签名无效');
  }
  
  // 步骤4：检查过期时间
  if (payload.exp && payload.exp < Date.now() / 1000) {
    throw new Error('JWT已过期');
  }
  
  return { header, payload };
}
```

**解析示例代码：**
```javascript
// 使用Node.js解析JWT
const jwt = require('jsonwebtoken');

function verifyJWT(token) {
  const secret = 'my-secret-key';
  
  try {
    // 验证并解析JWT
    const decoded = jwt.verify(token, secret);
    
    console.log('用户ID:', decoded.userId);
    console.log('用户名:', decoded.username);
    console.log('角色:', decoded.role);
    
    return decoded;
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      console.log('JWT已过期');
    } else if (error.name === 'JsonWebTokenError') {
      console.log('JWT格式错误或签名无效');
    }
    return null;
  }
}

// 使用示例
const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';
const userInfo = verifyJWT(token);
```

---

## 5. ✅ JWT校验流程详解


### 5.1 JWT校验步骤

```
🔍 JWT校验的4个步骤：

1️⃣ 格式校验：检查是否是 xxx.xxx.xxx 格式
2️⃣ 签名校验：验证签名是否有效（防伪检查）
3️⃣ 时间校验：检查JWT是否过期
4️⃣ 内容校验：检查用户信息是否有效
```

### 5.2 详细校验流程

```javascript
function validateJWT(token) {
  // 第1步：格式校验
  if (!token) {
    return { valid: false, error: '缺少JWT token' };
  }
  
  const parts = token.split('.');
  if (parts.length !== 3) {
    return { valid: false, error: 'JWT格式错误' };
  }
  
  try {
    // 第2步：解码Header和Payload
    const header = JSON.parse(base64decode(parts[0]));
    const payload = JSON.parse(base64decode(parts[1]));
    
    // 第3步：签名校验
    const expectedSignature = generateSignature(parts[0] + '.' + parts[1]);
    if (parts[2] !== expectedSignature) {
      return { valid: false, error: 'JWT签名无效' };
    }
    
    // 第4步：时间校验
    const now = Math.floor(Date.now() / 1000);
    
    // 检查过期时间
    if (payload.exp && payload.exp < now) {
      return { valid: false, error: 'JWT已过期' };
    }
    
    // 检查生效时间
    if (payload.nbf && payload.nbf > now) {
      return { valid: false, error: 'JWT尚未生效' };
    }
    
    // 第5步：业务校验
    if (!payload.userId) {
      return { valid: false, error: '缺少用户信息' };
    }
    
    return { 
      valid: true, 
      user: {
        id: payload.userId,
        username: payload.username,
        role: payload.role
      }
    };
    
  } catch (error) {
    return { valid: false, error: 'JWT解析失败' };
  }
}
```

### 5.3 服务器端JWT中间件

```javascript
// Express.js JWT验证中间件
function jwtMiddleware(req, res, next) {
  // 从请求头获取token
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: '缺少访问令牌' });
  }
  
  // 验证JWT
  const result = validateJWT(token);
  
  if (!result.valid) {
    return res.status(401).json({ error: result.error });
  }
  
  // 将用户信息添加到请求对象
  req.user = result.user;
  next();
}

// 使用中间件保护路由
app.get('/api/profile', jwtMiddleware, (req, res) => {
  // 这里可以安全地使用 req.user
  res.json({
    message: '获取用户信息成功',
    user: req.user
  });
});
```

---

## 6. 🛠️ JWT实际应用示例


### 6.1 前端JWT使用示例

```javascript
// JWT工具类
class JWTHelper {
  // 保存JWT到本地存储
  static saveToken(token) {
    localStorage.setItem('jwt_token', token);
  }
  
  // 获取JWT
  static getToken() {
    return localStorage.getItem('jwt_token');
  }
  
  // 删除JWT（退出登录）
  static removeToken() {
    localStorage.removeItem('jwt_token');
  }
  
  // 检查JWT是否过期
  static isTokenExpired() {
    const token = this.getToken();
    if (!token) return true;
    
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const now = Date.now() / 1000;
      return payload.exp < now;
    } catch (error) {
      return true;
    }
  }
}

// 登录函数
async function login(username, password) {
  try {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    });
    
    const data = await response.json();
    
    if (data.token) {
      JWTHelper.saveToken(data.token);
      console.log('登录成功');
      return true;
    }
  } catch (error) {
    console.log('登录失败:', error);
    return false;
  }
}

// 发送需要认证的请求
async function fetchUserData() {
  const token = JWTHelper.getToken();
  
  if (!token || JWTHelper.isTokenExpired()) {
    console.log('需要重新登录');
    return;
  }
  
  try {
    const response = await fetch('/api/user', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    const userData = await response.json();
    console.log('用户数据:', userData);
  } catch (error) {
    console.log('获取数据失败:', error);
  }
}
```

### 6.2 后端JWT验证示例

```javascript
// Node.js + Express JWT示例
const express = require('express');
const jwt = require('jsonwebtoken');
const app = express();

const JWT_SECRET = 'your-super-secret-key';

// 登录接口
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  
  // 验证用户名密码（这里简化处理）
  if (username === 'admin' && password === '123456') {
    // 生成JWT
    const token = jwt.sign(
      {
        userId: 1,
        username: 'admin',
        role: 'admin'
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({ 
      success: true, 
      token: token,
      message: '登录成功'
    });
  } else {
    res.status(401).json({ 
      success: false, 
      message: '用户名或密码错误' 
    });
  }
});

// JWT验证中间件
function authenticateJWT(req, res, next) {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: '缺少访问令牌' });
  }
  
  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: '令牌无效' });
    }
    req.user = user;
    next();
  });
}

// 受保护的接口
app.get('/api/user', authenticateJWT, (req, res) => {
  res.json({
    success: true,
    user: req.user,
    message: '获取用户信息成功'
  });
});
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 JWT本质：一个包含用户信息的加密字符串，像电子身份证
🔸 三部分结构：Header.Payload.Signature（头部.载荷.签名）
🔸 工作原理：客户端携带JWT，服务器验证JWT获取用户信息
🔸 主要优势：无状态、跨服务器、移动端友好
🔸 核心作用：身份认证、信息传递、防止伪造
```

### 7.2 JWT三部分详解


**🔹 Header（头部）- "证件类型"**
```
作用：说明JWT使用的签名算法和类型
内容：{ "alg": "HS256", "typ": "JWT" }
理解：就像身份证上印着"居民身份证"几个字
```

**🔹 Payload（载荷）- "个人信息"**
```
作用：存储用户信息和JWT元数据
内容：用户ID、角色、过期时间等
理解：就像身份证上的姓名、性别、身份证号
注意：信息是Base64编码的，不是加密（可以解码看到）
```

**🔹 Signature（签名）- "防伪标识"**
```
作用：防止JWT被篡改，验证JWT真伪
生成：用密钥对Header+Payload进行加密
理解：就像身份证上的防伪标识和印章
关键：只有知道密钥的服务器才能验证和生成
```

### 7.3 JWT工作流程记忆


```
登录阶段：
1. 用户提交用户名密码
2. 服务器验证成功后生成JWT
3. 返回JWT给客户端保存

使用阶段：
4. 客户端每次请求携带JWT（HTTP Header）
5. 服务器验证JWT获取用户信息
6. 返回请求的数据

验证过程：
✅ 检查JWT格式是否正确
✅ 验证签名是否有效（防伪）
✅ 检查是否过期
✅ 获取用户信息
```

### 7.4 实际应用要点


**🔹 JWT存储方式**
```
常用存储：localStorage、sessionStorage
安全考虑：HttpOnly Cookie更安全
移动端：通常存储在安全的本地存储
```

**🔹 JWT使用注意事项**
```
✅ 设置合理的过期时间
✅ 密钥要保密且足够复杂
✅ 敏感信息不要放在Payload中
✅ HTTPS传输保证安全
❌ 不要在URL中传递JWT
❌ 注销时要让JWT失效
```

**🔹 JWT vs Session对比**
```
JWT优势：
- 服务器无状态（不需要存储）
- 分布式系统友好
- 移动端支持好

Session优势：
- 可以随时撤销
- 服务器可控性强
- 不会暴露用户信息
```

### 7.5 核心记忆口诀


```
JWT三部分，头载签名不能少
Header说明算法类型很重要  
Payload存放用户信息要记牢
Signature防伪签名是关键
Base64编码拼接用点号
服务器验签获取用户信息妙
```

**实际理解**：
- JWT就是一个"会说话的身份证"
- 不需要查数据库就知道用户是谁
- 通过签名保证身份证是真的
- 过期了就需要重新办理（重新登录）