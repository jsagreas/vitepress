---
title: 12、Token失效与登出机制
---
## 📚 目录

1. [Token失效机制概述](#1-Token失效机制概述)
2. [主动注销Token机制](#2-主动注销Token机制)
3. [黑名单机制实现](#3-黑名单机制实现)
4. [被动失效机制](#4-被动失效机制)
5. [全局登出实现](#5-全局登出实现)
6. [多设备Token管理策略](#6-多设备Token管理策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔐 Token失效机制概述


### 1.1 什么是Token失效


**简单理解**：Token失效就是让一个已经发出的Token变成"无效状态"，用户再用这个Token就访问不了系统了。

```
生活类比：
银行卡 → Token
挂失银行卡 → Token失效
挂失后卡就不能用了 → Token失效后无法访问
```

### 1.2 为什么需要Token失效


**核心原因**：
- 🔒 **安全需要**：用户主动退出登录时，Token应该立即失效
- 🛡️ **防止盗用**：Token被盗后可以及时失效，阻止恶意使用
- 👥 **账户管理**：管理员可以强制某个用户下线
- 📱 **设备管理**：用户可以让其他设备上的登录失效

### 1.3 Token失效的两种方式


```
主动失效：
用户点击"退出登录" → 系统主动让Token失效
管理员强制下线用户 → 系统主动让Token失效

被动失效：
Token到期了 → 自然失效
长时间不使用 → 自动失效
```

---

## 2. ✋ 主动注销Token机制


### 2.1 什么是主动注销


**通俗解释**：主动注销就是用户或系统**主动**让Token失效，不等它自然过期。

```
现实场景：
❌ 被动等待：等银行卡到期作废
✅ 主动处理：立即挂失银行卡

Token场景：
❌ 被动等待：等Token过期失效
✅ 主动处理：立即让Token失效
```

### 2.2 服务端标记失效的原理


**核心思路**：在服务器端维护一个"失效Token列表"

```
用户登录流程：
1. 用户登录 → 生成Token → 返回给用户
2. 用户使用Token访问接口 → 服务器验证Token有效性
3. 用户点击退出 → 服务器将Token加入失效列表
4. 用户再次使用Token → 服务器检查发现Token已失效 → 拒绝访问
```

### 2.3 实现代码示例


**简单的失效机制**：

```javascript
// 存储失效的Token（实际项目中用Redis）
const invalidTokens = new Set();

// 用户退出登录接口
app.post('/logout', (req, res) => {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (token) {
        // 将Token加入失效列表
        invalidTokens.add(token);
        res.json({ message: '退出成功' });
    } else {
        res.status(400).json({ error: 'Token不存在' });
    }
});

// 验证Token的中间件
function verifyToken(req, res, next) {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    // 1. 检查Token是否在失效列表中
    if (invalidTokens.has(token)) {
        return res.status(401).json({ error: 'Token已失效，请重新登录' });
    }
    
    // 2. 验证Token是否有效和过期
    try {
        const decoded = jwt.verify(token, 'secret');
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({ error: 'Token无效或已过期' });
    }
}
```

**管理员强制下线**：

```javascript
// 管理员强制用户下线
app.post('/admin/force-logout/:userId', (req, res) => {
    const userId = req.params.userId;
    
    // 找到该用户的所有有效Token并使其失效
    // 实际实现中需要维护用户和Token的关系
    const userTokens = getUserTokens(userId); // 获取用户的所有Token
    
    userTokens.forEach(token => {
        invalidTokens.add(token); // 将用户的所有Token都失效
    });
    
    res.json({ message: `用户 ${userId} 已被强制下线` });
});
```

---

## 3. 🚫 黑名单机制实现


### 3.1 什么是黑名单机制


**通俗理解**：黑名单就像是一个"禁止入内"的名单，凡是在名单上的Token都不能使用。

```
生活类比：
商店黑名单 → 记录不受欢迎的顾客
Token黑名单 → 记录已失效的Token

黑名单顾客不能进店 → 黑名单Token不能访问系统
```

### 3.2 黑名单的存储策略


**Redis存储方案**（推荐）：

```javascript
const redis = require('redis');
const client = redis.createClient();

// 将Token加入黑名单
async function addToBlacklist(token, expireTime) {
    // 用Token作为key，存储到Redis
    // 设置过期时间为Token的剩余有效期
    const remainingTime = expireTime - Date.now();
    
    if (remainingTime > 0) {
        await client.setex(`blacklist:${token}`, Math.floor(remainingTime / 1000), 'invalid');
    }
}

// 检查Token是否在黑名单中
async function isInBlacklist(token) {
    const result = await client.get(`blacklist:${token}`);
    return result !== null; // 如果存在就是在黑名单中
}

// 用户退出登录
app.post('/logout', async (req, res) => {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    try {
        // 解析Token获取过期时间
        const decoded = jwt.decode(token);
        const expireTime = decoded.exp * 1000; // JWT的exp是秒，转换为毫秒
        
        // 将Token加入黑名单
        await addToBlacklist(token, expireTime);
        
        res.json({ message: '退出成功' });
    } catch (error) {
        res.status(400).json({ error: '退出失败' });
    }
});
```

**数据库存储方案**：

```javascript
// 数据库表结构
/*
CREATE TABLE token_blacklist (
    id INT AUTO_INCREMENT PRIMARY KEY,
    token VARCHAR(500) NOT NULL,
    expire_time TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_token (token),
    INDEX idx_expire_time (expire_time)
);
*/

// 将Token加入数据库黑名单
async function addToBlacklistDB(token, expireTime) {
    const query = `
        INSERT INTO token_blacklist (token, expire_time) 
        VALUES (?, FROM_UNIXTIME(?))
    `;
    await db.execute(query, [token, Math.floor(expireTime / 1000)]);
}

// 检查Token是否在数据库黑名单中
async function isInBlacklistDB(token) {
    const query = `
        SELECT 1 FROM token_blacklist 
        WHERE token = ? AND expire_time > NOW() 
        LIMIT 1
    `;
    const result = await db.execute(query, [token]);
    return result.length > 0;
}

// 清理过期的黑名单记录（定时任务）
async function cleanExpiredBlacklist() {
    const query = `DELETE FROM token_blacklist WHERE expire_time < NOW()`;
    await db.execute(query);
}
```

### 3.3 两种方案对比


| 特性 | **Redis方案** | **数据库方案** |
|------|-------------|---------------|
| 🚀 **性能** | 极快，内存操作 | 较慢，磁盘I/O |
| 💾 **持久性** | 重启可能丢失 | 永久保存 |
| 🔧 **维护** | 自动过期清理 | 需要定时清理 |
| 💰 **成本** | 需要Redis服务 | 使用现有数据库 |
| 📊 **适用场景** | 高并发系统 | 中小型系统 |

---

## 4. ⏰ 被动失效机制


### 4.1 什么是被动失效


**通俗解释**：被动失效就是Token**自然过期**，不需要人为干预。

```
生活类比：
牛奶保质期 → Token过期时间
过期自然坏掉 → Token自然失效
不需要人为处理 → 系统自动判断
```

### 4.2 过期时间机制


**JWT内置过期机制**：

```javascript
// 创建Token时设置过期时间
function createToken(userId) {
    const payload = {
        userId: userId,
        iat: Math.floor(Date.now() / 1000), // 发布时间
        exp: Math.floor(Date.now() / 1000) + (2 * 60 * 60) // 2小时后过期
    };
    
    return jwt.sign(payload, 'secret');
}

// 验证Token时自动检查过期
function verifyToken(token) {
    try {
        // jwt.verify会自动检查exp字段
        const decoded = jwt.verify(token, 'secret');
        return { valid: true, data: decoded };
    } catch (error) {
        if (error.name === 'TokenExpiredError') {
            return { valid: false, reason: 'Token已过期' };
        }
        return { valid: false, reason: 'Token无效' };
    }
}
```

### 4.3 不同过期时间策略


**根据安全级别设置**：

```javascript
// 不同类型Token的过期时间配置
const TOKEN_EXPIRES = {
    // 普通用户：2小时
    user: 2 * 60 * 60,
    
    // 管理员：1小时（更安全）
    admin: 1 * 60 * 60,
    
    // 移动端：7天（用户体验优先）
    mobile: 7 * 24 * 60 * 60,
    
    // 敏感操作：30分钟
    sensitive: 30 * 60
};

function createTokenByRole(userId, role) {
    const expiresIn = TOKEN_EXPIRES[role] || TOKEN_EXPIRES.user;
    
    const payload = {
        userId: userId,
        role: role,
        exp: Math.floor(Date.now() / 1000) + expiresIn
    };
    
    return jwt.sign(payload, 'secret');
}
```

### 4.4 滑动过期机制


**什么是滑动过期**：用户活跃时自动延长Token有效期

```javascript
// 滑动过期中间件
function slidingExpiration(req, res, next) {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    try {
        const decoded = jwt.verify(token, 'secret');
        const now = Math.floor(Date.now() / 1000);
        
        // 如果Token还有不到30分钟过期，自动续期
        if (decoded.exp - now < 30 * 60) {
            const newToken = createToken(decoded.userId);
            res.setHeader('New-Token', newToken); // 返回新Token给前端
        }
        
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({ error: 'Token无效' });
    }
}
```

---

## 5. 🌐 全局登出实现


### 5.1 什么是全局登出


**通俗理解**：全局登出就是让用户在**所有设备**上的登录都失效。

```
现实场景：
微信账号异常 → 微信强制你在所有设备重新登录
银行卡密码错误多次 → 银行冻结所有相关服务

系统场景：
密码被修改 → 所有设备的Token都失效
管理员操作 → 强制用户在所有地方重新登录
```

### 5.2 全局登出的实现策略


**方案一：用户版本号机制**

```javascript
// 用户表增加version字段
/*
ALTER TABLE users ADD COLUMN token_version INT DEFAULT 1;
*/

// 创建Token时包含version
function createTokenWithVersion(userId) {
    const user = getUserById(userId); // 从数据库获取用户信息
    
    const payload = {
        userId: userId,
        version: user.token_version, // 包含当前版本号
        exp: Math.floor(Date.now() / 1000) + (2 * 60 * 60)
    };
    
    return jwt.sign(payload, 'secret');
}

// 验证Token时检查version
async function verifyTokenWithVersion(token) {
    try {
        const decoded = jwt.verify(token, 'secret');
        const user = await getUserById(decoded.userId);
        
        // 检查Token中的版本号是否与数据库一致
        if (decoded.version !== user.token_version) {
            return { valid: false, reason: 'Token版本过期，请重新登录' };
        }
        
        return { valid: true, data: decoded };
    } catch (error) {
        return { valid: false, reason: 'Token无效' };
    }
}

// 全局登出：增加用户的版本号
async function globalLogout(userId) {
    const query = `
        UPDATE users 
        SET token_version = token_version + 1 
        WHERE id = ?
    `;
    await db.execute(query, [userId]);
    
    // 版本号+1后，所有旧Token的version就不匹配了，全部失效
}
```

**方案二：用户Token列表管理**

```javascript
// Redis存储用户的有效Token列表
async function addUserToken(userId, token) {
    const key = `user_tokens:${userId}`;
    await redis.sadd(key, token); // 将Token加入用户的集合
    await redis.expire(key, 7 * 24 * 60 * 60); // 设置7天过期
}

// 验证Token是否在用户的有效列表中
async function isValidUserToken(userId, token) {
    const key = `user_tokens:${userId}`;
    const result = await redis.sismember(key, token);
    return result === 1;
}

// 全局登出：清空用户的所有Token
async function globalLogoutClearTokens(userId) {
    const key = `user_tokens:${userId}`;
    await redis.del(key); // 删除用户的整个Token集合
}

// 单设备登出：只删除当前Token
async function singleDeviceLogout(userId, token) {
    const key = `user_tokens:${userId}`;
    await redis.srem(key, token); // 从集合中移除指定Token
}
```

### 5.3 触发全局登出的场景


```javascript
// 场景1：用户修改密码
app.post('/change-password', async (req, res) => {
    const { userId, oldPassword, newPassword } = req.body;
    
    // 验证旧密码
    const isValidOldPassword = await verifyPassword(userId, oldPassword);
    if (!isValidOldPassword) {
        return res.status(400).json({ error: '旧密码错误' });
    }
    
    // 更新密码
    await updatePassword(userId, newPassword);
    
    // 全局登出：让所有设备重新登录
    await globalLogout(userId);
    
    res.json({ message: '密码修改成功，请重新登录' });
});

// 场景2：管理员强制全局下线
app.post('/admin/global-logout/:userId', async (req, res) => {
    const userId = req.params.userId;
    
    await globalLogout(userId);
    
    res.json({ message: `用户 ${userId} 已被全局强制下线` });
});

// 场景3：检测到异常登录
async function detectAbnormalLogin(userId, loginInfo) {
    const isAbnormal = await checkLoginPattern(userId, loginInfo);
    
    if (isAbnormal) {
        // 异常登录，全局登出
        await globalLogout(userId);
        
        // 发送通知给用户
        await sendSecurityAlert(userId, '检测到异常登录，已强制全部下线');
    }
}
```

---

## 6. 📱 多设备Token管理策略


### 6.1 什么是多设备管理


**现实场景理解**：
```
你的微信可以同时在：
📱 手机上登录
💻 电脑上登录  
🌐 网页版登录

每个设备都有自己的"登录状态" → 每个设备都有自己的Token
你可以单独让某个设备下线 → 可以单独失效某个设备的Token
```

### 6.2 设备Token管理数据结构


**Redis存储方案**：

```javascript
// 数据结构设计
/*
用户设备Token映射：
user_devices:123 = {
    "mobile_ios_uuid1": "token_abc123",
    "pc_windows_uuid2": "token_def456", 
    "web_chrome_uuid3": "token_ghi789"
}

设备信息详情：
device:mobile_ios_uuid1 = {
    "userId": 123,
    "deviceType": "mobile",
    "platform": "ios", 
    "deviceId": "uuid1",
    "lastActive": "2024-01-19T10:30:00Z",
    "loginTime": "2024-01-19T08:00:00Z",
    "ipAddress": "192.168.1.100"
}
*/

// 用户登录时记录设备信息
async function loginWithDevice(userId, deviceInfo, token) {
    const deviceKey = `${deviceInfo.deviceType}_${deviceInfo.platform}_${deviceInfo.deviceId}`;
    
    // 1. 存储用户设备Token映射
    await redis.hset(`user_devices:${userId}`, deviceKey, token);
    
    // 2. 存储设备详细信息
    const deviceData = {
        userId: userId,
        deviceType: deviceInfo.deviceType,
        platform: deviceInfo.platform,
        deviceId: deviceInfo.deviceId,
        lastActive: new Date().toISOString(),
        loginTime: new Date().toISOString(),
        ipAddress: deviceInfo.ipAddress
    };
    
    await redis.hset(`device:${deviceKey}`, deviceData);
    
    // 3. 设置过期时间
    await redis.expire(`user_devices:${userId}`, 7 * 24 * 60 * 60);
    await redis.expire(`device:${deviceKey}`, 7 * 24 * 60 * 60);
}
```

### 6.3 设备管理策略


**策略一：设备数量限制**

```javascript
// 限制同类设备登录数量
const DEVICE_LIMITS = {
    mobile: 2,    // 最多2个手机
    pc: 1,        // 最多1台电脑
    web: 3        // 最多3个浏览器
};

async function checkDeviceLimit(userId, deviceType) {
    const userDevices = await redis.hgetall(`user_devices:${userId}`);
    
    // 统计同类型设备数量
    let sameTypeCount = 0;
    for (let deviceKey in userDevices) {
        if (deviceKey.startsWith(deviceType)) {
            sameTypeCount++;
        }
    }
    
    const limit = DEVICE_LIMITS[deviceType] || 1;
    
    if (sameTypeCount >= limit) {
        // 超出限制，踢掉最旧的设备
        await removeOldestDevice(userId, deviceType);
    }
}

// 移除最旧的设备
async function removeOldestDevice(userId, deviceType) {
    const userDevices = await redis.hgetall(`user_devices:${userId}`);
    
    let oldestDevice = null;
    let oldestTime = null;
    
    for (let deviceKey in userDevices) {
        if (deviceKey.startsWith(deviceType)) {
            const deviceInfo = await redis.hgetall(`device:${deviceKey}`);
            const loginTime = new Date(deviceInfo.loginTime);
            
            if (!oldestTime || loginTime < oldestTime) {
                oldestTime = loginTime;
                oldestDevice = deviceKey;
            }
        }
    }
    
    if (oldestDevice) {
        // 将该设备的Token加入黑名单
        const token = userDevices[oldestDevice];
        await addToBlacklist(token);
        
        // 删除设备记录
        await redis.hdel(`user_devices:${userId}`, oldestDevice);
        await redis.del(`device:${oldestDevice}`);
    }
}
```

**策略二：设备活跃度管理**

```javascript
// 更新设备活跃时间
async function updateDeviceActivity(token) {
    const decoded = jwt.decode(token);
    const userId = decoded.userId;
    const userDevices = await redis.hgetall(`user_devices:${userId}`);
    
    // 找到对应的设备
    for (let deviceKey in userDevices) {
        if (userDevices[deviceKey] === token) {
            await redis.hset(`device:${deviceKey}`, 'lastActive', new Date().toISOString());
            break;
        }
    }
}

// 清理长时间不活跃的设备
async function cleanInactiveDevices() {
    const keys = await redis.keys('device:*');
    const inactiveThreshold = 30 * 24 * 60 * 60 * 1000; // 30天
    
    for (let key of keys) {
        const deviceInfo = await redis.hgetall(key);
        const lastActive = new Date(deviceInfo.lastActive);
        
        if (Date.now() - lastActive.getTime() > inactiveThreshold) {
            // 设备30天未活跃，移除
            const deviceKey = key.replace('device:', '');
            const token = await redis.hget(`user_devices:${deviceInfo.userId}`, deviceKey);
            
            if (token) {
                await addToBlacklist(token);
                await redis.hdel(`user_devices:${deviceInfo.userId}`, deviceKey);
            }
            
            await redis.del(key);
        }
    }
}
```

### 6.4 用户设备管理接口


```javascript
// 获取用户的所有设备
app.get('/user/devices', async (req, res) => {
    const userId = req.user.userId;
    const userDevices = await redis.hgetall(`user_devices:${userId}`);
    
    const devices = [];
    for (let deviceKey in userDevices) {
        const deviceInfo = await redis.hgetall(`device:${deviceKey}`);
        devices.push({
            deviceKey: deviceKey,
            deviceType: deviceInfo.deviceType,
            platform: deviceInfo.platform,
            lastActive: deviceInfo.lastActive,
            loginTime: deviceInfo.loginTime,
            ipAddress: deviceInfo.ipAddress,
            isCurrent: userDevices[deviceKey] === req.token // 标记当前设备
        });
    }
    
    res.json({ devices });
});

// 踢出指定设备
app.post('/user/devices/:deviceKey/logout', async (req, res) => {
    const userId = req.user.userId;
    const deviceKey = req.params.deviceKey;
    
    // 获取设备的Token
    const token = await redis.hget(`user_devices:${userId}`, deviceKey);
    
    if (token) {
        // 将Token加入黑名单
        await addToBlacklist(token);
        
        // 删除设备记录
        await redis.hdel(`user_devices:${userId}`, deviceKey);
        await redis.del(`device:${deviceKey}`);
        
        res.json({ message: '设备已下线' });
    } else {
        res.status(404).json({ error: '设备不存在' });
    }
});

// 踢出所有其他设备（只保留当前设备）
app.post('/user/logout-other-devices', async (req, res) => {
    const userId = req.user.userId;
    const currentToken = req.token;
    const userDevices = await redis.hgetall(`user_devices:${userId}`);
    
    for (let deviceKey in userDevices) {
        const token = userDevices[deviceKey];
        
        if (token !== currentToken) {
            // 不是当前设备，踢出
            await addToBlacklist(token);
            await redis.hdel(`user_devices:${userId}`, deviceKey);
            await redis.del(`device:${deviceKey}`);
        }
    }
    
    res.json({ message: '其他设备已全部下线' });
});
```

---

## 7. 📋 核心要点总结


### 7.1 必须理解的核心概念


```
🔸 Token失效：让Token变成无效状态，无法继续使用
🔸 主动失效：人为主动让Token失效（用户退出、管理员操作）
🔸 被动失效：Token自然过期失效，无需人为干预
🔸 黑名单机制：维护失效Token列表，拦截无效访问
🔸 全局登出：让用户在所有设备的登录都失效
🔸 多设备管理：管理用户在不同设备上的Token状态
```

### 7.2 实现方案选择指南


**黑名单存储方案选择**：
```
高并发系统 → 选择Redis方案
- 优点：性能极佳，自动过期清理
- 缺点：重启可能丢失数据

中小型系统 → 选择数据库方案  
- 优点：数据持久，成本较低
- 缺点：性能一般，需要定时清理
```

**全局登出方案选择**：
```
简单系统 → 版本号机制
- 实现简单，只需要在用户表加一个字段
- 适合不需要精细设备管理的系统

复杂系统 → Token列表管理
- 功能强大，支持精细的设备管理
- 适合需要详细设备信息的系统
```

### 7.3 关键注意事项


**⚠️ 安全注意事项**：
- Token失效后要立即生效，不能有延迟
- 黑名单要设置合理的过期时间，避免无限膨胀
- 敏感操作后要考虑强制重新认证

**🔧 性能注意事项**：  
- Redis黑名单要设置过期时间，避免内存泄漏
- 数据库黑名单要定时清理过期记录
- 设备信息不要存储过多详细信息，避免存储压力

**💡 用户体验注意事项**：
- 全局登出要给用户明确提示
- 设备被踢出要通过适当方式通知用户
- 提供设备管理界面让用户自主管理

### 7.4 常见应用场景


**🎯 业务场景应用**：
- **电商系统**：用户修改密码后全局下线，保护账户安全
- **办公系统**：员工离职后管理员强制下线所有设备
- **社交应用**：检测异常登录后自动全局下线并通知用户
- **金融系统**：敏感操作后要求重新认证，短期Token失效

**核心记忆要点**：
- Token失效是安全防护的重要手段
- 主动失效需要黑名单机制支持  
- 被动失效依靠过期时间自然处理
- 多设备管理要平衡安全性和用户体验
- 选择合适的技术方案要考虑系统规模和需求