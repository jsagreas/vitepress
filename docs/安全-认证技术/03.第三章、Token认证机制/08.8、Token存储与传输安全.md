---
title: 8、Token存储与传输安全
---
## 📚 目录

1. [Token存储位置选择](#1-Token存储位置选择)
2. [浏览器端存储详解](#2-浏览器端存储详解)
3. [移动端安全存储](#3-移动端安全存储)
4. [Token传输安全机制](#4-Token传输安全机制)
5. [防止Token泄露攻击](#5-防止Token泄露攻击)
6. [存储方式对比与选择](#6-存储方式对比与选择)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔒 Token存储位置选择


### 1.1 Token存储的基本概念


**什么是Token存储？**
```
简单理解：就是把用户登录后获得的"通行证"(Token)放在哪里
好比：你有一张会员卡，是放在钱包里、手机里，还是贴在衣服上？

核心问题：
• 放在哪里最安全？
• 放在哪里最方便使用？
• 放在哪里不容易丢失？
```

**为什么存储位置很重要？**
```
安全风险：
Token就像你的身份证明，如果被坏人拿到就能冒充你
存储位置不当 → Token被窃取 → 账户被盗用

使用便利性：
存储位置影响Token的读取和使用效率
位置选择不当 → 频繁重新登录 → 用户体验差
```

### 1.2 存储位置分类概览


**浏览器环境存储选择**
```
三种主要方式：

🍪 Cookie存储
优点：服务器可以直接操作，自动发送到服务器
缺点：容易被XSS攻击，有大小限制(4KB)

💾 LocalStorage存储  
优点：容量大(5-10MB)，操作简单
缺点：永久存储，容易被XSS攻击

⏰ SessionStorage存储
优点：会话结束自动清除，相对安全
缺点：容量有限，标签页关闭就消失
```

**移动端存储选择**
```
安全级别更高的存储：

🔐 iOS Keychain
系统级加密存储，即使App卸载重装数据也能保留

🔐 Android Keystore
硬件级安全存储，提供最高级别的安全保护

📱 应用沙盒存储
App专属存储空间，其他App无法访问
```

---

## 2. 🌐 浏览器端存储详解


### 2.1 LocalStorage存储方式


**LocalStorage是什么？**
```
简单理解：浏览器提供的一个"本地仓库"
特点：
• 容量大：通常5-10MB
• 永久保存：除非手动清除或浏览器清理
• 同源访问：只有相同域名的页面能访问
• 纯前端操作：JavaScript直接读写
```

**LocalStorage使用示例**
```javascript
// 存储Token
localStorage.setItem('accessToken', 'eyJhbGciOiJIUzI1NiIs...');

// 读取Token
const token = localStorage.getItem('accessToken');

// 使用Token发送请求
fetch('/api/user', {
    headers: {
        'Authorization': `Bearer ${token}`
    }
});

// 清除Token（退出登录时）
localStorage.removeItem('accessToken');
```

**LocalStorage的安全风险**
```javascript
// ❌ 危险：XSS攻击可以轻易获取Token
// 恶意脚本注入后执行：
console.log(localStorage.getItem('accessToken')); // Token被盗

// 🛡️ 相对安全的使用方式
// 1. 设置较短的Token过期时间
const tokenData = {
    token: 'eyJhbGciOiJIUzI1NiIs...',
    expiry: Date.now() + (60 * 60 * 1000) // 1小时后过期
};
localStorage.setItem('tokenData', JSON.stringify(tokenData));

// 2. 使用时检查是否过期
function getValidToken() {
    const stored = localStorage.getItem('tokenData');
    if (!stored) return null;
    
    const data = JSON.parse(stored);
    if (Date.now() > data.expiry) {
        localStorage.removeItem('tokenData');
        return null; // Token已过期
    }
    
    return data.token;
}
```

### 2.2 SessionStorage存储方式


**SessionStorage是什么？**
```
简单理解：浏览器标签页的"临时仓库"
特点：
• 会话存储：标签页关闭就消失
• 相对安全：不会长期驻留
• 容量适中：通常5MB左右
• 隔离性好：每个标签页独立存储
```

**SessionStorage使用场景**
```javascript
// 适合存储临时性Token
sessionStorage.setItem('tempToken', token);

// 页面刷新后仍然可用
const token = sessionStorage.getItem('tempToken');

// 标签页关闭后自动清除，相对安全
// 适合：
// • 单次会话使用
// • 临时认证状态
// • 敏感操作的临时授权
```

### 2.3 Cookie存储方式


**Cookie存储的特殊性**
```
Cookie不只是存储，还有传输功能：
• 自动发送：每次请求自动带上
• 服务器控制：服务器可以设置和修改
• 安全选项：HttpOnly、Secure、SameSite等
```

**安全的Cookie设置**
```javascript
// 服务器端设置安全Cookie
app.post('/login', (req, res) => {
    // 用户验证成功后
    const token = generateToken(user);
    
    res.cookie('authToken', token, {
        httpOnly: true,      // ✅ 防止XSS，JS无法读取
        secure: true,        // ✅ 只在HTTPS下传输
        sameSite: 'strict',  // ✅ 防止CSRF攻击
        maxAge: 3600000,     // ✅ 1小时过期
        path: '/'           // Cookie作用路径
    });
    
    res.json({ success: true });
});
```

**Cookie的优缺点对比**
```
✅ Cookie优点：
• 自动传输：无需前端代码处理
• 服务器控制：后端可以直接操作
• 安全选项多：HttpOnly、Secure等
• 浏览器原生支持：兼容性好

❌ Cookie缺点：
• 容量限制：单个Cookie最大4KB
• 自动发送：可能被CSRF攻击利用
• 性能影响：每次请求都会发送
• 移动端支持：某些场景下支持不好
```

---

## 3. 📱 移动端安全存储


### 3.1 iOS Keychain存储


**Keychain是什么？**
```
简单理解：iOS系统提供的"保险柜"
特点：
• 系统级加密：使用硬件级加密
• 持久存储：App卸载重装后数据仍在
• 安全隔离：其他App无法访问
• 生物识别：可结合Touch ID/Face ID
```

**iOS Keychain使用示例**
```swift
// Swift代码示例
import Security

class TokenManager {
    private let service = "com.yourapp.tokens"
    private let account = "userToken"
    
    // 存储Token到Keychain
    func saveToken(_ token: String) -> Bool {
        let data = token.data(using: .utf8)!
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account,
            kSecValueData as String: data
        ]
        
        // 删除旧的，存储新的
        SecItemDelete(query as CFDictionary)
        let status = SecItemAdd(query as CFDictionary, nil)
        
        return status == errSecSuccess
    }
    
    // 从Keychain读取Token
    func getToken() -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account,
            kSecReturnData as String: true
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        if status == errSecSuccess,
           let data = result as? Data,
           let token = String(data: data, encoding: .utf8) {
            return token
        }
        
        return nil
    }
}
```

### 3.2 Android Keystore存储


**Android Keystore是什么？**
```
简单理解：Android系统的"安全保险库"
特点：
• 硬件支持：现代设备提供硬件级安全
• 加密保护：密钥存储在安全区域
• 生物识别：支持指纹、面部识别
• 系统集成：与Android安全框架深度集成
```

**Android安全存储示例**
```java
// Java代码示例
public class SecureTokenManager {
    private static final String KEYSTORE_PROVIDER = "AndroidKeyStore";
    private static final String KEY_ALIAS = "TokenKey";
    private static final String SHARED_PREFS_NAME = "secure_tokens";
    
    // 初始化加密密钥
    private void initKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(
            KeyProperties.KEY_ALGORITHM_AES, KEYSTORE_PROVIDER);
        
        KeyGenParameterSpec keyGenSpec = new KeyGenParameterSpec.Builder(
            KEY_ALIAS,
            KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
            .setUserAuthenticationRequired(true) // 需要用户认证
            .setUserAuthenticationValidityDurationSeconds(300) // 5分钟有效
            .build();
        
        keyGen.init(keyGenSpec);
        keyGen.generateKey();
    }
    
    // 加密存储Token
    public void saveToken(String token) {
        try {
            KeyStore keyStore = KeyStore.getInstance(KEYSTORE_PROVIDER);
            keyStore.load(null);
            
            SecretKey key = (SecretKey) keyStore.getKey(KEY_ALIAS, null);
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, key);
            
            byte[] encrypted = cipher.doFinal(token.getBytes("UTF-8"));
            byte[] iv = cipher.getIV();
            
            // 存储到SharedPreferences
            SharedPreferences.Editor editor = getSharedPrefs().edit();
            editor.putString("encrypted_token", Base64.encodeToString(encrypted, Base64.DEFAULT));
            editor.putString("iv", Base64.encodeToString(iv, Base64.DEFAULT));
            editor.apply();
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 3.3 移动端存储最佳实践


**存储策略选择**
```
🔐 高安全需求：
使用Keychain/Keystore + 生物识别
适合：银行App、支付App、企业App

⚖️ 平衡安全与便利：
加密存储在App沙盒 + 定期刷新Token
适合：社交App、购物App

💡 快速开发：
使用成熟的安全存储库
iOS：KeychainSwift
Android：EncryptedSharedPreferences
```

---

## 4. 🚀 Token传输安全机制


### 4.1 HTTPS传输的重要性


**为什么必须使用HTTPS？**
```
HTTP传输的风险：
用户 ----[Token明文]----> 服务器
        ↑
    容易被拦截和窃取

HTTPS传输的保护：
用户 ----[加密Token]----> 服务器
        ↑
    即使拦截也无法解密
```

**HTTPS保护机制**
```
传输层加密过程：

1. 握手阶段：
客户端 ←→ 服务器 建立安全连接
交换证书，协商加密算法

2. 数据传输：
所有Token数据都经过SSL/TLS加密
即使网络被监听，Token内容也是安全的

3. 完整性验证：
确保Token在传输过程中没有被篡改
```

**强制HTTPS的实现**
```javascript
// 前端：确保所有API请求都使用HTTPS
const API_BASE_URL = 'https://api.example.com'; // ✅ 使用HTTPS

// 检查当前连接是否安全
if (location.protocol !== 'https:') {
    console.warn('当前连接不安全，Token传输存在风险');
    // 在生产环境中应该重定向到HTTPS
}

// 服务器端：强制HTTPS重定向
app.use((req, res, next) => {
    if (req.header('x-forwarded-proto') !== 'https') {
        res.redirect(`https://${req.header('host')}${req.url}`);
    } else {
        next();
    }
});
```

### 4.2 Token传输的标准方式


**Authorization Header传输**
```javascript
// ✅ 推荐方式：使用Authorization Header
fetch('/api/user', {
    method: 'GET',
    headers: {
        'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIs...',
        'Content-Type': 'application/json'
    }
});

// 为什么这种方式最安全？
// 1. Token不会出现在URL中
// 2. 不会被浏览器历史记录保存
// 3. 日志文件中不会记录Token
```

**避免不安全的传输方式**
```javascript
// ❌ 危险：Token放在URL参数中
// 这样的URL会被记录在各种日志中
fetch('/api/user?token=eyJhbGciOiJIUzI1NiIs...');

// ❌ 危险：Token在URL路径中
fetch('/api/user/eyJhbGciOiJIUzI1NiIs.../profile');

// ❌ 危险：GET请求的Query参数
fetch('/api/data?access_token=eyJhbGciOiJIUzI1NiIs...');
```

### 4.3 请求拦截器统一处理


**自动添加Token的机制**
```javascript
// 使用Axios拦截器自动添加Token
import axios from 'axios';

// 创建axios实例
const apiClient = axios.create({
    baseURL: 'https://api.example.com',
    timeout: 10000
});

// 请求拦截器：自动添加Token
apiClient.interceptors.request.use(
    (config) => {
        const token = getValidToken(); // 获取有效Token
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// 响应拦截器：处理Token过期
apiClient.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            // Token无效或过期，清除本地Token
            clearToken();
            // 跳转到登录页
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);
```

---

## 5. 🛡️ 防止Token泄露攻击


### 5.1 XSS攻击防护


**XSS攻击是什么？**
```
XSS (跨站脚本攻击) 简单理解：
坏人在网站中注入恶意JavaScript代码
这些代码可以读取用户的Token并发送给攻击者

攻击场景：
用户访问被注入恶意代码的页面
↓
恶意代码执行：localStorage.getItem('token')
↓
Token被发送到攻击者服务器
↓
攻击者获得用户Token，可以冒充用户
```

**XSS防护措施**
```javascript
// 1. 使用HttpOnly Cookie（推荐）
// 服务器设置Cookie时加上HttpOnly
res.cookie('authToken', token, {
    httpOnly: true,  // ✅ JavaScript无法读取
    secure: true,
    sameSite: 'strict'
});

// 2. 如果必须使用localStorage，加强防护
class SecureTokenManager {
    constructor() {
        this.tokenKey = 'app_token';
        this.initCSPProtection();
    }
    
    // 内容安全策略保护
    initCSPProtection() {
        // 设置CSP头部，限制脚本执行
        const meta = document.createElement('meta');
        meta.httpEquiv = 'Content-Security-Policy';
        meta.content = "script-src 'self' 'unsafe-inline'";
        document.head.appendChild(meta);
    }
    
    // 加密存储Token
    setToken(token) {
        const encrypted = this.encrypt(token);
        localStorage.setItem(this.tokenKey, encrypted);
    }
    
    // 简单的加密方法（实际项目中应使用更强的加密）
    encrypt(text) {
        return btoa(text.split('').reverse().join(''));
    }
    
    decrypt(encrypted) {
        return atob(encrypted).split('').reverse().join('');
    }
}
```

### 5.2 CSRF攻击防护


**CSRF攻击是什么？**
```
CSRF (跨站请求伪造) 简单理解：
用户在网站A登录后，访问恶意网站B
网站B利用用户在A的登录状态，偷偷发送请求到网站A
如果Token通过Cookie自动发送，就会被恶意利用

攻击流程：
1. 用户登录银行网站A，Token存储在Cookie中
2. 用户访问恶意网站B（未退出网站A）
3. 网站B的页面包含向网站A转账的隐藏请求
4. 浏览器自动发送Cookie中的Token
5. 银行网站A接收到"合法"的转账请求
```

**CSRF防护措施**
```javascript
// 1. 使用Authorization Header而非Cookie
// Token不会自动发送，需要显式添加
fetch('/api/transfer', {
    method: 'POST',
    headers: {
        'Authorization': `Bearer ${token}`, // ✅ 需要显式添加
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ amount: 1000 })
});

// 2. 如果使用Cookie，添加CSRF Token
// 服务器生成CSRF Token
app.get('/csrf-token', (req, res) => {
    const csrfToken = generateCSRFToken();
    req.session.csrfToken = csrfToken;
    res.json({ csrfToken });
});

// 前端在表单中包含CSRF Token
function submitForm(formData) {
    fetch('/csrf-token')
        .then(res => res.json())
        .then(({ csrfToken }) => {
            return fetch('/api/transfer', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken // ✅ 包含CSRF Token
                },
                body: JSON.stringify({
                    ...formData,
                    _csrf: csrfToken
                })
            });
        });
}
```

### 5.3 Token劫持防护


**Token劫持的常见方式**
```
网络嗅探：
HTTP传输时被截获 → 使用HTTPS防护

恶意软件：
电脑中毒，Token被读取 → 使用短期Token + 刷新机制

社交工程：
诱导用户泄露Token → 用户教育 + Token格式保护
```

**防劫持的技术措施**
```javascript
// 1. Token绑定设备特征
class DeviceBoundToken {
    generateToken(user, deviceInfo) {
        const tokenPayload = {
            userId: user.id,
            deviceId: this.generateDeviceId(deviceInfo),
            userAgent: deviceInfo.userAgent,
            ipAddress: deviceInfo.ip,
            exp: Date.now() + 3600000 // 1小时过期
        };
        
        return jwt.sign(tokenPayload, SECRET_KEY);
    }
    
    validateToken(token, deviceInfo) {
        const decoded = jwt.verify(token, SECRET_KEY);
        
        // 验证设备特征
        if (decoded.deviceId !== this.generateDeviceId(deviceInfo)) {
            throw new Error('Token设备绑定验证失败');
        }
        
        return decoded;
    }
    
    generateDeviceId(deviceInfo) {
        // 基于设备特征生成唯一ID
        const features = [
            deviceInfo.userAgent,
            deviceInfo.screenResolution,
            deviceInfo.timezone
        ];
        return crypto.createHash('sha256')
            .update(features.join('|'))
            .digest('hex');
    }
}

// 2. 异常行为检测
class TokenSecurityMonitor {
    checkSuspiciousActivity(token, requestInfo) {
        const decoded = jwt.decode(token);
        
        // 检查IP地址变化
        if (this.isIPSuspicious(decoded.ipAddress, requestInfo.ip)) {
            return { suspicious: true, reason: 'IP地址异常变化' };
        }
        
        // 检查访问频率
        if (this.isRequestFrequencyAbnormal(decoded.userId)) {
            return { suspicious: true, reason: '请求频率异常' };
        }
        
        return { suspicious: false };
    }
}
```

---

## 6. ⚖️ 存储方式对比与选择


### 6.1 浏览器端存储对比


| 存储方式 | **安全性** | **容量** | **持久性** | **使用便利性** | **适用场景** |
|---------|-----------|----------|-----------|---------------|-------------|
| 🍪 **Cookie** | `中等` | `4KB` | `可设置过期` | `自动传输` | `传统Web应用、需要服务器控制` |
| 💾 **LocalStorage** | `较低` | `5-10MB` | `永久存储` | `操作简单` | `长期登录、离线应用` |
| ⏰ **SessionStorage** | `中等` | `5MB` | `会话级别` | `操作简单` | `单次会话、临时状态` |
| 🔐 **Memory存储** | `最高` | `受限于内存` | `页面刷新丢失` | `需要重新登录` | `高安全要求、临时操作` |

### 6.2 移动端存储对比


```
🔒 安全级别对比：

Keychain/Keystore (最安全)
• 硬件级加密保护
• 系统级访问控制
• 适合：金融App、企业App

加密文件存储 (较安全)  
• 应用级加密
• 沙盒环境保护
• 适合：一般商业App

普通文件存储 (基础安全)
• 沙盒保护
• 无加密
• 适合：低敏感度App
```

### 6.3 选择决策指南


**根据应用类型选择**
```javascript
// 电商/社交类App
class ECommerceTokenStrategy {
    getStorageStrategy() {
        return {
            web: 'localStorage', // 便于长期使用
            mobile: 'encrypted_storage', // 平衡安全与便利
            tokenExpiry: '7天'
        };
    }
}

// 金融/支付类App
class FinancialTokenStrategy {
    getStorageStrategy() {
        return {
            web: 'httpOnly_cookie', // 最安全的Web方案
            mobile: 'keychain', // 最高级别加密
            tokenExpiry: '30分钟', // 短期Token
            requireReauth: true // 重要操作需要重新认证
        };
    }
}

// 企业/办公类App
class EnterpriseTokenStrategy {
    getStorageStrategy() {
        return {
            web: 'sessionStorage', // 会话级安全
            mobile: 'keystore', // 企业级安全
            tokenExpiry: '8小时', // 工作时间内有效
            deviceBinding: true // 绑定设备
        };
    }
}
```

**存储策略实现**
```javascript
class AdaptiveTokenManager {
    constructor(appType) {
        this.strategy = this.getStrategy(appType);
        this.initStorage();
    }
    
    getStrategy(appType) {
        const strategies = {
            'ecommerce': new ECommerceTokenStrategy(),
            'financial': new FinancialTokenStrategy(),
            'enterprise': new EnterpriseTokenStrategy()
        };
        
        return strategies[appType] || strategies['ecommerce'];
    }
    
    saveToken(token) {
        const config = this.strategy.getStorageStrategy();
        
        switch (config.web) {
            case 'localStorage':
                this.saveToLocalStorage(token, config.tokenExpiry);
                break;
            case 'sessionStorage':
                this.saveToSessionStorage(token);
                break;
            case 'httpOnly_cookie':
                this.saveToHttpOnlyCookie(token, config.tokenExpiry);
                break;
        }
    }
    
    saveToLocalStorage(token, expiry) {
        const data = {
            token,
            expiry: Date.now() + this.parseExpiry(expiry)
        };
        localStorage.setItem('auth_data', JSON.stringify(data));
    }
    
    parseExpiry(expiry) {
        const units = {
            '分钟': 60 * 1000,
            '小时': 60 * 60 * 1000,
            '天': 24 * 60 * 60 * 1000
        };
        
        for (const [unit, ms] of Object.entries(units)) {
            if (expiry.includes(unit)) {
                const num = parseInt(expiry);
                return num * ms;
            }
        }
        
        return 60 * 60 * 1000; // 默认1小时
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔐 Token存储本质：
• 就像保管重要证件，位置选择决定安全性
• 浏览器端：LocalStorage、SessionStorage、Cookie各有优劣
• 移动端：Keychain/Keystore提供最高级别保护

🚀 传输安全要求：
• HTTPS是基础：所有Token传输必须加密
• Authorization Header：最安全的传输方式
• 避免URL参数：防止Token被日志记录

🛡️ 安全威胁防护：
• XSS攻击：恶意脚本窃取Token
• CSRF攻击：跨站请求伪造
• Token劫持：网络嗅探和恶意软件
```

### 7.2 关键理解要点


**🔹 存储位置选择原则**
```
安全性优先级：
Memory存储 > HttpOnly Cookie > SessionStorage > LocalStorage

便利性优先级：  
LocalStorage > SessionStorage > HttpOnly Cookie > Memory存储

平衡选择：
根据应用类型和安全要求，选择最适合的存储方式
```

**🔹 传输安全的重要性**
```
为什么传输比存储更重要？
• 传输过程中Token完全暴露
• 网络监听可以轻易截获
• HTTPS加密是最基本的保护

传输安全检查清单：
✅ 使用HTTPS协议
✅ Token放在Header中
✅ 避免URL参数传递
✅ 设置适当的请求头
```

**🔹 移动端存储的优势**
```
为什么移动端更安全？
• 系统级加密：Keychain/Keystore硬件保护
• 应用沙盒：其他App无法访问
• 生物识别：Touch ID/Face ID额外保护
• 设备绑定：Token与设备特征关联
```

### 7.3 实际应用指导


**应用场景决策树**
```
🎯 高安全需求（金融、支付）：
Web端：HttpOnly Cookie + CSRF防护
移动端：Keychain/Keystore + 生物识别
Token有效期：15-30分钟

⚖️ 一般安全需求（电商、社交）：
Web端：LocalStorage + XSS防护
移动端：加密存储
Token有效期：1-7天

💼 企业级应用：
Web端：SessionStorage + 设备绑定
移动端：Keystore + MDM管理
Token有效期：工作时间内（8小时）
```

**安全最佳实践**
```javascript
// 综合安全策略示例
class ComprehensiveTokenSecurity {
    constructor(options = {}) {
        this.appType = options.appType || 'general';
        this.securityLevel = options.securityLevel || 'medium';
        this.initSecurityMeasures();
    }
    
    // 初始化安全措施
    initSecurityMeasures() {
        this.enableHTTPS();
        this.setupCSP();
        this.initTokenEncryption();
        this.setupSecurityMonitoring();
    }
    
    // 强制HTTPS
    enableHTTPS() {
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            location.replace(`https:${location.href.substring(location.protocol.length)}`);
        }
    }
    
    // 设置内容安全策略
    setupCSP() {
        const meta = document.createElement('meta');
        meta.httpEquiv = 'Content-Security-Policy';
        meta.content = "default-src 'self'; script-src 'self' 'unsafe-inline'";
        document.head.appendChild(meta);
    }
    
    // 智能存储选择
    saveToken(token) {
        const strategy = this.getStorageStrategy();
        
        switch (strategy.method) {
            case 'encrypted_localStorage':
                this.saveEncryptedToken(token);
                break;
            case 'httpOnly_cookie':
                this.requestServerSetCookie(token);
                break;
            case 'sessionStorage':
                sessionStorage.setItem('auth_token', token);
                break;
        }
        
        // 设置自动刷新
        if (strategy.autoRefresh) {
            this.setupTokenRefresh(strategy.refreshInterval);
        }
    }
}
```

**核心记忆要点**
```
Token存储三要素：
1. 位置安全：选择合适的存储位置
2. 传输安全：必须使用HTTPS + Header传输
3. 防护全面：XSS、CSRF、劫持一个都不能少

移动端优于Web端：
系统级保护 > 应用级保护 > 浏览器级保护

安全与便利的平衡：
根据应用类型选择最适合的安全策略
高安全需求宁可牺牲便利性
一般应用可以适当平衡
```