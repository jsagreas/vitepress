---
title: 11、Token在API接口中的使用
---
## 📚 目录

1. [Token在API中的作用](#1-Token在API中的作用)
2. [RESTful API中的Token认证](#2-RESTful-API中的Token认证)
3. [HTTP Header中Authorization的Bearer用法](#3-HTTP-Header中Authorization的Bearer用法)
4. [单页应用（SPA）前后端分离场景](#4-单页应用SPA前后端分离场景)
5. [移动端App与后端接口调用](#5-移动端App与后端接口调用)
6. [跨域请求中的Token传递](#6-跨域请求中的Token传递)
7. [API网关统一鉴权思路](#7-API网关统一鉴权思路)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 Token在API中的作用


### 1.1 什么是Token认证

**简单理解**：Token就像是一张**通行证**，你拿着这张通行证就能证明"我是谁"，从而访问需要权限的资源。

```
生活中的类比：
去银行办事 → 需要身份证（Token）
进入小区 → 需要门禁卡（Token）
网上购物 → 需要登录凭证（Token）

API接口中：
访问用户信息 → 需要Token
修改数据 → 需要Token
调用敏感接口 → 需要Token
```

### 1.2 为什么API需要Token认证

**核心问题**：如何确保只有合法用户才能调用接口？

```
没有认证的问题：
❌ 任何人都能调用接口
❌ 数据泄露风险
❌ 恶意攻击无法防范
❌ 无法追踪操作者

有Token认证的好处：
✅ 确认用户身份
✅ 控制访问权限
✅ 记录操作日志
✅ 防止恶意调用
```

### 1.3 Token认证的基本流程

```
用户端                          服务端
  |                              |
  |--[1]登录请求(用户名密码)-------->|
  |                              |--验证用户信息
  |<-[2]返回Token-----------------|--生成Token
  |                              |
  |--[3]携带Token调用API---------->|
  |                              |--验证Token
  |<-[4]返回接口数据--------------|--返回结果
```

---

## 2. 🌐 RESTful API中的Token认证


### 2.1 RESTful API的特点

**什么是RESTful API**：一种设计风格的API，简单说就是**用不同的HTTP方法对资源进行操作**。

```
RESTful API的核心理念：
- 每个URL代表一种资源
- 用HTTP方法表示操作类型
- 无状态：每次请求都是独立的

常见操作：
GET /users/123     → 获取用户信息（查）
POST /users        → 创建用户（增）
PUT /users/123     → 更新用户（改）  
DELETE /users/123  → 删除用户（删）
```

### 2.2 RESTful API中Token的必要性

**为什么RESTful API特别需要Token**：

```
无状态特性：
- 服务器不保存用户会话信息
- 每次请求都需要重新验证身份
- Token成为唯一的身份凭证

安全要求：
- 防止未授权访问
- 确保数据操作的合法性
- 追踪API调用者
```

### 2.3 RESTful API Token认证实现

```javascript
// 前端调用示例
const token = localStorage.getItem('accessToken');

// 获取用户列表
fetch('/api/users', {
    method: 'GET',
    headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
    }
})
.then(response => response.json())
.then(data => console.log(data));

// 创建新用户
fetch('/api/users', {
    method: 'POST',
    headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        name: '张三',
        email: 'zhangsan@example.com'
    })
});
```

---

## 3. 📨 HTTP Header中Authorization的Bearer用法


### 3.1 Authorization Header详解

**什么是Authorization Header**：HTTP请求头中专门用来**传递认证信息**的字段。

```
HTTP请求结构：
GET /api/users HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...  ← 这就是Authorization
Content-Type: application/json
```

### 3.2 Bearer认证方式

**Bearer是什么意思**：英文"bearer"意思是"持有者"，简单理解就是**"谁持有这个Token，谁就有相应权限"**。

```
Authorization格式：
Authorization: Bearer <token>

举例说明：
Authorization: Bearer abc123def456

分解理解：
- Authorization：告诉服务器这是认证信息
- Bearer：认证方式，表示Token认证
- abc123def456：具体的Token值
```

### 3.3 为什么使用Bearer

```
Bearer方式的优势：
✅ 标准化：HTTP标准推荐的方式
✅ 简单：格式固定，易于解析
✅ 安全：不在URL中暴露Token
✅ 通用：各种客户端都支持

对比其他方式：
❌ URL参数：/api/users?token=abc123 （Token暴露在地址中）
❌ 自定义Header：X-Token: abc123 （非标准化）
✅ Bearer：Authorization: Bearer abc123 （标准推荐）
```

### 3.4 服务端如何解析Bearer Token

```javascript
// Node.js Express示例
app.get('/api/users', (req, res) => {
    // 1. 获取Authorization头
    const authHeader = req.headers.authorization;
    
    // 2. 检查是否存在且以Bearer开头
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: '缺少Token' });
    }
    
    // 3. 提取Token值（去掉"Bearer "前缀）
    const token = authHeader.substring(7); // "Bearer ".length = 7
    
    // 4. 验证Token
    try {
        const user = verifyToken(token);
        res.json({ users: getUserList() });
    } catch (error) {
        res.status(401).json({ error: 'Token无效' });
    }
});
```

---

## 4. 💻 单页应用（SPA）前后端分离场景


### 4.1 什么是SPA和前后端分离

**单页应用（SPA）**：整个网站就是**一个页面**，通过JavaScript动态更新内容，不需要跳转页面。

```
传统网站 vs SPA：

传统网站：
用户点击 → 跳转新页面 → 服务器返回完整HTML
首页.html → 用户页.html → 产品页.html

SPA：
用户点击 → JavaScript更新内容 → 页面不刷新
index.html + JavaScript动态更新
```

**前后端分离**：**前端只管界面显示，后端只管数据处理**，两者通过API接口通信。

```
前后端分离架构：

前端（浏览器）              后端（服务器）
     |                        |
   Vue.js                   Spring Boot
   React                    Node.js  
   Angular                  Python
     |                        |
     |----API调用（JSON）----->|
     |<---返回数据（JSON）-----|
```

### 4.2 SPA中Token认证的特点

```
SPA Token认证流程：

1. 用户登录
   ┌─────────────┐    POST /login     ┌─────────────┐
   │   前端SPA   │─────────────────→ │   后端API   │
   │             │←─────────────────  │             │
   └─────────────┘   返回Token       └─────────────┘

2. 存储Token
   前端将Token保存在：
   - localStorage（持久存储）
   - sessionStorage（会话存储）
   - 内存中（最安全但刷新丢失）

3. 后续API调用
   每次调用API都携带Token
```

### 4.3 SPA Token存储方案对比

```
存储方式对比：

localStorage：
✅ 刷新页面不丢失
✅ 关闭浏览器不丢失  
❌ 容易被XSS攻击获取
❌ 同域名下所有页面都能访问

sessionStorage：
✅ 刷新页面不丢失
✅ 相对localStorage更安全
❌ 关闭浏览器就丢失
❌ 仍然可能被XSS攻击

内存存储：
✅ 最安全，XSS无法获取
❌ 刷新页面就丢失
❌ 用户体验不好
```

### 4.4 SPA Token认证代码示例

```javascript
// 登录获取Token
async function login(username, password) {
    const response = await fetch('/api/login', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ username, password })
    });
    
    const data = await response.json();
    
    if (data.success) {
        // 存储Token
        localStorage.setItem('token', data.token);
        console.log('登录成功');
    }
}

// 创建带Token的请求函数
function apiRequest(url, options = {}) {
    const token = localStorage.getItem('token');
    
    return fetch(url, {
        ...options,
        headers: {
            ...options.headers,
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });
}

// 使用示例
apiRequest('/api/user/profile')
    .then(res => res.json())
    .then(user => console.log(user));
```

---

## 5. 📱 移动端App与后端接口调用


### 5.1 移动端Token认证的特点

**移动端和Web端的区别**：

```
Web端特点：
- 运行在浏览器中
- 有同源策略限制
- 容易被XSS攻击
- Token存储选择少

移动端特点：
- 运行在原生环境
- 没有同源策略
- XSS攻击风险小
- Token存储更安全
```

### 5.2 移动端Token存储方案

```
移动端安全存储：

iOS：
✅ Keychain Services（最安全）
✅ UserDefaults（简单但安全性低）
❌ 文件存储（不推荐）

Android：
✅ SharedPreferences + 加密
✅ Android Keystore（最安全）  
✅ Room数据库 + 加密
❌ 普通文件（不推荐）
```

### 5.3 移动端API调用示例

```javascript
// React Native示例
import AsyncStorage from '@react-native-async-storage/async-storage';

class ApiClient {
    // 保存Token
    static async saveToken(token) {
        try {
            await AsyncStorage.setItem('userToken', token);
        } catch (error) {
            console.log('Token保存失败:', error);
        }
    }
    
    // 获取Token
    static async getToken() {
        try {
            return await AsyncStorage.getItem('userToken');
        } catch (error) {
            console.log('Token获取失败:', error);
            return null;
        }
    }
    
    // API请求
    static async request(url, options = {}) {
        const token = await this.getToken();
        
        return fetch(url, {
            ...options,
            headers: {
                ...options.headers,
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        });
    }
}

// 使用示例
ApiClient.request('/api/user/orders')
    .then(res => res.json())
    .then(orders => console.log(orders));
```

### 5.4 移动端Token刷新策略

```
Token自动刷新机制：

问题：Token会过期，过期后需要重新登录
解决：自动刷新Token，用户无感知

实现思路：
1. 检测Token即将过期
2. 自动调用刷新接口
3. 更新存储的Token
4. 重试原始请求
```

```javascript
// Token自动刷新示例
class TokenManager {
    static async refreshToken() {
        const refreshToken = await AsyncStorage.getItem('refreshToken');
        
        const response = await fetch('/api/token/refresh', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ refreshToken })
        });
        
        const data = await response.json();
        
        if (data.success) {
            await AsyncStorage.setItem('userToken', data.newToken);
            return data.newToken;
        }
        
        throw new Error('Token刷新失败');
    }
    
    static async requestWithAutoRefresh(url, options) {
        let response = await ApiClient.request(url, options);
        
        // 如果Token过期，自动刷新后重试
        if (response.status === 401) {
            await this.refreshToken();
            response = await ApiClient.request(url, options);
        }
        
        return response;
    }
}
```

---

## 6. 🌍 跨域请求中的Token传递


### 6.1 什么是跨域问题

**跨域**：简单说就是**一个网站去访问另一个网站的资源**，浏览器出于安全考虑会阻止这种访问。

```
跨域示例：
网站A：https://www.example.com
想要访问：
网站B：https://api.example.com  ← 不同子域名，跨域！
网站C：http://www.example.com   ← 不同协议，跨域！
网站D：https://www.example.com:8080  ← 不同端口，跨域！
```

**同源策略**：浏览器的安全机制，只允许访问**相同协议、域名、端口**的资源。

### 6.2 跨域请求中Token传递的问题

```
跨域Token传递的挑战：

问题1：OPTIONS预检请求
跨域请求会先发送OPTIONS请求检查权限
如果服务器不支持，Token请求会失败

问题2：Cookie无法携带
跨域时Cookie默认不会发送
只能通过Authorization Header传递Token

问题3：响应头被限制
服务器返回的某些头部信息可能被浏览器隐藏
```

### 6.3 CORS配置解决跨域Token传递

```javascript
// 后端CORS配置示例（Node.js Express）
app.use(cors({
    origin: ['https://www.example.com', 'https://app.example.com'],
    credentials: true, // 允许携带认证信息
    allowedHeaders: [
        'Content-Type',
        'Authorization', // 明确允许Authorization头
        'X-Requested-With'
    ],
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
}));

// 手动设置CORS头
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', 'https://www.example.com');
    res.header('Access-Control-Allow-Credentials', true);
    res.header('Access-Control-Allow-Headers', 'Authorization, Content-Type');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    
    // 处理预检请求
    if (req.method === 'OPTIONS') {
        res.sendStatus(200);
    } else {
        next();
    }
});
```

### 6.4 前端跨域Token请求

```javascript
// 前端跨域请求配置
const token = localStorage.getItem('token');

fetch('https://api.example.com/users', {
    method: 'GET',
    credentials: 'include', // 包含认证信息
    headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
    }
})
.then(response => {
    if (!response.ok) {
        throw new Error(`HTTP错误: ${response.status}`);
    }
    return response.json();
})
.then(data => console.log(data))
.catch(error => console.error('请求失败:', error));
```

### 6.5 跨域Token传递最佳实践

```
跨域Token安全建议：

✅ 使用HTTPS防止Token泄露
✅ 设置合适的Token过期时间
✅ 验证请求来源域名
✅ 使用CSP头部增强安全性
❌ 不要在URL中传递Token
❌ 不要设置过于宽泛的CORS策略
```

---

## 7. 🏗️ API网关统一鉴权思路


### 7.1 什么是API网关

**API网关**：想象成一个**大门口的保安**，所有想要进入系统的请求都必须经过这个保安的检查。

```
没有API网关的问题：
客户端 → 用户服务（需要验证Token）
客户端 → 订单服务（需要验证Token）  
客户端 → 支付服务（需要验证Token）
每个服务都要写一遍Token验证逻辑！

有API网关的好处：
客户端 → API网关（统一验证Token）→ 各个服务
只需要在网关一个地方验证Token！
```

### 7.2 API网关鉴权的优势

```
统一鉴权的好处：

✅ 代码复用：鉴权逻辑只写一次
✅ 安全统一：所有接口统一安全标准
✅ 性能优化：统一处理，减少重复验证
✅ 监控集中：统一记录访问日志
✅ 配置灵活：可以统一配置权限规则
```

### 7.3 API网关鉴权流程

```
API网关鉴权处理流程：

客户端请求
    ↓
┌─────────────────────┐
│    1. 提取Token     │ ← 从Authorization Header获取
├─────────────────────┤
│    2. 验证Token     │ ← 检查格式、签名、过期时间
├─────────────────────┤  
│    3. 获取用户信息   │ ← 解析Token获取用户ID、权限等
├─────────────────────┤
│    4. 权限检查      │ ← 检查是否有权限访问目标接口
├─────────────────────┤
│    5. 转发请求      │ ← 验证通过，转发给后端服务
└─────────────────────┘
    ↓
后端服务处理
```

### 7.4 API网关实现示例

```javascript
// API网关鉴权中间件示例（Node.js）
class ApiGateway {
    // Token验证中间件
    static async authMiddleware(req, res, next) {
        try {
            // 1. 提取Token
            const token = extractToken(req);
            if (!token) {
                return res.status(401).json({ error: '缺少Token' });
            }
            
            // 2. 验证Token
            const user = await verifyToken(token);
            if (!user) {
                return res.status(401).json({ error: 'Token无效' });
            }
            
            // 3. 权限检查
            const hasPermission = await checkPermission(user, req.path, req.method);
            if (!hasPermission) {
                return res.status(403).json({ error: '权限不足' });
            }
            
            // 4. 将用户信息传递给后端服务
            req.headers['x-user-id'] = user.id;
            req.headers['x-user-role'] = user.role;
            
            next();
        } catch (error) {
            res.status(500).json({ error: '鉴权失败' });
        }
    }
    
    // 路由转发
    static setupRoutes(app) {
        // 用户服务
        app.use('/api/users/*', this.authMiddleware, proxy('http://user-service:3001'));
        
        // 订单服务  
        app.use('/api/orders/*', this.authMiddleware, proxy('http://order-service:3002'));
        
        // 支付服务
        app.use('/api/payments/*', this.authMiddleware, proxy('http://payment-service:3003'));
    }
}

function extractToken(req) {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
        return authHeader.substring(7);
    }
    return null;
}
```

### 7.5 权限控制策略

```javascript
// 权限检查逻辑
async function checkPermission(user, path, method) {
    // 基于角色的权限控制（RBAC）
    const permissions = {
        admin: ['*'], // 管理员所有权限
        user: [
            'GET /api/users/profile',      // 查看自己信息
            'PUT /api/users/profile',      // 修改自己信息
            'GET /api/orders',             // 查看自己订单
            'POST /api/orders'             // 创建订单
        ],
        guest: [
            'GET /api/products'            // 只能查看商品
        ]
    };
    
    const userPermissions = permissions[user.role] || [];
    
    // 检查是否有通配符权限
    if (userPermissions.includes('*')) {
        return true;
    }
    
    // 检查具体权限
    const requiredPermission = `${method} ${path}`;
    return userPermissions.includes(requiredPermission);
}
```

### 7.6 API网关的扩展功能

```
API网关的其他功能：

🔄 负载均衡：
将请求分发到多个后端服务实例

📊 监控统计：
统计API调用次数、响应时间等

🛡️ 安全防护：
防止SQL注入、XSS攻击等

🚦 限流控制：
防止API被恶意大量调用

📝 日志记录：
记录所有API访问日志

🔧 协议转换：  
HTTP到gRPC的协议转换
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念

```
🔸 Token认证本质：用Token作为身份凭证访问API
🔸 Bearer认证方式：HTTP标准的Token传递方式
🔸 RESTful API特点：无状态，每次请求都需要Token
🔸 SPA前后端分离：前端存储Token，调用API获取数据
🔸 移动端特色：更安全的Token存储方案
🔸 跨域问题：CORS配置允许跨域Token传递
🔸 API网关：统一的鉴权入口，提高安全性和效率
```

### 8.2 关键理解要点


**🔹 Token在API中的核心作用**
```
身份认证：证明"我是谁"
权限控制：决定"我能做什么"  
安全保护：防止"别人冒充我"
追踪审计：记录"我做了什么"
```

**🔹 不同场景下的Token使用**
```
Web SPA：存储在浏览器，每次API调用携带
移动App：存储在安全存储中，自动刷新Token
跨域调用：需要正确配置CORS允许Token传递
微服务：通过API网关统一验证，避免重复验证
```

**🔹 Token传递的最佳实践**
```
✅ 使用Authorization: Bearer格式
✅ 通过HTTPS传输保证安全
✅ 设置合理的Token过期时间
✅ 实现Token自动刷新机制
❌ 不要在URL参数中传递Token
❌ 不要在客户端明文存储敏感Token
```

### 8.3 实际应用场景

- **电商网站**：用户登录后获取Token，调用订单、支付等API
- **管理系统**：管理员Token访问用户管理、数据统计等接口
- **移动应用**：App启动时检查Token，自动登录用户
- **第三方集成**：其他系统调用我方API时的身份验证
- **微服务架构**：服务间调用的统一认证机制

### 8.4 安全注意事项

```
Token安全要点：
🔒 传输安全：必须使用HTTPS
🕐 时效控制：设置合理过期时间
🔄 刷新机制：实现无感知的Token更新
💾 存储安全：根据平台选择安全存储方案
🛡️ 权限控制：基于Token实现细粒度权限管理
```

**核心记忆**：
- Token是API世界的"身份证"，有了它才能证明身份
- Bearer是标准的Token传递方式，格式固定易用
- 不同场景（SPA、移动端、跨域）有不同的Token使用策略
- API网关是Token验证的"统一大门"，提高效率和安全性