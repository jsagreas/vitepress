---
title: 7、安全防护与最佳实践
---
## 📚 目录

1. [CSRF防护核心机制](#1-CSRF防护核心机制)
2. [Token安全管理](#2-Token安全管理)
3. [传输安全保障](#3-传输安全保障)
4. [访问控制策略](#4-访问控制策略)
5. [数据安全处理](#5-数据安全处理)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🛡️ CSRF防护核心机制


### 1.1 什么是CSRF攻击


**🔍 CSRF攻击简单理解**
```
想象一个场景：
你已经登录了银行网站，浏览器保存了登录状态
这时你点击了一个恶意链接，这个链接偷偷向银行发送转账请求
由于你处于登录状态，银行认为这是你本人操作，执行了转账

这就是CSRF攻击 - 跨站请求伪造
```

**🎯 第三方登录中的CSRF风险**
```
正常流程：
用户 → 点击"微信登录" → 跳转微信 → 授权后回调你的网站

CSRF攻击：
黑客 → 伪造登录链接 → 诱导用户点击 → 用户在不知情下登录了黑客账号
```

### 1.2 State参数随机生成与验证


**💡 State参数的作用**
```
State参数就像一个"暗号"：
1. 你发起登录请求时，生成一个随机暗号
2. 把这个暗号告诉第三方平台（如微信）
3. 用户授权后，第三方平台把暗号原样返回
4. 你验证暗号是否正确，确认这是你发起的请求
```

**🔧 State参数实现**
```javascript
// 1️⃣ 生成随机State
function generateState() {
    // 生成32位随机字符串
    return Math.random().toString(36).substr(2, 15) + 
           Math.random().toString(36).substr(2, 15);
}

// 2️⃣ 发起登录时保存State
const state = generateState();
// 保存到session或Redis中
req.session.oauthState = state;

// 构造登录URL
const loginUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?` +
    `appid=${APP_ID}&` +
    `redirect_uri=${CALLBACK_URL}&` +
    `response_type=code&` +
    `scope=snsapi_userinfo&` +
    `state=${state}`;

// 3️⃣ 回调时验证State
app.get('/callback', (req, res) => {
    const { state, code } = req.query;
    const savedState = req.session.oauthState;
    
    // 验证state参数
    if (state !== savedState) {
        return res.status(400).send('CSRF攻击检测到');
    }
    
    // state验证通过，继续处理...
});
```

### 1.3 一次性使用原则


**🔑 为什么要一次性使用**
```
State参数用完就丢弃，就像：
- 电影票用完就作废
- 一次性密码用完就失效
- 防止被重复利用进行攻击
```

**⚡ 实现一次性使用**
```javascript
app.get('/callback', (req, res) => {
    const { state } = req.query;
    const savedState = req.session.oauthState;
    
    if (state !== savedState) {
        return res.status(400).send('无效的state参数');
    }
    
    // ✅ 验证通过后立即删除
    delete req.session.oauthState;
    
    // 继续处理登录逻辑...
});
```

### 1.4 服务端状态校验


**📊 完整的状态校验流程**
```
客户端请求登录
       ↓
服务端生成State并保存
       ↓
跳转到第三方平台
       ↓
用户授权完成
       ↓
第三方平台回调（带State）
       ↓
服务端验证State
       ↓
State正确 → 继续登录
State错误 → 拒绝请求
```

**🔒 多重验证机制**
```javascript
// 完整的状态校验
function validateOAuthCallback(req) {
    const { state, code } = req.query;
    
    // 1️⃣ 检查参数是否存在
    if (!state || !code) {
        throw new Error('缺少必要参数');
    }
    
    // 2️⃣ 检查state是否存在于session中
    const savedState = req.session.oauthState;
    if (!savedState) {
        throw new Error('未找到对应的登录会话');
    }
    
    // 3️⃣ 验证state是否匹配
    if (state !== savedState) {
        throw new Error('State参数验证失败');
    }
    
    // 4️⃣ 检查state是否过期（可选）
    const stateTimestamp = req.session.oauthTimestamp;
    if (Date.now() - stateTimestamp > 10 * 60 * 1000) { // 10分钟过期
        throw new Error('登录会话已过期');
    }
    
    return true;
}
```

---

## 2. 🔐 Token安全管理


### 2.1 Token是什么


**💡 Token简单理解**
```
Token就像一张"临时通行证"：
- 你登录成功后，系统给你一张通行证
- 以后访问需要权限的功能时，出示这张通行证
- 通行证有有效期，过期需要重新申请
- 比传统的账号密码更安全，因为可以随时作废
```

### 2.2 Token加密存储策略


**🔒 为什么要加密存储**
```
不加密的风险：
- Token被偷窥（XSS攻击）
- Token被截获（网络监听）
- Token被复制（浏览器插件恶意读取）

加密后的好处：
- 即使被偷看也看不懂
- 增加破解难度
- 多一层安全保障
```

**🛠️ 加密存储实现**
```javascript
const crypto = require('crypto');

// 1️⃣ 加密Token
function encryptToken(token) {
    const algorithm = 'aes-256-gcm';
    const secretKey = process.env.TOKEN_SECRET_KEY; // 32字节密钥
    const iv = crypto.randomBytes(16); // 随机初始向量
    
    const cipher = crypto.createCipher(algorithm, secretKey);
    let encrypted = cipher.update(token, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return iv.toString('hex') + ':' + encrypted;
}

// 2️⃣ 解密Token
function decryptToken(encryptedToken) {
    const algorithm = 'aes-256-gcm';
    const secretKey = process.env.TOKEN_SECRET_KEY;
    
    const [ivHex, encrypted] = encryptedToken.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    
    const decipher = crypto.createDecipher(algorithm, secretKey);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
}

// 3️⃣ 存储到数据库
async function saveUserToken(userId, accessToken) {
    const encryptedToken = encryptToken(accessToken);
    
    await db.query(`
        UPDATE users 
        SET encrypted_token = ?, 
            token_updated_at = NOW()
        WHERE id = ?
    `, [encryptedToken, userId]);
}
```

### 2.3 合理过期时间设置


**⏰ 过期时间的平衡艺术**
```
时间太短：
😤 用户频繁需要重新登录
😤 用户体验差

时间太长：
😰 被盗用风险高
😰 安全性降低

最佳实践：
🎯 Access Token: 2小时
🎯 Refresh Token: 30天
🎯 根据应用敏感度调整
```

**📅 分层过期策略**
```javascript
const TOKEN_CONFIG = {
    // 不同类型Token的过期时间
    ACCESS_TOKEN_EXPIRE: 2 * 60 * 60,        // 2小时
    REFRESH_TOKEN_EXPIRE: 30 * 24 * 60 * 60, // 30天
    ADMIN_TOKEN_EXPIRE: 30 * 60,             // 管理员30分钟
    API_TOKEN_EXPIRE: 24 * 60 * 60           // API调用24小时
};

// 根据用户角色设置不同过期时间
function getTokenExpireTime(userRole) {
    switch(userRole) {
        case 'admin':
            return TOKEN_CONFIG.ADMIN_TOKEN_EXPIRE;
        case 'api':
            return TOKEN_CONFIG.API_TOKEN_EXPIRE;
        default:
            return TOKEN_CONFIG.ACCESS_TOKEN_EXPIRE;
    }
}
```

### 2.4 服务端主动失效机制


**🚫 什么时候需要主动失效Token**
```
常见场景：
👤 用户主动退出登录
🔒 用户修改密码
⚠️ 检测到异常登录
🛡️ 账号被锁定
📱 设备丢失报告
```

**⚡ 实现Token黑名单**
```javascript
// 1️⃣ Token黑名单存储（Redis）
class TokenBlacklist {
    // 添加到黑名单
    static async addToBlacklist(token, expireTime) {
        const key = `blacklist:${token}`;
        // 设置过期时间为原Token的剩余时间
        await redis.setex(key, expireTime, 'revoked');
    }
    
    // 检查是否在黑名单中
    static async isBlacklisted(token) {
        const key = `blacklist:${token}`;
        const result = await redis.get(key);
        return result === 'revoked';
    }
}

// 2️⃣ 用户退出时失效Token
app.post('/logout', authenticateToken, async (req, res) => {
    const token = req.headers.authorization.split(' ')[1];
    
    // 解析Token获取过期时间
    const decoded = jwt.decode(token);
    const remainingTime = decoded.exp - Math.floor(Date.now() / 1000);
    
    // 添加到黑名单
    await TokenBlacklist.addToBlacklist(token, remainingTime);
    
    res.json({ message: '退出成功' });
});

// 3️⃣ 验证Token时检查黑名单
async function authenticateToken(req, res, next) {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({ error: '缺少Token' });
    }
    
    // 检查是否在黑名单中
    if (await TokenBlacklist.isBlacklisted(token)) {
        return res.status(401).json({ error: 'Token已失效' });
    }
    
    // 验证Token有效性
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(401).json({ error: 'Token无效' });
    }
}
```

---

## 3. 🌐 传输安全保障


### 3.1 全程HTTPS强制使用


**🔒 为什么必须使用HTTPS**
```
HTTP传输（不安全）：
明文传输 → 数据可被窃听
无法验证 → 可能连接到假网站
容易篡改 → 数据可能被修改

HTTPS传输（安全）：
加密传输 → 数据无法被窃听
身份验证 → 确保连接到真实网站  
完整性校验 → 数据无法被篡改
```

**⚡ 强制HTTPS实现**
```javascript
// 1️⃣ 中间件强制HTTPS
function forceHTTPS(req, res, next) {
    // 检查是否为HTTPS连接
    if (!req.secure && req.get('x-forwarded-proto') !== 'https') {
        // 重定向到HTTPS版本
        const httpsUrl = `https://${req.get('host')}${req.url}`;
        return res.redirect(301, httpsUrl);
    }
    next();
}

// 2️⃣ 应用到所有路由
app.use(forceHTTPS);

// 3️⃣ 设置安全头
app.use((req, res, next) => {
    // 强制HTTPS传输
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
    // 防止在非HTTPS页面加载资源
    res.setHeader('Content-Security-Policy', 'upgrade-insecure-requests');
    next();
});

// 4️⃣ OAuth回调URL必须HTTPS
const OAUTH_CONFIG = {
    wechat: {
        appId: process.env.WECHAT_APP_ID,
        appSecret: process.env.WECHAT_APP_SECRET,
        // 确保回调地址为HTTPS
        redirectUri: 'https://yoursite.com/auth/wechat/callback'
    }
};
```

### 3.2 敏感参数POST传输


**📨 GET vs POST的安全区别**
```
GET请求问题：
🔍 URL中的参数会被记录在服务器日志
🔍 浏览器历史记录会保存完整URL
🔍 URL可能被分享时泄露敏感信息

POST请求优势：
✅ 参数在请求体中，不会出现在URL
✅ 服务器日志通常不记录请求体
✅ 浏览器历史不会保存请求体内容
```

**🔧 敏感参数POST传输实现**
```javascript
// ❌ 错误：敏感参数通过GET传输
app.get('/auth/token', (req, res) => {
    // 这样很危险！access_token暴露在URL中
    const { access_token, user_id } = req.query;
    // ...
});

// ✅ 正确：敏感参数通过POST传输
app.post('/auth/token', (req, res) => {
    // 敏感信息在请求体中，更安全
    const { access_token, user_id } = req.body;
    
    // 添加内容类型验证
    if (req.get('Content-Type') !== 'application/json') {
        return res.status(400).json({ error: '请使用JSON格式' });
    }
    
    // 处理登录逻辑...
});

// 🔒 第三方登录回调处理
app.post('/auth/callback', async (req, res) => {
    const { code, state } = req.body; // 从POST body获取
    
    try {
        // 1. 验证state参数
        if (!validateState(req, state)) {
            throw new Error('State验证失败');
        }
        
        // 2. 用code换取access_token
        const tokenResponse = await fetch('https://api.weixin.qq.com/sns/oauth2/access_token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                appid: WECHAT_APP_ID,
                secret: WECHAT_APP_SECRET,
                code: code,
                grant_type: 'authorization_code'
            })
        });
        
        const tokenData = await tokenResponse.json();
        // 处理Token...
        
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});
```

### 3.3 回调地址白名单机制


**🎯 什么是回调地址白名单**
```
想象快递配送：
📦 你只允许快递送到指定的几个地址（家、公司）
📦 如果快递员说要送到其他地址，你会拒绝

回调地址白名单也是这样：
✅ 只允许回调到预先设置的安全地址
❌ 拒绝回调到未知或可疑地址
```

**🛡️ 白名单验证实现**
```javascript
// 1️⃣ 配置允许的回调地址
const ALLOWED_CALLBACK_URLS = [
    'https://yoursite.com/auth/wechat/callback',
    'https://yoursite.com/auth/qq/callback',
    'https://app.yoursite.com/auth/callback',
    'https://m.yoursite.com/auth/callback'
];

// 2️⃣ 验证回调地址
function validateCallbackUrl(url) {
    try {
        const callbackUrl = new URL(url);
        
        // 检查协议必须是HTTPS
        if (callbackUrl.protocol !== 'https:') {
            return false;
        }
        
        // 检查是否在白名单中
        return ALLOWED_CALLBACK_URLS.includes(url);
        
    } catch (error) {
        // URL格式错误
        return false;
    }
}

// 3️⃣ 发起OAuth授权前验证
app.post('/auth/initiate', (req, res) => {
    const { provider, callback_url } = req.body;
    
    // 验证回调地址
    if (!validateCallbackUrl(callback_url)) {
        return res.status(400).json({ 
            error: '无效的回调地址' 
        });
    }
    
    // 生成授权URL
    const authUrl = buildOAuthUrl(provider, callback_url);
    res.json({ authUrl });
});

// 4️⃣ 动态配置管理
class CallbackWhitelist {
    static async addUrl(url, userId) {
        // 只有管理员可以添加新的回调地址
        if (!await this.isAdmin(userId)) {
            throw new Error('权限不足');
        }
        
        // 验证URL格式
        if (!this.isValidUrl(url)) {
            throw new Error('URL格式无效');
        }
        
        // 添加到数据库
        await db.query(`
            INSERT INTO callback_whitelist (url, added_by, created_at) 
            VALUES (?, ?, NOW())
        `, [url, userId]);
    }
    
    static async isUrlAllowed(url) {
        const result = await db.query(`
            SELECT COUNT(*) as count 
            FROM callback_whitelist 
            WHERE url = ? AND status = 'active'
        `, [url]);
        
        return result[0].count > 0;
    }
}
```

---

## 4. 🚦 访问控制策略


### 4.1 登录频率限制


**⚡ 为什么要限制登录频率**
```
防止暴力破解：
🔨 恶意用户不断尝试登录
🔨 短时间内大量登录请求
🔨 可能导致系统性能下降

限制后的好处：
✅ 阻止自动化攻击
✅ 保护系统资源
✅ 给正常用户更好的体验
```

**🕐 登录频率限制实现**
```javascript
const rateLimit = require('express-rate-limit');

// 1️⃣ 基础登录频率限制
const loginRateLimit = rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟时间窗口
    max: 5,                   // 最多5次尝试
    message: {
        error: '登录尝试次数过多，请15分钟后再试'
    },
    standardHeaders: true,    // 返回速率限制信息到头部
    legacyHeaders: false,
});

// 2️⃣ 应用到登录路由
app.post('/auth/login', loginRateLimit, async (req, res) => {
    // 登录逻辑...
});

// 3️⃣ 更精细的频率控制
class LoginRateController {
    static async checkLimit(identifier) {
        // identifier可以是IP、用户名、邮箱等
        const key = `login_attempts:${identifier}`;
        const attempts = await redis.get(key) || 0;
        
        if (attempts >= 5) {
            const ttl = await redis.ttl(key);
            throw new Error(`登录尝试次数过多，请${Math.ceil(ttl/60)}分钟后再试`);
        }
        
        return true;
    }
    
    static async recordAttempt(identifier, success) {
        const key = `login_attempts:${identifier}`;
        
        if (success) {
            // 登录成功，清除计数
            await redis.del(key);
        } else {
            // 登录失败，增加计数
            const attempts = await redis.incr(key);
            if (attempts === 1) {
                // 设置15分钟过期
                await redis.expire(key, 15 * 60);
            }
        }
    }
}

// 4️⃣ 在登录逻辑中使用
app.post('/auth/login', async (req, res) => {
    const { username, password } = req.body;
    const clientIP = req.ip;
    
    try {
        // 检查频率限制
        await LoginRateController.checkLimit(clientIP);
        await LoginRateController.checkLimit(username);
        
        // 执行登录验证
        const user = await authenticateUser(username, password);
        
        if (user) {
            // 登录成功
            await LoginRateController.recordAttempt(clientIP, true);
            await LoginRateController.recordAttempt(username, true);
            
            res.json({ success: true, user });
        } else {
            // 登录失败
            await LoginRateController.recordAttempt(clientIP, false);
            await LoginRateController.recordAttempt(username, false);
            
            res.status(401).json({ error: '用户名或密码错误' });
        }
        
    } catch (error) {
        res.status(429).json({ error: error.message });
    }
});
```

### 4.2 IP访问控制


**🌍 IP访问控制的作用**
```
就像门卫检查身份证：
🏠 只允许特定小区的人进入
🏠 阻止可疑人员进入
🏠 记录所有进出人员

IP访问控制：
✅ 只允许信任的IP访问
✅ 阻止已知恶意IP
✅ 记录所有访问行为
```

**🔒 IP白名单和黑名单**
```javascript
// 1️⃣ IP访问控制中间件
class IPAccessControl {
    // IP白名单（只允许这些IP访问）
    static whitelist = [
        '192.168.1.0/24',    // 内网段
        '10.0.0.0/8',        // 私有网络
        '203.0.113.1'        // 特定公网IP
    ];
    
    // IP黑名单（禁止这些IP访问）
    static blacklist = [
        '198.51.100.1',      // 已知恶意IP
        '203.0.113.100'      // 被举报IP
    ];
    
    static async isIPAllowed(ip) {
        // 先检查黑名单
        if (this.isInBlacklist(ip)) {
            return false;
        }
        
        // 如果有白名单，检查是否在白名单中
        if (this.whitelist.length > 0) {
            return this.isInWhitelist(ip);
        }
        
        // 没有白名单限制，且不在黑名单中
        return true;
    }
    
    static isInRange(ip, range) {
        // 简化的IP范围检查（实际应用建议使用专业库）
        if (range.includes('/')) {
            // CIDR格式处理
            return this.checkCIDR(ip, range);
        } else {
            // 精确匹配
            return ip === range;
        }
    }
}

// 2️⃣ 应用IP访问控制
app.use('/auth', async (req, res, next) => {
    const clientIP = req.ip || req.connection.remoteAddress;
    
    if (!await IPAccessControl.isIPAllowed(clientIP)) {
        // 记录被拒绝的访问
        console.log(`拒绝IP访问: ${clientIP} at ${new Date()}`);
        
        return res.status(403).json({
            error: '访问被拒绝',
            code: 'IP_BLOCKED'
        });
    }
    
    next();
});

// 3️⃣ 动态IP管理
class DynamicIPControl {
    // 临时添加IP到黑名单
    static async blockIP(ip, reason, duration = 3600) {
        const key = `blocked_ip:${ip}`;
        await redis.setex(key, duration, JSON.stringify({
            reason,
            blockedAt: new Date(),
            duration
        }));
    }
    
    // 检查IP是否被临时阻止
    static async isIPBlocked(ip) {
        const key = `blocked_ip:${ip}`;
        const result = await redis.get(key);
        return result !== null;
    }
    
    // 自动检测可疑IP
    static async detectSuspiciousIP(ip) {
        const key = `ip_requests:${ip}`;
        const requests = await redis.incr(key);
        
        if (requests === 1) {
            await redis.expire(key, 60); // 1分钟窗口
        }
        
        // 1分钟内超过100次请求，自动阻止1小时
        if (requests > 100) {
            await this.blockIP(ip, '请求频率过高', 3600);
            return true;
        }
        
        return false;
    }
}
```

### 4.3 防刷攻击机制


**🤖 什么是刷攻击**
```
刷攻击就像：
🤖 机器人不停地点击按钮
🤖 同一个人注册无数个账号
🤖 批量发送垃圾信息

对系统的危害：
💥 消耗服务器资源
💥 影响正常用户使用
💥 可能导致服务崩溃
```

**🛡️ 多层防刷机制**
```javascript
// 1️⃣ 验证码防护
const captcha = require('svg-captcha');

app.get('/captcha', (req, res) => {
    const cap = captcha.create({
        size: 4,        // 4位验证码
        noise: 2,       // 干扰线条数
        color: true,    // 彩色验证码
        background: '#f0f0f0'
    });
    
    // 保存验证码到session
    req.session.captcha = cap.text.toLowerCase();
    
    res.type('svg');
    res.send(cap.data);
});

// 2️⃣ 设备指纹识别
class DeviceFingerprint {
    static generate(req) {
        const userAgent = req.get('User-Agent') || '';
        const acceptLanguage = req.get('Accept-Language') || '';
        const acceptEncoding = req.get('Accept-Encoding') || '';
        
        // 创建设备指纹
        const fingerprint = crypto
            .createHash('md5')
            .update(userAgent + acceptLanguage + acceptEncoding)
            .digest('hex');
            
        return fingerprint;
    }
    
    static async checkFingerprint(fingerprint) {
        const key = `device:${fingerprint}`;
        const requests = await redis.incr(key);
        
        if (requests === 1) {
            await redis.expire(key, 3600); // 1小时窗口
        }
        
        // 1小时内同一设备超过50次请求
        if (requests > 50) {
            throw new Error('设备请求频率过高');
        }
        
        return true;
    }
}

// 3️⃣ 行为分析防护
class BehaviorAnalysis {
    static async analyzeLoginBehavior(req, userData) {
        const risks = [];
        
        // 检查登录时间
        const hour = new Date().getHours();
        if (hour >= 2 && hour <= 6) {
            risks.push('深夜登录');
        }
        
        // 检查地理位置变化
        const lastIP = userData.lastLoginIP;
        const currentIP = req.ip;
        if (lastIP && this.isIPLocationChanged(lastIP, currentIP)) {
            risks.push('地理位置异常');
        }
        
        // 检查登录间隔
        const lastLogin = userData.lastLoginTime;
        const now = new Date();
        if (lastLogin && (now - lastLogin) < 5000) { // 5秒内重复登录
            risks.push('登录间隔异常');
        }
        
        return risks;
    }
    
    static async requireAdditionalVerification(risks) {
        // 根据风险级别决定是否需要额外验证
        return risks.length >= 2;
    }
}

// 4️⃣ 综合防刷中间件
async function antiSpamMiddleware(req, res, next) {
    try {
        // 1. 检查验证码
        const { captcha } = req.body;
        if (!captcha || captcha.toLowerCase() !== req.session.captcha) {
            return res.status(400).json({ error: '验证码错误' });
        }
        
        // 2. 检查设备指纹
        const fingerprint = DeviceFingerprint.generate(req);
        await DeviceFingerprint.checkFingerprint(fingerprint);
        
        // 3. 检查IP是否被阻止
        if (await DynamicIPControl.isIPBlocked(req.ip)) {
            return res.status(429).json({ error: 'IP已被临时阻止' });
        }
        
        // 4. 检测可疑行为
        if (await DynamicIPControl.detectSuspiciousIP(req.ip)) {
            return res.status(429).json({ error: '检测到异常行为' });
        }
        
        next();
        
    } catch (error) {
        res.status(429).json({ error: error.message });
    }
}
```

---

## 5. 🔐 数据安全处理


### 5.1 敏感信息脱敏


**🎭 什么是数据脱敏**
```
就像给敏感信息"打马赛克"：
📱 手机号：138****8888
💳 银行卡：6222****1234
📧 邮箱：abc***@gmail.com
🏠 地址：北京市朝阳区****小区

目的：
✅ 保护用户隐私
✅ 降低数据泄露风险
✅ 符合法律法规要求
```

**🛠️ 数据脱敏实现**
```javascript
class DataMasking {
    // 手机号脱敏
    static maskPhone(phone) {
        if (!phone || phone.length < 11) return phone;
        return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
    }
    
    // 邮箱脱敏
    static maskEmail(email) {
        if (!email || !email.includes('@')) return email;
        const [username, domain] = email.split('@');
        const maskedUsername = username.length > 2 
            ? username.substring(0, 2) + '***' + username.slice(-1)
            : username.substring(0, 1) + '***';
        return `${maskedUsername}@${domain}`;
    }
    
    // 身份证脱敏
    static maskIdCard(idCard) {
        if (!idCard || idCard.length < 15) return idCard;
        return idCard.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
    }
    
    // 银行卡脱敏
    static maskBankCard(cardNumber) {
        if (!cardNumber || cardNumber.length < 12) return cardNumber;
        return cardNumber.replace(/(\d{4})\d{8,12}(\d{4})/, '$1****$2');
    }
    
    // 姓名脱敏
    static maskName(name) {
        if (!name || name.length < 2) return name;
        if (name.length === 2) {
            return name.charAt(0) + '*';
        }
        return name.charAt(0) + '*'.repeat(name.length - 2) + name.slice(-1);
    }
    
    // 地址脱敏
    static maskAddress(address) {
        if (!address || address.length < 10) return address;
        // 保留前面和后面部分，中间用***替代
        const front = address.substring(0, 6);
        const back = address.slice(-4);
        return `${front}***${back}`;
    }
}

// 用户信息脱敏处理
function maskUserInfo(user) {
    return {
        id: user.id,
        username: user.username,
        // 敏感信息脱敏
        phone: DataMasking.maskPhone(user.phone),
        email: DataMasking.maskEmail(user.email),
        realName: DataMasking.maskName(user.realName),
        idCard: DataMasking.maskIdCard(user.idCard),
        address: DataMasking.maskAddress(user.address),
        // 非敏感信息保持原样
        avatar: user.avatar,
        createTime: user.createTime
    };
}

// API返回时自动脱敏
app.get('/api/user/profile', authenticateToken, async (req, res) => {
    const user = await getUserById(req.user.id);
    
    // 返回前先脱敏
    const maskedUser = maskUserInfo(user);
    
    res.json({
        success: true,
        data: maskedUser
    });
});
```

### 5.2 日志安全记录


**📝 为什么要安全记录日志**
```
日志的价值：
🔍 问题排查：出错时能快速定位
🕵️ 安全审计：发现异常行为
📊 数据分析：了解用户使用模式

日志的风险：
💥 可能记录敏感信息
💥 日志文件可能被盗
💥 内部人员可能滥用
```

**🔒 安全日志实现**
```javascript
const winston = require('winston');

// 1️⃣ 日志配置
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json(),
        // 自定义格式化，自动脱敏
        winston.format.printf(({ timestamp, level, message, ...meta }) => {
            // 对meta中的敏感信息脱敏
            const safeMeta = sanitizeLogData(meta);
            return JSON.stringify({
                timestamp,
                level,
                message,
                ...safeMeta
            });
        })
    ),
    transports: [
        // 普通日志文件
        new winston.transports.File({ 
            filename: 'logs/app.log',
            maxsize: 10 * 1024 * 1024, // 10MB
            maxFiles: 5
        }),
        // 错误日志单独文件
        new winston.transports.File({ 
            filename: 'logs/error.log', 
            level: 'error' 
        })
    ]
});

// 2️⃣ 日志数据脱敏
function sanitizeLogData(data) {
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'phone', 'email', 'idCard'];
    const sanitized = JSON.parse(JSON.stringify(data));
    
    function maskSensitiveData(obj) {
        for (let key in obj) {
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                maskSensitiveData(obj[key]);
            } else if (typeof obj[key] === 'string') {
                // 检查是否为敏感字段
                if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
                    obj[key] = '***MASKED***';
                }
                // 检查是否为手机号格式
                else if (/^1[3-9]\d{9}$/.test(obj[key])) {
                    obj[key] = DataMasking.maskPhone(obj[key]);
                }
                // 检查是否为邮箱格式
                else if (/\S+@\S+\.\S+/.test(obj[key])) {
                    obj[key] = DataMasking.maskEmail(obj[key]);
                }
            }
        }
    }
    
    maskSensitiveData(sanitized);
    return sanitized;
}

// 3️⃣ 安全事件记录
class SecurityLogger {
    static logLoginAttempt(username, ip, success, reason = '') {
        logger.info('登录尝试', {
            event: 'LOGIN_ATTEMPT',
            username: DataMasking.maskEmail(username), // 脱敏用户名
            ip,
            success,
            reason,
            timestamp: new Date().toISOString()
        });
    }
    
    static logTokenIssued(userId, tokenType, expiresIn) {
        logger.info('Token颁发', {
            event: 'TOKEN_ISSUED',
            userId,
            tokenType,
            expiresIn,
            timestamp: new Date().toISOString()
        });
    }
    
    static logSecurityAlert(type, details, severity = 'medium') {
        logger.warn('安全警报', {
            event: 'SECURITY_ALERT',
            type,
            details: sanitizeLogData(details),
            severity,
            timestamp: new Date().toISOString()
        });
    }
    
    static logDataAccess(userId, resource, action, ip) {
        logger.info('数据访问', {
            event: 'DATA_ACCESS',
            userId,
            resource,
            action,
            ip,
            timestamp: new Date().toISOString()
        });
    }
}

// 4️⃣ 在实际操作中使用
app.post('/auth/login', async (req, res) => {
    const { username, password } = req.body;
    const clientIP = req.ip;
    
    try {
        const user = await authenticateUser(username, password);
        
        if (user) {
            // 记录成功登录
            SecurityLogger.logLoginAttempt(username, clientIP, true);
            SecurityLogger.logTokenIssued(user.id, 'access_token', 7200);
            
            res.json({ success: true, user: maskUserInfo(user) });
        } else {
            // 记录失败登录
            SecurityLogger.logLoginAttempt(username, clientIP, false, '用户名或密码错误');
            res.status(401).json({ error: '登录失败' });
        }
    } catch (error) {
        // 记录异常
        SecurityLogger.logSecurityAlert('LOGIN_ERROR', {
            username,
            ip: clientIP,
            error: error.message
        }, 'high');
        
        res.status(500).json({ error: '系统错误' });
    }
});
```

### 5.3 用户隐私保护


**🛡️ 隐私保护的核心原则**
```
最小化原则：
📝 只收集必要的信息
📝 只保留必要的时间
📝 只给必要的人访问

透明化原则：
👁️ 告知用户收集什么信息
👁️ 说明信息用途
👁️ 提供查看和删除选项

用户控制原则：
🎛️ 用户可以查看自己的数据
🎛️ 用户可以修改自己的数据
🎛️ 用户可以删除自己的数据
```

**🔐 隐私保护实现**
```javascript
// 1️⃣ 数据收集控制
class PrivacyController {
    // 数据收集声明
    static getDataCollectionPolicy() {
        return {
            necessary: {
                fields: ['username', 'email'],
                purpose: '账户创建和登录',
                retention: '账户删除后立即清除'
            },
            optional: {
                fields: ['phone', 'avatar', 'birthday'],
                purpose: '提供个性化服务',
                retention: '用户可随时删除',
                userControl: true
            },
            thirdParty: {
                providers: ['微信', 'QQ'],
                dataShared: ['昵称', '头像'],
                purpose: '第三方登录',
                userConsent: true
            }
        };
    }
    
    // 用户同意记录
    static async recordConsent(userId, consentType, agreed) {
        await db.query(`
            INSERT INTO user_consents (user_id, consent_type, agreed, created_at)
            VALUES (?, ?, ?, NOW())
            ON DUPLICATE KEY UPDATE
            agreed = VALUES(agreed), updated_at = NOW()
        `, [userId, consentType, agreed]);
    }
    
    // 检查用户同意状态
    static async hasUserConsent(userId, consentType) {
        const result = await db.query(`
            SELECT agreed FROM user_consents
            WHERE user_id = ? AND consent_type = ?
        `, [userId, consentType]);
        
        return result.length > 0 && result[0].agreed;
    }
}

// 2️⃣ 数据访问控制
class DataAccessControl {
    // 记录数据访问
    static async logAccess(userId, accessor, dataType, purpose) {
        SecurityLogger.logDataAccess(accessor, `user:${userId}:${dataType}`, 'READ', req.ip);
        
        await db.query(`
            INSERT INTO data_access_logs 
            (user_id, accessor, data_type, purpose, accessed_at)
            VALUES (?, ?, ?, ?, NOW())
        `, [userId, accessor, dataType, purpose]);
    }
    
    // 用户查看访问记录
    static async getUserAccessLogs(userId, limit = 50) {
        const logs = await db.query(`
            SELECT accessor, data_type, purpose, accessed_at
            FROM data_access_logs
            WHERE user_id = ?
            ORDER BY accessed_at DESC
            LIMIT ?
        `, [userId, limit]);
        
        return logs;
    }
}

// 3️⃣ 数据导出和删除
class DataPortability {
    // 用户数据导出
    static async exportUserData(userId) {
        // 收集用户所有数据
        const userData = {
            profile: await this.getUserProfile(userId),
            loginHistory: await this.getLoginHistory(userId),
            accessLogs: await DataAccessControl.getUserAccessLogs(userId),
            consents: await this.getUserConsents(userId),
            thirdPartyConnections: await this.getThirdPartyConnections(userId)
        };
        
        // 脱敏处理
        userData.profile = maskUserInfo(userData.profile);
        
        return {
            exportDate: new Date().toISOString(),
            data: userData,
            format: 'JSON',
            note: '此导出包含您的所有个人数据'
        };
    }
    
    // 用户数据删除
    static async deleteUserData(userId, deleteType = 'soft') {
        if (deleteType === 'hard') {
            // 硬删除：完全清除数据
            await this.hardDeleteUser(userId);
        } else {
            // 软删除：标记删除，保留必要的审计信息
            await this.softDeleteUser(userId);
        }
        
        // 记录删除操作
        SecurityLogger.logDataAccess(userId, 'SYSTEM', 'USER_DATA', 'DELETE');
    }
    
    static async softDeleteUser(userId) {
        // 1. 标记用户为已删除
        await db.query(`
            UPDATE users SET 
                status = 'deleted',
                deleted_at = NOW(),
                -- 清空敏感信息
                email = CONCAT('deleted_', id, '@deleted.com'),
                phone = NULL,
                real_name = NULL,
                id_card = NULL,
                address = NULL
            WHERE id = ?
        `, [userId]);
        
        // 2. 清除第三方连接
        await db.query(`
            DELETE FROM third_party_accounts WHERE user_id = ?
        `, [userId]);
        
        // 3. 清除Token
        await db.query(`
            DELETE FROM user_tokens WHERE user_id = ?
        `, [userId]);
    }
}

// 4️⃣ 隐私设置API
app.get('/api/privacy/policy', (req, res) => {
    res.json(PrivacyController.getDataCollectionPolicy());
});

app.post('/api/privacy/consent', authenticateToken, async (req, res) => {
    const { consentType, agreed } = req.body;
    
    await PrivacyController.recordConsent(req.user.id, consentType, agreed);
    
    res.json({ success: true, message: '隐私设置已更新' });
});

app.get('/api/privacy/export', authenticateToken, async (req, res) => {
    const exportData = await DataPortability.exportUserData(req.user.id);
    
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', `attachment; filename="user_data_${req.user.id}.json"`);
    res.json(exportData);
});

app.delete('/api/privacy/delete-account', authenticateToken, async (req, res) => {
    const { confirmPassword, deleteType = 'soft' } = req.body;
    
    // 验证密码
    const user = await getUserById(req.user.id);
    if (!await bcrypt.compare(confirmPassword, user.password)) {
        return res.status(400).json({ error: '密码验证失败' });
    }
    
    // 删除数据
    await DataPortability.deleteUserData(req.user.id, deleteType);
    
    res.json({ 
        success: true, 
        message: '账户删除请求已处理',
        deleteType 
    });
});
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的安全要点


**🔑 CSRF防护**
```
💡 核心思想：用随机"暗号"验证请求来源
✅ State参数：每次登录生成唯一随机值
✅ 一次性使用：验证后立即删除，防止重放
✅ 服务端验证：回调时严格校验State参数
```

**🔐 Token安全**
```
💡 核心思想：Token像临时通行证，需要妥善保管
✅ 加密存储：Token不能明文保存
✅ 合理过期：平衡安全性和用户体验
✅ 主动失效：支持立即作废Token的能力
```

**🌐 传输安全**
```
💡 核心思想：数据传输全程加密保护
✅ 强制HTTPS：所有敏感操作必须加密传输
✅ POST传输：敏感参数避免出现在URL中
✅ 回调白名单：只允许安全地址接收回调
```

**🚦 访问控制**
```
💡 核心思想：限制和监控访问行为
✅ 频率限制：防止暴力破解和刷攻击
✅ IP控制：基于来源IP的访问策略
✅ 行为分析：识别异常访问模式
```

**🔒 数据安全**
```
💡 核心思想：保护用户隐私，安全记录操作
✅ 信息脱敏：敏感数据展示时打"马赛克"
✅ 安全日志：记录操作但不泄露敏感信息
✅ 隐私保护：用户对自己数据有完全控制权
```

### 6.2 实施优先级建议


**🔥 优先级1（必须实施）**
- ✅ 强制HTTPS传输
- ✅ State参数CSRF防护
- ✅ 基础登录频率限制
- ✅ Token加密存储

**⚡ 优先级2（强烈建议）**
- ✅ IP访问控制
- ✅ 敏感信息脱敏
- ✅ 安全日志记录
- ✅ Token主动失效

**🎯 优先级3（条件允许）**
- ✅ 设备指纹识别
- ✅ 行为分析检测
- ✅ 数据导出功能
- ✅ 高级防刷机制

### 6.3 常见安全误区


**❌ 错误做法**
```
🚫 认为HTTPS就万无一失
🚫 State参数使用固定值
🚫 Token永不过期
🚫 敏感信息明文记录日志
🚫 没有访问频率限制
```

**✅ 正确做法**
```
🎯 HTTPS + 其他安全措施组合
🎯 State参数每次随机生成
🎯 Token设置合理过期时间
🎯 日志记录时自动脱敏
🎯 多层次的访问控制策略
```

### 6.4 安全检查清单


**🔍 上线前检查**
- [ ] HTTPS证书正确配置
- [ ] State参数正确实现
- [ ] Token安全存储和管理
- [ ] 敏感数据脱敏处理
- [ ] 访问频率限制启用
- [ ] 安全日志正常记录
- [ ] 回调地址白名单配置
- [ ] 用户隐私政策完善

**🛡️ 安全记忆口诀**
```
HTTPS传输要强制，State参数防伪造
Token加密设过期，频率限制挡暴力
敏感信息要脱敏，日志记录保安全
IP控制防恶意，隐私保护用户权
```

