---
title: 3、RBAC权限粒度控制
---
## 📚 目录

1. [权限粒度控制概述](#1-权限粒度控制概述)
2. [粗粒度vs细粒度权限控制](#2-粗粒度vs细粒度权限控制)
3. [权限级别分类详解](#3-权限级别分类详解)
4. [数据权限vs功能权限](#4-数据权限vs功能权限)
5. [动态权限设计与配置](#5-动态权限设计与配置)
6. [权限资源标识机制](#6-权限资源标识机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 权限粒度控制概述


### 1.1 什么是权限粒度


**通俗理解**：
权限粒度就像是**钥匙的精细程度**。想象一下：
- **粗粒度**：一把总钥匙，能开整栋楼的所有门
- **细粒度**：每个房间一把专用钥匙，精确控制每个具体位置

```
生活中的权限粒度对比：

银行管理系统：
粗粒度 → "银行经理"角色，能做所有经理级别的事
细粒度 → 具体到"能查看A客户的账户"，"能审批10万以下贷款"

公司系统：
粗粒度 → "财务部门"权限，能访问所有财务功能
细粒度 → "只能查看本部门的报销单"，"只能审批5000元以下费用"
```

### 1.2 权限粒度的重要性


**为什么要控制权限粒度？**

```
🔸 安全需要：越精确的权限控制，系统越安全
🔸 业务需要：不同岗位需要不同程度的数据访问
🔸 合规需要：法律法规要求数据访问有明确边界
🔸 管理需要：精确权限让管理更高效，责任更清晰
```

---

## 2. ⚖️ 粗粒度vs细粒度权限控制


### 2.1 粗粒度权限控制


**定义**：以较大的功能模块或业务域为单位进行权限控制

**特点**：
```
✅ 优点：
• 管理简单，配置容易
• 系统性能好，检查速度快
• 适合小型系统或权限要求不高的场景

❌ 缺点：  
• 权限控制不够精确
• 容易出现权限过大的问题
• 难以满足复杂业务需求
```

**实际例子**：
```
电商系统粗粒度权限：

角色：商品管理员
权限：商品管理模块
- 能做：查看所有商品、添加商品、修改商品、删除商品
- 问题：可能不需要删除权限，但粗粒度控制做不到细分
```

### 2.2 细粒度权限控制


**定义**：以具体的操作、数据行、甚至数据字段为单位进行权限控制

**特点**：
```
✅ 优点：
• 权限控制非常精确
• 安全性高，符合最小权限原则
• 能满足复杂业务场景需求

❌ 缺点：
• 管理复杂，配置工作量大
• 系统性能相对较差
• 容易出现权限配置错误
```

**实际例子**：
```
电商系统细粒度权限：

角色：商品管理员
具体权限：
- 查看：自己创建的商品 ✓
- 查看：其他人创建的商品 ✗
- 修改：商品基本信息 ✓
- 修改：商品价格 ✗ (需要审批)
- 删除：上架状态的商品 ✗
- 删除：草稿状态的商品 ✓
```

### 2.3 粗细粒度权限对比表


| 对比维度 | **粗粒度权限** | **细粒度权限** | **适用场景** |
|---------|--------------|--------------|------------|
| 🎯 **控制精度** | `模块级别` | `操作/数据级别` | `细粒度适合企业级` |
| ⚡ **性能表现** | `检查速度快` | `检查相对较慢` | `粗粒度适合高并发` |
| 🔧 **管理复杂度** | `简单易管理` | `复杂需专人维护` | `粗粒度适合小团队` |
| 🛡️ **安全级别** | `基础安全保障` | `高级精确安全` | `细粒度适合敏感数据` |
| 💰 **实施成本** | `低成本快速实现` | `高成本长期投入` | `根据业务价值选择` |

---

## 3. 🏗️ 权限级别分类详解


### 3.1 系统级权限


**定义**：控制用户能否访问整个系统或大的业务模块

**通俗理解**：就像**进门卡**，决定你能不能进入某个区域

```
系统级权限示例：

用户管理系统：
- 人事系统访问权限
- 财务系统访问权限  
- 销售系统访问权限

电商平台：
- 商家后台访问权限
- 运营后台访问权限
- 客服系统访问权限
```

**实现方式**：
```java
// 系统级权限检查（简化示例）
@RestController
public class SystemController {
    
    @GetMapping("/admin/users")
    @RequiredPermission("SYSTEM_ADMIN") // 需要系统管理员权限
    public List<User> getUserList() {
        return userService.findAll();
    }
}
```

### 3.2 功能级权限


**定义**：控制用户能否使用系统中的具体功能操作

**通俗理解**：就像**功能按钮的开关**，决定你能看到和使用哪些功能

```
功能级权限细分：

菜单权限：
- 用户管理菜单 ✓
- 订单管理菜单 ✓  
- 财务报表菜单 ✗

按钮权限：
- 添加用户按钮 ✓
- 删除用户按钮 ✗
- 导出数据按钮 ✓

操作权限：
- 查看操作 ✓
- 新增操作 ✓
- 修改操作 ✗
- 删除操作 ✗
```

**权限控制层次图**：
```
系统首页
├── 用户管理 ✓
│   ├── 用户列表 ✓
│   │   ├── 查看按钮 ✓
│   │   ├── 添加按钮 ✓
│   │   ├── 编辑按钮 ✗
│   │   └── 删除按钮 ✗
│   └── 角色管理 ✗
└── 订单管理 ✓
    ├── 订单查询 ✓
    └── 订单统计 ✗
```

### 3.3 数据级权限


**定义**：控制用户能访问哪些具体的数据记录

**通俗理解**：就像**数据的过滤器**，同样的功能，不同用户看到不同的数据

```
数据级权限常见类型：

按部门过滤：
- 销售经理：只能看销售部的数据
- 技术经理：只能看技术部的数据

按地区过滤：
- 华东区域经理：只能看华东地区的订单
- 华南区域经理：只能看华南地区的订单

按创建者过滤：
- 普通员工：只能看自己创建的记录
- 部门经理：能看本部门所有人创建的记录
```

**数据权限实现示例**：
```java
// 数据权限过滤（简化示例）
@Service
public class OrderService {
    
    public List<Order> getOrders(User currentUser) {
        // 根据用户角色过滤数据
        if (currentUser.hasRole("ADMIN")) {
            return orderDao.findAll(); // 管理员看所有数据
        } else if (currentUser.hasRole("DEPT_MANAGER")) {
            return orderDao.findByDept(currentUser.getDeptId()); // 部门经理看部门数据
        } else {
            return orderDao.findByCreator(currentUser.getId()); // 普通用户看自己的数据
        }
    }
}
```

---

## 4. 🔄 数据权限vs功能权限


### 4.1 概念区别


**功能权限**：控制**能做什么**
**数据权限**：控制**能看什么数据**

```
生活中的类比：

图书馆管理系统：
功能权限 → 借书员有"借书操作"权限，管理员有"购书操作"权限
数据权限 → 借书员只能看到可借阅的书，管理员能看到所有书包括库存

银行系统：  
功能权限 → 柜员有"存款操作"权限，经理有"贷款审批"权限
数据权限 → 柜员只能查看自己办理的账户，经理能查看分行所有账户
```

### 4.2 两种权限的关联关系


**权限检查流程**：
```
用户操作请求
    ↓
1. 功能权限检查 → 能否执行这个操作？
    ↓ (通过)
2. 数据权限检查 → 能否访问这些数据？
    ↓ (通过)  
3. 执行具体操作
```

**实际应用场景**：
```
员工查看工资单：

步骤1 - 功能权限检查：
- 检查用户是否有"查看工资单"的功能权限 ✓

步骤2 - 数据权限检查：  
- 普通员工：只能看自己的工资单
- HR经理：能看所有员工的工资单
- 部门经理：能看本部门员工的工资单

步骤3 - 返回过滤后的数据
```

### 4.3 权限组合策略表


| 场景类型 | **功能权限** | **数据权限** | **实际效果** |
|---------|------------|------------|------------|
| 👤 **普通用户** | `查看订单 ✓` | `只看自己的订单` | `能查看，但只看到自己的` |
| 👥 **部门经理** | `查看订单 ✓` | `看本部门所有订单` | `能查看本部门全部订单` |
| 👨‍💼 **系统管理员** | `查看订单 ✓` | `看全部订单` | `能查看系统所有订单` |
| 🚫 **访客用户** | `查看订单 ✗` | `无数据权限` | `完全无法查看订单` |

---

## 5. ⚙️ 动态权限设计与配置


### 5.1 什么是动态权限


**静态权限**：权限写死在代码里，要改权限就要改代码重新发布
**动态权限**：权限存在数据库里，可以通过配置界面随时调整

```
对比说明：

静态权限（硬编码）：
@RequiredPermission("USER_DELETE") // 写死在代码里
public void deleteUser() { ... }

动态权限（可配置）：
数据库存储：
权限表：permission_id='user_delete', name='删除用户'
角色权限表：role_id='manager', permission_id='user_delete'
用户角色表：user_id='zhangsan', role_id='manager'
```

### 5.2 动态权限系统架构


**系统组成部分**：
```
权限管理系统
├── 用户管理
├── 角色管理  
├── 权限管理
│   ├── 菜单权限配置
│   ├── 按钮权限配置
│   └── 数据权限配置
├── 角色权限分配
└── 用户角色分配
```

**数据库设计**：
```sql
-- 用户表
CREATE TABLE sys_user (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(100),
    dept_id BIGINT -- 部门ID，用于数据权限
);

-- 角色表  
CREATE TABLE sys_role (
    role_id BIGINT PRIMARY KEY,
    role_name VARCHAR(50),
    role_code VARCHAR(50)
);

-- 权限表
CREATE TABLE sys_permission (
    permission_id BIGINT PRIMARY KEY,
    permission_name VARCHAR(100),
    permission_code VARCHAR(100), -- 如：user:delete
    resource_type VARCHAR(20),    -- menu/button/data
    resource_url VARCHAR(200)     -- 资源路径
);

-- 角色权限关联表
CREATE TABLE sys_role_permission (
    role_id BIGINT,
    permission_id BIGINT
);

-- 用户角色关联表
CREATE TABLE sys_user_role (
    user_id BIGINT,
    role_id BIGINT
);
```

### 5.3 动态权限配置示例


**权限配置界面设计思路**：
```
权限配置页面
├── 左侧：系统功能树
│   ├── 用户管理
│   │   ├── 用户列表 [查看☑ 新增☑ 编辑☐ 删除☐]
│   │   └── 角色管理 [查看☐ 新增☐ 编辑☐ 删除☐]
│   └── 订单管理
│       ├── 订单查询 [查看☑ 导出☑]
│       └── 订单统计 [查看☐]
└── 右侧：数据权限配置
    ├── 全部数据 ☐
    ├── 本部门数据 ☑  
    ├── 本人数据 ☐
    └── 自定义数据过滤规则
```

**动态权限加载代码示例**：
```java
@Service
public class DynamicPermissionService {
    
    // 获取用户的所有权限
    public Set<String> getUserPermissions(Long userId) {
        // 1. 查询用户的所有角色
        List<Role> roles = userRoleDao.findRolesByUserId(userId);
        
        Set<String> permissions = new HashSet<>();
        for (Role role : roles) {
            // 2. 查询角色的所有权限
            List<Permission> rolePermissions = rolePermissionDao.findByRoleId(role.getId());
            for (Permission perm : rolePermissions) {
                permissions.add(perm.getPermissionCode());
            }
        }
        return permissions;
    }
    
    // 检查用户是否有特定权限
    public boolean hasPermission(Long userId, String permissionCode) {
        Set<String> userPermissions = getUserPermissions(userId);
        return userPermissions.contains(permissionCode);
    }
}
```

---

## 6. 🏷️ 权限资源标识机制


### 6.1 权限资源标识的作用


**为什么需要资源标识？**
```
问题：系统有成千上万个功能，怎么精确识别每一个需要控制权限的地方？
解决：给每个需要权限控制的资源一个唯一的"身份证号"

就像：
- 身份证号码 → 唯一标识一个人
- 权限编码 → 唯一标识一个权限点
```

### 6.2 URL资源标识


**定义**：用访问路径作为权限标识

```
URL权限示例：
/admin/users          → 用户管理页面访问权限
/admin/users/add      → 添加用户页面权限
/api/users            → 用户列表API权限
/api/users/{id}       → 特定用户信息API权限
```

**优缺点分析**：
```
✅ 优点：
• 直观易理解，URL就是权限点
• 实现简单，Web框架都支持URL拦截

❌ 缺点：
• 粒度受限，一个页面多个操作不好区分
• URL变更时权限配置也要跟着变
```

**实现代码示例**：
```java
@Component
public class UrlPermissionInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) {
        String requestUrl = request.getRequestURI();
        Long userId = getCurrentUserId(request);
        
        // 检查用户是否有访问该URL的权限
        if (!permissionService.hasUrlPermission(userId, requestUrl)) {
            response.setStatus(403);
            return false;
        }
        return true;
    }
}
```

### 6.3 菜单编码标识


**定义**：给每个菜单项分配唯一编码作为权限标识

```
菜单编码设计：
M001 → 系统管理
M001001 → 用户管理  
M001001001 → 用户列表
M001002 → 角色管理
M001002001 → 角色列表
M002 → 业务管理
M002001 → 订单管理
```

**前端权限控制示例**：
```javascript
// Vue.js 菜单权限控制
export default {
    data() {
        return {
            menuList: [
                { code: 'M001001', name: '用户管理', path: '/users' },
                { code: 'M001002', name: '角色管理', path: '/roles' },
                { code: 'M002001', name: '订单管理', path: '/orders' }
            ]
        }
    },
    computed: {
        // 过滤用户有权限的菜单
        accessibleMenus() {
            return this.menuList.filter(menu => 
                this.$store.getters.hasPermission(menu.code)
            )
        }
    }
}
```

### 6.4 按钮编码标识


**定义**：给页面上的每个操作按钮分配权限编码

```
按钮权限编码规范：
user:view   → 查看用户信息
user:add    → 添加用户  
user:edit   → 编辑用户
user:delete → 删除用户
user:export → 导出用户数据
```

**按钮权限控制实现**：
```html
<!-- 前端按钮权限控制 -->
<template>
    <div class="user-list">
        <button v-if="$hasPermission('user:add')" @click="addUser">
            添加用户
        </button>
        
        <table>
            <tr v-for="user in users" :key="user.id">
                <td>{{ user.name }}</td>
                <td>
                    <button v-if="$hasPermission('user:edit')" @click="editUser(user)">
                        编辑
                    </button>
                    <button v-if="$hasPermission('user:delete')" @click="deleteUser(user)">
                        删除  
                    </button>
                </td>
            </tr>
        </table>
    </div>
</template>
```

### 6.5 权限编码最佳实践


**编码规范建议**：
```
层次化编码：
system:user:view     → 系统管理-用户管理-查看
system:user:add      → 系统管理-用户管理-添加  
business:order:view  → 业务管理-订单管理-查看

动作标准化：
view/query  → 查看/查询
add/create  → 添加/创建
edit/update → 编辑/更新
delete      → 删除
export      → 导出
import      → 导入
audit       → 审核
```

**权限编码对照表**：
| 资源类型 | **编码示例** | **说明** | **控制粒度** |
|---------|------------|---------|------------|
| 🌐 **URL权限** | `/admin/users` | `访问路径标识` | `页面级控制` |
| 📋 **菜单权限** | `M001001` | `菜单编码标识` | `菜单显示控制` |
| 🔘 **按钮权限** | `user:delete` | `操作编码标识` | `按钮级控制` |
| 📊 **数据权限** | `dept:self` | `数据范围标识` | `数据过滤控制` |

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 权限粒度：控制权限的精细程度，从粗到细影响安全性和复杂度
🔸 三级权限：系统级(进门卡) → 功能级(功能开关) → 数据级(数据过滤器)  
🔸 双重控制：功能权限(能做什么) + 数据权限(能看什么数据)
🔸 动态配置：权限存数据库，通过界面配置，无需修改代码
🔸 资源标识：URL、菜单编码、按钮编码等唯一识别权限点
```

### 7.2 关键理解要点


**🔹 粗细粒度的平衡**
```
选择原则：
• 小系统、简单业务 → 粗粒度权限，快速实现
• 大系统、复杂业务 → 细粒度权限，精确控制
• 混合模式 → 核心模块细粒度，辅助模块粗粒度
```

**🔹 功能权限与数据权限的配合**
```
实施策略：
1. 先设计功能权限框架
2. 再根据业务需要补充数据权限
3. 两种权限叠加检查，都通过才允许操作
```

**🔹 动态权限的设计思路**
```
架构要点：
• 权限配置与业务代码分离
• 提供可视化的权限配置界面
• 权限变更即时生效，无需重启系统
• 支持权限的批量导入导出
```

### 7.3 实际应用指导


**权限设计决策表**：
| 业务场景 | **推荐粒度** | **重点关注** | **实现建议** |
|---------|------------|------------|------------|
| 🏢 **小型OA系统** | `粗粒度为主` | `快速实现，成本控制` | `角色-菜单权限即可` |
| 🏦 **银行业务系统** | `细粒度必须` | `数据安全，合规要求` | `功能+数据双重权限` |
| 🛒 **电商平台** | `混合粒度` | `用户体验，安全平衡` | `核心功能细粒度` |
| 📊 **数据分析平台** | `数据权限为主` | `数据访问边界清晰` | `重点设计数据权限` |

**权限实施路线图**：
```
第1阶段：基础权限框架
• 用户-角色-权限基本模型
• 主要菜单和功能的权限控制

第2阶段：细化功能权限  
• 页面按钮级权限控制
• API接口权限校验

第3阶段：数据权限补充
• 部门/区域数据隔离
• 个人数据访问控制

第4阶段：高级权限特性
• 动态权限配置界面
• 权限审计和监控
```

**常见问题解决**：
```
Q: 权限太多管理困难怎么办？
A: 建立权限模板和角色模板，批量分配权限

Q: 数据权限性能影响大怎么办？  
A: 使用缓存机制，在SQL查询时直接过滤数据

Q: 权限变更频繁怎么办？
A: 设计工作流审批，权限变更需要审批才能生效
```

**核心记忆口诀**：
- 权限粒度粗细选，业务复杂细一点
- 功能数据两重关，先功能来后数据  
- 动态配置是趋势，代码权限要分离
- 资源标识要规范，URL按钮菜单全