---
title: 10、RBAC数据权限控制
---
## 📚 目录

1. [数据权限的核心概念](#1-数据权限的核心概念)
2. [行级数据权限详解](#2-行级数据权限详解)
3. [部门组织结构数据控制](#3-部门组织结构数据控制)
4. [SQL条件过滤实现机制](#4-SQL条件过滤实现机制)
5. [数据权限与角色权限整合设计](#5-数据权限与角色权限整合设计)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 数据权限的核心概念


### 1.1 什么是数据权限


**📋 通俗理解**
```
想象一个公司场景：
- 销售员小王只能看到自己负责客户的信息
- 销售主管可以看到整个小组客户的信息  
- 销售总监可以看到全公司客户的信息

这就是数据权限！同样的功能，不同的人看到不同范围的数据
```

**🔸 核心定义**
- **数据权限**：控制用户能访问哪些具体数据记录的机制
- **与功能权限的区别**：功能权限决定"能不能做"，数据权限决定"能看到什么"
- **细粒度控制**：精确到每一行数据的访问控制

### 1.2 数据权限的应用价值


**💡 实际应用场景**
```
🏢 企业管理系统：
- 部门经理只看本部门员工信息
- 财务只能查看财务相关数据
- HR只能访问人事数据

🏥 医院管理系统：
- 医生只能查看自己负责病人的病历
- 科室主任能看科室所有病人信息
- 药剂师只能看药品相关数据

🏫 教育管理系统：
- 老师只能看自己班级学生成绩
- 年级主任能看整个年级数据
- 校长可以看全校数据
```

### 1.3 数据权限的分类


| 权限类型 | **控制范围** | **典型场景** | **实现难度** |
|---------|-------------|-------------|-------------|
| 🔸 **个人数据** | `只能访问自己的数据` | `查看个人工资单` | `⭐ 简单` |
| 🔸 **部门数据** | `本部门范围内的数据` | `部门业绩统计` | `⭐⭐ 中等` |
| 🔸 **角色数据** | `特定角色相关的数据` | `财务查看财务数据` | `⭐⭐ 中等` |
| 🔸 **层级数据** | `按组织层级控制` | `上级看下级数据` | `⭐⭐⭐ 复杂` |
| 🔸 **条件数据** | `满足特定条件的数据` | `只看已审核的数据` | `⭐⭐⭐ 复杂` |

---

## 2. 🔍 行级数据权限详解


### 2.1 什么是行级数据权限


**🔸 概念理解**
```
数据库表就像一张Excel表格：
┌────────┬──────────┬────────┬──────────┐
│ 订单ID │  客户名称  │ 销售员  │  订单金额  │
├────────┼──────────┼────────┼──────────┤
│ 001    │ 腾讯科技   │ 小王    │ 100,000  │ ← 小王能看到
├────────┼──────────┼────────┼──────────┤
│ 002    │ 阿里巴巴   │ 小李    │ 200,000  │ ← 小王看不到
├────────┼──────────┼────────┼──────────┤
│ 003    │ 字节跳动   │ 小王    │ 150,000  │ ← 小王能看到
└────────┴──────────┴────────┴──────────┘

行级权限 = 控制用户能看到表格中的哪几行数据
```

**💡 核心特点**
- **精细控制**：精确到每一行数据记录
- **动态过滤**：根据用户身份动态筛选数据
- **透明操作**：用户感觉不到权限限制，就像数据本来就这么少

### 2.2 行级权限的实现原理


**🔧 基本工作流程**
```
用户查询请求
       ↓
识别用户身份和权限
       ↓
构建数据过滤条件
       ↓
在SQL查询中添加WHERE条件
       ↓
返回过滤后的数据结果
```

**📝 简单代码示例**
```java
// 销售员查询订单
public List<Order> getOrders(User currentUser) {
    String sql = "SELECT * FROM orders WHERE 1=1";
    
    // 根据用户角色添加数据过滤条件
    if (currentUser.getRole().equals("销售员")) {
        sql += " AND salesperson = '" + currentUser.getUsername() + "'";
    } else if (currentUser.getRole().equals("部门经理")) {
        sql += " AND department = '" + currentUser.getDepartment() + "'";
    }
    // 销售总监不加限制条件，可以看全部数据
    
    return jdbcTemplate.query(sql, new OrderMapper());
}
```

### 2.3 常见的行级权限模式


**🎯 个人数据模式**
```sql
-- 只能看自己创建的数据
WHERE created_by = '当前用户ID'

-- 只能看分配给自己的任务
WHERE assigned_to = '当前用户ID'
```

**🏢 部门数据模式**  
```sql
-- 只能看本部门的数据
WHERE department_id = '当前用户部门ID'

-- 或者使用关联查询
WHERE user_id IN (
    SELECT user_id FROM users 
    WHERE department_id = '当前用户部门ID'
)
```

**🔄 层级数据模式**
```sql
-- 能看自己和下级部门的数据
WHERE department_id IN (
    SELECT dept_id FROM departments 
    WHERE path LIKE '当前部门路径%'
)
```

---

## 3. 🏢 部门组织结构数据控制


### 3.1 组织架构的数据权限思路


**📊 典型组织结构示例**
```
                 总经理
                   |
        ┌──────────┼──────────┐
        |          |          |
      销售部      技术部      财务部
        |          |          |
    ┌───┼───┐  ┌───┼───┐      |
    |   |   |  |   |   |      |
   华北 华南 华东 前端 后端   会计
```

**🔸 权限控制逻辑**
```
总经理：看到全公司所有数据
销售部经理：看到销售部及下属区域的数据
华北区主管：只看华北区的数据
普通销售：只看自己负责的客户数据
```

### 3.2 部门树的数据库设计


**📋 部门表结构**
```sql
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    parent_id INT,                    -- 上级部门ID
    level INT DEFAULT 1,              -- 部门层级
    path VARCHAR(500),                -- 部门路径如: /1/2/5/
    sort_order INT DEFAULT 0          -- 排序
);

-- 示例数据
INSERT INTO departments VALUES 
(1, '总公司', NULL, 1, '/1/', 1),
(2, '销售部', 1, 2, '/1/2/', 2),  
(3, '技术部', 1, 2, '/1/3/', 3),
(4, '华北区', 2, 3, '/1/2/4/', 1),
(5, '华南区', 2, 3, '/1/2/5/', 2);
```

**🔧 用户部门关联**
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    department_id INT,               -- 所属部门
    role VARCHAR(50),               -- 角色
    data_scope VARCHAR(20)          -- 数据权限范围
);

-- data_scope 可选值：
-- 'ALL'     - 全部数据权限
-- 'DEPT'    - 本部门数据权限  
-- 'DEPT_SUB'- 本部门及子部门数据权限
-- 'SELF'    - 仅本人数据权限
-- 'CUSTOM'  - 自定义数据权限
```

### 3.3 部门数据权限的查询实现


**💡 根据数据范围生成SQL条件**
```java
public String buildDataScopeCondition(User user, String tableAlias) {
    String dataScope = user.getDataScope();
    
    switch (dataScope) {
        case "ALL":
            return ""; // 无限制条件
            
        case "DEPT":
            return tableAlias + ".department_id = " + user.getDepartmentId();
            
        case "DEPT_SUB":
            return tableAlias + ".department_id IN (" +
                   "SELECT id FROM departments " +
                   "WHERE path LIKE '" + user.getDepartmentPath() + "%')";
                   
        case "SELF":
            return tableAlias + ".created_by = " + user.getId();
            
        default:
            return tableAlias + ".department_id = " + user.getDepartmentId();
    }
}
```

**📝 实际查询应用**
```java
// 查询员工信息的方法
public List<Employee> getEmployees(User currentUser) {
    String sql = "SELECT * FROM employees e WHERE 1=1";
    
    // 添加数据权限条件
    String dataCondition = buildDataScopeCondition(currentUser, "e");
    if (!dataCondition.isEmpty()) {
        sql += " AND " + dataCondition;
    }
    
    return jdbcTemplate.query(sql, new EmployeeMapper());
}
```

---

## 4. 🔧 SQL条件过滤实现机制


### 4.1 动态SQL条件构建


**🎯 核心思路**
```
基础查询 + 权限过滤条件 = 最终执行的SQL

例如：
基础SQL：SELECT * FROM orders  
权限条件：WHERE salesperson = 'zhangsan'
最终SQL：SELECT * FROM orders WHERE salesperson = 'zhangsan'
```

**💻 条件构建器实现**
```java
public class DataPermissionBuilder {
    
    // 构建数据权限SQL条件
    public String buildPermissionCondition(User user, String tableName) {
        List<String> conditions = new ArrayList<>();
        
        // 个人数据权限
        if (hasPersonalDataPermission(user)) {
            conditions.add(tableName + ".created_by = " + user.getId());
        }
        
        // 部门数据权限
        if (hasDepartmentDataPermission(user)) {
            conditions.add(tableName + ".department_id = " + user.getDepartmentId());
        }
        
        // 角色数据权限
        if (hasRoleDataPermission(user)) {
            conditions.add(buildRoleDataCondition(user, tableName));
        }
        
        // 用OR连接多个条件（满足任一条件即可访问）
        return conditions.isEmpty() ? "" : 
               "(" + String.join(" OR ", conditions) + ")";
    }
}
```

### 4.2 不同场景的SQL过滤实现


**🔸 按创建者过滤**
```sql
-- 只看自己创建的记录
SELECT * FROM orders 
WHERE created_by = #{currentUserId}

-- 包含分配给自己的记录  
SELECT * FROM orders 
WHERE created_by = #{currentUserId} 
   OR assigned_to = #{currentUserId}
```

**🔸 按部门层级过滤**
```sql
-- 本部门及子部门的数据
SELECT o.* FROM orders o
JOIN users u ON o.created_by = u.id
JOIN departments d ON u.department_id = d.id
WHERE d.path LIKE CONCAT(#{userDeptPath}, '%')
```

**🔸 按时间范围过滤**
```sql
-- 只能查看近3个月的数据
SELECT * FROM orders 
WHERE created_time >= DATE_SUB(NOW(), INTERVAL 3 MONTH)
  AND department_id = #{userDeptId}
```

### 4.3 复杂权限条件的组合


**🔗 多条件组合示例**
```java
public String buildComplexPermissionSQL(User user) {
    StringBuilder sql = new StringBuilder("SELECT * FROM orders WHERE 1=1");
    
    // 部门权限条件
    if (user.hasDataScope("DEPT")) {
        sql.append(" AND department_id = ").append(user.getDepartmentId());
    }
    
    // 时间权限条件  
    if (user.hasTimeLimit()) {
        sql.append(" AND created_time >= '").append(user.getDataStartTime()).append("'");
    }
    
    // 状态权限条件
    if (user.hasStatusLimit()) {
        sql.append(" AND status IN (").append(user.getAllowedStatuses()).append(")");
    }
    
    // 金额权限条件
    if (user.hasAmountLimit()) {
        sql.append(" AND amount <= ").append(user.getMaxAmount());
    }
    
    return sql.toString();
}
```

---

## 5. 🔗 数据权限与角色权限整合设计


### 5.1 权限体系的整体架构


**🏗️ RBAC + 数据权限架构图**
```
用户(User)
    ↓
 分配角色
    ↓  
角色(Role) ──→ 功能权限(菜单、按钮、API)
    ↓
 设置数据范围
    ↓
数据权限(Data Permission) ──→ 数据过滤条件

完整的访问控制 = 功能权限 ✓ + 数据权限 ✓
```

**💡 设计思路**
```
第一层：功能权限控制
- 用户能不能访问某个功能模块？
- 能不能点击某个按钮？
- 能不能调用某个API？

第二层：数据权限控制  
- 在有功能权限的前提下
- 能看到哪些具体的数据？
- 数据的范围有多大？
```

### 5.2 数据库表结构设计


**📋 角色数据权限关联表**
```sql
-- 角色表
CREATE TABLE roles (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    description VARCHAR(200),
    data_scope VARCHAR(20) DEFAULT 'DEPT'  -- 默认数据范围
);

-- 角色数据权限表（支持自定义数据范围）
CREATE TABLE role_data_permissions (
    id INT PRIMARY KEY,
    role_id INT NOT NULL,
    resource_type VARCHAR(50),    -- 资源类型：user、order、product等  
    permission_condition TEXT,    -- 权限条件SQL片段
    created_time TIMESTAMP
);

-- 示例数据
INSERT INTO role_data_permissions VALUES
(1, 2, 'order', 'department_id = ${user.departmentId}', NOW()),
(2, 3, 'user', 'created_by = ${user.id}', NOW()),
(3, 1, 'order', '1=1', NOW()); -- 管理员无限制
```

### 5.3 权限检查的完整流程


**🔄 权限验证流程图**
```
用户请求访问数据
         ↓
第一步：功能权限检查
         ↓
    有功能权限？
         ↓ Yes
第二步：获取用户角色
         ↓
第三步：查询角色数据权限配置
         ↓
第四步：构建数据过滤条件
         ↓
第五步：执行带权限条件的SQL查询
         ↓
返回过滤后的数据结果
```

**💻 完整的权限检查代码**
```java
@Service
public class DataPermissionService {
    
    // 检查并执行带权限的查询
    public <T> List<T> queryWithPermission(User user, String sql, Class<T> clazz) {
        // 1. 检查功能权限
        if (!hasFunctionPermission(user, "data.query")) {
            throw new SecurityException("无查询权限");
        }
        
        // 2. 构建数据权限条件
        String dataCondition = buildDataPermissionCondition(user);
        
        // 3. 组合完整SQL
        String finalSql = combineSQL(sql, dataCondition);
        
        // 4. 执行查询
        return jdbcTemplate.query(finalSql, new BeanPropertyRowMapper<>(clazz));
    }
    
    // 构建数据权限条件
    private String buildDataPermissionCondition(User user) {
        List<String> conditions = new ArrayList<>();
        
        // 获取用户所有角色的数据权限
        for (Role role : user.getRoles()) {
            String roleCondition = getRoleDataCondition(role, user);
            if (!roleCondition.isEmpty()) {
                conditions.add(roleCondition);
            }
        }
        
        // 多个角色的权限用OR连接（取并集）
        return conditions.isEmpty() ? "1=0" : // 无权限则查不到数据
               "(" + String.join(" OR ", conditions) + ")";
    }
}
```

### 5.4 实际应用场景整合


**🎯 订单管理系统的权限设计**
```java
// 不同角色的订单查看权限
public List<Order> getOrders(User user) {
    String baseSql = "SELECT * FROM orders o " +
                    "LEFT JOIN customers c ON o.customer_id = c.id " +
                    "WHERE 1=1";
    
    List<String> conditions = new ArrayList<>();
    
    // 根据角色添加数据权限条件
    for (Role role : user.getRoles()) {
        switch (role.getName()) {
            case "销售员":
                conditions.add("o.salesperson_id = " + user.getId());
                break;
                
            case "销售主管":  
                conditions.add("o.department_id = " + user.getDepartmentId());
                break;
                
            case "大客户经理":
                conditions.add("c.customer_type = 'VIP' AND o.salesperson_id = " + user.getId());
                break;
                
            case "财务":
                conditions.add("o.status IN ('PAID', 'COMPLETED')");
                break;
                
            case "总经理":
                // 无限制，不添加条件
                break;
        }
    }
    
    if (!conditions.isEmpty()) {
        baseSql += " AND (" + String.join(" OR ", conditions) + ")";
    }
    
    return jdbcTemplate.query(baseSql, new OrderRowMapper());
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 数据权限本质：控制用户能看到哪些具体数据记录
🔸 行级权限：精确到每一行数据的访问控制  
🔸 部门权限：基于组织架构的数据范围控制
🔸 SQL过滤：通过WHERE条件实现数据权限
🔸 权限整合：功能权限 + 数据权限的完整访问控制
```

### 6.2 关键理解要点


**🔹 数据权限与功能权限的区别**
```
功能权限：能不能用这个功能？（开关控制）
数据权限：能看到什么数据？（范围控制）

例子：
- 功能权限决定你能不能打开"订单管理"页面
- 数据权限决定页面上显示哪些订单记录
```

**🔹 行级权限的核心思路**
```
不是直接限制用户访问数据库
而是在查询时自动添加过滤条件
让用户感觉自己有完整权限，但实际只能看到允许的数据

这样做的好处：
- 对用户透明，体验好
- 对开发者友好，逻辑清晰
- 安全性高，数据不会泄露
```

**🔹 部门权限的设计精髓**
```
核心是部门路径(path)设计：
/1/        总公司
/1/2/      销售部  
/1/2/4/    华北区

查询时用 LIKE '/1/2/%' 就能找到销售部下的所有子部门
这是树形结构权限控制的经典方案
```

### 6.3 实际应用价值


**💼 企业级应用场景**
- **ERP系统**：不同部门看不同的业务数据
- **CRM系统**：销售只看自己客户，主管看团队客户
- **OA系统**：审批流程中的数据可见性控制
- **财务系统**：按部门、按权限查看财务报表

**🔧 技术实现要点**
- **性能考虑**：权限条件要能用上数据库索引
- **安全考虑**：权限判断逻辑要在后端，不能只在前端
- **维护考虑**：权限配置要灵活，支持可视化管理
- **扩展考虑**：要支持复杂的权限组合和自定义规则

**核心记忆口诀**：
```
数据权限控范围，行级过滤是关键
部门树形路径巧，SQL条件把关严  
功能数据要结合，完整权限才安全
```

**⚠️ 重要提醒**
- 数据权限一定要在后端实现，前端隐藏只是用户体验优化
- SQL注入风险要特别注意，权限条件的拼接要做好防护
- 权限设计要考虑性能，避免复杂查询影响系统响应速度
- 权限变更要有审计日志，记录谁在什么时候修改了权限配置