---
title: 9、RBAC前端权限控制
---
## 📚 目录

1. [RBAC前端权限控制概述](#1-RBAC前端权限控制概述)
2. [前端路由权限控制](#2-前端路由权限控制)
3. [动态菜单渲染](#3-动态菜单渲染)
4. [按钮级权限控制](#4-按钮级权限控制)
5. [权限信息存储与刷新](#5-权限信息存储与刷新)
6. [前后端权限同步机制](#6-前后端权限同步机制)
7. [数据权限结合案例](#7-数据权限结合案例)
8. [企业级RBAC实现示例](#8-企业级RBAC实现示例)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 RBAC前端权限控制概述


### 1.1 什么是前端权限控制


**通俗解释**：前端权限控制就像是**门卫**，决定用户在网页上能看到什么、能点击什么、能访问哪些页面。

```
想象一个办公楼：
🏢 整栋楼 → 整个系统
🚪 不同楼层 → 不同页面/路由
🔘 各种按钮 → 操作权限（增删改查）
👮‍♂️ 门卫 → 前端权限控制
```

### 1.2 前端权限控制的核心作用


**🔸 用户体验优化**
- 只显示用户能用的功能，避免混乱
- 防止用户点击无权限的按钮后报错
- 提供清晰的操作界面

**🔸 安全第一道防线**
- 虽然不能完全依赖前端安全
- 但能防止普通用户的误操作
- 减少无效请求，提升系统性能

**🔸 业务逻辑清晰**
```
普通员工登录：
✅ 能看到：个人信息、工作报告
❌ 看不到：员工管理、薪资设置

管理员登录：
✅ 能看到：所有功能模块
✅ 能操作：所有管理功能
```

### 1.3 前端权限控制的层级


```
权限控制层级图：
┌─────────────────────────────┐
│ 🌐 页面/路由级别权限         │ ← 能否访问某个页面
├─────────────────────────────┤
│ 📋 菜单级别权限             │ ← 侧边栏显示哪些菜单
├─────────────────────────────┤
│ 🔘 按钮/操作级别权限         │ ← 能否进行增删改查
├─────────────────────────────┤
│ 📊 数据级别权限             │ ← 能看到哪些数据
└─────────────────────────────┘
```

---

## 2. 🛣️ 前端路由权限控制


### 2.1 什么是路由权限控制


**简单理解**：路由权限就是控制用户能访问网站的哪些页面，就像**楼层门禁卡**，有权限才能进入特定楼层。

### 2.2 Vue Router权限守卫实现


**🔸 全局前置守卫（最常用的方法）**

```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { getUserPermissions } from '@/utils/auth'

const routes = [
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('@/views/Dashboard.vue'),
    meta: { 
      requiresAuth: true,
      permissions: ['dashboard:view'] // 需要的权限
    }
  },
  {
    path: '/user-manage',
    name: 'UserManage', 
    component: () => import('@/views/UserManage.vue'),
    meta: { 
      requiresAuth: true,
      permissions: ['user:manage'] // 只有管理员能访问
    }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// 🚪 路由守卫 - 像门卫一样检查权限
router.beforeEach((to, from, next) => {
  // 获取用户权限信息
  const userPermissions = getUserPermissions()
  
  // 如果页面需要登录
  if (to.meta.requiresAuth) {
    if (!userPermissions || userPermissions.length === 0) {
      // 没登录，跳转到登录页
      next('/login')
      return
    }
    
    // 检查具体权限
    if (to.meta.permissions) {
      const hasPermission = to.meta.permissions.some(permission => 
        userPermissions.includes(permission)
      )
      
      if (!hasPermission) {
        // 没权限，跳转到403页面
        next('/403')
        return
      }
    }
  }
  
  next() // 通过检查，允许访问
})
```

**🔸 React Router权限守卫实现**

```jsx
// components/ProtectedRoute.jsx
import { Navigate } from 'react-router-dom'
import { useSelector } from 'react-redux'

function ProtectedRoute({ children, requiredPermissions }) {
  const userPermissions = useSelector(state => state.auth.permissions)
  
  // 检查是否有必需的权限
  const hasPermission = requiredPermissions?.every(permission => 
    userPermissions.includes(permission)
  )
  
  if (!hasPermission) {
    return <Navigate to="/403" replace />
  }
  
  return children
}

// App.js中使用
function App() {
  return (
    <Routes>
      <Route path="/dashboard" element={
        <ProtectedRoute requiredPermissions={['dashboard:view']}>
          <Dashboard />
        </ProtectedRoute>
      } />
      
      <Route path="/user-manage" element={
        <ProtectedRoute requiredPermissions={['user:manage']}>
          <UserManage />
        </ProtectedRoute>
      } />
    </Routes>
  )
}
```

### 2.3 路由权限的工作流程


```
用户访问页面的检查流程：

用户点击链接/输入URL
        ↓
   路由守卫拦截
        ↓
   检查是否需要登录？
   ├─ 不需要 → 直接放行
   └─ 需要 ↓
   检查用户是否已登录？
   ├─ 未登录 → 跳转登录页
   └─ 已登录 ↓
   检查是否有访问权限？
   ├─ 无权限 → 跳转403页面
   └─ 有权限 ↓
        正常访问页面
```

---

## 3. 📋 动态菜单渲染


### 3.1 什么是动态菜单


**通俗解释**：动态菜单就是根据用户的权限，**后端告诉前端**应该显示哪些菜单项。就像餐厅根据你是普通顾客还是VIP会员，给你看不同的菜单。

```
普通员工看到的菜单：          管理员看到的菜单：
├─ 📊 工作台                ├─ 📊 工作台
├─ 📝 我的任务              ├─ 📝 我的任务  
├─ 📋 工作报告              ├─ 📋 工作报告
└─ ⚙️ 个人设置              ├─ 👥 员工管理    ← 管理员专属
                           ├─ 🏢 部门管理    ← 管理员专属
                           ├─ 🔐 权限管理    ← 管理员专属
                           └─ ⚙️ 系统设置    ← 管理员专属
```

### 3.2 后端返回权限菜单数据


**🔸 后端API返回的菜单数据结构**

```javascript
// GET /api/user/menus - 后端返回当前用户的菜单
{
  "code": 200,
  "data": {
    "menus": [
      {
        "id": 1,
        "name": "工作台",
        "path": "/dashboard", 
        "icon": "dashboard",
        "children": []
      },
      {
        "id": 2,
        "name": "系统管理",
        "path": "/system",
        "icon": "system", 
        "children": [
          {
            "id": 21,
            "name": "用户管理",
            "path": "/system/users",
            "icon": "user"
          },
          {
            "id": 22, 
            "name": "角色管理",
            "path": "/system/roles",
            "icon": "role"
          }
        ]
      }
    ]
  }
}
```

### 3.3 Vue动态菜单渲染实现


**🔸 菜单组件实现**

```vue
<!-- components/SideMenu.vue -->
<template>
  <el-menu 
    :default-active="$route.path"
    class="side-menu"
    router
  >
    <menu-item 
      v-for="menu in userMenus" 
      :key="menu.id" 
      :menu="menu" 
    />
  </el-menu>
</template>

<script setup>
import { computed } from 'vue'
import { useStore } from 'vuex'
import MenuItem from './MenuItem.vue'

const store = useStore()

// 从状态管理中获取用户菜单
const userMenus = computed(() => store.getters.userMenus)
</script>
```

**🔸 递归菜单项组件**

```vue
<!-- components/MenuItem.vue -->
<template>
  <!-- 如果有子菜单，显示为子菜单 -->
  <el-sub-menu 
    v-if="menu.children && menu.children.length > 0" 
    :index="menu.path"
  >
    <template #title>
      <el-icon><component :is="menu.icon" /></el-icon>
      <span>{{ menu.name }}</span>
    </template>
    
    <!-- 递归渲染子菜单 -->
    <menu-item 
      v-for="child in menu.children" 
      :key="child.id" 
      :menu="child" 
    />
  </el-sub-menu>
  
  <!-- 没有子菜单，显示为普通菜单项 -->
  <el-menu-item v-else :index="menu.path">
    <el-icon><component :is="menu.icon" /></el-icon>
    <span>{{ menu.name }}</span>
  </el-menu-item>
</template>

<script setup>
defineProps({
  menu: {
    type: Object,
    required: true
  }
})
</script>
```

### 3.4 React动态菜单渲染实现


```jsx
// components/SideMenu.jsx
import { Menu } from 'antd'
import { useSelector } from 'react-redux'
import { useNavigate, useLocation } from 'react-router-dom'

function SideMenu() {
  const navigate = useNavigate()
  const location = useLocation()
  const userMenus = useSelector(state => state.auth.menus)
  
  // 递归构建菜单项
  const buildMenuItems = (menus) => {
    return menus.map(menu => {
      if (menu.children && menu.children.length > 0) {
        // 有子菜单
        return {
          key: menu.path,
          icon: menu.icon,
          label: menu.name,
          children: buildMenuItems(menu.children)
        }
      } else {
        // 普通菜单项
        return {
          key: menu.path,
          icon: menu.icon,
          label: menu.name
        }
      }
    })
  }
  
  const handleMenuClick = ({ key }) => {
    navigate(key)
  }
  
  return (
    <Menu
      mode="inline"
      selectedKeys={[location.pathname]}
      items={buildMenuItems(userMenus)}
      onClick={handleMenuClick}
    />
  )
}
```

---

## 4. 🔘 按钮级权限控制


### 4.1 什么是按钮级权限控制


**通俗解释**：按钮级权限就是控制页面上的**每个按钮**用户能不能看到、能不能点击。就像遥控器上的按钮，有些功能你有权限用，有些没有。

```
用户管理页面的按钮权限：

普通员工：
👀 只能查看用户列表
❌ 看不到：新增按钮、编辑按钮、删除按钮

部门经理： 
👀 能查看用户列表
✅ 能看到：新增按钮、编辑按钮
❌ 看不到：删除按钮

系统管理员：
👀 能查看用户列表  
✅ 能看到：新增按钮、编辑按钮、删除按钮
✅ 全部功能都可用
```

### 4.2 Vue按钮权限控制实现


**🔸 使用v-if指令控制显示**

```vue
<template>
  <div class="user-manage">
    <div class="toolbar">
      <!-- 只有有'user:add'权限的用户才能看到新增按钮 -->
      <el-button 
        v-if="hasPermission('user:add')"
        type="primary" 
        @click="handleAdd"
      >
        新增用户
      </el-button>
      
      <!-- 批量操作按钮 -->
      <el-button 
        v-if="hasPermission('user:delete')"
        type="danger" 
        @click="handleBatchDelete"
      >
        批量删除
      </el-button>
    </div>
    
    <!-- 用户列表表格 -->
    <el-table :data="users">
      <el-table-column prop="name" label="姓名" />
      <el-table-column prop="email" label="邮箱" />
      <el-table-column label="操作">
        <template #default="{ row }">
          <!-- 编辑按钮 -->
          <el-button 
            v-if="hasPermission('user:edit')"
            size="small" 
            @click="handleEdit(row)"
          >
            编辑
          </el-button>
          
          <!-- 删除按钮 -->
          <el-button 
            v-if="hasPermission('user:delete')"
            size="small" 
            type="danger" 
            @click="handleDelete(row)"
          >
            删除
          </el-button>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useStore } from 'vuex'

const store = useStore()

// 获取用户权限
const userPermissions = computed(() => store.getters.userPermissions)

// 检查权限的方法
const hasPermission = (permission) => {
  return userPermissions.value.includes(permission)
}
</script>
```

**🔸 自定义权限指令（更优雅的方式）**

```javascript
// directives/permission.js
export default {
  mounted(el, binding) {
    const { value: permission } = binding
    const userPermissions = store.getters.userPermissions
    
    if (!userPermissions.includes(permission)) {
      // 没有权限就移除这个元素
      el.parentNode && el.parentNode.removeChild(el)
    }
  }
}

// main.js中注册指令
app.directive('permission', permission)
```

```vue
<!-- 使用自定义指令 -->
<template>
  <div>
    <!-- 使用v-permission指令控制按钮显示 -->
    <el-button v-permission="'user:add'">新增用户</el-button>
    <el-button v-permission="'user:delete'">删除用户</el-button>
  </div>
</template>
```

### 4.3 React按钮权限控制实现


**🔸 权限组件封装**

```jsx
// components/PermissionButton.jsx
import { useSelector } from 'react-redux'

function PermissionButton({ 
  permission, 
  children, 
  fallback = null,
  ...props 
}) {
  const userPermissions = useSelector(state => state.auth.permissions)
  
  // 检查是否有权限
  const hasPermission = userPermissions.includes(permission)
  
  if (!hasPermission) {
    return fallback // 没权限返回备用内容（通常是null）
  }
  
  return <button {...props}>{children}</button>
}

// 使用示例
function UserManage() {
  return (
    <div>
      <div className="toolbar">
        <PermissionButton 
          permission="user:add"
          className="btn btn-primary"
          onClick={handleAdd}
        >
          新增用户
        </PermissionButton>
        
        <PermissionButton 
          permission="user:delete"
          className="btn btn-danger" 
          onClick={handleBatchDelete}
        >
          批量删除
        </PermissionButton>
      </div>
    </div>
  )
}
```

**🔸 通用权限Hook**

```jsx
// hooks/usePermission.js
import { useSelector } from 'react-redux'

export function usePermission() {
  const userPermissions = useSelector(state => state.auth.permissions)
  
  // 检查单个权限
  const hasPermission = (permission) => {
    return userPermissions.includes(permission)
  }
  
  // 检查多个权限（需要全部满足）
  const hasAllPermissions = (permissions) => {
    return permissions.every(permission => 
      userPermissions.includes(permission)
    )
  }
  
  // 检查多个权限（满足任一即可）
  const hasAnyPermission = (permissions) => {
    return permissions.some(permission => 
      userPermissions.includes(permission)
    )
  }
  
  return {
    hasPermission,
    hasAllPermissions, 
    hasAnyPermission
  }
}

// 在组件中使用
function UserManage() {
  const { hasPermission } = usePermission()
  
  return (
    <div>
      {hasPermission('user:add') && (
        <button onClick={handleAdd}>新增用户</button>
      )}
      
      {hasPermission('user:delete') && (
        <button onClick={handleDelete}>删除用户</button>
      )}
    </div>
  )
}
```

---

## 5. 💾 权限信息存储与刷新


### 5.1 权限信息存储方案


**通俗解释**：权限信息存储就是把用户的权限数据**记住**，这样用户在网站上操作时，系统随时知道他能干什么、不能干什么。

```
权限信息存储的位置：

🧠 内存中（Vuex/Redux）
├─ 优点：读取速度快
├─ 缺点：刷新页面就丢失
└─ 适合：临时存储，配合其他方式

💾 浏览器本地存储
├─ localStorage：长期存储，关闭浏览器不丢失
├─ sessionStorage：会话存储，关闭标签页就丢失  
└─ 适合：持久化权限信息

🍪 Cookie存储
├─ 优点：自动发送给服务器
├─ 缺点：大小限制，安全性相对较低
└─ 适合：简单的权限标识
```

### 5.2 Vuex权限状态管理


```javascript
// store/modules/auth.js
const state = {
  token: localStorage.getItem('token') || '',
  userInfo: JSON.parse(localStorage.getItem('userInfo') || '{}'),
  permissions: JSON.parse(localStorage.getItem('permissions') || '[]'),
  menus: JSON.parse(localStorage.getItem('menus') || '[]')
}

const mutations = {
  // 设置用户信息和权限
  SET_USER_INFO(state, userInfo) {
    state.userInfo = userInfo
    localStorage.setItem('userInfo', JSON.stringify(userInfo))
  },
  
  SET_PERMISSIONS(state, permissions) {
    state.permissions = permissions
    localStorage.setItem('permissions', JSON.stringify(permissions))
  },
  
  SET_MENUS(state, menus) {
    state.menus = menus  
    localStorage.setItem('menus', JSON.stringify(menus))
  },
  
  // 清除所有权限信息（退出登录时）
  CLEAR_AUTH(state) {
    state.token = ''
    state.userInfo = {}
    state.permissions = []
    state.menus = []
    localStorage.removeItem('token')
    localStorage.removeItem('userInfo')
    localStorage.removeItem('permissions')
    localStorage.removeItem('menus')
  }
}

const actions = {
  // 登录并获取权限信息
  async login({ commit }, loginForm) {
    try {
      const { data } = await loginAPI(loginForm)
      
      // 保存token
      commit('SET_TOKEN', data.token)
      
      // 获取用户信息和权限
      await this.dispatch('auth/getUserInfo')
    } catch (error) {
      console.error('登录失败:', error)
      throw error
    }
  },
  
  // 获取用户信息和权限
  async getUserInfo({ commit }) {
    try {
      // 获取用户基本信息
      const userRes = await getUserInfoAPI()
      commit('SET_USER_INFO', userRes.data)
      
      // 获取用户权限
      const permRes = await getUserPermissionsAPI()  
      commit('SET_PERMISSIONS', permRes.data.permissions)
      
      // 获取用户菜单
      const menuRes = await getUserMenusAPI()
      commit('SET_MENUS', menuRes.data.menus)
      
    } catch (error) {
      console.error('获取用户信息失败:', error)
    }
  },
  
  // 退出登录
  logout({ commit }) {
    commit('CLEAR_AUTH')
    // 跳转到登录页
    router.push('/login')
  }
}

const getters = {
  isLoggedIn: state => !!state.token,
  userPermissions: state => state.permissions,
  userMenus: state => state.menus,
  hasPermission: (state) => (permission) => {
    return state.permissions.includes(permission)
  }
}
```

### 5.3 Redux权限状态管理


```javascript
// store/authSlice.js
import { createSlice } from '@reduxjs/toolkit'

const authSlice = createSlice({
  name: 'auth',
  initialState: {
    token: localStorage.getItem('token') || '',
    userInfo: JSON.parse(localStorage.getItem('userInfo') || '{}'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]'),
    menus: JSON.parse(localStorage.getItem('menus') || '[]')
  },
  reducers: {
    setAuth: (state, action) => {
      const { token, userInfo, permissions, menus } = action.payload
      
      state.token = token
      state.userInfo = userInfo  
      state.permissions = permissions
      state.menus = menus
      
      // 同步到localStorage
      localStorage.setItem('token', token)
      localStorage.setItem('userInfo', JSON.stringify(userInfo))
      localStorage.setItem('permissions', JSON.stringify(permissions))
      localStorage.setItem('menus', JSON.stringify(menus))
    },
    
    clearAuth: (state) => {
      state.token = ''
      state.userInfo = {}
      state.permissions = []
      state.menus = []
      
      localStorage.removeItem('token')
      localStorage.removeItem('userInfo') 
      localStorage.removeItem('permissions')
      localStorage.removeItem('menus')
    }
  }
})

export const { setAuth, clearAuth } = authSlice.actions
export default authSlice.reducer
```

### 5.4 权限信息刷新机制


**🔸 页面刷新时权限恢复**

```javascript
// 在应用启动时恢复权限信息
// main.js
import { createApp } from 'vue'
import store from './store'

const app = createApp(App)

// 页面刷新时，从localStorage恢复权限信息
if (store.getters.isLoggedIn) {
  // 重新获取最新的权限信息
  store.dispatch('auth/getUserInfo')
}

app.use(store).mount('#app')
```

**🔸 权限变化时实时更新**

```javascript
// 权限变化监听（比如管理员修改了用户权限）
const setupPermissionRefresh = () => {
  // 定时检查权限是否有变化
  setInterval(async () => {
    try {
      const res = await checkPermissionUpdateAPI()
      if (res.data.hasUpdate) {
        // 权限有更新，重新获取
        store.dispatch('auth/getUserInfo')
        ElMessage.success('权限已更新')
      }
    } catch (error) {
      console.error('检查权限更新失败:', error)
    }
  }, 5 * 60 * 1000) // 5分钟检查一次
}
```

---

## 6. 🔄 前后端权限同步机制


### 6.1 为什么需要权限同步


**通俗解释**：前后端权限同步就像**门卫和保安的配合**，前端门卫负责第一道检查，后端保安负责最终验证，两者必须信息一致。

```
权限不同步的问题：

❌ 前端显示了按钮，但后端拒绝操作
❌ 前端隐藏了功能，但用户直接调用API成功了  
❌ 管理员修改权限后，用户前端没有及时更新

✅ 同步后的效果：
✅ 前后端权限完全一致
✅ 权限修改后实时生效
✅ 用户体验流畅，操作结果可预期
```

### 6.2 权限同步的实现方式


**🔸 定期同步机制**

```javascript
// utils/permissionSync.js
class PermissionSync {
  constructor(store) {
    this.store = store
    this.syncInterval = null
    this.lastSyncTime = null
  }
  
  // 开始定期同步
  startSync(interval = 5 * 60 * 1000) { // 默认5分钟
    this.syncInterval = setInterval(() => {
      this.syncPermissions()
    }, interval)
  }
  
  // 同步权限信息
  async syncPermissions() {
    try {
      // 获取服务器时间戳，检查是否有更新
      const res = await checkPermissionVersionAPI()
      
      if (!this.lastSyncTime || res.data.updateTime > this.lastSyncTime) {
        // 有更新，重新获取权限
        await this.store.dispatch('auth/getUserInfo')
        this.lastSyncTime = res.data.updateTime
        
        console.log('权限信息已同步')
      }
    } catch (error) {
      console.error('权限同步失败:', error)
    }
  }
  
  // 停止同步
  stopSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval)
      this.syncInterval = null
    }
  }
}

// 在应用中使用
const permissionSync = new PermissionSync(store)
permissionSync.startSync()
```

**🔸 WebSocket实时同步**

```javascript
// utils/websocket.js
class PermissionWebSocket {
  constructor(store) {
    this.store = store
    this.ws = null
  }
  
  connect() {
    const token = this.store.getters.token
    this.ws = new WebSocket(`ws://localhost:8080/ws?token=${token}`)
    
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data)
      
      if (message.type === 'PERMISSION_UPDATE') {
        // 权限更新通知
        this.handlePermissionUpdate(message.data)
      }
    }
    
    this.ws.onclose = () => {
      // 连接断开，尝试重连
      setTimeout(() => this.connect(), 3000)
    }
  }
  
  async handlePermissionUpdate(data) {
    // 权限有变化，重新获取
    await this.store.dispatch('auth/getUserInfo')
    
    // 通知用户权限已更新
    ElNotification({
      title: '权限更新',
      message: '您的权限已更新，请注意功能变化',
      type: 'info'
    })
  }
}
```

### 6.3 API请求权限验证


**🔸 请求拦截器统一处理**

```javascript
// utils/request.js
import axios from 'axios'
import { ElMessage } from 'element-plus'
import store from '@/store'
import router from '@/router'

const service = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL,
  timeout: 5000
})

// 请求拦截器 - 添加权限信息
service.interceptors.request.use(
  config => {
    const token = store.getters.token
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// 响应拦截器 - 处理权限错误
service.interceptors.response.use(
  response => {
    return response
  },
  error => {
    if (error.response) {
      switch (error.response.status) {
        case 401:
          // 未登录或token过期
          ElMessage.error('登录已过期，请重新登录')
          store.dispatch('auth/logout')
          router.push('/login')
          break
          
        case 403:
          // 无权限
          ElMessage.error('没有权限执行此操作')
          break
          
        case 423:
          // 权限已变化，需要重新获取
          ElMessage.warning('权限已更新，正在刷新...')
          store.dispatch('auth/getUserInfo').then(() => {
            location.reload() // 刷新页面
          })
          break
      }
    }
    return Promise.reject(error)
  }
)
```

---

## 7. 📊 数据权限结合案例


### 7.1 什么是数据权限


**通俗解释**：数据权限不仅控制用户能不能操作，还控制用户能看到哪些**具体的数据**。就像公司里，你只能看到自己部门的员工信息，看不到其他部门的。

```
数据权限的层级：

全部数据权限：     部门数据权限：     个人数据权限：
├─ 所有部门       ├─ 只看本部门     ├─ 只看自己的
├─ 所有员工       ├─ 本部门员工     ├─ 个人信息
└─ 所有项目       └─ 本部门项目     └─ 参与的项目

总经理 → 全部      部门经理 → 部门    普通员工 → 个人
```

### 7.2 前端数据权限处理


**🔸 列表数据权限过滤**

```vue
<!-- 员工管理页面 -->
<template>
  <div class="employee-manage">
    <!-- 搜索条件 -->
    <div class="search-form">
      <el-form inline>
        <el-form-item label="部门">
          <el-select v-model="searchForm.deptId">
            <!-- 根据数据权限显示可选部门 -->
            <el-option 
              v-for="dept in availableDepts" 
              :key="dept.id" 
              :label="dept.name" 
              :value="dept.id" 
            />
          </el-select>
        </el-form-item>
        
        <el-form-item>
          <el-button @click="handleSearch">搜索</el-button>
        </el-form-item>
      </el-form>
    </div>
    
    <!-- 员工列表 -->
    <el-table :data="employeeList">
      <el-table-column prop="name" label="姓名" />
      <el-table-column prop="dept" label="部门" />
      <el-table-column prop="position" label="职位" />
      
      <!-- 薪资列表 - 只有HR和高管能看到 -->
      <el-table-column 
        v-if="hasPermission('salary:view')" 
        prop="salary" 
        label="薪资" 
      />
      
      <el-table-column label="操作">
        <template #default="{ row }">
          <!-- 编辑按钮 - 根据数据权限判断 -->
          <el-button 
            v-if="canEdit(row)"
            size="small"
            @click="handleEdit(row)"
          >
            编辑
          </el-button>
          
          <!-- 删除按钮 -->
          <el-button 
            v-if="canDelete(row)"
            size="small" 
            type="danger"
            @click="handleDelete(row)"
          >
            删除  
          </el-button>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useStore } from 'vuex'

const store = useStore()
const employeeList = ref([])
const searchForm = ref({ deptId: '' })

// 获取用户的数据权限范围
const userDataScope = computed(() => store.getters.userDataScope)
const userDeptId = computed(() => store.getters.userInfo.deptId)
const userId = computed(() => store.getters.userInfo.id)

// 根据数据权限获取可选部门
const availableDepts = computed(() => {
  const allDepts = store.getters.allDepts
  
  switch (userDataScope.value) {
    case 'ALL':
      return allDepts // 全部部门
    case 'DEPT':
      return allDepts.filter(dept => dept.id === userDeptId.value) // 本部门
    case 'SELF':
      return [] // 个人权限不需要选择部门
    default:
      return []
  }
})

// 判断是否能编辑某个员工
const canEdit = (employee) => {
  if (!hasPermission('employee:edit')) {
    return false
  }
  
  switch (userDataScope.value) {
    case 'ALL':
      return true // 全部权限
    case 'DEPT': 
      return employee.deptId === userDeptId.value // 同部门
    case 'SELF':
      return employee.id === userId.value // 只能编辑自己
    default:
      return false
  }
}

// 判断是否能删除某个员工  
const canDelete = (employee) => {
  return hasPermission('employee:delete') && canEdit(employee)
}

// 搜索员工
const handleSearch = async () => {
  try {
    // 根据数据权限范围发送不同的请求参数
    const params = { ...searchForm.value }
    
    // 后端会根据用户的数据权限返回对应范围的数据
    const res = await getEmployeeListAPI(params)
    employeeList.value = res.data.list
  } catch (error) {
    console.error('搜索失败:', error)
  }
}
</script>
```

### 7.3 后端数据权限配合


**🔸 后端返回的用户权限信息**

```javascript
// 用户登录后，后端返回权限信息
{
  "userInfo": {
    "id": 123,
    "name": "张三",
    "deptId": 10, 
    "roleIds": [2]
  },
  "permissions": [
    "employee:view",
    "employee:edit" 
  ],
  "dataScope": "DEPT", // 数据权限范围
  "deptIds": [10], // 能访问的部门ID列表
  "menus": [...] 
}
```

**🔸 前端请求时携带权限标识**

```javascript
// API请求时，后端会自动根据用户身份过滤数据
const getEmployeeListAPI = (params) => {
  return request({
    url: '/api/employees',
    method: 'get',
    params
    // 请求头中的token已包含用户身份信息
    // 后端会根据用户的dataScope自动过滤返回的数据
  })
}

// 后端处理逻辑（示例）：
// 1. 从token中解析用户信息
// 2. 根据用户的dataScope决定查询条件
// 3. 返回用户有权限查看的数据
```

---

## 8. 🏢 企业级RBAC实现示例


### 8.1 完整的权限管理架构


```
企业级权限管理系统架构：

┌─────────────────────────────────────┐
│ 🌐 前端权限控制层                    │
├─────────────────────────────────────┤
│ ├─ 路由守卫（页面访问控制）          │
│ ├─ 菜单渲染（动态菜单显示）          │  
│ ├─ 按钮权限（功能操作控制）          │
│ └─ 数据权限（数据范围控制）          │
├─────────────────────────────────────┤
│ 🔄 权限同步机制                     │
├─────────────────────────────────────┤
│ ├─ 定时同步（5分钟检查一次）         │
│ ├─ 实时推送（WebSocket通知）         │
│ └─ 手动刷新（用户主动更新）          │
├─────────────────────────────────────┤
│ 💾 状态管理层                       │
├─────────────────────────────────────┤
│ ├─ Vuex/Redux（内存状态）            │
│ ├─ localStorage（持久化存储）        │
│ └─ Session管理（会话控制）           │
├─────────────────────────────────────┤
│ 🔐 后端权限验证                     │
└─────────────────────────────────────┘
```

### 8.2 企业后台管理系统示例


**🔸 主应用入口配置**

```vue
<!-- App.vue -->
<template>
  <div id="app">
    <!-- 登录页面 -->
    <LoginPage v-if="!isLoggedIn" />
    
    <!-- 主应用界面 -->
    <MainLayout v-else>
      <!-- 顶部导航 -->
      <template #header>
        <TopNavbar />
      </template>
      
      <!-- 侧边菜单 -->
      <template #aside>
        <SideMenu />
      </template>
      
      <!-- 主内容区 -->
      <template #main>
        <router-view />
      </template>
    </MainLayout>
  </div>
</template>

<script setup>
import { computed, onMounted } from 'vue'
import { useStore } from 'vuex'

const store = useStore()
const isLoggedIn = computed(() => store.getters.isLoggedIn)

// 应用启动时初始化权限
onMounted(async () => {
  if (isLoggedIn.value) {
    try {
      // 恢复用户权限信息
      await store.dispatch('auth/getUserInfo')
    } catch (error) {
      // 权限获取失败，可能token过期
      store.dispatch('auth/logout')
    }
  }
})
</script>
```

**🔸 权限管理页面实现**

```vue
<!-- views/system/PermissionManage.vue -->
<template>
  <div class="permission-manage">
    <div class="page-header">
      <h2>权限管理</h2>
      <el-button 
        v-if="hasPermission('permission:add')"
        type="primary" 
        @click="handleAdd"
      >
        新增权限
      </el-button>
    </div>
    
    <!-- 权限树形表格 -->
    <el-table 
      :data="permissionTree" 
      row-key="id"
      default-expand-all
      tree-props="{ children: 'children' }"
    >
      <el-table-column prop="name" label="权限名称" />
      <el-table-column prop="code" label="权限标识" />
      <el-table-column prop="type" label="权限类型">
        <template #default="{ row }">
          <el-tag :type="getTypeColor(row.type)">
            {{ getTypeName(row.type) }}
          </el-tag>
        </template>
      </el-table-column>
      
      <el-table-column label="操作">
        <template #default="{ row }">
          <el-button 
            v-if="hasPermission('permission:edit')"
            size="small" 
            @click="handleEdit(row)"
          >
            编辑
          </el-button>
          
          <el-button 
            v-if="hasPermission('permission:delete')"
            size="small" 
            type="danger" 
            @click="handleDelete(row)"
          >
            删除
          </el-button>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- 权限编辑对话框 -->
    <PermissionDialog 
      v-model:visible="dialogVisible"
      :permission-data="currentPermission"
      @success="handleSuccess"
    />
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { usePermission } from '@/hooks/usePermission'
import PermissionDialog from './components/PermissionDialog.vue'

const { hasPermission } = usePermission()
const permissionTree = ref([])
const dialogVisible = ref(false)
const currentPermission = ref(null)

// 权限类型映射
const typeMap = {
  'MENU': '菜单',
  'BUTTON': '按钮', 
  'DATA': '数据'
}

const typeColorMap = {
  'MENU': 'primary',
  'BUTTON': 'success',
  'DATA': 'warning'
}

const getTypeName = (type) => typeMap[type] || type
const getTypeColor = (type) => typeColorMap[type] || 'default'

// 获取权限列表
const fetchPermissions = async () => {
  try {
    const res = await getPermissionTreeAPI()
    permissionTree.value = res.data
  } catch (error) {
    ElMessage.error('获取权限列表失败')
  }
}

// 新增权限
const handleAdd = () => {
  currentPermission.value = null
  dialogVisible.value = true
}

// 编辑权限
const handleEdit = (permission) => {
  currentPermission.value = { ...permission }
  dialogVisible.value = true
}

// 删除权限
const handleDelete = async (permission) => {
  try {
    await ElMessageBox.confirm('确定删除此权限吗？', '提示')
    
    await deletePermissionAPI(permission.id)
    ElMessage.success('删除成功')
    
    fetchPermissions() // 刷新列表
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('删除失败')
    }
  }
}

// 操作成功回调
const handleSuccess = () => {
  dialogVisible.value = false
  fetchPermissions()
}

onMounted(() => {
  fetchPermissions()
})
</script>
```

### 8.3 角色权限分配实现


```vue
<!-- views/system/RolePermission.vue -->
<template>
  <div class="role-permission">
    <el-row :gutter="20">
      <!-- 角色列表 -->
      <el-col :span="8">
        <el-card title="角色列表">
          <el-list>
            <el-list-item 
              v-for="role in roleList" 
              :key="role.id"
              :class="{ active: currentRoleId === role.id }"
              @click="selectRole(role)"
            >
              <div class="role-item">
                <div class="role-name">{{ role.name }}</div>
                <div class="role-desc">{{ role.description }}</div>
              </div>
            </el-list-item>
          </el-list>
        </el-card>
      </el-col>
      
      <!-- 权限分配 -->
      <el-col :span="16">
        <el-card title="权限分配">
          <div v-if="currentRoleId">
            <div class="toolbar">
              <el-button 
                type="primary" 
                @click="handleSavePermissions"
                :loading="saving"
              >
                保存权限
              </el-button>
            </div>
            
            <!-- 权限树 -->
            <el-tree
              ref="permissionTreeRef"
              :data="permissionTree"
              :props="treeProps"
              show-checkbox
              node-key="id" 
              :default-checked-keys="rolePermissions"
            />
          </div>
          
          <el-empty v-else description="请选择角色" />
        </el-card>
      </el-col>
    </el-row>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const roleList = ref([])
const permissionTree = ref([])
const currentRoleId = ref(null)
const rolePermissions = ref([])
const permissionTreeRef = ref(null)
const saving = ref(false)

const treeProps = {
  children: 'children',
  label: 'name'
}

// 选择角色
const selectRole = async (role) => {
  currentRoleId.value = role.id
  
  // 获取角色的权限
  try {
    const res = await getRolePermissionsAPI(role.id)
    rolePermissions.value = res.data.permissionIds
    
    // 设置树的选中状态
    permissionTreeRef.value.setCheckedKeys(rolePermissions.value)
  } catch (error) {
    ElMessage.error('获取角色权限失败')
  }
}

// 保存权限分配
const handleSavePermissions = async () => {
  if (!currentRoleId.value) return
  
  saving.value = true
  
  try {
    // 获取选中的权限ID
    const checkedKeys = permissionTreeRef.value.getCheckedKeys()
    const halfCheckedKeys = permissionTreeRef.value.getHalfCheckedKeys()
    const permissionIds = [...checkedKeys, ...halfCheckedKeys]
    
    await assignRolePermissionsAPI({
      roleId: currentRoleId.value,
      permissionIds
    })
    
    ElMessage.success('权限分配成功')
  } catch (error) {
    ElMessage.error('权限分配失败')
  } finally {
    saving.value = false
  }
}

onMounted(async () => {
  // 获取角色列表和权限树
  try {
    const [roleRes, permRes] = await Promise.all([
      getRoleListAPI(),
      getPermissionTreeAPI()
    ])
    
    roleList.value = roleRes.data
    permissionTree.value = permRes.data
  } catch (error) {
    ElMessage.error('数据加载失败')
  }
})
</script>

<style scoped>
.role-item {
  cursor: pointer;
  padding: 10px;
  border-radius: 4px;
  transition: background-color 0.3s;
}

.role-item:hover {
  background-color: #f5f7fa;
}

.active .role-item {
  background-color: #e6f7ff;
  border: 1px solid #1890ff;
}

.role-name {
  font-weight: 500;
  margin-bottom: 4px;
}

.role-desc {
  font-size: 12px;
  color: #666;
}

.toolbar {
  margin-bottom: 20px;
}
</style>
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 前端权限控制本质：用户体验优化 + 安全第一道防线
🔸 权限控制层级：页面级 → 菜单级 → 按钮级 → 数据级
🔸 实现技术栈：路由守卫 + 动态菜单 + 指令控制 + 状态管理
🔸 同步机制：定时同步 + WebSocket推送 + 请求拦截
🔸 存储方案：内存状态 + 本地存储 + 服务端权限
```

### 9.2 关键理解要点


**🔹 前端权限的作用和局限**
```
✅ 作用：
- 优化用户体验，只显示有用的功能
- 减少无效请求，提升系统性能  
- 提供清晰的操作界面

❌ 局限：
- 不能作为唯一的安全防护
- 可以被绕过（直接调用API）
- 必须配合后端权限验证
```

**🔹 权限控制的最佳实践**
```
前端显示控制：
- 使用v-if/v-show控制组件显示
- 用指令简化权限判断逻辑
- 动态路由配合静态路由

状态管理：
- Vuex/Redux统一管理权限状态
- localStorage持久化存储
- 页面刷新时自动恢复权限

同步机制：
- 定期检查权限更新
- WebSocket实时推送变化
- API请求失败时重新获取权限
```

**🔹 数据权限的处理思路**
```
权限范围划分：
- 全部数据：超级管理员
- 部门数据：部门经理
- 个人数据：普通员工

前端处理：
- 根据权限范围显示不同的搜索条件
- 根据数据权限决定操作按钮的显示
- 列表渲染时考虑敏感信息的隐藏

后端配合：
- 根据用户身份自动过滤数据
- 返回权限范围信息给前端
- API层面的权限验证
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **企业管理系统**：员工、部门、权限的分层管理
- **电商后台**：商家、运营、客服的权限区分
- **内容管理系统**：编辑、审核、发布的流程控制
- **财务系统**：查看、审批、操作权限的严格控制

**🔧 开发实践**
- **组件化设计**：权限组件、指令的封装复用
- **状态管理**：权限信息的集中管理和同步
- **错误处理**：权限异常的友好提示和处理
- **性能优化**：权限检查的缓存和优化

**💡 设计原则**
```
用户体验优先：
- 不让用户看到用不了的功能
- 权限不足时给出明确提示
- 操作流程要符合业务逻辑

安全性考虑：
- 前端权限不能作为唯一防护
- 敏感操作必须后端二次验证  
- 权限变更要及时同步生效

可维护性：
- 权限逻辑集中管理
- 权限配置与业务代码分离
- 权限变更要便于测试验证
```

**核心记忆口诀**：
- 前端权限重体验，后端验证保安全
- 路由菜单按钮控，数据权限要细分  
- 状态管理要集中，同步机制保一致
- 指令组件来封装，维护升级都方便