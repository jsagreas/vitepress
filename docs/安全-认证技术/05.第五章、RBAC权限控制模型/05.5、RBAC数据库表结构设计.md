---
title: 5、RBAC数据库表结构设计
---
## 📚 目录

1. [RBAC模型核心概念](#1-RBAC模型核心概念)
2. [数据库表结构设计](#2-数据库表结构设计)
3. [核心表详细设计](#3-核心表详细设计)
4. [关联表设计原理](#4-关联表设计原理)
5. [字段设计规范](#5-字段设计规范)
6. [数据库范式与索引优化](#6-数据库范式与索引优化)
7. [唯一约束与外键关系](#7-唯一约束与外键关系)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 RBAC模型核心概念


### 1.1 什么是RBAC

**RBAC**（Role-Based Access Control）叫做**基于角色的访问控制**，简单说就是：

> 💡 **通俗理解**：就像公司里不同职位的人有不同的权限
> - 总经理：可以查看所有数据，批准所有申请
> - 部门经理：只能管理自己部门的事
> - 普通员工：只能处理自己的工作

### 1.2 RBAC的三个核心要素

```
👤 用户 (User)        →  张三、李四、王五
👔 角色 (Role)        →  管理员、编辑、查看者  
🔑 权限 (Permission)  →  增删改查、审批、导出
```

### 1.3 RBAC工作原理

```
传统方式：
👤 用户 ←直接关联→ 🔑 权限  (一个用户对应N个权限，复杂！)

RBAC方式：
👤 用户 ←→ 👔 角色 ←→ 🔑 权限  (通过角色做中间层，简单！)
```

**为什么要用角色做中间层？**
- ✅ **管理简单**：给用户分配角色，比直接分配权限简单得多
- ✅ **批量操作**：一个角色可以给很多用户用
- ✅ **权限变更**：修改角色权限，所有该角色用户自动生效
- ✅ **职责清晰**：角色对应现实中的职位，好理解

---

## 2. 🗃️ 数据库表结构设计


### 2.1 RBAC的五张核心表

```
📊 RBAC数据库表结构全览

核心表（3张）：
├── 👤 user（用户表）
├── 👔 role（角色表）  
└── 🔑 permission（权限表）

关联表（2张）：
├── 👤👔 user_role（用户-角色关联表）
└── 👔🔑 role_permission（角色-权限关联表）
```

### 2.2 表与表的关系图

```
       用户表                    角色表                    权限表
    ┌─────────┐              ┌─────────┐              ┌─────────┐
    │   user  │              │   role  │              │permission│
    │         │              │         │              │         │
    │ user_id │              │ role_id │              │ perm_id │
    │username │              │role_name│              │perm_name│
    │password │              │   ...   │              │   ...   │
    └─────────┘              └─────────┘              └─────────┘
         │                        │                        │
         │                        │                        │
         └──────┐          ┌──────┴──────┐          ┌──────┘
                │          │             │          │
         ┌─────────────┐   │   ┌─────────────────┐  │
         │  user_role  │   │   │ role_permission │  │
         │             │   │   │                 │  │
         │   user_id   │───┘   │    role_id      │──┘
         │   role_id   │───────│    perm_id      │
         └─────────────┘       └─────────────────┘
```

**关系说明**：
- 👤 **用户** 和 👔 **角色**：多对多关系（一个用户可以有多个角色，一个角色可以给多个用户）
- 👔 **角色** 和 🔑 **权限**：多对多关系（一个角色可以有多个权限，一个权限可以给多个角色）

---

## 3. 📋 核心表详细设计


### 3.1 用户表（user）设计

```sql
CREATE TABLE `user` (
  `user_id` bigint PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
  `username` varchar(50) UNIQUE NOT NULL COMMENT '用户名',
  `password` varchar(255) NOT NULL COMMENT '密码（加密存储）',
  `email` varchar(100) UNIQUE COMMENT '邮箱',
  `phone` varchar(20) COMMENT '手机号',
  `real_name` varchar(50) COMMENT '真实姓名',
  `avatar` varchar(255) COMMENT '头像URL',
  `status` tinyint DEFAULT 1 COMMENT '状态：1=启用，0=禁用',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  
  INDEX idx_username (`username`),
  INDEX idx_email (`email`),
  INDEX idx_status (`status`),
  INDEX idx_create_time (`create_time`)
) COMMENT='用户表';
```

**字段详解**：
- 🔑 `user_id`：主键，用数字而不用UUID，查询快
- 📝 `username`：用户名，设置唯一约束，不能重复
- 🔒 `password`：密码，必须加密存储（如BCrypt）
- 📧 `email`：邮箱，也要唯一，用于找回密码
- 📱 `phone`：手机号，可选字段
- 👥 `status`：状态字段，1启用0禁用，软删除思想

### 3.2 角色表（role）设计

```sql
CREATE TABLE `role` (
  `role_id` bigint PRIMARY KEY AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(50) UNIQUE NOT NULL COMMENT '角色名称',
  `role_code` varchar(50) UNIQUE NOT NULL COMMENT '角色编码',
  `description` varchar(255) COMMENT '角色描述',
  `status` tinyint DEFAULT 1 COMMENT '状态：1=启用，0=禁用',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  
  INDEX idx_role_name (`role_name`),
  INDEX idx_role_code (`role_code`),
  INDEX idx_status (`status`)
) COMMENT='角色表';
```

**字段详解**：
- 🏷️ `role_name`：角色名称，给人看的，如"系统管理员"
- 🔤 `role_code`：角色编码，给程序用的，如"ADMIN"、"USER"
- 📝 `description`：角色描述，说明这个角色是干什么的

### 3.3 权限表（permission）设计

```sql
CREATE TABLE `permission` (
  `perm_id` bigint PRIMARY KEY AUTO_INCREMENT COMMENT '权限ID',
  `perm_name` varchar(100) NOT NULL COMMENT '权限名称',
  `perm_code` varchar(100) UNIQUE NOT NULL COMMENT '权限编码',
  `perm_type` varchar(20) DEFAULT 'button' COMMENT '权限类型：menu=菜单，button=按钮',
  `parent_id` bigint DEFAULT 0 COMMENT '父权限ID，0表示顶级',
  `path` varchar(200) COMMENT '权限路径',
  `icon` varchar(100) COMMENT '图标',
  `sort_order` int DEFAULT 0 COMMENT '排序',
  `status` tinyint DEFAULT 1 COMMENT '状态：1=启用，0=禁用',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  
  UNIQUE KEY uk_perm_code (`perm_code`),
  INDEX idx_parent_id (`parent_id`),
  INDEX idx_perm_type (`perm_type`),
  INDEX idx_status (`status`)
) COMMENT='权限表';
```

**权限类型说明**：
```
🗂️ 菜单权限 (menu)：
   - 用户管理 (user:menu)
   - 角色管理 (role:menu)
   - 系统设置 (system:menu)

🔘 按钮权限 (button)：
   - 新增用户 (user:add)
   - 删除用户 (user:delete)
   - 修改用户 (user:edit)
   - 查询用户 (user:view)
```

---

## 4. 🔗 关联表设计原理


### 4.1 为什么需要关联表？

**问题**：如果直接在用户表里存储角色信息会怎样？

❌ **错误设计**：
```sql
-- 这样设计是错误的！
CREATE TABLE `user` (
  `user_id` bigint PRIMARY KEY,
  `username` varchar(50),
  `roles` varchar(500) -- 存储角色ID，如"1,2,3"
);
```

**问题所在**：
- 🚫 违反数据库第一范式（字段不可分割）
- 🚫 查询复杂（需要用LIKE或字符串函数）
- 🚫 维护困难（角色变更需要更新多个用户记录）
- 🚫 数据一致性差（容易出现脏数据）

### 4.2 用户-角色关联表（user_role）

```sql
CREATE TABLE `user_role` (
  `id` bigint PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `role_id` bigint NOT NULL COMMENT '角色ID',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '分配时间',
  `create_by` bigint COMMENT '分配人ID',
  
  UNIQUE KEY uk_user_role (`user_id`, `role_id`),
  INDEX idx_user_id (`user_id`),
  INDEX idx_role_id (`role_id`),
  FOREIGN KEY (`user_id`) REFERENCES `user`(`user_id`) ON DELETE CASCADE,
  FOREIGN KEY (`role_id`) REFERENCES `role`(`role_id`) ON DELETE CASCADE
) COMMENT='用户-角色关联表';
```

**设计要点**：
- 🔑 联合唯一约束 `uk_user_role`：防止同一用户重复分配相同角色
- 📊 独立索引：`user_id` 和 `role_id` 都要建索引，提高查询效率
- 🗑️ 级联删除：用户或角色删除时，自动删除关联关系

### 4.3 角色-权限关联表（role_permission）

```sql
CREATE TABLE `role_permission` (
  `id` bigint PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
  `role_id` bigint NOT NULL COMMENT '角色ID',
  `perm_id` bigint NOT NULL COMMENT '权限ID',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '分配时间',
  `create_by` bigint COMMENT '分配人ID',
  
  UNIQUE KEY uk_role_perm (`role_id`, `perm_id`),
  INDEX idx_role_id (`role_id`),
  INDEX idx_perm_id (`perm_id`),
  FOREIGN KEY (`role_id`) REFERENCES `role`(`role_id`) ON DELETE CASCADE,
  FOREIGN KEY (`perm_id`) REFERENCES `permission`(`perm_id`) ON DELETE CASCADE
) COMMENT='角色-权限关联表';
```

---

## 5. 📝 字段设计规范


### 5.1 主键设计规范

**✅ 推荐做法**：
```sql
-- 使用 bigint 自增主键
`user_id` bigint PRIMARY KEY AUTO_INCREMENT

-- 为什么用 bigint？
-- int 最大值：21亿（2^31-1）
-- bigint 最大值：900万万亿（2^63-1）
-- 确保永远不会主键用完
```

**❌ 不推荐做法**：
```sql
-- 不推荐用UUID做主键
`user_id` varchar(36) PRIMARY KEY -- UUID

-- 缺点：
-- 1. 存储空间大（36字节 vs 8字节）
-- 2. 查询性能差（字符串比较 vs 数字比较）  
-- 3. 索引效率低（随机UUID vs 自增数字）
```

### 5.2 唯一约束设计

```sql
-- 单字段唯一约束
`username` varchar(50) UNIQUE NOT NULL,
`email` varchar(100) UNIQUE,

-- 联合唯一约束
UNIQUE KEY uk_user_role (`user_id`, `role_id`)
```

**唯一约束的作用**：
- 🛡️ **数据完整性**：防止重复数据
- ⚡ **查询优化**：唯一约束会自动创建索引
- 🔍 **业务逻辑**：保证业务规则的唯一性

### 5.3 状态字段设计

```sql
-- 状态字段统一规范
`status` tinyint DEFAULT 1 COMMENT '状态：1=启用，0=禁用'

-- 为什么用 tinyint？
-- 占用空间小：1字节
-- 取值范围：-128 到 127 或 0 到 255
-- 适合存储状态枚举值
```

**状态值设计规范**：
```
📊 推荐的状态值设计：

启用/禁用状态：
1 = 启用 ✅
0 = 禁用 ❌

订单状态：
1 = 待付款 ⏳
2 = 已付款 💰  
3 = 已发货 🚚
4 = 已完成 ✅
5 = 已取消 ❌

审核状态：
1 = 待审核 ⏳
2 = 审核通过 ✅
3 = 审核拒绝 ❌
```

### 5.4 时间字段设计

```sql
-- 标准时间字段设计
`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
`update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'

-- 软删除时间字段（可选）
`delete_time` datetime NULL COMMENT '删除时间，NULL表示未删除'
```

---

## 6. 🎯 数据库范式与索引优化


### 6.1 数据库范式的应用

**第一范式（1NF）**：字段不可分割
```sql
-- ❌ 违反第一范式
CREATE TABLE user (
    user_id bigint,
    user_info varchar(500) -- "张三,男,25,北京" 这样存储违反1NF
);

-- ✅ 符合第一范式  
CREATE TABLE user (
    user_id bigint,
    name varchar(50),    -- 每个字段都是不可分割的
    gender char(1),
    age int,
    city varchar(50)
);
```

**第二范式（2NF）**：消除部分函数依赖
```sql
-- ❌ 违反第二范式
CREATE TABLE user_role_info (
    user_id bigint,
    role_id bigint,
    username varchar(50),    -- 只依赖user_id，不依赖role_id
    role_name varchar(50),   -- 只依赖role_id，不依赖user_id
    assign_time datetime
);

-- ✅ 符合第二范式（分解为多个表）
CREATE TABLE user (
    user_id bigint PRIMARY KEY,
    username varchar(50)
);

CREATE TABLE role (
    role_id bigint PRIMARY KEY, 
    role_name varchar(50)
);

CREATE TABLE user_role (
    user_id bigint,
    role_id bigint,
    assign_time datetime
);
```

### 6.2 索引设计原则

**✅ 需要建索引的字段**：
```sql
-- 1. 主键字段（自动建索引）
PRIMARY KEY (`user_id`)

-- 2. 唯一约束字段（自动建索引）  
UNIQUE KEY (`username`)

-- 3. 频繁作为WHERE条件的字段
INDEX idx_status (`status`)
INDEX idx_create_time (`create_time`)

-- 4. 外键字段
INDEX idx_user_id (`user_id`)
INDEX idx_role_id (`role_id`)

-- 5. 经常排序的字段
INDEX idx_sort_order (`sort_order`)
```

**❌ 不建议建索引的字段**：
- 🚫 很少用于查询条件的字段
- 🚫 频繁更新的字段（每次更新都要维护索引）
- 🚫 数据重复度很高的字段（如性别字段）
- 🚫 TEXT、BLOB等大字段

### 6.3 复合索引设计

```sql
-- 联合唯一约束（同时也是复合索引）
UNIQUE KEY uk_user_role (`user_id`, `role_id`)

-- 复合索引设计原则（最左前缀原则）
INDEX idx_user_status_time (`user_id`, `status`, `create_time`)

-- 可以利用的查询：
-- WHERE user_id = 1
-- WHERE user_id = 1 AND status = 1  
-- WHERE user_id = 1 AND status = 1 AND create_time > '2024-01-01'

-- 无法利用的查询：
-- WHERE status = 1
-- WHERE create_time > '2024-01-01'
```

---

## 7. 🔗 唯一约束与外键关系


### 7.1 唯一约束设计

**单字段唯一约束**：
```sql
-- 用户名唯一
`username` varchar(50) UNIQUE NOT NULL

-- 等同于
`username` varchar(50) NOT NULL,
UNIQUE KEY uk_username (`username`)
```

**联合唯一约束**：
```sql
-- 防止用户重复分配相同角色
UNIQUE KEY uk_user_role (`user_id`, `role_id`)

-- 防止角色重复分配相同权限
UNIQUE KEY uk_role_perm (`role_id`, `perm_id`)
```

**唯一约束的好处**：
- ✅ **数据一致性**：从数据库层面保证不会有重复数据
- ✅ **性能优化**：唯一约束会自动创建索引
- ✅ **错误提前发现**：插入重复数据时会立即报错

### 7.2 外键关系设计

```sql
-- 用户-角色关联表的外键
FOREIGN KEY (`user_id`) REFERENCES `user`(`user_id`) ON DELETE CASCADE,
FOREIGN KEY (`role_id`) REFERENCES `role`(`role_id`) ON DELETE CASCADE

-- 角色-权限关联表的外键  
FOREIGN KEY (`role_id`) REFERENCES `role`(`role_id`) ON DELETE CASCADE,
FOREIGN KEY (`perm_id`) REFERENCES `permission`(`perm_id`) ON DELETE CASCADE
```

**外键约束的作用**：
- 🛡️ **引用完整性**：确保子表记录引用的父表记录真实存在
- 🗑️ **级联操作**：父表记录删除时，自动删除相关子表记录
- 🚫 **防止孤儿记录**：不允许插入无效的外键值

**外键约束选项说明**：
```sql
-- ON DELETE CASCADE：父记录删除，子记录也删除
-- ON DELETE SET NULL：父记录删除，子记录外键设为NULL  
-- ON DELETE RESTRICT：有子记录存在时，不允许删除父记录
-- ON UPDATE CASCADE：父记录主键更新，子记录外键也更新
```

### 7.3 实际应用示例

**插入测试数据**：
```sql
-- 1. 插入用户
INSERT INTO `user` (`username`, `password`, `email`, `real_name`) VALUES
('admin', '$2a$10$...', 'admin@example.com', '系统管理员'),
('zhangsan', '$2a$10$...', 'zhang@example.com', '张三'),
('lisi', '$2a$10$...', 'li@example.com', '李四');

-- 2. 插入角色
INSERT INTO `role` (`role_name`, `role_code`, `description`) VALUES
('系统管理员', 'ADMIN', '拥有系统所有权限'),
('编辑员', 'EDITOR', '可以编辑内容'),
('查看员', 'VIEWER', '只能查看内容');

-- 3. 插入权限
INSERT INTO `permission` (`perm_name`, `perm_code`, `perm_type`) VALUES
('用户管理', 'user:menu', 'menu'),
('新增用户', 'user:add', 'button'),
('删除用户', 'user:delete', 'button'),
('查看用户', 'user:view', 'button');

-- 4. 分配角色给用户
INSERT INTO `user_role` (`user_id`, `role_id`) VALUES
(1, 1), -- admin用户分配管理员角色
(2, 2), -- zhangsan用户分配编辑员角色  
(3, 3); -- lisi用户分配查看员角色

-- 5. 分配权限给角色
INSERT INTO `role_permission` (`role_id`, `perm_id`) VALUES
(1, 1), (1, 2), (1, 3), (1, 4), -- 管理员拥有所有权限
(2, 1), (2, 2), (2, 4),         -- 编辑员拥有查看和新增权限
(3, 1), (3, 4);                 -- 查看员只有查看权限
```

**常用查询语句**：
```sql
-- 查询用户的所有角色
SELECT u.username, r.role_name 
FROM user u
JOIN user_role ur ON u.user_id = ur.user_id
JOIN role r ON ur.role_id = r.role_id
WHERE u.username = 'zhangsan';

-- 查询用户的所有权限  
SELECT DISTINCT u.username, p.perm_name, p.perm_code
FROM user u
JOIN user_role ur ON u.user_id = ur.user_id
JOIN role r ON ur.role_id = r.role_id  
JOIN role_permission rp ON r.role_id = rp.role_id
JOIN permission p ON rp.perm_id = p.perm_id
WHERE u.username = 'zhangsan';

-- 查询角色下的所有用户
SELECT r.role_name, u.username, u.real_name
FROM role r
JOIN user_role ur ON r.role_id = ur.role_id
JOIN user u ON ur.user_id = u.user_id
WHERE r.role_code = 'EDITOR';
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念

```
🔸 RBAC模型：用户-角色-权限的三层关系模型
🔸 五张核心表：user、role、permission、user_role、role_permission
🔸 多对多关系：通过中间表解决多对多关联问题
🔸 数据库设计：主键、唯一约束、外键、索引的正确使用
🔸 字段规范：状态字段、时间字段、编码字段的设计标准
```

### 8.2 关键设计原则

**🔹 表结构设计原则**
```
主键设计：使用bigint自增主键，性能最优
唯一约束：防重复数据，自动创建索引
外键约束：保证数据完整性，支持级联操作
状态字段：统一使用tinyint，1启用0禁用
时间字段：create_time创建时间，update_time更新时间
```

**🔹 索引设计原则**
```
必建索引：主键、唯一约束、外键、频繁查询字段
复合索引：遵循最左前缀原则，合理设计字段顺序
避免过度：不要在每个字段都建索引，影响写入性能
```

### 8.3 实际应用要点

- **权限检查流程**：用户登录 → 获取角色 → 获取权限 → 验证访问权
- **角色管理**：通过角色批量管理用户权限，而不是单个分配
- **权限粒度**：菜单权限控制页面访问，按钮权限控制操作权限
- **数据安全**：密码加密存储，状态字段控制账号启停

### 8.4 常见问题解答

❓ **为什么不直接给用户分配权限？**
> 答：角色是权限的集合，便于批量管理。如果直接分配，100个用户每人10个权限就是1000条记录，而通过角色可能只需要100条用户-角色记录。

❓ **user_role表为什么要单独的主键id？**  
> 答：虽然user_id+role_id已经唯一，但独立主键便于程序操作，也为将来扩展字段（如分配时间、分配人）提供便利。

❓ **权限编码perm_code如何设计？**
> 答：建议用"模块:操作"格式，如user:add、user:delete、order:view，便于程序中进行权限判断。

**核心记忆**：
- RBAC通过角色连接用户和权限，简化权限管理
- 五张表构成完整权限体系，表关系通过外键保证一致性  
- 字段设计遵循规范，主键、唯一约束、索引合理使用
- 数据库范式指导表结构，索引设计提升查询性能