---
title: 6、RBAC数据库SQL实现
---
## 📚 目录

1. [RBAC数据库设计概念](#1-rbac数据库设计概念)
2. [MySQL建表语句设计](#2-mysql建表语句设计)
3. [初始化基础数据](#3-初始化基础数据)
4. [多表关联查询实现](#4-多表关联查询实现)
5. [用户权限查询SQL](#5-用户权限查询sql)
6. [动态权限数据加载](#6-动态权限数据加载)
7. [实际应用示例](#7-实际应用示例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ RBAC数据库设计概念


### 1.1 什么是RBAC数据库实现


**通俗理解**：把RBAC权限控制模型用数据库表来存储和管理

```
生活场景类比：
公司权限管理 → 数据库RBAC
员工档案     → 用户表
职位信息     → 角色表  
工作权限     → 权限表
员工职位关系 → 用户角色关系表
职位权限关系 → 角色权限关系表
```

### 1.2 核心设计思想


**🔸 五张核心表**
```
用户表(users)           → 存储用户基本信息
角色表(roles)           → 存储角色信息
权限表(permissions)     → 存储权限信息
用户角色表(user_roles)  → 用户和角色的关联
角色权限表(role_permissions) → 角色和权限的关联
```

**🔸 关系设计原理**
```
用户 ←→ 角色：多对多关系（一个用户可以有多个角色）
角色 ←→ 权限：多对多关系（一个角色可以有多个权限）

实际查询流程：
用户ID → 查角色 → 查权限 → 得到用户最终权限
```

---

## 2. 🛠️ MySQL建表语句设计


### 2.1 用户表设计


**用户表(users)**：存储用户基本信息
```sql
-- 用户表：存储用户基本信息
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    password VARCHAR(255) NOT NULL COMMENT '密码',
    email VARCHAR(100) COMMENT '邮箱',
    real_name VARCHAR(50) COMMENT '真实姓名',
    phone VARCHAR(20) COMMENT '手机号',
    status TINYINT DEFAULT 1 COMMENT '状态：1-正常，0-禁用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT '用户表';
```

**字段含义解释**：
- `id`：用户唯一标识，主键自增
- `username`：登录用户名，必须唯一
- `password`：登录密码，通常加密存储
- `status`：账户状态，1表示正常，0表示禁用

### 2.2 角色表设计


**角色表(roles)**：存储角色信息
```sql
-- 角色表：存储角色信息
CREATE TABLE roles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    role_name VARCHAR(50) NOT NULL UNIQUE COMMENT '角色名称',
    role_code VARCHAR(50) NOT NULL UNIQUE COMMENT '角色编码',
    description TEXT COMMENT '角色描述',
    status TINYINT DEFAULT 1 COMMENT '状态：1-正常，0-禁用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT '角色表';
```

**字段含义解释**：
- `role_name`：角色显示名称，如"管理员"、"普通用户"
- `role_code`：角色编码，如"ADMIN"、"USER"，用于程序识别
- `description`：角色的详细说明

### 2.3 权限表设计


**权限表(permissions)**：存储权限信息
```sql
-- 权限表：存储权限信息
CREATE TABLE permissions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    permission_name VARCHAR(50) NOT NULL COMMENT '权限名称',
    permission_code VARCHAR(50) NOT NULL UNIQUE COMMENT '权限编码',
    resource_type VARCHAR(20) NOT NULL COMMENT '资源类型：menu-菜单,button-按钮,api-接口',
    resource_url VARCHAR(200) COMMENT '资源路径',
    parent_id INT DEFAULT 0 COMMENT '父权限ID，0表示顶级权限',
    sort_order INT DEFAULT 0 COMMENT '排序',
    status TINYINT DEFAULT 1 COMMENT '状态：1-正常，0-禁用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT '权限表';
```

**字段含义解释**：
- `resource_type`：权限类型，menu(菜单)、button(按钮)、api(接口)
- `resource_url`：资源地址，如"/user/list"、"/admin/delete"
- `parent_id`：支持权限的树形结构，实现权限分级

### 2.4 关联表设计


**用户角色关联表**：
```sql
-- 用户角色关联表：多对多关系
CREATE TABLE user_roles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL COMMENT '用户ID',
    role_id INT NOT NULL COMMENT '角色ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    UNIQUE KEY unique_user_role (user_id, role_id)
) COMMENT '用户角色关联表';
```

**角色权限关联表**：
```sql
-- 角色权限关联表：多对多关系
CREATE TABLE role_permissions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    role_id INT NOT NULL COMMENT '角色ID',
    permission_id INT NOT NULL COMMENT '权限ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE,
    UNIQUE KEY unique_role_permission (role_id, permission_id)
) COMMENT '角色权限关联表';
```

**关键设计要点**：
- `FOREIGN KEY`：外键约束，保证数据完整性
- `ON DELETE CASCADE`：删除角色时，相关关联记录也删除
- `UNIQUE KEY`：防止重复关联

---

## 3. 📊 初始化基础数据


### 3.1 插入基础权限数据


**权限数据初始化**：
```sql
-- 插入基础权限数据
INSERT INTO permissions (permission_name, permission_code, resource_type, resource_url, parent_id) VALUES
-- 系统管理权限
('系统管理', 'SYSTEM_MANAGE', 'menu', '/system', 0),
('用户管理', 'USER_MANAGE', 'menu', '/system/user', 1),
('角色管理', 'ROLE_MANAGE', 'menu', '/system/role', 1),
('权限管理', 'PERMISSION_MANAGE', 'menu', '/system/permission', 1),

-- 用户管理具体操作权限
('用户查询', 'USER_VIEW', 'api', '/api/user/list', 2),
('用户添加', 'USER_ADD', 'button', '/api/user/add', 2),
('用户编辑', 'USER_EDIT', 'button', '/api/user/edit', 2),
('用户删除', 'USER_DELETE', 'button', '/api/user/delete', 2),

-- 业务功能权限
('订单管理', 'ORDER_MANAGE', 'menu', '/order', 0),
('订单查询', 'ORDER_VIEW', 'api', '/api/order/list', 9),
('订单创建', 'ORDER_CREATE', 'button', '/api/order/create', 9);
```

**数据结构说明**：
```
权限树形结构：
系统管理(1)
├── 用户管理(2)
│   ├── 用户查询(5)
│   ├── 用户添加(6)
│   ├── 用户编辑(7)
│   └── 用户删除(8)
├── 角色管理(3)
└── 权限管理(4)

订单管理(9)
├── 订单查询(10)
└── 订单创建(11)
```

### 3.2 插入角色数据


**角色数据初始化**：
```sql
-- 插入角色数据
INSERT INTO roles (role_name, role_code, description) VALUES
('超级管理员', 'SUPER_ADMIN', '拥有系统所有权限'),
('系统管理员', 'ADMIN', '拥有用户和角色管理权限'),
('业务员', 'SALES', '拥有订单相关权限'),
('普通用户', 'USER', '基础查看权限');
```

### 3.3 插入用户数据


**用户数据初始化**：
```sql
-- 插入用户数据（密码应该加密，这里为演示使用明文）
INSERT INTO users (username, password, email, real_name, phone) VALUES
('admin', 'admin123', 'admin@example.com', '管理员', '13800138000'),
('zhangsan', 'pass123', 'zhangsan@example.com', '张三', '13800138001'),
('lisi', 'pass123', 'lisi@example.com', '李四', '13800138002'),
('wangwu', 'pass123', 'wangwu@example.com', '王五', '13800138003');
```

### 3.4 建立用户角色关联


**分配用户角色**：
```sql
-- 给用户分配角色
INSERT INTO user_roles (user_id, role_id) VALUES
-- admin用户是超级管理员
(1, 1),
-- zhangsan是系统管理员
(2, 2),
-- lisi是业务员
(3, 3),
-- wangwu是普通用户
(4, 4),
-- zhangsan同时也是业务员（一个用户可以有多个角色）
(2, 3);
```

### 3.5 建立角色权限关联


**分配角色权限**：
```sql
-- 给角色分配权限
INSERT INTO role_permissions (role_id, permission_id) VALUES
-- 超级管理员拥有所有权限(1-11)
(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11),
-- 系统管理员拥有系统管理权限
(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8),
-- 业务员拥有订单权限
(3, 9), (3, 10), (3, 11),
-- 普通用户只有查看权限
(4, 5), (4, 10);
```

---

## 4. 🔍 多表关联查询实现


### 4.1 基础关联查询概念


**什么是多表关联查询**：
同时从多个相关的表中获取数据，通过JOIN操作把分散在不同表中的信息组合起来

**RBAC中的关联关系**：
```
查询流程：
用户表 → 用户角色表 → 角色表 → 角色权限表 → 权限表

实际路径：
users → user_roles → roles → role_permissions → permissions
```

### 4.2 查询用户基本信息和角色


**查询用户及其角色信息**：
```sql
-- 查询用户及其拥有的角色
SELECT 
    u.id as user_id,
    u.username,
    u.real_name,
    r.id as role_id,
    r.role_name,
    r.role_code
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
WHERE u.id = 2  -- 查询ID为2的用户
  AND u.status = 1  -- 用户状态正常
  AND (r.status = 1 OR r.status IS NULL);  -- 角色状态正常
```

**查询结果示例**：
```
user_id | username | real_name | role_id | role_name | role_code
--------|----------|-----------|---------|-----------|----------
   2    | zhangsan |   张三     |    2    | 系统管理员 | ADMIN
   2    | zhangsan |   张三     |    3    | 业务员    | SALES
```

### 4.3 查询角色及其权限信息


**查询角色拥有的权限**：
```sql
-- 查询角色及其拥有的权限
SELECT 
    r.id as role_id,
    r.role_name,
    p.id as permission_id,
    p.permission_name,
    p.permission_code,
    p.resource_type,
    p.resource_url
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON rp.permission_id = p.id
WHERE r.id = 2  -- 查询ID为2的角色
  AND r.status = 1
  AND (p.status = 1 OR p.status IS NULL)
ORDER BY p.sort_order, p.id;
```

---

## 5. 🎯 用户权限查询SQL


### 5.1 核心权限查询SQL


**根据用户ID获取所有权限**：
```sql
-- 查询用户的所有权限（完整版）
SELECT DISTINCT
    u.id as user_id,
    u.username,
    p.id as permission_id,
    p.permission_name,
    p.permission_code,
    p.resource_type,
    p.resource_url,
    p.parent_id
FROM users u
INNER JOIN user_roles ur ON u.id = ur.user_id
INNER JOIN roles r ON ur.role_id = r.id
INNER JOIN role_permissions rp ON r.id = rp.role_id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE u.id = ?  -- 参数：用户ID
  AND u.status = 1  -- 用户状态正常
  AND r.status = 1  -- 角色状态正常
  AND p.status = 1  -- 权限状态正常
ORDER BY p.parent_id, p.sort_order, p.id;
```

**SQL解析**：
- `DISTINCT`：去重，防止用户有多个角色时权限重复
- `INNER JOIN`：内连接，只查询有关联关系的数据
- `WHERE`条件：确保用户、角色、权限都是启用状态

### 5.2 按权限类型查询


**查询用户的菜单权限**：
```sql
-- 查询用户的菜单权限
SELECT DISTINCT
    p.id,
    p.permission_name,
    p.permission_code,
    p.resource_url,
    p.parent_id,
    p.sort_order
FROM users u
INNER JOIN user_roles ur ON u.id = ur.user_id
INNER JOIN roles r ON ur.role_id = r.id
INNER JOIN role_permissions rp ON r.id = rp.role_id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE u.id = ?
  AND u.status = 1
  AND r.status = 1
  AND p.status = 1
  AND p.resource_type = 'menu'  -- 只查询菜单权限
ORDER BY p.parent_id, p.sort_order;
```

**查询用户的API权限**：
```sql
-- 查询用户的API权限（用于接口鉴权）
SELECT DISTINCT p.permission_code, p.resource_url
FROM users u
INNER JOIN user_roles ur ON u.id = ur.user_id
INNER JOIN roles r ON ur.role_id = r.id
INNER JOIN role_permissions rp ON r.id = rp.role_id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE u.id = ?
  AND u.status = 1
  AND r.status = 1
  AND p.status = 1
  AND p.resource_type = 'api'
  AND p.resource_url IS NOT NULL;
```

### 5.3 权限验证专用SQL


**验证用户是否拥有特定权限**：
```sql
-- 检查用户是否拥有指定权限
SELECT COUNT(*) as has_permission
FROM users u
INNER JOIN user_roles ur ON u.id = ur.user_id
INNER JOIN roles r ON ur.role_id = r.id
INNER JOIN role_permissions rp ON r.id = rp.role_id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE u.id = ?  -- 用户ID
  AND p.permission_code = ?  -- 权限编码
  AND u.status = 1
  AND r.status = 1
  AND p.status = 1;
```

**使用示例**：
```sql
-- 检查用户ID为2的用户是否有'USER_DELETE'权限
SELECT COUNT(*) as has_permission
FROM users u
INNER JOIN user_roles ur ON u.id = ur.user_id
INNER JOIN roles r ON ur.role_id = r.id
INNER JOIN role_permissions rp ON r.id = rp.role_id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE u.id = 2
  AND p.permission_code = 'USER_DELETE'
  AND u.status = 1
  AND r.status = 1
  AND p.status = 1;

-- 结果：has_permission > 0 表示有权限，= 0 表示无权限
```

---

## 6. ⚡ 动态权限数据加载


### 6.1 什么是动态权限加载


**概念解释**：
系统根据用户登录状态和角色变化，实时从数据库获取最新的权限数据，而不是使用缓存的旧数据

**应用场景**：
- 用户登录时加载权限
- 权限变更后刷新权限
- 实时权限验证

### 6.2 用户登录时权限加载


**登录权限加载SQL**：
```sql
-- 用户登录时获取完整权限信息
SELECT 
    -- 用户信息
    u.id as user_id,
    u.username,
    u.real_name,
    -- 角色信息
    GROUP_CONCAT(DISTINCT r.role_code) as roles,
    -- 权限信息（JSON格式）
    JSON_ARRAYAGG(
        JSON_OBJECT(
            'permission_code', p.permission_code,
            'permission_name', p.permission_name,
            'resource_type', p.resource_type,
            'resource_url', p.resource_url
        )
    ) as permissions
FROM users u
INNER JOIN user_roles ur ON u.id = ur.user_id
INNER JOIN roles r ON ur.role_id = r.id
INNER JOIN role_permissions rp ON r.id = rp.role_id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE u.username = ?  -- 登录用户名
  AND u.password = ?  -- 登录密码
  AND u.status = 1
  AND r.status = 1
  AND p.status = 1
GROUP BY u.id, u.username, u.real_name;
```

### 6.3 权限树形结构加载


**获取用户的权限树**：
```sql
-- 获取用户权限的树形结构
WITH RECURSIVE permission_tree AS (
    -- 获取用户的顶级权限（parent_id = 0）
    SELECT DISTINCT
        p.id,
        p.permission_name,
        p.permission_code,
        p.resource_type,
        p.resource_url,
        p.parent_id,
        p.sort_order,
        0 as level
    FROM users u
    INNER JOIN user_roles ur ON u.id = ur.user_id
    INNER JOIN roles r ON ur.role_id = r.id
    INNER JOIN role_permissions rp ON r.id = rp.role_id
    INNER JOIN permissions p ON rp.permission_id = p.id
    WHERE u.id = ? AND p.parent_id = 0
      AND u.status = 1 AND r.status = 1 AND p.status = 1
    
    UNION ALL
    
    -- 递归获取子权限
    SELECT DISTINCT
        p.id,
        p.permission_name,
        p.permission_code,
        p.resource_type,
        p.resource_url,
        p.parent_id,
        p.sort_order,
        pt.level + 1
    FROM permissions p
    INNER JOIN permission_tree pt ON p.parent_id = pt.id
    INNER JOIN role_permissions rp ON p.id = rp.permission_id
    INNER JOIN roles r ON rp.role_id = r.id
    INNER JOIN user_roles ur ON r.id = ur.role_id
    WHERE ur.user_id = ? AND p.status = 1 AND r.status = 1
)
SELECT * FROM permission_tree
ORDER BY parent_id, sort_order, id;
```

### 6.4 权限变更后的数据刷新


**权限变更检测SQL**：
```sql
-- 检查用户权限是否发生变更
SELECT 
    MAX(GREATEST(
        IFNULL(u.updated_at, '1970-01-01'),
        IFNULL(r.updated_at, '1970-01-01'),
        IFNULL(p.updated_at, '1970-01-01'),
        IFNULL(ur.created_at, '1970-01-01'),
        IFNULL(rp.created_at, '1970-01-01')
    )) as last_permission_update
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON rp.permission_id = p.id
WHERE u.id = ?;

-- 如果 last_permission_update > 缓存时间，则需要重新加载权限
```

---

## 7. 💼 实际应用示例


### 7.1 Java应用集成示例


**权限查询服务类**：
```java
@Service
public class PermissionService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * 获取用户所有权限
     */
    public List<Permission> getUserPermissions(Long userId) {
        String sql = """
            SELECT DISTINCT
                p.id, p.permission_name, p.permission_code,
                p.resource_type, p.resource_url, p.parent_id
            FROM users u
            INNER JOIN user_roles ur ON u.id = ur.user_id
            INNER JOIN roles r ON ur.role_id = r.id
            INNER JOIN role_permissions rp ON r.id = rp.role_id
            INNER JOIN permissions p ON rp.permission_id = p.id
            WHERE u.id = ? AND u.status = 1 AND r.status = 1 AND p.status = 1
            ORDER BY p.parent_id, p.sort_order
            """;
        
        return jdbcTemplate.query(sql, new PermissionRowMapper(), userId);
    }
    
    /**
     * 检查用户是否有指定权限
     */
    public boolean hasPermission(Long userId, String permissionCode) {
        String sql = """
            SELECT COUNT(*) FROM users u
            INNER JOIN user_roles ur ON u.id = ur.user_id
            INNER JOIN roles r ON ur.role_id = r.id
            INNER JOIN role_permissions rp ON r.id = rp.role_id
            INNER JOIN permissions p ON rp.permission_id = p.id
            WHERE u.id = ? AND p.permission_code = ?
              AND u.status = 1 AND r.status = 1 AND p.status = 1
            """;
        
        Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId, permissionCode);
        return count != null && count > 0;
    }
}
```

### 7.2 权限验证拦截器


**基于SQL的权限验证**：
```java
@Component
public class PermissionInterceptor implements HandlerInterceptor {
    
    @Autowired
    private PermissionService permissionService;
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        
        // 获取当前用户ID
        Long userId = getCurrentUserId(request);
        if (userId == null) {
            return false;
        }
        
        // 获取请求的API路径
        String requestPath = request.getRequestURI();
        
        // 检查用户是否有访问该API的权限
        String sql = """
            SELECT COUNT(*) FROM users u
            INNER JOIN user_roles ur ON u.id = ur.user_id
            INNER JOIN roles r ON ur.role_id = r.id
            INNER JOIN role_permissions rp ON r.id = rp.role_id
            INNER JOIN permissions p ON rp.permission_id = p.id
            WHERE u.id = ? AND p.resource_url = ? AND p.resource_type = 'api'
              AND u.status = 1 AND r.status = 1 AND p.status = 1
            """;
        
        return permissionService.hasApiPermission(userId, requestPath);
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 RBAC数据库设计：五张核心表的关系和作用
🔸 多表关联查询：通过JOIN操作获取用户权限
🔸 权限查询SQL：根据用户ID获取完整权限信息
🔸 动态加载机制：实时从数据库获取最新权限
🔸 权限验证SQL：检查用户是否拥有特定权限
```

### 8.2 关键理解要点


**🔹 表结构设计的核心思想**
```
用户表 ←→ 用户角色表 ←→ 角色表 ←→ 角色权限表 ←→ 权限表

设计原则：
- 主表存储基础信息
- 关联表处理多对多关系  
- 外键约束保证数据完整性
- 状态字段支持软删除
```

**🔹 多表关联查询的要点**
```
查询流程：users → user_roles → roles → role_permissions → permissions

关键技巧：
- 使用INNER JOIN确保数据完整
- 使用DISTINCT去除重复权限
- 添加状态条件过滤无效数据
- 合理使用索引优化查询性能
```

**🔹 权限验证的实现方式**
```
方式一：查询所有权限后在应用中判断
方式二：直接查询是否有指定权限（推荐）

实际应用：
- 登录时加载用户权限缓存
- 权限验证时查询数据库确认
- 权限变更后及时刷新缓存
```

### 8.3 实际应用指导


**🔧 数据库设计最佳实践**
- 合理设置索引：用户ID、角色ID、权限编码
- 使用外键约束：保证数据一致性
- 添加状态字段：支持逻辑删除
- 记录时间戳：便于权限变更追踪

**⚡ 性能优化建议**
- 权限数据适当缓存，减少数据库查询
- 使用连接池管理数据库连接
- 对常用查询建立合适的索引
- 定期清理无效的关联数据

**🔒 安全注意事项**
- 权限查询必须验证用户状态
- 避免SQL注入，使用参数化查询
- 权限变更要有审计日志
- 敏感操作需要额外权限验证

**核心记忆**：
- RBAC数据库实现就是用五张表存储用户、角色、权限及其关系
- 多表关联查询是获取用户权限的核心技术
- 动态权限加载保证权限数据的实时性和准确性
- 合理的数据库设计是RBAC系统稳定运行的基础