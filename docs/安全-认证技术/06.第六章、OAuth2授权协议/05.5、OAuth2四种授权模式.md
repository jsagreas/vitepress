---
title: 5、OAuth2四种授权模式
---
## 📚 目录

1. [OAuth2授权协议概述](#1-OAuth2授权协议概述)
2. [四种授权模式总览](#2-四种授权模式总览)
3. [授权码模式详解](#3-授权码模式详解)
4. [客户端模式详解](#4-客户端模式详解)
5. [密码模式详解](#5-密码模式详解)
6. [简化模式详解](#6-简化模式详解)
7. [模式选择策略](#7-模式选择策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 OAuth2授权协议概述


### 1.1 什么是OAuth2


> 💡 **核心概念**：OAuth2是一个**授权协议**，不是认证协议
> 
> **通俗理解**：就像给别人一把钥匙，让他们可以进入你的房间拿特定的东西，但不是把房子给他们

**OAuth2解决什么问题？**

```
传统问题场景：
👤 用户：我想让第三方应用帮我发微博
🏢 第三方应用：请给我你的微博账号密码
👤 用户：这样不安全啊，我不想给密码

OAuth2解决方案：
👤 用户：我去微博那里申请一个授权码
🏢 微博：好的，给你一个临时授权码
👤 用户：第三方应用，你拿这个码去换访问令牌吧
🏢 第三方应用：太好了，我可以代替用户发微博了
```

### 1.2 OAuth2的核心角色


**四个关键角色**：

| 角色 | **英文名称** | **通俗理解** | **实际例子** |
|------|-------------|-------------|-------------|
| 🧑‍💻 **资源拥有者** | `Resource Owner` | `资源的主人，就是用户本人` | `你（微博账号的主人）` |
| 📱 **客户端** | `Client` | `想要访问资源的第三方应用` | `美图秀秀APP` |
| 🏢 **授权服务器** | `Authorization Server` | `负责验证身份和颁发令牌的服务器` | `微博的登录认证服务器` |
| 📦 **资源服务器** | `Resource Server` | `存放用户资源的服务器` | `微博的API服务器` |

### 1.3 OAuth2的工作原理


```
基础流程图：

用户         第三方应用          授权服务器         资源服务器
 |              |                    |                  |
 |--①想要授权--->|                    |                  |
 |              |--②请求授权--------->|                  |
 |<--③跳转到授权页面----------------|                  |
 |--④同意授权-------------------->|                  |
 |              |<--⑤返回授权码-------|                  |
 |              |--⑥用授权码换令牌--->|                  |
 |              |<--⑦返回访问令牌-----|                  |
 |              |--⑧用令牌访问资源------------------>|
 |              |<--⑨返回资源数据--------------------|
```

---

## 2. 🎯 四种授权模式总览


### 2.1 四种模式一览表


| 模式名称 | **英文名称** | **适用场景** | **安全级别** | **使用频率** |
|---------|-------------|-------------|-------------|-------------|
| 🔐 **授权码模式** | `Authorization Code` | `Web应用、移动应用` | `⭐⭐⭐⭐⭐ 最高` | `🔥🔥🔥 最常用` |
| ⚡ **简化模式** | `Implicit` | `单页应用（SPA）` | `⭐⭐⭐ 中等` | `🔥 较少用` |
| 🔑 **密码模式** | `Password Credentials` | `可信任的第一方应用` | `⭐⭐ 较低` | `🔥🔥 中等` |
| 🤖 **客户端模式** | `Client Credentials` | `服务器之间调用` | `⭐⭐⭐⭐ 较高` | `🔥🔥 中等` |

### 2.2 选择决策树


```
选择OAuth2模式决策流程：

开始选择模式
    |
    ├─ 是否有用户参与？
    │   │
    │   ├─ 否 → 【客户端模式】(服务器对服务器)
    │   │
    │   └─ 是 → 应用类型是什么？
    │       │
    │       ├─ Web应用 → 【授权码模式】(最安全)
    │       │
    │       ├─ 单页应用(SPA) → 【简化模式】(已较少使用)
    │       │
    │       └─ 可信的第一方应用 → 【密码模式】(需谨慎)
```

---

## 3. 🎖️ 授权码模式详解


### 3.1 为什么授权码模式是主流？


> 🔥 **核心优势**：最安全的OAuth2授权方式
> 
> **原因**：用户密码始终不暴露给第三方应用，访问令牌通过安全后端交换获得

### 3.2 授权码模式工作流程


```
详细时序图：

用户浏览器    第三方应用      授权服务器    资源服务器
     |           |              |             |
     |--①点击登录->|              |             |
     |           |--②构造授权URL-->|             |
     |           |              |             |
     |<--③重定向到授权页面-------|             |
     |           |              |             |
     |--④输入账号密码----------->|             |
     |           |              |             |
     |<--⑤重定向并返回授权码-----|             |
     |           |              |             |
     |--⑥发送授权码------------>|              |
     |           |--⑦后端用code换token------->|             |
     |           |<--⑧返回access_token-------|             |
     |           |                           |             |
     |           |--⑨用token请求API资源---------------->|
     |           |<--⑩返回用户数据--------------------|
```

### 3.3 授权码模式核心参数


**步骤②：构造授权URL**
```http
GET https://oauth.example.com/authorize?
    response_type=code          # 固定值：code
    &client_id=YOUR_CLIENT_ID   # 应用ID
    &redirect_uri=CALLBACK_URL  # 回调地址
    &scope=read_profile         # 权限范围
    &state=RANDOM_STRING        # 防CSRF攻击
```

**步骤⑦：用授权码换访问令牌**
```http
POST https://oauth.example.com/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code   # 固定值
&code=AUTHORIZATION_CODE        # 第一步获得的授权码
&client_id=YOUR_CLIENT_ID       # 应用ID
&client_secret=YOUR_SECRET      # 应用密钥
&redirect_uri=CALLBACK_URL      # 必须与第一步一致
```

**返回的访问令牌**
```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA",
  "scope": "read_profile"
}
```

### 3.4 授权码模式代码示例


**前端发起授权**
```javascript
// 构造授权URL
function startOAuth() {
  const authUrl = 'https://oauth.example.com/authorize' +
    '?response_type=code' +
    '&client_id=your_app_id' +
    '&redirect_uri=' + encodeURIComponent('http://localhost:3000/callback') +
    '&scope=read_profile' +
    '&state=' + generateRandomState();
  
  // 跳转到授权页面
  window.location.href = authUrl;
}
```

**后端处理回调**
```javascript
// 处理授权回调
app.get('/callback', async (req, res) => {
  const { code, state } = req.query;
  
  // 验证state防止CSRF攻击
  if (!validateState(state)) {
    return res.status(400).send('Invalid state');
  }
  
  try {
    // 用授权码换访问令牌
    const tokenResponse = await axios.post('https://oauth.example.com/token', {
      grant_type: 'authorization_code',
      code: code,
      client_id: process.env.CLIENT_ID,
      client_secret: process.env.CLIENT_SECRET,
      redirect_uri: 'http://localhost:3000/callback'
    });
    
    const { access_token } = tokenResponse.data;
    
    // 用访问令牌获取用户信息
    const userResponse = await axios.get('https://api.example.com/user', {
      headers: {
        'Authorization': `Bearer ${access_token}`
      }
    });
    
    res.json({ user: userResponse.data });
  } catch (error) {
    res.status(500).send('OAuth error');
  }
});
```

---

## 4. 🤖 客户端模式详解


### 4.1 客户端模式的使用场景


> 💡 **核心理解**：这种模式**没有用户参与**，完全是服务器对服务器的调用
> 
> **典型场景**：微服务之间的API调用、定时任务访问API、服务器后台管理

### 4.2 客户端模式工作流程


```
简化时序图：

应用服务器                授权服务器              资源服务器
    |                        |                      |
    |--①请求访问令牌--------->|                      |
    |   (client_id + secret)  |                      |
    |                        |                      |
    |<--②返回access_token-----|                      |
    |                        |                      |
    |--③用token调用API资源--------------------------->|
    |                        |                      |
    |<--④返回API数据----------------------------------|
```

> ⚠️ **重要特点**：没有授权码步骤，直接用客户端凭证换取访问令牌

### 4.3 客户端模式请求示例


**请求访问令牌**
```http
POST https://oauth.example.com/token
Content-Type: application/x-www-form-urlencoded
Authorization: Basic BASE64(client_id:client_secret)

grant_type=client_credentials   # 固定值
&scope=api_access              # 可选：权限范围
```

**返回结果**
```json
{
  "access_token": "2YotnFZFEjr1zCsicMWpAA",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "api_access"
}
```

### 4.4 客户端模式代码示例


```javascript
// Node.js示例：获取客户端模式访问令牌
async function getClientToken() {
  const credentials = Buffer.from(
    `${CLIENT_ID}:${CLIENT_SECRET}`
  ).toString('base64');
  
  try {
    const response = await axios.post('https://oauth.example.com/token', 
      'grant_type=client_credentials&scope=api_access',
      {
        headers: {
          'Authorization': `Basic ${credentials}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );
    
    return response.data.access_token;
  } catch (error) {
    console.error('获取令牌失败:', error.message);
    throw error;
  }
}

// 使用令牌调用API
async function callProtectedAPI() {
  const token = await getClientToken();
  
  const apiResponse = await axios.get('https://api.example.com/data', {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  
  return apiResponse.data;
}
```

---

## 5. 🔑 密码模式详解


### 5.1 密码模式的适用场景


> ⚠️ **重要提醒**：密码模式要求用户**直接将账号密码提供给第三方应用**
> 
> **适用场景**：只能用于**高度可信的第一方应用**，比如公司自己开发的移动APP

### 5.2 密码模式工作流程


```
时序图：

用户      第三方应用      授权服务器      资源服务器
 |           |              |              |
 |--①输入账号密码->|              |              |
 |           |--②发送用户凭证---->|              |
 |           |   (username+pwd)  |              |
 |           |<--③返回访问令牌----|              |
 |           |                  |              |
 |           |--④用token访问资源--------------->|
 |           |<--⑤返回用户数据----------------|
```

### 5.3 密码模式请求示例


**用用户名密码换取令牌**
```http
POST https://oauth.example.com/token
Content-Type: application/x-www-form-urlencoded

grant_type=password             # 固定值
&username=user@example.com      # 用户名
&password=userpassword          # 用户密码  
&client_id=YOUR_CLIENT_ID       # 应用ID
&client_secret=YOUR_SECRET      # 应用密钥
&scope=read_profile            # 权限范围
```

### 5.4 密码模式代码示例


```javascript
// 密码模式登录
async function loginWithPassword(username, password) {
  try {
    const response = await axios.post('https://oauth.example.com/token', {
      grant_type: 'password',
      username: username,
      password: password,
      client_id: process.env.CLIENT_ID,
      client_secret: process.env.CLIENT_SECRET,
      scope: 'read_profile write_posts'
    });
    
    const { access_token, refresh_token } = response.data;
    
    // 存储令牌
    localStorage.setItem('access_token', access_token);
    localStorage.setItem('refresh_token', refresh_token);
    
    return response.data;
  } catch (error) {
    console.error('登录失败:', error.response?.data || error.message);
    throw new Error('用户名或密码错误');
  }
}
```

> ⚠️ **安全警告**：密码模式存在安全风险，OAuth2.1已经移除了这种模式

---

## 6. ⚡ 简化模式详解


### 6.1 简化模式的设计背景


> 💡 **设计初衷**：为了解决**单页应用(SPA)**无法安全存储客户端密钥的问题
> 
> **现状**：由于安全性问题，现在**不推荐使用**，建议SPA也使用授权码模式配合PKCE

### 6.2 简化模式工作流程


```
时序图：

用户浏览器        第三方SPA应用      授权服务器
     |               |                  |
     |--①点击登录---->|                  |
     |               |--②跳转到授权页面->|
     |               |                  |
     |<--③显示授权页面------------------|
     |               |                  |
     |--④用户同意授权----------------->|
     |               |                  |
     |<--⑤直接返回访问令牌(在URL中)-----|
     |               |                  |
     |--⑥JS提取令牌-->|                  |
```

### 6.3 简化模式特点


**优点**：
- ✅ 流程简单，减少了一次后端交换步骤
- ✅ 适合无服务器端的单页应用

**缺点**：
- ❌ 访问令牌暴露在URL中，容易泄露
- ❌ 无法获得刷新令牌
- ❌ 令牌可能被浏览器历史记录保存

### 6.4 简化模式请求示例


**构造授权URL**
```javascript
const authUrl = 'https://oauth.example.com/authorize' +
  '?response_type=token' +           // 注意：这里是token，不是code
  '&client_id=your_spa_app_id' +
  '&redirect_uri=' + encodeURIComponent('http://localhost:3000') +
  '&scope=read_profile' +
  '&state=' + generateRandomState();

window.location.href = authUrl;
```

**处理返回的令牌**
```javascript
// 页面加载时检查URL hash中的访问令牌
function handleAuthCallback() {
  const hash = window.location.hash.substring(1);
  const params = new URLSearchParams(hash);
  
  const accessToken = params.get('access_token');
  const tokenType = params.get('token_type');
  const expiresIn = params.get('expires_in');
  const state = params.get('state');
  
  if (accessToken) {
    // 验证state
    if (validateState(state)) {
      // 存储访问令牌
      sessionStorage.setItem('access_token', accessToken);
      
      // 清除URL中的敏感信息
      window.location.hash = '';
      
      console.log('登录成功！');
    }
  }
}
```

---

## 7. 🎯 模式选择策略


### 7.1 实际开发中如何选择


```
选择决策表：

应用场景                   推荐模式              理由
─────────────────────────────────────────────────────
📱 移动APP                授权码模式 + PKCE     最安全，主流做法
🌐 传统Web应用            授权码模式            后端可以安全存储密钥  
🔄 SPA单页应用            授权码模式 + PKCE     比简化模式更安全
🤖 服务器间调用           客户端模式            无用户参与的场景
🏢 内部可信应用           密码模式              仅限高度可信环境
```

### 7.2 各模式的适用场景详解


**🔐 授权码模式 - 首选方案**
```
✅ 适用场景：
- Web应用（有后端服务器）
- 移动应用（配合PKCE）
- 需要最高安全级别的场景

🔒 安全特点：
- 授权码只能使用一次
- 访问令牌在后端安全交换
- 用户密码不暴露给第三方
```

**🤖 客户端模式 - 服务调用**
```
✅ 适用场景：
- 微服务之间的API调用
- 后台定时任务
- 服务器管理接口

⚠️ 注意事项：
- 没有用户上下文
- 需要妥善保护客户端密钥
- 权限范围要严格控制
```

**🔑 密码模式 - 谨慎使用**
```
✅ 适用场景：
- 公司内部的第一方应用
- 从旧系统迁移的过渡方案

❌ 不适用场景：
- 第三方应用
- 公开的应用程序
- 对安全要求高的场景
```

**⚡ 简化模式 - 不推荐**
```
⚠️ 现状：
- OAuth2.1已移除
- 存在安全隐患
- 建议用授权码+PKCE替代

🔄 替代方案：
- SPA使用授权码模式配合PKCE
- 使用现代前端框架的OAuth库
```

### 7.3 选择建议总结


> 🎯 **最佳实践建议**
> 
> - **90%的场景**：使用授权码模式
> - **服务器调用**：使用客户端模式  
> - **内部可信应用**：可考虑密码模式（谨慎）
> - **避免使用**：简化模式（已废弃）

---

## 8. 📋 核心要点总结


### 8.1 四种模式核心要点


```
🔐 授权码模式 (Authorization Code)
├─ 💡 核心：最安全的OAuth2模式
├─ 🎯 场景：Web应用、移动应用
├─ ⭐ 优点：用户密码不暴露、支持刷新令牌
└─ 🔥 推荐：首选方案，使用最广泛

🤖 客户端模式 (Client Credentials)  
├─ 💡 核心：服务器对服务器调用
├─ 🎯 场景：微服务API、后台任务
├─ ⭐ 优点：流程简单、无用户参与
└─ ✅ 推荐：服务调用的标准选择

🔑 密码模式 (Password Credentials)
├─ 💡 核心：直接用用户名密码换令牌
├─ 🎯 场景：高度可信的第一方应用
├─ ⚠️ 缺点：用户密码暴露给第三方
└─ 🤔 谨慎：仅限内部可信环境

⚡ 简化模式 (Implicit)
├─ 💡 核心：为SPA设计的简化流程
├─ 🎯 场景：单页应用（历史产物）
├─ ❌ 缺点：安全性差、令牌易泄露
└─ 🚫 不推荐：已被OAuth2.1移除
```

### 8.2 关键理解要点


**🔹 授权vs认证的区别**
```
认证(Authentication)：你是谁？
授权(Authorization)：你能做什么？

OAuth2专注授权：
- 不验证用户身份
- 只关心权限范围
- 通过令牌控制访问
```

**🔹 为什么授权码模式最安全**
```
安全机制：
1️⃣ 授权码只能使用一次
2️⃣ 访问令牌不暴露给前端
3️⃣ 客户端密钥保存在后端
4️⃣ 支持令牌刷新机制
```

**🔹 选择模式的核心原则**
```
安全第一：
- 优先选择授权码模式
- 避免在前端暴露敏感信息
- 根据应用架构选择合适模式

实用性考虑：
- 服务调用用客户端模式
- 内部应用可考虑密码模式
- 新项目避免简化模式
```

### 8.3 实战开发建议


**🛠️ 开发最佳实践**
- ✅ **Web应用**：授权码模式 + 后端存储密钥
- ✅ **移动应用**：授权码模式 + PKCE扩展
- ✅ **SPA应用**：授权码模式 + PKCE，避免简化模式
- ✅ **微服务**：客户端模式，注意密钥管理
- ✅ **内部工具**：可使用密码模式，但要评估风险

**🔒 安全注意事项**
- 🔐 客户端密钥绝对不能暴露给前端
- 🔄 访问令牌要设置合理的过期时间
- 🛡️ 使用HTTPS，防止令牌在传输中被窃取
- 🎯 权限范围(scope)要遵循最小权限原则

**核心记忆**：
- OAuth2是授权协议，不是认证协议
- 授权码模式是主流，安全性最高
- 客户端模式用于服务间调用
- 密码模式要谨慎使用，简化模式已废弃
- 选择模式要考虑安全性和应用架构