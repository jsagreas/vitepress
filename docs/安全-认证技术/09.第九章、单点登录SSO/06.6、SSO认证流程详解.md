---
title: 6、SSO认证流程详解
---
## 📚 目录

1. [SSO基本概念](#1-sso基本概念)
2. [典型登录流程分解](#2-典型登录流程分解)
3. [Ticket票据机制](#3-ticket票据机制)
4. [重定向跳转机制](#4-重定向跳转机制)
5. [Token存储与传输](#5-token存储与传输)
6. [Session管理与刷新](#6-session管理与刷新)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔐 SSO基本概念


### 1.1 什么是SSO


**🎯 通俗理解**：SSO就像一张"万能钥匙"，一次登录就能访问多个系统，不用重复输入用户名密码。

```
传统登录方式：
用户访问系统A → 输入账号密码 → 登录成功
用户访问系统B → 再次输入账号密码 → 登录成功
用户访问系统C → 又要输入账号密码 → 登录成功

SSO登录方式：
用户访问系统A → 输入账号密码 → 登录成功
用户访问系统B → 自动识别已登录 → 直接进入
用户访问系统C → 自动识别已登录 → 直接进入
```

### 1.2 SSO解决的问题


**🔸 用户体验问题**
- ✅ **减少密码疲劳** - 不用记住多套账号密码
- ✅ **提高效率** - 一次登录，到处访问
- ✅ **降低忘记密码风险** - 只需要记住一套凭证

**🔸 企业管理问题**
- ✅ **统一用户管理** - 集中管理所有用户权限
- ✅ **提高安全性** - 统一的安全策略和审计
- ✅ **降低运维成本** - 减少账号管理工作量

### 1.3 SSO核心角色


```
SSO系统架构图：

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   用户浏览器   │    │  认证中心(CAS) │    │   业务系统A   │
│             │    │             │    │             │
│   存储Token   │◄──►│  颁发Token   │◄──►│  验证Token   │
└─────────────┘    └─────────────┘    └─────────────┘
                           ▲
                           │
                           ▼
                   ┌─────────────┐
                   │   业务系统B   │
                   │             │
                   │  验证Token   │
                   └─────────────┘
```

**🔸 三大核心角色**：
- **用户（Client）** - 需要访问多个系统的最终用户
- **认证中心（CAS Server）** - 专门负责用户登录验证的中央服务
- **业务系统（Service）** - 各个需要登录的具体应用系统

---

## 2. 🔄 典型登录流程分解


### 2.1 首次登录完整流程


**📋 详细步骤解析**

```
第一次访问流程（用户从未登录过）：

①用户浏览器                ②认证中心               ③业务系统A
     │                        │                      │
     │──1.访问系统A─────────────→│                      │
     │   GET /systemA          │                      │
     │                        │──2.检查是否登录────────→│
     │                        │                      │
     │                        │←─3.用户未登录，返回───────│
     │←─4.重定向到登录页面───────────│                      │
     │   302 /cas/login        │                      │
     │                        │                      │
     │──5.显示登录表单──────────→│                      │
     │                        │                      │
     │──6.提交用户名密码────────→│                      │
     │   POST username/password │                      │
     │                        │                      │
     │                        │──7.验证用户凭证────────→│数据库
     │                        │←─8.验证成功─────────────│
     │                        │                      │
     │←─9.返回Ticket──────────────│                      │
     │   302 /systemA?ticket=ST-123                   │
     │                        │                      │
     │──10.携带Ticket访问系统───────────────────────────→│
     │   GET /systemA?ticket=ST-123                   │
     │                        │                      │
     │                        │←─11.验证Ticket────────────│
     │                        │   GET /cas/validate?ticket=ST-123
     │                        │                      │
     │                        │──12.Ticket有效─────────→│
     │                        │   返回用户信息            │
     │                        │                      │
     │←─────────────────────────13.登录成功，返回页面──────│
     │                        │                      │
```

**🔸 核心理解要点**：

1. **初始访问** - 用户想访问业务系统A，但还没有登录过任何系统
2. **身份检查** - 系统A发现用户没有登录凭证，无法直接访问
3. **重定向登录** - 自动跳转到统一的认证中心进行登录
4. **凭证验证** - 认证中心验证用户输入的账号密码是否正确
5. **颁发票据** - 验证成功后，生成一个临时票据（Ticket）
6. **票据验证** - 业务系统收到票据后，向认证中心确认票据的真实性
7. **建立会话** - 验证通过后，业务系统为用户建立登录会话

### 2.2 后续系统访问流程


**🚀 已登录状态下的访问**

```
用户已在认证中心登录，访问其他系统：

①用户浏览器                ②认证中心               ③业务系统B
     │                        │                      │
     │──1.访问系统B─────────────→│                      │
     │   GET /systemB          │                      │
     │                        │──2.检查登录状态────────→│
     │                        │                      │
     │                        │←─3.未在系统B登录───────│
     │←─4.重定向到认证中心───────────│                      │
     │   302 /cas/login?service=systemB                │
     │                        │                      │
     │──5.携带已有Cookie访问────→│                      │
     │   已登录状态              │                      │
     │                        │                      │
     │←─6.直接返回Ticket─────────│                      │
     │   302 /systemB?ticket=ST-456（无需再次输入密码）   │
     │                        │                      │
     │──7.使用Ticket登录系统B─────────────────────────→│
     │                        │                      │
     │                        │←─8.验证Ticket────────────│
     │                        │──9.验证成功──────────→│
     │                        │                      │
     │←─────────────────────────10.直接进入系统B────────│
```

**💡 关键差异**：
- **第二次登录无需输入密码** - 认证中心记住了用户的登录状态
- **自动生成新票据** - 为不同系统生成不同的访问票据
- **快速验证** - 整个过程用户几乎无感知

---

## 3. 🎫 Ticket票据机制


### 3.1 什么是Ticket


**🔸 通俗理解**：Ticket就像电影票或演唱会门票，是一张临时的"通行证"

```
电影票的特点：                 SSO Ticket的特点：
- 一次性使用                  - 一次性使用（验证后立即失效）
- 有时间限制                  - 有时间限制（通常几分钟内有效）  
- 对应特定场次                - 对应特定的业务系统
- 防伪验证                    - 包含签名防止伪造
- 票面信息                    - 包含用户身份信息
```

### 3.2 Ticket生成过程


**🔧 Ticket的诞生**

```javascript
// 简化的Ticket生成逻辑
function generateTicket(username, targetService) {
    // 1. 基础信息
    const ticketInfo = {
        username: username,           // 用户标识
        service: targetService,       // 目标系统
        timestamp: Date.now(),        // 生成时间
        expiry: Date.now() + 300000   // 5分钟后过期
    };
    
    // 2. 生成唯一标识
    const ticketId = 'ST-' + generateRandomString(32);
    
    // 3. 数字签名（防伪）
    const signature = createSignature(ticketInfo, secretKey);
    
    // 4. 完整Ticket
    return {
        id: ticketId,
        info: ticketInfo,
        signature: signature
    };
}
```

**🔸 Ticket命名规则**：
- **ST-** 开头表示 Service Ticket（服务票据）
- **TGT-** 开头表示 Ticket Granting Ticket（票据授权票据）
- **随机字符串** 确保唯一性和不可预测性

### 3.3 Ticket校验过程


**✅ 如何验证Ticket真伪**

```
业务系统验证Ticket的步骤：

业务系统A                     认证中心
    │                          │
    │──1.收到用户携带的Ticket────│
    │   ticket=ST-abc123       │
    │                          │
    │──2.向认证中心验证─────────→│
    │   GET /cas/validate?     │
    │   ticket=ST-abc123&      │
    │   service=systemA        │
    │                          │
    │                          │──3.检查Ticket
    │                          │   - 格式是否正确
    │                          │   - 是否已过期
    │                          │   - 是否已使用过
    │                          │   - 签名是否有效
    │                          │   - 目标系统是否匹配
    │                          │
    │←─4.返回验证结果───────────────│
    │   success=true&          │
    │   username=zhangsan      │
    │                          │
    │──5.销毁Ticket（一次性）───→│
```

**⚠️ 重要特性**：
- **一次性使用** - 验证后立即失效，防止重放攻击
- **时间限制** - 通常5-10分钟内必须使用
- **目标绑定** - 只能在指定的业务系统中使用
- **签名验证** - 防止伪造和篡改

---

## 4. 🔄 重定向跳转机制


### 4.1 HTTP 302重定向的作用


**🔸 什么是302重定向**

```
HTTP 302 状态码的含义：
"Found" - 临时重定向，资源临时移动到新位置

普通网页访问：
用户 → 直接访问目标页面 → 显示内容

SSO中的302重定向：
用户 → 访问业务系统 → 302跳转认证中心 → 登录 → 302跳转回业务系统
```

**💡 为什么要用302而不是301**：
- **301永久重定向** - 浏览器会缓存，下次直接跳转，不适合SSO
- **302临时重定向** - 每次都重新判断，适合动态的登录状态检查

### 4.2 SSO中的重定向链路


**🔄 完整的跳转路径**

```
用户想访问：https://mail.company.com

实际跳转过程：
①https://mail.company.com
   ↓ 302重定向
②https://sso.company.com/login?service=https://mail.company.com
   ↓ 用户登录成功后302重定向  
③https://mail.company.com?ticket=ST-123456
   ↓ 系统验证ticket后正常显示
④https://mail.company.com （最终显示邮箱界面）
```

**🔸 关键参数说明**：

| 参数 | 含义 | 示例 |
|------|------|------|
| **service** | 用户最终要访问的系统地址 | `https://mail.company.com` |
| **ticket** | 认证中心颁发的临时票据 | `ST-1234567890abcdef` |
| **gateway** | 是否允许透明登录 | `true/false` |

### 4.3 重定向安全防护


**🛡️ 防止恶意重定向**

```javascript
// 验证重定向地址的安全性
function validateRedirectUrl(serviceUrl) {
    // 1. 检查是否在白名单域名内
    const allowedDomains = [
        'company.com',
        'mail.company.com', 
        'oa.company.com'
    ];
    
    // 2. 防止开放重定向攻击
    const urlObj = new URL(serviceUrl);
    const domain = urlObj.hostname;
    
    if (!allowedDomains.includes(domain)) {
        throw new Error('不允许重定向到外部域名');
    }
    
    // 3. 检查协议安全性
    if (urlObj.protocol !== 'https:') {
        throw new Error('只允许HTTPS协议');
    }
    
    return true;
}
```

**⚠️ 常见安全风险**：
- **开放重定向** - 恶意网站利用SSO跳转到钓鱼网站
- **中间人攻击** - HTTP传输被截获
- **CSRF攻击** - 跨站请求伪造

---

## 5. 🔑 Token存储与传输


### 5.1 Token vs Ticket的区别


**🔸 概念区分**

```
Ticket（票据）：
- 临时性：几分钟内有效
- 一次性：使用后立即失效  
- 用途：用于系统间的身份传递

Token（令牌）：
- 持久性：几小时到几天有效
- 可重复使用：在有效期内可多次使用
- 用途：维持用户的登录状态
```

### 5.2 Token存储方式


**🍪 Cookie存储**

```javascript
// 设置登录Token到Cookie
function setLoginToken(token) {
    document.cookie = `sso_token=${token}; ` +
                     `path=/; ` +
                     `domain=.company.com; ` +  // 跨子域共享
                     `secure; ` +               // 只在HTTPS下传输
                     `httpOnly; ` +             // 防止XSS攻击
                     `max-age=86400`;           // 24小时有效
}

// 读取Cookie中的Token
function getLoginToken() {
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'sso_token') {
            return value;
        }
    }
    return null;
}
```

**💾 LocalStorage存储**

```javascript
// 存储到本地存储
function saveTokenToStorage(token) {
    const tokenData = {
        value: token,
        expiry: Date.now() + 24 * 60 * 60 * 1000  // 24小时后过期
    };
    
    localStorage.setItem('sso_token', JSON.stringify(tokenData));
}

// 从本地存储读取
function getTokenFromStorage() {
    const tokenData = localStorage.getItem('sso_token');
    if (!tokenData) return null;
    
    const parsed = JSON.parse(tokenData);
    
    // 检查是否过期
    if (Date.now() > parsed.expiry) {
        localStorage.removeItem('sso_token');
        return null;
    }
    
    return parsed.value;
}
```

### 5.3 Token传输方式


**📡 HTTP Header传输**

```javascript
// 在请求头中携带Token
function makeAuthenticatedRequest(url) {
    const token = getLoginToken();
    
    return fetch(url, {
        headers: {
            'Authorization': `Bearer ${token}`,     // 标准方式
            'X-Auth-Token': token,                  // 自定义头
            'Content-Type': 'application/json'
        }
    });
}

// 服务端验证Token
app.use((req, res, next) => {
    const token = req.headers['authorization']?.replace('Bearer ', '') ||
                  req.headers['x-auth-token'];
    
    if (!token) {
        return res.status(401).json({ error: '缺少认证Token' });
    }
    
    // 验证Token有效性
    if (validateToken(token)) {
        req.user = getUserFromToken(token);
        next();
    } else {
        res.status(401).json({ error: 'Token无效或已过期' });
    }
});
```

**🔒 安全传输对比**

| 传输方式 | **安全性** | **适用场景** | **优缺点** |
|---------|-----------|-------------|-----------|
| **Cookie** | `高` | `浏览器应用` | `自动携带，但受同源限制` |
| **HTTP Header** | `高` | `API调用` | `灵活，但需手动处理` |
| **URL参数** | `低` | `特殊情况` | `容易泄露，不推荐` |
| **POST Body** | `中` | `表单提交` | `相对安全，但不够标准` |

---

## 6. 🔄 Session管理与刷新


### 6.1 SSO中的Session层次


**🏗️ 多层Session架构**

```
SSO的三层Session结构：

┌─────────────────────────────────────────┐
│            浏览器层面                     │
│  存储：Cookie中的Session ID               │
│  作用：标识用户身份                       │
└─────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────┐
│           认证中心层面                     │  
│  存储：TGT (Ticket Granting Ticket)      │
│  作用：记录全局登录状态                    │
└─────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────┐
│           业务系统层面                     │
│  存储：本地Session或Token                │
│  作用：维持在具体系统中的会话状态           │
└─────────────────────────────────────────┘
```

### 6.2 Session生命周期管理


**⏰ Session的创建、维持、销毁**

```javascript
// Session创建
function createSSSession(username) {
    const sessionData = {
        username: username,
        loginTime: Date.now(),
        lastAccessTime: Date.now(),
        expiry: Date.now() + 8 * 60 * 60 * 1000,  // 8小时有效
        loginSystems: []  // 记录已登录的系统
    };
    
    const sessionId = generateSessionId();
    
    // 存储到Redis或内存
    sessionStore.set(sessionId, sessionData);
    
    return sessionId;
}

// Session维持（心跳机制）
function keepSessionAlive(sessionId) {
    const session = sessionStore.get(sessionId);
    if (session) {
        session.lastAccessTime = Date.now();
        
        // 滑动过期时间（可选）
        session.expiry = Date.now() + 8 * 60 * 60 * 1000;
        
        sessionStore.set(sessionId, session);
        return true;
    }
    return false;
}

// Session销毁
function destroySession(sessionId) {
    const session = sessionStore.get(sessionId);
    if (session) {
        // 通知所有已登录系统退出
        session.loginSystems.forEach(system => {
            notifySystemLogout(system, sessionId);
        });
        
        // 删除Session
        sessionStore.delete(sessionId);
    }
}
```

### 6.3 Token自动刷新机制


**🔄 Token续期策略**

```javascript
// Token刷新逻辑
class TokenManager {
    constructor() {
        this.refreshThreshold = 10 * 60 * 1000;  // 10分钟内过期时刷新
    }
    
    // 检查Token是否需要刷新
    needsRefresh(token) {
        const payload = this.parseToken(token);
        const timeUntilExpiry = payload.exp * 1000 - Date.now();
        
        return timeUntilExpiry < this.refreshThreshold;
    }
    
    // 自动刷新Token
    async autoRefreshToken() {
        const currentToken = getLoginToken();
        
        if (!currentToken) {
            // 没有Token，重定向到登录页
            window.location.href = '/sso/login';
            return;
        }
        
        if (this.needsRefresh(currentToken)) {
            try {
                // 调用刷新接口
                const response = await fetch('/sso/refresh', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });
                
                if (response.ok) {
                    const { newToken } = await response.json();
                    setLoginToken(newToken);
                    console.log('Token已自动刷新');
                } else {
                    // 刷新失败，需要重新登录
                    this.redirectToLogin();
                }
            } catch (error) {
                console.error('Token刷新失败:', error);
                this.redirectToLogin();
            }
        }
    }
    
    // 重定向到登录页面
    redirectToLogin() {
        const currentUrl = encodeURIComponent(window.location.href);
        window.location.href = `/sso/login?service=${currentUrl}`;
    }
}

// 定期检查Token状态
const tokenManager = new TokenManager();
setInterval(() => {
    tokenManager.autoRefreshToken();
}, 5 * 60 * 1000);  // 每5分钟检查一次
```

### 6.4 统一退出机制


**🚪 Single Logout (SLO)**

```
统一退出流程：

用户在系统A点击退出
      │
      ▼
认证中心收到退出请求
      │
      ▼  
查找用户在所有系统的Session
      │
      ▼
┌─────────────────────────────────┐
│ 并发通知所有相关系统执行退出操作    │
├─────────────────────────────────┤
│ 系统A：清除本地Session           │
│ 系统B：清除本地Session           │  
│ 系统C：清除本地Session           │
└─────────────────────────────────┘
      │
      ▼
认证中心清除全局Session
      │
      ▼
返回退出成功页面
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 SSO本质：一次登录，处处通行的统一认证机制
🔸 三大角色：用户、认证中心、业务系统的协作关系  
🔸 Ticket机制：临时票据用于安全的身份传递
🔸 重定向跳转：302状态码实现系统间的无感切换
🔸 Token管理：持久化存储用户登录状态
🔸 Session层次：多层会话管理确保安全性
```

### 7.2 关键理解要点


**🔹 为什么需要重定向**
```
安全性考虑：
- 用户密码只在认证中心输入，其他系统看不到
- 统一的安全策略和审计日志
- 防止密码在多个系统中传播

用户体验：
- 一次登录，自动获得所有系统访问权限
- 统一的登录界面和操作流程
- 避免重复输入凭证的麻烦
```

**🔹 Ticket与Token的设计理念**
```
Ticket（短期票据）：
- 设计原则：一次性使用，防止重放攻击
- 使用场景：系统间身份传递的临时凭证
- 安全特性：时间限制、目标绑定、签名验证

Token（长期令牌）：
- 设计原则：可重复使用，维持会话状态  
- 使用场景：用户在系统内的持续认证
- 安全特性：定期刷新、权限控制、加密存储
```

**🔹 Session管理的复杂性**
```
多层管理：
- 浏览器层：Cookie存储和传输
- 认证中心层：全局登录状态跟踪
- 业务系统层：本地会话和权限管理

生命周期：
- 创建：首次登录时建立全局会话
- 维持：定期心跳和自动续期
- 销毁：单点退出时的级联清理
```

### 7.3 实际应用指导


**🎯 SSO选型考虑**
- **企业规模** - 大企业适合CAS，小企业可选OAuth
- **系统复杂度** - 多系统必须，单系统不必要
- **安全要求** - 高安全场景需要多因素认证
- **技术栈** - 选择与现有技术栈兼容的方案

**🔧 实施关键点**
- **域名规划** - 统一域名便于Cookie共享
- **HTTPS强制** - 确保传输安全
- **异常处理** - 网络故障时的降级方案
- **性能优化** - 减少重定向次数，缓存验证结果

**⚠️ 常见问题**
- **跨域问题** - 不同域名间的Cookie和Token传递
- **时间同步** - 多服务器间的时钟同步
- **退出问题** - 确保所有系统完全退出
- **性能瓶颈** - 认证中心的高可用和负载均衡

**核心记忆**：
- SSO让多系统登录变简单，一次认证处处通行
- Ticket是临时通行证，Token是长期身份证
- 302重定向是关键，安全传递用户身份
- Session分层管理，统一退出要彻底