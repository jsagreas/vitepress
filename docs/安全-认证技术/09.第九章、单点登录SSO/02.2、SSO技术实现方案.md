---
title: 2、SSO技术实现方案
---
## 📚 目录

1. [SSO单点登录基础概念](#1-SSO单点登录基础概念)
2. [多系统认证状态共享方式](#2-多系统认证状态共享方式)
3. [Cookie跨域与Session共享](#3-Cookie跨域与Session共享)
4. [前后端分离下的SSO设计](#4-前后端分离下的SSO设计)
5. [主流SSO技术实现方案](#5-主流SSO技术实现方案)
6. [SSO认证流程详解](#6-SSO认证流程详解)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 SSO单点登录基础概念


### 1.1 什么是单点登录？


**🔸 SSO定义**
```
单点登录（Single Sign-On，SSO）：
用户只需要登录一次，就能访问所有相互信任的应用系统，
无需在每个系统中重复输入用户名和密码。
```

**🌰 生活中的例子**
想象你有一张万能钥匙，用这把钥匙开了家门后，家里的书房、卧室、厨房的门都自动为你打开，不需要再用其他钥匙。SSO就是这样的"万能钥匙"概念。

### 1.2 为什么需要SSO？


**❌ 没有SSO的痛苦**
```
用户痛点：
- 需要记住多套用户名密码
- 每个系统都要重新登录
- 密码忘记要到处找回

企业痛点：
- 用户体验差，客户流失
- 管理多套用户体系复杂
- 安全风险分散难以控制
```

**✅ 有了SSO的好处**
```
用户体验：一次登录，处处畅通
安全管理：统一认证，集中控制
运维成本：减少密码重置，降低支持成本
数据统一：用户行为可以跨系统分析
```

### 1.3 SSO的核心理念


> 💡 **核心思想**  
> 把"登录认证"这件事从各个应用系统中抽离出来，交给专门的认证中心来处理。各个应用系统只需要相信认证中心的判断即可。

**🔗 信任关系图**
```
     认证中心(可信任的)
         /  |  \
        /   |   \
   系统A  系统B  系统C
   (信任) (信任) (信任)
```

---

## 2. 🔄 多系统认证状态共享方式


### 2.1 认证状态共享的本质问题


**🤔 核心挑战**
```
问题：用户在系统A登录了，怎么让系统B知道用户已经登录？

传统方式：每个系统都有自己的用户表和登录机制
SSO方式：多个系统共享同一个登录状态
```

### 2.2 主要共享方式对比


| 共享方式 | **工作原理** | **优点** | **缺点** | **适用场景** |
|---------|------------|---------|---------|-------------|
| 🍪 **Cookie共享** | `同域名下共享Cookie` | `实现简单，浏览器原生支持` | `只适用同域名，安全性一般` | `子域名系统集成` |
| 🗄️ **Session共享** | `多系统连接同一Session存储` | `传统技术，成熟可靠` | `需要共享存储，扩展性差` | `内网系统集群` |
| 🎫 **Token传递** | `通过Token在系统间传递认证信息` | `跨域支持好，扩展性强` | `需要加密签名，复杂度高` | `微服务、前后端分离` |
| 🏛️ **认证中心** | `专门的认证服务器统一管理` | `安全性高，功能完整` | `架构复杂，开发成本高` | `大型企业级应用` |

### 2.3 共享方式选择指南


**🎯 选择决策树**
```
是否同域名？
    ├─ 是 → Cookie共享方式
    └─ 否 → 是否微服务架构？
              ├─ 是 → Token/JWT方式  
              └─ 否 → 传统架构？
                      ├─ 是 → Session共享方式
                      └─ 否 → 认证中心方式
```

---

## 3. 🍪 Cookie跨域与Session共享


### 3.1 Cookie跨域共享机制


**🔸 同域名Cookie共享**
```javascript
// 在主域名 example.com 设置Cookie
document.cookie = "token=abc123; domain=.example.com; path=/";

// 子域名自动共享
// app1.example.com 可以读取
// app2.example.com 可以读取
// app3.example.com 可以读取
```

**🌐 Cookie跨域共享示意图**
```
主域名: example.com
    ├─ app1.example.com  (可以读取主域名Cookie)
    ├─ app2.example.com  (可以读取主域名Cookie)  
    └─ app3.example.com  (可以读取主域名Cookie)

不同域名: other.com (无法读取example.com的Cookie)
```

### 3.2 Cookie共享的实现步骤


**🚀 实现步骤**
```
1️⃣ 用户在主域名 sso.example.com 登录
2️⃣ 登录成功后设置domain=.example.com的Cookie
3️⃣ 用户访问 app1.example.com 时，浏览器自动带上Cookie
4️⃣ app1.example.com 验证Cookie中的登录信息
5️⃣ 验证通过，用户直接进入系统，无需再次登录
```

**💻 代码示例**
```javascript
// 登录成功后设置跨域Cookie
function setSSoCookie(token) {
    // 设置为主域名，所有子域名都能访问
    document.cookie = `sso_token=${token}; domain=.example.com; path=/; max-age=7200`;
}

// 在各个子系统中检查SSO状态
function checkSSOStatus() {
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        if (cookie.trim().startsWith('sso_token=')) {
            const token = cookie.split('=')[1];
            return validateToken(token); // 验证token有效性
        }
    }
    return false; // 未找到SSO token
}
```

### 3.3 Session共享存储方案


**🗄️ 分布式Session存储**
```
传统Session问题：
用户登录系统A → Session存在A服务器内存中
用户访问系统B → B服务器没有这个Session → 需要重新登录

解决方案：
所有系统的Session都存储在同一个地方
```

**🔧 Redis共享Session架构**
```
          用户
           │
    ┌──────┼──────┐
    │      │      │
 系统A   系统B   系统C
    │      │      │
    └──────┼──────┘
           │
    Redis Session存储
    (所有系统共享)
```

**💻 Redis Session实现**
```java
// Spring Boot配置Redis Session共享
@Configuration
public class SessionConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 配置Redis连接
        return template;
    }
}

// 在应用中使用
@RestController
public class LoginController {
    
    @PostMapping("/login")
    public Result login(HttpServletRequest request) {
        // 登录验证成功后
        HttpSession session = request.getSession();
        session.setAttribute("user", userInfo);
        // Session自动存储到Redis，其他系统可以访问
        return Result.success();
    }
}
```

### 3.4 Cookie跨域的限制与解决


**⚠️ Cookie跨域限制**
```
浏览器安全策略：
- 不同域名间Cookie完全隔离
- example.com 和 other.com 无法共享Cookie
- 即使是相似域名也不行：app.com 和 web.com
```

**🔧 跨域解决方案**
```javascript
// 方案1: 通过iframe+postMessage传递认证信息
// 主域名页面
window.addEventListener('message', function(event) {
    if (event.origin === 'https://other.com') {
        // 接收其他域名的认证请求
        const token = getLocalToken();
        event.source.postMessage({token: token}, event.origin);
    }
});

// 方案2: 通过URL参数传递token
function redirectWithToken(targetUrl) {
    const token = getCurrentToken();
    window.location.href = `${targetUrl}?sso_token=${token}`;
}
```

---

## 4. 💻 前后端分离下的SSO设计


### 4.1 前后端分离的认证挑战


**🤔 新的问题**
```
传统模式：
浏览器 ←→ 后端服务器 (Session在服务器端)

前后端分离：
浏览器 ←→ 前端应用(Vue/React) ←→ 后端API
        (无状态，不能依赖Session)
```

**💡 解决思路**
前后端分离下，认证信息主要通过Token来传递，而不是依赖服务器端的Session。

### 4.2 Token-Based SSO架构


**🏗️ 架构示意图**
```
                 SSO认证中心
                      │
              颁发JWT Token
                      │
    ┌─────────────────┼─────────────────┐
    │                 │                 │
前端应用A          前端应用B          前端应用C
(Vue/React)      (Vue/React)      (Vue/React)
    │                 │                 │
后端API-A          后端API-B          后端API-C
(验证Token)       (验证Token)       (验证Token)
```

### 4.3 JWT在前后端分离SSO中的应用


**🎫 JWT Token结构**
```javascript
// JWT包含三部分，用.分隔
const jwt = "header.payload.signature";

// Header: 加密算法信息
{
  "alg": "HS256",
  "typ": "JWT"
}

// Payload: 用户信息和权限
{
  "userId": "12345",
  "username": "张三",
  "roles": ["user", "admin"],
  "exp": 1625097600  // 过期时间
}

// Signature: 防止篡改的签名
```

**🔄 前后端分离SSO流程**
```
1️⃣ 用户在前端A输入账号密码
2️⃣ 前端A发送登录请求到SSO认证中心
3️⃣ 认证中心验证成功，返回JWT Token
4️⃣ 前端A将Token存储在localStorage中
5️⃣ 用户访问前端B时，前端B检查localStorage中的Token
6️⃣ 如果Token有效，直接登录；如果无效，重定向到认证中心
```

### 4.4 前端Token管理实现


**💻 前端Token管理代码**
```javascript
// Token管理工具类
class TokenManager {
    
    // 保存Token
    static saveToken(token) {
        localStorage.setItem('sso_token', token);
    }
    
    // 获取Token
    static getToken() {
        return localStorage.getItem('sso_token');
    }
    
    // 检查Token是否有效
    static isTokenValid() {
        const token = this.getToken();
        if (!token) return false;
        
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return payload.exp > Date.now() / 1000;
        } catch (e) {
            return false;
        }
    }
    
    // 清除Token（退出登录）
    static clearToken() {
        localStorage.removeItem('sso_token');
    }
}

// 在Vue应用中使用
// main.js
import { TokenManager } from './utils/token';

router.beforeEach((to, from, next) => {
    if (to.meta.requiresAuth) {
        if (TokenManager.isTokenValid()) {
            next(); // Token有效，继续访问
        } else {
            // Token无效，重定向到SSO登录页面
            window.location.href = 'https://sso.example.com/login?redirect=' + encodeURIComponent(window.location.href);
        }
    } else {
        next();
    }
});
```

### 4.5 后端Token验证实现


**🔐 后端验证Token**
```java
@Component
public class JwtTokenValidator {
    
    private String secretKey = "your-secret-key";
    
    public boolean validateToken(String token) {
        try {
            Claims claims = Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(token)
                .getBody();
                
            // 检查过期时间
            Date expiration = claims.getExpiration();
            return expiration.after(new Date());
            
        } catch (JwtException e) {
            return false;
        }
    }
    
    public String getUserId(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(secretKey)
            .parseClaimsJws(token)
            .getBody();
        return claims.getSubject();
    }
}

// 在Controller中使用
@RestController
public class ApiController {
    
    @Autowired
    private JwtTokenValidator tokenValidator;
    
    @GetMapping("/user/info")
    public Result getUserInfo(@RequestHeader("Authorization") String token) {
        if (!tokenValidator.validateToken(token)) {
            return Result.error("Token无效");
        }
        
        String userId = tokenValidator.getUserId(token);
        // 返回用户信息
        return Result.success(userService.getUserById(userId));
    }
}
```

---

## 5. 🏛️ 主流SSO技术实现方案


### 5.1 中心认证模式（CAS）


**🔸 CAS基本概念**
```
CAS = Central Authentication Server (中心认证服务器)
核心思想：所有的登录认证都由一个中心服务器来处理
其他应用系统只需要信任这个中心服务器的认证结果
```

**🌰 CAS生活类比**
就像学校的门卫大爷，所有人进校园都必须经过门卫的检查。门卫认可了，你就可以去教学楼、图书馆、食堂等任何地方，不需要每个地方都再查一遍身份证。

**🏗️ CAS架构图**
```
           用户浏览器
                │
        访问应用系统A
                │
            是否已登录？
           ╱           ╲
         否               是
        ╱                 ╲
   重定向到CAS          直接访问
   认证中心              应用系统A
        │                    │
    CAS登录界面         应用系统A界面
        │
    用户输入账号密码
        │
    CAS验证并生成票据
        │
    重定向回应用系统A
    (带着认证票据)
        │
    应用系统A验证票据
        │
    验证成功，用户登录
```

**💻 CAS实现示例**
```java
// CAS客户端配置
@Configuration
public class CasConfig {
    
    @Bean
    public ServiceProperties serviceProperties() {
        ServiceProperties properties = new ServiceProperties();
        properties.setService("http://app1.example.com/login/cas");
        return properties;
    }
    
    @Bean
    public CasAuthenticationFilter casAuthenticationFilter() {
        CasAuthenticationFilter filter = new CasAuthenticationFilter();
        filter.setServiceProperties(serviceProperties());
        return filter;
    }
}
```

### 5.2 分布式Session存储模式


**🗄️ Redis集中存储方案**
```
核心思想：
把所有应用的Session都存储在同一个Redis集群中
用户在任何应用中登录后，其他应用都能读取到Session信息
```

**📊 Redis Session架构**
```
负载均衡器
    │
┌───┼───┐
│   │   │
A1  A2  A3  (应用集群)
│   │   │
└───┼───┘
    │
Redis集群
(Session存储)
```

**🔧 实现配置**
```java
// Spring Boot Redis Session配置
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 7200)
public class RedisSessionConfig {
    
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        LettuceConnectionFactory factory = new LettuceConnectionFactory();
        factory.setHostName("redis.example.com");
        factory.setPort(6379);
        return factory;
    }
}
```

### 5.3 Token/JWT驱动的SSO


**🎫 JWT Token优势**
```
优点：
✅ 无状态：不需要在服务器端存储Session
✅ 跨域：可以在不同域名间传递
✅ 扩展性：易于水平扩展
✅ 移动端友好：APP可以很方便地使用

缺点：
❌ Token较大：包含用户信息，比Cookie大
❌ 无法主动失效：除非过期，否则一直有效
❌ 安全风险：如果Token泄露，攻击者可以冒充用户
```

**🔒 JWT安全实现**
```java
@Service
public class JwtService {
    
    private String secret = "mySecretKey";
    private long expiration = 7200; // 2小时
    
    // 生成Token
    public String generateToken(User user) {
        return Jwts.builder()
            .setSubject(user.getId())
            .claim("username", user.getUsername())
            .claim("roles", user.getRoles())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
            .signWith(SignatureAlgorithm.HS256, secret)
            .compact();
    }
    
    // 验证Token
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 5.4 SSO主要组件详解


**🔧 认证中心（SSO Server）**
```
职责：
- 提供统一的登录界面
- 验证用户身份（账号密码、手机验证等）
- 生成和管理认证票据/Token
- 处理单点退出
- 管理用户会话状态
```

**🖥️ 应用系统（SSO Client）**
```
职责：
- 检测用户是否已登录
- 重定向用户到认证中心
- 接收并验证认证票据
- 根据认证结果控制用户访问权限
```

**📋 认证协议**
```
常见协议：
- CAS协议：简单易用，适合传统Web应用
- OAuth 2.0：适合第三方授权场景
- SAML：企业级标准，功能强大但复杂
- OpenID Connect：基于OAuth 2.0的身份认证层
```

---

## 6. 🔄 SSO认证流程详解


### 6.1 完整认证流程示意图


**📋 标准SSO认证流程**
```
用户              应用系统A           SSO认证中心
 │                    │                    │
 │─[1]访问受保护资源─▶│                    │
 │                    │◀─[2]检查登录状态───│
 │                    │                    │
 │                    │─[3]重定向到SSO───▶│
 │◀─[4]显示登录页面───│                    │
 │                    │                    │
 │─[5]输入账号密码───▶│─[6]验证身份─────▶│
 │                    │                    │
 │                    │◀─[7]返回认证票据───│
 │◀─[8]重定向回应用───│                    │
 │                    │                    │
 │─[9]访问应用资源───▶│─[10]验证票据────▶│
 │                    │◀─[11]确认有效─────│
 │◀─[12]返回资源─────│                    │
```

### 6.2 第一次登录详细步骤


**🚀 初次登录流程**
```
1️⃣ 用户访问应用系统A的受保护页面
2️⃣ 应用系统A检查用户是否已登录
   - 检查本地Session/Cookie
   - 发现用户未登录
3️⃣ 应用系统A重定向用户到SSO认证中心
   - URL: https://sso.example.com/login?service=http://app1.example.com
4️⃣ SSO认证中心检查用户全局登录状态
   - 检查SSO的Session/Cookie
   - 发现用户未在任何地方登录
5️⃣ SSO认证中心显示登录页面
6️⃣ 用户输入用户名和密码
7️⃣ SSO认证中心验证用户身份
   - 查询用户数据库
   - 验证密码是否正确
8️⃣ 验证成功后，SSO认证中心：
   - 创建全局登录会话
   - 生成认证票据（如ST-12345）
   - 重定向回应用系统A: http://app1.example.com?ticket=ST-12345
9️⃣ 应用系统A接收到票据，向SSO认证中心验证票据
   - 请求: https://sso.example.com/validate?ticket=ST-12345&service=http://app1.example.com
🔟 SSO认证中心确认票据有效，返回用户信息
1️⃣1️⃣ 应用系统A创建本地会话，用户成功登录
```

### 6.3 访问其他系统的流程


**⚡ 已登录用户访问其他系统**
```
1️⃣ 用户访问应用系统B的受保护页面
2️⃣ 应用系统B检查用户是否已登录
   - 发现用户在本系统未登录
3️⃣ 应用系统B重定向用户到SSO认证中心
4️⃣ SSO认证中心检查用户全局登录状态
   - 发现用户已经在SSO中心登录过了
5️⃣ SSO认证中心直接生成新的认证票据
   - 无需再次输入密码
   - 重定向回应用系统B: http://app2.example.com?ticket=ST-67890
6️⃣ 应用系统B验证票据，创建本地会话
7️⃣ 用户直接进入系统B，实现了"单点登录"
```

### 6.4 单点退出流程


**🚪 Single Logout (SLO) 流程**
```
用户              应用系统A           SSO认证中心         应用系统B
 │                    │                    │                │
 │─[1]点击退出─────▶│                    │                │
 │                    │─[2]通知SSO退出──▶│                │
 │                    │                    │─[3]通知其他系统─▶│
 │                    │◀─[4]确认退出─────│◀─[5]确认退出───│
 │                    │─[6]清除本地会话──│                │
 │◀─[7]重定向到首页───│                    │                │
```

**💻 退出实现代码**
```java
@GetMapping("/logout")
public String logout(HttpServletRequest request, HttpServletResponse response) {
    // 1. 清除本地会话
    HttpSession session = request.getSession(false);
    if (session != null) {
        session.invalidate();
    }
    
    // 2. 清除Cookie
    Cookie cookie = new Cookie("JSESSIONID", null);
    cookie.setMaxAge(0);
    response.addCookie(cookie);
    
    // 3. 重定向到SSO退出页面，让SSO处理全局退出
    String ssoLogoutUrl = "https://sso.example.com/logout?service=" + 
                         URLEncoder.encode("http://app1.example.com", "UTF-8");
    return "redirect:" + ssoLogoutUrl;
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🔸 SSO本质理解**
```
单点登录 = 认证统一化 + 状态共享
核心：把登录这件事交给专门的服务来做
目标：用户只登录一次，就能访问所有系统
```

**🔸 技术实现方式**
```
🍪 Cookie共享：同域名下最简单的方式
🗄️ Session共享：传统集群应用的选择  
🎫 Token传递：前后端分离和微服务的首选
🏛️ 认证中心：企业级的完整解决方案
```

### 7.2 关键理解要点


**🔹 选择合适的方案**
```
技术选型决策：
- 系统规模：小规模用Cookie，大规模用认证中心
- 架构类型：传统Web用Session，前后端分离用Token
- 安全要求：高安全用认证中心，一般需求用Token
- 域名情况：同域名用Cookie，跨域名用Token或认证中心
```

**🔹 安全考虑要点**
```
安全风险：
- Token泄露：使用HTTPS，设置合理过期时间
- 会话劫持：IP验证，用户行为分析
- 跨站攻击：CSRF Token，同源策略
- 密码安全：强密码策略，多因素认证
```

### 7.3 实际应用建议


**💡 最佳实践**
```
开发建议：
✅ 选择成熟的SSO框架（如Spring Security、CAS）
✅ 设计良好的用户体验（无感知登录）
✅ 考虑移动端适配（Token方式更友好）
✅ 实现完整的监控和日志记录

运维建议：
✅ 认证中心高可用部署
✅ 定期更新安全策略
✅ 监控异常登录行为
✅ 建立应急响应机制
```

**🎯 技术发展趋势**
```
现代SSO发展方向：
- 零信任安全模型
- 生物识别认证
- 人工智能风险识别
- 无密码认证技术
```

### 7.4 学习进阶路径


**📚 学习建议**
```
基础阶段：
- 理解HTTP Session/Cookie机制
- 掌握JWT的原理和使用
- 了解OAuth 2.0基本概念

进阶阶段：
- 实践CAS系统搭建
- 学习SAML协议
- 研究OpenID Connect

高级阶段：
- 安全攻防技术
- 大规模分布式认证
- 跨云跨平台SSO
```

**🧠 记忆要点**
- SSO解决"一次登录，处处畅通"的问题
- 技术方案要根据实际场景选择
- 安全性和用户体验需要平衡考虑
- 认证中心是SSO的核心组件
- Token和Session是状态传递的两种主要方式

> 💡 **核心记忆**  
> SSO就像一张通行证，有了它就能在信任的系统间自由穿行。技术实现有多种方式，但核心思想都是"统一认证，状态共享"。选择哪种方式，主要看你的系统架构、安全需求和技术栈。