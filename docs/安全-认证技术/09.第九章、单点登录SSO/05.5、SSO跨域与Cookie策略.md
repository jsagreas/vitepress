---
title: 5、SSO跨域与Cookie策略
---
## 📚 目录

1. [单点登录基础概念](#1-单点登录基础概念)
2. [同域SSO与跨域SSO的区别](#2-同域SSO与跨域SSO的区别)
3. [Cookie作用域详解](#3-Cookie作用域详解)
4. [Cookie安全属性深入](#4-Cookie安全属性深入)
5. [跨域认证的实现方式](#5-跨域认证的实现方式)
6. [前后端分离场景下的SSO](#6-前后端分离场景下的SSO)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔑 单点登录基础概念


### 1.1 什么是单点登录（SSO）


> 💡 **简单理解**：一次登录，到处通行！就像用一张身份证可以在多个地方证明身份一样。

**单点登录（Single Sign-On，SSO）**：用户只需要登录一次，就可以访问多个相关的应用系统，无需重复输入用户名和密码。

```
传统模式：
用户 → 登录系统A → 输入账号密码
用户 → 登录系统B → 再次输入账号密码  
用户 → 登录系统C → 又要输入账号密码

SSO模式：
用户 → 登录认证中心 → 输入一次账号密码
用户 → 访问系统A → 自动登录 ✅
用户 → 访问系统B → 自动登录 ✅
用户 → 访问系统C → 自动登录 ✅
```

### 1.2 SSO的核心价值


**🎯 用户体验**：
- 减少重复登录操作
- 避免记忆多套账号密码
- 提高使用便利性

**🛡️ 安全管理**：
- 集中身份验证
- 统一密码策略
- 方便权限管控

**💼 企业效率**：
- 降低IT维护成本
- 提高员工工作效率
- 简化系统集成

### 1.3 SSO基本架构


```
SSO基本架构图：
                    ┌─────────────────┐
                    │   认证中心       │
                    │   (Auth Server) │
                    └─────────┬───────┘
                              │
                 ┌────────────┼────────────┐
                 │            │            │
           ┌─────▼────┐ ┌────▼────┐ ┌─────▼────┐
           │  应用A   │ │  应用B  │ │  应用C   │
           │(app-a.com)│ │(app-b.com)│ │(app-c.com)│
           └──────────┘ └─────────┘ └──────────┘
```

**核心组件说明**：
- **认证中心**：负责用户身份验证，颁发登录凭证
- **应用系统**：业务应用，信任认证中心的登录凭证
- **用户**：使用统一身份访问多个应用

---

## 2. 🌐 同域SSO与跨域SSO的区别


### 2.1 同域SSO（Same Domain SSO）


> 📖 **概念**：所有应用都在同一个域名下，比如都是 `company.com` 的子域名。

**典型场景**：
```
主站：www.company.com
邮箱：mail.company.com  
OA系统：oa.company.com
财务：finance.company.com
```

**实现原理**：
```
工作流程：
1. 用户访问 mail.company.com
2. 检查是否有登录Cookie（domain=.company.com）
3. 没有Cookie，跳转到 auth.company.com 登录
4. 登录成功，设置Cookie（domain=.company.com）
5. 跳转回 mail.company.com，携带Cookie自动登录
6. 用户再访问 oa.company.com 时，直接读取Cookie，无需重新登录
```

**优势**：
- ✅ **实现简单**：直接共享Cookie
- ✅ **性能好**：无需额外请求验证
- ✅ **安全性相对较高**：Cookie限制在同一域名下

**局限性**：
- ❌ **只能同域使用**：不同域名无法共享Cookie
- ❌ **灵活性差**：所有系统必须使用相同域名

### 2.2 跨域SSO（Cross Domain SSO）


> 📖 **概念**：应用系统分布在不同的域名下，需要特殊技术实现单点登录。

**典型场景**：
```
认证中心：auth.company.com
邮箱系统：mail.example.com
OA系统：oa.business.com  
合作伙伴：partner.other.com
```

**核心挑战**：
```
浏览器安全策略限制：
┌─────────────────────────────────────┐
│ 不同域名之间无法直接共享Cookie        │
│ example.com的Cookie无法被other.com读取 │
│ 需要特殊技术绕过这个限制            │
└─────────────────────────────────────┘
```

**实现难点**：
- 🚫 **Cookie隔离**：浏览器安全策略阻止跨域Cookie共享
- 🚫 **CORS限制**：跨域请求受到严格限制
- 🚫 **信任建立**：不同域名间需要建立信任关系

### 2.3 同域与跨域对比


| 对比项目 | **同域SSO** | **跨域SSO** |
|---------|------------|------------|
| **实现复杂度** | `简单` | `复杂` |
| **Cookie共享** | `直接共享` | `需要特殊处理` |
| **性能开销** | `很小` | `相对较大` |
| **安全风险** | `较低` | `需要额外防护` |
| **域名要求** | `必须同域` | `任意域名` |
| **维护成本** | `低` | `高` |

---

## 3. 🍪 Cookie作用域详解


### 3.1 Cookie基础概念


> 💡 **通俗理解**：Cookie就像浏览器给网站发放的"通行证"，网站通过这个通行证识别用户身份。

**Cookie的本质**：
- 存储在浏览器中的小文本文件
- 包含用户身份信息或状态数据
- 每次请求时自动发送给服务器

### 3.2 Cookie作用域机制


**Domain（域）属性**：

```javascript
// 设置Cookie的域属性示例
// 在 auth.company.com 上设置Cookie

// 只能在 auth.company.com 使用
document.cookie = "token=abc123; domain=auth.company.com";

// 可以在所有 *.company.com 子域使用  
document.cookie = "token=abc123; domain=.company.com";

// 可以在当前域及其子域使用
document.cookie = "token=abc123; domain=company.com";
```

**作用域规则图解**：
```
Domain设置说明：
                    company.com
                   /     |     \
              auth.     mail.   oa.
             company.  company. company.
               com       com     com

Cookie设置在 auth.company.com：
- domain=auth.company.com  → 只能在auth子域使用
- domain=.company.com      → 所有子域都能使用  
- domain=company.com       → 主域和子域都能使用
```

**Path（路径）属性**：

```javascript
// 路径限制示例
// 在 www.example.com/admin 设置

// 只能在 /admin 路径下使用
document.cookie = "admin_token=xyz; path=/admin";

// 可以在整个网站使用
document.cookie = "user_token=abc; path=/";

// 可以在 /api 路径下使用
document.cookie = "api_token=def; path=/api";
```

### 3.3 Cookie作用域实际应用


**同域SSO场景**：
```javascript
// 认证中心设置全域Cookie
function setSSoCookie(token) {
    // 设置Cookie可以被所有子域访问
    document.cookie = `sso_token=${token}; domain=.company.com; path=/; max-age=86400`;
}

// 应用系统读取SSO Cookie
function getSSoToken() {
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'sso_token') {
            return value;
        }
    }
    return null;
}
```

**跨域限制演示**：
```javascript
// 在 example.com 设置的Cookie
document.cookie = "token=abc123; domain=example.com";

// 在 other.com 尝试读取 - 失败！
console.log(document.cookie); // 无法读取到example.com的Cookie
```

---

## 4. 🔒 Cookie安全属性深入


### 4.1 SameSite属性详解


> 📖 **作用**：控制Cookie在跨站请求中的发送行为，防止CSRF攻击。

**SameSite的三个值**：

**Strict（严格模式）**：
```javascript
// 最严格的设置
document.cookie = "sensitive_token=abc123; SameSite=Strict";

// 行为说明：
// ✅ 同站请求：正常发送Cookie
// ❌ 跨站请求：完全不发送Cookie，包括用户点击链接
```

**Lax（宽松模式，默认值）**：
```javascript
// 平衡安全和可用性
document.cookie = "session_id=xyz789; SameSite=Lax";

// 行为说明：
// ✅ 同站请求：正常发送Cookie
// ✅ 用户主动导航（点击链接）：发送Cookie
// ❌ 异步请求（AJAX、fetch）：不发送Cookie
// ❌ 表单POST提交：不发送Cookie
```

**None（无限制）**：
```javascript
// 允许所有跨站请求，必须配合Secure使用
document.cookie = "api_token=def456; SameSite=None; Secure";

// 行为说明：
// ✅ 所有请求：都发送Cookie
// ⚠️ 必须使用HTTPS：SameSite=None强制要求Secure
```

### 4.2 Secure属性


> 🔐 **作用**：确保Cookie只在HTTPS连接中传输，防止中间人攻击。

```javascript
// 只在HTTPS下传输
document.cookie = "secure_token=abc123; Secure";

// 应用场景对比：
// HTTP网站：Cookie不会被发送 ❌
// HTTPS网站：Cookie正常发送 ✅
```

**实际应用**：
```javascript
// 生产环境设置
function setSecureCookie(name, value) {
    const isHttps = location.protocol === 'https:';
    const secureFlag = isHttps ? '; Secure' : '';
    
    document.cookie = `${name}=${value}; HttpOnly; SameSite=Lax${secureFlag}`;
}
```

### 4.3 HttpOnly属性


> 🛡️ **作用**：防止JavaScript读取Cookie，有效防范XSS攻击。

```javascript
// 服务端设置HttpOnly Cookie
// 注意：客户端JavaScript无法设置HttpOnly

// 服务端代码示例（Node.js）
app.post('/login', (req, res) => {
    const token = generateToken(user);
    
    // 设置HttpOnly Cookie，JavaScript无法读取
    res.cookie('auth_token', token, {
        httpOnly: true,    // 防止XSS攻击
        secure: true,      // 只在HTTPS传输
        sameSite: 'lax',   // 防止CSRF攻击
        maxAge: 86400000   // 24小时有效期
    });
    
    res.json({ success: true });
});
```

**安全对比**：
```javascript
// 不安全的做法
document.cookie = "token=abc123"; // JavaScript可读取，容易被XSS攻击

// 安全的做法（服务端设置）
// Set-Cookie: token=abc123; HttpOnly; Secure; SameSite=Lax
// JavaScript无法读取，但浏览器会自动发送
```

### 4.4 Cookie安全最佳实践


```javascript
// 💎 推荐的Cookie安全配置
const secureTokenConfig = {
    httpOnly: true,        // 防止XSS
    secure: true,          // 强制HTTPS
    sameSite: 'lax',       // 防止CSRF
    maxAge: 86400,         // 限制有效期
    domain: '.company.com', // 限制作用域
    path: '/'              // 限制路径
};

// 🚀 实际应用示例
app.use(session({
    name: 'sessionId',
    secret: process.env.SESSION_SECRET,
    cookie: secureTokenConfig,
    resave: false,
    saveUninitialized: false
}));
```

---

## 5. 🌉 跨域认证的实现方式


### 5.1 URL跳转方式


> 💡 **核心思想**：通过URL参数传递认证信息，实现跨域身份验证。

**实现流程**：
```
跳转认证流程：
1. 用户访问 app.example.com
2. 检测未登录，跳转到 auth.company.com?redirect=app.example.com
3. 用户在认证中心登录
4. 认证成功，跳转回 app.example.com?token=abc123
5. app.example.com 验证token，完成登录
```

**代码实现**：
```javascript
// 📁 应用系统：检查登录状态
function checkLogin() {
    const token = getTokenFromUrl() || localStorage.getItem('token');
    
    if (!token) {
        // 跳转到认证中心
        const currentUrl = encodeURIComponent(window.location.href);
        window.location.href = `https://auth.company.com/login?redirect=${currentUrl}`;
        return;
    }
    
    // 验证token有效性
    validateToken(token);
}

// 📁 从URL获取token
function getTokenFromUrl() {
    const params = new URLSearchParams(window.location.search);
    const token = params.get('token');
    
    if (token) {
        // 存储token并清理URL
        localStorage.setItem('token', token);
        history.replaceState({}, '', window.location.pathname);
        return token;
    }
    
    return null;
}

// 📁 认证中心：登录成功后跳转
function redirectAfterLogin(token, redirectUrl) {
    const url = new URL(redirectUrl);
    url.searchParams.set('token', token);
    window.location.href = url.toString();
}
```

**优势与不足**：
- ✅ **实现简单**：不需要复杂的技术
- ✅ **兼容性好**：所有浏览器都支持
- ❌ **安全风险**：token暴露在URL中
- ❌ **用户体验**：页面会跳转刷新

### 5.2 前端存储方式


> 💡 **核心思想**：使用localStorage、sessionStorage等前端存储技术保存认证信息。

**LocalStorage方案**：
```javascript
// 📁 认证中心：登录成功设置token
function handleLoginSuccess(userInfo, token) {
    // 存储到localStorage
    localStorage.setItem('sso_token', token);
    localStorage.setItem('user_info', JSON.stringify(userInfo));
    
    // 通知其他标签页
    window.dispatchEvent(new CustomEvent('sso_login', {
        detail: { token, userInfo }
    }));
}

// 📁 应用系统：检查认证状态
function checkAuthStatus() {
    const token = localStorage.getItem('sso_token');
    
    if (token) {
        // 验证token是否有效
        return validateTokenWithServer(token);
    }
    
    // 未登录，跳转到认证中心
    redirectToAuthCenter();
}

// 📁 监听其他标签页的登录事件
window.addEventListener('sso_login', (event) => {
    const { token, userInfo } = event.detail;
    
    // 同步登录状态
    updateUIForLoggedInUser(userInfo);
    startTokenRefreshTimer(token);
});
```

**PostMessage方案**：
```javascript
// 📁 应用系统：打开认证中心弹窗
function openAuthPopup() {
    const popup = window.open(
        'https://auth.company.com/login',
        'auth_popup',
        'width=400,height=500,scrollbars=yes'
    );
    
    // 监听认证结果
    window.addEventListener('message', (event) => {
        if (event.origin !== 'https://auth.company.com') return;
        
        if (event.data.type === 'SSO_SUCCESS') {
            // 认证成功
            const { token, userInfo } = event.data;
            localStorage.setItem('sso_token', token);
            popup.close();
            location.reload();
        }
    });
}

// 📁 认证中心：登录成功通知父窗口
function notifyParentWindow(token, userInfo) {
    if (window.opener) {
        window.opener.postMessage({
            type: 'SSO_SUCCESS',
            token: token,
            userInfo: userInfo
        }, '*');
        
        window.close();
    }
}
```

### 5.3 反向代理方式


> 💡 **核心思想**：通过服务器端代理，将认证中心的功能"伪装"成同域服务。

**架构设计**：
```
反向代理架构：
                用户浏览器
                     │
                     ▼
              ┌─────────────┐
              │   Nginx     │
              │ (代理服务器) │
              └─────────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
   ┌────▼───┐   ┌───▼────┐   ┌───▼────┐
   │ 应用A  │   │ 应用B  │   │认证中心│
   │        │   │        │   │        │
   └────────┘   └────────┘   └────────┘
```

**Nginx配置示例**：
```nginx
# 📁 nginx.conf
server {
    listen 80;
    server_name app.company.com;
    
    # 应用系统路由
    location / {
        proxy_pass http://app-server:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # 认证中心路由（伪装成同域）
    location /auth/ {
        proxy_pass http://auth-server:4000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # 透传Cookie
        proxy_cookie_domain auth-server.com app.company.com;
    }
}
```

**应用代码**：
```javascript
// 📁 应用系统：通过代理访问认证接口
async function checkAuthStatus() {
    try {
        // 通过代理访问认证中心API（看起来是同域请求）
        const response = await fetch('/auth/verify', {
            credentials: 'include' // 携带Cookie
        });
        
        if (response.ok) {
            const userInfo = await response.json();
            return userInfo;
        } else {
            // 未登录，跳转到代理的登录页面
            window.location.href = '/auth/login';
        }
    } catch (error) {
        console.error('认证检查失败:', error);
    }
}
```

### 5.4 三种方式对比


| 实现方式 | **复杂度** | **安全性** | **用户体验** | **维护成本** |
|---------|----------|----------|------------|------------|
| **URL跳转** | `低` | `中等` | `一般` | `低` |
| **前端存储** | `中等` | `较高` | `好` | `中等` |
| **反向代理** | `高` | `高` | `最好` | `高` |

---

## 6. 💻 前后端分离场景下的SSO


### 6.1 前后端分离的挑战


> 📖 **背景**：前端（Vue/React）和后端（API）分别部署，增加了SSO实现的复杂性。

**典型架构**：
```
前后端分离架构：
    前端应用              后端API              认证中心
  (Vue/React)           (Node.js/Java)        (Auth Server)
      │                      │                      │
  app.example.com      api.example.com      auth.company.com
```

**主要挑战**：
- 🚫 **跨域请求**：前端调用后端API存在跨域问题
- 🚫 **Cookie传递**：前后端不同域，Cookie无法自动传递
- 🚫 **状态同步**：前端需要知道用户登录状态

### 6.2 Token传递策略


**Authorization Header方案**：
```javascript
// 📁 前端：使用Header传递token
class ApiClient {
    constructor() {
        this.token = localStorage.getItem('access_token');
    }
    
    async request(url, options = {}) {
        const config = {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            }
        };
        
        // 添加认证头
        if (this.token) {
            config.headers['Authorization'] = `Bearer ${this.token}`;
        }
        
        const response = await fetch(url, config);
        
        // 处理token过期
        if (response.status === 401) {
            await this.refreshToken();
            // 重试请求
            config.headers['Authorization'] = `Bearer ${this.token}`;
            return fetch(url, config);
        }
        
        return response;
    }
    
    async refreshToken() {
        const refreshToken = localStorage.getItem('refresh_token');
        const response = await fetch('/auth/refresh', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ refresh_token: refreshToken })
        });
        
        if (response.ok) {
            const { access_token, refresh_token } = await response.json();
            this.token = access_token;
            localStorage.setItem('access_token', access_token);
            localStorage.setItem('refresh_token', refresh_token);
        } else {
            // 刷新失败，重新登录
            this.redirectToLogin();
        }
    }
}
```

**请求拦截器方案**：
```javascript
// 📁 使用axios拦截器
import axios from 'axios';

// 创建axios实例
const apiClient = axios.create({
    baseURL: 'https://api.example.com',
    timeout: 10000
});

// 请求拦截器：自动添加token
apiClient.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('access_token');
        if (token) {
            config.headers['Authorization'] = `Bearer ${token}`;
        }
        return config;
    },
    (error) => Promise.reject(error)
);

// 响应拦截器：处理token过期
apiClient.interceptors.response.use(
    (response) => response,
    async (error) => {
        const { response } = error;
        
        if (response?.status === 401) {
            try {
                // 尝试刷新token
                await refreshAccessToken();
                
                // 重新发送原请求
                const originalRequest = error.config;
                const newToken = localStorage.getItem('access_token');
                originalRequest.headers['Authorization'] = `Bearer ${newToken}`;
                
                return apiClient.request(originalRequest);
            } catch (refreshError) {
                // 刷新失败，跳转登录
                redirectToLogin();
                return Promise.reject(refreshError);
            }
        }
        
        return Promise.reject(error);
    }
);
```

### 6.3 跨域Cookie处理


**CORS配置**：
```javascript
// 📁 后端：正确的CORS配置
app.use(cors({
    origin: ['https://app.example.com', 'https://admin.example.com'],
    credentials: true, // 允许携带Cookie
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization']
}));

// 📁 前端：请求时携带Cookie
fetch('https://api.example.com/user', {
    method: 'GET',
    credentials: 'include', // 携带Cookie
    headers: {
        'Content-Type': 'application/json'
    }
});

// 使用axios时
axios.defaults.withCredentials = true;
```

**SameSite处理**：
```javascript
// 📁 后端：设置兼容的Cookie
app.post('/login', (req, res) => {
    const token = generateToken(user);
    
    res.cookie('session_token', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',
        maxAge: 24 * 60 * 60 * 1000, // 24小时
        domain: process.env.COOKIE_DOMAIN // 设置正确的域
    });
    
    res.json({ success: true });
});
```

### 6.4 前端状态管理


**Vue示例**：
```javascript
// 📁 store/auth.js - Vuex状态管理
export default {
    state: {
        user: null,
        token: localStorage.getItem('access_token'),
        isAuthenticated: false
    },
    
    mutations: {
        SET_USER(state, user) {
            state.user = user;
            state.isAuthenticated = !!user;
        },
        
        SET_TOKEN(state, token) {
            state.token = token;
            if (token) {
                localStorage.setItem('access_token', token);
            } else {
                localStorage.removeItem('access_token');
            }
        }
    },
    
    actions: {
        async checkAuth({ commit }) {
            const token = localStorage.getItem('access_token');
            if (!token) return;
            
            try {
                const response = await apiClient.get('/auth/me');
                commit('SET_USER', response.data);
            } catch (error) {
                // token无效，清除登录状态
                commit('SET_TOKEN', null);
                commit('SET_USER', null);
            }
        },
        
        async login({ commit }, credentials) {
            const response = await apiClient.post('/auth/login', credentials);
            const { token, user } = response.data;
            
            commit('SET_TOKEN', token);
            commit('SET_USER', user);
        },
        
        logout({ commit }) {
            commit('SET_TOKEN', null);
            commit('SET_USER', null);
        }
    }
};
```

**React示例**：
```javascript
// 📁 hooks/useAuth.js - React Hook
import { createContext, useContext, useReducer, useEffect } from 'react';

const AuthContext = createContext();

const authReducer = (state, action) => {
    switch (action.type) {
        case 'LOGIN':
            return {
                ...state,
                user: action.payload.user,
                token: action.payload.token,
                isAuthenticated: true
            };
        case 'LOGOUT':
            localStorage.removeItem('access_token');
            return {
                ...state,
                user: null,
                token: null,
                isAuthenticated: false
            };
        default:
            return state;
    }
};

export const AuthProvider = ({ children }) => {
    const [state, dispatch] = useReducer(authReducer, {
        user: null,
        token: localStorage.getItem('access_token'),
        isAuthenticated: false
    });
    
    useEffect(() => {
        // 应用启动时检查认证状态
        const checkAuth = async () => {
            if (state.token) {
                try {
                    const response = await fetch('/api/auth/me', {
                        headers: { 'Authorization': `Bearer ${state.token}` }
                    });
                    
                    if (response.ok) {
                        const user = await response.json();
                        dispatch({ type: 'LOGIN', payload: { user, token: state.token } });
                    } else {
                        dispatch({ type: 'LOGOUT' });
                    }
                } catch (error) {
                    dispatch({ type: 'LOGOUT' });
                }
            }
        };
        
        checkAuth();
    }, []);
    
    return (
        <AuthContext.Provider value={{ ...state, dispatch }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 SSO基本概念：一次登录，多处使用的身份认证机制
🔸 同域与跨域：Cookie共享的可行性决定实现复杂度
🔸 Cookie作用域：Domain和Path属性控制Cookie的访问范围
🔸 安全属性：SameSite、Secure、HttpOnly保障Cookie安全
🔸 跨域实现：URL跳转、前端存储、反向代理三种主要方式
🔸 前后端分离：Token传递和状态管理是关键挑战
```

### 7.2 关键理解要点


**🔹 Cookie安全的重要性**
```
理解要点：
- Cookie是SSO的核心载体，安全配置至关重要
- SameSite防止CSRF，Secure保证传输安全，HttpOnly防止XSS
- 生产环境必须启用所有安全属性
```

**🔹 跨域认证的选择策略**
```
选择原则：
- 简单场景：URL跳转方式，实现成本低
- 用户体验要求高：前端存储方式，无页面刷新
- 安全要求严格：反向代理方式，服务端控制
```

**🔹 前后端分离的最佳实践**
```
核心要点：
- Token存储在localStorage，通过Header传递
- 实现自动刷新机制，提升用户体验
- 正确配置CORS，支持跨域Cookie传递
```

### 7.3 实际应用指导


**📊 技术选型建议**：

| 应用场景 | **推荐方案** | **理由** |
|---------|------------|---------|
| **企业内部系统** | `同域SSO + Cookie` | `实现简单，安全性好` |
| **多品牌网站** | `跨域SSO + 反向代理` | `用户体验最佳` |
| **移动端应用** | `Token + JWT` | `无Cookie限制` |
| **第三方集成** | `OAuth 2.0` | `标准协议，兼容性好` |

**⚠️ 常见问题及解决方案**：

```
问题1：Cookie无法跨域共享
解决：使用postMessage或反向代理方案

问题2：SameSite=None要求HTTPS
解决：开发环境使用SameSite=Lax，生产环境使用HTTPS

问题3：前端刷新后登录状态丢失  
解决：页面加载时检查localStorage中的token

问题4：Token泄露安全风险
解决：使用短期token + refresh token机制
```

**🚀 最佳实践总结**：
- **安全第一**：始终启用Cookie安全属性
- **用户体验**：减少不必要的登录跳转
- **性能优化**：合理设置token过期时间
- **监控告警**：记录异常登录和token刷新失败
- **降级策略**：SSO服务故障时的备用方案

**核心记忆**：
- Cookie作用域决定SSO可行性
- 安全属性是Cookie防护的基石  
- 跨域认证需要特殊技术方案
- 前后端分离重点在状态同步