---
title: 8、常见加密算法基础与应用
---
## 📚 目录

1. [加密算法概述](#1-加密算法概述)
2. [对称加密（AES）](#2-对称加密AES)
3. [非对称加密（RSA）](#3-非对称加密RSA)
4. [哈希算法详解](#4-哈希算法详解)
5. [数字签名与加盐哈希](#5-数字签名与加盐哈希)
6. [签名校验机制](#6-签名校验机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔐 加密算法概述


### 1.1 什么是加密算法


**🔸 通俗理解**
```
加密就像给秘密信息"穿衣服"：
原文（明文）→ 加密过程 → 密文（加密后的内容）

举个例子：
明文：我爱你
加密：#$@%^&*
解密：我爱你

就像古代的密信，外人看不懂，只有知道密码的人才能读懂真正内容
```

**🎯 加密的核心目的**
- **机密性**：防止信息被窃取
- **完整性**：确保信息未被篡改  
- **身份认证**：确认信息来源
- **不可否认**：发送方无法否认已发送

### 1.2 加密算法的基本分类


```
加密算法家族树：

加密算法
├── 对称加密（钥匙相同）
│   ├── AES（现代主流）
│   ├── DES（已过时）
│   └── 3DES（逐渐淘汰）
│
├── 非对称加密（公钥私钥）
│   ├── RSA（最常用）
│   ├── ECC（移动设备友好）
│   └── DSA（主要用于签名）
│
└── 哈希算法（单向加密）
    ├── MD5（安全性低）
    ├── SHA1（逐渐淘汰）
    └── SHA256（当前主流）
```

**🔑 三种算法的根本区别**

| 类型 | **钥匙情况** | **主要用途** | **生活比喻** |
|-----|------------|------------|------------|
| **对称加密** | `同一把钥匙加密解密` | `大量数据加密` | `保险箱，一把钥匙开关` |
| **非对称加密** | `公钥加密，私钥解密` | `身份验证，密钥交换` | `邮箱，公开地址，私人钥匙取信` |
| **哈希算法** | `无钥匙，单向转换` | `数据完整性校验` | `指纹，唯一且不可逆` |

---

## 2. 🔒 对称加密（AES）


### 2.1 对称加密的基本原理


**🔸 核心概念**
```
对称加密就像一个"魔法盒子"：
- 用同一把钥匙锁住盒子（加密）
- 用同一把钥匙打开盒子（解密）
- 钥匙丢了，盒子里的东西就永远拿不出来了

实际过程：
明文 + 密钥 → [AES加密算法] → 密文
密文 + 密钥 → [AES解密算法] → 明文
```

**💡 为什么叫"对称"**
- 加密和解密使用**相同的密钥**
- 就像一把钥匙既能锁门也能开门
- 密钥必须**严格保密**，不能泄露

### 2.2 AES算法详解


**🎯 AES（Advanced Encryption Standard）是什么**
```
AES = 高级加密标准
- 美国政府官方加密标准（2001年确立）
- 目前世界上最安全、最广泛使用的对称加密算法
- 取代了老旧的DES算法

技术特点：
✅ 速度快：适合加密大量数据
✅ 安全性高：目前无法被暴力破解
✅ 标准化：各种编程语言都有实现
```

**🔧 AES的关键参数**

| 参数 | **含义** | **常用选项** | **安全性** |
|------|---------|------------|-----------|
| **密钥长度** | `密码的位数` | `128位、192位、256位` | `位数越高越安全` |
| **加密模式** | `数据处理方式` | `CBC、GCM、ECB等` | `不同模式安全性不同` |
| **填充方式** | `数据长度不够时的填充` | `PKCS7、PKCS5等` | `影响兼容性` |

**💻 AES加密示例（简化版）**
```javascript
// JavaScript中使用AES加密的概念示例
const crypto = require('crypto');

// 加密过程
function aesEncrypt(text, key) {
    const cipher = crypto.createCipher('aes-256-cbc', key);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
}

// 解密过程  
function aesDecrypt(encrypted, key) {
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

// 实际使用
const key = 'my-secret-key-123';
const text = '用户密码123456';

const encrypted = aesEncrypt(text, key);  // 加密
console.log('加密后:', encrypted);       // 输出乱码

const decrypted = aesDecrypt(encrypted, key); // 解密
console.log('解密后:', decrypted);       // 输出：用户密码123456
```

### 2.3 AES在实际项目中的应用


**🌟 常见使用场景**
```
数据库敏感信息：
- 用户密码（配合哈希使用）
- 身份证号、银行卡号
- 个人隐私数据

文件加密：
- 重要文档保护
- 数据传输加密
- 备份文件安全

API通信：
- 请求数据加密
- 响应数据保护
- 内部服务通信
```

**⚠️ 使用AES的注意事项**
```
密钥管理：
❌ 不要把密钥写在代码里
❌ 不要用简单的密码作为密钥
✅ 使用环境变量或专门的密钥管理系统

加密模式选择：
❌ 不要使用ECB模式（不安全）
✅ 推荐使用CBC或GCM模式

实际开发：
✅ 每次加密生成不同的结果（使用随机IV）
✅ 加密前验证数据合法性
✅ 异常处理要完善
```

---

## 3. 🗝️ 非对称加密（RSA）


### 3.1 非对称加密的革命性概念


**🔸 非对称加密解决了什么问题**
```
传统对称加密的困境：
你想给远方朋友发秘密信息 → 需要先把密钥告诉他 → 但如何安全传递密钥？

非对称加密的解决方案：
朋友生成一对钥匙：公钥（可公开）+ 私钥（严格保密）
你用他的公钥加密 → 只有他的私钥能解密 → 问题解决！

生活比喻：
公钥 = 银行账户号（可以告诉任何人）
私钥 = 银行卡密码（只有自己知道）
任何人都可以给你转账，但只有你能取钱
```

**🎯 公钥和私钥的关系**
```
数学关系：公钥和私钥是数学上配对的
- 公钥加密 → 私钥解密
- 私钥签名 → 公钥验证

实际应用：
用途1 - 加密通信：
  A用B的公钥加密 → B用自己的私钥解密

用途2 - 数字签名：
  A用自己的私钥签名 → 其他人用A的公钥验证
```

### 3.2 RSA算法深入理解


**🔢 RSA是什么**
```
RSA = Rivest-Shamir-Adleman（三位发明者的姓氏首字母）
- 1977年发明，最经典的非对称加密算法
- 基于大数分解的数学难题
- 目前互联网安全的基石之一

安全原理：
把两个大质数相乘很容易 → 但要分解乘积找出原来的质数很困难
RSA的安全性就建立在这个数学难题上
```

**🔧 RSA密钥长度与安全性**

| 密钥长度 | **安全级别** | **应用场景** | **性能影响** |
|---------|------------|------------|-------------|
| **1024位** | `较低（已不推荐）` | `老系统兼容` | `速度快` |
| **2048位** | `标准安全级别` | `当前主流应用` | `平衡点` |
| **4096位** | `高安全级别` | `重要系统` | `速度较慢` |

**💻 RSA加密解密示例**
```javascript
// Node.js中RSA的概念示例
const crypto = require('crypto');

// 1. 生成RSA密钥对
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
    modulusLength: 2048,  // 密钥长度2048位
    publicKeyEncoding: { type: 'spki', format: 'pem' },
    privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
});

console.log('公钥:', publicKey);
console.log('私钥:', privateKey);

// 2. 公钥加密
function rsaEncrypt(text, publicKey) {
    const buffer = Buffer.from(text, 'utf8');
    const encrypted = crypto.publicEncrypt(publicKey, buffer);
    return encrypted.toString('base64');
}

// 3. 私钥解密
function rsaDecrypt(encrypted, privateKey) {
    const buffer = Buffer.from(encrypted, 'base64');
    const decrypted = crypto.privateDecrypt(privateKey, buffer);
    return decrypted.toString('utf8');
}

// 实际使用
const message = '这是机密信息';
const encrypted = rsaEncrypt(message, publicKey);   // 公钥加密
const decrypted = rsaDecrypt(encrypted, privateKey); // 私钥解密

console.log('原文:', message);
console.log('加密后:', encrypted);
console.log('解密后:', decrypted);
```

### 3.3 RSA的实际应用场景


**🌍 HTTPS中的RSA**
```
网站访问过程中RSA的作用：

浏览器 ←→ 网站服务器

1. 浏览器请求网站 
2. 服务器发送包含RSA公钥的SSL证书
3. 浏览器验证证书真实性
4. 浏览器生成对称密钥，用RSA公钥加密后发送
5. 服务器用RSA私钥解密得到对称密钥
6. 双方用对称密钥进行后续通信（更快）

为什么不全程用RSA？
因为RSA速度慢，只用来交换对称密钥，实际数据传输用AES
```

**🔐 数字证书与PKI体系**
```
RSA在身份验证中的核心作用：

证书颁发机构(CA)
├── 用自己的私钥给网站证书签名
├── 浏览器内置CA的公钥
└── 浏览器用CA公钥验证网站证书

信任链条：
浏览器信任CA → CA为网站背书 → 浏览器信任网站 → 安全通信建立
```

---

## 4. 🔍 哈希算法详解


### 4.1 哈希算法的本质理解


**🔸 什么是哈希算法**
```
哈希就像"数据指纹"：
- 任何数据输入 → 固定长度的"指纹"输出
- 相同输入 → 相同指纹
- 不同输入 → 不同指纹（几乎不可能重复）
- 无法从指纹逆推出原数据

生活比喻：
就像每个人的指纹都是唯一的，但你不能从指纹反推出这个人的长相
哈希值就是数据的"身份证号"，用来识别但不能还原
```

**🎯 哈希算法的核心特性**
```
单向性（不可逆）：
- 原文 → 哈希值：很容易
- 哈希值 → 原文：几乎不可能

确定性：
- 同样的输入必定产生同样的输出
- "hello" → 总是产生相同的哈希值

雪崩效应：
- 输入微小变化 → 输出巨大变化
- "hello" 和 "Hello" 的哈希值完全不同

固定长度：
- 无论输入多长，输出长度固定
- 1个字符和1GB文件的哈希值长度相同
```

### 4.2 常见哈希算法对比


**📊 三大哈希算法家族**

| 算法 | **输出长度** | **安全性** | **速度** | **当前状态** | **典型用途** |
|------|------------|-----------|---------|-------------|-------------|
| **MD5** | `128位（32字符）` | `❌ 已不安全` | `🚀 很快` | `不推荐使用` | `文件校验（非安全场景）` |
| **SHA1** | `160位（40字符）` | `⚠️ 安全性降低` | `⚡ 较快` | `逐渐淘汰` | `Git版本控制（历史原因）` |
| **SHA256** | `256位（64字符）` | `✅ 高安全性` | `📈 中等` | `当前主流` | `密码存储、区块链、JWT` |

**💻 哈希算法实际示例**
```javascript
const crypto = require('crypto');

// 同一个输入的不同哈希算法结果
const input = 'Hello World';

// MD5哈希
const md5Hash = crypto.createHash('md5').update(input).digest('hex');
console.log('MD5:   ', md5Hash);     
// 输出：b10a8db164e0754105b7a99be72e3fe5

// SHA1哈希  
const sha1Hash = crypto.createHash('sha1').update(input).digest('hex');
console.log('SHA1:  ', sha1Hash);    
// 输出：0a4d55a8d778e5022fab701977c5d840bbc486d0

// SHA256哈希
const sha256Hash = crypto.createHash('sha256').update(input).digest('hex');
console.log('SHA256:', sha256Hash);  
// 输出：a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e

// 微小变化导致的巨大差异（雪崩效应）
const input2 = 'Hello world';  // 注意W变成了小写w
const sha256Hash2 = crypto.createHash('sha256').update(input2).digest('hex');
console.log('原文SHA256:', sha256Hash);
console.log('改后SHA256:', sha256Hash2);
// 两个哈希值完全不同！
```

### 4.3 哈希算法的实际应用


**🔐 密码存储（最重要的应用）**
```
❌ 错误做法：直接存储密码
数据库：用户名=张三，密码=123456
问题：数据库泄露 = 密码直接暴露

❌ 错误做法：简单哈希存储
数据库：用户名=张三，密码=e10adc3949ba59abbe56e057f20f883e（123456的MD5）
问题：彩虹表攻击，常见密码的哈希值已被预计算

✅ 正确做法：加盐哈希存储
数据库：用户名=张三，密码=哈希值，盐值=随机字符串
过程：密码+盐值 → SHA256 → 存储哈希值
```

**📁 文件完整性校验**
```
下载大文件时的完整性验证：

下载网站提供：
文件：ubuntu-20.04.iso (2.6GB)
SHA256：28ccdb56450e643bad03bb7bcf7507ce3d8d90e8bf09dfc696629728978a13de

你下载后计算：
本地文件SHA256：28ccdb56450e643bad03bb7bcf7507ce3d8d90e8bf09dfc696629728978a13de

对比结果：
- 相同 → 文件完整，没有损坏或被篡改
- 不同 → 文件有问题，需要重新下载
```

**🔗 区块链中的哈希**
```
比特币区块链中哈希的作用：

每个区块包含：
- 前一个区块的哈希值
- 当前区块的交易数据  
- 随机数（nonce）

通过哈希将区块连接成链：
区块1 → 哈希值A → 区块2 → 哈希值B → 区块3

任何区块被篡改 → 哈希值变化 → 链条断裂 → 篡改被发现
```

---

## 5. ✍️ 数字签名与加盐哈希


### 5.1 数字签名的概念与原理


**🔸 数字签名是什么**
```
数字签名 = 电子世界的"亲笔签名"

现实中的签名：
- 证明文件是你写的
- 别人无法伪造你的笔迹
- 你无法否认签过这个文件

数字签名：
- 证明数据是你发送的
- 别人无法伪造你的签名  
- 你无法否认发过这个数据
- 还能检测数据是否被篡改
```

**🔐 数字签名的工作原理**
```
签名过程（发送方）：
原始数据 → SHA256哈希 → 用私钥加密哈希值 → 数字签名

验证过程（接收方）：
1. 收到：原始数据 + 数字签名
2. 对原始数据计算SHA256哈希值  
3. 用发送方公钥解密数字签名得到哈希值
4. 比较两个哈希值是否相同

验证结果：
- 相同 → 签名有效，数据完整
- 不同 → 签名无效或数据被篡改
```

**💻 数字签名示例**
```javascript
const crypto = require('crypto');

// 1. 准备RSA密钥对
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
    modulusLength: 2048
});

// 2. 原始数据
const data = 'important contract content';

// 3. 创建数字签名
function createSignature(data, privateKey) {
    const sign = crypto.createSign('SHA256');
    sign.update(data);
    return sign.sign(privateKey, 'base64');
}

// 4. 验证数字签名
function verifySignature(data, signature, publicKey) {
    const verify = crypto.createVerify('SHA256');
    verify.update(data);
    return verify.verify(publicKey, signature, 'base64');
}

// 实际使用
const signature = createSignature(data, privateKey);
console.log('数字签名:', signature);

const isValid = verifySignature(data, signature, publicKey);
console.log('签名验证结果:', isValid ? '有效' : '无效');

// 测试数据篡改检测
const tamperedData = 'tampered contract content';
const isValidAfterTamper = verifySignature(tamperedData, signature, publicKey);
console.log('篡改后验证:', isValidAfterTamper ? '有效' : '无效'); // 输出：无效
```

### 5.2 加盐哈希的安全机制


**🧂 什么是"盐"（Salt）**
```
盐 = 随机生成的字符串，和密码混合后再哈希

没有盐的问题：
- 相同密码 → 相同哈希值
- 攻击者用彩虹表（预计算的哈希表）快速破解
- 123456 的MD5总是 e10adc3949ba59abbe56e057f20f883e

加盐后的效果：
- 密码123456 + 盐abc → 哈希值A  
- 密码123456 + 盐xyz → 哈希值B
- 相同密码产生不同哈希值，彩虹表失效
```

**🔒 加盐哈希的实现流程**
```
注册时：
1. 用户输入密码：123456
2. 系统生成随机盐：a8f5f167f44f4964e6c998dee827110c
3. 拼接：123456a8f5f167f44f4964e6c998dee827110c
4. SHA256哈希：ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
5. 存储：盐值 + 哈希值

登录验证时：
1. 用户输入密码：123456
2. 从数据库取出盐值：a8f5f167f44f4964e6c998dee827110c  
3. 拼接：123456a8f5f167f44f4964e6c998dee827110c
4. SHA256哈希：ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
5. 与数据库中的哈希值比较
6. 相同 → 密码正确，不同 → 密码错误
```

**💻 加盐哈希实现示例**
```javascript
const crypto = require('crypto');

// 生成随机盐值
function generateSalt() {
    return crypto.randomBytes(16).toString('hex');
}

// 加盐哈希函数
function hashPassword(password, salt) {
    return crypto.createHash('sha256').update(password + salt).digest('hex');
}

// 用户注册
function registerUser(username, password) {
    const salt = generateSalt();
    const hashedPassword = hashPassword(password, salt);
    
    // 存储到数据库（简化示例）
    const userRecord = {
        username: username,
        salt: salt,
        hashedPassword: hashedPassword
    };
    
    console.log('用户注册成功:', userRecord);
    return userRecord;
}

// 用户登录验证
function loginUser(username, inputPassword, userRecord) {
    const inputHash = hashPassword(inputPassword, userRecord.salt);
    
    if (inputHash === userRecord.hashedPassword) {
        console.log('登录成功');
        return true;
    } else {
        console.log('密码错误');
        return false;
    }
}

// 实际使用示例
const user = registerUser('张三', '123456');
// 输出：用户注册成功: {
//   username: '张三',
//   salt: '7d865e959b2466918c9863afca942d0f',
//   hashedPassword: '1a9f...'（很长的哈希值）
// }

loginUser('张三', '123456', user);  // 输出：登录成功
loginUser('张三', '错误密码', user);  // 输出：密码错误
```

### 5.3 现代密码存储最佳实践


**🛡️ 专业密码哈希算法**
```
❌ 不要用：MD5、SHA1、简单SHA256
原因：速度太快，容易被暴力破解

✅ 推荐使用：bcrypt、Argon2、PBKDF2
特点：计算缓慢，自带盐值，抗暴力破解

bcrypt的优势：
- 自动生成盐值
- 可调节计算复杂度
- 经过时间验证，广泛使用
```

**💻 bcrypt使用示例**
```javascript
const bcrypt = require('bcrypt');

// 注册用户
async function registerWithBcrypt(password) {
    const saltRounds = 12;  // 复杂度，数字越大越安全但越慢
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    console.log('bcrypt哈希结果:', hashedPassword);
    return hashedPassword;
}

// 登录验证
async function loginWithBcrypt(inputPassword, hashedPassword) {
    const isMatch = await bcrypt.compare(inputPassword, hashedPassword);
    console.log('密码验证结果:', isMatch ? '正确' : '错误');
    return isMatch;
}

// 实际使用
async function demo() {
    const hashed = await registerWithBcrypt('123456');
    // 输出：$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/lewohyFcYm5BpZ8lK
    
    await loginWithBcrypt('123456', hashed);     // 输出：正确  
    await loginWithBcrypt('错误密码', hashed);    // 输出：错误
}
```

---

## 6. 🔏 签名校验机制


### 6.1 JWT中的签名机制


**🔸 JWT签名的基本概念**
```
JWT = Header + Payload + Signature（签名）

JWT结构示例：
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

分解：
Header:    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
Payload:   eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9  
Signature: TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

**🔐 JWT签名的生成过程**
```
签名算法选择：
- HS256：HMAC + SHA256（对称加密，共享密钥）
- RS256：RSA + SHA256（非对称加密，公钥私钥）

HS256签名过程：
1. 准备数据：Header的base64 + "." + Payload的base64
2. 用密钥和HMAC-SHA256算法计算哈希
3. 对哈希结果进行base64编码
4. 得到最终签名

验证过程：
1. 收到JWT，拆分成三部分
2. 用相同密钥对Header+Payload重新计算签名
3. 与JWT中的签名比较
4. 相同 → JWT有效，不同 → JWT被篡改或伪造
```

**💻 JWT签名实现示例**
```javascript
const crypto = require('crypto');

// JWT简化实现
class SimpleJWT {
    constructor(secret) {
        this.secret = secret;
    }
    
    // Base64 URL编码（JWT专用）
    base64UrlEncode(str) {
        return Buffer.from(str).toString('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }
    
    // 生成签名
    sign(header, payload) {
        const encodedHeader = this.base64UrlEncode(JSON.stringify(header));
        const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));
        const data = `${encodedHeader}.${encodedPayload}`;
        
        const signature = crypto
            .createHmac('sha256', this.secret)
            .update(data)
            .digest('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
            
        return `${data}.${signature}`;
    }
    
    // 验证JWT
    verify(token) {
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('JWT格式错误');
        }
        
        const [headerB64, payloadB64, signature] = parts;
        const data = `${headerB64}.${payloadB64}`;
        
        // 重新计算签名
        const expectedSignature = crypto
            .createHmac('sha256', this.secret)
            .update(data)
            .digest('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
            
        // 比较签名
        if (signature !== expectedSignature) {
            throw new Error('JWT签名验证失败');
        }
        
        // 解析payload
        const payload = JSON.parse(Buffer.from(payloadB64, 'base64').toString());
        return payload;
    }
}

// 实际使用示例
const jwt = new SimpleJWT('my-secret-key-123');

// 创建JWT
const header = { typ: 'JWT', alg: 'HS256' };
const payload = { userId: 123, username: '张三', exp: Date.now() + 3600000 };
const token = jwt.sign(header, payload);

console.log('生成的JWT:', token);

// 验证JWT
try {
    const decoded = jwt.verify(token);
    console.log('JWT验证成功，用户信息:', decoded);
} catch (error) {
    console.log('JWT验证失败:', error.message);
}

// 测试篡改检测
const tamperedToken = token.slice(0, -5) + 'XXXXX';  // 篡改签名
try {
    jwt.verify(tamperedToken);
} catch (error) {
    console.log('篡改检测成功:', error.message);  // 输出：JWT签名验证失败
}
```

### 6.2 API签名校验机制


**🔸 API签名的应用场景**
```
为什么需要API签名：
- 防止请求被篡改
- 验证请求来源身份
- 防止重放攻击
- 保证数据传输完整性

常见应用：
- 支付接口（微信支付、支付宝）
- 开放平台API（微博、QQ登录）
- 企业级API接口
- 区块链交易验证
```

**🔧 API签名的标准流程**
```
签名生成过程：
1. 收集请求参数（包括时间戳、随机数）
2. 按字母顺序排序参数
3. 拼接成查询字符串格式
4. 加入密钥
5. 计算哈希值作为签名
6. 将签名添加到请求中

验证过程：
1. 接收到请求后提取参数和签名
2. 按相同规则重新计算签名
3. 比较计算的签名和请求中的签名
4. 相同则验证通过，不同则拒绝请求
```

**💻 API签名实现示例**
```javascript
const crypto = require('crypto');

// API签名工具类
class APISignature {
    constructor(appKey, appSecret) {
        this.appKey = appKey;
        this.appSecret = appSecret;
    }
    
    // 生成签名
    generateSignature(params) {
        // 添加公共参数
        const fullParams = {
            ...params,
            app_key: this.appKey,
            timestamp: Date.now(),
            nonce: Math.random().toString(36).substring(2)
        };
        
        // 按key排序
        const sortedKeys = Object.keys(fullParams).sort();
        
        // 拼接字符串
        let queryString = '';
        sortedKeys.forEach(key => {
            queryString += `${key}=${fullParams[key]}&`;
        });
        
        // 加入密钥
        queryString += `key=${this.appSecret}`;
        
        // 计算MD5签名（实际建议用SHA256）
        const signature = crypto.createHash('md5').update(queryString).digest('hex');
        
        return {
            ...fullParams,
            signature: signature
        };
    }
    
    // 验证签名
    verifySignature(params) {
        const receivedSignature = params.signature;
        delete params.signature;  // 移除签名参数
        
        // 重新生成签名进行比较
        const calculatedParams = this.generateSignature(params);
        
        return receivedSignature === calculatedParams.signature;
    }
}

// 客户端使用示例
const client = new APISignature('app123', 'secret456');

// 发送API请求
const requestParams = {
    user_id: 12345,
    action: 'get_profile',
    format: 'json'
};

const signedParams = client.generateSignature(requestParams);
console.log('签名后的请求参数:', signedParams);

// 服务端验证示例  
const server = new APISignature('app123', 'secret456');
const isValid = server.verifySignature({...signedParams});
console.log('签名验证结果:', isValid ? '有效' : '无效');

// 测试篡改检测
const tamperedParams = {...signedParams, user_id: 99999};  // 篡改参数
const isValidAfterTamper = server.verifySignature(tamperedParams);
console.log('篡改后验证:', isValidAfterTamper ? '有效' : '无效');  // 输出：无效
```

### 6.3 签名校验的安全考虑


**⚠️ 常见安全问题与防护**
```
时间戳验证：
问题：重放攻击（重复使用旧的有效请求）
解决：加入时间戳，拒绝超时的请求
示例：timestamp参数，服务端只接受5分钟内的请求

随机数验证：
问题：即使有时间戳，仍可能在时间窗口内重放
解决：加入随机数(nonce)，服务端记录已使用的随机数
示例：nonce参数，相同随机数只能使用一次

密钥安全：
问题：密钥泄露导致签名可被伪造
解决：密钥定期更换，不同客户端使用不同密钥
示例：每月更换密钥，每个APP分配独立密钥
```

**🛡️ 签名算法选择建议**
```
❌ 不推荐：MD5
原因：安全性较低，可能被碰撞攻击

⚠️ 谨慎使用：SHA1  
原因：安全性下降，逐渐被淘汰

✅ 推荐使用：HMAC-SHA256
原因：安全性高，性能好，广泛支持

✅ 高安全场景：RSA-SHA256
原因：非对称加密，私钥不需要共享
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 对称加密（AES）：一把钥匙加密解密，速度快，适合大量数据
🔸 非对称加密（RSA）：公钥私钥配对，解决密钥分发问题
🔸 哈希算法：数据指纹，单向不可逆，用于完整性校验
🔸 数字签名：电子签名，防篡改和身份认证
🔸 加盐哈希：防彩虹表攻击的密码存储方式
🔸 JWT签名：Token完整性保护机制
```

### 7.2 关键理解要点


**🔹 三种加密方式的适用场景**
```
对称加密场景：
✅ 大文件加密（视频、文档）
✅ 数据库敏感字段加密
✅ 内部系统通信加密

非对称加密场景：
✅ 初次密钥交换
✅ 数字签名和身份验证
✅ HTTPS证书验证

哈希算法场景：
✅ 密码存储（配合盐值）
✅ 文件完整性检验
✅ 数字签名的摘要计算
```

**🔹 安全性考虑的优先级**
```
密码存储安全等级：
1. bcrypt/Argon2 + 随机盐（推荐）
2. SHA256 + 随机盐（可接受）
3. MD5 + 盐（不推荐）
4. 明文存储（绝对禁止）

哈希算法安全等级：
1. SHA256/SHA384/SHA512（当前主流）
2. SHA1（逐渐淘汰）
3. MD5（已不安全，仅用于非安全场景）
```

### 7.3 实际开发应用指南


**💡 密码存储最佳实践**
```javascript
// ✅ 推荐做法
const bcrypt = require('bcrypt');
const saltRounds = 12;
const hashedPassword = await bcrypt.hash(userPassword, saltRounds);

// ❌ 不要这样做
const crypto = require('crypto');
const hashedPassword = crypto.createHash('md5').update(userPassword).digest('hex');
```

**🔐 JWT使用建议**
```javascript
// ✅ 正确的JWT配置
const jwt = require('jsonwebtoken');
const token = jwt.sign(
    { userId: user.id, role: user.role },
    process.env.JWT_SECRET,  // 使用环境变量
    { 
        expiresIn: '2h',     // 设置过期时间
        algorithm: 'HS256'   // 明确指定算法
    }
);

// ❌ 不安全的做法
const token = jwt.sign(userData, 'simple-key', { algorithm: 'none' });
```

**🛡️ API安全防护清单**
- [x] **使用HTTPS**：保证传输层安全
- [x] **实现签名校验**：防止请求篡改
- [x] **添加时间戳验证**：防止重放攻击
- [x] **使用随机数**：增强安全性
- [x] **密钥定期更换**：降低泄露风险
- [x] **日志记录异常**：便于安全监控

### 7.4 常见错误与避免方法


**❌ 常见安全错误**
```
错误1：把密钥硬编码在代码中
影响：代码泄露 = 密钥泄露
正确：使用环境变量或密钥管理服务

错误2：使用弱哈希算法（MD5、SHA1）
影响：容易被破解
正确：使用SHA256或更安全的bcrypt

错误3：不验证JWT签名
影响：Token可被任意伪造
正确：始终验证签名有效性

错误4：忽略时间戳验证
影响：容易遭受重放攻击
正确：检查请求时间戳的有效性
```

**✅ 安全开发检查清单**
- 🔍 **代码审查**：检查是否有硬编码密钥
- 🧪 **安全测试**：测试各种攻击场景
- 📊 **监控告警**：建立安全异常监控
- 📚 **团队培训**：提高团队安全意识
- 🔄 **定期更新**：及时更新安全库版本

**核心记忆口诀**：
- 对称加密速度快，大量数据它来加
- 非对称解决分发难，公钥私钥配成对  
- 哈希算法像指纹，完整校验不可逆
- 数字签名防篡改，身份认证有保障
- 密码存储要加盐，彩虹表攻击防得住
- JWT签名保完整，API调用更安全