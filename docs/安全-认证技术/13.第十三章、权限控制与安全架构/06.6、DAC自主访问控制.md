---
title: 6、DAC自主访问控制
---
## 📚 目录

1. [DAC自主访问控制基础](#1-DAC自主访问控制基础)
2. [DAC核心特点解析](#2-DAC核心特点解析)
3. [实现机制深度讲解](#3-实现机制深度讲解)
4. [Unix权限系统详解](#4-Unix权限系统详解)
5. [Windows权限体系](#5-Windows权限体系)
6. [数据库权限控制](#6-数据库权限控制)
7. [文件系统权限机制](#7-文件系统权限机制)
8. [云存储权限管理](#8-云存储权限管理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 DAC自主访问控制基础


### 1.1 什么是DAC


**🎯 简单理解**：DAC就是"**谁拥有资源，谁说了算**"的权限控制方式

```
生活中的例子：
你的手机 → 你决定谁能用
你的房子 → 你决定给谁钥匙
你的文件 → 你决定谁能看、谁能改

DAC核心思想：资源的所有者有完全的控制权
```

**🔸 DAC全称**：`Discretionary Access Control` - 自主访问控制

> 💡 **关键理解**：为什么叫"自主"？因为资源所有者可以**自主决定**把权限给谁，怎么给

### 1.2 DAC的基本工作原理


**🔄 权限控制流程**：

```
用户请求访问资源
      ↓
检查用户身份
      ↓
查看资源的权限设置 ←── 所有者之前设定的规则
      ↓
匹配用户权限
      ↓
允许/拒绝访问
```

**📋 核心要素**：
- **👤 主体**：想要访问资源的用户或程序
- **📄 客体**：被访问的资源（文件、数据库、网页等）
- **🔑 权限**：能做什么操作（读、写、执行等）
- **👑 所有者**：决定权限分配的人

---

## 2. ⭐ DAC核心特点解析


### 2.1 所有者控制 - 核心特征


**🔸 什么是所有者控制**：

> 🎯 **简单说**：谁创建的文件，谁就是老板，想给谁权限就给谁权限

```
实际例子：
小王写了一个文档 document.txt
→ 小王是所有者
→ 小王可以决定：
  ✅ 小李能看但不能改
  ✅ 小张能看能改
  ❌ 小陈完全不能访问
```

**💻 系统体现**：
```bash
# Linux中查看文件所有者
ls -l myfile.txt
-rw-r--r-- 1 xiaowang staff 1024 Aug 12 10:30 myfile.txt
#            ↑
#         所有者是xiaowang
```

### 2.2 灵活授权 - 使用简单


**🔸 什么是灵活授权**：

> 💡 **通俗解释**：权限可以随意调整，想给就给，想收回就收回

| 传统方式 | DAC方式 |
|---------|---------|
| 📋 **固定角色** | 🎯 **自由分配** |
| `只能按部门给权限` | `可以给任何人任何权限` |
| `权限变更需要管理员` | `所有者自己就能改` |
| `权限模式单一` | `权限组合灵活` |

**🔧 灵活授权示例**：
```bash
# 给不同人不同权限
chmod 754 project.txt    # 所有者：读写执行，组：读执行，其他：读
chmod 644 document.txt   # 所有者：读写，组：读，其他：读
chmod 700 private.txt    # 只有所有者能访问
```

### 2.3 易用性 - 学会就能用


**🔸 为什么易用**：

> 🎯 **关键**：权限概念直观，符合人的直觉思维

```
直观理解：
🏠 我的房子 → 我决定谁能进
📱 我的手机 → 我决定谁能用  
💻 我的文件 → 我决定谁能看

技术实现也很直观：
- 读权限 = 能看内容
- 写权限 = 能修改内容  
- 执行权限 = 能运行程序
```

**📊 易用性对比**：

| 访问控制类型 | **学习难度** | **配置复杂度** | **理解难度** |
|-------------|-------------|---------------|-------------|
| 🟢 **DAC** | `简单` | `低` | `直观` |
| 🟡 **RBAC** | `中等` | `中等` | `需要理解角色概念` |
| 🔴 **MAC** | `困难` | `高` | `需要理解安全级别` |

---

## 3. 🔧 实现机制深度讲解


### 3.1 ACL访问控制列表


**🔸 什么是ACL**：

> 💡 **通俗解释**：ACL就像一个"**权限清单**"，详细记录了谁能对这个文件做什么

```
想象成门禁卡系统：
办公室门上贴着一张名单：
- 张三：可以进入、可以开灯
- 李四：只能进入、不能开灯  
- 王五：完全不能进入

ACL就是这张"数字版名单"
```

**📋 ACL基本结构**：
```
资源：/home/user/document.txt
ACL列表：
┌──────────────┬──────────────┬──────────────┐
│   用户/组    │     权限     │     说明     │
├──────────────┼──────────────┼──────────────┤
│ user:alice   │ rw-          │ Alice能读写  │
│ user:bob     │ r--          │ Bob只能读    │
│ group:team   │ r--          │ team组能读   │
│ other        │ ---          │ 其他人无权限  │
└──────────────┴──────────────┴──────────────┘
```

**💻 实际操作示例**：
```bash
# 查看文件的ACL
getfacl document.txt
# 输出：
# user::rw-
# user:alice:rw-
# user:bob:r--
# group::r--
# other::---

# 给用户添加权限
setfacl -m u:charlie:rw document.txt

# 删除用户权限  
setfacl -x u:bob document.txt
```

### 3.2 权限位机制


**🔸 什么是权限位**：

> 🎯 **简单说**：用几个数字或字母来表示权限，像密码一样简洁

```
权限位就像开关：
r (read)    → 📖 阅读开关  
w (write)   → ✏️ 写入开关
x (execute) → ⚡ 执行开关

开关状态：
开 = 1 = 有权限
关 = 0 = 无权限
```

**🔢 权限位计算**：

| 权限 | **二进制** | **十进制** | **含义** |
|------|-----------|-----------|----------|
| `---` | `000` | `0` | 无任何权限 |
| `--x` | `001` | `1` | 只能执行 |
| `-w-` | `010` | `2` | 只能写 |
| `-wx` | `011` | `3` | 能写能执行 |
| `r--` | `100` | `4` | 只能读 |
| `r-x` | `101` | `5` | 能读能执行 |
| `rw-` | `110` | `6` | 能读能写 |
| `rwx` | `111` | `7` | 完全权限 |

**🔧 实际应用**：
```bash
# 755 的含义
7 = rwx = 所有者有完全权限
5 = r-x = 组用户能读和执行  
5 = r-x = 其他用户能读和执行

chmod 755 myscript.sh  # 设置权限
```

---

## 4. 🐧 Unix权限系统详解


### 4.1 rwx权限位系统


**🔸 Unix权限的三层结构**：

```
文件权限显示：-rwxr-xr--
                ↓
分解分析：
- ：文件类型（-=普通文件，d=目录，l=链接）
rwx：所有者权限（owner）
r-x：组权限（group） 
r--：其他用户权限（others）
```

**📊 权限对象详解**：

| 对象类型 | **符号** | **说明** | **实际含义** |
|---------|---------|---------|-------------|
| 🙋 **所有者** | `u (user)` | `文件创建者` | `拥有最高控制权` |
| 👥 **组** | `g (group)` | `所有者所在的用户组` | `共享部分权限` |
| 🌐 **其他** | `o (others)` | `系统中的其他用户` | `一般权限最少` |

**💻 权限修改实践**：
```bash
# 符号模式修改权限
chmod u+w file.txt      # 给所有者添加写权限
chmod g-x file.txt      # 移除组的执行权限  
chmod o+r file.txt      # 给其他用户添加读权限
chmod a+x file.txt      # 给所有人添加执行权限(a=all)

# 数字模式修改权限
chmod 644 document.txt  # rw-r--r--
chmod 755 program.exe   # rwxr-xr-x
chmod 600 secret.txt    # rw-------（只有所有者能读写）
```

### 4.2 特殊权限详解


**🔸 SUID (Set User ID)**：

> 💡 **通俗解释**：程序运行时"变身"成文件所有者来执行

```
实际例子：
passwd 命令需要修改 /etc/shadow 文件
普通用户没权限修改这个文件
但是 passwd 设置了 SUID
运行时就"变身"成 root 用户
所以能成功修改密码
```

```bash
# 查看SUID权限
ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 68208 passwd*
#   ↑ s表示有SUID权限

# 设置SUID
chmod u+s myprogram
chmod 4755 myprogram  # 数字方式，4表示SUID
```

**🔸 SGID (Set Group ID)**：

> 💡 **作用**：程序运行时使用文件所属组的权限

```bash
# 目录设置SGID后
# 在其中创建的文件会自动属于该目录的组
chmod g+s shared_folder
chmod 2755 shared_folder  # 数字方式，2表示SGID
```

**🔸 Sticky Bit（粘着位）**：

> 💡 **通俗解释**：在共享目录中，只有文件所有者才能删除自己的文件

```
典型应用：/tmp 目录
所有人都能在里面创建文件
但只能删除自己的文件
不能删除别人的文件
```

```bash
# /tmp目录的权限
ls -ld /tmp
drwxrwxrwt 8 root root 4096 /tmp/
#       ↑ t表示有sticky bit

chmod +t shared_dir
chmod 1755 shared_dir  # 数字方式，1表示sticky bit
```

### 4.3 umask默认权限


**🔸 什么是umask**：

> 💡 **简单理解**：umask是"**权限过滤器**"，决定新文件的默认权限

```
umask工作原理：
最大权限 - umask = 实际权限

文件最大权限：666 (rw-rw-rw-)
目录最大权限：777 (rwxrwxrwx)

如果 umask = 022
新文件权限：666 - 022 = 644 (rw-r--r--)
新目录权限：777 - 022 = 755 (rwxr-xr-x)
```

**🔧 umask实际操作**：
```bash
# 查看当前umask
umask
# 输出：0022

# 查看umask的符号表示
umask -S  
# 输出：u=rwx,g=rx,o=rx

# 临时修改umask
umask 002  # 让组用户也有写权限

# 测试新文件权限
touch testfile
ls -l testfile
# -rw-rw-r-- 1 user group 0 testfile
```

---

## 5. 🪟 Windows权限体系


### 5.1 DACL权限控制


**🔸 什么是DACL**：

> 💡 **通俗解释**：DACL就是Windows版本的"权限清单"，比Unix的权限更详细

```
DACL = Discretionary Access Control List
中文：自主访问控制列表

想象成酒店房间的权限卡：
不同的客人有不同级别的房卡
- VIP卡：能开所有门，使用所有设施
- 普通卡：只能开自己房间的门
- 员工卡：能开工作区域的门
```

**📋 Windows权限类型**：

| 权限类型 | **说明** | **实际作用** |
|---------|---------|-------------|
| 🔓 **完全控制** | `Full Control` | `能做任何操作，包括修改权限` |
| ✏️ **修改** | `Modify` | `能读写删除，但不能改权限` |
| 📝 **读取和执行** | `Read & Execute` | `能看内容和运行程序` |
| 📖 **读取** | `Read` | `只能查看内容` |
| ✍️ **写入** | `Write` | `能创建和修改文件` |

### 5.2 继承机制


**🔸 什么是权限继承**：

> 💡 **生活比喻**：就像"父债子还"，父目录的权限会自动传给子文件和子目录

```
继承示例：
项目文件夹/
├── 文档/          ← 继承父目录权限
│   ├── 报告.doc   ← 继承"文档"目录权限
│   └── 数据.xlsx  ← 继承"文档"目录权限  
└── 代码/          ← 继承父目录权限
    ├── main.py    ← 继承"代码"目录权限
    └── test.py    ← 继承"代码"目录权限
```

**🔧 继承控制**：
```powershell
# 查看文件权限（PowerShell）
Get-Acl "C:\MyFolder" | Format-Table

# 禁用继承
icacls "C:\MyFolder" /inheritance:d

# 启用继承
icacls "C:\MyFolder" /inheritance:e
```

### 5.3 有效权限计算


**🔸 什么是有效权限**：

> 💡 **关键理解**：用户实际拥有的权限 = 所有权限来源的综合计算结果

```
权限来源：
1. 直接分配给用户的权限
2. 用户所属组的权限  
3. 从父目录继承的权限

计算规则：
✅ 允许权限：取所有来源的并集（最宽松）
❌ 拒绝权限：优先级最高（一票否决）
```

**📊 有效权限示例**：

| 权限来源 | **读取** | **写入** | **执行** | **删除** |
|---------|---------|---------|---------|---------|
| 用户权限 | ✅ 允许 | ❌ 拒绝 | ✅ 允许 | ✅ 允许 |
| 组权限 | ✅ 允许 | ✅ 允许 | ❌ 拒绝 | ✅ 允许 |
| **有效权限** | **✅ 允许** | **❌ 拒绝** | **❌ 拒绝** | **✅ 允许** |

---

## 6. 🗄️ 数据库权限控制


### 6.1 表权限管理


**🔸 什么是表权限**：

> 💡 **通俗解释**：表权限就是控制谁能对整张表做什么操作

```
表权限就像图书馆的区域管制：
- 有些人能进阅览区看书
- 有些人能进书库拿书  
- 有些人能进管理区修改图书信息
- 管理员能决定哪些书放在哪里
```

**📋 常见表权限**：

| 权限类型 | **SQL关键字** | **作用** | **实际含义** |
|---------|-------------|---------|-------------|
| 👀 **查询** | `SELECT` | `读取数据` | `能看表里的内容` |
| ➕ **插入** | `INSERT` | `添加数据` | `能往表里加新记录` |
| ✏️ **更新** | `UPDATE` | `修改数据` | `能改表里的内容` |
| 🗑️ **删除** | `DELETE` | `删除数据` | `能从表里删记录` |
| 🔧 **修改结构** | `ALTER` | `改表结构` | `能加字段、改字段类型等` |

**💻 权限操作示例**：
```sql
-- 给用户分配查询权限
GRANT SELECT ON employees TO user_alice;

-- 给用户分配多种权限  
GRANT SELECT, INSERT, UPDATE ON products TO user_bob;

-- 给用户分配所有权限
GRANT ALL ON orders TO user_admin;

-- 撤销权限
REVOKE INSERT ON products FROM user_bob;

-- 查看用户权限
SHOW GRANTS FOR user_alice;
```

### 6.2 列权限精细控制


**🔸 什么是列权限**：

> 💡 **通俗解释**：列权限能精确控制到某个用户只能看或改表中的特定列

```
实际应用场景：
员工表有这些列：姓名、部门、工资、身份证号

不同角色的权限：
👤 普通员工：只能看 姓名、部门
💼 部门经理：能看 姓名、部门、工资  
👑 HR：能看所有列，能修改除工资外的列
💰 财务：能看所有列，只能修改工资列
```

**💻 列权限设置**：
```sql
-- 只给特定列的查询权限
GRANT SELECT (name, department) ON employees TO regular_user;

-- 给特定列的更新权限
GRANT UPDATE (salary) ON employees TO finance_user;

-- 组合权限
GRANT SELECT (name, department, salary), 
      UPDATE (department) ON employees TO manager_user;
```

### 6.3 行级安全控制


**🔸 什么是行级安全**：

> 💡 **关键理解**：行级安全能让不同用户看到同一张表的不同内容

```
典型场景：
销售表中有全国所有地区的销售数据
北京经理：只能看北京地区的数据  
上海经理：只能看上海地区的数据
总经理：能看所有地区的数据

同一张表，不同用户看到不同行！
```

**🔧 行级安全实现**：
```sql
-- PostgreSQL 行级安全示例
-- 创建安全策略
ALTER TABLE sales_data ENABLE ROW LEVEL SECURITY;

-- 普通用户只能看自己地区的数据
CREATE POLICY user_region_policy ON sales_data
    FOR SELECT TO sales_user
    USING (region = current_user_region());

-- 经理能看自己管辖地区的数据  
CREATE POLICY manager_policy ON sales_data
    FOR ALL TO manager_user  
    USING (region IN (SELECT managed_region FROM manager_regions 
                     WHERE manager = current_user));
```

---

## 7. 📁 文件系统权限机制


### 7.1 NTFS权限系统


**🔸 NTFS权限特点**：

> 💡 **核心优势**：NTFS权限比FAT32更精细，支持用户级别的权限控制

```
NTFS vs FAT32权限对比：

FAT32文件系统：
- 没有用户概念
- 所有人权限相同  
- 要么能访问，要么不能访问

NTFS文件系统：  
- 支持多用户
- 每个用户可以有不同权限
- 权限可以精确到文件级别
```

**📋 NTFS权限类型详解**：

| 权限级别 | **包含的具体权限** | **实际能做什么** |
|---------|------------------|----------------|
| 🔓 **完全控制** | `所有权限 + 修改权限` | `想干啥都行，包括改权限` |
| ✏️ **修改** | `读取+写入+执行+删除` | `能改内容但不能改权限` |
| 📝 **读取和执行** | `读取+执行` | `能看能运行但不能改` |
| 📂 **列出文件夹内容** | `读取+执行（仅文件夹）` | `能看文件夹里有什么` |
| 📖 **读取** | `读取` | `只能看内容` |
| ✍️ **写入** | `写入` | `只能创建文件和文件夹` |

### 7.2 ext4 ACL扩展权限


**🔸 ext4 ACL功能**：

> 💡 **突破限制**：传统Linux权限只有所有者、组、其他三类，ACL能给任意用户设置权限

```bash
# 传统权限的局限：
chmod 755 project/
# 只能设置：所有者、组、其他人的权限
# 如果想给某个特定用户权限，就很难办

# ACL解决方案：
setfacl -m u:alice:rwx project/    # 给alice完全权限
setfacl -m u:bob:r-- project/      # 给bob只读权限  
setfacl -m g:developers:rw- project/  # 给developers组读写权限
```

**🔧 ext4 ACL实际操作**：
```bash
# 查看ACL权限
getfacl myfile
# user::rw-
# user:alice:rw-
# group::r--  
# group:team:rw-
# other::r--

# 设置用户ACL
setfacl -m u:charlie:rwx myfile

# 设置组ACL
setfacl -m g:admin:rwx myfile

# 设置默认ACL（新文件会继承）
setfacl -d -m u:alice:rw /shared/

# 删除ACL
setfacl -x u:bob myfile
```

### 7.3 ZFS权限管理


**🔸 ZFS权限的强大之处**：

> 💡 **核心优势**：ZFS不仅是文件系统，还提供了数据完整性、快照、压缩等高级功能

```
ZFS权限特色：
1. 继承性更强：权限设置会影响所有子文件系统
2. 粒度更细：可以控制快照、克隆等高级操作的权限
3. 集成度高：权限与文件系统管理深度集成
```

**📊 ZFS权限类型**：

| 权限类型 | **作用范围** | **典型用途** |
|---------|-------------|-------------|
| 🔧 **文件系统权限** | `create, destroy, mount` | `创建删除文件系统` |
| 📸 **快照权限** | `snapshot, rollback` | `创建和恢复快照` |
| 💾 **存储池权限** | `pool operations` | `存储池管理` |
| 📊 **配额权限** | `quota, reservation` | `磁盘空间管理` |

```bash
# ZFS权限委派示例
zfs allow user1 create,mount,snapshot tank/project
zfs allow -s @developers create,destroy,snapshot,mount tank/shared
```

---

## 8. ☁️ 云存储权限管理


### 8.1 对象存储权限


**🔸 什么是对象存储**：

> 💡 **通俗解释**：对象存储就像一个巨大的"文件柜"，每个文件都有唯一的"地址"和"权限标签"

```
对象存储特点：
📦 每个文件都是一个"对象"
🏷️ 每个对象都有元数据（包括权限信息）
🌐 通过HTTP API访问  
🔑 权限控制非常灵活

常见的对象存储：
- AWS S3
- 阿里云OSS  
- 腾讯云COS
- 华为云OBS
```

**📋 对象存储权限模型**：

| 权限级别 | **作用范围** | **实际含义** | **典型应用** |
|---------|-------------|-------------|-------------|
| 🪣 **存储桶权限** | `整个存储桶` | `控制桶的访问` | `公开网站，私有备份` |
| 📄 **对象权限** | `单个文件` | `控制文件访问` | `个人照片，共享文档` |
| 🔗 **临时权限** | `限时访问` | `临时分享链接` | `文件分享，下载链接` |

### 8.2 权限策略配置


**🔸 基于策略的权限控制**：

> 💡 **核心思想**：用JSON格式的"规则文件"来描述复杂的权限逻辑

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {"AWS": "user:alice"},
      "Action": ["s3:GetObject"],
      "Resource": "arn:aws:s3:::my-bucket/public/*"
    },
    {
      "Effect": "Deny", 
      "Principal": {"AWS": "*"},
      "Action": ["s3:DeleteObject"],
      "Resource": "arn:aws:s3:::my-bucket/important/*"
    }
  ]
}
```

**🔍 策略解读**：
```
第一条规则：
✅ 允许(Allow) alice用户
✅ 执行GetObject操作（下载文件）  
✅ 对象范围：my-bucket/public/ 下的所有文件

第二条规则：
❌ 拒绝(Deny) 所有人(*)
❌ 执行DeleteObject操作（删除文件）
❌ 对象范围：my-bucket/important/ 下的所有文件
```

### 8.3 预签名URL机制


**🔸 什么是预签名URL**：

> 💡 **生活比喻**：预签名URL就像"临时通行证"，有时间限制，过期就失效

```
使用场景：
你想分享一个私有文件给朋友
但不想给朋友你的账号密码
怎么办？

解决方案：
生成一个预签名URL
朋友用这个链接可以下载文件  
链接24小时后自动失效
```

**💻 预签名URL生成示例**：
```python
import boto3
from botocore.exceptions import ClientError

s3_client = boto3.client('s3')

try:
    # 生成预签名下载URL（1小时有效）
    url = s3_client.generate_presigned_url(
        'get_object',
        Params={'Bucket': 'my-bucket', 'Key': 'private/document.pdf'},
        ExpiresIn=3600  # 1小时 = 3600秒
    )
    
    print(f"预签名URL: {url}")
    # 输出类似：https://my-bucket.s3.amazonaws.com/private/document.pdf?
    # X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=...&X-Amz-Expires=3600
    
except ClientError as e:
    print(f"生成失败: {e}")
```

**🔧 预签名URL的优势**：

| 特点 | **传统方式** | **预签名URL** |
|------|-------------|---------------|
| 🔐 **安全性** | `需要分享账号信息` | `无需分享凭证` |
| ⏰ **时效性** | `永久有效或手动管理` | `自动过期` |
| 🎯 **精确性** | `可能访问其他文件` | `只能访问指定文件` |
| 📊 **可控性** | `难以撤销` | `过期自动失效` |

---

## 9. 📋 核心要点总结


### 9.1 DAC的本质理解


**🎯 核心概念回顾**：
```
🔸 DAC = 所有者说了算的权限控制
🔸 特点 = 灵活、直观、易用
🔸 实现 = ACL列表 + 权限位
🔸 应用 = 几乎所有主流系统都支持
```

### 9.2 各系统权限对比


| 系统类型 | **权限模型** | **复杂度** | **适用场景** |
|---------|-------------|-----------|-------------|
| 🐧 **Linux/Unix** | `rwx权限位 + ACL` | `中等` | `服务器、开发环境` |
| 🪟 **Windows** | `DACL + 继承` | `较复杂` | `桌面环境、企业网络` |
| 🗄️ **数据库** | `表/列/行级权限` | `复杂` | `数据管理、业务应用` |
| ☁️ **云存储** | `策略 + 临时权限` | `很复杂` | `大规模分布式应用` |

### 9.3 权限设计最佳实践


**🔸 设计原则**：
```
✅ 最小权限原则：只给必要的最小权限
✅ 权限分离：不同角色不同权限  
✅ 定期审查：检查权限是否合理
✅ 及时回收：离职或角色变更时及时收回权限
```

**🔸 常见错误避免**：
```
❌ 图方便给所有人最大权限
❌ 忘记设置权限继承  
❌ 不区分开发和生产环境权限
❌ 长期不清理无用权限
```

**💡 记忆口诀**：
```
DAC权限控制核心记：
所有者控制是根本，
ACL列表记权限，  
继承机制要搞清，
最小权限保安全！
```