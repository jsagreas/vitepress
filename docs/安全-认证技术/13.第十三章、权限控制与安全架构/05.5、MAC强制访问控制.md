---
title: 5、MAC强制访问控制
---
## 📚 目录

1. [MAC强制访问控制概述](#1-MAC强制访问控制概述)
2. [MAC核心原理深入解析](#2-MAC核心原理深入解析)
3. [经典安全模型详解](#3-经典安全模型详解)
4. [安全标签系统机制](#4-安全标签系统机制)
5. [Linux系统MAC实现](#5-Linux系统MAC实现)
6. [Windows系统MAC实现](#6-Windows系统MAC实现)
7. [实际应用场景分析](#7-实际应用场景分析)
8. [配置管理实践指南](#8-配置管理实践指南)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ MAC强制访问控制概述


### 1.1 什么是MAC强制访问控制


**🔸 通俗理解**
想象一下军事基地的安全管理：
```
普通公司的权限管理（DAC）：
- 老板说："小王，这个文件你可以看"
- 小王可以决定让谁看这个文件

军事基地的权限管理（MAC）：
- 系统说："机密文件只能机密级人员查看"
- 无论是谁，都不能改变这个规则
```

**🔹 核心定义**
MAC（**M**andatory **A**ccess **C**ontrol）强制访问控制是一种系统级的安全机制，它：
- 🚫 **用户无法随意修改权限** - 不是你说了算
- 🏷️ **基于安全标签控制** - 每个对象都有安全等级
- ⚖️ **系统强制执行规则** - 规则不可违背
- 🔒 **保护敏感信息** - 防止信息泄露

### 1.2 MAC与DAC的本质区别


| 特性对比 | **DAC（自主访问控制）** | **MAC（强制访问控制）** |
|---------|---------------------|---------------------|
| 🎛️ **控制方式** | `用户自主决定权限分配` | `系统强制执行安全策略` |
| 📝 **权限修改** | `文件所有者可以修改` | `只能由安全管理员修改` |
| 🏷️ **安全标签** | `不使用安全标签` | `必须使用安全标签` |
| 🎯 **安全目标** | `保护数据不被误操作` | `防止机密信息泄露` |
| 📊 **适用场景** | `一般商业环境` | `高安全要求环境` |

**💡 生活化类比**
```
DAC就像家里的门锁：
- 你可以决定给谁钥匙
- 你可以随时换锁
- 你可以让别人也配钥匙

MAC就像银行金库：
- 有严格的安全等级制度
- 不是你想进就能进
- 规则由银行制定，无法改变
```

### 1.3 为什么需要MAC


**🚨 解决的安全问题**
```
DAC的安全漏洞：

场景1：特洛伊木马攻击
用户小明：机密级别
恶意程序：冒充小明运行
DAC结果：程序可以访问小明的所有文件 ❌
MAC结果：程序无法获得机密标签，被拒绝 ✅

场景2：权限滥用
员工小李：可以修改客户资料
小李恶意：将客户资料权限给外人
DAC结果：外人可以访问敏感数据 ❌
MAC结果：系统拒绝权限转移 ✅
```

---

## 2. 🔧 MAC核心原理深入解析


### 2.1 安全标签（Security Labels）


**🏷️ 什么是安全标签**
安全标签就像给每个人和每个物品贴上的"身份证"：

```
人员标签示例：
张三：机密级 + 研发部门 + 项目A
李四：秘密级 + 市场部门 + 项目B

文件标签示例：
salary.xlsx：机密级 + 人事部门
product.doc：秘密级 + 研发部门 + 项目A
```

**🔸 标签的组成部分**
```
完整安全标签 = 安全级别 + 类别集合

┌─安全级别（分类）─┐    ┌─类别集合（分区）─┐
│                  │    │                  │
│ 绝密 (Top Secret)│    │ 核心技术         │
│ 机密 (Secret)    │ +  │ 财务信息         │
│ 秘密 (Confident) │    │ 人事档案         │
│ 公开 (Public)    │    │ 市场资料         │
└──────────────────┘    └──────────────────┘
```

### 2.2 访问规则（Access Rules）


**⚖️ 基本访问原则**

**📖 读取规则（No Read Up）**
```
简单理解：你不能读比自己级别高的信息

实例说明：
小明标签：秘密级 + 研发部门
文件A：公开级 + 研发部门  ✅ 可以读取（级别更低）
文件B：秘密级 + 研发部门  ✅ 可以读取（级别相同）
文件C：机密级 + 研发部门  ❌ 不能读取（级别更高）
```

**📝 写入规则（No Write Down）**
```
简单理解：你不能往比自己级别低的地方写信息

实例说明：
小明标签：机密级 + 研发部门
写入公开文件：❌ 禁止（可能泄露机密信息）
写入秘密文件：❌ 禁止（可能泄露机密信息）
写入机密文件：✅ 允许（级别匹配）
```

### 2.3 强制执行机制


**🔒 系统级强制执行**

```
传统权限检查流程：
用户请求 → 检查文件权限 → 允许/拒绝

MAC权限检查流程：
用户请求 → 检查文件权限 → 检查MAC标签 → 应用安全规则 → 允许/拒绝

关键点：即使文件权限允许，MAC规则也可能拒绝访问！
```

**💻 实际执行示例**
```bash
# 用户张三（机密级）尝试访问文件
# 文件权限：-rw-r--r-- zhang  staff  secret.txt
# 文件标签：机密级 + 财务部门
# 用户标签：机密级 + 研发部门

系统检查过程：
1. ✅ 文件权限检查：张三是所有者，有读写权限
2. ❌ MAC标签检查：张三不属于财务部门
3. 🚫 最终结果：访问被拒绝

系统日志：
MAC denial: user zhang(secret+dev) -> file secret.txt(secret+finance)
```

---

## 3. 📊 经典安全模型详解


### 3.1 Bell-LaPadula模型


**🔸 模型目标：防止机密信息向下泄露**

**核心规则详解：**

```
📖 简单安全属性（Simple Security Property）
通俗说法：不能偷看机密
正式定义：主体只能读取安全级别不高于自己的客体

实例理解：
              绝密级用户 Alice
                   ↓
        ✅ 可以读取机密级文件
        ✅ 可以读取秘密级文件  
        ✅ 可以读取公开级文件
        ❌ 不能读取其他绝密级文件（需要相同类别）
```

```
📝 *-属性（Star Property）
通俗说法：不能泄露机密
正式定义：主体只能写入安全级别不低于自己的客体

实例理解：
              机密级用户 Bob
                   ↓
        ❌ 不能写入秘密级文件（会泄露机密）
        ❌ 不能写入公开级文件（会泄露机密）
        ✅ 可以写入机密级文件
        ✅ 可以写入绝密级文件
```

**🎯 应用场景示例**
```
军事指挥系统：
- 将军（绝密级）：可以看所有情报，只能写绝密文件
- 上校（机密级）：看不到绝密情报，不能写秘密文件
- 士兵（秘密级）：只能看秘密以下情报

这样确保：机密信息不会意外流向低级别人员
```

### 3.2 Biba完整性模型


**🔸 模型目标：防止低级信息污染高级信息**

**核心思想对比：**
```
Bell-LaPadula（保密性）：防止信息向下泄露
    高级 ──不能写──→ 低级

Biba（完整性）：防止信息向上污染
    低级 ──不能写──→ 高级
```

**实际应用理解：**
```
企业财务系统：
- 总账（高完整性）：只能由会计师修改
- 原始凭证（中等完整性）：可以由出纳录入
- 草稿数据（低完整性）：任何人都可以录入

Biba规则确保：
❌ 出纳不能直接修改总账
✅ 会计师可以基于凭证更新总账
❌ 草稿数据不能直接进入正式账目
```

### 3.3 Chinese Wall模型


**🔸 模型目标：防止利益冲突**

**通俗理解：**
```
律师事务所场景：
- 律师A正在为公司甲打官司
- 公司甲的竞争对手是公司乙
- Chinese Wall规则：律师A不能接公司乙的案子

数据访问场景：
- 分析师正在研究银行A的投资机会
- 银行A的竞争对手是银行B  
- Chinese Wall规则：分析师不能再访问银行B的信息
```

**🔧 实现机制：**
```
冲突类定义：
{银行A, 银行B, 银行C} → 银行业冲突类
{汽车厂D, 汽车厂E}   → 汽车业冲突类

访问历史记录：
分析师张三已访问：银行A信息
系统自动禁止：访问银行B、银行C信息
系统仍允许：访问汽车厂D、汽车厂E信息
```

---

## 4. 🏷️ 安全标签系统机制


### 4.1 分类级别（Classification Levels）


**📊 标准分级体系：**

```
政府/军事标准：
┌─────────────────────────────────┐
│ 4. 绝密 (Top Secret)     █████  │ ← 最高级别
│ 3. 机密 (Secret)         ████   │
│ 2. 秘密 (Confidential)   ███    │ 
│ 1. 公开 (Unclassified)   ██     │ ← 最低级别
└─────────────────────────────────┘

企业标准：
┌─────────────────────────────────┐
│ 4. 高度机密 (Highly Sensitive) │
│ 3. 商业机密 (Business Secret)  │
│ 2. 内部资料 (Internal Use)     │
│ 1. 公开信息 (Public)           │
└─────────────────────────────────┘
```

**🔢 级别数值化表示：**
```java
// 安全级别枚举
public enum SecurityLevel {
    PUBLIC(1, "公开"),
    CONFIDENTIAL(2, "秘密"), 
    SECRET(3, "机密"),
    TOP_SECRET(4, "绝密");
    
    private int level;
    private String name;
}

// 访问检查逻辑
public boolean canRead(SecurityLevel userLevel, SecurityLevel fileLevel) {
    return userLevel.getLevel() >= fileLevel.getLevel();
}
```

### 4.2 类别集合（Categories）


**🎯 类别的作用：**
类别就像给信息贴上"部门标签"，实现横向隔离：

```
研发部门类别：{TECH, PRODUCT, RESEARCH}
财务部门类别：{FINANCE, BUDGET, AUDIT} 
人事部门类别：{HR, RECRUITMENT, PAYROLL}

同级别不同类别也无法访问：
机密级+研发类别 ≠ 机密级+财务类别
```

**🔗 类别组合规则：**

```
包含关系检查：
用户类别：{TECH, PRODUCT}
文件类别：{TECH}
结果：✅ 可以访问（用户类别包含文件类别）

用户类别：{PRODUCT}  
文件类别：{TECH, PRODUCT}
结果：❌ 不能访问（用户类别不完全包含文件类别）
```

### 4.3 标签比较算法


**⚖️ 支配关系判断：**

```python
def dominates(user_label, file_label):
    """
    判断用户标签是否支配文件标签
    支配条件：
    1. 用户安全级别 >= 文件安全级别
    2. 文件类别集合 ⊆ 用户类别集合
    """
    # 检查安全级别
    if user_label.level < file_label.level:
        return False
    
    # 检查类别包含关系
    if not file_label.categories.issubset(user_label.categories):
        return False
    
    return True

# 使用示例
user = SecurityLabel(level=SECRET, categories={'TECH', 'PRODUCT'})
file = SecurityLabel(level=CONFIDENTIAL, categories={'TECH'})

can_access = dominates(user, file)  # True
```

---

## 5. 🐧 Linux系统MAC实现


### 5.1 SELinux详解


**🔸 SELinux基本概念**

SELinux（Security-Enhanced Linux）是Linux内核的安全模块：

```
SELinux工作原理：
                应用程序
                    ↓
            ┌─────────────────┐
            │   系统调用      │
            └─────────┬───────┘
                      ↓
            ┌─────────────────┐
            │ DAC权限检查     │ ← 传统Unix权限
            └─────────┬───────┘  
                      ↓
            ┌─────────────────┐
            │ SELinux检查     │ ← MAC额外检查
            └─────────┬───────┘
                      ↓
                 允许/拒绝
```

**🏷️ SELinux上下文（Context）**

```bash
# 查看文件的SELinux上下文
ls -Z /etc/passwd
-rw-r--r--. root root system_u:object_r:passwd_file_t:s0 /etc/passwd

# 上下文格式：user:role:type:level
# user:   SELinux用户（system_u）
# role:   角色（object_r）  
# type:   类型（passwd_file_t）
# level:  多级安全级别（s0）
```

**🛠️ SELinux策略配置**

```bash
# 查看SELinux状态
sestatus
SELinux status:                 enabled
Current mode:                   enforcing
Policy version:                 31

# 临时设置为宽松模式（仅记录不阻止）
setenforce 0

# 查看拒绝日志
ausearch -m AVC -ts recent
```

### 5.2 AppArmor详解


**🔸 AppArmor特点**

AppArmor采用路径为基础的访问控制：

```
AppArmor vs SELinux对比：
┌─────────────────┬─────────────────────┬─────────────────────┐
│     特性        │      SELinux        │      AppArmor       │
├─────────────────┼─────────────────────┼─────────────────────┤
│ 🎯 控制方式     │ 基于标签和类型      │ 基于文件路径        │
│ 📝 策略复杂度   │ 复杂，功能强大      │ 简单，易于理解      │
│ 🔧 配置难度     │ 较高                │ 较低                │
│ 📊 性能开销     │ 中等                │ 较小                │
└─────────────────┴─────────────────────┴─────────────────────┘
```

**📋 AppArmor配置示例**

```bash
# 查看AppArmor状态  
aa-status

# 示例：限制应用程序只能访问特定目录
/usr/bin/myapp {
  # 允许读取配置文件
  /etc/myapp/** r,
  
  # 允许写入日志目录
  /var/log/myapp/** rw,
  
  # 允许网络访问
  network inet tcp,
  
  # 禁止访问其他目录
  deny /** w,
}
```

### 5.3 实际部署示例


**🚀 SELinux部署流程**

```bash
# 1. 安装必要工具
yum install policycoreutils selinux-policy-targeted

# 2. 为应用创建自定义类型
setsebool -P httpd_can_network_connect 1

# 3. 设置文件上下文
semanage fcontext -a -t httpd_exec_t "/opt/myapp/bin/myapp"
restorecon -R /opt/myapp/

# 4. 创建自定义策略模块
# 编写 myapp.te 策略文件
policy_module(myapp, 1.0)
type myapp_t;
type myapp_exec_t;
application_domain(myapp_t, myapp_exec_t)

# 编译并加载策略
make -f /usr/share/selinux/devel/Makefile myapp.pp
semodule -i myapp.pp
```

---

## 6. 🏢 Windows系统MAC实现


### 6.1 MIC (Mandatory Integrity Control)


**🔸 Windows完整性级别**

Windows Vista引入了完整性级别概念：

```
Windows完整性级别：
┌────────────────────────────────────────┐
│ System（系统级）      █████████████████ │ ← 系统服务
│ High（高级）          █████████████     │ ← 管理员程序  
│ Medium（中等）        ████████          │ ← 普通程序
│ Low（低级）           ████              │ ← 受限程序
│ Untrusted（不信任）   ██                │ ← 沙盒程序
└────────────────────────────────────────┘
```

**🔧 MIC规则说明**

```
完整性规则：
1. 📖 读取：低级别可以读取高级别对象
2. 📝 写入：只能写入同级别或更低级别对象
3. 🚫 执行：只能执行同级别或更高级别程序

实际应用：
Internet Explorer运行在Low级别：
✅ 可以读取用户文档（Medium级别）
❌ 不能修改系统文件（High级别）
❌ 不能写入用户文档目录
✅ 只能写入Temp\Low目录
```

### 6.2 UAC (User Account Control)


**🔸 UAC工作机制**

```
UAC提升流程：
普通用户令牌 → 请求管理员权限 → UAC提示 → 用户确认 → 管理员令牌

实际场景：
用户双击安装程序
    ↓
程序请求写入Program Files目录
    ↓  
UAC检测到需要管理员权限
    ↓
弹出确认对话框
    ↓
用户点击"是" → 获得High完整性级别令牌
用户点击"否" → 程序以Medium级别运行（可能失败）
```

### 6.3 WIP (Windows Information Protection)


**🔸 企业数据保护**

```
WIP数据分类：
┌─────────────────────────────────────────────────┐
│ 🏢 企业数据                                      │
│   - 被WIP策略保护                                │
│   - 只能在受信任的应用中使用                     │
│   - 离开企业环境时自动加密                       │
│                                                 │  
│ 👤 个人数据                                      │
│   - 不受WIP保护                                  │
│   - 可以自由使用和分享                           │
└─────────────────────────────────────────────────┘

数据流控制：
企业邮件应用 → 可以访问企业数据
消费者应用   → 无法访问企业数据
剪贴板      → 企业数据复制时自动提示
```

---

## 7. 🎯 实际应用场景分析


### 7.1 军事系统应用


**🏭 军事指挥系统架构**

```
军事网络分级示例：
            ┌─绝密网络─┐
            │ 作战计划 │ ← 仅绝密级人员
            │ 情报分析 │
            └─────┬────┘
                  │ 单向数据流
            ┌─────↓────┐
            │ 机密网络 │ ← 机密级及以上
            │ 战术资料 │
            └─────┬────┘  
                  │
            ┌─────↓────┐
            │ 秘密网络 │ ← 秘密级及以上
            │ 后勤信息 │
            └─────┬────┘
                  │
            ┌─────↓────┐ 
            │ 公开网络 │ ← 所有人员
            │ 一般通知 │
            └──────────┘
```

**🛡️ 安全策略示例**

```bash
# 军事系统SELinux策略示例
# 定义安全级别
mls_range s0-s3:c0.c1023

# 绝密级用户只能访问s3级别文件
user classified_user roles classified_r level s3 range s3;

# 机密级文件类型定义
type secret_document_t;
typeattribute secret_document_t sensitive_file_type;

# 访问规则：只有相应级别用户才能访问
allow classified_user secret_document_t:file { read write };
```

### 7.2 政府机构应用


**🏛️ 政府信息分级**

```
政府文档分类体系：
┌──────────────────────────────────────────────┐
│ 🔴 绝密文件                                   │
│    - 国家安全相关                             │
│    - 外交机密                                 │
│    - 军事计划                                 │
│                                              │
│ 🟡 机密文件                                   │  
│    - 政策草案                                 │
│    - 预算计划                                 │
│    - 人事任免                                 │
│                                              │
│ 🟢 秘密文件                                   │
│    - 内部通知                                 │
│    - 工作计划                                 │
│                                              │
│ ⚪ 公开文件                                   │
│    - 法律法规                                 │
│    - 公告通知                                 │
└──────────────────────────────────────────────┘
```

### 7.3 高安全企业环境


**🏦 金融机构MAC应用**

```
银行数据分级管理：

客户数据保护：
- 个人账户信息：机密级 + 零售银行部门
- 企业账户信息：机密级 + 企业银行部门  
- 交易记录：秘密级 + 相关业务部门
- 监管报告：绝密级 + 合规部门

访问控制矩阵：
┌─────────────┬──────┬──────┬──────┬──────┐
│   角色/数据  │ 个人 │ 企业 │ 交易 │ 监管 │
├─────────────┼──────┼──────┼──────┼──────┤
│ 零售银行员工 │  ✅  │  ❌  │  ✅  │  ❌  │
│ 企业银行员工 │  ❌  │  ✅  │  ✅  │  ❌  │
│ 风控分析师   │  ✅  │  ✅  │  ✅  │  ❌  │
│ 合规管理员   │  ✅  │  ✅  │  ✅  │  ✅  │
└─────────────┴──────┴──────┴──────┴──────┘
```

---

## 8. ⚙️ 配置管理实践指南


### 8.1 策略编写最佳实践


**📝 策略设计原则**

```
1. 🎯 最小权限原则
   - 用户只获得完成工作必需的最低权限
   - 定期审核和回收不必要的权限

2. 🔄 职责分离原则  
   - 敏感操作需要多人协作完成
   - 避免单一角色拥有过大权限

3. 📊 分层防护原则
   - 多层安全检查机制
   - 任何一层失败都不会导致整体失败

4. 🔍 审计跟踪原则
   - 所有访问操作都要记录日志
   - 支持事后审计和问题追溯
```

**🛠️ 策略编写模板**

```bash
# SELinux策略模板
policy_module(myapp, 1.0)

# 定义应用程序域
type myapp_t;
type myapp_exec_t;
application_domain(myapp_t, myapp_exec_t)

# 定义文件类型
type myapp_config_t;
type myapp_log_t;
type myapp_data_t;

# 允许读取配置文件
allow myapp_t myapp_config_t:file { read open };

# 允许写入日志文件
allow myapp_t myapp_log_t:file { create write append };

# 允许访问数据文件
allow myapp_t myapp_data_t:file { read write create unlink };

# 网络访问权限
allow myapp_t self:tcp_socket { create connect };
```

### 8.2 测试验证流程


**🧪 MAC策略测试方法**

```bash
# 1. 策略语法检查
checkpolicy -M -m myapp.te -o myapp.mod

# 2. 模拟测试环境
# 使用测试用户和文件验证策略

# 3. 渗透测试
# 尝试突破MAC限制
su - testuser
cat /etc/shadow  # 应该被MAC拒绝

# 4. 日志分析
# 检查是否有异常的MAC决策
ausearch -m AVC -ts today

# 5. 性能测试  
# 测量MAC检查对系统性能的影响
time ls -la /etc/  # 对比开启MAC前后的性能
```

### 8.3 维护更新策略


**🔄 策略生命周期管理**

```
策略维护流程：
┌─────────────────┐
│   需求变更      │ → 业务需求变化
└─────┬───────────┘
      ↓
┌─────────────────┐
│   策略修订      │ → 更新安全策略
└─────┬───────────┘
      ↓
┌─────────────────┐
│   测试验证      │ → 测试环境验证
└─────┬───────────┘
      ↓
┌─────────────────┐
│   灰度部署      │ → 部分系统试点
└─────┬───────────┘
      ↓
┌─────────────────┐
│   全面部署      │ → 生产环境部署
└─────┬───────────┘
      ↓
┌─────────────────┐
│   监控反馈      │ → 持续监控调优
└─────────────────┘
```

**📋 常见维护任务**

```bash
# 每日检查任务
#!/bin/bash
# 检查MAC拒绝日志
echo "=== MAC Denials Today ==="
ausearch -m AVC -ts today | wc -l

# 检查策略状态
echo "=== Policy Status ==="
sestatus

# 每周任务：策略优化
# 分析访问模式，优化策略规则
semanage boolean -l | grep httpd

# 每月任务：安全审计
# 生成访问报告，检查异常行为
aureport -au -ts this-month
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 MAC本质：系统强制执行的安全策略，用户无法绕过
🔸 安全标签：每个主体和客体都有安全级别和类别标记
🔸 访问规则：No Read Up（不能读高级）+ No Write Down（不能写低级）
🔸 强制执行：在传统权限检查基础上增加MAC检查层
🔸 经典模型：Bell-LaPadula（保密）、Biba（完整性）、Chinese Wall（防冲突）
```

### 9.2 关键理解要点


**🔹 MAC与DAC的本质区别**
```
控制权归属：
DAC → 用户控制："我的文件我做主"
MAC → 系统控制："系统规则最高"

安全目标：
DAC → 防止误操作和恶意访问
MAC → 防止机密信息泄露和污染
```

**🔹 安全标签的工作机制**
```
标签比较过程：
1. 比较安全级别：用户级别必须≥文件级别
2. 比较类别集合：文件类别必须⊆用户类别
3. 两个条件都满足才能访问
```

**🔹 不同安全模型的适用场景**
```
Bell-LaPadula → 军事、政府系统（重视保密性）
Biba → 金融、医疗系统（重视数据完整性）  
Chinese Wall → 投行、律所（避免利益冲突）
```

### 9.3 实际应用价值


**🎯 适用场景判断**
- ✅ **高安全要求**：军事、政府、金融等敏感环境
- ✅ **多级别用户**：不同安全级别人员共享系统
- ✅ **机密信息保护**：防止信息泄露是核心需求
- ✅ **合规要求**：法规要求实施强制访问控制

**🛠️ 实施建议**
- 🚀 **从小规模试点开始**：避免影响业务正常运行
- 📊 **充分测试验证**：确保策略正确性和完整性
- 👥 **加强人员培训**：管理员需要掌握MAC配置技能
- 🔍 **持续监控优化**：根据实际使用情况调整策略

**核心记忆口诀**：
- MAC强制控制系统管，安全标签贴满天
- 不能读高不写低，Bell模型保机密
- SELinux标签AppArmor路径，Windows完整性级别
- 军政金融高安全，策略编写要规范