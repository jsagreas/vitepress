---
title: 14ã€ç½‘ç»œå®‰å…¨ç¼–ç¨‹åŸºç¡€
---
## ğŸ“š ç›®å½•


1. [ç½‘ç»œå®‰å…¨ç¼–ç¨‹æ¦‚è¿°](#1-ç½‘ç»œå®‰å…¨ç¼–ç¨‹æ¦‚è¿°)
2. [SSL/TLSåŠ å¯†é€šä¿¡åŸç†](#2-ssl-tlsåŠ å¯†é€šä¿¡åŸç†)
3. [OpenSSLåº“åŸºç¡€ä½¿ç”¨](#3-opensslåº“åŸºç¡€ä½¿ç”¨)
4. [è¯ä¹¦éªŒè¯ä¸ä¿¡ä»»é“¾](#4-è¯ä¹¦éªŒè¯ä¸ä¿¡ä»»é“¾)
5. [åŠ å¯†Socketç¼–ç¨‹å®ç°](#5-åŠ å¯†socketç¼–ç¨‹å®ç°)
6. [ç½‘ç»œæ•°æ®åŠ å¯†ä¼ è¾“](#6-ç½‘ç»œæ•°æ®åŠ å¯†ä¼ è¾“)
7. [èº«ä»½è®¤è¯æœºåˆ¶å®ç°](#7-èº«ä»½è®¤è¯æœºåˆ¶å®ç°)
8. [é˜²æ­¢ç½‘ç»œæ”»å‡»ç¼–ç¨‹æŠ€å·§](#8-é˜²æ­¢ç½‘ç»œæ”»å‡»ç¼–ç¨‹æŠ€å·§)
9. [å®‰å…¨ç¼–ç¨‹æœ€ä½³å®è·µ](#9-å®‰å…¨ç¼–ç¨‹æœ€ä½³å®è·µ)
10. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#10-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

# ğŸ¯ **å­¦ä¹ è·¯å¾„å¯¼èˆª**


**å‰ç½®çŸ¥è¯†**ï¼šéœ€è¦æŒæ¡Socketç¼–ç¨‹åŸºç¡€ã€ç½‘ç»œåè®®æ ˆã€å¯†ç å­¦åŸºç¡€ â†’ **å½“å‰å†…å®¹**ï¼šç½‘ç»œå®‰å…¨ç¼–ç¨‹åŸºç¡€ â†’ **åç»­å­¦ä¹ **ï¼šå»ºè®®å­¦ä¹ ç½‘ç»œå®‰å…¨é˜²æŠ¤ã€æ¸—é€æµ‹è¯•æŠ€æœ¯

â±ï¸ **é¢„è®¡å­¦ä¹ æ—¶é—´**ï¼šæœ¬ç« é¢„è®¡90åˆ†é’Ÿ | å®è·µç»ƒä¹ 60åˆ†é’Ÿ

---

## 1. ğŸ” ç½‘ç»œå®‰å…¨ç¼–ç¨‹æ¦‚è¿°



### 1.1 ä»€ä¹ˆæ˜¯ç½‘ç»œå®‰å…¨ç¼–ç¨‹



**ğŸ”¸ æ ¸å¿ƒå®šä¹‰**
```
ç½‘ç»œå®‰å…¨ç¼–ç¨‹ï¼šåœ¨ç½‘ç»œé€šä¿¡ä¸­é›†æˆå®‰å…¨æœºåˆ¶çš„ç¼–ç¨‹æŠ€æœ¯
ç›®æ ‡ï¼šä¿æŠ¤æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­çš„æœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§
æœ¬è´¨ï¼šä¸ºæ™®é€šSocketé€šä¿¡ç©¿ä¸Š"å®‰å…¨é“ ç”²"
```

**ğŸ’¡ é€šä¿—ç†è§£**
æƒ³è±¡ç½‘ç»œä¼ è¾“å°±åƒé‚®å¯„åŒ…è£¹ï¼š
- **æ™®é€šSocket**ï¼šæ˜ä¿¡ç‰‡ï¼Œå†…å®¹äººäººå¯è§
- **å®‰å…¨Socket**ï¼šå¯†å°åŒ…è£¹+ç­¾åï¼Œæ—¢ä¿å¯†åˆé˜²ä¼ª

### 1.2 ç½‘ç»œå®‰å…¨å¨èƒç±»å‹



**âš ï¸ å¸¸è§å®‰å…¨å¨èƒ**

| **å¨èƒç±»å‹** | **æ”»å‡»æ–¹å¼** | **å±å®³åæœ** | **é˜²æŠ¤æ–¹æ³•** |
|-------------|-------------|-------------|-------------|
| **çªƒå¬æ”»å‡»** | ç›‘å¬ç½‘ç»œæ•°æ®åŒ… | æ•æ„Ÿä¿¡æ¯æ³„éœ² | æ•°æ®åŠ å¯†ä¼ è¾“ |
| **ç¯¡æ”¹æ”»å‡»** | ä¿®æ”¹ä¼ è¾“æ•°æ® | æ•°æ®å®Œæ•´æ€§ç ´å | æ•°å­—ç­¾åéªŒè¯ |
| **é‡æ”¾æ”»å‡»** | é‡å‘æ—§æ•°æ®åŒ… | éæ³•æ“ä½œé‡å¤æ‰§è¡Œ | æ—¶é—´æˆ³+éšæœºæ•° |
| **èº«ä»½ä¼ªé€ ** | å†’å……åˆæ³•ç”¨æˆ· | éæ³•è®¿é—®ç³»ç»Ÿ | èº«ä»½è®¤è¯æœºåˆ¶ |

### 1.3 å®‰å…¨ç¼–ç¨‹æ ¸å¿ƒè¦ç´ 



**ğŸ›¡ï¸ å®‰å…¨ä¸‰è¦ç´ **
```
æœºå¯†æ€§ (Confidentiality)ï¼š
â€¢ å«ä¹‰ï¼šåªæœ‰æˆæƒäººå‘˜èƒ½çœ‹åˆ°ä¿¡æ¯
â€¢ å®ç°ï¼šå¯¹ç§°/éå¯¹ç§°åŠ å¯†

å®Œæ•´æ€§ (Integrity)ï¼š
â€¢ å«ä¹‰ï¼šæ•°æ®ä¼ è¾“è¿‡ç¨‹ä¸­æœªè¢«ç¯¡æ”¹
â€¢ å®ç°ï¼šå“ˆå¸Œæ ¡éªŒã€æ•°å­—ç­¾å

å¯ç”¨æ€§ (Availability)ï¼š
â€¢ å«ä¹‰ï¼šåˆæ³•ç”¨æˆ·èƒ½æ­£å¸¸è®¿é—®æœåŠ¡
â€¢ å®ç°ï¼šé˜²DDoSã€å†—ä½™å¤‡ä»½
```

---

## 2. ğŸ”’ SSL/TLSåŠ å¯†é€šä¿¡åŸç†



### 2.1 SSL/TLSåè®®æ¦‚è¿°



**ğŸ“‹ åè®®åŸºæœ¬æ¦‚å¿µ**
```
SSLï¼šSecure Socket Layerï¼Œå®‰å…¨å¥—æ¥å­—å±‚
TLSï¼šTransport Layer Securityï¼Œä¼ è¾“å±‚å®‰å…¨åè®®
å…³ç³»ï¼šTLSæ˜¯SSLçš„åç»­ç‰ˆæœ¬ï¼Œæ›´å®‰å…¨æ›´ç°ä»£
ä½ç½®ï¼šå·¥ä½œåœ¨TCPå’Œåº”ç”¨å±‚ä¹‹é—´
```

**ğŸŒŸ TLSåè®®ç‰ˆæœ¬å¯¹æ¯”**

| **ç‰ˆæœ¬** | **å‘å¸ƒæ—¶é—´** | **å®‰å…¨æ€§** | **ä½¿ç”¨å»ºè®®** |
|----------|-------------|-----------|-------------|
| **SSL 3.0** | 1996å¹´ | â­â­ | å·²å¼ƒç”¨ |
| **TLS 1.0** | 1999å¹´ | â­â­â­ | ä¸æ¨è |
| **TLS 1.2** | 2008å¹´ | â­â­â­â­ | å¹¿æ³›ä½¿ç”¨ |
| **TLS 1.3** | 2018å¹´ | â­â­â­â­â­ | å¼ºçƒˆæ¨è |

### 2.2 TLSæ¡æ‰‹è¿‡ç¨‹è¯¦è§£



**ğŸ¤ æ¡æ‰‹æµç¨‹å›¾ç¤º**
```
å®¢æˆ·ç«¯                               æœåŠ¡å™¨
   |                                   |
   |--[1] Client Hello--------------->|
   |    (æ”¯æŒçš„åŠ å¯†ç®—æ³•å¥—ä»¶)            |
   |                                   |
   |<--[2] Server Hello---------------|
   |    (é€‰æ‹©çš„åŠ å¯†ç®—æ³•)                |
   |<--[3] Certificate----------------|
   |    (æœåŠ¡å™¨è¯ä¹¦)                   |
   |<--[4] Server Hello Done----------|
   |                                   |
   |--[5] Client Key Exchange-------->|
   |    (é¢„ä¸»å¯†é’¥ï¼Œç”¨æœåŠ¡å™¨å…¬é’¥åŠ å¯†)    |
   |--[6] Change Cipher Spec--------->|
   |--[7] Finished------------------->|
   |                                   |
   |<--[8] Change Cipher Spec---------|
   |<--[9] Finished-------------------|
   |                                   |
   |<====[åŠ å¯†æ•°æ®ä¼ è¾“]===============>|
```

**ğŸ”‘ å¯†é’¥ç”Ÿæˆè¿‡ç¨‹**
```
ä¸»å¯†é’¥ç”Ÿæˆï¼š
1. å®¢æˆ·ç«¯ç”Ÿæˆéšæœºçš„é¢„ä¸»å¯†é’¥ (Pre-Master Secret)
2. ç”¨æœåŠ¡å™¨å…¬é’¥åŠ å¯†åå‘é€ç»™æœåŠ¡å™¨
3. åŒæ–¹æ ¹æ®é¢„ä¸»å¯†é’¥+éšæœºæ•°ç”Ÿæˆä¸»å¯†é’¥ (Master Secret)
4. ä»ä¸»å¯†é’¥æ´¾ç”Ÿå‡ºä¼šè¯å¯†é’¥ç”¨äºå®é™…åŠ å¯†
```

### 2.3 åŠ å¯†ç®—æ³•å¥—ä»¶



**ğŸ”§ å¸¸ç”¨åŠ å¯†å¥—ä»¶ç»„æˆ**
```
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384

è§£æï¼š
â€¢ TLSï¼šåè®®ç‰ˆæœ¬
â€¢ ECDHEï¼šå¯†é’¥äº¤æ¢ç®—æ³• (æ¤­åœ†æ›²çº¿è¿ªè²-èµ«å°”æ›¼)
â€¢ RSAï¼šèº«ä»½è®¤è¯ç®—æ³•
â€¢ AES_256_GCMï¼šå¯¹ç§°åŠ å¯†ç®—æ³• (256ä½AESï¼ŒGCMæ¨¡å¼)
â€¢ SHA384ï¼šæ¶ˆæ¯è®¤è¯ç ç®—æ³•
```

**â­ æ¨èåŠ å¯†å¥—ä»¶**
- `TLS_AES_256_GCM_SHA384` (TLS 1.3)
- `TLS_CHACHA20_POLY1305_SHA256` (TLS 1.3)
- `ECDHE-RSA-AES256-GCM-SHA384` (TLS 1.2)

---

## 3. ğŸ› ï¸ OpenSSLåº“åŸºç¡€ä½¿ç”¨



### 3.1 OpenSSLåº“ç®€ä»‹



**ğŸ“š åº“çš„åŸºæœ¬æ¦‚å¿µ**
```
OpenSSLï¼šå¼€æºçš„SSL/TLSå®ç°åº“
ç»„æˆï¼šlibssl (SSL/TLSåè®®) + libcrypto (å¯†ç å­¦ç®—æ³•)
ç”¨é€”ï¼šæä¾›åŠ å¯†ã€è§£å¯†ã€æ•°å­—ç­¾åã€è¯ä¹¦ç®¡ç†ç­‰åŠŸèƒ½
å®‰è£…ï¼šsudo apt-get install libssl-dev
```

### 3.2 åŸºç¡€APIä½¿ç”¨



**ğŸ”Œ SSLè¿æ¥å»ºç«‹**
```c
#include <openssl/ssl.h>

#include <openssl/err.h>


// åˆå§‹åŒ–SSLåº“
SSL_library_init();
SSL_load_error_strings();
OpenSSL_add_all_algorithms();

// åˆ›å»ºSSLä¸Šä¸‹æ–‡
SSL_CTX *ctx = SSL_CTX_new(TLS_client_method());
if (!ctx) {
    fprintf(stderr, "SSL_CTX_new failed\n");
    exit(1);
}

// åˆ›å»ºSSLè¿æ¥å¯¹è±¡
SSL *ssl = SSL_new(ctx);
SSL_set_fd(ssl, sockfd);  // ç»‘å®šåˆ°socket

// å»ºç«‹SSLè¿æ¥
if (SSL_connect(ssl) <= 0) {
    ERR_print_errors_fp(stderr);
    exit(1);
}
```

**ğŸ“– åŸºæœ¬è¯»å†™æ“ä½œ**
```c
// SSLæ•°æ®å‘é€
int bytes_sent = SSL_write(ssl, data, strlen(data));
if (bytes_sent <= 0) {
    int error = SSL_get_error(ssl, bytes_sent);
    // å¤„ç†é”™è¯¯
}

// SSLæ•°æ®æ¥æ”¶
char buffer[1024];
int bytes_received = SSL_read(ssl, buffer, sizeof(buffer));
if (bytes_received > 0) {
    buffer[bytes_received] = '\0';
    printf("æ¥æ”¶åˆ°: %s\n", buffer);
}

// æ¸…ç†èµ„æº
SSL_shutdown(ssl);
SSL_free(ssl);
SSL_CTX_free(ctx);
```

### 3.3 è¯ä¹¦å’Œå¯†é’¥åŠ è½½



**ğŸ” è¯ä¹¦é…ç½®ç¤ºä¾‹**
```c
// åŠ è½½CAè¯ä¹¦ç”¨äºéªŒè¯æœåŠ¡å™¨
if (!SSL_CTX_load_verify_locations(ctx, "ca-cert.pem", NULL)) {
    fprintf(stderr, "åŠ è½½CAè¯ä¹¦å¤±è´¥\n");
    exit(1);
}

// åŠ è½½å®¢æˆ·ç«¯è¯ä¹¦ (åŒå‘è®¤è¯æ—¶éœ€è¦)
if (!SSL_CTX_use_certificate_file(ctx, "client-cert.pem", SSL_FILETYPE_PEM)) {
    fprintf(stderr, "åŠ è½½å®¢æˆ·ç«¯è¯ä¹¦å¤±è´¥\n");
    exit(1);
}

// åŠ è½½å®¢æˆ·ç«¯ç§é’¥
if (!SSL_CTX_use_PrivateKey_file(ctx, "client-key.pem", SSL_FILETYPE_PEM)) {
    fprintf(stderr, "åŠ è½½ç§é’¥å¤±è´¥\n");
    exit(1);
}

// éªŒè¯ç§é’¥å’Œè¯ä¹¦æ˜¯å¦åŒ¹é…
if (!SSL_CTX_check_private_key(ctx)) {
    fprintf(stderr, "ç§é’¥å’Œè¯ä¹¦ä¸åŒ¹é…\n");
    exit(1);
}
```

---

## 4. ğŸ“œ è¯ä¹¦éªŒè¯ä¸ä¿¡ä»»é“¾



### 4.1 æ•°å­—è¯ä¹¦åŸºç¡€



**ğŸ“‹ è¯ä¹¦çš„æ„æˆè¦ç´ **
```
X.509è¯ä¹¦åŒ…å«ï¼š
â€¢ å…¬é’¥ï¼šç”¨äºåŠ å¯†å’Œç­¾åéªŒè¯
â€¢ èº«ä»½ä¿¡æ¯ï¼šè¯ä¹¦æ‰€æœ‰è€…çš„ä¿¡æ¯ (CN, O, Cç­‰)
â€¢ æœ‰æ•ˆæœŸï¼šè¯ä¹¦çš„èµ·å§‹å’Œæˆªæ­¢æ—¶é—´
â€¢ ç­¾åï¼šCAç”¨ç§é’¥å¯¹è¯ä¹¦å†…å®¹çš„ç­¾å
â€¢ æ‰©å±•å­—æ®µï¼šç”¨é€”é™åˆ¶ã€å¤‡ç”¨åç§°ç­‰
```

**ğŸŒ³ è¯ä¹¦ä¿¡ä»»é“¾**
```
ä¿¡ä»»é“¾å±‚æ¬¡ç»“æ„ï¼š

æ ¹CAè¯ä¹¦ (Root CA)
    â†“ ç­¾å
ä¸­é—´CAè¯ä¹¦ (Intermediate CA)
    â†“ ç­¾å  
æœåŠ¡å™¨è¯ä¹¦ (End Entity Certificate)

éªŒè¯è¿‡ç¨‹ï¼š
1. æ£€æŸ¥æœåŠ¡å™¨è¯ä¹¦ç­¾å â† ä¸­é—´CAå…¬é’¥éªŒè¯
2. æ£€æŸ¥ä¸­é—´CAè¯ä¹¦ç­¾å â† æ ¹CAå…¬é’¥éªŒè¯  
3. æ£€æŸ¥æ ¹CAè¯ä¹¦ â† æœ¬åœ°ä¿¡ä»»å­˜å‚¨éªŒè¯
```

### 4.2 è¯ä¹¦éªŒè¯å®ç°



**âœ… æ‰‹åŠ¨è¯ä¹¦éªŒè¯**
```c
#include <openssl/x509.h>

#include <openssl/x509_vfy.h>


int verify_certificate(SSL *ssl) {
    X509 *cert = SSL_get_peer_certificate(ssl);
    if (!cert) {
        printf("âŒ æœåŠ¡å™¨æœªæä¾›è¯ä¹¦\n");
        return 0;
    }
    
    // è·å–è¯ä¹¦ä¸»é¢˜ä¿¡æ¯
    char subject[256];
    X509_NAME_oneline(X509_get_subject_name(cert), subject, sizeof(subject));
    printf("ğŸ“‹ è¯ä¹¦ä¸»é¢˜: %s\n", subject);
    
    // æ£€æŸ¥è¯ä¹¦æœ‰æ•ˆæœŸ
    ASN1_TIME *not_before = X509_get_notBefore(cert);
    ASN1_TIME *not_after = X509_get_notAfter(cert);
    
    if (X509_cmp_current_time(not_before) > 0) {
        printf("âŒ è¯ä¹¦å°šæœªç”Ÿæ•ˆ\n");
        X509_free(cert);
        return 0;
    }
    
    if (X509_cmp_current_time(not_after) < 0) {
        printf("âŒ è¯ä¹¦å·²è¿‡æœŸ\n");
        X509_free(cert);
        return 0;
    }
    
    printf("âœ… è¯ä¹¦æœ‰æ•ˆæœŸéªŒè¯é€šè¿‡\n");
    X509_free(cert);
    return 1;
}
```

### 4.3 è¯ä¹¦ç”Ÿæˆå’Œç®¡ç†



**ğŸ”§ è‡ªç­¾åè¯ä¹¦ç”Ÿæˆ**
```bash
# ç”Ÿæˆç§é’¥

openssl genrsa -out server-key.pem 2048

# ç”Ÿæˆè¯ä¹¦ç­¾åè¯·æ±‚

openssl req -new -key server-key.pem -out server.csr \
    -subj "/C=CN/ST=Beijing/L=Beijing/O=MyCompany/CN=localhost"

# ç”Ÿæˆè‡ªç­¾åè¯ä¹¦

openssl x509 -req -days 365 -in server.csr \
    -signkey server-key.pem -out server-cert.pem

# æŸ¥çœ‹è¯ä¹¦ä¿¡æ¯

openssl x509 -in server-cert.pem -text -noout
```

**ğŸ“Š è¯ä¹¦ä¿¡æ¯æ£€æŸ¥å·¥å…·**
```bash
# æ£€æŸ¥è¯ä¹¦è¿‡æœŸæ—¶é—´

openssl x509 -in cert.pem -noout -dates

# éªŒè¯è¯ä¹¦é“¾

openssl verify -CAfile ca-cert.pem intermediate-cert.pem

# æ£€æŸ¥ç§é’¥å’Œè¯ä¹¦æ˜¯å¦åŒ¹é…

openssl x509 -noout -modulus -in cert.pem | openssl md5
openssl rsa -noout -modulus -in key.pem | openssl md5
```

---

## 5. ğŸ”Œ åŠ å¯†Socketç¼–ç¨‹å®ç°



### 5.1 SSLæœåŠ¡å™¨ç¼–ç¨‹



**ğŸ–¥ï¸ å®‰å…¨æœåŠ¡å™¨å®ç°**
```c
#include <sys/socket.h>

#include <netinet/in.h>

#include <openssl/ssl.h>

#include <openssl/err.h>


int create_ssl_server(int port) {
    SSL_CTX *ctx;
    int server_fd;
    struct sockaddr_in addr;
    
    // åˆå§‹åŒ–SSL
    SSL_library_init();
    SSL_load_error_strings();
    
    // åˆ›å»ºSSLä¸Šä¸‹æ–‡
    ctx = SSL_CTX_new(TLS_server_method());
    if (!ctx) {
        perror("SSL_CTX_new failed");
        exit(EXIT_FAILURE);
    }
    
    // åŠ è½½æœåŠ¡å™¨è¯ä¹¦å’Œç§é’¥
    if (SSL_CTX_use_certificate_file(ctx, "server-cert.pem", SSL_FILETYPE_PEM) <= 0) {
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }
    
    if (SSL_CTX_use_PrivateKey_file(ctx, "server-key.pem", SSL_FILETYPE_PEM) <= 0) {
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }
    
    // åˆ›å»ºsocket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;
    
    bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
    listen(server_fd, 5);
    
    printf("ğŸ”’ SSLæœåŠ¡å™¨å¯åŠ¨ï¼Œç›‘å¬ç«¯å£ %d\n", port);
    
    return server_fd;
}
```

### 5.2 SSLå®¢æˆ·ç«¯ç¼–ç¨‹



**ğŸ’» å®‰å…¨å®¢æˆ·ç«¯å®ç°**
```c
int connect_ssl_client(const char *hostname, int port) {
    SSL_CTX *ctx;
    SSL *ssl;
    int sockfd;
    struct sockaddr_in addr;
    
    // åˆ›å»ºSSLä¸Šä¸‹æ–‡
    ctx = SSL_CTX_new(TLS_client_method());
    
    // è®¾ç½®è¯ä¹¦éªŒè¯
    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL);
    SSL_CTX_set_default_verify_paths(ctx);
    
    // åˆ›å»ºsocketè¿æ¥
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    inet_pton(AF_INET, hostname, &addr.sin_addr);
    
    if (connect(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("è¿æ¥å¤±è´¥");
        return -1;
    }
    
    // å»ºç«‹SSLè¿æ¥
    ssl = SSL_new(ctx);
    SSL_set_fd(ssl, sockfd);
    
    if (SSL_connect(ssl) <= 0) {
        ERR_print_errors_fp(stderr);
        return -1;
    }
    
    printf("âœ… SSLè¿æ¥å»ºç«‹æˆåŠŸ\n");
    
    // éªŒè¯æœåŠ¡å™¨è¯ä¹¦
    verify_certificate(ssl);
    
    return sockfd;
}
```

### 5.3 åŒå‘è®¤è¯å®ç°



**ğŸ” å®¢æˆ·ç«¯è¯ä¹¦é…ç½®**
```c
void setup_mutual_auth(SSL_CTX *ctx) {
    // æœåŠ¡å™¨ç«¯è¦æ±‚å®¢æˆ·ç«¯è¯ä¹¦
    SSL_CTX_set_verify(ctx, 
        SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, 
        verify_callback);
    
    // åŠ è½½å—ä¿¡ä»»çš„CAè¯ä¹¦
    if (!SSL_CTX_load_verify_locations(ctx, "ca-cert.pem", NULL)) {
        fprintf(stderr, "âŒ åŠ è½½CAè¯ä¹¦å¤±è´¥\n");
        exit(1);
    }
    
    printf("ğŸ”’ å·²å¯ç”¨åŒå‘è®¤è¯\n");
}

// è¯ä¹¦éªŒè¯å›è°ƒå‡½æ•°
int verify_callback(int preverify_ok, X509_STORE_CTX *ctx) {
    if (!preverify_ok) {
        X509 *cert = X509_STORE_CTX_get_current_cert(ctx);
        int error = X509_STORE_CTX_get_error(ctx);
        
        char subject[256];
        X509_NAME_oneline(X509_get_subject_name(cert), subject, sizeof(subject));
        
        printf("âš ï¸ è¯ä¹¦éªŒè¯å¤±è´¥: %s\n", subject);
        printf("   é”™è¯¯: %s\n", X509_verify_cert_error_string(error));
    }
    
    return preverify_ok;
}
```

---

## 6. ğŸ” ç½‘ç»œæ•°æ®åŠ å¯†ä¼ è¾“



### 6.1 å¯¹ç§°åŠ å¯†å®ç°



**ğŸ”‘ AESåŠ å¯†ç¤ºä¾‹**
```c
#include <openssl/aes.h>

#include <openssl/rand.h>


typedef struct {
    unsigned char key[32];      // 256ä½å¯†é’¥
    unsigned char iv[16];       // åˆå§‹åŒ–å‘é‡
} crypto_params_t;

int aes_encrypt_data(const char *plaintext, char *ciphertext, 
                     crypto_params_t *params) {
    AES_KEY aes_key;
    int len = strlen(plaintext);
    
    // è®¾ç½®åŠ å¯†å¯†é’¥
    if (AES_set_encrypt_key(params->key, 256, &aes_key) < 0) {
        printf("âŒ AESå¯†é’¥è®¾ç½®å¤±è´¥\n");
        return -1;
    }
    
    // ä½¿ç”¨CBCæ¨¡å¼åŠ å¯†
    AES_cbc_encrypt((unsigned char*)plaintext, 
                    (unsigned char*)ciphertext,
                    len, &aes_key, params->iv, AES_ENCRYPT);
    
    printf("ğŸ”’ æ•°æ®åŠ å¯†å®Œæˆï¼Œé•¿åº¦: %då­—èŠ‚\n", len);
    return len;
}

int aes_decrypt_data(const char *ciphertext, char *plaintext,
                     int len, crypto_params_t *params) {
    AES_KEY aes_key;
    
    // è®¾ç½®è§£å¯†å¯†é’¥
    if (AES_set_decrypt_key(params->key, 256, &aes_key) < 0) {
        printf("âŒ AESå¯†é’¥è®¾ç½®å¤±è´¥\n");
        return -1;
    }
    
    // è§£å¯†æ•°æ®
    AES_cbc_encrypt((unsigned char*)ciphertext,
                    (unsigned char*)plaintext,
                    len, &aes_key, params->iv, AES_DECRYPT);
    
    printf("ğŸ”“ æ•°æ®è§£å¯†å®Œæˆ\n");
    return len;
}
```

### 6.2 æ¶ˆæ¯è®¤è¯ç 



**âœ… HMACå®ç°**
```c
#include <openssl/hmac.h>


int generate_hmac(const char *data, const char *key, 
                  unsigned char *digest) {
    unsigned int digest_len;
    
    HMAC(EVP_sha256(),
         key, strlen(key),
         (unsigned char*)data, strlen(data),
         digest, &digest_len);
    
    printf("ğŸ” HMACç”Ÿæˆå®Œæˆï¼Œé•¿åº¦: %då­—èŠ‚\n", digest_len);
    return digest_len;
}

int verify_hmac(const char *data, const char *key,
                const unsigned char *expected_digest) {
    unsigned char computed_digest[32];
    int len = generate_hmac(data, key, computed_digest);
    
    if (memcmp(computed_digest, expected_digest, len) == 0) {
        printf("âœ… HMACéªŒè¯é€šè¿‡\n");
        return 1;
    } else {
        printf("âŒ HMACéªŒè¯å¤±è´¥\n");
        return 0;
    }
}
```

### 6.3 å®‰å…¨éšæœºæ•°ç”Ÿæˆ



**ğŸ² å¯†ç å­¦å®‰å…¨éšæœºæ•°**
```c
#include <openssl/rand.h>


void generate_secure_random(unsigned char *buffer, int length) {
    if (RAND_bytes(buffer, length) != 1) {
        printf("âŒ å®‰å…¨éšæœºæ•°ç”Ÿæˆå¤±è´¥\n");
        exit(1);
    }
    
    printf("ğŸ² ç”Ÿæˆ %d å­—èŠ‚å®‰å…¨éšæœºæ•°\n", length);
}

void generate_session_key(crypto_params_t *params) {
    // ç”Ÿæˆ256ä½å¯†é’¥
    generate_secure_random(params->key, 32);
    
    // ç”Ÿæˆ128ä½åˆå§‹åŒ–å‘é‡
    generate_secure_random(params->iv, 16);
    
    printf("ğŸ”‘ ä¼šè¯å¯†é’¥ç”Ÿæˆå®Œæˆ\n");
}
```

---

## 7. ğŸ« èº«ä»½è®¤è¯æœºåˆ¶å®ç°



### 7.1 åŸºäºå¯†ç çš„è®¤è¯



**ğŸ” å®‰å…¨å¯†ç éªŒè¯**
```c
#include <openssl/sha.h>

#include <openssl/rand.h>


typedef struct {
    char username[64];
    unsigned char salt[16];
    unsigned char hash[32];
} user_credential_t;

// ç”Ÿæˆå¯†ç å“ˆå¸Œ
int hash_password(const char *password, unsigned char *salt, 
                  unsigned char *hash) {
    SHA256_CTX ctx;
    
    // ç”Ÿæˆéšæœºç›å€¼
    RAND_bytes(salt, 16);
    
    // è®¡ç®— SHA256(password + salt)
    SHA256_Init(&ctx);
    SHA256_Update(&ctx, password, strlen(password));
    SHA256_Update(&ctx, salt, 16);
    SHA256_Final(hash, &ctx);
    
    printf("ğŸ” å¯†ç å“ˆå¸Œç”Ÿæˆå®Œæˆ\n");
    return 1;
}

// éªŒè¯å¯†ç 
int verify_password(const char *password, const user_credential_t *user) {
    unsigned char computed_hash[32];
    SHA256_CTX ctx;
    
    // ä½¿ç”¨ç›¸åŒçš„ç›å€¼è®¡ç®—å“ˆå¸Œ
    SHA256_Init(&ctx);
    SHA256_Update(&ctx, password, strlen(password));
    SHA256_Update(&ctx, user->salt, 16);
    SHA256_Final(computed_hash, &ctx);
    
    // æ¯”è¾ƒå“ˆå¸Œå€¼
    if (memcmp(computed_hash, user->hash, 32) == 0) {
        printf("âœ… ç”¨æˆ· %s è®¤è¯æˆåŠŸ\n", user->username);
        return 1;
    } else {
        printf("âŒ ç”¨æˆ· %s è®¤è¯å¤±è´¥\n", user->username);
        return 0;
    }
}
```

### 7.2 JWTä»¤ç‰Œè®¤è¯



**ğŸ« ç®€å•JWTå®ç°**
```c
#include <openssl/bio.h>

#include <openssl/evp.h>


// Base64ç¼–ç 
char* base64_encode(const unsigned char *data, int length) {
    BIO *b64 = BIO_new(BIO_f_base64());
    BIO *mem = BIO_new(BIO_s_mem());
    BIO_push(b64, mem);
    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
    
    BIO_write(b64, data, length);
    BIO_flush(b64);
    
    char *encoded_data;
    long encoded_length = BIO_get_mem_data(mem, &encoded_data);
    
    char *result = malloc(encoded_length + 1);
    memcpy(result, encoded_data, encoded_length);
    result[encoded_length] = '\0';
    
    BIO_free_all(b64);
    return result;
}

// ç”Ÿæˆç®€å•JWTä»¤ç‰Œ
char* generate_jwt_token(const char *username, const char *secret) {
    // JWT Header (ç®€åŒ–)
    char header[] = "{\"alg\":\"HS256\",\"typ\":\"JWT\"}";
    
    // JWT Payload
    char payload[256];
    time_t now = time(NULL);
    snprintf(payload, sizeof(payload),
             "{\"sub\":\"%s\",\"iat\":%ld,\"exp\":%ld}",
             username, now, now + 3600);  // 1å°æ—¶æœ‰æ•ˆæœŸ
    
    // Base64ç¼–ç 
    char *encoded_header = base64_encode((unsigned char*)header, strlen(header));
    char *encoded_payload = base64_encode((unsigned char*)payload, strlen(payload));
    
    // ç”Ÿæˆç­¾å
    char message[512];
    snprintf(message, sizeof(message), "%s.%s", encoded_header, encoded_payload);
    
    unsigned char signature[32];
    unsigned int sig_len;
    HMAC(EVP_sha256(), secret, strlen(secret),
         (unsigned char*)message, strlen(message),
         signature, &sig_len);
    
    char *encoded_signature = base64_encode(signature, sig_len);
    
    // ç»„è£…å®Œæ•´Token
    char *token = malloc(strlen(message) + strlen(encoded_signature) + 2);
    sprintf(token, "%s.%s", message, encoded_signature);
    
    free(encoded_header);
    free(encoded_payload);
    free(encoded_signature);
    
    printf("ğŸ« JWTä»¤ç‰Œç”Ÿæˆå®Œæˆ\n");
    return token;
}
```

### 7.3 ä¼šè¯ç®¡ç†



**ğŸ“ å®‰å…¨ä¼šè¯å®ç°**
```c
#define MAX_SESSIONS 100


typedef struct {
    char session_id[33];      // 32ä½åå…­è¿›åˆ¶ + NULLç»ˆæ­¢ç¬¦
    char username[64];
    time_t created_time;
    time_t last_activity;
    int active;
} session_t;

session_t sessions[MAX_SESSIONS];
int session_count = 0;

// åˆ›å»ºæ–°ä¼šè¯
char* create_session(const char *username) {
    if (session_count >= MAX_SESSIONS) {
        printf("âŒ ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™\n");
        return NULL;
    }
    
    session_t *session = &sessions[session_count++];
    
    // ç”Ÿæˆéšæœºä¼šè¯ID
    unsigned char random_bytes[16];
    RAND_bytes(random_bytes, 16);
    
    for (int i = 0; i < 16; i++) {
        sprintf(&session->session_id[i*2], "%02x", random_bytes[i]);
    }
    
    strcpy(session->username, username);
    session->created_time = time(NULL);
    session->last_activity = session->created_time;
    session->active = 1;
    
    printf("ğŸ“ ä¸ºç”¨æˆ· %s åˆ›å»ºä¼šè¯: %s\n", username, session->session_id);
    return session->session_id;
}

// éªŒè¯ä¼šè¯
int validate_session(const char *session_id) {
    time_t now = time(NULL);
    
    for (int i = 0; i < session_count; i++) {
        if (sessions[i].active && 
            strcmp(sessions[i].session_id, session_id) == 0) {
            
            // æ£€æŸ¥ä¼šè¯æ˜¯å¦è¿‡æœŸ (30åˆ†é’Ÿ)
            if (now - sessions[i].last_activity > 1800) {
                sessions[i].active = 0;
                printf("â° ä¼šè¯å·²è¿‡æœŸ: %s\n", session_id);
                return 0;
            }
            
            // æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
            sessions[i].last_activity = now;
            printf("âœ… ä¼šè¯éªŒè¯é€šè¿‡: %s\n", sessions[i].username);
            return 1;
        }
    }
    
    printf("âŒ æ— æ•ˆä¼šè¯: %s\n", session_id);
    return 0;
}
```

---

## 8. ğŸ›¡ï¸ é˜²æ­¢ç½‘ç»œæ”»å‡»ç¼–ç¨‹æŠ€å·§



### 8.1 è¾“å…¥éªŒè¯å’Œè¿‡æ»¤



**ğŸ” å®‰å…¨è¾“å…¥æ£€æŸ¥**
```c
#include <ctype.h>

#include <regex.h>


// éªŒè¯ç”¨æˆ·åæ ¼å¼
int validate_username(const char *username) {
    int len = strlen(username);
    
    // é•¿åº¦æ£€æŸ¥
    if (len < 3 || len > 32) {
        printf("âŒ ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨3-32å­—ç¬¦ä¹‹é—´\n");
        return 0;
    }
    
    // å­—ç¬¦æ£€æŸ¥ï¼šåªå…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿
    for (int i = 0; i < len; i++) {
        if (!isalnum(username[i]) && username[i] != '_') {
            printf("âŒ ç”¨æˆ·ååŒ…å«éæ³•å­—ç¬¦: %c\n", username[i]);
            return 0;
        }
    }
    
    return 1;
}

// éªŒè¯é‚®ç®±æ ¼å¼
int validate_email(const char *email) {
    regex_t regex;
    const char *pattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    
    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        printf("âŒ æ­£åˆ™è¡¨è¾¾å¼ç¼–è¯‘å¤±è´¥\n");
        return 0;
    }
    
    int result = regexec(&regex, email, 0, NULL, 0);
    regfree(&regex);
    
    if (result == 0) {
        printf("âœ… é‚®ç®±æ ¼å¼æ­£ç¡®\n");
        return 1;
    } else {
        printf("âŒ é‚®ç®±æ ¼å¼é”™è¯¯\n");
        return 0;
    }
}

// SQLæ³¨å…¥é˜²æŠ¤
char* escape_sql_string(const char *input) {
    int len = strlen(input);
    char *escaped = malloc(len * 2 + 1);
    int j = 0;
    
    for (int i = 0; i < len; i++) {
        if (input[i] == '\'' || input[i] == '"' || input[i] == '\\') {
            escaped[j++] = '\\';
        }
        escaped[j++] = input[i];
    }
    escaped[j] = '\0';
    
    return escaped;
}
```

### 8.2 é€Ÿç‡é™åˆ¶å’Œé˜²æŠ¤



**â±ï¸ è¿æ¥é¢‘ç‡é™åˆ¶**
```c
#define MAX_CONNECTIONS_PER_IP 10

#define TIME_WINDOW 60  // 60ç§’æ—¶é—´çª—å£


typedef struct {
    char ip_address[16];
    int connection_count;
    time_t window_start;
} rate_limit_entry_t;

rate_limit_entry_t rate_limits[256];
int rate_limit_count = 0;

int check_rate_limit(const char *client_ip) {
    time_t now = time(NULL);
    
    // æŸ¥æ‰¾ç°æœ‰æ¡ç›®
    for (int i = 0; i < rate_limit_count; i++) {
        if (strcmp(rate_limits[i].ip_address, client_ip) == 0) {
            // æ£€æŸ¥æ—¶é—´çª—å£æ˜¯å¦é‡ç½®
            if (now - rate_limits[i].window_start >= TIME_WINDOW) {
                rate_limits[i].connection_count = 1;
                rate_limits[i].window_start = now;
                return 1;
            }
            
            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
            if (rate_limits[i].connection_count >= MAX_CONNECTIONS_PER_IP) {
                printf("ğŸš« IP %s è¿æ¥è¿‡äºé¢‘ç¹\n", client_ip);
                return 0;
            }
            
            rate_limits[i].connection_count++;
            return 1;
        }
    }
    
    // æ–°IPåœ°å€
    if (rate_limit_count < 256) {
        strcpy(rate_limits[rate_limit_count].ip_address, client_ip);
        rate_limits[rate_limit_count].connection_count = 1;
        rate_limits[rate_limit_count].window_start = now;
        rate_limit_count++;
    }
    
    return 1;
}
```

### 8.3 ç¼“å†²åŒºæº¢å‡ºé˜²æŠ¤



**ğŸ›¡ï¸ å®‰å…¨å­—ç¬¦ä¸²æ“ä½œ**
```c
// å®‰å…¨çš„å­—ç¬¦ä¸²å¤åˆ¶
int safe_strcpy(char *dest, size_t dest_size, const char *src) {
    if (!dest || !src || dest_size == 0) {
        return -1;
    }
    
    size_t src_len = strlen(src);
    if (src_len >= dest_size) {
        printf("âš ï¸ å­—ç¬¦ä¸²è¿‡é•¿ï¼Œæˆªæ–­å¤„ç†\n");
        strncpy(dest, src, dest_size - 1);
        dest[dest_size - 1] = '\0';
        return 0;  // è¡¨ç¤ºå‘ç”Ÿäº†æˆªæ–­
    }
    
    strcpy(dest, src);
    return 1;
}

// å®‰å…¨çš„æ•°æ®è¯»å–
int safe_read_data(int sockfd, char *buffer, size_t max_size) {
    size_t total_read = 0;
    ssize_t bytes_read;
    
    while (total_read < max_size - 1) {
        bytes_read = recv(sockfd, buffer + total_read, 
                         max_size - total_read - 1, 0);
        
        if (bytes_read <= 0) {
            break;
        }
        
        total_read += bytes_read;
        
        // æ£€æŸ¥æ˜¯å¦æ¥æ”¶åˆ°å®Œæ•´æ¶ˆæ¯ï¼ˆä»¥æ¢è¡Œç¬¦ç»“æŸï¼‰
        if (buffer[total_read - 1] == '\n') {
            break;
        }
    }
    
    buffer[total_read] = '\0';
    printf("ğŸ“¥ å®‰å…¨è¯»å– %zu å­—èŠ‚æ•°æ®\n", total_read);
    return total_read;
}
```

---

## 9. âœ¨ å®‰å…¨ç¼–ç¨‹æœ€ä½³å®è·µ



### 9.1 å®‰å…¨å¼€å‘åŸåˆ™



**ğŸ›ï¸ æ ¸å¿ƒå®‰å…¨åŸåˆ™**

| **åŸåˆ™** | **å«ä¹‰** | **ç¼–ç¨‹å®è·µ** |
|---------|---------|-------------|
| **æœ€å°æƒé™** | åªç»™å¿…éœ€çš„æœ€å°æƒé™ | ä½¿ç”¨érootç”¨æˆ·è¿è¡ŒæœåŠ¡ |
| **çºµæ·±é˜²æŠ¤** | å¤šå±‚å®‰å…¨æªæ–½ | è¾“å…¥éªŒè¯+åŠ å¯†+è®¿é—®æ§åˆ¶ |
| **é»˜è®¤å®‰å…¨** | é»˜è®¤é…ç½®è¦å®‰å…¨ | é»˜è®¤å…³é—­å±é™©åŠŸèƒ½ |
| **å¤±è´¥å®‰å…¨** | å¤±è´¥æ—¶ä¿æŒå®‰å…¨çŠ¶æ€ | è®¤è¯å¤±è´¥æ‹’ç»è®¿é—® |

### 9.2 å®‰å…¨é…ç½®ç®¡ç†



**âš™ï¸ å®‰å…¨é…ç½®å®è·µ**
```c
typedef struct {
    int enable_ssl;
    int min_tls_version;
    int max_connections;
    int session_timeout;
    char allowed_ciphers[256];
    int require_client_cert;
} security_config_t;

void load_security_config(security_config_t *config) {
    // è®¾ç½®å®‰å…¨çš„é»˜è®¤å€¼
    config->enable_ssl = 1;                    // é»˜è®¤å¯ç”¨SSL
    config->min_tls_version = 0x0303;         // æœ€ä½TLS 1.2
    config->max_connections = 100;            // é™åˆ¶è¿æ¥æ•°
    config->session_timeout = 1800;          // 30åˆ†é’Ÿä¼šè¯è¶…æ—¶
    strcpy(config->allowed_ciphers, 
           "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256");
    config->require_client_cert = 0;         // å¯é€‰çš„å®¢æˆ·ç«¯è¯ä¹¦
    
    printf("ğŸ”§ å®‰å…¨é…ç½®åŠ è½½å®Œæˆ\n");
    printf("   SSLå¯ç”¨: %s\n", config->enable_ssl ? "æ˜¯" : "å¦");
    printf("   æœ€ä½TLSç‰ˆæœ¬: 1.%d\n", (config->min_tls_version & 0xFF) - 1);
    printf("   æœ€å¤§è¿æ¥æ•°: %d\n", config->max_connections);
}
```

### 9.3 é”™è¯¯å¤„ç†å’Œæ—¥å¿—



**ğŸ“ å®‰å…¨æ—¥å¿—è®°å½•**
```c
#include <syslog.h>


typedef enum {
    LOG_SECURITY_INFO,
    LOG_SECURITY_WARNING,  
    LOG_SECURITY_ERROR,
    LOG_SECURITY_CRITICAL
} log_level_t;

void security_log(log_level_t level, const char *client_ip, 
                  const char *event, const char *details) {
    const char *level_str[] = {"INFO", "WARN", "ERROR", "CRIT"};
    time_t now = time(NULL);
    char *time_str = ctime(&now);
    time_str[strlen(time_str) - 1] = '\0';  // ç§»é™¤æ¢è¡Œç¬¦
    
    // å†™å…¥ç³»ç»Ÿæ—¥å¿—
    int syslog_priority[] = {LOG_INFO, LOG_WARNING, LOG_ERR, LOG_CRIT};
    syslog(syslog_priority[level], 
           "SECURITY [%s] %s from %s: %s", 
           level_str[level], event, client_ip, details);
    
    // åŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°ï¼ˆå¼€å‘è°ƒè¯•ç”¨ï¼‰
    printf("[%s] ğŸ”’ %s [%s] %s from %s: %s\n",
           time_str, level_str[level], "SECURITY", 
           event, client_ip, details);
}

// ä½¿ç”¨ç¤ºä¾‹
void log_authentication_attempt(const char *client_ip, 
                               const char *username, int success) {
    if (success) {
        security_log(LOG_SECURITY_INFO, client_ip, 
                    "LOGIN_SUCCESS", username);
    } else {
        char details[128];
        snprintf(details, sizeof(details), "ç”¨æˆ·å: %s", username);
        security_log(LOG_SECURITY_WARNING, client_ip, 
                    "LOGIN_FAILED", details);
    }
}
```

### 9.4 å†…å­˜å®‰å…¨ç®¡ç†



**ğŸ’¾ å®‰å…¨å†…å­˜æ“ä½œ**
```c
// å®‰å…¨æ¸…é›¶æ•æ„Ÿæ•°æ®
void secure_zero_memory(void *ptr, size_t size) {
    if (ptr) {
        // ä½¿ç”¨volatileé˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–æ‰è¿™ä¸ªæ“ä½œ
        volatile char *p = (volatile char *)ptr;
        for (size_t i = 0; i < size; i++) {
            p[i] = 0;
        }
    }
}

// å®‰å…¨é‡Šæ”¾å¯†ç ç­‰æ•æ„Ÿæ•°æ®
void secure_free_password(char *password) {
    if (password) {
        size_t len = strlen(password);
        secure_zero_memory(password, len);
        free(password);
        password = NULL;
    }
}

// å®‰å…¨çš„åŠ¨æ€å†…å­˜åˆ†é…
void* secure_malloc(size_t size) {
    void *ptr = malloc(size);
    if (!ptr) {
        printf("âŒ å†…å­˜åˆ†é…å¤±è´¥\n");
        exit(EXIT_FAILURE);
    }
    
    // åˆå§‹åŒ–ä¸ºé›¶
    memset(ptr, 0, size);
    return ptr;
}
```

---

## 10. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“



### 10.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ



```
ğŸ”¸ ç½‘ç»œå®‰å…¨ä¸‰è¦ç´ ï¼šæœºå¯†æ€§ã€å®Œæ•´æ€§ã€å¯ç”¨æ€§
ğŸ”¸ SSL/TLSåè®®ï¼šç°ä»£ç½‘ç»œåŠ å¯†é€šä¿¡çš„æ ‡å‡†
ğŸ”¸ è¯ä¹¦éªŒè¯ï¼šå»ºç«‹ä¿¡ä»»å…³ç³»çš„é‡è¦æœºåˆ¶
ğŸ”¸ åŠ å¯†ç¼–ç¨‹ï¼šå¯¹ç§°åŠ å¯†ã€éå¯¹ç§°åŠ å¯†ã€å“ˆå¸Œç®—æ³•çš„åº”ç”¨
ğŸ”¸ èº«ä»½è®¤è¯ï¼šå¯†ç éªŒè¯ã€ä»¤ç‰Œè®¤è¯ã€ä¼šè¯ç®¡ç†
ğŸ”¸ æ”»å‡»é˜²æŠ¤ï¼šè¾“å…¥éªŒè¯ã€é€Ÿç‡é™åˆ¶ã€ç¼“å†²åŒºä¿æŠ¤
ğŸ”¸ å®‰å…¨å®è·µï¼šæœ€å°æƒé™ã€çºµæ·±é˜²æŠ¤ã€å®‰å…¨é…ç½®
```

### 10.2 å…³é”®ç†è§£è¦ç‚¹



**ğŸ”¹ ä¸ºä»€ä¹ˆç½‘ç»œé€šä¿¡éœ€è¦åŠ å¯†**
```
ç½‘ç»œä¼ è¾“çš„è„†å¼±æ€§ï¼š
- æ•°æ®åŒ…å¯èƒ½è¢«æˆªè·
- å†…å®¹å¯èƒ½è¢«ç¯¡æ”¹  
- èº«ä»½å¯èƒ½è¢«ä¼ªé€ 

åŠ å¯†é€šä¿¡çš„ä»·å€¼ï¼š
- ä¿æŠ¤æ•°æ®éšç§
- ç¡®ä¿æ•°æ®å®Œæ•´æ€§
- éªŒè¯é€šä¿¡åŒæ–¹èº«ä»½
```

**ğŸ”¹ SSL/TLSæ¡æ‰‹çš„é‡è¦æ€§**
```
æ¡æ‰‹è¿‡ç¨‹ä½œç”¨ï¼š
- åå•†åŠ å¯†ç®—æ³•
- äº¤æ¢å¯†é’¥ææ–™
- éªŒè¯æœåŠ¡å™¨èº«ä»½
- å»ºç«‹å®‰å…¨é€šé“

ç†è§£è¦ç‚¹ï¼š
- æ¡æ‰‹åªå‘ç”Ÿä¸€æ¬¡ï¼Œåç»­é€šä¿¡ä½¿ç”¨ä¼šè¯å¯†é’¥
- æ¡æ‰‹è¿‡ç¨‹ç›¸å¯¹è¾ƒé‡ï¼Œåº”è¯¥å¤ç”¨è¿æ¥
- è¯ä¹¦éªŒè¯æ˜¯å®‰å…¨çš„å…³é”®ç¯èŠ‚
```

### 10.3 å®é™…åº”ç”¨ä»·å€¼



**ğŸ¯ å¼€å‘åœºæ™¯åº”ç”¨**
- **WebæœåŠ¡**ï¼šHTTPSç½‘ç«™å’ŒAPIæ¥å£å®‰å…¨
- **ç§»åŠ¨åº”ç”¨**ï¼šå®¢æˆ·ç«¯ä¸æœåŠ¡å™¨å®‰å…¨é€šä¿¡
- **ç‰©è”ç½‘**ï¼šè®¾å¤‡é—´çš„å®‰å…¨æ•°æ®ä¼ è¾“
- **é‡‘èç³»ç»Ÿ**ï¼šäº¤æ˜“æ•°æ®çš„å®‰å…¨ä¿æŠ¤

**ğŸ› ï¸ ç¼–ç¨‹å®è·µè¦ç‚¹**
```
è¯ä¹¦ç®¡ç†ï¼š
- ä½¿ç”¨å—ä¿¡ä»»çš„CAç­¾å‘çš„è¯ä¹¦
- å®šæœŸæ›´æ–°å³å°†è¿‡æœŸçš„è¯ä¹¦
- å¦¥å–„ä¿ç®¡ç§é’¥æ–‡ä»¶

ä»£ç å®‰å…¨ï¼š
- è¾“å…¥æ•°æ®å¿…é¡»éªŒè¯å’Œè¿‡æ»¤
- æ•æ„Ÿæ•°æ®ä½¿ç”¨åç«‹å³æ¸…é›¶
- é”™è¯¯ä¿¡æ¯ä¸è¦æ³„éœ²å†…éƒ¨ç»†èŠ‚

æ€§èƒ½ä¼˜åŒ–ï¼š
- å¤ç”¨SSLè¿æ¥å‡å°‘æ¡æ‰‹å¼€é”€
- ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿå¡æå‡åŠ å¯†æ€§èƒ½
- åˆç†è®¾ç½®è¶…æ—¶å’Œç¼“å­˜å‚æ•°
```

### 10.4 å­¦ä¹ æ£€æŸ¥æ¸…å•



- [ ] ç†è§£SSL/TLSæ¡æ‰‹è¿‡ç¨‹
- [ ] æŒæ¡OpenSSLåŸºæœ¬APIä½¿ç”¨
- [ ] èƒ½å¤Ÿå®ç°è¯ä¹¦éªŒè¯
- [ ] ä¼šç¼–å†™å®‰å…¨çš„Socketé€šä¿¡ç¨‹åº
- [ ] äº†è§£å¸¸è§ç½‘ç»œæ”»å‡»å’Œé˜²æŠ¤æ–¹æ³•
- [ ] èƒ½å¤Ÿè®¾è®¡å®‰å…¨çš„èº«ä»½è®¤è¯æœºåˆ¶

**ğŸ”‘ æ ¸å¿ƒè®°å¿†å£è¯€**
> SSLæ¡æ‰‹å»ºä¿¡ä»»ï¼Œè¯ä¹¦éªŒè¯å¾ˆå…³é”®
> è¾“å…¥è¿‡æ»¤é˜²æ³¨å…¥ï¼Œé€Ÿç‡é™åˆ¶æŒ¡æ”»å‡»
> å¯†ç åŠ ç›å†å“ˆå¸Œï¼Œä¼šè¯ç®¡ç†è¦åŠæ—¶
> å®‰å…¨ç¼–ç¨‹æ— å°äº‹ï¼Œçºµæ·±é˜²æŠ¤ä¿å¹³å®‰

**ğŸ’¡ å»¶ä¼¸å­¦ä¹ å»ºè®®**
- æ·±å…¥å­¦ä¹ å¯†ç å­¦ç†è®ºåŸºç¡€
- ç ”ç©¶ç°ä»£ç½‘ç»œå®‰å…¨å¨èƒå’Œé˜²æŠ¤æŠ€æœ¯
- äº†è§£å®‰å…¨å¼€å‘ç”Ÿå‘½å‘¨æœŸ(SDLC)
- å­¦ä¹ æ¸—é€æµ‹è¯•å’Œå®‰å…¨å®¡è®¡æ–¹æ³•