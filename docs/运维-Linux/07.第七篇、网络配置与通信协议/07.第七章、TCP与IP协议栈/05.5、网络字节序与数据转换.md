---
title: 5ã€ç½‘ç»œå­—èŠ‚åºä¸æ•°æ®è½¬æ¢
---
## ğŸ“š ç›®å½•

1. [å­—èŠ‚åºåŸºç¡€æ¦‚å¿µ](#1-å­—èŠ‚åºåŸºç¡€æ¦‚å¿µ)
2. [ç½‘ç»œå­—èŠ‚åºæ ‡å‡†](#2-ç½‘ç»œå­—èŠ‚åºæ ‡å‡†)
3. [å­—èŠ‚åºè½¬æ¢å‡½æ•°](#3-å­—èŠ‚åºè½¬æ¢å‡½æ•°)
4. [ç½‘ç»œç¼–ç¨‹ä¸­çš„å­—èŠ‚åºå¤„ç†](#4-ç½‘ç»œç¼–ç¨‹ä¸­çš„å­—èŠ‚åºå¤„ç†)
5. [è·¨å¹³å°å­—èŠ‚åºå¤„ç†](#5-è·¨å¹³å°å­—èŠ‚åºå¤„ç†)
6. [ç»“æ„ä½“å­—èŠ‚å¯¹é½é—®é¢˜](#6-ç»“æ„ä½“å­—èŠ‚å¯¹é½é—®é¢˜)
7. [äºŒè¿›åˆ¶æ•°æ®ç½‘ç»œä¼ è¾“](#7-äºŒè¿›åˆ¶æ•°æ®ç½‘ç»œä¼ è¾“)
8. [å­—ç¬¦ä¸²ä¸äºŒè¿›åˆ¶è½¬æ¢](#8-å­—ç¬¦ä¸²ä¸äºŒè¿›åˆ¶è½¬æ¢)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ”¢ å­—èŠ‚åºåŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯å­—èŠ‚åº


> ğŸ“– **æ ¸å¿ƒæ¦‚å¿µ**  
> **å­—èŠ‚åºï¼ˆByte Orderï¼‰**ï¼šå¤šå­—èŠ‚æ•°æ®åœ¨å†…å­˜ä¸­çš„å­˜å‚¨é¡ºåºã€‚å°±åƒæˆ‘ä»¬è¯»ä¹¦æœ‰ä»å·¦åˆ°å³å’Œä»å³åˆ°å·¦çš„åŒºåˆ«ï¼Œè®¡ç®—æœºå­˜å‚¨å¤šå­—èŠ‚æ•°æ®ä¹Ÿæœ‰ä¸åŒçš„é¡ºåºæ–¹å¼ã€‚

**ğŸ’¡ ç”Ÿæ´»ç±»æ¯”**ï¼š
æƒ³è±¡ä½ è¦åœ¨çº¸ä¸Šå†™ä¸‹æ•°å­— `1234`ï¼š
- **ä»å·¦åˆ°å³å†™**ï¼š1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£4ï¸âƒ£ ï¼ˆå¤§ç«¯åºæ€ç»´ï¼‰
- **ä»å³åˆ°å·¦å†™**ï¼š4ï¸âƒ£3ï¸âƒ£2ï¸âƒ£1ï¸âƒ£ ï¼ˆå°ç«¯åºæ€ç»´ï¼‰

### 1.2 å¤§ç«¯åºä¸å°ç«¯åºè¯¦è§£


```
ä»¥32ä½æ•´æ•° 0x12345678 ä¸ºä¾‹ï¼š

å†…å­˜åœ°å€ï¼š     0x1000  0x1001  0x1002  0x1003
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
å¤§ç«¯åºå­˜å‚¨ï¼š  â”‚  12   â”‚  34   â”‚  56   â”‚  78   â”‚ â† é«˜ä½å­—èŠ‚åœ¨å‰
            â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
            
å°ç«¯åºå­˜å‚¨ï¼š  â”‚  78   â”‚  56   â”‚  34   â”‚  12   â”‚ â† ä½ä½å­—èŠ‚åœ¨å‰
            â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ” è¯¦ç»†å¯¹æ¯”**ï¼š

| å­—èŠ‚åºç±»å‹ | **å­˜å‚¨æ–¹å¼** | **ä»£è¡¨æ¶æ„** | **ç‰¹ç‚¹** |
|-----------|-------------|-------------|----------|
| ğŸ”¹ **å¤§ç«¯åº** | `é«˜ä½å­—èŠ‚å­˜å‚¨åœ¨ä½åœ°å€` | `PowerPCã€SPARCã€ç½‘ç»œåè®®` | `ç¬¦åˆäººç±»é˜…è¯»ä¹ æƒ¯` |
| ğŸ”¸ **å°ç«¯åº** | `ä½ä½å­—èŠ‚å­˜å‚¨åœ¨ä½åœ°å€` | `x86ã€x86_64ã€ARMï¼ˆå¤šæ•°ï¼‰` | `ä¾¿äºCPUå¤„ç†è¿ç®—` |

### 1.3 å­—èŠ‚åºçš„å†å²ç”±æ¥


**ğŸ§  è®°å¿†æŠ€å·§**ï¼š
- **Big Endianï¼ˆå¤§ç«¯åºï¼‰**ï¼šBig = å¤§å¤´ï¼Œå¤§å¤´ï¼ˆé«˜ä½å­—èŠ‚ï¼‰åœ¨å‰é¢
- **Little Endianï¼ˆå°ç«¯åºï¼‰**ï¼šLittle = å°å¤´ï¼Œå°å¤´ï¼ˆä½ä½å­—èŠ‚ï¼‰åœ¨å‰é¢

> ğŸ’¡ **æœ‰è¶£å…¸æ•…**  
> è¿™ä¸ªå‘½åæ¥è‡ªã€Šæ ¼åˆ—ä½›æ¸¸è®°ã€‹ä¸­çš„"å¤§ç«¯æ´¾"å’Œ"å°ç«¯æ´¾"äº‰è®ºâ€”â€”ç©¶ç«Ÿåº”è¯¥ä»é¸¡è›‹çš„å“ªä¸€ç«¯å¼€å§‹åƒèµ·ã€‚è®¡ç®—æœºç§‘å­¦å®¶å€Ÿç”¨è¿™ä¸ªå…¸æ•…æ¥æè¿°å­—èŠ‚å­˜å‚¨çš„ä¸¤ç§æ–¹å¼ã€‚

---

## 2. ğŸŒ ç½‘ç»œå­—èŠ‚åºæ ‡å‡†


### 2.1 ä¸ºä»€ä¹ˆéœ€è¦ç½‘ç»œå­—èŠ‚åº


**ğŸ¯ é—®é¢˜åœºæ™¯**ï¼š
```
åœºæ™¯1ï¼šä¸åŒæ¶æ„é€šä¿¡
x86æœºå™¨ï¼ˆå°ç«¯åºï¼‰ â”€â”€å‘é€æ•°æ®â”€â”€> PowerPCæœºå™¨ï¼ˆå¤§ç«¯åºï¼‰
å‘é€ï¼š0x12345678     æ¥æ”¶è§£æï¼š0x78563412  â† æ•°æ®é”™ä¹±ï¼

åœºæ™¯2ï¼šç»Ÿä¸€æ ‡å‡†å
x86æœºå™¨ â”€â”€è½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åºâ”€â”€> ç½‘ç»œ â”€â”€è½¬æ¢ä¸ºæœ¬æœºå­—èŠ‚åºâ”€â”€> PowerPCæœºå™¨
0x12345678 â†’ 0x12345678 â†’ ç½‘ç»œä¼ è¾“ â†’ 0x12345678 â†’ 0x12345678  âœ“
```

### 2.2 ç½‘ç»œå­—èŠ‚åºè§„èŒƒ


> ğŸ“‹ **ç½‘ç»œå­—èŠ‚åºæ ‡å‡†**  
> **RFCå®šä¹‰**ï¼šç½‘ç»œä¼ è¾“ä¸­æ‰€æœ‰å¤šå­—èŠ‚æ•´æ•°å¿…é¡»ä½¿ç”¨**å¤§ç«¯åº**æ ¼å¼  
> **é€‚ç”¨èŒƒå›´**ï¼šIPåœ°å€ã€ç«¯å£å·ã€é•¿åº¦å­—æ®µã€æ‰€æœ‰åè®®å¤´éƒ¨çš„æ•°å€¼å­—æ®µ

**ğŸ”— åè®®ç¤ºä¾‹**ï¼š
```
TCPå¤´éƒ¨ä¸­çš„ç«¯å£å·ï¼š
æºç«¯å£ï¼ˆ16ä½ï¼‰ï¼š80 (HTTP)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   00    â”‚   50    â”‚  â† ç½‘ç»œå­—èŠ‚åºå­˜å‚¨
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
åœ¨x86æœºå™¨å†…å­˜ä¸­ä¼šè½¬æ¢ä¸ºï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   50    â”‚   00    â”‚  â† å°ç«¯åºå­˜å‚¨
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 ç½‘ç»œå­—èŠ‚åºçš„ä¼˜åŠ¿


**â­ ä¸»è¦ä¼˜åŠ¿**ï¼š
- **ğŸ”„ ç»Ÿä¸€æ ‡å‡†**ï¼šæ¶ˆé™¤ä¸åŒæ¶æ„é—´çš„å­—èŠ‚åºå·®å¼‚
- **ğŸ›¡ï¸ æ•°æ®å®Œæ•´æ€§**ï¼šç¡®ä¿ç½‘ç»œä¼ è¾“æ•°æ®çš„æ­£ç¡®è§£æ
- **ğŸŒ å…¨çƒå…¼å®¹**ï¼šæ”¯æŒå¼‚æ„ç³»ç»Ÿé—´çš„æ— ç¼é€šä¿¡
- **ğŸ“ åè®®ç®€åŒ–**ï¼šåè®®è®¾è®¡ä¸éœ€è¦è€ƒè™‘å­—èŠ‚åºé—®é¢˜

---

## 3. ğŸ”§ å­—èŠ‚åºè½¬æ¢å‡½æ•°


### 3.1 æ ‡å‡†è½¬æ¢å‡½æ•°æ—


Linuxæä¾›äº†4ä¸ªæ ¸å¿ƒçš„å­—èŠ‚åºè½¬æ¢å‡½æ•°ï¼š

```c
#include <arpa/inet.h>

// Host TO Network (ä¸»æœºåº â†’ ç½‘ç»œåº)
uint16_t htons(uint16_t hostshort);    // 16ä½çŸ­æ•´æ•°
uint32_t htonl(uint32_t hostlong);     // 32ä½é•¿æ•´æ•°

// Network TO Host (ç½‘ç»œåº â†’ ä¸»æœºåº)  
uint16_t ntohs(uint16_t netshort);     // 16ä½çŸ­æ•´æ•°
uint32_t ntohl(uint32_t netlong);      // 32ä½é•¿æ•´æ•°
```

**ğŸ§  å‡½æ•°åè®°å¿†æ³•**ï¼š
- **h** = hostï¼ˆä¸»æœºï¼‰
- **n** = networkï¼ˆç½‘ç»œï¼‰  
- **to** = è½¬æ¢åˆ°
- **s** = shortï¼ˆ16ä½ï¼‰
- **l** = longï¼ˆ32ä½ï¼‰

### 3.2 å‡½æ•°ä½¿ç”¨ç¤ºä¾‹


```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    // åŸå§‹æ•°æ®
    uint16_t port = 80;           // HTTPç«¯å£
    uint32_t ip = 0xC0A80001;     // 192.168.0.1
    
    printf("=== åŸå§‹ä¸»æœºåºæ•°æ® ===\n");
    printf("ç«¯å£: %u (0x%04X)\n", port, port);
    printf("IP: 0x%08X\n", ip);
    
    // è½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åº
    uint16_t net_port = htons(port);
    uint32_t net_ip = htonl(ip);
    
    printf("\n=== ç½‘ç»œå­—èŠ‚åºæ•°æ® ===\n");
    printf("ç½‘ç»œç«¯å£: 0x%04X\n", net_port);
    printf("ç½‘ç»œIP: 0x%08X\n", net_ip);
    
    // è½¬æ¢å›ä¸»æœºå­—èŠ‚åº
    uint16_t host_port = ntohs(net_port);
    uint32_t host_ip = ntohl(net_ip);
    
    printf("\n=== è½¬æ¢å›ä¸»æœºåº ===\n");
    printf("æ¢å¤ç«¯å£: %u\n", host_port);
    printf("æ¢å¤IP: 0x%08X\n", host_ip);
    
    return 0;
}
```

### 3.3 64ä½æ•°æ®çš„å¤„ç†


å¯¹äº64ä½æ•°æ®ï¼ŒLinuxæä¾›äº†æ‰©å±•å‡½æ•°ï¼š

```c
#include <endian.h>

// 64ä½å­—èŠ‚åºè½¬æ¢
uint64_t htobe64(uint64_t host_64bits);  // host to big endian
uint64_t be64toh(uint64_t big_endian_64bits);  // big endian to host
```

**ğŸ“Š ä½¿ç”¨åœºæ™¯**ï¼š
- **æ—¶é—´æˆ³**ï¼š64ä½æ—¶é—´å€¼çš„ç½‘ç»œä¼ è¾“
- **æ–‡ä»¶å¤§å°**ï¼šå¤§æ–‡ä»¶ä¿¡æ¯çš„åè®®ä¼ è¾“
- **é«˜ç²¾åº¦è®¡æ•°å™¨**ï¼š64ä½è®¡æ•°å€¼çš„ç½‘ç»œåŒæ­¥

---

## 4. ğŸŒ ç½‘ç»œç¼–ç¨‹ä¸­çš„å­—èŠ‚åºå¤„ç†


### 4.1 Socketç¼–ç¨‹ä¸­çš„å­—èŠ‚åº


**ğŸ”¸ å…³é”®åœºæ™¯**ï¼šæ‰€æœ‰æ¶‰åŠç½‘ç»œä¼ è¾“çš„æ•°å€¼éƒ½éœ€è¦è½¬æ¢

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

// æ­£ç¡®çš„SocketæœåŠ¡å™¨è®¾ç½®
int create_server(uint16_t port) {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);  // â† å…³é”®ï¼šç«¯å£è½¬æ¢
    
    bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));
    return sockfd;
}
```

### 4.2 å¸¸è§é”™è¯¯æ¡ˆä¾‹


âŒ **é”™è¯¯åšæ³•**ï¼š
```c
// å±é™©ï¼šå¿˜è®°è½¬æ¢å­—èŠ‚åº
server_addr.sin_port = 80;  // é”™è¯¯ï¼ç›´æ¥ä½¿ç”¨ä¸»æœºå­—èŠ‚åº
```

âœ… **æ­£ç¡®åšæ³•**ï¼š
```c
// å®‰å…¨ï¼šæ­£ç¡®è½¬æ¢å­—èŠ‚åº
server_addr.sin_port = htons(80);  // æ­£ç¡®ï¼è½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åº
```

### 4.3 IPåœ°å€çš„å­—èŠ‚åºå¤„ç†


```c
#include <arpa/inet.h>

// IPåœ°å€å­—ç¬¦ä¸²è½¬æ¢ç¤ºä¾‹
int ip_conversion_demo() {
    char ip_str[] = "192.168.1.100";
    struct in_addr addr;
    
    // å­—ç¬¦ä¸² â†’ ç½‘ç»œå­—èŠ‚åºäºŒè¿›åˆ¶
    if (inet_aton(ip_str, &addr) == 0) {
        printf("IPåœ°å€æ ¼å¼é”™è¯¯\n");
        return -1;
    }
    
    printf("IPå­—ç¬¦ä¸²: %s\n", ip_str);
    printf("ç½‘ç»œå­—èŠ‚åº: 0x%08X\n", addr.s_addr);
    printf("ä¸»æœºå­—èŠ‚åº: 0x%08X\n", ntohl(addr.s_addr));
    
    // ç½‘ç»œå­—èŠ‚åºäºŒè¿›åˆ¶ â†’ å­—ç¬¦ä¸²
    char *converted = inet_ntoa(addr);
    printf("è½¬æ¢å›å­—ç¬¦ä¸²: %s\n", converted);
    
    return 0;
}
```

---

## 5. ğŸ”„ è·¨å¹³å°å­—èŠ‚åºå¤„ç†


### 5.1 å­—èŠ‚åºæ£€æµ‹


**ğŸ” è¿è¡Œæ—¶æ£€æµ‹æ–¹æ³•**ï¼š

```c
#include <stdio.h>

// æ–¹æ³•1ï¼šè”åˆä½“æ£€æµ‹
int check_endian_union() {
    union {
        uint32_t i;
        char c[4];
    } test = {0x12345678};
    
    if (test.c[0] == 0x12) {
        printf("å½“å‰ç³»ç»Ÿï¼šå¤§ç«¯åº\n");
        return 1;  // å¤§ç«¯åº
    } else {
        printf("å½“å‰ç³»ç»Ÿï¼šå°ç«¯åº\n");
        return 0;  // å°ç«¯åº
    }
}

// æ–¹æ³•2ï¼šæŒ‡é’ˆæ£€æµ‹
int check_endian_pointer() {
    uint32_t test = 0x12345678;
    char *p = (char*)&test;
    
    printf("å†…å­˜å¸ƒå±€: ");
    for(int i = 0; i < 4; i++) {
        printf("%02X ", (unsigned char)p[i]);
    }
    printf("\n");
    
    return (p[0] == 0x12) ? 1 : 0;
}
```

### 5.2 ç¼–è¯‘æ—¶å­—èŠ‚åºæ£€æµ‹


```c
#include <endian.h>

// ç¼–è¯‘æ—¶å¸¸é‡æ£€æµ‹
void compile_time_endian_check() {
    #if __BYTE_ORDER == __LITTLE_ENDIAN
        printf("ç¼–è¯‘æ—¶ç¡®å®šï¼šå°ç«¯åºç³»ç»Ÿ\n");
    #elif __BYTE_ORDER == __BIG_ENDIAN
        printf("ç¼–è¯‘æ—¶ç¡®å®šï¼šå¤§ç«¯åºç³»ç»Ÿ\n");
    #else
        printf("ç¼–è¯‘æ—¶ç¡®å®šï¼šæœªçŸ¥å­—èŠ‚åº\n");
    #endif
}
```

### 5.3 å¯ç§»æ¤çš„å­—èŠ‚åºå¤„ç†


```c
// é€šç”¨å­—èŠ‚åºè½¬æ¢å®
#ifndef htobe32
    #if __BYTE_ORDER == __LITTLE_ENDIAN
        #define htobe32(x) __builtin_bswap32(x)
        #define be32toh(x) __builtin_bswap32(x)
    #else
        #define htobe32(x) (x)
        #define be32toh(x) (x)
    #endif
#endif
```

---

## 6. ğŸ“ ç»“æ„ä½“å­—èŠ‚å¯¹é½é—®é¢˜


### 6.1 å­—èŠ‚å¯¹é½åŸºç¡€


> ğŸ’¡ **æ¦‚å¿µè§£é‡Š**  
> **å­—èŠ‚å¯¹é½**ï¼šç¼–è¯‘å™¨ä¸ºäº†æé«˜è®¿é—®æ•ˆç‡ï¼Œä¼šåœ¨ç»“æ„ä½“æˆå‘˜ä¹‹é—´æ’å…¥å¡«å……å­—èŠ‚ï¼Œä½¿æˆå‘˜æŒ‰ç‰¹å®šè¾¹ç•Œå¯¹é½ã€‚

```c
// é»˜è®¤å¯¹é½çš„ç»“æ„ä½“
struct default_align {
    char a;      // 1å­—èŠ‚
    // å¡«å……3å­—èŠ‚
    int b;       // 4å­—èŠ‚  
    char c;      // 1å­—èŠ‚
    // å¡«å……3å­—èŠ‚
};
// æ€»å¤§å°ï¼š12å­—èŠ‚ï¼ˆè€Œä¸æ˜¯6å­—èŠ‚ï¼‰

printf("ç»“æ„ä½“å¤§å°: %zu\n", sizeof(struct default_align));  // è¾“å‡ºï¼š12
```

### 6.2 ç½‘ç»œä¼ è¾“ä¸­çš„å¯¹é½é—®é¢˜


**âš ï¸ ç½‘ç»œä¼ è¾“é™·é˜±**ï¼š
```c
// é—®é¢˜ï¼šç›´æ¥ä¼ è¾“å¯¹é½ç»“æ„ä½“
struct network_packet {
    uint16_t type;     // 2å­—èŠ‚
    // å¡«å……2å­—èŠ‚ â† é—®é¢˜æ‰€åœ¨ï¼
    uint32_t length;   // 4å­—èŠ‚
    uint16_t checksum; // 2å­—èŠ‚
    // å¡«å……2å­—èŠ‚
};  // æ€»å¤§å°ï¼š12å­—èŠ‚ï¼Œä½†é€»è¾‘åªéœ€8å­—èŠ‚
```

### 6.3 è§£å†³æ–¹æ¡ˆï¼šç´§å‡‘ç»“æ„ä½“


```c
// æ–¹æ¡ˆ1ï¼šä½¿ç”¨packedå±æ€§
struct __attribute__((packed)) network_packet {
    uint16_t type;
    uint32_t length;
    uint16_t checksum;
};  // å¤§å°ï¼š8å­—èŠ‚ï¼Œæ— å¡«å……

// æ–¹æ¡ˆ2ï¼šä½¿ç”¨pragmaæŒ‡ä»¤
#pragma pack(1)
struct tight_packet {
    uint16_t type;
    uint32_t length;
    uint16_t checksum;
};
#pragma pack()
```

### 6.4 å®‰å…¨çš„ç½‘ç»œæ•°æ®ä¼ è¾“


```c
// æ¨èæ–¹æ³•ï¼šæ‰‹åŠ¨åºåˆ—åŒ–
void serialize_packet(struct network_packet *pkt, char *buffer) {
    uint16_t net_type = htons(pkt->type);
    uint32_t net_length = htonl(pkt->length);
    uint16_t net_checksum = htons(pkt->checksum);
    
    memcpy(buffer, &net_type, 2);
    memcpy(buffer + 2, &net_length, 4);
    memcpy(buffer + 6, &net_checksum, 2);
}

void deserialize_packet(char *buffer, struct network_packet *pkt) {
    uint16_t net_type, net_checksum;
    uint32_t net_length;
    
    memcpy(&net_type, buffer, 2);
    memcpy(&net_length, buffer + 2, 4);
    memcpy(&net_checksum, buffer + 6, 2);
    
    pkt->type = ntohs(net_type);
    pkt->length = ntohl(net_length);
    pkt->checksum = ntohs(net_checksum);
}
```

---

## 7. ğŸ“¦ äºŒè¿›åˆ¶æ•°æ®ç½‘ç»œä¼ è¾“


### 7.1 äºŒè¿›åˆ¶æ•°æ®ä¼ è¾“ç­–ç•¥


**ğŸ¯ æ ¸å¿ƒåŸåˆ™**ï¼š
1. **å®šé•¿å¤´éƒ¨**ï¼šæè¿°æ•°æ®æ ¼å¼å’Œé•¿åº¦
2. **å­—èŠ‚åºè½¬æ¢**ï¼šæ‰€æœ‰å¤šå­—èŠ‚æ•°å€¼è½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åº
3. **è¾¹ç•Œå¯¹é½**ï¼šé¿å…ç»“æ„ä½“å¡«å……å¸¦æ¥çš„é—®é¢˜

```c
// é€šç”¨äºŒè¿›åˆ¶æ•°æ®åŒ…æ ¼å¼
struct binary_packet {
    uint32_t magic;      // é­”æ•°ï¼Œç”¨äºéªŒè¯
    uint16_t version;    // åè®®ç‰ˆæœ¬
    uint16_t type;       // æ•°æ®ç±»å‹
    uint32_t length;     // æ•°æ®é•¿åº¦
    // ç´§è·Ÿå®é™…æ•°æ®
};
```

### 7.2 å®é™…ä¼ è¾“ç¤ºä¾‹


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>

#define MAGIC_NUMBER 0x12345678

// å‘é€äºŒè¿›åˆ¶æ•°æ®
int send_binary_data(int sockfd, uint16_t type, void *data, uint32_t len) {
    // 1. å‡†å¤‡å¤´éƒ¨
    struct binary_packet header;
    header.magic = htonl(MAGIC_NUMBER);
    header.version = htons(1);
    header.type = htons(type);
    header.length = htonl(len);
    
    // 2. å‘é€å¤´éƒ¨
    if (send(sockfd, &header, sizeof(header), 0) != sizeof(header)) {
        perror("å‘é€å¤´éƒ¨å¤±è´¥");
        return -1;
    }
    
    // 3. å‘é€æ•°æ®
    if (len > 0 && send(sockfd, data, len, 0) != len) {
        perror("å‘é€æ•°æ®å¤±è´¥");
        return -1;
    }
    
    return 0;
}

// æ¥æ”¶äºŒè¿›åˆ¶æ•°æ®
int recv_binary_data(int sockfd, uint16_t *type, void **data, uint32_t *len) {
    struct binary_packet header;
    
    // 1. æ¥æ”¶å¤´éƒ¨
    if (recv(sockfd, &header, sizeof(header), MSG_WAITALL) != sizeof(header)) {
        perror("æ¥æ”¶å¤´éƒ¨å¤±è´¥");
        return -1;
    }
    
    // 2. éªŒè¯é­”æ•°
    if (ntohl(header.magic) != MAGIC_NUMBER) {
        printf("æ— æ•ˆçš„é­”æ•°: 0x%08X\n", ntohl(header.magic));
        return -1;
    }
    
    // 3. è§£æå¤´éƒ¨ä¿¡æ¯
    *type = ntohs(header.type);
    *len = ntohl(header.length);
    
    // 4. æ¥æ”¶æ•°æ®
    if (*len > 0) {
        *data = malloc(*len);
        if (recv(sockfd, *data, *len, MSG_WAITALL) != *len) {
            free(*data);
            perror("æ¥æ”¶æ•°æ®å¤±è´¥");
            return -1;
        }
    } else {
        *data = NULL;
    }
    
    return 0;
}
```

### 7.3 å¤æ‚æ•°æ®ç»“æ„çš„å¤„ç†


```c
// ç¤ºä¾‹ï¼šä¼ è¾“å­¦ç”Ÿä¿¡æ¯ç»“æ„
struct student_info {
    uint32_t id;
    char name[32];
    uint16_t age;
    float score;
};

// åºåˆ—åŒ–å‡½æ•°
int serialize_student(struct student_info *student, char *buffer, int buffer_size) {
    if (buffer_size < sizeof(uint32_t) + 32 + sizeof(uint16_t) + sizeof(uint32_t)) {
        return -1;  // ç¼“å†²åŒºå¤ªå°
    }
    
    int offset = 0;
    
    // IDï¼ˆéœ€è¦å­—èŠ‚åºè½¬æ¢ï¼‰
    uint32_t net_id = htonl(student->id);
    memcpy(buffer + offset, &net_id, sizeof(uint32_t));
    offset += sizeof(uint32_t);
    
    // å§“åï¼ˆå­—ç¬¦ä¸²ä¸éœ€è¦å­—èŠ‚åºè½¬æ¢ï¼‰
    memcpy(buffer + offset, student->name, 32);
    offset += 32;
    
    // å¹´é¾„ï¼ˆéœ€è¦å­—èŠ‚åºè½¬æ¢ï¼‰
    uint16_t net_age = htons(student->age);
    memcpy(buffer + offset, &net_age, sizeof(uint16_t));
    offset += sizeof(uint16_t);
    
    // åˆ†æ•°ï¼ˆæµ®ç‚¹æ•°è½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åºï¼‰
    uint32_t score_bits = htonl(*(uint32_t*)&student->score);
    memcpy(buffer + offset, &score_bits, sizeof(uint32_t));
    offset += sizeof(uint32_t);
    
    return offset;  // è¿”å›å®é™…ä½¿ç”¨çš„å­—èŠ‚æ•°
}
```

---

## 8. ğŸ”¤ å­—ç¬¦ä¸²ä¸äºŒè¿›åˆ¶è½¬æ¢


### 8.1 å­—ç¬¦ä¸²ç¼–ç å¤„ç†


**ğŸ”¸ å­—ç¬¦ä¸²ä¼ è¾“æ³¨æ„äº‹é¡¹**ï¼š
- **ASCIIå­—ç¬¦ä¸²**ï¼šä¸éœ€è¦å­—èŠ‚åºè½¬æ¢
- **Unicodeå­—ç¬¦ä¸²**ï¼šéœ€è¦æ³¨æ„ç¼–ç æ ¼å¼
- **é•¿åº¦ä¿¡æ¯**ï¼šå­—ç¬¦ä¸²é•¿åº¦éœ€è¦å­—èŠ‚åºè½¬æ¢

```c
// å®‰å…¨çš„å­—ç¬¦ä¸²ä¼ è¾“å‡½æ•°
int send_string(int sockfd, const char *str) {
    uint32_t len = strlen(str);
    uint32_t net_len = htonl(len);
    
    // å…ˆå‘é€é•¿åº¦ï¼ˆç½‘ç»œå­—èŠ‚åºï¼‰
    if (send(sockfd, &net_len, sizeof(net_len), 0) != sizeof(net_len)) {
        return -1;
    }
    
    // å†å‘é€å­—ç¬¦ä¸²å†…å®¹
    if (len > 0 && send(sockfd, str, len, 0) != len) {
        return -1;
    }
    
    return 0;
}

char* recv_string(int sockfd) {
    uint32_t net_len, len;
    
    // æ¥æ”¶é•¿åº¦ä¿¡æ¯
    if (recv(sockfd, &net_len, sizeof(net_len), MSG_WAITALL) != sizeof(net_len)) {
        return NULL;
    }
    
    len = ntohl(net_len);
    if (len == 0) {
        return strdup("");  // ç©ºå­—ç¬¦ä¸²
    }
    
    // åˆ†é…å†…å­˜å¹¶æ¥æ”¶å­—ç¬¦ä¸²
    char *str = malloc(len + 1);
    if (recv(sockfd, str, len, MSG_WAITALL) != len) {
        free(str);
        return NULL;
    }
    
    str[len] = '\0';  // æ·»åŠ å­—ç¬¦ä¸²ç»“æŸç¬¦
    return str;
}
```

### 8.2 äºŒè¿›åˆ¶æ•°æ®çš„æ–‡æœ¬è¡¨ç¤º


```c
#include <ctype.h>

// äºŒè¿›åˆ¶æ•°æ®è½¬åå…­è¿›åˆ¶å­—ç¬¦ä¸²
char* binary_to_hex(const unsigned char *data, size_t len) {
    char *hex_str = malloc(len * 2 + 1);
    for (size_t i = 0; i < len; i++) {
        sprintf(hex_str + i * 2, "%02X", data[i]);
    }
    hex_str[len * 2] = '\0';
    return hex_str;
}

// åå…­è¿›åˆ¶å­—ç¬¦ä¸²è½¬äºŒè¿›åˆ¶æ•°æ®
unsigned char* hex_to_binary(const char *hex_str, size_t *out_len) {
    size_t len = strlen(hex_str);
    if (len % 2 != 0) return NULL;  // é•¿åº¦å¿…é¡»æ˜¯å¶æ•°
    
    *out_len = len / 2;
    unsigned char *data = malloc(*out_len);
    
    for (size_t i = 0; i < *out_len; i++) {
        sscanf(hex_str + i * 2, "%2hhX", &data[i]);
    }
    
    return data;
}

// æ‰“å°äºŒè¿›åˆ¶æ•°æ®ï¼ˆè°ƒè¯•ç”¨ï¼‰
void print_binary_data(const unsigned char *data, size_t len) {
    printf("äºŒè¿›åˆ¶æ•°æ® (%zu å­—èŠ‚):\n", len);
    printf("åå…­è¿›åˆ¶: ");
    for (size_t i = 0; i < len; i++) {
        printf("%02X ", data[i]);
        if ((i + 1) % 16 == 0) printf("\n         ");
    }
    printf("\n");
    
    printf("ASCIIè§†å›¾: ");
    for (size_t i = 0; i < len; i++) {
        printf("%c", isprint(data[i]) ? data[i] : '.');
    }
    printf("\n");
}
```

### 8.3 Base64ç¼–ç å¤„ç†


å¯¹äºéœ€è¦åœ¨æ–‡æœ¬åè®®ä¸­ä¼ è¾“äºŒè¿›åˆ¶æ•°æ®çš„åœºæ™¯ï¼š

```c
// ç®€åŒ–çš„Base64ç¼–ç ç¤ºä¾‹ï¼ˆå®é™…ä½¿ç”¨å»ºè®®ç”¨æ ‡å‡†åº“ï¼‰
static const char base64_chars[] = 
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

char* base64_encode(const unsigned char *data, size_t len) {
    size_t out_len = ((len + 2) / 3) * 4;
    char *encoded = malloc(out_len + 1);
    size_t i, j = 0;
    
    for (i = 0; i < len; i += 3) {
        uint32_t octet_a = i < len ? data[i] : 0;
        uint32_t octet_b = i + 1 < len ? data[i + 1] : 0;
        uint32_t octet_c = i + 2 < len ? data[i + 2] : 0;
        
        uint32_t triple = (octet_a << 16) + (octet_b << 8) + octet_c;
        
        encoded[j++] = base64_chars[(triple >> 18) & 63];
        encoded[j++] = base64_chars[(triple >> 12) & 63];
        encoded[j++] = (i + 1 < len) ? base64_chars[(triple >> 6) & 63] : '=';
        encoded[j++] = (i + 2 < len) ? base64_chars[triple & 63] : '=';
    }
    
    encoded[out_len] = '\0';
    return encoded;
}
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


> ğŸ¯ **å­—èŠ‚åºæ ¸å¿ƒè¦ç‚¹**  
> - **å¤§ç«¯åº**ï¼šé«˜ä½å­—èŠ‚åœ¨å‰ï¼Œç¬¦åˆäººç±»é˜…è¯»ä¹ æƒ¯ï¼Œç½‘ç»œæ ‡å‡†
> - **å°ç«¯åº**ï¼šä½ä½å­—èŠ‚åœ¨å‰ï¼Œä¾¿äºCPUè¿ç®—ï¼Œx86æ¶æ„
> - **ç½‘ç»œå­—èŠ‚åº**ï¼šç»Ÿä¸€ä½¿ç”¨å¤§ç«¯åºï¼Œæ¶ˆé™¤å¹³å°å·®å¼‚
> - **è½¬æ¢å‡½æ•°**ï¼šhtons/htonlï¼ˆä¸»æœºâ†’ç½‘ç»œï¼‰ï¼Œntohs/ntohlï¼ˆç½‘ç»œâ†’ä¸»æœºï¼‰

### 9.2 å®æˆ˜ç¼–ç¨‹è¦ç‚¹


**âœ… å¿…åšäº‹é¡¹**ï¼š
- ğŸ”¹ **ç«¯å£å·è½¬æ¢**ï¼š`sin_port = htons(port)`
- ğŸ”¹ **IPåœ°å€è½¬æ¢**ï¼šä½¿ç”¨ `inet_aton`ã€`inet_ntoa`
- ğŸ”¹ **æ•°æ®åŒ…å¤´éƒ¨**ï¼šæ‰€æœ‰å¤šå­—èŠ‚æ•°å€¼éƒ½è¦è½¬æ¢
- ğŸ”¹ **ç»“æ„ä½“ä¼ è¾“**ï¼šä½¿ç”¨æ‰‹åŠ¨åºåˆ—åŒ–ï¼Œé¿å…å­—èŠ‚å¯¹é½é—®é¢˜

**âŒ å¸¸è§é”™è¯¯**ï¼š
- ğŸ”¸ ç›´æ¥ä¼ è¾“ç»“æ„ä½“ï¼ˆå­—èŠ‚å¯¹é½é—®é¢˜ï¼‰
- ğŸ”¸ å¿˜è®°è½¬æ¢ç«¯å£å·å’Œé•¿åº¦å­—æ®µ
- ğŸ”¸ æ··æ·†ä¸»æœºå­—èŠ‚åºå’Œç½‘ç»œå­—èŠ‚åº
- ğŸ”¸ åœ¨ä¸åŒå¹³å°é—´ç›´æ¥æ‹·è´äºŒè¿›åˆ¶æ•°æ®

### 9.3 æ€§èƒ½ä¸å…¼å®¹æ€§è€ƒè™‘


**âš¡ æ€§èƒ½ä¼˜åŒ–**ï¼š
```
è½¬æ¢æ—¶æœºé€‰æ‹©ï¼š
- å‘é€æ—¶è½¬æ¢ï¼šæ•°æ®å‡†å¤‡é˜¶æ®µä¸€æ¬¡æ€§è½¬æ¢
- æ¥æ”¶æ—¶è½¬æ¢ï¼šæ•°æ®è§£æé˜¶æ®µæŒ‰éœ€è½¬æ¢  
- æ‰¹é‡è½¬æ¢ï¼šå¤šä¸ªç›¸åŒç±»å‹æ•°æ®ä¸€èµ·å¤„ç†
```

**ğŸŒ è·¨å¹³å°å…¼å®¹**ï¼š
- **ç¼–è¯‘æ—¶æ£€æµ‹**ï¼šä½¿ç”¨ `__BYTE_ORDER` å®
- **è¿è¡Œæ—¶æ£€æµ‹**ï¼šè”åˆä½“æˆ–æŒ‡é’ˆæ–¹æ³•
- **æ ‡å‡†å‡½æ•°**ï¼šä¼˜å…ˆä½¿ç”¨ç³»ç»Ÿæä¾›çš„è½¬æ¢å‡½æ•°
- **æµ‹è¯•éªŒè¯**ï¼šåœ¨ä¸åŒæ¶æ„ä¸ŠéªŒè¯æ•°æ®æ­£ç¡®æ€§

### 9.4 è°ƒè¯•ä¸æ’é”™æŠ€å·§


**ğŸ” è°ƒè¯•æ–¹æ³•**ï¼š
- **åå…­è¿›åˆ¶æ‰“å°**ï¼šè§‚å¯Ÿå†…å­˜ä¸­çš„å®é™…å­—èŠ‚åºåˆ—
- **ç½‘ç»œæŠ“åŒ…**ï¼šä½¿ç”¨ wireshark æŸ¥çœ‹ç½‘ç»œæ•°æ®æ ¼å¼
- **äº¤å‰éªŒè¯**ï¼šåœ¨ä¸åŒå¹³å°é—´ä¼ è¾“æµ‹è¯•æ•°æ®
- **å•å…ƒæµ‹è¯•**ï¼šé’ˆå¯¹è½¬æ¢å‡½æ•°ç¼–å†™æµ‹è¯•ç”¨ä¾‹

### 9.5 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ“Š åº”ç”¨åœºæ™¯æ€»ç»“**ï¼š

| åœºæ™¯ | **å¤„ç†æ–¹æ³•** | **æ³¨æ„äº‹é¡¹** |
|------|-------------|-------------|
| `Socketç«¯å£` | `htons(port)` | `å¿…é¡»è½¬æ¢ï¼Œå¦åˆ™è¿æ¥å¤±è´¥` |
| `IPåœ°å€` | `inet_aton/inet_ntoa` | `å­—ç¬¦ä¸²ä¸äºŒè¿›åˆ¶è½¬æ¢` |
| `æ–‡ä»¶ä¼ è¾“` | `é•¿åº¦å­—æ®µè½¬æ¢` | `æ–‡ä»¶å¤§å°ã€åç§»é‡ç­‰` |
| `åè®®è®¾è®¡` | `æ‰‹åŠ¨åºåˆ—åŒ–` | `é¿å…ç»“æ„ä½“å¯¹é½é—®é¢˜` |
| `äºŒè¿›åˆ¶æ•°æ®` | `é€å­—æ®µå¤„ç†` | `æµ®ç‚¹æ•°éœ€ç‰¹æ®Šå¤„ç†` |

**ğŸ§  æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
- ç½‘ç»œä¼ è¾“ç”¨å¤§ç«¯ï¼Œä¸»æœºæœ¬åœ°çœ‹æ¶æ„
- htonså‘é€å‰è½¬æ¢ï¼Œntohsæ¥æ”¶åè¿˜åŸ  
- ç»“æ„ä½“ä¼ è¾“è¦å°å¿ƒï¼Œæ‰‹åŠ¨åºåˆ—åŒ–æœ€ç¨³
- å­—ç¬¦ä¸²é•¿åº¦è¦è½¬æ¢ï¼ŒäºŒè¿›åˆ¶è°ƒè¯•çœ‹åå…­è¿›åˆ¶

**ğŸ’¡ æœ€ä½³å®è·µ**ï¼š
- è®¾è®¡ç½‘ç»œåè®®æ—¶ï¼Œæ˜ç¡®æŒ‡å®šæ‰€æœ‰å­—æ®µçš„å­—èŠ‚åº
- ç¼–å†™å¯ç§»æ¤ä»£ç ï¼Œä¸ä¾èµ–ç‰¹å®šå¹³å°çš„å­—èŠ‚åº
- ä½¿ç”¨æ ‡å‡†åº“å‡½æ•°ï¼Œé¿å…è‡ªå·±å®ç°å­—èŠ‚åºè½¬æ¢
- å……åˆ†æµ‹è¯•ï¼Œç¡®ä¿åœ¨ä¸åŒæ¶æ„é—´æ•°æ®ä¼ è¾“æ­£ç¡®