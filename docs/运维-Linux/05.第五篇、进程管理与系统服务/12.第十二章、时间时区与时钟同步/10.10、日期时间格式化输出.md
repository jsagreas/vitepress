---
title: 10、日期时间格式化输出
---
## 📚 目录

1. [date命令基础与格式化选项](#1-date命令基础与格式化选项)
2. [strftime格式字符串详解](#2-strftime格式字符串详解)
3. [locale环境下的日期格式](#3-locale环境下的日期格式)
4. [自定义时间输出格式](#4-自定义时间输出格式)
5. [脚本中的时间戳处理](#5-脚本中的时间戳处理)
6. [日志时间戳标准化](#6-日志时间戳标准化)
7. [时间计算与运算](#7-时间计算与运算)
8. [跨时区时间转换](#8-跨时区时间转换)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🕐 date命令基础与格式化选项


### 1.1 date命令的本质作用


**date命令是什么？**
`date`命令就是Linux系统中用来显示和设置系统时间的工具。简单说，它就是系统的"时钟管家"，负责告诉你现在几点了，还能按你的要求把时间格式化成不同的样子。

```bash
# 最基本的用法 - 显示当前时间
$ date
Mon Jan 21 15:30:45 CST 2025

# 这行输出的意思：
# Mon - 星期一
# Jan 21 - 1月21日  
# 15:30:45 - 15点30分45秒
# CST - 中国标准时间
# 2025 - 2025年
```

### 1.2 核心格式化选项


**为什么需要格式化？**
系统默认的时间格式可能不符合我们的需求。比如写日志时想要简洁的格式，做文件备份时想要时间戳，这时就需要自定义时间格式。

| 选项 | **含义** | **示例输出** | **应用场景** |
|------|---------|-------------|-------------|
| `%Y` | 4位年份 | `2025` | 文件名、日志记录 |
| `%y` | 2位年份 | `25` | 简短标识 |
| `%m` | 月份(01-12) | `01` | 数字月份 |
| `%B` | 完整月份名 | `January` | 友好显示 |
| `%b` | 简写月份名 | `Jan` | 简洁显示 |
| `%d` | 日期(01-31) | `21` | 具体日期 |
| `%H` | 小时(00-23) | `15` | 24小时制 |
| `%I` | 小时(01-12) | `03` | 12小时制 |
| `%M` | 分钟(00-59) | `30` | 分钟数 |
| `%S` | 秒(00-59) | `45` | 秒数 |

**💡 实用示例**

```bash
# 年-月-日 格式 (常用于文件命名)
$ date +"%Y-%m-%d"
2025-01-21

# 年月日时分秒 (常用于时间戳)
$ date +"%Y%m%d_%H%M%S"
20250121_153045

# 友好的日期显示
$ date +"%B %d, %Y"
January 21, 2025

# 12小时制带上午/下午
$ date +"%I:%M %p"
03:30 PM
```

### 1.3 常用组合格式


**📋 实际工作中的常用格式**

```bash
# 🔸 文件备份时间戳
$ date +"%Y%m%d_%H%M%S"
20250121_153045
# 用法：cp file.txt file_backup_$(date +"%Y%m%d_%H%M%S").txt

# 🔸 日志记录格式
$ date +"%Y-%m-%d %H:%M:%S"
2025-01-21 15:30:45
# 用法：echo "$(date +"%Y-%m-%d %H:%M:%S") - 程序启动" >> app.log

# 🔸 ISO 8601 标准格式
$ date +"%Y-%m-%dT%H:%M:%S%z"
2025-01-21T15:30:45+0800
# 用法：国际化应用的时间戳

# 🔸 简洁的日期格式
$ date +"%m/%d/%Y"
01/21/2025
# 用法：美式日期格式
```

---

## 2. 📝 strftime格式字符串详解


### 2.1 什么是strftime


**strftime的含义**
`strftime`就是"string format time"的缩写，意思是"把时间格式化成字符串"。它定义了一套标准的格式化规则，不仅Linux的date命令在用，很多编程语言（Python、C、PHP等）也都遵循这套规则。

**为什么要学strftime？**
- 🎯 **统一标准**：掌握了strftime，在任何系统和语言中都能用
- 🎯 **精确控制**：可以精确控制时间显示的每一个细节
- 🎯 **广泛应用**：日志系统、数据库、配置文件都在用

### 2.2 完整格式字符表


```
时间基础格式化字符：
┌─────────┬─────────────┬─────────────┬─────────────┐
│ 字符    │ 含义        │ 示例        │ 说明        │
├─────────┼─────────────┼─────────────┼─────────────┤
│ %Y      │ 4位年份     │ 2025        │ 完整年份    │
│ %y      │ 2位年份     │ 25          │ 年份后2位   │
│ %C      │ 世纪        │ 20          │ 年份前2位   │
│ %m      │ 月份数字    │ 01          │ 01-12       │
│ %B      │ 月份全名    │ January     │ 完整月份名  │
│ %b/%h   │ 月份简称    │ Jan         │ 3字母简称   │
│ %d      │ 月中日期    │ 21          │ 01-31       │
│ %e      │ 日期(空格)  │ 21          │ 1-31,个位前空格│
└─────────┴─────────────┴─────────────┴─────────────┘

时间格式化字符：
┌─────────┬─────────────┬─────────────┬─────────────┐
│ %H      │ 24小时制    │ 15          │ 00-23       │
│ %I      │ 12小时制    │ 03          │ 01-12       │
│ %M      │ 分钟        │ 30          │ 00-59       │
│ %S      │ 秒          │ 45          │ 00-59       │
│ %p      │ AM/PM       │ PM          │ 大写        │
│ %P      │ am/pm       │ pm          │ 小写        │
│ %r      │ 12小时时间  │ 03:30:45 PM │ 包含AM/PM   │
│ %R      │ 24小时时间  │ 15:30       │ HH:MM格式   │
│ %T      │ 完整时间    │ 15:30:45    │ HH:MM:SS    │
└─────────┴─────────────┴─────────────┴─────────────┘
```

### 2.3 星期和特殊格式


```bash
# 🔸 星期相关格式
$ date +"%A"        # 完整星期名
Monday

$ date +"%a"        # 简写星期名  
Mon

$ date +"%w"        # 星期数字(0=周日)
1

$ date +"%u"        # 星期数字(1=周一)
1

# 🔸 特殊组合格式
$ date +"%c"        # 本地完整日期时间
Mon 21 Jan 2025 03:30:45 PM CST

$ date +"%x"        # 本地日期格式
01/21/2025

$ date +"%X"        # 本地时间格式
03:30:45 PM

$ date +"%D"        # MM/DD/YY格式
01/21/25

$ date +"%F"        # YYYY-MM-DD格式 (ISO日期)
2025-01-21
```

### 2.4 实际应用模板


**📋 常用时间格式模板**

```bash
# 🎯 数据库时间戳格式
$ date +"%Y-%m-%d %H:%M:%S"
2025-01-21 15:30:45

# 🎯 文件命名安全格式 (避免特殊字符)
$ date +"%Y%m%d_%H%M%S"
20250121_153045

# 🎯 人类友好格式
$ date +"%A, %B %d, %Y at %I:%M %p"
Monday, January 21, 2025 at 03:30 PM

# 🎯 紧凑格式 (节省空间)
$ date +"%y%m%d%H%M"
2501211530

# 🎯 国际标准格式 (RFC 3339)
$ date +"%Y-%m-%dT%H:%M:%S%z"
2025-01-21T15:30:45+0800
```

---

## 3. 🌍 locale环境下的日期格式


### 3.1 什么是locale


**locale的含义**
`locale`就是"本地化设置"，它告诉系统你在哪个地区，使用什么语言。这样系统就知道：
- 用中文还是英文显示月份名
- 用什么格式显示日期（年/月/日 还是 月/日/年）
- 星期一是一周的第一天还是星期日

**为什么locale影响日期格式？**
不同国家有不同的日期习惯：
- 🇺🇸 美国：月/日/年 (01/21/2025)
- 🇨🇳 中国：年-月-日 (2025-01-21)  
- 🇬🇧 英国：日/月/年 (21/01/2025)

### 3.2 查看和设置locale


```bash
# 🔍 查看当前locale设置
$ locale
LANG=en_US.UTF-8
LC_CTYPE="en_US.UTF-8"
LC_NUMERIC="en_US.UTF-8"
LC_TIME="en_US.UTF-8"    # 这个控制时间格式
LC_COLLATE="en_US.UTF-8"
LC_MONETARY="en_US.UTF-8"
LC_MESSAGES="en_US.UTF-8"
LC_PAPER="en_US.UTF-8"
LC_NAME="en_US.UTF-8"
LC_ADDRESS="en_US.UTF-8"
LC_TELEPHONE="en_US.UTF-8"
LC_MEASUREMENT="en_US.UTF-8"
LC_IDENTIFICATION="en_US.UTF-8"
LC_ALL=

# 🔍 查看可用的locale
$ locale -a | grep -E "(zh|en)"
en_US.utf8
zh_CN.utf8
zh_TW.utf8
```

### 3.3 不同locale下的日期显示


**🌏 英文环境 (en_US.UTF-8)**

```bash
$ export LC_TIME=en_US.UTF-8
$ date +"%A, %B %d, %Y"
Monday, January 21, 2025

$ date +"%c"
Mon 21 Jan 2025 03:30:45 PM CST

$ date +"%x"
01/21/2025
```

**🇨🇳 中文环境 (zh_CN.UTF-8)**

```bash
$ export LC_TIME=zh_CN.UTF-8
$ date +"%A, %B %d, %Y"
星期一, 一月 21, 2025

$ date +"%c"  
2025年01月21日 星期一 15时30分45秒

$ date +"%x"
2025年01月21日
```

### 3.4 临时切换locale


**💡 不改变系统设置，临时使用不同locale**

```bash
# 🔸 临时使用中文显示
$ LC_TIME=zh_CN.UTF-8 date +"%A %B %d日"
星期一 一月 21日

# 🔸 临时使用英文显示  
$ LC_TIME=en_US.UTF-8 date +"%A %B %d"
Monday January 21

# 🔸 临时使用德文显示
$ LC_TIME=de_DE.UTF-8 date +"%A, %d. %B %Y"
Montag, 21. Januar 2025

# 🔸 在脚本中使用
#!/bin/bash
# 确保使用英文格式，避免本地化差异
export LC_TIME=C
LOG_TIME=$(date +"%Y-%m-%d %H:%M:%S")
echo "$LOG_TIME - 程序启动"
```

---

## 4. 🎨 自定义时间输出格式


### 4.1 基础自定义格式


**什么是自定义格式？**
就是根据你的具体需求，把日期时间组合成你想要的样子。比如做文件备份时想要清晰的时间标识，写日志时想要统一的格式等。

**📋 常见自定义需求与实现**

```bash
# 🎯 文件备份命名格式
$ date +"%Y%m%d_%H%M%S"
20250121_153045
# 应用：backup_$(date +"%Y%m%d_%H%M%S").tar.gz

# 🎯 日志时间戳格式
$ date +"[%Y-%m-%d %H:%M:%S]"
[2025-01-21 15:30:45]
# 应用：echo "$(date +"[%Y-%m-%d %H:%M:%S]") ERROR: 连接失败" >> error.log

# 🎯 数据库查询格式
$ date +"%Y-%m-%d %H:%M:%S"
2025-01-21 15:30:45
# 应用：SELECT * FROM logs WHERE created_at >= '$(date +"%Y-%m-%d") 00:00:00'

# 🎯 友好显示格式
$ date +"今天是%Y年%m月%d日，现在时间%H:%M"
今天是2025年01月21日，现在时间15:30
```

### 4.2 高级格式组合


**🔧 复杂场景的格式设计**

```bash
# 🔸 邮件标题格式
$ date +"【%m月%d日】系统报告"
【01月21日】系统报告

# 🔸 报表文件名格式  
$ date +"销售报表_%Y年%m月_%A"
销售报表_2025年01月_Monday

# 🔸 API时间戳格式 (ISO 8601)
$ date +"%Y-%m-%dT%H:%M:%S.%3N%z"
2025-01-21T15:30:45.123+0800

# 🔸 人类可读的相对时间描述
current_hour=$(date +%H)
if [ $current_hour -lt 12 ]; then
    period="上午"
elif [ $current_hour -lt 18 ]; then
    period="下午"  
else
    period="晚上"
fi
echo "$(date +"今天%m月%d日")${period}$(date +"%I:%M")"
# 输出：今天01月21日下午03:30
```

### 4.3 特殊字符和转义


**🔤 在格式中使用特殊字符**

```bash
# 🔸 添加方括号
$ date +"[%Y-%m-%d] %H:%M:%S"
[2025-01-21] 15:30:45

# 🔸 添加分隔符和文字
$ date +"时间：%Y年%m月%d日 %H时%M分"
时间：2025年01月21日 15时30分

# 🔸 使用百分号字面量
$ date +"完成度：100%% - %Y/%m/%d"
完成度：100% - 2025/01/21

# 🔸 多行格式输出
$ date +"日期：%Y-%m-%d%n时间：%H:%M:%S%n星期：%A"
日期：2025-01-21
时间：15:30:45
星期：Monday
```

### 4.4 实用模板库


**📚 可直接使用的格式模板**

```bash
# 📋 模板1：文件系统安全格式（无特殊字符）
FILE_TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
echo $FILE_TIMESTAMP  # 20250121_153045

# 📋 模板2：数据库友好格式
DB_TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")
echo $DB_TIMESTAMP    # 2025-01-21 15:30:45

# 📋 模板3：日志标准格式
LOG_TIMESTAMP=$(date +"[%Y-%m-%d %H:%M:%S]")
echo $LOG_TIMESTAMP   # [2025-01-21 15:30:45]

# 📋 模板4：用户友好格式
USER_TIMESTAMP=$(date +"%Y年%m月%d日 %H:%M")
echo $USER_TIMESTAMP  # 2025年01月21日 15:30

# 📋 模板5：国际化格式
ISO_TIMESTAMP=$(date +"%Y-%m-%dT%H:%M:%S%z")
echo $ISO_TIMESTAMP   # 2025-01-21T15:30:45+0800
```

---

## 5. 📜 脚本中的时间戳处理


### 5.1 脚本中时间戳的作用


**为什么脚本需要时间戳？**
在Shell脚本中，时间戳就像是"数字化的标签"，主要用来：
- 🏷️ **标记事件发生时间** - 记录脚本运行时间
- 📁 **创建唯一文件名** - 避免文件重名覆盖
- 📊 **记录操作日志** - 追踪脚本执行过程
- ⏱️ **计算执行时间** - 性能监控和优化

### 5.2 基础时间戳变量


**🔧 在脚本中定义时间戳变量**

```bash
#!/bin/bash

# 🔸 基础时间戳变量定义
NOW=$(date +"%Y-%m-%d %H:%M:%S")
TODAY=$(date +"%Y-%m-%d")
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
EPOCH=$(date +%s)  # Unix时间戳(秒)

echo "当前时间: $NOW"
echo "今天日期: $TODAY"  
echo "文件时间戳: $TIMESTAMP"
echo "Unix时间戳: $EPOCH"

# 输出示例：
# 当前时间: 2025-01-21 15:30:45
# 今天日期: 2025-01-21
# 文件时间戳: 20250121_153045  
# Unix时间戳: 1737530245
```

### 5.3 实用脚本示例


**📝 备份脚本中的时间戳应用**

```bash
#!/bin/bash
# backup_script.sh - 数据备份脚本

# 🔸 定义时间戳变量
BACKUP_DATE=$(date +"%Y%m%d")
BACKUP_TIME=$(date +"%H%M%S")
BACKUP_TIMESTAMP="${BACKUP_DATE}_${BACKUP_TIME}"

# 🔸 创建备份目录
BACKUP_DIR="/backup/${BACKUP_DATE}"
mkdir -p "$BACKUP_DIR"

# 🔸 备份文件命名
SOURCE_DIR="/var/www/html"
BACKUP_FILE="website_backup_${BACKUP_TIMESTAMP}.tar.gz"
BACKUP_PATH="${BACKUP_DIR}/${BACKUP_FILE}"

# 🔸 执行备份
echo "$(date +'%Y-%m-%d %H:%M:%S') - 开始备份到: $BACKUP_PATH"
tar -czf "$BACKUP_PATH" "$SOURCE_DIR"

if [ $? -eq 0 ]; then
    echo "$(date +'%Y-%m-%d %H:%M:%S') - 备份成功完成"
else
    echo "$(date +'%Y-%m-%d %H:%M:%S') - 备份失败" >&2
fi
```

**📊 日志记录脚本**

```bash
#!/bin/bash
# log_helper.sh - 日志记录辅助脚本

# 🔸 日志函数定义
log_info() {
    echo "$(date +'[%Y-%m-%d %H:%M:%S] INFO:') $1" | tee -a app.log
}

log_error() {
    echo "$(date +'[%Y-%m-%d %H:%M:%S] ERROR:') $1" | tee -a app.log >&2
}

log_warn() {
    echo "$(date +'[%Y-%m-%d %H:%M:%S] WARN:') $1" | tee -a app.log
}

# 🔸 使用示例
log_info "程序启动"
log_warn "配置文件未找到，使用默认配置"
log_error "数据库连接失败"

# 输出示例：
# [2025-01-21 15:30:45] INFO: 程序启动
# [2025-01-21 15:30:45] WARN: 配置文件未找到，使用默认配置
# [2025-01-21 15:30:45] ERROR: 数据库连接失败
```

### 5.4 时间戳变量的最佳实践


**✅ 推荐做法**

```bash
#!/bin/bash

# 🎯 在脚本开头定义时间戳（保证一致性）
SCRIPT_START=$(date +"%Y-%m-%d %H:%M:%S")
SCRIPT_START_EPOCH=$(date +%s)

# 🎯 使用函数生成实时时间戳
get_timestamp() {
    date +"%Y-%m-%d %H:%M:%S"
}

# 🎯 文件名安全的时间戳格式
get_file_timestamp() {
    date +"%Y%m%d_%H%M%S"
}

# 🎯 使用示例
echo "脚本启动时间: $SCRIPT_START"
echo "当前操作时间: $(get_timestamp)"

# 创建日志文件
LOG_FILE="operation_$(get_file_timestamp).log"
echo "$(get_timestamp) - 开始处理" > "$LOG_FILE"
```

**❌ 避免的问题**

```bash
# ❌ 不要在循环中重复调用date（性能问题）
for i in {1..1000}; do
    echo "$(date) - 处理第 $i 项"  # 每次都调用date，很慢
done

# ✅ 正确做法：批量处理时使用缓存
BATCH_START=$(date +"%Y-%m-%d %H:%M:%S")
for i in {1..1000}; do
    echo "$BATCH_START - 处理第 $i 项"
done

# ❌ 不要使用空格和特殊字符做文件名
BAD_FILE="backup $(date).tar.gz"  # 文件名有空格，会出问题

# ✅ 正确做法：使用下划线和连字符
GOOD_FILE="backup_$(date +%Y%m%d_%H%M%S).tar.gz"
```

---

## 6. 📋 日志时间戳标准化


### 6.1 日志时间戳的重要性


**为什么日志需要标准化时间戳？**
日志时间戳就像是事件的"身份证"，标准化的时间戳能让你：
- 🔍 **快速定位问题** - 按时间查找特定事件
- 📈 **分析系统性能** - 统计响应时间和处理量
- 🔄 **追踪操作流程** - 了解事件发生的先后顺序
- 🛠️ **自动化日志处理** - 便于日志分析工具解析

### 6.2 标准日志格式


**📋 常用的日志时间戳格式**

```bash
# 🔸 标准格式1：ISO 8601格式（推荐）
$ date +"%Y-%m-%dT%H:%M:%S%z"
2025-01-21T15:30:45+0800
# 优点：国际标准，包含时区信息，便于跨系统交换

# 🔸 标准格式2：数据库友好格式
$ date +"%Y-%m-%d %H:%M:%S"
2025-01-21 15:30:45
# 优点：MySQL、PostgreSQL等数据库原生支持

# 🔸 标准格式3：系统日志格式
$ date +"%b %d %H:%M:%S"
Jan 21 15:30:45
# 优点：与系统syslog格式一致

# 🔸 标准格式4：应用日志格式
$ date +"[%Y-%m-%d %H:%M:%S]"
[2025-01-21 15:30:45]
# 优点：易于人工阅读，方便正则表达式匹配
```

### 6.3 日志级别与时间戳结合


**🎯 完整的日志格式设计**

```bash
#!/bin/bash
# logger.sh - 标准化日志记录脚本

# 🔸 定义日志级别
LOG_LEVEL_DEBUG=0
LOG_LEVEL_INFO=1
LOG_LEVEL_WARN=2
LOG_LEVEL_ERROR=3

# 当前日志级别（可配置）
CURRENT_LOG_LEVEL=$LOG_LEVEL_INFO

# 🔸 日志记录函数
write_log() {
    local level=$1
    local message=$2
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    
    case $level in
        $LOG_LEVEL_DEBUG) echo "[$timestamp] DEBUG: $message" ;;
        $LOG_LEVEL_INFO)  echo "[$timestamp] INFO:  $message" ;;
        $LOG_LEVEL_WARN)  echo "[$timestamp] WARN:  $message" ;;
        $LOG_LEVEL_ERROR) echo "[$timestamp] ERROR: $message" >&2 ;;
    esac
}

# 🔸 便捷函数
log_debug() { 
    [ $CURRENT_LOG_LEVEL -le $LOG_LEVEL_DEBUG ] && write_log $LOG_LEVEL_DEBUG "$1"
}
log_info() { 
    [ $CURRENT_LOG_LEVEL -le $LOG_LEVEL_INFO ] && write_log $LOG_LEVEL_INFO "$1"
}
log_warn() { 
    [ $CURRENT_LOG_LEVEL -le $LOG_LEVEL_WARN ] && write_log $LOG_LEVEL_WARN "$1"
}
log_error() { 
    [ $CURRENT_LOG_LEVEL -le $LOG_LEVEL_ERROR ] && write_log $LOG_LEVEL_ERROR "$1"
}

# 🔸 使用示例
log_info "程序启动"
log_debug "加载配置文件: /etc/app.conf"
log_warn "磁盘空间不足，剩余10%"
log_error "数据库连接失败"

# 输出示例：
# [2025-01-21 15:30:45] INFO:  程序启动
# [2025-01-21 15:30:45] WARN:  磁盘空间不足，剩余10%
# [2025-01-21 15:30:45] ERROR: 数据库连接失败
```

### 6.4 日志轮转与时间戳


**🔄 基于时间的日志文件管理**

```bash
#!/bin/bash
# log_rotation.sh - 日志轮转脚本

# 🔸 日志文件路径配置
LOG_DIR="/var/log/myapp"
APP_NAME="myapp"

# 🔸 获取日志文件名（按日期分割）
get_log_file() {
    local log_date=$(date +"%Y%m%d")
    echo "${LOG_DIR}/${APP_NAME}_${log_date}.log"
}

# 🔸 获取归档文件名（按小时分割）
get_archive_file() {
    local archive_time=$(date +"%Y%m%d_%H")
    echo "${LOG_DIR}/archive/${APP_NAME}_${archive_time}.log.gz"
}

# 🔸 日志记录函数（自动轮转）
app_log() {
    local message="$1"
    local log_file=$(get_log_file)
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    
    # 确保日志目录存在
    mkdir -p "$(dirname "$log_file")"
    
    # 写入日志
    echo "[$timestamp] $message" >> "$log_file"
}

# 🔸 日志清理函数（删除30天前的日志）
cleanup_old_logs() {
    find "$LOG_DIR" -name "${APP_NAME}_*.log" -mtime +30 -delete
    echo "$(date +"%Y-%m-%d %H:%M:%S") - 清理完成：删除30天前的日志文件"
}

# 🔸 使用示例
app_log "用户登录：user123"
app_log "订单创建：order_456"
app_log "支付完成：payment_789"

# 定期清理（通常放在crontab中）
# 0 2 * * * /path/to/log_rotation.sh cleanup_old_logs
```

### 6.5 日志分析友好格式


**🔍 便于自动化分析的日志格式**

```bash
#!/bin/bash
# structured_log.sh - 结构化日志记录

# 🔸 结构化日志函数
structured_log() {
    local level="$1"
    local component="$2"
    local action="$3"
    local result="$4"
    local details="$5"
    
    local timestamp=$(date +"%Y-%m-%dT%H:%M:%S%z")
    local hostname=$(hostname)
    local pid=$$
    
    # JSON格式日志（便于日志收集系统解析）
    cat << EOF
{"timestamp":"$timestamp","hostname":"$hostname","pid":$pid,"level":"$level","component":"$component","action":"$action","result":"$result","details":"$details"}
EOF
}

# 🔸 简化的结构化日志
simple_structured_log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    
    # 管道分隔格式（便于awk/cut处理）
    echo "$timestamp|$level|$$|$message"
}

# 🔸 使用示例
structured_log "INFO" "auth" "user_login" "success" "user_id=123,ip=192.168.1.100"
structured_log "ERROR" "database" "connection" "failed" "timeout=30s,host=db.example.com"

simple_structured_log "INFO" "程序启动完成"
simple_structured_log "WARN" "内存使用率超过80%"

# JSON格式输出：
# {"timestamp":"2025-01-21T15:30:45+0800","hostname":"server1","pid":12345,"level":"INFO","component":"auth","action":"user_login","result":"success","details":"user_id=123,ip=192.168.1.100"}

# 管道分隔格式输出：
# 2025-01-21 15:30:45|INFO|12345|程序启动完成
# 2025-01-21 15:30:45|WARN|12345|内存使用率超过80%
```

---

## 7. ⏰ 时间计算与运算


### 7.1 什么是时间计算


**时间计算的含义**
时间计算就是对日期和时间进行数学运算，比如：
- 📅 **计算日期差** - 两个日期相隔多少天
- ⏱️ **计算程序运行时间** - 脚本执行了多长时间
- 📆 **推算未来/过去日期** - 30天后是几号
- 🕐 **时间单位转换** - 秒转换为时分秒格式

### 7.2 Unix时间戳计算


**什么是Unix时间戳？**
Unix时间戳就是从1970年1月1日00:00:00 UTC开始到现在的总秒数。它就像一个"全球统一的计时器"，所有Unix系统都用这个标准。

```bash
# 🔸 获取当前Unix时间戳
$ date +%s
1737530245

# 🔸 将Unix时间戳转换为可读时间
$ date -d @1737530245
Mon Jan 21 15:30:45 CST 2025

# 🔸 指定日期转换为时间戳
$ date -d "2025-01-21 15:30:45" +%s
1737530245

# 🔸 计算两个时间戳的差值（秒）
start_time=$(date -d "2025-01-21 10:00:00" +%s)
end_time=$(date -d "2025-01-21 15:30:45" +%s)
duration=$((end_time - start_time))
echo "持续时间：$duration 秒"
# 输出：持续时间：19845 秒
```

### 7.3 日期推算


**📅 计算相对日期**

```bash
# 🔸 未来日期计算
$ date -d "+7 days" +"%Y-%m-%d"
2025-01-28
# 7天后的日期

$ date -d "+3 months" +"%Y-%m-%d"
2025-04-21  
# 3个月后的日期

$ date -d "+1 year" +"%Y-%m-%d"
2026-01-21
# 1年后的日期

# 🔸 过去日期计算
$ date -d "-30 days" +"%Y-%m-%d"
2024-12-22
# 30天前的日期

$ date -d "-1 week" +"%Y-%m-%d"
2025-01-14
# 1周前的日期

# 🔸 复杂日期计算
$ date -d "2025-01-01 +3 months +2 weeks +5 days" +"%Y-%m-%d"
2025-04-20
# 从2025年1月1日开始，加3个月、2周、5天
```

### 7.4 实用时间计算脚本


**⏱️ 程序执行时间统计**

```bash
#!/bin/bash
# timer_script.sh - 执行时间统计脚本

# 🔸 开始时间记录
start_time=$(date +%s)
start_readable=$(date +"%Y-%m-%d %H:%M:%S")

echo "程序开始时间: $start_readable"

# 🔸 模拟程序执行（这里用sleep模拟）
echo "正在执行任务..."
sleep 3  # 模拟3秒的工作时间

# 🔸 结束时间记录
end_time=$(date +%s)
end_readable=$(date +"%Y-%m-%d %H:%M:%S")

echo "程序结束时间: $end_readable"

# 🔸 计算执行时间
duration=$((end_time - start_time))
echo "总执行时间: $duration 秒"

# 🔸 格式化显示执行时间
hours=$((duration / 3600))
minutes=$(((duration % 3600) / 60))
seconds=$((duration % 60))

if [ $hours -gt 0 ]; then
    echo "详细时间: ${hours}小时${minutes}分${seconds}秒"
elif [ $minutes -gt 0 ]; then
    echo "详细时间: ${minutes}分${seconds}秒"
else
    echo "详细时间: ${seconds}秒"
fi
```

**📊 日期差值计算**

```bash
#!/bin/bash
# date_diff.sh - 计算两个日期的差值

calculate_date_diff() {
    local date1="$1"  # 格式：YYYY-MM-DD
    local date2="$2"  # 格式：YYYY-MM-DD
    
    # 转换为时间戳
    timestamp1=$(date -d "$date1" +%s)
    timestamp2=$(date -d "$date2" +%s)
    
    # 计算差值（秒）
    diff_seconds=$((timestamp2 - timestamp1))
    
    # 转换为天数
    diff_days=$((diff_seconds / 86400))  # 86400 = 24*60*60
    
    echo "从 $date1 到 $date2 相隔 $diff_days 天"
    
    # 详细计算
    if [ $diff_days -lt 0 ]; then
        echo "注意：第二个日期早于第一个日期"
        diff_days=$((-diff_days))
    fi
    
    years=$((diff_days / 365))
    remaining_days=$((diff_days % 365))
    months=$((remaining_days / 30))
    days=$((remaining_days % 30))
    
    if [ $years -gt 0 ]; then
        echo "大约: ${years}年${months}个月${days}天"
    elif [ $months -gt 0 ]; then
        echo "大约: ${months}个月${days}天"
    else
        echo "大约: ${days}天"
    fi
}

# 🔸 使用示例
calculate_date_diff "2024-01-01" "2025-01-21"
# 输出：
# 从 2024-01-01 到 2025-01-21 相隔 386 天
# 大约: 1年0个月21天

calculate_date_diff "2025-01-21" "2025-02-14"
# 输出：
# 从 2025-01-21 到 2025-02-14 相隔 24 天
# 大约: 24天
```

### 7.5 时间格式转换


**🔄 各种时间格式之间的转换**

```bash
#!/bin/bash
# time_converter.sh - 时间格式转换工具

# 🔸 秒数转换为时分秒格式
seconds_to_hms() {
    local total_seconds=$1
    
    local hours=$((total_seconds / 3600))
    local minutes=$(((total_seconds % 3600) / 60))
    local seconds=$((total_seconds % 60))
    
    printf "%02d:%02d:%02d\n" $hours $minutes $seconds
}

# 🔸 时分秒格式转换为秒数
hms_to_seconds() {
    local time_str="$1"  # 格式：HH:MM:SS
    
    IFS=':' read -r hours minutes seconds <<< "$time_str"
    
    total_seconds=$((hours * 3600 + minutes * 60 + seconds))
    echo $total_seconds
}

# 🔸 日期格式标准化
normalize_date() {
    local input_date="$1"
    
    # 尝试解析各种格式并转换为标准格式
    if date -d "$input_date" >/dev/null 2>&1; then
        date -d "$input_date" +"%Y-%m-%d %H:%M:%S"
    else
        echo "错误：无法解析日期格式 '$input_date'" >&2
        return 1
    fi
}

# 🔸 使用示例
echo "秒数转换："
seconds_to_hms 3661    # 输出：01:01:01
seconds_to_hms 7384    # 输出：02:03:04

echo "时分秒转换："
hms_to_seconds "01:01:01"  # 输出：3661
hms_to_seconds "02:03:04"  # 输出：7384

echo "日期格式标准化："
normalize_date "2025/01/21"           # 输出：2025-01-21 00:00:00
normalize_date "Jan 21, 2025"        # 输出：2025-01-21 00:00:00
normalize_date "2025-1-21 3:30 PM"   # 输出：2025-01-21 15:30:00
```

---

## 8. 🌐 跨时区时间转换


### 8.1 时区的基本概念


**什么是时区？**
时区就是地球上使用相同标准时间的地区。由于地球是圆的，太阳不能同时照亮所有地方，所以不同地区有不同的"当地时间"。

**为什么需要时区转换？**
- 🌍 **全球化应用** - 服务器在美国，用户在中国
- 📊 **数据分析** - 统一不同地区的时间数据
- 🔗 **系统集成** - 多个系统间的时间同步
- 📅 **会议安排** - 跨国会议的时间协调

### 8.2 查看和设置时区


```bash
# 🔍 查看当前时区
$ date
Mon Jan 21 15:30:45 CST 2025

$ timedatectl
               Local time: Mon 2025-01-21 15:30:45 CST
           Universal time: Mon 2025-01-21 07:30:45 UTC
                 RTC time: Mon 2025-01-21 07:30:45
                Time zone: Asia/Shanghai (CST, +0800)

# 🔍 查看可用时区
$ timedatectl list-timezones | grep -E "(Shanghai|Tokyo|New_York|London)"
Asia/Shanghai
Asia/Tokyo  
America/New_York
Europe/London

# 🔍 查看时区文件
$ ls /usr/share/zoneinfo/Asia/ | head -5
Shanghai
Tokyo
Seoul
Bangkok
Manila
```

### 8.3 时区转换方法


**🌏 使用TZ环境变量进行时区转换**

```bash
# 🔸 当前北京时间
$ date
Mon Jan 21 15:30:45 CST 2025

# 🔸 转换为纽约时间
$ TZ='America/New_York' date
Mon Jan 21 02:30:45 EST 2025

# 🔸 转换为伦敦时间
$ TZ='Europe/London' date  
Mon Jan 21 07:30:45 GMT 2025

# 🔸 转换为东京时间
$ TZ='Asia/Tokyo' date
Mon Jan 21 16:30:45 JST 2025

# 🔸 转换为UTC时间
$ TZ='UTC' date
Mon Jan 21 07:30:45 UTC 2025
```

**⏰ 指定时间的时区转换**

```bash
# 🔸 将北京时间转换为其他时区
beijing_time="2025-01-21 15:30:45"

# 转换为纽约时间
TZ='America/New_York' date -d "TZ=\"Asia/Shanghai\" $beijing_time"
Mon Jan 21 02:30:45 EST 2025

# 转换为伦敦时间  
TZ='Europe/London' date -d "TZ=\"Asia/Shanghai\" $beijing_time"
Mon Jan 21 07:30:45 GMT 2025

# 🔸 更简洁的方法：先转为UTC再转目标时区
utc_time=$(TZ='UTC' date -d "TZ=\"Asia/Shanghai\" $beijing_time" +"%Y-%m-%d %H:%M:%S")
echo "UTC时间: $utc_time"

TZ='America/New_York' date -d "$utc_time UTC"
TZ='Europe/London' date -d "$utc_time UTC"
```

### 8.4 跨时区脚本实例


**🔧 时区转换工具脚本**

```bash
#!/bin/bash
# timezone_converter.sh - 时区转换工具

# 🔸 常用时区定义
declare -A TIMEZONES=(
    ["beijing"]="Asia/Shanghai"
    ["tokyo"]="Asia/Tokyo"
    ["london"]="Europe/London"
    ["newyork"]="America/New_York"
    ["losangeles"]="America/Los_Angeles"
    ["sydney"]="Australia/Sydney"
    ["dubai"]="Asia/Dubai"
    ["utc"]="UTC"
)

# 🔸 显示所有时区的当前时间
show_world_time() {
    echo "🌍 世界时间 - $(date +"%Y-%m-%d")"
    echo "================================"
    
    for city in "${!TIMEZONES[@]}"; do
        timezone="${TIMEZONES[$city]}"
        time_str=$(TZ="$timezone" date +"%H:%M:%S %Z")
        printf "%-12s: %s\n" "$city" "$time_str"
    done
}

# 🔸 转换指定时间到目标时区
convert_time() {
    local source_time="$1"      # 源时间，格式：YYYY-MM-DD HH:MM:SS
    local source_tz="$2"        # 源时区
    local target_tz="$3"        # 目标时区
    
    # 输入验证
    if [[ -z "$source_time" || -z "$source_tz" || -z "$target_tz" ]]; then
        echo "用法: convert_time '时间' '源时区' '目标时区'"
        echo "示例: convert_time '2025-01-21 15:30:45' 'Asia/Shanghai' 'America/New_York'"
        return 1
    fi
    
    # 执行转换
    local result=$(TZ="$target_tz" date -d "TZ=\"$source_tz\" $source_time" 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        echo "源时间: $source_time ($source_tz)"
        echo "目标时间: $result"
    else
        echo "错误：无法转换时间。请检查时间格式和时区名称。"
        return 1
    fi
}

# 🔸 会议时间协调器
meeting_planner() {
    local meeting_time="$1"     # 会议时间
    local meeting_tz="$2"       # 会议时区
    
    echo "📅 会议时间安排"
    echo "会议时间: $meeting_time ($meeting_tz)"
    echo "各地对应时间:"
    echo "---------------"
    
    for city in "${!TIMEZONES[@]}"; do
        if [ "${TIMEZONES[$city]}" != "$meeting_tz" ]; then
            local local_time=$(TZ="${TIMEZONES[$city]}" date -d "TZ=\"$meeting_tz\" $meeting_time" +"%H:%M %Z" 2>/dev/null)
            if [ $? -eq 0 ]; then
                printf "%-12s: %s\n" "$city" "$local_time"
            fi
        fi
    done
}

# 🔸 使用示例
case "${1:-help}" in
    "world")
        show_world_time
        ;;
    "convert")
        convert_time "$2" "$3" "$4"
        ;;
    "meeting")
        meeting_planner "$2" "$3"
        ;;
    "help"|*)
        echo "时区转换工具使用说明："
        echo "  $0 world                           # 显示世界时间"
        echo "  $0 convert '时间' '源时区' '目标时区'  # 时间转换"
        echo "  $0 meeting '会议时间' '会议时区'      # 会议时间规划"
        echo ""
        echo "时区示例："
        echo "  Asia/Shanghai, America/New_York, Europe/London"
        echo "  Asia/Tokyo, America/Los_Angeles, UTC"
        ;;
esac
```

### 8.5 时区转换的最佳实践


**✅ 推荐做法**

```bash
#!/bin/bash
# timezone_best_practices.sh

# 🎯 1. 在脚本中明确指定时区
get_utc_timestamp() {
    TZ='UTC' date +"%Y-%m-%dT%H:%M:%SZ"
}

get_local_timestamp() {
    date +"%Y-%m-%d %H:%M:%S %Z"
}

# 🎯 2. 数据存储使用UTC时间
log_event() {
    local event="$1"
    local utc_time=$(get_utc_timestamp)
    local local_time=$(get_local_timestamp)
    
    # 数据库存储使用UTC
    echo "INSERT INTO events (timestamp_utc, event) VALUES ('$utc_time', '$event');"
    
    # 日志显示使用本地时间
    echo "[$local_time] $event" >> app.log
}

# 🎯 3. API接口使用ISO 8601格式
api_timestamp() {
    date +"%Y-%m-%dT%H:%M:%S%z"
}

# 🎯 4. 时区转换函数
convert_utc_to_local() {
    local utc_time="$1"
    local target_tz="${2:-Asia/Shanghai}"
    
    TZ="$target_tz" date -d "$utc_time UTC" +"%Y-%m-%d %H:%M:%S %Z"
}

# 🔸 使用示例
echo "UTC时间戳: $(get_utc_timestamp)"
echo "本地时间戳: $(get_local_timestamp)"
echo "API时间戳: $(api_timestamp)"

log_event "用户登录"

utc_now=$(TZ='UTC' date +"%Y-%m-%d %H:%M:%S")
echo "UTC转北京时间: $(convert_utc_to_local "$utc_now" "Asia/Shanghai")"
echo "UTC转纽约时间: $(convert_utc_to_local "$utc_now" "America/New_York")"
```

**❌ 避免的问题**

```bash
# ❌ 不要混用不同时区的时间
start_time=$(date +%s)                    # 本地时区时间戳
end_time=$(TZ='UTC' date +%s)            # UTC时区时间戳
duration=$((end_time - start_time))      # 结果可能不准确

# ✅ 正确做法：统一使用UTC
start_time=$(TZ='UTC' date +%s)
end_time=$(TZ='UTC' date +%s)
duration=$((end_time - start_time))

# ❌ 不要假设用户的时区
echo "会议时间：2025-01-21 15:30"         # 没有时区信息，容易混淆

# ✅ 正确做法：明确指定时区
echo "会议时间：2025-01-21 15:30 CST (北京时间)"
echo "会议时间：2025-01-21T15:30:00+0800"  # ISO 8601格式
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 date命令：Linux系统的时间显示和格式化工具
🔸 strftime：标准的时间格式化字符串规范
🔸 locale：影响日期显示语言和格式的本地化设置
🔸 时间戳：程序中用于标记时间的数字化表示
🔸 Unix时间戳：从1970年1月1日开始的总秒数
🔸 时区转换：不同地理位置时间的相互转换
```

### 9.2 关键理解要点


**🔹 date命令的核心价值**
```
格式化灵活性：
- 可以生成任意格式的时间字符串
- 适应不同场景的显示需求
- 支持本地化和国际化

实用性强：
- 文件命名：避免重名冲突
- 日志记录：时间追踪和调试
- 脚本编程：时间逻辑处理
- 数据分析：时间维度统计
```

**🔹 时间格式选择原则**
```
文件命名场景：
- 使用 %Y%m%d_%H%M%S 格式
- 避免空格和特殊字符
- 确保文件名唯一性

数据库存储：
- 使用 %Y-%m-%d %H:%M:%S 格式
- 统一使用UTC时间存储
- 显示时转换为本地时间

日志记录：
- 使用 [%Y-%m-%d %H:%M:%S] 格式
- 包含日志级别信息
- 便于自动化分析

API接口：
- 使用ISO 8601标准格式
- 包含时区信息
- 支持国际化应用
```

**🔹 时区处理最佳实践**
```
存储原则：
- 数据库统一存储UTC时间
- 避免时区混乱和转换错误
- 保证全球一致性

显示原则：
- 根据用户位置显示本地时间
- 明确标注时区信息
- 提供时区选择功能

转换原则：
- 先转UTC再转目标时区
- 使用标准时区名称
- 处理夏令时变更
```

### 9.3 实际应用价值


**🎯 系统管理场景**
- **日志分析**：通过时间戳快速定位问题发生时间
- **任务调度**：cron任务的时间规划和执行记录
- **备份管理**：基于时间的文件备份和版本控制
- **性能监控**：系统性能数据的时间维度分析

**🎯 开发编程场景**
- **文件操作**：生成带时间戳的唯一文件名
- **错误追踪**：记录程序执行过程的时间信息
- **缓存管理**：基于时间的缓存过期策略
- **用户体验**：友好的时间显示和国际化

**🎯 数据处理场景**
- **报表生成**：按时间维度统计和分析数据
- **数据同步**：多系统间的时间戳对比和同步
- **事件关联**：基于时间序列的事件关联分析
- **趋势分析**：时间序列数据的趋势预测

### 9.4 工程实践要点


```
代码规范：
✅ 统一时间格式：团队内使用统一的时间格式标准
✅ 函数封装：将常用时间操作封装为可复用函数
✅ 错误处理：时间转换失败时的降级处理
✅ 性能优化：避免在循环中频繁调用date命令

调试技巧：
🔧 时间对比：使用before/after时间戳定位性能瓶颈
🔧 日志分级：不同级别日志使用不同时间格式
🔧 测试验证：跨时区功能的测试用例设计
🔧 监控告警：基于时间阈值的系统监控

运维管理：
🚀 自动化脚本：定时任务的时间参数设计
🚀 容灾备份：跨地域备份的时间同步策略
🚀 日志轮转：基于时间的日志文件管理
🚀 系统维护：维护窗口的时间安排和通知
```

### 9.5 进阶学习方向


```
相关技术栈：
- chrony/NTP：网络时间同步协议和服务
- systemd-timesyncd：现代Linux的时间同步服务
- timedatectl：系统时间和时区管理工具
- hwclock：硬件时钟管理命令

高级应用：
- 分布式系统的时间同步策略
- 高精度时间戳的应用场景
- 时间序列数据库的设计原理
- 实时系统的时间调度算法

工具和框架：
- 各编程语言的时间处理库
- 日志收集系统的时间解析
- 监控系统的时间聚合算法
- 数据可视化的时间轴设计
```

**核心记忆口诀**：
- date命令格式化，strftime是标准
- 时间戳唯一标识，UTC存储最安全
- 跨时区要谨慎，本地显示要友好
- 日志规范要统一，调试分析都方便