---
title: 2、进程查看与信息获取
---
## 📚 目录

1. [进程查看基础概念](#1-进程查看基础概念)
2. [ps命令详解](#2-ps命令详解)  
3. [进程信息字段解读](#3-进程信息字段解读)
4. [进程搜索与查找](#4-进程搜索与查找)
5. [进程树显示](#5-进程树显示)
6. [proc文件系统](#6-proc文件系统)
7. [实战应用场景](#7-实战应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 进程查看基础概念


### 1.1 什么是进程查看

**通俗理解**：就像查看手机里运行的APP一样，Linux系统也需要查看当前有哪些程序在运行

```
想象场景：
你的电脑很卡，想看看是哪个程序占用了太多资源
就像手机设置里的"应用管理"，Linux用命令来查看进程

Windows任务管理器 ←→ Linux进程查看命令
```

### 1.2 为什么需要查看进程

**实际需求场景**：
- 🔥 **系统卡顿**：找出占用CPU/内存最多的程序
- 🔍 **程序异常**：检查某个服务是否正在运行
- 🛡️ **安全检查**：发现可疑的进程
- 📊 **性能监控**：了解系统资源使用情况

### 1.3 进程信息的来源

**Linux系统的"幕后机制"**：
```
内核维护进程表 → /proc文件系统 → 进程查看命令

就像：
酒店总台记录住客信息 → 登记册 → 前台查询系统
```

---

## 2. 📋 ps命令详解


### 2.1 ps命令基础

**ps = Process Status（进程状态）**

**最基本用法**：
```bash
# 只显示当前终端的进程
ps

# 结果示例：
  PID TTY          TIME CMD
 1234 pts/0    00:00:00 bash
 5678 pts/0    00:00:00 ps
```

**通俗解释**：
- `PID`：进程编号（就像身份证号）
- `TTY`：在哪个终端运行（就像在哪个窗口）
- `TIME`：运行了多长时间
- `CMD`：程序名称

### 2.2 三种最常用的ps格式


#### 🔸 ps aux（显示所有用户的所有进程）


```bash
ps aux

# 输出示例：
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 225316  9024 ?        Ss   Jan10   0:29 /sbin/init
nginx     1234  0.1  0.5 125632 41024 ?        S    10:30   0:05 nginx: worker
mysql     5678  2.1  5.2 987654 421024 ?       Sl   10:25   1:23 mysqld
```

**通俗解释**：
- `USER`：谁启动的进程（就像程序的主人）
- `PID`：进程ID（身份证号）
- `%CPU`：占用CPU的百分比（耗电量）
- `%MEM`：占用内存的百分比（占用的空间）
- `COMMAND`：完整的命令行（程序的全名）

#### 🔸 ps -ef（标准Unix格式）


```bash
ps -ef

# 输出示例：
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Jan10 ?        00:00:29 /sbin/init
root       123     1  0 Jan10 ?        00:00:00 [kthreadd]
nginx     1234   890  0 10:30 ?        00:00:05 nginx: worker
```

**通俗解释**：
- `UID`：用户ID（主人的编号）
- `PPID`：父进程ID（谁启动了这个程序）
- `C`：CPU使用率
- `STIME`：启动时间

#### 🔸 ps -elf（详细信息格式）


```bash
ps -elf

# 包含更多字段，如优先级、nice值等
```

### 2.3 常用ps命令组合


| 命令 | **作用** | **使用场景** |
|------|---------|-------------|
| `ps aux` | `查看所有进程的资源使用` | `系统性能分析` |
| `ps -ef` | `查看进程的父子关系` | `进程关系排查` |
| `ps aux --sort=-%cpu` | `按CPU使用率排序` | `找出最占CPU的进程` |
| `ps aux --sort=-%mem` | `按内存使用率排序` | `找出最占内存的进程` |

**实用技巧**：
```bash
# 只显示前10个最占CPU的进程
ps aux --sort=-%cpu | head -10

# 只显示某个用户的进程
ps aux | grep nginx

# 查看进程树（谁启动了谁）
ps -ef --forest
```

---

## 3. 📊 进程信息字段解读


### 3.1 STAT字段详解（进程状态）


**进程状态就像人的状态**：

| 状态 | **含义** | **通俗理解** |
|------|---------|-------------|
| `R` | `Running 运行中` | `正在工作` |
| `S` | `Sleep 可中断睡眠` | `在休息，可以被叫醒` |
| `D` | `不可中断睡眠` | `在深度睡眠，叫不醒` |
| `Z` | `Zombie 僵尸进程` | `已死但尸体还在` |
| `T` | `Stopped 停止` | `被暂停了` |

**附加标志**：
```
S    - 基本睡眠状态
Ss   - 会话领导者（s = session leader）
S+   - 前台进程组（+ = foreground）
Sl   - 多线程进程（l = multi-threaded）
S<   - 高优先级进程（< = high priority）
SN   - 低优先级进程（N = low priority）
```

**实际例子**：
```bash
ps aux | grep nginx
# nginx: master process    Ss    (主进程，会话领导者)
# nginx: worker process    S     (工作进程，普通睡眠)
```

### 3.2 资源使用字段


**内存相关**：
- `%MEM`：占用物理内存的百分比（重要指标）
- `VSZ`：虚拟内存大小（程序申请的总内存）
- `RSS`：实际占用的物理内存（真正使用的内存）

**通俗理解**：
```
VSZ = 你借了多少钱（虚拟内存）
RSS = 你实际花了多少钱（物理内存）
%MEM = 你花的钱占总收入的百分比
```

**CPU相关**：
- `%CPU`：CPU使用百分比（瞬时值）
- `TIME`：累计使用CPU时间

### 3.3 时间字段解读


```bash
ps -eo pid,lstart,etime,time,cmd

# lstart: 启动的具体时间
# etime:  运行了多长时间（elapsed time）
# time:   实际使用CPU的时间
```

**区别理解**：
```
lstart = 程序什么时候开始的（出生时间）
etime  = 程序活了多久（年龄）
time   = 程序实际工作了多久（工作时长）
```

---

## 4. 🔍 进程搜索与查找


### 4.1 pgrep命令（进程搜索神器）


**基本语法**：
```bash
# 按进程名搜索
pgrep nginx
# 输出：1234 5678

# 按用户搜索
pgrep -u root
# 输出：1 2 3 ... （所有root用户的进程PID）

# 按完整命令搜索
pgrep -f "python app.py"
# 搜索包含"python app.py"的进程
```

**实用选项**：

| 选项 | **作用** | **示例** |
|------|---------|---------|
| `-l` | `显示进程名` | `pgrep -l nginx` |
| `-u` | `按用户搜索` | `pgrep -u www-data` |
| `-f` | `搜索完整命令行` | `pgrep -f "java.*tomcat"` |
| `-x` | `精确匹配进程名` | `pgrep -x sshd` |
| `-n` | `最新的进程` | `pgrep -n python` |
| `-o` | `最老的进程` | `pgrep -o python` |

**实战场景**：
```bash
# 检查nginx是否运行
if pgrep nginx > /dev/null; then
    echo "nginx正在运行"
else
    echo "nginx未运行"
fi

# 找出所有Python进程
pgrep -fl python
```

### 4.2 pidof命令（简单查找进程ID）


```bash
# 查找nginx的PID
pidof nginx
# 输出：1234 5678

# 只显示第一个PID
pidof -s nginx
# 输出：1234
```

**pgrep vs pidof对比**：

| 命令 | **特点** | **适用场景** |
|------|---------|-------------|
| `pgrep` | `功能强大，支持正则` | `复杂搜索需求` |
| `pidof` | `简单直接` | `快速查找简单进程名` |

---

## 5. 🌳 进程树显示


### 5.1 pstree命令详解


**基本用法**：
```bash
# 显示所有进程树
pstree

# 输出示例：
systemd─┬─NetworkManager───2*[{NetworkManager}]
        ├─accounts-daemon───2*[{accounts-daemon}]
        ├─apache2───5*[apache2]
        ├─cron
        ├─dbus-daemon
        ├─nginx───nginx
        └─sshd───sshd───bash───pstree
```

**通俗理解**：
就像家族族谱，显示谁是谁的父亲，谁是谁的孩子

### 5.2 pstree常用选项


```bash
# 显示PID
pstree -p
# systemd(1)─┬─NetworkManager(823)─┬─{NetworkManager}(834)

# 显示用户名
pstree -u
# systemd─┬─NetworkManager(root)
#         ├─apache2(www-data)───5*[apache2(www-data)]

# 只显示某个用户的进程树
pstree root

# 只显示某个进程的子树
pstree -p 1234
```

### 5.3 进程关系理解


**父子进程关系**：
```
父进程启动子进程的过程：

1. 父进程 fork() → 创建子进程
2. 子进程继承父进程的环境
3. 子进程执行新程序

实际例子：
shell(bash) → 你输入命令 → 创建新进程执行命令
```

**进程树的实际意义**：
- 🔍 **故障排查**：某个服务出问题，查看它的子进程
- 🛡️ **安全检查**：检查可疑的进程关系
- 📊 **资源管理**：了解进程的层次结构

---

## 6. 💾 proc文件系统


### 6.1 /proc目录概述


**什么是/proc**：
```
/proc = 进程信息的"数据库"
每个PID都有对应的目录：/proc/PID/

就像：
每个人都有个人档案袋
里面记录了详细信息
```

### 6.2 /proc/PID目录结构


**重要文件说明**：

| 文件 | **作用** | **查看方法** |
|------|---------|-------------|
| `cmdline` | `完整命令行参数` | `cat /proc/1234/cmdline` |
| `environ` | `环境变量` | `cat /proc/1234/environ` |
| `status` | `进程详细状态` | `cat /proc/1234/status` |
| `stat` | `进程统计信息` | `cat /proc/1234/stat` |
| `maps` | `内存映射` | `cat /proc/1234/maps` |
| `fd/` | `文件描述符` | `ls -l /proc/1234/fd/` |

**实用示例**：
```bash
# 查看nginx主进程的完整启动命令
cat /proc/$(pidof nginx | cut -d' ' -f1)/cmdline

# 查看进程打开的文件
ls -l /proc/1234/fd/

# 查看进程的内存使用详情
cat /proc/1234/status | grep -E "VmSize|VmRSS"
```

### 6.3 /proc/stat系统统计


```bash
# 查看系统整体进程统计
cat /proc/stat

# 输出示例：
cpu  12345 0 6789 987654 1234 0 567 0 0 0
cpu0 3456 0 1789 246543 345 0 123 0 0 0
processes 123456
procs_running 3
procs_blocked 0
```

**字段含义**：
- `processes`：自启动以来创建的进程总数
- `procs_running`：当前运行的进程数
- `procs_blocked`：当前阻塞的进程数

---

## 7. 🛠️ 实战应用场景


### 7.1 系统性能排查


**场景：系统很卡，要找出罪魁祸首**

```bash
# 1. 找出最占CPU的进程
ps aux --sort=-%cpu | head -10

# 2. 找出最占内存的进程
ps aux --sort=-%mem | head -10

# 3. 实时监控（每2秒刷新一次）
watch -n 2 'ps aux --sort=-%cpu | head -10'
```

### 7.2 服务状态检查


**场景：检查Web服务是否正常**

```bash
# 检查nginx是否运行
if pgrep nginx > /dev/null; then
    echo "✅ nginx正在运行"
    echo "进程数量：$(pgrep nginx | wc -l)"
    echo "主进程PID：$(pgrep -o nginx)"
else
    echo "❌ nginx未运行"
fi

# 查看nginx的详细信息
ps aux | grep nginx | grep -v grep
```

### 7.3 进程监控脚本


**实用的监控脚本**：

<details>
<summary>点击展开完整脚本</summary>

```bash
#!/bin/bash
# 进程监控脚本

echo "=== 系统进程监控报告 ==="
echo "生成时间：$(date)"
echo

echo "📊 系统负载："
uptime

echo
echo "🔥 TOP 5 CPU占用进程："
ps aux --sort=-%cpu --no-headers | head -5 | awk '{printf "%-10s %5s%% %s\n", $1, $3, $11}'

echo
echo "💾 TOP 5 内存占用进程："
ps aux --sort=-%mem --no-headers | head -5 | awk '{printf "%-10s %5s%% %s\n", $1, $4, $11}'

echo
echo "🔍 关键服务状态："
for service in nginx apache2 mysql sshd; do
    if pgrep "$service" > /dev/null; then
        count=$(pgrep "$service" | wc -l)
        echo "✅ $service: 运行中 ($count 个进程)"
    else
        echo "❌ $service: 未运行"
    fi
done
```

</details>

### 7.4 僵尸进程清理


**什么是僵尸进程**：
```
子进程已死，但父进程还没收尸
就像：人死了但户口还没注销

危害：占用进程表项，数量多了影响系统
```

**查找和处理**：
```bash
# 查找僵尸进程
ps aux | grep -E "Z|<defunct>"

# 找出僵尸进程的父进程
ps -eo pid,ppid,state,comm | grep Z

# 通常需要重启父进程来清理僵尸进程
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 进程查看：了解系统运行状态的基本技能
🔸 ps命令：最重要的进程查看工具，掌握aux、-ef格式
🔸 进程状态：理解R、S、D、Z等状态含义
🔸 进程关系：父子进程关系，进程树结构
🔸 /proc文件系统：进程信息的详细来源
```

### 8.2 常用命令速查表


| 需求 | **命令** | **说明** |
|------|---------|---------|
| `查看所有进程` | `ps aux` | `最常用的格式` |
| `按CPU排序` | `ps aux --sort=-%cpu` | `找出CPU占用最高的` |
| `按内存排序` | `ps aux --sort=-%mem` | `找出内存占用最高的` |
| `搜索进程` | `pgrep 进程名` | `快速查找进程ID` |
| `查看进程树` | `pstree -p` | `显示进程层次关系` |
| `查找进程ID` | `pidof 进程名` | `简单查找方式` |

### 8.3 实际应用记忆要点


**🔹 系统卡顿时的排查思路**：
```
1. ps aux --sort=-%cpu   (找CPU占用高的)
2. ps aux --sort=-%mem   (找内存占用高的)
3. pstree -p             (看进程关系)
4. /proc/PID/status      (看详细信息)
```

**🔹 服务管理的常用检查**：
```
1. pgrep 服务名          (快速检查是否运行)
2. ps aux | grep 服务名  (看详细状态)
3. pstree 服务PID        (看子进程情况)
```

**🔹 记忆技巧**：
```
ps = Process Status (进程状态)
aux = All Users eXtended (所有用户扩展信息)
pgrep = Process GREP (进程搜索)
pstree = Process TREE (进程树)
pidof = PID OF (某进程的PID)
```

### 8.4 新手常见问题


::: warning 注意事项
- **不要**用`kill -9`随便杀进程，先了解进程作用
- **僵尸进程**不能直接杀死，要处理父进程
- **系统进程**（PID很小的）不要随便动
- **ps输出**很多时可以配合grep、head等命令过滤
:::

**核心记忆口诀**：
```
ps aux查进程，CPU内存看得清
pgrep来搜索，pidof找ID行
pstree显关系，父子一目明
/proc存详情，系统信息真
```