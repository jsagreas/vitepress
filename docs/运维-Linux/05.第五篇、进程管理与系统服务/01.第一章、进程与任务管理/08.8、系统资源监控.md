---
title: 8、系统资源监控
---
## 📚 目录

1. [系统负载监控 - uptime命令](#1-系统负载监控---uptime命令)
2. [负载平均值深度解析](#2-负载平均值深度解析)
3. [内存使用监控 - free命令](#3-内存使用监控---free命令)
4. [虚拟内存统计 - vmstat命令](#4-虚拟内存统计---vmstat命令)
5. [磁盘I/O监控 - iostat命令](#5-磁盘io监控---iostat命令)
6. [系统活动报告 - sar命令](#6-系统活动报告---sar命令)
7. [系统资源瓶颈识别与分析](#7-系统资源瓶颈识别与分析)
8. [资源使用趋势分析](#8-资源使用趋势分析)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🖥️ 系统负载监控 - uptime命令


### 1.1 uptime命令基本概念


**什么是uptime？**
`uptime`命令就像是给系统"量体温"的工具，它告诉我们系统运行了多长时间，以及当前系统有多"忙碌"。

```bash
# 查看系统运行时间和负载
uptime
```

**典型输出示例：**
```
15:30:25 up 7 days, 2:15, 3 users, load average: 0.25, 0.31, 0.28
```

让我们逐个解释这些数字的含义：

```
时间解读：
┌─ 当前时间：15:30:25
│
├─ 运行时长：up 7 days, 2:15  (系统已运行7天2小时15分钟)
│
├─ 用户数量：3 users  (当前有3个用户登录)
│
└─ 负载平均值：load average: 0.25, 0.31, 0.28
   ├─ 0.25: 最近1分钟的平均负载
   ├─ 0.31: 最近5分钟的平均负载  
   └─ 0.28: 最近15分钟的平均负载
```

### 1.2 系统运行时间的意义


**为什么关心运行时间？**
- **系统稳定性指标**：运行时间越长，说明系统越稳定
- **重启记录**：可以判断系统是否最近重启过
- **维护计划**：帮助安排系统维护窗口

**实际应用场景：**
```bash
# 检查服务器是否刚重启过
uptime
# 如果显示 "up 5 min"，说明系统刚启动不久

# 在脚本中获取运行时间
uptime | awk '{print $3,$4}' | sed 's/,//'
# 输出：7 days
```

---

## 2. ⚖️ 负载平均值深度解析


### 2.1 什么是负载平均值（Load Average）


**通俗理解：**
想象一下高速公路的收费站：
- **负载 = 0**：收费站空闲，车辆可以直接通过
- **负载 = 1**：收费站刚好忙碌，车辆需要排队但不堵车
- **负载 > 1**：收费站过载，车辆开始排长队

```
CPU负载示意图：
负载 0.0    [    ]  CPU完全空闲
负载 0.5    [██  ]  CPU使用50%
负载 1.0    [████]  CPU完全使用，无等待
负载 2.0    [████] + 队列[████]  CPU满载，还有等待任务
```

### 2.2 三个时间窗口的含义


**为什么有1分钟、5分钟、15分钟三个值？**

```bash
load average: 0.25, 0.31, 0.28
             ↑     ↑     ↑
         1分钟  5分钟  15分钟
```

**实际场景分析：**
```
场景1：突发负载高峰
load average: 3.2, 1.1, 0.4
解读：刚才1分钟系统很忙(3.2)，但整体还算正常

场景2：持续高负载
load average: 2.8, 2.9, 2.7  
解读：系统持续过载，需要立即处理

场景3：负载逐渐上升
load average: 1.5, 1.2, 0.8
解读：系统负载在增加，需要关注趋势
```

### 2.3 负载值的判断标准


**单核CPU的负载标准：**
```
负载范围        系统状态         实际含义
0.0 - 0.7      优秀           系统很轻松，响应快速
0.7 - 1.0      良好           系统正常工作，偶有等待
1.0 - 1.5      关注           系统开始吃力，需要监控
1.5 - 3.0      警告           系统过载，响应变慢
> 3.0          危险           系统严重过载，可能卡死
```

**多核CPU的负载计算：**
```bash
# 查看CPU核心数
nproc
# 输出：4  (表示4核CPU)

# 对于4核CPU：
# 负载4.0 = 相当于单核的负载1.0 (刚好满负荷)
# 负载2.0 = 相当于单核的负载0.5 (使用50%)
# 负载6.0 = 相当于单核的负载1.5 (过载50%)
```

**快速判断公式：**
```
实际负载率 = 当前负载 ÷ CPU核心数

示例：4核CPU，负载3.2
实际负载率 = 3.2 ÷ 4 = 0.8 (80%的负载，属于良好状态)
```

---

## 3. 💾 内存使用监控 - free命令


### 3.1 free命令基本用法


**什么是内存监控？**
内存就像是我们的工作桌面，桌面越大，我们能同时处理的事情就越多。`free`命令告诉我们桌面有多大，用了多少，还剩多少。

```bash
# 查看内存使用情况
free

# 以人类可读的格式显示
free -h

# 每2秒刷新一次
free -h -s 2
```

### 3.2 内存信息详解


**典型输出示例：**
```
              total        used        free      shared  buff/cache   available
Mem:           7.8G        2.1G        1.2G        234M        4.5G        5.1G
Swap:          2.0G          0B        2.0G
```

**各字段含义通俗解释：**

```
内存使用结构图：
┌─────────────── total (总内存 7.8G) ──────────────────┐
│                                                      │
├─ used (已用 2.1G) ─┬─ free (空闲 1.2G) ─┬─ buff/cache (缓存 4.5G) ─┤
│                   │                     │                           │
│ 程序正在使用的内存   │ 完全空闲的内存      │ 系统缓存，可释放给程序用    │
└──────────────────┴─────────────────────┴───────────────────────────┘
                              ↑
                    available (可用 5.1G)
                    实际可供程序使用的内存
```

**重要概念解释：**

> 💡 **核心理解**：`available`是最重要的指标！
> 
> - **free**：完全没使用的内存（通常很小）
> - **buff/cache**：系统为了加速而缓存的数据，需要时可以释放
> - **available**：free + 可释放的buff/cache = 实际可用内存

### 3.3 内存使用判断标准


**内存状态评判：**
```bash
# 计算内存使用率
memory_usage=$(free | grep Mem | awk '{printf "%.1f", ($3/$2) * 100.0}')
echo "内存使用率: ${memory_usage}%"
```

**使用率判断标准：**
```
使用率范围        系统状态         建议操作
0% - 60%        优秀           内存充足，运行流畅
60% - 80%       良好           内存使用正常
80% - 90%       关注           开始监控，考虑优化
90% - 95%       警告           内存紧张，需要处理
> 95%           危险           内存即将耗尽，立即处理
```

### 3.4 swap交换空间理解


**什么是swap？**
Swap就像是我们的"临时仓库"。当工作桌面（内存）满了，我们把暂时不用的东西放到仓库（swap）里。

```
内存和Swap的关系：
┌─ 内存(RAM) ─┐    ┌─ Swap(磁盘) ─┐
│ 速度：极快   │    │ 速度：较慢    │
│ 容量：较小   │◄──►│ 容量：较大    │
│ 程序活跃数据 │    │ 程序休眠数据  │
└─────────────┘    └──────────────┘
```

**Swap使用状况判断：**
```
Swap使用         系统状态         说明
0%              理想状态         内存充足，无需交换
< 10%           正常状态         偶尔使用，属正常
10% - 50%       需要关注         频繁交换，影响性能
> 50%           性能问题         大量交换，系统变慢
```

---

## 4. 📊 虚拟内存统计 - vmstat命令


### 4.1 vmstat命令概述


**什么是vmstat？**
如果说`free`是看内存的"静态照片"，那么`vmstat`就是看系统的"动态视频"。它能告诉我们系统各个方面的实时变化情况。

```bash
# 每2秒输出一次，共输出5次
vmstat 2 5

# 显示更详细的内存信息
vmstat -a

# 显示磁盘统计信息
vmstat -d
```

### 4.2 vmstat输出详解


**典型输出示例：**
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1234567  89123 456789    0    0    12    45  123  234  5  2 92  1  0
 0  0      0 1235678  89124 456790    0    0     8    32  98   189  3  1 95  1  0
```

**字段含义通俗解释：**

```
进程状态 (procs):
r: 运行队列中的进程数（正在运行+等待运行）
   ├─ 理想值：≤ CPU核心数
   └─ 含义：就像排队等服务的人数
b: 等待I/O的进程数（被阻塞的进程）
   ├─ 理想值：接近0
   └─ 含义：等待读写文件的进程数
```

```
内存信息 (memory - 单位KB):
swpd: 已使用的swap空间
free: 空闲内存
buff: 用作缓冲的内存（即将写入磁盘的数据）
cache: 用作缓存的内存（从磁盘读取的数据）
```

```
交换信息 (swap - 单位KB/秒):
si: 从磁盘交换到内存的数据量
so: 从内存交换到磁盘的数据量
注意：si/so > 0 说明系统在频繁使用swap，性能会下降
```

```
I/O信息 (io - 单位块/秒):
bi: 从磁盘读入的块数
bo: 写入磁盘的块数
含义：数值越大说明磁盘I/O越繁忙
```

```
CPU使用率 (cpu - 百分比):
us: 用户态CPU使用率（运行应用程序）
sy: 内核态CPU使用率（运行系统调用）
id: 空闲CPU使用率
wa: 等待I/O的CPU使用率
st: 被虚拟机偷走的CPU使用率（虚拟化环境）
```

### 4.3 vmstat数据分析实例


**场景1：CPU密集型负载**
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 8  0      0 1234567  89123 456789    0    0     5    10  567  890 85 10  5  0  0
```
**分析**：`r=8`（多个进程等待CPU），`us=85%`（用户程序占用CPU高），`wa=0`（无I/O等待）
**结论**：系统CPU负载高，可能需要优化程序或增加CPU资源

**场景2：I/O密集型负载**
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  5      0 1234567  89123 456789    0    0   890  1200  234  456 20 15 30 35  0
```
**分析**：`b=5`（多个进程等待I/O），`wa=35%`（CPU等待I/O时间长），`bi/bo`很高
**结论**：系统I/O瓶颈，可能需要优化磁盘性能或减少I/O操作

**场景3：内存不足**
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 3  2  512000    8000  12000  45000   45   67    23    89  345  567 15 25 45 15  0
```
**分析**：`swpd=512MB`（大量使用swap），`si/so>0`（频繁交换），`free`很小
**结论**：内存不足，系统在频繁使用swap，性能下降

---

## 5. 💿 磁盘I/O监控 - iostat命令


### 5.1 iostat命令基础


**什么是iostat？**
`iostat`就像是给硬盘装了一个"速度计"和"里程表"，告诉我们硬盘有多忙，读写速度如何。

> 📝 **注意**：`iostat`命令属于`sysstat`软件包，如果没有需要先安装：
> ```bash
> # CentOS/RHEL
> yum install sysstat
> # Ubuntu/Debian  
> apt install sysstat
> ```

```bash
# 基本使用
iostat

# 每2秒刷新一次
iostat 2

# 显示扩展信息
iostat -x

# 只显示设备信息，不显示CPU信息
iostat -d
```

### 5.2 iostat输出解析


**典型输出示例：**
```bash
iostat -x 2
```

```
Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.12     4.25    2.15    8.47    89.23   245.67    63.21     0.08    7.45    3.21   8.92   1.23   1.31
sdb               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00   0.00   0.00   0.00
```

**重要字段含义解释：**

```
吞吐量指标：
r/s:  每秒读请求数      理想值：根据应用需求
w/s:  每秒写请求数      理想值：根据应用需求
rkB/s: 每秒读取KB数     注意：1MB/s = 1024KB/s
wkB/s: 每秒写入KB数     合计不应超过磁盘极限
```

```
性能指标：
await:   平均I/O等待时间（毫秒）
         ├─ < 10ms : 优秀
         ├─ 10-20ms: 良好  
         ├─ 20-100ms: 一般
         └─ > 100ms: 较差

%util:   磁盘使用率
         ├─ < 70%: 正常
         ├─ 70-85%: 需要关注
         ├─ 85-95%: 繁忙
         └─ > 95%: 可能存在瓶颈
```

```
队列指标：
avgqu-sz: 平均队列长度
          ├─ < 1: 磁盘轻松
          ├─ 1-4: 正常范围
          └─ > 10: 队列过长，性能下降
```

### 5.3 磁盘性能判断实例


**场景1：磁盘性能良好**
```
Device:    r/s     w/s    rkB/s    wkB/s   await   %util
sda       12.5    25.3    512.4   1024.8     8.2    35.4
```
**分析**：等待时间短（8.2ms），使用率适中（35.4%），性能良好

**场景2：磁盘出现瓶颈**
```
Device:    r/s     w/s    rkB/s    wkB/s   await   %util
sda      156.7   234.8   6789.2  12345.6    85.3    98.7
```
**分析**：等待时间长（85.3ms），使用率极高（98.7%），磁盘瓶颈明显

**场景3：磁盘几乎空闲**
```
Device:    r/s     w/s    rkB/s    wkB/s   await   %util
sda        0.2     1.8     12.4     45.6     2.1     0.8
```
**分析**：读写很少，等待时间短，使用率极低，磁盘很空闲

---

## 6. 📈 系统活动报告 - sar命令


### 6.1 sar命令概述


**什么是sar？**
`sar`（System Activity Reporter）是系统活动的"记录仪"，就像飞机的黑匣子一样，记录系统的各种活动历史，让我们能够分析系统的历史性能。

```bash
# 显示CPU使用情况，每2秒一次，共5次
sar -u 2 5

# 显示内存使用情况
sar -r 

# 显示磁盘I/O情况
sar -b

# 显示网络统计
sar -n DEV

# 查看历史数据（昨天的）
sar -u -f /var/log/sa/sa$(date -d yesterday +%d)
```

### 6.2 CPU监控 - sar -u


**典型输出：**
```
Linux 5.4.0 (server01)    09/14/2025    _x86_64_    (4 CPU)

03:25:01 PM     CPU     %user     %nice    %system   %iowait    %steal     %idle
03:25:03 PM     all      12.5       0.0       3.2       1.8       0.0      82.5
03:25:05 PM     all      15.2       0.0       4.1       2.3       0.0      78.4
```

**字段含义：**
- **%user**: 用户程序使用CPU的百分比
- **%system**: 系统内核使用CPU的百分比
- **%iowait**: CPU等待I/O操作的百分比
- **%idle**: CPU空闲的百分比

**判断标准：**
```
CPU使用模式分析：
%user高(>70%)  → 应用程序CPU密集，可能需要优化算法
%system高(>30%) → 系统调用频繁，可能有I/O瓶颈
%iowait高(>20%) → 磁盘I/O成为瓶颈
%idle低(<20%)   → CPU资源紧张
```

### 6.3 内存监控 - sar -r


**典型输出：**
```
03:25:01 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit
03:25:03 PM   1048576   6291456     75.0    204800   3145728   4194304     50.0
```

**关键指标：**
- **%memused**: 内存使用率
- **kbcached**: 缓存大小
- **%commit**: 内存承诺率（已分配但未必使用的内存）

### 6.4 磁盘I/O监控 - sar -b


**典型输出：**
```
03:25:01 PM       tps      rtps      wtps   bread/s   bwrtn/s
03:25:03 PM     45.50     12.00     33.50    245.67    892.34
```

**字段解释：**
- **tps**: 每秒传输次数（IOPS）
- **rtps**: 每秒读取次数
- **wtps**: 每秒写入次数
- **bread/s**: 每秒读取的块数
- **bwrtn/s**: 每秒写入的块数

---

## 7. 🔍 系统资源瓶颈识别与分析


### 7.1 瓶颈类型识别


**系统性能瓶颈的四大类型：**

```
系统瓶颈类型图：
┌─ CPU瓶颈 ─┐    ┌─ 内存瓶颈 ─┐    ┌─ 磁盘I/O瓶颈 ─┐    ┌─ 网络瓶颈 ─┐
│ 负载高     │    │ 使用率高   │    │ 等待时间长      │    │ 丢包率高   │
│ 队列长     │    │ swap频繁   │    │ 使用率高        │    │ 延迟大     │
│ %idle低    │    │ 可用内存少 │    │ 队列长          │    │ 带宽满     │
└───────────┘    └───────────┘    └───────────────┘    └───────────┘
```

### 7.2 瓶颈识别方法


**CPU瓶颈识别：**
```bash
# 检查负载是否过高
uptime
# 如果load average超过CPU核心数，可能有CPU瓶颈

# 检查CPU使用率
sar -u 1 5
# 如果%idle < 20%且%iowait < 20%，是CPU瓶颈
```

**内存瓶颈识别：**
```bash
# 检查内存使用和swap使用
free -h
vmstat 2 5
# 如果available内存<10%或频繁使用swap，是内存瓶颈
```

**磁盘I/O瓶颈识别：**
```bash
# 检查磁盘使用率和等待时间
iostat -x 2 5
# 如果%util > 85%或await > 20ms，可能是I/O瓶颈
```

### 7.3 综合瓶颈分析实例


**实例1：CPU瓶颈场景**
```bash
# 系统症状
uptime
# 15:30:25 up 1 day, load average: 8.50, 7.20, 6.80

sar -u 2 3  
# %user=85%, %system=10%, %iowait=2%, %idle=3%

# 分析结论：CPU瓶颈
# 解决方案：优化应用程序、增加CPU核心、分布式处理
```

**实例2：I/O瓶颈场景**
```bash
# 系统症状  
iostat -x 2 3
# await=156ms, %util=98%, avgqu-sz=12.5

vmstat 2 3
# wa=45%, b=8

# 分析结论：磁盘I/O瓶颈
# 解决方案：优化I/O操作、使用SSD、增加内存做缓存
```

**实例3：内存瓶颈场景**
```bash
# 系统症状
free -h
# available: 234M (总共8G内存)

vmstat 2 3  
# si=1200, so=890 (频繁swap交换)

# 分析结论：内存不足
# 解决方案：增加物理内存、优化程序内存使用、调整swap策略
```

---

## 8. 📊 资源使用趋势分析


### 8.1 建立监控基线


**什么是性能基线？**
性能基线就像是给系统做"体检报告"，记录系统正常状态下的各项指标，用于后续对比分析。

**建立基线的方法：**
```bash
#!/bin/bash
# 性能基线收集脚本 baseline.sh

DATE=$(date +%Y%m%d_%H%M%S)
LOGDIR="/var/log/performance"
mkdir -p $LOGDIR

echo "=== 系统性能基线收集 - $DATE ===" > $LOGDIR/baseline_$DATE.log

# 系统负载
echo "== 系统负载 ==" >> $LOGDIR/baseline_$DATE.log
uptime >> $LOGDIR/baseline_$DATE.log

# CPU信息
echo "== CPU使用情况 ==" >> $LOGDIR/baseline_$DATE.log
sar -u 1 60 >> $LOGDIR/baseline_$DATE.log

# 内存使用
echo "== 内存使用情况 ==" >> $LOGDIR/baseline_$DATE.log
free -h >> $LOGDIR/baseline_$DATE.log
sar -r 1 60 >> $LOGDIR/baseline_$DATE.log

# 磁盘I/O
echo "== 磁盘I/O情况 ==" >> $LOGDIR/baseline_$DATE.log
iostat -x 1 60 >> $LOGDIR/baseline_$DATE.log

echo "基线数据收集完成：$LOGDIR/baseline_$DATE.log"
```

### 8.2 趋势分析方法


**资源使用趋势分类：**

```
趋势类型分析：
┌─ 稳定型 ─┐    ┌─ 上升型 ─┐    ┌─ 波动型 ─┐    ┌─ 周期型 ─┐
│  ─────── │    │      ／  │    │ ∩   ∩   │    │ ∩ ∩ ∩ ∩ │
│          │    │    ／    │    │∪ ∪ ∪ ∪  │    │∪ ∪ ∪ ∪  │
│ 系统稳定  │    │ 资源耗尽  │    │ 负载不均  │    │ 规律变化  │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
```

**使用sar进行历史分析：**
```bash
# 查看过去7天的CPU使用趋势
for i in {1..7}; do
  date_suffix=$(date -d "$i days ago" +%d)
  if [ -f /var/log/sa/sa$date_suffix ]; then
    echo "=== $(date -d "$i days ago" +%Y-%m-%d) ==="
    sar -u -f /var/log/sa/sa$date_suffix | grep Average
  fi
done
```

### 8.3 预警机制建立


**资源使用预警脚本：**
```bash
#!/bin/bash
# 系统资源监控预警脚本 alert.sh

# 预警阈值设置
CPU_THRESHOLD=80        # CPU使用率阈值
MEM_THRESHOLD=85        # 内存使用率阈值  
DISK_THRESHOLD=90       # 磁盘使用率阈值
LOAD_THRESHOLD=5.0      # 负载阈值

# 获取当前状态
CPU_USAGE=$(sar -u 1 1 | grep Average | awk '{print 100-$NF}')
MEM_USAGE=$(free | grep Mem | awk '{printf "%.0f", ($3/$2) * 100.0}')
LOAD_AVG=$(uptime | awk '{print $(NF-2)}' | sed 's/,//')

# CPU预警
if (( $(echo "$CPU_USAGE > $CPU_THRESHOLD" | bc -l) )); then
    echo "警告：CPU使用率过高 ${CPU_USAGE}% (阈值: ${CPU_THRESHOLD}%)"
fi

# 内存预警  
if [ $MEM_USAGE -gt $MEM_THRESHOLD ]; then
    echo "警告：内存使用率过高 ${MEM_USAGE}% (阈值: ${MEM_THRESHOLD}%)"
fi

# 负载预警
if (( $(echo "$LOAD_AVG > $LOAD_THRESHOLD" | bc -l) )); then
    echo "警告：系统负载过高 $LOAD_AVG (阈值: $LOAD_THRESHOLD)"
fi
```

**设置定时监控：**
```bash
# 添加到crontab，每5分钟检查一次
crontab -e
# 添加以下行：
# */5 * * * * /path/to/alert.sh >> /var/log/system_alerts.log 2>&1
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 uptime：系统负载查看工具，关注load average三个值的含义
🔸 free：内存监控工具，重点关注available字段
🔸 vmstat：系统动态监控，综合显示CPU、内存、I/O状态
🔸 iostat：磁盘I/O专用监控，关注await和%util指标  
🔸 sar：系统活动历史记录，支持多维度性能分析
```

### 9.2 关键判断标准


**🔹 负载评判标准**
```
单核CPU负载标准：
• 0.0-0.7：优秀状态，响应迅速
• 0.7-1.0：良好状态，偶有等待
• 1.0-1.5：需要关注，开始过载
• >1.5：警告状态，响应变慢

多核CPU：实际负载率 = 当前负载 ÷ CPU核心数
```

**🔹 内存使用判断**
```
关键指标：
• available内存：最重要的可用内存指标
• swap使用：si/so > 0表示内存不足
• 使用率：>90%需要立即关注
```

**🔹 磁盘I/O性能**
```  
核心指标：
• await < 10ms：优秀
• await 10-20ms：良好
• await > 100ms：较差
• %util > 85%：可能存在瓶颈
```

### 9.3 实际应用指导


**🎯 日常监控流程**
```bash
# 快速系统状态检查
uptime && free -h && iostat -x 1 1

# 深入问题分析  
vmstat 2 5    # 查看系统动态
sar -u 2 5    # 查看CPU详情
sar -r 2 5    # 查看内存详情
```

**🎯 瓶颈排查思路**
```
1. 查看系统负载 → uptime
2. 判断瓶颈类型：
   - 负载高+%iowait低 → CPU瓶颈
   - %iowait高+await高 → I/O瓶颈  
   - swap频繁+内存不足 → 内存瓶颈
3. 针对性优化处理
```

**🎯 监控最佳实践**
```
建立监控体系：
• 设置性能基线
• 建立预警机制
• 定期趋势分析
• 优化响应方案
```

> 🧠 **记忆要点**：
> 
> - **uptime看负载**：三个数字分别是1、5、15分钟平均值
> - **free看内存**：available是真正可用的内存
> - **vmstat看动态**：综合监控系统实时状态
> - **iostat看磁盘**：await和%util是关键指标
> - **sar看历史**：分析系统性能趋势变化

**实战记忆口诀**：
> 系统监控五大宝，uptime负载要记牢
> free内存看available，vmstat动态最重要  
> iostat专看磁盘忙，sar命令查历史好
> 瓶颈分析有方法，CPU内存IO都要考