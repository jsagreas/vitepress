---
title: 3、服务启动瀑布图分析
---
## 📚 目录


1. [瀑布图分析概述](#1-瀑布图分析概述)
2. [systemd-analyze plot 基础使用](#2-systemd-analyze-plot-基础使用)
3. [SVG图表深度解读](#3-SVG图表深度解读)
4. [服务启动并行与串行分析](#4-服务启动并行与串行分析)
5. [启动瓶颈识别方法](#5-启动瓶颈识别方法)
6. [时间轴分析与关键路径](#6-时间轴分析与关键路径)
7. [图表导出与报告生成](#7-图表导出与报告生成)
8. [启动流程优化策略](#8-启动流程优化策略)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 瀑布图分析概述



### 1.1 什么是启动瀑布图



**🔸 瀑布图定义**
```
瀑布图（Plot Chart）：一种可视化展示系统启动时序的图表工具
形象比喻：就像瀑布一样，从上到下按时间顺序展示各个服务的启动过程
核心作用：帮助我们直观看到系统启动时"谁先启动、谁后启动、谁最慢"
```

**💡 为什么需要瀑布图**
```
问题场景：
系统启动慢，但不知道是哪个服务拖后腿 → 瀑布图一目了然
服务启动顺序混乱，依赖关系不清楚 → 瀑布图显示依赖链
想优化启动性能，不知从何下手 → 瀑布图指出瓶颈点
```

### 1.2 瀑布图的核心价值



**🎯 解决的关键问题**
- **❓ 启动慢在哪？** → 找出耗时最长的服务
- **❓ 为什么这样启动？** → 理解服务依赖关系
- **❓ 能并行启动吗？** → 识别可优化的串行环节
- **❓ 优化效果如何？** → 对比优化前后的差异

### 1.3 瀑布图的组成要素



```
时间轴分析图示：
|<-- 内核启动 -->|<-- initrd -->|<-- userspace -->|

时间：0s────────5s────────10s────────15s────────20s
     │         │         │          │          │
     启动      initrd    用户空间    图形界面   启动完成
     内核      阶段      服务启动    启动
```

**🔧 图表核心元素**
- **⏰ 时间轴**：横坐标显示启动时间进度
- **📋 服务条**：每个服务用一条横bar表示，长度=耗时
- **🔗 依赖线**：显示服务间的启动依赖关系
- **🎨 颜色编码**：不同颜色表示服务状态和类型

---

## 2. 🖥️ systemd-analyze plot 基础使用



### 2.1 基本命令语法



**📝 核心命令格式**
```bash
# 基础语法

systemd-analyze plot [选项] > 输出文件.svg

# 最简单用法

systemd-analyze plot > boot-analysis.svg
```

**💻 常用命令示例**
```bash
# 生成完整启动分析图

systemd-analyze plot > /tmp/boot-plot.svg

# 只分析特定服务的启动

systemd-analyze plot --no-legend > simple-plot.svg

# 生成详细的启动时序图

systemd-analyze plot --fuzz=2s > detailed-plot.svg
```

### 2.2 命令参数详解



| 🔧 参数选项 | **作用说明** | **使用场景** |
|-------------|------------|------------|
| `--no-legend` | 不显示图例说明 | 简化图表，突出重点 |
| `--fuzz=时间` | 设置时间模糊度 | 过滤掉极短时间的服务 |
| `--no-pager` | 不使用分页显示 | 直接输出，便于重定向 |

### 2.3 输出文件处理



**📁 文件保存位置建议**
```bash
# 推荐保存路径

/tmp/boot-analysis.svg          # 临时分析文件
~/Documents/system-analysis/    # 个人分析目录
/var/log/system-performance/    # 系统性能日志目录
```

**🌐 查看SVG文件方法**
```bash
# 方法1：使用浏览器打开

firefox /tmp/boot-plot.svg
google-chrome boot-analysis.svg

# 方法2：使用图像查看器

eog boot-plot.svg              # GNOME图像查看器
gwenview boot-plot.svg         # KDE图像查看器

# 方法3：转换为其他格式

convert boot-plot.svg boot-plot.png
```

---

## 3. 🔍 SVG图表深度解读



### 3.1 图表整体结构理解



```
SVG瀑布图结构示意：
┌─────────────────────────────────────────────────────────────┐
│  标题：Startup finished in 2.1s (kernel) + 8.3s (userspace)│
├─────────────────────────────────────────────────────────────┤
│  时间轴：0s      5s      10s      15s      20s      25s    │
├─────────────────────────────────────────────────────────────┤
│  kernel ████████████                                       │
│  initrd      ████                                          │
│  multi-user.target ████████████████████████████████       │
│  graphical.target                    ████                 │
│  NetworkManager  ██████                                    │
│  sshd.service      ███                                     │
│  httpd.service        ████                                 │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 颜色编码含义解析



**🎨 标准颜色体系**
```
🟢 绿色：正常启动完成的服务
🔵 蓝色：系统核心服务（如systemd本身）
🟡 黄色：用户空间服务启动阶段
🔴 红色：启动失败或耗时过长的服务
🟣 紫色：目标单元（target units）
🟠 橙色：依赖等待时间
```

**💡 颜色深浅含义**
- **深色**：服务实际执行时间
- **浅色**：服务等待依赖的时间
- **渐变**：服务启动过程中的不同阶段

### 3.3 关键信息提取技巧



**⏱️ 时间信息读取**
```
图表顶部总结信息解读：
"Startup finished in 2.349s (kernel) + 1.835s (initrd) + 12.543s (userspace)"

含义解释：
- kernel: 2.349s    → 内核启动耗时
- initrd: 1.835s    → 初始内存磁盘耗时  
- userspace: 12.543s → 用户空间服务启动耗时
- 总启动时间 = 2.349 + 1.835 + 12.543 = 16.727秒
```

**📊 服务条长度分析**
```
横条长度含义：
████████████ (长条) = 启动耗时较长，需要关注
███ (短条) = 启动迅速，无需优化
```

---

## 4. ⚖️ 服务启动并行与串行分析



### 4.1 并行启动识别



**🔄 并行启动模式识别**
```
并行启动图示：
时间： 0s    5s    10s    15s    20s
      │     │     │      │      │
ServiceA ████████
ServiceB ████████
ServiceC ████████
      │     │     │      │      │
      └─────┴─────┴──────┴──────┘
     这三个服务同时启动（并行）
```

**✅ 并行启动的优势**
- **⚡ 提升效率**：多个服务同时启动，节省总时间
- **🎯 资源利用**：充分利用CPU多核心能力
- **📈 性能优化**：整体启动时间显著缩短

### 4.2 串行依赖关系分析



**🔗 串行依赖示例**
```
串行依赖图示：
时间： 0s    5s    10s    15s    20s
      │     │     │      │      │
network.service ████████
               └─→ sshd.service ████████
                              └─→ httpd.service ████████

说明：sshd依赖network，httpd依赖sshd，必须串行启动
```

**⚠️ 串行依赖的影响**
```
依赖链问题：
A → B → C → D
如果B服务启动慢，会影响C和D的启动时间
整条链的总时间 = A时间 + B时间 + C时间 + D时间
```

### 4.3 混合启动模式理解



**🎯 实际启动场景**
```
复杂启动流程示意：
时间： 0s    5s    10s    15s    20s
      │     │     │      │      │
systemd-resolved ████████
network.service ████████
                └─→ sshd.service ████
dbus.service ████████
           └─→ NetworkManager ████████
                              └─→ cups.service ████
```

**🧠 分析思路**
- **识别关键路径**：找出启动时间最长的依赖链
- **发现并行机会**：看哪些服务可以同时启动
- **定位瓶颈服务**：找出拖慢整体启动的服务

---

## 5. 🎯 启动瓶颈识别方法



### 5.1 瓶颈服务快速定位



**🔍 三步定位法**

**步骤 1️⃣：总体时间分析**
```bash
# 查看启动时间总览

systemd-analyze

# 输出示例：

Startup finished in 2.1s (kernel) + 1.8s (initrd) + 15.2s (userspace) = 19.1s
graphical.target reached after 15.2s in userspace
```

**步骤 2️⃣：服务耗时排序**
```bash
# 查看最慢的服务

systemd-analyze blame | head -10

# 输出示例：

8.234s mysql.service
5.123s httpd.service  
3.456s NetworkManager.service
2.789s sshd.service
```

**步骤 3️⃣：瀑布图确认**
```bash
# 生成详细分析图

systemd-analyze plot > analysis.svg
# 在图中找到blame命令显示的慢服务，查看其在时间轴上的位置

```

### 5.2 瓶颈类型分类



**🐌 慢启动服务瓶颈**
```
特征：服务条很长，占用大量时间
原因：
- 服务本身启动复杂（如数据库初始化）
- 配置文件过大需要解析时间
- 磁盘I/O性能不足

识别方法：
在瀑布图中显示为特别长的横条
```

**⏳ 依赖等待瓶颈**
```
特征：服务等待时间长，实际运行时间短
原因：
- 依赖的服务启动慢
- 网络等待（如等待网络接口up）
- 资源竞争等待

识别方法：
横条中浅色部分占比大
```

**🔄 并发冲突瓶颈**
```
特征：多个服务争抢同一资源
原因：
- 磁盘I/O竞争
- 内存资源不足
- CPU核心数限制

识别方法：
多个服务启动时间重叠但都比较慢
```

### 5.3 瓶颈服务优化策略



**🎯 针对性优化方案**

| 🚫 瓶颈类型 | **优化策略** | **具体方法** |
|-------------|------------|------------|
| 慢启动服务 | 服务优化 | 精简配置、SSD存储、内存优化 |
| 依赖等待 | 依赖重构 | 并行化改造、依赖解耦 |
| 并发冲突 | 资源优化 | 硬件升级、启动时序调整 |

---

## 6. ⏰ 时间轴分析与关键路径识别



### 6.1 关键路径概念理解



**🛣️ 什么是关键路径**
```
关键路径定义：
从系统启动开始到完全就绪，耗时最长的那条依赖链路
就像：从家到公司有多条路线，最堵的那条路决定了你的总通勤时间

示例关键路径：
kernel → initrd → systemd → basic.target → network.service → multi-user.target → graphical.target
```

**⚡ 为什么关键路径重要**
- **决定总时间**：关键路径的长度=系统总启动时间
- **优化重点**：优化关键路径上的服务效果最明显
- **资源分配**：应该把主要精力投入到关键路径优化

### 6.2 关键路径识别方法



**🔍 瀑布图中的关键路径识别**
```bash
# 1. 生成详细分析图

systemd-analyze plot > critical-path.svg

# 2. 查看关键路径

systemd-analyze critical-chain

# 输出示例：

graphical.target @15.2s
└─multi-user.target @15.1s
  └─network.service @10.2s +4.9s
    └─NetworkManager.service @8.1s +2.1s
      └─dbus.service @3.2s +4.9s
        └─basic.target @3.1s
```

**📊 关键路径可视化理解**
```
关键路径时间轴：
0s────3.1s────8.1s────10.2s────15.1s────15.2s
│     │       │       │        │        │
启动  basic   NM开始  network  multi    graphical
     target  启动    完成     user     就绪
            ↑       ↑       target   
         dbus    网络管理器
         耗时    启动完成
         4.9s
```

### 6.3 时间轴分段分析



**🔄 启动阶段划分**
```
完整启动时间轴分析：

阶段1: 内核阶段 (0s - 2.1s)
├─ 硬件初始化
├─ 内核模块加载  
└─ initrd准备

阶段2: initrd阶段 (2.1s - 3.9s)
├─ 根文件系统挂载
├─ 必要驱动加载
└─ systemd启动

阶段3: 基础服务阶段 (3.9s - 8.0s)
├─ dbus.service启动
├─ basic.target达成
└─ 核心系统服务启动

阶段4: 网络服务阶段 (8.0s - 13.0s)
├─ NetworkManager启动
├─ network.service完成
└─ 网络相关服务启动

阶段5: 用户服务阶段 (13.0s - 15.2s)
├─ multi-user.target达成
├─ 用户服务启动
└─ graphical.target就绪
```

**⚡ 各阶段优化重点**
- **内核阶段**：硬件兼容性、内核参数优化
- **initrd阶段**：精简initrd、SSD存储
- **基础服务**：并行化核心服务启动
- **网络服务**：网络配置优化
- **用户服务**：禁用不必要的服务

---

## 7. 📊 图表导出与报告生成



### 7.1 多格式导出方法



**📁 SVG格式处理**
```bash
# 基础SVG导出

systemd-analyze plot > boot-analysis.svg

# 高质量SVG导出

systemd-analyze plot --fuzz=1s --no-legend > clean-analysis.svg
```

**🖼️ 转换为其他格式**
```bash
# 转换为PNG（需要imagemagick）

convert -density 300 boot-analysis.svg boot-analysis.png

# 转换为PDF（需要rsvg-convert）

rsvg-convert -f pdf -o boot-analysis.pdf boot-analysis.svg

# 转换为JPEG

convert -background white -flatten boot-analysis.svg boot-analysis.jpg
```

### 7.2 自动化报告生成



**🤖 报告生成脚本**
```bash
#!/bin/bash

# 系统启动性能自动分析脚本


REPORT_DIR="/var/log/boot-analysis"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建报告目录

mkdir -p "$REPORT_DIR"

# 生成基础分析

echo "=== 系统启动性能分析报告 ===" > "$REPORT_DIR/report_$DATE.txt"
echo "分析时间: $(date)" >> "$REPORT_DIR/report_$DATE.txt"
echo "" >> "$REPORT_DIR/report_$DATE.txt"

# 总体时间分析

echo "1. 启动时间总览:" >> "$REPORT_DIR/report_$DATE.txt"
systemd-analyze >> "$REPORT_DIR/report_$DATE.txt"
echo "" >> "$REPORT_DIR/report_$DATE.txt"

# 最慢服务分析

echo "2. 最慢的10个服务:" >> "$REPORT_DIR/report_$DATE.txt"
systemd-analyze blame | head -10 >> "$REPORT_DIR/report_$DATE.txt"
echo "" >> "$REPORT_DIR/report_$DATE.txt"

# 关键路径分析

echo "3. 关键路径分析:" >> "$REPORT_DIR/report_$DATE.txt"
systemd-analyze critical-chain >> "$REPORT_DIR/report_$DATE.txt"

# 生成可视化图表

systemd-analyze plot > "$REPORT_DIR/boot_plot_$DATE.svg"

echo "报告已生成到: $REPORT_DIR"
```

### 7.3 报告内容结构



**📋 标准分析报告模板**
```markdown
# 系统启动性能分析报告


# 📈 总体性能指标


- 总启动时间: XX.Xs
- 内核启动时间: XX.Xs  
- 用户空间启动时间: XX.Xs
- 性能等级: [优秀/良好/一般/需优化]

# 🎯 关键发现


- 最慢服务: service-name (XX.Xs)
- 关键瓶颈: [描述主要问题]
- 优化建议: [具体改进方案]

# 📊 详细分析


## 服务启动时间排序


1. service1: XX.Xs
2. service2: XX.Xs
...

## 关键路径分析


[关键路径图表和说明]

# 💡 优化建议


1. [具体优化方案1]
2. [具体优化方案2]
...
```

---

## 8. 🚀 启动流程优化策略



### 8.1 并行化优化策略



**🔄 识别可并行化的服务**
```bash
# 查看服务依赖关系

systemctl list-dependencies graphical.target

# 分析哪些服务可以并行启动

systemd-analyze dump > services-dump.txt
grep -E "(After|Before|Requires|Wants)" services-dump.txt
```

**⚡ 并行化实施方案**
```bash
# 示例：优化网络相关服务启动

# 原始配置：sshd → network → httpd (串行)

# 优化后：sshd ← network → httpd (并行)


# 修改服务依赖关系

sudo systemctl edit sshd.service
# 在编辑器中添加：

[Unit]
After=network.target
# 移除对network.service的直接依赖

```

### 8.2 服务精简优化



**🎯 识别不必要的服务**
```bash
# 查看所有已启用的服务

systemctl list-unit-files --state=enabled

# 查看启动时间超过阈值的服务

systemd-analyze blame | awk '$1 > "5.000s" {print $2}'
```

**✂️ 服务禁用策略**
```bash
# 安全禁用不需要的服务

sudo systemctl disable bluetooth.service    # 不需要蓝牙
sudo systemctl disable cups.service         # 不需要打印服务
sudo systemctl disable avahi-daemon.service # 不需要网络发现

# 查看禁用效果

systemd-analyze blame
```

### 8.3 硬件层面优化



**💾 存储优化**
```bash
# SSD优化设置

echo 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash elevator=noop"' | sudo tee -a /etc/default/grub
sudo update-grub

# 文件系统优化

sudo tune2fs -o journal_data_writeback /dev/sda1
```

**🧠 内存优化**
```bash
# 预加载常用程序

echo 'vm.swappiness=10' | sudo tee -a /etc/sysctl.conf
echo 'vm.vfs_cache_pressure=50' | sudo tee -a /etc/sysctl.conf
```

### 8.4 优化效果验证



**📊 性能对比方法**
```bash
# 优化前记录基准

systemd-analyze > before-optimization.txt
systemd-analyze plot > before-plot.svg

# 执行优化措施

[执行各种优化步骤]

# 优化后测试

systemd-analyze > after-optimization.txt
systemd-analyze plot > after-plot.svg

# 对比分析

echo "=== 优化对比结果 ==="
echo "优化前："
cat before-optimization.txt
echo "优化后："
cat after-optimization.txt
```

**✅ 优化成功指标**
- ⏱️ **启动时间缩短** > 20%
- 🎯 **关键路径优化** 明显
- 📊 **瓶颈服务减少**
- 🔄 **并行度提升**

---

## 9. 📋 核心要点总结



### 9.1 必须掌握的核心概念



```
🔸 瀑布图本质：可视化展示系统启动时序的强大工具
🔸 关键命令：systemd-analyze plot 生成SVG分析图表
🔸 图表解读：时间轴、服务条、颜色编码、依赖关系
🔸 瓶颈识别：慢服务、依赖等待、并发冲突三大类型
🔸 关键路径：决定总启动时间的最长依赖链
🔸 优化策略：并行化、服务精简、硬件优化
```

### 9.2 实用技巧记忆



**🧠 分析思路口诀**
```
看图先看总时间，找出最慢是关键
颜色深浅有含义，横条长短藏玄机  
串行并行要分清，依赖关系理得明
瓶颈一找优化易，效果对比验真理
```

**⚡ 快速诊断流程**
```
第一步：systemd-analyze 看总时间
第二步：systemd-analyze blame 找慢服务
第三步：systemd-analyze plot 画瀑布图
第四步：systemd-analyze critical-chain 找关键路径
第五步：针对性优化，效果对比验证
```

### 9.3 实际应用价值



**🎯 解决的实际问题**
- **🐌 系统启动慢**：精确定位瓶颈服务，不再盲目优化
- **❓ 不知道优化什么**：瀑布图直观显示改进点
- **🔧 优化效果不明显**：关键路径分析找到真正影响因素
- **📊 性能监控需要**：可视化报告便于长期跟踪

**💼 实际工作应用**
- **服务器运维**：快速诊断服务器启动问题
- **性能调优**：系统性能优化的第一步分析工具
- **故障排查**：启动相关问题的可视化诊断
- **容量规划**：了解系统资源使用特点

**核心记忆**：
- 瀑布图让启动过程一目了然，从"不知道慢在哪"到"精确定位瓶颈"
- systemd-analyze plot是Linux系统管理员必备的性能分析利器
- 理解并行与串行、识别关键路径是优化的核心思路
- 可视化分析+数据对比=科学的性能优化方法