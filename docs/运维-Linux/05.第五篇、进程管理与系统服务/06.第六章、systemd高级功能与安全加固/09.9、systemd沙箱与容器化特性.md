---
title: 9、systemd沙箱与容器化特性
---
## 📚 目录

1. [systemd沙箱机制概述](#1-systemd沙箱机制概述)
2. [命名空间隔离技术](#2-命名空间隔离技术)
3. [根目录隔离机制](#3-根目录隔离机制)
4. [设备访问控制](#4-设备访问控制)
5. [内核参数与系统保护](#5-内核参数与系统保护)
6. [时钟与实时性保护](#6-时钟与实时性保护)
7. [沙箱配置验证与测试](#7-沙箱配置验证与测试)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛡️ systemd沙箱机制概述


### 1.1 什么是systemd沙箱


**💡 核心概念**：
systemd沙箱是一套**安全隔离机制**，让服务运行在受限的环境中，就像把程序关在一个"沙箱"里，限制它能接触到的系统资源。

```
传统服务运行：
服务 ──→ 直接访问系统资源
     ├── 读写任意文件
     ├── 访问所有设备
     ├── 修改内核参数  
     └── 影响其他进程

沙箱化服务运行：
服务 ──→ 受限环境
     ├── 只能访问指定文件 ✓
     ├── 禁止访问敏感设备 ✗
     ├── 无法修改内核参数 ✗
     └── 与其他进程隔离 ✓
```

### 1.2 沙箱机制的实现原理


**🔧 底层技术支撑**：
```
Linux内核特性：
┌─────────────────┐
│  命名空间隔离    │ ← 进程、文件系统、网络隔离
├─────────────────┤
│  能力限制       │ ← 限制特权操作权限
├─────────────────┤
│  安全计算模式    │ ← seccomp系统调用过滤
├─────────────────┤
│  访问控制列表    │ ← 文件和设备访问控制
└─────────────────┘
```

**🎯 沙箱的三大作用**：
- **隔离**：限制服务能看到和访问的资源
- **防护**：防止恶意代码破坏系统
- **限制**：约束服务的权限范围

### 1.3 沙箱配置基础语法


**📋 基本配置结构**：
```ini
[Unit]
Description=安全的Web服务
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/my-web-server
User=web-user
Group=web-group

# 沙箱配置开始
PrivateTmp=yes           # 私有临时目录
PrivateDevices=yes       # 禁止访问设备文件
ProtectSystem=strict     # 保护系统文件
ProtectHome=yes          # 保护用户家目录
# 沙箱配置结束

[Install]
WantedBy=multi-user.target
```

---

## 2. 📦 命名空间隔离技术


### 2.1 PrivateMounts - 文件系统隔离


**🔸 基本概念**：
`PrivateMounts`让服务拥有**独立的文件系统视图**，看不到其他进程的挂载操作。

```ini
# 启用私有挂载命名空间
[Service]
PrivateMounts=yes
```

**💡 实际效果对比**：
```
普通服务视图：
/
├── /tmp (系统共享)
├── /mnt/usb (其他进程挂载的USB)
├── /home (所有用户目录)
└── /proc (系统进程信息)

私有挂载视图：
/
├── /tmp (服务私有)
├── /home (受限访问)
└── /proc (过滤后的进程信息)
注意：看不到/mnt/usb等其他挂载
```

**🎯 应用场景**：
- **Web服务器**：防止看到临时挂载的外部存储
- **数据库服务**：避免受到动态挂载的干扰
- **后台服务**：需要稳定文件系统环境的服务

### 2.2 PrivateIPC - 进程间通信隔离


**🔸 工作原理**：
`PrivateIPC`创建独立的**IPC命名空间**，服务无法与其他进程通过共享内存、信号量等方式通信。

```ini
# 配置IPC隔离
[Service]
PrivateIPC=yes

# 实际效果验证
ExecStart=/bin/bash -c 'ipcs -m; sleep 10'
```

**📊 IPC隔离对比**：
```
系统IPC资源：
$ ipcs -m
------ 共享内存段 ------
key        shmid    owner   perms   bytes
0x00000000 32768    mysql   666     16777216
0x00000000 65537    redis   666     8388608

隔离后的IPC视图：
$ systemd-run --property=PrivateIPC=yes ipcs -m
------ 共享内存段 ------
(空白 - 看不到其他进程的IPC资源)
```

### 2.3 PrivateUsers - 用户命名空间


**🔸 核心作用**：
`PrivateUsers`让服务运行在独立的用户空间中，即使以root身份运行，在容器外也没有root权限。

```ini
# 用户命名空间隔离
[Service]
PrivateUsers=yes
DynamicUser=yes    # 配合使用，创建临时用户

# 查看用户映射
ExecStart=/bin/bash -c 'id; cat /proc/self/uid_map'
```

**🔍 用户映射机制**：
```
容器内视图：          宿主机实际映射：
UID 0 (root)    →    UID 100000 (普通用户)
UID 1 (daemon)  →    UID 100001 (普通用户)
UID 65534 (nobody) → UID 165534 (普通用户)

关键理解：
- 容器内看起来是root，实际上是普通用户
- 无法操作宿主机的真正root权限文件
- 提供了权限隔离但保持了程序兼容性
```

### 2.4 完整的命名空间配置示例


```ini
[Unit]
Description=高度隔离的应用服务
After=network.target

[Service]
Type=simple
ExecStart=/opt/myapp/bin/server

# 命名空间隔离组合
PrivateMounts=yes        # 文件系统隔离
PrivateIPC=yes          # IPC隔离  
PrivateUsers=yes        # 用户空间隔离
PrivateNetwork=yes      # 网络隔离（可选）

# 配合其他安全选项
DynamicUser=yes         # 动态用户
NoNewPrivileges=yes     # 禁止提权

[Install]
WantedBy=multi-user.target
```

---

## 3. 🏠 根目录隔离机制


### 3.1 RootDirectory - 根目录重定向


**🔸 基本概念**：
`RootDirectory`让服务以指定目录作为根目录(`/`)运行，看不到真实系统的文件结构。

```ini
# 设置服务的根目录
[Service]
RootDirectory=/srv/myapp-root
ExecStart=/bin/server    # 这个路径相对于/srv/myapp-root

# 目录结构准备
# /srv/myapp-root/
# ├── bin/server          ← 实际的可执行文件
# ├── lib/               ← 必要的库文件
# ├── etc/config.conf    ← 配置文件
# └── tmp/               ← 临时目录
```

**💡 根目录隔离效果**：
```
服务视图中的文件系统：
/                     ← 实际指向 /srv/myapp-root
├── bin/server        ← 服务可执行文件
├── lib/             ← 运行时库
├── etc/config.conf  ← 配置文件
└── tmp/            ← 临时文件

无法看到：
- /etc/passwd (系统用户信息)
- /home/ (用户目录)  
- /usr/bin/ (系统命令)
- /var/log/ (系统日志)
```

### 3.2 RootImage - 镜像化根目录


**🔸 高级特性**：
`RootImage`直接使用文件系统镜像作为服务的根目录，类似Docker容器。

```ini
# 使用镜像文件作为根目录
[Service]
RootImage=/opt/images/myapp.img
RootImagePolicy=strict       # 镜像验证策略
ExecStart=/app/bin/server

# 镜像制作示例
# 1. 创建镜像文件
dd if=/dev/zero of=/opt/images/myapp.img bs=1M count=100
mkfs.ext4 /opt/images/myapp.img

# 2. 挂载并安装应用
mount /opt/images/myapp.img /mnt
# ... 在/mnt中安装应用和依赖
umount /mnt
```

**📊 RootDirectory vs RootImage对比**：

| 特性 | **RootDirectory** | **RootImage** |
|-----|------------------|---------------|
| **设置方式** | 指定目录路径 | 指定镜像文件 |
| **隔离程度** | 目录级隔离 | 文件系统级隔离 |
| **可移植性** | 依赖宿主机目录 | 自包含镜像 |
| **性能开销** | 低 | 中等（需要挂载） |
| **管理复杂度** | 简单 | 中等 |
| **适用场景** | 简单应用隔离 | 复杂环境封装 |

### 3.3 根目录隔离配置实例


```ini
[Unit]
Description=隔离的PHP应用
After=network.target

[Service]
Type=forking
# 根目录隔离
RootDirectory=/srv/php-app

# 在隔离环境中的启动命令
ExecStart=/usr/sbin/php-fpm
ExecReload=/bin/kill -USR2 $MAINPID

# 必要的绑定挂载
BindReadOnlyPaths=/etc/resolv.conf
BindPaths=/var/log/php-app:/var/log

# 用户权限
User=php-user
Group=php-user

[Install]
WantedBy=multi-user.target
```

---

## 4. 🔧 设备访问控制


### 4.1 PrivateDevices - 设备文件隔离


**🔸 核心作用**：
`PrivateDevices`阻止服务访问`/dev`目录下的设备文件，防止直接操作硬件设备。

```ini
# 启用设备隔离
[Service]
PrivateDevices=yes
```

**💡 设备隔离效果展示**：
```
正常系统的/dev目录：
/dev/
├── sda1, sda2      # 硬盘分区
├── tty0, tty1      # 终端设备  
├── random, urandom # 随机数设备
├── null, zero      # 特殊设备文件
├── input/          # 输入设备
└── sound/          # 音频设备

隔离后服务看到的/dev：
/dev/
├── null            # 仅保留基本设备
├── zero
├── full  
├── random
├── urandom
└── tty             # 最小必要集
```

**⚠️ 注意事项**：
- **保留基本设备**：`null`, `zero`, `random`等基本设备仍可访问
- **阻止硬件访问**：无法直接读写磁盘、网卡等硬件
- **兼容性考虑**：某些应用可能需要特定设备文件

### 4.2 DevicePolicy - 精细设备控制


**🔸 设备策略配置**：
`DevicePolicy`提供更细粒度的设备访问控制，可以允许特定设备的访问。

```ini
# 设备访问策略
[Service]
DevicePolicy=strict          # 严格模式：默认拒绝所有
DeviceAllow=/dev/null rw     # 允许读写null设备
DeviceAllow=/dev/random r    # 允许只读random设备
DeviceAllow=char-input r     # 允许读取输入设备类
```

**📋 DevicePolicy选项说明**：
```
auto (默认)：
- 自动允许标准设备访问
- 兼容性最好，安全性一般

strict (严格)：
- 默认拒绝所有设备访问
- 需要明确指定允许的设备
- 安全性最高

closed (封闭)：
- 禁止访问所有设备
- 最严格的限制
```

**🎯 设备类型表示法**：
```ini
# 具体设备文件
DeviceAllow=/dev/sda1 r      # 特定磁盘分区只读

# 设备类型
DeviceAllow=char-input r     # 字符输入设备类
DeviceAllow=block-* rw       # 所有块设备读写

# 主要设备号
DeviceAllow=1:1 rw           # 设备号1:1 (/dev/mem)
```

### 4.3 设备控制实际案例


```ini
[Unit]
Description=安全的日志分析服务
After=network.target

[Service]
Type=simple
ExecStart=/opt/loganalyzer/bin/analyzer

# 设备访问控制
DevicePolicy=strict
# 只允许必要的设备访问
DeviceAllow=/dev/null rw          # 空设备
DeviceAllow=/dev/urandom r        # 随机数生成
DeviceAllow=/dev/log w            # 系统日志socket

# 其他安全配置
PrivateDevices=no                 # 使用DevicePolicy时设为no
PrivateTmp=yes
ProtectSystem=strict

User=loganalyzer
Group=loganalyzer

[Install]
WantedBy=multi-user.target
```

---

## 5. 🛡️ 内核参数与系统保护


### 5.1 ProtectKernelModules - 内核模块保护


**🔸 基本概念**：
`ProtectKernelModules`防止服务**加载或卸载内核模块**，阻止恶意代码通过内核模块获取系统级权限。

```ini
# 保护内核模块
[Service]
ProtectKernelModules=yes
```

**💡 内核模块操作限制**：
```
被阻止的操作：
- insmod 命令加载模块    ✗
- rmmod 命令卸载模块     ✗
- modprobe 动态加载     ✗
- 直接系统调用操作模块   ✗

正常操作（不受影响）：
- 使用已加载的模块功能   ✓
- 读取模块信息         ✓
- 应用程序正常运行     ✓
```

### 5.2 ProtectKernelLogs - 内核日志保护


**🔸 日志安全隔离**：
`ProtectKernelLogs`阻止服务读取内核日志信息，防止敏感系统信息泄露。

```ini
# 保护内核日志
[Service]
ProtectKernelLogs=yes
```

**📊 日志访问对比**：
```
正常情况下可访问：
$ dmesg
[    0.000000] Linux version 5.4.0...
[    0.000000] Command line: root=UUID=...
[    1.234567] CPU: Physical Processor ID: 0

启用保护后：
$ dmesg
dmesg: read kernel buffer failed: Operation not permitted

受保护的日志源：
- /dev/kmsg        # 内核消息设备
- /proc/kmsg       # 内核消息接口
- dmesg命令输出     # 内核环形缓冲区
```

### 5.3 ProtectKernelTunables - 内核参数保护


**🔸 系统调优参数保护**：
`ProtectKernelTunables`防止服务修改内核运行时参数，保护系统配置稳定性。

```ini
# 保护内核参数
[Service]
ProtectKernelTunables=yes
```

**🔧 受保护的参数位置**：
```
/proc/sys/ 目录下的参数：
├── kernel/          # 内核参数
│   ├── hostname     # 主机名
│   ├── panic        # 内核崩溃行为
│   └── sysrq        # 系统请求键
├── vm/              # 虚拟内存参数
│   ├── swappiness   # 交换分区使用倾向
│   └── dirty_ratio  # 脏页刷新比例
└── net/             # 网络参数
    ├── ipv4/        # IPv4配置
    └── core/        # 网络核心参数

这些都无法被服务修改！
```

### 5.4 综合内核保护配置


```ini
[Unit]
Description=高安全级别的网络服务
After=network.target

[Service]
Type=notify
ExecStart=/usr/bin/secure-server
Restart=always
RestartSec=10

# 内核级别保护（强烈推荐组合）
ProtectKernelModules=yes     # 禁止模块操作
ProtectKernelLogs=yes        # 保护内核日志
ProtectKernelTunables=yes    # 保护内核参数
ProtectControlGroups=yes     # 保护cgroup设置

# 系统文件保护
ProtectSystem=strict         # 严格保护系统目录
ProtectHome=yes             # 保护用户目录

# 进程权限限制
NoNewPrivileges=yes         # 禁止权限提升
LockPersonality=yes         # 锁定进程个性设置

User=secure-server
Group=secure-server

[Install]
WantedBy=multi-user.target
```

---

## 6. ⏰ 时钟与实时性保护


### 6.1 ProtectClock - 系统时钟保护


**🔸 时钟安全重要性**：
`ProtectClock`防止服务修改**系统时钟**，这对于日志记录、证书验证、定时任务等都至关重要。

```ini
# 保护系统时钟
[Service]
ProtectClock=yes
```

**⏰ 时钟操作限制**：
```
被阻止的时钟操作：
- settimeofday() 系统调用    ✗
- clock_settime() 调用      ✗  
- date 命令修改时间         ✗
- hwclock 硬件时钟设置      ✗

允许的时钟操作：
- gettimeofday() 读取时间   ✓
- clock_gettime() 读取      ✓
- 时间相关的程序逻辑       ✓
```

**💡 为什么要保护时钟**：
```
时钟被恶意修改的后果：
1. 日志时间错乱 → 安全审计困难
2. SSL证书验证失败 → 服务中断
3. 定时任务混乱 → 系统功能异常
4. 数据库事务问题 → 数据一致性破坏
```

### 6.2 RestrictRealtime - 实时调度限制


**🔸 实时调度风险**：
`RestrictRealtime`限制服务获得**实时调度优先级**，防止恶意进程独占CPU资源。

```ini
# 限制实时调度
[Service]
RestrictRealtime=yes
```

**🎯 实时调度的影响**：
```
实时调度的危险：
高优先级进程 → 长时间占用CPU → 系统响应缓慢

实时调度示例：
┌─────────────────────────────┐
│ 实时进程 (优先级99)          │ ← 始终优先执行
├─────────────────────────────┤
│ 普通进程 (优先级20)          │ ← 等待执行
│ 系统服务 (优先级20)          │ ← 可能被阻塞
│ 用户应用 (优先级20)          │ ← 响应延迟
└─────────────────────────────┘

启用限制后：
所有进程都在普通调度范围内，避免系统锁死
```

### 6.3 时钟保护实际案例


```ini
[Unit]
Description=安全的数据库备份服务
After=network.target

[Service]
Type=oneshot
ExecStart=/opt/backup/bin/db-backup.sh

# 时钟与实时性保护
ProtectClock=yes            # 防止修改系统时间
RestrictRealtime=yes        # 限制实时调度权限

# 其他安全配置
PrivateTmp=yes              # 私有临时目录
ProtectSystem=strict        # 保护系统文件
NoNewPrivileges=yes         # 禁止提权

# 资源限制
CPUQuota=50%                # 限制CPU使用率
MemoryLimit=1G              # 限制内存使用

User=backup
Group=backup

[Install]
WantedBy=multi-user.target

# 配合timer使用
[Timer]
OnCalendar=daily
Persistent=yes
```

### 6.4 时钟同步服务的特殊考虑


**⚠️ 特殊情况处理**：
对于确实需要修改时钟的服务（如NTP客户端），需要特殊配置：

```ini
[Unit]
Description=网络时间同步客户端
After=network.target

[Service]
Type=forking
ExecStart=/usr/sbin/ntpd -g

# 时钟服务的特殊权限
ProtectClock=no             # 允许修改时钟
AmbientCapabilities=CAP_SYS_TIME  # 时间设置权限

# 其他限制保持
ProtectKernelModules=yes    
ProtectKernelLogs=yes
RestrictRealtime=yes

User=ntp
Group=ntp

[Install]
WantedBy=multi-user.target
```

---

## 7. 🔍 沙箱配置验证与测试


### 7.1 配置验证命令


**🔸 systemd-analyze检查**：
使用`systemd-analyze`工具验证服务的安全配置：

```bash
# 分析服务安全配置
systemd-analyze security myservice.service

# 输出示例：
#   EXPOSURE LEVEL: 6.2 (MEDIUM)
#   
#   ✓ PrivateDevices=             yes
#   ✓ ProtectKernelModules=       yes  
#   ✗ User=/DynamicUser=          no
#   ~ ProtectSystem=              yes (not strict)
```

**📊 安全评分理解**：
```
评分等级说明：
0.0 - 2.0  🟢 SAFE      (安全)
2.1 - 4.0  🟡 EXPOSED   (有风险)  
4.1 - 7.0  🟠 UNSAFE    (不安全)
7.1 - 10.0 🔴 DANGEROUS (危险)

改进建议：
- 启用更多安全选项
- 使用专用用户账户
- 严格限制文件系统访问
```

### 7.2 沙箱功能测试


**🧪 隔离效果验证脚本**：

```bash
#!/bin/bash
# sandbox-test.sh - 沙箱效果测试脚本

echo "=== 沙箱隔离测试 ==="

# 测试文件系统访问
echo "1. 测试系统文件访问："
ls -la /etc/shadow 2>/dev/null && echo "❌ 可访问敏感文件" || echo "✅ 无法访问敏感文件"

# 测试设备访问  
echo "2. 测试设备文件访问："
ls -la /dev/sda 2>/dev/null && echo "❌ 可访问块设备" || echo "✅ 无法访问块设备"

# 测试内核模块
echo "3. 测试内核模块操作："
lsmod > /dev/null 2>&1 && echo "✅ 可查看模块信息" || echo "❌ 无法查看模块"
modprobe dummy 2>/dev/null && echo "❌ 可加载模块" || echo "✅ 无法加载模块"

# 测试时钟修改
echo "4. 测试时钟修改："
date -s "2025-01-01" 2>/dev/null && echo "❌ 可修改时钟" || echo "✅ 无法修改时钟"

echo "=== 测试完成 ==="
```

**🔧 测试服务配置**：
```ini
[Unit]
Description=沙箱测试服务
After=network.target

[Service]
Type=oneshot
ExecStart=/opt/test/sandbox-test.sh
RemainAfterExit=no

# 完整沙箱配置
PrivateDevices=yes
PrivateTmp=yes
ProtectSystem=strict
ProtectHome=yes
ProtectKernelModules=yes
ProtectKernelLogs=yes
ProtectKernelTunables=yes
ProtectClock=yes
RestrictRealtime=yes
NoNewPrivileges=yes

User=test-user
Group=test-user

[Install]
WantedBy=multi-user.target
```

### 7.3 沙箱逃逸检测


**⚠️ 常见沙箱逃逸手段**：
```bash
# 检测脚本：escape-detection.sh

# 1. 检查/proc文件系统泄露
echo "检查进程信息泄露："
cat /proc/1/environ 2>/dev/null && echo "❌ 可读取init进程环境" || echo "✅ 进程信息受保护"

# 2. 检查符号链接逃逸
echo "检查符号链接逃逸："
readlink /proc/self/root 2>/dev/null | grep -v "^/$" && echo "❌ 检测到根目录逃逸" || echo "✅ 根目录正常"

# 3. 检查挂载信息泄露
echo "检查挂载信息："
cat /proc/mounts | grep -E "(home|root)" && echo "❌ 可见敏感挂载" || echo "✅ 挂载信息过滤"

# 4. 检查网络命名空间
echo "检查网络隔离："
ip addr show | grep -E "eth|wlan" && echo "❌ 可见物理网卡" || echo "✅ 网络已隔离"
```

### 7.4 性能影响评估


**📈 性能测试方法**：
```bash
# 性能对比测试脚本
#!/bin/bash

# 测试普通服务启动时间
echo "测试普通服务启动："
time systemctl start normal-service
time systemctl stop normal-service

# 测试沙箱服务启动时间  
echo "测试沙箱服务启动："
time systemctl start sandbox-service
time systemctl stop sandbox-service

# 内存使用对比
echo "内存使用对比："
systemd-cgtop -n 1 | grep -E "(normal|sandbox)-service"
```

**📊 典型性能数据**：
```
启动时间对比：
普通服务：    0.1s
沙箱服务：    0.3s (+200%)

内存开销：
基础开销：    +2-5MB
命名空间：    +1-3MB  
文件系统隔离： +5-10MB

CPU开销：
正常运行：    <1% 额外开销
启动阶段：    +10-20% 开销
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🎯 沙箱机制本质**：
- **隔离原理**：通过Linux内核特性限制服务能力
- **安全边界**：在服务和系统之间建立保护层
- **权限最小化**：只给服务最必要的权限
- **纵深防御**：多层安全机制组合使用

### 8.2 关键配置选项理解


**🔸 命名空间隔离**：
```
PrivateMounts=yes    → 独立文件系统视图
PrivateIPC=yes       → 隔离进程间通信
PrivateUsers=yes     → 用户权限映射
PrivateNetwork=yes   → 网络环境隔离
```

**🔸 系统保护**：
```
ProtectSystem=strict        → 系统目录只读
ProtectHome=yes            → 用户目录保护
ProtectKernelModules=yes   → 内核模块保护
ProtectClock=yes           → 系统时钟保护
```

**🔸 设备与权限**：
```
PrivateDevices=yes         → 设备文件隔离
DevicePolicy=strict        → 细粒度设备控制
NoNewPrivileges=yes        → 禁止权限提升
RestrictRealtime=yes       → 限制实时调度
```

### 8.3 实际应用策略


**📊 安全级别分层**：

| 服务类型 | **推荐安全级别** | **关键配置** |
|---------|----------------|-------------|
| **Web服务** | 高 | `PrivateDevices + ProtectSystem=strict` |
| **数据库** | 中高 | `PrivateTmp + ProtectKernelModules` |
| **系统服务** | 中 | `ProtectHome + RestrictRealtime` |
| **临时任务** | 高 | `PrivateUsers + PrivateMounts` |

**🎯 配置建议**：
```
基础安全配置（所有服务）：
✓ PrivateTmp=yes
✓ ProtectSystem=yes  
✓ NoNewPrivileges=yes

中等安全配置（网络服务）：
✓ 基础配置 +
✓ PrivateDevices=yes
✓ ProtectKernelModules=yes
✓ RestrictRealtime=yes

高安全配置（敏感服务）：  
✓ 中等配置 +
✓ PrivateUsers=yes
✓ ProtectClock=yes
✓ RootDirectory=/srv/app
```

### 8.4 故障排除要点


**🔧 常见问题处理**：
- **服务启动失败**：检查文件权限和路径映射
- **功能异常**：验证必要设备和文件的访问权限
- **性能下降**：评估沙箱开销，调整配置级别
- **兼容性问题**：渐进式启用安全选项，逐步测试

**⚠️ 安全与兼容性平衡**：
- 不是所有服务都需要最高安全级别
- 根据实际威胁模型选择合适的安全配置
- 在生产环境中充分测试沙箱配置
- 建立监控机制，及时发现配置问题

**💡 核心记忆**：
- systemd沙箱通过内核特性实现服务隔离
- 命名空间隔离是核心技术，限制服务视野
- 保护选项组合使用，实现纵深防御
- 配置验证和测试是确保安全性的关键步骤