---
title: 3、CPU资源控制与调度
---
## 📚 目录

1. [CPU资源控制基础概念](#1-CPU资源控制基础概念)
2. [cgroup CPU子系统详解](#2-cgroup-CPU子系统详解)
3. [CPU时间片分配机制](#3-CPU时间片分配机制)
4. [CPU配额与周期控制](#4-CPU配额与周期控制)
5. [CPU亲和性绑定管理](#5-CPU亲和性绑定管理)
6. [实时调度策略控制](#6-实时调度策略控制)
7. [CPU使用率监控统计](#7-CPU使用率监控统计)
8. [实践应用与故障排除](#8-实践应用与故障排除)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 CPU资源控制基础概念


### 1.1 什么是CPU资源控制


> **💡 核心理解**
> CPU资源控制就像给每个程序分配"CPU使用券"，确保重要程序能获得足够的计算时间，防止某个程序独占CPU影响其他程序运行。

**简单理解**：
```
生活类比：
就像食堂打饭 → 每个人都有排队号码和用餐时间限制
CPU控制 → 每个进程都有优先级和CPU时间限制

没有控制的情况：
进程A疯狂占用CPU → 其他进程卡死 → 系统响应慢

有控制的情况：  
进程A：最多用50%CPU → 进程B：保证25%CPU → 系统流畅
```

### 1.2 为什么需要CPU资源控制


**实际问题场景**：
```
🔴 问题1：CPU饥饿
某个程序bug导致死循环 → 占用100%CPU → 系统卡死

🔴 问题2：优先级混乱  
重要的数据库进程 → 得不到足够CPU → 用户访问超时

🔴 问题3：资源争抢
多个计算密集型任务同时运行 → 互相抢占 → 都运行很慢
```

**CPU控制解决方案**：
- **限制上限**：防止单个进程占用过多CPU
- **保证下限**：确保重要进程获得必要资源
- **公平调度**：合理分配CPU时间给各个进程

### 1.3 CPU资源控制的核心机制


```
Linux CPU控制层次结构：

内核调度器 (CFS/RT)
    ↓
cgroup CPU子系统
    ↓
进程/线程调度
    ↓
实际CPU执行

控制点：
• 调度策略：CFS(完全公平调度) / RT(实时调度)
• 时间分片：每个进程获得的CPU时间片长度
• 优先级：nice值、实时优先级
• 亲和性：绑定到特定CPU核心
```

---

## 2. ⚙️ cgroup CPU子系统详解


### 2.1 CPU子系统基本概念


**什么是CPU cgroup**：
```
cgroup CPU子系统 = CPU资源的"管理员"

作用：
• 限制：某个进程组最多能用多少CPU
• 分配：保证某个进程组至少能用多少CPU  
• 隔离：不同进程组之间CPU使用相互独立
```

**CPU子系统核心文件**：
```bash
# CPU子系统挂载点
/sys/fs/cgroup/cpu/

# 关键配置文件
cpu.shares          # CPU权重分配(相对值)
cpu.cfs_quota_us    # CPU配额时间(微秒)
cpu.cfs_period_us   # CPU调度周期(微秒)
cpu.stat            # CPU使用统计
tasks               # 受控制的进程列表
```

### 2.2 创建和管理CPU cgroup


**创建CPU控制组**：
```bash
# 1. 创建新的CPU控制组
sudo mkdir /sys/fs/cgroup/cpu/myapp
sudo mkdir /sys/fs/cgroup/cpu/database

# 2. 验证创建成功
ls -la /sys/fs/cgroup/cpu/myapp/
# 自动生成CPU相关控制文件
```

**基本管理操作**：
```bash
# 添加进程到控制组
echo $PID > /sys/fs/cgroup/cpu/myapp/tasks

# 查看控制组中的进程
cat /sys/fs/cgroup/cpu/myapp/tasks

# 删除空的控制组
sudo rmdir /sys/fs/cgroup/cpu/myapp
```

> **⚠️ 常见误区**
> 删除cgroup目录前必须确保tasks文件为空，否则会删除失败

### 2.3 CPU子系统继承机制


```
CPU控制组层次结构：

/sys/fs/cgroup/cpu/                    (根组)
├── system/                           (系统服务组)
│   ├── database.service/            (数据库服务)
│   └── webserver.service/           (Web服务器)
└── user/                           (用户进程组)
    ├── user-1000/                  (用户1000)
    └── user-1001/                  (用户1001)

继承规则：
• 子组继承父组的限制
• 子组的限制不能超过父组
• 兄弟组之间相互竞争父组资源
```

---

## 3. 📊 CPU时间片分配机制


### 3.1 cpu.shares权重分配原理


> **💡 核心理解**
> cpu.shares就像分蛋糕的"股份"，不是绝对数量，而是相对比例。拥有更多shares的进程组能获得更多CPU时间。

**shares权重工作原理**：
```
理解shares的关键：它是相对权重，不是绝对值！

示例场景：
GroupA: cpu.shares = 1024  (默认值)
GroupB: cpu.shares = 512   (一半权重)
GroupC: cpu.shares = 2048  (双倍权重)

当三组都需要CPU时的分配：
总权重 = 1024 + 512 + 2048 = 3584
GroupA获得 = 1024/3584 ≈ 28.6% CPU
GroupB获得 = 512/3584 ≈ 14.3% CPU  
GroupC获得 = 2048/3584 ≈ 57.1% CPU
```

### 3.2 配置CPU权重分配


**设置CPU权重**：
```bash
# 设置应用组获得默认权重
echo 1024 > /sys/fs/cgroup/cpu/myapp/cpu.shares

# 设置数据库组获得双倍权重
echo 2048 > /sys/fs/cgroup/cpu/database/cpu.shares

# 设置后台任务组获得较低权重
echo 512 > /sys/fs/cgroup/cpu/background/cpu.shares

# 验证设置
cat /sys/fs/cgroup/cpu/*/cpu.shares
```

**实际效果测试**：
```bash
# 创建CPU密集型测试程序
# 在不同组中运行相同的计算任务
stress --cpu 1 &  # 在myapp组中运行
PID1=$!
echo $PID1 > /sys/fs/cgroup/cpu/myapp/tasks

stress --cpu 1 &  # 在database组中运行  
PID2=$!
echo $PID2 > /sys/fs/cgroup/cpu/database/tasks

# 观察CPU分配效果
top -p $PID1,$PID2
# database组的进程应该获得约2倍的CPU时间
```

### 3.3 权重分配的动态特性


> **🔍 深入思考**
> shares只在CPU竞争时生效。如果只有一个组需要CPU，它可以使用100%CPU，不受shares限制。

**动态分配示例**：
```
场景1：只有GroupA在运行
GroupA实际获得：100% CPU (不受shares=1024限制)

场景2：GroupA和GroupB都在运行  
GroupA(shares=1024)：获得 1024/(1024+512) ≈ 67% CPU
GroupB(shares=512)：获得 512/(1024+512) ≈ 33% CPU

场景3：三组都在运行
按前面计算的比例分配：28.6% : 14.3% : 57.1%
```

---

## 4. ⏰ CPU配额与周期控制


### 4.1 CFS配额机制详解


> **💡 核心理解**
> CPU配额就像给每个进程组发放"CPU时间券"，在固定时间周期内只能使用规定的CPU时间，用完就必须等待下个周期。

**配额机制基本概念**：
```
CFS (Completely Fair Scheduler) 配额控制：

cpu.cfs_period_us：时间周期(微秒)，默认100000(0.1秒)
cpu.cfs_quota_us：配额时间(微秒)，在period内最多可用CPU时间

计算公式：
CPU使用率 = quota_us / period_us

示例：
period = 100000us (100毫秒)
quota = 50000us (50毫秒)  
→ 最多使用50%CPU
```

### 4.2 配置CPU配额限制


**基本配额设置**：
```bash
# 限制进程组最多使用50%CPU
echo 100000 > /sys/fs/cgroup/cpu/myapp/cpu.cfs_period_us
echo 50000 > /sys/fs/cgroup/cpu/myapp/cpu.cfs_quota_us

# 限制进程组最多使用25%CPU  
echo 100000 > /sys/fs/cgroup/cpu/background/cpu.cfs_period_us
echo 25000 > /sys/fs/cgroup/cpu/background/cpu.cfs_quota_us

# 取消配额限制(设为-1)
echo -1 > /sys/fs/cgroup/cpu/myapp/cpu.cfs_quota_us
```

**多核CPU配额设置**：
```bash
# 在4核CPU上，允许使用2个完整核心(200%CPU)
echo 100000 > /sys/fs/cgroup/cpu/compute/cpu.cfs_period_us  
echo 200000 > /sys/fs/cgroup/cpu/compute/cpu.cfs_quota_us

# 验证设置
cat /sys/fs/cgroup/cpu/compute/cpu.cfs_*
```

> **⚠️ 常见误区**
> 配额是硬限制，不管系统有多少空闲CPU，超过配额的进程必须等待下个周期

### 4.3 配额vs权重的区别


| 控制方式 | **作用机制** | **适用场景** | **优缺点** |
|---------|------------|-------------|-----------|
| **cpu.shares权重** | `相对分配，动态调整` | `公平竞争，负载均衡` | `✅ 灵活 ❌ 不精确` |
| **cpu.cfs_quota配额** | `绝对限制，硬约束` | `严格控制，SLA保证` | `✅ 精确 ❌ 可能浪费` |

**实际应用建议**：
```bash
# 组合使用示例：重要服务既要保证又要限制
# 1. 用shares保证至少获得足够资源
echo 2048 > /sys/fs/cgroup/cpu/important/cpu.shares

# 2. 用quota防止占用过多资源  
echo 100000 > /sys/fs/cgroup/cpu/important/cpu.cfs_period_us
echo 150000 > /sys/fs/cgroup/cpu/important/cpu.cfs_quota_us  # 最多150%CPU
```

---

## 5. 🎯 CPU亲和性绑定管理


### 5.1 cpuset子系统基础


**什么是CPU亲和性**：
```
CPU亲和性 = 指定进程只能在特定的CPU核心上运行

为什么需要CPU绑定：
• 缓存局部性：减少跨核心内存访问
• 性能隔离：避免不同类型任务相互干扰  
• 资源专用：为重要任务保留专用CPU核心
• NUMA优化：绑定到同一NUMA节点的CPU
```

**cpuset子系统文件**：
```bash
/sys/fs/cgroup/cpuset/
├── cpuset.cpus              # 可用的CPU核心列表
├── cpuset.mems              # 可用的内存节点列表  
├── cpuset.cpu_exclusive     # 是否独占CPU
├── cpuset.mem_exclusive     # 是否独占内存
└── tasks                    # 受控制的进程列表
```

### 5.2 配置CPU核心绑定


**查看系统CPU信息**：
```bash
# 查看CPU核心数量和编号
nproc                        # 显示CPU核心总数
cat /proc/cpuinfo | grep processor  # 显示所有CPU编号

# 查看NUMA拓扑结构
numactl --hardware
lscpu                       # 显示详细CPU架构信息
```

**创建CPU绑定控制组**：
```bash
# 1. 创建cpuset控制组
sudo mkdir /sys/fs/cgroup/cpuset/compute
sudo mkdir /sys/fs/cgroup/cpuset/realtime

# 2. 设置可用CPU核心(必须先设置cpus和mems)
# 绑定到CPU核心0,1
echo "0-1" > /sys/fs/cgroup/cpuset/compute/cpuset.cpus
echo "0" > /sys/fs/cgroup/cpuset/compute/cpuset.mems

# 绑定到CPU核心2,3  
echo "2-3" > /sys/fs/cgroup/cpuset/realtime/cpuset.cpus
echo "0" > /sys/fs/cgroup/cpuset/realtime/cpuset.mems
```

### 5.3 CPU亲和性实际应用


**应用场景配置**：
```bash
# 场景1：数据库服务器绑定到特定核心
# 将MySQL进程绑定到CPU 0-3
echo "0-3" > /sys/fs/cgroup/cpuset/database/cpuset.cpus
echo "0" > /sys/fs/cgroup/cpuset/database/cpuset.mems
systemctl show mysql | grep MainPID
echo $MYSQL_PID > /sys/fs/cgroup/cpuset/database/tasks

# 场景2：网络服务绑定到其他核心
# 将Nginx进程绑定到CPU 4-7
echo "4-7" > /sys/fs/cgroup/cpuset/webserver/cpuset.cpus  
echo "1" > /sys/fs/cgroup/cpuset/webserver/cpuset.mems
echo $NGINX_PID > /sys/fs/cgroup/cpuset/webserver/tasks
```

**CPU绑定语法规则**：
```bash
# CPU编号表示方法
echo "0"     > cpuset.cpus  # 只使用CPU0
echo "0,2"   > cpuset.cpus  # 使用CPU0和CPU2  
echo "0-3"   > cpuset.cpus  # 使用CPU0到CPU3
echo "0-1,4-5" > cpuset.cpus # 使用CPU0,1,4,5

# 验证绑定效果
cat /proc/$PID/status | grep Cpus_allowed_list
```

### 5.4 NUMA感知的CPU绑定


```
NUMA (Non-Uniform Memory Access) 架构示意：

Node 0                    Node 1
├── CPU 0-7              ├── CPU 8-15
├── Memory 0-31GB        ├── Memory 32-63GB
└── PCIe设备             └── 网卡设备

最佳实践：
进程 + CPU + 内存 绑定到同一NUMA节点
→ 减少跨节点内存访问延迟
→ 提高性能
```

**NUMA优化配置**：
```bash
# 查看NUMA拓扑
numactl --hardware

# 将进程绑定到NUMA节点0
echo "0-7" > /sys/fs/cgroup/cpuset/app/cpuset.cpus
echo "0" > /sys/fs/cgroup/cpuset/app/cpuset.mems

# 使用numactl工具启动程序
numactl --cpunodebind=0 --membind=0 ./my_application
```

---

## 6. ⚡ 实时调度策略控制


### 6.1 Linux调度策略类型


**调度策略分类**：
```
Linux进程调度策略：

普通调度策略：
• SCHED_NORMAL (CFS)：完全公平调度，默认策略
• SCHED_BATCH：批处理任务，低优先级
• SCHED_IDLE：空闲时运行，极低优先级

实时调度策略：  
• SCHED_FIFO：先进先出实时调度
• SCHED_RR：时间片轮转实时调度
• SCHED_DEADLINE：截止时间调度(较新)
```

> **💡 核心理解**
> 实时调度策略的进程优先级永远高于普通调度策略，可以抢占普通进程的CPU时间。

### 6.2 实时调度配置


**查看和设置调度策略**：
```bash
# 查看进程当前调度策略
chrt -p $PID

# 设置进程为FIFO实时调度，优先级50
chrt -f -p 50 $PID

# 设置进程为RR实时调度，优先级30  
chrt -r -p 30 $PID

# 以实时优先级启动程序
chrt -f 50 ./critical_application
```

**实时调度参数范围**：
```bash
# 查看实时优先级范围
chrt -m
# 通常显示：
# SCHED_FIFO优先级范围：1-99
# SCHED_RR优先级范围：1-99  
# 数字越大优先级越高
```

### 6.3 实时调度安全控制


> **⚠️ 常见误区**
> 实时调度策略可能导致系统无响应！必须配合CPU限制使用。

**安全配置实时调度**：
```bash
# 1. 创建实时任务控制组
mkdir /sys/fs/cgroup/cpu/realtime

# 2. 限制实时任务CPU使用率(防止系统卡死)
echo 100000 > /sys/fs/cgroup/cpu/realtime/cpu.cfs_period_us
echo 50000 > /sys/fs/cgroup/cpu/realtime/cpu.cfs_quota_us  # 最多50%

# 3. 将实时进程加入控制组
echo $RT_PID > /sys/fs/cgroup/cpu/realtime/tasks

# 4. 设置实时调度策略
chrt -f -p 80 $RT_PID
```

**系统实时调度限制**：
```bash
# 查看系统实时调度限制
cat /proc/sys/kernel/sched_rt_period_us    # 实时调度周期
cat /proc/sys/kernel/sched_rt_runtime_us   # 实时调度最大运行时间

# 调整系统级实时调度限制(谨慎操作)
echo 1000000 > /proc/sys/kernel/sched_rt_period_us    # 1秒周期
echo 950000 > /proc/sys/kernel/sched_rt_runtime_us    # 最多95%时间
```

---

## 7. 📈 CPU使用率监控统计


### 7.1 cgroup CPU统计信息


**读取CPU统计数据**：
```bash
# CPU使用统计文件
cat /sys/fs/cgroup/cpu/myapp/cpu.stat
# 输出示例：
nr_periods 1250          # 调度周期数
nr_throttled 340         # 被限制的周期数  
throttled_time 1580000000 # 被限制的总时间(纳秒)
```

**统计数据含义解释**：
```
nr_periods：经历的调度周期总数
nr_throttled：由于配额耗尽被限制的周期数
throttled_time：进程被限制等待的总时间

计算限制率：
throttled_rate = nr_throttled / nr_periods * 100%

示例：340/1250 = 27.2% 的时间周期中进程被限制
```

### 7.2 实时CPU使用率监控


**编写监控脚本**：
```bash
#!/bin/bash
# cpu_monitor.sh - CPU使用率监控脚本

CGROUP_PATH="/sys/fs/cgroup/cpu"
INTERVAL=5  # 监控间隔(秒)

monitor_cpu_usage() {
    local group_name=$1
    local group_path="$CGROUP_PATH/$group_name"
    
    while true; do
        # 读取统计数据
        local stat_file="$group_path/cpu.stat"
        if [[ -f "$stat_file" ]]; then
            local nr_periods=$(grep nr_periods "$stat_file" | awk '{print $2}')
            local nr_throttled=$(grep nr_throttled "$stat_file" | awk '{print $2}')
            local throttled_time=$(grep throttled_time "$stat_file" | awk '{print $2}')
            
            # 计算限制率
            if [[ $nr_periods -gt 0 ]]; then
                local throttle_rate=$(echo "scale=2; $nr_throttled * 100 / $nr_periods" | bc)
                echo "$(date): Group $group_name - Throttle Rate: ${throttle_rate}%"
            fi
        fi
        
        sleep $INTERVAL
    done
}

# 使用方法
monitor_cpu_usage "myapp"
```

### 7.3 系统级CPU监控


**使用系统工具监控**：
```bash
# 1. 使用top监控cgroup进程
top -p $(cat /sys/fs/cgroup/cpu/myapp/tasks | tr '\n' ',' | sed 's/,$//')

# 2. 使用systemd-cgtop监控控制组
systemd-cgtop

# 3. 使用cgstat监控(如果安装了cgroup-tools)
cgstat -r cpu

# 4. 自定义监控命令
watch -n 1 'cat /sys/fs/cgroup/cpu/*/cpu.stat'
```

**CPU性能分析**：
```bash
# 分析CPU调度延迟
perf sched record ./my_program
perf sched latency

# 分析CPU使用热点
perf record -g ./my_program  
perf report

# 实时查看进程CPU使用情况
pidstat -p $PID 1
```

---

## 8. 🛠️ 实践应用与故障排除


### 8.1 典型应用场景配置


**场景1：Web服务器优化**：
```bash
# 创建Web服务器控制组结构
mkdir -p /sys/fs/cgroup/cpu/webserver/{nginx,php-fpm,mysql}

# Nginx配置：保证响应速度，限制CPU使用
echo 2048 > /sys/fs/cgroup/cpu/webserver/nginx/cpu.shares
echo 100000 > /sys/fs/cgroup/cpu/webserver/nginx/cpu.cfs_period_us  
echo 80000 > /sys/fs/cgroup/cpu/webserver/nginx/cpu.cfs_quota_us    # 最多80%

# PHP-FPM配置：处理业务逻辑
echo 1024 > /sys/fs/cgroup/cpu/webserver/php-fpm/cpu.shares

# MySQL配置：数据库优先级最高  
echo 4096 > /sys/fs/cgroup/cpu/webserver/mysql/cpu.shares
```

**场景2：批处理任务管理**：
```bash  
# 创建批处理控制组
mkdir /sys/fs/cgroup/cpu/batch

# 低优先级，避免影响在线服务
echo 256 > /sys/fs/cgroup/cpu/batch/cpu.shares
echo 100000 > /sys/fs/cgroup/cpu/batch/cpu.cfs_period_us
echo 30000 > /sys/fs/cgroup/cpu/batch/cpu.cfs_quota_us     # 最多30%

# 设置批处理调度策略
echo $BATCH_PID > /sys/fs/cgroup/cpu/batch/tasks
chrt -b -p 0 $BATCH_PID  # SCHED_BATCH策略
```

### 8.2 常见问题排除


**问题1：进程无法加入控制组**：
```bash
# 检查问题
echo $PID > /sys/fs/cgroup/cpu/myapp/tasks
# 错误：写入失败

# 排查步骤
# 1. 检查进程是否存在
ps -p $PID

# 2. 检查权限
ls -la /sys/fs/cgroup/cpu/myapp/tasks

# 3. 检查控制组状态  
cat /sys/fs/cgroup/cpu/myapp/tasks

# 解决方法
sudo bash -c "echo $PID > /sys/fs/cgroup/cpu/myapp/tasks"
```

**问题2：CPU限制不生效**：
```bash
# 检查配置
cat /sys/fs/cgroup/cpu/myapp/cpu.cfs_quota_us
cat /sys/fs/cgroup/cpu/myapp/cpu.cfs_period_us

# 验证进程是否在控制组中
grep $PID /sys/fs/cgroup/cpu/myapp/tasks

# 检查是否被父组限制
cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us  # 父组配置

# 测试CPU使用率
stress --cpu 1 &
STRESS_PID=$!
echo $STRESS_PID > /sys/fs/cgroup/cpu/myapp/tasks
top -p $STRESS_PID  # 观察CPU使用率
```

### 8.3 性能调优建议


**调优检查清单**：
```bash
# ✅ 1. 验证CPU控制配置
cat /sys/fs/cgroup/cpu/*/cpu.{shares,cfs_*}

# ✅ 2. 检查进程分布
for group in /sys/fs/cgroup/cpu/*/; do
    echo "Group: $group"
    cat "$group/tasks" | wc -l
done

# ✅ 3. 监控限制效果  
watch -n 1 'grep throttled /sys/fs/cgroup/cpu/*/cpu.stat'

# ✅ 4. 分析系统负载
uptime && cat /proc/loadavg

# ✅ 5. 检查上下文切换
vmstat 1 5 | grep cs  # context switches per second
```

> **🔍 深入思考**
> CPU控制的目标是平衡性能和公平性，不是越严格越好。要根据实际业务需求调整参数。

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🎯 CPU资源控制本质：通过cgroup限制和分配进程CPU使用时间
🎯 两种控制方式：shares(相对权重) vs quota(绝对限制)  
🎯 CPU亲和性：绑定进程到特定CPU核心，优化性能
🎯 实时调度：高优先级调度策略，需要谨慎使用
🎯 监控统计：通过cpu.stat文件监控控制效果
```

### 9.2 关键配置参数


| 参数 | **作用** | **取值范围** | **使用建议** |
|------|---------|-------------|-------------|
| **cpu.shares** | `相对权重分配` | `2-262144，默认1024` | `用于公平调度` |
| **cpu.cfs_quota_us** | `CPU时间配额` | `-1或正整数(微秒)` | `硬限制场景` |
| **cpu.cfs_period_us** | `调度周期` | `1000-1000000，默认100000` | `通常保持默认` |
| **cpuset.cpus** | `可用CPU核心` | `CPU编号列表` | `性能敏感应用` |

### 9.3 实际应用指导


**🔹 选择合适的控制方式**：
```
使用shares的场景：
• 多个应用公平竞争CPU资源
• 负载变化较大的环境  
• 希望充分利用CPU资源

使用quota的场景：
• 需要严格控制CPU使用率
• 防止单个应用影响其他服务
• SLA保证和合规要求
```

**🔹 避免常见误区**：
```
❌ 错误：随意设置实时调度策略
✅ 正确：实时调度必须配合CPU限制

❌ 错误：quota设置过于严格导致性能下降  
✅ 正确：根据实际负载合理设置quota

❌ 错误：忽略NUMA拓扑结构
✅ 正确：CPU绑定考虑内存访问局部性
```

### 9.4 监控和运维要点


**📊 关键监控指标**：
- **CPU使用率**：各控制组的实际CPU占用
- **限制率**：nr_throttled/nr_periods，反映限制效果  
- **等待时间**：throttled_time，衡量性能影响
- **负载均衡**：各CPU核心使用是否均匀

**🛠️ 运维最佳实践**：
```bash
# 1. 建立监控脚本
#!/bin/bash  
echo "CPU控制组状态检查："
for group in /sys/fs/cgroup/cpu/*/; do
    if [[ -f "$group/tasks" ]] && [[ -s "$group/tasks" ]]; then
        echo "组: $(basename $group)"
        echo "  进程数: $(cat $group/tasks | wc -l)"  
        echo "  配额: $(cat $group/cpu.cfs_quota_us 2>/dev/null || echo 'unlimited')"
        echo "  权重: $(cat $group/cpu.shares)"
    fi
done

# 2. 设置告警阈值
# 当限制率超过80%时告警，可能需要调整配额

# 3. 定期优化
# 根据监控数据调整shares和quota参数
```

**核心记忆口诀**：
- CPU控制两法宝：shares分权重，quota设上限
- 实时调度需谨慎：高优先级配限制  
- 亲和绑定看场景：性能优化考虑NUMA
- 监控统计要及时：throttled反映限制效果