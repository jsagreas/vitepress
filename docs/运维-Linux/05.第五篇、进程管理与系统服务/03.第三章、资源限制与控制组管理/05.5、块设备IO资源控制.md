---
title: 5、块设备IO资源控制
---
## 📚 目录

1. [blkio子系统基础概念](#1-blkio子系统基础概念)
2. [IO带宽限制设置](#2-io带宽限制设置)
3. [IOPS限制配置](#3-iops限制配置)
4. [设备权重分配](#4-设备权重分配)
5. [IO优先级控制](#5-io优先级控制)
6. [块设备IO统计](#6-块设备IO统计)
7. [IO调度器配合使用](#7-io调度器配合使用)
8. [存储性能监控](#8-存储性能监控)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 blkio子系统基础概念


### 1.1 什么是blkio子系统


**🔸 通俗理解**
```
想象一个图书馆：
- 很多人同时借书（多个进程访问磁盘）
- 只有几个借书窗口（有限的磁盘IO能力）
- 需要排队规则（IO调度和限制）

blkio子系统就是这个"图书馆管理员"：
• 控制谁能借多少书（IO带宽限制）
• 决定排队的优先级（IO权重）
• 统计借书情况（IO使用统计）
```

**核心功能**：
- **带宽控制**：限制进程的读写速度
- **IOPS限制**：控制每秒IO操作次数
- **权重分配**：不同进程的IO优先级
- **性能统计**：监控IO使用情况

### 1.2 blkio与其他cgroup的关系


```
系统资源控制体系：
┌─────────────────────────────┐
│         cgroup              │
├─────────────────────────────┤
│ cpu    │ memory  │ blkio   │ ← 三大核心子系统
├─────────────────────────────┤
│ 计算    │ 内存     │ 存储    │
└─────────────────────────────┘

协同工作：
• CPU密集型任务 → cpu子系统控制
• 内存大户应用 → memory子系统限制  
• IO频繁程序 → blkio子系统管理
```

### 1.3 支持的存储设备类型


**📋 设备支持范围**：
```
✅ 支持的设备：
• 传统硬盘（HDD）
• 固态硬盘（SSD）  
• RAID设备
• LVM逻辑卷
• 网络存储（NFS、iSCSI等）

❌ 不支持的场景：
• 内存文件系统（tmpfs）
• proc、sys等虚拟文件系统
• 部分网络文件系统
```

---

## 2. ⚡ IO带宽限制设置


### 2.1 什么是IO带宽限制


**💡 概念解释**
```
带宽就是"数据传输的宽度"：
类比高速公路：
• 单车道：同时只能过1辆车（带宽小）
• 8车道：同时能过8辆车（带宽大）

IO带宽限制：
• 读带宽：每秒最多读取多少数据
• 写带宽：每秒最多写入多少数据
• 单位：MB/s、KB/s等
```

### 2.2 带宽限制配置方法


**🔧 基础配置步骤**
```bash
# 1. 创建blkio控制组
mkdir /sys/fs/cgroup/blkio/myapp

# 2. 设置读带宽限制（每秒最多读10MB）
echo "8:0 10485760" > /sys/fs/cgroup/blkio/myapp/blkio.throttle.read_bps_device

# 3. 设置写带宽限制（每秒最多写5MB）  
echo "8:0 5242880" > /sys/fs/cgroup/blkio/myapp/blkio.throttle.write_bps_device

# 4. 将进程加入控制组
echo $PID > /sys/fs/cgroup/blkio/myapp/cgroup.procs
```

**📊 参数说明**
```
格式："设备号 限制值"

设备号获取方法：
ls -l /dev/sda
brw-rw---- 1 root disk 8, 0 Sep 14 10:30 /dev/sda
               ↑  ↑
            主设备号 次设备号 → 8:0

限制值单位：
• 字节/秒：1048576 = 1MB/s
• 计算公式：MB * 1024 * 1024
```

### 2.3 实际应用示例


**🎯 场景：限制数据库备份IO**
```bash
#!/bin/bash
# 创建数据库备份专用控制组

# 1. 创建控制组
mkdir -p /sys/fs/cgroup/blkio/db_backup

# 2. 限制读写带宽（避免影响正常业务）
# 读限制：20MB/s，写限制：10MB/s
DEVICE="8:0"  # /dev/sda
READ_LIMIT=$((20 * 1024 * 1024))   # 20MB
WRITE_LIMIT=$((10 * 1024 * 1024))  # 10MB

echo "$DEVICE $READ_LIMIT" > /sys/fs/cgroup/blkio/db_backup/blkio.throttle.read_bps_device
echo "$DEVICE $WRITE_LIMIT" > /sys/fs/cgroup/blkio/db_backup/blkio.throttle.write_bps_device

# 3. 执行备份（自动受到限制）
echo $$ > /sys/fs/cgroup/blkio/db_backup/cgroup.procs
mysqldump -u root -p mydb > /backup/mydb.sql
```

**⚠️ 实用技巧**
```
多设备环境：
# 对多个磁盘分别设置限制
echo "8:0 10485760" > blkio.throttle.read_bps_device   # sda
echo "8:16 20971520" > blkio.throttle.read_bps_device  # sdb

动态调整：
# 运行时修改限制值
echo "8:0 20971520" > blkio.throttle.read_bps_device  # 调整为20MB/s
```

---

## 3. 🎛️ IOPS限制配置


### 3.1 IOPS概念理解


**💡 什么是IOPS**
```
IOPS = Input/Output Operations Per Second（每秒IO操作数）

生活类比：
银行柜台服务：
• 带宽 = 每次服务处理的金额大小
• IOPS = 每秒服务多少个客户

技术对比：
┌──────────────────────────┐
│ 带宽控制  vs  IOPS控制   │
├──────────────────────────┤
│ 数据量大小 vs 操作频率    │
│ MB/s单位  vs 次/s单位    │
│ 大文件读写 vs 小文件频繁  │
└──────────────────────────┘
```

### 3.2 IOPS限制配置


**🔧 配置方法**
```bash
# 1. 创建控制组
mkdir /sys/fs/cgroup/blkio/iops_limit

# 2. 设置读IOPS限制（每秒最多1000次读操作）
echo "8:0 1000" > /sys/fs/cgroup/blkio/iops_limit/blkio.throttle.read_iops_device

# 3. 设置写IOPS限制（每秒最多500次写操作）
echo "8:0 500" > /sys/fs/cgroup/blkio/iops_limit/blkio.throttle.write_iops_device

# 4. 应用到进程
echo $PID > /sys/fs/cgroup/blkio/iops_limit/cgroup.procs
```

### 3.3 带宽与IOPS协同使用


**🔗 组合限制策略**
```bash
#!/bin/bash
# 综合限制示例：既限制带宽又限制IOPS

CGROUP_PATH="/sys/fs/cgroup/blkio/web_server"
mkdir -p $CGROUP_PATH

DEVICE="8:0"
# 带宽限制：读50MB/s，写30MB/s  
echo "$DEVICE 52428800" > $CGROUP_PATH/blkio.throttle.read_bps_device
echo "$DEVICE 31457280" > $CGROUP_PATH/blkio.throttle.write_bps_device

# IOPS限制：读2000次/s，写1500次/s
echo "$DEVICE 2000" > $CGROUP_PATH/blkio.throttle.read_iops_device  
echo "$DEVICE 1500" > $CGROUP_PATH/blkio.throttle.write_iops_device
```

**📊 效果对比表**

| **限制类型** | **适用场景** | **效果** | **配置难度** |
|-------------|-------------|-----------|-------------|
| 仅带宽限制 | `大文件传输` | `控制总流量` | `简单` |
| 仅IOPS限制 | `小文件频繁访问` | `控制操作频率` | `简单` |
| 组合限制 | `复杂应用环境` | `精细化控制` | `中等` |

---

## 4. ⚖️ 设备权重分配


### 4.1 权重控制原理


**💡 权重概念解释**
```
权重就像"排队的VIP等级"：
普通客户：权重100
VIP客户：权重500  
SVIP客户：权重1000

当资源紧张时：
• 高权重进程优先获得IO资源
• 低权重进程需要等待
• 权重比例决定资源分配比例
```

**🔸 权重 vs 限制的区别**
```
硬限制（throttle）：
"绝对不能超过这个值"
适用：严格控制，防止影响其他服务

软控制（weight）：  
"优先级高的多分配一些"
适用：弹性分配，充分利用资源
```

### 4.2 权重配置方法


**🔧 基础权重设置**
```bash
# 1. 高优先级应用（数据库）
mkdir /sys/fs/cgroup/blkio/database
echo 1000 > /sys/fs/cgroup/blkio/database/blkio.weight

# 2. 中等优先级应用（Web服务）  
mkdir /sys/fs/cgroup/blkio/webserver
echo 500 > /sys/fs/cgroup/blkio/webserver/blkio.weight

# 3. 低优先级应用（日志处理）
mkdir /sys/fs/cgroup/blkio/logprocess  
echo 100 > /sys/fs/cgroup/blkio/logprocess/blkio.weight
```

**📈 权重分配效果**
```
当IO资源争用时的分配比例：
数据库 : Web服务 : 日志处理 = 1000 : 500 : 100 = 10 : 5 : 1

实际意义：
• 数据库获得约62.5%的IO资源
• Web服务获得约31.2%的IO资源  
• 日志处理获得约6.3%的IO资源
```

### 4.3 设备级权重控制


**🎯 针对不同设备设置权重**
```bash
# 为特定设备设置权重
CGROUP_PATH="/sys/fs/cgroup/blkio/myapp"

# SSD设备（8:0）设置高权重
echo "8:0 800" > $CGROUP_PATH/blkio.weight_device

# HDD设备（8:16）设置低权重  
echo "8:16 200" > $CGROUP_PATH/blkio.weight_device
```

---

## 5. 🚦 IO优先级控制


### 5.1 IO优先级类别


**📊 Linux IO优先级体系**
```
IO优先级分类：
┌─────────────────────────────┐
│ Class 1: RT (Real-time)     │ ← 实时IO，最高优先级
├─────────────────────────────┤  
│ Class 2: BE (Best-effort)   │ ← 普通IO，默认类别
├─────────────────────────────┤
│ Class 3: IDLE               │ ← 空闲IO，最低优先级  
└─────────────────────────────┘

每个类别内部还有0-7的子级别：
• 0 = 最高优先级
• 7 = 最低优先级
```

### 5.2 ionice工具使用


**🔧 ionice命令详解**
```bash
# 查看进程IO优先级
ionice -p $PID

# 设置实时IO优先级
ionice -c 1 -n 0 -p $PID  # 最高实时优先级

# 设置普通IO优先级  
ionice -c 2 -n 4 -p $PID  # 中等优先级

# 设置空闲IO优先级
ionice -c 3 -p $PID       # 只在空闲时执行IO

# 启动程序时指定优先级
ionice -c 2 -n 1 rsync -av /source/ /dest/
```

### 5.3 结合blkio使用


**⚡ 综合优化策略**
```bash
#!/bin/bash
# 创建不同优先级的服务组

# 1. 关键业务组（高优先级 + 高权重）
mkdir -p /sys/fs/cgroup/blkio/critical
echo 1000 > /sys/fs/cgroup/blkio/critical/blkio.weight

# 2. 普通业务组（中等配置）
mkdir -p /sys/fs/cgroup/blkio/normal  
echo 500 > /sys/fs/cgroup/blkio/normal/blkio.weight

# 3. 后台任务组（低优先级 + 低权重 + 带宽限制）
mkdir -p /sys/fs/cgroup/blkio/background
echo 100 > /sys/fs/cgroup/blkio/background/blkio.weight
echo "8:0 10485760" > /sys/fs/cgroup/blkio/background/blkio.throttle.read_bps_device

# 启动不同服务
start_critical_service() {
    echo $$ > /sys/fs/cgroup/blkio/critical/cgroup.procs
    ionice -c 1 -n 0 your_critical_app
}

start_background_task() {
    echo $$ > /sys/fs/cgroup/blkio/background/cgroup.procs  
    ionice -c 3 your_background_task
}
```

---

## 6. 📊 块设备IO统计


### 6.1 统计信息类型


**📋 blkio统计文件说明**
```
主要统计文件：
/sys/fs/cgroup/blkio/myapp/
├── blkio.sectors              # 扇区读写统计
├── blkio.io_service_bytes     # 字节数统计  
├── blkio.io_serviced          # IO操作次数统计
├── blkio.time                 # IO时间统计
└── blkio.io_wait_time         # IO等待时间统计
```

### 6.2 读取统计信息


**🔍 查看IO使用情况**
```bash
# 查看字节级统计
cat /sys/fs/cgroup/blkio/myapp/blkio.io_service_bytes
# 输出格式：设备 操作类型 字节数
# 8:0 Read 1048576000
# 8:0 Write 524288000

# 查看操作次数统计  
cat /sys/fs/cgroup/blkio/myapp/blkio.io_serviced
# 输出格式：设备 操作类型 次数
# 8:0 Read 1000
# 8:0 Write 500

# 查看IO耗时统计
cat /sys/fs/cgroup/blkio/myapp/blkio.time
# 8:0 5000  # 毫秒
```

### 6.3 统计信息分析脚本


**📊 IO监控脚本**
```bash
#!/bin/bash
# IO统计分析脚本

CGROUP_PATH="/sys/fs/cgroup/blkio"
APP_NAME="myapp"

monitor_io() {
    local app_path="$CGROUP_PATH/$APP_NAME"
    
    echo "=== IO统计报告 ==="
    echo "时间：$(date)"
    echo "应用：$APP_NAME"
    echo ""
    
    # 读取字节统计
    echo "📖 数据传输统计："
    while read device op bytes; do
        if [[ "$device" =~ ^[0-9]+:[0-9]+$ ]]; then
            mb=$(( bytes / 1024 / 1024 ))
            printf "  %s %s: %d MB\n" "$device" "$op" "$mb"
        fi
    done < "$app_path/blkio.io_service_bytes"
    
    echo ""
    
    # 读取操作次数
    echo "🔢 操作次数统计："
    while read device op count; do
        if [[ "$device" =~ ^[0-9]+:[0-9]+$ ]]; then
            printf "  %s %s: %d 次\n" "$device" "$op" "$count"
        fi
    done < "$app_path/blkio.io_serviced"
}

# 持续监控
while true; do
    clear
    monitor_io
    sleep 5
done
```

---

## 7. 🔄 IO调度器配合使用


### 7.1 IO调度器类型


**📋 常见IO调度器对比**

| **调度器** | **特点** | **适用场景** | **与blkio配合** |
|-----------|----------|-------------|----------------|
| `CFQ` | `公平队列` | `桌面环境` | `✅ 权重控制效果好` |
| `Deadline` | `截止时间` | `数据库服务` | `⚡ 延迟敏感应用` |
| `NOOP` | `先进先出` | `SSD设备` | `🔧 简单高效` |
| `BFQ` | `预算公平` | `交互应用` | `🎯 响应性优先` |

### 7.2 调度器配置


**🔧 查看和修改调度器**
```bash
# 查看当前调度器
cat /sys/block/sda/queue/scheduler
# [mq-deadline] kyber bfq none

# 修改调度器（临时）
echo cfq > /sys/block/sda/queue/scheduler

# 永久修改（通过启动参数）
# 在/etc/default/grub中添加：
# GRUB_CMDLINE_LINUX="elevator=cfq"
```

### 7.3 优化组合策略


**⚡ 不同场景的最佳配置**
```bash
# 场景1：数据库服务器
# 使用deadline调度器 + 权重控制
echo deadline > /sys/block/sda/queue/scheduler
echo 1000 > /sys/fs/cgroup/blkio/database/blkio.weight

# 场景2：文件服务器  
# 使用cfq调度器 + 带宽限制
echo cfq > /sys/block/sda/queue/scheduler
echo "8:0 104857600" > /sys/fs/cgroup/blkio/fileserver/blkio.throttle.read_bps_device

# 场景3：SSD存储
# 使用noop调度器 + IOPS控制
echo noop > /sys/block/sda/queue/scheduler  
echo "8:0 2000" > /sys/fs/cgroup/blkio/webapp/blkio.throttle.read_iops_device
```

---

## 8. 📈 存储性能监控


### 8.1 监控工具概览


**🛠️ 监控工具对比**
```
系统级监控：
• iostat：磁盘IO统计
• iotop：进程IO排行
• blktrace：IO事件跟踪

cgroup级监控：
• blkio统计文件：cgroup内部统计  
• cgroupstop：cgroup IO监控
• systemd-cgtop：systemd cgroup监控
```

### 8.2 iostat监控


**📊 iostat详细使用**
```bash
# 基础IO统计（每2秒刷新）
iostat -x 2

# 输出解读：
Device    r/s   w/s   rkB/s   wkB/s  %util
sda      50.0  25.0  2048.0  1024.0   45.2

参数含义：
• r/s: 每秒读操作次数
• w/s: 每秒写操作次数  
• rkB/s: 每秒读KB数
• wkB/s: 每秒写KB数
• %util: 设备使用率
```

### 8.3 综合监控脚本


**🔍 完整性能监控**
```bash
#!/bin/bash
# 存储性能综合监控脚本

CGROUP_BASE="/sys/fs/cgroup/blkio"
LOG_FILE="/var/log/io_monitor.log"

# 监控函数
monitor_performance() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] === 存储性能报告 ===" | tee -a $LOG_FILE
    
    # 1. 系统整体IO状况
    echo "📊 系统整体IO：" | tee -a $LOG_FILE
    iostat -x 1 1 | tail -n +4 | head -n -1 | tee -a $LOG_FILE
    
    # 2. cgroup IO统计
    echo "🏷️ cgroup IO统计：" | tee -a $LOG_FILE
    for cgroup in $(find $CGROUP_BASE -maxdepth 1 -type d -name "*" | grep -v "^$CGROUP_BASE$"); do
        local name=$(basename $cgroup)
        echo "  [$name]" | tee -a $LOG_FILE
        
        if [[ -f "$cgroup/blkio.io_service_bytes" ]]; then
            local read_bytes=$(grep "8:0 Read" $cgroup/blkio.io_service_bytes | awk '{print $3}' 2>/dev/null || echo "0")
            local write_bytes=$(grep "8:0 Write" $cgroup/blkio.io_service_bytes | awk '{print $3}' 2>/dev/null || echo "0")
            
            local read_mb=$((read_bytes / 1024 / 1024))
            local write_mb=$((write_bytes / 1024 / 1024))
            
            echo "    读取: ${read_mb}MB, 写入: ${write_mb}MB" | tee -a $LOG_FILE
        fi
    done
    
    # 3. 设备使用率检查
    echo "⚠️ 高负载设备：" | tee -a $LOG_FILE
    iostat -x 1 1 | awk 'NR>3 && $NF>80 {print "  " $1 " 使用率: " $NF "%"}' | tee -a $LOG_FILE
    
    echo "" | tee -a $LOG_FILE
}

# 主循环
while true; do
    monitor_performance
    sleep 30
done
```

### 8.4 告警配置


**🚨 性能告警设置**
```bash
#!/bin/bash
# IO性能告警脚本

check_io_health() {
    # 检查设备使用率
    local high_util=$(iostat -x 1 1 | awk 'NR>3 && $NF>90 {print $1 ":" $NF}')
    
    if [[ -n "$high_util" ]]; then
        echo "🔥 警告：设备IO使用率过高"
        echo "$high_util"
        # 发送邮件或其他通知
        # mail -s "IO Alert" admin@company.com <<< "IO使用率告警: $high_util"
    fi
    
    # 检查cgroup是否超出预期
    for cgroup in /sys/fs/cgroup/blkio/*/; do
        local name=$(basename $cgroup)
        local read_bps=$(grep "8:0 Read" $cgroup/blkio.io_service_bytes 2>/dev/null | awk '{print $3}' || echo "0")
        
        # 如果读取超过100MB，发出警告
        if (( read_bps > 104857600 )); then
            echo "⚠️ 警告：$name cgroup IO过高: $((read_bps/1024/1024))MB"
        fi
    done
}

# 每分钟检查一次
while true; do
    check_io_health
    sleep 60
done
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 blkio子系统：Linux中控制块设备IO资源的cgroup子系统
🔸 带宽限制：控制每秒传输的数据量（MB/s）
🔸 IOPS限制：控制每秒IO操作的次数（次/s）
🔸 权重分配：不同进程的IO资源分配比例
🔸 IO统计：监控和分析IO使用情况的数据
```

### 9.2 关键理解要点


**🔹 限制类型的选择**
```
硬限制（throttle）场景：
• 需要严格控制，防止影响其他服务
• 备份、日志等后台任务
• 多租户环境的资源隔离

权重控制（weight）场景：  
• 希望弹性分配资源
• 根据业务重要性设置优先级
• 充分利用系统IO能力
```

**🔹 带宽 vs IOPS的区别**
```
选择原则：
• 大文件操作：主要关注带宽限制
• 小文件频繁：主要关注IOPS限制  
• 复杂应用：两者结合使用
• 数据库应用：IOPS更重要
• 文件传输：带宽更关键
```

### 9.3 实际应用价值


**🎯 典型应用场景**
- **数据库服务**：高权重 + IOPS控制，保证响应速度
- **备份任务**：低权重 + 带宽限制，避免影响业务
- **Web服务**：中等权重 + 综合限制，平衡性能和稳定性
- **多租户系统**：按用户级别设置不同的IO资源配额

**🔧 运维最佳实践**
```
配置建议：
1. 先了解应用IO特性（大小文件、读写比例）
2. 根据业务重要性设置权重
3. 为关键服务预留足够IO资源
4. 建立监控和告警机制
5. 定期分析统计数据优化配置

常见误区：
❌ 过度限制导致性能下降
❌ 忽略不同设备的特性
❌ 缺乏监控无法发现问题
✅ 渐进式调整，持续优化
```

**核心记忆要点**：
- blkio子系统是Linux IO资源控制的核心工具
- 带宽控制数据量，IOPS控制操作频率
- 权重实现弹性分配，限制实现硬性约束
- 配合IO调度器使用效果更佳
- 监控统计是优化配置的重要依据