---
title: 2、cgroups控制组原理与架构
---
## 📚 目录

1. [cgroups基础概念](#1-cgroups基础概念)
2. [cgroups层次结构原理](#2-cgroups层次结构原理)
3. [cgroups v1与v2架构对比](#3-cgroups-v1与v2架构对比)
4. [控制组子系统详解](#4-控制组子系统详解)
5. [文件系统结构深入](#5-文件系统结构深入)
6. [控制组操作实践](#6-控制组操作实践)
7. [cgroups与systemd集成](#7-cgroups与systemd集成)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 cgroups基础概念


### 1.1 什么是cgroups


**🔤 cgroups全称**：Control Groups（控制组）

**💡 简单理解**：
```
就像给进程划分"管理区域"，每个区域有自己的资源配额
类似于：公司部门管理 → 每个部门有自己的预算限制
```

**🎯 核心作用**：
- **资源限制**：限制进程使用的CPU、内存、磁盘等资源
- **优先级控制**：设定进程的资源使用优先级
- **资源统计**：监控进程的资源使用情况
- **进程隔离**：将进程分组管理，互不影响

### 1.2 cgroups解决的核心问题


**❗ 传统问题**：
```
问题场景：
- 某个程序占用过多CPU，导致整个系统卡顿
- 内存泄漏程序耗尽系统内存
- 多个服务抢占资源，互相影响性能

解决前：系统资源无序竞争，"能者多得"
解决后：按需分配，公平使用，可控管理
```

**✅ cgroups的解决方案**：

| 问题类型 | 传统方式 | cgroups方式 |
|---------|---------|------------|
| **CPU抢占** | 进程自由竞争 | 设置CPU配额限制 |
| **内存占用** | 依赖程序自律 | 强制内存使用上限 |
| **资源监控** | 事后查看top | 实时精确统计 |
| **服务隔离** | 手动nice调整 | 自动分组隔离 |

### 1.3 cgroups的基本特性


**🔸 层次化管理**：
```
系统根组
├── 数据库服务组     (限制内存4GB，CPU 50%)
├── Web服务组        (限制内存2GB，CPU 30%)  
└── 系统服务组       (限制内存1GB，CPU 20%)
```

**🔸 继承性**：子组继承父组的限制，但可以设置更严格的限制

**🔸 动态调整**：运行时可以修改资源限制，无需重启进程

---

## 2. 🏗️ cgroups层次结构原理


### 2.1 层次结构基本概念


**🌳 层次结构就像公司组织架构**：
```
总公司 (root cgroup)
├── 技术部门 (tech cgroup)
│   ├── 开发组 (dev cgroup)      ← 可以进一步细分
│   └── 测试组 (test cgroup)
├── 运营部门 (ops cgroup)
└── 财务部门 (finance cgroup)

每个层级都可以设置资源限制
子部门的资源不能超过父部门的配额
```

### 2.2 层次结构的核心规则


**🔹 规则1：资源继承**
```
父组资源限制：CPU 100%，内存 8GB
子组最大可用：CPU ≤ 100%，内存 ≤ 8GB

实际分配示例：
父组: CPU 80%, 内存 6GB
├── 子组A: CPU 40%, 内存 3GB ✅ (在父组范围内)
└── 子组B: CPU 50%, 内存 4GB ❌ (超出父组剩余)
```

**🔹 规则2：进程归属**
```
一个进程只能属于一个控制组
但可以受多个子系统控制

例子：nginx进程
├── 在 /sys/fs/cgroup/memory/web-services/ (内存限制)
├── 在 /sys/fs/cgroup/cpu/web-services/ (CPU限制)  
└── 在 /sys/fs/cgroup/blkio/web-services/ (磁盘IO限制)
```

### 2.3 实际层次结构示例


**📋 典型的Web服务器层次**：
```
root (/)
├── system.slice/          ← 系统服务
│   ├── ssh.service
│   └── cron.service
├── user.slice/            ← 用户服务
│   └── user-1000.slice/
└── docker.slice/          ← 容器服务
    ├── container1/
    └── container2/
```

---

## 3. ⚔️ cgroups v1与v2架构对比


### 3.1 版本演进背景


**🟡 cgroups v1的局限**：
- **多层次混乱**：每个子系统有独立的层次结构
- **管理复杂**：同一进程在不同子系统中可能位置不同
- **性能问题**：多个控制器冲突，资源统计不准确

**🟢 cgroups v2的改进**：
- **统一层次**：所有子系统共享同一个层次结构
- **简化管理**：一个进程在所有子系统中位置一致
- **性能优化**：更准确的资源控制和统计

### 3.2 架构差异对比


**📊 结构对比表**：

| 特性 | cgroups v1 | cgroups v2 |
|-----|-----------|-----------|
| **层次结构** | 每个控制器独立层次 | 统一层次结构 |
| **挂载点** | `/sys/fs/cgroup/控制器名/` | `/sys/fs/cgroup/` |
| **接口文件** | 各控制器独立接口 | 统一接口风格 |
| **进程迁移** | 需要在每个控制器中操作 | 一次操作全部生效 |
| **资源统计** | 分散在各控制器 | 集中统计 |

### 3.3 v1与v2共存机制


**⚠️ 重要提醒**：现代Linux系统通常同时支持v1和v2

```bash
# 查看当前系统支持的版本
ls /sys/fs/cgroup/

# 典型输出：
/sys/fs/cgroup/
├── blkio/          ← v1控制器
├── cpu/            ← v1控制器  
├── memory/         ← v1控制器
├── unified/        ← v2统一入口
└── cgroup.procs    ← v2根目录文件
```

**🔧 选择建议**：
- **新项目**：优先使用cgroups v2
- **兼容性要求**：继续使用v1
- **systemd环境**：通常默认v2，但保持v1兼容

---

## 4. 🛠️ 控制组子系统详解


### 4.1 主要子系统分类


**🔥 核心资源控制器** ⭐⭐⭐

**💾 memory（内存控制器）**
```
功能：限制和监控内存使用
主要控制：
- 物理内存限制
- Swap使用限制  
- 内存使用统计
- OOM(内存不足)行为控制

应用场景：防止内存泄漏程序影响系统
```

**⚡ cpu（CPU控制器）**
```
功能：控制CPU时间分配
主要控制：
- CPU使用比例(shares)
- CPU核心绑定(cpuset)
- CPU配额(quota)和周期(period)

应用场景：保证重要服务的CPU时间
```

**💽 blkio（块设备IO控制器）**  
```
功能：控制磁盘读写速度
主要控制：
- 读写带宽限制
- IOPS(每秒IO操作)限制
- IO优先级设置

应用场景：避免IO密集程序影响其他服务
```

### 4.2 其他重要控制器


**🌐 网络相关** ⭐⭐

**net_cls（网络分类）**：为网络包添加类标记，配合tc(流量控制)使用

**net_prio（网络优先级）**：设置网络接口优先级

**🔒 安全相关** ⭐

**devices（设备访问控制）**：控制进程可以访问哪些设备文件

**🎯 其他功能** ⭐

**pids（进程数量限制）**：限制控制组中可创建的进程数量

**freezer（进程冻结）**：暂停/恢复控制组中的所有进程

### 4.3 子系统使用优先级


**🔥 必须掌握（日常运维）**：
- memory：内存管理最重要
- cpu：性能调优必需
- blkio：存储服务优化

**⚡ 重点了解（特定场景）**：
- pids：容器环境常用  
- devices：安全要求高的环境

**💡 了解即可（特殊需求）**：
- freezer、net_cls等：特定应用场景

---

## 5. 📂 文件系统结构深入


### 5.1 /sys/fs/cgroup目录结构


**📋 典型目录布局**：
```
/sys/fs/cgroup/
├── blkio/                 ← 磁盘IO控制
├── cpu,cpuacct/          ← CPU控制和统计
├── cpuset/               ← CPU核心绑定  
├── devices/              ← 设备访问控制
├── freezer/              ← 进程冻结
├── memory/               ← 内存控制
├── net_cls,net_prio/     ← 网络控制
├── pids/                 ← 进程数量限制
├── systemd/              ← systemd管理的控制组
└── unified/              ← cgroups v2入口
```

### 5.2 控制组目录内容详解


**🔍 以memory控制器为例**：
```bash
/sys/fs/cgroup/memory/
├── cgroup.procs          ← 组内进程列表
├── tasks                 ← 组内任务列表
├── memory.limit_in_bytes ← 内存限制设置
├── memory.usage_in_bytes ← 当前内存使用量
├── memory.max_usage_in_bytes ← 历史最大使用量
├── memory.stat           ← 详细内存统计
├── memory.oom_control    ← OOM控制设置
└── notify_on_release     ← 空组时是否通知
```

**📊 关键文件功能说明**：

| 文件名 | 功能说明 | 操作类型 |
|--------|---------|---------|
| `cgroup.procs` | 进程ID列表 | 读取/写入 |
| `tasks` | 线程ID列表 | 读取/写入 |
| `memory.limit_in_bytes` | 内存限制 | 读取/写入 |
| `memory.usage_in_bytes` | 当前使用量 | 只读 |
| `memory.stat` | 详细统计信息 | 只读 |

### 5.3 子控制组创建规则


**🏗️ 创建子控制组**：
```bash
# 创建控制组就是创建目录
mkdir /sys/fs/cgroup/memory/my-service

# 自动生成控制文件
ls /sys/fs/cgroup/memory/my-service/
# 输出与父目录相同的控制文件
```

**📝 文件继承规则**：
- 子控制组自动继承父控制组的所有控制文件
- 初始值通常继承父控制组的设置
- 可以设置比父控制组更严格的限制

---

## 6. ⚙️ 控制组操作实践


### 6.1 创建和删除控制组


**🔧 手动创建控制组**：
```bash
# 1. 创建memory控制组
sudo mkdir /sys/fs/cgroup/memory/web-service

# 2. 设置内存限制（512MB）
echo 536870912 | sudo tee /sys/fs/cgroup/memory/web-service/memory.limit_in_bytes

# 3. 创建CPU控制组
sudo mkdir /sys/fs/cgroup/cpu/web-service

# 4. 设置CPU份额（512 = 50%的权重）
echo 512 | sudo tee /sys/fs/cgroup/cpu/web-service/cpu.shares
```

**🗑️ 删除控制组**：
```bash
# 注意：只能删除空的控制组
# 1. 先移出所有进程
echo $$ | sudo tee /sys/fs/cgroup/memory/cgroup.procs

# 2. 删除控制组目录
sudo rmdir /sys/fs/cgroup/memory/web-service
```

### 6.2 进程加入控制组机制


**🎯 三种加入方式**：

**方式1：直接加入现有进程**
```bash
# 将进程1234加入memory控制组
echo 1234 | sudo tee /sys/fs/cgroup/memory/web-service/cgroup.procs

# 验证进程加入
cat /sys/fs/cgroup/memory/web-service/cgroup.procs
```

**方式2：启动时指定控制组**
```bash
# 使用systemd启动并指定控制组
sudo systemd-run --slice=my-service.slice --scope my-program

# 使用cgexec启动程序
sudo cgexec -g memory:web-service -g cpu:web-service nginx
```

**方式3：批量迁移**
```bash
# 获取进程的所有子进程/线程
ps -eo pid,ppid | awk '$2=='$parent_pid' {print $1}' | \
while read pid; do
    echo $pid | sudo tee /sys/fs/cgroup/memory/web-service/cgroup.procs
done
```

### 6.3 控制组状态查看


**📊 查看控制组信息**：
```bash
# 1. 查看控制组中的进程
cat /sys/fs/cgroup/memory/web-service/cgroup.procs

# 2. 查看内存使用统计
cat /sys/fs/cgroup/memory/web-service/memory.stat

# 3. 查看当前内存使用量
cat /sys/fs/cgroup/memory/web-service/memory.usage_in_bytes

# 4. 使用systemd查看
systemctl status my-service.slice
```

**🔍 实用查看命令**：
```bash
# 查看所有控制组的CPU使用情况
systemd-cgtop

# 查看特定控制组的详细信息
systemd-cgls /system.slice/nginx.service

# 查看进程所属的控制组
cat /proc/$PID/cgroup
```

---

## 7. 🔗 cgroups与systemd集成


### 7.1 systemd的控制组管理


**💡 简单理解**：systemd就像控制组的"管理员"

```
传统方式：手动创建和管理控制组
systemd方式：自动创建，配置即用

优势：
- 自动化管理，减少手动操作
- 配置持久化，重启后自动恢复
- 与服务管理集成，一站式配置
```

### 7.2 systemd控制组层次结构


**🌳 systemd的控制组组织方式**：
```
/sys/fs/cgroup/systemd/
├── system.slice/          ← 系统服务
│   ├── nginx.service      
│   ├── mysql.service
│   └── ssh.service
├── user.slice/            ← 用户服务  
│   └── user-1000.slice/
│       └── session-1.scope
└── machine.slice/         ← 虚拟机/容器
    ├── docker.service
    └── libvirt.service
```

**🔸 Slice的概念**：
- **Slice**：控制组的组织单位，类似文件夹
- **Service**：具体的服务单位，运行在Slice中
- **Scope**：临时的进程组，通常是用户会话

### 7.3 systemd控制组配置


**📝 服务单元配置示例**：
```ini
# /etc/systemd/system/my-web.service
[Unit]
Description=My Web Service
After=network.target

[Service]
ExecStart=/usr/bin/my-web-server
Restart=always

# 资源限制配置
MemoryMax=1G              ← 最大内存1GB
CPUQuota=50%              ← CPU配额50%
IOWeight=100              ← IO权重
TasksMax=50               ← 最大进程数50

[Install]
WantedBy=multi-user.target
```

**🔧 动态调整资源限制**：
```bash
# 动态设置内存限制
sudo systemctl set-property my-web.service MemoryMax=2G

# 动态设置CPU配额  
sudo systemctl set-property my-web.service CPUQuota=80%

# 查看当前限制
systemctl show my-web.service | grep -i memory
```

### 7.4 systemd与手动控制组的关系


**⚠️ 重要注意事项**：
```
✅ 推荐：使用systemd管理服务的控制组
❌ 避免：同时手动操作systemd管理的控制组

原因：
- systemd会自动维护控制组状态
- 手动修改可能被systemd覆盖
- 可能导致配置冲突和异常
```

**🔄 最佳实践**：
- **系统服务**：通过systemd配置资源限制
- **临时任务**：可以手动创建控制组
- **容器应用**：通过容器运行时管理（如Docker）

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🎯 基础概念**：
```
🔸 cgroups = 进程资源管理的"管理区域"
🔸 层次结构 = 树形组织，子组继承父组限制
🔸 子系统 = 不同类型的资源控制器（CPU、内存等）
🔸 控制组 = 具体的资源限制容器
```

**🔍 关键理解要点**：

| 概念 | 通俗解释 | 核心作用 |
|-----|---------|---------|
| **控制组** | 资源的"包间" | 隔离和限制进程资源 |
| **子系统** | 不同的"限制规则" | 控制特定类型资源 |
| **层次结构** | "部门组织架构" | 继承式资源分配 |
| **进程归属** | "员工部门划分" | 确定资源限制范围 |

### 8.2 实际应用价值


**🚀 常见使用场景**：
- **Web服务器**：限制每个站点的资源使用
- **数据库服务**：保证数据库的资源优先级
- **容器技术**：Docker等容器的底层技术
- **多用户系统**：用户间资源隔离

**💼 运维实践指导**：
- **监控重点**：内存使用率、CPU配额、IO延迟
- **限制策略**：预留系统资源，避免资源争抢
- **故障排查**：通过控制组统计定位资源问题

### 8.3 版本选择与管理建议


**🔧 技术选型建议**：

| 使用场景 | 推荐版本 | 管理方式 |
|---------|---------|---------|
| **现代生产环境** | cgroups v2 + systemd | systemd配置 |
| **兼容性要求** | cgroups v1 | 手动或脚本 |
| **容器环境** | v2优先，v1兼容 | 容器运行时管理 |
| **学习研究** | 两者都要了解 | 手动操作练习 |

**🎓 学习路径建议**：
1. **理解概念**：掌握控制组、子系统等基本概念
2. **手动实践**：通过文件系统操作加深理解
3. **systemd集成**：学会在生产环境中正确使用
4. **监控调优**：掌握性能监控和问题排查

**🔑 核心记忆**：
- cgroups = 资源管理的"房间"，每个房间有使用规则
- 子系统 = 不同的管理员（CPU管理员、内存管理员等）
- systemd = 现代的"物业管理"，自动化管理所有房间
- v2比v1更简单统一，但要保持兼容性意识