---
title: 4、服务依赖关系管理
---
## 📚 目录

1. [服务依赖关系基础概念](#1-服务依赖关系基础概念)
2. [依赖类型详解](#2-依赖类型详解)
3. [启动顺序控制](#3-启动顺序控制)
4. [冲突与强依赖关系](#4-冲突与强依赖关系)
5. [循环依赖问题处理](#5-循环依赖问题处理)
6. [依赖关系查看与管理](#6-依赖关系查看与管理)
7. [target单元依赖管理](#7-target单元依赖管理)
8. [故障排查实战](#8-故障排查实战)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔗 服务依赖关系基础概念


### 1.1 什么是服务依赖


**简单理解**：服务依赖就像生活中的"先后顺序"和"必需条件"

```
现实生活类比：
做饭：先有电 → 再开火 → 才能炒菜
开车：先发动 → 再挂档 → 才能行驶

Linux服务：
网络服务启动 → 数据库启动 → Web服务启动
```

**核心作用**：
- 🎯 **确保启动顺序**：让服务按正确顺序启动
- 🔒 **保证运行条件**：确保必需的服务先运行
- ⚡ **提高系统稳定性**：避免服务间冲突
- 🛡️ **故障隔离**：一个服务失败不影响全部

### 1.2 systemd依赖系统的优势


**传统SysV问题**：
```
问题1：启动顺序混乱
- 脚本编号决定顺序（S01、S02...）
- 难以表达复杂依赖关系
- 串行启动，效率低下

问题2：依赖关系不明确
- 只能粗糙控制启动顺序
- 无法处理循环依赖
- 故障排查困难
```

**systemd解决方案**：
```
优势1：声明式依赖
- 明确声明服务间关系
- 自动计算启动顺序
- 并行启动提升效率

优势2：多种依赖类型
- 弱依赖、强依赖、冲突关系
- 灵活的启动顺序控制
- 完善的故障处理机制
```

---

## 2. 🎯 依赖类型详解


### 2.1 Wants（弱依赖）vs Requires（强依赖）


#### 🔸 Wants - 弱依赖关系


**含义**：希望某个服务启动，但不是必须的

```ini
# web.service
[Unit]
Wants=network.service
# 翻译：希望网络服务启动，但网络服务失败不影响我启动

[Service]
Type=simple
ExecStart=/usr/bin/httpd
```

**特点对比表**：

| 方面 | **Wants行为** | **实际效果** |
|------|-------------|-------------|
| **依赖服务启动成功** | `继续启动本服务` | `✅ 正常工作` |
| **依赖服务启动失败** | `仍然启动本服务` | `⚠️ 功能可能受限` |
| **依赖服务运行中停止** | `本服务继续运行` | `📱 保持服务可用性` |

**实际应用场景**：
```
场景1：Web服务 wants 缓存服务
- 有缓存：性能更好
- 无缓存：仍能正常工作

场景2：应用服务 wants 监控服务
- 有监控：能收集指标
- 无监控：业务功能不受影响
```

#### 🔸 Requires - 强依赖关系


**含义**：必须依赖某个服务，缺少就无法工作

```ini
# database-backup.service
[Unit]
Requires=mysqld.service
# 翻译：必须要数据库服务，否则备份没意义

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup-db.sh
```

**特点对比表**：

| 方面 | **Requires行为** | **实际效果** |
|------|-----------------|-------------|
| **依赖服务启动成功** | `继续启动本服务` | `✅ 正常工作` |
| **依赖服务启动失败** | `本服务启动失败` | `❌ 无法启动` |
| **依赖服务运行中停止** | `本服务也会停止` | `🔄 连锁停止` |

### 2.2 选择Wants还是Requires？


**决策流程图**：
```
问题：服务A依赖服务B

服务A没有服务B能否正常工作？
├─ 能工作 → 使用 Wants
│   └─ 示例：Web服务 + 缓存服务
└─ 不能工作 → 使用 Requires  
    └─ 示例：Web应用 + 数据库服务

服务B停止后，服务A是否应该停止？
├─ 应该停止 → 使用 Requires
│   └─ 示例：备份服务 + 数据库
└─ 可以继续 → 使用 Wants
    └─ 示例：应用服务 + 日志服务
```

### 2.3 实际配置示例


**Web服务配置**：
```ini
# nginx.service
[Unit]
Description=nginx web server
Wants=network.service         # 希望有网络，但没网络也能启动（监听本地）
Requires=network-online.target # 必须等网络完全就绪
After=network.service         # 在网络服务之后启动

[Service]
Type=forking
ExecStart=/usr/sbin/nginx
ExecReload=/bin/kill -HUP $MAINPID

[Install]
WantedBy=multi-user.target
```

**数据库应用配置**：
```ini
# webapp.service  
[Unit]
Description=Web Application
Requires=mysqld.service       # 数据库是必须的
Wants=redis.service          # 缓存是可选的
After=mysqld.service redis.service

[Service]
Type=simple
ExecStart=/opt/webapp/start.sh
Restart=always

[Install]
WantedBy=multi-user.target
```

---

## 3. ⏰ 启动顺序控制


### 3.1 After与Before的区别


#### 🔸 After - 在某服务之后启动


**含义**：等某个服务启动完成后，再启动我

```ini
# web.service
[Unit]
After=network.service
# 翻译：等网络服务启动完成后，我再启动
```

**启动时序图**：
```
时间线：  ----1----2----3----4--->
         
network.service: [启动][完成]
                        ↓
web.service:            [等待][启动][完成]
```

#### 🔸 Before - 在某服务之前启动


**含义**：我必须先启动完成，某服务才能启动

```ini
# database.service
[Unit]  
Before=web.service
# 翻译：我必须先启动完成，web服务才能启动
```

**启动时序图**：
```
时间线：  ----1----2----3----4--->

database.service: [启动][完成]
                         ↓
web.service:             [等待][启动][完成]
```

### 3.2 顺序控制与依赖关系的组合


**重要理解**：After/Before只管顺序，不管依赖

```ini
# 错误理解示例
[Unit]
After=network.service
# ❌ 这不会自动启动network.service

# 正确配置示例
[Unit]
Wants=network.service     # 请求启动网络服务
After=network.service     # 在网络服务之后启动
```

**常见组合模式**：

| 组合 | **含义** | **使用场景** |
|------|---------|-------------|
| `Requires + After` | `强依赖 + 顺序控制` | `数据库应用依赖数据库服务` |
| `Wants + After` | `弱依赖 + 顺序控制` | `Web服务希望先有网络` |
| `Before + WantedBy` | `被动启动控制` | `基础服务被其他服务需要` |

### 3.3 复杂启动序列示例


**多层依赖的Web应用**：

```ini
# 1. mysql.service - 数据库层
[Unit]
Description=MySQL Database
After=network.service
Wants=network.service

# 2. redis.service - 缓存层  
[Unit]
Description=Redis Cache
After=network.service
Wants=network.service

# 3. webapp.service - 应用层
[Unit]
Description=Web Application  
Requires=mysql.service        # 强依赖数据库
Wants=redis.service          # 弱依赖缓存
After=mysql.service redis.service  # 顺序控制

# 4. nginx.service - 代理层
[Unit]
Description=Nginx Proxy
Requires=webapp.service      # 强依赖应用
After=webapp.service         # 顺序控制
```

**实际启动顺序**：
```
启动流程图：

network.service (基础网络)
    ↓
┌─mysql.service   redis.service─┐ (并行启动)
│           ↓           ↓       │
│         webapp.service        │ (等待数据库，可选缓存)
│               ↓               │
└─────── nginx.service ─────────┘ (最后启动代理)
```

---

## 4. ⚔️ 冲突与强依赖关系


### 4.1 Conflicts - 冲突关系定义


**含义**：两个服务不能同时运行，类似"水火不容"

```ini
# apache.service
[Unit]
Description=Apache Web Server
Conflicts=nginx.service
# 翻译：我和nginx不能同时运行（都占用80端口）

[Service]
Type=forking
ExecStart=/usr/sbin/httpd
```

**冲突行为**：

| 场景 | **系统行为** | **实际效果** |
|------|-------------|-------------|
| **启动冲突服务时** | `自动停止对方服务` | `确保只有一个运行` |
| **两服务同时启动** | `按优先级决定保留谁` | `避免端口冲突` |
| **手动启动冲突服务** | `提示冲突并停止对方` | `用户能感知冲突` |

**实际应用**：
```
场景1：Web服务器冲突
apache.service ⚔️ nginx.service
- 都占用80/443端口
- 只能运行一个

场景2：防火墙冲突  
iptables.service ⚔️ firewalld.service
- 都管理网络规则
- 同时运行会冲突

场景3：数据库冲突
mysql.service ⚔️ mysql-community.service  
- 不同版本的MySQL
- 避免数据损坏
```

### 4.2 PartOf - 部分隶属关系


**含义**：我是某个整体的一部分，整体停止我也停止

```ini
# worker.service
[Unit]
Description=Worker Process
PartOf=main-app.service
# 翻译：我属于主应用，主应用停止我也停止

[Service]
Type=simple
ExecStart=/opt/app/worker
```

**PartOf特性**：
- ✅ **单向关系**：整体停止，部分停止
- ❌ **不影响启动**：部分停止，整体继续运行
- 🎯 **适用场景**：多进程应用、微服务架构

### 4.3 BindsTo - 绑定关系


**含义**：我和某个服务是"生死与共"的关系

```ini
# app-worker.service
[Unit]
Description=Application Worker
BindsTo=app-master.service
After=app-master.service
# 翻译：我和主服务绑定，主服务死我也死

[Service]
Type=simple
ExecStart=/opt/app/worker
```

**BindsTo vs PartOf vs Requires对比**：

| 依赖类型 | **对方启动失败** | **对方运行中停止** | **我启动时行为** |
|---------|----------------|-------------------|-----------------|
| `Requires` | `我启动失败` | `我也停止` | `会启动对方` |
| `BindsTo` | `我启动失败` | `我也停止` | `会启动对方` |
| `PartOf` | `我可以启动` | `我也停止` | `不启动对方` |

### 4.4 强依赖关系实战示例


**主从架构应用**：
```ini
# master.service - 主服务
[Unit]
Description=Application Master
Requires=database.service
After=database.service

[Service]
Type=forking
ExecStart=/opt/app/master
PIDFile=/var/run/app-master.pid

# worker1.service - 工作进程1  
[Unit]
Description=Worker Process 1
BindsTo=master.service    # 与主服务生死与共
After=master.service      # 主服务启动后再启动

[Service]
Type=simple
ExecStart=/opt/app/worker --id=1

# worker2.service - 工作进程2
[Unit]  
Description=Worker Process 2
PartOf=master.service     # 属于主服务
After=master.service

[Service]
Type=simple
ExecStart=/opt/app/worker --id=2
```

**依赖关系图**：
```
database.service (数据库)
        ↓ (Requires)
master.service (主服务)
    ↓               ↓
worker1.service  worker2.service
 (BindsTo)        (PartOf)

停止master.service时：
- worker1.service 自动停止 (BindsTo)
- worker2.service 自动停止 (PartOf)

worker1.service异常退出时：
- master.service 继续运行
- worker2.service 继续运行
```

---

## 5. 🔄 循环依赖问题处理


### 5.1 什么是循环依赖


**简单理解**：两个或多个服务相互依赖，形成"鸡生蛋蛋生鸡"的问题

```
循环依赖示例：
A服务 Requires B服务
B服务 Requires C服务  
C服务 Requires A服务

A → B → C → A (形成环)
```

**现实类比**：
```
错误的逻辑：
- 要开车必须先有驾照
- 要考驾照必须先会开车
- 要会开车必须先有车
- 要有车必须先会开车
→ 无法开始！
```

### 5.2 循环依赖的识别


**检测命令**：
```bash
# 检查服务依赖树
systemctl list-dependencies service-name --all

# 查看依赖关系
systemd-analyze verify service-name.service

# 检查所有单元的循环依赖
systemd-analyze dump | grep -A5 -B5 "circular"
```

**识别症状**：
```
症状1：服务启动超时
- systemctl start 命令长时间无响应
- 日志显示等待依赖服务

症状2：启动失败
- "依赖失败" 错误信息
- 多个服务状态异常

症状3：系统启动慢
- 启动过程中长时间停顿
- 某些服务never启动
```

### 5.3 循环依赖解决方案


#### 🔧 方案1：改为弱依赖


```ini
# 原始配置（循环依赖）
# service-a.service
[Unit]
Requires=service-b.service

# service-b.service  
[Unit]
Requires=service-a.service

# 修复方案
# service-a.service
[Unit]
Wants=service-b.service    # 改为弱依赖
After=service-b.service

# service-b.service
[Unit]
# 移除对service-a的依赖
```

#### 🔧 方案2：使用socket激活


```ini
# 传统方式（可能循环依赖）
# web.service依赖database.service
# database.service依赖network.service  
# network.service依赖web.service（错误配置）

# socket激活方式
# web.socket
[Unit]
Description=Web Server Socket

[Socket]
ListenStream=80
Accept=yes

[Install]
WantedBy=sockets.target

# web@.service
[Unit]
Description=Web Server Instance

[Service]
Type=simple
ExecStart=/usr/bin/web-server
StandardInput=socket
```

#### 🔧 方案3：重新设计架构


**问题分析**：
```
原始设计问题：
App-A需要App-B的数据
App-B需要App-A的配置
App-C需要前两者都启动

循环：A → B → A
```

**重构方案**：
```
方案1：引入配置服务
Config-Service (配置中心)
    ↓
App-A, App-B (并行启动)
    ↓
App-C (最后启动)

方案2：延迟初始化
App-A启动 → App-B启动 → 运行时再建立连接
```

### 5.4 预防循环依赖的最佳实践


**设计原则**：
```
原则1：分层设计
基础层 → 服务层 → 应用层 → 表示层
依赖只能向下，不能向上

原则2：单一职责
每个服务职责明确
减少不必要的依赖

原则3：配置外置
依赖配置写在外部文件
运行时动态加载依赖关系
```

---

## 6. 🔍 依赖关系查看与管理


### 6.1 依赖关系查看命令


#### 📊 基础查看命令


```bash
# 查看服务的直接依赖
systemctl list-dependencies nginx.service

# 查看完整依赖树（包括间接依赖）
systemctl list-dependencies nginx.service --all

# 查看反向依赖（谁依赖我）
systemctl list-dependencies nginx.service --reverse

# 查看依赖详情（包括依赖类型）
systemctl show nginx.service | grep -E "(Requires|Wants|After|Before)"
```

#### 🎯 高级分析命令


```bash
# 分析服务启动时间和依赖
systemd-analyze critical-chain nginx.service

# 生成依赖关系图（需要graphviz）
systemd-analyze dot nginx.service | dot -Tsvg > nginx-deps.svg

# 检查配置文件语法
systemd-analyze verify nginx.service

# 查看所有服务依赖统计
systemd-analyze dump | grep -E "(Requires|Wants)" | sort | uniq -c
```

### 6.2 依赖信息解读


**命令输出示例**：
```bash
$ systemctl list-dependencies nginx.service
nginx.service
├─system.slice
├─network.target
│ ├─NetworkManager.service
│ ├─network.service  
│ └─wpa_supplicant.service
└─sysinit.target
  ├─dev-disk-by\x2duuid-xxx.device
  ├─systemd-modules-load.service
  └─...

# 符号含义：
● 绿色圆点：服务正常运行
○ 白色圆点：服务已停止
× 红色叉号：服务启动失败
```

**依赖类型标识**：
```bash
$ systemctl show nginx.service | grep -E "(Requires|Wants)"
Requires=system.slice sysinit.target
Wants=network.target
RequiredBy=multi-user.target  
WantedBy=multi-user.target

# 含义解释：
Requires=     # 我强依赖的服务
Wants=        # 我弱依赖的服务  
RequiredBy=   # 强依赖我的服务
WantedBy=     # 弱依赖我的服务
```

### 6.3 依赖关系图谱分析


**生成可视化图谱**：
```bash
# 安装图形工具
sudo yum install graphviz

# 生成nginx服务依赖图
systemd-analyze dot nginx.service > nginx.dot
dot -Tpng nginx.dot -o nginx-deps.png

# 生成系统全局依赖图（注意：文件很大）
systemd-analyze dot > system-deps.dot
```

**图谱解读技巧**：
```
图形元素含义：
├─ 实线：Requires（强依赖）
├─ 虚线：Wants（弱依赖）  
├─ 红线：Conflicts（冲突）
├─ 箭头：依赖方向
└─ 颜色：服务状态
```

### 6.4 动态依赖管理


**临时修改依赖**：
```bash
# 临时添加依赖（重启后失效）
sudo systemctl add-wants multi-user.target nginx.service

# 临时移除依赖
sudo systemctl remove-wants multi-user.target nginx.service

# 查看临时修改
ls /etc/systemd/system/multi-user.target.wants/
```

**永久修改依赖**：
```bash
# 编辑服务文件
sudo systemctl edit nginx.service

# 在编辑器中添加：
[Unit]
Wants=redis.service
After=redis.service

# 重新加载配置
sudo systemctl daemon-reload
```

---

## 7. 🎯 target单元依赖管理


### 7.1 什么是target单元


**简单理解**：target就像是"服务组合套餐"，把相关服务打包管理

```
现实类比：
外卖套餐 = 主食 + 小菜 + 汤 + 饮料
target单元 = 服务A + 服务B + 服务C + ...

作用：
- 一次性启动多个相关服务
- 定义系统运行级别
- 简化服务组管理
```

**常见target单元**：
```
multi-user.target    # 多用户文本模式（相当于运行级别3）
graphical.target     # 图形界面模式（相当于运行级别5）
network.target       # 网络服务组
basic.target         # 基本系统服务组
sysinit.target       # 系统初始化服务组
```

### 7.2 target与服务的依赖关系


**WantedBy vs RequiredBy**：
```ini
# 服务配置示例
# nginx.service
[Unit]
Description=Nginx Web Server
Requires=network.target
After=network.target

[Service]
Type=forking
ExecStart=/usr/sbin/nginx

[Install]
WantedBy=multi-user.target    # 被multi-user.target弱依赖
# RequiredBy=multi-user.target  # 被multi-user.target强依赖（少用）
```

**依赖关系图**：
```
multi-user.target
    ↓ (Wants)
nginx.service
    ↓ (Requires)  
network.target
    ↓ (Wants)
├─ NetworkManager.service
├─ network.service
└─ systemd-networkd.service
```

### 7.3 自定义target单元


**创建自定义target**：
```ini
# /etc/systemd/system/webapp.target
[Unit]
Description=Web Application Stack
Requires=multi-user.target
After=multi-user.target
AllowIsolate=yes

# 这个target本身不运行服务，只是一个组合
```

**让服务加入target**：
```ini
# mysql.service
[Install]
WantedBy=webapp.target

# redis.service  
[Install]
WantedBy=webapp.target

# nginx.service
[Install]  
WantedBy=webapp.target
```

**使用自定义target**：
```bash
# 启动整个Web应用栈
sudo systemctl start webapp.target

# 停止整个Web应用栈
sudo systemctl stop webapp.target

# 设置默认启动到webapp.target
sudo systemctl set-default webapp.target

# 隔离到webapp.target（停止其他不相关服务）
sudo systemctl isolate webapp.target
```

### 7.4 target依赖最佳实践


**分层target设计**：
```
系统层次结构：
sysinit.target          # 系统初始化
    ↓
basic.target            # 基础服务  
    ↓
network.target          # 网络服务
    ↓
multi-user.target       # 多用户服务
    ↓
webapp.target          # 自定义应用栈
    ↓
graphical.target       # 图形界面（可选）
```

**实际配置示例**：
```ini
# database.target - 数据库服务组
[Unit]
Description=Database Services
Requires=network.target
After=network.target
Wants=mysql.service postgresql.service redis.service

# web.target - Web服务组
[Unit]  
Description=Web Services
Requires=database.target network.target
After=database.target
Wants=nginx.service apache.service

# monitoring.target - 监控服务组
[Unit]
Description=Monitoring Services  
Requires=network.target
After=multi-user.target
Wants=prometheus.service grafana.service
```

---

## 8. 🛠️ 故障排查实战


### 8.1 常见依赖问题症状


**症状识别表**：

| 症状 | **可能原因** | **检查方法** |
|------|-------------|-------------|
| `服务启动超时` | `依赖服务无响应` | `systemctl list-dependencies --failed` |
| `服务启动失败` | `强依赖服务未启动` | `systemctl status service-name` |
| `系统启动缓慢` | `循环依赖或依赖链太长` | `systemd-analyze critical-chain` |
| `服务意外停止` | `依赖服务停止触发连锁反应` | `journalctl -u service-name` |

### 8.2 依赖故障排查步骤


**第一步：检查服务状态**
```bash
# 查看服务当前状态
systemctl status problematic.service

# 查看详细失败信息
systemctl --failed

# 查看最近的日志
journalctl -u problematic.service --since "10 minutes ago"
```

**第二步：分析依赖关系**
```bash
# 查看依赖树，找出失败点
systemctl list-dependencies problematic.service --failed

# 查看关键启动链
systemd-analyze critical-chain problematic.service

# 检查配置文件语法
systemd-analyze verify problematic.service
```

**第三步：深入日志分析**
```bash
# 查看启动过程详细日志
journalctl -b | grep problematic.service

# 查看依赖服务的日志
journalctl -u dependency.service

# 查看系统级错误
journalctl -p err -b
```

### 8.3 实际故障案例


#### 📋 案例1：Web服务启动失败


**故障现象**：
```bash
$ sudo systemctl start webapp.service
Job for webapp.service failed because start of the service was attempted too often.
```

**排查过程**：
```bash
# 1. 检查服务状态
$ systemctl status webapp.service
● webapp.service - Web Application
   Loaded: loaded (/etc/systemd/system/webapp.service; enabled)
   Active: failed (Result: start-limit-hit)

# 2. 查看依赖
$ systemctl list-dependencies webapp.service --failed  
● webapp.service
  ├─● mysql.service ← 发现mysql服务失败

# 3. 检查mysql服务
$ systemctl status mysql.service
● mysql.service - MySQL Database  
   Active: failed (Result: exit-code)
   
$ journalctl -u mysql.service | tail -5
ERROR: Can't connect to MySQL server on 'localhost' (111)
```

**解决方案**：
```bash
# 修复mysql配置问题
sudo vim /etc/mysql/my.cnf

# 重新启动mysql
sudo systemctl restart mysql.service

# 再次启动webapp
sudo systemctl start webapp.service
```

#### 📋 案例2：循环依赖问题


**故障现象**：
```bash
$ sudo systemctl start service-a.service
A dependency job for service-a.service failed.
```

**排查过程**：
```bash
# 发现循环依赖
$ systemd-analyze verify service-a.service  
service-a.service: Dependency loop found, dropping requirement on service-b.service

# 查看具体循环
$ systemctl list-dependencies service-a.service
service-a.service
├─service-b.service
│ └─service-c.service  
│   └─service-a.service ← 循环！
```

**解决方案**：
```ini
# 修改service-c.service
[Unit]
# Requires=service-a.service  # 删除强依赖
Wants=service-a.service       # 改为弱依赖
```

### 8.4 预防性监控


**依赖健康检查脚本**：
```bash
#!/bin/bash
# dependency-check.sh

echo "=== 系统依赖健康检查 ==="

# 检查失败的服务
echo "失败的服务："
systemctl --failed --no-legend

# 检查循环依赖
echo -e "\n检查循环依赖："
systemd-analyze verify 2>&1 | grep -i "circular\|loop" || echo "无循环依赖"

# 检查关键服务链
echo -e "\n关键服务启动链："
systemd-analyze critical-chain

# 检查依赖过深的服务
echo -e "\n依赖深度分析："
systemctl list-dependencies --all | grep -E "^[│├└─ ]{10,}" | head -5
```

**定期检查建议**：
```bash
# 添加到cron任务
0 8 * * * /usr/local/bin/dependency-check.sh | mail -s "系统依赖检查报告" admin@example.com

# 或者作为监控服务
sudo systemctl enable --now dependency-monitor.timer
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 依赖类型：Wants弱依赖、Requires强依赖，选择看业务需要
🔸 顺序控制：After/Before只管顺序，不管是否启动依赖服务  
🔸 冲突关系：Conflicts解决服务冲突，PartOf/BindsTo处理强绑定
🔸 循环依赖：最常见问题，通过弱依赖或架构重构解决
🔸 target管理：服务组合管理，简化批量操作
🔸 故障排查：从状态→依赖→日志的排查流程
```

### 9.2 关键理解要点


**🔹 依赖选择决策**
```
选择Wants：
- 服务可选，有更好，没有也行
- 依赖服务停止不影响本服务
- 示例：Web + 缓存，应用 + 监控

选择Requires：  
- 服务必需，缺少无法工作
- 依赖服务停止，本服务也停止
- 示例：应用 + 数据库，备份 + 源数据
```

**🔹 顺序vs依赖的区别**
```
常见误区：After等于依赖
正确理解：
- After/Before：只管启动顺序
- Wants/Requires：管依赖关系和启动请求
- 通常需要组合使用

正确写法：
Wants=network.service      # 请求启动网络
After=network.service      # 网络启动后再启动我
```

**🔹 故障排查思路**
```
排查步骤：
1. 看现象：服务状态、错误信息
2. 查依赖：依赖树、失败服务
3. 读日志：启动日志、错误详情
4. 找根因：配置错误、资源问题
5. 验证修复：重启测试、监控验证
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **Web应用架构**：数据库→应用→缓存→代理的依赖链
- **微服务架构**：服务发现→配置中心→业务服务的启动顺序
- **监控系统**：基础服务→数据收集→分析展示的分层依赖
- **开发环境**：数据库→消息队列→应用服务的开发栈

**🔧 运维实践**
- **服务部署**：确保依赖服务先于应用服务启动
- **故障恢复**：理解依赖链，快速定位故障源头
- **系统升级**：合理规划服务停启顺序，减少业务影响
- **容量规划**：分析依赖关系，评估系统负载传播

**核心记忆口诀**：
- 弱依赖可选择，强依赖必须要
- 顺序只管先后，依赖决定启停  
- 循环依赖要避免，架构设计需合理
- 故障排查有步骤，从现象到根因