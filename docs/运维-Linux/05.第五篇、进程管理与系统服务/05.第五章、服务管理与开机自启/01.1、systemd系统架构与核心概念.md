---
title: 1、systemd系统架构与核心概念
---
## 📚 目录

1. [systemd架构与核心概念](#1-systemd架构与核心概念)
2. [PID 1进程角色与职责](#2-pid-1进程角色与职责)
3. [systemd vs SysV init对比](#3-systemd-vs-sysv-init对比)
4. [unit单元文件概念与分类](#4-unit单元文件概念与分类)
5. [target运行级别替代机制](#5-target运行级别替代机制)
6. [systemd守护进程启动流程](#6-systemd守护进程启动流程)
7. [并行启动与依赖管理](#7-并行启动与依赖管理)
8. [systemd主要命令工具集](#8-systemd主要命令工具集)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🏗️ systemd架构与核心概念


### 1.1 什么是systemd


**简单理解**：systemd就是Linux系统的"大管家"，负责管理系统启动、服务运行、进程监控等各种任务。

> 💡 **通俗解释**
> 
> 就像一个大公司需要总经理来统筹管理各个部门一样，Linux系统也需要一个"总管理员"来协调所有程序的运行。systemd就是这个总管理员。

**核心特点**：
- 🚀 **快速启动**：并行启动服务，比传统方式快得多
- 🔧 **统一管理**：用一套工具管理所有系统服务
- 📊 **智能监控**：自动重启崩溃的服务
- 🎯 **按需启动**：只在需要时启动相关服务

### 1.2 systemd架构组件


systemd不是一个单独的程序，而是一整套工具的集合：

```
systemd架构图：
┌─────────────────────────────────────────┐
│           用户空间应用程序               │
├─────────────────────────────────────────┤
│  systemctl  │ journalctl │ systemd-run  │ ← 用户命令工具
├─────────────────────────────────────────┤
│           systemd核心管理器             │ ← PID 1进程
├─────────────────────────────────────────┤
│ systemd-logind │ systemd-networkd │... │ ← 各种守护进程
├─────────────────────────────────────────┤
│              Linux内核                  │
└─────────────────────────────────────────┘
```

**主要组件说明**：
- 🔸 **systemd**：核心管理器，PID为1的主进程
- 🔸 **systemctl**：服务控制命令，用来启动、停止、查看服务
- 🔸 **journalctl**：日志查看工具，查看系统和服务日志
- 🔸 **systemd-logind**：管理用户登录会话
- 🔸 **systemd-networkd**：网络配置管理
- 🔸 **systemd-resolved**：DNS解析服务

### 1.3 进程关系图


```
进程树结构：
systemd (PID 1)
├── systemd-logind
├── systemd-networkd  
├── systemd-resolved
├── ssh.service
├── nginx.service
├── mysql.service
└── 用户进程...
```

> ⚡ **重要概念**
> 
> systemd是系统启动后第一个运行的进程，PID永远是1，所有其他进程都是它的"子孙"。

---

## 2. 👑 PID 1进程角色与职责


### 2.1 PID 1的特殊地位


**什么是PID 1**：
- PID就是进程ID，每个进程都有唯一的编号
- PID 1是系统启动后第一个进程，非常特殊
- 所有其他进程都是PID 1进程直接或间接创建的

> 💡 **形象比喻**
> 
> 如果把系统比作一个家族，PID 1就是始祖，所有进程都是它的后代。如果始祖死了，整个家族就完了，系统也就崩溃了。

### 2.2 传统init的问题


**老式SysV init的缺点**：
- 🐌 **串行启动**：服务一个接一个启动，很慢
- 📝 **脚本复杂**：启动脚本写起来很复杂
- 🔄 **管理困难**：重启服务需要复杂的脚本
- 📊 **缺乏监控**：不知道服务是否正常运行

### 2.3 systemd作为PID 1的优势


**systemd的改进**：

🚀 **并行启动**
```
传统init启动顺序：
网络 → 数据库 → Web服务器 → 应用
(总计：30秒)

systemd并行启动：
网络 ━━━━┓
数据库 ━━┫→ 系统就绪
Web服务器 ┫  (总计：10秒)
应用 ━━━━┛
```

🔧 **统一管理**
- 所有服务用同样的方式启动、停止、查看状态
- 不需要记忆各种不同的脚本位置和语法

📊 **智能监控**
- 自动检测服务是否崩溃
- 可以自动重启失败的服务
- 记录详细的启动和运行日志

### 2.4 PID 1的核心职责


| 职责 | 说明 | 举例 |
|------|------|------|
| **进程管理** | 创建、监控、回收子进程 | 启动SSH服务，监控其运行状态 |
| **信号处理** | 处理系统信号，如关机信号 | 接收Ctrl+Alt+Del信号执行重启 |
| **僵尸进程回收** | 清理已死亡但未被回收的进程 | 自动清理退出的子进程 |
| **系统初始化** | 挂载文件系统，启动基础服务 | 挂载/home分区，启动网络服务 |

---

## 3. ⚖️ systemd vs SysV init对比


### 3.1 启动速度对比


**SysV init启动过程**：
```
启动流程（串行）：
开机 → BIOS → 内核 → init → 
→ /etc/rc.d/rc.sysinit（系统初始化）
→ /etc/rc.d/rc（运行级别脚本）
→ /etc/rc.d/rc.local（用户自定义）
→ getty（登录界面）

典型启动时间：60-120秒
```

**systemd启动过程**：
```
启动流程（并行）：
开机 → BIOS → 内核 → systemd →
→ 同时启动多个服务（并行）
→ 按需启动（用到才启动）
→ 登录界面

典型启动时间：20-30秒
```

### 3.2 管理方式对比


**SysV init管理**：
```bash
# 启动Apache服务（CentOS 6）
service httpd start
/etc/init.d/httpd start

# 设置开机自启
chkconfig httpd on

# 查看服务状态
service httpd status
```

**systemd管理**：
```bash
# 启动Apache服务（CentOS 7+）
systemctl start httpd

# 设置开机自启
systemctl enable httpd

# 查看服务状态
systemctl status httpd
```

> 💡 **一目了然的区别**
> 
> SysV需要记住不同的命令（service、chkconfig），systemd只需要记住systemctl一个命令！

### 3.3 配置文件对比


**SysV init配置**（复杂的shell脚本）：
```bash
#!/bin/bash
# /etc/init.d/myapp
case "$1" in
  start)
    echo "Starting myapp..."
    /usr/bin/myapp &
    echo $! > /var/run/myapp.pid
    ;;
  stop)
    echo "Stopping myapp..."
    kill `cat /var/run/myapp.pid`
    rm /var/run/myapp.pid
    ;;
  *)
    echo "Usage: $0 {start|stop|restart}"
    ;;
esac
```

**systemd配置**（简单的配置文件）：
```ini
[Unit]
Description=My Application
After=network.target

[Service]
ExecStart=/usr/bin/myapp
Restart=always

[Install]
WantedBy=multi-user.target
```

> ✅ **明显优势**
> 
> systemd的配置文件就像填表格一样简单，不需要写复杂的脚本！

### 3.4 功能特性对比


| 特性 | **SysV init** | **systemd** | **说明** |
|------|---------------|-------------|----------|
| 🚀 **启动方式** | 串行启动 | 并行启动 | systemd快3-5倍 |
| 📊 **服务监控** | 无 | 自动监控 | systemd可自动重启崩溃服务 |
| 📝 **配置复杂度** | 复杂shell脚本 | 简单配置文件 | systemd更易维护 |
| 🔧 **管理命令** | service/chkconfig | systemctl | systemd命令统一 |
| 📋 **日志管理** | 各自记录 | 统一journald | systemd日志集中管理 |
| ⚡ **按需启动** | 不支持 | 支持 | systemd节省资源 |

---

## 4. 📋 unit单元文件概念与分类


### 4.1 什么是unit单元文件


**简单理解**：unit就是systemd管理的"单位"，每个服务、设备、挂载点等都是一个unit。

> 💡 **生活化比喻**
> 
> 就像公司里的各个部门（销售部、技术部、财务部），每个部门都是一个"单位"，有自己的职责和管理方式。systemd把系统中的各种资源都当作"单位"来统一管理。

**unit文件的作用**：
- 告诉systemd如何启动这个服务
- 定义服务的依赖关系
- 设置服务的运行参数
- 指定服务出错时的处理方式

### 4.2 unit文件存放位置


```
unit文件位置优先级：
/etc/systemd/system/           ← 管理员自定义（最高优先级）
├── nginx.service
├── myapp.service
└── mysql.service.d/           ← 配置片段目录

/run/systemd/system/           ← 运行时动态创建（中优先级）
├── tmp.mount
└── user-1000.slice

/usr/lib/systemd/system/       ← 软件包安装（最低优先级）
├── ssh.service
├── NetworkManager.service
└── bluetooth.service
```

> ⚡ **重要提醒**
> 
> 自定义的配置文件放在`/etc/systemd/system/`目录下，这样不会被软件更新覆盖！

### 4.3 unit文件类型分类


systemd把不同类型的资源分成不同类型的unit：

**🔸 .service（服务单元）** - 最常用
```ini
# nginx.service
[Unit]
Description=Web服务器
After=network.target

[Service]
ExecStart=/usr/sbin/nginx
Type=forking

[Install]
WantedBy=multi-user.target
```

**🔸 .target（目标单元）** - 类似运行级别
```ini
# multi-user.target（多用户模式）
[Unit]
Description=多用户系统
Requires=basic.target
```

**🔸 .mount（挂载单元）** - 文件系统挂载
```ini
# home.mount
[Unit]
Description=挂载/home分区

[Mount]
What=/dev/sdb1
Where=/home
Type=ext4
```

**🔸 .socket（套接字单元）** - 网络监听
```ini
# ssh.socket
[Unit]
Description=SSH监听端口

[Socket]
ListenStream=22
Accept=yes
```

### 4.4 unit文件基本结构


每个unit文件都分为几个部分：

```ini
[Unit]           ← 通用信息
Description=服务描述
After=依赖的服务
Before=需要等待本服务的服务
Requires=强制依赖
Wants=弱依赖

[Service]        ← 服务专用配置（.service文件特有）
Type=服务类型
ExecStart=启动命令
ExecStop=停止命令
Restart=重启策略
User=运行用户

[Install]        ← 安装信息
WantedBy=归属目标
RequiredBy=强制归属
```

> 📚 **记忆技巧**
> 
> - `[Unit]`：基本信息，告诉systemd这是什么
> - `[Service]`：具体配置，告诉systemd怎么做
> - `[Install]`：安装位置，告诉systemd放在哪

---

## 5. 🎯 target运行级别替代机制


### 5.1 传统运行级别的问题


**SysV init运行级别**（已过时）：
```
运行级别对照：
0 - 关机
1 - 单用户模式（救援模式）
2 - 多用户模式（无网络）
3 - 多用户模式（有网络，无图形界面）
4 - 未使用
5 - 图形界面模式
6 - 重启
```

**问题**：
- 级别固定，不够灵活
- 只能同时处于一个运行级别
- 切换运行级别会停止很多服务

### 5.2 systemd target概念


**什么是target**：
target就是一组相关服务的集合，类似于"工作模式"。

> 💡 **形象理解**
> 
> 就像手机的场景模式：
> - "会议模式"：静音、震动、屏幕变暗
> - "游戏模式"：高性能、不休眠、免打扰
> - "省电模式"：降频、关闭后台、减少亮度
> 
> systemd的target也是这样，每种模式启动不同的服务组合。

**常用target类型**：
```
target替代对照：
poweroff.target     ← 对应运行级别0（关机）
rescue.target       ← 对应运行级别1（单用户救援）
multi-user.target   ← 对应运行级别3（多用户命令行）
graphical.target    ← 对应运行级别5（图形界面）
reboot.target       ← 对应运行级别6（重启）
```

### 5.3 target依赖关系


```
target依赖层次：
graphical.target
├── multi-user.target
│   ├── basic.target
│   │   ├── sysinit.target
│   │   │   ├── local-fs.target
│   │   │   └── swap.target
│   │   ├── sockets.target
│   │   └── timers.target
│   ├── ssh.service
│   ├── network.target
│   └── 其他服务...
└── display-manager.service（图形登录管理器）
```

**依赖关系说明**：
- 🔸 **图形模式**需要**多用户模式**的所有功能
- 🔸 **多用户模式**需要**基础系统**正常工作
- 🔸 **基础系统**需要文件系统、网络等基础设施

### 5.4 target操作命令


**查看当前target**：
```bash
# 查看当前默认启动target
systemctl get-default

# 查看当前活动的target
systemctl list-units --type=target
```

**切换target**：
```bash
# 临时切换到命令行模式
systemctl isolate multi-user.target

# 临时切换到图形模式
systemctl isolate graphical.target

# 设置默认启动模式
systemctl set-default graphical.target
```

**创建自定义target**：
```ini
# /etc/systemd/system/myapp.target
[Unit]
Description=我的应用运行环境
Requires=multi-user.target
After=multi-user.target

[Install]
WantedBy=multi-user.target
```

---

## 6. 🚀 systemd守护进程启动流程


### 6.1 完整启动时序


```
系统启动完整流程：

BIOS/UEFI
    ↓
引导加载程序（GRUB）
    ↓
Linux内核加载
    ↓
内核初始化
    ↓
启动systemd（PID 1）
    ↓
┌─────────────────────────────────┐
│       systemd启动阶段           │
├─────────────────────────────────┤
│ 1. 解析配置文件                  │
│ 2. 确定启动目标                  │
│ 3. 解析依赖关系                  │
│ 4. 并行启动服务                  │
│ 5. 等待所有服务就绪              │
└─────────────────────────────────┘
    ↓
用户登录界面
```

### 6.2 systemd内部启动详情


**第一阶段：基础初始化**
```bash
# systemd启动后立即执行的目标
1. sysinit.target（系统初始化）
   ├── 挂载基础文件系统
   ├── 加载内核模块
   ├── 设置系统时间
   └── 初始化随机数种子

2. basic.target（基础服务）
   ├── 启动设备管理器
   ├── 启动日志服务
   └── 启动基础网络服务
```

**第二阶段：服务启动**
```bash
3. multi-user.target（多用户服务）
   ├── 网络服务（NetworkManager）
   ├── SSH服务
   ├── 定时任务（cron）
   ├── 数据库服务
   └── Web服务器

4. graphical.target（图形界面，如果需要）
   └── 显示管理器（GDM/SDDM/LightDM）
```

### 6.3 启动过程监控


**查看启动时间分析**：
```bash
# 查看整体启动用时
systemd-analyze

# 查看每个服务启动用时
systemd-analyze blame

# 查看启动关键路径
systemd-analyze critical-chain

# 生成启动时间图表
systemd-analyze plot > boot.svg
```

**输出示例**：
```
$ systemd-analyze
启动完成时间：34.567秒
内核启动：3.245秒
用户空间启动：31.322秒
固件时间：2.1秒

最慢的5个服务：
12.456s NetworkManager-wait-online.service
8.234s mysql.service
5.123s httpd.service
3.987s postfix.service
2.345s firewalld.service
```

### 6.4 启动故障排查


**常见启动问题**：
```bash
# 查看启动失败的服务
systemctl --failed

# 查看具体服务的启动日志
journalctl -u 服务名 -f

# 查看开机启动日志
journalctl -b

# 进入救援模式（类似Windows安全模式）
systemctl rescue
```

---

## 7. 🔗 并行启动与依赖管理


### 7.1 并行启动原理


**传统串行启动**：
```
时间线：
0s    5s    10s   15s   20s   25s
|-----|-----|-----|-----|-----|
网络启动 → 数据库 → Web → 邮件 → 完成
```

**systemd并行启动**：
```
时间线：
0s    5s    10s
|-----|-----|
网络启动
数据库启动 ━━━┓
Web服务启动 ━┫→ 完成
邮件服务启动 ━┛
```

> ⚡ **速度提升原理**
> 
> 就像做饭一样，传统方式是先烧水，水开了再下面条，面条熟了再炒菜。systemd方式是同时烧水、准备面条、洗菜，大家一起干，当然快！

### 7.2 依赖关系类型


**🔸 强依赖（Requires）**
```ini
[Unit]
Requires=mysql.service
# Web服务强制需要MySQL，MySQL启动失败，Web服务也不启动
```

**🔸 弱依赖（Wants）**
```ini
[Unit]
Wants=redis.service
# Web服务希望有Redis，但Redis启动失败，Web服务仍然启动
```

**🔸 顺序依赖（After/Before）**
```ini
[Unit]
After=network.target
# 网络就绪后再启动本服务（但不强制要求网络成功）

Before=httpd.service
# 本服务要在Apache之前启动
```

### 7.3 依赖关系实例


**Web应用依赖配置示例**：
```ini
# /etc/systemd/system/mywebapp.service
[Unit]
Description=我的Web应用
# 强制依赖：没有数据库就无法运行
Requires=mysql.service
# 弱依赖：有缓存更好，没有也能运行
Wants=redis.service
# 顺序：网络和数据库都就绪后再启动
After=network.target mysql.service redis.service
# 冲突：不能和测试版同时运行
Conflicts=mywebapp-test.service

[Service]
ExecStart=/opt/myapp/bin/start.sh
Type=simple
User=webapp
Restart=always

[Install]
WantedBy=multi-user.target
```

### 7.4 智能依赖解析


systemd会自动解析复杂的依赖关系：

```
服务依赖图：
                Web应用
                /    \
           数据库      缓存
             |         |
          文件系统    网络服务
             |         |
           设备驱动   网卡驱动
             |         |
             硬件检测 ────┘
```

**systemd的智能之处**：
- ✅ **自动排序**：根据依赖关系安排启动顺序
- ✅ **并行优化**：无依赖关系的服务同时启动
- ✅ **循环检测**：发现依赖循环会报错
- ✅ **失败隔离**：一个服务失败不会拖垮整个系统

---

## 8. 🛠️ systemd主要命令工具集


### 8.1 systemctl核心命令


**🔸 服务控制命令**
```bash
# 启动服务
systemctl start nginx
systemctl start nginx.service  # 完整写法

# 停止服务
systemctl stop nginx

# 重启服务
systemctl restart nginx

# 重新加载配置（不重启进程）
systemctl reload nginx

# 查看服务状态
systemctl status nginx

# 检查服务是否在运行
systemctl is-active nginx

# 检查服务是否开机自启
systemctl is-enabled nginx
```

**🔸 开机自启管理**
```bash
# 设置开机自启
systemctl enable nginx

# 取消开机自启
systemctl disable nginx

# 立即启动并设置开机自启
systemctl enable --now nginx

# 立即停止并取消开机自启
systemctl disable --now nginx
```

### 8.2 系统状态查看


**🔸 服务列表查看**
```bash
# 查看所有服务状态
systemctl list-units --type=service

# 查看所有已启动的服务
systemctl list-units --type=service --state=active

# 查看所有失败的服务
systemctl --failed

# 查看所有开机自启的服务
systemctl list-unit-files --type=service --state=enabled
```

**🔸 系统状态信息**
```bash
# 查看系统整体状态
systemctl status

# 查看启动用时分析
systemd-analyze

# 查看启动关键路径
systemd-analyze critical-chain

# 重新加载systemd配置
systemctl daemon-reload
```

### 8.3 journalctl日志管理


**🔸 基础日志查看**
```bash
# 查看所有系统日志
journalctl

# 查看特定服务日志
journalctl -u nginx

# 实时查看日志（类似tail -f）
journalctl -u nginx -f

# 查看最近N行日志
journalctl -u nginx -n 50

# 查看某个时间段的日志
journalctl --since "2024-01-01" --until "2024-01-02"
```

**🔸 高级日志过滤**
```bash
# 查看开机日志
journalctl -b

# 查看内核消息
journalctl -k

# 按优先级查看（只看错误和警告）
journalctl -p err

# 按进程PID查看
journalctl _PID=1234

# 查看日志占用空间
journalctl --disk-usage

# 清理旧日志（保留最近1周）
journalctl --vacuum-time=1w
```

### 8.4 高级管理命令


**🔸 target管理**
```bash
# 查看当前运行级别
systemctl get-default

# 设置默认运行级别
systemctl set-default graphical.target

# 切换运行级别（立即生效）
systemctl isolate multi-user.target

# 查看所有target
systemctl list-units --type=target
```

**🔸 系统电源管理**
```bash
# 关机
systemctl poweroff

# 重启
systemctl reboot

# 挂起（睡眠）
systemctl suspend

# 休眠
systemctl hibernate

# 进入救援模式
systemctl rescue
```

### 8.5 实用命令组合


**🔸 一键服务部署**
```bash
# 部署新服务的完整流程
sudo cp myapp.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable --now myapp
sudo systemctl status myapp
```

**🔸 服务故障排查**
```bash
# 故障排查三步走
systemctl status 服务名     # 查看状态
journalctl -u 服务名 -f     # 查看日志
systemctl restart 服务名    # 尝试重启
```

**🔸 系统维护检查**
```bash
# 系统健康检查
systemctl --failed           # 查看失败服务
journalctl -p err -b         # 查看启动错误
systemd-analyze blame        # 查看启动慢的服务
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


> 💡 **systemd本质理解**
> 
> systemd就是Linux的"系统管家"，负责：
> - 🏠 **房屋管理**：管理系统启动和关机
> - 👥 **人员管理**：管理各种服务进程
> - 📊 **状态监控**：监控服务运行状况
> - 📝 **日志记录**：记录系统运行日志

### 9.2 关键技术优势


```
systemd vs 传统init优势对比：
┌────────────────┬──────────────┬─────────────┐
│   对比项目     │  传统init    │  systemd    │
├────────────────┼──────────────┼─────────────┤
│ 🚀 启动速度    │    慢(串行)   │  快(并行)   │
│ 🔧 管理复杂度  │   复杂脚本   │  简单配置   │
│ 📊 服务监控    │     无       │  自动监控   │
│ 📝 日志管理    │   分散存储   │  集中管理   │
│ ⚡ 按需启动    │   不支持     │   支持      │
│ 🔄 依赖管理    │    手动      │   自动      │
└────────────────┴──────────────┴─────────────┘
```

### 9.3 实用操作记忆


**🔸 日常最常用命令**
```bash
# 服务管理三板斧
systemctl start/stop/restart 服务名
systemctl enable/disable 服务名
systemctl status 服务名

# 故障排查两步走
systemctl --failed
journalctl -u 服务名 -f
```

**🔸 unit文件基础结构**
```ini
[Unit]          # 基本信息（是什么）
[Service]       # 服务配置（怎么做）  
[Install]       # 安装信息（放哪里）
```

**🔸 依赖关系记忆**
- `Requires`：**强依赖**，必须成功
- `Wants`：**弱依赖**，最好有
- `After`：**顺序依赖**，之后启动

### 9.4 实际应用价值


**🎯 运维工作中的实用性**：
- **服务部署**：统一的服务管理方式
- **故障排查**：集中的日志查看
- **系统优化**：并行启动提升性能
- **自动化运维**：依赖管理简化部署

**🔧 开发工作中的应用**：
- **应用部署**：编写service文件部署应用
- **环境管理**：使用target管理不同运行环境
- **日志调试**：使用journalctl查看应用日志
- **进程监控**：利用systemd自动重启机制

> 🎓 **学习建议**
> 
> 1. **先理解概念**：systemd是什么，解决什么问题
> 2. **掌握基础命令**：systemctl的常用操作
> 3. **学会写配置**：简单的service文件编写
> 4. **实践操作**：在虚拟机中反复练习
> 
> 记住：systemd虽然功能强大，但核心就是**统一管理**，把复杂的事情变简单！