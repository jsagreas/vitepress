---
title: 10、信号机制与异步通信
---
## 📚 目录

1. [信号机制基础概念](#1-信号机制基础概念)
2. [标准信号与实时信号](#2-标准信号与实时信号)
3. [信号处理器注册与执行](#3-信号处理器注册与执行)
4. [信号掩码与阻塞机制](#4-信号掩码与阻塞机制)
5. [信号在多线程环境](#5-信号在多线程环境)
6. [信号发送命令详解](#6-信号发送命令详解)
7. [信号安全编程指南](#7-信号安全编程指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 信号机制基础概念


### 1.1 什么是信号


**🔸 信号的本质**
```
信号就像现实中的"通知"：
- 手机短信：异步通知，不需要立即处理
- 火警警报：紧急信号，需要立即响应
- 邮件提醒：可以暂时忽略，稍后处理

Linux信号 = 进程间的"短信通知"
```

> **💡 核心理解**：信号是Linux系统中进程间通信的一种异步机制，用于通知进程发生了某种事件

### 1.2 信号的工作流程


**📊 信号传递过程**
```
发送方进程          内核          接收方进程
    |                |                |
    |--[1]发送信号--->|                |
    |                |--[2]记录信号--->|
    |                |                |--[3]检查信号
    |                |                |--[4]执行处理器
    |                |<--[5]继续执行---|
```

**🔧 三种处理方式**
```
当进程收到信号时，可以选择：

1. 默认处理 (Default)：
   - 大部分信号：终止进程
   - SIGCHLD：忽略
   - SIGSTOP：停止进程

2. 忽略信号 (Ignore)：
   - 进程假装没收到这个信号
   - 注意：SIGKILL和SIGSTOP不能忽略

3. 自定义处理 (Custom Handler)：
   - 执行我们编写的处理函数
   - 处理完后继续原来的工作
```

### 1.3 常见信号速览表


| 信号名称 | **编号** | **默认行为** | **含义说明** |
|---------|---------|-------------|-------------|
| `SIGINT` | `2` | `终止` | **Ctrl+C中断信号，最常用** |
| `SIGQUIT` | `3` | `终止+核心转储` | **Ctrl+\退出信号** |
| `SIGKILL` | `9` | `强制终止` | **无法捕获的终止信号** |
| `SIGTERM` | `15` | `优雅终止` | **软件终止信号，默认kill命令** |
| `SIGCHLD` | `17` | `忽略` | **子进程状态改变通知** |
| `SIGUSR1` | `10` | `终止` | **用户自定义信号1** |
| `SIGUSR2` | `12` | `终止` | **用户自定义信号2** |

---

## 2. ⚖️ 标准信号与实时信号


### 2.1 标准信号特性


**🔸 标准信号（1-31号）**
```
特点就像"普通短信"：
✅ 历史悠久，兼容性好
❌ 不支持排队，同类型信号会丢失
❌ 不能携带数据
❌ 传递顺序不确定

实际例子：
如果连续发送3个SIGUSR1信号
→ 进程可能只收到1个！
```

**💻 标准信号演示**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void signal_handler(int sig) {
    printf("收到信号 %d\n", sig);
}

int main() {
    // 注册信号处理器
    signal(SIGUSR1, signal_handler);
    
    printf("进程PID: %d\n", getpid());
    printf("等待信号...\n");
    
    while(1) {
        sleep(1);
    }
    return 0;
}
```

### 2.2 实时信号特性


**🔸 实时信号（32-64号）**
```
特点就像"微信消息"：
✅ 支持排队，不会丢失
✅ 可以携带整数数据
✅ 按发送顺序传递
✅ 优先级高于标准信号

排队机制：
SIGRTMIN+1 → [消息1] [消息2] [消息3] → 按顺序处理
```

**📊 两种信号对比**

| 特性 | **标准信号** | **实时信号** |
|-----|-------------|-------------|
| **信号范围** | `1-31` | `SIGRTMIN-SIGRTMAX (32-64)` |
| **排队支持** | `❌ 不支持` | `✅ 支持排队` |
| **数据携带** | `❌ 无法携带` | `✅ 可携带int数据` |
| **传递顺序** | `不确定` | `先进先出(FIFO)` |
| **兼容性** | `极佳` | `较新系统支持` |

### 2.3 实时信号编程实例


**🔧 发送实时信号**
```c
#include <signal.h>
#include <sys/types.h>

// 发送带数据的实时信号
int send_realtime_signal(pid_t pid, int data) {
    union sigval value;
    value.sival_int = data;
    
    // 发送SIGRTMIN信号，携带数据
    return sigqueue(pid, SIGRTMIN, value);
}
```

**📝 接收实时信号**
```c
void rt_signal_handler(int sig, siginfo_t *info, void *context) {
    printf("收到实时信号: %d\n", sig);
    printf("携带数据: %d\n", info->si_value.sival_int);
    printf("发送者PID: %d\n", info->si_pid);
}

int main() {
    struct sigaction sa;
    sa.sa_sigaction = rt_signal_handler;
    sa.sa_flags = SA_SIGINFO;  // 启用扩展信息
    
    sigaction(SIGRTMIN, &sa, NULL);
    // ... 等待信号
}
```

---

## 3. 🔧 信号处理器注册与执行


### 3.1 signal() vs sigaction() 详解


**🔸 signal() - 简单但有缺陷**
```c
// 老式接口，简单但功能受限
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

问题：
❌ 行为在不同Unix系统间不一致
❌ 无法获取信号的详细信息
❌ 无法控制信号掩码
❌ 处理器可能被自动重置
```

**🔸 sigaction() - 现代推荐方式**
```c
int sigaction(int signum, 
              const struct sigaction *act,
              struct sigaction *oldact);

优势：
✅ 行为一致，POSIX标准
✅ 功能强大，选项丰富
✅ 可获取信号详细信息
✅ 可精确控制信号处理行为
```

### 3.2 sigaction结构详解


**📋 sigaction结构体**
```c
struct sigaction {
    // 三选一的处理器指定方式
    void (*sa_handler)(int);                    // 简单处理器
    void (*sa_sigaction)(int, siginfo_t*, void*); // 扩展处理器
    
    sigset_t sa_mask;      // 处理器执行时要阻塞的信号
    int sa_flags;          // 控制标志
    void (*sa_restorer)(void); // 已废弃，设为NULL
};
```

**🎯 重要标志位说明**

| 标志 | **作用** | **使用场景** |
|-----|---------|-------------|
| `SA_SIGINFO` | `使用sa_sigaction而非sa_handler` | **需要信号详细信息时** |
| `SA_RESTART` | `被信号中断的系统调用自动重启` | **避免EINTR错误** |
| `SA_NODEFER` | `处理器执行时不自动阻塞该信号` | **允许信号嵌套** |
| `SA_RESETHAND` | `信号处理后重置为默认行为` | **一次性处理器** |

### 3.3 完整的信号处理示例


```c
#include <signal.h>
#include <stdio.h>
#include <string.h>

// 扩展信号处理器
void enhanced_handler(int sig, siginfo_t *info, void *context) {
    printf("=== 信号详细信息 ===\n");
    printf("信号编号: %d\n", sig);
    printf("发送者PID: %d\n", info->si_pid);
    printf("信号产生原因: ");
    
    switch(info->si_code) {
        case SI_USER:    printf("用户发送\n"); break;
        case SI_KERNEL:  printf("内核发送\n"); break;
        case SI_QUEUE:   printf("sigqueue发送\n"); break;
        default:         printf("其他原因\n"); break;
    }
}

int main() {
    struct sigaction sa;
    
    // 清空结构体
    memset(&sa, 0, sizeof(sa));
    
    // 配置处理器
    sa.sa_sigaction = enhanced_handler;
    sa.sa_flags = SA_SIGINFO | SA_RESTART;
    
    // 设置处理器执行时要阻塞的信号
    sigemptyset(&sa.sa_mask);
    sigaddset(&sa.sa_mask, SIGUSR2);  // 处理SIGUSR1时阻塞SIGUSR2
    
    // 注册处理器
    if (sigaction(SIGUSR1, &sa, NULL) == -1) {
        perror("sigaction失败");
        return 1;
    }
    
    printf("进程PID: %d，等待SIGUSR1信号...\n", getpid());
    
    while(1) {
        pause();  // 等待信号
    }
    
    return 0;
}
```

**🧪 测试方法**
```bash
# 编译程序
gcc -o signal_demo signal_demo.c

# 运行程序（记录PID）
./signal_demo &

# 发送信号测试
kill -USR1 1234  # 替换为实际PID
```

---

## 4. 🛡️ 信号掩码与阻塞机制


### 4.1 信号掩码基本概念


**🔸 什么是信号掩码**
```
信号掩码就像"免打扰模式"：
📱 手机免打扰：屏蔽来电和短信
🔕 信号掩码：暂时屏蔽某些信号

被屏蔽的信号会"等待"：
- 信号不会丢失
- 解除屏蔽后立即传递
- 可以选择性屏蔽不同信号
```

### 4.2 信号集合操作


**📦 信号集合(sigset_t)操作**
```c
#include <signal.h>

sigset_t set;

// 初始化信号集合
sigemptyset(&set);    // 清空集合（所有信号都不在集合中）
sigfillset(&set);     // 填满集合（所有信号都在集合中）

// 添加/删除特定信号
sigaddset(&set, SIGUSR1);    // 添加SIGUSR1到集合
sigdelset(&set, SIGTERM);    // 从集合中删除SIGTERM

// 检查信号是否在集合中
if (sigismember(&set, SIGUSR1)) {
    printf("SIGUSR1在集合中\n");
}
```

### 4.3 进程信号掩码操作


**🔧 sigprocmask() 函数详解**
```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

**参数说明**：
- `how`：操作类型
- `set`：新的信号集合
- `oldset`：保存原来的信号掩码

| how参数 | **作用** | **理解方式** |
|---------|---------|-------------|
| `SIG_BLOCK` | `mask = mask ∪ set` | **添加屏蔽信号** |
| `SIG_UNBLOCK` | `mask = mask - set` | **解除屏蔽信号** |
| `SIG_SETMASK` | `mask = set` | **直接设置掩码** |

### 4.4 信号掩码实际应用


**💻 关键代码段保护示例**
```c
#include <signal.h>

void critical_work() {
    sigset_t newmask, oldmask;
    
    // 准备要屏蔽的信号集合
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);   // 屏蔽Ctrl+C
    sigaddset(&newmask, SIGTERM);  // 屏蔽终止信号
    
    // 设置信号掩码，保存原掩码
    sigprocmask(SIG_BLOCK, &newmask, &oldmask);
    
    printf("开始关键操作（不可中断）...\n");
    
    // 这里是关键代码，不能被信号中断
    for(int i = 0; i < 5; i++) {
        printf("正在处理 %d/5\n", i+1);
        sleep(1);
    }
    
    printf("关键操作完成\n");
    
    // 恢复原来的信号掩码
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
    
    printf("已恢复信号处理\n");
}
```

### 4.5 等待信号的安全方法


**🔸 sigsuspend() - 原子性等待**
```c
// 问题场景：检查条件和等待信号间的竞态条件
while (!condition) {
    pause();  // 危险！可能错过信号
}

// 解决方案：使用sigsuspend()
sigset_t mask, oldmask;

sigemptyset(&mask);
sigaddset(&mask, SIGUSR1);

// 屏蔽信号
sigprocmask(SIG_BLOCK, &mask, &oldmask);

while (!condition) {
    // 原子性地：恢复信号掩码 + 等待信号 + 重新设置掩码
    sigsuspend(&oldmask);
}

// 恢复掩码
sigprocmask(SIG_SETMASK, &oldmask, NULL);
```

**💡 sigsuspend优势**：
- ✅ 避免竞态条件
- ✅ 原子性操作
- ✅ 信号安全

---

## 5. 🧵 信号在多线程环境


### 5.1 多线程信号传递规则


**🔸 信号在多线程中的行为**
```
进程收到信号时的传递规则：

1. 同步信号（如SIGSEGV）：
   → 发送给产生该信号的线程

2. 异步信号（如SIGTERM）：
   → 发送给没有阻塞该信号的任意线程
   → 如果所有线程都阻塞，则挂起等待

3. 信号处理器：
   → 整个进程共享一套信号处理器
   → 任何线程都可以修改
```

### 5.2 多线程信号管理策略


**🎯 推荐做法：专门的信号处理线程**
```c
#include <pthread.h>
#include <signal.h>

void* signal_thread(void* arg) {
    sigset_t set;
    int sig;
    
    // 设置要处理的信号
    sigemptyset(&set);
    sigaddset(&set, SIGINT);
    sigaddset(&set, SIGTERM);
    sigaddset(&set, SIGUSR1);
    
    while (1) {
        // 等待信号（不使用信号处理器）
        sigwait(&set, &sig);
        
        switch (sig) {
            case SIGINT:
                printf("收到中断信号，开始优雅退出\n");
                // 设置退出标志，通知其他线程
                break;
                
            case SIGUSR1:
                printf("收到用户信号1\n");
                // 执行相应处理
                break;
                
            case SIGTERM:
                printf("收到终止信号\n");
                exit(0);
                break;
        }
    }
    return NULL;
}

int main() {
    pthread_t sig_thread;
    sigset_t set;
    
    // 在主线程中阻塞所有信号
    sigfillset(&set);
    pthread_sigmask(SIG_BLOCK, &set, NULL);
    
    // 创建专门处理信号的线程
    pthread_create(&sig_thread, NULL, signal_thread, NULL);
    
    // 其他工作线程
    // ...
    
    pthread_join(sig_thread, NULL);
    return 0;
}
```

### 5.3 线程信号掩码操作


**🔧 pthread_sigmask() 使用**
```c
// 线程级别的信号掩码操作
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);

// 线程特定信号发送
int pthread_kill(pthread_t thread, int sig);

示例：
sigset_t set;
sigemptyset(&set);
sigaddset(&set, SIGUSR1);

// 当前线程屏蔽SIGUSR1
pthread_sigmask(SIG_BLOCK, &set, NULL);

// 向特定线程发送信号
pthread_kill(target_thread, SIGUSR1);
```

---

## 6. 📤 信号发送命令详解


### 6.1 kill命令详解


**🔸 kill - 最基础的信号发送命令**
```bash
# 基本语法
kill [选项] [信号] PID

# 常用方式
kill 1234           # 发送SIGTERM（默认）
kill -9 1234        # 发送SIGKILL（强制终止）
kill -TERM 1234     # 发送SIGTERM（用名称）
kill -USR1 1234     # 发送SIGUSR1

# 查看所有信号
kill -l
# 输出：1) SIGHUP  2) SIGINT  3) SIGQUIT ...
```

**📊 常用信号对比**

| 信号 | **编号** | **作用** | **可捕获** | **使用场景** |
|-----|---------|---------|-----------|-------------|
| `TERM` | `15` | `优雅终止` | `✅` | **正常结束程序** |
| `KILL` | `9` | `强制终止` | `❌` | **程序无响应时** |
| `INT` | `2` | `中断` | `✅` | **模拟Ctrl+C** |
| `HUP` | `1` | `挂起/重载配置` | `✅` | **重载服务配置** |

### 6.2 killall命令详解


**🔸 killall - 按进程名发送信号**
```bash
# 语法
killall [选项] [信号] 进程名

# 实例
killall firefox          # 终止所有firefox进程
killall -9 python       # 强制终止所有python进程
killall -USR1 nginx      # 向所有nginx进程发送USR1信号

# 安全选项
killall -i vim           # 交互模式，每个进程都询问
killall -w vim           # 等待进程真正终止
```

**⚠️ killall注意事项**
```bash
# 危险操作示例
killall init     # 危险！不要对系统进程这样做
killall bash     # 可能终止你的shell会话

# 安全做法
killall -i firefox    # 使用交互模式
ps aux | grep firefox # 先查看进程再决定
```

### 6.3 pkill命令详解


**🔸 pkill - 最灵活的信号发送**
```bash
# 基本语法
pkill [选项] [信号] 模式

# 按进程名模式
pkill python         # 终止名称包含python的进程
pkill -f "python.*server"  # 按完整命令行匹配

# 按用户
pkill -u alice       # 终止alice用户的所有进程
pkill -u alice,bob   # 终止多个用户的进程

# 按父进程
pkill -P 1234        # 终止父进程ID为1234的子进程

# 组合条件
pkill -u alice -f firefox  # alice用户的firefox进程
```

### 6.4 信号发送编程实现


**💻 程序中发送信号**
```c
#include <signal.h>
#include <sys/types.h>

// 基本信号发送
int result = kill(target_pid, SIGUSR1);
if (result == -1) {
    perror("发送信号失败");
}

// 发送信号给进程组
kill(-group_id, SIGTERM);  // 负号表示进程组

// 发送实时信号（携带数据）
union sigval value;
value.sival_int = 42;
sigqueue(target_pid, SIGRTMIN, value);

// 检查进程是否存在
if (kill(pid, 0) == 0) {
    printf("进程 %d 存在\n", pid);
} else {
    printf("进程 %d 不存在\n", pid);
}
```

---

## 7. 🔒 信号安全编程指南


### 7.1 信号安全函数列表


**🔸 异步信号安全函数**
> **关键概念**：在信号处理器中只能调用异步信号安全的函数

**✅ 安全函数（部分列表）**
```c
// 文件操作
open(), close(), read(), write()

// 进程控制  
fork(), execve(), _exit()

// 信号相关
signal(), sigaction(), kill(), pause()

// 其他安全函数
time(), sleep(), alarm()
```

**❌ 不安全函数（禁用）**
```c
// 标准I/O库
printf(), scanf(), fopen(), fclose()

// 内存管理
malloc(), free(), calloc(), realloc()

// 字符串处理
strlen(), strcpy(), strcat()

// 线程相关
pthread_* 系列函数
```

### 7.2 信号处理器编程原则


**🎯 信号处理器最佳实践**

<details>
<summary>📋 **原则1：保持处理器简单**</summary>

```c
// ❌ 复杂的处理器（错误示例）
void bad_handler(int sig) {
    printf("收到信号 %d\n", sig);      // 不安全！
    FILE *fp = fopen("log.txt", "a");  // 不安全！
    fprintf(fp, "信号记录\n");          // 不安全！
    fclose(fp);                        // 不安全！
}

// ✅ 简单的处理器（正确示例）
volatile sig_atomic_t signal_received = 0;

void good_handler(int sig) {
    signal_received = sig;  // 只设置标志
}
```
</details>

<details>
<summary>📋 **原则2：使用sig_atomic_t类型**</summary>

```c
// 信号处理器中的变量必须是原子类型
volatile sig_atomic_t quit_flag = 0;
volatile sig_atomic_t reload_config = 0;

void signal_handler(int sig) {
    switch(sig) {
        case SIGTERM:
            quit_flag = 1;
            break;
        case SIGHUP:
            reload_config = 1;
            break;
    }
}
```
</details>

### 7.3 自写信号处理框架


**🔧 实用的信号处理框架**
```c
#include <signal.h>
#include <stdio.h>

// 信号状态记录
typedef struct {
    volatile sig_atomic_t sigint_count;
    volatile sig_atomic_t sigterm_received;
    volatile sig_atomic_t sigusr1_received;
} signal_status_t;

signal_status_t g_signals = {0};

// 统一的信号处理器
void universal_handler(int sig) {
    switch(sig) {
        case SIGINT:
            g_signals.sigint_count++;
            break;
        case SIGTERM:
            g_signals.sigterm_received = 1;
            break;
        case SIGUSR1:
            g_signals.sigusr1_received = 1;
            break;
    }
}

// 信号处理初始化
int init_signals() {
    struct sigaction sa;
    sa.sa_handler = universal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    
    if (sigaction(SIGINT, &sa, NULL) == -1) return -1;
    if (sigaction(SIGTERM, &sa, NULL) == -1) return -1;
    if (sigaction(SIGUSR1, &sa, NULL) == -1) return -1;
    
    return 0;
}

// 主程序循环
int main() {
    if (init_signals() == -1) {
        perror("信号初始化失败");
        return 1;
    }
    
    printf("程序运行中... PID: %d\n", getpid());
    
    while (1) {
        // 检查信号状态并处理
        if (g_signals.sigterm_received) {
            printf("收到终止信号，程序退出\n");
            break;
        }
        
        if (g_signals.sigusr1_received) {
            printf("收到USR1信号，执行特殊任务\n");
            g_signals.sigusr1_received = 0;  // 重置标志
        }
        
        if (g_signals.sigint_count > 0) {
            printf("收到 %d 次中断信号\n", g_signals.sigint_count);
            if (g_signals.sigint_count >= 3) {
                printf("连续收到3次中断，程序退出\n");
                break;
            }
        }
        
        // 正常业务逻辑
        sleep(1);
        printf("正在工作...\n");
    }
    
    return 0;
}
```

### 7.4 信号处理调试技巧


**🐛 信号调试方法**
```bash
# 1. 使用strace跟踪信号
strace -e trace=signal ./my_program

# 2. 使用gdb调试信号
gdb ./my_program
(gdb) handle SIGUSR1 nostop print
(gdb) run
(gdb) kill -USR1 进程PID

# 3. 查看进程信号状态
cat /proc/PID/status | grep Sig
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 信号本质：进程间异步通信机制，类似"通知消息"
🔸 信号类型：标准信号(1-31)和实时信号(32-64)
🔸 处理方式：默认处理、忽略信号、自定义处理器
🔸 注册接口：推荐sigaction()，避免signal()
🔸 掩码机制：临时屏蔽信号，实现原子操作
🔸 多线程：专门线程处理信号，避免竞态条件
🔸 发送命令：kill、killall、pkill各有特点
🔸 安全编程：处理器中只能调用安全函数
```

### 8.2 关键理解要点


**🔹 信号 vs 其他IPC机制**
```
信号特点：
✅ 轻量级，开销小
✅ 异步通信，不阻塞发送方
❌ 数据量有限（实时信号可携带一个整数）
❌ 可能丢失（标准信号）

适用场景：
- 进程控制（启动、停止、重载）
- 错误通知（段错误、管道破裂）
- 用户交互（Ctrl+C中断）
- 定时器通知（alarm信号）
```

**🔹 标准信号 vs 实时信号**
```
标准信号：历史悠久，兼容性好，但功能有限
实时信号：功能强大，支持排队，但需要较新系统

选择建议：
- 简单通知 → 使用标准信号
- 需要数据传递 → 使用实时信号
- 要求不丢失 → 使用实时信号
- 兼容老系统 → 使用标准信号
```

**🔹 信号安全编程要点**
```
核心原则：信号处理器要简单！

推荐模式：
1. 信号处理器只设置标志
2. 主程序循环检查标志
3. 在主程序中执行复杂逻辑
4. 使用sig_atomic_t类型
5. 多线程程序用专门线程处理信号
```

### 8.3 实际应用指导


**🎯 常见应用场景**

| 场景 | **推荐信号** | **处理方式** | **注意事项** |
|-----|-------------|-------------|-------------|
| **程序优雅退出** | `SIGTERM` | `设置退出标志` | **清理资源后退出** |
| **配置重载** | `SIGHUP` | `设置重载标志` | **重新读取配置文件** |
| **状态查询** | `SIGUSR1/USR2` | `打印状态信息` | **可用于调试** |
| **强制终止** | `SIGKILL` | `无法捕获` | **最后手段** |

**🔧 编程最佳实践**
```c
// 1. 统一的信号初始化
int setup_signals() {
    // 屏蔽所有信号，然后选择性处理
}

// 2. 简单的处理器
void handler(int sig) {
    // 只设置全局标志，不做复杂操作
}

// 3. 主循环处理
while (running) {
    if (signal_flags.reload) {
        reload_config();
        signal_flags.reload = 0;
    }
    // 正常业务逻辑
}
```

**📚 学习建议**
1. **先理解概念**：信号是什么，用来做什么
2. **掌握基础**：signal()和sigaction()的区别
3. **实践编程**：写简单的信号处理程序
4. **深入学习**：信号掩码、多线程环境
5. **应用实战**：在实际项目中使用信号

**💡 核心记忆口诀**：
- 信号通知异步传，三种处理方式选
- sigaction功能全，signal接口要慎用  
- 处理器要保简单，复杂逻辑放主线
- 掩码机制防竞态，多线程要专门管

**🔍 调试提示**：
- 使用`kill -l`查看所有信号
- 用`ps`和`pgrep`找到目标进程
- `strace`可以跟踪信号传递
- 信号处理器中避免调用不安全函数