---
title: 1、Linux进程调度器架构原理
---
## 📚 目录

1. [进程调度基础概念](#1-进程调度基础概念)
2. [CFS完全公平调度器深入解析](#2-CFS完全公平调度器深入解析)
3. [调度器类层次结构](#3-调度器类层次结构)
4. [运行队列与负载均衡](#4-运行队列与负载均衡)
5. [调度性能优化与参数调节](#5-调度性能优化与参数调节)
6. [多核系统调度策略](#6-多核系统调度策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🚀 进程调度基础概念


### 1.1 什么是进程调度


**进程调度**就像是一个**智能的交通指挥员**，负责决定哪个进程在什么时候使用CPU。

> 💡 **生活类比**：想象你是一个图书馆管理员，有很多读者要借书，但只有一个服务窗口。你需要决定先为谁服务，让大家都觉得公平，这就是调度的本质。

```
调度前景象：                调度后效果：
进程A -----> 等待         进程A =====> 运行中
进程B -----> 等待         进程B -----> 准备就绪  
进程C -----> 等待         进程C -----> 准备就绪
进程D -----> 等待         进程D -----> 准备就绪

调度器的作用：合理分配CPU时间，让系统高效运行
```

### 1.2 调度的核心目标


**🎯 调度器要达成的目标**：

| 目标 | **含义** | **实际表现** |
|------|---------|-------------|
| **响应性** | `用户操作要快速响应` | `点击程序立即打开` |
| **公平性** | `所有进程都能获得CPU时间` | `后台程序不会饿死` |
| **吞吐量** | `单位时间完成更多任务` | `系统整体效率高` |
| **低延迟** | `重要任务快速执行` | `音视频播放流畅` |

### 1.3 调度的基本概念


**🔸 时间片（Time Slice）**
```
时间片 = 进程连续运行的最大时间
就像：每个人最多可以连续使用10分钟的电脑

传统时间片问题：
- 时间片太长 → 响应慢
- 时间片太短 → 切换开销大
- 固定时间片 → 不够灵活
```

**🔸 抢占式调度（Preemptive Scheduling）**
```
抢占 = 高优先级进程可以打断正在运行的进程
就像：救护车可以插队，不用等红绿灯

非抢占调度：
进程A ========> 运行完毕才切换

抢占式调度：
进程A ====> 被打断
进程B =====> 紧急任务先执行
```

---

## 2. ⚖️ CFS完全公平调度器深入解析


### 2.1 CFS的设计哲学


**CFS（Completely Fair Scheduler）**的核心思想：**给每个进程公平的CPU时间**。

> 💭 **核心理念**：如果有一个"完美的多任务CPU"，能让所有进程同时以相同速度执行，那每个进程获得的时间就是完全公平的。CFS就是要模拟这种理想状态。

```
理想状态（不可能）：          CFS的近似实现：
进程A ================     进程A ==> 进程B ==> 进程C ==>
进程B ================     进程A ==> 进程B ==> 进程C ==>
进程C ================     进程A ==> 进程B ==> 进程C ==>
同时并行执行                快速轮换，近似并行效果
```

### 2.2 vruntime虚拟运行时间


**vruntime**是CFS的核心概念，可以理解为**进程的"欠债额度"**。

**🔸 vruntime计算原理**
```
基本公式：
vruntime += 实际运行时间 × (NICE_0_LOAD / 进程权重)

通俗解释：
- 进程运行时，vruntime不断增加
- 优先级高的进程，vruntime增加得慢（欠债少）
- 优先级低的进程，vruntime增加得快（欠债多）
```

**💡 vruntime示例**
```
假设3个进程同时启动：

进程A（nice=0，权重1024）运行100ms：
vruntime_A = 100ms × (1024/1024) = 100ms

进程B（nice=-5，权重3121，高优先级）运行100ms：
vruntime_B = 100ms × (1024/3121) ≈ 33ms

进程C（nice=5，权重335，低优先级）运行100ms：
vruntime_C = 100ms × (1024/335) ≈ 306ms

结果：B的vruntime最小，下次优先调度
```

### 2.3 红黑树调度结构


**CFS使用红黑树管理进程**，就像一个**自动排序的进程队列**。

```
红黑树结构示例：
                vruntime=50
               /           \
        vruntime=30      vruntime=80
         /      \         /        \
   vruntime=20 vruntime=40 vruntime=70 vruntime=90

调度规则：
1. 总是选择vruntime最小的进程（最左边的节点）
2. 进程运行后vruntime增加，重新插入树中
3. 自动维护按vruntime排序的结构
```

**🔧 红黑树的优势**
```
查找最小vruntime：O(1) 时间复杂度
插入新进程：O(log n) 时间复杂度
删除进程：O(log n) 时间复杂度

相比链表的优势：
- 不需要遍历整个队列找最小值
- 自动保持有序状态
- 插入删除效率高
```

### 2.4 调度延迟与最小粒度


**🔸 调度延迟（Scheduling Latency）**
```
调度延迟 = 所有可运行进程都至少运行一次所需的时间

默认值：6ms （sysctl_sched_latency）

含义：在6ms内，每个进程都能得到执行机会
```

**🔸 最小粒度（Minimum Granularity）**
```
最小粒度 = 单个进程最少运行时间

默认值：0.75ms （sysctl_sched_min_granularity）

作用：防止进程切换过于频繁
```

**💡 动态时间片计算**
```python
# CFS时间片计算伪代码
def calculate_time_slice(process):
    runnable_tasks = get_runnable_task_count()
    
    if runnable_tasks <= (sched_latency / min_granularity):
        # 进程数较少，使用标准调度延迟
        time_slice = sched_latency / runnable_tasks
    else:
        # 进程数过多，使用最小粒度
        time_slice = min_granularity
    
    # 根据进程权重调整
    time_slice = time_slice * (process.weight / NICE_0_LOAD)
    return time_slice

# 示例：
# 3个进程，调度延迟6ms：每个进程2ms
# 10个进程，调度延迟6ms：每个进程使用最小粒度0.75ms
```

---

## 3. 🏗️ 调度器类层次结构


### 3.1 sched_class调度类概念


Linux内核使用**分层调度架构**，就像**公司的部门层级结构**。

```
Linux调度类层次：
                    调度器框架
                        |
        ┌───────────────┼───────────────┐
        |               |               |
   stop_sched_class  rt_sched_class  fair_sched_class
   (停机调度类)      (实时调度类)    (公平调度类-CFS)
        |               |               |
    最高优先级       高优先级         普通优先级
```

### 3.2 各调度类详解


**🔸 stop_sched_class（停机调度类）**
```
优先级：最高
用途：系统停机、CPU热插拔等特殊任务
特点：可以抢占任何其他进程
示例：系统关机时的清理任务
```

**🔸 rt_sched_class（实时调度类）**
```
优先级：高于CFS
调度策略：
- SCHED_FIFO：先进先出，不被同级抢占
- SCHED_RR：轮转调度，有时间片限制

适用场景：
- 音视频处理
- 工业控制系统
- 高频交易系统
```

**🔸 fair_sched_class（公平调度类）**
```
优先级：普通级别
调度策略：
- SCHED_NORMAL：标准CFS调度
- SCHED_BATCH：批处理作业优化
- SCHED_IDLE：空闲时运行

适用场景：
- 大部分用户程序
- 后台服务
- 批量计算任务
```

### 3.3 调度类选择机制


**调度器按优先级顺序检查调度类**：

```
调度决策流程：
1. stop_sched_class.pick_next_task()
   └─ 有停机任务？ → 执行停机任务
   
2. rt_sched_class.pick_next_task()
   └─ 有实时任务？ → 执行实时任务
   
3. fair_sched_class.pick_next_task()
   └─ 执行CFS选中的任务
   
4. idle_sched_class.pick_next_task()
   └─ 系统空闲，运行idle进程
```

---

## 4. 🎯 运行队列与负载均衡


### 4.1 运行队列结构


**每个CPU核心都有自己的运行队列**，就像每个收银台都有自己的排队队伍。

```
多核系统运行队列示意：

CPU0运行队列          CPU1运行队列          CPU2运行队列
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   进程A     │      │   进程D     │      │   进程G     │
│   进程B     │      │   进程E     │      │   进程H     │
│   进程C     │      │   进程F     │      │             │
└─────────────┘      └─────────────┘      └─────────────┘
    负载：3             负载：2             负载：1
```

**🔸 运行队列的组成**
```c
struct cfs_rq {
    struct rb_root_cached tasks_timeline;  // 红黑树根节点
    struct rb_node *rb_leftmost;          // 最左节点（最小vruntime）
    unsigned int nr_running;               // 可运行进程数
    u64 min_vruntime;                     // 队列最小vruntime
    struct sched_entity *curr;            // 当前运行进程
    // ... 其他字段
};
```

### 4.2 负载均衡机制


**负载均衡**就像**商场的客流疏导**，避免某些收银台排队过长。

**🔸 负载计算方法**
```
负载权重计算：
CPU负载 = Σ(进程权重 × 进程在队列中的时间)

示例：
CPU0: 进程A(权重1024) + 进程B(权重512) = 负载1536
CPU1: 进程C(权重2048) = 负载2048
CPU2: 空闲 = 负载0

不均衡度 = max_load - min_load = 2048 - 0 = 2048
```

**🔸 负载均衡触发时机**
```
1. 定期负载均衡（每个tick）：
   - 检查CPU负载差异
   - 超过阈值时触发迁移

2. 新进程创建时：
   - 选择负载最轻的CPU
   - 考虑CPU亲和性

3. 进程唤醒时：
   - 评估是否需要迁移
   - 平衡性能和缓存局部性

4. 空闲负载均衡：
   - CPU空闲时主动拉取任务
   - 避免CPU闲置
```

**💡 负载均衡策略**
```
迁移决策考虑因素：

优先级排序：
1. 负载差异 > 阈值
2. 进程可迁移（未绑定特定CPU）
3. 迁移收益 > 迁移成本

成本收益分析：
迁移成本：缓存失效、TLB刷新、内存访问延迟
迁移收益：负载均衡、CPU利用率提升
```

### 4.3 CPU拓扑感知调度


**现代CPU有复杂的层次结构**，调度器需要**智能地理解硬件布局**。

```
典型CPU拓扑结构：
                    系统
                     |
              ┌──────┴──────┐
              |             |
           socket0       socket1
              |             |
        ┌─────┴─────┐ ┌─────┴─────┐
        |           | |           |
     core0       core1 core2   core3
        |           | |           |
    ┌───┴───┐  ┌───┴─┴──┐  ┌───┴───┐
   cpu0   cpu1 cpu2   cpu3 cpu4   cpu5
   (超线程)     (超线程)     (超线程)
```

**🔧 拓扑感知的调度优化**
```
调度域（Scheduling Domain）层次：

1. SMT域（超线程）：
   - cpu0和cpu1共享执行单元
   - 负载均衡频率最高

2. MC域（多核）：
   - core0和core1共享L3缓存
   - 中等频率的负载均衡

3. NODE域（NUMA节点）：
   - socket0和socket1内存访问不同
   - 较低频率的负载均衡

优化原则：
- 优先在同一缓存域内调度
- 减少跨NUMA节点的迁移
- 保持缓存热度和内存局部性
```

---

## 5. 🔧 调度性能优化与参数调节


### 5.1 关键调度参数


**Linux提供了丰富的调度参数**，让系统管理员可以**根据应用场景优化性能**。

**🔸 核心CFS参数**

| 参数名 | **默认值** | **含义** | **调优建议** |
|--------|----------|----------|------------|
| `sched_latency_ns` | `6ms` | `调度延迟` | `交互式应用调小，批处理调大` |
| `sched_min_granularity_ns` | `0.75ms` | `最小时间片` | `减少上下文切换开销` |
| `sched_wakeup_granularity_ns` | `1ms` | `唤醒粒度` | `影响进程抢占敏感度` |
| `sched_child_runs_first` | `0` | `子进程优先` | `fork密集场景可开启` |

**🔸 参数查看与修改**
```bash
# 查看当前调度参数
cat /proc/sys/kernel/sched_latency_ns
cat /proc/sys/kernel/sched_min_granularity_ns

# 临时修改参数
echo 4000000 > /proc/sys/kernel/sched_latency_ns  # 改为4ms

# 永久修改（/etc/sysctl.conf）
kernel.sched_latency_ns = 4000000
kernel.sched_min_granularity_ns = 500000
```

### 5.2 调度性能指标


**🔸 关键性能指标**
```bash
# 1. 上下文切换频率
sar -w 1  # 每秒上下文切换次数

# 2. CPU利用率分布
top -d 1  # 实时CPU使用情况

# 3. 平均负载
uptime    # 1分钟、5分钟、15分钟平均负载

# 4. 进程调度延迟
perf sched record -a -- sleep 10  # 记录调度事件
perf sched latency                 # 分析调度延迟
```

**💡 性能调优实例**
```bash
# 场景1：低延迟交互式系统
# 目标：提高响应速度
echo 3000000 > /proc/sys/kernel/sched_latency_ns      # 3ms
echo 400000 > /proc/sys/kernel/sched_min_granularity_ns # 0.4ms

# 场景2：高吞吐批处理系统
# 目标：减少上下文切换开销
echo 12000000 > /proc/sys/kernel/sched_latency_ns     # 12ms
echo 1500000 > /proc/sys/kernel/sched_min_granularity_ns # 1.5ms

# 场景3：多媒体实时处理
# 配合实时调度策略
chrt -f 50 your_media_app  # FIFO调度，优先级50
```

### 5.3 进程优先级调整


**🔸 Nice值调整**
```bash
# Nice值范围：-20（最高优先级）到 +19（最低优先级）

# 启动时设置nice值
nice -n 10 your_program    # 降低优先级

# 运行时调整nice值
renice -n 5 -p 1234       # 进程1234的nice值改为5
renice -n -5 -u alice     # 用户alice的所有进程nice值改为-5

# 批量调整
for pid in $(pgrep firefox); do
    renice -n 10 -p $pid  # 所有firefox进程降低优先级
done
```

**🔸 实时优先级设置**
```bash
# 查看支持的调度策略
chrt -m

# 设置FIFO实时调度
chrt -f 50 your_rt_app     # 实时优先级50，FIFO策略

# 设置RR轮转调度
chrt -r 30 your_rt_app     # 实时优先级30，RR策略

# 查看进程调度信息
chrt -p 1234               # 查看进程1234的调度策略和优先级
```

---

## 6. 🌐 多核系统调度策略


### 6.1 SMP调度挑战


**多核调度**就像**管理多个施工队**，既要保证每个队伍有活干，又要避免相互干扰。

**🔸 多核调度的核心挑战**
```
1. 负载均衡 vs 缓存局部性
   均衡：所有CPU都有任务执行
   局部性：进程尽量在同一CPU上运行

2. 扩展性问题
   CPU数量增加时，调度算法复杂度不能线性增长

3. NUMA感知
   不同CPU访问内存的延迟差异很大

4. 功耗优化
   在性能和功耗之间找到平衡
```

### 6.2 CPU亲和性管理


**CPU亲和性**就像给进程**指定专用的工作台**，提高工作效率。

```bash
# 查看进程的CPU亲和性
taskset -p 1234

# 设置进程只在CPU 0和1上运行
taskset -pc 0,1 1234

# 启动程序时指定CPU
taskset -c 2,3 your_program

# 绑定到特定CPU核心
taskset -c 4 intensive_task    # 只在CPU4上运行
```

**💡 亲和性设置策略**
```
应用场景分析：

1. 计算密集型任务：
   - 绑定到特定CPU核心
   - 避免缓存失效
   - 示例：科学计算、加密运算

2. I/O密集型任务：
   - 允许在多个CPU间迁移
   - 提高I/O并发处理能力
   - 示例：web服务器、数据库

3. 实时任务：
   - 隔离专用CPU核心
   - 避免被其他进程干扰
   - 示例：音视频处理、控制系统
```

### 6.3 NUMA感知调度


**NUMA（Non-Uniform Memory Access）**环境下，**内存访问速度因距离而异**。

```
NUMA拓扑示例：
Node 0:                    Node 1:
┌─────────────────┐       ┌─────────────────┐
│ CPU 0-7         │←─────→│ CPU 8-15        │
│ Memory 0-31GB   │  互联  │ Memory 32-63GB  │
└─────────────────┘       └─────────────────┘

内存访问延迟：
- 本地内存：100ns
- 远程内存：150ns（慢50%）
```

**🔸 NUMA优化策略**
```bash
# 查看NUMA拓扑
numactl --hardware

# 查看进程的NUMA策略
numactl --show

# 绑定进程到特定NUMA节点
numactl --cpunodebind=0 --membind=0 your_program

# 交错内存分配
numactl --interleave=all memory_intensive_app

# 查看NUMA使用统计
numastat
```

### 6.4 CPU隔离与专用核心


**CPU隔离**就像为重要任务**预留专用车道**，保证关键应用不被打扰。

```bash
# 内核启动参数中隔离CPU
# /etc/default/grub
GRUB_CMDLINE_LINUX="isolcpus=2,3,6,7"

# 重新生成grub配置
update-grub

# 查看隔离的CPU
cat /sys/devices/system/cpu/isolated
```

**💡 CPU隔离应用场景**
```
1. 高频交易系统：
   - 隔离CPU2,3专门处理交易
   - 最小化调度延迟

2. 实时控制系统：
   - 专用核心处理控制循环
   - 避免被系统任务干扰

3. 网络包处理：
   - DPDK应用绑定专用CPU
   - 旁路内核网络栈

配置示例：
# 隔离CPU 4-7，绑定应用
isolcpus=4-7
# 应用启动
taskset -c 4 critical_app_1
taskset -c 5 critical_app_2
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🔸 进程调度基础**
```
- 调度器 = CPU时间的分配管理者
- 目标：响应性、公平性、吞吐量、低延迟的平衡
- 抢占式调度允许高优先级任务打断低优先级任务
```

**🔸 CFS完全公平调度器**
```
- vruntime = 进程的"时间债务"，越小越优先
- 红黑树维护按vruntime排序的进程队列  
- 调度延迟和最小粒度控制进程切换频率
- 权重机制实现优先级差异化
```

**🔸 调度器架构**
```
- 分层结构：stop > rt > fair > idle
- 每个调度类处理不同类型的任务
- sched_class提供统一的调度接口
```

### 7.2 关键理解要点


**🔹 为什么CFS比传统调度器更公平**
```
传统时间片调度：
- 固定时间片，无法适应不同负载
- 优先级调整困难
- 容易出现饥饿现象

CFS优势：
- vruntime自动平衡，天然公平
- 动态时间片，适应系统负载
- 红黑树结构，调度效率高
- 权重机制，优先级调整精确
```

**🔹 多核调度的复杂性**
```
单核调度：简单的进程队列管理
多核调度：涉及多个维度
- 负载均衡：避免CPU空闲或过载
- 缓存局部性：减少缓存失效
- NUMA感知：优化内存访问
- 功耗考虑：平衡性能和能耗
```

**🔹 调度参数调优的原则**
```
交互式应用：
- 减小调度延迟（sched_latency_ns）
- 提高响应速度

批处理应用：
- 增大最小粒度（sched_min_granularity_ns）
- 减少上下文切换开销

实时应用：
- 使用RT调度类
- 配合CPU隔离和亲和性
```

### 7.3 实际应用指导


**🎯 性能优化实践**
```bash
# 1. 诊断调度问题
perf sched record -a -- sleep 10  # 记录调度活动
perf sched latency                 # 分析调度延迟
sar -w 1                          # 监控上下文切换

# 2. 交互式系统优化
echo 4000000 > /proc/sys/kernel/sched_latency_ns

# 3. 批处理系统优化  
nice -n 10 batch_job              # 降低批处理优先级

# 4. 实时应用配置
chrt -f 50 realtime_app           # 设置实时优先级
taskset -c 2,3 realtime_app       # 绑定专用CPU
```

**🔧 故障排查思路**
```
调度相关性能问题排查：

1. 系统负载异常 → 检查平均负载和CPU使用率
2. 响应延迟高 → 分析调度延迟和上下文切换
3. 特定应用慢 → 检查进程优先级和CPU亲和性
4. 多核利用率低 → 分析负载均衡和NUMA配置
```

### 7.4 核心记忆要点


> 💡 **CFS调度口诀**：
> vruntime小者先运行，红黑树中找最优
> 权重影响时间债，公平调度不饥饿

> 🎯 **多核优化原则**：
> 亲和性提高缓存效率，负载均衡避免闲置
> NUMA感知减少延迟，隔离核心保证实时

> ⚡ **调优三步曲**：
> 测量当前性能基线，识别瓶颈根本原因
> 调整参数验证效果，监控确保稳定运行

**实用记忆**：
- **CFS = 完全公平 = vruntime最小优先**
- **多核 = 均衡负载 + 缓存局部性**
- **调优 = 测量诊断 + 参数调整 + 效果验证**