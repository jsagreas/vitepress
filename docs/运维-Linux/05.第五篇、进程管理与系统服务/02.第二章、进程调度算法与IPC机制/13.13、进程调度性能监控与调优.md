---
title: 13、进程调度性能监控与调优
---
## 📚 目录

1. [进程调度监控基础](#1-进程调度监控基础)
2. [调度信息查看工具详解](#2-调度信息查看工具详解)
3. [调度参数调整与工具](#3-调度参数调整与工具)
4. [性能指标监控与分析](#4-性能指标监控与分析)
5. [调度器参数调优实践](#5-调度器参数调优实践)
6. [生产环境优化案例](#6-生产环境优化案例)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 进程调度监控基础


### 1.1 什么是进程调度监控


> 💡 **简单理解**：进程调度监控就像是给系统装了个"体检仪"，随时观察CPU如何分配时间给不同程序

**核心概念**：
```
进程调度监控 = 观察 + 测量 + 分析
• 观察：哪些进程在运行，运行多长时间
• 测量：CPU利用率、响应时间、切换频率
• 分析：找出性能瓶颈，制定优化策略
```

**为什么需要监控**：
- **性能问题定位**：找出是哪个进程拖慢了系统
- **资源使用优化**：合理分配CPU时间
- **用户体验改善**：减少程序卡顿和延迟

### 1.2 调度监控的关键指标


**CPU使用率指标**：
```
┌─ CPU使用率类型 ─────────────┐
│ • user：用户程序占用时间   │
│ • system：内核占用时间     │
│ • idle：CPU空闲时间       │
│ • iowait：等待IO的时间    │
│ • irq：处理中断的时间     │
└────────────────────────────┘
```

**调度延迟指标**：
- **响应时间**：从进程变为可运行到实际运行的时间
- **调度延迟**：进程等待被调度的时间
- **上下文切换**：CPU在不同进程间切换的频率

---

## 2. 🛠️ 调度信息查看工具详解


### 2.1 /proc/sched_debug - 调度器调试信息


> 🔑 **核心理解**：`/proc/sched_debug`是Linux内核提供的"调度器仪表盘"，显示详细的调度状态

**基本用法**：
```bash
# 查看调度器调试信息
cat /proc/sched_debug

# 更友好的格式查看
cat /proc/sched_debug | head -50
```

**输出信息解读**：
```
Sched Debug Version: v0.11, 4.15.0 #1
ktime                                   : 12345678.123456
sched_clk                               : 12345678.123456
cpu_clk                                 : 12345678.123456
jiffies                                 : 4294967295

# 重要字段含义：
• ktime: 内核时间戳
• sched_clk: 调度器时钟
• cpu_clk: CPU时钟
• jiffies: 系统滴答计数
```

**CPU运行队列信息**：
```bash
# 查看特定CPU的运行队列
grep -A 20 "cpu#0" /proc/sched_debug

# 典型输出解析
cpu#0, 2400.000 MHz
  .nr_running                    : 3        # 当前运行队列中的进程数
  .load                          : 1024     # 负载值
  .nr_switches                   : 1234567  # 总切换次数
  .nr_load_updates              : 123456   # 负载更新次数
  .nr_uninterruptible           : 0        # 不可中断进程数
```

### 2.2 schedtool - 调度参数调整工具


**安装schedtool**：
```bash
# Ubuntu/Debian系统
sudo apt-get install schedtool

# CentOS/RHEL系统  
sudo yum install schedtool
```

**基本使用方法**：

**查看进程调度信息**：
```bash
# 查看指定进程的调度策略
schedtool PID

# 示例输出
PID   1234: PRIO   0, POLICY N: SCHED_NORMAL, NICE   0
#     进程ID  优先级    调度策略      nice值
```

**调整进程调度策略**：
```bash
# 设置为实时调度策略
schedtool -f -p 50 PID    # SCHED_FIFO, 优先级50

# 设置为循环调度策略  
schedtool -r -p 50 PID    # SCHED_RR, 优先级50

# 设置为普通调度策略
schedtool -n -p 10 PID    # SCHED_NORMAL, nice值10

# 启动程序时指定调度策略
schedtool -f -p 80 -e ./重要程序
```

> ⚠️ **重要提醒**：实时调度策略需要root权限，设置不当可能导致系统卡死

### 2.3 perf sched - 调度事件追踪


**perf工具简介**：
```
perf是什么？
就像是系统的"行车记录仪"，记录所有调度事件
可以看到：
• 进程什么时候运行
• 运行了多长时间  
• 什么时候被切换
• 在哪个CPU上运行
```

**基本使用**：
```bash
# 记录调度事件（运行10秒）
sudo perf sched record -- sleep 10

# 生成调度报告
perf sched report

# 查看调度延迟统计
perf sched latency
```

**调度延迟分析示例**：
```bash
# 运行调度延迟分析
perf sched latency

# 典型输出
-------------------------------------------------
 Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at     |
-------------------------------------------------
 firefox:1234          |    1205.123   |      456 |        2.34      |       15.67      | 12345.678 s
 chrome:5678           |     856.789   |      321 |        1.89      |       12.34      | 12346.123 s
```

**实时调度监控**：
```bash
# 实时查看调度事件（类似top，但针对调度）
perf top -e sched:sched_switch

# 查看调度统计信息
perf stat -e sched:sched_switch ./程序
```

---

## 3. ⚙️ 调度参数调整与工具


### 3.1 nice和renice命令


> 💭 **生活类比**：nice值就像是排队时的"优先券"，数字越小优先级越高

**nice命令 - 启动时设置优先级**：
```bash
# nice值范围：-20到19，数字越小优先级越高
# 普通用户只能设置0-19，root可以设置-20到19

# 以低优先级运行程序（nice值10）
nice -n 10 ./计算密集程序

# 以高优先级运行重要程序（需要root）
sudo nice -n -10 ./重要服务

# 查看程序的nice值
ps -l PID
```

**renice命令 - 运行时调整优先级**：
```bash
# 调整正在运行进程的nice值
renice 5 PID              # 设置nice值为5
renice -n -5 PID          # 设置nice值为-5（需要root）

# 按用户调整所有进程
renice 10 -u username     # 调整用户的所有进程

# 按进程组调整
renice 5 -g pgrp_id       # 调整进程组的所有进程
```

### 3.2 实时进程优先级设置


**理解实时优先级**：
```
实时优先级 vs 普通优先级：

普通进程（SCHED_NORMAL）：
priority = 20 + nice值
范围：0-39（数字越小优先级越高）

实时进程（SCHED_FIFO/SCHED_RR）：
priority = 1-99（数字越大优先级越高）
总是比普通进程优先级高
```

**chrt命令 - 实时调度设置**：
```bash
# 查看进程的调度策略和优先级
chrt -p PID

# 设置为FIFO调度策略
chrt -f -p 50 PID         # 优先级50的FIFO

# 设置为轮转调度策略  
chrt -r -p 50 PID         # 优先级50的RR

# 启动时设置实时调度
chrt -f 80 ./实时程序      # 高优先级实时程序
```

**实际应用场景**：
```bash
# 音频处理程序需要低延迟
chrt -f 70 ./音频服务

# 视频编码程序占用资源大，降低优先级
nice -n 15 ./视频编码

# 数据库服务需要稳定性能
chrt -f 50 ./数据库服务
```

---

## 4. 📊 性能指标监控与分析


### 4.1 调度延迟与响应时间测量


**什么是调度延迟**：
```
调度延迟流程：
进程变为可运行 → 等待调度 → 实际运行
        ↑_____调度延迟_____↑

影响因素：
• 系统负载高低
• 调度策略设置
• CPU核心数量
• 中断处理频率
```

**测量工具和方法**：

**cyclictest - 实时性测量**：
```bash
# 安装cyclictest
sudo apt-get install rt-tests

# 基本延迟测试（运行60秒）
sudo cyclictest -t 1 -p 99 -n -D 60

# 多线程测试（每个CPU核心一个线程）
sudo cyclictest -t $(nproc) -p 99 -n -D 60

# 典型输出解析
T: 0 ( 1234) P:99 I:1000 C: 59234 Min:    5 Act:    8 Avg:   12 Max:  156
# T:线程ID P:优先级 I:间隔 C:循环次数 Min:最小延迟 Act:当前延迟 Avg:平均延迟 Max:最大延迟
```

**自定义延迟测试脚本**：
```bash
#!/bin/bash
# 简单的调度延迟测试

echo "开始调度延迟测试..."
for i in {1..100}; do
    start_time=$(date +%s%N)
    taskset -c 0 sleep 0.001  # 在CPU0上短暂睡眠
    end_time=$(date +%s%N)
    
    delay=$((($end_time - $start_time) / 1000))  # 转换为微秒
    echo "测试 $i: 延迟 $delay 微秒"
done
```

### 4.2 CPU使用率与上下文切换统计


**vmstat - 系统整体统计**：
```bash
# 每秒更新一次，共显示10次
vmstat 1 10

# 输出解析
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0 1234567  12345 123456    0    0     5    10  123  456 15  5 78  2  0

# 重要字段：
# r: 运行队列长度（等待CPU的进程数）
# cs: 每秒上下文切换次数
# us: 用户空间CPU使用百分比
# sy: 内核空间CPU使用百分比  
# id: CPU空闲百分比
# wa: 等待IO的CPU百分比
```

**sar - 详细系统活动报告**：
```bash
# 安装sar（通常在sysstat包中）
sudo apt-get install sysstat

# 每秒监控CPU使用率
sar -u 1 10

# 监控上下文切换和中断
sar -w 1 10

# 查看历史数据
sar -u -f /var/log/sysstat/saXX  # XX是日期
```

**pidstat - 进程级别统计**：
```bash
# 监控所有进程的CPU使用率
pidstat 1 10

# 监控特定进程
pidstat -p PID 1 10

# 监控上下文切换
pidstat -w 1 10

# 输出示例
Average:      PID    %usr %system  %guest    %CPU   CPU  Command
Average:     1234    2.50    1.20    0.00    3.70     -  firefox
Average:     5678    1.80    0.90    0.00    2.70     -  chrome
```

### 4.3 负载均衡效果评估


**理解负载均衡**：
```
什么是负载均衡？
就像是工厂的流水线分工：
• 理想情况：每个CPU核心工作量差不多
• 问题情况：有的核心很忙，有的核心很闲
• 负载均衡器：自动调节各核心的工作分配
```

**查看各CPU核心负载**：
```bash
# 查看每个CPU核心的使用率
mpstat -P ALL 1 5

# 输出示例
Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
Average:     all    12.34    0.00    5.67    2.13    0.00    1.23    0.00    0.00    0.00   78.63
Average:       0    15.23    0.00    6.78    1.89    0.00    1.45    0.00    0.00    0.00   74.65
Average:       1    10.12    0.00    4.89    2.34    0.00    0.98    0.00    0.00    0.00   81.67
Average:       2    11.45    0.00    5.23    2.01    0.00    1.12    0.00    0.00    0.00   80.19
Average:       3    12.89    0.00    6.12    2.45    0.00    1.34    0.00    0.00    0.00   77.20
```

**CPU亲和性设置**：
```bash
# 查看进程运行在哪些CPU上
taskset -cp PID

# 设置进程只在特定CPU上运行
taskset -cp 0,1 PID        # 只在CPU 0和1上运行
taskset -cp 0-3 PID        # 在CPU 0到3上运行

# 启动时设置CPU亲和性
taskset -c 2 ./程序         # 只在CPU 2上运行
```

**负载均衡监控脚本**：
```bash
#!/bin/bash
# CPU负载均衡监控

echo "=== CPU负载均衡检查 ==="
mpstat -P ALL 1 1 | grep -E "Average.*[0-9]" | while read line; do
    cpu=$(echo $line | awk '{print $2}')
    idle=$(echo $line | awk '{print $12}')
    used=$(echo "100 - $idle" | bc)
    
    if (( cpu != "all" )); then
        echo "CPU $cpu: 使用率 ${used}%"
    fi
done
```

---

## 5. 🔧 调度器参数调优实践


### 5.1 /sys/kernel/sched参数详解


**调度器参数目录结构**：
```bash
# 查看所有可调参数
ls -la /sys/kernel/sched/
find /proc/sys/kernel/ -name "*sched*"

# 常见参数位置
/proc/sys/kernel/sched_min_granularity_ns    # 最小调度粒度
/proc/sys/kernel/sched_wakeup_granularity_ns # 唤醒粒度
/proc/sys/kernel/sched_latency_ns            # 调度延迟
/proc/sys/kernel/sched_child_runs_first      # 子进程优先运行
```

**核心参数含义与调优**：

**sched_min_granularity_ns - 最小时间片**：
```bash
# 查看当前值（纳秒）
cat /proc/sys/kernel/sched_min_granularity_ns
# 默认值通常是 2250000 (2.25ms)

# 调优建议：
# 减小值：提高响应性，但增加切换开销
echo 1000000 > /proc/sys/kernel/sched_min_granularity_ns  # 1ms

# 增大值：减少切换开销，但可能影响响应性
echo 4000000 > /proc/sys/kernel/sched_min_granularity_ns  # 4ms
```

**sched_latency_ns - 调度周期**：
```bash
# 查看调度周期
cat /proc/sys/kernel/sched_latency_ns
# 默认值通常是 18000000 (18ms)

# 调优原理：
# 调度周期 ÷ 活跃进程数 = 每进程时间片
# 18ms ÷ 4个进程 = 每个进程4.5ms

# 低延迟系统调优
echo 10000000 > /proc/sys/kernel/sched_latency_ns  # 10ms

# 高吞吐系统调优  
echo 30000000 > /proc/sys/kernel/sched_latency_ns  # 30ms
```

### 5.2 实际调优案例


**Web服务器调优**：
```bash
#!/bin/bash
# Web服务器响应性优化

echo "=== Web服务器调度调优 ==="

# 减少调度延迟，提高响应性
echo 1500000 > /proc/sys/kernel/sched_min_granularity_ns
echo 12000000 > /proc/sys/kernel/sched_latency_ns  
echo 3000000 > /proc/sys/kernel/sched_wakeup_granularity_ns

# 设置Web服务进程为高优先级
if pgrep nginx > /dev/null; then
    for pid in $(pgrep nginx); do
        renice -10 $pid
        echo "调整nginx进程 $pid 优先级"
    done
fi

echo "Web服务器调优完成"
```

**数据库服务器调优**：
```bash
#!/bin/bash
# 数据库服务器稳定性优化

echo "=== 数据库服务器调度调优 ==="

# 适中的调度参数，平衡响应性和稳定性
echo 2000000 > /proc/sys/kernel/sched_min_granularity_ns
echo 20000000 > /proc/sys/kernel/sched_latency_ns

# 数据库进程使用实时调度
if pgrep mysqld > /dev/null; then
    db_pid=$(pgrep mysqld)
    chrt -f -p 30 $db_pid
    echo "设置MySQL实时调度，优先级30"
fi

# 绑定数据库到特定CPU核心（避免迁移开销）
taskset -cp 0,1 $(pgrep mysqld)

echo "数据库调优完成"
```

**实时音频系统调优**：
```bash
#!/bin/bash
# 音频系统低延迟调优

echo "=== 实时音频系统调优 ==="

# 最小调度粒度和延迟
echo 500000 > /proc/sys/kernel/sched_min_granularity_ns   # 0.5ms
echo 5000000 > /proc/sys/kernel/sched_latency_ns          # 5ms
echo 500000 > /proc/sys/kernel/sched_wakeup_granularity_ns

# 音频进程最高实时优先级
if pgrep jackd > /dev/null; then
    audio_pid=$(pgrep jackd)
    chrt -f -p 95 $audio_pid
    echo "设置JACK音频服务最高优先级"
fi

echo "音频系统调优完成"
```

---

## 6. 🏭 生产环境优化案例


### 6.1 高并发Web应用优化


**问题场景**：
```
问题描述：
电商网站在促销期间出现：
• 页面响应慢，用户等待时间长
• CPU使用率不均匀
• 频繁的上下文切换

诊断过程：
1. 监控发现CPU使用率80%+，但响应慢
2. 上下文切换每秒10000+次
3. 部分CPU核心满载，部分核心空闲
```

**诊断命令**：
```bash
# 1. 查看系统整体负载
vmstat 1 5

# 2. 查看各CPU核心使用情况  
mpstat -P ALL 1 5

# 3. 查看上下文切换详情
pidstat -w 1 5

# 4. 查看调度延迟
perf sched latency
```

**优化方案**：
```bash
#!/bin/bash
# 高并发Web应用调度优化

echo "=== 高并发Web应用优化 ==="

# 1. 调整调度器参数
# 减少最小粒度，提高响应性
echo 1000000 > /proc/sys/kernel/sched_min_granularity_ns

# 适当减少调度周期
echo 15000000 > /proc/sys/kernel/sched_latency_ns

# 2. 设置Web服务器进程亲和性
web_pids=$(pgrep -f "nginx\|apache2\|httpd")
cpu_count=$(nproc)

i=0
for pid in $web_pids; do
    cpu_id=$((i % cpu_count))
    taskset -cp $cpu_id $pid
    echo "绑定进程 $pid 到 CPU $cpu_id"
    i=$((i + 1))
done

# 3. 调整Web服务进程优先级
for pid in $web_pids; do
    renice -5 $pid
done

echo "Web应用优化完成"
```

**优化效果**：
- 平均响应时间从500ms降到200ms
- 上下文切换减少40%
- CPU负载分布更均匀

### 6.2 批处理作业调度优化


**问题场景**：
```
问题描述：
大数据处理任务影响在线服务：
• 批处理作业占用大量CPU
• 在线服务响应时间增加
• 系统整体性能下降

需求：
• 批处理任务要完成，但优先级要低
• 保证在线服务的响应性能
• 合理利用系统资源
```

**优化策略**：
```bash
#!/bin/bash
# 批处理作业调度优化

echo "=== 批处理作业调度优化 ==="

# 1. 识别批处理进程
batch_keywords="python.*batch\|java.*batch\|./data_process"
batch_pids=$(pgrep -f "$batch_keywords")

if [ -z "$batch_pids" ]; then
    echo "未发现批处理进程"
    exit 1
fi

# 2. 降低批处理任务优先级
for pid in $batch_pids; do
    # 设置最低nice值（最低优先级）
    renice 19 $pid
    echo "设置批处理进程 $pid nice值为19"
    
    # 限制到特定CPU核心（避免影响关键服务）
    cpu_count=$(nproc)
    batch_cpus="$((cpu_count/2))-$((cpu_count-1))"  # 使用后半部分CPU
    taskset -cp $batch_cpus $pid
    echo "限制进程 $pid 到CPU $batch_cpus"
done

# 3. 设置CPU使用限制（可选，需要cgroups）
if [ -d /sys/fs/cgroup/cpu ]; then
    # 创建批处理cgroup
    mkdir -p /sys/fs/cgroup/cpu/batch_jobs
    echo 50000 > /sys/fs/cgroup/cpu/batch_jobs/cpu.cfs_quota_us  # 限制50%CPU
    
    # 将批处理进程加入cgroup
    for pid in $batch_pids; do
        echo $pid > /sys/fs/cgroup/cpu/batch_jobs/tasks
    done
    
    echo "设置批处理任务CPU使用限制为50%"
fi

echo "批处理优化完成"
```

### 6.3 实时系统调度优化


**问题场景**：
```
应用场景：工业控制系统
要求：
• 控制信号必须在1ms内响应
• 数据采集间隔精确
• 系统不能出现长时间阻塞

挑战：
• Linux不是硬实时系统
• 需要最小化调度延迟
• 处理中断优先级
```

**完整优化方案**：
```bash
#!/bin/bash
# 实时系统调度优化

echo "=== 实时系统调度优化 ==="

# 1. 系统级调度参数调优
# 最小调度粒度500微秒
echo 500000 > /proc/sys/kernel/sched_min_granularity_ns
echo 2000000 > /proc/sys/kernel/sched_latency_ns
echo 250000 > /proc/sys/kernel/sched_wakeup_granularity_ns

# 2. 内存管理优化（避免页面交换导致延迟）
echo 1 > /proc/sys/vm/swappiness  # 最小化交换
sysctl -w vm.min_free_kbytes=65536  # 保留足够空闲内存

# 3. 中断处理优化
# 查找实时控制设备的中断
control_irq=$(grep "控制设备" /proc/interrupts | awk '{print $1}' | tr -d ':')
if [ -n "$control_irq" ]; then
    # 设置中断亲和性到单独CPU
    echo 1 > /proc/irq/$control_irq/smp_affinity
    echo "控制设备中断绑定到CPU 0"
fi

# 4. 实时进程设置
rt_process="real_time_control"
rt_pid=$(pgrep -f $rt_process)

if [ -n "$rt_pid" ]; then
    # 最高实时优先级
    chrt -f -p 99 $rt_pid
    
    # 绑定到专用CPU核心
    taskset -cp 1 $rt_pid
    
    # 锁定内存页面（避免页面交换）
    echo -1000 > /proc/$rt_pid/oom_score_adj  # 避免被OOM killer杀死
    
    echo "实时控制进程优化完成"
else
    echo "未找到实时控制进程"
fi

# 5. 创建实时监控
cat > /tmp/rt_monitor.sh << 'EOF'
#!/bin/bash
while true; do
    latency=$(cyclictest -t1 -p99 -n -q -D 1 | grep "Max:" | awk '{print $2}')
    if [ "$latency" -gt 1000 ]; then  # 如果延迟超过1ms
        echo "警告：调度延迟 ${latency}μs 超过阈值" | logger -t RT_MONITOR
    fi
    sleep 10
done
EOF

chmod +x /tmp/rt_monitor.sh
nohup /tmp/rt_monitor.sh &

echo "实时系统优化完成"
echo "实时监控已启动"
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 调度监控本质：观察CPU如何分配时间给进程
🔸 关键工具：/proc/sched_debug、schedtool、perf sched
🔸 重要指标：CPU使用率、上下文切换、调度延迟
🔸 参数调优：/sys/kernel/sched下的调度器参数
🔸 优化策略：根据应用场景选择合适的调度策略
```

### 7.2 关键理解要点


**🔹 调度延迟的影响**
```
调度延迟直接影响系统响应性：
• Web服务：延迟影响用户体验
• 数据库：延迟影响事务处理
• 实时系统：延迟可能导致控制失效

优化思路：
• 减少调度粒度提高响应性
• 合理设置进程优先级
• 使用CPU亲和性避免迁移开销
```

**🔹 监控工具的选择**
```
工具选择原则：
• /proc/sched_debug：查看调度器内部状态
• perf sched：详细的调度事件分析
• vmstat/sar：系统整体性能监控
• pidstat：进程级别详细监控

实际应用：
• 问题定位时用perf sched
• 日常监控用vmstat/sar
• 详细分析用/proc/sched_debug
```

**🔹 参数调优的平衡**
```
调优永远是权衡：
• 响应性 ↔ 吞吐量
• 实时性 ↔ 系统稳定性
• CPU利用率 ↔ 功耗

关键原则：
• 先测量，再调优
• 小步迭代，验证效果
• 保留回退方案
```

### 7.3 实际应用价值


**生产环境应用指导**：
- **Web服务**：重点优化响应延迟，使用适中的调度参数
- **批处理**：降低优先级，避免影响在线服务
- **数据库**：使用实时调度策略，绑定CPU核心
- **实时系统**：最小化调度延迟，锁定内存页面

### 7.4 常见问题与解决方案


| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|---------|
| 🐌 **响应慢** | 调度延迟大 | 减小`sched_min_granularity_ns` |
| 🔄 **CPU使用不均** | 负载均衡问题 | 调整CPU亲和性设置 |
| ⚡ **上下文切换频繁** | 进程太多或调度过于频繁 | 增大调度粒度，合并小进程 |
| 💥 **实时任务被抢占** | 优先级设置不当 | 使用FIFO调度，提高优先级 |

### 7.5 最佳实践总结


**🎯 监控策略**：
```bash
# 建立基线监控
vmstat 1 > /var/log/vmstat.log &
sar -u 1 > /var/log/sar_cpu.log &

# 定期检查调度健康度
cat > /usr/local/bin/sched_check.sh << 'EOF'
#!/bin/bash
cs_rate=$(vmstat 1 2 | tail -1 | awk '{print $12}')
if [ $cs_rate -gt 5000 ]; then
    echo "警告：上下文切换过于频繁 ($cs_rate/s)" | logger
fi
EOF
```

**🔧 调优流程**：
```
1. 建立性能基线
2. 识别性能瓶颈
3. 小步骤调优
4. 验证效果
5. 记录最佳配置
```

**⚠️ 注意事项**：
- 实时调度需要谨慎使用，可能导致系统卡死
- 调度参数修改后需要重启进程才能生效
- 生产环境调优要先在测试环境验证

**核心记忆**：
> 💡 **一句话总结**：进程调度监控就是给系统装"体检仪"，通过观察CPU时间分配找出性能瓶颈，合理调优提升系统响应性能

