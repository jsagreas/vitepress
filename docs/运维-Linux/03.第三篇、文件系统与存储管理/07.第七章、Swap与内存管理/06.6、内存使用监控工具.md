---
title: 6、内存使用监控工具
---
## 📚 目录

1. [内存监控概述](#1-内存监控概述)
2. [free命令详细解读](#2-free命令详细解读)
3. [/proc/meminfo内存信息解析](#3-procmeminfo内存信息解析)
4. [vmstat虚拟内存统计](#4-vmstat虚拟内存统计)
5. [sar内存监控数据采集](#5-sar内存监控数据采集)
6. [top/htop内存使用分析](#6-tophtop内存使用分析)
7. [smem进程内存占用统计](#7-smem进程内存占用统计)
8. [pmap进程内存映射查看](#8-pmap进程内存映射查看)
9. [内存泄漏检测方法](#9-内存泄漏检测方法)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 内存监控概述


### 1.1 为什么需要内存监控


**内存监控的重要性**
```
想象内存就像你家的仓库：
- 空间有限：物理内存就是仓库大小
- 需要管理：合理分配存储物品
- 避免堆积：防止内存泄漏
- 监控使用：及时发现问题
```

**🔸 内存监控解决的问题**
- **性能问题**：内存不足导致系统缓慢
- **稳定性问题**：内存耗尽引起程序崩溃
- **容量规划**：评估是否需要扩容
- **故障排查**：定位内存相关问题

### 1.2 内存类型基础概念


**Linux内存分类**
```
物理内存(Physical Memory)：
┌─────────────────────────────┐
│ 已使用内存 │ 缓存/缓冲 │ 空闲内存 │
└─────────────────────────────┘

虚拟内存(Virtual Memory)：
物理内存 + Swap分区 = 总可用内存
```

**🔸 关键概念解释**
- **物理内存**：真实的RAM硬件
- **虚拟内存**：操作系统提供的抽象内存空间  
- **缓存(Cache)**：加速文件读取的内存
- **缓冲(Buffer)**：加速磁盘写入的内存
- **交换分区(Swap)**：硬盘上的虚拟内存扩展

### 1.3 内存监控工具分类


| 工具类型 | **主要工具** | **监控对象** | **适用场景** |
|---------|------------|-------------|-------------|
| 🔸 **系统级** | `free`, `vmstat` | `整体内存使用` | `快速了解系统状态` |
| 🔸 **进程级** | `top`, `htop` | `进程内存占用` | `找出占用内存大的程序` |
| 🔸 **详细分析** | `smem`, `pmap` | `详细内存分布` | `深度分析内存使用` |
| 🔸 **历史监控** | `sar` | `内存使用趋势` | `长期监控和分析` |

---

## 2. 📊 free命令详细解读


### 2.1 free命令基本用法


**🔸 最简单的内存查看方式**
```bash
# 查看内存使用情况
free

# 以人类可读格式显示（推荐）
free -h

# 每秒刷新一次
free -h -s 1
```

### 2.2 free输出结果解读


**free -h 输出示例**
```bash
              total        used        free      shared  buff/cache   available
Mem:           7.8G        2.1G        1.2G        245M        4.5G        5.2G
Swap:          2.0G          0B        2.0G
```

**🔸 每列含义详细解释**

**内存(Mem)部分**：
- **total**: `7.8G` - 总物理内存大小
- **used**: `2.1G` - 已被进程直接使用的内存
- **free**: `1.2G` - 完全空闲的内存
- **shared**: `245M` - 进程间共享的内存
- **buff/cache**: `4.5G` - 缓存和缓冲区占用的内存
- **available**: `5.2G` - 可供新程序使用的内存

> 💡 **重要理解**  
> available才是真正可用的内存！它包括free + 可释放的buff/cache

**交换分区(Swap)部分**：
- **total**: `2.0G` - 交换分区总大小  
- **used**: `0B` - 已使用的交换分区
- **free**: `2.0G` - 可用的交换分区

### 2.3 内存使用状态判断


**🔸 内存使用健康状态**

```
🟢 健康状态：
- available > total * 20%
- swap使用 < swap总量 * 10%

🟡 需要关注：
- available < total * 20%  
- swap使用 > swap总量 * 10%

🔴 危险状态：
- available < total * 5%
- swap使用 > swap总量 * 50%
```

**实际案例分析**
```bash
# 案例1：健康状态
free -h
              total        used        free      shared  buff/cache   available
Mem:           8.0G        1.5G        2.0G        100M        4.5G        6.2G
# 分析：available=6.2G占总内存77%，非常健康

# 案例2：需要关注  
free -h
              total        used        free      shared  buff/cache   available
Mem:           8.0G        6.0G        200M       500M        1.8G        1.5G
# 分析：available=1.5G仅占总内存19%，需要关注
```

### 2.4 free命令高级用法


```bash
# 显示详细信息，包括低/高内存
free -h -w

# 每2秒刷新，共刷新5次
free -h -s 2 -c 5

# 显示总和行
free -h -t

# 以MB为单位显示
free -m

# 以字节为单位显示（精确值）
free -b
```

---

## 3. 📋 /proc/meminfo内存信息解析


### 3.1 /proc/meminfo文件概述


**🔸 什么是/proc/meminfo**
```bash
# 查看详细内存信息
cat /proc/meminfo
```

> 💡 **核心理解**  
> /proc/meminfo是Linux内核提供的内存信息接口，包含比free更详细的内存统计数据

### 3.2 关键内存指标解读


**🔸 基础内存指标**
```bash
cat /proc/meminfo | head -10

MemTotal:        8174464 kB    # 总物理内存
MemFree:         1234567 kB    # 空闲内存  
MemAvailable:    5432100 kB    # 可用内存
Buffers:          234567 kB    # 缓冲区内存
Cached:          3456789 kB    # 缓存内存
SwapCached:            0 kB    # 交换缓存
Active:          4567890 kB    # 活跃内存
Inactive:        2345678 kB    # 非活跃内存
```

**每个指标的实际含义**：

| 指标名称 | **含义说明** | **实际作用** |
|---------|-------------|-------------|
| **MemTotal** | `物理内存总量` | `系统硬件配置参考` |
| **MemFree** | `完全未使用的内存` | `立即可分配给新程序` |
| **MemAvailable** | `估算的可用内存` | `新程序启动的参考值` |
| **Buffers** | `文件系统元数据缓存` | `加速文件操作` |
| **Cached** | `页面缓存` | `加速文件内容读取` |
| **Active** | `最近使用的内存` | `不易被回收` |
| **Inactive** | `较少使用的内存` | `可能被回收` |

### 3.3 Swap相关指标


```bash
# 查看swap相关信息
cat /proc/meminfo | grep -i swap

SwapTotal:       2097148 kB    # 交换分区总大小
SwapFree:        2097148 kB    # 交换分区空闲
SwapCached:            0 kB    # 交换缓存大小
```

**🔸 Swap使用状态分析**
```bash
# 计算swap使用率的简单脚本
swap_used=$(cat /proc/meminfo | grep SwapTotal | awk '{print $2-0}')
swap_free=$(cat /proc/meminfo | grep SwapFree | awk '{print $2-0}')  
swap_used=$((swap_total - swap_free))
swap_usage=$((swap_used * 100 / swap_total))
echo "Swap使用率: ${swap_usage}%"
```

### 3.4 内存碎片和脏页信息


```bash
# 查看脏页信息
cat /proc/meminfo | grep -i dirty

Dirty:               123 kB     # 等待写入磁盘的脏页
Writeback:             0 kB     # 正在写入磁盘的页面
WritebackTmp:          0 kB     # 临时写回页面
```

**脏页含义解释**：
- **脏页**：内存中已修改但未写入磁盘的数据页
- **过多脏页**：可能导致系统卡顿
- **监控意义**：评估磁盘I/O压力

---

## 4. 📈 vmstat虚拟内存统计


### 4.1 vmstat命令基础


**🔸 vmstat是什么**
vmstat（Virtual Memory Statistics）是监控系统虚拟内存、进程、CPU活动的工具。

```bash
# 基本用法
vmstat

# 每2秒显示一次，共5次
vmstat 2 5

# 显示活跃和非活跃内存
vmstat -a

# 显示磁盘统计信息
vmstat -d
```

### 4.2 vmstat输出解读


**标准vmstat输出**
```bash
vmstat 2 3

procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1234567  23456 345678    0    0    12    34   56   78  5  2 92  1  0
 0  0      0 1234567  23456 345678    0    0     0     8   45   67  3  1 95  1  0
```

**🔸 各列详细含义**

**进程信息(procs)**：
- **r**: 运行中或等待运行的进程数
- **b**: 不可中断睡眠的进程数（通常是等待I/O）

**内存信息(memory)**：
- **swpd**: 已使用的交换内存(KB)
- **free**: 空闲内存(KB)
- **buff**: 缓冲区内存(KB)  
- **cache**: 缓存内存(KB)

**交换分区(swap)**：
- **si**: 从交换分区读入内存的数据(KB/s)
- **so**: 写入交换分区的数据(KB/s)

**I/O信息(io)**：
- **bi**: 从块设备读取的数据(blocks/s)
- **bo**: 写入块设备的数据(blocks/s)

### 4.3 vmstat性能分析


**🔸 关键指标判断标准**

```
内存压力判断：
🟢 正常：si=0, so=0 (无swap活动)
🟡 注意：si>0或so>0 (有swap活动)  
🔴 严重：si和so持续>100 (频繁swap)

系统负载判断：
🟢 正常：r <= CPU核心数
🟡 繁忙：r = CPU核心数 * 1.5
🔴 过载：r >= CPU核心数 * 2
```

**实际分析案例**
```bash
# 案例1：内存不足导致swap频繁
vmstat 1 3
procs -----------memory---------- ---swap-- -----io----
 r  b   swpd   free   buff  cache   si   so    bi    bo
 3  1  45678   12345   1000   5000  150  200    50   100
# 分析：si=150，so=200，说明系统在频繁使用swap，内存不足

# 案例2：健康状态
vmstat 1 3  
procs -----------memory---------- ---swap-- -----io----
 r  b   swpd   free   buff  cache   si   so    bi    bo
 1  0      0  234567  12345 456789    0    0    10    20
# 分析：swap未使用，内存充足，系统健康
```

### 4.4 vmstat监控脚本


```bash
#!/bin/bash
# 内存监控脚本
echo "内存使用监控 - $(date)"
echo "========================"

# 连续监控5次，每次间隔2秒
vmstat 2 5 | while read line; do
    if [[ $line =~ ^[[:space:]]*[0-9] ]]; then
        # 提取swap活动数据
        si=$(echo $line | awk '{print $7}')
        so=$(echo $line | awk '{print $8}')
        
        if [ $si -gt 10 ] || [ $so -gt 10 ]; then
            echo "⚠️  检测到swap活动: si=$si, so=$so"
        fi
    fi
done
```

---

## 5. 🕐 sar内存监控数据采集


### 5.1 sar工具概述


**🔸 什么是sar**
sar（System Activity Reporter）是系统活动报告工具，可以收集、报告和保存系统活动信息。

```bash
# 安装sar工具（如果没有）
# CentOS/RHEL
yum install sysstat

# Ubuntu/Debian  
apt install sysstat
```

### 5.2 sar内存监控基本用法


```bash
# 查看内存使用情况，每2秒采样一次，共5次
sar -r 2 5

# 查看swap使用情况  
sar -S 2 5

# 查看内存和swap综合信息
sar -r -S 2 5

# 查看历史数据（昨天的内存使用）
sar -r -f /var/log/sa/sa$(date -d yesterday +%d)
```

### 5.3 sar内存报告解读


**sar -r 输出示例**
```bash
sar -r 1 3

Linux 4.15.0 (server01)        2025-09-14      _x86_64_        (4 CPU)

14:30:01    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit
14:30:02      1234567   5432100   4567890     55.85     23456   3456789   6789012     65.23
14:30:03      1234567   5432100   4567890     55.85     23456   3456789   6789012     65.23
Average:      1234567   5432100   4567890     55.85     23456   3456789   6789012     65.23
```

**🔸 各字段含义**
- **kbmemfree**: 空闲内存(KB)
- **kbavail**: 可用内存(KB)
- **kbmemused**: 已使用内存(KB)
- **%memused**: 内存使用百分比
- **kbbuffers**: 缓冲区大小(KB)
- **kbcached**: 缓存大小(KB)
- **kbcommit**: 提交的内存(KB)
- **%commit**: 提交内存百分比

### 5.4 sar历史数据分析


**🔸 查看系统历史内存使用趋势**
```bash
# 查看本月内存使用趋势
for day in {01..31}; do
    if [ -f /var/log/sa/sa$day ]; then
        echo "=== $day 日内存使用情况 ==="
        sar -r -f /var/log/sa/sa$day | tail -1
    fi
done
```

**生成内存使用报告**
```bash
#!/bin/bash
# 内存使用周报生成
echo "内存使用周报 - $(date)"
echo "======================"

for i in {1..7}; do
    date_str=$(date -d "$i days ago" +%d)
    log_file="/var/log/sa/sa$date_str"
    
    if [ -f "$log_file" ]; then
        echo "$(date -d "$i days ago" +%Y-%m-%d):"
        sar -r -f "$log_file" | grep Average | awk '{printf "  内存使用率: %.1f%%\n", $4}'
    fi
done
```

### 5.5 sar实时监控和告警


```bash
#!/bin/bash
# sar内存监控告警脚本
THRESHOLD=80  # 内存使用率阈值

while true; do
    mem_usage=$(sar -r 1 1 | tail -1 | awk '{print $4}')
    
    if (( $(echo "$mem_usage > $THRESHOLD" | bc -l) )); then
        echo "⚠️  内存使用率告警: ${mem_usage}% > ${THRESHOLD}%"
        # 这里可以添加邮件告警或其他通知方式
    fi
    
    sleep 60  # 每分钟检查一次
done
```

---

## 6. 📊 top/htop内存使用分析


### 6.1 top命令内存监控


**🔸 top基本用法**
```bash
# 启动top
top

# 按内存使用排序
top -o %MEM

# 只显示特定用户的进程
top -u username

# 批处理模式（适合脚本）
top -b -n 1
```

### 6.2 top界面解读


**top界面内存信息区域**
```
top - 14:30:15 up 7 days,  3:25,  2 users,  load average: 0.15, 0.18, 0.12
Tasks: 234 total,   1 running, 233 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.1 us,  0.8 sy,  0.0 ni, 96.9 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7982.4 total,   1205.7 free,   2087.3 used,   4689.4 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   5432.1 avail Mem
```

**🔸 内存信息详解**
- **7982.4 total**: 总物理内存 7.98GB
- **1205.7 free**: 空闲内存 1.2GB
- **2087.3 used**: 已使用内存 2.1GB
- **4689.4 buff/cache**: 缓存缓冲 4.7GB
- **5432.1 avail Mem**: 可用内存 5.4GB

**进程内存列含义**
```
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 1234 mysql     20   0 1847032 456789  23456 S   1.5  5.7   2:34.56 mysqld
 5678 apache    20   0  234567 123456   7890 S   0.3  1.5   0:12.34 httpd
```

- **VIRT**: 虚拟内存使用量
- **RES**: 物理内存使用量（重点关注）
- **SHR**: 共享内存使用量
- **%MEM**: 内存使用百分比

### 6.3 htop增强监控


**🔸 htop优势**
```bash
# 安装htop
sudo apt install htop    # Ubuntu/Debian
sudo yum install htop    # CentOS/RHEL

# 启动htop
htop
```

**htop界面特色功能**：
- **彩色显示**：更直观的视觉效果
- **鼠标支持**：可以用鼠标操作
- **树状显示**：显示进程父子关系
- **内存条显示**：图形化内存使用情况

**🔸 htop快捷键**
```
F6: 选择排序字段（按内存排序选择%MEM）
F4: 过滤进程（输入关键词筛选）
F5: 树状显示进程关系
F9: 杀死进程
t:  切换树状显示
u:  选择显示特定用户的进程
```

### 6.4 找出内存占用大户


**🔸 快速找到内存消耗最多的进程**
```bash
# 按内存使用排序，显示前10个进程
ps aux --sort=-%mem | head -10

# 显示进程的详细内存使用
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head -10

# 找出内存使用超过100MB的进程
ps aux | awk '$6 > 100000 {print $2, $6/1024 "MB", $11}' | sort -k2 -nr
```

**内存使用分析脚本**
```bash
#!/bin/bash
# 内存使用TOP10分析脚本
echo "=== 内存使用TOP10进程 ==="
echo "PID     内存使用    进程名"
echo "-------------------------"

ps aux --sort=-%mem | head -11 | tail -10 | while read line; do
    pid=$(echo $line | awk '{print $2}')
    mem=$(echo $line | awk '{print $6/1024}')
    cmd=$(echo $line | awk '{print $11}')
    printf "%-8s %-10.1fMB %s\n" $pid $mem $cmd
done
```

---

## 7. 📋 smem进程内存占用统计


### 7.1 smem工具介绍


**🔸 为什么需要smem**
传统工具如ps和top显示的内存信息可能重复计算共享内存，smem能提供更准确的内存使用统计。

```bash
# 安装smem
sudo apt install smem    # Ubuntu/Debian
sudo yum install smem    # CentOS/RHEL（需要EPEL仓库）
```

### 7.2 smem基本用法


```bash
# 显示所有进程的内存使用
smem

# 按内存使用排序
smem -r

# 显示用户级统计
smem -u

# 显示更详细的内存信息
smem -k

# 生成图形化报告（需要matplotlib）
smem --pie name -c "name pss"
```

### 7.3 smem输出解读


**smem标准输出**
```bash
smem -r -c "name pid pss rss"

 Name                 PID        PSS        RSS
firefox             1234      45.6M      67.8M
chrome              5678      32.1M      54.3M  
mysql               9012      28.9M      42.1M
apache              3456      12.3M      18.7M
```

**🔸 内存指标含义**
- **PSS（Proportional Set Size）**：比例集合大小，最准确的内存使用指标
- **RSS（Resident Set Size）**：常驻集合大小，物理内存使用量
- **USS（Unique Set Size）**：独占内存大小，进程独有的内存

> 💡 **重要理解**  
> PSS = USS + 共享内存的一部分，是最准确的内存使用指标

### 7.4 smem高级分析


**🔸 按用户统计内存使用**
```bash
# 用户内存使用排行
smem -u -c "name count pss rss" -r

 User     Count        PSS        RSS
mysql        3     156.7M     234.5M
apache      10      87.4M     156.8M
nobody       5      34.2M      67.9M
root        45      78.9M     145.6M
```

**🔸 系统内存使用分析**
```bash
# 生成系统内存使用报告
smem -w -c "name pid pss uss rss" | head -20

# 查找内存泄漏嫌疑进程
smem -c "name pid pss" -P "python|java|node" -r
```

### 7.5 内存使用趋势监控


```bash
#!/bin/bash
# smem内存监控脚本
LOG_FILE="/var/log/memory_monitor.log"

while true; do
    timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    
    # 记录总内存使用
    total_pss=$(smem -t -c pss | tail -1 | awk '{print $1}')
    
    # 记录TOP5进程
    echo "[$timestamp] 总PSS内存: $total_pss" >> $LOG_FILE
    echo "TOP5进程内存使用:" >> $LOG_FILE
    smem -r -c "name pid pss" | head -5 >> $LOG_FILE
    echo "---" >> $LOG_FILE
    
    sleep 300  # 每5分钟记录一次
done
```

---

## 8. 🗺️ pmap进程内存映射查看


### 8.1 pmap工具概述


**🔸 pmap的作用**
pmap显示进程的内存映射情况，帮助了解进程如何使用内存空间。

```bash
# 查看进程内存映射
pmap PID

# 显示详细信息
pmap -d PID

# 显示扩展信息
pmap -x PID

# 显示设备格式
pmap -X PID
```

### 8.2 pmap输出分析


**pmap基本输出示例**
```bash
pmap 1234

1234:   /usr/sbin/mysqld
00400000    980K r-x-- mysqld
006f5000     32K rw--- mysqld  
006fd000     12K rw---   [ anon ]
01c6a000    132K rw---   [ heap ]
7f8b4c000000  132K rw---   [ anon ]
7f8b4c021000 65404K -----   [ anon ]
...
total         234567K
```

**🔸 各列含义**
- **地址（00400000）**：内存映射的虚拟地址
- **大小（980K）**：映射区域的大小
- **权限（r-x--）**：读(r)、写(w)、执行(x)权限
- **映射对象（mysqld）**：映射的文件或区域类型

### 8.3 内存区域类型理解


**🔸 常见内存区域类型**
```
[ anon ]:     匿名内存映射（堆、栈等）
[ heap ]:     堆内存区域
[ stack ]:    栈内存区域
/lib/xxx.so:  共享库文件
/usr/bin/xxx: 可执行文件
[ vdso ]:     虚拟动态共享对象
```

**内存权限含义**
```
r-x--: 可读可执行（通常是代码段）
rw---: 可读可写（通常是数据段）
r----: 只读（通常是只读数据）
-----: 无权限（预留空间）
```

### 8.4 pmap实践应用


**🔸 分析进程内存使用模式**
```bash
# 分析MySQL进程内存映射
mysql_pid=$(pidof mysqld)
echo "MySQL进程($mysql_pid)内存映射分析:"

# 统计各类型内存使用
pmap -x $mysql_pid | awk '
/anon/ {anon+=$3} 
/heap/ {heap+=$3}
/lib.*\.so/ {lib+=$3}
END {
    print "匿名内存:", anon "KB"
    print "堆内存:", heap "KB"  
    print "库文件:", lib "KB"
}'
```

**内存映射监控脚本**
```bash
#!/bin/bash
# 进程内存映射监控
PID=$1

if [ -z "$PID" ]; then
    echo "用法: $0 <PID>"
    exit 1
fi

echo "进程 $PID 内存映射分析"
echo "===================="

# 详细内存映射信息
pmap -x $PID | head -20

echo ""
echo "内存使用统计:"
echo "============"

# 统计总内存使用
total=$(pmap $PID | tail -1 | awk '{print $2}')
echo "总映射内存: $total"

# 统计可写内存（潜在的数据段和堆）
writable=$(pmap $PID | grep 'rw' | awk '{sum+=$2} END {print sum}')
echo "可写内存: ${writable}K"
```

---

## 9. 🔍 内存泄漏检测方法


### 9.1 什么是内存泄漏


**🔸 内存泄漏的含义**
```
内存泄漏就像家里的水管漏水：
- 程序申请了内存（接了水）
- 使用完后没有释放（忘记关水龙头）
- 内存逐渐被耗尽（水费越来越高）
- 最终系统崩溃（房子被淹）
```

**内存泄漏的典型表现**：
- 程序运行时间越长，内存占用越大
- 系统可用内存逐渐减少  
- 程序性能逐渐下降
- 严重时导致系统卡死或程序崩溃

### 9.2 内存泄漏检测策略


**🔸 系统级检测方法**

**长期内存监控**
```bash
#!/bin/bash
# 内存泄漏检测脚本
LOGFILE="/var/log/memory_leak_monitor.log"
INTERVAL=300  # 5分钟间隔

while true; do
    timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    
    # 记录系统总内存使用
    mem_used=$(free -m | awk 'NR==2{print $3}')
    
    # 记录TOP5进程内存使用
    echo "[$timestamp] 系统内存使用: ${mem_used}MB" >> $LOGFILE
    
    ps aux --sort=-%mem | head -6 | tail -5 | while read line; do
        pid=$(echo $line | awk '{print $2}')
        mem=$(echo $line | awk '{print $6/1024}')
        cmd=$(echo $line | awk '{print $11}')
        echo "  PID:$pid MEM:${mem}MB CMD:$cmd" >> $LOGFILE
    done
    
    echo "---" >> $LOGFILE
    sleep $INTERVAL
done
```

### 9.3 进程级内存泄漏检测


**🔸 监控特定进程内存增长**
```bash
#!/bin/bash
# 单进程内存泄漏监控
PID=$1
DURATION=${2:-3600}  # 默认监控1小时

if [ -z "$PID" ]; then
    echo "用法: $0 <PID> [监控时长(秒)]"
    exit 1
fi

echo "监控进程 $PID 内存使用情况..."
echo "时间            RSS内存     VSZ内存     内存增长"
echo "============================================"

# 获取初始内存使用
initial_rss=$(ps -p $PID -o rss= 2>/dev/null)
if [ -z "$initial_rss" ]; then
    echo "进程 $PID 不存在"
    exit 1
fi

start_time=$(date +%s)
last_rss=$initial_rss

while [ $(($(date +%s) - start_time)) -lt $DURATION ]; do
    current_rss=$(ps -p $PID -o rss= 2>/dev/null)
    current_vsz=$(ps -p $PID -o vsz= 2>/dev/null)
    
    if [ -z "$current_rss" ]; then
        echo "进程 $PID 已终止"
        break
    fi
    
    growth=$((current_rss - last_rss))
    timestamp=$(date "+%H:%M:%S")
    
    printf "%-12s %8dKB %8dKB %+8dKB\n" \
        "$timestamp" "$current_rss" "$current_vsz" "$growth"
    
    last_rss=$current_rss
    sleep 60  # 每分钟检查一次
done

echo ""
echo "总内存增长: $((current_rss - initial_rss))KB"
```

### 9.4 使用valgrind检测内存泄漏


**🔸 valgrind安装和使用**
```bash
# 安装valgrind
sudo apt install valgrind    # Ubuntu/Debian
sudo yum install valgrind    # CentOS/RHEL

# 检测程序内存泄漏
valgrind --tool=memcheck --leak-check=full ./your_program

# 生成详细报告
valgrind --tool=memcheck \
         --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
         --log-file=valgrind-out.txt \
         ./your_program
```

**valgrind输出解读示例**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 1,024 bytes in 1 blocks
==12345==   total heap usage: 10 allocs, 9 frees, 2,048 bytes allocated
==12345== 
==12345== 1,024 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x4C2AB80: malloc (in /usr/lib/libc.so.6)
==12345==    at 0x108654: main (test.c:10)
==12345== 
==12345== LEAK SUMMARY:
==12345==    definitely lost: 1,024 bytes in 1 blocks
```

> 💡 **valgrind报告理解**  
> - **definitely lost**: 确定的内存泄漏
> - **possibly lost**: 可能的内存泄漏  
> - **still reachable**: 程序结束时仍可访问的内存

### 9.5 生产环境内存泄漏排查


**🔸 生产环境排查步骤**

1. **确认内存泄漏现象**
```bash
# 连续监控系统内存使用
watch -n 60 'free -h && echo "---" && ps aux --sort=-%mem | head -10'
```

2. **定位可疑进程**
```bash
# 找出内存增长最快的进程
for i in {1..10}; do
    ps aux --sort=-%mem | head -5 | tail -4
    sleep 300
    echo "--- $(date) ---"
done
```

3. **分析进程内存映射**
```bash
# 分析可疑进程的内存映射变化
suspicious_pid=1234
for i in {1..6}; do
    echo "=== $(date) ==="
    pmap -x $suspicious_pid | tail -1
    sleep 600  # 每10分钟检查一次
done
```

4. **收集诊断信息**
```bash
#!/bin/bash
# 内存泄漏诊断信息收集
PID=$1
OUTPUT_DIR="/tmp/memory_leak_diagnosis_$(date +%Y%m%d_%H%M%S)"

mkdir -p $OUTPUT_DIR

echo "收集进程 $PID 的诊断信息到 $OUTPUT_DIR"

# 进程基本信息
ps -p $PID -o pid,ppid,cmd,etime,%mem,rss,vsz > $OUTPUT_DIR/process_info.txt

# 内存映射
pmap -x $PID > $OUTPUT_DIR/memory_map.txt

# 文件描述符
ls -la /proc/$PID/fd/ > $OUTPUT_DIR/file_descriptors.txt

# 进程状态
cat /proc/$PID/status > $OUTPUT_DIR/process_status.txt

echo "诊断信息已保存到 $OUTPUT_DIR"
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


**🔸 内存监控核心概念**
- **物理内存 vs 虚拟内存**：硬件内存和操作系统抽象内存
- **缓存和缓冲区**：系统性能优化机制，不是内存浪费
- **available内存**：真正可用于新程序的内存
- **Swap使用**：内存不足的信号，需要重点关注

**🔸 关键监控指标**
```
健康状态判断标准：
🟢 available > 总内存的20%
🟢 swap使用 < swap总量的10%  
🟢 内存使用增长平稳

警告状态：
🟡 available < 总内存的20%
🟡 swap使用 > swap总量的10%
🟡 内存使用持续增长

危险状态：
🔴 available < 总内存的5%
🔴 swap使用 > swap总量的50%
🔴 频繁的swap活动（si/so > 100）
```

### 10.2 工具使用要点


| 监控场景 | **推荐工具** | **关键命令** | **重点关注** |
|---------|------------|-------------|-------------|
| 🔸 **快速了解** | `free` | `free -h` | `available内存` |
| 🔸 **实时监控** | `top/htop` | `htop` | `进程内存排序` |
| 🔸 **历史分析** | `sar` | `sar -r 1 5` | `内存使用趋势` |
| 🔸 **详细统计** | `vmstat` | `vmstat 2 5` | `swap活动` |
| 🔸 **精确分析** | `smem` | `smem -r` | `PSS真实内存使用` |
| 🔸 **进程诊断** | `pmap` | `pmap -x PID` | `内存映射分布` |

### 10.3 实际应用指导


**🔹 日常监控检查清单**
- [ ] **系统总内存使用**: `free -h` 检查available
- [ ] **Swap使用状态**: 确认swap使用量不超过10%
- [ ] **内存大户识别**: `ps aux --sort=-%mem | head -10`
- [ ] **历史趋势分析**: `sar -r` 查看内存使用趋势

**🔹 内存问题排查步骤**
1. **确认问题现象**: 使用free和top确认内存不足
2. **找出内存大户**: 使用ps或htop按内存排序
3. **分析增长趋势**: 使用sar或自写脚本监控变化
4. **深入进程分析**: 使用pmap和smem详细分析
5. **检测内存泄漏**: 长期监控进程内存使用变化

**🔹 性能优化建议**
```
内存优化策略：
🔸 合理设置应用内存限制
🔸 优化数据库缓存配置
🔸 清理不必要的后台进程
🔸 考虑增加物理内存
🔸 优化swap分区大小和位置
```

### 10.4 监控自动化


**🔹 建立监控体系**
```bash
# 建议的监控策略
1. 实时监控: htop或自定义dashboard
2. 定期检查: cron任务每小时检查内存状态
3. 历史记录: sar自动记录历史数据
4. 告警机制: 内存使用超过阈值时告警
5. 自动清理: 定期清理系统缓存和临时文件
```

**🔹 告警阈值建议**
```
告警级别设置：
警告: available < 1GB 或 使用率 > 80%
严重: available < 500MB 或 使用率 > 90%
紧急: available < 100MB 或 swap活动频繁
```

---

**学习要点记忆**：
- 内存监控要看available，不只看free
- Swap使用是内存不足的重要信号
- 缓存和缓冲区是正常的，可以释放
- 内存泄漏通过长期监控发现
- 不同工具有不同的应用场景，组合使用效果更好

> 🎯 **实践建议**  
> 从free命令开始，逐步掌握其他工具。在实际环境中建立监控脚本，积累经验。记住：理解概念比记住命令参数更重要！