---
title: 8、内存压力与OOM处理
---
## 📚 目录

1. [内存压力基本概念](#1-内存压力基本概念)
2. [内存压力识别指标](#2-内存压力识别指标)
3. [OOM Killer机制详解](#3-OOM-Killer机制详解)
4. [OOM相关参数配置](#4-OOM相关参数配置)
5. [进程OOM优先级管理](#5-进程OOM优先级管理)
6. [OOM事件监控与分析](#6-OOM事件监控与分析)
7. [预防OOM的策略方法](#7-预防OOM的策略方法)
8. [内存限制与cgroups配合](#8-内存限制与cgroups配合)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🧠 内存压力基本概念


### 1.1 什么是内存压力


**简单理解**：内存压力就像房子太小但住的人太多，大家都觉得拥挤不堪。

> 💡 **核心概念**：内存压力是指系统可用内存不足，导致系统性能下降或无法满足新的内存分配请求的状态。

**内存压力的表现**：
```
轻度压力：系统开始使用swap，响应稍慢
中度压力：频繁swap交换，系统明显卡顿  
重度压力：内存几乎耗尽，可能触发OOM
```

### 1.2 内存压力产生的原因


**常见原因分析**：

🔸 **应用程序内存泄漏**
- 程序占用内存越来越多，不释放
- 像水龙头坏了一直流水

🔸 **并发进程过多**
- 同时运行的程序太多
- 每个都要占用内存空间

🔸 **大文件处理**
- 处理超大文件时内存不够
- 一次性加载过多数据

🔸 **缓存过度使用**
- 系统缓存占用过多内存
- 虽然能提升性能但挤占空间

### 1.3 内存不足时系统行为


**系统应对机制**：
```
第1步：释放可回收的缓存
第2步：启动swap交换机制
第3步：尝试回收更多内存
第4步：触发OOM Killer杀进程
```

---

## 2. 📊 内存压力识别指标


### 2.1 核心监控指标


**🔸 内存使用率**
```bash
# 查看内存整体使用情况
$ free -h
              total        used        free      shared  buff/cache   available
Mem:           7.8G        3.2G        1.1G        234M        3.5G        4.0G
Swap:          2.0G        512M        1.5G

# 关键指标解释：
# available：真正可用的内存（重要！）
# used：已使用内存
# buff/cache：缓存，可以被回收
```

**🔸 Swap使用情况**
```bash
# 查看swap详细信息
$ swapon -s
Filename                Type            Size    Used    Priority
/dev/sda2               partition       2097148 524288  -2

# swap使用率计算：524288 / 2097148 = 25%
```

### 2.2 实时监控命令


**top命令监控**：
```bash
$ top
# 重点关注：
# %MEM：进程内存使用百分比
# RES：进程实际占用物理内存
# VIRT：进程虚拟内存大小
# SHR：共享内存大小
```

**vmstat监控内存活动**：
```bash
$ vmstat 2 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0 524288 1048576  65536 3584000  0   0     5    10   50  100  5  2 92  1  0

# 关键字段：
# si：从swap读入内存的页面数/秒
# so：写入swap的页面数/秒  
# 如果si、so > 0说明在使用swap
```

### 2.3 内存压力等级判断


**压力等级标准**：

| 等级 | **可用内存** | **Swap使用** | **系统表现** |
|------|-------------|-------------|-------------|
| 🟢 **正常** | `>20%` | `<10%` | `响应迅速` |
| 🟡 **轻度** | `10-20%` | `10-30%` | `偶尔卡顿` |
| 🟠 **中度** | `5-10%` | `30-70%` | `明显变慢` |
| 🔴 **重度** | `<5%` | `>70%` | `严重卡顿，可能OOM` |

---

## 3. ⚡ OOM Killer机制详解


### 3.1 什么是OOM Killer


**简单比喻**：OOM Killer就像一个严格的管理员，当宿舍人太多住不下时，他会选择踢走一些人来缓解拥挤。

> 💡 **核心概念**：OOM (Out of Memory) Killer是Linux内核的一个保护机制，当系统内存严重不足时，会自动杀死一些进程来释放内存，避免系统崩溃。

### 3.2 OOM触发条件


**触发场景**：
```
条件1：系统可用内存几乎为0
条件2：swap空间也快用完
条件3：内核无法分配新的内存页
条件4：系统无法通过回收缓存解决
```

**具体数值**：
- 可用内存 < 系统总内存的2-3%
- 无法满足新的内存分配请求
- 内核判断继续运行可能导致系统死锁

### 3.3 OOM选择进程的算法


**评分机制**：OOM Killer会给每个进程打分，分数越高越容易被杀死。

```
评分因素：
📈 内存占用大 → 分数高（主要因素）
📈 运行时间短 → 分数高（新进程优先杀）
📈 优先级低 → 分数高
📉 系统关键进程 → 分数低（受保护）
📉 有子进程 → 分数略低
```

**评分公式示意**：
```
OOM Score = 内存使用量 + 进程调整值(oom_score_adj)
分数范围：-1000 到 1000
-1000：永远不被杀死
1000：最容易被杀死
```

### 3.4 OOM事件的处理流程


```
内存不足检测 → 尝试回收内存 → 启用swap → 仍然不足
      ↓
启动OOM Killer → 计算进程分数 → 选择目标进程
      ↓
发送SIGKILL信号 → 强制杀死进程 → 释放内存 → 记录日志
```

---

## 4. ⚙️ OOM相关参数配置


### 4.1 主要控制参数


**🔸 vm.oom_kill_allocating_task**
```bash
# 查看当前设置
$ cat /proc/sys/vm/oom_kill_allocating_task
0

# 参数含义：
# 0：杀死评分最高的进程（默认）
# 1：杀死触发OOM的进程

# 修改设置
$ echo 1 > /proc/sys/vm/oom_kill_allocating_task
```

**🔸 vm.panic_on_oom**
```bash
# 查看设置
$ cat /proc/sys/vm/panic_on_oom  
0

# 参数含义：
# 0：触发OOM时杀死进程（默认）
# 1：触发OOM时直接panic重启系统
# 2：只在特定条件下panic

# 设置OOM时panic（慎用！）
$ echo 1 > /proc/sys/vm/panic_on_oom
```

**🔸 vm.oom_dump_tasks**
```bash
# 查看设置
$ cat /proc/sys/vm/oom_dump_tasks
1

# 参数含义：
# 0：OOM时不输出进程信息
# 1：OOM时输出所有进程信息到日志

# 开启详细日志（调试用）
$ echo 1 > /proc/sys/vm/oom_dump_tasks
```

### 4.2 永久配置方法


**修改sysctl.conf**：
```bash
# 编辑配置文件
$ sudo vim /etc/sysctl.conf

# 添加OOM相关配置
vm.oom_kill_allocating_task = 0
vm.panic_on_oom = 0  
vm.oom_dump_tasks = 1

# 应用配置
$ sudo sysctl -p
```

---

## 5. 🎯 进程OOM优先级管理


### 5.1 oom_score_adj参数详解


**什么是oom_score_adj**：
> 💡 每个进程都有一个OOM调整值，用来影响被OOM Killer选中的概率。就像给不同的人贴上"重要"或"不重要"的标签。

**参数范围**：
```
-1000：永远不会被OOM杀死（除非没有其他选择）
-999 到 -1：降低被杀死的可能性
0：默认值，正常评分
1 到 999：增加被杀死的可能性  
1000：最容易被杀死
```

### 5.2 查看进程OOM分数


```bash
# 查看进程的OOM分数
$ cat /proc/PID/oom_score      # 当前分数（只读）
$ cat /proc/PID/oom_score_adj  # 调整值（可写）

# 示例：查看重要进程的分数
$ ps aux | grep nginx
root      1234  0.0  0.5   nginx: master process

$ cat /proc/1234/oom_score
150

$ cat /proc/1234/oom_score_adj  
0
```

### 5.3 设置进程OOM优先级


**🔸 保护重要进程**：
```bash
# 保护nginx主进程不被OOM杀死
$ echo -1000 > /proc/1234/oom_score_adj

# 或者启动时设置
$ echo -500 > /proc/self/oom_score_adj && exec nginx
```

**🔸 降低不重要进程优先级**：
```bash
# 让某个测试进程更容易被杀死
$ echo 500 > /proc/5678/oom_score_adj
```

### 5.4 systemd服务OOM配置


**在service文件中配置**：
```bash
# 编辑服务文件
$ sudo vim /etc/systemd/system/myapp.service

[Service]
# 设置OOM调整值
OOMScoreAdjust=-100

# 重载并重启服务
$ sudo systemctl daemon-reload
$ sudo systemctl restart myapp
```

---

## 6. 🔍 OOM事件监控与分析


### 6.1 使用dmesg查看OOM事件


**基本查看命令**：
```bash
# 查看最近的OOM事件
$ dmesg | grep -i "killed process"

# 查看详细的OOM信息
$ dmesg | grep -i "out of memory"

# 实时监控OOM事件
$ dmesg -w | grep -i oom
```

**OOM日志示例**：
```
[12345.678] Out of memory: Kill process 1234 (java) score 800 or sacrifice child
[12345.679] Killed process 1234 (java) total-vm:2097152kB, anon-rss:1048576kB, file-rss:0kB
```

### 6.2 分析OOM日志信息


**日志信息解读**：
```
关键信息：
Kill process 1234：被杀死的进程PID
(java)：进程名称
score 800：OOM评分
total-vm：进程虚拟内存总量
anon-rss：匿名页面内存（堆、栈等）
file-rss：文件映射内存
```

### 6.3 OOM事件自动监控


**编写监控脚本**：
```bash
#!/bin/bash
# oom_monitor.sh - OOM事件监控脚本

LOG_FILE="/var/log/oom_events.log"

# 监控OOM事件
dmesg -w | while read line; do
    if echo "$line" | grep -q "killed process"; then
        echo "[$(date)] OOM Event: $line" >> $LOG_FILE
        
        # 发送告警（可选）
        # mail -s "OOM Alert" admin@example.com < $LOG_FILE
    fi
done
```

**设置开机自启动**：
```bash
# 创建systemd服务
$ sudo vim /etc/systemd/system/oom-monitor.service

[Unit]
Description=OOM Event Monitor
After=multi-user.target

[Service]
Type=simple
ExecStart=/path/to/oom_monitor.sh
Restart=always

[Install]
WantedBy=multi-user.target

# 启用服务
$ sudo systemctl enable oom-monitor.service
$ sudo systemctl start oom-monitor.service
```

---

## 7. 🛡️ 预防OOM的策略方法


### 7.1 内存监控与预警


**🔸 设置内存使用阈值告警**：
```bash
#!/bin/bash
# memory_alert.sh - 内存监控告警脚本

THRESHOLD=80  # 内存使用率阈值80%

while true; do
    MEMORY_USAGE=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
    
    if [ $MEMORY_USAGE -gt $THRESHOLD ]; then
        echo "警告：内存使用率达到 ${MEMORY_USAGE}%" | \
        mail -s "Memory Alert" admin@example.com
    fi
    
    sleep 300  # 每5分钟检查一次
done
```

### 7.2 应用程序内存限制


**🔸 使用ulimit限制进程内存**：
```bash
# 限制单个进程最大虚拟内存为1GB
$ ulimit -v 1048576

# 限制单个进程最大物理内存为512MB  
$ ulimit -m 524288

# 在脚本中使用
$ ulimit -v 1048576 && ./my_program
```

**🔸 Java应用内存限制**：
```bash
# 启动Java应用时限制堆内存
$ java -Xmx512m -Xms256m MyApplication

# 同时设置OOM时的行为
$ java -Xmx512m -XX:+HeapDumpOnOutOfMemoryError MyApp
```

### 7.3 系统级预防措施


**🔸 合理配置Swap**：
```bash
# 检查swap配置
$ cat /proc/sys/vm/swappiness
60

# 降低swap使用倾向（可选）
$ echo 10 > /proc/sys/vm/swappiness

# 永久配置
$ echo 'vm.swappiness=10' >> /etc/sysctl.conf
```

**🔸 内存压力通知**：
```bash
# 启用内存压力检测
$ echo 1 > /proc/sys/vm/memory_failure_early_kill

# 配置内存压力级别
$ echo 90 > /proc/sys/vm/dirty_ratio
$ echo 10 > /proc/sys/vm/dirty_background_ratio
```

---

## 8. 🔗 内存限制与cgroups配合


### 8.1 cgroups内存控制基础


**什么是cgroups**：
> 💡 **核心概念**：cgroups（控制组）是Linux内核提供的资源管理功能，可以对进程组进行CPU、内存、网络等资源的限制和监控。就像给不同的部门分配不同的预算。

### 8.2 创建内存限制的cgroup


**🔸 创建cgroup**：
```bash
# 创建新的cgroup（需要root权限）
$ sudo mkdir /sys/fs/cgroup/memory/myapp

# 设置内存限制为512MB
$ echo 536870912 > /sys/fs/cgroup/memory/myapp/memory.limit_in_bytes

# 设置swap+内存总限制为1GB
$ echo 1073741824 > /sys/fs/cgroup/memory/myapp/memory.memsw.limit_in_bytes
```

**🔸 将进程加入cgroup**：
```bash
# 启动进程并加入cgroup
$ echo $$ > /sys/fs/cgroup/memory/myapp/cgroup.procs
$ ./my_application

# 或者直接启动进程到cgroup
$ cgexec -g memory:myapp ./my_application
```

### 8.3 systemd与cgroups集成


**在systemd服务中设置内存限制**：
```bash
# 编辑服务文件
$ sudo vim /etc/systemd/system/myapp.service

[Unit]
Description=My Application
After=multi-user.target

[Service]
Type=simple
ExecStart=/path/to/myapp
# 设置内存限制
MemoryLimit=512M
# 设置swap+内存限制
MemoryMax=1G
# OOM时的行为
OOMPolicy=kill

[Install]
WantedBy=multi-user.target
```

### 8.4 监控cgroup内存使用


```bash
# 查看cgroup内存使用情况
$ cat /sys/fs/cgroup/memory/myapp/memory.usage_in_bytes
134217728  # 当前使用128MB

$ cat /sys/fs/cgroup/memory/myapp/memory.max_usage_in_bytes  
268435456  # 历史最大使用256MB

# 查看内存统计
$ cat /sys/fs/cgroup/memory/myapp/memory.stat
cache 67108864
rss 67108864
mapped_file 0
pgpgin 16384
pgpgout 8192
```

**监控脚本示例**：
```bash
#!/bin/bash
# cgroup_monitor.sh - 监控cgroup内存使用

CGROUP_PATH="/sys/fs/cgroup/memory/myapp"

while true; do
    USAGE=$(cat $CGROUP_PATH/memory.usage_in_bytes)
    LIMIT=$(cat $CGROUP_PATH/memory.limit_in_bytes)
    
    USAGE_MB=$((USAGE / 1024 / 1024))
    LIMIT_MB=$((LIMIT / 1024 / 1024))
    USAGE_PERCENT=$((USAGE * 100 / LIMIT))
    
    echo "内存使用: ${USAGE_MB}MB / ${LIMIT_MB}MB (${USAGE_PERCENT}%)"
    
    sleep 10
done
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 内存压力：系统可用内存不足，影响性能的状态
🔸 OOM Killer：内核自动杀进程的保护机制
🔸 oom_score_adj：控制进程被杀优先级的参数
🔸 内存监控：通过各种工具识别内存使用情况
🔸 cgroups：对进程组进行资源限制的机制
```

### 9.2 关键理解要点


**🔹 内存压力的本质**
```
不是内存用完了就是压力，而是：
- 可用内存不足以满足新的分配请求
- 系统需要通过swap或回收来获得内存
- 影响了系统的正常响应速度
```

**🔹 OOM Killer的作用**
```
保护作用：
- 防止系统因内存不足而完全死锁
- 牺牲部分进程保证系统整体稳定
- 优先杀死占用内存多的非关键进程

选择标准：
- 内存占用量（主要因素）
- 进程重要性（系统进程受保护）
- 运行时间（新进程更容易被杀）
```

**🔹 预防策略的层次**
```
应用层面：
- 程序内存使用优化
- 合理设置JVM堆大小等

系统层面：
- 监控内存使用趋势
- 设置合理的swap配置
- 使用cgroups进行资源隔离

运维层面：
- 建立监控告警机制
- 制定OOM事件响应流程
- 定期检查系统资源规划
```

### 9.3 实际应用价值


**🎯 日常运维场景**：
- **Web服务器**：防止内存泄漏导致的服务中断
- **数据库服务器**：合理配置内存避免查询失败
- **容器环境**：通过cgroups限制容器内存使用
- **开发测试**：识别应用程序内存问题

**🛠️ 故障处理流程**：
```
发现OOM事件 → 查看dmesg日志 → 分析被杀进程
     ↓
确定原因 → 内存泄漏/配置不当/负载过高
     ↓  
制定方案 → 程序优化/增加内存/负载均衡
     ↓
预防措施 → 监控告警/资源限制/容量规划
```

### 9.4 最佳实践建议


**⚡ 监控建议**：
- 设置内存使用率80%的告警阈值
- 监控swap使用情况，超过30%需要关注
- 定期检查dmesg中的OOM事件
- 建立内存使用趋势分析

**🔧 配置建议**：
- 重要服务设置oom_score_adj为负值保护
- 测试环境可以设置正值优先释放资源
- 合理配置swappiness值（服务器建议10-30）
- 使用systemd的内存限制功能

**🚨 应急处理**：
```
OOM事件发生时：
1. 立即检查系统当前内存状态
2. 查看dmesg确认被杀死的进程
3. 重启必要的服务恢复业务
4. 分析根本原因制定长期解决方案
```

**核心记忆**：
- 内存压力要提前监控，不要等到OOM才发现
- OOM Killer是保护机制不是故障，但要分析原因
- oom_score_adj用来保护重要进程，合理设置优先级
- cgroups是现代资源管理的标准方式，容器化必备
- 预防胜于治疗，监控告警比事后补救更重要