---
title: 5、Swap性能调优参数
---
## 📚 目录

1. [Swap调优概述](#1-Swap调优概述)
2. [核心调优参数详解](#2-核心调优参数详解)
3. [缓存与内存管理参数](#3-缓存与内存管理参数)
4. [脏页管理参数](#4-脏页管理参数)
5. [内存回收策略参数](#5-内存回收策略参数)
6. [参数持久化配置](#6-参数持久化配置)
7. [不同场景调优策略](#7-不同场景调优策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 Swap调优概述


### 1.1 什么是Swap性能调优


**🔸 基本定义**
```
Swap性能调优：通过调整Linux内核参数来优化虚拟内存管理
目标：平衡内存使用效率、系统响应速度和I/O性能
核心思想：让系统在合适的时机使用合适的内存管理策略
```

**💡 为什么需要调优**
```
系统默认设置的问题：
• 通用配置：不能适应所有应用场景
• 保守策略：为了稳定性可能牺牲性能
• 一刀切：不考虑具体工作负载特点

调优带来的好处：
• 减少不必要的swap使用
• 提高内存利用效率
• 改善系统响应性能
• 优化磁盘I/O模式
```

### 1.2 调优参数分类


**🔧 参数体系结构**
```
内存管理参数体系：
├── 交换控制类
│   ├── vm.swappiness (交换积极性)
│   └── vm.zone_reclaim_mode (回收模式)
├── 缓存管理类  
│   ├── vm.vfs_cache_pressure (缓存压力)
│   └── vm.min_free_kbytes (最小空闲内存)
└── 脏页管理类
    ├── vm.dirty_ratio (脏页比例)
    └── vm.dirty_background_ratio (后台刷写)
```

---

## 2. ⚙️ 核心调优参数详解


### 2.1 vm.swappiness - 交换积极性控制


**🔸 参数含义**
```
vm.swappiness：控制内核使用swap的积极程度
取值范围：0-200 (Linux 5.8+)，传统为0-100
默认值：60
单位：百分比倾向值
```

**💡 工作机制**
```
swappiness的真实含义：
不是"内存使用60%才swap"，而是：
• 回收匿名页面的倾向性 vs 回收页面缓存的倾向性
• 数值越高：越倾向于回收匿名页面(使用swap)
• 数值越低：越倾向于回收页面缓存

内核决策过程：
当内存紧张时 → 内核需要回收内存
├── 回收页面缓存 (file cache)
└── 回收匿名页面 (anonymous pages，需要swap)

swappiness影响这两种选择的权重比例
```

**🎯 常用配置值**
```bash
# 查看当前值
cat /proc/sys/vm/swappiness

# 临时修改
echo 10 > /proc/sys/vm/swappiness

# 不同值的适用场景
vm.swappiness = 0    # 🔴 最小化swap (数据库服务器)
vm.swappiness = 1    # 🟡 几乎不用swap (Redis/内存数据库)  
vm.swappiness = 10   # 🟢 轻度使用swap (Web服务器)
vm.swappiness = 30   # 🔵 中等使用swap (开发环境)
vm.swappiness = 60   # ⚪ 系统默认值 (通用环境)
vm.swappiness = 100  # 🟣 积极使用swap (内存受限环境)
```

**⚡ 实际效果演示**
```bash
# 模拟内存压力测试
stress --vm 2 --vm-bytes 1G --timeout 60s

# swappiness=1时的表现：
free -h
              total   used   free   buffers   cache   available
Mem:           2.0G    1.8G   100M      50M     1.2G      200M
Swap:          1.0G     10M   990M      # 很少使用swap

# swappiness=80时的表现：
              total   used   free   buffers   cache   available  
Mem:           2.0G    1.5G   200M      30M     800M      300M
Swap:          1.0G    400M   600M      # 较多使用swap
```

### 2.2 vm.zone_reclaim_mode - 内存回收模式


**🔸 参数含义**
```
vm.zone_reclaim_mode：控制NUMA系统中的内存回收策略
取值：位掩码值 (0, 1, 2, 4及其组合)
默认值：0 (大多数情况)
作用：决定从远程节点分配内存还是回收本地内存
```

**🔧 配置选项解析**
```
位掩码组合含义：
0: 关闭zone reclaim，优先从其他NUMA节点分配
1: 回收页面缓存
2: 回收slab cache (内核对象缓存)  
4: 写出脏页面

常用组合：
0: 默认，性能优先 (推荐用于大多数应用)
1: 回收页面缓存
5: 回收页面缓存 + 写出脏页 (1+4)
7: 全面回收 (1+2+4)
```

**💻 NUMA感知配置**
```bash
# 检查NUMA拓扑
numactl --hardware
available: 2 nodes (0-1)
node 0 cpus: 0 1 2 3
node 0 size: 16384 MB
node 1 cpus: 4 5 6 7  
node 1 size: 16384 MB

# 根据应用特点选择
# 内存密集型应用 (数据库)
echo 0 > /proc/sys/vm/zone_reclaim_mode  # 优先远程内存

# I/O密集型应用 (文件服务器)
echo 1 > /proc/sys/vm/zone_reclaim_mode  # 优先本地回收
```

---

## 3. 🗂️ 缓存与内存管理参数


### 3.1 vm.vfs_cache_pressure - 缓存压力控制


**🔸 参数含义**
```
vm.vfs_cache_pressure：控制VFS缓存被回收的倾向性
取值范围：0-∞ (实际建议0-1000)
默认值：100
含义：相对于页面缓存，回收VFS缓存的积极性
```

**💡 VFS缓存详解**
```
什么是VFS缓存：
• dentry cache：目录项缓存 (文件/目录名到inode的映射)
• inode cache：索引节点缓存 (文件元数据)
• 作用：加速文件系统操作，避免重复磁盘访问

VFS缓存 vs 页面缓存的区别：
VFS缓存：存储文件系统元数据 (文件名、属性等)
页面缓存：存储文件内容数据

两者都占用内存，但用途不同
```

**⚡ 配置策略**
```bash
# 查看缓存使用情况
cat /proc/meminfo | grep -E "(Slab|Cache)"
Cached:         2048000 kB    # 页面缓存
SReclaimable:    384000 kB    # 可回收的slab(包含VFS缓存)

# 不同场景的配置：
echo 50 > /proc/sys/vm/vfs_cache_pressure   # 📁 文件服务器 (保留更多VFS缓存)
echo 100 > /proc/sys/vm/vfs_cache_pressure  # ⚖️ 默认平衡
echo 200 > /proc/sys/vm/vfs_cache_pressure  # 🗃️ 内存紧张环境 (更积极回收)
```

**📊 实际效果对比**
```
文件密集型工作负载测试：
find /usr -name "*.so" -type f | wc -l

vfs_cache_pressure=50时：
- 查找耗时：0.8秒
- VFS缓存：512MB
- 重复查找：0.1秒 (缓存命中)

vfs_cache_pressure=200时：  
- 查找耗时：1.2秒
- VFS缓存：128MB
- 重复查找：0.6秒 (缓存部分失效)
```

### 3.2 vm.min_free_kbytes - 最小空闲内存


**🔸 参数含义**
```
vm.min_free_kbytes：系统保留的最小空闲内存
取值：以KB为单位的数值
默认值：约为总内存的1.5% (最小128KB)
作用：确保系统有足够内存处理原子分配请求
```

**🔧 计算公式与设置**
```
推荐计算公式：
最小空闲内存 = sqrt(总内存MB * 16)

实际计算示例：
4GB内存：sqrt(4096 * 16) ≈ 256MB
8GB内存：sqrt(8192 * 16) ≈ 362MB
16GB内存：sqrt(16384 * 16) ≈ 512MB
32GB内存：sqrt(32768 * 16) ≈ 724MB
```

**⚠️ 设置注意事项**
```bash
# 查看当前设置
cat /proc/sys/vm/min_free_kbytes

# 根据内存大小调整
total_mem_kb=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
recommended=$(($(echo "sqrt($total_mem_kb * 16)" | bc -l | cut -d. -f1)))

echo "推荐设置: ${recommended}KB"

# 实际设置 (8GB内存示例)
echo 262144 > /proc/sys/vm/min_free_kbytes  # 256MB

# 验证效果
cat /proc/buddyinfo  # 查看空闲内存块分布
```

---

## 4. 📄 脏页管理参数


### 4.1 脏页概念详解


**💡 什么是脏页**
```
脏页 (Dirty Page)：内存中已被修改但尚未写入磁盘的页面
产生过程：
1. 应用程序修改文件内容
2. 修改先写入内存中的页面缓存
3. 该页面标记为"脏页" 
4. 稍后由内核统一写入磁盘

为什么需要管理脏页：
• 太多脏页：系统崩溃时数据丢失风险大
• 太少脏页：频繁磁盘写入影响性能
• 需要平衡：数据安全性 vs 写入性能
```

### 4.2 vm.dirty_ratio - 脏页比例控制


**🔸 参数含义**
```
vm.dirty_ratio：系统脏页的最大比例阈值
取值范围：1-100 (百分比)
默认值：20
触发机制：超过此比例时，写入进程会被阻塞等待刷写
```

**⚡ 工作机制**
```
脏页阈值控制流程：
当脏页占用内存比例 > dirty_ratio时：
1. 阻塞正在写入的应用进程
2. 强制启动磁盘刷写操作  
3. 等待脏页比例降低后继续执行

实际场景举例：
系统内存8GB，dirty_ratio=20：
最大脏页量 = 8GB × 20% = 1.6GB
当脏页超过1.6GB时，write()系统调用会被阻塞
```

**🎯 配置建议**
```bash
# 不同场景的配置策略
# 📊 数据库服务器 (重视数据安全)
echo 5 > /proc/sys/vm/dirty_ratio      # 严格控制脏页

# 🌐 Web服务器 (平衡性能与安全)  
echo 15 > /proc/sys/vm/dirty_ratio     # 中等控制

# 🔄 批处理服务器 (重视写入性能)
echo 40 > /proc/sys/vm/dirty_ratio     # 宽松控制

# 💾 SSD存储系统 (写入速度快)
echo 30 > /proc/sys/vm/dirty_ratio     # 可以适当放宽
```

### 4.3 vm.dirty_background_ratio - 后台刷写


**🔸 参数含义**
```
vm.dirty_background_ratio：触发后台刷写的脏页比例
取值范围：1-100 (百分比)  
默认值：10
机制：达到此比例时，启动后台刷写但不阻塞应用
```

**🔄 双重阈值机制**
```
脏页刷写的两个阈值：
┌─────────────────────┐
│     正常运行区      │ 0% - dirty_background_ratio
├─────────────────────┤  
│   后台刷写激活区    │ dirty_background_ratio - dirty_ratio
├─────────────────────┤
│     强制刷写区      │ dirty_ratio - 100%
└─────────────────────┘

工作流程：
• 0-10%：正常运行，不刷写
• 10-20%：后台daemon开始刷写，应用不阻塞  
• >20%：强制刷写，阻塞写入进程
```

**📊 性能影响分析**
```bash
# 监控脏页变化
watch -n 1 'cat /proc/meminfo | grep -i dirty'
Dirty:            102400 kB    # 当前脏页
Writeback:          2048 kB    # 正在写回的页面

# 测试不同配置的写入性能
dd if=/dev/zero of=/tmp/testfile bs=1M count=1000

# dirty_background_ratio=5, dirty_ratio=10 (保守配置)
1000+0 records in/out
1048576000 bytes transferred in 15.2s (69MB/s)

# dirty_background_ratio=15, dirty_ratio=30 (激进配置)  
1000+0 records in/out
1048576000 bytes transferred in 8.4s (125MB/s)
```

---

## 5. 🔄 内存回收策略参数


### 5.1 内存回收时机控制


**📊 回收触发条件**
```
Linux内存回收触发机制：
                        
        总内存
    ┌─────────────┐
    │    Used     │ ← 应用使用内存
    ├─────────────┤
    │   Cached    │ ← 页面缓存
    ├─────────────┤  
    │   Buffer    │ ← 缓冲区
    ├─────────────┤
    │    Free     │ ← 空闲内存
    └─────────────┘
         ↑
    min_free_kbytes  ← 触发回收的阈值
```

**⚡ kswapd内核线程**
```
kswapd：内核内存回收守护进程
工作原理：
1. 持续监控内存使用情况
2. 当空闲内存 < min_free_kbytes时启动
3. 回收页面缓存、匿名页面(swap)
4. 维持足够的空闲内存供系统分配

查看kswapd活动：
cat /proc/vmstat | grep kswapd
kswapd_inodesteal 12345      # 回收的inode数量
kswapd_low_wmark_hit_quickly 678  # 快速达到低水位次数
```

### 5.2 回收策略优化


**🔧 回收优先级调整**
```bash
# 内存压力测试工具
apt install stress-ng

# 测试内存回收行为
stress-ng --vm 4 --vm-bytes 75% --timeout 60s

# 观察回收统计
vmstat 1 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0 256000  64000 1024000    0    0     0   100  800 1200 25 15 60  0  0
 4  1    512 128000  32000  512000    0  512    0   500 1200 2000 40 30 30  0  0
 
# si/so：swap in/out 页面数
# bi/bo：块设备读写次数  
# 观察swap活动和I/O压力的关系
```

---

## 6. 💾 参数持久化配置


### 6.1 配置文件管理


**🔧 /etc/sysctl.conf 配置**
```bash
# 编辑系统配置文件
vim /etc/sysctl.conf

# 添加内存管理参数
# === Swap 和内存管理优化 ===
# 减少swap使用，优先回收缓存
vm.swappiness = 10

# 控制VFS缓存压力（文件服务器可降低到50）
vm.vfs_cache_pressure = 100

# 脏页管理 - 数据安全优先
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5

# 最小空闲内存（8GB内存系统）
vm.min_free_kbytes = 262144

# NUMA系统优化（默认关闭zone reclaim）
vm.zone_reclaim_mode = 0
```

**⚡ 立即生效命令**
```bash
# 重新加载配置
sysctl -p

# 或者单独设置
sysctl -w vm.swappiness=10

# 验证设置
sysctl vm.swappiness
vm.swappiness = 10

# 查看所有内存相关参数
sysctl -a | grep vm | grep -E "(swap|dirty|cache|free)"
```

### 6.2 场景化配置模板


**📋 不同环境的完整配置**
```bash
# ==========================================
# 🗄️ 数据库服务器配置模板
# ==========================================
cat > /etc/sysctl.d/99-database-memory.conf << 'EOF'
# 最小化swap使用
vm.swappiness = 1
# 保留更多VFS缓存（频繁的元数据访问）
vm.vfs_cache_pressure = 50  
# 严格的脏页控制（数据安全）
vm.dirty_ratio = 10
vm.dirty_background_ratio = 3
# 充足的空闲内存
vm.min_free_kbytes = 524288
# 关闭zone reclaim（性能优先）
vm.zone_reclaim_mode = 0
EOF

# ==========================================  
# 🌐 Web服务器配置模板
# ==========================================
cat > /etc/sysctl.d/99-webserver-memory.conf << 'EOF'
# 轻度使用swap
vm.swappiness = 10
# 平衡的缓存压力
vm.vfs_cache_pressure = 100
# 平衡的脏页管理
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5  
# 标准空闲内存
vm.min_free_kbytes = 262144
# 关闭zone reclaim
vm.zone_reclaim_mode = 0
EOF

# ==========================================
# 🗃️ 文件服务器配置模板  
# ==========================================
cat > /etc/sysctl.d/99-fileserver-memory.conf << 'EOF'
# 中等swap使用（大量缓存需求）
vm.swappiness = 30
# 降低VFS缓存压力（保留目录缓存）
vm.vfs_cache_pressure = 50
# 宽松的脏页管理（批量写入优化）
vm.dirty_ratio = 25
vm.dirty_background_ratio = 10
# 标准空闲内存
vm.min_free_kbytes = 262144  
# 启用zone reclaim（I/O密集）
vm.zone_reclaim_mode = 1
EOF
```

---

## 7. 🎯 不同场景调优策略


### 7.1 高并发Web服务器


**🌐 负载特征分析**
```
Web服务器工作负载特点：
• 大量短连接请求
• 频繁的小文件访问  
• 内存使用相对稳定
• 对响应延迟敏感

优化目标：
✅ 减少延迟尖刺
✅ 保持稳定的响应时间
✅ 避免因swap导致的性能抖动
```

**⚡ 具体优化配置**
```bash
# Web服务器优化脚本
#!/bin/bash
# 设置较低的swappiness，避免交换延迟
echo 10 > /proc/sys/vm/swappiness

# 保持默认的VFS缓存压力
echo 100 > /proc/sys/vm/vfs_cache_pressure

# 适中的脏页控制，平衡性能与数据安全
echo 15 > /proc/sys/vm/dirty_ratio
echo 5 > /proc/sys/vm/dirty_background_ratio

# 根据内存大小设置最小空闲内存（以8GB为例）
echo 262144 > /proc/sys/vm/min_free_kbytes

# 关闭zone reclaim，优先使用远程内存
echo 0 > /proc/sys/vm/zone_reclaim_mode

echo "Web服务器内存优化完成"
```

**📊 效果监控**
```bash
# 性能监控命令
# 1. 监控swap使用情况
watch -n 1 'free -m | head -2'

# 2. 监控页面回收活动
cat /proc/vmstat | grep -E "(pgsteal|pgscan)"
pgsteal_kswapd_dma32 0
pgsteal_kswapd_normal 45123
pgscan_kswapd_normal 67890

# 3. Web服务器响应时间测试
ab -n 10000 -c 100 http://localhost/
```

### 7.2 内存数据库系统


**🗄️ Redis/MemCached优化**
```
内存数据库特点：
• 数据完全存储在内存中
• 对内存访问延迟极度敏感
• 不能容忍swap操作
• 需要可预测的内存分配

关键策略：
🚨 绝对避免swap
🚨 预留充足的空闲内存
🚨 快速回收页面缓存
```

**🔧 激进的内存优化**
```bash
#!/bin/bash
# Redis/内存数据库专用优化

# 几乎禁用swap（设为1而不是0，避免OOM）
echo 1 > /proc/sys/vm/swappiness

# 积极回收VFS缓存，为数据让路
echo 200 > /proc/sys/vm/vfs_cache_pressure

# 严格控制脏页，快速刷写
echo 5 > /proc/sys/vm/dirty_ratio
echo 2 > /proc/sys/vm/dirty_background_ratio

# 预留大量空闲内存，避免内存分配延迟
total_mem=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
min_free=$((total_mem / 20))  # 预留5%内存
echo $min_free > /proc/sys/vm/min_free_kbytes

# 关闭zone reclaim
echo 0 > /proc/sys/vm/zone_reclaim_mode

# 透明大页优化（Redis建议）
echo never > /sys/kernel/mm/transparent_hugepage/enabled

echo "内存数据库优化完成，min_free_kbytes设置为: ${min_free}KB"
```

### 7.3 大数据批处理系统


**📊 Hadoop/Spark工作负载**
```
大数据系统特点：
• 大量顺序I/O操作
• 需要大量页面缓存
• 能容忍一定的延迟
• 内存使用模式多样

优化策略：
💾 适度使用swap缓解内存压力
💾 保留大量页面缓存
💾 宽松的脏页管理
```

**🔄 批处理优化配置**
```bash
#!/bin/bash  
# 大数据批处理系统优化

# 中等swap使用，缓解内存压力
echo 30 > /proc/sys/vm/swappiness

# 降低VFS缓存压力，保留页面缓存
echo 50 > /proc/sys/vm/vfs_cache_pressure

# 宽松的脏页管理，提高写入吞吐量
echo 40 > /proc/sys/vm/dirty_ratio
echo 15 > /proc/sys/vm/dirty_background_ratio

# 标准的最小空闲内存设置
total_mem=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
min_free=$((total_mem / 64))  # 约1.5%
echo $min_free > /proc/sys/vm/min_free_kbytes

# 启用zone reclaim（NUMA优化）
echo 1 > /proc/sys/vm/zone_reclaim_mode

echo "大数据系统优化完成"

# 额外的I/O调度优化
echo deadline > /sys/block/sda/queue/scheduler
echo 4096 > /sys/block/sda/queue/nr_requests
```

### 7.4 容器化环境优化


**🐳 Docker/K8s环境特点**
```
容器环境特殊性：
• 多个容器共享宿主机内存
• 容器内存限制（cgroup）
• 动态的内存分配模式
• 需要考虑容器密度

优化考虑：
⚖️ 平衡swap使用和容器性能
⚖️ 避免容器间的内存竞争
⚖️ 保持系统稳定性
```

**🔧 容器宿主机优化**
```bash
#!/bin/bash
# 容器宿主机内存优化

# 适中的swap设置，避免容器OOM
echo 20 > /proc/sys/vm/swappiness

# 标准VFS缓存压力
echo 100 > /proc/sys/vm/vfs_cache_pressure

# 中等脏页控制
echo 20 > /proc/sys/vm/dirty_ratio
echo 8 > /proc/sys/vm/dirty_background_ratio

# 容器环境需要更多空闲内存
total_mem=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
min_free=$((total_mem / 32))  # 约3%
echo $min_free > /proc/sys/vm/min_free_kbytes

# 关闭zone reclaim，容器可能跨NUMA运行
echo 0 > /proc/sys/vm/zone_reclaim_mode

# 容器特殊配置
echo 1 > /proc/sys/vm/overcommit_memory  # 允许内存超分配
echo 80 > /proc/sys/vm/overcommit_ratio  # 超分配比例

echo "容器宿主机优化完成"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 vm.swappiness：控制swap使用积极性，不是内存阈值而是回收策略权重
🔸 vm.vfs_cache_pressure：VFS缓存vs页面缓存的回收优先级
🔸 vm.dirty_ratio：强制刷写阈值，超过会阻塞写入进程  
🔸 vm.dirty_background_ratio：后台刷写阈值，不阻塞进程
🔸 vm.min_free_kbytes：系统保留的最小空闲内存
🔸 vm.zone_reclaim_mode：NUMA环境下的内存回收策略
```

### 8.2 关键理解要点


**🔹 参数之间的相互关系**
```
内存管理参数协同工作：
• swappiness 影响匿名页面 vs 文件页面回收
• vfs_cache_pressure 影响元数据缓存 vs 数据缓存回收  
• dirty参数控制写入行为和内存释放时机
• min_free_kbytes 确保系统基本运行需求
```

**🔹 调优的基本原则**
```
性能 vs 安全的权衡：
• 高性能：较大dirty_ratio，较低swappiness
• 高安全：较小dirty_ratio，较高vfs_cache_pressure
• 平衡：根据具体工作负载特点调整

不同工作负载的特征：
• I/O密集：注重缓存管理和脏页控制
• 内存密集：注重swap控制和空闲内存
• 批处理：可以牺牲响应性换取吞吐量
• 实时应用：严格控制延迟相关参数
```

### 8.3 实际应用价值


**🎯 生产环境应用**
- **数据库服务器**：最小化swap，严格脏页控制
- **Web服务器**：平衡性能与稳定性
- **文件服务器**：优化缓存管理，宽松脏页控制
- **大数据系统**：适度swap，优化I/O模式
- **容器环境**：考虑多租户特性，保持系统稳定

**🔧 调优实践要点**
- **逐步调整**：一次修改一个参数，观察效果
- **基准测试**：调整前后对比具体的性能指标
- **持续监控**：使用vmstat、/proc/meminfo等工具跟踪
- **文档记录**：记录修改原因和预期效果

**核心记忆要点**：
- 内存管理参数需要协同优化，不能孤立调整
- 不同应用场景需要不同的调优策略
- 性能和数据安全需要根据业务需求平衡
- 参数调整要基于实际测试和监控数据