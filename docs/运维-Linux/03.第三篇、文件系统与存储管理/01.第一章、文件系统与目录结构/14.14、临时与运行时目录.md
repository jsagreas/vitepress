---
title: 14、临时与运行时目录
---
## 📚 目录

1. [临时目录基本概念](#1-临时目录基本概念)
2. [/tmp临时文件目录详解](#2-tmp临时文件目录详解)
3. [/run运行时数据目录](#3-run运行时数据目录)
4. [tmpfs内存文件系统](#4-tmpfs内存文件系统)
5. [临时文件安全管理](#5-临时文件安全管理)
6. [进程与套接字文件管理](#6-进程与套接字文件管理)
7. [系统清理机制](#7-系统清理机制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📁 临时目录基本概念


### 1.1 什么是临时目录


**简单理解**：临时目录就像你桌上的草稿纸，用来放一些短期需要的文件

```
日常类比：
桌面草稿纸 → 临时目录
- 写计算过程 → 程序运行时的中间文件  
- 临时记录 → 进程间通信数据
- 用完就扔 → 系统重启或定期清理

特点：
✓ 存放临时性数据
✓ 系统重启后可能清空
✓ 多个程序共享使用
✓ 自动清理过期文件
```

### 1.2 临时目录的作用


**🎯 主要用途**：
```
程序运行临时文件：
- 编译过程中的中间文件
- 下载时的临时文件
- 程序缓存数据

系统运行时数据：
- 进程PID文件（记录进程号）
- 套接字文件（进程间通信）
- 锁文件（防止重复运行）

用户临时操作：
- 文件解压缩的临时目录
- 临时脚本和配置文件
- 系统维护时的临时数据
```

### 1.3 Linux中的主要临时目录


```
目录布局概览：
/tmp/           ← 传统临时目录，所有用户可用
/var/tmp/       ← 长期临时文件，重启不清空
/run/           ← 运行时数据，现代Linux标准
/dev/shm/       ← 内存共享区域

目录对比：
┌──────────┬─────────────┬─────────────┬─────────────┐
│   目录   │    清理时机  │   持久性    │   主要用途   │
├──────────┼─────────────┼─────────────┼─────────────┤
│  /tmp/   │  定期/重启   │    短期     │  临时文件   │
│/var/tmp/ │  手动清理   │    较长     │  持久临时   │
│  /run/   │    重启     │  运行时     │  系统数据   │
│/dev/shm/ │    重启     │   内存中    │  共享内存   │
└──────────┴─────────────┴─────────────┴─────────────┘
```

---

## 2. 📂 /tmp临时文件目录详解


### 2.1 /tmp目录特性


**🔸 核心特点**：
```
访问权限：
- 任何用户都可以创建文件
- 只有文件所有者可以删除自己的文件
- 设置了sticky bit（粘滞位）

权限查看：
$ ls -ld /tmp
drwxrwxrwt 10 root root 4096 Sep 14 15:30 /tmp
           ↑
       粘滞位标记
```

**💡 粘滞位的作用**：
```
没有粘滞位的情况：
- 任何人都能删除别人的文件
- 安全风险很大

有粘滞位的保护：
- 只有文件所有者能删除自己的文件
- root用户可以删除任意文件
- 类似公共桌面，每人只能动自己的东西
```

### 2.2 /tmp目录的实际应用


**🛠️ 常见使用场景**：

```bash
# 1. 程序编译时的临时文件
$ gcc -c hello.c          # 生成 hello.o 临时对象文件
$ make                    # 构建过程产生大量临时文件

# 2. 下载和解压操作
$ cd /tmp
$ wget http://example.com/archive.tar.gz
$ tar -xzf archive.tar.gz  # 解压到临时目录

# 3. 创建临时脚本
$ cat > /tmp/quick_test.sh << EOF
#!/bin/bash
echo "临时测试脚本"
EOF
$ chmod +x /tmp/quick_test.sh
$ /tmp/quick_test.sh
```

**📊 /tmp目录使用示例**：
```
实际文件示例：
/tmp/
├── ssh-agent.socket     ← SSH代理套接字
├── temp_download.zip    ← 临时下载文件  
├── build_12345/         ← 编译临时目录
├── .X11-unix/           ← X11图形界面套接字
└── user_session_files/  ← 用户会话文件
```

### 2.3 /tmp目录管理


**⚙️ 空间管理**：
```bash
# 查看/tmp目录使用情况
$ df -h /tmp
Filesystem      Size  Used Avail Use% Mounted on
tmpfs           2.0G  156M  1.9G   8% /tmp

# 查看/tmp下占用空间大的文件
$ du -sh /tmp/* | sort -hr
245M    /tmp/large_temp_file
89M     /tmp/build_cache
12M     /tmp/downloads
```

**🧹 手动清理示例**：
```bash
# 删除7天前的临时文件（小心使用）
$ find /tmp -type f -mtime +7 -delete

# 删除大于100MB的文件
$ find /tmp -type f -size +100M -ls

# 清理特定用户的临时文件
$ find /tmp -user username -delete
```

---

## 3. 🚀 /run运行时数据目录


### 3.1 /run目录的设计理念


**🎯 现代化设计**：
```
传统问题：
以前各种运行时文件分散在：
- /var/run/    ← PID文件
- /var/lock/   ← 锁文件  
- /tmp/        ← 套接字文件

现代解决方案：
统一到 /run/ 目录下：
- 更清晰的组织结构
- 统一的权限管理
- 系统重启自动清空
```

### 2.2 /run目录结构详解


```
/run/ 目录典型内容：
/run/
├── systemd/          ← systemd服务管理数据
│   ├── system/       ← 系统服务状态
│   └── user/         ← 用户服务数据
├── dbus/             ← 消息总线通信
├── NetworkManager/   ← 网络管理器数据
├── user/             ← 用户运行时目录
│   └── 1000/         ← UID 1000用户的数据
├── lock/             ← 锁文件目录
└── utmp              ← 当前登录用户信息

重要文件：
/run/systemd/system/   ← 系统服务状态文件
/run/user/1000/        ← 用户运行时目录（根据UID变化）
/run/NetworkManager/   ← 网络连接状态信息
```

**💻 实际查看示例**：
```bash
# 查看/run目录结构
$ ls -la /run/
drwxr-xr-x  25 root root       880 Sep 14 15:30 .
drwxr-xr-x  20 root root      4096 Sep 13 10:00 ..
drwxr-xr-x   2 root root        60 Sep 14 15:25 lock
drwxr-xr-x   3 root root        60 Sep 14 15:25 systemd
drwx------   3 user user        60 Sep 14 15:30 user

# 查看当前用户的运行时目录
$ echo $XDG_RUNTIME_DIR
/run/user/1000

$ ls -la $XDG_RUNTIME_DIR
total 0
drwx------ 3 user user  120 Sep 14 15:30 .
drwxr-xr-x 3 root root   60 Sep 14 15:25 ..
srw-rw-rw- 1 user user    0 Sep 14 15:30 bus
drw------- 2 user user   40 Sep 14 15:30 systemd
```

### 3.3 /run目录的实际应用


**🔧 系统服务应用**：
```bash
# 查看systemd服务的运行时数据
$ ls /run/systemd/system/
ssh.service
NetworkManager.service
cron.service

# 查看网络管理器状态
$ ls /run/NetworkManager/
NetworkManager.conf
NetworkManager.state
```

**👤 用户应用环境**：
```bash
# 用户运行时目录（每个用户有独立目录）
$ ls /run/user/$(id -u)/
bus           ← D-Bus用户会话总线
systemd/      ← 用户systemd服务
gvfs/         ← 虚拟文件系统
pulse/        ← 音频系统
```

---

## 4. 💾 tmpfs内存文件系统


### 4.1 tmpfs基本概念


**简单理解**：tmpfs就像把内存当作硬盘来用

```
传统硬盘文件系统：
数据 → 写入硬盘 → 持久保存 → 访问较慢

tmpfs内存文件系统：
数据 → 存在内存 → 断电丢失 → 访问超快

优势对比：
┌─────────────┬─────────────┬─────────────┐
│    特性     │    硬盘     │   tmpfs     │
├─────────────┼─────────────┼─────────────┤
│   访问速度   │     慢      │    极快     │
│   数据持久   │    持久     │   不持久    │
│   容量限制   │    很大     │  受内存限制  │
│   适用场景   │  长期存储   │   临时数据  │
└─────────────┴─────────────┴─────────────┘
```

### 4.2 tmpfs在Linux中的应用


**🖥️ 系统默认挂载**：
```bash
# 查看系统中的tmpfs挂载
$ df -t tmpfs
Filesystem     1K-blocks    Used Available Use% Mounted on
tmpfs            2048576     156   2048420   1% /tmp
tmpfs            2048576       8   2048568   1% /run
tmpfs            2048576       0   2048576   0% /dev/shm

# 详细查看挂载信息
$ mount | grep tmpfs
tmpfs on /tmp type tmpfs (rw,nosuid,nodev,noexec)
tmpfs on /run type tmpfs (rw,nosuid,nodev,noexec,mode=755)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
```

**📊 各tmpfs目录的用途**：
```
/tmp (tmpfs)：
作用：临时文件存储
特点：任何用户可写，有粘滞位
大小：通常为内存的50%

/run (tmpfs)：
作用：运行时数据存储
特点：系统管理，普通用户只读根目录
大小：通常比较小，够用即可

/dev/shm (tmpfs)：
作用：共享内存段存储
特点：进程间共享大数据
大小：通常为内存的50%
```

### 4.3 tmpfs的优势与限制


**✅ 主要优势**：
```
性能优势：
• 读写速度：接近内存速度（GB/s级别）
• 无磁盘IO：不占用磁盘带宽
• 低延迟：没有机械延迟

资源优势：
• 动态大小：按需分配内存
• 自动清理：重启自动清空
• 减少磁盘磨损：SSD友好
```

**⚠️ 使用限制**：
```
容量限制：
• 受系统内存限制
• 默认最大50%内存
• 大文件可能导致内存不足

持久性限制：
• 断电数据丢失
• 系统崩溃数据丢失
• 不适合重要数据

安全考虑：
• 内存数据可能被交换到硬盘
• 敏感数据需要特别处理
```

---

## 5. 🔐 临时文件安全管理


### 5.1 临时文件安全风险


**⚠️ 常见安全问题**：
```
文件名冲突攻击：
恶意用户预先创建同名文件 → 程序写入时被劫持

符号链接攻击：
创建恶意符号链接 → 程序误写入重要文件

权限提升攻击：
利用临时文件权限漏洞 → 获取更高权限

时间竞争攻击：
在文件创建和使用之间的时间窗口进行攻击
```

### 5.2 安全创建临时文件


**🔒 安全创建方法**：

```bash
# 1. 使用mktemp安全创建临时文件
$ temp_file=$(mktemp)
$ echo "安全的临时文件：$temp_file"
安全的临时文件：/tmp/tmp.X7vQ2p9mKL

# mktemp的安全特性：
# - 自动生成唯一文件名
# - 创建时设置安全权限（600）
# - 原子性操作，避免竞争条件

# 2. 创建临时目录
$ temp_dir=$(mktemp -d)
$ echo "临时目录：$temp_dir"
临时目录：/tmp/tmp.Bg8K3mNxYq

# 3. 指定临时文件模板
$ mktemp /tmp/myapp_XXXXXX
/tmp/myapp_Kp9sL2
```

**📝 脚本中的安全实践**：
```bash
#!/bin/bash
# 安全临时文件处理示例

# 创建安全的临时文件
TEMP_FILE=$(mktemp) || {
    echo "无法创建临时文件" >&2
    exit 1
}

# 确保脚本退出时清理临时文件
cleanup() {
    rm -f "$TEMP_FILE"
}
trap cleanup EXIT

# 使用临时文件
echo "处理数据..." > "$TEMP_FILE"
process_data "$TEMP_FILE"

# 脚本结束时自动清理（由trap触发）
```

### 5.3 临时文件权限管理


**🛡️ 权限最佳实践**：
```bash
# 1. 创建文件时设置安全权限
$ touch /tmp/myfile
$ chmod 600 /tmp/myfile    # 只有所有者可读写

# 2. 查看文件权限
$ ls -l /tmp/myfile
-rw------- 1 user user 0 Sep 14 15:30 /tmp/myfile

# 3. 对于需要共享的临时文件
$ chmod 644 /tmp/shared_file    # 所有者读写，其他人只读
```

**🔧 umask设置**：
```bash
# 查看当前umask
$ umask
0022

# 在脚本中设置更严格的umask
umask 077    # 创建的文件只有所有者可访问

# 创建文件测试权限
$ touch test_file
$ ls -l test_file
-rw------- 1 user user 0 Sep 14 15:30 test_file
```

---

## 6. 📋 进程与套接字文件管理


### 6.1 PID文件管理


**💡 PID文件的作用**：
```
PID文件 = 进程身份证：
• 记录进程的进程号（PID）
• 防止同一程序重复启动
• 便于管理和监控进程
• 提供进程间通信机制
```

**📁 PID文件位置**：
```
系统服务PID文件：
/run/nginx.pid          ← Web服务器
/run/ssh.pid            ← SSH服务
/run/systemd/system/    ← systemd管理的服务

用户程序PID文件：
/tmp/user_app.pid       ← 用户程序
~/.local/run/app.pid    ← 用户目录下
```

**🔧 PID文件操作示例**：
```bash
# 1. 创建PID文件
$ echo $$ > /run/myapp.pid    # $$表示当前shell进程号

# 2. 读取PID文件
$ cat /run/nginx.pid
1234

# 3. 检查进程是否存在
$ pid=$(cat /run/myapp.pid 2>/dev/null)
$ if kill -0 $pid 2>/dev/null; then
    echo "进程 $pid 正在运行"
else
    echo "进程不存在，清理PID文件"
    rm -f /run/myapp.pid
fi
```

### 6.2 套接字文件详解


**🔌 套接字文件基本概念**：
```
套接字文件 = 进程通信管道：
• 用于同一主机上进程间通信
• 比网络套接字更高效
• 像特殊的文件，但不存储数据
• 只是通信的"接口"
```

**📂 常见套接字文件**：
```bash
# 查看系统中的套接字文件
$ find /tmp /run -type s 2>/dev/null | head -10
/tmp/.X11-unix/X0           ← X11图形界面
/run/dbus/system_bus_socket ← 系统消息总线
/run/user/1000/bus          ← 用户消息总线
/run/systemd/private        ← systemd管理通信

# 查看套接字文件详细信息
$ ls -la /tmp/.X11-unix/X0
srwxrwxrwx 1 root root 0 Sep 14 15:30 /tmp/.X11-unix/X0
↑
s表示套接字文件类型
```

**💻 套接字文件实际应用**：
```bash
# 1. Docker守护进程套接字
$ ls -la /var/run/docker.sock
srw-rw---- 1 root docker 0 Sep 14 15:30 /var/run/docker.sock

# 2. MySQL数据库套接字
$ ls -la /var/run/mysqld/mysqld.sock
srwxrwxrwx 1 mysql mysql 0 Sep 14 15:30 /var/run/mysqld/mysqld.sock

# 3. 通过套接字连接（比TCP更快）
$ mysql -S /var/run/mysqld/mysqld.sock
```

### 6.3 进程文件清理机制


**🧹 自动清理策略**：
```bash
# 1. 检查并清理孤儿PID文件
cleanup_pid_files() {
    for pidfile in /run/*.pid; do
        [ -f "$pidfile" ] || continue
        
        pid=$(cat "$pidfile" 2>/dev/null)
        if ! kill -0 "$pid" 2>/dev/null; then
            echo "清理孤儿PID文件：$pidfile"
            rm -f "$pidfile"
        fi
    done
}

# 2. 清理无效套接字文件
cleanup_socket_files() {
    find /tmp -name "*.sock" -type s | while read socket; do
        # 尝试连接测试套接字是否有效
        if ! timeout 1 bash -c "echo > /dev/tcp/localhost/$(basename $socket)" 2>/dev/null; then
            echo "清理无效套接字：$socket"
            rm -f "$socket"
        fi
    done
}
```

---

## 7. 🕒 系统清理机制


### 7.1 systemd-tmpfiles清理服务


**⚙️ 现代清理机制**：
```
systemd-tmpfiles：
• 现代Linux发行版的标准清理工具
• 基于配置文件的规则清理
• 定时自动运行
• 支持复杂的清理条件
```

**📝 清理配置文件**：
```bash
# 查看清理配置文件
$ ls /usr/lib/tmpfiles.d/
tmp.conf
systemd.conf
x11.conf

# 查看tmp.conf内容
$ cat /usr/lib/tmpfiles.d/tmp.conf
#  Path        Mode UID  GID  Age    Argument
d  /tmp        1777 root root 10d    -
d  /var/tmp    1777 root root 30d    -
X  /tmp/*      -    -    -    10d    -
X  /var/tmp/*  -    -    -    30d    -

配置含义：
d = 创建目录
X = 删除匹配的文件/目录
10d = 10天前的文件
30d = 30天前的文件
```

**🔧 手动执行清理**：
```bash
# 手动运行清理服务
$ sudo systemd-tmpfiles --clean

# 查看清理服务状态
$ systemctl status systemd-tmpfiles-clean
● systemd-tmpfiles-clean.service
   Active: inactive (dead)
   
# 查看定时清理任务
$ systemctl list-timers | grep tmpfiles
systemd-tmpfiles-clean.timer  PASSED   12h left
```

### 7.2 传统cron清理机制


**⏰ cron清理任务**：
```bash
# 查看系统清理cron任务
$ ls /etc/cron.daily/ | grep tmp
tmpwatch

# 典型的清理脚本内容
#!/bin/bash
# 清理10天前的/tmp文件
find /tmp -type f -atime +10 -delete

# 清理30天前的/var/tmp文件  
find /var/tmp -type f -atime +30 -delete

# 清理空目录
find /tmp /var/tmp -type d -empty -delete
```

### 7.3 自定义清理策略


**📋 智能清理脚本**：
```bash
#!/bin/bash
# 智能临时文件清理脚本

LOG_FILE="/var/log/temp_cleanup.log"

log_message() {
    echo "$(date): $1" >> "$LOG_FILE"
}

# 清理大文件（>100MB且>1天）
cleanup_large_files() {
    local count=0
    find /tmp -type f -size +100M -mtime +1 -print0 | \
    while IFS= read -r -d '' file; do
        size=$(du -h "$file" | cut -f1)
        rm -f "$file"
        log_message "删除大文件: $file ($size)"
        ((count++))
    done
    log_message "清理大文件完成，删除 $count 个文件"
}

# 清理特定类型文件
cleanup_by_type() {
    # 清理临时下载文件
    find /tmp -name "*.tmp" -mtime +3 -delete
    find /tmp -name "*.temp" -mtime +3 -delete
    
    # 清理编译临时文件
    find /tmp -name "*.o" -mtime +1 -delete
    find /tmp -name "core.*" -mtime +1 -delete
    
    log_message "按类型清理完成"
}

# 主清理函数
main() {
    log_message "开始临时文件清理"
    
    # 检查磁盘使用率
    usage=$(df /tmp | awk 'NR==2 {print $5}' | sed 's/%//')
    
    if [ "$usage" -gt 80 ]; then
        log_message "临时目录使用率 ${usage}%，开始积极清理"
        cleanup_large_files
        cleanup_by_type
    else
        log_message "临时目录使用率 ${usage}%，执行常规清理"
        cleanup_by_type
    fi
    
    log_message "清理完成"
}

main "$@"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 临时目录本质：存放短期数据，系统重启或定期清理
🔸 主要目录：/tmp（通用）、/run（运行时）、/var/tmp（持久临时）
🔸 tmpfs优势：内存文件系统，速度快但不持久
🔸 安全原则：使用mktemp、设置正确权限、及时清理
🔸 系统管理：PID文件、套接字文件、自动清理机制
```

### 8.2 关键理解要点


**🔹 目录选择原则**
```
/tmp/：
✓ 短期临时文件（几小时到几天）
✓ 可能被定期清理
✓ 系统重启通常清空

/var/tmp/：
✓ 需要在重启后保留的临时文件
✓ 清理周期更长（通常30天）
✓ 适合大文件或长期临时数据

/run/：  
✓ 系统和服务运行时数据
✓ 系统重启必定清空
✓ 不适合用户数据
```

**🔹 安全使用要点**
```
文件权限：
• 使用mktemp创建安全临时文件
• 设置适当的umask
• 避免在脚本中硬编码文件名

清理机制：
• 设置trap确保清理
• 定期检查并清理孤儿文件
• 监控磁盘使用情况
```

### 8.3 实际应用指导


**💼 开发最佳实践**：
```bash
# 1. 脚本中使用临时文件模板
#!/bin/bash
TEMP_FILE=$(mktemp /tmp/myapp.XXXXXX)
trap "rm -f $TEMP_FILE" EXIT

# 2. 长期运行程序的PID管理
echo $$ > /run/myapp.pid
trap "rm -f /run/myapp.pid" EXIT

# 3. 监控临时目录使用
df -h /tmp | awk 'NR==2 {print "临时目录使用:", $5}'
```

**🎯 系统管理要点**：
- **监控空间**：定期检查临时目录使用情况
- **清理策略**：根据业务需求调整清理周期
- **权限审计**：定期检查临时文件权限
- **性能优化**：考虑将/tmp挂载为tmpfs提升性能

**🧠 记忆要点**：
```
临时目录记忆口诀：
/tmp短期存，/var/tmp长一点
/run运行时，重启就清空
tmpfs在内存，速度快如电
mktemp保安全，权限要设严
```

**核心记忆**：
- 临时目录是系统运行的"草稿纸"，用完要清理
- 不同目录有不同的生命周期和用途
- 安全创建和及时清理是使用临时文件的关键
- tmpfs提供内存级别的高速临时存储
- 系统有自动清理机制，但也要主动管理