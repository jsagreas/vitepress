---
title: 12、可变数据目录详解
---
## 📚 目录

1. [/var目录核心概念](#1-var目录核心概念)
2. [/var/log日志文件系统](#2-varlog日志文件系统)
3. [/var/spool队列文件管理](#3-varspool队列文件管理)
4. [/var/cache缓存文件存储](#4-varcache缓存文件存储)
5. [/var/lib应用数据管理](#5-varlib应用数据管理)
6. [/var/tmp临时文件处理](#6-vartmp临时文件处理)
7. [日志轮转机制详解](#7-日志轮转机制详解)
8. [磁盘空间监控策略](#8-磁盘空间监控策略)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📁 /var目录核心概念


### 1.1 什么是/var目录

🎯 **简单理解**：/var就像家里的"储物间"，专门存放会变化的东西

```
生活中的类比：
家庭固定物品 → /usr, /bin (程序文件，很少变)
家庭变化物品 → /var (日志、缓存、队列，经常变)

/var的特点：
- Variable的缩写，意思是"可变的"
- 存储运行时产生的数据
- 文件大小和内容经常变化
- 系统正常运行必不可少
```

**🔸 /var目录的核心作用**
```
系统运行时数据存储：
应用程序 → 产生日志 → 存到/var/log
邮件系统 → 邮件队列 → 存到/var/spool
软件包管理 → 缓存包 → 存到/var/cache
数据库 → 数据文件 → 存到/var/lib
用户操作 → 临时文件 → 存到/var/tmp
```

### 1.2 /var目录结构总览

**📊 /var子目录功能映射**

```
/var目录树状结构：
/var/
├── log/          ← 日志文件(最重要)
├── spool/        ← 队列文件(邮件、打印等)
├── cache/        ← 缓存文件(软件包、网页等)
├── lib/          ← 应用程序数据文件
├── tmp/          ← 临时文件(比/tmp更持久)
├── run/          ← 运行时文件(PID、socket等)
├── lock/         ← 锁文件(防止重复运行)
└── opt/          ← /opt下程序的可变数据
```

**🔍 目录用途详解**
```
按变化频率分类：
🔴 高频变化：log/, run/, lock/
🟡 中频变化：spool/, tmp/
🟢 低频变化：lib/, cache/, opt/

按重要性分类：
⭐⭐⭐ 关键：log/(排错必需), lib/(数据存储)
⭐⭐ 重要：spool/(服务队列), cache/(性能优化)
⭐ 一般：tmp/(临时存储), lock/(进程协调)
```

### 1.3 /var目录的系统意义

**💡 为什么需要独立的/var目录**

```
系统设计考虑：
1. 数据隔离
   固定数据(/usr) vs 可变数据(/var)
   避免可变数据影响系统稳定性

2. 存储管理
   可以单独分区，便于磁盘管理
   可以设置不同的备份策略

3. 安全考虑
   可以设置不同的权限和挂载选项
   防止日志等文件占满根分区

4. 运维便利
   集中管理所有可变数据
   便于监控和维护
```

**⚠️ /var满了会发生什么**
```
系统问题：
- 日志无法写入，应用报错
- 邮件队列堵塞，邮件丢失
- 软件包安装失败
- 数据库无法正常运行
- 系统可能无法启动

解决思路：
1. 立即清理空间
2. 找出占用大户
3. 优化日志轮转
4. 考虑分区扩容
```

---

## 2. 📝 /var/log日志文件系统


### 2.1 日志系统的重要性

🎯 **核心价值**：日志就像汽车的"行车记录仪"，记录系统的一切活动

```
日志的作用类比：
医生看病 → 需要病历记录 → /var/log记录系统"病历"
警察破案 → 需要监控录像 → /var/log记录系统"录像"
会计记账 → 需要流水明细 → /var/log记录系统"流水"

日志的实际价值：
✅ 故障诊断：系统出问题时查找原因
✅ 安全审计：发现异常访问和攻击
✅ 性能分析：了解系统运行状况
✅ 合规要求：满足审计和法规要求
```

### 2.2 常见日志文件详解

**📋 核心日志文件清单**

```
/var/log/主要文件：
messages      ← 系统主日志(最重要)
secure        ← 安全认证日志
cron          ← 定时任务日志  
maillog       ← 邮件系统日志
boot.log      ← 系统启动日志
dmesg         ← 内核消息日志
wtmp          ← 用户登录记录
lastlog       ← 用户最后登录
```

**🔍 日志文件功能详解**

| 日志文件 | **主要内容** | **查看命令** | **重要程度** |
|---------|-------------|-------------|-------------|
| 🔸 **messages** | `系统整体运行信息` | `tail -f /var/log/messages` | `⭐⭐⭐` |
| 🔸 **secure** | `SSH登录、sudo操作` | `grep "Failed" /var/log/secure` | `⭐⭐⭐` |
| 🔸 **cron** | `定时任务执行情况` | `tail /var/log/cron` | `⭐⭐` |
| 🔸 **boot.log** | `系统启动过程` | `cat /var/log/boot.log` | `⭐⭐` |
| 🔸 **dmesg** | `内核和硬件信息` | `dmesg | tail` | `⭐⭐⭐` |

### 2.3 日志查看与分析技巧

**🔧 实用日志分析命令**

```bash
# 1. 实时监控日志变化
tail -f /var/log/messages           # 实时查看系统日志
tail -f /var/log/secure            # 监控登录情况

# 2. 查找特定内容
grep "error" /var/log/messages     # 查找错误信息
grep "Failed password" /var/log/secure  # 查找登录失败

# 3. 按时间范围查看
journalctl --since "2024-01-15 10:00" --until "2024-01-15 12:00"

# 4. 查看特定服务日志
journalctl -u sshd                 # 查看SSH服务日志
journalctl -u httpd                # 查看Apache日志
```

**💡 日志分析实战示例**
```bash
# 场景1：系统突然变慢，查找原因
# 查看最近的系统消息
tail -100 /var/log/messages | grep -i "error\|warn\|fail"

# 场景2：发现异常登录，安全检查
# 查看登录失败记录
grep "Failed password" /var/log/secure | tail -20
# 查看成功登录记录
grep "Accepted password" /var/log/secure | tail -20

# 场景3：定时任务不执行，排查问题
# 查看cron日志
grep "$(date +%Y-%m-%d)" /var/log/cron | grep your_job_name
```

### 2.4 应用程序日志目录

**📂 应用日志的组织方式**

```
应用日志通常的存放位置：
/var/log/httpd/         ← Apache Web服务器
/var/log/nginx/         ← Nginx Web服务器  
/var/log/mysql/         ← MySQL数据库
/var/log/postgresql/    ← PostgreSQL数据库
/var/log/samba/         ← Samba文件共享
/var/log/audit/         ← 系统审计日志

每个应用目录通常包含：
access.log             ← 访问日志
error.log              ← 错误日志
slow.log               ← 慢查询日志(数据库)
```

**🎯 应用日志管理最佳实践**
```
日志管理原则：
1. 分级记录：ERROR > WARN > INFO > DEBUG
2. 结构化输出：便于程序分析
3. 合理轮转：防止占用过多空间
4. 安全保护：敏感信息脱敏处理

示例配置：
# Apache日志格式
LogFormat "%h %l %u %t \"%r\" %>s %O" combined
CustomLog /var/log/httpd/access.log combined
ErrorLog /var/log/httpd/error.log
```

---

## 3. 📮 /var/spool队列文件管理


### 3.1 什么是spool队列

🎯 **生活化理解**：spool就像邮局的"待处理邮件堆"

```
队列的概念类比：
银行排队 → 按顺序办理业务 → spool按顺序处理任务
邮局信件 → 先收集再发送 → spool先存储再处理
餐厅点菜 → 按顺序制作菜品 → spool按顺序执行任务

spool的核心特点：
- FIFO：First In First Out(先进先出)
- 缓冲：临时存储等待处理的任务
- 异步：接收和处理可以分开进行
- 可靠：即使重启也不会丢失任务
```

### 3.2 常见spool目录详解

**📁 /var/spool子目录功能**

```
/var/spool/目录结构：
mail/         ← 邮件队列(最常用)
cron/         ← 定时任务队列  
at/           ← 一次性定时任务
lpd/          ← 打印队列
mqueue/       ← Sendmail邮件队列
postfix/      ← Postfix邮件队列
cups/         ← CUPS打印系统
```

**🔍 邮件spool详解**
```
邮件队列的工作流程：
用户发邮件 → 邮件进入队列 → 等待发送 → 发送成功后删除

队列状态检查：
mailq                    # 查看邮件队列
postqueue -p             # Postfix队列状态
sendmail -bp             # Sendmail队列状态

常见问题处理：
# 清空邮件队列
postsuper -d ALL         # Postfix清空队列
# 删除特定邮件
postsuper -d [队列ID]    # 删除指定邮件
```

### 3.3 队列管理与监控

**⚙️ 队列健康状态监控**

```bash
# 1. 邮件队列监控
# 查看队列数量
mailq | tail -1 | awk '{print $5}'

# 查看队列中的邮件详情
mailq | head -20

# 2. 定时任务队列
# 查看当前用户的定时任务
crontab -l

# 查看系统定时任务
ls -la /var/spool/cron/

# 3. 打印队列监控  
lpq                     # 查看打印队列
lpstat -t              # 查看打印机状态
```

**🚨 队列异常处理**
```
常见队列问题：
1. 邮件队列堆积
   原因：SMTP服务器无法连接、配置错误
   解决：检查网络、修复配置、清理队列

2. 定时任务不执行
   原因：cron服务停止、权限问题
   解决：重启cron服务、检查文件权限

3. 打印队列卡住
   原因：打印机离线、驱动问题  
   解决：检查打印机状态、重启打印服务

队列清理命令：
# 清空所有邮件队列
postsuper -d ALL
# 重启相关服务
systemctl restart postfix
```

---

## 4. 🗄️ /var/cache缓存文件存储


### 4.1 缓存系统的作用

🎯 **理解缓存**：缓存就像书桌上的"常用文具盒"，把常用的东西放在手边

```
缓存的生活类比：
图书馆 → 把常借的书放在显眼位置 → 提高查找效率
超市 → 把热销商品放在入口处 → 方便顾客购买
浏览器 → 把访问过的网页保存本地 → 加快再次访问

缓存的核心价值：
⚡ 速度提升：避免重复计算或下载
💰 成本节约：减少网络流量和服务器压力  
🎯 体验优化：用户获得更快的响应
📈 性能增强：系统整体效率提升
```

### 4.2 常见缓存目录分析

**📂 /var/cache主要子目录**

```
/var/cache/目录结构：
yum/          ← YUM软件包缓存(CentOS/RHEL)
apt/          ← APT软件包缓存(Debian/Ubuntu)  
dnf/          ← DNF软件包缓存(新版CentOS)
man/          ← Manual手册页缓存
fontconfig/   ← 字体配置缓存
ldconfig/     ← 动态链接库缓存
httpd/        ← Apache Web服务器缓存
nginx/        ← Nginx反向代理缓存
```

**🔍 软件包缓存详解**
```
软件包缓存的工作机制：
下载软件包 → 保存到cache → 安装时直接使用 → 节省带宽

YUM缓存管理：
yum clean packages       # 清理已下载的软件包
yum clean metadata       # 清理软件包信息缓存
yum clean all           # 清理所有缓存

APT缓存管理：
apt-get clean           # 清理已下载的软件包
apt-get autoclean       # 清理过期的软件包缓存
du -sh /var/cache/apt/  # 查看缓存占用空间
```

### 4.3 缓存空间管理

**📊 缓存占用分析与清理**

```bash
# 1. 查看各缓存目录占用情况
du -sh /var/cache/*

# 2. 分析缓存空间分布
find /var/cache -name "*.rpm" -exec ls -lh {} \; | sort -k5 -hr | head -10
find /var/cache -name "*.deb" -exec ls -lh {} \; | sort -k5 -hr | head -10

# 3. 安全清理缓存
# YUM系统
yum clean all && yum makecache

# APT系统  
apt-get clean && apt-get update

# 手动清理特定缓存
rm -rf /var/cache/fontconfig/*
fc-cache -fv                    # 重建字体缓存
```

**⚙️ 缓存策略配置**
```
优化缓存配置：
1. 设置合理的缓存大小限制
2. 配置自动清理机制  
3. 监控缓存命中率
4. 定期清理过期缓存

YUM缓存配置示例：
# /etc/yum.conf
keepcache=1              # 保留下载的软件包
cachedir=/var/cache/yum  # 缓存目录
max_retries=10           # 最大重试次数

Nginx缓存配置示例：
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m;
proxy_cache my_cache;
proxy_cache_valid 200 1h;       # 200状态码缓存1小时
```

---

## 5. 🗃️ /var/lib应用数据管理


### 5.1 应用数据的特点

🎯 **理解/var/lib**：这里就像各个软件的"专属储物柜"

```
应用数据的特征：
数据库文件 → MySQL把表数据存这里 → 系统重启后数据还在
应用配置 → 软件运行时生成的设置 → 保持应用状态
索引文件 → 搜索引擎建立的索引 → 提高查询速度
状态信息 → 软件运行的当前状态 → 恢复运行环境

与其他目录的区别：
/etc/     → 管理员配置的设置(静态)
/var/lib/ → 程序运行产生的数据(动态)
/tmp/     → 临时文件(重启丢失)
/var/lib/ → 持久化数据(重启保留)
```

### 5.2 常见应用数据目录

**📁 /var/lib重要子目录**

```
/var/lib/目录结构：
mysql/        ← MySQL数据库文件
postgresql/   ← PostgreSQL数据库
mongodb/      ← MongoDB数据文件
redis/        ← Redis持久化文件
docker/       ← Docker镜像和容器数据
rpm/          ← RPM软件包数据库
dpkg/         ← DEB软件包数据库
systemd/      ← Systemd服务状态
NetworkManager/ ← 网络管理器数据
```

**🔍 数据库文件详解**
```
MySQL数据存储结构：
/var/lib/mysql/
├── ibdata1           ← InnoDB共享表空间
├── ib_logfile0       ← InnoDB日志文件
├── mysql/            ← 系统数据库
├── test/             ← 测试数据库
└── your_database/    ← 用户数据库
    ├── table1.frm    ← 表结构文件
    ├── table1.ibd    ← 表数据文件
    └── db.opt        ← 数据库选项

权限要求：
chown -R mysql:mysql /var/lib/mysql
chmod 750 /var/lib/mysql
```

### 5.3 应用数据备份与恢复

**💾 数据安全保护策略**

```bash
# 1. MySQL数据备份
# 逻辑备份(推荐)
mysqldump -u root -p database_name > backup.sql

# 物理备份(需要停止服务)
systemctl stop mysql
cp -R /var/lib/mysql /backup/mysql_$(date +%Y%m%d)
systemctl start mysql

# 2. PostgreSQL数据备份
pg_dump database_name > backup.sql
# 全量备份
pg_dumpall > full_backup.sql

# 3. 文件系统级别备份
rsync -av /var/lib/mysql/ /backup/mysql/
tar -czf mysql_backup.tar.gz /var/lib/mysql/
```

**🔧 数据恢复操作**
```bash
# MySQL数据恢复
mysql -u root -p database_name < backup.sql

# PostgreSQL数据恢复
psql database_name < backup.sql

# 物理恢复(需要停止服务)
systemctl stop mysql
rm -rf /var/lib/mysql/*
cp -R /backup/mysql/* /var/lib/mysql/
chown -R mysql:mysql /var/lib/mysql
systemctl start mysql
```

---

## 6. 🗂️ /var/tmp临时文件处理


### 6.1 /var/tmp vs /tmp的区别

🎯 **理解两种临时目录**：像家里的"临时存放区"和"长期存放区"

```
/tmp vs /var/tmp 对比：
/tmp/     → 桌面上的便签纸(重启就没了)
/var/tmp/ → 抽屉里的草稿(重启后还在)

具体区别：
持久性：
/tmp     → 重启后清空
/var/tmp → 重启后保留

用途：
/tmp     → 程序运行时的临时文件
/var/tmp → 需要跨重启保留的临时文件

清理策略：
/tmp     → 系统自动清理
/var/tmp → 需要手动或定期清理
```

### 6.2 /var/tmp使用场景

**📋 典型应用场景**

```
/var/tmp常见用途：
1. 软件安装过程
   大型软件包解压 → 需要重启后继续安装
   
2. 系统维护任务
   文件系统检查 → 跨重启的修复过程
   
3. 长时间任务
   大文件下载 → 防止网络中断后重新开始
   
4. 备份恢复
   临时备份文件 → 确认无误后再删除

权限设置：
ls -ld /var/tmp
drwxrwxrwt 3 root root 4096 Jan 15 10:30 /var/tmp
                ↑
            sticky bit(防止互相删除)
```

### 6.3 临时文件清理策略

**🧹 /var/tmp维护管理**

```bash
# 1. 查看/var/tmp占用情况
du -sh /var/tmp
find /var/tmp -type f -exec ls -lh {} \; | sort -k5 -hr | head -10

# 2. 按时间清理文件
# 删除30天前的文件
find /var/tmp -type f -mtime +30 -delete
# 删除7天前的临时文件
find /var/tmp -name "*.tmp" -mtime +7 -delete

# 3. 按大小清理
# 找出大于100M的文件
find /var/tmp -type f -size +100M -ls
# 交互式删除大文件
find /var/tmp -type f -size +100M -ok rm {} \;

# 4. 设置定期清理
# 添加到crontab
0 2 * * 0 find /var/tmp -type f -mtime +30 -delete
```

**⚠️ 清理注意事项**
```
清理前检查：
1. 确认文件不在使用中
   lsof /var/tmp/somefile

2. 检查文件重要性
   less /var/tmp/somefile  # 查看内容
   
3. 备份重要文件
   cp important_file /backup/

4. 分批清理
   避免一次删除过多文件导致系统负载过高

安全清理流程：
分析 → 确认 → 备份 → 清理 → 验证
```

---

## 7. 🔄 日志轮转机制详解


### 7.1 为什么需要日志轮转

🎯 **日志轮转的意义**：就像定期整理文档，防止办公桌堆满纸张

```
不轮转的问题：
日志文件会无限增长 → 占满磁盘空间 → 系统崩溃
单个文件过大 → 查看困难 → 影响性能
历史日志混杂 → 找不到关键信息 → 排错困难

轮转的好处：
✅ 控制磁盘使用：防止日志占满空间
✅ 提高查看效率：文件大小适中，便于分析
✅ 便于归档管理：按时间分类，便于备份
✅ 保持系统性能：避免单个大文件影响IO
```

### 7.2 logrotate工具详解

**🔧 系统级日志轮转工具**

```bash
# logrotate配置文件位置
/etc/logrotate.conf      # 主配置文件
/etc/logrotate.d/        # 各应用的配置目录

# 查看logrotate配置
cat /etc/logrotate.conf

# 手动执行轮转(测试用)
logrotate -f /etc/logrotate.conf
logrotate -d /etc/logrotate.conf  # 调试模式，不实际执行
```

**📋 logrotate配置语法**
```
# /etc/logrotate.d/myapp 示例配置
/var/log/myapp/*.log {
    daily                    # 每天轮转
    rotate 7                 # 保留7个备份
    compress                 # 压缩旧文件
    delaycompress           # 延迟一天压缩
    missingok               # 文件不存在不报错
    notifempty              # 空文件不轮转
    create 644 root root    # 创建新文件的权限
    postrotate              # 轮转后执行的命令
        systemctl reload myapp
    endscript
}

配置选项详解：
daily/weekly/monthly     # 轮转频率
size 100M               # 文件大小超过100M就轮转
copytruncate            # 复制后截断(适用于持续写入的程序)
sharedscripts           # 多个文件共享脚本
```

### 7.3 常见应用的日志轮转配置

**🎯 实战配置示例**

```bash
# 1. Apache日志轮转
# /etc/logrotate.d/httpd
/var/log/httpd/*log {
    daily
    rotate 52
    compress
    delaycompress
    missingok
    notifempty
    sharedscripts
    postrotate
        /bin/systemctl reload httpd.service > /dev/null 2>/dev/null || true
    endscript
}

# 2. Nginx日志轮转  
# /etc/logrotate.d/nginx
/var/log/nginx/*.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    copytruncate
}

# 3. MySQL日志轮转
# /etc/logrotate.d/mysql
/var/log/mysql/*.log {
    weekly
    rotate 4
    compress
    missingok
    notifempty
    postrotate
        if test -x /usr/bin/mysqladmin && \
           /usr/bin/mysqladmin ping &>/dev/null
        then
            /usr/bin/mysqladmin flush-logs
        fi
    endscript
}
```

### 7.4 轮转问题排查与优化

**🔍 常见问题及解决方案**

```bash
# 1. 检查轮转是否正常工作
# 查看轮转历史
cat /var/lib/logrotate/status

# 查看最近的轮转时间
ls -la /var/log/messages*

# 2. 轮转失败排查
# 检查配置语法
logrotate -d /etc/logrotate.d/myapp

# 查看系统日志中的错误
grep logrotate /var/log/messages

# 3. 手动强制轮转
logrotate -f /etc/logrotate.d/myapp

# 4. 调试模式运行
logrotate -d -v /etc/logrotate.conf
```

**⚙️ 轮转优化建议**
```
最佳实践：
1. 根据磁盘空间设置保留策略
   小磁盘：rotate 7 (保留一周)
   大磁盘：rotate 30 (保留一月)

2. 根据日志重要性设置压缩
   关键日志：compress + delaycompress
   普通日志：compress 立即压缩

3. 根据应用特点选择轮转方式
   持续写入：copytruncate
   可重启服务：create + postrotate

4. 设置合理的轮转触发条件
   高频日志：daily + size 100M
   低频日志：weekly 或 monthly

监控轮转效果：
# 创建轮转监控脚本
#!/bin/bash
for logfile in /var/log/*.log; do
    size=$(du -m "$logfile" | awk '{print $1}')
    if [ $size -gt 100 ]; then
        echo "Warning: $logfile is ${size}MB"
    fi
done
```

---

## 8. 📊 磁盘空间监控策略


### 8.1 磁盘空间监控的重要性

🎯 **为什么要监控磁盘空间**：就像关注油箱，避免半路"抛锚"

```
磁盘满了的后果：
系统层面：
- 无法写入新文件
- 日志记录中断
- 应用程序崩溃  
- 系统可能无法启动

业务层面：
- 数据库无法写入新数据
- 网站无法上传文件
- 邮件系统停止工作
- 备份任务失败

预防监控的价值：
⚡ 提前预警：在问题发生前就知道
🎯 精确定位：知道哪个目录占用过多
🔧 及时处理：有时间制定清理计划
📈 趋势分析：了解空间增长规律
```

### 8.2 空间查看与分析命令

**🔍 磁盘空间检查工具集**

```bash
# 1. 查看整体磁盘使用情况
df -h                    # 查看分区使用情况
df -h /var              # 查看特定分区

# 2. 查看目录占用情况
du -sh /var/*           # 查看/var各子目录占用
du -sh /var/log/*       # 查看日志目录详情

# 3. 按大小排序显示
du -sh /var/* | sort -hr    # 从大到小排序
find /var -type f -size +100M -exec ls -lh {} \;  # 找出大文件

# 4. 查看文件系统inode使用情况
df -i                   # inode使用情况
find /var -type f | wc -l   # 统计文件数量
```

**📊 空间分析实战示例**
```bash
# 场景：/var分区使用率90%，需要找出占用大户

# 第1步：查看各子目录占用
du -sh /var/* | sort -hr
# 输出示例：
# 15G    /var/log
# 8.2G   /var/lib  
# 2.1G   /var/cache
# 500M   /var/spool

# 第2步：深入分析最大的目录
du -sh /var/log/* | sort -hr
# 输出示例：
# 8.5G   /var/log/messages
# 3.2G   /var/log/httpd
# 2.1G   /var/log/mysql

# 第3步：查看具体文件
ls -lah /var/log/messages*
# 发现messages文件过大，需要轮转

# 第4步：找出最老的文件进行清理
find /var/log -name "*.log" -mtime +30 -ls
```

### 8.3 自动化监控脚本

**🤖 编写磁盘监控脚本**

```bash
#!/bin/bash
# disk_monitor.sh - 磁盘空间监控脚本

# 设置告警阈值
WARNING_THRESHOLD=80
CRITICAL_THRESHOLD=90
EMAIL="admin@company.com"

# 检查磁盘使用率
check_disk_usage() {
    local partition=$1
    local usage=$(df -h $partition | awk 'NR==2{print $5}' | sed 's/%//')
    
    if [ $usage -ge $CRITICAL_THRESHOLD ]; then
        echo "CRITICAL: $partition is ${usage}% full"
        send_alert "CRITICAL" $partition $usage
    elif [ $usage -ge $WARNING_THRESHOLD ]; then
        echo "WARNING: $partition is ${usage}% full"
        send_alert "WARNING" $partition $usage
    else
        echo "OK: $partition is ${usage}% full"
    fi
}

# 发送告警邮件
send_alert() {
    local level=$1
    local partition=$2
    local usage=$3
    
    cat << EOF | mail -s "Disk Usage Alert: $level" $EMAIL
Disk usage alert on $(hostname)

Partition: $partition
Usage: ${usage}%
Threshold: $level

Top 10 largest files:
$(find $partition -type f -exec ls -lh {} \; | sort -k5 -hr | head -10)

Please take action to free up disk space.
EOF
}

# 主程序
main() {
    echo "=== Disk Usage Report $(date) ==="
    
    # 检查主要分区
    check_disk_usage "/"
    check_disk_usage "/var"
    check_disk_usage "/home"
    
    # 详细分析/var目录
    if [ $(df /var | awk 'NR==2{print $5}' | sed 's/%//') -ge $WARNING_THRESHOLD ]; then
        echo -e "\n=== /var Directory Analysis ==="
        du -sh /var/* | sort -hr | head -10
        
        echo -e "\n=== Large Files in /var ==="
        find /var -type f -size +100M -exec ls -lh {} \; | head -10
    fi
}

# 执行主程序
main
```

### 8.4 预防性维护策略

**🛠️ 建立长期维护机制**

```bash
# 1. 创建定期清理脚本
#!/bin/bash
# cleanup.sh - 定期清理脚本

# 清理日志文件
echo "Cleaning old log files..."
find /var/log -name "*.log" -mtime +30 -delete
find /var/log -name "*.log.*" -mtime +7 -delete

# 清理缓存文件
echo "Cleaning cache files..."
yum clean all
apt-get clean

# 清理临时文件
echo "Cleaning temporary files..."
find /var/tmp -type f -mtime +7 -delete
find /tmp -type f -mtime +3 -delete

# 清理邮件队列中的错误邮件
echo "Cleaning mail queue..."
mailq | grep "MAILER-DAEMON" | awk '{print $1}' | xargs -r postsuper -d

# 统计清理效果
echo "Cleanup completed. Current disk usage:"
df -h /var

# 2. 设置定时任务
# 添加到crontab: crontab -e
# 每天凌晨2点执行清理
0 2 * * * /path/to/cleanup.sh > /var/log/cleanup.log 2>&1

# 每小时检查磁盘使用率
0 * * * * /path/to/disk_monitor.sh

# 3. 日志轮转优化
# 根据磁盘大小调整轮转策略
if [ $(df /var | awk 'NR==2{print $4}' | sed 's/G//') -lt 10 ]; then
    # 小于10G的磁盘，保留较少的日志
    sed -i 's/rotate 30/rotate 7/' /etc/logrotate.d/*
fi
```

**📈 长期监控策略**
```
建立监控体系：
1. 实时监控
   - 每小时检查磁盘使用率
   - 使用率超过80%立即告警
   
2. 趋势分析  
   - 记录每日磁盘使用情况
   - 分析增长趋势，预测空间需求
   
3. 自动化处理
   - 自动清理过期文件
   - 自动压缩或删除大日志文件
   
4. 容量规划
   - 根据业务增长预估空间需求
   - 提前规划磁盘扩容计划

监控数据收集：
# 创建磁盘使用历史记录
echo "$(date '+%Y-%m-%d %H:%M:%S'),$(df /var | awk 'NR==2{print $5}' | sed 's/%//')" >> /var/log/disk_usage_history.csv

# 生成月度报告
awk -F',' '{print $1,$2}' /var/log/disk_usage_history.csv | \
awk '$2>80{print $0 " - High usage detected"}'
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 /var目录本质：存储系统运行时产生的可变数据，是系统正常运行的关键
🔸 关键子目录：log(日志)、spool(队列)、cache(缓存)、lib(应用数据)、tmp(临时文件)
🔸 日志系统：系统故障诊断和安全审计的重要工具，需要重点关注
🔸 队列管理：保证邮件、打印等服务的正常运行，避免任务堆积
🔸 缓存优化：提高系统性能，但需要合理管理占用空间
🔸 应用数据：各种软件的核心数据，需要重点保护和备份
🔸 日志轮转：控制日志文件大小，防止占满磁盘空间
🔸 空间监控：预防磁盘空间不足导致系统故障
```

### 9.2 关键理解要点


**🔹 /var目录的系统意义**
```
设计理念：
- 分离固定数据和可变数据
- 便于独立管理和监控
- 支持不同的备份和清理策略

运维价值：
- 集中管理所有动态数据
- 便于故障排查和性能分析
- 支持系统的可扩展性
```

**🔹 日志系统的核心价值**
```
故障诊断：
- 通过日志快速定位问题根源
- 分析系统异常和性能问题
- 跟踪应用程序运行状态

安全审计：
- 监控用户登录和操作行为
- 检测异常访问和攻击行为
- 满足安全合规要求

性能分析：
- 了解系统负载和资源使用情况
- 识别性能瓶颈和优化点
- 支持容量规划决策
```

**🔹 空间管理的重要性**
```
预防性思维：
- 磁盘空间不足会导致系统崩溃
- 提前监控比事后补救更有效
- 建立自动化清理机制

平衡策略：
- 保留足够的历史数据用于分析
- 及时清理过期和无用文件
- 根据磁盘大小制定合理策略
```

### 9.3 实际应用价值


**🎯 生产环境应用场景**
- **Web服务器**：分析访问日志，优化网站性能和安全防护
- **数据库服务器**：监控数据文件增长，制定备份和维护计划
- **邮件服务器**：管理邮件队列，确保邮件正常收发
- **应用服务器**：跟踪应用日志，快速定位业务问题

**🔧 运维实践建议**
- **分区规划**：将/var单独分区，避免影响根分区
- **监控告警**：建立完善的磁盘空间监控和告警机制
- **定期维护**：制定日志清理和空间回收的定期任务
- **备份策略**：重要应用数据需要制定专门的备份计划

**📈 技能发展路径**
- **基础阶段**：熟悉各目录的作用和基本管理命令
- **进阶阶段**：掌握日志轮转配置和空间监控脚本
- **高级阶段**：建立自动化运维体系和容量规划能力
- **专家阶段**：优化系统性能和制定最佳实践规范

**核心记忆口诀**：
- var目录存可变，日志队列缓存全
- 日志轮转防爆盘，空间监控保平安  
- 应用数据要备份，临时文件定期删
- 运维自动化管理，系统稳定服务佳