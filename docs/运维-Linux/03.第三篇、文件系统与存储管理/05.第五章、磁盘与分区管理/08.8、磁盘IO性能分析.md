---
title: 8、磁盘IO性能分析
---
## 📚 目录

1. [磁盘I/O性能基础概念](#1-磁盘IO性能基础概念)
2. [iostat命令详解与实战](#2-iostat命令详解与实战)
3. [iotop实时I/O监控](#3-iotop实时IO监控)
4. [磁盘队列与等待时间分析](#4-磁盘队列与等待时间分析)
5. [随机与顺序读写性能对比](#5-随机与顺序读写性能对比)
6. [I/O性能三大核心指标](#6-IO性能三大核心指标)
7. [I/O瓶颈识别与诊断](#7-IO瓶颈识别与诊断)
8. [I/O调度器优化策略](#8-IO调度器优化策略)
9. [磁盘性能基准测试](#9-磁盘性能基准测试)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 💽 磁盘I/O性能基础概念


### 1.1 什么是磁盘I/O性能


**💡 生活类比**：磁盘I/O就像图书馆的借书还书过程
- **借书请求** = 程序要读取文件
- **管理员处理速度** = 磁盘响应速度  
- **同时处理能力** = I/O并发性能
- **排队等候时间** = I/O等待延迟

```
📖 核心概念解释

I/O (Input/Output)：输入输出操作
- Input：从磁盘读取数据到内存
- Output：从内存写入数据到磁盘
- 是系统最容易出现性能瓶颈的环节
```

### 1.2 为什么I/O性能如此重要


**🔍 性能对比一览**

```
存储介质速度对比（访问一次数据的时间）：
┌─────────────────┬──────────────┬────────────────┐
│   存储类型      │   访问时间   │   形象比喻     │
├─────────────────┼──────────────┼────────────────┤
│ CPU寄存器       │   1纳秒      │ 1秒           │
│ CPU缓存         │   2-10纳秒   │ 2-10秒        │
│ 内存RAM         │   100纳秒    │ 1分40秒       │
│ SSD固态硬盘     │   0.1毫秒    │ 1天           │
│ 机械硬盘HDD     │   10毫秒     │ 4个月         │
│ 网络存储        │   100毫秒    │ 3年           │
└─────────────────┴──────────────┴────────────────┘
```

> 💡 **关键理解**：磁盘是整个计算机系统中最慢的组件，一次磁盘访问的时间足够CPU执行数百万条指令！

### 1.3 I/O性能影响因素


**🎯 主要影响因素**

```
硬件因素：
🔸 磁盘类型：SSD vs HDD
🔸 接口速度：SATA、NVMe、SCSI
🔸 转速：5400rpm、7200rpm、10000rpm
🔸 缓存大小：磁盘自带缓存容量

软件因素：
🔸 文件系统：ext4、xfs、btrfs
🔸 I/O调度器：cfq、deadline、noop
🔸 应用程序：读写模式、数据大小
🔸 系统配置：内存缓存、预读设置
```

---

## 2. 📊 iostat命令详解与实战


### 2.1 iostat基础用法


**📋 命令格式**
```bash
iostat [选项] [间隔时间] [次数]
```

**🔧 基础示例**
```bash
# 每2秒显示一次，共显示3次
iostat 2 3

# 只显示磁盘统计信息
iostat -d

# 显示扩展磁盘统计信息
iostat -x
```

### 2.2 iostat输出详解


**📈 标准输出解读**
```bash
$ iostat -x 1 2

Device:   rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda         0.00     0.00   12.00    8.00   256.00   128.00    19.20     0.05    2.50   1.25   2.50
```

**📚 各字段含义详解**

| 字段 | **含义** | **通俗解释** | **正常范围** |
|------|----------|-------------|-------------|
| `rrqm/s` | 每秒合并的读请求数 | 系统把多个小的读请求合并成大请求 | - |
| `wrqm/s` | 每秒合并的写请求数 | 系统把多个小的写请求合并成大请求 | - |
| `r/s` | 每秒读操作数 | 每秒钟读了多少次 | 根据应用而定 |
| `w/s` | 每秒写操作数 | 每秒钟写了多少次 | 根据应用而定 |
| `rsec/s` | 每秒读取扇区数 | 每秒读取的数据量(512字节/扇区) | - |
| `wsec/s` | 每秒写入扇区数 | 每秒写入的数据量(512字节/扇区) | - |
| `avgrq-sz` | 平均请求大小 | 每次I/O操作的平均数据量(扇区) | 越大越好 |
| `avgqu-sz` | 平均队列长度 | 等待处理的I/O请求平均数量 | <2为佳 |
| `await` | 平均等待时间 | 从发出请求到完成的平均时间(ms) | <10ms为佳 |
| `svctm` | 平均服务时间 | 磁盘实际处理请求的时间(ms) | <5ms为佳 |
| `%util` | 磁盘利用率 | 磁盘忙碌时间的百分比 | <80%为佳 |

### 2.3 iostat实战案例


**🔍 性能问题诊断示例**

```bash
# 案例1：正常情况
$ iostat -x 1
Device:    r/s    w/s   await  svctm  %util
sda       50.0   20.0    3.2    2.1   15.0

# 分析：读写适中，延迟低，利用率不高 ✅

# 案例2：I/O瓶颈
$ iostat -x 1  
Device:    r/s    w/s   await  svctm  %util
sda      200.0  150.0   45.2   2.8   98.0

# 分析：利用率98%接近饱和，等待时间长 ⚠️
```

**💡 实用技巧**

```bash
# 持续监控并保存到文件
iostat -x 1 > iostat.log &

# 只监控特定磁盘
iostat -x sda 1

# 显示每个分区的统计信息
iostat -p ALL

# 以MB/s为单位显示
iostat -m 1
```

---

## 3. 🔍 iotop实时I/O监控


### 3.1 iotop基础概念


**📖 什么是iotop**

```
📝 核心定义
iotop = I/O版本的top命令
- 实时显示各进程的I/O使用情况
- 类似top显示CPU使用率
- 可以找出哪个程序占用I/O最多
```

**🛠️ 安装iotop**
```bash
# CentOS/RHEL
yum install iotop

# Ubuntu/Debian  
apt-get install iotop

# 检查是否支持
ls /proc/*/io
```

### 3.2 iotop使用详解


**📋 基础命令**
```bash
# 基本使用
iotop

# 只显示有I/O活动的进程
iotop -o

# 以kb/s为单位显示
iotop -k

# 显示累计I/O而非速率
iotop -a
```

**📊 iotop界面解读**

```
Total DISK READ: 25.67 M/s | Total DISK WRITE: 13.28 M/s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN    IO>    COMMAND
 2789 be/4 mysql      15.67 M/s    8.21 M/s   0.00 %  45.2% mysqld
 3456 be/4 root        5.32 M/s    2.15 M/s   0.00 %  15.8% rsync  
 4123 be/4 apache      2.15 M/s    1.89 M/s   0.00 %   8.9% httpd
```

**📚 字段含义说明**

| 字段 | **含义** | **通俗解释** |
|------|----------|-------------|
| `TID` | 线程ID | 进程的唯一标识符 |
| `PRIO` | I/O优先级 | be/rt + 优先级数字 |
| `USER` | 用户名 | 运行此进程的用户 |
| `DISK READ` | 磁盘读速度 | 每秒从磁盘读取多少数据 |
| `DISK WRITE` | 磁盘写速度 | 每秒向磁盘写入多少数据 |
| `SWAPIN` | 交换区读取 | 从swap分区读取的百分比 |
| `IO>` | I/O使用率 | 该进程I/O时间占总时间百分比 |

### 3.3 iotop实战技巧


**🎯 常用操作快捷键**

```bash
交互式操作：
r - 反向排序
o - 只显示有I/O活动的进程  
p - 只显示进程(不显示线程)
a - 切换显示累计/当前I/O
q - 退出iotop
左右箭头 - 改变排序列
```

**💡 实用示例**

```bash
# 找出I/O最高的进程
iotop -o -d 1

# 监控特定用户的I/O
iotop -u mysql

# 以批处理模式运行(适合脚本)
iotop -b -n 3
```

---

## 4. ⏳ 磁盘队列与等待时间分析


### 4.1 磁盘队列机制


**🚶‍♂️ 生活类比：银行排队**

```
磁盘I/O队列就像银行排队：

客户(I/O请求) → 排队等候 → 银行柜台(磁盘) → 服务完成

队列特点：
- 队列越长，等待时间越久
- 柜台数量固定(磁盘处理能力有限)
- 可以优化排队顺序(I/O调度)
```

**📊 队列深度概念图**

```
┌─────────────────────────────────────────┐
│          I/O请求队列示意图               │
├─────────────────────────────────────────┤
│ 新请求 → [请求4][请求3][请求2][请求1] → 磁盘 │
│             ↑                      ↑    │
│           队列尾                  队列头  │
│                                         │
│ 队列深度 = 4 (avgqu-sz)                 │
└─────────────────────────────────────────┘
```

### 4.2 等待时间构成分析


**⏰ I/O等待时间组成**

```
总等待时间(await) = 排队时间 + 服务时间

┌──────────────┬─────────────┬──────────────┐
│   发起请求   │   排队等待   │   磁盘处理   │
├──────────────┼─────────────┼──────────────┤
│      0ms     │  (await-svctm) │   svctm     │
└──────────────┴─────────────┴──────────────┘
                ↑                    ↑
              队列延迟            实际服务时间
```

**🔍 关键指标解读**

```bash
# 通过iostat观察队列情况
$ iostat -x 1

Device: avgqu-sz   await  svctm  %util
sda:        2.50    15.2    3.8   85.0

分析：
✅ avgqu-sz = 2.5 (队列不算太长)
⚠️ await = 15.2ms (总等待时间偏高)
✅ svctm = 3.8ms (磁盘处理速度正常)
⚠️ %util = 85% (磁盘利用率偏高)

结论：磁盘处理能力接近饱和，需要优化
```

### 4.3 队列优化策略


**🎯 优化方向**

```
📈 减少队列长度：
- 降低I/O请求频率
- 合并小的I/O请求
- 使用异步I/O
- 增加内存缓存

⚡ 提高处理效率：
- 选择合适的I/O调度器
- 使用更快的存储设备
- 优化文件系统
- 调整应用程序I/O模式
```

---

## 5. 🔄 随机与顺序读写性能对比


### 5.1 顺序读写vs随机读写


**🏃‍♂️ 生活类比：看书方式**

```
顺序读写 = 从头到尾看小说
- 一页页按顺序翻阅
- 效率高，速度快
- 适合大文件传输

随机读写 = 查字典找单词  
- 频繁跳页查找
- 效率低，速度慢
- 适合数据库操作
```

**📊 性能对比数据**

```
典型机械硬盘性能对比：

┌─────────────┬─────────────┬─────────────┐
│   操作类型   │  顺序读写    │  随机读写   │
├─────────────┼─────────────┼─────────────┤
│ 吞吐量      │  120MB/s    │   2MB/s     │
│ IOPS        │    300      │    150      │
│ 平均延迟    │    8ms      │    15ms     │
│ 典型应用    │ 文件备份    │  数据库     │
└─────────────┴─────────────┴─────────────┘

SSD固态硬盘性能对比：

┌─────────────┬─────────────┬─────────────┐
│   操作类型   │  顺序读写    │  随机读写   │
├─────────────┼─────────────┼─────────────┤
│ 吞吐量      │  500MB/s    │  300MB/s    │
│ IOPS        │   80000     │  50000      │
│ 平均延迟    │   0.1ms     │   0.2ms     │
└─────────────┴─────────────┴─────────────┘
```

### 5.2 如何识别读写模式


**🔍 通过iostat分析读写模式**

```bash
# 观察平均请求大小和IOPS
$ iostat -x 1

Device: avgrq-sz    r/s    w/s
sda:       128.0   10.0   20.0    # 大请求，可能是顺序I/O
sdb:         8.0  500.0  300.0    # 小请求，可能是随机I/O

判断依据：
📊 avgrq-sz > 64：通常是顺序I/O
📊 avgrq-sz < 16：通常是随机I/O  
📊 IOPS高+请求小：典型随机I/O模式
```

**🛠️ 使用fio测试工具验证**

```bash
# 测试顺序读性能
fio -name=seq-read -rw=read -bs=1M -size=1G -filename=/dev/sda

# 测试随机读性能  
fio -name=rand-read -rw=randread -bs=4K -size=1G -filename=/dev/sda

# 对比结果就能看出差异
```

### 5.3 优化不同读写模式


**⚡ 针对性优化策略**

```
🔸 顺序I/O优化：
- 增大读写缓冲区大小
- 使用预读(readahead)优化
- 选择吞吐量优先的调度器
- 文件尽量连续存储

🔸 随机I/O优化：
- 使用SSD替代机械硬盘
- 增加内存缓存减少磁盘访问
- 选择延迟优先的调度器
- 考虑使用内存数据库
```

---

## 6. 📈 I/O性能三大核心指标


### 6.1 IOPS (每秒输入输出操作数)


**📖 IOPS基本概念**

```
💡 通俗解释
IOPS = Input/Output Operations Per Second
就像餐厅服务员每秒钟能服务多少位客人

计算公式：
IOPS = (读操作/秒) + (写操作/秒)
     = r/s + w/s (iostat中显示)
```

**📊 不同设备IOPS对比**

```
设备类型对比表：

┌─────────────────┬────────────┬─────────────┐
│    设备类型     │ 随机IOPS   │  顺序IOPS   │
├─────────────────┼────────────┼─────────────┤
│ 7200转机械硬盘  │    150     │     300     │
│ 10000转机械硬盘 │    300     │     500     │
│ SAS硬盘        │    400     │     800     │
│ 普通SSD        │  50000     │   80000     │
│ 高端SSD        │ 500000     │  800000     │
│ NVMe SSD       │1000000     │ 2000000     │
└─────────────────┴────────────┴─────────────┘
```

**🔍 IOPS监控与分析**

```bash
# 使用iostat查看IOPS
$ iostat -x 1
Device:    r/s    w/s    # r/s + w/s = 总IOPS
sda       45.0   35.0    # 总IOPS = 80

# 使用sar命令监控IOPS
$ sar -d 1 5
Device:    tps    # tps就是IOPS
sda       80.5

# 判断标准：
🟢 IOPS < 设备额定值的70% → 正常
🟡 IOPS = 设备额定值的70-90% → 需关注  
🔴 IOPS > 设备额定值的90% → 有瓶颈
```

### 6.2 带宽 (数据传输速率)


**📊 带宽概念与计算**

```
💡 通俗解释
带宽就像水管的粗细，决定每秒能传输多少数据

计算公式：
带宽 = IOPS × 平均I/O大小
或者：带宽 = (rsec/s + wsec/s) × 512字节

单位转换：
- 1KB = 1024字节
- 1MB = 1024KB  
- 1扇区 = 512字节
```

**📈 带宽性能示例**

```bash
$ iostat -x -m 1  # -m表示以MB/s显示
Device: r/s   w/s  rMB/s  wMB/s  avgrq-sz
sda    100.0 50.0   25.0   12.5     512.0

分析：
- 读带宽：25MB/s
- 写带宽：12.5MB/s  
- 总带宽：37.5MB/s
- 平均请求大小：512扇区 = 256KB

评估：
✅ 对于7200转硬盘(120MB/s)，37.5MB/s使用率约30%，正常
```

### 6.3 延迟 (响应时间)


**⏰ 延迟类型与含义**

```
📝 延迟的三种类型：

🔸 服务时间(svctm)：
- 磁盘实际处理请求的时间
- 反映磁盘硬件性能
- 通常1-5ms为正常

🔸 等待时间(await)：  
- 从请求发出到完成的总时间
- 包含排队等待 + 服务时间
- 通常<10ms为良好

🔸 队列时间：
- 等待时间 - 服务时间
- await - svctm
- 反映系统负载情况
```

**🎯 延迟优化标准**

```
延迟评估标准：

┌─────────────┬─────────────┬─────────────┐
│   延迟范围   │   性能评级   │   用户感受   │
├─────────────┼─────────────┼─────────────┤
│    <5ms     │     优秀     │   很流畅    │
│   5-10ms    │     良好     │    流畅     │
│   10-20ms   │     一般     │  略有延迟   │
│   20-50ms   │     较差     │  明显延迟   │  
│    >50ms    │     很差     │   很卡顿    │
└─────────────┴─────────────┴─────────────┘
```

### 6.4 三大指标关系与平衡


**⚖️ 指标间的关系**

```
🔄 相互影响关系：

IOPS ↑ → 延迟可能 ↑ (队列变长)
带宽 ↑ → IOPS可能 ↓ (大请求减少请求数)  
延迟 ↑ → 用户体验 ↓ (响应变慢)

最佳平衡点：
- 在延迟可接受范围内
- 最大化IOPS和带宽
- 避免某个指标成为瓶颈
```

---

## 7. 🔍 I/O瓶颈识别与诊断


### 7.1 I/O瓶颈的典型表现


**⚠️ 系统表现症状**

```
🔸 用户感受：
- 程序启动慢，文件打开慢
- 数据库查询延迟高
- 系统整体响应慢
- 网站加载时间长

🔸 系统指标异常：
- 磁盘利用率持续>80%
- I/O等待时间>20ms
- 队列深度>5
- CPU等待I/O时间高
```

### 7.2 系统级I/O瓶颈诊断


**📊 使用多种工具综合诊断**

```bash
# 1. 查看整体I/O状况
$ iostat -x 1 3
Device:   %util  await  svctm  avgqu-sz
sda        95.2   45.8    5.2      8.5

# 危险信号：
# %util > 90%     磁盘几乎满负荷
# await > 20ms    等待时间过长
# avgqu-sz > 5    队列过长

# 2. 查看CPU等待I/O时间
$ top
# 关注 %wa (I/O wait) 这一列
Cpu(s): 10.2%us, 5.1%sy, 0.0%ni, 65.4%id, 19.3%wa

# %wa > 10% 说明CPU经常等待I/O完成

# 3. 查看进程I/O使用情况
$ iotop -o
# 找出I/O使用最高的进程
```

**🔧 综合诊断脚本**

```bash
#!/bin/bash
# I/O性能快速检查脚本

echo "=== I/O性能诊断报告 ==="
echo "时间：$(date)"
echo

echo "1. 磁盘利用率:"
iostat -x | grep -v "^$" | tail -n +4

echo
echo "2. TOP 5 I/O进程:"
iotop -b -n 1 | head -n 12 | tail -n 5

echo  
echo "3. CPU I/O等待:"
top -bn1 | grep "Cpu(s)" | awk '{print $10}' | cut -d, -f1
```

### 7.3 应用级I/O瓶颈定位


**🎯 定位具体应用问题**

```bash
# 1. 找出I/O最高的进程
$ iotop -p PID

# 2. 查看进程打开的文件  
$ lsof -p PID | head -20

# 3. 跟踪进程的系统调用
$ strace -e read,write,open,close -p PID

# 4. 分析进程I/O模式
$ pidstat -d 1 -p PID
```

**💡 常见问题模式**

```
🔸 问题类型识别：

数据库类问题：
- 大量小的随机I/O
- 读写比例不均
- 临时文件I/O过多

日志写入问题：  
- 频繁小写入
- 同步写入过多
- 日志轮转时I/O激增

备份恢复问题：
- 大量顺序读写
- 单一进程占用大部分带宽
- 持续时间长
```

### 7.4 I/O瓶颈解决策略


**🛠️ 分层次解决方案**

```
🔸 应急优化(立即见效)：
- 杀死占用I/O过高的非关键进程
- 调整进程I/O优先级: ionice
- 暂停非紧急的备份任务

🔸 配置优化(短期见效)：
- 调整I/O调度器
- 增加系统缓存
- 优化文件系统挂载参数

🔸 硬件优化(长期方案)：
- 升级到SSD
- 增加磁盘数量做RAID
- 使用高速网络存储

🔸 应用优化(根本解决)：
- 优化数据库查询
- 减少不必要的I/O操作
- 使用异步I/O
- 实施读写分离
```

---

## 8. 🔧 I/O调度器优化策略


### 8.1 I/O调度器基本概念


**📖 什么是I/O调度器**

```
💡 生活类比：电梯调度系统
I/O调度器就像电梯调度系统，决定I/O请求的处理顺序

主要作用：
🔸 合并相邻的I/O请求(减少磁头移动)
🔸 重新排序I/O请求(优化磁盘访问路径)  
🔸 防止某些请求饥饿(确保公平性)
🔸 平衡延迟和吞吐量
```

**🏗️ 调度器工作原理图**

```
应用程序I/O请求
        ↓
┌─────────────────┐
│   I/O调度器      │  ← 重排序、合并、优先级
│                │
│ [请求队列管理]   │
└─────────────────┘
        ↓
     磁盘设备
```

### 8.2 Linux主要I/O调度器类型


**🔍 四种主要调度器对比**

```
📊 调度器特性对比表：

┌──────────┬─────────────┬─────────────┬─────────────┐
│ 调度器名  │    特点     │   适用场景   │   延迟表现  │
├──────────┼─────────────┼─────────────┼─────────────┤
│   noop   │ 无重排序    │ SSD/虚拟化  │    最低     │
│ deadline │ 保证延迟    │ 数据库/实时  │     低      │  
│   cfq    │ 公平排队    │ 桌面/多用户  │    中等     │
│ bfq      │ 更公平      │ 桌面响应    │     低      │
└──────────┴─────────────┴─────────────┴─────────────┘
```

### 8.3 各调度器详细介绍


**🚀 NOOP (No Operation)**

```bash
📝 工作原理：
- 基本不做重排序，近似FIFO
- 只进行简单的I/O合并
- 开销最小，延迟最低

🎯 适用场景：
✅ SSD固态硬盘(无寻道时间)
✅ 虚拟化环境
✅ 硬件RAID控制器
✅ 高速存储设备

# 切换到noop调度器
echo noop > /sys/block/sda/queue/scheduler
```

**⏰ Deadline (截止时间调度)**

```bash
📝 工作原理：
- 为读写请求设置截止时间
- 读请求默认500ms，写请求默认5s
- 防止请求饥饿，保证响应时间

🎯 适用场景：
✅ 数据库服务器
✅ 实时应用
✅ 对延迟敏感的系统

# 切换到deadline调度器
echo deadline > /sys/block/sda/queue/scheduler

# 调整参数
echo 300 > /sys/block/sda/queue/iosched/read_expire
echo 3000 > /sys/block/sda/queue/iosched/write_expire
```

**⚖️ CFQ (完全公平队列)**

```bash  
📝 工作原理：
- 每个进程维护独立队列
- 时间片轮转，确保公平性
- 支持I/O优先级和权重

🎯 适用场景：
✅ 桌面系统  
✅ 多用户环境
✅ 需要公平性的场合

# CFQ是多数系统的默认调度器
echo cfq > /sys/block/sda/queue/scheduler

# 查看和调整参数
cat /sys/block/sda/queue/iosched/slice_idle
echo 8 > /sys/block/sda/queue/iosched/slice_idle
```

### 8.4 调度器选择与切换


**🔧 查看当前调度器**

```bash
# 查看当前使用的调度器
$ cat /sys/block/sda/queue/scheduler
noop deadline [cfq]    # [cfq]表示当前使用cfq

# 查看所有磁盘的调度器
$ for i in /sys/block/sd*/queue/scheduler; do 
    echo "$i: $(cat $i)"; 
  done
```

**⚡ 临时切换调度器**

```bash
# 切换到deadline(重启后失效)
echo deadline > /sys/block/sda/queue/scheduler

# 验证切换结果
cat /sys/block/sda/queue/scheduler
```

**💾 永久切换调度器**

```bash
# 方法1：修改内核参数
vim /etc/default/grub
# 添加：GRUB_CMDLINE_LINUX="elevator=deadline"
grub2-mkconfig -o /boot/grub2/grub.cfg

# 方法2：创建udev规则
vim /etc/udev/rules.d/60-schedulers.rules
# 添加：ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/scheduler}="deadline"
```

### 8.5 调度器性能优化


**🎯 针对不同工作负载优化**

```bash
# 数据库优化(deadline)
echo deadline > /sys/block/sda/queue/scheduler
echo 1 > /sys/block/sda/queue/iosched/fifo_batch
echo 300 > /sys/block/sda/queue/iosched/read_expire

# SSD优化(noop)  
echo noop > /sys/block/sda/queue/scheduler
echo 1 > /sys/block/sda/queue/nomerges

# 高并发Web服务器(deadline)
echo deadline > /sys/block/sda/queue/scheduler  
echo 64 > /sys/block/sda/queue/nr_requests
```

**📊 调度器性能测试**

```bash
#!/bin/bash
# 调度器性能对比测试脚本

echo "测试不同调度器性能..."
for sched in noop deadline cfq; do
    echo "测试 $sched 调度器:"
    echo $sched > /sys/block/sda/queue/scheduler
    
    # 使用fio进行测试
    fio -name=test -rw=randread -bs=4k -size=1G -numjobs=4 \
        -filename=/dev/sda --output=/tmp/fio_$sched.log
    
    echo "$sched 测试完成"
done

echo "查看测试结果:"
grep "IOPS" /tmp/fio_*.log
```

---

## 9. 🧪 磁盘性能基准测试


### 9.1 性能测试工具选择


**🛠️ 常用测试工具对比**

```
┌──────────┬─────────────┬─────────────┬─────────────┐
│  工具名   │    特点     │   复杂度    │   推荐度    │
├──────────┼─────────────┼─────────────┼─────────────┤
│    dd    │ 系统自带    │     低      │     ★★      │
│  hdparm  │ 硬件测试    │     低      │     ★★★     │
│   fio    │ 功能强大    │    中等     │    ★★★★★   │
│ iozone   │ 全面测试    │     高      │    ★★★★    │
└──────────┴─────────────┴─────────────┴─────────────┘
```

### 9.2 dd命令基准测试


**📊 基础读写测试**

```bash
# 测试写入性能(顺序写)
$ dd if=/dev/zero of=/tmp/testfile bs=1M count=1000 oflag=direct
1000+0 records in  
1000+0 records out
1048576000 bytes (1.0 GB) copied, 8.5 seconds, 123 MB/s

# 测试读取性能(顺序读)
$ dd if=/tmp/testfile of=/dev/null bs=1M iflag=direct  
1000+0 records in
1000+0 records out  
1048576000 bytes (1.0 GB) copied, 7.2 seconds, 146 MB/s

# 参数说明：
# bs=1M      - 每次读写1MB数据块
# count=1000 - 执行1000次操作
# oflag=direct - 绕过系统缓存直接写入
# iflag=direct - 绕过系统缓存直接读取
```

**💡 dd测试技巧**

```bash
# 测试不同块大小的性能
for bs in 4k 8k 16k 64k 1M; do
    echo "测试块大小 $bs:"
    dd if=/dev/zero of=/tmp/test bs=$bs count=10000 oflag=direct 2>&1 | 
    grep copied
done

# 测试同步写入性能
dd if=/dev/zero of=/tmp/testfile bs=1M count=100 oflag=sync

# 清除缓存后测试读取
echo 3 > /proc/sys/vm/drop_caches
dd if=/tmp/testfile of=/dev/null bs=1M
```

### 9.3 hdparm磁盘测试


**🔧 hdparm基础测试**

```bash
# 测试磁盘读取速度
$ hdparm -t /dev/sda
/dev/sda:
 Timing buffered disk reads: 366 MB in 3.01 seconds = 121.59 MB/sec

# 测试缓存读取速度  
$ hdparm -T /dev/sda
/dev/sda:
 Timing cached reads: 12312 MB in 2.00 seconds = 6159.96 MB/sec

# 获取磁盘详细信息
$ hdparm -I /dev/sda | grep -i speed
```

### 9.4 fio专业性能测试


**🚀 fio基础用法**

```bash
# 安装fio
yum install fio    # CentOS
apt install fio    # Ubuntu

# 基础语法
fio [options] jobfile
```

**📊 常用测试场景**

```bash
# 1. 顺序读测试
fio -name=sequential-read \
    -rw=read \
    -bs=1M \
    -size=1G \
    -numjobs=1 \
    -filename=/tmp/test

# 2. 随机读测试  
fio -name=random-read \
    -rw=randread \
    -bs=4k \
    -size=1G \
    -numjobs=4 \
    -filename=/tmp/test

# 3. 混合读写测试
fio -name=mixed-rw \
    -rw=randrw \
    -rwmixread=70 \
    -bs=4k \
    -size=1G \
    -numjobs=4 \
    -filename=/tmp/test
```

**🎯 生产环境模拟测试**

```bash
# 数据库工作负载模拟
fio -name=database-sim \
    -rw=randrw \
    -rwmixread=75 \
    -bs=8k \
    -iodepth=32 \
    -numjobs=4 \
    -size=2G \
    -runtime=300 \
    -filename=/data/fio-test

# Web服务器工作负载模拟  
fio -name=webserver-sim \
    -rw=randread \
    -bs=64k \
    -iodepth=16 \
    -numjobs=8 \
    -size=1G \
    -runtime=180 \
    -filename=/var/www/fio-test
```

### 9.5 fio结果解读


**📈 fio输出结果分析**

```bash
# 典型fio输出
Jobs: 4 (f=4): [r(4)] [100.0% done] [25.6MB/s] [6553 IOPS]

read : io=1024MB, bw=25.6MB/s, iops=6553, runt= 40001msec
  clat (usec): min=45, max=15234, avg=610.2, stdev=423.1
  lat (usec): min=47, max=15236, avg=612.8, stdev=423.2
  bw (KB/s) : min=5234, max=7890, per=25.1%, avg=6400, stdev=456
```

**📚 关键指标解释**

| 指标 | **含义** | **正常范围** |
|------|----------|-------------|
| `io` | 总I/O数据量 | 与设置的size匹配 |
| `bw` | 带宽(MB/s) | 根据硬件性能而定 |
| `iops` | 每秒I/O操作数 | 根据硬件性能而定 |
| `runt` | 运行时间(ms) | - |
| `clat` | 完成延迟 | <10ms为佳 |
| `lat` | 总延迟 | <15ms为佳 |

### 9.6 性能基准建立


**📋 建立性能基线**

```bash
#!/bin/bash
# 系统I/O性能基准测试脚本

echo "=== 系统I/O性能基准测试 ==="
echo "测试时间: $(date)"
echo

# 1. 顺序读写测试
echo "1. 顺序读写性能测试"
fio -name=seq-rw -rw=rw -bs=1M -size=1G -numjobs=1 \
    -filename=/tmp/benchmark --output-format=terse | \
    awk -F';' '{printf "顺序读: %.2f MB/s, 顺序写: %.2f MB/s\n", $7/1024, $48/1024}'

# 2. 随机读写测试
echo "2. 随机读写性能测试"  
fio -name=rand-rw -rw=randrw -bs=4k -size=1G -numjobs=4 \
    -filename=/tmp/benchmark --output-format=terse | \
    awk -F';' '{printf "随机读IOPS: %d, 随机写IOPS: %d\n", $8, $49}'

# 3. 延迟测试
echo "3. I/O延迟测试"
fio -name=latency -rw=randread -bs=4k -size=100M -numjobs=1 \
    -filename=/tmp/benchmark --output-format=normal | \
    grep -E "clat.*avg" | head -1

# 清理测试文件
rm -f /tmp/benchmark

echo "测试完成！"
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 I/O性能三大指标：IOPS、带宽、延迟的含义与关系
🔸 iostat命令：会看核心指标 %util、await、svctm、avgqu-sz
🔸 iotop命令：找出I/O占用高的进程，实时监控
🔸 队列机制：理解I/O队列深度与等待时间的关系
🔸 读写模式：区分随机I/O与顺序I/O的性能差异
🔸 调度器选择：了解不同场景下的最佳调度器
```

### 10.2 关键诊断思路


**🔍 I/O问题诊断流程**

```
第1步：整体观察
iostat -x 1 → 查看磁盘利用率和延迟

第2步：进程定位  
iotop -o → 找出I/O使用最高的进程

第3步：深入分析
lsof -p PID → 查看进程访问的文件
strace -p PID → 跟踪系统调用

第4步：优化方案
调整调度器 → 应用优化 → 硬件升级
```

### 10.3 优化策略记忆


**⚡ 分层次优化方案**

```
🔸 应急处理：
- 杀死占用I/O过高的进程
- 调整进程I/O优先级ionice
- 清理不必要的临时文件

🔸 系统优化：
- 选择合适的I/O调度器
- 调整文件系统参数
- 增加系统缓存

🔸 硬件升级：
- 机械硬盘 → SSD
- 单盘 → RAID磁盘阵列  
- 本地存储 → 高速网络存储

🔸 应用优化：
- 优化数据库查询
- 使用异步I/O
- 实施读写分离
- 增加应用缓存
```

### 10.4 实际应用指导


**💼 不同场景的I/O调优**

```
📊 数据库服务器：
- 调度器：deadline
- 关注：随机I/O性能、延迟
- 优化：索引优化、查询优化

🌐 Web服务器：
- 调度器：deadline或cfq  
- 关注：并发I/O能力
- 优化：静态文件缓存、CDN

📁 文件服务器：
- 调度器：cfq
- 关注：吞吐量、公平性
- 优化：大缓存、RAID

🖥️ 桌面系统：
- 调度器：cfq或bfq
- 关注：响应速度、公平性  
- 优化：SSD、足够内存
```

### 10.5 监控告警建议


**📊 关键指标监控阈值**

```
🔴 严重告警 (立即处理)：
- 磁盘利用率 > 90%
- I/O等待时间 > 50ms
- 队列深度 > 10
- CPU I/O等待 > 30%

🟡 警告提醒 (需要关注)：  
- 磁盘利用率 > 80%
- I/O等待时间 > 20ms
- 队列深度 > 5
- CPU I/O等待 > 15%

🟢 正常范围：
- 磁盘利用率 < 70%
- I/O等待时间 < 10ms  
- 队列深度 < 2
- CPU I/O等待 < 5%
```

**🧠 核心记忆口诀**：
```
iostat看整体，iotop找进程
util超八十需警惕，await过二十要优化  
IOPS延迟带宽三指标，调度器选对很关键
随机顺序差十倍，SSD机械性能殊
队列过长等待久，优化应用是根本
```

**💡 学习建议**：
- 多在测试环境练习各种命令
- 建立自己系统的性能基线
- 定期检查生产环境I/O状况
- 关注新的存储技术发展趋势