---
title: 14、文件系统空间分析
---
## 📚 目录

1. [文件系统空间分析概述](#1-文件系统空间分析概述)
2. [du命令磁盘使用统计](#2-du命令磁盘使用统计)
3. [目录大小分析技术](#3-目录大小分析技术)
4. [文件排序与热点识别](#4-文件排序与热点识别)
5. [高级空间统计技术](#5-高级空间统计技术)
6. [实时监控与自动化](#6-实时监控与自动化)
7. [实践应用与优化建议](#7-实践应用与优化建议)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💾 文件系统空间分析概述


### 1.1 什么是文件系统空间分析


**🔸 空间分析本质**
> **空间分析**：通过统计和分析文件系统中文件和目录的大小分布，帮助管理员了解磁盘空间使用情况，找出空间占用的热点，为清理和优化提供决策依据。

```
文件系统空间分析的作用：

磁盘空间紧张 → 空间分析 → 找出大文件 → 清理优化 → 释放空间
      ↓            ↓          ↓          ↓          ↓
   系统告警    统计分析    热点识别    删除整理    恢复正常
```

**💡 为什么需要空间分析**
```
常见场景：
- 磁盘空间不足警告出现
- 系统运行变慢，需要清理空间
- 定期维护，预防空间问题
- 成本控制，优化存储资源使用

分析目标：
- 哪些目录占用空间最多？
- 哪些文件是空间占用的大户？
- 有没有重复或无用的文件？
- 空间增长趋势如何？
```

### 1.2 空间分析工具体系


**🛠️ Linux空间分析工具全景**
```
Linux空间分析工具家族：

                      空间分析工具
                    /        |        \
               基础统计     排序分析     实时监控
              /       \    /       \   /        \
            du        df  sort     find  watch   inotify
          磁盘使用   磁盘空间 排序工具  查找工具 监控工具 文件监控
```

**📊 工具功能对比**
| **工具** | **主要功能** | **适用场景** | **特点** |
|---------|-------------|-------------|---------|
| **du** | `目录大小统计` | `递归统计目录空间使用` | `详细、可定制` |
| **df** | `文件系统使用情况` | `整体磁盘空间查看` | `快速、全局视图` |
| **find** | `按条件查找文件` | `找特定大小或类型文件` | `灵活、精确` |
| **sort** | `排序输出` | `按大小排序分析` | `数据处理必备` |
| **ncdu** | `交互式空间分析` | `可视化空间浏览` | `直观、易用` |

---

## 2. 📏 du命令磁盘使用统计


### 2.1 du命令基础语法


**📋 du命令格式**
```bash
# 基本语法
du [选项] [目录或文件]

# 常用格式
du -h /path/to/directory    # 人类可读格式显示
du -s /path/*              # 总结模式，只显示总大小
du -a /path/               # 显示所有文件和目录
```

**🎯 du核心选项**
| **选项** | **含义** | **示例** | **说明** |
|---------|---------|---------|---------|
| **-h** | `人类可读格式` | `du -h /home` | `显示K、M、G单位` |
| **-s** | `总结模式` | `du -s /var/*` | `只显示每个参数的总大小` |
| **-a** | `显示所有文件` | `du -a /etc` | `包括文件，不只目录` |
| **-d N** | `最大深度N层` | `du -d 2 /usr` | `限制递归深度` |
| **-c** | `显示总计` | `du -c /home/*` | `最后显示总和` |
| **-x** | `不跨文件系统` | `du -x /` | `不统计挂载点内容` |

### 2.2 du基本使用示例


**🔍 基础空间统计**
```bash
# 查看当前目录大小
du -h .                     # 递归显示当前目录及子目录大小

# 查看指定目录总大小
du -sh /var/log             # 只显示/var/log总大小
du -sh /home/*              # 显示/home下每个用户目录大小

# 查看多个目录
du -sh /var /tmp /opt       # 同时查看多个目录大小
```

**📊 典型输出示例**
```bash
$ du -sh /var/*
156M    /var/cache
2.1G    /var/lib
892M    /var/log
48K     /var/mail
4.0K    /var/opt
12M     /var/spool
32K     /var/tmp
```

### 2.3 du高级使用技巧


**⚡ 限制输出深度**
```bash
# 只看顶层目录大小
du -h --max-depth=1 /usr    # 等同于 du -d 1 -h /usr

# 看两层目录结构
du -h --max-depth=2 /var

# 输出示例：
# 1.2G    /var/lib
# 800M    /var/lib/mysql
# 400M    /var/lib/docker
# 892M    /var/log
# 600M    /var/log/apache2
# 292M    /var/log/syslog
```

**🎯 按大小阈值筛选**
```bash
# 只显示超过100M的目录
du -h /var | grep -E '^[0-9]+[0-9]M|^[0-9.]+G'

# 使用awk更精确筛选
du -h /var | awk '$1 ~ /[0-9]+G/ || $1 ~ /[5-9][0-9][0-9]M/'
```

---

## 3. 📁 目录大小分析技术


### 3.1 递归统计原理


**🔄 目录大小计算机制**
> **递归计算**：du命令通过递归遍历目录树，累加每个文件的实际磁盘占用空间，得出目录的总大小。

```
目录大小递归计算过程：

/home/user/
├── documents/
│   ├── file1.txt (10KB)
│   └── file2.pdf (5MB)
├── pictures/
│   ├── photo1.jpg (2MB)
│   └── photo2.png (3MB)
└── videos/
    └── movie.mp4 (1GB)

计算过程：
documents/ = 10KB + 5MB = 5.01MB
pictures/  = 2MB + 3MB = 5MB  
videos/    = 1GB = 1024MB
/home/user/ = 5.01MB + 5MB + 1024MB = 1034.01MB
```

**⚠️ 磁盘占用与文件大小的区别**
```bash
# 文件逻辑大小 vs 磁盘实际占用
ls -lh file.txt             # 显示文件逻辑大小
du -h file.txt              # 显示磁盘实际占用

# 稀疏文件示例
dd if=/dev/zero of=sparse.file bs=1 count=1 seek=1G
ls -lh sparse.file          # 显示1G
du -h sparse.file           # 可能只显示4K（一个块）
```

### 3.2 多层级目录分析


**🗂️ 分层统计策略**
```bash
# 逐层深入分析
du -h --max-depth=1 / | sort -hr    # 看根目录各分区大小
du -h --max-depth=1 /var | sort -hr # 深入/var目录
du -h --max-depth=2 /var/log | sort -hr # 再深入/var/log

# 一次性多层分析
for depth in 1 2 3; do
    echo "=== 深度 $depth ==="
    du -h --max-depth=$depth /usr | sort -hr | head -10
done
```

**📈 目录大小分布分析**
```bash
# 分析目录大小分布
#!/bin/bash
echo "目录大小分布分析："
echo "超过1G的目录："
du -h /var | awk '$1 ~ /[0-9.]+G/ {print $1 "\t" $2}'

echo "100M-1G的目录："
du -h /var | awk '$1 ~ /[5-9][0-9][0-9]M/ {print $1 "\t" $2}'

echo "10M-100M的目录："
du -h /var | awk '$1 ~ /[1-9][0-9]M/ {print $1 "\t" $2}'
```

### 3.3 排除特定内容


**🚫 跳过不相关目录**
```bash
# 排除特定目录
du -h --exclude="*.tmp" --exclude="cache" /var

# 排除多个模式
du -h /home --exclude="*.iso" --exclude="*.log" --exclude=".cache"

# 不跨越挂载点（重要！）
du -x -h /              # 不统计/proc、/sys等虚拟文件系统
```

**💡 为什么要排除虚拟文件系统**
```
虚拟文件系统说明：
/proc/  - 进程信息，内存中的虚拟文件
/sys/   - 系统设备信息，内核接口
/dev/   - 设备文件
这些目录在磁盘上不占用实际空间，统计时应该排除
```

---

## 4. 📊 文件排序与热点识别


### 4.1 按大小排序分析


**⬆️ 排序技巧大全**
```bash
# 按大小排序（数值排序）
du -h /var | sort -hr       # 降序排列，最大的在前
du -h /var | sort -h        # 升序排列，最小的在前

# 只看前10大目录
du -h /var | sort -hr | head -10

# 只看后10小目录  
du -h /var | sort -h | head -10
```

**🔥 空间占用热点识别**
```bash
# 找出系统中最大的目录（Top 10）
#!/bin/bash
echo "=== 系统空间占用 Top 10 ==="
du -h --max-depth=2 / 2>/dev/null | sort -hr | head -10

# 找出用户目录中的空间大户
echo "=== 用户目录空间分析 ==="
du -sh /home/* | sort -hr

# 找出日志目录中的大文件
echo "=== 日志文件大小分析 ==="
find /var/log -type f -size +10M -exec du -h {} + | sort -hr
```

### 4.2 文件大小排序分析


**📋 大文件识别策略**
```bash
# 按文件大小排序
du -a /var/log | sort -nr | head -20    # 数值排序，看最大文件

# 更直观的格式
du -ah /var/log | sort -hr | head -20   # 人类可读格式排序

# 只看大文件（超过100M）
find /var -type f -size +100M -exec du -h {} + | sort -hr
```

**🎯 特定类型文件分析**
```bash
# 分析不同类型文件的空间占用
echo "=== 日志文件空间统计 ==="
find /var/log -name "*.log" -exec du -ch {} + | tail -1

echo "=== 图片文件空间统计 ==="
find /home -name "*.jpg" -o -name "*.png" -exec du -ch {} + | tail -1

echo "=== 视频文件空间统计 ==="  
find /home -name "*.mp4" -o -name "*.avi" -exec du -ch {} + | tail -1
```

### 4.3 多维度排序分析


**📈 综合排序脚本**
```bash
#!/bin/bash
# 全方位空间分析脚本

echo "==================== 系统空间分析报告 ===================="
echo "生成时间: $(date)"
echo ""

echo "1. 磁盘使用概况："
df -h

echo ""
echo "2. 目录空间排行榜（Top 15）："
du -h --max-depth=2 / 2>/dev/null | sort -hr | head -15

echo ""
echo "3. 大文件排行榜（Top 10，超过50M）："
find / -type f -size +50M 2>/dev/null -exec du -h {} + | sort -hr | head -10

echo ""
echo "4. 用户目录使用情况："
if [ -d /home ]; then
    du -sh /home/* 2>/dev/null | sort -hr
fi

echo ""
echo "5. 日志文件统计："
if [ -d /var/log ]; then
    du -sh /var/log/* 2>/dev/null | sort -hr | head -5
fi
```

---

## 5. 🔍 高级空间统计技术


### 5.1 隐藏文件空间统计


**👻 隐藏文件处理**
```bash
# 包含隐藏文件的统计
du -ah .                    # -a选项自动包含隐藏文件

# 专门统计隐藏文件
du -sh .[^.]* 2>/dev/null   # 统计隐藏目录
du -sh .??* 2>/dev/null     # 另一种方式统计隐藏文件

# 隐藏文件大小分析
echo "隐藏目录大小统计："
for dir in .[^.]*; do
    [ -d "$dir" ] && du -sh "$dir"
done | sort -hr
```

**🔍 系统隐藏文件热点**
```bash
# 用户配置目录分析
du -sh ~/.cache ~/.config ~/.local 2>/dev/null | sort -hr

# 常见隐藏目录空间统计
echo "=== 隐藏目录空间分析 ==="
dirs=(".cache" ".config" ".local" ".mozilla" ".docker" ".npm")
for dir in "${dirs[@]}"; do
    if [ -d "$HOME/$dir" ]; then
        echo -n "$dir: "
        du -sh "$HOME/$dir" | cut -f1
    fi
done
```

### 5.2 硬链接去重统计


**🔗 硬链接重复统计问题**
> **硬链接问题**：同一个文件的多个硬链接会被重复统计，导致空间统计不准确。

```
硬链接统计示例：

原始文件: data.txt (100MB)
硬链接1: backup1.txt -> data.txt  
硬链接2: backup2.txt -> data.txt

普通du统计: 300MB（重复统计）
去重后统计: 100MB（实际占用）
```

**🎯 硬链接去重技术**
```bash
# 检测硬链接
find /path -type f -links +1    # 找出有多个硬链接的文件

# 按inode统计（自动去重）
find /path -type f -exec stat -c "%d %i %s %n" {} + | \
awk '{seen[$1":"$2] += $3} END {for(i in seen) total += seen[i]; print total}'

# 使用fdupes检测重复文件
fdupes -r /path                 # 需要安装fdupes工具
```

**⚡ 智能去重统计脚本**
```bash
#!/bin/bash
# 硬链接去重空间统计

smart_du() {
    local path="$1"
    echo "正在分析 $path 的真实空间占用..."
    
    # 按inode分组，避免重复统计
    find "$path" -type f -exec stat -c "%d:%i %s" {} + 2>/dev/null | \
    awk '{
        inode = $1; 
        size = $2; 
        if (seen[inode] == 0) {
            seen[inode] = 1; 
            total += size
        }
    } END {
        printf "真实占用空间: %.2f MB\n", total/1024/1024
    }'
    
    # 对比普通du的结果
    echo -n "du命令统计: "
    du -sm "$path" | cut -f1 | awk '{printf "%.2f MB\n", $1}'
}

# 使用示例
smart_du /var/log
```

### 5.3 实时空间监控


**⏰ 动态监控空间变化**
```bash
# 实时监控目录大小变化
watch -n 5 'du -sh /var/log'   # 每5秒更新一次

# 监控多个关键目录
watch -n 10 'echo "=== $(date) ==="; du -sh /var/log /tmp /home'

# 高级监控脚本
#!/bin/bash
monitor_space() {
    local target="$1"
    local threshold_mb="$2"
    
    while true; do
        current_size=$(du -sm "$target" | cut -f1)
        echo "$(date): $target 当前大小: ${current_size}MB"
        
        if [ "$current_size" -gt "$threshold_mb" ]; then
            echo "警告: $target 超过阈值 ${threshold_mb}MB!"
            # 可以在这里发送邮件或执行清理操作
        fi
        
        sleep 300  # 5分钟检查一次
    done
}

# 监控/var/log目录，阈值1GB
monitor_space /var/log 1024
```

---

## 6. 📱 实时监控与自动化


### 6.1 文件系统变化监控


**👀 inotify实时监控**
```bash
# 使用inotifywait监控目录变化
inotifywait -m -r --format '%w%f %e' /var/log

# 监控特定事件
inotifywait -m -r -e create,delete,modify --format '%T %w%f %e' \
--timefmt '%Y-%m-%d %H:%M:%S' /var/log

# 高级监控脚本
#!/bin/bash
monitor_filesystem_changes() {
    local watch_dir="$1"
    
    inotifywait -m -r -e create,delete,modify \
    --format '%T %w%f %e %s' --timefmt '%Y-%m-%d %H:%M:%S' \
    "$watch_dir" | while read time file event size; do
        
        if [[ "$event" == "CREATE" || "$event" == "MODIFY" ]]; then
            file_size=$(du -h "$file" 2>/dev/null | cut -f1)
            echo "$time: $file ($event) - 大小: $file_size"
            
            # 如果文件过大，记录警告
            if [[ "$file_size" =~ [0-9]+G ]]; then
                echo "警告: 检测到大文件 $file"
            fi
        fi
    done
}

# 监控/tmp目录
monitor_filesystem_changes /tmp
```

### 6.2 自动化空间分析


**🤖 定时分析任务**
```bash
#!/bin/bash
# 自动化空间分析和报告生成

generate_space_report() {
    local report_file="/tmp/space_report_$(date +%Y%m%d_%H%M%S).txt"
    
    {
        echo "================= 系统空间分析报告 ================="
        echo "生成时间: $(date)"
        echo "服务器: $(hostname)"
        echo ""
        
        echo "1. 磁盘使用总览："
        df -h
        echo ""
        
        echo "2. 空间使用TOP 10："
        du -h --max-depth=2 / 2>/dev/null | sort -hr | head -10
        echo ""
        
        echo "3. 大文件列表（>100M）："
        find / -type f -size +100M 2>/dev/null -exec ls -lh {} + | \
        awk '{print $5, $9}' | sort -hr | head -10
        echo ""
        
        echo "4. 日志文件统计："
        du -sh /var/log/* 2>/dev/null | sort -hr | head -5
        echo ""
        
        echo "5. 清理建议："
        generate_cleanup_suggestions
        
    } > "$report_file"
    
    echo "报告已生成: $report_file"
    
    # 如果空间紧张，发送邮件
    root_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$root_usage" -gt 80 ]; then
        echo "警告: 根分区使用率 ${root_usage}%，建议清理！"
        # mail -s "磁盘空间警告 $(hostname)" admin@company.com < "$report_file"
    fi
}

# 添加到crontab，每天凌晨2点执行
# 0 2 * * * /path/to/space_analysis.sh
```

### 6.3 智能清理建议


**💡 自动生成清理建议**
```bash
#!/bin/bash
generate_cleanup_suggestions() {
    echo "=== 清理建议 ==="
    
    # 检查日志文件
    echo "1. 日志文件清理："
    old_logs=$(find /var/log -name "*.log" -mtime +30 2>/dev/null | wc -l)
    if [ "$old_logs" -gt 0 ]; then
        echo "  - 发现 $old_logs 个超过30天的日志文件"
        echo "  - 建议命令: find /var/log -name '*.log' -mtime +30 -delete"
    fi
    
    # 检查临时文件
    echo "2. 临时文件清理："
    temp_size=$(du -sm /tmp 2>/dev/null | cut -f1)
    if [ "$temp_size" -gt 1024 ]; then
        echo "  - /tmp目录大小: ${temp_size}MB"
        echo "  - 建议清理: find /tmp -atime +7 -delete"
    fi
    
    # 检查包缓存
    echo "3. 软件包缓存："
    if command -v apt > /dev/null; then
        cache_size=$(du -sm /var/cache/apt 2>/dev/null | cut -f1)
        echo "  - APT缓存大小: ${cache_size}MB"
        echo "  - 建议清理: apt clean"
    fi
    
    if command -v yum > /dev/null; then
        cache_size=$(du -sm /var/cache/yum 2>/dev/null | cut -f1)
        echo "  - YUM缓存大小: ${cache_size}MB"
        echo "  - 建议清理: yum clean all"
    fi
    
    # 检查大文件
    echo "4. 大文件检查："
    large_files=$(find / -type f -size +1G 2>/dev/null | wc -l)
    if [ "$large_files" -gt 0 ]; then
        echo "  - 发现 $large_files 个大于1GB的文件"
        echo "  - 建议检查: find / -type f -size +1G 2>/dev/null"
    fi
}
```

---

## 7. 💼 实践应用与优化建议


### 7.1 常见空间问题诊断


**🔧 问题诊断流程**
```bash
#!/bin/bash
# 空间问题快速诊断脚本

space_diagnosis() {
    echo "================== 空间问题诊断 =================="
    
    # 1. 检查磁盘使用情况
    echo "1. 磁盘使用情况："
    df -h | awk 'NR==1 || $5>80 {print}' # 只显示使用率>80%的
    
    # 2. 检查inode使用情况
    echo -e "\n2. Inode使用情况："
    df -i | awk 'NR==1 || $5>80 {print}'
    
    # 3. 找出空间占用大户
    echo -e "\n3. 空间占用TOP 5："
    du -h --max-depth=1 / 2>/dev/null | sort -hr | head -5
    
    # 4. 检查最近增长的文件
    echo -e "\n4. 最近24小时内增长的大文件："
    find / -type f -newermt "24 hours ago" -size +100M 2>/dev/null -exec ls -lh {} +
    
    # 5. 检查进程占用的已删除文件
    echo -e "\n5. 已删除但仍被进程占用的文件："
    lsof +L1 2>/dev/null | grep deleted
    
    echo -e "\n================== 诊断完成 =================="
}

space_diagnosis
```

### 7.2 性能优化技巧


**⚡ du命令优化技巧**
```bash
# 避免跨文件系统统计（提高性能）
du -x -h /                  # 只统计本文件系统

# 并行处理大目录
parallel -j4 du -sh {} ::: /var/log/* /home/*

# 使用更快的替代工具
ncdu /var/log              # 交互式，更直观
dust /var/log              # Rust编写，速度更快（需安装）

# 针对大目录的优化
timeout 30 du -h /var      # 设置超时，避免长时间等待
```

**📊 统计结果缓存**
```bash
#!/bin/bash
# 缓存du结果，避免重复计算

CACHE_DIR="/tmp/du_cache"
mkdir -p "$CACHE_DIR"

cached_du() {
    local target="$1"
    local cache_file="$CACHE_DIR/$(echo "$target" | tr '/' '_').cache"
    
    # 如果缓存文件存在且不超过1小时
    if [ -f "$cache_file" ] && [ $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt 3600 ]; then
        echo "使用缓存数据:"
        cat "$cache_file"
    else
        echo "重新计算并缓存..."
        du -sh "$target" | tee "$cache_file"
    fi
}

# 使用示例
cached_du /var/log
```

### 7.3 企业级监控方案


**🏢 生产环境监控**
```bash
#!/bin/bash
# 企业级空间监控脚本

ALERT_THRESHOLD=85
LOG_FILE="/var/log/space_monitor.log"
ALERT_EMAIL="admin@company.com"

enterprise_monitor() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 检查所有挂载点
    df -h | awk 'NR>1 {
        gsub(/%/, "", $5); 
        if($5 > '$ALERT_THRESHOLD') 
            print $6 " 使用率: " $5 "% 警告!"
        else 
            print $6 " 使用率: " $5 "% 正常"
    }' | while read line; do
        echo "[$timestamp] $line" | tee -a "$LOG_FILE"
        
        # 发送告警
        if [[ "$line" == *"警告"* ]]; then
            echo "$line" | mail -s "磁盘空间告警 $(hostname)" "$ALERT_EMAIL"
        fi
    done
}

# 定期执行监控
while true; do
    enterprise_monitor
    sleep 3600  # 每小时检查一次
done
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 du命令：Linux系统中统计目录和文件磁盘使用量的核心工具
🔸 递归统计：du通过遍历目录树累计计算空间使用量
🔸 空间分析：找出系统中的空间占用热点，为优化提供依据
🔸 排序技巧：结合sort命令实现按大小排序的分析
🔸 实时监控：使用watch、inotify等工具监控空间变化
🔸 自动化：编写脚本实现定期分析和自动清理建议
```

### 8.2 关键理解要点


**🔹 du与df的区别**
```
du (disk usage)：
- 统计目录和文件的实际占用空间
- 递归计算，可以精确到文件级别
- 适合分析空间分布和查找大文件

df (disk free)：
- 显示文件系统的整体使用情况
- 显示可用空间和使用率
- 适合查看磁盘容量和剩余空间
```

**🔹 硬链接对统计的影响**
```
重复统计问题：
- 普通du会重复统计硬链接
- 需要按inode去重来获得真实占用
- 符号链接不会造成重复统计
```

**🔹 性能优化要点**
```
提升统计速度：
- 使用-x选项避免跨文件系统
- 限制递归深度避免过深遍历
- 排除虚拟文件系统和临时目录
- 使用并行处理处理多个大目录
```

### 8.3 实际应用价值


**💼 系统管理应用**
- **空间规划**：了解空间使用模式，合理分配存储资源
- **故障处理**：快速定位空间不足的原因，找出占用大户
- **性能优化**：清理无用文件，提高系统运行效率
- **容量预测**：分析空间增长趋势，提前做好扩容准备

**🔧 日常运维应用**
- **定期清理**：识别可清理的日志、缓存、临时文件
- **监控告警**：设置阈值监控，及时发现空间异常
- **成本控制**：在云环境中优化存储使用，降低成本
- **合规管理**：清理过期数据，满足数据保留策略

### 8.4 常用命令速查


**⚡ 核心命令清单**
```bash
# 基础统计
du -sh /path              # 显示目录总大小
du -h --max-depth=1 /path # 显示下一级目录大小
du -ah /path | sort -hr   # 所有文件按大小排序

# 查找大文件
find /path -type f -size +100M -exec du -h {} +
du -a /path | sort -nr | head -20

# 实时监控
watch -n 5 'du -sh /var/log'
inotifywait -m -r /path

# 批量分析
du -sh /* | sort -hr      # 根目录各分区大小
du -sh /home/* | sort -hr # 用户目录大小
```

**🎯 问题排查思路**
```bash
# 1. 整体空间查看
df -h

# 2. 找出空间占用大户
du -h --max-depth=2 / | sort -hr | head -10

# 3. 深入分析具体目录
du -ah /var/log | sort -hr | head -20

# 4. 查找最近增长的文件
find /var -type f -newermt "1 day ago" -size +50M

# 5. 检查进程占用的已删除文件
lsof +L1 | grep deleted
```

### 8.5 最佳实践建议


**💡 操作建议**
- **定期分析**：建立定期空间分析的习惯，预防问题发生
- **分层诊断**：从整体到局部，逐层深入分析空间使用
- **自动化监控**：编写监控脚本，实现自动化告警和报告
- **安全清理**：清理前做好备份，避免误删重要文件

**⚠️ 注意事项**
- 在生产环境中运行du命令时注意性能影响
- 统计大目录时可能需要较长时间，建议使用timeout限制
- 清理文件前要确认文件的重要性和依赖关系
- 注意硬链接可能导致的重复统计问题

**核心记忆口诀**：
```
du统计磁盘用量准，递归计算找根源
-h人读-s汇总显，sort排序热点现
大文件查找有技巧，实时监控要趁早
硬链接重复要注意，自动清理建议好
定期分析防问题，空间管理效率高
```