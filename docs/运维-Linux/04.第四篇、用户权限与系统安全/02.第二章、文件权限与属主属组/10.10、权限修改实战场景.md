---
title: 10、权限修改实战场景
---
## 📚 目录

1. [Web目录权限配置标准实践](#1-Web目录权限配置标准实践)
2. [日志文件权限安全配置](#2-日志文件权限安全配置)
3. [脚本文件执行权限设置](#3-脚本文件执行权限设置)
4. [共享目录多用户权限配置](#4-共享目录多用户权限配置)
5. [系统配置文件权限保护](#5-系统配置文件权限保护)
6. [备份文件权限安全设置](#6-备份文件权限安全设置)
7. [临时文件权限管理策略](#7-临时文件权限管理策略)
8. [权限批量修改脚本编写技巧](#8-权限批量修改脚本编写技巧)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 Web目录权限配置标准实践


### 1.1 Web服务器权限基础概念


**🔸 Web目录权限的重要性**
```
为什么Web目录权限很关键？

网站安全问题：
• 权限过松 → 黑客可以篡改网页文件
• 权限过紧 → 网站无法正常访问
• 配置错误 → 敏感信息泄露

就像家里的门锁：
• 不锁门 → 小偷随便进
• 锁太死 → 自己都进不了
• 钥匙给错人 → 危险分子能进入
```

**💡 Web服务器用户概念**
```
Apache服务器通常用什么用户运行？
• CentOS/RHEL: apache 或 www-data
• Ubuntu/Debian: www-data
• Nginx: nginx 或 www-data

就像公司的保安：
• 保安有钥匙能进办公室
• 但不能进入老板的保险柜
• Web服务器用户也一样，有权限访问网页文件，但不能碰系统核心文件
```

### 1.2 标准Web目录权限配置


**📂 典型Web目录结构**
```
/var/www/html/                 ← Web根目录
├── index.html                 ← 静态网页文件
├── css/                       ← 样式文件目录
├── js/                        ← JavaScript文件目录
├── images/                    ← 图片文件目录
├── uploads/                   ← 用户上传目录
├── config/                    ← 配置文件目录
└── logs/                      ← 日志文件目录
```

**🔧 标准权限设置命令**
```bash
# 1. 设置Web根目录所有者
sudo chown -R www-data:www-data /var/www/html/

# 2. 设置目录权限为755（所有者可读写执行，其他人可读执行）
sudo find /var/www/html/ -type d -exec chmod 755 {} \;

# 3. 设置文件权限为644（所有者可读写，其他人只读）
sudo find /var/www/html/ -type f -exec chmod 644 {} \;

# 4. 特殊目录权限设置
sudo chmod 775 /var/www/html/uploads/   # 上传目录需要写权限
sudo chmod 700 /var/www/html/config/    # 配置目录只有所有者能访问
```

**📊 Web权限配置对照表**

| 目录类型 | **权限设置** | **用途说明** | **安全考虑** |
|----------|-------------|-------------|-------------|
| 🏠 **根目录** | `755` | `Web服务器需要读取和执行` | `不给写权限防止被篡改` |
| 📄 **静态文件** | `644` | `只需要读取，不需要执行` | `防止恶意脚本执行` |
| 📁 **普通目录** | `755` | `需要进入目录查看文件` | `标准目录权限` |
| 📤 **上传目录** | `775` | `用户需要上传文件` | `定期清理，防止恶意文件` |
| ⚙️ **配置目录** | `700` | `只有管理员能访问` | `包含数据库密码等敏感信息` |

### 1.3 实战配置示例


**🎯 完整Web站点权限配置脚本**
```bash
#!/bin/bash
# Web站点权限标准化配置脚本

WEB_ROOT="/var/www/html"
WEB_USER="www-data"
WEB_GROUP="www-data"

echo "🔧 开始配置Web站点权限..."

# 检查目录是否存在
if [ ! -d "$WEB_ROOT" ]; then
    echo "❌ Web根目录不存在: $WEB_ROOT"
    exit 1
fi

# 设置所有者
echo "👤 设置目录所有者为 $WEB_USER:$WEB_GROUP"
chown -R $WEB_USER:$WEB_GROUP $WEB_ROOT

# 设置基本权限
echo "📂 设置目录权限为 755"
find $WEB_ROOT -type d -exec chmod 755 {} \;

echo "📄 设置文件权限为 644" 
find $WEB_ROOT -type f -exec chmod 644 {} \;

# 特殊目录权限
if [ -d "$WEB_ROOT/uploads" ]; then
    echo "📤 设置上传目录特殊权限 775"
    chmod 775 $WEB_ROOT/uploads
fi

if [ -d "$WEB_ROOT/config" ]; then
    echo "⚙️ 设置配置目录安全权限 700"
    chmod 700 $WEB_ROOT/config
fi

echo "✅ Web站点权限配置完成！"
```

---

## 2. 📋 日志文件权限安全配置


### 2.1 日志文件权限的重要性


**🔸 为什么日志文件权限很关键？**
```
日志文件包含什么敏感信息？
• 用户访问记录 → IP地址、访问时间
• 错误信息 → 系统内部结构暴露
• 认证日志 → 登录失败信息
• 应用日志 → 业务数据泄露

就像医生的病历本：
• 只有医生能写（记录日志）
• 护士能看（监控系统）
• 病人不能看（普通用户无权限）
```

### 2.2 系统日志权限配置


**📁 常见系统日志目录权限**
```bash
# 查看系统日志目录权限
ls -la /var/log/

# 典型输出：
drwxr-xr-x   root root     /var/log/
-rw-r-----   root adm      /var/log/syslog
-rw-------   root root     /var/log/auth.log
-rw-r--r--   root root     /var/log/messages
```

**🔧 标准日志权限设置**
```bash
# 1. 系统日志权限（只有root和adm组能读）
sudo chmod 640 /var/log/syslog
sudo chown root:adm /var/log/syslog

# 2. 认证日志权限（只有root能访问）
sudo chmod 600 /var/log/auth.log
sudo chown root:root /var/log/auth.log

# 3. 应用程序日志权限
sudo chmod 644 /var/log/application.log
sudo chown app-user:app-group /var/log/application.log
```

### 2.3 Web服务器日志权限配置


**🌐 Apache日志权限设置**
```bash
# Apache访问日志
sudo chmod 644 /var/log/apache2/access.log
sudo chown root:adm /var/log/apache2/access.log

# Apache错误日志（更严格的权限）
sudo chmod 640 /var/log/apache2/error.log  
sudo chown root:adm /var/log/apache2/error.log
```

**⚠️ 常见误区提醒**
```
❌ 错误做法：
chmod 777 /var/log/app.log  → 任何人都能修改日志，安全风险极大

✅ 正确做法：
chmod 644 /var/log/app.log  → 只有所有者能写，其他人只能读
```

### 2.4 日志轮转权限配置


**🔄 logrotate配置示例**
```bash
# /etc/logrotate.d/myapp 配置文件
/var/log/myapp/*.log {
    daily                    # 每天轮转
    missingok               # 文件不存在不报错
    rotate 52               # 保留52个备份
    compress                # 压缩旧日志
    notifempty             # 空文件不轮转
    create 644 myapp myapp  # 创建新文件的权限和所有者
    postrotate             # 轮转后执行的命令
        systemctl reload myapp
    endscript
}
```

---

## 3. ⚡ 脚本文件执行权限设置


### 3.1 脚本执行权限基础概念


**🔸 为什么脚本需要执行权限？**
```
Linux文件权限中的"执行"是什么意思？

就像现实生活中的说明书：
• 可读(r) → 能看懂说明书内容
• 可写(w) → 能修改说明书
• 可执行(x) → 能按照说明书去做事

脚本文件也一样：
• 没有执行权限 → 系统不认为它是可运行的程序
• 有执行权限 → 系统知道这是个可以运行的脚本
```

### 3.2 脚本权限设置实践


**📝 Shell脚本权限配置**
```bash
# 创建一个测试脚本
cat > test_script.sh << 'EOF'
#!/bin/bash
echo "Hello, I'm a script!"
date
EOF

# 查看当前权限
ls -l test_script.sh
# 输出：-rw-rw-r-- 1 user user 52 Sep 14 15:30 test_script.sh

# 尝试运行（会失败）
./test_script.sh
# 输出：bash: ./test_script.sh: Permission denied

# 添加执行权限
chmod +x test_script.sh

# 再次查看权限
ls -l test_script.sh  
# 输出：-rwxrwxr-x 1 user user 52 Sep 14 15:30 test_script.sh

# 现在可以运行了
./test_script.sh
# 输出：Hello, I'm a script!
```

**🔧 不同类型脚本权限设置**

| 脚本类型 | **权限设置** | **使用场景** | **安全考虑** |
|----------|-------------|-------------|-------------|
| 🔒 **系统管理脚本** | `700` | `只有root使用` | `最高安全级别` |
| 👥 **团队共用脚本** | `750` | `团队内部使用` | `组内可执行，其他人不能` |
| 🌐 **通用工具脚本** | `755` | `所有用户都能用` | `公开但只有所有者能修改` |
| 📊 **个人脚本** | `744` | `只有自己用` | `其他人可以看但不能运行` |

### 3.3 脚本安全权限最佳实践


**🛡️ 安全脚本权限配置示例**
```bash
#!/bin/bash
# 自动化脚本权限配置

SCRIPT_DIR="/opt/scripts"

# 系统管理脚本（只有root能执行）
sudo chmod 700 $SCRIPT_DIR/system-*
sudo chown root:root $SCRIPT_DIR/system-*

# 数据库备份脚本（只有数据库管理员能执行）
sudo chmod 750 $SCRIPT_DIR/db-backup.sh
sudo chown mysql:dba $SCRIPT_DIR/db-backup.sh

# 通用工具脚本（所有人都能使用）
sudo chmod 755 $SCRIPT_DIR/tools/*
sudo chown root:root $SCRIPT_DIR/tools/*

echo "✅ 脚本权限配置完成"
```

**💡 脚本权限检查技巧**
```bash
# 检查脚本是否有执行权限
if [ -x "/path/to/script.sh" ]; then
    echo "脚本有执行权限"
    ./script.sh
else
    echo "脚本没有执行权限，请先设置："
    echo "chmod +x /path/to/script.sh"
fi
```

---

## 4. 👥 共享目录多用户权限配置


### 4.1 共享目录权限概念


**🔸 什么是共享目录？**
```
共享目录就像公司的共享文件夹：
• 多个人都需要访问
• 不同人有不同权限
• 需要防止误删除和冲突

Linux中的共享目录特点：
• 多个用户需要读写权限
• 需要用户组来管理权限
• 要设置特殊权限位防止互相删除
```

### 4.2 用户组管理基础


**👥 创建共享用户组**
```bash
# 1. 创建共享项目组
sudo groupadd project-team

# 2. 将用户添加到组中
sudo usermod -a -G project-team alice
sudo usermod -a -G project-team bob  
sudo usermod -a -G project-team charlie

# 3. 查看组成员
getent group project-team
# 输出：project-team:x:1001:alice,bob,charlie
```

**📂 创建共享目录**
```bash
# 1. 创建共享目录
sudo mkdir /shared/project

# 2. 设置目录所有者和组
sudo chown root:project-team /shared/project

# 3. 设置目录权限
sudo chmod 775 /shared/project

# 4. 设置SGID位（重要！）
sudo chmod g+s /shared/project
```

### 4.3 SGID权限详解


**🔸 什么是SGID？**
```
SGID (Set Group ID) 是什么意思？

就像公司的项目文件夹规则：
• 任何人在这个文件夹里创建的文件
• 都自动属于项目组
• 这样团队所有人都能访问

没有SGID的问题：
• alice创建文件 → 属于alice组
• bob无法修改alice创建的文件
• 导致协作困难

有了SGID的好处：
• alice创建文件 → 自动属于project-team组
• bob也可以修改这个文件
• 团队协作顺畅
```

**🔧 SGID实战演示**
```bash
# 查看SGID权限设置效果
ls -ld /shared/project
# 输出：drwxrwsr-x 2 root project-team 4096 Sep 14 15:30 /shared/project
#           ↑ 注意这里是 's' 而不是 'x'

# 用alice身份创建文件
sudo -u alice touch /shared/project/alice_file.txt

# 查看文件权限
ls -l /shared/project/alice_file.txt
# 输出：-rw-rw-r-- 1 alice project-team 0 Sep 14 15:30 alice_file.txt
#                        ↑ 自动属于project-team组！

# bob现在可以编辑这个文件了
sudo -u bob echo "Bob's edit" >> /shared/project/alice_file.txt
```

### 4.4 Sticky Bit权限配置


**🔸 防止误删除的Sticky Bit**
```
Sticky Bit是什么？

就像公共垃圾桶的规则：
• 每个人都能扔垃圾（创建文件）
• 但只能拿走自己扔的垃圾（删除自己的文件）
• 不能拿走别人的东西（不能删除别人的文件）

在共享目录中的作用：
• 防止用户误删除别人的文件
• 只有文件所有者和root能删除文件
• 提高共享目录的安全性
```

**🔧 设置Sticky Bit**
```bash
# 设置Sticky Bit权限
sudo chmod +t /shared/project

# 查看权限变化
ls -ld /shared/project  
# 输出：drwxrwsr-t 2 root project-team 4096 Sep 14 15:30 /shared/project
#                ↑ 最后一位是 't'

# 测试效果
sudo -u alice touch /shared/project/alice_secret.txt
sudo -u bob rm /shared/project/alice_secret.txt
# 输出：rm: cannot remove 'alice_secret.txt': Operation not permitted
```

### 4.5 完整共享目录配置脚本


**🎯 共享目录标准化配置脚本**
```bash
#!/bin/bash
# 共享目录权限标准配置脚本

SHARED_DIR="/shared/team-project"
GROUP_NAME="dev-team"
USERS=("alice" "bob" "charlie" "david")

echo "🔧 开始配置共享目录权限..."

# 1. 创建用户组
if ! getent group $GROUP_NAME > /dev/null 2>&1; then
    echo "👥 创建用户组: $GROUP_NAME"
    groupadd $GROUP_NAME
fi

# 2. 添加用户到组
for user in "${USERS[@]}"; do
    if id "$user" > /dev/null 2>&1; then
        echo "➕ 添加用户 $user 到组 $GROUP_NAME"
        usermod -a -G $GROUP_NAME $user
    else
        echo "⚠️  用户 $user 不存在，跳过"
    fi
done

# 3. 创建共享目录
echo "📂 创建共享目录: $SHARED_DIR"
mkdir -p $SHARED_DIR

# 4. 设置权限
echo "🔧 设置目录权限和所有者"
chown root:$GROUP_NAME $SHARED_DIR
chmod 775 $SHARED_DIR    # 组内可读写执行
chmod g+s $SHARED_DIR    # 设置SGID
chmod +t $SHARED_DIR     # 设置Sticky Bit

# 5. 显示最终权限
echo "✅ 配置完成！最终权限："
ls -ld $SHARED_DIR

echo ""
echo "📋 使用说明："
echo "• 组成员可以在目录中创建、修改文件"
echo "• 新创建的文件自动属于 $GROUP_NAME 组"  
echo "• 用户只能删除自己创建的文件"
echo "• 重新登录后权限才会生效"
```

---

## 5. ⚙️ 系统配置文件权限保护


### 5.1 系统配置文件安全的重要性


**🔸 为什么要保护系统配置文件？**
```
系统配置文件包含什么重要信息？
• 用户密码哈希 (/etc/shadow)
• 系统服务配置 (/etc/systemd/)
• 网络配置 (/etc/network/)
• 安全策略配置 (/etc/security/)

就像家里的保险柜：
• 里面放着重要文档（配置文件）
• 只有家人能打开（root权限）
• 不能让外人随便翻看（严格权限控制）
```

### 5.2 关键系统配置文件权限


**🔒 密码相关文件权限**
```bash
# 查看密码文件权限
ls -l /etc/passwd /etc/shadow /etc/group

# 标准权限应该是：
# -rw-r--r-- 1 root root  /etc/passwd   # 644 用户信息，可以公开读取
# -rw-r----- 1 root shadow /etc/shadow  # 640 密码哈希，只有特权用户读取  
# -rw-r--r-- 1 root root  /etc/group    # 644 用户组信息，可以公开读取

# 如果权限不对，修正它们：
sudo chmod 644 /etc/passwd
sudo chmod 640 /etc/shadow  
sudo chmod 644 /etc/group
sudo chown root:shadow /etc/shadow
```

**⚙️ 系统服务配置文件权限**
```bash
# SSH配置文件权限
ls -l /etc/ssh/sshd_config
# 应该是：-rw------- 1 root root /etc/ssh/sshd_config

# 修正SSH配置权限
sudo chmod 600 /etc/ssh/sshd_config
sudo chown root:root /etc/ssh/sshd_config

# 网络配置权限
sudo chmod 644 /etc/network/interfaces
sudo chown root:root /etc/network/interfaces
```

### 5.3 应用程序配置文件权限


**🗄️ 数据库配置文件权限**
```bash
# MySQL配置文件
sudo chmod 644 /etc/mysql/mysql.conf.d/mysqld.cnf
sudo chown root:root /etc/mysql/mysql.conf.d/mysqld.cnf

# 包含密码的配置文件要更严格
sudo chmod 600 /etc/mysql/debian.cnf
sudo chown root:root /etc/mysql/debian.cnf
```

**🌐 Web服务器配置权限**
```bash
# Apache配置文件
sudo chmod 644 /etc/apache2/apache2.conf
sudo chmod 644 /etc/apache2/sites-available/*.conf

# 包含敏感信息的配置文件
sudo chmod 600 /etc/apache2/ssl/private-keys/*.key
sudo chown root:root /etc/apache2/ssl/private-keys/*.key
```

### 5.4 配置文件权限检查脚本


**🛡️ 系统配置权限审计脚本**
```bash
#!/bin/bash
# 系统配置文件权限检查脚本

echo "🔍 开始检查系统配置文件权限..."

# 定义检查函数
check_file_permission() {
    local file=$1
    local expected_perm=$2
    local expected_owner=$3
    
    if [ -f "$file" ]; then
        current_perm=$(stat -c "%a" "$file")
        current_owner=$(stat -c "%U:%G" "$file")
        
        echo "📄 检查文件: $file"
        if [ "$current_perm" = "$expected_perm" ] && [ "$current_owner" = "$expected_owner" ]; then
            echo "   ✅ 权限正确: $current_perm $current_owner"
        else
            echo "   ❌ 权限异常: 当前($current_perm $current_owner) 期望($expected_perm $expected_owner)"
            echo "   🔧 修复命令: sudo chmod $expected_perm $file && sudo chown $expected_owner $file"
        fi
    else
        echo "   ⚠️  文件不存在: $file"
    fi
    echo ""
}

# 检查关键系统文件
echo "🔐 检查密码相关文件..."
check_file_permission "/etc/passwd" "644" "root:root"
check_file_permission "/etc/shadow" "640" "root:shadow"
check_file_permission "/etc/group" "644" "root:root"

echo "🌐 检查网络配置文件..."
check_file_permission "/etc/ssh/sshd_config" "600" "root:root"
check_file_permission "/etc/network/interfaces" "644" "root:root"

echo "🗄️ 检查服务配置文件..."
check_file_permission "/etc/mysql/debian.cnf" "600" "root:root"

echo "✅ 权限检查完成！"
```

---

## 6. 💾 备份文件权限安全设置


### 6.1 备份文件安全的重要性


**🔸 为什么备份文件权限很重要？**
```
备份文件可能包含什么敏感信息？
• 数据库完整备份 → 所有用户数据
• 配置文件备份 → 密码和密钥
• 用户文件备份 → 个人隐私信息
• 系统备份 → 完整系统状态

就像银行保险库的备份钥匙：
• 威力比原钥匙更大（包含历史数据）
• 必须比原文件更严格保护
• 不能让无关人员接触
```

### 6.2 数据库备份权限配置


**🗄️ MySQL备份权限设置**
```bash
# 创建备份目录
sudo mkdir -p /backup/mysql
sudo mkdir -p /backup/mysql/daily
sudo mkdir -p /backup/mysql/weekly

# 设置备份目录权限（只有root和backup用户能访问）
sudo chown root:backup /backup/mysql
sudo chmod 750 /backup/mysql
sudo chmod 750 /backup/mysql/daily  
sudo chmod 750 /backup/mysql/weekly

# 创建备份脚本
cat > /opt/scripts/mysql-backup.sh << 'EOF'
#!/bin/bash
# MySQL备份脚本

BACKUP_DIR="/backup/mysql/daily"
DB_USER="backup_user"
DB_PASS="secure_password"  
DATE=$(date +%Y%m%d_%H%M%S)

# 执行备份
mysqldump -u$DB_USER -p$DB_PASS --all-databases > $BACKUP_DIR/all_databases_$DATE.sql

# 设置备份文件权限（只有root能读取）
chmod 600 $BACKUP_DIR/all_databases_$DATE.sql
chown root:root $BACKUP_DIR/all_databases_$DATE.sql

# 删除7天前的备份
find $BACKUP_DIR -name "*.sql" -mtime +7 -delete

echo "✅ 数据库备份完成: $BACKUP_DIR/all_databases_$DATE.sql"
EOF

# 设置脚本权限
sudo chmod 700 /opt/scripts/mysql-backup.sh
sudo chown root:root /opt/scripts/mysql-backup.sh
```

### 6.3 文件系统备份权限


**📂 系统文件备份权限配置**
```bash
# 创建系统备份目录结构
sudo mkdir -p /backup/system/{etc,home,var}

# 设置严格的备份目录权限
sudo chmod 700 /backup/system
sudo chown root:root /backup/system

# 配置文件备份
sudo tar -czf /backup/system/etc/etc-backup-$(date +%Y%m%d).tar.gz -C / etc
sudo chmod 600 /backup/system/etc/etc-backup-*.tar.gz

# 用户文件备份（如果需要）
sudo tar -czf /backup/system/home/home-backup-$(date +%Y%m%d).tar.gz -C / home  
sudo chmod 600 /backup/system/home/home-backup-*.tar.gz

# 日志文件备份
sudo tar -czf /backup/system/var/var-log-backup-$(date +%Y%m%d).tar.gz -C / var/log
sudo chmod 640 /backup/system/var/var-log-backup-*.tar.gz
sudo chown root:adm /backup/system/var/var-log-backup-*.tar.gz
```

### 6.4 备份加密和权限管理


**🔐 加密备份脚本**
```bash
#!/bin/bash
# 加密备份脚本

BACKUP_DIR="/backup/encrypted"
GPG_RECIPIENT="admin@company.com"
SOURCE_DIR="/important/data"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建加密备份目录
mkdir -p $BACKUP_DIR
chmod 700 $BACKUP_DIR

# 打包并加密备份
tar -czf - $SOURCE_DIR | gpg --trust-model always -r $GPG_RECIPIENT -e > $BACKUP_DIR/backup_$DATE.tar.gz.gpg

# 设置加密文件权限
chmod 600 $BACKUP_DIR/backup_$DATE.tar.gz.gpg
chown root:root $BACKUP_DIR/backup_$DATE.tar.gz.gpg

# 验证备份完整性
if [ -f "$BACKUP_DIR/backup_$DATE.tar.gz.gpg" ]; then
    echo "✅ 加密备份创建成功: $BACKUP_DIR/backup_$DATE.tar.gz.gpg"
    ls -l $BACKUP_DIR/backup_$DATE.tar.gz.gpg
else
    echo "❌ 加密备份失败！"
    exit 1
fi

# 清理旧备份（保留30天）
find $BACKUP_DIR -name "backup_*.tar.gz.gpg" -mtime +30 -delete
```

---

## 7. 🗂️ 临时文件权限管理策略


### 7.1 临时文件的安全风险


**🔸 临时文件为什么有安全风险？**
```
临时文件的常见问题：
• 包含敏感数据但权限过松
• 程序异常退出后未清理
• 多用户系统中的竞争条件
• 可能被其他用户读取或篡改

就像桌面上的草稿纸：
• 可能写着重要信息
• 忘记收拾就离开了
• 别人路过能看到内容
• 需要及时销毁或锁起来
```

### 7.2 /tmp目录权限管理


**📁 /tmp目录特殊权限设置**
```bash
# 查看/tmp目录权限
ls -ld /tmp
# 输出：drwxrwxrwt 10 root root 4096 Sep 14 15:30 /tmp
#                ↑ 注意最后的't'，这是sticky bit

# /tmp目录权限的含义：
# - 所有用户都可以创建文件（必要）
# - 但只能删除自己创建的文件（安全）
# - sticky bit防止用户互相删除临时文件
```

**🛡️ 安全的临时文件创建**
```bash
# 创建安全的临时文件
temp_file=$(mktemp)
echo "这是临时数据" > $temp_file

# 查看创建的临时文件权限
ls -l $temp_file
# 输出：-rw------- 1 user user 13 Sep 14 15:30 /tmp/tmp.XXXXXX
#       ↑ 注意权限是600，只有创建者能访问

# 使用完毕后立即删除
rm $temp_file

# 批量创建临时目录
temp_dir=$(mktemp -d)
chmod 700 $temp_dir  # 确保目录权限安全
echo "临时目录: $temp_dir"
```

### 7.3 应用程序临时文件管理


**📝 应用临时文件权限配置**
```bash
# 为特定应用创建独立的临时目录
APP_NAME="myapp"
APP_TMP_DIR="/tmp/$APP_NAME"
APP_USER="myapp"

# 创建应用专用临时目录
sudo mkdir -p $APP_TMP_DIR
sudo chown $APP_USER:$APP_USER $APP_TMP_DIR
sudo chmod 700 $APP_TMP_DIR

# 设置临时目录清理任务
cat > /etc/systemd/system/cleanup-myapp-tmp.service << 'EOF'
[Unit]
Description=清理myapp临时文件
After=multi-user.target

[Service]
Type=oneshot
ExecStart=/usr/bin/find /tmp/myapp -type f -mtime +1 -delete
User=root

[Install]
WantedBy=multi-user.target
EOF

# 创建定时器
cat > /etc/systemd/system/cleanup-myapp-tmp.timer << 'EOF'
[Unit]
Description=每小时清理myapp临时文件
Requires=cleanup-myapp-tmp.service

[Timer]
OnCalendar=hourly
Persistent=true

[Install]
WantedBy=timers.target
EOF

# 启用清理任务
sudo systemctl enable cleanup-myapp-tmp.timer
sudo systemctl start cleanup-myapp-tmp.timer
```

### 7.4 临时文件清理脚本


**🧹 临时文件安全清理脚本**
```bash
#!/bin/bash
# 临时文件安全清理脚本

echo "🧹 开始清理临时文件..."

# 清理/tmp目录中的过期文件（保留3天）
echo "📁 清理/tmp目录过期文件..."
find /tmp -type f -mtime +3 -user $(whoami) -delete 2>/dev/null
find /tmp -type d -empty -mtime +3 -user $(whoami) -rmdir 2>/dev/null

# 清理用户缓存目录
if [ -d "$HOME/.cache" ]; then
    echo "🗂️ 清理用户缓存目录..."
    find $HOME/.cache -type f -mtime +7 -delete 2>/dev/null
fi

# 清理应用程序临时文件
APPS_TMP=("/var/tmp/apache2" "/var/tmp/nginx" "/var/tmp/mysql")
for app_tmp in "${APPS_TMP[@]}"; do
    if [ -d "$app_tmp" ]; then
        echo "🔧 清理 $app_tmp..."
        find $app_tmp -type f -mtime +1 -delete 2>/dev/null
    fi
done

# 清理日志轮转产生的临时文件
echo "📋 清理日志轮转临时文件..."
find /var/log -name "*.tmp" -mtime +1 -delete 2>/dev/null

# 显示清理后的空间状态
echo "💾 当前磁盘使用情况："
df -h /tmp /var/tmp

echo "✅ 临时文件清理完成！"
```

---

## 8. 🔧 权限批量修改脚本编写技巧


### 8.1 批量权限修改的应用场景


**🔸 什么时候需要批量修改权限？**
```
常见的批量权限修改场景：
• 新服务器初始化 → 统一设置安全权限
• 系统迁移后 → 权限不一致需要修正
• 安全加固 → 批量收紧权限设置
• 应用部署 → 统一设置服务权限

就像整理办公室文件：
• 一个个整理太慢（单个修改）
• 按分类批量整理（批量修改）
• 统一的整理标准（权限规范）
• 效率高且不易遗漏（脚本化）
```

### 8.2 find命令批量权限修改


**🔍 使用find命令的权限修改技巧**
```bash
# 基本语法格式
find [路径] [条件] -exec [命令] {} \;

# 1. 批量修改目录权限为755
find /var/www -type d -exec chmod 755 {} \;

# 2. 批量修改文件权限为644  
find /var/www -type f -exec chmod 644 {} \;

# 3. 按文件扩展名修改权限
find /opt/scripts -name "*.sh" -exec chmod 755 {} \;
find /etc -name "*.conf" -exec chmod 644 {} \;

# 4. 按所有者修改权限
find /home -user olduser -exec chown newuser:newgroup {} \;

# 5. 按时间批量修改
find /tmp -mtime +7 -exec chmod 600 {} \;  # 修改7天前的文件权限
```

**⚡ 提高批量操作效率的技巧**
```bash
# 使用-exec +提高效率（一次传递多个文件）
find /var/www -type f -name "*.html" -exec chmod 644 {} +

# 使用xargs提高效率
find /var/log -name "*.log" | xargs chmod 640

# 使用-print0和xargs -0处理文件名中的空格
find /data -name "*.txt" -print0 | xargs -0 chmod 644
```

### 8.3 综合权限管理脚本


**🎯 企业级权限标准化脚本**
```bash
#!/bin/bash
# 企业级系统权限标准化脚本
# 版本: 1.0
# 作者: System Administrator

# 配置参数
WEB_ROOT="/var/www"
LOG_DIR="/var/log"  
BACKUP_DIR="/backup"
SCRIPT_DIR="/opt/scripts"
CONFIG_DIR="/etc"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'  
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"  
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查是否为root用户
check_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "请使用root用户运行此脚本"
        exit 1
    fi
}

# Web目录权限标准化
setup_web_permissions() {
    log_info "配置Web目录权限..."
    
    if [ -d "$WEB_ROOT" ]; then
        # 设置所有者
        chown -R www-data:www-data $WEB_ROOT
        
        # 设置目录权限
        find $WEB_ROOT -type d -exec chmod 755 {} +
        
        # 设置文件权限
        find $WEB_ROOT -type f -exec chmod 644 {} +
        
        # 特殊权限设置
        if [ -d "$WEB_ROOT/uploads" ]; then
            chmod 775 $WEB_ROOT/uploads
            log_info "设置uploads目录权限为775"
        fi
        
        if [ -d "$WEB_ROOT/cache" ]; then
            chmod 777 $WEB_ROOT/cache
            log_warn "cache目录设置为777，请确认安全性"
        fi
        
        log_info "Web目录权限设置完成"
    else
        log_warn "Web目录不存在: $WEB_ROOT"
    fi
}

# 日志目录权限标准化
setup_log_permissions() {
    log_info "配置日志目录权限..."
    
    if [ -d "$LOG_DIR" ]; then
        # 系统日志权限
        find $LOG_DIR -name "syslog*" -exec chmod 640 {} + 2>/dev/null
        find $LOG_DIR -name "auth.log*" -exec chmod 600 {} + 2>/dev/null
        find $LOG_DIR -name "*.log" -exec chmod 644 {} + 2>/dev/null
        
        # 设置所有者
        chown -R root:adm $LOG_DIR/*.log 2>/dev/null
        
        log_info "日志目录权限设置完成"
    else
        log_warn "日志目录不存在: $LOG_DIR"
    fi
}

# 备份目录权限标准化  
setup_backup_permissions() {
    log_info "配置备份目录权限..."
    
    if [ -d "$BACKUP_DIR" ]; then
        # 设置严格的备份目录权限
        chmod 700 $BACKUP_DIR
        chown root:root $BACKUP_DIR
        
        # 设置备份文件权限
        find $BACKUP_DIR -type f -exec chmod 600 {} +
        find $BACKUP_DIR -type d -exec chmod 700 {} +
        
        log_info "备份目录权限设置完成"
    else
        log_warn "备份目录不存在: $BACKUP_DIR"
    fi
}

# 脚本目录权限标准化
setup_script_permissions() {
    log_info "配置脚本目录权限..."
    
    if [ -d "$SCRIPT_DIR" ]; then
        # Shell脚本权限
        find $SCRIPT_DIR -name "*.sh" -exec chmod 755 {} +
        
        # Python脚本权限  
        find $SCRIPT_DIR -name "*.py" -exec chmod 755 {} +
        
        # 系统管理脚本更严格权限
        find $SCRIPT_DIR -name "system-*" -exec chmod 700 {} + 2>/dev/null
        find $SCRIPT_DIR -name "*admin*" -exec chmod 700 {} + 2>/dev/null
        
        # 设置所有者
        chown -R root:root $SCRIPT_DIR
        
        log_info "脚本目录权限设置完成"
    else
        log_warn "脚本目录不存在: $SCRIPT_DIR"  
    fi
}

# 系统配置文件权限检查
check_system_config_permissions() {
    log_info "检查系统配置文件权限..."
    
    # 关键配置文件列表
    config_files=(
        "/etc/passwd:644"
        "/etc/shadow:640"
        "/etc/group:644"
        "/etc/ssh/sshd_config:600"
        "/etc/sudoers:440"
    )
    
    for file_perm in "${config_files[@]}"; do
        file=$(echo $file_perm | cut -d: -f1)
        expected_perm=$(echo $file_perm | cut -d: -f2)
        
        if [ -f "$file" ]; then
            current_perm=$(stat -c "%a" "$file")
            if [ "$current_perm" != "$expected_perm" ]; then
                log_warn "$file 权限异常: 当前($current_perm) 期望($expected_perm)"
                chmod $expected_perm $file
                log_info "已修正 $file 权限为 $expected_perm"
            fi
        fi
    done
}

# 生成权限报告
generate_permission_report() {
    log_info "生成权限检查报告..."
    
    report_file="/tmp/permission_report_$(date +%Y%m%d_%H%M%S).txt"
    
    {
        echo "系统权限检查报告"
        echo "生成时间: $(date)"
        echo "===================="
        echo ""
        
        echo "Web目录权限状态:"
        if [ -d "$WEB_ROOT" ]; then
            ls -la $WEB_ROOT | head -10
        fi
        echo ""
        
        echo "关键系统文件权限:"
        ls -l /etc/passwd /etc/shadow /etc/group 2>/dev/null
        echo ""
        
        echo "脚本目录权限:"
        if [ -d "$SCRIPT_DIR" ]; then
            ls -la $SCRIPT_DIR | head -5
        fi
        
    } > $report_file
    
    log_info "权限报告已生成: $report_file"
}

# 主函数
main() {
    log_info "开始系统权限标准化..."
    
    # 检查root权限
    check_root
    
    # 执行权限设置
    setup_web_permissions
    setup_log_permissions  
    setup_backup_permissions
    setup_script_permissions
    check_system_config_permissions
    
    # 生成报告
    generate_permission_report
    
    log_info "✅ 系统权限标准化完成！"
}

# 脚本帮助信息
show_help() {
    echo "用法: $0 [选项]"
    echo ""
    echo "选项:"
    echo "  -h, --help     显示帮助信息"
    echo "  -w, --web      仅配置Web目录权限"
    echo "  -l, --log      仅配置日志目录权限"  
    echo "  -b, --backup   仅配置备份目录权限"
    echo "  -s, --script   仅配置脚本目录权限"
    echo "  -c, --check    仅检查系统配置文件权限"
    echo "  -r, --report   仅生成权限报告"
    echo ""
    echo "示例:"
    echo "  $0              # 执行完整权限标准化"
    echo "  $0 -w           # 仅配置Web目录权限"
    echo "  $0 -c -r        # 检查配置文件并生成报告"
}

# 参数处理
case "$1" in
    -h|--help)
        show_help
        exit 0
        ;;
    -w|--web)
        check_root
        setup_web_permissions
        ;;
    -l|--log)
        check_root
        setup_log_permissions
        ;;
    -b|--backup)
        check_root
        setup_backup_permissions
        ;;
    -s|--script)
        check_root  
        setup_script_permissions
        ;;
    -c|--check)
        check_root
        check_system_config_permissions
        ;;
    -r|--report)
        generate_permission_report
        ;;
    "")
        main
        ;;
    *)
        log_error "未知参数: $1"
        show_help
        exit 1
        ;;
esac
```

### 8.4 权限修改验证脚本


**✅ 权限设置验证脚本**
```bash
#!/bin/bash
# 权限设置验证脚本

echo "🔍 开始验证权限设置..."

# 验证函数
verify_permission() {
    local path=$1
    local expected_perm=$2
    local description=$3
    
    if [ -e "$path" ]; then
        current_perm=$(stat -c "%a" "$path" 2>/dev/null)
        if [ "$current_perm" = "$expected_perm" ]; then
            echo "✅ $description: $path ($current_perm)"
            return 0
        else
            echo "❌ $description: $path 权限错误 (当前:$current_perm 期望:$expected_perm)"
            return 1
        fi
    else
        echo "⚠️  $description: $path 不存在"
        return 1
    fi
}

# 验证计数
passed=0
failed=0

# Web目录验证
echo ""
echo "🌐 验证Web目录权限..."
if verify_permission "/var/www" "755" "Web根目录"; then ((passed++)); else ((failed++)); fi

# 系统配置文件验证
echo ""  
echo "⚙️ 验证系统配置文件权限..."
if verify_permission "/etc/passwd" "644" "用户信息文件"; then ((passed++)); else ((failed++)); fi
if verify_permission "/etc/shadow" "640" "密码文件"; then ((passed++)); else ((failed++)); fi
if verify_permission "/etc/ssh/sshd_config" "600" "SSH配置文件"; then ((passed++)); else ((failed++)); fi

# 备份目录验证
echo ""
echo "💾 验证备份目录权限..."
if verify_permission "/backup" "700" "备份根目录"; then ((passed++)); else ((failed++)); fi

# 显示验证结果
echo ""
echo "📊 验证结果统计:"
echo "✅ 通过: $passed 项"
echo "❌ 失败: $failed 项"

if [ $failed -eq 0 ]; then
    echo "🎉 所有权限验证通过！"
    exit 0
else
    echo "⚠️  发现 $failed 项权限问题，请检查修复"
    exit 1
fi
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 权限修改实战原则：安全性优先，功能性兼顾
🔸 Web目录配置：根目录755，文件644，上传目录775，配置目录700
🔸 日志文件权限：系统日志640，错误日志600，应用日志644
🔸 脚本执行权限：系统脚本700，团队脚本750，通用脚本755
🔸 共享目录管理：SGID位继承组权限，Sticky位防止误删
🔸 系统配置保护：密码文件640，配置文件600-644，密钥文件600
🔸 备份文件安全：严格权限600-700，加密存储，定期清理
🔸 临时文件管理：安全创建mktemp，及时清理，权限控制
```

### 9.2 关键理解要点


**🔹 权限设置的平衡艺术**
```
安全性 vs 可用性：
• 权限过严 → 系统无法正常工作
• 权限过松 → 存在安全风险
• 最佳实践 → 最小权限原则

就像给家人分配钥匙：
• 每个人只给必需的钥匙
• 重要房间钥匙限制更严
• 定期检查和更换钥匙
```

**🔹 特殊权限位的作用**
```
SGID (Set Group ID)：
• 让新创建的文件继承目录的组
• 解决团队协作中的权限问题
• 就像团队项目自动归属团队

Sticky Bit：
• 防止用户删除他人文件
• 在共享目录中特别重要  
• 就像"只能删除自己的垃圾"规则
```

**🔹 批量操作的重要性**
```
为什么需要批量权限管理？
• 手动修改效率低且易出错
• 标准化配置确保一致性
• 脚本化操作可以重复执行
• 便于权限审计和验证

批量操作的基本思路：
• 先分析需求和标准
• 编写脚本自动化执行
• 验证结果确保正确
• 记录操作便于回溯
```

### 9.3 实际应用指导


**🎯 权限配置最佳实践**
```
Web服务器权限配置：
1. 服务运行用户权限最小化
2. 静态文件只读，动态文件按需
3. 上传目录严格控制文件类型
4. 配置文件与网页文件分离

系统安全加固：
1. 定期审计文件权限
2. 清理不必要的权限设置  
3. 监控敏感文件权限变化
4. 建立权限变更记录

运维自动化：
1. 编写标准化权限脚本
2. 集成到部署流程中
3. 定期执行权限检查
4. 异常情况及时告警
```

**🛠️ 常用权限管理命令速查**
```bash
# 权限查看
ls -l file                    # 查看文件权限
stat -c "%a %n" file          # 数字格式显示权限
getfacl file                  # 查看ACL权限

# 权限修改
chmod 644 file                # 设置文件权限
chmod u+x file                # 给所有者添加执行权限
chmod g-w file                # 移除组写权限
chown user:group file         # 修改所有者

# 批量操作
find . -type f -exec chmod 644 {} +     # 批量修改文件权限
find . -type d -exec chmod 755 {} +     # 批量修改目录权限
find . -name "*.sh" -exec chmod +x {} + # 给脚本添加执行权限

# 特殊权限
chmod g+s dir                 # 设置SGID
chmod +t dir                  # 设置Sticky Bit
chmod 2755 dir                # 数字方式设置SGID
```

### 9.4 故障排查指南


**🔍 权限问题排查思路**
```
常见权限问题现象：
❌ "Permission denied" 错误
❌ Web服务无法启动
❌ 用户无法访问共享文件
❌ 脚本无法执行

排查步骤：
1. 确认当前用户身份：whoami
2. 查看文件权限：ls -l
3. 检查文件所有者：stat
4. 验证用户组成员：groups
5. 测试权限设置：sudo -u user command

解决方案：
• 权限不足 → 适当放宽权限
• 所有者错误 → 修改文件所有者
• 组权限问题 → 调整用户组设置
• 特殊权限 → 设置SGID或Sticky位
```

**📝 权限管理检查清单**
```
🔲 Web目录权限配置正确
🔲 系统配置文件权限安全
🔲 日志文件权限符合规范
🔲 脚本文件具有执行权限
🔲 共享目录支持多用户协作
🔲 备份文件权限严格控制
🔲 临时文件定期清理
🔲 权限变更有记录可查
```

**核心记忆要点**：
- Web配置遵循最小权限原则
- 共享目录善用SGID和Sticky位
- 敏感文件权限从严控制
- 批量操作脚本化自动化
- 定期检查验证权限设置
- 权限问题系统性排查解决