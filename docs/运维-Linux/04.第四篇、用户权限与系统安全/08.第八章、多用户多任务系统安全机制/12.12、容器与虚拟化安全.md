---
title: 12、容器与虚拟化安全
---
## 📚 目录

1. [容器隔离机制](#1-容器隔离机制)
2. [命名空间安全边界](#2-命名空间安全边界)
3. [cgroups资源控制安全](#3-cgroups资源控制安全)
4. [容器逃逸防护](#4-容器逃逸防护)
5. [虚拟化安全模型](#5-虚拟化安全模型)
6. [容器镜像安全扫描](#6-容器镜像安全扫描)
7. [容器运行时安全](#7-容器运行时安全)
8. [多租户环境隔离](#8-多租户环境隔离)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 容器隔离机制


### 1.1 什么是容器隔离


**通俗理解**：
容器隔离就像公寓楼里的各个房间 - 每个房间（容器）都有自己的空间，住户之间不会互相干扰，但它们共享同一栋楼（操作系统内核）的基础设施。

```
传统虚拟机 vs 容器隔离对比：

虚拟机模式（重隔离）：
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   App A     │ │   App B     │ │   App C     │
├─────────────┤ ├─────────────┤ ├─────────────┤
│  Guest OS   │ │  Guest OS   │ │  Guest OS   │
├─────────────┤ ├─────────────┤ ├─────────────┤
│  Hypervisor │ │  Hypervisor │ │  Hypervisor │
└─────────────┘ └─────────────┘ └─────────────┘
         共享物理主机操作系统

容器模式（轻隔离）：
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   App A     │ │   App B     │ │   App C     │
├─────────────┤ ├─────────────┤ ├─────────────┤
│ 容器运行时   │ │ 容器运行时   │ │ 容器运行时   │
└─────────────┘ └─────────────┘ └─────────────┘
         共享宿主机操作系统内核
```

### 1.2 容器隔离的核心技术


**三大支柱技术**：
- **Namespace（命名空间）**：视图隔离，让容器看不到其他容器
- **Cgroups（控制组）**：资源隔离，限制容器使用的资源
- **Union FS（联合文件系统）**：文件系统隔离，独立的文件层

```
隔离层次示意图：

应用层     │ 应用A    │ 应用B    │ 应用C    │
          ├──────────┼──────────┼──────────┤
视图隔离   │ PID NS   │ NET NS   │ MNT NS   │ ← Namespace
          ├──────────┼──────────┼──────────┤
资源隔离   │ CPU限制  │ 内存限制  │ IO限制   │ ← Cgroups
          ├──────────┼──────────┼──────────┤
文件隔离   │ 文件层A  │ 文件层B  │ 文件层C  │ ← Union FS
          └──────────┴──────────┴──────────┘
                    宿主机内核
```

### 1.3 隔离强度对比


| 隔离类型 | **安全级别** | **性能开销** | **启动速度** | **资源占用** |
|---------|-------------|------------|-------------|-------------|
| **物理隔离** | `最高` | `无` | `慢` | `独占` |
| **虚拟机** | `高` | `高` | `慢` | `大` |
| **容器** | `中等` | `低` | `快` | `小` |
| **进程** | `低` | `最低` | `最快` | `最小` |

---

## 2. 🏷️ 命名空间安全边界


### 2.1 Linux命名空间详解


**命名空间的本质**：
想象一下戴上VR眼镜，你看到的是虚拟世界，看不到真实世界的其他部分。命名空间就是给每个容器戴上"专属眼镜"，让它只看到属于自己的那部分系统资源。

**六大核心命名空间**：

```
┌─ PID Namespace ──────────────────────────────────┐
│ 进程ID隔离：容器内进程从PID 1开始编号              │
│ 宿主机：init(1) -> bash(2345) -> docker(3456)    │
│ 容器内：app(1) -> nginx(2) -> mysql(3)           │
└─────────────────────────────────────────────────┘

┌─ Network Namespace ──────────────────────────────┐
│ 网络隔离：独立的网络栈                             │
│ 宿主机：eth0(192.168.1.100)                     │
│ 容器A：eth0(172.17.0.2)                         │
│ 容器B：eth0(172.17.0.3)                         │
└─────────────────────────────────────────────────┘

┌─ Mount Namespace ────────────────────────────────┐
│ 文件系统隔离：独立的挂载点                          │
│ 宿主机：/home, /var, /etc                        │
│ 容器：/app, /data, /config                       │
└─────────────────────────────────────────────────┘
```

### 2.2 命名空间安全检查


**实用命令示例**：

```bash
# 查看当前进程的命名空间
ls -la /proc/self/ns/
# 输出示例：
# lrwxrwxrwx 1 root root 0 Jan 15 10:30 pid -> pid:[4026531836]
# lrwxrwxrwx 1 root root 0 Jan 15 10:30 net -> net:[4026531992]

# 查看容器进程的命名空间
docker exec mycontainer ls -la /proc/1/ns/

# 比较不同容器的命名空间ID
docker exec container1 readlink /proc/1/ns/pid
docker exec container2 readlink /proc/1/ns/pid
```

### 2.3 命名空间安全边界威胁


**常见安全风险**：

```
🔸 权限提升攻击
风险：通过特权容器或不当配置突破命名空间边界
防护：避免使用--privileged参数，最小权限原则

🔸 共享命名空间风险
风险：多个容器共享同一命名空间增加攻击面
防护：为每个应用使用独立命名空间

🔸 命名空间泄露
风险：敏感信息通过共享命名空间泄露
防护：严格控制命名空间共享范围
```

**安全配置示例**：
```bash
# 安全的容器启动配置
docker run -d \
  --name secure-app \
  --user 1000:1000 \              # 非root用户运行
  --read-only \                   # 只读文件系统
  --tmpfs /tmp \                  # 临时文件系统
  --no-new-privileges \           # 禁止获取新权限
  nginx:alpine

# 危险配置（避免使用）
docker run --privileged \          # 特权模式
  --net=host \                     # 共享宿主机网络
  --pid=host \                     # 共享宿主机进程空间
  myapp
```

---

## 3. ⚙️ cgroups资源控制安全


### 3.1 cgroups工作原理


**通俗解释**：
cgroups就像小区的物业管理 - 每户人家（容器）分配固定的水电气配额，超过限额就会被限制使用，防止某一户过度消耗影响整个小区的正常运行。

```
Cgroups资源控制结构：

                    Root Cgroup
                         │
           ┌─────────────┼─────────────┐
           │             │             │
      Container A   Container B   Container C
      CPU: 50%      CPU: 30%      CPU: 20%
      MEM: 1GB      MEM: 512MB    MEM: 2GB
      IO: 100MB/s   IO: 50MB/s    IO: 200MB/s
```

### 3.2 主要资源控制类型


**CPU控制**：
```bash
# CPU使用率限制（25%）
echo "25000" > /sys/fs/cgroup/cpu/mycontainer/cpu.cfs_quota_us
echo "100000" > /sys/fs/cgroup/cpu/mycontainer/cpu.cfs_period_us

# CPU核心绑定（只使用CPU 0和1）
echo "0-1" > /sys/fs/cgroup/cpuset/mycontainer/cpuset.cpus

# Docker方式设置
docker run -d --cpus="1.5" --cpuset-cpus="0,1" nginx
```

**内存控制**：
```bash
# 内存使用限制（512MB）
echo "536870912" > /sys/fs/cgroup/memory/mycontainer/memory.limit_in_bytes

# 启用内存交换限制
echo "1073741824" > /sys/fs/cgroup/memory/mycontainer/memory.memsw.limit_in_bytes

# Docker方式设置
docker run -d -m 512m --oom-kill-disable=false nginx
```

**IO控制**：
```bash
# 磁盘读写速度限制（10MB/s）
echo "8:0 10485760" > /sys/fs/cgroup/blkio/mycontainer/blkio.throttle.read_bps_device
echo "8:0 10485760" > /sys/fs/cgroup/blkio/mycontainer/blkio.throttle.write_bps_device

# Docker方式设置
docker run -d --device-read-bps /dev/sda:10mb nginx
```

### 3.3 cgroups安全防护


**资源耗尽攻击防护**：

```
🔸 Fork炸弹防护
问题：恶意进程无限创建子进程耗尽系统资源
防护：限制进程数量和内存使用

🔸 CPU资源占用防护  
问题：恶意程序占用大量CPU导致系统卡顿
防护：设置CPU使用上限和优先级

🔸 内存泄露防护
问题：程序内存泄露导致系统内存耗尽
防护：设置内存硬限制和OOM killer
```

**安全配置最佳实践**：
```bash
# 创建安全的cgroup配置
docker run -d \
  --memory=512m \                 # 内存限制
  --memory-swap=512m \            # 禁用swap
  --cpus="1.0" \                  # CPU限制
  --pids-limit=100 \              # 进程数限制
  --ulimit nofile=1024:1024 \     # 文件描述符限制
  --read-only \                   # 只读文件系统
  myapp
```

---

## 4. 🚨 容器逃逸防护


### 4.1 什么是容器逃逸


**通俗理解**：
容器逃逸就像囚犯越狱 - 原本被关在"容器牢房"里的程序，通过各种手段突破了隔离边界，获得了宿主机的控制权。

```
容器逃逸示意图：

正常情况：
┌─────────────────┐
│   容器应用       │ ← 被限制在容器内
├─────────────────┤
│  容器运行时      │
├─────────────────┤
│   宿主机内核     │ ← 无法直接访问
└─────────────────┘

逃逸后：
┌─────────────────┐
│   恶意程序       │ ← 获得宿主机权限
├─ ─ ─ ─ ─ ─ ─ ─ ─┤   (虚线表示边界被突破)
│  容器运行时      │
├─────────────────┤
│   宿主机内核     │ ← 可以直接操作
└─────────────────┘
```

### 4.2 常见逃逸攻击方式


**内核漏洞利用**：
```bash
# 检查内核版本和已知漏洞
uname -r
# 输出：5.4.0-74-generic

# 检查容器特权模式（危险配置）
docker inspect container_name | grep Privileged
# "Privileged": false  ← 安全
# "Privileged": true   ← 危险！
```

**不安全的挂载点**：
```bash
# 危险的挂载配置
docker run -v /:/host ubuntu  # 挂载整个根文件系统
docker run -v /var/run/docker.sock:/var/run/docker.sock ubuntu  # 挂载Docker socket

# 安全的挂载配置
docker run -v /app/data:/data:ro ubuntu  # 只读挂载指定目录
```

**特权容器风险**：
```bash
# 检测特权容器
docker ps --format "table {{.Names}}\t{{.Status}}" | while read name status; do
    if [ "$name" != "NAMES" ]; then
        privileged=$(docker inspect "$name" | grep '"Privileged":' | cut -d: -f2 | tr -d ' ",')
        echo "$name: Privileged=$privileged"
    fi
done
```

### 4.3 逃逸防护措施


**系统加固配置**：
```bash
# 启用AppArmor/SELinux
systemctl status apparmor
# 或
getenforce  # SELinux状态检查

# 配置安全的容器运行参数
docker run -d \
  --security-opt apparmor:docker-default \     # 启用AppArmor
  --security-opt no-new-privileges \           # 禁止提权
  --cap-drop ALL \                             # 移除所有能力
  --cap-add NET_BIND_SERVICE \                 # 只添加必需能力
  --user 1000:1000 \                          # 非root用户
  nginx
```

**运行时安全监控**：
```bash
# 监控容器行为
docker exec container_name ps aux          # 检查运行的进程
docker exec container_name netstat -tlnp   # 检查网络连接
docker logs container_name                  # 查看日志异常

# 资源使用监控
docker stats container_name                 # 实时资源使用
```

---

## 5. 🛡️ 虚拟化安全模型


### 5.1 虚拟化层级安全


**虚拟化安全架构**：
```
┌─────────────────────────────────────────┐
│           虚拟机 A    虚拟机 B           │ ← 客户机层安全
├─────────────────────────────────────────┤
│              Hypervisor                 │ ← 虚拟化层安全  
├─────────────────────────────────────────┤
│             宿主机操作系统                │ ← 宿主机层安全
├─────────────────────────────────────────┤
│               物理硬件                  │ ← 硬件层安全
└─────────────────────────────────────────┘
```

### 5.2 Type-1 vs Type-2 虚拟化安全


**Type-1虚拟化（裸机型）**：
```
安全特点：
✅ 直接运行在硬件上，攻击面小
✅ Hypervisor精简，漏洞相对较少  
✅ 虚拟机间隔离性更好
❌ 管理复杂度较高

代表产品：VMware ESXi、Xen、Hyper-V
```

**Type-2虚拟化（托管型）**：
```
安全特点：
✅ 管理相对简单
❌ 依赖宿主机操作系统，攻击面大
❌ 宿主机系统漏洞影响虚拟化安全
❌ 性能开销较大

代表产品：VMware Workstation、VirtualBox
```

### 5.3 虚拟化安全最佳实践


**Hypervisor安全加固**：
```bash
# KVM虚拟化安全配置示例
virsh edit vm-name
# 添加安全配置：
<domain type='kvm'>
  <seclabel type='dynamic' model='apparmor'>
    <label>libvirt-uuid</label>
  </seclabel>
  
  # 禁用不必要的设备
  <controller type='usb' index='0' model='none'/>
  
  # 内存安全
  <memory mode='strict' nodeset='0'/>
</domain>
```

**虚拟机网络安全**：
```bash
# 创建隔离的虚拟网络
virsh net-define isolated-network.xml
virsh net-start isolated-network

# isolated-network.xml 内容：
<network>
  <name>isolated</name>
  <bridge name='virbr1' stp='on' delay='0'/>
  <domain name='isolated'/>
  <ip address='192.168.100.1' netmask='255.255.255.0'>
    <dhcp>
      <range start='192.168.100.2' end='192.168.100.254'/>
    </dhcp>
  </ip>
</network>
```

---

## 6. 🔍 容器镜像安全扫描


### 6.1 镜像安全威胁


**常见安全问题**：
```
🔸 基础镜像漏洞
问题：使用过期或有漏洞的基础镜像
影响：继承基础镜像的所有安全问题

🔸 恶意代码植入
问题：第三方镜像包含恶意代码或后门
影响：数据泄露、系统被控制

🔸 敏感信息泄露
问题：镜像中包含密码、密钥等敏感信息
影响：认证信息被窃取

🔸 权限配置不当
问题：以root权限运行或权限过大
影响：提高攻击成功率和危害程度
```

### 6.2 镜像安全扫描工具


**Docker原生扫描**：
```bash
# Docker Hub漏洞扫描
docker scan nginx:latest

# 本地镜像扫描
docker scan myapp:v1.0

# 输出示例：
# Package manager:   apk
# Total vulnerabilities:   5
# Critical:   1
# High:      2  
# Medium:    1
# Low:       1
```

**第三方扫描工具**：
```bash
# 使用Trivy扫描
trivy image nginx:1.20
trivy image --severity HIGH,CRITICAL myapp:latest

# 使用Clair扫描
docker run -d --name clair-db arminc/clair-db:latest
docker run -p 6060:6060 -d --name clair --link clair-db:postgres arminc/clair-local-scan
```

### 6.3 安全镜像构建实践


**Dockerfile安全最佳实践**：
```dockerfile
# 使用官方基础镜像
FROM alpine:3.15

# 创建非特权用户
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup

# 安装必要软件并清理缓存
RUN apk add --no-cache nginx && \
    rm -rf /var/cache/apk/*

# 复制应用文件并设置权限
COPY --chown=appuser:appgroup app/ /app/

# 移除不必要的软件包
RUN apk del curl wget

# 使用非root用户运行
USER appuser

# 只暴露必要端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s \
  CMD curl -f http://localhost:8080/health || exit 1

CMD ["nginx", "-g", "daemon off;"]
```

**镜像安全检查清单**：
```bash
# 检查镜像层信息
docker history myapp:latest

# 检查镜像配置
docker inspect myapp:latest | jq '.Config'

# 检查用户权限
docker run --rm myapp:latest whoami
docker run --rm myapp:latest id

# 检查文件权限
docker run --rm myapp:latest ls -la /
```

---

## 7. 🔒 容器运行时安全


### 7.1 运行时安全威胁


**运行时攻击向量**：
```
┌─ 网络攻击 ────────────────────────────────────┐
│ • 网络扫描和端口探测                            │
│ • 中间人攻击                                  │
│ • DDoS攻击                                   │
└─────────────────────────────────────────────┘

┌─ 应用层攻击 ──────────────────────────────────┐
│ • SQL注入                                    │
│ • XSS跨站脚本                                │
│ • 文件上传漏洞                                │
└─────────────────────────────────────────────┘

┌─ 运行时逃逸 ──────────────────────────────────┐
│ • 特权容器滥用                                │
│ • 内核漏洞利用                                │
│ • 共享资源滥用                                │
└─────────────────────────────────────────────┘
```

### 7.2 运行时安全监控


**行为监控实现**：
```bash
# 使用Falco进行运行时监控
docker run -it --rm --name falco \
  -v /var/run/docker.sock:/host/var/run/docker.sock \
  -v /dev:/host/dev \
  -v /proc:/host/proc:ro \
  -v /boot:/host/boot:ro \
  -v /lib/modules:/host/lib/modules:ro \
  -v /usr:/host/usr:ro \
  --privileged \
  falcosecurity/falco

# 自定义规则示例（falco_rules.local.yaml）
- rule: Detect Shell in Container
  desc: Notice shell activity within a container
  condition: >
    spawned_process and container and
    (proc.name in (bash, sh, zsh))
  output: >
    Shell spawned in container
    (user=%user.name container=%container.name image=%container.image)
  priority: WARNING
```

**网络流量监控**：
```bash
# 监控容器网络连接
netstat -tulpn | grep docker
ss -tuln | grep docker

# 使用tcpdump监控特定容器
docker exec container_name tcpdump -i eth0 -n

# 分析容器网络流量
docker exec container_name iftop -i eth0
```

### 7.3 零信任安全模型


**零信任原则应用**：
```
传统安全模型：
外网（不信任） → 防火墙 → 内网（信任）

零信任模型：
所有流量都不信任 → 身份验证 → 授权访问 → 持续监控

容器零信任实现：
┌─ 身份认证 ─┐   ┌─ 网络分段 ─┐   ┌─ 持续监控 ─┐
│ • mTLS    │ → │ • 微分段   │ → │ • 行为分析  │
│ • JWT     │   │ • 网络策略 │   │ • 异常检测  │
└───────────┘   └───────────┘   └───────────┘
```

**实施示例**：
```yaml
# Kubernetes NetworkPolicy示例
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: web-app-netpol
spec:
  podSelector:
    matchLabels:
      app: web
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database
    ports:
    - protocol: TCP
      port: 3306
```

---

## 8. 🏢 多租户环境隔离


### 8.1 多租户隔离挑战


**隔离需求分析**：
```
业务隔离需求：
┌─ 租户A ─┐    ┌─ 租户B ─┐    ┌─ 租户C ─┐
│ 服务1   │    │ 服务1   │    │ 服务1   │
│ 服务2   │    │ 服务2   │    │ 服务2   │
│ 数据库  │    │ 数据库  │    │ 数据库  │
└────────┘    └────────┘    └────────┘
     ↓             ↓             ↓
需要隔离：计算、存储、网络、安全策略
```

### 8.2 Kubernetes多租户隔离


**命名空间级隔离**：
```yaml
# 创建租户专用命名空间
apiVersion: v1
kind: Namespace
metadata:
  name: tenant-a
  labels:
    tenant: tenant-a
    
---
# 资源配额限制
apiVersion: v1
kind: ResourceQuota
metadata:
  name: tenant-a-quota
  namespace: tenant-a
spec:
  hard:
    requests.cpu: "4"
    requests.memory: 8Gi
    limits.cpu: "8" 
    limits.memory: 16Gi
    persistentvolumeclaims: "4"
    services: "5"
    
---
# RBAC权限控制
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tenant-a-admin
  namespace: tenant-a
subjects:
- kind: User
  name: tenant-a-user
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: admin
  apiGroup: rbac.authorization.k8s.io
```

**网络隔离策略**：
```yaml
# 租户间网络隔离
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: tenant-isolation
  namespace: tenant-a
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          tenant: tenant-a
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          tenant: tenant-a
  - to: {} # 允许访问外部服务
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
```

### 8.3 虚拟集群隔离


**vcluster实现**：
```bash
# 安装vcluster
curl -L -o vcluster "https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-linux-amd64"
chmod +x vcluster

# 创建虚拟集群
vcluster create tenant-a --namespace tenant-a

# 连接到虚拟集群
vcluster connect tenant-a --namespace tenant-a

# 在虚拟集群中部署应用
kubectl apply -f tenant-a-app.yaml
```

**隔离效果验证**：
```bash
# 检查资源隔离
kubectl --namespace=tenant-a get all
kubectl --namespace=tenant-b get all

# 检查网络隔离
kubectl --namespace=tenant-a exec -it pod-name -- ping tenant-b-service.tenant-b.svc.cluster.local

# 检查权限隔离
kubectl --namespace=tenant-a auth can-i get pods --as=tenant-a-user
kubectl --namespace=tenant-b auth can-i get pods --as=tenant-a-user
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 容器隔离：基于Namespace、Cgroups、Union FS的轻量级隔离
🔸 命名空间：提供进程、网络、文件系统等维度的视图隔离
🔸 资源控制：通过Cgroups限制CPU、内存、IO等资源使用
🔸 容器逃逸：突破容器隔离边界获取宿主机权限的攻击
🔸 镜像安全：从构建到运行全生命周期的安全管控
🔸 运行时防护：持续监控和防护容器运行时的安全威胁
🔸 多租户隔离：在共享环境中实现不同租户间的安全隔离
```

### 9.2 关键理解要点


**🔹 安全边界的本质**
```
物理隔离 > 虚拟化隔离 > 容器隔离 > 进程隔离
安全强度递减，但性能和灵活性递增
选择隔离方案需要平衡安全性和效率
```

**🔹 纵深防御策略**
```
镜像安全：源头控制，安全基础
配置安全：运行时控制，减少攻击面  
监控防护：持续检测，及时响应
访问控制：最小权限，精确授权
```

**🔹 多租户隔离层次**
```
硬隔离：虚拟机、物理机
软隔离：命名空间、cgroup
网络隔离：VLAN、NetworkPolicy
数据隔离：加密、访问控制
```

### 9.3 实际应用指导


**容器安全检查清单**：
- ✅ 使用官方或可信的基础镜像
- ✅ 定期扫描镜像漏洞并及时更新
- ✅ 以非root用户运行容器应用
- ✅ 限制容器资源使用（CPU、内存、存储）
- ✅ 配置适当的安全上下文和权限
- ✅ 启用运行时安全监控
- ✅ 实施网络分段和访问控制
- ✅ 定期审计和更新安全策略

**安全配置最佳实践**：
```bash
# 安全的容器运行命令模板
docker run -d \
  --name secure-app \
  --user 1000:1000 \                    # 非root用户
  --read-only \                         # 只读文件系统  
  --tmpfs /tmp:rw,size=100m \          # 临时文件系统
  --memory=512m \                       # 内存限制
  --cpus="1.0" \                        # CPU限制
  --pids-limit=100 \                    # 进程数限制
  --cap-drop=ALL \                      # 移除所有权限
  --cap-add=NET_BIND_SERVICE \          # 只添加必需权限
  --security-opt=no-new-privileges \    # 禁止提权
  --network=custom-network \            # 自定义网络
  myapp:latest
```

**核心安全原则**：
- **最小权限原则**：只给予完成任务所需的最小权限
- **纵深防御**：多层安全控制，单点失效不影响整体安全
- **持续监控**：实时检测异常行为和安全威胁
- **定期更新**：及时修补已知漏洞和安全问题

**记忆要点**：
- 容器安全是系统性工程，需要从镜像构建到运行全生命周期考虑
- 隔离不是绝对的，需要配合其他安全措施形成完整防护体系
- 多租户环境的安全复杂度显著增加，需要更严格的隔离和监控
- 安全配置要在安全性和易用性之间找到平衡点