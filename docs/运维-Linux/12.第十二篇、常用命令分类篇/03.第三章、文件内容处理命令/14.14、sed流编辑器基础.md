---
title: 14、sed流编辑器基础
---
## 📚 目录

1. [sed流编辑器基础概念](#1-sed流编辑器基础概念)
2. [sed基本工作模式](#2-sed基本工作模式)
3. [替换删除插入操作](#3-替换删除插入操作)
4. [地址模式匹配](#4-地址模式匹配)
5. [正则表达式应用](#5-正则表达式应用)
6. [多行模式处理](#6-多行模式处理)
7. [脚本文件使用](#7-脚本文件使用)
8. [实时文本处理技巧](#8-实时文本处理技巧)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 sed流编辑器基础概念


### 1.1 什么是sed


**通俗理解**：sed就像一个"文本流水线工人"，它可以接收文本输入，按照你给的指令对文本进行各种加工处理，然后输出处理结果。

```
生活比喻：
工厂流水线 → sed处理流程
原材料输入 → 文本输入
加工指令   → sed命令
处理过程   → 文本处理
成品输出   → 处理结果
```

**🔸 sed的核心特点**
- **流式处理**：一行一行地处理文本，不需要把整个文件加载到内存
- **非交互式**：不需要用户干预，按预定指令自动处理
- **原文件不变**：默认只输出处理结果，不修改原文件
- **灵活强大**：支持正则表达式，可以完成复杂的文本操作

### 1.2 sed的实际用途


**💡 日常应用场景**
- **批量替换**：把文件中所有"老地址"改成"新地址"
- **删除特定行**：删除日志文件中的空行或错误行
- **提取信息**：从配置文件中提取特定的配置项
- **格式转换**：把数据从一种格式转换成另一种格式

**📊 使用场景对比**
| 场景 | **传统方法** | **sed方法** | **优势** |
|------|-------------|-------------|----------|
| 替换文本 | `手动编辑器查找替换` | `sed 's/old/new/g'` | `批量处理，可脚本化` |
| 删除空行 | `手动删除` | `sed '/^$/d'` | `一条命令解决` |
| 提取行 | `复制粘贴` | `sed -n '5,10p'` | `精确控制范围` |

### 1.3 sed与其他工具的关系


**🔗 文本处理工具家族**
```
简单查找 → grep    (我要找到包含某个词的行)
流式编辑 → sed     (我要修改/删除/插入某些行) 
复杂处理 → awk     (我要做复杂的数据分析和处理)

实际搭配使用：
grep "ERROR" logfile | sed 's/ERROR/警告/g'
↑ 先找到错误行      ↑ 再把ERROR改为中文
```

---

## 2. ⚙️ sed基本工作模式


### 2.1 sed的工作原理


**🔄 处理流程图示**
```
输入文本
   ↓
┌─────────────────┐
│  模式空间       │ ← sed的工作区域
│ (Pattern Space) │
└─────────────────┘
   ↓
应用sed命令
   ↓
输出处理结果
```

**💡 工作过程详解**
1. **读取一行**：sed从输入中读取一行文本
2. **放入模式空间**：这行文本被放到sed的工作区域
3. **执行命令**：按顺序执行所有的sed命令
4. **输出结果**：如果没有被删除，就输出这一行
5. **继续下一行**：重复以上过程直到文件结束

### 2.2 基本命令格式


**📝 命令结构**
```bash
sed [选项] '命令' 文件名
sed [选项] -f 脚本文件 文件名
sed [选项] -e '命令1' -e '命令2' 文件名
```

**🔸 常用选项说明**
- **`-n`**：安静模式，不自动输出每一行（需要用p命令才输出）
- **`-i`**：直接修改原文件（危险操作，建议先备份）
- **`-e`**：允许多个编辑命令
- **`-f`**：从脚本文件读取命令

### 2.3 基础命令演示


**🎯 简单替换示例**
```bash
# 创建测试文件
echo -e "hello world\nwelcome to sed\nhello everyone" > test.txt

# 基本替换：把hello改为hi
sed 's/hello/hi/' test.txt
# 输出：
# hi world
# welcome to sed  
# hi everyone

# 全局替换：把所有hello都改为hi
sed 's/hello/hi/g' test.txt
```

**🔍 查看特定行**
```bash
# 只显示第2行
sed -n '2p' test.txt
# 输出：welcome to sed

# 显示第1-3行
sed -n '1,3p' test.txt
# 输出全部内容

# 显示最后一行
sed -n '$p' test.txt
# 输出：hello everyone
```

---

## 3. ✏️ 替换删除插入操作


### 3.1 替换操作详解


**🔄 替换命令格式**
```
s/查找模式/替换内容/标志
```

**标志说明**：
- **`g`**：全局替换（一行中所有匹配的都替换）
- **`数字`**：只替换第几个匹配的
- **`p`**：打印发生替换的行
- **`w 文件名`**：把替换的行写入文件

**🎯 替换操作实例**
```bash
# 准备测试数据
echo -e "apple banana apple\norange apple grape\napple pie apple" > fruits.txt

# 只替换每行第一个apple
sed 's/apple/苹果/' fruits.txt

# 替换每行所有的apple  
sed 's/apple/苹果/g' fruits.txt

# 只替换每行第二个apple
sed 's/apple/苹果/2' fruits.txt

# 替换并显示修改的行
sed 's/apple/苹果/gp' fruits.txt
```

**💡 特殊字符处理**
```bash
# 替换路径中的斜杠（使用不同分隔符）
sed 's#/old/path#/new/path#g' config.txt

# 替换包含特殊字符的内容
sed 's/\$price/\$new_price/g' data.txt

# 使用变量替换
old_word="hello"
new_word="hi"
sed "s/$old_word/$new_word/g" test.txt
```

### 3.2 删除操作


**🗑️ 删除命令**
- **`d`**：删除匹配的行
- **配合地址使用**：指定删除哪些行

**📋 删除操作示例**
```bash
# 创建测试文件
cat > sample.txt << EOF
第一行内容
第二行内容

第四行内容
# 这是注释行
第六行内容
EOF

# 删除空行
sed '/^$/d' sample.txt

# 删除注释行（以#开头）
sed '/^#/d' sample.txt

# 删除第3行
sed '3d' sample.txt

# 删除第2-4行
sed '2,4d' sample.txt

# 删除最后一行
sed '$d' sample.txt
```

### 3.3 插入和追加操作


**📝 插入追加命令**
- **`i`**：在匹配行前插入文本
- **`a`**：在匹配行后追加文本
- **`c`**：替换整行内容

**🎯 插入追加实例**
```bash
# 在第一行前插入标题
sed '1i\=== 文档标题 ===' sample.txt

# 在最后一行后追加结尾
sed '$a\=== 文档结束 ===' sample.txt

# 在包含"内容"的行后添加说明
sed '/内容/a\（这是说明文字）' sample.txt

# 替换第3行内容
sed '3c\新的第三行内容' sample.txt

# 多行插入
sed '1i\第一行插入内容\
第二行插入内容\
第三行插入内容' sample.txt
```

---

## 4. 🎯 地址模式匹配


### 4.1 地址模式概念


**💡 什么是地址模式**
地址模式就是告诉sed"对哪些行进行操作"的方式。就像给快递员一个准确地址，让他知道要送到哪里一样。

**📍 地址模式类型**
```
行号地址：1, 5, $          (对第1行、第5行、最后一行操作)
模式地址：/pattern/        (对包含pattern的行操作)
范围地址：1,5  /start/,/end/ (对指定范围的行操作)
```

### 4.2 行号地址模式


**🔢 行号地址使用**
```bash
# 测试文件
cat -n sample.txt  # 显示行号

# 对第2行操作
sed '2s/内容/CONTENT/' sample.txt

# 对第2-4行操作
sed '2,4s/行/LINE/g' sample.txt

# 对第2行到最后一行操作
sed '2,$s/内容/CONTENT/g' sample.txt

# 对偶数行操作
sed '2~2s/^/[偶数行] /' sample.txt

# 对第3行以后每隔2行操作
sed '3~2s/^/[标记] /' sample.txt
```

### 4.3 模式地址匹配


**🔍 模式匹配语法**
```bash
/正则表达式/命令
```

**🎯 模式匹配实例**
```bash
# 创建日志文件示例
cat > app.log << EOF
2024-01-15 10:00:01 INFO 系统启动
2024-01-15 10:00:05 DEBUG 加载配置文件
2024-01-15 10:00:10 ERROR 数据库连接失败
2024-01-15 10:00:15 INFO 重新连接数据库
2024-01-15 10:00:20 WARN 内存使用率较高
EOF

# 只处理包含ERROR的行
sed '/ERROR/s/ERROR/错误/' app.log

# 删除所有DEBUG行
sed '/DEBUG/d' app.log

# 在INFO行后添加说明
sed '/INFO/a\--- 信息日志 ---' app.log

# 对以2024开头的行进行处理
sed '/^2024/s/-/\//g' app.log
```

### 4.4 范围地址模式


**📏 范围模式语法**
```bash
/开始模式/,/结束模式/命令
行号1,行号2/命令
/模式/,行号/命令
```

**🎯 范围操作示例**
```bash
# 从包含INFO的行到包含ERROR的行
sed '/INFO/,/ERROR/s/^/>>> /' app.log

# 从第2行到包含WARN的行
sed '2,/WARN/s/2024/年份/' app.log

# 提取特定范围的内容
sed -n '/INFO/,/ERROR/p' app.log

# 删除范围内的所有行
sed '/DEBUG/,/WARN/d' app.log
```

**⚠️ 范围地址注意事项**
- 如果找不到结束模式，会处理到文件末尾
- 范围可以重复匹配，不是只匹配一次
- 空范围（开始结束在同一行）也会执行命令

---

## 5. 🎨 正则表达式应用


### 5.1 sed中的正则表达式


**💡 正则表达式在sed中的作用**
正则表达式让sed能够进行"模糊匹配"，就像用通配符一样，可以匹配符合某种模式的文本，而不需要精确知道内容。

**🔸 基本正则表达式符号**
| 符号 | **含义** | **示例** | **匹配内容** |
|------|---------|---------|-------------|
| `^` | `行首` | `^hello` | `以hello开头的行` |
| `$` | `行尾` | `world$` | `以world结尾的行` |
| `.` | `任意单字符` | `h.llo` | `hello, hallo等` |
| `*` | `前字符0次或多次` | `ab*c` | `ac, abc, abbc等` |
| `[]` | `字符集合` | `[0-9]` | `任意数字` |
| `[^]` | `取反字符集` | `[^a-z]` | `非小写字母` |

### 5.2 实用正则表达式模式


**📞 常用模式示例**
```bash
# 创建包含各种格式的测试文件
cat > patterns.txt << EOF
手机号：13812345678
电话：010-12345678
邮箱：user@example.com
网址：http://www.example.com
IP地址：192.168.1.100
日期：2024-01-15
空行在下面

上面有空行
EOF

# 匹配手机号（11位数字）
sed -n '/[0-9]\{11\}/p' patterns.txt

# 匹配邮箱地址
sed -n '/[a-zA-Z0-9._-]*@[a-zA-Z0-9.-]*/p' patterns.txt

# 匹配IP地址（简单模式）
sed -n '/[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}/p' patterns.txt

# 匹配日期格式 YYYY-MM-DD
sed -n '/[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}/p' patterns.txt
```

### 5.3 分组和引用


**🔄 捕获组和反向引用**
```bash
# 交换日期格式：从YYYY-MM-DD改为DD/MM/YYYY
sed 's/\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)/\3\/\2\/\1/' patterns.txt

# 在电话号码前后加括号
sed 's/\([0-9]\{3\}-[0-9]\{8\}\)/(\1)/' patterns.txt

# 提取域名（从邮箱中）
sed 's/.*@\(.*\)/域名：\1/' patterns.txt

# 给网址添加标签
sed 's/\(http:\/\/[^ ]*\)/<a href="\1">\1<\/a>/' patterns.txt
```

### 5.4 高级正则应用


**🎯 复杂模式匹配**
```bash
# 验证和格式化数据
cat > data.txt << EOF
正确格式：user001@company.com
错误格式：invalid-email
正确格式：admin@test.org
错误格式：bad@
正确格式：support@example.net
EOF

# 只保留有效的邮箱地址
sed -n '/^[a-zA-Z0-9._-]\+@[a-zA-Z0-9.-]\+\.[a-zA-Z]\{2,4\}$/p' data.txt

# 格式化邮箱显示
sed 's/^.*：\([a-zA-Z0-9._-]\+@[a-zA-Z0-9.-]\+\.[a-zA-Z]\{2,4\}\)$/邮箱地址：[\1]/' data.txt

# 屏蔽邮箱中的用户名部分
sed 's/\([a-zA-Z0-9._-]\+\)@\([a-zA-Z0-9.-]\+\)/***@\2/g' data.txt
```

---

## 6. 📄 多行模式处理


### 6.1 多行模式概念


**💡 什么是多行模式**
有时候我们需要处理的内容跨越多行，比如要把分散在两行的信息合并，或者对多行内容进行整体操作。sed提供了专门的命令来处理这种情况。

**🔗 多行处理命令**
- **`N`**：读取下一行到模式空间
- **`P`**：打印模式空间中的第一行
- **`D`**：删除模式空间中的第一行

### 6.2 多行读取和处理


**📋 基础多行操作**
```bash
# 创建多行测试文件
cat > multiline.txt << EOF
姓名：张三
年龄：25
职业：工程师

姓名：李四
年龄：30
职业：设计师

姓名：王五
年龄：28
职业：产品经理
EOF

# 将姓名和年龄合并到一行
sed '/姓名/N;s/\n/ /' multiline.txt

# 将完整的个人信息合并到一行
sed '/姓名/{N;N;s/\n/ | /g}' multiline.txt

# 删除空行和下一行
sed '/^$/{N;d}' multiline.txt
```

### 6.3 实用多行处理场景


**🔧 配置文件处理**
```bash
# 创建配置文件示例
cat > config.txt << EOF
[database]
host = localhost
port = 3306
user = admin

[server]  
port = 8080
debug = true
log_level = info
EOF

# 在每个配置段后添加分隔线
sed '/\[.*\]/{N;s/$/\n--- 配置段分隔 ---/}' config.txt

# 合并配置项到配置段标题行
sed '/\[.*\]/{:a;N;/^\[/!ba;s/\n/ | /g}' config.txt
```

**📊 数据格式转换**
```bash
# 创建CSV数据转换示例
cat > csv_data.txt << EOF
name,age,city
张三,25,北京
李四,30,上海  
王五,28,广州
EOF

# 将CSV转换为固定格式
sed '1d;s/,/ | /g;s/^/员工信息：/' csv_data.txt

# 多行合并处理
sed '/name/{N;N;N;s/name,age,city\n//;s/,/ /g;s/\n/ | /g}' csv_data.txt
```

### 6.4 高级多行技巧


**🎯 复杂多行操作**
```bash
# 处理包含续行符的文件
cat > continuation.txt << EOF
这是第一行内容 \
这是续行内容
这是完整的一行
另一个续行开始 \
续行内容继续 \
续行内容结束
EOF

# 合并所有续行
sed ':a;/\\$/{N;s/\\\n//;ba}' continuation.txt

# 在多行注释块前后添加标记
cat > code.txt << EOF
正常代码行
/*
多行注释开始
注释内容
注释结束
*/
更多代码
EOF

# 处理多行注释
sed '/\/\*/{:a;N;/\*\//!ba;s/.*/### 注释块 ###/}' code.txt
```

---

## 7. 📜 脚本文件使用


### 7.1 sed脚本基础


**💡 为什么使用脚本文件**
当sed命令变得复杂，或者需要重复使用同样的处理逻辑时，把命令写在脚本文件中会更方便管理和维护。

**📝 脚本文件格式**
```bash
# 创建sed脚本文件
cat > process.sed << 'EOF'
# 这是注释行，以#开头
s/old/new/g
/pattern/d
1i\这是插入的标题行
$a\这是追加的结尾行
EOF

# 使用脚本文件
sed -f process.sed input.txt
```

### 7.2 实用脚本示例


**🔧 日志处理脚本**
```bash
# 创建日志清理脚本
cat > log_clean.sed << 'EOF'
# 删除空行
/^$/d

# 统一时间格式
s/\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)/\1年\2月\3日/g

# 翻译日志级别
s/ERROR/错误/g
s/WARN/警告/g  
s/INFO/信息/g
s/DEBUG/调试/g

# 在错误行前添加标记
/错误/i\!!! 注意：发现错误 !!!

# 在文件开头添加处理时间
1i\=== 日志处理时间：$(date) ===
EOF
```

**📊 数据转换脚本**
```bash
# 创建数据格式化脚本
cat > format_data.sed << 'EOF'
# 删除标题行
1d

# 清理多余空格
s/ \+/ /g
s/^ //
s/ $//

# 转换分隔符
s/,/|/g

# 添加行号
=

# 格式化输出
N
s/\n/) /
s/^/第/
s/) / 条记录：/
EOF

# 使用脚本处理数据
sed -f format_data.sed data.csv
```

### 7.3 脚本中的高级功能


**🔄 标签和跳转**
```bash
# 创建包含循环的脚本
cat > loop_script.sed << 'EOF'  
# 标签定义
:start

# 如果行首不是数字，跳转到end
/^[0-9]/!bend

# 在数字前添加"编号："
s/^/编号：/

# 标签end
:end

# 继续处理下一行
bend
EOF
```

**🎯 条件处理脚本**
```bash
# 创建条件处理脚本
cat > conditional.sed << 'EOF'
# 根据内容类型进行不同处理
/^[0-9]/b number
/^[a-zA-Z]/b letter  
/^$/b empty
b other

:number
s/^/数字行：/
b end

:letter
s/^/字母行：/
b end

:empty
i\发现空行
d

:other
s/^/其他类型：/

:end
EOF
```

### 7.4 脚本文件管理技巧


**📁 脚本组织和复用**
```bash
# 创建通用脚本库目录
mkdir -p ~/.sed_scripts

# 常用清理脚本
cat > ~/.sed_scripts/clean_text.sed << 'EOF'
# 删除空行
/^$/d
# 删除注释行
/^#/d
# 清理行首尾空格
s/^[ \t]*//
s/[ \t]*$//
EOF

# 在脚本中引用其他脚本
cat > main_process.sed << 'EOF'
# 首先执行清理
r ~/.sed_scripts/clean_text.sed

# 然后执行具体处理
s/old/new/g
EOF
```

---

## 8. ⚡ 实时文本处理技巧


### 8.1 管道配合使用


**🔗 sed与其他命令配合**
```bash
# 实时日志监控和处理
tail -f /var/log/messages | sed 's/ERROR/错误/g; /错误/s/^/!!! /'

# 网络数据处理
curl -s http://api.example.com/data | sed 's/,/\n/g' | grep "value"

# 系统信息格式化
ps aux | sed '1d' | sed 's/ \+/ /g' | cut -d' ' -f1,11
```

### 8.2 批量文件处理


**📁 批量处理技巧**
```bash
# 批量处理目录中的所有文本文件
find . -name "*.txt" -exec sed -i 's/old/new/g' {} \;

# 安全的批量处理（先备份）
for file in *.txt; do
    cp "$file" "$file.bak"
    sed 's/old/new/g' "$file.bak" > "$file"
done

# 批量转换文件编码和格式
find . -name "*.log" -exec sh -c 'iconv -f gbk -t utf8 "$1" | sed "s/\r//g" > "$1.utf8"' _ {} \;
```

### 8.3 动态内容处理


**⚡ 变量和动态替换**
```bash
# 使用变量进行动态替换
old_version="1.0.0"
new_version="2.0.0"
sed "s/$old_version/$new_version/g" config.txt

# 基于日期的动态处理
today=$(date +%Y-%m-%d)
sed "s/DATE_PLACEHOLDER/$today/g" template.txt

# 环境变量替换
export APP_NAME="MyApp"
export APP_VERSION="1.2.3"
sed "s/{{APP_NAME}}/$APP_NAME/g; s/{{APP_VERSION}}/$APP_VERSION/g" app.conf
```

### 8.4 性能优化技巧


**🚀 提升处理效率**
```bash
# 对于大文件，使用更高效的命令组合
# 不好的做法：多次调用sed
sed 's/old1/new1/g' bigfile.txt | sed 's/old2/new2/g' | sed '/pattern/d'

# 好的做法：一次完成所有操作  
sed 's/old1/new1/g; s/old2/new2/g; /pattern/d' bigfile.txt

# 使用条件跳转减少不必要的处理
sed '/pattern/!d; s/old/new/g' bigfile.txt

# 对于重复处理，使用脚本文件
sed -f complex_process.sed bigfile.txt
```

**⚠️ 内存优化注意事项**
- 避免使用`N`命令处理超大文件
- 大文件处理时使用流水线而不是临时文件
- 合理使用`-n`选项减少不必要的输出

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 sed本质：流式文本编辑器，一行一行处理文本
🔸 工作模式：读取→处理→输出的循环过程
🔸 基本操作：替换(s)、删除(d)、插入(i)、追加(a)
🔸 地址模式：行号地址、模式地址、范围地址
🔸 正则表达式：增强模式匹配和文本处理能力
```

### 9.2 关键理解要点


**🔹 sed的核心思想**
```
流式处理 = 高效处理大文件的关键
非交互式 = 可以自动化和脚本化
模式空间 = sed的工作区域，理解这个概念很重要

实际价值：
- 批量处理文本文件，节省手工操作时间
- 可以处理超大文件而不占用大量内存
- 与其他命令配合，构建强大的文本处理流水线
```

**🔹 常用命令记忆**
```
替换：s/old/new/g      (substitute，全局替换)
删除：/pattern/d       (delete，删除匹配行)  
打印：-n '/pattern/p'  (print，只显示匹配行)
插入：i\text          (insert，行前插入)
追加：a\text          (append，行后追加)
```

**🔹 实用技巧要点**
```
安全原则：
- 重要文件处理前先备份
- 复杂操作先在小文件上测试
- 使用 -n 选项避免意外输出

效率原则：
- 一次处理完成多个操作
- 合理使用正则表达式
- 大文件处理考虑内存限制
```

### 9.3 实际应用价值


- **系统管理**：日志分析、配置文件批量修改、系统监控
- **数据处理**：格式转换、数据清洗、报表生成  
- **开发辅助**：代码批量重构、配置管理、部署脚本
- **文档处理**：格式统一、内容替换、版本更新

### 9.4 学习进阶建议


```
🎯 掌握层次：
基础：熟练使用替换、删除、基本模式匹配
进阶：掌握正则表达式、多行处理、脚本编写
高级：能设计复杂的文本处理流水线
专家：深入理解sed内部机制，优化处理性能

📚 练习建议：
1. 从简单的替换操作开始
2. 多练习正则表达式匹配
3. 尝试处理真实的日志文件
4. 编写可复用的sed脚本
5. 与grep、awk等工具组合使用
```

**💡 学习心得**
- sed学习的关键是理解"流式处理"的思想
- 正则表达式是sed的核心武器，值得深入学习
- 多动手实践，从简单问题开始解决
- 建立自己的常用脚本库，提高工作效率

**核心记忆**：
- sed是流式编辑器，按行处理文本
- s/old/new/g 是最常用的替换命令
- 地址模式决定处理哪些行
- 正则表达式让匹配更灵活
- 脚本文件让复杂处理更简单