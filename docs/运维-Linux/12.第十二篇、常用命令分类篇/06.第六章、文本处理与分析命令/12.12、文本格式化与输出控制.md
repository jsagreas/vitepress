---
title: 12、文本格式化与输出控制
---
## 📚 目录

1. [printf格式化输出详解](#1-printf格式化输出详解)
2. [字段对齐与填充技术](#2-字段对齐与填充技术)
3. [数值格式化控制](#3-数值格式化控制)
4. [fmt文本重排格式](#4-fmt文本重排格式)
5. [fold行长度控制](#5-fold行长度控制)
6. [pr分页打印格式](#6-pr分页打印格式)
7. [特殊字符处理技巧](#7-特殊字符处理技巧)
8. [输出重定向控制技巧](#8-输出重定向控制技巧)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🖨️ printf格式化输出详解


### 1.1 printf基本概念


> 💡 **什么是printf**  
> printf是Linux系统中专门用来按照指定格式输出文本的命令。就像你用打印机打印文档需要设置格式一样，printf帮你精确控制文本在屏幕上的显示格式。

**printf vs echo的区别**：
```
echo：简单输出，功能有限
命令: echo "Hello World"
输出: Hello World

printf：精确格式控制，功能强大
命令: printf "Hello %s\n" "World"  
输出: Hello World
```

### 1.2 printf格式说明符


**核心格式说明符一览表**：

| 格式符 | **含义** | **示例** | **输出结果** |
|--------|----------|----------|--------------|
| `%s` | `字符串` | `printf "%s\n" "Hello"` | `Hello` |
| `%d` | `十进制整数` | `printf "%d\n" 123` | `123` |
| `%f` | `浮点数` | `printf "%f\n" 3.14` | `3.140000` |
| `%c` | `单个字符` | `printf "%c\n" A` | `A` |
| `%x` | `十六进制` | `printf "%x\n" 255` | `ff` |
| `%o` | `八进制` | `printf "%o\n" 8` | `10` |

### 1.3 printf实用示例


**基础用法演示**：
```bash
# 字符串格式化
printf "用户名: %s, 年龄: %d\n" "张三" 25
# 输出: 用户名: 张三, 年龄: 25

# 多个变量格式化
printf "文件: %s, 大小: %d字节, 权限: %s\n" "test.txt" 1024 "rwxr-xr-x"
# 输出: 文件: test.txt, 大小: 1024字节, 权限: rwxr-xr-x
```

### 1.4 特殊转义字符


```
常用转义字符表：
┌────────┬─────────────┬──────────────┐
│ 转义符 │    含义     │    示例      │
├────────┼─────────────┼──────────────┤
│  \n    │    换行     │ 光标移到下行 │
│  \t    │   制表符    │ 相当于Tab键  │
│  \\    │   反斜杠    │ 输出\字符    │
│  \"    │   双引号    │ 输出"字符    │
│  \r    │   回车符    │ 光标回行首   │
└────────┴─────────────┴──────────────┘
```

---

## 2. 📐 字段对齐与填充技术


### 2.1 字段宽度控制原理


> 🎯 **什么是字段宽度**  
> 想象你在制作表格，每一列都要有固定的宽度，这样内容才能整齐对齐。字段宽度就是指定每个数据占用多少个字符位置。

**宽度控制语法**：
```
格式: %[宽度]格式符
示例: %10s 表示字符串占10个字符宽度
     %5d  表示数字占5个字符宽度
```

### 2.2 左右对齐控制


**对齐方式对比**：
```bash
# 右对齐（默认）
printf "|%10s|\n" "Hello"
# 输出: |     Hello|

# 左对齐（加负号）
printf "|%-10s|\n" "Hello"  
# 输出: |Hello     |

# 数字右对齐
printf "|%5d|\n" 123
# 输出: |  123|
```

### 2.3 零填充与空格填充


```bash
# 空格填充（默认）
printf "%5d\n" 42
# 输出:    42

# 零填充（数字前加0）
printf "%05d\n" 42
# 输出: 00042

# 制作表格效果
printf "%-15s %8s %6s\n" "文件名" "大小" "类型"
printf "%-15s %8d %6s\n" "document.txt" 1024 "文本"
printf "%-15s %8d %6s\n" "image.jpg" 204800 "图片"
```

**输出效果**：
```
文件名            大小   类型
document.txt     1024   文本
image.jpg      204800   图片
```

### 2.4 制作表格的实用技巧


> 🔧 **实践应用**  
> 在系统管理中经常需要制作格式整齐的报表，掌握对齐技巧非常重要。

```bash
# 系统信息表格示例
printf "┌────────────┬──────────┬────────────┐\n"
printf "│ %-10s │ %-8s │ %-10s │\n" "进程名" "PID" "内存使用"
printf "├────────────┼──────────┼────────────┤\n"
printf "│ %-10s │ %-8d │ %-10s │\n" "nginx" 1234 "45MB"
printf "│ %-10s │ %-8d │ %-10s │\n" "mysql" 5678 "128MB"
printf "└────────────┴──────────┴────────────┘\n"
```

---

## 3. 🔢 数值格式化控制


### 3.1 浮点数精度控制


> 📊 **为什么要控制精度**  
> 计算机处理小数时会产生很长的小数位，但实际应用中往往只需要保留几位小数，比如金额通常只保留2位小数。

**精度控制语法**：
```
格式: %.[精度位数]f
示例: %.2f 保留2位小数
     %.0f 不显示小数（四舍五入到整数）
```

```bash
# 默认6位小数
printf "%f\n" 3.14159
# 输出: 3.141590

# 保留2位小数
printf "%.2f\n" 3.14159
# 输出: 3.14

# 保留0位小数（相当于取整）
printf "%.0f\n" 3.14159
# 输出: 3
```

### 3.2 科学记数法格式


```bash
# 科学记数法（小写e）
printf "%e\n" 123456.789
# 输出: 1.234568e+05

# 科学记数法（大写E）
printf "%E\n" 123456.789
# 输出: 1.234568E+05

# 自动选择最佳格式（%g）
printf "%g\n" 0.0001      # 输出: 0.0001
printf "%g\n" 1000000     # 输出: 1e+06
```

### 3.3 进制转换显示


**不同进制对比表**：

| 十进制 | **二进制** | **八进制** | **十六进制** |
|--------|------------|------------|--------------|
| `15` | `1111` | `17` | `f` |
| `255` | `11111111` | `377` | `ff` |
| `1024` | `10000000000` | `2000` | `400` |

```bash
# 同一个数字的不同进制显示
num=255
printf "十进制: %d\n" $num        # 输出: 十进制: 255
printf "八进制: %o\n" $num        # 输出: 八进制: 377
printf "十六进制: %x\n" $num      # 输出: 十六进制: ff
printf "十六进制大写: %X\n" $num  # 输出: 十六进制大写: FF
```

---

## 4. 📝 fmt文本重排格式


### 4.1 fmt命令基本作用


> 🎯 **fmt的实际用途**  
> 当你有一段文字，每行长短不一，看起来很乱时，fmt可以帮你重新整理成每行长度相近的段落，就像Word里的段落格式化功能。

**fmt处理效果对比**：
```
处理前：
这是一行很长的文字，可能会超出屏幕宽度，看起来不够整洁。
这行很短。
这是另外一行中等长度的文字内容。

处理后（fmt -w 40）：
这是一行很长的文字，可能会超出屏幕宽度，
看起来不够整洁。这行很短。这是另外一行中
等长度的文字内容。
```

### 4.2 fmt主要参数详解


**常用参数说明**：

| 参数 | **功能** | **示例** | **效果** |
|------|----------|----------|----------|
| `-w` | `指定行宽` | `fmt -w 50` | `每行最多50字符` |
| `-s` | `只分割长行` | `fmt -s` | `短行保持不变` |
| `-u` | `统一空格间隔` | `fmt -u` | `单词间只留一个空格` |

### 4.3 实用格式化示例


```bash
# 创建测试文本
cat > messy.txt << EOF
这是第一段很长的文字内容，需要重新格式化处理。
短行。
这是另一段需要整理的文字，让它们看起来更加整齐美观。
EOF

# 基本格式化（默认75字符宽度）
fmt messy.txt

# 指定宽度格式化
fmt -w 40 messy.txt

# 只处理过长的行，保持短行不变
fmt -s -w 60 messy.txt
```

### 4.4 格式化邮件和文档


> 💡 **实际应用场景**  
> 写邮件或编辑文档时，经常需要调整段落格式，fmt特别适合处理纯文本格式的内容。

---

## 5. 📏 fold行长度控制


### 5.1 fold命令基本功能


> 🔧 **fold与fmt的区别**  
> - fmt：聪明的重排，会保持单词完整，按意思分行
> - fold：简单的切割，到了指定长度就强制断行，不管是否把单词切断

```
原文: Hello World Test
fmt处理:  Hello World
         Test
fold处理: Hello Wor
         ld Test
```

### 5.2 fold参数详解


```bash
# 按字符数折行（默认80字符）
echo "这是一个很长的测试文本内容需要折行处理" | fold -w 20

# 按单词边界折行（保持单词完整）
echo "This is a very long line that needs wrapping" | fold -s -w 20

# 按字节数折行（处理多字节字符）
echo "中文字符处理测试内容" | fold -b -w 10
```

### 5.3 处理配置文件的实用场景


```bash
# 处理很长的配置行
cat config.conf | fold -s -w 80 > formatted_config.conf

# 格式化日志文件中的长行
tail -f /var/log/app.log | fold -w 100
```

---

## 6. 🖨️ pr分页打印格式


### 6.1 pr命令的作用


> 📄 **什么是分页打印**  
> 就像把文档分成一页页来打印，每页有标题、页码，看起来更专业。pr命令可以把普通文本文件格式化成适合打印的样式。

```
普通文本:                  pr格式化后:
line1                     ══════ 文件名 页1 ══════
line2                     
line3                     line1
...                       line2
                         line3
                         ...
                         
                         ══════ 文件名 页2 ══════
                         ...
```

### 6.2 pr分页参数控制


**核心分页参数**：

| 参数 | **功能** | **示例** | **说明** |
|------|----------|----------|----------|
| `-l` | `每页行数` | `pr -l 30` | `每页30行` |
| `-w` | `页面宽度` | `pr -w 80` | `每行80字符` |
| `-h` | `自定义页眉` | `pr -h "报告"` | `页眉显示"报告"` |
| `-n` | `行号显示` | `pr -n` | `给每行加行号` |

### 6.3 多列显示功能


```bash
# 单列显示（默认）
pr filename.txt

# 双列显示
pr -2 filename.txt

# 三列显示，指定列间分隔符
pr -3 -s"|" filename.txt

# 带行号的双列显示
pr -2 -n filename.txt
```

### 6.4 制作专业报告格式


```bash
# 创建格式化报告
pr -h "系统状态报告 - $(date +%Y-%m-%d)" \
   -l 50 \
   -w 80 \
   -n \
   system_status.txt > formatted_report.txt
```

---

## 7. 🔤 特殊字符处理技巧


### 7.1 不可见字符的识别


> ⚠️ **隐藏字符问题**  
> 文本文件中经常隐藏着看不见的字符（空格、制表符、换行符），这些字符可能导致程序出错或格式混乱。

**显示所有字符的方法**：
```bash
# 使用cat -A显示所有字符
cat -A filename.txt
# ^I 表示制表符
# $ 表示行尾
# ^M 表示回车符

# 使用od命令以八进制显示
od -c filename.txt

# 使用hexdump以十六进制显示
hexdump -C filename.txt | head
```

### 7.2 清理特殊字符


```bash
# 删除行尾的回车符（Windows格式转Unix格式）
tr -d '\r' < windows_file.txt > unix_file.txt

# 替换制表符为空格
tr '\t' ' ' < file_with_tabs.txt

# 删除行尾空格
sed 's/[[:space:]]*$//' filename.txt

# 压缩多个空格为单个空格
tr -s ' ' < filename.txt
```

### 7.3 处理编码字符


```bash
# 查看文件编码
file -i filename.txt

# 转换文件编码（GBK转UTF-8）
iconv -f gbk -t utf-8 chinese_file.txt > utf8_file.txt

# 处理特殊符号
tr '""' '""' < filename.txt  # 替换中文引号为英文引号
```

---

## 8. 🔄 输出重定向控制技巧


### 8.1 重定向基本概念


> 💡 **什么是输出重定向**  
> 默认情况下，命令的输出会显示在屏幕上。重定向就是把这些输出"改道"，发送到文件、其他命令，或者干脆不显示。

```
标准输出流示意图：
┌─────────┐    标准输出    ┌────────┐
│  命令   │ ────────────> │  屏幕  │
└─────────┘               └────────┘

重定向后：
┌─────────┐    重定向     ┌────────┐
│  命令   │ ───────────> │  文件  │
└─────────┘              └────────┘
```

### 8.2 输出重定向符号详解


**重定向符号对比表**：

| 符号 | **功能** | **示例** | **结果** |
|------|----------|----------|----------|
| `>` | `覆盖写入` | `echo "text" > file` | `文件被覆盖` |
| `>>` | `追加写入` | `echo "text" >> file` | `内容追加到末尾` |
| `2>` | `错误重定向` | `cmd 2> error.log` | `错误信息写入文件` |
| `&>` | `全部重定向` | `cmd &> all.log` | `所有输出写入文件` |

### 8.3 实用重定向技巧


```bash
# 同时输出到屏幕和文件（tee命令）
ls -la | tee file_list.txt

# 追加模式的tee
ps aux | tee -a system_processes.log

# 丢弃输出（发送到黑洞）
noisy_command > /dev/null 2>&1

# 分离正常输出和错误输出
command > output.txt 2> error.txt

# 将错误输出合并到标准输出
command 2>&1 | grep "warning"
```

### 8.4 管道与重定向组合使用


> 🔗 **管道的强大之处**  
> 管道让你可以把多个命令串联起来，前一个命令的输出成为后一个命令的输入，形成处理链条。

```bash
# 处理链条示例：统计日志中的错误数量
cat /var/log/app.log | \
grep "ERROR" | \
wc -l > error_count.txt

# 格式化系统进程信息
ps aux | \
awk '{printf "%-15s %8s %6s\n", $1, $2, $11}' | \
head -20 > formatted_processes.txt

# 生成格式化的磁盘使用报告
df -h | \
grep -v "tmpfs" | \
printf "磁盘使用情况报告\n$(date)\n\n" > disk_report.txt && \
df -h >> disk_report.txt
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


> 🎯 **学习重点**  
> 文本格式化和输出控制是Linux系统管理和脚本编写的基础技能，重点要理解每个命令的适用场景。

```
🔸 printf：精确格式控制的万能工具
🔸 字段对齐：制作整齐表格的关键技术
🔸 数值格式化：处理数字显示的必备知识
🔸 文本重排：整理文档格式的实用技巧
🔸 特殊字符：解决编码和格式问题的方法
🔸 重定向：控制输出流向的核心技能
```

### 9.2 命令选择指南


**根据需求选择合适的工具**：

```
制作报表 → printf + 字段对齐
整理文档 → fmt（保持单词完整）
强制断行 → fold（按字符数切割）
打印排版 → pr（分页、多列、页眉）
清理文本 → tr（字符替换和删除）
查看隐藏字符 → cat -A 或 od -c
```

### 9.3 实际应用场景


**系统管理中的常见应用**：

- **日志分析**：格式化输出、统计错误
- **报告生成**：制作格式整齐的系统状态报告  
- **配置文件处理**：清理格式、转换编码
- **数据处理**：CSV格式化、表格对齐
- **脚本输出**：美化命令行工具的输出

### 9.4 避免常见错误


> ⚠️ **注意事项**

```
常见错误：
❌ 混用 > 和 >>，导致文件被意外覆盖
❌ 忘记处理特殊字符，导致格式错乱
❌ printf格式符与数据类型不匹配
❌ 不了解命令差异，用错工具处理文本

最佳实践：
✅ 重要文件操作前先备份
✅ 使用 tee 命令同时保存和显示输出
✅ 测试重定向命令前先用小文件验证
✅ 处理不同编码文件时注意字符集转换
```

### 9.5 进阶学习建议


**继续深入的方向**：
- 学习awk和sed进行高级文本处理
- 掌握正则表达式提升匹配能力
- 了解Shell脚本中的变量格式化
- 研究不同Shell环境的差异

**核心记忆口诀**：
- printf精确控制格式化，字段对齐表格更美观
- fmt智能重排保单词，fold强制切割不留情  
- pr分页打印添页眉，特殊字符要清理
- 重定向控制输出流，管道串联功能强