---
title: 3、流编辑器sed命令详解
---
## 📚 目录

1. [sed基本概念与工作原理](#1-sed基本概念与工作原理)
2. [sed基本语法结构](#2-sed基本语法结构)
3. [替换命令s详解](#3-替换命令s详解)
4. [删除命令d用法](#4-删除命令d用法)
5. [插入与追加命令详解](#5-插入与追加命令详解)
6. [地址定位与范围选择](#6-地址定位与范围选择)
7. [sed脚本文件使用](#7-sed脚本文件使用)
8. [原地编辑与高级技巧](#8-原地编辑与高级技巧)
9. [实战应用场景](#9-实战应用场景)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔧 sed基本概念与工作原理


### 1.1 什么是sed

**sed**全称是`Stream Editor`（流编辑器），是Linux系统中一个强大的文本处理工具。

> 📌 **核心概念**  
> sed就像一个"文本加工厂"，文本从一端进入，经过处理后从另一端输出。它不会直接修改原文件，而是逐行读取、处理、输出。

**简单理解**：
```
原始文本 → sed处理 → 处理后文本

就像工厂流水线：
原材料 → 加工处理 → 成品输出
```

### 1.2 sed的工作流程


```
文本处理流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   读取一行   │───→│  应用命令   │───→│  输出结果   │
│  到模式空间  │    │  进行处理   │    │  到标准输出  │
└─────────────┘    └─────────────┘    └─────────────┘
       ↑                                      ↓
       └──────────── 循环处理下一行 ←──────────┘
```

🌱 **入门理解**：sed像一个传送带，文本逐行经过，每行都可以被"加工"

🌿 **进阶理解**：sed使用模式空间（Pattern Space）作为临时处理区域

🌳 **专家理解**：sed支持模式空间和保持空间的复杂操作

### 1.3 sed的核心特点


| 特点 | 说明 | 优势 |
|------|------|------|
| **流式处理** | 逐行处理，内存占用小 | 🚀 处理大文件高效 |
| **非交互式** | 命令行操作，可自动化 | ⚡ 适合脚本批处理 |
| **正则支持** | 支持强大的正则表达式 | 🎯 精确模式匹配 |
| **原文件安全** | 默认不修改原文件 | 🔒 数据安全有保障 |

---

## 2. 📝 sed基本语法结构


### 2.1 标准语法格式


```bash
sed [选项] '命令' 文件名
sed [选项] -e '命令1' -e '命令2' 文件名
sed [选项] -f 脚本文件 文件名
```

**语法解析**：
```
sed的三个组成部分：
┌─────────┐  ┌──────────┐  ┌─────────┐
│  选项   │  │   命令   │  │ 目标文件 │
│ Options │  │ Commands │  │  Files  │
└─────────┘  └──────────┘  └─────────┘
    ↓           ↓           ↓
  如何执行     做什么      处理什么
```

### 2.2 常用选项说明


| 选项 | 含义 | 使用场景 | 示例 |
|------|------|----------|------|
| **-n** | 静默模式，不输出模式空间内容 | 只输出特定行 | `sed -n '2p' file` |
| **-e** | 执行多个命令 | 组合多种操作 | `sed -e 's/old/new/' -e '/delete/d'` |
| **-f** | 从文件读取命令 | 复杂脚本处理 | `sed -f script.sed file` |
| **-i** | 直接修改文件 | 原地编辑文件 | `sed -i 's/old/new/' file` |
| **-r** | 使用扩展正则表达式 | 复杂模式匹配 | `sed -r 's/[0-9]+/NUM/' file` |

> ⚠️ **注意事项**  
> `-i`选项会直接修改原文件，使用前建议备份：`cp file file.bak`

### 2.3 命令的基本结构


```
sed命令的完整格式：
[地址] 命令 [参数]

例如：
2s/old/new/g
│ │   │   │ │
│ │   │   │ └─ 参数：全局替换
│ │   │   └─── 新内容
│ │   └─────── 旧内容  
│ └─────────── 命令：替换
└───────────── 地址：第2行
```

---

## 3. 🔄 替换命令s详解


### 3.1 基本替换语法


**标准格式**：`s/原内容/新内容/标志`

```bash
# 基本替换示例
echo "hello world" | sed 's/world/Linux/'
# 输出：hello Linux

# 替换文件内容
sed 's/old/new/' filename
```

> 💡 **实用技巧**  
> 分隔符不一定是`/`，可以使用其他字符：`s#old#new#` 或 `s|old|new|`

### 3.2 替换命令的标志


| 标志 | 作用 | 示例 | 结果说明 |
|------|------|------|----------|
| **g** | 全局替换（所有匹配） | `s/a/A/g` | 替换一行中所有的a |
| **数字** | 替换第N个匹配 | `s/a/A/2` | 只替换第2个a |
| **p** | 打印替换的行 | `s/a/A/p` | 输出发生替换的行 |
| **w 文件** | 将替换的行写入文件 | `s/a/A/w result.txt` | 保存替换行到文件 |

### 3.3 替换实战示例


**场景1：替换IP地址**
```bash
# 原文件内容
echo "server 192.168.1.10" > config.txt

# 替换IP地址  
sed 's/192\.168\.1\.10/192.168.1.20/' config.txt
# 输出：server 192.168.1.20
```

**场景2：删除行末空格**
```bash
# 删除每行末尾的空格和制表符
sed 's/[[:space:]]*$//' filename
```

**场景3：交换两个单词的位置**
```bash
# 交换用户名和密码的位置
echo "user:password" | sed 's/\(.*\):\(.*\)/\2:\1/'
# 输出：password:user
```

> 🔥 **面试重点**  
> 替换命令中的分组`\(...\)`和引用`\1 \2`是高频考点，表示捕获和替换分组内容

### 3.4 高级替换技巧


**使用变量进行替换**：
```bash
old_ip="192.168.1.10"
new_ip="192.168.1.20"
sed "s/$old_ip/$new_ip/g" config.txt
```

**多行替换**：
```bash
# 将连续两行合并为一行
sed 'N;s/\n/ /' filename
```

---

## 4. ❌ 删除命令d用法


### 4.1 基本删除语法


**删除命令**：`d` - 删除匹配的行

```bash
# 删除第3行
sed '3d' filename

# 删除包含"delete"的行
sed '/delete/d' filename

# 删除空行
sed '/^$/d' filename
```

### 4.2 删除命令实战


**实用删除场景**：

| 需求 | 命令 | 说明 |
|------|------|------|
| **删除空行** | `sed '/^$/d'` | ^$表示空行 |
| **删除注释行** | `sed '/^#/d'` | 删除#开头的行 |
| **删除特定范围** | `sed '2,5d'` | 删除2-5行 |
| **删除最后一行** | `sed '$d'` | $表示最后一行 |
| **删除匹配行** | `sed '/pattern/d'` | 删除包含pattern的行 |

**综合示例 - 清理配置文件**：
```bash
# 原配置文件
cat > demo.conf << EOF
# 这是注释
server=localhost

# 另一个注释  
port=8080

debug=true
EOF

# 删除注释和空行
sed -e '/^#/d' -e '/^$/d' demo.conf
# 输出：
# server=localhost
# port=8080  
# debug=true
```

### 4.3 条件删除技巧


**删除不匹配的行**：
```bash
# 只保留包含"keep"的行（删除其他行）
sed '/keep/!d' filename
# 等价于：sed -n '/keep/p' filename
```

**范围条件删除**：
```bash
# 从匹配"start"的行开始，到匹配"end"的行结束，都删除
sed '/start/,/end/d' filename
```

---

## 5. ➕ 插入与追加命令详解


### 5.1 插入命令i和追加命令a


```
插入和追加的区别：
         原文本行
            │
    i命令───┤        ├───a命令
    (插入)   │        │   (追加)
            │        │
         在前面      在后面
```

**基本语法**：
- `i\` - 在匹配行**之前**插入文本
- `a\` - 在匹配行**之后**追加文本

```bash
# 在第2行前插入文本
sed '2i\New line inserted' filename

# 在第2行后追加文本  
sed '2a\New line appended' filename

# 在包含"pattern"的行后追加
sed '/pattern/a\Additional info' filename
```

### 5.2 实用插入追加示例


**场景1：添加配置项**
```bash
# 在配置文件开头添加说明
sed '1i\# Configuration file\n# Generated automatically' config.txt

# 在[database]段落后添加新配置
sed '/\[database\]/a\timeout=30\nmax_connections=100' config.txt
```

**场景2：日志文件处理**
```bash
# 在错误日志行前添加标记
sed '/ERROR/i\=== 错误信息开始 ===' log.txt
sed '/ERROR/a\=== 错误信息结束 ===' log.txt
```

### 5.3 替换整行命令c


**替换命令**：`c\` - 替换整行内容

```bash
# 替换第3行内容
sed '3c\This is new line 3' filename

# 替换包含"old"的行
sed '/old/c\New content here' filename

# 替换多行
sed '2,4c\These three lines are replaced\nwith this new content' filename
```

**实战示例 - 更新版本信息**：
```bash
# 原文件内容
echo -e "Version: 1.0\nDate: 2024-01-01\nAuthor: admin" > version.txt

# 更新版本号
sed '/Version:/c\Version: 2.0' version.txt
```

---

## 6. 🎯 地址定位与范围选择


### 6.1 地址定位方式


sed支持多种方式来指定要操作的行：

```
地址定位方式：
┌─────────────┬─────────────┬─────────────┐
│  行号定位   │  模式定位   │  范围定位   │
├─────────────┼─────────────┼─────────────┤
│    '3'      │ '/pattern/' │   '2,5'     │
│   '3,5'     │'/start/,/end/│  '3,$'      │
│    '$'      │   '/^#/'    │ '/pat1/,/pat2/' │
└─────────────┴─────────────┴─────────────┘
```

### 6.2 行号定位


| 地址格式 | 含义 | 示例 |
|---------|------|------|
| **N** | 第N行 | `sed '3d'` - 删除第3行 |
| **N,M** | 第N行到第M行 | `sed '2,5d'` - 删除2-5行 |
| **N,+M** | 从第N行开始的M行 | `sed '3,+2d'` - 删除3-5行 |
| **$** | 最后一行 | `sed '$d'` - 删除最后一行 |
| **N~M** | 从第N行开始，每隔M行 | `sed '1~2d'` - 删除奇数行 |

### 6.3 模式定位


```bash
# 基于内容匹配的定位
sed '/ERROR/d' log.txt          # 删除包含ERROR的行
sed '/^#/d' config.txt          # 删除注释行（#开头）
sed '/^$/d' file.txt            # 删除空行
sed '/[0-9]/p' data.txt         # 打印包含数字的行
```

**正则表达式常用模式**：

| 模式 | 含义 | 应用场景 |
|------|------|----------|
| **^** | 行首 | 匹配行开头的内容 |
| **$** | 行尾 | 匹配行结尾的内容 |
| **[0-9]** | 任意数字 | 匹配包含数字的行 |
| **[a-zA-Z]** | 任意字母 | 匹配包含字母的行 |
| **.\*** | 任意字符 | 通配符匹配 |

### 6.4 范围选择高级用法


**组合地址定位**：
```bash
# 从第5行到包含"end"的行
sed '5,/end/d' filename

# 从包含"start"的行到第10行
sed '/start/,10d' filename

# 从包含"begin"的行到最后
sed '/begin/,$d' filename
```

**取反操作**：
```bash
# 除了第3行外，其他行都删除
sed '3!d' filename

# 除了包含"keep"的行，其他都删除  
sed '/keep/!d' filename
```

---

## 7. 📄 sed脚本文件使用


### 7.1 为什么使用脚本文件


当sed命令变得复杂时，使用脚本文件有以下优势：

> 📌 **脚本文件优势**  
> ✅ 命令可重用，避免重复输入  
> ✅ 复杂逻辑更清晰，易于维护  
> ✅ 可以添加注释，增强可读性  
> ✅ 版本控制更方便

### 7.2 创建sed脚本文件


**脚本文件格式**：
```bash
# 创建sed脚本文件 clean.sed
cat > clean.sed << 'EOF'
# 这是sed脚本文件
# 删除注释行
/^#/d

# 删除空行  
/^$/d

# 替换制表符为4个空格
s/\t/    /g

# 删除行尾空格
s/[[:space:]]*$//
EOF
```

**使用脚本文件**：
```bash
# 使用-f选项执行脚本文件
sed -f clean.sed input.txt

# 结合其他选项使用
sed -n -f extract.sed data.txt > output.txt
```

### 7.3 实战脚本示例


**场景1：日志清理脚本**
```bash
# 创建日志清理脚本 log_clean.sed
cat > log_clean.sed << 'EOF'
# 删除DEBUG级别的日志
/DEBUG/d

# 删除时间戳，只保留消息内容
s/^[0-9-]* [0-9:]* //

# 统一ERROR标记格式
s/\[ERROR\]/[ERR]/g
s/\[WARN\]/[WRN]/g

# 删除多余空行
/^$/d
EOF

# 使用脚本处理日志
sed -f log_clean.sed system.log > clean.log
```

**场景2：配置文件处理脚本**
```bash
# 创建配置优化脚本 config_optimize.sed
cat > config_optimize.sed << 'EOF'
# 删除注释行但保留重要说明
/^[[:space:]]*#[[:space:]]*IMPORTANT/!{
  /^[[:space:]]*#/d
}

# 标准化配置格式
s/[[:space:]]*=[[:space:]]*/=/g

# 删除空行
/^$/d

# 排序相同类型的配置（需要结合其他工具）
EOF
```

### 7.4 脚本调试技巧


```bash
# 调试脚本的方法

# 1. 逐行测试命令
sed -n '/pattern/p' file.txt  # 先查看匹配的行

# 2. 使用-n选项控制输出
sed -n -f script.sed file.txt  # 只输出p命令的结果

# 3. 添加调试输出
cat > debug.sed << 'EOF'
# 在处理前打印行号和内容
=
p
# 你的实际处理命令
s/old/new/g
EOF
```

---

## 8. 🔧 原地编辑与高级技巧


### 8.1 原地编辑-i选项详解


`-i`选项是sed的强大功能，可以直接修改文件内容。

> ⚠️ **重要警告**  
> `-i`选项会直接修改原文件，操作不可逆！建议先备份

**安全使用-i选项**：
```bash
# 1. 先备份再修改
cp important.txt important.txt.bak
sed -i 's/old/new/g' important.txt

# 2. 创建备份的同时修改
sed -i.bak 's/old/new/g' important.txt

# 3. 测试命令后再使用-i
sed 's/old/new/g' important.txt  # 先查看效果
sed -i 's/old/new/g' important.txt  # 确认无误后执行
```

### 8.2 批量文件处理


```bash
# 批量处理多个文件
sed -i 's/old/new/g' *.txt

# 批量清理配置文件
find /etc -name "*.conf" -exec sed -i '/^#/d' {} \;

# 批量更新IP地址
for file in *.config; do
    sed -i 's/192.168.1.10/192.168.1.20/g' "$file"
done
```

### 8.3 高级多命令组合


**使用分号分隔多个命令**：
```bash
# 单行执行多个操作
sed 's/old/new/g; /delete/d; /^$/d' filename
```

**使用-e选项执行多个命令**：
```bash
sed -e 's/old/new/g' -e '/delete/d' -e '/^$/d' filename
```

**使用花括号组合命令**：
```bash
# 对匹配的行执行多个操作
sed '/pattern/{
    s/old/new/g
    s/foo/bar/g
    a\Added line after pattern
}' filename
```

### 8.4 高级应用实例


**实例1：处理CSV文件**
```bash
# 原始CSV数据
cat > data.csv << EOF
Name,Age,City
John Doe,25,New York
Jane Smith,30,Los Angeles  
Bob Johnson,35,Chicago
EOF

# 格式化处理：统一城市名格式
sed -i '
    s/New York/NYC/g
    s/Los Angeles/LA/g
    s/Chicago/CHI/g
' data.csv
```

**实例2：代码格式化**
```bash
# Java代码格式化脚本
cat > format_java.sed << 'EOF'
# 标准化大括号风格
s/){/) {/g

# 统一缩进（将制表符替换为4个空格）
s/\t/    /g

# 删除行尾空格
s/[[:space:]]*$//

# 确保import语句后有空行
/^import/a\

# 删除多余的空行
/^$/{
    N
    /^\n$/d
}
EOF

# 应用格式化
sed -f format_java.sed MyClass.java > MyClass_formatted.java
```

---

## 9. 🚀 实战应用场景


### 9.1 系统管理场景


**场景1：清理系统日志**
```bash
# 删除旧的日志条目，只保留最近7天
current_date=$(date +%Y-%m-%d)
week_ago=$(date -d '7 days ago' +%Y-%m-%d)

# 删除7天前的日志行
sed -i "/^$week_ago/,\$!d" system.log
```

**场景2：配置文件维护**
```bash
# 更新nginx配置中的域名
sed -i 's/server_name old\.example\.com/server_name new.example.com/g' nginx.conf

# 批量更新数据库配置
find /opt/apps -name "*.properties" -exec sed -i 's/localhost:3306/db-server:3306/g' {} \;
```

### 9.2 开发场景


**场景1：代码重构**
```bash
# 批量重命名函数
sed -i 's/oldFunctionName/newFunctionName/g' *.java

# 更新API版本
sed -i 's/api\/v1\//api\/v2\//g' *.js
```

**场景2：环境配置切换**
```bash
# 切换到生产环境配置
sed -i '
    s/debug=true/debug=false/g
    s/localhost/prod-server/g  
    s/development/production/g
' application.properties
```

### 9.3 数据处理场景


**场景1：CSV数据清洗**
```bash
# 处理包含中文的CSV文件
sed -i '
    # 删除空行和只包含逗号的行
    /^[,]*$/d
    
    # 统一日期格式 
    s/\([0-9]\{4\}\)年\([0-9]\{1,2\}\)月\([0-9]\{1,2\}\)日/\1-\2-\3/g
    
    # 清理多余空格
    s/[[:space:]]*,[[:space:]]*/,/g
' data.csv
```

**场景2：文本格式转换**
```bash
# Markdown转纯文本
sed '
    # 删除Markdown标记
    s/^#*[[:space:]]*//
    s/\*\*\(.*\)\*\*/\1/g
    s/\*\(.*\)\*/\1/g
    
    # 删除链接标记
    s/\[.*\](\(.*\))/\1/g
' document.md > document.txt
```

### 9.4 自动化脚本集成


**完整的自动化处理脚本**：
```bash
#!/bin/bash
# 文件处理自动化脚本

echo "开始处理配置文件..."

# 1. 备份原文件
for file in *.conf; do
    cp "$file" "$file.$(date +%Y%m%d).bak"
done

# 2. 批量处理
sed -i -f process_config.sed *.conf

# 3. 验证处理结果
echo "处理完成，检查结果："
for file in *.conf; do
    if sed -n '/^ERROR/p' "$file" | grep -q ERROR; then
        echo "警告：$file 可能存在错误配置"
    fi
done

echo "所有文件处理完成"
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 sed本质：流编辑器，逐行处理文本，不直接修改原文件
🔸 基本语法：sed [选项] '命令' 文件名
🔸 核心命令：s替换、d删除、i插入、a追加、c替换行
🔸 地址定位：行号、模式匹配、范围选择
🔸 高级功能：脚本文件、原地编辑、多命令组合
```

### 10.2 关键操作速查


| 🎯 需求 | **命令示例** | **说明** |
|---------|-------------|----------|
| **替换文本** | `sed 's/old/new/g'` | 全局替换old为new |
| **删除行** | `sed '/pattern/d'` | 删除匹配行 |
| **插入内容** | `sed '2i\新内容'` | 第2行前插入 |
| **提取行** | `sed -n '/pattern/p'` | 只输出匹配行 |
| **范围操作** | `sed '2,5d'` | 删除2-5行 |
| **原地编辑** | `sed -i.bak 's/old/new/g'` | 修改文件并备份 |

### 10.3 实用记忆技巧


> 📖 **记忆口诀**：  
> sed流编辑逐行过，s替换d删除最常用  
> i前插a后追c整行，地址定位要记清  
> 斜杠模式行号范围，-i直接改文件  
> 脚本文件-f调用，复杂处理更轻松

### 10.4 学习路径建议


```
📚 学习建议：
🌱 初学阶段：掌握基本s、d、p命令，理解地址定位
🌿 进阶阶段：熟练使用正则表达式，掌握范围选择
🌳 高级阶段：编写复杂脚本，集成到自动化流程

⏱️ 实践建议：
第1周：基础命令练习，处理简单文本
第2周：复杂模式匹配，编写sed脚本
第3周：结合其他工具，解决实际问题
```

### 10.5 最佳实践原则


> 💡 **最佳实践**：  
> ✅ 重要文件操作前先备份  
> ✅ 复杂命令先测试再应用  
> ✅ 使用脚本文件提高可维护性  
> ✅ 结合grep、awk等工具发挥最大效力  
> ✅ 注意正则表达式的转义字符

> 🔥 **面试要点**：  
> - sed的工作原理和模式空间概念
> - 替换命令的各种标志用法
> - 地址定位的多种方式
> - -i选项的使用注意事项
> - sed与awk、grep的区别和配合使用

**核心记忆**：
- sed是强大的流编辑器，擅长批量文本处理
- 掌握s、d、i、a基本命令，解决90%的需求
- 地址定位是sed的精髓，决定处理哪些行
- 原地编辑功能强大但需谨慎使用
- 与其他Linux工具结合，发挥更大威力