---
title: 10、系统性能状态查看
---
## 📚 目录

1. [iostat I/O统计信息](#1-iostat-I/O统计信息)
2. [sar系统活动报告](#2-sar系统活动报告)
3. [nfsstat NFS统计信息](#3-nfsstat-NFS统计信息)
4. [iftop网络流量监控](#4-iftop网络流量监控)
5. [iotop I/O监控工具](#5-iotop-I/O监控工具)
6. [/proc/loadavg负载信息](#6-proc/loadavg负载信息)
7. [/proc/stat系统统计](#7-proc/stat系统统计)
8. [/proc/interrupts中断统计](#8-proc/interrupts中断统计)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 iostat I/O统计信息


### 1.1 什么是iostat


**iostat**是Linux系统中用来监控系统**输入输出（I/O）统计信息**的重要工具，简单来说就是帮你看清楚硬盘读写情况的"体检报告"。

**💡 通俗理解**：
- 就像医生用听诊器检查心跳一样，iostat用来检查硬盘的"心跳"
- 告诉你哪个硬盘忙，哪个硬盘闲，读写速度如何
- 帮助发现系统I/O性能瓶颈

### 1.2 iostat核心功能


```
系统I/O监控全景图：
┌─────────────────────────────────────┐
│              iostat                 │
├─────────────────┬───────────────────┤
│   CPU使用情况   │   磁盘I/O情况     │
│                 │                   │
│ • 用户使用率    │ • 读写请求数      │
│ • 系统使用率    │ • 读写速度        │
│ • I/O等待率     │ • 队列长度        │
│ • 空闲率        │ • 响应时间        │
└─────────────────┴───────────────────┘
```

### 1.3 基本使用方法


| 常用命令 | 作用说明 | 实际用途 |
|---------|----------|----------|
| `iostat` | **查看基本I/O统计** | 快速了解系统整体I/O状况 |
| `iostat -x` | **显示详细信息** | 深入分析每个设备的I/O性能 |
| `iostat 2` | **每2秒刷新一次** | 实时监控I/O变化 |
| `iostat -d` | **只显示设备信息** | 专注查看磁盘I/O，不看CPU |

### 1.4 关键指标含义


**🔍 CPU相关指标**：
- **%user**：用户程序占用CPU百分比
- **%system**：系统内核占用CPU百分比  
- **%iowait**：⚠️ **最重要** - CPU等待I/O操作的时间百分比
- **%idle**：CPU空闲百分比

**📊 磁盘I/O指标**：
- **tps**：每秒传输次数（读写请求总数）
- **kB_read/s**：每秒读取的数据量（KB）
- **kB_wrtn/s**：每秒写入的数据量（KB）
- **%util**：设备利用率（越高越繁忙）

> **💡 新手重点理解**：%iowait高说明CPU在等硬盘，系统可能有I/O瓶颈！

---

## 2. 📈 sar系统活动报告


### 2.1 什么是sar


**sar**（System Activity Reporter）是Linux的**系统活动报告工具**，它就像一个全能的"系统健康监控仪"，能记录和显示系统各方面的运行状况。

**🎯 形象理解**：
- 如果说iostat是专门的"心电图"，那sar就是全面的"体检报告"
- 不仅看I/O，还能看CPU、内存、网络、进程等所有指标
- 既能实时监控，又能查看历史记录

### 2.2 sar的强大功能


```
sar监控范围全览：
┌──────────────────────────────────────────┐
│                  sar                     │
├──────────┬──────────┬──────────┬─────────┤
│   CPU    │   内存   │   网络   │   I/O   │
│          │          │          │         │
│ • 使用率 │ • 使用量 │ • 流量   │ • 读写  │
│ • 负载   │ • 交换   │ • 错误   │ • 等待  │
│ • 中断   │ • 缓存   │ • 连接   │ • 队列  │
└──────────┴──────────┴──────────┴─────────┘
```

### 2.3 核心使用场景


| 监控类型 | 命令示例 | 作用说明 |
|---------|----------|----------|
| **CPU监控** | `sar -u 2 5` | 每2秒显示CPU使用情况，显示5次 |
| **内存监控** | `sar -r` | 查看内存和交换分区使用情况 |
| **网络监控** | `sar -n DEV` | 查看网络接口的流量统计 |
| **I/O监控** | `sar -b` | 查看系统整体I/O活动情况 |
| **历史数据** | `sar -u -f /var/log/sa/sa15` | 查看15号的CPU历史数据 |

### 2.4 实用技巧


**⚡ 快速诊断系统问题**：
1. **CPU问题**：`sar -u` 看%user和%system是否过高
2. **内存问题**：`sar -r` 看内存使用率和交换使用
3. **网络问题**：`sar -n DEV` 看网络流量和错误包
4. **I/O问题**：`sar -b` 看读写请求数和传输速率

> **🔧 实用建议**：sar的历史数据功能特别有用，能帮你分析"昨天下午2点系统为什么卡"这类问题！

---

## 3. 🌐 nfsstat NFS统计信息


### 3.1 什么是nfsstat


**nfsstat**是专门用来查看**NFS（网络文件系统）统计信息**的工具。简单来说，就是监控网络共享文件夹使用情况的专用工具。

**📁 通俗理解**：
- NFS就像在网络上建了一个"共享文件夹"
- 多台电脑可以像访问本地文件一样访问这个网络文件夹
- nfsstat就是查看这个"共享文件夹"使用情况的工具

### 3.2 NFS工作原理图示


```
NFS网络文件共享示意：
客户端电脑A          服务器电脑           客户端电脑B
    |                    |                    |
    |---[读写请求]------->|                    |
    |                    |                    |
    |<--[文件数据]--------|<---[读写请求]------|
    |                    |                    |
    |                共享目录                  |
                    /data/share
```

### 3.3 主要统计信息


| 统计类型 | 说明 | 关注重点 |
|---------|------|----------|
| **客户端统计** | 本机作为NFS客户端的活动 | 读写请求数、网络调用次数 |
| **服务端统计** | 本机作为NFS服务器的活动 | 处理请求数、响应时间 |
| **RPC统计** | 远程过程调用统计 | 网络通信质量、重传次数 |

### 3.4 使用场景


**适用情况**：
- ✅ 系统中使用了NFS网络文件共享
- ✅ 需要分析NFS性能问题
- ✅ 排查网络文件访问慢的问题

**不适用情况**：
- ❌ 系统没有使用NFS（显示为0或空）
- ❌ 纯本地文件系统环境

---

## 4. 🌊 iftop网络流量监控


### 4.1 什么是iftop


**iftop**是一个实时显示**网络流量**的监控工具，它能让你看到网络数据是怎样在你的电脑和互联网之间流动的。

**🔍 形象比喻**：
- 就像站在高速公路收费站，能看到每辆车从哪来到哪去
- 告诉你哪个程序在大量下载，哪个在上传
- 实时显示网络带宽使用情况

### 4.2 iftop界面解读


```
iftop显示界面示意：
┌──────────────────────────────────────────────────┐
│                   12.8Kb  25.6Kb  38.4Kb        │ ← 流量刻度
│────────────────────────────────────────────────  │
│本机IP:端口          =>   目标IP:端口         带宽 │
│192.168.1.100:22     =>   192.168.1.1:443   2.1KB│ ← 连接详情
│192.168.1.100:80     <=   114.114.114.114   15.2KB│
│────────────────────────────────────────────────  │
│TX: 发送总计  RX: 接收总计  TOTAL: 总计           │ ← 流量统计
└──────────────────────────────────────────────────┘
```

### 4.3 关键信息含义


**📊 流量方向标识**：
- `=>` 表示**发送数据**（上传）
- `<=` 表示**接收数据**（下载）
- 箭头后面的数字是**实时流量大小**

**📈 统计数据说明**：
- **TX**：Transmit（发送/上传的数据量）
- **RX**：Receive（接收/下载的数据量）  
- **TOTAL**：总流量（TX + RX）
- **peak**：峰值流量
- **rates**：平均速率

### 4.4 实用操作技巧


| 按键 | 功能 | 实际用途 |
|------|------|----------|
| **h** | 显示/隐藏帮助 | 查看所有操作命令 |
| **p** | 显示/隐藏端口号 | 了解具体是什么服务在传输数据 |
| **n** | 显示/隐藏域名解析 | 看IP地址还是域名，方便识别 |
| **t** | 切换显示格式 | 改变流量显示的详细程度 |
| **q** | 退出程序 | 结束监控 |

> **💡 新手技巧**：看到某个连接流量特别大，按`p`显示端口号，就能知道是什么程序在传输数据！

---

## 5. 💽 iotop I/O监控工具


### 5.1 什么是iotop


**iotop**是专门监控**进程I/O使用情况**的工具，它能告诉你哪个程序在读写硬盘，读写速度有多快。

**🔧 通俗理解**：
- 就像`top`命令看CPU使用情况一样，iotop专门看硬盘使用情况
- 能找出哪个程序在"拖累"硬盘性能
- 实时显示每个进程的读写活动

### 5.2 iotop显示界面


```
iotop界面布局：
┌─────────────────────────────────────────────────────┐
│Total DISK READ: 15.2M/s | Total DISK WRITE: 2.3M/s │ ← 总体I/O
├─────────────────────────────────────────────────────┤
│  PID  USER     DISK READ  DISK WRITE  COMMAND       │ ← 表头
│ 1234  root        10.2M/s      0.0B/s  cp /big/file │ ← 进程详情
│ 5678  mysql        2.1M/s      1.8M/s  mysqld       │
│ 9012  user         0.5M/s      0.2M/s  firefox      │
└─────────────────────────────────────────────────────┘
```

### 5.3 关键指标解释


**📊 重要列说明**：
- **TOTAL**：该进程启动以来的累计I/O量
- **CURRENT**：当前瞬时I/O速率
- **READ**：读取速度（从硬盘读数据）
- **WRITE**：写入速度（往硬盘写数据）
- **%**：该进程I/O占总I/O的百分比

### 5.4 实用参数选项


| 参数选项 | 作用 | 使用场景 |
|---------|------|----------|
| `iotop -o` | **只显示有I/O活动的进程** | 快速找出正在读写硬盘的程序 |
| `iotop -a` | **显示累积I/O量** | 查看哪个程序总共读写了多少数据 |
| `iotop -p PID` | **只监控指定进程** | 专门观察某个程序的I/O行为 |
| `iotop -u 用户名` | **只显示某用户的进程** | 查看特定用户的I/O使用情况 |

> **⚠️ 使用提醒**：iotop需要root权限才能运行，因为它需要访问内核的I/O统计信息！

---

## 6. ⚖️ /proc/loadavg负载信息


### 6.1 什么是系统负载


**/proc/loadavg**文件包含系统**负载平均值**信息，它反映了系统的繁忙程度。

**🏃 生活化理解**：
- 想象CPU是一条单车道，进程是要通过的汽车
- 负载值就是这条道路上"排队等候"的汽车数量
- 负载越高，说明"交通越拥堵"，系统越忙

### 6.2 负载数值含义


```bash
cat /proc/loadavg
0.25 0.50 0.75 2/180 12345
```

**数值解释**：
- **0.25**：最近1分钟的平均负载
- **0.50**：最近5分钟的平均负载  
- **0.75**：最近15分钟的平均负载
- **2/180**：当前运行进程数/总进程数
- **12345**：最近运行的进程ID

### 6.3 负载数值判断标准


| 负载范围 | 系统状态 | 实际含义 |
|---------|----------|----------|
| **0.0 - 1.0** | 🟢 **轻松** | 系统运行流畅，资源充足 |
| **1.0 - 2.0** | 🟡 **正常** | 系统有一定负载，但仍可接受 |
| **2.0 - 5.0** | 🟠 **繁忙** | 系统较忙，可能出现响应延迟 |
| **5.0+** | 🔴 **过载** | 系统严重过载，响应很慢 |

### 6.4 负载分析技巧


**📈 负载趋势分析**：
- **1分钟 > 5分钟 > 15分钟**：负载在**上升**，系统越来越忙
- **1分钟 < 5分钟 < 15分钟**：负载在**下降**，系统逐渐空闲
- **三个数值相近**：系统负载**稳定**

> **💡 新手要点**：单核CPU负载1.0表示满载，双核CPU满载是2.0，四核是4.0，以此类推！

---

## 7. 📊 /proc/stat系统统计


### 7.1 什么是/proc/stat


**/proc/stat**文件包含了系统和CPU的**详细统计信息**，它记录了系统启动以来的各种活动数据。

**📋 作用说明**：
- 记录CPU时间分配（用户态、内核态、空闲等）
- 统计系统启动以来的中断、上下文切换次数
- 提供进程创建、页面换入换出等信息

### 7.2 文件内容解读


```bash
cat /proc/stat
cpu  123456 789 23456 987654 1234 0 567 0 0 0
cpu0 61728 394 11728 493827 617 0 283 0 0 0
cpu1 61728 395 11728 493827 617 0 284 0 0 0
intr 12345678 0 2 0 0 0 0 0 0 1 0 0 0...
ctxt 87654321
btime 1609459200
processes 12345
procs_running 2
procs_blocked 1
```

### 7.3 关键字段含义


**🔍 CPU时间统计**（单位：jiffies，通常1秒=100 jiffies）：
- **第1个数**：用户态时间（运行应用程序）
- **第2个数**：nice时间（运行低优先级进程）
- **第3个数**：系统态时间（运行内核代码）
- **第4个数**：⭐ **空闲时间**（CPU无事可做）
- **第5个数**：I/O等待时间（等待硬盘读写）

**📈 其他重要统计**：
- **intr**：系统启动以来的中断总数
- **ctxt**：上下文切换总次数
- **processes**：系统启动以来创建的进程总数
- **procs_running**：当前正在运行的进程数
- **procs_blocked**：当前被阻塞的进程数

### 7.4 实际应用价值


**性能分析用途**：
- **CPU利用率计算**：(总时间 - 空闲时间) / 总时间 × 100%
- **系统繁忙程度**：通过上下文切换次数判断
- **I/O瓶颈识别**：I/O等待时间占比过高说明存储慢

---

## 8. ⚡ /proc/interrupts中断统计


### 8.1 什么是系统中断


**系统中断**是硬件设备通知CPU"我需要处理"的机制，**/proc/interrupts**记录了各种中断的统计信息。

**🔔 生活化理解**：
- 中断就像电话铃声，硬件设备用它来"呼叫"CPU
- CPU正在工作时，硬盘、网卡、键盘等设备可能随时"打电话"
- /proc/interrupts就是这些"电话记录"

### 8.2 中断类型说明


```
常见中断类型示意：
┌─────────────────────────────────────────┐
│              CPU                        │
├─────────────────────────────────────────┤
│  ↑ 键盘中断     ↑ 鼠标中断              │
│  ↑ 硬盘中断     ↑ 网卡中断              │
│  ↑ 定时器中断   ↑ USB中断               │
└─────────────────────────────────────────┘
```

### 8.3 文件内容解读


```bash
cat /proc/interrupts
           CPU0       CPU1       
  0:     123456     123457   IO-APIC-edge      timer
  1:        123        124   IO-APIC-edge      i8042
  8:          1          1   IO-APIC-edge      rtc0
 12:       1234       1235   IO-APIC-edge      i8042
 16:      12345      12346   IO-APIC-fasteoi   eth0
```

**列说明**：
- **第1列**：中断号（IRQ号）
- **CPU0/CPU1等**：各个CPU核心处理该中断的次数
- **最后一列**：中断对应的设备名称

### 8.4 常见中断设备


| 中断号 | 设备类型 | 作用说明 |
|--------|----------|----------|
| **0** | 系统定时器 | 系统时钟，每秒触发100-1000次 |
| **1** | 键盘控制器 | 键盘按键输入 |
| **12** | 鼠标控制器 | 鼠标移动和点击 |
| **14/15** | 硬盘控制器 | 硬盘读写完成通知 |
| **16+** | 网卡/USB等 | 网络数据接收、USB设备插拔 |

### 8.5 中断分析实用技巧


**🔍 性能问题排查**：
- **某个中断次数异常高**：可能对应设备有问题
- **CPU之间中断分布不均**：可能需要调整中断负载均衡
- **网卡中断过多**：可能网络流量过大或有攻击

> **📝 实用提醒**：正常系统中，定时器中断（IRQ 0）次数最多，这是正常现象！

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 iostat：专注I/O性能，关注%iowait和磁盘利用率
🔸 sar：全能监控工具，能查看CPU、内存、网络、I/O所有指标
🔸 nfsstat：NFS网络文件系统专用，只在使用NFS时才有意义
🔸 iftop：实时网络流量监控，能看到具体连接和带宽使用
🔸 iotop：进程级I/O监控，找出哪个程序在大量读写硬盘
🔸 /proc/loadavg：系统负载情况，反映系统繁忙程度
🔸 /proc/stat：系统统计信息，CPU时间分配和系统活动
🔸 /proc/interrupts：硬件中断统计，了解硬件设备活动
```

### 9.2 实际使用场景指南


**🚀 系统性能问题排查流程**：

```
系统卡顿问题诊断步骤：
┌─────────────────┐
│  1. 查看负载    │ ← cat /proc/loadavg
│     负载是否过高？ │
└─────────┬───────┘
          ▼
┌─────────────────┐
│  2. 分析CPU     │ ← iostat 查看%iowait
│     是CPU问题还是I/O问题？│
└─────────┬───────┘
          ▼
┌─────────────────┐
│  3. 具体排查    │ ← iotop找I/O大户
│     找出问题进程   │   top找CPU大户
└─────────────────┘
```

**📊 不同工具的使用时机**：

| 问题现象 | 推荐工具 | 分析重点 |
|---------|----------|----------|
| **系统响应慢** | `iostat` → `iotop` | 先看I/O等待，再找具体进程 |
| **网络异常** | `iftop` → `sar -n DEV` | 实时流量+历史统计结合 |
| **负载过高** | `/proc/loadavg` → `top` | 确认负载源头 |
| **历史问题分析** | `sar` 查历史数据 | 分析问题发生时的系统状态 |

### 9.3 关键理解要点


**🔹 性能监控的层次性**：
```
应用层面：哪个程序有问题？ → iotop, top
系统层面：哪个子系统有问题？ → iostat, sar  
硬件层面：哪个硬件设备有问题？ → /proc/interrupts
```

**🔹 数据的时间维度**：
- **实时数据**：iftop、iotop看当前状况
- **短期趋势**：iostat、sar看几分钟内变化
- **长期统计**：/proc/stat、sar历史数据看整体情况

**🔹 专用 vs 通用工具**：
- **专用工具**：功能专一但深入（iftop看网络，iotop看I/O）
- **通用工具**：功能全面但相对简单（sar什么都能看）
- **选择原则**：先用通用工具定位问题域，再用专用工具深入分析

### 9.4 实用记忆技巧


**📖 命令名记忆法**：
- **iostat**：I/O Statistics（I/O统计）
- **sar**：System Activity Reporter（系统活动报告）
- **nfsstat**：NFS Statistics（NFS统计）
- **iftop**：Interface TOP（网络接口流量排行）
- **iotop**：I/O TOP（I/O使用排行）

**🎯 快速判断口诀**：
- **负载高看loadavg，I/O慢看iostat**
- **进程I/O用iotop，网络流量用iftop**
- **历史数据找sar，中断问题看interrupts**
- **全面分析用sar，专项分析用专用工具**

**核心记忆**：
- 系统监控工具各有专长，根据问题类型选择合适工具
- 性能问题排查要分层次：先整体后局部，先定位后深入
- 实时监控和历史分析相结合，才能全面了解系统状况
- 理解工具原理比记住参数更重要，知其然更要知其所以然