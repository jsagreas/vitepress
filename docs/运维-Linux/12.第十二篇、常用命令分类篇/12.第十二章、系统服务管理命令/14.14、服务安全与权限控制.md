---
title: 14、服务安全与权限控制
---
## 📚 目录

1. [服务安全概述](#1-服务安全概述)
2. [用户与权限控制](#2-用户与权限控制)
3. [文件系统隔离](#3-文件系统隔离)
4. [系统保护机制](#4-系统保护机制)
5. [系统调用过滤](#5-系统调用过滤)
6. [能力边界控制](#6-能力边界控制)
7. [实践配置示例](#7-实践配置示例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 服务安全概述


### 1.1 为什么需要服务安全控制


**安全风险理解**：
```
想象你的Linux系统就像一栋大楼：
┌─────────────────────┐
│     系统内核        │ ← 大楼的地基和结构
├─────────────────────┤
│   重要系统文件      │ ← 大楼的重要设施
├─────────────────────┤
│   用户数据目录      │ ← 各个房间
├─────────────────────┤
│   各种服务程序      │ ← 在楼里工作的人员
└─────────────────────┘

如果服务程序（工作人员）权限太大：
• 可能误删重要文件（破坏设施）
• 可能访问其他用户数据（进入别人房间）
• 被攻击后影响整个系统（危害整栋楼）
```

### 1.2 systemd安全机制核心思想


**🎯 安全原则**：
- **最小权限**：服务只拥有完成任务所需的最小权限
- **隔离运行**：不同服务之间互不影响
- **访问控制**：限制服务能访问的文件和资源
- **系统保护**：防止服务破坏重要系统文件

---

## 2. 👤 用户与权限控制


### 2.1 User= 和 Group= 指定运行身份


**🔸 基本概念**：
默认情况下，系统服务以root用户运行，这很危险。通过指定专用用户，可以大大降低安全风险。

**实际应用理解**：
```bash
# 以root运行的风险
[Service]
ExecStart=/usr/bin/myapp
# 危险：如果myapp被攻击，攻击者获得root权限

# 安全的做法
[Service]
User=webapp
Group=webapp
ExecStart=/usr/bin/myapp
# 安全：即使被攻击，攻击者只能获得webapp用户权限
```

### 2.2 动态用户创建


**🔸 DynamicUser=true 的作用**：

这个功能让systemd自动为服务创建临时用户，服务停止后用户自动删除。

```ini
[Service]
DynamicUser=true
ExecStart=/usr/bin/myapp

# systemd会自动：
# 1. 创建临时用户（如 systemd-123456）
# 2. 服务运行在这个用户下
# 3. 服务停止后删除这个用户
```

**💡 使用场景**：
- ✅ **临时服务**：不需要持久化用户的服务
- ✅ **测试环境**：快速部署测试服务
- ❌ **数据持久化**：需要保存文件的服务（用户删除后文件权限会有问题）

### 2.3 用户配置对比


| 配置方式 | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|-------------|
| 默认root | `权限充足，兼容性好` | `安全风险极高` | `系统核心服务` |
| 指定用户 | `安全性好，权限可控` | `需要手动创建用户` | `长期运行的应用服务` |
| 动态用户 | `安全且自动管理` | `不能持久化数据` | `无状态服务` |

---

## 3. 📁 文件系统隔离


### 3.1 PrivateTmp= 临时目录隔离


**🔸 概念解释**：
Linux中的`/tmp`目录是所有用户共享的临时文件存储区域。如果多个程序都在这里创建文件，可能会：
- 互相干扰（文件名冲突）
- 信息泄露（其他程序读取临时文件）
- 安全风险（恶意程序替换临时文件）

```ini
# 不使用隔离（默认）
[Service]
ExecStart=/usr/bin/myapp
# myapp在 /tmp 创建文件，其他程序也能看到

# 使用临时目录隔离
[Service]
PrivateTmp=true
ExecStart=/usr/bin/myapp
# myapp看到的是独立的 /tmp，其他程序无法访问
```

**实际效果演示**：
```
服务A（PrivateTmp=false）     服务B（PrivateTmp=false）
        ↓                            ↓
     /tmp/fileA  ←→  /tmp/fileB  （可以互相看到）

服务A（PrivateTmp=true）      服务B（PrivateTmp=true）  
        ↓                            ↓
   /tmp/fileA                   /tmp/fileB  （完全隔离）
```

### 3.2 ReadOnlyPaths= 只读路径保护


**🔸 工作原理**：
将指定的目录设置为只读，服务无法修改这些位置的文件。

```ini
[Service]
ReadOnlyPaths=/etc /usr
ExecStart=/usr/bin/myapp

# 效果：myapp无法修改 /etc 和 /usr 下的任何文件
# 尝试写入会返回"权限不足"错误
```

**💡 实际应用场景**：
```
Web服务器配置：
ReadOnlyPaths=/etc/nginx /usr/share/nginx

数据库服务配置：
ReadOnlyPaths=/etc/mysql /usr/bin

# 这样即使服务被攻击，也无法修改配置文件和程序文件
```

### 3.3 InaccessiblePaths= 路径隐藏


**🔸 概念理解**：
让服务"看不到"指定的目录，就像这些目录不存在一样。

```ini
[Service]
InaccessiblePaths=/home /root /etc/shadow
ExecStart=/usr/bin/myapp

# myapp尝试访问 /home 时，系统返回"目录不存在"
# 实际上目录存在，但对这个服务不可见
```

---

## 4. 🛡️ 系统保护机制


### 4.1 ProtectSystem= 系统目录保护


**🔸 保护级别说明**：

| 级别 | **保护范围** | **具体效果** |
|-----|-------------|-------------|
| `false` | `无保护` | `服务可以修改任何系统文件` |
| `true` | `基本保护` | `/usr, /boot, /efi` 变为只读 |
| `full` | `完全保护` | `除了 /etc 外所有系统目录只读` |
| `strict` | `严格保护` | `整个文件系统只读，只能写入明确允许的目录` |

**实际配置示例**：
```ini
# Web服务器 - 基本保护就够了
[Service]
ProtectSystem=true
ExecStart=/usr/sbin/nginx

# 应用服务 - 需要完全保护
[Service]
ProtectSystem=full
ExecStart=/opt/myapp/bin/server

# 高安全要求服务 - 严格保护
[Service]
ProtectSystem=strict
ReadWritePaths=/var/log/myservice /var/lib/myservice
ExecStart=/usr/bin/secure-service
```

### 4.2 ProtectHome= 家目录保护


**🔸 保护原理**：
防止服务访问用户的个人文件，保护隐私。

```ini
# 完全隐藏家目录
[Service]
ProtectHome=true
# 服务看不到 /home 目录

# 只读访问家目录
[Service]
ProtectHome=read-only
# 服务可以读取但不能修改 /home 中的文件

# 临时家目录
[Service]
ProtectHome=tmpfs
# 服务看到空的 /home 目录
```

### 4.3 ProtectKernelTunables= 内核参数保护


**🔸 作用说明**：
防止服务修改内核运行参数，这些参数影响整个系统的行为。

```ini
[Service]
ProtectKernelTunables=true
# 禁止修改 /proc/sys, /sys 等内核接口文件
```

---

## 5. 🔍 系统调用过滤


### 5.1 SystemCallFilter= 基本概念


**🔸 什么是系统调用**：
程序想要完成任务（如读文件、网络通信），必须请求内核帮忙，这种请求就是系统调用。

```
程序执行流程：
应用程序 → 系统调用 → 内核 → 硬件
   ↓           ↓        ↓      ↓
read()    sys_read()  磁盘驱动 读取磁盘

危险的系统调用：
• reboot() - 重启系统
• mount() - 挂载文件系统
• ptrace() - 调试其他进程
```

### 5.2 过滤规则配置


**🔸 白名单模式（推荐）**：
```ini
[Service]
SystemCallFilter=@system-service
# 只允许系统服务需要的系统调用

# 常用的系统调用组：
# @basic-io     - 基本输入输出
# @file-system  - 文件系统操作
# @network-io   - 网络操作
# @system-service - 系统服务常用调用
```

**🔸 黑名单模式**：
```ini
[Service]
SystemCallFilter=~@privileged @resources
# 禁止特权操作和资源管理相关的系统调用
```

### 5.3 系统调用组说明


| 调用组 | **包含功能** | **适用服务** |
|--------|-------------|-------------|
| `@basic-io` | `读写文件、标准输入输出` | `所有服务的基础` |
| `@network-io` | `网络通信、Socket操作` | `Web服务器、API服务` |
| `@file-system` | `文件系统操作、目录管理` | `文件处理服务` |
| `@privileged` | `系统管理、特权操作` | `一般服务应禁止` |

---

## 6. ⚡ 能力边界控制


### 6.1 CapabilityBoundingSet= 概念理解


**🔸 什么是Linux能力（Capabilities）**：
传统上，Linux程序要么是普通用户（权限有限），要么是root（权限巨大）。能力机制提供了更细粒度的权限控制。

```
传统模式：
普通用户 ────────────── root用户
  ↓                      ↓
权限很少                权限巨大

能力模式：
普通用户 + 特定能力 = 精确权限
  ↓
只拥有完成任务需要的最小权限
```

### 6.2 常用能力说明


| 能力 | **作用** | **使用场景** |
|-----|---------|-------------|
| `CAP_NET_BIND_SERVICE` | `绑定1024以下端口` | `Web服务器绑定80/443端口` |
| `CAP_DAC_OVERRIDE` | `忽略文件权限检查` | `备份程序读取所有文件` |
| `CAP_SETUID` | `改变进程用户ID` | `登录程序切换用户身份` |
| `CAP_SYS_TIME` | `修改系统时间` | `时间同步服务` |
| `CAP_NET_RAW` | `使用原始Socket` | `网络监控工具` |

### 6.3 能力控制配置


**🔸 移除所有能力（最安全）**：
```ini
[Service]
User=webapp
CapabilityBoundingSet=
# 完全移除所有特殊能力，最安全但功能受限
```

**🔸 保留必要能力**：
```ini
[Service]
User=nginx
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
# nginx需要绑定80端口，只保留这一个能力
```

### 6.4 NoNewPrivileges= 权限提升控制


**🔸 作用说明**：
防止服务通过执行其他程序获得更高权限。

```ini
[Service]
NoNewPrivileges=true
# 即使服务执行了setuid程序，也不会获得更高权限
```

**实际效果**：
```bash
# 没有 NoNewPrivileges 时
service程序 → 执行 /usr/bin/sudo → 获得root权限 ❌

# 有 NoNewPrivileges=true 时  
service程序 → 执行 /usr/bin/sudo → 权限不变 ✅
```

---

## 7. 🛠️ 实践配置示例


### 7.1 Web服务器安全配置


```ini
[Unit]
Description=Secure Web Server
After=network.target

[Service]
Type=simple
User=nginx
Group=nginx
ExecStart=/usr/sbin/nginx -g "daemon off;"

# 基础安全设置
PrivateTmp=true
ProtectSystem=full
ProtectHome=true
NoNewPrivileges=true

# 文件系统保护
ReadOnlyPaths=/etc/nginx
ReadWritePaths=/var/log/nginx /var/cache/nginx

# 系统调用过滤
SystemCallFilter=@system-service
SystemCallFilter=~@privileged @resources

# 能力控制
CapabilityBoundingSet=CAP_NET_BIND_SERVICE

[Install]
WantedBy=multi-user.target
```

### 7.2 数据库服务安全配置


```ini
[Unit]
Description=Secure Database Service
After=network.target

[Service]
Type=notify
User=mysql
Group=mysql
ExecStart=/usr/bin/mysqld

# 高级安全设置
PrivateTmp=true
PrivateNetwork=false
ProtectSystem=strict
ProtectHome=true
ProtectKernelTunables=true
ProtectControlGroups=true

# 文件系统访问控制
ReadWritePaths=/var/lib/mysql /var/log/mysql
InaccessiblePaths=/home /root

# 系统调用限制
SystemCallFilter=@system-service @basic-io @file-system
SystemCallFilter=~@mount @swap @reboot @privileged

# 完全移除特权能力
CapabilityBoundingSet=
NoNewPrivileges=true

[Install]
WantedBy=multi-user.target
```

### 7.3 应用服务通用模板


```ini
[Unit]
Description=Secure Application Service
After=network.target

[Service]
Type=simple
DynamicUser=true
ExecStart=/opt/myapp/bin/server

# 标准安全配置
PrivateTmp=true
ProtectSystem=full
ProtectHome=true
NoNewPrivileges=true
ProtectKernelTunables=true

# 根据需要调整的部分
ReadWritePaths=/var/log/myapp /var/lib/myapp
SystemCallFilter=@system-service
CapabilityBoundingSet=

[Install]
WantedBy=multi-user.target
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的安全配置


```
🔸 用户控制：User=/Group= 指定运行用户，避免root权限
🔸 目录隔离：PrivateTmp=true 创建独立的临时目录
🔸 系统保护：ProtectSystem=full 保护重要系统文件
🔸 权限控制：NoNewPrivileges=true 防止权限提升
🔸 路径限制：ReadOnlyPaths= 设置只读目录保护
🔸 调用过滤：SystemCallFilter= 限制危险的系统调用
🔸 能力边界：CapabilityBoundingSet= 精确控制特权能力
```

### 8.2 安全配置最佳实践


**🔹 渐进式安全加固**：
```
第一步：指定专用用户
User=myservice
Group=myservice

第二步：基础文件保护
PrivateTmp=true
ProtectSystem=full
ProtectHome=true

第三步：高级安全特性
NoNewPrivileges=true
SystemCallFilter=@system-service
CapabilityBoundingSet=

第四步：根据具体需求调整
ReadWritePaths=/var/log/myservice
SystemCallFilter=~@privileged
```

**🔹 常见配置误区**：
```
❌ 错误：所有服务都用root运行
✅ 正确：为每个服务创建专用用户

❌ 错误：ProtectSystem=strict 但没设置ReadWritePaths  
✅ 正确：strict保护 + 明确指定可写目录

❌ 错误：SystemCallFilter设置过于严格导致服务无法启动
✅ 正确：从宽松开始，逐步收紧权限
```

### 8.3 实际应用指导


**🎯 不同类型服务的安全策略**：

| 服务类型 | **安全级别** | **推荐配置** |
|---------|-------------|-------------|
| `Web服务器` | `中等` | `ProtectSystem=full + 端口绑定能力` |
| `数据库` | `高` | `ProtectSystem=strict + 严格调用过滤` |
| `临时服务` | `高` | `DynamicUser=true + 最小权限` |
| `系统服务` | `中等` | `保留必要的系统管理能力` |

**🔧 排查配置问题的方法**：
```bash
# 查看服务启动失败原因
sudo journalctl -u myservice.service -f

# 常见错误和解决方案：
Permission denied → 检查ReadWritePaths设置
Operation not permitted → 检查SystemCallFilter配置  
Cannot bind to port → 添加CAP_NET_BIND_SERVICE能力
```

**核心记忆**：
- 服务安全三原则：**最小权限**、**隔离运行**、**访问控制**
- 配置顺序：**用户身份** → **文件保护** → **系统调用** → **能力边界**
- 调试方法：**逐步放宽** → **确认功能** → **逐步收紧** → **测试稳定**
- 实践要点：**先功能再安全**，**渐进式加固**，**充分测试**