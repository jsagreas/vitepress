---
title: 4、服务状态查询命令
---
## 📚 目录

1. [服务状态查询概述](#1-服务状态查询概述)
2. [systemctl状态查询命令](#2-systemctl状态查询命令)
3. [进程级别状态查询](#3-进程级别状态查询)
4. [网络端口监听检查](#4-网络端口监听检查)
5. [文件句柄查看](#5-文件句柄查看)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 服务状态查询概述


### 1.1 什么是服务状态查询


**🔸 核心概念**
服务状态查询就是检查Linux系统中各种服务程序的运行情况，类似于我们查看手机上的应用程序是否在后台运行一样。

```
日常生活类比：
检查服务状态 = 查看手机后台应用
- 哪些应用在运行？(is-active)
- 哪些会开机自启？(is-enabled) 
- 哪些运行异常？(is-failed)
- 手机系统正常吗？(is-system-running)
```

**💡 为什么需要查询服务状态**
```
实际应用场景：
🔸 网站无法访问 → 检查Web服务是否运行
🔸 数据库连接失败 → 确认数据库服务状态
🔸 开机后服务未启动 → 查看自启动配置
🔸 系统运行缓慢 → 排查异常服务
```

### 1.2 状态查询的层次结构


```
Linux服务状态查询体系：

系统层面
├── 整体系统运行状态
└── 服务管理器状态

服务层面  
├── 服务运行状态（active/inactive）
├── 服务启用状态（enabled/disabled）
└── 服务失败状态（failed/success）

进程层面
├── 进程是否存在
├── 进程资源占用
└── 进程树关系

网络层面
├── 端口监听状态
├── 网络连接情况  
└── 服务绑定端口
```

---

## 2. ⚙️ systemctl状态查询命令


### 2.1 is-active：检查服务运行状态


**🔸 命令含义**
`is-active`用来检查服务当前是否正在运行，就像问"这个程序现在开着吗？"

```bash
systemctl is-active 服务名
```

**💻 基本用法示例**
```bash
# 检查SSH服务是否运行
systemctl is-active ssh
# 返回：active（运行中）或 inactive（未运行）

# 检查Apache Web服务
systemctl is-active apache2
# 返回：active 或 inactive

# 批量检查多个服务
systemctl is-active ssh apache2 mysql
```

**📊 返回状态说明**

| 状态 | 含义 | 说明 |
|------|------|------|
| **active** | `运行中` | 服务正常工作 |
| **inactive** | `未运行` | 服务已停止 |
| **activating** | `启动中` | 服务正在启动过程中 |
| **deactivating** | `停止中` | 服务正在关闭过程中 |

**🛠️ 实际应用场景**
```bash
# 网站打不开时检查Web服务
systemctl is-active nginx
# 如果返回inactive，说明nginx没有运行

# 数据库连接失败时检查
systemctl is-active mysql
# 可以快速确定是否是数据库服务的问题
```

### 2.2 is-enabled：检查开机启动状态


**🔸 命令含义**
`is-enabled`检查服务是否设置为开机自动启动，就像问"这个程序会开机自动运行吗？"

```bash
systemctl is-enabled 服务名
```

**💻 实用示例**
```bash
# 检查SSH是否开机自启
systemctl is-enabled ssh
# 返回：enabled（会自启）或 disabled（不会自启）

# 检查防火墙开机启动状态
systemctl is-enabled ufw

# 检查时间同步服务
systemctl is-enabled ntp
```

**📋 返回状态详解**

| 状态 | 含义 | 实际意义 |
|------|------|----------|
| **enabled** | `已启用` | 开机会自动启动 |
| **disabled** | `已禁用` | 开机不会自动启动 |
| **static** | `静态` | 被其他服务依赖时启动 |
| **masked** | `已屏蔽` | 完全禁止启动 |

**🎯 实际应用价值**
```
为什么要检查开机启动状态？

服务器重启后问题排查：
✅ 重启前：systemctl is-enabled mysql → enabled
✅ 重启后：服务自动启动，网站正常

❌ 重启前：systemctl is-enabled mysql → disabled  
❌ 重启后：数据库未启动，网站报错

解决方案：systemctl enable mysql
```

### 2.3 is-failed：检查服务失败状态


**🔸 命令含义**
`is-failed`专门检查服务是否启动失败，就像问"这个程序启动时出错了吗？"

```bash
systemctl is-failed 服务名
```

**💻 故障排查示例**
```bash
# 服务启动异常时检查
systemctl is-failed apache2
# 返回：active（正常）或 failed（失败）

# 批量检查系统中失败的服务
systemctl --failed
```

**⚠️ 失败状态处理**
```bash
# 发现服务失败后的处理流程
systemctl is-failed mysql
# 如果返回 failed

# 1. 查看详细错误信息
systemctl status mysql

# 2. 查看日志分析原因  
journalctl -u mysql

# 3. 修复后重启服务
systemctl restart mysql
```

### 2.4 is-system-running：系统整体运行状态


**🔸 命令含义**
检查整个systemd系统的运行状态，就像问"我的Linux系统整体运行正常吗？"

```bash
systemctl is-system-running
```

**📊 系统状态说明**

```
系统运行状态层次：

🟢 running     → 系统完全正常运行
🟡 degraded    → 系统运行但有服务失败  
🔴 maintenance → 系统处于维护模式
🟠 initializing → 系统正在初始化
🔴 starting    → 系统正在启动
🔴 stopping    → 系统正在关闭
```

**🔧 实际应用**
```bash
# 系统启动完成后检查
systemctl is-system-running
# running：一切正常
# degraded：有服务异常，需要检查

# 如果是degraded状态，查看哪些服务有问题
systemctl --failed
```

---

## 3. 🔍 进程级别状态查询


### 3.1 ps命令查看服务进程


**🔸 核心概念**
`ps aux | grep` 是通过查看系统进程来确认服务是否真正在运行，这是最底层的检查方式。

```bash
ps aux | grep 服务名
```

**💡 命令参数解释**
```
ps aux 参数含义：
a → 显示所有用户的进程
u → 显示详细信息（用户、CPU、内存等）
x → 显示没有控制终端的进程

| grep → 管道符，筛选包含指定关键字的行
```

**💻 实际使用示例**
```bash
# 查看nginx相关进程
ps aux | grep nginx
# 输出示例：
# root      1234  0.0  0.1  nginx: master process
# www-data  1235  0.0  0.2  nginx: worker process

# 查看MySQL数据库进程  
ps aux | grep mysql
# 可以看到mysqld进程信息

# 查看SSH服务进程
ps aux | grep ssh
# 可以看到sshd进程
```

**📋 进程信息解读**
```
ps aux输出字段含义：
USER     → 运行进程的用户
PID      → 进程ID号  
%CPU     → CPU使用率
%MEM     → 内存使用率
COMMAND  → 完整的命令行
```

### 3.2 pgrep：进程名查找进程ID


**🔸 命令含义**
`pgrep`是"process grep"的缩写，专门用来根据进程名查找进程ID，比grep更精确。

```bash
pgrep 进程名
```

**💻 实用示例**
```bash
# 查找nginx进程ID
pgrep nginx
# 输出：1234 1235（所有nginx进程的PID）

# 查找MySQL进程  
pgrep mysql
# 输出：5678

# 同时显示进程名和PID
pgrep -l nginx
# 输出：1234 nginx 1235 nginx
```

**🎯 pgrep vs grep的区别**
```
ps aux | grep nginx：
✅ 显示完整进程信息
❌ 可能包含grep自身进程
❌ 输出信息较多

pgrep nginx：  
✅ 只返回进程ID，简洁
✅ 不会包含grep进程
❌ 信息相对简单
```

### 3.3 pidof：服务进程ID查找


**🔸 命令含义**
`pidof`专门用来查找正在运行的程序的进程ID，功能类似pgrep但更专业。

```bash
pidof 程序名
```

**💻 使用示例**
```bash
# 查找SSH服务的进程ID
pidof sshd
# 输出：1123

# 查找nginx的进程ID
pidof nginx  
# 输出：1234 1235

# 如果程序未运行，无输出
pidof not-running-service
# 无输出
```

**⚡ 快速判断服务状态**
```bash
# 编写简单的状态检查脚本
if pidof nginx > /dev/null; then
    echo "nginx正在运行"
else  
    echo "nginx未运行"
fi
```

---

## 4. 🌐 网络端口监听检查


### 4.1 netstat：网络连接状态查看


**🔸 核心概念**
`netstat`用来显示网络连接、路由表、接口统计等信息，通过检查端口监听状态来确认服务是否正常工作。

```bash
netstat -tuln
```

**💡 参数含义详解**
```
netstat参数说明：
-t → 显示TCP连接
-u → 显示UDP连接  
-l → 只显示监听状态的端口
-n → 用数字显示地址和端口号（不解析域名）
```

**💻 实际应用示例**
```bash
# 查看所有监听的端口
netstat -tuln
# 输出示例：
# Proto Recv-Q Send-Q Local Address   Foreign Address State
# tcp   0      0      0.0.0.0:22      0.0.0.0:*       LISTEN
# tcp   0      0      0.0.0.0:80      0.0.0.0:*       LISTEN

# 检查特定端口是否在监听
netstat -tuln | grep :80
# 如果有输出，说明80端口有服务在监听

# 检查SSH服务（22端口）
netstat -tuln | grep :22
```

**📊 常见服务端口对照表**

| 服务 | 端口 | 协议 | 说明 |
|------|------|------|------|
| **SSH** | `22` | TCP | 远程登录服务 |
| **HTTP** | `80` | TCP | Web服务 |
| **HTTPS** | `443` | TCP | 加密Web服务 |
| **MySQL** | `3306` | TCP | 数据库服务 |
| **DNS** | `53` | UDP | 域名解析服务 |

### 4.2 ss：现代网络状态查看工具


**🔸 命令优势**
`ss`是`netstat`的现代替代品，速度更快，功能更强大，是新版Linux系统推荐使用的网络状态查看工具。

```bash
ss -tuln
```

**💻 实用示例**
```bash
# 查看监听端口
ss -tuln
# 输出格式类似netstat但更快

# 查看特定端口
ss -tuln | grep :80

# 显示进程信息
ss -tulnp
# -p参数显示使用端口的进程名和PID
```

**⚡ ss vs netstat性能对比**
```
在大型服务器上：
netstat → 扫描/proc目录，较慢
ss      → 直接从内核获取信息，快速

建议：
新系统 → 优先使用ss
旧系统 → 使用netstat（兼容性好）
```

---

## 5. 📁 文件句柄查看


### 5.1 lsof：服务文件句柄查看


**🔸 核心概念**
`lsof`（List Open Files）显示系统中被打开的文件，由于Linux中"一切皆文件"，网络连接、设备等都是文件，所以lsof能看到服务占用的各种资源。

```bash
lsof -i :端口号
```

**💡 为什么查看文件句柄**
```
服务运行时会占用：
🔸 配置文件      → 读取设置
🔸 日志文件      → 写入日志  
🔸 网络端口      → 对外提供服务
🔸 数据库文件    → 存储数据
🔸 临时文件      → 处理缓存

通过lsof可以：
✅ 确认服务真正在工作
✅ 查看服务占用的资源
✅ 排查文件占用问题
```

**💻 实际使用示例**
```bash
# 查看80端口被哪个进程占用
lsof -i :80
# 输出：
# COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
# nginx   1234 root   6u  IPv4  12345      0t0  TCP *:http (LISTEN)

# 查看MySQL数据库占用的文件
lsof -c mysql
# 显示所有mysql相关进程打开的文件

# 查看特定进程打开的文件
lsof -p 1234
# 查看PID为1234的进程打开的所有文件
```

**📋 lsof输出字段含义**
```
字段解释：
COMMAND  → 进程命令名
PID      → 进程ID  
USER     → 运行用户
FD       → 文件描述符
TYPE     → 文件类型
NAME     → 文件名或网络连接
```

**🔧 故障排查应用**
```bash
# 服务无法启动，提示端口被占用
lsof -i :80
# 找到占用80端口的进程，决定是否需要停止

# 日志文件无法写入
lsof | grep /var/log/nginx/access.log  
# 查看是否有其他进程占用日志文件

# 磁盘空间不足，但删除文件后空间未释放
lsof | grep deleted
# 查看被删除但仍被进程占用的文件
```

---

## 6. 🎯 实际应用场景


### 6.1 Web服务故障排查流程


```
网站无法访问故障排查：

第一步：检查服务状态
systemctl is-active nginx
├── active → 服务运行正常，检查配置
└── inactive → 服务未运行，尝试启动

第二步：检查端口监听  
ss -tuln | grep :80
├── 有监听 → 网络层正常，检查应用
└── 无监听 → 服务可能启动失败

第三步：检查进程状态
ps aux | grep nginx  
├── 有进程 → 进程存在，检查配置文件
└── 无进程 → 进程异常退出，查看日志

第四步：检查详细状态
systemctl status nginx
├── 查看启动失败原因
└── 根据错误信息修复问题
```

**💻 实战示例**
```bash
# 完整的Web服务检查脚本
#!/bin/bash
echo "=== 检查nginx服务状态 ==="

# 1. 检查systemctl状态
echo "服务运行状态：$(systemctl is-active nginx)"
echo "开机启动状态：$(systemctl is-enabled nginx)"

# 2. 检查端口监听
echo "端口监听检查："
ss -tuln | grep :80

# 3. 检查进程
echo "进程检查："  
pgrep -l nginx

# 4. 检查文件句柄
echo "端口占用检查："
lsof -i :80
```

### 6.2 数据库服务监控


**🔸 MySQL服务全面检查**
```bash
# 数据库服务状态检查
systemctl is-active mysql && echo "MySQL运行正常" || echo "MySQL未运行"

# 检查数据库端口
ss -tuln | grep :3306 && echo "数据库端口监听正常" || echo "数据库端口未监听"

# 检查数据库进程
pgrep mysql > /dev/null && echo "MySQL进程存在" || echo "MySQL进程不存在"

# 检查数据库连接
mysql -u root -p -e "SELECT 1;" && echo "数据库连接正常" || echo "数据库连接失败"
```

### 6.3 系统服务批量检查


**💻 批量服务状态监控脚本**
```bash
#!/bin/bash
# 重要服务列表
services=("ssh" "nginx" "mysql" "ufw")

echo "=== 系统服务状态报告 ==="
printf "%-10s %-10s %-10s %-10s\n" "服务名" "运行状态" "启动状态" "失败状态"
echo "----------------------------------------"

for service in "${services[@]}"; do
    active=$(systemctl is-active $service)
    enabled=$(systemctl is-enabled $service)  
    failed=$(systemctl is-failed $service)
    
    printf "%-10s %-10s %-10s %-10s\n" $service $active $enabled $failed
done
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 服务状态查询：确认Linux服务程序运行情况的方法
🔸 systemctl查询：现代Linux系统标准的服务状态检查工具
🔸 进程级查询：从底层进程角度验证服务运行状态  
🔸 网络端口检查：通过端口监听状态判断服务是否对外提供服务
🔸 文件句柄查看：深入了解服务占用的系统资源
```

### 7.2 关键命令速查表


| 用途 | 命令 | 返回结果 | 使用场景 |
|------|------|----------|----------|
| **服务运行状态** | `systemctl is-active 服务名` | active/inactive | 快速检查服务是否运行 |
| **开机启动状态** | `systemctl is-enabled 服务名` | enabled/disabled | 检查服务开机自启配置 |
| **服务失败状态** | `systemctl is-failed 服务名` | active/failed | 排查服务启动失败问题 |
| **系统运行状态** | `systemctl is-system-running` | running/degraded | 检查系统整体健康状态 |
| **进程查看** | `ps aux \| grep 服务名` | 进程详细信息 | 底层验证进程是否存在 |
| **进程ID查找** | `pgrep/pidof 服务名` | 进程ID号 | 快速获取进程ID |
| **端口监听检查** | `ss -tuln \| grep :端口` | 监听状态 | 确认服务网络监听状态 |
| **文件句柄查看** | `lsof -i :端口` | 占用进程信息 | 深入分析服务资源占用 |

### 7.3 实际应用价值


**🔹 故障排查思路**
```
层次化排查方法：
系统层 → systemctl is-system-running
服务层 → systemctl is-active/enabled/failed  
进程层 → ps/pgrep/pidof
网络层 → ss/netstat
资源层 → lsof

从上到下逐层排查，快速定位问题
```

**🔹 日常运维场景**
```
开机检查：is-enabled确保关键服务自启
运行监控：is-active定期检查服务状态
故障处理：is-failed快速发现异常服务
性能分析：lsof了解资源占用情况
```

**🔹 最佳实践建议**
- **定期检查**：建立服务状态检查脚本，定期执行
- **多层验证**：不只看systemctl状态，还要检查进程和端口
- **日志结合**：状态异常时及时查看系统日志分析原因
- **预防为主**：通过监控及时发现并解决潜在问题

**核心记忆**：
- systemctl查状态，is-active看运行
- ps和pgrep查进程，底层验证更可靠  
- ss和lsof看网络，端口资源全掌握
- 多层检查不遗漏，故障排查有章法