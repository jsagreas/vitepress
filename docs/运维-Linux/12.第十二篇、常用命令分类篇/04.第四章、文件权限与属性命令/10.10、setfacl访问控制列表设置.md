---
title: 10、setfacl访问控制列表设置
---
## 📚 目录

1. [ACL访问控制列表基础概念](#1-ACL访问控制列表基础概念)
2. [setfacl命令语法结构](#2-setfacl命令语法结构)
3. [用户与组ACL设置](#3-用户与组ACL设置)
4. [ACL权限精确控制](#4-ACL权限精确控制)
5. [默认ACL设置方法](#5-默认ACL设置方法)
6. [ACL条目删除与修改](#6-ACL条目删除与修改)
7. [递归ACL设置](#7-递归ACL设置)
8. [ACL备份与恢复](#8-ACL备份与恢复)
9. [ACL安全最佳实践](#9-ACL安全最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔐 ACL访问控制列表基础概念


### 1.1 什么是ACL

**ACL（Access Control List）** 是一种比传统Unix文件权限更灵活的权限控制机制。

**传统权限的限制：**
```
传统Linux权限模型：
┌─────────┬─────────┬─────────┐
│ 文件拥有者 │  所属组   │  其他用户 │
│   rwx    │   rwx    │   rwx   │
└─────────┴─────────┴─────────┘

问题：
- 只能设置一个用户和一个组的权限
- 无法为多个特定用户设置不同权限
- 权限控制粒度太粗
```

**ACL的优势：**
```
ACL权限模型：
┌──────────────────────────────────┐
│ 文件拥有者：rwx                    │
│ 用户alice：r-x                    │
│ 用户bob：rw-                      │
│ 所属组：r--                       │
│ 组developers：rwx                 │
│ 组testers：r-x                    │
│ 其他用户：---                     │
│ mask：rwx（有效权限掩码）           │
└──────────────────────────────────┘

优势：
✅ 为多个用户设置不同权限
✅ 为多个组设置不同权限
✅ 精确控制每个用户/组的访问权限
✅ 支持默认权限继承
```

### 1.2 ACL的工作原理


**权限检查顺序：**
```
用户访问文件时的权限检查流程：

1. 是否为文件拥有者？
   ├─ 是 → 使用拥有者权限
   └─ 否 → 继续检查

2. 是否在用户ACL列表中？
   ├─ 是 → 使用该用户ACL权限 & mask
   └─ 否 → 继续检查

3. 是否为文件所属组成员？
   ├─ 是 → 使用所属组权限 & mask
   └─ 否 → 继续检查

4. 是否在组ACL列表中？
   ├─ 是 → 使用该组ACL权限 & mask
   └─ 否 → 继续检查

5. 使用其他用户权限
```

### 1.3 ACL条目类型


| 条目类型 | **说明** | **格式示例** | **作用范围** |
|---------|---------|-------------|-------------|
| `user::` | 文件拥有者权限 | `user::rwx` | 文件拥有者 |
| `user:name:` | 指定用户权限 | `user:alice:r-x` | 特定用户alice |
| `group::` | 文件所属组权限 | `group::r--` | 文件所属组 |
| `group:name:` | 指定组权限 | `group:dev:rwx` | 特定组dev |
| `mask::` | 有效权限掩码 | `mask::rwx` | 限制最大权限 |
| `other::` | 其他用户权限 | `other::---` | 所有其他用户 |

---

## 2. ⚙️ setfacl命令语法结构


### 2.1 基本语法格式

```bash
setfacl [选项] [ACL规则] 文件或目录
```

### 2.2 常用选项参数


| 选项 | **含义** | **作用说明** | **使用场景** |
|------|---------|-------------|-------------|
| `-m` | **修改ACL** | 添加或修改ACL条目 | `最常用，设置权限` |
| `-x` | **删除ACL** | 删除指定ACL条目 | `移除特定权限` |
| `-b` | **删除所有ACL** | 清除所有扩展ACL | `重置权限设置` |
| `-k` | **删除默认ACL** | 只删除默认ACL条目 | `清理默认权限` |
| `-R` | **递归操作** | 对目录及子内容递归设置 | `批量设置权限` |
| `-d` | **设置默认ACL** | 为目录设置默认权限 | `权限继承设置` |
| `--set` | **完全替换** | 用新ACL完全替换现有ACL | `重新定义权限` |
| `--restore` | **恢复ACL** | 从备份文件恢复ACL | `权限恢复操作` |

### 2.3 ACL规则格式


**标准ACL规则语法：**
```
类型:名称:权限

示例解释：
user:alice:rwx    # 用户alice具有读写执行权限
group:dev:r-x     # 组dev具有读执行权限
user::rw-         # 文件拥有者具有读写权限
other::---        # 其他用户无任何权限
```

**权限字符含义：**
- `r` - 读权限（read）
- `w` - 写权限（write） 
- `x` - 执行权限（execute）
- `-` - 无该权限

---

## 3. 👥 用户与组ACL设置


### 3.1 为特定用户设置权限


**给用户alice设置读写权限：**
```bash
# 创建测试文件
touch /tmp/testfile.txt

# 为用户alice设置读写权限
setfacl -m user:alice:rw- /tmp/testfile.txt

# 查看设置结果
getfacl /tmp/testfile.txt
```

**预期输出：**
```
# file: /tmp/testfile.txt
# owner: root
# group: root
user::rw-
user:alice:rw-          # alice用户的ACL权限
group::r--
mask::rw-               # 自动生成的mask
other::r--
```

**为多个用户设置不同权限：**
```bash
# 同时为多个用户设置权限
setfacl -m user:alice:rw-,user:bob:r--,user:charlie:rwx /tmp/testfile.txt

# 分别设置（效果相同）
setfacl -m user:alice:rw- /tmp/testfile.txt
setfacl -m user:bob:r-- /tmp/testfile.txt  
setfacl -m user:charlie:rwx /tmp/testfile.txt
```

### 3.2 为特定组设置权限


**为开发组设置权限：**
```bash
# 为组developers设置读写执行权限
setfacl -m group:developers:rwx /tmp/project/

# 为测试组设置只读权限
setfacl -m group:testers:r-- /tmp/project/

# 查看权限设置
ls -l /tmp/project/
# 输出会显示 + 号，表示有扩展ACL权限
```

### 3.3 实际应用场景


**项目协作权限设置：**
```bash
# 创建项目目录
mkdir /home/project

# 项目负责人：完全权限
setfacl -m user:manager:rwx /home/project

# 开发人员：读写权限
setfacl -m group:developers:rw- /home/project

# 测试人员：只读权限
setfacl -m group:testers:r-- /home/project

# 实习生：无权限（明确拒绝）
setfacl -m user:intern:--- /home/project
```

---

## 4. 🎯 ACL权限精确控制


### 4.1 理解mask权限掩码


**mask的作用：**
mask是ACL中的关键概念，它**限制了除文件拥有者和其他用户外，所有用户和组的最大有效权限**。

```
权限计算公式：
有效权限 = 设置的ACL权限 & mask权限

示例说明：
用户alice设置权限：rwx (111)
当前mask权限：r-x (101)  
alice实际有效权限：r-x (101)   # 写权限被mask屏蔽
```

**查看和设置mask：**
```bash
# 查看当前ACL包含mask信息
getfacl /tmp/testfile.txt

# 手动设置mask权限
setfacl -m mask::r-x /tmp/testfile.txt

# 重新计算mask（自动优化）
setfacl -m mask::rwx /tmp/testfile.txt
```

### 4.2 权限验证实战


**创建测试环境：**
```bash
# 创建测试文件
echo "test content" > /tmp/acl_test.txt

# 设置复杂的ACL权限
setfacl -m user:alice:rwx /tmp/acl_test.txt
setfacl -m user:bob:r-- /tmp/acl_test.txt
setfacl -m group:developers:rw- /tmp/acl_test.txt
setfacl -m mask::r-x /tmp/acl_test.txt

# 查看最终权限
getfacl /tmp/acl_test.txt
```

**权限生效验证：**
```bash
# 切换到alice用户验证
su - alice
cat /tmp/acl_test.txt        # 可以读取
echo "new" >> /tmp/acl_test.txt  # 写入被mask限制，失败

# 切换到bob用户验证  
su - bob
cat /tmp/acl_test.txt        # 可以读取
```

### 4.3 权限冲突处理


**权限冲突的解决原则：**

1. **最小权限原则** - 实际权限不能超过mask设定的范围
2. **明确拒绝优先** - 如果设置了`---`权限，则完全拒绝访问
3. **组权限叠加** - 用户如果属于多个有ACL权限的组，取所有组权限的并集

```bash
# 处理权限冲突的示例
# 用户alice同时属于dev组和test组
setfacl -m user:alice:r-- /tmp/file        # alice个人权限：只读
setfacl -m group:dev:rw- /tmp/file         # dev组权限：读写
setfacl -m group:test:--x /tmp/file        # test组权限：执行
# alice最终权限：rwx（个人权限 + 所属组权限的并集）
```

---

## 5. 📁 默认ACL设置方法


### 5.1 什么是默认ACL


**默认ACL的概念：**
默认ACL只能设置在**目录**上，它定义了在该目录中新创建的文件和子目录自动继承的权限。

```
默认ACL工作流程：
┌─────────────────┐
│   父目录设置     │
│  default:ACL   │ 
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  新建文件/目录   │
│ 自动继承ACL权限  │
└─────────────────┘
```

### 5.2 设置默认ACL权限


**为目录设置默认ACL：**
```bash
# 创建项目目录
mkdir /home/shared_project

# 设置默认ACL - 新建文件自动继承这些权限
setfacl -d -m user:alice:rw- /home/shared_project
setfacl -d -m user:bob:r-- /home/shared_project  
setfacl -d -m group:developers:rwx /home/shared_project

# 或者一次性设置多个默认ACL
setfacl -d -m user:alice:rw-,user:bob:r--,group:developers:rwx /home/shared_project
```

**验证默认ACL生效：**
```bash
# 查看目录的默认ACL
getfacl /home/shared_project

# 在目录中创建新文件
touch /home/shared_project/newfile.txt
mkdir /home/shared_project/subdir

# 查看新文件是否继承了默认ACL
getfacl /home/shared_project/newfile.txt
getfacl /home/shared_project/subdir
```

### 5.3 默认ACL的继承规则


**文件与目录的继承差异：**

```bash
# 设置目录的默认ACL
setfacl -d -m user:alice:rwx /home/shared_project

# 在目录中创建文件和子目录
touch /home/shared_project/file.txt
mkdir /home/shared_project/subdir

# 查看继承结果
getfacl /home/shared_project/file.txt
# 文件继承：user:alice:rw- (自动去除执行权限)

getfacl /home/shared_project/subdir  
# 目录继承：user:alice:rwx (完整继承)
# 同时：default:user:alice:rwx (子目录也获得默认ACL)
```

**继承规则总结：**
- **新建普通文件**：继承默认ACL，但自动去除执行权限
- **新建目录**：完整继承默认ACL，同时自己也获得相同的默认ACL
- **现有文件**：不受默认ACL影响，需要手动设置

---

## 6. 🗑️ ACL条目删除与修改


### 6.1 删除特定ACL条目


**删除指定用户的ACL：**
```bash
# 删除用户alice的ACL权限
setfacl -x user:alice /tmp/testfile.txt

# 删除组developers的ACL权限  
setfacl -x group:developers /tmp/testfile.txt

# 同时删除多个ACL条目
setfacl -x user:alice,user:bob,group:testers /tmp/testfile.txt
```

**删除默认ACL条目：**
```bash
# 删除特定的默认ACL
setfacl -x default:user:alice /home/project/

# 删除所有默认ACL（保留普通ACL）
setfacl -k /home/project/
```

### 6.2 修改现有ACL条目


**修改用户权限：**
```bash
# alice原来有rwx权限，现在改为只读
setfacl -m user:alice:r-- /tmp/testfile.txt

# 修改组权限
setfacl -m group:developers:r-x /tmp/testfile.txt

# 修改mask权限
setfacl -m mask::rw- /tmp/testfile.txt
```

### 6.3 完全清除ACL设置


**清除所有扩展ACL：**
```bash
# 清除文件的所有ACL（保留基本权限）
setfacl -b /tmp/testfile.txt

# 递归清除目录及其所有内容的ACL
setfacl -R -b /home/project/

# 只清除默认ACL
setfacl -k /home/project/
```

**验证清除结果：**
```bash
# 查看ACL是否已清除
getfacl /tmp/testfile.txt
# 应该只显示基本的user::, group::, other:: 权限

# 使用ls查看文件权限
ls -l /tmp/testfile.txt
# 文件权限后面不应该有 + 号
```

---

## 7. 🔄 递归ACL设置


### 7.1 递归设置的必要性


**目录结构权限管理挑战：**
```
项目目录结构：
/home/project/
├── src/
│   ├── main.c
│   └── utils/
│       └── helper.c
├── docs/
│   └── readme.txt
└── tests/
    └── test.c

问题：需要为整个目录树设置统一的ACL权限
```

### 7.2 递归设置ACL权限


**基本递归设置：**
```bash
# 为整个目录树递归设置ACL
setfacl -R -m user:alice:rwx /home/project/
setfacl -R -m group:developers:rw- /home/project/
setfacl -R -m user:guest:r-- /home/project/

# 一次性设置多个ACL条目（递归）
setfacl -R -m user:alice:rwx,group:developers:rw-,user:guest:r-- /home/project/
```

**递归设置默认ACL：**
```bash
# 为所有子目录递归设置默认ACL
setfacl -R -d -m user:alice:rwx /home/project/
setfacl -R -d -m group:developers:rw- /home/project/

# 同时设置普通ACL和默认ACL
setfacl -R -m user:alice:rwx /home/project/        # 对现有文件生效
setfacl -R -d -m user:alice:rwx /home/project/     # 对新建文件生效
```

### 7.3 递归操作的注意事项


**⚠️ 递归操作风险：**
```bash
# 错误示例：不小心递归设置了系统目录
setfacl -R -m user:alice:rwx /etc/    # ❌ 危险！可能破坏系统

# 安全做法：先测试小范围
setfacl -m user:alice:rwx /home/project/single_file.txt  # 先测试
setfacl -R -m user:alice:rwx /home/project/               # 再递归
```

**递归性能优化：**
```bash
# 对于大目录树，使用并行处理
find /home/project -type f -exec setfacl -m user:alice:rw- {} +
find /home/project -type d -exec setfacl -m user:alice:rwx {} +
find /home/project -type d -exec setfacl -d -m user:alice:rwx {} +
```

---

## 8. 💾 ACL备份与恢复


### 8.1 备份ACL权限设置


**单个文件ACL备份：**
```bash
# 备份单个文件的ACL
getfacl /home/project/important.txt > /backup/important.txt.acl

# 查看备份文件内容
cat /backup/important.txt.acl
```

**目录树ACL批量备份：**
```bash
# 备份整个目录树的ACL权限
getfacl -R /home/project > /backup/project_acl_backup.txt

# 只备份有ACL权限的文件
find /home/project -exec getfacl {} \; > /backup/acl_backup.txt
```

### 8.2 恢复ACL权限设置


**从备份文件恢复ACL：**
```bash
# 恢复单个文件的ACL
setfacl --restore=/backup/important.txt.acl

# 恢复整个目录的ACL
setfacl --restore=/backup/project_acl_backup.txt
```

**恢复过程验证：**
```bash
# 恢复前后对比验证
getfacl /home/project/important.txt > /tmp/before_restore.txt
setfacl --restore=/backup/important.txt.acl
getfacl /home/project/important.txt > /tmp/after_restore.txt

# 对比差异
diff /tmp/before_restore.txt /tmp/after_restore.txt
```

### 8.3 ACL备份策略


**生产环境备份建议：**
```bash
#!/bin/bash
# ACL权限备份脚本
BACKUP_DIR="/backup/acl/$(date +%Y%m%d)"
mkdir -p $BACKUP_DIR

# 备份重要目录的ACL
for dir in /home /var/www /opt/applications; do
    if [ -d "$dir" ]; then
        echo "备份 $dir 的ACL权限..."
        getfacl -R "$dir" > "$BACKUP_DIR/$(basename $dir)_acl.backup"
    fi
done

# 压缩备份文件
tar -czf "$BACKUP_DIR.tar.gz" -C "$(dirname $BACKUP_DIR)" "$(basename $BACKUP_DIR)"
echo "ACL备份完成: $BACKUP_DIR.tar.gz"
```

---

## 9. 🔒 ACL安全最佳实践


### 9.1 权限设计原则


**最小权限原则：**
```bash
# ✅ 好的做法：按需分配最小权限
setfacl -m user:developer:rw- /project/source/     # 开发者：读写源码
setfacl -m user:tester:r-- /project/source/        # 测试者：只读源码
setfacl -m user:manager:rwx /project/              # 管理者：完全权限

# ❌ 不好的做法：给予过多权限
setfacl -m user:intern:rwx /project/               # 实习生不需要完全权限
```

**权限分层管理：**
```
权限层级设计：
┌─────────────────┐
│  超级管理员 rwx   │  系统管理员
├─────────────────┤
│  项目负责人 rwx   │  项目整体管理
├─────────────────┤  
│  开发人员   rw-   │  代码读写
├─────────────────┤
│  测试人员   r-x   │  测试执行
├─────────────────┤
│  访客用户   r--   │  只读查看
└─────────────────┘
```

### 9.2 常见安全陷阱


**mask权限陷阱：**
```bash
# 陷阱：设置了权限但mask限制了实际权限
setfacl -m user:alice:rwx /sensitive/file     # 设置alice完全权限
setfacl -m mask::r-- /sensitive/file          # mask限制为只读
# 结果：alice实际只有读权限，写和执行被屏蔽

# 解决：检查mask设置
getfacl /sensitive/file | grep mask
```

**默认ACL继承陷阱：**
```bash
# 陷阱：忘记设置默认ACL，新文件权限不一致
mkdir /project
setfacl -m user:alice:rwx /project            # 只对当前目录生效
touch /project/newfile                        # 新文件没有alice权限

# 解决：同时设置默认ACL
setfacl -d -m user:alice:rw- /project         # 新文件自动继承
```

### 9.3 ACL权限审计


**定期权限检查脚本：**
```bash
#!/bin/bash
# ACL权限审计脚本

echo "=== ACL权限审计报告 ==="
echo "审计时间: $(date)"
echo

# 查找所有有ACL权限的文件
echo "有ACL权限的文件列表:"
find /home /var /opt -type f -exec ls -l {} \; 2>/dev/null | grep "+"

echo
echo "详细ACL权限信息:"
find /home /var /opt -type f -exec getfacl {} \; 2>/dev/null | grep -E "^# file:|^user:|^group:" 

# 查找可疑的高权限设置
echo
echo "⚠️ 需要注意的高权限设置:"
getfacl -R /home 2>/dev/null | grep -B1 "rwx" | grep -E "user:|group:"
```

**权限合规检查：**
```bash
# 检查敏感目录的权限设置
check_sensitive_dirs() {
    local sensitive_dirs=("/etc" "/var/log" "/home" "/opt")
    
    for dir in "${sensitive_dirs[@]}"; do
        echo "检查目录: $dir"
        
        # 查找有写权限的外部用户
        getfacl -R "$dir" 2>/dev/null | grep -E "user:.*:.*w" | grep -v "user::"
        
        # 查找有执行权限的可疑设置
        getfacl -R "$dir" 2>/dev/null | grep -E "other::.*x"
    done
}
```

### 9.4 ACL与SELinux的配合


**在SELinux环境中使用ACL：**
```bash
# 查看SELinux状态
sestatus

# 设置ACL时考虑SELinux上下文
setfacl -m user:alice:rw- /var/www/html/index.html
ls -Z /var/www/html/index.html                    # 查看SELinux上下文

# 必要时调整SELinux上下文
restorecon /var/www/html/index.html
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 ACL本质：比传统权限更灵活的访问控制机制
🔸 核心组件：user、group、mask、other、default等条目类型
🔸 工作原理：按优先级检查权限，mask限制最大有效权限
🔸 继承机制：默认ACL控制新建文件的权限继承
🔸 命令语法：setfacl -m/-x/-b/-d + ACL规则 + 目标文件
```

### 10.2 关键理解要点


**🔹 mask权限掩码的理解**
```
关键概念：
- mask限制除owner和other外的所有权限上限
- 有效权限 = 设置权限 & mask权限
- 设置ACL时系统会自动计算合适的mask值
- 手动设置mask可以快速限制多个用户/组的权限
```

**🔹 默认ACL的继承规则**
```
继承特点：
- 只能在目录上设置默认ACL
- 新建文件继承默认ACL但去除执行权限
- 新建目录完整继承默认ACL并自己也获得默认ACL
- 现有文件不受默认ACL影响
```

**🔹 递归操作的适用场景**
```
使用时机：
- 新建目录树需要统一权限设置
- 批量修改大量文件的权限
- 权限迁移和同步操作
- 结合默认ACL实现权限模板
```

### 10.3 实际应用指导


**适用场景判断：**
```
✅ 适合使用ACL的场景：
- 多用户协作项目权限管理
- 细粒度的文件访问控制
- 需要权限继承的目录结构
- 复杂的组织架构权限映射

❌ 不适合使用ACL的场景：
- 简单的个人文件权限设置
- 系统核心文件的权限管理
- 对性能要求极高的场景
- 不支持ACL的文件系统
```

**常见命令组合：**
```bash
# 完整项目权限设置模板
setfacl -m user:manager:rwx /project/                    # 管理员权限
setfacl -m group:developers:rw- /project/                # 开发组权限
setfacl -m group:testers:r-- /project/                   # 测试组权限
setfacl -R -m user:manager:rwx /project/                 # 递归设置现有文件
setfacl -R -d -m user:manager:rwx /project/              # 设置默认权限
setfacl -R -d -m group:developers:rw- /project/          # 新文件继承权限
```

**故障排除checklist：**
```
ACL权限不生效排查步骤：
□ 检查文件系统是否支持ACL (mount | grep acl)
□ 确认ACL条目格式正确 (getfacl查看)
□ 检查mask权限是否限制了有效权限
□ 验证用户是否存在且拼写正确
□ 确认目录的默认ACL设置
□ 检查SELinux等安全机制的影响
```

### 10.4 安全使用建议


```
安全原则：
🔸 最小权限：只给必需的最小权限，定期审查
🔸 分层管理：建立清晰的权限层级结构
🔸 定期备份：重要权限设置要备份和版本控制
🔸 审计监控：定期检查ACL权限设置的合规性
🔸 测试验证：权限设置后要实际测试验证效果
```

**核心记忆要点：**
- ACL让权限控制更精确，一个文件可以给多个不同用户设置不同权限
- setfacl -m 设置权限，-x 删除权限，-b 清空权限，-d 默认权限
- mask是权限上限，限制所有命名用户和组的实际有效权限
- 默认ACL只能在目录设置，控制新建文件的权限继承
- 递归操作要谨慎，先小范围测试再大范围应用