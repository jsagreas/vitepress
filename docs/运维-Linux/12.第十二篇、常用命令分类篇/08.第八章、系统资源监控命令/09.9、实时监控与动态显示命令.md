---
title: 9、实时监控与动态显示命令
---
## 📚 目录

1. [watch命令周期性执行](#1-watch命令周期性执行)
2. [实时监控文件变化](#2-实时监控文件变化)  
3. [动态刷新监控数据](#3-动态刷新监控数据)
4. [tail -f日志实时跟踪](#4-tail--f日志实时跟踪)
5. [监控命令组合使用技巧](#5-监控命令组合使用技巧)
6. [自定义监控脚本基础](#6-自定义监控脚本基础)
7. [监控数据输出格式化](#7-监控数据输出格式化)
8. [实时告警阈值设置](#8-实时告警阈值设置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔄 watch命令周期性执行


### 1.1 watch命令基础概念


**什么是watch命令？**
watch命令就像一个"定时器"，它能够按照你设定的时间间隔，重复执行同一个命令，并把结果显示在屏幕上。想象一下，你需要每隔几秒钟查看一次系统状态，用watch就不用手动重复输入命令了。

**核心作用**：
- 🔸 **周期性执行**：每隔固定时间自动运行指定命令
- 🔸 **实时更新**：屏幕内容自动刷新，显示最新结果  
- 🔸 **差异高亮**：可以突出显示前后两次的变化部分
- 🔸 **连续监控**：适合观察系统状态的持续变化

### 1.2 watch命令基本语法


```bash
# 基本语法格式
watch [选项] 命令

# 常用选项说明
-n 秒数    # 设置执行间隔时间（默认2秒）
-d         # 高亮显示变化的部分
-t         # 关闭标题显示
-c         # 支持颜色输出
```

**语法解析**：
- `watch` 是命令名称
- `[选项]` 是可选的参数设置
- `命令` 是你要重复执行的具体命令

### 1.3 watch命令实用示例


**监控系统负载**
```bash
# 每2秒查看系统负载情况
watch uptime

# 每1秒查看，并高亮显示变化
watch -n 1 -d uptime
```

**监控磁盘使用情况**
```bash
# 每5秒检查磁盘空间
watch -n 5 df -h

# 监控特定目录大小变化
watch -n 3 'du -sh /var/log'
```

**观察进程状态**
```bash
# 监控特定用户的进程
watch -n 2 'ps aux | grep username'

# 观察内存使用情况
watch -d free -m
```

> 💡 **使用提示**：watch命令运行时按 `Ctrl+C` 可以退出监控

### 1.4 watch命令进阶技巧


**组合多个命令**
```bash
# 同时监控多个指标
watch -n 2 'echo "=== 系统负载 ===" && uptime && echo "=== 内存使用 ===" && free -m'
```

**监控网络连接**
```bash
# 观察网络连接数变化
watch -d 'netstat -an | wc -l'

# 监控特定端口
watch -n 1 'netstat -tulpn | grep :80'
```

**文件监控应用**
```bash
# 监控日志文件大小
watch -n 5 'ls -lh /var/log/messages'

# 观察目录文件数量变化
watch -d 'find /tmp -type f | wc -l'
```

---

## 2. 👁️ 实时监控文件变化


### 2.1 文件变化监控的重要性


**为什么需要监控文件变化？**
在Linux系统管理中，文件的变化往往反映了系统的运行状态。比如日志文件的增长表示系统活动，配置文件的修改可能影响服务运行。实时监控这些变化能帮助我们：

- 🔸 **及时发现问题**：异常的文件变化可能预示着系统问题
- 🔸 **追踪系统活动**：了解系统正在进行的操作
- 🔸 **安全监控**：发现可疑的文件修改
- 🔸 **性能分析**：观察系统资源使用模式

### 2.2 stat命令监控文件属性


**stat命令基础**
stat命令能显示文件的详细信息，包括大小、权限、修改时间等。结合watch使用，可以实时监控这些属性的变化。

```bash
# 查看文件详细信息
stat filename

# 实时监控文件属性变化  
watch -d stat /var/log/messages
```

**监控文件大小变化**
```bash
# 只显示文件大小
watch -n 2 'stat -c "%s bytes" /var/log/messages'

# 监控多个文件大小
watch -n 5 'stat -c "%n: %s bytes" /var/log/*.log'
```

### 2.3 ls命令动态监控


**监控目录内容变化**
```bash
# 监控目录文件数量和大小变化
watch -d 'ls -la /tmp'

# 按时间排序监控最新文件
watch -n 3 'ls -lt /var/log | head -10'
```

**监控特定类型文件**
```bash
# 监控图片文件变化
watch -d 'ls -lh *.jpg *.png 2>/dev/null || echo "无图片文件"'

# 监控临时文件
watch -n 1 'ls -la /tmp/temp_*'
```

### 2.4 find命令实时搜索


**监控新创建的文件**
```bash
# 查找最近5分钟内创建的文件
watch -n 30 'find /home -type f -cmin -5'

# 监控大文件的出现
watch -n 60 'find /var -size +100M -type f'
```

**监控文件权限变化**
```bash
# 查找权限为777的文件
watch -d 'find /home -perm 777 -type f'

# 监控SUID文件
watch -n 300 'find /usr -perm -4000 -type f'
```

### 2.5 inotify工具高级监控


**inotifywait基本使用**
inotify是Linux内核的文件系统事件监控机制，可以实时监测文件和目录的各种变化。

```bash
# 安装inotify工具（CentOS/RHEL）
yum install inotify-tools

# 监控单个文件
inotifywait -m /etc/passwd

# 监控目录所有变化
inotifywait -m -r /var/log
```

**监控特定事件**
```bash
# 只监控文件修改
inotifywait -m -e modify /etc/hosts

# 监控文件创建和删除
inotifywait -m -e create,delete /tmp
```

---

## 3. 📊 动态刷新监控数据


### 3.1 系统资源动态监控


**CPU使用率实时监控**
```bash
# 使用top命令动态监控
top -d 1  # 每秒刷新一次

# 监控特定进程CPU使用
watch -n 1 'ps aux | sort -nrk 3 | head -5'
```

**内存使用动态监控**
```bash
# 实时监控内存使用情况
watch -d free -m

# 监控内存使用率
watch -n 2 'free | grep Mem | awk "{printf \"Memory Usage: %.2f%%\n\", \$3/\$2 * 100.0}"'
```

### 3.2 网络状态动态监控


**网络连接监控**
```bash
# 监控网络连接数
watch -d 'ss -s'

# 监控特定端口连接
watch -n 2 'ss -tuln | grep :22'
```

**网络流量监控**
```bash
# 监控网络接口统计
watch -d 'cat /proc/net/dev'

# 简化的流量监控
watch -n 1 'iftop -t -s 5' 2>/dev/null
```

### 3.3 进程动态监控


**进程状态监控**
```bash
# 监控进程数量
watch -d 'ps aux | wc -l'

# 监控特定用户进程
watch -n 3 'ps -u username'
```

**系统服务监控**
```bash
# 监控systemd服务状态
watch -d 'systemctl list-units --failed'

# 监控特定服务
watch -n 5 'systemctl status nginx'
```

### 3.4 磁盘I/O动态监控


**磁盘使用监控**
```bash
# 监控磁盘空间变化
watch -d 'df -h'

# 监控inode使用情况
watch -n 30 'df -i'
```

**I/O性能监控**
```bash
# 使用iostat监控磁盘I/O
watch -n 2 'iostat -x 1 1'

# 监控磁盘读写统计
watch -d 'cat /proc/diskstats'
```

---

## 4. 📝 tail -f日志实时跟踪


### 4.1 tail命令基础概念


**什么是tail命令？**
tail命令就像是"文件的望远镜"，它专门用来查看文件的末尾部分。在Linux系统管理中，大部分重要信息都会追加到日志文件的末尾，所以tail命令是查看日志的利器。

**核心功能**：
- 🔸 **查看文件末尾**：显示文件最后几行内容
- 🔸 **实时跟踪**：文件有新内容时自动显示  
- 🔸 **持续监控**：保持监控状态，不会自动退出
- 🔸 **多文件支持**：可以同时监控多个文件

### 4.2 tail基本用法


```bash
# 查看文件最后10行（默认）
tail filename

# 查看最后20行
tail -n 20 filename

# 实时跟踪文件变化（重点功能）
tail -f filename

# 从第100行开始显示到文件末尾
tail -n +100 filename
```

**参数说明**：
- `-f`：follow，持续跟踪文件变化
- `-n`：指定显示行数
- `-c`：按字节数显示
- `-q`：静默模式，不显示文件名标题

### 4.3 实时日志监控实践


**系统日志监控**
```bash
# 监控系统主要日志
tail -f /var/log/messages

# 监控认证日志  
tail -f /var/log/secure

# 监控内核日志
tail -f /var/log/dmesg
```

**Web服务器日志监控**
```bash
# Apache访问日志
tail -f /var/log/httpd/access_log

# Nginx错误日志
tail -f /var/log/nginx/error.log

# 同时监控访问和错误日志
tail -f /var/log/nginx/access.log /var/log/nginx/error.log
```

### 4.4 tail命令高级技巧


**过滤日志内容**
```bash
# 监控包含ERROR的日志行
tail -f /var/log/messages | grep ERROR

# 监控特定IP的访问
tail -f /var/log/httpd/access_log | grep "192.168.1.100"
```

**彩色输出日志**
```bash
# 使用ccze为日志添加颜色
tail -f /var/log/messages | ccze -A

# 使用multitail同时监控多个文件
multitail /var/log/messages /var/log/secure
```

**日志轮转处理**
```bash
# 处理日志轮转的情况
tail -F /var/log/messages  # 大写F，自动处理文件轮转

# 监控压缩日志
zcat /var/log/messages.gz | tail -f
```

### 4.5 日志分析组合命令


**统计分析**
```bash
# 实时统计ERROR数量
tail -f /var/log/messages | grep -c ERROR

# 分析访问日志中的IP统计
tail -f /var/log/httpd/access_log | awk '{print $1}' | sort | uniq -c | sort -nr
```

**时间范围过滤**
```bash
# 监控今天的日志
tail -f /var/log/messages | grep "$(date '+%b %d')"

# 监控最近1小时的日志
tail -f /var/log/messages | grep "$(date -d '1 hour ago' '+%H'):"
```

---

## 5. 🔧 监控命令组合使用技巧


### 5.1 管道组合监控


**基本管道组合思路**
Linux的强大之处在于可以将多个简单命令组合成复杂的监控方案。管道（|）就是连接这些命令的桥梁，让数据像水流一样从一个命令流向下一个命令。

```bash
# 基本组合模式
命令1 | 命令2 | 命令3

# 实时监控组合模式  
watch "命令1 | 命令2 | 命令3"
```

### 5.2 系统性能组合监控


**CPU和内存组合监控**
```bash
# 监控CPU使用率最高的进程
watch -n 2 'ps aux | sort -nrk 3 | head -5 | awk "{print \$2,\$3,\$11}"'

# 同时监控CPU和内存使用情况
watch -n 3 'echo "=== CPU Top 3 ===" && ps aux | sort -nrk 3 | head -3 && echo "=== Memory Info ===" && free -m'
```

**磁盘和网络组合监控**
```bash
# 磁盘空间和I/O组合监控
watch -n 5 'echo "=== Disk Usage ===" && df -h | grep -v tmpfs && echo "=== Disk I/O ===" && iostat -x 1 1'
```

### 5.3 日志分析组合技巧


**多维度日志分析**
```bash
# 实时分析Web访问日志
tail -f /var/log/nginx/access.log | while read line; do
    echo "$line" | awk '{print $1, $7, $9}' | grep -v "200"
done

# 组合分析错误日志和访问日志
tail -f /var/log/nginx/error.log | grep -E "(error|warning)" &
tail -f /var/log/nginx/access.log | grep -E "(404|500)" &
```

**日志统计组合**
```bash
# 实时统计访问频率最高的IP
watch -n 10 'tail -1000 /var/log/nginx/access.log | awk "{print \$1}" | sort | uniq -c | sort -nr | head -10'
```

### 5.4 进程监控组合


**进程状态深度监控**
```bash
# 监控进程资源使用详情
watch -n 2 'ps aux | awk "NR==1 || /nginx/" | column -t'

# 进程数和连接数组合监控
watch -d 'echo "进程数: $(ps aux | wc -l)" && echo "网络连接数: $(ss -s | grep TCP | head -1)"'
```

**服务状态组合检查**
```bash
# 多服务状态一览
watch -n 5 'for service in nginx mysql redis; do echo "$service: $(systemctl is-active $service)"; done'
```

### 5.5 自定义监控组合脚本


**创建监控函数**
```bash
# 系统概览监控函数
system_overview() {
    echo "=== 系统时间 ==="
    date
    echo "=== 系统负载 ==="  
    uptime
    echo "=== 内存使用 ==="
    free -m
    echo "=== 磁盘使用 ==="
    df -h | head -5
}

# 使用函数进行监控
watch -n 10 system_overview
```

---

## 6. 📜 自定义监控脚本基础


### 6.1 监控脚本设计思路


**为什么需要自定义监控脚本？**
虽然Linux提供了很多监控命令，但实际工作中，我们往往需要：
- 🔸 **个性化监控**：针对特定业务需求设计监控内容
- 🔸 **自动化处理**：当监控到异常时自动执行处理动作
- 🔸 **数据整合**：将多个监控数据整合到一个界面
- 🔸 **历史记录**：保存监控历史数据供分析使用

### 6.2 基础监控脚本框架


**简单监控脚本模板**
```bash
#!/bin/bash
# 基础系统监控脚本

# 设置监控间隔（秒）
INTERVAL=5

# 日志文件路径
LOG_FILE="/var/log/system_monitor.log"

# 监控函数
monitor_system() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # CPU使用率
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    
    # 内存使用率  
    local mem_usage=$(free | grep Mem | awk '{printf "%.2f", $3/$2 * 100.0}')
    
    # 磁盘使用率
    local disk_usage=$(df -h / | awk 'NR==2 {print $5}' | cut -d'%' -f1)
    
    echo "[$timestamp] CPU:${cpu_usage}% MEM:${mem_usage}% DISK:${disk_usage}%"
}

# 主循环
while true; do
    monitor_system
    sleep $INTERVAL
done
```

### 6.3 进阶监控脚本示例


**Web服务器监控脚本**
```bash
#!/bin/bash
# Nginx服务监控脚本

check_nginx() {
    # 检查Nginx进程
    if pgrep nginx > /dev/null; then
        echo "✅ Nginx进程运行正常"
    else
        echo "❌ Nginx进程未运行"
        # 自动重启
        systemctl start nginx
        echo "🔄 已尝试重启Nginx"
    fi
    
    # 检查端口监听
    if ss -tuln | grep :80 > /dev/null; then
        echo "✅ 80端口监听正常"
    else
        echo "❌ 80端口未监听"
    fi
    
    # 检查配置文件语法
    if nginx -t 2>/dev/null; then
        echo "✅ 配置文件语法正确"
    else
        echo "❌ 配置文件语法错误"
    fi
}

# 执行检查
check_nginx
```

**磁盘空间监控脚本**
```bash
#!/bin/bash
# 磁盘空间监控脚本

# 设置告警阈值（百分比）
THRESHOLD=80

check_disk_usage() {
    # 获取所有挂载点的使用率
    df -h | grep -E '^/dev' | while read line; do
        local usage=$(echo $line | awk '{print $5}' | cut -d'%' -f1)
        local mount_point=$(echo $line | awk '{print $6}')
        
        if [ $usage -gt $THRESHOLD ]; then
            echo "⚠️  警告: $mount_point 使用率达到 ${usage}%"
            # 可以在这里添加发送邮件或其他告警动作
        else
            echo "✅ $mount_point 使用率正常: ${usage}%"
        fi
    done
}

check_disk_usage
```

### 6.4 监控脚本自动化


**使用crontab定时执行**
```bash
# 编辑定时任务
crontab -e

# 每5分钟执行一次监控脚本
*/5 * * * * /path/to/monitor_script.sh >> /var/log/monitor.log 2>&1

# 每小时生成监控报告
0 * * * * /path/to/generate_report.sh
```

**systemd服务方式运行**
```bash
# 创建服务文件 /etc/systemd/system/monitor.service
[Unit]
Description=Custom System Monitor
After=network.target

[Service]
Type=simple
ExecStart=/path/to/monitor_script.sh
Restart=always
User=monitor

[Install]
WantedBy=multi-user.target

# 启动服务
systemctl enable monitor.service
systemctl start monitor.service
```

---

## 7. 🎨 监控数据输出格式化


### 7.1 格式化输出的重要性


**为什么要格式化输出？**
原始的监控数据往往密密麻麻、不易阅读。格式化输出能让我们：
- 🔸 **提高可读性**：让数据一目了然
- 🔸 **突出重点**：重要信息更加醒目
- 🔸 **统一标准**：保持输出格式的一致性
- 🔸 **便于分析**：结构化数据便于后续处理

### 7.2 使用awk格式化输出


**基础格式化技巧**
```bash
# 格式化进程信息显示
ps aux | awk 'NR==1{printf "%-10s %-8s %-8s %s\n", "USER", "PID", "CPU%", "COMMAND"} NR>1{printf "%-10s %-8s %-8s %s\n", $1, $2, $3, $11}'

# 格式化内存信息
free -m | awk 'NR==2{printf "内存使用: %s/%sMB (%.2f%%)\n", $3, $2, $3*100/$2}'

# 格式化磁盘使用信息  
df -h | awk 'NR>1{printf "%-20s %10s %10s %10s %s\n", $1, $2, $3, $4, $5}'
```

**高级格式化示例**
```bash
# 彩色输出CPU使用率
ps aux | awk '{cpu=$3; if(cpu>80) color="\033[31m"; else if(cpu>50) color="\033[33m"; else color="\033[32m"; printf "%s%-10s %6.1f%%\033[0m %s\n", color, $1, cpu, $11}' | head -10
```

### 7.3 使用printf美化输出


**表格式输出**
```bash
# 创建表格式系统信息
printf "%-15s %-15s %-15s\n" "指标" "当前值" "状态"
printf "%-15s %-15s %-15s\n" "---" "---" "---"
printf "%-15s %-15s %-15s\n" "CPU使用率" "$(top -bn1 | grep "Cpu(s)" | awk '{print $2}')" "正常"
printf "%-15s %-15s %-15s\n" "内存使用率" "$(free | awk 'NR==2{printf "%.1f%%", $3*100/$2}')" "正常"
```

**对齐输出**
```bash
# 右对齐数字，左对齐文本
printf "%-20s %10s %10s\n" "文件系统" "已使用" "可用空间"
df -h | tail -n +2 | while read line; do
    filesystem=$(echo $line | awk '{print $1}')
    used=$(echo $line | awk '{print $3}')
    avail=$(echo $line | awk '{print $4}')
    printf "%-20s %10s %10s\n" "$filesystem" "$used" "$avail"
done
```

### 7.4 颜色和符号增强


**添加颜色代码**
```bash
# 定义颜色变量
RED='\033[31m'
GREEN='\033[32m'  
YELLOW='\033[33m'
BLUE='\033[34m'
NC='\033[0m' # No Color

# 带颜色的状态输出
echo -e "${GREEN}✅ 服务运行正常${NC}"
echo -e "${YELLOW}⚠️  磁盘使用率较高${NC}"
echo -e "${RED}❌ 服务启动失败${NC}"
```

**状态符号系统**
```bash
# 服务状态检查函数
check_service_status() {
    local service=$1
    if systemctl is-active $service &>/dev/null; then
        echo -e "🟢 $service 运行中"
    else
        echo -e "🔴 $service 已停止"  
    fi
}

# 检查多个服务
for service in nginx mysql redis; do
    check_service_status $service
done
```

### 7.5 实时刷新显示


**清屏重绘技术**
```bash
#!/bin/bash
# 实时监控显示脚本

while true; do
    # 清屏
    clear
    
    # 显示标题
    echo "==================== 系统监控面板 ===================="
    echo "更新时间: $(date)"
    echo "======================================================"
    
    # 系统负载
    echo "📊 系统负载:"
    uptime
    echo
    
    # 内存使用
    echo "💾 内存使用:"
    free -h
    echo
    
    # 磁盘使用  
    echo "💽 磁盘使用:"
    df -h | grep -E '^/dev'
    echo
    
    # 等待5秒后刷新
    sleep 5
done
```

---

## 8. 🚨 实时告警阈值设置


### 8.1 告警系统设计思路


**什么是阈值告警？**
阈值告警就像是给系统装上"报警器"，当某个监控指标超过预设的安全范围时，系统会自动发出警告。这样可以让管理员在问题严重化之前及时发现并处理问题。

**告警系统的核心要素**：
- 🔸 **监控指标**：确定要监控的具体数据（CPU、内存、磁盘等）
- 🔸 **阈值设定**：定义正常、警告、危险的数值范围
- 🔸 **检查频率**：多久检查一次监控指标
- 🔸 **告警动作**：达到阈值时执行什么操作

### 8.2 系统资源阈值设置


**CPU使用率告警**
```bash
#!/bin/bash
# CPU使用率监控脚本

# 设置阈值
CPU_WARNING=70    # 警告阈值70%
CPU_CRITICAL=90   # 危险阈值90%

check_cpu() {
    # 获取CPU使用率
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d',' -f1)
    cpu_usage=${cpu_usage%.*}  # 去掉小数点
    
    if [ $cpu_usage -ge $CPU_CRITICAL ]; then
        echo "🔴 危险: CPU使用率 ${cpu_usage}% (>= ${CPU_CRITICAL}%)"
        # 这里可以发送邮件或短信
        send_alert "CPU使用率过高: ${cpu_usage}%"
    elif [ $cpu_usage -ge $CPU_WARNING ]; then
        echo "🟡 警告: CPU使用率 ${cpu_usage}% (>= ${CPU_WARNING}%)"
    else
        echo "🟢 正常: CPU使用率 ${cpu_usage}%"
    fi
}

check_cpu
```

**内存使用率告警**
```bash
#!/bin/bash
# 内存使用率监控脚本

# 设置阈值
MEM_WARNING=80
MEM_CRITICAL=95

check_memory() {
    # 获取内存使用率
    local mem_info=$(free | grep Mem)
    local total=$(echo $mem_info | awk '{print $2}')
    local used=$(echo $mem_info | awk '{print $3}')
    local mem_usage=$((used * 100 / total))
    
    if [ $mem_usage -ge $MEM_CRITICAL ]; then
        echo "🔴 危险: 内存使用率 ${mem_usage}% (>= ${MEM_CRITICAL}%)"
        # 显示内存使用最多的进程
        echo "内存占用最高的进程:"
        ps aux | sort -nrk 4 | head -5 | awk '{printf "  %s: %.1f%%\n", $11, $4}'
    elif [ $mem_usage -ge $MEM_WARNING ]; then
        echo "🟡 警告: 内存使用率 ${mem_usage}% (>= ${MEM_WARNING}%)"
    else
        echo "🟢 正常: 内存使用率 ${mem_usage}%"
    fi
}

check_memory
```

### 8.3 磁盘空间告警


**磁盘使用率监控**
```bash
#!/bin/bash
# 磁盘空间监控脚本

# 设置阈值
DISK_WARNING=80
DISK_CRITICAL=95

check_disk_space() {
    # 检查所有磁盘分区
    df -h | grep -E '^/dev' | while read line; do
        local usage=$(echo $line | awk '{print $5}' | cut -d'%' -f1)
        local mount_point=$(echo $line | awk '{print $6}')
        local filesystem=$(echo $line | awk '{print $1}')
        
        if [ $usage -ge $DISK_CRITICAL ]; then
            echo "🔴 危险: $mount_point 使用率 ${usage}% (>= ${DISK_CRITICAL}%)"
            echo "  文件系统: $filesystem"
            # 显示占用空间最大的目录
            echo "  占用空间最大的目录:"
            du -sh $mount_point/* 2>/dev/null | sort -hr | head -3 | sed 's/^/    /'
        elif [ $usage -ge $DISK_WARNING ]; then
            echo "🟡 警告: $mount_point 使用率 ${usage}% (>= ${DISK_WARNING}%)"
        else
            echo "🟢 正常: $mount_point 使用率 ${usage}%"
        fi
    done
}

check_disk_space
```

### 8.4 网络连接告警


**网络连接数监控**
```bash
#!/bin/bash
# 网络连接监控脚本

# 设置阈值
CONN_WARNING=1000
CONN_CRITICAL=2000

check_network() {
    # 获取网络连接总数
    local total_conn=$(ss -s | grep TCP | head -1 | awk '{print $2}')
    
    # 获取ESTABLISHED连接数
    local established_conn=$(ss -tuln | grep ESTAB | wc -l)
    
    echo "网络连接状态:"
    echo "  总连接数: $total_conn"
    echo "  已建立连接: $established_conn"
    
    if [ $established_conn -ge $CONN_CRITICAL ]; then
        echo "🔴 危险: 网络连接数过多 ${established_conn} (>= ${CONN_CRITICAL})"
        # 显示连接数最多的端口
        echo "连接数最多的端口:"
        ss -tuln | awk '{print $4}' | cut -d':' -f2 | sort | uniq -c | sort -nr | head -5
    elif [ $established_conn -ge $CONN_WARNING ]; then
        echo "🟡 警告: 网络连接数较多 ${established_conn} (>= ${CONN_WARNING})"
    else
        echo "🟢 正常: 网络连接数 ${established_conn}"
    fi
}

check_network
```

### 8.5 综合告警脚本


**全方位系统监控告警**
```bash
#!/bin/bash
# 综合系统监控告警脚本

# 配置文件路径
CONFIG_FILE="/etc/monitor.conf"
LOG_FILE="/var/log/system_alerts.log"

# 默认阈值设置
CPU_WARNING=70
CPU_CRITICAL=90
MEM_WARNING=80
MEM_CRITICAL=95
DISK_WARNING=80
DISK_CRITICAL=95

# 读取配置文件（如果存在）
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# 日志记录函数
log_alert() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
}

# 发送告警函数（可扩展）
send_alert() {
    local message=$1
    log_alert "ALERT" "$message"
    
    # 可以在这里添加邮件、短信、微信等告警方式
    # mail -s "系统告警" admin@example.com <<< "$message"
    echo "📧 告警已记录: $message"
}

# 主监控函数
main_monitor() {
    echo "=== 系统监控报告 $(date) ==="
    echo
    
    # CPU检查
    check_cpu
    echo
    
    # 内存检查  
    check_memory
    echo
    
    # 磁盘检查
    check_disk_space
    echo
    
    # 网络检查
    check_network
    echo "=============================================="
}

# 执行监控
main_monitor
```

**监控脚本的定时执行**
```bash
# 添加到crontab，每5分钟执行一次
*/5 * * * * /path/to/system_monitor.sh >> /var/log/monitor_output.log 2>&1

# 每天早上8点发送监控日报  
0 8 * * * /path/to/daily_report.sh | mail -s "每日监控报告" admin@example.com
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心命令


```
🔸 watch命令：周期性执行监控，实时观察变化
🔸 tail -f命令：实时跟踪日志文件，监控系统活动  
🔸 inotify工具：内核级文件监控，精确捕获文件变化
🔸 组合命令：管道连接多个命令，构建复杂监控方案
🔸 自定义脚本：针对特定需求，实现个性化监控
```

### 9.2 关键理解要点


**🔹 实时监控的本质**
```
核心思想：
- 持续观察系统状态变化
- 及时发现异常情况  
- 自动化响应处理
- 记录历史数据供分析

实现方式：
- 命令循环执行（watch）
- 事件驱动监控（inotify）
- 主动轮询检查（定时脚本）
- 被动日志跟踪（tail -f）
```

**🔹 监控数据的处理流程**
```
数据采集 → 阈值比较 → 状态判断 → 告警动作 → 记录存储

关键环节：
- 选择合适的监控指标
- 设定合理的告警阈值
- 设计有效的告警机制
- 建立完善的日志记录
```

**🔹 监控系统的设计原则**
```
实用性原则：监控最重要的指标，避免信息过载
及时性原则：快速发现问题，缩短响应时间
准确性原则：减少误报，确保告警的有效性
可维护性：脚本结构清晰，便于修改和扩展
```

### 9.3 实际应用价值


**系统管理方面**：
- 📊 **性能监控**：实时了解CPU、内存、磁盘使用情况
- 🔍 **故障排查**：通过日志监控快速定位问题
- ⚠️ **预警机制**：在问题严重化前获得通知
- 📈 **趋势分析**：通过历史数据分析系统性能趋势

**运维自动化**：
- 🔄 **自动重启**：服务异常时自动恢复
- 📧 **智能告警**：根据不同级别发送不同类型通知
- 📝 **报告生成**：定期生成系统运行报告
- 🎯 **资源优化**：根据监控数据优化资源配置

**安全监控**：
- 👁️ **文件监控**：监控重要配置文件的变化
- 🔒 **权限检查**：监控异常的权限变更
- 🌐 **网络监控**：检测异常的网络连接
- 📋 **审计日志**：跟踪系统操作记录

### 9.4 最佳实践建议


**监控策略制定**：
- ✅ **分级监控**：根据重要程度设置不同的监控频率
- ✅ **合理阈值**：基于历史数据和业务需求设定告警阈值
- ✅ **多维监控**：从多个角度监控同一个系统组件
- ✅ **定期评估**：定期回顾和调整监控策略

**脚本编写规范**：
- 💻 **模块化设计**：将不同功能封装成独立函数
- 📝 **详细注释**：为复杂逻辑添加清晰的注释说明
- 🔧 **配置分离**：将阈值等配置项独立到配置文件
- 🛡️ **错误处理**：添加适当的错误处理和容错机制

**运维管理建议**：
- 📚 **文档记录**：记录监控脚本的用途和配置方法
- 🧪 **测试验证**：在生产环境部署前充分测试
- 🔄 **版本控制**：使用版本控制系统管理监控脚本
- 👥 **权限管理**：合理设置脚本执行权限和访问控制

**核心记忆要点**：
- watch命令是实时监控的基础工具，掌握其各种参数使用
- tail -f是日志监控的利器，结合grep等命令能实现强大的日志分析
- 组合命令是Linux监控的精髓，管道连接让简单命令实现复杂功能
- 自定义脚本让监控更加智能化，能够实现自动化的问题检测和处理
- 合理的阈值设置是有效告警的关键，需要根据实际业务情况调整