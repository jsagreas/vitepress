---
title: 3、内存使用监控命令
---
## 📚 目录

1. [free命令内存统计详解](#1-free命令内存统计详解)
2. [内存概念深度剖析](#2-内存概念深度剖析)
3. [proc-meminfo内存详细信息](#3-proc-meminfo内存详细信息)
4. [vmstat虚拟内存统计](#4-vmstat虚拟内存统计)
5. [内存使用率计算与监控](#5-内存使用率计算与监控)
6. [Swap交换分区监控](#6-Swap交换分区监控)
7. [内存问题诊断与排查](#7-内存问题诊断与排查)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💾 free命令内存统计详解


### 1.1 free命令基础语法


**🔸 命令格式与选项**
```bash
free [选项]
```

| 选项 | **作用** | **示例** |
|------|---------|---------|
| `-h` | **人类可读格式** | `free -h` |
| `-m` | **以MB为单位显示** | `free -m` |
| `-g` | **以GB为单位显示** | `free -g` |
| `-b` | **以字节为单位显示** | `free -b` |
| `-s N` | **每N秒刷新一次** | `free -s 2` |
| `-c N` | **显示N次后退出** | `free -c 5` |

### 1.2 free命令输出解析


**📊 典型输出格式**
```
              total        used        free      shared  buff/cache   available
Mem:           7.7G        2.1G        1.2G        156M        4.4G        5.1G
Swap:          2.0G          0B        2.0G
```

**🔍 字段含义详解**

```
内存统计行 (Mem):
┌─────────────────────────────────────────────────────────┐
│ total    │ used     │ free     │ shared   │ buff/cache │
├─────────────────────────────────────────────────────────┤
│ 总内存   │ 已使用   │ 空闲     │ 共享     │ 缓冲缓存   │
│ 8GB      │ 2.1GB    │ 1.2GB    │ 156MB    │ 4.4GB      │
└─────────────────────────────────────────────────────────┘
                                                 ↓
                                           available
                                           实际可用内存
                                              5.1GB
```

> 💡 **关键理解**
> 
> **available** ≠ **free**
> 
> available = free + 可释放的buff/cache

### 1.3 实时内存监控


**⏱️ 持续监控内存状态**
```bash
# 每2秒刷新一次，显示5次
free -h -s 2 -c 5

# 无限循环监控（Ctrl+C退出）
watch -n 1 'free -h'
```

**📈 内存使用趋势观察**
```
监控输出示例：
Time: 14:30:00  Mem: 2.1G/7.7G (27%)  Available: 5.1G
Time: 14:30:02  Mem: 2.3G/7.7G (30%)  Available: 4.9G  
Time: 14:30:04  Mem: 2.5G/7.7G (32%)  Available: 4.7G
                     ↑ 内存使用上升趋势
```

---

## 2. 🧠 内存概念深度剖析


### 2.1 Linux内存分类体系


**🏗️ 内存层次结构**
```
Linux内存架构：
┌─────────────────────────┐
│      物理内存 (RAM)      │ ← 8GB总容量
├─────────────────────────┤
│     已分配内存区域       │
│  ┌─────────────────────┐ │
│  │   应用程序内存       │ │ ← used (2.1GB)
│  │   系统内核内存       │ │
│  │   共享内存段        │ │ ← shared (156MB)
│  └─────────────────────┘ │
│     缓存缓冲区域        │
│  ┌─────────────────────┐ │
│  │   页面缓存(Page)    │ │ ← buff/cache (4.4GB)
│  │   缓冲区(Buffer)    │ │
│  └─────────────────────┘ │
│       空闲内存          │ ← free (1.2GB)
└─────────────────────────┘
```

### 2.2 关键内存概念解析


**🔸 可用内存(Available)**
```
计算公式：
Available ≈ Free + Reclaimable(buff/cache)

实际意义：
✅ 应用程序实际可申请的内存量
✅ 考虑了可回收的缓存和缓冲区
✅ 比free字段更准确反映内存可用性

示例分析：
Free:      1.2GB  ← 完全空闲的内存
Buff/Cache: 4.4GB  ← 其中约3.9GB可回收
Available:  5.1GB  ← 实际可用 = 1.2 + 3.9
```

**🔸 缓存与缓冲区(Cache vs Buffer)**
```
Buffer (缓冲区)：
用途：磁盘写入缓冲
特点：提高磁盘写入性能
示例：文件写入时的临时存储

Cache (页面缓存)：
用途：磁盘读取缓存  
特点：提高文件读取速度
示例：最近访问过的文件内容

内存回收机制：
当系统需要内存时，内核会自动释放这些缓存
优先级：Cache > Buffer > 应用内存
```

**🔸 共享内存(Shared)**
```
定义：多个进程共同使用的内存区域
类型：
• 共享库内存 (libc.so等)
• 进程间通信内存 (IPC)
• 共享文件映射

特点：
✅ 节省物理内存
✅ 进程间高效通信
⚠️ 需要同步机制保护
```

### 2.3 内存状态分析实例


**📊 内存使用模式识别**

| 场景类型 | **Free** | **Available** | **Buff/Cache** | **分析** |
|---------|----------|---------------|----------------|----------|
| 🖥️ **桌面轻度使用** | `3.2GB` | `5.8GB` | `2.1GB` | `缓存适中，内存充足` |
| 🗄️ **数据库服务器** | `0.5GB` | `2.1GB` | `5.2GB` | `大量文件缓存，正常` |
| 💻 **开发环境** | `1.8GB` | `4.2GB` | `3.1GB` | `编译缓存较多` |
| ⚠️ **内存压力** | `0.1GB` | `0.3GB` | `0.8GB` | `需要关注内存释放` |

---

## 3. 📁 /proc/meminfo内存详细信息


### 3.1 meminfo文件结构


**🔍 查看详细内存信息**
```bash
cat /proc/meminfo | head -20
```

**📋 核心字段解析**
```
MemTotal:        7909548 kB  ← 总物理内存
MemFree:         1234567 kB  ← 空闲内存  
MemAvailable:    5234567 kB  ← 可用内存
Buffers:          234567 kB  ← 缓冲区大小
Cached:          4123456 kB  ← 页面缓存
SwapCached:           12 kB  ← 交换缓存
Active:          3456789 kB  ← 活跃内存
Inactive:        2345678 kB  ← 非活跃内存
```

### 3.2 内存分类统计


**🎯 活跃与非活跃内存**
```
内存活跃度分类：
Active(anon):    1234567 kB  ← 活跃匿名页
Inactive(anon):   234567 kB  ← 非活跃匿名页  
Active(file):    2234567 kB  ← 活跃文件页
Inactive(file):  1234567 kB  ← 非活跃文件页

回收优先级：
Inactive(file) > Active(file) > Inactive(anon) > Active(anon)
```

**🔧 专用内存统计**
```bash
# 筛选特定内存信息
grep -E "(Dirty|Writeback|Mapped)" /proc/meminfo

输出解析：
Dirty:              123 kB  ← 脏页(待写回磁盘)
Writeback:            0 kB  ← 正在写回的页面  
Mapped:           567890 kB  ← 内存映射文件
```

### 3.3 内存信息实用脚本


**📊 内存使用率快速计算**
```bash
#!/bin/bash
# 计算内存使用百分比

total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
used=$((total - available))
usage_percent=$((used * 100 / total))

echo "内存使用情况："
echo "总内存: $(($total / 1024)) MB"
echo "已使用: $(($used / 1024)) MB" 
echo "使用率: ${usage_percent}%"
```

---

## 4. 📈 vmstat虚拟内存统计


### 4.1 vmstat命令详解


**🔸 基本语法**
```bash
vmstat [间隔] [次数]
vmstat 2 5  # 每2秒显示一次，共5次
```

**📊 输出格式解析**
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1234567  45678 4567890  0    0    12    34  567  890 10  5 82  3  0
```

### 4.2 字段含义详解


**🔍 内存相关字段**

| 字段 | **含义** | **单位** | **正常范围** |
|------|---------|---------|-------------|
| `swpd` | **已使用交换空间** | `KB` | `接近0最佳` |
| `free` | **空闲物理内存** | `KB` | `>总内存10%` |
| `buff` | **缓冲区内存** | `KB` | `动态变化` |
| `cache` | **页面缓存内存** | `KB` | `通常较大` |
| `si` | **换入速率** | `KB/s` | `0最佳` |
| `so` | **换出速率** | `KB/s` | `0最佳` |

**🚨 系统资源字段**

| 字段 | **含义** | **异常标志** |
|------|---------|-------------|
| `r` | **运行队列长度** | `>CPU核数` |
| `b` | **等待IO的进程数** | `持续>2` |
| `wa` | **IO等待CPU百分比** | `>30%` |

### 4.3 vmstat使用场景


**⏱️ 实时性能监控**
```bash
# 持续监控系统性能
vmstat 1

# 监控内存交换活动
vmstat -s | grep -i swap
```

**📋 性能基线建立**
```
正常负载基线：
r: 0-2        ← 运行队列正常
b: 0          ← 无IO阻塞
swpd: 0       ← 无交换使用  
si/so: 0      ← 无交换活动
wa: 0-5%      ← IO等待较低

高负载告警阈值：
r: >CPU核数×2
b: >5 且持续
si/so: >0 且持续
wa: >30%
```

---

## 5. 🧮 内存使用率计算与监控


### 5.1 内存使用率计算公式


**📐 标准计算方法**
```
方法1：基于总内存
使用率 = (Total - Available) / Total × 100%

方法2：基于已分配内存  
使用率 = Used / Total × 100%

方法3：考虑缓存回收
实际使用率 = (Used - Buffers - Cached) / Total × 100%

推荐使用方法1，因为Available已考虑可回收缓存
```

### 5.2 内存监控脚本实现


**🔧 实用监控脚本**
```bash
#!/bin/bash
# 内存监控告警脚本

THRESHOLD=80  # 告警阈值80%

get_memory_usage() {
    local total=$(free -m | awk 'NR==2{print $2}')
    local available=$(free -m | awk 'NR==2{print $7}')
    local used=$((total - available))
    local usage_percent=$((used * 100 / total))
    
    echo "内存使用: ${used}MB/${total}MB (${usage_percent}%)"
    
    if [ $usage_percent -gt $THRESHOLD ]; then
        echo "⚠️ 内存使用率超过阈值 ${THRESHOLD}%"
        # 这里可以添加告警通知逻辑
        return 1
    fi
    
    return 0
}

# 执行检查
get_memory_usage
```

### 5.3 内存趋势分析


**📊 使用率分级标准**

| 使用率范围 | **状态** | **建议** |
|-----------|---------|---------|
| `0-60%` | 🟢 **正常** | `继续监控` |
| `60-80%` | 🟡 **注意** | `检查大内存进程` |
| `80-90%` | 🟠 **警告** | `优化应用或增加内存` |
| `90-100%` | 🔴 **危险** | `立即处理，可能触发OOM` |

**📈 监控指标建议**
```
持续监控指标：
✅ 内存使用率趋势
✅ Available内存绝对值
✅ Swap使用情况
✅ 内存增长速度

告警触发条件：
⚠️ 使用率>80%且持续15分钟
⚠️ Available<500MB
⚠️ Swap使用>10%
⚠️ 内存增长>100MB/小时
```

---

## 6. 🔄 Swap交换分区监控


### 6.1 Swap基础概念


**🔸 交换空间作用机制**
```
Swap工作原理：
┌─────────────────┐    内存不足时    ┌─────────────────┐
│   物理内存(RAM)  │ ──────────────→ │   交换分区(Disk) │
│                │    换出较少使用   │                │
│ 活跃进程数据    │    的内存页面    │ 非活跃内存页面  │
│ 系统核心数据    │                 │ 休眠进程数据    │
└─────────────────┘ ←────────────── └─────────────────┘
                      需要时换入
```

**💡 Swap使用策略**
- **Swappiness参数**：控制内核使用swap的积极程度(0-100)
- **推荐设置**：桌面系统10-20，服务器1-10
- **查看当前值**：`cat /proc/sys/vm/swappiness`

### 6.2 Swap监控命令


**📊 交换空间状态查看**
```bash
# 查看交换分区信息
swapon --show

输出示例：
NAME      TYPE      SIZE USED PRIO
/swapfile file        2G   0B   -2

# 查看交换统计
vmstat 1 5 | awk 'NR>2 {print "换入:"$7"KB/s 换出:"$8"KB/s"}'
```

**🔍 详细交换信息**
```bash
# 查看所有交换相关信息
grep -i swap /proc/meminfo

输出解析：
SwapTotal:     2097148 kB  ← 交换分区总大小
SwapFree:      2097148 kB  ← 空闲交换空间
SwapCached:          0 kB  ← 交换缓存大小
```

### 6.3 Swap性能优化


**⚖️ 交换分区配置建议**

| RAM大小 | **Swap推荐大小** | **使用场景** |
|---------|-----------------|-------------|
| `<2GB` | `RAM × 2` | `老旧系统` |
| `2-8GB` | `RAM大小` | `普通服务器` |
| `8-64GB` | `RAM × 0.5` | `高性能服务器` |
| `>64GB` | `4-8GB或关闭` | `大内存服务器` |

**🚨 Swap异常模式识别**
```
正常模式：
swap使用: 0-5%
si/so值: 0 KB/s
响应时间: 正常

轻度交换：
swap使用: 5-20%  
si/so值: <100 KB/s
响应时间: 轻微影响

重度交换(Swap颠簸)：
swap使用: >20%
si/so值: >1000 KB/s  
响应时间: 严重下降
```

---

## 7. 🔧 内存问题诊断与排查


### 7.1 内存泄漏识别方法


**🕵️ 内存泄漏检测步骤**

**步骤 1️⃣：** 识别可疑进程
```bash
# 按内存使用排序查看进程
ps aux --sort=-%mem | head -10

# 持续监控进程内存变化
watch -n 5 'ps aux --sort=-%mem | head -5'
```

**步骤 2️⃣：** 分析内存增长趋势
```bash
#!/bin/bash
# 监控特定进程内存增长

PID=$1
LOG_FILE="/tmp/memory_monitor_$PID.log"

while true; do
    mem_usage=$(ps -o pid,rss,vsz,comm -p $PID | tail -1)
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "$timestamp $mem_usage" >> $LOG_FILE
    sleep 60
done
```

**步骤 3️⃣：** 内存映射分析
```bash
# 查看进程内存映射
pmap -d $PID

# 查看进程详细内存信息  
cat /proc/$PID/status | grep -E "(VmSize|VmRSS|VmData|VmStk)"
```

### 7.2 OOM Killer机制详解


**⚠️ OOM触发条件**
```
OOM Killer激活场景：
1. 物理内存耗尽
2. 交换空间不足  
3. 无法分配新的内存页面
4. 系统内存压力持续过高
```

**🔍 OOM日志查看**
```bash
# 查看OOM相关日志
dmesg | grep -i "killed process"
journalctl | grep -i "out of memory"

# 典型OOM日志格式
Out of memory: Kill process 1234 (chrome) score 800 or sacrifice child
Killed process 1234 (chrome) total-vm:2048MB, anon-rss:1024MB, file-rss:512MB
```

**🛡️ OOM预防策略**
```
系统层面：
✅ 设置合适的swap大小
✅ 配置内存使用限制
✅ 监控内存使用趋势
✅ 及时清理无用进程

应用层面：  
✅ 避免内存泄漏
✅ 优化内存使用
✅ 实现内存池管理
✅ 设置合理的缓存策略
```

### 7.3 内存优化实践


**🚀 系统内存释放**
```bash
# 清理页面缓存
echo 1 > /proc/sys/vm/drop_caches

# 清理目录项和inode缓存  
echo 2 > /proc/sys/vm/drop_caches

# 清理所有缓存
echo 3 > /proc/sys/vm/drop_caches

# 注意：仅在必要时使用，会影响性能
```

**📊 内存使用优化检查清单**

| 检查项目 | **命令** | **正常值** | **异常处理** |
|---------|---------|-----------|-------------|
| 🔍 **内存使用率** | `free -h` | `<80%` | `优化大内存进程` |
| 🔄 **交换使用** | `swapon -s` | `<10%` | `增加物理内存` |
| 📈 **内存增长** | `watch free` | `稳定` | `检查内存泄漏` |
| 🚨 **OOM事件** | `dmesg \| grep OOM` | `无` | `分析被杀进程` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心命令


```
🔸 free：内存使用情况查看，重点理解available字段
🔸 vmstat：虚拟内存统计，关注si/so交换指标  
🔸 /proc/meminfo：详细内存信息，深度分析必备
🔸 ps/top：进程内存使用，定位内存消耗大户
🔸 pmap：进程内存映射，内存泄漏分析工具
```

### 8.2 关键理解要点


**🔹 内存概念澄清**
```
Available vs Free：
• Available = 应用可用内存（推荐参考）
• Free = 完全空闲内存（仅供参考）

Cache vs Buffer：
• Cache = 文件读取缓存（可快速回收）
• Buffer = 磁盘写入缓冲（系统管理）
```

**🔹 监控重点指标**
```
内存健康度评估：
✅ Available内存 > 总内存20%
✅ 交换使用率 < 10%
✅ 内存使用增长趋势平稳
✅ 无频繁的si/so交换活动
```

**🔹 问题诊断思路**
```
内存问题排查流程：
1. free命令查看整体状况
2. vmstat监控交换活动
3. ps/top找出内存大户
4. pmap分析具体进程
5. 日志检查OOM记录
```

### 8.3 实际应用价值


**🎯 运维实践应用**
- **性能监控**：建立内存使用基线，及时发现异常
- **容量规划**：根据历史数据预测内存需求增长
- **故障排查**：快速定位内存相关性能问题
- **优化调整**：合理配置交换分区和内核参数

**🔧 监控脚本模板**
```bash
# 内存监控一键脚本
check_memory() {
    echo "=== 内存使用情况 ==="
    free -h
    echo "=== 交换使用情况 ==="  
    swapon -s
    echo "=== Top5内存进程 ==="
    ps aux --sort=-%mem | head -6
}
```

**核心记忆口诀**：
- 内存监控看available，交换活动关注si/so
- 缓存可回收，buffer助写入，free非全貌看available  
- OOM杀进程保系统，监控趋势防未然
- vmstat观全局，pmap查细节，日志寻真相