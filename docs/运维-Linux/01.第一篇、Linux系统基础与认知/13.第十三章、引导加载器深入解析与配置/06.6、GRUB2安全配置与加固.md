---
title: 6、GRUB2安全配置与加固
---
## 📚 目录

1. [GRUB2安全基础概念](#1-GRUB2安全基础概念)
2. [GRUB2密码保护机制](#2-GRUB2密码保护机制)
3. [启动菜单权限控制](#3-启动菜单权限控制)
4. [Secure Boot与GRUB2](#4-Secure-Boot与GRUB2)
5. [GRUB2模块与签名验证](#5-GRUB2模块与签名验证)
6. [防止内核参数篡改](#6-防止内核参数篡改)
7. [配置文件权限加固](#7-配置文件权限加固)
8. [引导器防篡改措施](#8-引导器防篡改措施)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ GRUB2安全基础概念


### 1.1 什么是GRUB2安全

**GRUB2安全**就像给你家的大门装上多重保险锁，确保只有授权的人才能启动和修改你的系统。

```
普通情况 vs 安全配置：

普通GRUB2：
用户开机 → 看到启动菜单 → 随意选择/编辑 → 进入系统

安全GRUB2：
用户开机 → 需要密码验证 → 限制编辑权限 → 防止恶意修改
```

**🎯 安全目标**
- **防止未授权启动**：只有知道密码的人才能启动系统
- **防止参数篡改**：阻止恶意修改内核启动参数
- **保护配置完整性**：确保引导配置不被恶意修改
- **增强系统可信性**：通过签名验证确保启动过程可信

### 1.2 GRUB2安全威胁分析


┌─ 常见安全威胁 ─────────────────┐
│ 1. 物理访问攻击                │
│    - 直接编辑启动参数          │
│    - 从外部介质启动            │
│                                │
│ 2. 内核参数注入                │
│    - single用户模式绕过        │
│    - 禁用安全模块              │
│                                │
│ 3. 配置文件篡改                │
│    - 修改启动项                │
│    - 植入恶意内核              │
└────────────────────────────────┘

---

## 2. 🔐 GRUB2密码保护机制


### 2.1 密码保护的工作原理

**简单理解**：就像给你的启动菜单加了一把锁，不输入正确密码就无法进行敏感操作。

```
密码保护流程：
开机 → GRUB2菜单 → 尝试编辑/启动 → 要求输入密码 → 验证通过 → 允许操作
```

### 2.2 生成安全密码


**🔧 使用grub2-mkpasswd-pbkdf2生成密码**
```bash
# 生成加密密码（推荐方法）
sudo grub2-mkpasswd-pbkdf2

# 输入过程：
Enter password: [输入你的密码]
Reenter password: [再次输入确认]

# 输出示例：
PBKDF2 hash of your password is grub.pbkdf2.sha512.10000.9AC39...
```

**💡 为什么用这个命令？**
- **PBKDF2加密**：比明文密码安全1000倍
- **SHA512哈希**：目前最安全的哈希算法之一
- **10000次迭代**：让暴力破解变得极其困难

**🚨 安全建议**
```
✅ 密码强度要求：
- 至少12位字符
- 包含大小写字母、数字、特殊符号
- 避免使用常见单词

❌ 避免的做法：
- 不要使用生日、姓名等个人信息
- 不要使用键盘序列（123456、qwerty）
- 不要与系统用户密码相同
```

### 2.3 配置密码保护


**📝 编辑GRUB配置文件**
```bash
# 编辑自定义配置文件
sudo vim /etc/grub.d/40_custom

# 添加以下内容：
cat << 'EOF'
# 设置超级用户
set superusers="admin"

# 设置用户密码（使用上面生成的加密密码）
password_pbkdf2 admin grub.pbkdf2.sha512.10000.9AC39...

# 保护启动项（需要认证才能启动）
menuentry 'Ubuntu' --users admin {
    # 启动配置
}

# 普通启动项（无需认证，但不能编辑）
menuentry 'Ubuntu (Safe Mode)' --unrestricted {
    # 启动配置
}
EOF
```

**🔄 应用配置**
```bash
# 更新GRUB配置
sudo update-grub2

# 或者在某些系统上：
sudo grub2-mkconfig -o /boot/grub2/grub.cfg
```

### 2.4 密码策略配置


┌─ 密码策略对比 ─────────────────┐
│ **策略类型**     **安全级别** │
│ 无密码保护       ⭐☆☆☆☆      │
│ 明文密码         ⭐⭐☆☆☆      │
│ MD5密码哈希      ⭐⭐⭐☆☆      │
│ PBKDF2加密       ⭐⭐⭐⭐⭐      │
└────────────────────────────────┘

---

## 3. 🎛️ 启动菜单权限控制


### 3.1 用户权限分级

**理解概念**：就像公司的门禁卡一样，不同级别的员工有不同的访问权限。

```
权限层级：
📋 超级用户 (superusers)
   ├─ 完全控制权限
   ├─ 可以编辑启动参数
   └─ 可以启动所有系统

👤 普通用户 (users)  
   ├─ 受限启动权限
   ├─ 无法编辑参数
   └─ 只能启动指定系统

🔓 无限制项 (unrestricted)
   ├─ 任何人都可以使用
   ├─ 无需密码验证
   └─ 但仍无法编辑
```

### 3.2 实际配置示例


**🔧 复杂权限控制配置**
```bash
# 编辑 /etc/grub.d/40_custom
cat << 'EOF'
# 定义多个用户
set superusers="root admin"

# 设置不同用户的密码
password_pbkdf2 root grub.pbkdf2.sha512.10000.AAAAA...
password_pbkdf2 admin grub.pbkdf2.sha512.10000.BBBBB...
password user1 plaintext_password_for_testing

# 超级用户专用启动项
menuentry 'System Maintenance' --users root {
    linux /vmlinuz root=/dev/sda1 single
}

# 管理员可用启动项  
menuentry 'Ubuntu (Admin Mode)' --users admin {
    linux /vmlinuz root=/dev/sda1 ro quiet
}

# 普通启动项（无需认证但不能编辑）
menuentry 'Ubuntu (Normal)' --unrestricted {
    linux /vmlinuz root=/dev/sda1 ro quiet splash
}
EOF
```

**💡 配置解释**
- `--users root`：只有root用户可以启动此项
- `--users admin`：只有admin用户可以启动此项  
- `--unrestricted`：任何人都可以启动，但不能编辑

### 3.3 编辑权限控制


```bash
# 防止启动时按'e'键编辑
# 在 /etc/grub.d/00_header 中添加：
echo 'set timeout_style=countdown' >> /etc/grub.d/00_header

# 完全禁用编辑功能
echo 'export GRUB_DISABLE_RECOVERY=true' >> /etc/default/grub
```

**🎯 权限控制效果**
```
用户操作              无保护     有保护
按'e'编辑启动参数      ✅ 可以    ❌ 需要密码
按'c'进入命令行        ✅ 可以    ❌ 需要密码
选择启动项            ✅ 可以    🔒 根据配置
从USB/CD启动          ✅ 可以    ❌ 需要密码
```

---

## 4. 🔒 Secure Boot与GRUB2


### 4.1 什么是Secure Boot

**通俗解释**：Secure Boot就像一个严格的门卫，只允许有"通行证"（数字签名）的程序进入你的电脑。

```
启动验证链：
UEFI固件 → 验证GRUB2签名 → 验证内核签名 → 启动系统
    ↓           ↓              ↓
  信任根      引导器验证      内核验证
```

### 4.2 GRUB2与Secure Boot兼容配置


**🔍 检查Secure Boot状态**
```bash
# 检查是否启用Secure Boot
sudo mokutil --sb-state

# 输出示例：
SecureBoot enabled    # 已启用
SecureBoot disabled   # 已禁用
```

**⚙️ 配置GRUB2支持Secure Boot**
```bash
# 1. 安装必要软件包
sudo apt install shim-signed grub-efi-amd64-signed

# 2. 重新安装GRUB2
sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=ubuntu

# 3. 更新配置
sudo update-grub
```

### 4.3 自定义内核与Secure Boot


**⚠️ 自定义内核的挑战**
```
问题：自定义编译的内核没有微软的签名，Secure Boot会拒绝启动

解决方案：
方案1：禁用Secure Boot（降低安全性）
方案2：自己签名内核（推荐）
方案3：使用MOK（Machine Owner Key）
```

**🔧 使用MOK签名自定义内核**
```bash
# 1. 生成密钥对
openssl req -new -x509 -newkey rsa:2048 -keyout MOK.priv -outform DER -out MOK.der -nodes -days 36500 -subj "/CN=My Kernel/"

# 2. 导入MOK密钥
sudo mokutil --import MOK.der

# 3. 重启并在MOK界面完成注册

# 4. 签名内核
sudo sbsign --key MOK.priv --cert MOK.der /boot/vmlinuz-5.x.x-custom
```

### 4.4 Secure Boot故障排除


┌─ 常见问题与解决方案 ───────────┐
│ **问题**          **解决方案** │
│ 启动失败          检查签名状态 │
│ 驱动不能加载      签名驱动模块 │
│ 自定义内核拒绝    使用MOK签名  │
│ GRUB不能启动      重装shim    │
└────────────────────────────────┘

---

## 5. 📜 GRUB2模块与签名验证


### 5.1 GRUB2模块系统

**理解概念**：GRUB2模块就像手机应用一样，每个模块提供特定功能，比如支持不同文件系统、网络启动等。

```
GRUB2核心架构：
核心 (core.img)
  ├─ 基础模块 (part_gpt, ext2, fat...)
  ├─ 网络模块 (net, tftp, http...)
  ├─ 加密模块 (luks, cryptodisk...)
  └─ 其他功能模块
```

**📍 模块存储位置**
```bash
# 查看GRUB2模块位置
ls /boot/grub/i386-pc/          # BIOS系统
ls /boot/grub/x86_64-efi/       # UEFI系统

# 常见模块文件
ls *.mod                        # 模块文件
```

### 5.2 模块签名验证配置


**🔒 启用模块签名验证**
```bash
# 编辑GRUB配置
vim /etc/grub.d/00_header

# 添加验证设置
cat << 'EOF'
# 启用模块签名验证
set check_signatures=enforce

# 加载公钥
trust /boot/grub/pubkey.gpg

# 设置签名策略
set signature_policy=enforce
EOF
```

**🔑 生成和管理签名密钥**
```bash
# 1. 生成GPG密钥对
gpg --gen-key

# 2. 导出公钥
gpg --armor --export "Your Name" > grub_public.key

# 3. 转换为GRUB格式
gpg --export "Your Name" > /boot/grub/pubkey.gpg

# 4. 签名模块
gpg --detach-sign custom_module.mod
```

### 5.3 安全模块加载策略


**🛡️ 模块白名单配置**
```bash
# 创建允许的模块列表
vim /etc/grub.d/01_modules

cat << 'EOF'
# 基础必需模块（总是加载）
insmod part_gpt
insmod ext2
insmod fat

# 条件加载模块（根据需要）
if [ "$signature_verified" = "yes" ]; then
    insmod luks
    insmod cryptodisk
fi

# 禁用危险模块
# insmod halt  # 禁用halt模块
EOF
```

**⚠️ 安全考虑**
```
高危模块（需要特别注意）：
- halt: 可以关闭系统
- reboot: 可以重启系统  
- terminal: 可以访问终端
- password: 可能绕过密码验证

安全策略：
✅ 只加载必需模块
✅ 对关键模块进行签名验证
❌ 避免加载未知来源的模块
```

---

## 6. 🚫 防止内核参数篡改


### 6.1 内核参数攻击原理

**攻击场景**：攻击者通过修改内核启动参数来绕过安全机制。

```
常见攻击参数：
init=/bin/bash          # 绕过正常启动，直接获取root shell
single                  # 进入单用户模式
ro→rw                   # 将只读改为读写
apparmor=0             # 禁用AppArmor安全模块
selinux=0              # 禁用SELinux安全模块
```

### 6.2 参数保护机制


**🔒 锁定关键启动参数**
```bash
# 编辑 /etc/grub.d/10_linux
# 找到linux命令行，添加保护

# 原始配置：
linux /vmlinuz root=/dev/sda1 ro quiet splash

# 安全配置：
linux /vmlinuz root=/dev/sda1 ro quiet splash \
    security=apparmor \
    apparmor=1 \
    audit=1 \
    kernel.kptr_restrict=1 \
    kernel.dmesg_restrict=1
```

**🛡️ 参数完整性验证**
```bash
# 创建参数校验脚本
cat << 'EOF' > /etc/grub.d/99_security_check
#!/bin/bash
# GRUB2启动参数安全检查

# 定义危险参数列表
DANGEROUS_PARAMS="init=/bin/bash init=/bin/sh single rdinit=/bin/bash"

# 检查函数
check_params() {
    local cmdline="$1"
    for param in $DANGEROUS_PARAMS; do
        if echo "$cmdline" | grep -q "$param"; then
            echo "警告: 检测到危险参数 $param" >&2
            return 1
        fi
    done
    return 0
}
EOF

chmod +x /etc/grub.d/99_security_check
```

### 6.3 内核命令行完整性


**📋 白名单参数控制**
```bash
# 创建允许的参数白名单
cat << 'EOF' > /boot/grub/allowed_params.conf
# 允许的内核参数
root=
ro
rw
quiet
splash
security=
apparmor=
selinux=
audit=
# 禁止其他参数
EOF
```

**💡 实时参数监控**
```bash
# 添加启动时参数记录
echo 'echo "Boot parameters: $(cat /proc/cmdline)" >> /var/log/boot-params.log' >> /etc/rc.local

# 检查启动参数变化
cat /var/log/boot-params.log | tail -10
```

---

## 7. 📁 配置文件权限加固


### 7.1 GRUB配置文件安全

**理解重要性**：GRUB配置文件就像是你房子的钥匙，必须严格保护，不能让无关的人接触。

```
重要配置文件列表：
/boot/grub/grub.cfg          # 主配置文件
/etc/grub.d/                 # 配置脚本目录
/etc/default/grub            # 默认设置文件
/boot/grub/device.map        # 设备映射文件
```

**🔧 设置安全权限**
```bash
# 设置配置文件权限（只有root可读写）
sudo chmod 600 /boot/grub/grub.cfg
sudo chmod 600 /etc/default/grub
sudo chmod -R 700 /etc/grub.d/

# 设置所有者
sudo chown root:root /boot/grub/grub.cfg
sudo chown -R root:root /etc/grub.d/

# 验证权限设置
ls -la /boot/grub/grub.cfg
# 输出应该是：-rw------- 1 root root
```

### 7.2 配置文件完整性监控


**🔍 文件完整性检查**
```bash
# 1. 创建配置文件哈希
sha256sum /boot/grub/grub.cfg > /root/grub.cfg.sha256
sha256sum /etc/default/grub > /root/default-grub.sha256

# 2. 创建监控脚本
cat << 'EOF' > /root/check_grub_integrity.sh
#!/bin/bash
# GRUB配置完整性检查脚本

CONFIG_FILES=(
    "/boot/grub/grub.cfg"
    "/etc/default/grub"
)

HASH_DIR="/root"
ALERT_EMAIL="admin@example.com"

check_file_integrity() {
    local file="$1"
    local hash_file="$HASH_DIR/$(basename $file).sha256"
    
    if [ ! -f "$hash_file" ]; then
        echo "警告: 哈希文件 $hash_file 不存在"
        return 1
    fi
    
    if ! sha256sum -c "$hash_file" >/dev/null 2>&1; then
        echo "严重: 文件 $file 已被修改！"
        # 发送告警邮件
        echo "GRUB配置文件 $file 被意外修改" | mail -s "安全告警" $ALERT_EMAIL
        return 1
    fi
    
    echo "文件 $file 完整性检查通过"
    return 0
}

# 检查所有配置文件
for file in "${CONFIG_FILES[@]}"; do
    check_file_integrity "$file"
done
EOF

chmod +x /root/check_grub_integrity.sh
```

**⏰ 自动化监控**
```bash
# 添加到crontab，每天检查一次
(crontab -l 2>/dev/null; echo "0 2 * * * /root/check_grub_integrity.sh") | crontab -

# 或者使用inotify实时监控
apt install inotify-tools
cat << 'EOF' > /root/grub_monitor.sh
#!/bin/bash
inotifywait -m -e modify,create,delete /boot/grub/ /etc/grub.d/ --format '%w%f %e' |
while read file event; do
    echo "$(date): 文件 $file 发生 $event 事件" >> /var/log/grub-changes.log
    /root/check_grub_integrity.sh
done
EOF
```

### 7.3 备份与恢复策略


**💾 配置文件备份**
```bash
# 创建备份脚本
cat << 'EOF' > /root/backup_grub_config.sh
#!/bin/bash
BACKUP_DIR="/root/grub_backups"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# 备份配置文件
cp /boot/grub/grub.cfg "$BACKUP_DIR/grub.cfg_$DATE"
cp /etc/default/grub "$BACKUP_DIR/default-grub_$DATE"
cp -r /etc/grub.d/ "$BACKUP_DIR/grub.d_$DATE/"

# 保留最近10个备份
cd "$BACKUP_DIR"
ls -t grub.cfg_* | tail -n +11 | xargs rm -f
ls -t default-grub_* | tail -n +11 | xargs rm -f
ls -td grub.d_*/ | tail -n +11 | xargs rm -rf

echo "GRUB配置备份完成: $DATE"
EOF

# 设置定期备份
(crontab -l 2>/dev/null; echo "0 1 * * 0 /root/backup_grub_config.sh") | crontab -
```

---

## 8. 🛡️ 引导器防篡改措施


### 8.1 引导扇区保护

**理解概念**：引导扇区就像是房子的地基，如果被破坏，整个系统都无法启动。

```
MBR引导扇区结构：
┌─────────────────────────┐
│ 引导代码 (446字节)      │ ← GRUB第一阶段代码
├─────────────────────────┤
│ 分区表 (64字节)         │ ← 分区信息
├─────────────────────────┤
│ 启动签名 (2字节)        │ ← 0x55AA魔术数字
└─────────────────────────┘
```

**🔒 MBR保护措施**
```bash
# 1. 备份MBR
sudo dd if=/dev/sda of=/root/mbr_backup.img bs=512 count=1

# 2. 创建MBR校验和
md5sum /root/mbr_backup.img > /root/mbr_backup.md5

# 3. 监控MBR变化
cat << 'EOF' > /root/check_mbr.sh
#!/bin/bash
DEVICE="/dev/sda"
BACKUP_FILE="/root/mbr_backup.img"
HASH_FILE="/root/mbr_backup.md5"

# 读取当前MBR
dd if=$DEVICE of=/tmp/current_mbr.img bs=512 count=1 2>/dev/null

# 比较MBR
if ! cmp -s "$BACKUP_FILE" "/tmp/current_mbr.img"; then
    echo "警告: MBR已被修改！"
    echo "原始MBR: $(md5sum $BACKUP_FILE)"
    echo "当前MBR: $(md5sum /tmp/current_mbr.img)"
    
    # 可选：自动恢复MBR
    # dd if="$BACKUP_FILE" of="$DEVICE" bs=512 count=1
    
    exit 1
else
    echo "MBR完整性检查通过"
fi

rm -f /tmp/current_mbr.img
EOF

chmod +x /root/check_mbr.sh
```

### 8.2 UEFI启动保护


**🔐 UEFI变量保护**
```bash
# 查看UEFI启动项
efibootmgr -v

# 备份UEFI变量
efibootmgr -v > /root/uefi_boot_backup.txt

# 锁定UEFI变量（防止修改）
# 在UEFI设置中启用：
# - Secure Boot
# - Boot Order Lock
# - Setup Password
```

**🔧 UEFI启动项监控**
```bash
cat << 'EOF' > /root/check_uefi_boot.sh
#!/bin/bash
BACKUP_FILE="/root/uefi_boot_backup.txt"
CURRENT_FILE="/tmp/current_uefi_boot.txt"

# 获取当前UEFI启动项
efibootmgr -v > "$CURRENT_FILE"

# 比较变化
if ! cmp -s "$BACKUP_FILE" "$CURRENT_FILE"; then
    echo "警告: UEFI启动项已发生变化！"
    echo "变化详情:"
    diff "$BACKUP_FILE" "$CURRENT_FILE"
    
    # 发送告警
    mail -s "UEFI启动项变化告警" admin@example.com < "$CURRENT_FILE"
else
    echo "UEFI启动项检查正常"
fi

rm -f "$CURRENT_FILE"
EOF
```

### 8.3 硬件安全模块集成


**🔒 TPM集成**
```bash
# 检查TPM状态
sudo systemctl status tpm2-abrmd

# 使用TPM封存GRUB密钥
tpm2_createprimary -C e -g sha256 -G rsa -c primary.ctx
tpm2_create -g sha256 -G keyedhash -u grub.pub -r grub.priv -C primary.ctx
tpm2_load -C primary.ctx -u grub.pub -r grub.priv -c grub.ctx

# 在GRUB中使用TPM解封
# 需要编译支持TPM的GRUB2版本
```

### 8.4 物理防护措施


┌─ 物理安全检查清单 ─────────────┐
│ ✅ BIOS/UEFI设置密码            │
│ ✅ 禁用从USB/CD启动             │
│ ✅ 启用安全启动                 │
│ ✅ 机箱锁定防止硬件篡改         │
│ ✅ 显示器自动锁定               │
│ ✅ 关键服务器物理隔离           │
└────────────────────────────────┘

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的安全概念


```
🔸 密码保护：使用PBKDF2加密，设置超级用户
🔸 权限控制：区分超级用户、普通用户和无限制启动项
🔸 Secure Boot：通过数字签名验证启动链完整性
🔸 模块安全：签名验证GRUB2模块，防止恶意模块
🔸 参数保护：防止通过修改内核参数绕过安全机制
🔸 文件加固：严格设置配置文件权限和完整性监控
🔸 防篡改：保护引导扇区和UEFI变量不被恶意修改
```

### 9.2 安全配置最佳实践


**🎯 基础安全配置**
1. **设置强密码保护**：使用`grub2-mkpasswd-pbkdf2`生成加密密码
2. **配置用户权限**：区分不同用户的启动权限
3. **启用Secure Boot**：在支持的硬件上启用
4. **保护配置文件**：设置正确的文件权限和监控

**⚡ 高级安全措施**
```
企业级安全：
- TPM硬件安全模块集成
- 网络启动签名验证
- 集中化配置管理
- 自动化安全监控

个人用户安全：
- 基础密码保护
- 禁用危险启动选项
- 定期备份配置
- 简单完整性检查
```

### 9.3 故障排除与恢复


**🚨 常见问题及解决方案**
```
忘记GRUB密码：
→ 使用救援模式或Live CD重置

配置文件损坏：
→ 从备份恢复或重新生成

Secure Boot冲突：
→ 签名自定义内核或禁用Secure Boot

启动失败：
→ 检查MBR/UEFI完整性，从备份恢复
```

**💡 安全vs可用性平衡**
```
高安全性配置：
✅ 适合：服务器、关键系统
❌ 缺点：操作复杂，故障恢复困难

中等安全性配置：
✅ 适合：工作站、办公电脑
✅ 平衡：安全性与易用性

基础安全性配置：
✅ 适合：个人电脑、测试环境  
✅ 优点：简单易用，快速部署
```

### 9.4 实施建议


**📝 分步实施计划**
```
第一阶段（基础保护）：
- 设置GRUB2密码保护
- 配置基本权限控制
- 备份重要配置文件

第二阶段（增强安全）：
- 启用Secure Boot
- 配置模块签名验证
- 实施文件完整性监控

第三阶段（深度防护）：
- 集成TPM等硬件安全
- 部署自动化监控
- 建立应急响应机制
```

**⚠️ 重要提醒**
- 在生产环境部署前，先在测试环境验证
- 确保有可靠的恢复方案
- 定期更新安全配置和监控脚本
- 平衡安全性和可用性需求

**核心记忆**：
- GRUB2安全配置是系统安全的第一道防线
- 密码保护、权限控制、签名验证是三大核心
- 配置文件权限和完整性监控不可忽视
- 物理安全和逻辑安全同等重要