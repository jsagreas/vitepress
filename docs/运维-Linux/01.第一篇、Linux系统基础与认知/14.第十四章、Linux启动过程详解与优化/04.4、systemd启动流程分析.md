---
title: 4、systemd启动流程分析
---
## 📚 目录

1. [systemd启动概述](#1-systemd启动概述)
2. [systemd启动阶段划分](#2-systemd启动阶段划分)
3. [target依赖关系解析](#3-target依赖关系解析)
4. [并行启动机制](#4-并行启动机制)
5. [服务依赖排序](#5-服务依赖排序)
6. [default.target选择机制](#6-defaulttarget选择机制)
7. [启动事务处理](#7-启动事务处理)
8. [服务超时处理](#8-服务超时处理)
9. [systemd日志记录](#9-systemd日志记录)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🚀 systemd启动概述


### 1.1 什么是systemd启动流程


**通俗理解**：systemd就像一个系统管家，负责把Linux系统从开机到完全可用的整个过程管理起来。

```
简单类比：
开机过程 = 开一家餐厅
systemd = 餐厅经理
各种服务 = 厨师、服务员、收银员等员工

经理需要：
• 按顺序安排员工上班（依赖关系）
• 同时让多个员工开始工作（并行启动）
• 确保重要岗位先就位（优先级）
• 处理员工迟到问题（超时处理）
```

**📋 核心定义**
```
systemd：System and Service Manager
• 是Linux系统的初始化系统和服务管理器
• 替代了传统的SysV init系统
• 采用并行启动，大幅提升启动速度
• 使用unit文件描述系统资源和服务
```

### 1.2 systemd与传统init的区别


**🔄 启动方式对比**
```
传统SysV init：           systemd：
┌─服务A─启动完成─┐       ┌─服务A─┐
│               │       │      │
└─服务B─启动完成─┤  VS   ├─服务B─┤ 并行启动
│               │       │      │
└─服务C─启动完成─┘       └─服务C─┘

串行启动，慢              并行启动，快
```

**💡 主要优势**
- **启动速度快**：并行启动多个服务
- **依赖管理**：自动处理服务间依赖关系
- **资源控制**：可以限制服务的CPU、内存使用
- **日志集中**：统一的日志管理系统

---

## 2. 📊 systemd启动阶段划分


### 2.1 启动阶段概览


**🎯 四个主要阶段**
```
阶段1: 内核启动 → systemd接管
阶段2: 基础系统初始化
阶段3: 多用户环境准备
阶段4: 图形界面启动（可选）

时间轴：
开机 → [内核] → [systemd] → [基础服务] → [网络服务] → [图形界面]
 0s     1-3s      3-5s        5-10s       10-15s      15-20s
```

### 2.2 详细启动流程


**🔸 阶段1：systemd接管（PID 1）**
```
内核启动完成后：
1. 内核创建第一个用户空间进程
2. 执行 /sbin/init -> /lib/systemd/systemd
3. systemd成为PID 1进程
4. 开始解析配置文件

关键理解：
• PID 1是所有用户进程的祖先
• systemd必须永远运行，不能退出
• 负责回收孤儿进程
```

**🔸 阶段2：基础系统初始化**
```
basic.target相关服务：
┌─ 挂载文件系统
├─ 启动udev设备管理
├─ 配置网络接口  
├─ 加载内核模块
└─ 初始化系统时钟

这些是系统能正常工作的基础，必须先完成
```

**🔸 阶段3：多用户环境**
```
multi-user.target相关服务：
┌─ 网络服务（NetworkManager）
├─ SSH服务（sshd）
├─ 定时任务（cron）
├─ 日志服务（rsyslog）
└─ 数据库服务（mysql/postgresql）

用户可以登录使用系统的状态
```

**🔸 阶段4：图形界面（可选）**
```
graphical.target相关服务：
┌─ 显示管理器（gdm/lightdm）
├─ 桌面环境（gnome/kde）
├─ 音频服务（pulseaudio）
└─ 蓝牙服务（bluetooth）

提供图形用户界面
```

### 2.3 target概念解释


**📋 什么是target**
```
target = 目标状态 = 一组服务的集合

类比理解：
target就像"工作模式"
• rescue.target = 维修模式（最基本的服务）
• multi-user.target = 办公模式（命令行环境）
• graphical.target = 娱乐模式（图形界面）
```

**🎯 常见target类型**
| Target名称 | **含义** | **包含服务** | **使用场景** |
|-----------|----------|-------------|-------------|
| `rescue.target` | `紧急模式` | `最基本系统服务` | `系统修复` |
| `multi-user.target` | `多用户命令行` | `网络+基础服务` | `服务器环境` |
| `graphical.target` | `图形界面` | `桌面+所有服务` | `桌面环境` |
| `poweroff.target` | `关机` | `清理和关闭服务` | `系统关机` |

---

## 3. 🔗 target依赖关系解析


### 3.1 依赖关系类型


**📊 依赖关系说明**
```
A requires B：A必须要B，B失败则A也失败
A wants B：  A希望有B，B失败不影响A
A after B：  A在B之后启动（顺序关系）
A before B： A在B之前启动
```

**🌳 依赖关系树状图**
```
graphical.target
├─ multi-user.target
│  ├─ basic.target
│  │  ├─ sysinit.target
│  │  │  ├─ local-fs.target
│  │  │  └─ swap.target
│  │  └─ sockets.target
│  ├─ network.target
│  └─ getty.target
└─ display-manager.service

理解要点：
• 上层target包含下层target
• 启动时从底层向上层依次激活
• 某层失败会影响上层启动
```

### 3.2 依赖解析过程


**🔍 解析步骤**
```
步骤1️⃣：读取default.target
步骤2️⃣：递归解析所有依赖
步骤3️⃣：构建启动事务
步骤4️⃣：检查循环依赖
步骤5️⃣：确定启动顺序

示例解析过程：
default.target -> graphical.target
                    ↓
                 multi-user.target
                    ↓
                 basic.target
                    ↓
                 sysinit.target
```

### 3.3 循环依赖处理


**⚠️ 循环依赖问题**
```
问题场景：
服务A依赖服务B
服务B依赖服务C  
服务C依赖服务A

形成循环：A → B → C → A

解决方法：
• systemd自动检测循环依赖
• 断开某些"软依赖"（wants关系）
• 保留"硬依赖"（requires关系）
• 记录警告日志
```

---

## 4. ⚡ 并行启动机制


### 4.1 并行启动原理


**🚀 为什么能并行启动**
```
传统思维：必须等A完成再启动B
systemd智慧：A和B如果没有依赖关系，可以同时启动

并行启动示意图：
时间轴：  0s    2s    4s    6s    8s
服务A：   |--启动完成
服务B：   |--启动完成
服务C：        |--启动完成
服务D：        |-----启动完成

总用时：8s（而不是串行的16s）
```

**💡 并行条件**
- 服务间没有强依赖关系
- 系统资源充足（CPU、内存、磁盘IO）
- 服务本身支持并行启动

### 4.2 socket激活机制


**🔌 什么是socket激活**
```
传统方式：
1. 启动服务A
2. 服务A创建socket监听
3. 客户端连接socket

socket激活方式：
1. systemd预先创建socket
2. 客户端连接时才启动服务A
3. 服务A接管已存在的socket

优势：
• 更快的启动速度
• 按需启动服务
• 服务重启不丢失连接
```

**📋 socket激活示例**
```bash
# SSH服务的socket激活
# /lib/systemd/system/ssh.socket
[Unit]
Description=OpenBSD Secure Shell server socket

[Socket]
ListenStream=22          # 监听22端口
Accept=yes              # 接受连接

[Install]
WantedBy=sockets.target

# 当有SSH连接时，自动启动ssh.service
```

### 4.3 并行启动优化


**🎯 优化策略**
```
1. 服务分类：
   • 关键服务：必须等待完成
   • 普通服务：可以并行启动
   • 可选服务：可以延迟启动

2. 资源调度：
   • CPU密集型服务错开启动
   • 磁盘IO密集型服务排队
   • 内存占用大的服务优先级

3. 启动超时：
   • 设置合理的超时时间
   • 避免某个服务卡住整个启动过程
```

---

## 5. 📋 服务依赖排序


### 5.1 排序算法原理


**🔢 拓扑排序**
```
什么是拓扑排序：
把有依赖关系的服务按照正确的顺序排列

例子：
A依赖B，B依赖C
正确顺序：C → B → A

拓扑排序步骤：
1️⃣ 找出没有依赖的服务（入度为0）
2️⃣ 启动这些服务
3️⃣ 从依赖图中移除已启动的服务
4️⃣ 重复1-3步，直到所有服务启动完成
```

### 5.2 依赖类型影响排序


**📊 不同依赖类型的排序规则**

```
┌─ Requires依赖 ─┐
│ 强制依赖，必须  │
│ 严格按顺序启动  │
└────────────────┘

┌─ Wants依赖 ────┐
│ 希望依赖，可选  │
│ 尽量按顺序启动  │
└────────────────┘

┌─ After依赖 ────┐
│ 顺序依赖，排序  │
│ 只管先后顺序    │
└────────────────┘
```

**🔄 排序示例**
```
服务配置：
A.service: After=B.service, Wants=C.service
B.service: Requires=D.service
C.service: After=D.service

排序结果：
D → B → C → A

解释：
• D没有依赖，最先启动
• B需要D，D完成后启动B
• C在D之后，可以和B并行
• A最后启动，等待B和C
```

### 5.3 启动时间优化


**⏱️ 关键路径分析**
```
找出启动时间最长的路径：

路径1：D(2s) → B(3s) → A(1s) = 6秒
路径2：D(2s) → C(4s) → A(1s) = 7秒

关键路径是路径2，总启动时间7秒

优化思路：
• 优化C服务的启动时间
• 或者让C和B并行启动
```

---

## 6. 🎯 default.target选择机制


### 6.1 default.target是什么


**📋 概念解释**
```
default.target = 系统默认启动目标

类比理解：
就像电脑开机后进入的默认模式
• Windows默认进入桌面
• Linux可以选择进入命令行或图形界面

systemd启动流程：
开机 → systemd → default.target → 对应的服务集合
```

### 6.2 target选择机制


**🔍 选择优先级**
```
优先级从高到低：

1️⃣ 内核启动参数：systemd.unit=rescue.target
2️⃣ /etc/systemd/system/default.target链接
3️⃣ 编译时默认值（通常是graphical.target）

实际检查过程：
systemd启动 → 检查内核参数 → 检查default.target → 应用默认值
```

**📂 default.target配置**
```bash
# 查看当前默认target
systemctl get-default

# 设置默认target为多用户模式
systemctl set-default multi-user.target

# 设置默认target为图形模式  
systemctl set-default graphical.target

# 实际上是创建软链接
ls -l /etc/systemd/system/default.target
# lrwxrwxrwx 1 root root 36 /etc/systemd/system/default.target -> /lib/systemd/system/graphical.target
```

### 6.3 运行时target切换


**🔄 动态切换target**
```bash
# 切换到救援模式（单用户）
systemctl isolate rescue.target

# 切换到多用户命令行模式
systemctl isolate multi-user.target

# 切换到图形界面模式
systemctl isolate graphical.target

# 重启到不同target
systemctl reboot --boot-loader-entry=rescue
```

**⚠️ isolate命令说明**
```
isolate = 隔离启动
• 停止当前target的所有服务
• 启动新target需要的服务
• 类似完全切换工作模式

注意：只有设置了AllowIsolate=yes的target才能被隔离启动
```

---

## 7. 💼 启动事务处理


### 7.1 什么是启动事务


**💡 事务概念**
```
事务 = 一组操作的集合，要么全部成功，要么全部失败

systemd启动事务：
把所有需要启动的服务看作一个事务
• 分析依赖关系
• 确定启动顺序
• 并行执行服务启动
• 处理失败情况
```

**📊 事务处理流程**
```
开始启动
    ↓
解析default.target
    ↓
递归分析依赖
    ↓
构建启动事务
    ↓
检查冲突和循环依赖
    ↓
优化启动顺序
    ↓
执行并行启动
    ↓
处理失败和超时
    ↓
完成启动
```

### 7.2 事务冲突处理


**⚠️ 常见冲突类型**
```
1. 服务冲突：
   两个服务不能同时运行
   例：apache2 vs nginx（都监听80端口）

2. 资源冲突：
   多个服务需要独占同一资源
   例：多个服务要绑定同一端口

3. 配置冲突：
   服务配置互相矛盾
   例：网络配置冲突
```

**🔧 冲突解决策略**
```bash
# 在unit文件中声明冲突
[Unit]
Description=Apache HTTP Server
Conflicts=nginx.service    # 与nginx冲突
After=network.target

# systemd自动处理：
# • 如果nginx正在运行，启动apache时会先停止nginx
# • 如果同时启动两者，根据优先级选择一个
```

### 7.3 事务失败恢复


**🚑 失败处理机制**
```
服务启动失败时：
1️⃣ 记录失败信息到日志
2️⃣ 根据配置决定是否继续
3️⃣ 可能回滚已启动的相关服务
4️⃣ 进入降级模式（如emergency.target）

配置选项：
• OnFailure：失败时启动的服务
• FailureAction：失败时的系统动作
• JobTimeoutSec：作业超时时间
```

---

## 8. ⏰ 服务超时处理


### 8.1 超时机制概述


**🕐 为什么需要超时处理**
```
问题场景：
某个服务启动时卡住了，一直等待
→ 整个系统启动被阻塞
→ 用户无法正常使用系统

超时机制：
给每个服务设置最大等待时间
超时后采取相应措施，不影响整体启动
```

### 8.2 超时参数配置


**⚙️ 常用超时参数**
```bash
[Service]
Type=simple
ExecStart=/usr/bin/myservice

# 启动超时（默认90秒）
TimeoutStartSec=60s

# 停止超时（默认90秒）  
TimeoutStopSec=30s

# 整体超时
TimeoutSec=120s

# 定期检查服务状态的间隔
WatchdogSec=30s
```

**📊 不同服务类型的超时策略**
| 服务类型 | **启动超时** | **停止超时** | **说明** |
|---------|-------------|-------------|---------|
| `数据库` | `60-120s` | `30-60s` | `启动慢，停止需要保存数据` |
| `Web服务` | `30-60s` | `10-30s` | `启动较快，停止简单` |
| `系统服务` | `10-30s` | `5-15s` | `基础服务，应该很快` |
| `网络服务` | `30-90s` | `15-30s` | `可能需要网络连接时间` |

### 8.3 超时处理策略


**🚨 超时后的处理动作**
```bash
[Service]
# 超时后的处理方式
TimeoutStartSec=60s

# 失败时的动作
FailureAction=none        # 什么都不做（默认）
FailureAction=reboot      # 重启系统
FailureAction=poweroff    # 关机
FailureAction=exit        # 退出systemd

# 重启策略
Restart=always           # 总是重启
Restart=on-failure       # 失败时重启
Restart=no              # 不重启

# 重启间隔
RestartSec=5s
```

**🔄 实际超时处理示例**
```
服务mysql启动超时处理：

1️⃣ mysql.service配置TimeoutStartSec=120s
2️⃣ 如果120秒内没有启动完成
3️⃣ systemd发送SIGTERM信号给mysql进程
4️⃣ 等待TimeoutStopSec时间（默认90s）
5️⃣ 如果进程还没退出，发送SIGKILL强制杀死
6️⃣ 标记mysql.service为failed状态
7️⃣ 记录日志，继续启动其他服务
```

---

## 9. 📝 systemd日志记录


### 9.1 systemd日志系统


**📋 日志系统组成**
```
systemd日志 = journald + 传统syslog

journald特点：
• 二进制格式存储
• 结构化日志记录
• 自动日志轮转
• 丰富的查询功能

存储位置：
/var/log/journal/    # 持久化日志
/run/log/journal/    # 内存中的临时日志
```

### 9.2 启动日志查看


**🔍 常用日志查看命令**
```bash
# 查看启动日志
journalctl -b                    # 本次启动的日志
journalctl -b -1                 # 上次启动的日志
journalctl -b 0                  # 当前启动的日志

# 查看特定服务日志
journalctl -u sshd               # SSH服务日志
journalctl -u NetworkManager     # 网络管理器日志

# 实时跟踪日志
journalctl -f                    # 类似tail -f
journalctl -u mysql -f           # 跟踪mysql服务日志

# 按时间查看
journalctl --since "2024-01-01"
journalctl --since "1 hour ago"
journalctl --until "2024-01-31"
```

### 9.3 日志分析技巧


**📊 关键信息识别**
```bash
# 查看启动时间分析
systemd-analyze                  # 总体启动时间
systemd-analyze blame           # 各服务启动时间排序
systemd-analyze critical-chain  # 关键路径分析

# 输出示例：
Startup finished in 2.841s (kernel) + 8.082s (userspace) = 10.923s
graphical.target @8.082s
└─multi-user.target @8.081s
  └─NetworkManager.service @3.054s +2.010s
    └─dbus.service @2.993s
      └─basic.target @2.985s
```

**⚠️ 常见错误日志**
```bash
# 查找错误和警告
journalctl -p err                # 只显示错误
journalctl -p warning            # 显示警告及以上级别

# 查找特定关键词
journalctl -b | grep -i error    # 查找错误信息
journalctl -b | grep -i failed   # 查找失败信息
journalctl -b | grep timeout     # 查找超时信息

# 常见启动问题：
• "Failed to start xxx.service"  # 服务启动失败
• "Dependency failed"            # 依赖关系失败  
• "Timed out"                   # 启动超时
• "Job xxx.service/start failed" # 作业执行失败
```

### 9.4 日志配置优化


**⚙️ journald配置**
```bash
# 编辑journald配置
sudo nano /etc/systemd/journald.conf

[Journal]
# 存储方式
Storage=persistent              # 持久化存储
#Storage=volatile               # 只在内存中
#Storage=auto                   # 自动选择

# 日志大小限制
SystemMaxUse=500M              # 最大占用磁盘空间
SystemMaxFileSize=50M          # 单个日志文件大小
MaxRetentionSec=1month         # 日志保留时间

# 压缩和转发
Compress=yes                   # 压缩旧日志
ForwardToSyslog=no            # 不转发给syslog
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 systemd本质：现代Linux的初始化系统和服务管理器
🔸 启动阶段：内核→systemd→基础服务→多用户→图形界面
🔸 target概念：一组服务的集合，定义系统运行状态  
🔸 并行启动：根据依赖关系同时启动多个服务
🔸 依赖管理：requires/wants/after/before关系
🔸 超时处理：防止单个服务阻塞整个启动过程
🔸 日志系统：journald提供结构化日志记录
```

### 10.2 关键理解要点


**🔹 systemd的核心优势**
```
传统init问题：
• 串行启动，速度慢
• 脚本复杂，难维护
• 依赖关系手动管理

systemd解决方案：
• 并行启动，速度快
• 声明式配置，简单
• 自动依赖解析
```

**🔹 启动流程的理解**
```
关键路径思维：
• 找出启动时间最长的服务链
• 优化关键路径上的服务
• 其他服务可以并行启动

依赖关系理解：
• requires = 必须依赖
• wants = 希望依赖  
• after = 顺序依赖
• before = 反向顺序依赖
```

**🔹 故障排除思路**
```
启动问题分析：
1️⃣ 查看systemd-analyze了解整体时间
2️⃣ 用journalctl查看具体错误信息
3️⃣ 检查服务依赖关系是否正确
4️⃣ 确认服务配置文件语法
5️⃣ 测试服务的超时设置
```

### 10.3 实际应用场景


**🎯 服务器启动优化**
- **分析启动瓶颈**：找出最慢的服务
- **调整依赖关系**：减少不必要的串行等待  
- **配置合理超时**：避免卡死但给足够时间
- **优化服务配置**：使用socket激活等技术

**🔧 故障诊断技巧**
- **启动失败**：检查依赖关系和配置文件
- **启动变慢**：分析关键路径，优化慢服务
- **服务冲突**：检查端口和资源占用冲突
- **随机失败**：查看超时和资源限制设置

### 10.4 最佳实践建议


**✨ 服务配置最佳实践**
```
1. 明确依赖关系：
   • 必须的用requires
   • 可选的用wants  
   • 顺序用after/before

2. 合理设置超时：
   • 不要太短（避免误杀）
   • 不要太长（避免等待）
   • 根据服务特点调整

3. 优化启动性能：
   • 使用socket激活
   • 减少不必要的依赖
   • 并行启动无关服务

4. 做好日志记录：
   • 定期清理日志
   • 关注错误信息
   • 建立监控机制
```

**核心记忆口诀**：
- systemd管启动，并行速度快
- target是目标，依赖要理清
- 超时防卡死，日志查问题
- 优化看路径，排错有方法