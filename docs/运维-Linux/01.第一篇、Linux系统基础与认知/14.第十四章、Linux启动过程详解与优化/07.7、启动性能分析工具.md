---
title: 7、启动性能分析工具
---
## 📚 目录

1. [启动性能分析概述](#1-启动性能分析概述)
2. [systemd-analyze核心工具](#2-systemd-analyze核心工具)
3. [bootchart启动图表分析](#3-bootchart启动图表分析)
4. [内核启动时间测量](#4-内核启动时间测量)
5. [服务启动时间统计](#5-服务启动时间统计)
6. [瓶颈识别与优化方法](#6-瓶颈识别与优化方法)
7. [性能基准对比分析](#7-性能基准对比分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 启动性能分析概述


### 1.1 什么是启动性能分析


**简单理解**：就像给你的电脑做"体检"，看看开机时哪些步骤慢了，找出拖后腿的环节。

```
启动过程像接力赛：
BIOS/UEFI → 内核加载 → systemd启动 → 各种服务启动 → 用户登录

每个环节都要计时，看谁跑得慢！
```

### 1.2 为什么要做启动分析


**核心目的**：
- 🎯 **找出慢的服务**：哪个服务启动时间最长
- 🔍 **识别瓶颈**：什么地方卡住了启动过程
- ⚡ **提升启动速度**：让系统开机更快
- 📊 **监控性能变化**：升级后是变快了还是变慢了

> 💡 **生活类比**：就像分析早上出门为什么总是迟到，是刷牙慢了？穿衣服慢了？还是找钥匙花时间太多？

### 1.3 启动时间的构成


```
系统启动总时间构成：

固件时间        内核时间        用户空间时间
┌─────────┐   ┌─────────┐    ┌──────────────┐
│ BIOS/   │→  │ 内核    │ →  │ systemd +    │
│ UEFI    │   │ 加载    │    │ 各种服务     │
└─────────┘   └─────────┘    └──────────────┘
  通常固定      可能有问题      重点分析对象
```

---

## 2. 🔧 systemd-analyze核心工具


### 2.1 systemd-analyze基本介绍


**什么是systemd-analyze**：这是systemd自带的启动分析工具，就像系统启动的"医生"，能诊断启动过程中的各种问题。

> 📝 **记住**：只要你的Linux系统用的是systemd（现在大部分都是），就一定有这个工具。

### 2.2 查看启动总时间


**基本命令**：
```bash
systemd-analyze
```

**输出示例**：
```
启动完成于 2.534s (固件) + 1.234s (加载器) + 2.456s (内核) + 8.765s (用户空间) = 15.989s
graphical.target reached after 8.765s in userspace
```

**结果解读**：
- **固件时间**：BIOS/UEFI自检时间（硬件决定，基本改不了）
- **加载器时间**：GRUB等启动加载器时间
- **内核时间**：Linux内核初始化时间
- **用户空间时间**：systemd和各种服务启动时间（**重点关注**）

### 2.3 blame分析 - 找出最慢的服务


**命令**：
```bash
systemd-analyze blame
```

**作用**：列出所有服务的启动时间，按从慢到快排序

**输出示例**：
```
3.234s NetworkManager.service
2.567s mysqld.service
1.890s httpd.service
1.234s sshd.service
0.567s chronyd.service
0.234s systemd-logind.service
```

**实用解读**：
- **排在前面的服务**就是启动最慢的"罪魁祸首"
- **重点关注超过1秒的服务**
- **网络服务通常比较慢**（NetworkManager、网卡驱动等）

> ⚠️ **注意**：blame只显示每个服务自己的时间，不包括依赖关系的等待时间

### 2.4 critical-chain分析 - 找出关键路径


**命令**：
```bash
systemd-analyze critical-chain
```

**作用**：显示启动的"关键路径"，就像找出最慢的那条"依赖链"

**输出示例**：
```
graphical.target @8.765s
└─multi-user.target @8.234s
  └─mysql.service @5.678s +2.556s
    └─network.target @5.123s
      └─NetworkManager.service @1.789s +3.334s
        └─basic.target @1.678s
          └─sysinit.target @1.234s
```

**关键符号解释**：
- `@8.765s` - 这个服务在第8.765秒时启动完成
- `+2.556s` - 这个服务本身花了2.556秒启动
- `└─` - 依赖关系，表示"依赖于"

**实际含义**：
```
理解关键路径：

NetworkManager启动慢(+3.334s) 
      ↓
network.target被拖慢
      ↓  
mysql.service等network.target，也被拖慢
      ↓
整个系统启动被拖慢
```

### 2.5 plot绘图 - 可视化启动过程


**命令**：
```bash
systemd-analyze plot > startup.svg
```

**作用**：生成启动过程的时间轴图表，用浏览器打开SVG文件就能看到图形界面

**图表内容**：
- **横轴**：时间轴（从0秒到启动完成）
- **纵轴**：各个服务
- **彩色条带**：每个服务的启动时间段
- **依赖线**：服务之间的依赖关系

**实用技巧**：
```bash
# 生成图表并直接用浏览器打开
systemd-analyze plot > /tmp/startup.svg && firefox /tmp/startup.svg
```

---

## 3. 📊 bootchart启动图表分析


### 3.1 什么是bootchart


**简单理解**：bootchart就像给启动过程拍"视频"，记录每一秒钟系统在做什么，最后生成一张详细的图表。

**与systemd-analyze的区别**：
```
systemd-analyze：          bootchart：
主要看服务启动时间        →  看整个系统资源使用情况
文字输出为主              →  图形化显示
只看systemd管理的服务     →  包括内核、进程、CPU、内存等
```

### 3.2 安装bootchart


**Ubuntu/Debian系统**：
```bash
sudo apt install bootchart2 pybootchartgui
```

**CentOS/RHEL系统**：
```bash
sudo yum install bootchart2
# 或新版本
sudo dnf install bootchart2
```

### 3.3 启用bootchart监控


**临时启用（下次启动生效）**：
```bash
# 在内核启动参数中添加
sudo vim /etc/default/grub
# 在GRUB_CMDLINE_LINUX中添加：initcall_debug printk.time=y
```

**systemd方式启用**：
```bash
sudo systemctl enable bootchart
```

### 3.4 bootchart图表解读


**图表包含内容**：

```
CPU使用率图表
┌─────────────────────────────────────┐
│     ████                 ███        │ ← CPU繁忙程度
│  ███    ███           ███   ██      │
│ ██        ██       ███        ███   │
└─────────────────────────────────────┘
0s    10s    20s    30s    40s    50s

进程启动时序图
├── init (PID 1)
│   ├── systemd-journald
│   ├── systemd-udevd  
│   │   ├── NetworkManager
│   │   └── sshd
│   └── gdm
```

**关键指标理解**：
- **CPU峰值**：启动过程中CPU最忙的时段
- **I/O等待**：磁盘读写等待时间
- **进程数量**：同时运行的进程数
- **内存使用**：启动过程中的内存占用

---

## 4. ⏱️ 内核启动时间测量


### 4.1 内核启动时间分析


**查看内核启动信息**：
```bash
dmesg | head -20
```

**输出示例**：
```
[    0.000000] Linux version 5.4.0-48-generic
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz root=UUID=...
[    0.001234] x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'
[    1.234567] ACPI: Core revision 20190816
[    2.345678] PCI: Using configuration type 1 for base access
```

**时间戳含义**：
- `[0.000000]` - 内核启动的第0秒（基准时间）
- `[1.234567]` - 内核启动后1.234567秒发生的事件
- 最后一个时间戳大概就是内核启动完成时间

### 4.2 关键内核启动阶段


**内核启动的几个重要时间点**：

```bash
# 查看文件系统挂载时间
dmesg | grep -i "mounted root"

# 查看init进程启动时间  
dmesg | grep -i "init"

# 查看网络初始化时间
dmesg | grep -i "network"
```

**典型输出分析**：
```
[    2.456789] VFS: Mounted root (ext4 filesystem)    ← 根文件系统挂载完成
[    3.123456] systemd[1]: systemd 245 running       ← systemd开始接管
[    4.789012] IPv4 over IPv4 tunneling driver       ← 网络功能初始化
```

### 4.3 内核启动性能问题排查


**常见慢启动原因**：

| 问题类型 | **现象** | **排查方法** | **解决思路** |
|---------|---------|-------------|-------------|
| 🔍 **硬件检测慢** | `ACPI等待时间长` | `dmesg \| grep -i acpi` | `BIOS设置优化` |
| 💾 **磁盘问题** | `文件系统挂载慢` | `dmesg \| grep -i filesystem` | `检查磁盘健康度` |
| 🌐 **网络配置** | `网络初始化等待` | `dmesg \| grep -i network` | `网络配置优化` |
| 🔌 **USB设备** | `USB设备枚举慢` | `dmesg \| grep -i usb` | `禁用不需要的USB` |

---

## 5. 📋 服务启动时间统计


### 5.1 详细服务时间分析


**按服务类型分组查看**：
```bash
# 查看最慢的10个服务
systemd-analyze blame | head -10

# 查看特定服务的详细信息
systemd-analyze critical-chain sshd.service
```

**按时间范围筛选**：
```bash
# 查看启动时间超过1秒的服务
systemd-analyze blame | awk '$1 > 1.0 {print}'

# 查看启动时间超过500ms的服务  
systemd-analyze blame | grep -E "[0-9]+\.[5-9][0-9][0-9]s|[0-9]+s"
```

### 5.2 服务启动状态检查


**检查失败的服务**：
```bash
# 查看启动失败的服务
systemctl --failed

# 查看特定服务的详细状态
systemctl status NetworkManager.service

# 查看服务的启动日志
journalctl -u NetworkManager.service --since boot
```

**服务启动统计脚本**：
```bash
#!/bin/bash
# 服务启动时间统计脚本

echo "=== 启动总时间 ==="
systemd-analyze

echo -e "\n=== 最慢的5个服务 ==="
systemd-analyze blame | head -5

echo -e "\n=== 启动失败的服务 ==="  
systemctl --failed --no-pager

echo -e "\n=== 关键路径分析 ==="
systemd-analyze critical-chain | head -10
```

### 5.3 服务依赖关系分析


**查看服务依赖**：
```bash
# 查看某个服务依赖什么
systemctl list-dependencies graphical.target

# 查看什么服务依赖某个服务
systemd-analyze critical-chain NetworkManager.service
```

**依赖关系可视化**：
```
graphical.target (图形界面)
├─ multi-user.target (多用户模式)
│  ├─ basic.target (基础服务)
│  │  ├─ sysinit.target (系统初始化)  
│  │  └─ sockets.target (套接字服务)
│  ├─ network.target (网络服务)
│  └─ ssh.service (SSH服务)
└─ display-manager.service (显示管理器)
```

---

## 6. 🔍 瓶颈识别与优化方法


### 6.1 常见启动瓶颈类型


**网络服务瓶颈**：
```bash
# 检查网络相关的慢服务
systemd-analyze blame | grep -i network
systemd-analyze blame | grep -i manager

# 常见问题：
# - NetworkManager等待网络连接超时
# - DHCP获取IP地址慢  
# - DNS解析配置问题
```

**数据库服务瓶颈**：
```bash
# 检查数据库启动时间
systemd-analyze blame | grep -E "(mysql|mariadb|postgresql)"

# 常见问题：
# - 数据库恢复检查时间长
# - 大量数据需要加载
# - 配置文件解析慢
```

**存储I/O瓶颈**：
```bash
# 查看磁盘相关的慢启动
dmesg | grep -i "mounted"
systemd-analyze blame | grep -i mount
```

### 6.2 瓶颈识别方法


**系统性分析流程**：

```
第1步：总体分析
systemd-analyze  ← 看总启动时间

第2步：服务分析  
systemd-analyze blame  ← 找最慢服务

第3步：依赖分析
systemd-analyze critical-chain  ← 找关键路径

第4步：详细分析
journalctl -u 慢服务名称  ← 看具体问题

第5步：可视化分析
systemd-analyze plot > boot.svg  ← 生成图表
```

**瓶颈识别脚本示例**：
```bash
#!/bin/bash
# 启动瓶颈快速诊断脚本

echo "🔍 启动瓶颈快速诊断"
echo "===================="

echo "📊 总启动时间："
systemd-analyze | head -1

echo -e "\n🐌 最慢的3个服务："
systemd-analyze blame | head -3

echo -e "\n🔗 关键路径上的慢服务："
systemd-analyze critical-chain | grep "+" | head -3

echo -e "\n❌ 启动失败的服务："
if systemctl --failed --quiet; then
    systemctl --failed --no-pager
else
    echo "✅ 没有启动失败的服务"
fi

echo -e "\n🌐 网络相关慢服务："
systemd-analyze blame | grep -i -E "(network|manager|dhcp)" | head -3
```

### 6.3 优化策略和方法


**禁用不需要的服务**：
```bash
# 查看所有开机启动的服务
systemctl list-unit-files --type=service --state=enabled

# 禁用不需要的服务（示例）
sudo systemctl disable bluetooth.service    # 如果不用蓝牙
sudo systemctl disable cups.service         # 如果不用打印机
sudo systemctl disable postfix.service      # 如果不用邮件服务
```

**并行化服务启动**：
```bash
# 检查服务是否可以并行启动
# 编辑服务文件，移除不必要的After=依赖

sudo systemctl edit some-service.service
```

**网络优化配置**：
```bash
# 配置NetworkManager不等待网络连接
sudo vim /etc/NetworkManager/conf.d/10-globally-managed-devices.conf

# 内容：
[main]
no-auto-default=*
```

---

## 7. 📈 性能基准对比分析


### 7.1 建立性能基准


**创建启动性能记录**：
```bash
#!/bin/bash
# 启动性能基准测试脚本

DATE=$(date +%Y%m%d_%H%M%S)
LOGDIR="/var/log/boot-performance"
sudo mkdir -p $LOGDIR

echo "记录启动性能基准: $DATE"

# 记录总启动时间
systemd-analyze > $LOGDIR/analyze_$DATE.log

# 记录服务启动时间
systemd-analyze blame > $LOGDIR/blame_$DATE.log

# 记录关键路径
systemd-analyze critical-chain > $LOGDIR/critical_$DATE.log

# 生成启动图表
systemd-analyze plot > $LOGDIR/plot_$DATE.svg

echo "基准记录完成，保存在: $LOGDIR"
```

### 7.2 性能对比分析


**对比不同时期的启动性能**：
```bash
# 比较两次启动时间
echo "=== 历史启动时间对比 ==="
echo "上次启动："
cat /var/log/boot-performance/analyze_20241201_090000.log | head -1
echo "本次启动："  
systemd-analyze | head -1
```

**服务启动时间变化分析**：
```bash
#!/bin/bash
# 服务启动时间变化分析

OLD_FILE="/var/log/boot-performance/blame_20241201.log"
NEW_FILE="/tmp/blame_current.log"

systemd-analyze blame > $NEW_FILE

echo "服务启动时间变化分析："
echo "========================"

while read line; do
    service=$(echo $line | awk '{print $2}')
    old_time=$(echo $line | awk '{print $1}')
    
    new_time=$(grep $service $NEW_FILE | awk '{print $1}' | sed 's/s$//')
    
    if [ ! -z "$new_time" ]; then
        change=$(echo "$new_time - $old_time" | bc -l)
        printf "%-30s: %8s -> %8s (变化: %+.3fs)\n" $service $old_time $new_time $change
    fi
done < $OLD_FILE
```

### 7.3 性能监控自动化


**定期性能检查脚本**：
```bash
#!/bin/bash
# 启动性能监控脚本 (放入crontab定期执行)

THRESHOLD_TOTAL=30      # 总启动时间阈值(秒)
THRESHOLD_SERVICE=5     # 单个服务启动时间阈值(秒)
LOG_FILE="/var/log/boot-monitor.log"

# 获取当前启动时间
TOTAL_TIME=$(systemd-analyze | grep "=>" | awk '{print $(NF-1)}' | sed 's/s$//')
DATE=$(date '+%Y-%m-%d %H:%M:%S')

echo "[$DATE] 总启动时间: ${TOTAL_TIME}s" >> $LOG_FILE

# 检查是否超过阈值
if (( $(echo "$TOTAL_TIME > $THRESHOLD_TOTAL" | bc -l) )); then
    echo "[$DATE] ⚠️  启动时间超过阈值 ${THRESHOLD_TOTAL}s" >> $LOG_FILE
    
    # 记录慢服务
    echo "[$DATE] 慢服务列表:" >> $LOG_FILE
    systemd-analyze blame | head -5 >> $LOG_FILE
fi
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 systemd-analyze：系统启动分析的核心工具
🔸 blame分析：找出启动最慢的服务，按时间排序
🔸 critical-chain：识别启动的关键依赖路径  
🔸 plot图表：可视化启动过程的时间线
🔸 bootchart：更详细的启动过程图表分析
🔸 瓶颈识别：从网络、存储、服务依赖等角度分析问题
🔸 性能基准：建立对比标准，监控性能变化趋势
```

### 8.2 关键理解要点


**🔹 启动分析的核心思路**
```
总体分析 → 服务分析 → 依赖分析 → 深入诊断 → 优化实施

就像看病：先量体温（总时间）→ 找症状（慢服务）→ 查原因（依赖关系）→ 开药方（优化策略）
```

**🔹 时间数据的正确理解**
```
blame时间：服务自己的启动耗时
critical-chain时间：包含等待依赖的总耗时

一个服务blame显示1秒，critical-chain可能显示5秒
→ 说明这个服务等待依赖服务用了4秒
```

**🔹 优化的优先级原则**
```
1. 先解决启动失败的服务（必须修复）
2. 再优化关键路径上的慢服务（影响最大）
3. 最后考虑禁用不需要的服务（额外收益）
```

### 8.3 实际应用场景


**🎯 服务器启动优化**：
- 数据库服务器：重点分析MySQL/PostgreSQL启动时间
- Web服务器：关注Apache/Nginx、PHP-FPM等服务
- 开发环境：可以禁用一些不必要的系统服务

**🎯 桌面系统优化**：
- 显示管理器：GDM、LightDM启动时间分析
- 网络管理：NetworkManager配置优化
- 开机自启程序：清理不必要的开机启动项

**🎯 问题排查场景**：
- 系统更新后启动变慢：对比更新前后的启动数据
- 新安装软件影响启动：分析新增服务的启动时间
- 硬件故障导致启动慢：通过内核日志分析硬件问题

### 8.4 实用技巧总结


**📋 日常使用清单**：
```bash
# 快速检查启动情况（每天一次）
systemd-analyze

# 深入分析慢启动问题（发现问题时）  
systemd-analyze blame
systemd-analyze critical-chain
systemctl --failed

# 可视化分析（复杂问题时）
systemd-analyze plot > boot.svg

# 建立性能基准（系统变更前后）
systemd-analyze > baseline.log
```

**⚠️ 常见误区提醒**：
- **不要盲目禁用服务**：先确认服务的作用再决定是否禁用
- **blame时间不等于影响**：要结合critical-chain分析真实影响  
- **硬件因素很重要**：SSD vs 机械硬盘对启动时间影响巨大
- **网络环境影响**：DHCP、DNS配置问题会显著影响启动时间

**核心记忆要点**：
- 启动分析三步走：总时间→慢服务→关键路径
- systemd-analyze是主要工具，blame找慢的，critical-chain找卡的
- 优化重点是关键路径上的慢服务，不是所有慢服务
- 定期建立性能基准，监控系统启动性能变化趋势