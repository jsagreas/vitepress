---
title: 10、性能参数初始调优
---
## 📚 目录

1. [系统资源限制配置详解](#1-系统资源限制配置详解)
2. [内核参数基础优化](#2-内核参数基础优化)
3. [文件描述符限制调整](#3-文件描述符限制调整)
4. [网络参数基础优化](#4-网络参数基础优化)
5. [内存管理参数调整](#5-内存管理参数调整)
6. [I/O调度器选择与配置](#6-IO调度器选择与配置)
7. [系统性能基线建立](#7-系统性能基线建立)
8. [性能监控工具基础配置](#8-性能监控工具基础配置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 系统资源限制配置详解


### 1.1 什么是系统资源限制

🎯 **简单理解**：就像给每个程序设定"使用规则"

```
生活化比喻：
想象一个图书馆：
- 每个人最多能借10本书（文件描述符限制）
- 每个人在馆内最多待8小时（CPU时间限制）
- 每个人的书包最多装5公斤（内存使用限制）

系统资源限制也是类似的道理：
- 防止单个程序消耗过多资源
- 保护系统整体稳定性
- 确保多程序公平使用资源
```

### 1.2 ulimit命令详解

**🔸 ulimit是什么**
```
ulimit = user limit （用户限制）
作用：控制当前shell及其启动的进程能使用的资源
影响范围：当前用户的当前会话
生效时间：临时生效，重启失效
```

**📋 常用ulimit选项**
```bash
# 查看所有当前限制
ulimit -a

# 常用选项说明：
ulimit -n     # 文件描述符数量（最重要）
ulimit -u     # 最大进程数
ulimit -c     # 核心转储文件大小
ulimit -f     # 单个文件最大大小
ulimit -m     # 最大内存使用量
ulimit -t     # CPU时间限制（秒）
ulimit -v     # 虚拟内存限制
```

**💡 实际使用示例**
```bash
# 查看当前文件描述符限制
ulimit -n
# 输出：1024（默认值，通常不够用）

# 临时增加文件描述符限制
ulimit -n 65536
# 这次会话有效，重启后恢复默认

# 查看修改后的结果
ulimit -n
# 输出：65536

# 查看当前用户的所有资源限制
ulimit -a
# 显示完整的限制列表
```

### 1.3 永久资源限制配置

**🔧 /etc/security/limits.conf 配置**

```bash
# 编辑系统资源限制配置文件
sudo vim /etc/security/limits.conf

# 配置格式：
# <domain> <type> <item> <value>
# domain: 用户名或组名（*表示所有用户）
# type: soft(软限制) 或 hard(硬限制)
# item: 资源类型
# value: 限制值
```

**📊 推荐的基础配置**
```bash
# 文件描述符限制（最重要的配置）
* soft nofile 65536
* hard nofile 65536

# 进程数限制
* soft nproc 32768
* hard nproc 32768

# 核心转储文件大小（用于调试）
* soft core unlimited
* hard core unlimited

# 最大文件大小限制
* soft fsize unlimited
* hard fsize unlimited

# 针对特定用户的配置示例
mysql soft nofile 65536
mysql hard nofile 65536
nginx soft nofile 65536  
nginx hard nofile 65536
```

**🔸 软限制 vs 硬限制的区别**
```
软限制（soft limit）：
- 当前实际生效的限制
- 用户可以自行调整（但不能超过硬限制）
- 相当于"建议限制"

硬限制（hard limit）：
- 软限制的上限
- 只有root用户才能修改
- 相当于"绝对限制"

实际应用：
通常设置为相同值，简化管理
软限制可以动态调整，硬限制做最终保护
```

### 1.4 验证和生效配置

**✅ 配置生效验证**

```bash
# 1. 重新登录用户（让limits.conf生效）
exit
# 重新ssh登录

# 2. 验证新的限制值
ulimit -n
# 应该显示65536

# 3. 验证进程限制
ulimit -u  
# 应该显示32768

# 4. 查看系统级别的限制
cat /proc/sys/fs/file-max
# 系统整体文件描述符限制

# 5. 查看当前系统使用情况
cat /proc/sys/fs/file-nr
# 已分配、已使用、最大限制
```

---

## 2. ⚙️ 内核参数基础优化


### 2.1 sysctl是什么

🎯 **通俗理解**：sysctl就像系统的"控制面板"

```
类比Windows系统：
Windows有"控制面板"可以调整系统设置
Linux的sysctl就是命令行版本的控制面板

作用：
- 动态修改运行中的内核参数
- 不需要重启系统立即生效
- 控制系统底层行为和性能
```

### 2.2 sysctl基本操作

**🔧 基础命令使用**

```bash
# 查看所有内核参数（输出很多）
sysctl -a | head -20

# 查看特定参数
sysctl kernel.hostname
# 输出：kernel.hostname = myserver

# 临时修改参数
sudo sysctl kernel.hostname=newname
# 立即生效，重启后恢复

# 从文件加载配置
sudo sysctl -p /etc/sysctl.conf
# 加载配置文件中的所有设置

# 查看网络相关参数
sysctl net.core | head -10
# 显示网络核心参数
```

### 2.3 重要的内核参数分类

**📊 内核参数的主要分类**

```
内核参数命名规律：
kernel.*    - 内核核心功能参数
net.*       - 网络相关参数  
vm.*        - 虚拟内存管理参数
fs.*        - 文件系统相关参数
dev.*       - 设备相关参数

举例说明：
net.core.somaxconn     - 网络连接队列大小
vm.swappiness          - 内存交换积极程度
fs.file-max            - 系统最大文件描述符
kernel.pid_max         - 最大进程ID号
```

### 2.4 推荐的基础优化参数

**🚀 生产环境推荐配置**

```bash
# 编辑主配置文件
sudo vim /etc/sysctl.conf

# 或创建独立配置文件
sudo vim /etc/sysctl.d/99-performance.conf
```

**📋 基础性能优化配置**
```bash
# ===== 网络基础优化 =====
# TCP连接队列大小（重要）
net.core.somaxconn = 32768
# 网络设备接收队列
net.core.netdev_max_backlog = 32768  
# 接收缓冲区大小
net.core.rmem_default = 262144
net.core.rmem_max = 16777216
# 发送缓冲区大小  
net.core.wmem_default = 262144
net.core.wmem_max = 16777216

# ===== 内存管理优化 =====
# 交换分区使用积极程度（0-100，值越小越少使用swap）
vm.swappiness = 10
# 脏页写回磁盘的比例
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5

# ===== 文件系统优化 =====  
# 系统级文件描述符限制
fs.file-max = 2097152
# 监控文件数量限制
fs.inotify.max_user_watches = 524288

# ===== 进程管理优化 =====
# 最大进程ID（避免PID回绕）
kernel.pid_max = 4194304
# 共享内存段大小
kernel.shmmax = 68719476736
```

**⚡ 配置生效和验证**
```bash
# 加载新配置
sudo sysctl -p

# 或者加载特定文件
sudo sysctl -p /etc/sysctl.d/99-performance.conf

# 验证配置是否生效
sysctl net.core.somaxconn
# 应该输出：net.core.somaxconn = 32768

sysctl vm.swappiness  
# 应该输出：vm.swappiness = 10
```

---

## 3. 📁 文件描述符限制调整


### 3.1 文件描述符是什么

🎯 **生活化理解**：文件描述符就像"办事窗口号码"

```
银行办业务的比喻：
- 你去银行办业务需要先取号
- 号码就是你和银行柜员沟通的"凭证"  
- 银行有限的柜台窗口（文件描述符限制）
- 窗口不够，客户就要排队等待

文件描述符也是类似：
- 程序要访问文件、网络连接都需要"号码"
- 号码不够，程序就会报错："Too many open files"
- 高并发服务器特别需要调大这个限制
```

### 3.2 文件描述符的类型

**📋 Linux中什么会占用文件描述符**

```
常见的文件描述符使用：
1. 普通文件：打开文件读写
2. 网络连接：TCP/UDP socket连接  
3. 管道通信：进程间通信管道
4. 设备文件：访问硬件设备
5. 目录：打开目录进行操作

高并发场景的典型消耗：
- Web服务器：每个HTTP连接占用1个
- 数据库：每个客户端连接占用1个  
- 缓存服务：每个缓存连接占用1个
- 日志文件：每个日志文件占用1个
```

### 3.3 查看文件描述符使用情况

**🔍 系统层面监控**

```bash
# 查看系统整体文件描述符使用情况
cat /proc/sys/fs/file-nr
# 输出格式：已分配数量  未使用数量  最大限制
# 例如：1024    0    2097152

# 查看当前用户的限制
ulimit -n
# 输出当前进程的文件描述符限制

# 查看系统最大限制
cat /proc/sys/fs/file-max
# 系统级别的最大文件描述符数

# 查看特定进程的文件描述符使用
ls /proc/进程ID/fd | wc -l
# 统计某进程当前打开的文件描述符数量

# 实际示例：查看nginx进程
pgrep nginx | head -1 | xargs -I {} ls /proc/{}/fd | wc -l
```

**📊 进程级别详细监控**
```bash
# 查看占用文件描述符最多的进程
lsof | awk '{print $2}' | sort | uniq -c | sort -rn | head -10

# 查看特定进程打开的所有文件描述符
sudo lsof -p 进程ID

# 按进程名查看文件描述符使用
sudo lsof -c nginx
# 显示nginx进程打开的所有文件和网络连接

# 查看网络连接占用的描述符
sudo lsof -i
# 显示所有网络连接
```

### 3.4 分层次调整文件描述符限制

**🏗️ 多层限制的调整策略**

```
Linux文件描述符的三层限制：
1. 系统级别：整个系统的总限制
2. 用户级别：单个用户的限制  
3. 进程级别：单个进程的限制

调整优先级：系统级 > 用户级 > 进程级
```

**🔧 系统级别调整**
```bash
# 1. 调整系统最大文件描述符
sudo vim /etc/sysctl.conf
# 添加：
fs.file-max = 2097152

# 使配置生效
sudo sysctl -p

# 验证修改
cat /proc/sys/fs/file-max
```

**👤 用户级别调整**
```bash
# 2. 调整用户限制
sudo vim /etc/security/limits.conf
# 添加：
* soft nofile 65536
* hard nofile 65536

# 特定服务用户的配置
nginx soft nofile 100000
nginx hard nofile 100000
mysql soft nofile 100000  
mysql hard nofile 100000

# 重新登录生效
exit && ssh user@server
```

**🚀 服务级别调整（systemd）**
```bash
# 3. 针对系统服务调整
sudo mkdir -p /etc/systemd/system/nginx.service.d
sudo vim /etc/systemd/system/nginx.service.d/limits.conf

# 添加内容：
[Service]
LimitNOFILE=100000

# 重新加载配置
sudo systemctl daemon-reload
sudo systemctl restart nginx

# 验证服务的限制
sudo systemctl show nginx | grep LimitNOFILE
```

---

## 4. 🌐 网络参数基础优化


### 4.1 网络参数优化的重要性

🎯 **为什么要优化网络参数**

```
想象高速公路系统：
默认配置 = 乡村小路：窄、慢、堵车
优化配置 = 高速公路：宽、快、通畅

网络参数影响：
- 并发连接数（车道数量）
- 响应速度（通行速度）  
- 吞吐量（运输能力）
- 稳定性（交通管理）
```

### 4.2 TCP连接相关参数

**🔸 核心TCP参数详解**

```bash
# ===== TCP连接队列参数 =====
# 半连接队列大小（SYN队列）
net.ipv4.tcp_max_syn_backlog = 32768
# 全连接队列大小（ACCEPT队列）  
net.core.somaxconn = 32768

# ===== TCP连接复用参数 =====
# 开启TIME_WAIT连接复用（重要）
net.ipv4.tcp_tw_reuse = 1
# 减少TIME_WAIT超时时间
net.ipv4.tcp_fin_timeout = 30

# ===== TCP缓冲区参数 =====
# TCP读缓冲区（接收窗口）
net.ipv4.tcp_rmem = 4096 65536 16777216
# TCP写缓冲区（发送窗口）
net.ipv4.tcp_wmem = 4096 65536 16777216
```

**💡 参数含义详细说明**
```
1. tcp_max_syn_backlog（半连接队列）
   作用：控制正在进行三次握手的连接数量
   场景：高并发时防止SYN flood攻击
   推荐：32768（默认通常只有1024）

2. somaxconn（全连接队列）  
   作用：控制已完成三次握手但未被应用accept的连接
   场景：Web服务器高并发处理
   推荐：32768（默认通常只有128）

3. tcp_tw_reuse（TIME_WAIT复用）
   作用：允许复用TIME_WAIT状态的连接
   场景：解决大量短连接导致的端口耗尽
   推荐：开启（1）

4. tcp_fin_timeout（FIN超时）
   作用：控制连接关闭等待时间
   场景：快速回收连接资源
   推荐：30秒（默认60秒）
```

### 4.3 网络缓冲区优化

**📊 缓冲区大小调整**

```bash
# ===== 核心网络缓冲区 =====
# 默认接收缓冲区
net.core.rmem_default = 262144
# 最大接收缓冲区  
net.core.rmem_max = 16777216
# 默认发送缓冲区
net.core.wmem_default = 262144
# 最大发送缓冲区
net.core.wmem_max = 16777216

# ===== 网络设备队列 =====
# 网卡接收队列大小
net.core.netdev_max_backlog = 32768
# 网络层接收队列
net.core.netdev_budget = 600
```

**🔧 缓冲区参数的实际应用**
```
缓冲区大小的影响：

太小的问题：
- 高速网络无法充分利用带宽
- 大文件传输性能差
- 网络抖动时容易丢包

太大的问题：  
- 占用过多内存
- 增加网络延迟
- 可能导致内存不足

推荐策略：
- 千兆网络：rmem_max = 16MB
- 万兆网络：rmem_max = 64MB  
- 内存充足时可以适当调大
```

### 4.4 实际配置示例和验证

**✅ 完整的网络优化配置**

```bash
# 创建网络优化配置文件
sudo vim /etc/sysctl.d/90-network.conf

# ===== 网络性能优化配置 =====
# TCP连接队列
net.ipv4.tcp_max_syn_backlog = 32768
net.core.somaxconn = 32768

# TCP连接复用和回收
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 3

# 网络缓冲区大小
net.core.rmem_default = 262144
net.core.rmem_max = 16777216
net.core.wmem_default = 262144  
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 65536 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# 网络设备队列
net.core.netdev_max_backlog = 32768
net.core.netdev_budget = 600

# 其他优化
net.ipv4.tcp_congestion_control = bbr
net.ipv4.tcp_slow_start_after_idle = 0
```

**🔍 验证网络参数优化效果**
```bash
# 应用配置
sudo sysctl -p /etc/sysctl.d/90-network.conf

# 验证关键参数
sysctl net.core.somaxconn
sysctl net.ipv4.tcp_tw_reuse  
sysctl net.core.rmem_max

# 查看TCP连接统计
ss -s
# 输出连接数量统计

# 监控网络队列使用情况
cat /proc/net/sockstat
# 显示socket使用统计

# 性能测试（可选）
# 使用iperf3测试网络吞吐量
iperf3 -s  # 服务端
iperf3 -c server_ip -t 30  # 客户端测试30秒
```

---

## 5. 💾 内存管理参数调整


### 5.1 Linux内存管理基础概念

🎯 **内存管理的通俗理解**

```
把内存想象成一个仓库：
物理内存 = 实际仓库空间  
虚拟内存 = 仓库管理系统
交换分区 = 临时存储区（硬盘空间）
页缓存 = 常用货物的快速取用区

内存管理的目标：
- 合理分配有限的内存空间
- 提高内存使用效率
- 减少磁盘I/O操作
- 保证系统稳定运行
```

### 5.2 核心内存参数详解

**🔸 vm.swappiness（交换积极程度）**

```bash
# 查看当前设置
cat /proc/sys/vm/swappiness
# 默认值通常是60

# vm.swappiness参数说明：
# 0   = 尽量不使用swap，直到内存不足
# 1   = 最小化使用swap  
# 10  = 推荐值，轻微使用swap
# 60  = 默认值，平衡使用
# 100 = 积极使用swap
```

**💡 swappiness的实际影响**
```
高swappiness值（如默认60）的问题：
- 系统会较早开始使用swap
- 导致活跃进程被换出到硬盘
- 造成系统响应缓慢

低swappiness值（如推荐10）的优势：
- 更多利用物理内存
- 减少不必要的磁盘I/O
- 提高系统响应速度
- 只在内存真正不足时才使用swap

推荐设置：
vm.swappiness = 10
```

### 5.3 脏页管理参数

**🔸 什么是脏页（Dirty Page）**

```
脏页的通俗解释：
想象一个笔记本：
- 干净页面 = 已经保存到硬盘的数据
- 脏页面 = 修改过但还没保存的数据
- 写回操作 = 将笔记本内容保存到硬盘

脏页管理的重要性：
- 控制内存中未写入磁盘的数据量
- 防止突然断电导致数据丢失
- 平衡内存使用和I/O性能
```

**📊 脏页相关参数**
```bash
# ===== 脏页管理参数 =====
# 脏页占总内存的比例上限（触发强制写回）
vm.dirty_ratio = 15

# 脏页占总内存的比例（开始后台写回）  
vm.dirty_background_ratio = 5

# 脏页的最大存活时间（秒）
vm.dirty_expire_centisecs = 3000

# 写回进程的唤醒间隔（秒）
vm.dirty_writeback_centisecs = 500
```

**🔧 脏页参数的调整策略**
```
参数影响分析：

dirty_ratio设置太高（如默认20）：
- 优点：减少磁盘I/O，提高写入性能
- 缺点：断电风险大，可能丢失更多数据
- 适用：内存充足，有UPS保护的环境

dirty_ratio设置合理（推荐15）：
- 平衡性能和数据安全
- 适合大部分生产环境

dirty_background_ratio设置（推荐5）：
- 及早开始后台写回
- 避免达到强制写回的阈值
- 保持系统响应的平滑性
```

### 5.4 内存优化配置实例

**🚀 生产环境内存优化配置**

```bash
# 创建内存优化配置
sudo vim /etc/sysctl.d/80-memory.conf

# ===== 内存管理优化 =====
# 交换分区使用策略（推荐值）
vm.swappiness = 10

# 脏页管理（适合SSD环境）
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5
vm.dirty_expire_centisecs = 3000
vm.dirty_writeback_centisecs = 500

# 内存过量分配控制
vm.overcommit_memory = 1
vm.overcommit_ratio = 50

# 内存页面回收优化
vm.vfs_cache_pressure = 100
vm.min_free_kbytes = 65536

# 共享内存优化
kernel.shmmax = 68719476736
kernel.shmall = 4294967296
```

**✅ 验证内存优化配置**
```bash
# 应用配置
sudo sysctl -p /etc/sysctl.d/80-memory.conf

# 验证关键参数
sysctl vm.swappiness
sysctl vm.dirty_ratio
sysctl vm.dirty_background_ratio

# 查看内存使用情况
free -h
# 显示内存和swap使用情况

# 查看详细内存信息  
cat /proc/meminfo | head -20

# 监控脏页情况
watch -n 2 'cat /proc/meminfo | grep -i dirty'
# 实时监控脏页数量变化
```

**📊 内存使用监控脚本**
```bash
#!/bin/bash
# 内存监控脚本

echo "=== 内存使用概览 ==="
free -h

echo -e "\n=== 内存参数设置 ==="
echo "swappiness: $(cat /proc/sys/vm/swappiness)"
echo "dirty_ratio: $(cat /proc/sys/vm/dirty_ratio)"
echo "dirty_background_ratio: $(cat /proc/sys/vm/dirty_background_ratio)"

echo -e "\n=== 脏页统计 ==="
grep -i dirty /proc/meminfo

echo -e "\n=== TOP 10 内存使用进程 ==="
ps aux --sort=-%mem | head -11
```

---

## 6. 💿 I/O调度器选择与配置


### 6.1 什么是I/O调度器

🎯 **I/O调度器的通俗理解**

```
想象电梯运行系统：
传统电梯：按先来后到顺序停靠（FIFO）
智能电梯：优化路径，减少总运行时间

I/O调度器就像"硬盘访问的电梯系统"：
- 决定磁盘读写请求的执行顺序
- 减少磁盘寻道时间
- 提高整体I/O性能
- 保证访问的公平性
```

### 6.2 Linux I/O调度器类型

**📋 主要调度器类型及特点**

```
1. noop（无操作调度器）
   特点：简单的FIFO队列，不做任何优化
   适用：SSD固态硬盘、闪存设备
   优势：CPU开销最小，延迟最低
   缺陷：不适合机械硬盘

2. deadline（截止时间调度器）  
   特点：保证读写请求的最大延迟时间
   适用：数据库、实时应用
   优势：延迟可预测，读写公平
   缺陷：吞吐量可能不是最优

3. cfq（完全公平队列调度器）
   特点：为每个进程分配时间片，保证公平性
   适用：桌面系统、多用户环境  
   优势：公平性好，交互体验佳
   缺陷：高并发时性能不佳

4. mq-deadline（多队列截止时间）
   特点：针对多核CPU优化的deadline
   适用：现代多核服务器
   优势：并发性能好，延迟可控
```

### 6.3 查看和修改I/O调度器

**🔍 当前调度器查看**

```bash
# 查看所有磁盘的调度器
for disk in /sys/block/*/queue/scheduler; do
  echo "$disk: $(cat $disk)"
done

# 查看特定磁盘的调度器
cat /sys/block/sda/queue/scheduler
# 输出示例：noop deadline [cfq] 
# 方括号表示当前使用的调度器

# 查看系统中所有磁盘设备
lsblk
# 显示磁盘分区信息

# 查看磁盘类型（是否为SSD）
lsblk -d -o name,rota
# ROTA=1表示机械硬盘，ROTA=0表示SSD
```

**🔧 临时修改调度器**
```bash
# 临时修改特定磁盘的调度器
echo deadline | sudo tee /sys/block/sda/queue/scheduler

# 验证修改结果
cat /sys/block/sda/queue/scheduler
# 应该显示：noop [deadline] cfq

# 针对不同类型磁盘的推荐设置
# SSD固态硬盘：
echo noop | sudo tee /sys/block/sda/queue/scheduler

# 机械硬盘：
echo deadline | sudo tee /sys/block/sdb/queue/scheduler
```

### 6.4 永久配置I/O调度器

**🔒 系统启动时自动配置**

```bash
# 方法1：通过内核启动参数（推荐）
sudo vim /etc/default/grub

# 在GRUB_CMDLINE_LINUX行添加：
GRUB_CMDLINE_LINUX="elevator=deadline"

# 更新GRUB配置
sudo update-grub  # Ubuntu/Debian
# 或
sudo grub2-mkconfig -o /boot/grub2/grub.cfg  # CentOS/RHEL

# 重启系统生效
sudo reboot
```

**🚀 udev规则方式配置**
```bash
# 方法2：基于设备类型自动配置
sudo vim /etc/udev/rules.d/60-schedulers.rules

# SSD使用noop调度器
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="0", ATTR{queue/scheduler}="noop"

# 机械硬盘使用deadline调度器  
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", ATTR{queue/scheduler}="deadline"

# 重新加载udev规则
sudo udevadm control --reload-rules
sudo udevadm trigger --subsystem-match=block
```

### 6.5 I/O调度器性能调优

**⚡ 调度器参数微调**

```bash
# deadline调度器参数调整
# 读请求的最大延迟时间（毫秒）
echo 50 | sudo tee /sys/block/sda/queue/iosched/read_expire

# 写请求的最大延迟时间（毫秒）  
echo 250 | sudo tee /sys/block/sda/queue/iosched/write_expire

# 批处理请求数量
echo 16 | sudo tee /sys/block/sda/queue/iosched/fifo_batch

# cfq调度器参数调整
# 时间片长度（毫秒）
echo 100 | sudo tee /sys/block/sda/queue/iosched/slice_sync

# 异步请求队列深度
echo 64 | sudo tee /sys/block/sda/queue/iosched/slice_async
```

**📊 I/O性能监控和测试**
```bash
# 监控I/O性能
iostat -x 1
# 显示详细的I/O统计信息

# 磁盘性能测试（谨慎使用）
# 测试读性能
sudo hdparm -t /dev/sda

# 测试写性能（小心数据安全）
dd if=/dev/zero of=/tmp/testfile bs=1M count=1024 oflag=direct
# 测试完成后删除测试文件
rm /tmp/testfile

# 使用fio进行综合性能测试
sudo apt install fio  # 安装fio工具
fio --name=test --size=1G --rw=randwrite --bs=4k --numjobs=1 --time_based --runtime=60s
```

---

## 7. 📊 系统性能基线建立


### 7.1 什么是性能基线

🎯 **性能基线的重要性**

```
性能基线就像"体检报告"：
正常体检：记录各项指标的正常值
异常对比：通过对比发现健康问题

系统性能基线的作用：
- 记录系统正常状态下的性能指标
- 为性能优化提供对比参考
- 帮助快速发现性能异常
- 制定容量规划和扩容策略
```

### 7.2 关键性能指标

**📋 需要监控的核心指标**

```
系统性能的五大维度：

1. CPU使用情况
   - CPU使用率（%user, %system, %idle）
   - 负载平均值（1分钟、5分钟、15分钟）
   - 上下文切换次数
   - 中断处理次数

2. 内存使用情况  
   - 物理内存使用率
   - 交换分区使用情况
   - 缓存和缓冲区使用量
   - 脏页数量

3. 磁盘I/O性能
   - 读写IOPS（每秒I/O操作数）
   - 读写带宽（MB/s）  
   - I/O等待时间
   - 磁盘使用率

4. 网络性能
   - 网络吞吐量（收发字节数）
   - 网络包速率（收发包数）
   - 网络错误率
   - TCP连接数

5. 系统整体状态
   - 进程总数
   - 文件描述符使用数
   - 系统运行时间
   - 平均响应时间
```

### 7.3 建立性能基线的方法

**🔧 基线数据收集脚本**

```bash
#!/bin/bash
# 性能基线收集脚本
LOGFILE="/var/log/performance_baseline.log"
TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")

echo "=== 性能基线记录 - $TIMESTAMP ===" >> $LOGFILE

# 1. CPU信息收集
echo "--- CPU性能指标 ---" >> $LOGFILE
# CPU使用率
vmstat 1 5 | tail -1 >> $LOGFILE
# 负载平均值  
uptime >> $LOGFILE
# CPU详细信息
mpstat 1 1 >> $LOGFILE

# 2. 内存信息收集
echo "--- 内存性能指标 ---" >> $LOGFILE  
free -h >> $LOGFILE
cat /proc/meminfo | grep -E "(MemTotal|MemFree|MemAvailable|Buffers|Cached|SwapTotal|SwapFree)" >> $LOGFILE

# 3. 磁盘I/O信息
echo "--- 磁盘I/O指标 ---" >> $LOGFILE
iostat -x 1 1 >> $LOGFILE
df -h >> $LOGFILE

# 4. 网络信息  
echo "--- 网络性能指标 ---" >> $LOGFILE
ss -s >> $LOGFILE
cat /proc/net/dev | grep -v "lo:" >> $LOGFILE

# 5. 系统整体状态
echo "--- 系统整体状态 ---" >> $LOGFILE
ps aux | wc -l >> $LOGFILE
cat /proc/loadavg >> $LOGFILE
cat /proc/sys/fs/file-nr >> $LOGFILE

echo "================================" >> $LOGFILE
echo "" >> $LOGFILE
```

### 7.4 自动化基线监控

**⏰ 定期监控配置**

```bash
# 创建监控脚本目录
sudo mkdir -p /opt/monitoring

# 保存基线收集脚本
sudo vim /opt/monitoring/collect_baseline.sh
# 将上面的脚本内容保存到这个文件

# 添加执行权限
sudo chmod +x /opt/monitoring/collect_baseline.sh

# 配置定时任务
sudo crontab -e
# 添加以下内容：

# 每小时收集一次性能数据
0 * * * * /opt/monitoring/collect_baseline.sh

# 每天生成基线报告  
0 6 * * * /opt/monitoring/generate_daily_report.sh

# 每周清理旧日志（保留30天）
0 2 * * 0 find /var/log -name "performance_*" -mtime +30 -delete
```

**📊 基线分析脚本**
```bash
#!/bin/bash
# 性能基线分析脚本
LOGFILE="/var/log/performance_baseline.log"
REPORT="/tmp/performance_report_$(date +%Y%m%d).txt"

echo "=== 系统性能基线分析报告 ===" > $REPORT
echo "生成时间: $(date)" >> $REPORT
echo "分析周期: 最近24小时" >> $REPORT
echo "" >> $REPORT

# 分析CPU使用趋势
echo "--- CPU使用情况分析 ---" >> $REPORT
grep "vmstat" $LOGFILE | tail -24 | awk '{sum+=$15} END {print "平均CPU空闲率: " sum/NR "%"}' >> $REPORT

# 分析内存使用趋势  
echo "--- 内存使用情况分析 ---" >> $REPORT
grep "MemAvailable" $LOGFILE | tail -24 | awk '{print $2}' | awk '{sum+=$1} END {print "平均可用内存: " sum/NR " kB"}' >> $REPORT

# 分析负载情况
echo "--- 系统负载分析 ---" >> $REPORT  
grep "load average" $LOGFILE | tail -24 | awk -F'load average:' '{print $2}' | awk -F',' '{sum+=$1} END {print "平均1分钟负载: " sum/NR}' >> $REPORT

echo "报告已生成: $REPORT"
```

---

## 8. 🔍 性能监控工具基础配置


### 8.1 系统自带监控工具

🎯 **Linux内置监控工具详解**

```
Linux系统自带的性能监控工具：
就像医生的"听诊器、血压计、体温计"
每个工具都有特定的监控用途

主要工具分类：
1. 实时监控：top、htop、iostat、vmstat
2. 历史数据：sar、pidstat  
3. 网络监控：ss、netstat、iftop
4. 磁盘分析：iotop、df、du
5. 进程追踪：strace、lsof、pstack
```

### 8.2 top和htop配置优化

**📊 top工具的高级使用**

```bash
# top的实用快捷键配置
# 运行top后，按以下键进行配置：

# 1. 按'1' - 显示所有CPU核心使用率
# 2. 按'c' - 显示完整的命令行
# 3. 按'M' - 按内存使用排序  
# 4. 按'P' - 按CPU使用排序
# 5. 按'T' - 按累计CPU时间排序
# 6. 按'W' - 保存当前配置

# 自定义top配置文件
mkdir -p ~/.config
cat > ~/.toprc << 'EOF'
top's Config File (Linux processes with windows)
Id:i, Mode_altscr=0, Mode_irixps=1, Delay_time=3.000, Curwin=0
Def	fieldscur=ƒ&K¤¿º·»½ª©®¬*µ´¶¸·Ã
	winflags=163124, sortindx=18, maxtasks=0
	summclr=1, msgsclr=1, headclr=3, taskclr=1
EOF

# htop的安装和配置
sudo apt install htop  # Ubuntu/Debian
# 或
sudo yum install htop   # CentOS/RHEL

# htop的优势：
# - 彩色界面，更易阅读
# - 支持鼠标操作
# - 显示进程树结构
# - 内置搜索和过滤功能
```

### 8.3 iostat和vmstat配置

**💿 磁盘和内存监控配置**

```bash
# 安装sysstat包（包含iostat、vmstat、sar等工具）
sudo apt install sysstat  # Ubuntu/Debian
# 或
sudo yum install sysstat   # CentOS/RHEL

# 启用sysstat数据收集
sudo systemctl enable sysstat
sudo systemctl start sysstat

# iostat常用参数组合
# 每2秒显示一次扩展I/O统计
iostat -x 2

# 只显示特定设备
iostat -x 2 sda sdb

# 显示CPU和I/O统计
iostat -c -d 2

# vmstat常用参数
# 每秒显示一次系统统计，连续10次
vmstat 1 10

# 显示内存统计（以MB为单位）
vmstat -S m 1

# 显示磁盘统计
vmstat -d
```

**🔧 创建监控别名**
```bash
# 编辑bash配置文件
vim ~/.bashrc

# 添加实用的监控别名
alias cpu='top -p $(pgrep -d, ".*")'
alias mem='free -h && echo && ps aux --sort=-%mem | head -10'  
alias disk='df -h && echo && iostat -x 1 1'
alias net='ss -s && echo && iftop -t -s 10'
alias load='uptime && echo && vmstat 1 5'
alias procs='ps aux --sort=-%cpu | head -10'

# 重新加载配置
source ~/.bashrc
```

### 8.4 网络监控工具配置

**🌐 网络性能监控设置**

```bash
# 安装网络监控工具
sudo apt install iftop nethogs iotop  # Ubuntu/Debian
# 或  
sudo yum install iftop nethogs iotop   # CentOS/RHEL

# iftop - 实时网络流量监控
# 基础使用
sudo iftop

# 监控特定网络接口
sudo iftop -i eth0

# 显示端口信息
sudo iftop -P

# nethogs - 按进程显示网络使用
sudo nethogs

# 只监控特定网络接口
sudo nethogs eth0

# ss命令的高级使用（替代netstat）
# 显示所有TCP连接
ss -t

# 显示监听端口及进程
ss -tlnp

# 显示连接统计
ss -s

# 监控特定端口
ss -tlnp | grep :80
```

### 8.5 综合监控脚本

**🚀 一键监控脚本**

```bash
#!/bin/bash
# 综合系统监控脚本
# 文件名: system_monitor.sh

clear
echo "=========================================="
echo "       系统性能综合监控报告"
echo "=========================================="
echo "监控时间: $(date)"
echo

# 1. 系统基本信息
echo "--- 系统基本信息 ---"
echo "主机名: $(hostname)"
echo "系统版本: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
echo "内核版本: $(uname -r)"
echo "运行时间: $(uptime | cut -d',' -f1 | cut -d' ' -f4-)"
echo

# 2. CPU使用情况
echo "--- CPU使用情况 ---"
echo "CPU核心数: $(nproc)"
echo "负载平均值: $(uptime | awk -F'load average:' '{print $2}')"
echo "CPU使用率:"
vmstat 1 3 | tail -1 | awk '{print "  用户态: "$13"%, 系统态: "$14"%, 空闲: "$15"%"}'
echo

# 3. 内存使用情况  
echo "--- 内存使用情况 ---"
free -h | grep -E "(Mem|Swap)" | while read line; do
    echo "  $line"
done
echo

# 4. 磁盘使用情况
echo "--- 磁盘使用情况 ---"  
df -h | grep -vE '^tmpfs|^udev' | awk 'NR==1 {print "  "$0} NR>1 && $5+0 > 80 {print "  [警告]"$0} NR>1 && $5+0 <= 80 {print "  "$0}'
echo

# 5. 网络连接情况
echo "--- 网络连接统计 ---"
ss -s | grep -E "(TCP|UDP)" | while read line; do
    echo "  $line"  
done
echo

# 6. TOP 5 进程（按CPU使用率）
echo "--- TOP 5 CPU使用进程 ---"
ps aux --sort=-%cpu | head -6 | tail -5 | awk '{printf "  %s\t%s%%\t%s\n", $11, $3, $2}'
echo

# 7. TOP 5 进程（按内存使用率）  
echo "--- TOP 5 内存使用进程 ---"
ps aux --sort=-%mem | head -6 | tail -5 | awk '{printf "  %s\t%s%%\t%s\n", $11, $4, $2}'
echo

# 8. I/O统计
echo "--- 磁盘I/O统计 ---"
iostat -x 1 1 | grep -E "(Device|sd|nvme)" | tail -n +2 | while read line; do
    echo "  $line"
done
echo

echo "=========================================="
echo "监控完成 - $(date)"
echo "=========================================="
```

**⏰ 监控脚本的使用和自动化**
```bash
# 保存监控脚本
sudo vim /opt/monitoring/system_monitor.sh

# 添加执行权限
sudo chmod +x /opt/monitoring/system_monitor.sh

# 创建快捷命令
echo 'alias sysmon="/opt/monitoring/system_monitor.sh"' >> ~/.bashrc
source ~/.bashrc

# 设置定时监控（每小时执行一次，保存到日志）
sudo crontab -e
# 添加：
0 * * * * /opt/monitoring/system_monitor.sh >> /var/log/system_monitor.log

# 日志轮转配置
sudo vim /etc/logrotate.d/system_monitor
# 内容：
/var/log/system_monitor.log {
    daily
    rotate 30
    compress
    missingok
    notifempty
    copytruncate
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 系统资源限制：通过ulimit和limits.conf控制进程资源使用
🔸 内核参数优化：使用sysctl调整系统底层行为和性能
🔸 文件描述符：高并发场景的关键限制，需要分层调整
🔸 网络参数：TCP连接、缓冲区、队列大小的优化配置
🔸 内存管理：swap使用策略、脏页管理、内存回收机制
🔸 I/O调度器：根据存储类型选择合适的调度策略
🔸 性能基线：建立系统正常状态的性能基准参考
🔸 监控工具：掌握系统自带工具的配置和使用方法
```

### 9.2 关键理解要点


**🔹 参数调优的层次化思维**
```
系统性能调优需要分层考虑：
硬件层：CPU、内存、磁盘、网络的物理特性
内核层：内核参数、调度器、资源限制
应用层：程序配置、连接池、缓存策略
监控层：基线建立、异常发现、趋势分析

优化原则：
- 先建立基线，再进行优化
- 一次只调整一个参数
- 调整后验证效果和影响
- 记录优化过程和结果
```

**🔹 不同场景的优化重点**
```
Web服务器场景：
- 重点：文件描述符限制、TCP连接参数
- 关键：net.core.somaxconn、ulimit -n

数据库服务器：
- 重点：内存管理、I/O调度器
- 关键：vm.swappiness、I/O调度器选择

高并发应用：
- 重点：网络缓冲区、连接复用
- 关键：TCP缓冲区大小、TIME_WAIT处理

存储密集型：
- 重点：I/O调度器、脏页管理
- 关键：调度器选择、vm.dirty_ratio
```

**🔹 配置管理的最佳实践**
```
版本控制：
- 配置文件纳入版本管理
- 记录每次修改的原因和效果
- 保留原始配置的备份

标准化部署：
- 创建标准化的配置模板
- 区分开发、测试、生产环境
- 使用配置管理工具自动化部署

监控验证：
- 每次调优后进行性能测试
- 建立告警机制监控关键指标
- 定期回顾和调整优化策略
```

### 9.3 实际应用价值


**🎯 生产环境应用场景**
- **电商平台**：大促期间的高并发处理能力优化
- **内容平台**：大文件传输和用户访问的网络优化
- **数据库服务**：查询性能和并发连接的系统优化
- **容器平台**：容器密度和资源隔离的参数调整

**🔧 运维实践建议**
- **渐进优化**：从基础参数开始，逐步深入优化
- **环境隔离**：在测试环境充分验证后再应用到生产
- **监控驱动**：基于监控数据进行针对性优化
- **文档记录**：完整记录优化过程和参数变更

**📈 技术发展趋势**
- **自动化调优**：基于机器学习的参数自动优化
- **容器化优化**：针对容器环境的特殊优化策略
- **云原生适配**：云环境下的性能参数调整
- **可观测性增强**：更精细的性能监控和分析能力

**核心记忆口诀**：
- 系统调优分层次，内核参数是基础
- 文件描述符要放大，网络缓冲区加宽
- 内存交换要适度，I/O调度选对路
- 监控基线先建立，优化效果好验证