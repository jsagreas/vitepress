---
title: 5、脚本模板与代码复用
---
## 📚 目录

1. [标准脚本模板结构](#1-标准脚本模板结构)
2. [函数库组织与复用](#2-函数库组织与复用)
3. [配置模板参数化](#3-配置模板参数化)
4. [代码片段管理](#4-代码片段管理)
5. [脚本版本控制策略](#5-脚本版本控制策略)
6. [模块化设计原则](#6-模块化设计原则)
7. [通用工具函数集](#7-通用工具函数集)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📋 标准脚本模板结构


### 1.1 什么是脚本模板


**🔸 核心定义**
```
脚本模板：预定义的脚本框架和结构
目的：统一脚本格式，提高开发效率，减少错误
本质：就像写文章的格式模板，有固定的开头、正文、结尾
```

**💡 为什么需要脚本模板**
```
问题场景：
- 每次写脚本都要重新考虑结构
- 不同人写的脚本风格差异很大
- 缺少错误处理和日志记录
- 维护困难，不知道脚本的作用

模板解决：
- 统一的代码结构和风格
- 内置错误处理机制
- 标准化的日志输出
- 完善的注释和文档
```

### 1.2 基础脚本模板结构


**🏗️ 标准模板框架**
```bash
#!/bin/bash
# =============================================================================
# 脚本名称：backup_system.sh
# 作者：运维团队
# 创建日期：2024-01-15
# 版本：v1.0
# 功能描述：系统备份脚本
# 使用方法：./backup_system.sh [选项]
# =============================================================================

# 脚本配置区
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="/var/log/backup.log"
CONFIG_FILE="${SCRIPT_DIR}/backup.conf"

# 错误处理函数
error_exit() {
    echo "错误：$1" >&2
    exit 1
}

# 日志记录函数
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# 主要功能函数
main() {
    log_message "脚本开始执行"
    # 具体业务逻辑
    log_message "脚本执行完成"
}

# 脚本入口
main "$@"
```

### 1.3 增强版脚本模板


**🚀 功能完整的模板**
```bash
#!/bin/bash
# 设置脚本选项：遇到错误立即退出，使用未定义变量时报错
set -euo pipefail

# =============================================================================
# 脚本信息
readonly SCRIPT_NAME="${0##*/}"
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_AUTHOR="运维团队"

# 颜色定义（用于美化输出）
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # 无颜色

# 全局变量
LOG_LEVEL="INFO"
DRY_RUN=false
VERBOSE=false

# 使用说明
usage() {
    cat << EOF
使用方法: $SCRIPT_NAME [选项]

选项:
    -h, --help      显示帮助信息
    -v, --verbose   详细输出
    -d, --dry-run   试运行模式
    -l, --log-level 日志级别 (DEBUG|INFO|WARN|ERROR)

示例:
    $SCRIPT_NAME --verbose
    $SCRIPT_NAME --dry-run --log-level DEBUG
EOF
}

# 参数解析
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            *)
                error_exit "未知参数: $1"
                ;;
        esac
    done
}

# 检查运行环境
check_requirements() {
    # 检查是否以root权限运行
    if [[ $EUID -eq 0 ]]; then
        log_warn "脚本以root权限运行，请确认是否必要"
    fi
    
    # 检查必需的命令
    local required_commands=("rsync" "tar" "gzip")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            error_exit "需要安装命令: $cmd"
        fi
    done
}

main() {
    parse_arguments "$@"
    check_requirements
    
    log_info "脚本 $SCRIPT_NAME v$SCRIPT_VERSION 开始执行"
    
    # 主要业务逻辑在这里
    if [[ "$DRY_RUN" == true ]]; then
        log_info "试运行模式，不执行实际操作"
    fi
    
    log_info "脚本执行完成"
}

# 脚本入口点
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

**🔑 模板关键特性说明**
- `set -euo pipefail`：严格模式，遇到错误立即退出
- `readonly`：只读变量，防止意外修改
- **颜色输出**：让终端输出更清晰
- **参数解析**：标准化的命令行参数处理
- **环境检查**：确保运行环境满足要求

---

## 2. 🔧 函数库组织与复用


### 2.1 什么是函数库


**📖 函数库概念**
```
函数库：把常用的功能封装成函数，放在单独的文件中
作用：多个脚本可以重复使用这些函数
好处：减少重复代码，统一功能实现，便于维护
```

### 2.2 创建通用函数库


**📁 函数库文件结构**
```
/opt/scripts/
├── lib/                    # 函数库目录
│   ├── common.sh          # 通用工具函数
│   ├── logging.sh         # 日志处理函数
│   ├── config.sh          # 配置管理函数
│   └── network.sh         # 网络相关函数
├── templates/             # 脚本模板
└── examples/              # 使用示例
```

**🛠️ 通用工具函数库 (lib/common.sh)**
```bash
#!/bin/bash
# 通用工具函数库

# 检查命令是否存在
command_exists() {
    command -v "$1" &> /dev/null
}

# 安全删除文件（移到回收站）
safe_remove() {
    local file="$1"
    local trash_dir="/tmp/.trash/$(date +%Y%m%d)"
    
    mkdir -p "$trash_dir"
    mv "$file" "$trash_dir/" 2>/dev/null || {
        echo "警告: 无法移动文件 $file 到回收站" >&2
        return 1
    }
    echo "文件已移动到: $trash_dir/"
}

# 获取文件大小（人类可读格式）
get_file_size() {
    local file="$1"
    if [[ -f "$file" ]]; then
        ls -lh "$file" | awk '{print $5}'
    else
        echo "文件不存在"
        return 1
    fi
}

# 检查磁盘空间
check_disk_space() {
    local path="${1:-.}"
    local threshold="${2:-90}"
    
    local usage=$(df "$path" | tail -1 | awk '{print $5}' | sed 's/%//')
    
    if [[ $usage -gt $threshold ]]; then
        echo "警告: 磁盘使用率 ${usage}% 超过阈值 ${threshold}%"
        return 1
    else
        echo "磁盘使用率: ${usage}%"
        return 0
    fi
}
```

### 2.3 日志处理函数库


**📝 日志函数库 (lib/logging.sh)**
```bash
#!/bin/bash
# 日志处理函数库

# 默认日志配置
LOG_FILE="${LOG_FILE:-/var/log/script.log}"
LOG_LEVEL="${LOG_LEVEL:-INFO}"

# 日志级别定义
declare -A LOG_LEVELS=(
    ["DEBUG"]=0
    ["INFO"]=1
    ["WARN"]=2
    ["ERROR"]=3
)

# 写入日志
write_log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 检查日志级别
    if [[ ${LOG_LEVELS[$level]} -ge ${LOG_LEVELS[$LOG_LEVEL]} ]]; then
        echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
        
        # 如果是ERROR级别，也输出到标准错误
        if [[ "$level" == "ERROR" ]]; then
            echo "错误: $message" >&2
        fi
    fi
}

# 便捷日志函数
log_debug() { write_log "DEBUG" "$1"; }
log_info() { write_log "INFO" "$1"; }
log_warn() { write_log "WARN" "$1"; }
log_error() { write_log "ERROR" "$1"; }

# 错误退出函数
error_exit() {
    log_error "$1"
    exit "${2:-1}"
}
```

### 2.4 在脚本中使用函数库


**🔄 函数库使用示例**
```bash
#!/bin/bash
# 业务脚本示例

# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 加载函数库
source "$SCRIPT_DIR/lib/common.sh"
source "$SCRIPT_DIR/lib/logging.sh"

# 设置日志文件
LOG_FILE="/var/log/my_script.log"

main() {
    log_info "脚本开始执行"
    
    # 检查磁盘空间
    if ! check_disk_space "/var" 80; then
        error_exit "磁盘空间不足，脚本终止"
    fi
    
    # 检查必需命令
    if ! command_exists "rsync"; then
        error_exit "缺少rsync命令"
    fi
    
    log_info "环境检查通过，开始执行任务"
    # 具体业务逻辑...
}

main "$@"
```

---

## 3. ⚙️ 配置模板参数化


### 3.1 为什么需要配置模板


**🎯 配置模板的价值**
```
问题：
- 不同环境需要不同配置
- 手动修改配置容易出错
- 配置分散，难以统一管理

解决方案：
- 配置模板：定义配置的结构和变量
- 参数文件：存储具体的参数值
- 生成脚本：根据参数生成最终配置
```

### 3.2 配置模板设计


**📋 Nginx配置模板示例**
```bash
# nginx.conf.template
server {
    listen {{PORT}};
    server_name {{DOMAIN}};
    
    location / {
        proxy_pass http://{{BACKEND_HOST}}:{{BACKEND_PORT}};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    access_log {{LOG_PATH}}/access.log;
    error_log {{LOG_PATH}}/error.log;
    
    # SSL配置（可选）
    {{#SSL_ENABLED}}
    ssl_certificate {{SSL_CERT_PATH}};
    ssl_certificate_key {{SSL_KEY_PATH}};
    {{/SSL_ENABLED}}
}
```

**🗂️ 参数配置文件**
```bash
# config/production.env
PORT=80
DOMAIN=www.example.com
BACKEND_HOST=192.168.1.100
BACKEND_PORT=8080
LOG_PATH=/var/log/nginx
SSL_ENABLED=true
SSL_CERT_PATH=/etc/ssl/certs/example.crt
SSL_KEY_PATH=/etc/ssl/private/example.key
```

### 3.3 配置生成脚本


**🔄 模板处理脚本**
```bash
#!/bin/bash
# generate_config.sh - 配置文件生成器

generate_config() {
    local template_file="$1"
    local config_file="$2"
    local env_file="$3"
    
    # 检查文件是否存在
    [[ -f "$template_file" ]] || error_exit "模板文件不存在: $template_file"
    [[ -f "$env_file" ]] || error_exit "环境文件不存在: $env_file"
    
    # 加载环境变量
    source "$env_file"
    
    # 简单的变量替换
    local content=$(cat "$template_file")
    
    # 替换所有 {{VARIABLE}} 格式的变量
    while IFS='=' read -r key value; do
        if [[ -n "$key" && ! "$key" =~ ^# ]]; then
            content=${content//\{\{$key\}\}/$value}
        fi
    done < "$env_file"
    
    # 写入最终配置文件
    echo "$content" > "$config_file"
    
    echo "配置文件已生成: $config_file"
}

# 使用示例
generate_config "nginx.conf.template" "/etc/nginx/conf.d/app.conf" "config/production.env"
```

### 3.4 高级配置模板功能


**🎨 条件配置和循环**
```bash
# 支持条件的配置模板处理
process_template_advanced() {
    local template="$1"
    local output="$2"
    
    # 处理条件块 {{#VARIABLE}} ... {{/VARIABLE}}
    while [[ "$template" =~ \{\{#([A-Z_]+)\}\}(.*?)\{\{/\1\}\} ]]; do
        local var_name="${BASH_REMATCH[1]}"
        local block_content="${BASH_REMATCH[2]}"
        
        # 检查变量值
        local var_value="${!var_name:-}"
        
        if [[ "$var_value" == "true" || -n "$var_value" ]]; then
            # 保留块内容
            template=${template//${BASH_REMATCH[0]}/$block_content}
        else
            # 删除整个块
            template=${template//${BASH_REMATCH[0]}/}
        fi
    done
    
    echo "$template" > "$output"
}
```

---

## 4. 📄 代码片段管理


### 4.1 什么是代码片段


**🔸 代码片段概念**
```
代码片段：常用的小段代码，可以快速插入到脚本中
类型：
- 错误处理代码
- 参数解析逻辑
- 日志输出格式
- 文件操作模式
```

### 4.2 代码片段分类管理


**📂 片段库组织结构**
```
snippets/
├── error-handling/         # 错误处理
│   ├── basic-exit.sh
│   └── trap-cleanup.sh
├── argument-parsing/       # 参数解析
│   ├── getopt-basic.sh
│   └── manual-parsing.sh
├── file-operations/        # 文件操作
│   ├── safe-backup.sh
│   └── atomic-write.sh
└── logging/               # 日志记录
    ├── syslog-integration.sh
    └── rotating-logs.sh
```

### 4.3 常用代码片段示例


**⚠️ 错误处理片段**
```bash
# snippets/error-handling/trap-cleanup.sh
# 清理函数：脚本退出时自动清理临时文件
cleanup() {
    local exit_code=$?
    
    # 清理临时文件
    [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]] && rm -rf "$TEMP_DIR"
    
    # 解锁文件
    [[ -n "$LOCK_FILE" && -f "$LOCK_FILE" ]] && rm -f "$LOCK_FILE"
    
    # 记录退出状态
    if [[ $exit_code -ne 0 ]]; then
        log_error "脚本异常退出，退出码: $exit_code"
    fi
    
    exit $exit_code
}

# 设置陷阱：无论脚本如何退出都会执行清理
trap cleanup EXIT INT TERM
```

**🔒 文件锁片段**
```bash
# snippets/file-operations/file-lock.sh
# 文件锁：防止脚本重复运行
acquire_lock() {
    local lock_file="$1"
    local timeout="${2:-10}"
    
    local count=0
    while [[ $count -lt $timeout ]]; do
        if (set -C; echo $$ > "$lock_file") 2>/dev/null; then
            return 0  # 获取锁成功
        fi
        
        # 检查锁文件中的进程是否还存在
        if [[ -f "$lock_file" ]]; then
            local old_pid=$(cat "$lock_file" 2>/dev/null)
            if ! kill -0 "$old_pid" 2>/dev/null; then
                # 进程不存在，删除旧锁文件
                rm -f "$lock_file"
                continue
            fi
        fi
        
        sleep 1
        ((count++))
    done
    
    return 1  # 获取锁失败
}

# 使用示例
LOCK_FILE="/tmp/my_script.lock"
acquire_lock "$LOCK_FILE" 30 || error_exit "无法获取文件锁，可能有其他实例正在运行"
```

### 4.4 片段管理工具


**🛠️ 简单的片段管理脚本**
```bash
#!/bin/bash
# snippet_manager.sh - 代码片段管理器

SNIPPET_DIR="$HOME/.local/share/snippets"

# 列出所有片段
list_snippets() {
    echo "可用的代码片段："
    find "$SNIPPET_DIR" -name "*.sh" -type f | while read -r file; do
        local name=$(basename "$file" .sh)
        local category=$(basename "$(dirname "$file")")
        printf "  %-20s %s\n" "$category/$name" "$(head -2 "$file" | tail -1 | sed 's/^# //')"
    done
}

# 显示片段内容
show_snippet() {
    local snippet_path="$SNIPPET_DIR/$1.sh"
    if [[ -f "$snippet_path" ]]; then
        cat "$snippet_path"
    else
        echo "片段不存在: $1" >&2
        return 1
    fi
}

# 插入片段到文件
insert_snippet() {
    local snippet_name="$1"
    local target_file="$2"
    local line_number="${3:-$(wc -l < "$target_file")}"
    
    show_snippet "$snippet_name" | sed "${line_number}r /dev/stdin" "$target_file" > "${target_file}.tmp"
    mv "${target_file}.tmp" "$target_file"
}

case "${1:-list}" in
    list) list_snippets ;;
    show) show_snippet "$2" ;;
    insert) insert_snippet "$2" "$3" "$4" ;;
    *) echo "用法: $0 {list|show|insert} [参数...]" >&2; exit 1 ;;
esac
```

---

## 5. 📚 脚本版本控制策略


### 5.1 为什么脚本需要版本控制


**🎯 版本控制的重要性**
```
问题场景：
- 脚本修改后出现问题，不知道哪里改错了
- 多人协作时代码冲突
- 无法追踪脚本的变更历史
- 生产环境和开发环境脚本版本不一致

版本控制解决：
- 记录每次修改的内容和原因
- 支持多人协作开发
- 可以随时回滚到之前的版本
- 分支管理不同环境的配置
```

### 5.2 Git在脚本管理中的应用


**📁 脚本项目结构**
```
automation-scripts/
├── .git/                  # Git仓库
├── .gitignore            # 忽略文件列表
├── README.md             # 项目说明
├── scripts/              # 脚本目录
│   ├── backup/
│   ├── monitoring/
│   └── deployment/
├── lib/                  # 函数库
├── templates/            # 模板文件
├── config/               # 配置文件
│   ├── dev.env
│   ├── staging.env
│   └── prod.env
└── docs/                 # 文档
```

**⚙️ .gitignore 配置示例**
```bash
# 日志文件
*.log
logs/

# 临时文件
*.tmp
.temp/

# 敏感配置
*secret*
*password*
*.key
*.pem

# 备份文件
*.bak
*~

# 运行时文件
*.pid
*.lock
```

### 5.3 脚本内置版本信息


**🏷️ 脚本版本标识**
```bash
#!/bin/bash
# =============================================================================
# 脚本版本信息
readonly SCRIPT_VERSION="1.2.0"
readonly SCRIPT_BUILD="$(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
readonly SCRIPT_DATE="$(git log -1 --format='%ci' 2>/dev/null || date)"

# 显示版本信息
show_version() {
    cat << EOF
$SCRIPT_NAME version $SCRIPT_VERSION
Build: $SCRIPT_BUILD
Date: $SCRIPT_DATE
EOF
}

# 在帮助信息中包含版本
usage() {
    show_version
    echo
    cat << EOF
使用方法: $SCRIPT_NAME [选项]
...
EOF
}
```

### 5.4 版本控制最佳实践


**📝 提交信息规范**
```bash
# 好的提交信息格式
git commit -m "feat: 添加自动备份功能"
git commit -m "fix: 修复磁盘空间检查bug"
git commit -m "docs: 更新安装说明"

# 提交类型说明：
# feat: 新功能
# fix: bug修复  
# docs: 文档更新
# style: 代码格式调整
# refactor: 重构代码
# test: 测试相关
# chore: 构建/工具相关
```

**🌿 分支管理策略**
```bash
# 主要分支
main        # 生产环境版本
develop     # 开发分支
staging     # 测试环境分支

# 功能分支
feature/backup-enhancement     # 备份功能增强
feature/monitoring-alerts      # 监控告警
hotfix/critical-bug-fix       # 紧急bug修复

# 分支操作示例
git checkout -b feature/new-backup-method
git checkout develop
git merge feature/new-backup-method
git push origin develop
```

---

## 6. 🏗️ 模块化设计原则


### 6.1 什么是模块化设计


**🧩 模块化核心概念**
```
模块化：把复杂的脚本拆分成多个独立的、功能单一的模块
好处：
- 代码更容易理解和维护
- 模块可以独立测试
- 功能可以在不同脚本间复用
- 团队可以分工开发不同模块
```

### 6.2 模块设计原则


**📏 SOLID原则在脚本中的应用**

| 原则 | **说明** | **脚本中的体现** |
|------|---------|----------------|
| **单一职责** | 每个模块只做一件事 | 备份模块只负责备份，不处理日志 |
| **开闭原则** | 对扩展开放，对修改封闭 | 通过配置文件扩展功能，不修改核心代码 |
| **依赖倒置** | 依赖抽象而非具体实现 | 通过接口函数调用，不直接调用具体命令 |

### 6.3 模块化脚本示例


**🎯 备份系统模块化设计**
```
backup-system/
├── main.sh              # 主控脚本
├── modules/             # 功能模块
│   ├── database.sh      # 数据库备份
│   ├── files.sh         # 文件备份
│   ├── compress.sh      # 压缩处理
│   └── upload.sh        # 上传模块
├── lib/                 # 公共库
│   └── common.sh
└── config/              # 配置文件
    └── backup.conf
```

**🔧 主控脚本 (main.sh)**
```bash
#!/bin/bash
# 备份系统主控脚本

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 加载公共库
source "$SCRIPT_DIR/lib/common.sh"

# 加载所有模块
for module in "$SCRIPT_DIR/modules"/*.sh; do
    source "$module"
done

main() {
    log_info "开始执行备份任务"
    
    # 按顺序执行各个模块
    database_backup || error_exit "数据库备份失败"
    files_backup || error_exit "文件备份失败"
    compress_backup || error_exit "压缩处理失败"
    upload_backup || error_exit "上传备份失败"
    
    log_info "备份任务完成"
}

main "$@"
```

**💾 数据库备份模块 (modules/database.sh)**
```bash
#!/bin/bash
# 数据库备份模块

database_backup() {
    local backup_dir="/backup/db/$(date +%Y%m%d)"
    local db_list="${DB_LIST:-mysql postgres}"
    
    mkdir -p "$backup_dir"
    
    for db in $db_list; do
        case "$db" in
            mysql)
                backup_mysql "$backup_dir"
                ;;
            postgres)
                backup_postgres "$backup_dir"
                ;;
            *)
                log_warn "不支持的数据库类型: $db"
                ;;
        esac
    done
}

backup_mysql() {
    local backup_dir="$1"
    local dump_file="$backup_dir/mysql_$(date +%H%M%S).sql"
    
    log_info "开始MySQL备份"
    
    if mysqldump --all-databases > "$dump_file"; then
        log_info "MySQL备份完成: $dump_file"
        return 0
    else
        log_error "MySQL备份失败"
        return 1
    fi
}
```

### 6.4 模块间通信机制


**📡 模块通信方式**
```bash
# 方式1: 全局变量
BACKUP_STATUS=""
DATABASE_BACKUP_FILE=""
FILES_BACKUP_FILE=""

# 方式2: 返回值传递
get_backup_status() {
    echo "SUCCESS"  # 或 "FAILED"
}

# 方式3: 临时文件通信
TEMP_STATUS_FILE="/tmp/backup_status.tmp"

set_module_status() {
    local module="$1"
    local status="$2"
    echo "$module:$status" >> "$TEMP_STATUS_FILE"
}

get_module_status() {
    local module="$1"
    grep "^$module:" "$TEMP_STATUS_FILE" | cut -d: -f2
}
```

---

## 7. 🔨 通用工具函数集


### 7.1 文件操作工具函数


**📁 文件处理函数集合**
```bash
# 创建带时间戳的备份
backup_file() {
    local source="$1"
    local backup_dir="${2:-$(dirname "$source")}"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="$(basename "$source").backup_$timestamp"
    
    cp "$source" "$backup_dir/$backup_name"
    echo "$backup_dir/$backup_name"
}

# 安全地替换文件内容
replace_file_content() {
    local file="$1"
    local old_content="$2"
    local new_content="$3"
    
    # 先备份
    local backup_file=$(backup_file "$file")
    
    # 替换内容
    if sed -i "s/$old_content/$new_content/g" "$file"; then
        log_info "文件内容替换成功: $file"
        return 0
    else
        # 恢复备份
        cp "$backup_file" "$file"
        log_error "文件内容替换失败，已恢复原文件"
        return 1
    fi
}

# 获取文件的MD5值
get_file_md5() {
    local file="$1"
    if [[ -f "$file" ]]; then
        md5sum "$file" | awk '{print $1}'
    else
        echo "文件不存在" >&2
        return 1
    fi
}
```

### 7.2 系统信息工具函数


**💻 系统监控函数**
```bash
# 获取系统负载
get_system_load() {
    local load_1min=$(uptime | awk -F'load average:' '{print $2}' | cut -d',' -f1 | tr -d ' ')
    echo "$load_1min"
}

# 检查进程是否运行
is_process_running() {
    local process_name="$1"
    pgrep -x "$process_name" >/dev/null 2>&1
}

# 获取内存使用情况
get_memory_usage() {
    local mem_info=$(free -m | grep '^Mem:')
    local total=$(echo $mem_info | awk '{print $2}')
    local used=$(echo $mem_info | awk '{print $3}')
    local usage_percent=$((used * 100 / total))
    
    echo "$usage_percent"
}

# 检查端口是否被占用
is_port_open() {
    local port="$1"
    local host="${2:-localhost}"
    
    if nc -z "$host" "$port" 2>/dev/null; then
        return 0  # 端口开放
    else
        return 1  # 端口关闭
    fi
}
```

### 7.3 网络工具函数


**🌐 网络操作函数**
```bash
# 测试网络连通性
test_connectivity() {
    local host="$1"
    local timeout="${2:-5}"
    
    if ping -c 1 -W "$timeout" "$host" >/dev/null 2>&1; then
        echo "网络连通"
        return 0
    else
        echo "网络不通"
        return 1
    fi
}

# 下载文件（带重试）
download_file() {
    local url="$1"
    local output_file="$2"
    local max_retry="${3:-3}"
    local retry=0
    
    while [[ $retry -lt $max_retry ]]; do
        if curl -sS -o "$output_file" "$url"; then
            log_info "文件下载成功: $output_file"
            return 0
        fi
        
        ((retry++))
        log_warn "下载失败，正在重试 ($retry/$max_retry)"
        sleep 2
    done
    
    log_error "文件下载失败: $url"
    return 1
}

# 发送HTTP请求
send_http_request() {
    local method="$1"
    local url="$2"
    local data="$3"
    
    case "$method" in
        GET)
            curl -sS "$url"
            ;;
        POST)
            curl -sS -X POST -d "$data" -H "Content-Type: application/json" "$url"
            ;;
        *)
            echo "不支持的HTTP方法: $method" >&2
            return 1
            ;;
    esac
}
```

### 7.4 配置管理工具函数


**⚙️ 配置文件处理**
```bash
# 读取配置值
get_config_value() {
    local config_file="$1"
    local key="$2"
    local default_value="${3:-}"
    
    if [[ -f "$config_file" ]]; then
        # 从配置文件中读取值
        local value=$(grep "^$key=" "$config_file" | cut -d'=' -f2- | tr -d '"'"'"')
        echo "${value:-$default_value}"
    else
        echo "$default_value"
    fi
}

# 设置配置值
set_config_value() {
    local config_file="$1"
    local key="$2"
    local value="$3"
    
    # 创建配置文件（如果不存在）
    touch "$config_file"
    
    # 检查key是否已存在
    if grep -q "^$key=" "$config_file"; then
        # 更新现有值
        sed -i "s|^$key=.*|$key=$value|" "$config_file"
    else
        # 添加新值
        echo "$key=$value" >> "$config_file"
    fi
}

# 验证配置文件
validate_config() {
    local config_file="$1"
    local required_keys=("${@:2}")  # 必需的配置项
    
    local missing_keys=()
    
    for key in "${required_keys[@]}"; do
        if ! grep -q "^$key=" "$config_file"; then
            missing_keys+=("$key")
        fi
    done
    
    if [[ ${#missing_keys[@]} -gt 0 ]]; then
        log_error "配置文件缺少必需项: ${missing_keys[*]}"
        return 1
    else
        log_info "配置文件验证通过"
        return 0
    fi
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 脚本模板：统一的脚本结构框架，提高开发效率
🔸 函数库复用：将常用功能封装成函数，避免重复编写
🔸 配置参数化：通过模板和参数分离，支持多环境部署
🔸 代码片段管理：收集常用代码段，快速构建脚本
🔸 版本控制：使用Git管理脚本变更，支持协作开发
🔸 模块化设计：将复杂脚本拆分成独立模块，便于维护
🔸 工具函数集：构建通用函数库，提升脚本功能
```

### 8.2 关键理解要点


**🔹 模板化的价值**
```
统一性：所有脚本都有相同的基础结构
质量：内置错误处理、日志记录等最佳实践
效率：新脚本开发时间大幅缩短
维护：结构统一便于团队协作维护
```

**🔹 函数复用的好处**
```
DRY原则：Don't Repeat Yourself，避免重复代码
一致性：同样功能的实现保持一致
测试：函数可以独立测试，提高质量
维护：修改函数一处，所有调用处都生效
```

**🔹 配置分离的意义**
```
灵活性：同一套脚本适配不同环境
安全性：敏感信息单独管理
维护性：配置变更不需要修改代码
可扩展：新环境只需增加配置文件
```

### 8.3 实际应用价值


**🚀 企业级脚本开发流程**
```
1. 需求分析 → 确定脚本功能和接口
2. 模板选择 → 选择合适的脚本模板
3. 模块设计 → 拆分功能模块
4. 函数复用 → 使用现有函数库
5. 配置分离 → 设计配置文件结构
6. 代码实现 → 使用代码片段快速开发
7. 版本管理 → 提交到Git仓库
8. 测试部署 → 多环境验证
```

**🛠️ 运维自动化最佳实践**
```
代码规范：
- 使用统一的脚本模板
- 遵循命名约定
- 添加完整注释

架构设计：
- 核心功能模块化
- 配置与代码分离
- 错误处理标准化

团队协作：
- Git分支管理策略
- 代码审查流程
- 文档同步更新
```

### 8.4 学习建议


**📚 学习路径**
```
基础阶段：
1. 掌握脚本模板的基本结构
2. 学会使用函数库
3. 练习配置文件的设计

提高阶段：
4. 理解模块化设计原则
5. 建立自己的代码片段库
6. 掌握Git版本控制

高级阶段：
7. 设计企业级脚本架构
8. 建立完整的工具函数集
9. 制定团队开发规范
```

**💡 实践建议**
- **从小做起**：先用模板重写现有的简单脚本
- **积累经验**：收集工作中常用的代码片段
- **持续优化**：定期重构和改进函数库
- **分享交流**：与团队成员分享最佳实践

**核心记忆**：
- 脚本开发要规范化，模板函数是基础
- 配置代码要分离，版本控制不能少
- 模块设计讲原则，工具函数提效率
- 团队协作靠标准，持续改进是关键