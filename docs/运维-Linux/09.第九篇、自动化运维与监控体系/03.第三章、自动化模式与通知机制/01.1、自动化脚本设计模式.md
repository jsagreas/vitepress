---
title: 1ã€è‡ªåŠ¨åŒ–è„šæœ¬è®¾è®¡æ¨¡å¼
---
## ğŸ“š ç›®å½•

1. [å¹‚ç­‰æ€§è„šæœ¬è®¾è®¡åŸåˆ™](#1-å¹‚ç­‰æ€§è„šæœ¬è®¾è®¡åŸåˆ™)
2. [é”æ–‡ä»¶æœºåˆ¶è¯¦è§£](#2-é”æ–‡ä»¶æœºåˆ¶è¯¦è§£)
3. [è„šæœ¬é€€å‡ºçŠ¶æ€ç è§„èŒƒ](#3-è„šæœ¬é€€å‡ºçŠ¶æ€ç è§„èŒƒ)
4. [é”™è¯¯å¤„ç†ä¸é‡è¯•æœºåˆ¶](#4-é”™è¯¯å¤„ç†ä¸é‡è¯•æœºåˆ¶)
5. [è¶…æ—¶æ§åˆ¶ä¸èµ„æºæ¸…ç†](#5-è¶…æ—¶æ§åˆ¶ä¸èµ„æºæ¸…ç†)
6. [æ—¥å¿—è®°å½•æ ‡å‡†åŒ–](#6-æ—¥å¿—è®°å½•æ ‡å‡†åŒ–)
7. [é…ç½®æ–‡ä»¶åˆ†ç¦»æ¨¡å¼](#7-é…ç½®æ–‡ä»¶åˆ†ç¦»æ¨¡å¼)
8. [ç¯å¢ƒå˜é‡ç®¡ç†ç­–ç•¥](#8-ç¯å¢ƒå˜é‡ç®¡ç†ç­–ç•¥)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ”„ å¹‚ç­‰æ€§è„šæœ¬è®¾è®¡åŸåˆ™


### 1.1 ä»€ä¹ˆæ˜¯å¹‚ç­‰æ€§

ğŸ¯ **ç®€å•ç†è§£**ï¼šå¹‚ç­‰æ€§å°±åƒç”µæ¢¯æŒ‰é’®ï¼Œæ— è®ºæŒ‰å¤šå°‘æ¬¡ç»“æœéƒ½ä¸€æ ·

```
ç”Ÿæ´»ä¸­çš„å¹‚ç­‰æ€§ï¼š
å¼€å…³ç¯ â†’ å¼€ç€å°±æ˜¯å¼€ç€ï¼Œå…³ç€å°±æ˜¯å…³ç€
ç”µæ¢¯æŒ‰é’® â†’ æŒ‰ä¸€æ¬¡å’ŒæŒ‰åæ¬¡æ•ˆæœç›¸åŒ
ATMå–æ¬¾ â†’ åŒä¸€ç¬”äº¤æ˜“ä¸ä¼šé‡å¤æ‰§è¡Œ

è„šæœ¬å¹‚ç­‰æ€§ï¼š
åˆ›å»ºç›®å½• â†’ ç›®å½•å·²å­˜åœ¨æ—¶ä¸æŠ¥é”™
å®‰è£…è½¯ä»¶ â†’ å·²å®‰è£…æ—¶è·³è¿‡è€Œéé‡å¤å®‰è£…
é…ç½®è®¾ç½® â†’ é…ç½®å·²æ­£ç¡®æ—¶ä¸é‡å¤æ‰§è¡Œ
```

**ğŸ”¸ å¹‚ç­‰æ€§çš„æ ¸å¿ƒä»·å€¼**
```
è¿ç»´å®‰å…¨æ€§ï¼š
- é¿å…é‡å¤æ‰§è¡Œé€ æˆçš„å‰¯ä½œç”¨
- æ”¯æŒè„šæœ¬å¤šæ¬¡è¿è¡Œè€Œä¸ç ´åç³»ç»Ÿ
- é™ä½äººä¸ºæ“ä½œé”™è¯¯çš„é£é™©

è‡ªåŠ¨åŒ–å¯é æ€§ï¼š
- æ”¯æŒå®šæ—¶ä»»åŠ¡çš„é‡å¤æ‰§è¡Œ
- æ•…éšœæ¢å¤æ—¶å¯ä»¥å®‰å…¨é‡è·‘
- ç®€åŒ–è¿ç»´æµç¨‹å’Œé”™è¯¯å¤„ç†
```

### 1.2 å¹‚ç­‰æ€§è®¾è®¡æ¨¡å¼


**ğŸ“‹ æ£€æŸ¥-æ‰§è¡Œ-éªŒè¯æ¨¡å¼**
```bash
# æ ‡å‡†å¹‚ç­‰æ€§æ¨¡æ¿
check_and_execute() {
    local target_state=$1
    local action_description=$2
    
    # 1. æ£€æŸ¥å½“å‰çŠ¶æ€
    if check_current_state "$target_state"; then
        log_info "$action_description å·²ç»å®Œæˆï¼Œè·³è¿‡æ‰§è¡Œ"
        return 0
    fi
    
    # 2. æ‰§è¡Œå˜æ›´æ“ä½œ
    log_info "å¼€å§‹æ‰§è¡Œï¼š$action_description"
    if execute_change "$target_state"; then
        log_success "$action_description æ‰§è¡ŒæˆåŠŸ"
    else
        log_error "$action_description æ‰§è¡Œå¤±è´¥"
        return 1
    fi
    
    # 3. éªŒè¯æœ€ç»ˆçŠ¶æ€
    if verify_final_state "$target_state"; then
        log_success "$action_description éªŒè¯é€šè¿‡"
        return 0
    else
        log_error "$action_description éªŒè¯å¤±è´¥"
        return 1
    fi
}
```

**ğŸ’¡ å…·ä½“åº”ç”¨ç¤ºä¾‹**

```bash
# å¹‚ç­‰æ€§åˆ›å»ºç”¨æˆ·
create_user_idempotent() {
    local username=$1
    local home_dir="/home/$username"
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    if id "$username" >/dev/null 2>&1; then
        echo "ç”¨æˆ· $username å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º"
        return 0
    fi
    
    # åˆ›å»ºç”¨æˆ·
    useradd -m -d "$home_dir" "$username"
    local result=$?
    
    # éªŒè¯åˆ›å»ºç»“æœ
    if [ $result -eq 0 ] && id "$username" >/dev/null 2>&1; then
        echo "ç”¨æˆ· $username åˆ›å»ºæˆåŠŸ"
        return 0
    else
        echo "ç”¨æˆ· $username åˆ›å»ºå¤±è´¥"
        return 1
    fi
}

# å¹‚ç­‰æ€§ç›®å½•åˆ›å»º
ensure_directory() {
    local dir_path=$1
    local permissions=${2:-755}
    local owner=${3:-$(whoami)}
    
    # ç›®å½•å·²å­˜åœ¨ä¸”æƒé™æ­£ç¡®
    if [ -d "$dir_path" ]; then
        local current_perm=$(stat -c "%a" "$dir_path")
        local current_owner=$(stat -c "%U" "$dir_path")
        
        if [ "$current_perm" = "$permissions" ] && [ "$current_owner" = "$owner" ]; then
            return 0
        fi
    fi
    
    # åˆ›å»ºæˆ–ä¿®æ­£ç›®å½•
    mkdir -p "$dir_path"
    chmod "$permissions" "$dir_path"
    chown "$owner" "$dir_path"
    
    echo "ç›®å½• $dir_path å·²ç¡®ä¿å­˜åœ¨å¹¶é…ç½®æ­£ç¡®"
}

# å¹‚ç­‰æ€§æœåŠ¡ç®¡ç†
ensure_service_running() {
    local service_name=$1
    
    if systemctl is-active "$service_name" >/dev/null 2>&1; then
        echo "æœåŠ¡ $service_name å·²åœ¨è¿è¡Œ"
        return 0
    fi
    
    echo "å¯åŠ¨æœåŠ¡ $service_name"
    systemctl start "$service_name"
    
    # ç­‰å¾…æœåŠ¡å¯åŠ¨å®Œæˆ
    sleep 2
    
    if systemctl is-active "$service_name" >/dev/null 2>&1; then
        echo "æœåŠ¡ $service_name å¯åŠ¨æˆåŠŸ"
        return 0
    else
        echo "æœåŠ¡ $service_name å¯åŠ¨å¤±è´¥"
        return 1
    fi
}
```

### 1.3 çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ


**ğŸ” çŠ¶æ€æ£€æŸ¥æŠ€å·§**

```bash
# æ–‡ä»¶çŠ¶æ€æ£€æŸ¥
check_file_state() {
    local file_path=$1
    local expected_content=$2
    
    # æ–‡ä»¶å­˜åœ¨ä¸”å†…å®¹åŒ¹é…
    if [ -f "$file_path" ]; then
        if [ -n "$expected_content" ]; then
            grep -qF "$expected_content" "$file_path" && return 0
        else
            return 0
        fi
    fi
    return 1
}

# æœåŠ¡çŠ¶æ€æ£€æŸ¥
check_service_state() {
    local service_name=$1
    local expected_state=${2:-active}
    
    local current_state=$(systemctl is-active "$service_name" 2>/dev/null)
    [ "$current_state" = "$expected_state" ]
}

# ç½‘ç»œç«¯å£æ£€æŸ¥
check_port_listening() {
    local port=$1
    local host=${2:-localhost}
    
    netstat -ln | grep -q ":$port " || \
    ss -ln | grep -q ":$port "
}

# è½¯ä»¶åŒ…å®‰è£…çŠ¶æ€æ£€æŸ¥
check_package_installed() {
    local package_name=$1
    
    if command -v dpkg >/dev/null 2>&1; then
        dpkg -l | grep -q "^ii.*$package_name"
    elif command -v rpm >/dev/null 2>&1; then
        rpm -q "$package_name" >/dev/null 2>&1
    else
        command -v "$package_name" >/dev/null 2>&1
    fi
}
```

---

## 2. ğŸ”’ é”æ–‡ä»¶æœºåˆ¶è¯¦è§£


### 2.1 ä¸ºä»€ä¹ˆéœ€è¦é”æ–‡ä»¶æœºåˆ¶

**ğŸ¯ å¹¶å‘é—®é¢˜çš„ç°å®åœºæ™¯**

```
è¿ç»´ä¸­çš„å¹¶å‘å†²çªï¼š

1. å®šæ—¶ä»»åŠ¡é‡å 
   cronæ¯åˆ†é’Ÿæ‰§è¡Œå¤‡ä»½è„šæœ¬
   ä¸Šæ¬¡å¤‡ä»½æœªå®Œæˆï¼Œæ–°å¤‡ä»½åˆå¼€å§‹
   ç»“æœï¼šæ–‡ä»¶æŸåã€èµ„æºç«äº‰

2. æ‰‹åŠ¨å¹²é¢„å†²çª
   ç®¡ç†å‘˜æ‰‹åŠ¨æ‰§è¡Œç»´æŠ¤è„šæœ¬
   åŒæ—¶è‡ªåŠ¨åŒ–ä»»åŠ¡ä¹Ÿåœ¨è¿è¡Œ
   ç»“æœï¼šæ“ä½œå†²çªã€çŠ¶æ€ä¸ä¸€è‡´

3. å¤šå®ä¾‹ç«äº‰
   é›†ç¾¤ç¯å¢ƒä¸‹å¤šä¸ªèŠ‚ç‚¹
   åŒæ—¶æ‰§è¡Œç›¸åŒçš„ç®¡ç†ä»»åŠ¡
   ç»“æœï¼šé‡å¤æ“ä½œã€èµ„æºæµªè´¹
```

### 2.2 flocké”æ–‡ä»¶å®ç°


**ğŸ”§ flockåŸºç¡€ç”¨æ³•**

```bash
# åŸºæœ¬flockè¯­æ³•
flock_basic_example() {
    local lock_file="/var/lock/my_script.lock"
    
    # æ–¹å¼1ï¼šå‘½ä»¤è¡Œæ–¹å¼
    flock -n "$lock_file" /path/to/script.sh || {
        echo "è„šæœ¬æ­£åœ¨è¿è¡Œä¸­ï¼Œé€€å‡º"
        exit 1
    }
    
    # æ–¹å¼2ï¼šæ–‡ä»¶æè¿°ç¬¦æ–¹å¼
    exec 200>"$lock_file"
    flock -n 200 || {
        echo "è·å–é”å¤±è´¥ï¼Œè„šæœ¬å¯èƒ½æ­£åœ¨è¿è¡Œ"
        exit 1
    }
    
    # è„šæœ¬ä¸»è¦é€»è¾‘
    echo "å¼€å§‹æ‰§è¡Œä¸»è¦ä»»åŠ¡..."
    sleep 10
    echo "ä»»åŠ¡å®Œæˆ"
    
    # é‡Šæ”¾é”ï¼ˆè„šæœ¬ç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾ï¼‰
}

# é«˜çº§flockåº”ç”¨
advanced_flock_pattern() {
    local script_name=$(basename "$0")
    local lock_dir="/var/lock"
    local lock_file="$lock_dir/${script_name}.lock"
    local lock_fd=200
    
    # ç¡®ä¿é”ç›®å½•å­˜åœ¨
    mkdir -p "$lock_dir"
    
    # è·å–é”æ–‡ä»¶æè¿°ç¬¦
    exec {lock_fd}>"$lock_file"
    
    # å°è¯•è·å–é”ï¼ˆéé˜»å¡ï¼‰
    if ! flock -n $lock_fd; then
        echo "é”™è¯¯ï¼šè„šæœ¬ $script_name å·²åœ¨è¿è¡Œä¸­"
        echo "é”æ–‡ä»¶ï¼š$lock_file"
        exit 1
    fi
    
    # åœ¨é”æ–‡ä»¶ä¸­è®°å½•è¿›ç¨‹ä¿¡æ¯
    echo "PID: $$" >&$lock_fd
    echo "å¼€å§‹æ—¶é—´: $(date)" >&$lock_fd
    echo "ç”¨æˆ·: $(whoami)" >&$lock_fd
    
    # è®¾ç½®æ¸…ç†å‡½æ•°
    trap "cleanup_and_exit" EXIT INT TERM
    
    cleanup_and_exit() {
        echo "æ¸…ç†é”æ–‡ä»¶å¹¶é€€å‡º"
        flock -u $lock_fd
        exec {lock_fd}>&-
        rm -f "$lock_file"
        exit
    }
    
    # ä¸»è¦ä¸šåŠ¡é€»è¾‘
    main_business_logic
}
```

### 2.3 lockfileå·¥å…·ä½¿ç”¨


**ğŸ“¦ lockfile-progså·¥å…·åŒ…**

```bash
# å®‰è£…lockfileå·¥å…·
# Ubuntu/Debian: apt install lockfile-progs
# CentOS/RHEL: yum install procmail (åŒ…å«lockfile)

lockfile_example() {
    local lock_file="/tmp/backup_script.lock"
    local max_wait=300  # æœ€å¤§ç­‰å¾…5åˆ†é’Ÿ
    
    # å°è¯•è·å–é”
    if ! lockfile -r 0 -l $max_wait "$lock_file"; then
        echo "æ— æ³•è·å–é”ï¼Œå¯èƒ½æœ‰å…¶ä»–å®ä¾‹åœ¨è¿è¡Œ"
        exit 1
    fi
    
    # è®¾ç½®æ¸…ç†é™·é˜±
    trap 'rm -f "$lock_file"; exit' INT TERM EXIT
    
    echo "å¼€å§‹æ‰§è¡Œå¤‡ä»½ä»»åŠ¡..."
    
    # ä¸»è¦ä¸šåŠ¡é€»è¾‘
    perform_backup_tasks
    
    # æ¸…ç†é”æ–‡ä»¶
    rm -f "$lock_file"
    echo "å¤‡ä»½ä»»åŠ¡å®Œæˆ"
}

# å¸¦è¶…æ—¶çš„é”è·å–
lockfile_with_timeout() {
    local lock_file="/var/run/maintenance.lock"
    local timeout=600  # 10åˆ†é’Ÿè¶…æ—¶
    
    # å†™å…¥é”ä¿¡æ¯
    echo "è¿›ç¨‹PID: $$" > "$lock_file.info"
    echo "å¼€å§‹æ—¶é—´: $(date)" >> "$lock_file.info"
    
    # è·å–é”ï¼Œæœ€å¤šç­‰å¾…10åˆ†é’Ÿ
    if lockfile -l $timeout "$lock_file"; then
        echo "æˆåŠŸè·å–é”ï¼Œå¼€å§‹æ‰§è¡Œç»´æŠ¤ä»»åŠ¡"
        
        # æ‰§è¡Œç»´æŠ¤é€»è¾‘
        maintenance_tasks
        
        # æ¸…ç†
        rm -f "$lock_file" "$lock_file.info"
    else
        echo "è·å–é”è¶…æ—¶ï¼Œé€€å‡ºæ‰§è¡Œ"
        rm -f "$lock_file.info"
        exit 1
    fi
}
```

### 2.4 è‡ªå®šä¹‰é”æœºåˆ¶


**ğŸ› ï¸ æ‰‹å·¥å®ç°é”æœºåˆ¶**

```bash
# åŸºäºPIDçš„é”å®ç°
pid_lock_implementation() {
    local script_name=$(basename "$0")
    local pid_file="/var/run/${script_name}.pid"
    
    # æ£€æŸ¥PIDæ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if [ -f "$pid_file" ]; then
        local old_pid=$(cat "$pid_file")
        
        # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦ä»åœ¨è¿è¡Œ
        if kill -0 "$old_pid" 2>/dev/null; then
            echo "è„šæœ¬å·²åœ¨è¿è¡Œ (PID: $old_pid)"
            exit 1
        else
            echo "å‘ç°åƒµå°¸PIDæ–‡ä»¶ï¼Œæ¸…ç†ä¸­..."
            rm -f "$pid_file"
        fi
    fi
    
    # å†™å…¥å½“å‰PID
    echo $$ > "$pid_file"
    
    # è®¾ç½®æ¸…ç†å‡½æ•°
    cleanup_pid() {
        rm -f "$pid_file"
        exit
    }
    trap cleanup_pid EXIT INT TERM
    
    # ä¸»è¦ä¸šåŠ¡é€»è¾‘
    echo "å¼€å§‹æ‰§è¡Œä»»åŠ¡ (PID: $$)"
    main_task_execution
}

# å¸¦æ—¶é—´æˆ³çš„é”æ£€æŸ¥
timestamp_based_lock() {
    local lock_file="/tmp/script.lock"
    local max_age=3600  # 1å°æ—¶è¿‡æœŸ
    
    # æ£€æŸ¥é”æ–‡ä»¶æ˜¯å¦è¿‡æœŸ
    if [ -f "$lock_file" ]; then
        local lock_age=$(($(date +%s) - $(stat -c %Y "$lock_file")))
        
        if [ $lock_age -gt $max_age ]; then
            echo "é”æ–‡ä»¶å·²è¿‡æœŸï¼Œå¼ºåˆ¶æ¸…ç†"
            rm -f "$lock_file"
        else
            echo "å‘ç°æœ‰æ•ˆé”æ–‡ä»¶ï¼Œé€€å‡º"
            exit 1
        fi
    fi
    
    # åˆ›å»ºé”æ–‡ä»¶
    touch "$lock_file"
    echo "PID: $$" > "$lock_file"
    echo "æ—¶é—´: $(date)" >> "$lock_file"
    
    # æ¸…ç†å‡½æ•°
    trap 'rm -f "$lock_file"' EXIT
    
    # ä¸šåŠ¡é€»è¾‘
    execute_main_logic
}
```

---

## 3. âš¡ è„šæœ¬é€€å‡ºçŠ¶æ€ç è§„èŒƒ


### 3.1 æ ‡å‡†é€€å‡ºçŠ¶æ€ç å«ä¹‰

**ğŸ“‹ Linuxç³»ç»Ÿæ ‡å‡†çŠ¶æ€ç **

```
æ ‡å‡†çŠ¶æ€ç è§„èŒƒï¼š
0   : æˆåŠŸæ‰§è¡Œ
1   : ä¸€èˆ¬æ€§é”™è¯¯
2   : è¯¯ç”¨shellå‘½ä»¤
126 : å‘½ä»¤ä¸å¯æ‰§è¡Œ
127 : å‘½ä»¤æœªæ‰¾åˆ°
128 : æ— æ•ˆçš„é€€å‡ºå‚æ•°
130 : è„šæœ¬è¢«Ctrl+Cç»ˆæ­¢
```

**ğŸ¯ è‡ªå®šä¹‰çŠ¶æ€ç è®¾è®¡åŸåˆ™**

| çŠ¶æ€ç èŒƒå›´ | **ç”¨é€”** | **ç¤ºä¾‹åœºæ™¯** |
|-----------|---------|-------------|
| **0** | `æˆåŠŸ` | `æ­£å¸¸å®Œæˆæ‰€æœ‰ä»»åŠ¡` |
| **1-2** | `ä¸€èˆ¬é”™è¯¯` | `å‚æ•°é”™è¯¯ã€æ–‡ä»¶ä¸å­˜åœ¨` |
| **3-9** | `é…ç½®é”™è¯¯` | `é…ç½®æ–‡ä»¶é—®é¢˜ã€æƒé™ä¸è¶³` |
| **10-19** | `ç½‘ç»œé”™è¯¯` | `è¿æ¥å¤±è´¥ã€ä¸‹è½½è¶…æ—¶` |
| **20-29** | `ç³»ç»Ÿèµ„æº` | `ç£ç›˜æ»¡ã€å†…å­˜ä¸è¶³` |
| **30-39** | `ä¸šåŠ¡é€»è¾‘` | `æ•°æ®éªŒè¯å¤±è´¥ã€ä¸šåŠ¡è§„åˆ™å†²çª` |

### 3.2 é€€å‡ºçŠ¶æ€ç æœ€ä½³å®è·µ


```bash
# å®šä¹‰çŠ¶æ€ç å¸¸é‡
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_MISUSE=2
readonly EXIT_CONFIG_ERROR=3
readonly EXIT_PERMISSION_ERROR=4
readonly EXIT_NETWORK_ERROR=10
readonly EXIT_DISK_FULL=20
readonly EXIT_MEMORY_ERROR=21
readonly EXIT_BUSINESS_ERROR=30

# é€€å‡ºå‡½æ•°å°è£…
exit_with_message() {
    local exit_code=$1
    local message=$2
    local log_level=${3:-ERROR}
    
    case $exit_code in
        $EXIT_SUCCESS)
            log_level="INFO"
            ;;
        $EXIT_CONFIG_ERROR|$EXIT_PERMISSION_ERROR)
            log_level="ERROR"
            ;;
        $EXIT_NETWORK_ERROR)
            log_level="WARN"
            ;;
    esac
    
    log_message "$log_level" "$message"
    exit $exit_code
}

# å®é™…åº”ç”¨ç¤ºä¾‹
backup_script_example() {
    local backup_source="/home/user/data"
    local backup_dest="/backup/daily"
    
    # æ£€æŸ¥æºç›®å½•
    if [ ! -d "$backup_source" ]; then
        exit_with_message $EXIT_CONFIG_ERROR "å¤‡ä»½æºç›®å½•ä¸å­˜åœ¨: $backup_source"
    fi
    
    # æ£€æŸ¥ç›®æ ‡ç›®å½•æƒé™
    if [ ! -w "$(dirname "$backup_dest")" ]; then
        exit_with_message $EXIT_PERMISSION_ERROR "æ— æƒé™å†™å…¥å¤‡ä»½ç›®å½•: $backup_dest"
    fi
    
    # æ£€æŸ¥ç£ç›˜ç©ºé—´
    local available_space=$(df "$backup_dest" | awk 'NR==2 {print $4}')
    local required_space=$(du -s "$backup_source" | awk '{print $1}')
    
    if [ "$available_space" -lt "$required_space" ]; then
        exit_with_message $EXIT_DISK_FULL "ç£ç›˜ç©ºé—´ä¸è¶³ï¼Œéœ€è¦ ${required_space}KBï¼Œå¯ç”¨ ${available_space}KB"
    fi
    
    # æ‰§è¡Œå¤‡ä»½
    if rsync -av "$backup_source/" "$backup_dest/"; then
        exit_with_message $EXIT_SUCCESS "å¤‡ä»½å®ŒæˆæˆåŠŸ"
    else
        exit_with_message $EXIT_GENERAL_ERROR "å¤‡ä»½æ‰§è¡Œå¤±è´¥"
    fi
}
```

### 3.3 çŠ¶æ€ç åœ¨ç›‘æ§ä¸­çš„åº”ç”¨


```bash
# ç›‘æ§å‹å¥½çš„çŠ¶æ€ç è®¾è®¡
monitoring_friendly_script() {
    local script_name=$(basename "$0")
    local status_file="/var/run/${script_name}.status"
    local metric_file="/var/log/${script_name}.metrics"
    
    # è®°å½•å¼€å§‹çŠ¶æ€
    echo "RUNNING" > "$status_file"
    echo "start_time=$(date +%s)" > "$metric_file"
    
    # ä¸»è¦é€»è¾‘æ‰§è¡Œ
    if main_business_logic; then
        local exit_code=$EXIT_SUCCESS
        local status="SUCCESS"
    else
        local exit_code=$?
        case $exit_code in
            $EXIT_CONFIG_ERROR)
                local status="CONFIG_ERROR"
                ;;
            $EXIT_NETWORK_ERROR)
                local status="NETWORK_ERROR"
                ;;
            $EXIT_DISK_FULL)
                local status="RESOURCE_ERROR"
                ;;
            *)
                local status="GENERAL_ERROR"
                ;;
        esac
    fi
    
    # è®°å½•ç»“æŸçŠ¶æ€å’ŒæŒ‡æ ‡
    echo "$status" > "$status_file"
    echo "end_time=$(date +%s)" >> "$metric_file"
    echo "exit_code=$exit_code" >> "$metric_file"
    
    # å‘é€ç›‘æ§æŒ‡æ ‡
    send_metrics_to_monitoring "$script_name" "$exit_code" "$status"
    
    exit $exit_code
}

# é›†æˆPrometheusç›‘æ§
prometheus_integration() {
    local metric_name="automation_script_status"
    local labels="script=\"$1\",host=\"$(hostname)\""
    local value=$2
    local status=$3
    
    # å†™å…¥node_exporter textfile collector
    local metric_file="/var/lib/node_exporter/textfile_collector/${1}.prom"
    
    cat > "$metric_file" << EOF
# HELP $metric_name Automation script execution status
# TYPE $metric_name gauge
${metric_name}{${labels},status="$status"} $value
automation_script_last_success{${labels}} $(date +%s)
EOF
}
```

---

## 4. ğŸ”„ é”™è¯¯å¤„ç†ä¸é‡è¯•æœºåˆ¶


### 4.1 é”™è¯¯å¤„ç†è®¾è®¡æ¨¡å¼


**ğŸ¯ åˆ†å±‚é”™è¯¯å¤„ç†æ¶æ„**

```bash
# å…¨å±€é”™è¯¯å¤„ç†æ¡†æ¶
setup_error_handling() {
    # è®¾ç½®ä¸¥æ ¼æ¨¡å¼
    set -euo pipefail
    
    # å…¨å±€é”™è¯¯é™·é˜±
    trap 'handle_error $? $LINENO $BASH_COMMAND' ERR
    trap 'cleanup_on_exit' EXIT
    trap 'handle_signal INT' INT
    trap 'handle_signal TERM' TERM
}

# é”™è¯¯å¤„ç†å‡½æ•°
handle_error() {
    local exit_code=$1
    local line_number=$2
    local command="$3"
    
    log_error "è„šæœ¬æ‰§è¡Œå¤±è´¥"
    log_error "é€€å‡ºç : $exit_code"
    log_error "è¡Œå·: $line_number" 
    log_error "å‘½ä»¤: $command"
    log_error "è°ƒç”¨æ ˆ: ${FUNCNAME[*]}"
    
    # å‘é€é”™è¯¯é€šçŸ¥
    send_error_notification "$exit_code" "$line_number" "$command"
    
    # æ¸…ç†èµ„æº
    cleanup_resources
    
    exit $exit_code
}

# å¯æ¢å¤é”™è¯¯å¤„ç†
recoverable_error_handling() {
    local operation_description=$1
    shift  # å‰©ä½™å‚æ•°æ˜¯è¦æ‰§è¡Œçš„å‘½ä»¤
    
    if "$@"; then
        log_success "$operation_description æ‰§è¡ŒæˆåŠŸ"
        return 0
    else
        local exit_code=$?
        log_warn "$operation_description æ‰§è¡Œå¤±è´¥ï¼Œé€€å‡ºç : $exit_code"
        
        # æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦ç»§ç»­
        case $exit_code in
            $EXIT_NETWORK_ERROR|$EXIT_DISK_FULL)
                log_info "é‡åˆ°å¯æ¢å¤é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œåç»­æ“ä½œ"
                return $exit_code
                ;;
            *)
                log_error "é‡åˆ°ä¸¥é‡é”™è¯¯ï¼Œåœæ­¢æ‰§è¡Œ"
                exit $exit_code
                ;;
        esac
    fi
}
```

### 4.2 é‡è¯•æœºåˆ¶å®ç°


**ğŸ” æŒ‡æ•°é€€é¿é‡è¯•ç®—æ³•**

```bash
# é€šç”¨é‡è¯•å‡½æ•°
retry_with_backoff() {
    local max_attempts=${1:-3}
    local delay=${2:-1}
    local backoff_factor=${3:-2}
    local max_delay=${4:-60}
    
    shift 4  # ç§»é™¤é‡è¯•å‚æ•°ï¼Œå‰©ä½™æ˜¯è¦æ‰§è¡Œçš„å‘½ä»¤
    local command=("$@")
    
    local attempt=1
    local current_delay=$delay
    
    while [ $attempt -le $max_attempts ]; do
        log_info "å°è¯•æ‰§è¡Œ (ç¬¬ $attempt/$max_attempts æ¬¡): ${command[*]}"
        
        if "${command[@]}"; then
            log_success "å‘½ä»¤æ‰§è¡ŒæˆåŠŸ (å°è¯• $attempt æ¬¡)"
            return 0
        else
            local exit_code=$?
            log_warn "å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼Œé€€å‡ºç : $exit_code"
            
            if [ $attempt -eq $max_attempts ]; then
                log_error "æ‰€æœ‰é‡è¯•å·²ç”¨å°½ï¼Œæœ€ç»ˆå¤±è´¥"
                return $exit_code
            fi
            
            log_info "ç­‰å¾… $current_delay ç§’åé‡è¯•..."
            sleep $current_delay
            
            # è®¡ç®—ä¸‹æ¬¡å»¶è¿Ÿæ—¶é—´ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
            current_delay=$((current_delay * backoff_factor))
            if [ $current_delay -gt $max_delay ]; then
                current_delay=$max_delay
            fi
            
            attempt=$((attempt + 1))
        fi
    done
}

# ç½‘ç»œæ“ä½œé‡è¯•ç¤ºä¾‹
retry_network_operation() {
    local url=$1
    local output_file=$2
    
    # ç½‘ç»œæ“ä½œé€šå¸¸éœ€è¦æ›´å¤šé‡è¯•æ¬¡æ•°
    retry_with_backoff 5 2 2 30 wget -O "$output_file" "$url"
}

# æ•°æ®åº“æ“ä½œé‡è¯•
retry_database_operation() {
    local sql_command=$1
    
    # æ•°æ®åº“è¿æ¥é—®é¢˜é€šå¸¸å¾ˆå¿«æ¢å¤
    retry_with_backoff 3 1 2 10 mysql -e "$sql_command"
}

# æ–‡ä»¶æ“ä½œé‡è¯•ï¼ˆå¤„ç†ä¸´æ—¶é”å®šï¼‰
retry_file_operation() {
    local source_file=$1
    local dest_file=$2
    
    # æ–‡ä»¶æ“ä½œå†²çªé€šå¸¸éœ€è¦çŸ­æš‚ç­‰å¾…
    retry_with_backoff 5 0.5 1.5 5 cp "$source_file" "$dest_file"
}
```

### 4.3 æ¡ä»¶é‡è¯•å’Œæ–­è·¯å™¨æ¨¡å¼


**âš¡ æ™ºèƒ½é‡è¯•å†³ç­–**

```bash
# æ¡ä»¶é‡è¯•ï¼šæ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¯•
conditional_retry() {
    local max_attempts=$1
    local command=("${@:2}")
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        log_info "æ‰§è¡Œå‘½ä»¤ (å°è¯• $attempt/$max_attempts)"
        
        if "${command[@]}"; then
            return 0
        else
            local exit_code=$?
            
            # æ ¹æ®é”™è¯¯ç±»å‹åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
            case $exit_code in
                $EXIT_NETWORK_ERROR|$EXIT_DISK_FULL)
                    log_info "é‡åˆ°å¯é‡è¯•é”™è¯¯ ($exit_code)ï¼Œå‡†å¤‡é‡è¯•"
                    ;;
                $EXIT_CONFIG_ERROR|$EXIT_PERMISSION_ERROR)
                    log_error "é‡åˆ°ä¸å¯é‡è¯•é”™è¯¯ ($exit_code)ï¼Œåœæ­¢é‡è¯•"
                    return $exit_code
                    ;;
                *)
                    if [ $attempt -eq $max_attempts ]; then
                        log_error "æœªçŸ¥é”™è¯¯ ($exit_code)ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°"
                        return $exit_code
                    fi
                    log_warn "æœªçŸ¥é”™è¯¯ ($exit_code)ï¼Œç»§ç»­é‡è¯•"
                    ;;
            esac
            
            attempt=$((attempt + 1))
            sleep $((attempt - 1))  # é€’å¢å»¶è¿Ÿ
        fi
    done
}

# æ–­è·¯å™¨æ¨¡å¼ï¼šè¿ç»­å¤±è´¥æ—¶æš‚åœæœåŠ¡
circuit_breaker() {
    local service_name=$1
    local failure_threshold=${2:-5}
    local recovery_timeout=${3:-300}  # 5åˆ†é’Ÿ
    local state_file="/tmp/circuit_breaker_${service_name}.state"
    
    # è¯»å–æ–­è·¯å™¨çŠ¶æ€
    local failure_count=0
    local last_failure_time=0
    
    if [ -f "$state_file" ]; then
        source "$state_file"
    fi
    
    local current_time=$(date +%s)
    
    # æ£€æŸ¥æ˜¯å¦åœ¨æ¢å¤æœŸå†…
    if [ $((current_time - last_failure_time)) -lt $recovery_timeout ]; then
        if [ $failure_count -ge $failure_threshold ]; then
            log_error "æ–­è·¯å™¨å¼€å¯ï¼šæœåŠ¡ $service_name æš‚åœ ($failure_count æ¬¡è¿ç»­å¤±è´¥)"
            return 1
        fi
    else
        # æ¢å¤æœŸç»“æŸï¼Œé‡ç½®è®¡æ•°å™¨
        failure_count=0
    fi
    
    # æ‰§è¡ŒæœåŠ¡æ“ä½œ
    shift 3  # ç§»é™¤å‰ä¸‰ä¸ªå‚æ•°
    if "$@"; then
        # æˆåŠŸæ—¶é‡ç½®å¤±è´¥è®¡æ•°
        failure_count=0
        echo "failure_count=0" > "$state_file"
        echo "last_failure_time=$current_time" >> "$state_file"
        return 0
    else
        # å¤±è´¥æ—¶å¢åŠ è®¡æ•°
        failure_count=$((failure_count + 1))
        echo "failure_count=$failure_count" > "$state_file"
        echo "last_failure_time=$current_time" >> "$state_file"
        
        log_warn "æœåŠ¡ $service_name å¤±è´¥ (è¿ç»­ $failure_count æ¬¡)"
        return 1
    fi
}
```

---

## 5. â±ï¸ è¶…æ—¶æ§åˆ¶ä¸èµ„æºæ¸…ç†


### 5.1 å‘½ä»¤è¶…æ—¶æ§åˆ¶æœºåˆ¶


**ğŸ”§ timeoutå‘½ä»¤å’Œè‡ªå®šä¹‰è¶…æ—¶**

```bash
# ä½¿ç”¨timeoutå‘½ä»¤
basic_timeout_usage() {
    local max_time=$1
    local command=("${@:2}")
    
    # timeoutå‘½ä»¤åŸºç¡€ç”¨æ³•
    if timeout "$max_time" "${command[@]}"; then
        log_success "å‘½ä»¤åœ¨ $max_time ç§’å†…å®Œæˆ"
        return 0
    else
        local exit_code=$?
        case $exit_code in
            124)
                log_error "å‘½ä»¤è¶…æ—¶ (${max_time}ç§’)"
                ;;
            125)
                log_error "timeoutå‘½ä»¤æœ¬èº«å¤±è´¥"
                ;;
            126|127)
                log_error "å‘½ä»¤æ— æ³•æ‰§è¡Œ"
                ;;
            *)
                log_error "å‘½ä»¤å¤±è´¥ï¼Œé€€å‡ºç : $exit_code"
                ;;
        esac
        return $exit_code
    fi
}

# è‡ªå®šä¹‰è¶…æ—¶å®ç°
custom_timeout_implementation() {
    local timeout_seconds=$1
    local command=("${@:2}")
    
    # åœ¨åå°æ‰§è¡Œå‘½ä»¤
    "${command[@]}" &
    local cmd_pid=$!
    
    # å¯åŠ¨è¶…æ—¶ç›‘æ§
    (
        sleep "$timeout_seconds"
        if kill -0 "$cmd_pid" 2>/dev/null; then
            log_warn "å‘½ä»¤è¶…æ—¶ï¼Œæ­£åœ¨ç»ˆæ­¢è¿›ç¨‹ $cmd_pid"
            kill -TERM "$cmd_pid" 2>/dev/null
            sleep 5
            
            # å¦‚æœTERMä¿¡å·æ— æ•ˆï¼Œä½¿ç”¨KILL
            if kill -0 "$cmd_pid" 2>/dev/null; then
                log_error "å¼ºåˆ¶ç»ˆæ­¢è¿›ç¨‹ $cmd_pid"
                kill -KILL "$cmd_pid" 2>/dev/null
            fi
        fi
    ) &
    local timeout_pid=$!
    
    # ç­‰å¾…å‘½ä»¤å®Œæˆ
    if wait "$cmd_pid"; then
        # å‘½ä»¤æˆåŠŸå®Œæˆï¼Œæ¸…ç†è¶…æ—¶ç›‘æ§
        kill "$timeout_pid" 2>/dev/null
        wait "$timeout_pid" 2>/dev/null
        return 0
    else
        local exit_code=$?
        # æ¸…ç†è¶…æ—¶ç›‘æ§
        kill "$timeout_pid" 2>/dev/null
        wait "$timeout_pid" 2>/dev/null
        return $exit_code
    fi
}
```

### 5.2 èµ„æºæ¸…ç†æœºåˆ¶


**ğŸ§¹ å…¨é¢çš„èµ„æºæ¸…ç†ç­–ç•¥**

```bash
# å…¨å±€èµ„æºè·Ÿè¸ª
declare -a TEMP_FILES=()
declare -a TEMP_DIRS=()
declare -a BACKGROUND_PIDS=()
declare -a CLEANUP_COMMANDS=()

# èµ„æºæ³¨å†Œå‡½æ•°
register_temp_file() {
    local temp_file=$1
    TEMP_FILES+=("$temp_file")
    log_debug "æ³¨å†Œä¸´æ—¶æ–‡ä»¶: $temp_file"
}

register_temp_dir() {
    local temp_dir=$1
    TEMP_DIRS+=("$temp_dir")
    log_debug "æ³¨å†Œä¸´æ—¶ç›®å½•: $temp_dir"
}

register_background_process() {
    local pid=$1
    BACKGROUND_PIDS+=("$pid")
    log_debug "æ³¨å†Œåå°è¿›ç¨‹: $pid"
}

register_cleanup_command() {
    local command=$1
    CLEANUP_COMMANDS+=("$command")
    log_debug "æ³¨å†Œæ¸…ç†å‘½ä»¤: $command"
}

# å…¨é¢æ¸…ç†å‡½æ•°
cleanup_all_resources() {
    log_info "å¼€å§‹æ¸…ç†æ‰€æœ‰èµ„æº..."
    
    # æ¸…ç†åå°è¿›ç¨‹
    for pid in "${BACKGROUND_PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            log_info "ç»ˆæ­¢åå°è¿›ç¨‹: $pid"
            kill -TERM "$pid" 2>/dev/null
            sleep 2
            
            # å¼ºåˆ¶ç»ˆæ­¢ä»åœ¨è¿è¡Œçš„è¿›ç¨‹
            if kill -0 "$pid" 2>/dev/null; then
                log_warn "å¼ºåˆ¶ç»ˆæ­¢è¿›ç¨‹: $pid"
                kill -KILL "$pid" 2>/dev/null
            fi
        fi
    done
    
    # æ‰§è¡Œè‡ªå®šä¹‰æ¸…ç†å‘½ä»¤
    for cmd in "${CLEANUP_COMMANDS[@]}"; do
        log_info "æ‰§è¡Œæ¸…ç†å‘½ä»¤: $cmd"
        eval "$cmd" || log_warn "æ¸…ç†å‘½ä»¤æ‰§è¡Œå¤±è´¥: $cmd"
    done
    
    # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    for file in "${TEMP_FILES[@]}"; do
        if [ -f "$file" ]; then
            log_info "æ¸…ç†ä¸´æ—¶æ–‡ä»¶: $file"
            rm -f "$file"
        fi
    done
    
    # æ¸…ç†ä¸´æ—¶ç›®å½•
    for dir in "${TEMP_DIRS[@]}"; do
        if [ -d "$dir" ]; then
            log_info "æ¸…ç†ä¸´æ—¶ç›®å½•: $dir"
            rm -rf "$dir"
        fi
    done
    
    log_info "èµ„æºæ¸…ç†å®Œæˆ"
}

# è®¾ç½®æ¸…ç†é™·é˜±
setup_cleanup_traps() {
    trap 'cleanup_all_resources' EXIT
    trap 'log_warn "æ”¶åˆ°ä¸­æ–­ä¿¡å·"; cleanup_all_resources; exit 130' INT
    trap 'log_warn "æ”¶åˆ°ç»ˆæ­¢ä¿¡å·"; cleanup_all_resources; exit 143' TERM
}
```

### 5.3 é«˜çº§èµ„æºç®¡ç†


**ğŸ’¡ æ™ºèƒ½èµ„æºç®¡ç†æ¨¡å¼**

```bash
# èµ„æºæ± ç®¡ç†
resource_pool_manager() {
    local pool_name=$1
    local max_resources=${2:-10}
    local pool_file="/tmp/resource_pool_${pool_name}"
    
    # åˆå§‹åŒ–èµ„æºæ± 
    init_resource_pool() {
        echo "max_resources=$max_resources" > "$pool_file"
        echo "current_resources=0" >> "$pool_file"
        echo "allocated_resources=()" >> "$pool_file"
    }
    
    # ç”³è¯·èµ„æº
    allocate_resource() {
        local resource_id=$1
        
        # è¯»å–å½“å‰çŠ¶æ€
        source "$pool_file"
        
        if [ ${#allocated_resources[@]} -ge $max_resources ]; then
            log_error "èµ„æºæ± å·²æ»¡ï¼Œæ— æ³•åˆ†é…æ–°èµ„æº"
            return 1
        fi
        
        # åˆ†é…èµ„æº
        allocated_resources+=("$resource_id")
        current_resources=${#allocated_resources[@]}
        
        # æ›´æ–°çŠ¶æ€æ–‡ä»¶
        echo "max_resources=$max_resources" > "$pool_file"
        echo "current_resources=$current_resources" >> "$pool_file"
        echo "allocated_resources=(${allocated_resources[*]})" >> "$pool_file"
        
        log_info "åˆ†é…èµ„æº: $resource_id (å½“å‰: $current_resources/$max_resources)"
        return 0
    }
    
    # é‡Šæ”¾èµ„æº
    release_resource() {
        local resource_id=$1
        
        # è¯»å–å½“å‰çŠ¶æ€
        source "$pool_file"
        
        # ä»æ•°ç»„ä¸­ç§»é™¤èµ„æº
        local new_resources=()
        for res in "${allocated_resources[@]}"; do
            if [ "$res" != "$resource_id" ]; then
                new_resources+=("$res")
            fi
        done
        
        allocated_resources=("${new_resources[@]}")
        current_resources=${#allocated_resources[@]}
        
        # æ›´æ–°çŠ¶æ€æ–‡ä»¶
        echo "max_resources=$max_resources" > "$pool_file"
        echo "current_resources=$current_resources" >> "$pool_file"
        echo "allocated_resources=(${allocated_resources[*]})" >> "$pool_file"
        
        log_info "é‡Šæ”¾èµ„æº: $resource_id (å½“å‰: $current_resources/$max_resources)"
    }
    
    case ${3:-status} in
        init) init_resource_pool ;;
        allocate) allocate_resource "$4" ;;
        release) release_resource "$4" ;;
        status) 
            if [ -f "$pool_file" ]; then
                cat "$pool_file"
            else
                echo "èµ„æºæ±  $pool_name æœªåˆå§‹åŒ–"
            fi
            ;;
    esac
}

# æ™ºèƒ½å†…å­˜ç›‘æ§æ¸…ç†
memory_aware_cleanup() {
    local memory_threshold=${1:-80}  # å†…å­˜ä½¿ç”¨ç‡é˜ˆå€¼
    local check_interval=${2:-30}   # æ£€æŸ¥é—´éš”ç§’æ•°
    
    while true; do
        local memory_usage=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100)}')
        
        if [ "$memory_usage" -gt "$memory_threshold" ]; then
            log_warn "å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: ${memory_usage}%"
            
            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            log_info "æ¸…ç†ä¸´æ—¶æ–‡ä»¶ä»¥é‡Šæ”¾å†…å­˜"
            find /tmp -name "*.tmp" -mtime +1 -delete 2>/dev/null || true
            
            # æ¸…ç†æ—¥å¿—ç¼“å­˜
            if command -v sync >/dev/null; then
                sync  # åŒæ­¥ç¼“å­˜åˆ°ç£ç›˜
            fi
            
            # è§¦å‘åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæœ‰ç›¸å…³æœåŠ¡ï¼‰
            trigger_garbage_collection
            
            sleep 10
        fi
        
        sleep "$check_interval"
    done
}
```

---

## 6. ğŸ“‹ æ—¥å¿—è®°å½•æ ‡å‡†åŒ–


### 6.1 ç»“æ„åŒ–æ—¥å¿—è®¾è®¡


**ğŸ“ æ ‡å‡†æ—¥å¿—æ ¼å¼å®šä¹‰**

```bash
# æ—¥å¿—é…ç½®
readonly LOG_DIR="/var/log/automation"
readonly LOG_FILE="$LOG_DIR/$(basename "$0" .sh).log"
readonly LOG_LEVEL_DEBUG=0
readonly LOG_LEVEL_INFO=1
readonly LOG_LEVEL_WARN=2
readonly LOG_LEVEL_ERROR=3
readonly LOG_LEVEL_FATAL=4

# å½“å‰æ—¥å¿—çº§åˆ«ï¼ˆå¯é€šè¿‡ç¯å¢ƒå˜é‡è¦†ç›–ï¼‰
CURRENT_LOG_LEVEL=${LOG_LEVEL:-$LOG_LEVEL_INFO}

# ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
mkdir -p "$LOG_DIR"

# æ ‡å‡†æ—¥å¿—å‡½æ•°
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local hostname=$(hostname)
    local pid=$$
    local script_name=$(basename "$0")
    
    # æ—¥å¿—çº§åˆ«æ•°å€¼æ˜ å°„
    local level_num
    case $level in
        DEBUG) level_num=$LOG_LEVEL_DEBUG ;;
        INFO)  level_num=$LOG_LEVEL_INFO ;;
        WARN)  level_num=$LOG_LEVEL_WARN ;;
        ERROR) level_num=$LOG_LEVEL_ERROR ;;
        FATAL) level_num=$LOG_LEVEL_FATAL ;;
        *) level_num=$LOG_LEVEL_INFO ;;
    esac
    
    # åªè¾“å‡ºè¾¾åˆ°å½“å‰çº§åˆ«çš„æ—¥å¿—
    if [ $level_num -ge $CURRENT_LOG_LEVEL ]; then
        # ç»“æ„åŒ–æ—¥å¿—æ ¼å¼
        local log_entry="[$timestamp] [$hostname] [$script_name:$pid] [$level] $message"
        
        # è¾“å‡ºåˆ°æ–‡ä»¶å’Œç»ˆç«¯
        echo "$log_entry" | tee -a "$LOG_FILE"
        
        # é”™è¯¯çº§åˆ«é¢å¤–è¾“å‡ºåˆ°stderr
        if [ $level_num -ge $LOG_LEVEL_ERROR ]; then
            echo "$log_entry" >&2
        fi
    fi
}

# ä¾¿æ·æ—¥å¿—å‡½æ•°
log_debug() { log_message "DEBUG" "$1"; }
log_info()  { log_message "INFO" "$1"; }
log_warn()  { log_message "WARN" "$1"; }
log_error() { log_message "ERROR" "$1"; }
log_fatal() { log_message "FATAL" "$1"; exit 1; }
log_success() { log_message "INFO" "âœ“ $1"; }
```

### 6.2 JSONæ ¼å¼æ—¥å¿—


**ğŸ”§ æœºå™¨å¯è¯»çš„JSONæ—¥å¿—**

```bash
# JSONæ—¥å¿—å‡½æ•°
log_json() {
    local level=$1
    local message=$2
    local component=${3:-$(basename "$0")}
    local extra_fields=$4
    
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%S.%3NZ')
    local hostname=$(hostname)
    local pid=$$
    
    # æ„å»ºåŸºç¡€JSONç»“æ„
    local json_log=$(cat <<EOF
{
    "timestamp": "$timestamp",
    "level": "$level",
    "message": "$message",
    "component": "$component",
    "hostname": "$hostname",
    "pid": $pid,
    "thread": "main"
EOF
)
    
    # æ·»åŠ é¢å¤–å­—æ®µ
    if [ -n "$extra_fields" ]; then
        json_log="${json_log},${extra_fields}"
    fi
    
    json_log="${json_log}}"
    
    # è¾“å‡ºJSONæ—¥å¿—
    echo "$json_log" >> "${LOG_FILE%.log}.json"
    
    # åŒæ—¶è¾“å‡ºäººç±»å¯è¯»æ ¼å¼åˆ°ç»ˆç«¯
    log_message "$level" "$message"
}

# ä¸šåŠ¡æ—¥å¿—è®°å½•å‡½æ•°
log_business_event() {
    local event_type=$1
    local event_data=$2
    local user_id=${3:-system}
    
    local extra_fields=$(cat <<EOF
    "event_type": "$event_type",
    "event_data": $event_data,
    "user_id": "$user_id",
    "correlation_id": "$CORRELATION_ID"
EOF
)
    
    log_json "INFO" "Business event: $event_type" "business" "$extra_fields"
}

# æ€§èƒ½æ—¥å¿—è®°å½•
log_performance() {
    local operation=$1
    local duration_ms=$2
    local status=$3
    
    local extra_fields=$(cat <<EOF
    "operation": "$operation",
    "duration_ms": $duration_ms,
    "status": "$status",
    "performance_category": "timing"
EOF
)
    
    log_json "INFO" "Performance: $operation took ${duration_ms}ms" "performance" "$extra_fields"
}
```

### 6.3 æ—¥å¿—è½®è½¬å’Œç®¡ç†


**ğŸ”„ æ—¥å¿—æ–‡ä»¶ç®¡ç†ç­–ç•¥**

```bash
# æ—¥å¿—è½®è½¬é…ç½®
setup_log_rotation() {
    local script_name=$(basename "$0" .sh)
    local logrotate_config="/etc/logrotate.d/${script_name}"
    
    # åˆ›å»ºlogrotateé…ç½®
    cat > "$logrotate_config" << EOF
$LOG_DIR/*.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    create 644 $(whoami) $(whoami)
    postrotate
        /bin/kill -HUP \$(cat /var/run/rsyslogd.pid 2> /dev/null) 2> /dev/null || true
    endscript
}

$LOG_DIR/*.json {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 644 $(whoami) $(whoami)
}
EOF

    log_info "æ—¥å¿—è½®è½¬é…ç½®å·²åˆ›å»º: $logrotate_config"
}

# æ‰‹åŠ¨æ—¥å¿—æ¸…ç†
cleanup_old_logs() {
    local retention_days=${1:-30}
    local log_pattern=${2:-"*.log"}
    
    log_info "æ¸…ç† $retention_days å¤©å‰çš„æ—¥å¿—æ–‡ä»¶"
    
    # æŸ¥æ‰¾å¹¶åˆ é™¤æ—§æ—¥å¿—
    find "$LOG_DIR" -name "$log_pattern" -mtime +$retention_days -type f -print0 | \
    while IFS= read -r -d '' file; do
        log_info "åˆ é™¤æ—§æ—¥å¿—æ–‡ä»¶: $file"
        rm -f "$file"
    done
    
    # å‹ç¼©7å¤©å‰çš„æ—¥å¿—
    find "$LOG_DIR" -name "*.log" -mtime +7 -type f -print0 | \
    while IFS= read -r -d '' file; do
        if [ ! -f "${file}.gz" ]; then
            log_info "å‹ç¼©æ—¥å¿—æ–‡ä»¶: $file"
            gzip "$file"
        fi
    done
}

# æ—¥å¿—ç»Ÿè®¡åˆ†æ
analyze_logs() {
    local log_file=${1:-$LOG_FILE}
    local analysis_period=${2:-"1 day ago"}
    
    log_info "åˆ†ææ—¥å¿—æ–‡ä»¶: $log_file"
    log_info "åˆ†ææ—¶é—´èŒƒå›´: since $analysis_period"
    
    # æå–æ—¶é—´èŒƒå›´å†…çš„æ—¥å¿—
    local since_timestamp=$(date -d "$analysis_period" '+%Y-%m-%d %H:%M:%S')
    local temp_log="/tmp/log_analysis_$$"
    
    awk -v since="$since_timestamp" '
    $1 " " $2 >= "[" since "]" {print}
    ' "$log_file" > "$temp_log"
    
    # ç»Ÿè®¡å„çº§åˆ«æ—¥å¿—æ•°é‡
    echo "=== æ—¥å¿—çº§åˆ«ç»Ÿè®¡ ==="
    grep -oE '\[(DEBUG|INFO|WARN|ERROR|FATAL)\]' "$temp_log" | \
    sort | uniq -c | sort -nr
    
    echo "=== é”™è¯¯æ—¥å¿—è¯¦æƒ… ==="
    grep '\[ERROR\]' "$temp_log" | head -10
    
    echo "=== æœ€é¢‘ç¹çš„æ¶ˆæ¯ ==="
    grep -oE '\] [^[]*$' "$temp_log" | \
    sort | uniq -c | sort -nr | head -10
    
    rm -f "$temp_log"
}
```

---

## 7. âš™ï¸ é…ç½®æ–‡ä»¶åˆ†ç¦»æ¨¡å¼


### 7.1 é…ç½®æ–‡ä»¶è®¾è®¡åŸåˆ™


**ğŸ“‹ é…ç½®ä¸ä»£ç åˆ†ç¦»çš„ä»·å€¼**

```
é…ç½®åˆ†ç¦»çš„æ ¸å¿ƒä¼˜åŠ¿ï¼š

1. ç¯å¢ƒé€‚åº”æ€§
   åŒä¸€ä»½ä»£ç é€‚é…ä¸åŒç¯å¢ƒ
   å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒé…ç½®ç‹¬ç«‹
   
2. å®‰å…¨æ€§æå‡
   æ•æ„Ÿä¿¡æ¯ä¸å†™å…¥ä»£ç 
   é…ç½®æ–‡ä»¶å¯ä»¥è®¾ç½®ç‰¹æ®Šæƒé™
   
3. ç»´æŠ¤ä¾¿åˆ©æ€§
   é…ç½®ä¿®æ”¹ä¸éœ€è¦é‡æ–°éƒ¨ç½²
   æ”¯æŒè¿è¡Œæ—¶é…ç½®é‡è½½
   
4. ç‰ˆæœ¬ç®¡ç†
   é…ç½®å˜æ›´å¯ä»¥ç‹¬ç«‹è·Ÿè¸ª
   æ”¯æŒé…ç½®å›æ»šæ“ä½œ
```

### 7.2 å¤šæ ¼å¼é…ç½®æ–‡ä»¶æ”¯æŒ


**ğŸ”§ æ”¯æŒå¤šç§é…ç½®æ ¼å¼**

```bash
# é…ç½®æ–‡ä»¶è·¯å¾„å®šä¹‰
readonly CONFIG_DIR="/etc/automation"
readonly CONFIG_FILE="$CONFIG_DIR/$(basename "$0" .sh).conf"
readonly JSON_CONFIG="$CONFIG_DIR/$(basename "$0" .sh).json"
readonly YAML_CONFIG="$CONFIG_DIR/$(basename "$0" .sh).yaml"

# é»˜è®¤é…ç½®å€¼
declare -A DEFAULT_CONFIG=(
    ["log_level"]="INFO"
    ["log_dir"]="/var/log/automation"
    ["max_retries"]="3"
    ["timeout"]="300"
    ["backup_retention"]="30"
    ["notification_email"]="admin@example.com"
)

# Shellæ ¼å¼é…ç½®æ–‡ä»¶è¯»å–
load_shell_config() {
    local config_file=$1
    
    if [ -f "$config_file" ]; then
        log_info "åŠ è½½Shellé…ç½®æ–‡ä»¶: $config_file"
        
        # å®‰å…¨åœ°åŠ è½½é…ç½®æ–‡ä»¶
        while IFS='=' read -r key value; do
            # è·³è¿‡æ³¨é‡Šå’Œç©ºè¡Œ
            [[ $key =~ ^[[:space:]]*# ]] && continue
            [[ -z $key ]] && continue
            
            # ç§»é™¤å€¼çš„å¼•å·
            value=$(echo "$value" | sed 's/^["'\'']\(.*\)["'\'']$/\1/')
            
            # è®¾ç½®å˜é‡
            declare -g "$key=$value"
            log_debug "é…ç½®é¡¹: $key = $value"
        done < "$config_file"
        
        return 0
    else
        log_warn "é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: $config_file"
        return 1
    fi
}

# JSONæ ¼å¼é…ç½®æ–‡ä»¶è¯»å–
load_json_config() {
    local json_file=$1
    
    if [ -f "$json_file" ] && command -v jq >/dev/null; then
        log_info "åŠ è½½JSONé…ç½®æ–‡ä»¶: $json_file"
        
        # éªŒè¯JSONæ ¼å¼
        if ! jq empty "$json_file" 2>/dev/null; then
            log_error "JSONé…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯: $json_file"
            return 1
        fi
        
        # è¯»å–é…ç½®é¡¹
        while IFS='=' read -r key value; do
            declare -g "$key=$value"
            log_debug "JSONé…ç½®é¡¹: $key = $value"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$json_file")
        
        return 0
    else
        log_warn "JSONé…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–jqå‘½ä»¤ä¸å¯ç”¨: $json_file"
        return 1
    fi
}

# YAMLæ ¼å¼é…ç½®æ–‡ä»¶è¯»å–ï¼ˆéœ€è¦yqå·¥å…·ï¼‰
load_yaml_config() {
    local yaml_file=$1
    
    if [ -f "$yaml_file" ] && command -v yq >/dev/null; then
        log_info "åŠ è½½YAMLé…ç½®æ–‡ä»¶: $yaml_file"
        
        # è¯»å–YAMLé…ç½®
        while IFS='=' read -r key value; do
            declare -g "$key=$value"
            log_debug "YAMLé…ç½®é¡¹: $key = $value"
        done < <(yq eval 'to_entries | .[] | "\(.key)=\(.value)"' "$yaml_file")
        
        return 0
    else
        log_warn "YAMLé…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–yqå‘½ä»¤ä¸å¯ç”¨: $yaml_file"
        return 1
    fi
}
```

### 7.3 é…ç½®æ–‡ä»¶ä¼˜å…ˆçº§å’Œåˆå¹¶


**ğŸ¯ å¤šå±‚é…ç½®ç®¡ç†ç­–ç•¥**

```bash
# é…ç½®åŠ è½½ä¼˜å…ˆçº§ç®¡ç†
load_configuration() {
    log_info "å¼€å§‹åŠ è½½é…ç½®æ–‡ä»¶"
    
    # 1. åŠ è½½é»˜è®¤é…ç½®
    for key in "${!DEFAULT_CONFIG[@]}"; do
        declare -g "$key=${DEFAULT_CONFIG[$key]}"
        log_debug "é»˜è®¤é…ç½®: $key = ${DEFAULT_CONFIG[$key]}"
    done
    
    # 2. ç³»ç»Ÿçº§é…ç½®ï¼ˆä¼˜å…ˆçº§æœ€ä½ï¼‰
    load_shell_config "/etc/default/$(basename "$0" .sh)"
    
    # 3. ç”¨æˆ·çº§é…ç½®
    load_shell_config "$HOME/.$(basename "$0" .sh).conf"
    
    # 4. é¡¹ç›®çº§é…ç½®
    load_shell_config "$CONFIG_FILE"
    load_json_config "$JSON_CONFIG"
    load_yaml_config "$YAML_CONFIG"
    
    # 5. ç¯å¢ƒå˜é‡è¦†ç›–ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
    override_with_env_vars
    
    # 6. éªŒè¯é…ç½®
    validate_configuration
    
    log_info "é…ç½®åŠ è½½å®Œæˆ"
}

# ç¯å¢ƒå˜é‡è¦†ç›–é…ç½®
override_with_env_vars() {
    local prefix="AUTOMATION_"
    
    log_info "æ£€æŸ¥ç¯å¢ƒå˜é‡è¦†ç›–"
    
    # éå†æ‰€æœ‰ç¯å¢ƒå˜é‡
    while IFS='=' read -r name value; do
        if [[ $name =~ ^${prefix}(.+)$ ]]; then
            local config_key=$(echo "${BASH_REMATCH[1]}" | tr '[:upper:]' '[:lower:]')
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„é…ç½®é¡¹
            if [[ -v $config_key ]]; then
                declare -g "$config_key=$value"
                log_info "ç¯å¢ƒå˜é‡è¦†ç›–: $config_key = $value"
            fi
        fi
    done < <(env)
}

# é…ç½®éªŒè¯
validate_configuration() {
    log_info "éªŒè¯é…ç½®å‚æ•°"
    
    # æ•°å€¼å‹é…ç½®éªŒè¯
    local numeric_configs=("max_retries" "timeout" "backup_retention")
    for config in "${numeric_configs[@]}"; do
        if [[ -v $config ]]; then
            local value=${!config}
            if ! [[ $value =~ ^[0-9]+$ ]]; then
                log_error "é…ç½®é¡¹ $config å¿…é¡»æ˜¯æ•°å­—: $value"
                exit $EXIT_CONFIG_ERROR
            fi
        fi
    done
    
    # ç›®å½•é…ç½®éªŒè¯
    if [[ -v log_dir ]]; then
        if [ ! -d "$log_dir" ]; then
            log_warn "æ—¥å¿—ç›®å½•ä¸å­˜åœ¨ï¼Œå°è¯•åˆ›å»º: $log_dir"
            mkdir -p "$log_dir" || {
                log_error "æ— æ³•åˆ›å»ºæ—¥å¿—ç›®å½•: $log_dir"
                exit $EXIT_CONFIG_ERROR
            }
        fi
    fi
    
    # é‚®ä»¶åœ°å€æ ¼å¼éªŒè¯
    if [[ -v notification_email ]]; then
        if ! [[ $notification_email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
            log_error "é‚®ä»¶åœ°å€æ ¼å¼é”™è¯¯: $notification_email"
            exit $EXIT_CONFIG_ERROR
        fi
    fi
    
    log_success "é…ç½®éªŒè¯é€šè¿‡"
}

# é…ç½®æ–‡ä»¶æ¨¡æ¿ç”Ÿæˆ
generate_config_template() {
    local template_type=${1:-shell}
    local output_file=${2:-"$(basename "$0" .sh).conf.template"}
    
    case $template_type in
        shell)
            cat > "$output_file" << 'EOF'
# è‡ªåŠ¨åŒ–è„šæœ¬é…ç½®æ–‡ä»¶
# æ—¥å¿—é…ç½®
log_level=INFO
log_dir=/var/log/automation

# é‡è¯•å’Œè¶…æ—¶é…ç½®
max_retries=3
timeout=300

# å¤‡ä»½é…ç½®
backup_retention=30

# é€šçŸ¥é…ç½®
notification_email=admin@example.com

# è‡ªå®šä¹‰é…ç½®é¡¹
# custom_param=value
EOF
            ;;
        json)
            cat > "$output_file" << 'EOF'
{
  "log_level": "INFO",
  "log_dir": "/var/log/automation",
  "max_retries": 3,
  "timeout": 300,
  "backup_retention": 30,
  "notification_email": "admin@example.com"
}
EOF
            ;;
        yaml)
            cat > "$output_file" << 'EOF'
# è‡ªåŠ¨åŒ–è„šæœ¬é…ç½®
log_level: INFO
log_dir: /var/log/automation
max_retries: 3
timeout: 300
backup_retention: 30
notification_email: admin@example.com
EOF
            ;;
    esac
    
    log_info "ç”Ÿæˆé…ç½®æ–‡ä»¶æ¨¡æ¿: $output_file (æ ¼å¼: $template_type)"
}
```

---

## 8. ğŸŒ ç¯å¢ƒå˜é‡ç®¡ç†ç­–ç•¥


### 8.1 ç¯å¢ƒå˜é‡åˆ†ç±»å’Œå‘½å


**ğŸ“ æ ‡å‡†åŒ–ç¯å¢ƒå˜é‡ç®¡ç†**

```bash
# ç¯å¢ƒå˜é‡å‘½åè§„èŒƒ
readonly APP_PREFIX="AUTOMATION"
readonly ENV_FILE=".env"
readonly ENV_TEMPLATE=".env.template"

# ç¯å¢ƒå˜é‡åˆ†ç±»
declare -A ENV_CATEGORIES=(
    ["SYSTEM"]="ç³»ç»Ÿçº§é…ç½®"
    ["DATABASE"]="æ•°æ®åº“è¿æ¥"
    ["NETWORK"]="ç½‘ç»œé…ç½®"
    ["SECURITY"]="å®‰å…¨ç›¸å…³"
    ["MONITORING"]="ç›‘æ§é…ç½®"
    ["BUSINESS"]="ä¸šåŠ¡é…ç½®"
)

# ç¯å¢ƒå˜é‡å®šä¹‰å’Œé»˜è®¤å€¼
define_environment_variables() {
    # ç³»ç»Ÿé…ç½®
    export AUTOMATION_LOG_LEVEL=${AUTOMATION_LOG_LEVEL:-INFO}
    export AUTOMATION_LOG_DIR=${AUTOMATION_LOG_DIR:-/var/log/automation}
    export AUTOMATION_WORK_DIR=${AUTOMATION_WORK_DIR:-/tmp/automation}
    export AUTOMATION_CONFIG_DIR=${AUTOMATION_CONFIG_DIR:-/etc/automation}
    
    # ç½‘ç»œé…ç½®
    export AUTOMATION_HTTP_TIMEOUT=${AUTOMATION_HTTP_TIMEOUT:-30}
    export AUTOMATION_RETRY_ATTEMPTS=${AUTOMATION_RETRY_ATTEMPTS:-3}
    export AUTOMATION_RETRY_DELAY=${AUTOMATION_RETRY_DELAY:-5}
    
    # æ•°æ®åº“é…ç½®ï¼ˆæ•æ„Ÿä¿¡æ¯ï¼‰
    export AUTOMATION_DB_HOST=${AUTOMATION_DB_HOST:-localhost}
    export AUTOMATION_DB_PORT=${AUTOMATION_DB_PORT:-3306}
    export AUTOMATION_DB_NAME=${AUTOMATION_DB_NAME:-automation}
    # å¯†ç ç­‰æ•æ„Ÿä¿¡æ¯ä¸è®¾é»˜è®¤å€¼
    
    # å®‰å…¨é…ç½®
    export AUTOMATION_ENCRYPT_DATA=${AUTOMATION_ENCRYPT_DATA:-true}
    export AUTOMATION_SSL_VERIFY=${AUTOMATION_SSL_VERIFY:-true}
    
    # ç›‘æ§é…ç½®
    export AUTOMATION_MONITORING_ENABLED=${AUTOMATION_MONITORING_ENABLED:-true}
    export AUTOMATION_METRICS_PORT=${AUTOMATION_METRICS_PORT:-9090}
    
    log_info "ç¯å¢ƒå˜é‡åˆå§‹åŒ–å®Œæˆ"
}

# ç¯å¢ƒå˜é‡éªŒè¯
validate_environment_variables() {
    local validation_errors=()
    
    # å¿…éœ€çš„ç¯å¢ƒå˜é‡æ£€æŸ¥
    local required_vars=(
        "AUTOMATION_LOG_DIR"
        "AUTOMATION_CONFIG_DIR"
    )
    
    for var in "${required_vars[@]}"; do
        if [ -z "${!var:-}" ]; then
            validation_errors+=("å¿…éœ€çš„ç¯å¢ƒå˜é‡æœªè®¾ç½®: $var")
        fi
    done
    
    # æ•°å€¼å‹å˜é‡éªŒè¯
    local numeric_vars=(
        "AUTOMATION_HTTP_TIMEOUT"
        "AUTOMATION_RETRY_ATTEMPTS"
        "AUTOMATION_DB_PORT"
        "AUTOMATION_METRICS_PORT"
    )
    
    for var in "${numeric_vars[@]}"; do
        local value="${!var:-}"
        if [ -n "$value" ] && ! [[ $value =~ ^[0-9]+$ ]]; then
            validation_errors+=("ç¯å¢ƒå˜é‡ $var å¿…é¡»æ˜¯æ•°å­—: $value")
        fi
    done
    
    # å¸ƒå°”å‹å˜é‡éªŒè¯
    local boolean_vars=(
        "AUTOMATION_ENCRYPT_DATA"
        "AUTOMATION_SSL_VERIFY"
        "AUTOMATION_MONITORING_ENABLED"
    )
    
    for var in "${boolean_vars[@]}"; do
        local value="${!var:-}"
        if [ -n "$value" ] && ! [[ $value =~ ^(true|false|yes|no|1|0)$ ]]; then
            validation_errors+=("ç¯å¢ƒå˜é‡ $var å¿…é¡»æ˜¯å¸ƒå°”å€¼: $value")
        fi
    done
    
    # ç›®å½•å­˜åœ¨æ€§éªŒè¯
    local directory_vars=(
        "AUTOMATION_LOG_DIR"
        "AUTOMATION_WORK_DIR"
        "AUTOMATION_CONFIG_DIR"
    )
    
    for var in "${directory_vars[@]}"; do
        local dir="${!var:-}"
        if [ -n "$dir" ] && [ ! -d "$dir" ]; then
            log_warn "ç›®å½•ä¸å­˜åœ¨ï¼Œå°è¯•åˆ›å»º: $dir"
            mkdir -p "$dir" || validation_errors+=("æ— æ³•åˆ›å»ºç›®å½• $var: $dir")
        fi
    done
    
    # è¾“å‡ºéªŒè¯ç»“æœ
    if [ ${#validation_errors[@]} -gt 0 ]; then
        log_error "ç¯å¢ƒå˜é‡éªŒè¯å¤±è´¥:"
        for error in "${validation_errors[@]}"; do
            log_error "  $error"
        done
        exit $EXIT_CONFIG_ERROR
    else
        log_success "ç¯å¢ƒå˜é‡éªŒè¯é€šè¿‡"
    fi
}
```

### 8.2 ç¯å¢ƒå˜é‡æ–‡ä»¶ç®¡ç†


**ğŸ“ .envæ–‡ä»¶æ ‡å‡†åŒ–ç®¡ç†**

```bash
# .envæ–‡ä»¶åŠ è½½å‡½æ•°
load_env_file() {
    local env_file=${1:-$ENV_FILE}
    local env_scope=${2:-local}  # local, global, system
    
    if [ ! -f "$env_file" ]; then
        log_warn "ç¯å¢ƒå˜é‡æ–‡ä»¶ä¸å­˜åœ¨: $env_file"
        return 1
    fi
    
    log_info "åŠ è½½ç¯å¢ƒå˜é‡æ–‡ä»¶: $env_file (ä½œç”¨åŸŸ: $env_scope)"
    
    # é€è¡Œå¤„ç†ç¯å¢ƒå˜é‡
    while IFS= read -r line || [ -n "$line" ]; do
        # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
        [[ $line =~ ^[[:space:]]*$ ]] && continue
        [[ $line =~ ^[[:space:]]*# ]] && continue
        
        # è§£æé”®å€¼å¯¹
        if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            
            # ç§»é™¤é”®å’Œå€¼çš„å‰åç©ºæ ¼
            key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # å¤„ç†å¼•å·
            if [[ $value =~ ^\"(.*)\"$ ]] || [[ $value =~ ^\'(.*)\'$ ]]; then
                value="${BASH_REMATCH[1]}"
            fi
            
            # æ ¹æ®ä½œç”¨åŸŸè®¾ç½®å˜é‡
            case $env_scope in
                global)
                    export "$key=$value"
                    ;;
                local|*)
                    declare "$key=$value"
                    ;;
            esac
            
            log_debug "ç¯å¢ƒå˜é‡: $key = [å·²è®¾ç½®]"
        else
            log_warn "è·³è¿‡æ— æ•ˆçš„ç¯å¢ƒå˜é‡è¡Œ: $line"
        fi
    done < "$env_file"
    
    return 0
}

# ç”Ÿæˆ.envæ¨¡æ¿æ–‡ä»¶
generate_env_template() {
    local template_file=${1:-$ENV_TEMPLATE}
    
    cat > "$template_file" << 'EOF'
# ================================
# è‡ªåŠ¨åŒ–è„šæœ¬ç¯å¢ƒå˜é‡é…ç½®æ¨¡æ¿
# ================================

# ç³»ç»Ÿé…ç½®
AUTOMATION_LOG_LEVEL=INFO
AUTOMATION_LOG_DIR=/var/log/automation
AUTOMATION_WORK_DIR=/tmp/automation
AUTOMATION_CONFIG_DIR=/etc/automation

# ç½‘ç»œé…ç½®
AUTOMATION_HTTP_TIMEOUT=30
AUTOMATION_RETRY_ATTEMPTS=3
AUTOMATION_RETRY_DELAY=5

# æ•°æ®åº“é…ç½®ï¼ˆè¯·æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹ï¼‰
AUTOMATION_DB_HOST=localhost
AUTOMATION_DB_PORT=3306
AUTOMATION_DB_NAME=automation
AUTOMATION_DB_USER=automation_user
AUTOMATION_DB_PASSWORD=your_password_here

# å®‰å…¨é…ç½®
AUTOMATION_ENCRYPT_DATA=true
AUTOMATION_SSL_VERIFY=true

# ç›‘æ§é…ç½®
AUTOMATION_MONITORING_ENABLED=true
AUTOMATION_METRICS_PORT=9090

# é‚®ä»¶é€šçŸ¥é…ç½®
AUTOMATION_SMTP_SERVER=smtp.example.com
AUTOMATION_SMTP_PORT=587
AUTOMATION_SMTP_USER=notifications@example.com
AUTOMATION_SMTP_PASSWORD=smtp_password_here
AUTOMATION_FROM_EMAIL=automation@example.com
AUTOMATION_TO_EMAIL=admin@example.com

# å¤‡ä»½é…ç½®
AUTOMATION_BACKUP_DIR=/backup
AUTOMATION_BACKUP_RETENTION_DAYS=30
AUTOMATION_BACKUP_COMPRESS=true

# è°ƒè¯•é…ç½®
AUTOMATION_DEBUG=false
AUTOMATION_TRACE=false
EOF

    log_info "ç”Ÿæˆç¯å¢ƒå˜é‡æ¨¡æ¿æ–‡ä»¶: $template_file"
    log_info "è¯·å¤åˆ¶ä¸º $ENV_FILE å¹¶æ ¹æ®å®é™…ç¯å¢ƒä¿®æ”¹é…ç½®"
}

# æ•æ„Ÿä¿¡æ¯å¤„ç†
handle_sensitive_env_vars() {
    local sensitive_vars=(
        "PASSWORD"
        "SECRET"
        "TOKEN"
        "KEY"
        "PRIVATE"
    )
    
    log_info "å¤„ç†æ•æ„Ÿç¯å¢ƒå˜é‡"
    
    # æ£€æŸ¥æ˜¯å¦æœ‰æ•æ„Ÿä¿¡æ¯æœªåŠ å¯†
    while IFS='=' read -r name value; do
        for sensitive_pattern in "${sensitive_vars[@]}"; do
            if [[ $name =~ $sensitive_pattern ]]; then
                # æ£€æŸ¥å€¼æ˜¯å¦çœ‹èµ·æ¥åƒæ˜æ–‡å¯†ç 
                if [ ${#value} -lt 50 ] && [[ ! $value =~ ^[A-Za-z0-9+/]+=*$ ]]; then
                    log_warn "æ£€æµ‹åˆ°å¯èƒ½çš„æ˜æ–‡æ•æ„Ÿä¿¡æ¯: $name"
                    log_warn "å»ºè®®ä½¿ç”¨åŠ å¯†æˆ–å¤–éƒ¨å¯†é’¥ç®¡ç†ç³»ç»Ÿ"
                fi
                
                # åœ¨æ—¥å¿—ä¸­éšè—æ•æ„Ÿå€¼
                log_debug "æ•æ„Ÿç¯å¢ƒå˜é‡: $name = [å·²éšè—]"
                break
            fi
        done
    done < <(env | grep "^AUTOMATION_")
}
```

### 8.3 å¤šç¯å¢ƒå˜é‡ç®¡ç†


**ğŸŒ ç¯å¢ƒç‰¹å®šçš„å˜é‡ç®¡ç†ç­–ç•¥**

```bash
# ç¯å¢ƒæ£€æµ‹å’Œå˜é‡åŠ è½½
detect_and_load_environment() {
    local environment=""
    
    # ç¯å¢ƒæ£€æµ‹é€»è¾‘
    if [ -n "${AUTOMATION_ENVIRONMENT:-}" ]; then
        environment="$AUTOMATION_ENVIRONMENT"
    elif [ -n "${NODE_ENV:-}" ]; then
        environment="$NODE_ENV"
    elif [ -n "${RAILS_ENV:-}" ]; then
        environment="$RAILS_ENV"
    elif [ -f "/.dockerenv" ]; then
        environment="docker"
    elif [ "$USER" = "root" ] && [ -d "/var/log" ]; then
        environment="production"
    else
        environment="development"
    fi
    
    export AUTOMATION_ENVIRONMENT="$environment"
    log_info "æ£€æµ‹åˆ°è¿è¡Œç¯å¢ƒ: $environment"
    
    # åŠ è½½ç¯å¢ƒç‰¹å®šçš„é…ç½®æ–‡ä»¶
    local env_files=(
        ".env"
        ".env.$environment"
        ".env.local"
        "/etc/automation/.env"
        "/etc/automation/.env.$environment"
    )
    
    for env_file in "${env_files[@]}"; do
        if [ -f "$env_file" ]; then
            load_env_file "$env_file" "global"
        fi
    done
}

# ç¯å¢ƒå˜é‡å¯¼å‡ºå’Œå¯¼å…¥
export_environment_config() {
    local output_file=${1:-"automation_env_$(date +%Y%m%d_%H%M%S).env"}
    local include_sensitive=${2:-false}
    
    log_info "å¯¼å‡ºç¯å¢ƒå˜é‡é…ç½®åˆ°: $output_file"
    
    {
        echo "# è‡ªåŠ¨åŒ–è„šæœ¬ç¯å¢ƒå˜é‡å¯¼å‡º"
        echo "# å¯¼å‡ºæ—¶é—´: $(date)"
        echo "# å¯¼å‡ºç¯å¢ƒ: $AUTOMATION_ENVIRONMENT"
        echo ""
        
        while IFS='=' read -r name value; do
            # è¿‡æ»¤æ•æ„Ÿä¿¡æ¯
            if [ "$include_sensitive" = "false" ]; then
                local is_sensitive=false
                for pattern in "PASSWORD" "SECRET" "TOKEN" "KEY" "PRIVATE"; do
                    if [[ $name =~ $pattern ]]; then
                        echo "# $name=[å·²éšè—æ•æ„Ÿä¿¡æ¯]"
                        is_sensitive=true
                        break
                    fi
                done
                
                if [ "$is_sensitive" = "false" ]; then
                    echo "$name=$value"
                fi
            else
                echo "$name=$value"
            fi
        done < <(env | grep "^AUTOMATION_" | sort)
        
    } > "$output_file"
    
    chmod 600 "$output_file"  # é™åˆ¶æ–‡ä»¶æƒé™
    log_success "ç¯å¢ƒå˜é‡é…ç½®å¯¼å‡ºå®Œæˆ"
}

# ç¯å¢ƒå˜é‡è¿è¡Œæ—¶ä¿®æ”¹
runtime_env_management() {
    local action=$1
    local var_name=$2
    local var_value=$3
    
    case $action in
        set)
            if [ -n "$var_name" ] && [ -n "$var_value" ]; then
                export "$var_name=$var_value"
                log_info "è¿è¡Œæ—¶è®¾ç½®ç¯å¢ƒå˜é‡: $var_name"
                
                # å¯é€‰ï¼šæŒä¹…åŒ–åˆ°é…ç½®æ–‡ä»¶
                if [ "${PERSIST_RUNTIME_CHANGES:-false}" = "true" ]; then
                    echo "$var_name=$var_value" >> "$ENV_FILE"
                    log_info "ç¯å¢ƒå˜é‡å·²æŒä¹…åŒ–åˆ° $ENV_FILE"
                fi
            fi
            ;;
        get)
            if [ -n "$var_name" ]; then
                local value="${!var_name:-}"
                if [ -n "$value" ]; then
                    echo "$var_name=$value"
                else
                    log_warn "ç¯å¢ƒå˜é‡æœªè®¾ç½®: $var_name"
                    return 1
                fi
            fi
            ;;
        unset)
            if [ -n "$var_name" ]; then
                unset "$var_name"
                log_info "è¿è¡Œæ—¶å–æ¶ˆè®¾ç½®ç¯å¢ƒå˜é‡: $var_name"
            fi
            ;;
        list)
            echo "=== è‡ªåŠ¨åŒ–è„šæœ¬ç¯å¢ƒå˜é‡ ==="
            env | grep "^AUTOMATION_" | sort
            ;;
        *)
            log_error "æœªçŸ¥çš„ç¯å¢ƒå˜é‡ç®¡ç†æ“ä½œ: $action"
            log_info "æ”¯æŒçš„æ“ä½œ: set, get, unset, list"
            return 1
            ;;
    esac
}
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ å¹‚ç­‰æ€§è®¾è®¡ï¼šç¡®ä¿è„šæœ¬å¤šæ¬¡è¿è¡Œç»“æœä¸€è‡´ï¼Œé¿å…å‰¯ä½œç”¨
ğŸ”¸ é”æ–‡ä»¶æœºåˆ¶ï¼šé˜²æ­¢å¹¶å‘æ‰§è¡Œå†²çªï¼Œä¿è¯èµ„æºå®‰å…¨è®¿é—®
ğŸ”¸ é€€å‡ºçŠ¶æ€ç ï¼šæ ‡å‡†åŒ–é”™è¯¯å¤„ç†ï¼Œä¾¿äºç›‘æ§å’Œè°ƒè¯•
ğŸ”¸ é”™è¯¯å¤„ç†ï¼šåˆ†å±‚å¤„ç†ç­–ç•¥ï¼Œæ”¯æŒé‡è¯•å’Œä¼˜é›…é™çº§
ğŸ”¸ è¶…æ—¶æ§åˆ¶ï¼šé˜²æ­¢èµ„æºæ³„éœ²ï¼Œç¡®ä¿è„šæœ¬æŒ‰æ—¶å®Œæˆ
ğŸ”¸ æ—¥å¿—æ ‡å‡†åŒ–ï¼šç»“æ„åŒ–è®°å½•ï¼Œæ”¯æŒé—®é¢˜è¿½è¸ªå’Œå®¡è®¡
ğŸ”¸ é…ç½®åˆ†ç¦»ï¼šä»£ç ä¸é…ç½®åˆ†ç¦»ï¼Œæ”¯æŒå¤šç¯å¢ƒéƒ¨ç½²
ğŸ”¸ ç¯å¢ƒå˜é‡ï¼šç»Ÿä¸€ç®¡ç†è¿è¡Œæ—¶å‚æ•°å’Œæ•æ„Ÿä¿¡æ¯
```

### 9.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ å¹‚ç­‰æ€§çš„å®ç°åŸç†**
```
è®¾è®¡æ ¸å¿ƒï¼š
- æ£€æŸ¥å½“å‰çŠ¶æ€æ˜¯å¦å·²è¾¾åˆ°ç›®æ ‡
- åªåœ¨å¿…è¦æ—¶æ‰§è¡Œå˜æ›´æ“ä½œ
- éªŒè¯æ“ä½œç»“æœç¡®ä¿æ­£ç¡®æ€§

å®é™…ä»·å€¼ï¼š
- æ”¯æŒè‡ªåŠ¨åŒ–ä»»åŠ¡çš„é‡å¤æ‰§è¡Œ
- é™ä½äººä¸ºæ“ä½œé”™è¯¯çš„é£é™©
- ç®€åŒ–æ•…éšœæ¢å¤å’Œè¿ç»´æµç¨‹
```

**ğŸ”¹ é”™è¯¯å¤„ç†çš„åˆ†å±‚ç­–ç•¥**
```
å¤„ç†å±‚æ¬¡ï¼š
- ç³»ç»Ÿçº§é”™è¯¯ï¼šèµ„æºä¸è¶³ã€æƒé™é—®é¢˜
- ç½‘ç»œçº§é”™è¯¯ï¼šè¿æ¥è¶…æ—¶ã€æœåŠ¡ä¸å¯ç”¨  
- ä¸šåŠ¡çº§é”™è¯¯ï¼šæ•°æ®éªŒè¯ã€é€»è¾‘å†²çª
- é…ç½®çº§é”™è¯¯ï¼šå‚æ•°é”™è¯¯ã€ç¯å¢ƒé—®é¢˜

ç­–ç•¥é€‰æ‹©ï¼š
- å¯æ¢å¤é”™è¯¯ï¼šè‡ªåŠ¨é‡è¯•ã€é™çº§å¤„ç†
- ä¸¥é‡é”™è¯¯ï¼šç«‹å³åœæ­¢ã€å‘é€å‘Šè­¦
- é…ç½®é”™è¯¯ï¼šå‚æ•°éªŒè¯ã€å‹å¥½æç¤º
```

**ğŸ”¹ é…ç½®ç®¡ç†çš„æœ€ä½³å®è·µ**
```
åˆ†ç¦»åŸåˆ™ï¼š
- ä»£ç ä¸é…ç½®å®Œå…¨åˆ†ç¦»
- æ”¯æŒå¤šç§é…ç½®æ ¼å¼
- ç¯å¢ƒç‰¹å®šçš„é…ç½®è¦†ç›–

å®‰å…¨è€ƒè™‘ï¼š
- æ•æ„Ÿä¿¡æ¯åŠ å¯†å­˜å‚¨
- é…ç½®æ–‡ä»¶æƒé™æ§åˆ¶
- ç¯å¢ƒå˜é‡å®‰å…¨å¤„ç†

ç»´æŠ¤ä¾¿åˆ©ï¼š
- é…ç½®æ¨¡æ¿è‡ªåŠ¨ç”Ÿæˆ
- è¿è¡Œæ—¶é…ç½®éªŒè¯
- é…ç½®å˜æ›´å¯è¿½æº¯
```

### 9.3 å®é™…åº”ç”¨ä»·å€¼


**ğŸ¯ ç”Ÿäº§ç¯å¢ƒåº”ç”¨åœºæ™¯**
- **æ•°æ®å¤‡ä»½**ï¼šå¹‚ç­‰æ€§ç¡®ä¿å¤‡ä»½ä»»åŠ¡å¯ä»¥å®‰å…¨é‡å¤æ‰§è¡Œ
- **æœåŠ¡éƒ¨ç½²**ï¼šé”æ–‡ä»¶é˜²æ­¢å¹¶å‘éƒ¨ç½²å¯¼è‡´çš„å†²çª
- **ç³»ç»Ÿç›‘æ§**ï¼šæ ‡å‡†åŒ–æ—¥å¿—ä¾¿äºæ•…éšœå®šä½å’Œæ€§èƒ½åˆ†æ
- **æ‰¹é‡å¤„ç†**ï¼šé”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶ä¿è¯æ•°æ®å¤„ç†å®Œæ•´æ€§

**ğŸ”§ è¿ç»´æ•ˆç‡æå‡**
- **æ ‡å‡†åŒ–æµç¨‹**ï¼šç»Ÿä¸€çš„è„šæœ¬è®¾è®¡æ¨¡å¼é™ä½ç»´æŠ¤æˆæœ¬
- **è‡ªåŠ¨åŒ–ç¨‹åº¦**ï¼šå‡å°‘äººå·¥å¹²é¢„ï¼Œæé«˜è¿ç»´æ•ˆç‡
- **æ•…éšœæ¢å¤**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†æ”¯æŒå¿«é€Ÿé—®é¢˜å®šä½
- **ç¯å¢ƒä¸€è‡´æ€§**ï¼šé…ç½®ç®¡ç†ç¡®ä¿å„ç¯å¢ƒçš„ä¸€è‡´æ€§

**ğŸ“ˆ æŠ€æœ¯å‘å±•è¶‹åŠ¿**
- **äº‘åŸç”Ÿé€‚é…**ï¼šé€‚åº”å®¹å™¨åŒ–å’Œå¾®æœåŠ¡æ¶æ„
- **æ™ºèƒ½åŒ–è¿ç»´**ï¼šç»“åˆAIè¿›è¡Œæ•…éšœé¢„æµ‹å’Œè‡ªåŠ¨ä¿®å¤
- **å®‰å…¨æ€§å¢å¼º**ï¼šæ›´ä¸¥æ ¼çš„æƒé™æ§åˆ¶å’Œæ•æ„Ÿä¿¡æ¯ä¿æŠ¤
- **å¯è§‚æµ‹æ€§**ï¼šæ›´ä¸°å¯Œçš„ç›‘æ§æŒ‡æ ‡å’Œé“¾è·¯è¿½è¸ª

**æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
- å¹‚ç­‰è®¾è®¡ä¿å®‰å…¨ï¼Œé”æ–‡ä»¶é˜²å†²çª
- çŠ¶æ€ç è¦è§„èŒƒï¼Œé”™è¯¯å¤„ç†åˆ†å±‚çº§
- è¶…æ—¶æ§åˆ¶é˜²æ³„éœ²ï¼Œæ—¥å¿—è®°å½•è¦æ ‡å‡†
- é…ç½®åˆ†ç¦»æ˜“ç»´æŠ¤ï¼Œç¯å¢ƒå˜é‡ç»Ÿä¸€ç®¡