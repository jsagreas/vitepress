---
title: 6、条件判断与测试表达式
---
## 📚 目录

1. [条件判断基础概念](#1-条件判断基础概念)
2. [test命令与基础语法](#2-test命令与基础语法)
3. [文件测试操作符详解](#3-文件测试操作符详解)
4. [数值比较操作符](#4-数值比较操作符)
5. [字符串测试与匹配](#5-字符串测试与匹配)
6. [逻辑操作符与组合](#6-逻辑操作符与组合)
7. [扩展条件判断[[ ]]语法](#7-扩展条件判断语法)
8. [实战应用与最佳实践](#8-实战应用与最佳实践)
9. [常见陷阱与避坑指南](#9-常见陷阱与避坑指南)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 条件判断基础概念


### 1.1 什么是条件判断


**🔸 简单理解**
条件判断就像生活中的"如果...那么..."逻辑。比如：
- 如果天下雨，那么带伞出门
- 如果文件存在，那么读取文件内容
- 如果用户是管理员，那么允许执行操作

**🔸 在Shell中的作用**
条件判断是Shell脚本中的"决策大脑"，根据不同情况执行不同的操作，让脚本具备智能判断能力。

### 1.2 条件判断的本质


```
条件判断的核心逻辑：
输入条件 → 测试评估 → 返回结果 → 执行动作

测试结果只有两种：
✅ 真（True） → 退出状态码 0
❌ 假（False）→ 退出状态码 非0
```

**🔸 退出状态码概念**
- **成功/真**：命令执行成功，返回0
- **失败/假**：命令执行失败，返回1-255

🧠 **记忆技巧**：数字越小越好，0是最好的（成功）

### 1.3 条件判断的应用场景


| 场景类型 | **实际用途** | **举例说明** |
|---------|------------|-------------|
| 🔸 **文件操作** | `检查文件是否存在` | `备份前检查目标目录` |
| 🔸 **用户验证** | `检查用户权限` | `管理员权限验证` |
| 🔸 **系统监控** | `检查系统状态` | `内存使用率告警` |
| 🔸 **参数校验** | `验证输入参数` | `检查参数数量和格式` |

---

## 2. ⚙️ test命令与基础语法


### 2.1 test命令基本概念


**🔸 test命令的作用**
`test`命令是Shell中专门用来进行条件测试的工具，它像一个"法官"，对给定的条件进行裁决。

**🔸 基本使用方式**
```bash
# 方式1：使用test命令
test 条件表达式

# 方式2：使用方括号（更常用）
[ 条件表达式 ]

# 方式3：扩展语法（后面详讲）
[[ 条件表达式 ]]
```

### 2.2 test命令语法规则


**🔸 基础语法结构**
```bash
# 标准格式
[ 操作数1 操作符 操作数2 ]

# 注意事项：
# 1. 方括号前后必须有空格
# 2. 操作符前后也要有空格
# 3. 字符串最好用引号包围
```

**🔸 语法示例对比**

```bash
# ✅ 正确写法
[ $num -eq 10 ]
[ "$str" = "hello" ]
[ -f "/etc/passwd" ]

# ❌ 错误写法
[$num -eq 10]        # 缺少空格
[ $num-eq 10 ]       # 操作符缺少空格
[ $str = hello]      # 字符串未加引号（可能出问题）
```

### 2.3 test命令返回值测试


**🔸 如何查看测试结果**
```bash
# 执行测试后查看结果
[ 5 -eq 5 ]
echo $?    # 输出：0（真）

[ 5 -eq 3 ]
echo $?    # 输出：1（假）
```

**🔸 实际应用示例**
```bash
# 检查文件是否存在
if [ -f "/etc/passwd" ]; then
    echo "密码文件存在"
else
    echo "密码文件不存在"
fi
```

---

## 3. 📁 文件测试操作符详解


### 3.1 文件存在性测试


**🔸 常用文件测试操作符**

| 操作符 | **含义说明** | **使用场景** | **记忆技巧** |
|--------|------------|-------------|-------------|
| **-e** | `文件是否存在` | `通用存在检查` | `exist存在` |
| **-f** | `是否为普通文件` | `检查配置文件` | `file文件` |
| **-d** | `是否为目录` | `检查目录路径` | `directory目录` |
| **-L** | `是否为符号链接` | `检查软链接` | `Link链接` |

**🔸 基础使用示例**
```bash
# 检查文件存在
if [ -e "/etc/passwd" ]; then
    echo "文件存在"
fi

# 检查是否为普通文件
if [ -f "/etc/passwd" ]; then
    echo "这是一个普通文件"
fi

# 检查是否为目录
if [ -d "/home/user" ]; then
    echo "这是一个目录"
fi
```

### 3.2 文件权限测试


**🔸 权限测试操作符**

| 操作符 | **权限含义** | **实际用途** |
|--------|------------|-------------|
| **-r** | `可读权限` | `检查能否读取文件` |
| **-w** | `可写权限` | `检查能否修改文件` |
| **-x** | `可执行权限` | `检查能否执行脚本` |

```bash
# 检查文件权限
file="/etc/passwd"

if [ -r "$file" ]; then
    echo "文件可读"
fi

if [ -w "$file" ]; then
    echo "文件可写"
else
    echo "文件只读"
fi

if [ -x "/usr/bin/ls" ]; then
    echo "ls命令可执行"
fi
```

### 3.3 文件大小与时间测试


**🔸 文件状态测试**

| 操作符 | **测试内容** | **返回真的条件** |
|--------|------------|---------------|
| **-s** | `文件大小` | `文件非空（大小>0）` |
| **-z** | `文件为空` | `文件大小为0` |
| **-nt** | `文件时间比较` | `文件1比文件2新` |
| **-ot** | `文件时间比较` | `文件1比文件2旧` |

```bash
# 检查日志文件是否有内容
if [ -s "/var/log/app.log" ]; then
    echo "日志文件有内容"
else
    echo "日志文件为空"
fi

# 比较文件时间
if [ "file1.txt" -nt "file2.txt" ]; then
    echo "file1比file2新"
fi
```

### 3.4 实际应用场景


**🔸 备份脚本中的文件检查**
```bash
#!/bin/bash
backup_dir="/backup"
source_dir="/data"

# 检查源目录是否存在
if [ ! -d "$source_dir" ]; then
    echo "错误：源目录不存在"
    exit 1
fi

# 检查备份目录，不存在则创建
if [ ! -d "$backup_dir" ]; then
    echo "创建备份目录：$backup_dir"
    mkdir -p "$backup_dir"
fi

# 检查是否有写权限
if [ ! -w "$backup_dir" ]; then
    echo "错误：备份目录无写权限"
    exit 1
fi

echo "开始备份..."
```

---

## 4. 🔢 数值比较操作符


### 4.1 数值比较操作符详解


**🔸 核心数值比较操作符**

| 操作符 | **含义** | **英文全称** | **记忆技巧** | **示例** |
|--------|---------|-------------|-------------|---------|
| **-eq** | `等于` | `equal` | `相等` | `[ $a -eq $b ]` |
| **-ne** | `不等于` | `not equal` | `不相等` | `[ $a -ne $b ]` |
| **-gt** | `大于` | `greater than` | `更大than` | `[ $a -gt $b ]` |
| **-lt** | `小于` | `less than` | `更少than` | `[ $a -lt $b ]` |
| **-ge** | `大于等于` | `greater equal` | `更大或相等` | `[ $a -ge $b ]` |
| **-le** | `小于等于` | `less equal` | `更少或相等` | `[ $a -le $b ]` |

### 4.2 数值比较基础示例


```bash
#!/bin/bash
num1=10
num2=20

# 基础比较
if [ $num1 -eq 10 ]; then
    echo "num1等于10"
fi

if [ $num1 -lt $num2 ]; then
    echo "num1小于num2"
fi

if [ $num1 -ne $num2 ]; then
    echo "num1不等于num2"
fi
```

### 4.3 实际应用场景


**🔸 系统监控脚本**
```bash
#!/bin/bash
# 检查磁盘使用率
disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')

if [ $disk_usage -ge 90 ]; then
    echo "警告：磁盘使用率已达${disk_usage}%"
    # 发送告警邮件
elif [ $disk_usage -ge 80 ]; then
    echo "注意：磁盘使用率为${disk_usage}%"
else
    echo "磁盘使用正常：${disk_usage}%"
fi
```

**🔸 参数数量检查**
```bash
#!/bin/bash
# 检查脚本参数数量
if [ $# -lt 2 ]; then
    echo "错误：参数不足，需要至少2个参数"
    echo "用法: $0 <参数1> <参数2>"
    exit 1
fi

if [ $# -gt 5 ]; then
    echo "警告：参数过多，只处理前5个"
fi
```

### 4.4 数值比较注意事项


> ⚠️ **重要提醒**  
> - 数值比较操作符只能用于**整数比较**
> - 如果变量包含非数字字符，比较结果可能不准确
> - 浮点数比较需要使用其他方法（如bc命令）

```bash
# ❌ 不推荐：可能有问题的写法
price="19.99"
if [ $price -gt 20 ]; then
    echo "价格超过20"
fi

# ✅ 推荐：处理浮点数比较
if [ $(echo "$price > 20" | bc) -eq 1 ]; then
    echo "价格超过20"
fi
```

---

## 5. 📝 字符串测试与匹配


### 5.1 字符串基础测试操作符


**🔸 字符串测试核心操作符**

| 操作符 | **测试内容** | **返回真的条件** | **使用场景** |
|--------|------------|---------------|-------------|
| **=** 或 **==** | `字符串相等` | `两个字符串完全相同` | `密码验证、选项判断` |
| **!=** | `字符串不等` | `两个字符串不相同` | `排除特定值` |
| **-z** | `字符串长度` | `字符串为空（长度为0）` | `检查必需参数` |
| **-n** | `字符串长度` | `字符串非空（长度>0）` | `验证输入存在` |

### 5.2 字符串测试基础示例


```bash
#!/bin/bash
username="admin"
password=""

# 字符串相等性测试
if [ "$username" = "admin" ]; then
    echo "管理员用户"
fi

# 字符串不等测试
if [ "$username" != "guest" ]; then
    echo "非访客用户"
fi

# 检查字符串是否为空
if [ -z "$password" ]; then
    echo "密码为空，请输入密码"
fi

# 检查字符串非空
if [ -n "$username" ]; then
    echo "用户名已设置：$username"
fi
```

### 5.3 字符串比较陷阱与最佳实践


**🔸 常见问题及解决方案**

```bash
# ❌ 危险写法：变量未加引号
name=""
if [ $name = "admin" ]; then  # 当name为空时会出错
    echo "管理员"
fi

# ✅ 安全写法：变量加引号
if [ "$name" = "admin" ]; then
    echo "管理员"
fi

# ✅ 更安全的写法：使用-z测试
if [ -n "$name" ] && [ "$name" = "admin" ]; then
    echo "管理员"
fi
```

### 5.4 实际应用示例


**🔸 用户输入验证脚本**
```bash
#!/bin/bash
echo "请输入用户类型（admin/user/guest）："
read user_type

# 参数校验
if [ -z "$user_type" ]; then
    echo "错误：用户类型不能为空"
    exit 1
fi

# 类型判断
case "$user_type" in
    "admin")
        echo "管理员权限：可以执行所有操作"
        ;;
    "user")
        echo "普通用户权限：可以执行基本操作"
        ;;
    "guest")
        echo "访客权限：只能查看信息"
        ;;
    *)
        echo "错误：无效的用户类型"
        exit 1
        ;;
esac
```

---

## 6. 🔗 逻辑操作符与组合


### 6.1 基础逻辑操作符


**🔸 三种核心逻辑操作符**

| 操作符 | **逻辑含义** | **Shell写法** | **生活类比** |
|--------|------------|-------------|-------------|
| **&&** | `逻辑与（AND）` | `条件1 && 条件2` | `既要...又要...` |
| **\|\|** | `逻辑或（OR）` | `条件1 \|\| 条件2` | `要么...要么...` |
| **!** | `逻辑非（NOT）` | `! 条件` | `不是...` |

### 6.2 逻辑操作符真值表


```
逻辑与（&&）真值表：
条件1  条件2  结果
 真    真    真
 真    假    假  
 假    真    假
 假    假    假

逻辑或（||）真值表：
条件1  条件2  结果
 真    真    真
 真    假    真
 假    真    真
 假    假    假

逻辑非（!）真值表：
条件   结果
 真    假
 假    真
```

### 6.3 逻辑操作符实际应用


**🔸 逻辑与（&&）示例**
```bash
#!/bin/bash
age=25
score=85

# 检查年龄和分数都满足条件
if [ $age -ge 18 ] && [ $score -ge 80 ]; then
    echo "符合录取条件：年龄${age}岁，分数${score}分"
else
    echo "不符合录取条件"
fi

# 文件存在且可读
config_file="/etc/config.conf"
if [ -f "$config_file" ] && [ -r "$config_file" ]; then
    echo "配置文件存在且可读，开始处理..."
    # 处理配置文件
else
    echo "配置文件不存在或无法读取"
fi
```

**🔸 逻辑或（||）示例**
```bash
#!/bin/bash
# 检查用户是管理员或超级用户
current_user=$(whoami)
if [ "$current_user" = "root" ] || [ "$current_user" = "admin" ]; then
    echo "具有管理员权限"
else
    echo "普通用户权限"
fi

# 检查多个可能的配置文件位置
config1="/etc/app.conf"
config2="/usr/local/etc/app.conf" 
config3="$HOME/.app.conf"

if [ -f "$config1" ] || [ -f "$config2" ] || [ -f "$config3" ]; then
    echo "找到配置文件"
else
    echo "未找到配置文件"
fi
```

**🔸 逻辑非（!）示例**
```bash
#!/bin/bash
# 检查文件不存在
backup_file="/tmp/backup.tar.gz"
if [ ! -f "$backup_file" ]; then
    echo "备份文件不存在，开始创建备份..."
    # 创建备份
else
    echo "备份文件已存在"
fi

# 检查非root用户
if [ ! "$USER" = "root" ]; then
    echo "请使用root权限运行此脚本"
    exit 1
fi
```

### 6.4 复合条件表达式组合


**🔸 复杂逻辑组合**
```bash
#!/bin/bash
# 系统健康检查脚本
cpu_usage=75
memory_usage=60
disk_usage=85
load_avg=2.5

# 复合条件：CPU或内存使用率高，且磁盘使用率也高
if ([ $cpu_usage -gt 80 ] || [ $memory_usage -gt 70 ]) && [ $disk_usage -gt 80 ]; then
    echo "系统负载过高，需要关注！"
    echo "CPU: ${cpu_usage}%, 内存: ${memory_usage}%, 磁盘: ${disk_usage}%"
else
    echo "系统运行正常"
fi
```

---

## 7. 🚀 扩展条件判断[[ ]]语法


### 7.1 [[ ]]与[ ]的区别


**🔸 为什么需要[[ ]]**
`[[ ]]`是Bash的扩展语法，比传统的`[ ]`更强大、更安全，可以理解为"条件判断的升级版"。

**🔸 主要优势对比**

| 特性 | **[ ]传统语法** | **[[ ]]扩展语法** |
|------|---------------|-----------------|
| **字符串处理** | `需要小心引号` | `自动处理空格和特殊字符` |
| **模式匹配** | `不支持` | `支持通配符匹配` |
| **正则匹配** | `不支持` | `支持正则表达式` |
| **逻辑组合** | `较复杂` | `更直观` |

### 7.2 [[ ]]基础语法增强


**🔸 字符串匹配增强**
```bash
#!/bin/bash
filename="data.txt"

# 传统方式：复杂且易错
if [ "${filename##*.}" = "txt" ]; then
    echo "这是文本文件"
fi

# 扩展语法：简洁直观
if [[ $filename == *.txt ]]; then
    echo "这是文本文件"
fi

# 多种格式匹配
if [[ $filename == *.@(txt|log|conf) ]]; then
    echo "这是配置类文件"
fi
```

**🔸 正则表达式匹配**
```bash
#!/bin/bash
# 邮箱格式验证
email="user@example.com"

if [[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
    echo "邮箱格式正确"
else
    echo "邮箱格式错误"
fi

# IP地址格式验证
ip="192.168.1.100"
if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    echo "IP格式正确"
else
    echo "IP格式错误"
fi
```

### 7.3 [[ ]]高级特性应用


**🔸 空值安全处理**
```bash
#!/bin/bash
name=""

# 传统方式：需要小心处理空值
if [ "$name" = "" ]; then
    echo "姓名为空"
fi

# 扩展语法：更安全
if [[ -z $name ]]; then
    echo "姓名为空"
fi

# 即使变量未定义也安全
if [[ -z $undefined_var ]]; then
    echo "变量未定义或为空"
fi
```

**🔸 复杂逻辑表达式**
```bash
#!/bin/bash
# 用户权限检查
user="alice"
group="admin"
age=25

# 复杂条件组合
if [[ ($user == "admin" || $group == "admin") && $age -ge 21 ]]; then
    echo "允许执行管理操作"
else
    echo "权限不足"
fi
```

### 7.4 实际应用场景


**🔸 文件类型检查脚本**
```bash
#!/bin/bash
# 文件处理脚本
process_file() {
    local file="$1"
    
    if [[ ! -f $file ]]; then
        echo "错误：文件不存在"
        return 1
    fi
    
    # 根据文件扩展名处理
    if [[ $file == *.jpg || $file == *.png || $file == *.gif ]]; then
        echo "处理图片文件：$file"
    elif [[ $file == *.txt || $file == *.log ]]; then
        echo "处理文本文件：$file"
    elif [[ $file == *.tar.gz || $file == *.zip ]]; then
        echo "处理压缩文件：$file"
    else
        echo "未知文件类型：$file"
    fi
}

# 使用示例
process_file "photo.jpg"
process_file "data.txt"
process_file "backup.tar.gz"
```

---

## 8. 💼 实战应用与最佳实践


### 8.1 综合实战：系统检查脚本


```bash
#!/bin/bash
# 系统健康检查脚本

echo "=== 系统健康检查 ==="

# 检查是否为root用户
if [[ $EUID -ne 0 ]]; then
    echo "⚠️ 建议使用root权限运行以获取完整信息"
fi

# 检查磁盘使用情况
echo "📁 磁盘使用情况："
while read -r line; do
    if [[ $line =~ ^/dev ]]; then
        usage=$(echo "$line" | awk '{print $5}' | sed 's/%//')
        mount_point=$(echo "$line" | awk '{print $6}')
        
        if [[ $usage -ge 90 ]]; then
            echo "🔴 警告：$mount_point 使用率 ${usage}%（严重）"
        elif [[ $usage -ge 80 ]]; then
            echo "🟡 注意：$mount_point 使用率 ${usage}%（较高）"
        else
            echo "🟢 正常：$mount_point 使用率 ${usage}%"
        fi
    fi
done < <(df -h)

# 检查内存使用情况
echo -e "\n💾 内存使用情况："
mem_info=$(free -m)
mem_used=$(echo "$mem_info" | awk 'NR==2{print $3}')
mem_total=$(echo "$mem_info" | awk 'NR==2{print $2}')
mem_percent=$((mem_used * 100 / mem_total))

if [[ $mem_percent -ge 90 ]]; then
    echo "🔴 内存使用率：${mem_percent}%（严重）"
elif [[ $mem_percent -ge 80 ]]; then
    echo "🟡 内存使用率：${mem_percent}%（较高）"
else
    echo "🟢 内存使用率：${mem_percent}%（正常）"
fi

# 检查重要服务
echo -e "\n🔧 服务状态检查："
services=("sshd" "nginx" "mysql" "redis")

for service in "${services[@]}"; do
    if systemctl is-active --quiet "$service"; then
        echo "🟢 $service 服务运行正常"
    else
        echo "🔴 $service 服务未运行"
    fi
done

echo -e "\n✅ 系统检查完成"
```

### 8.2 实战：自动化备份脚本


```bash
#!/bin/bash
# 智能备份脚本

# 配置参数
SOURCE_DIR="/important/data"
BACKUP_DIR="/backup"
MAX_BACKUPS=7
LOG_FILE="/var/log/backup.log"

# 日志函数
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# 检查前置条件
check_prerequisites() {
    log_message "开始备份前检查..."
    
    # 检查源目录
    if [[ ! -d $SOURCE_DIR ]]; then
        log_message "错误：源目录不存在 - $SOURCE_DIR"
        exit 1
    fi
    
    # 检查源目录是否可读
    if [[ ! -r $SOURCE_DIR ]]; then
        log_message "错误：源目录无读权限 - $SOURCE_DIR"
        exit 1
    fi
    
    # 创建备份目录
    if [[ ! -d $BACKUP_DIR ]]; then
        if mkdir -p "$BACKUP_DIR"; then
            log_message "创建备份目录：$BACKUP_DIR"
        else
            log_message "错误：无法创建备份目录"
            exit 1
        fi
    fi
    
    # 检查备份目录写权限
    if [[ ! -w $BACKUP_DIR ]]; then
        log_message "错误：备份目录无写权限 - $BACKUP_DIR"
        exit 1
    fi
    
    # 检查磁盘空间
    source_size=$(du -s "$SOURCE_DIR" | awk '{print $1}')
    available_space=$(df "$BACKUP_DIR" | awk 'NR==2 {print $4}')
    
    if [[ $source_size -gt $available_space ]]; then
        log_message "警告：磁盘空间可能不足"
        log_message "源目录大小：${source_size}KB，可用空间：${available_space}KB"
    fi
    
    log_message "前置检查通过"
}

# 执行备份
perform_backup() {
    local timestamp=$(date '+%Y%m%d_%H%M%S')
    local backup_file="${BACKUP_DIR}/backup_${timestamp}.tar.gz"
    
    log_message "开始备份：$SOURCE_DIR -> $backup_file"
    
    if tar -czf "$backup_file" -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")"; then
        log_message "备份成功完成：$backup_file"
        
        # 验证备份文件
        if [[ -f $backup_file && -s $backup_file ]]; then
            local backup_size=$(du -h "$backup_file" | cut -f1)
            log_message "备份文件大小：$backup_size"
        else
            log_message "错误：备份文件验证失败"
            return 1
        fi
    else
        log_message "错误：备份操作失败"
        return 1
    fi
}

# 清理旧备份
cleanup_old_backups() {
    log_message "清理旧备份文件（保留最新${MAX_BACKUPS}个）..."
    
    cd "$BACKUP_DIR" || return
    
    # 列出备份文件并按时间排序
    local backup_count=$(ls -1 backup_*.tar.gz 2>/dev/null | wc -l)
    
    if [[ $backup_count -gt $MAX_BACKUPS ]]; then
        local files_to_delete=$((backup_count - MAX_BACKUPS))
        ls -1t backup_*.tar.gz | tail -n "$files_to_delete" | while read -r file; do
            if rm "$file"; then
                log_message "删除旧备份：$file"
            else
                log_message "警告：无法删除 $file"
            fi
        done
    else
        log_message "当前备份数量：$backup_count，无需清理"
    fi
}

# 主函数
main() {
    log_message "====== 开始自动备份 ======"
    
    check_prerequisites
    perform_backup
    cleanup_old_backups
    
    log_message "====== 备份完成 ======"
}

# 执行主函数
main "$@"
```

### 8.3 最佳实践总结


**🔸 代码编写最佳实践**

1. **变量引用安全**
```bash
# ✅ 推荐：变量加双引号
if [[ -f "$config_file" ]]; then

# ❌ 避免：变量不加引号
if [[ -f $config_file ]]; then
```

2. **条件检查顺序**
```bash
# ✅ 推荐：先检查基础条件
if [[ -n $file ]] && [[ -f $file ]] && [[ -r $file ]]; then
    # 处理文件
fi
```

3. **错误处理**
```bash
# ✅ 推荐：及时退出错误情况
if [[ ! -d $important_dir ]]; then
    echo "错误：重要目录不存在"
    exit 1
fi
```

---

## 9. ⚠️ 常见陷阱与避坑指南


### 9.1 变量引用陷阱


**🔸 空变量陷阱**
```bash
# ❌ 危险写法
name=""
if [ $name = "admin" ]; then  # 当name为空时变成 [ = "admin" ]
    echo "管理员"
fi

# ✅ 安全写法
if [[ $name == "admin" ]]; then  # [[ ]]自动处理
    echo "管理员"
fi

# ✅ 传统安全写法
if [ "$name" = "admin" ]; then  # 双引号保护
    echo "管理员"
fi
```

**🔸 包含空格的变量**
```bash
# ❌ 危险写法
file_name="my document.txt"
if [ -f $file_name ]; then  # 空格导致参数分割
    echo "文件存在"
fi

# ✅ 正确写法
if [[ -f $file_name ]]; then  # 推荐方式
    echo "文件存在"
fi

if [ -f "$file_name" ]; then  # 传统方式
    echo "文件存在"
fi
```

### 9.2 数值比较陷阱


**🔸 字符串数值混淆**
```bash
# ❌ 可能有问题的写法
version="2.1.0"
if [[ $version -gt 2 ]]; then  # 字符串不能用数值比较
    echo "版本大于2"
fi

# ✅ 正确的版本比较
compare_version() {
    local v1="$1"
    local v2="$2"
    
    if [[ $v1 == $v2 ]]; then
        return 0  # 相等
    fi
    
    # 使用sort进行版本比较
    local greater=$(printf '%s\n' "$v1" "$v2" | sort -V | tail -n1)
    if [[ $greater == $v1 ]]; then
        return 1  # v1 > v2
    else
        return 2  # v1 < v2
    fi
}
```

**🔸 浮点数比较陷阱**
```bash
# ❌ 错误：整数操作符用于浮点数
price=19.99
if [[ $price -gt 20 ]]; then  # 浮点数无法直接比较
    echo "价格超过20"
fi

# ✅ 正确：使用bc进行浮点数比较
if [[ $(echo "$price > 20" | bc -l) -eq 1 ]]; then
    echo "价格超过20"
fi

# ✅ 另一种方法：转换为整数比较
price_cents=$(echo "$price * 100" | bc)
if [[ $price_cents -gt 2000 ]]; then
    echo "价格超过20元"
fi
```

### 9.3 文件测试陷阱


**🔸 符号链接测试陷阱**
```bash
# 创建测试场景
ln -s /nonexistent/file broken_link

# ❌ 可能误导的结果
if [[ -e broken_link ]]; then
    echo "文件存在"  # 这里不会执行，因为目标不存在
else
    echo "文件不存在"  # 但链接本身存在！
fi

# ✅ 正确的符号链接检查
if [[ -L broken_link ]]; then
    echo "这是一个符号链接"
    if [[ -e broken_link ]]; then
        echo "链接目标存在"
    else
        echo "链接目标不存在（断开的链接）"
    fi
fi
```

### 9.4 条件组合陷阱


**🔸 操作符优先级陷阱**
```bash
# ❌ 可能产生意外结果
if [[ $a -eq 1 || $b -eq 2 && $c -eq 3 ]]; then
    # && 优先级高于 ||，实际逻辑是：$a -eq 1 || ($b -eq 2 && $c -eq 3)
    echo "条件满足"
fi

# ✅ 明确使用括号
if [[ ($a -eq 1 || $b -eq 2) && $c -eq 3 ]]; then
    echo "条件满足"
fi

# ✅ 或者分开写更清晰
if [[ $a -eq 1 || $b -eq 2 ]]; then
    if [[ $c -eq 3 ]]; then
        echo "条件满足"
    fi
fi
```

### 9.5 避坑检查清单


> 📋 **条件判断检查清单**
> 
> - [ ] 变量是否加了适当的引号保护？
> - [ ] 是否检查了变量为空的情况？
> - [ ] 数值比较是否使用了正确的操作符？
> - [ ] 文件测试是否考虑了符号链接情况？
> - [ ] 复合条件是否使用了括号明确优先级？
> - [ ] 是否添加了适当的错误处理？
> - [ ] 脚本是否在不同情况下都经过了测试？

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


**🔸 条件判断基础**
- 条件判断返回退出状态码：0为真，非0为假
- `test`命令、`[ ]`和`[[ ]]`三种语法形式
- 所有条件表达式都需要空格分隔

**🔸 核心操作符分类**
```
文件测试：-f（文件） -d（目录） -e（存在） -r/-w/-x（权限）
数值比较：-eq（等于） -ne（不等） -gt/-lt（大小比较）
字符串测试：=（相等） !=（不等） -z（为空） -n（非空）
逻辑操作：&&（与） ||（或） !（非）
```

### 10.2 关键理解要点


**🔹 语法选择策略**
```
简单条件 → 使用 [ ]
复杂逻辑 → 使用 [[ ]]
模式匹配 → 使用 [[ ]]
兼容性要求 → 使用 [ ]
```

**🔹 安全编程原则**
```
变量引用 → 加双引号保护
空值检查 → 先测试再使用
错误处理 → 及时退出异常情况
条件组合 → 使用括号明确优先级
```

**🔹 性能优化建议**
```
条件顺序 → 最可能为假的条件放前面（短路求值）
文件测试 → 避免重复的昂贵操作
复杂逻辑 → 考虑分解为多个简单判断
```

### 10.3 实际应用价值


**🎯 在系统管理中的价值**
- **自动化脚本**：根据不同条件执行不同操作
- **错误处理**：检查命令执行结果和系统状态
- **安全检查**：验证用户权限和文件安全性
- **资源监控**：监控系统资源使用情况

**🎯 在开发中的价值**
- **参数验证**：检查脚本参数的合法性
- **环境检测**：检查运行环境的准备情况
- **流程控制**：根据条件选择不同的执行路径
- **数据处理**：根据数据特征进行分类处理

### 10.4 学习进阶建议


**🔹 下一步学习方向**
1. **循环控制结构**：for、while、until循环
2. **函数定义与调用**：代码模块化和重用
3. **数组处理**：处理批量数据
4. **正则表达式**：高级文本匹配和处理

**🔹 实践建议**
1. **多写小脚本**：从简单的条件判断开始练习
2. **模拟真实场景**：编写系统管理相关的脚本
3. **注意边界情况**：测试各种异常和特殊情况
4. **代码审查**：定期回顾和优化已有脚本

**核心记忆要点**：
- 条件判断是Shell脚本的决策核心
- `[[ ]]`比`[ ]`更强大更安全
- 变量引用要加引号保护
- 逻辑组合要注意优先级
- 实践出真知，多写多练是关键