---
title: 5、数组操作与数据结构
---
## 📚 目录

1. [数组基础概念](#1-数组基础概念)
2. [索引数组详解](#2-索引数组详解)
3. [关联数组详解](#3-关联数组详解)
4. [数组操作技巧](#4-数组操作技巧)
5. [数组遍历方法](#5-数组遍历方法)
6. [数组高级应用](#6-数组高级应用)
7. [实际应用案例](#7-实际应用案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🗃️ 数组基础概念


### 1.1 什么是Shell数组


**🔸 数组的本质**
数组就像一个**有序的储物柜**，每个柜子有个编号(索引)，里面可以存放数据。想象一下：

```
普通变量：就像一个盒子，只能装一样东西
name="张三"

数组变量：就像一排柜子，每个柜子都能装东西
students[0]="张三"    ← 0号柜子装张三
students[1]="李四"    ← 1号柜子装李四  
students[2]="王五"    ← 2号柜子装王五
```

### 1.2 Shell数组的两种类型


| 类型 | **说明** | **索引** | **用途** |
|------|---------|----------|---------|
| 🔢 **索引数组** | 用数字做编号的柜子 | 0,1,2,3... | 存放有序数据列表 |
| 🏷️ **关联数组** | 用名字做标签的柜子 | 自定义字符串 | 存放键值对数据 |

**📝 简单理解**：
- **索引数组**：像图书馆的书架，按1、2、3号位置摆放
- **关联数组**：像通讯录，按姓名查找电话号码

### 1.3 为什么要用数组


**🚫 不用数组的痛苦**：
```bash
# 存储5个学生成绩，需要5个变量
score1=85
score2=92
score3=78
score4=96
score5=88

# 计算平均分要这样写...
total=$((score1 + score2 + score3 + score4 + score5))
```

**✅ 用数组的便利**：
```bash
# 所有成绩存在一个数组里
scores=(85 92 78 96 88)

# 用循环轻松处理
for score in "${scores[@]}"; do
    total=$((total + score))
done
```

---

## 2. 🔢 索引数组详解


### 2.1 索引数组的创建方法


**🔸 方法一：直接赋值**
```bash
# 单个元素赋值
fruits[0]="苹果"
fruits[1]="香蕉"
fruits[2]="橙子"

echo ${fruits[0]}  # 输出：苹果
```

**🔸 方法二：一次性创建**
```bash
# 括号方式创建
colors=("红色" "绿色" "蓝色" "黄色")

# 等价于：
colors[0]="红色"
colors[1]="绿色"
colors[2]="蓝色"  
colors[3]="黄色"
```

**🔸 方法三：指定索引创建**
```bash
# 可以跳跃式指定索引
numbers[1]=10
numbers[3]=30
numbers[5]=50

# 索引0,2,4是空的，这样也可以
```

### 2.2 索引数组的访问


**🔸 访问单个元素**
```bash
fruits=("苹果" "香蕉" "橙子")

# 访问第一个元素（索引从0开始）
echo ${fruits[0]}     # 输出：苹果
echo ${fruits[1]}     # 输出：香蕉

# 访问最后一个元素
echo ${fruits[-1]}    # 输出：橙子（bash 4.0+支持）
```

**🔸 访问所有元素**
```bash
fruits=("苹果" "香蕉" "橙子")

# 获取所有元素
echo ${fruits[@]}     # 输出：苹果 香蕉 橙子
echo ${fruits[*]}     # 效果相同，但在引号中表现不同

# 推荐使用 "${fruits[@]}" 的形式
for fruit in "${fruits[@]}"; do
    echo "水果：$fruit"
done
```

### 2.3 数组长度获取


**🔸 获取数组长度**
```bash
fruits=("苹果" "香蕉" "橙子" "葡萄")

# 获取数组元素个数
echo ${#fruits[@]}    # 输出：4
echo ${#fruits[*]}    # 效果相同

# 获取单个元素的长度
echo ${#fruits[0]}    # 输出：2（"苹果"是2个字符）
```

**💡 实际应用场景**：
```bash
#!/bin/bash
# 检查数组是否为空
students=("张三" "李四" "王五")

if [ ${#students[@]} -eq 0 ]; then
    echo "没有学生数据"
else
    echo "共有 ${#students[@]} 名学生"
fi
```

### 2.4 数组元素的修改


**🔸 修改现有元素**
```bash
colors=("红" "绿" "蓝")
echo "原来：${colors[@]}"     # 输出：红 绿 蓝

# 修改第二个元素
colors[1]="黄"
echo "修改后：${colors[@]}"   # 输出：红 黄 蓝
```

**🔸 添加新元素**
```bash
fruits=("苹果" "香蕉")

# 方法1：指定索引添加
fruits[2]="橙子"

# 方法2：追加到末尾
fruits[${#fruits[@]}]="葡萄"  # 在最后一个位置添加

# 方法3：使用+=操作符
fruits+=("草莓")

echo ${fruits[@]}  # 输出：苹果 香蕉 橙子 葡萄 草莓
```

---

## 3. 🏷️ 关联数组详解


### 3.1 关联数组的概念


**🔸 什么是关联数组**
关联数组就像一个**字典**或**通讯录**，不用数字编号，而是用**有意义的名字**作为标签：

```
索引数组：像酒店房间号
room[101]="张三"  ← 101号房住张三
room[102]="李四"  ← 102号房住李四

关联数组：像通讯录
phone["张三"]="13800138000"  ← 张三的电话
phone["李四"]="13900139000"  ← 李四的电话
```

### 3.2 关联数组的声明与使用


**🔸 声明关联数组**
```bash
# 必须先声明为关联数组
declare -A student_info

# 然后赋值
student_info["姓名"]="张三"
student_info["年龄"]="20"
student_info["专业"]="计算机"
```

**⚠️ 重要注意**：
- 关联数组必须用 `declare -A` 声明
- 不声明直接赋值会被当作索引数组处理

### 3.3 关联数组的赋值方法


**🔸 方法一：逐个赋值**
```bash
declare -A colors
colors["红色"]="red"
colors["绿色"]="green"  
colors["蓝色"]="blue"
```

**🔸 方法二：批量赋值**
```bash
declare -A colors=(
    ["红色"]="red"
    ["绿色"]="green"
    ["蓝色"]="blue"
)
```

**🔸 方法三：动态赋值**
```bash
declare -A student_scores

# 从用户输入获取
echo "请输入学生成绩："
read -p "张三的成绩：" score1
read -p "李四的成绩：" score2

student_scores["张三"]=$score1
student_scores["李四"]=$score2
```

### 3.4 关联数组的访问


**🔸 访问单个元素**
```bash
declare -A phone_book=(
    ["张三"]="13800138000"
    ["李四"]="13900139000"
    ["王五"]="15000150000"
)

# 通过键名访问值
echo "张三的电话：${phone_book['张三']}"
echo "李四的电话：${phone_book['李四']}"
```

**🔸 获取所有键和值**
```bash
declare -A student_info=(
    ["姓名"]="张三"
    ["年龄"]="20"
    ["专业"]="计算机"
)

# 获取所有的键（key）
echo "所有属性：${!student_info[@]}"  # 输出：姓名 年龄 专业

# 获取所有的值（value）  
echo "所有信息：${student_info[@]}"   # 输出：张三 20 计算机
```

---

## 4. 🛠️ 数组操作技巧


### 4.1 数组切片操作


**🔸 什么是数组切片**
就像切面包一样，从数组中"切出"一部分元素：

```bash
fruits=("苹果" "香蕉" "橙子" "葡萄" "草莓" "西瓜")

# 基本语法：${array[@]:起始位置:长度}
```

**🔸 切片操作实例**
```bash
numbers=(1 2 3 4 5 6 7 8 9 10)

# 从第3个开始，取5个元素
echo ${numbers[@]:2:5}    # 输出：3 4 5 6 7

# 从第5个开始，取到最后
echo ${numbers[@]:4}      # 输出：5 6 7 8 9 10

# 取前3个元素
echo ${numbers[@]:0:3}    # 输出：1 2 3
```

**💡 实用场景**：
```bash
#!/bin/bash
# 日志文件分页显示
log_lines=("错误1" "错误2" "错误3" "错误4" "错误5" "错误6")

page_size=3
current_page=1

start=$(( (current_page - 1) * page_size ))
echo "第${current_page}页内容："
echo ${log_lines[@]:$start:$page_size}
```

### 4.2 数组元素查找与检查


**🔸 检查元素是否存在**
```bash
fruits=("苹果" "香蕉" "橙子")

# 检查"香蕉"是否在数组中
if [[ " ${fruits[*]} " =~ " 香蕉 " ]]; then
    echo "找到了香蕉"
else
    echo "没有香蕉"
fi
```

**🔸 查找元素位置**
```bash
#!/bin/bash
# 查找函数
find_element() {
    local arr=("$@")
    local target=${arr[-1]}  # 最后一个参数是要查找的元素
    unset arr[-1]            # 删除最后一个参数
    
    for i in "${!arr[@]}"; do
        if [[ "${arr[i]}" == "$target" ]]; then
            echo "找到 '$target' 在位置 $i"
            return 0
        fi
    done
    echo "'$target' 未找到"
    return 1
}

# 使用示例
colors=("红" "绿" "蓝" "黄")
find_element "${colors[@]}" "蓝"  # 输出：找到 '蓝' 在位置 2
```

### 4.3 数组元素删除


**🔸 删除指定位置的元素**
```bash
fruits=("苹果" "香蕉" "橙子" "葡萄")

# 删除索引为1的元素（香蕉）
unset fruits[1]

echo ${fruits[@]}         # 输出：苹果 橙子 葡萄
echo ${!fruits[@]}        # 输出索引：0 2 3（注意1被跳过了）
```

**🔸 删除数组中的特定值**
```bash
#!/bin/bash
# 删除数组中所有指定值的函数
remove_value() {
    local arr_name=$1
    local value=$2
    local -n arr=$arr_name
    
    local new_arr=()
    for element in "${arr[@]}"; do
        if [[ "$element" != "$value" ]]; then
            new_arr+=("$element")
        fi
    done
    
    arr=("${new_arr[@]}")
}

# 使用示例
fruits=("苹果" "香蕉" "苹果" "橙子" "苹果")
echo "删除前：${fruits[@]}"

remove_value fruits "苹果"
echo "删除后：${fruits[@]}"  # 输出：香蕉 橙子
```

### 4.4 数组排序操作


**🔸 简单排序**
```bash
#!/bin/bash
# 冒泡排序示例
bubble_sort() {
    local -n arr=$1
    local n=${#arr[@]}
    
    for ((i = 0; i < n-1; i++)); do
        for ((j = 0; j < n-1-i; j++)); do
            if [[ ${arr[j]} > ${arr[j+1]} ]]; then
                # 交换元素
                local temp=${arr[j]}
                arr[j]=${arr[j+1]}
                arr[j+1]=$temp
            fi
        done
    done
}

# 使用示例
numbers=(64 34 25 12 22 11 90)
echo "排序前：${numbers[@]}"

bubble_sort numbers
echo "排序后：${numbers[@]}"
```

---

## 5. 🔄 数组遍历方法


### 5.1 for循环遍历


**🔸 遍历数组值**
```bash
fruits=("苹果" "香蕉" "橙子")

# 方法1：遍历所有元素
for fruit in "${fruits[@]}"; do
    echo "水果：$fruit"
done

# 输出：
# 水果：苹果  
# 水果：香蕉
# 水果：橙子
```

**🔸 遍历数组索引**
```bash
fruits=("苹果" "香蕉" "橙子")

# 同时获取索引和值
for i in "${!fruits[@]}"; do
    echo "第${i}个水果是：${fruits[i]}"
done

# 输出：
# 第0个水果是：苹果
# 第1个水果是：香蕉  
# 第2个水果是：橙子
```

**🔸 C风格for循环**
```bash
fruits=("苹果" "香蕉" "橙子")

# 传统C风格循环
for ((i=0; i<${#fruits[@]}; i++)); do
    echo "索引$i：${fruits[i]}"
done
```

### 5.2 while循环遍历


**🔸 while循环基础用法**
```bash
fruits=("苹果" "香蕉" "橙子")
i=0

while [ $i -lt ${#fruits[@]} ]; do
    echo "第$((i+1))个：${fruits[i]}"
    i=$((i+1))
done
```

**🔸 while读取数组到变量**
```bash
colors=("红" "绿" "蓝" "黄")

# 使用管道和while
printf '%s\n' "${colors[@]}" | while read color; do
    echo "处理颜色：$color"
done
```

### 5.3 关联数组遍历


**🔸 遍历关联数组**
```bash
declare -A student_info=(
    ["姓名"]="张三"
    ["年龄"]="20"
    ["专业"]="计算机"
    ["成绩"]="85"
)

# 遍历键值对
for key in "${!student_info[@]}"; do
    echo "$key：${student_info[$key]}"
done

# 输出：
# 姓名：张三
# 年龄：20  
# 专业：计算机
# 成绩：85
```

---

## 6. 🚀 数组高级应用


### 6.1 数组作为函数参数


**🔸 传递数组给函数**
```bash
#!/bin/bash
# 计算数组平均值的函数
calculate_average() {
    local arr=("$@")  # 接收所有参数作为数组
    local sum=0
    local count=${#arr[@]}
    
    # 计算总和
    for num in "${arr[@]}"; do
        sum=$((sum + num))
    done
    
    # 计算平均值
    local average=$((sum / count))
    echo "平均分：$average"
}

# 使用示例
scores=(85 92 78 96 88)
calculate_average "${scores[@]}"  # 输出：平均分：87
```

**🔸 函数返回数组**
```bash
#!/bin/bash
# 过滤数组元素的函数
filter_array() {
    local threshold=$1
    shift  # 移除第一个参数
    local arr=("$@")
    local result=()
    
    for num in "${arr[@]}"; do
        if [ $num -gt $threshold ]; then
            result+=("$num")
        fi
    done
    
    # 通过echo返回结果
    echo "${result[@]}"
}

# 使用示例
numbers=(45 67 89 23 78 92 34)
filtered=($(filter_array 60 "${numbers[@]}"))

echo "大于60的数字：${filtered[@]}"  # 输出：67 89 78 92
```

### 6.2 多维数组模拟


**🔸 模拟二维数组**
```bash
#!/bin/bash
# 使用关联数组模拟二维数组
declare -A matrix

# 设置矩阵值 matrix[行,列]
matrix[0,0]=1;  matrix[0,1]=2;  matrix[0,2]=3
matrix[1,0]=4;  matrix[1,1]=5;  matrix[1,2]=6  
matrix[2,0]=7;  matrix[2,1]=8;  matrix[2,2]=9

# 显示矩阵
for i in {0..2}; do
    for j in {0..2}; do
        echo -n "${matrix[$i,$j]} "
    done
    echo  # 换行
done

# 输出：
# 1 2 3
# 4 5 6
# 7 8 9
```

### 6.3 数组的序列化与反序列化


**🔸 数组转字符串**
```bash
fruits=("苹果" "香蕉" "橙子")

# 使用分隔符连接数组元素
IFS=","
joined="${fruits[*]}"
echo $joined        # 输出：苹果,香蕉,橙子

# 恢复IFS
IFS=" "
```

**🔸 字符串转数组**
```bash
# 字符串分割为数组
data="苹果,香蕉,橙子"
IFS="," read -ra fruits <<< "$data"

# 验证结果
for fruit in "${fruits[@]}"; do
    echo "水果：$fruit"
done
```

---

## 7. 💼 实际应用案例


### 7.1 系统信息收集脚本


```bash
#!/bin/bash
# 系统信息收集器

declare -A system_info

# 收集系统信息
system_info["主机名"]=$(hostname)
system_info["操作系统"]=$(uname -s)
system_info["内核版本"]=$(uname -r)
system_info["CPU核心数"]=$(nproc)
system_info["内存总量"]=$(free -h | awk '/^Mem:/ {print $2}')
system_info["磁盘使用"]=$(df -h / | awk 'NR==2 {print $5}')

# 显示信息
echo "=== 系统信息报告 ==="
for key in "${!system_info[@]}"; do
    printf "%-12s : %s\n" "$key" "${system_info[$key]}"
done
```

### 7.2 批量文件处理脚本


```bash
#!/bin/bash  
# 批量重命名文件

# 获取当前目录下所有.txt文件
txt_files=(*.txt)

if [ ${#txt_files[@]} -eq 0 ]; then
    echo "没有找到.txt文件"
    exit 1
fi

echo "找到 ${#txt_files[@]} 个.txt文件："

# 显示文件列表
for i in "${!txt_files[@]}"; do
    echo "  $((i+1)). ${txt_files[i]}"
done

# 批量重命名
for file in "${txt_files[@]}"; do
    new_name="backup_$(date +%Y%m%d)_$file"
    mv "$file" "$new_name"
    echo "重命名：$file → $new_name"
done
```

### 7.3 配置文件解析脚本


```bash
#!/bin/bash
# 解析配置文件

declare -A config

# 读取配置文件
read_config() {
    local config_file="$1"
    
    while IFS='=' read -r key value; do
        # 跳过注释和空行
        if [[ $key =~ ^[[:space:]]*# ]] || [[ -z $key ]]; then
            continue
        fi
        
        # 去除前后空格
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        config["$key"]="$value"
    done < "$config_file"
}

# 示例配置文件内容：
# host=192.168.1.100
# port=3306
# username=admin
# password=secret123

read_config "app.conf"

# 使用配置
echo "连接到 ${config['host']}:${config['port']}"
echo "用户名：${config['username']}"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 索引数组：用数字编号，从0开始，适合有序数据
🔸 关联数组：用字符串作键，必须declare -A声明
🔸 数组长度：${#array[@]} 获取元素个数
🔸 数组遍历：for循环遍历值，"${!array[@]}"遍历索引
🔸 数组切片：${array[@]:start:length} 获取子数组
🔸 元素访问：${array[index]} 访问单个元素
```

### 8.2 重要语法对比


| 操作 | **索引数组** | **关联数组** | **注意事项** |
|------|-------------|-------------|-------------|
| **声明** | `arr=()` | `declare -A arr` | 关联数组必须先声明 |
| **赋值** | `arr[0]="值"` | `arr["键"]="值"` | 索引从0开始 |
| **访问** | `${arr[0]}` | `${arr["键"]}` | 记得用大括号 |
| **所有值** | `${arr[@]}` | `${arr[@]}` | 推荐用引号包围 |
| **所有键** | `${!arr[@]}` | `${!arr[@]}` | 关联数组的键是字符串 |

### 8.3 常见操作速查


**📋 数组操作检查清单**：

☑️ **创建数组**：
```bash
# 索引数组
arr=(元素1 元素2 元素3)

# 关联数组  
declare -A arr=(["键1"]="值1" ["键2"]="值2")
```

☑️ **遍历数组**：
```bash
# 遍历值
for item in "${arr[@]}"; do
    echo $item
done

# 遍历索引/键
for key in "${!arr[@]}"; do  
    echo "$key: ${arr[$key]}"
done
```

☑️ **数组长度**：
```bash
echo "数组长度：${#arr[@]}"
```

☑️ **数组切片**：
```bash
echo "前3个：${arr[@]:0:3}"
```

### 8.4 最佳实践建议


**💡 编程建议**：

1. **引用规范**：总是用 `"${array[@]}"` 而不是 `${array[@]}`
2. **索引检查**：访问数组前检查索引是否存在  
3. **关联数组声明**：记住用 `declare -A` 声明关联数组
4. **函数传递**：用 `"${array[@]}"` 传递整个数组给函数
5. **错误处理**：检查数组长度避免空数组操作

**⚠️ 常见陷阱**：

- 忘记声明关联数组导致被当作索引数组
- 数组元素包含空格时不用引号导致分割
- 删除数组元素后索引不连续的问题
- 在函数中修改数组需要使用引用传递

**🎯 记忆口诀**：
```
索引数组数字编号，关联数组键值对应
声明关联要declare，访问元素加大括号
遍历数组用for循环，切片操作冒号分割
传递数组加双引号，避免空格来捣乱
```