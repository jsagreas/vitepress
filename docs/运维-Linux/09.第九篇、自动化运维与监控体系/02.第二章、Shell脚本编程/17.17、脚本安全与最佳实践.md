---
title: 17、脚本安全与最佳实践
---
## 📚 目录

1. [输入验证与清理](#1-输入验证与清理)
2. [权限最小化原则应用](#2-权限最小化原则应用)
3. [临时文件安全创建](#3-临时文件安全创建)
4. [密码与密钥安全处理](#4-密码与密钥安全处理)
5. [脚本签名与完整性校验](#5-脚本签名与完整性校验)
6. [安全编码规范遵循](#6-安全编码规范遵循)
7. [代码审计与漏洞检测](#7-代码审计与漏洞检测)
8. [生产环境部署安全checklist](#8-生产环境部署安全checklist)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ 输入验证与清理


### 1.1 什么是输入验证


**核心概念**：输入验证就像门卫检查身份证一样，对所有进入脚本的数据进行严格检查，确保数据符合预期格式，防止恶意数据破坏系统。

**为什么必须验证输入**：
```
用户输入：rm /tmp/test.txt
恶意输入：rm /tmp/test.txt; rm -rf /

如果不验证，恶意输入可能：
• 删除重要文件
• 执行危险命令
• 获取敏感信息
• 破坏系统稳定性
```

### 1.2 输入验证的基本方法


**🔍 数据格式验证**

```bash
#!/bin/bash

# 验证IP地址格式
validate_ip() {
    local ip="$1"
    
    # 基本格式检查
    if [[ ! $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        echo "错误: IP地址格式不正确"
        return 1
    fi
    
    # 检查每段数值范围
    local IFS='.'
    local segments=($ip)
    for segment in "${segments[@]}"; do
        if [ "$segment" -gt 255 ]; then
            echo "错误: IP地址段超出范围"
            return 1
        fi
    done
    
    return 0
}

# 使用示例
user_ip="192.168.1.100"
if validate_ip "$user_ip"; then
    echo "IP地址有效: $user_ip"
    # 继续处理...
else
    echo "拒绝处理无效IP"
    exit 1
fi
```

**🔒 防止命令注入**

```bash
# ❌ 危险做法 - 直接使用用户输入
dangerous_function() {
    local filename="$1"
    # 用户可能输入: "test.txt; rm -rf /"
    eval "ls -l $filename"  # 非常危险！
}

# ✅ 安全做法 - 严格验证和转义
safe_function() {
    local filename="$1"
    
    # 检查文件名是否包含危险字符
    if [[ "$filename" =~ [;\|\&\$\`] ]]; then
        echo "错误: 文件名包含非法字符"
        return 1
    fi
    
    # 检查文件名长度
    if [ ${#filename} -gt 255 ]; then
        echo "错误: 文件名过长"
        return 1
    fi
    
    # 使用数组避免命令注入
    ls -l -- "$filename"
}
```

### 1.3 输入清理技术


**字符过滤与转义**：

```bash
# 清理用户输入的通用函数
sanitize_input() {
    local input="$1"
    local clean_input
    
    # 移除控制字符和非打印字符
    clean_input=$(echo "$input" | tr -d '\000-\037\177-\377')
    
    # 转义特殊字符
    clean_input="${clean_input//\\/\\\\}"  # 转义反斜杠
    clean_input="${clean_input//\"/\\\"}"  # 转义双引号
    clean_input="${clean_input//\$/\\\$}"  # 转义美元符号
    clean_input="${clean_input//\`/\\\`}"  # 转义反引号
    
    echo "$clean_input"
}

# 数值输入验证
validate_number() {
    local input="$1"
    local min_val="${2:-0}"
    local max_val="${3:-1000000}"
    
    # 检查是否为数字
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "错误: 输入必须为数字"
        return 1
    fi
    
    # 检查数值范围
    if [ "$input" -lt "$min_val" ] || [ "$input" -gt "$max_val" ]; then
        echo "错误: 数值超出范围 [$min_val, $max_val]"
        return 1
    fi
    
    return 0
}
```

---

## 2. 🔐 权限最小化原则应用


### 2.1 权限最小化的含义


**核心思想**：就像给员工分配工作权限一样，脚本和用户只应该拥有完成任务所需的**最小权限**，多余的权限就是安全风险。

```
权限分级示例：
┌─────────────┐
│   root用户   │ ← 系统管理员，最高权限
├─────────────┤
│  普通用户    │ ← 日常操作权限
├─────────────┤
│  受限用户    │ ← 特定任务权限
├─────────────┤
│  脚本执行    │ ← 最小必需权限
└─────────────┘
```

### 2.2 用户和组权限管理


**🎯 创建专用执行用户**

```bash
# 创建专门运行脚本的用户
create_script_user() {
    local script_user="webbackup"
    local script_group="backup"
    
    # 创建系统用户（不能登录shell）
    if ! id "$script_user" >/dev/null 2>&1; then
        echo "创建脚本执行用户: $script_user"
        useradd -r -s /bin/false -c "Web Backup Script User" "$script_user"
    fi
    
    # 设置用户到指定组
    usermod -aG "$script_group" "$script_user"
    
    echo "脚本用户 $script_user 已准备就绪"
}

# 权限检查函数
check_permissions() {
    local required_user="$1"
    local current_user=$(whoami)
    
    if [ "$current_user" != "$required_user" ]; then
        echo "错误: 此脚本必须以 $required_user 用户运行"
        echo "当前用户: $current_user"
        exit 1
    fi
}
```

**🔒 文件权限设置**

```bash
# 安全设置脚本文件权限
secure_script_permissions() {
    local script_path="$1"
    local owner="$2"
    
    # 设置文件所有者
    chown "$owner:$owner" "$script_path"
    
    # 设置权限: 所有者读写执行，组读执行，其他无权限
    chmod 750 "$script_path"
    
    # 验证权限设置
    local perms=$(stat -c "%a" "$script_path")
    echo "脚本权限已设置为: $perms"
}

# 敏感目录权限配置
secure_directories() {
    local backup_dir="/opt/backup"
    local log_dir="/var/log/myapp"
    
    # 创建目录并设置权限
    for dir in "$backup_dir" "$log_dir"; do
        mkdir -p "$dir"
        chown backup:backup "$dir"
        chmod 750 "$dir"
        
        echo "目录 $dir 权限已设置"
    done
}
```

### 2.3 sudo权限精确控制


**创建精确的sudo规则**：

```bash
# /etc/sudoers.d/backup-script
# 允许backup用户执行特定命令，无需密码

# 只允许执行备份相关命令
backup ALL = (root) NOPASSWD: /bin/tar, /bin/gzip, /usr/bin/rsync

# 限制命令参数（更安全）
backup ALL = (root) NOPASSWD: /usr/local/bin/secure-backup.sh

# 禁止执行shell相关命令
backup ALL = (root) !/bin/bash, !/bin/sh, !/usr/bin/su
```

---

## 3. 📁 临时文件安全创建


### 3.1 临时文件的安全风险


**常见安全问题**：
```
风险场景分析：

时间竞争攻击：
1. 脚本创建 /tmp/data.tmp
2. 攻击者快速创建同名链接指向 /etc/passwd
3. 脚本写入数据时实际修改了系统文件

权限泄露：
• 临时文件权限过宽，其他用户可读取敏感数据
• 临时文件残留，包含密码等敏感信息

路径遍历：
• 使用用户提供的文件名创建临时文件
• 攻击者可能访问系统其他目录
```

### 3.2 安全创建临时文件


**🛡️ 使用mktemp创建安全临时文件**

```bash
# 安全创建临时文件
create_secure_temp() {
    local temp_file
    local temp_dir
    
    # 创建临时文件（自动生成随机名称）
    temp_file=$(mktemp) || {
        echo "错误: 无法创建临时文件"
        exit 1
    }
    
    # 创建临时目录
    temp_dir=$(mktemp -d) || {
        echo "错误: 无法创建临时目录"
        exit 1
    }
    
    # 设置严格权限（只有所有者可读写）
    chmod 600 "$temp_file"
    chmod 700 "$temp_dir"
    
    echo "临时文件: $temp_file"
    echo "临时目录: $temp_dir"
    
    # 返回路径供后续使用
    echo "$temp_file" "$temp_dir"
}

# 临时文件清理函数
cleanup_temp_files() {
    local -a temp_files=("$@")
    
    for file in "${temp_files[@]}"; do
        if [ -f "$file" ]; then
            # 先清空文件内容（防止数据恢复）
            shred -vfz -n 3 "$file" 2>/dev/null || {
                # 如果shred不可用，使用dd覆盖
                dd if=/dev/zero of="$file" bs=1024 count=1 2>/dev/null
            }
            rm -f "$file"
            echo "已清理临时文件: $file"
        fi
        
        if [ -d "$file" ]; then
            rm -rf "$file"
            echo "已清理临时目录: $file"
        fi
    done
}
```

**自动清理机制**：

```bash
#!/bin/bash

# 设置退出时自动清理
temp_files=()

# 注册清理函数
cleanup() {
    echo "执行清理操作..."
    cleanup_temp_files "${temp_files[@]}"
}

# 设置信号处理
trap cleanup EXIT INT TERM

# 主程序逻辑
main() {
    # 创建临时文件
    local temp_file=$(mktemp)
    temp_files+=("$temp_file")
    
    # 使用临时文件
    echo "处理数据..." > "$temp_file"
    
    # 即使程序异常退出，清理函数也会执行
    # 正常情况下，EXIT信号会触发清理
}

main "$@"
```

---

## 4. 🔑 密码与密钥安全处理


### 4.1 密码安全存储原则


**密码处理的黄金法则**：
```
❌ 绝对不能做的：
• 密码写在脚本里
• 密码作为命令行参数传递
• 密码存储在普通文本文件中
• 密码通过环境变量传递（进程列表可见）

✅ 应该这样做：
• 使用专门的密码管理工具
• 从安全的配置文件读取
• 使用密钥文件代替密码
• 运行时提示用户输入
```

### 4.2 安全的密码输入方法


**🔐 安全读取用户密码**

```bash
# 安全读取密码（不回显）
read_password() {
    local prompt="$1"
    local password
    
    echo -n "$prompt"
    
    # 关闭回显，读取密码
    read -s password
    echo  # 换行
    
    # 基本密码强度检查
    if [ ${#password} -lt 8 ]; then
        echo "错误: 密码长度至少8位"
        return 1
    fi
    
    echo "$password"
}

# 从安全配置文件读取密码
read_password_from_config() {
    local config_file="/etc/myapp/credentials"
    local password
    
    # 检查配置文件权限
    if [ $(stat -c "%a" "$config_file") != "600" ]; then
        echo "错误: 配置文件权限不安全"
        return 1
    fi
    
    # 读取密码
    password=$(grep "^password=" "$config_file" | cut -d'=' -f2)
    
    if [ -z "$password" ]; then
        echo "错误: 配置文件中未找到密码"
        return 1
    fi
    
    echo "$password"
}
```

### 4.3 SSH密钥管理


**🔑 SSH密钥安全配置**

```bash
# 生成SSH密钥对
generate_ssh_key() {
    local key_name="$1"
    local key_path="$HOME/.ssh/$key_name"
    
    # 检查密钥是否已存在
    if [ -f "$key_path" ]; then
        echo "密钥已存在: $key_path"
        return 1
    fi
    
    # 生成RSA密钥（4096位）
    ssh-keygen -t rsa -b 4096 -f "$key_path" -N "" -C "automated-script@$(hostname)"
    
    # 设置正确权限
    chmod 600 "$key_path"        # 私钥只有所有者可读
    chmod 644 "$key_path.pub"    # 公钥可读
    
    echo "SSH密钥已生成: $key_path"
}

# 使用SSH密钥连接
ssh_with_key() {
    local user="$1"
    local host="$2"
    local key_path="$3"
    local command="$4"
    
    # 验证私钥文件权限
    if [ $(stat -c "%a" "$key_path") != "600" ]; then
        echo "错误: SSH私钥权限不安全"
        return 1
    fi
    
    # 使用密钥连接
    ssh -i "$key_path" \
        -o StrictHostKeyChecking=yes \
        -o UserKnownHostsFile="$HOME/.ssh/known_hosts" \
        "$user@$host" "$command"
}
```

---

## 5. ✍️ 脚本签名与完整性校验


### 5.1 为什么需要脚本签名


**核心概念**：脚本签名就像官方文件的印章，用来证明脚本的来源和完整性，防止脚本被恶意篡改。

```
完整性威胁场景：

场景1: 脚本被替换
原始脚本: backup.sh (执行备份)
恶意脚本: backup.sh (删除文件)

场景2: 脚本被修改
原始: rm /tmp/old_files
修改后: rm -rf /

场景3: 中间人攻击
下载脚本时被替换为恶意版本
```

### 5.2 使用哈希值校验完整性


**📋 创建和验证哈希值**

```bash
# 生成脚本哈希值
generate_script_hash() {
    local script_file="$1"
    local hash_file="$script_file.sha256"
    
    if [ ! -f "$script_file" ]; then
        echo "错误: 脚本文件不存在: $script_file"
        return 1
    fi
    
    # 生成SHA256哈希值
    sha256sum "$script_file" > "$hash_file"
    
    # 设置哈希文件为只读
    chmod 444 "$hash_file"
    
    echo "哈希值已生成: $hash_file"
    cat "$hash_file"
}

# 验证脚本完整性
verify_script_integrity() {
    local script_file="$1"
    local hash_file="$script_file.sha256"
    
    if [ ! -f "$hash_file" ]; then
        echo "错误: 哈希文件不存在: $hash_file"
        return 1
    fi
    
    # 验证哈希值
    if sha256sum -c "$hash_file" >/dev/null 2>&1; then
        echo "✅ 脚本完整性验证通过"
        return 0
    else
        echo "❌ 脚本完整性验证失败！"
        echo "警告: 脚本可能已被篡改"
        return 1
    fi
}
```

**在脚本开头添加自检**：

```bash
#!/bin/bash

# 脚本自检函数
self_check() {
    local script_path="$0"
    local script_dir=$(dirname "$script_path")
    
    echo "开始脚本完整性自检..."
    
    if verify_script_integrity "$script_path"; then
        echo "自检通过，继续执行"
    else
        echo "自检失败，拒绝执行"
        exit 1
    fi
}

# 在主逻辑前进行自检
self_check

# 主程序逻辑
echo "脚本开始执行..."
```

---

## 6. 📝 安全编码规范遵循


### 6.1 核心安全编码原则


**🎯 防御式编程思维**

```bash
# ✅ 安全编码示例
safe_file_processing() {
    local input_file="$1"
    local output_file="$2"
    
    # 1. 参数检查
    if [ $# -ne 2 ]; then
        echo "用法: $0 <输入文件> <输出文件>" >&2
        return 1
    fi
    
    # 2. 输入文件存在性检查
    if [ ! -f "$input_file" ]; then
        echo "错误: 输入文件不存在: $input_file" >&2
        return 1
    fi
    
    # 3. 输入文件可读性检查
    if [ ! -r "$input_file" ]; then
        echo "错误: 输入文件不可读: $input_file" >&2
        return 1
    fi
    
    # 4. 输出目录检查
    local output_dir=$(dirname "$output_file")
    if [ ! -d "$output_dir" ]; then
        echo "错误: 输出目录不存在: $output_dir" >&2
        return 1
    fi
    
    # 5. 输出目录写权限检查
    if [ ! -w "$output_dir" ]; then
        echo "错误: 输出目录不可写: $output_dir" >&2
        return 1
    fi
    
    # 6. 防止覆盖重要文件
    if [ -f "$output_file" ]; then
        read -p "输出文件已存在，是否覆盖？(y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "操作取消"
            return 1
        fi
    fi
    
    # 7. 执行实际操作
    cp "$input_file" "$output_file" || {
        echo "错误: 文件复制失败" >&2
        return 1
    }
    
    echo "文件处理完成: $output_file"
}
```

### 6.2 变量和字符串安全处理


**引号和转义的正确使用**：

```bash
# ✅ 正确的变量使用方法
secure_variable_handling() {
    local filename="user file.txt"
    local directory="/path/to/files"
    
    # 正确: 使用双引号包围变量
    if [ -f "$directory/$filename" ]; then
        echo "文件存在: $directory/$filename"
    fi
    
    # 正确: 数组处理文件列表
    local -a file_list=()
    while IFS= read -r -d '' file; do
        file_list+=("$file")
    done < <(find "$directory" -name "*.txt" -print0)
    
    # 正确: 遍历数组
    for file in "${file_list[@]}"; do
        echo "处理文件: $file"
    done
}

# ❌ 危险的做法对比
dangerous_examples() {
    local filename="user file.txt"
    
    # 危险: 不使用引号
    # if [ -f $filename ]; then  # 会被解析为多个参数
    
    # 危险: 使用eval
    # eval "ls $filename"  # 可能执行恶意代码
    
    # 危险: 命令替换未引用
    # for file in $(ls *.txt); do  # 文件名有空格时出错
}
```

### 6.3 错误处理和日志记录


**完善的错误处理机制**：

```bash
# 统一的错误处理函数
error_handler() {
    local line_number="$1"
    local error_code="$2"
    local command="$3"
    
    echo "错误发生位置: 第 $line_number 行" >&2
    echo "错误代码: $error_code" >&2
    echo "失败命令: $command" >&2
    echo "时间: $(date)" >&2
    
    # 记录到系统日志
    logger -t "script-error" "Script $0 failed at line $line_number with code $error_code"
    
    # 清理资源
    cleanup
    
    exit "$error_code"
}

# 设置错误处理
set -eE  # 出错立即退出，包括函数内的错误
trap 'error_handler ${LINENO} $? "$BASH_COMMAND"' ERR

# 安全的日志记录
secure_log() {
    local level="$1"
    local message="$2"
    local log_file="/var/log/myapp/script.log"
    
    # 确保日志目录存在且权限正确
    local log_dir=$(dirname "$log_file")
    if [ ! -d "$log_dir" ]; then
        mkdir -p "$log_dir"
        chmod 750 "$log_dir"
    fi
    
    # 记录日志（不记录敏感信息）
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$log_file"
    
    # 限制日志文件大小
    if [ -f "$log_file" ] && [ $(stat -c%s "$log_file") -gt 10485760 ]; then
        # 大于10MB时轮转日志
        mv "$log_file" "$log_file.old"
        touch "$log_file"
        chmod 640 "$log_file"
    fi
}
```

---

## 7. 🔍 代码审计与漏洞检测


### 7.1 常见Shell脚本漏洞类型


**🎯 漏洞分类和识别**

| 漏洞类型 | **风险等级** | **典型表现** | **危害后果** |
|---------|------------|------------|------------|
| **命令注入** | `高危` | 直接执行用户输入 | 系统完全控制权 |
| **路径遍历** | `中危` | 未验证文件路径 | 访问任意文件 |
| **权限提升** | `高危` | 不当的sudo使用 | 获取管理员权限 |
| **信息泄露** | `中危` | 敏感数据暴露 | 数据被窃取 |
| **拒绝服务** | `低危` | 资源耗尽攻击 | 服务不可用 |

### 7.2 自动化代码审计工具


**使用shellcheck进行静态分析**：

```bash
# 安装shellcheck
install_shellcheck() {
    if command -v shellcheck >/dev/null 2>&1; then
        echo "ShellCheck 已安装"
        return 0
    fi
    
    echo "正在安装 ShellCheck..."
    
    # Ubuntu/Debian
    if command -v apt-get >/dev/null 2>&1; then
        sudo apt-get update && sudo apt-get install -y shellcheck
    # CentOS/RHEL
    elif command -v yum >/dev/null 2>&1; then
        sudo yum install -y ShellCheck
    # macOS
    elif command -v brew >/dev/null 2>&1; then
        brew install shellcheck
    else
        echo "无法自动安装，请手动安装 ShellCheck"
        return 1
    fi
}

# 执行代码审计
audit_script() {
    local script_file="$1"
    local report_file="audit_report_$(date +%Y%m%d_%H%M%S).txt"
    
    echo "开始审计脚本: $script_file"
    
    # 基本语法检查
    if ! bash -n "$script_file"; then
        echo "❌ 语法错误检查失败"
        return 1
    fi
    
    # ShellCheck 分析
    if command -v shellcheck >/dev/null 2>&1; then
        echo "执行 ShellCheck 分析..."
        shellcheck -f gcc "$script_file" > "$report_file" 2>&1
        
        if [ -s "$report_file" ]; then
            echo "⚠️  发现潜在问题，详细报告: $report_file"
            echo "主要问题预览:"
            head -10 "$report_file"
        else
            echo "✅ ShellCheck 分析通过"
            rm -f "$report_file"
        fi
    else
        echo "⚠️  ShellCheck 未安装，跳过静态分析"
    fi
}
```

### 7.3 手动安全检查清单


**安全审计检查表**：

```bash
# 脚本安全自检函数
security_self_check() {
    local script_file="$1"
    local issues=0
    
    echo "开始安全自检: $script_file"
    echo "================================"
    
    # 1. 检查文件权限
    local perms=$(stat -c "%a" "$script_file")
    if [ "$perms" -gt 755 ]; then
        echo "⚠️  文件权限过宽: $perms"
        ((issues++))
    fi
    
    # 2. 检查是否使用了危险命令
    local dangerous_commands=("eval" "exec" "source" ". ")
    for cmd in "${dangerous_commands[@]}"; do
        if grep -q "$cmd" "$script_file"; then
            echo "⚠️  发现危险命令: $cmd"
            ((issues++))
        fi
    done
    
    # 3. 检查是否有硬编码密码
    if grep -i "password\s*=" "$script_file" | grep -v "read_password"; then
        echo "⚠️  可能存在硬编码密码"
        ((issues++))
    fi
    
    # 4. 检查是否使用了不安全的临时文件
    if grep -q "/tmp/" "$script_file" && ! grep -q "mktemp"; then
        echo "⚠️  可能存在不安全的临时文件使用"
        ((issues++))
    fi
    
    # 5. 检查变量引用
    if grep -q '\$[A-Za-z_][A-Za-z0-9_]*[^"]' "$script_file"; then
        echo "⚠️  发现未加引号的变量引用"
        ((issues++))
    fi
    
    echo "================================"
    if [ $issues -eq 0 ]; then
        echo "✅ 安全检查通过"
        return 0
    else
        echo "❌ 发现 $issues 个潜在安全问题"
        return 1
    fi
}
```

---

## 8. 📋 生产环境部署安全checklist


### 8.1 部署前安全检查


**🔐 完整的部署前检查流程**

```bash
#!/bin/bash
# 生产环境部署安全检查脚本

deployment_security_check() {
    local script_path="$1"
    local target_env="$2"
    local check_passed=0
    local total_checks=0
    
    echo "========================================"
    echo "生产环境部署安全检查"
    echo "脚本: $script_path"
    echo "环境: $target_env"
    echo "时间: $(date)"
    echo "========================================"
    
    # 检查1: 脚本文件存在性和权限
    echo "检查1: 脚本文件权限..."
    ((total_checks++))
    if [ -f "$script_path" ] && [ $(stat -c "%a" "$script_path") -eq 750 ]; then
        echo "✅ 脚本文件权限正确"
        ((check_passed++))
    else
        echo "❌ 脚本文件权限不正确"
    fi
    
    # 检查2: 代码审计结果
    echo "检查2: 代码审计..."
    ((total_checks++))
    if audit_script "$script_path"; then
        echo "✅ 代码审计通过"
        ((check_passed++))
    else
        echo "❌ 代码审计未通过"
    fi
    
    # 检查3: 依赖环境检查
    echo "检查3: 依赖环境..."
    ((total_checks++))
    if check_dependencies; then
        echo "✅ 依赖环境检查通过"
        ((check_passed++))
    else
        echo "❌ 依赖环境检查失败"
    fi
    
    # 检查4: 网络安全配置
    echo "检查4: 网络安全配置..."
    ((total_checks++))
    if check_network_security; then
        echo "✅ 网络安全配置正确"
        ((check_passed++))
    else
        echo "❌ 网络安全配置有问题"
    fi
    
    # 检查5: 日志和监控
    echo "检查5: 日志和监控配置..."
    ((total_checks++))
    if check_logging_monitoring; then
        echo "✅ 日志和监控配置完整"
        ((check_passed++))
    else
        echo "❌ 日志和监控配置不完整"
    fi
    
    # 生成检查报告
    echo "========================================"
    echo "检查结果汇总:"
    echo "通过: $check_passed/$total_checks"
    
    if [ $check_passed -eq $total_checks ]; then
        echo "🎉 所有检查通过，可以部署到生产环境"
        return 0
    else
        echo "⚠️  存在安全问题，不建议部署"
        return 1
    fi
}

# 依赖环境检查
check_dependencies() {
    local required_commands=("curl" "jq" "openssl" "gpg")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [ ${#missing_commands[@]} -gt 0 ]; then
        echo "缺少必需命令: ${missing_commands[*]}"
        return 1
    fi
    
    return 0
}

# 网络安全配置检查
check_network_security() {
    # 检查防火墙状态
    if command -v ufw >/dev/null 2>&1; then
        if ufw status | grep -q "Status: active"; then
            echo "防火墙已启用"
        else
            echo "警告: 防火墙未启用"
            return 1
        fi
    fi
    
    # 检查SSH配置
    if [ -f "/etc/ssh/sshd_config" ]; then
        if grep -q "PermitRootLogin no" "/etc/ssh/sshd_config"; then
            echo "SSH root登录已禁用"
        else
            echo "警告: SSH root登录未禁用"
            return 1
        fi
    fi
    
    return 0
}

# 日志和监控检查
check_logging_monitoring() {
    local log_dir="/var/log/myapp"
    
    # 检查日志目录
    if [ -d "$log_dir" ] && [ $(stat -c "%a" "$log_dir") -eq 750 ]; then
        echo "日志目录配置正确"
    else
        echo "日志目录配置错误"
        return 1
    fi
    
    # 检查日志轮转配置
    if [ -f "/etc/logrotate.d/myapp" ]; then
        echo "日志轮转配置存在"
    else
        echo "警告: 日志轮转配置不存在"
        return 1
    fi
    
    return 0
}
```

### 8.2 生产环境配置模板


**安全配置文件示例**：

```bash
# /etc/myapp/production.conf
# 生产环境安全配置文件

# 基本安全设置
SECURITY_LEVEL="strict"
DEBUG_MODE="false"
LOG_LEVEL="warn"

# 文件权限设置
SCRIPT_USER="myapp"
SCRIPT_GROUP="myapp"
DATA_DIR="/opt/myapp/data"
LOG_DIR="/var/log/myapp"

# 网络安全
ALLOWED_HOSTS="192.168.1.0/24,10.0.0.0/8"
MAX_CONNECTIONS="100"
TIMEOUT="30"

# 备份和恢复
BACKUP_RETENTION="30"
BACKUP_ENCRYPTION="true"
BACKUP_LOCATION="/secure/backup"

# 监控和告警
MONITOR_ENABLED="true"
ALERT_EMAIL="admin@company.com"
HEALTH_CHECK_INTERVAL="300"
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的安全要点


```
🔸 输入验证：所有外部输入必须验证和清理
🔸 权限最小化：只给予完成任务所需的最小权限
🔸 临时文件安全：使用mktemp，设置严格权限，及时清理
🔸 密码安全：绝不硬编码，使用安全存储和传输方式
🔸 完整性校验：使用哈希值或签名验证脚本完整性
🔸 安全编码：遵循防御式编程，完善错误处理
🔸 代码审计：定期审计代码，使用自动化工具
🔸 部署检查：生产环境部署前进行全面安全检查
```

### 9.2 安全编程核心思维


**🛡️ 防御式编程原则**：
```
假设输入都是恶意的 → 严格验证所有输入
假设环境是不安全的 → 最小化权限和暴露面  
假设代码会出错 → 完善的错误处理机制
假设被人攻击 → 多层防护和监控机制
```

**⚖️ 安全与便利的平衡**：
```
安全性要求：严格的验证和限制
便利性要求：简单易用的操作
平衡方案：在保证安全的前提下提供便利性
实现方法：自动化安全检查，友好的错误提示
```

### 9.3 实际应用价值


- **企业级脚本**：满足安全合规要求，降低安全风险
- **自动化运维**：提高系统稳定性，减少安全事故
- **数据处理**：保护敏感数据，防止数据泄露
- **系统集成**：安全的系统间交互，可信的数据传输

**🔑 记忆要点**：
- 安全是设计出来的，不是补救出来的
- 每一行代码都要考虑安全影响
- 最小权限原则贯穿始终
- 输入验证是第一道防线
- 定期审计和持续改进