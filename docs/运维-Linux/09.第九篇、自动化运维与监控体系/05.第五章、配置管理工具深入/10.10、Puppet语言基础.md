---
title: 10、Puppet语言基础
---
## 📚 目录

1. [Puppet DSL语法规则](#1-puppet-dsl语法规则)
2. [资源声明与属性](#2-资源声明与属性)
3. [类定义与继承机制](#3-类定义与继承机制)
4. [模块结构与命名空间](#4-模块结构与命名空间)
5. [变量作用域与优先级](#5-变量作用域与优先级)
6. [条件语句与选择器](#6-条件语句与选择器)
7. [函数定义与调用](#7-函数定义与调用)
8. [类型系统与验证](#8-类型系统与验证)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📝 Puppet DSL语法规则


### 1.1 什么是Puppet DSL


Puppet DSL（Domain Specific Language）是Puppet专门设计的**配置声明语言**，用来描述系统应该处于什么状态。

🔸 **核心理念**：**声明式编程** - 你只需要告诉Puppet"我要什么"，不用告诉它"怎么做"

```
传统命令式：                     Puppet声明式：
1. 创建用户                     user { 'webuser':
2. 设置密码                       ensure => present,
3. 设置家目录                     home   => '/home/webuser',
4. 设置shell                      shell  => '/bin/bash',
                                }
```

### 1.2 基本语法结构


**🔹 注释规则**
```puppet
# 这是单行注释
/* 这是多行注释
   可以跨越多行 */
```

**🔹 语句结束**
```puppet
# 大部分语句不需要分号，但建议加上
file { '/etc/motd':
  content => 'Welcome to the system',  # 行末逗号
}
```

**🔹 字符串类型**
```puppet
# 单引号字符串 - 不解析变量
$message = 'Hello $name'        # 输出: Hello $name

# 双引号字符串 - 解析变量  
$name = 'World'
$message = "Hello $name"        # 输出: Hello World

# 多行字符串
$config = @(END)
这是一个多行字符串
可以包含多行内容
| END
```

### 1.3 数据类型详解


**🔸 基本数据类型**

| 类型 | 示例 | 说明 |
|------|------|------|
| **String** | `'hello'`, `"world"` | 字符串，单双引号 |
| **Integer** | `42`, `-10` | 整数 |
| **Float** | `3.14`, `-0.5` | 浮点数 |
| **Boolean** | `true`, `false` | 布尔值 |
| **Array** | `[1, 2, 3]` | 数组 |
| **Hash** | `{'key' => 'value'}` | 哈希表 |

**🔸 高级数据类型**
```puppet
# 数组操作
$users = ['alice', 'bob', 'charlie']
$first_user = $users[0]           # 'alice'

# 哈希操作  
$config = {
  'server' => 'web01',
  'port'   => 80,
  'ssl'    => true,
}
$server_name = $config['server']  # 'web01'
```

---

## 2. 🏗️ 资源声明与属性


### 2.1 资源的概念


**资源**是Puppet管理的基本单位，代表系统中的**一个具体对象**，比如文件、用户、服务等。

```
现实世界映射：
文件 → file资源
用户 → user资源  
软件包 → package资源
服务 → service资源
```

### 2.2 资源声明语法


**🔸 基本语法结构**
```puppet
资源类型 { '资源名称':
  属性1 => 值1,
  属性2 => 值2,
}
```

**🔸 实际示例**
```puppet
# 管理一个配置文件
file { '/etc/nginx/nginx.conf':
  ensure  => present,           # 确保文件存在
  content => template('nginx/nginx.conf.erb'),
  owner   => 'root',            # 文件所有者
  group   => 'root',            # 文件组
  mode    => '0644',            # 文件权限
  notify  => Service['nginx'],  # 文件变更时重启nginx
}

# 管理系统用户
user { 'webuser':
  ensure     => present,        # 确保用户存在
  uid        => 1001,           # 用户ID
  gid        => 1001,           # 主组ID  
  home       => '/home/webuser',# 家目录
  shell      => '/bin/bash',    # 登录shell
  managehome => true,           # 管理家目录
}
```

### 2.3 常用资源类型


**📦 Package资源 - 软件包管理**
```puppet
package { 'nginx':
  ensure => installed,    # latest, absent, specific version
}

package { 'apache2':
  ensure => absent,       # 卸载软件包
}
```

**🔧 Service资源 - 服务管理** 
```puppet
service { 'nginx':
  ensure => running,      # stopped, running
  enable => true,         # 开机自启动
  subscribe => File['/etc/nginx/nginx.conf'],
}
```

**👤 User & Group资源**
```puppet
group { 'webapp':
  ensure => present,
  gid    => 1500,
}

user { 'webapp':
  ensure  => present,
  uid     => 1500,
  gid     => 'webapp',
  require => Group['webapp'],  # 依赖关系
}
```

### 2.4 资源关系与依赖


**🔸 依赖关系类型**

```
require  → 依赖（先执行依赖资源）
before   → 先于（在目标资源前执行）
notify   → 通知（变更时通知其他资源）
subscribe → 订阅（监听其他资源变更）
```

**🔸 实际应用示例**
```puppet
# Web服务器配置的完整依赖链
package { 'nginx':
  ensure => installed,
} ->                              # 链式依赖符号

file { '/etc/nginx/nginx.conf':
  ensure  => present,
  content => template('nginx/nginx.conf.erb'),
  require => Package['nginx'],    # 显式依赖
} ~>                              # 链式通知符号

service { 'nginx':
  ensure => running,
  enable => true,
}
```

---

## 3. 🏛️ 类定义与继承机制


### 3.1 类的基本概念


**类（Class）**是Puppet中**资源的集合**，把相关的配置组织在一起，方便复用和管理。

**🔸 为什么需要类？**
```
问题：如果直接写资源，代码会很混乱
解决：用类把相关资源组织起来

比如安装Web服务器需要：
- 安装软件包
- 配置文件
- 启动服务
- 创建用户
→ 把这些包装成一个 webserver 类
```

### 3.2 类定义语法


**🔸 基本定义**
```puppet
class webserver {
  # 安装nginx包
  package { 'nginx':
    ensure => installed,
  }
  
  # 配置文件
  file { '/etc/nginx/nginx.conf':
    ensure  => present,
    content => template('nginx/nginx.conf.erb'),
    require => Package['nginx'],
  }
  
  # 启动服务
  service { 'nginx':
    ensure    => running,
    enable    => true,
    subscribe => File['/etc/nginx/nginx.conf'],
  }
}
```

**🔸 带参数的类**
```puppet
class webserver(
  String $server_name = 'localhost',
  Integer $listen_port = 80,
  Boolean $ssl_enabled = false,
) {
  package { 'nginx':
    ensure => installed,
  }
  
  file { '/etc/nginx/nginx.conf':
    ensure  => present,
    content => epp('nginx/nginx.conf.epp', {
      'server_name'  => $server_name,
      'listen_port'  => $listen_port,
      'ssl_enabled'  => $ssl_enabled,
    }),
  }
}
```

### 3.3 类的使用方式


**🔸 include语句**
```puppet
# 简单包含，使用默认参数
include webserver
include mysql::server
```

**🔸 资源式声明**
```puppet
# 传递参数
class { 'webserver':
  server_name  => 'example.com',
  listen_port  => 8080,
  ssl_enabled  => true,
}
```

**🔸 类继承机制**
```puppet
# 基础类
class webserver::base {
  package { 'nginx':
    ensure => installed,
  }
  
  service { 'nginx':
    ensure => running,
    enable => true,
  }
}

# 继承并扩展
class webserver::ssl inherits webserver::base {
  # 重写父类资源
  Service['nginx'] {
    subscribe => File['/etc/nginx/ssl.conf'],
  }
  
  # 添加新资源
  file { '/etc/nginx/ssl.conf':
    ensure  => present,
    content => template('nginx/ssl.conf.erb'),
  }
}
```

### 3.4 类的最佳实践


**✅ 好的做法**
```puppet
# 1. 使用参数化类
class apache(
  String $server_admin = 'admin@localhost',
  Array $modules = ['rewrite', 'ssl'],
) { }

# 2. 合理的类命名
class profiles::webserver { }      # 角色配置
class roles::frontend { }          # 业务角色

# 3. 单一职责原则
class nginx::install { }           # 只负责安装
class nginx::config { }            # 只负责配置
class nginx::service { }           # 只负责服务
```

---

## 4. 📦 模块结构与命名空间


### 4.1 模块是什么


**模块（Module）**是Puppet代码的**打包单位**，包含了类、函数、文件等资源，是代码复用和分享的基础。

```
模块就像一个工具箱：
├── manifests/     # 放Puppet代码(.pp文件)
├── files/         # 放静态文件
├── templates/     # 放模板文件
├── lib/          # 放自定义函数和类型
└── metadata.json  # 模块信息
```

### 4.2 标准模块目录结构


```
nginx/                          # 模块名称
├── manifests/                  # 主要代码目录
│   ├── init.pp                # 主类文件(nginx)
│   ├── install.pp             # 安装类(nginx::install)
│   ├── config.pp              # 配置类(nginx::config)
│   ├── service.pp             # 服务类(nginx::service)
│   └── params.pp              # 参数类(nginx::params)
├── files/                      # 静态文件
│   ├── nginx.conf
│   └── default.conf
├── templates/                  # 模板文件
│   ├── nginx.conf.erb
│   └── vhost.conf.epp
├── lib/                        # Ruby代码
│   ├── puppet/
│   │   ├── functions/         # 自定义函数
│   │   └── type/              # 自定义资源类型
├── spec/                       # 测试文件
├── metadata.json              # 模块元数据
└── README.md                  # 说明文档
```

### 4.3 命名空间机制


**🔸 命名空间规则**
```puppet
# 模块名: nginx
# 主类: nginx (在init.pp中定义)
# 子类: nginx::install, nginx::config, nginx::service

模块名称 = 命名空间前缀
文件路径对应类名：
manifests/init.pp     → nginx
manifests/install.pp  → nginx::install  
manifests/config.pp   → nginx::config
manifests/vhost.pp    → nginx::vhost
```

**🔸 实际示例**

**manifests/init.pp** - 主类文件
```puppet
# nginx模块的主入口
class nginx(
  String $package_name = $nginx::params::package_name,
  String $service_name = $nginx::params::service_name,
) inherits nginx::params {
  
  include nginx::install
  include nginx::config
  include nginx::service
  
  # 建立依赖关系
  Class['nginx::install']
  -> Class['nginx::config']
  ~> Class['nginx::service']
}
```

**manifests/install.pp** - 安装类
```puppet
class nginx::install {
  package { $nginx::package_name:
    ensure => installed,
  }
}
```

**manifests/params.pp** - 参数类
```puppet
class nginx::params {
  case $facts['os']['family'] {
    'RedHat': {
      $package_name = 'nginx'
      $service_name = 'nginx'
      $config_dir   = '/etc/nginx'
    }
    'Debian': {
      $package_name = 'nginx'
      $service_name = 'nginx'  
      $config_dir   = '/etc/nginx'
    }
    default: {
      fail("不支持的操作系统: ${facts['os']['family']}")
    }
  }
}
```

### 4.4 模块的使用与管理


**🔸 使用Puppet Forge模块**
```bash
# 安装官方模块
puppet module install puppetlabs-nginx

# 查看已安装模块
puppet module list

# 升级模块
puppet module upgrade puppetlabs-nginx
```

**🔸 在代码中使用模块**
```puppet
# site.pp 或其他manifest文件中
node 'web01.example.com' {
  # 使用nginx模块
  class { 'nginx':
    worker_processes => 4,
    worker_connections => 1024,
  }
  
  # 使用子类
  include nginx::install
  include nginx::config
}
```

---

## 5. 📊 变量作用域与优先级


### 5.1 变量基础知识


**🔸 变量声明**
```puppet
# 局部变量
$package_name = 'nginx'
$version = '1.18.0'

# 全局变量(顶级作用域)
$::global_var = 'global value'

# 事实变量(系统信息)
$os_family = $facts['os']['family']
```

### 5.2 作用域层级


```
作用域层次结构：
全局作用域 (Global Scope)
    ├── 节点作用域 (Node Scope)  
    │   ├── 类作用域 (Class Scope)
    │   │   └── 局部作用域 (Local Scope)
    │   └── 定义作用域 (Defined Type Scope)
    └── 其他类作用域
```

**🔸 实际示例**
```puppet
# 全局作用域
$global_config = '/etc/app'

# 节点作用域  
node 'web01.example.com' {
  $node_role = 'frontend'
  
  # 类作用域
  class webserver {
    $class_var = 'webserver config'
    
    # 局部作用域
    if $facts['os']['family'] == 'RedHat' {
      $local_package = 'httpd'
    } else {
      $local_package = 'apache2'  
    }
  }
}
```

### 5.3 变量优先级规则


**🔸 优先级从高到低**

```
1. 局部作用域变量 (Local Scope)
2. 类参数 (Class Parameters)  
3. 类作用域变量 (Class Scope)
4. 节点作用域变量 (Node Scope)
5. 顶级作用域变量 (Top Scope)
6. 继承的变量 (Inherited Variables)
```

**🔸 优先级示例**
```puppet
# 顶级作用域
$message = 'global message'

class example(
  String $message = 'parameter message',  # 参数默认值
) {
  $message = 'class message'              # 类变量
  
  if true {
    $message = 'local message'            # 局部变量(最高优先级)
    notice($message)                      # 输出: local message
  }
}
```

### 5.4 变量访问技巧


**🔸 显式作用域引用**
```puppet
class apache {
  $config_dir = '/etc/apache2'
}

class nginx {
  # 访问其他类的变量
  $apache_config = $apache::config_dir
  
  # 访问顶级作用域变量
  $global_value = $::some_global_var
  
  # 访问事实变量
  $hostname = $facts['networking']['hostname']
}
```

---

## 6. 🔄 条件语句与选择器


### 6.1 if条件语句


**🔸 基本if语句**
```puppet
if $facts['os']['family'] == 'RedHat' {
  $package_name = 'httpd'
  $service_name = 'httpd'
} elsif $facts['os']['family'] == 'Debian' {
  $package_name = 'apache2'
  $service_name = 'apache2'
} else {
  fail('不支持的操作系统')
}
```

**🔸 布尔判断**
```puppet
# 检查变量是否定义
if $ssl_enabled {
  file { '/etc/ssl/certs':
    ensure => directory,
  }
}

# 检查空值
if $config_content != undef and $config_content != '' {
  file { '/etc/myapp/config':
    content => $config_content,
  }
}
```

### 6.2 case语句


**🔸 基本case语句**
```puppet
case $facts['os']['family'] {
  'RedHat': {
    $package_name = 'nginx'
    $config_path = '/etc/nginx/nginx.conf'
  }
  'Debian': {
    $package_name = 'nginx'  
    $config_path = '/etc/nginx/nginx.conf'
  }
  'FreeBSD': {
    $package_name = 'nginx'
    $config_path = '/usr/local/etc/nginx/nginx.conf'
  }
  default: {
    fail("不支持的操作系统: ${facts['os']['family']}")
  }
}
```

**🔸 正则表达式匹配**
```puppet
case $facts['networking']['hostname'] {
  /^web\d+/: {
    $server_role = 'webserver'
  }
  /^db\d+/: {
    $server_role = 'database'  
  }
  /^lb\d+/: {
    $server_role = 'loadbalancer'
  }
  default: {
    $server_role = 'unknown'
  }
}
```

### 6.3 选择器表达式


**选择器**是一种**简洁的条件赋值**方式，类似三元运算符。

**🔸 基本选择器**
```puppet
# 语法: condition ? { value1 => result1, value2 => result2, default => result3 }

$package_name = $facts['os']['family'] ? {
  'RedHat' => 'httpd',
  'Debian' => 'apache2',
  default  => 'apache',
}

$service_command = $ssl_enabled ? {
  true    => '/usr/sbin/nginx -s reload',
  false   => '/usr/sbin/nginx -t && /usr/sbin/nginx -s reload',  
  default => '/usr/sbin/nginx -s reload',
}
```

**🔸 复杂选择器**
```puppet
# 多条件选择器
$mysql_config = "${facts['os']['family']}-${facts['os']['release']['major']}" ? {
  'RedHat-7' => '/etc/mysql/mysql.conf.d/mysqld.cnf',
  'RedHat-8' => '/etc/mysql/mysql.conf.d/mysqld.cnf',
  'Ubuntu-18' => '/etc/mysql/mysql.conf.d/mysqld.cnf',
  'Ubuntu-20' => '/etc/mysql/mysql.conf.d/mysqld.cnf',
  default    => '/etc/mysql/my.cnf',
}
```

### 6.4 条件语句最佳实践


**✅ 推荐做法**
```puppet
# 1. 使用params类管理平台差异
class nginx::params {
  case $facts['os']['family'] {
    'RedHat': { $config_dir = '/etc/nginx' }
    'Debian': { $config_dir = '/etc/nginx' }
    default:  { fail('不支持的系统') }
  }
}

# 2. 条件逻辑简洁明了
$enable_ssl = $ssl_cert_path ? {
  undef   => false,
  ''      => false, 
  default => true,
}

# 3. 错误处理
if $required_param == undef {
  fail('必须提供 required_param 参数')
}
```

---

## 7. 🛠️ 函数定义与调用


### 7.1 内置函数


**🔸 字符串函数**
```puppet
# 字符串操作
$upper_name = upcase('hello world')           # HELLO WORLD
$lower_name = downcase('HELLO WORLD')         # hello world  
$trimmed = strip(' hello world ')             # hello world

# 字符串模板
$message = sprintf('Hello %s, you are %d years old', 'Alice', 25)
```

**🔸 数组和哈希函数**
```puppet
$users = ['alice', 'bob', 'charlie']
$user_count = length($users)                  # 3
$first_user = $users[0]                       # alice

$config = {'server' => 'web01', 'port' => 80}
$keys = keys($config)                         # ['server', 'port']
$has_port = has_key($config, 'port')          # true
```

**🔸 类型检查函数**
```puppet
$is_string = is_string($hostname)             # true/false
$is_array = is_array($users)                  # true/false
$is_empty = empty($config)                    # true/false
```

### 7.2 模板函数


**🔸 ERB模板**
```puppet
# 使用ERB模板
file { '/etc/nginx/nginx.conf':
  content => template('nginx/nginx.conf.erb'),
}

# templates/nginx.conf.erb文件内容
user <%= @nginx_user %>;
worker_processes <%= @worker_processes %>;
server_name <%= @server_name %>;
```

**🔸 EPP模板（推荐）**
```puppet
# 使用EPP模板（Puppet 4+推荐）
file { '/etc/nginx/nginx.conf':
  content => epp('nginx/nginx.conf.epp', {
    'nginx_user'        => 'nginx',
    'worker_processes'  => 4,
    'server_name'       => 'example.com',
  }),
}

# templates/nginx.conf.epp文件内容  
user <%= $nginx_user %>;
worker_processes <%= $worker_processes %>;
server_name <%= $server_name %>;
```

### 7.3 自定义函数


**🔸 简单函数定义**

**lib/puppet/functions/mymodule/calculate_workers.rb**
```ruby
# Ruby 4.x API自定义函数
Puppet::Functions.create_function(:'mymodule::calculate_workers') do
  # 函数文档
  dispatch :calculate_workers do
    param 'Integer', :cpu_count
    param 'Float', :load_factor
    return_type 'Integer'
  end

  def calculate_workers(cpu_count, load_factor = 1.5)
    (cpu_count * load_factor).round
  end
end
```

**🔸 在Puppet代码中使用**
```puppet
$cpu_count = $facts['processors']['count']
$workers = mymodule::calculate_workers($cpu_count, 1.2)

class nginx {
  file { '/etc/nginx/nginx.conf':
    content => epp('nginx/nginx.conf.epp', {
      'worker_processes' => $workers,
    }),
  }
}
```

### 7.4 函数调用技巧


**🔸 链式调用**
```puppet
# 处理数组数据
$cleaned_users = $raw_users.filter |$user| { $user != '' }
                           .map |$user| { downcase($user) }
                           .unique()

# 等价于传统写法
$step1 = filter($raw_users) |$user| { $user != '' }
$step2 = map($step1) |$user| { downcase($user) }
$cleaned_users = unique($step2)
```

---

## 8. 🔍 类型系统与验证


### 8.1 Puppet数据类型


**🔸 基础类型**
```puppet
# 字符串类型和约束
String                          # 任意字符串
String[1]                       # 非空字符串  
String[1,50]                    # 长度1-50的字符串
Pattern[/^\d+$/]                # 匹配正则的字符串

# 数值类型
Integer                         # 任意整数
Integer[0]                      # 非负整数
Integer[1,100]                  # 1到100的整数
Float[0.0,1.0]                 # 0到1的浮点数
```

**🔸 集合类型**
```puppet
# 数组类型
Array                          # 任意数组
Array[String]                  # 字符串数组
Array[String, 1]               # 非空字符串数组
Array[Integer, 1, 10]          # 1-10个整数的数组

# 哈希类型  
Hash                           # 任意哈希
Hash[String, String]           # 字符串键值哈希
Hash[String, Integer, 1, 5]    # 1-5个条目的哈希
```

### 8.2 类型验证


**🔸 参数类型验证**
```puppet
class webserver(
  String[1] $server_name,                    # 必需的非空字符串
  Integer[1,65535] $port = 80,              # 端口号范围
  Array[String[1]] $modules = [],            # 字符串数组
  Hash[String, String] $config = {},         # 配置哈希
  Optional[String] $ssl_cert = undef,        # 可选字符串
  Boolean $debug_mode = false,               # 布尔值
) {
  # 类实现...
}
```

**🔸 运行时类型检查**
```puppet
# assert_type函数进行类型检查
$validated_port = assert_type(Integer[1,65535], $input_port)

# 类型检查失败时的处理
if $input_data =~ String {
  $processed_data = $input_data
} else {
  fail('输入数据必须是字符串类型')
}
```

### 8.3 自定义类型


**🔸 类型别名**
```puppet
# 在模块中定义类型别名 (types/port.pp)
type MyModule::Port = Integer[1,65535]

# 使用自定义类型
class myservice(
  MyModule::Port $listen_port = 8080,
) {
  # ...
}
```

**🔸 复杂类型定义**
```puppet
# types/serverconfig.pp
type MyModule::ServerConfig = Struct[{
  'name'        => String[1],
  'port'        => Integer[1,65535], 
  'ssl_enabled' => Boolean,
  'modules'     => Array[String[1]],
  'workers'     => Optional[Integer[1,100]],
}]

# 使用结构化类型
class loadbalancer(
  Array[MyModule::ServerConfig] $backend_servers,
) {
  $backend_servers.each |$server| {
    # $server 已经过类型验证
    nginx::upstream::server { $server['name']:
      server => "${server['name']}:${server['port']}",
    }
  }
}
```

### 8.4 类型系统最佳实践


**✅ 推荐做法**
```puppet
# 1. 为所有参数定义类型
class database(
  String[1] $db_name,                        # 明确类型约束
  String[1] $username,
  Sensitive[String[1]] $password,            # 敏感数据类型
  Enum['mysql', 'postgresql'] $engine,       # 枚举类型
) { }

# 2. 使用适当的类型约束
class monitoring(
  Integer[1,3600] $check_interval = 60,      # 合理的数值范围
  Pattern[/^https?:\/\//] $webhook_url,      # URL格式验证
) { }

# 3. 为复杂数据定义结构
type MyApp::Config = Hash[
  String[1],                                 # 配置项名
  Variant[String, Integer, Boolean]          # 配置项值类型
]
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Puppet DSL：声明式配置语言，描述期望状态
🔸 资源管理：系统对象的抽象，包含类型、名称和属性
🔸 类与模块：代码组织和复用的基本单位
🔸 变量作用域：理解变量的可见性和优先级
🔸 条件控制：if/case语句和选择器的使用
🔸 函数系统：内置函数和自定义函数的应用
🔸 类型验证：保证数据安全性和代码质量
```

### 9.2 语法要点记忆


**🔹 基础语法记忆**
```puppet
# 资源声明模式
type { 'name':
  attribute => value,
}

# 类定义模式  
class name(parameters) {
  # resources
}

# 条件判断模式
if condition { } elsif condition { } else { }
case variable { value => {}, default => {} }
variable ? { value => result, default => result }
```

**🔹 作用域优先级**
```
局部 > 参数 > 类 > 节点 > 全局 > 继承
Local > Params > Class > Node > Top > Inherited
```

### 9.3 最佳实践要点


**✅ 代码组织**
- 使用模块组织相关功能
- 一个类只负责一个功能
- 参数化所有可变的配置

**✅ 类型安全**
- 为所有参数定义类型
- 使用适当的类型约束
- 处理可选参数的默认值

**✅ 错误处理**
- 验证必需参数
- 为不支持的平台提供错误信息
- 使用合理的默认值

### 9.4 实际应用场景


**🎯 Web服务器配置**
- 跨平台软件包管理
- 配置文件模板化
- 服务依赖关系管理

**🎯 用户权限管理**  
- 批量用户创建
- 权限统一配置
- 密钥分发管理

**🎯 应用部署**
- 环境配置标准化
- 多环境差异管理
- 配置变更自动化

**核心记忆要点**：
- Puppet是**声明式**语言：描述"要什么"而不是"怎么做"
- **资源**是管理的基本单位，**类**是资源的集合
- **模块**是代码复用的包装，**命名空间**避免冲突
- **类型系统**保证配置安全，**条件语句**处理平台差异