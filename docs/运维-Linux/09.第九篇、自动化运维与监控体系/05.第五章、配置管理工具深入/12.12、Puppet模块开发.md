---
title: 12、Puppet模块开发
---
## 📚 目录

1. [Puppet模块基础概念](#1-Puppet模块基础概念)
2. [模块目录结构规范](#2-模块目录结构规范)
3. [Manifest文件组织](#3-Manifest文件组织)
4. [模板系统使用](#4-模板系统使用)
5. [文件服务配置](#5-文件服务配置)
6. [模块元数据定义](#6-模块元数据定义)
7. [依赖关系管理](#7-依赖关系管理)
8. [模块测试框架](#8-模块测试框架)
9. [Puppet Forge发布](#9-Puppet-Forge发布)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 Puppet模块基础概念


### 1.1 什么是Puppet模块


**简单理解**：Puppet模块就是把相关的配置代码打包在一起的"工具包"

```
类比理解：
模块 = 一个完整的软件包
├── 安装说明书（manifest）
├── 配置模板（templates）  
├── 静态文件（files）
└── 说明文档（metadata）

就像安装一个软件，模块包含了所有需要的东西
```

**🔸 模块的作用**
- **代码复用**：写一次，到处使用
- **逻辑分组**：相关功能放在一起管理
- **版本控制**：可以独立更新和维护
- **共享交流**：可以发布给其他人使用

### 1.2 模块vs类的区别


| 概念 | **用途** | **包含内容** | **示例** |
|------|---------|-------------|---------|
| **类(Class)** | `单一功能配置` | `资源定义` | `安装nginx` |
| **模块(Module)** | `完整解决方案` | `类+文件+模板+文档` | `完整的nginx服务` |

**通俗解释**：
- **类**：像一个函数，做一件具体的事
- **模块**：像一个完整的程序，包含多个函数和资源

### 1.3 模块命名规范


```
命名规则：作者-模块名
例如：puppetlabs-apache, example-nginx

避免使用的字符：
❌ 大写字母、空格、特殊符号
✅ 小写字母、数字、连字符
```

---

## 2. 📁 模块目录结构规范


### 2.1 标准目录结构


```
nginx/                          ← 模块根目录
├── manifests/                  ← Puppet代码目录
│   ├── init.pp                ← 主类文件（必须）
│   ├── install.pp             ← 安装相关类
│   ├── config.pp              ← 配置相关类
│   └── service.pp             ← 服务相关类
├── templates/                  ← 模板文件目录
│   ├── nginx.conf.erb         ← 主配置模板
│   └── vhost.conf.erb         ← 虚拟主机模板
├── files/                     ← 静态文件目录
│   ├── nginx.conf             ← 静态配置文件
│   └── ssl/                   ← SSL证书文件
├── lib/                       ← Ruby库目录
│   └── puppet/                ← Puppet扩展
├── spec/                      ← 测试文件目录
│   └── classes/               ← 类测试文件
├── examples/                  ← 使用示例
│   └── init.pp               ← 示例代码
├── metadata.json             ← 模块元数据（必须）
└── README.md                 ← 说明文档
```

### 2.2 目录作用详解


**🔸 manifests/ - 核心代码目录**
```
作用：存放所有Puppet类和定义
规则：
- init.pp是入口文件，定义主类
- 其他.pp文件定义子类
- 文件名必须与类名对应
```

**🔸 templates/ - 动态配置模板**  
```
作用：存放ERB模板文件
特点：可以使用变量，动态生成配置
扩展名：通常是.erb
```

**🔸 files/ - 静态资源文件**
```
作用：存放不需要修改的文件
用途：证书、脚本、配置文件等
访问：通过puppet:///modules/模块名/文件路径
```

### 2.3 创建模块目录的方法


**方法一：手动创建**
```bash
mkdir -p nginx/{manifests,templates,files,spec,examples}
touch nginx/manifests/init.pp
touch nginx/metadata.json
```

**方法二：使用PDK工具**
```bash
# 安装PDK（Puppet开发工具包）
puppet resource package pdk ensure=installed

# 创建新模块
pdk new module nginx
cd nginx

# 创建新类
pdk new class nginx::install
```

> 💡 **小贴士**：推荐使用PDK工具，它会自动创建标准结构和必要文件

---

## 3. 📄 Manifest文件组织


### 3.1 init.pp主类设计


**init.pp的作用**：模块的入口点，定义主类

```puppet
# manifests/init.pp
class nginx (
  String $package_name = 'nginx',
  String $service_name = 'nginx',
  String $config_file = '/etc/nginx/nginx.conf',
  Boolean $service_enable = true,
  Enum['running', 'stopped'] $service_ensure = 'running',
) {

  # 包含其他类，实现功能组合
  contain nginx::install
  contain nginx::config  
  contain nginx::service

  # 定义类之间的依赖关系
  Class['nginx::install'] 
  -> Class['nginx::config']
  ~> Class['nginx::service']
}
```

**🔸 设计要点**：
- **参数化**：通过参数控制行为
- **模块化**：拆分为多个专门的类
- **依赖管理**：明确类之间的执行顺序

### 3.2 功能类的拆分


**install.pp - 软件包安装**
```puppet
# manifests/install.pp
class nginx::install {
  package { $nginx::package_name:
    ensure => 'installed',
  }
}
```

**config.pp - 配置文件管理**
```puppet
# manifests/config.pp  
class nginx::config {
  file { $nginx::config_file:
    ensure  => 'file',
    content => template('nginx/nginx.conf.erb'),
    owner   => 'root',
    group   => 'root',
    mode    => '0644',
    require => Class['nginx::install'],
  }
}
```

**service.pp - 服务管理**
```puppet
# manifests/service.pp
class nginx::service {
  service { $nginx::service_name:
    ensure => $nginx::service_ensure,
    enable => $nginx::service_enable,
  }
}
```

### 3.3 定义类型(Define)的使用


**什么是定义类型**：可以重复使用的代码块，类似于函数

```puppet
# manifests/vhost.pp
define nginx::vhost (
  String $port = '80',
  String $docroot = "/var/www/${title}",
  String $template = 'nginx/vhost.conf.erb',
) {
  
  # 创建虚拟主机配置文件
  file { "/etc/nginx/sites-available/${title}":
    ensure  => 'file',
    content => template($template),
    notify  => Service['nginx'],
  }
  
  # 启用站点
  file { "/etc/nginx/sites-enabled/${title}":
    ensure => 'link',
    target => "/etc/nginx/sites-available/${title}",
  }
}
```

**使用定义类型**：
```puppet
# 创建多个虚拟主机
nginx::vhost { 'example.com':
  port    => '80',
  docroot => '/var/www/example',
}

nginx::vhost { 'test.com':
  port    => '8080', 
  docroot => '/var/www/test',
}
```

---

## 4. 🎨 模板系统使用


### 4.1 ERB模板基础


**什么是ERB**：Embedded Ruby，在文本中嵌入Ruby代码的模板系统

**基本语法**：
```erb
<% Ruby代码 %>          ← 执行代码，不输出
<%= Ruby表达式 %>       ← 执行并输出结果
<%# 注释内容 %>         ← 注释，不会出现在结果中
```

### 4.2 在模板中使用变量


**模板文件示例**：
```erb
# templates/nginx.conf.erb
user <%= @user || 'nginx' %>;
worker_processes <%= @worker_processes || 'auto' %>;

events {
    worker_connections <%= @worker_connections || '1024' %>;
}

http {
    # 基本设置
    sendfile on;
    tcp_nopush on;
    
    # 服务器配置
    <% if @enable_gzip %>
    gzip on;
    gzip_vary on;
    <% end %>
    
    # 虚拟主机配置
    <% @virtual_hosts.each do |vhost| %>
    server {
        listen <%= vhost['port'] %>;
        server_name <%= vhost['name'] %>;
        root <%= vhost['docroot'] %>;
    }
    <% end %>
}
```

**在manifest中传递变量**：
```puppet
class nginx::config {
  file { '/etc/nginx/nginx.conf':
    ensure  => 'file',
    content => template('nginx/nginx.conf.erb'),
  }
}
```

> 📝 **变量说明**：模板中的`@变量名`自动对应类中的`$变量名`

### 4.3 模板中的逻辑控制


**条件判断**：
```erb
<% if @ssl_enabled %>
server {
    listen 443 ssl;
    ssl_certificate <%= @ssl_cert_file %>;
    ssl_certificate_key <%= @ssl_key_file %>;
}
<% else %>
server {
    listen 80;
}
<% end %>
```

**循环处理**：
```erb
# 处理数组
<% @server_names.each do |name| %>
server_name <%= name %>;
<% end %>

# 处理哈希
<% @locations.each do |path, config| %>
location <%= path %> {
    <% config.each do |key, value| %>
    <%= key %> <%= value %>;
    <% end %>
}
<% end %>
```

### 4.4 模板最佳实践


**🔸 变量检查和默认值**
```erb
worker_processes <%= @worker_processes || scope['::processorcount'] %>;
```

**🔸 复杂逻辑提取到manifest**
```puppet
# 在manifest中处理复杂逻辑
$real_worker_processes = $worker_processes ? {
  'auto'  => $facts['processorcount'],
  undef   => $facts['processorcount'], 
  default => $worker_processes,
}
```

**🔸 模板注释**
```erb
<%# 这是模板注释，不会出现在最终文件中 %>
# 这是配置文件注释，会出现在最终文件中
```

---

## 5. 📦 文件服务配置


### 5.1 静态文件管理


**files目录的作用**：存放不需要模板处理的静态文件

**目录结构示例**：
```
files/
├── ssl/
│   ├── nginx.crt
│   └── nginx.key  
├── scripts/
│   └── nginx-logrotate.sh
└── default-configs/
    └── default.conf
```

### 5.2 在manifest中使用文件


**基本用法**：
```puppet
file { '/etc/nginx/ssl/nginx.crt':
  ensure => 'file',
  source => 'puppet:///modules/nginx/ssl/nginx.crt',
  owner  => 'root',
  group  => 'nginx',
  mode   => '0644',
}
```

**批量文件管理**：
```puppet
file { '/etc/nginx/conf.d/':
  ensure  => 'directory',
  source  => 'puppet:///modules/nginx/conf.d/',
  recurse => true,
  purge   => true,
  owner   => 'root',
  group   => 'nginx',
  mode    => '0644',
}
```

### 5.3 文件服务的URL格式


**URL格式解析**：
```
puppet:///modules/模块名/文件路径

示例：
puppet:///modules/nginx/ssl/nginx.crt
       ↑      ↑     ↑    ↑
    协议   模块路径  模块名 文件路径
```

**特殊用法**：
```puppet
# 根据操作系统选择不同文件
source => [
  "puppet:///modules/nginx/configs/${facts['os']['family']}/nginx.conf",
  "puppet:///modules/nginx/configs/default/nginx.conf",
]
```

---

## 6. 📋 模块元数据定义


### 6.1 metadata.json文件详解


**metadata.json的作用**：定义模块的基本信息和依赖关系

```json
{
  "name": "example-nginx",
  "version": "1.0.0",
  "author": "Your Name",
  "summary": "Nginx web server management module",
  "license": "Apache-2.0",
  "source": "https://github.com/yourusername/puppet-nginx",
  "project_page": "https://github.com/yourusername/puppet-nginx",
  "issues_url": "https://github.com/yourusername/puppet-nginx/issues",
  
  "operatingsystem_support": [
    {
      "operatingsystem": "Ubuntu",
      "operatingsystemrelease": ["18.04", "20.04", "22.04"]
    },
    {
      "operatingsystem": "CentOS", 
      "operatingsystemrelease": ["7", "8"]
    }
  ],
  
  "requirements": [
    {
      "name": "puppet",
      "version_requirement": ">= 6.0.0 < 8.0.0"
    }
  ],
  
  "dependencies": [
    {
      "name": "puppetlabs/stdlib",
      "version_requirement": ">= 6.0.0 < 9.0.0"
    }
  ]
}
```

### 6.2 关键字段说明


| 字段 | **必需** | **说明** | **示例** |
|------|---------|---------|---------|
| `name` | ✅ | `模块标识名` | `example-nginx` |
| `version` | ✅ | `版本号` | `1.0.0` |
| `author` | ✅ | `作者信息` | `Your Name` |
| `summary` | ✅ | `简短描述` | `Nginx管理模块` |
| `license` | ✅ | `开源许可` | `Apache-2.0` |
| `dependencies` | ❌ | `依赖模块` | `stdlib模块` |

### 6.3 版本号规范


**语义化版本(SemVer)**：
```
主版本.次版本.补丁版本
    ↓      ↓      ↓
   1.0.0

主版本：不兼容的API修改
次版本：向后兼容的功能性新增  
补丁版本：向后兼容的问题修正
```

**版本约束表达式**：
```
>= 1.0.0      # 大于等于1.0.0
< 2.0.0       # 小于2.0.0  
~> 1.2.0      # >= 1.2.0 且 < 1.3.0
```

---

## 7. 🔗 依赖关系管理


### 7.1 依赖关系的类型


**🔸 模块依赖**：一个模块需要另一个模块才能正常工作
```json
"dependencies": [
  {
    "name": "puppetlabs/stdlib",
    "version_requirement": ">= 6.0.0"
  }
]
```

**🔸 类依赖**：类之间的执行顺序关系
```puppet
Class['nginx::install'] 
-> Class['nginx::config']     # install完成后执行config
~> Class['nginx::service']    # config变化时通知service
```

### 7.2 依赖关系操作符


**依赖关系符号含义**：
```puppet
# 顺序依赖（->）
A -> B    # A必须在B之前执行

# 通知依赖（~>）  
A ~> B    # A变化时通知B刷新

# require和before
class nginx::config {
  file { '/etc/nginx/nginx.conf':
    require => Class['nginx::install'],  # 需要install类先执行
    notify  => Service['nginx'],         # 变化时通知service
  }
}

class nginx::install {
  package { 'nginx':
    before => File['/etc/nginx/nginx.conf'],  # 在文件资源前执行
  }
}
```

### 7.3 contain vs include的区别


**include的问题**：
```puppet
class nginx {
  include nginx::install
  include nginx::config
}

# 问题：被include的类不受外部依赖关系约束
Class['some_other_class'] -> Class['nginx']
# nginx::install和nginx::config可能在some_other_class之前执行！
```

**contain的解决方案**：
```puppet
class nginx {
  contain nginx::install
  contain nginx::config
  
  # 现在依赖关系正确传播
  Class['nginx::install'] -> Class['nginx::config']
}

# 现在工作正常
Class['some_other_class'] -> Class['nginx']
```

> ⚠️ **重要提醒**：在模块开发中优先使用`contain`而不是`include`

---

## 8. 🧪 模块测试框架


### 8.1 测试的重要性


**为什么需要测试**：
- **质量保证**：确保代码按预期工作
- **回归检测**：防止修改破坏现有功能  
- **文档作用**：测试即是使用示例
- **重构信心**：安全地改进代码

### 8.2 rspec-puppet测试基础


**安装测试工具**：
```bash
gem install rspec-puppet
gem install puppetlabs_spec_helper
```

**基本测试结构**：
```ruby
# spec/classes/nginx_spec.rb
require 'spec_helper'

describe 'nginx' do
  context 'with default parameters' do
    it { should compile }
    it { should contain_package('nginx') }
    it { should contain_service('nginx').with_ensure('running') }
    it { should contain_file('/etc/nginx/nginx.conf') }
  end
  
  context 'with custom parameters' do
    let(:params) do
      {
        'package_name' => 'nginx-full',
        'service_ensure' => 'stopped'
      }
    end
    
    it { should contain_package('nginx-full') }
    it { should contain_service('nginx').with_ensure('stopped') }
  end
end
```

### 8.3 测试用例编写


**基础测试类型**：

**🔸 编译测试**：
```ruby
it { should compile }                    # 检查语法正确性
it { should compile.with_all_deps }      # 检查包含依赖的编译
```

**🔸 资源存在性测试**：
```ruby
it { should contain_package('nginx') }
it { should contain_service('nginx') }
it { should contain_file('/etc/nginx/nginx.conf') }
```

**🔸 资源属性测试**：
```ruby
it { should contain_file('/etc/nginx/nginx.conf').with({
  'owner' => 'root',
  'group' => 'root', 
  'mode'  => '0644'
}) }
```

**🔸 依赖关系测试**：
```ruby
it { should contain_package('nginx').that_comes_before('File[/etc/nginx/nginx.conf]') }
it { should contain_file('/etc/nginx/nginx.conf').that_notifies('Service[nginx]') }
```

### 8.4 运行测试


**执行测试命令**：
```bash
# 运行所有测试
rake spec

# 运行特定测试文件
rspec spec/classes/nginx_spec.rb

# 查看测试覆盖率
rake spec SPEC_OPTS="--format RspecJunitFormatter --out reports/rspec.xml"
```

**测试输出示例**：
```
nginx
  with default parameters
    ✓ should compile
    ✓ should contain Package[nginx]
    ✓ should contain Service[nginx] with ensure => "running"
    ✓ should contain File[/etc/nginx/nginx.conf]

Finished in 0.5 seconds (files took 2.1 seconds to load)
4 examples, 0 failures
```

---

## 9. 📤 Puppet Forge发布


### 9.1 什么是Puppet Forge


**Puppet Forge简介**：Puppet官方的模块仓库，类似于软件包管理器

```
功能对比：
Puppet Forge  ←→  模块仓库
apt/yum      ←→  软件包仓库  
npm          ←→  Node.js包仓库
pip          ←→  Python包仓库
```

**访问地址**：https://forge.puppet.com

### 9.2 发布前的准备工作


**🔸 完善文档**：
```markdown
# README.md 必须包含的内容
- 模块描述和功能
- 安装方法
- 使用示例  
- 参数说明
- 限制和已知问题
- 开发和贡献指南
```

**🔸 检查metadata.json**：
```json
{
  "name": "yourname-nginx",           # 必须符合命名规范
  "version": "1.0.0",                # 遵循语义化版本
  "summary": "清晰的模块描述",          # 简洁明了
  "license": "Apache-2.0",           # 明确开源协议
  "operatingsystem_support": [...],   # 支持的操作系统
  "dependencies": [...]               # 正确的依赖关系
}
```

### 9.3 发布流程


**步骤1：创建Forge账号**
```bash
# 访问 https://forge.puppet.com 注册账号
# 获取API Token用于命令行操作
```

**步骤2：构建模块包**
```bash
# 使用PDK构建
pdk build

# 或手动构建
puppet module build .

# 生成 yourname-nginx-1.0.0.tar.gz 文件
```

**步骤3：上传到Forge**
```bash
# 通过网页界面上传，或使用命令行
puppet module push yourname-nginx-1.0.0.tar.gz
```

### 9.4 发布后的维护


**版本管理**：
```
发布流程：
开发 -> 测试 -> 打tag -> 构建 -> 发布

版本更新：
修复bug -> 补丁版本 (1.0.1)
新功能 -> 次版本 (1.1.0)  
破坏性变更 -> 主版本 (2.0.0)
```

**社区互动**：
- **及时回应**：处理用户提出的问题和建议
- **文档更新**：保持README和文档的实时性
- **兼容性维护**：支持新的Puppet版本和操作系统

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 模块结构：标准目录结构和文件组织规范
🔸 Manifest组织：init.pp主类和功能类拆分
🔸 模板使用：ERB语法和变量传递机制
🔸 文件服务：静态文件管理和URL格式
🔸 元数据定义：metadata.json的关键字段
🔸 依赖管理：模块依赖和类依赖关系
🔸 测试框架：rspec-puppet基本用法
🔸 Forge发布：模块打包和发布流程
```

### 10.2 关键理解要点


**🔹 模块化设计思想**
```
原则：
- 单一职责：每个类负责一个特定功能
- 松耦合：类之间依赖关系清晰
- 高内聚：相关功能组织在一起
- 可复用：模块可以在不同环境中使用
```

**🔹 最佳实践总结**
```
代码组织：
✅ 使用标准目录结构
✅ 合理拆分功能类
✅ 明确依赖关系
✅ 参数化配置

质量保证：
✅ 编写测试用例
✅ 完善文档说明
✅ 遵循编码规范
✅ 版本管理规范
```

### 10.3 实际应用指导


**🎯 模块开发流程**
```
1. 需求分析 → 确定模块功能范围
2. 结构设计 → 规划类和文件组织  
3. 编码实现 → 编写manifest和模板
4. 测试验证 → 单元测试和集成测试
5. 文档完善 → README和使用说明
6. 发布维护 → Forge发布和后续更新
```

**🔧 常见问题避免**
```
❌ 避免的问题：
- 所有代码都写在init.pp中
- 硬编码配置值，缺乏参数化
- 忽略依赖关系管理
- 缺少测试和文档

✅ 正确做法：
- 合理拆分功能类
- 充分参数化配置
- 明确define依赖关系
- 完善测试和文档
```

**核心记忆**：
- **模块是Puppet代码的最佳组织形式**，提供完整的解决方案
- **标准结构和规范命名**是模块可维护性的基础  
- **测试和文档**是高质量模块不可缺少的部分
- **社区分享**通过Forge让优秀模块惠及更多用户