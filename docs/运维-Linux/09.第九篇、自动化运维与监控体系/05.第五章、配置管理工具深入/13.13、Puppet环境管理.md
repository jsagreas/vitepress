---
title: 13、Puppet环境管理
---
## 📚 目录

1. [环境隔离机制](#1-环境隔离机制)
2. [Git集成工作流](#2-Git集成工作流)
3. [代码部署策略](#3-代码部署策略)
4. [环境切换管理](#4-环境切换管理)
5. [Hiera数据分离](#5-Hiera数据分离)
6. [环境特定配置](#6-环境特定配置)
7. [测试环境搭建](#7-测试环境搭建)
8. [生产环境部署](#8-生产环境部署)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🏢 环境隔离机制


### 1.1 什么是环境隔离


**📝 核心概念**
环境隔离就像在不同的房间里工作 - 开发、测试、生产都有各自独立的空间，互不干扰。在Puppet中，这意味着每个环境有自己的代码版本、配置数据和运行规则。

```
现实场景类比：
厨房试菜 → 开发环境（dev）
餐厅试营业 → 测试环境（test）  
正式营业 → 生产环境（production）

每个阶段都有不同的要求和配置
```

### 1.2 环境隔离的架构设计


**🏗️ 基础架构**
```
Puppet Server
├── environments/
│   ├── production/     ← 生产环境
│   │   ├── manifests/
│   │   ├── modules/
│   │   └── hiera.yaml
│   ├── testing/        ← 测试环境
│   │   ├── manifests/
│   │   ├── modules/
│   │   └── hiera.yaml
│   └── development/    ← 开发环境
│       ├── manifests/
│       ├── modules/
│       └── hiera.yaml
└── hieradata/         ← 分层数据
    ├── common/
    ├── production/
    ├── testing/
    └── development/
```

**⚙️ 配置文件设置**
```ruby
# /etc/puppetlabs/puppet/puppet.conf
[master]
environmentpath = /etc/puppetlabs/code/environments
basemodulepath = /etc/puppetlabs/code/modules:/opt/puppetlabs/puppet/modules

# 环境超时设置
environment_timeout = unlimited
```

### 1.3 环境隔离的核心原理


**🔸 隔离维度**
- **代码隔离**：不同环境运行不同版本的Puppet代码
- **数据隔离**：各环境使用独立的Hiera数据
- **节点隔离**：指定节点只能访问特定环境
- **模块隔离**：环境可以有不同版本的模块

> 💡 **核心理解**：环境隔离让我们能够安全地测试变更，就像在沙盒里玩耍，不会弄坏真正的玩具。

---

## 2. 🔄 Git集成工作流


### 2.1 Git分支策略设计


**🌿 分支对应关系**
```
Git仓库分支结构：
master/main     → production环境
testing         → testing环境  
development     → development环境
feature/*       → 个人开发分支

工作流程：
开发者 → feature分支 → development分支 → testing分支 → master分支
```

### 2.2 自动化同步机制


**⚡ Webhook自动部署**
```bash
# Git仓库配置webhook
# 当代码推送时，自动触发Puppet环境更新

#!/bin/bash
# /usr/local/bin/puppet-deploy.sh
ENVIRONMENT=$1
BRANCH=$2

cd /etc/puppetlabs/code/environments/$ENVIRONMENT
git fetch origin
git reset --hard origin/$BRANCH
puppet generate types --environment $ENVIRONMENT

# 重启Puppet服务（如需要）
systemctl reload puppetserver
```

**🔧 r10k工具集成**
```yaml
# /etc/puppetlabs/r10k/r10k.yaml
:cachedir: /var/cache/r10k
:git:
  :repositories:
    - /etc/puppetlabs/code/environments

:sources:
  :control:
    :remote: 'https://github.com/company/puppet-control.git'
    :basedir: '/etc/puppetlabs/code/environments'
```

### 2.3 代码审查流程


**📋 Pull Request流程**
```
步骤流程：
① 开发者创建feature分支
② 提交代码变更
③ 创建Pull Request到development分支
④ 代码审查和自动化测试
⑤ 合并到development环境测试
⑥ 逐步推广到testing和production
```

> ⚠️ **重要提醒**：生产环境的代码变更必须经过完整的审查流程，绝不能直接推送。

---

## 3. 🚀 代码部署策略


### 3.1 蓝绿部署模式


**🔵🟢 蓝绿切换原理**
```
蓝绿部署就像准备两套完全相同的舞台：

当前生产环境（蓝色）：正在服务用户
新版本环境（绿色）：部署新代码，准备切换

切换过程：
蓝色 ← 用户流量     绿色（待命）
蓝色（待命）     → 绿色 ← 用户流量
```

**🔄 实施步骤**
```bash
# 1. 准备绿色环境
r10k deploy environment green -pv

# 2. 验证绿色环境
puppet agent -t --environment green --noop

# 3. 切换节点到绿色环境
# 修改节点分类或ENC配置

# 4. 监控和回滚准备
# 保持蓝色环境可用，以备快速回滚
```

### 3.2 滚动部署策略


**⚡ 渐进式部署**
```
滚动部署像接力赛，一批一批地更新：

第1批节点：web01, web02 → 新版本
等待验证...
第2批节点：web03, web04 → 新版本  
等待验证...
...依此类推

优势：
✅ 风险分散，影响范围可控
✅ 可以随时暂停或回滚
✅ 服务连续性好
```

### 3.3 金丝雀部署


**🐤 金丝雀测试机制**
```bash
# 金丝雀部署脚本
#!/bin/bash

# 选择1%的节点作为金丝雀
CANARY_NODES="web01 app01"
ENVIRONMENT="canary"

# 部署到金丝雀节点
for node in $CANARY_NODES; do
    puppet agent -t --environment $ENVIRONMENT --server puppetserver
done

# 监控关键指标
# 错误率、响应时间、资源使用率
```

> 💡 **金丝雀部署比喻**：矿工下井前会带金丝雀测试空气质量，金丝雀部署也是用少量节点先"试水"。

---

## 4. 🔧 环境切换管理


### 4.1 节点环境指定方法


**📋 环境指定方式对比**

| 方法 | **适用场景** | **优点** | **缺点** |
|------|------------|---------|---------|
| `puppet.conf配置` | `固定环境分配` | `简单直接` | `不够灵活` |
| `ENC分类器` | `动态环境管理` | `集中控制，灵活` | `复杂度较高` |
| `命令行参数` | `临时测试` | `即时切换` | `不持久` |

### 4.2 ENC环境分类器


**🎯 动态环境分配**
```python
#!/usr/bin/env python3
# /usr/local/bin/puppet-enc.py
# External Node Classifier 示例

import json
import sys

def get_node_config(hostname):
    config = {
        'classes': {},
        'parameters': {},
        'environment': 'production'  # 默认环境
    }
    
    # 根据主机名规则分配环境
    if hostname.startswith('dev-'):
        config['environment'] = 'development'
    elif hostname.startswith('test-'):
        config['environment'] = 'testing'
    elif hostname.endswith('.canary'):
        config['environment'] = 'canary'
    
    return config

if __name__ == '__main__':
    hostname = sys.argv[1]
    config = get_node_config(hostname)
    print(json.dumps(config, indent=2))
```

### 4.3 环境切换的安全机制


**🔒 切换前检查**
```bash
#!/bin/bash
# 环境切换安全脚本

NODE=$1
NEW_ENV=$2
CURRENT_ENV=$(puppet config print environment --section agent)

echo "🔍 当前环境: $CURRENT_ENV"
echo "🎯 目标环境: $NEW_ENV" 

# 安全检查
echo "⚠️ 执行环境切换前检查..."

# 1. 检查目标环境是否存在
if [ ! -d "/etc/puppetlabs/code/environments/$NEW_ENV" ]; then
    echo "❌ 目标环境不存在"
    exit 1
fi

# 2. 执行noop测试
echo "🧪 执行noop测试..."
puppet agent -t --environment $NEW_ENV --noop

echo "✅ 检查通过，可以切换环境"
```

---

## 5. 📊 Hiera数据分离


### 5.1 Hiera分层数据架构


**🏗️ 数据层次结构**
```
Hiera数据分层就像俄罗斯套娃，一层套一层：

最具体 → 节点专用数据 (web01.example.com.yaml)
      → 角色数据 (role_webserver.yaml)
      → 环境数据 (production.yaml)
最通用 → 公共数据 (common.yaml)

查找顺序：从最具体到最通用
```

**📁 目录结构设计**
```
hieradata/
├── nodes/                    # 节点特定数据
│   ├── web01.example.com.yaml
│   └── db01.example.com.yaml
├── roles/                    # 角色数据
│   ├── webserver.yaml
│   └── database.yaml
├── environments/             # 环境数据
│   ├── production.yaml
│   ├── testing.yaml
│   └── development.yaml
└── common.yaml              # 公共数据
```

### 5.2 环境相关的Hiera配置


**⚙️ hiera.yaml配置**
```yaml
# /etc/puppetlabs/code/environments/production/hiera.yaml
---
version: 5
hierarchy:
  - name: "Per-node data"
    path: "nodes/%{facts.fqdn}.yaml"
    
  - name: "Per-role data"  
    path: "roles/%{facts.role}.yaml"
    
  - name: "Per-environment data"
    path: "environments/%{environment}.yaml"
    
  - name: "Common data"
    path: "common.yaml"

defaults:
  datadir: hieradata
  data_hash: yaml_data
```

### 5.3 环境差异化配置实例


**🔧 实际配置示例**
```yaml
# hieradata/environments/development.yaml
---
mysql::root_password: 'dev_password_123'
apache::listen_port: 8080
debug_mode: true
log_level: 'debug'

# hieradata/environments/production.yaml  
---
mysql::root_password: 'super_secure_prod_password'
apache::listen_port: 80
debug_mode: false
log_level: 'warn'
backup_enabled: true
monitoring_enabled: true
```

> 📝 **实用技巧**：使用eyaml加密生产环境的敏感数据，开发环境可以使用明文便于调试。

---

## 6. ⚙️ 环境特定配置


### 6.1 条件配置管理


**🎯 基于环境的条件逻辑**
```puppet
# 根据环境调整配置
case $environment {
  'development': {
    $mysql_max_connections = 50
    $apache_worker_processes = 2
    $enable_debug = true
  }
  'testing': {
    $mysql_max_connections = 100  
    $apache_worker_processes = 4
    $enable_debug = true
  }
  'production': {
    $mysql_max_connections = 500
    $apache_worker_processes = 8  
    $enable_debug = false
  }
  default: {
    fail("Unsupported environment: ${environment}")
  }
}
```

### 6.2 资源规格差异化


**📊 不同环境的资源配置**

| 配置项 | **开发环境** | **测试环境** | **生产环境** |
|-------|-----------|-----------|-----------|
| `CPU核心` | `2核` | `4核` | `8核` |
| `内存` | `4GB` | `8GB` | `32GB` |
| `MySQL连接数` | `50` | `100` | `500` |
| `日志级别` | `DEBUG` | `INFO` | `WARN` |
| `备份` | `禁用` | `每日` | `实时+每日` |

### 6.3 服务依赖管理


**🔗 环境相关的服务配置**
```puppet
# site.pp 或环境特定的配置
if $environment == 'production' {
  include monitoring::nagios
  include backup::daily
  include security::hardening
} elsif $environment == 'development' {
  include development::tools
  include debug::logging
}

# 不同环境的服务质量
$service_ensure = $environment ? {
  'production' => 'running',
  'testing'    => 'running', 
  'development'=> 'stopped',  # 开发环境可能不需要某些服务
}
```

---

## 7. 🧪 测试环境搭建


### 7.1 测试环境设计原则


**📋 设计核心原则**
- **数据隔离**：测试数据不能影响生产数据
- **规模适中**：配置足够验证功能，但不需要生产规模
- **易于重建**：可以快速销毁和重建
- **接近生产**：架构和配置尽量接近生产环境

### 7.2 Vagrant测试环境


**🏠 本地测试环境搭建**
```ruby
# Vagrantfile
Vagrant.configure("2") do |config|
  # 测试环境虚拟机
  config.vm.define "puppet-test" do |test|
    test.vm.box = "centos/7"
    test.vm.hostname = "puppet-test.local"
    test.vm.network "private_network", ip: "192.168.50.10"
    
    # Puppet配置
    test.vm.provision "puppet" do |puppet|
      puppet.environment = "testing"
      puppet.environment_path = "environments"
      puppet.manifest_file = "site.pp"
    end
  end
end
```

### 7.3 Docker容器测试


**🐳 容器化测试环境**
```dockerfile
# Dockerfile.puppet-test
FROM centos:7

RUN yum install -y puppet-agent
COPY environments/testing /etc/puppetlabs/code/environments/testing

CMD ["/opt/puppetlabs/bin/puppet", "apply", "--environment", "testing", "/etc/puppetlabs/code/environments/testing/manifests/site.pp"]
```

```bash
# 构建和运行测试
docker build -t puppet-test .
docker run -it puppet-test
```

### 7.4 自动化测试流程


**⚙️ CI/CD集成测试**
```bash
#!/bin/bash
# test-puppet-changes.sh

ENVIRONMENT="testing"

echo "🧪 开始Puppet代码测试..."

# 1. 语法检查
echo "📋 执行语法检查..."
puppet parser validate manifests/*.pp

# 2. 执行noop测试  
echo "🔍 执行noop测试..."
puppet agent -t --environment $ENVIRONMENT --noop

# 3. 实际执行测试
echo "⚡ 执行实际部署测试..."
puppet agent -t --environment $ENVIRONMENT

# 4. 验证结果
echo "✅ 验证部署结果..."
# 这里加入具体的验证逻辑

echo "🎉 测试完成！"
```

---

## 8. 🏭 生产环境部署


### 8.1 生产部署前检查清单


**✅ 部署前必检项目**
- [ ] **代码审查**：所有变更都经过peer review
- [ ] **测试验证**：在测试环境完整验证
- [ ] **备份确认**：确保关键数据已备份  
- [ ] **回滚方案**：准备回滚计划和脚本
- [ ] **监控准备**：部署期间的监控和告警
- [ ] **通知机制**：相关团队已收到部署通知

### 8.2 分批部署策略


**📊 生产环境分批方案**
```
Phase 1: 金丝雀节点 (5% nodes)
  ↓ 监控30分钟，无异常继续
Phase 2: 第一批业务节点 (25% nodes)  
  ↓ 监控1小时，无异常继续
Phase 3: 第二批业务节点 (50% nodes)
  ↓ 监控1小时，无异常继续  
Phase 4: 剩余节点 (20% nodes)
  ↓ 完整监控和验证
```

### 8.3 部署监控和告警


**📡 关键监控指标**
- **Puppet运行状态**：成功/失败率
- **系统资源**：CPU、内存、磁盘使用率
- **应用指标**：响应时间、错误率
- **业务指标**：用户访问、交易量

```bash
# 部署监控脚本示例
#!/bin/bash
check_puppet_run() {
    local node=$1
    echo "🔍 检查节点 $node 的Puppet运行状态..."
    
    # 检查最后一次运行时间
    last_run=$(ssh $node "puppet config print lastrunfile")
    if [ -f "$last_run" ]; then
        echo "✅ $node: Puppet运行正常"
    else
        echo "❌ $node: Puppet运行异常"
        return 1
    fi
}
```

### 8.4 紧急回滚机制


**🚨 快速回滚方案**
```bash
#!/bin/bash
# emergency-rollback.sh
# 紧急回滚脚本

ROLLBACK_ENV="production-backup"
TARGET_NODES="web01 web02 web03"

echo "🚨 执行紧急回滚..."

for node in $TARGET_NODES; do
    echo "🔄 回滚节点: $node"
    ssh $node "puppet agent -t --environment $ROLLBACK_ENV"
done

echo "📞 通知相关团队回滚完成"
```

> ⚠️ **生产部署金律**：宁可慢一点，也要确保稳定性。生产环境的每一次变更都可能影响业务。

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 环境隔离：开发、测试、生产环境完全分离
🔸 Git集成：代码版本控制与环境自动同步  
🔸 分层数据：Hiera实现配置数据的环境差异化
🔸 部署策略：蓝绿、滚动、金丝雀等安全部署模式
🔸 测试驱动：先测试后部署的安全理念
🔸 监控告警：部署过程的实时监控和快速响应
```

### 9.2 关键理解要点


**🔹 环境管理的本质**
```
环境管理就像管理不同的工作场所：
- 开发环境 = 个人办公室（可以随意实验）
- 测试环境 = 会议室（正式演示前的彩排）  
- 生产环境 = 正式会议厅（严肃正式，不容出错）

每个环境都有其用途和规范
```

**🔹 为什么需要环境隔离**
```
没有环境隔离的风险：
❌ 开发代码直接影响生产
❌ 测试数据污染生产数据  
❌ 无法安全验证变更
❌ 回滚困难

有了环境隔离的好处：
✅ 安全的变更验证
✅ 风险可控的部署
✅ 快速的问题定位
✅ 灵活的回滚机制
```

**🔹 部署策略的选择原则**
```
蓝绿部署：适合可以停机的应用
滚动部署：适合无法停机的分布式应用  
金丝雀部署：适合对稳定性要求极高的关键业务

核心思想：小步快跑，逐步验证
```

### 9.3 实际应用价值


**🎯 企业场景应用**
- **开发团队**：并行开发不同功能，环境隔离避免冲突
- **测试团队**：独立的测试环境，不影响开发进度
- **运维团队**：安全的生产部署，可控的变更管理
- **业务团队**：稳定的服务质量，最小的业务中断

**🛠️ 运维最佳实践**
- **渐进式部署**：分批部署降低风险
- **自动化测试**：减少人工错误
- **监控驱动**：数据指导决策
- **文档规范**：清晰的操作流程

**核心记忆要点**：
- 环境隔离是配置管理的基础安全机制
- Git集成实现了代码和配置的版本化管理
- Hiera分层让不同环境的配置管理变得简单
- 部署策略的选择要基于业务需求和风险承受能力
- 测试环境是生产部署的重要保障
- 生产部署必须有完整的检查、监控和回滚机制