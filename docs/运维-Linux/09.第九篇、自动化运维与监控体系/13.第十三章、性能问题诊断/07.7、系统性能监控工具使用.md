---
title: 7、系统性能监控工具使用
---
## 📚 目录

1. [性能监控工具概述](#1-性能监控工具概述)
2. [实时性能监控 - top/htop](#2-实时性能监控---top-htop)
3. [系统统计信息 - vmstat](#3-系统统计信息---vmstat)
4. [磁盘IO统计 - iostat](#4-磁盘io统计---iostat)
5. [网络连接状态 - netstat/ss](#5-网络连接状态---netstat-ss)
6. [系统活动报告 - sar](#6-系统活动报告---sar)
7. [性能分析工具 - perf](#7-性能分析工具---perf)
8. [系统调用跟踪 - strace](#8-系统调用跟踪---strace)
9. [性能监控工具选择策略](#9-性能监控工具选择策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 性能监控工具概述


### 1.1 什么是性能监控


**💡 通俗理解**：
性能监控就像是给服务器装上"体检仪器"，随时了解服务器的"健康状况"。就像医生用听诊器听心跳、用血压计测血压一样，我们用各种工具来检查服务器的CPU使用率、内存占用、磁盘读写速度等指标。

**🎯 核心目标**：
- **发现问题** - 及时发现系统瓶颈和异常
- **定位问题** - 准确找到问题的根本原因  
- **预防问题** - 通过监控趋势预防故障
- **优化性能** - 为系统调优提供数据依据

### 1.2 监控工具分类体系


```
Linux性能监控工具全景图：

实时监控类：
├── top/htop     → 进程和系统总体状态
├── vmstat       → 虚拟内存和系统统计
├── iostat       → 磁盘IO和CPU统计
└── netstat/ss   → 网络连接状态

历史分析类：
├── sar          → 系统活动历史报告
├── perf         → 深度性能剖析
└── strace       → 系统调用跟踪分析

专项分析类：
├── free         → 内存使用详情
├── df/du        → 磁盘空间统计
└── lsof         → 文件和进程关联
```

### 1.3 监控工具选择原则


| 场景类型 | **推荐工具** | **使用理由** |
|---------|------------|-------------|
| 🔥 **日常巡检** | `top/htop` | `直观显示，实时更新` |
| 📊 **性能分析** | `vmstat + iostat` | `多维度数据，便于对比` |
| 🌐 **网络诊断** | `ss + netstat` | `连接状态，流量统计` |
| 📈 **趋势分析** | `sar` | `历史数据，趋势图表` |
| 🔬 **深度调试** | `perf + strace` | `底层分析，精确定位` |

---

## 2. 👁️ 实时性能监控 - top/htop


### 2.1 top命令详解


**🔸 基本概念**：
`top`命令是Linux中最常用的**实时系统监控工具**，就像Windows的"任务管理器"一样。它能实时显示系统中正在运行的进程信息，包括CPU使用率、内存占用、运行时间等。

**💻 基础使用方法**：
```bash
# 基础用法
top

# 常用参数
top -d 2        # 每2秒刷新一次（默认3秒）
top -p 1234     # 只监控进程ID为1234的进程
top -u nginx    # 只显示nginx用户的进程
top -n 5        # 刷新5次后自动退出
```

### 2.2 top界面信息详解


**📊 系统概要信息区域**：
```
top界面顶部信息解读：

第1行：系统基本信息
top - 14:30:15 up 7 days, 2:15, 3 users, load average: 0.15, 0.25, 0.20
      当前时间   运行时间    登录用户  系统负载(1分钟,5分钟,15分钟)

第2行：任务统计
Tasks: 245 total, 2 running, 243 sleeping, 0 stopped, 0 zombie
       总任务数  运行中    休眠中     停止的   僵尸进程

第3行：CPU使用情况  
%Cpu(s): 12.5 us, 6.2 sy, 0.0 ni, 81.2 id, 0.0 wa, 0.0 hi, 0.1 si, 0.0 st
         用户态   系统态  Nice  空闲   等待IO  硬中断 软中断 虚拟化

第4行：内存使用情况
MiB Mem: 7936.2 total, 6148.9 free, 1020.7 used, 766.6 buff/cache
         总内存      空闲内存    已用内存   缓冲/缓存

第5行：交换分区
MiB Swap: 2048.0 total, 2048.0 free, 0.0 used. 6683.1 avail Mem
          总交换区   空闲交换区  已用交换  可用内存
```

**🔍 关键指标含义**：

**系统负载（Load Average）**：
- **含义**：系统在特定时间内的平均负载
- **数值解释**：
  - `0.00-1.00`：系统运行流畅 ✅
  - `1.00-CPU核数`：系统负载正常 ⚠️
  - `>CPU核数`：系统过载 🚨

**CPU使用率各项**：
- **us（user）**：用户态程序占用CPU时间
- **sy（system）**：内核态程序占用CPU时间  
- **id（idle）**：CPU空闲时间百分比
- **wa（wait）**：等待IO操作的时间

### 2.3 进程信息区域详解


```
进程列表各列含义：

PID    USER   PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
进程ID  用户  优先级 Nice值 虚拟内存 物理内存 共享内存 状态 CPU% 内存%  运行时间 命令名

重要字段解释：
- PID：进程唯一标识符
- %CPU：CPU使用百分比
- %MEM：内存使用百分比  
- VIRT：虚拟内存使用量
- RES：实际物理内存使用量
- TIME+：进程累计CPU使用时间
```

### 2.4 top交互式操作


**⌨️ 常用快捷键**：

| 按键 | **功能说明** | **使用场景** |
|------|------------|-------------|
| `h` | `显示帮助信息` | `查看所有快捷键` |
| `q` | `退出top` | `结束监控` |
| `P` | `按CPU使用率排序` | `找出CPU占用最高的进程` |
| `M` | `按内存使用率排序` | `找出内存占用最高的进程` |
| `T` | `按运行时间排序` | `找出运行时间最长的进程` |
| `k` | `杀死进程` | `终止异常进程` |
| `1` | `显示每个CPU核心状态` | `多核CPU详细信息` |
| `f` | `选择显示字段` | `自定义显示内容` |

### 2.5 htop增强版工具


**🚀 htop优势**：
`htop`是`top`的增强版本，提供了更友好的界面和更强的交互功能：

```bash
# 安装htop（如果系统没有）
# CentOS/RHEL
yum install htop
# Ubuntu/Debian  
apt install htop

# 使用htop
htop
```

**✨ htop特色功能**：
- **彩色界面** - 更直观的视觉效果
- **鼠标支持** - 可以用鼠标点击操作
- **进程树显示** - 清晰显示进程间关系
- **横向滚动** - 查看完整的命令行
- **批量操作** - 同时选择多个进程操作

**📊 htop界面布局**：
```
htop界面结构：

顶部：CPU和内存使用条形图（彩色显示）
[|||||||||||||||              25.3%]  CPU使用率
[████████████████████████      78.1%]  内存使用率

中部：进程列表（可排序、可筛选）
F1Help F2Setup F3Search F4Filter F5Tree F6SortBy...

底部：功能键说明
F9Kill F10Quit（按对应功能键执行操作）
```

---

## 3. 📊 系统统计信息 - vmstat


### 3.1 vmstat工具概述


**🔸 基本概念**：
`vmstat`是"**Virtual Memory Statistics**"的缩写，它像一个"系统体检表"，能够报告关于进程、内存、分页、块IO、中断、磁盘和CPU活动的信息。

**💡 主要用途**：
- **内存使用分析** - 查看内存分配和回收情况
- **系统负载评估** - 了解CPU和IO的工作状态  
- **性能瓶颈定位** - 发现内存或CPU瓶颈
- **系统健康检查** - 定期监控系统运行状态

### 3.2 vmstat基本使用


```bash
# 基础语法
vmstat [间隔时间] [次数]

# 常用示例
vmstat              # 显示一次统计信息
vmstat 2            # 每2秒显示一次，持续监控
vmstat 2 5          # 每2秒显示一次，共显示5次
vmstat -a           # 显示活跃和非活跃内存
vmstat -d           # 显示磁盘统计信息
vmstat -s           # 显示各种统计计数器
```

### 3.3 vmstat输出信息详解


**📋 标准输出格式**：
```
vmstat输出示例及含义：

procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0 629284  52712 191740    0    0     5     1   23   42  1  1 98  0  0
 1  0      0 629284  52712 191740    0    0     0     0   23   42  0  0 100 0  0
```

**🔍 各字段详细含义**：

**进程状态（procs）**：
- **r（running）**：运行队列中等待CPU的进程数
  - *正常值*：≤ CPU核数
  - *异常表现*：持续 > CPU核数，说明CPU不足

- **b（blocked）**：等待IO操作完成的进程数  
  - *正常值*：通常为0
  - *异常表现*：持续 > 0，可能存在IO瓶颈

**内存状态（memory）**：
- **swpd**：使用的虚拟内存量（KB）
- **free**：空闲的物理内存量（KB） 
- **buff**：用作缓冲的内存量（KB）
- **cache**：用作缓存的内存量（KB）

**交换分区（swap）**：
- **si（swap in）**：从磁盘交换到内存的速率（KB/s）
- **so（swap out）**：从内存交换到磁盘的速率（KB/s）

**磁盘IO（io）**：  
- **bi（blocks in）**：从磁盘读取的块数（blocks/s）
- **bo（blocks out）**：写入磁盘的块数（blocks/s）

**系统调用（system）**：
- **in（interrupts）**：每秒中断次数
- **cs（context switches）**：每秒上下文切换次数

**CPU使用率（cpu）**：
- **us**：用户态CPU使用百分比
- **sy**：系统态CPU使用百分比  
- **id**：CPU空闲百分比
- **wa**：等待IO的CPU时间百分比
- **st**：被虚拟化偷走的CPU时间百分比

### 3.4 vmstat实战分析


**🎯 性能问题识别**：

**CPU密集型负载特征**：
```
# CPU密集型系统的vmstat输出特征
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 8  0      0 500000  52000 180000    0    0     2     3   25   50 85  10  5  0  0
 7  0      0 498000  52000 180000    0    0     1     2   28   52 88   8  4  0  0

特征分析：
✅ r值较高（7-8），超过CPU核数  
✅ us%很高（85-88%），CPU主要用于用户态程序
✅ wa%很低（0%），几乎不等待IO
✅ bi/bo很低，磁盘IO较少
```

**IO密集型负载特征**：
```
# IO密集型系统的vmstat输出特征  
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  5      0 400000  30000 200000    0    0   500   300  150  200 20  15 40 25  0
 2  4      0 398000  30000 202000    0    0   480   280  140  190 18  12 45 25  0

特征分析：
✅ b值较高（4-5），多个进程等待IO
✅ wa%较高（25%），CPU大量时间等待IO
✅ bi/bo较高（300-500），磁盘读写频繁
✅ us%较低（18-20%），用户态CPU使用不高
```

**内存不足特征**：
```
# 内存不足系统的vmstat输出特征
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----  
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 3  2  50000   5000   1000  10000   20   15    50    30   80  120 15  25 40 20  0
 4  3  55000   3000   1000   8000   25   20    60    35   90  140 12  28 35 25  0

特征分析：
⚠️ swpd较高（50000-55000），使用了大量swap
⚠️ si/so > 0，频繁的swap in/out操作
⚠️ free很低（3000-5000），可用内存不足  
⚠️ wa%较高，可能因swap导致IO等待增加
```

---

## 4. 💾 磁盘IO统计 - iostat


### 4.1 iostat工具概述


**🔸 基本概念**：
`iostat`是"**IO Statistics**"的缩写，专门用于监控系统的**磁盘IO性能**。就像给硬盘装了个"速度表"，能实时显示磁盘的读写速度、使用率、响应时间等关键指标。

**💡 核心功能**：
- **IO性能监控** - 实时查看磁盘读写速度
- **设备利用率分析** - 了解各磁盘的繁忙程度
- **IO瓶颈诊断** - 发现存储系统性能问题
- **容量规划支撑** - 为存储扩容提供数据

### 4.2 iostat基本使用


```bash
# 基础语法
iostat [选项] [间隔时间] [次数]

# 常用示例
iostat              # 显示一次IO统计
iostat -x           # 显示扩展统计信息  
iostat -x 2         # 每2秒显示一次扩展信息
iostat -x 2 5       # 每2秒显示一次，共5次
iostat -d           # 仅显示磁盘统计
iostat -c           # 仅显示CPU统计
iostat -h           # 以人类可读格式显示
```

### 4.3 iostat输出信息详解


**📊 基础输出格式**：
```bash
# iostat -x 输出示例
Linux 5.4.0 (server01)    01/17/2025    _x86_64_    (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           1.2%    0.0%    0.8%    0.5%    0.0%   97.5%

Device            r/s     w/s     rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda              2.15    3.45     86.2    124.8    61.2     0.05    14.2    12.1    15.3    4.2    2.4
sdb              0.85    1.20     34.0     48.0    80.0     0.02     9.8     8.5    10.8    3.1    0.6
```

**🔍 CPU部分指标**：
- **%user**：用户态CPU使用率
- **%system**：系统态CPU使用率  
- **%iowait**：CPU等待IO完成的时间百分比
  - *正常值*：< 10%
  - *需关注*：> 20%（可能存在IO瓶颈）
- **%idle**：CPU空闲时间百分比

**📋 磁盘IO核心指标**：

**读写操作指标**：
- **r/s**：每秒读操作次数
- **w/s**：每秒写操作次数  
- **rkB/s**：每秒读取的KB数
- **wkB/s**：每秒写入的KB数

**队列和延迟指标**：
- **avgrq-sz**：平均请求大小（扇区数）
- **avgqu-sz**：平均请求队列长度
- **await**：平均等待时间（毫秒）
  - *优秀*：< 10ms
  - *良好*：10-20ms
  - *需优化*：> 50ms

**服务时间指标**：
- **svctm**：平均服务时间（毫秒）
- **%util**：设备利用率百分比
  - *正常*：< 80%
  - *繁忙*：80-95%
  - *饱和*：> 95%

### 4.4 iostat实战分析


**🎯 IO性能问题识别**：

**高IO延迟问题**：
```bash
# 高延迟IO的iostat特征
Device            r/s     w/s     rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda              5.2    12.8     208.0    512.0    80.0     2.45   135.6   120.2   142.8   45.2   81.5

问题特征分析：
⚠️ await很高（135.6ms） - 平均等待时间过长
⚠️ avgqu-sz较高（2.45） - 请求队列较长
⚠️ %util较高（81.5%） - 磁盘使用率高
📊 结论：磁盘IO负载过重，可能需要优化或升级存储
```

**顺序IO vs 随机IO**：
```bash
# 顺序IO模式特征（如备份、日志写入）
Device            r/s     w/s     rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sdb              2.1    15.6     84.0   1560.0   186.4     0.15     8.5     7.2     8.8    2.1    3.7

特征：avgrq-sz很大（186.4），说明大块顺序读写

# 随机IO模式特征（如数据库访问）  
Device            r/s     w/s     rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sdc             25.8    18.4    103.2     73.6     8.0     0.85    19.2    15.6    24.1    8.5   37.6

特征：avgrq-sz较小（8.0），r/s和w/s较高，说明小块随机读写
```

**💡 性能调优建议**：

| IO模式 | **特征** | **优化建议** |
|--------|---------|-------------|
| 🔄 **随机IO多** | `r/s+w/s高，avgrq-sz小` | `使用SSD，增加内存缓存` |
| 📝 **顺序IO多** | `avgrq-sz大，吞吐量高` | `使用RAID0，优化文件系统` |
| ⏱️ **延迟高** | `await>50ms，%util>90%` | `分散IO负载，升级存储` |
| 📈 **吞吐量不足** | `rkB/s+wkB/s<硬件能力` | `调整IO调度器，优化应用` |

---

## 5. 🌐 网络连接状态 - netstat/ss


### 5.1 网络监控工具概述


**🔸 基本概念**：
网络连接监控就像是给服务器装了个"网络监控摄像头"，能够实时查看有哪些网络连接正在活跃、哪些端口在监听、网络流量如何分布等信息。

**🔄 netstat vs ss对比**：
```
工具演进关系：
netstat（传统工具）→ ss（新一代工具）

主要区别：
netstat：历史悠久，使用广泛，但性能较慢
ss：现代替代品，速度更快，信息更详细
```

| 对比项 | **netstat** | **ss** |
|--------|------------|--------|
| **性能** | `较慢，读取/proc文件` | `快速，直接查询内核` |
| **功能** | `基础网络连接信息` | `更丰富的统计信息` |
| **兼容性** | `所有Linux发行版` | `较新系统支持更好` |
| **推荐度** | `传统运维，脚本兼容` | `现代运维，推荐使用` |

### 5.2 netstat使用详解


**💻 基本使用语法**：
```bash
# 基础语法
netstat [选项]

# 常用参数组合
netstat -an         # 显示所有连接（数字格式）
netstat -tnl        # 显示TCP监听端口
netstat -unl        # 显示UDP监听端口  
netstat -anp        # 显示连接对应的进程信息
netstat -i          # 显示网络接口统计
netstat -s          # 显示网络统计信息
```

**📊 参数含义说明**：
- **-a**：显示所有连接和监听端口
- **-n**：以数字格式显示地址和端口（不解析主机名）
- **-t**：仅显示TCP连接
- **-u**：仅显示UDP连接
- **-l**：仅显示监听状态的服务  
- **-p**：显示连接所属的进程ID和名称
- **-i**：显示网络接口信息
- **-s**：显示各协议的统计信息

### 5.3 netstat输出信息解读


**🔍 连接状态输出**：
```bash
# netstat -anp输出示例
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1028/sshd
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      2156/mysqld
tcp        0      0 192.168.1.100:22        192.168.1.50:51234      ESTABLISHED 3456/sshd: root
tcp        0     52 192.168.1.100:80        192.168.1.30:45678      ESTABLISHED 4567/nginx
```

**📋 字段详细说明**：
- **Proto**：协议类型（tcp、udp、tcp6、udp6）
- **Recv-Q**：接收队列中等待处理的字节数
- **Send-Q**：发送队列中等待发送的字节数
- **Local Address**：本地地址和端口
- **Foreign Address**：远程地址和端口
- **State**：连接状态
- **PID/Program**：进程ID和程序名

**🔄 TCP连接状态详解**：
- **LISTEN**：服务器监听状态，等待客户端连接
- **ESTABLISHED**：连接已建立，正在进行数据传输
- **TIME_WAIT**：连接关闭后的等待状态  
- **CLOSE_WAIT**：等待应用程序关闭连接
- **SYN_SENT**：客户端发起连接请求
- **SYN_RECV**：服务器收到连接请求

### 5.4 ss工具详解


**🚀 ss基本使用**：
```bash
# 基础用法
ss -tuln            # 显示TCP和UDP监听端口
ss -tuna            # 显示所有TCP和UDP连接  
ss -tunap           # 显示连接对应的进程
ss -t state established  # 只显示已建立的TCP连接
ss -o state established  # 显示连接的时间信息
```

**🔍 ss高级功能**：
```bash
# 按状态过滤
ss -t state listening       # 只显示监听状态
ss -t state established     # 只显示已建立连接
ss -t state time-wait       # 只显示TIME_WAIT状态

# 按地址和端口过滤
ss -t dst 192.168.1.100     # 目标地址过滤
ss -t dport :80             # 目标端口过滤
ss -t sport :22             # 源端口过滤

# 显示统计信息
ss -s                       # 显示套接字统计摘要
ss -i                       # 显示内部TCP信息
```

### 5.5 网络连接实战分析


**🎯 常见网络问题诊断**：

**端口监听检查**：
```bash
# 检查Web服务是否正常监听
$ ss -tnlp | grep :80
LISTEN    0    128    *:80    *:*    users:(("nginx",pid=1234,fd=6))

# 检查数据库连接
$ ss -tnlp | grep :3306  
LISTEN    0    50    127.0.0.1:3306    *:*    users:(("mysqld",pid=2345,fd=21))

✅ 正常：端口在监听状态
⚠️ 异常：无输出说明服务未启动或端口配置错误
```

**连接数统计分析**：
```bash
# 统计各种连接状态数量
$ ss -ant | awk '{print $1}' | sort | uniq -c
    1 CLOSE-WAIT
   15 ESTABLISHED  
    8 LISTEN
   45 TIME-WAIT

# 统计特定端口连接数
$ ss -ant | grep :80 | wc -l
128

📊 分析要点：
- TIME_WAIT过多可能表示连接频繁建立断开
- ESTABLISHED数量反映当前活跃连接
- CLOSE_WAIT过多可能存在程序bug（连接未正确关闭）
```

**网络性能瓶颈识别**：
```bash
# 检查接收和发送队列
$ ss -tnp | grep ESTAB
ESTAB  0      0     192.168.1.100:80   192.168.1.50:12345  users:(("nginx",pid=3456))
ESTAB  0      52    192.168.1.100:80   192.168.1.60:23456  users:(("nginx",pid=3456))
       接收队列 发送队列

⚠️ 性能问题指标：
- Recv-Q > 0：接收缓冲区堆积，可能CPU处理不及时
- Send-Q > 0：发送缓冲区堆积，可能网络带宽不足或对端处理慢
```

---

## 6. 📈 系统活动报告 - sar


### 6.1 sar工具概述


**🔸 基本概念**：
`sar`是"**System Activity Reporter**"的缩写，是Linux系统中最全面的**历史性能监控工具**。它就像一个"系统黑匣子"，能够记录和分析系统各个方面的历史性能数据。

**💡 核心特点**：
- **历史数据分析** - 可以查看过去任意时间的系统状态
- **全方位监控** - 涵盖CPU、内存、IO、网络等所有指标
- **趋势分析** - 发现性能变化趋势和规律
- **自动记录** - 通过定时任务自动收集数据

### 6.2 sar数据收集机制


**📊 数据收集架构**：
```
sar数据收集流程：

sadc(数据收集器) → /var/log/sa/saXX(二进制数据文件) → sar(报告生成器)
    ↓                           ↓                        ↓
每10分钟收集一次         按日期存储数据文件          生成各种格式报告

自动收集配置：
/etc/cron.d/sysstat 包含定时任务
# 每10分钟收集一次数据  
*/10 * * * * root /usr/lib64/sa/sa1 1 1
# 每天23:53生成日报告
53 23 * * * root /usr/lib64/sa/sa2 -A
```

**🔧 启用sar监控**：
```bash
# 检查sysstat是否安装
rpm -qa | grep sysstat     # CentOS/RHEL
dpkg -l | grep sysstat     # Ubuntu/Debian

# 安装sysstat（如果未安装）
yum install sysstat        # CentOS/RHEL
apt install sysstat        # Ubuntu/Debian

# 启动sysstat服务
systemctl enable sysstat
systemctl start sysstat

# 手动收集一次数据
/usr/lib64/sa/sa1 1 1
```

### 6.3 sar基本使用方法


**💻 sar命令语法**：
```bash
# 基础语法
sar [选项] [间隔] [次数]
sar [选项] -f [数据文件]

# 实时监控示例
sar -u 2 5              # 每2秒显示CPU使用率，共5次
sar -r 5                # 每5秒显示内存使用率
sar -d 3 10             # 每3秒显示磁盘IO，共10次

# 历史数据查询示例
sar -u                  # 显示当天CPU使用情况
sar -u -f /var/log/sa/sa15  # 显示15号的CPU数据
sar -r -s 09:00 -e 17:00    # 显示9点到17点的内存数据
```

### 6.4 sar监控指标详解


**🖥️ CPU使用率监控（-u）**：
```bash
# sar -u 输出示例
Linux 5.4.0 (server01)    01/17/2025    _x86_64_    (4 CPU)

09:00:01 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
09:10:01 AM     all      2.45      0.00      1.23      0.15      0.00     96.17
09:20:01 AM     all      3.12      0.00      1.45      0.22      0.00     95.21
Average:        all      2.78      0.00      1.34      0.18      0.00     95.69
```

**字段含义**：
- **%user**：用户态程序CPU使用率
- **%system**：内核态程序CPU使用率
- **%iowait**：等待IO完成的CPU时间
- **%idle**：CPU空闲时间百分比

**🧠 内存使用监控（-r）**：
```bash  
# sar -r 输出示例
09:00:01 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit
09:10:01 AM    524288   3670016     87.51     65536    892012   2456789     58.32
09:20:01 AM    498432   3695872     88.13     67584    896543   2489654     59.13
Average:       511360   3682944     87.82     66560    894277   2473221     58.72
```

**字段含义**：
- **kbmemfree**：空闲内存（KB）
- **kbmemused**：已用内存（KB）  
- **%memused**：内存使用率
- **kbbuffers**：缓冲区内存（KB）
- **kbcached**：缓存内存（KB）

**💾 磁盘IO监控（-d）**：
```bash
# sar -d 输出示例  
09:00:01 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz   await   svctm   %util
09:10:01 AM    dev8-0      5.23     41.67    156.78     38.02      0.12    23.45    4.56    2.39
09:20:01 AM    dev8-0      6.45     52.34    189.23     37.45      0.15    24.78    4.23    2.73
Average:       dev8-0      5.84     47.00    173.00     37.73      0.13    24.11    4.39    2.56
```

**关键指标**：
- **tps**：每秒传输次数（IOPS）
- **rd_sec/s**：每秒读扇区数
- **wr_sec/s**：每秒写扇区数
- **await**：平均等待时间（毫秒）
- **%util**：设备利用率

### 6.5 sar高级功能应用


**🔍 网络监控（-n）**：
```bash
# 网络设备统计
sar -n DEV 2 5          # 网络接口流量统计

# 网络错误统计  
sar -n EDEV 2 5         # 网络接口错误统计

# TCP连接统计
sar -n TCP 2 5          # TCP连接活动统计
```

**⏰ 时间范围查询**：
```bash
# 查询特定时间段数据
sar -u -s 08:00:00 -e 18:00:00     # 查询8点到18点CPU数据
sar -r -s 14:30 -e 15:30           # 查询14:30到15:30内存数据

# 查询历史文件  
sar -u -f /var/log/sa/sa10 -s 09:00 -e 17:00    # 查询10号9-17点数据
```

**📊 数据导出和分析**：
```bash
# 生成CSV格式报告（便于Excel分析）
sar -u -o temp.dat 2 30    # 收集30次数据到临时文件
sar -u -f temp.dat > cpu_report.csv    # 导出为CSV格式

# 生成系统综合报告
sar -A > system_report.txt     # 生成包含所有指标的综合报告
```

### 6.6 sar实战分析案例


**📈 性能趋势分析**：
```bash
# 分析一周CPU使用趋势
for i in {10..16}; do
  echo "=== 1月${i}日 CPU使用情况 ==="
  sar -u -f /var/log/sa/sa${i} | tail -1
done

输出示例：
=== 1月10日 CPU使用情况 ===
Average:        all      5.23      0.00      2.45      1.23      0.00     91.09
=== 1月11日 CPU使用情况 ===  
Average:        all      8.45      0.00      3.12      2.15      0.00     86.28
=== 1月12日 CPU使用情况 ===
Average:        all     15.67      0.00      4.23      3.45      0.00     76.65

📊 分析结论：CPU使用率呈上升趋势，12日达到24%，需要关注
```

**🚨 异常时段定位**：
```bash
# 定位高CPU使用时段
sar -u | awk '$3 > 80 {print $0}'    # 找出CPU使用率超过80%的时段

# 定位IO瓶颈时段  
sar -d | awk '$9 > 90 {print $0}'    # 找出磁盘利用率超过90%的时段

# 定位内存紧张时段
sar -r | awk '$4 > 90 {print $0}'    # 找出内存使用率超过90%的时段
```

---

## 7. 🔬 性能分析工具 - perf


### 7.1 perf工具概述


**🔸 基本概念**：
`perf`是Linux内核提供的**专业性能分析工具**，被称为"Linux性能分析的瑞士军刀"。它能够深入到程序和系统的底层，提供CPU使用、函数调用、缓存命中率等详细的性能数据。

**💡 核心能力**：
- **CPU性能剖析** - 分析程序的CPU热点函数
- **系统事件监控** - 监控内核和硬件事件
- **调用链分析** - 生成函数调用关系图
- **缓存性能分析** - 分析CPU缓存使用效率

**🎯 适用场景**：
- 应用程序性能调优
- 系统级性能瓶颈分析  
- 内核模块性能评估
- 硬件性能特征分析

### 7.2 perf安装和基本使用


**🔧 perf安装**：
```bash
# CentOS/RHEL系统
yum install perf

# Ubuntu/Debian系统
apt install linux-tools-common linux-tools-generic

# 验证安装
perf --version
```

**💻 基本使用语法**：
```bash
# 基础语法
perf [command] [options] [program]

# 常用子命令
perf list           # 列出所有可监控的事件
perf stat           # 统计程序运行期间的性能事件
perf record         # 记录程序运行时的性能数据
perf report         # 分析记录的性能数据
perf top            # 实时显示系统性能热点
```

### 7.3 perf stat - 性能统计


**📊 基本性能统计**：
```bash
# 统计程序运行的基本性能指标
perf stat ./my_program

# 输出示例：
 Performance counter stats for './my_program':

        2,847.892718      task-clock (msec)         #    0.998 CPUs utilized
                 145      context-switches          #    0.051 K/sec
                  12      cpu-migrations            #    0.004 K/sec
                 456      page-faults               #    0.160 K/sec
       8,456,789,123      cycles                    #    2.970 GHz
       6,234,567,890      instructions              #    0.74  insn per cycle
       1,234,567,890      branches                  #  433.456 M/sec
          12,345,678      branch-misses             #    1.00% of all branches

       2.852341234 seconds time elapsed
```

**🔍 关键指标解读**：
- **task-clock**：程序实际使用CPU时间
- **context-switches**：上下文切换次数（过多说明任务切换频繁）
- **cpu-migrations**：CPU迁移次数（多核系统中任务在不同CPU间迁移）
- **page-faults**：页面错误次数（包括缺页中断）
- **cycles**：CPU时钟周期数
- **instructions**：执行的指令数
- **IPC（insn per cycle）**：每个时钟周期的指令数（越高越好）
- **branch-misses**：分支预测失败率（越低越好）

**🎯 专项性能分析**：
```bash
# 分析缓存性能
perf stat -e cache-misses,cache-references ./my_program

# 分析分支预测性能  
perf stat -e branch-misses,branches ./my_program

# 分析内存访问性能
perf stat -e page-faults,minor-faults,major-faults ./my_program

# 多次运行取平均值
perf stat -r 5 ./my_program    # 运行5次取平均值
```

### 7.4 perf record/report - 详细剖析


**📹 记录性能数据**：
```bash
# 记录程序运行时的性能数据
perf record ./my_program

# 指定采样频率
perf record -F 1000 ./my_program    # 每秒采样1000次

# 记录特定事件
perf record -e cycles,instructions ./my_program

# 记录系统级性能（所有进程）
perf record -a sleep 10    # 记录系统10秒钟的性能数据
```

**📊 分析记录数据**：
```bash
# 生成性能报告
perf report

# 报告输出示例：
# Samples: 2K of event 'cycles:ppp'
# Event count (approx.): 1670663288
#
# Overhead  Command  Shared Object     Symbol
# ........  .......  ................  ..............................
#
    45.67%  my_prog  my_program        [.] calculate_heavy_function
    23.45%  my_prog  libc-2.31.so      [.] __memcpy_avx_unaligned
    12.34%  my_prog  my_program        [.] data_processing_loop
     8.90%  my_prog  libm.so.6         [.] __ieee754_sqrt
     5.67%  my_prog  my_program        [.] input_validation
```

**🔍 报告分析要点**：
- **Overhead**：函数占用CPU时间的百分比
- **Command**：程序名称
- **Shared Object**：所在的共享库或可执行文件
- **Symbol**：具体的函数名称

### 7.5 perf top - 实时性能监控


**⚡ 实时热点分析**：
```bash
# 实时显示系统热点函数
perf top

# 只监控特定进程
perf top -p 1234

# 只监控特定命令
perf top -e cycles --call-graph dwarf

# 界面输出示例：
Samples: 10K of event 'cycles:ppp', Event count (approx.): 4000000000
Overhead  Shared Object       Symbol
   8.25%  [kernel]            [k] __do_page_fault
   6.78%  libc-2.31.so        [.] __memset_avx2_unaligned_erms  
   5.43%  [kernel]            [k] copy_user_enhanced_fast_string
   4.21%  nginx               [.] ngx_http_process_request
   3.98%  mysql               [.] row_search_mvcc
```

### 7.6 perf实战应用案例


**🎯 应用程序性能优化**：

**案例1：发现CPU热点函数**
```bash
# 1. 记录程序运行数据
perf record -g ./slow_program input_file

# 2. 分析热点函数
perf report --stdio | head -20

# 3. 查看函数调用图
perf report --call-graph

结果分析：
发现sort_algorithm函数占用45%的CPU时间
↓
优化排序算法或使用更高效的实现
↓
再次测试验证性能提升
```

**案例2：系统级性能瓶颈定位**
```bash
# 1. 记录系统整体性能（10秒）
perf record -a -g sleep 10

# 2. 分析系统热点
perf report | grep -E "(kernel|mysql|nginx)"

# 3. 针对性优化
# 如果发现内核函数占比高 → 可能存在系统调用过多
# 如果发现某服务占比异常高 → 针对该服务进行优化
```

**🔧 性能调优指导**：

| 性能指标 | **正常范围** | **异常表现** | **优化建议** |
|---------|------------|-------------|-------------|
| **IPC** | `> 1.0` | `< 0.5` | `优化算法，减少分支` |
| **分支预测失败率** | `< 5%` | `> 15%` | `优化条件判断逻辑` |
| **缓存缺失率** | `< 10%` | `> 30%` | `优化数据访问模式` |
| **页面错误** | `适中` | `过高` | `增加内存或优化内存使用` |

---

## 8. 🔍 系统调用跟踪 - strace


### 8.1 strace工具概述


**🔸 基本概念**：
`strace`是"**System Call Trace**"的缩写，是一个强大的**系统调用跟踪工具**。它就像给程序装了个"监听器"，能够实时显示程序运行时调用了哪些系统调用，传递了什么参数，返回了什么结果。

**💡 核心功能**：
- **系统调用跟踪** - 监控程序的所有系统调用
- **参数和返回值显示** - 详细显示调用参数和结果
- **执行时间统计** - 统计各系统调用的耗时
- **故障诊断** - 定位程序运行中的问题

**🎯 应用场景**：
- **程序调试** - 理解程序行为和执行流程
- **性能分析** - 发现IO密集操作和瓶颈
- **故障排查** - 定位程序崩溃或异常原因
- **安全分析** - 监控程序的系统资源访问

### 8.2 strace基本使用


**💻 基础语法**：
```bash
# 基本语法
strace [选项] 命令
strace [选项] -p PID

# 基础示例
strace ls /home              # 跟踪ls命令的系统调用
strace -p 1234              # 跟踪进程ID为1234的进程
strace -o trace.log ./program    # 将跟踪结果保存到文件
```

**🔧 常用参数详解**：
```bash
# 输出控制
strace -o file program      # 输出到文件
strace -f program          # 跟踪子进程
strace -t program          # 显示时间戳
strace -tt program         # 显示精确时间戳
strace -T program          # 显示每个系统调用的耗时

# 过滤控制  
strace -e trace=file program    # 只跟踪文件相关系统调用
strace -e trace=network program # 只跟踪网络相关系统调用
strace -e trace=process program # 只跟踪进程相关系统调用
```

### 8.3 strace输出解读


**📊 典型输出格式**：
```bash
# strace cat /etc/passwd 输出示例
execve("/bin/cat", ["cat", "/etc/passwd"], [/* 26 vars */]) = 0
brk(NULL)                               = 0x55e8c2345000
access("/etc/ld.so.nohwcap", F_OK)     = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)     = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=27002, ...}) = 0
mmap(NULL, 27002, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f8b2c3d1000
close(3)                                = 0
openat(AT_FDCWD, "/etc/passwd", O_RDONLY) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=1876, ...}) = 0
read(3, "root:x:0:0:root:/root:/bin/bash\n"..., 131072) = 1876
write(1, "root:x:0:0:root:/root:/bin/bash\n"..., 1876) = 1876
close(3)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
```

**🔍 输出格式说明**：
```
系统调用名(参数1, 参数2, ...) = 返回值 [错误信息]

具体解析：
openat(AT_FDCWD, "/etc/passwd", O_RDONLY) = 3
|      |         |              |          |
|      |         |              |          └─ 返回值：文件描述符3  
|      |         |              └─ 参数3：只读模式打开
|      |         └─ 参数2：要打开的文件路径
|      └─ 参数1：相对于当前目录
└─ 系统调用名：打开文件
```

### 8.4 常见系统调用类型


**📁 文件操作系统调用**：
```bash
# 跟踪文件操作
strace -e trace=file ls /home

常见文件系统调用：
- openat()：打开文件
- read()：读取数据  
- write()：写入数据
- close()：关闭文件
- stat()/fstat()：获取文件信息
- access()：检查文件访问权限
- unlink()：删除文件
```

**🌐 网络操作系统调用**：
```bash
# 跟踪网络操作
strace -e trace=network curl http://example.com

常见网络系统调用：
- socket()：创建套接字
- connect()：建立连接
- bind()：绑定地址  
- listen()：监听连接
- accept()：接受连接
- send()/recv()：发送/接收数据
- close()：关闭连接
```

**⚙️ 进程管理系统调用**：
```bash
# 跟踪进程操作
strace -e trace=process bash -c "echo hello"

常见进程系统调用：
- execve()：执行程序
- fork()：创建子进程
- clone()：创建线程/进程
- wait()：等待子进程结束
- kill()：发送信号
- exit_group()：退出程序
```

### 8.5 strace实战应用


**🎯 故障诊断案例**：

**案例1：程序启动失败诊断**
```bash
# 程序无法启动，使用strace诊断
strace ./problematic_program 2>&1 | grep -E "(ENOENT|EACCES|EPERM)"

# 常见错误类型：
ENOENT (No such file or directory) → 缺少依赖文件
EACCES (Permission denied) → 权限不足
EPERM (Operation not permitted) → 操作被禁止

# 示例输出：
openat(AT_FDCWD, "/usr/lib/libmysql.so", O_RDONLY|O_CLOEXEC) = -1 ENOENT
↓
问题：缺少MySQL客户端库
解决：安装mysql-devel包
```

**案例2：性能问题分析**
```bash
# 分析程序IO性能
strace -T -e trace=file ./slow_program 2>&1 | grep -E "read|write"

# 输出示例：
read(3, "data"..., 4096) = 4096 <0.000015>
read(3, "data"..., 4096) = 4096 <0.000012>  
read(3, "data"..., 4096) = 4096 <0.000018>
write(4, "result"..., 1024) = 1024 <0.002156>  ← 写入耗时较长

分析结论：
✅ 读操作很快（15微秒左右）
⚠️ 写操作较慢（2毫秒），可能是磁盘IO瓶颈
```

**案例3：网络连接问题诊断**
```bash
# 诊断网络连接问题
strace -e trace=network curl -m 5 http://problematic-site.com

# 可能的输出和问题：
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("192.168.1.100")}, 16) = -1 ETIMEDOUT (Connection timed out)

问题分析：
- socket()成功 → 套接字创建正常
- connect()超时 → 目标服务器不可达或防火墙阻止
```

### 8.6 strace高级用法


**📊 统计分析功能**：
```bash
# 统计系统调用时间和次数
strace -c ./program

# 输出示例：
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 45.67    0.012456        1245        10           write
 23.45    0.006398         213        30           read  
 12.34    0.003367         168        20           openat
  8.90    0.002431         121        20           close
  5.67    0.001547         386         4           mmap
  3.97    0.001084         271         4           fstat
------ ----------- ----------- --------- --------- ----------------
100.00    0.027283                   118           total

分析要点：
- write()调用占用45.67%的时间，可能是IO瓶颈
- 每次write()平均耗时1245微秒，相对较高
- 总共118次系统调用，程序逻辑相对简单
```

**🔍 高级过滤和分析**：
```bash
# 只跟踪特定系统调用
strace -e trace=openat,read,write,close ./program

# 跟踪多个进程（包括子进程）
strace -f -o trace.log ./parent_program

# 显示字符串内容（默认只显示32个字符）
strace -s 128 ./program    # 显示128个字符

# 跟踪正在运行的进程
strace -p $(pgrep nginx) -o nginx_trace.log

# 按信号分组显示
strace -e signal=all ./program    # 显示所有信号相关调用
```

**💡 strace最佳实践**：

| 使用场景 | **推荐参数** | **说明** |
|---------|------------|---------|
| **快速诊断** | `-e trace=file` | `只关注文件操作` |
| **性能分析** | `-T -c` | `显示耗时统计` |
| **完整跟踪** | `-f -o logfile` | `跟踪子进程，保存日志` |
| **网络问题** | `-e trace=network` | `专注网络调用` |
| **生产环境** | `-p PID -o file` | `附加到进程，减少影响` |

---

## 9. 🎯 性能监控工具选择策略


### 9.1 监控工具选择矩阵


**📊 工具选择决策表**：

| 监控需求 | **首选工具** | **备选工具** | **使用场景** |
|---------|------------|-------------|-------------|
| **🔍 日常巡检** | `top/htop` | `vmstat` | `快速了解系统整体状态` |
| **📈 历史分析** | `sar` | `iostat + 脚本` | `分析性能趋势和规律` |
| **💾 IO性能** | `iostat` | `iotop, dstat` | `磁盘读写性能分析` |
| **🌐 网络诊断** | `ss` | `netstat, iftop` | `网络连接和流量分析` |
| **🔬 深度分析** | `perf` | `gprof, valgrind` | `CPU热点和性能优化` |
| **🐛 故障调试** | `strace` | `ltrace, gdb` | `系统调用跟踪诊断` |

### 9.2 不同场景的工具组合策略


**🏢 生产环境监控组合**：
```bash
# 第一层：基础监控（每分钟）
*/1 * * * * root top -b -n1 | head -20 >> /var/log/system_status.log

# 第二层：详细统计（每10分钟）
*/10 * * * * root iostat -x 1 5 >> /var/log/io_stats.log
*/10 * * * * root vmstat 1 5 >> /var/log/vm_stats.log

# 第三层：长期趋势（sar自动收集）
# /etc/cron.d/sysstat 已配置

监控告警脚本示例：
#!/bin/bash
# 检查系统关键指标
CPU_USAGE=$(top -b -n1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
LOAD_AVG=$(uptime | awk '{print $(NF-2)}' | cut -d',' -f1)
MEMORY_USAGE=$(free | grep Mem | awk '{printf "%.1f", $3/$2 * 100}')

# 告警阈值判断
if (( $(echo "$CPU_USAGE > 80" | bc -l) )); then
    echo "WARNING: CPU usage is ${CPU_USAGE}%"
fi
```

**🔧 开发环境调试组合**：
```bash
# 开发阶段性能分析流程
# 1. 程序整体性能概况
perf stat ./my_program

# 2. 找出性能热点
perf record -g ./my_program
perf report

# 3. 系统调用分析
strace -c -T ./my_program

# 4. 特定问题深入分析
strace -e trace=file ./my_program    # 文件IO问题
strace -e trace=network ./my_program # 网络问题
```

### 9.3 监控工具性能开销对比


**⚡ 工具性能影响评估**：

| 工具 | **CPU开销** | **内存开销** | **IO开销** | **生产适用性** |
|------|-----------|-------------|-----------|---------------|
| **top/htop** | `极低 (<1%)` | `极低 (~2MB)` | `极低` | `✅ 完全适用` |
| **vmstat/iostat** | `极低 (<0.5%)` | `极低 (~1MB)` | `极低` | `✅ 完全适用` |
| **sar** | `低 (~1%)` | `低 (~5MB)` | `低` | `✅ 推荐使用` |
| **netstat/ss** | `低-中 (~2%)` | `低 (~3MB)` | `极低` | `✅ 适用` |
| **perf** | `中-高 (5-15%)` | `中 (~20MB)` | `中` | `⚠️ 短期使用` |
| **strace** | `高 (10-50%)` | `低 (~10MB)` | `中` | `❌ 仅调试用` |

### 9.4 监控数据存储和分析策略


**📊 数据收集架构设计**：
```
监控数据流转架构：

原始数据收集层：
├── sar (系统级历史数据)
├── 自定义脚本 (应用级数据)  
└── 日志文件 (错误和事件)
         ↓
数据处理层：
├── logrotate (日志轮转)
├── 数据清洗脚本 (格式化)
└── 异常检测 (告警触发)
         ↓
可视化展示层：
├── Grafana (图表展示)
├── 自定义Web界面
└── 报告生成 (周报/月报)
```

**🔧 监控脚本示例**：
```bash
#!/bin/bash
# comprehensive_monitor.sh - 综合监控脚本

LOG_DIR="/var/log/performance"
DATE=$(date +"%Y-%m-%d_%H-%M-%S")

# 创建日志目录
mkdir -p $LOG_DIR

# 收集系统基础信息
echo "=== System Overview ===" > $LOG_DIR/system_$DATE.log
uptime >> $LOG_DIR/system_$DATE.log
free -h >> $LOG_DIR/system_$DATE.log
df -h >> $LOG_DIR/system_$DATE.log

# 收集进程信息
echo "=== Top Processes ===" >> $LOG_DIR/system_$DATE.log
top -b -n1 | head -20 >> $LOG_DIR/system_$DATE.log

# 收集网络连接
echo "=== Network Connections ===" >> $LOG_DIR/system_$DATE.log
ss -tuln | head -10 >> $LOG_DIR/system_$DATE.log

# 收集IO统计
iostat -x 1 3 > $LOG_DIR/io_$DATE.log &

# 异常检测和告警
check_alerts() {
    local cpu_usage=$(top -b -n1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    local load_avg=$(uptime | awk '{print $10}' | cut -d',' -f1)
    local disk_usage=$(df / | tail -1 | awk '{print $5}' | cut -d'%' -f1)
    
    # 生成告警
    if (( $(echo "$cpu_usage > 80" | bc -l) )); then
        echo "ALERT: High CPU usage: ${cpu_usage}%" | mail -s "Server Alert" admin@company.com
    fi
}

check_alerts
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心工具


```
🔸 基础监控三剑客：
  - top/htop：实时系统状态，进程监控
  - vmstat：系统统计，内存和CPU分析  
  - iostat：磁盘IO性能，存储瓶颈诊断

🔸 网络诊断双工具：
  - ss：现代网络连接状态查看
  - netstat：传统网络统计，兼容性好

🔸 深度分析利器：
  - sar：历史数据分析，趋势监控
  - perf：CPU性能剖析，热点定位
  - strace：系统调用跟踪，故障诊断
```

### 10.2 工具使用要点总结


**⚡ 关键命令速查**：

| 场景 | **命令** | **说明** |
|------|---------|---------|
| **快速巡检** | `top`, `free -h`, `df -h` | `系统整体状态` |
| **CPU分析** | `top -P`, `sar -u`, `vmstat 2` | `CPU使用率和负载` |
| **内存分析** | `free -h`, `vmstat`, `sar -r` | `内存使用和交换` |
| **IO分析** | `iostat -x 2`, `sar -d` | `磁盘读写性能` |
| **网络分析** | `ss -tuln`, `sar -n DEV` | `网络连接和流量` |
| **进程分析** | `htop`, `ps aux`, `pgrep` | `进程状态和资源` |

**🎯 性能指标警戒值**：

| 指标类型 | **正常范围** | **需关注** | **紧急处理** |
|---------|------------|-----------|-------------|
| **CPU使用率** | `< 70%` | `70-85%` | `> 85%` |
| **系统负载** | `< CPU核数` | `CPU核数-2倍` | `> 2倍CPU核数` |
| **内存使用** | `< 80%` | `80-90%` | `> 90%` |
| **磁盘IO等待** | `< 10%` | `10-20%` | `> 20%` |
| **磁盘利用率** | `< 80%` | `80-95%` | `> 95%` |

### 10.3 实际应用指导


**🔍 故障排查流程**：
```
故障排查标准流程：

第一步：快速定位（2分钟内）
├── top/htop 查看整体状态
├── free -h 检查内存使用  
└── df -h 检查磁盘空间

第二步：深入分析（5-10分钟）
├── 如果CPU高 → vmstat, sar -u, perf top
├── 如果内存不足 → vmstat, sar -r, ps aux
├── 如果IO慢 → iostat -x, sar -d
└── 如果网络问题 → ss, netstat, sar -n

第三步：精确诊断（根据需要）
├── 应用问题 → strace, perf record
├── 系统问题 → sar历史数据分析
└── 硬件问题 → dmesg, /var/log/messages
```

**📊 监控策略建议**：

**日常监控**：
- 使用`htop`进行人工巡检
- 配置`sar`自动收集历史数据
- 设置基础的阈值告警

**性能调优**：
- 用`perf`找出代码热点
- 用`iostat`分析IO瓶颈
- 用`vmstat`监控内存使用模式

**故障诊断**：
- 用`strace`跟踪异常行为
- 用`sar`分析历史趋势
- 结合日志文件综合判断

### 10.4 学习进阶建议


**🎓 学习路径**：
```
入门阶段（掌握基础）：
top/htop → vmstat → iostat → netstat/ss

进阶阶段（深入理解）：
sar → perf stat → strace基础用法

高级阶段（专家级应用）：
perf record/report → strace高级过滤 → 自定义监控脚本
```

**💡 最佳实践要点**：
- **工具组合使用**：单一工具看不全，要多工具配合
- **关注趋势变化**：不只看当前值，更要看变化趋势  
- **建立基线**：了解系统正常状态的各项指标
- **自动化监控**：手工监控无法7×24小时持续
- **及时响应告警**：监控数据要能转化为实际行动

**🔧 实践建议**：
- 在测试环境多练习各工具的使用
- 建立自己的监控工具箱和常用命令集
- 学会写简单的监控脚本自动化日常任务
- 理解各指标的业务含义，而不只是技术含义

**核心记忆口诀**：
- top看整体，vmstat看统计
- iostat查IO，ss看网络
- sar存历史，perf找热点  
- strace追调用，组合解难题