---
title: 5、告警规则定义与管理
---
## 📚 目录

1. [告警规则基础概念](#1-告警规则基础概念)
2. [告警规则文件结构](#2-告警规则文件结构)
3. [告警表达式编写规范](#3-告警表达式编写规范)
4. [告警级别与标签设计](#4-告警级别与标签设计)
5. [告警触发条件与持续时间](#5-告警触发条件与持续时间)
6. [告警模板与注释信息](#6-告警模板与注释信息)
7. [规则组织与文件管理](#7-规则组织与文件管理)
8. [告警规则语法验证](#8-告警规则语法验证)
9. [动态规则加载与更新](#9-动态规则加载与更新)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 告警规则基础概念


### 1.1 什么是告警规则


💭 **想象一下**：告警规则就像是给系统安装的"烟雾报警器"。当系统出现问题时（就像房间里有烟雾），报警器会立刻响起（发送告警通知），提醒管理员处理问题。

**🔍 核心定义**：
- 告警规则是一组预定义的**监控条件**，当这些条件满足时自动触发告警
- 它通过**PromQL表达式**来检测系统状态，发现异常情况
- 告警规则是Prometheus监控体系的"智能大脑"，负责判断什么时候需要人工介入

### 1.2 告警规则的工作原理


```
监控数据流程：
指标数据 → Prometheus存储 → 告警规则评估 → 满足条件 → 发送到Alertmanager → 通知渠道

实际例子：
CPU使用率 > 80% → 持续5分钟 → 触发告警 → 发送钉钉/邮件通知
```

**🔧 工作机制**：
1. **定期评估**：Prometheus按设定间隔（如30秒）检查所有告警规则
2. **条件判断**：用PromQL表达式查询指标数据，判断是否满足告警条件
3. **状态转换**：告警状态在Inactive（未激活）、Pending（待定）、Firing（触发）间切换
4. **告警发送**：满足条件的告警发送给Alertmanager进行后续处理

### 1.3 告警规则的重要性


**🏢 实际价值**：
- **主动监控**：不用人工盯着屏幕，系统自动发现问题
- **快速响应**：问题出现后几分钟内就能收到通知
- **减少损失**：及时发现并处理问题，避免业务中断
- **运维自动化**：把人从24小时监控中解放出来

---

## 2. 📋 告警规则文件结构


### 2.1 基本文件格式


告警规则使用**YAML格式**编写，这是一种人类易读的数据格式，就像写配置清单一样简单。

```yaml
# /etc/prometheus/rules/basic_alerts.yml
groups:
  - name: "基础系统告警"
    rules:
      - alert: 服务器CPU过高
        expr: 100 - (avg(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m
        labels:
          severity: warning
          team: sre
        annotations:
          summary: "服务器 {{ $labels.instance }} CPU使用率过高"
          description: "当前CPU使用率为 {{ $value }}%，已持续超过5分钟"
```

### 2.2 文件结构详解


**📊 结构层次**：
```
告警规则文件
├── groups (告警组)
│   ├── name (组名)
│   ├── interval (评估间隔，可选)
│   └── rules (规则列表)
│       ├── alert (告警名称)
│       ├── expr (PromQL表达式)
│       ├── for (持续时间)
│       ├── labels (标签)
│       └── annotations (注释信息)
```

**🔸 各字段含义**：
- `groups`: 告警规则的顶级容器，可以包含多个告警组
- `name`: 告警组的名称，用于识别和管理
- `rules`: 该组下的具体告警规则列表
- `alert`: 告警的名称，应该简洁明了
- `expr`: PromQL查询表达式，定义告警触发条件
- `for`: 条件持续多长时间后才触发告警
- `labels`: 给告警添加标签，用于分类和路由
- `annotations`: 告警的描述信息，用于通知内容

### 2.3 完整示例文件


```yaml
# /etc/prometheus/rules/system_alerts.yml
groups:
  - name: "系统基础监控"
    interval: 30s  # 每30秒评估一次
    rules:
      # CPU使用率告警
      - alert: CPUUsageHigh
        expr: 100 - (avg by(instance)(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m
        labels:
          severity: warning
          service: system
        annotations:
          summary: "CPU使用率过高"
          description: "实例 {{ $labels.instance }} 的CPU使用率为 {{ printf \"%.2f\" $value }}%"
      
      # 内存使用率告警  
      - alert: MemoryUsageHigh
        expr: (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes * 100 > 85
        for: 3m
        labels:
          severity: critical
          service: system
        annotations:
          summary: "内存使用率过高"
          description: "实例 {{ $labels.instance }} 的内存使用率为 {{ printf \"%.2f\" $value }}%"
```

---

## 3. 📝 告警表达式编写规范


### 3.1 PromQL基础语法


💡 **简单理解**：PromQL就像是跟Prometheus"对话"的语言。你用这种语言告诉Prometheus："帮我查一下CPU使用率"或"看看哪台服务器内存不够用"。

**🔤 基本语法元素**：

| 元素类型 | 语法示例 | 含义说明 |
|---------|----------|----------|
| **指标选择** | `node_cpu_seconds_total` | 选择指定的监控指标 |
| **标签筛选** | `{instance="server1"}` | 根据标签过滤数据 |
| **时间范围** | `[5m]` | 指定查询的时间窗口 |
| **聚合函数** | `avg()`, `sum()`, `max()` | 对数据进行聚合计算 |
| **算术运算** | `+`, `-`, `*`, `/`, `%` | 数学运算操作 |
| **比较运算** | `>`, `<`, `>=`, `<=`, `==`, `!=` | 条件比较操作 |

### 3.2 常用告警表达式模式


**🚨 CPU使用率监控**：
```yaml
# CPU使用率超过80%
expr: 100 - (avg by(instance)(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80

# 解释：
# 1. irate() 计算每秒的增长率
# 2. mode="idle" 选择空闲时间
# 3. 100 - idle% = 使用率%
# 4. avg by(instance) 按实例聚合
```

**💾 内存使用率监控**：
```yaml
# 内存使用率超过85%
expr: (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes * 100 > 85

# 解释：
# 1. MemTotal - MemAvailable = 已使用内存
# 2. 除以总内存得到使用率
# 3. 乘以100转换为百分比
```

**💽 磁盘使用率监控**：
```yaml
# 磁盘使用率超过90%
expr: (node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes * 100 > 90

# 解释：
# 1. size - free = 已使用空间
# 2. 除以总容量得到使用率
```

### 3.3 表达式编写最佳实践


**📋 编写规范**：

```yaml
# ✅ 推荐写法：清晰明确
expr: rate(http_requests_total[5m]) > 100

# ❌ 避免写法：过于复杂
expr: sum(rate(http_requests_total{status=~"2..|3.."}[5m])) by (instance) / sum(rate(http_requests_total[5m])) by (instance) * 100 > 95 and sum(rate(http_requests_total[5m])) by (instance) > 10
```

**🎯 编写要点**：
- **简洁明了**：表达式应该一眼就能看懂要监控什么
- **避免复杂**：复杂逻辑应该拆分为多个简单规则
- **性能考虑**：避免使用计算量过大的函数和长时间范围
- **标签合理**：合理使用标签过滤，避免查询过多不相关数据

---

## 4. 🏷️ 告警级别与标签设计


### 4.1 告警级别分类


🔍 **理解告警级别**：就像医院里的病人分诊一样，不同严重程度的告警需要不同的处理优先级和响应方式。

**⭐ 标准级别定义**：

| 级别 | 英文名称 | 响应时间 | 处理方式 | 典型场景 |
|------|----------|----------|----------|----------|
| **🔴 Critical** | 严重 | 立即响应(5分钟内) | 电话+短信+钉钉 | 服务完全不可用、数据丢失 |
| **🟡 Warning** | 警告 | 30分钟内响应 | 钉钉+邮件 | 性能下降、资源使用率高 |
| **🔵 Info** | 信息 | 工作时间内处理 | 仅邮件记录 | 配置变更、定期检查 |

### 4.2 标签设计策略


**🎨 标签设计原则**：
- **层次化**：按服务、团队、环境等维度分层
- **标准化**：团队内统一标签命名规范
- **路由友好**：便于Alertmanager进行告警路由

```yaml
# 推荐的标签设计
labels:
  severity: critical           # 告警级别
  service: user-service       # 服务名称
  team: backend-team         # 负责团队
  env: production            # 运行环境
  cluster: k8s-prod          # 集群标识
  component: database        # 组件类型
```

### 4.3 实际标签应用示例


```yaml
groups:
  - name: "服务监控告警"
    rules:
      # 数据库连接告警 - 严重级别
      - alert: DatabaseConnectionLost
        expr: mysql_up == 0
        for: 1m
        labels:
          severity: critical
          service: mysql
          team: dba-team
          env: production
          component: database
        annotations:
          summary: "MySQL数据库连接丢失"
          description: "数据库 {{ $labels.instance }} 无法连接"
      
      # API响应时间告警 - 警告级别
      - alert: APIResponseTimeSlow
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
        for: 5m
        labels:
          severity: warning
          service: api-gateway
          team: backend-team
          env: production
          component: api
        annotations:
          summary: "API响应时间过慢"
          description: "95%的请求响应时间超过2秒"
```

---

## 5. ⏰ 告警触发条件与持续时间


### 5.1 持续时间的重要性


🤔 **为什么需要持续时间**：
想象一下，如果CPU瞬间飙到90%就立刻报警，你可能会收到很多"假报警"。因为CPU可能只是临时处理一个任务，很快就恢复正常了。所以我们需要设置一个"观察期"，只有问题持续一段时间才真正报警。

### 5.2 持续时间设置策略


**📊 不同场景的持续时间设置**：

| 监控类型 | 建议持续时间 | 设置原因 | 示例 |
|----------|--------------|----------|------|
| **系统资源** | 3-5分钟 | 避免瞬时波动误报 | CPU、内存使用率 |
| **服务可用性** | 1-2分钟 | 快速发现服务异常 | 服务健康检查、端口监听 |
| **业务指标** | 5-10分钟 | 考虑业务波动特性 | 订单量、用户登录数 |
| **网络连通性** | 30秒-1分钟 | 网络问题需快速响应 | ping检测、连接超时 |

### 5.3 动态持续时间配置


```yaml
groups:
  - name: "分层监控告警"
    rules:
      # 服务完全不可用 - 快速告警
      - alert: ServiceDown
        expr: up == 0
        for: 1m  # 1分钟就告警，因为服务不可用很严重
        labels:
          severity: critical
        annotations:
          summary: "服务不可用"
      
      # CPU持续高负载 - 稍长观察期
      - alert: CPUHighUsage
        expr: 100 - (avg(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m  # 5分钟观察期，避免临时高负载误报
        labels:
          severity: warning
        annotations:
          summary: "CPU使用率持续过高"
      
      # 磁盘使用率告警 - 更长观察期
      - alert: DiskSpaceUsageHigh
        expr: (node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes * 100 > 85
        for: 10m  # 磁盘使用率变化较慢，设置更长观察期
        labels:
          severity: warning
        annotations:
          summary: "磁盘空间使用率过高"
```

### 5.4 告警状态转换机制


```
告警状态流转图：
Inactive (未激活)
    ↓ 条件满足
Pending (待定状态，等待持续时间)
    ↓ 持续时间到达      ↓ 条件不再满足
Firing (触发告警)    或  返回 Inactive
    ↓ 条件恢复正常
Resolved (已恢复)
```

**🔄 状态说明**：
- **Inactive**：告警条件不满足，一切正常
- **Pending**：告警条件满足，但还在等待持续时间确认
- **Firing**：告警条件持续满足，正式触发告警
- **Resolved**：告警条件恢复正常，告警解除

---

## 6. 📄 告警模板与注释信息


### 6.1 注释信息的作用


💭 **为什么需要好的注释**：
想象你在深夜收到一个告警短信："CPUHigh"。这个信息对你有帮助吗？你根本不知道是哪台服务器，CPU多高，什么时候开始的。好的注释就是要告诉你："北京机房的web服务器CPU使用率达到92%，已经持续8分钟了，可能影响用户访问速度"。

### 6.2 注释字段详解


**📝 标准注释字段**：
- `summary`: **简短摘要** - 一句话说明问题
- `description`: **详细描述** - 包含具体数值、影响范围等
- `runbook_url`: **处理手册** - 指向问题处理文档
- `dashboard_url`: **监控面板** - 相关监控图表链接

### 6.3 模板变量使用


告警模板支持Go模板语法，可以动态插入实际数据：

```yaml
annotations:
  # 基础变量使用
  summary: "服务器 {{ $labels.instance }} CPU使用率过高"
  
  # 数值格式化
  description: "当前CPU使用率为 {{ printf \"%.2f\" $value }}%，已持续 {{ $labels.for }} 时间"
  
  # 条件判断
  impact: |
    {{ if gt $value 90 }}
    严重影响：系统响应极慢，可能出现服务中断
    {{ else if gt $value 80 }}
    中等影响：系统响应变慢，用户体验下降
    {{ else }}
    轻微影响：系统负载较高，需要关注
    {{ end }}
```

### 6.4 实用模板示例


```yaml
groups:
  - name: "完整模板示例"
    rules:
      - alert: HighCPUUsage
        expr: 100 - (avg by(instance)(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m
        labels:
          severity: warning
          team: sre
        annotations:
          # 简洁的摘要
          summary: "🔥 {{ $labels.instance }} CPU使用率告警"
          
          # 详细的描述信息
          description: |
            **告警详情：**
            - 服务器：{{ $labels.instance }}
            - 当前CPU使用率：{{ printf "%.1f" $value }}%
            - 持续时间：{{ .ActiveFor }}
            - 告警时间：{{ .StartsAt.Format "2006-01-02 15:04:05" }}
            
            **可能原因：**
            - 应用程序异常消耗CPU资源
            - 系统进程或服务异常
            - 恶意程序或病毒感染
            
            **建议处理：**
            1. 登录服务器查看top命令输出
            2. 检查应用程序日志
            3. 必要时重启相关服务
          
          # 处理手册链接
          runbook_url: "https://wiki.company.com/sre/cpu-high-troubleshooting"
          
          # 监控面板链接
          dashboard_url: "https://grafana.company.com/d/node-exporter/{{ $labels.instance }}"
```

---

## 7. 📁 规则组织与文件管理


### 7.1 文件组织策略


🏗️ **合理的文件组织**：就像整理书柜一样，把相关的书放在一起，贴上标签，这样查找和管理都方便。

**📂 推荐的目录结构**：
```
/etc/prometheus/rules/
├── infrastructure/          # 基础设施监控
│   ├── system.yml          # 系统资源监控
│   ├── network.yml         # 网络监控
│   └── storage.yml         # 存储监控
├── applications/           # 应用服务监控
│   ├── web-services.yml    # Web服务监控
│   ├── databases.yml       # 数据库监控
│   └── message-queues.yml  # 消息队列监控
├── business/               # 业务指标监控
│   ├── orders.yml          # 订单相关监控
│   └── users.yml           # 用户行为监控
└── kubernetes/             # K8s集群监控
    ├── nodes.yml           # 节点监控
    ├── pods.yml            # Pod监控
    └── services.yml        # 服务监控
```

### 7.2 规则分组策略


**🎯 分组原则**：
- **按功能分组**：相同功能的告警放在一个组里
- **按团队分组**：不同团队负责的服务分开管理
- **按紧急程度分组**：critical和warning级别分开
- **按评估频率分组**：需要不同检查频率的规则分开

```yaml
# /etc/prometheus/rules/infrastructure/system.yml
groups:
  # 系统资源 - 高频检查
  - name: "system-resources-critical"
    interval: 15s
    rules:
      - alert: SystemDown
        expr: up{job="node-exporter"} == 0
        for: 1m
        labels:
          severity: critical

  # 系统资源 - 普通检查
  - name: "system-resources-warning"
    interval: 30s
    rules:
      - alert: CPUUsageHigh
        expr: 100 - (avg(irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m
        labels:
          severity: warning
```

### 7.3 Prometheus配置集成


在Prometheus主配置文件中引用规则文件：

```yaml
# /etc/prometheus/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

# 规则文件配置
rule_files:
  - "rules/infrastructure/*.yml"
  - "rules/applications/*.yml"
  - "rules/business/*.yml"
  - "rules/kubernetes/*.yml"

# Alertmanager配置
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

---

## 8. ✅ 告警规则语法验证


### 8.1 语法检查工具


🔧 **为什么要验证语法**：
就像写代码一样，告警规则也可能有语法错误。如果规则文件有语法问题，Prometheus就无法正常加载，整个监控系统都会受影响。所以我们需要在部署前验证语法是否正确。

### 8.2 使用promtool验证


**命令行验证**：
```bash
# 检查规则文件语法
promtool check rules /etc/prometheus/rules/*.yml

# 验证整个Prometheus配置
promtool check config /etc/prometheus/prometheus.yml

# 测试具体的PromQL表达式
promtool query instant 'up'
promtool query range 'up' --start=2024-01-01T00:00:00Z --end=2024-01-01T01:00:00Z
```

**✅ 验证成功示例**：
```bash
$ promtool check rules /etc/prometheus/rules/system.yml
Checking /etc/prometheus/rules/system.yml
  SUCCESS: 3 rules found
```

**❌ 验证失败示例**：
```bash
$ promtool check rules /etc/prometheus/rules/system.yml
Checking /etc/prometheus/rules/system.yml
  FAILED:
    - group "system-alerts", rule 1, "CPUHigh": could not parse expression: parse error at char 15: unexpected identifier "by"
```

### 8.3 CI/CD集成验证


在部署管道中集成语法检查：

```bash
#!/bin/bash
# deploy-rules.sh

echo "开始验证告警规则语法..."

# 验证所有规则文件
if promtool check rules /etc/prometheus/rules/*.yml; then
    echo "✅ 规则语法验证通过"
else
    echo "❌ 规则语法验证失败，停止部署"
    exit 1
fi

# 重载Prometheus配置
echo "重载Prometheus配置..."
curl -X POST http://prometheus:9090/-/reload

echo "告警规则部署完成"
```

### 8.4 常见语法错误


**🚨 典型错误类型**：

```yaml
# ❌ 错误：YAML缩进不正确
groups:
- name: "test"
rules:  # 应该缩进两个空格
- alert: TestAlert

# ✅ 正确：
groups:
  - name: "test"
    rules:
      - alert: TestAlert

# ❌ 错误：PromQL语法错误
expr: cpu_usage > 80%  # 百分号不能直接使用

# ✅ 正确：
expr: cpu_usage > 80

# ❌ 错误：标签名包含特殊字符
labels:
  team-name: backend  # 连字符可能有问题

# ✅ 正确：
labels:
  team_name: backend
```

---

## 9. 🔄 动态规则加载与更新


### 9.1 热更新机制


💡 **理解热更新**：
想象你在开车途中需要调整导航路线，你不用停车重启导航，而是直接更新路线。Prometheus的热更新也是这样，不用重启整个服务就能加载新的告警规则。

### 9.2 手动热更新方法


**🔄 HTTP API方式**：
```bash
# 重载配置和规则（推荐方式）
curl -X POST http://prometheus-server:9090/-/reload

# 检查配置重载状态
curl http://prometheus-server:9090/api/v1/status/config

# 查看当前加载的规则
curl http://prometheus-server:9090/api/v1/rules
```

**⚠️ 重载注意事项**：
- 重载前先验证规则语法，避免加载失败
- 重载过程中可能有短暂的监控盲区
- 建议在业务低峰期进行规则更新

### 9.3 自动化更新方案


**🤖 基于文件监控的自动更新**：
```bash
#!/bin/bash
# auto-reload.sh - 监控规则文件变化并自动重载

RULES_DIR="/etc/prometheus/rules"
PROMETHEUS_URL="http://localhost:9090"

# 监控规则目录的文件变化
inotifywait -m -r -e modify,create,delete "$RULES_DIR" --format '%w%f %e' |
while read file event; do
    if [[ "$file" == *.yml ]]; then
        echo "检测到规则文件变化: $file ($event)"
        
        # 验证语法
        if promtool check rules "$RULES_DIR"/*.yml; then
            echo "语法验证通过，重载配置..."
            curl -X POST "$PROMETHEUS_URL/-/reload"
            echo "配置重载完成"
        else
            echo "语法验证失败，跳过重载"
        fi
    fi
done
```

### 9.4 集群环境下的规则同步


**🏢 多实例环境管理**：
```yaml
# docker-compose.yml 示例
version: '3.8'
services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./rules:/etc/prometheus/rules:ro
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--web.enable-lifecycle'  # 启用热更新API
    ports:
      - "9090:9090"

  # 规则管理容器
  rules-manager:
    image: alpine:latest
    volumes:
      - ./rules:/rules
      - ./scripts:/scripts
    command: /scripts/watch-rules.sh
```

**📋 规则版本管理**：
```bash
# 规则文件版本化管理
git add rules/
git commit -m "更新CPU告警阈值为85%"
git tag -a v1.2.0 -m "告警规则v1.2.0版本"

# 部署到生产环境
git checkout v1.2.0
docker-compose restart prometheus
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


🎯 **核心要点回顾**：
- **告警规则本质**：基于PromQL的自动化监控条件判断系统
- **文件结构**：groups -> rules -> alert/expr/for/labels/annotations
- **表达式编写**：清晰简洁的PromQL，避免过度复杂
- **标签设计**：层次化、标准化的标签体系
- **持续时间**：根据监控对象特性设置合理的观察期
- **注释信息**：提供详细有用的告警描述和处理指导

### 10.2 关键理解要点


**🔹 告警规则设计原则**：
```
精准性：准确识别真实问题，减少误报
及时性：在问题影响业务前及时发现
可操作性：提供明确的问题定位和处理指导
可维护性：规则易于理解、修改和管理
```

**🔹 文件管理最佳实践**：
- **模块化组织**：按功能、团队、环境分类管理
- **版本控制**：使用Git管理规则文件变更
- **自动化验证**：CI/CD流程中集成语法检查
- **动态更新**：支持热更新，减少服务中断

### 10.3 实际应用指导


**💼 生产环境实施步骤**：
1. **规划设计**：确定监控范围和告警级别分类
2. **文件组织**：建立清晰的规则文件目录结构
3. **规则编写**：从基础资源监控开始，逐步完善
4. **测试验证**：在测试环境充分验证后再上生产
5. **持续优化**：根据实际运行情况调整和完善规则

**⚡ 常见问题解决**：
- **告警风暴**：合理设置持续时间，使用告警分组和抑制
- **误报过多**：调整阈值和表达式，优化监控逻辑
- **遗漏告警**：完善监控覆盖范围，设置多层级告警
- **处理不及时**：优化通知方式，建立值班制度

### 10.4 进阶学习方向


**📚 扩展知识点**：
- **高级PromQL**：复杂聚合查询、时序预测函数
- **Alertmanager集成**：路由规则、通知模板、静默管理
- **自定义监控**：自定义exporter开发、业务指标设计
- **可观测性**：链路追踪、日志聚合、指标关联分析

**核心记忆**：
- 告警规则是监控系统的"智能大脑"，负责自动识别异常
- 好的规则设计需要平衡准确性、及时性和可操作性
- 文件组织和版本管理对大规模监控系统至关重要
- 持续优化和调整是监控系统运维的核心工作