---
title: 7、系统诊断工具集
---
## 📚 目录

1. [诊断工具概述](#1-诊断工具概述)
2. [进程诊断工具](#2-进程诊断工具)
3. [内存诊断工具](#3-内存诊断工具)
4. [存储诊断工具](#4-存储诊断工具)
5. [网络诊断工具](#5-网络诊断工具)
6. [系统调用跟踪](#6-系统调用跟踪)
7. [内核诊断工具](#7-内核诊断工具)
8. [硬件诊断工具](#8-硬件诊断工具)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 诊断工具概述


### 1.1 什么是系统诊断工具


**诊断工具**：Linux系统自带的用于分析、监控和排查系统问题的命令行程序。就像医生用听诊器检查病人身体一样，这些工具帮助我们"体检"服务器。

**为什么需要诊断工具**：
```
系统故障场景：
服务器响应慢 → 需要找出是CPU、内存还是磁盘问题
网站打不开 → 需要检查网络连接和端口状态
程序崩溃 → 需要分析进程状态和系统调用
磁盘空间满 → 需要找出哪些文件占用空间大

诊断工具的价值：
快速定位问题 → 不用靠猜测
量化系统状态 → 用数据说话
实时监控 → 及时发现异常
```

### 1.2 诊断工具分类体系


```
Linux诊断工具体系图：

系统诊断工具
├── 进程诊断 (Process)
│   ├── ps (进程状态快照)
│   ├── top (实时进程监控)
│   └── htop (增强版top)
├── 内存诊断 (Memory)
│   ├── free (内存使用情况)
│   └── vmstat (虚拟内存统计)
├── 存储诊断 (Storage)
│   ├── df (磁盘空间)
│   ├── du (目录占用)
│   └── iostat (I/O统计)
├── 网络诊断 (Network)
│   ├── ping (连通性测试)
│   ├── netstat (网络连接)
│   └── ss (套接字统计)
├── 系统调用 (System Call)
│   ├── strace (系统调用跟踪)
│   └── ltrace (库函数跟踪)
└── 硬件诊断 (Hardware)
    ├── lscpu (CPU信息)
    └── lspci (PCI设备)
```

### 1.3 诊断思路和方法


**🎯 系统性诊断方法**

| 诊断层面 | **关注指标** | **核心工具** | **典型问题** |
|---------|-------------|-------------|-------------|
| 🔥 **进程层** | `CPU使用率、内存占用` | `top, ps` | `进程占用资源过高` |
| 💾 **内存层** | `内存使用率、交换分区` | `free, vmstat` | `内存泄漏、OOM` |
| 💿 **存储层** | `磁盘空间、I/O性能` | `df, iostat` | `磁盘满、I/O瓶颈` |
| 🌐 **网络层** | `连通性、端口状态` | `ping, netstat` | `网络不通、端口被占` |
| ⚙️ **内核层** | `系统调用、内核消息` | `strace, dmesg` | `系统调用错误` |

---

## 2. ⚡ 进程诊断工具


### 2.1 ps命令 - 进程状态快照


**ps是什么**：Process Status的缩写，用来查看当前系统中运行的进程信息。就像给所有正在运行的程序拍了个"全家福"。

**💡 核心概念理解**
```
进程 = 正在运行的程序
每个程序启动后都会成为一个进程
每个进程都有唯一的进程号(PID)
进程有不同的状态：运行、睡眠、停止、僵尸
```

**🔧 常用ps命令组合**

```bash
# 查看所有进程的详细信息
ps aux

# 查看进程树状结构
ps -ef --forest

# 查看特定用户的进程
ps -u username

# 按CPU使用率排序
ps aux --sort=-pcpu
```

**📊 ps输出解读**
```
USER    PID  %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      1   0.0  0.1 225316  9012 ?        Ss   Dec01   0:02 systemd
mysql  1234   2.5 15.2 1753944 1247808 ?     Sl   Dec01  45:23 mysqld

关键字段含义：
USER：进程所属用户
PID：进程ID号
%CPU：CPU使用百分比  
%MEM：内存使用百分比
VSZ：虚拟内存大小(KB)
RSS：实际内存占用(KB)
STAT：进程状态(S=睡眠,R=运行,Z=僵尸)
```

### 2.2 top命令 - 实时进程监控


**top是什么**：实时显示系统中进程的动态信息，类似Windows任务管理器。能看到哪个进程最"贪心"地占用资源。

**🎯 top界面解读**

```
系统信息区域：
top - 14:30:25 up 5 days,  2:15,  3 users,  load average: 0.45, 0.32, 0.28
Tasks: 245 total,   2 running, 243 sleeping,   0 stopped,   0 zombie
%Cpu(s):  3.2 us,  1.1 sy,  0.0 ni, 95.5 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  7936.2 total,   1234.5 free,   3456.7 used,   3245.0 buff/cache
MiB Swap:  2048.0 total,   2048.0 free,      0.0 used.   4123.8 avail Mem

解释说明：
load average：系统负载(1分钟、5分钟、15分钟平均值)
us：用户进程CPU使用率
sy：系统进程CPU使用率  
id：空闲CPU百分比
wa：等待I/O的CPU时间百分比
```

**⚡ top实用技巧**

> 💡 **交互技巧**：在top运行时按这些键
> - `P`：按CPU使用率排序
> - `M`：按内存使用排序  
> - `k`：杀死指定进程
> - `q`：退出top

### 2.3 htop命令 - 增强版监控


**htop优势**：比top更直观美观，彩色显示，支持鼠标操作，像图形界面的任务管理器。

```
htop显示特点：
- 彩色进度条显示CPU和内存使用情况
- 可以用鼠标点击排序
- 直接显示完整命令行
- 更友好的进程树视图
```

### 2.4 其他进程工具


**pgrep - 按名字查找进程**
```bash
# 查找nginx进程的PID
pgrep nginx

# 查找并显示进程信息
pgrep -l httpd
```

**pstree - 进程树显示**
```bash
# 显示进程树结构
pstree

# 显示特定用户的进程树
pstree username
```

---

## 3. 💾 内存诊断工具


### 3.1 free命令 - 内存使用情况


**free是什么**：显示系统内存使用情况的工具。告诉你内存够不够用，有没有发生内存不足的问题。

**💡 内存概念理解**
```
物理内存(RAM)：真正的内存条
虚拟内存：硬盘作为内存使用(swap)
缓存(Cache)：系统为了加速而缓存的数据
缓冲区(Buffer)：I/O操作的临时存储
```

**🔧 free命令使用**

```bash
# 以人类可读格式显示
free -h

# 每秒刷新一次
free -s 1

输出示例：
               total        used        free      shared  buff/cache   available
Mem:            7.8G        2.1G        1.2G        145M        4.5G        5.2G
Swap:           2.0G          0B        2.0G

字段解释：
total：总内存大小
used：已使用内存
free：空闲内存  
buff/cache：缓存占用内存
available：真正可用内存(重要指标)
```

> ⚠️ **重要提醒**：不要被free字段迷惑！
> Linux会把空闲内存用来做缓存，看**available**字段才是真正可用内存

### 3.2 vmstat命令 - 虚拟内存统计


**vmstat是什么**：Virtual Memory Statistics，监控虚拟内存、进程、CPU活动的综合工具。

```bash
# 每2秒刷新一次，共显示5次
vmstat 2 5

输出示例：
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1234567  89123 456789    0    0    45   123  567  890  5  2 92  1  0

核心指标解读：
r：等待运行的进程数
b：不可中断睡眠的进程数
swpd：使用的swap大小
free：空闲内存
si/so：swap in/out速度
bi/bo：块设备读写速度
us/sy/id/wa：CPU使用情况
```

### 3.3 其他内存工具


**smem - 内存使用详情**
```bash
# 按内存使用排序
smem -s pss

# 显示进程内存映射
smem -m
```

**pmap - 进程内存映射**
```bash
# 查看进程内存布局
pmap -x [PID]
```

---

## 4. 💿 存储诊断工具


### 4.1 df命令 - 磁盘空间使用


**df是什么**：Disk Free的缩写，显示文件系统的磁盘空间使用情况。就像查看手机存储空间一样简单。

**🔧 df常用选项**

```bash
# 人类可读格式显示
df -h

# 显示文件系统类型
df -T

# 只显示本地文件系统
df -l

输出示例：
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        20G   15G  4.2G  79% /
/dev/sda2       100G   45G   50G  48% /home
tmpfs           4.0G     0  4.0G   0% /tmp

关键信息：
Size：总大小
Used：已使用
Avail：可用空间
Use%：使用百分比(超过90%需要注意)
Mounted on：挂载点
```

> 🚨 **磁盘空间警告阈值**
> - **90%以上**：需要清理空间
> - **95%以上**：系统可能出现问题
> - **100%**：系统无法写入新文件

### 4.2 du命令 - 目录空间占用


**du是什么**：Disk Usage，统计目录或文件的磁盘使用量。帮你找出是哪个文件夹占用空间最大。

```bash
# 查看当前目录各子目录大小
du -h --max-depth=1

# 查看最大的10个目录
du -h | sort -hr | head -10

# 查看特定目录总大小
du -sh /var/log

输出解读：
4.2G    /var/log
1.8G    /home/user/downloads  
567M    /tmp
234M    /opt

直观含义：
/var/log目录占用4.2GB空间
/home/user/downloads占用1.8GB空间
```

### 4.3 lsof命令 - 打开文件列表


**lsof是什么**：List Open Files，显示系统中被进程打开的文件。在Unix/Linux系统中"一切皆文件"，所以这个工具很强大。

**🎯 lsof实用场景**

```bash
# 查看谁在使用某个文件
lsof /path/to/file

# 查看某个进程打开的文件
lsof -p [PID]

# 查看某个端口被谁占用
lsof -i :80

# 查看某个用户打开的文件
lsof -u username

典型应用场景：
"设备忙，无法卸载" → 用lsof找出谁在使用
"端口被占用" → 用lsof -i找出占用进程
"删除文件后空间没释放" → 用lsof找出还在使用的进程
```

### 4.4 I/O性能诊断工具


**iostat命令 - I/O统计**
```bash
# 每秒显示I/O统计
iostat 1

# 显示扩展统计信息
iostat -x 1

关键指标：
%iowait：CPU等待I/O的时间百分比
r/s, w/s：每秒读写次数
rkB/s, wkB/s：每秒读写数据量(KB)
avgqu-sz：平均I/O队列长度
await：平均I/O响应时间
```

**iotop命令 - I/O监控**
```bash
# 实时显示进程I/O使用情况
iotop

# 只显示有I/O活动的进程
iotop -o
```

---

## 5. 🌐 网络诊断工具


### 5.1 ping命令 - 网络连通性测试


**ping是什么**：测试网络连通性的基础工具。就像喊话看对方能不能听到并回应一样。

**💡 ping工作原理**
```
ping的过程：
你的电脑 → 发送ICMP回音请求 → 目标主机
你的电脑 ← 接收ICMP回音回复 ← 目标主机

衡量指标：
往返时间(RTT)：数据包来回的时间
丢包率：有多少数据包丢失了
```

**🔧 ping实用技巧**

```bash
# 基本ping测试
ping google.com

# 指定ping次数
ping -c 4 baidu.com

# 设置ping间隔
ping -i 2 192.168.1.1

# 大包ping测试
ping -s 1024 目标地址

输出解读：
PING google.com (142.250.191.14): 56 data bytes
64 bytes from 142.250.191.14: icmp_seq=1 ttl=54 time=15.2 ms
64 bytes from 142.250.191.14: icmp_seq=2 ttl=54 time=14.8 ms

含义说明：
time=15.2 ms：往返时间15.2毫秒
ttl=54：生存时间，经过的路由器数量相关
icmp_seq：序列号，用来匹配请求和响应
```

> 📊 **ping时间评估标准**
> - **<10ms**：优秀 ⭐⭐⭐⭐⭐
> - **10-50ms**：良好 ⭐⭐⭐⭐
> - **50-100ms**：一般 ⭐⭐⭐  
> - **>100ms**：较慢 ⭐⭐

### 5.2 traceroute命令 - 路径追踪


**traceroute是什么**：追踪数据包到达目标主机经过的路径。就像GPS导航显示你经过了哪些路口一样。

```bash
# 追踪到目标的网络路径
traceroute google.com

输出示例：
traceroute to google.com (142.250.191.14), 30 hops max, 60 byte packets
 1  192.168.1.1    1.234 ms   1.123 ms   0.987 ms
 2  10.0.0.1      15.234 ms  14.567 ms  15.123 ms
 3  61.145.123.1   25.678 ms  24.789 ms  25.456 ms
 ...

解读说明：
每一行代表一个网络节点(路由器)
三个时间是三次测试的往返时间
可以看出网络延迟在哪个节点突然增加
```

### 5.3 netstat命令 - 网络连接状态


**netstat是什么**：显示网络连接、路由表、接口统计等网络相关信息。

**🔧 netstat常用组合**

```bash
# 显示所有TCP连接
netstat -ant

# 显示监听端口
netstat -anl

# 显示进程和端口的对应关系
netstat -anp

# 统计网络连接状态
netstat -s

输出解读：
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program
tcp        0      0 0.0.0.0:22             0.0.0.0:*               LISTEN      1234/sshd
tcp        0      0 192.168.1.100:22       192.168.1.200:54321     ESTABLISHED 5678/sshd

字段含义：
Proto：协议类型(tcp/udp)
Local Address：本地地址和端口  
Foreign Address：远程地址和端口
State：连接状态(LISTEN/ESTABLISHED等)
PID/Program：进程ID和程序名
```

**📊 连接状态含义**

| 状态 | **含义** | **说明** |
|------|---------|---------|
| `LISTEN` | 监听状态 | 服务端等待客户端连接 |
| `ESTABLISHED` | 已建立连接 | 正常的数据传输状态 |
| `TIME_WAIT` | 等待足够时间 | 连接关闭后的等待状态 |
| `CLOSE_WAIT` | 等待关闭 | 对方已关闭，等待本地关闭 |

### 5.4 ss命令 - 现代版netstat


**ss是什么**：Socket Statistics，现代版的netstat，速度更快，信息更详细。

```bash
# 显示所有TCP连接
ss -ant

# 显示监听的端口
ss -anl

# 显示特定端口的连接
ss -ant sport :80

# 显示进程信息
ss -antp
```

### 5.5 tcpdump命令 - 网络抓包


**tcpdump是什么**：网络数据包捕获工具，可以"窃听"网络通信内容，用于网络问题深度分析。

```bash
# 抓取网卡eth0上的数据包
tcpdump -i eth0

# 抓取特定端口的数据包  
tcpdump port 80

# 抓取特定主机的通信
tcpdump host 192.168.1.100

# 保存抓包结果到文件
tcpdump -w capture.pcap port 443
```

> ⚠️ **使用tcpdump注意事项**
> - 需要root权限
> - 会产生大量数据，注意磁盘空间
> - 可能涉及隐私，谨慎使用

---

## 6. 🔎 系统调用跟踪


### 6.1 strace命令 - 系统调用跟踪


**strace是什么**：System Call Trace，跟踪进程的系统调用。就像给程序装上"窃听器"，听它和操作系统的对话。

**💡 什么是系统调用**
```
系统调用 = 程序向操作系统请求服务的方式

常见系统调用：
open()：打开文件
read()：读取数据
write()：写入数据  
connect()：网络连接
malloc()：内存分配

为什么要跟踪：
程序出错时，看看它最后在做什么
程序运行慢，看看卡在哪个操作上
程序崩溃时，找出根本原因
```

**🔧 strace使用方法**

```bash
# 跟踪正在运行的进程
strace -p [PID]

# 跟踪新启动的程序
strace ./myprogram

# 只跟踪文件操作
strace -e trace=file ./myprogram

# 统计系统调用
strace -c ./myprogram

输出示例：
open("/etc/passwd", O_RDONLY)           = 3
read(3, "root:x:0:0:root:/root:/bin/bash"..., 4096) = 1847
close(3)                                = 0

解读：
程序打开了/etc/passwd文件，得到文件描述符3
从文件描述符3读取了1847字节数据
关闭了文件描述符3
```

**🎯 strace实战应用**

> 📝 **典型故障排查场景**
> - 程序启动失败 → 看它试图访问哪个文件失败
> - 程序运行卡住 → 看它卡在哪个系统调用上
> - 配置文件不生效 → 看程序实际读取了哪个配置文件

### 6.2 ltrace命令 - 库函数跟踪


**ltrace是什么**：Library Trace，跟踪程序调用的库函数。如果strace看系统调用，ltrace就看程序调用的各种函数库。

```bash
# 跟踪库函数调用
ltrace ./myprogram

# 跟踪特定进程
ltrace -p [PID]

输出示例：
printf("Hello World\n")                 = 12
malloc(1024)                            = 0x55a123456000
strcpy(0x55a123456000, "test")          = 0x55a123456000
free(0x55a123456000)                    = <void>
```

### 6.3 perf命令 - 性能分析工具


**perf是什么**：Linux内核自带的性能分析工具，可以分析CPU使用情况、找出性能热点。

```bash
# 性能统计
perf stat ./myprogram

# CPU采样分析
perf record ./myprogram
perf report

# 实时性能监控
perf top

关键指标：
cycles：CPU周期数
instructions：执行的指令数
cache-misses：缓存未命中次数
```

---

## 7. ⚙️ 内核诊断工具


### 7.1 dmesg命令 - 内核消息


**dmesg是什么**：Display Message，显示内核的消息缓冲区内容。就像系统的"黑匣子"，记录了系统启动和运行时的重要信息。

**💡 内核消息的重要性**
```
内核消息包含：
硬件检测信息：系统启动时检测到的硬件
驱动加载信息：各种设备驱动的加载状态
错误信息：硬件故障、驱动错误等
系统事件：设备热插拔、网络状态变化等

为什么重要：
很多系统问题的根源都在内核消息里
硬件故障通常会在dmesg中留下痕迹
驱动问题、内存错误都会记录在这里
```

**🔧 dmesg使用技巧**

```bash
# 显示所有内核消息
dmesg

# 实时显示新消息
dmesg -w

# 按时间排序显示
dmesg -T

# 只显示错误信息
dmesg -l err

# 清空消息缓冲区
dmesg -c

常见消息类型：
[    0.000000] Linux version 5.4.0-42-generic
[    0.123456] Memory: 8GB available  
[   10.234567] USB disconnect, address 1
[ERROR] Out of memory: Kill process 1234
```

> 🚨 **重要错误信息关键词**
> - **Out of memory**：内存不足，系统杀进程
> - **segfault**：程序段错误，通常是程序bug
> - **I/O error**：硬盘读写错误，可能硬盘故障
> - **Temperature above threshold**：温度过高警告

### 7.2 journalctl命令 - 系统日志查询


**journalctl是什么**：现代Linux系统(systemd)的日志查询工具，比传统的/var/log文件查看更强大。

```bash
# 查看所有日志
journalctl

# 查看特定服务的日志
journalctl -u nginx

# 实时跟踪日志
journalctl -f

# 查看启动日志
journalctl -b

# 查看特定时间段的日志
journalctl --since "2024-01-01 00:00:00"

# 按优先级过滤
journalctl -p err
```

### 7.3 /proc文件系统 - 系统信息接口


**/proc是什么**：Linux的虚拟文件系统，实时显示内核和进程信息。就像系统的"仪表盘"。

**🔧 重要的/proc文件**

```bash
# CPU信息
cat /proc/cpuinfo

# 内存信息  
cat /proc/meminfo

# 系统运行时间和负载
cat /proc/uptime
cat /proc/loadavg

# 网络统计
cat /proc/net/dev

# 进程信息(以PID=1234为例)
cat /proc/1234/status    # 进程状态
cat /proc/1234/cmdline   # 启动命令行
cat /proc/1234/environ   # 环境变量
```

**📊 /proc/meminfo详解**
```bash
cat /proc/meminfo

MemTotal:        8165888 kB    # 总内存
MemFree:         1234567 kB    # 空闲内存
MemAvailable:    5678901 kB    # 可用内存
Buffers:          123456 kB    # 缓冲区
Cached:          2345678 kB    # 缓存
SwapTotal:       2097148 kB    # 交换分区总大小
SwapFree:        2097148 kB    # 交换分区空闲
```

### 7.4 /sys文件系统 - 硬件设备接口


**/sys是什么**：系统设备和驱动信息的接口，可以查看和控制硬件设备。

```bash
# 查看CPU频率
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq

# 查看电源管理信息
cat /sys/class/power_supply/BAT0/capacity

# 查看网卡状态
cat /sys/class/net/eth0/operstate

# 查看硬盘信息
ls /sys/block/
```

---

## 8. 🖥️ 硬件诊断工具


### 8.1 lscpu命令 - CPU信息查看


**lscpu是什么**：List CPU，以人类友好的方式显示CPU架构信息。

```bash
lscpu

输出示例：
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
CPU(s):              8
On-line CPU(s) list: 0-7
Thread(s) per core:  2
Core(s) per socket:  4
Socket(s):           1
Vendor ID:           GenuineIntel
CPU family:          6
Model:               142
Model name:          Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz

关键信息解读：
CPU(s): 8 → 系统有8个逻辑CPU
Thread(s) per core: 2 → 每核心2个线程(支持超线程)
Core(s) per socket: 4 → 每个CPU插槽4个物理核心
Socket(s): 1 → 1个CPU插槽
```

**💡 CPU相关概念理解**
```
物理CPU：主板上实际的CPU芯片数量
物理核心：每个CPU芯片中的处理核心数
逻辑CPU：操作系统能看到的CPU数量(核心×超线程数)

计算公式：
逻辑CPU数 = 物理CPU数 × 每CPU核心数 × 超线程数

例子：1个CPU × 4核心 × 2超线程 = 8个逻辑CPU
```

### 8.2 内存信息查看


**lsmem命令 - 内存模块信息**
```bash
lsmem

输出示例：
RANGE                                  SIZE   STATE REMOVABLE BLOCK
0x0000000000000000-0x000000007fffffff  2G    online       yes     0
0x0000000100000000-0x000000017fffffff  2G    online       yes     1
...

# 查看内存详细信息
cat /proc/meminfo | head -10
```

**dmidecode命令 - 硬件详细信息**
```bash
# 查看内存条信息
dmidecode -t memory

# 查看主板信息  
dmidecode -t baseboard

# 查看系统信息
dmidecode -t system
```

### 8.3 PCI设备信息


**lspci命令 - PCI设备列表**
```bash
# 列出所有PCI设备
lspci

# 显示详细信息
lspci -v

# 显示数字ID
lspci -n

输出示例：
00:00.0 Host bridge: Intel Corporation 8th Gen Core Processor Host Bridge
00:02.0 VGA compatible controller: Intel Corporation UHD Graphics 620
00:14.0 USB controller: Intel Corporation Cannon Point-LP USB 3.1 xHCI Controller
00:1f.0 ISA bridge: Intel Corporation Cannon Point-LP LPC Controller
```

### 8.4 USB设备信息


**lsusb命令 - USB设备列表**
```bash
# 列出USB设备
lsusb

# 显示设备树
lsusb -t

输出示例：
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 8087:0aaa Intel Corp.
Bus 001 Device 003: ID 046d:c52f Logitech, Inc. Unifying Receiver
```

### 8.5 硬盘信息查看


```bash
# 查看硬盘分区信息
lsblk

# 查看硬盘详细信息
fdisk -l

# 查看硬盘健康状态(需要smartmontools)
smartctl -a /dev/sda

输出示例(lsblk)：
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 931.5G  0 disk 
├─sda1   8:1    0   512M  0 part /boot/efi
├─sda2   8:2    0    20G  0 part /
└─sda3   8:3    0   911G  0 part /home
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的诊断思路


```
🔸 分层诊断法：从应用→系统→硬件逐层排查
🔸 数据驱动：用工具获取准确数据，不靠猜测
🔸 对比分析：正常时vs异常时的数据对比
🔸 实时监控：使用动态工具观察系统变化
🔸 日志分析：系统日志往往包含关键信息
```

### 9.2 工具选择策略


| 问题类型 | **首选工具** | **辅助工具** | **深入工具** |
|---------|------------|-------------|-------------|
| 🔥 **CPU高** | `top, htop` | `ps aux` | `perf top` |
| 💾 **内存不足** | `free -h` | `vmstat` | `pmap, smem` |
| 💿 **磁盘问题** | `df -h, du` | `iostat` | `iotop, lsof` |
| 🌐 **网络故障** | `ping, ss` | `netstat` | `tcpdump` |
| ⚙️ **程序异常** | `strace -p` | `lsof -p` | `gdb` |
| 🖥️ **硬件故障** | `dmesg` | `lscpu, lspci` | `smartctl` |

### 9.3 常见故障排查流程


**🎯 系统响应慢排查步骤**
```
1. top/htop → 看CPU和内存使用情况
2. iostat → 看磁盘I/O是否有瓶颈  
3. free -h → 确认内存是否充足
4. ss/netstat → 检查网络连接状态
5. dmesg → 查看是否有硬件错误
6. strace → 对慢进程进行详细分析
```

**🚨 紧急故障处理优先级**

> ⭐ **1级紧急**：系统无响应
> → `dmesg` 查看内核消息
> → `top` 找出占用资源的进程
> 
> ⭐ **2级重要**：服务异常
> → `systemctl status` 检查服务状态
> → `journalctl -u` 查看服务日志
> 
> ⭐ **3级一般**：性能问题
> → `iostat`, `vmstat` 系统性能分析
> → `perf` 深入性能分析

### 9.4 监控指标阈值参考


**📊 关键指标告警阈值**

| 指标类型 | **正常范围** | **警告阈值** | **危险阈值** |
|---------|-------------|-------------|-------------|
| 🔥 **CPU使用率** | `< 70%` | `70-90%` | `> 90%` |
| 💾 **内存使用率** | `< 80%` | `80-95%` | `> 95%` |
| 💿 **磁盘使用率** | `< 80%` | `80-95%` | `> 95%` |
| ⏱️ **系统负载** | `< 核心数` | `1-2倍核心数` | `> 2倍核心数` |
| 🌐 **网络延迟** | `< 50ms` | `50-100ms` | `> 100ms` |

### 9.5 实用技巧总结


**💡 提高诊断效率的技巧**

> 📝 **命令组合使用**
> ```bash
> # 一行命令找出占用CPU最多的进程
> ps aux --sort=-pcpu | head -5
> 
> # 一行命令找出占用内存最多的进程  
> ps aux --sort=-pmem | head -5
> 
> # 实时监控磁盘使用变化
> watch -n 1 'df -h'
> ```

> 🔧 **脚本化监控**
> - 将常用诊断命令写成脚本
> - 设置定时任务收集系统信息
> - 建立基线数据库便于对比分析

**核心记忆要点**：
- 工具很多不用慌，按层次分类来使用
- 进程内存存储网络内核硬件，七大类别要分清
- 数据说话最可靠，实时监控加日志
- 故障排查有套路，从简单到复杂层层推进