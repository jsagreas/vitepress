---
title: 14、故障排查工具箱
---
## 📚 目录

1. [故障排查工具体系概览](#1-故障排查工具体系概览)
2. [系统诊断工具集详解](#2-系统诊断工具集详解)
3. [网络诊断工具集实践](#3-网络诊断工具集实践)
4. [性能分析工具集应用](#4-性能分析工具集应用)
5. [日志分析工具集掌握](#5-日志分析工具集掌握)
6. [监控工具集成使用](#6-监控工具集成使用)
7. [故障排查脚本库建设](#7-故障排查脚本库建设)
8. [应急工具包与标准化](#8-应急工具包与标准化)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 故障排查工具体系概览


### 1.1 什么是故障排查工具箱


**故障排查工具箱**就是运维工程师的"医疗急救包"，里面装着各种"诊断设备"来快速定位和解决系统问题。

> **💡 核心理解**
> 工具箱 = 诊断工具 + 分析方法 + 解决方案，三位一体的故障处理体系

**🎯 工具箱的价值：**
- **快速定位**：从现象快速找到根本原因
- **标准化**：统一的排查流程和方法
- **经验积累**：将解决方案沉淀为可复用工具
- **效率提升**：减少故障处理时间

### 1.2 工具分类体系


```
故障排查工具分类图：
┌─────────────────────────────────────┐
│          故障排查工具箱              │
├─────────────────────────────────────┤
│ 系统诊断  │ 网络诊断  │ 性能分析    │
│ htop      │ tcpdump   │ perf       │
│ iostat    │ nmap      │ strace     │
│ netstat   │ curl      │ lsof       │
├─────────────────────────────────────┤
│ 日志分析  │ 监控集成  │ 脚本工具    │
│ grep      │ grafana   │ 自定义脚本  │
│ awk       │ zabbix    │ 标准工具包  │
│ journalctl│ prometheus│ 应急预案    │
└─────────────────────────────────────┘
```

### 1.3 工具选择原则


**🔸 基础原则：**
- **先系统后应用**：从底层硬件到上层应用逐层排查
- **先简单后复杂**：优先使用轻量级工具，避免影响生产
- **先现象后原因**：观察现象→收集数据→分析原因
- **标准化优先**：使用团队统一的工具和方法

---

## 2. 🖥️ 系统诊断工具集详解


### 2.1 htop - 可视化进程监控


**htop**是top命令的增强版，提供彩色界面和交互功能，就像给系统装了一个"仪表盘"。

> **⚠️ 使用场景**
> 当系统响应缓慢时，htop是第一个要打开的工具，快速查看CPU、内存使用情况

**🔧 核心功能：**
- **彩色显示**：不同颜色代表不同状态
- **交互操作**：可以直接杀进程、排序
- **资源监控**：CPU、内存、交换分区实时显示

**📊 界面解读：**
```
htop界面布局：
┌─ CPU使用率条 ──────────┐
│ CPU[||||||||   45.2%] │ ← 每个CPU核心使用率
│ Mem[|||||||| 2.1G/8G] │ ← 内存使用情况  
│ Swp[         0K/2G  ] │ ← 交换分区使用
├────────────────────────┤
│ PID  USER  CPU%  MEM%  │ ← 进程详细信息
│ 1234 root  23.1  15.2  │
└────────────────────────┘
```

**⚡ 实用快捷键：**

| 按键 | **功能** | **使用场景** |
|------|----------|-------------|
| `F6` | 排序选择 | 按CPU或内存排序找问题进程 |
| `F9` | 杀进程 | 终止异常进程 |
| `F4` | 过滤 | 查找特定进程名 |
| `/` | 搜索 | 快速定位进程 |
| `Space` | 标记进程 | 批量操作多个进程 |

**🎯 实践技巧：**
```bash
# 安装htop（如果系统没有）
sudo apt install htop

# 启动并常用操作
htop
# → 按F6选择按CPU排序
# → 找到CPU占用最高的进程
# → 按F4过滤特定程序名
# → 按F9终止问题进程
```

### 2.2 iostat - I/O性能分析神器


**iostat**专门分析磁盘I/O性能，就像给磁盘装了个"速度计"。

**🔍 核心指标解读：**
```bash
$ iostat -x 2 5
# -x: 显示详细信息
# 2: 每2秒刷新一次
# 5: 总共显示5次

Device    r/s   w/s    rkB/s   wkB/s  %util
sda1     12.3  45.6   156.7   892.1   85.2
```

**📋 关键指标含义：**
- `r/s, w/s`：每秒读写次数
- `rkB/s, wkB/s`：每秒读写数据量
- `%util`：**最重要** - 磁盘使用率，超过80%需要关注
- `await`：平均等待时间，过高说明磁盘慢

> **🔸 判断标准**
> %util > 80%：磁盘可能成为瓶颈  
> await > 20ms：响应时间过长  
> r/s + w/s 过高：I/O压力大

### 2.3 netstat - 网络连接状态检查


**netstat**查看网络连接状态，就像查看"网络体检报告"。

**⚡ 常用命令组合：**
```bash
# 查看所有TCP连接
netstat -tuln

# 查看特定端口占用
netstat -tlnp | grep :80

# 查看网络统计
netstat -i  # 网络接口统计
netstat -s  # 协议统计信息
```

**📊 连接状态解读：**

| 状态 | **含义** | **正常性** |
|------|----------|-----------|
| `LISTEN` | 端口监听中 | ✅ 服务正常 |
| `ESTABLISHED` | 连接已建立 | ✅ 通信正常 |
| `TIME_WAIT` | 连接关闭等待 | ⚠️ 数量过多需关注 |
| `CLOSE_WAIT` | 等待关闭 | ❌ 可能有程序bug |

**🔧 实际排查案例：**
```bash
# 场景：网站访问慢
# 1. 检查Web服务端口
netstat -tlnp | grep :80
# 结果：tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1234/nginx

# 2. 查看连接数
netstat -an | grep :80 | wc -l
# 结果：1250 (连接数)

# 3. 分析连接状态分布
netstat -an | grep :80 | awk '{print $6}' | sort | uniq -c
#   800 ESTABLISHED  ← 正常连接
#   450 TIME_WAIT    ← 等待关闭，数量正常
```

---

## 3. 🌐 网络诊断工具集实践


### 3.1 tcpdump - 网络数据包抓取分析


**tcpdump**是网络故障排查的"显微镜"，能看到网络通信的每个细节。

> **💡 核心理解**
> tcpdump让网络通信变得透明，就像偷听两个人的电话对话

**🔧 基础使用语法：**
```bash
# 基本格式
tcpdump -i 网卡 -n 过滤条件

# 常用参数
-i eth0    # 指定网络接口
-n         # 不解析域名，显示IP
-c 100     # 抓取100个包就停止
-w file.cap # 保存到文件
```

**📋 实用过滤表达式：**

| 过滤条件 | **作用** | **示例** |
|----------|----------|----------|
| `host IP` | 指定主机 | `host 192.168.1.100` |
| `port 端口` | 指定端口 | `port 80` |
| `tcp/udp` | 协议过滤 | `tcp port 22` |
| `src/dst` | 方向过滤 | `src host 10.0.0.1` |

**🎯 实际应用场景：**

**场景1：网站无法访问**
```bash
# 抓取HTTP通信包
sudo tcpdump -i eth0 -n port 80

# 分析结果
# 12:34:56.789 IP 192.168.1.100.45678 > 192.168.1.200.80: Flags [S]
# ↑ 客户端发起连接请求
# 12:34:56.790 IP 192.168.1.200.80 > 192.168.1.100.45678: Flags [R]  
# ↑ 服务器拒绝连接，说明服务有问题
```

**场景2：SSH连接异常**
```bash
# 专门抓取SSH流量
sudo tcpdump -i any -n 'port 22 and host 192.168.1.50'

# 保存详细分析
sudo tcpdump -i eth0 -s 0 -w ssh_debug.cap port 22
# 后续用wireshark分析
```

### 3.2 nmap - 网络端口扫描工具


**nmap**是网络的"探测器"，能发现网络中的主机和服务。

**🔍 基础扫描类型：**
```bash
# 主机发现扫描
nmap -sn 192.168.1.0/24  # 扫描整个网段活动主机

# 端口扫描
nmap 192.168.1.100       # 扫描常见端口
nmap -p 1-1000 192.168.1.100  # 扫描指定端口范围

# 服务版本检测
nmap -sV 192.168.1.100   # 检测服务版本信息
```

**⚡ 快速故障诊断：**
```bash
# 检查Web服务是否正常
nmap -p 80,443 web.example.com

# 检查数据库连接
nmap -p 3306,5432 db.example.com

# 检查防火墙规则
nmap -sS 192.168.1.100  # SYN扫描，不建立完整连接
```

### 3.3 curl - HTTP请求测试工具


**curl**是网络请求的"瑞士军刀"，能模拟各种HTTP请求。

**🔧 常用测试场景：**

**场景1：测试API接口**
```bash
# GET请求测试
curl -v http://api.example.com/users
# -v 显示详细过程

# POST请求测试
curl -X POST -H "Content-Type: application/json" \
     -d '{"name":"test"}' http://api.example.com/users

# 测试响应时间
curl -w "@curl-format.txt" http://example.com
# curl-format.txt内容：
# time_total: %{time_total}
# time_connect: %{time_connect}
# time_starttransfer: %{time_starttransfer}
```

**场景2：SSL证书检查**
```bash
# 检查HTTPS证书
curl -vI https://secure.example.com

# 忽略证书错误（测试用）
curl -k https://self-signed.example.com

# 检查证书过期时间
curl -vI https://example.com 2>&1 | grep -E "(expire|valid)"
```

---

## 4. ⚡ 性能分析工具集应用


### 4.1 perf - 系统性能剖析器


**perf**是Linux内核提供的性能分析工具，能深入分析程序性能瓶颈。

> **🔍 实际价值**
> perf能告诉你程序把时间花在哪里了，就像给程序做"体检"

**🔧 核心功能使用：**
```bash
# CPU使用情况统计
perf top  # 实时显示CPU热点函数

# 性能事件统计
perf stat ./your-program  # 统计程序执行的性能指标

# 函数调用分析
perf record ./your-program  # 记录性能数据
perf report                 # 分析记录的数据
```

**📊 性能指标解读：**
- **cycles**：CPU周期数
- **instructions**：执行的指令数
- **cache-misses**：缓存未命中次数
- **page-faults**：页面错误次数

### 4.2 strace - 系统调用跟踪


**strace**跟踪程序的系统调用，就像给程序装了个"监听器"。

**⚡ 实用排查场景：**

**场景1：程序启动慢**
```bash
# 跟踪程序启动过程
strace -tt -o startup.log ./slow-program

# 分析日志找耗时操作
grep -E "(open|read|write)" startup.log | head -20
```

**场景2：程序异常退出**
```bash
# 跟踪程序执行到退出
strace -f ./buggy-program 2>&1 | tail -50
# -f 跟踪子进程
```

### 4.3 lsof - 文件和网络连接查看


**lsof**显示系统中打开的文件和网络连接，就像系统的"透视镜"。

**🔧 常用查询方式：**

| 命令 | **功能** | **使用场景** |
|------|----------|-------------|
| `lsof -i :80` | 查看80端口占用 | Web服务故障排查 |
| `lsof -p 1234` | 查看进程打开的文件 | 进程资源使用分析 |
| `lsof /var/log/` | 查看目录文件占用 | 磁盘空间问题 |
| `lsof -u username` | 查看用户打开的文件 | 用户行为分析 |

**🎯 实际应用：**
```bash
# 问题：无法删除文件，提示"设备或资源忙"
# 解决：找出哪个进程在使用这个文件
lsof /path/to/locked-file
# 结果显示进程PID，然后决定是否终止该进程

# 问题：端口被占用，服务无法启动
# 解决：查看端口占用情况
lsof -i :8080
# 找到占用进程，分析是否冲突
```

---

## 5. 📋 日志分析工具集掌握


### 5.1 grep - 文本搜索利器


**grep**是日志分析的基础工具，就像文本中的"搜索引擎"。

**🔧 高效使用技巧：**

**基础搜索模式：**
```bash
# 基本搜索
grep "ERROR" /var/log/app.log

# 忽略大小写
grep -i "error" /var/log/app.log

# 显示行号
grep -n "404" /var/log/nginx/access.log

# 搜索多个文件
grep -r "database connection" /var/log/
```

**高级搜索技巧：**
```bash
# 正则表达式搜索
grep -E "2[0-9]{3}-[0-9]{2}-[0-9]{2}" /var/log/app.log  # 匹配日期

# 反向匹配（排除）
grep -v "INFO" /var/log/app.log  # 显示非INFO日志

# 上下文显示
grep -A 5 -B 5 "Exception" /var/log/error.log  # 显示错误前后5行

# 只显示匹配行数
grep -c "ERROR" /var/log/app.log
```

### 5.2 awk - 强大的文本处理工具


**awk**是日志分析的"瑞士军刀"，能进行复杂的文本处理和统计。

**📊 实用分析场景：**

**场景1：访问日志分析**
```bash
# 统计访问最多的IP
awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -10

# 统计HTTP状态码分布
awk '{print $9}' /var/log/nginx/access.log | sort | uniq -c | sort -nr

# 分析响应时间（假设在第10列）
awk '$10 > 1.0 {print $0}' /var/log/nginx/access.log  # 响应时间超过1秒的请求
```

**场景2：应用日志统计**
```bash
# 按小时统计错误数量
awk '/ERROR/ {hour=substr($1,12,2); errors[hour]++} END {for(h in errors) print h"时: "errors[h]"个错误"}' app.log

# 计算平均响应时间
awk '{sum+=$5; count++} END {print "平均响应时间:", sum/count, "ms"}' response.log
```

### 5.3 journalctl - systemd日志查看


**journalctl**是现代Linux系统的日志查看工具，功能强大且使用方便。

**⚡ 常用查看方式：**
```bash
# 查看系统启动日志
journalctl -b

# 跟踪实时日志
journalctl -f

# 查看特定服务日志
journalctl -u nginx.service

# 按时间范围查看
journalctl --since "2025-01-01" --until "2025-01-02"

# 按日志级别过滤
journalctl -p err  # 只看错误级别
```

**🎯 实际故障排查：**
```bash
# 系统启动异常排查
journalctl -b -p err  # 查看本次启动的所有错误

# 服务异常排查
journalctl -u mysql.service --since "1 hour ago"  # 查看MySQL最近1小时日志

# 内核问题排查
journalctl -k  # 查看内核日志
```

---

## 6. 📊 监控工具集成使用


### 6.1 监控工具生态系统


**监控工具集成**就是把各种监控工具串联起来，形成完整的"健康检查体系"。

```
监控工具集成架构：
┌─────────────────────────────────────┐
│              数据展示               │
│           Grafana/Kibana            │
├─────────────────────────────────────┤
│              数据存储               │
│       InfluxDB/Elasticsearch        │
├─────────────────────────────────────┤
│              数据收集               │
│    Telegraf/Beats/Node_exporter     │
├─────────────────────────────────────┤
│              监控对象               │
│      服务器/应用/数据库/网络         │
└─────────────────────────────────────┘
```

### 6.2 Prometheus + Grafana 组合


**核心优势：**
- **Prometheus**：强大的时序数据库和监控引擎
- **Grafana**：美观的可视化面板
- **组合效果**：1+1>2的监控解决方案

**🔧 快速搭建：**
```bash
# 使用Docker快速部署
docker run -d --name=prometheus -p 9090:9090 prom/prometheus
docker run -d --name=grafana -p 3000:3000 grafana/grafana

# 配置Node Exporter收集系统指标
docker run -d --name=node_exporter -p 9100:9100 prom/node-exporter
```

### 6.3 集成监控实践


**🎯 监控指标体系：**

| 层级 | **监控对象** | **关键指标** | **告警阈值** |
|------|-------------|-------------|-------------|
| **基础设施** | CPU/内存/磁盘 | 使用率、IOPS | CPU>80%, 磁盘>90% |
| **应用层** | 应用性能 | 响应时间、错误率 | 响应>2s, 错误率>1% |
| **业务层** | 用户体验 | 访问量、转化率 | 同比下降>20% |

**⚡ 告警规则设置：**
```yaml
# Prometheus告警规则示例
groups:
  - name: system_alerts
    rules:
      - alert: HighCPUUsage
        expr: 100 - (avg by(instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m
        annotations:
          summary: "CPU使用率过高"
          description: "{{ $labels.instance }} CPU使用率已达到 {{ $value }}%"
```

---

## 7. 📜 故障排查脚本库建设


### 7.1 脚本库设计理念


**故障排查脚本库**就是把常用的排查命令组合成"一键检查"工具。

> **🎯 设计目标**
> 让新手也能像专家一样快速定位问题，将经验转化为可执行的工具

### 7.2 系统健康检查脚本


**🔧 基础系统检查脚本：**
```bash
#!/bin/bash
# system_health_check.sh - 系统健康检查工具

echo "=== 系统健康检查报告 ==="
echo "检查时间: $(date)"
echo "======================================="

# 1. 系统基本信息
echo "【系统信息】"
echo "操作系统: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
echo "内核版本: $(uname -r)"
echo "运行时间: $(uptime -p)"
echo ""

# 2. CPU使用率检查
echo "【CPU使用率】"
cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
echo "当前CPU使用率: ${cpu_usage}%"
if (( $(echo "$cpu_usage > 80" | bc -l) )); then
    echo "⚠️  警告: CPU使用率过高!"
fi
echo ""

# 3. 内存使用检查
echo "【内存使用情况】"
free -h
mem_usage=$(free | awk 'NR==2{printf "%.1f", $3/$2*100}')
echo "内存使用率: ${mem_usage}%"
echo ""

# 4. 磁盘空间检查
echo "【磁盘空间使用】"
df -h | grep -E "(Filesystem|/dev/)"
echo ""

# 5. 网络连接检查
echo "【网络连接状态】"
echo "当前TCP连接数: $(netstat -an | grep ESTABLISHED | wc -l)"
echo "监听端口: $(netstat -tlnp | grep LISTEN | awk '{print $4}' | cut -d':' -f2 | sort -n | uniq | tr '\n' ' ')"
echo ""

echo "======================================="
echo "检查完成!"
```

### 7.3 应用服务检查脚本


**⚡ 服务状态检查：**
```bash
#!/bin/bash
# service_check.sh - 服务状态检查工具

SERVICES=("nginx" "mysql" "redis" "php7.4-fpm")

echo "=== 服务状态检查 ==="
for service in "${SERVICES[@]}"; do
    if systemctl is-active --quiet $service; then
        status="✅ 运行中"
        port_info=$(ss -tlnp | grep $service | head -1 | awk '{print $4}')
    else
        status="❌ 已停止"
        port_info="无"
    fi
    
    echo "$service: $status (监听端口: $port_info)"
    
    # 检查服务日志中的错误
    error_count=$(journalctl -u $service --since "1 hour ago" -p err --no-pager -q | wc -l)
    if [ $error_count -gt 0 ]; then
        echo "  ⚠️  最近1小时有 $error_count 条错误日志"
    fi
done
```

### 7.4 网络诊断脚本


**🌐 网络连通性检查：**
```bash
#!/bin/bash
# network_check.sh - 网络诊断工具

HOSTS=("8.8.8.8" "baidu.com" "github.com")
PORTS=("80" "443" "22")

echo "=== 网络连通性检查 ==="

# DNS解析检查
echo "【DNS解析测试】"
for host in "${HOSTS[@]}"; do
    if nslookup $host >/dev/null 2>&1; then
        echo "$host: ✅ 解析正常"
    else
        echo "$host: ❌ 解析失败"
    fi
done
echo ""

# 网络连通性检查
echo "【网络连通性测试】"
for host in "${HOSTS[@]}"; do
    if ping -c 1 -W 2 $host >/dev/null 2>&1; then
        rtt=$(ping -c 1 $host | grep "time=" | awk '{print $7}')
        echo "$host: ✅ 连通 ($rtt)"
    else
        echo "$host: ❌ 无法连通"
    fi
done
echo ""

# 端口可用性检查
echo "【端口可用性检查】"
for port in "${PORTS[@]}"; do
    if ss -tln | grep -q ":$port "; then
        echo "端口 $port: ✅ 监听中"
    else
        echo "端口 $port: ❌ 未监听"
    fi
done
```

---

## 8. 🚑 应急工具包与标准化


### 8.1 应急工具包设计


**应急工具包**就是故障处理的"急救箱"，包含处理紧急故障所需的所有工具和文档。

```
应急工具包结构：
emergency-toolkit/
├── scripts/              ← 应急脚本
│   ├── quick-check.sh    ← 快速检查脚本
│   ├── service-restart.sh ← 服务重启脚本  
│   └── cleanup.sh        ← 清理脚本
├── configs/              ← 配置文件备份
│   ├── nginx.conf.backup
│   └── mysql.conf.backup
├── docs/                 ← 应急手册
│   ├── troubleshooting-guide.md
│   └── contact-list.md
└── tools/                ← 便携工具
    ├── htop-static
    └── tcpdump-static
```

### 8.2 标准化操作流程


**🔸 故障处理标准流程：**
1. **现象确认** → 收集用户反馈和监控告警
2. **影响评估** → 确定影响范围和严重程度
3. **快速诊断** → 使用工具包快速定位问题
4. **临时恢复** → 优先恢复服务可用性
5. **根因分析** → 深入分析根本原因
6. **永久修复** → 彻底解决问题
7. **复盘改进** → 总结经验，完善工具

### 8.3 工具使用标准化


**📋 标准化要素：**

| 要素 | **内容** | **目的** |
|------|----------|----------|
| **命名规范** | 统一的脚本和文件命名 | 便于查找和使用 |
| **参数标准** | 统一的命令行参数 | 降低学习成本 |
| **输出格式** | 统一的结果展示格式 | 便于理解和比较 |
| **日志规范** | 统一的日志记录方式 | 便于审计和分析 |

**⚡ 实施建议：**
```bash
# 创建工具别名，简化使用
echo "alias sys-check='~/emergency-toolkit/scripts/quick-check.sh'" >> ~/.bashrc
echo "alias net-check='~/emergency-toolkit/scripts/network-check.sh'" >> ~/.bashrc
echo "alias log-check='~/emergency-toolkit/scripts/log-analysis.sh'" >> ~/.bashrc

# 使用时只需要输入简短命令
sys-check    # 系统检查
net-check    # 网络检查  
log-check    # 日志分析
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心工具


```
🔸 系统诊断三宝：htop(进程) + iostat(磁盘) + netstat(网络)
🔸 网络诊断套装：tcpdump(抓包) + nmap(扫描) + curl(请求测试)  
🔸 性能分析利器：perf(性能剖析) + strace(系统调用) + lsof(文件占用)
🔸 日志分析组合：grep(搜索) + awk(处理) + journalctl(系统日志)
🔸 监控工具集成：Prometheus + Grafana + 各种Exporter
```

### 9.2 故障排查方法论


**🔹 排查思路流程：**
```
问题发现 → 现象收集 → 工具诊断 → 原因定位 → 解决方案 → 效果验证

具体方法：
1. 先看监控图表，了解整体状况
2. 用系统工具检查资源使用
3. 用网络工具检查连接状态
4. 用日志工具查找错误信息
5. 用性能工具深入分析瓶颈
```

**🔹 工具选择原则：**
```
紧急故障：优先使用轻量级工具(htop, netstat, grep)
深入分析：使用专业工具(perf, strace, tcpdump)
预防监控：使用监控平台(Prometheus, Grafana)
经验积累：构建脚本库和工具包
```

### 9.3 实践能力培养


**🚀 能力进阶路径：**
- **基础阶段**：熟练使用单个工具，了解各工具特点
- **进阶阶段**：组合使用多个工具，快速定位问题  
- **高级阶段**：构建自动化脚本，建设监控体系
- **专家阶段**：设计标准化流程，培训团队成员

**💡 持续改进要点：**
- **工具熟练度**：日常多练习，形成肌肉记忆
- **脚本积累**：将常用操作脚本化，提高效率
- **监控完善**：建立全面监控，实现主动发现
- **知识分享**：团队内知识分享，共同提高

**🎯 记忆口诀：**
- htop看进程，iostat查磁盘，netstat观网络
- tcpdump抓数据，nmap扫端口，curl测请求
- perf析性能，strace追调用，lsof查占用  
- grep找关键，awk做统计，journalctl看系统
- 监控要集成，脚本要标准，流程要规范