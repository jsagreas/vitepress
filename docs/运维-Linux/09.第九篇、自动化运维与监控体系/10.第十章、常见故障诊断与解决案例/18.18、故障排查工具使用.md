---
title: 18、故障排查工具使用
---
## 📚 目录


1. [系统监控工具组合使用](#1-系统监控工具组合使用)
2. [日志分析工具实战](#2-日志分析工具实战)
3. [网络诊断工具链](#3-网络诊断工具链)
4. [性能分析工具应用](#4-性能分析工具应用)
5. [文件系统检查工具](#5-文件系统检查工具)
6. [进程跟踪调试工具](#6-进程跟踪调试工具)
7. [内存分析工具使用](#7-内存分析工具使用)
8. [综合诊断脚本编写](#8-综合诊断脚本编写)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🖥️ 系统监控工具组合使用



### 1.1 系统监控的本质理解



> 💡 **核心概念**  
> 系统监控就像医生给病人体检，通过各种"检查工具"来了解系统的"健康状况"，及时发现问题并解决

**监控的四个维度**：
- **CPU利用率** ⚡：系统处理能力使用情况
- **内存占用** 💾：系统存储资源使用状况  
- **磁盘I/O** 💿：数据读写操作性能
- **网络流量** 🌐：网络通信质量和带宽使用

### 1.2 基础监控工具组合



#### 🔍 top命令 - 系统全景监控器



`top`就像系统的"实时仪表盘"，显示当前系统运行的所有重要信息：

```bash
# 基本使用

top

# 常用参数

top -u username    # 只显示指定用户的进程
top -p 1234       # 监控指定进程ID
top -d 5          # 每5秒刷新一次
```

**🎯 重点关注指标**：
- **load average**：系统负载，理想值 < CPU核心数
- **%CPU**：进程CPU占用率
- **%MEM**：进程内存占用率
- **TIME+**：进程运行总时间

#### 📊 htop命令 - 增强版系统监控



`htop`是`top`的升级版，界面更友好，功能更强大：

```bash
# 安装htop（如果没有）

yum install htop    # CentOS/RHEL
apt install htop    # Ubuntu/Debian

# 使用htop

htop
```

**✨ htop优势**：
- 🎨 彩色界面，信息一目了然
- 🖱️ 支持鼠标操作
- 🔢 显示所有CPU核心使用率
- ⌨️ 快捷键操作更便捷

#### ⚡ vmstat命令 - 虚拟内存统计



`vmstat`专门监控系统的内存、进程、CPU活动：

```bash
# 每2秒显示一次，总共显示10次

vmstat 2 10

# 显示磁盘统计信息

vmstat -d

# 显示内存统计信息

vmstat -s
```

**📋 输出解读**：
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0  1234M   89M   456M    0    0    10    20  150  300 15  5 78  2  0
```

- **r**：运行队列中的进程数
- **b**：等待I/O的进程数  
- **free**：空闲内存
- **us/sy/id/wa**：用户/系统/空闲/等待I/O的CPU时间占比

### 1.3 专业监控工具组合



#### 📈 sar命令 - 系统活动报告器



`sar`是Linux系统性能分析的"瑞士军刀"：

```bash
# CPU使用率统计（每5秒一次，共6次）

sar -u 5 6

# 内存使用统计

sar -r 5 6

# 磁盘I/O统计

sar -d 5 6

# 网络统计

sar -n DEV 5 6
```

#### 🔧 iostat命令 - I/O统计专家



专门监控磁盘I/O性能：

```bash
# 基本I/O统计

iostat

# 详细统计，每3秒更新

iostat -x 3

# 只显示指定设备

iostat -x sda 2
```

**🎯 关键指标解读**：
- **%util**：设备使用率，>80%需要关注
- **await**：平均等待时间，单位毫秒
- **svctm**：平均服务时间

### 1.4 监控工具组合使用策略



**🔄 三步诊断法**：

```
步骤1：快速概览
top/htop → 查看系统整体状况

步骤2：专项分析  
vmstat → 内存和CPU详细分析
iostat → 磁盘I/O性能分析
sar → 历史数据趋势分析

步骤3：定向深入
针对发现的问题使用专门工具
```

---

## 2. 📋 日志分析工具实战



### 2.1 Linux日志系统概述



> 💡 **生活类比**  
> 日志就像系统的"日记本"，记录了系统运行的每个重要时刻。分析日志就像侦探破案，通过线索找到问题的根源

**🗂️ 主要日志位置**：
```
/var/log/messages    ← 系统主要日志
/var/log/secure      ← 安全相关日志
/var/log/cron        ← 定时任务日志
/var/log/boot.log    ← 启动日志
/var/log/dmesg       ← 内核日志
```

### 2.2 基础日志查看工具



#### 📖 tail命令 - 日志实时监控器



`tail`是监控日志最常用的工具，就像"显微镜"实时观察日志变化：

```bash
# 显示文件最后10行

tail /var/log/messages

# 实时监控日志（最重要）

tail -f /var/log/messages

# 显示最后50行并实时监控

tail -n 50 -f /var/log/secure

# 同时监控多个日志文件

tail -f /var/log/messages /var/log/secure
```

**💡 实用技巧**：
- `Ctrl+C`停止监控
- `-F`参数可以处理日志轮转的情况

#### 🔍 grep命令 - 日志内容过滤器



`grep`就像"搜索引擎"，在海量日志中快速找到关键信息：

```bash
# 搜索包含"error"的行

grep "error" /var/log/messages

# 忽略大小写搜索

grep -i "error" /var/log/messages

# 显示匹配行的前后3行

grep -A3 -B3 "failed" /var/log/secure

# 递归搜索整个目录

grep -r "ssh" /var/log/

# 统计匹配行数

grep -c "error" /var/log/messages
```

#### 📊 awk命令 - 日志数据处理器



`awk`是处理结构化日志数据的专家：

```bash
# 提取日志中的IP地址（第4列）

awk '{print $4}' /var/log/secure

# 统计不同IP的访问次数

awk '{print $11}' /var/log/httpd/access_log | sort | uniq -c | sort -nr

# 提取特定时间段的日志

awk '/Dec 25/ {print}' /var/log/messages

# 计算某列的平均值

awk '{sum+=$7} END {print sum/NR}' data.log
```

### 2.3 专业日志分析工具



#### 🔎 journalctl命令 - systemd日志管理器



现代Linux系统使用`systemd`管理服务，`journalctl`是查看systemd日志的专门工具：

```bash
# 查看所有日志

journalctl

# 查看指定服务的日志

journalctl -u ssh.service

# 实时监控日志

journalctl -f

# 查看最近1小时的日志

journalctl --since "1 hour ago"

# 查看特定时间段的日志

journalctl --since "2023-12-01" --until "2023-12-02"

# 查看指定优先级的日志

journalctl -p err    # 只显示错误级别日志
```

**🎯 常用参数组合**：
```bash
# 查看启动相关的错误

journalctl -b -p err

# 查看某个进程的详细日志

journalctl _PID=1234

# 按时间倒序查看日志

journalctl -r
```

### 2.4 日志分析实战案例



#### 🚨 登录失败分析



```bash
# 查找SSH登录失败记录

grep "Failed password" /var/log/secure

# 统计失败最多的IP

grep "Failed password" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr

# 分析特定IP的攻击模式

grep "192.168.1.100" /var/log/secure | grep "Failed"
```

#### 📈 系统负载分析



```bash
# 查找系统负载过高的时间点

grep "load average" /var/log/messages

# 结合多个工具分析

grep -E "(error|warning|critical)" /var/log/messages | tail -20
```

---

## 3. 🌐 网络诊断工具链



### 3.1 网络诊断基础概念



> 💡 **网络类比**  
> 网络就像快递系统，数据包像快递包裹。网络诊断就是追踪包裹在运输过程中哪里出了问题

**🔄 网络诊断层次**：
```
应用层 ← 能否访问服务？
传输层 ← 端口是否开放？  
网络层 ← 路由是否通畅？
物理层 ← 网络设备是否正常？
```

### 3.2 基础连通性测试工具



#### 🏓 ping命令 - 网络连通性测试



`ping`就像发送"问候消息"，测试网络是否畅通：

```bash
# 基本ping测试

ping google.com

# 指定ping次数

ping -c 4 192.168.1.1

# 设置ping间隔（每0.1秒一次）

ping -i 0.1 baidu.com

# 设置数据包大小

ping -s 1000 192.168.1.1

# 记录路由（显示经过的路由器）

ping -R google.com
```

**📊 结果解读**：
```
PING google.com (172.217.16.14): 56 data bytes
64 bytes from 172.217.16.14: icmp_seq=1 ttl=117 time=15.2 ms
```
- **time**：往返延迟，<50ms为好，>200ms较慢
- **ttl**：生存时间，可判断经过的路由器数量
- **丢包率**：0%最理想

#### 🗺️ traceroute命令 - 网络路径追踪



`traceroute`显示数据包到达目标的完整路径：

```bash
# 基本路由追踪

traceroute google.com

# 使用TCP而不是ICMP

traceroute -T -p 80 google.com

# 不解析主机名（更快）

traceroute -n 8.8.8.8
```

**🔍 结果分析技巧**：
- 出现`* * *`表示某个路由器不响应
- 延迟突然增大的节点可能是瓶颈
- 路径中断点帮助定位网络故障

### 3.3 端口和服务检测工具



#### 🔌 telnet命令 - 端口连通性测试



`telnet`可以测试指定端口是否开放：

```bash
# 测试Web服务端口

telnet www.baidu.com 80

# 测试SSH端口

telnet 192.168.1.100 22

# 测试SMTP端口

telnet mail.qq.com 25
```

**✅ 连接成功**：显示"Connected to..."
**❌ 连接失败**：显示"Connection refused"或"Connection timed out"

#### 🔍 nmap命令 - 网络扫描神器



`nmap`是网络扫描和安全审计的专业工具：

```bash
# 扫描主机开放端口

nmap 192.168.1.100

# 扫描指定端口范围

nmap -p 1-1000 192.168.1.100

# 快速扫描（常用端口）

nmap -F 192.168.1.100

# 扫描整个网段

nmap 192.168.1.1/24

# 服务版本检测

nmap -sV 192.168.1.100

# TCP SYN扫描（隐蔽扫描）

nmap -sS 192.168.1.100
```

### 3.4 网络流量监控工具



#### 📊 netstat命令 - 网络连接状态查看



`netstat`显示网络连接、路由表、接口统计等信息：

```bash
# 显示所有网络连接

netstat -a

# 只显示监听端口

netstat -l

# 显示进程信息

netstat -p

# 显示数字地址（不解析域名）

netstat -n

# 组合使用（最常用）

netstat -tlnp    # 显示TCP监听端口及进程
netstat -ulnp    # 显示UDP监听端口及进程

# 显示路由表

netstat -r

# 显示网络接口统计

netstat -i
```

#### 🚀 ss命令 - 现代网络连接查看工具



`ss`是`netstat`的现代替代品，速度更快：

```bash
# 显示所有TCP连接

ss -t

# 显示监听端口

ss -l

# 显示进程信息

ss -p

# 组合使用

ss -tlnp

# 按状态过滤连接

ss -t state established
ss -t state listening

# 按端口过滤

ss -tlnp sport :80
ss -tlnp dport :3306
```

---

## 4. ⚡ 性能分析工具应用



### 4.1 性能分析基础概念



> 💡 **性能优化类比**  
> 系统性能就像交通系统，CPU是处理器，内存是临时停车场，磁盘是仓库，网络是道路。性能分析就是找出交通堵塞的原因

**🎯 性能分析四大维度**：
- **CPU性能**：处理能力是否充足
- **内存性能**：存储空间是否够用
- **磁盘性能**：数据读写是否快速
- **网络性能**：数据传输是否顺畅

### 4.2 CPU性能分析工具



#### 🔥 perf命令 - 系统性能分析利器



`perf`是Linux内核提供的性能分析工具：

```bash
# 系统整体性能统计

perf stat -a sleep 10

# 性能采样分析

perf record -a sleep 10
perf report

# 实时性能监控

perf top

# 针对特定进程分析

perf stat -p 1234 sleep 10

# CPU缓存分析

perf stat -e cache-misses,cache-references ./program
```

**📊 常见性能指标**：
- **IPC（Instructions Per Cycle）**：每个时钟周期执行的指令数
- **Cache Miss率**：缓存未命中率
- **Branch Misprediction**：分支预测错误率

#### 🌡️ mpstat命令 - 多处理器统计



`mpstat`提供详细的CPU使用情况分析：

```bash
# 显示所有CPU的使用情况

mpstat

# 每2秒显示一次，共5次

mpstat 2 5

# 显示平均值

mpstat -A

# 按处理器分别显示

mpstat -P ALL 2
```

### 4.3 内存性能分析工具



#### 💾 free命令 - 内存使用状况



`free`显示系统内存使用情况：

```bash
# 基本内存信息

free

# 以人类可读格式显示

free -h

# 每3秒刷新一次

free -h -s 3

# 显示详细信息

free -m -t
```

**🔍 内存指标解读**：
```bash
              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       324Mi       4.5Gi       5.1Gi
```
- **available**：实际可用内存（重要指标）
- **buff/cache**：缓存，可释放给应用程序使用
- **used**：真正被程序占用的内存

#### 📈 pmap命令 - 进程内存映射



`pmap`显示进程的内存映射详情：

```bash
# 显示进程内存映射

pmap 1234

# 显示详细信息

pmap -d 1234

# 显示扩展信息

pmap -x 1234
```

### 4.4 磁盘性能分析工具



#### 💿 iotop命令 - I/O监控专家



`iotop`实时显示进程的磁盘I/O使用情况：

```bash
# 安装iotop

yum install iotop

# 实时监控I/O

iotop

# 只显示有I/O活动的进程

iotop -o

# 累积I/O模式

iotop -a
```

**🎯 关键指标**：
- **TOTAL READ/WRITE**：总读写速度
- **CURRENT READ/WRITE**：当前读写速度
- **%**：I/O等待时间百分比

#### 📊 dstat命令 - 系统资源统计



`dstat`提供全面的系统资源监控：

```bash
# 基本系统统计

dstat

# 详细的磁盘统计

dstat -d

# 网络统计

dstat -n

# 综合监控（CPU、内存、网络、磁盘）

dstat -cdngy

# 每5秒更新，总共20次

dstat 5 20
```

---

## 5. 💿 文件系统检查工具



### 5.1 文件系统健康检查概念



> 💡 **文件系统类比**  
> 文件系统就像图书馆的管理系统，需要定期检查书籍是否放在正确位置，目录是否完整，有没有损坏的书籍

**🔍 检查的三个方面**：
- **结构完整性**：文件系统结构是否正确
- **数据一致性**：文件数据是否损坏
- **空间利用**：磁盘空间使用情况

### 5.2 基础文件系统检查工具



#### 🔧 fsck命令 - 文件系统检查修复工具



`fsck`是文件系统检查和修复的核心工具：

```bash
# 检查文件系统（只读检查）

fsck /dev/sda1

# 自动修复发现的错误

fsck -y /dev/sda1

# 强制检查（即使文件系统看起来正常）

fsck -f /dev/sda1

# 详细输出检查过程

fsck -v /dev/sda1

# 检查但不修复（测试模式）

fsck -n /dev/sda1
```

**⚠️ 重要提醒**：
- 检查前必须卸载文件系统
- 对根文件系统检查需要从rescue模式启动
- 建议在检查前备份重要数据

#### 📏 df命令 - 磁盘空间使用情况



`df`显示文件系统磁盘空间使用情况：

```bash
# 显示所有文件系统

df

# 人类可读格式

df -h

# 显示文件系统类型

df -T

# 显示inode使用情况

df -i

# 只显示指定类型的文件系统

df -t ext4
```

**📊 结果解读**：
```bash
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        20G  15G  4.2G  79% /
```
- **Use%超过80%**：需要清理磁盘空间
- **Use%超过95%**：系统可能出现问题

#### 🔍 du命令 - 目录空间使用分析



`du`分析目录和文件的磁盘使用情况：

```bash
# 显示当前目录大小

du -h

# 只显示目录总大小

du -sh

# 显示指定目录下各子目录大小

du -h --max-depth=1 /var/log

# 按大小排序

du -h | sort -hr

# 查找大文件

du -h | grep "G\|[0-9][0-9][0-9]M"
```

### 5.3 高级文件系统诊断工具



#### 🔬 tune2fs命令 - ext文件系统调优



`tune2fs`用于调整ext2/ext3/ext4文件系统参数：

```bash
# 显示文件系统详细信息

tune2fs -l /dev/sda1

# 设置最大挂载次数

tune2fs -c 30 /dev/sda1

# 设置检查间隔时间

tune2fs -i 180d /dev/sda1

# 添加日志（ext2升级到ext3）

tune2fs -j /dev/sda1

# 设置卷标

tune2fs -L "MyDisk" /dev/sda1
```

#### 🔎 lsof命令 - 列出打开的文件



`lsof`显示系统中被进程打开的文件：

```bash
# 显示所有打开的文件

lsof

# 显示特定进程打开的文件

lsof -p 1234

# 显示特定文件被哪些进程打开

lsof /var/log/messages

# 显示特定目录下被打开的文件

lsof +D /var/log

# 显示网络连接

lsof -i

# 显示特定端口的进程

lsof -i :80

# 显示特定用户打开的文件

lsof -u username
```

**💡 实用场景**：
- 删除文件提示"设备忙"时查找占用进程
- 查看日志文件被哪些程序在写入
- 网络端口被哪个程序占用

---

## 6. 🔍 进程跟踪调试工具



### 6.1 进程调试基础概念



> 💡 **进程调试类比**  
> 进程调试就像跟踪一个人的行为轨迹，观察他在什么时候做了什么事情，与谁进行了交流，帮助理解程序的运行逻辑

**🎯 调试的三个层次**：
- **系统调用层**：程序与操作系统的交互
- **函数调用层**：程序内部函数执行流程
- **资源使用层**：程序对系统资源的使用

### 6.2 系统调用跟踪工具



#### 🔬 strace命令 - 系统调用跟踪器



`strace`是跟踪程序系统调用的强大工具：

```bash
# 跟踪程序的所有系统调用

strace ls

# 跟踪运行中的进程

strace -p 1234

# 跟踪特定类型的系统调用

strace -e trace=file ls        # 只跟踪文件操作
strace -e trace=network nc     # 只跟踪网络操作
strace -e trace=memory malloc  # 只跟踪内存操作

# 统计系统调用

strace -c ls

# 跟踪子进程

strace -f ./parent_process

# 输出到文件

strace -o trace.log ls

# 显示时间戳

strace -t ls
```

**📊 输出解读示例**：
```bash
openat(AT_FDCWD, "/etc/passwd", O_RDONLY) = 3
read(3, "root:x:0:0:root:/root:/bin/bash\n", 4096) = 1024
close(3) = 0
```
- `openat`：系统调用名称
- `AT_FDCWD, "/etc/passwd", O_RDONLY`：参数
- `= 3`：返回值（文件描述符）

#### 🔧 ltrace命令 - 库函数调用跟踪



`ltrace`跟踪程序的库函数调用：

```bash
# 跟踪库函数调用

ltrace ls

# 跟踪运行中的进程

ltrace -p 1234

# 跟踪特定库函数

ltrace -e printf ./program

# 统计函数调用次数

ltrace -c ./program

# 显示系统调用和库函数调用

ltrace -S ./program
```

### 6.3 进程状态监控工具



#### 📋 ps命令 - 进程状态快照



`ps`显示系统中进程的状态信息：

```bash
# 显示所有进程

ps aux

# 显示进程树

ps auxf

# 按CPU使用率排序

ps aux --sort=-%cpu

# 按内存使用率排序

ps aux --sort=-%mem

# 显示特定用户的进程

ps -u username

# 显示进程详细信息

ps -eo pid,ppid,cmd,pcpu,pmem

# 实时监控进程

watch -n 1 'ps aux --sort=-%cpu | head -10'
```

**🔍 状态码解读**：
- **R**：运行中（Running）
- **S**：睡眠中（Sleeping）
- **D**：不可中断睡眠（等待I/O）
- **Z**：僵尸进程（Zombie）
- **T**：停止（Stopped）

#### ⚡ pstree命令 - 进程关系树



`pstree`以树形结构显示进程间的父子关系：

```bash
# 显示所有进程树

pstree

# 显示进程ID

pstree -p

# 显示特定进程的子树

pstree -p 1234

# 显示进程参数

pstree -a

# 按用户分组显示

pstree username
```

### 6.4 动态调试工具



#### 🔍 gdb命令 - 程序调试器



`gdb`是调试程序的专业工具：

```bash
# 调试程序

gdb ./program

# 附加到运行中的进程

gdb -p 1234

# 批量执行gdb命令

gdb -batch -ex "thread apply all bt" -p 1234
```

**📋 gdb常用命令**：
```bash
(gdb) run                 # 运行程序
(gdb) break main          # 在main函数设置断点
(gdb) continue           # 继续执行
(gdb) step               # 单步执行
(gdb) print variable     # 打印变量值
(gdb) backtrace          # 显示调用栈
(gdb) info threads       # 显示线程信息
(gdb) quit               # 退出gdb
```

---

## 7. 🧠 内存分析工具使用



### 7.1 内存问题诊断基础



> 💡 **内存管理类比**  
> 内存就像办公桌面，程序运行需要在桌面上摆放文件。内存分析就是检查桌面使用情况：哪些文件占用空间大，是否有遗忘清理的文件

**🎯 常见内存问题**：
- **内存泄漏**：程序申请内存后忘记释放
- **内存溢出**：程序需要的内存超过可用内存
- **内存碎片**：内存被分割成小块，无法分配大块内存

### 7.2 内存使用监控工具



#### 💾 valgrind命令 - 内存调试神器



`valgrind`是检测内存错误的专业工具：

```bash
# 基本内存检查

valgrind ./program

# 详细内存泄漏检查

valgrind --leak-check=full ./program

# 显示可能的内存泄漏

valgrind --leak-check=yes --show-possibly-lost=yes ./program

# 生成详细报告

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./program

# 检查缓冲区溢出

valgrind --tool=exp-sgcheck ./program
```

**📊 输出解读**：
```bash
==1234== HEAP SUMMARY:
==1234==     in use at exit: 1,024 bytes in 1 blocks
==1234==   total heap usage: 100 allocs, 99 frees, 10,240 bytes allocated
==1234== 
==1234== LEAK SUMMARY:
==1234==    definitely lost: 1,024 bytes in 1 blocks
```

#### 📈 smem命令 - 内存使用统计



`smem`提供详细的进程内存使用报告：

```bash
# 安装smem

yum install smem

# 显示所有进程内存使用

smem

# 按进程分组显示

smem -t

# 显示系统总内存使用

smem -w

# 按用户分组

smem -u

# 生成图形化报告

smem --pie=name -s pss
```

**🔍 内存指标说明**：
- **USS**：进程独占内存
- **PSS**：进程按比例分摊的内存
- **RSS**：进程实际使用的物理内存

### 7.3 内存泄漏检测工具



#### 🔍 memleak工具 - 实时内存泄漏检测



`memleak`是基于eBPF的内存泄漏检测工具：

```bash
# 检测进程的内存泄漏

memleak -p 1234

# 设置检测间隔和持续时间

memleak -p 1234 -a -O 10 60

# 显示调用栈

memleak -p 1234 -s

# 按大小过滤泄漏

memleak -p 1234 --min-size=1024
```

#### 📊 /proc文件系统内存分析



直接读取`/proc`文件系统获取内存信息：

```bash
# 查看系统内存信息

cat /proc/meminfo

# 查看进程内存映射

cat /proc/1234/maps

# 查看进程内存状态

cat /proc/1234/status

# 查看进程内存统计

cat /proc/1234/smaps

# 监控内存变化

watch -n 1 'cat /proc/meminfo | grep -E "MemFree|MemAvailable|Cached"'
```

---

## 8. 📝 综合诊断脚本编写



### 8.1 自动化诊断脚本设计思路



> 💡 **脚本设计理念**  
> 诊断脚本就像医生的标准检查流程，按照固定步骤检查各个"器官"，快速发现问题并给出建议

**🎯 脚本设计原则**：
- **模块化**：每个功能独立成函数
- **可配置**：支持参数调整检查级别
- **易读性**：输出结果清晰易懂
- **可扩展**：便于添加新的检查项目

### 8.2 系统健康检查脚本



```bash
#!/bin/bash

# 系统健康检查脚本


# 定义颜色输出

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 输出函数

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# CPU检查函数

check_cpu() {
    log_info "检查CPU使用情况..."
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d% -f1)
    if (( $(echo "$cpu_usage > 80" | bc -l) )); then
        log_error "CPU使用率过高: ${cpu_usage}%"
    elif (( $(echo "$cpu_usage > 60" | bc -l) )); then
        log_warn "CPU使用率较高: ${cpu_usage}%"
    else
        log_info "CPU使用率正常: ${cpu_usage}%"
    fi
}

# 内存检查函数

check_memory() {
    log_info "检查内存使用情况..."
    local mem_info=$(free | grep Mem)
    local total=$(echo $mem_info | awk '{print $2}')
    local used=$(echo $mem_info | awk '{print $3}')
    local usage=$(echo "scale=2; $used/$total*100" | bc)
    
    if (( $(echo "$usage > 90" | bc -l) )); then
        log_error "内存使用率过高: ${usage}%"
    elif (( $(echo "$usage > 70" | bc -l) )); then
        log_warn "内存使用率较高: ${usage}%"
    else
        log_info "内存使用率正常: ${usage}%"
    fi
}

# 磁盘检查函数

check_disk() {
    log_info "检查磁盘使用情况..."
    df -h | grep -E '^/dev/' | while read line; do
        usage=$(echo $line | awk '{print $5}' | sed 's/%//')
        mount=$(echo $line | awk '{print $6}')
        if [ $usage -gt 90 ]; then
            log_error "磁盘使用率过高: $mount ${usage}%"
        elif [ $usage -gt 70 ]; then
            log_warn "磁盘使用率较高: $mount ${usage}%"
        fi
    done
}

# 主函数

main() {
    echo "========== 系统健康检查报告 =========="
    echo "检查时间: $(date)"
    echo "主机名: $(hostname)"
    echo "======================================"
    
    check_cpu
    check_memory
    check_disk
    
    echo "======================================"
    echo "检查完成"
}

# 执行主函数

main "$@"
```

### 8.3 网络诊断脚本



```bash
#!/bin/bash

# 网络连通性诊断脚本


# 目标列表

TARGETS=("8.8.8.8" "114.114.114.114" "baidu.com" "google.com")
PORTS=("22" "80" "443" "53")

# 网络连通性检查

check_connectivity() {
    log_info "检查网络连通性..."
    for target in "${TARGETS[@]}"; do
        if ping -c 3 -W 3 "$target" >/dev/null 2>&1; then
            log_info "$target 连通正常"
        else
            log_error "$target 连通失败"
        fi
    done
}

# 端口检查

check_ports() {
    log_info "检查常用端口..."
    local host=$1
    for port in "${PORTS[@]}"; do
        if timeout 5 bash -c "</dev/tcp/$host/$port" 2>/dev/null; then
            log_info "$host:$port 端口开放"
        else
            log_warn "$host:$port 端口关闭或不可达"
        fi
    done
}

# DNS解析检查

check_dns() {
    log_info "检查DNS解析..."
    local domains=("baidu.com" "google.com" "github.com")
    for domain in "${domains[@]}"; do
        if nslookup "$domain" >/dev/null 2>&1; then
            log_info "$domain DNS解析正常"
        else
            log_error "$domain DNS解析失败"
        fi
    done
}
```

### 8.4 性能监控脚本



```bash
#!/bin/bash

# 系统性能监控脚本


# 创建监控报告

REPORT_DIR="/tmp/performance_report_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$REPORT_DIR"

# 收集系统信息

collect_system_info() {
    log_info "收集系统基本信息..."
    {
        echo "=== 系统信息 ==="
        uname -a
        echo ""
        echo "=== CPU信息 ==="
        lscpu
        echo ""
        echo "=== 内存信息 ==="
        free -h
        echo ""
        echo "=== 磁盘信息 ==="
        df -h
    } > "$REPORT_DIR/system_info.txt"
}

# 收集性能数据

collect_performance_data() {
    log_info "收集性能数据..."
    
#    # CPU性能
    vmstat 1 10 > "$REPORT_DIR/vmstat.txt" &
    
#    # I/O性能
    iostat -x 1 10 > "$REPORT_DIR/iostat.txt" &
    
#    # 网络统计
    ss -s > "$REPORT_DIR/network_stats.txt"
    
#    # 进程信息
    ps aux --sort=-%cpu | head -20 > "$REPORT_DIR/top_cpu_processes.txt"
    ps aux --sort=-%mem | head -20 > "$REPORT_DIR/top_mem_processes.txt"
    
#    # 等待后台任务完成
    wait
}

# 生成报告

generate_report() {
    log_info "生成性能报告..."
    cat > "$REPORT_DIR/README.md" << EOF
# 系统性能报告


生成时间: $(date)
主机名: $(hostname)

# 文件说明



- \`system_info.txt\`: 系统基本信息
- \`vmstat.txt\`: CPU和内存性能数据
- \`iostat.txt\`: 磁盘I/O性能数据
- \`network_stats.txt\`: 网络连接统计
- \`top_cpu_processes.txt\`: CPU使用率最高的进程
- \`top_mem_processes.txt\`: 内存使用率最高的进程

EOF
    
    log_info "报告已生成到: $REPORT_DIR"
}
```

---

## 9. 📋 核心要点总结



### 9.1 故障诊断工具分类总结



**🎯 按功能分类**：

| 工具类别 | 核心工具 | 主要用途 | 使用场景 |
|---------|---------|---------|----------|
| **系统监控** | `top`, `htop`, `vmstat` | 实时系统状态 | 日常监控，快速定位 |
| **日志分析** | `tail`, `grep`, `journalctl` | 历史问题追踪 | 故障回溯，模式分析 |
| **网络诊断** | `ping`, `traceroute`, `netstat` | 网络连通性 | 网络故障排查 |
| **性能分析** | `perf`, `iotop`, `dstat` | 性能瓶颈识别 | 性能优化，容量规划 |
| **文件系统** | `fsck`, `lsof`, `du` | 存储问题检查 | 磁盘故障，空间管理 |
| **进程调试** | `strace`, `gdb`, `pstree` | 程序行为分析 | 应用程序调试 |
| **内存分析** | `valgrind`, `smem` | 内存问题诊断 | 内存泄漏检测 |

### 9.2 诊断思路与方法论



**🔄 故障诊断标准流程**：

```
第1步：问题现象确认
├─ 用户反馈什么问题？
├─ 问题何时开始出现？
└─ 影响范围有多大？

第2步：系统整体检查  
├─ top/htop → 系统负载概览
├─ free -h → 内存使用情况
└─ df -h → 磁盘空间检查

第3步：专项深入分析
├─ CPU问题 → vmstat, perf, mpstat
├─ 内存问题 → smem, valgrind, /proc/meminfo  
├─ 磁盘问题 → iostat, iotop, fsck
├─ 网络问题 → ping, traceroute, ss
└─ 进程问题 → ps, strace, lsof

第4步：日志证据收集
├─ journalctl → systemd服务日志
├─ /var/log/messages → 系统日志
└─ 应用程序专用日志

第5步：问题定位与解决
├─ 根据证据分析根本原因
├─ 制定解决方案
└─ 实施并验证效果
```

### 9.3 工具使用最佳实践



**💡 高效诊断技巧**：

🔹 **组合使用原则**
```bash
# 系统性能一览

top && free -h && df -h

# 网络问题排查链

ping target → traceroute target → telnet target port

# 进程问题调查链  

ps aux | grep process → lsof -p pid → strace -p pid
```

🔹 **监控脚本化**
- 将常用诊断命令组合成脚本
- 定期收集系统性能基线数据
- 建立告警阈值和自动化响应

🔹 **数据保存习惯**
- 重要诊断结果及时保存到文件
- 建立故障处理日志和知识库
- 定期备份重要配置和日志

### 9.4 学习进阶建议



**📚 深入学习路径**：

🟢 **基础阶段**（必须掌握）
- 熟练使用 `top`, `ps`, `netstat`, `df`, `free`
- 掌握 `tail`, `grep` 进行日志分析
- 学会 `ping`, `traceroute` 网络诊断

🟡 **进阶阶段**（提升技能）
- 学习 `strace`, `lsof` 进行深度调试
- 掌握 `perf`, `iotop` 性能分析
- 编写自动化诊断脚本

🔴 **专家阶段**（精通技能）
- 深入理解系统内核机制
- 熟练使用 `valgrind`, `gdb` 等专业工具
- 构建完整的监控和自动化运维体系

**🎯 实践建议**：
1. **日常积累**：在正常系统上熟悉各工具的输出结果
2. **模拟练习**：人为制造问题进行诊断练习
3. **案例总结**：记录每次故障处理的经验和教训
4. **工具深入**：选择几个核心工具深入学习所有参数和用法

**🧠 记忆口诀**：
```
系统问题先概览，top查看系统忙
内存磁盘紧跟上，free和df来帮忙
网络不通ping开路，trace路由查方向
进程异常ps追踪，strace系统调用详
日志分析tail开头，grep过滤找重点
性能分析有工具，iotop和vmstat强
```