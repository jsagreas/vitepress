---
title: 5、CPU性能问题排查
---
## 📚 目录

1. [CPU占用率100%问题定位](#1-CPU占用率100问题定位)
2. [负载过高原因分析](#2-负载过高原因分析)  
3. [僵尸进程批量清理](#3-僵尸进程批量清理)
4. [CPU频率异常处理](#4-CPU频率异常处理)
5. [进程调度问题排查](#5-进程调度问题排查)
6. [中断处理异常诊断](#6-中断处理异常诊断)
7. [多核负载不均衡](#7-多核负载不均衡)
8. [CPU温度过高处理](#8-CPU温度过高处理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔥 CPU占用率100%问题定位


### 1.1 什么是CPU占用率100%

**💡 通俗理解**：CPU占用率100%就像一个人忙得团团转，没有一丝空闲时间。系统把所有CPU时间都分配给了正在运行的程序，导致响应变慢甚至卡死。

**🎯 核心概念解释**：
- **CPU使用率**：CPU实际工作时间占总时间的百分比
- **用户态CPU**：运行应用程序消耗的CPU时间
- **系统态CPU**：运行系统内核消耗的CPU时间
- **空闲CPU**：CPU没有工作的时间

### 1.2 快速定位CPU使用率异常


**🔧 基本排查流程**
```
第一步：查看整体CPU使用情况
第二步：找出占用CPU最高的进程
第三步：分析进程详细信息
第四步：确定是否为正常行为
第五步：采取相应解决措施
```

**📊 主要诊断命令对比**

| 命令 | 功能说明 | 适用场景 | 优缺点 |
|------|----------|----------|---------|
| `top` | 实时显示进程CPU使用率 | 快速查看系统状况 | ✅实时更新 ❌信息较少 |
| `htop` | 增强版top，界面友好 | 详细进程分析 | ✅界面直观 ❌需要安装 |
| `ps aux` | 静态进程信息快照 | 脚本化分析 | ✅信息全面 ❌非实时 |
| `pidstat` | 进程统计信息 | 性能分析 | ✅详细统计 ❌学习成本高 |

### 1.3 详细排查步骤


**🔍 步骤一：查看CPU整体使用情况**
```bash
# 查看实时CPU使用率
top -bn1 | head -3

# 输出示例：
# %Cpu(s): 95.2 us, 3.8 sy, 0.0 ni, 1.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
```

**📝 CPU指标含义解释**：
- `us (user)`: **用户态CPU使用率** - 运行用户程序的时间
- `sy (system)`: **系统态CPU使用率** - 运行内核的时间  
- `id (idle)`: **空闲CPU使用率** - CPU空闲时间
- `wa (wait)`: **IO等待CPU使用率** - 等待磁盘IO的时间
- `hi (hardware irq)`: **硬件中断CPU使用率**
- `si (software irq)`: **软件中断CPU使用率**

**🔍 步骤二：找出CPU使用率最高的进程**
```bash
# 按CPU使用率排序显示进程
ps aux --sort=-%cpu | head -10

# 或使用top交互式查看
top -o %CPU
```

**🔍 步骤三：分析具体进程详情**
```bash
# 查看进程详细信息
ps -p <PID> -o pid,ppid,cmd,pcpu,pmem,time

# 查看进程打开的文件
lsof -p <PID>

# 查看进程线程信息
ps -mp <PID> -o THREAD,tid,time,%cpu
```

### 1.4 常见CPU100%场景及解决方案


**🔴 场景1：死循环程序**
- **现象**：某个进程CPU使用率持续100%
- **原因**：程序出现死循环，无限占用CPU
- **解决**：`kill -9 <PID>` 强制终止进程

**🔴 场景2：系统服务异常**
- **现象**：系统服务进程CPU使用率异常
- **原因**：服务配置错误或资源不足
- **解决**：重启服务 `systemctl restart <service>`

**🔴 场景3：恶意挖矿程序**
- **现象**：不明进程CPU使用率100%
- **原因**：系统被植入挖矿木马
- **解决**：查杀木马，加强系统安全

**⚠️ 重要提醒**：在终止进程前，要确认该进程不是关键系统服务，避免造成系统故障。

---

## 2. ⚖️ 负载过高原因分析


### 2.1 什么是系统负载

**💡 通俗理解**：系统负载就像银行排队的人数。数字越高，说明等待处理的任务越多，系统越繁忙。

**🎯 负载指标详解**：
- **1分钟负载**：最近1分钟的平均负载
- **5分钟负载**：最近5分钟的平均负载  
- **15分钟负载**：最近15分钟的平均负载

**📊 负载评估标准**
```
单核CPU系统：
负载 < 1.0  ✅ 正常，系统运行流畅
负载 = 1.0  🟡 满负荷，但仍可接受
负载 > 1.0  🔴 超负荷，开始出现等待

四核CPU系统：
负载 < 4.0  ✅ 正常
负载 = 4.0  🟡 满负荷
负载 > 4.0  🔴 超负荷
```

### 2.2 负载过高的类型分析


**🔧 CPU密集型高负载**
```
特征：CPU使用率高，负载高，IO等待低
原因：计算密集型任务过多
表现：%us 很高，%wa 很低
```

**💾 IO密集型高负载**  
```
特征：CPU使用率不高，但负载很高，IO等待高
原因：磁盘/网络IO成为瓶颈
表现：%us 不高，%wa 很高
```

**🧵 进程过多高负载**
```
特征：进程/线程数量过多
原因：应用创建过多进程/线程
表现：大量处于运行/等待状态的进程
```

### 2.3 负载分析工具使用


**📈 基础监控命令**
```bash
# 查看当前负载
uptime
# 输出：14:30:15 up 2 days, 3:25, 2 users, load average: 2.50, 2.10, 1.95

# 实时监控负载变化  
watch -n 1 'uptime'
```

**🔍 详细分析工具**
```bash
# 查看每个CPU核心使用情况
mpstat -P ALL 1 5

# 查看IO等待详情
iostat -x 1 5

# 查看进程状态统计
vmstat 1 5
```

**📊 vmstat输出解释**
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  2      0 1234567   8901 234567    0    0    12    45   67   89 25  5 65  5  0
```

**🔤 字段含义说明**：
- `r`: **运行队列长度** - 正在运行和等待CPU的进程数
- `b`: **阻塞队列长度** - 等待IO完成的进程数
- `wa`: **IO等待时间百分比** - CPU等待IO的时间占比

### 2.4 负载过高解决策略


**🎯 解决思路框架**
```
1. 确定负载类型（CPU/IO/进程密集型）
2. 找到负载来源（具体进程/服务）
3. 分析负载原因（配置/代码/资源问题）
4. 采取针对性措施（优化/限制/扩容）
5. 持续监控验证效果
```

**⚡ 快速缓解措施**
- **限制进程CPU使用率**：`cpulimit -l 50 -p <PID>`
- **调整进程优先级**：`renice +10 -p <PID>`  
- **临时停止非关键服务**：`systemctl stop <service>`

---

## 3. 🧟 僵尸进程批量清理


### 3.1 什么是僵尸进程  

**💡 通俗理解**：僵尸进程就像已经死去但还没有被"埋葬"的进程。它们已经执行完毕，但父进程还没有读取它们的退出状态。

**🎯 僵尸进程特征**：
- **状态显示**：进程状态为 `Z` (Zombie)
- **占用资源**：不占用CPU和内存，但占用进程表项
- **无法直接杀死**：`kill` 命令对僵尸进程无效
- **需要父进程处理**：只能通过父进程回收

### 3.2 僵尸进程产生原因


**🔄 进程生命周期**
```
进程创建 → 运行 → 终止 → 僵尸状态 → 被回收(消失)
             ↑                    ↑
         子进程执行完毕      父进程调用wait()
```

**❌ 产生僵尸进程的常见情况**：
- **父进程忘记回收**：没有调用 `wait()` 或 `waitpid()`
- **父进程死循环**：无法执行到回收子进程的代码
- **程序设计缺陷**：异常处理不完善

### 3.3 检查和识别僵尸进程


**🔍 查找僵尸进程的方法**
```bash
# 方法1：查看所有僵尸进程
ps aux | grep '[Zz]ombie\|<defunct>'

# 方法2：统计僵尸进程数量  
ps aux | awk '$8 ~ /^Z/ { count++ } END { print "僵尸进程数量:", count+0 }'

# 方法3：显示进程状态
ps -eo pid,ppid,state,comm | grep Z
```

**📊 进程状态字母含义**
```
R - Running     (运行中)
S - Sleeping    (休眠)  
D - Disk Sleep  (磁盘休眠，不可中断)
T - Traced      (被追踪或停止)
Z - Zombie      (僵尸进程) ← 重点关注
```

### 3.4 清理僵尸进程的方法


**⭐ 方法一：通知父进程回收(推荐)**
```bash
# 1. 找到僵尸进程的父进程ID  
ps -eo pid,ppid,state,comm | grep Z

# 2. 向父进程发送SIGCHLD信号
kill -SIGCHLD <父进程PID>

# 3. 验证是否清理成功
ps aux | grep '[Zz]ombie\|<defunct>'
```

**🔨 方法二：重启父进程**
```bash
# 1. 确认父进程是什么服务
ps -p <父进程PID> -o comm=

# 2. 重启对应服务(如果是系统服务)
systemctl restart <service_name>
```

**⚠️ 方法三：重启系统(最后手段)**
- 当父进程无法正常处理或是关键系统进程时
- 这种方法会清理所有僵尸进程，但影响业务连续性

### 3.5 批量清理脚本


**🔧 自动化清理脚本**
```bash
#!/bin/bash
# 批量清理僵尸进程脚本

echo "🔍 正在检查僵尸进程..."

# 获取所有僵尸进程信息
zombie_processes=$(ps -eo pid,ppid,state,comm | awk '$3=="Z" {print $1,$2,$4}')

if [ -z "$zombie_processes" ]; then
    echo "✅ 没有发现僵尸进程"
    exit 0
fi

echo "发现以下僵尸进程："
echo "$zombie_processes" | while read zpid ppid comm; do
    echo "僵尸进程: PID=$zpid, 父进程: PID=$ppid, 命令: $comm"
    
    # 向父进程发送信号
    if kill -SIGCHLD $ppid 2>/dev/null; then
        echo "✅ 已向父进程 $ppid 发送回收信号"
    else
        echo "❌ 无法向父进程 $ppid 发送信号"
    fi
done

sleep 2
echo "🔍 再次检查僵尸进程..."
remaining=$(ps aux | awk '$8 ~ /^Z/ { count++ } END { print count+0 }')
echo "剩余僵尸进程数量: $remaining"
```

### 3.6 预防僵尸进程的措施


**💡 程序设计层面**：
- **正确处理信号**：在父进程中设置 `SIGCHLD` 信号处理函数
- **及时回收子进程**：使用 `wait()` 或 `waitpid()` 函数
- **使用双重 fork**：让子进程的父进程变成 init 进程

**🛡️ 系统管理层面**：
- **定期检查**：设置定时任务检查僵尸进程
- **监控告警**：当僵尸进程数量超过阈值时告警
- **代码审查**：审查容易产生僵尸进程的代码

---

## 4. ⚡ CPU频率异常处理


### 4.1 什么是CPU频率调节

**💡 通俗理解**：CPU频率就像汽车的档位，频率高就像高档位跑得快但耗油多，频率低就像低档位省油但速度慢。现代CPU可以根据负载自动调节频率。

**🎯 核心概念**：
- **基准频率**：CPU的标称工作频率
- **最大频率**：CPU可以达到的最高频率(Turbo Boost)
- **最小频率**：CPU为节能设置的最低频率
- **动态调频**：根据负载自动调节CPU频率

### 4.2 CPU频率调节机制


**🔧 调频策略(Governor)类型**

| 策略名称 | 工作模式 | 适用场景 | 特点 |
|----------|----------|----------|------|
| `performance` | 始终最高频率 | 高性能计算 | 🔥高性能 ⚡高耗电 |
| `powersave` | 始终最低频率 | 节能优先 | 🔋低功耗 🐌低性能 |
| `ondemand` | 根据负载调节 | 桌面/服务器 | ⚖️平衡性能功耗 |
| `conservative` | 渐进式调节 | 平滑负载变化 | 📈缓慢响应变化 |
| `schedutil` | 调度器驱动 | 现代Linux | 🎯智能调频 |

### 4.3 检查CPU频率状态


**📊 查看当前CPU频率信息**
```bash
# 查看所有CPU核心当前频率
cat /proc/cpuinfo | grep -i mhz

# 查看CPU频率范围和当前策略
cpupower frequency-info

# 实时监控CPU频率变化
watch -n 1 'cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq'
```

**🔍 详细频率信息查看**
```bash
# 查看支持的调频策略
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors

# 查看当前调频策略  
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

# 查看频率范围
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
```

### 4.4 常见CPU频率异常问题


**🔴 问题1：CPU频率锁定在最低值**
```
现象：系统响应缓慢，CPU频率始终很低
原因：调频策略设置为powersave或硬件限制
诊断：cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
解决：切换到performance或ondemand策略
```

**🔴 问题2：CPU频率无法提升**
```
现象：高负载时CPU频率不升高
原因：温度过高触发降频或电源管理限制
诊断：检查CPU温度和电源状态
解决：改善散热或调整电源管理设置
```

**🔴 问题3：频率调节不生效**  
```
现象：设置调频策略后没有变化
原因：缺少调频驱动或权限不足
诊断：检查cpufreq驱动是否加载
解决：加载对应驱动或使用root权限操作
```

### 4.5 CPU频率调优方案


**⚡ 高性能场景优化**
```bash
# 设置所有CPU核心为performance模式
cpupower frequency-set -g performance

# 验证设置结果
cpupower frequency-info -p
```

**🔋 节能场景优化**
```bash  
# 设置为节能模式
cpupower frequency-set -g powersave

# 设置最大频率限制
cpupower frequency-set -u 2000000  # 限制在2GHz
```

**⚖️ 平衡模式设置**
```bash
# 使用智能调频策略
cpupower frequency-set -g ondemand

# 调整ondemand参数(可选)
echo 10 > /sys/devices/system/cpu/cpufreq/ondemand/up_threshold    # 降低触发阈值
echo 5 > /sys/devices/system/cpu/cpufreq/ondemand/sampling_down_factor  # 调整采样参数
```

### 4.6 频率异常诊断脚本


**🔧 CPU频率诊断工具**
```bash
#!/bin/bash
# CPU频率异常诊断脚本

echo "🔍 CPU频率诊断报告"
echo "=================="

# 检查CPU基本信息
echo "📊 CPU基本信息："
lscpu | grep -E "Model name|CPU MHz|CPU max MHz|CPU min MHz"

echo -e "\n📈 当前频率状态："
# 显示各核心当前频率
for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
    if [ -f "$cpu/cpufreq/scaling_cur_freq" ]; then
        cpu_num=$(basename $cpu)
        cur_freq=$(cat $cpu/cpufreq/scaling_cur_freq)
        governor=$(cat $cpu/cpufreq/scaling_governor)
        echo "${cpu_num}: ${cur_freq} kHz (${governor})"
    fi
done

echo -e "\n⚙️ 调频设置："
if command -v cpupower &> /dev/null; then
    cpupower frequency-info -p
else
    echo "❌ cpupower工具未安装，请安装: yum install kernel-tools 或 apt install linux-tools-generic"
fi

# 检查温度(如果支持)
echo -e "\n🌡️ CPU温度："
if [ -d /sys/class/thermal ]; then
    for thermal in /sys/class/thermal/thermal_zone*; do
        if [ -f "$thermal/temp" ]; then
            temp=$(cat $thermal/temp)
            zone=$(basename $thermal)
            echo "${zone}: $((temp/1000))°C"
        fi
    done
else
    echo "❌ 无法获取温度信息"
fi
```

---

## 5. 🔄 进程调度问题排查


### 5.1 什么是进程调度

**💡 通俗理解**：进程调度就像一个交通警察，决定哪个进程能使用CPU，使用多长时间。Linux使用复杂的算法来公平地分配CPU时间给所有进程。

**🎯 核心概念**：
- **时间片**：每个进程能连续使用CPU的最大时间
- **优先级**：决定进程获得CPU时间的先后顺序
- **调度类**：不同类型的进程使用不同的调度策略
- **负载均衡**：在多核系统中平衡各CPU核心的负载

### 5.2 Linux调度策略类型


**📊 调度类详解**

| 调度策略 | 数值范围 | 适用场景 | 特点 |
|----------|----------|----------|------|
| `SCHED_NORMAL` | nice值-20到19 | 普通用户进程 | 🔄时间片轮转 |
| `SCHED_FIFO` | 优先级1-99 | 实时进程 | 🏃‍♂️先入先出，不被抢占 |
| `SCHED_RR` | 优先级1-99 | 实时进程 | ⏰带时间片的轮转 |
| `SCHED_BATCH` | nice值-20到19 | 批处理作业 | 🐌CPU密集型，低优先级 |
| `SCHED_IDLE` | 固定最低 | 空闲任务 | 💤仅在系统空闲时运行 |

### 5.3 进程优先级系统


**🎯 优先级数值含义**
```
实时优先级: 1-99 (数值越大，优先级越高)
  ├── 99: 最高优先级 (紧急实时任务)
  ├── 50: 中等优先级 (一般实时任务)  
  └── 1:  最低实时优先级

nice值: -20到19 (数值越小，优先级越高)
  ├── -20: 最高优先级 (系统关键进程)
  ├── 0:   默认优先级 (普通用户进程)
  └── 19:  最低优先级 (后台任务)
```

**💡 优先级换算关系**：
- **静态优先级** = 120 + nice值
- **动态优先级** = 静态优先级 ± 奖惩值
- **实时优先级** 始终高于普通进程

### 5.4 调度问题诊断方法


**🔍 查看进程调度信息**
```bash
# 查看进程优先级和nice值
ps -eo pid,pri,ni,comm --sort=-pri | head -20

# 查看实时进程
ps -eo pid,class,rtprio,pri,ni,comm | grep -E "FF|RR"

# 查看调度统计信息
cat /proc/sched_debug | head -50
```

**📈 调度延迟分析**
```bash
# 查看进程调度延迟
cat /proc/[PID]/sched | grep -E "sum_exec_runtime|nr_switches"

# 使用perf工具分析调度
perf sched record sleep 10  # 记录10秒调度信息
perf sched latency          # 显示调度延迟统计
```

### 5.5 常见调度问题及解决


**🔴 问题1：进程响应缓慢**
```
现象：重要进程响应时间过长
原因：进程优先级过低或系统负载过高
诊断：ps -eo pid,pri,ni,pcpu,comm --sort=-pcpu
解决：提高进程优先级 nice -n -10 command
```

**🔴 问题2：实时进程调度异常**  
```
现象：实时进程无法获得预期的响应时间
原因：实时进程配置错误或系统不支持
诊断：chrt -p [PID] 查看调度策略
解决：正确设置实时调度策略和优先级
```

**🔴 问题3：CPU核心负载不均**
```
现象：某些CPU核心很忙，其他核心很闲
原因：进程CPU亲和性设置不当或调度器负载均衡失效
诊断：mpstat -P ALL 1 5 查看各核心使用率
解决：调整CPU亲和性或检查NUMA设置
```

### 5.6 调度优化实践


**⚡ 提升重要进程优先级**
```bash
# 方法1：启动时设置nice值
nice -n -10 important_command

# 方法2：运行时调整nice值  
renice -10 -p [PID]

# 方法3：设置实时调度(需要谨慎)
chrt -f -p 50 [PID]  # FIFO实时调度，优先级50
```

**🎯 批处理任务优化**
```bash
# 设置为批处理调度类
chrt -b -p 0 [PID]

# 降低nice值
renice 19 -p [PID]

# 限制CPU使用率
cpulimit -l 20 -p [PID]  # 限制使用20%CPU
```

**⚖️ 负载均衡优化**
```bash
# 查看CPU亲和性
taskset -p [PID]

# 设置进程运行在特定CPU核心
taskset -p 0x3 [PID]    # 运行在核心0和1上
taskset -c 2,3 [PID]    # 运行在核心2和3上

# 让内核自动负载均衡
echo 1 > /proc/sys/kernel/sched_autogroup_enabled
```

---

## 6. ⚡ 中断处理异常诊断


### 6.1 什么是系统中断

**💡 通俗理解**：中断就像手机来电，无论你在做什么，手机响了你都要先处理来电。系统中断也是这样，硬件设备需要CPU注意时，会发送中断信号打断当前工作。

**🎯 中断类型分析**：
- **硬件中断(IRQ)**：硬件设备产生的中断信号
- **软件中断(SoftIRQ)**：内核软件产生的中断
- **中断处理程序**：响应中断的内核代码
- **中断嵌套**：中断处理过程中又来新中断

### 6.2 中断处理流程


**🔄 中断处理过程**
```
硬件设备产生中断 → CPU接收中断信号 → 保存当前状态 → 
执行中断处理程序 → 恢复之前状态 → 继续执行原任务
```

**📊 中断上下文分类**
```
上半部(Top Half):
├── 硬中断处理 (不可被中断)
├── 时间很短 (微秒级别)
└── 只做紧急处理

下半部(Bottom Half):
├── 软中断/tasklet/工作队列
├── 可以被中断
└── 处理耗时的工作
```

### 6.3 中断统计信息查看


**📈 查看中断统计**
```bash
# 查看中断统计总览
cat /proc/interrupts

# 监控中断变化
watch -n 1 'cat /proc/interrupts'

# 查看软中断统计
cat /proc/softirqs

# 查看中断负载分布
cat /proc/stat | grep intr
```

**🔍 中断信息解读示例**
```bash
# /proc/interrupts 输出示例：
           CPU0       CPU1       CPU2       CPU3       
  0:        150          0          0          0   IO-APIC    2-edge      timer
  1:          2          0          0          0   IO-APIC    1-edge      i8042
  8:          0          0          0          0   IO-APIC    8-edge      rtc0
 24:      45231      38492      41203      39874   PCI-MSI   1048576-edge      eth0
```

**📝 字段含义**：
- **第一列**：中断号(IRQ号)
- **CPU列**：各CPU核心处理该中断的次数
- **最后列**：中断来源设备名称

### 6.4 中断异常问题诊断


**🔴 问题1：中断风暴(Interrupt Storm)**
```
现象：某个中断频率异常高，CPU中断处理时间占比很大
表现：%hi 或 %si 值很高 (top命令中)
原因：硬件故障、驱动Bug或配置错误
```

**🔍 诊断中断风暴**
```bash
# 监控中断频率变化
sar -I ALL 1 10

# 查看哪个中断增长最快
watch -d -n 1 'cat /proc/interrupts | head -20'

# 分析软中断分布
cat /proc/softirqs | grep -E "NET_RX|NET_TX|TIMER"
```

**🔴 问题2：中断不均衡**
```
现象：中断都集中在某个CPU核心处理
影响：该核心负载过高，其他核心利用率低
原因：中断亲和性设置不合理
```

**🔍 检查中断亲和性**
```bash
# 查看中断绑定的CPU
cat /proc/irq/*/smp_affinity

# 查看网卡中断分布
grep eth0 /proc/interrupts
```

### 6.5 中断优化配置


**⚖️ 中断负载均衡**
```bash
# 启用中断自动均衡服务
systemctl start irqbalance
systemctl enable irqbalance

# 手动设置中断亲和性
echo 2 > /proc/irq/24/smp_affinity  # 绑定到CPU1 (二进制10=2)
echo f > /proc/irq/24/smp_affinity  # 绑定到CPU0-3 (二进制1111=f)
```

**🌐 网络中断优化**
```bash
# 查看网卡多队列支持
ethtool -l eth0

# 设置网卡多队列数量
ethtool -L eth0 combined 4

# 查看网卡中断合并设置
ethtool -c eth0

# 调整中断合并参数
ethtool -C eth0 rx-usecs 50 tx-usecs 50
```

**🔧 中断优化脚本**
```bash
#!/bin/bash
# 中断优化脚本

echo "🔍 当前中断统计："
echo "硬中断总数: $(cat /proc/stat | grep intr | awk '{print $2}')"
echo "上下文切换: $(cat /proc/stat | grep ctxt | awk '{print $2}')"

echo -e "\n📊 各CPU中断处理情况："
mpstat -I ALL 1 1 | grep -E "CPU|Average"

echo -e "\n⚖️ 检查中断均衡服务："
if systemctl is-active irqbalance &>/dev/null; then
    echo "✅ irqbalance服务运行正常"
else  
    echo "❌ irqbalance服务未运行，建议启动"
    echo "   执行: systemctl start irqbalance"
fi

echo -e "\n🌐 网络中断分析："
for iface in $(ls /sys/class/net/ | grep -v lo); do
    irq_count=$(grep $iface /proc/interrupts | wc -l)
    if [ $irq_count -gt 0 ]; then
        echo "网卡 $iface 中断队列数: $irq_count"
    fi
done
```

---

## 7. ⚖️ 多核负载不均衡


### 7.1 什么是多核负载均衡

**💡 通俗理解**：多核CPU就像多条车道，理想情况下每条车道的车流量都差不多。如果某条车道堵车严重，其他车道很空闲，就说明负载不均衡。

**🎯 负载均衡的重要性**：
- **性能最优化**：充分利用所有CPU核心
- **避免瓶颈**：防止某个核心成为性能瓶颈  
- **响应时间**：提升系统整体响应速度
- **能耗管理**：均匀分布可以更好地管理功耗

### 7.2 检查多核负载分布


**📊 多核使用率监控**
```bash
# 实时查看各CPU核心使用率
htop  # 按数字键1显示各核心

# 命令行查看各核心详情
mpstat -P ALL 1 5

# 简化版各核心使用率
sar -u -P ALL 1 3
```

**📈 负载不均衡判断标准**
```
理想状态：各核心使用率相近 (差异 < 20%)
轻微不均：个别核心使用率差异 20%-40%
严重不均：某核心使用率 > 80%，其他核心 < 30%
```

**🔍 深度分析工具**
```bash
# 查看进程在各CPU的运行时间
ps -eo pid,psr,pcpu,comm --sort=-pcpu | head -20

# 查看CPU亲和性设置
for pid in $(ps -eo pid --no-headers); do
    if [ -d /proc/$pid ]; then
        echo "PID $pid: $(taskset -p $pid 2>/dev/null | cut -d: -f2)"
    fi
done | head -10
```

### 7.3 负载不均衡的常见原因


**🔴 原因1：进程CPU亲和性设置不当**
```
问题：进程被绑定到特定CPU核心
影响：该核心负载过高，其他核心空闲
检查：taskset -p [PID]
```

**🔴 原因2：中断分布不均**
```
问题：网络、磁盘中断集中在某个核心
影响：该核心频繁处理中断，影响其他任务
检查：cat /proc/interrupts
```

**🔴 原因3：NUMA架构影响**
```
问题：进程访问远程内存节点，性能下降
影响：跨NUMA节点的内存访问延迟高
检查：numactl --hardware
```

**🔴 原因4：调度器负载均衡失效**
```
问题：Linux调度器负载均衡机制异常
影响：新进程总是分配到相同CPU核心
检查：/proc/sys/kernel/sched_* 参数
```

### 7.4 多核负载均衡优化


**⚖️ 自动负载均衡设置**
```bash
# 启用调度器自动负载均衡
echo 1 > /proc/sys/kernel/sched_autogroup_enabled

# 调整负载均衡间隔
echo 5 > /proc/sys/kernel/sched_migration_cost_ns

# 启用中断负载均衡
systemctl enable irqbalance
systemctl start irqbalance
```

**🎯 进程CPU亲和性优化**
```bash
# 清除进程CPU亲和性限制(让内核自动分配)
taskset -ap $(nproc --all) [PID]

# 将CPU密集型任务分散到不同核心
for pid in $(pgrep cpu_intensive_app); do
    core=$((RANDOM % $(nproc)))
    taskset -cp $core $pid
    echo "PID $pid 绑定到CPU核心 $core"
done
```

**🌐 中断均衡优化**
```bash
# 查看当前中断分布
cat /proc/interrupts | grep -E "eth0|sda"

# 手动分散网络中断(示例)
irq_list=$(grep eth0 /proc/interrupts | cut -d: -f1)
cpu_count=$(nproc)
i=0

for irq in $irq_list; do
    target_cpu=$((i % cpu_count))
    echo $((2**target_cpu)) > /proc/irq/$irq/smp_affinity
    echo "中断 $irq 绑定到 CPU $target_cpu"
    i=$((i+1))
done
```

### 7.5 负载均衡监控脚本


**📊 负载均衡监控工具**
```bash
#!/bin/bash
# 多核负载均衡监控脚本

echo "🔍 多核CPU负载均衡分析报告"
echo "============================="

# 获取CPU核心数
cpu_count=$(nproc)
echo "📊 系统信息："
echo "CPU核心数: $cpu_count"
echo "逻辑处理器: $(nproc --all)"

# 获取各核心使用率
echo -e "\n📈 各CPU核心使用率："
mpstat -P ALL 1 1 | grep -E "CPU|Average" | grep -v "all"

# 计算负载均衡度
echo -e "\n⚖️ 负载均衡分析："
usage_stats=$(mpstat -P ALL 1 1 | awk '/^Average:/ && $2 != "all" {print $4}' | tr '\n' ' ')

if [ -n "$usage_stats" ]; then
    max_usage=$(echo $usage_stats | tr ' ' '\n' | sort -rn | head -1)
    min_usage=$(echo $usage_stats | tr ' ' '\n' | sort -n | head -1)
    diff=$(echo "$max_usage - $min_usage" | bc -l 2>/dev/null || echo "计算错误")
    
    echo "最高使用率: ${max_usage}%"
    echo "最低使用率: ${min_usage}%"  
    echo "使用率差异: ${diff}%"
    
    if (( $(echo "$diff > 40" | bc -l 2>/dev/null) )); then
        echo "🔴 警告: 负载严重不均衡"
    elif (( $(echo "$diff > 20" | bc -l 2>/dev/null) )); then
        echo "🟡 注意: 负载轻微不均衡"
    else
        echo "✅ 负载分布均衡"
    fi
fi

# 检查中断分布
echo -e "\n⚡ 中断分布检查："
total_interrupts=$(cat /proc/interrupts | awk 'NR>1 {for(i=2;i<=NF-4;i++) sum+=$i} END {print sum}')
echo "总中断数: $total_interrupts"

if systemctl is-active irqbalance &>/dev/null; then
    echo "✅ irqbalance服务正在运行"
else
    echo "❌ irqbalance服务未运行，建议启动"
fi

# 显示高CPU使用率的进程
echo -e "\n🔥 高CPU使用率进程："
ps -eo pid,psr,pcpu,comm --sort=-pcpu --no-headers | head -5 | while read pid cpu usage comm; do
    echo "PID:$pid CPU核心:$cpu 使用率:${usage}% 进程:$comm"
done
```

---

## 8. 🌡️ CPU温度过高处理


### 8.1 什么是CPU温度过高

**💡 通俗理解**：CPU温度过高就像人发高烧，会影响正常工作，严重时还会自我保护性地降频甚至关机。现代CPU有多重温度保护机制。

**🎯 温度等级划分**：
- **正常温度**：30-60°C (日常使用)
- **警告温度**：60-80°C (需要关注)  
- **危险温度**：80-95°C (降频保护)
- **临界温度**：95°C以上 (自动关机)

### 8.2 CPU温度监控方法


**🌡️ 查看CPU温度**
```bash
# 方法1：使用sensors命令
sensors

# 方法2：直接读取温度文件
cat /sys/class/thermal/thermal_zone*/temp | awk '{print $1/1000"°C"}'

# 方法3：查看具体温度区域
for zone in /sys/class/thermal/thermal_zone*; do
    type=$(cat $zone/type)
    temp=$(cat $zone/temp)
    echo "$type: $((temp/1000))°C"
done
```

**📊 温度持续监控**
```bash
# 实时监控温度变化
watch -n 2 'sensors | grep -E "Core|temp"'

# 记录温度日志
while true; do
    echo "$(date): $(cat /sys/class/thermal/thermal_zone0/temp | awk '{print $1/1000"°C"}')" 
    sleep 60
done > cpu_temp.log
```

### 8.3 温度过高的常见原因


**🔥 硬件原因**
```
散热器问题：
├── 风扇故障或转速不够
├── 导热硅脂老化干涸  
├── 散热器积尘严重
└── 散热器安装不当

环境因素：
├── 机房/环境温度过高
├── 机箱通风不良
└── 空调制冷不足
```

**💻 软件原因**
```
负载过重：
├── CPU使用率长期100%
├── 挖矿病毒或恶意程序
└── 大量计算密集型任务

设置问题：
├── CPU频率锁定在最高
├── 电源管理设置不当  
└── 超频设置过激进
```

### 8.4 温度异常处理方案


**🚨 紧急降温措施**
```bash
# 立即降低CPU频率
cpupower frequency-set -g powersave
cpupower frequency-set -u 1500000  # 限制最高1.5GHz

# 终止高CPU使用率的进程
ps aux --sort=-%cpu | head -10  # 找出CPU使用率最高的进程
kill -9 [高CPU使用率的PID]
```

**⚡ 调频策略调整**
```bash
# 设置温度敏感的调频策略
echo conservative > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

# 降低最大频率限制
for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
    echo 2000000 > $cpu/cpufreq/scaling_max_freq  # 限制2GHz
done
```

**🔧 系统级温度控制**
```bash
# 检查温度控制服务
systemctl status thermald  # Intel温度控制守护进程

# 启用温度控制
systemctl enable thermald
systemctl start thermald

# 查看温度控制策略
thermostat --help 2>/dev/null || echo "thermostat未安装"
```

### 8.5 温度监控告警系统


**📱 温度告警脚本**
```bash
#!/bin/bash
# CPU温度监控告警脚本

# 配置温度阈值
WARN_TEMP=75    # 警告温度
CRIT_TEMP=85    # 危险温度  
EMRG_TEMP=90    # 紧急温度

# 获取当前温度
get_cpu_temp() {
    local temp_file="/sys/class/thermal/thermal_zone0/temp"
    if [ -f "$temp_file" ]; then
        echo $(( $(cat $temp_file) / 1000 ))
    else
        echo "N/A"
    fi
}

# 发送告警通知
send_alert() {
    local level=$1
    local temp=$2
    local message="CPU温度告警: ${level} - 当前温度: ${temp}°C"
    
    echo "[$(date)] $message" >> /var/log/cpu_temp.log
    
    # 可以添加邮件或其他通知方式
    # echo "$message" | mail -s "CPU温度告警" admin@company.com
}

# 紧急降温处理
emergency_cooling() {
    echo "[$(date)] 执行紧急降温措施" >> /var/log/cpu_temp.log
    
    # 设置节能模式
    cpupower frequency-set -g powersave
    
    # 杀死高CPU使用率进程(需要谨慎)
    pkill -f "cpu_intensive_process"  # 替换为实际进程名
}

# 主监控循环
while true; do
    temp=$(get_cpu_temp)
    
    if [ "$temp" != "N/A" ]; then
        if [ $temp -ge $EMRG_TEMP ]; then
            send_alert "紧急" $temp
            emergency_cooling
        elif [ $temp -ge $CRIT_TEMP ]; then
            send_alert "危险" $temp
        elif [ $temp -ge $WARN_TEMP ]; then
            send_alert "警告" $temp
        fi
        
        echo "当前CPU温度: ${temp}°C"
    fi
    
    sleep 30  # 每30秒检查一次
done
```

### 8.6 预防性温度管理


**🛡️ 系统温度优化配置**
```bash
# 配置CPU温度控制
echo "# CPU温度管理配置" >> /etc/sysctl.conf
echo "kernel.nmi_watchdog = 0" >> /etc/sysctl.conf  # 关闭不必要的watchdog

# 设置合理的调频策略
echo 'GOVERNOR="ondemand"' > /etc/default/cpufrequtils

# 配置温度相关的内核模块
echo "coretemp" >> /etc/modules
echo "lm_sensors" >> /etc/modules
```

**📊 温度趋势分析**
```bash
# 温度数据收集脚本
collect_temp_data() {
    while true; do
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        temp=$(cat /sys/class/thermal/thermal_zone0/temp | awk '{print $1/1000}')
        load=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
        
        echo "$timestamp,$temp,$load" >> /var/log/temp_history.csv
        sleep 300  # 每5分钟记录一次
    done
}

# 温度报告生成
generate_temp_report() {
    echo "📊 CPU温度统计报告 (最近24小时)"
    echo "================================="
    
    tail -288 /var/log/temp_history.csv | awk -F',' '
    BEGIN {sum=0; count=0; max=0; min=999}
    {
        temp=$2
        if(temp>max) max=temp
        if(temp<min) min=temp  
        sum+=temp; count++
    }
    END {
        print "平均温度: " sum/count "°C"
        print "最高温度: " max "°C" 
        print "最低温度: " min "°C"
    }'
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基础概念


```
🔸 CPU占用率：衡量CPU工作繁忙程度的关键指标
🔸 系统负载：反映系统整体繁忙程度，包括CPU、IO、内存等
🔸 僵尸进程：已终止但未被回收的进程，占用进程表项
🔸 CPU调频：根据负载动态调整CPU频率以平衡性能和功耗
🔸 进程调度：操作系统分配CPU时间给各进程的机制
🔸 系统中断：硬件设备与CPU通信的机制
🔸 多核均衡：在多核CPU上均匀分布计算负载
🔸 温度管理：监控和控制CPU温度以保证稳定运行
```

### 9.2 关键诊断思路


**🔹 系统性能问题排查流程**
```
1. 观察现象 → 确定问题类型 (CPU/IO/内存)
2. 收集数据 → 使用合适的监控工具
3. 定位根因 → 分析具体进程和资源使用
4. 制定方案 → 选择适当的解决措施
5. 验证效果 → 持续监控确认问题解决
```

**🔹 工具选择原则**
```
快速排查：top, htop, ps aux
详细分析：pidstat, mpstat, iostat, vmstat
实时监控：sar, watch, perf
历史数据：/proc/stat, /proc/loadavg, 日志文件
```

### 9.3 常用命令速查表


| 问题类型 | 推荐命令 | 关键参数 | 输出重点 |
|----------|----------|----------|----------|
| **CPU使用率** | `top -o %CPU` | `-bn1`快照 | `%CPU`, `TIME+` |
| **系统负载** | `uptime` | 无 | `load average` |
| **僵尸进程** | `ps aux \| grep Z` | `--sort=-%cpu` | `STAT`列 |
| **CPU频率** | `cpupower frequency-info` | `-p`策略 | 当前频率和策略 |
| **进程调度** | `ps -eo pid,pri,ni,comm` | `--sort=-pri` | `PRI`, `NI` |
| **中断统计** | `cat /proc/interrupts` | 无 | 各CPU中断次数 |
| **核心负载** | `mpstat -P ALL` | `1 5`监控 | 各核心使用率 |
| **CPU温度** | `sensors` | 无 | Core温度值 |

### 9.4 最佳实践建议


**✅ 预防性措施**
```
定期监控：建立CPU性能监控体系
合理配置：根据业务特点调整系统参数  
及时清理：定期清理僵尸进程和不必要的服务
温度管理：保持良好的散热环境
负载均衡：合理分配多核CPU负载
```

**⚠️ 注意事项**
```
谨慎操作：修改系统参数前要充分测试
备份配置：重要配置文件要备份
影响评估：考虑优化措施对其他服务的影响
持续验证：优化后要持续监控效果
```

### 9.5 故障处理优先级


**🚨 紧急处理 (影响业务)**
- CPU占用率100%导致系统无响应
- CPU温度过高触发保护性关机
- 关键服务进程异常退出

**⚡ 优先处理 (性能影响)**
- 系统负载持续过高
- 多核负载严重不均衡
- 中断风暴影响网络性能

**📊 日常优化 (预防性)**
- 定期清理僵尸进程
- 调整CPU调频策略  
- 优化进程调度参数

### 9.6 学习建议


**📚 深入学习路径**
```
基础概念 → 工具使用 → 问题诊断 → 性能优化 → 自动化监控
```

**🛠️ 实践建议**
- 搭建测试环境，模拟各种CPU性能问题
- 编写监控脚本，自动化日常检查任务
- 建立性能基线，便于异常情况的识别
- 制定应急预案，快速响应生产环境问题

**核心记忆要点**：
- CPU性能问题诊断要系统性思考，从现象到根因
- 工具组合使用效果更好，单一工具有局限性  
- 预防胜于治疗，建立完善的监控体系很重要
- 优化措施要考虑副作用，避免解决一个问题引发新问题