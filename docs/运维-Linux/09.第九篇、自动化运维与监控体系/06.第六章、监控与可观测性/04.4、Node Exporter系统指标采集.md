---
title: 4、Node Exporter系统指标采集
---
## 📚 目录

1. [Node Exporter概述](#1-node-exporter概述)
2. [安装与配置](#2-安装与配置)
3. [系统硬件指标采集](#3-系统硬件指标采集)
4. [CPU使用率指标详解](#4-cpu使用率指标详解)
5. [内存使用指标分析](#5-内存使用指标分析)
6. [磁盘空间和I/O指标](#6-磁盘空间和io指标)
7. [网络接口流量指标](#7-网络接口流量指标)
8. [系统负载和进程指标](#8-系统负载和进程指标)
9. [文件系统和挂载点指标](#9-文件系统和挂载点指标)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 Node Exporter概述


### 1.1 什么是Node Exporter


**核心定义**：Node Exporter是Prometheus生态系统中的一个**系统指标收集器**，专门负责收集Linux/Unix系统的各种硬件和操作系统指标。

```
简单理解：
Node Exporter = 系统健康检查员
- 定期检查CPU、内存、磁盘等系统状态
- 将这些数据转换成Prometheus能理解的格式
- 提供HTTP接口供Prometheus拉取数据
```

### 1.2 工作原理


**数据流向图**：
```
Linux系统     Node Exporter     Prometheus     Grafana
    |              |                |            |
 [系统指标] → [采集转换] → [存储查询] → [可视化展示]
    |              |                |            |
  /proc/          HTTP             PromQL       仪表盘
  /sys/          :9100            时序库        告警
  命令行         metrics
```

**工作流程**：
1. **读取系统信息** - 从`/proc`、`/sys`等系统文件读取数据
2. **格式转换** - 将系统数据转换为Prometheus指标格式
3. **HTTP暴露** - 通过9100端口提供metrics接口
4. **被动采集** - 等待Prometheus定期拉取数据

### 1.3 为什么需要Node Exporter


| 传统监控方式 | Node Exporter方式 |
|-------------|-------------------|
| 需要安装各种监控客户端 | 只需一个轻量级程序 |
| 数据格式不统一 | 标准化Prometheus格式 |
| 难以集成和扩展 | 完美融入Prometheus生态 |
| 资源消耗较大 | 极低资源占用 |

---

## 2. ⚙️ 安装与配置


### 2.1 安装方式选择


**安装方式对比**：
- **🔸 二进制安装**：最直接，适合测试和简单部署
- **🔸 Docker安装**：容器化部署，便于管理
- **🔸 包管理器**：系统集成度高，便于维护
- **🔸 源码编译**：定制化需求

### 2.2 二进制安装步骤


```bash
# 1. 下载最新版本
wget https://github.com/prometheus/node_exporter/releases/download/v1.6.1/node_exporter-1.6.1.linux-amd64.tar.gz

# 2. 解压安装
tar xvfz node_exporter-1.6.1.linux-amd64.tar.gz
sudo cp node_exporter-1.6.1.linux-amd64/node_exporter /usr/local/bin/

# 3. 创建专用用户（安全考虑）
sudo useradd --no-create-home --shell /bin/false node_exporter

# 4. 设置权限
sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter
```

### 2.3 systemd服务配置


**创建服务文件**：
```bash
sudo vim /etc/systemd/system/node_exporter.service
```

**服务配置内容**：
```ini
[Unit]
Description=Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=node_exporter
Group=node_exporter
Type=simple
ExecStart=/usr/local/bin/node_exporter

[Install]
WantedBy=multi-user.target
```

**启动服务**：
```bash
# 重新加载systemd配置
sudo systemctl daemon-reload

# 启动并设置开机自启
sudo systemctl start node_exporter
sudo systemctl enable node_exporter

# 检查状态
sudo systemctl status node_exporter
```

### 2.4 验证安装


**检查运行状态**：
```bash
# 检查进程
ps aux | grep node_exporter

# 检查端口监听
netstat -tlnp | grep 9100

# 测试metrics接口
curl http://localhost:9100/metrics | head -20
```

**Docker方式安装**：
```bash
# 运行容器
docker run -d \
  --name node-exporter \
  --restart unless-stopped \
  -p 9100:9100 \
  -v /proc:/host/proc:ro \
  -v /sys:/host/sys:ro \
  -v /:/rootfs:ro \
  prom/node-exporter \
  --path.procfs=/host/proc \
  --path.sysfs=/host/sys \
  --collector.filesystem.mount-points-exclude='^/(sys|proc|dev|host|etc)($$|/)'
```

---

## 3. 🖥️ 系统硬件指标采集


### 3.1 硬件信息指标


**CPU硬件信息**：
```
node_cpu_info - CPU详细信息
├── cpu: CPU核心编号
├── package: CPU插槽编号  
├── core: 物理核心编号
├── vendor: 制造商(Intel/AMD)
├── family: CPU家族
└── model_name: CPU型号
```

**内存硬件信息**：
```
node_memory_* 指标族：
├── MemTotal: 总内存大小
├── MemFree: 空闲内存
├── MemAvailable: 可用内存
├── Buffers: 缓冲区内存
└── Cached: 缓存内存
```

### 3.2 硬件温度监控


**温度传感器指标**：
- `node_hwmon_temp_celsius` - 硬件温度(摄氏度)
- `node_thermal_zone_temp` - 热区温度

**常见传感器类型**：
```
CPU温度传感器：
- coretemp: Intel CPU核心温度
- k10temp: AMD CPU温度

主板传感器：
- acpi: ACPI温度传感器
- iwlwifi: 无线网卡温度
```

### 3.3 硬件状态指标


| 指标名称 | 含义说明 | 重要程度 |
|---------|---------|---------|
| `node_hwmon_fan_rpm` | 风扇转速 | ⭐⭐⭐ |
| `node_power_supply_*` | 电源状态 | ⭐⭐ |
| `node_edac_*` | 内存错误检测 | ⭐⭐ |
| `node_entropy_available_bits` | 系统熵池 | ⭐⭐ |

---

## 4. 🚀 CPU使用率指标详解


### 4.1 CPU时间指标


**核心CPU指标**：
```
node_cpu_seconds_total 指标详解：
├── mode="user"    - 用户态时间（用户程序执行）
├── mode="system"  - 内核态时间（系统调用、中断）
├── mode="idle"    - 空闲时间（CPU无任务）
├── mode="iowait"  - I/O等待时间（等待磁盘、网络）
├── mode="irq"     - 硬中断时间
├── mode="softirq" - 软中断时间
├── mode="steal"   - 虚拟化环境被偷取时间
└── mode="nice"    - 低优先级用户态时间
```

### 4.2 CPU使用率计算


**使用率计算公式**：
```
CPU使用率 = 100% - (idle时间增量 / 总时间增量) × 100%

具体计算：
1. 获取两个时间点的CPU时间
2. 计算各个mode的时间增量
3. 计算总时间增量 = Σ(所有mode时间增量)
4. 计算空闲率 = idle增量 / 总时间增量
5. 使用率 = 1 - 空闲率
```

**PromQL查询示例**：
```promql
# 整体CPU使用率
100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

# 按CPU核心分别显示
100 - (irate(node_cpu_seconds_total{mode="idle"}[5m]) * 100)

# 用户态CPU使用率
irate(node_cpu_seconds_total{mode="user"}[5m]) * 100

# I/O等待时间占比
irate(node_cpu_seconds_total{mode="iowait"}[5m]) * 100
```

### 4.3 CPU负载指标


**系统负载指标**：
- `node_load1` - 1分钟平均负载
- `node_load5` - 5分钟平均负载  
- `node_load15` - 15分钟平均负载

**负载理解**：
```
负载值含义：
├── 0.00: 系统完全空闲
├── 1.00: 系统满负载运行（单核）
├── 2.00: 系统过载100%（单核）或满载（双核）
└── 4.00: 四核系统满负载或单核过载300%

判断标准：
✅ 负载 < CPU核数：系统正常
⚠️  负载 = CPU核数：系统满载
❌ 负载 > CPU核数：系统过载
```

---

## 5. 🧠 内存使用指标分析


### 5.1 内存基础指标


**内存指标体系**：
```
Linux内存管理结构：
┌─────────────────────────────────┐
│          物理内存总量            │
├─────────────────────────────────┤
│  已使用内存                      │
│  ├── 应用程序内存                │
│  ├── 内核内存                   │
│  └── 缓存/缓冲区                │
├─────────────────────────────────┤
│  空闲内存                       │
└─────────────────────────────────┘
```

**核心内存指标**：
```
node_memory_MemTotal_bytes     - 总内存
node_memory_MemFree_bytes      - 空闲内存
node_memory_MemAvailable_bytes - 可用内存
node_memory_Buffers_bytes      - 缓冲区内存
node_memory_Cached_bytes       - 页面缓存
node_memory_Active_bytes       - 活跃内存
node_memory_Inactive_bytes     - 非活跃内存
```

### 5.2 内存使用率计算


**内存使用率公式**：
```
传统计算方式：
使用率 = (总内存 - 空闲内存) / 总内存 × 100%

推荐计算方式：
使用率 = (总内存 - 可用内存) / 总内存 × 100%

其中：
可用内存 = 空闲内存 + 缓冲区 + 可回收缓存
```

**PromQL查询示例**：
```promql
# 内存使用率（推荐方式）
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100

# 内存使用率（传统方式）
(1 - (node_memory_MemFree_bytes / node_memory_MemTotal_bytes)) * 100

# 缓存使用量
node_memory_Cached_bytes + node_memory_Buffers_bytes

# 应用程序实际使用内存
node_memory_MemTotal_bytes - node_memory_MemFree_bytes - node_memory_Buffers_bytes - node_memory_Cached_bytes
```

### 5.3 交换分区指标


**交换分区监控**：
- `node_memory_SwapTotal_bytes` - 交换分区总大小
- `node_memory_SwapFree_bytes` - 交换分区空闲空间
- `node_vmstat_pswpin` - 换入页面数
- `node_vmstat_pswpout` - 换出页面数

**交换活动分析**：
```
交换分区使用情况判断：
✅ 交换使用率 < 10%: 内存充足
⚠️  交换使用率 10-50%: 内存紧张
❌ 交换使用率 > 50%: 严重内存不足

频繁交换判断：
pswpin/pswpout速率 > 100/s: 频繁交换，性能影响大
```

---

## 6. 💽 磁盘空间和I/O指标


### 6.1 磁盘空间指标


**文件系统空间指标**：
```
node_filesystem_* 指标族：
├── size_bytes: 文件系统总大小
├── free_bytes: 可用空间
├── avail_bytes: 普通用户可用空间
└── files: inode总数
```

**磁盘使用率计算**：
```promql
# 磁盘使用率
(1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100

# 过滤系统文件系统
(1 - (
  node_filesystem_avail_bytes{fstype!~"tmpfs|rootfs|overlay"} / 
  node_filesystem_size_bytes{fstype!~"tmpfs|rootfs|overlay"}
)) * 100
```

### 6.2 磁盘I/O性能指标


**磁盘I/O指标体系**：
```
磁盘I/O性能维度：
┌─────────────────┐
│   I/O吞吐量     │ ← 每秒读写字节数
├─────────────────┤
│   I/O操作数     │ ← 每秒读写次数  
├─────────────────┤
│   I/O延迟       │ ← 平均等待时间
├─────────────────┤
│   I/O利用率     │ ← 磁盘繁忙程度
└─────────────────┘
```

**核心I/O指标**：
| 指标名称 | 含义说明 | 计算方式 |
|---------|---------|---------|
| `node_disk_reads_completed_total` | 读操作完成次数 | 累计计数器 |
| `node_disk_writes_completed_total` | 写操作完成次数 | 累计计数器 |
| `node_disk_read_bytes_total` | 读取字节总数 | 累计计数器 |
| `node_disk_written_bytes_total` | 写入字节总数 | 累计计数器 |
| `node_disk_io_time_seconds_total` | I/O总时间 | 累计计数器 |

### 6.3 I/O性能分析


**IOPS计算**：
```promql
# 读IOPS
irate(node_disk_reads_completed_total[5m])

# 写IOPS  
irate(node_disk_writes_completed_total[5m])

# 总IOPS
irate(node_disk_reads_completed_total[5m]) + irate(node_disk_writes_completed_total[5m])
```

**吞吐量计算**：
```promql
# 读吞吐量 (字节/秒)
irate(node_disk_read_bytes_total[5m])

# 写吞吐量 (字节/秒)
irate(node_disk_written_bytes_total[5m])

# 总吞吐量
irate(node_disk_read_bytes_total[5m]) + irate(node_disk_written_bytes_total[5m])
```

**磁盘利用率**：
```promql
# 磁盘使用率（百分比）
irate(node_disk_io_time_seconds_total[5m]) * 100
```

---

## 7. 🌐 网络接口流量指标


### 7.1 网络流量指标


**网络接口指标**：
```
node_network_* 指标族：
├── receive_bytes_total: 接收字节总数
├── transmit_bytes_total: 发送字节总数
├── receive_packets_total: 接收数据包总数  
├── transmit_packets_total: 发送数据包总数
├── receive_errs_total: 接收错误总数
├── transmit_errs_total: 发送错误总数
├── receive_drop_total: 接收丢包总数
└── transmit_drop_total: 发送丢包总数
```

### 7.2 网络流量计算


**带宽使用率计算**：
```promql
# 网络接收流量（字节/秒）
irate(node_network_receive_bytes_total{device!~"lo|veth.*"}[5m])

# 网络发送流量（字节/秒）  
irate(node_network_transmit_bytes_total{device!~"lo|veth.*"}[5m])

# 总网络流量
irate(node_network_receive_bytes_total{device!~"lo|veth.*"}[5m]) + 
irate(node_network_transmit_bytes_total{device!~"lo|veth.*"}[5m])

# 网络包速率
irate(node_network_receive_packets_total{device!~"lo|veth.*"}[5m])
```

### 7.3 网络质量指标


**网络错误率**：
```promql
# 接收错误率
(
  irate(node_network_receive_errs_total[5m]) / 
  irate(node_network_receive_packets_total[5m])
) * 100

# 丢包率
(
  irate(node_network_receive_drop_total[5m]) / 
  irate(node_network_receive_packets_total[5m])
) * 100
```

**网络接口状态**：
- `node_network_up` - 网络接口状态（1=up, 0=down）
- `node_network_carrier` - 网络载波状态
- `node_network_mtu_bytes` - 最大传输单元大小

---

## 8. ⚖️ 系统负载和进程指标


### 8.1 系统负载详解


**负载均值指标**：
- `node_load1` - 1分钟负载均值
- `node_load5` - 5分钟负载均值
- `node_load15` - 15分钟负载均值

**负载趋势分析**：
```
负载趋势判断：
├── load1 > load5 > load15: 负载上升趋势
├── load1 < load5 < load15: 负载下降趋势
├── load1 ≈ load5 ≈ load15: 负载稳定
└── 差值过大: 负载波动剧烈
```

### 8.2 进程和线程指标


**进程统计指标**：
- `node_procs_running` - 运行中进程数
- `node_procs_blocked` - 阻塞进程数  
- `node_forks_total` - 进程fork总数

**上下文切换**：
- `node_context_switches_total` - 上下文切换总数
- `node_intr_total` - 中断总数

**进程状态分析**：
```promql
# 进程创建速率
irate(node_forks_total[5m])

# 上下文切换速率
irate(node_context_switches_total[5m])

# 中断处理速率
irate(node_intr_total[5m])
```

### 8.3 文件描述符指标


**文件描述符监控**：
- `node_filefd_allocated` - 已分配文件描述符数
- `node_filefd_maximum` - 最大文件描述符限制

**使用率计算**：
```promql
# 文件描述符使用率
(node_filefd_allocated / node_filefd_maximum) * 100
```

---

## 9. 📁 文件系统和挂载点指标


### 9.1 文件系统类型


**常见文件系统类型**：
- `ext4` - Linux标准文件系统
- `xfs` - 高性能文件系统
- `tmpfs` - 内存文件系统
- `overlay` - 容器overlayfs
- `nfs` - 网络文件系统

**文件系统过滤**：
```promql
# 只监控物理文件系统
node_filesystem_size_bytes{fstype=~"ext4|xfs|btrfs"}

# 排除临时文件系统
node_filesystem_size_bytes{fstype!~"tmpfs|devtmpfs|overlay"}
```

### 9.2 inode使用监控


**inode指标**：
- `node_filesystem_files` - inode总数
- `node_filesystem_files_free` - 空闲inode数

**inode使用率**：
```promql
# inode使用率
(1 - (node_filesystem_files_free / node_filesystem_files)) * 100
```

### 9.3 挂载点监控


**只读文件系统检测**：
- `node_filesystem_readonly` - 文件系统只读状态

**挂载点状态检查**：
```promql
# 检测只读文件系统
node_filesystem_readonly{fstype!~"tmpfs|rootfs"} == 1

# 磁盘空间告警
(1 - (node_filesystem_avail_bytes{fstype!~"tmpfs"} / 
     node_filesystem_size_bytes{fstype!~"tmpfs"})) * 100 > 85
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 Node Exporter本质：Prometheus生态中的系统指标收集器
🔸 数据来源：主要从/proc和/sys目录读取Linux系统信息
🔸 工作模式：被动模式，等待Prometheus拉取数据
🔸 端口：默认9100端口提供metrics接口
🔸 数据格式：Prometheus标准格式，支持标签和时间序列
```

### 10.2 关键监控维度


**🔹 CPU监控要点**：
- **使用率计算**：基于idle时间的反向计算
- **负载理解**：负载值与CPU核数的关系
- **时间分配**：user、system、iowait时间的含义

**🔹 内存监控要点**：
- **可用内存**：MemAvailable比MemFree更准确
- **缓存理解**：buffer/cache是可回收内存
- **交换监控**：关注交换频率而非使用量

**🔹 磁盘监控要点**：
- **空间监控**：使用率、inode使用率
- **性能监控**：IOPS、吞吐量、延迟、利用率
- **健康监控**：错误计数、只读状态

**🔹 网络监控要点**：
- **流量监控**：接收/发送字节数和包数
- **质量监控**：错误率、丢包率
- **接口状态**：up/down状态、载波状态

### 10.3 实际应用指导


**☑️ 安装部署检查清单**：
- ✅ 创建专用用户运行Node Exporter
- ✅ 配置systemd服务实现自启动
- ✅ 验证9100端口可访问
- ✅ 检查metrics接口返回数据

**☑️ 监控配置最佳实践**：
- ✅ 合理设置抓取间隔（通常15-60秒）
- ✅ 过滤不需要的文件系统类型
- ✅ 关注核心指标，避免信息过载
- ✅ 设置合理的告警阈值

### 10.4 常见问题解决


**🔧 性能问题**：
```
Node Exporter占用资源过高：
├── 检查是否启用了不必要的collector
├── 调整Prometheus抓取频率
├── 优化文件系统监控范围
└── 考虑使用更高效的存储
```

**🔧 数据问题**：
```
指标数据不准确或缺失：
├── 检查/proc和/sys目录权限
├── 验证系统支持相关功能
├── 查看Node Exporter日志
└── 确认collector是否正常启用
```

**🔧 连接问题**：
```
Prometheus无法抓取数据：
├── 检查网络连通性
├── 验证防火墙规则
├── 确认端口监听状态
└── 检查服务运行状态
```

### 10.5 进阶应用


**🚀 自定义监控**：
- 使用textfile collector添加自定义指标
- 编写脚本定期更新自定义指标文件
- 结合业务需求扩展监控维度

**🚀 高可用部署**：
- 多个Node Exporter实例避免单点故障
- 使用负载均衡分散监控压力
- 实现自动化部署和配置管理

**核心记忆要点**：
- Node Exporter是系统监控的数据采集基石
- 理解Linux系统指标的实际含义比记住指标名称更重要
- 合理的监控配置平衡准确性和性能开销
- 持续优化监控策略，关注真正有价值的指标