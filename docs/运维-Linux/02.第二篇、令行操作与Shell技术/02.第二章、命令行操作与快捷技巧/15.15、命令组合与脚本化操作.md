---
title: 15、命令组合与脚本化操作
---
## 📚 目录

1. [命令连接操作符](#1-命令连接操作符)
2. [后台执行与进程控制](#2-后台执行与进程控制)
3. [命令分组技术](#3-命令分组技术)
4. [条件判断与测试](#4-条件判断与测试)
5. [基础循环结构](#5-基础循环结构)
6. [函数定义与使用](#6-函数定义与使用)
7. [脚本执行方式](#7-脚本执行方式)
8. [退出状态管理](#8-退出状态管理)
9. [实战应用案例](#9-实战应用案例)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔗 命令连接操作符


### 1.1 什么是命令连接


**💡 通俗理解**：
命令连接就像生活中的"然后"、"如果"、"否则"：
- **顺序执行**：先做这个，再做那个（不管结果如何）
- **条件执行**：只有成功了才做下一个
- **失败执行**：只有失败了才做备用方案

```
生活类比：
; = 无论如何都要做
&& = 成功了再做下一件事
|| = 失败了就做备用计划

例如：起床; 刷牙 && 洗脸 || 直接出门
```

### 1.2 分号(;)顺序执行


**📚 基本概念**：
分号让命令按顺序依次执行，不管前面的命令是否成功。

```bash
# 基本语法
command1 ; command2 ; command3

# 实际示例
cd /tmp ; ls -la ; pwd
```

**🔢 实用场景**：

1️⃣ **批量文件操作**：
```bash
# 创建目录并进入，然后创建文件
mkdir test_dir ; cd test_dir ; touch file1.txt file2.txt
```

2️⃣ **系统维护任务**：
```bash
# 清理临时文件，更新系统，重启服务
sudo apt clean ; sudo apt update ; sudo systemctl restart nginx
```

3️⃣ **日志记录**：
```bash
# 记录操作时间和执行命令
date ; whoami ; pwd ; ls -la
```

### 1.3 双与号(&&)条件执行


**💡 通俗理解**：
`&&` 就像"如果...那么"的逻辑，只有前面成功了才执行后面的。

```bash
# 基本语法  
command1 && command2 && command3

# 只有command1成功，才会执行command2
# 只有command2也成功，才会执行command3
```

**🎯 典型应用**：

1️⃣ **安全的文件操作**：
```bash
# 只有创建目录成功，才进入并创建文件
mkdir backup && cd backup && cp /etc/passwd .

# 只有文件存在，才进行备份
test -f config.txt && cp config.txt config.txt.bak
```

2️⃣ **编译安装流程**：
```bash
# 典型的编译安装三部曲
./configure && make && make install
```

3️⃣ **网络操作**：
```bash
# 只有能ping通，才下载文件
ping -c 1 www.example.com && wget http://www.example.com/file.tar.gz
```

### 1.4 双或号(||)失败执行


**💡 通俗理解**：
`||` 就像"否则"的意思，前面失败了才执行后面的，通常用作备用方案。

```bash
# 基本语法
command1 || command2

# 只有command1失败，才会执行command2
```

**🔧 实用案例**：

1️⃣ **容错处理**：
```bash
# 尝试用vim编辑，如果没安装就用nano
vim file.txt || nano file.txt

# 尝试用git命令，失败就提示安装
git --version || echo "请先安装git: sudo apt install git"
```

2️⃣ **目录切换**：
```bash
# 尝试进入项目目录，失败就创建它
cd /home/user/project || mkdir -p /home/user/project
```

3️⃣ **服务管理**：
```bash
# 尝试重启服务，失败就启动服务
sudo systemctl restart nginx || sudo systemctl start nginx
```

### 1.5 组合使用技巧


```bash
# 复杂的逻辑组合
mkdir logs && cd logs && touch error.log || echo "创建日志目录失败"

# 等价于：
# 如果能创建logs目录，并且能进入，并且能创建文件，就什么都不做
# 否则显示错误信息
```

---

## 2. 🔄 后台执行与进程控制


### 2.1 &符号后台执行


**💡 通俗理解**：
`&` 就像把任务"丢到后台"继续运行，你可以继续做其他事情。

```
生活类比：
没有& = 洗衣服时必须在旁边等着
有&   = 启动洗衣机后可以去做其他事
```

**🔢 基本使用**：

1️⃣ **简单后台执行**：
```bash
# 后台运行长时间任务
find / -name "*.log" > findresult.txt &

# 后台启动服务
python3 webserver.py &

# 后台执行备份
tar -czf backup.tar.gz /home/user/ &
```

2️⃣ **查看后台任务**：
```bash
# 查看当前后台任务
jobs

# 输出示例：
# [1]+  Running    find / -name "*.log" > findresult.txt &
# [2]-  Running    python3 webserver.py &
```

3️⃣ **控制后台任务**：
```bash
# 将后台任务调到前台
fg %1    # 调出第一个后台任务

# 让暂停的任务在后台继续
bg %1    # 让第一个任务在后台继续运行
```

### 2.2 nohup持久化执行


**💡 通俗理解**：
`nohup` 就像给程序"买保险"，即使你关闭终端窗口，程序也会继续运行。

```
对比理解：
普通&: 关闭终端，程序就停止了
nohup&: 关闭终端，程序还在运行
```

**🔧 实际应用**：

1️⃣ **基本语法**：
```bash
# 基本用法
nohup command &

# 实例：后台持久运行Python脚本
nohup python3 monitor.py &

# 输出会保存到nohup.out文件
```

2️⃣ **指定输出文件**：
```bash
# 将输出重定向到指定文件
nohup python3 webserver.py > server.log 2>&1 &

# 解释：
# > server.log     标准输出到server.log
# 2>&1            错误输出也到server.log
# &               后台运行
```

3️⃣ **实用场景**：
```bash
# 长时间的数据处理
nohup ./process_big_data.sh > process.log 2>&1 &

# 启动Web服务器
nohup java -jar myapp.jar > app.log 2>&1 &

# 持续监控系统
nohup watch -n 60 'df -h' > disk_monitor.log 2>&1 &
```

**⚠️ 重要提醒**：
> 使用nohup时记住：
> - 程序会在后台持续运行
> - 要停止程序需要找到进程ID并kill
> - 输出默认保存在nohup.out中

---

## 3. 📦 命令分组技术


### 3.1 小括号()子shell分组


**💡 通俗理解**：
小括号就像"开一个新房间"执行命令，不会影响当前环境。

```
类比理解：
() = 在新房间里操作，不影响主房间
{} = 在当前房间操作，会影响环境
```

**🔢 基本使用**：

1️⃣ **环境隔离**：
```bash
# 在子shell中切换目录，不影响当前目录
(cd /tmp && ls -la && pwd)
pwd  # 仍在原来的目录

# 对比：直接执行会改变当前目录
cd /tmp && ls -la && pwd
pwd  # 已经在/tmp目录了
```

2️⃣ **变量作用域**：
```bash
# 子shell中的变量不影响父shell
VAR="原始值"
(VAR="新值"; echo "子shell中: $VAR")
echo "父shell中: $VAR"  # 仍是"原始值"
```

3️⃣ **实用场景**：
```bash
# 临时切换目录执行命令
(cd /var/log && tar -czf ~/logs_backup.tar.gz *.log)

# 批量操作但不影响当前环境
(export PATH="/custom/bin:$PATH" && custom_command && another_command)
```

### 3.2 大括号{}当前shell分组


**💡 通俗理解**：
大括号在当前环境中分组执行命令，所有改变都会保留。

**🔧 语法要点**：
```bash
# 注意语法细节
{ command1; command2; }  # 注意分号和空格

# 错误写法
{command1; command2}     # 缺少空格
{ command1; command2 }   # 最后缺少分号
```

**🎯 应用场景**：

1️⃣ **重定向分组**：
```bash
# 将多个命令的输出一起重定向
{
    echo "系统信息报告"
    date
    uname -a
    df -h
} > system_report.txt
```

2️⃣ **条件执行分组**：
```bash
# 多个命令作为一个整体进行条件判断
test -d /backup || {
    echo "创建备份目录"
    mkdir -p /backup
    chmod 755 /backup
}
```

3️⃣ **函数式使用**：
```bash
# 创建临时的命令组合
backup_logs() {
    local backup_dir="/backup/$(date +%Y%m%d)"
    {
        mkdir -p "$backup_dir"
        cp /var/log/*.log "$backup_dir/"
        echo "备份完成: $backup_dir"
    }
}
```

---

## 4. ✅ 条件判断与测试


### 4.1 test命令基础


**💡 通俗理解**：
`test` 就像问"是不是"的问题，返回"是"(真)或"不是"(假)。

```
生活类比：
test -f file.txt  = "这个文件存在吗？"
test $a -eq $b    = "a等于b吗？"
test -d directory = "这是个目录吗？"
```

**📋 常用测试操作**：

| **测试类型** | **操作符** | **含义** | **示例** |
|------------|-----------|---------|----------|
| **文件测试** | `-f` | 是普通文件 | `test -f file.txt` |
| | `-d` | 是目录 | `test -d /home` |
| | `-e` | 文件存在 | `test -e path` |
| | `-r` | 可读 | `test -r file` |
| | `-w` | 可写 | `test -w file` |
| | `-x` | 可执行 | `test -x script` |
| **数值比较** | `-eq` | 等于 | `test $a -eq $b` |
| | `-ne` | 不等于 | `test $a -ne $b` |
| | `-lt` | 小于 | `test $a -lt $b` |
| | `-gt` | 大于 | `test $a -gt $b` |
| **字符串测试** | `=` | 字符串相等 | `test "$a" = "$b"` |
| | `!=` | 字符串不等 | `test "$a" != "$b"` |
| | `-z` | 字符串为空 | `test -z "$var"` |
| | `-n` | 字符串非空 | `test -n "$var"` |

### 4.2 []方括号测试


**💡 通俗理解**：
`[ ]` 是 `test` 的简写形式，使用更方便，但功能相同。

```bash
# 这两种写法完全等价
test -f file.txt
[ -f file.txt ]

# 注意：方括号内必须有空格
[ -f file.txt ]    # 正确
[-f file.txt]      # 错误
[    -f file.txt    ]  # 正确，多余空格也可以
```

**🔢 实用示例**：

1️⃣ **文件检查**：
```bash
# 检查配置文件是否存在
if [ -f /etc/nginx/nginx.conf ]; then
    echo "Nginx配置文件存在"
else
    echo "请先安装Nginx"
fi
```

2️⃣ **目录操作**：
```bash
# 安全创建目录
[ -d backup ] || mkdir backup

# 清理空目录
[ -d temp ] && [ ! "$(ls -A temp)" ] && rmdir temp
```

3️⃣ **变量判断**：
```bash
# 检查变量是否设置
[ -n "$USER" ] && echo "用户名: $USER"

# 检查命令行参数
[ $# -eq 0 ] && echo "请提供参数" && exit 1
```

### 4.3 [[]]双方括号增强测试


**💡 通俗理解**：
`[[ ]]` 是增强版测试，支持更多功能，比如模式匹配和正则表达式。

```bash
# 基本功能与[]相同
[[ -f file.txt ]] && echo "文件存在"

# 但支持更多高级功能
[[ $filename == *.txt ]] && echo "这是文本文件"
[[ $string =~ [0-9]+ ]] && echo "包含数字"
```

**🚀 高级功能**：

1️⃣ **模式匹配**：
```bash
filename="document.pdf"

# 检查文件扩展名
[[ $filename == *.pdf ]] && echo "这是PDF文件"
[[ $filename == *.txt || $filename == *.md ]] && echo "这是文本文件"
```

2️⃣ **正则表达式**：
```bash
input="abc123def"

# 检查是否包含数字
[[ $input =~ [0-9] ]] && echo "包含数字"

# 检查邮箱格式（简单验证）
email="user@example.com"
[[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]] && echo "邮箱格式正确"
```

3️⃣ **逻辑组合**：
```bash
# 复杂条件判断
if [[ -f "$file" && -r "$file" && -s "$file" ]]; then
    echo "文件存在且可读且不为空"
fi

# 等价的test写法会很复杂
if test -f "$file" -a -r "$file" -a -s "$file"; then
    echo "文件存在且可读且不为空"
fi
```

---

## 5. 🔄 基础循环结构


### 5.1 for循环遍历


**💡 通俗理解**：
`for` 循环就像"对每一个...都做同样的事情"。

```
生活类比：
for 每个苹果 in 篮子里; do
    洗苹果
    吃苹果
done
```

**🔢 基本语法形式**：

1️⃣ **遍历列表**：
```bash
# 基本语法
for item in list; do
    command $item
done

# 实例：处理多个文件
for file in *.txt; do
    echo "处理文件: $file"
    wc -l "$file"
done
```

2️⃣ **遍历数组**：
```bash
# 定义数组
servers=("web01" "web02" "db01" "cache01")

# 遍历数组
for server in "${servers[@]}"; do
    echo "检查服务器: $server"
    ping -c 1 "$server" || echo "$server 无法访问"
done
```

3️⃣ **数值范围循环**：
```bash
# 使用seq命令
for i in $(seq 1 10); do
    echo "第 $i 次循环"
done

# 使用大括号展开
for i in {1..10}; do
    echo "数字: $i"
done

# 步长循环
for i in {1..20..2}; do  # 从1到20，步长为2
    echo "奇数: $i"
done
```

### 5.2 while循环控制


**💡 通俗理解**：
`while` 循环就像"只要...就继续做"。

```bash
# 基本语法
while [ condition ]; do
    command
done
```

**🎯 实用场景**：

1️⃣ **计数循环**：
```bash
# 简单计数
count=1
while [ $count -le 5 ]; do
    echo "计数: $count"
    count=$((count + 1))
done
```

2️⃣ **文件监控**：
```bash
# 等待文件出现
while [ ! -f "/tmp/ready.flag" ]; do
    echo "等待文件创建..."
    sleep 2
done
echo "文件已创建，继续执行"
```

3️⃣ **用户输入循环**：
```bash
# 持续获取用户输入
while true; do
    echo -n "请输入命令 (quit退出): "
    read input
    
    if [ "$input" = "quit" ]; then
        break
    fi
    
    echo "你输入了: $input"
done
```

### 5.3 until循环结构


**💡 通俗理解**：
`until` 循环是 `while` 的反面，"直到...才停止"。

```bash
# 基本语法
until [ condition ]; do
    command
done

# 等价于
while [ ! condition ]; do
    command
done
```

**🔧 实际应用**：

```bash
# 等待服务启动
until curl -s http://localhost:8080 > /dev/null; do
    echo "等待服务启动..."
    sleep 5
done
echo "服务已就绪"

# 等待网络连接
until ping -c 1 google.com > /dev/null 2>&1; do
    echo "等待网络连接..."
    sleep 10
done
echo "网络已连接"
```

---

## 6. 🔧 函数定义与使用


### 6.1 函数基本语法


**💡 通俗理解**：
函数就像"封装好的工具包"，定义一次可以重复使用。

```bash
# 两种定义方式

# 方式1：使用function关键字
function function_name() {
    commands
}

# 方式2：直接定义（推荐）
function_name() {
    commands
}
```

**🔢 简单示例**：

1️⃣ **基础函数**：
```bash
# 定义打招呼函数
greet() {
    echo "你好，$1!"
}

# 调用函数
greet "张三"      # 输出：你好，张三!
greet "李四"      # 输出：你好，李四!
```

2️⃣ **带参数的函数**：
```bash
# 创建备份函数
backup_file() {
    local source_file="$1"
    local backup_dir="$2"
    
    if [ -f "$source_file" ]; then
        cp "$source_file" "$backup_dir/$(basename "$source_file").bak"
        echo "备份完成: $source_file"
    else
        echo "文件不存在: $source_file"
        return 1
    fi
}

# 使用函数
backup_file "/etc/hosts" "/backup"
```

### 6.2 函数参数与返回值


**📋 参数处理**：

| **变量** | **含义** | **示例** |
|---------|---------|----------|
| `$1, $2, ...` | 第1、2...个参数 | `$1` |
| `$#` | 参数个数 | `echo "参数个数: $#"` |
| `$@` | 所有参数列表 | `for arg in "$@"` |
| `$*` | 所有参数字符串 | `echo "$*"` |

```bash
# 参数处理示例
process_files() {
    echo "函数名: $0"
    echo "参数个数: $#"
    echo "所有参数: $@"
    
    for file in "$@"; do
        if [ -f "$file" ]; then
            echo "处理文件: $file"
        else
            echo "文件不存在: $file"
        fi
    done
}

# 调用示例
process_files file1.txt file2.txt file3.txt
```

**🎯 返回值处理**：

```bash
# 检查文件类型
check_file_type() {
    local file="$1"
    
    if [ -f "$file" ]; then
        return 0    # 普通文件
    elif [ -d "$file" ]; then
        return 1    # 目录
    else
        return 2    # 不存在
    fi
}

# 使用返回值
check_file_type "/etc/hosts"
case $? in
    0) echo "这是一个普通文件" ;;
    1) echo "这是一个目录" ;;
    2) echo "文件不存在" ;;
esac
```

### 6.3 局部变量与作用域


**⚠️ 重要概念**：
```bash
# 全局变量（默认）
global_var="全局变量"

my_function() {
    # 局部变量（推荐）
    local local_var="局部变量"
    
    # 修改全局变量
    global_var="被函数修改了"
    
    echo "函数内: $local_var"
}

my_function
echo "函数外: $global_var"      # 输出：被函数修改了
echo "函数外: $local_var"       # 输出：空（局部变量不存在）
```

**💡 最佳实践**：
- 函数内的变量都用 `local` 声明
- 避免意外修改全局变量
- 通过返回值或echo返回结果

---

## 7. ▶️ 脚本执行方式


### 7.1 直接执行方式


**💡 通俗理解**：
脚本执行就像运行程序，有几种不同的"启动方式"。

**🔢 常用执行方式**：

1️⃣ **使用解释器执行**：
```bash
# 用bash解释器执行
bash script.sh

# 用sh执行（兼容性更好）
sh script.sh

# 指定其他解释器
python3 script.py
perl script.pl
```

2️⃣ **直接执行（需要可执行权限）**：
```bash
# 首先添加执行权限
chmod +x script.sh

# 然后直接执行
./script.sh

# 或者放在PATH路径中执行
script.sh
```

### 7.2 执行权限管理


**📋 权限设置详解**：

```bash
# 查看文件权限
ls -l script.sh
# -rw-r--r-- 1 user user 123 date script.sh

# 添加执行权限
chmod +x script.sh
# -rwxr-xr-x 1 user user 123 date script.sh

# 精确权限控制
chmod 755 script.sh    # 所有者可读写执行，其他人可读执行
chmod u+x script.sh    # 只给所有者添加执行权限
```

**⚠️ 重要提醒**：
> **shebang行的作用**  
> 脚本第一行的 `#!/bin/bash` 告诉系统用什么解释器执行
> ```bash
> #!/bin/bash
> echo "这是bash脚本"
> ```

### 7.3 脚本执行环境


**🔧 执行环境差异**：

| **执行方式** | **环境** | **变量继承** | **适用场景** |
|-------------|---------|-------------|-------------|
| `bash script.sh` | 子shell | 继承当前环境 | 调试、测试 |
| `./script.sh` | 子shell | 继承当前环境 | 正常执行 |
| `source script.sh` | 当前shell | 共享变量 | 环境设置 |
| `. script.sh` | 当前shell | 共享变量 | 环境设置 |

**📱 实际应用场景**：

```bash
# 环境配置脚本（需要在当前shell执行）
source ~/.bashrc       # 重新加载配置
. /etc/profile         # 系统环境设置

# 普通脚本（在子shell执行）
./backup.sh           # 执行备份脚本
bash deploy.sh        # 执行部署脚本
```

---

## 8. 🎯 退出状态管理


### 8.1 退出状态码概念


**💡 通俗理解**：
退出状态码就像考试成绩，告诉你程序执行得怎么样。

```
状态码含义：
0  = 成功（满分）
1-255 = 各种错误（不及格，数字越大问题越严重）

生活类比：
0 = "做得很好！"
1 = "有点小问题"
2 = "问题比较严重"
```

**📋 常见状态码**：

| **状态码** | **含义** | **示例场景** |
|-----------|---------|-------------|
| `0` | 成功 | 命令正常执行 |
| `1` | 一般性错误 | 文件不存在 |
| `2` | 误用shell命令 | 参数错误 |
| `126` | 命令无法执行 | 权限不够 |
| `127` | 命令未找到 | 命令不存在 |
| `128+n` | 致命错误 | 被信号n终止 |

### 8.2 $?变量使用


**🔢 基本使用**：

```bash
# 执行命令后立即检查状态
ls /tmp
echo "ls命令的退出状态: $?"

# 条件判断中使用
cp file1.txt file2.txt
if [ $? -eq 0 ]; then
    echo "复制成功"
else
    echo "复制失败"
fi
```

**🎯 实用模式**：

1️⃣ **命令成功性检查**：
```bash
# 方法1：使用$?
wget http://example.com/file.tar.gz
if [ $? -eq 0 ]; then
    echo "下载成功"
    tar -xzf file.tar.gz
else
    echo "下载失败，退出状态: $?"
fi

# 方法2：直接使用命令作为条件（推荐）
if wget http://example.com/file.tar.gz; then
    echo "下载成功"
    tar -xzf file.tar.gz
else
    echo "下载失败"
fi
```

2️⃣ **错误日志记录**：
```bash
backup_database() {
    mysqldump -u root -p database > backup.sql
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        echo "$(date): 数据库备份成功" >> backup.log
    else
        echo "$(date): 数据库备份失败，错误码: $exit_code" >> error.log
    fi
    
    return $exit_code
}
```

### 8.3 exit命令使用


**🔧 主动设置退出状态**：

```bash
#!/bin/bash

# 检查参数
if [ $# -eq 0 ]; then
    echo "错误：请提供文件名参数"
    exit 1    # 以状态码1退出
fi

filename="$1"

# 检查文件是否存在
if [ ! -f "$filename" ]; then
    echo "错误：文件 $filename 不存在"
    exit 2    # 以状态码2退出
fi

# 正常处理
echo "处理文件: $filename"
# ... 处理逻辑 ...

exit 0    # 成功退出
```

**💡 最佳实践**：
```bash
# 脚本开头设置错误处理
set -e    # 遇到错误立即退出
set -u    # 使用未定义变量时退出

# 或者使用函数统一处理错误
error_exit() {
    echo "错误: $1" >&2
    exit 1
}

# 使用示例
[ -f config.txt ] || error_exit "配置文件不存在"
```

---

## 9. 💼 实战应用案例


### 9.1 系统监控脚本


```bash
#!/bin/bash

# 系统健康检查脚本
system_health_check() {
    local report_file="/tmp/health_report_$(date +%Y%m%d_%H%M%S).txt"
    
    {
        echo "=== 系统健康检查报告 ==="
        echo "检查时间: $(date)"
        echo
        
        # 检查磁盘使用率
        echo "磁盘使用情况:"
        df -h | while read line; do
            usage=$(echo "$line" | awk '{print $5}' | sed 's/%//')
            if [[ "$usage" =~ ^[0-9]+$ ]] && [ "$usage" -gt 80 ]; then
                echo "警告: $line"
            else
                echo "$line"
            fi
        done
        
        echo
        
        # 检查内存使用
        echo "内存使用情况:"
        free -h
        
        echo
        
        # 检查CPU负载
        echo "CPU负载:"
        uptime
        
        # 检查重要服务状态
        echo
        echo "服务状态检查:"
        for service in ssh nginx mysql; do
            if systemctl is-active --quiet "$service" 2>/dev/null; then
                echo "$service: 运行中 ✓"
            else
                echo "$service: 未运行 ✗"
            fi
        done
        
    } | tee "$report_file"
    
    echo "报告已保存到: $report_file"
}

# 执行检查
system_health_check
```

### 9.2 批量文件处理脚本


```bash
#!/bin/bash

# 批量图片处理脚本
batch_process_images() {
    local source_dir="$1"
    local output_dir="$2"
    local operation="$3"  # resize, convert, compress
    
    # 参数检查
    [ $# -ne 3 ] && {
        echo "使用方法: $0 源目录 输出目录 操作类型"
        echo "操作类型: resize, convert, compress"
        exit 1
    }
    
    # 目录检查
    [ ! -d "$source_dir" ] && {
        echo "错误: 源目录不存在: $source_dir"
        exit 2
    }
    
    # 创建输出目录
    mkdir -p "$output_dir" || {
        echo "错误: 无法创建输出目录: $output_dir"
        exit 3
    }
    
    local processed=0
    local failed=0
    
    # 处理图片文件
    for img in "$source_dir"/*.{jpg,jpeg,png,gif}; do
        # 跳过不存在的文件（通配符未匹配时）
        [ ! -f "$img" ] && continue
        
        local filename=$(basename "$img")
        local output_file="$output_dir/$filename"
        
        echo "处理: $filename"
        
        case "$operation" in
            resize)
                convert "$img" -resize 800x600 "$output_file" && 
                ((processed++)) || ((failed++))
                ;;
            convert)
                convert "$img" "${output_file%.*}.jpg" && 
                ((processed++)) || ((failed++))
                ;;
            compress)
                convert "$img" -quality 85 "$output_file" && 
                ((processed++)) || ((failed++))
                ;;
            *)
                echo "错误: 未知操作类型: $operation"
                exit 4
                ;;
        esac
    done
    
    echo "处理完成: 成功 $processed 个, 失败 $failed 个"
}

# 脚本主逻辑
batch_process_images "$@"
```

### 9.3 自动化部署脚本


```bash
#!/bin/bash

# 应用自动化部署脚本
deploy_application() {
    local app_name="$1"
    local version="$2"
    local environment="$3"  # dev, staging, production
    
    # 配置参数
    local deploy_dir="/opt/apps/$app_name"
    local backup_dir="/backup/apps/$app_name"
    local log_file="/var/log/deploy_${app_name}_$(date +%Y%m%d_%H%M%S).log"
    
    # 日志函数
    log() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$log_file"
    }
    
    # 错误处理函数
    error_exit() {
        log "错误: $1"
        exit 1
    }
    
    log "开始部署 $app_name v$version 到 $environment 环境"
    
    # 1. 预检查
    log "执行预检查..."
    {
        # 检查磁盘空间
        local available_space=$(df "$deploy_dir" | awk 'NR==2 {print $4}')
        [ "$available_space" -lt 1000000 ] && error_exit "磁盘空间不足"
        
        # 检查依赖服务
        systemctl is-active --quiet nginx || error_exit "Nginx服务未运行"
        
        # 检查网络连接
        ping -c 1 google.com > /dev/null || log "警告: 外网连接异常"
        
    } && log "预检查通过" || error_exit "预检查失败"
    
    # 2. 创建备份
    log "创建当前版本备份..."
    if [ -d "$deploy_dir" ]; then
        local backup_name="backup_$(date +%Y%m%d_%H%M%S)"
        mkdir -p "$backup_dir" && 
        cp -r "$deploy_dir" "$backup_dir/$backup_name" &&
        log "备份创建成功: $backup_dir/$backup_name" ||
        error_exit "备份创建失败"
    fi
    
    # 3. 停止应用服务
    log "停止应用服务..."
    systemctl stop "$app_name" 2>/dev/null || log "服务可能未运行"
    
    # 4. 部署新版本
    log "部署新版本..."
    {
        mkdir -p "$deploy_dir"
        wget -O "/tmp/${app_name}-${version}.tar.gz" \
            "https://releases.example.com/$app_name/$version.tar.gz" &&
        tar -xzf "/tmp/${app_name}-${version}.tar.gz" -C "$deploy_dir" --strip-components=1 &&
        rm "/tmp/${app_name}-${version}.tar.gz"
    } && log "部署文件成功" || error_exit "部署文件失败"
    
    # 5. 配置应用
    log "更新应用配置..."
    {
        # 根据环境复制配置文件
        cp "$deploy_dir/config/${environment}.conf" "$deploy_dir/app.conf" &&
        # 设置权限
        chown -R www-data:www-data "$deploy_dir" &&
        chmod +x "$deploy_dir/bin/app"
    } && log "配置更新成功" || error_exit "配置更新失败"
    
    # 6. 启动服务
    log "启动应用服务..."
    systemctl start "$app_name" &&
    sleep 5 &&
    systemctl is-active --quiet "$app_name" &&
    log "服务启动成功" || error_exit "服务启动失败"
    
    # 7. 健康检查
    log "执行健康检查..."
    local max_attempts=10
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f -s "http://localhost:8080/health" > /dev/null; then
            log "健康检查通过"
            break
        else
            log "健康检查失败，重试 ($attempt/$max_attempts)"
            sleep 3
            ((attempt++))
        fi
    done
    
    [ $attempt -gt $max_attempts ] && error_exit "健康检查最终失败"
    
    log "部署成功完成！应用版本: $version"
    log "部署日志: $log_file"
}

# 参数验证
[ $# -ne 3 ] && {
    echo "使用方法: $0 应用名 版本号 环境"
    echo "环境选项: dev, staging, production"
    exit 1
}

# 执行部署
deploy_application "$@"
```

---

## 10. 📋 核心要点总结


### 10.1 命令连接操作符掌握要点


**🔸 核心记忆法**：
```
; = 无论如何都执行（顺序执行）
&& = 成功了才执行（条件执行）  
|| = 失败了才执行（失败执行）
& = 丢到后台执行（后台执行）
```

**🎯 使用原则**：
- **安全操作用&&**：`mkdir dir && cd dir`
- **容错处理用||**：`command || echo "失败了"`
- **批量任务用;**：`cmd1; cmd2; cmd3`
- **长任务用&**：`long_task.sh &`

### 10.2 后台执行与进程控制


**💡 关键理解**：
- `&` = 后台执行，但关闭终端会停止
- `nohup` = 持久执行，关闭终端也继续
- `jobs` = 查看后台任务
- `fg/bg` = 前后台切换

**⚠️ 重要提醒**：
> 使用nohup记得重定向输出：  
> `nohup command > output.log 2>&1 &`

### 10.3 条件判断最佳实践


**📊 测试选择指南**：

| **场景** | **推荐用法** | **理由** |
|---------|-------------|----------|
| **简单条件** | `[ ]` | 兼容性好，够用 |
| **复杂条件** | `[[ ]]` | 功能强大，支持模式匹配 |
| **数值比较** | `(( ))` | 算数表达式更直观 |
| **字符串操作** | `[[ ]]` | 支持通配符和正则 |

### 10.4 循环结构应用指南


**🔄 循环选择策略**：
- **已知列表** → 用 `for`
- **条件循环** → 用 `while`
- **等待某事** → 用 `until`

**💻 实用模板**：
```bash
# 处理文件列表
for file in *.txt; do
    [ -f "$file" ] && process_file "$file"
done

# 等待条件满足
while [ ! -f ready.flag ]; do
    sleep 1
done

# 服务监控
until service_is_ready; do
    echo "等待服务启动..."
    sleep 5
done
```

### 10.5 函数编写规范


**🔧 最佳实践**：
```bash
function_name() {
    # 1. 参数验证
    [ $# -eq 0 ] && { echo "需要参数"; return 1; }
    
    # 2. 局部变量声明
    local param1="$1"
    local param2="$2"
    
    # 3. 核心逻辑
    # ...
    
    # 4. 返回结果
    return 0
}
```

### 10.6 脚本执行与调试


**🎯 执行方式选择**：
- **调试阶段**：`bash -x script.sh`（显示执行过程）
- **正常执行**：`./script.sh`（需要可执行权限）
- **环境设置**：`source script.sh`（在当前shell执行）

**🔍 调试技巧**：
```bash
# 脚本开头添加
set -e  # 遇错即停
set -u  # 未定义变量报错
set -x  # 显示执行过程

# 或者组合使用
set -euxo pipefail
```

### 10.7 退出状态码管理


**📋 状态码使用规范**：
```bash
# 成功情况
exit 0

# 错误情况（自定义含义）
exit 1    # 一般错误
exit 2    # 参数错误
exit 3    # 文件错误
exit 4    # 权限错误
# ...

# 检查命令执行结果
command
case $? in
    0) echo "成功" ;;
    *) echo "失败，错误码: $?" ;;
esac
```

**🚀 核心记忆**：
- 命令连接是脚本化的基础，掌握&&、||、;的区别
- 后台执行用&，持久执行用nohup
- 条件判断优先用[[ ]]，简单情况用[ ]
- 循环结构要根据具体需求选择for、while、until
- 函数要用local声明局部变量
- 脚本要有合适的shebang和权限设置
- 善用退出状态码进行错误处理和流程控制