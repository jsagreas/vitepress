---
title: 9、文本处理基础命令
---
## 📚 目录

1. [文本处理基础概念](#1-文本处理基础概念)
2. [echo文本输出命令](#2-echo文本输出命令)
3. [printf格式化输出](#3-printf格式化输出)
4. [cut字段提取工具](#4-cut字段提取工具)
5. [sort排序命令](#5-sort排序命令)
6. [uniq去重处理](#6-uniq去重处理)
7. [tr字符转换工具](#7-tr字符转换工具)
8. [paste文件合并](#8-paste文件合并)
9. [tee输出分流](#9-tee输出分流)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📝 文本处理基础概念


### 1.1 什么是文本处理


**通俗理解**：文本处理就是对文字内容进行各种操作，就像我们在Word里编辑文档一样，只不过在Linux里是用命令来完成。

```
日常生活类比：
文本处理 = 文字编辑加工
- echo：相当于"说话"，把内容显示出来
- cut：相当于"剪刀"，从一行文字中剪出需要的部分
- sort：相当于"整理"，把乱序的内容按顺序排列
- paste：相当于"粘贴"，把多个文件的内容拼接起来
```

### 1.2 为什么需要文本处理命令


**实际用途**：
```
📋 日志分析：从系统日志中提取关键信息
📊 数据处理：处理CSV文件，提取特定列数据
🔍 文件整理：对文件列表进行排序和去重
📝 配置管理：批量修改配置文件内容
```

**核心价值**：
- **批量处理**：一次处理大量文本，节省时间
- **精确操作**：准确提取需要的信息
- **自动化**：配合脚本实现自动化处理
- **标准化**：统一的处理方式，结果可预期

---

## 2. 🔊 echo文本输出命令


### 2.1 echo基本概念


**简单理解**：`echo`就是让计算机"说话"的命令，它会把你告诉它的内容显示在屏幕上。

```bash
# 最基本的用法：让电脑说"你好"
echo "你好"
# 输出：你好

# 显示当前时间（配合其他命令）
echo "当前时间是: $(date)"
# 输出：当前时间是: Mon Jan 13 15:30:45 CST 2025
```

### 2.2 echo的常用选项


**🔸 -e选项：启用转义字符**

**什么是转义字符**：就是一些特殊的符号组合，用来表示换行、制表符等特殊效果。

```bash
# 普通输出（不处理转义字符）
echo "第一行\n第二行"
# 输出：第一行\n第二行

# 使用-e选项处理转义字符
echo -e "第一行\n第二行"
# 输出：
# 第一行
# 第二行
```

**常用转义字符速查**：
```
\n  - 换行（new line）
\t  - 制表符（tab）
\\  - 反斜杠本身
\"  - 双引号
\r  - 回车符
```

**实际应用示例**：
```bash
# 制作简单的菜单
echo -e "系统菜单：\n1. 查看磁盘\n2. 查看内存\n3. 退出"
# 输出：
# 系统菜单：
# 1. 查看磁盘
# 2. 查看内存
# 3. 退出
```

**🔸 -n选项：不换行输出**

**用途**：正常情况下echo输出后会自动换行，`-n`选项可以取消这个换行。

```bash
# 正常输出（自动换行）
echo "请输入："
echo "用户名"
# 输出：
# 请输入：
# 用户名

# 使用-n选项（不换行）
echo -n "请输入用户名："
echo "admin"
# 输出：请输入用户名：admin
```

### 2.3 echo的实际应用场景


**📝 写入文件**：
```bash
# 创建文件并写入内容
echo "Hello World" > hello.txt

# 追加内容到文件
echo "第二行内容" >> hello.txt
```

**🔧 配置文件修改**：
```bash
# 在配置文件末尾添加新配置
echo "export PATH=\$PATH:/usr/local/bin" >> ~/.bashrc
```

**📊 生成简单报告**：
```bash
# 生成系统信息报告
echo -e "系统报告\n=========="
echo "主机名: $(hostname)"
echo "当前用户: $(whoami)"
echo "系统时间: $(date)"
```

---

## 3. 📄 printf格式化输出


### 3.1 printf与echo的区别


**通俗理解**：
- **echo**：像平时说话一样，简单直接
- **printf**：像正式演讲一样，格式严谨，可以精确控制输出格式

```bash
# echo方式：简单粗暴
echo "姓名: 张三, 年龄: 25, 工资: 5000"

# printf方式：格式精美
printf "姓名: %-10s 年龄: %3d 工资: %8.2f\n" "张三" 25 5000
# 输出：姓名: 张三       年龄:  25 工资:  5000.00
```

### 3.2 printf格式说明符


**🔸 基本格式说明符**：

```
%s  - 字符串（string）
%d  - 整数（decimal）
%f  - 浮点数（float）
%c  - 单个字符（character）
%%  - 百分号本身
```

**实际示例**：
```bash
# 字符串格式化
printf "用户名：%s\n" "admin"
# 输出：用户名：admin

# 数字格式化
printf "数量：%d个\n" 100
# 输出：数量：100个

# 小数格式化
printf "价格：%.2f元\n" 29.9
# 输出：价格：29.90元
```

**🔸 宽度和对齐控制**：

```bash
# 右对齐（默认）
printf "姓名：%10s|\n" "张三"
# 输出：姓名：        张三|

# 左对齐（加负号）
printf "姓名：%-10s|\n" "张三"
# 输出：姓名：张三        |

# 数字补零
printf "编号：%05d\n" 123
# 输出：编号：00123
```

### 3.3 printf实际应用


**📊 制作报表**：
```bash
# 制作整齐的表格
printf "%-10s %8s %12s\n" "姓名" "年龄" "工资"
printf "%-10s %8d %12.2f\n" "张三" 25 5500.50
printf "%-10s %8d %12.2f\n" "李四" 30 8000.00
# 输出：
# 姓名          年龄         工资
# 张三            25      5500.50
# 李四            30      8000.00
```

**📝 生成配置文件**：
```bash
# 生成统一格式的配置项
printf "server_name=%s\n" "web01"
printf "port=%d\n" 8080
printf "max_connections=%d\n" 1000
```

---

## 4. ✂️ cut字段提取工具


### 4.1 cut命令的作用


**通俗理解**：`cut`命令就像一把剪刀，可以从一行文字中剪出你需要的部分。

```
生活中的类比：
从地址"北京市朝阳区建国路100号"中：
- 只要省份：北京市
- 只要区县：朝阳区  
- 只要街道：建国路
- 只要门牌号：100号

cut命令就是用来做这种"精确切割"的工具
```

### 4.2 -d分隔符选项


**基本语法**：`cut -d'分隔符' -f字段号 文件名`

**🔸 处理以特定字符分隔的数据**：

```bash
# 创建测试数据
echo "张三,25,北京,工程师" > users.txt
echo "李四,30,上海,设计师" >> users.txt
echo "王五,28,广州,产品经理" >> users.txt

# 提取姓名（第1个字段）
cut -d',' -f1 users.txt
# 输出：
# 张三
# 李四
# 王五

# 提取年龄（第2个字段）
cut -d',' -f2 users.txt
# 输出：
# 25
# 30
# 28
```

**🔸 提取多个字段**：

```bash
# 提取姓名和城市（第1和第3字段）
cut -d',' -f1,3 users.txt
# 输出：
# 张三,北京
# 李四,上海
# 王五,广州

# 提取第2到第4字段
cut -d',' -f2-4 users.txt
# 输出：
# 25,北京,工程师
# 30,上海,设计师
# 28,广州,产品经理
```

### 4.3 实际应用场景


**📋 处理系统文件**：
```bash
# 从/etc/passwd中提取用户名
cut -d':' -f1 /etc/passwd | head -5
# 输出：
# root
# bin
# daemon
# adm
# lp

# 提取用户名和登录shell
cut -d':' -f1,7 /etc/passwd | head -3
# 输出：
# root:/bin/bash
# bin:/sbin/nologin
# daemon:/sbin/nologin
```

**📊 处理日志文件**：
```bash
# 假设日志格式：时间|级别|消息
echo "2025-01-13 10:30:25|INFO|用户登录成功" > app.log
echo "2025-01-13 10:31:10|ERROR|数据库连接失败" >> app.log

# 只提取时间和消息
cut -d'|' -f1,3 app.log
# 输出：
# 2025-01-13 10:30:25|用户登录成功
# 2025-01-13 10:31:10|数据库连接失败
```

**💡 实用技巧**：
```bash
# 处理空格分隔的数据（如ps命令输出）
ps aux | cut -d' ' -f1,11- | head -3
# 提取用户名和命令行

# 配合管道处理复杂数据
cat /etc/passwd | cut -d':' -f1,5 | grep -v "^$"
# 提取用户名和描述信息，过滤空行
```

---

## 5. 🔢 sort排序命令


### 5.1 sort基本概念


**通俗理解**：`sort`就是整理数据的工具，就像把一堆乱放的文件按照名字排序一样。

```
日常生活类比：
sort命令 = 图书管理员整理书籍
- 按字母顺序排列
- 按数字大小排列  
- 可以正序或倒序
```

**基本用法**：
```bash
# 创建测试数据
echo -e "香蕉\n苹果\n橙子\n葡萄" > fruits.txt

# 基本排序（按字母顺序）
sort fruits.txt
# 输出：
# 橙子
# 苹果
# 葡萄
# 香蕉
```

### 5.2 -n数值排序


**🔸 为什么需要-n选项**：

```bash
# 创建数字数据
echo -e "100\n20\n3\n1000" > numbers.txt

# 普通排序（按字符排序）
sort numbers.txt
# 输出：
# 100
# 1000
# 20
# 3

# 数值排序（按数字大小排序）
sort -n numbers.txt
# 输出：
# 3
# 20
# 100
# 1000
```

**为什么会这样**：
- **普通排序**：按字符比较，"1"比"2"小，所以"100"排在"20"前面
- **数值排序**：按实际数字大小比较，3 < 20 < 100 < 1000

### 5.3 -r逆序排列


**🔸 倒序排列**：

```bash
# 正序排列
sort -n numbers.txt
# 输出：3, 20, 100, 1000

# 倒序排列
sort -nr numbers.txt  
# 输出：1000, 100, 20, 3
```

**实际应用**：
```bash
# 找出最大的文件
ls -l | sort -k5 -nr | head -5
# 按文件大小倒序排列，显示前5个最大文件
```

### 5.4 -k指定键（排序字段）


**🔸 按指定字段排序**：

```bash
# 创建员工数据
cat > employees.txt << EOF
张三 25 5500
李四 30 8000  
王五 28 6200
赵六 35 9500
EOF

# 按年龄排序（第2列）
sort -k2 -n employees.txt
# 输出：
# 张三 25 5500
# 王五 28 6200
# 李四 30 8000
# 赵六 35 9500

# 按工资排序（第3列）
sort -k3 -nr employees.txt
# 输出：
# 赵六 35 9500
# 李四 30 8000
# 王五 28 6200
# 张三 25 5500
```

### 5.5 sort实际应用


**📊 日志分析**：
```bash
# 按访问次数排序网站日志
cat access.log | cut -d' ' -f1 | sort | uniq -c | sort -nr
# 统计IP访问次数，按访问量倒序
```

**📋 系统管理**：
```bash
# 按内存使用量排序进程
ps aux | sort -k4 -nr | head -10
# 显示内存使用最多的10个进程

# 按文件大小排序
du -h * | sort -hr
# 显示目录下文件大小，按大小倒序
```

---

## 6. 🔄 uniq去重处理


### 6.1 uniq基本概念


**通俗理解**：`uniq`就是"去重复"的工具，把重复出现的行变成只出现一次。

```
生活类比：
uniq = 整理重复的物品
- 把重复的照片只保留一张
- 把重复的联系人合并
- 统计有多少个重复项
```

**重要提醒**：uniq只能处理**相邻**的重复行，所以通常需要先用sort排序。

### 6.2 基本去重功能


```bash
# 创建有重复内容的文件
cat > duplicates.txt << EOF
苹果
香蕉
苹果
橙子
香蕉
苹果
EOF

# 直接使用uniq（只能去除相邻重复）
uniq duplicates.txt
# 输出：
# 苹果
# 香蕉
# 苹果
# 橙子
# 香蕉
# 苹果

# 先排序再去重（推荐做法）
sort duplicates.txt | uniq
# 输出：
# 橙子
# 苹果
# 香蕉
```

### 6.3 -c计数选项


**🔸 统计重复次数**：

```bash
# 统计每种水果出现的次数
sort duplicates.txt | uniq -c
# 输出：
#       1 橙子
#       3 苹果  
#       2 香蕉

# 按出现次数排序
sort duplicates.txt | uniq -c | sort -nr
# 输出：
#       3 苹果
#       2 香蕉
#       1 橙子
```

### 6.4 uniq实际应用


**📊 日志分析**：
```bash
# 统计网站访问最多的IP
cat access.log | cut -d' ' -f1 | sort | uniq -c | sort -nr | head -10
# 提取IP → 排序 → 去重计数 → 按次数排序 → 显示前10
```

**📝 数据清理**：
```bash
# 清理邮件列表中的重复邮箱
cat email_list.txt | sort | uniq > clean_emails.txt

# 找出重复的文件名
ls -1 | sort | uniq -d  # -d选项只显示重复的行
```

**🔍 系统管理**：
```bash
# 统计系统中不同的shell类型
cut -d':' -f7 /etc/passwd | sort | uniq -c
# 输出各种shell的使用数量
```

---

## 7. 🔄 tr字符转换工具


### 7.1 tr基本概念


**通俗理解**：`tr`就是"翻译"工具，可以把文本中的某些字符替换成其他字符。

```
生活类比：
tr = 查找替换功能
- 把所有"A"替换成"B"  
- 把大写字母变成小写字母
- 删除不需要的字符
```

**基本语法**：`tr '原字符' '新字符'`

### 7.2 字符替换功能


**🔸 基本替换**：

```bash
# 把所有的a替换成A
echo "banana" | tr 'a' 'A'
# 输出：bAnAnA

# 把多个字符同时替换
echo "hello world" | tr 'lo' 'LO'
# 输出：heLLO wOrLd
```

**🔸 大小写转换**：

```bash
# 小写转大写
echo "Hello World" | tr 'a-z' 'A-Z'
# 输出：HELLO WORLD

# 大写转小写
echo "Hello World" | tr 'A-Z' 'a-z'  
# 输出：hello world

# 使用预定义字符集（推荐）
echo "Hello World" | tr '[:lower:]' '[:upper:]'
# 输出：HELLO WORLD
```

### 7.3 删除字符功能


**🔸 使用-d选项删除字符**：

```bash
# 删除所有数字
echo "abc123def456" | tr -d '0-9'
# 输出：abcdef

# 删除空格
echo "hello world" | tr -d ' '
# 输出：helloworld

# 删除特定字符
echo "a,b,c,d" | tr -d ','
# 输出：abcd
```

### 7.4 字符集合替换


**🔸 常用字符集**：

```
[:alnum:]  - 字母和数字
[:alpha:]  - 字母
[:digit:]  - 数字  
[:lower:]  - 小写字母
[:upper:]  - 大写字母
[:space:]  - 空白字符
[:punct:]  - 标点符号
```

**实际应用**：
```bash
# 把所有标点符号替换成空格
echo "hello,world!how are you?" | tr '[:punct:]' ' '
# 输出：hello world how are you 

# 压缩连续的空格为单个空格
echo "hello    world" | tr -s ' '
# 输出：hello world
```

### 7.5 tr实际应用场景


**📝 文本格式化**：
```bash
# 把Windows格式的文本转换为Unix格式（删除回车符）
tr -d '\r' < windows_file.txt > unix_file.txt

# 把制表符替换为空格
cat file.txt | tr '\t' ' '
```

**🔒 简单加密**：
```bash
# ROT13加密（字母向后移13位）
echo "hello" | tr 'a-zA-Z' 'n-za-mN-ZA-M'
# 输出：uryyb
```

**📊 数据清理**：
```bash
# 统一电话号码格式（删除所有非数字字符）
echo "136-8888-9999" | tr -d '-'
# 输出：13688889999
```

---

## 8. 📋 paste文件合并


### 8.1 paste基本概念


**通俗理解**：`paste`就像胶水一样，可以把多个文件的内容按行粘贴在一起。

```
办公类比：
paste = Excel中的合并列功能
- 把A文件的每一行和B文件的每一行拼接
- 可以自定义连接符号
- 适合处理表格数据
```

### 8.2 基本文件合并


```bash
# 创建两个测试文件
echo -e "张三\n李四\n王五" > names.txt
echo -e "25\n30\n28" > ages.txt

# 基本合并（默认用制表符分隔）
paste names.txt ages.txt
# 输出：
# 张三	25
# 李四	30  
# 王五	28
```

**🔸 自定义分隔符**：

```bash
# 使用逗号作为分隔符
paste -d',' names.txt ages.txt
# 输出：
# 张三,25
# 李四,30
# 王五,28

# 使用空格作为分隔符
paste -d' ' names.txt ages.txt
# 输出：
# 张三 25
# 李四 30
# 王五 28
```

### 8.3 合并多个文件


```bash
# 创建第三个文件
echo -e "北京\n上海\n广州" > cities.txt

# 合并三个文件
paste -d',' names.txt ages.txt cities.txt
# 输出：
# 张三,25,北京
# 李四,30,上海
# 王五,28,广州
```

### 8.4 paste实际应用


**📊 制作报表**：
```bash
# 创建完整的员工信息表
echo -e "工程师\n设计师\n产品经理" > jobs.txt

# 生成最终报表
paste -d'|' names.txt ages.txt cities.txt jobs.txt
# 输出：
# 张三|25|北京|工程师
# 李四|30|上海|设计师  
# 王五|28|广州|产品经理
```

**📝 配置文件生成**：
```bash
# 批量生成用户配置
echo -e "user1\nuser2\nuser3" > usernames.txt
echo -e "pass1\npass2\npass3" > passwords.txt

paste -d':' usernames.txt passwords.txt > user_config.txt
# 生成：user1:pass1 格式的配置文件
```

---

## 9. 🔀 tee输出分流


### 9.1 tee基本概念


**通俗理解**：`tee`就像水管的三通接头，可以让水流向两个方向。在命令行中，它可以让输出同时显示在屏幕上和保存到文件里。

```
生活类比：
tee = 复印机
- 原件显示在屏幕上（给人看）
- 复印件保存到文件（留档案）
- 一次操作，两份结果
```

### 9.2 基本分流功能


```bash
# 基本用法：既显示又保存
echo "重要信息" | tee important.txt
# 效果：
# 1. 屏幕显示：重要信息  
# 2. 同时保存到important.txt文件

# 查看文件确认保存成功
cat important.txt
# 输出：重要信息
```

**🔸 追加模式**：

```bash
# 使用-a选项追加到文件（而不是覆盖）
echo "第一条信息" | tee log.txt
echo "第二条信息" | tee -a log.txt  # 追加模式

# 查看完整内容
cat log.txt
# 输出：
# 第一条信息
# 第二条信息
```

### 9.3 同时输出到多个文件


```bash
# 同时保存到多个文件
echo "系统备份完成" | tee backup.log system.log admin.log
# 效果：
# 1. 屏幕显示信息
# 2. 同时保存到三个不同的日志文件
```

### 9.4 tee实际应用场景


**📊 系统监控**：
```bash
# 实时监控系统负载，同时记录到日志
uptime | tee -a system_load.log
# 既能立即看到结果，又能保存历史记录
```

**🔧 脚本调试**：
```bash
# 在复杂的管道命令中查看中间结果
cat data.txt | sort | tee sorted_data.txt | uniq -c | tee count_result.txt
# 可以检查每一步的处理结果
```

**📝 命令记录**：
```bash
# 记录重要命令的执行结果
ps aux | grep mysql | tee mysql_processes.txt
# 既能查看当前MySQL进程，又能保存快照
```

**💾 备份和监控**：
```bash
# 数据库备份时记录过程
mysqldump database_name | tee backup_$(date +%Y%m%d).sql
# 既能监控备份进度，又能保存备份文件
```

---

## 10. 📋 核心要点总结


### 10.1 命令功能速查表


| 命令 | **核心作用** | **常用选项** | **典型应用** |
|------|-------------|-------------|-------------|
| 🔊 **echo** | `文本输出显示` | `-e`转义 `-n`不换行 | `消息提示` `文件写入` |
| 📄 **printf** | `格式化输出` | `%s %d %f` | `报表制作` `格式规整` |
| ✂️ **cut** | `字段提取` | `-d`分隔符 `-f`字段号 | `数据提取` `日志分析` |
| 🔢 **sort** | `数据排序` | `-n`数值 `-r`倒序 `-k`指定列 | `数据整理` `排名统计` |
| 🔄 **uniq** | `去重处理` | `-c`计数 | `数据清理` `统计分析` |
| 🔄 **tr** | `字符转换` | `-d`删除 `[:class:]`字符集 | `格式转换` `文本清理` |
| 📋 **paste** | `文件合并` | `-d`分隔符 | `表格合并` `数据拼接` |
| 🔀 **tee** | `输出分流` | `-a`追加 | `日志记录` `调试监控` |

### 10.2 组合使用的经典模式


**🔍 日志分析经典组合**：
```bash
# 分析访问日志：提取IP → 排序 → 去重计数 → 按次数排序
cat access.log | cut -d' ' -f1 | sort | uniq -c | sort -nr | head -10
```

**📊 数据处理经典组合**：
```bash  
# 处理CSV数据：提取字段 → 排序 → 去重 → 保存结果
cut -d',' -f1,3 data.csv | sort | uniq | tee result.txt
```

**📝 系统信息收集**：
```bash
# 生成系统报告：格式化输出 → 同时保存
printf "系统报告 - %s\n" "$(date)" | tee system_report.txt
ps aux | sort -k4 -nr | head -5 | tee -a system_report.txt
```

### 10.3 学习要点梳理


**🎯 掌握标准**：
```
✅ 理解每个命令的核心作用和适用场景
✅ 熟练使用常见选项和参数组合  
✅ 能够将多个命令组合解决实际问题
✅ 掌握在脚本中使用这些命令的方法
```

**💡 实用技巧**：
```
🔸 大部分文本处理都可以用管道连接多个命令
🔸 处理数据前先用head查看格式，避免处理错误
🔸 使用tee在复杂管道中保存中间结果便于调试
🔸 sort和uniq组合是数据去重的标准做法
🔸 printf比echo更适合格式化输出
```

**⚠️ 常见陷阱**：
```
🚫 uniq只能处理相邻重复行，使用前要先sort
🚫 cut处理空格分隔数据时要注意连续空格问题
🚫 sort默认按字符排序，数字排序要用-n选项
🚫 tr只能处理单个字符，不能处理字符串
```

### 10.4 进阶学习方向


**🚀 扩展命令**：
- `awk`：更强大的文本处理工具
- `sed`：流式文本编辑器
- `grep`：文本搜索和过滤
- `xargs`：参数传递工具

**📚 应用领域**：
- **日志分析**：系统日志、应用日志、访问日志处理
- **数据处理**：CSV文件处理、报表生成
- **系统管理**：批量配置、监控脚本
- **自动化运维**：数据清洗、格式转换

**核心记忆口诀**：
- echo输出printf格式，cut提取sort排序
- uniq去重tr转换，paste合并tee分流
- 管道连接解决问题，文本处理效率高