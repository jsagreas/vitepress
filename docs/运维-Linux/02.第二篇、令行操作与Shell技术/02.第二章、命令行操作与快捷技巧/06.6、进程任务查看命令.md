---
title: 6、进程任务查看命令
---
## 📚 目录

1. [进程基础概念](#1-进程基础概念)
2. [ps命令详解](#2-ps命令详解)
3. [pgrep和pkill命令](#3-pgrep和pkill命令)
4. [top和htop实时监控](#4-top和htop实时监控)
5. [任务控制命令](#5-任务控制命令)
6. [进程终止命令](#6-进程终止命令)
7. [进程树显示](#7-进程树显示)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🖥️ 进程基础概念


### 1.1 什么是进程


💭 **简单理解**：进程就是正在运行的程序

```
生活中的类比：
程序 = 菜谱（静态的文档）
进程 = 正在做菜的过程（动态的活动）

一份菜谱可以同时有多个人在做菜
一个程序也可以同时运行多个进程
```

🏷️ **专业术语**：`进程（Process）` = 操作系统中正在执行的程序实例

### 1.2 进程的重要属性


**🔍 每个进程都有的身份证信息**：
- **PID**：进程ID号，每个进程的唯一标识
- **PPID**：父进程ID，创建这个进程的进程ID
- **UID**：运行进程的用户ID
- **状态**：进程当前在做什么（运行、睡眠、停止等）

```
进程状态说明：
R (Running)     : 正在运行或等待运行
S (Sleeping)    : 可中断的睡眠状态  
D (Disk Sleep)  : 不可中断睡眠（通常是等待I/O）
Z (Zombie)      : 僵尸进程（已结束但未被回收）
T (Stopped)     : 已停止的进程
```

---

## 2. 🔍 ps命令详解


### 2.1 ps命令基础


🎯 **核心作用**：`ps`命令用来查看当前系统中运行的进程

🌰 **最简单的使用**：
```bash
# 查看当前终端的进程
ps
```

### 2.2 ps aux - 最常用的查看方式


**💡 记忆技巧**：`aux` = **A**ll **U**sers e**X**tended

```bash
# 查看所有用户的所有进程，显示详细信息
ps aux
```

**📋 输出格式解读**：
```
USER       PID  %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1   0.0  0.1  19356  1464 ?        Ss   10:30   0:01 /sbin/init
user      1234   2.5  5.2 459652 53248 pts/0    S+   10:35   0:15 firefox
```

🔢 **各列含义详解**：
- **USER**: 运行进程的用户名
- **PID**: 进程ID号
- **%CPU**: CPU使用率百分比
- **%MEM**: 内存使用率百分比
- **VSZ**: 虚拟内存大小（KB）
- **RSS**: 实际物理内存大小（KB）
- **TTY**: 关联的终端
- **STAT**: 进程状态
- **START**: 进程启动时间
- **TIME**: CPU累计使用时间
- **COMMAND**: 启动进程的完整命令

### 2.3 ps -ef - 另一种常用格式


```bash
# System V风格的进程显示
ps -ef
```

**🔄 两种格式对比**：

| 参数 | 风格 | 特点 | 适用场景 |
|------|------|------|----------|
| `aux` | **BSD风格** | 显示资源使用情况 | 查看进程性能 |
| `-ef` | **System V风格** | 显示进程层次关系 | 查看进程树结构 |

### 2.4 ps命令实用技巧


**🔍 常用过滤操作**：
```bash
# 查找特定进程
ps aux | grep firefox

# 查看特定用户的进程
ps -u username

# 按CPU使用率排序
ps aux --sort=-%cpu

# 按内存使用率排序
ps aux --sort=-%mem
```

---

## 3. 🎯 pgrep和pkill命令


### 3.1 pgrep - 按名称查找进程


🏷️ **专业术语**：`pgrep` = **P**rocess **GREP**，通过进程名查找PID

**💭 为什么需要pgrep**：
```bash
# 传统方法：复杂且容易出错
ps aux | grep firefox | grep -v grep | awk '{print $2}'

# pgrep方法：简洁明了
pgrep firefox
```

**🌰 基础用法**：
```bash
# 查找进程名包含firefox的所有PID
pgrep firefox

# 显示进程名和PID
pgrep -l firefox

# 查找特定用户的进程
pgrep -u username firefox
```

### 3.2 pkill - 按名称终止进程


🏷️ **专业术语**：`pkill` = **P**rocess **KILL**，通过进程名终止进程

**⚡ 基础用法**：
```bash
# 终止名称包含firefox的所有进程
pkill firefox

# 向进程发送特定信号
pkill -TERM firefox

# 只终止特定用户的进程
pkill -u username firefox
```

**🚨 重要提醒**：使用pkill要格外小心，确保不会误杀重要进程

---

## 4. 📊 top和htop实时监控


### 4.1 top命令 - 动态进程查看器


🎯 **核心作用**：实时显示系统中进程的运行状态

**💡 启动方式**：
```bash
# 启动top
top

# 每2秒更新一次
top -d 2

# 只显示特定用户的进程
top -u username
```

**📊 top界面解读**：
```
top - 14:30:25 up 2:15, 1 user, load average: 0.15, 0.20, 0.18
Tasks: 125 total, 1 running, 124 sleeping, 0 stopped, 0 zombie
%Cpu(s): 2.1 us, 1.2 sy, 0.0 ni, 96.5 id, 0.2 wa, 0.0 hi, 0.0 si, 0.0 st
KiB Mem: 2048576 total, 1024288 used, 1024288 free, 102400 buffers
KiB Swap: 1048576 total, 0 used, 1048576 free, 512000 cached

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 1234 user      20   0  459652  53248  12345 S   5.2  2.6   0:15.23 firefox
```

🔢 **关键信息理解**：
- **load average**: 系统负载（1分钟、5分钟、15分钟平均值）
- **Tasks**: 进程总数和状态统计
- **%Cpu(s)**: CPU使用情况
- **Mem/Swap**: 内存和交换分区使用情况

**⌨️ top交互快捷键**：
- `q`: 退出top
- `h`: 显示帮助
- `k`: 终止进程（输入PID）
- `M`: 按内存使用率排序
- `P`: 按CPU使用率排序

### 4.2 htop - 增强版的top


🌟 **htop的优势**：
- 彩色显示，界面更友好
- 支持鼠标操作
- 可以横向滚动查看完整命令
- 树状显示进程关系

```bash
# 安装htop（如果没有）
sudo apt install htop    # Ubuntu/Debian
sudo yum install htop    # CentOS/RHEL

# 运行htop
htop
```

---

## 5. 🔄 任务控制命令


### 5.1 jobs - 查看作业列表


🏷️ **专业术语**：`作业（Job）` = 在shell中启动的进程组

**💭 理解作业概念**：
```
当你在终端运行命令时：
firefox &          # 后台作业
vim file.txt        # 前台作业（会占用终端）
```

**📋 jobs基本用法**：
```bash
# 查看当前shell的所有作业
jobs

# 显示作业PID
jobs -p

# 显示详细信息
jobs -l
```

**🔢 jobs输出格式**：
```
[1]+  Running    firefox &
[2]-  Stopped    vim file.txt
```
- `[1]`: 作业编号
- `+`: 当前作业
- `-`: 上一个作业
- `Running/Stopped`: 作业状态

### 5.2 bg和fg - 前后台切换


**💡 典型使用场景**：
```
你正在编辑文件时，突然需要运行其他命令：
1. 按 Ctrl+Z 暂停当前任务
2. 运行其他命令
3. 用 fg 回到原来的任务
```

**⚡ 基本操作**：
```bash
# 启动一个前台任务
vim file.txt

# 按 Ctrl+Z 暂停任务

# 将暂停的任务放到后台运行
bg

# 将后台任务调到前台
fg

# 操作特定作业编号
bg %1    # 将作业1放到后台
fg %2    # 将作业2调到前台
```

### 5.3 nohup - 忽略挂断信号


🎯 **解决的问题**：当你退出终端时，正在运行的程序会被终止

🏷️ **专业术语**：`nohup` = **NO** **H**ang**UP**，忽略挂断信号

**🌰 典型使用场景**：
```bash
# 启动一个长时间运行的任务，退出终端后继续运行
nohup python long_script.py &

# 输出会重定向到nohup.out文件
nohup python script.py > output.log 2>&1 &
```

**🔍 命令解析**：
- `nohup`: 忽略挂断信号
- `&`: 放到后台运行
- `> output.log`: 重定向标准输出
- `2>&1`: 重定向错误输出到标准输出

---

## 6. ⚡ 进程终止命令


### 6.1 kill命令详解


🎯 **核心作用**：向进程发送信号，通常用于终止进程

**💭 理解信号概念**：
```
信号就像是给进程发短信：
TERM信号：礼貌地请求进程退出
KILL信号：强制立即终止进程
```

**📋 常用信号类型**：

| 信号名 | 信号号 | 含义 | 进程能否忽略 |
|-------|--------|------|-------------|
| **TERM** | 15 | 请求正常终止 | ✅ 可以忽略 |
| **KILL** | 9 | 强制终止 | ❌ 不能忽略 |
| **HUP** | 1 | 挂断信号 | ✅ 可以忽略 |
| **STOP** | 19 | 暂停进程 | ❌ 不能忽略 |
| **CONT** | 18 | 继续进程 | ❌ 不能忽略 |

**⚡ 基本使用方法**：
```bash
# 正常终止进程（默认发送TERM信号）
kill 1234

# 强制终止进程
kill -9 1234
kill -KILL 1234

# 重启进程（常用于重载配置）
kill -HUP 1234

# 暂停进程
kill -STOP 1234

# 继续进程
kill -CONT 1234
```

### 6.2 killall命令


🏷️ **专业术语**：`killall` = 通过进程名批量终止进程

**🌰 实际应用**：
```bash
# 终止所有firefox进程
killall firefox

# 强制终止所有firefox进程
killall -9 firefox

# 只终止特定用户的进程
killall -u username firefox
```

**🚨 重要提醒**：
```
使用killall要非常小心！
killall init    # 这会导致系统崩溃
killall bash    # 这会关闭所有bash终端
```

### 6.3 信号使用建议


**✅ 推荐的终止进程流程**：
```bash
# 1. 首先尝试礼貌终止
kill 1234

# 2. 等待几秒钟，检查进程是否还存在
ps -p 1234

# 3. 如果还存在，强制终止
kill -9 1234
```

**💡 为什么要先用TERM信号**：
- 允许进程清理临时文件
- 保存未完成的工作
- 正确关闭网络连接
- 释放系统资源

---

## 7. 🌳 进程树显示


### 7.1 pstree命令


🎯 **核心作用**：以树形结构显示进程的父子关系

**💭 理解进程树概念**：
```
进程就像家族族谱：
init(1)                 # 祖先进程（PID 1）
├─systemd---(...)       # 子进程
├─NetworkManager        # 子进程
└─bash(1234)           # shell进程
  ├─firefox(2345)       # firefox主进程
  │ ├─{firefox}(2346)   # firefox线程
  │ └─{firefox}(2347)   # firefox线程
  └─vim(2348)           # vim编辑器
```

**⚡ 基本用法**：
```bash
# 显示完整的进程树
pstree

# 显示进程ID
pstree -p

# 显示特定用户的进程树
pstree -u username

# 从特定进程开始显示子树
pstree -p 1234
```

### 7.2 ps命令显示进程树


```bash
# 使用ps显示进程层次关系
ps -ef --forest

# 或者使用axjf参数
ps axjf
```

**🔍 进程树的实际意义**：
- **理解进程关系**：知道哪个进程启动了哪个进程
- **故障排查**：找到问题进程的源头
- **资源管理**：终止父进程会影响所有子进程

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心命令


```
🔸 ps aux：查看所有进程详细信息（最常用）
🔸 ps -ef：查看进程层次关系
🔸 pgrep：根据进程名查找PID
🔸 pkill：根据进程名终止进程
🔸 top：实时监控系统进程
🔸 jobs：查看当前作业列表
🔸 bg/fg：前后台任务切换
🔸 nohup：创建不受终端关闭影响的进程
🔸 kill：向进程发送信号（通常用于终止）
🔸 killall：批量终止同名进程
🔸 pstree：显示进程树结构
```

### 8.2 关键概念理解


**🔹 进程基础概念**
```
进程 = 正在运行的程序
PID = 进程的身份证号码
PPID = 进程的父进程ID
进程状态：运行、睡眠、停止、僵尸
```

**🔹 任务控制概念**
```
前台任务：占用终端，接收键盘输入
后台任务：不占用终端，在后台运行
作业：shell中管理的进程组
nohup：让进程不受终端关闭影响
```

**🔹 信号机制理解**
```
TERM(15)：礼貌地请求进程退出
KILL(9)：强制立即终止进程
优先使用TERM，必要时使用KILL
```

### 8.3 实际应用价值


**🎯 日常使用场景**：
- **系统监控**：用`top`查看系统负载和进程资源使用
- **进程管理**：用`ps aux`查找特定进程
- **故障排查**：用`pstree`理解进程关系
- **任务管理**：用`nohup`运行长期任务
- **进程清理**：用`kill/killall`清理无响应进程

**🛠️ 运维实践**：
- **服务器监控**：定期检查进程状态和资源使用
- **问题排查**：通过进程信息定位系统问题
- **性能优化**：识别消耗资源过多的进程
- **安全管理**：监控异常进程和可疑活动

**💡 学习建议**：
- 从`ps aux`开始，这是最实用的命令
- 练习使用`top`来理解系统资源使用情况
- 掌握`kill`信号的正确使用方法
- 学会用`nohup`管理长期运行的任务

**🎪 记忆技巧**：
- **ps aux**：All Users eXtended（所有用户扩展信息）
- **pgrep/pkill**：Process GREP/KILL（进程查找/终止）
- **nohup**：NO HangUP（不挂断）
- **fg/bg**：ForeGround/BackGround（前台/后台）

**核心记忆**：
- 进程管理从查看开始，ps aux是基础
- 任务控制要会前后台切换，nohup保持运行
- 进程终止要礼貌优先，TERM信号先于KILL
- 系统监控用top实时看，pstree显示进程关系树