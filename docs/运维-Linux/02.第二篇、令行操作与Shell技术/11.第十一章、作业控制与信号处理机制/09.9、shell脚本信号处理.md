---
title: 9、shell脚本信号处理
---
## 📚 目录

1. [信号处理基础概念](#1-信号处理基础概念)
2. [trap命令详解](#2-trap命令详解)
3. [常用信号类型处理](#3-常用信号类型处理)
4. [实际应用场景](#4-实际应用场景)
5. [信号处理最佳实践](#5-信号处理最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 信号处理基础概念


### 1.1 什么是信号


**🔸 信号的本质**
信号就像生活中的通知消息，当系统或用户想要告诉正在运行的程序"发生了什么事"时，就会发送信号。

```
生活中的例子：                 Linux信号：
门铃响了 → 有客人来访           SIGINT → 用户按Ctrl+C
闹钟响了 → 该起床了            SIGALRM → 定时器到期
电话响了 → 有人打电话           SIGTERM → 系统要关闭程序
```

**🔸 信号的作用**
- **通知程序**：告诉程序发生了什么情况
- **控制程序**：让程序执行特定的操作
- **清理资源**：程序结束前做收尾工作

### 1.2 为什么需要信号处理


> 💡 **核心理解**  
> 想象你在做饭，突然有人敲门。如果你不处理这个"信号"，可能会错过重要的事情；但如果处理得当，你可以先关火再去开门，避免烧焦食物。

**🔸 不处理信号的问题**
```bash
# 没有信号处理的脚本
#!/bin/bash
while true; do
    echo "工作中..." >> /tmp/work.log
    sleep 1
done
```

当用户按 `Ctrl+C` 时，脚本直接退出，可能导致：
- 临时文件没有清理
- 数据没有保存
- 资源没有释放

### 1.3 常见信号类型


| 信号名称 | **编号** | **默认行为** | **通俗含义** | **能否捕获** |
|---------|---------|-------------|-------------|-------------|
| `SIGINT` | `2` | `终止程序` | `Ctrl+C，用户中断` | `✅ 可以` |
| `SIGTERM` | `15` | `终止程序` | `礼貌地请求结束` | `✅ 可以` |
| `SIGKILL` | `9` | `强制终止` | `立即杀死，不讲道理` | `❌ 不能` |
| `SIGQUIT` | `3` | `退出并生成核心转储` | `Ctrl+\，强制退出` | `✅ 可以` |
| `SIGUSR1` | `10` | `终止程序` | `用户自定义信号1` | `✅ 可以` |
| `SIGUSR2` | `12` | `终止程序` | `用户自定义信号2` | `✅ 可以` |

---

## 2. 🔧 trap命令详解


### 2.1 trap命令基础语法


**🔸 基本语法格式**
```bash
trap '处理命令' 信号名称
```

> 🧠 **记忆技巧**  
> trap就像"陷阱"，当特定信号"掉进"这个陷阱时，就会执行你设定的处理命令。

**🔸 简单示例**
```bash
#!/bin/bash

# 捕获Ctrl+C信号
trap 'echo "检测到中断信号，正在清理..."; exit 1' INT

echo "程序运行中，按Ctrl+C试试..."
while true; do
    sleep 1
done
```

### 2.2 信号处理函数定义


**🔸 函数式信号处理**
```bash
#!/bin/bash

# 定义信号处理函数
cleanup() {
    echo ""
    echo "🧹 正在清理资源..."
    # 删除临时文件
    rm -f /tmp/script_temp_*
    # 关闭可能开启的进程
    jobs -p | xargs -r kill
    echo "✅ 清理完成，程序退出"
    exit 0
}

# 绑定信号处理函数
trap cleanup INT TERM QUIT

echo "程序启动，创建临时文件..."
touch /tmp/script_temp_$$.txt

# 模拟长时间运行的任务
for i in {1..100}; do
    echo "处理任务 $i/100" > /tmp/script_temp_$$.txt
    sleep 1
done

echo "所有任务完成"
cleanup
```

### 2.3 trap命令的特殊用法


**🔸 查看当前trap设置**
```bash
# 查看所有trap设置
trap

# 查看特定信号的trap设置
trap -p INT
```

**🔸 重置信号处理**
```bash
# 恢复信号的默认行为
trap - INT TERM

# 忽略信号
trap '' INT TERM
```

**🔸 在子Shell中的行为**
```bash
#!/bin/bash

trap 'echo "父进程收到信号"' INT

# 在子Shell中，trap会被继承
(
    echo "子Shell开始"
    sleep 10
    echo "子Shell结束"
) &

wait
```

---

## 3. ⚡ 常用信号类型处理


### 3.1 EXIT信号处理


**🔸 EXIT信号的特殊性**
EXIT信号不是真正的系统信号，而是Shell的内建功能。无论脚本是正常结束还是异常退出，EXIT信号都会被触发。

```bash
#!/bin/bash

# EXIT信号处理函数
exit_handler() {
    local exit_code=$?
    echo ""
    echo "📊 脚本执行统计："
    echo "   退出码: $exit_code"
    echo "   执行时间: $((SECONDS))秒"
    echo "   处理文件数: $(cat /tmp/file_count 2>/dev/null || echo 0)"
    
    # 清理工作
    rm -f /tmp/file_count /tmp/process_*.log
    echo "🧹 清理完成"
}

# 绑定EXIT信号
trap exit_handler EXIT

# 初始化计数器
echo 0 > /tmp/file_count

echo "开始处理文件..."
# 模拟文件处理
for file in /etc/*.conf; do
    if [ -f "$file" ]; then
        echo "处理: $file" > "/tmp/process_$(basename $file).log"
        echo $(($(cat /tmp/file_count) + 1)) > /tmp/file_count
    fi
done

echo "所有文件处理完成"
# 脚本结束时会自动触发EXIT信号处理
```

### 3.2 ERR信号处理


**🔸 ERR信号的作用**
ERR信号在命令执行失败时触发，帮助我们捕获脚本中的错误。

```bash
#!/bin/bash

# 启用严格模式
set -eE  # -e: 遇到错误立即退出, -E: trap ERR信号会被继承

# 错误处理函数
error_handler() {
    local line_number=$1
    local error_code=$2
    echo "💥 错误发生！"
    echo "   位置: 第 ${line_number} 行"
    echo "   错误码: ${error_code}"
    echo "   命令: ${BASH_COMMAND}"
    
    # 记录错误日志
    echo "[$(date)] 错误: 行${line_number}, 退出码${error_code}, 命令: ${BASH_COMMAND}" >> error.log
    
    exit $error_code
}

# 绑定ERR信号，$LINENO和$?分别是行号和错误码
trap 'error_handler ${LINENO} $?' ERR

echo "开始执行可能出错的操作..."

# 这些命令中如果有任何一个失败，都会触发错误处理
ls /nonexistent/directory  # 这行会触发错误
echo "如果上一行出错，这行不会执行"
```

**🔸 更实用的错误处理示例**
```bash
#!/bin/bash

set -eE

# 错误恢复处理
error_recovery() {
    local exit_code=$?
    echo "⚠️  检测到错误，尝试恢复..."
    
    case $exit_code in
        1)
            echo "一般错误，记录日志后继续"
            return 0  # 返回0表示错误已处理，继续执行
            ;;
        2)
            echo "文件未找到错误，创建默认文件"
            touch default_file.txt
            return 0
            ;;
        *)
            echo "未知错误，无法恢复"
            exit $exit_code
            ;;
    esac
}

trap 'error_recovery' ERR

echo "执行可能出错的文件操作..."
cat nonexistent_file.txt || echo "文件不存在，但已处理"
echo "程序继续执行"
```

### 3.3 用户自定义信号处理


**🔸 SIGUSR1和SIGUSR2的使用**
```bash
#!/bin/bash

# 状态报告函数
status_report() {
    echo ""
    echo "📋 程序状态报告 [$(date)]"
    echo "   进程ID: $$"
    echo "   运行时长: ${SECONDS}秒"
    echo "   内存使用: $(ps -o pid,rss -p $$ | tail -1)"
    echo "   当前任务: $current_task"
    echo ""
}

# 配置重载函数
reload_config() {
    echo ""
    echo "🔄 重新加载配置文件..."
    if [ -f "app.conf" ]; then
        source app.conf
        echo "✅ 配置文件重载成功"
    else
        echo "⚠️  配置文件不存在，使用默认配置"
    fi
    echo ""
}

# 绑定用户自定义信号
trap status_report USR1
trap reload_config USR2

# 程序主循环
current_task="初始化"
echo "程序启动，PID: $$"
echo "发送信号方式："
echo "  kill -USR1 $$  # 查看状态"
echo "  kill -USR2 $$  # 重载配置"

for i in {1..60}; do
    current_task="处理任务 $i"
    sleep 1
done
```

使用方法：
```bash
# 在另一个终端中发送信号
kill -USR1 1234  # 查看状态报告
kill -USR2 1234  # 重载配置文件
```

---

## 4. 🚀 实际应用场景


### 4.1 信号处理器清理资源


**🔸 临时文件清理**
```bash
#!/bin/bash

# 临时目录
TEMP_DIR="/tmp/script_$$"
LOG_FILE="$TEMP_DIR/process.log"

# 资源清理函数
cleanup_resources() {
    echo ""
    echo "🧹 开始清理资源..."
    
    # 清理临时文件
    if [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
        echo "   ✅ 已清理临时目录: $TEMP_DIR"
    fi
    
    # 终止子进程
    local child_pids=$(jobs -p)
    if [ -n "$child_pids" ]; then
        echo "   🔄 正在终止子进程..."
        echo "$child_pids" | xargs -r kill -TERM
        sleep 2
        echo "$child_pids" | xargs -r kill -KILL 2>/dev/null || true
        echo "   ✅ 子进程已终止"
    fi
    
    # 释放网络端口（如果有的话）
    if [ -n "$SERVER_PID" ]; then
        kill "$SERVER_PID" 2>/dev/null || true
        echo "   ✅ 服务器进程已停止"
    fi
    
    echo "🎯 资源清理完成"
}

# 绑定多个信号
trap cleanup_resources EXIT INT TERM QUIT

# 创建工作环境
mkdir -p "$TEMP_DIR"
echo "📁 创建临时目录: $TEMP_DIR"

# 启动后台任务
{
    for i in {1..100}; do
        echo "[$(date)] 处理任务 $i" >> "$LOG_FILE"
        sleep 2
    done
} &

# 模拟启动服务器
{
    echo "启动模拟服务器..."
    sleep 1000
} &
SERVER_PID=$!

echo "程序运行中... (按 Ctrl+C 安全退出)"
wait
```

### 4.2 信号处理器嵌套


**🔸 嵌套信号处理的场景**
```bash
#!/bin/bash

# 标志变量
SHUTDOWN_IN_PROGRESS=false

# 第一层：优雅关闭
graceful_shutdown() {
    if [ "$SHUTDOWN_IN_PROGRESS" = true ]; then
        echo "⚠️  已在关闭过程中，请稍候..."
        return
    fi
    
    SHUTDOWN_IN_PROGRESS=true
    echo ""
    echo "🛑 收到关闭信号，开始优雅关闭..."
    echo "   (再次按 Ctrl+C 可强制退出)"
    
    # 设置强制退出处理
    trap force_shutdown INT TERM
    
    # 模拟优雅关闭过程
    for i in {5..1}; do
        echo "   正在关闭... $i 秒后完成"
        sleep 1
    done
    
    echo "✅ 优雅关闭完成"
    exit 0
}

# 第二层：强制关闭
force_shutdown() {
    echo ""
    echo "💥 强制关闭！"
    echo "🧹 快速清理..."
    rm -f /tmp/emergency_*
    echo "⚡ 立即退出"
    exit 1
}

# 绑定第一层信号处理
trap graceful_shutdown INT TERM

echo "服务启动中..."
echo "按 Ctrl+C 优雅关闭，连续按两次强制关闭"

# 主程序循环
while true; do
    echo "服务运行中... [$(date)]"
    sleep 3
done
```

### 4.3 脚本中断恢复


**🔸 断点续传功能**
```bash
#!/bin/bash

# 状态文件
STATE_FILE="/tmp/script_state_$$.txt"

# 保存当前状态
save_state() {
    echo "current_index=$current_index" > "$STATE_FILE"
    echo "start_time=$start_time" >> "$STATE_FILE"
    echo "processed_files=$processed_files" >> "$STATE_FILE"
}

# 恢复状态
restore_state() {
    if [ -f "$STATE_FILE" ]; then
        echo "🔄 发现之前的执行状态，正在恢复..."
        source "$STATE_FILE"
        echo "   从第 $current_index 个文件继续处理"
        echo "   已处理文件数: $processed_files"
        return 0
    else
        echo "📝 首次运行，初始化状态..."
        current_index=1
        start_time=$(date +%s)
        processed_files=0
        return 1
    fi
}

# 中断处理
interrupt_handler() {
    echo ""
    echo "⏸️  程序被中断，保存当前状态..."
    save_state
    echo "💾 状态已保存到: $STATE_FILE"
    echo "💡 重新运行脚本可继续处理"
    exit 130
}

# 完成处理
completion_handler() {
    echo ""
    echo "🎉 所有文件处理完成！"
    echo "📊 统计信息："
    echo "   总处理时间: $(($(date +%s) - start_time))秒"
    echo "   处理文件数: $processed_files"
    rm -f "$STATE_FILE"
    echo "🧹 状态文件已清理"
}

# 绑定信号
trap interrupt_handler INT TERM QUIT
trap completion_handler EXIT

# 恢复或初始化状态
restore_state

# 获取要处理的文件列表
files=($(find /etc -name "*.conf" 2>/dev/null | head -20))
total_files=${#files[@]}

echo "开始处理 $total_files 个配置文件..."
echo "(按 Ctrl+C 可中断并保存状态)"

# 从保存的位置继续处理
for ((i=current_index-1; i<total_files; i++)); do
    current_index=$((i+1))
    file="${files[i]}"
    
    echo "处理文件 $current_index/$total_files: $(basename "$file")"
    
    # 模拟文件处理
    sleep 1
    
    processed_files=$((processed_files+1))
    
    # 每处理5个文件自动保存状态
    if ((current_index % 5 == 0)); then
        save_state
    fi
done

echo "✅ 批处理任务完成"
```

---

## 5. 💡 信号处理最佳实践


### 5.1 信号处理设计原则


> 🎯 **核心原则**  
> 信号处理函数应该简单、快速、安全，就像紧急逃生通道一样，必须畅通无阻。

**🔸 设计要点**

```
✅ DO（应该做的）:
- 处理函数保持简洁
- 设置合适的清理顺序
- 使用原子操作
- 记录必要的日志

❌ DON'T（避免做的）:
- 在信号处理中执行复杂逻辑
- 调用不安全的函数
- 忽略错误处理
- 产生死锁
```

**🔸 安全的信号处理模板**
```bash
#!/bin/bash

# 全局状态标志
CLEANUP_DONE=false

# 安全的清理函数
safe_cleanup() {
    # 防止重复执行
    if [ "$CLEANUP_DONE" = true ]; then
        return 0
    fi
    CLEANUP_DONE=true
    
    echo "开始安全清理..."
    
    # 原子操作：快速设置退出标志
    echo "EXIT" > /tmp/script_$$.signal
    
    # 等待主程序检测到退出标志
    local timeout=10
    while [ $timeout -gt 0 ] && pgrep -f "main_process_$$" >/dev/null; do
        sleep 0.5
        timeout=$((timeout-1))
    done
    
    # 强制清理
    rm -f /tmp/script_$$.* 2>/dev/null || true
    
    echo "清理完成"
}

# 主程序检查退出标志的循环
main_process() {
    while [ ! -f "/tmp/script_$$.signal" ]; do
        # 执行主要工作
        echo "工作中..." >> "/tmp/script_$$.log"
        sleep 1
    done
    echo "检测到退出信号，主程序结束"
}

# 设置信号处理
trap safe_cleanup INT TERM EXIT

# 启动主程序
main_process &
echo $! > /tmp/main_process_$$

# 等待主程序完成
wait
```

### 5.2 常见问题与解决方案


**🔸 问题1：信号处理函数中执行耗时操作**
```bash
# ❌ 错误做法
trap 'find / -name "*.tmp" -delete' INT  # 可能耗时很长

# ✅ 正确做法
trap 'echo "cleanup" > /tmp/cleanup_flag' INT

# 在主程序中检查标志
while [ ! -f /tmp/cleanup_flag ]; do
    # 主要工作
    sleep 1
done
# 执行清理
find / -name "*.tmp" -delete
```

**🔸 问题2：子进程的信号处理**
```bash
#!/bin/bash

# 父进程信号处理
parent_cleanup() {
    echo "父进程开始清理"
    
    # 向进程组发送信号
    kill -TERM 0  # 0表示当前进程组
    
    # 等待子进程结束
    wait
    
    echo "父进程清理完成"
}

# 子进程信号处理
child_cleanup() {
    echo "子进程 $$ 收到信号，正在退出"
    exit 0
}

trap parent_cleanup INT TERM

# 启动子进程
for i in {1..3}; do
    {
        trap child_cleanup INT TERM
        echo "子进程 $$ 启动"
        sleep 30
        echo "子进程 $$ 正常结束"
    } &
done

echo "所有子进程已启动，按 Ctrl+C 统一清理"
wait
```

### 5.3 调试信号处理


**🔸 信号处理调试技巧**
```bash
#!/bin/bash

# 调试模式
DEBUG=${DEBUG:-false}

# 调试输出函数
debug_log() {
    if [ "$DEBUG" = true ]; then
        echo "[DEBUG $(date '+%H:%M:%S')] $*" >&2
    fi
}

# 带调试的信号处理
debug_signal_handler() {
    local signal=$1
    debug_log "收到信号: $signal"
    debug_log "当前进程: $$"
    debug_log "当前函数: ${FUNCNAME[1]}"
    debug_log "调用行号: ${BASH_LINENO[0]}"
    
    # 实际的信号处理逻辑
    case $signal in
        INT)
            echo "处理中断信号..."
            ;;
        TERM)
            echo "处理终止信号..."
            ;;
        USR1)
            echo "处理用户信号1..."
            ;;
    esac
    
    debug_log "信号 $signal 处理完成"
}

# 绑定带调试的信号处理
trap 'debug_signal_handler INT' INT
trap 'debug_signal_handler TERM' TERM
trap 'debug_signal_handler USR1' USR1

# 使用方法：
# DEBUG=true ./script.sh
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 信号处理基础**
- 信号是系统与程序通信的方式
- `trap`命令用于捕获和处理信号
- 不同信号有不同的默认行为和用途
- `SIGKILL`和`SIGSTOP`无法被捕获

**🔸 关键命令用法**
```bash
# 基本语法
trap 'command' SIGNAL

# 函数处理
trap function_name SIGNAL

# 多信号绑定
trap 'cleanup' INT TERM QUIT

# 恢复默认
trap - SIGNAL

# 忽略信号
trap '' SIGNAL
```

### 6.2 实用记忆要点


**🧠 信号处理记忆口诀**
```
信号处理要记牢，trap命令是法宝
INT中断TERM终止，KILL强杀捕不到
EXIT必执行，ERR错误找
清理资源第一位，简单快速最重要
```

**🔸 最佳实践清单**
- [ ] **简洁性**: 信号处理函数保持简单
- [ ] **安全性**: 避免在信号处理中执行复杂操作  
- [ ] **完整性**: 清理所有创建的资源
- [ ] **原子性**: 使用标志位进行状态控制
- [ ] **测试性**: 充分测试各种信号场景

### 6.3 常用代码模板


**🔸 通用清理模板**
```bash
#!/bin/bash
cleanup() {
    echo "清理资源..."
    rm -f /tmp/script_$$.* 
    jobs -p | xargs -r kill
    exit 0
}
trap cleanup EXIT INT TERM
```

**🔸 状态保存模板**  
```bash
save_and_exit() {
    echo "current_state=$state" > state.txt
    echo "状态已保存"
    exit 0
}
trap save_and_exit INT TERM
```

**核心理解**：
- 信号处理是Linux系统中程序间通信的重要机制
- `trap`命令让Shell脚本能够优雅地处理各种系统信号
- 好的信号处理能让脚本更加健壮和用户友好
- 清理资源和保存状态是信号处理的两大核心应用