---
title: 10、实时信号与扩展信号
---
## 📚 目录

1. [实时信号基础概念](#1-实时信号基础概念)
2. [实时信号范围与特性](#2-实时信号范围与特性)
3. [信号队列机制](#3-信号队列机制)
4. [信号优先级处理](#4-信号优先级处理)
5. [信号数据传递](#5-信号数据传递)
6. [signalfd信号文件描述符](#6-signalfd信号文件描述符)
7. [异步信号安全编程](#7-异步信号安全编程)
8. [性能考虑与最佳实践](#8-性能考虑与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 实时信号基础概念


### 1.1 什么是实时信号


**实时信号**是Linux系统中的一种增强型信号机制，相比传统的标准信号有更强的可靠性和灵活性。

```
传统信号 vs 实时信号：

传统信号：                    实时信号：
SIGTERM (15)                 SIGRTMIN (34) 到 SIGRTMAX (64)
│                           │
├─ 不排队                    ├─ 支持排队
├─ 可能丢失                  ├─ 不会丢失
├─ 无附加数据               ├─ 可携带数据
└─ 固定含义                 └─ 用户自定义含义
```

> 💡 **核心理解**：实时信号就像是"升级版"的信号，解决了传统信号可能丢失、无法排队的问题

### 1.2 实时信号的主要优势


```
🔸 可靠性保证
• 信号不会丢失
• 支持排队机制
• 按发送顺序处理

🔸 数据传递能力
• 可以携带整数或指针数据
• 支持结构化信息传递
• 适合复杂的进程间通信

🔸 优先级机制
• 编号小的优先级高
• 可控制处理顺序
• 支持紧急信号优先处理
```

### 1.3 应用场景举例


**实际应用场景**：
- **服务器程序**：接收客户端请求通知
- **多媒体应用**：音视频数据到达通知
- **实时监控**：传感器数据更新通知
- **分布式系统**：节点状态变化通知

---

## 2. 📊 实时信号范围与特性


### 2.1 信号编号范围


**实时信号编号体系**：
```bash
# 查看系统实时信号范围
$ kill -l | grep -E "RT|[3-6][0-9]"
34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7
...
60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1
64) SIGRTMAX
```

**编号范围详解**：
```c
// 获取实时信号范围
#include <signal.h>

int min_signal = SIGRTMIN;     // 通常是 34
int max_signal = SIGRTMAX;     // 通常是 64
int total_rt_signals = SIGRTMAX - SIGRTMIN + 1;  // 通常是 31 个
```

> 📝 **重要说明**：不同系统的实时信号数量可能不同，建议使用 `SIGRTMIN` 和 `SIGRTMAX` 宏而不是硬编码数字

### 2.2 信号特性对比表


| 特性 | **传统信号** | **实时信号** | **说明** |
|------|-------------|-------------|----------|
| 🔢 **数量** | `31个固定信号` | `31个可用信号` | `实时信号数量与系统相关` |
| 📦 **排队** | `❌ 不支持` | `✅ 支持排队` | `多个相同信号会排队等待` |
| 💾 **数据** | `❌ 无法携带` | `✅ 可携带数据` | `可传递整数或指针` |
| ⚡ **优先级** | `固定优先级` | `可配置优先级` | `编号越小优先级越高` |
| 🔒 **可靠性** | `可能丢失` | `保证送达` | `不会因为重复发送而丢失` |

### 2.3 实时信号的编号规则


```
优先级从高到低：

SIGRTMIN (34)      ← 最高优先级
SIGRTMIN+1 (35)    
SIGRTMIN+2 (36)
...
SIGRTMAX-1 (63)
SIGRTMAX (64)      ← 最低优先级

使用建议：
• 紧急事件：使用 SIGRTMIN
• 普通事件：使用中间编号
• 低优先级：使用 SIGRTMAX
```

---

## 3. 🗂️ 信号队列机制


### 3.1 队列工作原理


**信号队列的本质**：
```
传统信号处理：               实时信号队列：
发送 SIGTERM                发送 SIGRTMIN
发送 SIGTERM (丢失!)         发送 SIGRTMIN (入队)
发送 SIGTERM (丢失!)         发送 SIGRTMIN (入队)
处理 1 次                   发送 SIGRTMIN (入队)
                           处理 4 次 (按顺序)
```

### 3.2 队列机制演示代码


```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

static int signal_count = 0;

// 实时信号处理函数
void rt_handler(int sig, siginfo_t *info, void *context) {
    signal_count++;
    printf("接收到第 %d 个实时信号 %d，携带数据：%d\n", 
           signal_count, sig, info->si_value.sival_int);
}

int main() {
    struct sigaction sa;
    sa.sa_sigaction = rt_handler;
    sa.sa_flags = SA_SIGINFO;  // 启用扩展信息
    sigemptyset(&sa.sa_mask);
    
    // 注册实时信号处理器
    sigaction(SIGRTMIN, &sa, NULL);
    
    printf("进程ID: %d\n", getpid());
    printf("发送信号命令: kill -s SIGRTMIN %d\n", getpid());
    
    // 等待信号
    while(1) {
        pause();
    }
    
    return 0;
}
```

**测试队列效果**：
```bash
# 快速发送多个相同实时信号
$ for i in {1..5}; do kill -s SIGRTMIN $PID; done

# 输出结果：
接收到第 1 个实时信号 34，携带数据：0
接收到第 2 个实时信号 34，携带数据：0
接收到第 3 个实时信号 34，携带数据：0
接收到第 4 个实时信号 34，携带数据：0
接收到第 5 个实时信号 34，携带数据：0
```

> ✅ **关键观察**：每个信号都被独立处理，没有丢失

### 3.3 队列限制与配置


**系统队列限制**：
```bash
# 查看信号队列限制
$ ulimit -i
63445

# 查看详细的资源限制
$ cat /proc/sys/kernel/rtsig-max
1024

# 查看当前排队的实时信号数量
$ cat /proc/sys/kernel/rtsig-nr
0
```

**队列满的处理**：
```c
// 当队列满时，sigqueue() 会返回错误
union sigval value;
value.sival_int = 123;

if (sigqueue(target_pid, SIGRTMIN, value) == -1) {
    if (errno == EAGAIN) {
        printf("信号队列已满，无法发送\n");
    }
    perror("sigqueue");
}
```

---

## 4. ⚖️ 信号优先级处理


### 4.1 优先级规则详解


**处理优先级规则**：
```
1. 标准信号优先于实时信号
2. 实时信号按编号升序处理 (小编号优先)
3. 相同信号按发送顺序处理

优先级示例：
SIGTERM (15)        ← 最高优先级 (标准信号)
SIGRTMIN (34)       ← 次高优先级
SIGRTMIN+1 (35)     
SIGRTMIN+2 (36)
...
SIGRTMAX (64)       ← 最低优先级
```

### 4.2 优先级处理演示


```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <time.h>

// 通用信号处理函数
void signal_handler(int sig, siginfo_t *info, void *context) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    
    printf("[%ld.%09ld] 处理信号 %d", 
           ts.tv_sec, ts.tv_nsec, sig);
    
    if (sig >= SIGRTMIN && sig <= SIGRTMAX) {
        printf("，携带数据：%d", info->si_value.sival_int);
    }
    printf("\n");
}

int main() {
    struct sigaction sa;
    sa.sa_sigaction = signal_handler;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    
    // 注册多个信号
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGRTMIN, &sa, NULL);
    sigaction(SIGRTMIN+1, &sa, NULL);
    sigaction(SIGRTMIN+2, &sa, NULL);
    
    printf("进程ID: %d\n", getpid());
    printf("测试命令:\n");
    printf("kill -s SIGRTMIN+2 %d\n", getpid());
    printf("kill -s SIGRTMIN+1 %d\n", getpid());
    printf("kill -s SIGUSR1 %d\n", getpid());
    printf("kill -s SIGRTMIN %d\n", getpid());
    
    while(1) pause();
    return 0;
}
```

**测试结果**：
```bash
# 按逆序发送信号
$ kill -s SIGRTMIN+2 $PID
$ kill -s SIGRTMIN+1 $PID  
$ kill -s SIGUSR1 $PID
$ kill -s SIGRTMIN $PID

# 处理顺序 (按优先级)：
处理信号 10 (SIGUSR1)      ← 标准信号最先处理
处理信号 34 (SIGRTMIN)      ← 实时信号按编号顺序
处理信号 35 (SIGRTMIN+1)
处理信号 36 (SIGRTMIN+2)
```

---

## 5. 📦 信号数据传递


### 5.1 数据传递机制


**sigval联合体**：
```c
// 信号可以携带的数据类型
union sigval {
    int   sival_int;    // 整数数据
    void *sival_ptr;    // 指针数据
};
```

**数据传递的两种方式**：
```
1. 整数传递：传递状态码、计数器、ID等
2. 指针传递：传递复杂数据结构地址
```

### 5.2 整数数据传递示例


```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

// 接收方处理函数
void data_handler(int sig, siginfo_t *info, void *context) {
    printf("收到信号 %d\n", sig);
    printf("发送进程PID: %d\n", info->si_pid);
    printf("携带的整数数据: %d\n", info->si_value.sival_int);
    printf("---\n");
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("用法: %s <target_pid>\n", argv[0]);
        return 1;
    }
    
    pid_t target_pid = atoi(argv[1]);
    
    if (target_pid == getpid()) {
        // 接收方模式
        struct sigaction sa;
        sa.sa_sigaction = data_handler;
        sa.sa_flags = SA_SIGINFO;
        sigemptyset(&sa.sa_mask);
        
        sigaction(SIGRTMIN, &sa, NULL);
        
        printf("接收方启动，PID: %d\n", getpid());
        while(1) pause();
    } else {
        // 发送方模式
        union sigval value;
        
        for (int i = 1; i <= 3; i++) {
            value.sival_int = i * 100;  // 发送 100, 200, 300
            
            printf("发送数据 %d 到进程 %d\n", value.sival_int, target_pid);
            if (sigqueue(target_pid, SIGRTMIN, value) == -1) {
                perror("sigqueue");
                return 1;
            }
            sleep(1);
        }
    }
    
    return 0;
}
```

### 5.3 指针数据传递示例


```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

// 共享数据结构
struct message {
    int type;
    char content[100];
    time_t timestamp;
};

// 全局共享内存区域 (简化示例)
static struct message shared_data;

void pointer_handler(int sig, siginfo_t *info, void *context) {
    struct message *msg = (struct message *)info->si_value.sival_ptr;
    
    printf("收到消息类型: %d\n", msg->type);
    printf("消息内容: %s\n", msg->content);
    printf("时间戳: %ld\n", msg->timestamp);
}

int main() {
    struct sigaction sa;
    sa.sa_sigaction = pointer_handler;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    
    sigaction(SIGRTMIN+1, &sa, NULL);
    
    // 准备消息数据
    shared_data.type = 1;
    strcpy(shared_data.content, "Hello from real-time signal!");
    shared_data.timestamp = time(NULL);
    
    // 发送指针数据
    union sigval value;
    value.sival_ptr = &shared_data;
    
    printf("发送指针数据到自己，PID: %d\n", getpid());
    sigqueue(getpid(), SIGRTMIN+1, value);
    
    sleep(1);  // 给信号处理时间
    return 0;
}
```

> ⚠️ **安全注意**：指针传递时要确保目标进程能访问该内存地址，通常需要共享内存机制

---

## 6. 🔌 signalfd信号文件描述符


### 6.1 signalfd机制介绍


**什么是signalfd**：
```
传统信号处理：                signalfd处理：
信号 → 中断程序 → 处理函数      信号 → 文件描述符 → read()读取

优势：
• 同步处理信号 (无需担心信号处理函数的限制)
• 可以用select/poll/epoll监控
• 避免信号处理函数的竞态条件
• 更容易与事件循环集成
```

### 6.2 signalfd基础用法


```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/signalfd.h>
#include <stdlib.h>

int main() {
    sigset_t mask;
    int sfd;
    struct signalfd_siginfo si;
    ssize_t s;
    
    // 1. 屏蔽要处理的信号
    sigemptyset(&mask);
    sigaddset(&mask, SIGRTMIN);
    sigaddset(&mask, SIGRTMIN+1);
    sigaddset(&mask, SIGUSR1);
    
    // 屏蔽信号，防止默认处理
    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {
        perror("sigprocmask");
        exit(1);
    }
    
    // 2. 创建signalfd
    sfd = signalfd(-1, &mask, SFD_CLOEXEC);
    if (sfd == -1) {
        perror("signalfd");
        exit(1);
    }
    
    printf("进程PID: %d\n", getpid());
    printf("通过signalfd处理信号，文件描述符: %d\n", sfd);
    
    // 3. 循环读取信号
    while (1) {
        s = read(sfd, &si, sizeof(si));
        if (s == sizeof(si)) {
            printf("接收到信号: %d\n", si.ssi_signo);
            printf("发送者PID: %d\n", si.ssi_pid);
            
            if (si.ssi_signo >= SIGRTMIN && si.ssi_signo <= SIGRTMAX) {
                printf("实时信号数据: %d\n", si.ssi_int);
            }
            
            if (si.ssi_signo == SIGUSR1) {
                printf("收到退出信号，程序结束\n");
                break;
            }
            printf("---\n");
        }
    }
    
    close(sfd);
    return 0;
}
```

### 6.3 与epoll结合使用


```c
#include <sys/epoll.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/signalfd.h>

int main() {
    int epfd, sfd;
    sigset_t mask;
    struct epoll_event ev, events[10];
    struct signalfd_siginfo si;
    
    // 创建epoll实例
    epfd = epoll_create1(EPOLL_CLOEXEC);
    if (epfd == -1) {
        perror("epoll_create1");
        return 1;
    }
    
    // 设置信号掩码
    sigemptyset(&mask);
    sigaddset(&mask, SIGRTMIN);
    sigaddset(&mask, SIGINT);
    sigprocmask(SIG_BLOCK, &mask, NULL);
    
    // 创建signalfd
    sfd = signalfd(-1, &mask, SFD_CLOEXEC);
    
    // 将signalfd添加到epoll
    ev.events = EPOLLIN;
    ev.data.fd = sfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, sfd, &ev);
    
    printf("使用epoll监控signalfd，PID: %d\n", getpid());
    
    // 事件循环
    while (1) {
        int nfds = epoll_wait(epfd, events, 10, -1);
        
        for (int i = 0; i < nfds; i++) {
            if (events[i].data.fd == sfd) {
                read(sfd, &si, sizeof(si));
                printf("通过epoll接收信号: %d\n", si.ssi_signo);
                
                if (si.ssi_signo == SIGINT) {
                    printf("收到SIGINT，退出\n");
                    goto cleanup;
                }
            }
        }
    }
    
cleanup:
    close(sfd);
    close(epfd);
    return 0;
}
```

> 💡 **实际应用**：signalfd特别适合服务器程序，可以将信号处理集成到主事件循环中

---

## 7. 🔒 异步信号安全编程


### 7.1 异步信号安全概念


**什么是异步信号安全**：
```
问题场景：
程序正在执行 malloc()
↓
信号中断到来
↓  
信号处理函数也调用 malloc()
↓
死锁！(malloc内部锁被持有)

解决方案：
只在信号处理函数中使用"异步信号安全"的函数
```

### 7.2 安全函数与不安全函数


**异步信号安全的函数** (部分列表)：
```c
// 安全的系统调用
write()         // ✅ 可以在信号处理函数中使用
read()          // ✅ 可以在信号处理函数中使用
open()          // ✅ 可以在信号处理函数中使用
close()         // ✅ 可以在信号处理函数中使用
_exit()         // ✅ 可以在信号处理函数中使用

// 不安全的函数
printf()        // ❌ 不能在信号处理函数中使用
malloc()        // ❌ 不能在信号处理函数中使用
free()          // ❌ 不能在信号处理函数中使用
pthread_mutex_lock() // ❌ 不能在信号处理函数中使用
```

### 7.3 安全的信号处理示例


```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>

// 安全的信号处理函数
void safe_handler(int sig) {
    // 使用异步信号安全的write()而不是printf()
    const char msg[] = "Safe signal handler called\n";
    write(STDOUT_FILENO, msg, sizeof(msg) - 1);
}

// 不安全的信号处理函数 (仅作对比)
void unsafe_handler(int sig) {
    // ❌ 危险！printf()不是异步信号安全的
    printf("Unsafe signal handler called\n");  // 可能导致死锁
}

int main() {
    // 注册安全的处理函数
    signal(SIGRTMIN, safe_handler);
    
    printf("进程PID: %d\n", getpid());
    printf("发送信号测试: kill -s SIGRTMIN %d\n", getpid());
    
    while(1) {
        pause();
    }
    
    return 0;
}
```

### 7.4 自恢复中断系统调用


```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>

void dummy_handler(int sig) {
    // 空处理函数，只是为了中断系统调用
}

int main() {
    struct sigaction sa;
    sa.sa_handler = dummy_handler;
    sa.sa_flags = 0;  // 不设置SA_RESTART
    sigemptyset(&sa.sa_mask);
    
    sigaction(SIGRTMIN, &sa, NULL);
    
    printf("PID: %d\n", getpid());
    printf("发送信号来中断read: kill -s SIGRTMIN %d\n", getpid());
    
    char buffer[100];
    ssize_t result;
    
    // 自动重试的读取循环
    while (1) {
        printf("等待输入 (输入'quit'退出):\n");
        
        result = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
        
        if (result == -1) {
            if (errno == EINTR) {
                printf("read()被信号中断，自动重试...\n");
                continue;  // 重试
            } else {
                perror("read");
                break;
            }
        } else if (result > 0) {
            buffer[result] = '\0';
            printf("读取到: %s", buffer);
            
            if (strncmp(buffer, "quit", 4) == 0) {
                break;
            }
        }
    }
    
    return 0;
}
```

---

## 8. ⚡ 性能考虑与最佳实践


### 8.1 性能影响因素


**实时信号的性能开销**：
```
开销来源：
1. 队列管理：需要维护信号队列
2. 优先级排序：需要按优先级处理
3. 数据传递：需要复制sigval数据
4. 内核内存：队列占用内核内存

性能对比 (微秒级别)：
标准信号处理：1-2μs
实时信号处理：2-4μs (约2倍开销)
signalfd处理：3-5μs (包含系统调用开销)
```

### 8.2 性能测试代码


```c
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <unistd.h>
#include <sys/wait.h>

volatile int signal_count = 0;

void rt_counter(int sig, siginfo_t *info, void *context) {
    signal_count++;
}

void performance_test() {
    struct sigaction sa;
    sa.sa_sigaction = rt_counter;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGRTMIN, &sa, NULL);
    
    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);
    
    // 发送1000个实时信号
    union sigval value;
    value.sival_int = 0;
    
    for (int i = 0; i < 1000; i++) {
        sigqueue(getpid(), SIGRTMIN, value);
    }
    
    // 等待所有信号处理完成
    while (signal_count < 1000) {
        usleep(1);
    }
    
    clock_gettime(CLOCK_MONOTONIC, &end);
    
    long duration = (end.tv_sec - start.tv_sec) * 1000000000L + 
                   (end.tv_nsec - start.tv_nsec);
    
    printf("处理1000个实时信号用时: %ld 纳秒\n", duration);
    printf("平均每个信号: %ld 纳秒\n", duration / 1000);
}

int main() {
    performance_test();
    return 0;
}
```

### 8.3 最佳实践建议


**🔸 信号选择策略**：
```c
// 根据应用需求选择合适的信号

// 1. 简单通知 (无数据) - 使用标准信号
kill(pid, SIGUSR1);

// 2. 需要排队保证 - 使用实时信号
union sigval val;
val.sival_int = 0;
sigqueue(pid, SIGRTMIN, val);

// 3. 需要传递数据 - 使用实时信号
union sigval val;
val.sival_int = 12345;
sigqueue(pid, SIGRTMIN, val);

// 4. 高频率信号 - 考虑signalfd
// (避免频繁的上下文切换)
```

**🔸 队列管理策略**：
```c
// 检查队列状态，避免队列溢出
int send_queued_signal(pid_t pid, int sig, int data) {
    union sigval value;
    value.sival_int = data;
    
    if (sigqueue(pid, sig, value) == -1) {
        if (errno == EAGAIN) {
            // 队列满，可以选择：
            // 1. 等待重试
            // 2. 丢弃信号
            // 3. 使用标准信号作为fallback
            printf("信号队列满，使用标准信号\n");
            return kill(pid, sig);
        }
        return -1;
    }
    return 0;
}
```

**🔸 signalfd使用时机**：
```c
// 适合使用signalfd的场景：
// 1. 服务器程序的主事件循环
// 2. 需要同步处理信号的场合
// 3. 信号处理逻辑复杂的程序

// 不适合signalfd的场景：
// 1. 简单的信号处理
// 2. 需要立即响应的信号
// 3. 兼容性要求高的程序
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 实时信号本质：增强版信号，支持排队、数据传递、优先级
🔸 信号范围：SIGRTMIN (34) 到 SIGRTMAX (64)，共31个可用信号
🔸 核心特性：不丢失、支持排队、可携带数据、有优先级
🔸 数据传递：通过sigval联合体传递整数或指针
🔸 signalfd：将信号转换为文件描述符，支持同步处理
🔸 安全编程：只在信号处理函数中使用异步信号安全函数
```

### 9.2 关键理解要点


**🔹 实时信号vs传统信号**：
```
选择依据：
• 需要排队？ → 实时信号
• 需要传递数据？ → 实时信号  
• 需要优先级？ → 实时信号
• 简单通知？ → 传统信号就够了
```

**🔹 性能与可靠性的平衡**：
```
可靠性：实时信号 > 传统信号
性能：传统信号 > 实时信号 > signalfd
复杂度：signalfd > 实时信号 > 传统信号

根据应用需求选择合适的方案
```

**🔹 异步安全的重要性**：
```
错误理解：信号处理函数可以调用任何函数
正确理解：只能调用异步信号安全的函数
解决方案：使用signalfd或minimal处理函数
```

### 9.3 实际应用指导


**适用场景判断**：
- ✅ **服务器程序**：实时信号 + signalfd，处理客户端事件
- ✅ **实时系统**：实时信号，保证事件不丢失
- ✅ **IPC通信**：实时信号传递结构化数据
- ❌ **简单脚本**：传统信号就足够
- ❌ **高频信号**：考虑其他IPC机制

**编程实践要点**：
```c
// 1. 优先级分配
#define URGENT_SIGNAL    SIGRTMIN      // 紧急事件
#define NORMAL_SIGNAL    SIGRTMIN+10   // 普通事件  
#define LOW_SIGNAL       SIGRTMAX      // 低优先级事件

// 2. 错误处理
if (sigqueue(pid, sig, val) == -1) {
    if (errno == EAGAIN) {
        // 队列满的处理策略
    }
}

// 3. 性能优化
// 批量处理信号，避免逐个处理的开销
```

**调试技巧**：
```bash
# 查看进程的信号状态
$ cat /proc/$PID/status | grep -E "Sig|blocked|ignored|caught"

# 监控实时信号队列
$ watch "cat /proc/sys/kernel/rtsig-nr"

# 使用strace跟踪信号系统调用
$ strace -e signal=all -p $PID
```

**核心记忆**：
- 实时信号可排队不丢失，优先级高低看编号
- 数据传递用sigval，整数指针都能行
- signalfd变同步，事件循环好集成
- 异步安全很重要，write替代printf用