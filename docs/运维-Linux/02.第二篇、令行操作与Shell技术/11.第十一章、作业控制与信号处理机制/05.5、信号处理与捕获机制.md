---
title: 5、信号处理与捕获机制
---
## 📚 目录

1. [信号处理基础概念](#1-信号处理基础概念)
2. [信号处理函数注册](#2-信号处理函数注册)
3. [信号默认行为覆盖](#3-信号默认行为覆盖)
4. [信号忽略与阻塞机制](#4-信号忽略与阻塞机制)
5. [信号队列与排队处理](#5-信号队列与排队处理)
6. [信号处理原子性与限制](#6-信号处理原子性与限制)
7. [不可捕获的信号](#7-不可捕获的信号)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 信号处理基础概念


### 1.1 什么是信号处理


**简单理解**：信号处理就像给程序设置"紧急事件处理员"

```
现实生活类比：
火警警报响起 → 立即停止手头工作 → 执行疏散程序 → 继续原来工作
程序运行中   → 收到信号        → 执行处理函数 → 继续执行

核心作用：让程序能够主动响应外部事件，而不是被动等待
```

### 1.2 信号处理的工作原理


**🔸 基本工作流程**
```
程序正常执行
    ↓ (收到信号)
保存当前上下文
    ↓
执行信号处理函数
    ↓
恢复上下文继续执行

关键理解：
• 信号处理是"中断式"的，会打断程序正常执行
• 处理完信号后，程序会回到被中断的地方继续执行
• 就像接电话一样，暂停手头工作，接完电话继续干活
```

### 1.3 为什么需要信号处理


**🎯 实际应用场景**
```
优雅关闭程序：
• 程序收到终止信号时，先保存数据再退出
• 而不是粗暴地直接杀死进程

资源清理：
• 释放内存、关闭文件、断开网络连接
• 避免资源泄露和数据丢失

动态配置更新：
• 服务器收到特定信号时重新加载配置文件
• 无需重启整个服务

错误恢复：
• 程序崩溃时记录错误信息
• 尝试恢复或优雅退出
```

---

## 2. 📝 信号处理函数注册


### 2.1 signal函数 - 最简单的注册方式


**🔸 基本语法和含义**
```c
#include <signal.h>
void (*signal(int sig, void (*handler)(int)))(int);

简单理解：
signal(信号编号, 处理函数) = 给这个信号安排一个处理员
```

**💡 实际使用示例**
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

// 信号处理函数 - 就像一个专门的服务员
void handle_interrupt(int sig) {
    printf("收到中断信号(Ctrl+C)，但我不会退出！\n");
    printf("如果要退出，请输入'quit'命令\n");
}

int main() {
    // 注册信号处理函数 - 雇佣这个服务员
    signal(SIGINT, handle_interrupt);
    
    printf("程序运行中...按Ctrl+C试试看\n");
    
    // 程序持续运行
    while(1) {
        sleep(1);
        printf("我还在工作中...\n");
    }
    
    return 0;
}
```

### 2.2 sigaction函数 - 更强大的注册方式


**🔸 为什么需要sigaction**
```
signal函数的局限性：
• 功能比较简单，只能设置基本的处理函数
• 不能获取详细的信号信息
• 在不同系统上行为可能不一致

sigaction的优势：
• 功能更强大，可以获取详细信号信息
• 行为更一致，可移植性更好
• 可以设置更多的选项和标志
```

**💡 sigaction实际应用**
```c
#include <stdio.h>
#include <signal.h>
#include <string.h>

// 更详细的信号处理函数
void detailed_handler(int sig, siginfo_t *info, void *context) {
    printf("收到信号：%d\n", sig);
    printf("发送进程ID：%d\n", info->si_pid);
    printf("信号原因：%d\n", info->si_code);
}

int main() {
    struct sigaction sa;
    
    // 设置信号处理函数
    sa.sa_sigaction = detailed_handler;
    
    // 清空信号掩码（后面会详细解释）
    sigemptyset(&sa.sa_mask);
    
    // 使用详细信息模式
    sa.sa_flags = SA_SIGINFO;
    
    // 注册信号处理
    sigaction(SIGINT, &sa, NULL);
    
    printf("按Ctrl+C测试详细信号处理\n");
    while(1) {
        pause(); // 等待信号
    }
    
    return 0;
}
```

### 2.3 注册信号处理的注意事项


**⚠️ 重要提醒**
```
信号处理函数要求：
• 函数要尽可能简单快速
• 避免调用不安全的库函数
• 不要进行复杂的操作

安全的操作：
• 设置全局标志变量
• 调用async-signal-safe函数
• 简单的计算操作

危险的操作：
• 调用printf等I/O函数（在信号处理函数中）
• 动态内存分配malloc/free
• 调用非线程安全函数
```

---

## 3. 🔄 信号默认行为覆盖


### 3.1 信号的默认行为


**🔸 常见信号的默认行为**

| 信号名称 | **默认行为** | **含义说明** |
|---------|-------------|-------------|
| `SIGINT` | `终止进程` | `Ctrl+C键盘中断` |
| `SIGTERM` | `终止进程` | `正常终止请求` |
| `SIGKILL` | `强制终止` | `立即杀死进程(不可捕获)` |
| `SIGSTOP` | `暂停进程` | `暂停进程运行(不可捕获)` |
| `SIGCONT` | `继续进程` | `恢复暂停的进程` |
| `SIGCHLD` | `忽略` | `子进程状态改变` |
| `SIGPIPE` | `终止进程` | `管道破裂` |

### 3.2 覆盖默认行为的方法


**💡 实际示例：让程序"顽强生存"**
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

// 自定义终止处理
void my_termination_handler(int sig) {
    printf("有人想终止我(信号%d)，但我选择继续运行！\n", sig);
    printf("如果真的要关闭，请发送SIGKILL信号\n");
}

// 自定义暂停处理
void my_stop_handler(int sig) {
    printf("收到暂停信号，但我拒绝暂停！\n");
}

int main() {
    // 覆盖默认的终止行为
    signal(SIGINT, my_termination_handler);   // Ctrl+C
    signal(SIGTERM, my_termination_handler);  // 正常终止
    
    // 注意：SIGKILL和SIGSTOP无法覆盖！
    
    printf("顽强程序启动！尝试各种方式终止我吧\n");
    printf("Ctrl+C, kill命令都试试看\n");
    
    int counter = 0;
    while(1) {
        printf("运行计数：%d\n", ++counter);
        sleep(2);
    }
    
    return 0;
}
```

### 3.3 恢复默认行为


**🔸 如何恢复信号的原始处理**
```c
// 方法1：使用SIG_DFL恢复默认行为
signal(SIGINT, SIG_DFL);

// 方法2：使用sigaction恢复
struct sigaction sa;
sa.sa_handler = SIG_DFL;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
sigaction(SIGINT, &sa, NULL);

实际应用场景：
• 程序初始化时覆盖默认行为
• 运行过程中根据需要恢复默认行为
• 清理阶段让系统正常处理信号
```

---

## 4. 🚫 信号忽略与阻塞机制


### 4.1 信号忽略 - 视而不见


**🔸 什么是信号忽略**
```
简单理解：
就像把手机调成静音模式，电话打来了但不响铃，也不接听

技术含义：
• 信号到达进程，但进程不做任何处理
• 信号直接被丢弃，不会影响程序执行
• 使用SIG_IGN来实现
```

**💡 忽略信号的实际应用**
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int main() {
    printf("设置忽略SIGINT信号\n");
    
    // 忽略Ctrl+C信号
    signal(SIGINT, SIG_IGN);
    
    printf("现在按Ctrl+C不会有任何反应\n");
    
    for(int i = 0; i < 10; i++) {
        printf("倒计时：%d\n", 10-i);
        sleep(1);
    }
    
    // 恢复默认行为
    signal(SIGINT, SIG_DFL);
    printf("现在Ctrl+C又可以终止程序了\n");
    
    while(1) {
        printf("按Ctrl+C试试\n");
        sleep(1);
    }
    
    return 0;
}
```

### 4.2 信号阻塞 - 暂时屏蔽


**🔸 阻塞vs忽略的区别**
```
信号忽略：
• 信号直接丢弃，永远不处理
• 就像删除未读短信

信号阻塞：
• 信号暂时不处理，但会保存起来
• 解除阻塞后会处理这些信号
• 就像把短信设置为"稍后提醒"
```

**🔧 信号掩码操作**
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void show_signal_blocking() {
    sigset_t block_set, old_set;
    
    // 初始化信号集
    sigemptyset(&block_set);
    
    // 添加要阻塞的信号
    sigaddset(&block_set, SIGINT);
    sigaddset(&block_set, SIGTERM);
    
    printf("阻塞SIGINT和SIGTERM信号\n");
    
    // 设置信号掩码，阻塞指定信号
    sigprocmask(SIG_BLOCK, &block_set, &old_set);
    
    printf("现在按Ctrl+C不会立即响应\n");
    
    // 在阻塞期间做一些工作
    for(int i = 0; i < 5; i++) {
        printf("工作中...%d\n", i+1);
        sleep(1);
    }
    
    printf("解除信号阻塞\n");
    
    // 恢复原来的信号掩码
    sigprocmask(SIG_SETMASK, &old_set, NULL);
    
    printf("如果刚才按了Ctrl+C，现在应该会响应\n");
    sleep(3);
}
```

### 4.3 信号集操作详解


**🔸 信号集基本操作**
```c
// 信号集就像一个"信号清单"

sigset_t my_set;

// 清空信号集（清单上什么都没有）
sigemptyset(&my_set);

// 填满信号集（清单上列出所有信号）
sigfillset(&my_set);

// 添加一个信号到集合（在清单上打勾）
sigaddset(&my_set, SIGINT);

// 从集合中移除一个信号（在清单上擦掉）
sigdelset(&my_set, SIGINT);

// 检查信号是否在集合中（查看清单上有没有）
if (sigismember(&my_set, SIGINT)) {
    printf("SIGINT在信号集中\n");
}
```

---

## 5. 📋 信号队列与排队处理


### 5.1 信号排队的基本概念


**🔸 什么是信号排队**
```
生活类比：
餐厅排号系统 - 客人排队等待，按顺序服务
信号排队 - 多个信号同时到达，按顺序处理

技术含义：
• 当程序正在处理一个信号时，又来了其他信号
• 这些信号会被"排队"等待处理
• 处理完当前信号后，继续处理排队的信号
```

### 5.2 标准信号 vs 实时信号


**📊 信号排队行为对比**

| 信号类型 | **排队行为** | **处理方式** | **示例** |
|---------|-------------|-------------|---------|
| `标准信号` | `不排队，会丢失` | `只记住最后一个` | `SIGINT, SIGTERM` |
| `实时信号` | `严格排队` | `按顺序处理所有信号` | `SIGRTMIN到SIGRTMAX` |

**💡 标准信号的特点演示**
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int signal_count = 0;

void count_signals(int sig) {
    signal_count++;
    printf("处理信号 %d，当前计数：%d\n", sig, signal_count);
    
    // 模拟处理耗时
    sleep(2);
    
    printf("信号 %d 处理完成\n", sig);
}

int main() {
    signal(SIGINT, count_signals);
    
    printf("快速按多次Ctrl+C，看看信号是否会丢失\n");
    printf("（在处理第一个信号期间按的其他信号可能会丢失）\n");
    
    while(1) {
        pause(); // 等待信号
    }
    
    return 0;
}
```

### 5.3 信号队列的实际影响


**⚠️ 需要注意的问题**
```
标准信号可能丢失的情况：
• 程序正在处理SIGINT信号
• 此时又收到多个SIGINT信号
• 只有一个SIGINT会被排队，其他的丢失

实际应用中的解决方案：
• 使用实时信号替代标准信号
• 在信号处理函数中设置标志，主程序轮询
• 使用signalfd等现代机制
```

---

## 6. ⚛️ 信号处理原子性与限制


### 6.1 什么是原子性


**🔸 原子性的通俗解释**
```
原子性就像"要么全做，要么全不做"：

喝一口水的动作：
• 拿起杯子 → 送到嘴边 → 喝下去 → 放下杯子
• 这个过程要么完整完成，要么完全不做
• 不能做到一半就停下

程序中的原子性：
• 某些操作不能被信号中断
• 要么完整执行，要么不执行
• 保证数据的一致性
```

### 6.2 信号处理函数的限制


**⚠️ 在信号处理函数中不能做的事**

```c
// ❌ 危险操作示例
void bad_signal_handler(int sig) {
    // 这些操作都是不安全的！
    
    printf("收到信号\n");          // I/O操作，可能死锁
    malloc(100);                  // 内存分配，不可重入
    free(some_ptr);              // 内存释放，不可重入
    fopen("file.txt", "w");      // 文件操作，不可重入
}

// ✅ 安全操作示例
volatile sig_atomic_t signal_flag = 0;

void safe_signal_handler(int sig) {
    // 只设置标志，其他什么都不做
    signal_flag = 1;
}

int main() {
    signal(SIGINT, safe_signal_handler);
    
    while(1) {
        // 在主程序中检查标志
        if (signal_flag) {
            printf("检测到信号，进行相应处理\n");
            signal_flag = 0;
            // 在这里进行复杂操作是安全的
        }
        
        // 正常工作
        usleep(100000);
    }
}
```

### 6.3 可重入性问题


**🔸 什么是可重入性**
```
可重入函数：
• 可以被同时多次调用而不会出问题
• 就像公共厕所，多人使用不会相互干扰

不可重入函数：
• 使用了全局变量或静态变量
• 调用了其他不可重入函数
• 进行了内存分配操作

常见的不可重入函数：
• printf, fprintf 等I/O函数
• malloc, free 等内存管理函数
• strtok 等使用静态缓冲区的函数
```

**📋 async-signal-safe函数列表**
```c
// 这些函数在信号处理函数中是安全的
write()     // 写入文件描述符
read()      // 读取文件描述符  
open()      // 打开文件
close()     // 关闭文件
signal()    // 设置信号处理
pause()     // 等待信号
sleep()     // 休眠
alarm()     // 设置闹钟
kill()      // 发送信号

// 详细列表可以通过 man 7 signal-safety 查看
```

---

## 7. 🔒 不可捕获的信号


### 7.1 SIGKILL - 终极杀手


**🔸 SIGKILL的特殊性**
```
为什么SIGKILL不可捕获：
• 系统需要一个"最后手段"来强制终止失控进程
• 如果连SIGKILL都能被拦截，系统可能无法管理进程
• 保证系统管理员总是能够终止任何进程

实际使用：
kill -9 PID    # 发送SIGKILL信号
kill -KILL PID # 同样的效果
```

**💡 SIGKILL使用示例**
```bash
# 创建一个顽固的进程
$ ./stubborn_process &
[1] 12345

# 尝试正常终止（可能被拦截）
$ kill 12345
程序说：我拒绝退出！

# 强制终止（无法拦截）
$ kill -9 12345
[1]+ Killed stubborn_process

# 进程确实被终止了
$ ps aux | grep stubborn_process
# 没有结果，进程已死
```

### 7.2 SIGSTOP - 强制暂停


**🔸 SIGSTOP的作用机制**
```
SIGSTOP与Ctrl+Z的区别：

Ctrl+Z (SIGTSTP)：
• 可以被程序捕获和处理
• 程序可以选择忽略或自定义处理
• 是"请求暂停"

SIGSTOP：
• 不可被程序捕获
• 立即强制暂停进程
• 是"强制暂停"

配对使用：
SIGSTOP → 强制暂停进程
SIGCONT → 恢复被暂停的进程
```

**🔧 暂停和恢复进程演示**
```bash
# 启动一个长时间运行的程序
$ ping google.com &
[1] 12345

# 强制暂停进程
$ kill -STOP 12345
[1]+ Stopped ping google.com

# 查看进程状态
$ ps aux | grep ping
user 12345  0.0  0.0 ... T  ... ping google.com
# 注意状态是T(stopped)

# 恢复进程
$ kill -CONT 12345
[1]+ ping google.com &

# 或者使用作业控制
$ fg %1    # 恢复到前台
$ bg %1    # 恢复到后台
```

### 7.3 为什么需要不可捕获信号


**🎯 设计原理**
```
系统稳定性需求：
• 防止恶意程序拒绝退出
• 保证系统管理员的控制权
• 避免系统资源被长期占用

实际应用场景：
• 服务器程序崩溃需要强制重启
• 调试程序时需要立即停止
• 系统资源不足需要紧急清理进程

权限模型：
• 普通用户只能管理自己的进程
• root用户可以管理所有进程
• 但SIGKILL对所有进程都有效
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 信号处理：程序对外部事件的响应机制，类似紧急事件处理员
🔸 函数注册：使用signal()或sigaction()为信号安排处理函数
🔸 行为覆盖：可以改变信号的默认行为，但SIGKILL和SIGSTOP除外
🔸 忽略vs阻塞：忽略是永久丢弃，阻塞是暂时屏蔽后处理
🔸 信号排队：标准信号不排队会丢失，实时信号严格排队
🔸 原子性限制：信号处理函数只能做简单安全的操作
🔸 不可捕获：SIGKILL和SIGSTOP确保系统的最终控制权
```

### 8.2 实际应用指南


**🔹 选择合适的处理方式**
```
简单场景：
• 使用signal()函数快速注册
• 适合基本的信号响应需求

复杂场景：
• 使用sigaction()获取详细信息
• 需要高可靠性和可移植性

安全编程：
• 信号处理函数只设置标志变量
• 主程序轮询标志进行实际处理
• 避免在信号处理函数中调用复杂函数
```

**🔹 常见使用模式**
```c
// 模式1：优雅退出
volatile sig_atomic_t should_exit = 0;

void exit_handler(int sig) {
    should_exit = 1;
}

int main() {
    signal(SIGINT, exit_handler);
    signal(SIGTERM, exit_handler);
    
    while (!should_exit) {
        // 正常工作
    }
    
    // 清理资源后退出
    cleanup_and_exit();
}

// 模式2：配置重载
volatile sig_atomic_t should_reload = 0;

void reload_handler(int sig) {
    should_reload = 1;
}

int main() {
    signal(SIGUSR1, reload_handler);
    
    while (1) {
        if (should_reload) {
            reload_configuration();
            should_reload = 0;
        }
        
        do_work();
    }
}
```

### 8.3 记忆要点


**核心理解**：
- 信号处理让程序能够响应外部事件
- 就像给程序配备了"事件处理员"
- 处理函数要简单快速，复杂操作放在主程序
- SIGKILL和SIGSTOP是系统的"最后手段"

**最佳实践**：
- 总是使用volatile sig_atomic_t类型的标志变量
- 在信号处理函数中只做最简单的操作
- 重要的清理工作在main函数中完成
- 测试程序在各种信号下的行为