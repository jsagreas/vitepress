---
title: 11、常用正则表达式模式库
---
## 📚 目录

1. [邮箱地址验证模式](#1-邮箱地址验证模式)
2. [IP地址匹配规则](#2-IP地址匹配规则)
3. [域名和URL模式匹配](#3-域名和URL模式匹配)
4. [日期时间格式验证](#4-日期时间格式验证)
5. [电话号码格式匹配](#5-电话号码格式匹配)
6. [文件路径和扩展名提取](#6-文件路径和扩展名提取)
7. [数字格式匹配](#7-数字格式匹配)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📧 邮箱地址验证模式


### 1.1 邮箱的基本结构


**什么是邮箱地址？**
```
邮箱地址的组成部分：
用户名@域名.顶级域名

例子：zhang.san@company.com.cn
├─用户名: zhang.san
├─分隔符: @
├─域名: company.com
└─顶级域名: .cn
```

> **💡 关键理解**：邮箱验证是最常用的正则表达式应用场景，用来检查用户输入的邮箱格式是否正确。

### 1.2 简单邮箱验证模式


**基础版本：**
```bash
# 最简单的邮箱模式（仅用于演示概念）
[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}

# 测试示例
echo "test@example.com" | grep -E '[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}'
```

**模式解释：**
```
[a-zA-Z0-9]+     ← 用户名：字母数字，至少1个
@                ← 固定的@符号  
[a-zA-Z0-9]+     ← 域名：字母数字，至少1个
\.               ← 转义的点号
[a-zA-Z]{2,}     ← 顶级域名：字母，至少2个
```

### 1.3 实用邮箱验证模式


**推荐使用的模式：**
```bash
# 支持常见邮箱格式的模式
^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

# 实际使用示例
check_email() {
    local email="$1"
    if [[ $email =~ ^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        echo "邮箱格式正确: $email"
    else
        echo "邮箱格式错误: $email"
    fi
}

# 测试各种邮箱
check_email "user@example.com"        # ✅ 正确
check_email "user.name@company.cn"    # ✅ 正确  
check_email "user_123@sub.domain.org" # ✅ 正确
check_email "invalid.email"           # ❌ 错误
```

**模式详解：**
```
^                    ← 行开始
[a-zA-Z0-9._-]+     ← 用户名：字母数字点下划线短横线
@                    ← @符号
[a-zA-Z0-9.-]+      ← 域名：支持子域名
\.                   ← 点号
[a-zA-Z]{2,}        ← 顶级域名：至少2个字母
$                    ← 行结束
```

### 1.4 邮箱提取示例


```bash
# 从文本中提取所有邮箱地址
extract_emails() {
    local text="$1"
    echo "$text" | grep -oE '[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
}

# 示例文本
text="联系我们：admin@company.com 或 support@help.org"
extract_emails "$text"
# 输出：
# admin@company.com
# support@help.org
```

---

## 2. 🌐 IP地址匹配规则


### 2.1 IPv4地址结构


**IPv4地址是什么？**
```
IPv4地址格式：A.B.C.D
- 每个部分是0-255的数字
- 用点号分隔

例子：192.168.1.100
├─第1段: 192 (0-255)
├─分隔: .
├─第2段: 168 (0-255) 
├─分隔: .
├─第3段: 1   (0-255)
├─分隔: .
└─第4段: 100 (0-255)
```

> **💡 关键理解**：IPv4验证的难点在于每段数字必须在0-255范围内，不能简单地用[0-9]重复。

### 2.2 IPv4地址验证模式


**精确的IPv4模式：**
```bash
# 严格的IPv4地址匹配
ipv4_pattern='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'

# 验证函数
check_ipv4() {
    local ip="$1"
    if [[ $ip =~ $ipv4_pattern ]]; then
        echo "有效的IPv4地址: $ip"
    else
        echo "无效的IPv4地址: $ip"
    fi
}

# 测试示例
check_ipv4 "192.168.1.1"    # ✅ 有效
check_ipv4 "255.255.255.255" # ✅ 有效
check_ipv4 "256.1.1.1"      # ❌ 无效（256超出范围）
check_ipv4 "192.168.1"      # ❌ 无效（缺少段）
```

**模式解释：**
```
25[0-5]              ← 250-255
|                    ← 或者
2[0-4][0-9]         ← 200-249  
|                    ← 或者
[01]?[0-9][0-9]?    ← 0-199
```

### 2.3 简化的IPv4模式


**如果不需要严格验证范围：**
```bash
# 简单IPv4模式（不验证0-255范围）
simple_ipv4='^([0-9]{1,3}\.){3}[0-9]{1,3}$'

# 从日志中提取IP地址
extract_ips() {
    grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' /var/log/access.log
}
```

### 2.4 IPv6地址基础匹配


**IPv6地址结构：**
```
IPv6格式：8组4位十六进制数，用冒号分隔
例子：2001:0db8:85a3:0000:0000:8a2e:0370:7334
```

**简单IPv6模式：**
```bash
# 基本IPv6模式（完整格式）
ipv6_full='^([0-9a-fA-F]{4}:){7}[0-9a-fA-F]{4}$'

# 测试IPv6
check_ipv6() {
    local ip="$1"  
    if [[ $ip =~ $ipv6_full ]]; then
        echo "有效的IPv6地址: $ip"
    else
        echo "无效的IPv6地址: $ip"
    fi
}

check_ipv6 "2001:0db8:85a3:0000:0000:8a2e:0370:7334"  # ✅ 有效
```

---

## 3. 🌍 域名和URL模式匹配


### 3.1 域名的基本结构


**什么是域名？**
```
域名结构：子域名.域名.顶级域名
例子：www.example.com.cn

分解：
├─子域名: www
├─主域名: example  
├─顶级域名: com
└─国家域名: cn
```

> **💡 关键理解**：域名验证主要检查字符组成和结构，确保符合DNS规范。

### 3.2 域名验证模式


**标准域名模式：**
```bash
# 域名验证模式
domain_pattern='^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'

# 简化的域名模式（实用版本）
simple_domain='^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

# 验证函数
check_domain() {
    local domain="$1"
    if [[ $domain =~ $simple_domain ]]; then
        echo "有效域名: $domain"
    else
        echo "无效域名: $domain" 
    fi
}

# 测试示例
check_domain "www.example.com"     # ✅ 有效
check_domain "sub.domain.org.cn"   # ✅ 有效
check_domain "invalid..domain"     # ❌ 无效
```

### 3.3 URL匹配模式


**完整URL结构：**
```
URL组成：协议://域名:端口/路径?参数#锚点

例子：https://www.example.com:8080/path/page?id=123#section
├─协议: https
├─域名: www.example.com
├─端口: 8080
├─路径: /path/page
├─参数: ?id=123
└─锚点: #section
```

**实用URL匹配：**
```bash
# HTTP/HTTPS URL模式
url_pattern='^https?://[a-zA-Z0-9.-]+(/[^?#]*)?(\?[^#]*)?(#.*)?$'

# URL验证函数
check_url() {
    local url="$1"
    if [[ $url =~ $url_pattern ]]; then
        echo "有效URL: $url"
    else
        echo "无效URL: $url"
    fi
}

# 从文本提取URL
extract_urls() {
    local text="$1"
    echo "$text" | grep -oE 'https?://[a-zA-Z0-9.-]+(/[^[:space:]]*)?'
}

# 测试
text="访问 https://www.example.com 或 http://localhost:8080/api"
extract_urls "$text"
```

---

## 4. 📅 日期时间格式验证


### 4.1 常见日期格式


**日期格式的多样性：**
```
常见日期格式：
• YYYY-MM-DD    → 2023-12-25 (ISO标准)
• DD/MM/YYYY    → 25/12/2023 (欧洲格式)
• MM/DD/YYYY    → 12/25/2023 (美国格式)
• YYYY年MM月DD日 → 2023年12月25日 (中文格式)
```

> **💡 关键理解**：日期验证需要根据实际应用场景选择合适的格式，不同国家和系统使用不同标准。

### 4.2 ISO日期格式验证


**YYYY-MM-DD格式：**
```bash
# ISO标准日期格式
iso_date='^[0-9]{4}-[0-9]{2}-[0-9]{2}$'

# 更严格的日期验证（考虑月份和日期范围）
strict_date='^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$'

# 日期验证函数
check_date() {
    local date="$1"
    if [[ $date =~ $strict_date ]]; then
        echo "有效日期: $date"
    else
        echo "无效日期: $date"
    fi
}

# 测试
check_date "2023-12-25"  # ✅ 有效
check_date "2023-13-01"  # ❌ 无效（月份错误）
check_date "2023-12-32"  # ❌ 无效（日期错误）
```

### 4.3 时间格式验证


**时间格式匹配：**
```bash
# 24小时制时间 HH:MM:SS
time_24h='^([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$'

# 简化时间格式 HH:MM
time_simple='^([01][0-9]|2[0-3]):[0-5][0-9]$'

# 时间验证函数
check_time() {
    local time="$1"
    if [[ $time =~ $time_24h ]]; then
        echo "有效时间: $time"
    else
        echo "无效时间: $time"
    fi
}

# 测试
check_time "14:30:45"  # ✅ 有效
check_time "25:30:00"  # ❌ 无效（小时错误）
check_time "14:65:00"  # ❌ 无效（分钟错误）
```

### 4.4 日期时间组合


**完整日期时间格式：**
```bash
# YYYY-MM-DD HH:MM:SS格式
datetime_pattern='^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$'

# 从日志中提取时间戳
extract_timestamp() {
    local logfile="$1"
    grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}' "$logfile"
}

# 示例：分析日志文件中的时间信息
# extract_timestamp /var/log/application.log
```

---

## 5. 📱 电话号码格式匹配


### 5.1 中国手机号码


**中国手机号码规律：**
```
中国手机号码特点：
• 11位数字
• 以1开头
• 第二位是3,4,5,6,7,8,9中的一个
• 后面9位是任意数字

例子：13812345678
├─国家: 中国（1开头）
├─运营商: 38（移动/联通/电信）
└─用户号码: 12345678
```

> **💡 关键理解**：手机号验证要根据不同国家的编号规则，中国手机号有特定的格式要求。

**中国手机号验证：**
```bash
# 中国手机号模式
china_mobile='^1[3-9][0-9]{9}$'

# 更详细的运营商区分
china_mobile_detail='^1(3[0-9]|4[5-9]|5[0-35-9]|6[56]|7[0-8]|8[0-9]|9[89])[0-9]{8}$'

# 验证函数
check_mobile() {
    local mobile="$1"
    if [[ $mobile =~ $china_mobile ]]; then
        echo "有效手机号: $mobile"
    else
        echo "无效手机号: $mobile"
    fi
}

# 测试
check_mobile "13812345678"  # ✅ 有效
check_mobile "12812345678"  # ❌ 无效（第二位不符合规则）
check_mobile "138123456789" # ❌ 无效（长度错误）
```

### 5.2 固定电话号码


**固定电话格式：**
```bash
# 带区号的固定电话
landline_with_area='^0[0-9]{2,3}-[0-9]{7,8}$'

# 不带区号的固定电话  
landline_simple='^[0-9]{7,8}$'

# 验证函数
check_landline() {
    local phone="$1"
    if [[ $phone =~ $landline_with_area ]] || [[ $phone =~ $landline_simple ]]; then
        echo "有效固话: $phone"
    else
        echo "无效固话: $phone"
    fi
}

# 测试
check_landline "010-12345678"  # ✅ 有效
check_landline "0755-1234567"  # ✅ 有效
check_landline "12345678"      # ✅ 有效
```

### 5.3 国际电话格式


**国际格式电话：**
```bash
# 国际电话格式 +国家码-区号-号码
international_phone='^\+[1-9][0-9]{1,3}-[0-9]{1,4}-[0-9]{4,10}$'

# 简化国际格式
simple_international='^\+[1-9][0-9]{7,14}$'

# 测试
check_international() {
    local phone="$1"
    if [[ $phone =~ $simple_international ]]; then
        echo "有效国际号码: $phone"
    else
        echo "无效国际号码: $phone"
    fi
}

check_international "+8613812345678"   # ✅ 有效
check_international "+1-555-1234567"   # 根据模式验证
```

---

## 6. 📁 文件路径和扩展名提取


### 6.1 文件路径结构


**Linux文件路径组成：**
```
完整路径：/home/user/documents/file.txt
├─根目录: /
├─目录层级: home/user/documents/
├─文件名: file
├─扩展名: .txt
└─完整文件名: file.txt
```

> **💡 关键理解**：文件路径处理是系统管理的基础，需要能够提取路径中的各个组成部分。

### 6.2 路径验证模式


**Linux路径模式：**
```bash
# 绝对路径
absolute_path='^/([^/\0]+/)*[^/\0]*$'

# 相对路径  
relative_path='^[^/\0]([^/\0]+/)*[^/\0]*$'

# 路径验证函数
check_path() {
    local path="$1"
    if [[ $path =~ $absolute_path ]]; then
        echo "绝对路径: $path"
    elif [[ $path =~ $relative_path ]]; then
        echo "相对路径: $path"
    else
        echo "无效路径: $path"
    fi
}

# 测试
check_path "/home/user/file.txt"    # 绝对路径
check_path "documents/file.txt"     # 相对路径
check_path "../parent/file.txt"     # 相对路径
```

### 6.3 文件扩展名提取


**扩展名匹配模式：**
```bash
# 提取文件扩展名
extract_extension() {
    local filename="$1"
    if [[ $filename =~ \.([^.]+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "无扩展名"
    fi
}

# 批量处理文件
process_files_by_extension() {
    local directory="$1"
    
    # 找出所有图片文件
    find "$directory" -type f | grep -E '\.(jpg|jpeg|png|gif)$'
    
    # 找出所有文档文件
    find "$directory" -type f | grep -E '\.(txt|doc|pdf)$'
}

# 测试
extract_extension "document.pdf"     # 输出: pdf
extract_extension "archive.tar.gz"   # 输出: gz
extract_extension "README"           # 输出: 无扩展名
```

### 6.4 路径组件分离


**分离路径各部分：**
```bash
# 路径分析函数
analyze_path() {
    local fullpath="$1"
    
    # 提取目录部分
    local dirname=$(dirname "$fullpath")
    
    # 提取文件名
    local basename=$(basename "$fullpath")
    
    # 提取不含扩展名的文件名
    local filename="${basename%.*}"
    
    # 提取扩展名
    local extension="${basename##*.}"
    
    echo "完整路径: $fullpath"
    echo "目录: $dirname"
    echo "完整文件名: $basename"
    echo "文件名: $filename"
    echo "扩展名: $extension"
}

# 示例
analyze_path "/home/user/documents/report.pdf"
# 输出：
# 完整路径: /home/user/documents/report.pdf
# 目录: /home/user/documents
# 完整文件名: report.pdf
# 文件名: report
# 扩展名: pdf
```

---

## 7. 🔢 数字格式匹配


### 7.1 整数匹配


**什么是整数匹配？**
```
整数类型：
• 正整数: 123, 456
• 负整数: -123, -456  
• 零: 0
• 带符号: +123, -456
```

> **💡 关键理解**：数字匹配需要考虑正负号、前导零、小数点等各种情况。

**整数验证模式：**
```bash
# 基本整数（包括负数）
integer_pattern='^-?[0-9]+$'

# 不允许前导零的整数
integer_no_leading_zero='^-?(0|[1-9][0-9]*)$'

# 验证函数
check_integer() {
    local number="$1"
    if [[ $number =~ $integer_no_leading_zero ]]; then
        echo "有效整数: $number"
    else
        echo "无效整数: $number"
    fi
}

# 测试
check_integer "123"    # ✅ 有效
check_integer "-456"   # ✅ 有效
check_integer "0"      # ✅ 有效
check_integer "007"    # ❌ 无效（前导零）
check_integer "12.3"   # ❌ 无效（小数）
```

### 7.2 小数匹配


**小数格式验证：**
```bash
# 基本小数格式
decimal_pattern='^-?[0-9]+\.[0-9]+$'

# 更严格的小数（不允许前导零）
strict_decimal='^-?(0|[1-9][0-9]*)\.[0-9]+$'

# 可选小数（整数或小数都可以）
optional_decimal='^-?(0|[1-9][0-9]*)(\.[0-9]+)?$'

# 验证函数
check_decimal() {
    local number="$1"
    if [[ $number =~ $optional_decimal ]]; then
        echo "有效数字: $number"
    else
        echo "无效数字: $number"
    fi
}

# 测试
check_decimal "123.45"   # ✅ 有效
check_decimal "-0.5"     # ✅ 有效
check_decimal "123"      # ✅ 有效（整数也可以）
check_decimal ".5"       # 根据规则验证
```

### 7.3 科学计数法


**科学计数法格式：**
```
科学计数法：数字e指数
例子：
• 1.23e5   = 123000
• -2.5e-3  = -0.0025
• 1E+10    = 10000000000
```

**科学计数法模式：**
```bash
# 科学计数法匹配
scientific_pattern='^-?[0-9]+(\.[0-9]+)?[eE][+-]?[0-9]+$'

# 验证函数
check_scientific() {
    local number="$1"
    if [[ $number =~ $scientific_pattern ]]; then
        echo "有效科学计数法: $number"
    else
        echo "无效科学计数法: $number"
    fi
}

# 测试
check_scientific "1.23e5"    # ✅ 有效
check_scientific "-2.5E-3"   # ✅ 有效  
check_scientific "1e10"      # ✅ 有效
check_scientific "1.23x5"    # ❌ 无效
```

### 7.4 数字提取和统计


**从文本中提取数字：**
```bash
# 提取所有整数
extract_integers() {
    local text="$1"
    echo "$text" | grep -oE '-?[0-9]+'
}

# 提取所有数字（包括小数）
extract_numbers() {
    local text="$1"
    echo "$text" | grep -oE '-?[0-9]+(\.[0-9]+)?'
}

# 数字统计
count_numbers() {
    local text="$1"
    local count=$(extract_numbers "$text" | wc -l)
    echo "找到 $count 个数字"
}

# 示例
text="温度是25.5度，湿度60%，压力1013.25hPa"
echo "提取的数字："
extract_numbers "$text"
# 输出：
# 25.5
# 60
# 1013.25

count_numbers "$text"
# 输出：找到 3 个数字
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 正则表达式的实用价值：快速验证和提取特定格式的数据
🔸 常用模式记忆：邮箱、IP、域名、日期是最常用的验证场景
🔸 模式设计原则：简单实用优于完美复杂
🔸 测试的重要性：每个模式都要用实际数据验证
🔸 适度原则：根据实际需求选择合适的严格程度
```

### 8.2 实际应用指导


**🔹 模式选择策略**
```
邮箱验证：
• 简单场景：基础格式检查即可
• 严格场景：考虑国际化域名

IP地址验证：
• IPv4：重点掌握，应用最广
• IPv6：了解基础，按需深入

日期时间：
• 选择统一格式：建议ISO标准
• 考虑时区：必要时包含时区信息
```

**🔹 性能优化建议**
```
编译优化：
• 重复使用的模式应该预编译
• 避免在循环中重复编译正则表达式

模式简化：
• 复杂模式拆分为多个简单模式
• 优先使用高效的字符类

错误处理：
• 提供友好的错误信息
• 区分不同类型的格式错误
```

### 8.3 常见错误避免


**🔹 模式设计陷阱**
```
❌ 过度复杂：试图用一个模式解决所有情况
✅ 合理简化：根据实际需求调整精确度

❌ 忽略边界：没有使用^和$锚定
✅ 明确边界：确保完整匹配

❌ 字符转义：忘记转义特殊字符
✅ 正确转义：\.、\+、\?等特殊字符
```

### 8.4 学习建议


```
📚 **学习路径**
1. 从简单模式开始：邮箱、数字
2. 逐步增加复杂度：日期、URL
3. 结合实际项目：解决具体问题
4. 建立模式库：收集常用模式

🛠️ **实践技巧**
• 使用在线正则测试工具
• 保存验证过的模式作为模板
• 为每个模式编写测试用例
• 定期更新模式以适应新需求
```

### 8.5 扩展应用


```
🔸 日志分析：提取访问日志中的关键信息
🔸 数据清洗：标准化不规范的输入数据
🔸 配置验证：检查配置文件格式正确性
🔸 内容过滤：识别和处理特定内容
🔸 数据迁移：转换不同系统间的数据格式
```

**核心记忆**：
- 正则表达式是数据验证和提取的利器
- 实用性优于完美性，够用就好
- 每种常见格式都有成熟的模式可参考
- 测试验证是确保模式正确的关键步骤
- 建立个人模式库，提高开发效率