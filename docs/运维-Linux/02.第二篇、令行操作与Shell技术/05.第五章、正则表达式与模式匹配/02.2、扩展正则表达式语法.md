---
title: 2、扩展正则表达式语法
---
## 📚 目录

1. [扩展正则表达式概述](#1-扩展正则表达式概述)
2. [精确重复量词](#2-精确重复量词)
3. [分组与捕获](#3-分组与捕获)
4. [选择与或逻辑](#4-选择与或逻辑)
5. [非贪婪匹配](#5-非贪婪匹配)
6. [否定字符类](#6-否定字符类)
7. [组合字符范围](#7-组合字符范围)
8. [POSIX字符类](#8-posix字符类)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚀 扩展正则表达式概述


### 1.1 什么是扩展正则表达式

**简单理解**：扩展正则表达式就像是基础正则的"升级版"，提供了更强大、更灵活的模式匹配功能。

```
生活类比：
基础正则 = 普通话：能基本交流
扩展正则 = 方言+专业术语：表达更精确、更丰富

实际应用：
基础：找到包含"hello"的行
扩展：找到恰好出现3次"hello"，或者包含"hello"或"hi"的行
```

**🔍 核心特点**：
- **更精确的控制**：能指定确切的重复次数
- **更复杂的逻辑**：支持分组和选择操作
- **更高效的匹配**：非贪婪匹配避免过度匹配
- **更丰富的字符类**：预定义的字符集合

### 1.2 基础与扩展正则的区别

```
使用工具对比：
基础正则：grep、sed（默认模式）
扩展正则：grep -E、egrep、sed -E

语法差异示例：
基础正则：需要转义    \{3\}  \+  \?  \|  \( \)
扩展正则：直接使用    {3}    +   ?   |   ( )
```

**💡 记忆技巧**：
> 扩展正则 = "懒人版"正则，很多符号不需要反斜杠转义了！

---

## 2. 🎯 精确重复量词


### 2.1 花括号量词的三种形式

**核心概念**：花括号`{}`让我们能精确控制字符或模式的重复次数。

```
量词语法格式：
{n}    - 恰好重复n次
{n,}   - 至少重复n次  
{n,m}  - 重复n到m次之间
```

### 2.2 恰好重复：{n}

**作用**：匹配前面的字符或模式恰好n次，不多不少。

```bash
# 示例：查找恰好3个数字的字符串
echo -e "12\n123\n1234\n12345" | grep -E '[0-9]{3}'
```

```
匹配结果分析：
12     ✗ (只有2个数字)
123    ✓ (恰好3个数字)
1234   ✓ (包含3个连续数字：123)
12345  ✓ (包含3个连续数字：123, 234, 345)
```

**💼 实际应用场景**：
- **验证手机号**：`1[3-9][0-9]{9}` (1开头+第二位3-9+后面9位数字)
- **匹配IP地址段**：`[0-9]{1,3}` (1-3位数字)
- **检查密码长度**：`[a-zA-Z0-9]{8}` (恰好8位字符)

### 2.3 至少重复：{n,}

**作用**：匹配前面的字符或模式至少出现n次，上不封顶。

```bash
# 示例：查找至少3个连续字母a的字符串
echo -e "a\naa\naaa\naaaa\naaaaa" | grep -E 'a{3,}'
```

```
匹配过程：
a      ✗ (只有1个a，少于3个)
aa     ✗ (只有2个a，少于3个)  
aaa    ✓ (恰好3个a，满足条件)
aaaa   ✓ (4个a，大于3个)
aaaaa  ✓ (5个a，大于3个)
```

### 2.4 范围重复：{n,m}

**作用**：匹配前面的字符或模式重复n到m次之间，包含n和m。

```bash
# 示例：匹配2-4位数字
echo -e "1\n12\n123\n1234\n12345" | grep -E '[0-9]{2,4}'
```

```
匹配逻辑：
1      ✗ (1位，少于2位)
12     ✓ (2位，在范围内)
123    ✓ (3位，在范围内)
1234   ✓ (4位，在范围内)
12345  ✓ (包含4位数字：1234)
```

### 2.5 精确量词的实用案例


**📱 手机号验证**：
```bash
# 中国手机号格式：1开头，第二位3-9，总共11位
grep -E '^1[3-9][0-9]{9}$' phone_numbers.txt
```

**🔢 身份证号检查**：
```bash
# 18位身份证：前17位数字+最后1位数字或X
grep -E '^[0-9]{17}[0-9Xx]$' id_cards.txt
```

**💳 银行卡号长度验证**：
```bash
# 银行卡号通常16-19位数字
grep -E '^[0-9]{16,19}$' card_numbers.txt
```

---

## 3. 🔗 分组与捕获


### 3.1 圆括号分组的基本概念

**简单理解**：圆括号`()`就像数学中的括号一样，把几个字符"捆绑"成一个整体来处理。

```
数学类比：
数学：2×(3+4) = 2×7 = 14
正则：ab(cd){2} = abcdcd

作用：
- 把多个字符当作一个单元
- 对整个组应用量词
- 提取匹配的部分内容
```

### 3.2 分组的基本语法

```bash
# 基础分组示例
echo "abcabc" | grep -E '(abc){2}'     # 匹配abc重复2次
echo "hellohello" | grep -E '(hello){2}' # 匹配hello重复2次
```

**🔍 分组匹配过程**：
```
模式：(abc){2}
输入：abcabc

步骤：
1. (abc) 匹配第一个"abc" ✓
2. {2} 要求重复2次
3. 再次匹配"abc" ✓
4. 整体匹配成功：abcabc
```

### 3.3 复杂分组示例


**📧 邮箱地址匹配**：
```bash
# 简化的邮箱格式：用户名@域名.后缀
echo "user@example.com" | grep -E '([a-zA-Z0-9]+)@([a-zA-Z0-9]+)\.([a-zA-Z]{2,4})'
```

```
分组解析：
([a-zA-Z0-9]+)    - 第1组：用户名部分
([a-zA-Z0-9]+)    - 第2组：域名部分  
([a-zA-Z]{2,4})   - 第3组：后缀部分(2-4个字母)
```

**🌐 URL格式匹配**：
```bash
# 简化URL：协议://域名/路径
echo "https://www.example.com/path" | grep -E '(https?)://([^/]+)(/.*)?'
```

### 3.4 分组的实际应用


**📁 文件名分解**：
```bash
# 分离文件名和扩展名
ls *.txt | grep -E '(.+)\.([a-zA-Z]{2,4})$'

# 示例：document.txt
# 第1组：document
# 第2组：txt
```

**📅 日期格式提取**：
```bash
# 匹配YYYY-MM-DD格式日期
echo "2024-03-15" | grep -E '([0-9]{4})-([0-9]{2})-([0-9]{2})'

# 分组结果：
# 第1组：2024 (年)
# 第2组：03   (月)  
# 第3组：15   (日)
```

---

## 4. ⚡ 选择与或逻辑


### 4.1 管道符的基本概念

**简单理解**：管道符`|`就是"或者"的意思，让正则表达式可以匹配多个不同的模式中的任意一个。

```
生活类比：
"我想吃苹果或香蕉" = 苹果|香蕉
"查找txt或doc文件" = \.txt|\.doc

语法格式：
模式1|模式2|模式3  (匹配其中任意一个即可)
```

### 4.2 基础选择操作

```bash
# 匹配cat或dog
echo -e "cat\ndog\nbird" | grep -E 'cat|dog'
```

```
匹配过程：
cat   ✓ (匹配第一个选项"cat")
dog   ✓ (匹配第二个选项"dog")  
bird  ✗ (两个选项都不匹配)
```

### 4.3 与分组结合使用

**重要概念**：当选择操作与其他模式结合时，通常需要用括号明确范围。

```bash
# 错误写法：匹配hello或world后跟数字
echo "hello123" | grep -E 'hello|world[0-9]+'   # 容易误解

# 正确写法：用括号明确选择范围
echo "hello123" | grep -E '(hello|world)[0-9]+'  # 清晰明确
```

```
区别解释：
hello|world[0-9]+  意思是："hello" 或者 "world后跟数字"
(hello|world)[0-9]+ 意思是："hello或world" 后跟数字
```

### 4.4 多选择实用案例


**📋 文件类型过滤**：
```bash
# 查找图片文件：jpg、png、gif格式
ls | grep -E '\.(jpg|png|gif)$'

# 更复杂：包含大小写
ls | grep -E '\.(jpg|jpeg|png|gif|bmp)$' -i
```

**📞 电话号码格式**：
```bash
# 匹配多种电话格式
echo -e "138-1234-5678\n(010)12345678\n13812345678" | grep -E '([0-9]{3}-[0-9]{4}-[0-9]{4}|\([0-9]{3}\)[0-9]{8}|[0-9]{11})'
```

```
格式解析：
[0-9]{3}-[0-9]{4}-[0-9]{4}  - 格式：138-1234-5678
\([0-9]{3}\)[0-9]{8}        - 格式：(010)12345678  
[0-9]{11}                   - 格式：13812345678
```

**🌍 协议匹配**：
```bash
# 匹配http或https开头的URL
echo "https://example.com" | grep -E '^(http|https)://'

# 更简洁的写法
echo "https://example.com" | grep -E '^https?://'  # ?表示s可选
```

---

## 5. 🐌 非贪婪匹配


### 5.1 贪婪vs非贪婪的概念

**核心理解**：贪婪匹配就像"贪吃蛇"，能吃多少就吃多少；非贪婪匹配就像"适度饮食"，够用就行。

```
生活类比：
贪婪匹配 = 自助餐时装满整个盘子
非贪婪匹配 = 自助餐时适量取用

技术对比：
贪婪匹配：尽可能匹配更多字符
非贪婪匹配：尽可能匹配更少字符
```

### 5.2 懒惰量词语法

```
贪婪量词 → 非贪婪量词
*       → *?     (0次或多次，非贪婪)
+       → +?     (1次或多次，非贪婪)  
?       → ??     (0次或1次，非贪婪)
{n,m}   → {n,m}? (n到m次，非贪婪)
```

### 5.3 实际匹配对比


**HTML标签匹配示例**：
```bash
# 测试字符串
text="<p>第一段</p><p>第二段</p>"

# 贪婪匹配 (可能有问题)
echo "$text" | grep -E '<p>.*</p>'
# 结果：匹配整个字符串 "<p>第一段</p><p>第二段</p>"

# 非贪婪匹配 (更准确)  
echo "$text" | grep -E '<p>.*?</p>'
# 理想结果：分别匹配 "<p>第一段</p>" 和 "<p>第二段</p>"
```

**⚠️ 注意**：传统的grep不支持非贪婪量词，需要使用其他工具如Python、Perl或较新版本的grep。

### 5.4 非贪婪匹配的应用场景


**📝 提取引号内容**：
```
字符串：He said "Hello" and "World"

贪婪匹配 ".*"：
结果：整个 "Hello" and "World"

非贪婪匹配 ".*?"：  
结果：分别匹配 "Hello" 和 "World"
```

**🔗 URL参数提取**：
```
URL：http://example.com?name=John&age=25&city=NYC

贪婪匹配 =.*&：
结果：=John&age=25& (匹配太多)

非贪婪匹配 =.*?&：
结果：=John& (恰好匹配一个参数值)
```

### 5.5 在Linux中的替代方法


由于传统Linux工具对非贪婪支持有限，可以使用以下策略：

**🛠️ 使用字符类替代**：
```bash
# 代替 ".*?"，使用 "[^"]*" 匹配引号内容
echo 'He said "Hello" and "World"' | grep -E '"[^"]*"'

# 解释：[^"]* 表示匹配任意个非引号字符
```

**🐍 使用Python进行复杂匹配**：
```bash
# 使用python -c进行非贪婪匹配
echo "<p>段落1</p><p>段落2</p>" | python3 -c "
import re, sys
text = sys.stdin.read()
matches = re.findall('<p>.*?</p>', text)
for match in matches: print(match)
"
```

---

## 6. 🚫 否定字符类


### 6.1 否定字符类的基本概念

**简单理解**：否定字符类就是"不要这些字符"的意思，用`[^...]`表示匹配除了指定字符之外的任何字符。

```
对比理解：
[abc]    = 匹配a、b、c中的任意一个
[^abc]   = 匹配除了a、b、c之外的任意字符

生活类比：
[abc]    = "我只要苹果、香蕉、樱桃"
[^abc]   = "除了苹果、香蕉、樱桃，其他都要"
```

### 6.2 基础否定字符类语法

```bash
# 匹配非数字字符
echo "abc123def" | grep -E '[^0-9]+'
# 结果：匹配 "abc" 和 "def"

# 匹配非字母字符  
echo "hello123world" | grep -E '[^a-zA-Z]+'
# 结果：匹配 "123"
```

### 6.3 常用否定字符类模式


**📝 匹配非空白字符**：
```bash
# [^[:space:]] 或 [^ \t\n\r]
echo "hello world" | grep -E '[^[:space:]]+'
# 结果：分别匹配 "hello" 和 "world"
```

**🔤 匹配非字母数字**：
```bash
# 匹配标点符号和特殊字符
echo "hello, world!" | grep -E '[^a-zA-Z0-9 ]+'  
# 结果：匹配 "," 和 "!"
```

**📋 匹配非换行符**：
```bash
# 匹配一行中的所有字符（除换行符外）
echo -e "line1\nline2" | grep -E '[^\n]+'
```

### 6.4 否定字符类的实用案例


**🔍 提取文件名（去除路径）**：
```bash
# 匹配最后一个/之后的内容
echo "/home/user/document.txt" | grep -E '[^/]+$'
# 结果：document.txt
```

**📧 验证邮箱格式（简化版）**：
```bash
# 用户名部分：非@字符
# 域名部分：非@和.字符
echo "user@domain.com" | grep -E '[^@]+@[^@.]+\.[^@.]+'
```

**🧹 过滤特殊字符**：
```bash
# 只保留字母、数字、下划线
echo "hello@world#123" | grep -E '[^a-zA-Z0-9_]+' --color=always
# 高亮显示：@#（需要清理的字符）
```

### 6.5 否定字符类的注意事项


**⚠️ 位置很重要**：
```
[^abc]   ✓ 正确：否定字符类
[abc^]   ✗ 错误：匹配a、b、c、^四个字符
[a^bc]   ✗ 错误：匹配a、^、b、c四个字符
```

**🎯 范围否定**：
```bash
# 否定数字范围
[^0-9]     # 匹配非数字
[^a-z]     # 匹配非小写字母  
[^A-Z]     # 匹配非大写字母
[^a-zA-Z]  # 匹配非字母
```

---

## 7. 🎨 组合字符范围


### 7.1 字符范围组合的概念

**核心理解**：组合字符范围就是把多个字符集合"打包"在一起，让一个字符类能匹配更多类型的字符。

```
单一范围：
[a-z]     只匹配小写字母
[A-Z]     只匹配大写字母  
[0-9]     只匹配数字

组合范围：
[a-zA-Z]     匹配所有字母
[a-zA-Z0-9]  匹配字母和数字
[a-zA-Z0-9_] 匹配字母、数字、下划线
```

### 7.2 常用组合模式


**📝 标识符匹配**（变量名、函数名等）：
```bash
# 匹配合法的程序标识符：字母开头，后跟字母数字下划线
echo "user_name123" | grep -E '^[a-zA-Z][a-zA-Z0-9_]*$'

# 分解：
# ^[a-zA-Z]         - 必须以字母开头
# [a-zA-Z0-9_]*     - 后面跟任意个字母、数字、下划线
# $                 - 字符串结束
```

**🔐 密码复杂度检查**：
```bash
# 包含大小写字母、数字的8位密码
echo "MyPass123" | grep -E '^[a-zA-Z0-9]{8}$'

# 更复杂：必须包含特殊字符
echo "MyPass@123" | grep -E '^[a-zA-Z0-9!@#$%^&*()_+-=]{8,}$'
```

**🌐 URL路径字符**：
```bash
# 匹配URL中允许的字符
echo "path/to/file-name_123.html" | grep -E '^[a-zA-Z0-9._/-]+$'
```

### 7.3 中文和特殊字符范围


**🈯 中文字符范围**（UTF-8编码）：
```bash
# 注意：需要支持UTF-8的grep版本
# 中文字符范围（简化）
echo "你好world" | grep -E '[一-龯]+'
```

**💱 货币和特殊符号**：
```bash
# 匹配价格格式：数字+货币符号
echo "$123.45" | grep -E '[$¥€£][0-9]+(\.[0-9]{2})?'
echo "¥99.99" | grep -E '[$¥€£][0-9]+(\.[0-9]{2})?'
```

### 7.4 实用组合范例


**📱 手机号码国际化**：
```bash
# 匹配多种格式的电话号码
phone_pattern='[0-9+() -]{10,15}'

echo "+86 138-1234-5678" | grep -E "$phone_pattern"
echo "(010) 1234-5678" | grep -E "$phone_pattern"  
echo "13812345678" | grep -E "$phone_pattern"
```

**📂 文件名合法性检查**：
```bash
# Windows/Linux通用的安全文件名字符
safe_filename='^[a-zA-Z0-9._() -]+$'

echo "My Document (v2).txt" | grep -E "$safe_filename"  # ✓
echo "file<>name.txt" | grep -E "$safe_filename"        # ✗
```

**🏷️ 标签和关键词提取**：
```bash
# 匹配程序中的标签格式：#tag_name
echo "Check out #linux_tips and #regex_tutorial" | grep -oE '#[a-zA-Z0-9_]+'
# 结果：#linux_tips 和 #regex_tutorial
```

---

## 8. 📚 POSIX字符类


### 8.1 POSIX字符类的概念

**简单理解**：POSIX字符类就是预定义的"字符套餐"，不用自己写复杂的字符范围，直接用现成的。

```
自己做饭 vs 点外卖：
传统方式：[a-zA-Z]           (自己定义字母范围)
POSIX方式：[[:alpha:]]       (直接用预定义的"字母套餐")

优势：
- 更简洁易读
- 国际化支持更好
- 避免字符编码问题
```

### 8.2 常用POSIX字符类


| 字符类 | 等效表达 | 说明 | 示例用法 |
|-------|----------|------|----------|
| `[:alpha:]` | `[a-zA-Z]` | **字母字符** | 匹配用户名 |
| `[:digit:]` | `[0-9]` | **数字字符** | 匹配数值 |
| `[:alnum:]` | `[a-zA-Z0-9]` | **字母数字** | 匹配标识符 |
| `[:space:]` | `[ \t\n\r\f\v]` | **空白字符** | 处理格式 |
| `[:punct:]` | 标点符号 | **标点字符** | 清理文本 |
| `[:upper:]` | `[A-Z]` | **大写字母** | 格式检查 |
| `[:lower:]` | `[a-z]` | **小写字母** | 格式转换 |
| `[:word:]` | `[a-zA-Z0-9_]` | **单词字符** | 程序标识符 |

### 8.3 POSIX字符类的使用方法


**📝 基础使用语法**：
```bash
# 注意：POSIX字符类需要放在方括号内
[[:alpha:]]    ✓ 正确用法
[:alpha:]      ✗ 错误用法

# 实际示例
echo "Hello123World" | grep -E '[[:alpha:]]+'
# 结果：匹配 "Hello" 和 "World"
```

**🔍 常用模式示例**：
```bash
# 匹配纯字母单词
echo "Hello-World 123" | grep -oE '[[:alpha:]]+'
# 结果：Hello, World

# 匹配数字
echo "Price: $99.99" | grep -oE '[[:digit:]]+'  
# 结果：99, 99

# 匹配字母数字组合
echo "user123_name" | grep -E '^[[:alnum:]_]+$'
# 匹配成功
```

### 8.4 POSIX字符类的实用案例


**📄 文本清理**：
```bash
# 提取文本中的单词（只保留字母）
echo "Hello, World! 123" | grep -oE '[[:alpha:]]+'
# 结果：Hello World

# 提取所有数字
echo "Price $99.99, Discount 15%" | grep -oE '[[:digit:]]+'
# 结果：99 99 15
```

**📧 邮箱验证（简化版）**：
```bash
# 使用POSIX字符类的邮箱匹配
email_pattern='^[[:alnum:]._-]+@[[:alnum:].-]+\.[[:alpha:]]{2,}$'

echo "user.name@example.com" | grep -E "$email_pattern"  # ✓
echo "test@domain.co.uk" | grep -E "$email_pattern"      # ✓
echo "invalid@" | grep -E "$email_pattern"               # ✗
```

**🔐 密码强度检查**：
```bash
# 密码必须包含：大写字母、小写字母、数字
check_password() {
    local pwd="$1"
    
    # 检查是否包含小写字母
    echo "$pwd" | grep -q '[[:lower:]]' || return 1
    
    # 检查是否包含大写字母  
    echo "$pwd" | grep -q '[[:upper:]]' || return 1
    
    # 检查是否包含数字
    echo "$pwd" | grep -q '[[:digit:]]' || return 1
    
    echo "密码强度合格"
}

check_password "MyPassword123"  # 合格
check_password "mypassword"     # 不合格
```

### 8.5 POSIX字符类的高级用法


**🌍 国际化支持**：
```bash
# POSIX字符类能更好地处理不同语言
# 对于中文、日文等，[[:alpha:]]能正确识别

# 匹配文本中的标点符号
echo "你好，世界！Hello, World!" | grep -oE '[[:punct:]]'
# 结果：，！,
```

**🔄 与否定结合**：
```bash
# 匹配非字母字符
echo "Hello123World" | grep -oE '[^[:alpha:]]+'
# 结果：123

# 匹配非空白字符
echo "hello world" | grep -oE '[^[:space:]]+'
# 结果：hello world
```

**📊 数据提取**：
```bash
# 从日志中提取时间戳（假设格式为HH:MM:SS）
echo "2024-01-15 14:30:25 INFO: System started" | grep -oE '[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}'
# 结果：14:30:25

# 提取IP地址
echo "Connection from 192.168.1.100" | grep -oE '([[:digit:]]{1,3}\.){3}[[:digit:]]{1,3}'
# 结果：192.168.1.100
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 精确重复量词：{n} {n,} {n,m} 控制重复次数
🔸 分组操作：() 将多个字符组合处理
🔸 选择操作：| 实现"或"逻辑匹配
🔸 非贪婪匹配：*? +? ?? 避免过度匹配
🔸 否定字符类：[^...] 排除特定字符
🔸 组合范围：[a-zA-Z0-9] 多种字符类型
🔸 POSIX字符类：[[:alpha:]] 预定义字符集
```

### 9.2 关键理解要点


**🔹 量词的作用和选择**
```
使用原则：
- 确定次数用 {n}
- 至少几次用 {n,}  
- 范围控制用 {n,m}
- 记住：量词作用于前面的字符或组
```

**🔹 分组与选择的配合**
```
重要概念：
- () 创建组，| 创建选择
- (pattern1|pattern2) 整体选择
- pattern1|pattern2 可能产生歧义
- 用括号明确优先级很重要
```

**🔹 字符类的层次关系**
```
从简单到复杂：
[a-z]           基础范围
[a-zA-Z0-9]     组合范围
[[:alnum:]]     POSIX字符类
[^[:space:]]    否定POSIX类
```

### 9.3 实际应用指导


**🎯 选择合适的语法**
```
数据验证：
- 手机号 → 精确量词 {n}
- 邮箱 → 分组 + 字符类
- 密码 → 组合范围 + 长度限制

文本处理：
- 提取信息 → POSIX字符类
- 格式转换 → 分组捕获
- 内容清理 → 否定字符类
```

**🔧 工具选择建议**
```
Linux环境：
- 基础需求：grep -E
- 复杂需求：sed -E 或 awk
- 高级需求：Python/Perl脚本
- 非贪婪匹配：优先考虑Python
```

### 9.4 学习路径建议


**📚 循序渐进的掌握顺序**
```
第1阶段：掌握精确量词 {n,m}
↓
第2阶段：理解分组概念 ()
↓  
第3阶段：学会选择操作 |
↓
第4阶段：掌握字符类 [[:alpha:]]
↓
第5阶段：综合应用和实践
```

**💡 记忆技巧**
```
🧠 口诀记忆：
"花括号控数量，圆括号做分组"
"竖线表选择，方括号定字符"
"脱字符做否定，POSIX类最标准"

🔤 符号记忆：
{} = 数量控制器
() = 分组打包器  
|  = 选择分支器
[^] = 排除过滤器
[[:]] = 标准套餐
```

**⚠️ 常见陷阱提醒**
```
陷阱1：忘记转义
解决：使用 -E 选项或转义特殊字符

陷阱2：分组优先级错误
解决：多用括号明确优先级

陷阱3：贪婪匹配问题
解决：Linux环境下用字符类替代

陷阱4：字符编码问题
解决：优先使用POSIX字符类

陷阱5：否定字符类位置错误
解决：^ 必须在 [ 后面的第一个位置
```

### 9.5 实践建议


**🛠️ 动手练习**
1. **基础练习**：用不同量词匹配同一个文本
2. **分组练习**：提取邮箱的用户名和域名部分
3. **选择练习**：匹配多种日期格式
4. **综合练习**：写一个完整的数据验证脚本

**📖 进阶学习**
- 学习sed和awk中的正则应用
- 了解不同编程语言中的正则差异
- 掌握正则表达式性能优化技巧

**核心记忆**：
> 扩展正则表达式 = 更强大的模式匹配工具
> 量词精确控制，分组灵活处理，选择多样匹配
> 字符类标准化，POSIX更通用，否定来排除
> 工具选择要恰当，语法使用需规范