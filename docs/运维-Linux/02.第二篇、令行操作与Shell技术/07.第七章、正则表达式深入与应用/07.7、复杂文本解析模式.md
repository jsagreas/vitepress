---
title: 7、复杂文本解析模式
---
## 📚 目录

1. [嵌套结构匹配技术](#1-嵌套结构匹配技术)
2. [平衡括号处理](#2-平衡括号处理)
3. [多行模式应用](#3-多行模式应用)
4. [递归正则表达式](#4-递归正则表达式)
5. [状态机模拟](#5-状态机模拟)
6. [复杂分隔符处理](#6-复杂分隔符处理)
7. [格式化文本解析](#7-格式化文本解析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 嵌套结构匹配技术


### 1.1 什么是嵌套结构


**💡 简单理解**：嵌套结构就像俄罗斯套娃一样，一个结构里面包含另一个结构。在文本中，常见的嵌套结构有：

```
HTML标签嵌套：
<div>
  <p>段落内容</p>
  <span>行内文本</span>
</div>

JSON数据嵌套：
{
  "user": {
    "name": "张三",
    "address": {
      "city": "北京",
      "street": "长安街1号"
    }
  }
}

括号表达式嵌套：
((a + b) * (c - d))
```

### 1.2 嵌套结构的特点


**🔸 核心特征**
- **层级关系**：内层结构被外层结构包围
- **对称性**：开始标记和结束标记成对出现
- **递归性**：结构可以无限嵌套下去

**🔸 匹配难点**
```
为什么普通正则难以处理嵌套：

问题示例：匹配 <div>...</div> 标签
错误写法：<div>.*</div>
问题：会匹配到第一个<div>和最后一个</div>

<div>外层<div>内层</div>还是外层</div>
     ↑____________________↑
     这样匹配是错误的！
```

### 1.3 基础嵌套匹配方法


**🛠️ 方法一：非贪婪匹配**
```bash
# 匹配最内层的标签（适用于简单情况）
echo '<div>外层<span>内层</span>外层</div>' | grep -oE '<[^>]+>.*?</[^>]+>'

# 说明：.*? 表示非贪婪匹配，尽可能少地匹配字符
```

**🛠️ 方法二：否定字符类**
```bash
# 匹配不包含特定字符的内容
echo 'func(arg1, func(arg2))' | grep -oE '\w+\([^()]*\)'

# [^()]* 表示匹配任意非括号字符
# 这样可以避免跨越括号边界
```

**🛠️ 方法三：分步处理**
```bash
# 先提取外层结构
text='<div class="outer"><p>内容</p><span>文本</span></div>'

# 第一步：提取div标签
echo "$text" | grep -o '<div[^>]*>.*</div>'

# 第二步：提取内部标签
echo "$text" | grep -oE '<[^/][^>]*>[^<]*</[^>]*>'
```

---

## 2. ⚖️ 平衡括号处理


### 2.1 什么是平衡括号


**💡 通俗解释**：平衡括号就像天平一样，左边的开括号和右边的闭括号要配对平衡。

```
平衡的例子：
✅ ()
✅ (())
✅ ((()))
✅ ()(())

不平衡的例子：
❌ (
❌ )
❌ (()
❌ ())
```

### 2.2 平衡括号的挑战


**🔸 核心问题**
```
普通正则表达式的困境：

表达式：((a + b) * (c - d))
│ │     │       │     │ │
│ │     └───────┘     │ │
│ └─────────────────────┘ │
└─────────────────────────┘

如何确保每个开括号都有对应的闭括号？
传统正则：\(.*\) 会匹配不正确
```

### 2.3 计数法处理平衡括号


**🛠️ Shell脚本实现**
```bash
#!/bin/bash
# 检查括号是否平衡
check_balanced_parentheses() {
    local text="$1"
    local count=0
    local i=0
    
    while [ $i -lt ${#text} ]; do
        char="${text:$i:1}"
        case "$char" in
            '(') ((count++)) ;;
            ')') 
                ((count--))
                if [ $count -lt 0 ]; then
                    echo "❌ 不平衡：闭括号过多"
                    return 1
                fi
                ;;
        esac
        ((i++))
    done
    
    if [ $count -eq 0 ]; then
        echo "✅ 括号平衡"
        return 0
    else
        echo "❌ 不平衡：开括号过多"
        return 1
    fi
}

# 测试示例
check_balanced_parentheses "((a + b) * c)"  # ✅ 平衡
check_balanced_parentheses "((a + b) * c"   # ❌ 不平衡
```

### 2.4 提取平衡括号内容


**🛠️ 实用脚本**
```bash
#!/bin/bash
# 提取最外层平衡括号的内容
extract_balanced_content() {
    local text="$1"
    local start_pos=-1
    local count=0
    local i=0
    
    while [ $i -lt ${#text} ]; do
        char="${text:$i:1}"
        case "$char" in
            '(')
                if [ $count -eq 0 ]; then
                    start_pos=$i
                fi
                ((count++))
                ;;
            ')')
                ((count--))
                if [ $count -eq 0 ] && [ $start_pos -ge 0 ]; then
                    # 找到了一个完整的平衡结构
                    local length=$((i - start_pos + 1))
                    echo "${text:$start_pos:$length}"
                    start_pos=-1
                fi
                ;;
        esac
        ((i++))
    done
}

# 示例使用
text="前面文字(第一组(嵌套内容))中间文字(第二组)后面文字"
extract_balanced_content "$text"
# 输出：
# (第一组(嵌套内容))
# (第二组)
```

---

## 3. 📄 多行模式应用


### 3.1 什么是多行模式


**💡 简单理解**：多行模式就是让正则表达式能够跨越多行进行匹配，而不是只在单行内查找。

```
单行模式 vs 多行模式：

文本示例：
第一行内容
第二行内容
第三行内容

单行模式：每行独立处理
多行模式：把所有行当作一个整体处理
```

### 3.2 多行模式的应用场景


**🎯 常见使用场景**
```
📝 配置文件解析：
[section1]
key1=value1
key2=value2

📝 日志文件分析：
2024-01-15 10:30:00 INFO Starting application
2024-01-15 10:30:01 DEBUG Loading configuration
2024-01-15 10:30:02 ERROR Connection failed
    Stack trace follows...
    at line 123

📝 代码块提取：
function myFunction() {
    // 函数内容
    return result;
}
```

### 3.3 多行匹配的实现方法


**🛠️ 方法一：使用sed多行处理**
```bash
# 匹配多行的函数定义
sed -n '/^function/,/^}$/p' script.js

# 说明：
# /^function/ - 匹配以function开头的行
# /^}$/ - 匹配只有}的行
# 两者之间的所有行都会被匹配
```

**🛠️ 方法二：使用awk多行处理**
```bash
# 提取多行的配置块
awk '
/^\[.*\]$/ { 
    section = 1; 
    print $0; 
    next 
}
section && /^$/ { 
    section = 0 
}
section { 
    print $0 
}
' config.ini

# 解释：
# /^\[.*\]$/ - 匹配配置节标题如[section]
# section变量跟踪是否在配置节内
# 空行时结束当前配置节
```

**🛠️ 方法三：使用grep多行匹配**
```bash
# 使用-A和-B选项匹配上下文
grep -A 5 -B 2 "ERROR" logfile.log

# -A 5: 匹配后的5行
# -B 2: 匹配前的2行
# 这样可以获取错误的上下文信息
```

### 3.4 复杂多行文本解析示例


**🛠️ 解析邮件格式**
```bash
#!/bin/bash
# 解析邮件头信息
parse_email() {
    local file="$1"
    
    # 提取发件人信息（可能跨多行）
    awk '
    BEGIN { in_from = 0 }
    /^From:/ { 
        in_from = 1
        from_line = $0
        next
    }
    /^[A-Za-z-]+:/ && in_from {
        in_from = 0
        print from_line
        from_line = ""
    }
    in_from {
        from_line = from_line " " $0
    }
    END {
        if (from_line) print from_line
    }
    ' "$file"
}

# 示例邮件内容：
# From: John Doe <john.doe@example.com>
#   (Additional info on next line)
# To: jane@example.com
# Subject: Important Message
```

---

## 4. 🔄 递归正则表达式


### 4.1 什么是递归正则表达式


**💡 通俗解释**：递归正则就像函数调用自己一样，正则表达式可以引用自身来处理嵌套结构。

```
递归的概念类比：

数学中的阶乘：
n! = n × (n-1)!
函数调用自己

递归正则：
括号匹配 = "(" + 括号匹配 + ")" | 普通内容
模式引用自己
```

### 4.2 递归正则的应用场景


**🎯 适用情况**
- **JSON/XML解析**：处理任意深度的嵌套
- **数学表达式**：处理括号嵌套
- **编程语言解析**：处理代码块嵌套
- **HTML标签匹配**：处理标签嵌套

### 4.3 PCRE递归语法


**🔸 基础语法**
```bash
# PCRE递归语法（Perl兼容正则）
(?R)    # 递归调用整个模式
(?1)    # 递归调用第一个捕获组
(?2)    # 递归调用第二个捕获组

# 注意：标准的grep不支持递归，需要使用pcregrep
```

**🛠️ 平衡括号的递归匹配**
```bash
# 使用pcregrep匹配平衡括号
echo "((a+b)*(c+d))" | pcregrep '\((?:[^()]|(?R))*\)'

# 解释：
# \(              - 匹配开括号
# (?:             - 开始非捕获组
#   [^()]         - 匹配非括号字符 或
#   |             - 或
#   (?R)          - 递归调用整个模式
# )*              - 重复0次或多次
# \)              - 匹配闭括号
```

### 4.4 实用的递归解析脚本


**🛠️ JSON结构验证**
```bash
#!/bin/bash
# 使用递归思想验证简单JSON结构
validate_json_structure() {
    local text="$1"
    local level=0
    local i=0
    local in_string=false
    
    while [ $i -lt ${#text} ]; do
        char="${text:$i:1}"
        
        # 跳过字符串内容
        if [ "$char" = '"' ]; then
            in_string=$(!$in_string)
        fi
        
        if [ "$in_string" = false ]; then
            case "$char" in
                '{' | '[') ((level++)) ;;
                '}' | ']') 
                    ((level--))
                    if [ $level -lt 0 ]; then
                        echo "❌ 结构不平衡"
                        return 1
                    fi
                    ;;
            esac
        fi
        ((i++))
    done
    
    if [ $level -eq 0 ]; then
        echo "✅ JSON结构平衡"
        return 0
    else
        echo "❌ 结构不完整"
        return 1
    fi
}

# 测试
validate_json_structure '{"user": {"name": "张三", "age": 30}}'
```

---

## 5. 🔧 状态机模拟


### 5.1 什么是状态机


**💡 生活中的状态机**：状态机就像红绿灯一样，有不同的状态（红、黄、绿），根据条件在状态间切换。

```
红绿灯状态机：
红灯 → 绿灯 → 黄灯 → 红灯
 ↑              ↓
 └──────────────┘

文本解析状态机：
正常文本 → 进入引号 → 引号内容 → 退出引号
    ↑                              ↓
    └──────────────────────────────┘
```

### 5.2 文本解析中的状态机


**🔸 常见状态类型**
- **NORMAL**：正常文本状态
- **IN_QUOTE**：在引号内
- **IN_COMMENT**：在注释内
- **ESCAPE**：转义字符状态

### 5.3 状态机解析CSV文件


**🛠️ CSV解析器**
```bash
#!/bin/bash
# 使用状态机解析CSV文件
parse_csv() {
    local line="$1"
    local state="NORMAL"
    local field=""
    local fields=()
    local i=0
    
    while [ $i -lt ${#line} ]; do
        char="${line:$i:1}"
        
        case "$state" in
            "NORMAL")
                case "$char" in
                    ',') 
                        fields+=("$field")
                        field=""
                        ;;
                    '"') 
                        state="IN_QUOTE"
                        ;;
                    *) 
                        field="$field$char"
                        ;;
                esac
                ;;
                
            "IN_QUOTE")
                case "$char" in
                    '"') 
                        # 检查是否是转义的引号
                        if [ $((i+1)) -lt ${#line} ] && [ "${line:$((i+1)):1}" = '"' ]; then
                            field="$field\""
                            ((i++))  # 跳过下一个引号
                        else
                            state="NORMAL"
                        fi
                        ;;
                    *) 
                        field="$field$char"
                        ;;
                esac
                ;;
        esac
        ((i++))
    done
    
    # 添加最后一个字段
    fields+=("$field")
    
    # 输出解析结果
    for i in "${!fields[@]}"; do
        echo "字段$((i+1)): ${fields[$i]}"
    done
}

# 测试复杂CSV行
parse_csv 'John,"Doe, Jr.",30,"He said ""Hello""",Manager'
```

### 5.4 配置文件解析状态机


**🛠️ INI文件解析器**
```bash
#!/bin/bash
# 解析INI配置文件
parse_ini() {
    local file="$1"
    local state="NORMAL"
    local section=""
    
    while IFS= read -r line; do
        # 去除前后空格
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # 跳过空行和注释
        if [[ -z "$line" || "$line" =~ ^[#;] ]]; then
            continue
        fi
        
        case "$state" in
            "NORMAL")
                if [[ "$line" =~ ^\[.*\]$ ]]; then
                    # 节标题
                    section=$(echo "$line" | sed 's/\[//;s/\]//')
                    echo "🏷️ 节：$section"
                    state="IN_SECTION"
                fi
                ;;
                
            "IN_SECTION")
                if [[ "$line" =~ ^\[.*\]$ ]]; then
                    # 新的节
                    section=$(echo "$line" | sed 's/\[//;s/\]//')
                    echo "🏷️ 节：$section"
                elif [[ "$line" =~ ^[^=]+=.*$ ]]; then
                    # 键值对
                    key=$(echo "$line" | cut -d'=' -f1 | sed 's/[[:space:]]*$//')
                    value=$(echo "$line" | cut -d'=' -f2- | sed 's/^[[:space:]]*//')
                    echo "  📝 $key = $value"
                fi
                ;;
        esac
    done < "$file"
}

# 示例INI文件内容：
# [database]
# host = localhost
# port = 3306
# 
# [cache]
# type = redis
# ttl = 3600
```

---

## 6. ✂️ 复杂分隔符处理


### 6.1 什么是复杂分隔符


**💡 简单理解**：复杂分隔符就是不只是简单的逗号或空格，可能有多种形式、嵌套或者有转义的分隔符。

```
简单分隔符：
a,b,c,d          (逗号分隔)
a b c d          (空格分隔)

复杂分隔符：
a,"b,c",d        (引号内的逗号不是分隔符)
a::b::c          (多字符分隔符)
a\,b,c           (转义的逗号不是分隔符)
a|b||c           (重复分隔符需要处理)
```

### 6.2 处理引号内容的分隔符


**🛠️ 智能分割函数**
```bash
#!/bin/bash
# 处理包含引号的复杂分隔符
smart_split() {
    local text="$1"
    local delimiter="${2:-,}"
    local in_quote=false
    local current_field=""
    local result=()
    local i=0
    
    while [ $i -lt ${#text} ]; do
        char="${text:$i:1}"
        
        case "$char" in
            '"')
                if [ "$in_quote" = true ]; then
                    in_quote=false
                else
                    in_quote=true
                fi
                current_field="$current_field$char"
                ;;
            "$delimiter")
                if [ "$in_quote" = false ]; then
                    result+=("$current_field")
                    current_field=""
                else
                    current_field="$current_field$char"
                fi
                ;;
            *)
                current_field="$current_field$char"
                ;;
        esac
        ((i++))
    done
    
    # 添加最后一个字段
    result+=("$current_field")
    
    # 输出结果
    printf '%s\n' "${result[@]}"
}

# 测试示例
smart_split 'name,"city,state",age' ','
# 输出：
# name
# "city,state"
# age
```

### 6.3 多字符分隔符处理


**🛠️ 多字符分隔符分割**
```bash
#!/bin/bash
# 处理多字符分隔符
multi_char_split() {
    local text="$1"
    local delimiter="$2"
    local delimiter_len=${#delimiter}
    
    # 使用sed替换分隔符为特殊标记，然后分割
    echo "$text" | sed "s/$delimiter/\n/g"
}

# 或者使用更复杂的方法
advanced_multi_split() {
    local text="$1"
    local delimiter="$2"
    local pos=0
    local start=0
    
    while true; do
        # 查找下一个分隔符位置
        pos=$(echo "$text" | grep -b -o "$delimiter" | head -1 | cut -d: -f1)
        
        if [ -z "$pos" ]; then
            # 没有更多分隔符，输出剩余部分
            echo "${text:$start}"
            break
        fi
        
        # 输出当前字段
        echo "${text:$start:$((pos-start))}"
        
        # 更新起始位置
        start=$((pos + ${#delimiter}))
        text="${text:$start}"
        start=0
    done
}

# 测试
advanced_multi_split "field1::field2::field3" "::"
```

### 6.4 转义字符处理


**🛠️ 处理转义的分隔符**
```bash
#!/bin/bash
# 处理转义字符的分隔符
escape_aware_split() {
    local text="$1"
    local delimiter="$2"
    local escape_char="\\"
    local result=()
    local current=""
    local i=0
    local escaped=false
    
    while [ $i -lt ${#text} ]; do
        char="${text:$i:1}"
        
        if [ "$escaped" = true ]; then
            # 前一个字符是转义符
            current="$current$char"
            escaped=false
        elif [ "$char" = "$escape_char" ]; then
            # 当前字符是转义符
            escaped=true
        elif [ "$char" = "$delimiter" ]; then
            # 未转义的分隔符
            result+=("$current")
            current=""
        else
            # 普通字符
            current="$current$char"
        fi
        
        ((i++))
    done
    
    result+=("$current")
    printf '%s\n' "${result[@]}"
}

# 测试转义分隔符
escape_aware_split "field1,field\,2,field3" ","
# 输出：
# field1
# field,2
# field3
```

---

## 7. 📊 格式化文本解析


### 7.1 什么是格式化文本


**💡 生活中的格式化文本**：就像表格、报告、配置文件这些有固定格式的文本。

```
常见的格式化文本：

📋 表格格式：
Name    Age   City
John    25    Beijing
Mary    30    Shanghai

📋 日志格式：
[2024-01-15 10:30:00] INFO: Application started
[2024-01-15 10:30:01] ERROR: Connection failed

📋 配置格式：
server.host = localhost
server.port = 8080
database.url = jdbc:mysql://localhost/mydb
```

### 7.2 固定宽度文本解析


**🛠️ 固定宽度字段提取**
```bash
#!/bin/bash
# 解析固定宽度格式的文本
parse_fixed_width() {
    local line="$1"
    
    # 定义字段位置和宽度
    local name_start=0 name_width=10
    local age_start=10 age_width=5
    local city_start=15 city_width=15
    
    # 提取字段（去除前后空格）
    name=$(echo "${line:$name_start:$name_width}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    age=$(echo "${line:$age_start:$age_width}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    city=$(echo "${line:$city_start:$city_width}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    echo "姓名: $name"
    echo "年龄: $age"
    echo "城市: $city"
    echo "---"
}

# 处理整个文件
while IFS= read -r line; do
    # 跳过标题行
    if [[ ! "$line" =~ ^Name ]]; then
        parse_fixed_width "$line"
    fi
done < data.txt
```

### 7.3 键值对格式解析


**🛠️ 属性文件解析器**
```bash
#!/bin/bash
# 解析属性文件格式
parse_properties() {
    local file="$1"
    declare -A properties
    
    while IFS= read -r line; do
        # 跳过注释和空行
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            continue
        fi
        
        # 检查是否是键值对格式
        if [[ "$line" =~ ^[^=]+= ]]; then
            # 分割键和值
            key=$(echo "$line" | cut -d'=' -f1 | sed 's/[[:space:]]*$//')
            value=$(echo "$line" | cut -d'=' -f2- | sed 's/^[[:space:]]*//')
            
            # 处理多级键名
            if [[ "$key" =~ \. ]]; then
                section=$(echo "$key" | cut -d'.' -f1)
                subkey=$(echo "$key" | cut -d'.' -f2-)
                echo "🏷️ [$section] $subkey = $value"
            else
                echo "📝 $key = $value"
            fi
            
            properties["$key"]="$value"
        fi
    done < "$file"
}

# 示例配置文件内容：
# # 服务器配置
# server.host = localhost
# server.port = 8080
# 
# # 数据库配置  
# database.url = jdbc:mysql://localhost/mydb
# database.username = admin
```

### 7.4 JSON格式简单解析


**🛠️ 简单JSON解析器**
```bash
#!/bin/bash
# 简单的JSON解析（仅处理基本结构）
parse_simple_json() {
    local json="$1"
    
    # 去除花括号和空格
    json=$(echo "$json" | sed 's/[{}]//g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    # 分割键值对
    IFS=',' read -ra pairs <<< "$json"
    
    for pair in "${pairs[@]}"; do
        # 去除空格
        pair=$(echo "$pair" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # 分割键和值
        if [[ "$pair" =~ : ]]; then
            key=$(echo "$pair" | cut -d':' -f1 | sed 's/"//g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            value=$(echo "$pair" | cut -d':' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # 处理字符串值（去除引号）
            if [[ "$value" =~ ^\".*\"$ ]]; then
                value=$(echo "$value" | sed 's/^"//;s/"$//')
            fi
            
            echo "📝 $key: $value"
        fi
    done
}

# 测试简单JSON
parse_simple_json '{"name": "张三", "age": 30, "city": "北京"}'
# 输出：
# 📝 name: 张三  
# 📝 age: 30
# 📝 city: 北京
```

### 7.5 表格格式数据处理


**🛠️ 表格数据分析器**
```bash
#!/bin/bash
# 分析表格格式的数据
analyze_table() {
    local file="$1"
    local line_num=0
    local header=()
    
    while IFS= read -r line; do
        ((line_num++))
        
        if [ $line_num -eq 1 ]; then
            # 处理表头
            IFS=$'\t' read -ra header <<< "$line"
            echo "🏷️ 表格列数: ${#header[@]}"
            echo "📋 列标题:"
            for i in "${!header[@]}"; do
                echo "  $((i+1)). ${header[$i]}"
            done
            echo "---"
        else
            # 处理数据行
            IFS=$'\t' read -ra fields <<< "$line"
            echo "📊 第$((line_num-1))行数据:"
            for i in "${!fields[@]}"; do
                if [ $i -lt ${#header[@]} ]; then
                    echo "  ${header[$i]}: ${fields[$i]}"
                fi
            done
            echo "---"
        fi
    done < "$file"
}

# 使用示例
# echo -e "Name\tAge\tCity\nJohn\t25\tBeijing\nMary\t30\tShanghai" | analyze_table /dev/stdin
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 嵌套结构处理**
```
💡 核心思想：层层剥离，逐步处理
🛠️ 基本方法：计数法、状态机、递归思想
⚡ 实用技巧：非贪婪匹配、否定字符类
```

**🔸 平衡括号技术**
```
💡 核心原理：开闭标记要配对平衡
🛠️ 实现方式：计数器跟踪、栈结构模拟
⚡ 应用场景：表达式解析、代码块提取
```

**🔸 多行模式应用**
```
💡 核心概念：跨行匹配和处理
🛠️ 工具选择：sed多行、awk状态、grep上下文
⚡ 使用场景：配置文件、日志分析、代码提取
```

### 8.2 实用技能清单


**☑️ 文本解析技能**
- 能够识别和处理嵌套结构
- 掌握平衡括号的匹配方法
- 熟练使用多行模式解析
- 理解状态机在文本处理中的应用

**☑️ 复杂分隔符处理**
- 处理引号内容的分隔符
- 应对多字符分隔符场景
- 正确处理转义字符
- 实现智能分割功能

**☑️ 格式化文本解析**
- 固定宽度字段提取
- 键值对格式解析
- 简单结构化数据处理
- 表格数据分析

### 8.3 学习路径建议


**🎯 初级阶段**
1. 掌握基本的嵌套匹配
2. 理解括号平衡原理
3. 学会使用多行工具

**🔥 中级阶段**  
1. 熟练使用状态机思想
2. 处理复杂分隔符场景
3. 解析常见格式化文本

**💀 高级阶段**
1. 编写递归解析脚本
2. 处理任意复杂的嵌套
3. 构建通用解析框架

### 8.4 实战应用指南


**📝 日常工作场景**
```
🔸 日志文件分析：多行错误信息提取
🔸 配置文件处理：嵌套配置项解析  
🔸 数据文件清洗：复杂分隔符处理
🔸 代码文件分析：函数块、类定义提取
```

**⚠️ 注意事项**
```
🔸 性能考虑：复杂正则会影响处理速度
🔸 兼容性：递归正则需要特定工具支持
🔸 可读性：过于复杂的模式要加注释
🔸 测试验证：复杂解析逻辑需要充分测试
```

**核心记忆**：
- 嵌套结构用计数法，层层递进不慌乱
- 平衡括号要配对，开闭标记仔细算  
- 多行模式跨行找，状态切换是关键
- 复杂分隔需智能，转义引号要考虑
- 格式文本有规律，提取字段按位置