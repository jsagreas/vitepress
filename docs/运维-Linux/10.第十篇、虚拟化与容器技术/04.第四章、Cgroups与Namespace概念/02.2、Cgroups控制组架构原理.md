---
title: 2、Cgroups控制组架构原理
---
## 📚 目录

1. [Control Groups基本概念与作用](#1-Control-Groups基本概念与作用)
2. [cgroups v1与v2版本差异](#2-cgroups-v1与v2版本差异)
3. [层次化资源管理结构](#3-层次化资源管理结构)
4. [cgroups子系统分类与功能](#4-cgroups子系统分类与功能)
5. [资源控制器概念详解](#5-资源控制器概念详解)
6. [cgroups文件系统挂载点](#6-cgroups文件系统挂载点)
7. [进程与cgroups关联机制](#7-进程与cgroups关联机制)
8. [cgroups继承关系](#8-cgroups继承关系)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 Control Groups基本概念与作用


### 1.1 什么是Control Groups

**Cgroups（Control Groups）**就是Linux内核提供的"资源管家"，专门负责管理和限制进程组的系统资源使用。

> **💡 核心理解**  
> Cgroups = 给进程划分"资源配额"，就像给不同部门分配预算一样

**🔸 生活化类比：**
```
公司资源分配：
├── 研发部门：70%CPU + 4GB内存
├──测试部门：20%CPU + 2GB内存  
└── 运维部门：10%CPU + 1GB内存

系统资源分配：
├── Web服务：60%CPU + 2GB内存
├── 数据库：30%CPU + 4GB内存
└── 监控程序：10%CPU + 512MB内存
```

### 1.2 Cgroups解决的核心问题


**⚠️ 没有Cgroups的问题：**
- **资源争抢**：某个程序可能占用全部CPU，导致系统卡死
- **无法控制**：不能限制特定程序的内存使用
- **不公平调度**：重要服务可能被其他程序"饿死"

**✅ Cgroups提供的解决方案：**
- **资源隔离**：每个进程组有独立的资源配额
- **精确控制**：可以精确限制CPU、内存、网络等资源
- **优先级管理**：重要服务获得更多资源保障
- **监控统计**：实时查看各进程组的资源使用情况

### 1.3 Cgroups的核心功能


**📊 主要功能特性：**

| 功能类别 | **具体能力** | **实际应用** |
|----------|-------------|-------------|
| 🔒 **资源限制** | 限制CPU、内存、磁盘IO | 防止单个服务占用过多资源 |
| 📈 **资源监控** | 统计资源使用情况 | 性能分析和容量规划 |
| 🎛️ **资源分配** | 按比例分配系统资源 | 确保关键服务获得足够资源 |
| 🏷️ **进程分组** | 将相关进程组织管理 | 批量管理相关进程 |

---

## 2. 🔄 cgroups v1与v2版本差异


### 2.1 版本演进背景


**历史发展：**
- **v1版本**：2008年引入，功能分散，管理复杂
- **v2版本**：2016年开始，统一架构，简化管理

> **🔍 核心差异**  
> v1 = 多个独立的子系统，v2 = 统一的层次结构

### 2.2 架构对比分析


**🏗️ Cgroups v1架构：**
```
独立子系统模式：
/sys/fs/cgroup/
├── cpu/          ← CPU控制器独立挂载
├── memory/       ← 内存控制器独立挂载  
├── blkio/        ← 块设备IO独立挂载
├── net_cls/      ← 网络分类独立挂载
└── ...

问题：每个子系统有自己的进程层次树
```

**🏗️ Cgroups v2架构：**
```
统一层次模式：
/sys/fs/cgroup/
├── cgroup.controllers    ← 可用控制器列表
├── cgroup.subtree_control ← 启用的控制器
├── app1/                ← 应用组1
│   ├── cpu.max          ← CPU限制配置  
│   └── memory.max       ← 内存限制配置
└── app2/                ← 应用组2
    ├── cpu.weight       ← CPU权重配置
    └── memory.high      ← 内存软限制
```

### 2.3 关键差异对比


**📋 详细对比表：**

| 对比维度 | **Cgroups v1** | **Cgroups v2** | **影响** |
|----------|----------------|----------------|----------|
| **层次结构** | 多个独立层次树 | 单一统一层次树 | v2更简洁易管理 |
| **进程分组** | 可在不同子系统中分组 | 必须在同一层次中 | v2避免冲突 |
| **控制器挂载** | 独立挂载点 | 统一挂载点 | v2减少复杂性 |
| **配置接口** | 每个子系统不同 | 标准化接口 | v2一致性更好 |
| **性能优化** | 分散管理开销大 | 集中管理效率高 | v2性能更优 |

### 2.4 版本选择建议


**🎯 实际应用指导：**
- **新系统推荐**：优先选择 cgroups v2
- **容器环境**：Docker、Kubernetes 逐步迁移到 v2  
- **兼容考虑**：老系统可继续使用 v1，逐步规划迁移

---

## 3. 🌳 层次化资源管理结构


### 3.1 层次结构基本概念


**层次化管理**就是把系统资源像"组织架构"一样分层管理，上级控制下级的资源分配。

```
企业组织架构类比：
公司总部(100%)
├── 技术部(70%)
│   ├── 前端组(30%)
│   └── 后端组(40%)  
├── 市场部(20%)
└── 财务部(10%)

Cgroups层次结构：
根cgroup(系统全部资源)
├── system.slice(系统服务)
│   ├── sshd.service
│   └── nginx.service
├── user.slice(用户服务)  
│   ├── user-1000.slice
│   └── user-1001.slice
└── machine.slice(虚拟机容器)
```

### 3.2 层次关系的核心规则


**🔸 资源继承规则：**
- **父级限制**：子cgroup不能超过父cgroup的资源限制
- **资源分配**：父级资源按比例或绝对值分配给子级  
- **递归影响**：对父级的限制会影响所有子级

**📝 实际示例：**
```
根cgroup: CPU=4核
├── webserver: CPU=2核(50%)
│   ├── nginx: CPU=1核
│   └── php-fpm: CPU=1核
└── database: CPU=2核(50%)
    └── mysql: CPU=2核
```

### 3.3 层次操作的基本原则


**⚡ 管理原则：**
- **自上而下**：先创建父级，再创建子级
- **资源约束**：子级资源总和不能超过父级限制
- **动态调整**：可以在运行时调整资源分配
- **空组清理**：没有进程的cgroup会被自动删除

---

## 4. 🔧 cgroups子系统分类与功能


### 4.1 子系统概念解释


**子系统（Subsystem）**就是cgroups中负责管理特定类型资源的模块，每种资源都有专门的"管理员"。

> **🧠 记忆技巧**  
> 每个子系统 = 一个专业的"资源管理员"，各司其职

### 4.2 主要子系统功能详解


**🖥️ CPU相关子系统：**

**`cpu`子系统：**
- **作用**：控制CPU时间分配和使用比例
- **核心参数**：`cpu.shares`（CPU权重）、`cpu.cfs_quota_us`（CPU配额）
- **应用场景**：限制web服务占用CPU不超过50%

**`cpuset`子系统：**  
- **作用**：指定进程可以使用哪些CPU核心和内存节点
- **核心参数**：`cpuset.cpus`（CPU核心列表）、`cpuset.mems`（内存节点）
- **应用场景**：将数据库绑定到特定CPU核心运行

**💾 内存相关子系统：**

**`memory`子系统：**
- **作用**：限制和监控内存使用
- **核心参数**：`memory.limit_in_bytes`（内存限制）、`memory.usage_in_bytes`（当前使用）
- **应用场景**：防止应用内存泄漏影响系统

**📁 存储相关子系统：**

**`blkio`子系统：**
- **作用**：控制块设备IO带宽和IOPS
- **核心参数**：`blkio.throttle.read_bps_device`（读取带宽限制）
- **应用场景**：限制备份程序的磁盘IO，避免影响在线服务

### 4.3 子系统功能对比


**📊 子系统能力矩阵：**

| 子系统名称 | **管理资源** | **主要功能** | **典型应用** |
|-----------|-------------|-------------|-------------|
| `cpu` | CPU时间 | 时间片分配、使用比例控制 | Web服务资源分配 |
| `cpuset` | CPU亲和性 | 指定CPU核心和内存节点 | 数据库性能优化 |
| `memory` | 物理内存 | 内存限制、OOM控制 | 防止内存泄漏 |
| `blkio` | 磁盘IO | 带宽和IOPS限制 | 备份任务IO控制 |
| `devices` | 设备访问 | 设备白名单控制 | 容器设备权限 |
| `freezer` | 进程状态 | 暂停/恢复进程组 | 调试和维护 |
| `net_cls` | 网络分类 | 网络流量标记 | QoS流量控制 |

---

## 5. 🎛️ 资源控制器概念详解


### 5.1 控制器基本概念


**资源控制器（Controller）**是cgroups中实现具体资源管理功能的核心组件，相当于"资源管理的执行者"。

> **💡 理解要点**  
> 子系统 = 资源管理的框架，控制器 = 具体的管理实现

### 5.2 控制器工作机制


**🔄 控制器运作流程：**
```
用户配置 → 控制器解析 → 内核策略 → 资源分配 → 实时监控

具体例子：
用户设置: echo "1073741824" > memory.limit_in_bytes
↓
memory控制器: 解析为1GB内存限制  
↓
内核策略: 当进程申请内存时检查限制
↓
资源分配: 超限则拒绝分配或触发OOM
↓
实时监控: 持续跟踪内存使用情况
```

### 5.3 常用控制器详解


**🖥️ CPU控制器关键参数：**

**CPU份额控制：**
- `cpu.shares`：**相对权重值**（默认1024）
- **计算公式**：实际CPU时间 = shares值 / 总shares值 × 总CPU时间
- **实际应用**：web服务设置2048，数据库设置1024，则web获得2/3的CPU时间

**CPU配额控制：**
- `cpu.cfs_quota_us`：**绝对时间限制**（微秒）
- `cpu.cfs_period_us`：**统计周期**（默认100000微秒=100毫秒）
- **限制计算**：CPU使用率 = quota / period × 100%

**💾 Memory控制器关键参数：**
- `memory.limit_in_bytes`：**硬限制**（超过触发OOM killer）
- `memory.soft_limit_in_bytes`：**软限制**（内存紧张时优先回收）
- `memory.usage_in_bytes`：**当前使用量**（只读，用于监控）

---

## 6. 📁 cgroups文件系统挂载点


### 6.1 文件系统挂载概念


**Cgroups文件系统**就是内核把资源管理功能"包装"成文件和目录的形式，让用户可以像操作文件一样管理资源。

> **🔍 核心理解**  
> 一切皆文件：资源限制 = 写文件，资源查看 = 读文件

### 6.2 标准挂载点位置


**📍 系统默认挂载点：**
```
/sys/fs/cgroup/          ← cgroups根目录
├── systemd/             ← systemd管理的cgroups
├── cpu,cpuacct/         ← CPU相关控制  
├── memory/              ← 内存控制
├── blkio/               ← 块设备IO控制
├── devices/             ← 设备访问控制
├── freezer/             ← 进程冻结控制
├── net_cls,net_prio/    ← 网络控制
├── perf_event/          ← 性能监控
├── pids/                ← 进程数限制
└── unified/             ← cgroups v2统一层次
```

### 6.3 挂载点查看与管理


**⚡ 实用命令操作：**
```bash
# 查看当前挂载的cgroups
mount | grep cgroup

# 查看可用的cgroups子系统
cat /proc/cgroups

# 查看某个进程所属的cgroups
cat /proc/[PID]/cgroup
```

**📋 输出示例解读：**
```bash
$ cat /proc/cgroups
subsys_name    hierarchy    num_cgroups    enabled
cpuset         2            1              1
cpu            3            64             1  
cpuacct        3            64             1
memory         4            90             1
devices        5            64             1
freezer        6            1              1
```

### 6.4 手动挂载操作


**🔧 手动挂载示例：**
```bash
# 创建挂载点目录
mkdir -p /mnt/cgroup/cpu

# 挂载CPU子系统
mount -t cgroup -o cpu cpu /mnt/cgroup/cpu

# 验证挂载成功
ls /mnt/cgroup/cpu
# 输出：cgroup.clone_children  cgroup.procs  cpu.shares  tasks...
```

---

## 7. 🔗 进程与cgroups关联机制


### 7.1 关联关系基本原理


**进程与cgroups的关系**就像"员工与部门"的关系，每个进程都必须"归属"到某个cgroups中接受资源管理。

> **📝 重要规则**  
> 每个进程必须且只能属于每个子系统的一个cgroup

### 7.2 进程关联的实现方式


**🔸 关联建立过程：**
```
创建cgroup → 配置资源限制 → 添加进程PID → 资源限制生效

实际操作流程：
1. mkdir /sys/fs/cgroup/cpu/webserver    # 创建cgroup
2. echo 512 > /sys/fs/cgroup/cpu/webserver/cpu.shares  # 设置权重
3. echo 1234 > /sys/fs/cgroup/cpu/webserver/tasks      # 添加进程
4. 进程1234开始受到CPU资源限制
```

### 7.3 进程管理关键文件


**📄 核心管理文件：**

**`tasks`文件：**
- **作用**：包含当前cgroup中所有**线程ID**的列表
- **操作**：向此文件写入TID来添加线程
- **特点**：一个进程的不同线程可能在不同cgroup中

**`cgroup.procs`文件：**
- **作用**：包含当前cgroup中所有**进程ID**的列表  
- **操作**：向此文件写入PID来添加整个进程
- **特点**：添加进程时，其所有线程都会一起移动

### 7.4 进程关联实践操作


**⚡ 常用操作命令：**
```bash
# 查看进程当前所属的cgroups
cat /proc/1234/cgroup

# 将进程添加到指定cgroup
echo 1234 > /sys/fs/cgroup/memory/webserver/cgroup.procs

# 查看cgroup中的所有进程
cat /sys/fs/cgroup/memory/webserver/cgroup.procs

# 验证进程资源使用情况
cat /sys/fs/cgroup/memory/webserver/memory.usage_in_bytes
```

---

## 8. 🧬 cgroups继承关系


### 8.1 继承关系基本概念


**Cgroups继承**就是子cgroup会"遗传"父cgroup的资源限制和配置，就像家族企业的资产传承一样。

> **🔍 继承原理**  
> 子级不能超越父级的资源上限，但可以在父级范围内自由分配

### 8.2 继承关系规则


**🔸 核心继承规则：**

**资源上限继承：**
```
父cgroup: CPU=2核, Memory=4GB
├── 子cgroup1: CPU≤2核, Memory≤4GB ✅
├── 子cgroup2: CPU≤2核, Memory≤4GB ✅  
└── 违规示例: CPU=3核 ❌ (超过父级限制)
```

**配置参数继承：**
- **默认值**：子cgroup创建时继承父级的默认配置
- **独立修改**：子cgroup可以在继承基础上独立调整配置  
- **约束检查**：系统会自动检查子级配置是否违反父级限制

### 8.3 继承关系的实际应用


**🎯 实践场景示例：**
```bash
# 创建父级cgroup并设置限制
mkdir /sys/fs/cgroup/cpu/company
echo 204800 > /sys/fs/cgroup/cpu/company/cpu.shares  # 200%CPU

# 创建部门子cgroup
mkdir /sys/fs/cgroup/cpu/company/development
mkdir /sys/fs/cgroup/cpu/company/testing

# 为开发部门分配60%的父级资源
echo 122880 > /sys/fs/cgroup/cpu/company/development/cpu.shares

# 为测试部门分配40%的父级资源  
echo 81920 > /sys/fs/cgroup/cpu/company/testing/cpu.shares
```

### 8.4 继承关系管理技巧


**💡 最佳实践：**
- **合理规划**：设计cgroup层次时要考虑资源分配的合理性
- **动态调整**：根据实际需求动态调整各层级的资源分配  
- **监控验证**：定期检查资源使用情况，确保分配策略有效
- **避免过深**：cgroup层次不宜过深，一般3-4层足够

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 Cgroups = Linux内核的"资源管家"，负责进程组资源管理
🔸 层次结构 = 树形组织架构，父级控制子级资源分配  
🔸 子系统 = 专门管理特定资源的模块(CPU、内存、IO等)
🔸 控制器 = 子系统中实现具体管理功能的核心组件
🔸 文件系统 = 通过文件操作实现资源配置和监控
🔸 进程关联 = 每个进程必须属于相应的cgroup接受管理
🔸 继承关系 = 子cgroup继承父级限制，不能超越上级配额
```

### 9.2 版本选择与架构理解


**🔹 v1 vs v2 核心差异：**
```
v1特点：多个独立层次树，管理分散但功能完善
v2特点：单一统一层次树，管理集中且接口标准

选择建议：
• 新项目：优先选择v2，架构更清晰
• 现有系统：v1稳定可靠，可逐步迁移v2  
• 容器环境：关注Docker/K8s的版本支持情况
```

### 9.3 实际应用要点


**🎯 应用场景理解：**
- **资源隔离**：防止单个服务影响整个系统性能
- **服务质量**：保证关键服务获得足够的资源保障
- **性能调优**：通过资源限制和监控优化系统性能  
- **容器基础**：Docker、LXC等容器技术的底层基础

**🔧 操作实践要点：**
- **规划先行**：设计cgroup层次结构前要充分规划资源分配
- **渐进调整**：资源限制要逐步调整，避免一次性改动过大
- **监控验证**：配置完成后要持续监控验证效果
- **文档记录**：重要的cgroup配置要做好文档记录

### 9.4 学习进阶方向


**🚀 深入学习路径：**
- **动手实践**：创建简单的cgroup进行资源限制实验
- **容器技术**：学习Docker是如何使用cgroups的
- **性能调优**：结合实际应用场景进行性能优化
- **源码分析**：深入内核源码了解实现原理

**💡 关键理解**：
Cgroups是现代Linux系统资源管理的基础设施，掌握其原理和使用方法对于系统管理、容器技术、性能优化都至关重要。从基本概念开始，通过实践操作加深理解，是学习cgroups的最佳路径。

**🧠 记忆口诀**：
- 控制组管资源，层次结构像部门
- 子系统分工明，控制器来执行  
- 文件操作配资源，进程关联受约束
- 继承关系要牢记，父级限制不可越