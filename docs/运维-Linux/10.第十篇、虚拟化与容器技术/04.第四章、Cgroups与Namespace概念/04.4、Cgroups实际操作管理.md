---
title: 4、Cgroups实际操作管理
---
## 📚 目录

1. [Cgroups目录结构详解](#1-cgroups目录结构详解)
2. [手动创建Cgroups层次](#2-手动创建cgroups层次)
3. [进程管理操作](#3-进程管理操作)
4. [命令行工具详解](#4-命令行工具详解)
5. [监控与管理工具](#5-监控与管理工具)
6. [配置文件管理](#6-配置文件管理)
7. [权限与安全设置](#7-权限与安全设置)
8. [清理与维护](#8-清理与维护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📂 Cgroups目录结构详解


### 1.1 什么是/sys/fs/cgroup


**简单理解**：
`/sys/fs/cgroup`就像一个**资源管理中心**，系统把各种资源控制器都放在这里，每个子目录代表一种资源类型。

```
/sys/fs/cgroup/              ← Cgroups的"总部"
├── memory/                  ← 内存控制器
├── cpu/                     ← CPU控制器  
├── cpuset/                  ← CPU亲和性控制
├── blkio/                   ← 磁盘IO控制
├── net_cls/                 ← 网络分类控制
├── devices/                 ← 设备访问控制
└── systemd/                 ← systemd管理的cgroups
```

### 1.2 目录结构深入解析


**🔍 内存控制器目录**
```
/sys/fs/cgroup/memory/
├── memory.limit_in_bytes    ← 内存限制设置
├── memory.usage_in_bytes    ← 当前内存使用量
├── memory.stat              ← 详细内存统计
├── cgroup.procs            ← 该组内的进程列表
├── tasks                   ← 该组内的任务列表
└── 用户创建的子组/           ← 自定义的cgroup组
```

**💡 生活类比**：
想象一个**公司的部门管理系统**：
- `/sys/fs/cgroup/` = 公司总部
- `memory/` = 财务部门（管钱）
- `cpu/` = 人力部门（管人力分配）
- 每个子目录 = 具体的项目组

### 1.3 重要文件功能说明


| 文件名 | **作用说明** | **通俗理解** |
|-------|------------|------------|
| `cgroup.procs` | 进程ID列表 | 这个组里有哪些"员工" |
| `tasks` | 线程ID列表 | 更细致的任务分配 |
| `memory.limit_in_bytes` | 内存限制 | 给这个组分配多少"预算" |
| `cpu.cfs_quota_us` | CPU时间配额 | 给这个组分配多少"工作时间" |
| `notify_on_release` | 自动清理设置 | 组解散时是否自动清理 |

---

## 2. 🛠️ 手动创建Cgroups层次


### 2.1 创建基础Cgroup组


**步骤一：创建目录**
```bash
# 在内存控制器下创建一个新组
mkdir /sys/fs/cgroup/memory/myapp

# 在CPU控制器下创建对应的组
mkdir /sys/fs/cgroup/cpu/myapp
```

**💭 为什么这样做？**
- 创建目录就是创建一个新的"部门"
- 系统会自动在新目录下生成控制文件
- 每个控制器都需要单独创建对应的组

### 2.2 层次结构的概念


**🏗️ 层次结构示例**：
```
/sys/fs/cgroup/memory/
├── web-servers/             ← 网站服务器组
│   ├── nginx/              ← Nginx子组
│   └── apache/             ← Apache子组
└── databases/              ← 数据库组
    ├── mysql/              ← MySQL子组
    └── redis/              ← Redis子组
```

**创建层次结构**：
```bash
# 创建父组
mkdir /sys/fs/cgroup/memory/web-servers
mkdir /sys/fs/cgroup/memory/databases

# 创建子组
mkdir /sys/fs/cgroup/memory/web-servers/nginx
mkdir /sys/fs/cgroup/memory/web-servers/apache
mkdir /sys/fs/cgroup/memory/databases/mysql
```

### 2.3 验证创建结果


**检查目录内容**：
```bash
# 查看新创建的组
ls -la /sys/fs/cgroup/memory/myapp/

# 应该看到类似输出：
# -rw-r--r-- memory.limit_in_bytes
# -rw-r--r-- memory.usage_in_bytes
# -rw-r--r-- cgroup.procs
```

---

## 3. 👥 进程管理操作


### 3.1 将进程添加到Cgroup


**🎯 核心概念**：
把进程添加到cgroup就像**给员工分配到具体的部门**，一旦分配，该进程就受到这个组的资源限制。

**基本操作方法**：
```bash
# 方法1：直接写入进程ID
echo $$ > /sys/fs/cgroup/memory/myapp/cgroup.procs

# 方法2：添加特定进程
echo 12345 > /sys/fs/cgroup/memory/myapp/cgroup.procs

# 方法3：添加当前运行的程序
./myprogram &
echo $! > /sys/fs/cgroup/memory/myapp/cgroup.procs
```

### 3.2 查看进程归属


**检查进程在哪个组**：
```bash
# 查看进程12345属于哪些cgroup
cat /proc/12345/cgroup

# 输出示例：
# 12:memory:/myapp
# 11:cpu:/myapp
# 10:blkio:/
```

**💡 读懂输出**：
- `12:memory:/myapp` = 在内存控制器的myapp组中
- `11:cpu:/myapp` = 在CPU控制器的myapp组中
- `10:blkio:/` = 在磁盘IO控制器的根组中

### 3.3 批量进程管理


**将整个进程树添加到组**：
```bash
# 获取nginx主进程ID
NGINX_PID=$(pidof nginx)

# 添加主进程
echo $NGINX_PID > /sys/fs/cgroup/memory/web-servers/nginx/cgroup.procs

# 子进程会自动继承父进程的cgroup设置
```

**📊 进程状态追踪**：
```bash
# 查看组内所有进程
cat /sys/fs/cgroup/memory/myapp/cgroup.procs

# 查看组内进程数量
wc -l < /sys/fs/cgroup/memory/myapp/cgroup.procs
```

---

## 4. 🔧 命令行工具详解


### 4.1 cgcreate - 创建Cgroup


**🎯 用途**：更方便地创建cgroup组，比手动创建目录更安全。

```bash
# 基本语法
cgcreate -g controller:path

# 实际例子
cgcreate -g memory:webserver
cgcreate -g cpu,memory:database
cgcreate -g memory:webserver/nginx
```

**🔸 参数说明**：
- `-g controller:path` = 在指定控制器下创建路径
- 可以同时指定多个控制器（用逗号分隔）
- 支持创建嵌套结构

### 4.2 cgset - 设置资源限制


**🎯 用途**：设置cgroup的资源限制参数。

```bash
# 设置内存限制为512MB
cgset -r memory.limit_in_bytes=536870912 webserver

# 设置CPU使用率限制为50%
cgset -r cpu.cfs_quota_us=50000 webserver
cgset -r cpu.cfs_period_us=100000 webserver

# 设置多个参数
cgset -r memory.limit_in_bytes=1073741824 \
      -r cpu.cfs_quota_us=80000 \
      database
```

**💭 参数理解**：
- `memory.limit_in_bytes` = 内存限制（字节）
- `cpu.cfs_quota_us` = CPU时间片配额（微秒）
- `cpu.cfs_period_us` = CPU调度周期（微秒）

### 4.3 cgexec - 在Cgroup中执行程序


**🎯 用途**：直接在指定的cgroup中启动程序。

```bash
# 在webserver组中启动nginx
cgexec -g memory:webserver nginx

# 在多个控制器组中启动程序
cgexec -g memory,cpu:database mysqld

# 启动并设置资源限制
cgcreate -g memory:test-app
cgset -r memory.limit_in_bytes=268435456 test-app
cgexec -g memory:test-app ./my-application
```

### 4.4 实用命令组合示例


**🔄 完整的应用部署流程**：
```bash
# 1. 创建应用专用cgroup
cgcreate -g memory,cpu:mywebapp

# 2. 设置资源限制
cgset -r memory.limit_in_bytes=1073741824 mywebapp    # 1GB内存
cgset -r cpu.cfs_quota_us=150000 mywebapp             # 1.5个CPU核心
cgset -r cpu.cfs_period_us=100000 mywebapp

# 3. 在限制环境中启动应用
cgexec -g memory,cpu:mywebapp ./start-webapp.sh
```

---

## 5. 📊 监控与管理工具


### 5.1 systemd-cgtop监控工具


**🎯 用途**：实时查看各个cgroup的资源使用情况，就像Linux的`top`命令。

```bash
# 启动监控界面
systemd-cgtop

# 按CPU使用率排序
systemd-cgtop --order=cpu

# 按内存使用排序
systemd-cgtop --order=memory

# 按磁盘IO排序
systemd-cgtop --order=io
```

**🖥️ 界面解读**：
```
Control Group                    Tasks   %CPU   Memory  Input/s Output/s
/                                  234   12.3     2.1G      0B      0B
/system.slice                       89    8.1   890.2M      0B      0B
/system.slice/nginx.service          4    2.1   156.3M      0B      0B
/system.slice/mysql.service          8    5.2   512.8M      0B      0B
/user.slice                         56    1.8   234.5M      0B      0B
```

### 5.2 资源使用查询


**内存使用情况查询**：
```bash
# 查看特定组的内存使用
cat /sys/fs/cgroup/memory/webserver/memory.usage_in_bytes

# 查看内存统计详情
cat /sys/fs/cgroup/memory/webserver/memory.stat

# 查看内存限制设置
cat /sys/fs/cgroup/memory/webserver/memory.limit_in_bytes
```

**CPU使用情况查询**：
```bash
# 查看CPU使用统计
cat /sys/fs/cgroup/cpu/webserver/cpu.stat

# 查看CPU配额设置
cat /sys/fs/cgroup/cpu/webserver/cpu.cfs_quota_us
cat /sys/fs/cgroup/cpu/webserver/cpu.cfs_period_us
```

### 5.3 自定义监控脚本


**📊 简单监控脚本示例**：
```bash
#!/bin/bash
# cgroup-monitor.sh - 简单的cgroup监控脚本

CGROUP_NAME=$1
if [ -z "$CGROUP_NAME" ]; then
    echo "用法: $0 <cgroup名称>"
    exit 1
fi

echo "=== $CGROUP_NAME 资源使用情况 ==="
echo "进程数量: $(cat /sys/fs/cgroup/memory/$CGROUP_NAME/cgroup.procs | wc -l)"
echo "内存使用: $(cat /sys/fs/cgroup/memory/$CGROUP_NAME/memory.usage_in_bytes | numfmt --to=iec)"
echo "内存限制: $(cat /sys/fs/cgroup/memory/$CGROUP_NAME/memory.limit_in_bytes | numfmt --to=iec)"
```

---

## 6. 📄 配置文件管理


### 6.1 Systemd服务中的Cgroups配置


**🎯 概念**：
现代Linux系统中，systemd会自动为每个服务创建cgroup，我们可以在服务配置中设置资源限制。

**服务配置示例**：
```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My Application
After=network.target

[Service]
Type=simple
ExecStart=/opt/myapp/bin/myapp
User=myapp

# Cgroups资源限制配置
MemoryLimit=1G                    # 内存限制1GB
CPUQuota=150%                     # CPU限制1.5核
BlockIOWeight=500                 # 磁盘IO权重
TasksMax=100                      # 最大任务数

[Install]
WantedBy=multi-user.target
```

### 6.2 配置文件参数详解


**🔸 内存相关配置**：
```ini
MemoryLimit=1G          # 硬限制，超过会被OOM杀死
MemoryHigh=800M         # 软限制，超过会被回收
MemoryMax=1G            # 等同于MemoryLimit
MemorySwapMax=512M      # 交换空间限制
```

**🔸 CPU相关配置**：
```ini
CPUQuota=200%           # 最多使用2个CPU核心
CPUWeight=100           # CPU调度权重（默认100）
CPUAffinity=0 1         # 绑定到CPU核心0和1
```

**🔸 IO相关配置**：
```ini
BlockIOWeight=500       # IO调度权重
BlockIOReadBandwidth=/dev/sda 10M    # 读取带宽限制
BlockIOWriteBandwidth=/dev/sda 5M    # 写入带宽限制
```

### 6.3 配置生效与重载


```bash
# 重新加载systemd配置
systemctl daemon-reload

# 重启服务使配置生效
systemctl restart myapp.service

# 查看服务的cgroup配置
systemctl show myapp.service | grep -E "(Memory|CPU|BlockIO)"
```

---

## 7. 🔒 权限与安全设置


### 7.1 Cgroups权限控制


**🎯 基本原则**：
- **只有root用户**可以创建顶级cgroup
- **目录所有者**可以管理该cgroup及其子组
- **合理的权限设置**防止普通用户滥用系统资源

**权限设置示例**：
```bash
# 创建用户专用的cgroup组
cgcreate -g memory:users/alice -a alice:alice -t alice:alice

# 参数说明：
# -a alice:alice  = 设置管理权限给alice用户
# -t alice:alice  = 设置任务权限给alice用户
```

### 7.2 用户委托管理


**设置用户可管理的子组**：
```bash
# 创建主组（root权限）
cgcreate -g memory,cpu:userspace

# 设置子目录权限给普通用户
chown alice:alice /sys/fs/cgroup/memory/userspace
chown alice:alice /sys/fs/cgroup/cpu/userspace

# 现在alice用户可以在userspace下创建子组
```

### 7.3 安全注意事项


**⚠️ 安全要点**：

```
🔸 内存炸弹防护：
设置合理的内存限制，防止内存泄露程序耗尽系统资源

🔸 CPU饥饿防护：
不要将所有CPU都分配给单一组，保留系统必要资源

🔸 权限最小化：
只给用户最小必要的cgroup管理权限

🔸 监控告警：
设置资源使用监控，异常时及时报警
```

**实用安全脚本**：
```bash
#!/bin/bash
# 安全检查脚本
check_cgroup_security() {
    echo "检查cgroup安全配置..."
    
    # 检查是否有过大的内存限制
    find /sys/fs/cgroup/memory -name "memory.limit_in_bytes" -exec \
        sh -c 'limit=$(cat "$1"); if [ $limit -gt 8589934592 ]; then echo "警告: $1 内存限制过大"; fi' _ {} \;
    
    # 检查权限设置
    ls -la /sys/fs/cgroup/*/cgroup.procs | grep -v "root root" && \
        echo "警告: 发现非root权限的cgroup控制文件"
}
```

---

## 8. 🧹 清理与维护


### 8.1 删除Cgroup组


**🎯 删除原则**：
删除cgroup组需要**先清空进程**，再删除目录，就像解散部门前要先转移员工。

**正确删除步骤**：
```bash
# 1. 查看组内进程
cat /sys/fs/cgroup/memory/myapp/cgroup.procs

# 2. 将进程移动到其他组（或根组）
cat /sys/fs/cgroup/memory/myapp/cgroup.procs | while read pid; do
    echo $pid > /sys/fs/cgroup/memory/cgroup.procs
done

# 3. 确认组已空
cat /sys/fs/cgroup/memory/myapp/cgroup.procs

# 4. 删除目录
rmdir /sys/fs/cgroup/memory/myapp
```

### 8.2 使用cgdelete命令


**更安全的删除方式**：
```bash
# 删除单个组
cgdelete memory:myapp

# 删除多控制器组
cgdelete memory,cpu:myapp

# 递归删除子组
cgdelete -r memory:webserver
```

### 8.3 自动清理设置


**启用自动清理**：
```bash
# 设置自动清理标志
echo 1 > /sys/fs/cgroup/memory/myapp/notify_on_release

# 设置清理脚本路径
echo "/usr/local/bin/cleanup-cgroup.sh" > /sys/fs/cgroup/release_agent
```

**📝 清理脚本示例**：
```bash
#!/bin/bash
# cleanup-cgroup.sh - 自动清理脚本
CGROUP_PATH=$1
echo "清理空的cgroup: $CGROUP_PATH" >> /var/log/cgroup-cleanup.log
rmdir "/sys/fs/cgroup/$CGROUP_PATH" 2>/dev/null
```

### 8.4 系统维护检查


**定期维护脚本**：
```bash
#!/bin/bash
# cgroup-maintenance.sh - 定期维护脚本

echo "=== Cgroups维护检查 $(date) ==="

# 1. 检查空的cgroup组
echo "检查空的cgroup组..."
find /sys/fs/cgroup -name "cgroup.procs" -exec sh -c \
    'if [ ! -s "$1" ]; then echo "空组: $(dirname $1)"; fi' _ {} \;

# 2. 检查资源使用异常
echo "检查内存使用异常..."
find /sys/fs/cgroup/memory -name "memory.usage_in_bytes" -exec sh -c \
    'usage=$(cat "$1"); if [ $usage -gt 1073741824 ]; then 
        echo "高内存使用: $(dirname $1) - $(numfmt --to=iec $usage)"; 
    fi' _ {} \;

# 3. 清理临时组
echo "清理过期的临时组..."
find /sys/fs/cgroup -name "tmp-*" -type d -mtime +1 -exec rmdir {} \; 2>/dev/null
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的操作技能


**🔸 基础操作流程**：
```
创建cgroup → 设置限制 → 添加进程 → 监控使用 → 清理维护
    ↓           ↓         ↓        ↓        ↓
  mkdir     echo限制值   echo进程ID  查看统计  rmdir删除
```

**🔸 核心命令记忆**：
- `cgcreate` = 创建组（Create）
- `cgset` = 设置限制（Set）  
- `cgexec` = 执行程序（Execute）
- `cgdelete` = 删除组（Delete）
- `systemd-cgtop` = 监控工具（Top）

### 9.2 实际应用场景


**💼 生产环境常用操作**：

```
🔸 Web服务器资源隔离：
为nginx、apache等创建独立的资源组

🔸 数据库性能保护：
为MySQL、Redis设置专门的内存和CPU限制

🔸 批处理任务控制：
为备份、数据处理任务设置后台资源限制

🔸 容器资源管理：
Docker底层就是基于cgroups实现资源控制
```

### 9.3 避免常见错误


**❌ 常见问题与解决**：

| 问题 | **原因** | **解决方法** |
|-----|---------|------------|
| 删除cgroup失败 | 组内还有进程 | 先清空进程再删除 |
| 进程无法添加到组 | 权限不足 | 检查目录权限设置 |
| 资源限制不生效 | 配置错误 | 确认参数格式和数值 |
| 监控数据异常 | 控制器未启用 | 检查内核模块加载 |

### 9.4 最佳实践建议


**🎯 操作建议**：

```
✅ 良好习惯：
• 创建前规划好目录结构
• 设置合理的资源限制值  
• 定期检查和清理无用组
• 为重要服务设置专门监控

✅ 安全考虑：
• 不给普通用户过大权限
• 为关键系统进程保留资源
• 设置合理的告警阈值
• 备份重要的配置设置
```

**核心记忆口诀**：
- 创建设置加进程，监控清理保安全
- 目录结构要规划，权限设置需谨慎  
- 工具命令熟练用，生产环境更稳定
- 资源隔离是关键，容器技术的基石

**🎪 学完收获**：
通过掌握cgroups的实际操作，你就具备了：
- Linux系统资源管理的核心技能
- 容器技术（Docker/K8s）的基础知识
- 生产环境性能优化的重要工具
- 系统管理员的必备技术能力