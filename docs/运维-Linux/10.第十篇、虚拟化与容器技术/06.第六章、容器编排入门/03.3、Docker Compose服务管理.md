---
title: 3、Docker Compose服务管理
---
## 📚 目录


1. [Docker Compose服务管理概述](#1-docker-compose服务管理概述)
2. [docker-compose up启动服务](#2-docker-compose-up启动服务)
3. [docker-compose down停止清理](#3-docker-compose-down停止清理)
4. [docker-compose ps查看服务状态](#4-docker-compose-ps查看服务状态)
5. [docker-compose logs日志查看](#5-docker-compose-logs日志查看)
6. [docker-compose exec进入容器](#6-docker-compose-exec进入容器)
7. [docker-compose restart重启服务](#7-docker-compose-restart重启服务)
8. [服务扩缩容操作](#8-服务扩缩容操作)
9. [单服务操作命令](#9-单服务操作命令)
10. [核心要点总结](#10-核心要点总结)

---

# 🎯 **学习路径导航**


**前置知识**：需要掌握Docker基础概念、YAML语法基础 → **当前内容**：Docker Compose服务管理 → **后续学习**：建议学习Kubernetes容器编排

⏱️ **预计学习时间**：本章预计45分钟 | 实践练习30分钟

---

## 1. 🐳 Docker Compose服务管理概述



### 1.1 什么是Docker Compose服务管理



**🔸 核心定义**
Docker Compose服务管理就是用一个工具来控制多个Docker容器的启动、停止、监控等操作。

**💡 通俗理解**
想象你开了一家餐厅，需要协调厨师、服务员、收银员等多个角色：
- **传统方式**：一个一个地安排每个人的工作
- **Docker Compose**：写好工作流程表，一键让所有人开始工作

### 1.2 为什么需要服务管理



**🎯 解决的问题**
```
手动管理容器的困难：
• 启动顺序复杂 - 数据库要先于应用启动
• 网络配置繁琐 - 容器间需要相互通信  
• 状态监控困难 - 难以了解所有服务运行状态
• 日志查看麻烦 - 多个容器日志分散
```

**✅ Docker Compose的优势**
- **一键操作**：用一条命令管理整个应用栈
- **编排智能**：自动处理服务间的依赖关系
- **统一管理**：集中查看和控制所有服务
- **环境一致**：开发、测试、生产环境保持一致

### 1.3 服务管理命令概览



| **命令类型** | **主要命令** | **作用** |
|-------------|-------------|---------|
| **生命周期** | `up/down` | 启动/停止服务 |
| **监控查看** | `ps/logs` | 查看状态/日志 |
| **交互操作** | `exec` | 进入容器执行命令 |
| **维护操作** | `restart/scale` | 重启/扩缩容 |

---

## 2. 🚀 docker-compose up启动服务



### 2.1 基本启动操作



**🔸 最简单的启动方式**
```bash
# 在包含docker-compose.yml的目录执行

docker-compose up
```

这条命令会：
- 读取当前目录的`docker-compose.yml`文件
- 按照依赖关系启动所有服务
- 在前台显示所有服务的日志输出

### 2.2 后台启动服务



**🌙 静默后台运行**
```bash
# 后台启动，不占用终端

docker-compose up -d

# 查看启动结果

docker-compose ps
```

**💡 什么时候用后台启动？**
- 生产环境部署时
- 需要长期运行的服务
- 不需要实时查看日志时

### 2.3 启动特定服务



**🎯 选择性启动**
```bash
# 只启动web服务及其依赖

docker-compose up web

# 启动多个指定服务

docker-compose up web database
```

这在开发调试时特别有用，比如你只想测试前端，就不需要启动整个后端系统。

### 2.4 强制重新构建



**🔨 重新构建并启动**
```bash
# 强制重新构建镜像再启动

docker-compose up --build

# 不使用缓存重新构建

docker-compose up --build --no-cache
```

**⚠️ 什么时候需要重新构建？**
- 修改了Dockerfile
- 更新了应用代码
- 怀疑镜像有问题时

### 2.5 启动参数详解



| **参数** | **作用** | **使用场景** |
|---------|---------|-------------|
| `-d` | 后台运行 | 生产环境，长期服务 |
| `--build` | 重新构建 | 代码更新后 |
| `--no-cache` | 不用构建缓存 | 彻底重新构建 |
| `--remove-orphans` | 删除孤儿容器 | 清理旧容器 |

---

## 3. 🛑 docker-compose down停止清理



### 3.1 基本停止操作



**🔸 完整停止和清理**
```bash
# 停止所有服务并删除容器

docker-compose down
```

这条命令会：
- 停止所有运行中的容器
- 删除创建的容器
- 删除创建的网络
- **保留**数据卷和镜像

### 3.2 彻底清理选项



**🧹 深度清理操作**
```bash
# 删除数据卷（注意：数据会丢失！）

docker-compose down -v

# 删除镜像

docker-compose down --rmi all

# 删除孤儿容器

docker-compose down --remove-orphans
```

**⚠️ 危险操作警告**
```
使用 -v 参数会删除数据卷，意味着：
✗ 数据库数据会丢失
✗ 上传的文件会丢失  
✗ 配置文件可能丢失

生产环境请谨慎使用！
```

### 3.3 停止vs删除对比



| **操作** | **容器状态** | **数据保留** | **网络保留** |
|---------|-------------|-------------|-------------|
| `stop` | 停止但存在 | ✅ | ✅ |
| `down` | 完全删除 | ✅ | ❌ |
| `down -v` | 完全删除 | ❌ | ❌ |

### 3.4 优雅停止服务



**⏱️ 设置停止超时**
```bash
# 等待30秒后强制停止

docker-compose down -t 30
```

这给容器更多时间来完成正在处理的请求，对于数据库等服务很重要。

---

## 4. 👀 docker-compose ps查看服务状态



### 4.1 基本状态查看



**🔸 查看所有服务状态**
```bash
docker-compose ps
```

**📊 输出信息解读**
```
         Name                       Command               State           Ports
--------------------------------------------------------------------------------
myapp_web_1      nginx -g daemon off;             Up      0.0.0.0:80->80/tcp
myapp_db_1       docker-entrypoint.sh mysqld      Up      0.0.0.0:3306->3306/tcp
myapp_redis_1    docker-entrypoint.sh redis ...   Up      6379/tcp
```

每一列的含义：
- **Name**: 容器名称
- **Command**: 运行的命令
- **State**: 运行状态（Up/Exit）
- **Ports**: 端口映射情况

### 4.2 查看特定服务



**🎯 针对性状态查看**
```bash
# 只查看web服务

docker-compose ps web

# 查看所有服务包括停止的

docker-compose ps -a
```

### 4.3 状态信息详解



**📈 服务状态类型**
- **Up**: 服务正常运行
- **Up (health: starting)**: 健康检查启动中  
- **Up (unhealthy)**: 健康检查失败
- **Exit**: 服务已退出
- **Restarting**: 服务重启中

**💡 快速诊断技巧**
```
看到Exit状态时：
1. 检查服务日志找出错误原因
2. 确认配置文件是否正确
3. 检查依赖服务是否就绪
```

### 4.4 服务状态监控



**🔄 实时监控服务状态**
```bash
# 每2秒刷新一次状态

watch -n 2 docker-compose ps
```

这在调试服务启动问题时很有用，可以实时观察服务状态变化。

---

## 5. 📋 docker-compose logs日志查看



### 5.1 基本日志查看



**🔸 查看所有服务日志**
```bash
# 显示所有服务的日志

docker-compose logs

# 实时跟踪日志（类似tail -f）

docker-compose logs -f
```

### 5.2 查看特定服务日志



**🎯 针对性日志查看**
```bash
# 只看web服务的日志

docker-compose logs web

# 看多个服务的日志

docker-compose logs web database
```

### 5.3 日志过滤和格式化



**🔍 高级日志查看技巧**
```bash
# 显示最近100行日志

docker-compose logs --tail=100

# 显示带时间戳的日志

docker-compose logs -t

# 显示最近1小时的日志

docker-compose logs --since="1h"
```

### 5.4 日志管理最佳实践



**📝 日志查看策略**

| **场景** | **推荐命令** | **说明** |
|---------|-------------|---------|
| **调试启动问题** | `logs -f service_name` | 实时查看特定服务 |
| **查看错误信息** | `logs --tail=50 service_name` | 查看最近错误 |
| **性能分析** | `logs --since="1h" -t` | 查看带时间的历史日志 |
| **生产监控** | `logs -f --tail=0` | 只看新产生的日志 |

**💡 日志查看技巧**
```
日志太多时的处理方法：
• 使用grep过滤关键字
• 重定向到文件保存
• 结合less命令分页查看

示例：
docker-compose logs web | grep "ERROR" > error.log
```

---

## 6. 💻 docker-compose exec进入容器



### 6.1 基本容器进入



**🔸 进入正在运行的容器**
```bash
# 进入web服务的bash终端

docker-compose exec web bash

# 如果容器没有bash，使用sh

docker-compose exec web sh
```

**💡 exec vs attach的区别**
- **exec**: 在容器中启动新进程，不会影响原有进程
- **attach**: 连接到容器的主进程，退出可能导致容器停止

### 6.2 执行特定命令



**🎯 不进入容器直接执行命令**
```bash
# 查看容器内的文件

docker-compose exec web ls -la

# 查看进程

docker-compose exec web ps aux

# 执行数据库操作

docker-compose exec db mysql -u root -p
```

### 6.3 文件操作技巧



**📁 容器文件管理**
```bash
# 查看配置文件

docker-compose exec web cat /etc/nginx/nginx.conf

# 编辑文件（如果容器内有编辑器）

docker-compose exec web vi /app/config.py

# 查看日志文件

docker-compose exec web tail -f /var/log/app.log
```

### 6.4 调试和故障排除



**🔧 容器内调试技巧**

**环境变量检查**
```bash
# 查看所有环境变量

docker-compose exec web env

# 查看特定环境变量

docker-compose exec web echo $DATABASE_URL
```

**网络连通性测试**
```bash
# 测试网络连接

docker-compose exec web ping database

# 测试端口连通性（如果有telnet）

docker-compose exec web telnet database 3306
```

**⚠️ 注意事项**
```
exec命令只能用于正在运行的容器
如果容器状态是Exit，需要先启动容器
可以使用 docker-compose up -d service_name 启动单个服务
```

---

## 7. 🔄 docker-compose restart重启服务



### 7.1 基本重启操作



**🔸 重启所有服务**
```bash
# 重启所有服务

docker-compose restart
```

**🎯 重启特定服务**
```bash
# 只重启web服务

docker-compose restart web

# 重启多个服务

docker-compose restart web database
```

### 7.2 重启超时设置



**⏱️ 控制重启等待时间**
```bash
# 设置10秒超时时间

docker-compose restart -t 10 web
```

这对于需要较长时间优雅关闭的服务（如数据库）很重要。

### 7.3 重启vs重新创建



**🔄 不同的"重启"方式对比**

| **操作** | **容器状态** | **配置更新** | **速度** |
|---------|-------------|-------------|---------|
| `restart` | 保持容器，重启进程 | ❌ | 快 |
| `up --force-recreate` | 删除重建容器 | ✅ | 慢 |
| `stop + up` | 停止后重新启动 | ✅ | 中等 |

### 7.4 什么时候需要重启



**🎯 常见重启场景**
```
应用代码更新：
• 如果使用数据卷挂载代码，重启应用服务即可
• 如果打包在镜像中，需要重新构建

配置文件修改：
• 修改了docker-compose.yml，需要重新创建
• 修改了应用配置文件，重启对应服务

服务异常：
• 服务假死或响应缓慢
• 内存泄漏问题
• 网络连接问题
```

### 7.5 重启故障排除



**🔧 重启失败处理**
```bash
# 如果重启卡住，强制停止后重启

docker-compose stop web
docker-compose up -d web

# 检查重启后的状态

docker-compose ps
docker-compose logs web
```

---

## 8. 📈 服务扩缩容操作



### 8.1 什么是服务扩缩容



**🔸 扩缩容概念解释**
服务扩缩容就是增加或减少同一服务的容器实例数量，类似于：
- **扩容**：餐厅生意好，多雇几个服务员
- **缩容**：客人少了，让部分服务员下班

### 8.2 基本扩容操作



**📈 横向扩展服务**
```bash
# 将web服务扩展到3个实例

docker-compose up --scale web=3 -d

# 多服务同时扩容

docker-compose up --scale web=3 --scale worker=2 -d
```

### 8.3 使用scale命令



**🎯 专门的扩缩容命令**
```bash
# 扩容web服务到5个实例

docker-compose scale web=5

# 缩容到1个实例

docker-compose scale web=1

# 查看扩容结果

docker-compose ps
```

### 8.4 扩容注意事项



**⚠️ 扩容前的考虑因素**

**端口冲突问题**
```yaml
# 错误的配置（会导致端口冲突）

services:
  web:
    ports:
      - "80:80"  # 多个容器无法绑定同一端口

# 正确的配置

services:
  web:
    expose:
      - "80"  # 只暴露给其他容器
  nginx:
    ports:
      - "80:80"  # 由负载均衡器统一对外
```

**负载均衡配置**
扩容后需要确保有负载均衡器来分发请求，否则扩容没有意义。

### 8.5 扩容最佳实践



**🎯 有效扩容策略**

**监控驱动扩容**
```bash
# 监控CPU使用率

docker stats

# 基于负载决定扩容

if cpu_usage > 80%; then
    docker-compose scale web=5
fi
```

**渐进式扩容**
```
1. 先扩容到2个实例测试
2. 观察系统表现
3. 根据需要继续扩容
4. 监控资源使用情况
```

### 8.6 缩容和资源清理



**📉 服务缩容**
```bash
# 缩容到1个实例

docker-compose scale web=1

# 完全停止某个服务

docker-compose scale web=0

# 检查缩容结果

docker-compose ps
```

**💡 缩容时机**
- 访问量下降时
- 资源使用率过低
- 成本控制需要
- 维护和更新时

---

## 9. 🎯 单服务操作命令



### 9.1 为什么需要单服务操作



**🔸 单服务操作的价值**
在开发和运维过程中，经常需要只操作某个特定服务：
- **开发调试**：只启动需要的服务节省资源
- **故障处理**：单独重启有问题的服务
- **更新部署**：逐个服务更新避免全面停机

### 9.2 单服务生命周期管理



**🔄 服务级别的操作**
```bash
# 启动单个服务

docker-compose up -d web

# 停止单个服务

docker-compose stop web

# 删除单个服务

docker-compose rm web

# 重启单个服务

docker-compose restart web
```

### 9.3 单服务构建和更新



**🔨 针对性构建操作**
```bash
# 只构建web服务

docker-compose build web

# 强制重新构建web服务

docker-compose build --no-cache web

# 构建后立即启动

docker-compose up --build -d web
```

### 9.4 单服务日志和监控



**📊 服务级别的监控**
```bash
# 查看单个服务状态

docker-compose ps web

# 单个服务日志

docker-compose logs -f web

# 进入单个服务容器

docker-compose exec web bash
```

### 9.5 服务依赖处理



**🔗 处理服务间依赖**
```bash
# 启动web及其依赖服务

docker-compose up -d web
# 这会自动启动web依赖的database服务


# 只启动web，不启动依赖

docker-compose up --no-deps -d web
```

**💡 依赖关系理解**
```yaml
# docker-compose.yml中的依赖定义

services:
  web:
    depends_on:
      - database
  database:
    image: mysql:8.0

# 启动web时会自动先启动database

```

### 9.6 单服务故障处理流程



**🔧 系统化故障处理**

**步骤1：问题识别**
```bash
# 检查服务状态

docker-compose ps web
```

**步骤2：日志分析**
```bash
# 查看错误日志

docker-compose logs --tail=50 web
```

**步骤3：容器检查**
```bash
# 进入容器调试

docker-compose exec web bash
```

**步骤4：服务恢复**
```bash
# 尝试重启

docker-compose restart web

# 如果重启无效，重新创建

docker-compose up --force-recreate -d web
```

---

## 10. 📋 核心要点总结



### 10.1 必须掌握的核心概念



```
🔸 Docker Compose本质：用一个工具管理多个相关容器的集合
🔸 服务生命周期：up启动 → ps监控 → logs调试 → exec交互 → restart维护 → down清理
🔸 扩缩容理念：通过增减容器实例数量应对负载变化
🔸 单服务操作：针对特定服务进行精确操作而不影响其他服务
🔸 日志和监控：通过logs和ps命令掌握服务运行状态
```

### 10.2 关键理解要点



**🔹 up vs start的区别**
```
docker-compose up：
- 会创建网络、数据卷等资源
- 如果容器不存在会创建
- 相当于"完整启动"

docker-compose start：  
- 只启动已存在的停止容器
- 不会创建新资源
- 相当于"恢复运行"
```

**🔹 重启的不同方式**
```
restart：快速重启进程，容器不重建
up --force-recreate：删除容器重新创建
stop + start：停止后重新启动
```

**🔹 扩容的前提条件**
```
服务设计要支持扩容：
- 无状态化应用
- 配置外部化
- 数据持久化分离
- 避免端口绑定冲突
```

### 10.3 实际应用指导



**🎯 开发环境使用**
```bash
# 开发时的常用流程

docker-compose up -d          # 后台启动所有服务
docker-compose logs -f web    # 实时查看应用日志
docker-compose exec web bash  # 进入容器调试
docker-compose restart web    # 代码更新后重启
```

**🏭 生产环境使用**
```bash
# 生产部署流程

docker-compose up -d                    # 后台启动
docker-compose ps                       # 确认状态
docker-compose scale web=3             # 根据负载扩容
docker-compose logs --tail=100 web     # 检查运行日志
```

### 10.4 故障排除检查清单



- [ ] 服务状态是否正常 (`docker-compose ps`)
- [ ] 日志是否有错误信息 (`docker-compose logs`)
- [ ] 网络连接是否正常 (`docker-compose exec ping`)
- [ ] 环境变量是否正确 (`docker-compose exec env`)
- [ ] 数据卷挂载是否正确 (`docker-compose exec ls`)
- [ ] 依赖服务是否就绪 (`docker-compose ps deps`)

### 10.5 常用命令速查表



| **功能** | **命令** | **说明** |
|---------|---------|---------|
| **启动** | `up -d` | 后台启动所有服务 |
| **停止** | `down` | 停止并删除容器 |
| **状态** | `ps` | 查看服务运行状态 |
| **日志** | `logs -f service` | 实时查看服务日志 |
| **进入** | `exec service bash` | 进入服务容器 |
| **重启** | `restart service` | 重启指定服务 |
| **扩容** | `scale service=3` | 扩容到3个实例 |

**🔑 核心记忆要点**
> Docker Compose管理多容器，up下down上ps看状态
> logs查日志exec进容器，restart重启scale扩容
> 单服务操作更精确，依赖关系要理清

**💡 最佳实践建议**
- **开发时**：多使用单服务操作，节省资源
- **生产时**：重视日志监控和健康检查
- **扩容时**：先确保服务支持水平扩展
- **故障时**：按照识别→分析→修复→验证的流程处理