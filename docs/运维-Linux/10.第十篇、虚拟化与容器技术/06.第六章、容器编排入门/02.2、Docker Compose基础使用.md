---
title: 2、Docker Compose基础使用
---
## 📚 目录

1. [Docker Compose概述](#1-Docker-Compose概述)
2. [安装与环境配置](#2-安装与环境配置)
3. [docker-compose.yml文件结构](#3-docker-compose-yml文件结构)
4. [服务定义与配置](#4-服务定义与配置)
5. [环境变量管理](#5-环境变量管理)
6. [网络与端口配置](#6-网络与端口配置)
7. [数据卷挂载配置](#7-数据卷挂载配置)
8. [容器依赖关系](#8-容器依赖关系)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🐳 Docker Compose概述


### 1.1 什么是Docker Compose


**通俗理解**：Docker Compose就像一个"项目管理器"，专门管理多个Docker容器的协同工作。

```
单容器时代：                 多容器协作时代：
   Web应用                     ┌──────────┐
     │                        │   Web    │
  手动启动                     │  容器    │
                               └─────┬────┘
                                     │
                               ┌─────┴────┐
                               │ 数据库   │
                               │  容器    │
                               └──────────┘
                               
问题：容器多了管理复杂         解决：用Compose统一管理
```

**核心作用**：
- **批量管理**：一个命令启动/停止多个容器
- **服务编排**：定义容器间的启动顺序和依赖关系
- **配置统一**：用一个文件管理所有容器的配置
- **环境隔离**：为不同环境（开发/测试/生产）提供不同配置

### 1.2 为什么需要Docker Compose


**实际场景举例**：
你要部署一个电商网站，需要：
- **Web服务器**：运行网站代码
- **数据库**：存储商品和用户信息  
- **Redis缓存**：提升访问速度
- **消息队列**：处理订单通知

```
传统方式的痛点：
docker run -d --name web nginx
docker run -d --name db mysql
docker run -d --name redis redis
docker run -d --name mq rabbitmq
# 每次都要手动输入一堆命令，容易出错

Docker Compose方式：
docker-compose up
# 一条命令搞定所有容器
```

### 1.3 Compose vs Docker的关系


**形象比喻**：
- **Docker** = 搭积木的积木块（单个容器）
- **Docker Compose** = 积木说明书（告诉你怎么把积木组装成完整作品）

**关系说明**：
```
Docker Compose 不是替代品，而是增强工具
├── 底层：仍然使用Docker引擎
├── 功能：批量管理多个Docker容器  
├── 配置：用YAML文件代替命令行参数
└── 目标：简化复杂应用的部署和管理
```

---

## 2. 🔧 安装与环境配置


### 2.1 Docker Compose安装方法


**检查Docker是否已安装**：
```bash
docker --version
# 如果没安装Docker，需要先安装Docker
```

**方法一：使用包管理器安装（推荐）**
```bash
# Ubuntu/Debian
sudo apt update
sudo apt install docker-compose

# CentOS/RHEL
sudo yum install docker-compose

# macOS（如果用Homebrew）
brew install docker-compose
```

**方法二：直接下载二进制文件**
```bash
# 下载最新版本
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

# 添加执行权限
sudo chmod +x /usr/local/bin/docker-compose
```

### 2.2 验证安装是否成功


```bash
# 检查版本
docker-compose --version

# 应该看到类似输出：
# docker-compose version 1.29.2, build 5becea4c
```

> 💡 **重要提示**：Docker Desktop（Windows/Mac版本）通常已经包含了Docker Compose，无需单独安装。

### 2.3 version版本兼容性说明


**版本对应关系表**：

| Compose文件版本 | Docker引擎版本 | **使用建议** |
|----------------|----------------|------------|
| `3.8` | 19.03.0+ | 🟢 **推荐使用** |
| `3.7` | 18.06.0+ | 🟡 稳定可用 |
| `3.6` | 18.02.0+ | 🟡 稳定可用 |
| `2.4` | 17.12.0+ | 🔴 已过时 |

**版本选择原则**：
```
新项目：使用 version: '3.8'
老项目：根据现有Docker版本选择对应的Compose版本
生产环境：选择稳定版本，避免使用最新的实验性功能
```

---

## 3. 📄 docker-compose.yml文件结构


### 3.1 基本文件结构


**标准结构解析**：
```yaml
# docker-compose.yml 基本结构
version: '3.8'          # 指定Compose文件格式版本

services:               # 定义所有服务（容器）
  web:                 # 服务名称
    # web服务的配置
  db:                  # 另一个服务名称  
    # 数据库服务的配置

volumes:               # 定义数据卷（可选）
  # 数据卷配置

networks:              # 定义网络（可选）
  # 网络配置
```

**文件命名规则**：
- **默认名称**：`docker-compose.yml` 或 `docker-compose.yaml`
- **自定义名称**：使用 `-f` 参数指定，如 `docker-compose -f my-app.yml up`
- **多文件合并**：`docker-compose -f docker-compose.yml -f docker-compose.prod.yml up`

### 3.2 完整示例文件


```yaml
# 一个简单的Web应用示例
version: '3.8'

services:
  # Web服务
  web:
    image: nginx:alpine           # 使用的镜像
    ports:                       # 端口映射
      - "80:80"
    volumes:                     # 文件挂载
      - ./html:/usr/share/nginx/html
    depends_on:                  # 依赖关系
      - db
    environment:                 # 环境变量
      - ENV=production
      
  # 数据库服务  
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: myapp
    volumes:
      - db_data:/var/lib/mysql
      
volumes:                        # 定义持久化卷
  db_data:
```

### 3.3 YAML语法要点


> ⚠️ **语法注意事项**：
> - 使用**空格**缩进，不要用Tab键
> - 冒号后面必须有空格：`key: value`
> - 列表项用短横线：`- item`
> - 字符串一般不需要引号，特殊字符才需要

**常见语法错误**：
```yaml
# ❌ 错误写法
services:
web:              # 缺少缩进
  image:nginx     # 冒号后缺少空格
	ports:          # 使用了Tab缩进
  
# ✅ 正确写法  
services:
  web:            # 正确缩进
    image: nginx  # 冒号后有空格
    ports:        # 使用空格缩进
```

---

## 4. ⚙️ 服务定义与配置


### 4.1 services服务定义语法


**服务定义的基本概念**：
- **服务（Service）** = 一个容器的完整配置
- **服务名** = 容器在内部网络中的主机名
- 每个服务可以启动一个或多个容器实例

```yaml
services:
  服务名:           # 这个名字很重要，其他服务可以用它来访问
    image: 镜像名   # 或者用 build: 构建路径
    # 其他配置项...
```

### 4.2 镜像指定方式


**方式一：使用现有镜像**
```yaml
services:
  web:
    image: nginx:1.21-alpine    # 指定具体版本（推荐）
    # image: nginx:latest       # 使用最新版本（不推荐生产环境）
    # image: nginx              # 默认使用latest标签
```

**方式二：构建自定义镜像**
```yaml
services:
  app:
    build:
      context: .              # Dockerfile所在目录
      dockerfile: Dockerfile  # 指定Dockerfile文件名
      args:                   # 构建时的参数
        - NODE_ENV=production
```

**方式三：组合使用**
```yaml
services:
  app:
    build: .                  # 构建镜像
    image: my-app:latest      # 给构建的镜像命名
```

### 4.3 常用服务配置选项


**基础配置选项**：

| 配置项 | **作用** | **示例** |
|--------|---------|---------|
| `container_name` | 指定容器名称 | `container_name: my-web` |
| `restart` | 重启策略 | `restart: always` |
| `command` | 覆盖默认启动命令 | `command: python app.py` |
| `working_dir` | 设置工作目录 | `working_dir: /app` |
| `user` | 指定运行用户 | `user: "1000:1000"` |

**实际应用示例**：
```yaml
services:
  web:
    image: nginx:alpine
    container_name: my-website        # 容器名字
    restart: unless-stopped           # 总是重启（除非手动停止）
    command: nginx -g 'daemon off;'   # 自定义启动命令
    working_dir: /usr/share/nginx/html
    user: nginx                       # 以nginx用户运行
```

### 4.4 重启策略详解


**四种重启策略**：

```yaml
services:
  web:
    restart: no              # 不自动重启（默认）
    # restart: always        # 总是重启
    # restart: on-failure    # 只在失败时重启  
    # restart: unless-stopped # 总是重启，除非手动停止
```

**选择建议**：
- **开发环境**：使用 `no` 或 `on-failure`
- **生产环境**：使用 `unless-stopped`
- **临时服务**：使用 `on-failure`

---

## 5. 🌍 环境变量管理


### 5.1 环境变量配置方法


**方法一：直接在yml中定义**
```yaml
services:
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=secret123    # 方式1：key=value
      - MYSQL_DATABASE=myapp
    # 或者用对象形式：
    environment:
      MYSQL_ROOT_PASSWORD: secret123     # 方式2：key: value
      MYSQL_DATABASE: myapp
```

**方法二：从文件加载（推荐）**
```yaml
services:
  web:
    image: nginx
    env_file:
      - .env                # 从.env文件加载
      - .env.local          # 可以指定多个文件
```

### 5.2 .env文件的使用


**创建.env文件**：
```bash
# .env 文件内容（注意：不要有空格）
DB_PASSWORD=secret123
DB_NAME=myapp
APP_ENV=production
API_KEY=abc123xyz
```

**在docker-compose.yml中使用**：
```yaml
services:
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}    # 引用.env中的变量
      MYSQL_DATABASE: ${DB_NAME}
      
  web:
    image: myapp:latest
    environment:
      - APP_ENV=${APP_ENV}
      - API_KEY=${API_KEY}
```

> 💡 **最佳实践**：
> - 敏感信息（密码、API密钥）放在 `.env` 文件中
> - 将 `.env` 文件加入 `.gitignore`，避免提交到代码仓库
> - 提供 `.env.example` 文件作为模板

### 5.3 环境变量的优先级


**优先级从高到低**：
```
1. docker-compose.yml 中的 environment
2. .env 文件中的变量  
3. Dockerfile 中的 ENV
4. 系统环境变量
```

**实际测试示例**：
```yaml
# docker-compose.yml
services:
  test:
    image: alpine
    environment:
      TEST_VAR: from-compose-yml    # 最高优先级
    env_file:
      - .env                        # 第二优先级
```

---

## 6. 🌐 网络与端口配置


### 6.1 端口映射配置


**基本端口映射语法**：
```yaml
services:
  web:
    image: nginx
    ports:
      - "8080:80"          # 主机端口:容器端口
      - "443:443"          # HTTPS端口
      - "127.0.0.1:8081:80" # 只绑定到本地回环地址
```

**端口映射的含义**：
```
"8080:80" 的含义：
┌─────────────┐    端口8080    ┌──────────────┐
│  主机系统   │ ─────────────> │   容器内部   │
│             │                │   端口80     │
└─────────────┘                └──────────────┘

访问 http://localhost:8080 实际访问的是容器内的80端口
```

### 6.2 expose端口暴露


**expose与ports的区别**：
```yaml
services:
  web:
    image: nginx
    expose:
      - "80"              # 只对其他容器暴露，主机无法访问
    ports:  
      - "8080:80"         # 对主机和其他容器都暴露
      
  api:
    image: node:alpine  
    expose:
      - "3000"            # API服务只需要内部访问
```

**使用场景说明**：
- **ports**：需要从外部访问的服务（如Web前端）
- **expose**：只需要内部服务间通信的服务（如API后端、数据库）

### 6.3 自定义网络配置


**默认网络行为**：
Docker Compose会自动为每个项目创建一个默认网络，所有服务都连接到这个网络。

```yaml
# 不需要额外配置，服务间可以直接通过服务名访问
services:
  web:
    image: nginx
  api:
    image: node:alpine
    
# web容器内可以通过 http://api:3000 访问api服务
```

**自定义网络示例**：
```yaml
services:
  web:
    image: nginx
    networks:
      - frontend              # web只连接前端网络
      
  api:
    image: node:alpine
    networks:
      - frontend              # api连接前端和后端网络
      - backend
      
  db:
    image: mysql:8.0  
    networks:
      - backend               # 数据库只连接后端网络

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true            # 内部网络，无法访问外网
```

**网络隔离的好处**：
```
┌─────────────┐    frontend网络    ┌─────────────┐
│    Web      │ <──────────────── │    API      │
└─────────────┘                   └──────┬──────┘
                                         │
                              backend网络 │
                                         │
                                  ┌──────▼──────┐
                                  │  Database   │
                                  └─────────────┘

Web无法直接访问Database，必须通过API，提高了安全性
```

---

## 7. 💾 数据卷挂载配置


### 7.1 数据卷的概念和作用


**什么是数据卷**：
数据卷就像给容器装了一个"外接硬盘"，用来解决数据持久化问题。

```
容器的问题：                    数据卷的解决方案：
┌─────────────┐                ┌─────────────┐
│   容器内    │                │   容器内    │
│  /var/data  │                │  /var/data  │ ←──┐
└─────────────┘                └─────────────┘    │
容器删除后数据丢失                                  │ 挂载
                               ┌─────────────┐    │
                               │  主机磁盘   │ ←──┘
                               │  /host/data │
                               └─────────────┘
                               容器删除后数据保留
```

### 7.2 三种挂载方式


**方式一：命名数据卷（推荐）**
```yaml
services:
  db:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql    # 命名卷:容器路径

volumes:
  mysql_data:                        # 定义命名卷
    driver: local
```

**方式二：主机目录挂载**
```yaml
services:
  web:
    image: nginx
    volumes:
      - ./html:/usr/share/nginx/html          # 相对路径
      - /host/logs:/var/log/nginx             # 绝对路径
      - ./config/nginx.conf:/etc/nginx/nginx.conf:ro  # 只读挂载
```

**方式三：匿名卷**
```yaml
services:
  temp:
    image: alpine
    volumes:
      - /tmp                         # 匿名卷，容器删除时一起删除
```

### 7.3 挂载选项和权限


**常用挂载选项**：
```yaml
services:
  app:
    image: myapp
    volumes:
      - ./data:/app/data:rw          # 读写模式（默认）
      - ./config:/app/config:ro      # 只读模式
      - ./cache:/app/cache:Z         # SELinux标签（CentOS/RHEL）
      - type: bind                   # 完整语法形式
        source: ./data
        target: /app/data
        read_only: true
```

### 7.4 实际应用场景


**常见数据持久化需求**：

| 应用类型 | **需要持久化的数据** | **挂载配置** |
|---------|-------------------|-------------|
| 数据库 | 数据文件 | `db_data:/var/lib/mysql` |
| Web服务器 | 网站文件、日志 | `./html:/var/www/html` |
| 应用程序 | 配置文件、上传文件 | `./config:/app/config` |
| 开发环境 | 源代码 | `./src:/app/src` |

**完整示例**：
```yaml
services:
  web:
    image: nginx:alpine
    volumes:
      - ./site:/usr/share/nginx/html    # 网站文件  
      - ./logs:/var/log/nginx           # 日志文件
      - ./nginx.conf:/etc/nginx/nginx.conf:ro  # 配置文件（只读）
      
  db:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql       # 数据库数据
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro  # 初始化脚本
    
volumes:
  mysql_data:                           # 持久化数据卷
```

---

## 8. 🔗 容器依赖关系


### 8.1 depends_on基本用法


**依赖关系的概念**：
就像盖房子，必须先打地基，再建墙，最后装屋顶。容器启动也有这样的先后顺序。

```yaml
services:
  web:
    image: nginx
    depends_on:
      - api                    # web依赖api
      - db                     # web也依赖db
      
  api:
    image: node:alpine
    depends_on:
      - db                     # api依赖db
      
  db:
    image: mysql:8.0           # db不依赖任何服务
```

**启动顺序**：
```
启动顺序：db → api → web
停止顺序：web → api → db（与启动相反）
```

### 8.2 depends_on的限制


> ⚠️ **重要理解**：`depends_on`只控制启动顺序，不等待服务就绪！

```
depends_on的实际作用：
✅ 控制容器启动的先后顺序  
❌ 等待服务完全就绪才启动下一个

实际情况：
1. 启动db容器
2. 立即启动api容器（不等db初始化完成）
3. 立即启动web容器

可能的问题：
- API尝试连接数据库时，数据库还在初始化中
- 连接失败，API容器退出
```

### 8.3 健康检查配置


**为服务添加健康检查**：
```yaml
services:
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: secret
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      interval: 30s
      retries: 5
      start_period: 80s
      
  api:
    image: node:alpine
    depends_on:
      db:
        condition: service_healthy    # 等待db健康检查通过
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

> 💡 **注意**：`condition: service_healthy` 需要 Docker Compose v2.1+ 版本支持。

### 8.4 应用启动等待策略


**方法一：应用内重试机制**
```yaml
services:
  api:
    image: node:alpine
    restart: on-failure
    environment:
      - DB_HOST=db
      - DB_RETRY_ATTEMPTS=10    # 应用内实现重试逻辑
```

**方法二：使用wait工具**
```yaml
services:
  api:
    image: node:alpine
    command: ["wait-for-it", "db:3306", "--", "node", "app.js"]
    depends_on:
      - db
```

**方法三：init容器模式**
```yaml
services:
  db:
    image: mysql:8.0
    
  db-migration:
    image: migrate/migrate
    command: ["-path", "/migrations", "-database", "mysql://db:3306/myapp", "up"]
    depends_on:
      - db
    volumes:
      - ./migrations:/migrations
      
  api:
    image: node:alpine  
    depends_on:
      - db-migration              # 等待数据库迁移完成
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基础概念


```
🔸 Docker Compose本质：多容器应用的编排工具
🔸 核心配置文件：docker-compose.yml，使用YAML语法  
🔸 服务概念：每个service代表一个容器的完整配置
🔸 版本兼容性：推荐使用version: '3.8'
🔸 基本命令：up启动、down停止、logs查看日志
```

### 9.2 关键配置要点


**🔹 环境变量最佳实践**
```
配置优先级：environment > .env文件 > Dockerfile ENV
敏感信息：使用.env文件，并加入.gitignore
引用语法：${VARIABLE_NAME}
```

**🔹 网络端口配置**
```
外部访问：使用ports映射
内部通信：使用expose或默认网络  
服务发现：通过服务名访问其他容器
网络隔离：自定义networks提高安全性
```

**🔹 数据持久化策略**  
```
生产数据：使用命名数据卷（推荐）
开发调试：使用主机目录挂载
配置文件：使用只读挂载:ro
权限设置：注意文件权限和用户映射
```

**🔹 依赖关系管理**
```
启动顺序：depends_on控制容器启动顺序
健康检查：healthcheck确保服务就绪
重试机制：restart策略处理启动失败
等待策略：应用层实现连接重试
```

### 9.3 实际应用指导


**常用命令速查**：
```bash
# 启动所有服务
docker-compose up -d

# 查看运行状态  
docker-compose ps

# 查看日志
docker-compose logs -f service_name

# 停止并删除容器
docker-compose down

# 重建并启动
docker-compose up --build -d
```

**文件组织建议**：
```
project/
├── docker-compose.yml        # 主配置文件
├── .env                      # 环境变量（不提交到git）
├── .env.example             # 环境变量模板
├── docker-compose.override.yml  # 本地开发覆盖配置
└── docker-compose.prod.yml  # 生产环境配置
```

### 9.4 进阶学习方向


**扩展功能探索**：
- **多环境管理**：override文件的使用
- **扩缩容配置**：scale参数和副本管理  
- **密钥管理**：secrets配置
- **配置管理**：configs外部配置
- **监控集成**：日志聚合和监控配置

**生产部署考虑**：
- **资源限制**：内存和CPU限制配置
- **安全加固**：用户权限和网络隔离
- **备份恢复**：数据卷备份策略
- **滚动更新**：零停机部署方案

**核心记忆口诀**：
- Compose编排多容器，YAML配置要规范
- 服务依赖看depends，环境变量用.env管  
- 端口映射分内外，数据卷挂载保持久
- 健康检查保就绪，生产部署考安全