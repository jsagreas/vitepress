---
title: 16、容器化应用部署实践
---
## 📚 目录

1. [应用容器化改造策略](#1-应用容器化改造策略)
2. [微服务容器化部署](#2-微服务容器化部署)
3. [数据库容器化考虑](#3-数据库容器化考虑)
4. [负载均衡容器配置](#4-负载均衡容器配置)
5. [容器化CI/CD流水线](#5-容器化ci-cd流水线)
6. [蓝绿部署与滚动更新](#6-蓝绿部署与滚动更新)
7. [容器备份与恢复](#7-容器备份与恢复)
8. [生产环境部署最佳实践](#8-生产环境部署最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🏗️ 应用容器化改造策略


### 1.1 什么是应用容器化


> 💡 **通俗理解**  
> 应用容器化就像把你的应用程序连同它的运行环境一起打包成一个"标准箱子"，这样无论在哪台机器上都能一样地运行

**🎯 容器化的本质**
```
传统部署方式：
应用程序 + 依赖库 + 操作系统配置
↓ (在不同机器上可能出现问题)
运行环境差异导致的各种故障

容器化部署：
应用程序 + 依赖库 + 运行环境
↓ (打包成容器镜像)
标准化的运行单元，到哪都一样
```

### 1.2 容器化改造步骤


**🔄 改造流程图**
```
现有应用
    ↓
① 分析应用依赖
    ↓
② 编写Dockerfile
    ↓
③ 构建容器镜像
    ↓
④ 测试容器运行
    ↓
⑤ 优化镜像大小
    ↓
⑥ 生产环境部署
```

**📋 第一步：应用依赖分析**

🔍 **依赖清单检查**
- **运行时环境**：Java 8、Python 3.9、Node.js 16等
- **系统依赖**：数据库客户端、系统库文件
- **配置文件**：应用配置、环境变量
- **数据存储**：需要持久化的数据路径
- **网络端口**：应用监听的端口号

**📝 第二步：编写Dockerfile**

```dockerfile
# 选择基础镜像 - 就像选择房子的地基
FROM openjdk:8-jre-slim

# 设置工作目录 - 就像在房子里规划房间
WORKDIR /app

# 复制应用文件 - 把家具搬进房间
COPY target/myapp.jar app.jar

# 暴露端口 - 给房子开个门
EXPOSE 8080

# 启动命令 - 告诉房子怎么"活起来"
CMD ["java", "-jar", "app.jar"]
```

> 🧠 **记忆技巧**：Dockerfile就像装修房子的施工图纸，FROM选地基，COPY搬东西，CMD定规矩

### 1.3 容器化改造的常见挑战


**❌ 常见问题与解决方案**

| 问题类型 | 具体表现 | 解决策略 |
|---------|----------|----------|
| 🗂️ **配置管理** | 硬编码配置路径 | 使用环境变量和配置文件挂载 |
| 📊 **数据持久化** | 数据写入容器内部 | 使用数据卷(Volume)外挂存储 |
| 🔗 **服务依赖** | 依赖固定IP地址 | 使用服务发现和环境变量 |
| 📦 **镜像过大** | 包含不必要文件 | 使用多阶段构建和Alpine镜像 |

**🛠️ 实际改造案例：Java Web应用**

```dockerfile
# 多阶段构建：先编译再运行
# 第一阶段：构建阶段
FROM maven:3.8-openjdk-8 AS builder
WORKDIR /build
COPY pom.xml .
COPY src ./src
RUN mvn package -DskipTests

# 第二阶段：运行阶段  
FROM openjdk:8-jre-alpine
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser
WORKDIR /app
COPY --from=builder /build/target/*.jar app.jar
RUN chown appuser:appuser app.jar
USER appuser
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

> ⚡ **优化要点**：多阶段构建就像搭积木，第一阶段负责"制造零件"，第二阶段负责"组装成品"，最终镜像只包含必要的运行文件

---

## 2. 🏢 微服务容器化部署


### 2.1 微服务容器化架构理解


> 📖 **核心概念**  
> 微服务容器化就像把一个大公司拆分成多个小部门，每个部门都有自己的办公室(容器)，各自独立工作但可以相互协作

**🌐 微服务容器化架构图**
```
┌─────────────────────────────────────┐
│           负载均衡器 (Nginx)          │
└──────────────┬──────────────────────┘
               │
    ┌──────────┼──────────┐
    │          │          │
┌───▼───┐  ┌───▼───┐  ┌───▼───┐
│用户服务│  │订单服务│  │支付服务│
│Container│ │Container│ │Container│
└───┬───┘  └───┬───┘  └───┬───┘
    │          │          │
    └──────────┼──────────┘
               │
        ┌──────▼──────┐
        │   数据库集群   │
        └─────────────┘
```

### 2.2 微服务容器编排策略


**📊 服务拆分原则**

✅ **单一职责**：一个服务只负责一个业务功能
- 用户管理服务 → 只处理用户注册、登录、信息管理
- 订单处理服务 → 只处理订单创建、查询、状态更新
- 支付服务 → 只处理支付相关逻辑

✅ **数据独立**：每个服务管理自己的数据
```
用户服务 ←→ 用户数据库
订单服务 ←→ 订单数据库  
支付服务 ←→ 支付数据库
```

**🐳 Docker Compose编排示例**

```yaml
version: '3.8'
services:
  # 用户服务
  user-service:
    image: myapp/user-service:latest
    ports:
      - "8081:8080"
    environment:
      - DB_HOST=user-db
      - DB_PASSWORD=userpass
    depends_on:
      - user-db
    networks:
      - microservices-net

  # 订单服务  
  order-service:
    image: myapp/order-service:latest
    ports:
      - "8082:8080"
    environment:
      - DB_HOST=order-db
      - USER_SERVICE_URL=http://user-service:8080
    depends_on:
      - order-db
    networks:
      - microservices-net

  # 用户数据库
  user-db:
    image: postgres:13
    environment:
      - POSTGRES_DB=userdb
      - POSTGRES_PASSWORD=userpass
    volumes:
      - user-data:/var/lib/postgresql/data
    networks:
      - microservices-net

networks:
  microservices-net:
    driver: bridge

volumes:
  user-data:
```

### 2.3 服务发现与通信


**🔗 服务间通信方式**

| 通信方式 | 使用场景 | 优点 | 缺点 |
|---------|----------|------|------|
| 🌐 **HTTP REST** | 一般业务调用 | 简单易懂，调试方便 | 性能相对较低 |
| ⚡ **gRPC** | 高性能要求 | 性能好，类型安全 | 学习成本高 |
| 📨 **消息队列** | 异步处理 | 解耦好，可靠性高 | 复杂度增加 |

**🎯 服务发现机制**
```
手动配置方式：
user-service 通过环境变量 ORDER_SERVICE_URL 找到 order-service

自动发现方式：
user-service → 注册中心 → 查询 order-service 地址
```

---

## 3. 🗄️ 数据库容器化考虑


### 3.1 数据库容器化的权衡


> ⚠️ **重要提醒**  
> 数据库容器化就像把银行金库搬到活动板房里，虽然灵活但要格外小心数据安全

**📊 容器化适用场景分析**

| 场景类型 | 🟢 **建议容器化** | 🟡 **谨慎考虑** | 🔴 **不建议容器化** |
|---------|------------------|----------------|-------------------|
| **开发测试环境** | ✅ 快速搭建，易于重置 | - | - |
| **小型应用** | ✅ 简化运维 | - | - |
| **大型生产系统** | - | ⚠️ 需要专业规划 | ❌ 直接使用专业数据库 |
| **高并发系统** | - | - | ❌ 性能损失不可接受 |

### 3.2 数据库容器化最佳实践


**💾 数据持久化策略**

```yaml
# PostgreSQL 容器化配置示例
services:
  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: appuser  
      POSTGRES_PASSWORD: securepass
    volumes:
      # 数据持久化 - 把数据放在宿主机上
      - postgres-data:/var/lib/postgresql/data
      # 初始化脚本
      - ./init-scripts:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    # 资源限制
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
    # 健康检查
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U appuser -d myapp"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres-data:
    driver: local
```

**🔒 数据库安全配置**

🔐 **安全检查清单**
- [ ] **密码管理**：使用Docker secrets或环境变量文件
- [ ] **网络隔离**：数据库不直接暴露到外网
- [ ] **访问控制**：只有应用服务能访问数据库
- [ ] **数据备份**：定期备份数据卷
- [ ] **日志管理**：监控数据库访问日志

### 3.3 数据库备份与恢复


**💾 备份策略实现**

```bash
#!/bin/bash
# 数据库备份脚本

# 备份PostgreSQL数据
docker exec postgres-container pg_dump -U appuser myapp > backup_$(date +%Y%m%d_%H%M%S).sql

# 定期清理旧备份（保留7天）
find /backup -name "backup_*.sql" -mtime +7 -delete

# 数据恢复命令
# docker exec -i postgres-container psql -U appuser myapp < backup_20241215_143000.sql
```

---

## 4. ⚖️ 负载均衡容器配置


### 4.1 容器负载均衡架构


> 🎯 **形象理解**  
> 负载均衡器就像餐厅的服务员，根据各个厨师(应用容器)的忙闲程度，合理分配订单(请求)

**🌊 负载均衡流程图**
```
用户请求
    ↓
┌─────────────┐
│负载均衡容器 │ ← nginx/traefik/haproxy
│   (调度器)   │
└──────┬──────┘
       │ 根据策略分发请求
    ┌──┴──┐
    │     │
┌───▼─┐ ┌─▼───┐ ┌───▼─┐
│应用1 │ │应用2 │ │应用3 │
│实例 │ │实例 │ │实例 │  
└─────┘ └─────┘ └─────┘
```

### 4.2 Nginx负载均衡配置


**⚙️ 基础负载均衡配置**

```nginx
# nginx.conf
upstream app_servers {
    # 轮询策略：请求依次分发给每个服务器
    server app1:8080 weight=1;
    server app2:8080 weight=1;  
    server app3:8080 weight=2;  # 权重高，分配更多请求
    
    # 健康检查：自动剔除故障节点
    server app4:8080 weight=1 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name myapp.com;
    
    location / {
        proxy_pass http://app_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 连接超时设置
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }
}
```

**🐳 负载均衡容器编排**

```yaml
version: '3.8'
services:
  # Nginx 负载均衡器
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app1
      - app2
      - app3
    networks:
      - web-net

  # 应用实例1
  app1:
    image: myapp:latest
    environment:
      - INSTANCE_ID=1
    networks:
      - web-net
    
  # 应用实例2  
  app2:
    image: myapp:latest
    environment:
      - INSTANCE_ID=2
    networks:
      - web-net
      
  # 应用实例3
  app3:
    image: myapp:latest  
    environment:
      - INSTANCE_ID=3
    networks:
      - web-net

networks:
  web-net:
    driver: bridge
```

### 4.3 负载均衡策略选择


**⚖️ 常用负载均衡算法**

| 算法类型 | 工作原理 | 适用场景 | 配置示例 |
|---------|----------|----------|----------|
| 🔄 **轮询** | 请求依次分配给每台服务器 | 服务器性能相近 | `# 默认即轮询` |
| ⚖️ **加权轮询** | 按权重比例分配请求 | 服务器性能不同 | `server app1:8080 weight=3;` |
| 📊 **最少连接** | 分配给连接数最少的服务器 | 长连接应用 | `upstream app { least_conn; }` |
| 🎯 **IP哈希** | 相同IP总是访问同一服务器 | 需要会话保持 | `upstream app { ip_hash; }` |

---

## 5. 🚀 容器化CI/CD流水线


### 5.1 CI/CD流水线概念


> 💡 **生活类比**  
> CI/CD就像工厂的自动化生产线，代码一提交就自动"生产"出可用的应用程序

**🔄 CI/CD流程图**
```
开发者提交代码
        ↓
    持续集成(CI)
    ┌─────────────┐
    │ 代码检查    │
    │ 单元测试    │  
    │ 构建镜像    │
    │ 推送仓库    │
    └──────┬──────┘
           ↓
    持续部署(CD)  
    ┌─────────────┐
    │ 拉取镜像    │
    │ 部署测试    │
    │ 健康检查    │
    │ 生产部署    │
    └─────────────┘
```

### 5.2 基于Docker的CI/CD实现


**📝 GitLab CI配置示例**

```yaml
# .gitlab-ci.yml
stages:
  - build
  - test  
  - deploy

variables:
  DOCKER_IMAGE: myapp/webapp
  DOCKER_TAG: $CI_COMMIT_SHORT_SHA

# 构建阶段
build:
  stage: build
  script:
    # 构建Docker镜像
    - docker build -t $DOCKER_IMAGE:$DOCKER_TAG .
    - docker tag $DOCKER_IMAGE:$DOCKER_TAG $DOCKER_IMAGE:latest
    # 推送到镜像仓库
    - docker push $DOCKER_IMAGE:$DOCKER_TAG
    - docker push $DOCKER_IMAGE:latest
  only:
    - main

# 测试阶段
test:
  stage: test
  script:
    # 启动测试容器
    - docker run --rm $DOCKER_IMAGE:$DOCKER_TAG npm test
  only:
    - main

# 部署阶段
deploy:
  stage: deploy
  script:
    # 更新生产环境
    - docker-compose -f docker-compose.prod.yml pull
    - docker-compose -f docker-compose.prod.yml up -d
    # 等待服务启动
    - sleep 30
    # 健康检查
    - curl -f http://localhost/health || exit 1
  only:
    - main
```

**🔧 自动化部署脚本**

```bash
#!/bin/bash
# deploy.sh - 自动化部署脚本

set -e  # 遇到错误立即退出

APP_NAME="myapp"
IMAGE_TAG="latest"
CONTAINER_PORT="8080"
HOST_PORT="80"

echo "🚀 开始部署 $APP_NAME..."

# 1. 拉取最新镜像
echo "📥 拉取最新镜像..."
docker pull $APP_NAME:$IMAGE_TAG

# 2. 停止旧容器
echo "🛑 停止旧容器..."
docker stop $APP_NAME-old 2>/dev/null || true
docker rm $APP_NAME-old 2>/dev/null || true

# 3. 重命名当前容器为old
echo "🔄 备份当前容器..."
docker rename $APP_NAME $APP_NAME-old 2>/dev/null || true

# 4. 启动新容器
echo "🆕 启动新容器..."
docker run -d \
  --name $APP_NAME \
  -p $HOST_PORT:$CONTAINER_PORT \
  --restart unless-stopped \
  $APP_NAME:$IMAGE_TAG

# 5. 健康检查
echo "🏥 健康检查..."
sleep 10
if curl -f http://localhost:$HOST_PORT/health; then
  echo "✅ 部署成功！"
  # 清理旧容器
  docker rm $APP_NAME-old 2>/dev/null || true
else
  echo "❌ 部署失败，回滚..."
  docker stop $APP_NAME
  docker rm $APP_NAME  
  docker rename $APP_NAME-old $APP_NAME
  docker start $APP_NAME
  exit 1
fi
```

### 5.3 容器镜像管理策略


**🏷️ 镜像标签管理**

```bash
# 镜像标签策略
myapp:latest          # 最新稳定版本
myapp:v1.2.3         # 语义化版本号
myapp:20241215       # 日期标签  
myapp:abc123         # Git提交号
myapp:develop        # 开发分支版本
```

**📦 镜像仓库选择**

| 仓库类型 | 适用场景 | 优点 | 缺点 |
|---------|----------|------|------|
| 🌐 **Docker Hub** | 开源项目 | 免费，使用简单 | 公开，下载速度慢 |
| 🏢 **私有仓库** | 企业应用 | 安全，速度快 | 需要维护成本 |
| ☁️ **云服务商** | 生产环境 | 高可用，集成好 | 费用较高 |

---

## 6. 🔄 蓝绿部署与滚动更新


### 6.1 蓝绿部署策略


> 🎨 **颜色类比**  
> 蓝绿部署就像有两个完全一样的舞台，观众在看蓝色舞台表演时，绿色舞台在后台准备新节目，准备好了就瞬间切换

**🎭 蓝绿部署架构**
```
负载均衡器
    │
    ├─ 路由开关 ─┐
    │           │
    ▼           ▼
┌─────────┐ ┌─────────┐
│蓝色环境  │ │绿色环境  │
│(生产中) │ │(待部署) │
│v1.0版本│ │v2.0版本│
└─────────┘ └─────────┘
```

**🐳 Docker实现蓝绿部署**

```bash
#!/bin/bash
# blue-green-deploy.sh

APP_NAME="myapp"
BLUE_NAME="${APP_NAME}-blue"
GREEN_NAME="${APP_NAME}-green"
NEW_IMAGE="$1"

# 检查当前活跃环境
if docker ps | grep -q $BLUE_NAME; then
    ACTIVE="blue"
    INACTIVE="green"
    ACTIVE_CONTAINER=$BLUE_NAME
    INACTIVE_CONTAINER=$GREEN_NAME
else
    ACTIVE="green" 
    INACTIVE="blue"
    ACTIVE_CONTAINER=$GREEN_NAME
    INACTIVE_CONTAINER=$BLUE_NAME
fi

echo "🔵 当前活跃环境: $ACTIVE"
echo "🟢 准备部署到: $INACTIVE"

# 1. 启动新环境
echo "🚀 启动新环境..."
docker run -d \
  --name $INACTIVE_CONTAINER \
  -p 808${INACTIVE:0:1}:8080 \
  --health-cmd="curl -f http://localhost:8080/health || exit 1" \
  --health-interval=10s \
  $NEW_IMAGE

# 2. 等待新环境就绪
echo "⏳ 等待新环境就绪..."
while [ "$(docker inspect --format='{{.State.Health.Status}}' $INACTIVE_CONTAINER)" != "healthy" ]; do
  sleep 5
  echo "等待中..."
done

# 3. 切换负载均衡
echo "🔄 切换负载均衡..."
# 更新nginx配置指向新环境
sed -i "s/808./808${INACTIVE:0:1}/" /etc/nginx/nginx.conf
nginx -s reload

# 4. 验证切换成功
echo "🧪 验证部署..."
sleep 10
if curl -f http://localhost/health; then
  echo "✅ 部署成功，清理旧环境"
  docker stop $ACTIVE_CONTAINER
  docker rm $ACTIVE_CONTAINER
else
  echo "❌ 部署失败，回滚"
  sed -i "s/808./808${ACTIVE:0:1}/" /etc/nginx/nginx.conf  
  nginx -s reload
  docker stop $INACTIVE_CONTAINER
  docker rm $INACTIVE_CONTAINER
fi
```

### 6.2 滚动更新策略


> ⚡ **渐进式更新**  
> 滚动更新就像换队伍中的队员，一次换一个人，保证队伍始终在运转

**🔄 滚动更新流程**
```
初始状态: [v1] [v1] [v1] [v1]
         ↓
步骤1:   [v2] [v1] [v1] [v1]  ← 更新第1个
         ↓
步骤2:   [v2] [v2] [v1] [v1]  ← 更新第2个
         ↓  
步骤3:   [v2] [v2] [v2] [v1]  ← 更新第3个
         ↓
完成:    [v2] [v2] [v2] [v2]  ← 全部完成
```

**🎛️ Docker Swarm滚动更新**

```bash
# 1. 初始化Swarm集群
docker swarm init

# 2. 部署服务
docker service create \
  --name myapp \
  --replicas 4 \
  --publish 80:8080 \
  --update-parallelism 1 \
  --update-delay 30s \
  --update-failure-action rollback \
  myapp:v1.0

# 3. 执行滚动更新
docker service update \
  --image myapp:v2.0 \
  myapp

# 4. 监控更新进度  
docker service ps myapp
```

### 6.3 回滚策略


**🔙 快速回滚机制**

| 回滚触发条件 | 检测方式 | 回滚动作 |
|-------------|----------|----------|
| 🚨 **健康检查失败** | HTTP状态码检查 | 自动切换到旧版本 |
| 📊 **错误率上升** | 日志监控 | 触发告警并回滚 |
| ⏱️ **响应时间超标** | 性能监控 | 逐步回滚到稳定版本 |
| 👥 **用户投诉** | 手动触发 | 紧急回滚到上一版本 |

---

## 7. 💾 容器备份与恢复


### 7.1 容器数据备份策略


> 🛡️ **数据保护理念**  
> 备份就像给重要文件拍照片，原件丢了还有底片可以重新洗出来

**📦 备份内容分类**
```
容器数据备份对象：
├── 📁 持久化数据 (最重要)
│   ├── 数据库文件
│   ├── 用户上传文件  
│   └── 配置文件
├── 🐳 容器镜像 (可重建)
│   ├── 应用镜像
│   └── 基础镜像
└── ⚙️ 运行配置 (代码管理)
    ├── docker-compose.yml
    └── 环境变量文件
```

### 7.2 数据卷备份实践


**💾 Volume备份脚本**

```bash
#!/bin/bash
# backup-volumes.sh - 数据卷备份脚本

BACKUP_DIR="/backup"
DATE=$(date +%Y%m%d_%H%M%S)

echo "🗄️ 开始备份容器数据卷..."

# 1. 备份PostgreSQL数据卷
echo "📊 备份数据库..."
docker run --rm \
  -v postgres-data:/source:ro \
  -v $BACKUP_DIR:/backup \
  alpine tar czf /backup/postgres-$DATE.tar.gz -C /source .

# 2. 备份应用上传文件
echo "📁 备份上传文件..."  
docker run --rm \
  -v app-uploads:/source:ro \
  -v $BACKUP_DIR:/backup \
  alpine tar czf /backup/uploads-$DATE.tar.gz -C /source .

# 3. 备份配置文件
echo "⚙️ 备份配置..."
docker run --rm \
  -v app-config:/source:ro \
  -v $BACKUP_DIR:/backup \
  alpine tar czf /backup/config-$DATE.tar.gz -C /source .

# 4. 清理旧备份(保留30天)
find $BACKUP_DIR -name "*.tar.gz" -mtime +30 -delete

echo "✅ 备份完成！文件保存在 $BACKUP_DIR"
```

**🔄 数据恢复脚本**

```bash  
#!/bin/bash
# restore-volumes.sh - 数据恢复脚本

BACKUP_FILE="$1"
VOLUME_NAME="$2"

if [ -z "$BACKUP_FILE" ] || [ -z "$VOLUME_NAME" ]; then
  echo "使用方法: $0 <备份文件> <目标卷名>"
  echo "示例: $0 postgres-20241215_143000.tar.gz postgres-data"
  exit 1
fi

echo "🔄 从 $BACKUP_FILE 恢复到 $VOLUME_NAME..."

# 1. 停止使用该卷的容器
echo "⏸️ 停止相关容器..."
CONTAINERS=$(docker ps --filter volume=$VOLUME_NAME --format "{{.Names}}")
if [ ! -z "$CONTAINERS" ]; then
  docker stop $CONTAINERS
fi

# 2. 清空目标卷
echo "🗑️ 清空目标卷..."
docker run --rm -v $VOLUME_NAME:/target alpine sh -c "rm -rf /target/*"

# 3. 恢复数据
echo "📥 恢复数据..."
docker run --rm \
  -v $(pwd):/backup:ro \
  -v $VOLUME_NAME:/target \
  alpine tar xzf /backup/$BACKUP_FILE -C /target

# 4. 重启容器
echo "🚀 重启容器..."
if [ ! -z "$CONTAINERS" ]; then
  docker start $CONTAINERS
fi

echo "✅ 数据恢复完成！"
```

### 7.3 镜像备份管理


**🏷️ 镜像导出与导入**

```bash
# 1. 导出镜像到文件
docker save -o myapp-v1.2.3.tar myapp:v1.2.3

# 2. 批量导出所有自定义镜像
docker images --format "{{.Repository}}:{{.Tag}}" | \
  grep -v "^<none>" | \
  while read image; do
    filename=$(echo $image | sed 's/[\/:]/-/g')
    docker save -o "${filename}.tar" "$image"
    echo "✅ 已导出: $image -> ${filename}.tar"
  done

# 3. 导入镜像
docker load -i myapp-v1.2.3.tar

# 4. 验证导入
docker images | grep myapp
```

---

## 8. 🏭 生产环境部署最佳实践


### 8.1 生产环境安全配置


> 🛡️ **安全第一原则**  
> 生产环境就像银行金库，每一道门都要设密码，每个角落都要有监控

**🔒 安全配置清单**

✅ **用户权限管理**
```dockerfile
# 创建非root用户运行应用
FROM node:16-alpine
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
USER nextjs
WORKDIR /app
COPY --chown=nextjs:nodejs . .
CMD ["npm", "start"]
```

✅ **网络安全隔离**
```yaml
# docker-compose.prod.yml
version: '3.8'
services:
  app:
    image: myapp:latest
    networks:
      - app-net        # 只连接必要网络
    # 不暴露不必要端口到主机
    expose:
      - "8080"
      
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"       # 只有nginx暴露到外网
      - "443:443"
    networks:
      - app-net
      
  database:
    image: postgres:13
    networks:
      - db-net        # 数据库独立网络
    # 数据库不暴露任何端口到主机
    
networks:
  app-net:
    driver: bridge
    internal: false
  db-net:
    driver: bridge  
    internal: true    # 内部网络，无法访问外网
```

### 8.2 资源限制与监控


**⚡ 容器资源限制**

```yaml
services:
  app:
    image: myapp:latest
    deploy:
      resources:
        limits:
          cpus: '0.50'      # 限制CPU使用50%
          memory: 512M      # 限制内存512MB
        reservations:
          cpus: '0.25'      # 预留CPU 25%  
          memory: 256M      # 预留内存256MB
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
```

**📊 监控配置示例**

```yaml
# 添加监控组件
services:
  # 应用监控
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      
  # 可视化监控
  grafana:
    image: grafana/grafana  
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
    volumes:
      - grafana-data:/var/lib/grafana

  # 日志收集
  fluentd:
    image: fluentd:latest
    volumes:
      - /var/log:/var/log:ro
      - ./fluentd.conf:/fluentd/etc/fluent.conf
```

### 8.3 高可用部署架构


**🌐 多节点部署架构**
```
                负载均衡器 (Nginx)
                        │
        ┌───────────────┼───────────────┐
        │               │               │
    节点1            节点2            节点3
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  应用容器    │  │  应用容器    │  │  应用容器    │
│  数据库从库  │  │  数据库主库  │  │  数据库从库  │
│  Redis从库  │  │  Redis主库  │  │  Redis从库  │
└─────────────┘  └─────────────┘  └─────────────┘
```

**🔧 生产部署脚本**

```bash
#!/bin/bash
# production-deploy.sh - 生产环境部署脚本

set -euo pipefail

# 配置变量
ENVIRONMENT="production"
APP_NAME="myapp"
IMAGE_TAG="${1:-latest}"
DEPLOY_DIR="/opt/deploy/$APP_NAME"

echo "🏭 开始生产环境部署..."
echo "📋 环境: $ENVIRONMENT"
echo "🏷️ 镜像标签: $IMAGE_TAG"

# 1. 预检查
echo "🔍 执行预检查..."
# 检查磁盘空间
df -h | awk '$5 > 80 {print "⚠️ 磁盘使用率过高: " $0; exit 1}'
# 检查内存使用
free -m | awk 'NR==2{printf "内存使用率: %.2f%%\n", $3*100/$2; if($3*100/$2 > 80) exit 1}'

# 2. 备份当前版本
echo "💾 备份当前版本..."
if [ -f "$DEPLOY_DIR/docker-compose.yml" ]; then
  cp -r $DEPLOY_DIR $DEPLOY_DIR.backup.$(date +%s)
fi

# 3. 拉取新镜像  
echo "📥 拉取新镜像..."
docker pull $APP_NAME:$IMAGE_TAG

# 4. 滚动更新
echo "🔄 执行滚动更新..."
cd $DEPLOY_DIR

# 分批重启容器以保证可用性
for service in app-1 app-2 app-3; do
  echo "🔄 更新服务: $service"
  docker-compose stop $service
  docker-compose rm -f $service
  docker-compose up -d $service
  
  # 等待服务就绪
  sleep 30
  
  # 健康检查
  if ! docker-compose exec $service curl -f http://localhost:8080/health; then
    echo "❌ 服务 $service 健康检查失败，回滚..."
    exit 1
  fi
  
  echo "✅ 服务 $service 更新完成"
done

# 5. 最终验证
echo "🧪 最终验证..."
sleep 60
if curl -f http://localhost/health; then
  echo "🎉 生产环境部署成功！"
  # 清理旧备份(保留最新3个)
  ls -dt $DEPLOY_DIR.backup.* | tail -n +4 | xargs rm -rf
else
  echo "❌ 最终验证失败"
  exit 1
fi
```

### 8.4 生产环境运维要点


**📋 日常运维检查清单**

🔍 **每日检查**
- [ ] 容器运行状态检查：`docker ps -a`
- [ ] 资源使用监控：CPU、内存、磁盘
- [ ] 应用日志检查：错误率、响应时间
- [ ] 备份任务执行状态确认

⚙️ **每周维护**
- [ ] 清理未使用的镜像：`docker image prune`
- [ ] 更新安全补丁
- [ ] 检查存储空间使用情况
- [ ] 验证备份恢复流程

🔧 **每月优化**
- [ ] 性能指标分析和优化
- [ ] 容器镜像大小优化
- [ ] 安全扫描和漏洞修复
- [ ] 容量规划评估

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 容器化改造：应用打包标准化，解决"在我机器上能跑"问题
🔸 微服务部署：服务拆分独立部署，提高系统弹性和扩展性
🔸 数据持久化：容器重启数据不丢失，生产环境必备
🔸 负载均衡：多实例分担请求，提高系统处理能力
🔸 CI/CD流水线：自动化部署，提高交付效率和质量
🔸 部署策略：蓝绿/滚动更新，保证业务连续性
🔸 备份恢复：数据安全防护，灾难恢复必备
🔸 生产实践：安全、监控、高可用配置
```

### 9.2 关键理解要点


**🔹 容器化的价值**
```
一致性：开发、测试、生产环境完全一致
可移植：任何支持Docker的环境都能运行
可扩展：轻松增减实例应对负载变化
资源效率：比虚拟机更轻量，启动更快
```

**🔹 生产部署的关键原则**
```
安全性：最小权限、网络隔离、数据加密
可靠性：健康检查、自动重启、故障转移
可观测：日志监控、性能指标、告警机制
可维护：标准化配置、自动化部署、文档完善
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **创业公司**：快速交付产品，降低运维成本
- **传统企业**：应用现代化改造，提升技术竞争力  
- **大型系统**：微服务架构，支撑高并发业务
- **DevOps团队**：自动化流水线，提高开发效率

**💼 职业技能价值**
- **开发工程师**：掌握现代应用部署方式
- **运维工程师**：容器平台管理和优化
- **架构师**：设计可扩展的容器化架构
- **项目经理**：理解容器化对项目交付的影响

**🧠 核心记忆口诀**：
- 容器打包标准化，应用部署更简化
- 微服务独立扩展，负载均衡解压力
- 数据持久要外挂，备份恢复保平安
- 蓝绿滚动零宕机，CI/CD提效率
- 生产环境讲安全，监控运维不能少