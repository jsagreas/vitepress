---
title: 15、容器故障排查诊断
---
## 📚 目录

1. [容器故障排查概述](#1-容器故障排查概述)
2. [容器启动失败诊断](#2-容器启动失败诊断)
3. [网络连接问题排查](#3-网络连接问题排查)
4. [存储挂载问题解决](#4-存储挂载问题解决)
5. [资源不足问题定位](#5-资源不足问题定位)
6. [日志分析与调试](#6-日志分析与调试)
7. [性能问题排查方法](#7-性能问题排查方法)
8. [镜像构建失败处理](#8-镜像构建失败处理)
9. [容器运行时错误解决](#9-容器运行时错误解决)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 容器故障排查概述


### 1.1 什么是容器故障排查


**简单理解**：就像医生看病一样，当容器"生病"了，我们需要通过各种"检查手段"来找出问题所在，然后"对症下药"。

```
容器故障就像汽车故障：
汽车启动不了 → 检查电池、油量、发动机
容器启动不了 → 检查镜像、配置、资源

汽车跑得慢 → 检查轮胎、引擎、燃油
容器运行慢 → 检查CPU、内存、网络
```

**核心概念**：
- **故障现象**：容器表现出的异常行为
- **故障原因**：导致异常的根本问题
- **诊断方法**：找出问题的具体手段
- **解决方案**：修复问题的操作步骤

### 1.2 容器故障的常见分类


**按故障阶段分类**：
```
构建阶段故障：
镜像构建失败 → Dockerfile语法错误、依赖问题

启动阶段故障：  
容器启动失败 → 镜像问题、配置错误、资源不足

运行阶段故障：
应用异常退出 → 代码bug、环境变量、网络问题

性能阶段故障：
运行缓慢 → 资源瓶颈、配置不当、硬件限制
```

**按影响范围分类**：

| 故障类型 | **影响范围** | **典型表现** | **紧急程度** |
|---------|------------|-------------|-------------|
| 🔴 **系统级** | `整个容器平台` | `Docker服务停止` | `🚨 极高` |
| 🟡 **容器级** | `单个容器实例` | `容器无法启动` | `⚠️ 高` |
| 🟢 **应用级** | `容器内应用` | `服务响应慢` | `💡 中等` |

### 1.3 故障排查的基本思路


**🎯 排查原则**：
```
由外到内：先检查宿主机，再检查容器内部
由简到繁：先检查基础配置，再检查复杂逻辑  
由近到远：先看最近的改动，再查历史问题
由日志到现象：先看错误信息，再分析具体表现
```

**📋 标准流程**：

1️⃣ **收集信息** → 了解故障现象和环境
2️⃣ **初步判断** → 确定可能的故障类型  
3️⃣ **定位问题** → 使用工具精确找到原因
4️⃣ **制定方案** → 设计解决问题的步骤
5️⃣ **执行修复** → 实施解决方案
6️⃣ **验证结果** → 确认问题已经解决
7️⃣ **总结经验** → 记录问题和解决方法

---

## 2. 🚀 容器启动失败诊断


### 2.1 启动失败的常见原因


**🔸 镜像相关问题**
```
镜像不存在：
docker run non-existent-image
→ Unable to find image 'non-existent-image:latest'

镜像损坏：
镜像文件不完整或校验失败
→ 重新拉取或构建镜像

镜像版本错误：
使用了错误的标签版本
→ 检查镜像标签是否正确
```

**🔸 配置相关问题**
```
端口冲突：
-p 80:80 但宿主机80端口已被占用
→ Error: port is already allocated

环境变量错误：
应用需要的环境变量未设置或值错误
→ 应用启动时找不到配置

挂载路径问题：
-v /wrong/path:/app/data
→ 路径不存在或权限不足
```

### 2.2 诊断启动问题的方法


**📊 基础检查命令**

```bash
# 查看容器状态
docker ps -a                    # 查看所有容器状态
docker inspect container-name   # 详细查看容器配置

# 查看启动日志
docker logs container-name      # 查看容器日志
docker logs -f container-name   # 实时跟踪日志
docker logs --tail 50 container-name  # 查看最后50行
```

**🔧 详细诊断步骤**

**步骤1：检查容器状态**
```bash
docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
```
状态说明：
- `Up X minutes` → 容器正常运行
- `Exited (0)` → 正常退出
- `Exited (1)` → 异常退出
- `Restarting` → 不断重启（通常有问题）

**步骤2：查看详细配置**
```bash
docker inspect container-name | grep -A 5 -B 5 "Error\|Status\|ExitCode"
```

**步骤3：分析启动命令**
```bash
# 检查启动命令是否正确
docker run --name test-container \
  -e APP_ENV=production \
  -p 8080:80 \
  -v /host/data:/app/data \
  nginx:latest
```

### 2.3 常见启动失败解决方案


**📋 问题检查清单**

- [ ] **镜像检查**
  ```bash
  docker images | grep image-name    # 镜像是否存在
  docker pull image-name:tag         # 重新拉取镜像
  ```

- [ ] **端口检查** 
  ```bash
  netstat -tulpn | grep :80          # 检查端口占用
  lsof -i :80                        # 查看端口使用情况
  ```

- [ ] **路径检查**
  ```bash
  ls -la /host/path                  # 检查挂载路径是否存在
  chmod 755 /host/path               # 调整权限
  ```

- [ ] **资源检查**
  ```bash
  free -h                           # 检查内存使用
  df -h                             # 检查磁盘空间
  ```

**💡 快速修复技巧**

```
端口冲突 → 换个端口：
docker run -p 8081:80 nginx

权限问题 → 调整用户：
docker run --user 1000:1000 image

内存不足 → 限制内存：
docker run -m 512m image

路径不存在 → 创建路径：
mkdir -p /host/data && docker run -v /host/data:/app image
```

---

## 3. 🌐 网络连接问题排查


### 3.1 容器网络基础理解


**🏠 网络就像房子的门牌和道路**
```
宿主机 = 小区
容器 = 小区里的房子
网络 = 房子之间的道路
端口 = 房子的门牌号

容器访问外网 = 房子里的人要出小区
外网访问容器 = 小区外的人要进入某个房子
容器间通信 = 小区内房子之间串门
```

**🔗 Docker网络类型**

| 网络模式 | **作用说明** | **适用场景** | **连接方式** |
|---------|------------|-------------|-------------|
| 🌉 **bridge** | `默认模式，容器间可通信` | `一般应用` | `通过docker0网桥` |
| 🏠 **host** | `共享宿主机网络` | `高性能需求` | `直接使用宿主机IP` |
| 🚫 **none** | `无网络连接` | `安全隔离` | `完全隔离` |
| 🔗 **container** | `共享其他容器网络` | `服务依赖` | `使用指定容器网络` |

### 3.2 网络问题的诊断方法


**🔍 网络检查工具包**

```bash
# 基础网络信息查看
docker network ls                    # 查看所有网络
docker network inspect bridge       # 检查网络详情
docker port container-name          # 查看端口映射

# 容器网络状态检查  
docker exec container-name ip addr show     # 查看容器IP
docker exec container-name netstat -tulpn   # 查看容器端口
docker exec container-name ping google.com  # 测试外网连接
```

**📊 网络连接测试步骤**

**步骤1：确认容器网络配置**
```bash
# 查看容器IP地址
docker inspect container-name | grep IPAddress

# 查看端口映射情况
docker port container-name
# 输出示例：80/tcp -> 0.0.0.0:8080
```

**步骤2：测试网络连通性**
```bash
# 从宿主机ping容器
ping container-ip

# 从容器ping外网
docker exec container-name ping -c 3 8.8.8.8

# 测试端口连通性
telnet localhost 8080
# 或者使用
nc -zv localhost 8080
```

**步骤3：检查防火墙设置**
```bash
# CentOS/RHEL系统
systemctl status firewalld
firewall-cmd --list-ports

# Ubuntu系统  
ufw status
iptables -L -n
```

### 3.3 常见网络问题及解决方案


**🚫 端口无法访问问题**

**问题现象**：浏览器访问 `http://服务器IP:8080` 无响应

**排查步骤**：
```bash
# 1. 检查容器是否运行
docker ps | grep container-name

# 2. 检查端口映射
docker port container-name
# 应该看到：80/tcp -> 0.0.0.0:8080

# 3. 在容器内测试服务
docker exec container-name curl localhost:80

# 4. 在宿主机测试端口
curl localhost:8080

# 5. 检查防火墙
netstat -tulpn | grep 8080
```

**解决方案**：
```bash
# 如果端口映射错误，重新运行容器
docker run -p 8080:80 nginx

# 如果防火墙阻止，开放端口
firewall-cmd --add-port=8080/tcp --permanent
firewall-cmd --reload
```

**🔗 容器间通信问题**

**场景**：Web容器需要连接数据库容器

```bash
# 创建自定义网络（推荐方式）
docker network create myapp-network

# 在同一网络中启动容器
docker run -d --name mysql --network myapp-network mysql:8.0
docker run -d --name webapp --network myapp-network webapp:latest

# 容器内可以通过名称访问
# webapp容器内可以用 "mysql" 作为主机名连接数据库
```

**传统方式（不推荐）**：
```bash
# 使用--link参数（已过时）
docker run -d --name mysql mysql:8.0
docker run -d --name webapp --link mysql:database webapp:latest
```

---

## 4. 💾 存储挂载问题解决


### 4.1 容器存储基础概念


**📁 存储就像租房的行李箱**
```
容器 = 临时住所（搬家时所有东西都带走）
挂载卷 = 保险箱（即使搬家，重要物品还在）
绑定挂载 = 与房东共用某个房间
临时卷 = 住宿期间的临时储物柜
```

**存储类型对比**：

| 存储类型 | **数据位置** | **生命周期** | **使用场景** |
|---------|-------------|-------------|-------------|
| 🗂️ **Volume** | `Docker管理` | `独立于容器` | `数据库文件、配置文件` |
| 📁 **Bind Mount** | `宿主机指定路径` | `依赖宿主机` | `开发时代码共享` |
| 💾 **tmpfs** | `内存中` | `容器销毁即消失` | `临时文件、敏感数据` |

### 4.2 存储问题的诊断方法


**🔍 存储检查命令**

```bash
# 查看容器挂载信息
docker inspect container-name | grep -A 20 "Mounts"

# 查看所有卷
docker volume ls

# 查看卷详细信息
docker volume inspect volume-name

# 查看容器内挂载点
docker exec container-name df -h
docker exec container-name mount | grep -E "(bind|volume)"
```

**📊 存储问题诊断流程**

**步骤1：确认挂载配置**
```bash
# 查看容器启动时的挂载参数
docker inspect container-name | jq '.[0].Config.Cmd'
docker inspect container-name | jq '.[0].Mounts'
```

**步骤2：检查路径和权限**
```bash
# 检查宿主机路径
ls -la /host/path
# 应该看到目录存在且有适当权限

# 检查容器内路径  
docker exec container-name ls -la /app/data
# 应该看到挂载成功的文件
```

**步骤3：测试读写权限**
```bash
# 在容器内创建测试文件
docker exec container-name touch /app/data/test.txt

# 在宿主机查看是否出现
ls /host/path/test.txt

# 反向测试
echo "test" > /host/path/host-test.txt
docker exec container-name cat /app/data/host-test.txt
```

### 4.3 常见存储问题及解决方案


**❌ 权限拒绝问题**

**问题现象**：
```bash
docker logs container-name
# 看到错误：Permission denied: /app/data/file.txt
```

**🔧 解决方案**：

**方法1：调整目录权限**
```bash
# 给目录设置合适的权限
chmod 755 /host/data
chown 1000:1000 /host/data  # 1000是容器内用户ID

# 或者设置为任何用户都可读写
chmod 777 /host/data
```

**方法2：指定容器运行用户**
```bash
# 以指定用户身份运行容器
docker run --user 1000:1000 -v /host/data:/app/data image-name

# 或者以root用户运行（不推荐生产环境）
docker run --user root -v /host/data:/app/data image-name
```

**📁 文件不同步问题**

**问题现象**：宿主机上修改文件，容器内看不到变化

**排查步骤**：
```bash
# 1. 确认挂载是否生效
docker exec container-name mount | grep /app/data

# 2. 检查是否是缓存问题
# 在容器内刷新文件系统缓存
docker exec container-name sync

# 3. 重启容器试试
docker restart container-name
```

**💿 卷空间不足问题**

**问题现象**：
```bash
docker logs container-name
# 错误：No space left on device
```

**解决方案**：
```bash
# 1. 检查磁盘空间
df -h
docker system df  # 查看Docker占用空间

# 2. 清理不用的资源
docker system prune -a  # 清理未使用的镜像、容器、网络、卷

# 3. 清理特定类型资源
docker volume prune     # 清理未使用的卷
docker image prune      # 清理未使用的镜像

# 4. 查找占用空间大的文件
du -sh /var/lib/docker/*
```

**🔄 数据迁移方案**

```bash
# 备份卷数据
docker run --rm -v volume-name:/data -v $(pwd):/backup \
  busybox tar czf /backup/backup.tar.gz /data

# 恢复卷数据  
docker run --rm -v volume-name:/data -v $(pwd):/backup \
  busybox tar xzf /backup/backup.tar.gz -C /
```

---

## 5. 📊 资源不足问题定位


### 5.1 容器资源管理基础


**💡 资源管理就像餐厅管理**
```
CPU = 厨师数量（处理任务的能力）
内存 = 餐桌数量（同时服务的客人数）
磁盘IO = 上菜速度（数据传输快慢）  
网络 = 服务员数量（网络传输能力）

资源不足 = 客人太多，厨师、桌子、服务员不够用
```

**🎯 资源监控的重要指标**

| 资源类型 | **关键指标** | **正常范围** | **警告阈值** |
|---------|-------------|-------------|-------------|
| 💻 **CPU** | `使用率%` | `< 70%` | `> 85%` |
| 🧠 **内存** | `使用率%，剩余量` | `< 80%` | `> 90%` |
| 💾 **磁盘** | `使用率%，IO等待` | `< 80%` | `> 90%` |
| 🌐 **网络** | `带宽使用，连接数` | `根据带宽而定` | `接近带宽上限` |

### 5.2 资源监控和诊断方法


**🔧 资源监控工具**

```bash
# Docker内置监控
docker stats                    # 实时查看所有容器资源使用
docker stats container-name     # 查看特定容器资源使用

# 系统级资源监控
top                            # 查看系统整体资源使用  
htop                           # 更直观的系统资源显示
free -h                        # 查看内存使用情况
df -h                          # 查看磁盘使用情况
iostat 1                       # 查看磁盘IO情况
```

**📈 详细监控示例**

```bash
# 实时监控容器资源（每2秒刷新）
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}"

# 输出示例：
# CONTAINER    CPU %    MEM USAGE / LIMIT     NET I/O      BLOCK I/O
# webapp       15.3%    256MiB / 1GiB         1.2MB/890kB  12MB/4.5MB
# mysql        8.1%     512MiB / 2GiB         890kB/1.2MB  45MB/12MB
```

**🔍 容器内资源检查**
```bash
# 进入容器查看资源使用
docker exec -it container-name bash

# 在容器内检查
ps aux | head -10              # 查看进程CPU使用
free -h                        # 查看内存使用
df -h                          # 查看磁盘使用
netstat -i                     # 查看网络接口状态
```

### 5.3 常见资源问题及解决方案


**🧠 内存不足问题**

**问题现象**：
```bash
# 容器被系统杀死
docker logs container-name
# 看到：Killed (OOMKilled)

# 或者应用响应极慢
```

**🔧 解决方案**：

**方法1：增加内存限制**
```bash
# 重新启动容器并设置更大内存限制
docker run -m 2g image-name    # 限制最大2GB内存

# 查看当前内存限制
docker inspect container-name | grep -i memory
```

**方法2：优化应用内存使用**
```bash
# Java应用示例：设置JVM内存参数
docker run -e JAVA_OPTS="-Xmx1g -Xms512m" java-app

# Node.js应用示例：设置内存限制
docker run -e NODE_OPTIONS="--max-old-space-size=1024" node-app
```

**⚡ CPU性能问题**

**问题现象**：
```bash
docker stats
# 看到CPU使用率持续100%，应用响应缓慢
```

**解决方案**：

```bash
# 设置CPU限制，避免某个容器占用过多CPU
docker run --cpus="1.5" image-name        # 限制使用1.5个CPU核心
docker run --cpu-shares=512 image-name    # 设置CPU权重

# 查看CPU使用详情
docker exec container-name top -bn1 | head -20
```

**💾 磁盘IO问题**

**问题现象**：
```bash
iostat 1
# 看到%iowait很高（>30%），磁盘读写缓慢
```

**解决方案**：

```bash
# 设置磁盘IO限制
docker run --device-read-bps /dev/sda:1mb image-name   # 限制读取速度
docker run --device-write-bps /dev/sda:1mb image-name  # 限制写入速度

# 使用更快的存储
docker run -v /ssd/data:/app/data image-name  # 使用SSD存储
```

**🌐 网络资源问题**

**问题现象**：网络延迟高，连接超时

**解决方案**：

```bash
# 检查网络延迟
docker exec container-name ping -c 5 external-service

# 优化网络配置
docker run --network host image-name        # 使用主机网络（性能最好）
docker run --dns=8.8.8.8 image-name        # 设置更快的DNS服务器
```

### 5.4 资源优化最佳实践


**🎯 资源分配策略**

```
开发环境：
CPU: 宽松限制，便于调试
内存: 适中限制，避免系统卡死
磁盘: 不限制，方便开发

生产环境：  
CPU: 根据负载设置严格限制
内存: 设置合理限制+监控告警
磁盘: 限制IO，保护系统稳定性
```

**📊 监控告警设置**

```bash
# 设置资源监控脚本
#!/bin/bash
# monitor.sh
while true; do
    docker stats --no-stream --format "{{.Container}}: CPU {{.CPUPerc}} MEM {{.MemPerc}}" | \
    while read line; do
        cpu=$(echo $line | grep -o 'CPU [0-9.]*%' | grep -o '[0-9.]*')
        if (( $(echo "$cpu > 85" | bc -l) )); then
            echo "WARNING: High CPU usage - $line"
        fi
    done
    sleep 10
done
```

---

## 6. 📝 日志分析与调试


### 6.1 容器日志系统理解


**📄 日志就像医院的病历记录**
```
症状记录 = 应用日志（记录程序运行情况）
检查报告 = 系统日志（记录容器运行状态）  
医生笔记 = 调试信息（开发时的详细追踪）
病历总结 = 日志聚合（多个来源的统一视图）
```

**🔍 容器日志的来源**

```
容器层面日志：
├── 标准输出(stdout) → docker logs直接显示
├── 标准错误(stderr) → 错误信息输出
├── 应用日志文件 → 程序写入的日志文件
└── 系统事件日志 → Docker守护进程记录

日志流向：
应用程序 → 容器内 → Docker引擎 → 日志驱动 → 存储位置
```

### 6.2 日志查看和分析方法


**🛠️ 基础日志查看命令**

```bash
# 查看容器日志的基本命令
docker logs container-name              # 查看所有日志
docker logs -f container-name           # 实时跟踪日志（类似tail -f）
docker logs --tail 100 container-name   # 查看最后100行
docker logs -t container-name           # 显示时间戳
docker logs --since 2h container-name   # 查看最近2小时的日志
```

**📊 日志分析实用技巧**

```bash
# 过滤特定关键词
docker logs container-name | grep "ERROR"
docker logs container-name | grep -i "exception"

# 统计错误数量
docker logs container-name | grep -c "ERROR"

# 查看特定时间段的错误
docker logs --since "2024-01-01T10:00:00" --until "2024-01-01T11:00:00" container-name

# 组合多个过滤条件
docker logs container-name | grep -E "(ERROR|FATAL|Exception)" | tail -20
```

**🔧 高级日志分析**

```bash
# 实时监控多个关键词
docker logs -f container-name | grep --color=always -E "(ERROR|WARN|INFO)"

# 日志输出到文件便于分析
docker logs container-name > /tmp/container.log 2>&1

# 使用jq分析JSON格式日志
docker logs container-name | jq '.level, .message, .timestamp'
```

### 6.3 常见日志问题及解决方案


**🚫 找不到日志信息**

**问题现象**：
```bash
docker logs container-name
# 没有任何输出，或者输出很少
```

**🔍 排查步骤**：

**步骤1：检查应用日志配置**
```bash
# 查看应用是否正确输出到stdout/stderr
docker exec container-name ps aux  # 确认进程在运行

# 进入容器检查日志文件
docker exec -it container-name bash
ls -la /app/logs/
tail -f /app/logs/application.log
```

**步骤2：检查Docker日志驱动**
```bash
# 查看容器的日志配置
docker inspect container-name | grep -A 5 "LogConfig"

# 可能的日志驱动类型：
# json-file（默认）、syslog、journald、none等
```

**解决方案**：
```bash
# 如果应用日志写入文件，需要挂载日志目录
docker run -v /host/logs:/app/logs image-name

# 或者修改应用配置，让日志输出到stdout
# 在应用配置中设置：console output = true
```

**📈 日志量过大问题**

**问题现象**：日志文件占用大量磁盘空间

**解决方案**：

```bash
# 设置日志轮转（推荐方式）
docker run --log-opt max-size=10m --log-opt max-file=3 image-name
# 限制单个日志文件最大10MB，最多保留3个文件

# 清理现有的大日志文件
docker logs container-name > /dev/null  # 清空当前日志（谨慎操作）

# 或者重启容器来重置日志
docker restart container-name
```

**🔍 调试应用问题**

**场景**：应用运行异常，需要深入调试

**调试步骤**：

**步骤1：启用详细日志**
```bash
# 重新运行容器，启用debug模式
docker run -e LOG_LEVEL=debug image-name
# 或者
docker run -e DEBUG=true image-name
```

**步骤2：实时监控日志**
```bash
# 开启多个终端，分别监控不同类型的日志
# 终端1：监控应用日志
docker logs -f container-name

# 终端2：监控系统资源
docker stats container-name

# 终端3：进入容器内部调试
docker exec -it container-name bash
```

**步骤3：收集调试信息**
```bash
# 导出完整的调试信息
{
  echo "=== 容器配置 ==="
  docker inspect container-name
  echo "=== 容器日志 ==="  
  docker logs container-name
  echo "=== 系统资源 ==="
  docker stats --no-stream container-name
} > debug-info.txt
```

### 6.4 日志最佳实践


**📋 日志配置建议**

```
应用层面：
✅ 统一日志格式（建议JSON格式）
✅ 合理的日志级别（DEBUG/INFO/WARN/ERROR）
✅ 包含关键信息（时间戳、用户ID、请求ID等）
✅ 避免敏感信息（密码、Token等）

容器层面：
✅ 设置日志轮转，避免磁盘占满
✅ 使用标准输出，便于统一收集
✅ 区分不同类型的日志流
✅ 设置合理的日志保留时间
```

**🎯 日志监控告警**

```bash
# 简单的日志监控脚本
#!/bin/bash
# log_monitor.sh

ERROR_COUNT=$(docker logs --since 5m container-name | grep -c "ERROR")

if [ $ERROR_COUNT -gt 10 ]; then
    echo "警告：最近5分钟内发现 $ERROR_COUNT 个错误！"
    # 这里可以发送邮件或短信通知
fi
```

---

## 7. 📈 性能问题排查方法


### 7.1 容器性能基础概念


**🏃 性能就像跑步比赛**
```
吞吐量 = 单位时间能完成多少事情（每小时跑多少圈）
延迟 = 完成一件事需要多长时间（跑一圈用时多久）
响应时间 = 从开始到结束的总时间（从起跑到冲线）
资源利用率 = 身体各部分的使用情况（心率、肌肉使用率）
```

**⚡ 性能指标体系**

| 性能维度 | **关键指标** | **测量方法** | **正常值参考** |
|---------|-------------|-------------|---------------|
| 🚀 **响应性能** | `响应时间、QPS` | `压力测试工具` | `< 200ms响应` |
| 💻 **系统性能** | `CPU、内存使用率` | `docker stats` | `CPU<80%, MEM<85%` |
| 💾 **I/O性能** | `磁盘读写速度` | `iostat工具` | `根据硬件而定` |
| 🌐 **网络性能** | `带宽、连接数` | `网络监控工具` | `延迟<10ms` |

### 7.2 性能监控和测试方法


**🔧 性能监控工具包**

```bash
# 实时性能监控
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"

# 详细的系统性能分析
# 安装性能分析工具
sudo apt-get install sysstat htop iotop

# CPU性能分析
top -p $(docker inspect container-name | grep Pid | grep -o '[0-9]*')
htop -p $(docker inspect container-name | grep Pid | grep -o '[0-9]*')

# 内存分析
free -h && cat /proc/meminfo | grep -E "(MemTotal|MemFree|MemAvailable)"

# 磁盘I/O分析  
iostat -x 1    # 每秒显示磁盘I/O统计
iotop          # 实时显示进程I/O使用情况
```

**📊 应用性能测试**

```bash
# HTTP接口性能测试
# 使用curl进行简单测试
time curl http://localhost:8080/api/users

# 使用ab（Apache Benchmark）进行压力测试
ab -n 1000 -c 10 http://localhost:8080/api/users
# -n 1000: 总共发送1000个请求
# -c 10: 并发10个请求

# 使用wrk进行现代化压力测试
wrk -t4 -c100 -d30s http://localhost:8080/api/users
# -t4: 4个线程
# -c100: 100个并发连接  
# -d30s: 测试持续30秒
```

**🔍 容器内性能分析**

```bash
# 进入容器进行内部分析
docker exec -it container-name bash

# 在容器内查看进程性能
top              # 查看CPU和内存使用
ps aux --sort=-%cpu | head -10    # 按CPU使用率排序
ps aux --sort=-%mem | head -10    # 按内存使用率排序

# 查看网络连接情况
netstat -an | grep ESTABLISHED | wc -l    # 统计活跃连接数
netstat -tulpn                            # 查看监听端口
```

### 7.3 常见性能问题及优化方案


**🐌 应用响应缓慢**

**问题现象**：
```bash
# 接口响应时间过长
curl -w "@curl-format.txt" -o /dev/null -s http://localhost:8080/api/slow

# curl-format.txt内容：
# time_namelookup: %{time_namelookup}s
# time_connect: %{time_connect}s  
# time_appconnect: %{time_appconnect}s
# time_pretransfer: %{time_pretransfer}s
# time_redirect: %{time_redirect}s
# time_starttransfer: %{time_starttransfer}s
# time_total: %{time_total}s
```

**🔧 优化方案**：

**方案1：应用层面优化**
```bash
# 增加应用线程/进程数
# Java应用示例
docker run -e JAVA_OPTS="-server -Xmx2g" \
  -e TOMCAT_MAX_THREADS=200 \
  java-web-app

# Node.js应用示例
docker run -e UV_THREADPOOL_SIZE=128 node-app

# Python应用示例（使用gunicorn）
docker run -e GUNICORN_WORKERS=4 python-app
```

**方案2：数据库连接优化**
```bash
# 数据库连接池配置示例
# MySQL连接池
docker run -e DB_POOL_SIZE=20 \
  -e DB_POOL_MAX_IDLE=5 \
  -e DB_POOL_MAX_LIFETIME=3600 \
  web-app
```

**🔥 CPU使用率过高**

**问题排查**：
```bash
# 找出CPU占用最高的进程
docker exec container-name top -bn1 | head -20

# 使用性能分析工具
# 安装perf工具
sudo apt-get install linux-perf

# 分析CPU热点
sudo perf top -p $(docker inspect container-name | grep Pid | grep -o '[0-9]*')
```

**优化方案**：
```bash
# 限制CPU使用，避免影响其他服务
docker run --cpus="2.0" image-name

# 使用多核优化
docker run -e OMP_NUM_THREADS=4 image-name  # 对于支持OpenMP的应用

# 代码层面优化（示例）
# 减少循环复杂度、使用缓存、异步处理等
```

**🧠 内存泄漏问题**

**问题检测**：
```bash
# 持续监控内存使用变化
while true; do
  docker stats --no-stream container-name | grep -o '[0-9.]*GiB'
  sleep 10
done

# Java应用内存分析
docker exec container-name jstat -gc PID 5s
```

**解决方案**：
```bash
# Java应用内存调优
docker run -e JAVA_OPTS="-Xmx1g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/app/dumps" \
  java-app

# Node.js内存限制
docker run -e NODE_OPTIONS="--max-old-space-size=1024" node-app

# 设置容器内存限制和交换区
docker run -m 2g --memory-swap=4g image-name
```

### 7.4 性能优化最佳实践


**🎯 容器性能调优策略**

```
资源配置优化：
✅ 合理设置CPU和内存限制
✅ 使用适当的存储类型（SSD vs HDD）
✅ 选择合适的网络模式
✅ 优化镜像大小和层数

应用配置优化：
✅ 调整应用线程池大小
✅ 配置合适的数据库连接池
✅ 启用应用缓存机制
✅ 使用异步处理方式
```

**📊 性能监控告警**

```bash
#!/bin/bash
# performance_monitor.sh

# 检查CPU使用率
CPU_USAGE=$(docker stats --no-stream container-name | awk 'NR==2{print $3}' | sed 's/%//')
if (( $(echo "$CPU_USAGE > 80" | bc -l) )); then
    echo "警告：CPU使用率过高 - $CPU_USAGE%"
fi

# 检查内存使用率
MEM_USAGE=$(docker stats --no-stream container-name | awk 'NR==2{print $7}' | sed 's/%//')
if (( $(echo "$MEM_USAGE > 85" | bc -l) )); then
    echo "警告：内存使用率过高 - $MEM_USAGE%"
fi

# 检查响应时间
RESPONSE_TIME=$(curl -w "%{time_total}" -o /dev/null -s http://localhost:8080/health)
if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
    echo "警告：响应时间过慢 - ${RESPONSE_TIME}s"
fi
```

---

## 8. 🛠️ 镜像构建失败处理


### 8.1 镜像构建基础理解


**🏗️ 构建镜像就像盖房子**
```
Dockerfile = 建筑图纸（详细的施工步骤）
基础镜像 = 地基（房子的基础结构）
各层指令 = 施工步骤（一步步搭建房子）
构建上下文 = 施工材料（需要的所有文件）
最终镜像 = 完工的房子（可以居住的成品）
```

**🔨 构建过程详解**

```
构建阶段：
1. 准备构建上下文 → 收集Dockerfile和相关文件
2. 解析Dockerfile → 理解每一条构建指令  
3. 逐层构建 → 按顺序执行每条指令
4. 创建镜像层 → 每条指令创建一个新层
5. 生成最终镜像 → 将所有层组合成镜像

常见指令作用：
FROM → 选择基础镜像
COPY → 复制文件到镜像
RUN → 执行命令安装软件
ENV → 设置环境变量
EXPOSE → 声明端口
CMD → 设置启动命令
```

### 8.2 构建失败诊断方法


**🔍 构建错误分析步骤**

**步骤1：查看详细构建日志**
```bash
# 启用详细日志构建
docker build --no-cache --progress=plain -t image-name .

# 或者保存构建日志到文件
docker build -t image-name . > build.log 2>&1
```

**步骤2：定位失败的具体指令**
```bash
# 构建失败时，Docker会显示类似信息：
# Step 5/8 : RUN npm install
# ---> Running in 1234567890ab
# npm ERR! Cannot resolve dependency
# The command '/bin/sh -c npm install' returned a non-zero code: 1
```

**步骤3：使用中间容器调试**
```bash
# 如果第5步失败，可以基于第4步的中间镜像进行调试
docker run -it <第4步的镜像ID> bash

# 在容器内手动执行失败的命令
npm install
# 查看详细错误信息，找出问题原因
```

### 8.3 常见构建失败问题及解决方案


**❌ 基础镜像问题**

**问题现象**：
```dockerfile
FROM node:16-alpine
# 错误：Unable to find image 'node:16-alpine:latest' locally
```

**🔧 解决方案**：

```dockerfile
# 方案1：使用确切存在的标签
FROM node:16.20.0-alpine

# 方案2：先手动拉取镜像
# docker pull node:16-alpine
# 然后再构建

# 方案3：使用替代的基础镜像
FROM node:16
# 或
FROM alpine:3.16
RUN apk add --no-cache nodejs npm
```

**📦 依赖安装失败**

**问题现象**：
```dockerfile
RUN npm install
# 错误：npm ERR! network timeout
# 或者：E: Unable to locate package python3-pip
```

**解决方案**：

```dockerfile
# Node.js依赖问题解决
FROM node:16-alpine

# 设置npm镜像源
RUN npm config set registry https://registry.npm.taobao.org/

# 清理npm缓存后安装
RUN npm cache clean --force && npm install

# 或者使用cnpm
RUN npm install -g cnpm --registry=https://registry.npm.taobao.org/
RUN cnpm install

# Python依赖问题解决  
FROM ubuntu:20.04

# 更新包索引
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    && rm -rf /var/lib/apt/lists/*

# Alpine系统的包管理
FROM alpine:3.16
RUN apk add --no-cache python3 py3-pip
```

**🗂️ 文件复制问题**

**问题现象**：
```dockerfile
COPY ./app /app
# 错误：COPY failed: file not found in build context
```

**解决方案**：

```dockerfile
# 检查构建上下文
# 确保文件在docker build执行目录下

# 正确的文件路径
COPY app/ /app/          # 复制app目录下所有内容
COPY requirements.txt /app/  # 复制单个文件

# 使用通配符
COPY *.py /app/          # 复制所有.py文件

# 检查.dockerignore文件
# 确保需要的文件没有被忽略
```

**⏰ 构建超时问题**

**问题现象**：构建过程卡住或超时

**解决方案**：

```dockerfile
# 设置构建超时时间
# docker build --build-arg BUILDKIT_INLINE_CACHE=1 -t image-name .

# 对于需要长时间的操作，增加超时设置
FROM ubuntu:20.04

# 设置环境变量避免交互
ENV DEBIAN_FRONTEND=noninteractive

# 分步骤安装，便于调试
RUN apt-get update
RUN apt-get install -y python3 python3-pip
RUN pip3 install -r requirements.txt

# 使用多阶段构建减少最终镜像大小
FROM ubuntu:20.04 AS builder
RUN apt-get update && apt-get install -y build-essential
COPY . /src
WORKDIR /src
RUN make build

FROM ubuntu:20.04
COPY --from=builder /src/dist /app
```

### 8.4 构建优化最佳实践


**🚀 构建效率优化**

```dockerfile
# 优化Dockerfile的层顺序
FROM node:16-alpine

# 1. 先复制依赖文件（变化较少）
COPY package*.json ./
RUN npm install

# 2. 再复制源代码（变化较多）
COPY . .

# 3. 构建应用
RUN npm run build

# 使用.dockerignore减少构建上下文
# .dockerignore文件内容：
# node_modules
# .git
# .gitignore
# README.md
# Dockerfile*
# .dockerignore
```

**💡 构建时间优化技巧**

```bash
# 使用BuildKit加速构建
export DOCKER_BUILDKIT=1
docker build -t image-name .

# 使用缓存加速
docker build --cache-from image-name:latest -t image-name:new .

# 并行构建多个镜像
docker build -t app1 ./app1 &
docker build -t app2 ./app2 &
wait
```

**🔄 构建故障自动处理**

```bash
#!/bin/bash
# auto_build.sh - 自动重试构建脚本

IMAGE_NAME="my-app"
MAX_RETRIES=3
RETRY_COUNT=0

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    echo "开始构建尝试 $((RETRY_COUNT + 1))/$MAX_RETRIES"
    
    if docker build -t $IMAGE_NAME .; then
        echo "构建成功！"
        exit 0
    else
        echo "构建失败，准备重试..."
        RETRY_COUNT=$((RETRY_COUNT + 1))
        
        # 清理可能的问题
        docker system prune -f
        sleep 10
    fi
done

echo "构建失败，已达到最大重试次数"
exit 1
```

---

## 9. ⚠️ 容器运行时错误解决


### 9.1 运行时错误类型概述


**🔄 运行时错误就像汽车行驶中的故障**
```
启动故障 = 汽车打不着火（配置问题、环境问题）
运行崩溃 = 汽车行驶中熄火（代码bug、资源不足）
服务异常 = 汽车功能失效（网络问题、依赖故障）
性能下降 = 汽车跑得慢（资源竞争、配置不当）
```

**🎯 错误分类体系**

| 错误类型 | **典型表现** | **影响程度** | **处理紧急度** |
|---------|------------|-------------|---------------|
| 🚨 **系统级错误** | `容器无法启动` | `服务完全不可用` | `🔥 极紧急` |
| ⚠️ **应用级错误** | `功能异常` | `部分功能不可用` | `📈 紧急` |
| 📉 **性能问题** | `响应缓慢` | `用户体验下降` | `🔍 重要` |
| 🔧 **配置问题** | `行为不符合预期` | `功能受限` | `📋 一般` |

### 9.2 运行时错误诊断流程


**🔍 标准错误诊断步骤**

```bash
# 步骤1：快速状态检查
docker ps -a | grep container-name     # 查看容器状态
docker logs --tail 50 container-name   # 查看最近日志

# 步骤2：详细信息收集
docker inspect container-name          # 获取详细配置信息
docker stats container-name            # 查看资源使用情况

# 步骤3：环境验证  
docker exec container-name env          # 检查环境变量
docker exec container-name ps aux       # 检查运行进程
docker exec container-name netstat -tulpn  # 检查网络端口

# 步骤4：依赖检查
docker network ls                       # 检查网络配置
docker volume ls                        # 检查存储卷
```

**📊 错误信息解读**

```bash
# 常见错误状态码含义
docker ps -a
# STATUS列的含义：
# Exited (0) → 正常退出
# Exited (1) → 一般性错误
# Exited (125) → Docker守护进程错误  
# Exited (126) → 容器命令不可执行
# Exited (127) → 容器命令未找到
# Exited (137) → 被SIGKILL信号杀死（通常是内存不足）
# Exited (139) → 段错误（程序内部错误）
```

### 9.3 典型运行时错误解决方案


**🔴 容器异常退出**

**问题现象**：
```bash
docker ps -a
# CONTAINER ID   STATUS
# abc123         Exited (137) 5 minutes ago
```

**🔧 解决步骤**：

**步骤1：分析退出原因**
```bash
# 查看详细日志
docker logs container-name

# 查看系统事件
dmesg | grep -i "killed process"    # 查看系统是否杀死了进程

# 检查资源使用
docker stats --no-stream container-name
```

**步骤2：针对性解决**
```bash
# 如果是内存不足（137退出码）
docker run -m 2g image-name         # 增加内存限制

# 如果是找不到命令（127退出码）  
docker run image-name ls -la /app   # 检查文件是否存在
# 可能需要修改Dockerfile中的CMD或ENTRYPOINT

# 如果是权限问题（126退出码）
docker run --user root image-name   # 使用root用户运行
# 或者修改文件权限：chmod +x /app/start.sh
```

**⚡ 应用无响应问题**

**问题现象**：容器在运行，但应用不响应请求

**诊断步骤**：
```bash
# 检查应用进程
docker exec container-name ps aux | grep -v "ps aux"

# 检查端口监听
docker exec container-name netstat -tulpn | grep LISTEN

# 测试应用连通性
docker exec container-name curl localhost:8080/health
curl http://localhost:8080/health  # 从宿主机测试
```

**解决方案**：
```bash
# 如果进程不存在，重启容器
docker restart container-name

# 如果端口没有监听，检查应用配置
docker exec -it container-name bash
# 进入容器检查配置文件，重启应用服务

# 如果是应用死锁，发送信号
docker exec container-name kill -USR1 PID  # 发送用户信号
docker exec container-name kill -HUP PID   # 重新加载配置
```

**🌐 网络连接错误**

**问题现象**：容器内应用无法连接外部服务

**诊断方法**：
```bash
# 测试DNS解析
docker exec container-name nslookup google.com
docker exec container-name dig google.com

# 测试网络连通性
docker exec container-name ping -c 3 8.8.8.8    # 测试外网
docker exec container-name curl -I http://google.com  # 测试HTTP

# 检查容器网络配置
docker inspect container-name | grep -A 10 "NetworkSettings"
```

**解决方案**：
```bash
# DNS问题解决
docker run --dns=8.8.8.8 image-name

# 网络隔离问题
docker run --network host image-name       # 使用主机网络

# 代理环境配置
docker run -e http_proxy=http://proxy:8080 \
           -e https_proxy=http://proxy:8080 \
           image-name
```

**💾 存储访问错误**

**问题现象**：应用无法读写文件

**解决步骤**：
```bash
# 检查挂载状态
docker exec container-name mount | grep /app/data

# 检查权限
docker exec container-name ls -la /app/data

# 测试读写
docker exec container-name touch /app/data/test.txt
docker exec container-name echo "test" > /app/data/test.txt
```

**修复方法**：
```bash
# 权限问题修复
docker exec --user root container-name chown -R appuser:appuser /app/data
docker exec --user root container-name chmod -R 755 /app/data

# 重新挂载（需要重启容器）
docker stop container-name
docker run -v /host/data:/app/data:rw image-name
```

### 9.4 错误预防和监控


**🛡️ 预防性措施**

```dockerfile
# 在Dockerfile中加入健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

# 设置合理的资源限制
# docker run -m 1g --cpus=1.0 --restart=unless-stopped image-name
```

**📊 运行时监控脚本**

```bash
#!/bin/bash
# runtime_monitor.sh

CONTAINER_NAME="my-app"

while true; do
    # 检查容器状态
    STATUS=$(docker inspect -f '{{.State.Status}}' $CONTAINER_NAME 2>/dev/null)
    
    if [ "$STATUS" != "running" ]; then
        echo "警告：容器 $CONTAINER_NAME 状态异常: $STATUS"
        
        # 尝试重启
        echo "尝试重启容器..."
        docker restart $CONTAINER_NAME
        
        sleep 30
        # 再次检查
        STATUS=$(docker inspect -f '{{.State.Status}}' $CONTAINER_NAME 2>/dev/null)
        if [ "$STATUS" = "running" ]; then
            echo "容器重启成功"
        else
            echo "容器重启失败，请手动检查"
        fi
    fi
    
    sleep 60
done
```

**🚨 错误告警系统**

```bash
#!/bin/bash
# error_alert.sh

# 监控容器日志中的错误
docker logs --since 5m container-name | grep -i "error\|exception\|fatal" > /tmp/errors.log

if [ -s /tmp/errors.log ]; then
    ERROR_COUNT=$(wc -l < /tmp/errors.log)
    echo "发现 $ERROR_COUNT 个错误："
    cat /tmp/errors.log
    
    # 这里可以集成邮件或钉钉通知
    # send_notification "容器出现错误" "$(cat /tmp/errors.log)"
fi
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 故障排查思路：由外到内、由简到繁、由近到远、由日志到现象
🔸 基本诊断工具：docker logs、docker stats、docker inspect、docker exec
🔸 常见故障类型：启动失败、网络问题、存储问题、资源不足、运行时错误
🔸 日志分析技巧：时间过滤、关键词搜索、实时监控、日志轮转
🔸 性能优化原则：合理资源分配、应用层优化、监控告警
```

### 10.2 关键理解要点


**🔹 故障排查的系统性方法**
```
信息收集 → 问题定位 → 方案制定 → 执行修复 → 验证结果 → 总结经验

这个流程必须严格遵循，跳过任何环节都可能导致问题复发
```

**🔹 不同类型故障的处理优先级**
```
系统级故障 → 影响最大，优先处理
应用级故障 → 功能受损，及时处理  
性能问题 → 体验影响，持续优化
配置问题 → 功能限制，定期整理
```

**🔹 日志分析的核心技巧**
```
时间维度：--since 和 --until 参数定位问题时间段
内容维度：grep、awk等工具过滤关键信息
实时监控：-f 参数跟踪实时日志变化
结构化：JSON格式日志便于自动化分析
```

### 10.3 实际应用场景总结


**💼 生产环境故障处理流程**

🚨 **紧急故障响应**
```
1分钟内：确认故障影响范围
3分钟内：实施临时恢复措施  
10分钟内：找出根本原因
30分钟内：实施永久解决方案
1小时内：完成故障复盘文档
```

**📋 日常维护检查清单**

- [ ] **每日检查**
  - 容器运行状态
  - 资源使用情况
  - 错误日志统计
  - 网络连通性测试

- [ ] **每周检查**  
  - 磁盘空间使用
  - 日志文件轮转
  - 镜像更新情况
  - 性能趋势分析

- [ ] **每月检查**
  - 容器安全漏洞扫描
  - 资源配置优化
  - 监控告警规则调整
  - 故障处理流程更新

### 10.4 工具和命令速查


**🔧 基础诊断命令组合**
```bash
# 快速状态检查
docker ps -a && docker stats --no-stream

# 日志和配置检查  
docker logs --tail 100 container-name
docker inspect container-name | jq '.State, .Config'

# 资源和网络检查
docker exec container-name free -h
docker exec container-name netstat -tulpn
```

**📊 性能监控命令组合**
```bash
# 实时监控脚本
watch -n 1 'docker stats --no-stream | head -5'

# 资源使用历史
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" | tee -a stats.log

# 应用健康检查
curl -w "响应时间: %{time_total}s\n" -o /dev/null -s http://localhost:8080/health
```

**🛠️ 故障恢复命令模板**
```bash
# 容器重启恢复
docker restart container-name && docker logs -f container-name

# 强制重建恢复
docker stop container-name && docker rm container-name
docker run -d --name container-name [原始启动参数] image-name

# 应急临时恢复
docker run -d --name temp-container -p 8080:80 nginx:latest
```

### 10.5 最佳实践总结


**🎯 预防性维护策略**
```
监控先行：建立完善的监控告警体系
文档齐全：维护详细的运维文档和故障处理手册
自动化：使用脚本自动化常见的故障检查和恢复
备份策略：定期备份重要数据和配置
版本管理：严格的镜像版本管理和回滚机制
```

**💡 经验总结**
```
80%的问题：都是配置错误和资源不足造成
15%的问题：来源于网络和存储问题  
5%的问题：是真正的系统bug或硬件故障

解决思路：
先看日志 → 再查资源 → 然后检配置 → 最后查代码
```

**🎪 高效排障心得**
```
保持冷静：故障面前不慌张，按流程逐步排查
工具熟练：熟悉常用诊断工具，提高排查效率  
记录详细：每次故障都要记录，积累经验库
团队协作：重大故障要多人协作，避免单点风险
持续改进：根据故障情况不断优化监控和流程
```

### 10.6 学习路径建议


**🎓 技能发展阶段**

**初级阶段（1-3个月）**：
- 熟练掌握基本Docker命令
- 理解容器基础概念和常见错误
- 能够查看日志和基础故障排查

**中级阶段（3-6个月）**：
- 掌握性能监控和优化方法
- 熟悉网络和存储问题排查  
- 能够编写简单的监控脚本

**高级阶段（6个月以上）**：
- 建立完整的监控告警体系
- 具备复杂故障的分析能力
- 能够优化整体容器化架构

**🔗 延伸学习建议**

相关技术栈：
- **容器编排**：学习Kubernetes故障排查
- **监控体系**：Prometheus + Grafana监控实践  
- **日志管理**：ELK Stack日志分析
- **DevOps**：CI/CD流水线中的容器化实践

**核心记忆口诀**：
- 故障不慌张，流程要规范
- 日志是线索，资源是关键
- 工具要熟练，经验要积累
- 预防胜治疗，监控要先行