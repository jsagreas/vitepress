---
title: 11、容器监控与日志管理
---
## 📚 目录

1. [容器资源监控基础](#1-容器资源监控基础)
2. [Docker日志系统详解](#2-Docker日志系统详解)
3. [容器健康检查机制](#3-容器健康检查机制)
4. [日志收集与聚合](#4-日志收集与聚合)
5. [性能监控与分析](#5-性能监控与分析)
6. [第三方监控工具集成](#6-第三方监控工具集成)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📊 容器资源监控基础


### 1.1 docker stats命令详解


**什么是容器资源监控**：
简单来说，就是实时查看容器使用了多少CPU、内存、网络、磁盘等资源，就像Windows的任务管理器一样。

**基础语法**：
```bash
# 查看所有运行容器的资源使用情况
docker stats

# 查看指定容器的资源使用
docker stats container_name

# 只显示一次数据（不持续刷新）
docker stats --no-stream
```

### 1.2 监控指标含义详解


**📈 各项指标的通俗解释**：

```
┌─ CPU使用率 ─┬─ 内存使用 ─┬─ 网络IO ─┬─ 磁盘IO ─┐
│ 0.25%      │ 50MB/2GB  │ 1.2KB   │ 8.5MB   │
│ 处理器占用  │ 已用/总量  │ 网络传输 │ 磁盘读写 │
└──────────── ┴────────── ┴──────── ┴─────────┘
```

**CPU %**：容器使用的CPU百分比
- 0.25% = 几乎不占用CPU资源
- 50% = 占用了半个CPU核心
- 200% = 占用了2个CPU核心（多核系统）

**MEM USAGE/LIMIT**：内存使用情况
- 50MB/2GB = 使用了50MB，限制是2GB
- 如果没设限制，显示为系统总内存

**NET I/O**：网络输入输出
- 1.2KB/856B = 接收1.2KB，发送856B
- 累计从容器启动开始的总流量

### 1.3 实用监控技巧


**定制化监控显示**：
```bash
# 只显示特定字段
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"

# 输出为JSON格式（便于脚本处理）
docker stats --format json --no-stream
```

**批量监控场景**：
```bash
# 监控多个指定容器
docker stats web-server database redis

# 结合其他命令使用
docker ps -q | xargs docker stats --no-stream
```

> 💡 **实用技巧**：使用`watch`命令可以定时刷新监控数据：`watch -n 2 "docker stats --no-stream"`

---

## 2. 📝 Docker日志系统详解


### 2.1 日志驱动基本概念


**什么是日志驱动**：
就像不同的记录方式，有人喜欢写日记本，有人喜欢发朋友圈，容器的日志也有不同的"记录方式"，这就是日志驱动。

**常用日志驱动对比**：

| 驱动类型 | **使用场景** | **存储位置** | **特点** |
|---------|------------|------------|----------|
| `json-file` | **默认选择，本地开发** | `/var/lib/docker/containers/` | `简单易用，支持日志轮转` |
| `journald` | **systemd系统** | `系统journal日志` | `与系统日志集成` |
| `syslog` | **传统Linux系统** | `系统syslog服务` | `标准化日志格式` |
| `none` | **不需要日志** | `不保存` | `节省磁盘空间` |

### 2.2 日志驱动配置方法


**全局配置（影响所有容器）**：
```bash
# 编辑Docker配置文件
sudo vim /etc/docker/daemon.json
```

```json
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
```

**单个容器配置**：
```bash
# 启动时指定日志驱动
docker run -d \
  --log-driver json-file \
  --log-opt max-size=5m \
  --log-opt max-file=2 \
  nginx
```

### 2.3 日志查看与管理


**基础日志查看**：
```bash
# 查看容器日志（最常用）
docker logs container_name

# 实时跟踪日志（类似tail -f）
docker logs -f container_name

# 查看最近100行日志
docker logs --tail 100 container_name

# 查看指定时间段的日志
docker logs --since "2024-01-01T00:00:00" container_name
```

**高级日志管理**：

```
日志轮转机制示意：
┌─────────────┐    达到10MB    ┌─────────────┐
│ 当前日志文件 │ ─────────────► │ 压缩存档    │
│ app.log     │                │ app.log.1   │
└─────────────┘                └─────────────┘
      │                              │
      ▼ 继续写入                       ▼ 保留备份
┌─────────────┐                ┌─────────────┐
│ 新的日志文件 │                │ 旧日志备份   │
│ app.log     │                │ app.log.2   │
└─────────────┘                └─────────────┘
```

---

## 3. 🏥 容器健康检查机制


### 3.1 健康检查的基本概念


**什么是健康检查**：
想象一下医生定期给病人量血压、测体温来判断健康状况。容器健康检查也类似，定期执行某个命令来判断容器内的应用是否正常工作。

**健康状态含义**：
- **🟢 healthy**：应用正常运行
- **🟡 starting**：容器刚启动，还在检查中
- **🔴 unhealthy**：应用出现问题

### 3.2 配置健康检查


**Dockerfile中配置**：
```dockerfile
# Web应用健康检查示例
FROM nginx
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost/ || exit 1
```

**运行时配置**：
```bash
# 启动容器时添加健康检查
docker run -d \
  --name web-server \
  --health-cmd="curl -f http://localhost:8080/health || exit 1" \
  --health-interval=30s \
  --health-timeout=3s \
  --health-retries=3 \
  my-web-app
```

### 3.3 健康检查参数详解


**参数含义说明**：

```
健康检查时间轴：
启动 ──30s──► 第1次检查 ──30s──► 第2次检查 ──30s──► 第3次检查
       │              │              │              │
       ▼              ▼              ▼              ▼
    starting      检查结果        检查结果         最终状态
```

- **interval=30s**：每30秒检查一次
- **timeout=3s**：单次检查最多等待3秒
- **retries=3**：连续失败3次才标记为不健康
- **start-period=60s**：启动后60秒内的失败不计入重试次数

**查看健康状态**：
```bash
# 查看容器健康状态
docker ps
# 显示结果中会有 (healthy) 或 (unhealthy) 标识

# 查看详细健康检查历史
docker inspect --format='{{json .State.Health}}' container_name
```

---

## 4. 📚 日志收集与聚合


### 4.1 日志收集架构设计


**什么是日志聚合**：
就像把散落在各个地方的文件收集到一个文件夹里整理，日志聚合就是把多个容器的日志统一收集到一个地方进行分析。

**典型架构示意**：
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  容器A      │    │  容器B      │    │  容器C      │
│  应用日志    │    │  应用日志    │    │  应用日志    │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       └─────────┬────────────────┬──────────┘
                 │                │
                 ▼                ▼
         ┌─────────────────────────────┐
         │      日志收集器              │
         │   (Fluentd/Filebeat)       │
         └─────────────┬───────────────┘
                       │
                       ▼
         ┌─────────────────────────────┐
         │      日志存储分析           │
         │  (Elasticsearch/Loki)      │
         └─────────────────────────────┘
```

### 4.2 使用Fluentd收集日志


**Fluentd是什么**：
一个专门用来收集、处理和转发日志的工具，就像邮局一样，负责把各个地方的"信件"（日志）收集起来，然后分发到正确的"地址"（存储系统）。

**基础配置示例**：
```bash
# 启动应用容器，使用fluentd日志驱动
docker run -d \
  --log-driver=fluentd \
  --log-opt fluentd-address=localhost:24224 \
  --log-opt tag="app.{{.Name}}" \
  nginx
```

**Fluentd配置文件示例**：
```ruby
# fluent.conf
<source>
  @type forward
  port 24224
  bind 0.0.0.0
</source>

<match app.**>
  @type file
  path /var/log/containers/app
  append true
  time_slice_format %Y%m%d
  time_slice_wait 1m
</match>
```

### 4.3 日志处理最佳实践


**结构化日志格式**：
```json
// 推荐的JSON格式日志
{
  "timestamp": "2024-09-17T15:30:00Z",
  "level": "INFO",
  "service": "web-api",
  "message": "User login successful",
  "user_id": "12345",
  "ip_address": "192.168.1.100"
}
```

**日志轮转策略**：

> 📌 **重要概念**：日志轮转就是当日志文件太大时，自动创建新文件，把旧文件压缩保存，防止磁盘被撑爆。

```bash
# 设置合理的日志轮转参数
docker run -d \
  --log-opt max-size=50m \
  --log-opt max-file=5 \
  --log-opt compress=true \
  my-app
```

---

## 5. 📈 性能监控与分析


### 5.1 容器性能指标体系


**关键性能指标（KPI）解释**：

```
┌─ 资源使用率 ─┐   ┌─ 应用性能 ─┐   ┌─ 业务指标 ─┐
│ CPU: 45%    │   │ 响应时间    │   │ QPS: 1000  │
│ 内存: 1.2GB  │   │ 错误率     │   │ 成功率: 99%│
│ 磁盘: 2.1GB  │   │ 吞吐量     │   │ 并发用户   │
└─────────────┘   └──────────── ┘   └──────────── ┘
     系统层面         应用层面         业务层面
```

**CPU性能分析**：
- **用户态CPU**：应用程序消耗
- **系统态CPU**：内核操作消耗
- **等待CPU**：等待IO操作时间

**内存性能分析**：
- **RSS内存**：实际物理内存使用
- **缓存内存**：系统缓存使用
- **交换内存**：虚拟内存使用

### 5.2 性能瓶颈诊断


**常见性能问题及解决**：

| 问题现象 | **可能原因** | **诊断命令** | **解决方案** |
|---------|------------|-------------|-------------|
| `CPU使用率过高` | `计算密集任务` | `docker exec top` | `优化算法，增加实例` |
| `内存不断增长` | `内存泄露` | `docker stats监控` | `检查代码，重启容器` |
| `响应时间长` | `IO等待` | `docker exec iostat` | `优化数据库查询` |
| `网络延迟高` | `网络配置` | `docker exec ping` | `检查网络设置` |

**性能分析工具使用**：
```bash
# 进入容器内部进行详细分析
docker exec -it container_name bash

# 查看进程CPU和内存使用
top

# 查看网络连接状态
netstat -an

# 查看磁盘IO情况
iostat -x 1
```

### 5.3 容器资源限制


**为什么要限制资源**：
就像给每个人分配固定的座位一样，给容器限制资源可以防止某个容器占用过多资源，影响其他容器的正常运行。

**CPU限制配置**：
```bash
# 限制容器只能使用1个CPU核心
docker run -d --cpus="1.0" nginx

# 限制容器CPU使用权重（相对值）
docker run -d --cpu-shares=512 nginx

# 绑定到特定CPU核心
docker run -d --cpuset-cpus="0,1" nginx
```

**内存限制配置**：
```bash
# 限制容器最大内存使用量
docker run -d --memory=512m nginx

# 设置内存交换限制
docker run -d --memory=512m --memory-swap=1g nginx

# 禁用OOM killer（不推荐生产环境）
docker run -d --memory=512m --oom-kill-disable nginx
```

---

## 6. 🔧 第三方监控工具集成


### 6.1 Prometheus + Grafana监控体系


**什么是Prometheus**：
一个专门收集和存储指标数据的系统，就像一个勤劳的记账员，定期记录各种数据指标。

**什么是Grafana**：
一个数据可视化工具，把Prometheus收集的枯燥数据变成漂亮的图表，就像把账本变成直观的图表。

**监控架构示意**：
```
┌───────────┐   指标数据   ┌─────────────┐   查询展示   ┌─────────────┐
│   容器     │ ─────────► │ Prometheus  │ ─────────► │   Grafana   │
│  应用     │            │   收集存储   │            │   图表展示   │
└───────────┘            └─────────────┘            └─────────────┘
      │                         │                          │
      ▼                         ▼                          ▼
 暴露指标接口              定期拉取数据              生成监控面板
```

### 6.2 容器监控配置实例


**启动监控容器组合**：
```bash
# 启动Prometheus
docker run -d \
  --name prometheus \
  -p 9090:9090 \
  -v prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus

# 启动Grafana
docker run -d \
  --name grafana \
  -p 3000:3000 \
  -e GF_SECURITY_ADMIN_PASSWORD=admin \
  grafana/grafana

# 启动节点监控器（收集系统指标）
docker run -d \
  --name node-exporter \
  -p 9100:9100 \
  prom/node-exporter
```

**Prometheus配置示例**：
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'docker-containers'
    static_configs:
      - targets: ['localhost:9100']
    scrape_interval: 5s
```

### 6.3 ELK日志分析栈


**ELK是什么**：
- **E**lasticsearch：搜索引擎，存储和搜索日志
- **L**ogstash：日志处理器，清洗和转换日志
- **K**ibana：可视化界面，查看和分析日志

**ELK工作流程**：
```
应用日志 ──► Logstash处理 ──► Elasticsearch存储 ──► Kibana展示
   │              │                  │               │
   ▼              ▼                  ▼               ▼
原始日志文件   格式化、过滤        建立索引         图表分析
```

**快速部署ELK**：
```bash
# 使用Docker Compose部署ELK（简化配置）
curl -L https://github.com/deviantony/docker-elk/archive/main.zip -o elk.zip
unzip elk.zip && cd docker-elk-main

# 启动ELK栈
docker-compose up -d

# 访问Kibana界面
# http://localhost:5601
# 用户名：elastic  密码：changeme
```

### 6.4 监控告警配置


**告警规则设置**：

> ⚠️ **重要提醒**：监控不仅要收集数据，更要在出现问题时及时通知，就像烟雾报警器一样。

```yaml
# Prometheus告警规则示例
groups:
- name: container-alerts
  rules:
  - alert: HighCPUUsage
    expr: rate(container_cpu_usage_seconds_total[5m]) > 0.8
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "容器CPU使用率过高"
      description: "容器 {{ $labels.name }} CPU使用率超过80%"

  - alert: HighMemoryUsage
    expr: container_memory_usage_bytes / container_spec_memory_limit_bytes > 0.9
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "容器内存使用率过高"
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 资源监控：使用docker stats查看CPU、内存、网络、磁盘使用情况
🔸 日志管理：理解日志驱动，配置日志轮转，查看容器日志
🔸 健康检查：设置健康检查命令，监控应用运行状态
🔸 日志聚合：使用工具收集多个容器的日志到统一位置
🔸 性能分析：识别性能瓶颈，设置合理的资源限制
🔸 监控工具：集成Prometheus、Grafana等第三方监控方案
```

### 7.2 关键理解要点


**🔹 监控的本质目的**
```
预防问题：
- 通过监控指标提前发现异常
- 设置告警规则及时响应问题
- 历史数据分析优化系统性能

故障排查：
- 日志记录详细的错误信息
- 性能指标帮助定位瓶颈
- 健康检查快速识别问题容器
```

**🔹 日志管理的重要性**
```
调试帮助：
- 应用出错时查看详细日志
- 跟踪用户行为和业务流程
- 分析系统性能和使用模式

合规要求：
- 审计日志记录关键操作
- 安全事件的追溯分析
- 业务数据的完整记录
```

**🔹 资源限制的平衡艺术**
```
限制太少：
- 容器可能耗尽系统资源
- 影响其他容器正常运行
- 系统不稳定，经常宕机

限制太多：
- 应用性能受到约束
- 无法处理突发流量
- 资源利用率不充分

合理配置：
- 根据应用特性设置限制
- 预留一定的资源缓冲
- 持续监控和调整参数
```

### 7.3 实际应用价值


**💼 生产环境最佳实践**
- **监控体系**：搭建完整的监控告警系统，7x24小时守护应用
- **日志策略**：制定统一的日志格式和收集策略，便于问题排查
- **性能调优**：基于监控数据持续优化应用和系统性能
- **故障处理**：建立标准化的故障诊断和处理流程

**📊 关键监控指标**
- **资源使用率**：CPU、内存、磁盘、网络的使用情况
- **应用性能**：响应时间、吞吐量、错误率、可用性
- **业务指标**：用户访问量、交易数量、业务成功率

### 7.4 学习路线建议


**⭐ 基础必会**：
- 熟练使用`docker stats`和`docker logs`命令
- 理解容器健康检查的配置和作用
- 掌握基本的日志轮转和清理策略

**⭐⭐ 进阶技能**：
- 配置日志驱动和聚合收集
- 设置合理的容器资源限制
- 使用基础的监控工具和告警

**⭐⭐⭐ 高级应用**：
- 搭建完整的监控体系（Prometheus + Grafana）
- 实现日志的自动分析和告警
- 进行深度的性能调优和容量规划

> 💡 **学习建议**：从基础命令开始，逐步搭建监控系统，在实践中加深理解。

**核心记忆口诀**：
- 监控日志手牵手，容器健康有保障
- 资源限制要合理，性能调优靠数据
- 告警及时问题少，生产环境更稳定