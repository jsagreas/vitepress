---
title: 13、容器镜像仓库管理
---
## 📚 目录

1. [镜像仓库基础概念](#1-镜像仓库基础概念)
2. [Docker Hub公共仓库使用](#2-Docker-Hub公共仓库使用)
3. [私有镜像仓库搭建](#3-私有镜像仓库搭建)
4. [Harbor企业级仓库](#4-Harbor企业级仓库)
5. [镜像推送与拉取操作](#5-镜像推送与拉取操作)
6. [仓库认证与权限管理](#6-仓库认证与权限管理)
7. [镜像同步与备份策略](#7-镜像同步与备份策略)
8. [仓库清理与维护](#8-仓库清理与维护)
9. [镜像安全扫描配置](#9-镜像安全扫描配置)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📦 镜像仓库基础概念


### 1.1 什么是容器镜像仓库

**简单理解**：镜像仓库就像一个"软件商店"，专门存放和分享容器镜像

```
生活类比：
镜像仓库 = 图书馆
镜像      = 书籍
推送      = 存书
拉取      = 借书
标签      = 书的版本号
```

**🔸 核心作用**
- **集中存储**：统一管理所有容器镜像
- **版本控制**：通过标签管理不同版本
- **分发共享**：团队成员共享镜像资源
- **权限管控**：控制谁能访问哪些镜像

### 1.2 仓库的基本结构


**层级关系图**：
```
Registry（注册服务器）
    ├── Repository（仓库）
    │   ├── nginx
    │   │   ├── latest
    │   │   ├── 1.20
    │   │   └── alpine
    │   └── mysql
    │       ├── 8.0
    │       └── 5.7
    └── User（用户空间）
        └── username/myapp
            └── v1.0
```

**🏷️ 核心概念**
- `Registry`：镜像注册服务器（如Docker Hub）
- `Repository`：具体的镜像仓库（如nginx仓库）
- `Tag`：镜像标签，用于版本标识
- `Image`：具体的镜像文件

### 1.3 公共仓库vs私有仓库


| 类型 | **特点** | **适用场景** | **优缺点** |
|------|----------|-------------|------------|
| 🌐 **公共仓库** | `免费使用，全球访问` | `开源项目，学习测试` | `✅免费 ❌安全风险` |
| 🔒 **私有仓库** | `企业内部，权限管控` | `商业项目，敏感数据` | `✅安全 ❌需要维护` |

---

## 2. 🌍 Docker Hub公共仓库使用


### 2.1 Docker Hub基础操作


**💡 什么是Docker Hub**
Docker Hub就像GitHub，但专门用来存放容器镜像。全球开发者都在上面分享自己制作的镜像。

**🔧 基本使用流程**
```bash
# 1. 注册Docker Hub账号（网页操作）
# 2. 登录到Docker Hub
docker login

# 3. 搜索需要的镜像
docker search nginx

# 4. 拉取镜像到本地
docker pull nginx:latest

# 5. 查看本地镜像
docker images
```

### 2.2 镜像搜索与选择


**🔍 如何选择合适的镜像**
```bash
# 搜索镜像（显示官方和流行镜像）
docker search nginx --limit 10

# 查看镜像详细信息（网页查看）
# 访问：https://hub.docker.com/_/nginx
```

**📊 选择镜像的标准**
- **官方镜像**：有`OFFICIAL`标记，最可靠
- **下载量**：`STARS`数量多，使用广泛
- **更新频率**：定期更新，维护活跃
- **文档完整**：有详细使用说明

**⭐ 常用官方镜像推荐**
```
Web服务器：
nginx      - 高性能Web服务器
apache     - 传统Web服务器

数据库：
mysql      - 关系型数据库
redis      - 内存数据库
postgres   - 企业级数据库

编程语言：
python     - Python运行环境
node       - Node.js运行环境
openjdk    - Java运行环境

操作系统：
ubuntu     - Ubuntu操作系统
alpine     - 超轻量级Linux
centos     - CentOS操作系统
```

### 2.3 理解镜像标签


**🏷️ 标签命名规律**
```
镜像完整名称格式：
[registry]/[namespace]/[repository]:[tag]

示例解析：
docker.io/library/nginx:1.20-alpine
│        │       │     │
registry namespace repository tag
```

**📝 常见标签含义**
- `latest`：最新稳定版本（默认标签）
- `1.20`：具体版本号
- `alpine`：基于Alpine Linux的轻量版本
- `slim`：精简版本，去除不必要组件
- `devel`：开发版本，包含开发工具

**💡 标签选择建议**
```
生产环境：使用具体版本号
nginx:1.20  ✅ 推荐
nginx:latest ❌ 不推荐（版本不确定）

开发环境：可以使用latest
nginx:latest ✅ 可以（方便获取新特性）
```

---

## 3. 🏗️ 私有镜像仓库搭建


### 3.1 为什么需要私有仓库


**🔸 企业需求场景**
- **数据安全**：公司内部镜像不能公开
- **网络限制**：内网环境无法访问外网
- **版本控制**：需要严格的版本管理
- **访问速度**：本地访问更快

**🎯 私有仓库的好处**
```
安全性：✅ 数据不外泄
速度：  ✅ 内网访问快
控制：  ✅ 完全自主管控
成本：  ✅ 避免公有云费用
```

### 3.2 使用Registry搭建简单私有仓库


**🚀 快速搭建步骤**

**步骤1：启动Registry服务**
```bash
# 创建数据存储目录
mkdir -p /opt/registry/data

# 启动Registry容器
docker run -d \
  --name my-registry \
  -p 5000:5000 \
  -v /opt/registry/data:/var/lib/registry \
  --restart=always \
  registry:2
```

**步骤2：配置Docker客户端**
```bash
# 修改Docker配置（允许非HTTPS仓库）
sudo vim /etc/docker/daemon.json

# 添加以下内容
{
  "insecure-registries": ["localhost:5000"]
}

# 重启Docker服务
sudo systemctl restart docker
```

**步骤3：测试私有仓库**
```bash
# 拉取一个测试镜像
docker pull hello-world

# 给镜像打标签（指向私有仓库）
docker tag hello-world localhost:5000/hello-world

# 推送到私有仓库
docker push localhost:5000/hello-world

# 从私有仓库拉取
docker pull localhost:5000/hello-world
```

### 3.3 添加HTTPS和认证


**🔒 配置HTTPS访问**

**生成自签名证书**：
```bash
# 创建证书目录
mkdir -p /opt/registry/certs

# 生成私钥和证书
openssl req -x509 -newkey rsa:4096 -keyout /opt/registry/certs/domain.key \
  -out /opt/registry/certs/domain.crt -days 365 -nodes \
  -subj "/CN=registry.company.com"
```

**配置认证文件**：
```bash
# 创建认证目录
mkdir -p /opt/registry/auth

# 创建用户密码文件
docker run --rm \
  --entrypoint htpasswd \
  httpd:2 -Bbn admin password123 > /opt/registry/auth/htpasswd
```

**启动安全的Registry**：
```bash
docker run -d \
  --name secure-registry \
  -p 443:5000 \
  -v /opt/registry/data:/var/lib/registry \
  -v /opt/registry/certs:/certs \
  -v /opt/registry/auth:/auth \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
  -e REGISTRY_AUTH=htpasswd \
  -e REGISTRY_AUTH_HTPASSWD_REALM="Registry Realm" \
  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
  --restart=always \
  registry:2
```

---

## 4. 🏢 Harbor企业级仓库


### 4.1 Harbor简介


**💡 什么是Harbor**
Harbor是由VMware开源的企业级容器镜像仓库，就像给Docker Registry穿上了一套"企业级盔甲"。

**🌟 Harbor的企业级特性**
```
基础功能：
✅ 镜像存储和分发
✅ Web管理界面
✅ 多租户支持

企业功能：
✅ 镜像安全扫描
✅ 内容信任和签名
✅ 审计日志
✅ 镜像复制
✅ Webhook通知
✅ LDAP/AD集成
```

### 4.2 Harbor安装部署


**📋 系统要求**
```
硬件要求：
CPU: 2核以上
内存: 4GB以上
磁盘: 40GB以上

软件要求：
Docker: 17.06+
Docker Compose: 1.18+
```

**🚀 安装步骤**

**步骤1：下载Harbor**
```bash
# 下载Harbor离线安装包
wget https://github.com/goharbor/harbor/releases/download/v2.5.0/harbor-offline-installer-v2.5.0.tgz

# 解压安装包
tar xvf harbor-offline-installer-v2.5.0.tgz
cd harbor
```

**步骤2：配置Harbor**
```bash
# 复制配置模板
cp harbor.yml.tmpl harbor.yml

# 编辑配置文件
vim harbor.yml
```

**核心配置项**：
```yaml
# Harbor访问地址
hostname: harbor.company.com

http:
  port: 80

https:
  port: 443
  certificate: /data/cert/server.crt
  private_key: /data/cert/server.key

# 管理员密码
harbor_admin_password: Harbor12345

# 数据存储位置
data_volume: /data

# 数据库配置
database:
  password: root123
  max_idle_conns: 50
  max_open_conns: 1000
```

**步骤3：安装和启动**
```bash
# 运行安装脚本
sudo ./install.sh --with-clair --with-chartmuseum

# 查看服务状态
docker-compose ps
```

### 4.3 Harbor基本使用


**🌐 Web界面访问**
```
访问地址：https://harbor.company.com
默认账号：admin
默认密码：Harbor12345（配置文件中设置的）
```

**📋 主要功能模块**
```
项目管理：
├── 公共项目（所有人可访问）
├── 私有项目（指定用户访问）
└── 项目配额管理

用户管理：
├── 本地用户
├── LDAP用户
└── 角色权限分配

系统管理：
├── 配置管理
├── 复制规则
├── 审计日志
└── 垃圾清理
```

**🔧 命令行使用**
```bash
# 登录Harbor
docker login harbor.company.com

# 推送镜像
docker tag nginx:latest harbor.company.com/myproject/nginx:v1.0
docker push harbor.company.com/myproject/nginx:v1.0

# 拉取镜像
docker pull harbor.company.com/myproject/nginx:v1.0
```

---

## 5. ⬆️⬇️ 镜像推送与拉取操作


### 5.1 镜像推送流程详解


**💡 推送是什么**
推送就是把本地制作好的镜像"上传"到仓库，供其他人使用。

**🔄 完整推送流程**

**流程图**：
```
本地镜像 → 打标签 → 登录仓库 → 推送镜像 → 验证推送
    ↓         ↓        ↓        ↓        ↓
  docker    docker   docker   docker   docker
   build     tag     login     push    images
```

**步骤1：构建本地镜像**
```dockerfile
# 示例：创建Dockerfile
FROM nginx:alpine
COPY index.html /usr/share/nginx/html/
EXPOSE 80
```

```bash
# 构建镜像
docker build -t myapp:1.0 .
```

**步骤2：镜像标签规范**
```bash
# 为不同仓库打标签
# Docker Hub格式
docker tag myapp:1.0 username/myapp:1.0

# 私有仓库格式
docker tag myapp:1.0 registry.company.com/project/myapp:1.0

# Harbor仓库格式
docker tag myapp:1.0 harbor.company.com/myproject/myapp:1.0
```

**步骤3：登录和推送**
```bash
# 登录仓库
docker login harbor.company.com

# 推送镜像
docker push harbor.company.com/myproject/myapp:1.0

# 查看推送进度
# Pushing to harbor.company.com/myproject/myapp:1.0
# Layer already exists: sha256:abc123...
# Pushed: sha256:def456...
```

### 5.2 镜像拉取策略


**⬇️ 拉取策略说明**

**默认拉取行为**：
- 本地没有镜像 → 自动拉取
- 本地有镜像且标签相同 → 不拉取
- 强制拉取 → 使用`--pull always`参数

**🎯 不同场景的拉取策略**

**开发环境（获取最新版本）**：
```bash
# 强制拉取最新镜像
docker pull nginx:latest

# 运行时强制拉取
docker run --pull always nginx:latest
```

**生产环境（版本固定）**：
```bash
# 拉取指定版本
docker pull nginx:1.20.2-alpine

# 验证镜像哈希值
docker inspect nginx:1.20.2-alpine | grep Id
```

**离线环境（镜像导入导出）**：
```bash
# 导出镜像
docker save -o nginx.tar nginx:latest

# 导入镜像
docker load -i nginx.tar
```

### 5.3 批量操作技巧


**📦 批量推送脚本**
```bash
#!/bin/bash
# 批量推送项目镜像

REGISTRY="harbor.company.com/myproject"
IMAGES=("webapp:1.0" "database:2.0" "cache:1.5")

for image in "${IMAGES[@]}"; do
    echo "Pushing $image..."
    docker tag $image $REGISTRY/$image
    docker push $REGISTRY/$image
    echo "$image pushed successfully"
done
```

**🔄 镜像同步脚本**
```bash
#!/bin/bash
# 从一个仓库同步到另一个仓库

SOURCE_REGISTRY="registry-a.com"
TARGET_REGISTRY="registry-b.com"
IMAGE_LIST="image-list.txt"

while read image; do
    docker pull $SOURCE_REGISTRY/$image
    docker tag $SOURCE_REGISTRY/$image $TARGET_REGISTRY/$image  
    docker push $TARGET_REGISTRY/$image
    docker rmi $SOURCE_REGISTRY/$image
done < $IMAGE_LIST
```

---

## 6. 🔐 仓库认证与权限管理


### 6.1 认证机制详解


**💡 为什么需要认证**
认证就像门禁系统，确保只有授权的人才能访问和操作镜像。

**🔑 认证方式对比**

| 认证方式 | **实现难度** | **安全等级** | **适用场景** |
|----------|-------------|-------------|-------------|
| 🔓 **无认证** | `极简单` | `⭐` | `开发测试` |
| 🔑 **基本认证** | `简单` | `⭐⭐⭐` | `小团队` |
| 🏢 **LDAP集成** | `复杂` | `⭐⭐⭐⭐` | `企业环境` |
| 🎫 **Token认证** | `中等` | `⭐⭐⭐⭐⭐` | `自动化CI/CD` |

### 6.2 Harbor权限管理体系


**👥 Harbor角色体系**
```
系统管理员 (System Admin)
    ├── 管理所有项目和用户
    ├── 系统配置和维护
    └── 审计日志查看

项目管理员 (Project Admin)
    ├── 管理项目成员
    ├── 配置项目设置
    └── 管理项目仓库

开发人员 (Developer)
    ├── 推送和拉取镜像
    ├── 删除镜像和标签
    └── 查看扫描报告

访客 (Guest)
    ├── 拉取镜像
    └── 查看项目信息

受限访客 (Limited Guest)
    └── 仅查看项目列表
```

**🎯 权限分配最佳实践**
```
原则1：最小权限原则
✅ 只给必要的最小权限
❌ 不要给过高权限

原则2：角色分离
✅ 开发人员：Developer角色
✅ 运维人员：Project Admin角色
✅ CI/CD系统：使用Robot账号

原则3：定期审查
✅ 定期清理无用账号
✅ 检查权限分配合理性
```

### 6.3 Robot账号配置


**🤖 什么是Robot账号**
Robot账号是专门给自动化系统使用的"机器人用户"，不需要人工登录。

**创建Robot账号步骤**：
```
1. 登录Harbor Web界面
2. 进入项目页面
3. 点击"Robot账号"标签
4. 点击"新建Robot账号"
5. 设置名称和权限
6. 复制生成的Token
```

**Robot账号使用**：
```bash
# 使用Robot账号登录
docker login harbor.company.com \
  -u "robot$myproject+ci-robot" \
  -p "token-generated-by-harbor"

# 在CI/CD脚本中使用
#!/bin/bash
echo $ROBOT_TOKEN | docker login harbor.company.com \
  -u $ROBOT_USER --password-stdin
```

### 6.4 LDAP集成配置


**🏢 企业LDAP集成好处**
- **单点登录**：使用企业账号直接登录
- **用户同步**：自动同步企业用户信息
- **权限继承**：基于企业组织架构分配权限

**LDAP配置示例**：
```yaml
# Harbor LDAP配置
auth_mode: ldap_auth

ldap:
  url: ldap://ldap.company.com:389
  base_dn: dc=company,dc=com
  search_dn: cn=admin,dc=company,dc=com
  search_password: admin_password
  uid: uid
  scope: subtree
  timeout: 5
```

**🎯 LDAP用户组映射**
```
企业组织架构 → Harbor角色映射

研发部门 → Developer角色
运维部门 → Project Admin角色  
管理层   → System Admin角色
实习生   → Guest角色
```

---

## 7. 🔄 镜像同步与备份策略


### 7.1 为什么需要镜像同步


**💡 镜像同步的价值**
镜像同步就像数据备份，保证在主仓库出问题时，还有其他地方可以获取镜像。

**🎯 同步应用场景**
```
多地部署：
北京机房 ⟷ 上海机房 ⟷ 广州机房
     ↕        ↕        ↕
   本地仓库   本地仓库   本地仓库

容灾备份：
生产仓库 → 备份仓库1 → 备份仓库2
   ↓
异地容灾仓库

开发环境同步：
生产仓库 → 测试仓库 → 开发仓库
```

### 7.2 Harbor镜像复制功能


**🔧 Harbor复制规则配置**

**创建复制规则步骤**：
```
1. 登录Harbor管理界面
2. 进入"复制管理" → "复制规则"
3. 点击"新建规则"
4. 配置复制参数：
   - 名称：production-to-backup
   - 源仓库：当前Harbor
   - 目标仓库：备份Harbor
   - 触发模式：手动/定时/事件触发
```

**复制规则配置示例**：
```yaml
# 复制规则示例
name: "prod-to-backup"
description: "生产环境镜像自动备份"

source:
  type: "harbor"
  registry: "harbor-prod.company.com"

destination:  
  type: "harbor"
  registry: "harbor-backup.company.com"
  
filters:
  - type: "repository"
    value: "production/**"
  - type: "tag" 
    value: "v*"

trigger:
  type: "scheduled"
  cron: "0 2 * * *"  # 每天凌晨2点执行
```

### 7.3 脚本化同步方案


**📜 自定义同步脚本**
```bash
#!/bin/bash
# 镜像同步脚本

SOURCE_REGISTRY="harbor-prod.company.com"
TARGET_REGISTRY="harbor-backup.company.com"
SYNC_LOG="/var/log/harbor-sync.log"

# 获取需要同步的镜像列表
get_image_list() {
    # 调用Harbor API获取镜像列表
    curl -s -X GET \
        -H "X-Harbor-Token: $HARBOR_TOKEN" \
        "$SOURCE_REGISTRY/api/v2.0/projects/production/repositories" \
        | jq -r '.[].name'
}

# 同步单个镜像
sync_image() {
    local image=$1
    echo "[$(date)] Syncing $image..." | tee -a $SYNC_LOG
    
    # 拉取源镜像
    if docker pull $SOURCE_REGISTRY/$image; then
        # 重新标签
        docker tag $SOURCE_REGISTRY/$image $TARGET_REGISTRY/$image
        
        # 推送到目标仓库
        if docker push $TARGET_REGISTRY/$image; then
            echo "[$(date)] Sync completed: $image" | tee -a $SYNC_LOG
            # 清理本地镜像节省空间
            docker rmi $SOURCE_REGISTRY/$image $TARGET_REGISTRY/$image
        else
            echo "[$(date)] Sync failed: $image" | tee -a $SYNC_LOG
        fi
    else
        echo "[$(date)] Pull failed: $image" | tee -a $SYNC_LOG
    fi
}

# 主同步流程
main() {
    echo "[$(date)] Harbor sync started" | tee -a $SYNC_LOG
    
    for image in $(get_image_list); do
        sync_image $image
        sleep 5  # 避免频繁请求
    done
    
    echo "[$(date)] Harbor sync completed" | tee -a $SYNC_LOG
}

main
```

### 7.4 备份策略设计


**📋 备份策略矩阵**

| 备份类型 | **频率** | **保留期** | **存储位置** |
|---------|---------|-----------|-------------|
| 🔄 **增量备份** | `每天` | `30天` | `本地存储` |
| 📦 **全量备份** | `每周` | `12周` | `网络存储` |
| 💾 **归档备份** | `每月` | `永久` | `对象存储` |

**🎯 备份策略建议**
```
3-2-1备份原则：
✅ 3份副本：生产+备份+归档
✅ 2种介质：本地磁盘+云存储  
✅ 1份异地：不同城市的数据中心

自动化要求：
✅ 定时自动执行
✅ 备份结果通知
✅ 失败自动重试
✅ 备份完整性验证
```

---

## 8. 🧹 仓库清理与维护


### 8.1 为什么需要仓库清理


**💡 清理的必要性**
容器镜像会越来越多，就像电脑文件一样，需要定期清理释放空间。

**🎯 清理带来的好处**
```
存储空间：
旧镜像占用 → 清理后释放 → 节省成本

性能提升：
仓库臃肿 → 清理优化 → 访问更快

安全提升：  
旧版本漏洞 → 清理过期 → 减少风险

管理简化：
镜像混乱 → 清理整理 → 便于管理
```

### 8.2 Harbor垃圾清理功能


**🗑️ Harbor内置清理功能**

**垃圾清理类型**：
```
镜像层清理：
├── 删除无引用的层文件
├── 清理孤儿镜像层
└── 释放存储空间

标签清理：
├── 删除过期标签
├── 保留最新N个版本  
└── 基于时间清理

仓库清理：
├── 删除空仓库
├── 清理无效项目
└── 整理仓库结构
```

**Web界面垃圾清理**：
```
1. 登录Harbor管理界面
2. 进入"垃圾清理"页面
3. 选择清理策略：
   - 清理未引用的blob
   - 清理manifest和tag
   - 执行垃圾回收
4. 点击"立即执行"
```

**命令行垃圾清理**：
```bash
# 进入Harbor部署目录
cd /opt/harbor

# 执行垃圾清理
docker-compose exec registry /bin/registry garbage-collect \
  --dry-run /etc/registry/config.yml

# 实际清理（去掉dry-run参数）
docker-compose exec registry /bin/registry garbage-collect \
  /etc/registry/config.yml
```

### 8.3 自动化清理策略


**⏰ 定时清理配置**
```bash
# 创建清理脚本
cat > /opt/harbor-cleanup.sh << 'EOF'
#!/bin/bash

HARBOR_DIR="/opt/harbor"
LOG_FILE="/var/log/harbor-cleanup.log"

cd $HARBOR_DIR

echo "[$(date)] Starting Harbor cleanup..." >> $LOG_FILE

# 停止Harbor服务
docker-compose stop

# 执行垃圾清理  
docker-compose exec registry /bin/registry garbage-collect \
  /etc/registry/config.yml >> $LOG_FILE 2>&1

# 启动Harbor服务
docker-compose start

echo "[$(date)] Harbor cleanup completed" >> $LOG_FILE
EOF

chmod +x /opt/harbor-cleanup.sh
```

**Cron定时任务**：
```bash
# 添加到系统cron
echo "0 3 * * 0 /opt/harbor-cleanup.sh" | crontab -
```

### 8.4 清理策略最佳实践


**📋 标签保留策略**
```yaml
# Harbor项目标签保留策略配置
retention_policy:
  - rule: "retain latest 10 artifacts"
    scope: "repository"
    
  - rule: "retain artifacts pushed in last 30 days"  
    scope: "repository"
    
  - rule: "retain tagged artifacts"
    scope: "tag"
    pattern: "release-*"
```

**🎯 清理操作建议**
```
清理前准备：
✅ 备份重要镜像
✅ 通知相关团队  
✅ 选择业务低峰期
✅ 准备回滚方案

清理中监控：
✅ 监控存储空间变化
✅ 检查服务可用性
✅ 记录清理过程日志

清理后验证：
✅ 验证关键镜像可用
✅ 检查应用正常运行
✅ 确认存储空间释放
```

---

## 9. 🛡️ 镜像安全扫描配置


### 9.1 为什么需要安全扫描


**💡 镜像安全的重要性**
容器镜像就像房子，可能存在"安全隐患"（漏洞），安全扫描就是"安全检查"。

**⚠️ 常见安全风险**
```
系统漏洞：
├── 操作系统漏洞（如Linux内核漏洞）
├── 基础软件漏洞（如OpenSSL漏洞）  
└── 运行时漏洞（如容器逃逸）

应用漏洞：
├── 代码依赖漏洞（如第三方库）
├── 配置错误（如默认密码）
└── 权限问题（如root运行）

供应链风险：
├── 恶意镜像（植入后门）
├── 未知来源（缺乏验证）
└── 版本过时（缺乏维护）
```

### 9.2 Harbor安全扫描功能


**🔍 Harbor集成的扫描器**

**Trivy扫描器特点**：
```
扫描能力：
✅ 操作系统包漏洞检测
✅ 应用依赖漏洞检测  
✅ 配置文件安全检查
✅ 秘密信息泄露检测

支持范围：
✅ 多种Linux发行版
✅ 主流编程语言依赖
✅ 容器镜像层分析
✅ 实时漏洞数据库更新
```

**🔧 启用安全扫描**

**Harbor配置文件修改**：
```yaml
# harbor.yml配置文件
# 启用Trivy扫描器
trivy:
  skip_update: false
  offline_scan: false
  security_check: true
  vuln_type: "os,library"
  severity: "UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL"
```

**重新部署Harbor**：
```bash
cd /opt/harbor
./prepare --with-trivy
docker-compose up -d
```

### 9.3 扫描策略配置


**📋 扫描策略设置**

**项目级扫描策略**：
```
自动扫描设置：
✅ 镜像推送时自动扫描
✅ 定时扫描已存储镜像
✅ 漏洞数据库更新后重扫

安全策略：
✅ 阻止推送有严重漏洞的镜像
✅ 设置漏洞阈值限制
✅ 扫描报告邮件通知
```

**Web界面配置步骤**：
```
1. 进入项目管理页面
2. 点击"配置管理"标签
3. 找到"安全扫描"部分
4. 配置扫描选项：
   - 自动扫描：推送时扫描
   - 阻止漏洞镜像：严重/高危
   - 定时扫描：每天/每周
```

### 9.4 扫描结果解读


**📊 扫描报告解读**

**漏洞等级说明**：
```
🔴 严重 (Critical): 立即修复
   - 远程代码执行
   - 权限提升漏洞
   
🟠 高危 (High): 优先修复  
   - 拒绝服务攻击
   - 信息泄露漏洞
   
🟡 中危 (Medium): 计划修复
   - 本地权限提升
   - 配置弱点
   
🔵 低危 (Low): 可选修复
   - 信息收集
   - 轻微配置问题
   
⚪ 未知 (Unknown): 需要评估
   - 新发现漏洞
   - 评级待确定
```

**🎯 修复建议流程**
```
扫描完成后：

1. 查看扫描报告
   ├── 漏洞总数统计
   ├── 按等级分类显示  
   └── 具体漏洞详情

2. 制定修复计划
   ├── 严重漏洞：24小时内修复
   ├── 高危漏洞：1周内修复
   ├── 中危漏洞：1月内修复
   └── 低危漏洞：下次更新时修复

3. 执行修复措施
   ├── 更新基础镜像
   ├── 升级依赖包版本
   ├── 修改配置文件
   └── 重新构建和推送
```

**🛠️ 常见修复方法**
```dockerfile
# 修复示例：更新基础镜像
FROM ubuntu:20.04  # 旧版本，可能有漏洞
# ↓ 修复为 ↓
FROM ubuntu:22.04  # 新版本，修复了已知漏洞

# 修复示例：更新软件包
RUN apt-get update && apt-get install -y \
    openssl=1.1.1f-1ubuntu2.16  # 指定安全版本
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基础概念


```
🔸 镜像仓库本质：容器镜像的集中存储和分发服务
🔸 公共vs私有：根据安全和访问需求选择仓库类型
🔸 推送拉取：镜像上传下载的基本操作流程
🔸 权限管理：控制谁能访问和操作镜像
🔸 安全扫描：检测镜像中的安全漏洞
```

### 10.2 关键理解要点


**🔹 仓库选择策略**
```
学习测试阶段：
✅ 使用Docker Hub公共仓库
✅ 免费方便，资源丰富

企业应用阶段：  
✅ 搭建私有仓库或使用Harbor
✅ 安全可控，功能完整

混合使用场景：
✅ 公共镜像从Docker Hub拉取
✅ 企业镜像存储在私有仓库
```

**🔹 安全最佳实践**
```
访问控制：
• 启用用户认证和权限管理
• 使用Robot账号进行CI/CD集成
• 定期审查和清理用户权限

镜像安全：
• 启用自动安全扫描
• 及时修复高危漏洞镜像
• 使用可信的基础镜像源

网络安全：
• 配置HTTPS加密传输
• 限制仓库网络访问范围
• 启用审计日志记录
```

**🔹 运维管理要点**
```
容量管理：
• 定期清理无用镜像和标签
• 设置合理的保留策略
• 监控存储空间使用情况

性能优化：
• 配置镜像缓存策略
• 使用多地域镜像同步
• 优化网络带宽分配

备份策略：
• 建立多份镜像备份
• 跨地域容灾部署
• 定期验证备份有效性
```

### 10.3 实际应用价值


**💼 企业应用场景**
- **开发团队协作**：统一的镜像版本管理
- **CI/CD流水线**：自动化镜像构建和部署
- **多环境管理**：开发/测试/生产环境镜像分发
- **微服务架构**：服务镜像的版本控制和发布

**🔧 技能发展路径**
- **入门阶段**：掌握Docker Hub使用和基本推拉操作
- **进阶阶段**：搭建私有仓库，理解权限管理
- **高级阶段**：Harbor企业级部署，安全扫描配置
- **专家阶段**：大规模仓库运维，自动化管理策略

**🎯 学习重点**
```
基础必会：
✅ Docker Hub基本使用
✅ 镜像推送拉取操作
✅ 简单私有仓库搭建

企业应用：
✅ Harbor部署和配置
✅ 用户权限管理
✅ 安全扫描设置

高级运维：
✅ 镜像同步和备份
✅ 自动化清理策略  
✅ 监控和维护方案
```

**核心记忆口诀**：
- 仓库管理有公私，安全权限是关键
- 推拉操作要规范，标签版本要明确  
- 定期清理保性能，安全扫描防风险
- Harbor企业首选项，运维自动化管理