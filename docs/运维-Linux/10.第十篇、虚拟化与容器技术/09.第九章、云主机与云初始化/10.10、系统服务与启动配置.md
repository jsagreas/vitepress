---
title: 10、系统服务与启动配置
---
## 📚 目录

1. [systemd服务管理基础](#1-systemd服务管理基础)
2. [开机自启动配置详解](#2-开机自启动配置详解)
3. [服务依赖关系配置](#3-服务依赖关系配置)
4. [自定义服务单元创建](#4-自定义服务单元创建)
5. [传统SysV服务配置](#5-传统sysv服务配置)
6. [服务配置文件模板](#6-服务配置文件模板)
7. [服务状态监控与检查](#7-服务状态监控与检查)
8. [服务重启策略配置](#8-服务重启策略配置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 systemd服务管理基础


### 1.1 什么是systemd

**简单理解**：systemd就是Linux系统的"总管家"，负责启动、停止、管理所有的系统服务。

```
传统方式启动服务：        systemd方式启动服务：
手动一个个启动 →          systemd统一管理 →
启动慢，容易出错          启动快，自动处理依赖
```

**🔸 systemd的核心优势**
- **并行启动**：多个服务同时启动，不用排队等待
- **自动依赖**：服务A需要服务B，systemd会自动先启动B
- **故障恢复**：服务挂了可以自动重启
- **统一管理**：用一套命令管理所有服务

### 1.2 systemd基本操作命令


**📋 日常必备命令**
```bash
# 查看服务状态（最常用）
systemctl status nginx
systemctl status ssh

# 启动/停止/重启服务
systemctl start nginx     # 启动
systemctl stop nginx      # 停止  
systemctl restart nginx   # 重启
systemctl reload nginx    # 重新加载配置

# 设置开机自启动
systemctl enable nginx    # 开机启动
systemctl disable nginx   # 取消开机启动
```

> 💡 **记忆技巧**：start/stop/restart很好理解，enable/disable就是"允许/禁止"开机启动

### 1.3 systemd服务文件位置


**📁 服务文件存放路径**
```
系统服务文件：/lib/systemd/system/       ← 系统自带服务
用户自定义：  /etc/systemd/system/       ← 管理员创建的服务
用户服务：    ~/.config/systemd/user/    ← 普通用户的服务

优先级：/etc > /lib > /usr（用户自定义优先级最高）
```

**🔍 查看服务文件**
```bash
# 查看nginx服务文件内容
cat /lib/systemd/system/nginx.service

# 查看所有服务列表
systemctl list-units --type=service
```

---

## 2. ⚡ 开机自启动配置详解


### 2.1 开机自启动的本质

**简单理解**：开机自启动就是告诉系统"这个服务很重要，电脑一开机就要运行它"。

```
开机启动流程：
电脑开机 → 加载内核 → systemd启动 → 读取自启动列表 → 启动标记的服务
```

### 2.2 设置开机自启动


**✅ 启用自启动服务**
```bash
# 设置nginx开机启动
systemctl enable nginx

# 查看是否已启用
systemctl is-enabled nginx
# 输出：enabled（已启用）或disabled（未启用）
```

**❌ 取消自启动服务**
```bash
# 取消nginx开机启动
systemctl disable nginx

# 一步到位：停止服务并取消自启动
systemctl disable --now nginx
```

### 2.3 查看开机启动状态


**📊 查看所有自启动服务**
```bash
# 查看所有启用的服务
systemctl list-unit-files --type=service --state=enabled

# 查看所有服务的启动状态
systemctl list-unit-files --type=service | grep enabled
```

**💡 常见服务启动建议**
```
建议开机启动：
✅ ssh        - 远程登录必需
✅ nginx      - Web服务器
✅ mysql      - 数据库服务
✅ docker     - 容器服务

不建议开机启动：
❌ redis      - 按需启动即可
❌ 测试服务    - 避免占用资源
```

### 2.4 开机启动的依赖关系


**🔗 启动目标（Target）概念**
```
multi-user.target  ← 多用户命令行模式（服务器常用）
graphical.target   ← 图形界面模式（桌面系统）
rescue.target      ← 救援模式
```

**查看当前启动目标**
```bash
# 查看当前目标
systemctl get-default

# 设置默认启动到命令行模式
systemctl set-default multi-user.target
```

---

## 3. 🔗 服务依赖关系配置


### 3.1 服务依赖关系的含义

**生活化理解**：就像做饭一样，要先洗菜、再切菜、最后炒菜，服务之间也有先后顺序。

```
Web服务启动顺序示例：
网络服务 → 数据库 → Web服务器 → 应用程序
   ↓        ↓        ↓         ↓
network → mysql → nginx → webapp
```

### 3.2 依赖关系类型详解


**📋 依赖关系配置指令**

| 指令类型 | **作用说明** | **实际含义** | **失败后果** |
|---------|-------------|-------------|-------------|
| `Requires=` | **强依赖** | `必须先启动依赖服务` | `依赖失败则本服务失败` |
| `Wants=` | **弱依赖** | `希望先启动依赖服务` | `依赖失败不影响本服务` |
| `After=` | **顺序依赖** | `在某服务之后启动` | `只管顺序，不管成败` |
| `Before=` | **顺序依赖** | `在某服务之前启动` | `只管顺序，不管成败` |

**🔸 依赖关系实例**
```ini
[Unit]
Description=Web Application
# 强依赖：必须要有网络和数据库
Requires=network.target mysql.service
# 启动顺序：在网络和数据库之后启动
After=network.target mysql.service
# 弱依赖：希望有Redis，但没有也能工作
Wants=redis.service
```

### 3.3 查看服务依赖关系


**🔍 查看依赖树**
```bash
# 查看nginx服务的依赖关系
systemctl list-dependencies nginx

# 查看反向依赖（谁依赖nginx）
systemctl list-dependencies --reverse nginx

# 查看详细的依赖信息
systemd-analyze dump | grep -A5 -B5 nginx
```

**依赖关系可视化示例**：
```
nginx.service
├─system.slice
└─basic.target
  ├─sockets.target
  ├─timers.target
  └─network.target
    └─network-online.target
```

---

## 4. 📝 自定义服务单元创建


### 4.1 服务文件基本结构

**简单理解**：服务文件就像服务的"身份证"，记录了服务的基本信息和启动方式。

**🏗️ 服务文件的三个基本部分**
```ini
[Unit]          ← 服务基本信息（描述、依赖等）
[Service]       ← 服务运行方式（启动命令、重启策略等）  
[Install]       ← 安装信息（开机启动设置等）
```

### 4.2 创建简单的自定义服务


**💡 实例：创建一个Python Web应用服务**

```bash
# 1. 创建服务文件
sudo nano /etc/systemd/system/myapp.service
```

**服务文件内容**：
```ini
[Unit]
# 服务描述（给人看的）
Description=My Python Web Application
# 依赖网络服务
After=network.target

[Service]
# 服务类型：简单服务
Type=simple
# 运行用户
User=www-data
# 工作目录
WorkingDirectory=/opt/myapp
# 启动命令
ExecStart=/usr/bin/python3 /opt/myapp/app.py
# 重启策略：总是重启
Restart=always
# 重启间隔：3秒
RestartSec=3

[Install]
# 安装到多用户目标（开机启动）
WantedBy=multi-user.target
```

**🔧 启用自定义服务**
```bash
# 2. 重新加载systemd配置
sudo systemctl daemon-reload

# 3. 启动服务
sudo systemctl start myapp

# 4. 设置开机启动
sudo systemctl enable myapp

# 5. 检查状态
sudo systemctl status myapp
```

### 4.3 服务类型详解


**📋 Service类型说明**

| 类型 | **特点** | **使用场景** | **实例** |
|------|---------|-------------|---------|
| `simple` | **默认类型，进程不fork** | `前台运行的程序` | `Python脚本、Node.js应用` |
| `forking` | **进程会fork后台运行** | `传统守护进程` | `Apache、Nginx` |
| `oneshot` | **执行一次就退出** | `初始化脚本、备份任务` | `系统初始化脚本` |
| `notify` | **程序会通知systemd已就绪** | `支持sd_notify的程序` | `现代化的守护进程` |

**🔸 Type=forking示例**
```ini
[Service]
Type=forking
ExecStart=/usr/sbin/nginx
PIDFile=/run/nginx.pid
```

**🔸 Type=oneshot示例**
```ini
[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup-script.sh
RemainAfterExit=yes
```

### 4.4 环境变量配置


**🌍 服务环境变量设置**
```ini
[Service]
# 直接设置环境变量
Environment=NODE_ENV=production
Environment=PORT=3000

# 从文件读取环境变量
EnvironmentFile=/etc/myapp/config.env

# 设置PATH路径
Environment=PATH=/usr/local/bin:/usr/bin:/bin
```

**配置文件示例（/etc/myapp/config.env）**：
```bash
NODE_ENV=production
DATABASE_URL=postgresql://user:pass@localhost/mydb
REDIS_URL=redis://localhost:6379
```

---

## 5. 🔄 传统SysV服务配置


### 5.1 SysV服务系统概述

**简单理解**：SysV是systemd之前的老式服务管理方式，现在主要用于兼容老系统。

```
SysV vs systemd对比：
SysV系统：          systemd系统：
/etc/init.d/        /etc/systemd/system/
service命令         systemctl命令
运行级别            目标（target）
串行启动            并行启动
```

### 5.2 SysV运行级别


**📊 传统运行级别含义**
```
运行级别 0：关机
运行级别 1：单用户模式（救援模式）
运行级别 2：多用户模式（无网络）
运行级别 3：多用户模式（有网络，无图形界面）← 服务器常用
运行级别 4：未定义
运行级别 5：图形界面模式 ← 桌面系统
运行级别 6：重启
```

**🔍 查看和切换运行级别**
```bash
# 查看当前运行级别
runlevel
# 输出示例：N 3（从无级别启动到3级别）

# 切换运行级别
sudo init 3    # 切换到命令行模式
sudo init 5    # 切换到图形模式
```

### 5.3 SysV服务脚本结构


**📝 典型的SysV启动脚本**
```bash
#!/bin/bash
# /etc/init.d/myservice

## BEGIN INIT INFO

# Provides:          myservice
# Required-Start:    $network $remote_fs
# Required-Stop:     $network $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: My Custom Service
## END INIT INFO


case "$1" in
    start)
        echo "Starting myservice..."
        /usr/local/bin/myservice &
        ;;
    stop)
        echo "Stopping myservice..."
        pkill myservice
        ;;
    restart)
        $0 stop
        sleep 2
        $0 start
        ;;
    *)
        echo "Usage: $0 {start|stop|restart}"
        exit 1
        ;;
esac
```

**🔧 安装SysV服务**
```bash
# 1. 复制脚本到init.d目录
sudo cp myservice /etc/init.d/

# 2. 设置执行权限
sudo chmod +x /etc/init.d/myservice

# 3. 设置开机启动
sudo update-rc.d myservice defaults

# 4. 启动服务
sudo service myservice start
```

### 5.4 SysV与systemd兼容性


**🔗 兼容性处理**
```bash
# systemd会自动包装SysV服务
systemctl status myservice    # 可以用systemctl管理SysV服务
service myservice status      # 传统命令仍然可用

# 查看是否为SysV服务
systemctl list-unit-files --type=service | grep -i sysv
```

---

## 6. 📋 服务配置文件模板


### 6.1 Web应用服务模板


**🌐 Python Flask应用服务**
```ini
[Unit]
Description=Flask Web Application
Documentation=https://example.com/docs
After=network.target postgresql.service

[Service]
Type=simple
User=www-data
Group=www-data
WorkingDirectory=/opt/webapp
Environment=FLASK_ENV=production
Environment=DATABASE_URL=postgresql://localhost/mydb
ExecStart=/opt/webapp/venv/bin/gunicorn --bind 0.0.0.0:8000 app:app
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

**🅹 Node.js应用服务**
```ini
[Unit]
Description=Node.js Web Application
After=network.target

[Service]
Type=simple
User=nodejs
WorkingDirectory=/opt/nodeapp
Environment=NODE_ENV=production
Environment=PORT=3000
ExecStart=/usr/bin/node server.js
Restart=always
RestartSec=3
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

### 6.2 数据库服务模板


**🗄️ Redis服务示例**
```ini
[Unit]
Description=Redis In-Memory Data Store
After=network.target

[Service]
Type=notify
User=redis
Group=redis
ExecStart=/usr/bin/redis-server /etc/redis/redis.conf
ExecStop=/usr/bin/redis-cli shutdown
TimeoutStopSec=0
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

### 6.3 定时任务服务模板


**⏰ 备份任务服务**
```ini
[Unit]
Description=Daily Backup Service
Wants=backup.timer

[Service]
Type=oneshot
User=backup
ExecStart=/usr/local/bin/backup.sh
StandardOutput=journal
StandardError=journal
```

**对应的Timer文件（backup.timer）**：
```ini
[Unit]
Description=Daily Backup Timer
Requires=backup.service

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
```

### 6.4 监控服务模板


**📊 简单的监控服务**
```ini
[Unit]
Description=System Monitor Service
After=network.target

[Service]
Type=simple
User=monitor
ExecStart=/usr/local/bin/monitor.py
Restart=always
RestartSec=10
# 健康检查
ExecStartPre=/bin/bash -c 'test -f /usr/local/bin/monitor.py'
# 停止前清理
ExecStopPost=/bin/rm -f /tmp/monitor.pid

[Install]
WantedBy=multi-user.target
```

---

## 7. 📊 服务状态监控与检查


### 7.1 服务状态查看基础


**🔍 基本状态查看**
```bash
# 查看单个服务详细状态
systemctl status nginx
```

**状态输出解读**：
```
● nginx.service - A high performance web server
   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)
   Active: active (running) since Mon 2025-09-18 10:30:15 CST; 2h 15min ago
     Docs: man:nginx(8)
  Process: 1234 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS)
 Main PID: 1235 (nginx)
    Tasks: 5 (limit: 4915)
   Memory: 15.2M
   CGroup: /system.slice/nginx.service
           ├─1235 nginx: master process /usr/sbin/nginx
           └─1236 nginx: worker process
```

**📋 状态字段含义**：
- **Loaded**: 服务文件是否加载，是否设置开机启动
- **Active**: 当前运行状态（active表示正在运行）
- **Main PID**: 主进程ID
- **Memory**: 内存使用量
- **CGroup**: 进程组信息

### 7.2 批量服务状态监控


**📊 查看所有服务状态**
```bash
# 查看所有正在运行的服务
systemctl list-units --type=service --state=active

# 查看失败的服务
systemctl list-units --type=service --state=failed

# 查看所有服务的简要状态
systemctl list-units --type=service --all
```

**🚨 查找问题服务**
```bash
# 只显示失败的服务名称
systemctl --failed --no-legend

# 查看服务启动耗时
systemd-analyze blame

# 查看启动关键路径
systemd-analyze critical-chain
```

### 7.3 服务日志查看


**📝 日志查看命令**
```bash
# 查看服务日志
journalctl -u nginx

# 实时跟踪日志（类似tail -f）
journalctl -u nginx -f

# 查看最近100行日志
journalctl -u nginx -n 100

# 查看今天的日志
journalctl -u nginx --since today

# 查看指定时间段的日志
journalctl -u nginx --since "2025-09-18 10:00:00" --until "2025-09-18 12:00:00"
```

**🔍 日志过滤技巧**
```bash
# 只看错误级别的日志
journalctl -u nginx -p err

# 查看启动相关的日志
journalctl -u nginx --since "10 minutes ago"

# 查看服务重启记录
journalctl -u nginx | grep -i restart
```

### 7.4 服务性能监控


**⚡ 资源使用监控**
```bash
# 查看服务资源使用
systemctl show nginx --property=MemoryUsage,CPUUsage

# 实时监控服务状态
watch -n 2 'systemctl status nginx'

# 查看服务进程树
systemctl status nginx --no-pager -l
```

**📈 服务启动时间分析**
```bash
# 分析系统启动时间
systemd-analyze

# 分析各服务启动时间
systemd-analyze blame | head -20

# 生成启动时间图表（需要图形环境）
systemd-analyze plot > startup.svg
```

---

## 8. 🔄 服务重启策略配置


### 8.1 重启策略基础概念

**简单理解**：重启策略就是告诉systemd"服务挂了怎么办"，是自动重启、忽略、还是报告错误。

**🔧 重启策略类型**

| 策略 | **触发条件** | **使用场景** | **风险** |
|------|-------------|-------------|---------|
| `no` | **从不重启** | `一次性任务、系统服务` | `服务挂了需手动重启` |
| `always` | **总是重启** | `重要的长期服务` | `可能掩盖问题` |
| `on-success` | **正常退出时重启** | `周期性任务` | `异常退出不重启` |
| `on-failure` | **异常退出时重启** | `大多数应用服务` | `正常退出不重启` |
| `on-abnormal` | **异常信号时重启** | `对信号敏感的服务` | `范围较窄` |

### 8.2 重启策略详细配置


**⚙️ 基本重启配置**
```ini
[Service]
# 重启策略：失败时重启
Restart=on-failure
# 重启间隔：5秒
RestartSec=5
# 最大重启次数：10次
StartLimitBurst=10
# 重启计数时间窗口：60秒
StartLimitIntervalSec=60
```

**💡 配置含义解释**：
- **RestartSec=5**: 服务停止后等5秒再重启
- **StartLimitBurst=10**: 在时间窗口内最多重启10次
- **StartLimitIntervalSec=60**: 60秒为一个时间窗口

### 8.3 实际应用场景配置


**🌐 Web服务重启策略**
```ini
[Service]
Type=simple
ExecStart=/usr/bin/my-web-app
# Web服务通常需要一直运行
Restart=always
RestartSec=3
# 避免启动失败时疯狂重启
StartLimitBurst=5
StartLimitIntervalSec=300
# 给服务足够时间启动
TimeoutStartSec=60
# 给服务足够时间停止
TimeoutStopSec=30
```

**🗄️ 数据库服务重启策略**
```ini
[Service]
Type=notify
ExecStart=/usr/bin/mysqld
# 数据库服务对稳定性要求高
Restart=on-failure
RestartSec=10
# 限制重启次数，避免数据问题
StartLimitBurst=3
StartLimitIntervalSec=600
# 数据库启动可能需要更长时间
TimeoutStartSec=300
```

**📊 监控服务重启策略**
```ini
[Service]
Type=simple
ExecStart=/usr/bin/monitor-daemon
# 监控服务失败时重启，正常退出不重启
Restart=on-failure
RestartSec=15
# 监控服务可以容忍更频繁的重启
StartLimitBurst=10
StartLimitIntervalSec=300
```

### 8.4 重启故障处理


**🚨 重启失败诊断**
```bash
# 查看服务重启历史
journalctl -u myservice | grep -E "(Started|Stopped|Failed)"

# 查看重启限制状态
systemctl show myservice --property=NRestarts,Result

# 重置启动限制计数器
systemctl reset-failed myservice
```

**🔧 调试重启问题**
```bash
# 查看详细的失败信息
systemctl status myservice --no-pager -l

# 查看最近的核心转储
journalctl -u myservice --since "1 hour ago" | grep -i "core dump"

# 手动启动服务进行调试
sudo -u service-user /path/to/service --debug
```

### 8.5 高级重启配置


**⏰ 条件重启配置**
```ini
[Service]
ExecStart=/usr/bin/myapp
# 只在特定退出码时重启
Restart=on-failure
# 定义成功的退出码
SuccessExitStatus=0 2 SIGTERM
# 定义重启的退出码
RestartForceExitStatus=1 3 SIGKILL
```

**🛡️ 重启保护机制**
```ini
[Service]
ExecStart=/usr/bin/myapp
Restart=on-failure
RestartSec=5
# 启动失败时的操作
StartLimitAction=reboot-force
# 或者可以设置为none（什么都不做）
# StartLimitAction=none
```

**📧 重启通知配置**
```ini
[Service]
ExecStart=/usr/bin/myapp
Restart=on-failure
# 重启前执行的命令（比如发送通知）
ExecStopPost=/usr/local/bin/notify-restart.sh %i
# 启动后执行的命令
ExecStartPost=/usr/local/bin/log-startup.sh %i
```

**通知脚本示例（notify-restart.sh）**：
```bash
#!/bin/bash
SERVICE_NAME=$1
echo "Service $SERVICE_NAME restarted at $(date)" | mail -s "Service Restart" admin@example.com
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本操作


**🔸 systemd基本命令**
```bash
# 服务控制三剑客
systemctl start/stop/restart 服务名
systemctl enable/disable 服务名    # 开机启动控制
systemctl status 服务名           # 状态查看

# 服务列表查看
systemctl list-units --type=service --state=active   # 运行中的服务
systemctl list-units --type=service --state=failed   # 失败的服务
```

**🔸 服务文件基本结构**
```ini
[Unit]          # 服务描述和依赖
[Service]       # 服务运行配置
[Install]       # 安装和启动目标
```

**🔸 开机启动管理**
```bash
systemctl enable 服务名     # 设置开机启动
systemctl disable 服务名    # 取消开机启动
systemctl is-enabled 服务名 # 检查启动状态
```

### 9.2 关键理解要点


**🔹 服务依赖关系的重要性**
```
理解要点：
- Requires：强依赖，依赖失败则服务失败
- Wants：弱依赖，依赖失败不影响本服务
- After：顺序依赖，控制启动顺序
- 合理设置依赖避免启动失败
```

**🔹 重启策略的选择原则**
```
选择原则：
- 重要服务：Restart=always 或 on-failure
- 一次性任务：Restart=no
- 周期性任务：Restart=on-success
- 设置合理的重启间隔和次数限制
```

**🔹 服务类型的适用场景**
```
Type选择：
- simple：大多数应用程序（Python、Node.js等）
- forking：传统守护进程（Apache、Nginx等）
- oneshot：初始化脚本、备份任务
- notify：支持systemd通知的现代程序
```

### 9.3 实际应用价值


**💼 业务场景应用**
- **Web服务部署**：自动启动Web服务器，配置重启策略
- **数据库管理**：确保数据库随系统启动，设置依赖关系
- **微服务架构**：管理多个服务的启动顺序和依赖
- **自动化任务**：配置定时任务和监控服务

**🔧 运维实践要点**
- **服务监控**：定期检查服务状态，及时发现问题
- **日志管理**：使用journalctl查看和分析服务日志
- **配置管理**：统一管理服务配置文件
- **故障恢复**：配置合理的重启策略和故障处理

### 9.4 常见问题排查


**🚨 启动失败排查步骤**
```
① 查看服务状态：systemctl status 服务名
② 查看详细日志：journalctl -u 服务名 -f
③ 检查配置文件：服务配置语法是否正确
④ 验证依赖服务：确保依赖的服务已启动
⑤ 检查权限问题：用户权限、文件权限等
```

**📝 配置文件常见错误**
```
常见错误：
- 路径错误：ExecStart路径不存在
- 权限问题：用户没有执行权限
- 依赖错误：依赖的服务不存在
- 语法错误：配置文件格式不正确
```

**💡 最佳实践建议**
```
建议做法：
✅ 为自定义服务创建专门的用户
✅ 使用绝对路径指定执行文件
✅ 设置合理的超时时间
✅ 配置适当的重启策略
✅ 定期备份服务配置文件
```

**核心记忆口诀**：
> 📚 systemd管服务，start stop restart控制器  
> 💫 enable disable开机启，status查看服务器  
> 🔗 依赖关系要理清，重启策略配置齐  
> 📊 日志监控不能忘，故障排查有规律