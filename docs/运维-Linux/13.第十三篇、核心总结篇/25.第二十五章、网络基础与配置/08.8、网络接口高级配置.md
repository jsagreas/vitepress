---
title: 8、网络接口高级配置
---
## 📚 目录

1. [网络接口聚合（Bonding）配置](#1-网络接口聚合bonding配置)
2. [VLAN虚拟局域网配置](#2-vlan虚拟局域网配置)
3. [网桥（Bridge）创建与管理](#3-网桥bridge创建与管理)
4. [网络命名空间（Network Namespace）](#4-网络命名空间network-namespace)
5. [虚拟网络设备管理](#5-虚拟网络设备管理)
6. [网络接口性能调优](#6-网络接口性能调优)
7. [ethtool网络接口工具](#7-ethtool网络接口工具)
8. [网络接口安全配置](#8-网络接口安全配置)
9. [网络接口故障切换](#9-网络接口故障切换)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔗 网络接口聚合（Bonding）配置


### 1.1 什么是网络接口聚合


**💡 通俗理解**
网络接口聚合就像是把多条马路合并成一条更宽的马路。当你有多张网卡时，可以把它们"捆绑"在一起，形成一个更强大的虚拟网络接口。

```
单张网卡：     网卡1 ──────→ 交换机
             100Mbps
             
聚合后：       网卡1 ┐
             网卡2 ├────→ 交换机
             网卡3 ┘
             300Mbps总带宽
```

**🔸 核心作用**：
- **提升带宽**：多张网卡带宽累加
- **增强可靠性**：一张网卡故障时，其他网卡继续工作
- **负载均衡**：网络流量在多张网卡间分配

### 1.2 Bonding工作模式详解


Linux支持7种不同的Bonding模式，每种都有不同的用途：

| 模式 | 名称 | **工作原理** | **适用场景** | **优缺点** |
|------|------|------------|-------------|-----------|
| **mode=0** | `round-robin` | 数据包轮流从不同网卡发送 | 高带宽需求 | ✅带宽累加 ❌包顺序可能乱 |
| **mode=1** | `active-backup` | 只有一张网卡工作，其他备用 | 高可靠性需求 | ✅简单可靠 ❌带宽不累加 |
| **mode=2** | `balance-xor` | 根据MAC地址哈希选择网卡 | 负载均衡 | ✅分布均匀 ❌需交换机支持 |
| **mode=4** | `802.3ad` | 链路聚合控制协议 | 企业环境 | ✅标准化 ❌交换机必须支持 |

### 1.3 配置网络接口聚合


**🔧 创建Bonding接口步骤**：

**第一步：加载bonding模块**
```bash
# 加载内核模块
modprobe bonding

# 验证模块是否加载
lsmod | grep bonding
```

**第二步：创建bond接口**
```bash
# 创建bond0接口（active-backup模式）
echo "+bond0" > /sys/class/net/bonding_masters

# 设置工作模式为active-backup
echo "active-backup" > /sys/class/net/bond0/bonding/mode
```

**第三步：添加成员网卡**
```bash
# 先关闭要添加的网卡
ip link set eth0 down
ip link set eth1 down

# 将网卡添加到bond
echo "+eth0" > /sys/class/net/bond0/bonding/slaves
echo "+eth1" > /sys/class/net/bond0/bonding/slaves
```

**第四步：配置IP地址**
```bash
# 启用bond接口并配置IP
ip link set bond0 up
ip addr add 192.168.1.100/24 dev bond0
```

> 💡 **实用提示**：也可以通过修改配置文件实现持久化配置

### 1.4 Bonding状态监控


**📊 查看bonding状态**：
```bash
# 查看详细状态
cat /proc/net/bonding/bond0

# 查看当前活动的网卡
cat /sys/class/net/bond0/bonding/active_slave
```

**输出示例解读**：
```
Ethernet Channel Bonding Driver: v3.7.1
Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: eth0    ← 当前工作的网卡
MII Status: up                  ← 整体状态
MII Polling Interval (ms): 100
```

---

## 2. 🏷️ VLAN虚拟局域网配置


### 2.1 VLAN基础概念


**💡 通俗理解**
VLAN就像是在一根网线里创建多个虚拟的网络通道。就好比一栋楼里的电梯，虽然都在同一个井道里，但可以分别到达不同的楼层。

```
物理网络：   [交换机] ──── 一根网线 ──── [服务器]

VLAN分割后： [交换机] ──── 一根网线 ──── [服务器]
            VLAN10: 财务部门    ┌─ eth0.10 (财务VLAN)
            VLAN20: 技术部门 ───┤
            VLAN30: 行政部门    └─ eth0.30 (行政VLAN)
```

**🔸 VLAN的核心价值**：
- **网络隔离**：不同VLAN间默认无法通信
- **节约设备**：一根网线传输多个网络
- **灵活管理**：可以动态调整网络归属

### 2.2 VLAN标签原理


**📋 VLAN标签结构**
```
标准以太网帧：
┌─────────┬─────────┬──────┬─────┬─────┐
│目标MAC  │源MAC    │类型  │数据 │校验 │
└─────────┴─────────┴──────┴─────┴─────┘

带VLAN标签的帧：
┌─────────┬─────────┬──────┬──────┬─────┬─────┐
│目标MAC  │源MAC    │VLAN  │类型  │数据 │校验 │
└─────────┴─────────┴──────┴──────┴─────┴─────┘
                    ↑
                VLAN ID（1-4094）
```

### 2.3 配置VLAN接口


**🔧 创建VLAN接口方法**：

**方法一：使用ip命令**
```bash
# 创建VLAN 10接口
ip link add link eth0 name eth0.10 type vlan id 10

# 配置IP地址
ip addr add 192.168.10.1/24 dev eth0.10

# 启用接口
ip link set eth0.10 up
```

**方法二：使用vconfig命令**（较老的方法）
```bash
# 创建VLAN接口
vconfig add eth0 20

# 配置IP地址
ip addr add 192.168.20.1/24 dev eth0.20
ip link set eth0.20 up
```

**🔍 验证VLAN配置**：
```bash
# 查看VLAN接口
ip link show type vlan

# 查看详细信息
cat /proc/net/vlan/config
```

### 2.4 多VLAN环境示例


**实际场景配置**：
```bash
# 创建多个VLAN用于不同部门
ip link add link eth0 name eth0.10 type vlan id 10  # 财务部
ip link add link eth0 name eth0.20 type vlan id 20  # 技术部
ip link add link eth0 name eth0.30 type vlan id 30  # 行政部

# 分别配置IP段
ip addr add 192.168.10.1/24 dev eth0.10  # 财务部网段
ip addr add 192.168.20.1/24 dev eth0.20  # 技术部网段
ip addr add 192.168.30.1/24 dev eth0.30  # 行政部网段

# 启用所有VLAN接口
ip link set eth0.10 up
ip link set eth0.20 up
ip link set eth0.30 up
```

---

## 3. 🌉 网桥（Bridge）创建与管理


### 3.1 网桥基础概念


**💡 通俗理解**
网桥就像是一个智能的网络交换机。它可以把多个网络接口连接起来，让它们像在同一个局域网中一样通信。

```
没有网桥时：
虚拟机1 ──── eth0 ──── 物理网络
虚拟机2 ──── eth1 ──── 物理网络
(每个都需要独立的物理连接)

使用网桥后：
虚拟机1 ┐
虚拟机2 ├──── 网桥br0 ──── eth0 ──── 物理网络  
虚拟机3 ┘
(所有虚拟机共享一个物理连接)
```

**🔸 网桥的核心功能**：
- **二层转发**：在MAC地址层面转发数据包
- **学习功能**：自动学习和记住设备的MAC地址
- **广播域连接**：将多个网络段连接成一个广播域

### 3.2 Linux网桥实现


Linux内核提供了软件网桥功能，主要通过`bridge-utils`工具包管理。

**📋 网桥工作流程**：
```
1. 数据包到达网桥
2. 查看目标MAC地址
3. 检查MAC地址表
4. 如果知道位置 → 直接转发到对应接口
5. 如果不知道 → 广播到所有接口
6. 学习源MAC地址位置
```

### 3.3 创建和配置网桥


**🔧 基本网桥配置步骤**：

**第一步：创建网桥**
```bash
# 创建网桥设备
ip link add name br0 type bridge

# 或使用brctl命令
brctl addbr br0
```

**第二步：添加网络接口**
```bash
# 将物理网卡加入网桥
ip link set dev eth0 master br0

# 或使用brctl命令
brctl addif br0 eth0
```

**第三步：配置网桥IP地址**
```bash
# 给网桥配置IP（注意：要先关闭eth0的IP）
ip addr flush dev eth0
ip addr add 192.168.1.100/24 dev br0
ip link set br0 up
```

**🔍 网桥状态查看**：
```bash
# 查看网桥列表
brctl show

# 查看MAC地址学习表
brctl showmacs br0

# 查看网桥详细信息  
ip link show type bridge
```

### 3.4 高级网桥配置


**⚙️ STP（生成树协议）配置**：
```bash
# 启用STP防止环路
brctl stp br0 on

# 设置网桥优先级（数字越小优先级越高）
brctl setbridgeprio br0 32768

# 设置端口成本
brctl setpathcost br0 eth0 100
```

**🎯 VLAN感知网桥**：
```bash
# 启用VLAN过滤
echo 1 > /sys/class/net/br0/bridge/vlan_filtering

# 为端口配置VLAN
bridge vlan add vid 10 dev eth0
bridge vlan add vid 20 dev eth1
```

---

## 4. 📦 网络命名空间（Network Namespace）


### 4.1 网络命名空间概念


**💡 通俗理解**
网络命名空间就像给每个应用或容器创建了一个独立的"网络房间"。每个房间都有自己的网络设备、IP地址、路由表，互不干扰。

```
主机网络空间：
┌─────────────────────┐
│ eth0: 192.168.1.10  │
│ lo: 127.0.0.1       │  ← 主机的网络环境
│ 路由表、防火墙规则   │
└─────────────────────┘

创建的网络命名空间：
┌─────────────────────┐  ┌─────────────────────┐
│ NS1:                │  │ NS2:                │
│ veth1: 10.0.1.1     │  │ veth2: 10.0.2.1     │
│ lo: 127.0.0.1       │  │ lo: 127.0.0.1       │
│ 独立的路由表        │  │ 独立的路由表        │
└─────────────────────┘  └─────────────────────┘
```

**🔸 网络命名空间的价值**：
- **完全隔离**：每个空间的网络配置完全独立
- **安全性**：不同应用无法互相访问网络
- **灵活性**：可以创建复杂的网络拓扑

### 4.2 网络命名空间基本操作


**🔧 创建和管理命名空间**：

**创建命名空间**：
```bash
# 创建新的网络命名空间
ip netns add myns

# 查看所有命名空间
ip netns list

# 删除命名空间
ip netns del myns
```

**在命名空间中执行命令**：
```bash
# 在指定命名空间中执行命令
ip netns exec myns ip addr show

# 进入命名空间的bash环境
ip netns exec myns bash
```

### 4.3 虚拟网络设备连接


**🔗 veth设备对创建**
veth（Virtual Ethernet）设备总是成对出现，就像一根虚拟网线的两端。

```bash
# 创建veth设备对
ip link add veth0 type veth peer name veth1

# 将一端移入命名空间
ip link set veth1 netns myns

# 配置主机端
ip addr add 10.0.0.1/24 dev veth0
ip link set veth0 up

# 配置命名空间端
ip netns exec myns ip addr add 10.0.0.2/24 dev veth1
ip netns exec myns ip link set veth1 up
ip netns exec myns ip link set lo up
```

**📊 连接示意图**：
```
主机网络空间                网络命名空间 myns
┌─────────────┐            ┌─────────────┐
│  veth0      │~~~~~~~~~~~~│   veth1     │
│ 10.0.0.1/24 │            │ 10.0.0.2/24 │
└─────────────┘            └─────────────┘
```

**🔍 测试连通性**：
```bash
# 从主机ping命名空间
ping 10.0.0.2

# 从命名空间ping主机
ip netns exec myns ping 10.0.0.1
```

### 4.4 复杂网络拓扑示例


**实际应用：模拟容器网络**
```bash
# 创建两个"容器"命名空间
ip netns add container1
ip netns add container2

# 创建网桥连接它们
ip link add br-containers type bridge
ip link set br-containers up

# 为每个容器创建veth对
ip link add veth-c1 type veth peer name veth-c1-br
ip link add veth-c2 type veth peer name veth-c2-br

# 将容器端移入命名空间
ip link set veth-c1 netns container1
ip link set veth-c2 netns container2

# 将网桥端连接到网桥
ip link set veth-c1-br master br-containers
ip link set veth-c2-br master br-containers
ip link set veth-c1-br up
ip link set veth-c2-br up

# 配置容器IP地址
ip netns exec container1 ip addr add 172.20.0.10/24 dev veth-c1
ip netns exec container1 ip link set veth-c1 up
ip netns exec container1 ip link set lo up

ip netns exec container2 ip addr add 172.20.0.20/24 dev veth-c2
ip netns exec container2 ip link set veth-c2 up
ip netns exec container2 ip link set lo up
```

---

## 5. 🛠️ 虚拟网络设备管理


### 5.1 虚拟网络设备类型


Linux提供了多种虚拟网络设备，每种都有特定的用途：

| 设备类型 | **用途说明** | **典型场景** | **特点** |
|----------|------------|-------------|----------|
| **veth** | 虚拟网线两端 | 容器网络 | 成对出现，数据从一端进另一端出 |
| **tun/tap** | 用户空间网络程序 | VPN、网络仿真 | tun工作在三层，tap工作在二层 |
| **macvlan** | 单网卡多MAC地址 | 网络虚拟化 | 每个接口有独立MAC |
| **ipvlan** | 单网卡多IP地址 | 轻量级虚拟化 | 共享MAC地址 |
| **dummy** | 虚拟环回接口 | 测试、占位 | 纯软件接口 |

### 5.2 TUN/TAP设备详解


**💡 TUN和TAP的区别**
- **TUN设备**：工作在网络层（Layer 3），处理IP数据包
- **TAP设备**：工作在数据链路层（Layer 2），处理以太网帧

**🔧 创建TUN/TAP设备**：
```bash
# 创建TUN设备
ip tuntap add mode tun tun0

# 创建TAP设备  
ip tuntap add mode tap tap0

# 配置IP地址
ip addr add 10.0.1.1/24 dev tun0
ip link set tun0 up
```

**应用示例：简单VPN隧道**
```bash
# 服务端创建TUN设备
ip tuntap add mode tun tun-vpn
ip addr add 10.8.0.1/24 dev tun-vpn
ip link set tun-vpn up

# 启用IP转发
echo 1 > /proc/sys/net/ipv4/ip_forward

# 配置NAT规则
iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE
```

### 5.3 MACVLAN设备应用


**💡 MACVLAN原理**
MACVLAN允许在一个物理网卡上创建多个虚拟网卡，每个都有独立的MAC地址。

```
物理网卡 eth0 (MAC: aa:bb:cc:dd:ee:ff)
├── macvlan0 (MAC: aa:bb:cc:dd:ee:01, IP: 192.168.1.10)
├── macvlan1 (MAC: aa:bb:cc:dd:ee:02, IP: 192.168.1.11)  
└── macvlan2 (MAC: aa:bb:cc:dd:ee:03, IP: 192.168.1.12)
```

**🔧 配置MACVLAN**：
```bash
# 创建MACVLAN接口
ip link add macvlan0 link eth0 type macvlan mode bridge

# 配置IP地址（注意要在不同网段或使用不同IP）
ip addr add 192.168.1.100/24 dev macvlan0
ip link set macvlan0 up
```

**⚙️ MACVLAN工作模式**：
- **bridge**：同一父接口下的macvlan可以通信
- **private**：同一父接口下的macvlan无法通信
- **vepa**：需要外部交换机支持
- **passthru**：只能创建一个macvlan接口

---

## 6. ⚡ 网络接口性能调优


### 6.1 网络性能影响因素


**📊 性能瓶颈分析**

网络性能受多个层面影响：
```
应用层：程序算法、缓冲区大小
传输层：TCP窗口、拥塞控制
网络层：路由效率、分片处理  
数据链路层：网卡驱动、队列长度
物理层：网线质量、接口速率
```

**🎯 关键性能指标**：
- **带宽**（Bandwidth）：每秒传输的数据量
- **延迟**（Latency）：数据传输的时间延迟
- **PPS**（Packets Per Second）：每秒处理的数据包数量
- **CPU使用率**：网络处理占用的CPU资源

### 6.2 网卡队列调优


**💡 多队列网卡原理**
现代网卡支持多个发送/接收队列，可以充分利用多核CPU。

**🔧 查看和调整队列设置**：
```bash
# 查看网卡队列信息
ethtool -l eth0

# 设置队列数量（需要网卡支持）
ethtool -L eth0 rx 4 tx 4

# 查看队列统计
ethtool -S eth0 | grep -i queue
```

**⚙️ 中断平衡配置**：
```bash
# 查看网卡中断号
cat /proc/interrupts | grep eth0

# 设置CPU亲和性（将中断绑定到特定CPU）
echo 2 > /proc/irq/24/smp_affinity  # 绑定到CPU 1
echo 4 > /proc/irq/25/smp_affinity  # 绑定到CPU 2
```

### 6.3 缓冲区优化


**📋 重要的缓冲区参数**：

| 参数 | **作用** | **调优建议** |
|------|---------|-------------|
| `txqueuelen` | 发送队列长度 | 高带宽时增大到10000 |
| `rx_buffer` | 接收缓冲区 | 根据内存情况适当增大 |
| `tx_buffer` | 发送缓冲区 | 平衡内存使用和性能 |
| `mtu` | 最大传输单元 | 内网可考虑巨帧9000 |

**🔧 调优示例**：
```bash
# 调整发送队列长度
ip link set dev eth0 txqueuelen 10000

# 调整MTU大小（需要网络支持）
ip link set dev eth0 mtu 9000

# 调整TCP缓冲区（系统级别）
echo 'net.core.rmem_max = 268435456' >> /etc/sysctl.conf
echo 'net.core.wmem_max = 268435456' >> /etc/sysctl.conf
sysctl -p
```

### 6.4 高级性能优化技术


**🚀 网络卸载技术**：

```bash
# 查看当前卸载特性
ethtool -k eth0

# 启用TCP段卸载（TSO）
ethtool -K eth0 tso on

# 启用通用接收卸载（GRO）  
ethtool -K eth0 gro on

# 启用校验和卸载
ethtool -K eth0 rx-checksumming on
ethtool -K eth0 tx-checksumming on
```

> ⚠️ **注意**：某些虚拟化环境可能不支持所有卸载特性

**🎯 NUMA优化**：
对于NUMA架构的服务器，网卡中断应该绑定到网卡所在的NUMA节点：

```bash
# 查看网卡所在NUMA节点
cat /sys/class/net/eth0/device/numa_node

# 查看CPU的NUMA分布  
numactl --hardware

# 将网络相关进程绑定到对应NUMA节点
numactl --cpunodebind=0 --membind=0 your_network_app
```

---

## 7. 🔧 ethtool网络接口工具


### 7.1 ethtool工具概述


**💡 ethtool是什么**
ethtool是Linux下专门用来查看和配置网卡硬件参数的工具。就像是网卡的"体检工具"和"设置面板"。

**🔸 主要功能**：
- **查看网卡信息**：速率、双工、链路状态
- **调整网卡参数**：速率协商、流控制、卸载特性
- **网卡测试**：自环测试、电缆测试
- **统计信息**：错误计数、流量统计

### 7.2 基本信息查询


**🔍 常用查询命令**：

```bash
# 查看网卡基本信息
ethtool eth0

# 查看网卡驱动信息
ethtool -i eth0

# 查看网卡统计信息
ethtool -S eth0

# 查看支持的特性
ethtool -k eth0
```

**典型输出解读**：
```
Settings for eth0:
	Supported ports: [ TP ]
	Supported link modes:   10baseT/Half 10baseT/Full 
	                        100baseT/Half 100baseT/Full 
	                        1000baseT/Full 
	Supported pause frame use: Symmetric
	Supports auto-negotiation: Yes        ← 支持自动协商
	Supported FEC modes: Not reported
	Advertised link modes:  1000baseT/Full  ← 当前广告的速率
	Advertised pause frame use: Symmetric
	Advertised auto-negotiation: Yes
	Speed: 1000Mb/s                      ← 当前速率
	Duplex: Full                         ← 全双工
	Port: Twisted Pair
	PHYAD: 1
	Transceiver: internal
	Auto-negotiation: on                 ← 自动协商开启
	MDI-X: on (auto)
	Link detected: yes                   ← 链路状态正常
```

### 7.3 网卡参数配置


**⚙️ 速率和双工设置**：
```bash
# 强制设置为100Mbps全双工（关闭自动协商）
ethtool -s eth0 speed 100 duplex full autoneg off

# 重新启用自动协商
ethtool -s eth0 autoneg on

# 只广告特定速率
ethtool -s eth0 advertise 0x020  # 只广告100baseT/Full
```

**🔧 卸载特性管理**：
```bash
# 关闭TCP校验和卸载（用于抓包分析）
ethtool -K eth0 tx-checksumming off

# 关闭大段卸载（某些情况下可能需要）
ethtool -K eth0 tso off gso off

# 查看修改后的状态
ethtool -k eth0 | grep -E "(checksum|offload)"
```

### 7.4 网卡诊断功能


**🔍 链路测试**：
```bash
# LED闪烁测试（持续10秒，用于识别物理网卡）
ethtool -p eth0 10

# 自环测试（需要网卡支持）
ethtool -t eth0

# 查看电缆长度和状态（某些网卡支持）
ethtool --cable-test eth0
```

**📊 实时监控**：
```bash
# 持续监控错误计数
watch -n 1 'ethtool -S eth0 | grep -E "(error|drop|crc)"'

# 监控链路状态变化
while true; do
    ethtool eth0 | grep "Link detected"
    sleep 1
done
```

### 7.5 高级诊断应用


**🛠️ 性能问题排查步骤**：

**第一步：检查基础状态**
```bash
# 1. 检查链路是否正常
ethtool eth0 | grep "Link detected"

# 2. 检查速率是否达到预期
ethtool eth0 | grep -E "(Speed|Duplex)"

# 3. 检查是否有硬件错误
ethtool -S eth0 | grep -E "(error|crc|collision)"
```

**第二步：分析错误类型**
```bash
# 接收错误分析
ethtool -S eth0 | grep -E "rx.*error"
# - rx_crc_errors: 物理层问题
# - rx_over_errors: 接收缓冲区溢出
# - rx_frame_errors: 帧格式错误

# 发送错误分析
ethtool -S eth0 | grep -E "tx.*error"  
# - tx_aborted_errors: 发送中断
# - tx_carrier_errors: 载波丢失
```

---

## 8. 🛡️ 网络接口安全配置


### 8.1 网络接口安全威胁


**⚠️ 常见安全威胁**：

| 威胁类型 | **描述** | **影响** | **防护重点** |
|----------|---------|----------|-------------|
| **MAC地址欺骗** | 攻击者伪造MAC地址 | 绕过MAC过滤 | MAC地址绑定 |
| **VLAN跳跃** | 攻击跨越VLAN边界 | 网络隔离失效 | VLAN配置检查 |
| **ARP欺骗** | 伪造ARP响应 | 中间人攻击 | 静态ARP绑定 |
| **网桥环路** | 形成二层环路 | 广播风暴 | STP协议 |
| **流量泛洪** | 大量恶意流量 | 网络拥塞 | 限流配置 |

### 8.2 MAC地址安全


**🔒 MAC地址固化**：
某些环境需要固定MAC地址防止欺骗：

```bash
# 查看当前MAC地址
ip link show eth0 | grep ether

# 临时修改MAC地址
ip link set dev eth0 down
ip link set dev eth0 address aa:bb:cc:dd:ee:ff
ip link set dev eth0 up

# 永久修改（编辑网络配置文件）
echo 'HWADDR=aa:bb:cc:dd:ee:ff' >> /etc/sysconfig/network-scripts/ifcfg-eth0
```

**🛡️ MAC地址过滤实现**：
```bash
# 使用ebtables进行MAC地址过滤
# 只允许特定MAC地址通过网桥
ebtables -A FORWARD -s ! aa:bb:cc:dd:ee:ff -j DROP

# 禁止特定MAC地址访问
ebtables -A FORWARD -s aa:bb:cc:dd:ee:ff -j DROP
```

### 8.3 VLAN安全配置


**🔐 VLAN隔离最佳实践**：

**正确的VLAN配置**：
```bash
# 1. 移除默认VLAN 1（安全隐患）
bridge vlan del vid 1 dev eth0

# 2. 只添加需要的VLAN
bridge vlan add vid 10 dev eth0
bridge vlan add vid 20 dev eth0

# 3. 设置端口为trunk或access模式
# Access模式（只允许一个VLAN）
bridge vlan add vid 10 dev eth0 untagged pvid

# 4. 验证VLAN配置
bridge vlan show dev eth0
```

**🚫 防止VLAN跳跃**：
```bash
# 在网桥接口禁用不需要的协议
echo 0 > /sys/class/net/br0/bridge/multicast_snooping

# 限制广播风暴
echo 100 > /sys/class/net/br0/bridge/multicast_querier_interval
```

### 8.4 流量控制和限制


**⚖️ 接口级别的流量控制**：

**基本限速配置**：
```bash
# 使用TC（Traffic Control）限制带宽
# 限制eth0出口带宽为100Mbps
tc qdisc add dev eth0 root tbf rate 100mbit burst 32kbit latency 400ms

# 查看当前限速状态
tc qdisc show dev eth0

# 删除限速规则
tc qdisc del dev eth0 root
```

**🎯 基于IP的流量整形**：
```bash
# 创建分类队列
tc qdisc add dev eth0 root handle 1: htb default 30

# 创建根类
tc class add dev eth0 parent 1: classid 1:1 htb rate 1000mbit

# 为特定IP创建子类（限制到100Mbps）
tc class add dev eth0 parent 1:1 classid 1:10 htb rate 100mbit ceil 200mbit

# 添加过滤器
tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 192.168.1.100/32 flowid 1:10
```

### 8.5 网络接口访问控制


**🔐 基于iptables的接口安全**：

```bash
# 禁止特定接口的所有流量
iptables -A INPUT -i eth1 -j DROP
iptables -A OUTPUT -o eth1 -j DROP

# 只允许特定协议通过接口
iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -i eth0 -p icmp -j ACCEPT
iptables -A INPUT -i eth0 -j DROP

# 防止IP欺骗（反向路径过滤）
echo 1 > /proc/sys/net/ipv4/conf/eth0/rp_filter

# 禁用ICMP重定向
echo 0 > /proc/sys/net/ipv4/conf/eth0/accept_redirects
```

**📋 网络接口安全检查清单**：

- ✅ **定期检查MAC地址表**：`brctl showmacs br0`
- ✅ **监控异常流量**：`iftop -i eth0`
- ✅ **验证VLAN配置**：`bridge vlan show`
- ✅ **检查接口状态**：`ethtool eth0`
- ✅ **审查防火墙规则**：`iptables -L -n`

---

## 9. 🔄 网络接口故障切换


### 9.1 故障切换基础概念


**💡 什么是故障切换**
故障切换（Failover）就像是给网络连接准备"备用轮胎"。当主要的网络连接出现问题时，系统自动切换到备用连接，保证服务不中断。

```
正常情况：
应用程序 ──→ 主网卡(eth0) ──→ 网络

故障情况：
应用程序 ──→ 主网卡(eth0) ✗ 故障
           └→ 备网卡(eth1) ──→ 网络
```

**🔸 故障切换的核心要素**：
- **故障检测**：如何发现网络故障
- **切换速度**：从故障到恢复的时间
- **切换透明性**：应用程序无需感知切换过程
- **数据一致性**：确保数据不丢失

### 9.2 基于Bonding的故障切换


**⚙️ Active-Backup模式详解**
这是最常用的故障切换模式，同时只有一张网卡工作。

```bash
# 创建active-backup模式的bond
echo "+bond0" > /sys/class/net/bonding_masters
echo "active-backup" > /sys/class/net/bond0/bonding/mode

# 设置故障检测间隔（单位：毫秒）
echo "100" > /sys/class/net/bond0/bonding/miimon

# 添加成员网卡
ip link set eth0 down
ip link set eth1 down
echo "+eth0" > /sys/class/net/bond0/bonding/slaves
echo "+eth1" > /sys/class/net/bond0/bonding/slaves

# 配置IP地址
ip addr add 192.168.1.100/24 dev bond0
ip link set bond0 up
```

**🔍 故障切换测试**：
```bash
# 模拟网络故障（断开主网卡）
ip link set eth0 down

# 查看切换状态
cat /proc/net/bonding/bond0 | grep -A5 "Currently Active Slave"

# 恢复网卡
ip link set eth0 up
```

### 9.3 高级故障检测机制


**📊 多种检测方式对比**：

| 检测方式 | **检测内容** | **适用场景** | **优缺点** |
|----------|------------|-------------|-----------|
| **MII监控** | 物理链路状态 | 直连场景 | ✅快速检测 ❌不检测网络可达性 |
| **ARP监控** | 网关可达性 | 需要网关通信 | ✅检测网络通路 ❌依赖ARP响应 |
| **组合监控** | 物理+逻辑检测 | 复杂网络环境 | ✅全面检测 ❌配置复杂 |

**🔧 ARP监控配置示例**：
```bash
# 设置ARP监控模式
echo "0" > /sys/class/net/bond0/bonding/miimon  # 关闭MII监控
echo "1000" > /sys/class/net/bond0/bonding/arp_interval  # ARP检测间隔1秒

# 设置ARP监控目标（通常是网关）
echo "+192.168.1.1" > /sys/class/net/bond0/bonding/arp_ip_target

# 查看ARP监控状态
cat /sys/class/net/bond0/bonding/arp_ip_target
```

### 9.4 网络命名空间故障切换


**🔄 命名空间级别的冗余**
在容器环境中，可以为不同的网络命名空间配置故障切换。

```bash
# 创建两个网络命名空间用于冗余
ip netns add primary-net
ip netns add backup-net

# 分别配置不同的网络路径
# 主路径：通过eth0
ip link add veth-p1 type veth peer name veth-p2
ip link set veth-p2 netns primary-net
ip netns exec primary-net ip addr add 10.0.1.2/24 dev veth-p2
ip netns exec primary-net ip link set veth-p2 up
ip netns exec primary-net ip link set lo up

# 备用路径：通过eth1
ip link add veth-b1 type veth peer name veth-b2  
ip link set veth-b2 netns backup-net
ip netns exec backup-net ip addr add 10.0.2.2/24 dev veth-b2
ip netns exec backup-net ip link set veth-b2 up
ip netns exec backup-net ip link set lo up
```

### 9.5 自动化故障切换脚本


**📋 故障切换监控脚本示例**：

```bash
#!/bin/bash
# 网络故障切换监控脚本

PRIMARY_IF="eth0"
BACKUP_IF="eth1"  
TEST_HOST="192.168.1.1"
CHECK_INTERVAL=5

while true; do
    # 检查主接口状态
    if ip link show $PRIMARY_IF | grep -q "state UP"; then
        # 物理链路正常，检查网络可达性
        if ping -c 1 -W 2 -I $PRIMARY_IF $TEST_HOST >/dev/null 2>&1; then
            echo "$(date): Primary interface $PRIMARY_IF is healthy"
            # 确保主接口处于活动状态
            if ! ip route show default | grep -q $PRIMARY_IF; then
                echo "$(date): Switching back to primary interface"
                ip route del default
                ip route add default via 192.168.1.1 dev $PRIMARY_IF
            fi
        else
            echo "$(date): Primary interface $PRIMARY_IF network unreachable"
            # 切换到备用接口
            echo "$(date): Switching to backup interface $BACKUP_IF"
            ip route del default
            ip route add default via 192.168.1.1 dev $BACKUP_IF
        fi
    else
        echo "$(date): Primary interface $PRIMARY_IF is down"
        # 确保备用接口激活
        if ! ip route show default | grep -q $BACKUP_IF; then
            echo "$(date): Activating backup interface $BACKUP_IF"
            ip route add default via 192.168.1.1 dev $BACKUP_IF
        fi
    fi
    
    sleep $CHECK_INTERVAL
done
```

**⚡ 快速故障切换优化**：

```bash
# 调整内核参数加快故障检测
echo 1 > /proc/sys/net/ipv4/tcp_retries2     # 减少TCP重试次数
echo 3 > /proc/sys/net/ipv4/tcp_syn_retries  # 减少SYN重试次数

# 调整ARP超时时间
echo 1 > /proc/sys/net/ipv4/neigh/eth0/delay_first_probe_time
echo 1 > /proc/sys/net/ipv4/neigh/eth0/retrans_time_ms

# 使用更短的bonding检测间隔
echo "50" > /sys/class/net/bond0/bonding/miimon  # 50毫秒检测一次
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心技术


```
🔸 网络接口聚合（Bonding）：提升带宽和可靠性的基础技术
🔸 VLAN配置：网络隔离和虚拟化的关键技术  
🔸 网桥管理：连接多个网络段的核心技术
🔸 网络命名空间：网络隔离和容器化的基础
🔸 性能调优：发挥网络硬件最大潜能
🔸 安全配置：保护网络基础设施安全
🔸 故障切换：确保网络服务高可用性
```

### 10.2 实际应用场景映射


**🏢 企业环境应用**：
- **服务器双网卡绑定**：使用bonding提升可靠性
- **部门网络隔离**：使用VLAN分离不同部门网络
- **虚拟化平台**：使用网桥连接虚拟机
- **容器网络**：使用网络命名空间隔离容器

**☁️ 云环境应用**：
- **多可用区部署**：跨网络的故障切换
- **微服务网络**：命名空间实现服务隔离
- **软件定义网络**：虚拟网络设备管理
- **网络安全**：流量控制和访问限制

### 10.3 关键理解要点


**🔹 技术选择原则**：
```
带宽优先 → 选择轮询模式bonding + 多队列网卡
可靠性优先 → 选择active-backup模式bonding
隔离需求 → 选择VLAN或网络命名空间
性能要求 → 重点关注网卡调优和缓冲区优化
```

**🔹 故障排查思路**：
```
1. 物理层检查：网线、接口状态、链路速率
2. 数据链路层：MAC地址、VLAN配置、网桥状态
3. 网络层：IP地址、路由、网络可达性
4. 性能分析：带宽、延迟、丢包率、错误统计
```

**🔹 安全配置要点**：
```
- 网络隔离：正确配置VLAN和命名空间
- 访问控制：合理设置防火墙规则
- 流量限制：防止DDoS和滥用
- 监控告警：及时发现异常行为
```

### 10.4 最佳实践建议


> 💡 **配置管理**：所有网络配置都应该有文档记录和版本控制

> ⚠️ **测试验证**：网络配置修改前应该在测试环境验证

> 🔍 **监控告警**：建立完善的网络监控体系

> 📋 **应急预案**：准备网络故障的应急处理流程

**🎯 学习进阶路径**：
1. **基础掌握**：熟练使用ip、ethtool等工具
2. **原理理解**：深入理解Linux网络协议栈
3. **实践应用**：在实际环境中配置和调优
4. **高级特性**：学习SDN、容器网络等新技术

**核心记忆口诀**：
- 网卡聚合提性能，主备模式保可靠
- VLAN划分做隔离，网桥连接多网段  
- 命名空间独立网，虚拟设备灵活用
- 性能调优抓重点，安全配置不可忘
- 故障切换要及时，监控告警是保障