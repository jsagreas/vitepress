---
title: 4、SELinux策略类型与管理
---
## 📚 目录

1. [SELinux策略类型概述](#1-SELinux策略类型概述)
2. [targeted策略详解](#2-targeted策略详解)
3. [策略文件系统结构](#3-策略文件系统结构)
4. [seinfo策略信息查看](#4-seinfo策略信息查看)
5. [sesearch策略规则查询](#5-sesearch策略规则查询)
6. [策略版本管理](#6-策略版本管理)
7. [自定义策略开发基础](#7-自定义策略开发基础)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛡️ SELinux策略类型概述


### 1.1 什么是SELinux策略


**🔸 策略的本质含义**
SELinux策略就像是一本详细的"规则手册"，规定了系统中每个程序、文件、用户能做什么，不能做什么。

```
生活类比：
策略 = 公司员工手册
规定了：哪个部门的人能访问哪些文件柜
         什么时候能访问
         能进行什么操作
```

**💡 策略的核心作用**
- **访问控制**：决定谁能访问什么资源
- **权限限制**：即使是root用户也要遵守规则
- **安全防护**：防止恶意软件突破传统权限控制

### 1.2 三大策略类型对比


| 策略类型 | **特点** | **安全级别** | **适用场景** | **复杂度** |
|---------|----------|-------------|-------------|-----------|
| 🎯 **targeted** | `保护关键服务` | ⭐⭐⭐ | `大多数服务器` | 🟢 简单 |
| 🔒 **strict** | `全面强制访问控制` | ⭐⭐⭐⭐⭐ | `高安全环境` | 🔴 复杂 |
| 🏛️ **mls** | `多级安全分类` | ⭐⭐⭐⭐⭐ | `军用/政府` | 🔴 极复杂 |

**🏠 生活类比理解**
```
targeted策略 = 小区保安
只管重要区域（门禁、车库），其他地方相对自由

strict策略 = 银行安保
每个角落都有监控，每次行为都要验证

mls策略 = 军事基地
不同级别人员只能接触对应级别的信息
```

---

## 2. 🎯 targeted策略详解


### 2.1 targeted策略的工作原理


**🔸 核心理念：选择性保护**
targeted策略并不是对所有程序都进行严格控制，而是"抓大放小"——重点保护那些容易被攻击的关键服务。

```
targeted策略的保护范围：
┌─受保护的服务────────┐    ┌─不受限制的普通程序──┐
│ • Apache网页服务器  │    │ • 普通用户程序      │
│ • SSH远程登录服务   │    │ • 文本编辑器        │  
│ • 数据库服务        │    │ • 计算器           │
│ • 邮件服务器        │    │ • 游戏程序         │
└────────────────────┘    └────────────────────┘
        严格管理                    相对自由
```

### 2.2 受限域(Confined Domain)详解


**📊 什么是受限域**
受限域就是被SELinux严格管理的"特殊区域"，运行在这些区域的程序必须严格遵守预设规则。

**🔍 查看当前受限域**
```bash
# 查看所有受限域
semanage domain -l

# 常见的受限域示例
httpd_t          # Apache网页服务器域
sshd_t           # SSH服务域  
mysqld_t         # MySQL数据库域
postfix_t        # 邮件服务域
```

**💪 受限域的优势**
- **防止权限升级**：即使程序被攻破，也无法访问不相关资源
- **限制横向移动**：攻击者无法从一个服务跳转到另一个服务
- **保护关键文件**：重要系统文件受到额外保护

### 2.3 不受限域(Unconfined Domain)


**🔸 不受限域的特点**
```
不受限域的程序特征：
✅ 像传统Linux一样运行
✅ 主要受DAC（传统权限）控制  
✅ SELinux对其影响最小
❌ 安全防护相对较弱
```

**📋 常见不受限域**
- `unconfined_t`：普通用户程序
- `unconfined_service_t`：某些系统服务
- `initrc_t`：启动脚本

### 2.4 targeted策略适用场景


**🎯 最佳使用场景**
```
✅ 推荐场景：
• Web服务器（保护Apache/Nginx）
• 数据库服务器（保护MySQL/PostgreSQL）  
• 邮件服务器（保护Postfix/Dovecot）
• SSH登录服务器
• 开发测试环境

❌ 不推荐场景：
• 桌面个人电脑（过于复杂）
• 纯计算服务器（无网络服务）
• 嵌入式设备（资源受限）
```

---

## 3. 📁 策略文件系统结构


### 3.1 策略文件存放位置


**🗂️ 核心目录结构**
```
SELinux策略文件分布：
/etc/selinux/
├── config                    ← 主配置文件
├── targeted/                 ← targeted策略目录
│   ├── policy/               ← 编译后的策略文件
│   │   └── policy.31         ← 策略版本文件
│   ├── contexts/             ← 上下文配置
│   │   ├── files/            ← 文件上下文规则
│   │   └── users/            ← 用户上下文规则
│   └── modules/              ← 策略模块
└── semanage.conf             ← 管理工具配置
```

### 3.2 重要配置文件详解


**📄 主配置文件：/etc/selinux/config**
```bash
# SELinux主要配置参数
SELINUX=enforcing        # SELinux运行模式
SELINUXTYPE=targeted     # 使用的策略类型  
```

**🔍 配置参数含义**
- **SELINUX参数**：
  - `enforcing`：强制模式，违规行为被阻止
  - `permissive`：宽容模式，违规行为仅记录日志
  - `disabled`：关闭SELinux
  
- **SELINUXTYPE参数**：
  - `targeted`：使用targeted策略
  - `strict`：使用strict策略  
  - `mls`：使用mls策略

### 3.3 策略模块系统


**🧩 模块化策略设计**
SELinux采用模块化设计，就像搭积木一样，每个服务对应一个策略模块。

```
策略模块结构：
/usr/share/selinux/targeted/
├── base.pp              ← 基础策略模块（必需）
├── apache.pp            ← Apache模块
├── mysql.pp             ← MySQL模块  
├── ssh.pp               ← SSH模块
└── postfix.pp           ← 邮件模块
```

**💡 模块化的好处**
- **灵活组合**：根据需要启用特定模块
- **易于维护**：单独更新某个服务的策略
- **减少冲突**：不同服务的规则分离

---

## 4. 🔍 seinfo策略信息查看


### 4.1 seinfo命令基础


**📊 seinfo命令的作用**
`seinfo`就像是SELinux策略的"百科全书查询工具"，帮你了解当前策略包含哪些规则和信息。

**🛠️ 基础语法**
```bash
seinfo [选项] [查询类型]
```

### 4.2 常用查询操作


**📋 查看策略统计信息**
```bash
# 显示策略概览统计
seinfo

# 输出示例解读：
Statistics for policy file: /etc/selinux/targeted/policy/policy.31
Policy Version & Type: v.31 (binary, mls)

   Classes:     134    # 对象类别数量（文件、进程等）
   Types:      4793    # 类型数量  
   Attributes:  259    # 属性数量
   Users:         8    # SELinux用户数量
   Roles:        14    # 角色数量
   Booleans:    344    # 布尔值数量
```

**🔎 查看特定信息类别**
```bash
# 查看所有类型
seinfo -t

# 查看所有角色  
seinfo -r

# 查看所有用户
seinfo -u

# 查看所有布尔值
seinfo -b
```

### 4.3 实用查询示例


**🎯 查找特定服务相关信息**
```bash
# 查找Apache相关类型
seinfo -t | grep httpd

# 查找SSH相关类型  
seinfo -t | grep ssh

# 查找数据库相关类型
seinfo -t | grep mysql
```

**💡 理解查询结果**
```
类型命名规律：
服务名_功能_t 的格式

httpd_t          # Apache主进程类型
httpd_config_t   # Apache配置文件类型  
httpd_log_t      # Apache日志文件类型
httpd_exec_t     # Apache可执行文件类型
```

### 4.4 进阶查询技巧


**🔍 属性查询**
```bash
# 查看域属性（进程类型的分类）
seinfo -adomain

# 查看文件属性
seinfo -afile_type

# 查看网络相关属性
seinfo -aport_type
```

**📊 布尔值详细查询**
```bash
# 查看所有布尔值及其状态
seinfo -b --stats

# 查找特定服务的布尔值
seinfo -b | grep httpd
```

---

## 5. 🔎 sesearch策略规则查询


### 5.1 sesearch命令原理


**🔸 sesearch的作用**
如果说`seinfo`是查看"有什么"，那么`sesearch`就是查询"能做什么"——它专门用来查询具体的访问规则。

**🏠 生活类比**
```
seinfo = 查看公司组织架构
"公司有哪些部门？每个部门有多少人？"

sesearch = 查看权限规则
"财务部门能访问哪些系统？技术部门能做什么操作？"
```

### 5.2 基本查询语法


**🛠️ 核心语法结构**
```bash
sesearch [选项] [规则类型] -s 源类型 -t 目标类型 -c 对象类别
```

**📋 主要选项说明**
- `-A`：查询允许规则（allow rules）
- `-s`：指定源类型（主体）
- `-t`：指定目标类型（客体）
- `-c`：指定对象类别
- `-p`：指定权限

### 5.3 实用查询示例


**🎯 查询Apache访问权限**
```bash
# 查看httpd进程能访问哪些文件
sesearch -A -s httpd_t -c file

# 查看httpd进程能执行的网络操作
sesearch -A -s httpd_t -c tcp_socket

# 查看httpd进程的所有允许操作
sesearch -A -s httpd_t
```

**🔍 查询文件访问规则**
```bash
# 查看谁能读取Apache配置文件
sesearch -A -t httpd_config_t -c file -p read

# 查看谁能写入日志目录
sesearch -A -t var_log_t -c dir -p write
```

### 5.4 复杂查询技巧


**📊 组合条件查询**
```bash
# 查询httpd进程对特定文件的读写权限
sesearch -A -s httpd_t -t httpd_config_t -c file -p read,write

# 查询所有能执行网络连接的进程
sesearch -A -c tcp_socket -p connect
```

**💡 查询结果解读**
```bash
# 示例输出：
allow httpd_t var_log_t:file { create write append };

# 解读：
# 允许(allow) httpd_t类型 对 var_log_t类型的file对象 
# 执行 创建、写入、追加 操作
```

### 5.5 故障排查应用


**🚨 权限问题诊断流程**
```
问题：Apache无法写入日志文件

1️⃣ 确认当前进程类型
ps -Z | grep httpd

2️⃣ 确认文件上下文  
ls -Z /var/log/httpd/

3️⃣ 查询权限规则
sesearch -A -s httpd_t -t var_log_t -c file -p write

4️⃣ 分析结果确定问题
```

---

## 6. 📊 策略版本管理


### 6.1 策略版本机制


**🔸 版本管理的作用**
SELinux策略版本就像软件版本一样，每次更新策略规则时版本号会递增，确保系统知道使用哪个版本的规则。

```
版本演进示例：
策略版本24 ──更新──> 策略版本25 ──更新──> 策略版本26
    ↓                    ↓                    ↓
包含100个模块         新增2个模块         修复3个Bug
```

### 6.2 查看当前策略版本


**🔍 版本信息查看**
```bash
# 查看当前策略版本
sestatus

# 输出解读：
SELinux status:                 enabled
Current mode:                   enforcing  
Policy version:                 31         # 当前版本号
```

**📄 版本文件位置**
```bash
# 策略版本文件路径
ls /etc/selinux/targeted/policy/
policy.31    # 版本31的策略文件

# 查看文件信息
file /etc/selinux/targeted/policy/policy.31
```

### 6.3 策略更新流程


**🔄 更新流程图**
```
策略更新流程：
开发策略源码 → 编译策略 → 安装策略 → 重载策略 → 生效执行
     ↓            ↓         ↓        ↓        ↓
   .te文件    policy.31   复制文件   semodule  实际运行
```

**⚙️ 手动更新步骤**
```bash
# 1. 查看可用更新
yum check-update selinux-policy*

# 2. 更新策略包
yum update selinux-policy

# 3. 重新加载策略
semodule -R

# 4. 验证版本
sestatus
```

### 6.4 版本兼容性管理


**⚠️ 版本兼容性注意事项**
```
版本升级风险：
🟢 小版本升级（31→32）：   通常安全，规则微调
🟡 大版本升级（30→35）：   需要测试，可能有变化  
🔴 跨代版本升级（25→31）： 谨慎操作，可能不兼容
```

**🛡️ 升级前预防措施**
1. **备份当前策略**：`cp /etc/selinux/targeted/policy/policy.31 ~/backup/`
2. **记录当前配置**：`semanage export > current_config.txt`
3. **测试环境验证**：先在测试机上验证
4. **准备回滚方案**：确保能快速恢复

---

## 7. 🛠️ 自定义策略开发基础


### 7.1 为什么需要自定义策略


**🤔 什么情况下需要自定义**
默认策略虽然覆盖了常见服务，但遇到以下情况就需要自定义：

```
需要自定义策略的场景：
✅ 自己开发的应用程序
✅ 第三方软件没有默认策略  
✅ 需要修改现有策略规则
✅ 特殊的文件访问需求
✅ 自定义的网络服务
```

### 7.2 策略开发基础工具


**🧰 必需的开发工具**
```bash
# 安装策略开发工具包
yum install policycoreutils-python-utils
yum install selinux-policy-devel

# 核心工具说明：
audit2allow    # 从日志生成策略规则
sepolicy       # 策略分析工具
semodule       # 模块管理工具
checkpolicy    # 策略编译工具
```

### 7.3 简单策略开发流程


**📝 开发流程概览**
```
策略开发五步法：
1️⃣ 问题识别 ──> 2️⃣ 日志分析 ──> 3️⃣ 规则生成 ──> 4️⃣ 策略编译 ──> 5️⃣ 安装测试
```

**🔧 实际操作示例**
```bash
# 步骤1：设置为宽容模式收集日志
setenforce 0

# 步骤2：运行程序触发访问
./my_custom_app

# 步骤3：分析审计日志
grep "my_custom_app" /var/log/audit/audit.log

# 步骤4：生成策略规则  
audit2allow -i /var/log/audit/audit.log -M my_custom_policy

# 步骤5：安装自定义策略
semodule -i my_custom_policy.pp

# 步骤6：切换回强制模式测试
setenforce 1
```

### 7.4 策略文件结构基础


**📄 .te策略文件基本结构**
```bash
# 示例：my_app.te文件结构

# 策略版本（必需）
policy_module(my_app, 1.0.0)

# 类型声明
type my_app_t;               # 进程类型
type my_app_exec_t;          # 可执行文件类型  
type my_app_config_t;        # 配置文件类型

# 属性关联
application_domain(my_app_t, my_app_exec_t)

# 访问规则
allow my_app_t my_app_config_t:file { read open };
```

### 7.5 策略开发最佳实践


**✨ 开发建议**
```
🎯 策略开发原则：
• 最小权限原则：只给必需的权限
• 循序渐进：先简单规则，后复杂规则
• 充分测试：在测试环境验证
• 文档记录：记录策略用途和规则
• 版本管理：使用版本控制工具
```

**⚠️ 常见陷阱避免**
- **权限过大**：不要图省事给过多权限
- **忽略依赖**：注意策略模块间的依赖关系  
- **测试不足**：必须在各种场景下充分测试
- **文档缺失**：复杂策略必须写清楚用途

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 策略类型理解**
```
targeted策略：重点保护关键服务，最常用
strict策略：  全面强制控制，高安全环境  
mls策略：    多级安全分类，军用政府
```

**🔸 关键文件位置**
```
/etc/selinux/config           # 主配置文件
/etc/selinux/targeted/policy/ # 策略文件目录
/var/log/audit/audit.log      # 审计日志文件
```

**🔸 核心管理工具**
```
seinfo：   查看策略信息统计
sesearch： 查询具体访问规则  
semodule： 管理策略模块
sestatus： 查看SELinux状态
```

### 8.2 关键操作流程


**🔹 策略问题排查流程**
```
1️⃣ 确认SELinux状态：sestatus
2️⃣ 查看审计日志：grep "拒绝操作" /var/log/audit/audit.log  
3️⃣ 分析权限规则：sesearch -A -s 源类型 -t 目标类型
4️⃣ 生成解决方案：audit2allow -i 日志文件
5️⃣ 应用策略修改：semodule -i 策略文件
```

**🔹 自定义策略开发流程**
```
1️⃣ 需求分析 → 2️⃣ 环境准备 → 3️⃣ 日志收集 → 4️⃣ 策略生成 → 5️⃣ 测试验证
```

### 8.3 实际应用价值


**🎯 日常运维应用**
- **服务部署**：为新服务配置合适的SELinux策略
- **故障排查**：快速定位SELinux相关的权限问题
- **安全加固**：通过策略定制提升系统安全性
- **合规检查**：确保系统符合安全策略要求

**🔧 进阶技能发展**
- **策略开发**：为自定义应用开发专属策略
- **安全审计**：通过策略分析发现潜在安全风险  
- **性能优化**：合理配置策略减少性能开销
- **自动化运维**：将SELinux管理集成到自动化流程

### 8.4 学习路径建议


**📚 学习进阶路线**
```
初级阶段：理解基本概念，掌握常用查询命令
    ↓
中级阶段：能够排查常见问题，进行简单策略修改  
    ↓  
高级阶段：独立开发自定义策略，设计安全方案
    ↓
专家阶段：优化性能，设计复杂安全架构
```

**💡 持续学习建议**
- **实践为主**：在实际环境中练习各种操作
- **案例积累**：收集和分析各种故障案例
- **社区参与**：关注SELinux社区最新动态
- **文档阅读**：深入研读官方文档和最佳实践

**🎯 记忆要点**
```
SELinux策略三句话：
1. targeted策略保重点，日常使用最合适
2. seinfo看信息，sesearch查规则，故障排查靠日志
3. 自定义策略要谨慎，最小权限是原则
```

**🚀 下一步学习方向**
- SELinux布尔值配置与管理
- 文件和进程上下文管理  
- 高级故障排查技巧
- 企业级SELinux安全策略设计