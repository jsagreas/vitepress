---
title: 6、tee分流工具使用
---
## 📚 目录

1. [tee工具基础概念](#1-tee工具基础概念)
2. [基础分流语法与工作原理](#2-基础分流语法与工作原理)
3. [覆盖模式与追加模式](#3-覆盖模式与追加模式)
4. [多文件同时输出分流](#4-多文件同时输出分流)
5. [管道中间结果保存技巧](#5-管道中间结果保存技巧)
6. [日志记录最佳实践](#6-日志记录最佳实践)
7. [错误输出分流处理](#7-错误输出分流处理)
8. [脚本调试中的应用](#8-脚本调试中的应用)
9. [分流性能与磁盘优化](#9-分流性能与磁盘优化)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔧 tee工具基础概念


### 1.1 什么是tee工具


**tee**是Linux系统中的一个实用命令，名字来源于水管的**T型三通接头**。就像水管三通可以让水流同时流向两个方向，tee命令可以让数据同时流向**屏幕显示**和**文件保存**两个地方。

```
数据流向对比：

普通重定向：
命令输出 ──────▶ 文件
(看不到屏幕输出)

tee分流：
      ┌─────▶ 屏幕显示
命令输出 ──┤
      └─────▶ 文件保存
```

### 1.2 tee的核心作用


**🔸 主要功能**：
- **同步输出**：数据既显示在终端，又保存到文件
- **中间保存**：在管道链中保存中间处理结果  
- **实时监控**：一边处理数据一边观察输出内容
- **调试辅助**：帮助定位管道链中的数据处理问题

**🔸 应用场景**：
- 脚本执行过程中既要看到输出，又要记录日志
- 数据处理管道中需要保存中间步骤的结果
- 系统监控时需要同时显示和记录状态信息

---

## 2. ⚙️ 基础分流语法与工作原理


### 2.1 基本语法结构


```bash
# 基础语法

command | tee filename

# 完整格式

tee [选项] 文件名1 [文件名2] [文件名3] ...
```

**🔸 工作流程**：
1. **接收输入**：从标准输入或管道接收数据
2. **双向输出**：将数据复制一份发送到标准输出(屏幕)
3. **写入文件**：同时将数据写入指定的文件
4. **继续传递**：如果后面还有管道，继续传递给下个命令

### 2.2 简单使用示例


```bash
# 列出文件并保存到list.txt，同时显示在屏幕上

ls -la | tee list.txt

# 查看系统信息，既显示又保存

date | tee system_time.log
```

**🔸 执行效果**：
```
执行：ls -la | tee list.txt

屏幕显示：
total 48
drwxr-xr-x  3 user user 4096 Jan 20 14:30 .
drwxr-xr-x 25 user user 4096 Jan 20 14:25 ..
-rw-r--r--  1 user user  220 Jan 20 14:30 file1.txt

同时，list.txt文件中也保存了相同内容
```

### 2.3 工作原理图解


```
输入数据流：command 的输出
     │
     ▼
┌────────────┐
│  tee命令   │ ──复制数据──┐
│  处理器    │             │
└────────────┘             │
     │                     │
     ▼                     ▼
  屏幕显示              写入文件
(标准输出)             filename
     │
     ▼
继续管道传递
(如果有后续命令)
```

---

## 3. 📝 覆盖模式与追加模式


### 3.1 默认覆盖模式


**tee命令默认使用覆盖模式**，每次执行都会**完全覆盖**目标文件的原有内容。

```bash
# 第一次执行

echo "第一行内容" | tee test.txt
# test.txt内容：第一行内容


# 第二次执行（覆盖前面的内容）

echo "第二行内容" | tee test.txt  
# test.txt内容：第二行内容（第一行内容被覆盖了）

```

**⚠️ 注意事项**：
- 覆盖模式会**丢失原文件内容**
- 适用于**临时结果保存**或**定期更新**的场景
- 如果文件不存在，会**自动创建**新文件

### 3.2 追加模式(-a选项)


使用`-a`选项可以启用**追加模式**，新内容会添加到文件末尾，**不会覆盖**原有内容。

```bash
# 创建初始内容

echo "第一行" | tee test.txt

# 追加新内容

echo "第二行" | tee -a test.txt
echo "第三行" | tee -a test.txt

# test.txt最终内容：

# 第一行

# 第二行  

# 第三行

```

### 3.3 模式选择指南


| 使用场景 | **推荐模式** | **选择理由** |
|---------|------------|-------------|
| 🔸 **日志记录** | `追加模式(-a)` | `保留历史记录，便于追踪` |
| 🔸 **状态快照** | `覆盖模式` | `只关心当前状态，节省空间` |
| 🔸 **临时文件** | `覆盖模式` | `避免文件越来越大` |
| 🔸 **累积统计** | `追加模式(-a)` | `需要汇总所有数据` |

---

## 4. 📂 多文件同时输出分流


### 4.1 同时写入多个文件


tee支持**一次性将数据写入多个文件**，这在需要将相同数据保存到不同位置时非常有用。

```bash
# 同时保存到3个文件

date | tee file1.txt file2.txt file3.txt

# 混合使用覆盖和追加模式

ls -la | tee current_list.txt -a history_list.txt backup_list.txt
```

**🔸 执行效果**：
- 屏幕显示一份内容
- 每个指定的文件都保存完整的数据副本
- 各文件独立操作，互不影响

### 4.2 分类保存应用示例


```bash
# 系统监控信息分类保存

ps aux | tee \
    /var/log/process_all.log \
    /home/user/monitoring/current_process.txt \
    /backup/system_snapshot.log
```

**💡 实用技巧**：
```bash
# 为不同文件设置不同的追加模式（需要多次tee）

command_output | tee new_file.txt | tee -a history_file.txt
```

### 4.3 多文件输出的应用场景


**🔸 备份策略**：
```bash
# 重要配置文件的多重备份

cat /etc/nginx/nginx.conf | tee \
    /backup/nginx.conf.$(date +%Y%m%d) \
    /home/admin/configs/nginx.conf \
    /mnt/remote/backup/nginx.conf
```

**🔸 分环境部署**：
```bash
# 配置文件同时部署到开发、测试环境

generate_config.sh | tee \
    /dev/app/config.yaml \
    /test/app/config.yaml
```

---

## 5. 🔄 管道中间结果保存技巧


### 5.1 管道链中的中间保存


在复杂的数据处理管道中，tee可以**保存中间步骤的结果**，这对于调试和数据验证非常重要。

```bash
# 数据处理管道示例

cat data.txt | \
    grep "关键词" | tee step1_filtered.txt | \
    sort | tee step2_sorted.txt | \
    uniq -c | tee step3_counted.txt | \
    head -10
```

**🔸 处理流程**：
```
原始数据 ──▶ 过滤 ──▶ 排序 ──▶ 去重计数 ──▶ 前10条
  │          │       │        │           │
  │      保存到   保存到   保存到      最终输出
  │     step1    step2    step3       到屏幕
data.txt
```

### 5.2 调试友好的管道设计


```bash
# 调试时可以随时检查中间结果

log_analysis() {
    cat /var/log/access.log | \
        tee raw_log.debug | \
        grep "ERROR" | tee error_lines.debug | \
        cut -d' ' -f1,4,7 | tee extracted_fields.debug | \
        sort | uniq -c | \
        sort -nr
}
```

**💡 调试优势**：
- 出错时可以检查每个步骤的输出
- 避免重复执行耗时的前置命令
- 便于优化单个处理步骤

### 5.3 条件保存技巧


```bash
# 只在满足条件时保存中间结果

process_data() {
    local debug_mode=${1:-false}
    
    if [[ "$debug_mode" == "true" ]]; then
        cat input.txt | \
            process_step1 | tee debug_step1.txt | \
            process_step2 | tee debug_step2.txt | \
            process_step3
    else
        cat input.txt | process_step1 | process_step2 | process_step3
    fi
}
```

---

## 6. 📋 日志记录最佳实践


### 6.1 实时日志监控


tee在日志处理中的最大优势是**边处理边查看**，特别适合需要实时监控的场景。

```bash
# 应用程序实时日志监控

./my_application 2>&1 | tee -a /var/log/myapp.log

# 带时间戳的日志记录

./monitor_script.sh | while read line; do
    echo "$(date '+%Y-%m-%d %H:%M:%S') $line" | tee -a system_monitor.log
done
```

### 6.2 分级日志管理


```bash
# 按日志级别分别保存

app_with_logging() {
    ./application 2>&1 | while read line; do
        echo "$line"  # 显示到屏幕
        
#        # 根据内容分类保存
        if echo "$line" | grep -q "ERROR"; then
            echo "$line" >> /var/log/app_error.log
        elif echo "$line" | grep -q "WARN"; then
            echo "$line" >> /var/log/app_warning.log
        fi
        
#        # 所有日志都保存到总日志
        echo "$line" >> /var/log/app_all.log
    done
}
```

### 6.3 轮换日志配置


```bash
# 按日期轮换的日志记录

daily_backup() {
    local today=$(date +%Y-%m-%d)
    ./backup_script.sh | tee -a "/var/log/backup_$today.log"
}

# 按大小限制的日志文件

limited_log() {
    local logfile="/var/log/application.log"
    
#    # 检查文件大小，超过10MB时轮换
    if [[ -f "$logfile" && $(stat -f%z "$logfile" 2>/dev/null || stat -c%s "$logfile") -gt 10485760 ]]; then
        mv "$logfile" "$logfile.old"
    fi
    
    ./application | tee -a "$logfile"
}
```

---

## 7. ⚠️ 错误输出分流处理


### 7.1 标准错误重定向问题


**重要概念**：tee默认只处理**标准输出(stdout)**，不会处理**标准错误(stderr)**。

```bash
# ❌ 错误的做法：错误信息不会被tee处理

command_with_errors | tee output.log
# 错误信息直接显示在屏幕，不保存到文件


# ✅ 正确的做法：先合并标准输出和标准错误

command_with_errors 2>&1 | tee output.log
# 2>&1 将stderr重定向到stdout，然后tee处理合并后的输出

```

### 7.2 错误输出分流技巧


**🔸 错误和正常输出合并保存**：
```bash
# 所有输出都保存，便于完整分析

./risky_command 2>&1 | tee complete_log.txt
```

**🔸 错误和正常输出分别保存**：
```bash
# 使用进程替换分别处理

./risky_command > >(tee stdout.log) 2> >(tee stderr.log >&2)

# 或者使用临时文件

{
    ./risky_command 2>&3 | tee stdout.log
} 3>&1 1>&2 | tee stderr.log
```

### 7.3 错误处理实用模式


```bash
# 错误日志和正常日志分开，但都显示在屏幕

safe_execution() {
    local cmd="$1"
    local log_prefix="$2"
    
#    # 执行命令并分别处理输出
    {
        eval "$cmd" 2>&3 | tee "${log_prefix}_success.log"
    } 3>&1 1>&2 | tee "${log_prefix}_error.log" >&2
}

# 使用示例

safe_execution "find /etc -name '*.conf'" "config_search"
```

---

## 8. 🔍 脚本调试中的应用


### 8.1 调试信息可视化


tee在脚本调试中可以帮助**可视化数据流动**，让调试过程更加直观。

```bash
#!/bin/bash

# 调试友好的数据处理脚本


debug_data_process() {
    local input_file="$1"
    local debug=${DEBUG:-false}
    
    if [[ "$debug" == "true" ]]; then
        echo "🔍 调试模式启用，中间结果将保存到debug/目录"
        mkdir -p debug/
        
        cat "$input_file" | \
            tee debug/01_raw_input.txt | \
            grep -v "^#" | tee debug/02_no_comments.txt | \
            sed 's/[[:space:]]*$//' | tee debug/03_trimmed.txt | \
            sort | tee debug/04_sorted.txt | \
            uniq | tee debug/05_unique.txt
    else
        cat "$input_file" | grep -v "^#" | sed 's/[[:space:]]*$//' | sort | uniq
    fi
}
```

### 8.2 性能监控集成


```bash
# 带性能统计的脚本执行

timed_execution() {
    local start_time=$(date +%s.%N)
    
    echo "开始执行: $(date)" | tee -a performance.log
    
    "$@" 2>&1 | tee -a execution.log | while read line; do
        printf "[%s] %s\n" "$(date '+%H:%M:%S')" "$line"
    done
    
    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc)
    
    echo "执行完成: $(date), 耗时: ${duration}秒" | tee -a performance.log
}
```

### 8.3 条件调试输出


```bash
# 可控的调试输出级别

debug_tee() {
    local level=${DEBUG_LEVEL:-0}
    local msg_level=${1:-1}
    local filename="$2"
    
    if [[ $level -ge $msg_level ]]; then
        if [[ -n "$filename" ]]; then
            tee -a "$filename"
        else
            tee -a debug.log
        fi
    else
        cat > /dev/null  # 丢弃输出
    fi
}

# 使用示例

echo "级别1调试信息" | debug_tee 1 "level1.log"
echo "级别2调试信息" | debug_tee 2 "level2.log"
```

---

## 9. ⚡ 分流性能与磁盘优化


### 9.1 I/O性能考虑


使用tee时需要考虑**磁盘I/O性能**影响，特别是处理大量数据时。

**🔸 性能影响因素**：
- **磁盘写入速度**：机械硬盘 < SSD < NVMe
- **文件系统类型**：ext4、xfs、btrfs性能差异
- **同时写入文件数量**：越多文件，I/O压力越大
- **数据量大小**：大数据流需要考虑缓冲策略

### 9.2 性能优化策略


**🔸 减少磁盘写入**：
```bash
# ❌ 性能较差：频繁小文件写入

continuous_small_writes() {
    while read line; do
        echo "$line" | tee -a many_files_*.log
    done
}

# ✅ 性能较好：批量写入

batch_writes() {
#    # 收集一定量数据后批量写入
    buffer=""
    count=0
    
    while read line; do
        buffer+="$line\n"
        ((count++))
        
        if [[ $count -ge 100 ]]; then
            echo -e "$buffer" | tee -a target.log > /dev/null
            buffer=""
            count=0
        fi
    done
    
#    # 处理剩余数据
    [[ -n "$buffer" ]] && echo -e "$buffer" | tee -a target.log > /dev/null
}
```

**🔸 内存缓冲优化**：
```bash
# 使用内存文件系统减少磁盘I/O

setup_temp_storage() {
#    # 创建内存文件系统（需要root权限）
    mkdir -p /tmp/tee_buffer
    mount -t tmpfs -o size=100M tmpfs /tmp/tee_buffer
    
#    # 在内存中进行中间处理
    process_large_data | tee /tmp/tee_buffer/temp.log | final_process
    
#    # 处理完成后移动到最终位置
    mv /tmp/tee_buffer/temp.log /var/log/final_result.log
}
```

### 9.3 监控和诊断


```bash
# 监控tee的性能影响

monitor_tee_performance() {
    local pid=""
    
#    # 启动命令并获取PID
    large_data_process | tee huge_output.log &
    pid=$!
    
#    # 监控I/O统计
    while kill -0 $pid 2>/dev/null; do
        iostat -x 1 1 | grep -E "(Device|sda|nvme)"
        sleep 5
    done
}
```

**🔸 性能基准测试**：
```bash
# 对比tee与重定向的性能差异

benchmark_tee() {
    local test_data="large_test_file.txt"
    
    echo "测试重定向性能..."
    time (cat "$test_data" > redirect_output.txt)
    
    echo "测试tee性能..."  
    time (cat "$test_data" | tee tee_output.txt > /dev/null)
    
    echo "测试多文件tee性能..."
    time (cat "$test_data" | tee file1.txt file2.txt file3.txt > /dev/null)
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基础概念


**🔸 tee工具本质**：
- T型分流器，将数据同时输出到屏幕和文件
- 不改变数据内容，只是复制分发
- 支持管道链中的中间结果保存

**🔸 核心语法模式**：
```bash
# 基础分流

command | tee filename

# 追加模式  

command | tee -a filename

# 多文件分流

command | tee file1 file2 file3

# 错误输出处理

command 2>&1 | tee logfile
```

### 10.2 实用应用模式


| 应用场景 | **命令模式** | **核心价值** |
|---------|------------|-------------|
| 🔸 **实时日志** | `app \| tee -a app.log` | `边运行边记录，便于监控` |
| 🔸 **调试管道** | `cmd1 \| tee debug.txt \| cmd2` | `保存中间结果，便于排错` |
| 🔸 **多重备份** | `data \| tee file1 file2 file3` | `一次操作，多处保存` |
| 🔸 **错误追踪** | `cmd 2>&1 \| tee error.log` | `捕获所有输出信息` |

### 10.3 最佳实践要点


**🔹 文件模式选择**：
- **覆盖模式**：临时文件、状态快照、定期更新
- **追加模式(-a)**：日志记录、累积数据、历史追踪

**🔹 性能优化**：
- 大数据量时考虑磁盘I/O性能
- 合理控制同时写入的文件数量
- 必要时使用内存缓冲区

**🔹 调试技巧**：
- 在管道链关键节点使用tee保存中间结果
- 结合错误重定向(2>&1)捕获完整信息
- 使用条件调试避免生产环境性能影响

### 10.4 常见误区避免


**❌ 容易犯的错误**：
- 忘记使用`2>&1`导致错误信息丢失
- 在性能敏感环境中过度使用多文件分流
- 混淆覆盖模式和追加模式导致数据丢失

**✅ 推荐做法**：
- 根据数据性质选择合适的保存模式
- 在脚本中提供调试开关控制tee使用
- 定期清理调试文件避免磁盘空间耗尽

**🧠 记忆要点**：
- **tee = T型分流**：一进两出，数据分发
- **默认覆盖，-a追加**：根据需求选择模式
- **2>&1配合**：完整捕获所有输出信息
- **调试利器**：管道中间结果可视化神器