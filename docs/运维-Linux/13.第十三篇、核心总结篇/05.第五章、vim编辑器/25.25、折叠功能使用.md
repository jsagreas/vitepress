---
title: 25、折叠功能使用
---
## 📚 目录


1. [折叠功能基本概念](#1-折叠功能基本概念)
2. [折叠方法设置](#2-折叠方法设置)
3. [折叠的创建与删除](#3-折叠的创建与删除)
4. [折叠的打开与关闭](#4-折叠的打开与关闭)
5. [折叠间的移动操作](#5-折叠间的移动操作)
6. [折叠的保存与恢复](#6-折叠的保存与恢复)
7. [折叠在长文件中的实际应用](#7-折叠在长文件中的实际应用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📁 折叠功能基本概念



### 1.1 什么是折叠功能



**🔸 简单理解**：
折叠功能就像是给文档做**"收纳整理"**，把暂时不需要看的内容"折叠"起来隐藏，让屏幕更清爽，专注于当前正在处理的部分。

```
展开状态：              折叠状态：
函数定义               函数定义
├─ 参数声明            +-- 5 lines folded ----
├─ 变量初始化
├─ 核心逻辑            下一个函数
├─ 返回语句
└─ 函数结束
下一个函数
```

**💡 生活类比**：
> 就像整理衣柜时，把不常穿的衣服折叠收起来，让常用的衣服更容易找到

### 1.2 为什么需要折叠功能



**🎯 核心价值**：
- **提升专注度**：隐藏无关内容，专注当前工作区域
- **提高效率**：快速浏览文件结构，减少滚动翻页
- **代码导航**：像IDE一样折叠函数、类、配置块
- **文档整理**：长文档按章节折叠，便于查看大纲

**📊 使用场景对比**：
| 场景类型 | **传统方式** | **使用折叠** |
|---------|------------|-------------|
| 🔧 **调试代码** | `滚动查找，容易迷失` | `折叠无关函数，专注bug区域` |
| 📄 **查看配置** | `配置项太多眼花缭乱` | `按模块折叠，结构清晰` |
| 📝 **编写文档** | `章节混乱，难以把控全局` | `按章节折叠，大纲式阅读` |
| 🔍 **代码审查** | `代码太长，上下文丢失` | `折叠已审查部分，逐步推进` |

---

## 2. ⚙️ 折叠方法设置



### 2.1 :set foldmethod 命令详解



**🔸 基本语法**：
`:set foldmethod=方法名` 或简写 `:set fdm=方法名`

**📋 六种折叠方法对比**：

| 方法名 | **适用场景** | **折叠依据** | **使用难度** |
|-------|------------|-------------|-------------|
| 🎯 **manual** | `手动精确控制` | `用户手动创建` | `⭐⭐⭐☆☆` |
| 📐 **indent** | `Python、YAML等缩进语言` | `代码缩进层次` | `⭐⭐☆☆☆` |
| 🔧 **syntax** | `C、Java等语法结构化语言` | `语法关键字` | `⭐⭐☆☆☆` |
| 📄 **marker** | `配置文件、文档` | `特殊标记符` | `⭐⭐⭐☆☆` |
| 📊 **expr** | `自定义复杂规则` | `表达式计算` | `⭐⭐⭐⭐⭐` |
| 🔄 **diff** | `比较文件差异` | `差异块` | `⭐⭐☆☆☆` |

### 2.2 最常用的三种方法详解



**🔸 缩进折叠（indent）**：
```bash
:set foldmethod=indent
```

**工作原理**：
```
级别0（无缩进）
    级别1（4空格缩进）
        级别2（8空格缩进）
            级别3（12空格缩进）
```

> **🏠 生活类比**：像书的目录结构，大章节包含小章节，小章节包含具体内容

**💡 适用文件类型**：Python、YAML、JSON、Makefile

**🔸 语法折叠（syntax）**：
```bash
:set foldmethod=syntax
```

**工作原理**：
根据编程语言的语法结构自动识别可折叠区域
```
函数定义 function() {     ← 可折叠开始
    代码内容...
}                        ← 可折叠结束

类定义 class Name {      ← 可折叠开始  
    方法和属性...
}                        ← 可折叠结束
```

**💡 适用文件类型**：C/C++、Java、JavaScript、PHP

**🔸 手动折叠（manual）**：
```bash
:set foldmethod=manual
```

**特点**：完全由用户控制，最灵活但需要手动管理

---

## 3. ✂️ 折叠的创建与删除



### 3.1 zf 创建折叠命令



**🔸 基本用法**：
`zf` + `移动命令` = 创建从当前位置到移动命令结束位置的折叠

**📋 常用创建折叠组合**：

| 命令 | **作用** | **使用场景** |
|------|---------|-------------|
| `zf5j` | `创建当前行向下5行的折叠` | `折叠一个函数` |
| `zf}` | `创建到下一个段落的折叠` | `折叠一个代码块` |
| `zfG` | `创建到文件末尾的折叠` | `折叠文件后半部分` |
| `zf'a` | `创建到标记a的折叠` | `折叠预定义区域` |

**🧪 实践演示**：
假设有以下Python代码：
```python
def calculate_sum(numbers):          ← 光标在这里
    """计算数字列表的总和"""
    total = 0
    for num in numbers:
        total += num
    return total                     ← 想折叠到这里

def print_result(result):
    print(f"结果是: {result}")
```

**操作步骤**：
1. 将光标移到函数开始行
2. 输入 `zf5j` （创建6行折叠）
3. 效果：函数被折叠成一行显示

### 3.2 可视模式创建折叠



**🎯 更直观的方法**：
1. `V` 进入行可视模式
2. 选择要折叠的行范围
3. `zf` 创建折叠

> **💡 记忆技巧**：`zf` = **z**折叠 + **f**创建(**f**old)

### 3.3 zd 删除折叠命令



**🔸 删除命令对比**：

| 命令 | **作用** | **影响范围** |
|------|---------|-------------|
| `zd` | `删除当前折叠` | `只删除光标所在折叠` |
| `zD` | `递归删除折叠` | `删除嵌套的所有子折叠` |
| `zE` | `删除所有折叠` | `清空全文件折叠` |

**⚠️ 重要提醒**：
删除折叠不会删除文本内容，只是取消折叠状态，文本仍然完整保留

---

## 4. 👁️ 折叠的打开与关闭



### 4.1 单个折叠操作



**🔸 基本开关命令**：

```
zo = 打开(Open)当前折叠        zc = 关闭(Close)当前折叠
za = 切换(toggle)折叠状态     zv = 查看(View)确保光标行可见
```

**💡 记忆口诀**：
- **zo**：**o**pen 打开，想象眼睛睁开👁️
- **zc**：**c**lose 关闭，想象眼睛闭上
- **za**：**a**lternative 切换，一键开关很方便

### 4.2 递归操作（处理嵌套折叠）



**🔸 大写命令 = 递归操作**：

| 命令 | **作用** | **应用场景** |
|------|---------|-------------|
| `zO` | `递归打开所有层级` | `查看复杂嵌套结构` |
| `zC` | `递归关闭所有层级` | `完全收纳嵌套折叠` |
| `zA` | `递归切换状态` | `智能处理多层嵌套` |

**📊 嵌套折叠示例**：
```
+ 类定义 (折叠级别1)
  + 构造函数 (折叠级别2)
    + 参数验证 (折叠级别3)
    + 属性初始化 (折叠级别3)
  + 公共方法 (折叠级别2)
  + 私有方法 (折叠级别2)
```

### 4.3 全局折叠操作



**🌍 全文档折叠控制**：

| 命令 | **作用** | **使用时机** |
|------|---------|-------------|
| `zR` | `打开**所有**折叠` | `查看完整文档` |
| `zM` | `关闭**所有**折叠` | `查看文档大纲` |
| `zr` | `减少折叠级别（展开一层）` | `逐层展开查看` |
| `zm` | `增加折叠级别（收起一层）` | `逐层收起整理` |

**🎯 实用技巧**：
- 打开长文件时先用 `zM` 折叠全部，查看整体结构
- 找到感兴趣的部分后用 `zR` 展开，开始详细阅读

---

## 5. 🧭 折叠间的移动操作



### 5.1 折叠跳转命令



**🔸 基本移动命令**：

```
zj = 跳转到下一个折叠开始       zk = 跳转到上一个折叠开始
]z = 移动到当前折叠结束        [z = 移动到当前折叠开始
```

**📍 移动路径图示**：
```
文件开始
├─ [第1个折叠开始] ← zk移动到这里
│   ├─ 折叠内容...
│   └─ [第1个折叠结束] ← ]z移动到这里
├─ 普通文本
├─ [第2个折叠开始] ← 当前位置，[z移动到这里
│   ├─ 折叠内容...
│   └─ [第2个折叠结束] ← ]z移动到这里
├─ [第3个折叠开始] ← zj移动到这里
│   └─ ...
文件结尾
```

### 5.2 快速导航技巧



**🎯 高效浏览长文档**：
1. `zM` - 先关闭所有折叠，查看文档大纲
2. `zj` - 跳转到感兴趣的章节
3. `zo` - 展开当前章节内容  
4. 阅读完毕后 `zc` - 重新折叠
5. `zj` - 继续到下一章节

**💡 记忆技巧**：
- `zj/zk`：像普通的`j/k`移动，但专门针对折叠
- `[z/]z`：方括号表示边界，跳到折叠的开始/结束边界

---

## 6. 💾 折叠的保存与恢复



### 6.1 为什么需要保存折叠



**🤔 常见困扰**：
退出Vim后重新打开文件，之前辛苦创建的折叠全部消失了！

**💡 解决方案**：
使用Vim的视图保存功能（view），把折叠状态持久化保存

### 6.2 手动保存与恢复



**🔸 基本命令**：
```bash
:mkview      # 保存当前文件的视图（包括折叠状态）
:loadview    # 恢复之前保存的视图
```

**📋 完整操作流程**：
1. 设置好折叠后，输入 `:mkview`
2. 退出Vim：`:q`
3. 重新打开文件：`vim filename`
4. 恢复折叠状态：`:loadview`

### 6.3 自动保存折叠（推荐设置）



**🔧 在.vimrc中添加配置**：
```bash
" 自动保存和恢复折叠
autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent loadview
```

**配置说明**：
- `BufWinLeave`：窗口关闭时自动保存视图
- `BufWinEnter`：窗口打开时自动恢复视图  
- `silent`：静默执行，不显示错误信息

**✅ 配置后的体验**：
无需手动操作，折叠状态会在文件关闭和打开时自动保持！

---

## 7. 🚀 折叠在长文件中的实际应用



### 7.1 配置文件管理



**📄 场景：管理nginx.conf配置文件**

**传统方式的问题**：
- 配置文件动辄几百行
- 不同模块混杂在一起
- 查找特定配置困难

**使用折叠的解决方案**：
```bash
# 设置基于标记的折叠

:set foldmethod=marker

# 在配置文件中添加折叠标记

# {{{ HTTP核心模块配置

http {
    include mime.types;
    default_type application/octet-stream;
#    # 相关配置...
}
# }}}


# {{{ 虚拟主机配置  

server {
    listen 80;
    server_name example.com;
#    # 相关配置...
}
# }}}

```

**效果对比**：
```
折叠前：                   折叠后：
# HTTP核心模块配置         +-- 15 lines: HTTP核心模块配置 ----

http {                    +-- 25 lines: 虚拟主机配置 ----
  include mime.types;     +-- 10 lines: SSL配置 ----
  default_type...         +-- 8 lines: 日志配置 ----
#  # 20多行配置
}
# 虚拟主机配置

server {
#  # 30多行配置  
}
```

### 7.2 代码项目文件浏览



**🔧 场景：查看大型Python项目**

**设置语法折叠**：
```bash
:set foldmethod=syntax
:set foldlevel=1    # 只显示最外层结构
```

**实际效果**：
```python
+-- 5 lines: import statements ----
+-- 12 lines: class DatabaseManager ----  
+-- 8 lines: class UserService ----
+-- 15 lines: class EmailService ----  
+-- 6 lines: main function ----
```

**🎯 工作流程**：
1. 打开文件后立即看到整体结构
2. `zj`跳转到需要修改的类
3. `zo`展开具体实现
4. 修改完成后`zc`重新折叠
5. 继续到下一个需要修改的部分

### 7.3 文档写作与阅读



**📝 场景：技术文档编写**

**按章节折叠示例**：
```markdown
# 系统安装指南


# 1. 准备工作        ← 折叠点1


## 1.1 硬件要求


## 1.2 软件依赖


## 1.3 网络配置



# 2. 安装过程        ← 折叠点2  


## 2.1 下载镜像


## 2.2 制作启动盘


## 2.3 安装系统



# 3. 后续配置        ← 折叠点3


## 3.1 用户配置


## 3.2 网络配置


```

**📊 文档管理策略**：

| 写作阶段 | **折叠策略** | **目的** |
|---------|------------|---------|
| 🎯 **大纲规划** | `zM关闭所有` | `专注整体结构设计` |
| ✍️ **具体写作** | `折叠无关章节` | `专注当前章节内容` |
| 🔍 **全文检查** | `zR展开所有` | `检查内容完整性` |
| 📖 **阅读分享** | `按需展开折叠` | `引导读者渐进理解` |

---

## 8. 📋 核心要点总结



### 8.1 必须掌握的基本操作



**🔸 核心命令记忆**：
```
设置: :set foldmethod=方法名
创建: zf + 移动命令
删除: zd(单个) zE(全部)
开关: zo(打开) zc(关闭) za(切换)
全局: zR(全开) zM(全关)
移动: zj(下一个) zk(上一个)
保存: :mkview 恢复: :loadview
```

### 8.2 三种最实用的折叠方法



| 方法 | **最佳使用场景** | **设置命令** |
|------|----------------|-------------|
| 📐 **indent** | `Python、YAML、配置文件` | `:set fdm=indent` |
| 🔧 **syntax** | `C/Java/JS等结构化语言` | `:set fdm=syntax` |
| 📄 **manual** | `需要精确控制的场景` | `:set fdm=manual` |

### 8.3 高效使用技巧



**🎯 最佳实践工作流**：
```
1. 打开长文件 → zM(查看大纲)
2. 定位目标区域 → zj/zk(跳转折叠)  
3. 展开工作区域 → zo(展开当前)
4. 完成工作 → zc(重新折叠)
5. 保存折叠状态 → :mkview(持久化)
```

**💡 记忆强化技巧**：
- **z系列命令**：z是折叠操作的标识前缀
- **小写=单个，大写=递归**：zo vs zO, zc vs zC
- **字母含义**：o=open, c=close, f=fold, d=delete
- **方向移动**：j=下, k=上, [=开始, ]=结束

**🚀 进阶应用场景**：
- **代码审查**：折叠已审查函数，专注待审查部分
- **学习源码**：折叠复杂实现，先理解整体架构
- **调试程序**：折叠正常函数，专注问题区域  
- **文档编写**：大纲式组织，渐进式展开内容

**⚠️ 常见注意事项**：
- 折叠不会改变文件内容，只影响显示
- 不同的`foldmethod`不能同时使用
- 建议在`.vimrc`中设置自动保存折叠状态
- 练习时从简单的`indent`方法开始

**🎭 实际价值**：
掌握折叠功能后，处理长文件的效率会显著提升，特别是在代码开发、配置管理、文档编写等场景中，能够保持思路清晰，专注核心任务，这正是专业开发者和系统管理员必备的技能之一。