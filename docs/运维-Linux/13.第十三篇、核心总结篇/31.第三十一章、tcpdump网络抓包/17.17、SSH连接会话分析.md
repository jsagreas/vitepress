---
title: 17、SSH连接会话分析
---
## 📚 目录

1. [SSH协议基础概述](#1-SSH协议基础概述)
2. [SSH握手过程观察](#2-SSH握手过程观察)
3. [加密算法协商分析](#3-加密算法协商分析)
4. [用户认证阶段监控](#4-用户认证阶段监控)
5. [会话建立过程跟踪](#5-会话建立过程跟踪)
6. [数据传输特征识别](#6-数据传输特征识别)
7. [连接保活机制观察](#7-连接保活机制观察)
8. [端口转发识别技巧](#8-端口转发识别技巧)
9. [安全连接监控实战](#9-安全连接监控实战)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔐 SSH协议基础概述


### 1.1 SSH是什么


**简单理解**：SSH就像是网络世界里的"保险箱传送带"

```
普通网络连接：
用户 --明文数据--> 服务器
❌ 任何人都能看到传输的内容

SSH安全连接：  
用户 --加密通道--> 服务器
✅ 数据被加密保护，无法窃听
```

**SSH的核心作用**：
- 🔒 **安全远程登录**：替代不安全的telnet
- 🛡️ **数据加密传输**：防止网络窃听
- 🔑 **身份认证**：确保连接到正确的服务器
- 📁 **文件传输**：scp、sftp等安全文件传输

### 1.2 SSH工作在哪一层


```
网络分层模型：
┌─────────────────┐
│   应用层        │ ← SSH协议在这里
├─────────────────┤
│   传输层        │ ← 使用TCP作为底层传输
├─────────────────┤
│   网络层        │ ← IP协议
├─────────────────┤
│   数据链路层    │ ← 以太网帧
└─────────────────┘

默认端口：22
协议类型：TCP
```

### 1.3 为什么要用tcpdump分析SSH


**实际应用场景**：
- 🔍 **故障排查**：SSH连接失败时定位问题
- 📊 **性能分析**：连接建立时间、数据传输效率
- 🛡️ **安全监控**：检测异常SSH连接行为
- 📚 **学习理解**：直观观察SSH协议工作过程

---

## 2. 🤝 SSH握手过程观察


### 2.1 SSH连接的完整流程


**SSH连接就像两个人见面的过程**：

```
第1步：打招呼（版本协商）
客户端 --> "我支持SSH-2.0" --> 服务器
客户端 <-- "我也支持SSH-2.0" <-- 服务器

第2步：商量加密方式（算法协商）  
客户端 --> "我会这些加密方法..." --> 服务器
客户端 <-- "我们用这种方法" <-- 服务器

第3步：建立安全通道（密钥交换）
客户端 <-- --> 服务器
     创建共同的加密密钥

第4步：验证身份（用户认证）
客户端 --> "用户名+密码" --> 服务器
客户端 <-- "认证通过" <-- 服务器

第5步：开始安全通信（会话建立）
```

### 2.2 tcpdump抓取SSH握手


**基础抓包命令**：
```bash
# 抓取SSH连接的完整过程
tcpdump -i any -nn -s 0 port 22

# 更详细的抓包（包含时间戳）
tcpdump -i any -nn -s 0 -t port 22

# 保存到文件供后续分析
tcpdump -i any -nn -s 0 port 22 -w ssh_session.pcap
```

### 2.3 版本协商阶段分析


**实际抓包输出示例**：
```
# 客户端发起连接
14:30:15.123456 192.168.1.100.45678 > 192.168.1.10.22: Flags [S]
# TCP三次握手建立

14:30:15.125432 192.168.1.10.22 > 192.168.1.100.45678: Flags [S.]
14:30:15.125445 192.168.1.100.45678 > 192.168.1.10.22: Flags [.]

# SSH版本协商开始
14:30:15.126789 192.168.1.10.22 > 192.168.1.100.45678: length 41
# 服务器发送：SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5

14:30:15.127234 192.168.1.100.45678 > 192.168.1.10.22: length 40  
# 客户端回应：SSH-2.0-OpenSSH_8.0p1
```

**如何读懂这些信息**：
- `192.168.1.100.45678` → 客户端IP和随机端口
- `192.168.1.10.22` → 服务器IP和SSH标准端口22
- `length 41` → 数据包大小
- **第一个包总是服务器发送版本信息**

### 2.4 握手过程的关键特征


**正常握手的标志**：
```
✅ 特征识别：
• TCP三次握手成功（SYN → SYN-ACK → ACK）
• 服务器主动发送SSH版本字符串
• 客户端回应自己的版本信息
• 版本兼容性检查通过
• 进入算法协商阶段

⚠️ 异常情况：
• TCP连接失败：网络不通或端口关闭
• 版本不兼容：客户端和服务器SSH版本冲突  
• 连接被重置：防火墙阻断或服务异常
```

---

## 3. 🔐 加密算法协商分析


### 3.1 算法协商是什么


**通俗解释**：就像两个人商量用哪种"暗号"来对话

```
客户端能力清单：
"我会这些加密方法：AES-256, AES-128, 3DES..."
"我会这些认证方法：RSA, ECDSA, ED25519..."
"我会这些压缩方法：zlib, none..."

服务器选择：
"好的，我们用AES-256加密，RSA认证，不压缩"
```

### 3.2 tcpdump中的协商过程


**抓包特征识别**：
```bash
# 专门抓取协商阶段的大数据包
tcpdump -i any -nn -s 0 port 22 and greater 100

# 输出示例：
14:30:15.128456 192.168.1.100.45678 > 192.168.1.10.22: length 1420
# 客户端发送算法列表（通常是个大包）

14:30:15.129123 192.168.1.10.22 > 192.168.1.100.45678: length 685
# 服务器发送算法列表和选择结果
```

**数据包大小特征**：
- **版本协商**：40-50字节（小包）
- **算法协商**：500-1500字节（大包）
- **密钥交换**：300-800字节（中包）

### 3.3 常见的加密算法组合


**现代SSH常用组合**：

| 🔐 **加密算法** | 🔑 **密钥交换** | ✍️ **签名算法** | 📊 **用途说明** |
|----------------|----------------|----------------|----------------|
| `aes256-ctr` | `ecdh-sha2-nistp256` | `ecdsa-sha2-nistp256` | `现代推荐组合` |
| `aes128-ctr` | `diffie-hellman-group14-sha256` | `rsa-sha2-256` | `传统兼容组合` |
| `chacha20-poly1305` | `curve25519-sha256` | `ed25519` | `高安全性组合` |

**如何判断协商结果**：
- 🔍 **看数据包大小**：大包通常是算法列表
- 📊 **看时序**：客户端先发，服务器后发
- ⏱️ **看时间间隔**：协商通常很快完成（几毫秒）

---

## 4. 🎯 用户认证阶段监控


### 4.1 认证阶段的特点


**认证就像门卫检查身份证**：

```
密码认证流程：
用户 --> "我是admin，密码是123456" --> 服务器
用户 <-- "身份验证通过，请进入" <-- 服务器

公钥认证流程：
用户 --> "我是admin，这是我的公钥签名" --> 服务器  
用户 <-- "签名验证通过，欢迎登录" <-- 服务器
```

### 4.2 认证方式识别技巧


**不同认证方式的网络特征**：

```
密码认证特征：
• 数据包相对较小（100-300字节）
• 交互次数少（2-4个包）
• 失败时会有重试行为

公钥认证特征：
• 第一次有大数据包（发送公钥，1000+字节）
• 后续认证包较小（签名验证）
• 成功率通常较高

多因子认证特征：
• 认证过程包数较多
• 会有额外的交互轮次
• 包含令牌或验证码交换
```

### 4.3 认证失败的识别


**tcpdump中看到的失败模式**：

```bash
# 抓取认证阶段
tcpdump -i any -nn -s 0 port 22 and host 192.168.1.100

# 认证失败的典型模式：
14:30:15.234567 客户端 > 服务器: length 156  # 发送认证信息
14:30:15.235123 服务器 > 客户端: length 68   # 认证失败响应
14:30:15.235890 客户端 > 服务器: length 156  # 重试认证
14:30:15.236456 服务器 > 客户端: length 68   # 再次失败
```

**失败特征判断**：
- 🔄 **重复模式**：相似大小的包重复出现
- ⏱️ **时间间隔**：失败后通常有短暂延迟
- 📏 **包大小**：失败响应包通常较小
- 🔚 **连接结束**：多次失败后连接被断开

### 4.4 暴力破解检测


**暴力破解的网络特征**：

> 💡 **识别要点**：短时间内大量的认证尝试

```
正常登录：
14:30:15.123 连接建立
14:30:15.456 认证成功
14:30:15.789 开始会话

暴力破解：
14:30:10.123 连接1 - 认证失败
14:30:10.234 连接2 - 认证失败  
14:30:10.345 连接3 - 认证失败
14:30:10.456 连接4 - 认证失败
...（持续大量尝试）
```

**监控命令示例**：
```bash
# 监控短时间内的大量SSH连接
tcpdump -i any -nn -c 100 port 22 | grep -E "\.S"

# 统计连接频率
tcpdump -i any -nn port 22 | awk '{print $3}' | sort | uniq -c
```

---

## 5. 🚀 会话建立过程跟踪


### 5.1 会话建立是什么


**通俗理解**：认证成功后，建立真正的工作环境

```
会话建立过程：
认证成功 → 请求shell → 分配终端 → 设置环境变量 → 开始交互

就像：
通过门禁 → 申请办公室 → 分配座位 → 摆放用品 → 开始工作
```

### 5.2 会话建立的网络特征


**tcpdump中的典型模式**：

```
认证成功后的包序列：
14:30:15.456789 客户端 > 服务器: length 44   # 请求shell服务
14:30:15.457123 服务器 > 客户端: length 28   # 确认请求
14:30:15.457456 客户端 > 服务器: length 52   # 终端配置请求
14:30:15.457789 服务器 > 客户端: length 36   # 终端配置确认
14:30:15.458123 服务器 > 客户端: length 128  # 发送shell提示符
```

**关键特征识别**：
- 📦 **包大小规律**：中小包为主（50-200字节）
- 🔄 **交互模式**：一问一答的请求-响应模式
- ⏱️ **时间特征**：连续快速的包交换
- 📊 **数据流向**：双向频繁交互

### 5.3 不同会话类型的特征


**Shell会话特征**：
```
特征：交互式命令执行
包特点：小包频繁，双向交互
数据模式：命令（小包）→ 输出（可能大包）

示例识别：
14:30:20.123 客户端 > 服务器: length 8   # "ls -la" 命令
14:30:20.234 服务器 > 客户端: length 1024 # 目录列表输出
```

**文件传输会话特征**：
```
特征：scp/sftp文件传输
包特点：大包连续，单向居多  
数据模式：持续的大数据包流

示例识别：
14:30:25.123 客户端 > 服务器: length 1460 # 文件数据块1
14:30:25.124 客户端 > 服务器: length 1460 # 文件数据块2
14:30:25.125 客户端 > 服务器: length 1460 # 文件数据块3
```

**端口转发会话特征**：
```
特征：隧道代理数据
包特点：大小不定，模式复杂
数据模式：取决于被代理的协议

示例识别：
14:30:30.123 客户端 > 服务器: length 523  # HTTP请求数据
14:30:30.234 服务器 > 客户端: length 2048 # HTTP响应数据
```

---

## 6. 📊 数据传输特征识别


### 6.1 SSH数据传输的基本特点


**加密后的数据特征**：
```
原始数据：echo "hello world"
加密后特征：
• 数据长度：总是16字节的倍数（块加密）
• 数据内容：完全随机，无法识别原始内容
• 包头信息：仍然可见（IP、TCP信息）
```

### 6.2 交互式会话的流量模式


**命令执行的典型模式**：

```bash
# 监控SSH会话的交互模式
tcpdump -i any -nn -s 0 port 22 and host 192.168.1.100

# 典型的命令执行模式：
时间戳              方向          大小    说明
14:30:15.123  客户端→服务器   52   输入命令
14:30:15.456  服务器→客户端   1024  命令输出
14:30:15.789  客户端→服务器   48   下一个命令
```

**不同命令类型的特征**：

| 📝 **命令类型** | 📏 **输入包大小** | 📤 **输出包大小** | ⏱️ **响应时间** |
|----------------|-----------------|-----------------|---------------|
| `ls` | 40-60字节 | 200-2000字节 | 几毫秒 |
| `cat 大文件` | 40-80字节 | 多个1460字节包 | 较长 |
| `top` | 40-60字节 | 持续的中等包 | 持续更新 |
| `vim` | 40-60字节 | 不规律的小中包 | 交互式 |

### 6.3 文件传输的流量特征


**scp传输模式识别**：
```
文件上传特征：
客户端→服务器：持续的大包流（1460字节居多）
服务器→客户端：偶尔的小确认包

文件下载特征：
服务器→客户端：持续的大包流
客户端→服务器：偶尔的小确认包
```

**传输速度计算技巧**：
```bash
# 实时监控SSH传输速度
tcpdump -i any -nn -l port 22 | \
awk '{sum+=$NF} END{print "Total bytes:", sum}'

# 或者使用更直观的方法
iftop -i any -f "port 22"
```

### 6.4 异常流量识别


**可疑传输模式**：

> ⚠️ **安全提醒**：这些模式可能表示异常行为

```
数据泄露特征：
• 大量数据持续外发
• 非工作时间的大流量传输
• 单向大数据流（只出不进）

后门通信特征：
• 定期的小包通信
• 不规律的连接时间
• 加密隧道内的可疑流量模式
```

---

## 7. 💓 连接保活机制观察


### 7.1 什么是SSH保活


**生活化理解**：就像定期发"我还在"的消息

```
保活机制的作用：
问题：长时间不活动，网络设备可能断开连接
解决：定期发送小数据包，证明连接还活着

类比：
酒店房间 → SSH连接
定期回房间 → 定期发保活包  
否则被清理 → 否则连接被断开
```

### 7.2 保活包的网络特征


**tcpdump中的保活模式**：
```
# 典型的保活包模式
14:30:00.000 客户端 > 服务器: length 0, ack 1
14:30:30.000 客户端 > 服务器: length 0, ack 1  
14:31:00.000 客户端 > 服务器: length 0, ack 1
...（每30秒一次）

特征识别：
• 固定的时间间隔（通常30-60秒）
• 很小的数据包（通常0-50字节）
• 单向发送（通常客户端发起）
```

### 7.3 不同保活机制对比


**TCP层保活 vs SSH层保活**：

```
TCP KeepAlive：
14:30:00.000 [TCP Keep-Alive] length 0
特点：TCP协议层面，系统自动处理

SSH KeepAlive：  
14:30:00.000 [SSH Keep-Alive] length 48
特点：SSH协议层面，应用程序处理
```

**保活配置的影响**：

| ⚙️ **配置项** | 🔢 **默认值** | 📊 **网络表现** | 💡 **用途说明** |
|-------------|-------------|---------------|---------------|
| `ServerAliveInterval` | 0 (关闭) | 客户端定期发包 | 防止客户端超时 |
| `ClientAliveInterval` | 0 (关闭) | 服务器定期发包 | 防止服务器超时 |
| `TCPKeepAlive` | yes | TCP层面保活 | 网络层面维持连接 |

### 7.4 保活失败的识别


**连接断开的模式**：
```
保活失败序列：
14:30:00.000 客户端 > 服务器: Keep-Alive
14:30:30.000 客户端 > 服务器: Keep-Alive  
14:31:00.000 客户端 > 服务器: Keep-Alive
...（无响应）
14:32:00.000 客户端 > 服务器: RST (连接重置)

异常特征：
• 保活包无响应
• 重传次数增加  
• 最终连接重置或超时
```

---

## 8. 🔀 端口转发识别技巧


### 8.1 SSH端口转发原理


**端口转发就像"网络传送门"**：

```
本地端口转发（-L）：
本地应用 → SSH客户端 → SSH服务器 → 目标服务

远程端口转发（-R）：
目标客户端 → SSH服务器 → SSH客户端 → 本地服务

动态端口转发（-D）：
任意应用 → SSH客户端(SOCKS代理) → SSH服务器 → 任意目标
```

### 8.2 端口转发的网络识别


**本地端口转发特征**：
```bash
# 建立本地转发
ssh -L 8080:target-server:80 user@ssh-server

# tcpdump观察到的模式：
# 1. 正常SSH连接建立
# 2. 额外的端口转发协商
14:30:15.123 客户端 > 服务器: length 64  # 转发请求
14:30:15.234 服务器 > 客户端: length 32  # 转发确认

# 3. 数据转发阶段  
14:30:20.123 客户端 > 服务器: length 1024 # 转发的HTTP请求
14:30:20.234 服务器 > 客户端: length 2048 # 转发的HTTP响应
```

**识别要点**：
- 🔍 **建立阶段**：比普通SSH多了转发协商包
- 📊 **流量模式**：包含被代理协议的特征
- 🔄 **双向特征**：数据双向转发，非交互式

### 8.3 动态端口转发（SOCKS代理）


**SOCKS代理的特殊性**：
```bash
# 建立SOCKS代理
ssh -D 1080 user@ssh-server

# 网络特征识别：
• 初始连接：标准SSH建立过程
• 协商阶段：SOCKS协议协商包
• 数据传输：混合了多种协议的流量
```

**SOCKS流量的复杂性**：
```
混合流量示例：
14:30:15.123 HTTP流量    (浏览器访问网站)
14:30:15.234 SMTP流量    (邮件收发)  
14:30:15.345 DNS查询流量  (域名解析)
...所有这些都通过一个SSH连接传输
```

### 8.4 端口转发的安全监控


**可疑端口转发识别**：

> 🛡️ **安全要点**：端口转发可能被用于绕过防火墙

```
正常使用模式：
• 工作时间建立连接
• 转发特定业务端口
• 流量模式相对规律

可疑使用模式：  
• 非工作时间大量转发
• 转发敏感端口（22, 3389等）
• 大量随机端口转发
• 流量模式异常复杂
```

**监控技巧**：
```bash
# 监控可疑的端口转发
tcpdump -i any -nn port 22 | grep -v ":22"

# 分析连接的复杂度
netstat -tn | grep :22 | wc -l
```

---

## 9. 🔒 安全连接监控实战


### 9.1 建立SSH监控体系


**监控目标分层**：

```
网络层监控：
├── 连接建立频率
├── 连接来源分析  
├── 失败连接统计
└── 流量异常检测

协议层监控：
├── 版本协商异常
├── 算法选择分析
├── 认证失败模式
└── 会话行为分析

应用层监控：
├── 命令执行审计
├── 文件传输监控
├── 端口转发检测
└── 异常行为告警
```

### 9.2 实用监控脚本


**连接监控脚本**：
```bash
#!/bin/bash
# SSH连接实时监控

echo "开始监控SSH连接..."
tcpdump -i any -nn -l port 22 | while read line; do
    # 解析连接信息
    time=$(echo $line | awk '{print $1}')
    src=$(echo $line | awk '{print $3}')
    dst=$(echo $line | awk '{print $5}')
    
    # 识别连接类型
    if [[ $line == *"Flags [S]"* ]]; then
        echo "[$time] 新连接: $src -> $dst"
    elif [[ $line == *"Flags [R]"* ]]; then  
        echo "[$time] 连接重置: $src -> $dst"
    fi
done
```

**异常检测逻辑**：
```bash
# 检测暴力破解
#!/bin/bash
tcpdump -i any -nn -c 1000 port 22 | \
awk '/Flags \[S\]/ {src=$3; gsub(/\.[0-9]+$/, "", src); count[src]++} 
     END {for(ip in count) if(count[ip] > 10) print ip, count[ip]}' 
```

### 9.3 常见安全事件识别


**暴力破解检测**：
```
特征模式：
• 短时间大量SYN包
• 来源IP相同，目标端口22
• 连接快速建立又断开
• 认证阶段包模式重复

识别命令：
tcpdump -i any -nn port 22 | \
grep -E "Flags \[S\]" | \
awk '{print $3}' | cut -d. -f1-4 | sort | uniq -c | sort -nr
```

**异常隧道检测**：
```
可疑特征：
• 长期保持的连接  
• 大量非交互式流量
• 不规律的包大小模式
• 数据流向异常

检测思路：
1. 统计连接持续时间
2. 分析流量模式
3. 识别非人工交互特征
```

### 9.4 监控告警机制


**告警触发条件**：

| 🚨 **告警类型** | 📊 **触发条件** | 🎯 **检测方法** | ⚡ **响应建议** |
|---------------|---------------|---------------|---------------|
| 暴力破解 | 1分钟内超过20次连接 | 统计SYN包频率 | 封禁来源IP |
| 异常登录 | 非办公时间大量连接 | 时间+频率分析 | 人工确认 |
| 数据泄露 | 单向大流量传输 | 流量方向+大小分析 | 断开连接调查 |
| 隧道滥用 | 长连接+复杂流量 | 连接时长+模式分析 | 审查用途 |

**告警实现示例**：
```bash
#!/bin/bash
# 简单的SSH告警系统

THRESHOLD=20  # 告警阈值
TIME_WINDOW=60 # 时间窗口（秒）

while true; do
    # 统计最近1分钟的连接数
    connections=$(tcpdump -i any -nn -c 100 port 22 2>/dev/null | \
                 grep "Flags \[S\]" | wc -l)
    
    if [ $connections -gt $THRESHOLD ]; then
        echo "告警：检测到暴力破解尝试，连接数：$connections"
        # 这里可以添加邮件通知、微信告警等
    fi
    
    sleep $TIME_WINDOW
done
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的关键概念


```
🔸 SSH连接过程：版本协商 → 算法协商 → 密钥交换 → 用户认证 → 会话建立
🔸 抓包识别技巧：根据包大小、时序、方向识别不同阶段
🔸 数据传输特征：加密后无法看内容，但能分析流量模式
🔸 保活机制：定期小包维持连接，防止超时断开
🔸 端口转发识别：额外协商包+混合协议流量特征
🔸 安全监控要点：频率异常、模式异常、行为异常
```

### 10.2 实用技能清单


**✅ 基础技能**：
- [x] 能用tcpdump抓取SSH会话数据
- [x] 能识别SSH连接的不同阶段
- [x] 能分析正常SSH流量的特征
- [x] 能判断连接成功或失败

**🎯 进阶技能**：  
- [x] 能识别不同认证方式的网络特征
- [x] 能检测SSH暴力破解行为
- [x] 能分析端口转发的流量模式
- [x] 能设计简单的监控告警机制

**🚀 专家技能**：
- [x] 能建立完整的SSH安全监控体系
- [x] 能编写自动化分析脚本
- [x] 能识别高级SSH隧道滥用行为
- [x] 能进行SSH流量的深度安全分析

### 10.3 关键命令速查


**🔧 基础抓包命令**：
```bash
# 抓取SSH连接
tcpdump -i any -nn -s 0 port 22

# 抓取特定主机的SSH  
tcpdump -i any -nn port 22 and host 192.168.1.100

# 保存到文件
tcpdump -i any -nn -s 0 port 22 -w ssh.pcap
```

**📊 分析命令**：
```bash
# 统计连接频率
tcpdump -i any -nn port 22 | awk '{print $3}' | cut -d. -f1-4 | sort | uniq -c

# 监控大包（算法协商）
tcpdump -i any -nn port 22 and greater 500

# 实时连接计数
tcpdump -i any -nn -l port 22 | grep -E "Flags \[S\]" | wc -l
```

### 10.4 故障排查思路


**🔍 SSH连接问题诊断流程**：

```
第1步：检查网络连通性
tcpdump -i any -nn port 22 and host [目标IP]
└── 看是否有TCP连接建立

第2步：检查SSH握手过程  
tcpdump -i any -nn -s 0 port 22 and host [目标IP]
└── 看版本协商和算法协商是否成功

第3步：检查认证阶段
分析认证包的大小和重试模式
└── 判断是认证失败还是其他问题

第4步：检查会话建立
观察认证成功后的包交换模式
└── 确认会话是否正常建立
```

### 10.5 安全最佳实践


**🛡️ SSH安全监控建议**：

```
监控策略：
• 建立基线：记录正常SSH使用模式
• 异常检测：识别偏离基线的行为  
• 实时告警：关键安全事件立即通知
• 定期审计：周期性分析SSH使用情况

防护措施：
• 限制来源：只允许可信IP连接SSH
• 强化认证：使用密钥认证代替密码
• 监控日志：结合系统日志和网络抓包
• 及时响应：发现异常立即调查处置
```

### 10.6 学习建议


**📚 进阶学习路径**：
1. **深入SSH协议**：学习RFC文档，理解协议细节
2. **网络安全分析**：学习更多网络协议分析技巧  
3. **自动化工具**：学习Wireshark、tshark等专业工具
4. **脚本编程**：编写更复杂的监控分析脚本
5. **安全运维**：将技能应用到实际安全运维工作

> 💡 **学习要点**：理论结合实践，多做实验，多分析真实流量

**核心记忆口诀**：
- SSH抓包看五步：握手协商认证建立传输
- 包大小有规律：小版本大协商中认证  
- 异常行为三特征：频率模式时间都要看
- 安全监控重实践：告警响应不能缺