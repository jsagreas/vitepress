---
title: 33、awk内置变量详解
---
## 📚 目录

1. [awk变量系统概述](#1-awk变量系统概述)
2. [字段变量详解](#2-字段变量详解)
3. [记录相关变量](#3-记录相关变量)
4. [字段分隔符变量](#4-字段分隔符变量)
5. [输出控制变量](#5-输出控制变量)
6. [文件处理变量](#6-文件处理变量)
7. [子系统变量](#7-子系统变量)
8. [自定义变量规则](#8-自定义变量规则)
9. [变量应用实战](#9-变量应用实战)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 awk变量系统概述


### 1.1 什么是awk内置变量


**💡 简单理解**：内置变量就像awk程序的"控制面板"，里面有各种开关和显示器，告诉你当前处理的状态信息。

```
想象一个文本处理工厂：
┌─────────────────────────┐
│       awk工厂控制室      │
├─────────────────────────┤
│ 🏭 当前行号: NR=156     │
│ 📄 当前字段数: NF=5     │  
│ 📍 当前文件: data.txt   │
│ ⚙️  字段分隔符: FS=,    │
└─────────────────────────┘
```

### 1.2 内置变量的作用


**🔸 自动维护状态**：awk自动更新这些变量，你不用手工计算
**🔸 控制行为**：通过修改某些变量可以改变awk的处理方式  
**🔸 获取信息**：随时了解当前处理到哪里、什么状态

---

## 2. 📝 字段变量详解


### 2.1 $0 - 整行内容


**🔸 核心概念**：`$0` 代表当前处理的整行内容

```bash
# 示例数据：employees.txt
name,age,department,salary
张三,25,技术部,8000
李四,30,市场部,7500
王五,28,人事部,6500
```

**💻 基础用法**：
```bash
# 打印整行内容
awk '{print $0}' employees.txt
# 等价于
awk '{print}' employees.txt

# 输出：
# name,age,department,salary
# 张三,25,技术部,8000
# 李四,30,市场部,7500
# 王五,28,人事部,6500
```

**⚡ 修改整行**：
```bash
# 在每行前加行号
awk '{$0 = NR ". " $0; print}' employees.txt
# 输出：
# 1. name,age,department,salary
# 2. 张三,25,技术部,8000
```

### 2.2 $1, $2, $3... - 各个字段


**🔸 字段编号规律**：从左到右，$1是第一个字段，$2是第二个字段，以此类推

**📊 字段分布示意**：
```
原始行: 张三,25,技术部,8000
         ↓
$0 = "张三,25,技术部,8000"  (整行)
$1 = "张三"                (第1字段)
$2 = "25"                  (第2字段)  
$3 = "技术部"              (第3字段)
$4 = "8000"                (第4字段)
```

**💻 实际应用**：
```bash
# 提取特定字段
awk -F',' '{print $1, $4}' employees.txt
# 输出员工姓名和薪资：
# name salary
# 张三 8000
# 李四 7500

# 修改字段内容
awk -F',' '{$4 = $4 * 1.1; print}' employees.txt
# 给所有薪资涨10%
```

### 2.3 字段的动态特性


**🔄 重要特点**：修改字段会自动重建 `$0`

```bash
# 交换第1和第3字段
awk -F',' '{temp=$1; $1=$3; $3=temp; print}' employees.txt
# 输出：
# department,age,name,salary  
# 技术部,25,张三,8000
```

---

## 3. 📈 记录相关变量


### 3.1 NR - 总记录号


**🔸 含义解释**：**N**umber of **R**ecord，从程序开始到现在总共处理了多少行

**💡 通俗理解**：就像一个永不停歇的计数器，每处理一行就加1

```bash
# 查看行号效果
awk '{print "第" NR "行:", $0}' employees.txt

# 输出：
# 第1行: name,age,department,salary
# 第2行: 张三,25,技术部,8000
# 第3行: 李四,30,市场部,7500
# 第4行: 王五,28,人事部,6500
```

### 3.2 FNR - 当前文件记录号


**🔸 区别理解**：处理多个文件时，FNR会重新计数，NR继续累加

```
处理两个文件的情况：
文件1: data1.txt (3行)    文件2: data2.txt (2行)
├─ 行1: NR=1, FNR=1      ├─ 行1: NR=4, FNR=1
├─ 行2: NR=2, FNR=2      └─ 行2: NR=5, FNR=2  
└─ 行3: NR=3, FNR=3
```

**💻 实际对比**：
```bash
# 同时显示NR和FNR
awk '{print "总行号:" NR, "文件行号:" FNR, "内容:" $0}' file1.txt file2.txt
```

### 3.3 实用场景


**🎯 常见用途**：

| 变量 | **适用场景** | **代码示例** |
|------|-------------|--------------|
| **NR** | `统计总行数` | `END {print "总共" NR "行"}` |
| **NR** | `处理特定行` | `NR==3 {print "第3行:" $0}` |
| **FNR** | `跳过文件标题` | `FNR>1 {print $0}` |
| **FNR** | `多文件处理` | `FNR==1 {print "新文件开始"}` |

---

## 4. 🔧 字段分隔符变量


### 4.1 FS - 输入字段分隔符


**🔸 基本概念**：**F**ield **S**eparator，告诉awk用什么来分割每行的字段

**💡 默认行为**：FS默认是空白字符（空格、制表符）

```bash
# 不同分隔符的处理
echo "a:b:c" | awk -F':' '{print $2}'        # 输出: b
echo "a,b,c" | awk -F',' '{print $2}'        # 输出: b  
echo "a b c" | awk '{print $2}'              # 输出: b (默认空格分隔)
```

### 4.2 FS的灵活设置


**🎨 多种设置方式**：

```bash
# 方式1：命令行设置
awk -F',' '{print $1}' data.csv

# 方式2：程序内设置  
awk 'BEGIN{FS=","} {print $1}' data.csv

# 方式3：正则表达式分隔符
awk 'BEGIN{FS="[,:]"} {print $1, $2}' data.txt  # 逗号或冒号分隔

# 方式4：多字符分隔符
awk 'BEGIN{FS="::"} {print $1}' data.txt        # 双冒号分隔
```

### 4.3 OFS - 输出字段分隔符


**🔸 作用说明**：**O**utput **F**ield **S**eparator，控制输出时字段之间用什么连接

```bash
# 默认OFS是空格
awk -F',' '{print $1, $2}' employees.csv
# 输出: 张三 25

# 自定义OFS
awk -F',' 'BEGIN{OFS=" | "} {print $1, $2, $3}' employees.csv  
# 输出: 张三 | 25 | 技术部
```

**⚡ 重要提醒**：只有用逗号分隔的print才会使用OFS
```bash
awk 'BEGIN{OFS="***"} {print $1, $2}'    # 会用OFS连接
awk 'BEGIN{OFS="***"} {print $1 $2}'     # 直接连接，不用OFS
```

---

## 5. 📤 输出控制变量


### 5.1 RS - 输入记录分隔符


**🔸 基本概念**：**R**ecord **S**eparator，告诉awk什么算作一条"记录"

**💡 默认理解**：RS默认是换行符，也就是一行算一条记录

```bash
# 处理特殊格式的数据
cat > multiline.txt << EOF
姓名:张三
年龄:25
部门:技术部
---
姓名:李四  
年龄:30
部门:市场部
---
EOF

# 用---作为记录分隔符
awk 'BEGIN{RS="---"} {gsub(/\n/, " "); print NR ":", $0}' multiline.txt
```

### 5.2 ORS - 输出记录分隔符


**🔸 控制输出**：**O**utput **R**ecord **S**eparator，每条记录输出后加什么

```bash
# 默认ORS是换行符
awk '{print $1}' data.txt     # 每个结果占一行

# 自定义ORS
awk 'BEGIN{ORS=" | "} {print $1}' data.txt   # 用 | 连接结果
# 输出: 张三 | 李四 | 王五 |
```

### 5.3 实际应用场景


**🎯 格式转换示例**：

```bash
# CSV转为竖直格式
awk -F',' 'BEGIN{OFS="\n"; ORS="\n---\n"} {$1=$1; print}' employees.csv

# JSON风格输出
awk -F',' 'BEGIN{ORS=",\n"} {printf "{\"name\":\"%s\", \"age\":%s}", $1, $2}' data.csv
```

---

## 6. 📁 文件处理变量


### 6.1 FILENAME - 当前文件名


**🔸 用途说明**：处理多文件时，随时知道当前在处理哪个文件

```bash
# 创建测试文件
echo -e "数据1\n数据2" > file1.txt
echo -e "内容A\n内容B" > file2.txt

# 显示文件名
awk '{print FILENAME ":", $0}' file1.txt file2.txt
# 输出：
# file1.txt: 数据1
# file1.txt: 数据2  
# file2.txt: 内容A
# file2.txt: 内容B
```

**💡 实用技巧**：
```bash
# 按文件分组处理
awk '{
    if (FILENAME != last_file) {
        print "=== " FILENAME " ==="
        last_file = FILENAME
    }
    print $0
}' *.txt
```

### 6.2 FNR与FILENAME组合应用


```bash
# 为每个文件的行加上文件特定前缀
awk '{
    prefix = substr(FILENAME, 1, 3)  # 取文件名前3字符作为前缀
    print prefix "-" FNR ": " $0
}' data1.txt data2.txt
```

---

## 7. ⚙️ 子系统变量


### 7.1 SUBSEP - 下标分隔符


**🔸 概念解释**：**SUB**script **SEP**arator，在多维数组中连接索引的符号

**💡 通俗理解**：当你用两个值做数组下标时，awk会用SUBSEP把它们连起来

```bash
# 默认SUBSEP是"\034"(不可见字符)
awk 'BEGIN {
    # 创建二维数组
    arr[1,2] = "值A"
    arr[1,3] = "值B"  
    
    # 查看实际的索引
    for (key in arr) {
        print "索引:", key, "值:", arr[key]
    }
}'
```

**🔧 自定义SUBSEP**：
```bash
awk 'BEGIN {
    SUBSEP = "-"
    arr["张三","技术部"] = 8000
    arr["李四","市场部"] = 7500
    
    for (key in arr) {
        print key ": " arr[key]
    }
}' 
# 输出：
# 张三-技术部: 8000
# 李四-市场部: 7500
```

### 7.2 ENVIRON - 环境变量


**🔸 访问系统环境**：通过ENVIRON数组访问系统环境变量

```bash
# 显示常用环境变量
awk 'BEGIN {
    print "用户:", ENVIRON["USER"]
    print "主目录:", ENVIRON["HOME"]  
    print "路径:", ENVIRON["PATH"]
}'
```

---

## 8. 🎨 自定义变量规则


### 8.1 变量命名规则


**✅ 合法命名**：
- 字母开头：`name`, `count`, `total`
- 下划线开头：`_temp`, `_result`
- 包含数字：`var1`, `data2024`

**❌ 非法命名**：
- 数字开头：`1name`  
- 特殊字符：`var-name`, `data@home`
- 关键字冲突：`if`, `for`, `while`

### 8.2 变量的作用域


**🔸 全局变量**：在任何地方都可以访问
**🔸 局部变量**：函数内部定义，仅函数内有效

```bash
awk '
function process_data(local_var) {
    # local_var是局部变量
    global_count++           # global_count是全局变量
    return local_var * 2
}

BEGIN { global_count = 0 }
{ result = process_data($1); print result }
END { print "处理了", global_count, "条记录" }
'
```

### 8.3 变量的自动类型转换


**💡 awk的智能之处**：变量会根据使用场景自动转换类型

```bash
awk 'BEGIN {
    # 数字操作
    a = "10"
    b = "20"  
    print a + b        # 输出: 30 (自动转为数字)
    
    # 字符串操作
    print a b          # 输出: 1020 (当作字符串连接)
    
    # 比较操作
    print (a < b)      # 输出: 1 (数字比较)
    print (a < "5")    # 输出: 0 (字符串比较)
}'
```

---

## 9. 🚀 变量应用实战


### 9.1 统计分析实例


**📊 统计员工信息**：
```bash
# 员工数据统计
awk -F',' '
BEGIN { 
    print "=== 员工统计分析 ==="
    total_salary = 0
    max_salary = 0
    min_salary = 999999
}

FNR > 1 {  # 跳过标题行
    # 累计统计
    total_salary += $4
    count++
    
    # 找最值
    if ($4 > max_salary) max_salary = $4
    if ($4 < min_salary) min_salary = $4
    
    # 按部门统计
    dept_count[$3]++
    dept_salary[$3] += $4
}

END {
    print "总员工数:", count
    print "平均薪资:", total_salary/count
    print "最高薪资:", max_salary  
    print "最低薪资:", min_salary
    print "\n部门统计:"
    for (dept in dept_count) {
        printf "  %s: %d人, 平均薪资: %.0f\n", 
               dept, dept_count[dept], dept_salary[dept]/dept_count[dept]
    }
}' employees.csv
```

### 9.2 日志分析实例


**📋 Web访问日志分析**：
```bash
# 分析nginx访问日志格式：IP - - [时间] "请求" 状态码 大小
awk '{
    # 提取关键信息
    ip = $1
    status = $9
    size = $10
    
    # 统计计数
    ip_count[ip]++
    status_count[status]++
    total_size += (size ~ /^[0-9]+$/ ? size : 0)
    total_requests++
    
} END {
    print "=== 访问统计 ==="
    print "总请求数:", total_requests
    print "总流量:", total_size, "字节"
    
    print "\n状态码分布:"
    for (code in status_count) {
        printf "  %s: %d (%.1f%%)\n", code, status_count[code], 
               status_count[code]/total_requests*100
    }
    
    print "\nTOP 5 访问IP:"
    # 简单的排序输出前5个IP
    n = asorti(ip_count, sorted_ips)
    for (i = 1; i <= (n > 5 ? 5 : n); i++) {
        printf "  %s: %d次\n", sorted_ips[i], ip_count[sorted_ips[i]]
    }
}' access.log
```

### 9.3 数据清洗实例


**🧹 清洗CSV数据**：
```bash
# 处理包含空值和格式问题的CSV文件
awk -F',' '
BEGIN {
    OFS = ","
    print "姓名,年龄,部门,薪资"  # 输出标题
}

FNR > 1 {
    # 清洗姓名字段：去除空格
    gsub(/^[ \t]+|[ \t]+$/, "", $1)
    
    # 清洗年龄字段：确保是数字
    if ($2 !~ /^[0-9]+$/) $2 = "未知"
    
    # 清洗部门字段：标准化名称
    gsub(/技术/, "研发", $3)
    gsub(/销售/, "市场", $3)
    
    # 清洗薪资字段：移除非数字字符
    gsub(/[^0-9]/, "", $4)
    if ($4 == "") $4 = 0
    
    # 输出清洗后的数据
    print $0
}' messy_data.csv > clean_data.csv
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心变量


```
🔸 字段变量: $0(整行) $1,$2...(各字段) NF(字段总数)
🔸 记录变量: NR(总行号) FNR(文件内行号)  
🔸 分隔符: FS(输入字段分隔) OFS(输出字段分隔) RS/ORS(记录分隔)
🔸 文件变量: FILENAME(当前文件名)
🔸 系统变量: SUBSEP(数组下标分隔) ENVIRON(环境变量)
```

### 10.2 关键理解要点


**🔹 字段与记录的关系**
```
记录 = 一行数据 (由RS分隔)
字段 = 记录内的片段 (由FS分隔)
修改字段会重建$0，这是awk的核心机制
```

**🔹 内置变量的自动维护**
- **NR/FNR**：awk自动计数，你只需要用
- **NF**：awk自动统计字段数
- **FILENAME**：处理多文件时自动更新

**🔹 输入输出分隔符的配对**
- **FS配OFS**：输入用什么分隔，输出就用什么连接
- **RS配ORS**：记录的输入输出分隔符要对应

### 10.3 实际应用技巧


**🎯 常用变量组合**：

| 应用场景 | **变量组合** | **典型用法** |
|---------|-------------|--------------|
| **跳过标题** | `FNR > 1` | `FNR > 1 {处理数据行}` |
| **处理特定行** | `NR == n` | `NR == 10 {print "第10行"}` |
| **多文件处理** | `FILENAME + FNR` | `FNR==1 {print "文件:" FILENAME}` |
| **格式转换** | `FS + OFS` | `BEGIN{FS=","; OFS="|"}` |
| **统计分析** | `NF + NR` | `END{print "平均字段数:" 总字段/NR}` |

**🔧 调试技巧**：
```bash
# 查看所有内置变量的值
awk '{print "NR=" NR, "FNR=" FNR, "NF=" NF, "FILENAME=" FILENAME}' file.txt
```

**💡 性能优化提醒**：
- 避免在热点循环中频繁访问ENVIRON
- 字符串操作优于数值操作性能
- 合理设置FS避免复杂正则表达式

### 10.4 学习进阶路径


1. **掌握基础**：先熟练使用字段变量和NR/FNR
2. **理解分隔符**：掌握FS/OFS的各种设置方法
3. **实战练习**：用实际数据做统计分析
4. **深入应用**：结合数组和函数做复杂数据处理

**核心记忆口诀**：
> *字段美元符，记录NR数*  
> *分隔FS配OFS，文件FILENAME*  
> *内置变量助你行，数据处理更轻松*