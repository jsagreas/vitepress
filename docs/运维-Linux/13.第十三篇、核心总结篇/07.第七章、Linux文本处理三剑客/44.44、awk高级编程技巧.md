---
title: 44ã€awké«˜çº§ç¼–ç¨‹æŠ€å·§
---
## ğŸ“š ç›®å½•

1. [awké«˜çº§ç¼–ç¨‹æ¦‚è¿°](#1-awké«˜çº§ç¼–ç¨‹æ¦‚è¿°)
2. [é€’å½’ç¼–ç¨‹æŠ€æœ¯](#2-é€’å½’ç¼–ç¨‹æŠ€æœ¯)
3. [åŠ¨æ€ç¼–ç¨‹åº”ç”¨](#3-åŠ¨æ€ç¼–ç¨‹åº”ç”¨)
4. [ç®—æ³•å®ç°æŠ€å·§](#4-ç®—æ³•å®ç°æŠ€å·§)
5. [æ•°æ®ç»“æ„æ¨¡æ‹Ÿ](#5-æ•°æ®ç»“æ„æ¨¡æ‹Ÿ)
6. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#6-æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
7. [å†…å­˜ç®¡ç†æœ€ä½³å®è·µ](#7-å†…å­˜ç®¡ç†æœ€ä½³å®è·µ)
8. [å¤æ‚ä¸šåŠ¡é€»è¾‘å¤„ç†](#8-å¤æ‚ä¸šåŠ¡é€»è¾‘å¤„ç†)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸš€ awké«˜çº§ç¼–ç¨‹æ¦‚è¿°


### 1.1 awkçš„ç¼–ç¨‹èƒ½åŠ›


**awkä¸åªæ˜¯æ–‡æœ¬å·¥å…·**ï¼šå¾ˆå¤šäººè®¤ä¸ºawkåªèƒ½åšç®€å•çš„æ–‡æœ¬å¤„ç†ï¼Œå…¶å®å®ƒæ˜¯ä¸€é—¨å®Œæ•´çš„ç¼–ç¨‹è¯­è¨€ã€‚

```
awkçš„ç¼–ç¨‹ç‰¹æ€§ï¼š
âœ… å®Œæ•´çš„å˜é‡ç³»ç»Ÿ       âœ… å‡½æ•°å®šä¹‰å’Œè°ƒç”¨
âœ… æ•°ç»„å’Œå…³è”æ•°ç»„       âœ… æ¡ä»¶åˆ¤æ–­å’Œå¾ªç¯
âœ… æ­£åˆ™è¡¨è¾¾å¼æ”¯æŒ       âœ… æ•°å­¦è®¡ç®—èƒ½åŠ›
âœ… å­—ç¬¦ä¸²å¤„ç†å‡½æ•°       âœ… I/Oæ“ä½œåŠŸèƒ½
```

**ä¸ºä»€ä¹ˆè¦å­¦awké«˜çº§ç¼–ç¨‹**ï¼š
- ğŸ¯ **å®ç”¨æ€§å¼º**ï¼šä¸€è¡Œawkä»£ç å¾€å¾€èƒœè¿‡å‡ åè¡Œå…¶ä»–è„šæœ¬
- ğŸ¯ **å¤„ç†é€Ÿåº¦å¿«**ï¼šå†…ç½®çš„æ–‡æœ¬å¤„ç†ä¼˜åŒ–ï¼Œæ¯”python/perlæ›´å¿«
- ğŸ¯ **éƒ¨ç½²ç®€å•**ï¼šå‡ ä¹æ‰€æœ‰Unix/Linuxç³»ç»Ÿéƒ½å†…ç½®awk
- ğŸ¯ **å­¦ä¹ æˆæœ¬ä½**ï¼šè¯­æ³•ç®€æ´ï¼Œå®¹æ˜“æŒæ¡æ ¸å¿ƒæ¦‚å¿µ

### 1.2 é«˜çº§ç¼–ç¨‹çš„åº”ç”¨åœºæ™¯


**å…¸å‹åº”ç”¨é¢†åŸŸ**ï¼š
```
ğŸ“Š æ•°æ®åˆ†æå¤„ç†ï¼š
  â€¢ æ—¥å¿—æ–‡ä»¶åˆ†æç»Ÿè®¡
  â€¢ CSVæ•°æ®æ¸…æ´—è½¬æ¢  
  â€¢ æŠ¥è¡¨ç”Ÿæˆå’Œè®¡ç®—

ğŸ”§ ç³»ç»Ÿç®¡ç†å·¥å…·ï¼š
  â€¢ é…ç½®æ–‡ä»¶å¤„ç†
  â€¢ è¿›ç¨‹ç›‘æ§åˆ†æ
  â€¢ æ€§èƒ½æ•°æ®ç»Ÿè®¡

ğŸŒ æ–‡æœ¬æ ¼å¼è½¬æ¢ï¼š
  â€¢ ä¸åŒæ ¼å¼äº’è½¬
  â€¢ æ•°æ®æå–æ•´ç†
  â€¢ æŠ¥å‘Šè‡ªåŠ¨ç”Ÿæˆ
```

---

## 2. ğŸ”„ é€’å½’ç¼–ç¨‹æŠ€æœ¯


### 2.1 é€’å½’çš„åŸºæœ¬æ¦‚å¿µ


**ä»€ä¹ˆæ˜¯é€’å½’**ï¼šå‡½æ•°è°ƒç”¨è‡ªå·±çš„ç¼–ç¨‹æŠ€æœ¯ï¼Œç”¨æ¥è§£å†³å¯ä»¥åˆ†è§£ä¸ºç›¸ä¼¼å­é—®é¢˜çš„å¤æ‚é—®é¢˜ã€‚

**awkä¸­çš„é€’å½’å®ç°**ï¼š
```bash
# è®¡ç®—é˜¶ä¹˜çš„é€’å½’å‡½æ•°
function factorial(n) {
    if (n <= 1) 
        return 1
    else 
        return n * factorial(n-1)
}

BEGIN {
    print "5çš„é˜¶ä¹˜æ˜¯:", factorial(5)
}
```

**é€’å½’æ€ç»´çš„ä¸‰è¦ç´ **ï¼š
```
ğŸ”¸ é€’å½’å‡ºå£ï¼šä»€ä¹ˆæ—¶å€™åœæ­¢é€’å½’
ğŸ”¸ é€’å½’å…³ç³»ï¼šå¦‚ä½•æŠŠå¤§é—®é¢˜åˆ†è§£æˆå°é—®é¢˜  
ğŸ”¸ çŠ¶æ€ä¼ é€’ï¼šå¦‚ä½•åœ¨é€’å½’è°ƒç”¨é—´ä¼ é€’ä¿¡æ¯
```

### 2.2 æ–æ³¢é‚£å¥‘æ•°åˆ—å®ç°


**ç»å…¸é€’å½’é—®é¢˜**ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ— F(n) = F(n-1) + F(n-2)

```bash
# åŸºç¡€é€’å½’ç‰ˆæœ¬ï¼ˆæ•ˆç‡è¾ƒä½ï¼‰
function fib_basic(n) {
    if (n <= 1) return n
    return fib_basic(n-1) + fib_basic(n-2)
}

# ä¼˜åŒ–ç‰ˆæœ¬ï¼šå¸¦è®°å¿†çš„é€’å½’
BEGIN { memo[0] = 0; memo[1] = 1 }

function fib_memo(n) {
    if (n in memo) return memo[n]
    memo[n] = fib_memo(n-1) + fib_memo(n-2)
    return memo[n]
}

BEGIN {
    # è®¡ç®—å‰10ä¸ªæ–æ³¢é‚£å¥‘æ•°
    for (i = 0; i < 10; i++) {
        printf "F(%d) = %d\n", i, fib_memo(i)
    }
}
```

**æ€§èƒ½å¯¹æ¯”åˆ†æ**ï¼š
```
åŸºç¡€é€’å½’ï¼šF(30)éœ€è¦è®¡ç®—çº¦10äº¿æ¬¡
è®°å¿†é€’å½’ï¼šF(30)åªéœ€è¦è®¡ç®—30æ¬¡
æ€§èƒ½æå‡ï¼šæå‡åƒä¸‡å€æ•ˆç‡ï¼
```

### 2.3 ç›®å½•éå†é€’å½’


**å®é™…åº”ç”¨ï¼šé€’å½’å¤„ç†ç›®å½•ç»“æ„**

```bash
# é€’å½’ç»Ÿè®¡ç›®å½•ä¸‹æ–‡ä»¶æ•°é‡
function count_files(path, level) {
    if (level == "") level = 0
    
    # æ„é€ ç¼©è¿›
    indent = ""
    for (i = 0; i < level; i++) indent = indent "  "
    
    # æ‰§è¡Œlså‘½ä»¤è·å–ç›®å½•å†…å®¹
    cmd = "ls -la " path " 2>/dev/null"
    total_files = 0
    
    while ((cmd | getline line) > 0) {
        if (line ~ /^d/ && line !~ /\.$/) {
            # è¿™æ˜¯ç›®å½•
            split(line, arr, /[ ]+/)
            dirname = arr[9]
            if (dirname != "." && dirname != "..") {
                printf "%s[ç›®å½•] %s\n", indent, dirname
                subcount = count_files(path "/" dirname, level + 1)
                total_files += subcount
            }
        } else if (line ~ /^-/) {
            # è¿™æ˜¯æ™®é€šæ–‡ä»¶
            total_files++
        }
    }
    close(cmd)
    
    if (level == 0) {
        printf "æ€»è®¡æ–‡ä»¶æ•°: %d\n", total_files
    }
    return total_files
}

BEGIN {
    if (ARGC < 2) {
        print "ç”¨æ³•: awk -f script.awk ç›®å½•è·¯å¾„"
        exit
    }
    count_files(ARGV[1])
}
```

---

## 3. ğŸ’¾ åŠ¨æ€ç¼–ç¨‹åº”ç”¨


### 3.1 åŠ¨æ€ç¼–ç¨‹åŸºç¡€


**åŠ¨æ€ç¼–ç¨‹çš„æ ¸å¿ƒæ€æƒ³**ï¼šæŠŠå¤æ‚é—®é¢˜åˆ†è§£æˆå­é—®é¢˜ï¼Œä¿å­˜å­é—®é¢˜çš„è§£ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚

**ä¸é€’å½’çš„åŒºåˆ«**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç‰¹å¾          â”‚   é€’å½’          â”‚   åŠ¨æ€ç¼–ç¨‹      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è®¡ç®—æ–¹å¼        â”‚ è‡ªé¡¶å‘ä¸‹       â”‚ è‡ªåº•å‘ä¸Š       â”‚
â”‚ æ˜¯å¦å­˜å‚¨ä¸­é—´ç»“æœâ”‚ ä¸å­˜å‚¨ï¼ˆåŸºç¡€ï¼‰ â”‚ å¿…é¡»å­˜å‚¨       â”‚
â”‚ æ—¶é—´å¤æ‚åº¦      â”‚ å¯èƒ½æŒ‡æ•°çº§     â”‚ é€šå¸¸å¤šé¡¹å¼çº§   â”‚
â”‚ ç©ºé—´å¤æ‚åº¦      â”‚ é€’å½’æ ˆç©ºé—´     â”‚ å­˜å‚¨è¡¨ç©ºé—´     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æœ€é•¿å…¬å…±å­åºåˆ—(LCS)


**é—®é¢˜æè¿°**ï¼šæ‰¾ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—ï¼Œè¿™åœ¨æ–‡ä»¶å¯¹æ¯”ã€ç‰ˆæœ¬æ§åˆ¶ä¸­å¾ˆæœ‰ç”¨ã€‚

```bash
function lcs(str1, str2) {
    len1 = length(str1)
    len2 = length(str2)
    
    # åˆå§‹åŒ–DPè¡¨
    for (i = 0; i <= len1; i++) {
        for (j = 0; j <= len2; j++) {
            dp[i][j] = 0
        }
    }
    
    # å¡«å……DPè¡¨
    for (i = 1; i <= len1; i++) {
        for (j = 1; j <= len2; j++) {
            char1 = substr(str1, i, 1)
            char2 = substr(str2, j, 1)
            
            if (char1 == char2) {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = (dp[i-1][j] > dp[i][j-1]) ? dp[i-1][j] : dp[i][j-1]
            }
        }
    }
    
    return dp[len1][len2]
}

# æ„é€ å…·ä½“çš„LCSå­—ç¬¦ä¸²
function build_lcs(str1, str2) {
    len1 = length(str1)
    len2 = length(str2)
    result = ""
    
    i = len1; j = len2
    while (i > 0 && j > 0) {
        if (substr(str1, i, 1) == substr(str2, j, 1)) {
            result = substr(str1, i, 1) result
            i--; j--
        } else if (dp[i-1][j] > dp[i][j-1]) {
            i--
        } else {
            j--
        }
    }
    
    return result
}

BEGIN {
    str1 = "ABCDGH"
    str2 = "AEDFHR"
    
    lcs_length = lcs(str1, str2)
    lcs_string = build_lcs(str1, str2)
    
    printf "å­—ç¬¦ä¸²1: %s\n", str1
    printf "å­—ç¬¦ä¸²2: %s\n", str2
    printf "æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦: %d\n", lcs_length
    printf "æœ€é•¿å…¬å…±å­åºåˆ—: %s\n", lcs_string
}
```

### 3.3 èƒŒåŒ…é—®é¢˜è§£å†³


**0-1èƒŒåŒ…é—®é¢˜**ï¼šåœ¨æœ‰é™å®¹é‡ä¸‹é€‰æ‹©ä»·å€¼æœ€å¤§çš„ç‰©å“ç»„åˆã€‚

```bash
function knapsack(weights, values, n, capacity) {
    # weights: é‡é‡æ•°ç»„  values: ä»·å€¼æ•°ç»„
    # n: ç‰©å“æ•°é‡  capacity: èƒŒåŒ…å®¹é‡
    
    # åˆå§‹åŒ–DPè¡¨
    for (i = 0; i <= n; i++) {
        for (w = 0; w <= capacity; w++) {
            if (i == 0 || w == 0) {
                dp[i][w] = 0
            } else if (weights[i] <= w) {
                # å¯ä»¥æ”¾å…¥å½“å‰ç‰©å“
                include = values[i] + dp[i-1][w - weights[i]]
                exclude = dp[i-1][w]
                dp[i][w] = (include > exclude) ? include : exclude
            } else {
                # æ— æ³•æ”¾å…¥å½“å‰ç‰©å“
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    
    return dp[n][capacity]
}

BEGIN {
    # ç¤ºä¾‹ï¼š3ä¸ªç‰©å“ï¼ŒèƒŒåŒ…å®¹é‡50
    n = 3
    capacity = 50
    
    weights[1] = 10; values[1] = 60  # ç‰©å“1
    weights[2] = 20; values[2] = 100 # ç‰©å“2  
    weights[3] = 30; values[3] = 120 # ç‰©å“3
    
    max_value = knapsack(weights, values, n, capacity)
    printf "èƒŒåŒ…æœ€å¤§ä»·å€¼: %d\n", max_value
    
    # è¾“å‡ºé€‰æ‹©çš„ç‰©å“
    w = capacity
    printf "é€‰æ‹©çš„ç‰©å“: "
    for (i = n; i >= 1 && max_value > 0; i--) {
        if (max_value != dp[i-1][w]) {
            printf "ç‰©å“%d(é‡é‡:%d,ä»·å€¼:%d) ", i, weights[i], values[i]
            max_value -= values[i]
            w -= weights[i]
        }
    }
    printf "\n"
}
```

---

## 4. ğŸ§® ç®—æ³•å®ç°æŠ€å·§


### 4.1 æ’åºç®—æ³•å®ç°


**å¿«é€Ÿæ’åº**ï¼šawkå®ç°é«˜æ•ˆæ’åºç®—æ³•

```bash
function quicksort(arr, low, high) {
    if (low < high) {
        pivot = partition(arr, low, high)
        quicksort(arr, low, pivot - 1)
        quicksort(arr, pivot + 1, high)
    }
}

function partition(arr, low, high) {
    pivot_value = arr[high]
    i = low - 1
    
    for (j = low; j < high; j++) {
        if (arr[j] <= pivot_value) {
            i++
            swap(arr, i, j)
        }
    }
    
    swap(arr, i + 1, high)
    return i + 1
}

function swap(arr, i, j) {
    temp = arr[i]
    arr[i] = arr[j] 
    arr[j] = temp
}

# ä½¿ç”¨ç¤ºä¾‹
BEGIN {
    # åˆ›å»ºæµ‹è¯•æ•°ç»„
    data[1] = 64; data[2] = 34; data[3] = 25
    data[4] = 12; data[5] = 22; data[6] = 11; data[7] = 90
    n = 7
    
    printf "æ’åºå‰: "
    for (i = 1; i <= n; i++) printf "%d ", data[i]
    printf "\n"
    
    quicksort(data, 1, n)
    
    printf "æ’åºå: "
    for (i = 1; i <= n; i++) printf "%d ", data[i]
    printf "\n"
}
```

### 4.2 å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•


**KMPç®—æ³•**ï¼šé«˜æ•ˆçš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•

```bash
function build_failure_table(pattern) {
    m = length(pattern)
    failure[1] = 0
    j = 0
    
    for (i = 2; i <= m; i++) {
        while (j > 0 && substr(pattern, j+1, 1) != substr(pattern, i, 1)) {
            j = failure[j]
        }
        
        if (substr(pattern, j+1, 1) == substr(pattern, i, 1)) {
            j++
        }
        
        failure[i] = j
    }
}

function kmp_search(text, pattern) {
    n = length(text)
    m = length(pattern)
    
    build_failure_table(pattern)
    
    matches = 0
    j = 0
    
    for (i = 1; i <= n; i++) {
        while (j > 0 && substr(pattern, j+1, 1) != substr(text, i, 1)) {
            j = failure[j]
        }
        
        if (substr(pattern, j+1, 1) == substr(text, i, 1)) {
            j++
        }
        
        if (j == m) {
            printf "æ¨¡å¼åœ¨ä½ç½® %d åŒ¹é…\n", i - m + 1
            matches++
            j = failure[j]
        }
    }
    
    return matches
}

BEGIN {
    text = "ABABDABACDABABCABCABCABCABC"
    pattern = "ABCAB"
    
    printf "æ–‡æœ¬: %s\n", text
    printf "æ¨¡å¼: %s\n", pattern
    
    count = kmp_search(text, pattern)
    printf "å…±æ‰¾åˆ° %d ä¸ªåŒ¹é…\n", count
}
```

### 4.3 å›¾ç®—æ³•åŸºç¡€


**æœ€çŸ­è·¯å¾„ç®—æ³•**ï¼šDijkstraç®—æ³•çš„ç®€åŒ–å®ç°

```bash
function dijkstra(graph, src, vertices) {
    # åˆå§‹åŒ–è·ç¦»å’Œè®¿é—®çŠ¶æ€
    for (v = 1; v <= vertices; v++) {
        dist[v] = 999999  # è¡¨ç¤ºæ— ç©·å¤§
        visited[v] = 0
    }
    
    dist[src] = 0
    
    for (count = 1; count <= vertices - 1; count++) {
        # æ‰¾åˆ°æœªè®¿é—®çš„æœ€çŸ­è·ç¦»é¡¶ç‚¹
        min_dist = 999999
        min_vertex = -1
        
        for (v = 1; v <= vertices; v++) {
            if (!visited[v] && dist[v] < min_dist) {
                min_dist = dist[v]
                min_vertex = v
            }
        }
        
        visited[min_vertex] = 1
        
        # æ›´æ–°ç›¸é‚»é¡¶ç‚¹çš„è·ç¦»
        for (v = 1; v <= vertices; v++) {
            if (!visited[v] && graph[min_vertex][v] && 
                dist[min_vertex] + graph[min_vertex][v] < dist[v]) {
                dist[v] = dist[min_vertex] + graph[min_vertex][v]
            }
        }
    }
    
    # è¾“å‡ºç»“æœ
    printf "ä»é¡¶ç‚¹ %d åˆ°å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·ç¦»:\n", src
    for (v = 1; v <= vertices; v++) {
        printf "é¡¶ç‚¹ %d: %d\n", v, dist[v]
    }
}

BEGIN {
    vertices = 5
    
    # æ„é€ ç¤ºä¾‹å›¾ï¼ˆé‚»æ¥çŸ©é˜µï¼‰
    graph[1][2] = 10; graph[1][4] = 5
    graph[2][3] = 1;  graph[2][4] = 2
    graph[3][5] = 4
    graph[4][2] = 3;  graph[4][3] = 9; graph[4][5] = 2
    graph[5][3] = 6
    
    dijkstra(graph, 1, vertices)
}
```

---

## 5. ğŸ—‚ï¸ æ•°æ®ç»“æ„æ¨¡æ‹Ÿ


### 5.1 æ ˆçš„å®ç°ä¸åº”ç”¨


**æ ˆçš„åŸºæœ¬æ“ä½œ**ï¼šåè¿›å…ˆå‡º(LIFO)çš„æ•°æ®ç»“æ„

```bash
# æ ˆçš„åŸºæœ¬æ“ä½œå‡½æ•°
function stack_init() {
    stack_top = 0
    delete stack_data
}

function stack_push(value) {
    stack_data[++stack_top] = value
}

function stack_pop() {
    if (stack_top <= 0) {
        print "æ ˆä¸ºç©ºï¼Œæ— æ³•å¼¹å‡º"
        return ""
    }
    value = stack_data[stack_top]
    delete stack_data[stack_top--]
    return value
}

function stack_peek() {
    if (stack_top <= 0) return ""
    return stack_data[stack_top]
}

function stack_is_empty() {
    return stack_top <= 0
}

function stack_size() {
    return stack_top
}

# åº”ç”¨ï¼šæ‹¬å·åŒ¹é…æ£€æŸ¥
function check_parentheses(expr) {
    stack_init()
    len = length(expr)
    
    for (i = 1; i <= len; i++) {
        char = substr(expr, i, 1)
        
        if (char == "(" || char == "[" || char == "{") {
            stack_push(char)
        } else if (char == ")" || char == "]" || char == "}") {
            if (stack_is_empty()) {
                return 0  # ä¸åŒ¹é…
            }
            
            top = stack_pop()
            if ((char == ")" && top != "(") ||
                (char == "]" && top != "[") ||
                (char == "}" && top != "{")) {
                return 0  # ä¸åŒ¹é…
            }
        }
    }
    
    return stack_is_empty() ? 1 : 0  # æ ˆä¸ºç©ºè¡¨ç¤ºåŒ¹é…
}

BEGIN {
    test_cases[1] = "()"
    test_cases[2] = "()[]{}"
    test_cases[3] = "([)]"
    test_cases[4] = "{[(())]}"
    test_cases[5] = "((("
    
    for (i = 1; i <= 5; i++) {
        result = check_parentheses(test_cases[i]) ? "åŒ¹é…" : "ä¸åŒ¹é…"
        printf "è¡¨è¾¾å¼ '%s': %s\n", test_cases[i], result
    }
}
```

### 5.2 é˜Ÿåˆ—çš„å®ç°


**é˜Ÿåˆ—çš„åŸºæœ¬æ“ä½œ**ï¼šå…ˆè¿›å…ˆå‡º(FIFO)çš„æ•°æ®ç»“æ„

```bash
# é˜Ÿåˆ—å®ç°
function queue_init() {
    queue_front = 1
    queue_rear = 0
    delete queue_data
}

function queue_enqueue(value) {
    queue_data[++queue_rear] = value
}

function queue_dequeue() {
    if (queue_front > queue_rear) {
        print "é˜Ÿåˆ—ä¸ºç©º"
        return ""
    }
    
    value = queue_data[queue_front]
    delete queue_data[queue_front++]
    return value
}

function queue_is_empty() {
    return queue_front > queue_rear
}

function queue_size() {
    return queue_rear - queue_front + 1
}

# åº”ç”¨ï¼šå±‚åºéå†æ ‘ç»“æ„
function level_order_traversal(tree, root) {
    queue_init()
    queue_enqueue(root)
    
    printf "å±‚åºéå†ç»“æœ: "
    
    while (!queue_is_empty()) {
        node = queue_dequeue()
        printf "%s ", node
        
        # å°†å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
        for (child in tree) {
            if (index(child, node "_") == 1) {
                queue_enqueue(substr(child, length(node) + 2))
            }
        }
    }
    printf "\n"
}
```

### 5.3 äºŒå‰æœç´¢æ ‘æ¨¡æ‹Ÿ


**BSTåŸºæœ¬æ“ä½œ**ï¼šç»´æŠ¤æœ‰åºæ€§çš„æ ‘ç»“æ„

```bash
# BSTèŠ‚ç‚¹ç»“æ„ï¼šä½¿ç”¨å…³è”æ•°ç»„æ¨¡æ‹Ÿ
function bst_insert(root, value, key) {
    if (key == "") key = "root"
    
    if (!(key in tree_data)) {
        tree_data[key] = value
        tree_left[key] = ""
        tree_right[key] = ""
        return key
    }
    
    if (value < tree_data[key]) {
        if (tree_left[key] == "") {
            new_key = key "_L"
            tree_data[new_key] = value
            tree_left[new_key] = ""
            tree_right[new_key] = ""
            tree_left[key] = new_key
        } else {
            bst_insert(root, value, tree_left[key])
        }
    } else {
        if (tree_right[key] == "") {
            new_key = key "_R"
            tree_data[new_key] = value
            tree_left[new_key] = ""
            tree_right[new_key] = ""
            tree_right[key] = new_key
        } else {
            bst_insert(root, value, tree_right[key])
        }
    }
    
    return key
}

function bst_inorder(key) {
    if (key == "" || !(key in tree_data)) return
    
    bst_inorder(tree_left[key])
    printf "%d ", tree_data[key]
    bst_inorder(tree_right[key])
}

function bst_search(key, value) {
    if (key == "" || !(key in tree_data)) return 0
    
    if (tree_data[key] == value) return 1
    else if (value < tree_data[key]) return bst_search(tree_left[key], value)
    else return bst_search(tree_right[key], value)
}

BEGIN {
    # æ„å»ºBST
    values[1] = 50; values[2] = 30; values[3] = 70
    values[4] = 20; values[5] = 40; values[6] = 60; values[7] = 80
    
    root = ""
    for (i = 1; i <= 7; i++) {
        root = bst_insert(root, values[i], root)
        if (root == "") root = "root"
    }
    
    printf "ä¸­åºéå† (æœ‰åºè¾“å‡º): "
    bst_inorder("root")
    printf "\n"
    
    # æœç´¢æµ‹è¯•
    search_values[1] = 40; search_values[2] = 90
    for (i = 1; i <= 2; i++) {
        found = bst_search("root", search_values[i])
        result = found ? "æ‰¾åˆ°" : "æœªæ‰¾åˆ°"
        printf "æœç´¢ %d: %s\n", search_values[i], result
    }
}
```

---

## 6. ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


### 6.1 ç®—æ³•å¤æ‚åº¦åˆ†æ


**æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–åŸåˆ™**ï¼š

```
å¸¸è§å¤æ‚åº¦ç­‰çº§ï¼ˆä»ä¼˜åˆ°åŠ£ï¼‰ï¼š
ğŸŸ¢ O(1)      - å¸¸æ•°æ—¶é—´    - æ•°ç»„è®¿é—®ã€å“ˆå¸ŒæŸ¥æ‰¾
ğŸŸ¢ O(log n)  - å¯¹æ•°æ—¶é—´    - äºŒåˆ†æœç´¢ã€å¹³è¡¡æ ‘æ“ä½œ  
ğŸŸ¡ O(n)      - çº¿æ€§æ—¶é—´    - å•æ¬¡éå†ã€ç®€å•æœç´¢
ğŸŸ¡ O(n log n)- çº¿æ€§å¯¹æ•°    - é«˜æ•ˆæ’åºç®—æ³•
ğŸ”´ O(nÂ²)     - å¹³æ–¹æ—¶é—´    - åµŒå¥—å¾ªç¯ã€å†’æ³¡æ’åº
ğŸ”´ O(2â¿)     - æŒ‡æ•°æ—¶é—´    - é€’å½’æ–æ³¢é‚£å¥‘ã€æš´åŠ›æœç´¢
```

**ä¼˜åŒ–ç­–ç•¥å¯¹æ¯”**ï¼š

```bash
# ä½æ•ˆç‰ˆæœ¬ï¼šO(nÂ²)å¤æ‚åº¦
function find_duplicates_slow(arr, n) {
    count = 0
    for (i = 1; i <= n; i++) {
        for (j = i + 1; j <= n; j++) {
            if (arr[i] == arr[j]) {
                count++
                break
            }
        }
    }
    return count
}

# é«˜æ•ˆç‰ˆæœ¬ï¼šO(n)å¤æ‚åº¦
function find_duplicates_fast(arr, n) {
    delete seen
    count = 0
    
    for (i = 1; i <= n; i++) {
        if (arr[i] in seen) {
            count++
        } else {
            seen[arr[i]] = 1
        }
    }
    return count
}

BEGIN {
    # æµ‹è¯•æ•°æ®
    test_arr[1] = 1; test_arr[2] = 2; test_arr[3] = 3
    test_arr[4] = 2; test_arr[5] = 4; test_arr[6] = 1
    n = 6
    
    # æ€§èƒ½æµ‹è¯•ï¼ˆæ¨¡æ‹Ÿï¼‰
    start_time = systime()
    result1 = find_duplicates_slow(test_arr, n)
    slow_time = systime() - start_time
    
    start_time = systime()  
    result2 = find_duplicates_fast(test_arr, n)
    fast_time = systime() - start_time
    
    printf "æ…¢é€Ÿç®—æ³•ç»“æœ: %d, è€—æ—¶: %dæ¯«ç§’\n", result1, slow_time * 1000
    printf "å¿«é€Ÿç®—æ³•ç»“æœ: %d, è€—æ—¶: %dæ¯«ç§’\n", result2, fast_time * 1000
    printf "æ€§èƒ½æå‡: %.2få€\n", slow_time / fast_time
}
```

### 6.2 å†…å­˜ä½¿ç”¨ä¼˜åŒ–


**å…³è”æ•°ç»„ä¼˜åŒ–**ï¼šawkçš„å…³è”æ•°ç»„æ˜¯æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œéœ€è¦åˆç†ä½¿ç”¨

```bash
# ä½æ•ˆï¼šå¤§é‡ä¸´æ—¶å˜é‡
function process_data_inefficient(filename) {
    while ((getline line < filename) > 0) {
        split(line, fields, ",")
        
        # åˆ›å»ºå¤§é‡ä¸´æ—¶å˜é‡ï¼ˆå†…å­˜æµªè´¹ï¼‰
        user_data[NR "_name"] = fields[1]
        user_data[NR "_age"] = fields[2] 
        user_data[NR "_city"] = fields[3]
        # ... æ›´å¤šå­—æ®µ
    }
    close(filename)
}

# é«˜æ•ˆï¼šç´§å‡‘çš„æ•°æ®ç»“æ„
function process_data_efficient(filename) {
    while ((getline line < filename) > 0) {
        split(line, fields, ",")
        
        # ä½¿ç”¨ç´§å‡‘æ ¼å¼å­˜å‚¨
        user_data[NR] = fields[1] "," fields[2] "," fields[3]
        
        # æˆ–è€…åªå­˜å‚¨éœ€è¦çš„æ•°æ®
        if (fields[2] > 18) {  # åªä¿ç•™æˆå¹´äººæ•°æ®
            adults[fields[1]] = fields[2]
        }
    }
    close(filename)
}

# å†…å­˜æ¸…ç†å‡½æ•°
function cleanup_memory() {
    delete user_data
    delete adults
    delete temp_vars
}

# æ‰¹é‡å¤„ç†å¤§æ–‡ä»¶
function process_large_file(filename, batch_size) {
    if (batch_size == "") batch_size = 1000
    
    record_count = 0
    
    while ((getline line < filename) > 0) {
        # å¤„ç†å½“å‰è®°å½•
        process_record(line, ++record_count)
        
        # è¾¾åˆ°æ‰¹æ¬¡å¤§å°æ—¶æ¸…ç†å†…å­˜
        if (record_count % batch_size == 0) {
            # è¾“å‡ºä¸­é—´ç»“æœ
            output_batch_results()
            # æ¸…ç†ä¸´æ—¶æ•°æ®
            delete temp_batch
            print "å·²å¤„ç†", record_count, "æ¡è®°å½•ï¼Œå†…å­˜å·²æ¸…ç†"
        }
    }
    
    # å¤„ç†å‰©ä½™è®°å½•
    if (record_count % batch_size != 0) {
        output_batch_results()
    }
    
    close(filename)
}
```

### 6.3 I/Oæ“ä½œä¼˜åŒ–


**æ–‡ä»¶è¯»å†™ä¼˜åŒ–ç­–ç•¥**ï¼š

```bash
# é«˜æ•ˆçš„æ–‡ä»¶å¤„ç†æ¨¡å¼
function optimized_file_processing() {
    # 1. ä½¿ç”¨åˆé€‚çš„ç¼“å†²åŒºå¤§å°
    RS = "\n"  # æ˜ç¡®è®°å½•åˆ†éš”ç¬¦
    FS = ","   # æ˜ç¡®å­—æ®µåˆ†éš”ç¬¦
    
    # 2. é¿å…é¢‘ç¹çš„æ–‡ä»¶æ“ä½œ
    output_buffer = ""
    buffer_size = 0
    max_buffer = 1000
    
    while ((getline) > 0) {
        # å¤„ç†é€»è¾‘
        processed_line = process_line($0)
        
        # ä½¿ç”¨ç¼“å†²åŒºå‡å°‘I/Oæ¬¡æ•°
        output_buffer = output_buffer processed_line "\n"
        buffer_size++
        
        if (buffer_size >= max_buffer) {
            print output_buffer > "output.txt"
            output_buffer = ""
            buffer_size = 0
        }
    }
    
    # è¾“å‡ºå‰©ä½™ç¼“å†²åŒºå†…å®¹
    if (buffer_size > 0) {
        print output_buffer > "output.txt"
    }
}

# æ¡ä»¶ç¼–è¯‘ï¼šåªåœ¨éœ€è¦æ—¶æ‰§è¡Œæ˜‚è´µæ“ä½œ
function conditional_processing(enable_advanced) {
    if (enable_advanced) {
        # å¤æ‚ä½†ç²¾ç¡®çš„å¤„ç†
        result = advanced_analysis($0)
    } else {
        # ç®€å•å¿«é€Ÿçš„å¤„ç†
        result = simple_analysis($0)
    }
    return result
}

# é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ï¼ˆæ¦‚å¿µæ€§ï¼‰
BEGIN {
    email_pattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    phone_pattern = "^[0-9]{3}-[0-9]{3}-[0-9]{4}$"
}

{
    # ä½¿ç”¨é¢„å®šä¹‰æ¨¡å¼ï¼Œé¿å…é‡å¤ç¼–è¯‘
    if ($1 ~ email_pattern) {
        email_count++
    }
    if ($2 ~ phone_pattern) {
        phone_count++
    }
}
```

---

## 7. ğŸ§  å†…å­˜ç®¡ç†æœ€ä½³å®è·µ


### 7.1 å˜é‡ç”Ÿå‘½å‘¨æœŸç®¡ç†


**åˆç†çš„å˜é‡ä½œç”¨åŸŸ**ï¼š

```bash
# å…¨å±€å˜é‡ï¼šç¨‹åºå…¨ç¨‹ä½¿ç”¨
BEGIN {
    global_config["debug"] = 1
    global_config["output_dir"] = "/tmp"
}

# å±€éƒ¨å˜é‡ï¼šå‡½æ•°å†…éƒ¨ä½¿ç”¨
function process_user_data(username, userdata,    # å‚æ•°
                          temp_var, i, result) {  # å±€éƒ¨å˜é‡
    
    # ä½¿ç”¨å±€éƒ¨å˜é‡è¿›è¡Œè®¡ç®—
    temp_var = split(userdata, fields, ",")
    result = ""
    
    for (i = 1; i <= temp_var; i++) {
        result = result fields[i] "|"
    }
    
    # å±€éƒ¨å˜é‡åœ¨å‡½æ•°ç»“æŸæ—¶è‡ªåŠ¨æ¸…ç†
    return result
}

# ä¸´æ—¶å˜é‡åŠæ—¶æ¸…ç†
function batch_processing() {
    delete temp_data  # æ¸…ç†ä¸Šä¸€æ‰¹æ¬¡çš„æ•°æ®
    
    # å¤„ç†å½“å‰æ‰¹æ¬¡
    for (i = 1; i <= batch_size; i++) {
        temp_data[i] = process_item(i)
    }
    
    # ä½¿ç”¨å®Œæ¯•ç«‹å³æ¸…ç†
    output_results(temp_data)
    delete temp_data
}
```

### 7.2 å¤§æ•°æ®é›†å¤„ç†ç­–ç•¥


**æµå¼å¤„ç†æŠ€æœ¯**ï¼š

```bash
# å¤„ç†è¶…å¤§æ–‡ä»¶ï¼šé€è¡Œå¤„ç†ï¼Œä¸å…¨éƒ¨åŠ è½½åˆ°å†…å­˜
function stream_process_large_file(filename) {
    line_count = 0
    sum = 0
    
    while ((getline line < filename) > 0) {
        line_count++
        
        # åªä¿ç•™å¿…è¦çš„ç»Ÿè®¡ä¿¡æ¯ï¼Œä¸å­˜å‚¨åŸå§‹æ•°æ®
        if (line ~ /^[0-9]+$/) {
            sum += line
        }
        
        # å®šæœŸè¾“å‡ºè¿›åº¦ï¼Œé‡Šæ”¾ä¸€äº›å†…å­˜å‹åŠ›
        if (line_count % 10000 == 0) {
            printf "å·²å¤„ç† %d è¡Œï¼Œå½“å‰å’Œ: %d\n", line_count, sum
        }
    }
    close(filename)
    
    printf "æ€»è®¡å¤„ç† %d è¡Œï¼Œæœ€ç»ˆå’Œ: %d\n", line_count, sum
}

# åˆ†ç‰‡å¤„ç†ï¼šå°†å¤§é—®é¢˜åˆ†è§£ä¸ºå°é—®é¢˜
function chunk_processing(data_array, chunk_size) {
    total_items = length(data_array)
    
    for (start = 1; start <= total_items; start += chunk_size) {
        end = (start + chunk_size - 1 > total_items) ? total_items : start + chunk_size - 1
        
        # å¤„ç†å½“å‰å—
        process_chunk(data_array, start, end)
        
        # å¯é€‰ï¼šæ¸…ç†ä¸­é—´ç»“æœ
        cleanup_chunk_temp_data()
    }
}

function process_chunk(data, start, end) {
    for (i = start; i <= end; i++) {
        # å¤„ç†å•ä¸ªé¡¹ç›®
        result = complex_operation(data[i])
        # ç«‹å³è¾“å‡ºæˆ–ç´¯ç§¯ï¼Œä¸é•¿æœŸå­˜å‚¨
        output_result(result)
    }
}
```

### 7.3 å†…å­˜æ³„æ¼é˜²æŠ¤


**å¸¸è§å†…å­˜æ³„æ¼åœºæ™¯åŠé¢„é˜²**ï¼š

```bash
# åœºæ™¯1ï¼šé€’å½’å‡½æ•°ä¸­çš„å±€éƒ¨æ•°ç»„æœªæ¸…ç†
function recursive_process(data, level,    local_cache) {
    # æ­£ç¡®ï¼šä½¿ç”¨å±€éƒ¨å˜é‡å£°æ˜
    delete local_cache  # ç¡®ä¿å¼€å§‹æ—¶ä¸ºç©º
    
    # å¤„ç†é€»è¾‘...
    if (level > 0) {
        local_cache[level] = data
        return recursive_process(data * 2, level - 1)
    }
    
    # å±€éƒ¨å˜é‡ä¼šè‡ªåŠ¨æ¸…ç†ï¼Œä½†å¤§æ•°ç»„å¯ä»¥æ‰‹åŠ¨æ¸…ç†
    delete local_cache
    return data
}

# åœºæ™¯2ï¼šæ–‡ä»¶å¥æŸ„æœªæ­£ç¡®å…³é—­
function safe_file_operations() {
    # ä½¿ç”¨æ•°ç»„è®°å½•æ‰“å¼€çš„æ–‡ä»¶
    opened_files[++file_count] = "data.txt"
    
    while ((getline line < "data.txt") > 0) {
        process_line(line)
    }
    
    # ç¡®ä¿æ–‡ä»¶è¢«å…³é—­
    close("data.txt")
    delete opened_files[file_count--]
}

# åœºæ™¯3ï¼šå¾ªç¯å¼•ç”¨
function avoid_circular_references() {
    # é¿å…è¿™æ ·çš„ç»“æ„ï¼š
    # parent[child] = value
    # child[parent] = value
    
    # æ”¹ç”¨å•å‘å¼•ç”¨ï¼š
    parent_to_child[parent] = child
    child_info[child] = value
    
    # æ¸…ç†æ—¶åˆ†åˆ«æ¸…ç†
    delete parent_to_child
    delete child_info
}

# å†…å­˜ä½¿ç”¨ç›‘æ§ï¼ˆæ¦‚å¿µæ€§ï¼‰
function monitor_memory_usage() {
    if (global_config["debug"]) {
        array_count = 0
        for (arr_name in SYMTAB) {
            if (isarray(SYMTAB[arr_name])) {
                array_count++
                array_size = length(SYMTAB[arr_name])
                printf "æ•°ç»„ %s: %d ä¸ªå…ƒç´ \n", arr_name, array_size
            }
        }
        printf "æ€»è®¡ %d ä¸ªæ•°ç»„\n", array_count
    }
}
```

---

## 8. ğŸ”§ å¤æ‚ä¸šåŠ¡é€»è¾‘å¤„ç†


### 8.1 çŠ¶æ€æœºå®ç°


**æœ‰é™çŠ¶æ€æœº**ï¼šå¤„ç†å¤æ‚çš„çŠ¶æ€è½¬æ¢é€»è¾‘

```bash
# è§£æå™¨çŠ¶æ€æœºï¼šå¤„ç†é…ç½®æ–‡ä»¶
function config_parser_init() {
    state = "IDLE"
    current_section = ""
    delete config_data
}

function parse_config_line(line) {
    # å»é™¤é¦–å°¾ç©ºç™½
    gsub(/^[ \t]+|[ \t]+$/, "", line)
    
    # å¿½ç•¥ç©ºè¡Œå’Œæ³¨é‡Š
    if (line == "" || line ~ /^#/) return
    
    switch (state) {
        case "IDLE":
            if (line ~ /^\[.*\]$/) {
                # è¿›å…¥æ–°èŠ‚
                current_section = substr(line, 2, length(line) - 2)
                state = "IN_SECTION"
                printf "è¿›å…¥èŠ‚: %s\n", current_section
            }
            break
            
        case "IN_SECTION":
            if (line ~ /^\[.*\]$/) {
                # æ–°èŠ‚å¼€å§‹
                current_section = substr(line, 2, length(line) - 2)
                printf "åˆ‡æ¢åˆ°èŠ‚: %s\n", current_section
            } else if (line ~ /^[^=]+=[^=]*$/) {
                # é”®å€¼å¯¹
                split(line, kv, "=")
                key = kv[1]
                value = kv[2]
                gsub(/^[ \t]+|[ \t]+$/, "", key)
                gsub(/^[ \t]+|[ \t]+$/, "", value)
                
                config_data[current_section][key] = value
                printf "  %s = %s\n", key, value
            }
            break
    }
}

# ä½¿ç”¨çŠ¶æ€æœºè§£ææ–‡ä»¶
BEGIN {
    config_parser_init()
    
    # æ¨¡æ‹Ÿé…ç½®æ–‡ä»¶å†…å®¹
    test_lines[1] = "[database]"
    test_lines[2] = "host = localhost"
    test_lines[3] = "port = 3306"
    test_lines[4] = "[cache]" 
    test_lines[5] = "redis_host = 127.0.0.1"
    test_lines[6] = "redis_port = 6379"
    
    for (i = 1; i <= 6; i++) {
        parse_config_line(test_lines[i])
    }
    
    # è¾“å‡ºè§£æç»“æœ
    print "\né…ç½®è§£æç»“æœ:"
    for (section in config_data) {
        printf "[%s]\n", section
        for (key in config_data[section]) {
            printf "  %s = %s\n", key, config_data[section][key]
        }
    }
}
```

### 8.2 å·¥ä½œæµå¼•æ“


**ä»»åŠ¡è°ƒåº¦å’Œä¾èµ–ç®¡ç†**ï¼š

```bash
# å·¥ä½œæµä»»åŠ¡å®šä¹‰
function workflow_init() {
    # ä»»åŠ¡å®šä¹‰ï¼šname, dependencies, status
    tasks["task1"]["deps"] = ""
    tasks["task1"]["status"] = "pending"
    tasks["task1"]["command"] = "echo 'æ‰§è¡Œä»»åŠ¡1'"
    
    tasks["task2"]["deps"] = "task1"
    tasks["task2"]["status"] = "pending"  
    tasks["task2"]["command"] = "echo 'æ‰§è¡Œä»»åŠ¡2'"
    
    tasks["task3"]["deps"] = "task1,task2"
    tasks["task3"]["status"] = "pending"
    tasks["task3"]["command"] = "echo 'æ‰§è¡Œä»»åŠ¡3'"
    
    tasks["task4"]["deps"] = "task2"
    tasks["task4"]["status"] = "pending"
    tasks["task4"]["command"] = "echo 'æ‰§è¡Œä»»åŠ¡4'"
}

function check_dependencies(task_name) {
    deps = tasks[task_name]["deps"]
    if (deps == "") return 1  # æ— ä¾èµ–ï¼Œå¯æ‰§è¡Œ
    
    # æ£€æŸ¥æ‰€æœ‰ä¾èµ–æ˜¯å¦å®Œæˆ
    split(deps, dep_array, ",")
    for (i in dep_array) {
        dep_task = dep_array[i]
        gsub(/^[ \t]+|[ \t]+$/, "", dep_task)  # å»ç©ºæ ¼
        
        if (tasks[dep_task]["status"] != "completed") {
            return 0  # ä¾èµ–æœªå®Œæˆ
        }
    }
    
    return 1  # æ‰€æœ‰ä¾èµ–å·²å®Œæˆ
}

function execute_task(task_name) {
    if (tasks[task_name]["status"] != "pending") {
        return 0  # ä»»åŠ¡å·²æ‰§è¡Œæˆ–å¤±è´¥
    }
    
    if (!check_dependencies(task_name)) {
        return 0  # ä¾èµ–æœªæ»¡è¶³
    }
    
    # æ‰§è¡Œä»»åŠ¡
    tasks[task_name]["status"] = "running"
    printf "å¼€å§‹æ‰§è¡Œä»»åŠ¡: %s\n", task_name
    
    # æ¨¡æ‹Ÿä»»åŠ¡æ‰§è¡Œ
    command = tasks[task_name]["command"]
    system(command)
    
    # æ ‡è®°å®Œæˆ
    tasks[task_name]["status"] = "completed"
    printf "ä»»åŠ¡ %s æ‰§è¡Œå®Œæˆ\n", task_name
    return 1
}

function workflow_execute() {
    max_iterations = 20  # é˜²æ­¢æ­»å¾ªç¯
    iteration = 0
    
    while (iteration < max_iterations) {
        executed_any = 0
        iteration++
        
        printf "\n=== æ‰§è¡Œè½®æ¬¡ %d ===\n", iteration
        
        # å°è¯•æ‰§è¡Œæ‰€æœ‰å¾…æ‰§è¡Œä»»åŠ¡
        for (task in tasks) {
            if (execute_task(task)) {
                executed_any = 1
            }
        }
        
        # æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        all_completed = 1
        for (task in tasks) {
            if (tasks[task]["status"] != "completed") {
                all_completed = 0
                break
            }
        }
        
        if (all_completed) {
            printf "\næ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼\n"
            break
        }
        
        if (!executed_any) {
            printf "\nè­¦å‘Šï¼šæœ¬è½®æ¬¡æ²¡æœ‰ä»»åŠ¡å¯æ‰§è¡Œï¼Œå¯èƒ½å­˜åœ¨å¾ªç¯ä¾èµ–\n"
            break
        }
    }
}

BEGIN {
    workflow_init()
    workflow_execute()
    
    # è¾“å‡ºæœ€ç»ˆçŠ¶æ€
    printf "\næœ€ç»ˆä»»åŠ¡çŠ¶æ€:\n"
    for (task in tasks) {
        printf "  %s: %s\n", task, tasks[task]["status"]
    }
}
```

### 8.3 å¤æ‚æ•°æ®è½¬æ¢


**å¤šæ ¼å¼æ•°æ®è½¬æ¢å™¨**ï¼š

```bash
# æ•°æ®æ ¼å¼è½¬æ¢å™¨
function convert_data(input_format, output_format, data) {
    if (input_format == "csv" && output_format == "json") {
        return csv_to_json(data)
    } else if (input_format == "json" && output_format == "xml") {
        return json_to_xml(data)  
    } else if (input_format == "xml" && output_format == "csv") {
        return xml_to_csv(data)
    }
    # æ·»åŠ æ›´å¤šè½¬æ¢...
    return data  # ä¸æ”¯æŒçš„è½¬æ¢
}

function csv_to_json(csv_data) {
    json_output = "["
    record_count = 0
    
    # å¤„ç†CSVæ•°æ®
    split(csv_data, lines, "\n")
    
    # ç¬¬ä¸€è¡Œä½œä¸ºæ ‡é¢˜
    if (length(lines) > 0) {
        split(lines[1], headers, ",")
        header_count = length(headers)
        
        # æ¸…ç†æ ‡é¢˜ä¸­çš„ç©ºæ ¼å’Œå¼•å·
        for (i = 1; i <= header_count; i++) {
            gsub(/^[ \t"]+|[ \t"]+$/, "", headers[i])
        }
    }
    
    # å¤„ç†æ•°æ®è¡Œ
    for (line_idx = 2; line_idx <= length(lines); line_idx++) {
        if (lines[line_idx] == "") continue
        
        split(lines[line_idx], fields, ",")
        
        if (record_count > 0) json_output = json_output ","
        json_output = json_output "\n  {"
        
        for (i = 1; i <= header_count && i <= length(fields); i++) {
            value = fields[i]
            gsub(/^[ \t"]+|[ \t"]+$/, "", value)  # æ¸…ç†å€¼
            
            if (i > 1) json_output = json_output ","
            json_output = json_output sprintf("\n    \"%s\": \"%s\"", headers[i], value)
        }
        
        json_output = json_output "\n  }"
        record_count++
    }
    
    json_output = json_output "\n]"
    return json_output
}

# æ•°æ®éªŒè¯å™¨
function validate_data(data, format, rules) {
    errors = 0
    
    if (format == "email") {
        if (data !~ /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) {
            printf "é”™è¯¯ï¼šæ— æ•ˆçš„é‚®ç®±æ ¼å¼: %s\n", data
            errors++
        }
    } else if (format == "phone") {
        if (data !~ /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/) {
            printf "é”™è¯¯ï¼šæ— æ•ˆçš„ç”µè¯æ ¼å¼: %s\n", data
            errors++
        }
    } else if (format == "date") {
        if (data !~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) {
            printf "é”™è¯¯ï¼šæ— æ•ˆçš„æ—¥æœŸæ ¼å¼: %s\n", data
            errors++
        }
    }
    
    return errors == 0
}

# æ‰¹é‡æ•°æ®å¤„ç†ç®¡é“
function data_pipeline(input_file, transformations) {
    stage = 1
    current_data = input_file
    
    # æŒ‰é¡ºåºæ‰§è¡Œè½¬æ¢
    split(transformations, transform_list, ",")
    
    for (i in transform_list) {
        transform = transform_list[i]
        gsub(/^[ \t]+|[ \t]+$/, "", transform)
        
        printf "æ‰§è¡Œè½¬æ¢é˜¶æ®µ %d: %s\n", stage++, transform
        
        if (transform == "clean") {
            current_data = clean_data(current_data)
        } else if (transform == "validate") {
            if (!validate_pipeline_data(current_data)) {
                printf "æ•°æ®éªŒè¯å¤±è´¥ï¼Œç®¡é“ç»ˆæ­¢\n"
                return ""
            }
        } else if (transform == "aggregate") {
            current_data = aggregate_data(current_data)
        }
    }
    
    return current_data
}

BEGIN {
    # æµ‹è¯•æ•°æ®è½¬æ¢
    test_csv = "name,age,city\nJohn,25,NYC\nJane,30,LA"
    
    printf "åŸå§‹CSVæ•°æ®:\n%s\n\n", test_csv
    
    json_result = csv_to_json(test_csv)
    printf "è½¬æ¢ä¸ºJSON:\n%s\n", json_result
    
    # æµ‹è¯•æ•°æ®éªŒè¯
    printf "\næ•°æ®éªŒè¯æµ‹è¯•:\n"
    validate_data("john@example.com", "email", "")
    validate_data("invalid-email", "email", "")
    validate_data("123-456-7890", "phone", "")
    validate_data("123456", "phone", "")
}
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæŠ€æœ¯


```
ğŸ”¸ é€’å½’ç¼–ç¨‹ï¼šæŒæ¡é€’å½’æ€ç»´ï¼Œèƒ½è§£å†³åˆ†å±‚é—®é¢˜
ğŸ”¸ åŠ¨æ€ç¼–ç¨‹ï¼šç†è§£çŠ¶æ€è½¬æ¢ï¼Œä¼˜åŒ–ç®—æ³•å¤æ‚åº¦
ğŸ”¸ æ•°æ®ç»“æ„ï¼šç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆã€é˜Ÿåˆ—ã€æ ‘ç­‰ç»“æ„
ğŸ”¸ ç®—æ³•å®ç°ï¼šæ’åºã€æŸ¥æ‰¾ã€å›¾ç®—æ³•çš„awkå®ç°
ğŸ”¸ æ€§èƒ½ä¼˜åŒ–ï¼šæ—¶é—´å¤æ‚åº¦åˆ†æå’Œå†…å­˜ç®¡ç†
ğŸ”¸ ä¸šåŠ¡é€»è¾‘ï¼šçŠ¶æ€æœºã€å·¥ä½œæµã€æ•°æ®è½¬æ¢
```

### 9.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ é€’å½’vsåŠ¨æ€ç¼–ç¨‹çš„é€‰æ‹©**
```
ä½¿ç”¨é€’å½’å½“ï¼š
- é—®é¢˜å…·æœ‰å¤©ç„¶çš„åˆ†å±‚ç»“æ„
- å­é—®é¢˜ä¸é‡å¤æˆ–é‡å¤æ¬¡æ•°å°‘
- ä»£ç ç®€æ´æ€§æ¯”æ€§èƒ½æ›´é‡è¦

ä½¿ç”¨åŠ¨æ€ç¼–ç¨‹å½“ï¼š
- å­˜åœ¨å¤§é‡é‡å¤å­é—®é¢˜
- å¯¹æ€§èƒ½è¦æ±‚è¾ƒé«˜
- å¯ä»¥æ‰¾åˆ°æœ€ä¼˜å­ç»“æ„
```

**ğŸ”¹ æ•°æ®ç»“æ„é€‰æ‹©åŸåˆ™**  
```
å…³è”æ•°ç»„ï¼šawkçš„æ ¸å¿ƒï¼Œç”¨äºé”®å€¼æ˜ å°„
æ™®é€šæ•°ç»„ï¼šæ•°å€¼ç´¢å¼•ï¼Œç”¨äºåˆ—è¡¨å’Œæ ˆ
å­—ç¬¦ä¸²æ‹¼æ¥ï¼šç®€å•çš„é˜Ÿåˆ—å’Œç¼“å†²åŒº
å‡½æ•°å‚æ•°ï¼šå±€éƒ¨ä¸´æ—¶å­˜å‚¨
```

**ğŸ”¹ æ€§èƒ½ä¼˜åŒ–çš„ä¼˜å…ˆçº§**
```
1. ç®—æ³•å¤æ‚åº¦ > 2. å†…å­˜ç®¡ç† > 3. I/Oä¼˜åŒ– > 4. ä»£ç ä¼˜åŒ–

å…ˆé€‰æ‹©æ­£ç¡®çš„ç®—æ³•ï¼Œå†è€ƒè™‘å®ç°ç»†èŠ‚
O(n)çš„ç²—ç³™å®ç°é€šå¸¸æ¯”O(nÂ²)çš„ç²¾ç»†å®ç°æ›´å¥½
```

### 9.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ”§ å¼€å‘æœ€ä½³å®è·µ**
```
ä»£ç ç»„ç»‡ï¼š
- å‡½æ•°åŠŸèƒ½å•ä¸€ï¼Œä¾¿äºæµ‹è¯•å’Œå¤ç”¨
- ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡å
- é€‚å½“çš„æ³¨é‡Šè¯´æ˜å¤æ‚é€»è¾‘

é”™è¯¯å¤„ç†ï¼š
- æ£€æŸ¥å‡½æ•°å‚æ•°çš„æœ‰æ•ˆæ€§
- å¤„ç†æ–‡ä»¶æ“ä½œçš„å¼‚å¸¸æƒ…å†µ
- æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯

æµ‹è¯•ç­–ç•¥ï¼š
- è¾¹ç•Œæ¡ä»¶æµ‹è¯•
- å¤§æ•°æ®é‡æµ‹è¯•
- æ€§èƒ½åŸºå‡†æµ‹è¯•
```

**ğŸ¯ é¡¹ç›®åº”ç”¨åœºæ™¯**
- **æ•°æ®åˆ†æ**ï¼šæ—¥å¿—åˆ†æã€ç»Ÿè®¡æŠ¥è¡¨ã€æ•°æ®æ¸…æ´—
- **ç³»ç»Ÿå·¥å…·**ï¼šé…ç½®å¤„ç†ã€ç›‘æ§è„šæœ¬ã€è‡ªåŠ¨åŒ–ä»»åŠ¡
- **æ–‡æœ¬å¤„ç†**ï¼šæ ¼å¼è½¬æ¢ã€å†…å®¹æå–ã€æ¨¡å¼åŒ¹é…
- **ç®—æ³•å®ç°**ï¼šåŸå‹å¼€å‘ã€ç®—æ³•éªŒè¯ã€æ•™å­¦æ¼”ç¤º

### 9.4 å­¦ä¹ è¿›é˜¶è·¯å¾„


**ğŸ“š æŠ€èƒ½æå‡é¡ºåº**
```
åˆçº§ï¼šæŒæ¡åŸºæœ¬è¯­æ³•å’Œå¸¸ç”¨å‡½æ•°
ä¸­çº§ï¼šç†è§£é€’å½’å’ŒåŠ¨æ€ç¼–ç¨‹æ€æƒ³
é«˜çº§ï¼šèƒ½å¤Ÿè®¾è®¡å¤æ‚çš„æ•°æ®ç»“æ„å’Œç®—æ³•
ä¸“å®¶ï¼šä¼˜åŒ–æ€§èƒ½ï¼Œå¤„ç†å¤§è§„æ¨¡æ•°æ®
```

**ğŸ”— ç›¸å…³æŠ€æœ¯æ‹“å±•**
- **shellè„šæœ¬**ï¼šä¸awké…åˆä½¿ç”¨
- **æ­£åˆ™è¡¨è¾¾å¼**ï¼šé«˜çº§æ¨¡å¼åŒ¹é…
- **æ•°æ®ç»“æ„ä¸ç®—æ³•**ï¼šè®¡ç®—æœºç§‘å­¦åŸºç¡€
- **å‡½æ•°å¼ç¼–ç¨‹**ï¼šawkçš„å‡½æ•°å¼ç‰¹æ€§

**æ ¸å¿ƒè®°å¿†è¦ç‚¹**ï¼š
- awkæ˜¯å®Œæ•´ç¼–ç¨‹è¯­è¨€ï¼Œä¸åªæ˜¯æ–‡æœ¬å·¥å…·
- é€’å½’è§£å†³åˆ†å±‚é—®é¢˜ï¼ŒåŠ¨æ€ç¼–ç¨‹ä¼˜åŒ–é‡å¤è®¡ç®—  
- å…³è”æ•°ç»„æ˜¯awkçš„æ ¸å¿ƒæ•°æ®ç»“æ„
- ç®—æ³•é€‰æ‹©æ¯”å®ç°ç»†èŠ‚æ›´é‡è¦
- å®è·µä¸­å­¦ä¹ ï¼Œåœ¨é¡¹ç›®ä¸­æå‡æŠ€èƒ½