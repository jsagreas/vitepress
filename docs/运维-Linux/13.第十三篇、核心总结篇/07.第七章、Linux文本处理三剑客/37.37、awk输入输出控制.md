---
title: 37、awk输入输出控制
---
## 📚 目录

1. [awk输入输出基础概念](#1-awk输入输出基础概念)
2. [标准输入读取技术](#2-标准输入读取技术)
3. [文件输入处理详解](#3-文件输入处理详解)
4. [输出重定向技术](#4-输出重定向技术)
5. [管道输出操作](#5-管道输出操作)
6. [格式化输出printf详解](#6-格式化输出printf详解)
7. [多文件处理技术](#7-多文件处理技术)
8. [输入记录控制机制](#8-输入记录控制机制)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 awk输入输出基础概念


### 1.1 什么是awk的输入输出控制


**直观理解**：awk的输入输出控制就像水龙头和水管系统
```
输入 → awk处理 → 输出
💧     🔧      💧
从哪读 → 怎么处理 → 往哪写
```

**核心概念**：
- **输入控制**：决定awk从哪里读取数据，怎么读
- **输出控制**：决定处理后的数据往哪里输出，怎么输出
- **记录和字段**：awk把输入看成一条条记录，每条记录分成若干字段

### 1.2 awk的数据处理模式


**工作流程**：
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│    输入源    │───→│  awk处理器   │───→│   输出目标   │
│             │    │             │    │             │
│ • 标准输入   │    │ • 模式匹配   │    │ • 标准输出   │
│ • 文件输入   │    │ • 动作执行   │    │ • 文件输出   │
│ • 管道输入   │    │ • 变量操作   │    │ • 管道输出   │
└─────────────┘    └─────────────┘    └─────────────┘
```

> 💡 **核心理解**：awk是一个流处理器，逐行读取输入，对每行执行模式匹配和动作处理

### 1.3 输入输出的基本术语


| 术语 | 含义 | 举例 |
|-----|-----|------|
| **记录(Record)** | 输入的一行数据 | `张三 25 北京` |
| **字段(Field)** | 记录中的一个数据项 | `张三`是第1个字段 |
| **分隔符(Separator)** | 字段之间的分隔字符 | 空格、逗号、制表符 |
| **重定向(Redirect)** | 改变输出目标 | 输出到文件而不是屏幕 |

---

## 2. 📥 标准输入读取技术


### 2.1 什么是标准输入


**生活类比**：标准输入就像你面前的键盘，别人通过键盘给你"喂"数据

**技术含义**：
- **标准输入(stdin)**：程序默认的数据来源，通常是键盘输入
- **在awk中**：如果不指定文件，awk就从标准输入读取数据

### 2.2 从标准输入读取数据


**基本用法**：
```bash
# 直接从键盘输入（按Ctrl+D结束）
awk '{print "你输入了:", $0}'

# 从管道输入
echo "hello world" | awk '{print "接收到:", $0}'

# 从命令输出输入
ls -l | awk '{print "文件:", $9}'
```

**实际应用场景**：
```bash
# 实时处理日志
tail -f /var/log/nginx/access.log | awk '{print $1, $7}' 

# 统计当前进程
ps aux | awk '{sum += $3} END {print "CPU总使用率:", sum"%"}'
```

### 2.3 交互式标准输入处理


**在脚本中读取用户输入**：
```bash
# 创建交互式awk脚本
awk '
BEGIN { print "请输入姓名和年龄，用空格分隔:" }
{
    if (NF >= 2) {
        print "姓名:", $1, "年龄:", $2
        if ($2 >= 18) print "已成年"
        else print "未成年"
    }
}
'
```

> ⚠️ **注意事项**：从标准输入读取时，awk会等待输入，直到遇到EOF(Ctrl+D)或者管道结束

---

## 3. 📁 文件输入处理详解


### 3.1 单文件输入处理


**基本语法**：
```bash
awk 'pattern { action }' filename
```

**实际示例**：
```bash
# 假设有一个员工信息文件 employees.txt
# 张三 25 销售部 5000
# 李四 30 技术部 8000
# 王五 28 市场部 6000

# 处理单个文件
awk '{print $1, "的工资是", $4}' employees.txt
```

**文件处理的内置变量**：

| 变量 | 含义 | 示例值 |
|-----|-----|--------|
| `FILENAME` | 当前处理的文件名 | `employees.txt` |
| `FNR` | 当前文件中的行号 | `1, 2, 3...` |
| `NR` | 总的记录行号 | `1, 2, 3...` |
| `NF` | 当前记录的字段数 | `4` |

### 3.2 读取不存在文件的处理


**错误处理技巧**：
```bash
# awk会自动报错并跳过不存在的文件
awk '{print $0}' file1.txt nonexistent.txt file2.txt

# 在BEGIN中检查文件是否存在
awk 'BEGIN {
    if ((getline < "test.txt") < 0) {
        print "文件不存在或无法读取"
        exit 1
    }
    close("test.txt")
}'
```

### 3.3 按条件读取文件内容


**模式匹配读取**：
```bash
# 只处理包含特定内容的行
awk '/技术部/ {print $1, "是技术人员"}' employees.txt

# 按字段值过滤
awk '$4 > 6000 {print $1, "高薪员工"}' employees.txt

# 按行号处理
awk 'NR >= 2 && NR <= 5 {print "第" NR "行:", $0}' data.txt
```

---

## 4. 📤 输出重定向技术


### 4.1 输出重定向基本概念


**什么是输出重定向**：
- **默认情况**：awk的输出显示在屏幕上（标准输出）
- **重定向后**：输出保存到文件或发送给其他程序

**重定向符号**：
```
>   ：覆盖写入文件
>>  ：追加写入文件  
|   ：通过管道传递给其他程序
```

### 4.2 输出到文件


**覆盖写入**：
```bash
# 将处理结果保存到文件
awk '{print $1, $4}' employees.txt > salary_list.txt

# 在awk内部重定向
awk '{print $1, $4 > "salary.txt"}' employees.txt
```

**追加写入**：
```bash
# 追加到现有文件
awk '{print $1, $4}' new_employees.txt >> salary_list.txt

# awk内部追加
awk '{print $1, $4 >> "salary.txt"}' employees.txt
```

### 4.3 条件输出到不同文件


**根据条件分别输出**：
```bash
# 根据部门分别保存到不同文件
awk '{
    if ($3 == "技术部") 
        print $0 > "tech_dept.txt"
    else if ($3 == "销售部")
        print $0 > "sales_dept.txt"
    else
        print $0 > "other_dept.txt"
}' employees.txt
```

**按薪资水平分类**：
```bash
awk '{
    if ($4 >= 8000) 
        print $1, $4 > "high_salary.txt"
    else if ($4 >= 5000)
        print $1, $4 > "medium_salary.txt"
    else
        print $1, $4 > "low_salary.txt"
}' employees.txt
```

> ⚠️ **重要提醒**：使用awk内部重定向时，记得在END中关闭文件句柄

```bash
awk '{
    print $0 > "output.txt"
} 
END {
    close("output.txt")
}' input.txt
```

---

## 5. 🔄 管道输出操作


### 5.1 管道输出基本概念


**什么是管道输出**：
- **管道（|）**：把一个程序的输出当作另一个程序的输入
- **在awk中**：可以把处理结果传递给其他命令进一步处理

```
awk处理 | 其他命令
   👆           👆
 输出数据     接收并处理
```

### 5.2 基本管道输出操作


**输出到排序命令**：
```bash
# 按薪资排序
awk '{print $4, $1}' employees.txt | sort -n

# 按姓名排序
awk '{print $1, $4}' employees.txt | sort
```

**输出到统计命令**：
```bash
# 统计行数
awk '/技术部/' employees.txt | wc -l

# 查看前几条记录
awk '$4 > 7000' employees.txt | head -5
```

### 5.3 awk内部管道输出


**在awk程序内使用管道**：
```bash
# 直接在awk内部使用管道
awk '{
    print $1, $4 | "sort -k2 -n"
}' employees.txt

# 输出到多个命令
awk '{
    if ($4 > 7000) {
        print $1, $4 | "sort > high_earners.txt"
    }
}' employees.txt
```

**复杂管道处理**：
```bash
# 统计各部门平均工资
awk '{
    dept_sum[$3] += $4
    dept_count[$3]++
}
END {
    for (dept in dept_sum) {
        avg = dept_sum[dept] / dept_count[dept]
        print dept, avg | "sort -k2 -nr"
    }
}' employees.txt
```

> 💡 **实用技巧**：记得关闭管道句柄以确保数据完全输出

```bash
awk '{
    print $0 | "sort"
}
END {
    close("sort")
}' data.txt
```

---

## 6. 🖨️ 格式化输出printf详解


### 6.1 printf vs print的区别


**print的特点**：
- **自动换行**：每次print后自动加换行符
- **简单输出**：直接输出内容，格式控制有限

**printf的特点**：
- **格式控制**：可以精确控制输出格式
- **不自动换行**：需要手动添加换行符`\n`
- **类似C语言**：格式字符串和C语言一样

### 6.2 printf格式字符串


**常用格式说明符**：

| 格式 | 含义 | 示例 | 输出 |
|-----|-----|------|-----|
| `%s` | 字符串 | `printf "%s\n", "hello"` | `hello` |
| `%d` | 整数 | `printf "%d\n", 123` | `123` |
| `%f` | 浮点数 | `printf "%f\n", 3.14` | `3.140000` |
| `%.2f` | 保留2位小数 | `printf "%.2f\n", 3.14159` | `3.14` |
| `%10s` | 右对齐，宽度10 | `printf "%10s\n", "hi"` | `        hi` |
| `%-10s` | 左对齐，宽度10 | `printf "%-10s\n", "hi"` | `hi        ` |

### 6.3 实际应用示例


**格式化员工信息表**：
```bash
awk 'BEGIN {
    printf "%-10s %-5s %-10s %10s\n", "姓名", "年龄", "部门", "工资"
    printf "%-10s %-5s %-10s %10s\n", "----", "----", "----", "----"
}
{
    printf "%-10s %-5d %-10s %10d\n", $1, $2, $3, $4
}' employees.txt
```

**输出效果**：
```
姓名         年龄  部门         工资
----         ----  ----         ----
张三         25    销售部           5000
李四         30    技术部           8000
王五         28    市场部           6000
```

### 6.4 printf的高级用法


**格式化数字**：
```bash
# 金额格式化（千分位分隔符需要其他处理）
awk '{
    printf "员工%s的工资是 %.2f 元\n", $1, $4
}' employees.txt

# 百分比显示
awk '{
    rate = $4 / 10000
    printf "%s的工资占比: %6.2f%%\n", $1, rate * 100
}' employees.txt
```

**条件格式化**：
```bash
awk '{
    if ($4 >= 8000)
        printf "🌟 %-10s: %6d (高薪)\n", $1, $4
    else if ($4 >= 6000)
        printf "⭐ %-10s: %6d (中薪)\n", $1, $4
    else
        printf "   %-10s: %6d (基薪)\n", $1, $4
}' employees.txt
```

> 💡 **记忆技巧**：printf = print + format，需要什么格式就指定什么格式符

---

## 7. 📚 多文件处理技术


### 7.1 多文件处理基本概念


**什么是多文件处理**：
- **一次处理多个文件**：awk可以同时处理多个输入文件
- **文件间的关联处理**：可以根据文件内容进行关联分析
- **顺序处理**：按命令行指定的顺序依次处理文件

### 7.2 基本多文件处理


**处理多个文件**：
```bash
# 处理多个员工数据文件
awk '{print FILENAME, NR, $1, $4}' dept1.txt dept2.txt dept3.txt

# 统计所有文件的总行数
awk 'END {print "总共处理了", NR, "行记录"}' *.txt
```

**区分文件的内置变量**：

| 变量 | 含义 | 说明 |
|-----|-----|------|
| `FILENAME` | 当前文件名 | 正在处理的文件名 |
| `FNR` | 当前文件内行号 | 每个文件都从1开始 |
| `NR` | 总记录行号 | 跨文件累计计数 |

### 7.3 按文件分别统计


**为每个文件生成统计**：
```bash
awk '{
    file_sum[FILENAME] += $4
    file_count[FILENAME]++
}
END {
    for (file in file_sum) {
        avg = file_sum[file] / file_count[file]
        printf "%s: 平均工资 %.2f\n", file, avg
    }
}' dept*.txt
```

**按文件分别处理不同逻辑**：
```bash
awk '{
    if (FILENAME == "current_employees.txt") {
        current[$1] = $4  # 记录现有员工工资
    } else if (FILENAME == "new_employees.txt") {
        if ($1 in current) {
            printf "%s 工资从 %d 变为 %d\n", $1, current[$1], $4
        } else {
            printf "%s 新入职，工资 %d\n", $1, $4
        }
    }
}' current_employees.txt new_employees.txt
```

### 7.4 文件间数据关联


**主从文件关联**：
```bash
# 员工基本信息文件：employees.txt (姓名 年龄 部门)
# 工资信息文件：salaries.txt (姓名 工资)

awk '
FNR == NR {  # 处理第一个文件
    salary[$1] = $2  # 建立姓名到工资的映射
    next
}
{  # 处理第二个文件
    if ($1 in salary) {
        printf "%-10s %3d %-10s %8d\n", $1, $2, $3, salary[$1]
    } else {
        printf "%-10s %3d %-10s %8s\n", $1, $2, $3, "未知"
    }
}' salaries.txt employees.txt
```

> 🔑 **核心技巧**：`FNR == NR` 表示正在处理第一个文件，`FNR != NR` 表示处理后续文件

---

## 8. 📋 输入记录控制机制


### 8.1 记录分隔符(RS)控制


**什么是记录分隔符**：
- **默认情况**：awk把每一行当作一条记录
- **自定义RS**：可以改变记录的分界标准

**基本用法**：
```bash
# 默认按行分割
awk '{print "记录" NR ":", $0}' data.txt

# 按段落分割（空行分割）
awk 'BEGIN {RS=""} {print "段落" NR ":", $0}' document.txt

# 按特定字符分割
awk 'BEGIN {RS=","} {print "项目" NR ":", $0}' items.txt
```

### 8.2 字段分隔符(FS)控制


**字段分隔符的作用**：
- **默认分隔符**：空格或制表符
- **自定义分隔符**：根据数据格式设置合适的分隔符

**常用分隔符设置**：
```bash
# CSV文件处理（逗号分隔）
awk 'BEGIN {FS=","} {print $1, $3}' data.csv

# 冒号分隔（如/etc/passwd文件）
awk 'BEGIN {FS=":"} {print $1, $7}' /etc/passwd

# 多字符分隔符
awk 'BEGIN {FS=" :: "} {print $1, $2}' data.txt
```

### 8.3 输出记录分隔符(ORS)控制


**输出记录分隔符**：
- **默认ORS**：换行符`\n`
- **自定义ORS**：改变输出记录间的分隔方式

```bash
# 用逗号分隔输出
awk 'BEGIN {ORS=", "} {print $1}' names.txt

# 每5个记录换一行
awk 'BEGIN {ORS=""} {print $1; if (NR % 5 == 0) print "\n"}' data.txt
```

### 8.4 输出字段分隔符(OFS)控制


**控制输出字段间的分隔**：
```bash
# 用制表符分隔输出
awk 'BEGIN {OFS="\t"} {print $1, $2, $3}' data.txt

# 用特定字符串分隔
awk 'BEGIN {OFS=" | "} {print $1, $2, $4}' employees.txt
```

### 8.5 getline高级输入控制


**什么是getline**：
- **主动读取**：不等awk自动读取下一行，主动获取输入
- **灵活控制**：可以从不同来源读取数据

**基本getline用法**：
```bash
# 读取下一行
awk '{
    print "当前行:", $0
    if (getline > 0) {
        print "下一行:", $0
    }
}' data.txt

# 从文件读取
awk 'BEGIN {
    while ((getline line < "config.txt") > 0) {
        print "配置:", line
    }
    close("config.txt")
}'
```

**getline返回值含义**：
- **返回值 > 0**：成功读取到数据
- **返回值 = 0**：到达文件末尾
- **返回值 < 0**：读取出错

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 输入控制：标准输入、文件输入、getline主动读取
🔸 输出控制：标准输出、文件重定向、管道输出
🔸 格式化输出：printf精确控制输出格式
🔸 多文件处理：FILENAME、FNR、NR变量的区别和应用
🔸 记录控制：RS、FS、ORS、OFS四个分隔符的作用
```

### 9.2 关键理解要点


**🔹 输入输出的本质**：
```
输入控制 = 数据从哪来，怎么读
输出控制 = 数据到哪去，怎么写
awk就是一个数据流处理的中间环节
```

**🔹 记录和字段的关系**：
```
记录 = 一行数据（可通过RS改变）
字段 = 记录中的数据项（通过FS分割）
理解这个关系是掌握awk的基础
```

**🔹 多文件处理的核心**：
```
FNR == NR ：正在处理第一个文件
FNR != NR ：正在处理后续文件
这是文件关联处理的关键技巧
```

### 9.3 实际应用指导


**输入场景选择**：
- ✅ **实时数据**：使用管道输入 `command | awk`
- ✅ **大文件**：直接文件输入 `awk 'script' file`
- ✅ **用户交互**：标准输入等待用户输入
- ✅ **精确控制**：getline主动读取

**输出场景选择**：
- ✅ **查看结果**：默认标准输出到屏幕
- ✅ **保存数据**：重定向到文件 `> file`
- ✅ **进一步处理**：管道给其他命令 `| command`
- ✅ **格式要求**：使用printf精确格式化

### 9.4 常用模式和最佳实践


**文件关联模式**：
```bash
# 模式：第一个文件建立映射，后续文件使用映射
awk 'FNR==NR{mapping[$1]=$2; next} {print $1, mapping[$1]}' file1 file2
```

**分类输出模式**：
```bash
# 模式：根据条件输出到不同文件
awk '{
    if (condition1) print > "type1.txt"
    else if (condition2) print > "type2.txt"
    else print > "others.txt"
}'
```

**统计报告模式**：
```bash
# 模式：边处理边统计，END中输出报告
awk '{stats[key] += value} END {for(i in stats) printf "%s: %d\n", i, stats[i]}'
```

### 9.5 调试和优化建议


**调试技巧**：
- 🔍 添加调试输出：`{print "DEBUG:", FILENAME, NR, $0}`
- 🔍 检查变量值：`{printf "变量x=%s\n", x > "/dev/stderr"}`
- 🔍 分步验证：先用简单脚本验证逻辑

**性能优化**：
- ⚡ 早期过滤：在模式部分过滤，减少动作执行
- ⚡ 合理使用next：跳过不需要的处理
- ⚡ 及时关闭文件句柄：避免打开太多文件

**核心记忆**：
- awk是流处理器，逐记录处理
- 输入控制决定数据来源，输出控制决定数据去向
- printf提供精确格式控制，getline提供主动读取
- 多文件处理关键在于理解FNR和NR的区别
- 四个分隔符(RS/FS/ORS/OFS)控制记录和字段的定义