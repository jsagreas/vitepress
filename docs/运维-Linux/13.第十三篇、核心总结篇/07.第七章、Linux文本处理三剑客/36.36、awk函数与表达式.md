---
title: 36、awk函数与表达式
---
## 📚 目录

1. [awk函数系统概述](#1-awk函数系统概述)
2. [字符串处理函数](#2-字符串处理函数)
3. [数学运算函数](#3-数学运算函数)
4. [字符串替换与分割函数](#4-字符串替换与分割函数)
5. [格式化输出函数](#5-格式化输出函数)
6. [自定义函数设计](#6-自定义函数设计)
7. [表达式与运算符](#7-表达式与运算符)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 awk函数系统概述


### 1.1 awk函数的作用


**什么是awk函数？**
```
awk函数就像工具箱里的各种专用工具：
• 每个函数都有特定的用途
• 输入原始数据，输出处理结果
• 让复杂的文本处理变得简单
```

> 💡 **通俗理解**  
> 就像我们用计算器的各种功能键（开方、三角函数等），awk的函数就是文本处理的各种"功能键"

### 1.2 awk函数分类体系


```
awk函数体系架构：

文本处理类
├── 字符串操作 → length, substr, index
├── 字符串替换 → sub, gsub, gensub
├── 字符串分割 → split
└── 格式化输出 → printf, sprintf

数值计算类
├── 基础数学 → sqrt, int, rand
├── 三角函数 → sin, cos, tan
└── 对数指数 → log, exp

自定义扩展
└── 用户自定义函数 → function name() {}
```

**📋 函数调用的基本语法：**
- `函数名(参数1, 参数2, ...)`
- 参数可以是变量、字符串、表达式
- 大多数函数都有返回值

---

## 2. 📝 字符串处理函数


### 2.1 length函数 - 字符串长度测量


**基本用法：** `length(字符串)`

**作用：** 计算字符串的字符个数

```bash
# 基本示例
echo "Hello World" | awk '{print length($0)}'
# 输出: 11

# 计算每行长度
cat file.txt | awk '{print "第" NR "行长度:", length($0)}'

# 找出最长的行
awk 'length > max {max = length; longest = $0} END {print "最长行:", longest, "长度:", max}' file.txt
```

> 🎯 **实际应用场景**  
> - 检查密码长度是否符合要求  
> - 找出文件中最长/最短的行  
> - 统计文本内容的字符分布

### 2.2 substr函数 - 字符串截取


**基本语法：** `substr(字符串, 起始位置, 长度)`

**重要说明：**
- 起始位置从1开始计算（不是0）
- 长度参数可选，省略则取到字符串末尾
- 如果起始位置超出字符串长度，返回空字符串

```bash
# 基本截取示例
echo "Hello World" | awk '{print substr($0, 1, 5)}'
# 输出: Hello

echo "Hello World" | awk '{print substr($0, 7)}'
# 输出: World

# 提取文件扩展名
echo "document.txt" | awk '{
    dot_pos = index($0, ".")
    if (dot_pos > 0) {
        ext = substr($0, dot_pos + 1)
        print "扩展名:", ext
    }
}'
```

**📊 常用截取模式：**

| 用法 | 含义 | 示例 | 结果 |
|------|------|------|------|
| `substr(s, 1, 3)` | 取前3个字符 | substr("Hello", 1, 3) | "Hel" |
| `substr(s, 4)` | 从第4个字符到末尾 | substr("Hello", 4) | "lo" |
| `substr(s, -2)` | 取后2个字符 | substr("Hello", length(s)-1) | "lo" |

### 2.3 index函数 - 字符串查找


**基本语法：** `index(字符串, 子字符串)`

**返回值：**
- 找到：返回子字符串首次出现的位置（从1开始）
- 没找到：返回0

```bash
# 基本查找示例
echo "Hello World" | awk '{
    pos = index($0, "World")
    if (pos > 0) {
        print "找到World在位置:", pos
    } else {
        print "没有找到World"
    }
}'

# 检查文件类型
ls -la | awk '{
    if (index($0, ".txt") > 0) {
        print $0, "← 文本文件"
    }
}'
```

> ⚠️ **注意事项**  
> - index函数区分大小写  
> - 只能找到第一次出现的位置  
> - 如果要找最后出现的位置，需要其他方法

---

## 3. 🔢 数学运算函数


### 3.1 基础数学函数


**常用数学函数一览：**

```
sqrt(x)    → 平方根
int(x)     → 取整数部分
rand()     → 0到1之间的随机数
srand(x)   → 设置随机数种子
```

```bash
# 数学计算示例
echo "16 25 36" | awk '{
    for (i = 1; i <= NF; i++) {
        printf "%d的平方根是: %.2f\n", $i, sqrt($i)
    }
}'

# 随机数生成
awk 'BEGIN {
    srand()  # 设置随机种子
    for (i = 1; i <= 5; i++) {
        print "随机数" i ":", int(rand() * 100)
    }
}'
```

### 3.2 三角函数


**三角函数系列：**
- `sin(x)` - 正弦值（x为弧度）
- `cos(x)` - 余弦值
- `atan2(y, x)` - 反正切值

```bash
# 计算角度的三角函数值
awk 'BEGIN {
    pi = 3.14159
    angle = 30  # 30度
    radian = angle * pi / 180  # 转换为弧度
    
    printf "30度的正弦值: %.4f\n", sin(radian)
    printf "30度的余弦值: %.4f\n", cos(radian)
}'
```

---

## 4. 🔄 字符串替换与分割函数


### 4.1 sub函数 - 单次替换


**语法：** `sub(正则表达式, 替换字符串, 目标字符串)`

**特点：** 只替换第一个匹配的内容

```bash
# 基本替换示例
echo "hello world hello" | awk '{
    sub(/hello/, "hi", $0)
    print $0
}'
# 输出: hi world hello

# 替换每行第一个数字
echo -e "abc123def456\nxy789z123" | awk '{
    sub(/[0-9]+/, "[NUM]", $0)
    print $0
}'
```

### 4.2 gsub函数 - 全局替换


**语法：** `gsub(正则表达式, 替换字符串, 目标字符串)`

**特点：** 替换所有匹配的内容

```bash
# 全局替换示例
echo "hello world hello" | awk '{
    gsub(/hello/, "hi", $0)
    print $0
}'
# 输出: hi world hi

# 清理数据：移除所有空格
echo "a b c d e" | awk '{
    gsub(/ /, "", $0)
    print $0
}'
# 输出: abcde
```

**📋 sub与gsub对比：**

| 函数 | 替换次数 | 适用场景 | 示例 |
|------|----------|----------|------|
| `sub` | 只替换第一个 | 修正格式、添加前缀 | 给每行加标题 |
| `gsub` | 替换所有匹配 | 数据清理、格式统一 | 删除所有空格 |

### 4.3 split函数 - 字符串分割


**语法：** `split(字符串, 数组, 分隔符)`

**返回值：** 分割后的数组元素个数

```bash
# 基本分割示例
echo "apple,banana,orange" | awk '{
    n = split($0, fruits, ",")
    for (i = 1; i <= n; i++) {
        print "水果" i ":", fruits[i]
    }
}'

# 处理路径
echo "/home/user/documents/file.txt" | awk '{
    n = split($0, path_parts, "/")
    print "文件名:", path_parts[n]
    print "目录数:", n-1
}'
```

> 💡 **实用技巧**  
> split函数创建的数组下标从1开始，这与其他编程语言的0开始不同

---

## 5. 📄 格式化输出函数


### 5.1 printf函数 - 格式化打印


**基本概念：** printf让你精确控制输出格式，就像调整打印机的各种设置

**常用格式说明符：**

```
%s    → 字符串
%d    → 整数
%f    → 浮点数
%c    → 字符
%.2f  → 保留2位小数
%10s  → 占10个字符宽度的字符串
%-10s → 左对齐的10字符宽度字符串
```

```bash
# 格式化输出示例
awk 'BEGIN {
    name = "张三"
    age = 25
    score = 98.67
    
    printf "姓名: %s\n", name
    printf "年龄: %d岁\n", age  
    printf "成绩: %.1f分\n", score
}'

# 创建表格式输出
echo -e "张三 25 98.5\n李四 30 87.2\n王五 22 95.8" | awk '{
    printf "| %-8s | %3d岁 | %6.1f分 |\n", $1, $2, $3
}'
```

### 5.2 sprintf函数 - 格式化字符串


**作用：** sprintf不直接输出，而是返回格式化后的字符串

```bash
# sprintf示例
awk 'BEGIN {
    formatted = sprintf("今天是%d年%d月%d日", 2024, 3, 15)
    print formatted
    print "长度:", length(formatted)
}'

# 生成文件名
ls -la | awk 'NR > 1 {
    new_name = sprintf("backup_%s_%d", $9, NR)
    printf "原文件: %s → 新文件: %s\n", $9, new_name
}'
```

**📊 printf vs sprintf 对比：**

| 函数 | 输出方式 | 返回值 | 适用场景 |
|------|----------|--------|----------|
| `printf` | 直接输出到屏幕 | 无 | 直接显示结果 |
| `sprintf` | 返回字符串 | 格式化的字符串 | 生成字符串供后续使用 |

---

## 6. 🛠️ 自定义函数设计


### 6.1 为什么需要自定义函数？


**问题：** 当我们需要重复执行某个复杂操作时，每次都写一遍很麻烦

**解决方案：** 把常用的操作封装成函数，就像制作一个专用工具

### 6.2 自定义函数的基本语法


```
function 函数名(参数1, 参数2, ...) {
    # 函数体
    return 返回值  # 可选
}
```

**📝 简单示例：**

```bash
# 自定义函数示例
awk '
function max(a, b) {
    if (a > b) 
        return a
    else 
        return b
}

function min(a, b) {
    return (a < b) ? a : b
}

BEGIN {
    print "最大值:", max(10, 20)
    print "最小值:", min(10, 20)
}
'
```

### 6.3 实用自定义函数示例


```bash
# 复杂的自定义函数
awk '
# 判断是否为闰年
function is_leap_year(year) {
    if (year % 400 == 0) return 1
    if (year % 100 == 0) return 0  
    if (year % 4 == 0) return 1
    return 0
}

# 清理字符串（去掉首尾空格）
function trim(str) {
    gsub(/^[ \t]+|[ \t]+$/, "", str)
    return str
}

# 计算字符串中某字符的出现次数
function count_char(str, char) {
    count = 0
    for (i = 1; i <= length(str); i++) {
        if (substr(str, i, 1) == char) {
            count++
        }
    }
    return count
}

BEGIN {
    test_str = "  hello world  "
    print "原字符串: [" test_str "]"
    print "清理后: [" trim(test_str) "]"
    print "字母l出现次数:", count_char(test_str, "l")
    print "2024年是闰年吗?", is_leap_year(2024)
}
'
```

### 6.4 函数参数传递机制


**重要概念：** awk中参数传递分两种情况

```
值传递（数字、字符串）：
• 传递的是值的副本
• 在函数内修改不影响原变量

引用传递（数组）：  
• 传递的是引用
• 在函数内修改会影响原数组
```

```bash
# 参数传递示例
awk '
function modify_value(x) {
    x = x + 100
    return x
}

function modify_array(arr) {
    arr[1] = "已修改"
}

BEGIN {
    # 值传递测试
    num = 50
    result = modify_value(num)
    print "原数值:", num, "函数返回:", result
    
    # 数组传递测试  
    my_array[1] = "原始值"
    modify_array(my_array)
    print "数组值:", my_array[1]
}
'
```

---

## 7. ⚡ 表达式与运算符


### 7.1 算术运算符


**基本运算符一览：**

| 运算符 | 含义 | 示例 | 结果 |
|--------|------|------|------|
| `+` | 加法 | `5 + 3` | 8 |
| `-` | 减法 | `10 - 4` | 6 |
| `*` | 乘法 | `6 * 7` | 42 |
| `/` | 除法 | `15 / 3` | 5 |
| `%` | 取余 | `17 % 5` | 2 |
| `^` 或 `**` | 幂运算 | `2^3` | 8 |

```bash
# 算术运算示例
echo "15 4" | awk '{
    a = $1; b = $2
    print a " + " b " = " (a + b)
    print a " - " b " = " (a - b)  
    print a " * " b " = " (a * b)
    print a " / " b " = " (a / b)
    print a " % " b " = " (a % b)
    print a "^" b " = " (a^b)
}'
```

### 7.2 比较运算符


```
<     小于
<=    小于等于  
>     大于
>=    大于等于
==    等于
!=    不等于
~     匹配正则表达式
!~    不匹配正则表达式
```

```bash
# 比较运算示例
echo -e "apple\nbanana\ncherry" | awk '{
    if ($0 ~ /^a/) {
        print $0, "以a开头"
    } else if (length($0) >= 6) {
        print $0, "长度>=6"  
    } else {
        print $0, "其他"
    }
}'
```

### 7.3 逻辑运算符


**逻辑运算符：**
- `&&` - 逻辑与
- `||` - 逻辑或  
- `!` - 逻辑非

```bash
# 复合条件判断
awk 'BEGIN {
    score = 85
    age = 20
    
    if (score >= 80 && age >= 18) {
        print "符合条件：成绩优秀且成年"
    }
    
    if (score < 60 || age < 16) {
        print "不符合标准"
    } else {
        print "基本符合要求"
    }
}'
```

### 7.4 条件运算符（三元运算符）


**语法：** `条件 ? 真值 : 假值`

```bash
# 三元运算符示例
echo -e "85\n45\n92" | awk '{
    grade = ($1 >= 60) ? "及格" : "不及格"
    level = ($1 >= 90) ? "优秀" : ($1 >= 80) ? "良好" : ($1 >= 60) ? "及格" : "不及格"
    printf "分数: %d, 结果: %s, 等级: %s\n", $1, grade, level
}'
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的函数


> 🎯 **字符串处理核心三剑客**
> - `length()` - 测量长度
> - `substr()` - 精确截取  
> - `index()` - 定位查找

> 🔧 **文本替换双子星**
> - `sub()` - 单次替换，适合修正
> - `gsub()` - 全局替换，适合清理

> 📊 **格式化输出利器**
> - `printf()` - 直接格式化输出
> - `sprintf()` - 返回格式化字符串

### 8.2 函数使用要点


**🔹 参数位置规律**
```
多数字符串函数的参数顺序：
函数名(源字符串, 操作参数, 目标字符串)
• length(string)
• substr(string, start, length)  
• sub(regex, replacement, target)
```

**🔹 数组下标规律**
```
awk中的下标都从1开始：
• substr的起始位置从1开始
• split产生的数组下标从1开始
• 这与C语言等从0开始不同
```

**🔹 返回值规律**
```
函数返回值的含义：
• 查找类函数：找到返回位置(>0)，没找到返回0
• 计数类函数：返回处理的数量
• 转换类函数：返回转换结果
```

### 8.3 实际应用指导


**📝 选择函数的思路：**
1. **文本截取** → 用`substr()`
2. **查找位置** → 用`index()`  
3. **内容替换** → 单次用`sub()`，多次用`gsub()`
4. **分词处理** → 用`split()`
5. **格式输出** → 用`printf()`
6. **重复逻辑** → 写自定义函数

**⚠️ 常见陷阱避免：**
- substr的起始位置从1开始，不是0
- sub只替换第一个，需要全部替换用gsub
- printf不会自动换行，需要手动添加\n
- 自定义函数的参数传递要注意值传递和引用传递的区别

**核心记忆口诀：**
```
字符串处理找三友：length、substr、index真给力
替换修改sub与gsub：单次全局要分清  
格式输出printf牛：sprintf返回字符串
自定义函数解重复：封装逻辑提效率
```