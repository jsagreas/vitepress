---
title: 25、sed在系统管理中的应用
---
## 📚 目录


1. [配置文件修改管理](#1-配置文件修改管理)
2. [日志文件处理与分析](#2-日志文件处理与分析)
3. [批量文件更新操作](#3-批量文件更新操作)
4. [系统参数调整](#4-系统参数调整)
5. [服务配置管理](#5-服务配置管理)
6. [自动化部署脚本](#6-自动化部署脚本)
7. [运维任务自动化](#7-运维任务自动化)
8. [核心要点总结](#8-核心要点总结)

---

# 🎯 **sed在系统管理中的核心价值**



```
┌──────────────────────────────────────┐
│              系统管理员               │
├──────────────────────────────────────┤
│  配置修改  │  日志处理  │  批量更新   │
├──────────────────────────────────────┤
│              sed流编辑器              │
├──────────────────────────────────────┤
│  文件处理  │  文本替换  │  自动化     │
└──────────────────────────────────────┘
```

**sed的管理优势**：
- 🔧 **批量处理**：一次命令处理多个文件
- ⚡ **高效快速**：流式处理，内存占用小
- 🛡️ **安全可靠**：可预览结果再执行修改
- 🔄 **自动化友好**：完美集成到脚本中

---

## 1. 📝 配置文件修改管理



### 1.1 配置文件修改的核心原理



**什么是配置文件修改？**
配置文件修改就是调整系统或服务的配置参数，让程序按照我们的需求运行。

```
传统方式                     sed方式
┌─────────────┐            ┌─────────────┐
│ 1.备份文件  │     VS     │ 1.一条命令  │
│ 2.编辑器打开│            │ 2.自动备份  │
│ 3.查找位置  │            │ 3.批量修改  │
│ 4.手工修改  │            │ 4.脚本友好  │
│ 5.保存文件  │            └─────────────┘
└─────────────┘
```

### 1.2 SSH配置文件管理



**场景描述**：系统管理员需要快速调整SSH安全设置

**🔑 修改SSH端口号**：
```bash
# 查看当前SSH配置

sed -n '/^#\?Port/p' /etc/ssh/sshd_config

# 修改SSH端口为2022（先备份）

cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
sed -i 's/^#Port 22/Port 2022/' /etc/ssh/sshd_config
```

**💡 工作原理**：
- `^#Port 22`：找到以"#Port 22"开头的行
- 替换为`Port 2022`：去掉注释，修改端口号
- `-i`参数：直接修改原文件

**🔒 批量安全加固**：
```bash
#!/bin/bash

# SSH安全配置脚本


CONFIG_FILE="/etc/ssh/sshd_config"
BACKUP_FILE="${CONFIG_FILE}.backup.$(date +%Y%m%d)"

# 1. 备份原配置

cp "$CONFIG_FILE" "$BACKUP_FILE"

# 2. 批量安全配置

sed -i '
    s/^#PermitRootLogin.*/PermitRootLogin no/
    s/^#PasswordAuthentication.*/PasswordAuthentication no/
    s/^#PermitEmptyPasswords.*/PermitEmptyPasswords no/
    s/^#MaxAuthTries.*/MaxAuthTries 3/
' "$CONFIG_FILE"

echo "SSH配置已加固，备份文件：$BACKUP_FILE"
```

**🎯 核心概念解释**：
- **`PermitRootLogin no`**：禁止root用户直接登录
- **`PasswordAuthentication no`**：禁用密码登录，只允许密钥
- **`MaxAuthTries 3`**：最多允许3次登录尝试

### 1.3 Apache/Nginx配置管理



**📊 性能调优示例**：
```bash
# Apache性能调优

sed -i '
    /^MaxRequestWorkers/c\MaxRequestWorkers 400
    /^ThreadsPerChild/c\ThreadsPerChild 25
    /^Timeout/c\Timeout 30
' /etc/apache2/apache2.conf

# Nginx worker进程调整

CPU_CORES=$(nproc)
sed -i "s/worker_processes.*/worker_processes $CPU_CORES;/" /etc/nginx/nginx.conf
```

**⚙️ 理解要点**：
- **MaxRequestWorkers**：最大并发请求数
- **ThreadsPerChild**：每个进程的线程数
- **`nproc`命令**：获取CPU核心数，动态设置worker进程

### 1.4 数据库配置自动化



**🗄️ MySQL配置优化**：
```bash
#!/bin/bash

# MySQL性能优化脚本


MYSQL_CNF="/etc/mysql/mysql.conf.d/mysqld.cnf"
MEMORY_GB=$(free -g | awk '/^Mem:/{print $2}')

# 根据内存大小调整buffer pool

INNODB_BUFFER_SIZE=$((MEMORY_GB * 1024 * 70 / 100))  # 70%内存

sed -i "
    /innodb_buffer_pool_size/c\innodb_buffer_pool_size = ${INNODB_BUFFER_SIZE}M
    /max_connections/c\max_connections = 200
    /query_cache_size/c\query_cache_size = 128M
" "$MYSQL_CNF"

echo "MySQL已优化，Buffer Pool设置为 ${INNODB_BUFFER_SIZE}MB"
```

**💭 知识拓展**：
- **InnoDB Buffer Pool**：MySQL最重要的内存区域，缓存数据和索引
- **通常设置为系统内存的70-80%**：留给系统和其他程序足够内存

---

## 2. 📊 日志文件处理与分析



### 2.1 日志处理的重要性



**为什么要处理日志？**
- 🔍 **故障排查**：快速定位问题源头
- 📈 **性能监控**：分析系统负载情况  
- 🛡️ **安全审计**：发现异常访问行为
- 📊 **数据统计**：生成运营报告

```
日志文件特点：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│   文件大    │ →  │   增长快     │ →  │  格式规范   │
│ 几GB到几TB   │    │ 每天几百MB   │    │ 时间+内容   │
└─────────────┘    └──────────────┘    └─────────────┘
```

### 2.2 Web服务器日志分析



**🌐 Apache访问日志处理**：
```bash
# Apache日志格式示例

# 192.168.1.100 - - [19/Sep/2025:10:30:45 +0800] "GET /index.html HTTP/1.1" 200 2326


# 1. 提取今天的访问记录

TODAY=$(date +"%d/%b/%Y")
sed -n "/\[$TODAY/p" /var/log/apache2/access.log

# 2. 统计状态码分布

sed -n "/\[$TODAY/p" /var/log/apache2/access.log | \
sed 's/.*" \([0-9]\{3\}\) .*/\1/' | \
sort | uniq -c | sort -rn
```

**📈 结果解释**：
```
输出示例：
    500 200    # 500次成功请求（状态码200）
     50 404    # 50次页面未找到
     10 500    # 10次服务器错误
      5 403    # 5次访问被禁止
```

**🔥 热门页面统计**：
```bash
# 提取访问页面并统计

sed -n "/\[$TODAY/p" /var/log/apache2/access.log | \
sed 's/.*"GET \([^ ]*\) HTTP.*/\1/' | \
sort | uniq -c | sort -rn | head -10

# 输出示例：

#    150 /index.html

#     89 /products.html

#     67 /about.html

```

### 2.3 系统日志清理与轮转



**🗑️ 自动日志清理脚本**：
```bash
#!/bin/bash

# 日志清理脚本


LOG_DIR="/var/log"
DAYS_TO_KEEP=30

# 1. 清理过期的应用日志

find "$LOG_DIR" -name "*.log" -mtime +$DAYS_TO_KEEP -delete

# 2. 压缩大文件

find "$LOG_DIR" -name "*.log" -size +100M | while read -r logfile; do
    echo "压缩大文件: $logfile"
    gzip "$logfile"
done

# 3. 清理空行和格式化当前日志

sed -i '/^$/d' "$LOG_DIR"/app/*.log  # 删除空行
sed -i 's/\r$//' "$LOG_DIR"/app/*.log  # 删除Windows换行符
```

**⏰ 错误日志提取**：
```bash
# 提取最近1小时的错误

HOUR_AGO=$(date -d '1 hour ago' +'%Y-%m-%d %H')
sed -n "/$HOUR_AGO/,/$(date +'%Y-%m-%d %H')/p" /var/log/syslog | \
grep -i "error\|fail\|exception"
```

### 2.4 安全日志监控



**🛡️ 登录失败监控**：
```bash
#!/bin/bash

# SSH登录失败监控


LOG_FILE="/var/log/auth.log"
ALERT_THRESHOLD=5

# 统计最近1小时失败登录次数

FAILED_LOGINS=$(sed -n '/Failed password/p' "$LOG_FILE" | \
                sed -n "/$(date -d '1 hour ago' +'%b %d %H'):/,/$(date +'%b %d %H'):/p" | \
                wc -l)

if [ "$FAILED_LOGINS" -gt "$ALERT_THRESHOLD" ]; then
#    # 提取攻击IP
    sed -n '/Failed password/p' "$LOG_FILE" | \
    sed 's/.*from \([0-9.]*\) port.*/\1/' | \
    sort | uniq -c | sort -rn > /tmp/attack_ips.txt
    
    echo "⚠️ 警告：检测到 $FAILED_LOGINS 次登录失败"
    echo "Top攻击IP："
    head -5 /tmp/attack_ips.txt
fi
```

---

## 3. 🔄 批量文件更新操作



### 3.1 批量更新的应用场景



**实际工作中的需求**：
- 📝 **版本号更新**：软件发布时统一更新版本信息
- 🌐 **域名更换**：网站迁移时批量替换域名
- 🔧 **配置同步**：多服务器间配置文件同步
- 📊 **数据格式转换**：日志或数据文件格式调整

```
批量更新流程：
准备阶段 → 测试验证 → 批量执行 → 结果检查
    ↓         ↓         ↓         ↓
  制定规则   小范围试试   正式执行   验收结果
```

### 3.2 代码项目版本更新



**🏷️ 项目版本号批量更新**：
```bash
#!/bin/bash

# 项目版本更新脚本


OLD_VERSION="2.1.0"
NEW_VERSION="2.2.0"
PROJECT_ROOT="/opt/myproject"

# 1. 更新所有配置文件中的版本号

find "$PROJECT_ROOT" -name "*.conf" -o -name "*.properties" -o -name "*.xml" | \
while read -r file; do
    if grep -q "$OLD_VERSION" "$file"; then
        echo "更新文件: $file"
        sed -i "s/$OLD_VERSION/$NEW_VERSION/g" "$file"
    fi
done

# 2. 更新README和文档

sed -i "s/Version $OLD_VERSION/Version $NEW_VERSION/g" "$PROJECT_ROOT"/README.md
sed -i "s/v$OLD_VERSION/v$NEW_VERSION/g" "$PROJECT_ROOT"/docs/*.md

echo "✅ 版本更新完成: $OLD_VERSION → $NEW_VERSION"
```

### 3.3 网站域名迁移



**🌍 域名批量替换**：
```bash
#!/bin/bash

# 网站域名迁移脚本


OLD_DOMAIN="oldsite.com"
NEW_DOMAIN="newsite.com"
WEB_ROOT="/var/www/html"

# 1. 备份重要文件

BACKUP_DIR="/tmp/domain_migration_backup_$(date +%Y%m%d)"
mkdir -p "$BACKUP_DIR"
cp -r "$WEB_ROOT"/{*.html,*.php,*.js,*.css} "$BACKUP_DIR"/ 2>/dev/null

# 2. 批量替换HTML文件中的域名

find "$WEB_ROOT" -name "*.html" | while read -r htmlfile; do
    echo "处理: $htmlfile"
    sed -i "
        s|https\?://$OLD_DOMAIN|https://$NEW_DOMAIN|g
        s|www\.$OLD_DOMAIN|www.$NEW_DOMAIN|g
        s|//$OLD_DOMAIN|//$NEW_DOMAIN|g
    " "$htmlfile"
done

# 3. 更新配置文件

sed -i "s/$OLD_DOMAIN/$NEW_DOMAIN/g" "$WEB_ROOT"/.htaccess
sed -i "s/$OLD_DOMAIN/$NEW_DOMAIN/g" /etc/apache2/sites-available/*.conf

echo "🌐 域名迁移完成，备份位置: $BACKUP_DIR"
```

### 3.4 数据库配置文件同步



**🔄 多服务器配置同步**：
```bash
#!/bin/bash

# 多服务器配置同步脚本


SERVERS=("web01" "web02" "web03")
MASTER_CONFIG="/etc/app/master.conf"
LOCAL_CONFIG="/etc/app/app.conf"

# 读取主配置中的关键参数

DB_HOST=$(sed -n 's/^database_host=//p' "$MASTER_CONFIG")
DB_USER=$(sed -n 's/^database_user=//p' "$MASTER_CONFIG")
CACHE_SERVER=$(sed -n 's/^cache_server=//p' "$MASTER_CONFIG")

# 更新本地配置

sed -i "
    s/^database_host=.*/database_host=$DB_HOST/
    s/^database_user=.*/database_user=$DB_USER/
    s/^cache_server=.*/cache_server=$CACHE_SERVER/
" "$LOCAL_CONFIG"

# 同步到其他服务器

for server in "${SERVERS[@]}"; do
    echo "同步配置到服务器: $server"
    scp "$LOCAL_CONFIG" "$server:$LOCAL_CONFIG"
    ssh "$server" "systemctl restart app-service"
done
```

---

## 4. ⚙️ 系统参数调整



### 4.1 内核参数优化



**💻 系统性能调优**：
```bash
#!/bin/bash

# 系统内核参数优化脚本


SYSCTL_CONF="/etc/sysctl.conf"

# 备份原配置

cp "$SYSCTL_CONF" "${SYSCTL_CONF}.backup.$(date +%Y%m%d)"

# 网络性能优化

cat >> "$SYSCTL_CONF" << 'EOF'
# 网络优化参数

net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
EOF

# 如果已存在相同参数，则更新而不是追加

sed -i '/^net.core.rmem_max/c\net.core.rmem_max = 16777216' "$SYSCTL_CONF"
sed -i '/^net.core.wmem_max/c\net.core.wmem_max = 16777216' "$SYSCTL_CONF"

# 应用配置

sysctl -p
echo "✅ 内核参数优化完成"
```

**🔍 参数含义解释**：
- **rmem_max/wmem_max**：接收/发送缓冲区最大值（16MB）
- **tcp_rmem/tcp_wmem**：TCP接收/发送缓冲区设置（最小值 默认值 最大值）

### 4.2 文件描述符限制调整



**📁 提升系统并发能力**：
```bash
# 当前用户临时调整

ulimit -n 65536

# 永久调整 - 修改limits.conf

LIMITS_CONF="/etc/security/limits.conf"

# 添加或更新文件描述符限制

if grep -q "^* soft nofile" "$LIMITS_CONF"; then
    sed -i 's/^* soft nofile.*/* soft nofile 65536/' "$LIMITS_CONF"
else
    echo "* soft nofile 65536" >> "$LIMITS_CONF"
fi

if grep -q "^* hard nofile" "$LIMITS_CONF"; then
    sed -i 's/^* hard nofile.*/* hard nofile 65536/' "$LIMITS_CONF"
else
    echo "* hard nofile 65536" >> "$LIMITS_CONF"
fi
```

---

## 5. 🎛️ 服务配置管理



### 5.1 服务配置的统一管理



**服务配置管理的核心思想**：
- 🎯 **标准化**：所有服务使用统一的配置格式
- 🔄 **版本控制**：配置变更可追溯和回滚
- ⚡ **快速部署**：一键更新所有服务配置
- 🛡️ **安全可靠**：配置变更前自动备份

```
配置管理流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   主配置    │ →  │   生成配置  │ →  │   部署服务  │
│ master.conf │    │  各服务配置  │    │  重启服务   │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 5.2 Docker容器配置管理



**🐳 容器环境变量批量设置**：
```bash
#!/bin/bash

# Docker容器配置管理脚本


ENV_TEMPLATE="docker.env.template"
ENV_FILE="docker.env"

# 设置环境变量

DATABASE_URL="mysql://user:pass@db:3306/myapp"
REDIS_URL="redis://cache:6379"
APP_ENV="production"
DEBUG_MODE="false"

# 使用sed生成最终配置文件

sed "
    s|{{DATABASE_URL}}|$DATABASE_URL|g
    s|{{REDIS_URL}}|$REDIS_URL|g
    s|{{APP_ENV}}|$APP_ENV|g
    s|{{DEBUG_MODE}}|$DEBUG_MODE|g
" "$ENV_TEMPLATE" > "$ENV_FILE"

# 重启相关容器

docker-compose down
docker-compose up -d

echo "🐳 Docker容器配置已更新"
```

**📝 环境变量模板示例**：
```bash
# docker.env.template 文件内容

DATABASE_URL={{DATABASE_URL}}
REDIS_URL={{REDIS_URL}}
APP_ENV={{APP_ENV}}
DEBUG={{DEBUG_MODE}}
```

### 5.3 负载均衡器配置



**⚖️ Nginx负载均衡动态配置**：
```bash
#!/bin/bash

# Nginx负载均衡配置更新脚本


NGINX_CONF="/etc/nginx/sites-available/load-balancer"
UPSTREAM_CONF="/tmp/upstream.conf"

# 当前可用的后端服务器

BACKEND_SERVERS=("192.168.1.10:8080" "192.168.1.11:8080" "192.168.1.12:8080")

# 生成upstream配置

cat > "$UPSTREAM_CONF" << 'EOF'
upstream backend_servers {
EOF

for server in "${BACKEND_SERVERS[@]}"; do
    echo "    server $server max_fails=3 fail_timeout=30s;" >> "$UPSTREAM_CONF"
done

echo "}" >> "$UPSTREAM_CONF"

# 更新nginx配置文件

# 1. 删除现有的upstream块

sed -i '/^upstream backend_servers/,/^}/d' "$NGINX_CONF"

# 2. 在文件开头插入新的upstream配置

sed -i '1r '"$UPSTREAM_CONF" "$NGINX_CONF"

# 3. 检查配置并重载

if nginx -t; then
    systemctl reload nginx
    echo "✅ Nginx负载均衡配置已更新"
else
    echo "❌ Nginx配置检查失败，回滚操作"
#    # 这里可以加入回滚逻辑
fi
```

---

## 6. 🚀 自动化部署脚本



### 6.1 自动化部署的核心价值



**为什么需要自动化部署？**
- 🎯 **提高效率**：几分钟完成原本需要几小时的工作
- 🛡️ **减少错误**：避免手工操作的失误
- 📊 **标准化流程**：每次部署都按照相同步骤
- 🔄 **快速回滚**：出现问题能立即恢复

```
手工部署 vs 自动化部署：

手工部署流程：                自动化部署：
┌─────────────┐             ┌─────────────┐
│ 1.停止服务  │             │  执行脚本   │
│ 2.备份文件  │             │     ↓       │
│ 3.上传代码  │      VS     │ 一键完成全部│
│ 4.修改配置  │             │     ↓       │
│ 5.启动服务  │             │  自动验证   │
│ 6.验证结果  │             └─────────────┘
└─────────────┘
```

### 6.2 Web应用部署脚本



**🌐 PHP Web应用自动部署**：
```bash
#!/bin/bash

# Web应用自动部署脚本


APP_NAME="mywebapp"
APP_ROOT="/var/www/$APP_NAME"
BACKUP_DIR="/var/backups/$APP_NAME"
NEW_VERSION="$1"

if [ -z "$NEW_VERSION" ]; then
    echo "❌ 请指定版本号: $0 <version>"
    exit 1
fi

echo "🚀 开始部署 $APP_NAME v$NEW_VERSION"

# 1. 创建备份

BACKUP_NAME="${APP_NAME}-$(date +%Y%m%d-%H%M%S)"
echo "📦 创建备份: $BACKUP_NAME"
mkdir -p "$BACKUP_DIR"
tar -czf "$BACKUP_DIR/$BACKUP_NAME.tar.gz" -C "$APP_ROOT" .

# 2. 下载新版本

cd /tmp
wget "https://releases.example.com/$APP_NAME-$NEW_VERSION.tar.gz"
tar -xzf "$APP_NAME-$NEW_VERSION.tar.gz"

# 3. 更新配置文件

cd "$APP_NAME-$NEW_VERSION"
# 保持数据库配置不变

cp "$APP_ROOT/config/database.php" config/
# 更新版本信息

sed -i "s/VERSION = .*/VERSION = '$NEW_VERSION'/" config/app.php

# 4. 部署新版本

echo "📂 部署新文件"
rsync -av --delete . "$APP_ROOT/"

# 5. 设置权限

chown -R www-data:www-data "$APP_ROOT"
chmod -R 755 "$APP_ROOT"
chmod -R 777 "$APP_ROOT/storage" "$APP_ROOT/cache"

# 6. 重启服务

echo "🔄 重启Web服务"
systemctl restart apache2

# 7. 验证部署

sleep 5
if curl -s "http://localhost/health" | grep -q "OK"; then
    echo "✅ 部署成功！版本: $NEW_VERSION"
#    # 清理旧备份（保留最近5个）
    ls -t "$BACKUP_DIR"/*.tar.gz | tail -n +6 | xargs rm -f
else
    echo "❌ 部署验证失败，开始回滚"
    tar -xzf "$BACKUP_DIR/$BACKUP_NAME.tar.gz" -C "$APP_ROOT"
    systemctl restart apache2
    echo "🔄 已回滚到之前版本"
    exit 1
fi
```

### 6.3 数据库迁移脚本



**🗄️ 数据库结构更新**：
```bash
#!/bin/bash

# 数据库迁移脚本


DB_HOST="localhost"
DB_NAME="myapp"
DB_USER="dbuser"
MIGRATION_DIR="/opt/migrations"

# 当前数据库版本

CURRENT_VERSION=$(mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" \
                  -se "SELECT version FROM schema_versions ORDER BY applied_at DESC LIMIT 1")

echo "📊 当前数据库版本: $CURRENT_VERSION"

# 查找待执行的迁移文件

for migration_file in "$MIGRATION_DIR"/*.sql; do
    if [ -f "$migration_file" ]; then
        FILE_VERSION=$(basename "$migration_file" .sql)
        
#        # 检查是否需要执行此迁移
        if [[ "$FILE_VERSION" > "$CURRENT_VERSION" ]]; then
            echo "⏳ 执行迁移: $FILE_VERSION"
            
#            # 备份数据库
            mysqldump -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" \
                > "/tmp/${DB_NAME}-backup-$(date +%Y%m%d%H%M%S).sql"
            
#            # 执行迁移
            if mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" < "$migration_file"; then
#                # 记录迁移版本
                mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" \
                    -e "INSERT INTO schema_versions (version, applied_at) VALUES ('$FILE_VERSION', NOW())"
                echo "✅ 迁移完成: $FILE_VERSION"
            else
                echo "❌ 迁移失败: $FILE_VERSION"
                exit 1
            fi
        fi
    fi
done

echo "🎉 所有迁移执行完成"
```

---

## 7. 🤖 运维任务自动化



### 7.1 系统监控自动化



**📊 系统健康检查脚本**：
```bash
#!/bin/bash

# 系统监控脚本


REPORT_FILE="/tmp/system-health-$(date +%Y%m%d).txt"

echo "=== 系统健康检查报告 ===" > "$REPORT_FILE"
echo "检查时间: $(date)" >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

# 1. 磁盘空间检查

echo "📁 磁盘使用情况:" >> "$REPORT_FILE"
df -h | while read -r line; do
    usage=$(echo "$line" | awk '{print $5}' | sed 's/%//')
    if [ "$usage" -gt 80 ] 2>/dev/null; then
        echo "⚠️ 磁盘空间不足: $line" >> "$REPORT_FILE"
    fi
done

# 2. 内存使用检查

echo "" >> "$REPORT_FILE"
echo "💾 内存使用情况:" >> "$REPORT_FILE"
MEMORY_USAGE=$(free | awk '/^Mem:/ {printf "%.1f", $3/$2 * 100.0}')
echo "内存使用率: ${MEMORY_USAGE}%" >> "$REPORT_FILE"

# 3. CPU负载检查

echo "" >> "$REPORT_FILE"
echo "⚡ CPU负载情况:" >> "$REPORT_FILE"
LOAD_AVG=$(uptime | sed 's/.*load average: //')
echo "负载平均值: $LOAD_AVG" >> "$REPORT_FILE"

# 4. 检查关键服务状态

echo "" >> "$REPORT_FILE"
echo "🛡️ 关键服务状态:" >> "$REPORT_FILE"
SERVICES=("apache2" "mysql" "redis-server" "nginx")
for service in "${SERVICES[@]}"; do
    if systemctl is-active "$service" >/dev/null 2>&1; then
        echo "✅ $service: 正在运行" >> "$REPORT_FILE"
    else
        echo "❌ $service: 已停止" >> "$REPORT_FILE"
    fi
done

# 5. 检查网络连接

echo "" >> "$REPORT_FILE"
echo "🌐 网络连接测试:" >> "$REPORT_FILE"
if ping -c 3 8.8.8.8 >/dev/null 2>&1; then
    echo "✅ 外网连接: 正常" >> "$REPORT_FILE"
else
    echo "❌ 外网连接: 异常" >> "$REPORT_FILE"
fi

# 发送报告（可选）

if command -v mail >/dev/null; then
    mail -s "系统健康检查报告" admin@example.com < "$REPORT_FILE"
fi

echo "📋 健康检查完成，报告保存至: $REPORT_FILE"
```

### 7.2 日志清理自动化



**🗑️ 智能日志清理**：
```bash
#!/bin/bash

# 智能日志清理脚本


LOG_DIRS=("/var/log/apache2" "/var/log/nginx" "/var/log/mysql")
ARCHIVE_DIR="/var/log/archive"
DAYS_TO_KEEP=7
DAYS_TO_COMPRESS=3

mkdir -p "$ARCHIVE_DIR"

for log_dir in "${LOG_DIRS[@]}"; do
    if [ -d "$log_dir" ]; then
        echo "🔍 处理目录: $log_dir"
        
#        # 1. 压缩3天前的日志
        find "$log_dir" -name "*.log" -mtime +$DAYS_TO_COMPRESS ! -name "*.gz" | \
        while read -r logfile; do
            echo "📦 压缩文件: $logfile"
            gzip "$logfile"
        done
        
#        # 2. 归档7天前的压缩日志
        find "$log_dir" -name "*.log.gz" -mtime +$DAYS_TO_KEEP | \
        while read -r gzfile; do
            echo "📂 归档文件: $gzfile"
            mv "$gzfile" "$ARCHIVE_DIR/"
        done
        
#        # 3. 删除30天前的归档文件
        find "$ARCHIVE_DIR" -name "*.log.gz" -mtime +30 -delete
    fi
done

# 4. 清理系统日志中的空行和重复行

sed -i '/^$/d' /var/log/syslog  # 删除空行
awk '!seen[$0]++' /var/log/auth.log > /tmp/auth.log.clean && \
mv /tmp/auth.log.clean /var/log/auth.log  # 删除重复行

echo "✅ 日志清理完成"
```

### 7.3 自动备份系统



**💾 完整的备份解决方案**：
```bash
#!/bin/bash

# 自动备份脚本


BACKUP_ROOT="/var/backups"
DATE=$(date +%Y%m%d)
BACKUP_DIR="$BACKUP_ROOT/backup-$DATE"

mkdir -p "$BACKUP_DIR"

echo "🚀 开始执行备份任务"

# 1. 数据库备份

echo "📊 备份数据库..."
DB_BACKUP_DIR="$BACKUP_DIR/databases"
mkdir -p "$DB_BACKUP_DIR"

# 获取所有数据库列表

mysql -e "SHOW DATABASES;" | tail -n +2 | grep -v -E "^(information_schema|performance_schema|sys)$" | \
while read -r database; do
    echo "  备份数据库: $database"
    mysqldump --single-transaction --routines --triggers "$database" | \
    gzip > "$DB_BACKUP_DIR/${database}-${DATE}.sql.gz"
done

# 2. 网站文件备份

echo "🌐 备份网站文件..."
WEB_BACKUP_DIR="$BACKUP_DIR/websites"
mkdir -p "$WEB_BACKUP_DIR"

WEB_DIRS=("/var/www/html" "/var/www/api" "/var/www/admin")
for web_dir in "${WEB_DIRS[@]}"; do
    if [ -d "$web_dir" ]; then
        site_name=$(basename "$web_dir")
        echo "  备份站点: $site_name"
        tar -czf "$WEB_BACKUP_DIR/${site_name}-${DATE}.tar.gz" -C "$(dirname "$web_dir")" "$site_name"
    fi
done

# 3. 配置文件备份

echo "⚙️ 备份配置文件..."
CONFIG_BACKUP_DIR="$BACKUP_DIR/configs"
mkdir -p "$CONFIG_BACKUP_DIR"

CONFIG_DIRS=("/etc/apache2" "/etc/nginx" "/etc/mysql")
for config_dir in "${CONFIG_DIRS[@]}"; do
    if [ -d "$config_dir" ]; then
        config_name=$(basename "$config_dir")
        echo "  备份配置: $config_name"
        tar -czf "$CONFIG_BACKUP_DIR/${config_name}-${DATE}.tar.gz" -C "$(dirname "$config_dir")" "$config_name"
    fi
done

# 4. 生成备份清单

echo "📋 生成备份清单..."
find "$BACKUP_DIR" -type f -exec ls -lh {} \; > "$BACKUP_DIR/backup-manifest.txt"

# 5. 清理旧备份（保留7天）

echo "🗑️ 清理旧备份..."
find "$BACKUP_ROOT" -type d -name "backup-*" -mtime +7 -exec rm -rf {} \;

# 6. 备份完成统计

BACKUP_SIZE=$(du -sh "$BACKUP_DIR" | cut -f1)
echo "✅ 备份完成"
echo "📊 备份大小: $BACKUP_SIZE"
echo "📂 备份位置: $BACKUP_DIR"

# 7. 发送完成通知（可选）

if command -v mail >/dev/null; then
    echo "备份任务完成，大小: $BACKUP_SIZE，位置: $BACKUP_DIR" | \
    mail -s "备份任务完成 - $(date)" admin@example.com
fi
```

---

## 8. 📋 核心要点总结



### 8.1 必须掌握的核心概念



**🎯 sed在系统管理中的价值**：
- **批量处理能力**：一次命令处理多个文件，提高工作效率
- **脚本友好性**：完美集成到自动化脚本中
- **安全可靠性**：支持备份和预览，降低操作风险
- **高性能**：流式处理，内存占用少，适合大文件

**🔧 关键应用场景**：
```
配置管理 ← sed → 日志处理
    ↓               ↓
批量更新 ← sed → 参数调整
    ↓               ↓ 
服务配置 ← sed → 自动部署
    ↓               ↓
运维自动化 ←─── sed
```

### 8.2 实用技巧总结



**💡 配置文件修改最佳实践**：
- ✅ **总是先备份**：`cp config.conf config.conf.bak`
- ✅ **使用精确匹配**：避免误改相似行
- ✅ **验证结果**：修改后检查配置文件语法
- ✅ **批量操作时测试**：先在单个文件上验证

**🛡️ 安全操作原则**：
```bash
# 好的做法：

sed -i.bak 's/old/new/g' config.conf  # 自动备份
sed -n 's/old/new/gp' config.conf     # 预览效果

# 避免的做法：

sed -i 's/.*/new/g' config.conf       # 过于宽泛的匹配
```

### 8.3 进阶应用指导



**🚀 自动化脚本设计原则**：

①️⃣ **幂等性**：多次执行结果相同
```bash
# 好的设计 - 先检查再操作

if ! grep -q "Port 2022" /etc/ssh/sshd_config; then
    sed -i 's/^#Port 22/Port 2022/' /etc/ssh/sshd_config
fi
```

②️⃣ **错误处理**：预料可能的失败情况
```bash
# 检查文件是否存在

if [ ! -f "$config_file" ]; then
    echo "❌ 配置文件不存在: $config_file"
    exit 1
fi

# 检查sed执行结果

if sed -i 's/old/new/g' "$config_file"; then
    echo "✅ 配置更新成功"
else
    echo "❌ 配置更新失败"
    exit 1
fi
```

③️⃣ **日志记录**：记录操作过程
```bash
LOG_FILE="/var/log/config-update.log"
echo "$(date): 开始更新配置文件 $config_file" >> "$LOG_FILE"
```

### 8.4 性能优化建议



**⚡ 处理大文件时的优化**：
- 🎯 **精确匹配**：使用具体的模式而不是通配符
- 🔄 **减少处理轮数**：尽量合并多个sed命令
- 💾 **合理使用-i**：确定需要修改时才使用就地编辑

```bash
# 优化前 - 多次调用

sed -i 's/old1/new1/g' large.conf
sed -i 's/old2/new2/g' large.conf
sed -i 's/old3/new3/g' large.conf

# 优化后 - 一次调用

sed -i '
    s/old1/new1/g
    s/old2/new2/g
    s/old3/new3/g
' large.conf
```

### 8.5 故障排查技巧



**🔍 常见问题及解决方案**：

**Q1: sed修改后服务启动失败？**
```bash
# 检查配置文件语法

nginx -t                    # Nginx
apache2ctl configtest      # Apache
sshd -t                    # SSH

# 如果语法错误，立即回滚

mv config.conf.bak config.conf
```

**Q2: 批量操作影响了不该修改的文件？**
```bash
# 使用find精确限定文件范围

find /etc -name "*.conf" -not -path "*/backup/*" -exec sed -i 's/old/new/g' {} \;

# 先用-n预览再执行

find /etc -name "*.conf" -exec sed -n 's/old/new/gp' {} \;
```

**🎓 记忆要点**：
- sed是系统管理员的得力助手，擅长批量文本处理
- 配置管理、日志处理、自动化部署都离不开sed
- 安全第一：备份、测试、验证三步走
- 自动化脚本要考虑错误处理和幂等性
- 熟练掌握sed能让系统管理工作事半功倍