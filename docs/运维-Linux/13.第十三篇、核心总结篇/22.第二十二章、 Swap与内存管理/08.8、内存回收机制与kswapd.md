---
title: 8、内存回收机制与kswapd
---
## 📚 目录

1. [内存回收机制概述](#1-内存回收机制概述)
2. [kswapd守护进程详解](#2-kswapd守护进程详解)
3. [内存水位线机制](#3-内存水位线机制)
4. [页面回收算法与LRU](#4-页面回收算法与lru)
5. [直接回收vs后台回收](#5-直接回收vs后台回收)
6. [关键参数调优](#6-关键参数调优)
7. [内存碎片整理](#7-内存碎片整理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💧 内存回收机制概述


### 1.1 为什么需要内存回收


**💡 生活类比**：
内存就像你的书桌，用久了会堆满各种文件。当桌面快满时，你需要：
- 把不常用的文件收起来（页面回收）
- 把重要文件放到抽屉里（换出到swap）
- 整理桌面空间（碎片整理）

```
内存使用状态演进：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 空闲内存多  │ →  │ 内存紧张    │ →  │ 触发回收    │
│ 系统流畅    │    │ 性能下降    │    │ 释放空间    │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 1.2 内存回收的核心思想


**🎯 基本原理**：
- **预防式回收**：在内存不够用之前就开始清理
- **智能选择**：优先回收最不重要的页面
- **后台进行**：不影响正常程序运行

**🔸 内存回收的层次**：
```
第一层：页面缓存清理
├── 文件缓存页面
├── 目录缓存
└── inode缓存

第二层：匿名页面回收  
├── 不活跃的进程页面
├── 可换出的堆内存
└── 未使用的栈空间

第三层：系统缓存压缩
├── slab缓存回收
├── 内核数据结构清理
└── 驱动程序缓存
```

---

## 2. 🤖 kswapd守护进程详解


### 2.1 kswapd是什么


**📋 基本定义**：
`kswapd`（kernel swap daemon）是Linux内核中的内存回收守护进程，就像一个**勤劳的清洁工**，不停地监控内存使用情况。

**🔸 kswapd的核心职责**：
- **监控内存水位**：时刻关注可用内存是否充足
- **后台回收**：在系统不忙时悄悄清理内存
- **预防性工作**：防止内存完全耗尽的情况发生
- **平衡各zone**：确保不同内存区域都有足够空间

### 2.2 kswapd工作机制


**⚡ 工作流程**：
```
1. 睡眠等待
   ↓ (内存水位下降)
2. 被唤醒检查
   ↓ (发现内存不足)  
3. 开始页面回收
   ↓ (回收足够页面)
4. 重新进入睡眠
```

**💻 查看kswapd状态**：
```bash
# 查看kswapd进程
ps aux | grep kswapd
# 输出示例：root 123 0.0 0.0 0 0 ? S 10:30 0:00 [kswapd0]

# 查看内存回收统计
cat /proc/vmstat | grep kswapd
# kswapd_inodesteal 1234
# kswapd_low_wmark_hit_quickly 5678
```

### 2.3 kswapd的唤醒条件


**🚨 什么时候kswapd开始工作**：

```
内存水位状态：
   HIGH ████████████████ (充足，kswapd睡眠)
    ↓
   LOW  ████████████     (不足，唤醒kswapd)  
    ↓
   MIN  ████████         (危险，直接回收)
```

> 💡 **核心理解**：kswapd就像家里的扫地机器人，当地面不够干净时自动开始工作，不需要你手动操作。

---

## 3. 🏊 内存水位线机制


### 3.1 三条水位线的含义


Linux使用三条"水位线"来管理内存，就像水库的**警戒线**一样：

**🔸 HIGH水位线（高水位）**：
- **含义**：内存充足状态
- **系统行为**：kswapd进入睡眠，不进行回收
- **类比**：水库水位很高，无需担心

**🔸 LOW水位线（低水位）**：  
- **含义**：内存开始紧张
- **系统行为**：唤醒kswapd开始后台回收
- **类比**：水库水位下降，需要开始关注

**🔸 MIN水位线（最低水位）**：
- **含义**：内存严重不足
- **系统行为**：触发直接回收，可能阻塞进程
- **类比**：水库接近干涸，必须立即行动

### 3.2 水位线的计算


**📊 水位线计算公式**：
```
MIN = vm.min_free_kbytes 参数值
LOW = MIN × 5/4  (MIN的1.25倍)
HIGH = MIN × 3/2 (MIN的1.5倍)

实际示例（8GB内存）：
MIN = 67584KB (约66MB)
LOW = 84480KB (约82MB)  
HIGH = 101376KB (约99MB)
```

**🔧 查看当前水位线**：
```bash
# 查看内存水位设置
cat /proc/sys/vm/min_free_kbytes
# 输出：67584

# 查看各zone的水位线
cat /proc/zoneinfo | grep -E "(low|high|min)"
```

### 3.3 vm.min_free_kbytes参数


**⚙️ 参数作用**：
- **定义**：设置系统保持的最小空闲内存量
- **影响**：决定了内存回收的触发点
- **默认值**：通常是总内存的0.8%-1%

**🔸 调整建议**：

| 内存大小 | **推荐min_free_kbytes** | **说明** |
|---------|----------------------|----------|
| `2GB以下` | `32MB-64MB` | `桌面系统，保守设置` |
| `4GB-8GB` | `64MB-128MB` | `服务器，平衡性能` |
| `16GB以上` | `128MB-256MB` | `高负载，积极回收` |

```bash
# 临时调整
echo 131072 > /proc/sys/vm/min_free_kbytes

# 永久生效
echo "vm.min_free_kbytes = 131072" >> /etc/sysctl.conf
```

> ⚠️ **注意事项**：设置过高会浪费内存，过低会导致频繁回收影响性能。

---

## 4. 🔄 页面回收算法与LRU


### 4.1 什么是LRU算法


**📚 LRU基本概念**：
LRU（Least Recently Used）= **最近最少使用算法**，就像整理书桌时，把最久没用的东西先收起来。

**💭 生活类比**：
```
你的书桌上有这些物品：
┌─────────────────────────┐
│ 笔(刚用过) - 最活跃     │ ← Active List
│ 纸(1小时前用) - 活跃    │
├─────────────────────────┤  
│ 书(昨天用过) - 不活跃   │ ← Inactive List  
│ 文件夹(一周前) - 很久   │
└─────────────────────────┘
收拾时优先收起最下面的物品
```

### 4.2 Linux的双LRU列表


Linux使用**两个LRU列表**管理内存页面：

**🔸 Active List（活跃列表）**：
- 存放最近被访问的页面
- 这些页面不会被优先回收
- 就像你桌面上正在用的文件

**🔸 Inactive List（不活跃列表）**：
- 存放较久未访问的页面  
- 优先从这里选择页面回收
- 就像你很久没碰的旧文件

**📈 页面在列表间的流动**：
```
新页面加入 → Inactive List
    ↓ (被访问)
Active List ← 页面升级
    ↓ (长时间未访问)
Inactive List ← 页面降级  
    ↓ (内存紧张)
被回收释放 ← 页面移除
```

### 4.3 页面回收选择策略


**🎯 回收优先级（从高到低）**：

```
优先级1：干净的文件页面
├── 已同步到磁盘的文件缓存
├── 可以直接丢弃的只读页面
└── 影响最小，回收最快

优先级2：脏的文件页面  
├── 需要先写回磁盘
├── 回收时间较长
└── 但不影响程序运行

优先级3：匿名页面
├── 进程的堆、栈内存
├── 需要写入swap分区
└── 影响程序性能
```

**💡 智能选择机制**：
- **文件页面优先**：因为可以从磁盘重新读取
- **干净页面优先**：不需要额外的写磁盘操作
- **大小考虑**：优先回收大块连续页面

---

## 5. ⚔️ 直接回收vs后台回收


### 5.1 两种回收方式对比


**🔸 后台回收（kswapd触发）**：
```
特点：温和、不急躁
时机：LOW水位线触发
影响：对系统性能影响小
速度：慢慢回收，细水长流
```

**🔸 直接回收（进程触发）**：
```
特点：紧急、立即执行  
时机：MIN水位线或分配失败
影响：可能阻塞当前进程
速度：快速回收，立竿见影
```

### 5.2 回收场景分析


**📊 回收触发对比表**：

| 回收类型 | **触发条件** | **执行者** | **性能影响** | **适用场景** |
|---------|------------|----------|------------|------------|
| `后台回收` | `LOW水位触发` | `kswapd进程` | `影响小` | `日常维护` |
| `直接回收` | `内存分配失败` | `当前进程` | `可能阻塞` | `紧急情况` |

**🚨 直接回收的影响**：
```
正常情况：
进程请求内存 → 立即分配 → 继续执行

直接回收情况：  
进程请求内存 → 内存不足 → 停下回收内存 → 获得内存 → 继续执行
               ↑________________↑
               这段时间进程被阻塞
```

### 5.3 如何避免直接回收


**✅ 优化策略**：

```
1. 合理设置水位线：
   适当提高min_free_kbytes值
   
2. 监控内存使用：
   定期检查/proc/meminfo
   
3. 应用程序优化：
   避免瞬间申请大量内存
   
4. 系统调优：
   合理配置swap分区
```

> 💡 **最佳实践**：让kswapd勤快一点工作，避免等到紧急情况才开始回收内存。

---

## 6. 🛠️ 关键参数调优


### 6.1 vfs_cache_pressure参数


**📋 参数含义**：
`/proc/sys/vm/vfs_cache_pressure`控制**文件系统缓存**的回收力度，就像调节清洁工对不同区域的清理强度。

**🔧 参数值含义**：
```
vfs_cache_pressure = 100  (默认值)
├── 均衡回收文件缓存和匿名页面
├── 适合大多数场景
└── 平衡性能和内存使用

vfs_cache_pressure < 100  (如50)
├── 更倾向于保留文件缓存
├── 优先回收进程内存  
└── 适合IO密集型应用

vfs_cache_pressure > 100  (如200)
├── 更积极回收文件缓存
├── 保护进程内存不被swap
└── 适合内存敏感型应用
```

### 6.2 核心调优参数汇总


**⚙️ 关键参数配置表**：

| 参数名 | **默认值** | **作用** | **调优建议** |
|-------|-----------|----------|------------|
| `vm.min_free_kbytes` | `总内存×1%` | `最小空闲内存` | `根据负载调整` |
| `vm.vfs_cache_pressure` | `100` | `缓存回收力度` | `IO多用50，内存紧用200` |
| `vm.swappiness` | `60` | `swap使用倾向` | `服务器建议10-30` |
| `vm.dirty_ratio` | `20` | `脏页面比例` | `SSD可适当提高` |

**🔧 实际调优示例**：
```bash
# 针对数据库服务器的优化配置
echo "vm.min_free_kbytes = 131072" >> /etc/sysctl.conf
echo "vm.vfs_cache_pressure = 50" >> /etc/sysctl.conf  
echo "vm.swappiness = 10" >> /etc/sysctl.conf

# 使配置生效
sysctl -p
```

### 6.3 监控命令汇总


**📊 常用监控命令**：
```bash
# 查看内存整体状况
free -h

# 查看详细内存统计
cat /proc/meminfo | grep -E "(MemFree|Cached|Active|Inactive)"

# 查看页面回收统计
cat /proc/vmstat | grep -E "(pgpgin|pgpgout|pswpin|pswpout)"

# 查看kswapd活动
cat /proc/vmstat | grep kswapd
```

---

## 7. 🧩 内存碎片整理


### 7.1 什么是内存碎片


**💭 生活类比**：
内存碎片就像停车场的情况：
```
理想状态：
[🚗][🚗][🚗][  ][  ][  ] ← 连续的大空间

碎片化后：  
[🚗][  ][🚗][  ][🚗][  ] ← 分散的小空间
      ↑       ↑       ↑
     虽然总空间够，但无法停大车
```

**🔸 碎片化的问题**：
- **外部碎片**：有足够总内存，但没有连续大块
- **内部碎片**：分配的内存块比实际需要的大
- **分配失败**：无法满足大块内存请求

### 7.2 碎片整理机制


**⚡ Linux的碎片整理策略**：

```
1. 内存压缩（Memory Compaction）：
   ┌─────────────────────────┐
   │ [A][ ][B][ ][C][ ]     │ → 碎片化状态
   └─────────────────────────┘
            ↓ 压缩整理
   ┌─────────────────────────┐  
   │ [A][B][C][      ]      │ → 连续空间
   └─────────────────────────┘

2. 页面迁移（Page Migration）：
   将可移动页面重新排列，腾出连续空间

3. 伙伴系统优化：
   智能合并相邻的空闲页面块
```

### 7.3 手动触发碎片整理


**🔧 手动整理命令**：
```bash
# 触发内存压缩
echo 1 > /proc/sys/vm/compact_memory

# 查看碎片化程度
cat /proc/buddyinfo

# 查看碎片整理统计
cat /proc/vmstat | grep compact
```

**📊 碎片化监控**：
```bash
# 查看内存块分布（buddyinfo解读）
cat /proc/buddyinfo
# Node 0, zone DMA     10  4   3   2   2   1   1   0   1   1   3
# Node 0, zone DMA32   100 50  30  15  8   4   2   1   0   0   0
#                      4K  8K  16K 32K 64K...
#                      ↑越往右块越大，数字越小说明大块内存越少
```

> ⚠️ **注意**：频繁的碎片整理会影响性能，应该合理控制触发时机。

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 kswapd：内核内存回收守护进程，后台默默清理内存
🔸 三水位线：MIN/LOW/HIGH决定内存回收的触发时机  
🔸 LRU算法：最近最少使用，智能选择要回收的页面
🔸 双列表：Active/Inactive列表管理页面活跃度
🔸 两种回收：后台回收温和，直接回收紧急但影响性能
🔸 关键参数：min_free_kbytes和vfs_cache_pressure最重要
🔸 碎片整理：解决内存分散问题，保证大块内存可用
```

### 8.2 关键理解要点


**🔹 内存回收的本质**：
```
不是等内存用完才清理，而是：
- 预防性回收：LOW水位就开始工作
- 智能化选择：优先回收最不重要的页面  
- 后台化处理：尽量不影响正常程序运行
```

**🔹 参数调优的思路**：
```
根据应用特点选择：
- IO密集型：保护文件缓存 (vfs_cache_pressure < 100)
- 内存敏感型：积极回收缓存 (vfs_cache_pressure > 100)  
- 高负载系统：提高水位线 (增大min_free_kbytes)
```

**🔹 监控的重点指标**：
```
关注这些指标变化：
- 空闲内存趋势：free命令
- kswapd活跃程度：/proc/vmstat
- 直接回收频率：是否频繁发生
- 碎片化程度：/proc/buddyinfo
```

### 8.3 实际应用价值


**🎯 服务器运维场景**：
- **性能调优**：通过参数调优减少内存回收对性能的影响
- **故障诊断**：通过监控指标定位内存相关问题  
- **容量规划**：基于内存使用模式合理配置服务器
- **应用优化**：指导应用程序的内存使用策略

**🔧 实战技能**：
- **会看**：能读懂/proc/meminfo、/proc/vmstat等信息
- **会调**：能根据业务场景调优关键参数
- **会监控**：能建立内存使用情况的监控体系  
- **会诊断**：能通过现象分析内存问题的根本原因

### 8.4 学习进度检查


**📝 自检清单**：
- [ ] 能解释kswapd的工作原理和触发条件
- [ ] 理解三条水位线的含义和关系  
- [ ] 掌握LRU算法在内存管理中的应用
- [ ] 知道如何调优vm.min_free_kbytes参数
- [ ] 能区分后台回收和直接回收的差异
- [ ] 了解内存碎片的成因和解决方法
- [ ] 会使用基本命令监控内存回收状态

**🎯 一句话总结**：
Linux内存回收就像一个智能管家，通过kswapd守护进程根据水位线监控内存状态，使用LRU算法智能选择回收页面，既保证系统有足够内存可用，又尽量不影响程序正常运行。

**核心记忆口诀**：
```
kswapd守护进程勤，三线水位控回收
LRU算法选页面，后台直接两方式  
参数调优看场景，碎片整理保连续
监控指标要关注，内存管理心中明
```