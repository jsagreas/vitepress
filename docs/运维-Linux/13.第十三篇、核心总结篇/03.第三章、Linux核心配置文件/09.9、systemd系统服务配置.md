---
title: 9、systemd系统服务配置
---
## 📚 目录

1. [systemd服务单元文件基础](#1-systemd服务单元文件基础)
2. [Unit段核心配置详解](#2-unit段核心配置详解)
3. [Service段服务配置](#3-service段服务配置)
4. [Install段安装配置](#4-install段安装配置)
5. [ExecStart启动命令配置](#5-execstart启动命令配置)
6. [Restart重启策略配置](#6-restart重启策略配置)
7. [用户权限配置](#7-用户权限配置)
8. [环境变量配置](#8-环境变量配置)
9. [服务依赖关系配置](#9-服务依赖关系配置)
10. [实战案例与最佳实践](#10-实战案例与最佳实践)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🏗️ systemd服务单元文件基础


### 1.1 什么是systemd服务


**systemd的本质**
> systemd就像一个"超级管家"，负责管理Linux系统中所有的服务程序。它知道哪些服务该什么时候启动、怎么启动、出错了怎么处理。

```
传统init vs systemd：

传统init系统：
启动脚本 → /etc/init.d/service_name
管理方式 → service nginx start
特点：脚本复杂，启动缓慢

systemd系统：
配置文件 → /etc/systemd/system/service_name.service  
管理方式 → systemctl start nginx
特点：配置简单，并行启动
```

### 1.2 服务单元文件位置


**系统目录结构**
```
systemd服务文件的"家族住址"：

/etc/systemd/system/          ← 系统管理员自定义服务
├── nginx.service             ← 自定义nginx服务
├── myapp.service            ← 自定义应用服务
└── multi-user.target.wants/  ← 默认启动的服务

/usr/lib/systemd/system/      ← 系统软件包提供的服务  
├── sshd.service             ← SSH服务
├── httpd.service            ← Apache服务
└── mysql.service            ← MySQL服务

优先级：/etc/systemd/system/ > /usr/lib/systemd/system/
```

**文件命名规则**
- **服务名.service** - 最常用的服务类型
- **服务名.target** - 系统状态目标（如multi-user.target）
- **服务名.socket** - 套接字激活服务
- **服务名.timer** - 定时任务服务

### 1.3 服务单元文件基本结构


**标准的服务配置文件就像"身份证"，包含三个主要部分：**

```ini
[Unit]                    ← 服务的基本信息
Description=我的应用服务    ← 服务描述
After=network.target     ← 启动顺序

[Service]                ← 服务的运行方式  
ExecStart=/usr/bin/myapp ← 启动命令
Restart=always          ← 重启策略

[Install]               ← 服务的安装信息
WantedBy=multi-user.target ← 被谁需要
```

---

## 2. 📋 Unit段核心配置详解


### 2.1 Unit段基本配置


**Unit段就像服务的"名片"，描述服务是什么、与其他服务的关系。**

#### 🔸 Description - 服务描述

```ini
[Unit]
Description=My Web Application Server
# 作用：给服务起个好理解的名字
# 显示：systemctl status myapp 时会看到这个描述
# 建议：用简洁明了的中文或英文描述服务功能
```

#### 🔸 Documentation - 文档链接

```ini
[Unit]  
Description=Nginx HTTP Server
Documentation=http://nginx.org/en/docs/
Documentation=man:nginx(8)
# 作用：提供服务相关文档的链接
# 用途：管理员可以快速找到帮助文档
```

### 2.2 服务依赖配置


#### 🔸 After - 启动顺序（推荐）

```ini
[Unit]
After=network.target
After=mysql.service
# 含义：等network.target和mysql.service启动后，再启动本服务
# 特点：即使依赖服务启动失败，本服务仍会尝试启动
# 适用：大多数常规依赖关系
```

**依赖关系示意图：**
```
启动时间线：
时间 0s ──→ network.target 启动
时间 5s ──→ mysql.service 启动  
时间 8s ──→ myapp.service 启动 (等待After指定的服务)
```

#### 🔸 Requires - 强制依赖

```ini
[Unit]
Requires=mysql.service
After=mysql.service
# 含义：mysql.service必须成功启动，否则本服务失败
# 风险：依赖服务挂了，本服务也会被停止
# 使用：核心依赖，缺一不可的情况
```

#### 🔸 Wants - 弱依赖（推荐）

```ini
[Unit]
Wants=redis.service  
After=redis.service
# 含义：希望redis.service启动，但不是必需的
# 特点：即使redis启动失败，本服务照常运行
# 适用：可选依赖，增强功能但非核心
```

**依赖关系选择指南：**
```
🎯 选择依赖类型的原则：

After单独使用：
适用：确保启动顺序，但不强制依赖
示例：Web服务等网络就绪后启动

Wants + After：  
适用：可选依赖，有更好，没有也能工作
示例：缓存服务、监控服务

Requires + After：
适用：强制依赖，缺少就无法工作  
示例：数据库服务对于Web应用
```

### 2.3 冲突与条件配置


#### 🔸 Conflicts - 服务冲突

```ini
[Unit]
Conflicts=apache2.service
# 含义：不能与apache2同时运行
# 应用：nginx和apache不能同时占用80端口
```

#### 🔸 Condition条件启动

```ini
[Unit]
ConditionPathExists=/etc/myapp/config.conf
ConditionFileNotEmpty=/etc/myapp/license.key
# 含义：只有满足条件才启动服务
# 用途：确保必要的配置文件存在
```

---

## 3. ⚙️ Service段服务配置


### 3.1 服务类型配置


**Service段是服务配置的"心脏"，决定服务如何运行。**

#### 🔸 Type - 服务类型

```ini
[Service]
Type=simple
# simple：默认类型，进程不会fork到后台
# 适用：大多数现代应用程序

Type=forking  
# forking：进程会fork到后台运行
# 适用：传统的守护进程

Type=oneshot
# oneshot：执行一次就退出的服务
# 适用：初始化脚本、数据迁移任务

Type=notify
# notify：服务启动后会通知systemd
# 适用：支持systemd通知的现代服务
```

**服务类型选择实例：**
```
Web应用程序：
Type=simple
ExecStart=/usr/bin/python app.py
# 应用直接在前台运行

传统守护进程：  
Type=forking
ExecStart=/usr/sbin/nginx
PIDFile=/var/run/nginx.pid
# nginx会自动后台化

初始化任务：
Type=oneshot  
ExecStart=/usr/local/bin/setup-database.sh
RemainAfterExit=yes
# 执行一次初始化脚本
```

### 3.2 工作目录与文件


#### 🔸 WorkingDirectory - 工作目录

```ini
[Service]
WorkingDirectory=/opt/myapp
ExecStart=./start.sh
# 作用：设置服务运行时的当前目录
# 好处：相对路径基于此目录，配置更清晰
```

#### 🔸 PIDFile - 进程ID文件

```ini
[Service]
Type=forking
PIDFile=/var/run/myapp.pid
# 作用：告诉systemd进程ID保存在哪里
# 用途：systemd通过PID文件监控服务状态
```

### 3.3 资源限制配置


#### 🔸 内存和CPU限制

```ini
[Service]
MemoryLimit=512M
CPUQuota=50%
# MemoryLimit：限制服务最大内存使用
# CPUQuota：限制CPU使用率（50%表示半个核心）
```

#### 🔸 文件描述符限制

```ini
[Service]
LimitNOFILE=65536
# 作用：设置可打开的文件描述符数量
# 适用：高并发服务，需要大量网络连接
```

---

## 4. 📦 Install段安装配置


### 4.1 Install段基本概念


**Install段就像"安装说明书"，告诉systemd这个服务应该何时自动启动。**

#### 🔸 WantedBy - 被谁需要

```ini
[Install]
WantedBy=multi-user.target
# 含义：当系统进入multi-user.target状态时，启动此服务
# 结果：systemctl enable myapp 会创建软链接
```

**target的含义：**
```
系统运行级别（target）说明：

multi-user.target     ← 多用户模式（常用）
├── 网络服务可用      ← 大多数服务选择这里
├── 用户可以登录      
└── 命令行界面

graphical.target      ← 图形界面模式
├── 包含multi-user    ← 图形界面相关服务选择
└── GUI环境可用

basic.target         ← 基础系统模式  
└── 最基本的系统功能  ← 系统核心服务选择
```

#### 🔸 RequiredBy - 被强制需要

```ini
[Install]
RequiredBy=multi-user.target
# 含义：multi-user.target强制需要此服务
# 区别：比WantedBy更强制，依赖方会强制启动此服务
```

#### 🔸 Alias - 服务别名

```ini
[Install]  
Alias=webapp.service
Alias=mycompany-web.service
# 作用：给服务起别名，可以用别名操作服务
# 使用：systemctl start webapp 等同于 systemctl start myapp
```

### 4.2 服务启用与禁用


**启用服务的本质：**
```
systemctl enable myapp.service 做了什么？

1. 读取myapp.service的[Install]段
2. 在/etc/systemd/system/multi-user.target.wants/
3. 创建软链接：myapp.service -> /etc/systemd/system/myapp.service
4. 下次启动到multi-user.target时，自动启动myapp
```

**服务管理命令：**
| 命令 | 作用 | 效果 |
|-----|------|------|
| `systemctl enable myapp` | 启用自动启动 | 开机自动启动服务 |
| `systemctl disable myapp` | 禁用自动启动 | 开机不启动服务 |
| `systemctl is-enabled myapp` | 查看启用状态 | 显示enabled/disabled |

---

## 5. 🚀 ExecStart启动命令配置


### 5.1 ExecStart基本用法


**ExecStart是服务的"启动按钮"，定义如何启动你的程序。**

#### 🔸 简单启动命令

```ini
[Service]
ExecStart=/usr/bin/python /opt/myapp/app.py
# 最基础的用法：直接指定程序路径和参数
```

#### 🔸 带参数的启动命令

```ini
[Service]
ExecStart=/usr/bin/java -jar /opt/myapp/app.jar --port=8080 --config=/etc/myapp/config.yml
# 完整的命令行，包含所有必要参数
```

### 5.2 多条执行命令


#### 🔸 前置和后置命令

```ini
[Service]
ExecStartPre=/usr/local/bin/check-config.sh
ExecStart=/usr/bin/myapp
ExecStartPost=/usr/local/bin/notify-started.sh
```

**执行顺序：**
```
服务启动流程：
1. ExecStartPre  ← 启动前检查（检查配置、创建目录等）
2. ExecStart     ← 主程序启动  
3. ExecStartPost ← 启动后处理（发送通知、注册服务等）
```

#### 🔸 停止命令配置

```ini
[Service]
ExecStop=/bin/kill -TERM $MAINPID
ExecStopPost=/usr/local/bin/cleanup.sh
# ExecStop：优雅停止服务的命令
# ExecStopPost：停止后的清理工作
```

### 5.3 启动命令高级配置


#### 🔸 命令前缀修饰符


| 前缀 | 含义 | 示例 | 效果 |
|-----|------|------|------|
| **无前缀** | 失败则服务失败 | `ExecStart=/usr/bin/app` | 命令失败=服务失败 |
| **`-`** | 允许失败 | `ExecStart=-/usr/bin/optional-task` | 失败也继续运行 |
| **`+`** | 以root权限运行 | `ExecStart=+/usr/bin/privileged-cmd` | 即使服务非root用户 |
| **`!`** | 以完整权限运行 | `ExecStart=!/usr/bin/system-cmd` | 绕过权限限制 |

#### 🔸 实际应用示例

```ini
[Service]
User=webapp
ExecStartPre=-/usr/bin/mkdir -p /var/log/myapp
ExecStartPre=/usr/local/bin/check-database.sh  
ExecStart=/usr/bin/python /opt/myapp/server.py
ExecReload=/bin/kill -HUP $MAINPID
ExecStopPost=+/usr/bin/chown root:root /var/log/myapp
```

**解释：**
- `ExecStartPre=-/usr/bin/mkdir` - 创建目录，失败也不影响启动
- `ExecStartPre=/usr/local/bin/check-database.sh` - 检查数据库，失败则停止启动  
- `ExecStopPost=+/usr/bin/chown` - 停止后用root权限修改文件权限

---

## 6. 🔄 Restart重启策略配置


### 6.1 重启策略详解


**Restart策略就像"不倒翁规则"，决定服务倒了之后怎么爬起来。**

#### 🔸 Restart选项对比


| 策略值 | 重启条件 | 适用场景 | 风险 |
|--------|----------|----------|------|
| **`no`** | 从不重启 | 一次性任务 | 服务挂了就挂了 |
| **`always`** | 总是重启 | 核心服务 | 可能无限重启循环 |
| **`on-success`** | 正常退出才重启 | 定期任务 | 异常退出不重启 |
| **`on-failure`** | 异常退出才重启 | 常规应用 | **推荐** |
| **`on-abort`** | 被信号终止才重启 | 特殊需求 | 使用较少 |

#### 🔸 推荐配置组合

```ini
[Service]
Restart=on-failure
RestartSec=10
StartLimitBurst=3  
StartLimitIntervalSec=60
```

**配置解释：**
- `Restart=on-failure` - 只有异常退出才重启
- `RestartSec=10` - 重启前等待10秒
- `StartLimitBurst=3` - 60秒内最多重启3次  
- `StartLimitIntervalSec=60` - 限制时间窗口60秒

### 6.2 重启时机控制


#### 🔸 RestartSec - 重启延迟

```ini
[Service]
Restart=on-failure
RestartSec=5
# 作用：服务挂了之后，等待5秒再重启
# 目的：避免快速重启消耗系统资源
```

#### 🔸 重启限制配置

```ini
[Service]  
StartLimitBurst=5
StartLimitIntervalSec=300
# 含义：5分钟内最多启动5次
# 超过限制：服务进入failed状态，不再自动重启
```

**重启限制示意：**
```
重启限制保护机制：

时间窗口：5分钟
最大次数：3次

0分钟: 服务启动 ✓ (1/3)
1分钟: 服务崩溃，重启 ✓ (2/3) 
2分钟: 服务崩溃，重启 ✓ (3/3)
3分钟: 服务崩溃 → 超过限制，停止重启 ❌
```

### 6.3 退出码处理


#### 🔸 RestartForceExitStatus - 强制重启

```ini
[Service]
Restart=on-failure
RestartForceExitStatus=125 126 127
# 含义：即使设置了on-failure，遇到125,126,127退出码也重启
# 应用：自定义退出码的特殊处理
```

#### 🔸 RestartPreventExitStatus - 阻止重启  

```ini
[Service]
Restart=always
RestartPreventExitStatus=0 1
# 含义：即使设置了always，遇到退出码0,1不重启
# 应用：正常退出或配置错误时不重启
```

---

## 7. 👤 用户权限配置


### 7.1 服务运行用户配置


**为什么要配置运行用户？**
> 就像不同的人有不同的房间钥匙，不同的服务应该用不同的用户运行，这样即使服务被攻破，损失也有限。

#### 🔸 User和Group配置

```ini
[Service]
User=webapp
Group=webapp  
# 作用：服务以webapp用户和组的身份运行
# 好处：限制服务权限，提高安全性
```

**用户权限安全原则：**
```
🔐 最小权限原则：

root用户：
权限：系统管理员，无限制权限
风险：服务被攻破=系统被攻破
使用：仅系统核心服务

专用用户：
权限：只能访问必要文件和端口
风险：即使被攻破，影响范围有限  
使用：所有应用服务（推荐）

示例用户创建：
sudo useradd -r -s /bin/false webapp
sudo usermod -G webapp webapp
```

#### 🔸 DynamicUser - 动态用户

```ini
[Service]
DynamicUser=yes
# 作用：systemd自动创建临时用户运行服务
# 好处：无需手动创建用户，安全性更高
# 限制：用户是临时的，重启后可能改变
```

### 7.2 权限控制配置


#### 🔸 文件系统权限

```ini
[Service]  
ReadOnlyPaths=/etc /usr
ReadWritePaths=/var/log/myapp /var/lib/myapp
InaccessiblePaths=/home /root
```

**权限设置说明：**
- `ReadOnlyPaths` - 只读访问的目录
- `ReadWritePaths` - 可读写访问的目录  
- `InaccessiblePaths` - 完全禁止访问的目录

#### 🔸 网络权限控制

```ini
[Service]
PrivateNetwork=yes        # 禁用网络访问
RestrictAddressFamilies=AF_INET AF_INET6  # 只允许IPv4/IPv6
```

#### 🔸 系统调用限制

```ini
[Service]
SystemCallFilter=@system-service
SystemCallFilter=~@privileged @resources
# 作用：只允许系统服务需要的系统调用
# 安全：阻止危险的系统调用
```

---

## 8. 🌍 环境变量配置


### 8.1 Environment环境变量基础


**环境变量就像服务的"工作环境设置"，告诉程序在什么环境下运行。**

#### 🔸 直接设置环境变量

```ini
[Service]
Environment="NODE_ENV=production"
Environment="PORT=8080" 
Environment="DATABASE_URL=mysql://user:pass@localhost/mydb"
# 特点：直接在服务文件中定义
# 适用：简单的、不敏感的配置
```

#### 🔸 从文件读取环境变量

```ini
[Service]
EnvironmentFile=/etc/myapp/env.conf
# 好处：敏感信息不暴露在服务文件中
# 维护：环境配置与服务配置分离
```

**环境变量文件示例 (`/etc/myapp/env.conf`)：**
```bash
# 数据库配置
DATABASE_HOST=localhost
DATABASE_PORT=3306
DATABASE_NAME=myapp

# API密钥（敏感信息）
API_SECRET_KEY=your-secret-key-here
REDIS_PASSWORD=redis-password

# 应用配置
APP_DEBUG=false
LOG_LEVEL=info
```

### 8.2 环境变量管理策略


#### 🔸 多环境配置

```ini
# 开发环境
[Service]
EnvironmentFile=/etc/myapp/dev.env

# 生产环境  
[Service]
EnvironmentFile=/etc/myapp/prod.env
```

#### 🔸 环境变量优先级

```ini
[Service]
Environment="APP_ENV=production"
EnvironmentFile=/etc/myapp/app.env
EnvironmentFile=-/etc/myapp/local.env
# 优先级：local.env > app.env > 直接定义的Environment
# "-"前缀：文件不存在也不报错
```

### 8.3 安全考虑


#### 🔸 敏感信息保护

```bash
# 设置环境变量文件权限
sudo chown root:webapp /etc/myapp/secret.env
sudo chmod 640 /etc/myapp/secret.env
# 只有root和webapp组可读，其他人无法访问
```

#### 🔸 使用systemd凭据管理

```ini
[Service]
LoadCredential=database-password:/etc/myapp/db-password
ExecStart=/usr/bin/myapp --db-password=${CREDENTIALS_DIRECTORY}/database-password
# 更安全的密码管理方式
```

---

## 9. 🔗 服务依赖关系配置


### 9.1 依赖关系类型详解


**服务依赖就像"朋友圈"，有些朋友必须一起出现，有些朋友有了更好，没有也行。**

#### 🔸 启动顺序依赖

```ini
[Unit]
After=network.target mysql.service redis.service
# 含义：等网络、MySQL、Redis都准备好了，再启动我
# 特点：不要求依赖服务必须成功启动
```

**启动时序示例：**
```
服务启动时间轴：
0s    ──→ network.target 开始启动
2s    ──→ mysql.service 开始启动  
3s    ──→ redis.service 开始启动
5s    ──→ network.target 启动完成
7s    ──→ mysql.service 启动完成
8s    ──→ redis.service 启动完成
8s    ──→ myapp.service 开始启动 (所有After依赖都满足)
```

#### 🔸 功能依赖配置

```ini
[Unit]
# 强依赖：缺少就无法工作
Requires=mysql.service
After=mysql.service

# 弱依赖：有更好，没有也能工作  
Wants=redis.service
After=redis.service

# 冲突：不能同时运行
Conflicts=apache2.service
```

### 9.2 复杂依赖场景


#### 🔸 Web应用典型依赖

```ini
[Unit]
Description=My Web Application
After=network-online.target
Wants=network-online.target

# 数据库依赖（必需）
Requires=mysql.service  
After=mysql.service

# 缓存依赖（可选）
Wants=redis.service
After=redis.service

# 文件系统依赖
RequiresMountsFor=/opt/myapp /var/log/myapp
```

#### 🔸 微服务依赖链

```ini
# API网关服务
[Unit]
Description=API Gateway
Wants=user-service.service order-service.service
After=user-service.service order-service.service

# 用户服务
[Unit]  
Description=User Service
Requires=mysql.service
After=mysql.service

# 订单服务
[Unit]
Description=Order Service  
Requires=mysql.service redis.service
After=mysql.service redis.service
```

### 9.3 依赖关系调试


#### 🔸 查看依赖关系

```bash
# 查看服务的依赖树
systemctl list-dependencies myapp.service

# 查看谁依赖这个服务
systemctl list-dependencies --reverse myapp.service

# 查看依赖关系图
systemd-analyze dot myapp.service | dot -Tsvg -o deps.svg
```

#### 🔸 启动顺序分析

```bash
# 分析启动时间
systemd-analyze blame

# 查看启动瓶颈  
systemd-analyze critical-chain

# 特定服务的启动链
systemd-analyze critical-chain myapp.service
```

---

## 10. 🛠️ 实战案例与最佳实践


### 10.1 完整的Web应用服务配置


#### 🔸 Node.js应用示例

```ini
[Unit]
Description=Node.js Web Application
Documentation=https://github.com/company/myapp
After=network-online.target mysql.service
Wants=network-online.target
Requires=mysql.service

[Service]
Type=simple
User=webapp
Group=webapp
WorkingDirectory=/opt/myapp
Environment="NODE_ENV=production"
Environment="PORT=3000"
EnvironmentFile=-/etc/myapp/production.env

ExecStartPre=-/usr/bin/mkdir -p /var/log/myapp
ExecStartPre=/usr/local/bin/check-database-connection.sh
ExecStart=/usr/bin/node server.js
ExecReload=/bin/kill -HUP $MAINPID

Restart=on-failure  
RestartSec=10
StartLimitBurst=3
StartLimitIntervalSec=60

# 安全配置
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/log/myapp /var/lib/myapp

# 资源限制
MemoryLimit=512M
CPUQuota=50%

[Install]
WantedBy=multi-user.target
```

#### 🔸 Java Spring Boot应用

```ini
[Unit]
Description=Spring Boot Application  
After=network.target

[Service]
Type=simple
User=springapp
Group=springapp
WorkingDirectory=/opt/springapp

ExecStart=/usr/bin/java -jar \
  -Xmx512m -Xms256m \
  -Dspring.profiles.active=production \
  /opt/springapp/app.jar

ExecStop=/bin/kill -TERM $MAINPID
KillMode=mixed
KillSignal=TERM
TimeoutStopSec=30

Restart=on-failure
RestartSec=15

[Install]
WantedBy=multi-user.target
```

### 10.2 数据库服务配置


#### 🔸 自定义MySQL配置

```ini
[Unit]
Description=Custom MySQL Database  
After=network.target

[Service]
Type=notify
User=mysql
Group=mysql

ExecStartPre=/usr/local/bin/mysql-pre-start.sh
ExecStart=/usr/sbin/mysqld --defaults-file=/etc/mysql/my.cnf
ExecReload=/bin/kill -HUP $MAINPID

TimeoutSec=300
Restart=on-failure
RestartSec=30

# MySQL特定配置
OOMScoreAdjust=-500
LimitNOFILE=65536
LimitMEMLOCK=infinity

[Install]
WantedBy=multi-user.target
```

### 10.3 定时任务服务


#### 🔸 数据备份服务

```ini
[Unit]
Description=Database Backup Service
Requires=mysql.service
After=mysql.service

[Service]  
Type=oneshot
User=backup
Group=backup
ExecStart=/usr/local/bin/backup-database.sh
RemainAfterExit=no

# 任务失败不影响系统
SuccessExitStatus=0 1
```

配套的timer文件 (`backup.timer`)：
```ini
[Unit]
Description=Run backup daily
Requires=backup.service

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
```

### 10.4 监控和维护


#### 🔸 健康检查脚本集成

```bash
#!/bin/bash
# /usr/local/bin/health-check.sh
curl -f http://localhost:8080/health || exit 1
```

```ini
[Service]
ExecStartPost=/usr/local/bin/health-check.sh
ExecReload=/usr/local/bin/health-check.sh
```

#### 🔸 日志管理配置

```ini
[Service]
StandardOutput=journal
StandardError=journal  
SyslogIdentifier=myapp

# 或输出到文件
StandardOutput=file:/var/log/myapp/output.log
StandardError=file:/var/log/myapp/error.log
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 服务文件结构：[Unit] + [Service] + [Install] 三段式
🔸 配置文件位置：/etc/systemd/system/ 优先级最高
🔸 依赖关系配置：After确定顺序，Wants/Requires确定依赖强度
🔸 启动命令配置：ExecStart是核心，配合Pre/Post命令
🔸 重启策略：on-failure是最佳平衡选择
🔸 用户权限：专用用户运行，遵循最小权限原则
🔸 环境变量：敏感信息用文件管理，权限控制严格
```

### 11.2 关键理解要点


**🔹 依赖关系选择策略**
```
启动顺序：Always use After
可选功能：Wants + After  
必需依赖：Requires + After
互斥服务：Conflicts
```

**🔹 重启策略最佳实践**
```
常规应用：
Restart=on-failure + RestartSec=10 + 启动限制

关键服务：
Restart=always + 更长的RestartSec + 宽松的启动限制

一次性任务：
Restart=no + Type=oneshot
```

**🔹 安全配置原则**
```
用户权限：专用用户，最小权限
文件权限：只读系统目录，限制写入范围  
网络权限：按需开放，默认限制
系统调用：使用SystemCallFilter限制
```

### 11.3 实际应用指导


**🎯 不同类型应用的配置模板**

```
Web应用程序：
Type=simple + Restart=on-failure
After=network-online.target + 数据库依赖
用户权限 + 资源限制 + 环境变量文件

数据库服务：
Type=notify/forking + 严格的重启策略
资源限制 + 文件描述符限制
数据目录权限配置

微服务架构：
清晰的依赖链 + 健康检查
服务发现配置 + 日志集中管理
容器化配置兼容
```

### 11.4 常见问题解决


**🔧 启动失败诊断**
```bash
# 查看服务状态
systemctl status myapp.service

# 查看详细日志
journalctl -u myapp.service -f

# 检查配置语法  
systemd-analyze verify myapp.service

# 重新加载配置
systemctl daemon-reload
```

**🔧 依赖问题排查**
```bash
# 查看依赖树
systemctl list-dependencies myapp.service

# 查看启动顺序
systemd-analyze critical-chain myapp.service

# 手动测试启动
systemctl start myapp.service --no-block
```

### 11.5 配置文件管理


**🚀 版本控制最佳实践**
```bash
# 配置文件版本控制
cd /etc/systemd/system
git init
git add *.service
git commit -m "Initial service configurations"

# 修改后的提交流程
systemctl daemon-reload
systemctl restart myapp.service
systemctl is-active myapp.service && git add myapp.service && git commit -m "Update myapp service config"
```

**🚀 配置模板化**
```bash
# 创建配置模板
mkdir -p /opt/systemd-templates
cp standard-webapp.service.template /opt/systemd-templates/

# 使用模板创建新服务
sed 's/{{APP_NAME}}/newapp/g' standard-webapp.service.template > /etc/systemd/system/newapp.service
```

**核心记忆要点：**
- systemd服务配置是现代Linux系统管理的核心技能
- 三段式结构简单清晰：Unit描述关系，Service定义行为，Install决定启用
- 依赖关系和重启策略是配置的重点和难点
- 安全配置不可忽视：专用用户、权限限制、资源控制
- 实际应用中要结合监控、日志、健康检查形成完整方案