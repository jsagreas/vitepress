---
title: 6、选择与分支
---
## 📚 目录

1. [交替匹配基础](#1-交替匹配基础)
2. [交替匹配实践应用](#2-交替匹配实践应用)
3. [条件匹配机制](#3-条件匹配机制)
4. [基于捕获组的条件匹配](#4-基于捕获组的条件匹配)
5. [基于断言的条件匹配](#5-基于断言的条件匹配)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔀 交替匹配基础


### 1.1 交替匹配语法结构


**🔸 什么是交替匹配**
交替匹配就像多选题，从几个选项中选择一个进行匹配。使用竖线`|`作为"或者"的意思，让正则表达式可以匹配多种不同的模式。

```
交替匹配（Alternation）架构：
├── 基本语法
│   └── A|B           # 匹配 A 或 B
├── 组合交替（分组配合使用）
│   └── (A|B|C)       # 匹配 A、B 或 C，作为一个整体处理
├── 配合结构
│   ├── \b(cat|dog)\b  # 匹配完整单词 "cat" 或 "dog"
│   ├── (https?|ftp):// # 匹配 URL 协议 http、https 或 ftp
│   └── (jpg|png|gif)$ # 匹配以 .jpg/.png/.gif 结尾的字符串
└── 默认贪婪（从左到右优先匹配）
```

### 1.2 基础语法示例


**💡 简单交替匹配**
```bash
cat|dog       # 匹配 "cat" 或 "dog"            
# → "I like cat" ✔，"a dog ran" ✔

red|green|blue
              # 匹配三种颜色任意一种            
# → "blue sky" ✔

(http|https)://
              # 匹配网址协议部分                 
# → "http://..."、"https://..."

(\.jpg|\.png)$
              # 匹配文件后缀名                  
# → "image.jpg" ✔，"doc.txt" ✘

(colou?r)
              # 匹配 "color" 或 "colour"         
# → 支持美式和英式拼写
```

### 1.3 优先级注意事项


**⚠️ 为什么需要括号分组**

```bash
# ❌ 错误写法：优先级混乱
www\.baidu\.com|google
# 这个表达式会先尝试匹配 www.，然后是 baidu.com|google
# 实际效果：匹配 "www.baidu.com" 或者 "google"

# ✅ 推荐写法：明确分组范围
(www\.baidu\.com|google)
# 清晰表达：匹配完整的网址或者 google
```

**🎯 优先级规则**
- 交替匹配从左到右进行
- 第一个匹配成功的选项会被选中
- 使用括号明确交替的范围

---

## 2. 🎯 交替匹配实践应用


### 2.1 与分组结合的常见结构


**🔧 实用表达式示例**

```bash
# 匹配完整单词
\b(cat|dog|fish)\b         
# 匹配完整单词 "cat"、"dog" 或 "fish"

# 匹配前缀
^(un|re|in)\w+              
# 匹配以 "un"、"re"、"in" 开头的单词，如 "undo", "retry"

# 兼容性匹配
\b(color|colour)\b         
# 匹配 "color" 或 "colour"，兼容英美拼写

# URL协议匹配
(https?|ftp)://            
# 匹配以 http://、https:// 或 ftp:// 协议开头的 URL

# 称谓匹配
(Mr|Mrs|Ms)\.\s[A-Z]\w+     
# 匹配带称谓的人名，如 "Mr. Smith"
```

### 2.2 复杂应用场景


**📅 日期格式匹配**
```bash
(?:19|20)\d{2}-(0[1-9]|1[0-2])-(\d{2}) 
# 匹配 "1999-12-31"、"2023-01-01" 格式的日期
```

**📞 电话号码匹配**
```bash
(\d{3}-|\(\d{3}\))\d{3}-\d{4}
# 匹配电话号码：123-456-7890 或 (123)456-7890
```

**📧 邮箱地址匹配**
```bash
([a-zA-Z0-9_.+-]+)@([a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)
# 匹配邮箱地址，分组提取用户名和域名部分
```

### 2.3 高级匹配技巧


**🔄 重复匹配**
```bash
(\w+)\s+\1                # 匹配重复单词，如 "hello hello"
```

**🏷️ HTML标签匹配**
```bash
<(h[1-6])>.*?</\1>        # 匹配 HTML 标题标签，如 <h1>内容</h1>
```

**🖼️ 文件类型匹配**
```bash
file\.(jpg|jpeg|png|gif)$ # 匹配图片文件名结尾，包含常见图片格式
```

**📋 日志级别匹配**
```bash
(?:ERROR|WARNING|INFO):   # 匹配日志中的等级关键词（非捕获分组）
```

### 2.4 网络相关匹配


**🌐 IP地址匹配**
```bash
(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}
(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)
# 匹配 IPv4 地址格式（4 个分组）
```

**📱 手机号匹配**
```bash
((?:\+86)?1[3-9]\d{9})    # 匹配中国大陆手机号，可选 +86 前缀
```

### 2.5 交替匹配注意事项


| 项目 | **建议说明** | **实际意义** |
|------|------------|-------------|
| `使用括号分组` | `避免优先级错乱，明确交替范围` | `保证匹配逻辑正确` |
| `由左至右匹配优先` | `若多个分支同时匹配，从左边优先匹配` | `匹配结果可预测` |
| `可配合边界使用` | `使用 \b、^、$ 控制更精确的匹配位置` | `避免部分匹配问题` |
| `性能考虑` | `常用选项放在前面` | `提高匹配效率` |

---

## 3. 🎛️ 条件匹配机制


### 3.1 条件匹配概念理解


**🔸 什么是条件匹配**
条件匹配就像编程中的if-else语句，根据某个条件的真假来决定后续匹配什么内容。正则表达式可以根据前面的匹配结果来动态选择不同的匹配策略。

**🔸 条件匹配分类架构**
```
正则中的条件匹配分类：
├── 基于捕获组的条件（编号或命名组）
│   └── 是否曾匹配某个组，用它来决定后续匹配内容
│
└── 基于断言（前瞻/后顾）条件
    └── 利用 (?=...)、(?<=...) 的真假结果做分支判断
```

### 3.2 条件匹配的应用价值


**💡 解决的实际问题**
- **格式灵活性**: 根据前缀决定后续格式要求
- **上下文敏感**: 根据周围环境选择不同匹配策略  
- **数据验证**: 复杂的表单验证逻辑
- **文本解析**: 处理多种可能的文本格式

**🎯 典型应用场景**
```
条件控制格式：有前缀 vs 无前缀
动态匹配不同内容结构：用户输入、命令参数  
HTML/XML 类结构判断：是否闭合标签
日志、协议等格式差异识别
```

---

## 4. 📊 基于捕获组的条件匹配


### 4.1 捕获组条件匹配语法


**🔸 基本语法结构**
```
基于捕获组的条件匹配架构：
├── 基本语法结构
│   ├── (组X)?       → 捕获组，用于判断是否匹配过
│   ├── (?(X)then)   → 如果组X匹配，则执行 then 分支
│   └── (?(X)then|else)
│       ├── then：组X匹配成功时要匹配的内容
│       └── else：组X未匹配时要匹配的内容（可选）
├── 分支语法说明
│   ├── X 是数字     → 表示捕获组编号，例如 \1, \2...
│   └── X 是名字     → 支持命名组，例如 (?<name>...)，使用 (?(name)...)
└── 语义逻辑理解
    ├── 组有内容     → then 分支执行
    └── 组为空或未匹配 → else 分支执行（如果有）
```

### 4.2 编号组判断示例


**🔧 基础示例：数字前缀控制**
```bash
(\d+)?(?(1)[A-Z]+|[a-z]+)
# 有数字前缀 → 匹配大写；否则 → 匹配小写
```

**📊 匹配结果分析**

| 输入 | **匹配结果** | **详细说明** |
|------|------------|-------------|
| `123ABC` | `✔ 匹配成功` | `组1 = "123"，进入大写分支 → "ABC"` |
| `abc` | `✔ 匹配成功` | `组1未匹配 → 匹配小写分支` |
| `123abc` | `✘ 匹配失败` | `有组1，但小写不符合分支 → 不匹配` |

### 4.3 命名组判断示例


**🔧 命名组示例：前缀判断**
```bash
(?<pre>un)?(?(pre)known|known)
# 有前缀 "un" → 匹配 "known"；否则也匹配 "known"
```

**📊 匹配结果分析**

| 输入 | **匹配结果** | **详细说明** |
|------|------------|-------------|
| `unknown` | `✔ 匹配成功` | `组 pre 匹配成功 → "known"` |
| `known` | `✔ 匹配成功` | `没有 pre → 仍匹配 "known"` |
| `unKNEW` | `✘ 匹配失败` | `后面不是 "known" → 不匹配` |

### 4.4 实际应用场景


**📱 手机号格式判断**
```bash
(\+86)?(?(1)1[3-9]\d{9}|1[3-9]\d{9})
# 有国际前缀时匹配完整格式，否则匹配国内格式
```

**🏷️ HTML标签匹配**
```bash
(<(\w+)>)?(?(1).*?</\2>|.*?)
# 如果有开始标签，必须有对应的结束标签
```

### 4.5 注意事项


**⚠️ 重要限制**
```
捕获组必须在条件之前出现（向前判断）
条件语法并非所有引擎支持（JS、Java 不支持）
复杂条件建议分步处理或用非捕获组优化性能
```

---

## 5. 🔍 基于断言的条件匹配


### 5.1 断言条件匹配语法


**🔸 基本语法结构**
```
基于断言的条件匹配架构：
├── 基本语法结构
│   ├── (?(?=X)then|else)    → 正向前瞻条件
│   ├── (?(?!X)then|else)    → 负向前瞻条件
│   ├── (?(?<=X)then|else)   → 正向后顾条件
│   └── (?(?<!X)then|else)   → 负向后顾条件
├── 语法说明
│   ├── 条件部分是一个断言表达式（不是捕获组）
│   ├── 如果断言结果为真 → 执行 then 分支
│   └── 否则 → 执行 else 分支（可省略）
└── 断言类型回顾（作为条件部分使用）
    ├── (?=X)      → 前面即将是 X
    ├── (?!X)      → 前面不是 X
    ├── (?<=X)     → 前面刚刚是 X
    └── (?<!X)     → 前面不是 X
```

### 5.2 前瞻条件判断示例


**🔧 示例1：前瞻判断后面是否是数字**
```bash
(?(?=\d{3})\d{3}|\w{3})
# 如果后面是 3 位数字 → 匹配数字；否则 → 匹配任意单词字符
```

**📊 匹配结果分析**

| 输入 | **匹配结果** | **详细说明** |
|------|------------|-------------|
| `123` | `✔ 匹配成功` | `前瞻成功，匹配 \d{3}` |
| `abc` | `✔ 匹配成功` | `前瞻失败，匹配 \w{3}` |
| `12a` | `✘ 匹配失败` | `前瞻失败，\w{3} 不满足 → 不匹配` |

### 5.3 后顾条件判断示例


**🔧 示例2：后顾判断前面是否是 @ 符号**
```bash
(?(?<=@)[a-z]+|\d+)
# 如果前面是 @ → 匹配小写字母；否则 → 匹配数字
```

**📊 匹配结果分析**

| 输入 | **匹配结果** | **详细说明** |
|------|------------|-------------|
| `@gmail` | `✔ 匹配成功` | `前顾成功 → 匹配 "gmail"` |
| `123` | `✔ 匹配成功` | `没有 @ → 匹配数字` |
| `@123` | `✘ 匹配失败` | `有 @ 但后面不是小写字母 → 匹配失败` |

### 5.4 复杂结构示例


**🔧 示例3：HTML结构判断**
```bash
(?(?=<div>)<div>.*?</div>|.*)
# 如果当前位置开始是 <div>，匹配整个标签；否则匹配其他文本
```

**📊 匹配结果分析**

| 输入 | **匹配结果** | **详细说明** |
|------|------------|-------------|
| `<div>abc</div>` | `✔ 匹配成功` | `前瞻成功，匹配完整div标签` |
| `普通文字段落` | `✔ 匹配成功` | `前瞻失败，匹配其他内容` |
| `<p>text</p>` | `✔ 匹配成功` | `匹配到 else 分支 .*` |

### 5.5 典型应用场景


**🎯 实际应用领域**
- **上下文决定匹配方式**: 根据前后文选择不同策略
- **文本格式灵活切换**: 字母 vs 数字，标签 vs 普通文本
- **表单校验**: 手机号 vs 邮箱 vs 地址格式判断
- **模拟 if/else 分支逻辑**: 复杂的条件判断

### 5.6 注意事项


**⚠️ 重要限制和建议**
```
断言条件不参与捕获，不消耗字符（零宽匹配）
JS 和 Java 等正则引擎不支持条件语法
Python、.NET、Perl 等支持完整条件 + 断言组合
可与捕获组条件组合嵌套（但正则可读性会变差）
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 关键技术要点**
```
交替匹配：使用 | 实现多选项匹配，注意优先级和分组
条件匹配：根据前面的匹配结果决定后续匹配策略
捕获组条件：基于组是否匹配来进行分支判断
断言条件：基于位置断言的真假来选择匹配分支
语法兼容性：不同正则引擎对条件匹配支持程度不同
```

### 6.2 技术选择建议


**🎯 使用场景对应**

| 场景类型 | **推荐技术** | **适用条件** |
|---------|------------|-------------|
| `简单多选` | `交替匹配 A|B` | `固定几个选项之间选择` |
| `复杂条件` | `捕获组条件` | `需要根据前面内容决定后续` |
| `位置敏感` | `断言条件` | `根据上下文环境选择策略` |
| `兼容性要求高` | `分步匹配` | `避免使用条件语法` |

### 6.3 实践应用指导


**📋 最佳实践建议**

**基础应用**:
- [x] 文件类型匹配：`\.(jpg|png|gif)$`
- [x] 协议匹配：`(https?|ftp)://`  
- [x] 英美拼写兼容：`(color|colour)`

**进阶应用**:
- [x] 电话号码格式：条件匹配不同格式
- [x] 邮箱地址验证：组合多种验证规则
- [x] HTML标签处理：配对标签匹配

**高级应用**:
- [x] 复杂表单验证：多条件组合判断
- [x] 日志解析：根据级别选择不同策略
- [x] 协议解析：动态格式识别

### 6.4 注意事项和限制


**⚠️ 重要提醒**
- **括号分组**: 交替匹配必须明确范围，避免优先级错误
- **引擎兼容**: 条件匹配语法不是所有引擎都支持
- **性能考虑**: 复杂条件会影响匹配性能
- **可读性**: 过度嵌套会降低正则表达式的可维护性

**🔧 实用建议**
- 优先使用简单的交替匹配
- 复杂逻辑考虑分步处理
- 测试不同正则引擎的兼容性
- 添加详细注释说明复杂表达式

> 💡 **学习要点**  
> 选择与分支是正则表达式的高级特性，能够实现类似编程语言中的条件判断功能。掌握这些技术可以让正则表达式处理更复杂的文本匹配需求，但要注意平衡功能复杂度和代码可维护性。

**🧠 记忆口诀**：
- 交替用竖线，多选一匹配
- 括号明范围，优先级清晰
- 条件看组值，真假走分支
- 断言判位置，上下文决策