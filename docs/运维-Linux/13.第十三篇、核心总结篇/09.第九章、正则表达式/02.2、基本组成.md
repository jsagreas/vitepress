---
title: 2、基本组成
---
## 📚 目录

1. [正则表达式的构成元素](#1-正则表达式的构成元素)
2. [匹配模式与标志](#2-匹配模式与标志)
3. [核心要点总结](#3-核心要点总结)

---

## 1. 🧩 正则表达式的构成元素


### 1.1 构成元素总览


**正则表达式的组成架构**：
```
正则表达式 = 普通字符 + 元字符 + 预定义字符类 + 断言 + 修饰符

简单理解：
普通字符：就像平时写的字母数字，直接匹配
元字符：有特殊魔法的符号，控制匹配规则
预定义字符类：常用模式的简写形式
断言：不占位置的条件检查
修饰符：改变整个匹配的行为方式
```

### 1.2 普通字符详解


**🔤 基础构成字符**

**字母字符**：
- **英文字母** - `a-z`（小写）、`A-Z`（大写）
- **直接匹配** - 在正则中写什么字母就匹配什么字母
- **示例** - `hello` 匹配文本中的 "hello"

**数字字符**：
- **数字范围** - `0-9` 
- **直接匹配** - 写数字几就匹配数字几
- **示例** - `123` 匹配文本中的 "123"

**其他符号**：
- **非特殊符号** - `@`、`#`、`%`、`&` 等
- **安全使用** - 这些符号在正则中没有特殊含义，可以直接使用
- **示例** - `user@domain.com` 中的 `@` 就是普通字符

### 1.3 元字符详解


#### 🔸 通配符


**点符号（.）**：
```
含义：匹配任意单个字符（除换行符外）
示例：
a.c 可以匹配：abc、a1c、a@c、a c
不能匹配：ac（缺少中间字符）、abbc（中间多个字符）
```

#### 🔸 重复匹配符


**星号（*）**：
```
含义：前面的字符重复0次或多次
示例：
ab*c 可以匹配：ac（b出现0次）、abc（b出现1次）、abbc（b出现2次）
```

**加号（+）**：
```
含义：前面的字符重复1次或多次
示例：
ab+c 可以匹配：abc、abbc、abbbc
不能匹配：ac（b必须至少出现1次）
```

**问号（?）**：
```
含义：前面的字符可选（0次或1次）
示例：
colou?r 可以匹配：color（u出现0次）、colour（u出现1次）
```

**花括号（{n,m}）**：
```
含义：精确控制重复次数
{n}：恰好n次
{n,}：至少n次
{n,m}：n到m次

示例：
a{3}：匹配 aaa
a{2,4}：匹配 aa、aaa、aaaa
```

#### 🔸 分组与引用


**圆括号（()）**：
```
含义：将多个字符作为一个整体分组
作用：
1. 分组处理：(abc)+ 匹配 abc、abcabc、abcabcabc
2. 捕获内容：可以提取匹配的子字符串
```

**反向引用（\1, \2）**：
```
含义：引用前面捕获组匹配的内容
示例：
(abc)\1 匹配 abcabc（第二个abc必须和第一个一样）
(\w+)\s+\1 匹配重复的单词，如 "hello hello"
```

**非捕获组（(?:)）**：
```
含义：分组但不捕获内容
示例：
(?:abc)+ 匹配 abc、abcabc，但不保存匹配内容供后续引用
```

#### 🔸 字符类


**方括号（[]）**：
```
含义：匹配方括号内任意一个字符
示例：
[abc] 匹配 a 或 b 或 c
[0-9] 匹配任意一个数字
[a-zA-Z] 匹配任意一个字母
```

**排除字符集（[^]）**：
```
含义：匹配不在方括号内的任意字符
示例：
[^abc] 匹配除了a、b、c之外的任意字符
[^0-9] 匹配任意非数字字符
```

**范围符（-）**：
```
含义：在字符类中表示字符范围
示例：
[a-z]：小写字母
[A-Z]：大写字母
[0-9]：数字
```

#### 🔸 边界控制


**行首（^）**：
```
含义：匹配行的开始位置
示例：
^hello 只匹配行首的 "hello"
```

**行尾（$）**：
```
含义：匹配行的结束位置
示例：
world$ 只匹配行尾的 "world"
^hello world$ 匹配整行只有 "hello world"
```

**单词边界（\b）**：
```
含义：匹配单词的边界位置
示例：
\bcat\b 匹配完整单词 "cat"
不匹配 "category" 中的 "cat"
```

**非单词边界（\B）**：
```
含义：匹配非单词边界位置
示例：
\Bcat\B 匹配 "category" 中的 "cat"
不匹配独立的单词 "cat"
```

#### 🔸 逻辑选择


**竖线（|）**：
```
含义：逻辑或运算，匹配左边或右边的表达式
示例：
cat|dog 匹配 "cat" 或 "dog"
(red|blue) car 匹配 "red car" 或 "blue car"
```

#### 🔸 转义字符


**反斜杠（\）**：
```
含义：转义元字符，让特殊字符失去特殊含义
示例：
\. 匹配点号字符 "."
\* 匹配星号字符 "*"
\\ 匹配反斜杠字符 "\"
```

### 1.4 预定义字符类


**什么是预定义字符类**：
预定义字符类就是正则表达式提供的"快捷方式"，用简短的符号代替常用的字符集合。

#### 📊 预定义字符类对照表


| 简写 | 等价形式 | 含义 | 示例 |
|------|---------|------|------|
| **\d** | `[0-9]` | 数字字符 | `\d+` 匹配 "123" |
| **\D** | `[^0-9]` | 非数字字符 | `\D+` 匹配 "abc" |
| **\w** | `[a-zA-Z0-9_]` | 单词字符 | `\w+` 匹配 "hello_123" |
| **\W** | `[^a-zA-Z0-9_]` | 非单词字符 | `\W+` 匹配 "@#$" |
| **\s** | `[ \t\n\r\f]` | 空白字符 | `\s+` 匹配空格、制表符等 |
| **\S** | `[^ \t\n\r\f]` | 非空白字符 | `\S+` 匹配非空白内容 |

**实际应用示例**：
```
手机号验证：\d{11}
邮箱格式：\w+@\w+\.\w+
提取单词：\w+
分割空白：\s+
```

### 1.5 断言（零宽断言）


**断言的概念**：
断言就像"条件检查员"，它检查某个位置是否满足条件，但不消耗字符（零宽度）。

```
断言类型分布图：
                位置检查
                    │
        ┌───────────┼───────────┐
        │                     │
    先行断言                后行断言
    (向前看)                (向后看)
        │                     │
    ┌───┴───┐             ┌───┴───┐
    │       │             │       │
  正向    负向           正向    负向
 (?=X)   (?!X)        (?<=X)  (?<!X)
```

#### 🔍 断言详解


**正向先行断言 (?=X)**：
```
含义：当前位置后面必须跟着 X
示例：
hello(?=world) 匹配 "helloworld" 中的 "hello"
不匹配 "hello123" 中的 "hello"
```

**负向先行断言 (?!X)**：
```
含义：当前位置后面不能跟着 X
示例：
hello(?!world) 匹配 "hello123" 中的 "hello"
不匹配 "helloworld" 中的 "hello"
```

**正向后行断言 (?<=X)**：
```
含义：当前位置前面必须是 X
示例：
(?<=hello)world 匹配 "helloworld" 中的 "world"
不匹配 "123world" 中的 "world"
```

**负向后行断言 (?<!X)**：
```
含义：当前位置前面不能是 X
示例：
(?<!hello)world 匹配 "123world" 中的 "world"
不匹配 "helloworld" 中的 "world"
```

### 1.6 修饰符（模式标志）


**修饰符的作用**：
修饰符就像"全局设置"，改变整个正则表达式的匹配行为。

#### ⚙️ 常用修饰符


**i（忽略大小写）**：
```
作用：让匹配不区分大小写
示例：
/hello/i 可以匹配 "Hello"、"HELLO"、"hello"
```

**g（全局匹配）**：
```
作用：找到所有匹配项，而不是只找第一个
示例：
/a/g 在 "banana" 中找到 3 个 "a"
/a/ 在 "banana" 中只找到第 1 个 "a"
```

**m（多行模式）**：
```
作用：^ 和 $ 匹配每一行的开头和结尾
示例：
/^hello/m 在多行文本中匹配每行开头的 "hello"
```

**s（单行模式）**：
```
作用：让 . 可以匹配换行符
示例：
/hello.world/s 可以匹配跨行的 "hello\nworld"
```

### 1.7 注释与命名


**注释 (?#...)**：
```
作用：在正则表达式中添加注释说明
示例：
\d{4}(?#年份)-\d{2}(?#月份)-\d{2}(?#日期)
```

**命名捕获组 (?<name>...)**：
```
作用：给捕获组起个有意义的名字
示例：
(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})
```

**命名反向引用 \k<name>**：
```
作用：引用命名捕获组的内容
示例：
(?<word>\w+)\s+\k<word> 匹配重复单词
```

---

## 2. 🚩 匹配模式与标志


### 2.1 模式标志概念


**什么是匹配模式**：
匹配模式（Flags/Modifiers）就像给正则表达式设置"工作规则"，告诉正则引擎用什么方式去匹配文本。

```
工作方式示意：
正则表达式 + 匹配模式 = 具体的匹配行为

例如：
/hello/ + i标志 = 不区分大小写匹配
/hello/ + g标志 = 全局查找所有匹配
/hello/ + ig标志 = 不区分大小写 + 全局查找
```

**设置方式**：
- **直接设置** - 在正则表达式后添加标志：`/pattern/flags`
- **API设置** - 通过编程接口设置：`new RegExp(pattern, flags)`

### 2.2 常用标志详解


#### 🔤 i（ignoreCase）- 忽略大小写


**基本概念**：
```
作用：让匹配过程不区分字母大小写
默认行为：严格区分大小写
使用场景：用户输入、不确定大小写的文本匹配
```

**实际示例**：
```javascript
// 不使用 i 标志
/abc/.test("ABC")     // false
/abc/.test("abc")     // true

// 使用 i 标志  
/abc/i.test("ABC")    // true
/abc/i.test("Abc")    // true
/abc/i.test("abc")    // true
```

**应用场景**：
- **用户搜索** - 不管用户输入大小写都能找到结果
- **配置文件解析** - 配置项不区分大小写
- **邮箱验证** - 邮箱地址通常不区分大小写

#### 🌐 g（global）- 全局匹配


**基本概念**：
```
作用：找到所有匹配项，而不是找到第一个就停止
默认行为：找到第一个匹配就停止
使用场景：替换所有匹配项、统计匹配次数
```

**匹配行为对比**：
```javascript
let text = "apple banana apple orange";

// 不使用 g 标志 - 只找第一个
text.match(/apple/)    // ["apple"]

// 使用 g 标志 - 找所有
text.match(/apple/g)   // ["apple", "apple"]
```

**实际应用**：
```javascript
// 替换所有匹配项
let text = "hello world hello";
text.replace(/hello/g, "hi")    // "hi world hi"
text.replace(/hello/, "hi")     // "hi world hello" (只替换第一个)
```

#### 📄 m（multiline）- 多行模式


**基本概念**：
```
作用：改变 ^ 和 $ 的匹配行为
默认：^ 匹配整个字符串开头，$ 匹配整个字符串结尾
多行模式：^ 匹配每行开头，$ 匹配每行结尾
```

**行为对比图**：
```
文本内容：
line1
line2  
line3

默认模式：
^ 只匹配 ──→ line1 (字符串开头)
$ 只匹配 ──→ line3 (字符串结尾)

多行模式(m)：
^ 匹配 ──→ line1, line2, line3 (每行开头)
$ 匹配 ──→ line1, line2, line3 (每行结尾)
```

**实际示例**：
```javascript
let text = `first line
second line
third line`;

// 不使用 m 标志
text.match(/^.*$/);     // null (无法匹配，因为有换行符)

// 使用 m 标志
text.match(/^.*$/gm);   // ["first line", "second line", "third line"]
```

#### 🔄 s（dotAll）- 单行模式


**基本概念**：
```
作用：让 . 可以匹配包括换行符在内的任意字符
默认：. 匹配除换行符外的任意字符
单行模式：. 匹配包括换行符的任意字符
```

**匹配行为对比**：
```javascript
let text = `hello
world`;

// 不使用 s 标志
/hello.world/.test(text)    // false (. 不匹配换行符)

// 使用 s 标志
/hello.world/s.test(text)   // true (. 可以匹配换行符)
```

**应用场景**：
- **多行内容匹配** - 匹配跨行的模式
- **HTML标签匹配** - 匹配包含换行的标签内容
- **代码块匹配** - 匹配多行代码片段

#### 🌍 u（unicode）- Unicode模式


**基本概念**：
```
作用：启用完整的Unicode支持
影响：正确处理Unicode字符和码点
主要用于：JavaScript等语言的UTF-16处理
```

**Unicode字符处理**：
```javascript
// 不使用 u 标志 - 可能无法正确处理
/^.$/u.test('𝒳')        // true (正确识别为单个字符)
/^.$/.test('𝒳')         // false (被识别为两个字符)

// Unicode码点匹配
/\u{1F600}/u.test('😀')  // true (表情符号)
```

#### 📌 y（sticky）- 粘性模式


**基本概念**：
```
作用：必须从 lastIndex 位置开始匹配
特点：连续匹配，不跳过字符
主要支持：JavaScript
```

**粘性匹配示例**：
```javascript
let regex = /abc/y;
let text = "abcabc";

regex.exec(text);  // ["abc"] (从位置0开始)
regex.exec(text);  // ["abc"] (从位置3开始)
regex.exec(text);  // null (从位置6开始，没有内容)
```

### 2.3 不同语言的设置方式


#### 💻 各语言标志设置


**JavaScript**：
```javascript
// 字面量方式
let regex1 = /pattern/igm;

// 构造函数方式  
let regex2 = new RegExp("pattern", "igm");

// 检查标志
regex1.flags;  // "igm"
```

**Java**：
```java
// 编译时设置
Pattern pattern = Pattern.compile("pattern", 
    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

// 常用标志常量
Pattern.CASE_INSENSITIVE  // 忽略大小写
Pattern.MULTILINE         // 多行模式
Pattern.DOTALL           // . 匹配任意字符
```

**Python**：
```python
import re

# 编译时设置
pattern = re.compile("pattern", re.IGNORECASE | re.MULTILINE)

# 函数调用时设置
re.search("pattern", text, re.IGNORECASE)

# 常用标志
re.IGNORECASE  # 忽略大小写
re.MULTILINE   # 多行模式  
re.DOTALL      # . 匹配任意字符
```

**C#**：
```csharp
// Regex构造函数设置
Regex regex = new Regex("pattern", 
    RegexOptions.IgnoreCase | RegexOptions.Multiline);

// 静态方法设置
Regex.IsMatch(text, "pattern", RegexOptions.IgnoreCase);
```

### 2.4 标志组合使用


#### 🔗 常用组合模式


**搜索类组合（ig）**：
```
用途：不区分大小写的全局搜索
场景：文本搜索、内容过滤
示例：/keyword/ig 找到所有关键词，不管大小写
```

**文本处理组合（igm）**：
```
用途：多行文本的全面处理
场景：日志分析、配置文件处理
示例：/^ERROR/igm 找到所有以ERROR开头的行
```

**内容匹配组合（ims）**：
```
用途：跨行内容匹配
场景：HTML解析、代码分析
示例：/<div.*?<\/div>/ims 匹配跨行的div标签
```

#### ⚠️ 注意事项


**标志冲突处理**：
```
某些标志可能在逻辑上冲突：
- m和s看似矛盾，但实际可以共存
- 不同语言对标志支持程度不同
- 有些语言有独特的标志（如JavaScript的y）
```

**性能考虑**：
```
标志对性能的影响：
- g标志会影响匹配策略
- u标志在JavaScript中影响字符处理
- 复杂组合可能降低匹配速度
```

---

## 3. 📋 核心要点总结


### 3.1 必须掌握的基本概念


```
🔸 普通字符：直接匹配的字母、数字、符号
🔸 元字符：具有特殊含义的控制符号
🔸 预定义字符类：\d \w \s 等常用简写
🔸 断言：零宽度的位置检查
🔸 修饰符：改变匹配行为的全局标志
```

### 3.2 关键理解要点


**🔹 元字符的魔法**
```
理解要点：
- 元字符是正则的"魔法符号"，让简单字符拥有特殊能力
- 需要匹配元字符本身时，要用反斜杠转义
- 不同上下文中，同一符号可能有不同含义
```

**🔹 预定义字符类的便利**
```
记忆方法：
- \d = digit（数字）
- \w = word（单词字符）  
- \s = space（空白字符）
- 大写字母表示相反含义（\D = 非数字）
```

**🔹 断言的精确控制**
```
实际意义：
- 断言让你可以精确控制匹配的上下文
- 零宽度意味着不消耗字符，只检查条件
- 先行和后行分别检查前后位置的内容
```

**🔹 修饰符的全局影响**
```
关键理解：
- 修饰符影响整个正则表达式的行为
- 不同语言的修饰符语法可能不同
- 组合使用时要注意逻辑关系
```

### 3.3 实际应用价值


**🎯 常见应用场景**
- **数据验证** - 邮箱、手机号、身份证格式检查
- **文本搜索** - 关键词查找、内容过滤
- **数据提取** - 从文本中提取特定信息
- **字符串替换** - 批量文本处理和格式化

**🔧 学习建议**
- **循序渐进** - 先掌握基础元字符，再学习复杂组合
- **实践为主** - 多动手练习，用实际例子验证理解
- **工具辅助** - 使用正则测试工具验证表达式
- **语言特性** - 了解不同编程语言的正则实现差异

**核心记忆口诀**：
```
普通字符直接配，元字符身怀绝技
预定义类有简写，断言检查零宽度
修饰符号管全局，组合使用威力大
转义反斜要记牢，实践验证最重要
```

**重要提醒**：
- 正则表达式功能强大，但也要考虑可读性和维护性
- 复杂的正则应该添加注释说明
- 性能敏感场景要测试正则表达式的执行效率
- 不同语言和版本的正则支持可能有差异