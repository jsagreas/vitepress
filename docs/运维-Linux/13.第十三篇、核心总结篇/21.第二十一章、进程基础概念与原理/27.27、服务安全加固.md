---
title: 27、服务安全加固
---
## 📚 目录

1. [服务安全加固概述](#1-服务安全加固概述)
2. [服务最小权限原则](#2-服务最小权限原则)
3. [用户与组权限设置](#3-用户与组权限设置)
4. [系统隔离机制](#4-系统隔离机制)
5. [系统调用过滤](#5-系统调用过滤)
6. [文件系统隔离](#6-文件系统隔离)
7. [网络隔离配置](#7-网络隔离配置)
8. [安全策略模板](#8-安全策略模板)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ 服务安全加固概述


### 1.1 什么是服务安全加固


**简单理解**：就像给房子装防盗门、防护窗一样，给Linux系统服务加装各种安全措施，防止被坏人利用。

**核心思想**：
```
传统服务启动：给服务最大权限，方便使用
安全加固思路：只给服务必需的最小权限，其他都限制

就像银行出纳员：
❌ 不加固：给出纳员银行所有权限（危险）
✅ 加固后：只能操作自己柜台，其他都禁止（安全）
```

### 1.2 为什么要做安全加固


**现实问题**：
- **服务漏洞**：Web服务被攻击，黑客通过漏洞入侵
- **权限滥用**：服务权限过大，被利用后影响整个系统  
- **数据泄露**：服务能访问敏感文件，被攻击后数据被盗
- **系统破坏**：服务被利用执行危险操作，破坏系统

**加固收益**：
```
🎯 降低攻击面：限制服务能做的事情
🛡️ 隔离影响：即使被攻击，影响范围也很小
🔒 保护数据：阻止服务访问不该访问的文件
⚡ 提升稳定性：防止服务异常影响系统
```

### 1.3 安全加固的核心理念


**最小权限原则**：
```
传统思维：默认允许，需要时禁止
安全思维：默认禁止，必需时才允许

生活类比：
公司新员工 → 只给基本权限 → 根据工作需要逐步开放
而不是：一开始就给所有权限 → 发现问题再收回
```

---

## 2. 🎯 服务最小权限原则


### 2.1 什么是最小权限原则


**核心含义**：给服务**刚好够用**的权限，多一分都不给。

**形象比喻**：
```
🏠 租房子的例子：
租客需要：卧室、厨房、卫生间的使用权
不需要：房东卧室、地下室、阁楼的钥匙

服务权限也一样：
Web服务需要：监听80端口，访问网页文件
不需要：读取用户密码文件，修改系统配置
```

### 2.2 权限分类与限制


**系统权限分类**：
```
📊 权限级别金字塔：
        root权限 (最危险)
            ↓
       系统服务权限
            ↓  
       普通用户权限
            ↓
       受限服务权限 (最安全)
```

**权限限制策略**：

| 权限类型 | **传统方式** | **加固方式** | **安全收益** |
|---------|------------|------------|------------|
| 🔐 **用户权限** | `root运行` | `专用用户运行` | `避免系统级破坏` |
| 📁 **文件访问** | `全盘可读写` | `仅限工作目录` | `保护敏感数据` |
| 🌐 **网络权限** | `所有端口可用` | `仅限必需端口` | `减少攻击面` |
| ⚙️ **系统调用** | `不限制` | `白名单模式` | `防止恶意操作` |

### 2.3 实施最小权限的步骤


**🔍 分析需求阶段**：
```
问题清单：
1. 这个服务到底需要做什么？
2. 需要访问哪些文件和目录？
3. 需要监听哪些网络端口？
4. 需要调用哪些系统功能？
5. 是否需要特殊权限？

nginx服务举例：
✅ 需要：监听80/443端口，读取网页文件，写日志
❌ 不需要：读取/etc/passwd，修改系统配置，访问其他用户数据
```

---

## 3. 👤 用户与组权限设置


### 3.1 User/Group权限设置详解


**基本概念**：每个服务都应该有自己专用的用户账号，就像每个员工都有自己的工号一样。

### 3.2 创建专用服务用户


**服务用户特点**：
```
🔸 系统用户：UID < 1000，不用于登录
🔸 无密码：防止直接登录
🔸 无Shell：通常设为/sbin/nologin
🔸 专用目录：有自己的工作目录
```

**创建服务用户示例**：
```bash
# 创建nginx专用用户
useradd -r -s /sbin/nologin -d /var/lib/nginx nginx

# 参数说明：
# -r: 创建系统用户
# -s: 指定shell（nologin表示不能登录）
# -d: 指定家目录
```

### 3.3 systemd服务配置


**User和Group配置**：
```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My Application
After=network.target

[Service]
# 🎯 核心安全配置
User=myapp          # 指定运行用户
Group=myapp         # 指定运行组
Type=simple
ExecStart=/opt/myapp/bin/myapp
Restart=always

[Install]
WantedBy=multi-user.target
```

**权限验证**：
```bash
# 查看服务运行用户
ps aux | grep myapp

# 检查文件权限
ls -la /opt/myapp/
# 应该显示 myapp用户 拥有必要文件
```

### 3.4 文件权限设置最佳实践


**目录权限设置**：
```bash
# 应用程序目录
chown -R myapp:myapp /opt/myapp/
chmod 755 /opt/myapp/bin/          # 可执行目录
chmod 644 /opt/myapp/config/       # 配置文件只读
chmod 700 /var/log/myapp/          # 日志目录私有

# 权限含义解释：
# 755 = rwxr-xr-x (所有者全权限，其他人只读执行)
# 644 = rw-r--r-- (所有者读写，其他人只读)
# 700 = rwx------ (只有所有者能访问)
```

---

## 4. 🔒 系统隔离机制


### 4.1 PrivateTmp临时目录隔离


**问题背景**：默认情况下，所有服务共享`/tmp`目录，存在安全风险。

**PrivateTmp工作原理**：
```
传统方式：
服务A → /tmp/file1
服务B → /tmp/file2    # 可以看到服务A的临时文件
恶意服务 → /tmp/      # 可以访问所有临时文件

PrivateTmp启用后：
服务A → /tmp/systemd-private-xxx-serviceA-yyy/tmp/file1
服务B → /tmp/systemd-private-xxx-serviceB-zzz/tmp/file2
# 每个服务都有独立的临时目录，互不干扰
```

**配置方式**：
```ini
[Service]
PrivateTmp=true    # 启用私有临时目录
```

**实际效果验证**：
```bash
# 查看服务的临时目录
systemctl show myapp.service | grep PrivateTmp
# 输出：PrivateTmp=yes

# 服务运行时查看实际目录
ls -la /tmp/systemd-private-*
```

### 4.2 NoNewPrivileges权限提升阻止


**安全问题**：某些程序可能通过setuid等机制获取更高权限。

**NoNewPrivileges作用**：
```
🚫 阻止权限提升：
禁止服务通过以下方式获取更高权限：
- setuid/setgid程序
- file capabilities
- SELinux/AppArmor转换

生活类比：
就像给员工一个"权限锁"，无论遇到什么情况，
都不能获得超出当前岗位的权限
```

**配置示例**：
```ini
[Service]
NoNewPrivileges=true    # 阻止权限提升
```

---

## 5. 🛡️ 系统调用过滤


### 5.1 SystemCallFilter概述


**什么是系统调用**：程序与操作系统内核交互的接口，比如文件操作、网络通信等。

**过滤器工作原理**：
```
程序想要：删除文件 (unlink系统调用)
         ↓
SystemCallFilter检查：这个调用在允许列表中吗？
         ↓
允许：正常执行  拒绝：直接阻止并记录日志
```

### 5.2 系统调用过滤配置


**基本语法**：
```ini
[Service]
# 白名单模式：只允许指定的系统调用
SystemCallFilter=@basic-io @file-system @network-io

# 黑名单模式：禁止危险的系统调用
SystemCallFilter=~@mount @swap @reboot
```

**常用系统调用组**：
```
📊 系统调用分类：
@basic-io       → 基本输入输出 (read, write)
@file-system    → 文件系统操作 (open, close, stat)
@network-io     → 网络通信 (socket, bind, listen)
@process        → 进程管理 (fork, exec, wait)
@mount          → 挂载文件系统 (mount, umount)
@reboot         → 系统重启 (reboot, shutdown)
@swap           → 内存交换 (swapon, swapoff)
```

**Web服务配置示例**：
```ini
[Service]
# Web服务通常只需要这些系统调用
SystemCallFilter=@basic-io @file-system @network-io @signal @ipc
SystemCallFilter=~@mount @swap @reboot @raw-io
```

### 5.3 系统调用调试


**测试配置**：
```bash
# 查看服务被阻止的系统调用
journalctl -u myapp.service | grep "Operation not permitted"

# 临时放宽限制进行调试
systemctl edit myapp.service
# 添加：
[Service]
SystemCallFilter=
```

---

## 6. 📁 文件系统隔离


### 6.1 文件系统隔离机制


**核心概念**：限制服务只能访问必要的文件和目录，其他地方都"看不见"。

**隔离效果演示**：
```
正常视图：                隔离后视图：
/                        /
├── bin/                 ├── bin/           (只读)
├── etc/                 ├── etc/myapp/     (部分只读)
├── home/                ├── opt/myapp/     (读写)
├── opt/                 └── tmp/           (私有临时)
├── tmp/
├── usr/
└── var/
```

### 6.2 目录访问控制


**ReadOnlyPaths只读路径**：
```ini
[Service]
# 系统目录设为只读
ReadOnlyPaths=/bin /sbin /usr /lib /lib64
```

**InaccessiblePaths禁止访问**：
```ini
[Service]
# 完全禁止访问这些目录
InaccessiblePaths=/home /root /boot /etc/ssh
```

**ReadWritePaths读写权限**：
```ini
[Service]
# 明确允许读写的目录
ReadWritePaths=/var/log/myapp /var/lib/myapp /tmp
```

### 6.3 根目录隔离


**RootDirectory根目录重定向**：
```ini
[Service]
RootDirectory=/opt/myapp/chroot
# 服务看到的"/"实际上是/opt/myapp/chroot

# 需要预先准备chroot环境
ExecStartPre=/bin/mkdir -p /opt/myapp/chroot/{bin,lib,etc}
ExecStartPre=/bin/cp /bin/sh /opt/myapp/chroot/bin/
```

**PrivateDevices设备隔离**：
```ini
[Service]
PrivateDevices=true    # 隐藏不必要的设备文件
# 服务将看不到/dev下的大部分设备
```

---

## 7. 🌐 网络隔离配置


### 7.1 网络隔离基本概念


**网络隔离目的**：
- 防止服务访问不需要的网络资源
- 限制服务监听的端口范围  
- 阻止恶意网络连接

### 7.2 网络访问限制


**PrivateNetwork网络隔离**：
```ini
[Service]
PrivateNetwork=true    # 服务拥有独立的网络命名空间
# 只能看到loopback接口，无法访问外网
```

**RestrictAddressFamilies地址族限制**：
```ini
[Service]
# 只允许IPv4和IPv6
RestrictAddressFamilies=AF_INET AF_INET6

# 常见地址族：
# AF_INET    → IPv4网络
# AF_INET6   → IPv6网络  
# AF_UNIX    → Unix域套接字
# AF_NETLINK → 内核通信
```

### 7.3 端口访问控制


**使用iptables配合限制**：
```bash
# 只允许特定端口
iptables -A OUTPUT -m owner --uid-owner myapp -p tcp --dport 80 -j ACCEPT
iptables -A OUTPUT -m owner --uid-owner myapp -p tcp --dport 443 -j ACCEPT
iptables -A OUTPUT -m owner --uid-owner myapp -j DROP
```

**IPAddressAllow/Deny配置**：
```ini
[Service]
# 只允许访问特定IP段
IPAddressAllow=127.0.0.1/8 192.168.1.0/24
IPAddressDeny=any
```

---

## 8. 📋 安全策略模板


### 8.1 Web服务安全模板


```ini
# /etc/systemd/system/webapp.service
[Unit]
Description=Secure Web Application
After=network.target

[Service]
Type=simple
User=webapp
Group=webapp
ExecStart=/opt/webapp/bin/webapp

# 🛡️ 权限控制
NoNewPrivileges=true
PrivateTmp=true
PrivateDevices=true

# 🔒 文件系统隔离
ReadOnlyPaths=/bin /sbin /usr /lib /lib64 /etc
InaccessiblePaths=/home /root /boot
ReadWritePaths=/var/log/webapp /var/lib/webapp

# 🌐 网络限制  
RestrictAddressFamilies=AF_INET AF_INET6
IPAddressAllow=localhost 192.168.1.0/24

# ⚙️ 系统调用过滤
SystemCallFilter=@basic-io @file-system @network-io @signal
SystemCallFilter=~@mount @swap @reboot @raw-io

# 🔄 运行控制
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

### 8.2 数据库服务安全模板


```ini
# /etc/systemd/system/database.service
[Unit]
Description=Secure Database Service
After=network.target

[Service]
Type=notify
User=database
Group=database
ExecStart=/opt/database/bin/database --config=/etc/database/db.conf

# 🛡️ 高级安全设置
NoNewPrivileges=true
PrivateTmp=true
PrivateDevices=true
ProtectSystem=strict
ProtectHome=true

# 📁 严格文件权限
ReadOnlyPaths=/
ReadWritePaths=/var/lib/database /var/log/database /run/database

# 🚫 网络限制（仅本地连接）
RestrictAddressFamilies=AF_UNIX AF_INET
IPAddressAllow=127.0.0.1/8

# ⚙️ 最小系统调用集
SystemCallFilter=@basic-io @file-system @ipc @signal
SystemCallErrorNumber=EPERM

# 📊 资源限制
LimitNOFILE=8192
LimitNPROC=64

[Install]
WantedBy=multi-user.target
```

### 8.3 通用安全检查清单


**🔍 部署前检查**：
```bash
#!/bin/bash
# 服务安全检查脚本

SERVICE_NAME="myapp"

echo "=== 服务安全检查 ==="

# 1. 检查运行用户
echo "1. 检查运行用户："
systemctl show $SERVICE_NAME.service -p User
systemctl show $SERVICE_NAME.service -p Group

# 2. 检查权限设置
echo "2. 检查权限设置："
systemctl show $SERVICE_NAME.service -p NoNewPrivileges
systemctl show $SERVICE_NAME.service -p PrivateTmp

# 3. 检查文件系统隔离
echo "3. 检查文件系统隔离："
systemctl show $SERVICE_NAME.service -p ReadOnlyPaths
systemctl show $SERVICE_NAME.service -p InaccessiblePaths

# 4. 检查网络限制
echo "4. 检查网络限制："
systemctl show $SERVICE_NAME.service -p RestrictAddressFamilies

# 5. 检查系统调用过滤
echo "5. 检查系统调用过滤："
systemctl show $SERVICE_NAME.service -p SystemCallFilter
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 最小权限原则：只给服务必需的最小权限
🔸 用户权限隔离：每个服务使用专用用户运行
🔸 系统调用过滤：限制服务能调用的系统功能
🔸 文件系统隔离：限制服务能访问的文件和目录
🔸 网络访问控制：限制服务的网络通信权限
```

### 9.2 关键配置理解要点


**🔹 权限设置的层次**：
```
系统级：User/Group → 进程以特定用户身份运行
调用级：SystemCallFilter → 限制能使用的系统功能
文件级：ReadOnlyPaths/InaccessiblePaths → 限制文件访问
网络级：RestrictAddressFamilies → 限制网络通信
```

**🔹 隔离机制的作用**：
```
PrivateTmp → 每个服务独立的临时目录
PrivateDevices → 隐藏不必要的设备文件  
NoNewPrivileges → 阻止权限提升
InaccessiblePaths → 完全隐藏敏感目录
```

**🔹 安全与功能的平衡**：
```
过度限制 → 服务无法正常工作
限制不足 → 存在安全风险
合理配置 → 既安全又可用
```

### 9.3 实际应用价值


**🎯 业务场景应用**：
- **Web应用**：防止代码注入攻击影响系统
- **数据库服务**：保护敏感数据不被非法访问  
- **API服务**：限制服务权限防止滥用
- **文件服务**：控制文件访问权限

**🔧 运维实践**：
- **服务部署**：按安全模板配置新服务
- **安全审计**：定期检查服务权限配置
- **问题排查**：通过日志分析权限问题
- **合规要求**：满足安全合规标准

**🚀 安全收益**：
```
降低攻击风险：限制攻击者能做的事情
减少影响范围：即使被攻击影响也很小  
提高系统稳定：防止服务异常影响整体
满足合规要求：符合安全标准和规范
```

**核心记忆口诀**：
- 最小权限要牢记，专用账号来运行
- 系统调用要过滤，文件访问需限制  
- 网络隔离保安全，临时目录要独立
- 配置模板多参考，安全检查不能缺