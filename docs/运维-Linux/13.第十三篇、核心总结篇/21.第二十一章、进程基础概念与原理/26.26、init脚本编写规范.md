---
title: 26、init脚本编写规范
---
## 📚 目录

1. [LSB脚本标准](#1-LSB脚本标准)
2. [脚本文件结构](#2-脚本文件结构)
3. [启动函数实现](#3-启动函数实现)
4. [停止函数实现](#4-停止函数实现)
5. [状态查询函数](#5-状态查询函数)
6. [PID文件管理](#6-PID文件管理)
7. [锁文件机制](#7-锁文件机制)
8. [脚本返回值规范](#8-脚本返回值规范)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📋 LSB脚本标准


### 1.1 什么是LSB标准


**LSB（Linux Standard Base）** 是Linux系统的标准化规范，就像是给所有Linux发行版制定的"统一规则"。

> **💡 核心理解**
> LSB脚本标准就是让所有的init脚本都按照同样的格式写，这样不管在哪个Linux系统上，脚本都能正常工作，就像所有的电器都用标准插头一样。

**为什么需要LSB标准？**
```
问题场景：
- CentOS的脚本在Ubuntu上不能用
- 不同系统的启动脚本格式不一样
- 服务依赖关系难以管理

LSB解决方案：
- 统一脚本格式
- 标准化函数接口
- 规范化依赖声明
```

### 1.2 LSB脚本头部信息


每个标准的init脚本都必须包含LSB头部信息，告诉系统这个脚本的基本情况：

```bash
#!/bin/bash
## BEGIN INIT INFO

# Provides:          myservice
# Required-Start:    $local_fs $network $remote_fs
# Required-Stop:     $local_fs $network $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: My custom service
# Description:       This is my custom service that does something useful
## END INIT INFO

```

**各字段含义：**

| 字段 | 含义 | 示例说明 |
|------|------|----------|
| **Provides** | 服务名称 | `myservice` - 这个脚本提供什么服务 |
| **Required-Start** | 启动依赖 | `$network` - 需要网络先启动 |
| **Required-Stop** | 停止依赖 | `$local_fs` - 需要文件系统最后停止 |
| **Default-Start** | 默认启动级别 | `2 3 4 5` - 在这些运行级别自动启动 |
| **Default-Stop** | 默认停止级别 | `0 1 6` - 在这些运行级别自动停止 |

> **🔍 深入思考**
> 运行级别就像汽车的档位：0是关机，1是单用户模式（维修模式），2-5是正常运行，6是重启

---

## 2. 🏗️ 脚本文件结构


### 2.1 标准脚本框架


一个完整的init脚本就像一栋房子，有固定的房间布局：

```
init脚本结构：
┌─────────────────────────┐
│    LSB头部信息          │ ← 脚本身份证
├─────────────────────────┤
│    变量定义区           │ ← 配置参数
├─────────────────────────┤
│    辅助函数区           │ ← 工具函数
├─────────────────────────┤
│    核心功能函数         │ ← start/stop/status
├─────────────────────────┤
│    主逻辑判断           │ ← case语句处理参数
└─────────────────────────┘
```

### 2.2 完整脚本模板


```bash
#!/bin/bash
## BEGIN INIT INFO

# Provides:          myapp
# Required-Start:    $local_fs $network
# Required-Stop:     $local_fs $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: My application service
## END INIT INFO


# 变量定义区
SERVICE_NAME="myapp"
USER="myapp"
DAEMON="/usr/local/bin/myapp"
PIDFILE="/var/run/$SERVICE_NAME.pid"
LOCKFILE="/var/lock/subsys/$SERVICE_NAME"

# 导入系统函数库
. /lib/lsb/init-functions

# 核心功能函数
start() {
    # 启动逻辑
}

stop() {
    # 停止逻辑
}

status() {
    # 状态查询逻辑
}

# 主程序逻辑
case "$1" in
    start)   start   ;;
    stop)    stop    ;;
    status)  status  ;;
    restart) stop; start ;;
    *)       echo "Usage: $0 {start|stop|status|restart}"
             exit 1
             ;;
esac
```

> **⚠️ 常见误区**
> 很多新手以为init脚本就是简单的启动命令，其实它需要处理很多细节：检查服务是否已运行、处理PID文件、设置合适的用户权限等。

---

## 3. 🚀 启动函数实现


### 3.1 启动函数的核心职责


启动函数就像汽车的启动按钮，需要做这些检查和操作：

```
启动前检查：
1. 服务是否已经在运行？
2. 程序文件是否存在？
3. 配置文件是否正确？
4. 用户权限是否足够？

启动操作：
1. 切换到合适的用户
2. 启动程序进程
3. 记录PID文件
4. 创建锁文件
5. 返回正确的状态码
```

### 3.2 标准启动函数实现


```bash
start() {
    echo -n "Starting $SERVICE_NAME: "
    
    # 检查服务是否已经运行
    if [ -f $PIDFILE ]; then
        PID=`cat $PIDFILE`
        if kill -0 $PID > /dev/null 2>&1; then
            echo "already running"
            return 1
        fi
    fi
    
    # 检查程序是否存在
    if [ ! -x $DAEMON ]; then
        echo "daemon not found"
        return 1
    fi
    
    # 启动服务
    su - $USER -c "$DAEMON" && echo_success || echo_failure
    RETVAL=$?
    
    # 记录PID和创建锁文件
    if [ $RETVAL -eq 0 ]; then
        echo $! > $PIDFILE
        touch $LOCKFILE
    fi
    
    echo
    return $RETVAL
}
```

**关键步骤解析：**

📌 **重复启动检查**
```bash
if kill -0 $PID > /dev/null 2>&1; then
```
这行代码的意思是：`kill -0` 不会真的杀掉进程，只是检查进程是否存在，就像敲门看有没有人在家。

📌 **用户权限切换**
```bash
su - $USER -c "$DAEMON"
```
以指定用户身份运行程序，避免用root权限运行普通服务（安全考虑）。

---

## 4. ⏹️ 停止函数实现


### 4.1 优雅停止的重要性


停止服务不是简单的"杀掉进程"，而是要让程序有机会保存数据、关闭连接：

> **💡 核心理解**
> 优雅停止就像礼貌地请客人离开，而不是直接把客人推出门。程序需要时间保存数据、关闭文件、断开网络连接。

**停止策略：**
```
第一步：SIGTERM信号（礼貌请求）
等待10-30秒...
第二步：SIGKILL信号（强制终止）
```

### 4.2 标准停止函数实现


```bash
stop() {
    echo -n "Shutting down $SERVICE_NAME: "
    
    # 检查PID文件是否存在
    if [ ! -f $PIDFILE ]; then
        echo "not running"
        return 1
    fi
    
    PID=`cat $PIDFILE`
    
    # 检查进程是否真的在运行
    if ! kill -0 $PID > /dev/null 2>&1; then
        echo "not running"
        rm -f $PIDFILE $LOCKFILE
        return 1
    fi
    
    # 优雅停止：先发送SIGTERM
    kill -TERM $PID
    
    # 等待进程结束，最多等待30秒
    for i in {1..30}; do
        if ! kill -0 $PID > /dev/null 2>&1; then
            break
        fi
        sleep 1
    done
    
    # 如果还没结束，强制杀掉
    if kill -0 $PID > /dev/null 2>&1; then
        kill -KILL $PID
        sleep 2
    fi
    
    # 清理文件
    rm -f $PIDFILE $LOCKFILE
    echo_success
    echo
    return 0
}
```

**停止过程时序图：**
```
脚本                     进程                     系统
  |                       |                        |
  |--[1] SIGTERM--------->|                        |
  |                       |--[2] 保存数据--------->|
  |                       |--[3] 关闭连接--------->|
  |--[4] 检查进程状态---->|                        |
  |                       |--[5] 正常退出--------->|
  |--[6] 清理PID文件----->|                        |
```

---

## 5. 📊 状态查询函数


### 5.1 状态查询的作用


状态查询就像医生给病人把脉，要能准确判断服务的健康状态：

**状态类型：**
- 🟢 **运行中**：进程存在且正常工作
- 🔴 **已停止**：进程不存在
- 🟡 **异常状态**：PID文件存在但进程不存在

### 5.2 状态查询实现


```bash
status() {
    if [ -f $PIDFILE ]; then
        PID=`cat $PIDFILE`
        if kill -0 $PID > /dev/null 2>&1; then
            echo "$SERVICE_NAME (pid $PID) is running..."
            return 0
        else
            echo "$SERVICE_NAME dead but pid file exists"
            return 1
        fi
    else
        echo "$SERVICE_NAME is stopped"
        return 3
    fi
}
```

**状态判断流程：**
```
开始
 ↓
PID文件存在？
 ├─ 是 → 进程存在？
 │       ├─ 是 → 运行中 (返回0)
 │       └─ 否 → 异常状态 (返回1)
 └─ 否 → 已停止 (返回3)
```

---

## 6. 📄 PID文件管理


### 6.1 PID文件的作用


PID文件就像服务的"身份证号码"，记录了服务进程的唯一标识：

> **💡 核心理解**
> PID文件就像停车牌，告诉别人"这个位置被占了"，同时记录了是谁占的（进程ID）。

**PID文件规范：**
```
存放位置：/var/run/服务名.pid
文件内容：进程ID号码
文件权限：644 (rw-r--r--)
文件所有者：运行服务的用户
```

### 6.2 PID文件操作


**创建PID文件：**
```bash
# 方法1：直接写入当前进程PID
echo $$ > $PIDFILE

# 方法2：启动后台进程并记录PID
$DAEMON &
echo $! > $PIDFILE
```

**读取和验证PID：**
```bash
# 安全读取PID文件
get_pid() {
    if [ -f $PIDFILE ]; then
        PID=`cat $PIDFILE`
        # 验证PID是否为数字
        if [[ $PID =~ ^[0-9]+$ ]]; then
            echo $PID
        else
            return 1
        fi
    else
        return 1
    fi
}
```

> **⚠️ 常见误区**
> 有些人以为PID文件可有可无，实际上它是服务管理的核心，没有它就无法准确判断服务状态，也无法正确停止服务。

---

## 7. 🔒 锁文件机制


### 7.1 锁文件的目的


锁文件就像门上的"请勿打扰"牌子，防止同一个服务被重复启动：

**锁文件作用：**
```
防止重复启动：同一时间只能有一个服务实例
启动状态标记：系统知道哪些服务应该在运行
依赖关系检查：其他服务可以检查依赖是否满足
```

### 7.2 锁文件规范


**标准位置和命名：**
```bash
# 锁文件位置
LOCKFILE="/var/lock/subsys/$SERVICE_NAME"

# RedHat/CentOS系列
LOCKDIR="/var/lock/subsys"

# Debian/Ubuntu系列  
LOCKDIR="/var/lock"
```

**锁文件操作：**
```bash
# 创建锁文件
create_lock() {
    touch $LOCKFILE
    return $?
}

# 删除锁文件
remove_lock() {
    rm -f $LOCKFILE
    return $?
}

# 检查锁文件
check_lock() {
    [ -f $LOCKFILE ]
}
```

### 7.3 锁文件与PID文件的区别


| 文件类型 | 作用 | 内容 | 使用场景 |
|----------|------|------|----------|
| **PID文件** | 记录进程ID | 进程号码 | 进程管理、状态检查 |
| **锁文件** | 标记服务状态 | 空文件 | 系统级服务管理 |

---

## 8. 📊 脚本返回值规范


### 8.1 LSB标准返回码


init脚本的返回值就像考试成绩，告诉系统操作是否成功：

**标准返回码：**

| 返回值 | 含义 | 使用场景 |
|--------|------|----------|
| **0** | 成功 | 操作完成，一切正常 |
| **1** | 通用错误 | 未知错误或操作失败 |
| **2** | 无效参数 | 命令参数错误 |
| **3** | 未实现功能 | 不支持的操作 |
| **4** | 权限不足 | 没有执行权限 |
| **5** | 程序不存在 | 找不到要执行的程序 |
| **6** | 程序未配置 | 缺少配置文件 |
| **7** | 程序未运行 | 服务没有启动 |

### 8.2 返回值最佳实践


```bash
# 在每个函数中正确设置返回值
start() {
    # ... 启动逻辑 ...
    if [ $? -eq 0 ]; then
        return 0  # 成功
    else
        return 1  # 失败
    fi
}

# 主程序中传递返回值
case "$1" in
    start)
        start
        exit $?  # 将函数返回值传递给shell
        ;;
    stop)
        stop  
        exit $?
        ;;
esac
```

> **🔍 深入思考**
> 正确的返回值不仅让脚本更专业，还能与其他系统工具（如监控系统、自动化工具）正确集成。

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 LSB标准：统一的脚本格式规范，保证跨平台兼容性
🔸 脚本结构：头部信息 + 变量定义 + 函数实现 + 主逻辑
🔸 三大核心函数：start(启动) + stop(停止) + status(状态查询)
🔸 文件管理：PID文件记录进程ID，锁文件防止重复启动
🔸 返回值规范：标准返回码让系统正确理解脚本执行结果
```

### 9.2 关键理解要点


> **💡 核心理解**
> init脚本不是简单的启动命令，而是一个完整的服务管理系统，需要处理启动、停止、状态查询、异常情况等各种场景。

**🔹 优雅停止的重要性**
```
为什么不能直接kill -9？
- 程序来不及保存数据
- 网络连接没有正常关闭
- 临时文件没有清理
- 可能导致数据损坏

正确做法：
SIGTERM → 等待 → SIGKILL（最后手段）
```

**🔹 文件管理的作用**
```
PID文件：进程身份证
- 记录进程ID
- 用于状态检查
- 用于进程终止

锁文件：服务状态标记  
- 防止重复启动
- 系统依赖检查
- 启动状态标识
```

### 9.3 实际应用价值


**🎯 应用场景**
- **自定义服务管理**：为自己开发的程序编写标准启动脚本
- **系统集成**：让自定义服务与系统服务管理无缝集成
- **运维自动化**：标准化的脚本便于批量管理
- **故障排查**：标准的返回值和日志便于问题定位

**🔧 最佳实践**
- 遵循LSB标准确保兼容性
- 实现完整的错误处理机制
- 提供详细的状态信息
- 使用合适的用户权限运行服务

**💪 进阶学习路径**
```
当前掌握：SysV init脚本编写
    ↓
下一步学习：systemd服务单元
    ↓  
深入理解：现代服务管理对比
    ↓
实践应用：容器化服务管理
```

**核心记忆口诀**：
> LSB标准做规范，头部信息要写全  
> 启停状态三函数，PID锁文件管周全  
> 优雅停止保数据，返回码要按标准  
> 脚本虽小功能大，服务管理靠它编