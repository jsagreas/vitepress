---
title: 29、服务监控与告警
---
## 📚 目录

1. [服务监控基础概念](#1-服务监控基础概念)
2. [服务状态监控实现](#2-服务状态监控实现)
3. [健康检查机制](#3-健康检查机制)
4. [自动重启策略](#4-自动重启策略)
5. [故障通知与告警](#5-故障通知与告警)
6. [监控脚本编写](#6-监控脚本编写)
7. [性能指标与统计](#7-性能指标与统计)
8. [告警阈值设置](#8-告警阈值设置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 服务监控基础概念


### 1.1 什么是服务监控


**服务监控**简单来说，就是**时刻盯着你的服务有没有正常工作**。就像医生定期给病人量血压、测心跳一样，我们需要定期检查服务的"生命体征"。

```
生活中的类比：
家里的电器 → Linux服务
定期检查电器是否正常 → 服务监控
电器坏了及时维修 → 自动重启/告警
```

**为什么需要监控？**
- 🔸 **及时发现问题**：服务挂了能第一时间知道
- 🔸 **预防故障**：发现异常苗头，提前处理
- 🔸 **保证可用性**：确保服务24小时正常运行
- 🔸 **性能优化**：通过数据分析找出瓶颈

### 1.2 监控的层次结构


```
监控金字塔：
┌─────────────────────┐
│     业务监控        │ ← 用户体验、业务指标
├─────────────────────┤
│     应用监控        │ ← 服务响应时间、错误率
├─────────────────────┤
│     系统监控        │ ← CPU、内存、磁盘使用率
├─────────────────────┤
│     基础设施监控     │ ← 网络、硬件状态
└─────────────────────┘
```

**监控对象分类**：
- **📊 系统资源**：CPU、内存、磁盘、网络
- **🔧 服务进程**：进程状态、端口监听、响应时间
- **📈 业务指标**：用户访问量、交易成功率、数据处理量
- **⚠️ 错误事件**：异常日志、错误代码、崩溃信息

### 1.3 监控的基本流程


```
监控流程图：
数据采集 → 数据存储 → 数据分析 → 告警判断 → 通知处理 → 问题修复

具体步骤：
[1] 收集监控指标（CPU使用率、进程状态等）
[2] 存储历史数据（便于趋势分析）
[3] 分析数据模式（发现异常）
[4] 触发告警规则（超过阈值）
[5] 发送通知信息（邮件、短信、钉钉）
[6] 执行修复动作（重启服务、清理资源）
```

---

## 2. 🔍 服务状态监控实现


### 2.1 systemctl状态监控


**systemctl**是检查systemd服务最直接的方法，就像用体温计测量体温一样简单直接。

**基本状态查看**：
```bash
# 查看服务当前状态
systemctl status nginx
systemctl status mysql
systemctl status sshd

# 只看服务是否运行（简洁输出）
systemctl is-active nginx     # 输出：active 或 inactive
systemctl is-enabled nginx    # 输出：enabled 或 disabled
systemctl is-failed nginx     # 输出：active 或 failed
```

**状态含义详解**：
- **✅ active (running)**：服务正在运行，一切正常
- **🔴 inactive (dead)**：服务已停止，需要启动
- **⚠️ active (exited)**：一次性任务已完成
- **❌ failed**：服务启动失败，需要检查
- **🟡 activating**：服务正在启动中

### 2.2 批量服务状态检查


当你管理多个服务时，一个个检查太麻烦。我们可以用脚本批量检查：

```bash
#!/bin/bash
# 批量检查服务状态
services=("nginx" "mysql" "redis" "sshd")

echo "=== 服务状态检查报告 ==="
for service in "${services[@]}"; do
    status=$(systemctl is-active $service)
    if [ "$status" = "active" ]; then
        echo "✅ $service: 运行正常"
    else
        echo "❌ $service: 状态异常 ($status)"
    fi
done
```

### 2.3 进程级别监控


有些程序不是systemd服务，我们需要直接监控进程：

```bash
# 检查进程是否存在
pgrep nginx > /dev/null && echo "nginx运行中" || echo "nginx未运行"

# 查看进程详细信息
ps aux | grep nginx | grep -v grep

# 监控进程数量（某些服务会有多个进程）
nginx_count=$(pgrep nginx | wc -l)
echo "nginx进程数量: $nginx_count"
```

**进程监控要点**：
- 🔸 **进程存在性**：进程是否还在运行
- 🔸 **进程数量**：是否有异常的进程数量变化
- 🔸 **CPU使用率**：进程是否消耗过多CPU
- 🔸 **内存使用**：进程内存占用是否正常

---

## 3. 🏥 健康检查机制


### 3.1 什么是健康检查


**健康检查**就是定期"问候"你的服务："你还好吗？能正常工作吗？"不仅要看服务进程在不在，还要看它能不能正常响应请求。

```
类比理解：
医生体检 → 健康检查
- 量体温血压 → 检查进程状态
- 验血化验 → 检查服务响应
- 心电图检查 → 检查功能是否正常
```

### 3.2 端口监听检查


**端口检查**是最基础的健康检查，看服务是否在监听指定端口：

```bash
# 检查端口是否在监听
netstat -tlnp | grep :80    # 检查80端口
ss -tlnp | grep :3306       # 检查MySQL端口

# 使用nc命令测试端口连通性
nc -zv localhost 80         # 测试本地80端口
nc -zv 192.168.1.100 22    # 测试远程SSH端口
```

**端口检查脚本**：
```bash
#!/bin/bash
check_port() {
    local host=$1
    local port=$2
    local service_name=$3
    
    if nc -zv $host $port >/dev/null 2>&1; then
        echo "✅ $service_name ($host:$port) 端口正常"
        return 0
    else
        echo "❌ $service_name ($host:$port) 端口异常"
        return 1
    fi
}

# 检查常用服务端口
check_port localhost 80 "Nginx"
check_port localhost 3306 "MySQL"
check_port localhost 22 "SSH"
```

### 3.3 HTTP健康检查


对于Web服务，我们需要检查HTTP响应是否正常：

```bash
# 使用curl检查HTTP状态
curl -I http://localhost/health 2>/dev/null | head -n1

# 检查响应码是否为200
http_code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/)
if [ "$http_code" = "200" ]; then
    echo "✅ Web服务响应正常"
else
    echo "❌ Web服务响应异常，状态码: $http_code"
fi
```

**深度健康检查**：
```bash
#!/bin/bash
web_health_check() {
    local url=$1
    local timeout=10
    
    # 检查响应时间和状态码
    response=$(curl -s -w "%{http_code},%{time_total}" -m $timeout $url -o /dev/null)
    http_code=$(echo $response | cut -d',' -f1)
    response_time=$(echo $response | cut -d',' -f2)
    
    if [ "$http_code" = "200" ]; then
        echo "✅ $url 健康检查通过 (响应时间: ${response_time}s)"
    else
        echo "❌ $url 健康检查失败 (状态码: $http_code)"
    fi
}

web_health_check "http://localhost"
web_health_check "http://localhost/api/status"
```

### 3.4 数据库连接检查


数据库服务的健康检查需要测试实际连接：

```bash
# MySQL连接检查
mysql_check() {
    mysql -u监控用户 -p密码 -e "SELECT 1;" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "✅ MySQL连接正常"
    else
        echo "❌ MySQL连接失败"
    fi
}

# Redis连接检查
redis_check() {
    redis-cli ping >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "✅ Redis连接正常"
    else
        echo "❌ Redis连接失败"
    fi
}
```

---

## 4. 🔄 自动重启策略


### 4.1 systemd自动重启配置


**systemd**提供了内置的自动重启功能，就像给服务配备了"自愈能力"：

**基本重启配置**：
```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My Application
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/myapp
User=appuser
Group=appuser

# 自动重启配置
Restart=always                    # 总是重启
RestartSec=10                     # 重启间隔10秒
StartLimitBurst=5                 # 10秒内最多重启5次
StartLimitIntervalSec=600         # 10分钟内限制重启次数

[Install]
WantedBy=multi-user.target
```

**重启策略详解**：
- **`always`**：无论什么原因退出都重启（推荐）
- **`on-failure`**：只有非正常退出才重启
- **`on-success`**：只有正常退出才重启
- **`no`**：从不自动重启

### 4.2 定时检查重启脚本


有时我们需要更复杂的重启逻辑，可以用脚本实现：

```bash
#!/bin/bash
# 服务监控和自动重启脚本
SERVICE_NAME="nginx"
MAX_RESTART_COUNT=3
RESTART_COUNT_FILE="/tmp/${SERVICE_NAME}_restart_count"

# 获取重启次数
get_restart_count() {
    if [ -f "$RESTART_COUNT_FILE" ]; then
        cat "$RESTART_COUNT_FILE"
    else
        echo 0
    fi
}

# 增加重启次数
increase_restart_count() {
    local count=$(get_restart_count)
    echo $((count + 1)) > "$RESTART_COUNT_FILE"
}

# 重置重启次数
reset_restart_count() {
    echo 0 > "$RESTART_COUNT_FILE"
}

# 检查服务状态并重启
check_and_restart() {
    if ! systemctl is-active --quiet "$SERVICE_NAME"; then
        local restart_count=$(get_restart_count)
        
        if [ $restart_count -lt $MAX_RESTART_COUNT ]; then
            echo "$(date): $SERVICE_NAME 服务异常，正在重启..."
            systemctl restart "$SERVICE_NAME"
            increase_restart_count
            
            # 等待服务启动
            sleep 5
            if systemctl is-active --quiet "$SERVICE_NAME"; then
                echo "$(date): $SERVICE_NAME 重启成功"
                reset_restart_count
            else
                echo "$(date): $SERVICE_NAME 重启失败"
            fi
        else
            echo "$(date): $SERVICE_NAME 重启次数过多，停止自动重启"
            # 可以在这里发送告警
        fi
    else
        # 服务正常，重置计数
        reset_restart_count
    fi
}

check_and_restart
```

### 4.3 基于资源使用的重启


有时服务会出现内存泄漏或CPU占用过高，需要基于资源使用情况重启：

```bash
#!/bin/bash
# 基于资源使用的服务重启
SERVICE_NAME="myapp"
MEMORY_THRESHOLD=80  # 内存使用阈值（%）
CPU_THRESHOLD=90     # CPU使用阈值（%）

# 获取进程资源使用情况
get_process_stats() {
    local service_name=$1
    # 获取主进程PID
    local pid=$(systemctl show --property MainPID --value $service_name)
    
    if [ "$pid" != "0" ] && [ -d "/proc/$pid" ]; then
        # 获取CPU和内存使用率
        local stats=$(ps -p $pid -o %cpu,%mem --no-headers)
        echo "$stats"
    else
        echo "0 0"
    fi
}

# 检查资源使用并决定是否重启
check_resource_usage() {
    local stats=$(get_process_stats $SERVICE_NAME)
    local cpu=$(echo $stats | cut -d' ' -f1 | cut -d'.' -f1)
    local memory=$(echo $stats | cut -d' ' -f2 | cut -d'.' -f1)
    
    echo "$(date): $SERVICE_NAME CPU使用: ${cpu}%, 内存使用: ${memory}%"
    
    if [ "$memory" -gt "$MEMORY_THRESHOLD" ] || [ "$cpu" -gt "$CPU_THRESHOLD" ]; then
        echo "$(date): $SERVICE_NAME 资源使用过高，执行重启"
        systemctl restart $SERVICE_NAME
        return 1
    fi
    
    return 0
}

check_resource_usage
```

---

## 5. 📢 故障通知与告警


### 5.1 告警的重要性


**告警系统**就像火灾报警器，当出现问题时能够立即通知相关人员。一个好的告警系统应该做到：

- 🔸 **及时性**：问题发生后立即通知
- 🔸 **准确性**：避免误报和漏报
- 🔸 **多样性**：支持多种通知方式
- 🔸 **分级性**：不同严重程度不同处理方式

```
告警级别分类：
🔴 P0-紧急: 服务完全不可用，立即处理
🟡 P1-重要: 服务部分功能异常，1小时内处理
🟢 P2-一般: 性能下降，24小时内处理
🔵 P3-提醒: 资源使用异常，定期处理
```

### 5.2 邮件告警实现


**邮件告警**是最常用的通知方式，可以发送详细的问题描述：

```bash
#!/bin/bash
# 邮件告警函数
send_email_alert() {
    local subject=$1
    local message=$2
    local recipient="admin@company.com"
    
    # 使用mail命令发送邮件
    echo "$message" | mail -s "$subject" $recipient
    
    # 或使用sendemail工具
    # sendemail -f monitor@company.com -t $recipient -s smtp.company.com -u "$subject" -m "$message"
}

# 服务故障告警示例
service_alert() {
    local service_name=$1
    local status=$2
    local hostname=$(hostname)
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    local subject="🚨 [$hostname] $service_name 服务异常"
    local message="
主机: $hostname
服务: $service_name
状态: $status
时间: $timestamp

请及时检查服务状态并处理。

详细信息:
$(systemctl status $service_name)
"
    
    send_email_alert "$subject" "$message"
}
```

### 5.3 钉钉/企业微信告警


**即时通讯告警**能够更快地触达相关人员：

```bash
#!/bin/bash
# 钉钉机器人告警
DINGTALK_WEBHOOK="https://oapi.dingtalk.com/robot/send?access_token=YOUR_TOKEN"

send_dingtalk_alert() {
    local message=$1
    local data='{
        "msgtype": "text",
        "text": {
            "content": "'$message'"
        },
        "at": {
            "atMobiles": ["13800000000"],
            "isAtAll": false
        }
    }'
    
    curl -X POST "$DINGTALK_WEBHOOK" \
         -H 'Content-Type: application/json' \
         -d "$data"
}

# 服务异常通知
notify_service_down() {
    local service_name=$1
    local hostname=$(hostname)
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    local message="🚨 服务告警
主机: $hostname  
服务: $service_name
状态: 服务异常
时间: $timestamp
请及时处理！"
    
    send_dingtalk_alert "$message"
}
```

### 5.4 告警抑制和升级


为了避免告警风暴，我们需要实现告警抑制机制：

```bash
#!/bin/bash
# 告警抑制管理
ALERT_STATE_DIR="/tmp/alerts"
mkdir -p "$ALERT_STATE_DIR"

# 检查是否需要发送告警
should_send_alert() {
    local alert_key=$1
    local alert_interval=$2  # 告警间隔（秒）
    local alert_file="$ALERT_STATE_DIR/$alert_key"
    
    if [ -f "$alert_file" ]; then
        local last_alert=$(cat "$alert_file")
        local current_time=$(date +%s)
        local time_diff=$((current_time - last_alert))
        
        if [ $time_diff -lt $alert_interval ]; then
            return 1  # 不需要发送告警
        fi
    fi
    
    # 记录告警时间
    date +%s > "$alert_file"
    return 0  # 需要发送告警
}

# 带抑制的告警函数
alert_with_suppression() {
    local service_name=$1
    local alert_message=$2
    local alert_key="service_${service_name}_down"
    local alert_interval=1800  # 30分钟内不重复告警
    
    if should_send_alert "$alert_key" "$alert_interval"; then
        send_dingtalk_alert "$alert_message"
        echo "$(date): 发送告警 - $service_name"
    else
        echo "$(date): 告警抑制中 - $service_name"
    fi
}
```

---

## 6. 📝 监控脚本编写


### 6.1 综合监控脚本框架


一个完整的监控脚本应该包含多个检查项，并能生成详细的报告：

```bash
#!/bin/bash
# 综合服务监控脚本
SCRIPT_NAME="service_monitor"
LOG_FILE="/var/log/${SCRIPT_NAME}.log"
CONFIG_FILE="/etc/${SCRIPT_NAME}.conf"

# 日志记录函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# 配置文件格式示例
init_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" << EOF
# 服务监控配置文件
SERVICES="nginx mysql redis sshd"
CHECK_INTERVAL=60
ALERT_EMAIL="admin@company.com"
DINGTALK_WEBHOOK="https://oapi.dingtalk.com/robot/send?access_token=YOUR_TOKEN"
ENABLE_AUTO_RESTART=true
MAX_RESTART_ATTEMPTS=3
EOF
        log_message "INFO" "配置文件已创建: $CONFIG_FILE"
    fi
}

# 加载配置
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        log_message "INFO" "配置文件加载完成"
    else
        log_message "ERROR" "配置文件不存在: $CONFIG_FILE"
        exit 1
    fi
}
```

### 6.2 模块化检查函数


将不同的检查项封装成独立的函数，便于维护和扩展：

```bash
# 系统资源检查
check_system_resources() {
    log_message "INFO" "开始系统资源检查"
    
    # CPU使用率检查
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    if (( $(echo "$cpu_usage > 80" | bc -l) )); then
        log_message "WARN" "CPU使用率过高: ${cpu_usage}%"
    fi
    
    # 内存使用率检查
    local mem_info=$(free | grep Mem)
    local mem_total=$(echo $mem_info | awk '{print $2}')
    local mem_used=$(echo $mem_info | awk '{print $3}')
    local mem_usage=$((mem_used * 100 / mem_total))
    
    if [ $mem_usage -gt 85 ]; then
        log_message "WARN" "内存使用率过高: ${mem_usage}%"
    fi
    
    # 磁盘空间检查
    df -h | awk 'NR>1 {gsub("%","",$5); if($5>90) print $0}' | while read line; do
        log_message "WARN" "磁盘空间不足: $line"
    done
}

# 服务状态检查
check_services() {
    log_message "INFO" "开始服务状态检查"
    
    for service in $SERVICES; do
        if systemctl is-active --quiet "$service"; then
            log_message "INFO" "服务正常: $service"
        else
            log_message "ERROR" "服务异常: $service"
            
            if [ "$ENABLE_AUTO_RESTART" = "true" ]; then
                restart_service "$service"
            fi
        fi
    done
}

# 网络连接检查
check_network() {
    log_message "INFO" "开始网络连接检查"
    
    # 检查外网连通性
    if ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        log_message "INFO" "外网连接正常"
    else
        log_message "ERROR" "外网连接异常"
    fi
    
    # 检查DNS解析
    if nslookup google.com >/dev/null 2>&1; then
        log_message "INFO" "DNS解析正常"
    else
        log_message "ERROR" "DNS解析异常"
    fi
}
```

### 6.3 完整监控脚本示例


```bash
#!/bin/bash
# 主监控流程
main() {
    log_message "INFO" "=== 开始监控检查 ==="
    
    # 初始化和加载配置
    init_config
    load_config
    
    # 执行各项检查
    check_system_resources
    check_services  
    check_network
    
    # 生成监控报告
    generate_report
    
    log_message "INFO" "=== 监控检查完成 ==="
}

# 生成监控报告
generate_report() {
    local report_file="/tmp/monitor_report_$(date +%Y%m%d_%H%M%S).txt"
    {
        echo "=== 系统监控报告 ==="
        echo "生成时间: $(date)"
        echo "主机名称: $(hostname)"
        echo ""
        echo "=== 系统资源状态 ==="
        echo "CPU负载: $(uptime | awk -F'load average:' '{print $2}')"
        echo "内存使用: $(free -h | grep Mem)"
        echo "磁盘使用: "
        df -h | grep -E '^/dev/'
        echo ""
        echo "=== 服务状态 ==="
        for service in $SERVICES; do
            status=$(systemctl is-active $service)
            echo "$service: $status"
        done
    } > "$report_file"
    
    log_message "INFO" "监控报告已生成: $report_file"
}

# 设置定时执行
setup_cron() {
    local cron_entry="*/$CHECK_INTERVAL * * * * /path/to/service_monitor.sh"
    if ! crontab -l 2>/dev/null | grep -q "$SCRIPT_NAME"; then
        (crontab -l 2>/dev/null; echo "$cron_entry") | crontab -
        log_message "INFO" "定时任务已设置"
    fi
}

# 脚本入口
if [ "$1" = "setup" ]; then
    setup_cron
else
    main
fi
```

---

## 7. 📊 性能指标与统计


### 7.1 服务可用性统计


**服务可用性**是衡量服务质量的重要指标，通常用百分比表示。

**可用性计算公式**：
```
可用性 = (总时间 - 停机时间) / 总时间 × 100%

例如：
一个月 = 30天 = 720小时
停机时间 = 2小时
可用性 = (720 - 2) / 720 × 100% = 99.72%
```

**可用性等级标准**：
- **99.9%** (Three Nines)：每月停机约43分钟
- **99.99%** (Four Nines)：每月停机约4分钟
- **99.999%** (Five Nines)：每月停机约26秒

```bash
#!/bin/bash
# 服务可用性统计脚本
AVAILABILITY_LOG="/var/log/service_availability.log"

# 记录服务状态
record_service_status() {
    local service_name=$1
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local epoch_time=$(date +%s)
    
    if systemctl is-active --quiet "$service_name"; then
        echo "$epoch_time,$timestamp,$service_name,UP" >> "$AVAILABILITY_LOG"
    else
        echo "$epoch_time,$timestamp,$service_name,DOWN" >> "$AVAILABILITY_LOG"
    fi
}

# 计算可用性百分比
calculate_availability() {
    local service_name=$1
    local days_back=${2:-30}  # 默认统计30天
    local start_time=$(($(date +%s) - days_back * 86400))
    
    # 统计UP和DOWN状态的记录数
    local total_checks=$(awk -F',' -v start="$start_time" -v service="$service_name" \
        '$1 >= start && $3 == service {count++} END {print count}' "$AVAILABILITY_LOG")
    
    local up_checks=$(awk -F',' -v start="$start_time" -v service="$service_name" \
        '$1 >= start && $3 == service && $4 == "UP" {count++} END {print count}' "$AVAILABILITY_LOG")
    
    if [ "$total_checks" -gt 0 ]; then
        local availability=$(echo "scale=4; $up_checks / $total_checks * 100" | bc)
        echo "服务 $service_name 在过去${days_back}天的可用性: ${availability}%"
    else
        echo "服务 $service_name 没有足够的统计数据"
    fi
}
```

### 7.2 性能指标采集


除了可用性，我们还需要采集各种性能指标：

```bash
#!/bin/bash
# 性能指标采集脚本
METRICS_DIR="/var/log/metrics"
mkdir -p "$METRICS_DIR"

# 采集系统性能指标
collect_system_metrics() {
    local timestamp=$(date +%s)
    local date_str=$(date '+%Y-%m-%d %H:%M:%S')
    
    # CPU使用率
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    echo "$timestamp,$date_str,cpu_usage,$cpu_usage" >> "$METRICS_DIR/system.csv"
    
    # 内存使用情况
    local mem_total=$(free | grep Mem | awk '{print $2}')
    local mem_used=$(free | grep Mem | awk '{print $3}')
    local mem_usage_percent=$((mem_used * 100 / mem_total))
    echo "$timestamp,$date_str,memory_usage_percent,$mem_usage_percent" >> "$METRICS_DIR/system.csv"
    
    # 负载平均值
    local load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | tr -d ' ')
    echo "$timestamp,$date_str,load_average,$load_avg" >> "$METRICS_DIR/system.csv"
    
    # 磁盘IO统计
    local disk_io=$(iostat -d 1 1 | tail -n +4 | grep -E '^(sd|nvme)' | head -1 | awk '{print $4","$5}')
    if [ ! -z "$disk_io" ]; then
        echo "$timestamp,$date_str,disk_io,$disk_io" >> "$METRICS_DIR/system.csv"
    fi
}

# 采集服务响应时间
collect_response_time() {
    local service_url=$1
    local service_name=$2
    local timestamp=$(date +%s)
    local date_str=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 测量HTTP响应时间
    local response_time=$(curl -s -w "%{time_total}" -o /dev/null --max-time 30 "$service_url" 2>/dev/null)
    local http_code=$(curl -s -w "%{http_code}" -o /dev/null --max-time 30 "$service_url" 2>/dev/null)
    
    echo "$timestamp,$date_str,$service_name,response_time,$response_time" >> "$METRICS_DIR/services.csv"
    echo "$timestamp,$date_str,$service_name,http_code,$http_code" >> "$METRICS_DIR/services.csv"
}
```

### 7.3 性能趋势分析


收集到数据后，我们需要分析趋势来发现潜在问题：

```bash
#!/bin/bash
# 性能趋势分析脚本
analyze_performance_trend() {
    local metric_type=$1
    local days_back=${2:-7}
    local threshold=${3:-80}
    
    # 分析过去几天的性能指标
    local start_time=$(($(date +%s) - days_back * 86400))
    
    # 统计超过阈值的次数
    local violations=$(awk -F',' -v start="$start_time" -v metric="$metric_type" -v thresh="$threshold" \
        '$1 >= start && $3 == metric && $4 > thresh {count++} END {print count+0}' "$METRICS_DIR/system.csv")
    
    # 计算平均值
    local average=$(awk -F',' -v start="$start_time" -v metric="$metric_type" \
        '$1 >= start && $3 == metric {sum+=$4; count++} END {if(count>0) print sum/count; else print 0}' "$METRICS_DIR/system.csv")
    
    echo "=== $metric_type 性能分析（过去${days_back}天）==="
    echo "平均值: $(printf "%.2f" $average)"
    echo "超过阈值($threshold)次数: $violations"
    
    if [ "$violations" -gt $((days_back * 24)) ]; then  # 每天超过1次
        echo "⚠️  警告: $metric_type 经常超过阈值，建议优化"
    fi
}
```

---

## 8. ⚙️ 告警阈值设置


### 8.1 阈值设置原则


**告警阈值**就像体温计上的刻度，需要根据实际情况设置合适的"正常范围"。设置过低会导致误报，设置过高可能错过真正的问题。

**阈值设置考虑因素**：
- 🔸 **历史数据**：基于过去的性能表现
- 🔸 **业务需求**：不同业务对性能要求不同
- 🔸 **系统容量**：硬件配置和负载能力
- 🔸 **时间段**：白天和夜间的正常值可能不同

### 8.2 动态阈值配置


```bash
#!/bin/bash
# 动态阈值配置管理
THRESHOLD_CONFIG="/etc/monitor/thresholds.conf"

# 初始化阈值配置
init_thresholds() {
    mkdir -p "$(dirname $THRESHOLD_CONFIG)"
    cat > "$THRESHOLD_CONFIG" << EOF
# 监控阈值配置文件
# 格式: 指标名称|警告阈值|严重阈值|单位

# 系统资源阈值
cpu_usage|70|90|%
memory_usage|80|95|%
disk_usage|85|95|%
load_average|2.0|5.0|

# 网络阈值  
response_time|2.0|5.0|seconds
packet_loss|5|15|%

# 服务阈值
service_restart_count|3|5|次/小时
error_rate|5|10|%
EOF
}

# 读取阈值配置
get_threshold() {
    local metric_name=$1
    local threshold_type=$2  # warning 或 critical
    
    if [ ! -f "$THRESHOLD_CONFIG" ]; then
        init_thresholds
    fi
    
    local line=$(grep "^$metric_name|" "$THRESHOLD_CONFIG")
    if [ ! -z "$line" ]; then
        if [ "$threshold_type" = "warning" ]; then
            echo "$line" | cut -d'|' -f2
        elif [ "$threshold_type" = "critical" ]; then
            echo "$line" | cut -d'|' -f3
        fi
    fi
}

# 检查阈值并返回告警级别
check_threshold() {
    local metric_name=$1
    local current_value=$2
    
    local warning_threshold=$(get_threshold "$metric_name" "warning")
    local critical_threshold=$(get_threshold "$metric_name" "critical")
    
    if (( $(echo "$current_value >= $critical_threshold" | bc -l) )); then
        echo "CRITICAL"
    elif (( $(echo "$current_value >= $warning_threshold" | bc -l) )); then
        echo "WARNING"  
    else
        echo "OK"
    fi
}
```

### 8.3 智能阈值调整


基于历史数据自动调整阈值，避免人工维护的繁琐：

```bash
#!/bin/bash
# 智能阈值调整
calculate_adaptive_threshold() {
    local metric_name=$1
    local days_back=${2:-30}
    local percentile=${3:-95}  # 95百分位数作为阈值
    
    # 获取历史数据
    local start_time=$(($(date +%s) - days_back * 86400))
    local temp_file="/tmp/metric_values.txt"
    
    awk -F',' -v start="$start_time" -v metric="$metric_name" \
        '$1 >= start && $3 == metric {print $4}' "$METRICS_DIR/system.csv" > "$temp_file"
    
    # 计算百分位数
    if [ -s "$temp_file" ]; then
        local threshold=$(sort -n "$temp_file" | awk -v p="$percentile" \
            'BEGIN{c=0} {a[c++]=$1} END{print a[int(c*p/100-0.5)]}')
        
        echo "建议 $metric_name 告警阈值: $threshold (基于${days_back}天${percentile}%分位数)"
        
        # 自动更新配置文件
        update_threshold_config "$metric_name" "$threshold"
    else
        echo "没有足够的历史数据用于计算 $metric_name 的阈值"
    fi
    
    rm -f "$temp_file"
}

# 更新阈值配置
update_threshold_config() {
    local metric_name=$1
    local new_threshold=$2
    
    # 备份原配置
    cp "$THRESHOLD_CONFIG" "${THRESHOLD_CONFIG}.backup"
    
    # 更新配置
    if grep -q "^$metric_name|" "$THRESHOLD_CONFIG"; then
        # 更新existing entry
        sed -i "s/^$metric_name|.*/$metric_name|$new_threshold|$(echo "$new_threshold * 1.2" | bc)|/" "$THRESHOLD_CONFIG"
    else
        # 添加新条目
        echo "$metric_name|$new_threshold|$(echo "$new_threshold * 1.2" | bc)|" >> "$THRESHOLD_CONFIG"
    fi
    
    echo "已更新 $metric_name 阈值配置"
}
```

### 8.4 告警规则引擎


实现更复杂的告警逻辑，支持多条件组合：

```bash
#!/bin/bash
# 告警规则引擎
RULES_CONFIG="/etc/monitor/alert_rules.conf"

# 初始化告警规则
init_alert_rules() {
    cat > "$RULES_CONFIG" << EOF
# 告警规则配置
# 格式: 规则名称|条件表达式|持续时间|告警级别|消息模板

# 简单规则
high_cpu|cpu_usage > 80|300|WARNING|CPU使用率过高: {value}%
critical_cpu|cpu_usage > 95|60|CRITICAL|CPU使用率严重过高: {value}%

# 组合规则  
high_load|load_average > 3.0 AND cpu_usage > 70|600|WARNING|系统负载高且CPU使用率高
disk_full|disk_usage > 90|0|CRITICAL|磁盘空间不足: {value}%

# 服务规则
service_down|service_status == 'inactive'|0|CRITICAL|服务 {service} 已停止
slow_response|response_time > 5.0|180|WARNING|服务响应缓慢: {value}秒
EOF
}

# 评估告警规则
evaluate_alert_rules() {
    local current_metrics="$1"  # JSON格式的当前指标
    
    while IFS='|' read -r rule_name condition duration level message_template; do
        if [[ $rule_name =~ ^[[:space:]]*# ]] || [ -z "$rule_name" ]; then
            continue  # 跳过注释和空行
        fi
        
        # 解析并评估条件
        if evaluate_condition "$condition" "$current_metrics"; then
            # 检查持续时间
            if check_duration "$rule_name" "$duration"; then
                # 生成告警消息
                local alert_message=$(generate_alert_message "$message_template" "$current_metrics")
                send_alert "$level" "$rule_name" "$alert_message"
            fi
        else
            # 条件不满足，清除持续时间记录
            clear_duration_record "$rule_name"
        fi
    done < "$RULES_CONFIG"
}

# 条件评估函数
evaluate_condition() {
    local condition=$1
    local metrics=$2
    
    # 简化的条件评估（实际实现会更复杂）
    # 这里仅作示例
    case "$condition" in
        *"cpu_usage > 80"*)
            local cpu_value=$(echo "$metrics" | jq -r '.cpu_usage // 0')
            (( $(echo "$cpu_value > 80" | bc -l) ))
            ;;
        *"service_status == 'inactive'"*)
            local status=$(echo "$metrics" | jq -r '.service_status // "active"')
            [ "$status" = "inactive" ]
            ;;
        *)
            return 1
            ;;
    esac
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 服务监控：定期检查服务状态，确保正常运行
🔸 健康检查：不仅看进程存在，还要测试功能正常
🔸 自动重启：服务异常时自动恢复，减少人工干预
🔸 告警通知：问题发生时及时通知相关人员
🔸 性能指标：收集和分析服务性能数据
🔸 阈值设置：合理设置告警临界值，避免误报漏报
```

### 9.2 关键理解要点


**🔹 监控的层次性**
```
监控要全面：
- 系统资源监控（CPU、内存、磁盘）
- 服务进程监控（进程状态、端口监听）
- 应用功能监控（HTTP响应、数据库连接）
- 业务指标监控（用户访问、交易成功率）
```

**🔹 告警的平衡性**
```
告警设置原则：
- 重要问题不能漏：关键服务异常必须告警
- 误报要尽量少：避免"狼来了"效应
- 响应要及时：告警发出后要快速处理
- 升级要合理：问题严重程度不同处理方式不同
```

**🔹 自动化的重要性**
```
为什么要自动化：
- 人工监控不现实：24小时盯着屏幕不现实
- 反应速度要求高：凌晨3点的故障也要立即处理
- 减少人为错误：自动化脚本比手工操作更可靠
- 提高运维效率：让运维人员专注于更重要的工作
```

### 9.3 实际应用指导


**🎯 监控系统搭建步骤**
1. **确定监控范围**：哪些服务需要监控
2. **选择监控工具**：命令行工具还是专业监控系统
3. **设置检查频率**：多久检查一次
4. **配置告警方式**：邮件、短信、即时消息
5. **测试告警流程**：确保告警能正常发送和接收

**🔧 最佳实践建议**
- **分层监控**：从基础设施到应用层全覆盖
- **合理频率**：重要服务1分钟检查，一般服务5分钟
- **告警分级**：不同严重程度用不同通知方式
- **文档记录**：监控脚本和配置要有详细文档
- **定期维护**：定期检查监控系统本身是否正常

**⚠️ 常见问题避免**
- **监控系统单点故障**：监控系统本身也要有备份
- **告警风暴**：短时间大量告警要有抑制机制  
- **阈值设置不当**：过低误报多，过高漏报严重
- **历史数据丢失**：监控数据要定期备份
- **权限设置错误**：监控脚本要有适当的执行权限

**核心记忆口诀**：
- 监控要全面，告警要精准
- 自动化处理，人工来兜底  
- 分层次检查，分等级告警
- 数据要保存，趋势要分析