---
title: 4、ps命令详解与实践
---
## 📚 目录

1. [ps命令基本语法与选项](#1-ps命令基本语法与选项)
2. [BSD风格与System V风格参数](#2-BSD风格与System V风格参数)
3. [进程信息字段详解](#3-进程信息字段详解)
4. [自定义输出格式](#4-自定义输出格式)
5. [进程过滤与搜索技巧](#5-进程过滤与搜索技巧)
6. [进程树显示](#6-进程树显示)
7. [内存使用统计](#7-内存使用统计)
8. [CPU时间统计](#8-CPU时间统计)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 ps命令基本语法与选项


### 1.1 什么是ps命令

🎯 **简单理解**：ps命令就像系统的"任务管理器"

```
生活中的类比：
手机设置中的"运行中的应用" → 查看当前活跃程序
ps命令的作用 → 查看Linux系统中运行的进程

基本功能：
- 显示当前运行的进程
- 查看进程的详细信息  
- 监控系统资源使用情况
- 帮助排查系统问题
```

**🔸 ps命令的核心价值**
```
系统管理：快速了解系统运行状态
故障诊断：找出占用资源过多的进程
安全检查：发现可疑或异常进程
性能优化：分析进程资源消耗情况
```

### 1.2 基本语法结构

**📋 命令格式**
```bash
ps [选项参数]
```

**🟢 最常用的基本形式**
- `ps` - 显示当前终端的进程
- `ps aux` - 显示所有用户的所有进程（BSD风格）
- `ps -ef` - 显示所有进程的完整信息（System V风格）
- `ps -elf` - 显示详细的长格式进程信息

### 1.3 快速上手示例

**🚀 立即可用的命令组合**

```bash
# 查看当前用户进程
ps

# 查看所有进程（推荐新手使用）
ps aux

# 查看进程层次关系
ps aux --forest

# 查看特定用户进程
ps -u root

# 实时查看进程（类似top命令）
watch -n 1 'ps aux --sort=-%cpu | head -20'
```

**💡 初学者友好提示**
```
记住三个最实用的命令：
1. ps aux → 查看所有进程
2. ps aux | grep 程序名 → 查找特定程序
3. ps aux --sort=-%cpu → 按CPU使用率排序
```

---

## 2. 🔄 BSD风格与System V风格参数


### 2.1 两种风格的历史背景

**📚 Unix系统发展历程**

```
历史演进：
1970s - Unix诞生
1980s - 分化为两大分支：
        ├─ BSD (Berkeley Software Distribution)
        └─ System V (AT&T Unix)

风格特征：
BSD风格：选项不带连字符，如 aux
System V风格：选项带连字符，如 -ef

现代Linux：两种风格都支持，可以混用
```

### 2.2 BSD风格参数详解

**🔸 常用BSD风格选项**

| 选项 | **含义** | **功能说明** |
|------|---------|-------------|
| `a` | **所有用户** | `显示所有用户的进程（不仅仅当前用户）` |
| `u` | **详细信息** | `显示用户名、CPU、内存等详细信息` |
| `x` | **所有进程** | `包括没有控制终端的进程` |
| `f` | **完整格式** | `显示完整的命令行参数` |
| `--forest` | **树形显示** | `以树形结构显示进程关系` |
| `--sort` | **排序显示** | `按指定字段排序` |

**💡 BSD风格组合技巧**
```bash
# 经典组合：显示所有进程详细信息
ps aux

# 树形结构显示进程关系
ps auxf

# 按内存使用量排序
ps aux --sort=-%mem

# 按CPU使用率排序
ps aux --sort=-%cpu

# 只显示特定字段
ps axo pid,ppid,user,%cpu,%mem,comm
```

### 2.3 System V风格参数详解

**🔸 常用System V风格选项**

| 选项 | **含义** | **功能说明** |
|------|---------|-------------|
| `-e` | **所有进程** | `equivalent to -A，显示所有进程` |
| `-f` | **完整格式** | `full format，完整信息格式` |
| `-l` | **长格式** | `long format，详细信息` |
| `-u` | **指定用户** | `显示指定用户的进程` |
| `-p` | **指定PID** | `显示指定进程ID的进程` |
| `-t` | **指定终端** | `显示指定终端的进程` |

**💡 System V风格实用组合**
```bash
# 显示所有进程完整信息
ps -ef

# 显示所有进程的详细长格式
ps -elf  

# 显示特定用户进程
ps -u nginx

# 显示特定PID进程
ps -p 1234

# 显示进程层次关系
ps -ejH
```

### 2.4 两种风格对比与选择

**⚖️ 风格选择建议**

```
🟢 初学者推荐：
首选 ps aux（BSD风格）
- 输出信息直观易懂
- 字段含义清晰
- 社区使用最广泛

🟡 系统管理员：
ps -ef（System V风格）  
- 显示完整命令行
- 进程关系更清楚
- 适合脚本处理

🔵 混合使用：
现代Linux系统支持混用
ps -auxf 或 ps aux -f 都可以
根据需要选择最合适的参数组合
```

---

## 3. 📊 进程信息字段详解


### 3.1 ps aux输出字段解读

**🔍 字段含义详细说明**

```
典型ps aux输出示例：
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169760  9076 ?        Ss   12:00   0:01 /sbin/init
nginx     1234  0.1  2.1 142584 43208 ?        S    12:05   0:02 nginx: worker
```

**📋 字段详细解释**

| 字段 | **含义** | **详细说明** |
|------|---------|-------------|
| `USER` | **进程所有者** | `启动该进程的用户名` |
| `PID` | **进程ID** | `系统分配的唯一进程标识符` |
| `%CPU` | **CPU占用率** | `进程占用CPU的百分比` |
| `%MEM` | **内存占用率** | `进程占用内存的百分比` |
| `VSZ` | **虚拟内存大小** | `进程虚拟内存总量（KB）` |
| `RSS` | **物理内存大小** | `进程实际占用物理内存（KB）` |
| `TTY` | **关联终端** | `进程关联的终端，?表示无终端` |
| `STAT` | **进程状态** | `进程当前运行状态` |
| `START` | **启动时间** | `进程启动的时间` |
| `TIME` | **CPU时间** | `进程累计使用的CPU时间` |
| `COMMAND` | **命令行** | `启动进程的完整命令` |

### 3.2 进程状态码详解

**🔸 STAT字段状态码含义**

```
基本状态码：
R (Running)     → 正在运行或等待运行
S (Sleeping)    → 可中断睡眠状态（等待事件）
D (Uninterruptible) → 不可中断睡眠（通常等待I/O）
T (Stopped)     → 进程被停止
Z (Zombie)      → 僵尸进程（已结束但未被回收）

附加标识：
< → 高优先级进程
N → 低优先级进程  
L → 页面已锁定在内存中
s → 会话领导者
l → 多线程进程
+ → 前台进程组
```

**💡 状态码实际含义**
```bash
# 查看不同状态的进程
ps aux | grep " R "    # 运行中进程
ps aux | grep " S "    # 睡眠进程  
ps aux | grep " Z "    # 僵尸进程（需要注意）
ps aux | grep " D "    # 不可中断睡眠（可能有问题）

# 找出僵尸进程
ps aux | awk '$8 ~ /^Z/ { print $2, $11 }'
```

### 3.3 内存信息字段理解

**💾 VSZ vs RSS 的区别**

```
VSZ (Virtual Set Size)：
含义：进程的虚拟内存总量
包括：所有虚拟内存空间
特点：包括未实际使用的内存空间

RSS (Resident Set Size)：
含义：进程实际占用的物理内存
包括：真正加载到RAM中的内存
特点：反映真实内存使用情况

实际意义：
RSS更重要 → 反映真实内存消耗
VSZ过大但RSS不大 → 通常不用担心
RSS持续增长 → 可能存在内存泄漏
```

### 3.4 ps -ef输出字段解读

**🔸 System V风格字段说明**

```
典型ps -ef输出：
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 12:00 ?        00:00:01 /sbin/init
root       123     1  0 12:01 ?        00:00:00 [kthreadd]
```

**📋 System V字段含义**

| 字段 | **含义** | **详细说明** |
|------|---------|-------------|
| `UID` | **用户ID** | `进程所有者的用户ID或用户名` |
| `PID` | **进程ID** | `当前进程的ID` |
| `PPID` | **父进程ID** | `创建该进程的父进程ID` |
| `C` | **CPU利用率** | `CPU使用率的整数表示` |
| `STIME` | **启动时间** | `进程启动的时间` |
| `TTY` | **控制终端** | `进程的控制终端` |
| `TIME` | **累计CPU时间** | `进程使用CPU的总时间` |
| `CMD` | **命令** | `启动进程的命令` |

---

## 4. 🎨 自定义输出格式


### 4.1 使用-o选项自定义字段

**🔧 精确控制输出内容**

```bash
# 基本语法
ps -o 字段1,字段2,字段3

# 常用自定义格式示例
ps -eo pid,ppid,user,cpu,mem,comm

# 更详细的自定义格式
ps -eo pid,ppid,user,%cpu,%mem,vsz,rss,tty,stat,start,time,comm
```

**📊 常用字段名称对照**

| 字段名 | **含义** | **示例值** |
|--------|---------|-----------|
| `pid` | **进程ID** | `1234` |
| `ppid` | **父进程ID** | `1` |
| `user` | **用户名** | `root` |
| `uid` | **用户ID** | `0` |
| `group` | **组名** | `root` |
| `comm` | **命令名** | `nginx` |
| `args` | **完整命令行** | `nginx -g daemon off` |
| `%cpu` | **CPU使用率** | `2.5` |
| `%mem` | **内存使用率** | `1.8` |
| `vsz` | **虚拟内存** | `142584` |
| `rss` | **物理内存** | `43208` |

### 4.2 实用的自定义格式模板

**🎯 针对不同场景的格式模板**

```bash
# 1. 进程监控模板（资源使用情况）
ps -eo pid,user,%cpu,%mem,vsz,rss,comm --sort=-%cpu

# 2. 进程关系模板（父子进程关系）
ps -eo pid,ppid,user,comm --forest

# 3. 内存分析模板
ps -eo pid,user,rss,vsz,%mem,comm --sort=-rss

# 4. 启动时间模板
ps -eo pid,user,lstart,etime,comm

# 5. 进程状态模板  
ps -eo pid,stat,user,comm | grep -v " S "

# 6. 网络服务模板
ps -eo pid,user,args | grep -E "(nginx|apache|httpd|mysql)"
```

### 4.3 输出格式美化技巧

**💅 让输出更易读**

```bash
# 1. 添加表头说明
ps -eo pid,user,%cpu,%mem,comm --no-headers | \
  awk 'BEGIN{print "进程ID  用户    CPU%  内存%  命令"} {print $0}'

# 2. 限制输出行数
ps aux --sort=-%cpu | head -10

# 3. 格式化数值显示  
ps -eo pid,user,%cpu,%mem,rss,comm | \
  awk '{printf "%-8s %-10s %6.1f%% %6.1f%% %8s %-15s\n", $1, $2, $3, $4, $5, $6}'

# 4. 彩色输出（需要配合其他工具）
ps aux | grep nginx | awk '{print "\033[32m" $1 "\033[0m", $2, $11}'
```

### 4.4 脚本中的格式化应用

**📝 自动化脚本中的ps用法**

```bash
#!/bin/bash
# 系统监控脚本示例

# 函数：显示CPU使用率最高的进程
show_top_cpu() {
    echo "=== CPU使用率最高的10个进程 ==="
    ps -eo pid,user,%cpu,comm --sort=-%cpu --no-headers | head -10 | \
    while read pid user cpu comm; do
        printf "%-8s %-12s %6.1f%%  %s\n" "$pid" "$user" "$cpu" "$comm"
    done
}

# 函数：显示内存使用率最高的进程
show_top_memory() {
    echo "=== 内存使用率最高的10个进程 ==="
    ps -eo pid,user,%mem,rss,comm --sort=-%mem --no-headers | head -10 | \
    while read pid user mem rss comm; do
        printf "%-8s %-12s %6.1f%% %8sKB  %s\n" "$pid" "$user" "$mem" "$rss" "$comm"
    done
}

# 函数：检查异常进程
check_zombie_processes() {
    zombie_count=$(ps aux | awk '$8 ~ /^Z/ {count++} END {print count+0}')
    if [ $zombie_count -gt 0 ]; then
        echo "⚠️  警告：发现 $zombie_count 个僵尸进程"
        ps aux | awk '$8 ~ /^Z/ {print "PID:", $2, "PPID:", $3, "CMD:", $11}'
    else
        echo "✅ 没有发现僵尸进程"
    fi
}

# 执行监控
show_top_cpu
echo
show_top_memory  
echo
check_zombie_processes
```

---

## 5. 🔎 进程过滤与搜索技巧


### 5.1 基本过滤方法

**🎯 快速定位目标进程**

```bash
# 1. 按进程名过滤
ps aux | grep nginx
ps aux | grep -v grep | grep nginx  # 排除grep自身

# 2. 按用户过滤  
ps -u root
ps -u www-data,nginx  # 多个用户

# 3. 按进程ID过滤
ps -p 1234
ps -p 1234,5678,9012  # 多个PID

# 4. 按终端过滤
ps -t pts/0
ps -t tty1,pts/1  # 多个终端
```

**💡 避免grep自身的技巧**
```bash
# 方法1：使用正则表达式
ps aux | grep '[n]ginx'

# 方法2：使用pgrep命令
pgrep nginx

# 方法3：两步过滤
ps aux | grep nginx | grep -v grep
```

### 5.2 高级搜索技巧

**🚀 复杂条件的进程搜索**

```bash
# 1. 按CPU使用率过滤
ps aux | awk '$3 > 5.0 {print $0}'  # CPU > 5%

# 2. 按内存使用率过滤  
ps aux | awk '$4 > 10.0 {print $0}'  # 内存 > 10%

# 3. 按启动时间过滤
ps -eo pid,lstart,comm | grep "Jan 11"  # 特定日期启动

# 4. 按进程状态过滤
ps aux | awk '$8 == "R" {print $0}'  # 运行状态

# 5. 组合条件过滤
ps aux | awk '$3 > 2.0 && $4 > 5.0 {print $2, $3, $4, $11}'
```

### 5.3 正则表达式搜索

**🔍 使用正则表达式精确匹配**

```bash
# 1. 匹配以特定字符开头的进程
ps aux | grep "^root.*nginx"

# 2. 匹配包含特定模式的命令行
ps aux | grep -E "(mysql|mariadb|postgres)"

# 3. 匹配PID范围
ps aux | awk '$2 >= 1000 && $2 <= 2000 {print $0}'

# 4. 复杂正则表达式
ps aux | grep -E "nginx.*worker|apache.*worker"

# 5. 排除特定模式
ps aux | grep -v -E "(kthread|migration|rcu_)"
```

### 5.4 结合其他命令的搜索

**🔗 组合命令增强搜索能力**

```bash
# 1. 结合sort排序
ps aux | grep nginx | sort -k3 -nr  # 按CPU排序

# 2. 结合head/tail限制输出
ps aux --sort=-%cpu | head -5  # 前5个CPU使用最高

# 3. 结合wc统计
ps aux | grep -c nginx  # 统计nginx进程数量

# 4. 结合xargs批量操作
ps aux | grep zombie | awk '{print $2}' | xargs kill -9

# 5. 结合while循环处理
ps aux | grep nginx | while read user pid cpu mem vsz rss tty stat start time command; do
    echo "进程$pid 使用CPU: $cpu%"
done
```

### 5.5 实用的搜索脚本

**📝 封装常用搜索功能**

```bash
#!/bin/bash
# process_finder.sh - 进程搜索工具

# 函数：搜索高资源消耗进程
find_resource_hogs() {
    local cpu_threshold=${1:-5.0}
    local mem_threshold=${2:-10.0}
    
    echo "查找CPU使用率 > $cpu_threshold% 或内存使用率 > $mem_threshold% 的进程："
    ps aux | awk -v cpu=$cpu_threshold -v mem=$mem_threshold '
    $3 > cpu || $4 > mem {
        printf "PID: %-8s User: %-10s CPU: %6.1f%% MEM: %6.1f%% CMD: %s\n", 
               $2, $1, $3, $4, $11
    }'
}

# 函数：按名称搜索进程详情
find_by_name() {
    local process_name=$1
    if [ -z "$process_name" ]; then
        echo "使用方法: find_by_name <进程名>"
        return 1
    fi
    
    echo "搜索进程: $process_name"
    ps aux | grep -E "$process_name" | grep -v grep | \
    while read user pid cpu mem vsz rss tty stat start time command; do
        echo "┌─ PID: $pid ($user)"
        echo "├─ CPU: $cpu% | 内存: $mem% | 状态: $stat"  
        echo "├─ 虚拟内存: ${vsz}KB | 物理内存: ${rss}KB"
        echo "└─ 命令: $command"
        echo
    done
}

# 函数：查找可疑进程
find_suspicious() {
    echo "查找可能的可疑进程："
    
    # 僵尸进程
    zombie_count=$(ps aux | awk '$8 ~ /^Z/ {count++} END {print count+0}')
    if [ $zombie_count -gt 0 ]; then
        echo "🔴 发现僵尸进程:"
        ps aux | awk '$8 ~ /^Z/ {print "  PID:", $2, "PPID:", $3, "CMD:", $11}'
    fi
    
    # 高CPU使用率进程
    echo "🟡 CPU使用率 > 20% 的进程:"
    ps aux | awk '$3 > 20 {print "  PID:", $2, "CPU:", $3 "%", "CMD:", $11}'
    
    # 长时间运行的进程
    echo "🔵 运行时间 > 24小时的进程:"
    ps -eo pid,etime,comm | awk '$2 ~ /-/ {print "  PID:", $1, "运行时间:", $2, "命令:", $3}'
}

# 主菜单
case $1 in
    "hogs")
        find_resource_hogs $2 $3
        ;;
    "name")
        find_by_name $2
        ;;
    "suspicious")
        find_suspicious
        ;;
    *)
        echo "进程搜索工具使用方法:"
        echo "  $0 hogs [cpu阈值] [内存阈值]  - 查找高资源消耗进程"
        echo "  $0 name <进程名>              - 按名称搜索进程"
        echo "  $0 suspicious                - 查找可疑进程"
        ;;
esac
```

---

## 6. 🌳 进程树显示


### 6.1 理解进程树概念

**🎯 进程父子关系的可视化**

```
进程树的含义：
系统中所有进程都有父子关系
init进程(PID 1)是所有进程的祖先
进程树显示了进程的继承和依赖关系

实际意义：
- 理解进程启动顺序
- 分析进程依赖关系  
- 排查进程异常问题
- 管理进程组和会话
```

### 6.2 基本进程树显示方法

**🌲 不同的树形显示选项**

```bash
# 1. BSD风格进程树
ps auxf
ps aux --forest

# 2. System V风格进程树  
ps -ejH
ps -ef --forest

# 3. 简化的进程树
ps -eo pid,ppid,comm --forest

# 4. 指定用户的进程树
ps -u root f
```

**💡 进程树输出理解**
```
典型进程树结构：
systemd(1)─┬─systemd-journal(123)
           ├─systemd-udevd(145)  
           ├─dbus-daemon(567)
           ├─nginx(890)─┬─nginx(891)
           │            ├─nginx(892)
           │            └─nginx(893)
           └─sshd(1001)───sshd(1234)───bash(1235)
```

### 6.3 pstree命令的使用

**🔧 专门的进程树显示工具**

```bash
# 基本进程树显示
pstree

# 显示PID  
pstree -p

# 显示用户名
pstree -u

# 显示完整命令行
pstree -a

# 显示特定进程的子树
pstree -p 1234

# 组合选项
pstree -pua
```

**🎨 pstree输出美化**
```bash
# 1. 彩色输出
pstree -C age

# 2. ASCII字符显示（兼容性好）
pstree -A

# 3. 按PID排序
pstree -n

# 4. 显示线程
pstree -T

# 5. 高亮特定进程
pstree -H 1234
```

### 6.4 分析进程关系实例

**📊 实际应用场景**

```bash
# 场景1：分析Web服务器进程结构
echo "=== Nginx进程树分析 ==="
ps aux | grep nginx | grep -v grep
echo
pstree -p $(pgrep nginx | head -1)

# 场景2：查看SSH连接进程
echo "=== SSH连接进程树 ==="
pstree -p $(pgrep sshd | head -1)

# 场景3：分析数据库进程结构
echo "=== MySQL进程树 ==="  
pstree -p $(pgrep mysql | head -1)

# 场景4：查看用户会话进程
echo "=== 用户会话进程树 ==="
w | grep -v load | tail -n +2 | while read user tty from login idle pcpu what; do
    echo "用户: $user, 终端: $tty"
    ps -t $tty --forest
    echo "---"
done
```

### 6.5 进程树监控脚本

**📝 动态监控进程树变化**

```bash
#!/bin/bash
# process_tree_monitor.sh

# 函数：监控特定进程的子进程
monitor_children() {
    local parent_pid=$1
    local parent_name=$(ps -p $parent_pid -o comm --no-headers 2>/dev/null)
    
    if [ -z "$parent_name" ]; then
        echo "进程 $parent_pid 不存在"
        return 1
    fi
    
    echo "监控进程 $parent_name($parent_pid) 的子进程："
    
    while true; do
        clear
        echo "=== $(date) ==="
        echo "父进程: $parent_name (PID: $parent_pid)"
        echo
        
        # 显示进程树
        pstree -p $parent_pid 2>/dev/null || {
            echo "进程已退出"
            break
        }
        
        echo
        echo "子进程详细信息："
        ps --ppid $parent_pid -o pid,user,%cpu,%mem,comm --no-headers | \
        while read pid user cpu mem comm; do
            printf "  PID: %-8s User: %-10s CPU: %6.1f%% MEM: %6.1f%% CMD: %s\n" \
                   "$pid" "$user" "$cpu" "$mem" "$comm"
        done
        
        sleep 2
    done
}

# 函数：显示系统完整进程树
show_full_tree() {
    echo "系统完整进程树："
    echo "=================="
    pstree -pua | head -50
    
    echo
    echo "主要服务进程："
    echo "=============="
    for service in systemd nginx apache2 mysql ssh; do
        pid=$(pgrep $service | head -1)
        if [ ! -z "$pid" ]; then
            echo "$service: PID $pid"
            pstree -p $pid | head -5
            echo
        fi
    done
}

# 主程序
case $1 in
    "monitor")
        if [ -z "$2" ]; then
            echo "用法: $0 monitor <PID>"
            exit 1
        fi
        monitor_children $2
        ;;
    "full")
        show_full_tree
        ;;
    *)
        echo "进程树监控工具:"
        echo "  $0 monitor <PID>  - 监控指定进程的子进程"
        echo "  $0 full           - 显示系统完整进程树"
        ;;
esac
```

---

## 7. 💾 内存使用统计


### 7.1 理解进程内存信息

**📊 内存使用的各种指标**

```
Linux进程内存类型：
VSZ (Virtual Set Size)    → 虚拟内存总量
RSS (Resident Set Size)   → 物理内存使用量  
PSS (Proportional Set Size) → 按比例分配的内存
USS (Unique Set Size)     → 进程独占内存
SHR (Shared Memory)       → 共享内存大小

实际意义：
RSS最重要 → 真实物理内存消耗
VSZ过大通常不用担心 → 虚拟内存便宜
PSS更准确 → 考虑共享内存的分摊
```

### 7.2 内存统计的ps命令用法

**🔍 查看进程内存使用情况**

```bash
# 1. 基本内存信息查看
ps aux | sort -k4 -nr | head -10  # 按内存使用率排序

# 2. 详细内存信息
ps -eo pid,user,vsz,rss,%mem,comm --sort=-rss

# 3. 内存使用超过阈值的进程
ps aux | awk '$4 > 5.0 {print $0}'  # 内存使用 > 5%

# 4. 特定进程的内存详情
ps -o pid,vsz,rss,%mem,comm -p 1234

# 5. 按内存使用量显示所有进程
ps -eo pid,user,rss,vsz,%mem,comm --sort=-rss --no-headers | \
  head -20 | awk '{printf "%-8s %-12s %10s %10s %8s %s\n", $1, $2, $3, $4, $5, $6}'
```

### 7.3 内存分析实用技巧

**💡 深入分析内存使用情况**

```bash
# 1. 统计各用户内存使用总量
ps aux | awk '{user[$1]+=$6} END {for (u in user) print u, user[u] "KB"}' | sort -k2 -nr

# 2. 统计进程名的内存使用
ps aux | awk '{cmd=$11; gsub(/.*\//, "", cmd); mem[cmd]+=$6} END {for (c in mem) print c, mem[c] "KB"}' | sort -k2 -nr

# 3. 查找内存泄漏候选进程
#!/bin/bash
# 连续监控进程内存使用情况
monitor_memory_leak() {
    local pid=$1
    local interval=${2:-5}
    local log_file="/tmp/memory_monitor_$pid.log"
    
    echo "监控进程 $pid 的内存使用情况，每 $interval 秒记录一次"
    echo "时间,PID,RSS,VSZ,%MEM" > $log_file
    
    while kill -0 $pid 2>/dev/null; do
        ps -p $pid -o pid,rss,vsz,%mem --no-headers | \
        while read pid rss vsz mem; do
            echo "$(date '+%H:%M:%S'),$pid,$rss,$vsz,$mem" >> $log_file
        done
        sleep $interval
    done
}

# 4. 内存使用Top N分析
memory_top_analysis() {
    local count=${1:-10}
    
    echo "=== 内存使用Top $count 进程 ==="
    printf "%-8s %-12s %10s %10s %8s %s\n" "PID" "用户" "物理内存" "虚拟内存" "百分比" "命令"
    echo "================================================================="
    
    ps aux --sort=-rss --no-headers | head -$count | \
    while read user pid cpu mem vsz rss tty stat start time command; do
        printf "%-8s %-12s %10s %10s %8s %s\n" "$pid" "$user" "${rss}KB" "${vsz}KB" "$mem%" "$command"
    done
}
```

### 7.4 内存监控脚本

**📈 持续监控内存使用情况**

```bash
#!/bin/bash
# memory_monitor.sh - 内存使用监控工具

# 系统内存总量 (KB)
total_memory=$(grep MemTotal /proc/meminfo | awk '{print $2}')

# 函数：格式化内存大小显示
format_memory() {
    local size_kb=$1
    if [ $size_kb -gt 1048576 ]; then
        printf "%.2fGB" $(echo "scale=2; $size_kb/1048576" | bc)
    elif [ $size_kb -gt 1024 ]; then
        printf "%.2fMB" $(echo "scale=2; $size_kb/1024" | bc)
    else
        printf "${size_kb}KB"
    fi
}

# 函数：内存使用报告
memory_usage_report() {
    echo "=== 系统内存使用报告 $(date) ==="
    echo
    
    # 系统整体内存情况
    echo "系统整体内存使用:"
    free -h | head -2 | tail -1 | awk '{print "  总内存:", $2, "已用:", $3, "可用:", $7}'
    echo
    
    # Top 10 内存消耗进程
    echo "内存使用Top 10进程:"
    echo "------------------------------------------------------------"
    printf "%-8s %-12s %10s %8s %s\n" "PID" "用户" "物理内存" "百分比" "命令"
    echo "------------------------------------------------------------"
    
    ps aux --sort=-rss --no-headers | head -10 | \
    while read user pid cpu mem vsz rss tty stat start time command; do
        rss_formatted=$(format_memory $rss)
        printf "%-8s %-12s %10s %8s %s\n" "$pid" "$user" "$rss_formatted" "$mem%" "${command:0:30}"
    done
    echo
    
    # 内存使用警告
    high_memory_processes=$(ps aux | awk '$4 > 10 {count++} END {print count+0}')
    if [ $high_memory_processes -gt 0 ]; then
        echo "⚠️  警告: $high_memory_processes 个进程内存使用超过10%"
        ps aux | awk '$4 > 10 {printf "  PID %s: %.1f%% (%s)\n", $2, $4, $11}'
        echo
    fi
    
    # 内存使用趋势（需要历史数据）
    if [ -f "/tmp/memory_history.log" ]; then
        echo "内存使用趋势 (最近5次记录):"
        tail -5 /tmp/memory_history.log
    fi
    
    # 记录当前内存使用到历史文件
    current_memory=$(free | awk '/^Mem:/ {printf "%.1f", ($3/$2)*100}')
    echo "$(date '+%Y-%m-%d %H:%M:%S') ${current_memory}%" >> /tmp/memory_history.log
}

# 函数：内存泄漏检测
memory_leak_detection() {
    echo "=== 内存泄漏检测 ==="
    echo
    
    # 查找长时间运行且内存使用量大的进程
    echo "长时间运行的高内存进程 (运行时间>1天, 内存>5%):"
    ps -eo pid,etime,pmem,comm | awk 'NR>1 && $2 ~ /-/ && $3 > 5 {print $0}' | \
    while read pid etime pmem comm; do
        echo "  PID $pid ($comm): 运行时间 $etime, 内存使用 $pmem%"
    done
    echo
    
    # 查找RSS持续增长的进程（需要历史数据对比）
    echo "注意: 内存泄漏需要长期监控RSS变化来确定"
    echo "建议使用: watch -n 10 'ps aux --sort=-rss | head -10'"
}

# 主程序
case $1 in
    "report")
        memory_usage_report
        ;;
    "leak")
        memory_leak_detection
        ;;
    "watch")
        watch -n 5 "$0 report"
        ;;
    *)
        echo "内存监控工具使用方法:"
        echo "  $0 report  - 显示内存使用报告"
        echo "  $0 leak    - 内存泄漏检测"  
        echo "  $0 watch   - 持续监控内存使用"
        ;;
esac
```

---

## 8. ⏱️ CPU时间统计


### 8.1 理解CPU时间概念

**🔍 CPU时间的不同含义**

```
CPU时间类型：
User Time (用户时间)   → 进程在用户态消耗的CPU时间
System Time (系统时间) → 进程在内核态消耗的CPU时间  
Real Time (实际时间)   → 进程运行的总时间（墙钟时间）
CPU Time (CPU时间)    → User Time + System Time

时间格式：
ps命令显示：累计CPU时间 (mm:ss或hh:mm:ss)
%CPU：当前CPU使用百分比
TIME：进程启动以来累计的CPU时间
```

### 8.2 CPU时间相关的ps选项

**📊 查看进程CPU使用情况**

```bash
# 1. 按CPU使用率排序
ps aux --sort=-%cpu

# 2. 显示详细的CPU时间信息
ps -eo pid,user,time,%cpu,pcpu,cputime,comm

# 3. 显示CPU使用率和累计时间
ps -eo pid,%cpu,cputime,etime,comm --sort=-%cpu

# 4. 实时CPU使用率（类似top）
watch -n 1 'ps aux --sort=-%cpu --no-headers | head -10'

# 5. 特定进程的CPU统计
ps -p 1234 -o pid,%cpu,cputime,etime,comm
```

### 8.3 CPU统计分析技巧

**🎯 深入分析CPU使用情况**

```bash
# 1. 统计各用户CPU使用总量
ps aux | awk '{user[$1]+=$3} END {for (u in user) printf "%s: %.1f%%\n", u, user[u]}' | sort -k2 -nr

# 2. 统计进程名CPU使用
ps aux | awk '{gsub(/.*\//, "", $11); cpu[$11]+=$3} END {for (c in cpu) printf "%s: %.1f%%\n", c, cpu[c]}' | sort -k2 -nr

# 3. 查找CPU密集型进程
ps aux | awk '$3 > 5.0 {print "PID:", $2, "CPU:", $3 "%", "CMD:", $11}'

# 4. CPU使用时间统计脚本
#!/bin/bash
cpu_time_analysis() {
    echo "=== CPU时间使用分析 ==="
    echo
    
    # 显示CPU使用时间最长的进程
    echo "CPU累计时间最长的10个进程:"
    echo "-------------------------------------------"
    printf "%-8s %-12s %10s %8s %s\n" "PID" "用户" "累计时间" "CPU%" "命令"
    echo "-------------------------------------------"
    
    ps -eo pid,user,cputime,%cpu,comm --sort=-time --no-headers | head -10 | \
    while read pid user cputime cpu comm; do
        printf "%-8s %-12s %10s %8s %s\n" "$pid" "$user" "$cputime" "$cpu%" "$comm"
    done
    echo
    
    # 显示当前CPU使用率最高的进程
    echo "当前CPU使用率最高的10个进程:"
    echo "-------------------------------------------"
    printf "%-8s %-12s %8s %10s %s\n" "PID" "用户" "CPU%" "累计时间" "命令"
    echo "-------------------------------------------"
    
    ps aux --sort=-%cpu --no-headers | head -10 | \
    while read user pid cpu mem vsz rss tty stat start time command; do
        printf "%-8s %-12s %8s %10s %s\n" "$pid" "$user" "$cpu%" "$time" "${command:0:30}"
    done
}
```

### 8.4 CPU性能监控

**📈 持续监控CPU使用情况**

```bash
#!/bin/bash
# cpu_monitor.sh - CPU使用监控工具

# 函数：CPU使用报告
cpu_usage_report() {
    echo "=== CPU使用报告 $(date) ==="
    echo
    
    # 系统整体CPU使用率
    echo "系统整体CPU使用率:"
    top -bn1 | grep "Cpu(s)" | awk '{print "  用户:", $2, "系统:", $4, "空闲:", $8}'
    echo
    
    # 负载平均值
    echo "系统负载平均值:"
    uptime | awk -F'load average:' '{print "  " $2}'
    echo
    
    # Top 10 CPU使用进程
    echo "CPU使用Top 10进程:"
    echo "--------------------------------------------------------"
    printf "%-8s %-12s %8s %10s %10s %s\n" "PID" "用户" "CPU%" "累计时间" "运行时间" "命令"
    echo "--------------------------------------------------------"
    
    ps -eo pid,user,%cpu,cputime,etime,comm --sort=-%cpu --no-headers | head -10 | \
    while read pid user cpu cputime etime comm; do
        printf "%-8s %-12s %8s %10s %10s %s\n" "$pid" "$user" "$cpu%" "$cputime" "$etime" "$comm"
    done
    echo
    
    # CPU使用警告
    high_cpu_count=$(ps aux | awk '$3 > 20 {count++} END {print count+0}')
    if [ $high_cpu_count -gt 0 ]; then
        echo "⚠️  警告: $high_cpu_count 个进程CPU使用率超过20%"
        ps aux | awk '$3 > 20 {printf "  PID %s: %.1f%% (%s)\n", $2, $3, $11}'
        echo
    fi
}

# 函数：CPU异常检测
cpu_anomaly_detection() {
    echo "=== CPU异常检测 ==="
    echo
    
    # 检查CPU使用率过高的进程
    echo "CPU使用率异常进程检测:"
    high_cpu_processes=$(ps aux | awk '$3 > 50')
    if [ ! -z "$high_cpu_processes" ]; then
        echo "🔴 发现CPU使用率>50%的进程:"
        echo "$high_cpu_processes" | awk '{printf "  PID %s (%s): %.1f%% - %s\n", $2, $1, $3, $11}'
    else
        echo "✅ 未发现CPU使用率异常的进程"
    fi
    echo
    
    # 检查长时间高CPU使用的进程
    echo "长时间高CPU使用进程检测:"
    ps -eo pid,%cpu,cputime,etime,comm | awk 'NR>1 && $2 > 10 && $3 ~ /:/ {print $0}' | \
    while read pid cpu cputime etime comm; do
        echo "🟡 PID $pid ($comm): CPU $cpu%, 累计时间 $cputime, 运行时间 $etime"
    done
    echo
    
    # 系统负载检查
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | tr -d ' ')
    cpu_cores=$(nproc)
    load_threshold=$(echo "$cpu_cores * 2" | bc)
    
    if (( $(echo "$load_avg > $load_threshold" | bc -l) )); then
        echo "🔴 系统负载过高: $load_avg (建议< $load_threshold)"
    else
        echo "✅ 系统负载正常: $load_avg"
    fi
}

# 函数：CPU使用趋势分析
cpu_trend_analysis() {
    local interval=${1:-5}
    local count=${2:-12}
    
    echo "=== CPU使用趋势分析 (每${interval}秒采样，共${count}次) ==="
    echo
    
    local log_file="/tmp/cpu_trend_$$.log"
    echo "时间,CPU%,负载,高CPU进程数" > $log_file
    
    for i in $(seq 1 $count); do
        timestamp=$(date '+%H:%M:%S')
        cpu_usage=$(ps aux | awk '{sum+=$3} END {printf "%.1f", sum}')
        load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | tr -d ' ')
        high_cpu_count=$(ps aux | awk '$3 > 10 {count++} END {print count+0}')
        
        echo "$timestamp,$cpu_usage,$load_avg,$high_cpu_count" >> $log_file
        echo "[$i/$count] 时间:$timestamp CPU总使用:$cpu_usage% 负载:$load_avg 高CPU进程:$high_cpu_count"
        
        sleep $interval
    done
    
    echo
    echo "趋势数据已保存到: $log_file"
    echo "分析结果:"
    
    avg_cpu=$(awk -F',' 'NR>1 {sum+=$2; count++} END {printf "%.1f", sum/count}' $log_file)
    max_cpu=$(awk -F',' 'NR>1 {if($2>max) max=$2} END {print max}' $log_file)
    
    echo "  平均CPU使用率: $avg_cpu%"
    echo "  最高CPU使用率: $max_cpu%"
    
    # 清理临时文件
    rm -f $log_file
}

# 主程序
case $1 in
    "report")
        cpu_usage_report
        ;;
    "anomaly")
        cpu_anomaly_detection
        ;;
    "trend")
        cpu_trend_analysis $2 $3
        ;;
    "watch")
        watch -n 3 "$0 report"
        ;;
    *)
        echo "CPU监控工具使用方法:"
        echo "  $0 report              - 显示CPU使用报告"
        echo "  $0 anomaly             - CPU异常检测"
        echo "  $0 trend [间隔] [次数] - CPU使用趋势分析"
        echo "  $0 watch               - 持续监控CPU使用"
        ;;
esac
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 ps命令本质：系统进程状态的快照工具，不是实时监控
🔸 两种风格：BSD风格(aux)和System V风格(-ef)可以混用
🔸 关键字段：PID、%CPU、%MEM、RSS、VSZ、STAT最重要
🔸 进程状态：R(运行)、S(睡眠)、Z(僵尸)、D(不可中断睡眠)
🔸 内存理解：RSS是真实物理内存，VSZ是虚拟内存总量
🔸 进程树：理解父子关系，使用--forest或pstree显示
🔸 自定义格式：-o选项可以精确控制输出字段
🔸 搜索过滤：结合grep、awk等工具实现复杂筛选
```

### 9.2 关键理解要点


**🔹 ps命令的定位和局限性**
```
ps命令特点：
- 提供某一时刻的进程快照
- 不是实时监控工具（需要反复执行）
- 信息来源于 /proc 文件系统
- 适合脚本处理和自动化

与其他工具的区别：
- top/htop：实时动态监控
- ps：静态快照，适合脚本
- pstree：专注进程关系树
- pidstat：详细的进程统计
```

**🔹 内存和CPU统计的正确理解**
```
内存指标选择：
- RSS：最重要，反映真实内存占用
- VSZ：参考价值有限，通常很大
- %MEM：基于RSS计算的百分比
- 共享内存会被重复计算

CPU统计理解：
- %CPU：当前时刻的CPU使用率
- TIME：进程启动以来累计CPU时间
- CPUTIME：更详细的累计CPU时间
- 高%CPU但低TIME：短时间突发
- 低%CPU但高TIME：长期运行
```

**🔹 进程状态的实际意义**
```
重要状态码：
- R：正在运行或等待CPU
- S：等待某个事件（正常状态）
- D：等待IO完成（可能有问题）
- Z：僵尸进程（需要清理）
- T：被信号停止

状态分析：
- 大量D状态：IO瓶颈
- 存在Z状态：父进程未回收子进程
- 很多R状态：CPU竞争激烈
```

### 9.3 实际应用价值


**🎯 系统管理场景应用**
- **性能监控**：定期检查资源使用top进程
- **故障排查**：查找占用资源异常的进程
- **安全审计**：发现可疑或异常进程
- **容量规划**：分析应用资源需求模式
- **进程管理**：理解进程关系，安全终止进程

**🔧 运维自动化实践**
- **监控脚本**：自动化的资源使用报告
- **告警系统**：基于阈值的异常进程告警
- **日志分析**：进程行为的历史趋势分析
- **批量操作**：结合xargs进行批量进程管理

**📈 与其他工具的配合使用**
```
工具组合建议：
ps + grep + awk：复杂的进程筛选和统计
ps + watch：准实时的进程监控
ps + xargs + kill：批量进程管理
ps + sort：按资源使用排序
pstree：理解进程关系
/proc/[pid]/：更详细的进程信息
```

**核心记忆口诀**：
- ps命令查进程，aux常用显详情
- BSD风格不带杠，SystemV要带杠
- RSS物理VSZ虚拟，CPU百分看当时
- 进程状态要关注，僵尸异常需处理
- 过滤排序巧组合，监控脚本助运维