---
title: 23、SysV初始化系统
---
## 📚 目录


1. [SysV初始化系统概述](#1-sysv初始化系统概述)
2. [SysV运行级别概念](#2-sysv运行级别概念)
3. [init进程工作机制](#3-init进程工作机制)
4. [/etc/inittab配置详解](#4-etcinittab配置详解)
5. [运行级别切换操作](#5-运行级别切换操作)
6. [telinit命令使用](#6-telinit命令使用)
7. [运行级别目录结构](#7-运行级别目录结构)
8. [启动脚本执行顺序](#8-启动脚本执行顺序)
9. [SysV兼容性问题](#9-sysv兼容性问题)
10. [核心要点总结](#10-核心要点总结)

---

# 🎯 **学习导航**


**前置知识**：Linux基础命令、进程概念、文件系统结构 → **当前内容**：SysV初始化系统 → **后续学习**：systemd现代服务管理

⏱️ **预计学习时间**：本章预计45分钟 | 实践操作20分钟

🏷️ **知识标签**：`#系统启动` `#服务管理` `#传统架构`

---

## 1. 🖥️ SysV初始化系统概述



### 1.1 什么是SysV初始化系统



**🔸 核心定义**
SysV（System V）初始化系统是传统Unix系统使用的启动管理机制，负责在Linux内核启动后接管系统初始化工作。

**💭 通俗理解**
想象系统启动就像公司开门营业：
- **内核启动**：相当于打开公司大门
- **SysV init**：相当于总经理，负责安排各部门按顺序开始工作
- **各种服务**：相当于不同部门，需要按优先级启动

### 1.2 SysV系统特点



**🏗️ 核心特征**
- **顺序启动**：服务按照预定顺序依次启动，确保依赖关系
- **运行级别**：系统有多个工作模式，每个模式启动不同服务
- **脚本驱动**：通过shell脚本控制服务的启动和停止
- **层次管理**：clear的目录结构和编号系统

### 1.3 SysV在Linux发展中的地位



**📊 发展历程对比**

| **时代** | **主流系统** | **特点** | **适用场景** |
|---------|-------------|---------|-------------|
| **1990-2010** | SysV init | 简单稳定，脚本驱动 | 传统服务器 |
| **2010-至今** | systemd | 并行启动，依赖管理 | 现代Linux发行版 |
| **兼容过渡** | Upstart | 事件驱动 | Ubuntu等部分发行版 |

> **⚠️ 重要提醒**：虽然现代Linux主要使用systemd，但很多系统仍保持SysV兼容性，理解SysV有助于深入理解Linux启动机制。

---

## 2. 🎚️ SysV运行级别概念



### 2.1 运行级别基本概念



**🔸 什么是运行级别**
运行级别（Runlevel）是系统当前的工作状态，决定了系统启动哪些服务和功能。就像手机的不同模式：静音模式、飞行模式、正常模式。

**📋 标准运行级别表**

| **级别** | **名称** | **功能描述** | **典型用途** |
|---------|---------|-------------|-------------|
| **0** | 关机模式 | 系统关闭 | shutdown命令执行时 |
| **1** | 单用户模式 | 最小系统，仅root | 系统维护、密码恢复 |
| **2** | 多用户模式（无网络） | 本地多用户，无NFS | 特殊维护场景 |
| **3** | 完整多用户模式 | 命令行界面，完整功能 | **服务器标准模式** |
| **4** | 保留级别 | 用户自定义 | 特殊用途定制 |
| **5** | 图形界面模式 | X11图形界面 | **桌面用户标准模式** |
| **6** | 重启模式 | 系统重启 | reboot命令执行时 |

### 2.2 运行级别的实际意义



**🎯 不同场景的选择**
```
服务器环境：
多数时候运行在级别3 → 节省资源，专注服务
需要图形管理时切换到级别5

桌面环境：
日常使用运行在级别5 → 完整图形界面
系统问题时降级到级别1 → 单用户修复

紧急情况：
密码忘记 → 级别1单用户模式重置
系统故障 → 级别1最小化环境修复
```

### 2.3 查看当前运行级别



**🔍 检查系统状态**
```bash
# 查看当前运行级别

runlevel
# 输出示例：N 3 (N表示之前级别，3是当前级别)


# 查看默认运行级别

grep "initdefault" /etc/inittab
# 输出：id:3:initdefault:

```

**💡 理解输出信息**
- `N 3` 表示从无定义状态进入级别3
- `5 3` 表示从级别5切换到级别3
- 第一个数字是前一个级别，第二个是当前级别

---

## 3. ⚙️ init进程工作机制



### 3.1 init进程的核心作用



**🔸 系统启动流程**
```
内核启动完成 → 寻找init程序 → 执行/sbin/init → 成为PID 1进程

init进程职责：
• 读取/etc/inittab配置
• 启动指定运行级别的服务  
• 管理子进程生命周期
• 处理系统信号和级别切换
```

**💭 生活类比**
init进程就像公司的总经理：
- **启动时**：按照公司章程（inittab）安排各部门工作
- **运行中**：监督各部门运转，出问题及时处理
- **调整时**：根据需要调整公司运营模式

### 3.2 init进程的工作循环



**🔄 持续监控机制**
```
init进程工作循环：
1. 读取inittab配置
2. 检查当前运行级别
3. 启动需要的服务进程
4. 监听进程状态变化
5. 处理僵尸进程
6. 响应级别切换信号
7. 回到步骤4继续循环
```

### 3.3 进程层次关系



**🌳 进程家族树**
```
系统进程层次结构：
init(1)
├── kernel threads [2-n]
├── system daemons
│   ├── syslogd
│   ├── crond  
│   └── sshd
├── getty processes (终端)
└── user processes
    └── user login shells
```

**📊 关键特征**
- **PID 1**：init永远是进程号1，系统第一个用户空间进程
- **父进程角色**：所有孤儿进程的最终父进程
- **不可杀死**：系统运行期间init进程不能被终止

---

## 4. 📝 /etc/inittab配置详解



### 4.1 inittab文件结构



**🔸 配置文件语法**
inittab每行的格式：`id:runlevels:action:process`

**📋 字段详解**

| **字段** | **含义** | **示例** | **说明** |
|---------|---------|---------|---------|
| **id** | 条目标识 | `si` | 1-4个字符的唯一标识符 |
| **runlevels** | 运行级别 | `35` | 适用的运行级别，可多个 |
| **action** | 执行动作 | `once` | 定义何时和如何执行 |
| **process** | 执行程序 | `/etc/rc.d/rc` | 要运行的命令或脚本 |

### 4.2 常见action动作类型



**⚡ 关键动作说明**
- **initdefault**：系统默认运行级别
- **sysinit**：系统初始化时执行（最早）
- **boot**：系统启动时执行
- **bootwait**：启动时执行并等待完成
- **once**：进入指定级别时执行一次
- **respawn**：进程退出后自动重启
- **ctrlaltdel**：Ctrl+Alt+Del组合键处理

### 4.3 典型inittab配置示例



**📄 实际配置解读**
```bash
# 系统默认运行级别

id:3:initdefault:

# 系统初始化脚本

si::sysinit:/etc/rc.d/rc.sysinit

# 各运行级别初始化

l0:0:wait:/etc/rc.d/rc 0
l1:1:wait:/etc/rc.d/rc 1  
l2:2:wait:/etc/rc.d/rc 2
l3:3:wait:/etc/rc.d/rc 3
l5:5:wait:/etc/rc.d/rc 5
l6:6:wait:/etc/rc.d/rc 6

# 终端getty进程

1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2

# 重启快捷键

ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
```

**💡 配置理解要点**
- `id:3:initdefault:` 设置系统默认到级别3
- `respawn` 确保终端进程总是可用
- `wait` 让init等待脚本执行完成再继续
- `ctrlaltdel` 定义三键重启的行为

---

## 5. 🔄 运行级别切换操作



### 5.1 临时切换运行级别



**⚡ 即时切换方法**
```bash
# 切换到单用户模式（维护模式）

init 1

# 切换到多用户命令行模式

init 3

# 切换到图形界面模式  

init 5

# 重启系统

init 6

# 关闭系统

init 0
```

**⚠️ 切换注意事项**
- 切换前保存重要工作，可能中断当前会话
- 从级别5到级别3会关闭图形界面
- 级别1只允许root用户，其他用户会被注销

### 5.2 永久修改默认级别



**🔧 修改系统默认启动级别**
```bash
# 编辑inittab文件

vim /etc/inittab

# 找到这一行并修改

id:3:initdefault:  # 改为想要的级别

# 示例：改为图形界面默认启动

id:5:initdefault:
```

### 5.3 运行级别切换过程



**🔄 系统切换机制**
```
用户执行init 3：
1. init收到切换信号
2. 查询当前级别（比如5）
3. 停止级别5独有的服务
4. 启动级别3需要的服务  
5. 更新当前运行级别
6. 切换完成
```

**📊 切换影响分析**

| **切换路径** | **影响** | **常见场景** |
|-------------|---------|-------------|
| **5→3** | 关闭图形界面，保留网络 | 服务器模式切换 |
| **3→1** | 停止网络和多用户服务 | 系统维护 |  
| **任何→6** | 系统重启 | 系统更新后 |
| **任何→0** | 系统关机 | 正常关机 |

---

## 6. 🛠️ telinit命令使用



### 6.1 telinit命令功能



**🔸 命令作用**
telinit是init命令的符号链接，提供更安全的运行级别切换方式，包含额外的安全检查。

**⚖️ telinit vs init对比**

| **特性** | **init** | **telinit** |
|---------|---------|------------|
| **安全检查** | 基础 | 增强 |
| **错误提示** | 简单 | 详细 |
| **兼容性** | 直接 | 推荐使用 |

### 6.2 telinit命令用法



**📋 基本语法和选项**
```bash
# 基本语法

telinit [选项] 运行级别

# 常用选项

telinit -t 5 3    # 等待5秒后切换到级别3
telinit q         # 重新读取inittab配置
telinit Q         # 同上（大写Q）
telinit u         # 重新初始化init进程
```

### 6.3 实用场景示例



**🎯 常见使用场景**
```bash
# 系统维护场景

telinit 1         # 进入单用户模式修复系统

# 服务器管理场景  

telinit 3         # 切换到纯命令行模式节省资源

# 配置更新场景

telinit q         # 修改inittab后重新加载配置

# 紧急重启场景

telinit 6         # 安全重启系统
```

**💡 最佳实践建议**
- 优先使用telinit而不是直接用init
- 重要操作前先保存工作
- 切换前通知其他用户
- 维护时使用级别1而不是直接关机

---

## 7. 📁 运行级别目录结构



### 7.1 RC目录体系结构



**🏗️ 标准目录布局**
```
/etc/rc.d/目录结构：
├── init.d/          # 服务启动脚本存放目录
├── rc0.d/          # 运行级别0的服务链接
├── rc1.d/          # 运行级别1的服务链接  
├── rc2.d/          # 运行级别2的服务链接
├── rc3.d/          # 运行级别3的服务链接
├── rc5.d/          # 运行级别5的服务链接
├── rc6.d/          # 运行级别6的服务链接
├── rc.sysinit      # 系统初始化主脚本
└── rc              # 运行级别切换控制脚本
```

### 7.2 服务脚本链接命名规则



**🔤 文件名编码规则**
```
链接文件命名格式：[K/S]NNservice_name

K = Kill（停止服务）
S = Start（启动服务）  
NN = 两位数字优先级（00-99）
service_name = 服务名称

示例：
S10network    # 优先级10启动网络服务
K90network    # 优先级90停止网络服务
S80httpd      # 优先级80启动Apache服务
```

### 7.3 服务优先级设计



**📊 典型服务启动顺序**

| **优先级范围** | **服务类型** | **典型服务** |
|---------------|-------------|-------------|
| **S10-S20** | 基础系统服务 | network, syslog |
| **S30-S50** | 核心服务 | crond, sshd |
| **S60-S80** | 应用服务 | httpd, mysql |
| **S90-S99** | 用户服务 | 自定义应用 |

**🔄 停止顺序（K脚本）**
停止顺序与启动相反，K90先执行，K10最后执行，确保依赖关系正确。

### 7.4 实际目录内容查看



**🔍 查看服务配置**
```bash
# 查看级别3的启动服务

ls -la /etc/rc.d/rc3.d/S*
# 输出示例：

# S10network -> ../init.d/network

# S12syslog -> ../init.d/syslog

# S50sshd -> ../init.d/sshd


# 查看级别3的停止服务

ls -la /etc/rc.d/rc3.d/K*
```

---

## 8. 🔢 启动脚本执行顺序



### 8.1 系统启动完整流程



**⚡ 详细启动时序**
```
1. 内核启动完成
   ↓
2. 执行/sbin/init（PID=1）
   ↓  
3. 读取/etc/inittab配置
   ↓
4. 执行系统初始化（rc.sysinit）
   ↓
5. 进入目标运行级别（如rc3.d）
   ↓
6. 按S脚本数字顺序启动服务
   ↓
7. 启动getty终端进程
   ↓
8. 系统就绪，等待用户登录
```

### 8.2 服务依赖关系处理



**🔗 依赖管理机制**
SysV通过数字优先级简单处理依赖：
```
网络服务依赖示例：
S10network     # 首先启动网络基础服务
S15netfs       # 然后启动网络文件系统
S20nfslock     # 再启动NFS锁服务
S50sshd        # 最后启动SSH服务（依赖网络）
```

**⚠️ 依赖处理局限**
- 只能通过数字顺序粗糙控制
- 无法表达复杂的依赖关系
- 不支持并行启动优化
- 这是SysV被systemd替代的主要原因

### 8.3 启动脚本标准接口



**🔧 脚本标准参数**
每个init.d下的服务脚本都应支持标准操作：
```bash
/etc/init.d/servicename start    # 启动服务
/etc/init.d/servicename stop     # 停止服务  
/etc/init.d/servicename restart  # 重启服务
/etc/init.d/servicename status   # 查看状态
/etc/init.d/servicename reload   # 重新加载配置
```

**📝 脚本编写要点**
- 必须支持start/stop参数
- 应该包含状态检查逻辑
- 需要正确处理返回值（0=成功）
- 建议包含详细的日志输出

---

## 9. 🔄 SysV兼容性问题



### 9.1 现代Linux中的SysV兼容



**🔸 兼容性现状**
现代Linux发行版主要使用systemd，但大多保持SysV兼容：

**📊 主流发行版兼容情况**

| **发行版** | **默认init** | **SysV兼容性** | **兼容程度** |
|-----------|-------------|---------------|-------------|
| **RHEL/CentOS 7+** | systemd | 完整兼容 | ⭐⭐⭐⭐⭐ |
| **Ubuntu 16+** | systemd | 良好兼容 | ⭐⭐⭐⭐ |
| **Debian 8+** | systemd | 完整兼容 | ⭐⭐⭐⭐⭐ |
| **老版本系统** | SysV init | 原生支持 | ⭐⭐⭐⭐⭐ |

### 9.2 兼容性实现方式



**🔄 systemd兼容机制**
```
systemd系统中的SysV兼容：
• systemctl start service → 自动查找SysV脚本
• 运行级别映射到systemd target
• telinit命令重定向到systemctl
• /etc/init.d/脚本仍可正常使用
```

**🎯 运行级别映射关系**
```
SysV级别 → systemd target：
0 → poweroff.target
1 → rescue.target  
3 → multi-user.target
5 → graphical.target
6 → reboot.target
```

### 9.3 迁移和适配建议



**🚀 现代化迁移路径**
```
SysV环境迁移建议：
1. 理解现有SysV脚本功能
2. 学习systemd service文件语法
3. 逐步将服务迁移到systemd
4. 保留关键SysV脚本作为备份
5. 测试兼容性和功能完整性
```

**💡 最佳实践**
- 新服务优先使用systemd service文件
- 旧系统维护时仍可使用SysV方式
- 重要生产环境谨慎迁移
- 保留SysV知识用于故障排除

---

## 10. 📋 核心要点总结



### 10.1 必须掌握的核心概念



```
🔸 SysV init：传统Unix风格的系统初始化机制，进程号永远是1
🔸 运行级别：0-6七个级别，定义系统不同工作模式
🔸 inittab配置：控制init行为的核心配置文件
🔸 rc.d目录：服务脚本和启动链接的标准存放位置
🔸 启动顺序：通过S/K前缀和数字优先级控制服务启动顺序
🔸 兼容性：现代systemd系统仍保持SysV兼容支持
```

### 10.2 关键理解要点



**🔹 为什么需要运行级别**
```
灵活性需求：
- 服务器不需要图形界面（级别3）
- 桌面用户需要完整功能（级别5）
- 维护时需要单用户模式（级别1）

资源优化：
- 不同模式启动不同服务
- 避免不必要的资源消耗
- 提供专门的维护环境
```

**🔹 SysV与现代init系统的差异**
```
SysV特点：
✅ 简单稳定，逻辑清晰
✅ 脚本化管理，容易理解
❌ 串行启动，速度较慢
❌ 依赖管理简单粗糙

systemd优势：
✅ 并行启动，速度更快  
✅ 复杂依赖管理
❌ 学习曲线较陡峭
❌ 系统复杂度增加
```

### 10.3 实际应用指导



**🛠️ 系统管理实践**
- **日常运维**：了解运行级别概念，合理选择系统模式
- **故障排除**：使用级别1单用户模式修复系统问题  
- **服务管理**：理解服务启动顺序，排查启动失败问题
- **系统迁移**：掌握SysV到systemd的迁移方法

**⚠️ 注意事项**
- 修改inittab前务必备份
- 运行级别切换会影响正在运行的服务
- 理解依赖关系，避免服务启动顺序错误
- 在虚拟机中练习，避免影响生产系统

### 10.4 学习检查清单



- [ ] 理解7个运行级别的含义和用途
- [ ] 能够读懂inittab配置文件格式  
- [ ] 掌握telinit命令的基本用法
- [ ] 了解rc.d目录结构和文件命名规则
- [ ] 理解服务启动的优先级机制
- [ ] 知道SysV在现代Linux中的兼容性状况

**🔑 核心记忆要点**
> SysV init系统历史悠久，运行级别概念清晰
> 配置简单脚本化，依赖顺序数字化  
> 现代兼容仍重要，理解原理助排障

**💡 延伸学习方向**
- 深入学习systemd现代服务管理
- 了解其他init系统（如OpenRC、runit）
- 学习编写标准的SysV服务脚本
- 掌握systemd与SysV的互操作技巧