---
title: 15、Sticky位权限
---
## 📚 目录

1. [Sticky位权限概念](#1-sticky位权限概念)
2. [Sticky位作用机制](#2-sticky位作用机制)
3. [/tmp目录Sticky位应用](#3-tmp目录sticky位应用)
4. [Sticky位设置与清除](#4-sticky位设置与清除)
5. [Sticky位权限检查](#5-sticky位权限检查)
6. [Sticky位安全防护](#6-sticky位安全防护)
7. [Sticky位故障排查](#7-sticky位故障排查)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 Sticky位权限概念


### 1.1 什么是Sticky位


**简单理解**：Sticky位就像给目录加了一把"特殊锁"，让目录里的文件只能被文件所有者删除。

```
没有Sticky位的目录：
用户A创建的文件 → 用户B、C、D都能删除

有Sticky位的目录：
用户A创建的文件 → 只有用户A能删除
```

**🔸 核心定义**
- **Sticky位**：一种特殊的文件权限位，主要用于目录
- **作用**：限制目录中文件的删除权限
- **符号表示**：权限末尾显示为 `t` 或 `T`
- **八进制值**：`1000`（第4位权限位）

### 1.2 Sticky位的历史背景


**历史由来**：
在早期的UNIX系统中，Sticky位最初用于可执行文件，让程序在内存中"粘住"以提高执行效率。现在主要用于目录权限管理。

**现代用途**：
- 🎯 **目录保护**：防止用户误删他人文件
- 🔒 **权限细化**：在共享目录中实现精细权限控制
- 🛡️ **安全增强**：提供额外的安全保护机制

### 1.3 权限位结构解析


**完整权限结构**：
```
特殊权限位 + 常规权限位
    ↓           ↓
   1234       rwxrwxrwx
   
第1位：setuid (4)
第2位：setgid (2)  
第3位：sticky (1)
第4-12位：用户、组、其他的rwx权限
```

**权限显示示例**：
```
drwxrwxrwt  # 有Sticky位的目录
drwxrwxrwx  # 没有Sticky位的目录

t = 小写t：其他用户有执行权限 + Sticky位
T = 大写T：其他用户无执行权限 + Sticky位
```

---

## 2. ⚙️ Sticky位作用机制


### 2.1 工作原理详解


**🔸 核心机制**：
Sticky位设置在目录上时，该目录中的文件和子目录只能被以下用户删除或重命名：
- 文件的所有者
- 目录的所有者  
- root用户

**权限判断流程**：
```
用户尝试删除文件
        ↓
    检查目录是否设置Sticky位？
        ↓
    是 → 检查用户身份
         ├─ 文件所有者？ → 允许删除
         ├─ 目录所有者？ → 允许删除
         ├─ root用户？   → 允许删除
         └─ 其他用户     → 拒绝删除
    否 → 按常规权限判断
```

### 2.2 权限交互关系


**Sticky位 vs 写权限**：

| **目录写权限** | **Sticky位** | **删除他人文件** | **说明** |
|----------------|--------------|------------------|----------|
| 🚫 **无写权限** | 无关 | ❌ **不能删除** | 写权限是基础 |
| ✅ **有写权限** | ❌ **无Sticky** | ✅ **能删除** | 常规情况 |
| ✅ **有写权限** | ✅ **有Sticky** | ❌ **不能删除** | Sticky保护 |

**🔸 重要理解**：
- Sticky位不能替代写权限，只能在有写权限的基础上限制删除
- 用户仍然可以在目录中创建、修改自己的文件
- 只是不能删除或重命名他人的文件

### 2.3 实际场景演示


**场景设置**：
```bash
# 创建测试目录
mkdir /test_sticky
chmod 777 /test_sticky  # 给所有用户读写执行权限

# 用户A创建文件
su - userA
echo "A的文件" > /test_sticky/fileA.txt

# 用户B尝试删除A的文件
su - userB
rm /test_sticky/fileA.txt  # 成功删除！
```

**加上Sticky位后**：
```bash
# 设置Sticky位
chmod +t /test_sticky

# 用户A重新创建文件
su - userA
echo "A的文件" > /test_sticky/fileA.txt

# 用户B再次尝试删除
su - userB
rm /test_sticky/fileA.txt  # 删除失败！
# 错误：rm: cannot remove 'fileA.txt': Operation not permitted
```

---

## 3. 📁 /tmp目录Sticky位应用


### 3.1 /tmp目录的特殊性


**🔸 /tmp目录特点**：
- **系统临时目录**：存放各种临时文件
- **全局可写**：所有用户都可以在此创建文件
- **多用户共享**：多个用户同时使用
- **默认Sticky位**：系统自动设置Sticky位保护

**权限查看**：
```bash
ls -ld /tmp
# 输出：drwxrwxrwt 15 root root 4096 Jan 20 14:30 /tmp
#              ↑
#           Sticky位标志
```

### 3.2 /tmp目录工作机制


**正常操作流程**：
```
用户操作流程图：

用户A                     /tmp目录                    用户B
  |                         |                         |
  |--创建临时文件----------->|                         |
  |   /tmp/tempA.txt        |<--创建临时文件-----------|
  |                         |    /tmp/tempB.txt       |
  |--可以删除自己的文件----->|                         |
  |   删除tempA.txt         |                         |
  |                         |<--只能删除自己的文件-----|
  |--不能删除他人文件----X-->|    不能删除tempA.txt    |
  |   拒绝访问              |                         |
```

**实际测试**：
```bash
# 用户A的操作
whoami  # userA
echo "用户A的临时数据" > /tmp/userA_temp.txt
ls -l /tmp/userA_temp.txt
# -rw-rw-r-- 1 userA userA 18 Jan 20 14:30 userA_temp.txt

# 用户B的操作
su - userB
cat /tmp/userA_temp.txt    # 可以读取（如果权限允许）
rm /tmp/userA_temp.txt     # 无法删除
# rm: cannot remove '/tmp/userA_temp.txt': Operation not permitted
```

### 3.3 /tmp目录安全价值


**🛡️ 安全防护机制**：

| **威胁类型** | **无Sticky位风险** | **有Sticky位保护** |
|--------------|-------------------|-------------------|
| **恶意删除** | 用户可删除他人临时文件 | 只能删除自己的文件 |
| **数据泄露** | 删除后可能恢复数据 | 文件所有权明确 |
| **系统破坏** | 删除重要临时文件 | 系统文件受保护 |
| **权限提升** | 可能通过删除获取权限 | 权限边界清晰 |

**💡 实际意义**：
想象一个公共的储物柜房间，每个人都可以放东西，但只能拿走自己的物品。这就是Sticky位在/tmp目录中的作用。

---

## 4. 🔧 Sticky位设置与清除


### 4.1 设置Sticky位的方法


**🔸 使用符号模式设置**：
```bash
# 添加Sticky位
chmod +t /path/to/directory

# 实例：为共享目录设置Sticky位
mkdir /shared
chmod 777 /shared      # 先给所有权限
chmod +t /shared       # 再添加Sticky位
ls -ld /shared
# drwxrwxrwt 2 root root 4096 Jan 20 14:30 /shared
```

**🔸 使用数字模式设置**：
```bash
# 数字模式：在权限前加1
chmod 1777 /path/to/directory

# 权限计算：
# 1000 (Sticky位) + 777 (rwxrwxrwx) = 1777

# 实例对比
chmod 777  /test1    # drwxrwxrwx (无Sticky位)
chmod 1777 /test2    # drwxrwxrwt (有Sticky位)
```

### 4.2 清除Sticky位的方法


**🔸 使用符号模式清除**：
```bash
# 移除Sticky位
chmod -t /path/to/directory

# 实例演示
ls -ld /shared
# drwxrwxrwt 2 root root 4096 Jan 20 14:30 /shared

chmod -t /shared
ls -ld /shared  
# drwxrwxrwx 2 root root 4096 Jan 20 14:30 /shared
```

**🔸 使用数字模式清除**：
```bash
# 直接设置不含Sticky位的权限
chmod 777 /path/to/directory

# 或者明确设置为0开头
chmod 0777 /path/to/directory
```

### 4.3 批量操作与脚本


**批量设置示例**：
```bash
#!/bin/bash
# 为多个共享目录设置Sticky位

shared_dirs=("/shared1" "/shared2" "/shared3")

for dir in "${shared_dirs[@]}"; do
    if [[ -d "$dir" ]]; then
        echo "设置 $dir 的Sticky位..."
        chmod +t "$dir"
        echo "✓ 完成: $(ls -ld $dir | awk '{print $1}')"
    else
        echo "⚠️ 目录不存在: $dir"
    fi
done
```

**权限验证脚本**：
```bash
#!/bin/bash
# 检查目录是否正确设置Sticky位

check_sticky() {
    local dir=$1
    if [[ -d "$dir" ]]; then
        local perms=$(stat -c "%a" "$dir")
        if [[ ${perms:0:1} == "1" ]] || [[ $(ls -ld "$dir" | grep -o "t$") ]]; then
            echo "✓ $dir 已设置Sticky位"
        else
            echo "✗ $dir 未设置Sticky位"
        fi
    else
        echo "⚠️ $dir 不存在"
    fi
}

check_sticky "/tmp"
check_sticky "/var/tmp"
```

---

## 5. 🔍 Sticky位权限检查


### 5.1 权限查看方法


**🔸 使用ls命令查看**：
```bash
# 长格式显示，注意最后一位
ls -ld /tmp
# drwxrwxrwt 15 root root 4096 Jan 20 14:30 /tmp
#        ↑
#    这里是 't' 表示有Sticky位

# 批量查看多个目录
ls -ld /tmp /var/tmp /shared
```

**🔸 使用stat命令查看**：
```bash
# 数字格式权限
stat -c "%a %n" /tmp
# 1777 /tmp
# ↑
# 开头的1表示Sticky位

# 详细权限信息
stat /tmp | grep Access
# Access: (1777/drwxrwxrwt)  Uid: (    0/    root)   Gid: (    0/    root)
```

### 5.2 权限状态识别


**权限标志解读表**：

| **显示** | **含义** | **说明** |
|----------|----------|----------|
| `t` | **小写t** | 其他用户有执行权限 + Sticky位 |
| `T` | **大写T** | 其他用户无执行权限 + Sticky位 |
| `x` | **小写x** | 其他用户有执行权限，无Sticky位 |
| `-` | **短横线** | 其他用户无执行权限，无Sticky位 |

**实际示例对比**：
```bash
# 创建测试目录演示不同权限组合
mkdir test{1,2,3,4}

chmod 1777 test1  # drwxrwxrwt (777 + sticky)
chmod 1776 test2  # drwxrwxrwT (776 + sticky)  
chmod 777  test3  # drwxrwxrwx (777, no sticky)
chmod 776  test4  # drwxrwxrw- (776, no sticky)

ls -ld test*
```

### 5.3 自动化权限审计


**权限审计脚本**：
```bash
#!/bin/bash
# Sticky位权限审计工具

echo "=== Sticky位权限审计报告 ==="
echo "检查时间: $(date)"
echo

# 检查系统关键目录
critical_dirs=("/tmp" "/var/tmp")
echo "📁 系统关键目录检查："
for dir in "${critical_dirs[@]}"; do
    if [[ -d "$dir" ]]; then
        perms=$(ls -ld "$dir" | awk '{print $1}')
        if [[ "$perms" == *"t" ]]; then
            echo "✅ $dir: $perms (正常)"
        else
            echo "⚠️  $dir: $perms (可能存在风险)"
        fi
    fi
done

echo
echo "🔍 查找所有设置Sticky位的目录："
find / -type d -perm -1000 2>/dev/null | head -20
```

---

## 6. 🛡️ Sticky位安全防护


### 6.1 安全防护机制


**🔸 防护原理**：
Sticky位通过限制文件删除权限，在多用户环境中提供额外的安全保护层。

**安全边界图**：
```
用户权限边界示意：

没有Sticky位的共享目录：
┌─────────────────────────────┐
│         共享目录            │
│  用户A文件 ←→ 用户B可删除   │  
│  用户B文件 ←→ 用户A可删除   │
│  用户C文件 ←→ 任何人可删除  │
└─────────────────────────────┘
        ↑ 安全风险高

有Sticky位的共享目录：
┌─────────────────────────────┐
│         共享目录 [t]        │
│  用户A文件 ←X→ 用户B不能删除 │
│  用户B文件 ←X→ 用户A不能删除 │  
│  用户C文件 ←X→ 他人不能删除  │
└─────────────────────────────┘
        ↑ 安全防护强
```

### 6.2 攻击防护案例


**🚨 常见攻击场景与防护**：

**场景1：恶意文件删除**
```bash
# 攻击者尝试删除他人重要文件
rm /shared/important_file.txt
# 无Sticky位：删除成功，数据丢失
# 有Sticky位：删除失败，数据安全
```

**场景2：竞争条件攻击**
```bash
# 攻击者监听文件创建，立即删除
while true; do
    rm /tmp/victim_temp_* 2>/dev/null
done
# Sticky位阻止此类攻击
```

**场景3：权限提升尝试**
```bash
# 攻击者创建同名文件替换
rm /tmp/important_script.sh    # 删除原文件
cp malicious.sh /tmp/important_script.sh  # 替换恶意文件
# Sticky位防止删除原文件
```

### 6.3 安全最佳实践


**🔒 配置建议**：

| **目录类型** | **权限设置** | **Sticky位** | **说明** |
|--------------|--------------|--------------|----------|
| **系统临时目录** | `1777` | ✅ **必须** | /tmp, /var/tmp |
| **共享工作目录** | `1775` | ✅ **推荐** | 团队协作目录 |
| **公共上传目录** | `1773` | ✅ **推荐** | 防止误删上传文件 |
| **个人目录** | `700` | ❌ **不需要** | 已有所有权保护 |

**安全检查清单**：
```
☐ /tmp目录是否设置Sticky位？
☐ /var/tmp目录是否设置Sticky位？
☐ 自定义共享目录是否需要Sticky位？
☐ 是否定期审计Sticky位设置？
☐ 用户是否了解Sticky位的作用？
```

---

## 7. 🔧 Sticky位故障排查


### 7.1 常见问题诊断


**🐛 问题1：文件删除失败**
```bash
# 现象
rm /shared/myfile.txt
# rm: cannot remove 'myfile.txt': Operation not permitted

# 诊断步骤
ls -ld /shared          # 检查目录权限
ls -l /shared/myfile.txt  # 检查文件所有权
whoami                  # 确认当前用户
```

**解决方案**：
- 确认你是文件所有者
- 或联系目录所有者
- 或使用sudo权限

**🐛 问题2：权限设置不生效**
```bash
# 现象
chmod +t /mydir
ls -ld /mydir
# drwxrwxrwx 2 user user 4096 Jan 20 14:30 /mydir  # 没有显示't'

# 可能原因
stat -c "%a" /mydir     # 检查数字权限
# 如果显示777而不是1777，说明设置失败
```

**解决方案**：
```bash
# 使用数字模式强制设置
chmod 1777 /mydir

# 或检查是否有足够权限
sudo chmod +t /mydir
```

### 7.2 权限冲突解决


**冲突场景分析**：

**情况A：Sticky位与其他特殊权限冲突**
```bash
# 同时设置多个特殊权限
chmod u+s,g+s,+t /testdir  # setuid + setgid + sticky

# 检查结果
stat -c "%a" /testdir  # 可能显示7777
ls -ld /testdir       # 显示rwsrwsrwt
```

**情况B：权限继承问题**
```bash
# 父目录有Sticky位，子目录没有
mkdir -p /sticky_parent/child
chmod +t /sticky_parent

ls -ld /sticky_parent        # drwxrwxrwt
ls -ld /sticky_parent/child  # drwxrwxrwx (没有继承)
```

### 7.3 故障排查工具


**综合诊断脚本**：
```bash
#!/bin/bash
# Sticky位故障诊断工具

diagnose_sticky() {
    local target=$1
    
    echo "=== 诊断目标: $target ==="
    
    # 检查目标是否存在
    if [[ ! -e "$target" ]]; then
        echo "❌ 目标不存在"
        return 1
    fi
    
    # 检查是否为目录
    if [[ ! -d "$target" ]]; then
        echo "⚠️ 目标不是目录，Sticky位仅用于目录"
        return 1
    fi
    
    # 显示权限信息
    echo "📋 权限信息："
    ls -ld "$target"
    
    # 显示数字权限
    local perms=$(stat -c "%a" "$target")
    echo "🔢 数字权限: $perms"
    
    # 检查Sticky位状态
    if [[ ${perms:0:1} == "1" ]]; then
        echo "✅ Sticky位已设置"
    else
        echo "❌ Sticky位未设置"
    fi
    
    # 显示所有权信息
    echo "👤 所有权信息："
    stat -c "所有者: %U (%u), 所属组: %G (%g)" "$target"
    
    echo
}

# 使用示例
diagnose_sticky "/tmp"
diagnose_sticky "/shared"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Sticky位本质：目录级别的删除权限限制机制
🔸 核心作用：只允许文件所有者、目录所有者、root删除文件
🔸 权限表示：ls -l 显示末尾't'或'T'，数字权限开头'1'
🔸 主要用途：保护共享目录中的文件安全
🔸 典型应用：/tmp目录防止用户删除他人临时文件
```

### 8.2 关键理解要点


**🔹 Sticky位与普通权限的关系**
```
理解要点：
- Sticky位是在写权限基础上的额外限制
- 不能替代基本的rwx权限
- 只对目录有意义，对普通文件无效果
- 是一种"更细粒度"的权限控制机制
```

**🔹 权限优先级顺序**
```
权限检查顺序：
1. 基本权限检查 (rwx)
2. 所有权检查 (owner)  
3. Sticky位检查 (删除限制)
4. root权限 (最高权限)
```

**🔹 安全防护价值**
```
实际意义：
- 多用户环境的文件保护
- 防止意外或恶意删除
- 临时文件安全管理
- 共享目录权限细化
```

### 8.3 实际应用指导


**🎯 使用场景判断**：
```
✅ 适用场景：
• 多用户共享的工作目录
• 临时文件存储目录
• 公共上传下载目录
• 需要防误删的协作目录

❌ 不适用场景：
• 个人私有目录
• 只读文件目录
• 单用户系统
• 需要批量清理的目录
```

**🔧 配置操作要点**：
```
设置命令：
chmod +t /directory    # 符号模式
chmod 1xxx /directory  # 数字模式 (xxx是原权限)

检查命令：
ls -ld /directory      # 查看权限标志
stat -c "%a" /directory # 查看数字权限

清除命令：
chmod -t /directory    # 移除Sticky位
```

### 8.4 故障排查要点


**🔍 常见问题及解决**：
```
问题：设置后不生效
→ 检查是否有足够权限设置
→ 确认目标是目录而非文件
→ 使用数字模式强制设置

问题：文件无法删除
→ 确认用户身份和文件所有权
→ 检查目录是否设置Sticky位
→ 联系文件所有者或使用sudo

问题：权限显示异常
→ 区分小写t和大写T的含义
→ 检查其他用户的执行权限
→ 使用stat命令确认数字权限
```

**核心记忆**：
- Sticky位是共享目录的"保护锁"
- 只有文件主人能删除自己的文件
- /tmp目录的安全守护神
- 't'标志是权限的特殊标识