---
title: 6、用户组管理命令
---
## 📚 目录

1. [用户组管理基础概念](#1-用户组管理基础概念)
2. [groupadd创建用户组](#2-groupadd创建用户组)
3. [groupmod修改组属性](#3-groupmod修改组属性)
4. [groupdel删除用户组](#4-groupdel删除用户组)
5. [gpasswd组密码管理](#5-gpasswd组密码管理)
6. [newgrp临时切换组](#6-newgrp临时切换组)
7. [groups查看组成员](#7-groups查看组成员)
8. [vigr安全编辑组文件](#8-vigr安全编辑组文件)
9. [组成员批量管理](#9-组成员批量管理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🏗️ 用户组管理基础概念


### 1.1 什么是用户组


**用户组简单理解**：就像现实中的**部门**或**团队**，把有相同工作需要的用户归类管理。

```
现实中的组织：              Linux中的用户组：
    公司                       系统
   /    \                     /    \
财务部  技术部             finance  tech
 |      |                    |       |
张三   李四                user1   user2
王五   赵六                user3   user4
```

**为什么需要用户组？**
- 🎯 **批量权限管理**：不用一个个给用户设权限，给整个组设置就行
- 🔒 **安全隔离**：不同组的用户访问不同的文件和资源
- 📊 **便于管理**：新员工加入，直接加到对应组即可

### 1.2 组的基本类型


**主要组（Primary Group）**：
- 每个用户**必须有且只有一个**主要组
- 用户创建文件时，文件默认属于这个组
- 就像你的**主要部门**，工资从这里发

**附属组（Secondary Group）**：
- 用户可以**属于多个**附属组
- 提供额外的权限和访问能力
- 就像**兼职部门**，有时候需要跨部门协作

### 1.3 组信息存储位置


```
重要文件位置：
┌─────────────────┐
│   /etc/group    │ ← 组的基本信息
├─────────────────┤
│  /etc/gshadow   │ ← 组的密码信息
├─────────────────┤
│   /etc/passwd   │ ← 用户的主要组信息
└─────────────────┘
```

**`/etc/group`文件格式解读**：
```bash
# 格式：组名:密码占位符:组ID:成员列表
root:x:0:
users:x:100:alice,bob
developers:x:1001:john,mary,tom
```

**字段含义**：
- `组名`：组的名称，如developers
- `x`：密码占位符（实际密码在/etc/gshadow）
- `组ID(GID)`：组的数字标识，如1001
- `成员列表`：属于这个组的用户，用逗号分隔

---

## 2. ➕ groupadd创建用户组


### 2.1 基本创建语法


**最简单的创建方式**：
```bash
# 创建一个基本的用户组
sudo groupadd developers
```

这就像在公司里**新建一个部门**，系统会：
- 自动分配一个组ID（GID）
- 在`/etc/group`文件中添加记录
- 创建组目录（如果配置了的话）

### 2.2 高级创建选项


| 选项 | **作用** | **实际应用** | **注意事项** |
|-----|---------|-------------|-------------|
| `-g GID` | **指定组ID** | `sudo groupadd -g 2000 finance` | `GID要唯一，建议1000以上` |
| `-r` | **创建系统组** | `sudo groupadd -r webserver` | `系统组ID通常小于1000` |
| `-f` | **强制创建** | `sudo groupadd -f existing_group` | `组已存在时不报错` |
| `-K` | **覆盖默认值** | `sudo groupadd -K GID_MIN=2000 mygroup` | `临时修改默认配置` |

### 2.3 创建实例详解


**场景1：为Web项目创建开发组**
```bash
# 创建Web开发组，指定GID为3000
sudo groupadd -g 3000 webdev

# 验证创建结果
grep webdev /etc/group
# 输出：webdev:x:3000:
```

**场景2：创建系统服务组**
```bash
# 创建nginx服务组（系统组）
sudo groupadd -r nginx

# 查看创建的系统组
grep nginx /etc/group
# 输出：nginx:x:995:  (系统组ID通常较小)
```

### 2.4 创建后的验证


```bash
# 方法1：查看组文件
tail -n 5 /etc/group

# 方法2：使用getent命令
getent group developers

# 方法3：查看所有组
cut -d: -f1 /etc/group | sort
```

---

## 3. 🔧 groupmod修改组属性


### 3.1 修改组名称


**为什么要改组名？**
- 部门重组：开发部改名为技术部
- 规范统一：统一命名风格
- 业务调整：项目名称变更

```bash
# 将developers组改名为tech_team
sudo groupmod -n tech_team developers

# 验证修改结果
grep tech_team /etc/group
# 输出：tech_team:x:1001:john,mary
```

> **⚠️ 重要提醒**：改组名不会自动更新用户的主要组，需要单独修改用户配置

### 3.2 修改组ID


**什么时候需要改GID？**
- 解决ID冲突
- 统一不同系统的组ID
- 满足特定的权限需求

```bash
# 将finance组的GID改为2500
sudo groupmod -g 2500 finance

# 同时查找并更新文件所有权
sudo find / -group 旧GID -exec chgrp finance {} \;
```

### 3.3 修改选项总览


| 选项 | **功能说明** | **使用示例** | **应用场景** |
|-----|-------------|-------------|-------------|
| `-n 新名` | **修改组名** | `groupmod -n newname oldname` | `部门重组、规范命名` |
| `-g 新GID` | **修改组ID** | `groupmod -g 2000 finance` | `解决ID冲突、系统迁移` |
| `-o` | **允许重复GID** | `groupmod -o -g 1000 backup` | `特殊需求，不推荐` |

### 3.4 批量修改实例


**场景：标准化所有项目组的命名**
```bash
# 修改前的组名不规范
# dev, develop, developers -> 统一为 proj_dev

sudo groupmod -n proj_frontend frontend_dev
sudo groupmod -n proj_backend backend_dev  
sudo groupmod -n proj_database db_team

# 验证修改结果
grep "proj_" /etc/group
```

---

## 4. ❌ groupdel删除用户组


### 4.1 基本删除操作


**什么时候删除组？**
- 项目结束，不再需要
- 组织架构调整
- 清理无用的测试组

```bash
# 删除不再需要的测试组
sudo groupdel test_group
```

### 4.2 删除的限制条件


**不能删除的情况**：

```
无法删除的组类型：
┌─────────────────┐
│  某用户的主要组  │ ← 必须先删除用户或改变其主要组
├─────────────────┤
│   系统关键组    │ ← 如root, wheel等系统组
├─────────────────┤
│   正在使用的组  │ ← 有进程正在以此组身份运行
└─────────────────┘
```

**删除前的检查**：
```bash
# 检查哪些用户以此组为主要组
grep ":1001:" /etc/passwd

# 检查哪些用户属于此组（附属组）
grep "test_group" /etc/group

# 检查是否有进程在使用
ps -eo pid,user,group | grep test_group
```

### 4.3 安全删除流程


**推荐的删除步骤**：

1. **检查组的使用情况**
```bash
# 查看组成员
getent group target_group

# 查看以此组为主要组的用户
awk -F: '$4==组GID {print $1}' /etc/passwd
```

2. **处理相关用户**
```bash
# 将用户移出附属组
sudo gpasswd -d username target_group

# 如果是主要组，需要先改变用户的主要组
sudo usermod -g new_primary_group username
```

3. **执行删除**
```bash
sudo groupdel target_group
```

### 4.4 批量清理示例


```bash
# 删除所有测试相关的组
for group in test_dev test_qa test_staging; do
    echo "正在删除组: $group"
    sudo groupdel $group 2>/dev/null || echo "删除 $group 失败"
done
```

---

## 5. 🔑 gpasswd组密码管理


### 5.1 gpasswd的核心作用


**gpasswd是什么？**
把它理解为**组的管理员工具**，就像部门主管可以决定谁加入或离开部门。

**主要功能**：
- 🔐 设置组密码（让用户可以临时加入组）
- 👥 管理组成员（添加、删除用户）
- 👑 指定组管理员（让普通用户也能管理组）
- 🚫 限制组访问（设置组的访问策略）

### 5.2 组成员管理


**添加用户到组**：
```bash
# 将alice添加到developers组
sudo gpasswd -a alice developers

# 批量添加多个用户
sudo gpasswd -M alice,bob,charlie developers
```

**从组中删除用户**：
```bash
# 将bob从developers组中移除
sudo gpasswd -d bob developers

# 清空整个组（移除所有成员）
sudo gpasswd -M "" developers
```

### 5.3 组管理员设置


**为什么需要组管理员？**
- 分权管理：不是所有管理都需要root权限
- 责任明确：让熟悉业务的人管理对应的组
- 提高效率：减少等待系统管理员的时间

```bash
# 设置alice为developers组的管理员
sudo gpasswd -A alice developers

# 设置多个管理员
sudo gpasswd -A alice,bob developers

# 组管理员可以做什么？
# - 添加/删除组成员
# - 修改组密码
# - 但不能删除组本身
```

### 5.4 组密码设置


**组密码的实际用途**：
```bash
# 为组设置密码
sudo gpasswd developers
# 系统会提示输入新密码

# 删除组密码
sudo gpasswd -r developers
```

**使用场景**：
- 临时访问：外部合作伙伴需要临时访问项目文件
- 应急情况：某个用户需要临时获得额外权限
- 培训环境：学员可以自己加入练习组

### 5.5 gpasswd命令参数详解


| 参数 | **功能** | **示例** | **使用场景** |
|-----|---------|---------|-------------|
| `-a user` | **添加用户到组** | `gpasswd -a john devs` | `新员工入职` |
| `-d user` | **从组中删除用户** | `gpasswd -d john devs` | `员工离职或调岗` |
| `-A admin` | **设置组管理员** | `gpasswd -A alice devs` | `委派管理权限` |
| `-M users` | **批量设置成员** | `gpasswd -M a,b,c devs` | `项目组重组` |
| `-r` | **删除组密码** | `gpasswd -r devs` | `取消临时访问` |

---

## 6. 🔄 newgrp临时切换组


### 6.1 newgrp的基本概念


**newgrp是做什么的？**
想象你在公司里**身兼多职**，上午在财务部工作，下午去技术部帮忙。`newgrp`就是让你**临时切换身份**的工具。

**实际效果**：
- 临时改变你的**主要组**
- 新创建的文件会属于新的组
- 获得新组的权限和访问能力
- 就像**戴上了不同部门的工作证**

### 6.2 基本使用方法


**切换到已属于的组**：
```bash
# 查看当前用户属于哪些组
groups
# 输出：alice wheel developers finance

# 切换到developers组
newgrp developers

# 验证切换结果
id
# 输出显示primary group已变为developers
```

**切换到不属于的组（需要密码）**：
```bash
# 尝试切换到marketing组（如果不是成员）
newgrp marketing
# 系统提示输入组密码
```

### 6.3 实际使用场景


**场景1：开发人员需要访问测试文件**
```bash
# 当前身份
$ id
uid=1001(alice) gid=1001(alice) groups=1001(alice),1002(developers)

# 切换到developers组
$ newgrp developers

# 现在创建的文件属于developers组
$ touch test.txt
$ ls -l test.txt
-rw-r--r-- 1 alice developers 0 Sep 19 15:30 test.txt
```

**场景2：临时获得管理权限**
```bash
# 切换到管理组
newgrp wheel

# 现在可以执行需要wheel组权限的操作
# 比如某些系统配置文件的修改
```

### 6.4 退出新组环境


```bash
# 方法1：使用exit命令
exit

# 方法2：使用Ctrl+D快捷键

# 方法3：切换回原来的组
newgrp alice  # 回到用户的默认主要组
```

### 6.5 newgrp的限制和注意事项


> **⚠️ 重要提醒**：
> - newgrp会启动一个新的shell，**不是简单的权限切换**
> - 退出时需要用`exit`，否则会一直在新的shell里
> - 如果组有密码，需要知道密码才能切换
> - 只影响**新创建的文件**，不影响已存在的文件

---

## 7. 👥 groups查看组成员


### 7.1 groups命令基本用法


**groups命令的作用**：
就像查看某个员工**在哪些部门任职**，告诉你用户属于哪些组。

**基本语法**：
```bash
# 查看当前用户的组
groups

# 查看指定用户的组
groups username

# 查看多个用户的组
groups alice bob charlie
```

### 7.2 输出结果解读


```bash
$ groups alice
alice : alice wheel developers finance
```

**输出解读**：
- `alice`：用户名
- `alice`：**主要组**（第一个显示的组）
- `wheel developers finance`：**附属组**

**理解方式**：
```
alice用户的身份：
主要身份 → alice组（默认组）
兼职身份 → wheel组（管理员权限）
         → developers组（开发权限）  
         → finance组（财务访问权限）
```

### 7.3 与相关命令的对比


| 命令 | **显示内容** | **适用场景** | **输出格式** |
|-----|-------------|-------------|-------------|
| `groups` | **用户所属的所有组** | `快速查看组成员关系` | `简洁的组名列表` |
| `id` | **用户和组的ID及名称** | `详细的身份信息` | `完整的UID/GID信息` |
| `getent group` | **组的所有成员** | `查看组内有哪些用户` | `组文件格式` |

### 7.4 实际应用示例


**场景1：检查用户权限**
```bash
# 用户报告无法访问某个文件，检查其组权限
$ ls -l /var/www/html/
drwxrwx--- 2 root developers 4096 Sep 19 15:30 project/

$ groups alice
alice : alice wheel developers
# alice属于developers组，应该有访问权限
```

**场景2：批量检查项目团队成员**
```bash
# 检查项目团队所有成员的组归属
for user in alice bob charlie; do
    echo "=== $user 的组成员关系 ==="
    groups $user
    echo
done
```

### 7.5 查看组的所有成员


**方法1：使用getent命令**
```bash
# 查看developers组的所有成员
getent group developers
# 输出：developers:x:1001:alice,bob,charlie
```

**方法2：解析/etc/group文件**
```bash
# 查找特定组的成员
grep "^developers:" /etc/group | cut -d: -f4
# 输出：alice,bob,charlie

# 更友好的显示方式
echo "developers组成员："
grep "^developers:" /etc/group | cut -d: -f4 | tr ',' '\n'
```

---

## 8. ✏️ vigr安全编辑组文件


### 8.1 为什么需要vigr


**直接编辑的风险**：
想象一下，如果多个管理员同时修改员工花名册，可能出现：
- 📝 **同时修改冲突**：两人同时改，后保存的覆盖前面的
- 🔒 **文件锁定问题**：一个人在改时，文件被锁定
- ❌ **语法错误**：手动编辑可能写错格式，导致系统异常

**vigr的解决方案**：
```
vigr的安全机制：
┌─────────────────────┐
│   文件锁定机制      │ ← 确保只有一个人在编辑
├─────────────────────┤
│   语法检查功能      │ ← 保存前检查格式正确性
├─────────────────────┤
│   备份恢复机制      │ ← 自动备份，出错可恢复
├─────────────────────┤
│   原子操作更新      │ ← 要么全部成功，要么全部回滚
└─────────────────────┘
```

### 8.2 vigr的基本使用


**编辑组文件**：
```bash
# 编辑 /etc/group 文件
sudo vigr

# 编辑 /etc/gshadow 文件（组密码文件）
sudo vigr -s
```

**编辑过程**：
1. vigr会打开默认编辑器（通常是vi或nano）
2. 你可以**安全地修改**组信息
3. 保存退出时，vigr会**检查语法**
4. 如果有错误，提示你修改；正确则更新文件

### 8.3 /etc/group文件格式详解


**标准格式**：
```bash
组名:密码占位符:组ID:成员列表
```

**实际示例**：
```bash
# 编辑前的组文件内容
developers:x:1001:alice,bob
finance:x:1002:charlie
marketing:x:1003:

# 可以进行的操作：
# 1. 添加新组
sales:x:1004:david,eve

# 2. 修改成员列表
developers:x:1001:alice,bob,frank

# 3. 修改组名（需要同步更新其他地方）
dev_team:x:1001:alice,bob,frank
```

### 8.4 常见编辑任务


**任务1：批量添加用户到组**
```bash
# 原来：
developers:x:1001:alice,bob

# 添加新成员后：
developers:x:1001:alice,bob,charlie,david,eve
```

**任务2：重组项目团队**
```bash
# 创建新的项目组
project_alpha:x:2001:alice,bob
project_beta:x:2002:charlie,david
project_gamma:x:2003:eve,frank
```

**任务3：清理无用组**
```bash
# 删除不再需要的测试组
# 直接删除对应行即可
# test_group:x:9999:  <- 删除这一行
```

### 8.5 vigr的优势对比


| 编辑方式 | **安全性** | **便利性** | **错误风险** | **推荐度** |
|---------|-----------|-----------|-------------|-----------|
| `vigr` | **🟢 高** | `🟡 中等` | `🟢 低` | `⭐⭐⭐⭐⭐ 强烈推荐` |
| `直接vi编辑` | **🔴 低** | `🟢 高` | `🔴 高` | `⭐⭐ 不推荐` |
| `命令行修改` | **🟡 中等** | `🔴 低` | `🟡 中等` | `⭐⭐⭐ 适合自动化` |

---

## 9. 📊 组成员批量管理


### 9.1 批量管理的应用场景


**什么时候需要批量管理？**
- 🏢 **新项目启动**：需要快速组建团队
- 📋 **组织架构调整**：部门合并或拆分  
- 🎓 **培训班管理**：批量添加学员到练习组
- 🔄 **系统迁移**：从旧系统迁移用户组关系

### 9.2 批量添加用户到组


**方法1：使用gpasswd批量设置**
```bash
# 一次性设置整个组的成员列表
sudo gpasswd -M alice,bob,charlie,david developers

# 注意：这会覆盖原有成员，不是追加！
```

**方法2：循环添加用户**
```bash
# 批量添加用户到组（追加方式）
users="alice bob charlie david eve"
for user in $users; do
    echo "添加用户 $user 到 developers 组"
    sudo gpasswd -a $user developers
done
```

**方法3：从文件读取用户列表**
```bash
# 创建用户列表文件
cat > team_members.txt << EOF
alice
bob  
charlie
david
eve
EOF

# 批量添加
while read username; do
    sudo gpasswd -a $username developers
    echo "已添加用户：$username"
done < team_members.txt
```

### 9.3 批量创建项目组


**实际场景：为多个项目创建开发组**
```bash
#!/bin/bash
# 项目组批量创建脚本

# 项目列表
projects="frontend backend database mobile"
base_gid=3000

for project in $projects; do
    group_name="proj_${project}"
    gid=$((base_gid++))
    
    echo "创建项目组：$group_name (GID: $gid)"
    sudo groupadd -g $gid $group_name
    
    # 设置项目负责人为组管理员
    case $project in
        "frontend") sudo gpasswd -A alice $group_name ;;
        "backend")  sudo gpasswd -A bob $group_name ;;
        "database") sudo gpasswd -A charlie $group_name ;;
        "mobile")   sudo gpasswd -A david $group_name ;;
    esac
done
```

### 9.4 基于CSV文件的批量管理


**准备CSV格式的数据文件**：
```csv
username,primary_group,secondary_groups
alice,developers,"wheel,finance"
bob,developers,"wheel,database"  
charlie,finance,"developers,audit"
david,marketing,"developers,sales"
```

**解析CSV并批量处理**：
```bash
#!/bin/bash
# 读取CSV文件并批量设置用户组

while IFS=',' read -r username primary_group secondary_groups; do
    # 跳过标题行
    [[ "$username" == "username" ]] && continue
    
    echo "处理用户：$username"
    
    # 设置主要组
    sudo usermod -g $primary_group $username
    
    # 清除并重新设置附属组
    # 移除引号并替换空格为逗号
    clean_groups=$(echo $secondary_groups | tr -d '"' | tr ' ' ',')
    sudo usermod -G $clean_groups $username
    
    echo "用户 $username 已设置完成"
done < users.csv
```

### 9.5 组权限批量同步


**场景：将开发组的权限同步给测试组**
```bash
#!/bin/bash
# 将一个组的文件权限复制给另一个组

source_group="developers"
target_group="testers"
project_dir="/opt/projects"

echo "同步 $source_group 组的权限到 $target_group 组"

# 查找所有属于源组的文件和目录
find $project_dir -group $source_group -exec chgrp $target_group {} \;

echo "权限同步完成"

# 验证结果
echo "验证同步结果："
find $project_dir -group $target_group | head -5
```

### 9.6 批量管理的最佳实践


**📋 批量操作前的检查清单**：

- [ ] **备份当前配置**
```bash
# 备份组文件
sudo cp /etc/group /etc/group.backup.$(date +%Y%m%d)
sudo cp /etc/gshadow /etc/gshadow.backup.$(date +%Y%m%d)
```

- [ ] **验证用户存在**
```bash
# 检查用户是否存在的函数
check_user_exists() {
    if ! id "$1" &>/dev/null; then
        echo "错误：用户 $1 不存在"
        return 1
    fi
}
```

- [ ] **测试小规模操作**
```bash
# 先在几个用户上测试脚本
test_users="testuser1 testuser2"
# 确认无误后再批量执行
```

- [ ] **记录操作日志**
```bash
# 记录所有操作到日志文件
exec > >(tee -a /var/log/group_management.log)
exec 2>&1
echo "$(date): 开始批量组管理操作"
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 用户组本质：批量权限管理的工具，类似现实中的部门概念
🔸 组的类型：主要组（每用户一个）+ 附属组（每用户可多个）
🔸 组信息存储：/etc/group（基本信息）+ /etc/gshadow（密码信息）
🔸 核心命令：groupadd（创建）、groupmod（修改）、groupdel（删除）
🔸 成员管理：gpasswd（添加/删除成员）、groups（查看归属）
🔸 安全编辑：vigr（安全修改组文件）、批量管理（提高效率）
```

### 10.2 关键理解要点


**🔹 组管理的核心思维**
```
个人管理 → 部门管理：
• 不再单独给每个用户设权限
• 通过组来批量管理权限
• 新用户加入组即可获得对应权限
• 类似现实中的部门职责分工
```

**🔹 主要组vs附属组的区别**
```
主要组：
• 每个用户有且只有一个
• 用户创建文件时的默认组
• 相当于用户的"主要工作部门"

附属组：  
• 每个用户可以有多个
• 提供额外的访问权限
• 相当于"兼职"或"协作"部门
```

**🔹 安全操作的重要性**
```
为什么要用vigr而不直接编辑：
• 防止多人同时编辑冲突
• 自动语法检查避免格式错误
• 文件锁定机制保证数据一致性
• 类似数据库的事务操作概念
```

### 10.3 实际应用指导


**🎯 常见应用场景**
- **Web开发团队**：创建前端、后端、测试等不同组
- **系统管理**：wheel组管理员、service组服务账号
- **文件共享**：项目组成员共享特定目录的读写权限
- **安全隔离**：不同业务线用户访问不同的资源

**🔧 最佳实践建议**
```
组名命名规范：
• 使用有意义的名称：proj_frontend 而不是 group1
• 保持命名一致性：统一前缀或后缀
• 避免特殊字符：使用字母、数字、下划线

GID分配策略：
• 系统组：< 1000
• 普通组：>= 1000
• 项目组：可使用特定范围如3000-3999

权限管理原则：
• 最小权限原则：只给必要的权限
• 定期审查：清理无用的组和权限
• 文档记录：记录组的用途和成员变化
```

### 10.4 故障排除指南


**🔍 常见问题及解决方案**
```bash
# 问题1：无法删除组
# 原因：有用户仍以此组为主要组
# 解决：先修改用户主要组，再删除
sudo usermod -g new_group username
sudo groupdel old_group

# 问题2：用户加入组后仍无权限
# 原因：需要重新登录或使用newgrp
# 解决：用户重新登录或执行newgrp
newgrp groupname

# 问题3：批量操作部分失败
# 原因：某些用户不存在或已在组中
# 解决：添加错误检查和日志记录
```

**⚠️ 安全注意事项**
```
操作前务必：
• 备份 /etc/group 和 /etc/gshadow 文件
• 在测试环境先验证脚本
• 记录操作日志便于追踪
• 避免在生产环境直接编辑组文件

权限设计原则：
• 遵循最小权限原则
• 定期审查组成员关系
• 及时清理离职用户的组权限
• 敏感组（如wheel）谨慎添加成员
```

### 10.5 命令速查表


| 操作类型 | **命令** | **示例** | **说明** |
|---------|---------|---------|---------|
| **创建组** | `groupadd` | `groupadd -g 3000 developers` | `创建指定GID的组` |
| **修改组** | `groupmod` | `groupmod -n newname oldname` | `修改组名或GID` |
| **删除组** | `groupdel` | `groupdel testgroup` | `删除不再使用的组` |
| **成员管理** | `gpasswd` | `gpasswd -a user group` | `添加用户到组` |
| **切换组** | `newgrp` | `newgrp developers` | `临时切换主要组` |
| **查看组** | `groups` | `groups username` | `查看用户所属组` |
| **安全编辑** | `vigr` | `sudo vigr` | `安全编辑组文件` |

**核心记忆口诀**：
- 组如部门管权限，批量管理效率高
- 主要组唯一附属多，权限叠加要记牢  
- 创建修改删除组，gpasswd管成员好
- vigr编辑最安全，批量操作要谨慎