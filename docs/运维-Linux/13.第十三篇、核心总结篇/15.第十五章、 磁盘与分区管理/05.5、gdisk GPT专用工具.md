---
title: 5、gdisk GPT专用工具
---
## 📚 目录

1. [gdisk工具基本概念](#1-gdisk工具基本概念)
2. [GPT分区表结构理解](#2-GPT分区表结构理解)
3. [gdisk基本操作命令](#3-gdisk基本操作命令)
4. [GUID分区类型代码](#4-GUID分区类型代码)
5. [GPT分区表保护与恢复](#5-GPT分区表保护与恢复)
6. [sgdisk脚本化操作](#6-sgdisk脚本化操作)
7. [实际应用场景](#7-实际应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💿 gdisk工具基本概念


### 1.1 什么是gdisk


**🔸 简单理解**
```
gdisk = GPT专用的磁盘分区工具
就像fdisk是给MBR分区表用的，gdisk是专门给GPT分区表用的

通俗比喻：
如果把硬盘比作一本书
- MBR就像老式的目录页（只能记录4个大章节）
- GPT就像现代的详细目录（可以记录128个章节，还有备份）
- gdisk就是专门编辑GPT这种详细目录的工具
```

**🔸 为什么需要专用工具**
- **容量限制**：MBR最大支持2TB硬盘，GPT支持更大容量
- **分区数量**：MBR最多4个主分区，GPT可以128个分区
- **数据安全**：GPT有备份分区表，更可靠
- **现代需求**：新系统（UEFI）都推荐使用GPT

### 1.2 GPT vs MBR 核心区别


| 特性对比 | **MBR分区表** | **GPT分区表** | **实际意义** |
|---------|-------------|-------------|-------------|
| 🗂️ **分区数量** | `最多4个主分区` | `最多128个分区` | `GPT不用区分主分区扩展分区` |
| 💾 **硬盘容量** | `最大2TB` | `理论上无限制` | `大硬盘必须用GPT` |
| 🔒 **数据安全** | `单点故障` | `有备份分区表` | `GPT分区表坏了还能恢复` |
| ⚡ **启动方式** | `传统BIOS启动` | `UEFI启动` | `新电脑都用UEFI+GPT` |
| 🆔 **分区标识** | `简单类型码` | `GUID唯一标识` | `GPT每个分区都有唯一ID` |

### 1.3 保护性MBR概念


**🔸 什么是保护性MBR**
```
保护性MBR：GPT硬盘上的一个"保护层"

工作原理：
┌─────────────────────────────────────┐
│  保护性MBR（兼容层）                 │  ← 让老系统认为这是个MBR盘
├─────────────────────────────────────┤
│  GPT头（主分区表）                   │  ← 真正的分区信息
├─────────────────────────────────────┤
│  分区1 | 分区2 | 分区3 | ...        │  ← 实际的数据分区
├─────────────────────────────────────┤
│  GPT备份头（备份分区表）              │  ← 分区表的备份
└─────────────────────────────────────┘

作用：防止不支持GPT的老工具误删分区表
```

---

## 2. 🏗️ GPT分区表结构理解


### 2.1 GPT分区表的完整结构


**🔸 从头到尾的布局**
```
GPT硬盘完整结构图：

扇区0     ┌─ 保护性MBR ─┐        保护老系统
扇区1     ├─ GPT头部   ─┤        分区表位置信息  
扇区2-33  ├─ 分区表项  ─┤        128个分区的详细信息
扇区34... ├─ 数据区域  ─┤        实际存储文件的地方
...       │   分区1     │        用户数据
...       │   分区2     │        用户数据  
...       │   分区3     │        用户数据
最后33扇区├─ 备份分区表─┤        分区表的完整备份
最后1扇区 └─ 备份GPT头─┘        分区表头的备份

关键理解：GPT把重要信息放在开头和结尾，双重保险！
```

### 2.2 分区唯一标识符系统


**🔸 GUID标识符的含义**
```
每个GPT分区都有两个重要ID：

分区类型GUID：
- 说明这个分区是做什么用的
- 比如：Windows系统分区有专门的GUID
- 比如：Linux根分区有专门的GUID

分区唯一GUID：  
- 这个分区在全世界的唯一身份证号
- 即使分区类型相同，这个ID也不会重复
- 用于精确识别特定分区

生活类比：
类型GUID = 职业（程序员、医生、教师）
唯一GUID = 身份证号（每个人都不同）
```

### 2.3 GPT分区表验证机制


**🔸 数据完整性保护**
```
GPT的三重保护机制：

第一重：CRC校验码
- 每个分区表都有校验码
- 发现数据损坏立即提醒

第二重：备份分区表
- 主分区表在硬盘开头
- 备份分区表在硬盘结尾
- 一个坏了用另一个恢复

第三重：版本号管理
- 每次修改分区表，版本号+1
- 确保使用最新的分区信息

这就像重要文件要存三份：本地一份、网盘一份、U盘一份
```

---

## 3. ⚙️ gdisk基本操作命令


### 3.1 启动gdisk和基本界面


**🔸 启动gdisk**
```bash
# 对指定硬盘进行GPT分区操作
sudo gdisk /dev/sda

# 启动后看到的界面
GPT fdisk (gdisk) version 1.0.8
Partition table scan:
  MBR: protective
  BSD: not present  
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help):
```

**🔸 获取帮助信息**
```bash
# 在gdisk命令行输入?查看所有命令
Command (? for help): ?

常用命令分类：
查看类：p(打印分区表) i(分区详情) 
操作类：n(新建分区) d(删除分区) t(改变类型)
保存类：w(写入保存) q(退出不保存)
恢复类：r(恢复菜单) v(验证分区表)
```

### 3.2 查看分区信息


**🔸 打印当前分区表**
```bash
Command (? for help): p

Disk /dev/sda: 125829120 sectors, 60.0 GiB
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): A1B2C3D4-E5F6-1234-5678-9ABCDEF01234
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 125829086
Partitions will be aligned on 2048-sector boundaries
Total free space is 2048 sectors (1.0 MiB)

Number  Start      End        Size       Code  Name
   1    2048       1050623    512.0 MiB  EF00  EFI System
   2    1050624    125829086  59.5 GiB   8300  Linux filesystem
```

**🔸 查看详细分区信息**
```bash
Command (? for help): i
Partition number (1-128): 1

Partition GUID code: C12A7328-F81F-11D2-BA4B-00A0C93EC93B (EFI system)
Partition unique GUID: 550E8400-E29B-41D4-A716-446655440000
First sector: 2048 (at 1.0 MiB)
Last sector: 1050623 (at 513.0 MiB) 
Partition size: 1048576 sectors (512.0 MiB)
Attribute flags: 0000000000000000
Partition name: 'EFI System'
```

### 3.3 创建和删除分区


**🔸 创建新分区**
```bash
Command (? for help): n
Partition number (1-128, default 3): 3
First sector (34-125829086, default = 125829087) or {+-}size{KMGTP}: 
Last sector (125829087-125829086, default = 125829086) or {+-}size{KMGTP}: +10G
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300): 8300
Changed type of partition to 'Linux filesystem'
```

**🔸 删除分区**
```bash
Command (? for help): d
Partition number (1-3): 3

# 删除后分区3就消失了，空间变成可用空间
```

### 3.4 保存和退出操作


> ⚠️ **重要提醒**：所有修改只有执行`w`命令后才真正写入硬盘

```bash
# 写入所有更改并退出
Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sda.
The operation has completed successfully.

# 退出不保存任何更改  
Command (? for help): q
```

---

## 4. 🏷️ GUID分区类型代码


### 4.1 常用分区类型代码


**🔸 Linux系统常用类型**

| 代码 | **分区类型** | **用途说明** | **实际应用** |
|-----|-------------|-------------|-------------|
| `8300` | **Linux文件系统** | `存放Linux系统和用户数据` | `根分区、home分区` |
| `8200` | **Linux swap** | `Linux虚拟内存交换空间` | `当内存不够时使用硬盘` |
| `8e00` | **Linux LVM** | `逻辑卷管理器分区` | `动态调整分区大小` |
| `fd00` | **Linux RAID** | `软件RAID阵列分区` | `多硬盘组成阵列` |

**🔸 Windows系统常用类型**

| 代码 | **分区类型** | **用途说明** | **实际应用** |
|-----|-------------|-------------|-------------|
| `0700` | **Microsoft基本数据** | `Windows系统和数据分区` | `C盘、D盘等` |
| `2700` | **Windows RE** | `Windows恢复环境` | `系统恢复工具` |
| `0c01` | **Microsoft保留** | `Windows系统保留分区` | `启动管理器等` |

**🔸 通用系统类型**

| 代码 | **分区类型** | **用途说明** | **实际应用** |
|-----|-------------|-------------|-------------|
| `EF00` | **EFI系统分区** | `UEFI启动引导程序` | `所有现代系统必需` |
| `EF02` | **BIOS启动分区** | `GRUB引导程序` | `传统BIOS兼容` |

### 4.2 修改分区类型


**🔸 更改分区类型代码**
```bash
Command (? for help): t
Partition number (1-3): 2
Current type is 'Linux filesystem' (8300)
Hex code or GUID (L to show codes, Enter = 8300): 8200
Changed type of partition to 'Linux swap'

# L命令可以列出所有可用的分区类型代码
Hex code or GUID (L to show codes, Enter = 8300): L

Type search string, or <Enter> to show all codes: linux
8200 Linux swap                        
8300 Linux filesystem                  
8301 Linux reserved                    
8302 Linux /home                       
8303 Linux x86 root (/)                
8304 Linux x86-64 root (/)             
8305 Linux ARM64 root (/)              
8306 Linux /srv                        
8307 Linux ARM32 root (/)              
```

---

## 5. 🛡️ GPT分区表保护与恢复


### 5.1 分区表验证和修复


**🔸 验证分区表完整性**
```bash
Command (? for help): v

Caution! Below are potential problems with your disk!

Problem: The secondary header's self-pointer indicates that it doesn't reside
at the end of the disk. If you've added a disk to a RAID array, use the 'e'
option on the experts' menu to adjust the secondary header's and partition
table's locations.

Identified 1 problems!
```

**🔸 进入专家模式修复**
```bash
Command (? for help): x

Expert command (? for help): ?
专家模式命令：
a - 设置属性标志
c - 修改分区名称  
e - 重新定位备份分区表
g - 修改磁盘GUID
i - 显示分区详细信息
l - 设置分区对齐值
m - 返回主菜单
n - 创建新的保护性MBR
p - 打印分区表
q - 退出不保存
r - 进入恢复菜单
s - 调整分区表大小
v - 验证分区表
w - 写入分区表并退出
z - 清除GPT数据结构
```

### 5.2 GPT分区表恢复操作


**🔸 从备份恢复主分区表**
```bash
Command (? for help): r

Recovery/transformation command (? for help): ?
恢复菜单命令：
b - 使用备份GPT头重建主GPT头
c - 从主GPT加载备份分区表  
d - 使用主GPT重建备份GPT
e - 从备份GPT加载主分区表
f - 从主分区表加载MBR并重建CHS
g - 转换GPT为MBR并退出
h - 创建新的混合MBR
i - 显示GPT数据完整性
l - 从MBR加载分区数据
m - 返回主菜单
o - 打印保护性MBR数据
p - 打印分区表
q - 退出不保存
t - 转换MBR为GPT并退出
v - 验证分区表
w - 写入分区表并退出
x - 进入专家菜单
```

**🔸 恢复操作示例**
```bash
# 当主分区表损坏时，从备份恢复
Recovery/transformation command (? for help): b
Warning! This will probably do weird things if you've converted an MBR to
GPT form and haven't yet saved the GPT! Proceed? (Y/N): y

# 验证恢复结果
Recovery/transformation command (? for help): v
No problems found. 128 free sectors (64.0 KiB) available in 1
segments, the largest of which is 128 (64.0 KiB) in size.
```

### 5.3 混合MBR处理


> 💡 **混合MBR概念**：同时包含MBR和GPT分区表的特殊配置，通常用于兼容性需求

**🔸 创建混合MBR**
```bash
Recovery/transformation command (? for help): h
WARNING! Hybrid MBRs are flaky and dangerous! If you decide not to use one,
just hit the Enter key at the below prompt and your MBR partition table will
be untouched.

Type from one to three GPT partition numbers, separated by spaces, to be
added to the hybrid MBR, in sequence: 1 2
Place EFI GPT (0xEE) partition first in MBR (good for GRUB)? (Y/N): Y
```

---

## 6. 🤖 sgdisk脚本化操作


### 6.1 sgdisk基本用法


**🔸 sgdisk工具简介**
```
sgdisk = 脚本版的gdisk
用途：在脚本中自动化GPT分区操作，不需要交互式输入

使用场景：
• 批量部署系统
• 自动化安装脚本
• 服务器批量配置
• 系统维护脚本
```

**🔸 基本语法格式**
```bash
# 基本语法
sgdisk [选项] 设备名

# 常用选项组合
sgdisk -p /dev/sda                    # 打印分区表
sgdisk -i 1 /dev/sda                  # 显示分区1的信息
sgdisk -n 1:2048:+512M /dev/sda       # 创建分区1，从扇区2048开始，大小512M
sgdisk -t 1:EF00 /dev/sda             # 设置分区1类型为EFI系统分区
sgdisk -c 1:"EFI System" /dev/sda     # 设置分区1名称为"EFI System"
```

### 6.2 批量分区创建脚本


**🔸 自动创建完整分区方案**
```bash
#!/bin/bash
# 自动创建标准Linux分区方案

DISK="/dev/sda"

# 清除现有分区表
sgdisk --zap-all $DISK

# 创建EFI系统分区 (512MB)
sgdisk --new=1:2048:+512M --typecode=1:EF00 --change-name=1:"EFI System" $DISK

# 创建/boot分区 (1GB)  
sgdisk --new=2:0:+1G --typecode=2:8300 --change-name=2:"Linux /boot" $DISK

# 创建swap分区 (4GB)
sgdisk --new=3:0:+4G --typecode=3:8200 --change-name=3:"Linux swap" $DISK

# 创建根分区 (剩余空间)
sgdisk --new=4:0:0 --typecode=4:8300 --change-name=4:"Linux root" $DISK

# 验证结果
sgdisk --print $DISK
```

### 6.3 分区表备份与还原


**🔸 备份GPT分区表**
```bash
# 备份分区表到文件
sgdisk --backup=partition-backup.sgdisk /dev/sda

# 显示备份文件信息
sgdisk --load-backup=partition-backup.sgdisk --print /dev/sdb
```

**🔸 还原分区表**
```bash
# 从备份文件还原分区表
sgdisk --load-backup=partition-backup.sgdisk /dev/sdb

# 生成随机GUID避免冲突
sgdisk --randomize-guids /dev/sdb
```

---

## 7. 🎯 实际应用场景


### 7.1 UEFI系统安装分区


**🔸 现代Linux系统标准分区方案**
```
典型的UEFI+GPT分区布局：

┌─────────────────────────────────────────────────────┐
│ /dev/sda1  │ 512MB  │ EF00 │ EFI系统分区          │
├─────────────────────────────────────────────────────┤  
│ /dev/sda2  │ 1GB    │ 8300 │ /boot (内核和引导)    │
├─────────────────────────────────────────────────────┤
│ /dev/sda3  │ 4GB    │ 8200 │ swap (虚拟内存)      │
├─────────────────────────────────────────────────────┤
│ /dev/sda4  │ 20GB   │ 8300 │ / (根文件系统)       │
├─────────────────────────────────────────────────────┤
│ /dev/sda5  │ 剩余   │ 8300 │ /home (用户数据)     │
└─────────────────────────────────────────────────────┘

为什么这样分区：
• EFI分区：UEFI固件读取启动程序
• /boot分区：存放内核文件，单独分区便于管理
• swap分区：虚拟内存，大小通常为物理内存的1-2倍
• 根分区：系统文件，20-40GB足够
• /home分区：用户数据，独立分区便于系统重装
```

### 7.2 服务器大容量存储


**🔸 企业级存储分区策略**
```bash
# 大容量服务器硬盘分区示例
# 假设有一块8TB的企业级硬盘

# 创建基本系统分区
sgdisk --new=1:2048:+512M --typecode=1:EF00 --change-name=1:"EFI System" /dev/sda
sgdisk --new=2:0:+1G --typecode=2:8300 --change-name=2:"Boot" /dev/sda  
sgdisk --new=3:0:+50G --typecode=3:8300 --change-name=3:"Root" /dev/sda
sgdisk --new=4:0:+32G --typecode=4:8200 --change-name=4:"Swap" /dev/sda

# 创建数据存储分区
sgdisk --new=5:0:+2T --typecode=5:8300 --change-name=5:"Database" /dev/sda
sgdisk --new=6:0:+2T --typecode=6:8300 --change-name=6:"Logs" /dev/sda
sgdisk --new=7:0:0 --typecode=7:8300 --change-name=7:"Backup" /dev/sda

优势：
✅ 系统和数据分离，便于管理
✅ 数据库独立分区，性能优化
✅ 日志独立分区，避免撑爆系统盘
✅ 备份分区，数据安全保障
```

### 7.3 双系统安装场景


**🔸 Windows + Linux 双系统分区**
```
双系统GPT分区推荐布局：

┌─────────────────────────────────────────────────────┐
│ /dev/sda1  │ 100MB  │ 0c01 │ Microsoft保留分区    │ Windows
├─────────────────────────────────────────────────────┤
│ /dev/sda2  │ 512MB  │ EF00 │ EFI系统分区          │ 共享
├─────────────────────────────────────────────────────┤  
│ /dev/sda3  │ 100GB  │ 0700 │ Windows系统盘(C:)    │ Windows
├─────────────────────────────────────────────────────┤
│ /dev/sda4  │ 200GB  │ 0700 │ Windows数据盘(D:)    │ Windows
├─────────────────────────────────────────────────────┤
│ /dev/sda5  │ 1GB    │ 8300 │ Linux /boot         │ Linux
├─────────────────────────────────────────────────────┤
│ /dev/sda6  │ 8GB    │ 8200 │ Linux swap          │ Linux
├─────────────────────────────────────────────────────┤
│ /dev/sda7  │ 50GB   │ 8300 │ Linux /             │ Linux
├─────────────────────────────────────────────────────┤
│ /dev/sda8  │ 剩余   │ 8300 │ Linux /home         │ Linux
└─────────────────────────────────────────────────────┘

关键要点：
🔸 EFI分区两个系统共享
🔸 先安装Windows再安装Linux
🔸 Linux的GRUB会管理双系统启动菜单
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 gdisk本质：专门处理GPT分区表的工具，比fdisk功能更强大
🔸 GPT优势：支持大硬盘(>2TB)、更多分区(128个)、有备份保护
🔸 保护性MBR：GPT硬盘的兼容层，防止老工具误删分区表
🔸 GUID系统：每个分区都有类型GUID和唯一GUID两个标识
🔸 备份机制：GPT在硬盘头尾都存储分区表，数据更安全
🔸 sgdisk工具：gdisk的脚本版本，用于自动化批量操作
```

### 8.2 关键理解要点


**🔹 什么时候必须用GPT**
```
强制使用GPT的情况：
✅ 硬盘容量超过2TB
✅ 需要超过4个分区  
✅ 使用UEFI启动的现代系统
✅ 需要分区表备份保护的重要数据

仍可用MBR的情况：
• 老旧系统兼容需求
• 硬盘小于2TB且分区少于4个
• 特殊嵌入式设备
```

**🔹 分区类型代码的实际意义**
```
不只是个代码，而是告诉系统：
EF00：这里存放启动程序，系统启动时要读取
8300：这是Linux文件系统，可以挂载使用  
8200：这是交换空间，内存不够时当虚拟内存用
0700：这是Windows分区，用NTFS格式化

选错类型的后果：
• 系统可能无法识别分区
• 启动程序可能找不到引导文件
• 自动挂载可能失败
```

**🔹 为什么GPT更安全**
```
传统MBR的问题：
分区表只有一份，在硬盘开头
如果这个区域损坏，整个硬盘的分区信息都丢了

GPT的解决方案：
• 主分区表在开头
• 备份分区表在结尾  
• 还有CRC校验码检测数据完整性
• 一个坏了立即用另一个恢复

就像重要文档要多备份一样！
```

### 8.3 实际应用指导


**🎯 日常使用建议**
```
新手推荐：
• 现代系统都选择GPT分区表
• 使用gdisk而不是fdisk
• 重要操作前先备份分区表
• 不确定时多用p命令查看现状

进阶操作：
• 学会使用sgdisk编写自动化脚本
• 掌握分区表验证和恢复方法
• 了解不同分区类型的具体用途
• 熟悉混合MBR的使用场景
```

**🔧 故障处理思路**
```
分区表损坏时的处理顺序：
1. 不要慌张，先用gdisk -l检查状况
2. 尝试用v命令验证分区表完整性
3. 进入恢复模式(r命令)尝试修复
4. 从备份分区表恢复主分区表
5. 实在不行就用备份文件恢复
6. 最后手段：重建分区表（数据可能丢失）

预防措施：
• 重要系统定期备份分区表
• 使用sgdisk --backup保存到文件
• 多个分区不要放在一个硬盘上
• 关键数据要有完整备份策略
```

### 8.4 学习路径建议


**🔹 初级阶段**
- 理解GPT vs MBR的区别和优势
- 掌握gdisk的基本p、n、d、t、w命令
- 能够创建标准的Linux系统分区方案
- 了解常用的分区类型代码含义

**🔹 中级阶段**  
- 掌握sgdisk脚本化操作
- 理解GPT分区表结构和验证机制
- 能处理分区表损坏的恢复操作
- 熟悉双系统和服务器分区策略

**🔹 高级阶段**
- 深入理解GUID标识符系统
- 掌握混合MBR的使用场景
- 能编写复杂的自动化分区脚本
- 具备企业级存储分区规划能力

**核心记忆口诀**：
```
GPT分区表功能强，gdisk工具来帮忙
备份机制保安全，GUID标识不会乱  
EF00启动8300数据，8200交换要记下
sgdisk脚本批量用，现代系统GPT当先
```