---
title: 2、LVM架构与核心组件
---
## 📚 目录

1. [LVM基础概念理解](#1-LVM基础概念理解)
2. [LVM架构层次分析](#2-LVM架构层次分析)
3. [核心组件详解](#3-核心组件详解)
4. [PE与LE存储机制](#4-PE与LE存储机制)
5. [元数据存储原理](#5-元数据存储原理)
6. [设备映射器工作机制](#6-设备映射器工作机制)
7. [LVM软件架构](#7-LVM软件架构)
8. [配置文件结构](#8-配置文件结构)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 LVM基础概念理解


### 1.1 什么是LVM


**LVM**（Logical Volume Manager）逻辑卷管理器，是Linux系统中一种**动态磁盘管理技术**。

> 💡 **通俗理解**：就像把多个小硬盘拼成一个大硬盘，然后可以随意分割使用，还能随时调整大小

**解决的核心问题**：
- **传统分区限制**：分区大小固定，无法灵活调整
- **存储空间浪费**：多个小分区无法合并利用
- **扩容困难**：硬盘空间不够时难以扩展

### 1.2 LVM vs 传统分区


```
传统分区方式：
硬盘 → 直接分区 → 文件系统
/dev/sda1 (固定大小) → ext4

LVM方式：
硬盘 → 物理卷 → 卷组 → 逻辑卷 → 文件系统
/dev/sda → PV → VG → LV → ext4 (可调整大小)
```

**LVM的核心优势**：
- ✅ **动态调整**：可以随时扩大或缩小分区
- ✅ **空间整合**：多个硬盘空间合并使用
- ✅ **快照备份**：支持创建逻辑卷快照
- ✅ **在线操作**：大部分操作可在系统运行时进行

---

## 2. 🏗️ LVM架构层次分析


### 2.1 LVM整体架构图


```
┌─────────────────────────────────────────┐
│            应用程序/文件系统              │ ← ext4, xfs等
├─────────────────────────────────────────┤
│         逻辑卷 (Logical Volume)         │ ← /dev/vg01/lv_data
├─────────────────────────────────────────┤
│          卷组 (Volume Group)            │ ← vg01
├─────────────────────────────────────────┤
│         物理卷 (Physical Volume)        │ ← /dev/sda1, /dev/sdb1
├─────────────────────────────────────────┤
│              物理硬盘                   │ ← /dev/sda, /dev/sdb
└─────────────────────────────────────────┘
```

### 2.2 层次关系说明


**📊 自下而上的层次**：
1. **物理硬盘**：实际的存储设备
2. **物理卷(PV)**：LVM识别的基本存储单元
3. **卷组(VG)**：多个物理卷组成的存储池
4. **逻辑卷(LV)**：从卷组中划分的逻辑分区
5. **文件系统**：格式化后的可用存储空间

> 🔧 **实际操作流程**：
> 1. 将硬盘转换为物理卷：`pvcreate /dev/sda1`
> 2. 创建卷组：`vgcreate vg01 /dev/sda1`
> 3. 创建逻辑卷：`lvcreate -L 10G -n lv_data vg01`
> 4. 格式化使用：`mkfs.ext4 /dev/vg01/lv_data`

### 2.3 数据流向示意


```
写入数据流程：
应用程序 → 文件系统 → 逻辑卷 → 卷组 → 物理卷 → 物理硬盘
    ↓         ↓        ↓       ↓       ↓        ↓
  写文件   →  inode  → LV映射 → VG分配 → PV定位 → 磁盘扇区
```

---

## 3. 🔧 核心组件详解


### 3.1 物理卷（Physical Volume - PV）


**定义**：LVM系统中最基础的存储单元，是LVM可以识别和管理的存储设备。

**🔸 物理卷的本质**：
- 就是在硬盘分区或整个硬盘上加了一个"LVM标签"
- 告诉系统这个设备可以被LVM管理
- 包含LVM元数据信息

**支持的设备类型**：
- 硬盘分区：`/dev/sda1`, `/dev/sdb2`
- 整个硬盘：`/dev/sdc`, `/dev/sdd`
- RAID设备：`/dev/md0`
- 其他块设备

**物理卷结构**：
```
┌─ 物理卷结构 ────────────────┐
│ 1. LVM标签区 (Label)        │ ← 标识这是LVM设备
│ 2. 元数据区 (Metadata)      │ ← 存储VG/LV信息
│ 3. 数据区 (Data Area)       │ ← 实际存储数据的区域
└────────────────────────────┘
```

> ⚠️ **注意**：创建物理卷会在设备上写入LVM信息，原有数据可能丢失

### 3.2 卷组（Volume Group - VG）


**定义**：由一个或多个物理卷组合而成的存储池，是逻辑卷的来源。

**🔸 卷组的作用**：
- 将多个物理卷的空间合并成一个大的存储池
- 提供统一的空间分配和管理
- 可以动态添加或移除物理卷

**卷组特性**：
- **名称唯一**：系统中卷组名称不能重复
- **动态扩展**：可以随时添加新的物理卷
- **空间共享**：所有逻辑卷共享卷组的空间

**卷组空间计算**：
```
卷组总容量 = Σ(各物理卷可用空间)

示例：
PV1: /dev/sda1 → 100GB
PV2: /dev/sdb1 → 200GB
PV3: /dev/sdc1 → 150GB
─────────────────────────
VG总容量 = 450GB
```

### 3.3 逻辑卷（Logical Volume - LV）


**定义**：从卷组中划分出来的虚拟分区，可以像传统分区一样格式化和挂载。

**🔸 逻辑卷的特点**：
- **灵活大小**：可以任意指定大小（不超过VG容量）
- **动态调整**：可以在线扩大或缩小
- **跨设备存储**：数据可能分布在多个物理设备上

**逻辑卷类型**：

| 类型 | **说明** | **特点** | **用途** |
|------|---------|---------|---------|
| **线性LV** | `数据顺序写入` | `简单，性能一般` | `普通存储` |
| **条带LV** | `数据并行写入多个PV` | `提升I/O性能` | `高性能需求` |
| **镜像LV** | `数据在多个PV上镜像` | `提供冗余保护` | `重要数据` |
| **快照LV** | `某时刻的数据副本` | `节省空间，快速备份` | `备份恢复` |

### 3.4 组件间关系图


```
实际示例关系：
    卷组 vg01 (总容量: 500GB)
         ├─ 物理卷: /dev/sda1 (200GB)
         ├─ 物理卷: /dev/sdb1 (300GB)
         │
         ├─ 逻辑卷: lv_root (50GB) → /
         ├─ 逻辑卷: lv_home (200GB) → /home
         ├─ 逻辑卷: lv_data (150GB) → /data
         └─ 剩余空间: 100GB (可继续分配)
```

---

## 4. 📦 PE与LE存储机制


### 4.1 什么是PE和LE


**物理扩展（PE - Physical Extent）**：
- 物理卷中最小的存储分配单元
- 类似于文件系统中的"块"概念
- 默认大小通常为4MB

**逻辑扩展（LE - Logical Extent）**：
- 逻辑卷中最小的存储分配单元
- 与PE一一对应
- 大小与PE相同

> 💡 **通俗理解**：PE就像仓库中的货架格子，LE就像订单中的空间需求，LVM负责把LE分配到具体的PE位置

### 4.2 PE/LE工作原理


**🔸 分配机制**：
```
物理卷空间划分：
┌─ PV1 (/dev/sda1) ────────────┐
│ PE1 │ PE2 │ PE3 │ PE4 │ PE5 │ ← 每个PE = 4MB
└──────────────────────────────┘

逻辑卷空间需求：
┌─ LV1 (lv_data) ─────┐
│ LE1 │ LE2 │ LE3 │   │ ← 需要3个LE = 12MB
└─────────────────────┘

映射关系：
LE1 → PE1 (已分配)
LE2 → PE3 (已分配)  
LE3 → PE5 (已分配)
```

### 4.3 PE大小的影响


**PE大小选择考虑**：

| PE大小 | **适用场景** | **优势** | **劣势** |
|--------|-------------|---------|---------|
| **4MB** | `一般应用` | `灵活分配，兼容性好` | `大卷组元数据较多` |
| **8MB** | `中等规模存储` | `平衡性能和灵活性` | `分配粒度稍粗` |
| **16MB+** | `大型存储系统` | `减少元数据，提升性能` | `空间分配不够灵活` |

### 4.4 PE分配策略


**LVM分配算法**：
1. **normal分配**：按顺序分配PE
2. **contiguous分配**：尽量分配连续的PE
3. **cling分配**：优先在已有PV上分配
4. **anywhere分配**：任意位置分配

```bash
# 指定分配策略示例
lvcreate -L 1G --alloc contiguous -n lv_test vg01
```

---

## 5. 💾 元数据存储原理


### 5.1 LVM元数据概念


**元数据**：描述LVM配置的关键信息，包括PV、VG、LV的所有属性和映射关系。

**🔸 元数据包含的信息**：
- 物理卷UUID、大小、PE分配状态
- 卷组名称、UUID、包含的PV列表
- 逻辑卷名称、大小、PE到LE的映射表
- LVM版本信息和创建时间

### 5.2 元数据存储位置


**多重备份机制**：
```
元数据存储位置：
┌─ 每个物理卷 ────────────────┐
│ 1. 主元数据区               │ ← 设备开头位置
│ 2. 备份元数据区             │ ← 设备末尾位置
└────────────────────────────┘

系统缓存：
/etc/lvm/backup/         ← 元数据文本备份
/etc/lvm/archive/        ← 历史变更记录
```

### 5.3 元数据格式示例


**元数据文本格式片段**：
```
# 卷组元数据示例
vg01 {
    id = "abc123-def4-5678-90ab-cdef12345678"
    status = ["WRITE", "READ"]
    extent_size = 8192        # PE大小 (4MB)
    max_lv = 0               # 最大LV数量
    max_pv = 0               # 最大PV数量
    
    physical_volumes {
        pv0 {
            id = "xyz789-abc1-2345-6789-abcdef123456"
            device = "/dev/sda1"
            status = ["ALLOCATABLE"]
            pe_start = 2048
            pe_count = 25599
        }
    }
    
    logical_volumes {
        lv_data {
            id = "lmn456-opq7-8901-2345-6789abcdef12"
            status = ["READ", "WRITE", "VISIBLE"]
            segment_count = 1
            segment1 {
                start_extent = 0
                extent_count = 2560  # 10GB
                type = "striped"
                stripe_count = 1
            }
        }
    }
}
```

### 5.4 元数据一致性保护


**保护机制**：
- **多副本存储**：每个PV都保存完整元数据
- **校验和验证**：检测元数据损坏
- **版本控制**：记录每次变更历史
- **原子操作**：确保操作的完整性

> ⚠️ **重要提醒**：元数据损坏可能导致整个LVM系统无法访问，定期备份元数据非常重要

---

## 6. 🔄 设备映射器工作机制


### 6.1 设备映射器简介


**Device Mapper（dm）**：Linux内核中的一个框架，为LVM提供底层的块设备虚拟化支持。

**🔸 设备映射器的作用**：
- 将逻辑卷映射为标准的块设备
- 处理I/O请求的转发和路由
- 支持复杂的存储拓扑（镜像、条带等）

### 6.2 设备映射器架构


```
用户空间应用
       ↓
  块设备接口 (/dev/dm-*)
       ↓
┌─ 设备映射器层 ────────────┐
│  ├─ 线性映射目标          │
│  ├─ 条带映射目标          │
│  ├─ 镜像映射目标          │
│  └─ 快照映射目标          │
└──────────┬────────────────┘
           ↓
    物理块设备层
```

### 6.3 映射表机制


**映射表**：定义逻辑地址到物理地址的转换规则。

**映射表格式**：
```
# dmsetup table 查看映射表
逻辑起始扇区 扇区数量 目标类型 目标参数

示例：
0 20971520 linear /dev/sda1 2048
# 含义：逻辑卷的0-20971520扇区映射到/dev/sda1的2048扇区开始
```

### 6.4 I/O处理流程


```
I/O请求处理流程：
应用程序
    ↓ (读写请求)
文件系统
    ↓ (块I/O)
逻辑卷 (/dev/vg01/lv_data)
    ↓ (设备映射器转换)
物理设备 (/dev/sda1, /dev/sdb1)
    ↓ (硬件I/O)
物理存储
```

**🔧 实际转换过程**：
1. 应用程序请求读取逻辑卷的第1000个块
2. 设备映射器查找映射表
3. 确定该块位于物理卷/dev/sda1的第2048个块
4. 转发I/O请求到物理设备
5. 返回读取结果

---

## 7. 🛠️ LVM软件架构


### 7.1 内核模块与用户工具


**LVM软件栈**：
```
┌─ 用户空间 ──────────────────┐
│ 管理工具: pvcreate, vgcreate │ ← 命令行工具
│ 库文件: liblvm2              │ ← LVM核心库
│ 配置: /etc/lvm/lvm.conf     │ ← 配置文件
├─────────────────────────────┤
│ 内核空间                    │
│ 设备映射器 (device-mapper)   │ ← 内核模块
│ 块设备层                    │ ← 通用块层
└─────────────────────────────┘
```

### 7.2 核心内核模块


**主要内核模块**：
- **dm_mod**：设备映射器核心模块
- **dm_linear**：线性映射支持
- **dm_stripe**：条带映射支持
- **dm_mirror**：镜像支持
- **dm_snapshot**：快照支持

### 7.3 用户空间工具分类


**管理工具分类**：

| 工具类型 | **命令** | **主要功能** |
|---------|---------|-------------|
| **PV管理** | `pvcreate, pvdisplay, pvremove` | `物理卷操作` |
| **VG管理** | `vgcreate, vgdisplay, vgextend` | `卷组操作` |
| **LV管理** | `lvcreate, lvdisplay, lvextend` | `逻辑卷操作` |
| **通用工具** | `lvs, vgs, pvs` | `状态查看` |
| **高级工具** | `dmsetup, lvm` | `底层操作和批处理` |

### 7.4 软件交互流程


```
用户命令执行流程：
lvcreate 命令
    ↓ (解析参数)
liblvm2 库
    ↓ (读取配置)
元数据操作
    ↓ (更新映射)
设备映射器
    ↓ (创建设备节点)
/dev/mapper/ 设备
```

---

## 8. ⚙️ 配置文件结构


### 8.1 主配置文件


**配置文件位置**：`/etc/lvm/lvm.conf`

**🔸 配置文件作用**：
- 控制LVM行为和默认参数
- 定义设备过滤规则
- 设置日志和调试选项
- 配置性能相关参数

### 8.2 关键配置段落


**主要配置段**：
```bash
# 全局配置
global {
    umask = 077                    # 文件权限掩码
    test = 0                       # 是否测试模式
    units = "h"                    # 容量单位显示
    si_unit_consistency = 1        # 单位一致性
    suffix = 1                     # 显示单位后缀
}

# 设备配置
devices {
    dir = "/dev"                   # 设备目录
    scan = [ "/dev" ]              # 扫描路径
    obtain_device_list_from_udev = 1  # 从udev获取设备
    
    filter = [ "a/.*/" ]           # 设备过滤规则
    # a/pattern/ = 接受匹配的设备
    # r/pattern/ = 拒绝匹配的设备
}

# 日志配置
log {
    verbose = 0                    # 详细程度
    level = 0                      # 日志级别
    file = "/var/log/lvm2.log"     # 日志文件
    syslog = 1                     # 是否使用syslog
}
```

### 8.3 设备过滤配置


**过滤规则示例**：
```bash
# 只扫描SCSI设备，排除光驱
filter = [ "a|/dev/sd.*|", "r|/dev/cdrom|" ]

# 排除特定设备
filter = [ "r|/dev/sda1|", "a|.*|" ]

# 只接受特定设备
filter = [ "a|/dev/sd[bc]|", "r|.*|" ]
```

### 8.4 性能调优配置


**常用性能配置**：
```bash
# 分配策略
allocation {
    maximise_cling = 0             # 是否优先使用已有PV
    mirror_logs_require_separate_pvs = 0  # 镜像日志是否需要独立PV
    thin_pool_metadata_require_separate_pvs = 0  # 精简池元数据是否独立
}

# 备份配置
backup {
    backup = 1                     # 是否备份元数据
    backup_dir = "/etc/lvm/backup" # 备份目录
    archive = 1                    # 是否归档
    archive_dir = "/etc/lvm/archive"  # 归档目录
    retain_min = 10                # 最少保留文件数
    retain_days = 30               # 保留天数
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 LVM层次结构：硬盘 → PV → VG → LV → 文件系统
🔸 核心组件：物理卷(PV)、卷组(VG)、逻辑卷(LV)
🔸 存储单元：物理扩展(PE)、逻辑扩展(LE)
🔸 底层机制：设备映射器、元数据管理
🔸 软件架构：内核模块 + 用户空间工具
```

### 9.2 关键理解要点


**🔹 LVM解决的核心问题**：
- **静态分区** → **动态卷管理**
- **固定大小** → **灵活调整**  
- **单设备限制** → **多设备整合**
- **扩容困难** → **在线扩展**

**🔹 各组件的关系**：
```
一个卷组 = 多个物理卷的空间池
一个逻辑卷 = 从卷组中分配的虚拟分区
PE/LE = 存储分配的最小单位
元数据 = 记录所有映射关系的"账本"
```

**🔹 设备映射器的价值**：
- 为LVM提供内核级别的支持
- 实现复杂的存储虚拟化功能
- 保证I/O操作的高效转发

### 9.3 实际应用指导


**适用场景**：
- ✅ **服务器存储管理**：需要灵活的磁盘空间分配
- ✅ **数据中心环境**：大量硬盘需要统一管理
- ✅ **虚拟化平台**：动态调整虚拟机存储
- ✅ **数据库服务器**：需要在线扩容的存储

**使用建议**：
- 🎯 **合理规划PE大小**：根据存储规模选择4MB-32MB
- 🎯 **做好元数据备份**：定期备份LVM配置信息
- 🎯 **监控存储健康**：及时发现硬盘故障和性能问题
- 🎯 **谨慎操作元数据**：避免直接修改元数据文件

### 9.4 学习路径建议


**推荐学习顺序**：
1. **理解基本概念** → PV、VG、LV的作用和关系
2. **掌握基础操作** → 创建、查看、管理LVM组件
3. **学习高级特性** → 快照、镜像、条带等功能
4. **了解底层原理** → 设备映射器、元数据机制
5. **实践故障恢复** → 元数据恢复、PV替换等

**实验环境搭建**：
- 准备多个虚拟磁盘或分区
- 从简单的线性LV开始实践
- 逐步尝试扩容、缩容操作
- 模拟故障场景进行恢复练习

**核心记忆口诀**：
- PV是基础，VG是资源池
- LV是分区，PE是积木块  
- 元数据是账本，映射器是翻译
- 灵活管理，动态调整是王道