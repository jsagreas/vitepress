---
title: 8、systemd定时器服务
---
## 📚 目录

1. [systemd定时器概述](#1-systemd定时器概述)
2. [timer单元类型详解](#2-timer单元类型详解)
3. [timer文件配置语法](#3-timer文件配置语法)
4. [OnCalendar时间表达式](#4-OnCalendar时间表达式)
5. [OnBootSec启动延迟](#5-OnBootSec启动延迟)
6. [OnUnitActiveSec间隔执行](#6-OnUnitActiveSec间隔执行)
7. [Persistent持久化选项](#7-Persistent持久化选项)
8. [timer与service关联](#8-timer与service关联)
9. [systemctl timer管理命令](#9-systemctl-timer管理命令)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🕐 systemd定时器概述


### 1.1 什么是systemd定时器


**通俗理解**：systemd定时器就像是系统的"闹钟服务"，可以在指定时间自动执行任务，是现代Linux系统替代cron的新方案。

```
传统方式 vs systemd定时器：

传统cron：
┌──────────── 分钟 (0-59)
│ ┌────────── 小时 (0-23)  
│ │ ┌──────── 日期 (1-31)
│ │ │ ┌────── 月份 (1-12)
│ │ │ │ ┌──── 星期 (0-7)
│ │ │ │ │
* * * * * /path/to/script

systemd定时器：
my-task.timer → 触发 → my-task.service
```

### 1.2 systemd定时器的优势


**相比传统cron的改进**：

| 特性对比 | **cron** | **systemd定时器** |
|---------|----------|------------------|
| 📊 **日志记录** | `简单，难调试` | `详细日志，易排查` |
| 🔧 **依赖管理** | `无依赖检查` | `完整的服务依赖` |
| ⚡ **资源管理** | `资源限制困难` | `内置资源控制` |
| 🔄 **失败处理** | `失败后停止` | `重试和恢复机制` |
| 📱 **系统集成** | `独立运行` | `完全集成到systemd` |

> 💡 **核心理念**：systemd定时器将"什么时候执行"和"执行什么任务"分离，让任务调度更加灵活和可管理。

---

## 2. 📋 timer单元类型详解


### 2.1 timer单元的基本概念


**timer单元的作用**：专门负责定时触发其他服务单元，本身不执行具体任务。

```
systemd单元类型架构：

系统单元类型：
├── .service     ← 服务单元（执行具体任务）
├── .timer       ← 定时器单元（定时触发）
├── .socket      ← 套接字单元
├── .target      ← 目标单元
└── .mount       ← 挂载单元

timer的角色：
timer单元 → 按时间规则 → 激活service单元
```

### 2.2 timer单元文件位置


**系统定时器位置**：
- `/etc/systemd/system/` - 系统管理员创建的定时器
- `/lib/systemd/system/` - 系统默认定时器
- `~/.config/systemd/user/` - 用户级定时器

### 2.3 timer单元的生命周期


```
定时器生命周期：

创建阶段：
├── 编写.timer文件
├── 编写对应的.service文件
└── 设置文件权限

激活阶段：
├── systemctl daemon-reload
├── systemctl enable xxx.timer
└── systemctl start xxx.timer

运行阶段：
├── 监控时间条件
├── 到达时间点
├── 激活对应service
└── 等待下次触发

管理阶段：
├── 查看状态和日志
├── 修改配置重载
└── 停止和禁用
```

---

## 3. 🔧 timer文件配置语法


### 3.1 timer文件基本结构


**.timer文件的标准格式**：

```ini
[Unit]
Description=我的定时任务描述
Requires=network.target

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
```

### 3.2 [Unit]段配置选项


**Unit段的核心配置**：

| 配置项 | **含义** | **示例** |
|--------|----------|----------|
| `Description` | `任务描述信息` | `Description=备份数据库` |
| `Requires` | `强依赖的服务` | `Requires=network.target` |
| `After` | `在某服务之后启动` | `After=network.target` |
| `Wants` | `希望的依赖服务` | `Wants=postgresql.service` |

> ⚠️ **注意**：timer的Unit段主要用于声明依赖关系，确保定时器在合适的系统状态下运行。

### 3.3 [Timer]段详细配置


**Timer段是核心配置部分**：

```ini
[Timer]
# 时间触发相关
OnCalendar=Mon *-*-* 02:00:00    # 每周一凌晨2点
OnBootSec=15min                   # 启动15分钟后
OnUnitActiveSec=1h               # 上次激活1小时后

# 持久化和精度
Persistent=true                   # 错过时间也要执行
AccuracySec=1min                 # 时间精度1分钟

# 随机延迟
RandomizedDelaySec=5min          # 随机延迟0-5分钟
```

### 3.4 [Install]段配置


**Install段决定定时器如何安装到系统**：

```ini
[Install]
WantedBy=timers.target    # 加入定时器目标组
```

> 💡 **说明**：`timers.target`是系统的定时器管理目标，所有定时器都应该加入这个组。

---

## 4. 📅 OnCalendar时间表达式


### 4.1 OnCalendar基本语法


**OnCalendar是最常用的时间配置方式**，语法类似cron但更强大。

```
基本格式：
DayOfWeek Year-Month-Day Hour:Minute:Second

完整示例：
Mon 2024-01-15 14:30:00    # 2024年1月15日周一14:30:00
```

### 4.2 常用时间表达式


**日常使用的时间表达式**：

```ini
# 每天定时
OnCalendar=daily           # 每天午夜00:00
OnCalendar=*-*-* 02:00:00  # 每天凌晨2点

# 每周定时
OnCalendar=weekly          # 每周一午夜
OnCalendar=Mon *-*-* 09:00:00  # 每周一上午9点

# 每月定时
OnCalendar=monthly         # 每月1号午夜
OnCalendar=*-*-01 03:00:00 # 每月1号凌晨3点

# 工作日定时
OnCalendar=Mon..Fri *-*-* 08:00:00  # 工作日早上8点
```

### 4.3 高级时间表达式


**复杂时间需求的表达方式**：

```ini
# 多个时间点
OnCalendar=*-*-* 06:00,18:00  # 每天6点和18点

# 时间范围
OnCalendar=Mon..Wed *-*-* 10:00:00  # 周一到周三10点

# 间隔表达
OnCalendar=*-*-* *:0/15:00  # 每15分钟执行一次

# 特定日期
OnCalendar=*-12-25 *:*:*    # 每年12月25日的每分每秒
```

### 4.4 时间表达式验证


**使用systemd-analyze验证时间表达式**：

```bash
# 验证时间表达式格式
systemd-analyze calendar "Mon *-*-* 02:00:00"

# 查看下次执行时间
systemd-analyze calendar "daily"
```

**验证输出示例**：
```
  Original form: Mon *-*-* 02:00:00
Normalized form: Mon *-*-* 02:00:00
    Next elapse: Mon 2024-01-22 02:00:00 CST
       (in UTC): Sun 2024-01-21 18:00:00 UTC
       From now: 1 day 11h left
```

---

## 5. ⏰ OnBootSec启动延迟


### 5.1 OnBootSec的作用


**OnBootSec用于系统启动后的延迟执行**，特别适合系统初始化任务。

```
系统启动时间线：

系统启动 → 基础服务启动 → OnBootSec计时开始
    ↓
    等待指定时间
    ↓
  触发定时任务

使用场景：
- 系统启动后的初始化检查
- 需要等待网络就绪的任务  
- 数据库启动后的维护任务
```

### 5.2 OnBootSec配置示例


```ini
[Timer]
# 系统启动30分钟后执行
OnBootSec=30min

# 系统启动2小时后执行
OnBootSec=2h

# 系统启动5分钟后，然后每小时执行一次
OnBootSec=5min
OnUnitActiveSec=1h
```

### 5.3 时间单位说明


**systemd支持的时间单位**：

| 单位 | **完整形式** | **含义** | **示例** |
|------|-------------|----------|----------|
| `s` | `seconds` | `秒` | `OnBootSec=30s` |
| `m` | `minutes` | `分钟` | `OnBootSec=15m` |
| `h` | `hours` | `小时` | `OnBootSec=2h` |
| `d` | `days` | `天` | `OnBootSec=1d` |
| `w` | `weeks` | `周` | `OnBootSec=1w` |

### 5.4 实际应用场景


**启动延迟的典型用途**：

```ini
# 数据备份定时器
[Timer]
OnBootSec=10min      # 等待系统稳定
OnUnitActiveSec=24h  # 每24小时备份一次
Persistent=true

# 系统健康检查
[Timer]  
OnBootSec=5min       # 启动后5分钟检查
OnCalendar=hourly    # 之后每小时检查
```

> 💡 **最佳实践**：对于系统关键任务，建议使用OnBootSec确保系统完全启动后再执行。

---

## 6. 🔄 OnUnitActiveSec间隔执行


### 6.1 OnUnitActiveSec工作原理


**OnUnitActiveSec实现周期性任务执行**，基于上次服务激活的时间计算下次执行。

```
间隔执行时间线：

服务首次激活 → 执行任务 → 任务完成
    ↓
  开始计时OnUnitActiveSec
    ↓
  到达间隔时间 → 再次激活服务
    ↓
  循环执行...

与cron的区别：
cron:     每小时整点执行 (如: 1:00, 2:00, 3:00)
间隔执行: 每次执行完成后1小时 (如: 1:15→2:15→3:15)
```

### 6.2 OnUnitActiveSec配置方法


```ini
[Timer]
# 每30分钟执行一次
OnUnitActiveSec=30min

# 每2小时执行一次  
OnUnitActiveSec=2h

# 组合使用：启动5分钟后首次执行，然后每小时一次
OnBootSec=5min
OnUnitActiveSec=1h
```

### 6.3 间隔执行的应用场景


**适合使用间隔执行的场景**：

- **日志清理**：每次清理完成后，等待固定时间再清理
- **数据同步**：避免频繁同步，确保每次同步间隔足够
- **监控检查**：定期检查服务状态，避免检查冲突

```ini
# 日志清理示例
[Unit]
Description=清理系统日志

[Timer]
OnBootSec=1h            # 启动1小时后首次清理
OnUnitActiveSec=6h      # 每次清理完成6小时后再清理
Persistent=true

[Install]
WantedBy=timers.target
```

### 6.4 OnUnitActiveSec注意事项


> ⚠️ **重要提醒**：
> 1. **时间计算**：从服务**完成**时刻开始计时，不是启动时刻
> 2. **任务重叠**：如果任务执行时间超过间隔时间，不会重叠执行
> 3. **持久化**：配合`Persistent=true`使用，避免错过执行

---

## 7. 💾 Persistent持久化选项


### 7.1 Persistent选项的作用


**Persistent解决"错过执行时间"的问题**，确保重要任务不会因为系统关机而被跳过。

```
没有Persistent的情况：

系统关机时间：  22:00
定时任务时间：  23:00  ← 错过了！
系统开机时间：  08:00
下次执行时间：  第二天23:00  ← 延迟了24小时

有Persistent的情况：

系统关机时间：  22:00
定时任务时间：  23:00  ← 记录错过
系统开机时间：  08:00
立即执行：      08:00  ← 马上补执行
下次正常时间：  当天23:00
```

### 7.2 Persistent配置方法


```ini
[Timer]
OnCalendar=daily
Persistent=true    # 启用持久化

# 或者
Persistent=false   # 禁用持久化（默认值）
```

### 7.3 Persistent的适用场景


**何时使用Persistent**：

✅ **适合使用**：
- 数据备份任务
- 安全更新检查  
- 重要的维护任务
- 关键数据同步

❌ **不适合使用**：
- 实时监控任务
- 网络状态检查
- 临时性清理任务
- 高频率执行的任务

### 7.4 Persistent实际示例


```ini
# 数据库备份定时器（需要持久化）
[Unit]
Description=数据库每日备份

[Timer]
OnCalendar=daily
Persistent=true        # 确保备份不会被跳过
AccuracySec=1min      # 1分钟内执行即可

[Install]
WantedBy=timers.target
```

```ini
# 系统监控定时器（不需要持久化）
[Unit] 
Description=系统状态监控

[Timer]
OnCalendar=*:0/5:00    # 每5分钟
Persistent=false       # 错过就算了，不影响监控

[Install]
WantedBy=timers.target
```

> 💡 **选择建议**：对于**不可错过**的任务使用`Persistent=true`，对于**可以错过**的任务使用`Persistent=false`。

---

## 8. 🔗 timer与service关联


### 8.1 关联机制原理


**timer和service的配对关系**：systemd通过文件名自动关联timer和service。

```
文件命名规则：

my-backup.timer  ←→  my-backup.service
│                    │
├── 定义何时执行      ├── 定义执行什么
├── 时间配置         ├── 命令配置  
└── 触发条件         └── 运行环境

自动关联：
文件名相同 → systemd自动建立关联关系
```

### 8.2 创建关联的timer和service


**完整的定时任务需要两个文件**：

**第一步：创建service文件** `/etc/systemd/system/backup-db.service`

```ini
[Unit]
Description=数据库备份服务
Wants=network-online.target
After=network-online.target

[Service]
Type=oneshot
User=backup
ExecStart=/usr/local/bin/backup-database.sh
StandardOutput=journal
StandardError=journal

# 安全设置
PrivateTmp=true
ProtectSystem=strict
ReadWritePaths=/var/backups
```

**第二步：创建timer文件** `/etc/systemd/system/backup-db.timer`

```ini
[Unit]
Description=数据库备份定时器
Requires=backup-db.service

[Timer]
OnCalendar=daily
Persistent=true
RandomizedDelaySec=300

[Install]
WantedBy=timers.target
```

### 8.3 service文件的关键配置


**OneShot类型service的配置要点**：

| 配置项 | **说明** | **推荐值** |
|--------|----------|------------|
| `Type=oneshot` | `执行完就退出的任务` | `定时任务必须` |
| `RemainAfterExit=no` | `执行完不保持激活状态` | `默认值` |
| `StandardOutput=journal` | `输出到系统日志` | `便于调试` |
| `User=` | `指定执行用户` | `非root用户` |

### 8.4 自定义service名称


**如果想使用不同的service名称**：

```ini
# my-timer.timer文件
[Timer]
Unit=custom-service-name.service  # 指定关联的service
OnCalendar=hourly
```

> 💡 **命名建议**：保持timer和service同名，这是最清晰和推荐的做法。

---

## 9. ⚙️ systemctl timer管理命令


### 9.1 基本管理命令


**创建和启用定时器的完整流程**：

```bash
# 1. 重新加载systemd配置
sudo systemctl daemon-reload

# 2. 启用定时器（开机自启）
sudo systemctl enable backup-db.timer

# 3. 启动定时器
sudo systemctl start backup-db.timer

# 4. 查看定时器状态
sudo systemctl status backup-db.timer
```

### 9.2 定时器状态查看


**查看所有定时器状态**：

```bash
# 查看所有激活的定时器
systemctl list-timers

# 查看所有定时器（包括未激活的）
systemctl list-timers --all
```

**输出示例**：
```
NEXT                         LEFT          LAST                         PASSED       UNIT                         ACTIVATES
Thu 2024-01-18 00:00:00 CST  8h left       Wed 2024-01-17 00:00:00 CST  15h ago      backup-db.timer              backup-db.service
Thu 2024-01-18 06:30:00 CST  14h left      n/a                          n/a          system-update.timer          system-update.service
```

### 9.3 定时器调试命令


**调试和测试定时器**：

```bash
# 查看详细状态和日志
sudo systemctl status backup-db.timer

# 查看定时器历史日志
sudo journalctl -u backup-db.timer

# 查看服务执行日志
sudo journalctl -u backup-db.service

# 手动触发服务（测试用）
sudo systemctl start backup-db.service
```

### 9.4 定时器管理最佳实践


**日常管理的推荐流程**：

```bash
# 🔧 创建阶段
sudo systemctl daemon-reload     # 重载配置
sudo systemctl enable xxx.timer  # 设置开机启动
sudo systemctl start xxx.timer   # 启动定时器

# 📊 监控阶段  
systemctl list-timers           # 查看所有定时器
systemctl status xxx.timer      # 查看特定状态
journalctl -u xxx.timer -f      # 实时监控日志

# 🔄 维护阶段
sudo systemctl restart xxx.timer # 重启定时器
sudo systemctl stop xxx.timer    # 停止定时器  
sudo systemctl disable xxx.timer # 禁用开机启动
```

### 9.5 常见问题排查


**定时器不执行的排查步骤**：

- [ ] 检查timer文件语法：`systemd-analyze verify xxx.timer`
- [ ] 检查service文件语法：`systemd-analyze verify xxx.service`  
- [ ] 查看定时器状态：`systemctl status xxx.timer`
- [ ] 查看执行日志：`journalctl -u xxx.service`
- [ ] 验证时间表达式：`systemd-analyze calendar "表达式"`
- [ ] 手动测试服务：`systemctl start xxx.service`

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 systemd定时器：现代Linux系统的定时任务解决方案
🔸 timer单元：专门负责时间触发，不执行具体任务
🔸 关联机制：timer文件触发同名的service文件
🔸 时间表达式：比cron更强大灵活的时间配置
🔸 持久化机制：确保重要任务不会被错过
```

### 10.2 关键配置要点


**🔹 时间配置选择**：
```
OnCalendar: 适用于固定时间点执行
OnBootSec: 适用于系统启动后延迟执行
OnUnitActiveSec: 适用于间隔重复执行
```

**🔹 持久化配置原则**：
```
Persistent=true: 重要任务，不可错过
Persistent=false: 普通任务，可以跳过
```

**🔹 文件配置结构**：
```
[Unit] → 服务依赖和描述
[Timer] → 时间规则和选项  
[Install] → 安装目标配置
```

### 10.3 实际应用指导


**适用场景判断**：
- ✅ **系统级定时任务**：系统维护、备份、监控
- ✅ **需要依赖管理**：任务间有前后依赖关系
- ✅ **需要详细日志**：便于故障排查和监控
- ✅ **资源控制需求**：需要限制CPU、内存使用

**管理运维要点**：
- 📊 **定期检查**：使用`systemctl list-timers`监控状态
- 📝 **日志分析**：通过`journalctl`分析执行情况
- 🔧 **测试验证**：新建定时器先手动测试service
- 🔄 **版本管理**：定时器配置文件纳入版本控制

### 10.4 与传统cron对比


| 对比维度 | **cron** | **systemd timer** |
|---------|----------|------------------|
| 🎯 **使用复杂度** | `简单直接` | `需要两个文件` |
| 🔧 **功能强大程度** | `基础功能` | `功能丰富` |
| 📊 **日志和调试** | `日志简单` | `详细日志` |
| 🔄 **系统集成度** | `相对独立` | `深度集成` |
| 💡 **学习建议** | `适合简单任务` | `适合复杂任务` |

> 🧠 **记忆要点**：
> - systemd定时器 = 现代化的cron升级版
> - timer负责"何时"，service负责"做什么"  
> - Persistent确保重要任务不错过
> - 通过systemctl统一管理，日志详细便于调试