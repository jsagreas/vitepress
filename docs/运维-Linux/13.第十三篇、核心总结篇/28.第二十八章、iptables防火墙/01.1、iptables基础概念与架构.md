---
title: 1、iptables基础概念与架构
---
## 📚 目录

1. [iptables是什么](#1-iptables是什么)
2. [netfilter内核框架](#2-netfilter内核框架)
3. [iptables核心架构](#3-iptables核心架构)
4. [表和链的概念](#4-表和链的概念)
5. [规则和目标详解](#5-规则和目标详解)
6. [数据包处理流程](#6-数据包处理流程)
7. [iptables vs nftables](#7-iptables-vs-nftables)
8. [防火墙工作原理](#8-防火墙工作原理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ iptables是什么


### 1.1 通俗理解

**简单比喻**：iptables就像是你家门口的保安，负责检查进出的人员和物品。

```
现实中的安保系统：                    iptables防火墙：
┌─────────────────┐                 ┌─────────────────┐
│    外部世界      │                 │    外部网络      │
└─────┬───────────┘                 └─────┬───────────┘
      │ 访客进入                          │ 数据包进入
┌─────▼───────────┐                 ┌─────▼───────────┐
│   门卫检查站     │                 │   iptables规则   │
│ • 查看身份证     │                 │ • 检查源IP地址   │
│ • 检查访问目的   │                 │ • 检查目标端口   │
│ • 决定放行/拒绝  │                 │ • 决定ACCEPT/DROP │
└─────┬───────────┘                 └─────┬───────────┘
      │ 允许进入                          │ 允许通过
┌─────▼───────────┐                 ┌─────▼───────────┐
│   受保护区域     │                 │   本地系统      │
└─────────────────┘                 └─────────────────┘
```

### 1.2 核心定义

**iptables** 是Linux系统上的**用户空间防火墙工具**，用来配置内核中的netfilter防火墙规则。

> 💡 **重要理解**：
> - `netfilter`：真正干活的是内核中的这个框架
> - `iptables`：我们用来下达命令的工具
> - 就像将军(我们) → 传令兵(iptables) → 士兵(netfilter)

### 1.3 主要作用

```
🔸 访问控制：决定哪些数据包可以通过
🔸 网络地址转换(NAT)：修改数据包的IP地址
🔸 数据包过滤：根据规则丢弃或转发数据包
🔸 端口转发：将数据包重定向到其他端口
🔸 网络监控：记录和统计网络流量
```

---

## 2. 🔧 netfilter内核框架


### 2.1 什么是netfilter

**netfilter**是Linux内核中的一个框架，在数据包传输路径上设置了**5个钩子点(Hook Points)**。

```
数据包在内核中的传输路径：

外部网络
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│                    Linux内核空间                             │
│                                                            │
│  ①PREROUTING  ②INPUT   ③FORWARD   ④OUTPUT   ⑤POSTROUTING │
│     │           │        │         │          │           │
│     ▼           ▼        ▼         ▼          ▼           │
│ [路由前检查] [进入本机] [转发] [本机发出] [路由后处理]      │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 五个Hook点详解

| Hook点 | **位置** | **作用** | **典型应用** |
|--------|---------|----------|-------------|
| `PREROUTING` | **刚进内核时** | `路由决策前的处理` | `DNAT、端口映射` |
| `INPUT` | **进入本机前** | `目标是本机的包` | `访问控制、防护本机` |
| `FORWARD` | **转发处理时** | `经过本机转发` | `网关过滤、转发控制` |
| `OUTPUT` | **本机发出时** | `本机产生的包` | `出站控制、本机限制` |
| `POSTROUTING` | **离开内核前** | `路由决策后的处理` | `SNAT、源地址伪装` |

> 🤔 **思考一下**：为什么需要这么多检查点？
> 
> 因为数据包的来源和去向不同，需要在不同阶段进行相应的处理！

### 2.3 netfilter的工作机制

```
当数据包到达Hook点时：
┌─────────────────┐
│   数据包到达     │
└─────┬───────────┘
      │
┌─────▼───────────┐
│  调用Hook函数   │ ← netfilter在这里插入检查
└─────┬───────────┘
      │
┌─────▼───────────┐
│  检查iptables   │ ← 按优先级依次检查规则
│     规则        │
└─────┬───────────┘
      │
┌─────▼───────────┐
│   执行动作      │ ← ACCEPT/DROP/REJECT等
└─────────────────┘
```

---

## 3. 🏗️ iptables核心架构


### 3.1 三层架构

iptables采用**三层嵌套结构**：表(Tables) → 链(Chains) → 规则(Rules)

```
iptables架构图：
┌─────────────────────────────────────────────────────┐
│                   iptables                          │
├─────────────────────────────────────────────────────┤
│  Filter表    │  NAT表     │  Mangle表  │  Raw表     │
│ ┌─────────┐  │ ┌────────┐ │ ┌────────┐ │ ┌────────┐ │
│ │ INPUT   │  │ │PREROUTING│ │PREROUTING│ │PREROUTING│ │
│ │ FORWARD │  │ │ OUTPUT │ │ │ INPUT  │ │ │ OUTPUT │ │
│ │ OUTPUT  │  │ │POSTROUTING│ │ FORWARD│ │          │ │
│ └─────────┘  │ └────────┘ │ │ OUTPUT │ │          │ │
│             │           │ │POSTROUTING│ │          │ │
│             │           │ └────────┘ │          │ │
└─────────────────────────────────────────────────────┘
```

### 3.2 为什么设计成这样

> **设计思想**：不同的网络处理任务需要在不同的时机进行
> 
> - **表**：按功能分类（过滤、NAT、标记等）  
> - **链**：按数据包流向分类（进入、转发、发出等）
> - **规则**：具体的处理指令

---

## 4. 📋 表和链的概念


### 4.1 四大表详解


#### 🔍 Filter表（过滤表）

**用途**：最常用，专门做访问控制

```
Filter表包含的链：
• INPUT链：   过滤进入本机的数据包
• OUTPUT链：  过滤本机发出的数据包  
• FORWARD链： 过滤经过本机转发的数据包

实际应用：
• 阻止某些IP访问本机
• 只允许特定端口的访问
• 防止恶意攻击
```

#### 🔄 NAT表（网络地址转换表）

**用途**：修改数据包的IP地址或端口

```
NAT表包含的链：
• PREROUTING链：  目标地址转换(DNAT)
• OUTPUT链：      本机发出包的NAT
• POSTROUTING链： 源地址转换(SNAT)

实际应用：
• 家用路由器共享上网（SNAT）
• 端口映射到内网服务器（DNAT）
• 负载均衡
```

#### 🏷️ Mangle表（标记表）

**用途**：修改数据包的头部信息

```
Mangle表的作用：
• 修改TTL值
• 设置TOS字段
• 给数据包打标记
• 实现QoS流量控制

使用场景：
• 流量整形
• 策略路由
• 网络优化
```

#### ⚡ Raw表（原始表）

**用途**：决定数据包是否被连接跟踪

```
Raw表的特点：
• 优先级最高，最先处理
• 主要用于性能优化
• 跳过连接跟踪以提高性能

使用场景：
• 高流量服务器优化
• 避免连接跟踪开销
```

### 4.2 表的优先级

**处理顺序**：Raw → Mangle → NAT → Filter

> ⚠️ **重要**：优先级高的表先处理，如果被DROP了，后面的表就不会处理了

### 4.3 链的作用

**链**就是Hook点上挂载的规则列表：

```
数据包流向决定了会经过哪些链：

进入本机的包：    PREROUTING → INPUT
本机发出的包：    OUTPUT → POSTROUTING  
转发的包：       PREROUTING → FORWARD → POSTROUTING
```

---

## 5. 📝 规则和目标详解


### 5.1 规则的组成

每条iptables规则包含两部分：**匹配条件** + **执行动作**

```
规则格式：
iptables -A INPUT -s 192.168.1.100 -p tcp --dport 80 -j ACCEPT
         │    │   │                │              │   │
         │    │   └─ 匹配条件：源IP地址              │   │
         │    └───── 链名                         │   │
         └────────── 动作：添加规则                │   │
                                            ┌───────┘   │
                                            │           │
                                         更多条件    执行动作
```

### 5.2 常用匹配条件

| 条件类型 | **参数** | **说明** | **示例** |
|---------|---------|----------|----------|
| `源地址` | `-s` | `指定源IP地址` | `-s 192.168.1.0/24` |
| `目标地址` | `-d` | `指定目标IP地址` | `-d 10.0.0.1` |
| `协议` | `-p` | `指定协议类型` | `-p tcp`, `-p udp` |
| `源端口` | `--sport` | `指定源端口` | `--sport 80` |
| `目标端口` | `--dport` | `指定目标端口` | `--dport 22` |
| `网络接口` | `-i/-o` | `指定进入/出去接口` | `-i eth0`, `-o wlan0` |

### 5.3 常用目标动作

| 动作 | **含义** | **用途** | **数据包去向** |
|------|---------|----------|---------------|
| `ACCEPT` | **放行** | `允许数据包通过` | `继续后续处理` |
| `DROP` | **丢弃** | `静默丢弃数据包` | `直接消失，不回应` |
| `REJECT` | **拒绝** | `拒绝并回应错误` | `发送拒绝消息给发送方` |
| `LOG` | **记录** | `记录日志但继续处理` | `记录后继续匹配规则` |
| `DNAT` | **目标NAT** | `修改目标地址` | `转发到新的目标` |
| `SNAT` | **源NAT** | `修改源地址` | `以新源地址发送` |

> 💡 **DROP vs REJECT的区别**：
> - DROP：就像石沉大海，发送方不知道发生了什么
> - REJECT：会告诉发送方"你的请求被拒绝了"

### 5.4 规则的匹配过程

```
数据包处理流程：
┌─────────────────┐
│   数据包到达     │
└─────┬───────────┘
      │
┌─────▼───────────┐
│ 检查第1条规则   │ ← 从上到下逐条检查
└─────┬───────────┘
      │ 不匹配
┌─────▼───────────┐
│ 检查第2条规则   │
└─────┬───────────┘
      │ 匹配！
┌─────▼───────────┐
│  执行动作       │ ← 执行对应的TARGET
└─────┬───────────┘
      │
┌─────▼───────────┐
│  停止匹配       │ ← 找到匹配就停止（除非是LOG）
└─────────────────┘
```

> ⚠️ **重要原则**：规则是按顺序匹配的，**匹配到就停止**，所以规则的顺序很重要！

---

## 6. 🔄 数据包处理流程


### 6.1 完整流程图

```
                               数据包进入Linux系统
                                       │
                                       ▼
                            ┌─────────────────────┐
                            │    PREROUTING      │ ← Raw→Mangle→NAT表
                            │   (路由前处理)      │
                            └─────────┬───────────┘
                                      │
                                      ▼
                            ┌─────────────────────┐
                            │     路由决策        │ ← 内核决定包的去向
                            └─────────┬───────────┘
                                      │
                    ┌─────────────────┼─────────────────┐
                    │                 │                 │
                    ▼                 ▼                 ▼
          ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
          │     INPUT       │ │    FORWARD      │ │    OUTPUT       │
          │  (进入本机)      │ │   (转发数据)     │ │  (本机发出)      │
          └─────────────────┘ └─────────────────┘ └─────────────────┘
                    │                 │                 │
                    ▼                 ▼                 │
          ┌─────────────────┐ ┌─────────────────┐      │
          │   本地进程      │ │       │         │      │
          │   处理数据      │ │       ▼         │      │
          └─────────────────┘ │ ┌─────────────────┐   │
                              │ │  POSTROUTING   │ ◄─┘
                              │ │  (路由后处理)   │
                              │ └─────────────────┘
                              │         │
                              │         ▼
                              │ ┌─────────────────┐
                              └▶│   发送到网络    │
                                └─────────────────┘
```

### 6.2 三种典型场景


#### 场景1：访问本机服务

```
外部客户端访问本机Web服务：

客户端 ──→ [PREROUTING] ──→ 路由决策 ──→ [INPUT] ──→ 本机Web服务
           Mangle/NAT表      "目标是本机"    Filter表     nginx/apache

处理的表：Mangle → NAT → Filter
经过的链：PREROUTING → INPUT
```

#### 场景2：本机访问外部

```
本机访问外部网站：

本机程序 ──→ [OUTPUT] ──→ 路由决策 ──→ [POSTROUTING] ──→ 外部网站
curl/wget    Filter表    "从哪个接口出去"   NAT/Mangle表

处理的表：Filter → NAT → Mangle  
经过的链：OUTPUT → POSTROUTING
```

#### 场景3：转发数据包（路由器功能）

```
A主机 ──→ 本机(作为网关) ──→ B主机

A主机 ──→ [PREROUTING] ──→ 路由决策 ──→ [FORWARD] ──→ [POSTROUTING] ──→ B主机
          NAT表做DNAT      "转发到B"      Filter表       NAT表做SNAT

处理的表：NAT → Filter → NAT
经过的链：PREROUTING → FORWARD → POSTROUTING
```

### 6.3 路由决策的作用

> 💭 **理解关键**：路由决策决定了数据包走哪条路径
> 
> - 目标是本机IP → 走INPUT链
> - 目标是其他IP且开启转发 → 走FORWARD链  
> - 本机产生的包 → 走OUTPUT链

---

## 7. ⚔️ iptables vs nftables


### 7.1 为什么要有nftables

**nftables**是iptables的继任者，解决了iptables的一些问题：

```
iptables的问题：
┌─ iptables痛点 ─────────────────┐
│ • 规则多时性能下降严重         │
│ • 语法不够统一，命令复杂       │  
│ • 内核中有多套重复的代码       │
│ • 扩展性不好，难以添加新功能   │
│ • 更新规则时需要替换整个规则集 │
└────────────────────────────────┘

nftables的改进：
┌─ nftables优势 ─────────────────┐
│ • 统一的语法，更易学习         │
│ • 内核中统一的框架，性能更好   │
│ • 支持增量更新规则             │
│ • 更好的脚本支持               │
│ • 向后兼容iptables             │
└────────────────────────────────┘
```

### 7.2 语法对比

| 操作 | **iptables命令** | **nftables命令** |
|------|-----------------|------------------|
| `查看规则` | `iptables -L` | `nft list table ip filter` |
| `添加规则` | `iptables -A INPUT -j DROP` | `nft add rule ip filter input drop` |
| `清空规则` | `iptables -F` | `nft flush table ip filter` |

### 7.3 现状和选择

```
🔸 CentOS 7/Ubuntu 18以前：主要使用iptables
🔸 CentOS 8/Ubuntu 20及以后：默认使用nftables，但保留iptables兼容
🔸 实际生产：很多系统仍在使用iptables
🔸 学习建议：先掌握iptables，再了解nftables

为什么先学iptables：
✅ 存量系统多，工作中经常遇到
✅ 概念和原理是共通的
✅ 网上资料和教程更丰富
✅ 掌握后再学nftables会更容易
```

---

## 8. 🔒 防火墙工作原理


### 8.1 防火墙的本质

**防火墙就是一个守门员**，根据预定的规则决定让谁进、让谁出。

```
传统物理防火墙：        Linux软件防火墙：
┌─────────────────┐    ┌─────────────────┐
│   内网(安全)     │    │    受保护主机    │
├─────────────────┤    ├─────────────────┤  
│  [防火墙设备]   │ ←→ │  [iptables规则] │
├─────────────────┤    ├─────────────────┤
│   外网(危险)     │    │    外部网络     │
└─────────────────┘    └─────────────────┘
```

### 8.2 包过滤防火墙原理

iptables属于**包过滤型防火墙**，工作在网络层：

```
包过滤防火墙的特点：
┌─ 优点 ─────────────────────────┐
│ • 效率高，处理速度快            │
│ • 对应用程序透明                │
│ • 成本低，通用性好              │
│ • 可以做NAT和端口映射           │
└─────────────────────────────────┘

┌─ 缺点 ─────────────────────────┐
│ • 无法检查应用层内容            │
│ • 无法防止应用层攻击            │
│ • 不能识别用户身份              │
│ • 对复杂协议支持有限            │
└─────────────────────────────────┘
```

### 8.3 状态跟踪机制

现代iptables支持**连接跟踪(Connection Tracking)**：

```
无状态过滤：                  有状态过滤：
每个包独立处理                记住连接状态

客户端 ──→ 服务器             客户端 ──→ 服务器
请求包: [检查规则]            请求包: [NEW] → 允许通过
                             
客户端 ←── 服务器             客户端 ←── 服务器  
响应包: [检查规则]            响应包: [ESTABLISHED] → 自动允许

问题：响应包需要单独配规则     优势：响应包自动允许，更安全
```

**连接状态类型**：
- `NEW`：新连接的第一个包
- `ESTABLISHED`：已建立连接的包  
- `RELATED`：与已有连接相关的包（如FTP数据连接）
- `INVALID`：无法识别的包

### 8.4 防火墙的防护策略


#### 🔒 默认拒绝策略

```
安全的防火墙策略：

1. 默认DROP所有包
2. 明确允许需要的服务
3. 最小权限原则

示例：
iptables -P INPUT DROP     # 默认拒绝进入
iptables -P FORWARD DROP   # 默认拒绝转发  
iptables -P OUTPUT ACCEPT  # 允许出去（可选）

然后添加具体的允许规则：
iptables -A INPUT -p tcp --dport 22 -j ACCEPT  # 允许SSH
iptables -A INPUT -p tcp --dport 80 -j ACCEPT  # 允许HTTP
```

#### 🚪 常见防护场景

| 防护目标 | **规则示例** | **说明** |
|---------|-------------|----------|
| `SSH防护` | `-p tcp --dport 22 -s 信任IP -j ACCEPT` | `只允许特定IP的SSH访问` |
| `Web服务` | `-p tcp --dport 80,443 -j ACCEPT` | `允许HTTP/HTTPS访问` |
| `防DDoS` | `-m limit --limit 25/minute -j ACCEPT` | `限制连接频率` |
| `防扫描` | `-p tcp --tcp-flags ALL NONE -j DROP` | `丢弃异常TCP包` |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念

```
🔸 iptables本质：用户空间工具，配置内核netfilter框架
🔸 核心架构：表(Tables) → 链(Chains) → 规则(Rules)  
🔸 五个Hook点：PREROUTING、INPUT、FORWARD、OUTPUT、POSTROUTING
🔸 四大表：Filter(过滤)、NAT(转换)、Mangle(标记)、Raw(原始)
🔸 规则匹配：从上到下，匹配即停止
🔸 数据包流向：决定经过哪些链
```

### 9.2 关键理解要点


**🔹 为什么叫"表"和"链"**
```
表(Table)：按功能分类的规则集合
链(Chain)：按数据包流向分类的检查点
规则(Rule)：具体的处理指令

就像医院分科室：
• 内科(Filter表)：专门看病(过滤)
• 外科(NAT表)：专门做手术(地址转换) 
• 每个科室有不同科室(链)：门诊、急诊、住院部
```

**🔹 数据包的"生命周期"**
```
理解关键：数据包在内核中的旅程
• 刚进来时：PREROUTING处理
• 路由决策：决定去哪里
• 目标确定：进入相应的链处理
• 最后离开：POSTROUTING处理
```

**🔹 规则的优先级**
```
记忆要点：
• 表的优先级：Raw → Mangle → NAT → Filter
• 链内规则：从上到下，先到先得
• 匹配原则：找到匹配就停止(除LOG外)
```

### 9.3 实际应用价值

**🎯 工作中的常见场景**：
- **服务器安全**：只允许必要的端口访问
- **网关配置**：家用路由器、企业网关都用iptables
- **访问控制**：限制特定IP或用户组的访问  
- **网络调试**：排查网络连接问题
- **性能优化**：通过规则减少不必要的连接

**🔧 学习路径建议**：
```
第一步：理解概念 ← 当前章节
第二步：学习基本命令语法
第三步：练习常用规则配置
第四步：学习NAT和端口转发  
第五步：掌握高级功能和调试
```

**🔑 记忆口诀**：
```
表链规则三层套，Hook点上把包挑
Raw表最先Mangle跟，NAT转换Filter过滤
数据流向定链路，规则匹配按顺序  
防火墙前守门员，安全第一是关键
```

> 💡 **核心理解**：
> iptables看起来复杂，但本质就是在数据包传输的关键节点上设置检查点，根据规则决定放行还是拦截。掌握了数据包的流向，就掌握了iptables的核心!