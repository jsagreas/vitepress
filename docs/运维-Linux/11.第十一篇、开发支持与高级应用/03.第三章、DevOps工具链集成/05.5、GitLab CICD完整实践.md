---
title: 5、GitLab CICD完整实践
---
## 📚 目录

1. [GitLab CI/CD基础概念](#1-GitLab-CI-CD基础概念)
2. [GitLab Runner安装与配置](#2-GitLab-Runner安装与配置)
3. [CI/CD配置文件详解](#3-CI-CD配置文件详解)
4. [多环境部署策略](#4-多环境部署策略)
5. [容器化构建环境](#5-容器化构建环境)
6. [变量与秘钥管理](#6-变量与秘钥管理)
7. [构建缓存与性能优化](#7-构建缓存与性能优化)
8. [GitLab Pages静态部署](#8-GitLab-Pages静态部署)
9. [安全扫描集成](#9-安全扫描集成)
10. [最佳实践与故障排查](#10-最佳实践与故障排查)

---

## 1. 🚀 GitLab CI/CD基础概念


### 1.1 什么是GitLab CI/CD


**CI/CD本质理解**：
- **CI（持续集成）**：把代码变化自动合并测试的过程
- **CD（持续部署）**：把测试通过的代码自动发布到服务器的过程

```
传统开发流程：
开发代码 → 手动测试 → 手动部署 → 祈祷不出问题

GitLab CI/CD流程：
代码提交 → 自动测试 → 自动构建 → 自动部署 → 自动监控
```

**核心组件关系**：
```
GitLab仓库                GitLab Runner              目标环境
     |                        |                        |
 代码提交  ──触发──→     执行任务     ──部署──→      应用服务
     |                        |                        |
.gitlab-ci.yml             具体执行器                  生产环境
```

### 1.2 GitLab CI/CD工作原理


**执行流程详解**：
1. **触发阶段**：代码推送到GitLab仓库
2. **解析阶段**：GitLab读取`.gitlab-ci.yml`配置文件
3. **调度阶段**：GitLab将任务分配给可用的Runner
4. **执行阶段**：Runner执行定义的任务（测试、构建、部署）
5. **反馈阶段**：任务结果返回到GitLab界面

**Pipeline（流水线）概念**：
```
Pipeline = 一次完整的CI/CD执行过程

举例说明：
提交代码 → 触发Pipeline → 包含多个Stage → 每个Stage包含多个Job

实际例子：
测试阶段：运行单元测试、代码质量检查
构建阶段：编译代码、打包应用
部署阶段：发布到测试环境、发布到生产环境
```

---

## 2. 🔧 GitLab Runner安装与配置


### 2.1 Runner类型选择


**Runner类型对比**：

| Runner类型 | **使用场景** | **优势** | **劣势** |
|-----------|------------|---------|---------|
| **Shared Runner** | `小团队、快速开始` | `免维护、即开即用` | `资源共享、性能限制` |
| **Group Runner** | `团队项目、统一管理` | `资源独享、可定制` | `需要维护、成本较高` |
| **Specific Runner** | `特殊需求、高安全性` | `完全控制、高性能` | `维护成本高、配置复杂` |

### 2.2 Linux环境Runner安装


**安装步骤详解**：

**第一步：添加GitLab官方仓库**
```bash
# 下载并安装仓库配置脚本
curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh" | sudo bash
```

**第二步：安装GitLab Runner**
```bash
# CentOS/RHEL系统
sudo yum install gitlab-runner

# Ubuntu/Debian系统  
sudo apt-get install gitlab-runner
```

**第三步：注册Runner**
```bash
sudo gitlab-runner register
```

**注册配置示例**：
```
注册交互过程：
1. GitLab实例URL: https://gitlab.example.com
2. 注册令牌: (从GitLab项目设置获取)
3. Runner描述: 我的项目构建器
4. Runner标签: docker,linux,build
5. 执行器类型: docker
6. 默认镜像: alpine:latest
```

### 2.3 Docker执行器配置


**为什么选择Docker执行器**：
- **环境隔离**：每个任务运行在独立容器中
- **依赖管理**：通过镜像管理复杂依赖
- **可重复性**：相同环境保证构建一致性

**Docker执行器配置文件**：
```toml
# /etc/gitlab-runner/config.toml
concurrent = 4
check_interval = 0

[session_server]
  session_timeout = 1800

[[runners]]
  name = "docker-runner"
  url = "https://gitlab.example.com"
  token = "your-runner-token"
  executor = "docker"
  [runners.custom_build_dir]
  [runners.cache]
    [runners.cache.s3]
    [runners.cache.gcs]
    [runners.cache.azure]
  [runners.docker]
    tls_verify = false
    image = "alpine:latest"
    privileged = false
    disable_entrypoint_overwrite = false
    oom_kill_disable = false
    disable_cache = false
    volumes = ["/cache"]
    shm_size = 0
```

---

## 3. 📝 CI/CD配置文件详解


### 3.1 .gitlab-ci.yml基础结构


**配置文件核心概念**：
- **Stage（阶段）**：把相关任务分组，比如测试阶段、构建阶段
- **Job（任务）**：具体要执行的工作，比如运行测试、编译代码
- **Script（脚本）**：任务中要运行的具体命令

**基础配置示例**：
```yaml
# 定义流水线的各个阶段
stages:
  - test      # 测试阶段
  - build     # 构建阶段  
  - deploy    # 部署阶段

# 测试任务
run_tests:
  stage: test                    # 属于test阶段
  image: node:16                 # 使用Node.js 16镜像
  script:                        # 要执行的命令
    - npm install                # 安装依赖
    - npm test                   # 运行测试
  only:                          # 只在这些情况下运行
    - merge_requests             # 合并请求时
    - main                       # main分支提交时

# 构建任务
build_app:
  stage: build
  image: node:16
  script:
    - npm install
    - npm run build
  artifacts:                     # 保存构建产物
    paths:
      - dist/                    # 保存dist目录
    expire_in: 1 hour            # 1小时后自动删除
```

### 3.2 常用关键字详解


**Job控制关键字**：

**`only`和`except`规则**：
```yaml
# 控制任务执行条件
deploy_production:
  script: echo "部署到生产环境"
  only:
    - main                       # 只在main分支执行
    - tags                       # 只在tag时执行
  except:
    - merge_requests             # 合并请求时不执行

# 使用规则表达式
deploy_staging:
  script: echo "部署到测试环境"
  only:
    refs:
      - /^feature\/.*$/          # feature/开头的分支
    variables:
      - $CI_COMMIT_MESSAGE =~ /deploy/  # 提交信息包含deploy
```

**`artifacts`产物管理**：
```yaml
build_job:
  script:
    - make build
  artifacts:
    name: "build-$CI_COMMIT_REF_NAME"    # 产物名称
    paths:
      - build/                           # 要保存的文件
      - logs/*.log                       # 支持通配符
    when: always                         # 总是保存（默认on_success）
    expire_in: 1 week                    # 保存时间
    reports:
      junit: test-reports.xml            # 测试报告
```

**`cache`缓存配置**：
```yaml
# 全局缓存配置
cache:
  key: ${CI_COMMIT_REF_SLUG}             # 缓存键值
  paths:
    - node_modules/                      # 缓存Node.js依赖
    - .pip-cache/                        # 缓存Python包

# 任务级缓存配置
test_job:
  cache:
    key: test-cache
    paths:
      - node_modules/
    policy: pull-push                    # 拉取并推送缓存
```

### 3.3 变量与环境配置


**内置变量使用**：
```yaml
show_info:
  script:
    - echo "项目名称：$CI_PROJECT_NAME"
    - echo "分支名称：$CI_COMMIT_REF_NAME"  
    - echo "提交SHA：$CI_COMMIT_SHA"
    - echo "构建编号：$CI_PIPELINE_ID"
    - echo "运行者：$GITLAB_USER_NAME"
```

**自定义变量定义**：
```yaml
variables:
  DATABASE_URL: "postgresql://localhost/myapp"
  NODE_ENV: "test"
  DOCKER_DRIVER: overlay2

deploy_job:
  variables:
    ENVIRONMENT: "production"            # 任务级变量
  script:
    - echo "部署到环境：$ENVIRONMENT"
```

---

## 4. 🌍 多环境部署策略


### 4.1 环境分离策略


**典型环境架构**：
```
开发环境(Dev)     测试环境(Test)     预发环境(Staging)     生产环境(Prod)
      |                |                    |                   |
  feature分支      develop分支          release分支         main分支
      |                |                    |                   |
   自动部署          自动部署             手动审批            手动审批
```

**环境配置对比**：

| 环境类型 | **部署条件** | **数据库** | **监控级别** | **回滚策略** |
|---------|------------|-----------|------------|-------------|
| **开发环境** | `每次提交自动部署` | `测试数据` | `基础监控` | `快速回滚` |
| **测试环境** | `合并到develop自动部署` | `模拟数据` | `完整监控` | `自动回滚` |
| **预发环境** | `手动触发部署` | `生产数据副本` | `生产级监控` | `谨慎回滚` |
| **生产环境** | `手动审批后部署` | `生产数据` | `全面监控` | `严格流程回滚` |

### 4.2 分支部署策略实现


**基于分支的部署配置**：
```yaml
stages:
  - test
  - build  
  - deploy_dev
  - deploy_test
  - deploy_staging
  - deploy_prod

# 开发环境部署（feature分支）
deploy_development:
  stage: deploy_dev
  script:
    - echo "部署到开发环境"
    - ./deploy.sh development
  environment:
    name: development
    url: https://dev.myapp.com
  only:
    - /^feature\/.*$/                    # feature分支自动部署

# 测试环境部署（develop分支）  
deploy_testing:
  stage: deploy_test
  script:
    - echo "部署到测试环境"
    - ./deploy.sh testing
  environment:
    name: testing
    url: https://test.myapp.com
  only:
    - develop                            # develop分支自动部署

# 生产环境部署（main分支 + 手动触发）
deploy_production:
  stage: deploy_prod
  script:
    - echo "部署到生产环境"
    - ./deploy.sh production
  environment:
    name: production
    url: https://myapp.com
  when: manual                           # 手动触发
  only:
    - main                               # 仅main分支
```

### 4.3 环境变量管理


**环境特定变量配置**：
```yaml
# 开发环境变量
deploy_dev:
  variables:
    APP_ENV: "development"
    DEBUG_MODE: "true"
    DATABASE_URL: $DEV_DATABASE_URL
  environment: development

# 生产环境变量  
deploy_prod:
  variables:
    APP_ENV: "production"
    DEBUG_MODE: "false"
    DATABASE_URL: $PROD_DATABASE_URL
  environment: production
```

---

## 5. 🐳 容器化构建环境


### 5.1 Docker镜像选择策略


**镜像选择原则**：
- **基础镜像**：选择官方维护的稳定版本
- **大小优化**：优先选择Alpine版本（体积小、安全性高）
- **版本固定**：使用具体版本号，避免latest标签

**常用镜像对比**：

| 用途 | **推荐镜像** | **大小** | **特点** |
|-----|------------|---------|---------|
| **Node.js应用** | `node:16-alpine` | `~110MB` | `轻量级、生产就绪` |
| **Python应用** | `python:3.9-alpine` | `~45MB` | `包含pip、轻量级` |
| **Java应用** | `openjdk:11-alpine` | `~320MB` | `JRE环境、体积较小` |
| **前端构建** | `node:16-alpine` | `~110MB` | `包含npm/yarn` |

### 5.2 多阶段构建优化


**传统单阶段构建问题**：
```dockerfile
# 问题：最终镜像包含编译工具，体积大、安全性差
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install                          # 包含开发依赖
COPY . .
RUN npm run build                        # 编译应用
EXPOSE 3000
CMD ["npm", "start"]                     # 最终镜像体积大
```

**优化后的多阶段构建**：
```dockerfile
# 第一阶段：构建环境
FROM node:16-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production             # 只安装生产依赖
COPY . .
RUN npm run build                        # 编译应用

# 第二阶段：运行环境
FROM node:16-alpine AS runtime
WORKDIR /app
COPY --from=builder /app/dist ./dist     # 只复制编译结果
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./
EXPOSE 3000
CMD ["npm", "start"]                     # 最终镜像体积小
```

### 5.3 GitLab CI中的容器化配置


**容器化构建任务配置**：
```yaml
# Docker镜像构建任务
build_docker_image:
  stage: build
  image: docker:20.10.16                 # Docker in Docker
  services:
    - docker:20.10.16-dind               # Docker守护进程
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest
```

**使用GitLab容器注册表**：
```yaml
variables:
  # GitLab内置容器注册表变量
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG

build_and_push:
  script:
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
  
deploy_with_image:
  script:
    - docker pull $IMAGE_TAG
    - docker run -d --name myapp $IMAGE_TAG
```

---

## 6. 🔐 变量与秘钥管理


### 6.1 变量类型与作用域


**变量作用域层级**：
```
实例级变量 (Instance Variables)
    ↓
组级变量 (Group Variables)  
    ↓
项目级变量 (Project Variables)
    ↓
Pipeline级变量 (Pipeline Variables)
    ↓
Job级变量 (Job Variables)
```

**变量优先级规则**：优先级由低到高，后者覆盖前者

### 6.2 敏感信息保护


**Protected变量配置**：
```yaml
# 在GitLab界面设置Protected变量
# Settings → CI/CD → Variables

变量名: PRODUCTION_API_KEY
变量值: [敏感信息]
Protected: ✓                            # 只在保护分支可用
Masked: ✓                               # 在日志中隐藏
```

**在CI配置中使用敏感变量**：
```yaml
deploy_production:
  script:
    - echo "部署到生产环境"
    - curl -H "Authorization: Bearer $PRODUCTION_API_KEY" https://api.example.com
  only:
    - main                               # 只在main分支运行
  environment: production
```

### 6.3 外部配置管理


**使用外部配置服务**：
```yaml
# 从HashiCorp Vault获取配置
get_secrets:
  image: vault:latest
  script:
    - export VAULT_ADDR="https://vault.example.com"
    - export VAULT_TOKEN="$VAULT_TOKEN"
    - vault kv get -field=password secret/myapp > .env
    - source .env
  artifacts:
    paths:
      - .env
    expire_in: 5 minutes
```

**环境特定的配置文件**：
```yaml
# 使用include包含环境特定配置
include:
  - local: '.gitlab-ci-base.yml'         # 基础配置
  - local: '.gitlab-ci-prod.yml'         # 生产环境配置
    rules:
      - if: $CI_COMMIT_REF_NAME == "main"

# 条件性包含配置
include:
  - project: 'mygroup/ci-templates'
    file: '/templates/security-scan.yml'
    rules:
      - if: $SECURITY_SCAN_ENABLED == "true"
```

---

## 7. ⚡ 构建缓存与性能优化


### 7.1 缓存策略设计


**缓存的本质作用**：避免重复下载和安装依赖，大幅提升构建速度

**缓存策略对比**：

| 策略类型 | **适用场景** | **缓存键** | **优势** | **注意事项** |
|---------|------------|-----------|---------|-------------|
| **按分支缓存** | `功能开发` | `$CI_COMMIT_REF_SLUG` | `分支隔离、并行开发` | `缓存可能过多` |
| **按文件哈希缓存** | `依赖管理` | `package-lock.json哈希` | `精确缓存、自动更新` | `配置复杂` |
| **全局共享缓存** | `依赖稳定` | `global-cache` | `节省存储、快速命中` | `可能冲突` |

### 7.2 依赖缓存优化


**Node.js项目缓存配置**：
```yaml
# 基于package-lock.json的精确缓存
cache:
  key:
    files:
      - package-lock.json                # 依赖文件变化时更新缓存
  paths:
    - node_modules/                      # 缓存依赖目录
    - .npm/                             # 缓存npm缓存

install_dependencies:
  script:
    - npm ci --cache .npm --prefer-offline  # 优先使用离线缓存
```

**Maven项目缓存配置**：
```yaml
cache:
  key: 
    files:
      - pom.xml                          # Maven配置文件
  paths:
    - .m2/repository/                    # Maven本地仓库

build_java:
  script:
    - mvn -Dmaven.repo.local=.m2/repository clean compile
```

**Docker层缓存优化**：
```yaml
build_with_cache:
  script:
    # 使用Docker buildkit启用层缓存
    - export DOCKER_BUILDKIT=1
    - docker build 
        --cache-from $CI_REGISTRY_IMAGE:cache 
        --build-arg BUILDKIT_INLINE_CACHE=1 
        -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:cache
    - docker push $CI_REGISTRY_IMAGE:cache
```

### 7.3 并行化构建


**Job并行执行配置**：
```yaml
# 测试任务并行化
test_unit:
  stage: test
  script:
    - npm run test:unit
  parallel: 3                            # 并行运行3个实例

test_integration:
  stage: test  
  script:
    - npm run test:integration
  parallel:
    matrix:                              # 矩阵策略并行
      - NODE_VERSION: ["14", "16", "18"]
      - TEST_SUITE: ["api", "frontend"]
```

**使用GitLab Runner的并发配置**：
```toml
# /etc/gitlab-runner/config.toml
concurrent = 10                          # 同时运行的任务数

[[runners]]
  name = "concurrent-runner"
  limit = 5                             # 该Runner最大并发数
```

---

## 8. 📄 GitLab Pages静态部署


### 8.1 GitLab Pages基础概念


**GitLab Pages是什么**：
- **静态网站托管服务**：直接从Git仓库部署静态网站
- **免费域名**：提供username.gitlab.io子域名
- **自定义域名**：支持绑定自己的域名
- **HTTPS支持**：自动提供SSL证书

**适用场景**：
- 📚 **文档网站**：API文档、用户手册
- 🎨 **个人博客**：技术博客、作品展示
- 📊 **项目主页**：开源项目介绍页面
- 🎯 **单页应用**：Vue/React构建的SPA应用

### 8.2 Pages部署配置


**基础Pages部署**：
```yaml
# 关键：Job名称必须是 pages
pages:
  stage: deploy
  script:
    - mkdir public                       # 必须创建public目录
    - cp -r dist/* public/               # 将构建产物复制到public
  artifacts:
    paths:
      - public                           # 必须发布public目录
  only:
    - main                               # 只在main分支部署
```

**Vue.js项目Pages部署**：
```yaml
image: node:16-alpine

stages:
  - build
  - deploy

# 构建阶段
build:
  stage: build
  script:
    - npm ci
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 hour

# 部署到GitLab Pages
pages:
  stage: deploy
  dependencies:
    - build                              # 依赖build任务的产物
  script:
    - mkdir public
    - cp -r dist/* public/
  artifacts:
    paths:
      - public
  only:
    - main
```

### 8.3 自定义域名配置


**域名绑定步骤**：

**第一步：在GitLab中配置域名**
```
Settings → Pages → New Domain
域名: www.mywebsite.com
证书: 可选择Let's Encrypt自动证书
```

**第二步：DNS配置**
```
CNAME记录配置：
名称: www
值: username.gitlab.io

A记录配置（根域名）：
名称: @
值: 35.185.44.232 (GitLab Pages IP)
```

**第三步：强制HTTPS配置**
```yaml
pages:
  script:
    - mkdir public
    - cp -r dist/* public/
    # 添加重定向规则强制HTTPS
    - echo "/*    /index.html   200" > public/_redirects
  artifacts:
    paths:
      - public
```

---

## 9. 🛡️ 安全扫描集成


### 9.1 代码安全扫描类型


**扫描类型对比**：

| 扫描类型 | **扫描对象** | **发现问题** | **执行时机** | **性能影响** |
|---------|------------|-------------|-------------|-------------|
| **SAST** | `源代码` | `代码安全漏洞` | `构建阶段` | `中等` |
| **Dependency Scan** | `依赖包` | `已知漏洞CVE` | `构建阶段` | `较小` |
| **Container Scan** | `容器镜像` | `镜像层漏洞` | `镜像构建后` | `较大` |
| **DAST** | `运行应用` | `运行时漏洞` | `部署后` | `很大` |

### 9.2 静态代码安全扫描(SAST)


**启用SAST扫描**：
```yaml
include:
  - template: Security/SAST.gitlab-ci.yml  # 包含SAST模板

# SAST扫描会自动运行，生成安全报告
# 支持多种语言：Java, JavaScript, Python, Go, C#等

# 自定义SAST配置
sast:
  variables:
    SAST_EXCLUDED_PATHS: "tests/,docs/"   # 排除扫描路径
    SAST_DEFAULT_ANALYZERS: "eslint,sobelow"  # 指定分析器
```

**查看扫描结果**：
```
Pipeline → Security → 查看漏洞详情
• 严重程度分级：Critical, High, Medium, Low
• 修复建议：提供具体的修复方案
• 误报处理：可标记为误报忽略
```

### 9.3 依赖安全扫描


**Node.js依赖扫描**：
```yaml
include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml

# 自动扫描package.json和package-lock.json
# 检查已知的CVE漏洞

# 手动依赖审计
audit_dependencies:
  image: node:16-alpine
  script:
    - npm audit                          # 检查漏洞
    - npm audit fix                      # 自动修复
  allow_failure: true                    # 允许失败但继续流水线
```

**Python依赖扫描**：
```yaml
# 使用safety检查Python依赖
python_security_check:
  image: python:3.9
  script:
    - pip install safety
    - safety check -r requirements.txt   # 检查requirements.txt
    - pip-audit                          # 使用pip-audit工具
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json
```

### 9.4 容器镜像安全扫描


**启用容器扫描**：
```yaml
include:
  - template: Security/Container-Scanning.gitlab-ci.yml

build_and_scan:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  variables:
    CS_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA  # 指定扫描镜像
```

**使用第三方扫描工具**：
```yaml
# 使用Trivy扫描容器
trivy_scan:
  image: aquasec/trivy:latest
  script:
    - trivy image --format json --output trivy-report.json $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - trivy image --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  artifacts:
    reports:
      container_scanning: trivy-report.json
    paths:
      - trivy-report.json
```

---

## 10. 🎯 最佳实践与故障排查


### 10.1 CI/CD最佳实践


**Pipeline设计原则**：
- ✅ **快速反馈**：核心测试在5分钟内完成
- ✅ **失败快停**：一旦发现问题立即停止
- ✅ **环境一致**：使用相同的Docker镜像
- ✅ **可回滚性**：保持多个版本的部署能力

**任务组织策略**：
```yaml
# 合理的Stage划分
stages:
  - validate      # 语法检查、lint（快速，1-2分钟）
  - test         # 单元测试、集成测试（中等，5-10分钟）
  - build        # 构建应用、镜像（较慢，10-15分钟）
  - security     # 安全扫描（可并行，10-20分钟）
  - deploy       # 部署应用（快速，2-5分钟）

# 并行化提速
test_parallel:
  parallel:
    matrix:
      - TEST_TYPE: [unit, integration, e2e]
      - NODE_VERSION: ["16", "18"]
```

**缓存优化策略**：
```yaml
# 分层缓存配置
cache:
  - key: 
      files:
        - package-lock.json              # 依赖变化时更新
    paths:
      - node_modules/
    policy: pull-push                    # 拉取并更新缓存
  
  - key: $CI_COMMIT_REF_SLUG             # 分支级缓存
    paths:
      - .npm/
      - dist/
    policy: pull                         # 只拉取缓存
```

### 10.2 常见问题排查


**问题1：Runner连接失败**
```bash
# 检查Runner状态
sudo gitlab-runner status

# 检查网络连接
curl -I https://gitlab.example.com

# 重新注册Runner
sudo gitlab-runner unregister --name "problem-runner"
sudo gitlab-runner register
```

**问题2：Docker权限问题**
```yaml
# 解决方案1：使用privileged模式
build_job:
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  script:
    - docker build -t test .

# 解决方案2：使用kaniko构建
build_kaniko:
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(echo -n $CI_REGISTRY_USER:$CI_REGISTRY_PASSWORD | base64)\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/Dockerfile --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

**问题3：缓存不生效**
```yaml
# 调试缓存问题
debug_cache:
  script:
    - echo "缓存键: $CI_COMMIT_REF_SLUG"
    - ls -la node_modules/ || echo "缓存未命中"
    - npm ci
    - ls -la node_modules/
  cache:
    key: $CI_COMMIT_REF_SLUG
    paths:
      - node_modules/
    policy: pull-push
```

### 10.3 性能监控与优化


**Pipeline执行时间分析**：
```
分析方法：
1. 查看Pipeline图表：耗时任务一目了然
2. 对比历史数据：识别性能趋势
3. 分解任务耗时：定位瓶颈环节

优化策略：
• 并行化耗时任务
• 优化缓存策略
• 使用更快的Runner
• 减少不必要的依赖安装
```

**监控指标设置**：
```yaml
# 添加性能监控
performance_test:
  script:
    - npm run build
    - echo "构建时间：$(date)"
    - du -sh dist/                       # 输出包大小
    - npm run test:performance
  after_script:
    - echo "任务完成时间：$(date)"
  artifacts:
    reports:
      performance: performance.json      # 性能报告
```

### 10.4 故障恢复策略


**快速回滚配置**：
```yaml
# 自动回滚机制
deploy_production:
  script:
    - ./deploy.sh $CI_COMMIT_SHA
  after_script:
    - |
      if [ $CI_JOB_STATUS == 'failed' ]; then
        echo "部署失败，执行回滚"
        ./rollback.sh
      fi
  environment:
    name: production
    on_stop: stop_production             # 停止环境时的清理任务

# 手动回滚任务
rollback_production:
  stage: deploy
  script:
    - ./rollback.sh $PREVIOUS_VERSION
  when: manual                           # 手动触发
  environment:
    name: production
```

**健康检查集成**：
```yaml
# 部署后健康检查
health_check:
  stage: deploy
  script:
    - sleep 30                           # 等待应用启动
    - curl -f http://myapp.com/health || exit 1
    - ./run-smoke-tests.sh
  dependencies:
    - deploy_production
  retry:
    max: 3                               # 最多重试3次
    when: script_failure
```

## 📋 核心要点总结


### 🎯 必须掌握的关键概念

- **CI/CD流程**：代码提交 → 自动测试 → 自动构建 → 自动部署
- **Runner配置**：选择合适的执行器类型，正确安装和注册
- **Pipeline结构**：Stage、Job、Script的层次关系
- **环境分离**：开发、测试、预发、生产环境的部署策略
- **安全管理**：变量保护、敏感信息处理、安全扫描

### 💡 实践经验要点

- **性能优化**：合理使用缓存，任务并行化，选择轻量级镜像
- **故障处理**：建立监控机制，准备回滚策略，定期检查Runner状态
- **最佳实践**：快速反馈、失败快停、环境一致性、可重复部署

### 🚀 进阶应用方向

- **微服务CI/CD**：多服务协调部署，服务依赖管理
- **多云部署**：跨云平台的一致性部署策略
- **GitOps实践**：基于Git的声明式部署管理

**核心记忆**：GitLab CI/CD让代码变更从提交到部署全程自动化，通过合理配置可以实现高效、安全、可靠的软件交付流程。