---
title: 10、进程间通信机制
---
## 📚 目录

1. [进程间通信概述](#1-进程间通信概述)
2. [管道通信机制](#2-管道通信机制)
3. [System V IPC机制](#3-system-v-ipc机制)
4. [POSIX IPC机制](#4-posix-ipc机制)
5. [信号处理机制](#5-信号处理机制)
6. [现代IPC机制](#6-现代ipc机制)
7. [内核IPC对象管理](#7-内核ipc对象管理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 进程间通信概述


### 1.1 什么是进程间通信


**💡 通俗理解**
```
进程间通信(IPC)就像不同房间的人要说话：
• 同一栋楼的邻居 → 本机进程通信
• 不同城市的朋友 → 网络进程通信
• 传话的方式有很多种 → 多种IPC机制
```

**🎯 核心概念**
- **IPC定义**：Inter-Process Communication，让不同进程之间交换数据和信息
- **核心作用**：突破进程地址空间隔离，实现数据共享和协作
- **应用场景**：多进程程序协作、服务间通信、系统组件交互

### 1.2 IPC机制分类总览


```
Linux IPC机制全景图：

传统UNIX IPC                System V IPC              POSIX IPC
├── 无名管道(pipe)          ├── 信号量(semaphore)      ├── 信号量
├── 命名管道(fifo)          ├── 共享内存(shm)          ├── 共享内存  
└── 信号(signal)            └── 消息队列(msg)          └── 消息队列

现代Linux扩展              网络IPC                   
├── Unix域套接字             ├── TCP/UDP套接字
├── eventfd                 └── 网络套接字
├── signalfd
└── timerfd
```

### 1.3 选择IPC机制的考虑因素


| 考虑因素 | **管道类** | **共享内存** | **消息队列** | **套接字** |
|---------|-----------|------------|------------|-----------|
| **性能** | 🟡 中等 | 🟢 最高 | 🟡 中等 | 🔴 较低 |
| **同步** | 🟢 自然同步 | 🔴 需手动 | 🟢 自然同步 | 🟢 自然同步 |
| **网络** | ❌ 本机only | ❌ 本机only | ❌ 本机only | ✅ 支持 |
| **数据量** | 🟡 中等 | 🟢 大量 | 🟡 中等 | 🟢 任意 |

---

## 2. 🚰 管道通信机制


### 2.1 无名管道(pipe)


**🔸 基本概念**
无名管道就像家里的水管，只能在有血缘关系的进程间使用：

```
父进程创建管道 → fork子进程 → 两个进程通过管道通信

     父进程              子进程
  ┌─────────┐          ┌─────────┐
  │ write() │ ────────▶│ read()  │
  └─────────┘   pipe   └─────────┘
```

**⚙️ pipe()系统调用**
```c
#include <unistd.h>

int pipefd[2];  // 文件描述符数组
int result = pipe(pipefd);

// pipefd[0] - 读端
// pipefd[1] - 写端
```

**💻 实用示例**
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];
    pid_t pid;
    char buffer[100];
    
    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe failed");
        return 1;
    }
    
    pid = fork();
    if (pid == 0) {
        // 子进程 - 读数据
        close(pipefd[1]);  // 关闭写端
        read(pipefd[0], buffer, sizeof(buffer));
        printf("子进程收到: %s\n", buffer);
        close(pipefd[0]);
    } else {
        // 父进程 - 写数据  
        close(pipefd[0]);  // 关闭读端
        write(pipefd[1], "Hello from parent!", 18);
        close(pipefd[1]);
        wait(NULL);  // 等待子进程
    }
    return 0;
}
```

### 2.2 命名管道(FIFO)


**🔸 基本概念**
命名管道就像邮箱，有固定地址，任何进程都能找到：

```
进程A                    FIFO文件                    进程B
┌─────┐                ┌───────────┐                ┌─────┐
│写入 │ ─────────────▶ │ /tmp/myfifo │ ─────────────▶ │读取 │
└─────┘                └───────────┘                └─────┘
```

**⚙️ mkfifo()创建命名管道**
```bash
# 命令行创建
mkfifo /tmp/myfifo

# 程序中创建
#include <sys/stat.h>
mkfifo("/tmp/myfifo", 0666);
```

**📋 pipe vs FIFO对比**

| 特性 | **无名管道** | **命名管道** |
|------|-------------|-------------|
| **创建方式** | `pipe()系统调用` | `mkfifo()或命令` |
| **使用范围** | `父子进程间` | `任意进程间` |
| **文件系统** | `无文件节点` | `有FIFO文件` |
| **生命周期** | `进程结束即消失` | `手动删除` |

**💡 使用场景**
- **无名管道**：shell命令行管道 `ls | grep txt`
- **命名管道**：不相关进程间数据传输、服务间通信

---

## 3. 🏛️ System V IPC机制


### 3.1 System V IPC基础概念


**🔸 什么是System V IPC**
System V IPC是Unix系统提供的三种进程间通信机制：
- **信号量(Semaphore)**：用于进程同步
- **共享内存(Shared Memory)**：用于高效数据共享  
- **消息队列(Message Queue)**：用于消息传递

**🔑 IPC标识机制**
```
每个IPC对象都有唯一标识：

IPC Key → IPC ID → IPC对象
   ↑         ↑         ↑
用户指定   内核分配   实际对象

# 查看系统IPC对象
ipcs        # 查看所有IPC对象
ipcs -s     # 查看信号量
ipcs -m     # 查看共享内存
ipcs -q     # 查看消息队列
```

### 3.2 信号量(Semaphore)机制


**🔸 通俗理解**
信号量就像停车场的车位计数器：
```
停车场有10个车位（信号量值=10）
每进一辆车，计数器-1（P操作/wait）
每出一辆车，计数器+1（V操作/signal）
车位满了(=0)，新车必须等待
```

**⚙️ 信号量操作**
```c
#include <sys/sem.h>

// 创建或获取信号量集
int semget(key_t key, int nsems, int semflg);

// 操作信号量
int semop(int semid, struct sembuf *sops, size_t nsops);

// 控制信号量
int semctl(int semid, int semnum, int cmd, ...);
```

**💻 实用示例**
```c
#include <sys/sem.h>
#include <sys/ipc.h>

// 信号量P操作（减1）
void sem_wait(int semid) {
    struct sembuf op = {0, -1, 0};  // 信号量0减1
    semop(semid, &op, 1);
}

// 信号量V操作（加1）
void sem_signal(int semid) {
    struct sembuf op = {0, 1, 0};   // 信号量0加1  
    semop(semid, &op, 1);
}

int main() {
    key_t key = ftok(".", 1);
    int semid = semget(key, 1, IPC_CREAT | 0666);
    
    // 初始化信号量值为1（互斥锁）
    semctl(semid, 0, SETVAL, 1);
    
    // 进入临界区
    sem_wait(semid);    // P操作
    printf("临界区代码执行\n");
    sem_signal(semid);  // V操作
    
    return 0;
}
```

### 3.3 共享内存(Shared Memory)


**🔸 通俗理解**
共享内存就像多人共用的白板：
```
进程A ←→ 共享内存区域 ←→ 进程B
     直接内存访问，最快的IPC方式
     
注意：需要同步机制避免竞争条件
```

**⚙️ 共享内存操作**
```c
#include <sys/shm.h>

// 创建或获取共享内存
int shmget(key_t key, size_t size, int shmflg);

// 连接共享内存到进程地址空间
void *shmat(int shmid, const void *shmaddr, int shmflg);

// 断开共享内存连接
int shmdt(const void *shmaddr);

// 控制共享内存
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

**💻 实用示例**
```c
#include <sys/shm.h>
#include <sys/ipc.h>
#include <string.h>

int main() {
    key_t key = ftok(".", 1);
    
    // 创建1024字节共享内存
    int shmid = shmget(key, 1024, IPC_CREAT | 0666);
    
    // 连接到进程地址空间
    char *shmaddr = (char*)shmat(shmid, NULL, 0);
    
    // 写入数据
    strcpy(shmaddr, "Hello Shared Memory!");
    
    // 读取数据
    printf("共享内存内容: %s\n", shmaddr);
    
    // 断开连接
    shmdt(shmaddr);
    
    // 删除共享内存（最后一个使用者）
    shmctl(shmid, IPC_RMID, NULL);
    
    return 0;
}
```

### 3.4 消息队列(Message Queue)


**🔸 通俗理解**
消息队列就像邮局的信箱系统：
```
发送者投递带标签的信件 → 邮箱 → 接收者按标签取信

消息类型(type) = 信件标签
消息内容(data) = 信件内容
队列顺序 = FIFO或按类型
```

**⚙️ 消息队列操作**
```c
#include <sys/msg.h>

// 创建或获取消息队列
int msgget(key_t key, int msgflg);

// 发送消息
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

// 接收消息  
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

// 控制消息队列
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

**💻 实用示例**
```c
#include <sys/msg.h>
#include <sys/ipc.h>

// 消息结构体
struct msg_buffer {
    long msg_type;      // 消息类型
    char msg_text[100]; // 消息内容
};

int main() {
    key_t key = ftok(".", 1);
    int msgid = msgget(key, IPC_CREAT | 0666);
    
    struct msg_buffer message;
    
    // 发送消息
    message.msg_type = 1;
    strcpy(message.msg_text, "Hello Message Queue!");
    msgsnd(msgid, &message, sizeof(message.msg_text), 0);
    
    // 接收消息
    msgrcv(msgid, &message, sizeof(message.msg_text), 1, 0);
    printf("收到消息: %s\n", message.msg_text);
    
    // 删除消息队列
    msgctl(msgid, IPC_RMID, NULL);
    
    return 0;
}
```

---

## 4. 🆕 POSIX IPC机制


### 4.1 POSIX vs System V对比


**📊 主要差异**

| 特性 | **System V IPC** | **POSIX IPC** |
|------|-----------------|---------------|
| **命名方式** | `数字key + ID` | `字符串名称` |
| **接口风格** | `专用函数` | `文件操作风格` |
| **可移植性** | `Unix特有` | `POSIX标准` |
| **易用性** | 🟡 复杂 | 🟢 简单 |

**🔸 POSIX IPC优势**
- **更直观**：使用文件路径样式的名称 `/dev/shm/myshm`
- **更简单**：类似文件操作的接口
- **更标准**：跨平台兼容性更好

### 4.2 POSIX共享内存


**⚙️ POSIX共享内存操作**
```c
#include <sys/mman.h>
#include <fcntl.h>

// 创建或打开共享内存对象
int shm_open(const char *name, int oflag, mode_t mode);

// 设置共享内存大小
int ftruncate(int fd, off_t length);

// 映射到进程地址空间
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

// 解除映射
int munmap(void *addr, size_t length);

// 删除共享内存对象
int shm_unlink(const char *name);
```

**💻 实用示例**
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <string.h>

int main() {
    const char *shm_name = "/myshm";
    
    // 创建共享内存对象
    int fd = shm_open(shm_name, O_CREAT | O_RDWR, 0666);
    
    // 设置大小为1024字节
    ftruncate(fd, 1024);
    
    // 映射到内存
    char *addr = mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    
    // 写入数据
    strcpy(addr, "Hello POSIX Shared Memory!");
    
    // 读取数据
    printf("共享内存: %s\n", addr);
    
    // 清理
    munmap(addr, 1024);
    close(fd);
    shm_unlink(shm_name);
    
    return 0;
}
```

### 4.3 POSIX信号量


**🔸 特点对比**
```
System V信号量：信号量集合，功能强大但复杂
POSIX信号量：单个信号量，简单易用

POSIX信号量类型：
• 命名信号量：进程间共享（sem_open）
• 匿名信号量：线程间共享（sem_init）
```

**💻 命名信号量示例**
```c
#include <semaphore.h>
#include <fcntl.h>

int main() {
    const char *sem_name = "/mysem";
    
    // 创建命名信号量，初值为1
    sem_t *sem = sem_open(sem_name, O_CREAT, 0666, 1);
    
    // P操作（等待）
    sem_wait(sem);
    printf("进入临界区\n");
    
    // V操作（信号）
    sem_post(sem);
    
    // 关闭和删除
    sem_close(sem);
    sem_unlink(sem_name);
    
    return 0;
}
```

---

## 5. 📡 信号处理机制


### 5.1 信号基础概念


**🔸 什么是信号**
信号就像生活中的通知方式：
```
电话铃声 = SIGINT（中断信号）
闹钟响起 = SIGALRM（定时器信号）
敲门声音 = SIGUSR1（用户自定义信号）
```

**📋 常用信号类型**
```c
SIGINT  (2)  - Ctrl+C 中断
SIGTERM (15) - 终止请求
SIGKILL (9)  - 强制杀死（不可捕获）
SIGCHLD (17) - 子进程状态改变
SIGALRM (14) - 定时器到期
SIGUSR1 (10) - 用户定义信号1
SIGUSR2 (12) - 用户定义信号2
```

### 5.2 信号处理方式


**⚙️ signal()函数**
```c
#include <signal.h>

// 注册信号处理函数
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

// 预定义处理方式
SIG_DFL  // 默认处理
SIG_IGN  // 忽略信号
```

**💻 信号处理示例**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

// 信号处理函数
void sig_handler(int signo) {
    if (signo == SIGINT) {
        printf("\n收到SIGINT信号，程序退出\n");
        exit(0);
    }
}

int main() {
    // 注册信号处理函数
    signal(SIGINT, sig_handler);
    
    printf("程序运行中，按Ctrl+C测试信号处理\n");
    
    // 无限循环等待信号
    while(1) {
        sleep(1);
        printf("程序正在运行...\n");
    }
    
    return 0;
}
```

### 5.3 信号发送


**⚙️ 发送信号的方法**
```c
#include <signal.h>

// 向指定进程发送信号
int kill(pid_t pid, int sig);

// 向当前进程发送信号
int raise(int sig);

// 设置定时器信号
unsigned int alarm(unsigned int seconds);
```

**🎯 实际应用场景**
- **程序控制**：优雅关闭服务 `kill -TERM <pid>`
- **进程通信**：父子进程协调 `SIGCHLD`
- **异常处理**：段错误捕获 `SIGSEGV`
- **定时任务**：周期性操作 `SIGALRM`

---

## 6. 🔧 现代IPC机制


### 6.1 Unix域套接字


**🔸 基本概念**
Unix域套接字是本机进程间的高效通信方式：
```
特点：
• 只能本机通信（比网络套接字快）
• 支持流式(SOCK_STREAM)和数据报(SOCK_DGRAM)
• 可以传递文件描述符
• 使用文件系统路径作为地址
```

**💻 简单示例**
```c
#include <sys/socket.h>
#include <sys/un.h>

// 创建Unix域套接字
int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

// 设置地址
struct sockaddr_un addr;
addr.sun_family = AF_UNIX;
strcpy(addr.sun_path, "/tmp/mysocket");

// 绑定地址（服务端）
bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));

// 连接地址（客户端）
connect(sockfd, (struct sockaddr*)&addr, sizeof(addr));
```

### 6.2 eventfd机制


**🔸 基本概念**
eventfd是Linux特有的事件通知机制：
```
类似一个计数器：
• 写入数值增加计数器
• 读取返回计数器值并清零
• 可用于线程/进程间事件通知
```

**⚙️ eventfd操作**
```c
#include <sys/eventfd.h>

// 创建eventfd
int eventfd(unsigned int initval, int flags);

// 写入事件
uint64_t value = 1;
write(efd, &value, sizeof(value));

// 读取事件
uint64_t result;
read(efd, &result, sizeof(result));
```

### 6.3 signalfd机制


**🔸 基本概念**
signalfd将信号转换为文件描述符事件：
```
传统信号处理：异步中断，编程复杂
signalfd方式：同步读取，编程简单

信号 → signalfd → read()读取信号信息
```

**💻 使用示例**
```c
#include <sys/signalfd.h>
#include <signal.h>

int main() {
    sigset_t mask;
    int sfd;
    
    // 屏蔽要处理的信号
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigprocmask(SIG_BLOCK, &mask, NULL);
    
    // 创建signalfd
    sfd = signalfd(-1, &mask, 0);
    
    // 同步读取信号
    struct signalfd_siginfo si;
    read(sfd, &si, sizeof(si));
    
    printf("收到信号: %d\n", si.ssi_signo);
    
    close(sfd);
    return 0;
}
```

### 6.4 timerfd机制


**🔸 基本概念**
timerfd将定时器转换为文件描述符事件：
```
传统定时器：信号方式，处理复杂
timerfd方式：文件描述符，可以poll/epoll

定时器到期 → timerfd → read()读取到期次数
```

---

## 7. 🏗️ 内核IPC对象管理


### 7.1 IPC对象生命周期


**🔸 创建过程**
```
用户空间                     内核空间
    │                           │
    ├── msgget()                │
    │   shmget()         ──────▶│ 分配IPC对象
    │   semget()                │ 分配ID
    │                           │ 加入IPC表
    ↓                           ↓
  返回ID                    对象就绪
```

**🔸 内核数据结构**
```c
// 内核中IPC对象的通用结构
struct kern_ipc_perm {
    key_t key;              // IPC键值
    uid_t uid;              // 所有者用户ID
    gid_t gid;              // 所有者组ID
    mode_t mode;            // 权限模式
    unsigned short seq;     // 序列号
};

// 每种IPC类型都有专门结构
struct shmid_kernel;    // 共享内存
struct sem_array;       // 信号量集
struct msg_queue;       // 消息队列
```

### 7.2 IPC对象权限管理


**🔸 权限检查机制**
```
访问权限 = 文件系统类似的权限位

  rwx rwx rwx
  ↑   ↑   ↑
 user group other

权限检查顺序：
1. 检查是否为所有者
2. 检查是否为同组用户  
3. 检查其他用户权限
```

**💻 权限设置示例**
```c
// 创建时设置权限
int shmid = shmget(key, size, IPC_CREAT | 0644);
//                              ↑
//                          rw-r--r--

// 修改权限
struct shmid_ds buf;
shmctl(shmid, IPC_STAT, &buf);      // 获取当前状态
buf.shm_perm.mode = 0666;           // 修改权限
shmctl(shmid, IPC_SET, &buf);       // 设置新权限
```

### 7.3 IPC资源限制


**📊 系统限制参数**
```bash
# 查看IPC限制
cat /proc/sys/kernel/shmmax    # 共享内存段最大大小
cat /proc/sys/kernel/shmall    # 共享内存总页数限制
cat /proc/sys/kernel/shmmni    # 共享内存段数量限制

cat /proc/sys/kernel/sem       # 信号量限制
cat /proc/sys/kernel/msgmax    # 消息最大大小
cat /proc/sys/kernel/msgmnb    # 队列最大字节数
```

**⚙️ 调整系统限制**
```bash
# 临时调整
echo 67108864 > /proc/sys/kernel/shmmax

# 永久调整（/etc/sysctl.conf）
kernel.shmmax = 67108864
kernel.shmall = 4194304
kernel.shmmni = 4096
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 IPC机制分类：管道、System V、POSIX、套接字、现代机制
🔸 选择原则：根据性能、同步、跨网络需求选择合适机制
🔸 管道特点：简单高效，适合父子进程或命令行管道
🔸 共享内存：最快的IPC，但需要额外同步机制
🔸 信号机制：异步通知，用于事件通知和进程控制
```

### 8.2 关键理解要点


**🔹 IPC机制演进脉络**
```
传统Unix IPC → System V IPC → POSIX IPC → 现代Linux扩展

发展趋势：
• 接口越来越简单易用
• 性能不断优化
• 功能更加丰富
• 标准化程度提高
```

**🔹 性能与同步的权衡**
```
性能排序（高到低）：
1. 共享内存（需手动同步）
2. Unix域套接字（自动同步）
3. 管道/消息队列（自动同步）
4. 网络套接字（自动同步）

选择建议：
• 高性能 + 复杂同步 → 共享内存 + 信号量
• 中等性能 + 简单使用 → 管道或套接字
• 跨网络通信 → 网络套接字
```

**🔹 现代IPC的优势**
```
eventfd/signalfd/timerfd优势：
• 统一的文件描述符接口
• 可以使用epoll等I/O复用
• 编程模型更简单一致
• 与现代异步编程框架兼容
```

### 8.3 实际应用场景


**💼 企业级应用选择**
- **Web服务器**：多进程模型用管道或共享内存
- **数据库系统**：共享内存 + 信号量实现缓冲池
- **消息中间件**：消息队列或Unix域套接字
- **系统监控**：信号机制实现优雅关闭和重载配置

**🛠️ 调试和运维**
```bash
# 查看IPC对象
ipcs -a                    # 查看所有IPC对象
lsof -U                    # 查看Unix域套接字
strace -e ipc program      # 跟踪IPC系统调用

# 清理僵尸IPC对象
ipcrm -m <shmid>          # 删除共享内存
ipcrm -s <semid>          # 删除信号量
ipcrm -q <msgid>          # 删除消息队列
```

### 8.4 编程最佳实践


**✅ 推荐做法**
```
1. 错误处理：所有IPC调用都要检查返回值
2. 资源清理：程序退出时清理IPC对象
3. 权限控制：合理设置IPC对象权限
4. 同步机制：共享内存必须配合同步原语
5. 名字管理：使用有意义的IPC对象名称
```

**❌ 常见错误**
```
1. 忘记检查系统调用返回值
2. 程序异常退出后IPC对象残留
3. 共享内存读写竞争条件
4. 信号处理函数中调用不安全函数
5. IPC对象权限设置过于宽松
```

**核心记忆**：
- IPC让进程能够突破地址空间限制进行通信
- 选择IPC机制要考虑性能、同步、跨网络等因素
- 管道简单高效，共享内存最快但需同步
- 现代Linux提供了更简单统一的IPC接口
- 编程时要注意错误处理和资源清理