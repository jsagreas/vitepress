---
title: 6、网络协议栈架构
---
## 📚 目录

1. [网络层次结构与skb数据结构](#1-网络层次结构与skb数据结构)
2. [套接字socket抽象层](#2-套接字socket抽象层)
3. [TCP/IP协议栈实现](#3-TCP-IP协议栈实现)
4. [网络设备驱动接口](#4-网络设备驱动接口)
5. [netfilter框架与钩子点](#5-netfilter框架与钩子点)
6. [网络命名空间隔离](#6-网络命名空间隔离)
7. [网络流量控制tc机制](#7-网络流量控制tc机制)
8. [高性能网络优化技术](#8-高性能网络优化技术)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 网络层次结构与skb数据结构


### 1.1 Linux网络架构概述


**🔸 核心理念**
Linux网络协议栈是一个分层设计的复杂系统，就像一座精密的工厂流水线，每一层都有自己专门的工作职责。

```
📊 **网络协议栈层次结构**：
┌─────────────────────────────┐
│    应用层 (Application)      │ ← 用户程序（浏览器、聊天软件）
├─────────────────────────────┤
│    套接字层 (Socket)         │ ← 系统调用接口（connect、send）
├─────────────────────────────┤
│    传输层 (Transport)        │ ← TCP/UDP协议处理
├─────────────────────────────┤
│    网络层 (Network)          │ ← IP路由转发
├─────────────────────────────┤
│    链路层 (Data Link)        │ ← 以太网帧处理
├─────────────────────────────┤
│    物理层 (Physical)         │ ← 网卡硬件驱动
└─────────────────────────────┘
```

**💡 通俗理解**：
想象寄快递的过程：
- **应用层**：你写的信件内容
- **套接字层**：快递员的服务窗口
- **传输层**：选择顺丰还是圆通（TCP还是UDP）
- **网络层**：规划送货路线（IP路由）
- **链路层**：装进快递箱贴标签（以太网帧）
- **物理层**：实际的交通工具（网线、光纤）

### 1.2 skb数据结构深入解析


**🔸 什么是skb**
`sk_buff`（简称skb）是Linux网络子系统的核心数据结构，可以理解为网络数据包的"万能容器"。

```
🎯 **skb结构示意图**：
┌─────────────────────────────────────┐
│            sk_buff 控制块            │
├─────────────────────────────────────┤
│  head → ┌─────────────────────────┐  │
│        │       headroom          │  │ ← 预留空间
│  data → ├─────────────────────────┤  │
│        │                         │  │
│        │     实际数据载荷        │  │ ← 应用数据
│        │                         │  │
│  tail → ├─────────────────────────┤  │
│        │       tailroom          │  │ ← 预留空间
│  end  → └─────────────────────────┘  │
└─────────────────────────────────────┘
```

**📋 skb核心字段解释**：

| 字段名 | **作用说明** | **通俗比喻** |
|--------|-------------|-------------|
| `head` | 缓冲区起始位置 | 快递箱的底部 |
| `data` | 有效数据起始 | 实际物品的位置 |
| `tail` | 有效数据结束 | 物品的顶部 |
| `end` | 缓冲区结束 | 快递箱的顶部 |
| `len` | 数据总长度 | 物品的重量 |
| `protocol` | 协议类型 | 快递的分类标签 |
| `dev` | 网络设备 | 哪个快递站处理 |

**⚡ skb的生命周期**：
```
创建阶段：alloc_skb() → 分配内存空间
填充阶段：各层协议添加头部信息  
传输阶段：在协议栈间传递
释放阶段：kfree_skb() → 回收内存
```

### 1.3 数据包在协议栈中的流转


**🔄 发送数据的完整流程**：
```
用户程序调用send()
        ↓
     套接字层处理
        ↓
     TCP层添加TCP头
        ↓
     IP层添加IP头
        ↓
     以太网层添加帧头
        ↓
     网卡驱动发送到网络
```

**🎯 每一层的具体工作**：

**应用层 → 套接字层**：
- 用户调用`send()`系统调用
- 数据从用户空间复制到内核空间
- 创建对应的skb结构

**传输层处理**：
- TCP层：添加TCP头部，处理序列号、确认号
- UDP层：添加UDP头部，计算校验和
- 进行拥塞控制和流量控制

**网络层处理**：
- 添加IP头部信息
- 确定下一跳地址
- 进行路由表查找

**链路层处理**：
- 添加以太网帧头
- 进行ARP地址解析
- 处理VLAN标签

---

## 2. 🔌 套接字socket抽象层


### 2.1 socket的本质理解


**🔸 socket是什么**
Socket（套接字）本质上是一个**文件描述符**，它是应用程序和网络协议栈之间的桥梁，就像电话机是你和电话网络之间的接口一样。

```
💡 **socket类比理解**：
电话通讯                    网络通讯
─────────                  ─────────
电话机     ←→    socket套接字
电话号码   ←→    IP地址+端口号
拨号过程   ←→    connect()建立连接
通话内容   ←→    send()/recv()数据传输
挂断电话   ←→    close()关闭连接
```

### 2.2 socket类型与特点


**📊 主要socket类型对比**：

| Socket类型 | **协议** | **特点** | **使用场景** |
|-----------|---------|---------|-------------|
| `SOCK_STREAM` | TCP | 可靠、有序、全双工 | Web服务、文件传输 |
| `SOCK_DGRAM` | UDP | 无连接、快速 | 视频直播、DNS查询 |
| `SOCK_RAW` | 原始 | 直接访问IP层 | 网络诊断工具 |
| `SOCK_UNIX` | 本地 | 进程间通信 | 本机服务通信 |

### 2.3 socket编程基本流程


**🔄 TCP服务器端流程**：
```
socket()     → 创建套接字
     ↓
bind()       → 绑定地址和端口
     ↓
listen()     → 监听连接请求
     ↓
accept()     → 接受客户端连接
     ↓
recv()/send() → 数据收发
     ↓
close()      → 关闭连接
```

**🔄 TCP客户端流程**：
```
socket()     → 创建套接字
     ↓
connect()    → 连接到服务器
     ↓
send()/recv() → 数据收发
     ↓
close()      → 关闭连接
```

### 2.4 socket在内核中的实现


**🏗️ socket内核数据结构**：
```
用户空间的socket文件描述符
         ↓
    内核file结构
         ↓
     socket结构
         ↓
      sock结构
         ↓
    具体协议的sock
   (tcp_sock/udp_sock)
```

**🔸 关键理解要点**：
- **文件系统接口**：socket表现为文件，可以用read/write操作
- **协议无关性**：socket层屏蔽了底层协议差异
- **状态管理**：维护连接状态、缓冲区等信息
- **多路复用**：一个进程可以管理多个socket

---

## 3. 🚀 TCP/IP协议栈实现


### 3.1 TCP协议的内核实现


**🔸 TCP状态机管理**
TCP连接在内核中通过状态机来管理，就像一个精密的自动机器。

```
📊 **TCP状态转换图**：
CLOSED → LISTEN → SYN_RCVD → ESTABLISHED
   ↑                              ↓
   └── CLOSE_WAIT ← FIN_WAIT_1 ←──┘
           ↓            ↓
       LAST_ACK → TIME_WAIT → CLOSED
```

**🎯 各状态的含义**：
- **CLOSED**：初始状态，就像电话机闲置
- **LISTEN**：服务器等待连接，像总机等待来电
- **ESTABLISHED**：连接建立，正在通话中
- **CLOSE_WAIT**：对方关闭连接，等待本地关闭
- **TIME_WAIT**：主动关闭方等待，确保连接彻底结束

### 3.2 TCP拥塞控制算法


**🔸 拥塞控制的必要性**
网络就像高速公路，如果所有车都全速行驶，就会造成交通堵塞。TCP拥塞控制就是网络的"交通管制"。

**📈 主要拥塞控制算法**：

| 算法名称 | **特点** | **适用场景** |
|---------|---------|-------------|
| **慢启动** | 指数增长 | 连接初期探测带宽 |
| **拥塞避免** | 线性增长 | 稳定传输阶段 |
| **快重传** | 快速检测丢包 | 网络偶发错误 |
| **快恢复** | 避免慢启动 | 轻微拥塞时 |

**⚡ 拥塞窗口变化过程**：
```
慢启动阶段：
时间: 0  1  2  3  4  5 秒
窗口: 1→ 2→ 4→ 8→16→32 (指数增长)

拥塞避免阶段：
时间: 5  6  7  8  9  10 秒  
窗口:32→33→34→35→36→37 (线性增长)

发生拥塞：
窗口大小立即减半，重新进入拥塞避免
```

### 3.3 IP层路由实现


**🔸 路由表的作用**
路由表就像城市的交通指示牌，告诉数据包"下一步该往哪里走"。

```
📋 **路由表示例**：
目标网络        网关          接口      跃点数
0.0.0.0/0      192.168.1.1    eth0        1     ← 默认路由
192.168.1.0/24 0.0.0.0        eth0        0     ← 直连路由
10.0.0.0/8     192.168.1.100  eth0        2     ← 静态路由
```

**🔄 IP数据包转发流程**：
```
收到IP数据包
      ↓
检查目标IP地址
      ↓
查找路由表
      ↓
确定下一跳地址
      ↓
更新TTL值
      ↓
重新计算校验和
      ↓
发送到下一跳
```

---

## 4. 🔧 网络设备驱动接口


### 4.1 网络设备抽象模型


**🔸 net_device结构**
在Linux内核中，每个网络设备都用`net_device`结构表示，这就像是网卡的"身份证"。

```
🎯 **网络设备层次结构**：
┌─────────────────────────────┐
│     应用层网络工具           │ ← ifconfig、ip命令
├─────────────────────────────┤
│     内核网络子系统           │ ← net_device管理
├─────────────────────────────┤  
│     设备驱动程序            │ ← e1000、rtl8139等
├─────────────────────────────┤
│     硬件网卡               │ ← 物理网卡芯片
└─────────────────────────────┘
```

**📋 net_device关键字段**：

| 字段名 | **作用** | **通俗解释** |
|--------|---------|-------------|
| `name` | 设备名称 | 网卡的名字（eth0、wlan0） |
| `mtu` | 最大传输单元 | 一次最多能传多少数据 |
| `flags` | 设备状态标志 | 网卡是否启用、是否支持广播 |
| `hard_start_xmit` | 发送函数 | 如何把数据发送出去 |
| `netdev_ops` | 操作函数集 | 网卡支持的各种操作 |

### 4.2 数据包的发送过程


**🚀 发送数据包的完整流程**：
```
协议栈调用dev_queue_xmit()
           ↓
      检查设备状态
           ↓
      调用设备的发送函数
           ↓
      DMA传输到网卡
           ↓
      网卡发送到网络
           ↓
      发送完成中断
```

**💡 关键概念解释**：
- **DMA传输**：让网卡直接从内存读取数据，CPU不参与，提高效率
- **发送队列**：当网卡忙碌时，数据包在队列中等待
- **中断处理**：网卡发送完成后通知CPU

### 4.3 数据包的接收过程


**📥 接收数据包的流程**：
```
网卡收到数据包
       ↓
    产生接收中断
       ↓
   DMA传输到内存
       ↓
  调用netif_rx()函数
       ↓
  放入CPU接收队列
       ↓
  软中断处理数据包
       ↓
  传递给协议栈
```

**⚡ NAPI机制优化**：
传统中断方式在高流量时会产生"中断风暴"，NAPI（New API）机制采用**轮询+中断**的混合方式：
- **低流量**：使用中断方式，及时响应
- **高流量**：切换到轮询方式，减少中断开销

---

## 5. 🛡️ netfilter框架与钩子点


### 5.1 netfilter框架概述


**🔸 什么是netfilter**
netfilter是Linux内核的网络包过滤框架，就像是网络数据包的"检查站"，可以在数据包的传输路径上设置多个检查点。

```
📊 **netfilter钩子点位置**：
          数据包流向
             ↓
    ┌─────── PRE_ROUTING ←──── 从网络设备接收
    │            ↓
    │       路由判断
    │       ↙        ↘
    │   LOCAL_IN    FORWARD ──→ POST_ROUTING ──→ 发送到网络
    │      ↓                        ↑
    │   本地进程                    │
    │      ↓                        │
    └── LOCAL_OUT ──────────────────┘
```

**🎯 五个钩子点的作用**：

| 钩子点 | **位置** | **主要用途** |
|--------|---------|-------------|
| `NF_INET_PRE_ROUTING` | 路由前 | DNAT、端口转发 |
| `NF_INET_LOCAL_IN` | 本地输入 | 输入过滤、防火墙 |
| `NF_INET_FORWARD` | 转发 | 转发控制、QoS |
| `NF_INET_LOCAL_OUT` | 本地输出 | 输出过滤 |
| `NF_INET_POST_ROUTING` | 路由后 | SNAT、流量控制 |

### 5.2 iptables与netfilter的关系


**🔸 iptables的本质**
iptables是netfilter框架的用户空间工具，就像是"遥控器"，用来配置内核中的防火墙规则。

```
💡 **iptables架构关系**：
用户空间：iptables命令 → 配置规则
         ↓
内核空间：netfilter框架 → 执行过滤
         ↓  
网络数据：数据包流转 → 应用规则
```

**📋 iptables表和链的关系**：

| 表名 | **功能** | **包含的链** |
|------|---------|-------------|
| `filter` | 包过滤 | INPUT、FORWARD、OUTPUT |
| `nat` | 地址转换 | PREROUTING、OUTPUT、POSTROUTING |
| `mangle` | 包修改 | 所有链 |
| `raw` | 状态跟踪 | PREROUTING、OUTPUT |

### 5.3 连接跟踪conntrack机制


**🔸 conntrack的作用**
连接跟踪就像是"网络流量的记账员"，记录每个连接的状态信息。

**🔄 连接状态跟踪**：
```
新连接: NEW → 首次数据包
建立连接: ESTABLISHED → 双向有数据包
相关连接: RELATED → 与已知连接相关（如FTP数据连接）
无效连接: INVALID → 不符合协议规范
```

**💼 实际应用场景**：
- **状态防火墙**：只允许已建立连接的回包
- **NAT转换**：记录内外网地址映射关系
- **流量统计**：统计每个连接的流量

---

## 6. 🏢 网络命名空间隔离


### 6.1 网络命名空间概念


**🔸 什么是网络命名空间**
网络命名空间（Network Namespace）是Linux提供的网络隔离机制，就像给每个进程提供一个独立的"网络世界"。

```
🏠 **命名空间隔离示意**：
┌─────────────────────────────────────┐
│          宿主机网络环境              │
│  ┌─────────────┐  ┌─────────────┐   │
│  │   容器A      │  │   容器B      │   │
│  │ eth0:10.1.1.2│  │ eth0:10.1.2.2│   │
│  │ 路由表A      │  │ 路由表B      │   │
│  │ iptables规则A│  │ iptables规则B│   │
│  └─────────────┘  └─────────────┘   │
│           ↓              ↓          │
│        veth pair      veth pair     │
│           ↓              ↓          │
│  ┌─────────────────────────────────┐ │
│  │        虚拟网桥 bridge          │ │
│  └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

### 6.2 网络命名空间的实现原理


**🔧 命名空间的组成部分**：
每个网络命名空间都包含独立的：
- **网络接口**：网卡设备列表
- **路由表**：数据包转发规则
- **ARP表**：IP到MAC地址映射
- **iptables规则**：防火墙配置
- **套接字**：网络连接状态

**⚡ 创建和使用网络命名空间**：
```bash
# 创建网络命名空间
ip netns add container1

# 在命名空间中执行命令
ip netns exec container1 ip link list

# 创建veth虚拟网卡对
ip link add veth0 type veth peer name veth1

# 将veth1移动到命名空间
ip link set veth1 netns container1
```

### 6.3 容器网络实现原理


**🔗 容器网络的典型架构**：
```
容器网络通信流程：
容器A(10.1.1.2) → veth1 → bridge0 → veth2 → 容器B(10.1.1.3)
                     ↓
                  宿主机路由转发
                     ↓
              外部网络(SNAT/DNAT)
```

**💡 关键概念解释**：
- **veth pair**：虚拟网线，连接容器和宿主机
- **bridge**：虚拟交换机，连接多个容器
- **SNAT/DNAT**：地址转换，实现容器访问外网

---

## 7. ⚖️ 网络流量控制tc机制


### 7.1 流量控制的基本概念


**🔸 为什么需要流量控制**
网络带宽是有限资源，就像高速公路的车道数量有限。流量控制（Traffic Control，简称tc）就是网络的"交通管制系统"。

```
📊 **流量控制应用场景**：
┌─────────────────────────────────────┐
│         100Mbps网络带宽              │
├─────────────────────────────────────┤
│ Web服务    ：30Mbps  (高优先级)      │
│ 文件下载   ：40Mbps  (中优先级)      │  
│ 备份传输   ：20Mbps  (低优先级)      │
│ 预留带宽   ：10Mbps  (紧急使用)      │
└─────────────────────────────────────┘
```

### 7.2 tc的组成架构


**🏗️ tc的核心组件**：

**队列规则（qdisc）**：
- **作用**：决定数据包如何排队和调度
- **类比**：银行的排队叫号系统

**分类器（class）**：
- **作用**：将不同类型的流量分类
- **类比**：VIP客户、普通客户的分类

**过滤器（filter）**：
- **作用**：识别和标记数据包
- **类比**：门口的分流指引员

### 7.3 常用队列算法


**📋 主要队列调度算法对比**：

| 算法名称 | **特点** | **适用场景** |
|---------|---------|-------------|
| `FIFO` | 先进先出 | 简单应用，无QoS需求 |
| `SFQ` | 随机公平队列 | 多用户公平共享 |
| `HTB` | 层次化令牌桶 | 复杂带宽分配 |
| `CBQ` | 基于类的队列 | 企业级流量管理 |

**⚡ HTB算法工作原理**：
```
HTB层次结构：
     根类(100Mbps)
      ↙        ↘
  高优先级      低优先级
  (60Mbps)     (40Mbps)
     ↓           ↙    ↘
   Web服务    文件传输  邮件
  (60Mbps)   (30Mbps) (10Mbps)
```

### 7.4 实际配置示例


**🔧 基本流量限制配置**：
```bash
# 为eth0接口添加根队列
tc qdisc add dev eth0 root handle 1: htb default 30

# 创建根类(总带宽100Mbps)
tc class add dev eth0 parent 1: classid 1:1 htb rate 100mbit

# 创建子类(Web服务60Mbps)
tc class add dev eth0 parent 1:1 classid 1:10 htb rate 60mbit ceil 80mbit

# 创建过滤器(匹配80端口流量)
tc filter add dev eth0 parent 1: protocol ip prio 1 u32 \
   match ip dport 80 0xffff flowid 1:10
```

---

## 8. 🚀 高性能网络优化技术


### 8.1 网络性能瓶颈分析


**🔸 常见性能瓶颈**
网络性能就像水管的流量，可能受到多个环节限制：

```
🎯 **网络性能瓶颈点**：
CPU处理能力 ←→ 中断处理频率
     ↓              ↓
内存带宽限制 ←→ 数据复制开销  
     ↓              ↓
网卡处理能力 ←→ 驱动程序效率
     ↓              ↓
网络带宽限制 ←→ 协议栈开销
```

**📊 性能指标含义**：

| 指标名称 | **含义** | **优化目标** |
|---------|---------|-------------|
| **吞吐量** | 单位时间传输数据量 | 越大越好 |
| **延迟** | 数据包传输时间 | 越小越好 |
| **PPS** | 每秒处理包数 | 小包性能指标 |
| **CPU使用率** | 网络处理占用CPU | 越低越好 |

### 8.2 零拷贝技术


**🔸 传统数据复制的问题**
传统网络I/O需要多次数据复制，就像搬家时需要多次装卸：

```
⚡ **传统数据传输路径**：
磁盘文件 → 内核缓冲区 → 用户缓冲区 → socket缓冲区 → 网卡
        ↑ 第1次复制 ↑ 第2次复制 ↑ 第3次复制 ↑ 第4次复制
```

**🚀 零拷贝优化后**：
```
磁盘文件 → 内核缓冲区 → 网卡
        ↑ 直接传输，零次复制
```

**🔧 主要零拷贝技术**：
- **sendfile()**：内核直接传输文件到socket
- **mmap()**：内存映射，减少用户空间复制
- **splice()**：管道传输，避免用户空间参与

### 8.3 多队列网卡技术


**🔸 多队列的优势**
传统单队列网卡就像单车道高速公路，多队列网卡就像多车道，能并行处理：

```
📊 **单队列 vs 多队列对比**：
单队列网卡：
CPU0 ← 所有中断 ← 网卡队列

多队列网卡：
CPU0 ← 中断0 ← 网卡队列0
CPU1 ← 中断1 ← 网卡队列1  
CPU2 ← 中断2 ← 网卡队列2
CPU3 ← 中断3 ← 网卡队列3
```

**⚡ RSS/RPS技术**：
- **RSS**（硬件）：网卡硬件分发数据包到不同队列
- **RPS**（软件）：软件模拟实现多队列分发
- **RFS**：将数据包发送到处理应用的CPU

### 8.4 用户态网络协议栈


**🔸 DPDK技术**
DPDK（Data Plane Development Kit）绕过内核，在用户态直接处理网络数据包：

```
🏎️ **传统协议栈 vs DPDK对比**：
传统方式：
应用程序 → 系统调用 → 内核协议栈 → 网卡驱动 → 网卡

DPDK方式：
应用程序 → DPDK库 → 用户态驱动 → 网卡
```

**🎯 DPDK的核心特性**：
- **轮询模式**：避免中断开销
- **无锁队列**：减少同步开销  
- **大页内存**：减少TLB miss
- **CPU亲和性**：绑定特定CPU核心

### 8.5 网络优化最佳实践


**🔧 系统级优化配置**：
```bash
# 增大网络缓冲区
echo 'net.core.rmem_max = 16777216' >> /etc/sysctl.conf
echo 'net.core.wmem_max = 16777216' >> /etc/sysctl.conf

# 调整TCP缓冲区
echo 'net.ipv4.tcp_rmem = 4096 87380 16777216' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_wmem = 4096 65536 16777216' >> /etc/sysctl.conf

# 启用网络设备多队列
echo 'net.core.netdev_max_backlog = 5000' >> /etc/sysctl.conf
```

**📊 监控和调优工具**：
- **iperf3**：网络带宽测试
- **tcpdump/wireshark**：抓包分析
- **ss/netstat**：连接状态查看
- **ethtool**：网卡参数调整

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 网络层次结构：分层设计，每层职责明确
🔸 skb数据结构：网络数据包的万能容器
🔸 socket抽象层：应用与协议栈的桥梁
🔸 TCP/IP实现：状态机管理、拥塞控制、路由转发
🔸 设备驱动接口：硬件抽象、发送接收流程
🔸 netfilter框架：包过滤、防火墙、NAT实现
🔸 网络命名空间：网络隔离、容器网络基础
🔸 流量控制tc：带宽管理、QoS保证
🔸 性能优化技术：零拷贝、多队列、用户态协议栈
```

### 9.2 关键理解要点


**🔹 Linux网络的设计哲学**：
```
分层抽象：每层只关心自己的职责
模块化设计：组件可替换、可扩展
性能优化：从硬件到软件全链路优化
安全考虑：多层安全防护机制
```

**🔹 数据包的生命周期**：
```
应用层：产生数据
传输层：添加可靠性保证
网络层：添加路由信息
链路层：添加硬件地址
物理层：转换为电信号传输
```

**🔹 网络性能优化思路**：
```
减少复制：零拷贝技术
并行处理：多队列、多CPU
绕过内核：用户态协议栈
智能调度：流量控制、QoS
```

### 9.3 实际应用价值


**💼 工程实践应用**：
- **容器化部署**：理解Docker/K8s网络原理
- **负载均衡器**：基于netfilter实现流量分发
- **网络监控**：使用tc和netfilter进行流量管控
- **高性能服务**：应用DPDK等技术提升网络性能

**🔧 故障排查能力**：
- **连接问题**：理解TCP状态机，分析连接异常
- **性能问题**：识别网络瓶颈，进行针对性优化
- **安全问题**：配置iptables规则，实现网络防护

**🎯 职业发展方向**：
- **系统工程师**：深入理解Linux网络架构
- **云计算开发**：掌握容器网络和微服务通信
- **性能优化专家**：精通网络性能调优技术
- **安全工程师**：熟悉网络安全防护机制

**🧠 核心记忆口诀**：
- 分层设计职责清，skb结构是核心
- socket桥梁连两端，TCP状态要记清  
- netfilter五钩子，namespace隔离强
- tc流控保QoS，性能优化有门道
- 理论实践相结合，网络高手就是你