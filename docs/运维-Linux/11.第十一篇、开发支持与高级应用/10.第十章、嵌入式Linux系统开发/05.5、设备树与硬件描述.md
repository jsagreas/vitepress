---
title: 5、设备树与硬件描述
---
## 📚 目录

1. [设备树基础概念](#1-设备树基础概念)
2. [DTS与DTB文件详解](#2-DTS与DTB文件详解)
3. [硬件资源描述语法](#3-硬件资源描述语法)
4. [常用接口配置详解](#4-常用接口配置详解)
5. [中断控制器配置](#5-中断控制器配置)
6. [时钟树配置管理](#6-时钟树配置管理)
7. [设备树调试与验证](#7-设备树调试与验证)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌳 设备树基础概念


### 1.1 什么是设备树


**设备树（Device Tree）** 就像是硬件设备的"身份证"和"说明书"，它用一种**标准化的文本格式**来描述硬件平台上有哪些设备、这些设备的配置信息以及它们之间的连接关系。

```
传统方式 vs 设备树方式：

传统方式（硬编码）：           设备树方式：
┌─────────────────┐           ┌─────────────────┐
│    内核代码     │           │    内核代码     │
│  ├─硬件信息A    │           │  ├─通用驱动     │
│  ├─硬件信息B    │    ====>  │  ├─设备匹配     │
│  ├─硬件信息C    │           │  └─动态加载     │
│  └─板级代码     │           └─────────────────┘
└─────────────────┘                    ▲
                                       │
                              ┌─────────────────┐
                              │    设备树文件    │
                              │  ├─硬件信息A    │
                              │  ├─硬件信息B    │
                              │  ├─硬件信息C    │
                              │  └─板级配置     │
                              └─────────────────┘
```

### 1.2 设备树的核心作用


**🎯 主要解决的问题：**

- **硬件抽象化**：将硬件信息从内核代码中分离出来
- **平台通用性**：同一个内核可以支持不同的硬件平台  
- **配置灵活性**：修改硬件配置不需要重新编译内核
- **开发效率**：减少重复的板级代码编写

💡 **通俗理解**：就像电脑的设备管理器，告诉操作系统"我有什么硬件，这些硬件怎么配置，如何使用"。

### 1.3 设备树的层次结构


设备树采用**树形层次结构**来组织硬件信息：

```
根节点 (/)
├── cpus                    # CPU节点
│   ├── cpu@0              # 第一个CPU核心
│   └── cpu@1              # 第二个CPU核心
├── memory                 # 内存节点
├── soc                    # 片上系统节点
│   ├── uart@12340000     # 串口控制器
│   ├── i2c@12350000      # I2C控制器
│   └── spi@12360000      # SPI控制器
└── gpio-keys             # GPIO按键
    ├── power-key
    └── volume-key
```

**🔑 关键理解**：
- **节点名称**：`uart@12340000` 中，`uart`是设备类型，`@12340000`是地址
- **层次关系**：子节点继承父节点的属性
- **地址空间**：`@`后面的数字表示设备的物理地址

---

## 2. 📄 DTS与DTB文件详解


### 2.1 DTS文件格式


**DTS（Device Tree Source）** 是设备树的**源代码文件**，使用类似C语言的语法，人类可读可编辑。

```dts
/dts-v1/;                          // 设备树版本声明

/ {                                // 根节点开始
    model = "My Demo Board";       // 板子型号
    compatible = "vendor,board";   // 兼容性字符串
    
    #address-cells = <2>;          // 地址单元格数量
    #size-cells = <1>;             // 大小单元格数量
    
    memory {                       // 内存节点
        device_type = "memory";
        reg = <0x0 0x80000000 0x40000000>;  // 起始地址和大小
    };
    
    uart0: uart@12340000 {         // 串口节点（带标签）
        compatible = "vendor,uart";
        reg = <0x0 0x12340000 0x1000>;
        interrupts = <0 15 4>;
        status = "okay";           // 设备状态
    };
};
```

**📝 语法要点**：
- **属性格式**：`属性名 = 值;`
- **节点格式**：`节点名 { 属性列表 };`
- **标签引用**：`uart0:` 是标签，可以被其他地方引用
- **注释**：使用 `//` 或 `/* */`

### 2.2 DTB文件与编译过程


**DTB（Device Tree Blob）** 是DTS编译后的**二进制文件**，这是内核实际使用的格式。

```
编译流程：
┌─────────────┐    dtc编译器    ┌─────────────┐    bootloader    ┌─────────────┐
│ .dts文件    │   =========>   │ .dtb文件    │   ==========>   │   内核      │
│ (源代码)     │                │ (二进制)     │                │  (运行时)    │
│ 人类可读     │                │ 机器可读     │                │   解析      │
└─────────────┘                └─────────────┘                └─────────────┘
```

**编译命令示例**：
```bash
# 编译单个DTS文件
dtc -I dts -O dtb -o board.dtb board.dts

# 使用内核编译系统
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- board.dtb
```

### 2.3 包含文件机制


为了避免重复代码，设备树支持**文件包含**机制：

```dts
/dts-v1/;

#include "soc-common.dtsi"         // 包含SOC通用配置
#include "board-common.dtsi"       // 包含板级通用配置

/ {
    model = "Specific Board";
    
    // 覆盖或扩展包含文件中的配置
    &uart0 {                       // 引用已定义的节点
        status = "okay";           // 启用设备
        baudrate = <115200>;       // 设置波特率
    };
};
```

**🔍 文件类型说明**：
- **`.dts`文件**：完整的设备树文件
- **`.dtsi`文件**：设备树包含文件（类似C语言的头文件）
- **`&节点名`**：引用和修改已定义的节点

---

## 3. 🔧 硬件资源描述语法


### 3.1 基本属性类型


设备树中的属性有多种数据类型，每种类型有不同的用途：

| 属性类型 | 语法示例 | 含义说明 |
|---------|---------|---------|
| **字符串** | `compatible = "vendor,device";` | 设备兼容性标识 |
| **数字** | `clock-frequency = <24000000>;` | 24MHz时钟频率 |
| **数组** | `reg = <0x0 0x12340000 0x1000>;` | 地址和大小信息 |
| **布尔值** | `interrupt-controller;` | 存在即为真 |
| **引用** | `clocks = <&clk_24m>;` | 引用其他节点 |

### 3.2 地址和大小的表示


**地址空间配置**是设备树的核心概念：

```dts
soc {
    #address-cells = <2>;    // 地址需要2个32位数表示（64位地址）
    #size-cells = <1>;       // 大小需要1个32位数表示
    
    uart@12340000 {
        // reg属性：<地址高32位 地址低32位 大小>
        reg = <0x0 0x12340000 0x1000>;
        //      ↑    ↑         ↑
        //   高32位 低32位    4KB大小
    };
};
```

**💡 理解要点**：
- **`#address-cells`**：子节点地址需要几个数字表示
- **`#size-cells`**：子节点大小需要几个数字表示  
- **`reg`属性**：按照父节点的规则描述地址和大小

### 3.3 兼容性字符串


**`compatible`属性**是设备匹配的关键，它告诉内核使用哪个驱动程序：

```dts
uart0: uart@12340000 {
    compatible = "arm,pl011", "arm,primecell";
    //           ↑ 具体型号   ↑ 通用类型
    reg = <0x0 0x12340000 0x1000>;
};
```

**🎯 匹配优先级**：
1. **精确匹配**：`"arm,pl011"` - 最高优先级
2. **通用匹配**：`"arm,primecell"` - 备选方案
3. **驱动选择**：内核根据优先级选择最匹配的驱动

### 3.4 状态属性


**`status`属性**控制设备的启用状态：

```dts
uart0: uart@12340000 {
    compatible = "arm,pl011";
    reg = <0x0 0x12340000 0x1000>;
    status = "okay";        // 设备可用
};

uart1: uart@12350000 {
    compatible = "arm,pl011";
    reg = <0x0 0x12350000 0x1000>;
    status = "disabled";    // 设备禁用
};
```

**📋 状态值说明**：
- **`"okay"`**：设备可操作使用
- **`"disabled"`**：设备存在但被禁用
- **`"fail"`**：设备不可操作（检测到错误）
- **`"fail-sss"`**：设备不可操作，sss是错误类型

---

## 4. 🔌 常用接口配置详解


### 4.1 GPIO配置


**GPIO（通用输入输出）** 是最常用的硬件接口，用于控制LED、按键等简单设备：

```dts
gpio-controller@12400000 {
    compatible = "vendor,gpio";
    reg = <0x0 0x12400000 0x1000>;
    gpio-controller;                    // 声明为GPIO控制器
    #gpio-cells = <2>;                 // GPIO引用需要2个参数
    
    gpio-ranges = <&pinctrl 0 32 32>;  // GPIO到引脚的映射
};

gpio-leds {
    compatible = "gpio-leds";
    
    power-led {
        label = "power";
        gpios = <&gpio0 5 0>;          // 使用GPIO0的第5脚，正极性
        //       ↑     ↑ ↑
        //    控制器  引脚号 标志
        default-state = "on";
    };
    
    status-led {
        label = "status";  
        gpios = <&gpio0 6 1>;          // 第6脚，负极性（1表示反向）
        default-state = "off";
    };
};
```

**🔑 GPIO参数说明**：
- **第1个参数**：引脚编号
- **第2个参数**：标志位（0=正常，1=反向，2=开漏等）

### 4.2 I2C接口配置


**I2C总线**用于连接各种传感器和外设：

```dts
i2c0: i2c@12350000 {
    compatible = "vendor,i2c";
    reg = <0x0 0x12350000 0x1000>;
    interrupts = <0 20 4>;
    
    #address-cells = <1>;              // I2C设备地址1个数字
    #size-cells = <0>;                 // I2C设备不需要大小信息
    
    clock-frequency = <400000>;        // 400KHz时钟频率
    
    // I2C从设备：温度传感器
    temp-sensor@48 {
        compatible = "ti,tmp102";
        reg = <0x48>;                  // I2C设备地址
        interrupt-parent = <&gpio0>;
        interrupts = <7 2>;            // GPIO7，下降沿触发
    };
    
    // I2C从设备：EEPROM
    eeprom@50 {
        compatible = "atmel,24c256";   
        reg = <0x50>;                  // I2C地址0x50
        pagesize = <64>;               // 页大小64字节
    };
};
```

**📊 I2C配置要点**：
- **时钟频率**：标准100KHz，快速400KHz，高速1MHz
- **设备地址**：7位地址，范围0x08-0x77
- **中断配置**：可选的数据就绪通知

### 4.3 SPI接口配置


**SPI接口**用于高速设备通信，如Flash存储器：

```dts
spi0: spi@12360000 {
    compatible = "vendor,spi";
    reg = <0x0 0x12360000 0x1000>;
    interrupts = <0 25 4>;
    
    #address-cells = <1>;
    #size-cells = <0>;
    
    clocks = <&clk_spi>;
    clock-names = "spiclk";
    
    // SPI Flash存储器
    flash@0 {
        compatible = "jedec,spi-nor";
        reg = <0>;                     // 片选信号CS0
        spi-max-frequency = <25000000>; // 最大25MHz
        spi-cpol;                      // 时钟极性
        spi-cpha;                      // 时钟相位
        
        // Flash分区定义
        partitions {
            compatible = "fixed-partitions";
            #address-cells = <1>;
            #size-cells = <1>;
            
            bootloader@0 {
                label = "bootloader";
                reg = <0x0 0x40000>;   // 0-256KB
                read-only;
            };
            
            kernel@40000 {
                label = "kernel";
                reg = <0x40000 0x200000>; // 256KB-2MB
            };
        };
    };
};
```

**⚙️ SPI配置参数**：
- **`spi-cpol`**：时钟空闲时的极性
- **`spi-cpha`**：数据采样的时钟相位
- **`spi-cs-high`**：片选信号高电平有效

---

## 5. ⚡ 中断控制器配置


### 5.1 中断控制器基础


**中断控制器**负责管理系统中所有的中断信号，它是连接外设和CPU的重要桥梁：

```dts
gic: interrupt-controller@10481000 {
    compatible = "arm,cortex-a9-gic";
    #interrupt-cells = <3>;            // 中断描述需要3个参数
    interrupt-controller;              // 声明为中断控制器
    reg = <0x10481000 0x1000>,         // GIC分发器地址
          <0x10482000 0x1000>;         // GIC CPU接口地址
};
```

### 5.2 中断属性配置


设备的中断配置需要指定**中断控制器**和**中断参数**：

```dts
uart0: uart@12340000 {
    compatible = "arm,pl011";
    reg = <0x0 0x12340000 0x1000>;
    
    interrupt-parent = <&gic>;         // 指定中断控制器
    interrupts = <0 15 4>;            // 中断配置
    //           ↑  ↑  ↑
    //        中断类型 中断号 触发方式
};
```

**🔢 GIC中断参数含义**：
- **第1个参数**：中断类型（0=SPI共享外设中断，1=PPI私有外设中断）
- **第2个参数**：中断号（硬件分配的中断ID）
- **第3个参数**：触发方式（1=上升沿，2=下降沿，4=高电平，8=低电平）

### 5.3 中断优先级与亲和性


```dts
ethernet@12380000 {
    compatible = "vendor,ethernet";
    reg = <0x0 0x12380000 0x10000>;
    
    interrupts = <0 30 4>;             // 基本中断配置
    interrupt-names = "macirq";        // 中断名称
    
    // 多队列网卡的多中断配置
    interrupts-extended = <&gic 0 30 4>,  // RX队列0
                         <&gic 0 31 4>,   // RX队列1  
                         <&gic 0 32 4>;   // TX队列
};
```

---

## 6. 🕐 时钟树配置管理


### 6.1 时钟树结构


**时钟树**描述了系统中所有时钟信号的来源和分发关系：

```
时钟树结构示例：
                 外部晶振 (24MHz)
                      ↓
                 ┌─────────────┐
                 │    PLL      │
                 │ (锁相环)     │
                 └─────────────┘
                      ↓ (480MHz)
           ┌─────────────────────────┐
           ↓                        ↓
      CPU时钟                    总线时钟
     (240MHz)                   (120MHz)
                                     ↓
                          ┌─────────────────┐
                          ↓                ↓
                      外设时钟A          外设时钟B
                     (60MHz)           (30MHz)
```

### 6.2 时钟节点定义


```dts
clocks {
    // 外部晶振
    xtal24m: xtal24m {
        compatible = "fixed-clock";
        clock-frequency = <24000000>;      // 24MHz
        #clock-cells = <0>;               // 不需要参数引用
    };
    
    // PLL时钟
    pll0: pll@12000000 {
        compatible = "vendor,pll";
        reg = <0x12000000 0x1000>;
        clocks = <&xtal24m>;              // 输入时钟
        #clock-cells = <1>;               // 输出多个时钟
        clock-output-names = "pll0-out0", "pll0-out1";
    };
    
    // 时钟分频器
    cpu_clk: cpu-clk {
        compatible = "vendor,divider-clock";
        clocks = <&pll0 0>;               // 来自PLL0的第0路输出
        clock-div = <2>;                  // 2分频
        #clock-cells = <0>;
    };
};
```

### 6.3 设备时钟引用


设备节点通过**`clocks`属性**引用所需的时钟：

```dts
uart0: uart@12340000 {
    compatible = "arm,pl011";
    reg = <0x0 0x12340000 0x1000>;
    
    clocks = <&uart_clk>, <&apb_clk>;     // 引用多个时钟
    clock-names = "uartclk", "apb_pclk";  // 时钟名称对应
    
    // 驱动程序中可以通过名称获取时钟：
    // clk_get(&pdev->dev, "uartclk");
};

i2c0: i2c@12350000 {
    compatible = "vendor,i2c";
    reg = <0x0 0x12350000 0x1000>;
    
    clocks = <&i2c_clk>;                  // 单个时钟引用
    clock-frequency = <400000>;           // 期望的I2C频率
};
```

**🎯 时钟配置要点**：
- **输入时钟**：通过`clocks`属性指定
- **时钟名称**：通过`clock-names`便于驱动程序识别
- **频率控制**：有些设备可以指定期望的工作频率

---

## 7. 🔍 设备树调试与验证


### 7.1 编译时检查


**语法检查**和**基本验证**：

```bash
# 编译时进行语法检查
dtc -I dts -O dtb -o board.dtb board.dts

# 详细的警告信息
dtc -W all -I dts -O dtb -o board.dtb board.dts

# 检查特定的警告类型
dtc -W no-unit_address_vs_reg -I dts -O dtb board.dts
```

**常见编译错误**：
- **语法错误**：缺少分号、括号不匹配
- **地址冲突**：多个设备使用相同的地址范围
- **引用错误**：引用不存在的节点或属性

### 7.2 运行时调试


**查看运行时设备树信息**：

```bash
# 查看当前活动的设备树
ls /proc/device-tree/

# 查看特定节点的属性
cat /proc/device-tree/soc/uart@12340000/compatible

# 查看设备树的完整dump
ls /sys/firmware/devicetree/base/

# 使用debugfs查看设备树
mount -t debugfs debugfs /sys/kernel/debug
cat /sys/kernel/debug/device_tree
```

### 7.3 设备状态验证


**检查设备是否正确识别**：

```bash
# 查看所有平台设备
ls /sys/bus/platform/devices/

# 查看特定设备的驱动绑定
ls -l /sys/bus/platform/devices/12340000.uart/driver

# 查看设备属性
cat /sys/bus/platform/devices/12340000.uart/modalias

# 查看中断分配情况
cat /proc/interrupts

# 查看GPIO使用情况  
cat /sys/kernel/debug/gpio
```

### 7.4 常见问题排查


**🚨 问题排查清单**：

| 问题现象 | 可能原因 | 排查方法 |
|---------|---------|---------|
| **设备未识别** | compatible不匹配 | 检查驱动程序支持的compatible字符串 |
| **地址冲突** | reg属性重叠 | 检查地址映射，确保无重叠 |
| **中断异常** | 中断号错误 | 查看`/proc/interrupts`确认中断分配 |
| **时钟问题** | 时钟引用错误 | 检查时钟树配置和引用关系 |
| **GPIO无效** | 引脚复用冲突 | 检查pinctrl配置和GPIO分配 |

**💡 调试技巧**：
- **单步验证**：逐个启用设备，定位问题设备
- **日志分析**：查看`dmesg`中的设备树相关错误
- **对比验证**：参考工作正常的类似配置

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 设备树本质：硬件信息的标准化描述方式，分离硬件和软件
🔸 DTS/DTB关系：源代码文件和二进制文件，编译转换关系
🔸 节点层次：树形结构组织，地址空间继承，属性覆盖
🔸 兼容性匹配：compatible属性决定驱动选择和设备绑定
🔸 资源描述：地址、中断、时钟、GPIO等硬件资源的标准描述
```

### 8.2 关键理解要点


**🔹 设备树的工作流程**：
```
硬件设计 → DTS编写 → DTB编译 → Bootloader加载 → 内核解析 → 驱动匹配
```

**🔹 地址空间的理解**：
```
理解要点：
- #address-cells和#size-cells定义地址格式
- reg属性必须遵循父节点的地址格式
- 地址映射关系：物理地址 → 虚拟地址
```

**🔹 中断系统的配置**：
```
配置要素：
- interrupt-controller：中断控制器声明
- interrupt-parent：指定中断控制器
- interrupts：中断号和触发方式
- #interrupt-cells：中断描述参数个数
```

### 8.3 实际应用指导


**✅ 最佳实践**：
- **模块化设计**：使用.dtsi文件组织通用配置
- **标准兼容**：使用标准的compatible字符串
- **完整描述**：包含所有必要的硬件信息
- **状态管理**：合理使用status属性控制设备启用

**❌ 常见错误**：
- **地址重叠**：多个设备使用相同的地址空间
- **引用错误**：引用不存在的节点或标签
- **时钟循环**：时钟引用形成循环依赖
- **兼容性问题**：compatible字符串与驱动不匹配

### 8.4 学习建议


**🎯 学习路径**：
1. **基础概念**：理解设备树的作用和基本语法
2. **实践练习**：修改现有的设备树文件
3. **接口配置**：掌握GPIO、I2C、SPI等常用接口
4. **调试技能**：学会使用调试工具排查问题
5. **高级应用**：时钟树、中断控制器等复杂配置

**📚 扩展学习**：
- **Pinctrl子系统**：引脚复用和电气特性配置
- **设备模型**：Linux设备驱动模型与设备树的关系
- **设备树绑定文档**：内核Documentation/devicetree/bindings/

**核心记忆**：
- 设备树是硬件的"说明书"，描述"有什么设备，怎么配置"
- DTS是源码，DTB是目标文件，内核解析DTB工作
- compatible属性是关键，决定使用哪个驱动程序
- 地址、中断、时钟是三大核心资源，必须正确配置
- 调试从编译检查开始，到运行时验证结束