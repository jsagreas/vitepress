---
title: 8ã€å®æ—¶åº”ç”¨å¼€å‘é…ç½®
---
## ğŸ“š ç›®å½•

1. [å®æ—¶åº”ç”¨å¼€å‘åŸºç¡€](#1-å®æ—¶åº”ç”¨å¼€å‘åŸºç¡€)
2. [å®æ—¶è¿›ç¨‹ç¼–ç¨‹æ¥å£](#2-å®æ—¶è¿›ç¨‹ç¼–ç¨‹æ¥å£)
3. [pthreadå®æ—¶å±æ€§è®¾ç½®](#3-pthreadå®æ—¶å±æ€§è®¾ç½®)
4. [ä¿¡å·å¤„ç†å®æ—¶åŒ–é…ç½®](#4-ä¿¡å·å¤„ç†å®æ—¶åŒ–é…ç½®)
5. [å®æ—¶å®šæ—¶å™¨ä½¿ç”¨](#5-å®æ—¶å®šæ—¶å™¨ä½¿ç”¨)
6. [å®æ—¶IPCæœºåˆ¶é€‰æ‹©](#6-å®æ—¶IPCæœºåˆ¶é€‰æ‹©)
7. [ç”¨æˆ·ç©ºé—´å®æ—¶é©±åŠ¨](#7-ç”¨æˆ·ç©ºé—´å®æ—¶é©±åŠ¨)
8. [å®æ—¶åº”ç”¨å†…å­˜ç®¡ç†](#8-å®æ—¶åº”ç”¨å†…å­˜ç®¡ç†)
9. [å®æ—¶åº”ç”¨è°ƒè¯•æ–¹æ³•](#9-å®æ—¶åº”ç”¨è°ƒè¯•æ–¹æ³•)
10. [å®æ—¶åº”ç”¨æ€§èƒ½ä¼˜åŒ–](#10-å®æ—¶åº”ç”¨æ€§èƒ½ä¼˜åŒ–)
11. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#11-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. âš¡ å®æ—¶åº”ç”¨å¼€å‘åŸºç¡€


### 1.1 å®æ—¶ç³»ç»Ÿçš„åŸºæœ¬ç‰¹å¾


**ğŸ”¸ ä»€ä¹ˆæ˜¯å®æ—¶ç³»ç»Ÿ**
```
å®æ—¶ç³»ç»Ÿçš„æ ¸å¿ƒç‰¹å¾ï¼š
ç¡®å®šæ€§å“åº” - ç³»ç»Ÿå¿…é¡»åœ¨è§„å®šæ—¶é—´å†…å®Œæˆä»»åŠ¡
å¯é¢„æµ‹æ€§ - èƒ½å¤Ÿé¢„æµ‹ç³»ç»Ÿçš„è¡Œä¸ºå’Œå“åº”æ—¶é—´
ä½å»¶è¿Ÿ - ä»è¾“å…¥åˆ°è¾“å‡ºçš„å»¶è¿Ÿå¿…é¡»å¾ˆä½
é«˜å¯é æ€§ - ç³»ç»Ÿä¸èƒ½åœ¨å…³é”®æ—¶åˆ»å¤±æ•ˆ

å¸¸è§åº”ç”¨åœºæ™¯ï¼š
- å·¥ä¸šæ§åˆ¶ç³»ç»Ÿï¼šæœºå™¨äººæ§åˆ¶ã€ç”Ÿäº§çº¿è‡ªåŠ¨åŒ–
- éŸ³è§†é¢‘å¤„ç†ï¼šä¸“ä¸šéŸ³é¢‘è®¾å¤‡ã€è§†é¢‘é‡‡é›†
- é€šä¿¡ç³»ç»Ÿï¼šåŸºç«™æ§åˆ¶ã€ç½‘ç»œè®¾å¤‡
- åŒ»ç–—è®¾å¤‡ï¼šå¿ƒè„èµ·æå™¨ã€ç›‘æŠ¤è®¾å¤‡
```

### 1.2 å®æ—¶ç³»ç»Ÿåˆ†ç±»


**ğŸ“Š ç¡¬å®æ—¶ vs è½¯å®æ—¶**

| ç‰¹æ€§ | **ç¡¬å®æ—¶ç³»ç»Ÿ** | **è½¯å®æ—¶ç³»ç»Ÿ** |
|------|----------------|----------------|
| **æ—¶é—´è¦æ±‚** | ç»å¯¹ä¸èƒ½è¶…è¿‡æˆªæ­¢æ—¶é—´ | å¶å°”è¶…æ—¶å¯ä»¥æ¥å— |
| **å¤±è´¥åæœ** | ç³»ç»Ÿç¾éš¾æ€§æ•…éšœ | æ€§èƒ½ä¸‹é™ä½†å¯ç”¨ |
| **å…¸å‹åº”ç”¨** | é£è¡Œæ§åˆ¶ã€æ ¸ååº”å † | å¤šåª’ä½“æ’­æ”¾ã€æ¸¸æˆ |
| **Linuxæ”¯æŒ** | éœ€è¦RT-PREEMPTè¡¥ä¸ | æ ‡å‡†å†…æ ¸åŸºæœ¬æ»¡è¶³ |

### 1.3 Linuxå®æ—¶æ”¯æŒèƒ½åŠ›


**ğŸ”§ RT-PREEMPTå†…æ ¸ç‰¹æ€§**
```
æŠ¢å èƒ½åŠ›å¢å¼ºï¼š
- å†…æ ¸ä»£ç å¤§éƒ¨åˆ†å¯æŠ¢å 
- ä¸­æ–­çº¿ç¨‹åŒ–å¤„ç†
- è‡ªæ—‹é”è½¬æ¢ä¸ºå¯ç¡çœ é”

è°ƒåº¦å™¨æ”¹è¿›ï¼š
- RTè°ƒåº¦ç±»ä¼˜å…ˆçº§æœ€é«˜
- é™ä½è°ƒåº¦å»¶è¿Ÿ
- æ›´ç²¾ç¡®çš„æ—¶é—´ç‰‡æ§åˆ¶

å†…å­˜ç®¡ç†ä¼˜åŒ–ï¼š
- å‡å°‘å†…å­˜åˆ†é…å»¶è¿Ÿ
- é¿å…é¡µé¢äº¤æ¢å½±å“
- å†…å­˜é”å®šæ”¯æŒ
```

---

## 2. ğŸ§µ å®æ—¶è¿›ç¨‹ç¼–ç¨‹æ¥å£


### 2.1 å®æ—¶è°ƒåº¦ç­–ç•¥


**ğŸ“‹ Linuxå®æ—¶è°ƒåº¦ç­–ç•¥ç±»å‹**

```
SCHED_FIFO (å…ˆè¿›å…ˆå‡º)ï¼š
ç‰¹ç‚¹ï¼šåŒä¼˜å…ˆçº§è¿›ç¨‹æŒ‰FIFOé¡ºåºæ‰§è¡Œ
ç”¨é€”ï¼šéœ€è¦ä¸¥æ ¼é¡ºåºæ§åˆ¶çš„ä»»åŠ¡
ä¼˜åŠ¿ï¼šç®€å•å¯é¢„æµ‹
é£é™©ï¼šå¯èƒ½å¯¼è‡´ä½ä¼˜å…ˆçº§è¿›ç¨‹é¥¥é¥¿

SCHED_RR (è½®è½¬è°ƒåº¦)ï¼š
ç‰¹ç‚¹ï¼šåŒä¼˜å…ˆçº§è¿›ç¨‹è½®æµæ‰§è¡Œ
ç”¨é€”ï¼šå¤šä¸ªåŒç­‰é‡è¦çš„å®æ—¶ä»»åŠ¡
ä¼˜åŠ¿ï¼šé¿å…è¿›ç¨‹é¥¥é¥¿
æ—¶é—´ç‰‡ï¼šå¯é…ç½®çš„è½®è½¬æ—¶é—´

SCHED_DEADLINE (æˆªæ­¢æ—¶é—´è°ƒåº¦)ï¼š
ç‰¹ç‚¹ï¼šåŸºäºä»»åŠ¡æˆªæ­¢æ—¶é—´è°ƒåº¦
ç”¨é€”ï¼šå‘¨æœŸæ€§ä»»åŠ¡ï¼Œä¸¥æ ¼æ—¶é—´è¦æ±‚
ä¼˜åŠ¿ï¼šç†è®ºä¸Šæœ€ä¼˜çš„å®æ—¶è°ƒåº¦
è¦æ±‚ï¼šå†…æ ¸3.14+æ”¯æŒ
```

### 2.2 å®æ—¶ä¼˜å…ˆçº§è®¾ç½®


**âš™ï¸ è¿›ç¨‹ä¼˜å…ˆçº§é…ç½®**

å®æ—¶ä¼˜å…ˆçº§èŒƒå›´æ˜¯1-99ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜ï¼š

```c
#include <sched.h>
#include <unistd.h>

// è®¾ç½®å½“å‰è¿›ç¨‹ä¸ºFIFOå®æ—¶è°ƒåº¦
struct sched_param param;
param.sched_priority = 80;  // é«˜ä¼˜å…ˆçº§

if (sched_setscheduler(0, SCHED_FIFO, &param) == -1) {
    perror("è®¾ç½®å®æ—¶è°ƒåº¦å¤±è´¥");
    return -1;
}

// éªŒè¯è®¾ç½®ç»“æœ
int policy = sched_getscheduler(0);
sched_getparam(0, &param);
printf("å½“å‰è°ƒåº¦ç­–ç•¥: %d, ä¼˜å…ˆçº§: %d\n", policy, param.sched_priority);
```

### 2.3 å®æ—¶è¿›ç¨‹æƒé™ç®¡ç†


**ğŸ” æƒé™å’Œèµ„æºé™åˆ¶**

```bash
# æŸ¥çœ‹å®æ—¶è°ƒåº¦æƒé™é™åˆ¶
ulimit -r
# æˆ–è€…
cat /proc/sys/kernel/sched_rt_runtime_us
cat /proc/sys/kernel/sched_rt_period_us

# é€šè¿‡capabilitiesèµ‹äºˆå®æ—¶æƒé™
sudo setcap cap_sys_nice+ep ./realtime_app

# æˆ–è€…é€šè¿‡PAM limitsé…ç½®
echo "@realtime - rtprio 99" >> /etc/security/limits.conf
echo "@realtime - memlock unlimited" >> /etc/security/limits.conf
```

**ğŸ’¡ érootç”¨æˆ·å®æ—¶æƒé™è®¾ç½®**
```bash
# å°†ç”¨æˆ·æ·»åŠ åˆ°audioç»„ï¼ˆé€šå¸¸æœ‰å®æ—¶æƒé™ï¼‰
sudo usermod -a -G audio $USER

# æ£€æŸ¥å½“å‰ç”¨æˆ·çš„æƒé™
id
getpcaps $$
```

---

## 3. ğŸ”€ pthreadå®æ—¶å±æ€§è®¾ç½®


### 3.1 å®æ—¶çº¿ç¨‹åˆ›å»º


**ğŸ§µ pthreadå®æ—¶çº¿ç¨‹é…ç½®**

åˆ›å»ºå…·æœ‰å®æ—¶å±æ€§çš„çº¿ç¨‹éœ€è¦è®¾ç½®çº¿ç¨‹å±æ€§ï¼š

```c
#include <pthread.h>
#include <sched.h>

pthread_t realtime_thread;
pthread_attr_t attr;
struct sched_param param;

// åˆå§‹åŒ–çº¿ç¨‹å±æ€§
pthread_attr_init(&attr);

// è®¾ç½®è°ƒåº¦ç­–ç•¥ä¸ºFIFO
pthread_attr_setschedpolicy(&attr, SCHED_FIFO);

// è®¾ç½®ä¼˜å…ˆçº§
param.sched_priority = 70;
pthread_attr_setschedparam(&attr, &param);

// è®¾ç½®ç»§æ‰¿å±æ€§
pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);

// åˆ›å»ºå®æ—¶çº¿ç¨‹
if (pthread_create(&realtime_thread, &attr, thread_func, NULL) != 0) {
    perror("åˆ›å»ºå®æ—¶çº¿ç¨‹å¤±è´¥");
}

pthread_attr_destroy(&attr);
```

### 3.2 çº¿ç¨‹äº²å’Œæ€§è®¾ç½®


**ğŸ¯ CPUäº²å’Œæ€§ç»‘å®š**

å°†å…³é”®çº¿ç¨‹ç»‘å®šåˆ°ç‰¹å®šCPUæ ¸å¿ƒï¼š

```c
#define _GNU_SOURCE
#include <sched.h>
#include <pthread.h>

void set_thread_affinity(pthread_t thread, int cpu_id) {
    cpu_set_t cpuset;
    
    CPU_ZERO(&cpuset);
    CPU_SET(cpu_id, &cpuset);
    
    int result = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
    if (result != 0) {
        printf("è®¾ç½®CPUäº²å’Œæ€§å¤±è´¥: %d\n", result);
    } else {
        printf("çº¿ç¨‹ç»‘å®šåˆ°CPU %d\n", cpu_id);
    }
}

// åœ¨çº¿ç¨‹å‡½æ•°ä¸­ä½¿ç”¨
void* realtime_worker(void* arg) {
    // å°†å½“å‰çº¿ç¨‹ç»‘å®šåˆ°CPU 2
    set_thread_affinity(pthread_self(), 2);
    
    // å®æ—¶ä»»åŠ¡é€»è¾‘
    while (running) {
        // å…³é”®å®æ—¶å¤„ç†ä»£ç 
    }
    return NULL;
}
```

### 3.3 çº¿ç¨‹æ ˆå¤§å°ä¼˜åŒ–


**ğŸ“ æ ˆç©ºé—´é…ç½®**

å®æ—¶åº”ç”¨éœ€è¦åˆç†é…ç½®æ ˆå¤§å°é¿å…è¿è¡Œæ—¶åˆ†é…ï¼š

```c
// è®¾ç½®çº¿ç¨‹æ ˆå¤§å°
size_t stack_size = 1024 * 1024;  // 1MBæ ˆç©ºé—´
pthread_attr_setstacksize(&attr, stack_size);

// æŸ¥è¯¢ç³»ç»Ÿæ ˆå¤§å°é™åˆ¶
size_t min_stack_size = PTHREAD_STACK_MIN;
printf("æœ€å°æ ˆå¤§å°: %zu bytes\n", min_stack_size);

// é¢„åˆ†é…æ ˆå†…å­˜
char* stack_mem = malloc(stack_size);
if (stack_mem) {
    pthread_attr_setstack(&attr, stack_mem, stack_size);
}
```

---

## 4. ğŸ“¡ ä¿¡å·å¤„ç†å®æ—¶åŒ–é…ç½®


### 4.1 å®æ—¶ä¿¡å·æœºåˆ¶


**ğŸ”¸ å®æ—¶ä¿¡å·çš„ç‰¹ç‚¹**
```
æ ‡å‡†ä¿¡å· vs å®æ—¶ä¿¡å·ï¼š

æ ‡å‡†ä¿¡å·ï¼ˆ1-31ï¼‰ï¼š
- ä¸æ’é˜Ÿï¼ŒåŒç±»ä¿¡å·ä¼šä¸¢å¤±
- æ— æ³•æºå¸¦é¢å¤–æ•°æ®
- ä¿¡å·å¤„ç†å¯èƒ½è¢«ä¸­æ–­

å®æ—¶ä¿¡å·ï¼ˆ34-64ï¼‰ï¼š
- æ”¯æŒæ’é˜Ÿï¼Œä¸ä¼šä¸¢å¤±
- å¯ä»¥æºå¸¦32ä½æ•°æ®
- æŒ‰ä¼˜å…ˆçº§é¡ºåºå¤„ç†
- æ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
```

### 4.2 sigactionå®æ—¶é…ç½®


**âš™ï¸ å®æ—¶ä¿¡å·å¤„ç†å™¨è®¾ç½®**

```c
#include <signal.h>
#include <time.h>

void realtime_signal_handler(int sig, siginfo_t *info, void *context) {
    // è·å–ä¿¡å·æºå¸¦çš„æ•°æ®
    int value = info->si_value.sival_int;
    printf("æ”¶åˆ°å®æ—¶ä¿¡å· %dï¼Œæºå¸¦æ•°æ®: %d\n", sig, value);
    
    // è®°å½•æ—¶é—´æˆ³ç”¨äºå»¶è¿Ÿåˆ†æ
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    
    // å¿«é€Ÿå¤„ç†ï¼Œé¿å…é˜»å¡
}

void setup_realtime_signal() {
    struct sigaction sa;
    
    sa.sa_sigaction = realtime_signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_SIGINFO | SA_RESTART;
    
    // æ³¨å†Œå®æ—¶ä¿¡å·å¤„ç†å™¨
    if (sigaction(SIGRTMIN, &sa, NULL) == -1) {
        perror("æ³¨å†Œå®æ—¶ä¿¡å·å¤„ç†å™¨å¤±è´¥");
    }
}
```

### 4.3 signalfdå¼‚æ­¥ä¿¡å·å¤„ç†


**ğŸ”„ åŒæ­¥ä¿¡å·å¤„ç†æ–¹å¼**

ä½¿ç”¨signalfdå°†ä¿¡å·è½¬æ¢ä¸ºæ–‡ä»¶æè¿°ç¬¦äº‹ä»¶ï¼š

```c
#include <sys/signalfd.h>
#include <unistd.h>

int setup_signalfd() {
    sigset_t mask;
    int sfd;
    
    // å±è”½è¦å¤„ç†çš„ä¿¡å·
    sigemptyset(&mask);
    sigaddset(&mask, SIGRTMIN);
    sigaddset(&mask, SIGRTMIN + 1);
    
    if (pthread_sigmask(SIG_BLOCK, &mask, NULL) == -1) {
        perror("ä¿¡å·å±è”½å¤±è´¥");
        return -1;
    }
    
    // åˆ›å»ºsignalfd
    sfd = signalfd(-1, &mask, SFD_CLOEXEC);
    if (sfd == -1) {
        perror("åˆ›å»ºsignalfdå¤±è´¥");
        return -1;
    }
    
    return sfd;
}

void process_signals(int sfd) {
    struct signalfd_siginfo si;
    ssize_t s;
    
    while ((s = read(sfd, &si, sizeof(si))) > 0) {
        if (si.ssi_signo == SIGRTMIN) {
            printf("å¤„ç†å®æ—¶ä¿¡å·ï¼Œæ•°æ®: %d\n", si.ssi_int);
        }
    }
}
```

---

## 5. â±ï¸ å®æ—¶å®šæ—¶å™¨ä½¿ç”¨


### 5.1 timer_createé«˜ç²¾åº¦å®šæ—¶å™¨


**ğŸ• POSIXå®æ—¶å®šæ—¶å™¨**

timer_createæä¾›äº†æ¯”alarmæ›´ç²¾ç¡®çš„å®šæ—¶åŠŸèƒ½ï¼š

```c
#include <time.h>
#include <signal.h>

timer_t timer_id;
struct sigevent sev;
struct itimerspec timer_spec;

void timer_handler(int sig, siginfo_t *si, void *uc) {
    // å®šæ—¶å™¨åˆ°æœŸå¤„ç†
    printf("å®šæ—¶å™¨è§¦å‘ï¼Œæ—¶é—´æˆ³: %ld\n", time(NULL));
}

int create_realtime_timer() {
    // é…ç½®ä¿¡å·äº‹ä»¶
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = SIGRTMIN;
    sev.sigev_value.sival_ptr = &timer_id;
    
    // åˆ›å»ºå®šæ—¶å™¨
    if (timer_create(CLOCK_MONOTONIC, &sev, &timer_id) == -1) {
        perror("åˆ›å»ºå®šæ—¶å™¨å¤±è´¥");
        return -1;
    }
    
    // è®¾ç½®å®šæ—¶å™¨æ—¶é—´ - æ¯100msè§¦å‘ä¸€æ¬¡
    timer_spec.it_value.tv_sec = 0;
    timer_spec.it_value.tv_nsec = 100000000;  // 100ms
    timer_spec.it_interval.tv_sec = 0;
    timer_spec.it_interval.tv_nsec = 100000000;
    
    // å¯åŠ¨å®šæ—¶å™¨
    if (timer_settime(timer_id, 0, &timer_spec, NULL) == -1) {
        perror("å¯åŠ¨å®šæ—¶å™¨å¤±è´¥");
        return -1;
    }
    
    return 0;
}
```

### 5.2 æ—¶é’Ÿæºé€‰æ‹©


**â° ä¸åŒæ—¶é’Ÿç±»å‹å¯¹æ¯”**

| æ—¶é’Ÿç±»å‹ | **ç‰¹ç‚¹** | **ç”¨é€”** | **å—å½±å“å› ç´ ** |
|----------|----------|----------|----------------|
| **CLOCK_REALTIME** | ç³»ç»Ÿå®æ—¶æ—¶é’Ÿ | ç»å¯¹æ—¶é—´æˆ³ | NTPè°ƒæ•´ã€æ‰‹åŠ¨ä¿®æ”¹ |
| **CLOCK_MONOTONIC** | å•è°ƒé€’å¢æ—¶é’Ÿ | ç›¸å¯¹æ—¶é—´æµ‹é‡ | ç³»ç»Ÿä¼‘çœ  |
| **CLOCK_MONOTONIC_RAW** | åŸå§‹å•è°ƒæ—¶é’Ÿ | ç²¾ç¡®æ—¶é—´æµ‹é‡ | æ— NTPå½±å“ |
| **CLOCK_PROCESS_CPUTIME_ID** | è¿›ç¨‹CPUæ—¶é—´ | æ€§èƒ½æµ‹é‡ | è¿›ç¨‹è°ƒåº¦ |

### 5.3 é«˜åˆ†è¾¨ç‡ç¡çœ 


**ğŸ’¤ ç²¾ç¡®å»¶è¿Ÿæ§åˆ¶**

ä½¿ç”¨clock_nanosleepè¿›è¡Œé«˜ç²¾åº¦å»¶è¿Ÿï¼š

```c
#include <time.h>

// ç²¾ç¡®ç¡çœ å‡½æ•°
int precise_sleep(long nanoseconds) {
    struct timespec req, rem;
    
    req.tv_sec = nanoseconds / 1000000000L;
    req.tv_nsec = nanoseconds % 1000000000L;
    
    // ä½¿ç”¨å•è°ƒæ—¶é’Ÿé¿å…æ—¶é—´è°ƒæ•´å½±å“
    while (clock_nanosleep(CLOCK_MONOTONIC, 0, &req, &rem) == EINTR) {
        req = rem;  // å¤„ç†ä¿¡å·ä¸­æ–­
    }
    
    return 0;
}

// å‘¨æœŸæ€§ä»»åŠ¡ç¤ºä¾‹
void periodic_task() {
    struct timespec next_time;
    long period_ns = 10000000;  // 10mså‘¨æœŸ
    
    clock_gettime(CLOCK_MONOTONIC, &next_time);
    
    while (running) {
        // æ‰§è¡Œå®æ—¶ä»»åŠ¡
        process_realtime_data();
        
        // è®¡ç®—ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
        next_time.tv_nsec += period_ns;
        if (next_time.tv_nsec >= 1000000000L) {
            next_time.tv_sec++;
            next_time.tv_nsec -= 1000000000L;
        }
        
        // ç¡çœ åˆ°ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next_time, NULL);
    }
}
```

---

## 6. ğŸ“¨ å®æ—¶IPCæœºåˆ¶é€‰æ‹©


### 6.1 IPCæœºåˆ¶æ€§èƒ½å¯¹æ¯”


**ğŸ“Š ä¸åŒIPCæ–¹å¼çš„å»¶è¿Ÿç‰¹æ€§**

```
å»¶è¿Ÿæ’åºï¼ˆä»ä½åˆ°é«˜ï¼‰ï¼š
1. å…±äº«å†…å­˜ + è‡ªæ—‹é”      ~100ns
2. æ— åç®¡é“ï¼ˆpipeï¼‰       ~1Î¼s  
3. UnixåŸŸå¥—æ¥å­—          ~2Î¼s
4. æ¶ˆæ¯é˜Ÿåˆ—             ~5Î¼s
5. ç½‘ç»œå¥—æ¥å­—           ~10Î¼s+
6. ä¿¡å·é‡               ~10Î¼s+

é€‰æ‹©åŸåˆ™ï¼š
- æœ€ä½å»¶è¿Ÿï¼šå…±äº«å†…å­˜
- è¿›ç¨‹é—´åŒæ­¥ï¼ševentfd + å…±äº«å†…å­˜
- ç®€å•é€šä¿¡ï¼šç®¡é“
- å¤æ‚æ•°æ®ï¼šUnixåŸŸå¥—æ¥å­—
```

### 6.2 å…±äº«å†…å­˜å®æ—¶é€šä¿¡


**ğŸ”„ é«˜æ•ˆå…±äº«å†…å­˜è®¾è®¡**

```c
#include <sys/mman.h>
#include <semaphore.h>

typedef struct {
    sem_t producer_sem;
    sem_t consumer_sem;
    volatile int write_index;
    volatile int read_index;
    char data[BUFFER_SIZE];
} realtime_ringbuffer_t;

// åˆ›å»ºå®æ—¶å…±äº«å†…å­˜åŒºåŸŸ
realtime_ringbuffer_t* create_rt_shm(const char* name) {
    int fd = shm_open(name, O_CREAT | O_RDWR, 0666);
    if (fd == -1) {
        perror("shm_openå¤±è´¥");
        return NULL;
    }
    
    // è®¾ç½®å…±äº«å†…å­˜å¤§å°
    if (ftruncate(fd, sizeof(realtime_ringbuffer_t)) == -1) {
        perror("ftruncateå¤±è´¥");
        close(fd);
        return NULL;
    }
    
    // æ˜ å°„åˆ°å†…å­˜ï¼Œä½¿ç”¨MAP_LOCKEDé¿å…æ¢é¡µ
    realtime_ringbuffer_t* buffer = mmap(NULL, 
                                        sizeof(realtime_ringbuffer_t),
                                        PROT_READ | PROT_WRITE,
                                        MAP_SHARED,
                                        fd, 0);
    
    if (buffer == MAP_FAILED) {
        perror("mmapå¤±è´¥");
        close(fd);
        return NULL;
    }
    
    // é”å®šå†…å­˜é˜²æ­¢äº¤æ¢
    if (mlock(buffer, sizeof(realtime_ringbuffer_t)) == -1) {
        perror("mlockå¤±è´¥");
    }
    
    close(fd);
    return buffer;
}
```

### 6.3 eventfdäº‹ä»¶é€šçŸ¥


**ğŸ”” è½»é‡çº§äº‹ä»¶é€šçŸ¥æœºåˆ¶**

eventfdæä¾›äº†éå¸¸è½»é‡çš„äº‹ä»¶é€šçŸ¥ï¼š

```c
#include <sys/eventfd.h>

int create_rt_eventfd() {
    // åˆ›å»ºeventfdï¼Œè®¾ç½®ä¸ºä¿¡å·é‡æ¨¡å¼
    int efd = eventfd(0, EFD_SEMAPHORE | EFD_CLOEXEC);
    if (efd == -1) {
        perror("eventfdåˆ›å»ºå¤±è´¥");
        return -1;
    }
    return efd;
}

// ç”Ÿäº§è€…é€šçŸ¥
void notify_consumer(int efd) {
    uint64_t value = 1;
    if (write(efd, &value, sizeof(value)) != sizeof(value)) {
        perror("eventfdå†™å…¥å¤±è´¥");
    }
}

// æ¶ˆè´¹è€…ç­‰å¾…
void wait_notification(int efd) {
    uint64_t value;
    if (read(efd, &value, sizeof(value)) != sizeof(value)) {
        perror("eventfdè¯»å–å¤±è´¥");
    }
}
```

---

## 7. ğŸ”§ ç”¨æˆ·ç©ºé—´å®æ—¶é©±åŠ¨


### 7.1 UIOç”¨æˆ·ç©ºé—´é©±åŠ¨æ¡†æ¶


**ğŸ”¸ UIOæ¡†æ¶åŸºç¡€**
```
UIO (Userspace I/O) ä¼˜åŠ¿ï¼š
- ç¡¬ä»¶è®¿é—®åœ¨ç”¨æˆ·ç©ºé—´å®Œæˆ
- é¿å…å†…æ ¸ç©ºé—´åˆ‡æ¢å¼€é”€
- å®æ—¶æ€§æ›´å¥½ï¼Œå»¶è¿Ÿæ›´ä½
- å¼€å‘è°ƒè¯•æ›´å®¹æ˜“

é€‚ç”¨åœºæ™¯ï¼š
- ä¸“ç”¨ç¡¬ä»¶æ§åˆ¶
- é«˜é€Ÿæ•°æ®é‡‡é›†
- å®æ—¶ä¿¡å·å¤„ç†
- å·¥ä¸šæ§åˆ¶åº”ç”¨
```

### 7.2 å†…å­˜æ˜ å°„ç¡¬ä»¶è®¿é—®


**ğŸ—ºï¸ ç›´æ¥ç¡¬ä»¶å†…å­˜è®¿é—®**

```c
#include <fcntl.h>
#include <sys/mman.h>

typedef struct {
    volatile uint32_t* registers;
    size_t reg_size;
    int fd;
} rt_device_t;

rt_device_t* open_rt_device(const char* device_path) {
    rt_device_t* dev = malloc(sizeof(rt_device_t));
    
    // æ‰“å¼€è®¾å¤‡æ–‡ä»¶
    dev->fd = open(device_path, O_RDWR | O_SYNC);
    if (dev->fd == -1) {
        perror("æ‰“å¼€è®¾å¤‡å¤±è´¥");
        free(dev);
        return NULL;
    }
    
    // è·å–è®¾å¤‡å†…å­˜å¤§å°
    dev->reg_size = 4096;  // é€šå¸¸ä»è®¾å¤‡å±æ€§è·å–
    
    // æ˜ å°„è®¾å¤‡å¯„å­˜å™¨åˆ°ç”¨æˆ·ç©ºé—´
    dev->registers = mmap(NULL, dev->reg_size,
                         PROT_READ | PROT_WRITE,
                         MAP_SHARED,
                         dev->fd, 0);
    
    if (dev->registers == MAP_FAILED) {
        perror("è®¾å¤‡å†…å­˜æ˜ å°„å¤±è´¥");
        close(dev->fd);
        free(dev);
        return NULL;
    }
    
    return dev;
}

// ç›´æ¥å¯„å­˜å™¨æ“ä½œ
void write_register(rt_device_t* dev, int offset, uint32_t value) {
    dev->registers[offset / 4] = value;
    __sync_synchronize();  // å†…å­˜å±éšœç¡®ä¿å†™å…¥å®Œæˆ
}

uint32_t read_register(rt_device_t* dev, int offset) {
    __sync_synchronize();
    return dev->registers[offset / 4];
}
```

### 7.3 ä¸­æ–­å¤„ç†ç”¨æˆ·åŒ–


**âš¡ ç”¨æˆ·ç©ºé—´ä¸­æ–­å¤„ç†**

```c
#include <poll.h>

// ç­‰å¾…UIOè®¾å¤‡ä¸­æ–­
int wait_interrupt(rt_device_t* dev, int timeout_ms) {
    struct pollfd pfd;
    uint32_t interrupt_count;
    
    pfd.fd = dev->fd;
    pfd.events = POLLIN;
    
    // ç­‰å¾…ä¸­æ–­
    int ret = poll(&pfd, 1, timeout_ms);
    if (ret > 0 && (pfd.revents & POLLIN)) {
        // è¯»å–ä¸­æ–­è®¡æ•°å™¨
        if (read(dev->fd, &interrupt_count, sizeof(interrupt_count)) > 0) {
            return interrupt_count;
        }
    }
    
    return -1;
}

// å®æ—¶ä¸­æ–­å¤„ç†å¾ªç¯
void* interrupt_handler_thread(void* arg) {
    rt_device_t* dev = (rt_device_t*)arg;
    
    while (running) {
        int count = wait_interrupt(dev, 1000);
        if (count > 0) {
            // å¤„ç†ä¸­æ–­äº‹ä»¶
            handle_device_interrupt(dev);
            
            // é‡æ–°ä½¿èƒ½ä¸­æ–­
            uint32_t enable = 1;
            write(dev->fd, &enable, sizeof(enable));
        }
    }
    
    return NULL;
}
```

---

## 8. ğŸ’¾ å®æ—¶åº”ç”¨å†…å­˜ç®¡ç†


### 8.1 å†…å­˜é”å®šç­–ç•¥


**ğŸ”’ é˜²æ­¢é¡µé¢äº¤æ¢**

å®æ—¶åº”ç”¨å¿…é¡»é¿å…é¡µé¢äº¤æ¢å¯¼è‡´çš„ä¸ç¡®å®šå»¶è¿Ÿï¼š

```c
#include <sys/mman.h>

int setup_realtime_memory() {
    // é”å®šæ‰€æœ‰å½“å‰å’Œæœªæ¥çš„å†…å­˜é¡µ
    if (mlockall(MCL_CURRENT | MCL_FUTURE) == -1) {
        perror("å†…å­˜é”å®šå¤±è´¥");
        return -1;
    }
    
    // é¢„åˆ†é…æ ˆç©ºé—´é˜²æ­¢è¿è¡Œæ—¶åˆ†é…
    char stack_warmup[1024 * 64];  // 64KBæ ˆé¢„çƒ­
    memset(stack_warmup, 0, sizeof(stack_warmup));
    
    printf("å®æ—¶å†…å­˜é”å®šå®Œæˆ\n");
    return 0;
}

// åº”ç”¨ç»“æŸæ—¶é‡Šæ”¾å†…å­˜é”å®š
void cleanup_realtime_memory() {
    munlockall();
}
```

### 8.2 å†…å­˜æ± ç®¡ç†


**ğŸŠ é¢„åˆ†é…å†…å­˜æ± **

é¿å…è¿è¡Œæ—¶åŠ¨æ€å†…å­˜åˆ†é…ï¼š

```c
#define POOL_SIZE (1024 * 1024)  // 1MBå†…å­˜æ± 
#define BLOCK_SIZE 256

typedef struct memory_block {
    struct memory_block* next;
    char data[BLOCK_SIZE - sizeof(struct memory_block*)];
} memory_block_t;

typedef struct {
    memory_block_t* free_list;
    char* pool_memory;
    size_t total_blocks;
} rt_memory_pool_t;

rt_memory_pool_t* create_rt_memory_pool() {
    rt_memory_pool_t* pool = malloc(sizeof(rt_memory_pool_t));
    
    // åˆ†é…å¤§å—å†…å­˜
    pool->pool_memory = malloc(POOL_SIZE);
    if (!pool->pool_memory) {
        free(pool);
        return NULL;
    }
    
    // é”å®šå†…å­˜æ± 
    if (mlock(pool->pool_memory, POOL_SIZE) == -1) {
        perror("å†…å­˜æ± é”å®šå¤±è´¥");
    }
    
    // åˆå§‹åŒ–ç©ºé—²é“¾è¡¨
    pool->total_blocks = POOL_SIZE / BLOCK_SIZE;
    pool->free_list = NULL;
    
    for (int i = 0; i < pool->total_blocks; i++) {
        memory_block_t* block = (memory_block_t*)(pool->pool_memory + i * BLOCK_SIZE);
        block->next = pool->free_list;
        pool->free_list = block;
    }
    
    return pool;
}

void* rt_malloc(rt_memory_pool_t* pool) {
    if (!pool->free_list) {
        return NULL;  // å†…å­˜æ± è€—å°½
    }
    
    memory_block_t* block = pool->free_list;
    pool->free_list = block->next;
    return block->data;
}

void rt_free(rt_memory_pool_t* pool, void* ptr) {
    if (!ptr) return;
    
    memory_block_t* block = (memory_block_t*)((char*)ptr - sizeof(memory_block_t*));
    block->next = pool->free_list;
    pool->free_list = block;
}
```

### 8.3 å†…å­˜åˆ†é…ç­–ç•¥


**ğŸ“‹ å®æ—¶å†…å­˜åˆ†é…åŸåˆ™**

```
å®æ—¶åº”ç”¨å†…å­˜ç®¡ç†åŸåˆ™ï¼š

1. å¯åŠ¨æ—¶é¢„åˆ†é…ï¼š
   âœ… æ‰€æœ‰éœ€è¦çš„å†…å­˜åœ¨åˆå§‹åŒ–æ—¶åˆ†é…å®Œæˆ
   âœ… ä½¿ç”¨å†…å­˜æ± é¿å…è¿è¡Œæ—¶malloc
   âœ… é¢„çƒ­æ ˆç©ºé—´é˜²æ­¢é¡µé”™è¯¯

2. é¿å…ç³»ç»Ÿè°ƒç”¨ï¼š
   âŒ è¿è¡Œæ—¶ä¸è°ƒç”¨malloc/free
   âŒ é¿å…æ–‡ä»¶I/Oæ“ä½œ
   âŒ å‡å°‘ç³»ç»Ÿè°ƒç”¨æ¬¡æ•°

3. å†…å­˜å¯¹é½ä¼˜åŒ–ï¼š
   âœ… ä½¿ç”¨cache lineå¯¹é½
   âœ… é¿å…false sharing
   âœ… NUMAæ„ŸçŸ¥å†…å­˜åˆ†é…
```

---

## 9. ğŸ› å®æ—¶åº”ç”¨è°ƒè¯•æ–¹æ³•


### 9.1 å»¶è¿Ÿæµ‹é‡å·¥å…·


**ğŸ“Š ç³»ç»Ÿå»¶è¿Ÿåˆ†æ**

```bash
# cyclictest - æœ€å¸¸ç”¨çš„å®æ—¶å»¶è¿Ÿæµ‹è¯•å·¥å…·
cyclictest -t 4 -p 80 -n -i 1000 -l 10000

# å‚æ•°è¯´æ˜ï¼š
# -t 4      : 4ä¸ªæµ‹è¯•çº¿ç¨‹
# -p 80     : å®æ—¶ä¼˜å…ˆçº§80
# -n        : ä½¿ç”¨clock_nanosleep
# -i 1000   : 1000å¾®ç§’é—´éš”
# -l 10000  : è¿è¡Œ10000æ¬¡å¾ªç¯

# åˆ†æç»“æœï¼š
# Min: æœ€å°å»¶è¿Ÿ
# Act: å®é™…å»¶è¿Ÿ  
# Avg: å¹³å‡å»¶è¿Ÿ
# Max: æœ€å¤§å»¶è¿Ÿ
```

### 9.2 å®æ—¶æ€§èƒ½ç›‘æ§


**ğŸ” è¿è¡Œæ—¶æ€§èƒ½ç›‘æ§**

```c
#include <time.h>

typedef struct {
    struct timespec start_time;
    struct timespec end_time;
    long min_latency;
    long max_latency;
    long total_latency;
    int sample_count;
} rt_perf_monitor_t;

rt_perf_monitor_t perf_monitor = {0};

void start_timing() {
    clock_gettime(CLOCK_MONOTONIC, &perf_monitor.start_time);
}

void end_timing() {
    clock_gettime(CLOCK_MONOTONIC, &perf_monitor.end_time);
    
    long latency_ns = (perf_monitor.end_time.tv_sec - perf_monitor.start_time.tv_sec) * 1000000000L +
                     (perf_monitor.end_time.tv_nsec - perf_monitor.start_time.tv_nsec);
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    if (perf_monitor.sample_count == 0) {
        perf_monitor.min_latency = latency_ns;
        perf_monitor.max_latency = latency_ns;
    } else {
        if (latency_ns < perf_monitor.min_latency) {
            perf_monitor.min_latency = latency_ns;
        }
        if (latency_ns > perf_monitor.max_latency) {
            perf_monitor.max_latency = latency_ns;
        }
    }
    
    perf_monitor.total_latency += latency_ns;
    perf_monitor.sample_count++;
}

void print_perf_stats() {
    if (perf_monitor.sample_count == 0) return;
    
    long avg_latency = perf_monitor.total_latency / perf_monitor.sample_count;
    
    printf("æ€§èƒ½ç»Ÿè®¡ (æ ·æœ¬æ•°: %d):\n", perf_monitor.sample_count);
    printf("  æœ€å°å»¶è¿Ÿ: %ld ns\n", perf_monitor.min_latency);
    printf("  å¹³å‡å»¶è¿Ÿ: %ld ns\n", avg_latency);
    printf("  æœ€å¤§å»¶è¿Ÿ: %ld ns\n", perf_monitor.max_latency);
}
```

### 9.3 è°ƒåº¦è·Ÿè¸ªåˆ†æ


**ğŸ“ˆ å†…æ ¸è°ƒåº¦è¡Œä¸ºåˆ†æ**

```bash
# å¯ç”¨å†…æ ¸è°ƒåº¦è·Ÿè¸ª
echo 1 > /sys/kernel/debug/tracing/events/sched/enable

# è·Ÿè¸ªç‰¹å®šè¿›ç¨‹
echo $PID > /sys/kernel/debug/tracing/set_ftrace_pid

# å¼€å§‹è·Ÿè¸ª
echo 1 > /sys/kernel/debug/tracing/tracing_on

# è¿è¡Œå®æ—¶åº”ç”¨...

# åœæ­¢è·Ÿè¸ª
echo 0 > /sys/kernel/debug/tracing/tracing_on

# æŸ¥çœ‹è·Ÿè¸ªç»“æœ
cat /sys/kernel/debug/tracing/trace | head -50

# ä½¿ç”¨trace-cmdå·¥å…·è¿›è¡Œæ›´è¯¦ç»†åˆ†æ
trace-cmd record -e sched_switch -e sched_wakeup ./realtime_app
trace-cmd report
```

---

## 10. âš¡ å®æ—¶åº”ç”¨æ€§èƒ½ä¼˜åŒ–


### 10.1 CPUéš”ç¦»é…ç½®


**ğŸ”’ ä¸“ç”¨CPUæ ¸å¿ƒéš”ç¦»**

```bash
# åœ¨å†…æ ¸å¯åŠ¨å‚æ•°ä¸­éš”ç¦»CPUæ ¸å¿ƒ
# /etc/default/grub
GRUB_CMDLINE_LINUX="isolcpus=2,3 nohz_full=2,3 rcu_nocbs=2,3"

# æ›´æ–°grubé…ç½®
sudo update-grub

# è¿è¡Œæ—¶æ£€æŸ¥éš”ç¦»çŠ¶æ€
cat /sys/devices/system/cpu/isolated
cat /sys/devices/system/cpu/nohz_full

# å°†å®æ—¶åº”ç”¨ç»‘å®šåˆ°éš”ç¦»çš„CPU
taskset -c 2 ./realtime_app
```

### 10.2 ä¸­æ–­äº²å’Œæ€§ä¼˜åŒ–


**ğŸ¯ ä¸­æ–­å¤„ç†ä¼˜åŒ–**

```bash
# æŸ¥çœ‹ä¸­æ–­åˆ†å¸ƒ
cat /proc/interrupts

# å°†ç½‘å¡ä¸­æ–­ç»‘å®šåˆ°ç‰¹å®šCPU
echo 1 > /proc/irq/24/smp_affinity

# ç¦ç”¨irqbalanceæœåŠ¡é¿å…ä¸­æ–­è¿ç§»
sudo systemctl stop irqbalance
sudo systemctl disable irqbalance

# æŸ¥çœ‹å½“å‰ä¸­æ–­äº²å’Œæ€§è®¾ç½®
for irq in /proc/irq/*/smp_affinity; do
    echo "$irq: $(cat $irq)"
done
```

### 10.3 ç³»ç»Ÿè°ƒä¼˜å‚æ•°


**âš™ï¸ å†…æ ¸å‚æ•°ä¼˜åŒ–**

```bash
# åˆ›å»ºå®æ—¶ç³»ç»Ÿè°ƒä¼˜è„šæœ¬
cat > /etc/sysctl.d/99-realtime.conf << 'EOF'
# è™šæ‹Ÿå†…å­˜å‚æ•°
vm.swappiness = 1
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5

# ç½‘ç»œç¼“å†²åŒº
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216

# è°ƒåº¦å™¨å‚æ•°
kernel.sched_rt_runtime_us = 950000
kernel.sched_rt_period_us = 1000000

# å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢
kernel.sched_migration_cost_ns = 5000000
EOF

# åº”ç”¨é…ç½®
sudo sysctl -p /etc/sysctl.d/99-realtime.conf
```

---

## 11. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 11.1 å¿…é¡»æŒæ¡çš„åŸºæœ¬æ¦‚å¿µ


```
ğŸ”¸ å®æ—¶è°ƒåº¦ï¼šFIFOã€RRã€DEADLINEä¸‰ç§ç­–ç•¥çš„åŒºåˆ«å’Œåº”ç”¨
ğŸ”¸ å®æ—¶ä¼˜å…ˆçº§ï¼š1-99çš„ä¼˜å…ˆçº§è®¾ç½®å’Œæƒé™ç®¡ç†
ğŸ”¸ pthreadå®æ—¶å±æ€§ï¼šçº¿ç¨‹è°ƒåº¦ç­–ç•¥ã€ä¼˜å…ˆçº§ã€CPUäº²å’Œæ€§
ğŸ”¸ å®æ—¶ä¿¡å·ï¼šå®æ—¶ä¿¡å·é˜Ÿåˆ—ã€signalfdå¼‚æ­¥å¤„ç†
ğŸ”¸ é«˜ç²¾åº¦å®šæ—¶å™¨ï¼štimer_createã€clock_nanosleepçš„ä½¿ç”¨
ğŸ”¸ å®æ—¶IPCï¼šå…±äº«å†…å­˜ã€eventfdç­‰ä½å»¶è¿Ÿé€šä¿¡æ–¹å¼
ğŸ”¸ å†…å­˜ç®¡ç†ï¼šmlockallã€å†…å­˜æ± ã€é¿å…åŠ¨æ€åˆ†é…
ğŸ”¸ æ€§èƒ½è°ƒè¯•ï¼šcyclictestã€å»¶è¿Ÿæµ‹é‡ã€è°ƒåº¦è·Ÿè¸ª
```

### 11.2 å…³é”®å®è·µè¦ç‚¹


**ğŸ”¹ å®æ—¶æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**
```
ç³»ç»Ÿçº§ä¼˜åŒ–ï¼š
âœ… ä½¿ç”¨RT-PREEMPTå†…æ ¸
âœ… é…ç½®CPUéš”ç¦»å’Œä¸­æ–­äº²å’Œæ€§
âœ… ç¦ç”¨ä¸å¿…è¦çš„ç³»ç»ŸæœåŠ¡
âœ… ä¼˜åŒ–å†…æ ¸å‚æ•°

åº”ç”¨çº§ä¼˜åŒ–ï¼š
âœ… åˆç†è®¾ç½®å®æ—¶ä¼˜å…ˆçº§
âœ… é”å®šæ‰€æœ‰å†…å­˜é¿å…é¡µé¢äº¤æ¢
âœ… ä½¿ç”¨å†…å­˜æ± é¿å…è¿è¡Œæ—¶åˆ†é…
âœ… é€‰æ‹©åˆé€‚çš„IPCæœºåˆ¶
```

**ğŸ”¹ å¸¸è§é—®é¢˜é¿å…**
```
æƒé™é—®é¢˜ï¼š
âŒ å¿˜è®°è®¾ç½®å®æ—¶è°ƒåº¦æƒé™
âŒ æ²¡æœ‰åŠ å…¥realtimeç”¨æˆ·ç»„

å†…å­˜é—®é¢˜ï¼š
âŒ è¿è¡Œæ—¶åŠ¨æ€å†…å­˜åˆ†é…
âŒ å¿˜è®°é”å®šå†…å­˜å¯¼è‡´é¡µé¢äº¤æ¢

è°ƒåº¦é—®é¢˜ï¼š
âŒ ä¼˜å…ˆçº§è®¾ç½®ä¸å½“å¯¼è‡´ç³»ç»Ÿæ— å“åº”
âŒ é•¿æ—¶é—´å ç”¨CPUä¸é‡Šæ”¾
```

### 11.3 å¼€å‘æœ€ä½³å®è·µ


**ğŸ’¡ å®æ—¶åº”ç”¨å¼€å‘æŒ‡å—**
```
è®¾è®¡é˜¶æ®µï¼š
1. æ˜ç¡®å®æ—¶æ€§è¦æ±‚ï¼ˆç¡¬å®æ—¶ vs è½¯å®æ—¶ï¼‰
2. é€‰æ‹©åˆé€‚çš„è°ƒåº¦ç­–ç•¥å’Œä¼˜å…ˆçº§
3. è®¾è®¡ç¡®å®šæ€§çš„ç®—æ³•å’Œæ•°æ®ç»“æ„
4. é¢„ä¼°å†…å­˜éœ€æ±‚å’ŒCPUä½¿ç”¨ç‡

å®ç°é˜¶æ®µï¼š
1. åˆå§‹åŒ–æ—¶å®Œæˆæ‰€æœ‰å†…å­˜åˆ†é…
2. é¿å…ä½¿ç”¨å¯èƒ½é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨
3. å®ç°ç²¾ç¡®çš„æ—¶é—´æ§åˆ¶æœºåˆ¶
4. è®¾è®¡ä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

æµ‹è¯•é˜¶æ®µï¼š
1. ä½¿ç”¨cyclictestç­‰å·¥å…·æµ‹é‡å»¶è¿Ÿ
2. è¿›è¡Œé•¿æœŸç¨³å®šæ€§æµ‹è¯•
3. éªŒè¯åœ¨é«˜è´Ÿè½½ä¸‹çš„å®æ—¶æ€§èƒ½
4. æµ‹è¯•é”™è¯¯æƒ…å†µä¸‹çš„ç³»ç»Ÿè¡Œä¸º
```

### 11.4 å®é™…åº”ç”¨å»ºè®®


**ğŸ¯ ä¸åŒåœºæ™¯çš„å®ç°é‡ç‚¹**
```
éŸ³é¢‘å¤„ç†åº”ç”¨ï¼š
- ä½¿ç”¨SCHED_FIFOè°ƒåº¦ç­–ç•¥
- è®¾ç½®é€‚ä¸­çš„å®æ—¶ä¼˜å…ˆçº§ï¼ˆ70-80ï¼‰
- ä½¿ç”¨ç¯å½¢ç¼“å†²åŒºç®¡ç†éŸ³é¢‘æ•°æ®
- é…ç½®ä½å»¶è¿ŸéŸ³é¢‘é©±åŠ¨

å·¥ä¸šæ§åˆ¶ç³»ç»Ÿï¼š
- ä½¿ç”¨SCHED_DEADLINEä¸ºå‘¨æœŸæ€§ä»»åŠ¡è°ƒåº¦
- å®ç°ç¡®å®šæ€§çš„æ§åˆ¶ç®—æ³•
- ä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œé«˜é€Ÿæ•°æ®äº¤æ¢
- é…ç½®çœ‹é—¨ç‹—æœºåˆ¶ä¿è¯ç³»ç»Ÿå¯é æ€§

æ•°æ®é‡‡é›†ç³»ç»Ÿï¼š
- ä½¿ç”¨UIOæ¡†æ¶ç›´æ¥è®¿é—®ç¡¬ä»¶
- å®ç°ç”¨æˆ·ç©ºé—´ä¸­æ–­å¤„ç†
- ä½¿ç”¨å†…å­˜æ˜ å°„å‡å°‘æ•°æ®æ‹·è´
- é…ç½®ä¸“ç”¨CPUæ ¸å¿ƒå¤„ç†å…³é”®ä»»åŠ¡
```

**æ ¸å¿ƒè®°å¿†è¦ç‚¹**ï¼š
- å®æ—¶åº”ç”¨çš„å…³é”®æ˜¯å¯é¢„æµ‹æ€§å’Œç¡®å®šæ€§
- å†…å­˜é”å®šå’Œé¢„åˆ†é…æ˜¯å®æ—¶æ€§èƒ½çš„åŸºç¡€
- é€‰æ‹©åˆé€‚çš„è°ƒåº¦ç­–ç•¥å’Œä¼˜å…ˆçº§è‡³å…³é‡è¦  
- ç³»ç»Ÿçº§è°ƒä¼˜å’Œåº”ç”¨çº§ä¼˜åŒ–éœ€è¦åè°ƒé…åˆ
- å……åˆ†çš„æµ‹è¯•å’Œç›‘æ§æ˜¯ä¿è¯å®æ—¶æ€§èƒ½çš„å¿…è¦æ‰‹æ®µ