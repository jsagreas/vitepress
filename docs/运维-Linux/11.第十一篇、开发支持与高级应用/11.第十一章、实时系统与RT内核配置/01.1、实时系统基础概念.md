---
title: 1、实时系统基础概念
---
## 📚 目录

1. [实时系统基础概念](#1-实时系统基础概念)
2. [实时系统分类与特点](#2-实时系统分类与特点)
3. [延迟类型与性能指标](#3-延迟类型与性能指标)
4. [实时应用场景分析](#4-实时应用场景分析)
5. [Linux内核实时性分析](#5-linux内核实时性分析)
6. [RT-Preempt补丁机制](#6-rt-preempt补丁机制)
7. [实时系统性能评估](#7-实时系统性能评估)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 实时系统基础概念


### 1.1 什么是实时系统


**🔸 实时系统定义**
实时系统是指系统的正确性不仅取决于计算结果的逻辑正确性，还取决于产生结果的时间。简单说，就是**必须在规定时间内完成任务的系统**。

```
生活类比：
普通系统 = 做作业，做对就行，早晚交都可以
实时系统 = 考试答题，不仅要做对，还必须在规定时间内完成
```

**💡 关键理解要点**
- **时间约束**：有明确的时间期限要求
- **确定性**：响应时间必须可预测
- **可靠性**：错过时间期限可能造成严重后果

### 1.2 实时系统核心特征


**🎯 必须具备的特征**

| 特征 | **含义** | **重要性** |
|------|----------|-----------|
| **时间确定性** | `响应时间可预测，有上界限制` | `⭐⭐⭐⭐⭐` |
| **高可靠性** | `系统故障率极低，稳定运行` | `⭐⭐⭐⭐⭐` |
| **实时调度** | `任务按优先级和时间要求调度` | `⭐⭐⭐⭐` |
| **资源管理** | `内存、CPU等资源精确控制` | `⭐⭐⭐⭐` |

**🔍 深入理解**
```
传统系统关注：吞吐量 > 响应时间
实时系统关注：响应时间 > 吞吐量

例子：
网页加载慢点没关系，但汽车刹车系统绝不能延迟！
```

### 1.3 实时性的本质要求


**⏰ 确定性响应时间**
```
确定性 = 可预测的最坏情况执行时间

不是要求"快"，而是要求"准时"：
✅ 规定10ms内完成，每次都在8-9ms内完成 → 好的实时系统
❌ 通常1ms完成，偶尔20ms → 差的实时系统
```

**🎯 一分钟掌握**
实时系统三个核心：
1. **时间约束**：必须在规定时间内完成
2. **确定性**：响应时间可预测
3. **可靠性**：绝不能错过时间期限

---

## 2. 🏷️ 实时系统分类与特点


### 2.1 硬实时系统（Hard Real-time）


**🔸 硬实时定义**
错过任何一个时间期限都是**系统失效**，可能导致灾难性后果。

```
硬实时特点：
• 时间期限是绝对的，不可违反
• 错过期限 = 系统失效
• 通常涉及安全关键应用
• 需要100%的时间保证
```

**🚨 典型应用场景**
```
汽车安全系统：
┌─ 传感器检测 ─┐    ┌─ 控制决策 ─┐    ┌─ 执行动作 ─┐
│  碰撞信号     │ →  │ 5ms内处理  │ →  │ 气囊弹出   │
└──────────────┘    └────────────┘    └────────────┘
错过5ms = 可能危及生命

飞行控制系统：
传感器数据 → 飞控计算 → 舵面控制
    1ms       2ms        1ms
总计4ms，错过 = 飞机失控
```

### 2.2 软实时系统（Soft Real-time）


**🔸 软实时定义**
偶尔错过时间期限是**可接受的**，但会降低系统性能或用户体验。

```
软实时特点：
• 时间期限是期望值，不是绝对要求
• 错过期限 = 性能下降，但系统继续工作
• 允许一定比例的期限错过
• 追求尽可能好的响应时间
```

**🎮 典型应用场景**
```
音频播放系统：
音频缓冲区 → 解码处理 → 音频输出
              10ms内
错过 = 音频卡顿，但不会系统崩溃

在线游戏：
用户输入 → 游戏逻辑 → 画面渲染
           16ms内（60fps）
错过 = 帧率下降，游戏体验变差
```

### 2.3 硬实时 vs 软实时对比


| 对比项 | **硬实时** | **软实时** |
|--------|-----------|-----------|
| **期限性质** | `绝对不可违反` | `期望值，可偶尔违反` |
| **失效后果** | `系统失效/安全事故` | `性能下降/体验变差` |
| **应用领域** | `安全关键系统` | `多媒体/游戏/通信` |
| **设计复杂度** | `极高，需要严格验证` | `中等，追求最佳努力` |
| **成本** | `非常高` | `相对较低` |

**🏠 生活类比**
```
硬实时 = 救护车：必须在黄金时间内到达，晚了可能救不回来
软实时 = 外卖：希望30分钟内送到，晚点送到也能吃，就是体验差点
```

---

## 3. ⏱️ 延迟类型与性能指标


### 3.1 延迟类型详解


**📊 调度延迟（Scheduling Latency）**
```
定义：从任务变为可运行状态到实际开始执行的时间

产生原因：
• 当前有更高优先级任务在运行
• 调度器需要时间选择下一个任务
• 上下文切换开销

调度延迟示例：
任务A正在运行 → 高优先级任务B到达 → 调度器介入 → 任务B开始执行
                                    ├─ 这段时间就是调度延迟 ─┤
```

**⚡ 中断延迟（Interrupt Latency）**
```
定义：从硬件中断信号到达到中断服务程序开始执行的时间

影响因素：
• CPU当前是否禁用中断
• 中断控制器处理时间
• 内核中断处理准备时间

中断延迟流程：
硬件中断信号 → CPU接收 → 保存现场 → 跳转到中断处理程序
             ├────── 中断延迟 ──────┤
```

**🔄 抢占延迟（Preemption Latency）**
```
定义：内核在临界区中无法被抢占的最长时间

临界区示例：
• 持有自旋锁的代码段
• 禁用抢占的内核代码
• 原子操作序列

抢占延迟影响：
高优先级任务 → 等待内核退出临界区 → 才能被调度
              ├─── 抢占延迟 ────┤
```

### 3.2 实时性能指标


**📈 核心性能指标**

| 指标 | **含义** | **计算方法** | **期望值** |
|------|----------|-------------|-----------|
| **最大延迟** | `最坏情况下的响应时间` | `max(所有延迟测量值)` | `< 时间期限` |
| **平均延迟** | `平均响应时间` | `sum(延迟)/测量次数` | `越小越好` |
| **延迟抖动** | `延迟时间的变化程度` | `标准差或方差` | `越小越好` |
| **期限错过率** | `错过时间期限的比例` | `错过次数/总任务数` | `硬实时=0%` |

**📊 延迟测量示例**
```
测量1000次任务执行的延迟时间：
测量结果：[2ms, 3ms, 2ms, 15ms, 3ms, 2ms, ...]

最大延迟 = 15ms
平均延迟 = 3.2ms
延迟抖动 = 2.1ms（标准差）

评估：如果时间期限是10ms
期限错过率 = 0%（所有延迟都小于10ms）
```

### 3.3 延迟的相互关系


**🔗 延迟链路图**
```
总响应延迟 = 中断延迟 + 调度延迟 + 执行时间 + 抢占延迟

外部事件 → 中断处理 → 任务唤醒 → 任务调度 → 任务执行 → 完成
    │        │         │         │         │        │
    └─中断延迟─┘         │         │         │        │
             └──调度延迟──┘         │         │        │
                       └─抢占延迟─┘         │        │
                                 └─执行时间─┘        │
         └─────────────────总响应延迟─────────────────┘
```

**⚠️ 注意事项**
```
常见误区：
❌ 只关注平均延迟，忽略最大延迟
❌ 只测试理想情况，不考虑最坏情况
❌ 混淆吞吐量和实时性

正确做法：
✅ 重点关注最大延迟和抖动
✅ 进行长时间压力测试
✅ 考虑系统负载对实时性的影响
```

---

## 4. 🎮 实时应用场景分析


### 4.1 工业控制系统


**🏭 工控系统实时要求**
```
典型工控场景：
生产线控制：传感器 → PLC控制器 → 执行器
           └─ 1-10ms响应时间要求 ─┘

机器人控制：位置反馈 → 运动控制 → 电机驱动
           └─ 0.1-1ms响应时间要求 ─┘
```

**📋 工控实时性要求**
- **确定性**：每个控制周期必须准时执行
- **高可靠性**：故障可能导致设备损坏或安全事故
- **长期稳定**：工业设备需要连续运行数月甚至数年

```
实际案例：汽车生产线焊接机器人
时间要求：每个焊点控制周期 = 500μs
后果：延迟超过1ms可能导致焊接质量问题
解决方案：专用实时控制器 + RT内核
```

### 4.2 音频处理系统


**🎵 音频系统实时特点**
```
音频实时处理链：
音频输入 → A/D转换 → 数字处理 → D/A转换 → 音频输出
         └─────── 低延迟处理要求 ────────┘

典型延迟要求：
• 专业音频：< 10ms（人耳察觉阈值）
• 高端应用：< 5ms（专业录音）
• 极致要求：< 2ms（现场演出）
```

**🎯 音频实时挑战**
```
缓冲区管理：
┌─ 输入缓冲 ─┐ → ┌─ 处理 ─┐ → ┌─ 输出缓冲 ─┐
│   64样本    │   │  算法  │   │   64样本    │
└─────────────┘   └────────┘   └─────────────┘
     2.7ms          处理时间       2.7ms
        └─────── 总延迟约6-8ms ──────┘

挑战：
• 缓冲区太小 → 容易欠载（underrun）
• 缓冲区太大 → 延迟过高
• 需要精确的时钟同步
```

### 4.3 金融交易系统


**💰 金融实时交易**
```
高频交易时间要求：
订单接收 → 策略计算 → 订单发送 → 市场执行
         └─── 微秒级响应要求 ────┘

典型延迟指标：
• 策略计算：< 10μs
• 网络延迟：< 100μs  
• 总响应：< 500μs
```

**⚡ 金融系统特点**
- **极低延迟**：微秒级延迟要求
- **高并发**：同时处理大量交易
- **抖动敏感**：延迟不一致会影响交易策略

```
实际影响：
延迟差异1ms = 在高频交易中可能损失数千美元
解决方案：
• 专用硬件（FPGA）
• 内核旁路技术
• 实时操作系统
```

### 4.4 应用场景总结


| 应用领域 | **延迟要求** | **实时类型** | **关键挑战** |
|----------|-------------|-------------|-------------|
| **工业控制** | `0.1-10ms` | `硬实时` | `长期稳定性` |
| **专业音频** | `2-10ms` | `软实时` | `低抖动要求` |
| **金融交易** | `10-500μs` | `软实时` | `极低延迟` |
| **汽车电子** | `1-100ms` | `硬实时` | `安全关键` |
| **游戏系统** | `16ms` | `软实时` | `用户体验` |

---

## 5. 🐧 Linux内核实时性分析


### 5.1 通用Linux内核的局限性


**❌ 标准内核的实时问题**

```
标准Linux内核设计目标：
• 高吞吐量（throughput）
• 公平调度（fairness）
• 多用户支持（multi-user）
✗ 不是为实时性设计的！
```

**🔸 主要实时性限制**

| 限制类型 | **具体问题** | **影响** |
|----------|-------------|---------|
| **抢占性** | `内核代码段不可抢占` | `高优先级任务等待时间不确定` |
| **中断处理** | `中断处理时间不可控` | `实时任务被长时间阻塞` |
| **内存管理** | `页面置换、内存分配延迟` | `不可预测的内存访问时间` |
| **调度算法** | `CFS调度器优化吞吐量` | `实时任务优先级保证不足` |

**📊 具体问题示例**
```
问题1：长时间禁用抢占
内核在持有自旋锁时禁用抢占：
spin_lock() {
    // 禁用抢占开始
    关键代码执行...  ← 这里可能耗时几毫秒
    // 禁用抢占结束
}
结果：高优先级实时任务被迫等待

问题2：中断处理不可控
网络中断处理：
中断到达 → 处理网络包 → 协议栈处理 → 应用层处理
         └─── 可能耗时数毫秒 ────┘
结果：其他中断和实时任务被阻塞
```

### 5.2 实时性能瓶颈分析


**⚠️ 调度延迟瓶颈**
```
标准CFS调度器特点：
• 追求公平性，不保证实时性
• 时间片轮转，实时任务可能被延迟
• 优先级范围有限

实时调度需求：
• 优先级抢占调度
• 确定性响应时间
• 细粒度优先级控制
```

**🐌 中断延迟瓶颈**
```
中断处理流程：
硬件中断 → 中断服务程序(ISR) → 软中断处理 → 进程上下文
          └─ 原子操作，不可抢占 ─┘

问题：
• ISR执行时间不可控
• 软中断可能批量处理，延迟累积
• 中断嵌套层次过深
```

**📝 内存管理瓶颈**
```
内存分配延迟：
kmalloc() → 查找空闲页面 → 可能触发内存回收 → 返回内存
           └─── 时间不可预测 ────┘

页面错误处理：
访问未加载页面 → 页面错误 → 从磁盘加载 → 继续执行
               └─── 可能耗时几十毫秒 ────┘
```

### 5.3 为什么需要RT补丁


**🎯 RT补丁的必要性**
```
标准内核 vs 实时需求：

标准内核优化目标          实时系统需求
      ↓                      ↓
  高吞吐量              →   低延迟
  公平调度              →   优先级保证
  批处理效率            →   确定性响应
  平均性能              →   最坏情况性能
```

**💡 RT补丁解决思路**
```
核心改进方向：
1. 可抢占内核：内核代码可以被实时任务抢占
2. 中断线程化：将中断处理移到内核线程中
3. 实时调度器：提供严格的优先级保证
4. 锁机制优化：减少锁持有时间
5. 内存优化：提供确定性内存分配
```

---

## 6. 🔧 RT-Preempt补丁机制


### 6.1 RT-Preempt补丁概述


**🔸 RT-Preempt补丁定义**
RT-Preempt是Linux内核的实时性增强补丁，将标准内核改造为具有硬实时能力的系统。

```
RT-Preempt补丁作用：
标准Linux内核 + RT-Preempt补丁 = 实时Linux内核

改进效果：
• 调度延迟：从毫秒级降到微秒级
• 中断延迟：从不可控变为可预测
• 抢占能力：内核大部分代码变为可抢占
```

**🎯 补丁的核心机制**

| 机制 | **标准内核** | **RT内核** |
|------|-------------|-----------|
| **内核抢占** | `部分可抢占` | `几乎完全可抢占` |
| **中断处理** | `原子上下文` | `线程化中断` |
| **锁机制** | `自旋锁` | `RT-mutex（可抢占锁）` |
| **调度器** | `CFS调度` | `实时调度优先` |

### 6.2 可抢占内核机制


**🔄 抢占粒度优化**
```
标准内核抢占点：
系统调用返回 → 用户态
中断返回 → 用户态
显式调用schedule()

RT内核抢占点：
几乎所有内核代码都可被抢占（除极少数临界区）
```

**📋 抢占禁用区域最小化**
```
RT内核策略：
• 大部分自旋锁转换为可抢占的RT-mutex
• 原子操作序列最小化
• 长时间运行的内核代码添加抢占点

效果：
最大抢占延迟：从毫秒级 → 微秒级
```

### 6.3 中断线程化机制


**⚡ 中断处理重构**
```
标准内核中断处理：
硬件中断 → ISR（不可抢占）→ 软中断（可能延迟）→ 进程上下文

RT内核中断处理：
硬件中断 → 最小ISR → 中断线程（可抢占、可调度）
```

**🧵 中断线程化流程**
```
1. 硬件中断到达
   ↓
2. 最小ISR执行（只做必要的硬件确认）
   ↓
3. 唤醒对应的中断线程
   ↓
4. 中断线程按优先级调度执行
   ↓
5. 完成实际的中断处理工作

优势：
• 中断处理可以被更高优先级任务抢占
• 中断处理时间可以精确控制
• 实时任务获得更好的响应性
```

### 6.4 RT-Mutex锁机制


**🔒 锁机制改进**
```
标准内核自旋锁问题：
spin_lock_irqsave(&lock, flags);  // 禁用中断和抢占
// 临界区代码
spin_unlock_irqrestore(&lock, flags);  // 恢复中断和抢占

问题：持有锁期间完全不可抢占
```

**🔐 RT-Mutex解决方案**
```
RT-Mutex特点：
• 持有锁的任务可以被更高优先级任务抢占
• 支持优先级继承，防止优先级反转
• 锁竞争时进入睡眠，而不是忙等待

优先级继承示例：
高优先级任务A → 等待锁 → 低优先级任务C
中优先级任务B → 抢占任务C
任务C继承任务A的优先级 → 抢占任务B → 释放锁
```

### 6.5 RT补丁配置选项


**⚚ 实时性配置级别**

```
CONFIG_PREEMPT_NONE     # 无抢占（服务器）
CONFIG_PREEMPT_VOLUNTARY # 自愿抢占（桌面）
CONFIG_PREEMPT         # 抢占式（低延迟桌面）
CONFIG_PREEMPT_RT      # 完全实时（RT补丁）
```

**🔧 关键配置选项**
```bash
# 启用完全实时抢占
CONFIG_PREEMPT_RT=y

# 启用中断线程化
CONFIG_IRQ_FORCED_THREADING=y

# 启用高精度定时器
CONFIG_HIGH_RES_TIMERS=y

# 禁用不必要的调试选项（影响性能）
CONFIG_DEBUG_PREEMPT=n
CONFIG_DEBUG_RT_MUTEXES=n
```

**📊 性能对比**
```
典型延迟改进效果：

标准内核：
最大调度延迟：1-10ms
平均调度延迟：100-500μs
延迟抖动：很大

RT内核：
最大调度延迟：10-100μs
平均调度延迟：5-20μs
延迟抖动：很小
```

---

## 7. 📊 实时系统性能评估


### 7.1 评估标准与方法


**📋 评估维度**

| 评估项 | **标准内核** | **RT内核目标** | **测量方法** |
|--------|-------------|---------------|-------------|
| **最大延迟** | `1-10ms` | `< 100μs` | `cyclictest工具` |
| **平均延迟** | `100-500μs` | `< 20μs` | `长时间统计` |
| **延迟抖动** | `高` | `极低` | `标准差计算` |
| **吞吐量** | `高` | `中等（可接受）` | `基准测试` |

**🔍 性能测试工具**
```bash
# cyclictest - 最重要的实时性能测试工具
cyclictest -t 4 -p 80 -n -i 1000 -l 100000

参数说明：
-t 4        # 4个测试线程
-p 80       # 实时优先级80
-n          # 使用clock_nanosleep
-i 1000     # 1000μs间隔
-l 100000   # 运行100000次循环

输出示例：
T: 0 ( 1234) P:80 I:1000 C: 100000 Min:   8 Act:  12 Avg:  11 Max:  89
```

### 7.2 基准测试结果分析


**📈 典型测试结果**
```
标准内核测试结果：
最小延迟：   10μs
平均延迟：  150μs  
最大延迟：  8500μs  ← 不可接受
标准差：    890μs   ← 抖动很大

RT内核测试结果：
最小延迟：    8μs
平均延迟：   11μs
最大延迟：   89μs   ← 可接受
标准差：     12μs   ← 抖动很小
```

**⚠️ 测试注意事项**
```
测试环境要求：
• 长时间测试（至少24小时）
• 系统负载测试（CPU、内存、I/O压力）
• 不同优先级任务并发测试
• 中断密集场景测试

常见测试陷阱：
❌ 测试时间太短（几分钟）
❌ 理想环境测试（无其他负载）
❌ 只关注平均值，忽略最大值
❌ 没有进行压力测试
```

### 7.3 性能调优策略


**🎯 系统级优化**
```bash
# 1. CPU隔离（isolcpus）
# 将某些CPU专门用于实时任务
GRUB_CMDLINE_LINUX="isolcpus=2,3"

# 2. 中断亲和性设置
# 将中断绑定到非实时CPU
echo 1 > /proc/irq/24/smp_affinity

# 3. 禁用电源管理
# 防止CPU频率变化影响延迟
echo performance > /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# 4. 内存锁定
# 防止实时进程内存被换出
mlockall(MCL_CURRENT | MCL_FUTURE)
```

**📝 应用级优化**
```c
// 设置实时优先级
struct sched_param param;
param.sched_priority = 80;
sched_setscheduler(0, SCHED_FIFO, &param);

// 锁定内存，防止页面错误
mlockall(MCL_CURRENT | MCL_FUTURE);

// 预分配内存，避免运行时分配
char *buffer = malloc(BUFFER_SIZE);
memset(buffer, 0, BUFFER_SIZE);  // 强制分配物理内存

// 使用高精度定时器
struct timespec ts;
clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &ts, NULL);
```

### 7.4 评估结果解读


**✅ 优秀的实时性能指标**
```
硬实时应用：
最大延迟 < 100μs
延迟抖动 < 10μs
期限错过率 = 0%

软实时应用：
最大延迟 < 1ms
延迟抖动 < 100μs
期限错过率 < 0.1%
```

**📊 性能权衡分析**
```
RT内核的代价：
• 吞吐量下降：10-20%（典型值）
• 功耗增加：5-15%（由于禁用省电特性）
• 复杂度提升：系统配置和调试更复杂

收益：
• 延迟大幅降低：从毫秒级到微秒级
• 延迟可预测：最大延迟有保证
• 实时任务响应：满足严格时间要求
```

**🎯 评估总结**
实时系统性能评估的关键是**最坏情况分析**，不是平均性能。成功的实时系统应该能在最恶劣条件下仍然满足时间要求。

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 实时系统本质：时间约束比计算结果更重要
🔸 硬实时vs软实时：错过期限的后果严重程度不同
🔸 延迟类型：调度延迟、中断延迟、抢占延迟
🔸 Linux实时性局限：标准内核不为实时性设计
🔸 RT-Preempt作用：将Linux改造为实时系统
🔸 性能评估重点：最大延迟和延迟抖动
```

### 8.2 关键理解要点


**🔹 实时性的本质理解**
```
实时性 ≠ 高性能
实时性 = 可预测的响应时间

关键：
• 宁要稳定的慢，不要不稳定的快
• 最坏情况比平均情况更重要
• 确定性比吞吐量更重要
```

**🔹 延迟的系统性分析**
```
延迟来源分析：
硬件延迟（不可控）+ 软件延迟（可优化）= 总延迟

优化策略：
• 减少软件延迟
• 提高延迟可预测性
• 消除延迟突发峰值
```

**🔹 RT-Preempt的核心价值**
```
转换效果：
吞吐量优化的通用OS → 延迟优化的实时OS

关键改进：
• 内核可抢占性：从部分到全面
• 中断处理：从原子到可调度
• 锁机制：从阻塞到可抢占
```

### 8.3 实际应用指导


**🎯 应用场景选择**
```
硬实时应用选择：
✅ 安全关键系统（汽车、航空）
✅ 工业控制（PLC、机器人）
✅ 医疗设备（起搏器、监护仪）

软实时应用选择：
✅ 多媒体处理（音频、视频）
✅ 游戏系统（帧率控制）
✅ 网络设备（路由器、交换机）
```

**🔧 系统配置要点**
```
内核配置：
• 启用CONFIG_PREEMPT_RT
• 配置高精度定时器
• 优化中断处理

系统调优：
• CPU隔离和亲和性
• 内存锁定和预分配
• 禁用不必要的系统服务
```

**📊 性能验证方法**
```
测试策略：
• 长时间压力测试（24小时以上）
• 多种负载组合测试
• 关注最大延迟而非平均延迟

评估标准：
• 硬实时：最大延迟 < 时间期限
• 软实时：延迟分布满足性能要求
• 系统稳定性：长期运行无异常
```

### 8.4 学习进阶路线


**📚 后续深入方向**
```
理论深化：
• 实时调度算法（EDF、Rate Monotonic）
• 实时系统设计方法学
• 形式化验证方法

技术实践：
• RT-Preempt内核编译和配置
• 实时应用程序开发
• 性能测试和调优

应用拓展：
• 嵌入式实时系统
• 工业控制系统开发
• 音频/视频实时处理
```

**💡 关键技能发展**
- **系统思维**：理解延迟的系统性来源
- **量化分析**：用数据评估实时性能
- **权衡决策**：在功能、性能、实时性间做选择
- **实践能力**：配置和调优实时系统

**🎯 一句话总结**
实时系统的核心是**时间可预测性**，RT-Preempt通过内核抢占、中断线程化、锁优化等机制，将Linux从吞吐量优化转向延迟优化，为时间关键应用提供确定性保证。

**核心记忆口诀**：
- 实时系统时间第一，延迟可控胜过快速
- 硬实时绝不容错，软实时偶尔可容
- RT补丁改内核，抢占中断锁优化
- 测试关注最坏况，长期压力验真章