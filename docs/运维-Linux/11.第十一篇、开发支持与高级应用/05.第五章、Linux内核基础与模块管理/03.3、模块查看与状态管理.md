---
title: 3、模块查看与状态管理
---
## 📚 目录

1. [模块查看基础概念](#1-模块查看基础概念)
2. [lsmod命令详解](#2-lsmod命令详解)
3. [proc-modules文件解读](#3-proc-modules文件解读)
4. [modinfo命令深入](#4-modinfo命令深入)
5. [模块依赖与使用计数](#5-模块依赖与使用计数)
6. [模块状态标识管理](#6-模块状态标识管理)
7. [sys-module目录结构](#7-sys-module目录结构)
8. [模块内存与版本信息](#8-模块内存与版本信息)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 模块查看基础概念


### 1.1 什么是模块状态管理


**通俗理解**：就像管理手机上的应用程序一样，Linux内核模块管理让我们能够：
- **查看当前**：看看内核里现在装了哪些"功能组件"
- **了解详情**：每个组件的版本、作用、占用资源等信息
- **监控状态**：组件是否正常工作，有没有被其他程序使用

```
生活比喻：
手机应用管理 → Linux模块管理
查看已安装应用 → lsmod查看已加载模块
应用详细信息 → modinfo查看模块信息
应用使用情况 → 模块使用计数
应用占用空间 → 模块内存占用
```

### 1.2 为什么需要模块状态管理


**🔸 系统监控需求**
- **性能分析**：了解哪些模块占用系统资源
- **故障排查**：定位问题模块，分析系统异常
- **安全审计**：检查是否有未授权模块加载
- **优化调整**：根据使用情况调整模块配置

**🔸 日常维护价值**
- **了解系统状态**：掌握当前内核功能配置
- **依赖关系管理**：理解模块间的相互依赖
- **内存使用监控**：优化系统内存分配
- **版本兼容检查**：确保模块版本匹配

### 1.3 模块状态信息来源


**📊 主要信息来源**
```
信息获取途径：
/proc/modules     → 内核提供的模块列表
/sys/module/      → 详细的模块属性信息
lsmod命令         → 格式化显示模块信息
modinfo命令       → 模块元数据和参数信息
```

**🔄 信息更新机制**
- **实时更新**：模块加载/卸载时信息立即更新
- **内核维护**：内核自动维护模块状态信息
- **用户空间访问**：通过文件系统接口提供信息

---

## 2. 📋 lsmod命令详解


### 2.1 lsmod基本使用


**🔸 命令作用**：显示当前内核中已加载的所有模块

```bash
# 查看所有已加载模块
lsmod

# 输出示例：
Module                  Size  Used by
nvidia_drm             69632  2
nvidia_modeset       1175552  6 nvidia_drm
nvidia               35282944  256 nvidia_modeset
ext4                  929792  2
crc16                  16384  1 ext4
```

**📊 输出字段含义**
| 字段 | **含义** | **示例** |
|------|----------|----------|
| `Module` | `模块名称` | `nvidia_drm` |
| `Size` | `模块大小(字节)` | `69632` |
| `Used by` | `使用计数和依赖者` | `2 nvidia_modeset` |

### 2.2 lsmod信息解读


**🔢 使用计数解释**
```
Used by字段解读：
2                    → 有2个其他模块正在使用它
2 nvidia_modeset     → 有2个使用者，其中nvidia_modeset是其中之一
0                    → 没有其他模块使用，可以安全卸载
256 nvidia_modeset   → 有256个使用者，nvidia_modeset是其中之一
```

**💾 模块大小分析**
```
大小单位：字节(Bytes)
69632 字节 ≈ 68 KB     → 小型模块
1175552 字节 ≈ 1.1 MB  → 中等模块  
35282944 字节 ≈ 33.6 MB → 大型模块(通常是驱动程序)
```

### 2.3 lsmod实用技巧


**🔍 查找特定模块**
```bash
# 查找包含nvidia的模块
lsmod | grep nvidia

# 查找网络相关模块
lsmod | grep -E "(net|eth|wifi)"

# 按大小排序显示
lsmod | sort -k2 -n
```

**📈 统计分析**
```bash
# 统计模块数量
lsmod | wc -l

# 统计总内存占用
lsmod | awk 'NR>1 {sum+=$2} END {print "Total: " sum " bytes (" sum/1024/1024 " MB)"}'

# 查找占用内存最多的模块
lsmod | sort -k2 -nr | head -10
```

---

## 3. 📁 /proc/modules文件解读


### 3.1 文件内容结构


**📋 /proc/modules文件格式**
```bash
# 查看原始文件内容
cat /proc/modules

# 输出格式：
# 模块名 大小 使用计数 依赖者列表 状态 内存地址
nvidia_drm 69632 2 nvidia_modeset, Live 0xffffffffc0a1e000
ext4 929792 2 - Live 0xffffffffc0234000
crc16 16384 1 ext4, Live 0xffffffffc0896000
```

**🔸 字段详细说明**
```
字段顺序和含义：
1. 模块名称：nvidia_drm
2. 模块大小：69632 (字节)
3. 使用计数：2
4. 依赖者列表：nvidia_modeset (用逗号分隔)
5. 模块状态：Live
6. 内存地址：0xffffffffc0a1e000 (模块在内核中的加载地址)
```

### 3.2 模块状态标识


**🚦 状态类型详解**
| 状态 | **含义** | **说明** |
|------|----------|----------|
| `Live` | `正常运行` | `模块已成功加载并正在工作` |
| `Loading` | `正在加载` | `模块正在初始化过程中` |
| `Unloading` | `正在卸载` | `模块正在清理和卸载` |

**⚠️ 异常状态处理**
```
Loading状态过久：
可能原因：模块初始化卡住
处理方法：检查dmesg日志，考虑重启

Unloading状态过久：
可能原因：模块清理过程出错
处理方法：强制重启或等待超时
```

### 3.3 与lsmod的关系


**🔄 数据来源对比**
```
lsmod命令 = 格式化显示 /proc/modules 内容

lsmod显示：
Module          Size  Used by
nvidia_drm     69632  2

/proc/modules显示：
nvidia_drm 69632 2 nvidia_modeset, Live 0xffffffffc0a1e000

区别：
- lsmod更易读，隐藏了内存地址
- /proc/modules提供完整信息，包括状态和地址
```

---

## 4. 🔧 modinfo命令深入


### 4.1 modinfo基本功能


**🔸 命令作用**：查看模块的详细元数据信息，包括版本、作者、描述、参数等

```bash
# 查看模块完整信息
modinfo ext4

# 输出示例：
filename:       /lib/modules/5.4.0/kernel/fs/ext4/ext4.ko
description:    Fourth Extended Filesystem
author:         Remy Card, Stephen Tweedie, Andrew Morton
license:        GPL
version:        1.0
srcversion:     A1B2C3D4E5F6G7H8I9J0K1L
depends:        crc16,jbd2,fscrypto
```

### 4.2 信息字段详解


**📖 重要字段含义**
```
filename: 模块文件的完整路径
description: 模块功能描述
author: 模块开发者信息
license: 许可证类型(GPL, MIT等)
version: 模块版本号
srcversion: 源码版本校验码
depends: 依赖的其他模块
parm: 模块参数(如果有的话)
```

**🔸 参数信息解读**
```bash
# 查看模块参数
modinfo e1000e | grep parm

# 输出示例：
parm:           copybreak:Maximum size of packet that is copied to a new buffer on receive (uint)
parm:           TxIntDelay:Transmit Interrupt Delay (array of int)
parm:           debug:Debug level (0=none,...,16=all) (int)
```

### 4.3 modinfo高级用法


**🎯 特定信息提取**
```bash
# 只查看模块描述
modinfo -d ext4

# 只查看模块作者
modinfo -a ext4

# 只查看模块参数
modinfo -p e1000e

# 查看模块依赖
modinfo ext4 | grep depends
```

**📊 批量信息获取**
```bash
# 查看所有网络模块信息
find /lib/modules/$(uname -r) -name "*.ko" -path "*/net/*" | head -5 | xargs -I {} basename {} .ko | xargs -I {} modinfo {}

# 查看系统中所有已加载模块的描述
lsmod | awk 'NR>1 {print $1}' | xargs -I {} modinfo -d {} 2>/dev/null
```

---

## 5. 🔗 模块依赖与使用计数


### 5.1 依赖关系理解


**🔸 依赖关系概念**
简单说就是"模块之间的相互需要关系"，比如：
- **USB鼠标驱动**依赖**USB核心模块**
- **文件系统模块**依赖**加密模块**
- **网卡驱动**依赖**网络核心模块**

```
依赖关系示例：
    USB核心模块
        ↑
    USB HID模块  
        ↑
    USB鼠标驱动

下层模块为上层模块提供服务
```

### 5.2 使用计数机制


**🔢 使用计数含义**
```
使用计数的作用：
- 防止误卸载：有程序使用时不能卸载
- 内存管理：跟踪模块使用情况
- 依赖管理：确保依赖关系正确

计数变化时机：
加载依赖模块 → 计数+1
卸载依赖模块 → 计数-1
程序使用模块 → 计数+1
程序释放模块 → 计数-1
```

**📈 使用计数查看**
```bash
# 查看特定模块使用情况
lsmod | grep usbcore

# 输出示例：
usbcore               282624  3 usbhid,ehci_hcd,uhci_hcd

# 解读：usbcore被3个模块使用，分别是usbhid、ehci_hcd、uhci_hcd
```

### 5.3 依赖关系可视化


**🌳 依赖树显示**
```bash
# 显示模块依赖树(需要安装module-init-tools)
lsmod | awk 'NR>1 {print $1}' | while read module; do
    echo "=== $module ==="
    modinfo $module | grep depends
    echo
done

# 更直观的依赖显示
grep -H "depends" /sys/module/*/srcversion 2>/dev/null | head -5
```

**📊 依赖统计分析**
```bash
# 统计最多被依赖的模块
lsmod | awk 'NR>1 && $3>0 {print $1, $3}' | sort -k2 -nr | head -10

# 查找没有依赖的"根"模块
lsmod | awk 'NR>1 && $3==0 {print $1}'
```

---

## 6. 🚦 模块状态标识管理


### 6.1 状态生命周期


**🔄 模块状态转换**
```
模块状态变化过程：
未加载 → Loading → Live → Unloading → 未加载

详细过程：
1. 未加载：模块文件存在但未载入内核
2. Loading：正在执行模块初始化代码
3. Live：模块正常工作，可以提供服务
4. Unloading：正在执行模块清理代码
```

### 6.2 状态异常处理


**⚠️ Loading状态异常**
```bash
# 检查是否有模块卡在Loading状态
grep "Loading" /proc/modules

# 如果发现异常，查看系统日志
dmesg | tail -20
journalctl -k | tail -20

# 常见原因：
# - 模块初始化代码死锁
# - 依赖模块未正确加载
# - 硬件不兼容
```

**🔧 Unloading状态异常**
```bash
# 检查卡在Unloading状态的模块
grep "Unloading" /proc/modules

# 处理方法：
# 1. 等待超时(通常几分钟)
# 2. 检查是否有进程仍在使用
# 3. 重启系统(最后手段)
```

### 6.3 状态监控脚本


**📊 自动状态监控**
```bash
#!/bin/bash
# 模块状态监控脚本

echo "=== 模块状态检查 ==="
echo "总模块数: $(lsmod | wc -l)"
echo "Live状态: $(grep -c "Live" /proc/modules)"
echo "Loading状态: $(grep -c "Loading" /proc/modules)"
echo "Unloading状态: $(grep -c "Unloading" /proc/modules)"

# 检查异常状态
if grep -q "Loading" /proc/modules; then
    echo "⚠️  发现Loading状态模块:"
    grep "Loading" /proc/modules
fi

if grep -q "Unloading" /proc/modules; then
    echo "⚠️  发现Unloading状态模块:"
    grep "Unloading" /proc/modules
fi
```

---

## 7. 📂 /sys/module目录结构


### 7.1 目录结构概览


**🗂 /sys/module目录作用**
这个目录提供了每个已加载模块的详细属性信息，就像每个模块都有自己的"档案袋"。

```
/sys/module目录结构：
/sys/module/
├── ext4/                   ← 模块名称目录
│   ├── holders/           ← 依赖此模块的其他模块
│   ├── initstate          ← 初始化状态
│   ├── refcnt             ← 引用计数
│   ├── sections/          ← 内存段信息
│   ├── parameters/        ← 模块参数(如果有)
│   └── uevent             ← 设备事件信息
└── nvidia/
    ├── holders/
    ├── parameters/
    └── ...
```

### 7.2 重要文件说明


**📋 核心文件功能**
```bash
# 查看模块初始化状态
cat /sys/module/ext4/initstate
# 输出：live (表示已成功初始化)

# 查看引用计数
cat /sys/module/ext4/refcnt  
# 输出：2 (与lsmod中Used by对应)

# 查看依赖此模块的其他模块
ls /sys/module/usbcore/holders/
# 输出：usbhid ehci_hcd uhci_hcd
```

**🔧 参数信息查看**
```bash
# 查看模块参数(如果有)
ls /sys/module/e1000e/parameters/
# 输出：copybreak debug TxIntDelay

# 查看参数当前值
cat /sys/module/e1000e/parameters/debug
# 输出：0
```

### 7.3 实用查询技巧


**🔍 批量信息获取**
```bash
# 查看所有模块的引用计数
for module in /sys/module/*/refcnt; do
    echo "$(basename $(dirname $module)): $(cat $module)"
done | sort -k2 -nr

# 查看有参数的模块
find /sys/module -name parameters -type d | while read dir; do
    module=$(basename $(dirname $dir))
    params=$(ls $dir 2>/dev/null | wc -l)
    [ $params -gt 0 ] && echo "$module: $params parameters"
done
```

**📊 依赖关系分析**
```bash
# 查看哪些模块被依赖最多
for module in /sys/module/*/holders; do
    count=$(ls $module 2>/dev/null | wc -l)
    [ $count -gt 0 ] && echo "$(basename $(dirname $module)): $count dependents"
done | sort -k2 -nr
```

---

## 8. 💾 模块内存与版本信息


### 8.1 内存占用分析


**📊 内存使用查看**
```bash
# 查看模块内存占用排序
lsmod | awk 'NR>1 {print $2, $1}' | sort -nr | head -10

# 转换为更易读的格式
lsmod | awk 'NR>1 {
    size = $2
    if (size > 1024*1024) 
        printf "%.1f MB  %s\n", size/(1024*1024), $1
    else if (size > 1024)
        printf "%.1f KB  %s\n", size/1024, $1
    else
        printf "%d B   %s\n", size, $1
}' | head -10
```

**🔢 内存统计分析**
```bash
# 计算总内存占用
total_kb=$(lsmod | awk 'NR>1 {sum+=$2} END {print sum/1024}')
echo "模块总占用内存: ${total_kb} KB"

# 按模块类型分类统计(简单分类)
echo "=== 驱动程序模块 ==="
lsmod | grep -E "(drm|nvidia|sound|net)" | awk '{sum+=$2} END {print "总计: " sum/1024 " KB"}'

echo "=== 文件系统模块 ==="  
lsmod | grep -E "(ext|ntfs|fat|xfs)" | awk '{sum+=$2} END {print "总计: " sum/1024 " KB"}'
```

### 8.2 版本信息管理


**🏷 版本信息查看**
```bash
# 查看模块版本信息
modinfo nvidia | grep -E "(version|srcversion)"

# 输出示例：
version:        470.141.03
srcversion:     ABC123DEF456789012345678

# 批量查看关键模块版本
for module in ext4 nvidia e1000e; do
    echo "=== $module ==="
    modinfo $module 2>/dev/null | grep -E "(version|description)" || echo "模块未找到"
    echo
done
```

**🔍 校验信息验证**
```bash
# 查看模块文件的校验信息
modinfo -F srcversion ext4

# 比较不同版本模块的srcversion
echo "当前加载的模块:"
grep ext4 /proc/modules | awk '{print $6}'
echo "磁盘上的模块:"
modinfo -F srcversion ext4
```

### 8.3 内存地址信息


**🗺 内存地址查看**
```bash
# 查看模块在内核中的加载地址
grep ext4 /proc/modules
# 输出：ext4 929792 2 - Live 0xffffffffc0234000

# 查看模块内存段信息
cat /sys/module/ext4/sections/.text
cat /sys/module/ext4/sections/.data
```

**📋 地址空间分析**
```
内核模块地址空间：
0xffffffffc0000000 - 0xffffffffefffffff  ← 内核模块区域
模块地址示例：
ext4:   0xffffffffc0234000
nvidia: 0xffffffffc0500000

地址信息用途：
- 内核调试
- 崩溃分析  
- 性能分析
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 模块状态管理：实时监控内核模块的运行状态
🔸 lsmod命令：快速查看已加载模块的基本信息
🔸 /proc/modules：内核提供的详细模块信息接口
🔸 modinfo命令：获取模块元数据和参数信息
🔸 依赖关系：理解模块间的相互依赖和使用计数
🔸 状态标识：Live、Loading、Unloading三种主要状态
```

### 9.2 关键理解要点


**🔹 模块管理的本质**
```
核心理念：
模块管理 = 动态功能组件的生命周期管理
状态监控 = 确保系统稳定性和性能
依赖管理 = 维护模块间的正确关系

实际价值：
- 系统故障排查的重要工具
- 性能优化的数据基础
- 安全审计的检查手段
```

**🔹 信息来源的层次**
```
信息详细程度：
lsmod        → 简洁概览(日常使用)
/proc/modules → 完整信息(深入分析)  
modinfo      → 元数据信息(开发调试)
/sys/module  → 运行时属性(精确控制)
```

**🔹 实际应用场景**
```
日常运维：
- 检查模块加载状态
- 分析内存使用情况
- 排查系统性能问题

故障处理：
- 定位问题模块
- 分析模块依赖关系
- 检查异常状态
```

### 9.3 实用技能总结


**🛠 常用命令组合**
```bash
# 快速系统检查
lsmod | wc -l                    # 模块总数
lsmod | awk 'NR>1{sum+=$2}END{print sum/1024"KB"}'  # 总内存占用
grep -v "Live" /proc/modules     # 检查异常状态

# 详细分析特定模块
modinfo 模块名                   # 详细信息
cat /sys/module/模块名/refcnt    # 使用计数
ls /sys/module/模块名/holders/   # 依赖者列表
```

**📊 监控和分析**
- 定期检查模块状态，及早发现异常
- 监控内存占用，优化系统性能
- 了解依赖关系，避免误操作
- 记录版本信息，便于问题追踪

### 9.4 学习进阶路径


```
🎯 技能层次：
初级：熟练使用lsmod和modinfo命令
中级：理解依赖关系和状态管理机制  
高级：能够编写监控脚本和自动化工具
专家：深入内核模块机制，进行系统调优

📚 扩展方向：
- 学习模块开发和编译
- 深入内核调试技术
- 掌握系统性能分析
- 了解容器环境下的模块管理
```

**💡 实践建议**
- 在虚拟机中练习各种模块操作
- 建立自己的模块监控脚本库
- 定期分析系统模块使用情况
- 关注模块版本更新和安全公告

**核心记忆**：
- 模块管理是Linux系统维护的基础技能
- 多种工具配合使用能获得全面信息
- 状态监控有助于提前发现和解决问题
- 理解依赖关系是安全操作的前提