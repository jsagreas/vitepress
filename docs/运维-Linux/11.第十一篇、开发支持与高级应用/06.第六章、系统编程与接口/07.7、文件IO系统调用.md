---
title: 7、文件IO系统调用
---
## 📚 目录

1. [文件IO系统调用概述](#1-文件IO系统调用概述)
2. [open()/close()文件打开关闭操作](#2-open-close文件打开关闭操作)
3. [read()/write()阻塞IO读写机制](#3-read-write阻塞IO读写机制)
4. [lseek()文件定位与随机访问](#4-lseek文件定位与随机访问)
5. [fcntl()文件控制属性设置](#5-fcntl文件控制属性设置)
6. [dup()/dup2()文件描述符复制](#6-dup-dup2文件描述符复制)
7. [文件锁机制](#7-文件锁机制)
8. [文件描述符限制与ulimit设置](#8-文件描述符限制与ulimit设置)
9. [文件IO缓冲区与刷新机制](#9-文件IO缓冲区与刷新机制)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📁 文件IO系统调用概述


### 1.1 什么是文件IO系统调用


**系统调用**就是程序直接向内核请求服务的方式。想象一下，你的程序就像一个客人，而内核就像酒店的服务台，系统调用就是你按服务铃请求服务的过程。

**文件IO系统调用**专门负责文件操作，它们是程序与文件系统之间的"翻译官"。

### 1.2 系统调用 vs 库函数


```
程序层面的对比：

📚 库函数(如fopen, fread)：
用户程序 → C库函数 → 系统调用 → 内核 → 硬件

🔧 系统调用(如open, read)：  
用户程序 → 系统调用 → 内核 → 硬件

特点对比：
库函数：有缓冲，使用方便，性能较好
系统调用：无缓冲，直接操作，控制精确
```

### 1.3 文件描述符概念


**文件描述符(File Descriptor, fd)**是Linux中文件的"身份证号"，是一个非负整数。

```
系统预定义的文件描述符：
0 → 标准输入(stdin)   键盘输入
1 → 标准输出(stdout)  屏幕输出  
2 → 标准错误(stderr)  错误输出

用户文件描述符：
从3开始分配，如 3, 4, 5, 6...
```

**文件描述符表示意图**：
```
进程文件描述符表：
┌─────┬──────────────┐
│ fd  │   文件对象   │
├─────┼──────────────┤
│  0  │ 标准输入     │
│  1  │ 标准输出     │
│  2  │ 标准错误     │
│  3  │ test.txt     │
│  4  │ data.log     │
│  5  │ config.conf  │
└─────┴──────────────┘
```

---

## 2. 🔓 open()/close()文件打开关闭操作


### 2.1 open()函数详解


**作用**：打开或创建一个文件，返回文件描述符。

**函数原型**：
```c
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

**参数说明**：
- `pathname`：文件路径
- `flags`：打开方式标志
- `mode`：文件权限（创建文件时使用）

### 2.2 打开方式标志(flags)


| 标志 | **含义** | **说明** |
|------|---------|----------|
| `O_RDONLY` | **只读** | `只能读取文件内容` |
| `O_WRONLY` | **只写** | `只能写入文件内容` |
| `O_RDWR` | **读写** | `既能读也能写` |
| `O_CREAT` | **创建** | `文件不存在时创建` |
| `O_TRUNC` | **截断** | `打开时清空文件内容` |
| `O_APPEND` | **追加** | `写入时追加到文件末尾` |

### 2.3 文件权限模式(mode)


文件权限用八进制数表示，如 `0644`：

```
权限含义：
0644 = rw-r--r--
│││  │││││││└── 其他用户读权限
│││  ││││││└─── 其他用户写权限(无)  
│││  │││││└──── 其他用户执行权限(无)
│││  ││││└───── 组用户读权限
│││  │││└────── 组用户写权限(无)
│││  ││└─────── 组用户执行权限(无)
│││  │└──────── 所有者读权限
│││  └───────── 所有者写权限
││└──────────── 所有者执行权限(无)
│└───────────── 特殊权限位
└────────────── 八进制前缀
```

### 2.4 实际使用示例


```c
#include <fcntl.h>
#include <unistd.h>

// 只读打开已存在文件
int fd1 = open("data.txt", O_RDONLY);

// 创建新文件并写入
int fd2 = open("new.txt", O_CREAT | O_WRONLY, 0644);

// 追加写入已存在文件
int fd3 = open("log.txt", O_WRONLY | O_APPEND);

// 读写方式打开，如果不存在则创建
int fd4 = open("config.txt", O_RDWR | O_CREAT, 0644);
```

### 2.5 close()函数


**作用**：关闭文件描述符，释放系统资源。

```c
int close(int fd);

// 使用示例
if (fd >= 0) {
    close(fd);  // 关闭文件
    fd = -1;    // 避免重复关闭
}
```

> **⚠️ 重要提醒**：每个 `open()` 都必须对应一个 `close()`，否则会造成文件描述符泄漏！

---

## 3. 📖 read()/write()阻塞IO读写机制


### 3.1 read()函数详解


**作用**：从文件描述符读取数据到缓冲区。

```c
ssize_t read(int fd, void *buf, size_t count);
```

**参数含义**：
- `fd`：文件描述符
- `buf`：存放数据的缓冲区
- `count`：要读取的字节数

**返回值**：
- `> 0`：实际读取的字节数
- `= 0`：到达文件末尾(EOF)
- `< 0`：出错

### 3.2 write()函数详解


**作用**：将缓冲区数据写入文件描述符。

```c
ssize_t write(int fd, const void *buf, size_t count);
```

**返回值**：
- `> 0`：实际写入的字节数
- `< 0`：出错

### 3.3 阻塞IO机制


**阻塞IO**意思是：当数据没有准备好时，程序会"等待"在那里，直到数据可用。

```
阻塞读取过程：
程序调用read() → 数据未准备好 → 程序暂停等待 → 数据到达 → 返回数据

就像去银行取钱：
你到柜台 → 柜员查账户 → 你等待 → 查询完成 → 给你钱
```

### 3.4 读写示例


```c
#include <unistd.h>
#include <fcntl.h>

// 文件复制示例
int copy_file(const char *src, const char *dst) {
    int src_fd = open(src, O_RDONLY);
    int dst_fd = open(dst, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    
    char buffer[1024];
    ssize_t bytes_read;
    
    // 循环读写直到文件结束
    while ((bytes_read = read(src_fd, buffer, sizeof(buffer))) > 0) {
        write(dst_fd, buffer, bytes_read);
    }
    
    close(src_fd);
    close(dst_fd);
    return 0;
}
```

### 3.5 部分读写问题


**重要概念**：`read()` 和 `write()` 可能不会一次性读写完所有数据！

```
为什么会出现部分读写：
- 网络中断
- 缓冲区满了
- 信号中断
- 设备忙碌

解决方案：循环读写
```

**安全的读写函数**：
```c
// 完整读取n字节
ssize_t read_n(int fd, void *buf, size_t n) {
    size_t nleft = n;
    ssize_t nread;
    char *ptr = buf;
    
    while (nleft > 0) {
        if ((nread = read(fd, ptr, nleft)) < 0) {
            return -1;  // 错误
        } else if (nread == 0) {
            break;      // EOF
        }
        nleft -= nread;
        ptr += nread;
    }
    return n - nleft;
}
```

---

## 4. 🎯 lseek()文件定位与随机访问


### 4.1 lseek()函数作用


**文件指针**就像阅读书籍时的书签，标记当前读到哪里了。`lseek()` 可以移动这个"书签"。

```c
off_t lseek(int fd, off_t offset, int whence);
```

**参数说明**：
- `fd`：文件描述符
- `offset`：偏移量（可正可负）
- `whence`：起始位置

### 4.2 起始位置(whence)选项


| 选项 | **含义** | **说明** |
|------|---------|----------|
| `SEEK_SET` | **文件开头** | `从文件第0字节开始计算` |
| `SEEK_CUR` | **当前位置** | `从当前位置开始计算` |
| `SEEK_END` | **文件末尾** | `从文件最后一字节开始计算` |

### 4.3 文件定位示意图


```
文件内容: [H][e][l][l][o][ ][W][o][r][l][d]
位置:      0  1  2  3  4  5  6  7  8  9  10

lseek(fd, 0, SEEK_SET)   → 移动到位置 0 (开头)
lseek(fd, 5, SEEK_SET)   → 移动到位置 5 (空格处)
lseek(fd, -3, SEEK_END)  → 移动到位置 8 (从末尾往前3位)
lseek(fd, 2, SEEK_CUR)   → 从当前位置往后移动2位
```

### 4.4 实际使用场景


```c
// 获取文件大小
off_t file_size = lseek(fd, 0, SEEK_END);

// 回到文件开头
lseek(fd, 0, SEEK_SET);

// 跳过文件头信息(假设头部100字节)
lseek(fd, 100, SEEK_SET);

// 从文件末尾往前读取最后1KB数据
lseek(fd, -1024, SEEK_END);
```

### 4.5 创建稀疏文件


**稀疏文件**是一种特殊文件，中间有"空洞"，实际不占用磁盘空间。

```c
// 创建一个有空洞的文件
int fd = open("sparse.txt", O_CREAT | O_WRONLY, 0644);
write(fd, "start", 5);           // 写入开头
lseek(fd, 1000000, SEEK_SET);    // 跳到100万字节处
write(fd, "end", 3);             // 写入结尾
close(fd);

// 文件大小：1000003字节，但实际只占用8字节磁盘空间
```

---

## 5. ⚙️ fcntl()文件控制属性设置


### 5.1 fcntl()函数概述


**fcntl**的全称是 "file control"，它是文件的"万能控制器"，可以查询和修改文件的各种属性。

```c
int fcntl(int fd, int cmd, ...);
```

**参数说明**：
- `fd`：文件描述符
- `cmd`：控制命令
- `...`：可选参数（根据cmd确定）

### 5.2 常用控制命令


| 命令 | **功能** | **说明** |
|------|---------|----------|
| `F_GETFL` | **获取文件状态** | `查看文件打开方式` |
| `F_SETFL` | **设置文件状态** | `修改文件打开方式` |
| `F_GETFD` | **获取文件描述符标志** | `查看close-on-exec标志` |
| `F_SETFD` | **设置文件描述符标志** | `设置close-on-exec标志` |

### 5.3 文件状态标志操作


```c
#include <fcntl.h>

// 获取当前文件状态
int flags = fcntl(fd, F_GETFL);

// 添加非阻塞标志
flags |= O_NONBLOCK;
fcntl(fd, F_SETFL, flags);

// 移除非阻塞标志  
flags &= ~O_NONBLOCK;
fcntl(fd, F_SETFL, flags);
```

### 5.4 非阻塞IO设置


**阻塞 vs 非阻塞**的区别：

```
阻塞IO：
程序: "给我读数据"
系统: "没数据，你等着吧" → 程序停止运行，等待
系统: "好了，给你数据"    → 程序继续运行

非阻塞IO：
程序: "给我读数据"  
系统: "没数据"      → 立即返回错误码 EAGAIN
程序: 继续做其他事情，过会儿再来问
```

```c
// 设置为非阻塞模式
int set_nonblock(int fd) {
    int flags = fcntl(fd, F_GETFL);
    if (flags < 0) return -1;
    
    flags |= O_NONBLOCK;
    return fcntl(fd, F_SETFL, flags);
}

// 非阻塞读取示例
char buffer[1024];
ssize_t n = read(fd, buffer, sizeof(buffer));
if (n < 0) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        // 数据还没准备好，稍后再试
        printf("数据还没准备好\n");
    } else {
        // 真正的错误
        perror("read error");
    }
}
```

### 5.5 close-on-exec标志


**close-on-exec**标志控制文件描述符在执行 `exec()` 时是否自动关闭。

```c
// 设置close-on-exec标志
int flags = fcntl(fd, F_GETFD);
flags |= FD_CLOEXEC;
fcntl(fd, F_SETFD, flags);

// 或者在open时直接设置
int fd = open("file.txt", O_RDONLY | O_CLOEXEC);
```

---

## 6. 📋 dup()/dup2()文件描述符复制


### 6.1 文件描述符复制概念


**文件描述符复制**就像给同一个文件办多张"身份证"，不同的证件号指向同一个文件。

```
复制前：
fd=3 → file.txt

复制后：  
fd=3 → file.txt ←── fd=4
```

### 6.2 dup()函数


**作用**：复制文件描述符，返回最小可用的文件描述符。

```c
int dup(int oldfd);

// 示例
int fd1 = open("test.txt", O_RDONLY);  // 假设返回3
int fd2 = dup(fd1);                    // 返回4，现在fd1和fd2指向同一文件
```

### 6.3 dup2()函数


**作用**：将文件描述符复制到指定的描述符号上。

```c
int dup2(int oldfd, int newfd);

// 示例：重定向标准输出到文件
int fd = open("output.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
dup2(fd, 1);    // 将文件描述符复制到标准输出(1)
close(fd);      // 关闭原描述符

// 现在所有printf输出都会写入output.txt文件
printf("这行文字会写入文件\n");
```

### 6.4 重定向应用示例


**标准输出重定向**：
```c
// 保存原始的标准输出
int saved_stdout = dup(1);

// 重定向到文件
int fd = open("log.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
dup2(fd, 1);
printf("这个会写入log.txt\n");
close(fd);

// 恢复标准输出
dup2(saved_stdout, 1);
close(saved_stdout);
printf("这个会显示在屏幕上\n");
```

### 6.5 管道通信应用


```c
// 父子进程管道通信
int pipefd[2];
pipe(pipefd);  // 创建管道

if (fork() == 0) {
    // 子进程：将标准输出重定向到管道写端
    close(pipefd[0]);        // 关闭读端
    dup2(pipefd[1], 1);      // 重定向标准输出
    close(pipefd[1]);        // 关闭原写端
    
    printf("子进程消息\n");   // 写入管道
    exit(0);
} else {
    // 父进程：从管道读取数据
    close(pipefd[1]);        // 关闭写端
    char buffer[100];
    read(pipefd[0], buffer, sizeof(buffer));
    printf("收到：%s", buffer);
    close(pipefd[0]);
}
```

---

## 7. 🔒 文件锁机制


### 7.1 文件锁的作用


**文件锁**就像给文件上一把锁，防止多个程序同时修改同一个文件造成数据混乱。

```
没有文件锁的问题：
进程A: 读取余额1000元 → 准备转账100元
进程B: 读取余额1000元 → 准备转账200元  
进程A: 写入余额900元
进程B: 写入余额800元  
结果: 应该是700元，但变成了800元！

有文件锁的解决：
进程A: 获取锁 → 读取1000元 → 转账100元 → 写入900元 → 释放锁
进程B: 等待锁 → 获取锁 → 读取900元 → 转账200元 → 写入700元 → 释放锁
结果: 正确的700元
```

### 7.2 flock()函数


**flock**提供简单的文件锁操作：

```c
int flock(int fd, int operation);
```

**操作类型**：
- `LOCK_SH`：共享锁（读锁）
- `LOCK_EX`：排它锁（写锁）  
- `LOCK_UN`：解锁
- `LOCK_NB`：非阻塞模式

### 7.3 共享锁 vs 排它锁


```
共享锁(读锁)：
- 多个进程可以同时获取
- 用于读取文件
- 阻止其他进程获取排它锁

排它锁(写锁)：
- 只有一个进程可以获取
- 用于修改文件  
- 阻止其他进程获取任何锁
```

**锁兼容性表**：
| 当前锁 | **请求共享锁** | **请求排它锁** |
|-------|---------------|---------------|
| **无锁** | `✅ 允许` | `✅ 允许` |
| **共享锁** | `✅ 允许` | `❌ 阻塞` |
| **排它锁** | `❌ 阻塞` | `❌ 阻塞` |

### 7.4 flock()使用示例


```c
#include <sys/file.h>

// 安全地写文件
int safe_write_file(const char *filename, const char *data) {
    int fd = open(filename, O_WRONLY | O_CREAT, 0644);
    if (fd < 0) return -1;
    
    // 获取排它锁
    if (flock(fd, LOCK_EX) < 0) {
        close(fd);
        return -1;
    }
    
    // 写入数据
    write(fd, data, strlen(data));
    
    // 锁会在close时自动释放
    close(fd);
    return 0;
}
```

### 7.5 fcntl()文件锁


**fcntl锁**比flock更精确，可以锁定文件的特定区域：

```c
struct flock lock;
lock.l_type = F_WRLCK;      // 写锁
lock.l_whence = SEEK_SET;   // 从文件开头
lock.l_start = 0;           // 起始位置
lock.l_len = 0;             // 长度(0表示整个文件)

// 设置锁
fcntl(fd, F_SETLKW, &lock);

// 解锁
lock.l_type = F_UNLCK;
fcntl(fd, F_SETLK, &lock);
```

---

## 8. 📊 文件描述符限制与ulimit设置


### 8.1 文件描述符限制概念


**文件描述符限制**是系统为了防止程序无限制地打开文件而设置的上限。

```
为什么要限制：
- 每个文件描述符占用内核内存
- 防止程序耗尽系统资源
- 避免文件描述符泄漏影响系统
```

### 8.2 查看当前限制


```bash
# 查看当前用户的软限制
ulimit -n

# 查看所有限制
ulimit -a

# 查看硬限制
ulimit -Hn
```

**输出示例**：
```
$ ulimit -n
1024

$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7680
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7680
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

### 8.3 软限制 vs 硬限制


```
软限制(Soft Limit)：
- 当前生效的限制
- 可以通过程序自己修改
- 不能超过硬限制

硬限制(Hard Limit)：
- 软限制的上限
- 只有root用户可以修改
- 防止普通用户设置过高的限制
```

### 8.4 程序中检查和修改限制


```c
#include <sys/resource.h>

// 获取文件描述符限制
struct rlimit limit;
if (getrlimit(RLIMIT_NOFILE, &limit) == 0) {
    printf("软限制: %ld\n", limit.rlim_cur);
    printf("硬限制: %ld\n", limit.rlim_max);
}

// 修改软限制
limit.rlim_cur = 2048;
if (setrlimit(RLIMIT_NOFILE, &limit) == 0) {
    printf("限制修改成功\n");
} else {
    perror("修改限制失败");
}
```

### 8.5 系统级限制配置


**临时修改**：
```bash
# 临时提高限制到4096
ulimit -n 4096

# 只对当前shell会话有效
```

**永久修改**：
编辑 `/etc/security/limits.conf`：
```
# 格式：用户 类型 资源 限制值
*        soft  nofile  4096
*        hard  nofile  8192
username soft  nofile  8192
username hard  nofile  16384
```

### 8.6 监控文件描述符使用


```bash
# 查看进程打开的文件描述符
lsof -p <PID>

# 查看特定进程的fd使用情况
ls -la /proc/<PID>/fd/

# 统计当前打开的文件描述符数量
ls /proc/<PID>/fd/ | wc -l
```

---

## 9. 💾 文件IO缓冲区与刷新机制


### 9.1 缓冲区概念


**缓冲区**就像一个临时的"中转站"，数据先存在这里，然后批量处理，提高效率。

```
无缓冲区的问题：
程序写1字节 → 立即调用系统调用 → 磁盘写入
程序写1字节 → 立即调用系统调用 → 磁盘写入
... (1000次系统调用，效率很低)

有缓冲区的优势：
程序写1字节 → 存入缓冲区
程序写1字节 → 存入缓冲区  
... (缓冲区满了)
一次性写入1000字节 → 磁盘写入 (只有1次系统调用)
```

### 9.2 缓冲区类型


**系统级别的缓冲区层次**：
```
应用程序
    ↓
用户空间缓冲区 (stdio库)
    ↓  
内核缓冲区 (页缓存)
    ↓
磁盘设备缓冲区
    ↓
磁盘存储
```

### 9.3 标准IO缓冲策略


| 缓冲类型 | **触发条件** | **典型设备** |
|---------|-------------|-------------|
| **无缓冲** | `立即输出` | `标准错误(stderr)` |
| **行缓冲** | `遇到换行符或缓冲区满` | `终端设备` |
| **全缓冲** | `缓冲区满或显式刷新` | `普通文件` |

### 9.4 系统调用 vs 标准IO缓冲


```
系统调用(read/write)：
- 无用户空间缓冲
- 直接与内核交互
- 每次调用都进入内核态

标准IO(fread/fwrite)：
- 有用户空间缓冲
- 减少系统调用次数
- 提高效率但增加复杂性
```

### 9.5 内核缓冲区管理


**页缓存(Page Cache)**是内核的文件缓冲机制：

```c
// sync()强制刷新所有缓冲区到磁盘
sync();

// fsync()刷新特定文件的缓冲区
int fd = open("important.txt", O_WRONLY);
write(fd, data, len);
fsync(fd);  // 确保数据写入磁盘
close(fd);

// fdatasync()只刷新数据，不刷新元数据
fdatasync(fd);  // 比fsync稍快
```

### 9.6 缓冲区刷新时机


**自动刷新条件**：
- 缓冲区满
- 程序正常退出
- 文件关闭
- 遇到换行符（行缓冲）

**手动刷新方法**：
```c
// 标准IO刷新
fflush(stdout);    // 刷新标准输出
fflush(NULL);      // 刷新所有打开的输出流

// 系统调用刷新
fsync(fd);         // 强制刷新到磁盘
fdatasync(fd);     // 只刷新数据
```

### 9.7 缓冲区大小调优


```c
// 查看系统推荐的缓冲区大小
struct stat st;
if (fstat(fd, &st) == 0) {
    printf("最优缓冲区大小: %ld\n", st.st_blksize);
}

// 使用合适的缓冲区大小
char *buffer = malloc(st.st_blksize);
ssize_t n = read(fd, buffer, st.st_blksize);
```

**性能对比**：
```
缓冲区大小 vs 性能：
512字节   →  较慢
4KB       →  适中  
64KB      →  较快
1MB       →  很快(但内存占用大)
16MB      →  可能反而变慢(缓存失效)
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 系统调用本质：程序直接请求内核服务的方式
🔸 文件描述符：Linux中文件的"身份证号"，非负整数
🔸 阻塞IO：数据未准备好时程序等待，简单但可能效率低
🔸 文件锁：防止多进程同时修改文件造成数据竞争
🔸 缓冲区：提高IO效率的临时存储区域
```

### 10.2 关键函数记忆


**🔹 文件操作基础**
```
open()  → 打开文件，返回文件描述符
close() → 关闭文件，释放资源
read()  → 从文件读取数据到缓冲区
write() → 将缓冲区数据写入文件
```

**🔹 高级控制功能**
```
lseek() → 移动文件读写位置，支持随机访问
fcntl() → 文件控制，修改文件属性和状态
dup2()  → 文件描述符复制，实现重定向
flock() → 文件锁定，防止并发访问冲突
```

### 10.3 重要理解要点


**🔹 为什么需要系统调用**
```
安全性：用户程序不能直接操作硬件
稳定性：内核统一管理资源，避免冲突
效率：内核优化IO操作，提供缓冲机制
```

**🔹 文件描述符的本质**
```
实际上是：进程文件表的索引号
指向：内核中的文件对象结构
作用：进程与文件之间的"桥梁"
```

**🔹 阻塞与非阻塞的选择**
```
阻塞IO：编程简单，适合简单应用
非阻塞IO：需要循环检查，适合高并发应用
```

### 10.4 实际应用指导


**🎯 文件操作最佳实践**
- ✅ 每个 `open()` 必须对应 `close()`
- ✅ 检查系统调用返回值，处理错误
- ✅ 使用合适的文件权限，避免安全问题
- ✅ 大文件操作时使用合适的缓冲区大小

**🔒 文件锁使用建议**
- 🔸 读操作使用共享锁，写操作使用排它锁
- 🔸 锁的粒度要合适，避免过度锁定
- 🔸 及时释放锁，避免死锁
- 🔸 考虑锁的性能影响

**⚡ 性能优化策略**
- 🚀 批量IO操作减少系统调用次数
- 🚀 使用合适的缓冲区大小
- 🚀 必要时使用内存映射(mmap)
- 🚀 合理使用 `fsync()` 保证数据安全

### 10.5 常见错误与避免


**❌ 容易犯的错误**
```
文件描述符泄漏：忘记close()
部分读写：没有处理返回值小于请求大小的情况
权限问题：文件权限设置不当
竞态条件：多进程访问文件没有加锁
```

**✅ 正确的做法**
```
资源管理：确保每个open都有对应的close
错误处理：检查所有系统调用的返回值
循环读写：处理部分读写的情况
同步机制：使用文件锁保护共享资源
```

**核心记忆口诀**：
- 系统调用连内核，文件描述符是关键
- 打开关闭要配对，读写位置可移动
- 文件锁定防冲突，缓冲提升IO速
- 错误检查不能少，资源管理要做好