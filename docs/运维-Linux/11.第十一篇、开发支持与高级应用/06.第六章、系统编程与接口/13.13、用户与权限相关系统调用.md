---
title: 13、用户与权限相关系统调用
---
## 📚 目录

1. [用户身份识别系统调用](#1-用户身份识别系统调用)
2. [权限设置与切换](#2-权限设置与切换)
3. [组权限管理](#3-组权限管理)
4. [权限检查机制](#4-权限检查机制)
5. [进程权限继承](#5-进程权限继承)
6. [特权进程管理](#6-特权进程管理)
7. [sudo机制原理](#7-sudo机制原理)
8. [安全考虑与最佳实践](#8-安全考虑与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 👤 用户身份识别系统调用


### 1.1 什么是用户ID


**简单理解**：每个用户在Linux系统中都有一个唯一的数字编号，这就是用户ID（UID）

```
用户身份的两个层面：
登录用户：  alice  (用户名)  →  1001 (UID)
当前进程：  可能以不同的UID运行

类比理解：
就像身份证号码 - 每个人都有唯一的数字标识
用户名像是姓名，UID像是身份证号
```

### 1.2 getuid() - 获取真实用户ID


**🔸 函数作用**：告诉你这个进程"真正属于"哪个用户

```c
#include <unistd.h>
#include <sys/types.h>

uid_t getuid(void);

// 简单示例
uid_t real_uid = getuid();
printf("我的真实用户ID是: %d\n", real_uid);
```

**💡 什么是真实用户ID**：
- 启动这个程序的用户的UID
- 不管程序如何切换权限，真实UID始终不变
- 用于追踪程序的"真正主人"

### 1.3 geteuid() - 获取有效用户ID


**🔸 函数作用**：告诉你这个进程"当前以什么身份"在运行

```c
uid_t geteuid(void);

// 权限检查示例
if (geteuid() == 0) {
    printf("当前以root权限运行\n");
} else {
    printf("当前以普通用户权限运行\n");
}
```

**⚡ 真实ID vs 有效ID的区别**：

```
场景说明：
普通用户alice启动了passwd程序
├── 真实UID: 1001 (alice的ID，永远不变)
└── 有效UID: 0 (root的ID，临时获得)

为什么需要这样？
passwd程序需要修改/etc/shadow文件
只有root才能修改这个文件
所以passwd程序被设置为"临时以root身份运行"
```

### 1.4 实际应用场景


**🎯 权限检查示例**：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    uid_t real_uid = getuid();
    uid_t effective_uid = geteuid();
    
    printf("═══ 用户身份信息 ═══\n");
    printf("真实用户ID: %d\n", real_uid);
    printf("有效用户ID: %d\n", effective_uid);
    
    if (real_uid != effective_uid) {
        printf("⚠️  检测到权限提升！\n");
        printf("原始用户: %d, 当前权限: %d\n", real_uid, effective_uid);
    }
    
    return 0;
}
```

---

## 2. 🔧 权限设置与切换


### 2.1 setuid() - 设置用户ID


**🔸 函数功能**：改变进程的用户身份

```c
#include <unistd.h>

int setuid(uid_t uid);
// 返回值: 成功返回0，失败返回-1
```

**💡 工作原理**：

```
setuid()的行为取决于当前权限：

特权进程 (root权限)：
├── 可以切换到任何用户
├── 同时设置真实UID和有效UID
└── 切换后无法再变回root

非特权进程：
├── 只能切换到自己的真实UID
├── 或者切换到已保存的set-user-ID
└── 不能随意切换到其他用户
```

### 2.2 seteuid() - 设置有效用户ID


**🔸 函数功能**：只改变有效用户ID，保留真实用户ID

```c
int seteuid(uid_t euid);

// 临时降权示例
uid_t original_uid = geteuid();
uid_t real_uid = getuid();

// 降权到普通用户
if (seteuid(real_uid) == -1) {
    perror("降权失败");
    exit(1);
}

// 执行普通用户操作
printf("当前以普通用户身份运行\n");

// 恢复特权 (如果程序是setuid程序)
if (seteuid(original_uid) == -1) {
    perror("恢复权限失败");
}
```

### 2.3 权限切换的安全模式


**🔒 最小权限原则示例**：

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

void secure_operation() {
    uid_t real_uid = getuid();
    uid_t saved_euid = geteuid();
    
    // 步骤1: 临时降权
    if (seteuid(real_uid) != 0) {
        perror("降权失败");
        exit(1);
    }
    
    printf("🔒 已降权，执行普通操作\n");
    
    // 执行不需要特权的操作
    system("whoami");  // 显示当前用户
    
    // 步骤2: 如果需要，恢复特权
    if (seteuid(saved_euid) != 0) {
        perror("恢复权限失败");
        exit(1);
    }
    
    printf("🔓 已恢复特权\n");
}
```

---

## 3. 👥 组权限管理


### 3.1 什么是组ID


**简单理解**：用户可以属于多个组，每个组也有唯一的数字编号（GID）

```
组的概念：
主组 (Primary Group)：    用户默认所属的组
附加组 (Supplementary)：  用户额外加入的组

示例：
用户alice属于：
├── 主组: users (GID: 100)
└── 附加组: developers (GID: 1001), sudo (GID: 27)
```

### 3.2 getgid() 和 getegid() - 组ID获取


```c
#include <unistd.h>

gid_t getgid(void);   // 获取真实组ID
gid_t getegid(void);  // 获取有效组ID

// 组信息查看示例
void show_group_info() {
    gid_t real_gid = getgid();
    gid_t effective_gid = getegid();
    
    printf("真实组ID: %d\n", real_gid);
    printf("有效组ID: %d\n", effective_gid);
}
```

### 3.3 setgid() 组权限设置


**🔸 工作机制**：与setuid()类似，但操作的是组权限

```c
int setgid(gid_t gid);
int setegid(gid_t egid);

// 组权限切换示例
void switch_group_permission() {
    gid_t target_gid = 100;  // 目标组ID
    
    if (setegid(target_gid) == 0) {
        printf("✅ 成功切换到组 %d\n", target_gid);
    } else {
        printf("❌ 组权限切换失败\n");
    }
}
```

---

## 4. 🔍 权限检查机制


### 4.1 access() - 文件访问权限检查


**🔸 函数作用**：检查当前用户是否有权限访问某个文件

```c
#include <unistd.h>

int access(const char *pathname, int mode);

// 权限检查模式
F_OK    // 文件是否存在
R_OK    // 是否可读
W_OK    // 是否可写  
X_OK    // 是否可执行
```

**💡 为什么需要access()**：

```
问题场景：
setuid程序以root权限运行
但我们想知道"原始用户"是否有权限访问某文件
直接open()会以root权限检查 - 这不是我们想要的！

access()的价值：
总是以"真实用户ID"的权限来检查
不受当前有效权限影响
```

### 4.2 权限检查实践


```c
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

void check_file_permission(const char *filename) {
    printf("═══ 检查文件: %s ═══\n", filename);
    
    // 检查文件是否存在
    if (access(filename, F_OK) == 0) {
        printf("✅ 文件存在\n");
    } else {
        printf("❌ 文件不存在\n");
        return;
    }
    
    // 检查各种权限
    printf("读权限: %s\n", access(filename, R_OK) == 0 ? "✅" : "❌");
    printf("写权限: %s\n", access(filename, W_OK) == 0 ? "✅" : "❌");
    printf("执行权限: %s\n", access(filename, X_OK) == 0 ? "✅" : "❌");
}

int main() {
    check_file_permission("/etc/passwd");
    check_file_permission("/etc/shadow");
    check_file_permission("/bin/ls");
    
    return 0;
}
```

### 4.3 安全的权限检查模式


**⚠️ 常见安全陷阱**：

```c
// ❌ 危险的做法 - 竞态条件
if (access("sensitive_file", W_OK) == 0) {
    // 在这里，文件权限可能已经被其他进程修改！
    FILE *fp = fopen("sensitive_file", "w");  // 可能失败或不安全
}

// ✅ 更安全的做法
FILE *fp = fopen("sensitive_file", "w");
if (fp == NULL) {
    if (errno == EACCES) {
        printf("权限不足\n");
    } else {
        perror("打开文件失败");
    }
} else {
    // 文件成功打开，可以安全使用
}
```

---

## 5. 🔄 进程权限继承


### 5.1 fork() 时的权限继承


**🔸 继承规则**：子进程完全继承父进程的所有权限信息

```
父进程权限状态：
├── 真实UID: 1001
├── 有效UID: 0
├── 保存的set-user-ID: 0
└── 真实GID: 100, 有效GID: 0

fork() 后子进程：
├── 真实UID: 1001    ← 完全相同
├── 有效UID: 0       ← 完全相同  
├── 保存的set-user-ID: 0  ← 完全相同
└── 真实GID: 100, 有效GID: 0  ← 完全相同
```

### 5.2 exec() 时的权限变化


**🔸 权限重置规则**：

```
普通程序执行：
├── 保持当前的真实UID/GID
├── 有效UID/GID = 真实UID/GID
└── 清除所有特殊权限

setuid程序执行：
├── 保持当前的真实UID/GID  
├── 有效UID = 程序文件的所有者UID
└── 保存的set-user-ID = 程序文件的所有者UID
```

### 5.3 权限继承示例


```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

void show_process_privileges(const char *label) {
    printf("\n═══ %s ═══\n", label);
    printf("进程ID: %d\n", getpid());
    printf("真实UID: %d, 有效UID: %d\n", getuid(), geteuid());
    printf("真实GID: %d, 有效GID: %d\n", getgid(), getegid());
}

int main() {
    show_process_privileges("父进程");
    
    pid_t pid = fork();
    
    if (pid == 0) {
        // 子进程
        show_process_privileges("子进程 (fork后)");
        
        // 执行新程序
        execl("/usr/bin/id", "id", NULL);
        
    } else if (pid > 0) {
        // 父进程
        wait(NULL);  // 等待子进程结束
        show_process_privileges("父进程 (子进程结束后)");
    }
    
    return 0;
}
```

---

## 6. 🏛️ 特权进程管理


### 6.1 什么是特权进程


**简单理解**：特权进程就是拥有超级用户权限的进程

```
特权进程的特征：
├── 有效UID = 0 (root)
├── 可以访问所有文件
├── 可以修改系统配置  
├── 可以切换到任何用户身份
└── 可以执行特殊的系统操作
```

### 6.2 特权管理策略


**🔸 最小权限原则**：只在必要时使用特权

```
权限管理的三个层次：

1️⃣ 永久降权：
   setuid(real_uid)  // 永久放弃特权，无法恢复

2️⃣ 临时降权：  
   seteuid(real_uid)  // 临时降权，可以恢复

3️⃣ 权限检查：
   if (geteuid() != 0) error("需要root权限");
```

### 6.3 安全的特权操作模式


```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

// 安全的特权操作框架
int secure_privileged_operation() {
    uid_t real_uid = getuid();
    uid_t effective_uid = geteuid();
    
    // 检查是否有特权
    if (effective_uid != 0) {
        fprintf(stderr, "❌ 此操作需要root权限\n");
        return -1;
    }
    
    printf("🔓 开始特权操作\n");
    
    // 临时降权执行安全检查
    if (seteuid(real_uid) != 0) {
        perror("降权失败");
        return -1;
    }
    
    // 以普通用户身份进行安全检查
    if (access("/etc/sensitive_config", R_OK) != 0) {
        printf("⚠️  普通用户无权访问配置文件\n");
        return -1;
    }
    
    // 恢复特权执行关键操作
    if (seteuid(0) != 0) {
        perror("恢复特权失败");
        return -1;
    }
    
    printf("🔒 执行特权操作: 修改系统配置\n");
    // 在这里执行需要root权限的操作
    
    // 操作完成后立即降权
    if (seteuid(real_uid) != 0) {
        perror("最终降权失败");
        return -1;
    }
    
    printf("✅ 特权操作完成，已降权\n");
    return 0;
}
```

---

## 7. 🔐 sudo机制原理


### 7.1 sudo是如何工作的


**🔸 sudo的本质**：一个setuid程序，让普通用户临时获得特权

```
sudo工作流程：
                                    
用户执行: sudo command
    ↓
1️⃣ sudo程序启动 (setuid root)
    ├── 真实UID: 1001 (alice)  
    └── 有效UID: 0 (root)
    ↓
2️⃣ 检查用户权限 (/etc/sudoers)
    ├── alice是否在sudoers文件中？
    └── alice是否有执行command的权限？
    ↓  
3️⃣ 身份验证 (密码验证)
    ├── 要求输入alice的密码
    └── 验证密码正确性
    ↓
4️⃣ 执行目标命令
    ├── fork()创建子进程
    ├── setuid(0) 完全切换到root
    └── exec() 执行目标命令
```

### 7.2 sudo配置机制


**🔸 /etc/sudoers文件解析**：

```bash
# 用户权限格式：
# 用户名  主机名=(运行身份) 命令列表

# 示例配置
alice   ALL=(ALL:ALL) ALL          # alice可以执行任何命令
bob     ALL=(root) /usr/bin/passwd # bob只能执行passwd命令
%wheel  ALL=(ALL) NOPASSWD: ALL    # wheel组成员无需密码

# 权限含义解释：
alice   # 用户名
ALL     # 可以在任何主机上使用
(ALL:ALL) # 可以以任何用户:组身份运行  
ALL     # 可以执行任何命令
```

### 7.3 实现一个简化的sudo


```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <string.h>

// 简化版sudo实现 (仅用于演示原理)
int simple_sudo(char *command) {
    uid_t real_uid = getuid();
    uid_t effective_uid = geteuid();
    
    // 检查程序是否以root权限运行
    if (effective_uid != 0) {
        printf("❌ 错误: 此程序需要setuid root\n");
        return -1;
    }
    
    // 获取用户信息
    struct passwd *pw = getpwuid(real_uid);
    if (!pw) {
        printf("❌ 无法获取用户信息\n");
        return -1;
    }
    
    printf("🔐 用户 %s 请求执行: %s\n", pw->pw_name, command);
    
    // 简化的权限检查 (实际应该检查sudoers文件)
    if (strcmp(pw->pw_name, "alice") != 0) {
        printf("❌ 用户 %s 无sudo权限\n", pw->pw_name);
        return -1;
    }
    
    // 简化的密码验证 (实际应该验证用户密码)
    printf("🔑 密码验证通过\n");
    
    // 执行命令
    printf("🚀 以root权限执行: %s\n", command);
    
    // 创建子进程执行命令
    pid_t pid = fork();
    if (pid == 0) {
        // 子进程: 完全切换到root身份
        if (setuid(0) != 0) {
            perror("切换到root失败");
            exit(1);
        }
        
        // 执行命令
        execl("/bin/sh", "sh", "-c", command, NULL);
        perror("命令执行失败");
        exit(1);
    }
    
    // 父进程等待命令完成
    int status;
    wait(&status);
    
    return 0;
}
```

---

## 8. 🛡️ 安全考虑与最佳实践


### 8.1 权限提升的安全风险


**⚠️ 常见安全问题**：

```
1️⃣ 权限泄露：
   问题: 获得特权后忘记降权
   风险: 后续代码以不必要的高权限运行
   
2️⃣ 竞态条件：  
   问题: 检查权限和使用权限之间的时间窗口
   风险: 文件权限在检查后被恶意修改
   
3️⃣ 环境污染：
   问题: 继承了不安全的环境变量
   风险: PATH劫持等攻击
   
4️⃣ 信号处理：
   问题: 特权进程的信号处理不当
   风险: 通过信号绕过安全检查
```

### 8.2 安全编程最佳实践


**🔒 安全检查清单**：

```c
// ✅ 安全的setuid程序模板
int secure_main() {
    // 1️⃣ 立即保存权限信息
    uid_t real_uid = getuid();
    uid_t effective_uid = geteuid();
    gid_t real_gid = getgid();
    gid_t effective_gid = getegid();
    
    // 2️⃣ 清理环境变量
    if (clearenv() != 0) {
        perror("清理环境变量失败");
        exit(1);
    }
    
    // 设置安全的PATH
    if (setenv("PATH", "/usr/bin:/bin", 1) != 0) {
        perror("设置PATH失败");
        exit(1);
    }
    
    // 3️⃣ 验证用户身份
    if (real_uid == 0) {
        printf("❌ 不允许root用户直接运行\n");
        exit(1);
    }
    
    // 4️⃣ 临时降权进行安全检查
    if (seteuid(real_uid) != 0) {
        perror("降权失败");
        exit(1);
    }
    
    // 进行各种安全检查...
    
    // 5️⃣ 只在必要时恢复特权
    if (seteuid(effective_uid) != 0) {
        perror("恢复特权失败");
        exit(1);
    }
    
    // 执行特权操作...
    
    // 6️⃣ 立即降权
    if (setuid(real_uid) != 0) {
        perror("最终降权失败");
        exit(1);
    }
    
    return 0;
}
```

### 8.3 权限审计与监控


**📊 权限监控要点**：

| 监控项目 | 重要性 | 检查方法 |
|---------|--------|----------|
| **setuid程序** | 🔴高 | `find / -perm -4000 -type f` |
| **特权进程** | 🔴高 | `ps aux | grep "UID.*0"` |
| **权限变化** | 🟡中 | 审计日志分析 |
| **文件权限** | 🟡中 | 定期权限扫描 |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 用户身份系统调用：
   ├── getuid() - 获取真实用户ID (永远不变)
   ├── geteuid() - 获取有效用户ID (当前权限)
   ├── setuid() - 设置用户ID (永久性切换)
   └── seteuid() - 设置有效用户ID (临时性切换)

🔸 组权限管理：
   ├── getgid()/getegid() - 获取组ID
   ├── setgid()/setegid() - 设置组ID  
   └── 主组vs附加组的区别

🔸 权限检查机制：
   ├── access() - 以真实用户身份检查权限
   ├── 避免竞态条件的安全检查
   └── 权限检查与文件操作的最佳实践
```

### 9.2 关键理解要点


**🔹 真实ID vs 有效ID**：
```
真实ID：你真正是谁 (不变的身份)
有效ID：你当前以什么身份在行动 (可变的权限)

类比：
真实ID = 身份证上的身份
有效ID = 当前佩戴的工作证
```

**🔹 权限提升的时机**：
```
获得特权 → 立即降权 → 必要时临时提权 → 立即降权
     ↓         ↓           ↓           ↓
   危险状态   安全状态    危险状态     安全状态
```

**🔹 sudo的本质**：
```
sudo = setuid程序 + 权限配置 + 身份验证
目的：让普通用户在受控情况下临时获得特权
```

### 9.3 实际应用价值


**🎯 系统编程应用**：
- **特权程序开发**：需要root权限的系统工具
- **权限管理系统**：用户权限控制和审计
- **安全工具开发**：权限检查和监控程序
- **系统服务设计**：守护进程的权限管理

**🔧 实践要点**：
- **最小权限原则**：只在必要时使用特权
- **防御性编程**：假设所有输入都不可信
- **权限审计**：定期检查系统权限配置
- **安全测试**：验证权限控制的有效性

**核心记忆口诀**：
```
真实身份永不变，有效权限可切换
特权获得要谨慎，用完立即就降权
检查权限用access，避免竞态要小心
sudo本质setuid程，权限控制靠配置
```