---
title: 10、Keepalived高可用实现
---
## 📚 目录

1. [Keepalived基础概念](#1-Keepalived基础概念)
2. [安装与基础配置](#2-安装与基础配置)
3. [VRRP虚拟路由协议](#3-VRRP虚拟路由协议)
4. [虚拟IP地址管理](#4-虚拟IP地址管理)
5. [主备切换配置](#5-主备切换配置)
6. [健康检查机制](#6-健康检查机制)
7. [抢占与非抢占模式](#7-抢占与非抢占模式)
8. [认证与安全配置](#8-认证与安全配置)
9. [状态通知机制](#9-状态通知机制)
10. [实战应用场景](#10-实战应用场景)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🏗️ Keepalived基础概念


### 1.1 什么是Keepalived


**💡 基本定义**
Keepalived是一个用于Linux系统的高可用性解决方案，主要用来防止单点故障。简单来说，就是当你的主服务器挂了，备用服务器能够自动接管工作，保证服务不中断。

**🎯 核心作用**
```
现实场景类比：
主服务器 = 公司的主要办公楼
备用服务器 = 备用办公楼
虚拟IP = 公司的统一地址

当主办公楼出问题时，所有业务自动转移到备用办公楼
但对外的地址（虚拟IP）保持不变，客户感觉不到变化
```

### 1.2 Keepalived的工作原理


**🔄 工作机制图示**
```
正常状态：
客户端 → 虚拟IP(192.168.1.100) → 主服务器A(MASTER)
                                     备服务器B(BACKUP) 待机

故障切换：
客户端 → 虚拟IP(192.168.1.100) → 主服务器A(DOWN)
                                     备服务器B(MASTER) 接管
```

**⚙️ 核心组件**
- **VRRP协议**：负责主备切换的通信协议
- **虚拟IP**：对外提供服务的统一IP地址
- **健康检查**：监控服务状态的检查机制
- **状态同步**：主备服务器之间的状态通信

### 1.3 使用场景


**✅ 适用场景**
- **Web服务器**：nginx、apache的高可用
- **数据库服务**：MySQL主备切换
- **负载均衡器**：防止负载均衡器单点故障
- **网关设备**：路由器、防火墙的备份

**🎯 解决的问题**
- **单点故障**：避免关键服务因单台服务器故障而中断
- **自动切换**：无需人工干预，自动完成故障转移
- **服务连续性**：最大化服务可用性和业务连续性

---

## 2. ⚙️ 安装与基础配置


### 2.1 Keepalived安装


**📦 不同系统的安装方法**

在CentOS/RHEL系统：
```bash
# 安装keepalived
yum install -y keepalived

# 启动并设置开机自启
systemctl start keepalived
systemctl enable keepalived
```

在Ubuntu/Debian系统：
```bash
# 更新包列表
apt update

# 安装keepalived
apt install -y keepalived

# 启动服务
systemctl start keepalived
systemctl enable keepalived
```

### 2.2 基本配置文件结构


**📂 配置文件位置**
主配置文件：`/etc/keepalived/keepalived.conf`

**📋 配置文件基本结构**
```
keepalived.conf 文件结构：
├── global_defs          # 全局配置段
├── vrrp_script          # 健康检查脚本段
├── vrrp_instance        # VRRP实例配置段
└── virtual_server       # 虚拟服务器配置段（可选）
```

### 2.3 最简单的配置示例


**🔧 主服务器配置**
```bash
# /etc/keepalived/keepalived.conf
global_defs {
   router_id LVS_MASTER    # 路由器标识，主备要不同
}

vrrp_instance VI_1 {
    state MASTER           # 角色：主服务器
    interface eth0         # 监听的网卡接口
    virtual_router_id 51   # 虚拟路由ID，主备必须相同
    priority 100           # 优先级，主服务器设置更高
    advert_int 1           # 心跳间隔，1秒
    
    authentication {
        auth_type PASS     # 认证类型
        auth_pass 1234     # 认证密码，主备必须相同
    }
    
    virtual_ipaddress {
        192.168.1.100      # 虚拟IP地址
    }
}
```

**🔧 备用服务器配置**
```bash
# /etc/keepalived/keepalived.conf
global_defs {
   router_id LVS_BACKUP   # 路由器标识，与主服务器不同
}

vrrp_instance VI_1 {
    state BACKUP           # 角色：备用服务器
    interface eth0         # 监听的网卡接口
    virtual_router_id 51   # 虚拟路由ID，与主服务器相同
    priority 90            # 优先级，比主服务器低
    advert_int 1           # 心跳间隔
    
    authentication {
        auth_type PASS
        auth_pass 1234     # 与主服务器相同的密码
    }
    
    virtual_ipaddress {
        192.168.1.100      # 与主服务器相同的虚拟IP
    }
}
```

---

## 3. 🌐 VRRP虚拟路由协议


### 3.1 VRRP协议基础


**💡 什么是VRRP**
VRRP（Virtual Router Redundancy Protocol）是虚拟路由冗余协议，它的作用就是让多台路由器（或服务器）看起来像一台虚拟的路由器，对外提供统一的服务。

**🔄 VRRP工作流程**
```
步骤1：选举MASTER
┌─────────────┐    ┌─────────────┐
│ 服务器A     │    │ 服务器B     │
│ 优先级:100  │◄──►│ 优先级:90   │
│ 状态:MASTER │    │ 状态:BACKUP │
└─────────────┘    └─────────────┘

步骤2：MASTER发送心跳
MASTER每隔1秒发送VRRP通告：
"我是MASTER，我还活着！"

步骤3：故障检测
如果BACKUP在3秒内没收到心跳：
"MASTER可能挂了，我来接管！"
```

### 3.2 VRRP关键参数详解


**⭐ 重要参数说明**

| 参数 | 含义 | 设置建议 |
|------|------|----------|
| **virtual_router_id** | 虚拟路由器ID | 同一组主备必须相同，范围1-255 |
| **priority** | 优先级 | 主服务器100，备服务器90 |
| **advert_int** | 心跳间隔 | 通常设置1秒，网络不稳定可设置2-3秒 |
| **state** | 初始状态 | MASTER或BACKUP |

**🔍 状态转换机制**
```
BACKUP → MASTER 切换条件：
1. 在 3 × advert_int 时间内没收到MASTER心跳
2. 收到优先级为0的MASTER通告（主动退出）
3. 自己的优先级高于当前MASTER（抢占模式）

MASTER → BACKUP 切换条件：
1. 接收到更高优先级的VRRP通告
2. 网卡接口DOWN
3. 健康检查失败（如果配置了）
```

### 3.3 VRRP实例配置进阶


**🔧 多实例配置示例**
```bash
# 可以配置多个VRRP实例实现多个虚拟IP
vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    virtual_ipaddress {
        192.168.1.100    # 第一个虚拟IP
    }
}

vrrp_instance VI_2 {
    state BACKUP         # 第二个实例可以是BACKUP
    interface eth0
    virtual_router_id 52
    priority 90
    virtual_ipaddress {
        192.168.1.101    # 第二个虚拟IP
    }
}
```

---

## 4. 🌐 虚拟IP地址管理


### 4.1 虚拟IP的概念


**💡 虚拟IP是什么**
虚拟IP（VIP）就是一个"假的"IP地址，它不固定绑定在某台服务器上，而是可以在不同服务器之间漂移。客户端始终访问这个虚拟IP，无论后端是哪台服务器在服务。

**🎯 虚拟IP的作用**
```
传统方式：
客户端 → 192.168.1.10 (主服务器)
         192.168.1.11 (备服务器，需要手动切换)

使用虚拟IP：
客户端 → 192.168.1.100 (虚拟IP)
         ↓
         自动指向可用的服务器 (192.168.1.10 或 192.168.1.11)
```

### 4.2 虚拟IP配置详解


**🔧 基本虚拟IP配置**
```bash
virtual_ipaddress {
    192.168.1.100          # 基本虚拟IP
    192.168.1.101/24       # 带子网掩码的虚拟IP
    192.168.1.102/24 dev eth1    # 指定网卡的虚拟IP
}
```

**🔧 高级虚拟IP配置**
```bash
virtual_ipaddress {
    192.168.1.100/24 dev eth0 scope global    # 完整配置
    # dev eth0      - 绑定到eth0网卡
    # scope global  - 全局可路由
    # /24          - 子网掩码
}

# 虚拟路由配置
virtual_routes {
    0.0.0.0/0 via 192.168.1.1 dev eth0    # 默认路由
    10.0.0.0/8 via 192.168.1.254          # 特定网段路由
}
```

### 4.3 虚拟IP的验证


**🔍 检查虚拟IP状态**
```bash
# 查看当前IP地址（虚拟IP会显示为secondary）
ip addr show eth0

# 示例输出：
# 2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
#    inet 192.168.1.10/24 brd 192.168.1.255 scope global eth0
#    inet 192.168.1.100/32 scope global secondary eth0    # 这就是虚拟IP

# 测试虚拟IP连通性
ping 192.168.1.100

# 查看ARP表（虚拟IP的MAC地址）
arp -n | grep 192.168.1.100
```

**⚠️ 常见问题与解决**

> **问题1**：虚拟IP无法访问
> - **原因**：防火墙阻止、网卡状态异常、IP冲突
> - **解决**：检查防火墙规则、确认网卡UP状态、检查IP是否重复

> **问题2**：虚拟IP在两台服务器都存在
> - **原因**：网络分割（脑裂）、配置错误
> - **解决**：检查网络连通性、确认配置一致性

---

## 5. 🔄 主备切换配置


### 5.1 主备切换原理


**🔄 切换机制说明**
主备切换的核心是通过VRRP协议来实现的，当主服务器出现问题时，备用服务器会自动接管虚拟IP和相关服务。

```
正常状态：
主服务器A [MASTER] ←→ 心跳通信 ←→ 备服务器B [BACKUP]
    ↓                                    ↓
 拥有虚拟IP                           监听状态

故障切换：
主服务器A [DOWN]    ✗ 心跳中断 ✗    备服务器B [MASTER]
    ↓                                    ↓
 失去虚拟IP                          接管虚拟IP
```

### 5.2 切换时间参数调优


**⏱️ 关键时间参数**
```bash
vrrp_instance VI_1 {
    advert_int 1           # 心跳间隔：1秒
    # 切换时间 = 3 × advert_int = 3秒
    
    # 快速切换配置（亚秒级）
    advert_int 1
    # 实际可以设置小数：advert_int 0.1（100毫秒）
}
```

**🎯 切换时间优化**
- **快速切换**：`advert_int 0.5`（500毫秒心跳，1.5秒切换）
- **标准配置**：`advert_int 1`（1秒心跳，3秒切换）
- **网络不稳定**：`advert_int 3`（3秒心跳，9秒切换）

### 5.3 主备切换脚本


**📜 切换通知脚本**
```bash
# 创建切换通知脚本
cat > /etc/keepalived/notify.sh << 'EOF'
#!/bin/bash
# $1 = "GROUP"|"INSTANCE"
# $2 = name of group or instance
# $3 = target state of transition (MASTER|BACKUP|FAULT)

TYPE=$1
NAME=$2
STATE=$3

case $STATE in
    "MASTER")
        echo "$(date): $NAME 切换为 MASTER 状态" >> /var/log/keepalived-notify.log
        # 启动相关服务
        systemctl start nginx
        ;;
    "BACKUP")
        echo "$(date): $NAME 切换为 BACKUP 状态" >> /var/log/keepalived-notify.log
        # 停止相关服务
        systemctl stop nginx
        ;;
    "FAULT")
        echo "$(date): $NAME 进入 FAULT 状态" >> /var/log/keepalived-notify.log
        ;;
    *)
        echo "$(date): $NAME 未知状态: $STATE" >> /var/log/keepalived-notify.log
        ;;
esac
EOF

# 设置执行权限
chmod +x /etc/keepalived/notify.sh
```

**🔧 在配置中使用通知脚本**
```bash
vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    
    # 添加通知脚本
    notify_master "/etc/keepalived/notify.sh INSTANCE VI_1 MASTER"
    notify_backup "/etc/keepalived/notify.sh INSTANCE VI_1 BACKUP"
    notify_fault  "/etc/keepalived/notify.sh INSTANCE VI_1 FAULT"
    
    virtual_ipaddress {
        192.168.1.100
    }
}
```

---

## 6. 🔍 健康检查机制


### 6.1 健康检查的重要性


**💡 为什么需要健康检查**
仅仅检查keepalived进程是否存在是不够的，我们需要确保实际的业务服务（如nginx、MySQL）也是正常运行的。健康检查就是用来监控这些业务服务状态的。

**🎯 健康检查场景**
```
场景1：keepalived正常，但nginx服务停止
→ 没有健康检查：虚拟IP仍然指向这台服务器，用户无法访问
→ 有健康检查：检测到nginx停止，自动切换到备用服务器

场景2：服务器网络正常，但数据库连接失败
→ 健康检查脚本检测数据库连接，失败时降低优先级或切换
```

### 6.2 健康检查脚本配置


**📜 基本健康检查脚本**
```bash
# 创建nginx健康检查脚本
cat > /etc/keepalived/check_nginx.sh << 'EOF'
#!/bin/bash

# 检查nginx进程是否存在
if ! pgrep nginx > /dev/null; then
    echo "Nginx进程不存在"
    exit 1
fi

# 检查nginx端口是否监听
if ! netstat -tnl | grep ':80' > /dev/null; then
    echo "Nginx端口80未监听"
    exit 1
fi

# 检查nginx响应是否正常
if ! curl -f http://localhost > /dev/null 2>&1; then
    echo "Nginx无法正常响应"
    exit 1
fi

echo "Nginx服务正常"
exit 0
EOF

chmod +x /etc/keepalived/check_nginx.sh
```

**🔧 在keepalived中配置健康检查**
```bash
# 定义健康检查脚本
vrrp_script chk_nginx {
    script "/etc/keepalived/check_nginx.sh"    # 脚本路径
    interval 2                                 # 检查间隔：2秒
    weight -20                                 # 失败时优先级减20
    fall 3                                     # 连续失败3次才认为失败
    rise 2                                     # 连续成功2次才认为恢复
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    
    # 引用健康检查脚本
    track_script {
        chk_nginx
    }
    
    virtual_ipaddress {
        192.168.1.100
    }
}
```

### 6.3 健康检查参数详解


**⭐ 重要参数说明**

| 参数 | 含义 | 推荐值 |
|------|------|--------|
| **interval** | 检查间隔时间 | 2-5秒，太频繁影响性能 |
| **weight** | 优先级变化值 | -10到-30，失败时降低优先级 |
| **fall** | 连续失败次数 | 2-3次，避免误判 |
| **rise** | 连续成功次数 | 2次，快速恢复 |

**🔍 健康检查状态验证**
```bash
# 查看keepalived日志
tail -f /var/log/messages | grep keepalived

# 手动测试健康检查脚本
/etc/keepalived/check_nginx.sh
echo $?    # 0表示成功，非0表示失败

# 查看当前VRRP状态
systemctl status keepalived
```

---

## 7. ⚡ 抢占与非抢占模式


### 7.1 抢占模式详解


**💡 什么是抢占模式**
抢占模式就是当优先级更高的服务器恢复时，它会主动"抢回"MASTER角色。非抢占模式则相反，即使高优先级服务器恢复了，也不会主动抢回MASTER角色。

**🔄 抢占模式工作流程**
```
抢占模式（默认）：
时刻1：主服务器A(优先级100) = MASTER，备服务器B(优先级90) = BACKUP
时刻2：主服务器A故障，备服务器B自动成为MASTER
时刻3：主服务器A恢复，发现自己优先级更高，主动抢回MASTER角色
结果：主服务器A重新成为MASTER，备服务器B回到BACKUP

非抢占模式：
时刻1：主服务器A(优先级100) = MASTER，备服务器B(优先级90) = BACKUP  
时刻2：主服务器A故障，备服务器B自动成为MASTER
时刻3：主服务器A恢复，但不抢回MASTER角色
结果：备服务器B继续保持MASTER，主服务器A成为BACKUP
```

### 7.2 抢占模式配置


**🔧 抢占模式配置（默认行为）**
```bash
vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    # 抢占模式是默认的，不需要特别配置
    
    virtual_ipaddress {
        192.168.1.100
    }
}
```

**🔧 非抢占模式配置**
```bash
vrrp_instance VI_1 {
    state BACKUP               # 注意：两台服务器都设置为BACKUP
    interface eth0
    virtual_router_id 51
    priority 100               # 主服务器优先级高
    nopreempt                  # 关键：启用非抢占模式
    
    virtual_ipaddress {
        192.168.1.100
    }
}

# 备用服务器配置
vrrp_instance VI_1 {
    state BACKUP               # 也设置为BACKUP
    interface eth0
    virtual_router_id 51
    priority 90                # 备服务器优先级低
    nopreempt                  # 同样启用非抢占模式
    
    virtual_ipaddress {
        192.168.1.100
    }
}
```

### 7.3 选择抢占还是非抢占


**✅ 抢占模式适用场景**
- **明确的主备关系**：有明确的主服务器和备服务器
- **硬件差异明显**：主服务器配置明显更好
- **短时间故障**：故障通常很快能修复

**✅ 非抢占模式适用场景**
- **避免频繁切换**：减少因网络抖动造成的来回切换
- **服务稳定性优先**：一旦切换后保持稳定，避免二次中断
- **相同硬件配置**：两台服务器配置相当

**⚠️ 注意事项**

> **非抢占模式限制**：
> - 只有优先级最高的VRRP实例才能使用 `nopreempt`
> - 初始状态必须设置为 `BACKUP`，不能设置为 `MASTER`
> - 两台服务器都要配置 `nopreempt`

---

## 8. 🔐 认证与安全配置


### 8.1 VRRP认证机制


**💡 为什么需要认证**
在同一个网络中，如果有多个keepalived实例使用相同的虚拟路由ID，就可能发生冲突。认证机制确保只有配置了正确密码的服务器才能参与VRRP通信。

**🔐 认证类型**
- **PASS**：简单密码认证（最常用）
- **AH**：IP认证头（Authentication Header），更安全但配置复杂

### 8.2 认证配置详解


**🔧 基本认证配置**
```bash
vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    
    # 简单密码认证
    authentication {
        auth_type PASS          # 认证类型
        auth_pass mypassword    # 密码（最长8个字符）
    }
    
    virtual_ipaddress {
        192.168.1.100
    }
}
```

**⚠️ 认证安全注意事项**

> **密码要求**：
> - 最长8个字符
> - 主备服务器必须完全相同
> - 避免使用简单密码如"123456"

> **安全建议**：
> - 定期更换认证密码
> - 使用复杂密码组合
> - 结合防火墙规则增强安全性

### 8.3 网络安全配置


**🔥 防火墙配置**
```bash
# VRRP协议使用IP协议号112，需要放行
# CentOS/RHEL防火墙配置
firewall-cmd --permanent --add-rich-rule="rule protocol value='vrrp' accept"
firewall-cmd --reload

# 或者使用iptables
iptables -I INPUT -p vrrp -j ACCEPT

# 允许组播地址 224.0.0.18
iptables -I INPUT -d 224.0.0.18 -j ACCEPT
```

**🌐 网络访问控制**
```bash
# 只允许特定IP参与VRRP通信
iptables -I INPUT -p vrrp -s 192.168.1.10 -j ACCEPT
iptables -I INPUT -p vrrp -s 192.168.1.11 -j ACCEPT
iptables -A INPUT -p vrrp -j DROP
```

---

## 9. 📢 状态通知机制


### 9.1 状态通知的作用


**💡 什么是状态通知**
状态通知机制让我们能够在keepalived状态发生变化时执行自定义的操作，比如发送邮件、启动/停止服务、记录日志等。

**🔔 通知触发场景**
- **成为MASTER**：接管虚拟IP，需要启动相关服务
- **变为BACKUP**：失去虚拟IP，可以停止部分服务节省资源  
- **进入FAULT**：发生故障，需要记录日志或报警

### 9.2 通知脚本配置


**📜 完整的通知脚本示例**
```bash
cat > /etc/keepalived/notify_comprehensive.sh << 'EOF'
#!/bin/bash

TYPE=$1      # GROUP 或 INSTANCE
NAME=$2      # 实例名称
STATE=$3     # 新状态：MASTER/BACKUP/FAULT
PRIORITY=$4  # 当前优先级

LOG_FILE="/var/log/keepalived-notify.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

# 记录状态变化
echo "[$DATE] $NAME: $STATE (Priority: $PRIORITY)" >> $LOG_FILE

case $STATE in
    "MASTER")
        echo "[$DATE] 成为MASTER，启动业务服务" >> $LOG_FILE
        
        # 启动nginx服务
        systemctl start nginx
        
        # 发送邮件通知（需要配置邮件系统）
        # echo "服务器 $(hostname) 成为MASTER" | mail -s "Keepalived状态变化" admin@company.com
        
        # 更新DNS记录（如果需要）
        # /path/to/update_dns.sh
        ;;
        
    "BACKUP")
        echo "[$DATE] 变为BACKUP，停止非必要服务" >> $LOG_FILE
        
        # 可以选择停止nginx来节省资源
        # systemctl stop nginx
        ;;
        
    "FAULT")
        echo "[$DATE] 进入FAULT状态，需要检查！" >> $LOG_FILE
        
        # 发送紧急通知
        logger -p local0.err "KEEPALIVED FAULT: $NAME on $(hostname)"
        ;;
esac

# 记录当前虚拟IP状态
ip addr show | grep -E "inet.*secondary" >> $LOG_FILE
EOF

chmod +x /etc/keepalived/notify_comprehensive.sh
```

**🔧 在keepalived配置中使用通知**
```bash
vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    
    # 配置各种状态的通知脚本
    notify_master "/etc/keepalived/notify_comprehensive.sh INSTANCE VI_1 MASTER 100"
    notify_backup "/etc/keepalived/notify_comprehensive.sh INSTANCE VI_1 BACKUP 100"  
    notify_fault  "/etc/keepalived/notify_comprehensive.sh INSTANCE VI_1 FAULT 100"
    
    # 通用通知脚本（所有状态变化都会调用）
    notify "/etc/keepalived/notify_comprehensive.sh INSTANCE VI_1"
    
    virtual_ipaddress {
        192.168.1.100
    }
}
```

### 9.3 日志监控与报警


**📊 日志分析脚本**
```bash
cat > /etc/keepalived/monitor_log.sh << 'EOF'
#!/bin/bash

LOG_FILE="/var/log/keepalived-notify.log"
ALERT_FILE="/tmp/keepalived_alert"

# 检查最近5分钟内的频繁切换
RECENT_CHANGES=$(tail -100 $LOG_FILE | grep "$(date '+%Y-%m-%d %H:%M' -d '5 minutes ago')" | wc -l)

if [ $RECENT_CHANGES -gt 3 ]; then
    if [ ! -f $ALERT_FILE ]; then
        echo "警告：检测到频繁的主备切换，可能存在网络问题" | logger -p local0.warning
        touch $ALERT_FILE
    fi
else
    # 清除报警状态
    rm -f $ALERT_FILE 2>/dev/null
fi
EOF

# 添加到cron定时执行
echo "*/5 * * * * /etc/keepalived/monitor_log.sh" | crontab -
```

---

## 10. 🚀 实战应用场景


### 10.1 Nginx负载均衡器高可用


**🎯 场景描述**
两台服务器作为nginx负载均衡器，后端有多台Web服务器。需要确保负载均衡器不会成为单点故障。

**🔧 完整配置示例**

主负载均衡器配置：
```bash
# /etc/keepalived/keepalived.conf
global_defs {
    router_id LB_MASTER
    vrrp_skip_check_adv_addr
    vrrp_strict
}

# nginx健康检查脚本
vrrp_script chk_nginx {
    script "/etc/keepalived/check_nginx.sh"
    interval 3
    weight -20
    fall 3
    rise 2
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 88
    priority 110
    advert_int 1
    
    authentication {
        auth_type PASS
        auth_pass lb@2024
    }
    
    track_script {
        chk_nginx
    }
    
    virtual_ipaddress {
        192.168.1.88/24 dev eth0    # 负载均衡器VIP
    }
    
    notify_master "/etc/keepalived/notify.sh MASTER"
    notify_backup "/etc/keepalived/notify.sh BACKUP"
}
```

**🔍 nginx健康检查脚本**
```bash
cat > /etc/keepalived/check_nginx.sh << 'EOF'
#!/bin/bash

# 检查nginx进程
if ! pgrep nginx >/dev/null 2>&1; then
    exit 1
fi

# 检查nginx配置是否正确
if ! nginx -t >/dev/null 2>&1; then
    exit 1
fi

# 检查upstream后端服务器
if ! curl -f http://localhost/health >/dev/null 2>&1; then
    exit 1
fi

exit 0
EOF
```

### 10.2 MySQL数据库主备高可用


**🎯 场景描述**
MySQL主从复制环境，使用keepalived实现自动故障转移。

**⚠️ 重要说明**

> MySQL高可用比较复杂，keepalived只负责VIP切换，不负责数据同步。
> 需要结合MySQL主从复制或MySQL Cluster使用。

**🔧 MySQL健康检查脚本**
```bash
cat > /etc/keepalived/check_mysql.sh << 'EOF'
#!/bin/bash

MYSQL_USER="keepalived"
MYSQL_PASS="check123"
MYSQL_HOST="localhost"
MYSQL_PORT="3306"

# 检查MySQL进程
if ! pgrep mysqld >/dev/null 2>&1; then
    exit 1
fi

# 检查MySQL连接
if ! mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASS -e "SELECT 1;" >/dev/null 2>&1; then
    exit 1
fi

# 检查主从同步状态（如果是从库）
# SLAVE_STATUS=$(mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW SLAVE STATUS\G" | grep "Slave_SQL_Running" | awk '{print $2}')
# if [ "$SLAVE_STATUS" != "Yes" ]; then
#     exit 1
# fi

exit 0
EOF
```

### 10.3 Web服务高可用方案


**🏗️ 完整架构图**
```
            Internet
                |
        ┌───────────────┐
        │  负载均衡器VIP │ 192.168.1.100
        │               │
        └───────┬───────┘
                │
    ┌───────────┴───────────┐
    │                       │
┌───▼────┐             ┌────▼───┐
│LB1     │             │LB2     │
│MASTER  │◄──VRRP────►│BACKUP  │
│nginx   │             │nginx   │
└───┬────┘             └────┬───┘
    │                       │
    └─────────┬─────────────┘
              │
    ┌─────────┴─────────┐
    │                   │
┌───▼───┐           ┌───▼───┐
│Web1   │           │Web2   │
│Apache │           │Apache │
└───────┘           └───────┘
```

**🔧 负载均衡器nginx配置**
```bash
# /etc/nginx/nginx.conf
upstream web_servers {
    server 192.168.1.201:80 weight=1 max_fails=2 fail_timeout=10s;
    server 192.168.1.202:80 weight=1 max_fails=2 fail_timeout=10s;
}

server {
    listen 80;
    server_name www.example.com;
    
    location / {
        proxy_pass http://web_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    
    # 健康检查接口
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的基本概念


**🎯 Keepalived核心概念**
- **VRRP协议**：实现虚拟路由冗余的通信协议
- **虚拟IP**：可以在服务器间漂移的IP地址
- **主备角色**：MASTER提供服务，BACKUP待机监控
- **优先级**：决定哪台服务器成为MASTER的重要参数
- **健康检查**：监控业务服务状态的检测机制

### 11.2 关键配置参数


| 参数 | 作用 | 典型值 | 注意事项 |
|------|------|--------|----------|
| **virtual_router_id** | 虚拟路由标识 | 1-255 | 同组主备必须相同 |
| **priority** | 优先级 | 主100，备90 | 数值越大优先级越高 |
| **advert_int** | 心跳间隔 | 1秒 | 切换时间=3倍心跳间隔 |
| **authentication** | 认证配置 | PASS+密码 | 主备密码必须相同 |

### 11.3 部署最佳实践


**✅ 配置建议**
1. **网络规划**：确保主备服务器网络互通，防火墙放行VRRP协议
2. **时间同步**：使用NTP确保两台服务器时间一致
3. **健康检查**：必须配置业务层面的健康检查脚本
4. **状态通知**：配置状态变化通知脚本，便于监控和故障排查
5. **日志记录**：启用详细日志，便于问题诊断

**⚠️ 常见问题避免**
- **脑裂问题**：确保网络连通性，避免网络分割
- **IP冲突**：确保虚拟IP没有被其他设备使用
- **权限问题**：确保keepalived有足够权限操作网络接口
- **防火墙阻挡**：放行VRRP协议（IP协议号112）

### 11.4 故障排查思路


**🔍 问题诊断步骤**
1. **检查服务状态**：`systemctl status keepalived`
2. **查看日志**：`tail -f /var/log/messages | grep keepalived`
3. **检查网络**：`ip addr show` 查看虚拟IP是否存在
4. **测试连通性**：`ping` 虚拟IP，测试服务可用性
5. **验证配置**：`keepalived -t -f /etc/keepalived/keepalived.conf`

**🎯 性能调优要点**
- **合理设置心跳间隔**：平衡切换速度和网络负载
- **优化健康检查**：避免检查过于频繁影响性能
- **选择合适模式**：根据业务需求选择抢占或非抢占模式

**核心记忆口诀**：
- Keepalived保高可用，VRRP协议是关键
- 虚拟IP来回漂移，主备切换要自然
- 健康检查不可少，业务正常才算好
- 优先级高者为主，心跳中断就切换