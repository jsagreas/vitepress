---
title: 7、故障检测与切换机制
---
## 📚 目录

1. [心跳检测机制](#1-心跳检测机制)
2. [节点故障判断](#2-节点故障判断)
3. [服务健康检查](#3-服务健康检查)
4. [自动故障切换](#4-自动故障切换)
5. [切换时间优化](#5-切换时间优化)
6. [故障恢复流程](#6-故障恢复流程)
7. [切换日志记录](#7-切换日志记录)
8. [误切换防护](#8-误切换防护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 💓 心跳检测机制


### 1.1 心跳机制基本概念


**什么是心跳检测**：
心跳检测就像人的心跳一样，用来证明"我还活着"。在高可用集群中，各个节点之间会定期发送信号来证明自己还在正常工作。

```
简单理解：
节点A对节点B说："我还活着吗？"
节点B回答："收到，你还活着！"
如果节点B没有回答，节点A就认为B可能出问题了
```

**🔸 心跳检测的作用**
- **存活监控**：确认节点是否还在运行
- **网络连通性**：检查节点间网络是否正常
- **服务状态**：监控关键服务是否正常响应
- **资源状态**：监控CPU、内存等资源使用情况

### 1.2 心跳检测方式


**📡 网络心跳**
```bash
# ICMP ping检测
ping -c 1 -W 2 192.168.1.100

# TCP端口检测
nc -z -w 3 192.168.1.100 22

# UDP心跳包
echo "heartbeat" | nc -u 192.168.1.100 5555
```

**💾 磁盘心跳**
```bash
# 共享存储心跳文件
echo "node1-$(date)" > /shared/heartbeat/node1
```

**🔌 串口心跳**
```bash
# 通过串口发送心跳信号
echo "alive" > /dev/ttyS0
```

### 1.3 心跳参数配置


**⏱️ 关键参数说明**

| 参数名称 | **含义说明** | **推荐值** | **影响** |
|---------|-------------|-----------|---------|
| `心跳间隔` | `多久发送一次心跳` | `1-3秒` | `间隔太短消耗资源，太长检测滞后` |
| `心跳超时` | `多久没收到心跳算超时` | `5-10秒` | `超时太短误判，太长切换慢` |
| `故障阈值` | `连续几次超时算故障` | `3-5次` | `阈值太低误切换，太高延迟长` |

**配置示例（Heartbeat）**：
```bash
# /etc/ha.d/ha.cf
keepalive 2          # 心跳间隔2秒
deadtime 10          # 10秒无心跳判定死亡
warntime 5           # 5秒无心跳发出警告
initdead 30          # 启动后30秒内允许无心跳
```

### 1.4 多路径心跳


**🛣️ 为什么需要多路径**：
单一心跳路径可能因为网络故障导致误判，多路径心跳可以提高检测准确性。

```
心跳路径示例：
节点A ←--网络心跳--→ 节点B
    ↑                 ↓
   共享存储 ←--磁盘心跳--→
    ↑                 ↓  
   串口线 ←--串口心跳---→
```

**配置多路径心跳**：
```bash
# 网络心跳
bcast eth0
bcast eth1

# 串口心跳  
serial /dev/ttyS0

# 多播心跳
mcast eth0 225.0.0.1 694 1 0
```

---

## 2. 🔍 节点故障判断


### 2.1 故障判断逻辑


**📊 故障判断流程**
```
开始监控
    ↓
发送心跳包
    ↓
等待响应 → 收到响应 → 正常状态
    ↓
超时无响应
    ↓
故障计数器+1
    ↓
达到故障阈值？ → 否 → 继续监控
    ↓ 是
节点故障确认
    ↓
启动故障处理
```

### 2.2 故障类型识别


**🔸 硬件故障**
- **服务器宕机**：完全无响应
- **网卡故障**：网络心跳中断
- **电源故障**：突然断电

**检测方法**：
```bash
# 检测网卡状态
ethtool eth0 | grep "Link detected"

# 检测硬件错误
dmesg | grep -i error

# 检测系统负载
uptime
```

**🔸 软件故障**
- **服务进程死锁**：进程存在但无响应
- **资源耗尽**：内存不足、磁盘满
- **网络拥塞**：网络延迟过高

**检测方法**：
```bash
# 检测服务状态
systemctl status httpd

# 检测资源使用
free -h
df -h

# 检测网络延迟
ping -c 5 目标IP
```

### 2.3 Split-Brain防护


**🧠 什么是脑裂**：
脑裂就像一个人有两个大脑，都认为自己是对的。在集群中，当网络中断时，两个节点都认为对方死了，都想成为主节点。

```
正常状态：
主节点A ←--心跳--→ 备节点B
  ↓
提供服务

脑裂状态：
主节点A ←--×断网×--→ 主节点B
  ↓                    ↓
提供服务              提供服务
(数据冲突！)
```

**🛡️ 防护机制**

**仲裁磁盘（Quorum Disk）**：
```bash
# 配置仲裁设备
echo "/dev/sdb1" > /etc/cluster/quorum_disk

# 检查仲裁状态
cat /proc/cluster/quorum
```

**节点数量要求**：
- **奇数节点**：3个节点中至少2个同意才能操作
- **投票机制**：超过半数节点同意才能成为主节点

```
3节点集群投票：
节点A得票：2票（自己+节点B）
节点C得票：1票（自己）
结果：节点A成为主节点
```

---

## 3. 🏥 服务健康检查


### 3.1 健康检查类型


**🔸 进程级检查**
检查服务进程是否还在运行：
```bash
# 检查进程是否存在
pgrep httpd

# 检查进程状态
ps aux | grep httpd

# 使用systemd检查
systemctl is-active httpd
```

**🔸 端口级检查**
检查服务端口是否在监听：
```bash
# 检查端口监听
netstat -tlnp | grep :80

# 使用ss命令
ss -tlnp | grep :80

# 测试端口连通性
telnet localhost 80
```

**🔸 应用级检查**
检查应用是否能正常响应：
```bash
# HTTP服务检查
curl -f http://localhost/health

# 数据库连接检查
mysql -u monitor -p -e "SELECT 1"

# 自定义检查脚本
/usr/local/bin/app_health_check.sh
```

### 3.2 健康检查配置


**📝 Pacemaker资源检查配置**：
```bash
# 配置HTTP服务监控
pcs resource create webserver ocf:heartbeat:apache \
    configfile="/etc/httpd/conf/httpd.conf" \
    op monitor interval=30s timeout=20s

# 配置数据库监控
pcs resource create database ocf:heartbeat:mysql \
    binary="/usr/bin/mysqld_safe" \
    config="/etc/my.cnf" \
    op monitor interval=20s timeout=10s
```

**🔧 自定义健康检查脚本**：
```bash
#!/bin/bash
# /usr/local/bin/web_health_check.sh

# 检查Web服务响应
response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/)

if [ "$response" = "200" ]; then
    echo "Web service is healthy"
    exit 0
else
    echo "Web service is unhealthy: HTTP $response"
    exit 1
fi
```

### 3.3 检查策略优化


**⚡ 检查频率调优**

| 检查类型 | **推荐间隔** | **超时设置** | **说明** |
|---------|-------------|-------------|---------|
| `关键服务` | `10-30秒` | `5-10秒` | `频繁检查，快速发现问题` |
| `一般服务` | `60-120秒` | `15-30秒` | `适中频率，平衡性能` |
| `资源监控` | `300秒` | `60秒` | `低频检查，减少开销` |

**智能检查策略**：
```bash
# 故障时加密检查
if [ $failure_count -gt 0 ]; then
    check_interval=10  # 故障时10秒检查一次
else
    check_interval=60  # 正常时60秒检查一次
fi
```

---

## 4. 🔄 自动故障切换


### 4.1 切换触发条件


**📋 触发条件列表**
- ✅ **节点无响应**：连续心跳超时
- ✅ **服务故障**：关键服务停止响应
- ✅ **资源耗尽**：内存、磁盘空间不足
- ✅ **网络故障**：网络连接中断
- ✅ **手动切换**：运维人员主动切换

**切换决策矩阵**：
```
故障类型     →  临时故障  →  重启服务
           →  硬件故障  →  切换节点
           →  网络故障  →  等待恢复
           →  资源不足  →  清理后重启
```

### 4.2 切换执行流程


**🔄 自动切换步骤**
```
1. 故障检测确认
   ↓
2. 停止故障节点服务
   ↓  
3. 卸载共享资源
   ↓
4. 在备用节点启动服务
   ↓
5. 挂载共享资源
   ↓
6. 更新IP地址/DNS
   ↓
7. 验证服务可用性
   ↓
8. 记录切换日志
```

**实际执行示例**：
```bash
# 停止故障节点上的服务
pcs resource disable webserver

# 清理资源状态
pcs resource cleanup webserver

# 在新节点启动服务
pcs resource enable webserver

# 检查资源状态
pcs status
```

### 4.3 切换类型


**🎯 主动切换**
运维人员手动执行的计划内切换：
```bash
# 手动切换资源到指定节点
pcs resource move webserver node2

# 取消位置约束
pcs resource clear webserver
```

**⚡ 被动切换**
系统自动检测故障后的切换：
```bash
# 配置自动故障切换
pcs resource defaults migration-threshold=3
pcs resource defaults failure-timeout=60s
```

**🔧 部分切换**
只切换部分服务或资源：
```bash
# 只切换数据库服务
pcs resource move database node2

# Web服务保持在原节点
pcs constraint location webserver prefers node1
```

---

## 5. ⚡ 切换时间优化


### 5.1 切换时间组成


**⏱️ 时间分解分析**
```
总切换时间 = 故障检测时间 + 决策时间 + 执行时间 + 验证时间

故障检测时间：心跳超时 × 重试次数
决策时间：算法计算 + 仲裁确认  
执行时间：停止服务 + 启动服务 + 资源迁移
验证时间：健康检查 + 连通性测试
```

**⏰ 典型时间分布**：

| 阶段 | **时间范围** | **优化重点** |
|------|-------------|-------------|
| `故障检测` | `10-30秒` | `调整心跳参数` |
| `决策仲裁` | `2-5秒` | `简化决策逻辑` |
| `服务切换` | `30-60秒` | `优化启动脚本` |
| `验证确认` | `5-15秒` | `并行验证检查` |

### 5.2 检测时间优化


**🚀 心跳参数调优**
```bash
# 快速检测配置
keepalive 1          # 1秒心跳间隔
deadtime 6           # 6秒判定故障
warntime 3           # 3秒警告

# 平衡配置
keepalive 2          # 2秒心跳间隔  
deadtime 10          # 10秒判定故障
warntime 5           # 5秒警告
```

**并行检测机制**：
```bash
# 多种检测方式并行
network_check &      # 网络检测
service_check &      # 服务检测
resource_check &     # 资源检测

# 等待任一检测完成
wait
```

### 5.3 切换时间优化技巧


**🔧 预热机制**
在备用节点预先准备好环境：
```bash
# 预加载应用程序
systemctl enable httpd
systemctl stop httpd    # 加载但不启动

# 预挂载文件系统
mount -o ro /shared/data  # 只读挂载，减少切换时间
```

**⚡ 并行处理**
```bash
#!/bin/bash
# 并行执行切换操作

# 同时执行多个操作
stop_old_service &
prepare_new_service &
update_dns &

# 等待所有操作完成
wait

# 启动新服务
start_new_service
```

**📦 资源预分配**
```bash
# 预分配IP地址池
ip addr add 192.168.1.100/24 dev eth0:1 scope link

# 预创建必要目录
mkdir -p /app/data
chown app:app /app/data
```

---

## 6. 🔄 故障恢复流程


### 6.1 恢复流程设计


**🛠️ 故障恢复步骤**
```
1. 故障节点修复完成
   ↓
2. 节点重新加入集群
   ↓
3. 同步数据和状态
   ↓
4. 验证节点功能
   ↓
5. 重新分配资源（可选）
   ↓
6. 更新监控状态
```

**自动恢复vs手动恢复**：

| 恢复方式 | **适用场景** | **优缺点** |
|---------|-------------|-----------|
| `自动恢复` | `临时故障，网络闪断` | `快速但可能不稳定` |
| `手动恢复` | `硬件故障，重大问题` | `安全但需要人工介入` |

### 6.2 数据同步策略


**📊 数据一致性检查**
```bash
# 检查数据库同步状态
mysql -e "SHOW SLAVE STATUS\G" | grep "Seconds_Behind_Master"

# 文件系统同步检查
rsync -avun --delete /source/ /destination/

# 配置文件对比
diff -r /etc/cluster/node1/ /etc/cluster/node2/
```

**🔄 增量同步机制**
```bash
# 使用rsync增量同步
rsync -avz --delete --progress \
    /primary/data/ backup:/backup/data/

# 数据库增量同步
mysqldump --single-transaction --master-data=2 \
    database | gzip > backup.sql.gz
```

### 6.3 回切策略


**🔙 主备回切**
当原主节点修复后，是否需要切换回去：

```bash
# 配置自动回切
pcs resource defaults resource-stickiness=100

# 禁用自动回切  
pcs resource defaults resource-stickiness=1000

# 手动回切
pcs resource move webserver node1
```

**⚖️ 回切决策因素**
- **业务影响**：回切是否会影响业务
- **性能考虑**：原主节点性能是否更好
- **运维策略**：是否有维护时间窗口
- **数据分布**：数据是否更适合在原节点

---

## 7. 📝 切换日志记录


### 7.1 日志记录要求


**📋 关键事件记录**
- **切换触发**：什么原因导致切换
- **切换过程**：每个步骤的执行情况
- **切换结果**：成功或失败，耗时多长
- **影响评估**：对业务的影响程度

**🎯 日志级别定义**

| 级别 | **事件类型** | **示例** |
|------|-------------|---------|
| `ERROR` | `切换失败，重大故障` | `节点完全无响应` |
| `WARN` | `切换成功，但有问题` | `切换时间超过阈值` |
| `INFO` | `正常切换事件` | `计划内维护切换` |
| `DEBUG` | `详细执行步骤` | `每个检查点状态` |

### 7.2 日志格式规范


**📄 标准日志格式**
```bash
# 推荐日志格式
[时间戳] [级别] [事件类型] [源节点] [目标节点] [描述] [耗时]

# 实际示例
[2024-01-18 10:30:15] [WARN] [AUTO_FAILOVER] [node1] [node2] 
[HTTP服务无响应，自动切换] [45秒]
```

**🔧 日志配置示例**
```bash
# rsyslog配置
# /etc/rsyslog.d/cluster.conf
local0.info     /var/log/cluster/failover.log
local0.warn     /var/log/cluster/failover.log
local0.err      /var/log/cluster/failover.log

# logrotate配置
# /etc/logrotate.d/cluster
/var/log/cluster/*.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    create 644 root root
}
```

### 7.3 切换事件记录


**📊 详细事件记录模板**
```bash
#!/bin/bash
# 切换事件记录函数

log_failover_event() {
    local level=$1
    local event_type=$2
    local source_node=$3
    local target_node=$4
    local description=$5
    local duration=$6
    
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] [$event_type] [$source_node] [$target_node] [$description] [${duration}s]" \
        >> /var/log/cluster/failover.log
}

# 使用示例
log_failover_event "INFO" "MANUAL_SWITCHOVER" "node1" "node2" "计划维护切换" "30"
```

**🎭 集群状态快照**
```bash
# 切换前后状态记录
record_cluster_snapshot() {
    timestamp=$(date '+%Y%m%d_%H%M%S')
    snapshot_file="/var/log/cluster/snapshot_${timestamp}.log"
    
    echo "=== 集群状态快照 $(date) ===" > $snapshot_file
    pcs status >> $snapshot_file
    pcs resource show >> $snapshot_file
    pcs constraint show >> $snapshot_file
}
```

---

## 8. 🛡️ 误切换防护


### 8.1 误切换原因分析


**⚠️ 常见误切换场景**
- **网络抖动**：短暂网络中断导致误判
- **负载过高**：系统负载导致心跳延迟
- **维护操作**：运维操作被误认为故障
- **时间同步**：时钟不同步导致超时
- **磁盘IO**：磁盘压力导致响应缓慢

**📊 误切换影响评估**
```
误切换的代价：
- 服务中断：切换过程中的短暂不可用
- 数据风险：可能导致数据不一致
- 性能影响：切换到性能较差的节点
- 运维负担：需要人工干预和恢复
```

### 8.2 防护机制设计


**🔒 多重确认机制**
```bash
# 配置多次确认
pcs property set stonith-enabled=true
pcs property set no-quorum-policy=stop

# 设置故障确认次数
pcs resource defaults failure-timeout=300s
pcs resource defaults migration-threshold=5
```

**⏱️ 切换延迟设置**
```bash
# 配置切换延迟
pcs resource defaults start-delay=30s

# 故障后等待时间
pcs property set cluster-delay=60s
```

**🎯 智能阈值调整**
```bash
#!/bin/bash
# 动态调整检测阈值

current_load=$(uptime | awk '{print $12}' | sed 's/,//')
base_timeout=10

if (( $(echo "$current_load > 5.0" | bc -l) )); then
    # 高负载时延长超时时间
    timeout=$((base_timeout * 2))
else
    timeout=$base_timeout
fi

echo "当前负载: $current_load，设置超时: ${timeout}秒"
```

### 8.3 防护策略配置


**🔧 Fencing策略**
```bash
# 配置STONITH设备（确保故障节点彻底停止）
pcs stonith create fence_node1 fence_ipmilan \
    ipaddr="192.168.1.10" login="admin" passwd="password" \
    pcmk_host_list="node1"

# 配置fence延迟
pcs property set stonith-timeout=60s
```

**📋 维护模式**
```bash
# 进入维护模式（暂停自动切换）
pcs property set maintenance-mode=true

# 维护完成后退出
pcs property set maintenance-mode=false

# 单个资源维护模式
pcs resource meta webserver set maintenance=true
```

**🚨 告警集成**
```bash
# 配置告警脚本
# /usr/local/bin/cluster_alert.sh
#!/bin/bash

event_type=$1
resource=$2
node=$3

# 发送告警邮件
echo "集群事件: $event_type, 资源: $resource, 节点: $node" | \
    mail -s "集群告警" admin@company.com

# 发送短信告警  
curl -X POST "http://sms-gateway/send" \
    -d "phone=13800138000&message=集群切换告警"
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 心跳检测：集群节点间的"生命信号"，证明节点存活
🔸 故障判断：通过多种检测方式确认节点真正故障
🔸 健康检查：不仅检查节点存活，还要检查服务是否正常
🔸 自动切换：故障发生时系统自动将服务切换到健康节点
🔸 脑裂防护：防止网络故障导致多个节点同时提供服务
🔸 误切换防护：避免因为临时问题导致不必要的服务切换
```

### 9.2 关键理解要点


**🔹 心跳检测的平衡艺术**
```
频率太高：
✅ 故障检测快
❌ 消耗系统资源
❌ 容易误判

频率太低：  
✅ 系统开销小
❌ 故障发现慢
❌ 切换延迟长

最佳实践：根据业务需求和系统资源找到平衡点
```

**🔹 故障切换的时间权衡**
```
快速切换：
✅ 减少服务中断时间
❌ 可能来不及确认真实故障
❌ 增加误切换风险

稳妥切换：
✅ 确保故障判断准确
✅ 减少误切换
❌ 服务中断时间较长
```

**🔹 防护机制的重要性**
```
没有防护机制的问题：
- 网络抖动就切换，服务不稳定
- 维护时误触发切换，增加工作量  
- 脑裂导致数据冲突，后果严重

防护机制的作用：
- 多重确认，确保故障真实存在
- 维护模式，避免维护时误切换
- 仲裁机制，防止脑裂问题
```

### 9.3 实际应用指导


**🎯 不同业务场景的配置策略**

**💻 Web服务集群**
```bash
# 快速检测，因为Web服务恢复快
keepalive 2
deadtime 8
migration-threshold 3

# 重点检查HTTP响应
op monitor interval=10s timeout=5s
```

**💾 数据库集群**
```bash
# 谨慎检测，因为数据库切换代价高
keepalive 3  
deadtime 15
migration-threshold 5

# 详细检查数据库状态
op monitor interval=30s timeout=20s
```

**📁 文件服务集群**
```bash
# 中等检测，平衡可用性和稳定性
keepalive 2
deadtime 10
migration-threshold 4

# 检查文件系统和网络
op monitor interval=20s timeout=10s
```

### 9.4 故障处理最佳实践


**🔧 日常运维建议**
- **定期演练**：每月进行一次故障切换演练
- **监控告警**：设置合理的告警阈值和通知方式
- **文档记录**：详细记录每次故障和处理过程
- **参数调优**：根据实际运行情况调整检测参数

**⚠️ 常见问题避免**
- **不要过度敏感**：避免因为小问题就频繁切换
- **不要盲目信任**：定期验证健康检查的有效性
- **不要忽视日志**：及时分析切换日志，发现潜在问题
- **不要单点依赖**：使用多种检测方式互相验证

**核心记忆口诀**：
- 心跳检测如脉搏，节拍稳定最重要
- 故障判断要谨慎，多重确认防误判  
- 切换快慢要平衡，业务需求是关键
- 日志记录很重要，问题分析靠得牢