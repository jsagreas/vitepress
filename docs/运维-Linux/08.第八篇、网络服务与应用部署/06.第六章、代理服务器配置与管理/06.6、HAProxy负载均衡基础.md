---
title: 6、HAProxy负载均衡基础
---
## 📚 目录

1. [HAProxy概述与架构](#1-HAProxy概述与架构)
2. [HAProxy工作模式](#2-HAProxy工作模式)
3. [负载均衡算法类型](#3-负载均衡算法类型)
4. [健康检查机制配置](#4-健康检查机制配置)
5. [后端服务器池管理](#5-后端服务器池管理)
6. [会话保持配置](#6-会话保持配置)
7. [故障转移机制](#7-故障转移机制)
8. [权重分配策略](#8-权重分配策略)
9. [连接超时参数设置](#9-连接超时参数设置)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌐 HAProxy概述与架构


### 1.1 什么是HAProxy


**定义理解**：HAProxy是一个高性能的负载均衡器和代理服务器，就像是网站前面的"智能交通指挥员"，负责将用户请求合理分配给后端的多台服务器。

```
现实类比：
HAProxy = 餐厅的领班
用户请求 = 顾客
后端服务器 = 服务员

领班的职责：
- 观察哪个服务员比较空闲
- 将新顾客安排给合适的服务员
- 如果某个服务员生病了，不安排顾客给他
- 确保所有顾客都能得到良好的服务
```

### 1.2 HAProxy核心优势


**性能特点**：
- ✅ **高并发处理**：单台服务器可处理数万并发连接
- ✅ **低资源消耗**：内存占用小，CPU效率高
- ✅ **配置灵活**：支持多种负载均衡策略
- ✅ **监控完善**：提供详细的统计信息和健康检查

### 1.3 HAProxy架构组成


```
HAProxy架构图：

客户端请求                  HAProxy代理                后端服务器池
    │                         │                         │
    │     ┌─────────────────┐  │  ┌─────────────────┐    │
    ├────→│   Frontend      │──┼─→│   Backend       │────┼──→ Web Server 1
    │     │  (接收请求)      │  │  │  (服务器池)     │    │
    │     └─────────────────┘  │  └─────────────────┘    │
    │                         │                         ├──→ Web Server 2
    │     ┌─────────────────┐  │  ┌─────────────────┐    │
    └────→│   监控统计       │  │  │   健康检查       │    ├──→ Web Server 3
          │  (状态报告)      │  │  │  (故障检测)     │    │
          └─────────────────┘  │  └─────────────────┘    └──→ Web Server N
```

**组件说明**：
- **Frontend（前端）**：接收客户端请求的入口点
- **Backend（后端）**：处理请求的服务器组
- **健康检查**：监控后端服务器的运行状态
- **统计监控**：提供实时的运行数据和性能指标

---

## 2. ⚙️ HAProxy工作模式


### 2.1 TCP模式（四层代理）


**工作原理**：HAProxy在网络传输层（TCP层）工作，直接转发TCP连接，不解析应用层内容。

```bash
# TCP模式配置示例
frontend tcp_frontend
    mode tcp
    bind *:3306
    default_backend mysql_servers

backend mysql_servers
    mode tcp
    balance roundrobin
    server mysql1 192.168.1.10:3306 check
    server mysql2 192.168.1.11:3306 check
```

**TCP模式特点**：

| 特性 | **说明** | **优势** | **适用场景** |
|------|---------|----------|-------------|
| 🔸 **性能** | `不解析应用内容` | `处理速度快，延迟低` | `数据库、游戏服务器` |
| 🔸 **透明性** | `完全透明转发` | `支持任何TCP协议` | `MySQL、Redis、SSH` |
| 🔸 **简单性** | `配置相对简单` | `故障点少，稳定性高` | `非HTTP协议服务` |

### 2.2 HTTP模式（七层代理）


**工作原理**：HAProxy在应用层（HTTP层）工作，可以解析HTTP请求内容，基于URL、Header等信息进行智能路由。

```bash
# HTTP模式配置示例
frontend http_frontend
    mode http
    bind *:80
    # 基于URL路径路由
    acl is_api path_beg /api
    acl is_static path_beg /static
    
    use_backend api_servers if is_api
    use_backend static_servers if is_static
    default_backend web_servers

backend web_servers
    mode http
    balance roundrobin
    cookie SERVERID insert indirect nocache
    server web1 192.168.1.20:80 check cookie web1
    server web2 192.168.1.21:80 check cookie web2
```

**HTTP模式特点**：

| 特性 | **说明** | **优势** | **适用场景** |
|------|---------|----------|-------------|
| 🔸 **智能路由** | `基于HTTP内容分发` | `灵活的请求分配策略` | `Web应用、API服务` |
| 🔸 **会话保持** | `支持Cookie会话绑定` | `用户体验一致性` | `有状态的Web应用` |
| 🔸 **内容操作** | `可修改HTTP头信息` | `增强安全性和功能` | `需要请求改写的场景` |

### 2.3 模式选择指导


**选择原则**：

```
选择TCP模式的场景：
✓ 非HTTP协议（数据库、消息队列、游戏服务器）
✓ 对性能要求极高（金融交易、实时通信）
✓ 需要完全透明代理（不修改任何数据包内容）
✓ 协议复杂或私有（自定义TCP协议）

选择HTTP模式的场景：
✓ Web应用和API服务
✓ 需要基于内容的路由（按URL、域名分发）
✓ 需要会话保持功能
✓ 需要SSL终止和证书管理
✓ 需要请求/响应内容修改
```

---

## 3. 🔄 负载均衡算法类型


### 3.1 轮询算法（roundrobin）


**工作原理**：按照顺序将请求依次分配给每台后端服务器，就像排队轮流一样。

```bash
# 轮询算法配置
backend web_servers
    balance roundrobin
    server web1 192.168.1.10:80 check
    server web2 192.168.1.11:80 check
    server web3 192.168.1.12:80 check

# 请求分发示例
请求1 → web1
请求2 → web2
请求3 → web3
请求4 → web1 (循环开始)
请求5 → web2
```

**适用场景**：
- ✅ **服务器性能相近**：所有后端服务器配置基本相同
- ✅ **请求处理时间相似**：各个请求的复杂度差不多
- ✅ **配置简单**：不需要复杂的权重计算

### 3.2 最少连接算法（leastconn）


**工作原理**：将新请求分配给当前活跃连接数最少的服务器，确保负载相对均衡。

```bash
# 最少连接算法配置
backend api_servers
    balance leastconn
    server api1 192.168.1.20:8080 check
    server api2 192.168.1.21:8080 check
    server api3 192.168.1.22:8080 check

# 动态分发示例
服务器状态：
api1: 当前连接数 5
api2: 当前连接数 3  ← 新请求分配到这里
api3: 当前连接数 7
```

**适用场景**：
- ✅ **长连接服务**：WebSocket、数据库连接
- ✅ **处理时间差异大**：有些请求快，有些请求慢
- ✅ **实时性要求高**：需要快速响应的应用

### 3.3 源IP哈希（source）


**工作原理**：根据客户端IP地址计算哈希值，确保同一客户端的请求总是分配给同一台服务器。

```bash
# 源IP哈希配置
backend session_servers
    balance source
    hash-type consistent
    server app1 192.168.1.30:8080 check
    server app2 192.168.1.31:8080 check
    server app3 192.168.1.32:8080 check

# IP哈希示例
客户端IP: 192.168.100.10 → 总是分配给 app2
客户端IP: 192.168.100.20 → 总是分配给 app1
客户端IP: 192.168.100.30 → 总是分配给 app3
```

**适用场景**：
- ✅ **会话依赖**：需要维持用户会话状态
- ✅ **缓存优化**：用户数据缓存在特定服务器
- ✅ **一致性要求**：用户体验需要保持一致

### 3.4 算法对比选择


**性能特点对比**：

| 算法类型 | **分发方式** | **性能影响** | **适用场景** | **配置复杂度** |
|---------|------------|-------------|-------------|---------------|
| 🔸 **roundrobin** | `依次轮流` | `🟢 低开销` | `无状态服务` | `🟢 简单` |
| 🔸 **leastconn** | `最少连接` | `🟡 中等开销` | `长连接服务` | `🟡 中等` |
| 🔸 **source** | `IP哈希` | `🟢 低开销` | `有状态服务` | `🟡 中等` |
| 🔸 **uri** | `URL哈希` | `🟡 中等开销` | `缓存优化` | `🟡 中等` |

---

## 4. 🔍 健康检查机制配置


### 4.1 基本健康检查


**检查原理**：HAProxy定期向后端服务器发送检查请求，根据响应结果判断服务器是否健康可用。

```bash
# 基本TCP健康检查
backend tcp_servers
    server db1 192.168.1.40:3306 check
    server db2 192.168.1.41:3306 check
    
# 检查参数说明
check                    # 启用健康检查
inter 2000              # 检查间隔2秒
timeout check 5000      # 检查超时5秒
rise 2                  # 连续成功2次认为服务器恢复
fall 3                  # 连续失败3次认为服务器故障
```

### 4.2 HTTP健康检查


**高级检查配置**：针对HTTP服务可以检查特定的URL路径和响应内容。

```bash
# HTTP健康检查配置
backend web_servers
    option httpchk GET /health
    http-check expect status 200
    server web1 192.168.1.50:80 check
    server web2 192.168.1.51:80 check

# 详细检查配置
option httpchk GET /api/health HTTP/1.1\r\nHost:\ example.com
http-check expect string "OK"
server api1 192.168.1.60:8080 check inter 3s fall 2 rise 3
```

### 4.3 自定义检查脚本


**外部检查程序**：使用自定义脚本进行复杂的健康状态检查。

```bash
# 外部检查配置
backend app_servers
    option external-check
    external-check command /usr/local/bin/check_app.sh
    server app1 192.168.1.70:8080 check
    server app2 192.168.1.71:8080 check

# 检查脚本示例 (/usr/local/bin/check_app.sh)
#!/bin/bash
HOST=$1
PORT=$2

# 检查应用端口
nc -z $HOST $PORT || exit 1

# 检查应用响应
response=$(curl -s http://$HOST:$PORT/status)
if [[ "$response" == *"healthy"* ]]; then
    exit 0
else
    exit 1
fi
```

### 4.4 健康检查策略


**检查参数调优**：

```
高可用场景（严格检查）：
inter 1s fall 2 rise 3    # 快速检测，严格判断

稳定性优先（宽松检查）：
inter 5s fall 5 rise 2    # 避免误报，减少抖动

性能优先（减少检查）：
inter 10s fall 3 rise 2   # 降低检查频率，减少开销
```

**检查状态监控**：
```
服务器状态含义：
UP     - 服务器正常运行
DOWN   - 服务器故障离线
DRAIN  - 服务器正在排空连接（维护模式）
MAINT  - 服务器处于维护状态
```

---

## 5. 🖥️ 后端服务器池管理


### 5.1 服务器池基础配置


**基本服务器定义**：后端服务器池是HAProxy管理的一组提供相同服务的服务器。

```bash
# 基础服务器池配置
backend web_pool
    balance roundrobin
    
    # 服务器定义格式
    server 服务器名称 IP地址:端口 [选项]
    
    server web01 192.168.1.100:80 check weight 100
    server web02 192.168.1.101:80 check weight 100
    server web03 192.168.1.102:80 check weight 80
    server web04 192.168.1.103:80 check backup
```

### 5.2 服务器参数详解


**常用服务器参数**：

| 参数名称 | **作用说明** | **配置示例** | **使用场景** |
|---------|------------|-------------|-------------|
| 🔸 **check** | `启用健康检查` | `server web1 192.168.1.10:80 check` | `自动故障检测` |
| 🔸 **weight** | `权重分配` | `weight 150` | `性能差异化分配` |
| 🔸 **backup** | `备份服务器` | `backup` | `主服务器故障时启用` |
| 🔸 **maxconn** | `最大连接数` | `maxconn 500` | `连接数限制` |
| 🔸 **disabled** | `禁用服务器` | `disabled` | `临时维护` |

### 5.3 动态服务器管理


**运行时管理命令**：
```bash
# 通过统计页面或API管理服务器
# 启用服务器
echo "enable server web_pool/web03" | socat stdio /var/run/haproxy.sock

# 禁用服务器
echo "disable server web_pool/web03" | socat stdio /var/run/haproxy.sock

# 设置服务器权重
echo "set weight web_pool/web03 50" | socat stdio /var/run/haproxy.sock

# 查看服务器状态
echo "show stat" | socat stdio /var/run/haproxy.sock
```

### 5.4 服务器池高可用设计


**多层级备份策略**：
```bash
backend high_availability_pool
    balance roundrobin
    
    # 主要服务器（优先使用）
    server primary1 192.168.1.10:80 check weight 100
    server primary2 192.168.1.11:80 check weight 100
    
    # 次要服务器（性能较低）
    server secondary1 192.168.1.20:80 check weight 50
    server secondary2 192.168.1.21:80 check weight 50
    
    # 备份服务器（最后选择）
    server backup1 192.168.1.30:80 check backup
    server backup2 192.168.1.31:80 check backup
```

**故障处理流程**：
```
正常状态：
primary1 + primary2 承担主要流量

部分故障：
primary1 故障 → primary2 + secondary1 + secondary2

严重故障：
所有主服务器故障 → backup1 + backup2 启用

恢复过程：
服务器恢复 → 自动重新加入服务器池
```

---

## 6. 🔗 会话保持配置


### 6.1 Cookie会话保持


**原理说明**：通过在客户端设置Cookie来标识用户会话应该访问哪台具体的后端服务器。

```bash
# Cookie会话保持配置
backend session_pool
    balance roundrobin
    cookie SERVERID insert indirect nocache
    
    server app1 192.168.1.10:8080 check cookie app1
    server app2 192.168.1.11:8080 check cookie app2
    server app3 192.168.1.12:8080 check cookie app3

# Cookie参数说明
insert    # HAProxy插入Cookie
indirect  # 不修改应用生成的Cookie
nocache   # 禁止缓存Cookie
```

**工作流程**：
```
用户首次访问：
1. 客户端请求 → HAProxy
2. HAProxy选择app1处理请求
3. HAProxy在响应中添加 Set-Cookie: SERVERID=app1
4. 客户端保存Cookie

后续访问：
1. 客户端带Cookie请求 → HAProxy
2. HAProxy读取Cookie: SERVERID=app1
3. HAProxy将请求转发给app1
4. 保证用户始终访问同一台服务器
```

### 6.2 源IP会话保持


```bash
# 基于源IP的会话保持
backend ip_session_pool
    balance source
    hash-type consistent
    
    server web1 192.168.1.20:80 check
    server web2 192.168.1.21:80 check
    server web3 192.168.1.22:80 check

# 一致性哈希的优势
# 当服务器数量变化时，大部分用户的会话不受影响
```

### 6.3 会话保持策略选择


**方案对比分析**：

| 保持方式 | **实现原理** | **优点** | **缺点** | **适用场景** |
|---------|------------|----------|----------|-------------|
| 🔸 **Cookie方式** | `客户端Cookie标识` | `精确绑定，支持故障转移` | `依赖Cookie支持` | `Web应用` |
| 🔸 **源IP方式** | `IP地址哈希` | `简单可靠，无依赖` | `NAT环境可能冲突` | `企业内网应用` |
| 🔸 **URL参数** | `请求参数标识` | `灵活控制` | `需要应用配合` | `API服务` |

---

## 7. 🔄 故障转移机制


### 7.1 自动故障检测


**故障检测流程**：HAProxy通过健康检查持续监控后端服务器状态，自动识别故障服务器。

```
故障检测时序图：

HAProxy          服务器A          服务器B
   │                │               │
   ├─健康检查────────→│               │
   │←──响应正常───────┤               │
   │                │               │
   ├─健康检查────────→│               │
   │   (超时)         │               │
   │                │               │
   ├─健康检查────────→│               │
   │   (超时)         │               │
   │                │               │
   ├─标记故障         │               │
   │                │               │
   ├─流量转移─────────────────────────→│
   │←──正常响应───────────────────────┤
```

### 7.2 故障转移配置


```bash
# 故障转移配置示例
backend fault_tolerant_pool
    balance roundrobin
    
    # 主服务器
    server main1 192.168.1.10:80 check inter 2s fall 3 rise 2
    server main2 192.168.1.11:80 check inter 2s fall 3 rise 2
    
    # 备份服务器（只在主服务器都故障时启用）
    server backup1 192.168.1.20:80 check backup inter 5s
    server backup2 192.168.1.21:80 check backup inter 5s
    
    # 故障转移参数
    option redispatch           # 允许重新分发请求
    retries 3                   # 重试次数
    timeout connect 5s          # 连接超时
    timeout server 30s          # 服务器响应超时
```

### 7.3 优雅的故障处理


**连接排空（Drain）**：在服务器维护前，逐渐减少新连接，等待现有连接自然结束。

```bash
# 设置服务器为排空状态
echo "set server web_pool/web01 state drain" | socat stdio /var/run/haproxy.sock

# 排空过程监控
echo "show stat" | socat stdio /var/run/haproxy.sock | grep web01

# 排空状态说明：
# - 不接受新连接
# - 保持现有连接
# - 现有连接处理完后服务器变为离线状态
```

### 7.4 故障恢复机制


**自动恢复流程**：
```bash
# 服务器恢复配置
backend auto_recovery_pool
    server web1 192.168.1.10:80 check rise 3
    server web2 192.168.1.11:80 check rise 3
    
# 恢复参数说明
rise 3    # 连续3次健康检查成功后重新上线
fall 3    # 连续3次健康检查失败后下线

# 恢复过程
服务器故障 → 标记为DOWN → 停止分发流量
         ↓
健康检查成功 → rise计数器+1 → 达到阈值后重新上线
```

---

## 8. ⚖️ 权重分配策略


### 8.1 基于性能的权重设置


**权重概念**：权重决定了服务器在负载均衡中分配到的请求比例，权重越高，分配的请求越多。

```bash
# 基于服务器性能的权重配置
backend performance_pool
    balance roundrobin
    
    # 高性能服务器 (16核, 32GB内存)
    server high-end-1  192.168.1.10:80 check weight 200
    server high-end-2  192.168.1.11:80 check weight 200
    
    # 中等性能服务器 (8核, 16GB内存)
    server medium-1    192.168.1.20:80 check weight 100
    server medium-2    192.168.1.21:80 check weight 100
    
    # 低性能服务器 (4核, 8GB内存)
    server low-end-1   192.168.1.30:80 check weight 50
    server low-end-2   192.168.1.31:80 check weight 50

# 权重计算示例
总权重 = 200+200+100+100+50+50 = 700
high-end-1 分配比例 = 200/700 ≈ 28.6%
medium-1 分配比例 = 100/700 ≈ 14.3%  
low-end-1 分配比例 = 50/700 ≈ 7.1%
```

### 8.2 动态权重调整


**实时权重管理**：根据服务器当前负载状况动态调整权重分配。

```bash
# 运行时权重调整命令
# 降低高负载服务器权重
echo "set weight performance_pool/high-end-1 100" | socat stdio /var/run/haproxy.sock

# 提高空闲服务器权重  
echo "set weight performance_pool/medium-1 150" | socat stdio /var/run/haproxy.sock

# 查看当前权重设置
echo "show stat" | socat stdio /var/run/haproxy.sock | grep performance_pool
```

### 8.3 权重策略最佳实践


**权重设置原则**：

```
性能比例设置：
CPU核心数比例：16核:8核:4核 = 4:2:1
内存比例：32GB:16GB:8GB = 4:2:1
综合权重：200:100:50

负载监控调整：
高负载时段：适当降低繁忙服务器权重
低负载时段：可以提高所有服务器权重
维护期间：将维护服务器权重设为0

测试新服务器：
新服务器初始权重设为较低值（如10-20）
稳定运行后逐步提高到正常权重
观察性能表现和错误率变化
```

---

## 9. ⏱️ 连接超时参数设置


### 9.1 超时参数类型


**核心超时配置**：合理的超时设置是保证服务稳定性和用户体验的关键。

```bash
# 全面的超时配置
frontend web_frontend
    bind *:80
    timeout client 30s          # 客户端空闲超时
    default_backend web_servers

backend web_servers
    timeout connect 5s          # 连接后端服务器超时
    timeout server 30s          # 后端服务器响应超时
    timeout queue 30s           # 队列等待超时
    timeout check 5s            # 健康检查超时
    
    server web1 192.168.1.10:80 check
    server web2 192.168.1.11:80 check

# 全局超时设置
global
    timeout http-request 10s    # HTTP请求完整接收超时
    timeout http-keep-alive 2s  # HTTP保持连接超时
```

### 9.2 超时参数详解


**各类超时含义**：

| 超时类型 | **作用范围** | **推荐值** | **说明** |
|---------|------------|----------|----------|
| 🔸 **client** | `客户端连接` | `30-60s` | `客户端无活动多久断开连接` |
| 🔸 **connect** | `后端连接` | `3-10s` | `连接后端服务器的最大等待时间` |
| 🔸 **server** | `服务器响应` | `30-300s` | `等待后端服务器响应的时间` |
| 🔸 **queue** | `队列等待` | `30-60s` | `请求在队列中的最大等待时间` |
| 🔸 **check** | `健康检查` | `3-10s` | `健康检查请求的超时时间` |

### 9.3 应用场景超时优化


**不同应用的超时策略**：

```bash
# Web应用超时配置
backend web_app_servers
    timeout connect 3s
    timeout server 30s
    timeout queue 10s
    # 快速响应，短超时时间

# API服务超时配置  
backend api_servers
    timeout connect 5s
    timeout server 60s
    timeout queue 30s
    # 可能需要较长处理时间

# 数据库代理超时配置
backend database_servers
    mode tcp
    timeout connect 10s
    timeout server 300s
    # 数据库查询可能需要更长时间

# 文件下载服务超时配置
backend download_servers
    timeout connect 5s
    timeout server 3600s        # 1小时
    timeout tunnel 3600s        # 长连接保持
    # 支持大文件下载
```

### 9.4 超时监控与调优


**超时监控指标**：
```bash
# 查看超时统计
echo "show stat" | socat stdio /var/run/haproxy.sock

# 关键超时指标
cli_abrt    # 客户端中断连接数
srv_abrt    # 服务器中断连接数
ctime       # 平均连接时间
rtime       # 平均响应时间
ttime       # 平均总时间

# 超时调优建议
连接超时频繁 → 增加 timeout connect
响应超时频繁 → 增加 timeout server  
客户端断开频繁 → 调整 timeout client
队列等待过长 → 增加后端服务器或调整 timeout queue
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 工作模式选择：TCP模式适用于非HTTP协议，HTTP模式适用于Web应用
🔸 负载均衡算法：roundrobin（轮询）、leastconn（最少连接）、source（源IP哈希）
🔸 健康检查机制：定期检测后端服务器状态，自动故障发现和恢复
🔸 会话保持策略：Cookie方式和源IP方式的应用场景和配置方法
🔸 故障转移机制：自动检测故障、流量重定向、优雅恢复
🔸 权重分配原理：基于服务器性能差异进行负载分配
🔸 超时参数设置：各类超时的含义和针对不同应用的优化策略
```

### 10.2 关键理解要点


**🔹 架构设计原则**：
```
高可用性设计：
- 多台后端服务器避免单点故障
- 备份服务器提供故障转移能力
- 健康检查确保服务可用性

性能优化策略：
- 根据服务器性能设置合理权重
- 选择适合的负载均衡算法
- 优化超时参数减少资源浪费

会话一致性保证：
- 有状态应用需要会话保持
- 无状态应用可以自由分发
- 故障时的会话处理策略
```

**🔹 配置最佳实践**：
```
循序渐进配置：
1. 基础功能配置（基本负载均衡）
2. 健康检查配置（故障检测）
3. 会话保持配置（用户体验）
4. 性能优化配置（权重、超时）
5. 监控告警配置（运维保障）

测试验证流程：
- 配置语法检查
- 小流量测试
- 故障场景模拟
- 性能压力测试
- 生产环境上线
```

**🔹 运维管理要点**：
```
日常监控关注：
- 后端服务器健康状态
- 请求分发是否均衡
- 响应时间和错误率
- 连接数和并发量

故障处理流程：
- 快速识别故障服务器
- 自动或手动故障转移
- 根因分析和问题修复
- 服务恢复和验证
```

### 10.3 实际应用指导


**常见部署场景**：

```bash
# 1. 基础Web站点负载均衡
frontend web_site
    bind *:80
    default_backend web_servers

backend web_servers
    balance roundrobin
    option httpchk GET /health
    server web1 192.168.1.10:80 check
    server web2 192.168.1.11:80 check

# 2. API服务负载均衡
frontend api_gateway  
    bind *:8080
    default_backend api_servers

backend api_servers
    balance leastconn
    option httpchk GET /api/health
    cookie APISERVER insert indirect
    server api1 192.168.1.20:8080 check cookie api1
    server api2 192.168.1.21:8080 check cookie api2

# 3. 数据库读写分离
frontend db_proxy
    bind *:3306
    default_backend db_read_servers

backend db_read_servers
    mode tcp
    balance leastconn
    server db-read1 192.168.1.30:3306 check
    server db-read2 192.168.1.31:3306 check
    server db-master 192.168.1.32:3306 check backup
```

**配置管理建议**：
- **版本控制**：使用Git管理配置文件，记录变更历史
- **配置模板**：标准化常用配置模板，提高配置效率
- **测试环境**：在测试环境验证配置后再应用到生产环境
- **监控告警**：建立完善的监控体系，及时发现和处理问题

**核心记忆要点**：
- HAProxy是高性能的七层和四层负载均衡器
- 通过健康检查、故障转移、会话保持保证服务高可用
- 负载均衡算法和权重设置影响请求分发效果
- 超时参数设置需要根据应用特点进行优化
- 运维管理要注重监控、测试和渐进式变更