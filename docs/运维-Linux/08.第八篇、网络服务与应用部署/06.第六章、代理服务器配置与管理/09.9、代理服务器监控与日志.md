---
title: 9、代理服务器监控与日志
---
## 📚 目录

1. [代理服务器监控基础概念](#1-代理服务器监控基础概念)
2. [Squid访问日志分析](#2-Squid访问日志分析)
3. [HAProxy统计信息监控](#3-HAProxy统计信息监控)
4. [性能指标监控配置](#4-性能指标监控配置)
5. [日志轮转管理](#5-日志轮转管理)
6. [错误日志分析方法](#6-错误日志分析方法)
7. [实时监控工具使用](#7-实时监控工具使用)
8. [SNMP监控配置](#8-SNMP监控配置)
9. [监控告警设置](#9-监控告警设置)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 代理服务器监控基础概念


### 1.1 监控的本质含义


**什么是代理服务器监控？**
代理服务器监控就像给服务器安装了一个"健康监测仪"，24小时不间断地检查服务器的运行状态，记录访问情况，发现问题并及时报警。

**为什么需要监控？**
```
现实类比：
汽车仪表盘 → 显示速度、油量、温度
代理服务器监控 → 显示请求量、响应时间、错误率

目的都是：
• 及时发现问题
• 预防故障发生  
• 优化性能表现
• 保证服务稳定
```

### 1.2 监控的核心要素


**🔸 监控什么？**
```
服务可用性：服务是否正常运行
性能指标：响应时间、吞吐量
资源使用：CPU、内存、磁盘、网络
业务指标：访问量、成功率、错误率
安全状况：异常访问、攻击检测
```

**🔸 怎么监控？**
```
日志分析：通过日志文件了解历史状况
实时监控：通过工具实时查看当前状态
统计报表：定期生成汇总分析报告
告警机制：问题出现时自动通知管理员
```

### 1.3 监控架构图示


```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   客户端     │───▶│ 代理服务器   │───▶│  后端服务    │
└─────────────┘    └─────────────┘    └─────────────┘
                          │
                          ▼
                   ┌─────────────┐
                   │  监控系统    │
                   │ • 日志收集   │
                   │ • 指标统计   │
                   │ • 告警通知   │
                   └─────────────┘
```

---

## 2. 📊 Squid访问日志分析


### 2.1 Squid日志格式理解


**什么是访问日志？**
访问日志就是Squid代理服务器的"行车记录仪"，记录每一个通过代理的访问请求的详细信息。

**🔸 标准日志格式解析**
```
# Squid访问日志示例
1694934123.456    789 192.168.1.100 TCP_HIT/200 1024 GET http://example.com/page.html - DIRECT/93.184.216.34 text/html

字段含义详解：
时间戳        响应时间  客户端IP     状态码   大小  方法  URL            用户  目标服务器     内容类型
1694934123.456  789   192.168.1.100 TCP_HIT/200 1024  GET  http://...     -    DIRECT/93...   text/html
```

**🔸 日志字段通俗解释**

| 字段 | 含义 | 通俗理解 |
|-----|------|---------|
| **时间戳** | 请求发生时间 | 什么时候访问的 |
| **响应时间** | 处理耗时（毫秒） | 这次访问用了多长时间 |
| **客户端IP** | 访问者地址 | 谁在访问 |
| **状态码** | 处理结果 | 访问成功还是失败 |
| **大小** | 传输字节数 | 下载了多少数据 |
| **方法** | HTTP方法 | 是查看还是提交数据 |
| **URL** | 访问地址 | 访问了什么网站 |

### 2.2 日志状态码含义


**🔸 缓存状态解析**
```
TCP_HIT：缓存命中 → 数据在缓存中找到了，速度快
TCP_MISS：缓存未命中 → 缓存中没有，需要去原服务器获取
TCP_REFRESH_HIT：刷新命中 → 缓存数据更新后命中
TCP_CLIENT_REFRESH：客户端强制刷新
TCP_DENIED：访问被拒绝 → 被访问控制规则阻止
```

**🔸 实际应用场景**
```bash
# 查看缓存命中率
grep "TCP_HIT" /var/log/squid/access.log | wc -l
grep "TCP_MISS" /var/log/squid/access.log | wc -l

# 计算缓存命中率公式：
命中率 = TCP_HIT数量 / (TCP_HIT + TCP_MISS)数量 × 100%
```

### 2.3 日志分析实用技巧


**🔸 常用分析命令**
```bash
# 1. 查看访问最多的IP地址
awk '{print $3}' /var/log/squid/access.log | sort | uniq -c | sort -nr | head -10

# 2. 统计访问最多的网站
awk '{print $7}' /var/log/squid/access.log | sort | uniq -c | sort -nr | head -10

# 3. 查看响应时间最长的请求
sort -k2 -nr /var/log/squid/access.log | head -10

# 4. 统计每小时访问量
awk '{print strftime("%Y-%m-%d %H:00", $1)}' /var/log/squid/access.log | sort | uniq -c
```

**🔸 日志分析脚本示例**
```bash
#!/bin/bash
# squid_analyzer.sh - Squid日志分析脚本

LOG_FILE="/var/log/squid/access.log"

echo "=== Squid访问日志分析报告 ==="
echo "分析时间: $(date)"
echo "日志文件: $LOG_FILE"
echo

# 基本统计
total_requests=$(wc -l < $LOG_FILE)
echo "总访问次数: $total_requests"

# 缓存命中率
hits=$(grep -c "TCP_HIT" $LOG_FILE)
misses=$(grep -c "TCP_MISS" $LOG_FILE)
hit_rate=$(echo "scale=2; $hits * 100 / ($hits + $misses)" | bc)
echo "缓存命中率: ${hit_rate}%"

# Top 5 访问IP
echo -e "\n=== Top 5 访问IP ==="
awk '{print $3}' $LOG_FILE | sort | uniq -c | sort -nr | head -5
```

---

## 3. 📈 HAProxy统计信息监控


### 3.1 HAProxy统计页面配置


**什么是HAProxy统计页面？**
就像汽车的仪表盘一样，HAProxy统计页面提供了一个图形化界面，让你能直观地看到负载均衡器的运行状态。

**🔸 启用统计页面**
```bash
# 在HAProxy配置文件中添加
listen stats
    bind *:8080                    # 统计页面端口
    stats enable                   # 启用统计功能
    stats uri /haproxy-stats      # 访问路径
    stats realm "HAProxy Statistics"  # 认证提示
    stats auth admin:password123   # 用户名密码
    stats admin if TRUE           # 启用管理功能
```

**🔸 访问统计页面**
```
浏览器访问：http://服务器IP:8080/haproxy-stats
输入用户名：admin
输入密码：password123
```

### 3.2 统计页面信息解读


**🔸 主要监控指标含义**

| 指标 | 英文名 | 含义 | 正常范围 |
|-----|-------|-----|---------|
| **会话数** | Sessions | 当前活跃连接数 | < 最大连接数80% |
| **队列** | Queue | 等待处理的请求 | 应该为0或很小 |
| **响应时间** | Response Time | 服务器响应时间 | < 500ms |
| **状态** | Status | 服务器健康状态 | UP（正常） |
| **权重** | Weight | 负载分配权重 | 根据服务器性能设置 |

**🔸 服务器状态说明**
```
UP：服务器正常运行 ✅
DOWN：服务器不可用 ❌  
DRAIN：服务器维护中，不接受新请求 ⚠️
MAINT：服务器进入维护模式 🔧
```

### 3.3 命令行统计信息


**🔸 通过Socket获取统计信息**
```bash
# 1. 配置统计socket
stats socket /var/run/haproxy.sock mode 600 level admin

# 2. 查看统计信息
echo "show stat" | socat - /var/run/haproxy.sock

# 3. 查看服务器信息  
echo "show servers state" | socat - /var/run/haproxy.sock

# 4. 启用/禁用服务器
echo "enable server backend/server1" | socat - /var/run/haproxy.sock
echo "disable server backend/server1" | socat - /var/run/haproxy.sock
```

**🔸 实用监控脚本**
```bash
#!/bin/bash
# haproxy_monitor.sh - HAProxy监控脚本

SOCKET="/var/run/haproxy.sock"

# 检查后端服务器状态
check_backend_health() {
    echo "=== 后端服务器健康状态 ==="
    echo "show stat" | socat - $SOCKET | grep -v "^#" | \
    awk -F',' '{if($2!="" && $18!="") printf "%-20s %-10s %-8s\n", $1"/"$2, $18, $9}'
}

# 检查会话连接数
check_sessions() {
    echo -e "\n=== 当前会话统计 ==="
    echo "show info" | socat - $SOCKET | grep -E "(CurrConns|MaxConns)"
}

check_backend_health
check_sessions
```

---

## 4. ⚡ 性能指标监控配置


### 4.1 关键性能指标


**什么是性能指标？**
性能指标就像体检报告中的各项数据，告诉我们代理服务器的"身体健康状况"如何。

**🔸 核心性能指标**
```
响应时间（Response Time）：
• 含义：从发送请求到收到响应的时间
• 重要性：直接影响用户体验
• 正常值：< 500ms（网页），< 100ms（API）

吞吐量（Throughput）：
• 含义：单位时间内处理的请求数量
• 重要性：体现服务器处理能力
• 单位：QPS（每秒查询数）、RPS（每秒请求数）

并发连接数（Concurrent Connections）：
• 含义：同时处理的连接数量
• 重要性：反映负载水平
• 监控：当前连接数/最大连接数比例

错误率（Error Rate）：
• 含义：失败请求占总请求的百分比
• 重要性：反映服务稳定性
• 目标：< 1%
```

### 4.2 监控配置实例


**🔸 Squid性能监控配置**
```bash
# squid.conf 性能监控相关配置
# 启用详细日志
access_log /var/log/squid/access.log squid

# 性能计数器
client_http_version_max 1.1
server_http_version_max 1.1

# 内存使用监控
cache_mem 256 MB
memory_pools off

# 缓存性能统计
cachemgr_passwd password all
```

**🔸 HAProxy性能监控配置**
```bash
# haproxy.cfg 性能监控配置
global
    # 统计信息更新间隔
    stats timeout 30s
    
defaults
    # 启用详细日志
    option httplog
    option log-health-checks
    
    # 超时设置
    timeout connect 5000ms
    timeout client  50000ms
    timeout server  50000ms
    
backend webservers
    # 健康检查
    option httpchk GET /health
    
    # 服务器定义（包含权重）
    server web1 192.168.1.10:80 check weight 100
    server web2 192.168.1.11:80 check weight 100
```

### 4.3 性能数据收集


**🔸 自动化性能数据收集脚本**
```bash
#!/bin/bash
# performance_collector.sh - 性能数据收集脚本

LOG_DIR="/var/log/proxy-monitor"
mkdir -p $LOG_DIR

# 收集Squid性能数据
collect_squid_perf() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local logfile="$LOG_DIR/squid_perf.log"
    
    # 获取缓存统计信息
    cache_hit=$(squidclient -h localhost cache_object://localhost/counters | grep "client_http.hit" | awk '{print $2}')
    cache_miss=$(squidclient -h localhost cache_object://localhost/counters | grep "client_http.miss" | awk '{print $2}')
    
    # 计算命中率
    if [ $((cache_hit + cache_miss)) -gt 0 ]; then
        hit_rate=$(echo "scale=2; $cache_hit * 100 / ($cache_hit + $cache_miss)" | bc)
    else
        hit_rate=0
    fi
    
    echo "$timestamp,hit_rate,$hit_rate,cache_hit,$cache_hit,cache_miss,$cache_miss" >> $logfile
}

# 收集HAProxy性能数据
collect_haproxy_perf() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local logfile="$LOG_DIR/haproxy_perf.log"
    
    # 通过socket获取统计信息
    echo "show info" | socat - /var/run/haproxy.sock | \
    while read line; do
        case $line in
            "CurrConns:"*)
                curr_conns=$(echo $line | awk '{print $2}')
                ;;
            "MaxConns:"*)
                max_conns=$(echo $line | awk '{print $2}')
                ;;
        esac
    done
    
    echo "$timestamp,current_connections,$curr_conns,max_connections,$max_conns" >> $logfile
}

# 定期执行收集
while true; do
    collect_squid_perf
    collect_haproxy_perf
    sleep 60  # 每分钟收集一次
done
```

---

## 5. 🔄 日志轮转管理


### 5.1 日志轮转的必要性


**为什么需要日志轮转？**
就像家里的垃圾需要定期清理一样，日志文件会越来越大，如果不及时处理，会占满磁盘空间，甚至导致系统崩溃。

**🔸 日志轮转的好处**
```
空间管理：防止日志文件占满磁盘
性能优化：小文件读写速度更快  
历史保留：保留一定时间的历史日志
便于分析：按时间分割便于查找问题
```

### 5.2 logrotate配置详解


**什么是logrotate？**
logrotate是Linux系统自带的日志管理工具，就像一个"自动清洁工"，按照你设定的规则定期整理日志文件。

**🔸 Squid日志轮转配置**
```bash
# /etc/logrotate.d/squid
/var/log/squid/*.log {
    daily                    # 每天轮转一次
    rotate 7                 # 保留7个历史文件
    compress                 # 压缩旧日志文件
    delaycompress           # 延迟压缩（下次轮转时压缩）
    missingok               # 文件不存在不报错
    notifempty              # 空文件不轮转
    create 644 squid squid  # 创建新文件的权限和所有者
    postrotate              # 轮转后执行的命令
        /usr/sbin/squid -k rotate
    endscript
}
```

**🔸 HAProxy日志轮转配置**
```bash
# /etc/logrotate.d/haproxy
/var/log/haproxy/*.log {
    weekly                   # 每周轮转一次
    rotate 4                 # 保留4个历史文件
    compress                 # 压缩旧文件
    missingok               
    notifempty              
    create 644 syslog adm   # 新文件权限设置
    postrotate
        /bin/kill -HUP `cat /var/run/rsyslogd.pid 2> /dev/null` 2> /dev/null || true
    endscript
}
```

### 5.3 日志轮转配置参数


**🔸 轮转频率选项**

| 参数 | 含义 | 适用场景 |
|-----|------|---------|
| **daily** | 每天轮转 | 高访问量网站 |
| **weekly** | 每周轮转 | 中等访问量 |
| **monthly** | 每月轮转 | 低访问量 |
| **size 100M** | 文件达到100M时轮转 | 根据文件大小 |

**🔸 实用配置示例**
```bash
# 高性能代理服务器配置
/var/log/squid/access.log {
    hourly                   # 每小时轮转（高频访问）
    rotate 24               # 保留24小时
    compress
    delaycompress
    missingok
    notifempty
    create 644 squid squid
    postrotate
        /usr/sbin/squid -k rotate
    endscript
}

# 测试logrotate配置
logrotate -d /etc/logrotate.d/squid     # 调试模式，不实际执行
logrotate -f /etc/logrotate.d/squid     # 强制执行轮转
```

---

## 6. 🔍 错误日志分析方法


### 6.1 常见错误类型识别


**错误日志是什么？**
错误日志就像医生的诊断报告，记录了代理服务器运行过程中遇到的各种问题和异常情况。

**🔸 Squid常见错误分析**
```bash
# 1. 连接错误
grep "TCP_DENIED" /var/log/squid/access.log
# 含义：访问被拒绝，可能是访问控制规则导致

# 2. 超时错误
grep "ERR_READ_TIMEOUT" /var/log/squid/cache.log
# 含义：读取超时，可能是后端服务器响应慢

# 3. 连接失败
grep "ERR_CONNECT_FAIL" /var/log/squid/cache.log
# 含义：无法连接到目标服务器

# 4. DNS解析错误
grep "ERR_DNS_FAIL" /var/log/squid/cache.log
# 含义：域名解析失败
```

**🔸 HAProxy错误状态码**

| 状态码 | 含义 | 可能原因 | 解决方法 |
|-------|------|---------|---------|
| **503** | 服务不可用 | 后端服务器全部下线 | 检查后端服务器状态 |
| **504** | 网关超时 | 后端响应时间过长 | 调整超时设置或优化后端 |
| **502** | 网关错误 | 后端服务器返回无效响应 | 检查后端服务器配置 |
| **400** | 请求错误 | 客户端请求格式错误 | 检查客户端请求 |

### 6.2 错误日志分析脚本


**🔸 自动化错误分析脚本**
```bash
#!/bin/bash
# error_analyzer.sh - 错误日志分析脚本

SQUID_LOG="/var/log/squid/access.log"
HAPROXY_LOG="/var/log/haproxy/haproxy.log"
REPORT_FILE="/tmp/error_report_$(date +%Y%m%d_%H%M%S).txt"

echo "=== 代理服务器错误分析报告 ===" > $REPORT_FILE
echo "分析时间: $(date)" >> $REPORT_FILE
echo >> $REPORT_FILE

# 分析Squid错误
analyze_squid_errors() {
    echo "=== Squid错误分析 ===" >> $REPORT_FILE
    
    # 统计各种错误类型
    echo "访问拒绝错误数量:" >> $REPORT_FILE
    grep -c "TCP_DENIED" $SQUID_LOG >> $REPORT_FILE
    
    echo -e "\n最近10个被拒绝的访问:" >> $REPORT_FILE
    grep "TCP_DENIED" $SQUID_LOG | tail -10 | \
    awk '{print $1, $3, $7}' >> $REPORT_FILE
    
    # 统计4xx和5xx错误
    echo -e "\n4xx客户端错误统计:" >> $REPORT_FILE
    awk '$9 ~ /^4[0-9][0-9]/ {print $9}' $SQUID_LOG | sort | uniq -c | sort -nr >> $REPORT_FILE
    
    echo -e "\n5xx服务器错误统计:" >> $REPORT_FILE
    awk '$9 ~ /^5[0-9][0-9]/ {print $9}' $SQUID_LOG | sort | uniq -c | sort -nr >> $REPORT_FILE
}

# 分析HAProxy错误
analyze_haproxy_errors() {
    echo -e "\n=== HAProxy错误分析 ===" >> $REPORT_FILE
    
    # 统计后端服务器连接错误
    echo "后端连接错误:" >> $REPORT_FILE
    grep -c "backend.*connect.*failed" $HAPROXY_LOG >> $REPORT_FILE
    
    # 统计超时错误
    echo -e "\n超时错误统计:" >> $REPORT_FILE
    grep -c "timeout" $HAPROXY_LOG >> $REPORT_FILE
}

# 生成建议
generate_suggestions() {
    echo -e "\n=== 问题解决建议 ===" >> $REPORT_FILE
    
    # 根据错误数量给出建议
    denied_count=$(grep -c "TCP_DENIED" $SQUID_LOG)
    if [ $denied_count -gt 100 ]; then
        echo "⚠️  访问拒绝错误较多，建议检查ACL规则配置" >> $REPORT_FILE
    fi
    
    timeout_count=$(grep -c "timeout" $HAPROXY_LOG)
    if [ $timeout_count -gt 50 ]; then
        echo "⚠️  超时错误较多，建议检查后端服务器性能和网络状况" >> $REPORT_FILE
    fi
}

# 执行分析
analyze_squid_errors
analyze_haproxy_errors
generate_suggestions

echo "错误分析报告已生成: $REPORT_FILE"
cat $REPORT_FILE
```

### 6.3 实时错误监控


**🔸 实时错误监控脚本**
```bash
#!/bin/bash
# real_time_error_monitor.sh - 实时错误监控

# 监控配置
SQUID_LOG="/var/log/squid/access.log"
ERROR_THRESHOLD=10  # 5分钟内错误超过10次就告警

# 实时监控函数
monitor_errors() {
    local log_file=$1
    local error_pattern=$2
    local description=$3
    
    # 使用tail -f实时监控日志
    tail -f $log_file | while read line; do
        if echo "$line" | grep -q "$error_pattern"; then
            echo "$(date): $description - $line"
            
            # 统计最近5分钟的错误数量
            recent_errors=$(grep "$error_pattern" $log_file | \
                          awk -v cutoff=$(($(date +%s) - 300)) '$1 > cutoff' | wc -l)
            
            if [ $recent_errors -gt $ERROR_THRESHOLD ]; then
                echo "🚨 告警：$description 错误频率过高！最近5分钟发生 $recent_errors 次"
                # 这里可以添加邮件或短信告警
            fi
        fi
    done
}

echo "开始实时监控代理服务器错误..."

# 并行监控多种错误类型
monitor_errors $SQUID_LOG "TCP_DENIED" "访问拒绝" &
monitor_errors $SQUID_LOG "ERR_CONNECT_FAIL" "连接失败" &
monitor_errors "/var/log/haproxy/haproxy.log" "503" "服务不可用" &

wait
```

---

## 7. 📱 实时监控工具使用


### 7.1 命令行实时监控工具


**什么是实时监控？**
实时监控就像看电视直播一样，能够立即看到代理服务器当前的运行状态，不需要等待或刷新。

**🔸 htop - 系统资源监控**
```bash
# 安装htop
apt-get install htop    # Debian/Ubuntu
yum install htop        # CentOS/RHEL

# 使用htop监控
htop
# 快捷键：
# F5: 树形显示进程
# F6: 排序方式选择
# F9: 杀死进程
# F10: 退出
```

**🔸 iftop - 网络流量监控**
```bash
# 安装iftop
apt-get install iftop

# 实时监控网络流量
iftop -i eth0           # 监控eth0网卡
iftop -n               # 不解析主机名（加快显示）
iftop -P               # 显示端口信息

# 界面说明：
# <= =>: 表示进出流量方向
# 三列数值: 2秒、10秒、40秒的平均流量
```

**🔸 nethogs - 进程网络使用监控**
```bash
# 安装nethogs
apt-get install nethogs

# 监控哪个进程在使用网络
nethogs eth0

# 显示内容：
# PID: 进程ID
# USER: 运行用户
# PROGRAM: 程序名称
# DEV: 网卡设备
# SENT/RECEIVED: 发送/接收的数据量
```

### 7.2 专业监控工具


**🔸 Nagios监控配置**
```bash
# 安装Nagios
apt-get install nagios3 nagios-plugins

# Squid服务监控配置 (/etc/nagios3/conf.d/squid.cfg)
define service {
    use                     generic-service
    host_name              proxy-server
    service_description    Squid Proxy Service
    check_command          check_tcp!3128
    check_interval         5
    retry_interval         2
    max_check_attempts     3
    notification_interval  30
}

# HAProxy监控配置
define service {
    use                     generic-service
    host_name              proxy-server
    service_description    HAProxy Service
    check_command          check_tcp!80
    check_interval         5
}
```

**🔸 Zabbix监控模板**
```bash
# Zabbix代理服务器监控项目
# 1. 服务可用性检查
UserParameter=squid.status,systemctl is-active squid
UserParameter=haproxy.status,systemctl is-active haproxy

# 2. 连接数监控
UserParameter=squid.connections,netstat -an | grep :3128 | grep ESTABLISHED | wc -l
UserParameter=haproxy.connections,netstat -an | grep :80 | grep ESTABLISHED | wc -l

# 3. 缓存命中率监控（Squid）
UserParameter=squid.hit_rate,squidclient -h localhost cache_object://localhost/counters | awk '/client_http.hit/ {hit=$2} /client_http.miss/ {miss=$2} END {if(hit+miss>0) print hit*100/(hit+miss); else print 0}'
```

### 7.3 自定义监控脚本


**🔸 综合实时监控脚本**
```bash
#!/bin/bash
# real_time_monitor.sh - 综合实时监控脚本

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 清屏并显示标题
clear_and_title() {
    clear
    echo -e "${GREEN}=== 代理服务器实时监控面板 ===${NC}"
    echo -e "${GREEN}更新时间: $(date)${NC}"
    echo "================================================"
}

# 检查服务状态
check_service_status() {
    echo -e "\n${YELLOW}=== 服务状态 ===${NC}"
    
    # 检查Squid状态
    if systemctl is-active squid >/dev/null 2>&1; then
        echo -e "Squid状态: ${GREEN}运行中${NC}"
    else
        echo -e "Squid状态: ${RED}已停止${NC}"
    fi
    
    # 检查HAProxy状态
    if systemctl is-active haproxy >/dev/null 2>&1; then
        echo -e "HAProxy状态: ${GREEN}运行中${NC}"
    else
        echo -e "HAProxy状态: ${RED}已停止${NC}"
    fi
}

# 显示连接统计
show_connections() {
    echo -e "\n${YELLOW}=== 连接统计 ===${NC}"
    
    # Squid连接数
    squid_conn=$(netstat -an | grep :3128 | grep ESTABLISHED | wc -l)
    echo "Squid当前连接数: $squid_conn"
    
    # HAProxy连接数
    haproxy_conn=$(netstat -an | grep :80 | grep ESTABLISHED | wc -l)
    echo "HAProxy当前连接数: $haproxy_conn"
}

# 显示系统资源
show_system_resources() {
    echo -e "\n${YELLOW}=== 系统资源 ===${NC}"
    
    # CPU使用率
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    echo "CPU使用率: ${cpu_usage}%"
    
    # 内存使用率
    mem_info=$(free | grep Mem)
    mem_total=$(echo $mem_info | awk '{print $2}')
    mem_used=$(echo $mem_info | awk '{print $3}')
    mem_usage=$(echo "scale=2; $mem_used * 100 / $mem_total" | bc)
    echo "内存使用率: ${mem_usage}%"
    
    # 磁盘使用率
    disk_usage=$(df -h | grep -E "/$" | awk '{print $5}' | cut -d'%' -f1)
    echo "磁盘使用率: ${disk_usage}%"
}

# 显示最新错误
show_recent_errors() {
    echo -e "\n${YELLOW}=== 最新错误（最近5分钟） ===${NC}"
    
    # 显示最近的Squid错误
    recent_squid_errors=$(grep "TCP_DENIED\|ERR_" /var/log/squid/access.log 2>/dev/null | tail -3)
    if [ ! -z "$recent_squid_errors" ]; then
        echo -e "${RED}Squid错误:${NC}"
        echo "$recent_squid_errors" | while read line; do
            echo "  $line"
        done
    else
        echo -e "Squid错误: ${GREEN}无${NC}"
    fi
}

# 主监控循环
main_loop() {
    while true; do
        clear_and_title
        check_service_status
        show_connections
        show_system_resources
        show_recent_errors
        
        echo -e "\n${GREEN}按Ctrl+C退出监控${NC}"
        sleep 5
    done
}

# 启动监控
echo "启动实时监控，按Ctrl+C退出..."
main_loop
```

---

## 8. 📊 SNMP监控配置


### 8.1 SNMP基础概念


**什么是SNMP？**
SNMP（简单网络管理协议）就像一套标准的"体检项目"，让不同的监控系统都能用相同的方式获取设备的运行状态信息。

**🔸 SNMP工作原理**
```
监控系统 (NMS)          被监控设备 (Agent)
      │                        │
      │──── SNMP Get ────────→ │  # 获取信息
      │                        │
      │←──── Response ────────  │  # 返回数据
      │                        │
      │←──── Trap/通知 ────────  │  # 主动告警
```

**🔸 SNMP版本差异**

| 版本 | 特点 | 安全性 | 使用场景 |
|-----|------|-------|---------|
| **SNMPv1** | 最简单 | 明文传输 | 内网环境 |
| **SNMPv2c** | 支持批量操作 | 明文传输 | 内网环境 |
| **SNMPv3** | 支持加密认证 | 高安全性 | 跨网环境 |

### 8.2 配置SNMP代理


**🔸 安装和配置SNMP**
```bash
# 安装SNMP服务
apt-get install snmpd snmp snmp-mibs-downloader    # Ubuntu/Debian
yum install net-snmp net-snmp-utils                # CentOS/RHEL

# 备份原配置
cp /etc/snmp/snmpd.conf /etc/snmp/snmpd.conf.bak

# 基础SNMP配置 (/etc/snmp/snmpd.conf)
# 社区字符串配置（类似密码）
rocommunity public  localhost                      # 只读权限，仅本机
rocommunity monitoring 192.168.1.0/24             # 只读权限，监控网段

# 系统信息配置
syslocation "Data Center Room 1"                   # 系统位置
syscontact "admin@company.com"                     # 联系人信息
sysname "proxy-server-01"                          # 系统名称

# 监听配置
agentAddress udp:161                               # 监听端口

# 进程监控
proc squid                                         # 监控squid进程
proc haproxy                                       # 监控haproxy进程

# 磁盘监控
disk / 90%                                         # 根目录使用率超过90%告警
disk /var 85%                                      # /var目录使用率超过85%告警
```

**🔸 启动SNMP服务**
```bash
# 启动SNMP服务
systemctl start snmpd
systemctl enable snmpd

# 检查服务状态
systemctl status snmpd

# 测试SNMP连通性
snmpwalk -v2c -c public localhost system
```

### 8.3 代理服务器专用监控配置


**🔸 自定义SNMP监控脚本**
```bash
# 在snmpd.conf中添加自定义扩展
extend squid-status /usr/local/bin/check_squid_status.sh
extend haproxy-status /usr/local/bin/check_haproxy_status.sh
extend proxy-performance /usr/local/bin/get_proxy_performance.sh

# /usr/local/bin/check_squid_status.sh
#!/bin/bash
if pgrep squid > /dev/null; then
    echo "1"  # 运行中
else
    echo "0"  # 已停止
fi

# /usr/local/bin/check_haproxy_status.sh  
#!/bin/bash
if pgrep haproxy > /dev/null; then
    echo "1"  # 运行中
else
    echo "0"  # 已停止
fi

# /usr/local/bin/get_proxy_performance.sh
#!/bin/bash
# 获取代理服务器性能指标
squid_conn=$(netstat -an | grep :3128 | grep ESTABLISHED | wc -l)
haproxy_conn=$(netstat -an | grep :80 | grep ESTABLISHED | wc -l)
cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d' ' -f1)

echo "squid_connections:$squid_conn haproxy_connections:$haproxy_conn cpu_usage:$cpu_usage"

# 给脚本执行权限
chmod +x /usr/local/bin/check_*.sh
chmod +x /usr/local/bin/get_proxy_performance.sh
```

**🔸 测试自定义监控**
```bash
# 测试自定义监控项
snmpwalk -v2c -c public localhost NET-SNMP-EXTEND-MIB::nsExtendOutput1Line

# 获取特定监控项
snmpget -v2c -c public localhost NET-SNMP-EXTEND-MIB::nsExtendOutput1Line."squid-status"
snmpget -v2c -c public localhost NET-SNMP-EXTEND-MIB::nsExtendOutput1Line."proxy-performance"
```

---

## 9. 🚨 监控告警设置


### 9.1 告警机制设计


**什么是监控告警？**
监控告警就像火灾报警器一样，当代理服务器出现问题时，能够立即通知管理员采取措施，避免小问题变成大故障。

**🔸 告警级别分类**
```
🔴 紧急告警（Critical）：
• 服务完全不可用
• 磁盘空间不足5%
• 内存使用超过95%
• 处理方式：立即处理，24x7响应

🟡 警告告警（Warning）：
• 服务响应变慢
• 错误率超过5%
• 资源使用率超过80%
• 处理方式：工作时间内处理

🟢 信息告警（Info）：
• 配置变更
• 定期维护
• 统计报告
• 处理方式：记录备案
```

### 9.2 邮件告警配置


**🔸 安装和配置邮件发送**
```bash
# 安装mailutils
apt-get install mailutils postfix

# 配置postfix为internet站点
dpkg-reconfigure postfix

# 测试邮件发送
echo "测试邮件内容" | mail -s "测试主题" admin@company.com
```

**🔸 告警脚本实现**
```bash
#!/bin/bash
# alert_system.sh - 告警系统脚本

# 配置信息
ALERT_EMAIL="admin@company.com"
ALERT_PHONE="13800138000"
LOG_FILE="/var/log/proxy_alerts.log"

# 发送邮件告警
send_email_alert() {
    local level=$1
    local service=$2
    local message=$3
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 根据告警级别设置主题前缀
    case $level in
        "CRITICAL")
            subject="🔴 [紧急] $service 告警"
            ;;
        "WARNING")
            subject="🟡 [警告] $service 告警"
            ;;
        "INFO")
            subject="🟢 [信息] $service 通知"
            ;;
    esac
    
    # 邮件内容
    email_body="
告警时间: $timestamp
告警级别: $level
服务名称: $service
告警信息: $message

服务器信息:
主机名: $(hostname)
IP地址: $(hostname -I | awk '{print $1}')

请及时检查和处理！
    "
    
    # 发送邮件
    echo "$email_body" | mail -s "$subject" $ALERT_EMAIL
    
    # 记录到日志
    echo "$timestamp [$level] $service: $message" >> $LOG_FILE
}

# 发送短信告警（这里使用简单的HTTP API示例）
send_sms_alert() {
    local message=$1
    # 这里需要根据实际的短信API调整
    # curl -X POST "https://sms-api.example.com/send" \
    #      -d "phone=$ALERT_PHONE" \
    #      -d "message=$message"
}

# 检查服务状态并告警
check_service_and_alert() {
    local service_name=$1
    local check_command=$2
    
    if ! eval $check_command; then
        send_email_alert "CRITICAL" "$service_name" "服务已停止运行"
        send_sms_alert "$service_name 服务停止"
    fi
}

# 检查性能指标并告警
check_performance_and_alert() {
    # 检查CPU使用率
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d' ' -f1)
    if (( $(echo "$cpu_usage > 90" | bc -l) )); then
        send_email_alert "WARNING" "系统性能" "CPU使用率过高: ${cpu_usage}%"
    fi
    
    # 检查内存使用率
    mem_usage=$(free | grep Mem | awk '{printf "%.2f", $3/$2 * 100.0}')
    if (( $(echo "$mem_usage > 90" | bc -l) )); then
        send_email_alert "WARNING" "系统性能" "内存使用率过高: ${mem_usage}%"
    fi
    
    # 检查磁盘使用率
    disk_usage=$(df -h | grep -E "/$" | awk '{print $5}' | cut -d'%' -f1)
    if [ $disk_usage -gt 90 ]; then
        send_email_alert "CRITICAL" "系统存储" "磁盘使用率过高: ${disk_usage}%"
    fi
}

# 主检查函数
main_check() {
    echo "开始执行监控检查..."
    
    # 检查服务状态
    check_service_and_alert "Squid" "systemctl is-active squid"
    check_service_and_alert "HAProxy" "systemctl is-active haproxy"
    
    # 检查性能指标
    check_performance_and_alert
    
    echo "监控检查完成"
}

# 如果脚本被直接执行
if [ "${BASH_SOURCE[0]}" == "${0}" ]; then
    main_check
fi
```

### 9.3 自动化告警部署


**🔸 定时任务配置**
```bash
# 编辑crontab
crontab -e

# 添加监控任务
# 每5分钟检查一次服务状态
*/5 * * * * /usr/local/bin/alert_system.sh >/dev/null 2>&1

# 每小时发送一次状态报告
0 * * * * /usr/local/bin/hourly_status_report.sh

# 每天凌晨2点生成日报
0 2 * * * /usr/local/bin/daily_report.sh
```

**🔸 状态报告脚本**
```bash
#!/bin/bash
# hourly_status_report.sh - 每小时状态报告

REPORT_FILE="/tmp/proxy_status_$(date +%Y%m%d_%H).txt"
ALERT_EMAIL="admin@company.com"

# 生成状态报告
generate_status_report() {
    echo "=== 代理服务器状态报告 ===" > $REPORT_FILE
    echo "报告时间: $(date)" >> $REPORT_FILE
    echo >> $REPORT_FILE
    
    # 服务状态
    echo "=== 服务状态 ===" >> $REPORT_FILE
    echo "Squid: $(systemctl is-active squid)" >> $REPORT_FILE
    echo "HAProxy: $(systemctl is-active haproxy)" >> $REPORT_FILE
    echo >> $REPORT_FILE
    
    # 连接统计
    echo "=== 连接统计 ===" >> $REPORT_FILE
    echo "Squid连接数: $(netstat -an | grep :3128 | grep ESTABLISHED | wc -l)" >> $REPORT_FILE
    echo "HAProxy连接数: $(netstat -an | grep :80 | grep ESTABLISHED | wc -l)" >> $REPORT_FILE
    echo >> $REPORT_FILE
    
    # 系统资源
    echo "=== 系统资源 ===" >> $REPORT_FILE
    echo "CPU使用率: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')" >> $REPORT_FILE
    echo "内存使用率: $(free | grep Mem | awk '{printf "%.2f%%", $3/$2 * 100.0}')" >> $REPORT_FILE
    echo "磁盘使用率: $(df -h | grep -E "/$" | awk '{print $5}')" >> $REPORT_FILE
    echo >> $REPORT_FILE
    
    # 最近错误（如果有）
    recent_errors=$(grep "$(date '+%Y-%m-%d %H:')" /var/log/proxy_alerts.log 2>/dev/null)
    if [ ! -z "$recent_errors" ]; then
        echo "=== 本小时告警记录 ===" >> $REPORT_FILE
        echo "$recent_errors" >> $REPORT_FILE
    else
        echo "=== 本小时告警记录 ===" >> $REPORT_FILE
        echo "无告警记录" >> $REPORT_FILE
    fi
}

# 发送报告
send_report() {
    local subject="📊 代理服务器状态报告 - $(date '+%Y-%m-%d %H:00')"
    cat $REPORT_FILE | mail -s "$subject" $ALERT_EMAIL
}

# 执行报告生成和发送
generate_status_report
send_report

echo "状态报告已发送到 $ALERT_EMAIL"
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 监控本质：24小时健康检查，及时发现问题预防故障
🔸 日志分析：通过访问日志了解服务状态和用户行为
🔸 性能监控：关注响应时间、吞吐量、连接数等关键指标
🔸 错误处理：识别常见错误类型，建立处理流程
🔸 告警机制：分级告警，确保重要问题得到及时响应
```

### 10.2 关键理解要点


**🔹 Squid日志解读核心**
```
状态码含义：
• TCP_HIT：缓存命中，性能好
• TCP_MISS：缓存未命中，需要从源站获取
• TCP_DENIED：访问被拒绝，检查ACL规则

关键指标：
• 缓存命中率：直接影响性能和带宽节省
• 响应时间：影响用户体验
• 错误率：反映服务稳定性
```

**🔹 HAProxy监控重点**
```
统计页面核心信息：
• 后端服务器状态：UP/DOWN/DRAIN
• 当前连接数：不能超过配置的最大值
• 响应时间：正常应该小于500ms
• 队列长度：应该保持为0或很小

性能调优方向：
• 合理配置超时时间
• 优化负载均衡算法
• 监控后端服务器健康状态
```

**🔹 监控告警设计原则**
```
分级处理：
• 紧急：服务不可用，立即处理
• 警告：性能下降，工作时间处理
• 信息：记录备案

避免告警疲劳：
• 设置合理的阈值
• 避免重复告警
• 提供清晰的处理建议
```

### 10.3 实际应用价值


**🎯 日常运维场景**
- **性能优化**：通过监控数据发现瓶颈，调整配置参数
- **故障排查**：利用日志分析快速定位问题原因
- **容量规划**：基于历史数据预测资源需求
- **安全防护**：监控异常访问模式，及时发现攻击

**🔧 最佳实践建议**
```
监控策略：
✅ 建立完整的监控体系，覆盖服务、性能、错误三个维度
✅ 设置合理的告警阈值，避免误报和漏报
✅ 定期审查监控指标，根据业务变化调整

日志管理：
✅ 配置日志轮转，防止磁盘空间耗尽
✅ 保留足够的历史日志用于问题分析
✅ 建立日志分析流程，定期生成报告

应急响应：
✅ 制定明确的故障处理流程
✅ 建立24x7的告警通知机制  
✅ 定期演练应急处理程序
```

### 10.4 学习进阶路径


**🎓 进阶技能发展**
```
初级：掌握基本的日志查看和简单监控配置
中级：能够分析性能瓶颈，配置自动化监控
高级：设计完整的监控体系，优化告警策略
专家：建立可视化监控平台，预测性维护
```

**🔗 相关技术关联**
- **系统监控**：与服务器监控、网络监控形成完整体系
- **自动化运维**：结合脚本和工具实现自动化管理
- **大数据分析**：利用日志数据进行深度业务分析
- **云平台监控**：在云环境中的监控实践

**核心记忆口诀**：
- 监控日志要分析，性能指标需关注
- 错误告警分等级，自动化运维效率高
- 预防故障胜治疗，持续优化保稳定