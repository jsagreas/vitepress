---
title: 10、网络传输加密配置
---
## 📚 目录

1. [网络传输加密概述](#1-网络传输加密概述)
2. [SSH隧道加密传输](#2-SSH隧道加密传输)
3. [VPN加密隧道配置](#3-VPN加密隧道配置)
4. [IPSec协议配置](#4-IPSec协议配置)
5. [OpenVPN证书认证](#5-OpenVPN证书认证)
6. [WireGuard现代VPN](#6-WireGuard现代VPN)
7. [端到端加密通信](#7-端到端加密通信)
8. [网络流量加密监控](#8-网络流量加密监控)
9. [加密协议选择策略](#9-加密协议选择策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔒 网络传输加密概述


### 1.1 为什么需要网络加密


**🌍 网络安全现状**
```
互联网传输过程：
你的电脑 → 路由器 → ISP → 互联网骨干网 → 目标服务器
    ↓         ↓       ↓         ↓           ↓
   明文     可能被截取  可能被监控  可能被窃取    接收
```

> **生活类比**：
> 网络传输就像寄信，如果不加密就相当于用明信片，途中任何人都能看到内容。
> 加密就像把信装进保险箱，只有收件人有钥匙才能打开。

### 1.2 加密的核心概念


**🔑 加密基本原理**

**对称加密**：发送和接收使用同一把钥匙
```
原理图示：
明文 + 密钥 → [加密算法] → 密文
密文 + 密钥 → [解密算法] → 明文

特点：
✅ 速度快，效率高
❌ 密钥分发困难
```

**非对称加密**：使用一对钥匙（公钥+私钥）
```
原理图示：
明文 + 公钥 → [加密] → 密文
密文 + 私钥 → [解密] → 明文

特点：
✅ 密钥分发安全
❌ 计算量大，速度慢
```

**🔍 常见加密算法**
| 算法类型 | **常见算法** | **密钥长度** | **安全级别** | **应用场景** |
|---------|------------|------------|------------|------------|
| **对称加密** | `AES-256` | `256位` | `极高` | `数据传输加密` |
| **对称加密** | `ChaCha20` | `256位` | `极高` | `现代移动设备` |
| **非对称加密** | `RSA-2048` | `2048位` | `高` | `密钥交换` |
| **非对称加密** | `ECDSA` | `256位` | `极高` | `数字签名` |

---

## 2. 🚇 SSH隧道加密传输


### 2.1 SSH隧道基本概念


**什么是SSH隧道？**
> SSH隧道就像在不安全的网络中挖了一条加密的地下通道，数据通过这条安全通道传输。

**🔸 SSH隧道类型**
```
本地端口转发（Local Forward）：
你的电脑 → SSH服务器 → 目标服务器
用途：访问内网服务

远程端口转发（Remote Forward）：
目标服务器 → SSH服务器 → 你的电脑  
用途：让外网访问你的本地服务

动态端口转发（SOCKS代理）：
你的电脑 → SSH服务器 → 任意网站
用途：科学上网，绕过网络限制
```

### 2.2 SSH隧道实践配置


**📝 本地端口转发配置**

**场景**：访问服务器内网的MySQL数据库（端口3306）

```bash
# 建立本地转发隧道
ssh -L 本地端口:目标地址:目标端口 用户@SSH服务器

# 实例：将本地8080端口映射到服务器的3306端口
ssh -L 8080:localhost:3306 root@192.168.1.100

# 后台运行隧道
ssh -f -N -L 8080:localhost:3306 root@192.168.1.100
```

**使用效果**：
- 在本地访问 `localhost:8080` 就相当于访问服务器的 `localhost:3306`
- 所有数据都经过SSH加密传输

**📝 远程端口转发配置**

**场景**：让外网能访问你本地的Web服务（端口8000）

```bash
# 建立远程转发隧道
ssh -R 远程端口:本地地址:本地端口 用户@SSH服务器

# 实例：将服务器的9000端口映射到本地8000端口
ssh -R 9000:localhost:8000 root@192.168.1.100
```

**📝 动态端口转发（SOCKS代理）**

```bash
# 建立SOCKS代理
ssh -D 本地端口 用户@SSH服务器

# 实例：在本地1080端口建立SOCKS代理
ssh -D 1080 root@192.168.1.100

# 配置应用程序使用代理：127.0.0.1:1080
```

### 2.3 SSH隧道高级配置


**🔧 SSH配置文件优化**

编辑 `~/.ssh/config`：
```bash
# 自动重连配置
Host tunnel-server
    HostName 192.168.1.100
    User root
    Port 22
    # 保持连接活跃
    ServerAliveInterval 60
    ServerAliveCountMax 3
    # 自动重连
    TCPKeepAlive yes
    # 压缩传输
    Compression yes
```

**🔴 安全注意事项**
> ⚠️ **重要提醒**
> 
> SSH隧道会占用系统资源，使用完毕记得关闭
> 不要在生产环境长期开启不必要的隧道

---

## 3. 🌐 VPN加密隧道配置


### 3.1 VPN工作原理


**VPN是什么？**
> VPN（虚拟专用网络）就像在公共网络中建立一条专属的高速公路，只有你能使用，而且全程加密保护。

**🔸 VPN连接过程**
```
建立VPN连接流程：

1. 身份认证阶段
   客户端 → VPN服务器：我是谁？
   VPN服务器 → 客户端：证明身份
   
2. 密钥协商阶段  
   双方协商：用什么加密算法？
   生成会话密钥：本次连接专用
   
3. 数据传输阶段
   所有数据都用会话密钥加密
   建立安全隧道进行通信
```

**🔍 VPN类型对比**
| VPN类型 | **技术特点** | **安全级别** | **配置难度** | **性能** |
|---------|------------|------------|------------|---------|
| **PPTP** | `老旧协议` | `❌ 低` | `✅ 简单` | `高` |
| **L2TP/IPSec** | `双层加密` | `✅ 高` | `🟡 中等` | `中等` |
| **OpenVPN** | `SSL/TLS` | `✅ 很高` | `🔴 复杂` | `中等` |
| **WireGuard** | `现代协议` | `✅ 极高` | `✅ 简单` | `极高` |

---

## 4. 🛡️ IPSec协议配置


### 4.1 IPSec协议理解


**什么是IPSec？**
> IPSec就像给每个数据包都穿上防弹衣，在网络层就开始保护数据，确保传输过程中不被窃取或篡改。

**🔸 IPSec工作模式**

**隧道模式（Tunnel Mode）**：
```
原始数据包结构：
[IP头] [数据载荷]

IPSec隧道模式加密后：
[新IP头] [IPSec头] [加密的原始数据包]
        ↑                ↑
   隧道端点信息      原始数据包全部加密
```

**传输模式（Transport Mode）**：
```
原始数据包：[IP头] [数据载荷]
传输模式：  [IP头] [IPSec头] [加密的数据载荷]
```

### 4.2 StrongSwan IPSec配置


**🔧 安装StrongSwan**

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install strongswan strongswan-pki libcharon-extra-plugins

# CentOS/RHEL  
sudo yum install epel-release
sudo yum install strongswan
```

**📝 基础配置文件**

编辑 `/etc/ipsec.conf`：
```bash
# 基本配置
config setup
    charondebug="ike 1, knl 1, cfg 0"
    uniqueids=no

# 连接配置
conn myvpn
    # 连接类型
    type=tunnel
    # 认证方式
    authby=secret
    # 左侧（本地）配置
    left=192.168.1.100
    leftsubnet=192.168.1.0/24
    # 右侧（远程）配置  
    right=203.0.113.12
    rightsubnet=10.10.10.0/24
    # 加密算法
    ike=aes256-sha2_256-modp2048
    esp=aes256-sha2_256
    # 自动启动
    auto=start
```

编辑 `/etc/ipsec.secrets`：
```bash
# 预共享密钥认证
192.168.1.100 203.0.113.12 : PSK "your-very-strong-password"
```

**🚀 启动IPSec服务**

```bash
# 启动服务
sudo systemctl start strongswan
sudo systemctl enable strongswan

# 检查连接状态
sudo ipsec status
sudo ipsec statusall
```

### 4.3 IPSec监控与故障排除


**📊 连接状态检查**

```bash
# 查看连接状态
ipsec status

# 查看详细信息
ipsec statusall

# 查看日志
journalctl -u strongswan -f
```

**🔧 常见问题解决**

| 问题现象 | **可能原因** | **解决方法** |
|---------|------------|------------|
| **连接超时** | `防火墙阻止` | `开放UDP 500,4500端口` |
| **认证失败** | `密钥错误` | `检查ipsec.secrets文件` |
| **无法通信** | `路由问题` | `检查网络路由配置` |

---

## 5. 🔐 OpenVPN证书认证


### 5.1 OpenVPN证书体系


**证书认证原理**
> OpenVPN的证书认证就像办银行卡，需要有权威机构（CA）颁发的身份证明，确保通信双方的身份真实可信。

**🔸 证书体系结构**
```
证书层级结构：
         CA根证书
            ↓
    ┌─────────────┐
    ↓             ↓
服务器证书      客户端证书
    ↓             ↓
 服务端私钥    客户端私钥
```

### 5.2 OpenVPN证书生成


**🛠️ 使用EasyRSA生成证书**

**步骤1：安装EasyRSA**
```bash
# 下载EasyRSA
wget https://github.com/OpenVPN/easy-rsa/releases/latest/download/EasyRSA-3.1.0.tgz
tar -xzf EasyRSA-3.1.0.tgz
cd EasyRSA-3.1.0
```

**步骤2：初始化PKI**
```bash
# 初始化PKI环境
./easyrsa init-pki

# 创建CA根证书
./easyrsa build-ca nopass
```

**步骤3：生成服务器证书**
```bash
# 生成服务器证书和私钥
./easyrsa gen-req server nopass
./easyrsa sign-req server server
```

**步骤4：生成客户端证书**
```bash
# 生成客户端证书
./easyrsa gen-req client1 nopass  
./easyrsa sign-req client client1

# 生成DH参数（用于密钥交换）
./easyrsa gen-dh
```

### 5.3 OpenVPN服务器配置


**📝 服务器配置文件** `/etc/openvpn/server.conf`：

```bash
# 基本设置
port 1194
proto udp
dev tun

# 证书和密钥文件
ca ca.crt
cert server.crt
key server.key
dh dh.pem

# 网络配置
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt

# 路由推送（客户端访问服务器内网）
push "route 192.168.1.0 255.255.255.0"

# DNS推送
push "dhcp-option DNS 8.8.8.8"
push "dhcp-option DNS 8.8.4.4"

# 安全设置
keepalive 10 120
cipher AES-256-CBC
user nobody
group nogroup
persist-key
persist-tun

# 日志
status openvpn-status.log
verb 3
```

### 5.4 OpenVPN客户端配置


**📝 客户端配置文件** `client.ovpn`：

```bash
# 客户端配置
client
dev tun
proto udp

# 服务器地址
remote your-server-ip 1194

# 连接设置
resolv-retry infinite
nobind
persist-key
persist-tun

# 证书内容（内联方式）
<ca>
-----BEGIN CERTIFICATE-----
[CA证书内容]
-----END CERTIFICATE-----
</ca>

<cert>
-----BEGIN CERTIFICATE-----
[客户端证书内容]  
-----END CERTIFICATE-----
</cert>

<key>
-----BEGIN PRIVATE KEY-----
[客户端私钥内容]
-----END PRIVATE KEY-----
</key>

# 安全设置
cipher AES-256-CBC
verb 3
```

**🚀 启动OpenVPN**

```bash
# 启动服务器
sudo systemctl start openvpn@server
sudo systemctl enable openvpn@server

# 客户端连接
sudo openvpn --config client.ovpn
```

---

## 6. ⚡ WireGuard现代VPN


### 6.1 WireGuard优势特点


**为什么选择WireGuard？**
> WireGuard就像现代汽车相比老爷车，更简单、更快、更安全，代码量只有传统VPN的1%，但性能却提升数倍。

**🔸 WireGuard核心特点**
```
技术优势对比：

传统VPN（OpenVPN）：
📦 代码量：100万行+
⏱️ 连接速度：较慢
🔧 配置复杂度：高
🚀 传输性能：中等

WireGuard：
📦 代码量：4千行
⏱️ 连接速度：极快
🔧 配置复杂度：低
🚀 传输性能：极高
```

### 6.2 WireGuard安装配置


**🛠️ 安装WireGuard**

```bash
# Ubuntu 20.04+
sudo apt update
sudo apt install wireguard

# CentOS 8+
sudo dnf install epel-release
sudo dnf install wireguard-tools

# 启用内核模块
sudo modprobe wireguard
```

**🔑 密钥生成**

```bash
# 生成私钥
wg genkey | tee private.key

# 从私钥生成公钥
cat private.key | wg pubkey > public.key

# 一键生成密钥对
wg genkey | tee private.key | wg pubkey > public.key
```

### 6.3 WireGuard配置实例


**📝 服务器配置** `/etc/wireguard/wg0.conf`：

```bash
[Interface]
# 服务器私钥
PrivateKey = SERVER_PRIVATE_KEY_HERE
# VPN网络地址
Address = 10.0.0.1/24
# 监听端口
ListenPort = 51820
# 启动后执行的命令
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# 客户端1配置
[Peer]
PublicKey = CLIENT1_PUBLIC_KEY_HERE
AllowedIPs = 10.0.0.2/32

# 客户端2配置  
[Peer]
PublicKey = CLIENT2_PUBLIC_KEY_HERE
AllowedIPs = 10.0.0.3/32
```

**📝 客户端配置** `/etc/wireguard/wg0.conf`：

```bash
[Interface]
# 客户端私钥
PrivateKey = CLIENT_PRIVATE_KEY_HERE
# 客户端VPN地址
Address = 10.0.0.2/24
# DNS设置
DNS = 8.8.8.8

[Peer]
# 服务器公钥
PublicKey = SERVER_PUBLIC_KEY_HERE
# 服务器地址和端口
Endpoint = your-server-ip:51820
# 允许的IP范围（0.0.0.0/0表示所有流量都通过VPN）
AllowedIPs = 0.0.0.0/0
# 保持连接
PersistentKeepalive = 25
```

**🚀 启动WireGuard**

```bash
# 启动接口
sudo wg-quick up wg0

# 设置开机自启
sudo systemctl enable wg-quick@wg0

# 查看连接状态
sudo wg show
```

### 6.4 WireGuard管理命令


**📊 状态监控**

```bash
# 查看接口状态
sudo wg

# 查看详细信息
sudo wg show wg0

# 实时查看流量
sudo wg show wg0 transfer
```

**🔧 动态管理**

```bash
# 添加客户端
sudo wg set wg0 peer CLIENT_PUBLIC_KEY allowed-ips 10.0.0.4/32

# 删除客户端
sudo wg set wg0 peer CLIENT_PUBLIC_KEY remove

# 重新加载配置
sudo wg-quick down wg0
sudo wg-quick up wg0
```

---

## 7. 🔐 端到端加密通信


### 7.1 端到端加密概念


**什么是端到端加密？**
> 端到端加密就像给每个人发放一把专属的保险箱钥匙，只有发送者和接收者能打开，连中间的邮递员都看不到内容。

**🔸 加密层级对比**
```
传输层加密（如HTTPS）：
客户端 ←[加密]→ 服务器 ←[明文]→ 其他服务器
        ↑               ↑
   只保护这段传输    服务器能看到明文

端到端加密：
客户端A ←[加密]→ 中继服务器 ←[加密]→ 客户端B
         ↑                          ↑
   整个过程都是加密的，中继服务器也无法解密
```

### 7.2 GPG加密实践


**🛠️ GPG安装和密钥管理**

```bash
# 安装GPG
sudo apt install gnupg

# 生成密钥对
gpg --full-generate-key

# 查看密钥
gpg --list-keys
gpg --list-secret-keys
```

**📝 文件加密解密**

```bash
# 加密文件（使用接收者的公钥）
gpg --encrypt --recipient user@example.com sensitive-data.txt

# 解密文件（使用自己的私钥）
gpg --decrypt sensitive-data.txt.gpg > decrypted-data.txt

# 签名文件（验证身份）
gpg --sign important-document.txt

# 验证签名
gpg --verify important-document.txt.gpg
```

### 7.3 应用层加密工具


**🔧 文本消息加密**

**使用Age工具**：
```bash
# 安装age
wget https://github.com/FiloSottile/age/releases/latest/download/age-v1.1.1-linux-amd64.tar.gz

# 生成密钥
age-keygen -o key.txt

# 加密消息
echo "机密消息" | age -r age1abc123... -o message.age

# 解密消息
age -d -i key.txt message.age
```

**🔐 磁盘加密**

**LUKS全盘加密**：
```bash
# 创建加密分区
sudo cryptsetup luksFormat /dev/sdb1

# 打开加密分区
sudo cryptsetup luksOpen /dev/sdb1 encrypted-disk

# 格式化并挂载
sudo mkfs.ext4 /dev/mapper/encrypted-disk
sudo mount /dev/mapper/encrypted-disk /mnt/secure
```

---

## 8. 📊 网络流量加密监控


### 8.1 加密流量识别


**如何识别加密流量？**
> 监控加密流量就像查看邮包的外包装，虽然看不到内容，但能知道谁发的、发给谁、多大、什么时候发的。

**🔍 流量分析工具**

**使用tcpdump抓包分析**：
```bash
# 抓取HTTPS流量
sudo tcpdump -i eth0 port 443 -w https-traffic.pcap

# 分析加密连接
sudo tcpdump -i eth0 'port 443' -c 100

# 统计流量
sudo tcpdump -i eth0 -c 1000 | awk '{print $3}' | sort | uniq -c
```

**使用netstat监控连接**：
```bash
# 查看加密连接
netstat -tuln | grep 443
netstat -tuln | grep 1194  # OpenVPN
netstat -tuln | grep 51820 # WireGuard

# 实时监控连接变化
watch -n 1 'netstat -tuln | grep -E "(443|1194|51820)"'
```

### 8.2 SSL/TLS证书监控


**📋 证书信息检查**

```bash
# 检查网站证书
openssl s_client -connect example.com:443 -servername example.com

# 查看证书详情
echo | openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -noout -text

# 检查证书有效期
echo | openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -noout -dates
```

**🔧 证书监控脚本**

```bash
#!/bin/bash
# cert-monitor.sh - 证书过期监控脚本

check_cert_expiry() {
    local host=$1
    local port=${2:-443}
    
    # 获取证书过期时间
    expiry=$(echo | openssl s_client -connect $host:$port 2>/dev/null | 
             openssl x509 -noout -enddate 2>/dev/null | 
             cut -d= -f2)
    
    if [ -n "$expiry" ]; then
        expiry_timestamp=$(date -d "$expiry" +%s)
        current_timestamp=$(date +%s)
        days_until_expiry=$(( (expiry_timestamp - current_timestamp) / 86400 ))
        
        echo "$host: $days_until_expiry days until expiry"
        
        if [ $days_until_expiry -lt 30 ]; then
            echo "WARNING: Certificate for $host expires soon!"
        fi
    else
        echo "ERROR: Could not retrieve certificate for $host"
    fi
}

# 监控多个站点
check_cert_expiry "example.com"
check_cert_expiry "myserver.com"
```

### 8.3 VPN连接监控


**📈 WireGuard流量统计**

```bash
# 查看实时传输统计
watch -n 1 'sudo wg show wg0 transfer'

# 生成流量报告
sudo wg show wg0 dump | awk '{
    if(NR>1) {
        print "Peer: " $1
        print "RX: " $6/1024/1024 " MB" 
        print "TX: " $7/1024/1024 " MB"
        print "---"
    }
}'
```

**📊 OpenVPN状态监控**

```bash
# 查看OpenVPN状态文件
cat /var/log/openvpn/openvpn-status.log

# 监控客户端连接
tail -f /var/log/openvpn/openvpn-status.log
```

---

## 9. 🎯 加密协议选择策略


### 9.1 不同场景的协议选择


**🔍 应用场景对比分析**

| 应用场景 | **推荐协议** | **原因** | **配置难度** |
|---------|------------|---------|------------|
| **远程办公** | `WireGuard` | `速度快、稳定、省电` | `⭐⭐` |
| **网站访问** | `SSH隧道` | `配置简单、临时使用` | `⭐` |
| **企业互联** | `IPSec` | `标准化、兼容性好` | `⭐⭐⭐⭐` |
| **移动设备** | `WireGuard` | `省电、快速重连` | `⭐⭐` |
| **高安全需求** | `OpenVPN` | `成熟稳定、功能丰富` | `⭐⭐⭐` |

### 9.2 性能对比测试


**⚡ 速度测试对比**
```
测试环境：1Gbps带宽，ping 20ms

协议性能对比：
┌──────────────┬─────────┬─────────┬─────────┐
│ 协议类型     │ 吞吐量  │ 延迟    │ CPU占用 │
├──────────────┼─────────┼─────────┼─────────┤
│ 无加密       │ 950Mbps │ 20ms    │ 5%      │
│ WireGuard    │ 920Mbps │ 22ms    │ 15%     │
│ OpenVPN      │ 680Mbps │ 28ms    │ 35%     │
│ IPSec        │ 780Mbps │ 25ms    │ 25%     │
│ SSH隧道      │ 450Mbps │ 35ms    │ 45%     │
└──────────────┴─────────┴─────────┴─────────┘

结论：WireGuard性能最接近无加密传输
```

### 9.3 安全等级评估


**🔒 安全性评分**

```
安全等级评估（10分制）：

WireGuard：
加密强度：⭐⭐⭐⭐⭐ (9/10)
代码审计：⭐⭐⭐⭐⭐ (10/10) 
漏洞历史：⭐⭐⭐⭐⭐ (10/10)
综合评分：9.7/10

OpenVPN：
加密强度：⭐⭐⭐⭐⭐ (9/10)
代码审计：⭐⭐⭐⭐ (8/10)
漏洞历史：⭐⭐⭐⭐ (8/10) 
综合评分：8.3/10

IPSec：
加密强度：⭐⭐⭐⭐⭐ (9/10)
代码审计：⭐⭐⭐ (7/10)
漏洞历史：⭐⭐⭐ (7/10)
综合评分：7.7/10
```

### 9.4 协议选择决策树


```
协议选择决策流程：

需要VPN吗？
├─ 否 → 使用HTTPS/SSH
└─ 是
   ├─ 临时使用？
   │  ├─ 是 → SSH隧道
   │  └─ 否 → 继续判断
   ├─ 移动设备多？
   │  ├─ 是 → WireGuard
   │  └─ 否 → 继续判断
   ├─ 企业级部署？
   │  ├─ 是 → IPSec/OpenVPN
   │  └─ 否 → WireGuard
   └─ 特殊需求？
      ├─ 高兼容性 → OpenVPN
      ├─ 最佳性能 → WireGuard
      └─ 标准化 → IPSec
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


**🔸 加密基础理解**
```
对称加密：一把钥匙，速度快，密钥分发困难
非对称加密：一对钥匙，安全性高，计算量大  
混合加密：结合两者优势，实际应用最常见
证书认证：PKI体系，确保身份可信
```

**🔸 各协议核心特点**
```
SSH隧道：简单快速，适合临时使用
IPSec：标准化强，企业级首选
OpenVPN：功能丰富，兼容性最好
WireGuard：现代协议，性能最佳
```

### 10.2 关键实践要点


**🔹 配置原则**
```
✅ 安全第一：选择强加密算法
✅ 性能平衡：根据需求选择协议
✅ 简化管理：自动化证书更新
✅ 监控告警：及时发现异常
✅ 定期更新：保持最新安全补丁
```

**🔹 常见错误避免**
```
❌ 使用弱密码或默认证书
❌ 忽略证书过期时间
❌ 不限制访问权限
❌ 缺少日志监控
❌ 配置过于复杂难维护
```

### 10.3 实际应用指导


**🎯 新手学习路径**
```
第1步：理解加密基本概念
第2步：掌握SSH隧道使用
第3步：学习WireGuard配置
第4步：了解证书管理
第5步：掌握流量监控方法
```

**🔧 生产环境建议**
```
推荐组合：
- 远程访问：WireGuard + 证书认证
- 站点互联：IPSec + 预共享密钥  
- 临时调试：SSH隧道 + 公钥认证
- 网站服务：HTTPS + Let's Encrypt
- 文件传输：SFTP/SCP + SSH密钥
```

**✅ 检查清单**
```
配置完成后检查：
□ 加密连接是否正常建立
□ 证书是否在有效期内
□ 防火墙规则是否正确
□ 监控告警是否配置
□ 备份恢复是否测试
□ 性能是否满足需求
□ 日志记录是否完整
```

**🧠 记忆要点**
- **SSH隧道**：简单快速，临时使用首选
- **WireGuard**：现代高效，日常VPN最佳
- **OpenVPN**：功能全面，企业级应用
- **IPSec**：标准协议，大型组织互联
- **证书管理**：安全基础，定期更新检查
- **流量监控**：安全保障，异常及时发现

**核心理念**：网络加密不是一次性配置，而是需要持续维护和监控的安全体系！