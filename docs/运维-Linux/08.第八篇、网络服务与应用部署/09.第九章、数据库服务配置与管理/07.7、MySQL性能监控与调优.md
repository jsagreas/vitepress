---
title: 7、MySQL性能监控与调优
---
## 📚 目录

1. [性能监控工具与指标](#1-性能监控工具与指标)
2. [慢查询识别与优化](#2-慢查询识别与优化)
3. [索引使用分析EXPLAIN](#3-索引使用分析EXPLAIN)
4. [内存配置参数调优](#4-内存配置参数调优)
5. [InnoDB存储引擎优化](#5-InnoDB存储引擎优化)
6. [连接数与线程池配置](#6-连接数与线程池配置)
7. [查询缓存配置与管理](#7-查询缓存配置与管理)
8. [性能schema数据库](#8-性能schema数据库)
9. [监控脚本与告警设置](#9-监控脚本与告警设置)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📊 性能监控工具与指标


### 1.1 MySQL内置性能监控工具


**🔍 什么是性能监控**
性能监控就像给MySQL装了一个"体检仪"，随时检查数据库的健康状况。就像医生看病人的血压、心率一样，我们需要看MySQL的各种"生命体征"。

**💡 核心监控指标说明**
```
CPU使用率：MySQL消耗多少处理器资源
内存使用：缓存命中率、内存分配情况
磁盘I/O：读写操作频率和响应时间
连接数：同时连接的客户端数量
查询响应时间：SQL执行需要多长时间
锁等待：事务等待锁的时间
```

**🛠️ 基础监控命令**
```sql
-- 查看当前连接状态
SHOW PROCESSLIST;

-- 查看系统状态变量
SHOW STATUS;

-- 查看重要性能指标
SHOW STATUS LIKE 'Threads_%';
SHOW STATUS LIKE 'Questions';
SHOW STATUS LIKE 'Slow_queries';
```

### 1.2 关键性能指标解析


**⚡ 连接相关指标**
| 指标名称 | **含义** | **正常范围** | **异常表现** |
|---------|---------|-------------|-------------|
| `Threads_connected` | `当前活跃连接数` | `< max_connections的70%` | `接近上限时需警惕` |
| `Threads_running` | `正在执行的线程数` | `< CPU核心数×2` | `过高表示并发压力大` |
| `Connection_errors_max_connections` | `连接数超限错误` | `0或接近0` | `频繁增长需调整参数` |

**📈 查询性能指标**
```
QPS (每秒查询数)：
计算公式：(Questions - 上次Questions值) / 时间间隔
正常值：根据业务需求，一般几百到几万不等

TPS (每秒事务数)：
计算公式：((Com_commit + Com_rollback) - 上次值) / 时间间隔
反映事务处理能力

慢查询比例：
计算公式：Slow_queries / Questions × 100%
建议值：< 5%，最好 < 1%
```

### 1.3 系统级监控工具


**🔧 mysqladmin工具使用**
```bash
# 实时查看MySQL状态（每2秒刷新一次）
mysqladmin -u root -p -i 2 status

# 查看当前进程
mysqladmin -u root -p processlist

# 查看扩展状态信息
mysqladmin -u root -p extended-status
```

**📊 MySQL Workbench性能仪表板**
```
图形化界面优势：
✅ 直观的图表显示
✅ 实时性能曲线
✅ 历史趋势分析
✅ 告警阈值设置

适用场景：
• 开发环境调试
• 性能问题定位
• 趋势分析
```

---

## 2. 🐌 慢查询识别与优化


### 2.1 慢查询日志配置


**📝 什么是慢查询日志**
慢查询日志就像是MySQL的"行车记录仪"，记录下所有执行时间超过设定阈值的SQL语句。通过分析这些"慢动作回放"，我们能发现性能瓶颈。

**⚙️ 开启慢查询日志**
```sql
-- 查看当前慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL slow_query_log_file = '/var/lib/mysql/slow.log';
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录
```

**📂 配置文件设置**
```ini
# /etc/mysql/my.cnf
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/lib/mysql/slow.log
long_query_time = 1
log_queries_not_using_indexes = 1
```

### 2.2 慢查询日志分析


**🔍 日志内容解读**
```
# 典型慢查询日志条目
# Time: 2025-09-17T10:30:45.123456Z
# User@Host: app_user[app_user] @ [192.168.1.100]
# Query_time: 5.123456  Lock_time: 0.000123  Rows_sent: 1000  Rows_examined: 50000
SELECT * FROM users WHERE age > 25 AND city = 'Shanghai';
```

**📊 日志字段说明**
```
Query_time：查询总耗时（秒）
Lock_time：等待锁的时间（秒）
Rows_sent：返回给客户端的行数
Rows_examined：扫描的行数

性能判断标准：
🚨 Rows_examined >> Rows_sent：效率很低，需要优化
⚠️ Lock_time 较高：存在锁竞争问题
```

**🛠️ mysqldumpslow工具分析**
```bash
# 按查询时间排序，显示前10条
mysqldumpslow -s t -t 10 /var/lib/mysql/slow.log

# 按扫描行数排序
mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log

# 按查询次数排序
mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log
```

### 2.3 慢查询优化策略


**🎯 常见慢查询类型及解决方案**

**全表扫描问题**
```sql
-- 问题SQL：没有合适索引
SELECT * FROM orders WHERE create_time > '2025-01-01';

-- 解决方案：添加索引
ALTER TABLE orders ADD INDEX idx_create_time (create_time);
```

**函数使用导致索引失效**
```sql
-- 问题SQL：索引字段使用函数
SELECT * FROM users WHERE YEAR(birthday) = 1990;

-- 优化方案：避免在索引字段使用函数
SELECT * FROM users WHERE birthday >= '1990-01-01' AND birthday < '1991-01-01';
```

**隐式类型转换**
```sql
-- 问题SQL：字符串字段与数字比较
SELECT * FROM products WHERE product_id = 123;  -- product_id是varchar类型

-- 优化方案：使用正确的数据类型
SELECT * FROM products WHERE product_id = '123';
```

---

## 3. 🔍 索引使用分析EXPLAIN


### 3.1 EXPLAIN基础概念


**💡 什么是EXPLAIN**
EXPLAIN就像是MySQL的"X光机"，能透视SQL语句的执行计划，告诉我们MySQL将如何执行这条查询，会用到哪些索引，扫描多少行数据。

**🔬 EXPLAIN基本语法**
```sql
-- 查看执行计划
EXPLAIN SELECT * FROM users WHERE age > 25;

-- 查看详细执行信息（MySQL 8.0+）
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE age > 25;
```

### 3.2 EXPLAIN输出字段详解


**📊 关键字段说明**
```
执行计划表格解读：

+----+-------------+-------+-------+------+------+------+-------+
| id | select_type | table | type  | key  | rows | Extra         |
+----+-------------+-------+-------+------+------+------+-------+
```

| 字段 | **含义** | **重要程度** | **优化目标** |
|------|---------|-------------|-------------|
| `type` | `访问类型` | `⭐⭐⭐⭐⭐` | `const > eq_ref > ref > range > index > ALL` |
| `key` | `实际使用的索引` | `⭐⭐⭐⭐⭐` | `确保使用了合适的索引` |
| `rows` | `预估扫描行数` | `⭐⭐⭐⭐` | `越少越好` |
| `Extra` | `额外执行信息` | `⭐⭐⭐⭐` | `避免Using filesort, Using temporary` |

### 3.3 type字段性能分析


**🚀 访问类型性能排序（从优到劣）**

```
const：常量级别（最快）
示例：SELECT * FROM users WHERE id = 1;
特点：主键或唯一索引的等值查询

eq_ref：唯一索引扫描
示例：JOIN查询中，对每个来自前面表的行，在当前表中只能找到一行
特点：通常出现在多表连接中

ref：非唯一索引扫描
示例：SELECT * FROM users WHERE name = 'John';
特点：返回匹配某个单独值的所有行

range：范围扫描
示例：SELECT * FROM users WHERE age BETWEEN 20 AND 30;
特点：使用索引进行范围查询

index：索引全扫描
示例：SELECT id FROM users;
特点：遍历整个索引树

ALL：全表扫描（最慢）
示例：SELECT * FROM users WHERE nickname LIKE '%test%';
特点：需要扫描整个表
```

**⚠️ 需要优化的type类型**
> 🚨 **警告**：当看到`ALL`或`index`类型时，通常需要优化  
> 📝 **目标**：尽量让查询达到`const`、`eq_ref`或`ref`级别

### 3.4 实际优化案例


**📋 案例：优化一个复杂查询**
```sql
-- 原始慢查询
EXPLAIN SELECT u.name, o.total 
FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.status = 'active' 
  AND o.create_time > '2025-01-01'
ORDER BY o.create_time DESC;
```

**🔧 优化步骤**
```sql
-- 步骤1：为关联字段创建索引
ALTER TABLE orders ADD INDEX idx_user_create (user_id, create_time);

-- 步骤2：为过滤条件创建索引
ALTER TABLE users ADD INDEX idx_status (status);

-- 步骤3：考虑覆盖索引
ALTER TABLE orders ADD INDEX idx_cover (user_id, create_time, total);
```

**📈 优化效果对比**
```
优化前：
type: ALL, rows: 100000, Extra: Using filesort

优化后：
type: ref, rows: 50, Extra: Using index
```

---

## 4. 💾 内存配置参数调优


### 4.1 MySQL内存架构理解


**🏗️ MySQL内存分配结构**
```
MySQL内存使用示意图：

┌─────────────────────────────────────┐
│           MySQL进程内存             │
├─────────────────────────────────────┤
│  全局缓冲区（所有连接共享）          │
│  ├── InnoDB Buffer Pool             │
│  ├── Query Cache                    │ 
│  ├── Table Cache                    │
│  └── Key Buffer (MyISAM)            │
├─────────────────────────────────────┤
│  连接级缓冲区（每个连接独有）        │
│  ├── Sort Buffer                    │
│  ├── Read Buffer                    │
│  ├── Join Buffer                    │
│  └── Tmp Table Size                 │
└─────────────────────────────────────┘
```

### 4.2 关键内存参数配置


**🔧 InnoDB Buffer Pool调优**
```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

-- 推荐配置（物理内存的70-80%）
-- 如果服务器有8GB内存，设置为6GB
SET GLOBAL innodb_buffer_pool_size = 6442450944;  -- 6GB
```

**📊 Buffer Pool效率监控**
```sql
-- 查看缓冲池命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_%';

-- 计算命中率公式
SELECT 
  (1 - (Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests)) * 100 
  AS buffer_pool_hit_rate;
```

> 💡 **最佳实践**：Buffer Pool命中率应该 > 99%

**⚙️ 连接级内存参数**
```ini
# /etc/mysql/my.cnf
[mysqld]
# 排序缓冲区大小
sort_buffer_size = 2M

# 读取缓冲区大小  
read_buffer_size = 128K

# 连接缓冲区大小
join_buffer_size = 128K

# 临时表大小
tmp_table_size = 64M
max_heap_table_size = 64M
```

### 4.3 内存使用监控与调优


**📈 内存使用情况检查**
```bash
# 系统层面检查MySQL内存使用
ps aux | grep mysql
pmap -d $(pgrep mysql)

# 使用MySQL自带工具
mysql -e "SHOW ENGINE INNODB STATUS\G" | grep -A 20 "BUFFER POOL"
```

**🎯 调优建议**
```
服务器内存分配建议：

4GB服务器：
├── 操作系统：1GB
├── InnoDB Buffer Pool：2.5GB  
├── 其他MySQL组件：300MB
└── 系统预留：200MB

8GB服务器：
├── 操作系统：1.5GB
├── InnoDB Buffer Pool：5.5GB
├── 其他MySQL组件：500MB  
└── 系统预留：500MB

调优原则：
✅ InnoDB Buffer Pool是最重要的参数
✅ 避免使用swap分区
✅ 监控OOM（内存溢出）错误
```

---

## 5. 🔧 InnoDB存储引擎优化


### 5.1 InnoDB核心特性


**💡 什么是InnoDB存储引擎**
InnoDB就像是MySQL的"发动机"，它负责数据的实际存储和管理。想象成汽车的发动机，不同的发动机有不同的性能特点，InnoDB是目前最主流、功能最强大的MySQL存储引擎。

**🌟 InnoDB主要特性**
```
事务支持：支持ACID事务特性
行级锁定：并发性能好，锁粒度小
外键约束：维护数据完整性
崩溃恢复：自动崩溃恢复机制
多版本并发控制（MVCC）：读写不冲突
```

### 5.2 InnoDB关键参数调优


**📊 事务日志相关参数**
```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'innodb_log%';

-- 关键参数说明
innodb_log_file_size = 256M        -- 日志文件大小
innodb_log_files_in_group = 2      -- 日志文件数量  
innodb_log_buffer_size = 16M       -- 日志缓冲区大小
innodb_flush_log_at_trx_commit = 1 -- 事务提交时日志刷新策略
```

**⚡ 刷新策略参数详解**
| 参数值 | **行为** | **性能** | **安全性** | **适用场景** |
|-------|---------|---------|-----------|-------------|
| `0` | `每秒刷新一次` | `最高` | `最低` | `高性能需求，可容忍少量数据丢失` |
| `1` | `每次事务提交都刷新` | `最低` | `最高` | `金融等高安全性要求场景` |
| `2` | `每次提交写入OS缓冲，每秒刷新` | `中等` | `中等` | `平衡性能和安全性` |

**🔄 并发控制参数**
```ini
# /etc/mysql/my.cnf
[mysqld]
# 并发线程数限制
innodb_thread_concurrency = 0  # 0表示不限制，推荐设置

# 读写I/O线程数
innodb_read_io_threads = 4
innodb_write_io_threads = 4

# 并发事务数量
innodb_max_dirty_pages_pct = 75  # 脏页比例阈值
```

### 5.3 InnoDB性能监控


**📈 监控关键指标**
```sql
-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS\G

-- 重要性能指标
SHOW STATUS LIKE 'Innodb_rows_%';        -- 行操作统计
SHOW STATUS LIKE 'Innodb_buffer_pool_%'; -- 缓冲池状态
SHOW STATUS LIKE 'Innodb_log_%';         -- 日志相关统计
```

**🔍 性能瓶颈识别**
```
常见性能问题及表现：

Buffer Pool命中率低：
表现：Innodb_buffer_pool_reads 增长很快
解决：增加innodb_buffer_pool_size

日志写入成为瓶颈：
表现：Innodb_log_waits > 0
解决：增加innodb_log_buffer_size

脏页刷新频繁：
表现：Innodb_buffer_pool_pages_dirty较高
解决：调整innodb_max_dirty_pages_pct
```

---

## 6. 🔗 连接数与线程池配置


### 6.1 MySQL连接机制理解


**💡 什么是数据库连接**
数据库连接就像是"电话线路"，应用程序通过这些"线路"与MySQL进行通信。每个连接都会消耗一定的系统资源，连接数量的合理配置直接影响系统性能。

**🏗️ 连接处理架构**
```
MySQL连接处理流程：

客户端应用 ──[建立连接]──> MySQL连接池 ──[分配线程]──> 工作线程
    │                           │                      │
    │                           │                      │
    └──[发送SQL]─────────────────┴──[执行查询]─────────────┘
```

### 6.2 连接参数配置


**⚙️ 核心连接参数**
```sql
-- 查看当前连接配置
SHOW VARIABLES LIKE 'max_connections';
SHOW VARIABLES LIKE 'max_user_connections';
SHOW VARIABLES LIKE 'thread%';

-- 连接相关状态
SHOW STATUS LIKE 'Threads_%';
SHOW STATUS LIKE 'Connections';
```

**📊 连接参数说明**
| 参数 | **默认值** | **推荐设置** | **说明** |
|------|-----------|-------------|---------|
| `max_connections` | `151` | `根据业务需求，通常200-1000` | `最大并发连接数` |
| `max_user_connections` | `0` | `根据用户分配，如100` | `单个用户最大连接数` |
| `thread_cache_size` | `9` | `50-100` | `线程缓存数量` |
| `connect_timeout` | `10` | `10-30` | `连接超时时间（秒）` |

### 6.3 连接数计算与调优


**🧮 连接数计算公式**
```
连接数估算方法：

基于并发用户数：
max_connections = 并发用户数 × 1.2（预留20%缓冲）

基于系统资源：
max_connections = (可用内存 - 系统开销) / 单连接内存消耗

单连接内存消耗约：
sort_buffer_size + read_buffer_size + join_buffer_size + binlog_cache_size
```

**📈 连接监控脚本**
```bash
#!/bin/bash
# MySQL连接监控脚本

mysql -e "
SELECT 
  VARIABLE_VALUE as max_connections 
FROM performance_schema.global_variables 
WHERE VARIABLE_NAME = 'max_connections';

SELECT 
  VARIABLE_VALUE as current_connections 
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Threads_connected';

SELECT 
  ROUND(
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Threads_connected') /
    (SELECT VARIABLE_VALUE FROM performance_schema.global_variables WHERE VARIABLE_NAME = 'max_connections') * 100, 2
  ) as connection_usage_percent;
"
```

**⚠️ 连接数告警阈值**
> 📝 **建议**：当连接使用率超过80%时应该告警  
> 🚨 **危险**：接近max_connections时会拒绝新连接

---

## 7. 💾 查询缓存配置与管理


### 7.1 查询缓存工作原理


**💡 什么是查询缓存**
查询缓存就像是MySQL的"记忆库"，它会记住之前执行过的查询结果。当相同的查询再次到来时，直接从"记忆库"中取出结果，而不需要重新执行，大大提高响应速度。

> ⚠️ **重要提醒**：MySQL 8.0已经移除查询缓存功能，此部分主要适用于MySQL 5.7及以下版本

**🔄 查询缓存工作流程**
```
查询缓存命中流程：

SQL查询请求 → 检查缓存 → 缓存命中？
                   ├─ 是：直接返回结果
                   └─ 否：执行查询 → 将结果存入缓存 → 返回结果
```

### 7.2 查询缓存配置


**⚙️ 查询缓存参数配置**
```sql
-- 查看查询缓存状态
SHOW VARIABLES LIKE 'query_cache%';

-- 核心参数
query_cache_type = ON              -- 启用查询缓存
query_cache_size = 64M             -- 缓存大小
query_cache_limit = 2M             -- 单个查询结果最大缓存大小
query_cache_min_res_unit = 4K      -- 缓存块最小单位
```

**📊 查询缓存类型设置**
| 设置值 | **行为** | **适用场景** |
|-------|---------|-------------|
| `OFF` | `完全禁用查询缓存` | `写操作频繁的系统` |
| `ON` | `缓存除SELECT SQL_NO_CACHE外的查询` | `读多写少的系统` |
| `DEMAND` | `只缓存SELECT SQL_CACHE的查询` | `需要精确控制缓存的场景` |

### 7.3 查询缓存性能监控


**📈 缓存效率监控**
```sql
-- 查看缓存统计信息
SHOW STATUS LIKE 'Qcache%';

-- 关键指标解读
Qcache_hits          -- 缓存命中次数
Qcache_inserts       -- 插入缓存的查询数  
Qcache_not_cached    -- 未缓存的查询数
Qcache_lowmem_prunes -- 因内存不足被移除的缓存数
```

**🎯 缓存命中率计算**
```sql
-- 计算查询缓存命中率
SELECT 
  ROUND(
    Qcache_hits / (Qcache_hits + Com_select) * 100, 2
  ) AS cache_hit_rate
FROM 
  (SELECT VARIABLE_VALUE AS Qcache_hits 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Qcache_hits') AS hits,
  (SELECT VARIABLE_VALUE AS Com_select 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Com_select') AS selects;
```

> 💡 **性能目标**：查询缓存命中率应该 > 40%才有意义

**⚠️ 查询缓存使用注意事项**
```
不适合使用查询缓存的场景：
❌ 表更新频繁：任何表的修改都会清空相关缓存
❌ 查询结果集很大：占用过多缓存空间
❌ 查询包含不确定函数：如NOW()、RAND()等

适合使用查询缓存的场景：
✅ 读多写少的系统
✅ 查询结果相对稳定
✅ 重复查询较多
```

---

## 8. 🎛️ 性能schema数据库


### 8.1 Performance Schema简介


**💡 什么是Performance Schema**
Performance Schema是MySQL内置的性能监控数据库，就像是MySQL的"黑匣子"，记录了数据库运行过程中的各种性能数据。通过查询这个特殊的数据库，我们可以深入了解MySQL的运行状态。

**🔍 Performance Schema主要功能**
```
性能数据收集范围：
• 服务器事件：连接、断开、查询执行等
• 语句事件：SQL语句执行的详细信息
• 等待事件：各种锁等待、I/O等待等
• 内存使用：各组件的内存分配情况
• 元数据锁：表锁、行锁等锁信息
```

### 8.2 常用Performance Schema表


**📊 核心监控表说明**

**语句分析相关表**
```sql
-- 查看最耗时的SQL语句
SELECT 
  sql_text,
  exec_count,
  avg_timer_wait/1000000000 AS avg_time_sec,
  sum_timer_wait/1000000000 AS total_time_sec
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY sum_timer_wait DESC 
LIMIT 10;
```

**连接和用户分析**
```sql
-- 查看各用户的连接统计
SELECT 
  user,
  current_connections,
  total_connections
FROM performance_schema.users;

-- 查看当前活跃的连接
SELECT 
  processlist_id,
  processlist_user,
  processlist_host,
  processlist_db,
  processlist_command,
  processlist_time
FROM performance_schema.threads 
WHERE processlist_command IS NOT NULL;
```

### 8.3 实用性能监控查询


**🔍 慢查询Top 10**
```sql
-- 查找执行时间最长的查询
SELECT 
  DIGEST_TEXT as query,
  COUNT_STAR as exec_count,
  AVG_TIMER_WAIT/1000000000 as avg_time,
  SUM_TIMER_WAIT/1000000000 as total_time,
  SUM_ROWS_EXAMINED as total_rows_examined,
  SUM_ROWS_SENT as total_rows_sent
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY SUM_TIMER_WAIT DESC 
LIMIT 10;
```

**📈 表访问统计**
```sql
-- 查看表的访问频率和耗时
SELECT 
  object_schema,
  object_name,
  count_read,
  count_write,
  sum_timer_wait/1000000000 as total_time_sec
FROM performance_schema.table_io_waits_summary_by_table 
WHERE object_schema NOT IN ('mysql', 'performance_schema', 'information_schema')
ORDER BY sum_timer_wait DESC 
LIMIT 10;
```

**💾 内存使用分析**
```sql
-- 查看内存使用情况
SELECT 
  event_name,
  current_alloc/1024/1024 as current_mb,
  high_alloc/1024/1024 as high_mb
FROM performance_schema.memory_summary_global_by_event_name 
WHERE current_alloc > 0 
ORDER BY current_alloc DESC 
LIMIT 10;
```

---

## 9. 🚨 监控脚本与告警设置


### 9.1 MySQL健康检查脚本


**🔧 基础健康检查脚本**
```bash
#!/bin/bash
# MySQL健康检查脚本
# 文件名：mysql_health_check.sh

MYSQL_USER="monitor_user"
MYSQL_PASS="monitor_password"
MYSQL_HOST="localhost"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo "=== MySQL健康检查报告 ==="
echo "检查时间：$(date)"
echo

# 1. 检查MySQL服务状态
echo "1. MySQL服务状态检查"
if systemctl is-active --quiet mysql; then
    echo -e "${GREEN}✓ MySQL服务正在运行${NC}"
else
    echo -e "${RED}✗ MySQL服务未运行${NC}"
    exit 1
fi

# 2. 检查连接数
echo "2. 连接数检查"
CURRENT_CONN=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW STATUS LIKE 'Threads_connected';" 2>/dev/null | grep Threads_connected | awk '{print $2}')
MAX_CONN=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW VARIABLES LIKE 'max_connections';" 2>/dev/null | grep max_connections | awk '{print $2}')

if [ ! -z "$CURRENT_CONN" ] && [ ! -z "$MAX_CONN" ]; then
    CONN_PERCENT=$((CURRENT_CONN * 100 / MAX_CONN))
    echo "当前连接数：$CURRENT_CONN / $MAX_CONN (${CONN_PERCENT}%)"
    
    if [ $CONN_PERCENT -gt 80 ]; then
        echo -e "${RED}⚠ 连接数使用率过高${NC}"
    elif [ $CONN_PERCENT -gt 60 ]; then
        echo -e "${YELLOW}⚠ 连接数使用率较高${NC}"
    else
        echo -e "${GREEN}✓ 连接数正常${NC}"
    fi
else
    echo -e "${RED}✗ 无法获取连接数信息${NC}"
fi

# 3. 检查慢查询
echo "3. 慢查询检查"
SLOW_QUERIES=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW STATUS LIKE 'Slow_queries';" 2>/dev/null | grep Slow_queries | awk '{print $2}')
if [ ! -z "$SLOW_QUERIES" ]; then
    echo "慢查询数量：$SLOW_QUERIES"
    if [ $SLOW_QUERIES -gt 100 ]; then
        echo -e "${YELLOW}⚠ 慢查询数量较多，建议检查${NC}"
    else
        echo -e "${GREEN}✓ 慢查询数量正常${NC}"
    fi
fi

echo
echo "=== 检查完成 ==="
```

### 9.2 性能指标监控脚本


**📊 性能监控脚本**
```bash
#!/bin/bash
# MySQL性能监控脚本
# 文件名：mysql_performance_monitor.sh

MYSQL_CMD="mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST"
LOG_FILE="/var/log/mysql_performance.log"

# 获取当前时间戳
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# 收集性能指标
QPS=$($MYSQL_CMD -e "SHOW STATUS LIKE 'Questions';" 2>/dev/null | grep Questions | awk '{print $2}')
CONNECTIONS=$($MYSQL_CMD -e "SHOW STATUS LIKE 'Threads_connected';" 2>/dev/null | grep Threads_connected | awk '{print $2}')
INNODB_BUFFER_POOL_READS=$($MYSQL_CMD -e "SHOW STATUS LIKE 'Innodb_buffer_pool_reads';" 2>/dev/null | grep Innodb_buffer_pool_reads | awk '{print $2}')
INNODB_BUFFER_POOL_READ_REQUESTS=$($MYSQL_CMD -e "SHOW STATUS LIKE 'Innodb_buffer_pool_read_requests';" 2>/dev/null | grep Innodb_buffer_pool_read_requests | awk '{print $2}')

# 计算缓冲池命中率
if [ ! -z "$INNODB_BUFFER_POOL_READS" ] && [ ! -z "$INNODB_BUFFER_POOL_READ_REQUESTS" ] && [ $INNODB_BUFFER_POOL_READ_REQUESTS -gt 0 ]; then
    BUFFER_POOL_HIT_RATE=$(echo "scale=2; (1 - $INNODB_BUFFER_POOL_READS / $INNODB_BUFFER_POOL_READ_REQUESTS) * 100" | bc)
else
    BUFFER_POOL_HIT_RATE="N/A"
fi

# 记录到日志文件
echo "$TIMESTAMP,QPS:$QPS,Connections:$CONNECTIONS,BufferPoolHitRate:$BUFFER_POOL_HIT_RATE%" >> $LOG_FILE

# 输出到屏幕
echo "[$TIMESTAMP] QPS:$QPS, 连接数:$CONNECTIONS, 缓冲池命中率:$BUFFER_POOL_HIT_RATE%"
```

### 9.3 告警规则配置


**🚨 关键告警阈值设置**
```bash
# 告警阈值配置文件：mysql_alert_thresholds.conf

# 连接数告警阈值（百分比）
CONNECTION_WARNING_THRESHOLD=70
CONNECTION_CRITICAL_THRESHOLD=85

# 缓冲池命中率告警阈值（百分比）
BUFFER_POOL_HIT_RATE_WARNING=95
BUFFER_POOL_HIT_RATE_CRITICAL=90

# QPS突增告警阈值
QPS_SPIKE_THRESHOLD=1000

# 慢查询告警阈值
SLOW_QUERY_WARNING_THRESHOLD=50
SLOW_QUERY_CRITICAL_THRESHOLD=100

# 磁盘空间告警阈值（百分比）
DISK_WARNING_THRESHOLD=80
DISK_CRITICAL_THRESHOLD=90
```

**📧 邮件告警脚本**
```bash
#!/bin/bash
# MySQL告警邮件发送脚本
# 文件名：mysql_alert.sh

send_alert() {
    local alert_level=$1
    local alert_message=$2
    local email_subject="[MySQL-$alert_level] $HOSTNAME MySQL告警"
    
    echo "$alert_message" | mail -s "$email_subject" admin@company.com
    
    # 同时记录到系统日志
    logger -p local0.warning "MySQL Alert [$alert_level]: $alert_message"
}

# 使用示例
# send_alert "WARNING" "MySQL连接数使用率达到75%，当前连接数：150/200"
```

**⏰ 定时监控设置**
```bash
# 添加到crontab
# crontab -e

# 每分钟执行健康检查
* * * * * /opt/scripts/mysql_health_check.sh

# 每5分钟收集性能指标  
*/5 * * * * /opt/scripts/mysql_performance_monitor.sh

# 每小时检查慢查询日志
0 * * * * /opt/scripts/mysql_slow_query_analysis.sh

# 每天凌晨生成性能报告
0 6 * * * /opt/scripts/mysql_daily_report.sh
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 性能监控：实时掌握MySQL运行状态的重要手段
🔸 慢查询优化：提升数据库性能的关键环节
🔸 EXPLAIN分析：SQL优化的重要工具
🔸 内存调优：合理配置各种缓冲区大小
🔸 InnoDB优化：重点关注存储引擎参数
🔸 连接管理：避免连接数成为性能瓶颈
🔸 监控告警：及时发现和处理性能问题
```

### 10.2 关键理解要点


**🔹 性能优化的层次结构**
```
应用层优化：SQL语句、索引设计
    ↓
配置层优化：参数调优、内存分配
    ↓  
系统层优化：操作系统、硬件配置
    ↓
架构层优化：读写分离、分库分表
```

**🔹 监控指标的优先级**
```
一级指标（必须监控）：
• 连接数使用率
• 缓冲池命中率
• 慢查询数量
• QPS/TPS

二级指标（重要监控）：
• 锁等待时间
• I/O统计
• 复制延迟
• 表空间使用率
```

**🔹 优化的基本原则**
```
优化顺序：
1. 先优化查询和索引（成本最低）
2. 再调整配置参数（风险可控）
3. 最后考虑硬件升级（成本最高）

性能与安全的平衡：
• 高性能配置可能降低数据安全性
• 需要根据业务需求合理权衡
• 关键业务优先保证数据安全
```

### 10.3 实际应用价值


**🎯 日常运维场景**
- **性能问题定位**：通过监控快速发现性能瓶颈
- **容量规划**：基于历史数据预测资源需求
- **故障预防**：通过告警机制提前发现潜在问题
- **优化决策**：基于性能数据制定优化策略

**🔧 实战建议**
```
建议的优化流程：
1. 建立完善的监控体系
2. 收集足够的性能基线数据  
3. 识别主要性能瓶颈点
4. 制定针对性优化方案
5. 逐步实施并验证效果
6. 持续监控和调整
```

**📊 成功标准**
```
性能优化目标：
• 响应时间：95%的查询在100ms内完成
• 缓冲池命中率：>99%
• 慢查询比例：<1%
• 连接数使用率：<70%
• 系统可用性：>99.9%
```

**核心记忆要点**：
- MySQL性能优化是一个持续过程，需要建立完善的监控体系
- 慢查询优化和索引设计是性能提升的关键点
- 合理的参数配置能显著提升数据库性能
- 监控告警是保障数据库稳定运行的重要手段
- 性能优化要遵循"先软件后硬件"的原则