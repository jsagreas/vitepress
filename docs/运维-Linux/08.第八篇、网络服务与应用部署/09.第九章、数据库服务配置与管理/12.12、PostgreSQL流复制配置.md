---
title: 12、PostgreSQL流复制配置
---
## 📚 目录

1. [流复制原理与架构模式](#1-流复制原理与架构模式)
2. [主服务器复制配置](#2-主服务器复制配置)
3. [备服务器配置与启动](#3-备服务器配置与启动)
4. [复制用户与认证设置](#4-复制用户与认证设置)
5. [同步模式与异步模式选择](#5-同步模式与异步模式选择)
6. [复制槽管理与监控](#6-复制槽管理与监控)
7. [备服务器提升与切换](#7-备服务器提升与切换)
8. [级联复制配置](#8-级联复制配置)
9. [复制故障处理与恢复](#9-复制故障处理与恢复)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔄 流复制原理与架构模式


### 1.1 什么是PostgreSQL流复制


**🔸 基本概念**
```
流复制（Streaming Replication）：
PostgreSQL的内置高可用解决方案，通过实时传输WAL日志
实现主备服务器数据同步的技术
```

**💡 通俗理解**
想象一下记账系统：主账本（主服务器）每写一笔账，立即把记录抄送给备份账本（备服务器）。这样即使主账本丢失，备份账本也有完整的记录。

**🎯 核心工作机制**
```
数据写入流程：
应用程序 → 主服务器 → 写入WAL日志 → 同时发送给备服务器 → 备服务器应用日志

关键特点：
• 基于WAL日志的实时传输
• 备服务器只读，不能写入
• 支持一主多备架构
• 可实现自动故障切换
```

### 1.2 流复制架构模式


**🏗️ 常见架构模式**

```
单主单备模式：
┌─────────────┐    WAL Stream    ┌─────────────┐
│ 主服务器     │ ──────────────> │ 备服务器     │
│ (Primary)   │                 │ (Standby)   │
│ 读写        │                 │ 只读        │
└─────────────┘                 └─────────────┘

一主多备模式：
                ┌─────────────┐
                │ 备服务器1    │
                │ (Standby1)  │
┌─────────────┐ └─────────────┘
│ 主服务器     │ 
│ (Primary)   │ ┌─────────────┐
│ 读写        │ │ 备服务器2    │
└─────────────┘ │ (Standby2)  │
                └─────────────┘

级联复制模式：
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│ 主服务器     │──>│ 备服务器1    │──>│ 备服务器2    │
│ (Primary)   │   │ (Standby1)  │   │ (Standby2)  │
└─────────────┘   └─────────────┘   └─────────────┘
```

**⚡ 架构选择指导**

| 模式类型 | **适用场景** | **优点** | **缺点** |
|---------|------------|---------|---------|
| 🔸 **单主单备** | `小型系统，简单高可用` | `配置简单，资源消耗小` | `读性能无法分担` |
| 🔸 **一主多备** | `读多写少，负载均衡` | `读性能可分担，高可用性` | `配置复杂，资源消耗大` |
| 🔸 **级联复制** | `跨地域备份，节省带宽` | `减少主服务器负载` | `延迟更大，故障点增加` |

### 1.3 WAL日志传输机制


**📦 WAL传输原理**
```
WAL（Write-Ahead Logging）工作流程：

步骤1：事务提交前，先写WAL日志
步骤2：WAL日志持久化到磁盘
步骤3：WAL日志通过网络发送给备服务器
步骤4：备服务器接收并应用WAL日志
步骤5：备服务器反馈应用状态给主服务器
```

**🔄 传输模式对比**
```
基于文件的传输（老方式）：
• 等WAL文件写满才传输（通常16MB）
• 延迟较大，可能丢失数据
• 配置相对简单

流式传输（推荐方式）：
• 实时传输WAL记录
• 延迟极小，数据安全性高
• 需要网络连接稳定
```

---

## 2. ⚙️ 主服务器复制配置


### 2.1 postgresql.conf核心参数配置


**🔧 基础复制参数**
```bash
# 编辑主服务器配置文件
sudo vim /etc/postgresql/14/main/postgresql.conf

# 关键配置参数：
wal_level = replica                    # WAL日志级别
max_wal_senders = 10                   # 最大WAL发送进程数
wal_keep_size = 1GB                    # 保留的WAL大小
hot_standby = on                       # 热备模式
archive_mode = on                      # 开启归档模式
archive_command = 'cp %p /var/lib/postgresql/archive/%f'
```

**💡 参数详解**

| 参数名称 | **含义** | **推荐值** | **说明** |
|---------|---------|-----------|---------|
| `wal_level` | `WAL日志详细程度` | `replica` | `包含备服务器需要的信息` |
| `max_wal_senders` | `最大发送进程数` | `备服务器数量+2` | `每个备服务器需要1个` |
| `wal_keep_size` | `保留WAL大小` | `1-2GB` | `网络中断时的缓冲` |
| `hot_standby` | `热备模式` | `on` | `备服务器可提供只读查询` |

**⚠️ 重要提醒**
```
注意事项：
• wal_level修改需要重启PostgreSQL
• max_wal_senders设置过小会导致连接失败
• wal_keep_size设置过小可能导致备服务器同步失败
• archive_command的目录必须存在且有写权限
```

### 2.2 监听地址和端口配置


**🌐 网络连接配置**
```bash
# 配置监听地址
listen_addresses = '*'                 # 监听所有IP地址
port = 5432                           # 默认端口

# 或者指定具体IP
listen_addresses = 'localhost,192.168.1.100'
```

**🔒 pg_hba.conf认证配置**
```bash
# 编辑认证配置文件
sudo vim /etc/postgresql/14/main/pg_hba.conf

# 添加复制连接规则
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     replica         192.168.1.0/24          md5
host    replication     replica         127.0.0.1/32            trust
```

**📝 认证规则解释**
```
规则格式说明：
• TYPE: 连接类型（host表示TCP/IP连接）
• DATABASE: replication表示复制连接
• USER: 复制用户名
• ADDRESS: 允许连接的IP地址范围
• METHOD: 认证方法（md5需要密码，trust不需要）
```

### 2.3 复制用户创建


**👤 创建专用复制用户**
```sql
-- 连接到主服务器
sudo -u postgres psql

-- 创建复制用户
CREATE USER replica WITH REPLICATION ENCRYPTED PASSWORD 'your_password';

-- 查看用户权限
\du replica
```

**🔑 权限说明**
```
REPLICATION权限特点：
• 只能用于流复制连接
• 不能访问普通数据库
• 不能执行常规SQL语句
• 专门用于WAL传输
```

---

## 3. 💾 备服务器配置与启动


### 3.1 基础数据备份


**📦 使用pg_basebackup创建基础备份**
```bash
# 在备服务器上执行
# 停止备服务器PostgreSQL服务
sudo systemctl stop postgresql

# 清空数据目录
sudo rm -rf /var/lib/postgresql/14/main/*

# 从主服务器创建基础备份
sudo -u postgres pg_basebackup \
    -h 192.168.1.100 \
    -U replica \
    -D /var/lib/postgresql/14/main \
    -W \
    -P \
    -R

# 参数说明：
# -h: 主服务器IP地址
# -U: 复制用户名
# -D: 备服务器数据目录
# -W: 提示输入密码
# -P: 显示进度
# -R: 自动创建standby.signal和配置复制参数
```

**⏱️ 备份过程监控**
```bash
# 备份过程会显示类似信息：
# pg_basebackup: initiating base backup, waiting for checkpoint to complete
# pg_basebackup: checkpoint completed
# pg_basebackup: write-ahead log start point: 0/2000000 on timeline 1
# pg_basebackup: starting background WAL receiver
# 24286/24286 kB (100%), 1/1 tablespace
# pg_basebackup: write-ahead log end point: 0/2000168
# pg_basebackup: waiting for background process to finish streaming...
# pg_basebackup: syncing data to disk...
# pg_basebackup: base backup completed
```

### 3.2 备服务器配置文件调整


**🔧 postgresql.conf参数调整**
```bash
# 编辑备服务器配置
sudo vim /var/lib/postgresql/14/main/postgresql.conf

# 备服务器专用配置
hot_standby = on                       # 允许只读查询
max_standby_streaming_delay = 30s      # 流复制最大延迟
hot_standby_feedback = on              # 向主服务器反馈查询冲突
```

**🔄 recovery.conf设置（PostgreSQL 12+使用postgresql.conf）**
```bash
# PostgreSQL 12+版本在postgresql.conf中配置
primary_conninfo = 'host=192.168.1.100 port=5432 user=replica password=your_password'
```

**📁 standby.signal文件**
```bash
# pg_basebackup -R 会自动创建这个文件
# 手动创建（如果需要）
sudo -u postgres touch /var/lib/postgresql/14/main/standby.signal
```

### 3.3 启动备服务器


**🚀 启动流程**
```bash
# 启动PostgreSQL服务
sudo systemctl start postgresql

# 检查服务状态
sudo systemctl status postgresql

# 查看日志确认复制状态
sudo tail -f /var/log/postgresql/postgresql-14-main.log
```

**✅ 验证复制连接**
```bash
# 在备服务器上检查复制状态
sudo -u postgres psql -c "SELECT pg_is_in_recovery();"
# 应该返回 t (true)

# 在主服务器上检查连接状态
sudo -u postgres psql -c "SELECT * FROM pg_stat_replication;"
```

---

## 4. 🔐 复制用户与认证设置


### 4.1 复制用户权限管理


**👤 复制用户最佳实践**
```sql
-- 创建复制用户的完整配置
CREATE USER replica WITH 
    REPLICATION 
    ENCRYPTED PASSWORD 'StrongPassword123!'
    CONNECTION LIMIT 5;

-- 查看复制用户信息
SELECT rolname, rolreplication, rolconnlimit 
FROM pg_roles 
WHERE rolname = 'replica';
```

**🔒 密码安全策略**
```bash
# 使用.pgpass文件避免明文密码
echo "192.168.1.100:5432:replication:replica:StrongPassword123!" >> ~/.pgpass
chmod 600 ~/.pgpass

# 在primary_conninfo中可以省略密码
primary_conninfo = 'host=192.168.1.100 port=5432 user=replica'
```

### 4.2 SSL加密连接配置


**🔐 启用SSL复制连接**
```bash
# 在主服务器postgresql.conf中
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
ssl_ca_file = 'ca.crt'

# 在备服务器的连接字符串中
primary_conninfo = 'host=192.168.1.100 port=5432 user=replica sslmode=require'
```

**📋 SSL模式选择**

| SSL模式 | **安全级别** | **验证证书** | **适用场景** |
|---------|-------------|-------------|-------------|
| `disable` | `无加密` | `否` | `内网环境，性能优先` |
| `require` | `加密传输` | `否` | `基本安全要求` |
| `verify-ca` | `加密+验证CA` | `是` | `高安全要求` |
| `verify-full` | `加密+验证主机名` | `是` | `最高安全级别` |

### 4.3 防火墙和网络配置


**🔥 防火墙规则配置**
```bash
# 在主服务器上开放PostgreSQL端口
sudo ufw allow from 192.168.1.0/24 to any port 5432

# 或者使用iptables
sudo iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 5432 -j ACCEPT
```

**🌐 网络连接测试**
```bash
# 从备服务器测试主服务器连接
telnet 192.168.1.100 5432

# 测试复制用户连接
psql -h 192.168.1.100 -U replica -d postgres -c "SELECT version();"
```

---

## 5. ⚖️ 同步模式与异步模式选择


### 5.1 复制模式对比


**🔄 异步复制（默认模式）**
```
工作原理：
主服务器 → 提交事务 → 立即返回成功 → 异步发送WAL → 备服务器

特点：
✅ 性能最高，延迟最小
✅ 主服务器不等待备服务器确认
❌ 可能丢失最新的几个事务
❌ 数据一致性较弱
```

**🔒 同步复制模式**
```
工作原理：
主服务器 → 提交事务 → 等待备服务器确认 → 返回成功

特点：
✅ 数据一致性强，不会丢失事务
✅ 故障切换后数据完整
❌ 性能较低，延迟较大
❌ 备服务器故障影响主服务器
```

### 5.2 同步复制配置


**🔧 启用同步复制**
```bash
# 在主服务器postgresql.conf中配置
synchronous_standby_names = 'standby1'        # 指定同步备服务器
synchronous_commit = on                       # 启用同步提交

# 重启PostgreSQL使配置生效
sudo systemctl restart postgresql
```

**📝 application_name配置**
```bash
# 在备服务器的连接字符串中指定应用名
primary_conninfo = 'host=192.168.1.100 port=5432 user=replica application_name=standby1'
```

### 5.3 混合模式配置


**⚖️ 多备服务器的同步策略**
```bash
# 配置多个备服务器，部分同步，部分异步
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'

# 解释：
# FIRST 1: 至少1个备服务器同步确认
# (standby1, standby2): 候选同步备服务器列表
# standby3如果存在，将是异步复制
```

**📊 性能影响分析**
```
性能测试对比（示例数据）：
异步模式：1000 TPS（事务/秒）
同步模式：600 TPS
混合模式：800 TPS

延迟对比：
异步模式：< 1ms
同步模式：10-50ms（取决于网络）
混合模式：5-20ms
```

---

## 6. 📊 复制槽管理与监控


### 6.1 复制槽基本概念


**🎯 什么是复制槽**
```
复制槽（Replication Slot）：
一种确保主服务器保留足够WAL日志的机制，
防止备服务器离线时WAL被过早清理
```

**💡 复制槽的作用**
```
问题场景：
备服务器网络中断 → 主服务器继续写入 → WAL日志被清理 
→ 备服务器恢复后无法同步 → 需要重新做基础备份

复制槽解决方案：
主服务器保留WAL日志 → 直到备服务器确认接收 → 避免重新备份
```

### 6.2 创建和管理复制槽


**🔧 创建复制槽**
```sql
-- 在主服务器上创建复制槽
SELECT pg_create_physical_replication_slot('slot_standby1');

-- 查看所有复制槽
SELECT * FROM pg_replication_slots;

-- 查看复制槽详细信息
\x on
SELECT * FROM pg_replication_slots WHERE slot_name = 'slot_standby1';
```

**📋 复制槽信息解读**
```sql
-- 重要字段说明：
slot_name          # 槽名称
slot_type          # 槽类型（physical/logical）
active             # 是否活跃
restart_lsn        # 重启LSN位置
confirmed_flush_lsn # 确认刷新LSN位置
```

### 6.3 复制槽监控


**📊 监控复制延迟**
```sql
-- 监控复制状态和延迟
SELECT 
    client_addr,
    application_name,
    state,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn,
    pg_size_pretty(pg_wal_lsn_diff(sent_lsn, replay_lsn)) AS replay_delay
FROM pg_stat_replication;
```

**⚠️ 复制槽空间监控**
```sql
-- 检查WAL积压情况
SELECT 
    slot_name,
    pg_size_pretty(
        pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)
    ) AS retained_wal
FROM pg_replication_slots
WHERE active = false;
```

**🚨 告警阈值设置**
```bash
# 创建监控脚本
cat > /usr/local/bin/check_replication.sh << 'EOF'
#!/bin/bash
DELAY=$(sudo -u postgres psql -t -c "
SELECT COALESCE(
    EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())), 
    0
);" 2>/dev/null)

if (( $(echo "$DELAY > 300" | bc -l) )); then
    echo "WARNING: Replication delay is ${DELAY}s"
    exit 1
fi
EOF

chmod +x /usr/local/bin/check_replication.sh
```

---

## 7. 🔄 备服务器提升与切换


### 7.1 手动故障切换


**🚨 主服务器故障处理流程**
```
故障切换步骤：
步骤1：确认主服务器真正故障
步骤2：选择要提升的备服务器
步骤3：提升备服务器为主服务器
步骤4：更新应用连接配置
步骤5：处理其他备服务器
```

**⚡ 提升备服务器**
```bash
# 方法1：使用pg_promote函数
sudo -u postgres psql -c "SELECT pg_promote();"

# 方法2：删除standby.signal文件
sudo rm /var/lib/postgresql/14/main/standby.signal
sudo systemctl restart postgresql

# 方法3：使用pg_ctl命令
sudo -u postgres pg_ctl promote -D /var/lib/postgresql/14/main
```

### 7.2 计划内切换


**📅 计划维护切换流程**
```bash
# 步骤1：确保备服务器同步完成
sudo -u postgres psql -c "
SELECT pg_wal_lsn_diff(
    pg_current_wal_lsn(), 
    pg_last_wal_replay_lsn()
) AS lag_bytes;"

# 步骤2：停止主服务器应用连接
# 修改pg_hba.conf拒绝应用连接

# 步骤3：等待备服务器追上
# 重复检查lag_bytes直到为0

# 步骤4：优雅关闭主服务器
sudo systemctl stop postgresql

# 步骤5：提升备服务器
sudo -u postgres pg_ctl promote -D /var/lib/postgresql/14/main
```

### 7.3 切换后配置调整


**🔧 新主服务器配置**
```bash
# 移除备服务器相关配置
sudo vim /var/lib/postgresql/14/main/postgresql.conf

# 注释或删除以下行：
# primary_conninfo = '...'
# recovery_target_timeline = 'latest'

# 重启服务
sudo systemctl restart postgresql
```

**🔄 重建复制关系**
```bash
# 将原主服务器作为新的备服务器
# 1. 在原主服务器上创建基础备份
sudo -u postgres pg_basebackup \
    -h NEW_PRIMARY_IP \
    -U replica \
    -D /var/lib/postgresql/14/main \
    -W -P -R

# 2. 启动原主服务器作为备服务器
sudo systemctl start postgresql
```

---

## 8. 🔗 级联复制配置


### 8.1 级联复制架构设计


**🏗️ 级联复制拓扑**
```
典型级联架构：
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│  主服务器    │──>│  备服务器1   │──>│  备服务器2   │
│ (Primary)   │   │(Standby1)   │   │(Standby2)   │
│  写入       │   │  中继       │   │  只读       │
└─────────────┘   └─────────────┘   └─────────────┘

地理分布示例：
北京主机房 ────> 上海机房 ────> 深圳机房
```

**🎯 级联复制优势**
```
带宽节省：
• 主服务器只需向一个备服务器发送数据
• 减少跨地域网络流量成本
• 适合多地域部署

负载分担：
• 主服务器WAL发送负载减轻
• 中继服务器承担部分转发工作
• 提高整体系统稳定性
```

### 8.2 中继服务器配置


**⚙️ 备服务器1（中继）配置**
```bash
# postgresql.conf 配置
hot_standby = on                        # 允许只读查询
max_wal_senders = 5                     # 允许向下级发送WAL
wal_level = replica                     # 确保WAL级别正确

# 连接上级主服务器
primary_conninfo = 'host=primary_server port=5432 user=replica'
```

**📡 启用WAL转发功能**
```bash
# 确保中继服务器可以向下级发送WAL
# 在pg_hba.conf中添加
host replication replica 192.168.1.0/24 md5
```

### 8.3 末级备服务器配置


**🔧 备服务器2配置**
```bash
# 连接中继服务器而非主服务器
primary_conninfo = 'host=standby1_server port=5432 user=replica'

# 其他配置与普通备服务器相同
hot_standby = on
hot_standby_feedback = on
```

**✅ 验证级联复制**
```sql
-- 在主服务器上查看复制状态
SELECT application_name, client_addr, state 
FROM pg_stat_replication;

-- 在中继服务器上查看
SELECT application_name, client_addr, state 
FROM pg_stat_replication;
```

---

## 9. 🔧 复制故障处理与恢复


### 9.1 常见故障类型


**🚨 网络连接故障**
```
故障现象：
• 备服务器日志显示连接错误
• pg_stat_replication中看不到备服务器
• 备服务器停止接收WAL更新

诊断方法：
# 测试网络连接
telnet primary_server 5432

# 检查防火墙
sudo ufw status
sudo iptables -L
```

**💾 磁盘空间不足**
```
故障现象：
• WAL日志堆积，磁盘空间用完
• 主服务器无法写入新的WAL
• 备服务器无法接收数据

解决方法：
# 清理旧的WAL文件（谨慎操作）
sudo -u postgres pg_archivecleanup /var/lib/postgresql/archive/ 000000010000000000000010

# 增加磁盘空间
# 调整wal_keep_size参数
```

### 9.2 复制中断恢复


**🔄 重新建立复制连接**
```bash
# 方法1：重启备服务器PostgreSQL
sudo systemctl restart postgresql

# 方法2：检查并修复配置
sudo vim /var/lib/postgresql/14/main/postgresql.conf
# 确保primary_conninfo配置正确

# 方法3：如果WAL丢失，重新做基础备份
sudo systemctl stop postgresql
sudo rm -rf /var/lib/postgresql/14/main/*
sudo -u postgres pg_basebackup -h primary -U replica -D /var/lib/postgresql/14/main -W -P -R
sudo systemctl start postgresql
```

### 9.3 数据一致性检查


**🔍 同步状态验证**
```sql
-- 在主服务器上检查当前LSN
SELECT pg_current_wal_lsn();

-- 在备服务器上检查最后应用的LSN
SELECT pg_last_wal_replay_lsn();

-- 计算延迟
SELECT pg_wal_lsn_diff(
    pg_current_wal_lsn(), 
    pg_last_wal_replay_lsn()
) AS lag_bytes;
```

**📊 自动化监控脚本**
```bash
cat > /usr/local/bin/replication_health.sh << 'EOF'
#!/bin/bash

# 检查复制状态
REPLICATION_STATUS=$(sudo -u postgres psql -t -c "
SELECT count(*) FROM pg_stat_replication;" 2>/dev/null)

if [ "$REPLICATION_STATUS" -eq 0 ]; then
    echo "ERROR: No standby servers connected"
    exit 1
fi

# 检查复制延迟
MAX_LAG=$(sudo -u postgres psql -t -c "
SELECT COALESCE(max(
    EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp()))
), 0) FROM pg_stat_replication;" 2>/dev/null)

if (( $(echo "$MAX_LAG > 300" | bc -l) )); then
    echo "WARNING: Max replication lag is ${MAX_LAG}s"
    exit 1
fi

echo "OK: Replication is healthy"
EOF

chmod +x /usr/local/bin/replication_health.sh

# 添加到crontab定期检查
echo "*/5 * * * * /usr/local/bin/replication_health.sh" | sudo crontab -
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 流复制本质：基于WAL日志的实时数据同步技术
🔸 架构模式：单主单备、一主多备、级联复制三种模式
🔸 配置要点：wal_level、max_wal_senders、复制用户、认证设置
🔸 模式选择：异步模式性能高，同步模式一致性强
🔸 故障切换：手动提升备服务器，重建复制关系
🔸 监控要点：复制延迟、连接状态、WAL堆积情况
```

### 10.2 关键配置检查清单


**✅ 主服务器配置验证**
```
□ wal_level = replica
□ max_wal_senders >= 备服务器数量 + 2
□ 复制用户创建且有REPLICATION权限
□ pg_hba.conf允许复制连接
□ 防火墙开放5432端口
□ listen_addresses包含备服务器可访问的地址
```

**✅ 备服务器配置验证**
```
□ standby.signal文件存在
□ primary_conninfo配置正确
□ hot_standby = on
□ 数据目录从主服务器同步
□ PostgreSQL服务正常启动
□ pg_is_in_recovery()返回true
```

### 10.3 运维最佳实践


**🔧 日常维护要点**
```
监控项目：
• 复制连接状态：pg_stat_replication
• 复制延迟：pg_wal_lsn_diff计算
• 磁盘空间：WAL目录和数据目录
• 网络连接：主备服务器间网络状态

定期任务：
• 备份验证：定期测试备服务器数据完整性
• 故障演练：模拟故障切换流程
• 性能监控：记录复制延迟和吞吐量
• 配置审核：检查配置文件一致性
```

**⚠️ 安全注意事项**
```
网络安全：
• 使用SSL加密复制连接
• 限制复制用户权限
• 防火墙规则最小化原则
• 定期更换复制用户密码

数据安全：
• 定期验证备份完整性
• 监控未授权连接尝试
• 记录复制相关操作日志
• 建立灾难恢复预案
```

**核心记忆要点**：
- **流复制原理**：WAL日志实时传输，备服务器持续应用
- **配置核心**：wal_level + max_wal_senders + 复制用户 + 认证
- **模式选择**：异步求性能，同步求一致，混合求平衡
- **故障处理**：监控先行，快速切换，及时恢复
- **运维关键**：定期监控 + 故障演练 + 配置管理