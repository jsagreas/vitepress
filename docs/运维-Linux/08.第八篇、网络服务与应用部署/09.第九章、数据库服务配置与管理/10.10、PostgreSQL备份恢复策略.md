---
title: 10、PostgreSQL备份恢复策略
---
## 📚 目录

1. [PostgreSQL备份策略概述](#1-PostgreSQL备份策略概述)
2. [逻辑备份（pg_dump/pg_dumpall）](#2-逻辑备份)
3. [物理备份与基础备份](#3-物理备份与基础备份)
4. [WAL归档与连续归档备份](#4-WAL归档与连续归档备份)
5. [时间点恢复PITR配置](#5-时间点恢复PITR配置)
6. [定时备份脚本与自动化](#6-定时备份脚本与自动化)
7. [备份验证与一致性检查](#7-备份验证与一致性检查)
8. [故障恢复流程与实践](#8-故障恢复流程与实践)
9. [表空间备份与恢复](#9-表空间备份与恢复)
10. [热备份与在线备份](#10-热备份与在线备份)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔄 PostgreSQL备份策略概述


### 1.1 备份的重要性


**💡 为什么需要备份**
备份就像给珍贵数据买保险，当硬件故障、误操作、恶意攻击等意外发生时，备份是唯一能让你挽回损失的手段。没有备份的数据库就像走钢丝没有安全网，风险极大。

### 1.2 备份类型对比


| 备份类型 | **本质** | **特点** | **适用场景** |
|---------|---------|----------|-------------|
| **逻辑备份** | `导出SQL语句` | 可读性强，跨版本兼容 | 数据迁移、开发测试 |
| **物理备份** | `复制数据文件` | 速度快，完整性高 | 生产环境、大数据量 |

### 1.3 备份策略架构图


```
PostgreSQL备份体系架构：

┌─────────────────────────────────────────┐
│              数据库实例                   │
├─────────────────────────────────────────┤
│  数据文件 │  WAL日志 │  配置文件        │
└─────┬───────────┬───────────┬───────────┘
      │           │           │
      ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│物理备份  │ │WAL归档  │ │逻辑备份  │
│(pg_base │ │(wal_e   │ │(pg_dump)│
│backup)  │ │archive) │ │         │
└─────────┘ └─────────┘ └─────────┘
      │           │           │
      └───────────┼───────────┘
                  ▼
        ┌─────────────────┐
        │   备份存储       │
        │  - 本地存储     │
        │  - 网络存储     │
        │  - 云端存储     │
        └─────────────────┘
```

---

## 2. 💾 逻辑备份（pg_dump/pg_dumpall）


### 2.1 什么是逻辑备份


**🔸 逻辑备份的本质**
逻辑备份就是把数据库中的数据转换成SQL语句保存起来。就像把一本书的内容重新抄写一遍，虽然字迹可能不同，但内容完全一样。

```
原理示意：
数据库表 → 读取数据 → 生成INSERT语句 → 保存到文件

示例：
表中数据：id=1, name='张三'
生成SQL：INSERT INTO users (id, name) VALUES (1, '张三');
```

### 2.2 pg_dump单库备份


**🛠️ 基本用法**
```bash
# 最简单的备份命令
pg_dump -U postgres -h localhost -d mydb > backup.sql

# 完整参数示例
pg_dump -U postgres -h localhost -p 5432 \
        -d mydb -f backup.sql \
        --verbose --no-password
```

**📋 常用参数说明**
- `-U` - 指定用户名（必须有权限访问数据库）
- `-h` - 数据库服务器地址
- `-p` - 端口号（默认5432）
- `-d` - 要备份的数据库名
- `-f` - 输出文件名
- `--verbose` - 显示详细过程信息

### 2.3 pg_dumpall全实例备份


**🔸 什么时候用pg_dumpall**
当你需要备份整个PostgreSQL实例（包括所有数据库、用户、权限等）时使用，相当于把整个数据库系统完整复制一份。

```bash
# 备份整个实例
pg_dumpall -U postgres -h localhost > full_backup.sql

# 只备份全局对象（用户、角色、表空间等）
pg_dumpall -U postgres -h localhost --globals-only > globals.sql
```

### 2.4 备份格式选择


| 格式类型 | **说明** | **恢复方式** | **优缺点** |
|----------|----------|-------------|-----------|
| **纯文本** | `默认格式，SQL语句` | `psql < backup.sql` | 可读性强，文件较大 |
| **自定义** | `压缩二进制格式` | `pg_restore backup.dump` | 文件小，恢复灵活 |
| **目录** | `每个表单独文件` | `pg_restore -d db backup_dir` | 并行恢复，便于管理 |

```bash
# 自定义格式备份（推荐）
pg_dump -U postgres -d mydb -Fc -f backup.dump

# 目录格式备份
pg_dump -U postgres -d mydb -Fd -f backup_dir/

# 压缩文本格式
pg_dump -U postgres -d mydb -Z9 -f backup.sql.gz
```

---

## 3. 🗃️ 物理备份与基础备份


### 3.1 物理备份原理


**🔸 什么是物理备份**
物理备份就是直接复制数据库的数据文件，就像复制照片原件一样，连文件的每个字节都完全相同。这种方式速度快，但需要数据库处于一致状态。

```
物理备份过程：
1. 通知数据库开始备份
2. 复制所有数据文件
3. 记录开始和结束的WAL位置
4. 创建备份标识文件

文件结构：
data/
├── base/          ← 数据文件目录
├── pg_wal/        ← WAL日志目录  
├── pg_tblspc/     ← 表空间链接
└── backup_label   ← 备份标识文件
```

### 3.2 pg_basebackup工具


**🛠️ 基础用法**
```bash
# 基本备份命令
pg_basebackup -U postgres -h localhost -D /backup/base -Ft

# 完整参数示例
pg_basebackup -U postgres -h localhost -p 5432 \
               -D /backup/base_20231201 \
               -Ft -z -P -v -W
```

**📋 重要参数解释**
- `-D` - 备份目录路径
- `-Ft` - tar格式输出（便于传输）
- `-z` - 压缩备份文件
- `-P` - 显示进度信息
- `-v` - 详细输出
- `-W` - 强制输入密码

### 3.3 在线物理备份


**⚡ 在线备份的原理**
在线备份就是在数据库正常运行时进行备份，不需要停止服务。PostgreSQL通过WAL日志保证备份的一致性。

```bash
# 标准在线备份流程
pg_basebackup -U replicator -h localhost \
               -D /backup/online_backup \
               -Ft -z -P \
               --wal-method=stream
```

**🔸 备份一致性保证**
```
备份过程中的数据一致性：

时间轴：  T1────────T2────────T3
         开始备份   修改数据   完成备份
         
WAL记录： [开始标记]→[数据变更]→[结束标记]

恢复时：基础备份 + WAL重放 = 一致状态
```

---

## 4. 📝 WAL归档与连续归档备份


### 4.1 WAL是什么


**🔸 WAL的通俗解释**
WAL（Write-Ahead Logging）就像数据库的"记账本"，任何对数据的修改都会先写入这个记账本，然后才写入真正的数据文件。这样即使数据文件损坏，也可以通过记账本恢复数据。

```
WAL工作原理：

用户操作：UPDATE users SET name='李四' WHERE id=1;

1. 先写WAL：记录"将用户1的姓名改为李四"
2. 再写数据：实际修改数据文件
3. 定期清理：旧的WAL文件被回收

WAL文件命名：000000010000000000000001
            ↑        ↑           ↑
         时间线    段号       文件号
```

### 4.2 配置WAL归档


**🔧 postgresql.conf配置**
```bash
# 开启WAL归档
wal_level = replica              # 设置WAL级别
archive_mode = on                # 开启归档模式
archive_command = 'test ! -f /backup/wal/%f && cp %p /backup/wal/%f'

# 可选优化配置
max_wal_size = 1GB              # WAL最大大小
min_wal_size = 80MB             # WAL最小大小
checkpoint_completion_target = 0.9  # 检查点完成目标
```

**📁 创建归档目录**
```bash
# 创建WAL归档目录
sudo mkdir -p /backup/wal
sudo chown postgres:postgres /backup/wal
sudo chmod 700 /backup/wal

# 重启PostgreSQL使配置生效
sudo systemctl restart postgresql
```

### 4.3 WAL归档验证


**✅ 检查归档是否正常**
```bash
# 查看当前WAL文件
sudo -u postgres psql -c "SELECT pg_current_wal_lsn();"

# 手动切换WAL文件测试归档
sudo -u postgres psql -c "SELECT pg_switch_wal();"

# 检查归档目录
ls -la /backup/wal/
```

**🔍 归档状态监控**
```sql
-- 查看归档统计信息
SELECT * FROM pg_stat_archiver;

-- 查看当前WAL状态
SELECT 
    pg_current_wal_lsn() as current_wal,
    pg_current_wal_insert_lsn() as insert_wal;
```

---

## 5. 🕐 时间点恢复PITR配置


### 5.1 PITR是什么


**🔸 时间点恢复的概念**
PITR（Point-In-Time Recovery）就像时光机器，能让数据库回到过去任意时刻的状态。比如发现下午3点有人误删了重要数据，可以将数据库恢复到下午2:59分的状态。

```
PITR恢复原理：

基础备份    +    WAL归档    =    任意时间点
  ↓               ↓               ↓
12:00的         12:01-15:00     14:30恢复点
完整快照          所有变更         指定时刻
```

### 5.2 PITR恢复配置


**📁 恢复环境准备**
```bash
# 停止PostgreSQL服务
sudo systemctl stop postgresql

# 清空数据目录（备份原数据）
sudo mv /var/lib/postgresql/14/main /var/lib/postgresql/14/main.backup
sudo mkdir /var/lib/postgresql/14/main
sudo chown postgres:postgres /var/lib/postgresql/14/main
```

**🔧 恢复配置文件**
```bash
# 创建恢复配置文件 recovery.conf
cat > /var/lib/postgresql/14/main/postgresql.auto.conf << EOF
# PITR恢复配置
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2023-12-01 14:30:00'
recovery_target_action = 'promote'
EOF
```

### 5.3 执行PITR恢复


**⚡ 恢复步骤**
```bash
# 1. 恢复基础备份
sudo -u postgres tar -xf /backup/base_backup.tar -C /var/lib/postgresql/14/main/

# 2. 创建恢复信号文件
sudo -u postgres touch /var/lib/postgresql/14/main/recovery.signal

# 3. 启动PostgreSQL开始恢复
sudo systemctl start postgresql

# 4. 监控恢复进度
sudo -u postgres tail -f /var/log/postgresql/postgresql-14-main.log
```

**🔍 恢复时间点选项**
| 恢复目标 | **配置参数** | **说明** |
|----------|-------------|----------|
| **时间点** | `recovery_target_time = '2023-12-01 14:30:00'` | 恢复到指定时间 |
| **事务ID** | `recovery_target_xid = '12345'` | 恢复到指定事务 |
| **WAL位置** | `recovery_target_lsn = '0/14000140'` | 恢复到指定LSN |
| **完全恢复** | `不设置target参数` | 恢复到最新状态 |

---

## 6. ⏰ 定时备份脚本与自动化


### 6.1 备份脚本设计


**📜 完整备份脚本示例**
```bash
#!/bin/bash
# PostgreSQL自动备份脚本

# 配置变量
DB_USER="postgres"
DB_HOST="localhost"
DB_PORT="5432"
BACKUP_DIR="/backup/postgresql"
LOG_FILE="/var/log/pg_backup.log"
RETENTION_DAYS=7

# 创建备份目录
mkdir -p $BACKUP_DIR/logical
mkdir -p $BACKUP_DIR/physical

# 记录开始时间
echo "$(date): 开始备份" >> $LOG_FILE

# 逻辑备份（所有数据库）
pg_dumpall -U $DB_USER -h $DB_HOST -p $DB_PORT \
    -f $BACKUP_DIR/logical/full_$(date +%Y%m%d_%H%M%S).sql
echo "$(date): 逻辑备份完成" >> $LOG_FILE

# 物理备份
pg_basebackup -U $DB_USER -h $DB_HOST -p $DB_PORT \
    -D $BACKUP_DIR/physical/base_$(date +%Y%m%d_%H%M%S) \
    -Ft -z -P
echo "$(date): 物理备份完成" >> $LOG_FILE

# 清理过期备份
find $BACKUP_DIR -type f -mtime +$RETENTION_DAYS -delete
echo "$(date): 清理过期备份完成" >> $LOG_FILE
```

### 6.2 定时任务配置


**⏱️ Cron定时设置**
```bash
# 编辑crontab
crontab -e

# 每天凌晨2点执行完整备份
0 2 * * * /scripts/pg_backup.sh >> /var/log/pg_backup.log 2>&1

# 每4小时执行增量WAL备份检查
0 */4 * * * /scripts/wal_check.sh

# 每周日执行备份验证
0 3 * * 0 /scripts/backup_verify.sh
```

### 6.3 备份策略配置


**📊 备份策略矩阵**
```
备份频率规划：

┌─────────────┬─────────────┬─────────────┐
│    时间     │   备份类型   │   保留期限   │
├─────────────┼─────────────┼─────────────┤
│   每天2点    │   完整备份   │    7天      │
│   每4小时    │   WAL归档   │    30天     │
│   每周日     │   验证测试   │    -        │
│   每月1号    │   长期存档   │    12个月   │
└─────────────┴─────────────┴─────────────┘
```

---

## 7. ✅ 备份验证与一致性检查


### 7.1 为什么要验证备份


**⚠️ 备份验证的重要性**
未经验证的备份就像未经测试的降落伞，关键时刻可能失效。备份验证能确保：
- 备份文件完整性
- 数据一致性
- 恢复过程可行性

### 7.2 逻辑备份验证


**🔍 验证脚本示例**
```bash
#!/bin/bash
# 逻辑备份验证脚本

BACKUP_FILE="/backup/logical/full_20231201.sql"
TEST_DB="test_restore"

# 创建测试数据库
sudo -u postgres createdb $TEST_DB

# 恢复备份到测试库
sudo -u postgres psql -d $TEST_DB -f $BACKUP_FILE

if [ $? -eq 0 ]; then
    echo "备份验证成功：$BACKUP_FILE"
    # 检查数据完整性
    sudo -u postgres psql -d $TEST_DB -c "\dt"
else
    echo "备份验证失败：$BACKUP_FILE"
fi

# 清理测试数据库
sudo -u postgres dropdb $TEST_DB
```

### 7.3 物理备份验证


**🛠️ 物理备份完整性检查**
```bash
# 检查备份文件完整性
pg_verify_checksums -D /backup/physical/base_20231201/

# 使用pg_resetwal检查WAL状态
pg_resetwal -n /backup/physical/base_20231201/

# 验证备份可启动性（使用测试端口）
postgres -D /backup/physical/base_20231201/ -p 5433 --check
```

### 7.4 数据一致性检查


**📋 一致性检查清单**
- [ ] **文件完整性** - 所有备份文件存在且可读
- [ ] **数据完整性** - 关键表记录数量正确
- [ ] **索引一致性** - 索引与数据匹配
- [ ] **约束检查** - 外键、唯一约束有效
- [ ] **权限验证** - 用户角色权限正确

```sql
-- 数据一致性检查SQL
-- 检查表记录数量
SELECT 
    schemaname,
    tablename,
    n_tup_ins as inserts,
    n_tup_upd as updates,
    n_tup_del as deletes
FROM pg_stat_user_tables
ORDER BY schemaname, tablename;

-- 检查索引状态
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0;  -- 未使用的索引
```

---

## 8. 🚨 故障恢复流程与实践


### 8.1 故障分类与对策


**🔸 常见故障类型**
```
故障分类决策树：

数据库故障
├── 硬件故障
│   ├── 磁盘损坏 → 物理备份恢复
│   └── 内存故障 → 重启+检查点恢复
├── 软件故障  
│   ├── 进程崩溃 → 自动恢复+WAL重放
│   └── 配置错误 → 修正配置+重启
└── 人为错误
    ├── 误删数据 → PITR时间点恢复
    └── 误删库表 → 逻辑备份恢复
```

### 8.2 故障恢复标准流程


**📋 恢复操作检查表**
```
阶段1：故障评估 (5-10分钟)
□ 确认故障类型和影响范围
□ 检查系统日志和错误信息  
□ 评估数据丢失程度
□ 选择合适的恢复策略

阶段2：准备恢复 (10-20分钟)
□ 停止应用连接
□ 备份当前状态（如可能）
□ 准备恢复环境
□ 验证备份文件可用性

阶段3：执行恢复 (根据数据量)
□ 按选定策略执行恢复
□ 监控恢复进度
□ 处理恢复过程中的异常
□ 验证恢复结果

阶段4：服务恢复 (10-30分钟)
□ 检查数据完整性
□ 重建索引和统计信息
□ 恢复应用连接
□ 验证业务功能正常
```

### 8.3 典型故障恢复案例


**💡 案例1：误删表数据恢复**
```bash
# 场景：下午3:15误删了users表数据

# 1. 立即停止应用写入
sudo systemctl stop myapp

# 2. 执行PITR恢复到3:10
sudo systemctl stop postgresql
sudo mv /var/lib/postgresql/14/main /var/lib/postgresql/14/main.damaged

# 3. 恢复基础备份
sudo -u postgres tar -xf /backup/base_backup_morning.tar \
    -C /var/lib/postgresql/14/main/

# 4. 配置恢复目标时间
echo "recovery_target_time = '2023-12-01 15:10:00'" >> \
    /var/lib/postgresql/14/main/postgresql.auto.conf

# 5. 启动恢复
sudo -u postgres touch /var/lib/postgresql/14/main/recovery.signal
sudo systemctl start postgresql
```

### 8.4 恢复时间优化


**⚡ 缩短恢复时间的方法**
| 优化方向 | **具体措施** | **效果** |
|----------|-------------|----------|
| **备份频率** | 增加基础备份频率 | 减少WAL重放时间 |
| **存储优化** | 使用SSD存储备份 | 提升IO性能 |
| **并行恢复** | 并行恢复多个表空间 | 缩短总恢复时间 |
| **网络优化** | 本地存储备份文件 | 避免网络传输延迟 |

---

## 9. 🗂️ 表空间备份与恢复


### 9.1 表空间概念


**🔸 什么是表空间**
表空间就像数据库的"分区存储"，可以把不同的表和索引存储在不同的磁盘位置。就像把不同类型的文件放在不同的文件夹里，便于管理和性能优化。

```
表空间布局示例：

/var/lib/postgresql/14/main/     ← 默认表空间
├── base/                        ← 系统数据库
└── pg_tblspc/                   ← 表空间链接目录
    ├── 16384 → /data/fast_ssd/  ← 高性能表空间
    └── 16385 → /data/archive/   ← 归档表空间

业务数据分布：
- 活跃表 → fast_ssd表空间 (高性能SSD)
- 历史表 → archive表空间 (便宜大容量)
```

### 9.2 表空间备份策略


**📁 表空间备份配置**
```sql
-- 查看当前表空间
SELECT spcname, pg_tablespace_location(oid) as location 
FROM pg_tablespace;

-- 创建表空间（示例）
CREATE TABLESPACE fast_data 
LOCATION '/data/fast_ssd/postgresql';
```

**🛠️ 包含表空间的备份**
```bash
# pg_basebackup自动处理表空间
pg_basebackup -U postgres -h localhost \
               -D /backup/full_with_tablespaces \
               -Ft -z --tablespace-mapping=/data/fast_ssd/postgresql=/backup/fast_ssd

# 逻辑备份包含表空间定义
pg_dumpall -U postgres --tablespaces-only > tablespaces.sql
```

### 9.3 表空间恢复注意事项


**⚠️ 恢复时的关键点**
- **路径映射**：表空间路径可能需要重新映射
- **权限设置**：确保postgres用户有目录权限
- **磁盘空间**：目标位置要有足够空间
- **符号链接**：恢复后检查链接是否正确

```bash
# 恢复时重新映射表空间路径
pg_basebackup -U postgres -h localhost \
               -D /restore/main \
               --tablespace-mapping=/old/path=/new/path
```

---

## 10. 🔥 热备份与在线备份


### 10.1 热备份原理


**🔸 什么是热备份**
热备份就是在数据库正常运行、用户正常使用的情况下进行备份，就像给行驶中的汽车换轮胎一样。PostgreSQL通过WAL机制保证热备份的数据一致性。

```
热备份过程示意：

用户操作：     读写数据库
备份进程：     复制数据文件
WAL机制：      记录所有变更

时间线：  |----备份开始----|----备份结束----|
          T1              T2              T3
WAL：     [开始标记]→[变更记录]→[结束标记]

一致性：  基础备份 + WAL记录 = 完整数据
```

### 10.2 流复制备份


**⚡ 流复制配置**
```bash
# 主服务器配置 postgresql.conf
wal_level = replica
max_wal_senders = 3
wal_keep_size = 1GB

# 创建复制用户
sudo -u postgres psql -c "
CREATE USER replicator REPLICATION LOGIN ENCRYPTED PASSWORD 'your_password';
"

# pg_hba.conf添加复制权限
echo "host replication replicator 192.168.1.0/24 md5" >> \
    /etc/postgresql/14/main/pg_hba.conf
```

**🔄 在线流备份命令**
```bash
# 实时流复制备份
pg_basebackup -U replicator -h master_host \
               -D /backup/streaming_backup \
               --wal-method=stream \
               --write-recovery-conf
```

### 10.3 在线备份监控


**📊 备份状态监控**
```sql
-- 查看当前复制状态
SELECT 
    client_addr,
    state,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn,
    sync_state
FROM pg_stat_replication;

-- 监控WAL发送状态
SELECT 
    slot_name,
    slot_type,
    active,
    xmin,
    restart_lsn
FROM pg_replication_slots;
```

### 10.4 热备份最佳实践


**✅ 热备份建议**
- **网络带宽**：确保足够带宽传输WAL
- **存储IO**：避免与生产系统竞争IO资源
- **监控告警**：及时发现复制延迟问题
- **定期验证**：验证备份可用性

```bash
# 热备份脚本示例
#!/bin/bash
# 热备份监控脚本

# 检查复制延迟
LAG=$(sudo -u postgres psql -t -c "
    SELECT EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp()));
")

if (( $(echo "$LAG > 300" | bc -l) )); then
    echo "警告：复制延迟超过5分钟($LAG秒)"
    # 发送告警通知
fi
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


**🔸 备份类型理解**
```
逻辑备份：SQL语句形式，可读性强，跨版本兼容
物理备份：文件级别复制，速度快，适合大数据量
WAL归档：事务日志备份，支持时间点恢复
```

**🔸 关键工具使用**
- **pg_dump/pg_dumpall** - 逻辑备份的标准工具
- **pg_basebackup** - 物理备份的官方工具  
- **WAL归档** - 连续数据保护的基础
- **PITR** - 精确时间点恢复机制

### 11.2 备份策略选择指南


| 业务场景 | **推荐策略** | **理由** |
|----------|-------------|----------|
| **小型数据库** | 每日逻辑备份 | 简单可靠，易于管理 |
| **中型生产** | 物理备份+WAL归档 | 平衡性能与恢复能力 |
| **大型系统** | 流复制+定期基础备份 | 最小化恢复时间 |
| **开发测试** | 按需逻辑备份 | 灵活便捷，成本低 |

### 11.3 故障恢复决策树


```
故障类型判断：
│
├── 数据误删除 → PITR时间点恢复
├── 硬件故障 → 物理备份+WAL重放  
├── 软件故障 → 重启+自动恢复
└── 完全损坏 → 最新完整备份恢复
```

### 11.4 最佳实践总结


**🎯 备份最佳实践**
- **3-2-1原则**：3份副本，2种媒介，1份异地
- **定期验证**：每月至少验证一次备份可用性
- **自动化管理**：使用脚本自动化备份和清理
- **监控告警**：实时监控备份状态和存储空间

**⚡ 恢复最佳实践**
- **演练预案**：定期进行恢复演练
- **快速响应**：建立故障响应流程
- **分级恢复**：根据业务优先级分级恢复
- **文档记录**：详细记录恢复过程和经验

**核心记忆要点**：
- 备份是数据安全的最后一道防线，必须认真对待
- 选择合适的备份策略比使用高级功能更重要
- 未经验证的备份等于没有备份
- 恢复能力比备份能力更重要，要定期演练