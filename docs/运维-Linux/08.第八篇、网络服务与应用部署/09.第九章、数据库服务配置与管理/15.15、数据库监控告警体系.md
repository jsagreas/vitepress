---
title: 15、数据库监控告警体系
---
## 📚 目录

1. [数据库监控基础概念](#1-数据库监控基础概念)
2. [关键指标监控设置](#2-关键指标监控设置)
3. [自动化监控脚本编写](#3-自动化监控脚本编写)
4. [告警阈值与通知机制](#4-告警阈值与通知机制)
5. [监控数据可视化展示](#5-监控数据可视化展示)
6. [第三方监控工具集成](#6-第三方监控工具集成)
7. [健康检查与故障恢复](#7-健康检查与故障恢复)
8. [容量规划与预警系统](#8-容量规划与预警系统)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 数据库监控基础概念


### 1.1 什么是数据库监控


**💡 简单理解**：数据库监控就像给数据库装了一个"体检仪"，随时检查数据库的"健康状况"

```
现实生活类比：
医生监控病人 ←→ 运维监控数据库
体温、血压、心率 ←→ CPU、内存、连接数
异常指标报警 ←→ 数据库告警通知
定期体检 ←→ 定期性能检查
```

**🔸 核心作用**
- **预防问题**：在故障发生前发现异常
- **快速定位**：问题出现时快速找到原因
- **性能优化**：通过数据分析优化数据库性能
- **容量规划**：预测未来资源需求

### 1.2 监控的必要性


**为什么需要监控**：
```
无监控的痛点：
❌ 数据库宕机才知道有问题
❌ 性能下降用户投诉才发现
❌ 磁盘满了数据库无法写入
❌ 故障排查像大海捞针

有监控的好处：
✅ 问题早发现早处理
✅ 性能趋势清晰可见
✅ 资源使用合理规划
✅ 故障定位快速准确
```

### 1.3 监控体系架构


**🏗️ 监控系统组成**
```
数据收集层：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│  MySQL/PG   │    │   系统指标   │    │  应用指标   │
│   数据库    │────│   CPU/内存   │────│   响应时间  │
└─────────────┘    └──────────────┘    └─────────────┘
       │                    │                   │
       ▼                    ▼                   ▼
┌─────────────────────────────────────────────────────┐
│              数据处理与存储层                        │
│        (Prometheus/InfluxDB/Zabbix)                │
└─────────────────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────────────────┐
│              可视化与告警层                          │
│         (Grafana/AlertManager)                     │
└─────────────────────────────────────────────────────┘
```

---

## 2. 📊 关键指标监控设置


### 2.1 MySQL关键指标


**🔸 连接相关指标**

| **指标名称** | **说明** | **正常范围** | **异常表现** |
|-------------|----------|-------------|-------------|
| `Threads_connected` | 当前连接数 | < 最大连接数80% | 接近最大值 |
| `Threads_running` | 执行中的连接 | < 10 | > 50持续增长 |
| `Connection_errors_max_connections` | 连接被拒绝次数 | 0 | > 0说明连接池不够 |
| `Aborted_connects` | 中断连接数 | < 1% | 频繁中断 |

**📈 查看连接状态**
```sql
-- 查看当前连接情况
SHOW STATUS LIKE 'Threads%';
SHOW STATUS LIKE '%connect%';

-- 查看连接详情
SHOW PROCESSLIST;
```

**🔸 性能相关指标**

```
查询性能：
• Slow_queries：慢查询数量（应该很少）
• Questions：总查询数（了解负载情况）
• Com_select/Com_insert/Com_update：各类操作次数

缓存性能：
• Innodb_buffer_pool_read_requests：缓冲池读请求
• Innodb_buffer_pool_reads：物理磁盘读次数
• 缓存命中率 = (read_requests - reads) / read_requests

锁相关：
• Innodb_row_lock_waits：行锁等待次数
• Innodb_row_lock_time：行锁等待总时间
• Table_locks_waited：表锁等待次数
```

### 2.2 PostgreSQL关键指标


**🔸 连接与活动监控**
```sql
-- 当前连接数
SELECT count(*) FROM pg_stat_activity;

-- 各状态连接分布
SELECT state, count(*) 
FROM pg_stat_activity 
GROUP BY state;

-- 长时间运行的查询
SELECT pid, now() - pg_stat_activity.query_start AS duration, query 
FROM pg_stat_activity 
WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes';
```

**🔸 数据库大小监控**
```sql
-- 数据库大小
SELECT pg_database.datname, 
       pg_size_pretty(pg_database_size(pg_database.datname)) AS size
FROM pg_database;

-- 表大小排序
SELECT schemaname, tablename,
       pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables 
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC 
LIMIT 10;
```

### 2.3 系统级指标


**💻 操作系统关键指标**
```
CPU指标：
• cpu_usage：CPU使用率（应 < 80%）
• cpu_iowait：IO等待时间（应 < 20%）
• load_average：平均负载（应 < CPU核心数）

内存指标：
• memory_usage：内存使用率（应 < 85%）
• swap_usage：交换空间使用率（应 < 10%）
• buffer_cache：缓冲区使用情况

磁盘指标：
• disk_usage：磁盘使用率（应 < 85%）
• disk_iops：磁盘IOPS
• disk_latency：磁盘延迟
```

---

## 3. 🔧 自动化监控脚本编写


### 3.1 MySQL监控脚本示例


**📝 基础监控脚本**
```bash
#!/bin/bash
# MySQL基础监控脚本

DB_HOST="localhost"
DB_USER="monitor_user"
DB_PASS="monitor_pass"
LOG_FILE="/var/log/mysql_monitor.log"

# 记录日志函数
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 检查MySQL服务状态
check_mysql_service() {
    if ! systemctl is-active --quiet mysql; then
        log_message "CRITICAL: MySQL服务未运行"
        # 发送告警
        send_alert "MySQL服务停止" "critical"
        return 1
    fi
    return 0
}

# 检查连接数
check_connections() {
    local current_conn=$(mysql -h$DB_HOST -u$DB_USER -p$DB_PASS -e "SHOW STATUS LIKE 'Threads_connected';" | tail -1 | awk '{print $2}')
    local max_conn=$(mysql -h$DB_HOST -u$DB_USER -p$DB_PASS -e "SHOW VARIABLES LIKE 'max_connections';" | tail -1 | awk '{print $2}')
    
    local usage_percent=$((current_conn * 100 / max_conn))
    
    if [ $usage_percent -gt 80 ]; then
        log_message "WARNING: 连接使用率过高 ${usage_percent}%"
        send_alert "MySQL连接数过高" "warning"
    fi
}

# 检查慢查询
check_slow_queries() {
    local slow_queries=$(mysql -h$DB_HOST -u$DB_USER -p$DB_PASS -e "SHOW STATUS LIKE 'Slow_queries';" | tail -1 | awk '{print $2}')
    
    # 记录到临时文件，比较增量
    local last_slow_file="/tmp/mysql_last_slow_queries"
    local last_slow=0
    
    if [ -f $last_slow_file ]; then
        last_slow=$(cat $last_slow_file)
    fi
    
    local new_slow=$((slow_queries - last_slow))
    echo $slow_queries > $last_slow_file
    
    if [ $new_slow -gt 10 ]; then
        log_message "WARNING: 新增慢查询 ${new_slow} 条"
        send_alert "MySQL慢查询增多" "warning"
    fi
}

# 发送告警函数
send_alert() {
    local message="$1"
    local level="$2"
    
    # 可以集成邮件、短信、钉钉等告警方式
    echo "告警: $message (级别: $level)" | mail -s "MySQL监控告警" admin@company.com
}

# 主函数
main() {
    log_message "开始MySQL监控检查"
    
    if check_mysql_service; then
        check_connections
        check_slow_queries
    fi
    
    log_message "MySQL监控检查完成"
}

main
```

### 3.2 PostgreSQL监控脚本


**📝 PostgreSQL健康检查**
```bash
#!/bin/bash
# PostgreSQL监控脚本

PG_HOST="localhost"
PG_PORT="5432"
PG_USER="postgres"
PG_DB="postgres"

# 检查PostgreSQL服务
check_pg_service() {
    if ! pg_isready -h $PG_HOST -p $PG_PORT; then
        echo "CRITICAL: PostgreSQL服务不可用"
        return 1
    fi
    echo "OK: PostgreSQL服务正常"
    return 0
}

# 检查数据库连接
check_connections() {
    local conn_info=$(psql -h $PG_HOST -p $PG_PORT -U $PG_USER -d $PG_DB -t -c "
        SELECT 
            count(*) as current_connections,
            current_setting('max_connections')::int as max_connections
        FROM pg_stat_activity;")
    
    local current=$(echo $conn_info | awk '{print $1}')
    local max=$(echo $conn_info | awk '{print $2}')
    local usage_percent=$((current * 100 / max))
    
    echo "连接使用率: ${usage_percent}% (${current}/${max})"
    
    if [ $usage_percent -gt 80 ]; then
        echo "WARNING: 连接使用率过高"
    fi
}

# 检查长时间运行的查询
check_long_queries() {
    local long_queries=$(psql -h $PG_HOST -p $PG_PORT -U $PG_USER -d $PG_DB -t -c "
        SELECT count(*)
        FROM pg_stat_activity 
        WHERE state = 'active' 
        AND now() - query_start > interval '10 minutes';")
    
    if [ $long_queries -gt 0 ]; then
        echo "WARNING: 发现 $long_queries 个长时间运行的查询"
    else
        echo "OK: 无长时间运行查询"
    fi
}

# 主执行
echo "=== PostgreSQL健康检查 $(date) ==="
check_pg_service && {
    check_connections
    check_long_queries
}
```

### 3.3 自动化部署监控


**⏰ 定时任务配置**
```bash
# 编辑crontab
crontab -e

# 添加监控任务
# 每5分钟检查一次基础指标
*/5 * * * * /opt/scripts/mysql_monitor.sh

# 每小时生成性能报告
0 * * * * /opt/scripts/mysql_performance_report.sh

# 每天凌晨检查数据库大小
0 2 * * * /opt/scripts/database_size_check.sh
```

---

## 4. 🚨 告警阈值与通知机制


### 4.1 告警级别定义


**🎯 告警分级标准**

| **级别** | **说明** | **响应时间** | **典型场景** |
|---------|----------|-------------|-------------|
| 🔴 **Critical** | 严重故障 | 立即响应 | 数据库宕机、磁盘满 |
| 🟡 **Warning** | 警告 | 30分钟内 | 连接数过高、慢查询增多 |
| 🟢 **Info** | 信息 | 日常查看 | 性能报告、容量统计 |

**🔸 具体阈值设置**
```
Critical级别（立即处理）：
• 数据库服务停止
• 磁盘使用率 > 95%
• 内存使用率 > 95%
• 连接数 > 最大连接数的95%

Warning级别（及时关注）：
• 磁盘使用率 > 85%
• 内存使用率 > 85%
• 连接数 > 最大连接数的80%
• CPU使用率 > 80%持续5分钟
• 慢查询1小时内增加50条以上

Info级别（信息记录）：
• 日常性能统计
• 数据库大小变化
• 用户连接统计
```

### 4.2 通知渠道配置


**📧 邮件告警配置**
```bash
# 安装邮件工具
sudo apt-get install mailutils

# 配置邮件发送
cat > /etc/mail.rc << 'EOF'
set smtp=smtp://smtp.company.com:587
set smtp-auth-user=monitor@company.com
set smtp-auth-password=password
set smtp-auth=login
EOF

# 邮件告警函数
send_email_alert() {
    local subject="$1"
    local message="$2"
    local level="$3"
    
    cat << EOF | mail -s "[$level] $subject" admin@company.com
告警时间: $(date)
告警级别: $level
告警内容: $message
服务器: $(hostname)
IP地址: $(hostname -I)

请及时处理！
EOF
}
```

**💬 钉钉告警配置**
```bash
# 钉钉机器人告警
send_dingtalk_alert() {
    local message="$1"
    local level="$2"
    local webhook_url="https://oapi.dingtalk.com/robot/send?access_token=YOUR_TOKEN"
    
    local color="info"
    case $level in
        "critical") color="red" ;;
        "warning") color="orange" ;;
    esac
    
    curl -X POST "$webhook_url" \
        -H 'Content-Type: application/json' \
        -d "{
            \"msgtype\": \"markdown\",
            \"markdown\": {
                \"title\": \"数据库监控告警\",
                \"text\": \"## [$level] 数据库告警\n\n**时间**: $(date)\n\n**服务器**: $(hostname)\n\n**详情**: $message\"
            }
        }"
}
```

### 4.3 告警抑制与升级


**🔇 告警抑制机制**
```bash
# 告警抑制配置
ALERT_SUPPRESS_FILE="/tmp/alert_suppress"

# 检查是否在抑制期内
is_alert_suppressed() {
    local alert_type="$1"
    local suppress_duration=3600  # 1小时抑制期
    
    local last_alert_file="${ALERT_SUPPRESS_FILE}_${alert_type}"
    
    if [ -f "$last_alert_file" ]; then
        local last_alert_time=$(cat "$last_alert_file")
        local current_time=$(date +%s)
        local time_diff=$((current_time - last_alert_time))
        
        if [ $time_diff -lt $suppress_duration ]; then
            return 0  # 在抑制期内
        fi
    fi
    
    # 记录本次告警时间
    echo $(date +%s) > "$last_alert_file"
    return 1  # 不在抑制期内，可以告警
}

# 使用示例
if ! is_alert_suppressed "high_connections"; then
    send_alert "连接数过高" "warning"
fi
```

---

## 5. 📈 监控数据可视化展示


### 5.1 Grafana仪表盘配置


**🎨 MySQL仪表盘指标**
```json
{
  "dashboard": {
    "title": "MySQL监控仪表盘",
    "panels": [
      {
        "title": "连接状态",
        "type": "stat",
        "targets": [
          {
            "expr": "mysql_global_status_threads_connected",
            "legendFormat": "当前连接数"
          }
        ]
      },
      {
        "title": "查询QPS",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(mysql_global_status_questions[5m])",
            "legendFormat": "每秒查询数"
          }
        ]
      }
    ]
  }
}
```

**📊 关键指标面板布局**
```
┌─────────────────────────────────────────────────────────┐
│                    MySQL监控仪表盘                       │
├─────────────────┬─────────────────┬─────────────────────┤
│   当前连接数     │    活跃连接     │     QPS            │
│      156        │       12       │      850           │
├─────────────────┼─────────────────┼─────────────────────┤
│              查询性能趋势图                             │
│    ╭─────────────────────────────────────────╮         │
│    │  QPS  ████████████████████████████      │         │
│    │       ████████████████████████████      │         │
│    ╰─────────────────────────────────────────╯         │
├─────────────────────────────────────────────────────────┤
│              缓冲池命中率                               │
│    ╭─────────────────────────────────────────╮         │
│    │  99.8% ████████████████████████████████ │         │
│    ╰─────────────────────────────────────────╯         │
└─────────────────────────────────────────────────────────┘
```

### 5.2 自定义监控大屏


**🖥️ 监控大屏设计思路**
```
顶部：核心指标概览
• 数据库状态（绿色正常/红色异常）
• 总连接数 / 活跃连接数
• 当前QPS / TPS
• 缓存命中率

中部：性能趋势图表
• 左侧：查询性能趋势（QPS/TPS）
• 右侧：资源使用趋势（CPU/内存）

底部：告警信息滚动
• 最近24小时告警列表
• 告警级别色彩区分
• 处理状态显示
```

### 5.3 移动端监控应用


**📱 移动监控要点**
```bash
# 轻量级监控API
#!/bin/bash
# 生成移动端API数据

generate_mobile_api() {
    local output_file="/var/www/html/api/db_status.json"
    
    # 获取关键指标
    local db_status="online"
    local connections=$(mysql -e "SHOW STATUS LIKE 'Threads_connected';" | tail -1 | awk '{print $2}')
    local qps=$(mysql -e "SHOW STATUS LIKE 'Questions';" | tail -1 | awk '{print $2}')
    
    # 生成JSON格式数据
    cat > "$output_file" << EOF
{
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "database": {
        "status": "$db_status",
        "connections": $connections,
        "qps": $qps
    },
    "alerts": [
        $(get_recent_alerts)
    ]
}
EOF
}

# 每分钟更新一次
while true; do
    generate_mobile_api
    sleep 60
done
```

---

## 6. 🔗 第三方监控工具集成


### 6.1 Zabbix集成配置


**📋 Zabbix MySQL监控模板**
```bash
# 安装Zabbix Agent
sudo apt-get install zabbix-agent

# 配置MySQL监控用户
mysql -u root -p << 'EOF'
CREATE USER 'zabbix'@'localhost' IDENTIFIED BY 'zabbix_password';
GRANT REPLICATION CLIENT,PROCESS,SHOW DATABASES,SHOW VIEW ON *.* TO 'zabbix'@'localhost';
FLUSH PRIVILEGES;
EOF

# 配置Zabbix Agent参数
cat >> /etc/zabbix/zabbix_agentd.conf << 'EOF'
# MySQL监控配置
UserParameter=mysql.status[*],echo "show global status where Variable_name='$1';" | mysql -uzabbix -pzabbix_password -N | awk '{print $$2}'
UserParameter=mysql.size[*],bash -c 'echo "select sum($(case "$3" in both|"") echo "data_length+index_length";; data|DATA) echo "data_length";; index|INDEX) echo "index_length";; free|FREE) echo "data_free";; esac)) from information_schema.tables$([[ "$1" = "all" ]] || echo " where table_schema=\"$1\"")$([[ "$2" = "all" ]] || echo "and table_name=\"$2\"");" | mysql -uzabbix -pzabbix_password -N'
EOF

# 重启Zabbix Agent
sudo systemctl restart zabbix-agent
```

### 6.2 Prometheus集成


**⚡ MySQL Exporter配置**
```bash
# 下载MySQL Exporter
wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.14.0/mysqld_exporter-0.14.0.linux-amd64.tar.gz
tar xzf mysqld_exporter-0.14.0.linux-amd64.tar.gz
sudo mv mysqld_exporter-0.14.0.linux-amd64/mysqld_exporter /usr/local/bin/

# 创建监控用户
mysql -u root -p << 'EOF'
CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'exporter_password';
GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';
FLUSH PRIVILEGES;
EOF

# 配置Exporter
cat > /etc/mysqld_exporter.cnf << 'EOF'
[client]
user=exporter
password=exporter_password
host=localhost
port=3306
EOF

# 创建systemd服务
cat > /etc/systemd/system/mysqld_exporter.service << 'EOF'
[Unit]
Description=MySQL Exporter
After=network.target

[Service]
Type=simple
Restart=always
User=prometheus
ExecStart=/usr/local/bin/mysqld_exporter --config.my-cnf=/etc/mysqld_exporter.cnf

[Install]
WantedBy=multi-user.target
EOF

# 启动服务
sudo systemctl daemon-reload
sudo systemctl enable mysqld_exporter
sudo systemctl start mysqld_exporter
```

### 6.3 Nagios集成


**🔍 Nagios插件配置**
```bash
# 下载MySQL检查插件
cd /usr/local/nagios/libexec/
sudo wget https://raw.githubusercontent.com/nagios-plugins/nagios-plugins/master/plugins/check_mysql.c

# 编译插件
sudo gcc -o check_mysql check_mysql.c -lmysqlclient

# 配置检查命令
cat >> /usr/local/nagios/etc/objects/commands.cfg << 'EOF'
define command{
    command_name    check_mysql
    command_line    $USER1$/check_mysql -H $HOSTADDRESS$ -u nagios -p nagios_password
}

define command{
    command_name    check_mysql_connections
    command_line    $USER1$/check_mysql_connections.sh $HOSTADDRESS$
}
EOF

# 自定义连接数检查脚本
cat > /usr/local/nagios/libexec/check_mysql_connections.sh << 'EOF'
#!/bin/bash
HOST=$1
WARNING=80
CRITICAL=90

CURRENT=$(mysql -h $HOST -u nagios -pnagios_password -e "SHOW STATUS LIKE 'Threads_connected';" | tail -1 | awk '{print $2}')
MAX=$(mysql -h $HOST -u nagios -pnagios_password -e "SHOW VARIABLES LIKE 'max_connections';" | tail -1 | awk '{print $2}')

PERCENT=$((CURRENT * 100 / MAX))

if [ $PERCENT -ge $CRITICAL ]; then
    echo "CRITICAL - MySQL连接使用率 ${PERCENT}%"
    exit 2
elif [ $PERCENT -ge $WARNING ]; then
    echo "WARNING - MySQL连接使用率 ${PERCENT}%"
    exit 1
else
    echo "OK - MySQL连接使用率 ${PERCENT}%"
    exit 0
fi
EOF

chmod +x /usr/local/nagios/libexec/check_mysql_connections.sh
```

---

## 7. 🏥 健康检查与故障恢复


### 7.1 数据库健康检查脚本


**🔍 综合健康检查**
```bash
#!/bin/bash
# 数据库综合健康检查脚本

DB_TYPE="mysql"  # 或 "postgresql"
HEALTH_SCORE=100
ISSUES=()

# 检查数据库服务状态
check_service_status() {
    echo "=== 检查服务状态 ==="
    
    if [ "$DB_TYPE" = "mysql" ]; then
        if ! systemctl is-active --quiet mysql; then
            ISSUES+=("数据库服务未运行")
            HEALTH_SCORE=$((HEALTH_SCORE - 50))
            return 1
        fi
    elif [ "$DB_TYPE" = "postgresql" ]; then
        if ! systemctl is-active --quiet postgresql; then
            ISSUES+=("PostgreSQL服务未运行")
            HEALTH_SCORE=$((HEALTH_SCORE - 50))
            return 1
        fi
    fi
    
    echo "✅ 数据库服务运行正常"
    return 0
}

# 检查连接性
check_connectivity() {
    echo "=== 检查连接性 ==="
    
    if [ "$DB_TYPE" = "mysql" ]; then
        if ! mysql -e "SELECT 1;" &>/dev/null; then
            ISSUES+=("无法连接到MySQL")
            HEALTH_SCORE=$((HEALTH_SCORE - 30))
            return 1
        fi
    elif [ "$DB_TYPE" = "postgresql" ]; then
        if ! psql -c "SELECT 1;" &>/dev/null; then
            ISSUES+=("无法连接到PostgreSQL")
            HEALTH_SCORE=$((HEALTH_SCORE - 30))
            return 1
        fi
    fi
    
    echo "✅ 数据库连接正常"
    return 0
}

# 检查磁盘空间
check_disk_space() {
    echo "=== 检查磁盘空间 ==="
    
    local disk_usage=$(df /var/lib/mysql | tail -1 | awk '{print $5}' | sed 's/%//')
    
    if [ $disk_usage -gt 90 ]; then
        ISSUES+=("磁盘使用率过高: ${disk_usage}%")
        HEALTH_SCORE=$((HEALTH_SCORE - 20))
    elif [ $disk_usage -gt 80 ]; then
        ISSUES+=("磁盘使用率较高: ${disk_usage}%")
        HEALTH_SCORE=$((HEALTH_SCORE - 10))
    fi
    
    echo "磁盘使用率: ${disk_usage}%"
    return 0
}

# 检查内存使用
check_memory_usage() {
    echo "=== 检查内存使用 ==="
    
    local mem_usage=$(free | grep Mem | awk '{printf("%.1f", $3/$2 * 100.0)}')
    local mem_int=${mem_usage%.*}
    
    if [ $mem_int -gt 90 ]; then
        ISSUES+=("内存使用率过高: ${mem_usage}%")
        HEALTH_SCORE=$((HEALTH_SCORE - 15))
    elif [ $mem_int -gt 80 ]; then
        ISSUES+=("内存使用率较高: ${mem_usage}%")
        HEALTH_SCORE=$((HEALTH_SCORE - 5))
    fi
    
    echo "内存使用率: ${mem_usage}%"
    return 0
}

# 生成健康报告
generate_health_report() {
    echo ""
    echo "=== 健康检查报告 ==="
    echo "检查时间: $(date)"
    echo "健康评分: ${HEALTH_SCORE}/100"
    
    if [ ${#ISSUES[@]} -eq 0 ]; then
        echo "状态: 🟢 健康"
    elif [ $HEALTH_SCORE -gt 70 ]; then
        echo "状态: 🟡 需要关注"
    else
        echo "状态: 🔴 需要紧急处理"
    fi
    
    if [ ${#ISSUES[@]} -gt 0 ]; then
        echo ""
        echo "发现的问题:"
        for issue in "${ISSUES[@]}"; do
            echo "  ❌ $issue"
        done
    fi
}

# 主执行函数
main() {
    echo "开始数据库健康检查..."
    echo ""
    
    check_service_status
    check_connectivity
    check_disk_space
    check_memory_usage
    
    generate_health_report
    
    # 根据健康评分决定退出码
    if [ $HEALTH_SCORE -lt 50 ]; then
        exit 2  # Critical
    elif [ $HEALTH_SCORE -lt 80 ]; then
        exit 1  # Warning
    else
        exit 0  # OK
    fi
}

main
```

### 7.2 故障自动恢复机制


**🔄 自动恢复脚本**
```bash
#!/bin/bash
# 数据库故障自动恢复脚本

RECOVERY_LOG="/var/log/db_recovery.log"
MAX_RECOVERY_ATTEMPTS=3

# 记录恢复日志
log_recovery() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $RECOVERY_LOG
}

# MySQL服务恢复
recover_mysql_service() {
    log_recovery "检测到MySQL服务停止，尝试恢复"
    
    local attempt=1
    while [ $attempt -le $MAX_RECOVERY_ATTEMPTS ]; do
        log_recovery "第 $attempt 次尝试启动MySQL服务"
        
        systemctl start mysql
        sleep 10
        
        if systemctl is-active --quiet mysql; then
            log_recovery "MySQL服务恢复成功"
            send_alert "MySQL服务已自动恢复" "info"
            return 0
        fi
        
        attempt=$((attempt + 1))
    done
    
    log_recovery "MySQL服务恢复失败，需要人工干预"
    send_alert "MySQL服务恢复失败，需要人工干预" "critical"
    return 1
}

# 清理长时间运行的查询
kill_long_running_queries() {
    log_recovery "检查并清理长时间运行的查询"
    
    # 获取运行超过10分钟的查询
    local long_queries=$(mysql -e "
        SELECT CONCAT('KILL ', id, ';') as kill_stmt
        FROM information_schema.processlist 
        WHERE command != 'Sleep' 
        AND time > 600 
        AND user != 'root';" -N)
    
    if [ -n "$long_queries" ]; then
        echo "$long_queries" | while read kill_stmt; do
            log_recovery "执行: $kill_stmt"
            mysql -e "$kill_stmt"
        done
        
        log_recovery "已清理长时间运行的查询"
        send_alert "已自动清理长时间运行的查询" "info"
    fi
}

# 磁盘空间清理
cleanup_disk_space() {
    local disk_usage=$(df /var/lib/mysql | tail -1 | awk '{print $5}' | sed 's/%//')
    
    if [ $disk_usage -gt 85 ]; then
        log_recovery "磁盘使用率 ${disk_usage}%，开始清理"
        
        # 清理二进制日志
        mysql -e "PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 3 DAY);"
        
        # 清理慢查询日志
        > /var/log/mysql/slow.log
        
        # 优化表空间
        mysql -e "OPTIMIZE TABLE information_schema.tables WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'mysql');"
        
        log_recovery "磁盘清理完成"
        send_alert "已自动清理磁盘空间" "info"
    fi
}

# 主恢复逻辑
main_recovery() {
    # 检查MySQL服务状态
    if ! systemctl is-active --quiet mysql; then
        recover_mysql_service
    fi
    
    # 检查并处理长时间查询
    kill_long_running_queries
    
    # 检查磁盘空间
    cleanup_disk_space
}

# 执行恢复
main_recovery
```

---

## 8. 📊 容量规划与预警系统


### 8.1 容量预测分析


**📈 数据增长趋势分析**
```bash
#!/bin/bash
# 数据库容量增长趋势分析

STATS_DIR="/var/log/db_capacity"
mkdir -p $STATS_DIR

# 收集数据库大小信息
collect_size_data() {
    local date_str=$(date '+%Y-%m-%d')
    local size_file="$STATS_DIR/db_size_$date_str.log"
    
    echo "=== $(date) ===" >> $size_file
    
    # MySQL数据库大小
    mysql -e "
        SELECT 
            table_schema as 'Database',
            ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) as 'Size_MB'
        FROM information_schema.tables 
        GROUP BY table_schema 
        ORDER BY SUM(data_length + index_length) DESC;" >> $size_file
    
    echo "" >> $size_file
}

# 分析增长趋势
analyze_growth_trend() {
    local days_back=30
    local current_size=$(mysql -e "
        SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 2)
        FROM information_schema.tables;" -N)
    
    echo "当前数据库总大小: ${current_size} MB"
    
    # 计算日均增长（这里简化处理）
    local daily_growth=50  # MB/天，实际应该从历史数据计算
    
    echo "预估日增长: ${daily_growth} MB"
    
    # 预测未来容量需求
    local months_ahead=6
    local days_ahead=$((months_ahead * 30))
    local predicted_size=$((current_size + daily_growth * days_ahead))
    
    echo "预测 ${months_ahead} 个月后大小: ${predicted_size} MB"
    
    # 检查是否需要扩容
    local disk_total=$(df /var/lib/mysql | tail -1 | awk '{print $2}')
    local disk_total_mb=$((disk_total / 1024))
    local usage_prediction=$((predicted_size * 100 / disk_total_mb))
    
    if [ $usage_prediction -gt 80 ]; then
        echo "⚠️  需要考虑扩容，预测使用率: ${usage_prediction}%"
        send_capacity_alert "数据库容量预警" "$predicted_size MB"
    fi
}

# 容量告警
send_capacity_alert() {
    local subject="$1"
    local predicted_size="$2"
    
    cat << EOF | mail -s "$subject" admin@company.com
容量预警报告

当前时间: $(date)
服务器: $(hostname)
预测大小: $predicted_size
建议: 请考虑扩容或数据清理

详细信息请查看容量分析报告。
EOF
}

# 执行分析
collect_size_data
analyze_growth_trend
```

### 8.2 资源使用预警


**⚠️ 资源预警配置**
```bash
#!/bin/bash
# 资源使用预警脚本

# 预警阈值配置
DISK_WARNING=80
DISK_CRITICAL=90
MEMORY_WARNING=85
MEMORY_CRITICAL=95
CONNECTION_WARNING=80
CONNECTION_CRITICAL=90

# 检查磁盘使用率预警
check_disk_forecast() {
    local current_usage=$(df /var/lib/mysql | tail -1 | awk '{print $5}' | sed 's/%//')
    local growth_rate=2  # 每月增长2%
    
    # 预测未来3个月的使用率
    local forecast_3months=$((current_usage + growth_rate * 3))
    
    echo "当前磁盘使用率: ${current_usage}%"
    echo "预测3个月后: ${forecast_3months}%"
    
    if [ $forecast_3months -gt $DISK_CRITICAL ]; then
        send_forecast_alert "磁盘空间" "3个月内将达到${forecast_3months}%" "critical"
    elif [ $forecast_3months -gt $DISK_WARNING ]; then
        send_forecast_alert "磁盘空间" "3个月内将达到${forecast_3months}%" "warning"
    fi
}

# 连接数趋势预警
check_connection_forecast() {
    local current_conn=$(mysql -e "SHOW STATUS LIKE 'Threads_connected';" | tail -1 | awk '{print $2}')
    local max_conn=$(mysql -e "SHOW VARIABLES LIKE 'max_connections';" | tail -1 | awk '{print $2}')
    local current_usage=$((current_conn * 100 / max_conn))
    
    echo "当前连接使用率: ${current_usage}%"
    
    # 基于历史趋势预测（简化处理）
    local growth_trend=5  # 假设月增长5%
    local forecast_usage=$((current_usage + growth_trend))
    
    if [ $forecast_usage -gt $CONNECTION_WARNING ]; then
        send_forecast_alert "连接数" "预计将达到${forecast_usage}%" "warning"
    fi
}

# 发送预测告警
send_forecast_alert() {
    local resource="$1"
    local forecast="$2"
    local level="$3"
    
    cat << EOF | mail -s "[$level] ${resource}容量预警" admin@company.com
资源容量预警

资源类型: $resource
预测情况: $forecast
告警级别: $level
检查时间: $(date)

建议尽快制定扩容计划。
EOF
}

# 执行预警检查
echo "=== 资源容量预警检查 ==="
check_disk_forecast
check_connection_forecast
```

### 8.3 监控数据保留策略


**🗄️ 数据保留管理**
```bash
#!/bin/bash
# 监控数据保留策略管理

MONITOR_DATA_DIR="/var/lib/monitoring"
LOG_RETENTION_DAYS=90
METRICS_RETENTION_DAYS=180

# 清理过期日志
cleanup_old_logs() {
    echo "清理超过 ${LOG_RETENTION_DAYS} 天的监控日志"
    
    find /var/log/mysql_monitor* -name "*.log" -mtime +$LOG_RETENTION_DAYS -delete
    find /var/log/pg_monitor* -name "*.log" -mtime +$LOG_RETENTION_DAYS -delete
    
    echo "日志清理完成"
}

# 清理过期指标数据
cleanup_old_metrics() {
    echo "清理超过 ${METRICS_RETENTION_DAYS} 天的指标数据"
    
    # 如果使用InfluxDB
    if command -v influx &> /dev/null; then
        influx -execute "DELETE FROM metrics WHERE time < now() - ${METRICS_RETENTION_DAYS}d"
    fi
    
    # 清理本地指标文件
    find $MONITOR_DATA_DIR -name "metrics_*" -mtime +$METRICS_RETENTION_DAYS -delete
    
    echo "指标数据清理完成"
}

# 压缩历史数据
compress_historical_data() {
    echo "压缩历史监控数据"
    
    # 压缩30天前的数据
    find /var/log -name "*monitor*.log" -mtime +30 ! -name "*.gz" -exec gzip {} \;
    
    echo "历史数据压缩完成"
}

# 生成数据保留报告
generate_retention_report() {
    local report_file="/var/log/data_retention_report.txt"
    
    cat > $report_file << EOF
监控数据保留报告
生成时间: $(date)

=== 当前数据量统计 ===
监控日志目录大小: $(du -sh /var/log/*monitor* 2>/dev/null | awk '{sum+=$1} END {print sum}' || echo "0") 
指标数据目录大小: $(du -sh $MONITOR_DATA_DIR 2>/dev/null | awk '{print $1}' || echo "0")

=== 保留策略 ===
日志保留期: ${LOG_RETENTION_DAYS} 天
指标保留期: ${METRICS_RETENTION_DAYS} 天

=== 清理统计 ===
已删除文件数量: $(find /var/log -name "*monitor*" -mtime +$LOG_RETENTION_DAYS 2>/dev/null | wc -l)
释放磁盘空间: 约 $(du -sh /var/log/*monitor* 2>/dev/null | awk '{sum+=$1} END {print sum*0.3}' || echo "0") 

EOF

    echo "数据保留报告已生成: $report_file"
}

# 主清理流程
main() {
    echo "=== 开始监控数据保留管理 ==="
    cleanup_old_logs
    cleanup_old_metrics
    compress_historical_data
    generate_retention_report
    echo "=== 数据保留管理完成 ==="
}

main
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 监控本质：数据库的"健康体检仪"，预防问题于未然
🔸 关键指标：连接数、查询性能、资源使用、锁状态
🔸 告警分级：Critical(立即处理) > Warning(及时关注) > Info(信息记录)
🔸 自动化：脚本监控 + 定时任务 + 故障自恢复
🔸 可视化：Grafana仪表盘 + 移动端监控 + 监控大屏
🔸 容量规划：趋势分析 + 预测预警 + 扩容建议
```

### 9.2 关键理解要点


**🔹 监控不是目的，是手段**
```
监控的价值：
- 预防 > 发现 > 解决
- 趋势分析 > 实时告警
- 自动化处理 > 人工干预
- 容量规划 > 被动扩容
```

**🔹 告警要智能，不要骚扰**
```
好的告警系统：
✅ 准确：真正有问题才告警
✅ 及时：问题发生时立即通知
✅ 分级：不同级别不同处理方式
✅ 抑制：避免重复告警骚扰

避免告警疲劳：
❌ 阈值设置过低导致频繁告警
❌ 所有告警都发给所有人
❌ 告警信息不明确，无法定位问题
❌ 没有告警抑制机制
```

**🔹 可视化要直观，数据要有用**
```
设计原则：
- 一眼看出系统健康状态
- 重要指标突出显示
- 趋势图比数字更直观
- 移动端也要能查看

数据价值：
- 历史数据用于趋势分析
- 实时数据用于故障处理
- 聚合数据用于容量规划
```

### 9.3 实际应用指导


**🎯 监控体系建设步骤**
```
第一步：基础监控
- 服务可用性监控
- 关键指标收集
- 基础告警设置

第二步：完善告警
- 告警分级配置
- 多渠道通知
- 告警抑制机制

第三步：可视化
- Grafana仪表盘
- 监控大屏
- 移动端支持

第四步：自动化
- 自动恢复脚本
- 容量预警
- 智能分析
```

**🔧 常见问题解决**
```
告警太多怎么办？
→ 调整阈值，增加抑制时间
→ 分级处理，不同级别不同响应

监控数据太多怎么办？
→ 设置合理的保留策略
→ 定期清理和压缩历史数据

故障恢复不及时怎么办？
→ 编写自动恢复脚本
→ 24小时值班制度
→ 分级响应机制
```

**⚡ 性能优化建议**
```
监控系统本身的优化：
- 监控脚本不要过于频繁执行
- 数据采集要轻量级，避免影响业务
- 使用缓存减少重复查询
- 监控数据要定期清理

数据库性能优化：
- 基于监控数据识别性能瓶颈
- 慢查询分析和优化
- 索引使用情况监控
- 连接池配置优化
```

### 9.4 最佳实践总结


**✅ 做的好的做法**
- 监控指标要全面但不冗余
- 告警要准确及时，避免误报
- 可视化要直观易懂
- 自动化程度要高
- 容量规划要前瞻性

**❌ 要避免的误区**
- 监控指标越多越好
- 所有异常都要告警
- 只关注实时数据，忽视趋势
- 完全依赖人工处理
- 监控系统比业务系统还复杂

**核心记忆**：
- 监控是预防，不是治疗
- 告警要智能，不要骚扰  
- 可视化要直观，数据要有用
- 自动化要可靠，人工要保底