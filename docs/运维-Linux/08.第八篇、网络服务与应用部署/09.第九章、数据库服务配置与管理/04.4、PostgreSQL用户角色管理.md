---
title: 4、PostgreSQL用户角色管理
---
## 📚 目录

1. [PostgreSQL角色系统概述](#1-PostgreSQL角色系统概述)
2. [角色创建与删除操作](#2-角色创建与删除操作)
3. [用户与组角色深度理解](#3-用户与组角色深度理解)
4. [登录权限与密码认证](#4-登录权限与密码认证)
5. [数据库访问权限控制](#5-数据库访问权限控制)
6. [表与schema权限管理](#6-表与schema权限管理)
7. [角色继承与成员关系](#7-角色继承与成员关系)
8. [默认权限设置](#8-默认权限设置)
9. [行级安全策略RLS](#9-行级安全策略RLS)
10. [权限查询与管理](#10-权限查询与管理)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 PostgreSQL角色系统概述


### 1.1 什么是角色系统


**角色系统的本质**：
PostgreSQL使用"角色"这个统一概念来管理所有的用户和权限。可以把角色理解为一个"身份证"，这个身份证决定了你能在数据库里做什么。

```
传统思维 vs PostgreSQL思维：
传统：用户 + 用户组 + 权限
PostgreSQL：角色（统一概念）

角色 = 用户 + 用户组 + 权限载体
```

**角色的三种用途**：
- **登录角色**：可以连接数据库的"用户"
- **组角色**：用来组织其他角色的"用户组"
- **权限角色**：专门用来承载特定权限的"权限包"

### 1.2 角色系统的核心特点


**🔸 统一性**：
```
不区分用户和组：
- 在PostgreSQL中，用户就是角色，组也是角色
- 区别只在于是否有LOGIN权限
- 这种设计更加灵活和统一
```

**🔸 继承性**：
```
角色可以继承其他角色的权限：
developer_role → 继承 → basic_user_role
                      ↓
                获得basic_user的所有权限
```

**🔸 组合性**：
```
一个角色可以是多个角色的成员：
user_alice → 成员 → [developer_role, admin_role]
                    ↓
                获得两个角色的所有权限
```

### 1.3 角色系统架构图


```
PostgreSQL角色权限架构：

┌─────────────────────┐
│     superuser       │ ← 超级用户（所有权限）
├─────────────────────┤
│   database_owner    │ ← 数据库所有者
├─────────────────────┤
│   schema_owner      │ ← Schema所有者
├─────────────────────┤
│   table_owner       │ ← 表所有者
├─────────────────────┤
│   regular_users     │ ← 普通用户
└─────────────────────┘

权限从上到下递减，上级可以管理下级
```

---

## 2. 🔧 角色创建与删除操作


### 2.1 CREATE ROLE详解


**基本语法理解**：
CREATE ROLE就是"创建一个新身份"的意思，这个身份可以是用户、也可以是组。

```sql
-- 最简单的角色创建
CREATE ROLE role_name;
```

**常用选项详解**：

| 选项 | 含义 | 实际作用 |
|------|------|----------|
| `LOGIN` | 允许登录 | 这个角色可以作为用户连接数据库 |
| `PASSWORD 'xxx'` | 设置密码 | 登录时需要提供的密码 |
| `CREATEDB` | 可创建数据库 | 允许这个角色创建新数据库 |
| `CREATEUSER` | 可创建用户 | 允许创建其他角色（现已改为CREATEROLE） |
| `SUPERUSER` | 超级用户 | 拥有所有权限，类似Linux的root |

### 2.2 实际创建示例


**🔸 创建普通用户**：
```sql
-- 创建一个可以登录的普通用户
CREATE ROLE alice LOGIN PASSWORD 'alice123';

-- 等价写法（CREATE USER是CREATE ROLE LOGIN的简写）
CREATE USER alice PASSWORD 'alice123';
```

**🔸 创建管理员用户**：
```sql
-- 创建具有创建数据库权限的管理员
CREATE ROLE admin_user 
  LOGIN 
  PASSWORD 'admin123' 
  CREATEDB 
  CREATEROLE;
```

**🔸 创建组角色**：
```sql
-- 创建不能登录的组角色（用于权限管理）
CREATE ROLE developers;
CREATE ROLE readonly_users;
```

### 2.3 角色删除操作


**DROP ROLE详解**：
删除角色前需要确保没有依赖关系，就像删除文件夹前要先清空内容。

```sql
-- 删除角色
DROP ROLE role_name;

-- 强制删除（如果存在的话）
DROP ROLE IF EXISTS role_name;
```

**删除前的检查清单**：
> ⚠️ **删除角色前必须检查**：
> 1. 角色是否拥有任何数据库对象
> 2. 角色是否有活动连接
> 3. 角色是否被其他角色引用

### 2.4 角色修改操作


**ALTER ROLE详解**：
修改现有角色的属性，就像修改用户的权限设置。

```sql
-- 修改密码
ALTER ROLE alice PASSWORD 'new_password';

-- 添加权限
ALTER ROLE alice CREATEDB;

-- 移除权限
ALTER ROLE alice NOCREATEDB;

-- 修改连接限制
ALTER ROLE alice CONNECTION LIMIT 10;
```

---

## 3. 👥 用户与组角色深度理解


### 3.1 用户角色 vs 组角色


**本质区别**：
在PostgreSQL中，用户和组在技术上是同一个东西——都是角色。区别仅在于用途和权限。

```
用户角色特征：
✅ 有LOGIN权限 → 可以连接数据库
✅ 通常有密码 → 用于身份验证
✅ 代表具体的人 → 如alice、bob

组角色特征：
❌ 无LOGIN权限 → 不能直接连接数据库
❌ 通常无密码 → 不用于登录
✅ 代表权限集合 → 如developers、managers
```

### 3.2 角色关系图示


```
组角色与用户角色关系：

    developers (组角色)
         ↑
    ┌────┼────┐
    │    │    │
  alice bob  charlie (用户角色)
    ↑    ↑     ↑
   LOGIN LOGIN LOGIN

权限流向：developers → alice/bob/charlie
```

### 3.3 实际使用场景


**🔸 按部门组织**：
```sql
-- 创建部门组角色
CREATE ROLE hr_department;
CREATE ROLE finance_department;
CREATE ROLE it_department;

-- 创建用户并分配到部门
CREATE USER alice LOGIN PASSWORD 'pass123';
CREATE USER bob LOGIN PASSWORD 'pass456';

-- 建立成员关系
GRANT hr_department TO alice;
GRANT it_department TO bob;
```

**🔸 按职能组织**：
```sql
-- 创建职能组角色
CREATE ROLE readonly_access;
CREATE ROLE readwrite_access;
CREATE ROLE admin_access;

-- 设置不同级别的权限
GRANT CONNECT ON DATABASE mydb TO readonly_access;
GRANT USAGE ON SCHEMA public TO readonly_access;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_access;
```

### 3.4 最佳实践原则


**权限管理策略**：
```
推荐做法：
1. 创建组角色承载权限
2. 用户角色只用于登录
3. 通过成员关系分配权限
4. 避免直接给用户分配复杂权限

避免做法：
❌ 直接给每个用户分配大量权限
❌ 创建过多粒度过细的组角色
❌ 组角色设置LOGIN权限
```

---

## 4. 🔐 登录权限与密码认证


### 4.1 LOGIN权限详解


**LOGIN权限的本质**：
LOGIN权限决定一个角色是否可以作为"用户"连接到数据库。没有LOGIN权限的角色只能作为"权限容器"存在。

```sql
-- 查看角色是否有登录权限
SELECT rolname, rolcanlogin FROM pg_roles WHERE rolname = 'alice';

-- 给现有角色添加登录权限
ALTER ROLE group_role LOGIN;

-- 移除登录权限
ALTER ROLE user_role NOLOGIN;
```

### 4.2 密码认证方式


**PostgreSQL支持的认证方式**：

| 认证方式 | 描述 | 使用场景 |
|----------|------|----------|
| `md5` | MD5加密密码 | 最常用的密码认证 |
| `scram-sha-256` | 更安全的加密 | PostgreSQL 10+推荐 |
| `trust` | 无需密码 | 开发环境（不安全） |
| `peer` | 系统用户认证 | 本地Unix套接字连接 |
| `ldap` | LDAP服务器认证 | 企业环境集成 |

### 4.3 密码管理最佳实践


**🔸 密码设置**：
```sql
-- 创建用户时设置密码
CREATE USER alice LOGIN PASSWORD 'StrongPass123!';

-- 修改现有用户密码
ALTER USER alice PASSWORD 'NewStrongPass456!';

-- 设置密码过期时间
ALTER USER alice VALID UNTIL '2024-12-31';
```

**🔸 连接限制**：
```sql
-- 限制同时连接数
ALTER ROLE alice CONNECTION LIMIT 5;

-- 查看当前连接
SELECT rolname, rolconnlimit FROM pg_roles WHERE rolname = 'alice';
```

### 4.4 认证配置文件


**pg_hba.conf配置理解**：
这个文件控制"谁可以从哪里连接到哪个数据库"。

```
pg_hba.conf配置格式：
TYPE  DATABASE  USER  ADDRESS  METHOD

示例配置：
# 类型  数据库   用户   地址范围    认证方式
local   all      all              peer
host    all      all   127.0.0.1/32  md5
host    mydb     alice 192.168.1.0/24 md5
```

**配置解释**：
- **local**：本地Unix套接字连接
- **host**：TCP/IP连接
- **all**：所有数据库/用户
- **地址范围**：允许连接的IP范围
- **认证方式**：如何验证用户身份

---

## 5. 🗄️ 数据库访问权限控制


### 5.1 数据库级权限


**数据库权限的含义**：
数据库级权限控制用户是否可以连接到特定数据库，以及在数据库中的基本操作权限。

```sql
-- 授予数据库连接权限
GRANT CONNECT ON DATABASE mydb TO alice;

-- 授予在数据库中创建schema的权限
GRANT CREATE ON DATABASE mydb TO alice;

-- 查看数据库权限
SELECT datname, datacl FROM pg_database WHERE datname = 'mydb';
```

### 5.2 权限类型详解


**数据库级权限类型**：

| 权限 | 英文 | 作用 | 实际含义 |
|------|------|------|----------|
| 连接 | CONNECT | 可以连接数据库 | 最基本权限，没有这个无法登录 |
| 创建 | CREATE | 可创建schema | 在数据库中创建新的命名空间 |
| 临时 | TEMPORARY/TEMP | 可创建临时表 | 创建会话级别的临时对象 |

### 5.3 权限授予与回收


**🔸 权限授予**：
```sql
-- 基本授权语法
GRANT privilege_type ON DATABASE database_name TO role_name;

-- 实际示例
GRANT CONNECT ON DATABASE sales_db TO sales_team;
GRANT CREATE ON DATABASE dev_db TO developers;
```

**🔸 权限回收**：
```sql
-- 回收权限语法
REVOKE privilege_type ON DATABASE database_name FROM role_name;

-- 实际示例
REVOKE CREATE ON DATABASE prod_db FROM intern_user;
```

### 5.4 默认数据库权限


**理解public角色**：
PostgreSQL中有一个特殊的"public"角色，所有用户都自动是它的成员。

```sql
-- 查看public角色的权限
SELECT datname, datacl FROM pg_database;

-- 回收public的默认权限（提高安全性）
REVOKE CONNECT ON DATABASE mydb FROM public;
```

**安全最佳实践**：
> 💡 **安全建议**：
> - 回收public角色的CONNECT权限
> - 明确授权给特定角色
> - 定期审查数据库权限
> - 使用最小权限原则

---

## 6. 📊 表与schema权限管理


### 6.1 Schema权限概念


**什么是Schema**：
Schema可以理解为数据库中的"文件夹"，用来组织和分类表、视图、函数等对象。

```
数据库结构层次：
Database (数据库)
    ├── Schema1 (模式/命名空间)
    │   ├── Table1
    │   ├── Table2
    │   └── View1
    ├── Schema2
    │   ├── Table3
    │   └── Function1
    └── public (默认schema)
```

### 6.2 Schema级权限


**Schema权限类型**：

| 权限 | 含义 | 实际作用 |
|------|------|----------|
| `USAGE` | 使用权限 | 可以访问schema中的对象 |
| `CREATE` | 创建权限 | 可以在schema中创建新对象 |
| `ALL` | 所有权限 | USAGE + CREATE |

**🔸 Schema权限操作**：
```sql
-- 创建schema
CREATE SCHEMA sales;
CREATE SCHEMA hr;

-- 授予schema使用权限
GRANT USAGE ON SCHEMA sales TO sales_team;

-- 授予schema创建权限
GRANT CREATE ON SCHEMA dev TO developers;

-- 授予所有权限
GRANT ALL ON SCHEMA admin TO admin_users;
```

### 6.3 表级权限管理


**表权限的细分**：
表级权限控制用户对具体表的操作能力，是最常用的权限控制级别。

| 权限 | 操作 | 说明 |
|------|------|------|
| `SELECT` | 查询 | 读取表中的数据 |
| `INSERT` | 插入 | 向表中添加新行 |
| `UPDATE` | 更新 | 修改表中现有数据 |
| `DELETE` | 删除 | 删除表中的行 |
| `TRUNCATE` | 清空 | 快速删除表中所有数据 |
| `REFERENCES` | 引用 | 创建外键引用此表 |
| `TRIGGER` | 触发器 | 在表上创建触发器 |

### 6.4 表权限实际操作


**🔸 单表权限授予**：
```sql
-- 授予单个表的查询权限
GRANT SELECT ON TABLE employees TO hr_staff;

-- 授予多种权限
GRANT SELECT, INSERT, UPDATE ON TABLE products TO sales_team;

-- 授予所有权限
GRANT ALL PRIVILEGES ON TABLE admin_logs TO admin_user;
```

**🔸 批量权限授予**：
```sql
-- 授予schema中所有现有表的权限
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;

-- 授予schema中所有序列的权限
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO app_user;
```

### 6.5 列级权限控制


**列级权限的概念**：
可以控制用户只能访问表中的特定列，实现更细粒度的权限控制。

```sql
-- 只授予特定列的查询权限
GRANT SELECT (name, department) ON employees TO hr_intern;

-- 只授予特定列的更新权限
GRANT UPDATE (salary) ON employees TO payroll_admin;
```

**使用场景**：
```
实际应用场景：
✅ 员工表：HR只能看姓名和部门，不能看薪资
✅ 客户表：销售只能看联系信息，不能看信用评级
✅ 财务表：会计只能看金额，不能看审批记录
```

---

## 7. 🔗 角色继承与成员关系


### 7.1 角色继承概念


**什么是角色继承**：
角色继承就是"子角色自动获得父角色的权限"，类似于面向对象编程中的继承概念。

```
继承关系示意：
    manager_role (父角色)
         ↓ 继承
    team_lead_role (子角色)
         ↓ 继承  
    developer_role (孙角色)

权限流向：manager → team_lead → developer
```

### 7.2 GRANT角色成员关系


**建立成员关系**：
通过GRANT命令可以让一个角色成为另一个角色的成员，从而获得权限。

```sql
-- 基本语法
GRANT parent_role TO child_role;

-- 实际示例
GRANT developers TO alice;
GRANT managers TO bob;
GRANT admin_role TO super_admin;
```

**🔸 复杂继承关系**：
```sql
-- 创建层级角色
CREATE ROLE basic_user;
CREATE ROLE power_user;
CREATE ROLE admin_user;

-- 建立继承链
GRANT basic_user TO power_user;
GRANT power_user TO admin_user;

-- 用户获得所有层级权限
CREATE USER alice LOGIN PASSWORD 'pass123';
GRANT admin_user TO alice;
-- alice现在拥有：admin_user + power_user + basic_user 的所有权限
```

### 7.3 WITH ADMIN OPTION


**管理权限的传递**：
WITH ADMIN OPTION允许被授权的角色再次授权给其他角色。

```sql
-- 授予角色并允许其管理该角色
GRANT developers TO team_leader WITH ADMIN OPTION;

-- 现在team_leader可以：
-- 1. 拥有developers的所有权限
-- 2. 将developers角色授予其他用户
-- 3. 从其他用户回收developers角色
```

### 7.4 角色继承的控制


**INHERIT vs NOINHERIT**：
控制角色是否自动继承其成员角色的权限。

```sql
-- 创建不自动继承权限的角色
CREATE ROLE special_user NOINHERIT LOGIN PASSWORD 'pass123';
GRANT developers TO special_user;

-- special_user需要显式切换角色才能使用developers权限
SET ROLE developers;
```

**使用场景对比**：
```
INHERIT (默认)：
✅ 适合大多数情况
✅ 权限自动生效
✅ 使用简单

NOINHERIT：
✅ 适合需要权限分离的场景
✅ 需要时才激活特定权限
✅ 更高的安全性
```

---

## 8. ⚙️ 默认权限设置


### 8.1 ALTER DEFAULT PRIVILEGES概念


**什么是默认权限**：
默认权限是指"未来创建的对象自动获得的权限"，解决了"后创建的表需要重新授权"的问题。

```
传统方式的问题：
1. 创建表 table1
2. 手动授权给用户A
3. 创建表 table2  
4. 忘记授权给用户A ← 权限缺失！

默认权限的解决：
1. 设置默认权限规则
2. 创建任何新表都自动应用规则
3. 无需手动重复授权
```

### 8.2 默认权限设置


**🔸 基本语法**：
```sql
ALTER DEFAULT PRIVILEGES 
  [FOR ROLE role_name] 
  [IN SCHEMA schema_name] 
  GRANT privileges ON object_type TO role_name;
```

**🔸 实际应用示例**：
```sql
-- 为未来创建的所有表设置默认权限
ALTER DEFAULT PRIVILEGES 
  GRANT SELECT ON TABLES TO readonly_users;

-- 为特定schema中未来的表设置权限
ALTER DEFAULT PRIVILEGES IN SCHEMA sales
  GRANT SELECT, INSERT, UPDATE ON TABLES TO sales_team;

-- 为特定用户创建的对象设置权限
ALTER DEFAULT PRIVILEGES FOR ROLE developer1
  GRANT ALL ON TABLES TO dev_team;
```

### 8.3 各种对象的默认权限


**不同对象类型的默认权限**：

```sql
-- 表的默认权限
ALTER DEFAULT PRIVILEGES GRANT SELECT, INSERT ON TABLES TO app_users;

-- 序列的默认权限
ALTER DEFAULT PRIVILEGES GRANT USAGE, SELECT ON SEQUENCES TO app_users;

-- 函数的默认权限
ALTER DEFAULT PRIVILEGES GRANT EXECUTE ON FUNCTIONS TO app_users;

-- 类型的默认权限
ALTER DEFAULT PRIVILEGES GRANT USAGE ON TYPES TO app_users;
```

### 8.4 查看和管理默认权限


**🔸 查看现有默认权限**：
```sql
-- 查看默认权限设置
SELECT * FROM pg_default_acl;

-- 更友好的查询方式
SELECT 
  pg_get_userbyid(defaclrole) AS role,
  nspname AS schema,
  defaclobjtype AS object_type,
  defaclacl AS privileges
FROM pg_default_acl 
LEFT JOIN pg_namespace ON pg_namespace.oid = defaclnamespace;
```

**🔸 撤销默认权限**：
```sql
-- 撤销默认权限
ALTER DEFAULT PRIVILEGES 
  REVOKE SELECT ON TABLES FROM readonly_users;
```

---

## 9. 🛡️ 行级安全策略RLS


### 9.1 RLS基本概念


**什么是行级安全**：
RLS（Row Level Security）是PostgreSQL的高级安全功能，可以控制用户只能看到或修改表中符合特定条件的行。

```
传统权限控制：
用户要么能访问整个表，要么完全不能访问

RLS权限控制：
用户可以访问表，但只能看到属于自己的行

示例场景：
employees表中，普通员工只能看到自己的记录
managers可以看到自己部门的所有员工记录
HR可以看到所有员工记录
```

### 9.2 启用RLS


**🔸 启用表的行级安全**：
```sql
-- 为表启用RLS
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;

-- 禁用RLS
ALTER TABLE employees DISABLE ROW LEVEL SECURITY;

-- 查看表是否启用了RLS
SELECT tablename, rowsecurity FROM pg_tables WHERE tablename = 'employees';
```

### 9.3 创建安全策略


**策略的基本概念**：
策略定义了"什么用户在什么条件下可以进行什么操作"。

```sql
-- 基本策略语法
CREATE POLICY policy_name ON table_name
  [FOR command]
  [TO role_name]
  [USING (condition)]
  [WITH CHECK (condition)];
```

**🔸 实际策略示例**：
```sql
-- 员工只能看到自己的记录
CREATE POLICY emp_self_policy ON employees
  FOR SELECT
  TO employee_role
  USING (user_name = current_user);

-- 经理可以看到自己部门的记录
CREATE POLICY manager_dept_policy ON employees
  FOR ALL
  TO manager_role
  USING (department = (
    SELECT department FROM employees 
    WHERE user_name = current_user AND role = 'manager'
  ));
```

### 9.4 策略类型详解


**不同操作的策略**：

| 策略类型 | 适用操作 | USING条件 | WITH CHECK条件 |
|----------|----------|-----------|----------------|
| `FOR SELECT` | 查询操作 | 哪些行可见 | 不适用 |
| `FOR INSERT` | 插入操作 | 不适用 | 插入的数据是否满足条件 |
| `FOR UPDATE` | 更新操作 | 哪些行可以更新 | 更新后的数据是否满足条件 |
| `FOR DELETE` | 删除操作 | 哪些行可以删除 | 不适用 |
| `FOR ALL` | 所有操作 | 查询/更新/删除条件 | 插入/更新检查条件 |

### 9.5 实际应用场景


**🔸 多租户应用**：
```sql
-- 租户隔离策略
CREATE POLICY tenant_isolation ON customer_data
  FOR ALL
  TO app_user
  USING (tenant_id = current_setting('app.tenant_id'))
  WITH CHECK (tenant_id = current_setting('app.tenant_id'));

-- 应用中设置租户ID
SET app.tenant_id = '12345';
```

**🔸 数据敏感性控制**：
```sql
-- 根据数据敏感级别控制访问
CREATE POLICY sensitivity_control ON documents
  FOR SELECT
  TO regular_user
  USING (sensitivity_level <= (
    SELECT max_sensitivity_level 
    FROM user_permissions 
    WHERE username = current_user
  ));
```

---

## 10. 🔍 权限查询与管理


### 10.1 系统视图概览


**PostgreSQL权限相关的系统视图**：

| 视图名称 | 作用 | 主要信息 |
|----------|------|----------|
| `pg_roles` | 角色信息 | 角色属性、权限等 |
| `pg_database` | 数据库权限 | 数据库级别的访问控制 |
| `pg_class` | 表权限 | 表、视图等对象的权限 |
| `pg_proc` | 函数权限 | 函数、过程的执行权限 |
| `information_schema.table_privileges` | 表权限详情 | 易读的表权限信息 |
| `information_schema.column_privileges` | 列权限详情 | 列级别权限信息 |

### 10.2 角色信息查询


**🔸 查看所有角色**：
```sql
-- 查看所有角色的基本信息
SELECT 
  rolname AS role_name,
  rolsuper AS is_superuser,
  rolinherit AS can_inherit,
  rolcreaterole AS can_create_role,
  rolcreatedb AS can_create_db,
  rolcanlogin AS can_login,
  rolconnlimit AS connection_limit
FROM pg_roles
ORDER BY rolname;
```

**🔸 查看角色成员关系**：
```sql
-- 查看角色的成员关系
SELECT 
  r.rolname AS role_name,
  m.rolname AS member_of
FROM pg_roles r
JOIN pg_auth_members am ON r.oid = am.member
JOIN pg_roles m ON am.roleid = m.oid
ORDER BY r.rolname;
```

### 10.3 数据库权限查询


**🔸 查看数据库级权限**：
```sql
-- 查看数据库权限
SELECT 
  datname AS database_name,
  datacl AS access_privileges
FROM pg_database
WHERE datname NOT IN ('template0', 'template1')
ORDER BY datname;

-- 解析权限的友好查询
SELECT 
  datname,
  (aclexplode(datacl)).grantee::regrole AS grantee,
  (aclexplode(datacl)).privilege_type AS privilege
FROM pg_database
WHERE datname = 'your_database_name';
```

### 10.4 表和列权限查询


**🔸 查看表权限**：
```sql
-- 使用information_schema查看表权限
SELECT 
  table_schema,
  table_name,
  grantee,
  privilege_type,
  is_grantable
FROM information_schema.table_privileges
WHERE table_schema = 'public'
ORDER BY table_name, grantee;
```

**🔸 查看列权限**：
```sql
-- 查看列级权限
SELECT 
  table_schema,
  table_name,
  column_name,
  grantee,
  privilege_type
FROM information_schema.column_privileges
WHERE table_schema = 'public'
ORDER BY table_name, column_name;
```

### 10.5 实用权限管理函数


**🔸 检查用户权限的实用函数**：
```sql
-- 检查用户是否有特定权限
SELECT has_database_privilege('alice', 'mydb', 'CONNECT');
SELECT has_schema_privilege('alice', 'public', 'USAGE');
SELECT has_table_privilege('alice', 'employees', 'SELECT');
SELECT has_column_privilege('alice', 'employees', 'salary', 'SELECT');

-- 获取当前用户的权限
SELECT current_user, session_user;
SELECT pg_has_role('alice', 'developers', 'MEMBER');
```

**🔸 权限审计查询**：
```sql
-- 生成权限审计报告
WITH role_permissions AS (
  SELECT 
    r.rolname,
    CASE 
      WHEN r.rolsuper THEN 'SUPERUSER'
      WHEN r.rolcreaterole THEN 'CREATE_ROLE'
      WHEN r.rolcreatedb THEN 'CREATE_DB'
      ELSE 'NORMAL'
    END AS permission_level
  FROM pg_roles r
  WHERE r.rolcanlogin = true
)
SELECT * FROM role_permissions
ORDER BY permission_level DESC, rolname;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 角色统一性：PostgreSQL中用户和组都是角色，区别在于LOGIN权限
🔸 权限层级：数据库 → Schema → 表 → 列，权限层层递进
🔸 继承机制：角色可以继承其他角色的权限，形成权限传递链
🔸 默认权限：为未来对象预设权限，避免遗漏授权
🔸 行级安全：表级权限之外的行级控制，实现精细化权限管理
```

### 11.2 关键操作要点


**🔹 角色管理最佳实践**：
```
创建原则：
✅ 用户角色只设置LOGIN权限和密码
✅ 组角色承载具体权限，不设LOGIN
✅ 通过成员关系而非直接授权分配权限
✅ 使用有意义的命名规范

权限分配：
✅ 遵循最小权限原则
✅ 定期审查和清理无用权限
✅ 使用默认权限简化管理
✅ 重要操作使用行级安全控制
```

**🔹 安全配置要点**：
```
认证安全：
- 使用强密码策略
- 配置合适的认证方式
- 限制连接来源和数量
- 回收public角色的默认权限

权限安全：
- 避免使用SUPERUSER权限
- 定期轮换密码
- 监控权限变更
- 使用RLS保护敏感数据
```

### 11.3 实际应用指导


**权限设计模式**：
```
🎯 按部门分组：
CREATE ROLE hr_team;
CREATE ROLE finance_team;
CREATE ROLE it_team;

🎯 按职能分级：
CREATE ROLE readonly_users;
CREATE ROLE readwrite_users;  
CREATE ROLE admin_users;

🎯 按项目分离：
CREATE ROLE project_a_team;
CREATE ROLE project_b_team;
```

**故障排查思路**：
```
权限问题排查步骤：
1. 确认用户角色是否存在且有LOGIN权限
2. 检查数据库级CONNECT权限
3. 检查Schema级USAGE权限
4. 检查表级具体权限
5. 检查是否启用了RLS并有相应策略
6. 确认角色继承关系是否正确
```

### 11.4 常用管理命令速查


**日常管理命令**：
```sql
-- 用户管理
CREATE USER username LOGIN PASSWORD 'password';
ALTER USER username PASSWORD 'new_password';
DROP USER username;

-- 权限管理
GRANT role_name TO user_name;
REVOKE role_name FROM user_name;
GRANT privilege ON object TO role;

-- 权限查询
\du                           -- 查看所有角色
\l                           -- 查看数据库列表
\dp table_name               -- 查看表权限
\dn+                         -- 查看schema权限
```

**核心记忆**：
- PostgreSQL权限管理以角色为核心，灵活而统一
- 权限分层设计：数据库→Schema→表→列→行
- 继承机制让权限管理更加高效
- 安全策略要结合业务需求，平衡安全性和易用性