---
title: 2、SELinux架构与工作原理
---
## 📚 目录

1. [SELinux核心概念](#1-SELinux核心概念)
2. [SELinux内核模块架构](#2-SELinux内核模块架构)
3. [安全策略决策过程](#3-安全策略决策过程)
4. [三种访问控制机制](#4-三种访问控制机制)
5. [安全上下文标签系统](#5-安全上下文标签系统)
6. [策略规则匹配机制](#6-策略规则匹配机制)
7. [AVC访问向量缓存](#7-AVC访问向量缓存)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛡️ SELinux核心概念


### 1.1 什么是SELinux


**🔸 SELinux基本定义**
```
SELinux = Security-Enhanced Linux（安全增强Linux）
本质：一套强制访问控制(MAC)安全机制
目标：即使程序被攻破，也限制其能造成的损害
原理：给系统中每个对象都贴上"安全标签"
```

**💡 为什么需要SELinux**

传统Linux的问题就像这样：
```
传统访问控制（DAC）问题：
用户A创建文件 → 用户A完全控制这个文件
程序以用户身份运行 → 程序拥有用户的所有权限

问题场景：
Web服务以root运行 → 被攻破后攻击者获得root权限
普通用户程序 → 可以访问用户目录下所有文件
```

SELinux的解决方案：
```
强制访问控制（MAC）：
不管你是谁，都要遵守系统预定义的安全规则
即使是root用户，也不能随意访问被保护的资源
每个进程只能做被明确允许的操作
```

### 1.2 SELinux的核心思想


**🎯 核心原理**
```
默认拒绝原则：
• 没有明确允许的操作，一律禁止
• 最小权限原则：程序只获得必需的最小权限
• 标签化管理：所有对象都有安全标签

举例理解：
传统方式：门默认开着，需要时关门
SELinux：门默认关着，需要时开门
```

---

## 2. 🏗️ SELinux内核模块架构


### 2.1 整体架构图


```
┌─────────────────────────────────────┐
│           用户空间                   │
│  ┌─────────┐  ┌─────────┐  ┌──────┐ │
│  │安全策略│  │管理工具│  │应用程序│ │
│  │文件    │  │semanage│  │httpd  │ │
│  └─────────┘  └─────────┘  └──────┘ │
└─────────────┬───────────────────────┘
              │ 系统调用接口
┌─────────────┴───────────────────────┐
│           内核空间                   │
│  ┌─────────────────────────────────┐ │
│  │      LSM (Linux Security       │ │
│  │       Module) 框架             │ │
│  │  ┌─────────────────────────┐   │ │
│  │  │    SELinux 安全模块     │   │ │
│  │  │  ┌─────┐  ┌─────┐      │   │ │
│  │  │  │ AVC │  │策略│      │   │ │
│  │  │  │缓存 │  │引擎│      │   │ │
│  │  │  └─────┘  └─────┘      │   │ │
│  │  └─────────────────────────┘   │ │
│  └─────────────────────────────────┘ │
│           内核其他部分               │
└─────────────────────────────────────┘
```

### 2.2 核心组件详解


**🔧 LSM（Linux Security Module）框架**
```
作用：提供安全钩子(Security Hook)机制
位置：在内核关键操作点设置检查点
时机：在实际操作执行前进行安全检查

钩子示例：
• 文件打开前 → security_file_open()
• 进程创建前 → security_task_create()
• 网络连接前 → security_socket_connect()
```

**⚡ SELinux安全模块**
```
策略引擎：
• 加载和解析安全策略
• 根据策略规则做出访问决策
• 维护安全上下文信息

AVC缓存：
• 缓存访问决策结果
• 提高重复访问的性能
• 避免重复的策略查询
```

### 2.3 工作流程


**📊 访问控制流程**
```
用户程序请求访问文件
           ↓
    内核接收系统调用
           ↓
    LSM框架拦截请求
           ↓
   SELinux模块检查权限
           ↓
      查询AVC缓存
           ↓
    有缓存？ ┌─是→ 返回缓存结果
           └─否↓
      查询策略引擎
           ↓
     根据策略规则决策
           ↓
    结果存入AVC缓存
           ↓
      返回允许/拒绝
```

---

## 3. 🔍 安全策略决策过程


### 3.1 决策的核心要素


**🎯 决策需要的信息**
```
主体信息：
• 源安全上下文（谁在请求）
• 源域类型（进程的域）
• 源角色（进程的角色）

客体信息：
• 目标安全上下文（要访问什么）
• 目标类型（资源的类型）
• 目标类别（资源的分类）

操作信息：
• 访问类型（读/写/执行）
• 操作权限（open/read/write）
```

### 3.2 决策过程详解


**⚡ 策略匹配流程**
```
步骤1：提取安全上下文
进程：system_u:system_r:httpd_t:s0
文件：system_u:object_r:httpd_config_t:s0

步骤2：匹配TE规则
查找规则：allow httpd_t httpd_config_t:file read;

步骤3：检查RBAC规则
验证角色：system_r 是否能操作 object_r

步骤4：检查MLS约束
验证级别：s0 是否能访问 s0

步骤5：综合决策
所有检查通过 → 允许访问
任一检查失败 → 拒绝访问
```

**💡 决策示例**
```
场景：Apache进程要读取配置文件

检查过程：
1. 进程上下文：httpd_t（Apache域）
2. 文件上下文：httpd_config_t（配置文件类型）
3. 操作类型：read（读取）
4. 查找规则：allow httpd_t httpd_config_t:file read;
5. 规则存在 → 允许访问

如果Apache要访问用户家目录：
1. 进程上下文：httpd_t
2. 文件上下文：user_home_t
3. 操作类型：read
4. 查找规则：allow httpd_t user_home_t:file read;
5. 规则不存在 → 拒绝访问
```

---

## 4. 🔐 三种访问控制机制


### 4.1 类型强制TE访问控制


**🔸 TE核心概念**
```
TE = Type Enforcement（类型强制）
原理：给每个对象分配类型，定义类型间的访问规则
特点：最核心、最常用的访问控制机制

类型分类：
• 域类型（Domain Type）：进程的类型
• 文件类型（File Type）：文件系统对象的类型
• 端口类型（Port Type）：网络端口的类型
```

**💡 TE规则格式**
```bash
# 基本语法
allow 主体类型 客体类型:对象类别 权限集合;

# 实际示例
allow httpd_t httpd_config_t:file read;
# 解读：允许httpd_t类型的进程读取httpd_config_t类型的文件

allow httpd_t http_port_t:tcp_socket name_bind;
# 解读：允许httpd_t类型的进程绑定http_port_t类型的TCP端口
```

**📊 常用权限示例**
| 对象类别 | 权限示例 | 含义说明 |
|---------|---------|---------|
| file | `read write execute` | 文件读写执行 |
| dir | `search add_name remove_name` | 目录搜索、创建文件、删除文件 |
| process | `fork exec signal` | 进程分叉、执行、发信号 |
| tcp_socket | `create bind listen accept` | TCP套接字操作 |

### 4.2 基于角色的访问控制RBAC


**🔸 RBAC核心概念**
```
RBAC = Role-Based Access Control（基于角色的访问控制）
原理：用户→角色→类型的三层映射关系
目的：用户权限管理，通常用于多用户环境
```

**🏗️ RBAC层次结构**
```
用户层(User)：
• system_u（系统用户）
• user_u（普通用户）
• root（超级用户）
        ↓
角色层(Role)：
• system_r（系统角色）
• user_r（用户角色）
• unconfined_r（不受限角色）
        ↓
类型层(Type)：
• 各种域类型和文件类型
```

**💡 RBAC规则示例**
```bash
# 用户角色映射
user user_u roles { user_r };
user system_u roles { system_r };

# 角色类型映射
role user_r types { user_t user_home_t };
role system_r types { httpd_t kernel_t };

# 实际含义：
# user_u用户只能使用user_r角色
# user_r角色只能操作user_t等类型的对象
```

### 4.3 多级安全MLS模型


**🔸 MLS核心概念**
```
MLS = Multi-Level Security（多级安全）
原理：给对象分配安全级别，高级别能读低级别，低级别不能读高级别
应用：主要用于军事、政府等高安全要求环境

安全级别：
s0 < s1 < s2 < ... < s15（16个级别）
```

**🎯 MLS规则**
```
Bell-LaPadula模型：
• No Read Up：不能读取比自己级别高的信息
• No Write Down：不能向比自己级别低的地方写信息

示例：
进程级别s2，文件级别s1 → 可以读取（s2 > s1）
进程级别s1，文件级别s2 → 不能读取（s1 < s2）
```

**⚠️ 注意事项**
> **💡 重要提示：** MLS在大多数常规系统中是禁用的，只有特殊安全需求才会启用

---

## 5. 🏷️ 安全上下文标签系统


### 5.1 安全上下文格式


**📋 标准格式**
```
用户:角色:类型:级别
user:role:type:level

实际示例：
system_u:system_r:httpd_t:s0
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

### 5.2 各部分详细解释


**👤 用户部分(User)**
```
system_u：系统进程使用
unconfined_u：不受限用户
user_u：受限用户
root：root用户
```

**🎭 角色部分(Role)**
```
system_r：系统角色（大多数系统服务）
unconfined_r：不受限角色（管理员操作）
user_r：普通用户角色
object_r：文件对象角色
```

**🏷️ 类型部分(Type)**
```
进程类型：
• httpd_t：Apache进程
• sshd_t：SSH服务进程
• user_t：用户进程

文件类型：
• httpd_config_t：Apache配置文件
• user_home_t：用户家目录文件
• bin_t：可执行文件
```

### 5.3 查看安全上下文


**🔍 常用查看命令**
```bash
# 查看文件的安全上下文
ls -Z /etc/httpd/conf/httpd.conf
-rw-r--r--. root root system_u:object_r:httpd_config_t:s0 httpd.conf

# 查看进程的安全上下文
ps -eZ | grep httpd
system_u:system_r:httpd_t:s0    1234 ?        httpd

# 查看当前用户的安全上下文
id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

---

## 6. ⚙️ 策略规则匹配机制


### 6.1 规则匹配过程


**🔍 匹配算法**
```
输入：主体上下文 + 客体上下文 + 权限
输出：允许/拒绝

匹配步骤：
1. 提取主体类型（from 主体上下文）
2. 提取客体类型（from 客体上下文）  
3. 确定对象类别（文件、套接字、进程等）
4. 在策略规则库中搜索匹配的allow规则
5. 找到匹配规则 → 允许，否则 → 拒绝
```

### 6.2 规则类型


**✅ Allow规则**
```bash
# 允许规则
allow httpd_t httpd_config_t:file { read open getattr };

# 含义：允许httpd_t类型的进程对httpd_config_t类型的文件
# 执行读取、打开、获取属性的操作
```

**❌ Deny规则（较少使用）**
```bash
# 拒绝规则（优先级高于allow）
deny user_t admin_home_t:file { read write };
```

**🔀 转换规则**
```bash
# 类型转换规则
type_transition httpd_t httpd_config_t:file httpd_log_t;

# 含义：当httpd_t创建httpd_config_t类型目录中的文件时
# 新文件的类型自动设置为httpd_log_t
```

### 6.3 规则优化机制


**⚡ 宏定义**
```bash
# 定义宏来简化规则编写
define(`web_domain', `
    allow $1 httpd_config_t:file read;
    allow $1 http_port_t:tcp_socket name_bind;
')

# 使用宏
web_domain(httpd_t)
web_domain(nginx_t)
```

---

## 7. 🚀 AVC访问向量缓存


### 7.1 AVC缓存机制


**🔸 AVC基本概念**
```
AVC = Access Vector Cache（访问向量缓存）
目的：缓存安全决策结果，提高性能
原理：相同的访问请求直接返回缓存结果，无需重新决策

缓存内容：
• 主体上下文 + 客体上下文 + 权限 → 决策结果
• 缓存项有时间戳和有效期
```

### 7.2 缓存工作流程


**📊 AVC缓存流程**
```
访问请求进入
       ↓
  查询AVC缓存
       ↓
  缓存命中？ ┌─是→ 返回缓存结果（快速）
       └─否↓
   查询策略引擎
       ↓
   策略引擎决策
       ↓
   结果存入缓存
       ↓
   返回决策结果
```

### 7.3 缓存性能优化


**⚡ 性能数据**
```
缓存命中率：通常 > 95%
性能提升：缓存访问比策略查询快 10-100 倍
内存占用：通常几MB到几十MB

缓存统计查看：
# 查看AVC缓存统计
cat /sys/fs/selinux/avc/cache_stats
lookups hits misses allocations reclaims frees
```

**🔧 缓存管理**
```bash
# 清空AVC缓存（重新加载策略后自动清空）
echo 1 > /sys/fs/selinux/avc/cache_threshold

# 调整缓存大小（内核参数）
echo 2048 > /sys/fs/selinux/avc/hash_stats
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 SELinux本质：强制访问控制系统，默认拒绝原则
🔸 架构组成：LSM框架 + SELinux模块 + AVC缓存 + 策略引擎
🔸 三种机制：TE类型强制 + RBAC角色控制 + MLS多级安全
🔸 安全上下文：用户:角色:类型:级别 四元组标签
🔸 决策过程：上下文匹配 + 规则查找 + 权限检查 + 缓存优化
```

### 8.2 关键理解要点


**🔹 为什么SELinux如此安全**
```
传统DAC问题：用户权限过大，程序继承用户权限
SELinux解决方案：
• 最小权限：程序只能做被明确允许的操作
• 标签隔离：不同类型的对象天然隔离
• 深度防御：即使root被攻破也受到限制
```

**🔹 SELinux的核心价值**
```
安全增强：
• 零日漏洞利用困难：攻击者权限被严格限制
• 内部威胁防护：管理员权限也受到约束
• 合规性支持：满足高等级安全认证要求

性能平衡：
• AVC缓存：95%以上命中率，性能影响很小
• 内核集成：安全检查在内核层，开销最小
```

**🔹 三种控制机制的关系**
```
实际应用中的重要性：
TE类型强制：🌟🌟🌟🌟🌟（最核心，日常主要使用）
RBAC角色控制：🌟🌟🌟（多用户环境重要）
MLS多级安全：🌟（特殊环境才用，大部分系统禁用）
```

### 8.3 实际应用指导


**💡 学习建议**
```
学习顺序：
1. 理解基本概念和架构
2. 掌握安全上下文格式
3. 学会查看和分析TE规则
4. 练习故障排查和策略调整

重点关注：
• TE规则是核心，必须熟练掌握
• 安全上下文是基础，要能快速理解
• AVC缓存影响性能，了解即可
• MLS在常规环境很少用，可以略过
```

**🔧 实践要点**
```
日常运维：
• 查看上下文：ls -Z, ps -eZ, id -Z
• 分析日志：/var/log/audit/audit.log
• 测试工具：sesearch, seinfo命令
• 策略管理：setsebool, semanage命令
```

**核心记忆口诀**：
```
SELinux架构记忆：
"LSM钩子拦截忙，SELinux模块来帮忙"
"AVC缓存提速度，策略引擎做决断"
"用户角色类型级，四个标签定乾坤"
"TE规则是核心，允许拒绝有门道"
```