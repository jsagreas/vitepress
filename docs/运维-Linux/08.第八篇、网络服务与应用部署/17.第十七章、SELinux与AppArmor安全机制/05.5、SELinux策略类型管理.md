---
title: 5、SELinux策略类型管理
---
## 📚 目录

1. [SELinux策略系统概述](#1-selinux策略系统概述)
2. [targeted目标策略详解](#2-targeted目标策略详解)
3. [strict严格策略配置](#3-strict严格策略配置)
4. [mls多级安全策略](#4-mls多级安全策略)
5. [策略模块管理机制](#5-策略模块管理机制)
6. [semodule策略模块操作](#6-semodule策略模块操作)
7. [自定义策略编写基础](#7-自定义策略编写基础)
8. [策略编译安装流程](#8-策略编译安装流程)
9. [策略版本管理](#9-策略版本管理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🛡️ SELinux策略系统概述


### 1.1 什么是SELinux策略


**🔸 基本概念理解**
SELinux策略就像是系统安全的"法律条文"，它定义了系统中每个进程、文件、用户能做什么，不能做什么。简单来说，策略决定了谁可以访问什么资源。

```
传统权限 vs SELinux策略对比：

传统Linux权限（DAC）：
用户alice拥有文件test.txt → alice可以读写这个文件
问题：如果alice被恶意程序控制，程序也能访问alice的所有文件

SELinux策略（MAC）：
即使alice拥有文件，但如果策略规定"web进程不能读用户家目录"
那么运行在web进程中的恶意代码也无法访问alice的文件
```

### 1.2 SELinux策略的三大核心


**🔧 策略架构组成**
```
策略架构图：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  用户映射   │    │  角色定义   │    │  类型标识   │
│   (user)    │───▶│   (role)    │───▶│   (type)    │
└─────────────┘    └─────────────┘    └─────────────┘
       │                   │                   │
       ▼                   ▼                   ▼
   谁在操作?            以什么身份?          访问什么对象?

实际例子：
用户：system_u (系统用户)
角色：system_r (系统角色) 
类型：httpd_t (Apache进程类型)
```

### 1.3 策略决定访问控制


**⚖️ 访问控制决策流程**
```
访问请求流程：
进程访问文件 ────┐
                 ▼
            ┌─────────┐
            │  内核   │
            └─────────┘
                 │
                 ▼
         检查传统权限(DAC)
                 │
                 ▼
         检查SELinux策略(MAC)
                 │
         ┌───────┴───────┐
         ▼               ▼
    策略允许            策略拒绝
      │                 │
      ▼                 ▼
   访问成功           访问被拒绝
                    (记录到日志)
```

---

## 2. 🎯 targeted目标策略详解


### 2.1 targeted策略的设计思想


**💡 什么是targeted策略**
targeted策略是SELinux中最常用的策略类型，它的设计理念是"**重点保护，适度宽松**"。不像strict策略那样严格控制所有进程，targeted只对高风险的网络服务进程实施强制访问控制。

| 策略类型 | **保护范围** | **用户体验** | **安全级别** |
|---------|-------------|-------------|-------------|
| `targeted` | 网络服务进程 | 用户感知较少 | 中等 |
| `strict` | 所有进程 | 限制较多 | 最高 |
| `mls` | 分级保护 | 复杂配置 | 很高 |

### 2.2 targeted策略保护的服务


**🔸 重点保护对象**
targeted策略主要保护这些容易被攻击的服务：

- **Web服务**：`httpd_t` (Apache)、`nginx_t` (Nginx)
- **数据库**：`mysqld_t` (MySQL)、`postgresql_t` (PostgreSQL)  
- **邮件服务**：`postfix_t` (Postfix)、`dovecot_t` (Dovecot)
- **DNS服务**：`named_t` (BIND)
- **FTP服务**：`ftpd_t` (vsftpd)
- **SSH服务**：`sshd_t` (OpenSSH)

### 2.3 查看targeted策略状态


**🔍 检查策略配置**
```bash
# 查看当前策略类型
sestatus | grep "Policy"

# 查看策略版本信息  
cat /etc/selinux/config

# 列出所有可用策略
ls -la /etc/selinux/
```

### 2.4 targeted策略的工作模式


**⚙️ 受限域与非受限域**
```
域的概念图解：
┌──────────────────────────────────────┐
│           用户空间                    │
│  ┌─────────────┐    ┌─────────────┐   │
│  │ 非受限域    │    │  受限域     │   │
│  │unconfined_t │    │  httpd_t    │   │
│  │(用户进程)   │    │ (Apache)    │   │
│  │             │    │             │   │
│  │自由访问大部分│    │严格限制访问 │   │
│  │系统资源     │    │特定资源     │   │
│  └─────────────┘    └─────────────┘   │
└──────────────────────────────────────┘

实际效果：
- 普通用户程序：几乎不受SELinux限制
- Apache进程：只能访问Web相关文件和端口
```

---

## 3. 🔒 strict严格策略配置


### 3.1 strict策略的特点


**⚠️ 全面强制访问控制**
strict策略是SELinux最严格的策略类型，它对系统中**每一个进程**都实施强制访问控制，包括用户的日常操作。

```
strict vs targeted 对比：

用户登录场景：
targeted策略：
  用户 → 登录shell → unconfined_t域 → 自由操作

strict策略：  
  用户 → 登录shell → user_t域 → 受限操作
  ↓
  需要明确的策略规则才能访问文件
```

### 3.2 启用strict策略


> ⚠️ **重要警告**：切换到strict策略前务必做好系统备份，错误配置可能导致系统无法使用

**🔧 策略切换步骤**
1. **备份当前配置**
2. **修改策略配置文件**
3. **重新标记文件系统**
4. **重启系统验证**

修改配置文件 `/etc/selinux/config`：
```ini
SELINUX=enforcing
SELINUXTYPE=strict
```

### 3.3 strict策略的用户角色


**👥 用户角色分类**
strict策略将用户分为不同角色，每个角色有特定的权限：

| 用户角色 | **SELinux用户** | **允许操作** | **适用场景** |
|---------|----------------|-------------|-------------|
| `unconfined_r` | `unconfined_u` | 管理员级别 | 系统管理员 |
| `sysadm_r` | `sysadm_u` | 系统管理 | 系统管理员 |
| `user_r` | `user_u` | 一般用户操作 | 普通用户 |
| `guest_r` | `guest_u` | 受限用户 | 临时用户 |

### 3.4 strict策略用户管理


**🔧 用户映射配置**
```bash
# 查看SELinux用户映射
semanage login -l

# 将Linux用户映射到SELinux用户
semanage login -a -s sysadm_u admin_user

# 查看用户当前的安全上下文
id -Z
```

---

## 4. 🏢 mls多级安全策略


### 4.1 MLS安全模型理解


**📊 多级安全概念**
MLS（Multi-Level Security）多级安全策略基于军用安全模型，将信息按照敏感级别分类，确保高级别信息不会泄露给低级别用户。

```
MLS安全级别模型：
┌─────────────────────────────────┐ ← 绝密 (Top Secret)
│          s3:c0.c1023            │
├─────────────────────────────────┤ ← 机密 (Secret)  
│          s2:c0.c1023            │
├─────────────────────────────────┤ ← 限制 (Confidential)
│          s1:c0.c1023            │ 
├─────────────────────────────────┤ ← 非密 (Unclassified)
│          s0:c0.c1023            │
└─────────────────────────────────┘

访问规则：
- 向上读取：低级别可以读取同级或更高级别
- 向下写入：高级别可以写入同级或更低级别
- 同级别：可以读写同级别信息
```

### 4.2 MLS标签格式


**🔸 安全标签结构**
MLS安全标签格式：`sensitivity:category`

```
标签格式解析：
s0:c0,c1,c5        # 敏感级别s0，类别c0,c1,c5
s2:c0.c100         # 敏感级别s2，类别c0到c100
s1                 # 敏感级别s1，无特定类别

实际应用示例：
财务部门文件：s2:c10,c20 (机密级别，财务类别)
人事部门文件：s2:c30,c40 (机密级别，人事类别)  
公开文档：s0 (非密级别)
```

### 4.3 启用MLS策略


**⚙️ MLS策略配置**
修改 `/etc/selinux/config` 文件：
```ini
SELINUX=enforcing
SELINUXTYPE=mls
```

重启系统后，需要重新标记文件系统：
```bash
# 重新标记文件系统（重启后自动执行）
touch /.autorelabel
reboot
```

### 4.4 MLS实际应用场景


**🎯 典型应用环境**
- **政府机构**：处理不同密级的公文
- **军事系统**：分级保护军事信息
- **金融机构**：隔离不同业务数据
- **医疗系统**：保护不同级别的患者信息

---

## 5. 🧩 策略模块管理机制


### 5.1 策略模块化设计


**💡 模块化的优势**
SELinux采用模块化设计，将整个策略分解为多个独立的模块，每个模块负责特定的功能域。这种设计带来诸多好处：

- **易于管理**：可以独立启用/禁用特定功能
- **便于定制**：根据需要添加或删除模块  
- **降低复杂性**：每个模块专注于特定服务
- **便于维护**：模块独立更新，不影响整体策略

### 5.2 策略模块的层次结构


**📊 模块分层架构**
```
SELinux策略模块层次：
┌─────────────────────────────────────┐
│              应用模块                │ ← 自定义应用策略
├─────────────────────────────────────┤
│              服务模块                │ ← Apache, MySQL等
├─────────────────────────────────────┤  
│              系统模块                │ ← 核心系统功能
├─────────────────────────────────────┤
│              基础模块                │ ← 基本类型和权限
└─────────────────────────────────────┘

依赖关系：
高层模块 ──depends──> 低层模块
```

### 5.3 查看已安装模块


**🔍 模块状态检查**
```bash
# 列出所有已安装的策略模块
semodule -l

# 查看模块详细信息
semodule -l -v

# 检查特定模块状态
semodule -l | grep apache
```

典型输出示例：
```
apache          1.13.1    # Apache Web服务器模块
mysql           1.13.1    # MySQL数据库模块  
ssh             1.13.1    # SSH服务模块
```

### 5.4 模块依赖关系


**🔗 依赖管理**
策略模块之间存在复杂的依赖关系，基础模块为上层模块提供基本类型和接口定义。

查看模块依赖：
```bash
# 查看模块信息（包括依赖）
seinfo -t | grep httpd    # 查看HTTP相关类型
seinfo --common           # 查看通用权限类
```

---

## 6. ⚙️ semodule策略模块操作


### 6.1 semodule命令详解


**🔧 核心命令参数**
semodule是管理SELinux策略模块的主要工具，掌握其用法对策略管理至关重要。

| 参数选项 | **功能说明** | **使用场景** |
|---------|-------------|-------------|
| `-l` | 列出模块 | 查看已安装模块 |
| `-i` | 安装模块 | 安装新策略模块 |
| `-r` | 删除模块 | 移除不需要的模块 |
| `-u` | 升级模块 | 更新模块版本 |
| `-e` | 启用模块 | 激活已安装模块 |
| `-d` | 禁用模块 | 临时关闭模块 |

### 6.2 安装自定义模块


**📦 模块安装流程**
```bash
# 安装策略模块(.pp文件)
semodule -i myapp.pp

# 同时安装多个模块
semodule -i module1.pp -i module2.pp

# 强制安装(忽略版本检查)
semodule -i --force myapp.pp

# 验证安装结果
semodule -l | grep myapp
```

### 6.3 模块版本管理


**📝 版本控制操作**
```bash
# 升级现有模块
semodule -u myapp_v2.pp

# 查看模块版本历史
semodule -l -v | grep myapp

# 回滚到之前版本（需要保存旧版本文件）
semodule -r myapp
semodule -i myapp_v1.pp
```

### 6.4 批量模块操作


**⚡ 高效管理技巧**
```bash
# 禁用多个不需要的模块
semodule -d bluetooth -d cups -d games

# 重新启用模块
semodule -e bluetooth

# 获取模块包文件
semodule -x module_name  # 导出模块为.pp文件
```

---

## 7. ✍️ 自定义策略编写基础


### 7.1 策略语言基础


**📝 策略语法入门**
SELinux策略使用特定的语言描述访问控制规则。虽然语法看起来复杂，但掌握基本模式后就能编写简单的策略。

**基本语法结构**：
```
allow source_type target_type:class permissions;

解释：
- source_type: 发起访问的进程类型
- target_type: 被访问的对象类型  
- class: 对象类别(file, dir, socket等)
- permissions: 具体权限(read, write, execute等)
```

### 7.2 策略模块文件结构


**📄 .te文件基本框架**
创建一个简单的策略模块文件 `myapp.te`：

```te
# 策略版本声明
policy_module(myapp, 1.0.0)

# 类型声明
type myapp_t;
type myapp_exec_t;  
type myapp_var_t;

# 基础类型继承
application_domain(myapp_t, myapp_exec_t)

# 访问规则
allow myapp_t myapp_var_t:file { read write create unlink };
allow myapp_t myapp_var_t:dir { read write add_name remove_name };
```

### 7.3 常用策略模式


**🔧 典型策略模板**
```te
# 1. 网络服务基本模板
allow myapp_t port_t:tcp_socket name_bind;      # 绑定端口
allow myapp_t self:tcp_socket { bind listen accept };  # TCP操作

# 2. 文件访问模板  
allow myapp_t myapp_config_t:file { read getattr };     # 读取配置
allow myapp_t myapp_log_t:file { write create append }; # 写入日志

# 3. 进程间通信
allow myapp_t self:unix_stream_socket { create bind listen accept };
```

### 7.4 策略调试技巧


**🔍 开发调试方法**
使用 `audit2allow` 工具根据拒绝日志生成策略规则：

```bash
# 查看拒绝日志
grep myapp /var/log/audit/audit.log | grep denied

# 根据日志自动生成策略  
grep myapp /var/log/audit/audit.log | audit2allow -M myapp_fix

# 检查生成的策略
cat myapp_fix.te
```

---

## 8. 🔨 策略编译安装流程


### 8.1 策略编译环境准备


**📦 安装必要工具**
```bash
# 安装策略开发工具包
yum install selinux-policy-devel   # RHEL/CentOS
apt install selinux-policy-dev     # Ubuntu/Debian

# 验证安装
ls /usr/share/selinux/devel/
```

### 8.2 编译策略模块


**⚙️ 编译步骤详解**
```bash
# 1. 准备源文件
ls myapp.*
# 应该有: myapp.te (策略规则)
#        myapp.fc (文件上下文，可选)
#        myapp.if (接口定义，可选)

# 2. 编译策略模块
make -f /usr/share/selinux/devel/Makefile myapp.pp

# 3. 检查编译结果
ls -la myapp.pp
file myapp.pp  # 应显示为策略包文件
```

### 8.3 安装测试流程


**✅ 安装验证步骤**
```bash
# 1. 安装编译好的模块
semodule -i myapp.pp

# 2. 验证安装
semodule -l | grep myapp

# 3. 查看策略是否生效
sesearch -A -s myapp_t  # 查看myapp_t相关规则

# 4. 测试实际应用
# 启动应用，观察是否有拒绝日志
tail -f /var/log/audit/audit.log | grep myapp
```

### 8.4 策略更新维护


**🔄 版本更新流程**
```bash
# 修改策略版本号 (myapp.te中)
policy_module(myapp, 1.0.1)

# 重新编译
make -f /usr/share/selinux/devel/Makefile myapp.pp

# 升级安装
semodule -u myapp.pp

# 验证更新
semodule -l -v | grep myapp
```

---

## 9. 📊 策略版本管理


### 9.1 策略版本控制概念


**🔖 版本管理重要性**
SELinux策略版本管理确保系统安全策略的可追溯性和可回滚性，特别是在生产环境中，版本管理是必不可少的。

```
版本管理流程：
开发版本 → 测试验证 → 生产部署 → 监控反馈
    ↓           ↓           ↓           ↓
  v1.0.0     v1.0.0-rc    v1.0.0     问题修复
                 ↓           ↑           ↓
              修复测试      回滚       v1.0.1
```

### 9.2 查看策略版本信息


**🔍 版本信息查询**
```bash
# 查看整体策略版本
sestatus | grep "Policy version"

# 查看所有模块版本
semodule -l -v

# 查看特定模块版本历史
semodule -l -v | grep "^apache"

# 查看策略构建信息
seinfo --stats
```

### 9.3 策略备份与恢复


**💾 备份策略**
```bash
# 备份当前所有策略模块
mkdir -p /backup/selinux/$(date +%Y%m%d)
cd /backup/selinux/$(date +%Y%m%d)

# 导出所有模块
for module in $(semodule -l | awk '{print $1}'); do
    semodule -x $module
done

# 备份策略配置
cp /etc/selinux/config config.backup
```

**🔄 恢复策略**
```bash
# 恢复特定模块
semodule -i /backup/selinux/20241201/myapp.pp

# 批量恢复模块
cd /backup/selinux/20241201
for pp_file in *.pp; do
    echo "恢复模块: $pp_file"
    semodule -i "$pp_file"
done
```

### 9.4 策略变更管理


**📝 变更记录最佳实践**
```bash
# 创建变更日志
cat > /etc/selinux/change.log << 'EOF'
[2024-12-01] v1.0.0 初始化myapp策略模块
[2024-12-02] v1.0.1 增加网络访问权限  
[2024-12-03] v1.0.2 修复文件访问问题
EOF

# 策略变更前检查
echo "变更前策略状态:" >> /var/log/selinux-changes.log
semodule -l -v | grep myapp >> /var/log/selinux-changes.log
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 策略类型选择：targeted适合大多数场景，strict最安全但复杂
🔸 模块化管理：策略分模块管理，便于维护和定制
🔸 semodule工具：策略模块管理的核心命令
🔸 策略编写：掌握基本语法，能编写简单策略规则
🔸 版本控制：策略变更需要版本管理和备份机制
```

### 10.2 关键理解要点


**🔹 策略类型选择原则**
```
选择依据：
• 安全需求：targeted < strict < mls
• 管理复杂度：targeted < mls < strict  
• 用户影响：targeted < mls < strict

推荐方案：
• 一般服务器：targeted策略
• 高安全要求：strict策略
• 分级保密：mls策略
```

**🔹 模块管理关键点**
```
模块操作原则：
• 最小权限：只安装必需的模块
• 定期审查：清理不用的模块
• 测试验证：新模块先测试再部署
• 备份回滚：重要变更前备份
```

### 10.3 实际应用建议


**💡 生产环境最佳实践**
```
策略管理流程：
1. 开发环境编写测试策略
2. 测试环境验证策略有效性  
3. 生产环境谨慎部署
4. 监控日志及时发现问题
5. 建立回滚机制应对异常
```

**⚠️ 常见问题避免**
- **不要直接在生产环境编写策略**
- **策略变更前必须备份**
- **定期检查审计日志**
- **保持策略版本文档更新**

### 10.4 学习进阶路径


```
SELinux策略掌握路径：
基础阶段 → 理解targeted策略，掌握semodule操作
进阶阶段 → 学会编写简单策略，处理常见拒绝  
高级阶段 → 自定义复杂策略，优化安全配置
专家阶段 → 策略架构设计，安全策略咨询
```

**🎯 核心记忆要点**：
- SELinux策略是系统安全的基石，选择合适的策略类型很关键
- 模块化管理让策略维护更灵活，semodule是必备工具
- 策略编写需要理解基本语法，从简单规则开始学习
- 版本管理和备份机制是生产环境的安全保障
- 持续学习和实践是掌握SELinux策略管理的关键