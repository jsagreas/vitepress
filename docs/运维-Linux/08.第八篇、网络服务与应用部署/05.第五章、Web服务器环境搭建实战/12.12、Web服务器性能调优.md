---
title: 12、Web服务器性能调优
---
## 📚 目录

1. [性能调优基础概念](#1-性能调优基础概念)
2. [并发连接数优化](#2-并发连接数优化)
3. [内存使用优化](#3-内存使用优化)
4. [CPU使用率优化](#4-CPU使用率优化)
5. [I/O性能调优](#5-IO性能调优)
6. [缓存策略配置](#6-缓存策略配置)
7. [连接保持配置](#7-连接保持配置)
8. [进程线程模型选择](#8-进程线程模型选择)
9. [系统内核参数调优](#9-系统内核参数调优)
10. [性能监控指标](#10-性能监控指标)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 性能调优基础概念


### 1.1 什么是Web服务器性能调优


**简单理解**：性能调优就像给汽车做保养和改装，让Web服务器跑得更快、更稳定、能承载更多用户访问。

**生活化比喻**：
```
Web服务器 = 餐厅
用户请求 = 顾客点餐
性能调优 = 餐厅管理优化

优化前的问题：
• 服务员太少，顾客排长队（并发不足）
• 厨房设备老旧，出菜慢（硬件瓶颈）
• 菜单复杂，点餐耗时（请求处理慢）

优化后的效果：
• 增加服务员，提高接待能力
• 升级厨房设备，加快出菜速度
• 简化流程，提升整体效率
```

### 1.2 性能调优的核心目标


**四大核心指标**：
```
🚀 响应速度（Response Time）
• 用户发起请求到收到响应的时间
• 目标：网页加载时间 < 3秒

⚡ 并发能力（Concurrency）
• 同时处理用户请求的数量
• 目标：支持更多同时在线用户

📊 吞吐量（Throughput）
• 单位时间内处理的请求数量
• 目标：每秒处理更多请求

🔧 资源利用率（Resource Utilization）
• CPU、内存、磁盘、网络的使用效率
• 目标：用最少资源达到最佳性能
```

### 1.3 性能瓶颈识别


**常见瓶颈类型**：
```
硬件瓶颈：
• CPU使用率持续过高（>80%）
• 内存不足，频繁swap
• 磁盘I/O等待时间长
• 网络带宽不够

软件瓶颈：
• Web服务器配置不当
• 数据库查询效率低
• 代码逻辑存在性能问题
• 缓存策略不合理

网络瓶颈：
• 带宽限制
• 网络延迟过高
• DNS解析慢
• CDN配置问题
```

---

## 2. 🔗 并发连接数优化


### 2.1 并发连接基本概念


**什么是并发连接**：同一时间内Web服务器能够处理的客户端连接数量。

**连接状态示意图**：
```
客户端连接生命周期：
建立连接 → 发送请求 → 处理请求 → 返回响应 → 关闭连接

并发处理示意：
客户端A: [连接] ---- [处理] ---- [响应] ---- [关闭]
客户端B:    [连接] ---- [处理] ---- [响应] ---- [关闭]
客户端C:       [连接] ---- [处理] ---- [响应] ---- [关闭]
时间轴: ---|---|---|---|---|---|---|---|---|---|---→
```

### 2.2 Apache并发优化


**Apache MPM模块选择**：

| MPM模式 | **工作方式** | **并发能力** | **内存使用** | **适用场景** |
|---------|------------|-------------|-------------|-------------|
| `prefork` | `多进程单线程` | `★★☆` | `★★★高` | `稳定性要求高` |
| `worker` | `多进程多线程` | `★★★` | `★★☆中` | `高并发+稳定` |
| `event` | `事件驱动` | `★★★★` | `★☆☆低` | `高性能场景` |

**配置优化示例**：
```apache
# worker模式配置
<IfModule mod_mpm_worker.c>
    StartServers          4      # 启动时的进程数
    MaxRequestWorkers   400      # 最大并发连接数
    MinSpareThreads      25      # 最小空闲线程
    MaxSpareThreads      75      # 最大空闲线程
    ThreadsPerChild      25      # 每个进程的线程数
    MaxRequestsPerChild 1000     # 子进程最大请求数
</IfModule>
```

### 2.3 Nginx并发优化


**Nginx并发配置**：
```nginx
# 核心配置
worker_processes auto;          # CPU核数自动检测
worker_connections 65535;       # 每个worker最大连接数
worker_rlimit_nofile 65535;     # worker进程文件描述符限制

# 事件处理优化
events {
    use epoll;                  # Linux下使用epoll
    worker_connections 65535;
    multi_accept on;            # 一次接受多个连接
    accept_mutex off;           # 关闭accept互斥锁
}

# HTTP配置
http {
    sendfile on;                # 启用高效文件传输
    tcp_nopush on;              # 优化数据包发送
    tcp_nodelay on;             # 减少延迟
    keepalive_timeout 65;       # 连接保持时间
}
```

### 2.4 系统级连接数限制


**文件描述符限制调整**：
```bash
# 查看当前限制
ulimit -n

# 临时调整（当前会话有效）
ulimit -n 65535

# 永久调整
echo "* soft nofile 65535" >> /etc/security/limits.conf
echo "* hard nofile 65535" >> /etc/security/limits.conf
```

**系统内核参数优化**：
```bash
# 网络连接优化
echo "net.core.somaxconn = 65535" >> /etc/sysctl.conf
echo "net.ipv4.tcp_max_syn_backlog = 65535" >> /etc/sysctl.conf
echo "net.core.netdev_max_backlog = 32768" >> /etc/sysctl.conf

# 应用配置
sysctl -p
```

---

## 3. 🧠 内存使用优化


### 3.1 内存使用模式分析


**Web服务器内存使用构成**：
```
内存分布示意：
┌─────────────────────────────────────┐ 总内存
│ 系统内核预留          (10-15%)      │
├─────────────────────────────────────┤
│ Web服务器进程         (60-70%)      │
├─────────────────────────────────────┤
│ 数据库缓存           (15-20%)      │
├─────────────────────────────────────┤
│ 文件系统缓存         (5-10%)       │
└─────────────────────────────────────┘

合理分配原则：
• 为操作系统预留足够内存
• Web服务器占用大部分内存
• 留出缓存空间提升性能
```

### 3.2 Apache内存优化


**进程内存控制**：
```apache
# 控制内存使用
<IfModule mod_mpm_prefork.c>
    StartServers 8              # 启动进程数
    MinSpareServers 5           # 最小空闲进程
    MaxSpareServers 20          # 最大空闲进程
    ServerLimit 256             # 服务器限制
    MaxRequestWorkers 256       # 最大工作进程
    MaxRequestsPerChild 4000    # 子进程处理请求数限制
</IfModule>

# 内存泄漏防护
MaxRequestsPerChild 4000        # 定期回收进程防止内存泄漏
```

**内存使用监控**：
```bash
# 查看Apache进程内存使用
ps aux | grep apache2 | awk '{sum+=$6} END {print "总内存使用: " sum/1024 "MB"}'

# 实时监控内存使用
watch -n 1 'ps aux | grep apache2'
```

### 3.3 Nginx内存优化


**缓冲区配置**：
```nginx
http {
    # 客户端缓冲区
    client_body_buffer_size 128k;      # 客户端请求体缓冲
    client_max_body_size 10m;          # 最大请求体大小
    client_header_buffer_size 32k;     # 请求头缓冲
    large_client_header_buffers 4 32k; # 大请求头缓冲
    
    # 代理缓冲区
    proxy_buffer_size 64k;             # 代理缓冲大小
    proxy_buffers 4 64k;               # 代理缓冲数量
    proxy_busy_buffers_size 128k;      # 忙碌缓冲大小
    
    # 文件缓存
    open_file_cache max=65535 inactive=60s;
    open_file_cache_valid 80s;
    open_file_cache_min_uses 1;
}
```

### 3.4 内存监控与报警


**内存监控脚本**：
```bash
#!/bin/bash
# 内存监控脚本

MEMORY_THRESHOLD=80  # 内存使用阈值80%

check_memory() {
    MEMORY_USAGE=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100)}')
    
    if [ $MEMORY_USAGE -gt $MEMORY_THRESHOLD ]; then
        echo "警告: 内存使用率达到 ${MEMORY_USAGE}%"
        # 可以添加邮件通知或其他报警逻辑
        
        # 显示最耗内存的进程
        echo "Top 5 内存消耗进程:"
        ps aux --sort=-%mem | head -6
    fi
}

# 每5分钟检查一次
while true; do
    check_memory
    sleep 300
done
```

---

## 4. ⚙️ CPU使用率优化


### 4.1 CPU使用模式分析


**CPU使用率构成**：
```
CPU时间分配：
用户态 (User):     应用程序执行时间
系统态 (System):   内核操作时间
空闲态 (Idle):     CPU空闲时间
等待态 (Wait):     等待I/O操作时间
中断态 (IRQ):      处理硬件中断时间

性能判断标准：
• 用户态 < 70%: 正常
• 系统态 < 30%: 正常  
• 等待态 > 20%: I/O瓶颈
• 总使用率 > 80%: 需要优化
```

### 4.2 进程线程模型对CPU的影响


**不同模型的CPU特点**：

```
多进程模型 (Apache Prefork):
优点：
• 进程隔离性好，稳定
• 单个进程崩溃不影响其他

缺点：
• 进程切换开销大
• 内存占用高
• 扩展性有限

多线程模型 (Apache Worker):
优点：
• 线程切换开销小
• 内存使用效率高
• 并发能力强

缺点：
• 线程安全要求高
• 调试复杂

事件驱动模型 (Nginx):
优点：
• CPU使用效率最高
• 内存占用最少
• 并发能力最强

缺点：
• 编程模型复杂
• 不适合CPU密集型任务
```

### 4.3 Nginx CPU优化配置


**CPU绑定配置**：
```nginx
# 自动检测CPU核数
worker_processes auto;

# 手动绑定CPU核心（4核CPU示例）
worker_processes 4;
worker_cpu_affinity 0001 0010 0100 1000;

# 或者让系统自动分配
worker_cpu_affinity auto;

# 进程优先级调整
worker_priority -5;  # 提高Nginx进程优先级（-20到19）
```

**CPU相关优化**：
```nginx
events {
    # 使用高效的事件模型
    use epoll;                  # Linux
    # use kqueue;               # FreeBSD
    
    # 单worker进程连接数
    worker_connections 65535;
    
    # 一次接受多个连接
    multi_accept on;
}

http {
    # 启用sendfile减少CPU复制
    sendfile on;
    
    # 优化TCP选项
    tcp_nopush on;
    tcp_nodelay on;
}
```

### 4.4 CPU监控与分析


**CPU使用监控**：
```bash
# 实时CPU使用率
top -p `pgrep nginx`

# 详细CPU统计
iostat -c 1 5

# 进程CPU使用排序
ps aux --sort=-%cpu | head -10

# CPU使用率趋势监控
sar -u 1 60  # 每秒采样，共60次
```

**CPU性能分析工具**：
```bash
# 使用htop查看详细信息
htop

# 使用perf分析性能
perf top -p `pgrep nginx`

# 查看系统调用
strace -c -p `pgrep nginx`
```

---

## 5. 💾 I/O性能调优


### 5.1 I/O类型与特点


**I/O操作分类**：
```
网络I/O：
• 接收客户端请求
• 发送响应数据
• 代理转发通信

磁盘I/O：
• 读取静态文件
• 写入访问日志
• 缓存文件操作

内存I/O：
• 缓存数据读写
• 进程间通信
• 共享内存操作

I/O性能影响因素：
• 磁盘类型（HDD vs SSD）
• 文件系统类型
• 内核I/O调度器
• 应用程序I/O模式
```

### 5.2 磁盘I/O优化


**文件系统优化**：
```bash
# 查看当前磁盘I/O
iostat -x 1 5

# SSD优化挂载选项
mount -o noatime,nodiratime,discard /dev/sdb1 /var/www

# 文件系统调优
echo 'deadline' > /sys/block/sda/queue/scheduler  # SSD使用deadline
echo 'cfq' > /sys/block/sda/queue/scheduler       # HDD使用cfq
```

**Nginx磁盘I/O优化**：
```nginx
http {
    # 启用高效文件传输
    sendfile on;
    sendfile_max_chunk 1m;
    
    # 文件缓存
    open_file_cache max=65535 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;
    
    # 异步I/O（需要编译支持）
    aio on;
    aio_write on;
    directio 512k;  # 大文件直接I/O
}
```

### 5.3 网络I/O优化


**TCP参数调优**：
```bash
# TCP接收/发送缓冲区
echo "net.core.rmem_max = 16777216" >> /etc/sysctl.conf
echo "net.core.wmem_max = 16777216" >> /etc/sysctl.conf
echo "net.ipv4.tcp_rmem = 4096 65536 16777216" >> /etc/sysctl.conf
echo "net.ipv4.tcp_wmem = 4096 65536 16777216" >> /etc/sysctl.conf

# 连接队列优化
echo "net.core.somaxconn = 65535" >> /etc/sysctl.conf
echo "net.ipv4.tcp_max_syn_backlog = 65535" >> /etc/sysctl.conf

# 应用设置
sysctl -p
```

**Nginx网络I/O配置**：
```nginx
events {
    use epoll;
    worker_connections 65535;
    multi_accept on;
}

http {
    # 网络优化
    tcp_nopush on;
    tcp_nodelay on;
    
    # 超时设置
    client_header_timeout 15;
    client_body_timeout 15;
    send_timeout 15;
    keepalive_timeout 65;
}
```

### 5.4 I/O监控分析


**I/O性能监控**：
```bash
# 实时I/O监控
iotop -o  # 只显示有I/O活动的进程

# 磁盘I/O统计
iostat -x 1

# 文件系统I/O
sar -b 1 10

# 进程I/O统计
pidstat -d 1
```

---

## 6. 🗂️ 缓存策略配置


### 6.1 缓存类型与层次


**Web缓存层次结构**：
```
客户端缓存 (浏览器缓存)
         ↓
CDN缓存 (内容分发网络)
         ↓  
反向代理缓存 (Nginx/Apache)
         ↓
应用缓存 (Redis/Memcached)
         ↓
数据库缓存 (MySQL查询缓存)
```

**缓存策略选择**：
```
静态资源缓存：
• 图片、CSS、JS文件
• 缓存时间：7-30天
• 使用强缓存策略

动态内容缓存：
• API响应、页面片段
• 缓存时间：几分钟到几小时
• 使用协商缓存

数据库缓存：
• 查询结果缓存
• 缓存时间：根据数据更新频率
• 使用应用层缓存
```

### 6.2 Nginx缓存配置


**静态文件缓存**：
```nginx
http {
    # 缓存路径配置
    proxy_cache_path /var/cache/nginx/proxy 
                     levels=1:2 
                     keys_zone=my_cache:10m 
                     max_size=10g 
                     inactive=60m;
    
    server {
        location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
            # 静态资源缓存1个月
            expires 1M;
            add_header Cache-Control "public, immutable";
        }
        
        location / {
            # 动态内容缓存
            proxy_cache my_cache;
            proxy_cache_valid 200 10m;
            proxy_cache_valid 404 1m;
            proxy_cache_use_stale error timeout updating;
            
            # 缓存键设置
            proxy_cache_key $scheme$proxy_host$request_uri;
            
            # 添加缓存状态头
            add_header X-Cache-Status $upstream_cache_status;
            
            proxy_pass http://backend;
        }
    }
}
```

**缓存清理配置**：
```nginx
# 缓存清理location
location ~ /purge(/.*) {
    allow 127.0.0.1;
    deny all;
    proxy_cache_purge my_cache $scheme$proxy_host$1;
}
```

### 6.3 Apache缓存配置


**mod_cache配置**：
```apache
# 启用缓存模块
LoadModule cache_module modules/mod_cache.so
LoadModule cache_disk_module modules/mod_cache_disk.so

# 缓存配置
<IfModule mod_cache.c>
    CacheEnable disk /
    CacheRoot /var/cache/apache2
    CacheDefaultExpire 3600
    CacheMaxExpire 86400
    CacheLastModifiedFactor 0.1
</IfModule>

# 静态文件缓存
<LocationMatch "\.(css|js|png|jpg|jpeg|gif|ico)$">
    ExpiresActive On
    ExpiresDefault "access plus 1 month"
</LocationMatch>
```

### 6.4 缓存监控与管理


**缓存命中率监控**：
```bash
# Nginx缓存状态统计
grep "X-Cache-Status" /var/log/nginx/access.log | \
awk '{print $NF}' | sort | uniq -c | sort -nr

# 缓存目录大小监控
du -sh /var/cache/nginx/

# 自动清理过期缓存
find /var/cache/nginx/ -type f -mtime +7 -delete
```

---

## 7. 🔄 连接保持配置


### 7.1 Keep-Alive机制原理


**HTTP连接模式对比**：
```
HTTP/1.0 短连接：
请求1: 建连 → 发送 → 接收 → 断连
请求2: 建连 → 发送 → 接收 → 断连
请求3: 建连 → 发送 → 接收 → 断连

HTTP/1.1 长连接 (Keep-Alive)：
建连 → 请求1 → 响应1 → 请求2 → 响应2 → ... → 断连

优势：
• 减少TCP握手开销
• 降低服务器负载
• 提升页面加载速度
• 减少网络拥塞
```

### 7.2 Nginx Keep-Alive配置


**客户端Keep-Alive**：
```nginx
http {
    # 连接保持时间
    keepalive_timeout 65;           # 65秒超时
    keepalive_requests 1000;        # 单连接最大请求数
    
    # 连接保持头信息
    keepalive_disable msie6;        # 禁用IE6的keep-alive
    
    # 发送超时
    send_timeout 60;
    
    # 客户端超时
    client_header_timeout 60;
    client_body_timeout 60;
}
```

**上游Keep-Alive配置**：
```nginx
upstream backend {
    server 192.168.1.10:8080;
    server 192.168.1.11:8080;
    
    # 上游连接保持
    keepalive 32;                   # 保持32个连接
    keepalive_requests 1000;        # 每连接最大请求数
    keepalive_timeout 60s;          # 空闲超时时间
}

server {
    location / {
        proxy_pass http://backend;
        
        # 向上游传递连接保持
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
    }
}
```

### 7.3 Apache Keep-Alive配置


**基础配置**：
```apache
# 启用Keep-Alive
KeepAlive On

# 连接保持时间
KeepAliveTimeout 5

# 单连接最大请求数
MaxKeepAliveRequests 100

# 超时设置
Timeout 300
```

**MPM相关配置**：
```apache
<IfModule mod_mpm_worker.c>
    StartServers 4
    MaxRequestWorkers 400
    MinSpareThreads 25
    MaxSpareThreads 75
    ThreadsPerChild 25
    MaxRequestsPerChild 0    # 0表示无限制
</IfModule>
```

### 7.4 Keep-Alive性能监控


**连接状态监控**：
```bash
# 查看TCP连接状态
netstat -ant | awk '{print $6}' | sort | uniq -c

# Nginx连接状态
curl http://localhost/nginx_status

# 活跃连接监控
ss -s

# 连接保持效果测试
ab -k -n 1000 -c 10 http://localhost/
```

**监控脚本示例**：
```bash
#!/bin/bash
# Keep-Alive效果监控

echo "=== TCP连接状态统计 ==="
netstat -ant | awk '{print $6}' | sort | uniq -c

echo "=== Nginx状态 ==="
curl -s http://localhost/nginx_status

echo "=== 连接保持率计算 ==="
TOTAL_CONN=$(netstat -ant | grep :80 | wc -l)
ESTABLISHED=$(netstat -ant | grep :80 | grep ESTABLISHED | wc -l)
KEEP_ALIVE_RATE=$((ESTABLISHED * 100 / TOTAL_CONN))
echo "连接保持率: ${KEEP_ALIVE_RATE}%"
```

---

## 8. 🔧 进程线程模型选择


### 8.1 不同模型特点对比


**模型对比分析表**：

| 模型类型 | **内存使用** | **CPU效率** | **并发能力** | **稳定性** | **复杂度** |
|---------|------------|------------|-------------|-----------|-----------|
| `多进程` | `★☆☆ 高` | `★★☆ 中` | `★★☆ 中` | `★★★ 高` | `★☆☆ 简单` |
| `多线程` | `★★☆ 中` | `★★★ 高` | `★★★ 高` | `★★☆ 中` | `★★☆ 中等` |
| `事件驱动` | `★★★ 低` | `★★★ 高` | `★★★★ 最高` | `★★☆ 中` | `★★★ 复杂` |

### 8.2 Apache MPM模块选择


**Prefork模式（多进程）**：
```apache
<IfModule mod_mpm_prefork.c>
    StartServers 8              # 启动时的服务器进程数
    MinSpareServers 5           # 最小空闲服务器进程数
    MaxSpareServers 20          # 最大空闲服务器进程数
    MaxRequestWorkers 256       # 最大并发连接数
    MaxRequestsPerChild 4000    # 子进程生命周期内的最大请求数
</IfModule>

适用场景：
• 需要最高稳定性
• 使用非线程安全的PHP模块
• 内存资源充足
• 并发要求不是特别高
```

**Worker模式（多进程+多线程）**：
```apache
<IfModule mod_mpm_worker.c>
    StartServers 4              # 启动时的服务器进程数
    MaxRequestWorkers 400       # 最大并发连接数
    MinSpareThreads 25          # 最小空闲线程数
    MaxSpareThreads 75          # 最大空闲线程数
    ThreadsPerChild 25          # 每个子进程的线程数
    MaxRequestsPerChild 0       # 子进程最大请求数
</IfModule>

适用场景：
• 需要平衡性能和稳定性
• 中高并发访问
• 内存使用要求适中
• 线程安全的应用程序
```

**Event模式（事件驱动）**：
```apache
<IfModule mod_mpm_event.c>
    StartServers 4
    MinSpareThreads 25
    MaxSpareThreads 75
    ThreadLimit 64
    ThreadsPerChild 25
    MaxRequestWorkers 400
    MaxRequestsPerChild 0
</IfModule>

适用场景：
• 高并发场景
• 大量Keep-Alive连接
• 静态内容为主
• 对性能要求最高
```

### 8.3 Nginx事件模型


**工作进程配置**：
```nginx
# 根据CPU核数设置
worker_processes auto;

# 手动设置（推荐与CPU核数相等）
worker_processes 4;

# CPU亲和性绑定
worker_cpu_affinity auto;

# 进程优先级
worker_priority 0;

# 工作目录
working_directory /var/cache/nginx;
```

**事件处理配置**：
```nginx
events {
    # Linux下最佳选择
    use epoll;
    
    # 单个worker最大连接数
    worker_connections 65535;
    
    # 是否一次接受多个连接
    multi_accept on;
    
    # 接受连接的负载均衡
    accept_mutex off;
    
    # 调试信息
    debug_connection 192.168.1.0/24;
}
```

### 8.4 模型性能测试


**性能测试方法**：
```bash
# Apache Bench测试
ab -n 10000 -c 100 http://localhost/

# wrk测试工具
wrk -t12 -c400 -d30s http://localhost/

# 自定义测试脚本
#!/bin/bash
for model in prefork worker event; do
    echo "测试 $model 模式"
    # 切换Apache模式
    a2dismod mpm_*
    a2enmod mpm_$model
    systemctl restart apache2
    
    # 执行性能测试
    ab -n 1000 -c 50 http://localhost/ > test_${model}.txt
done
```

---

## 9. ⚙️ 系统内核参数调优


### 9.1 网络参数优化


**TCP连接相关参数**：
```bash
# TCP连接队列大小
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.core.netdev_max_backlog = 32768

# TCP缓冲区大小
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 65536 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# TCP连接复用
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 15
net.ipv4.tcp_keepalive_time = 1200
```

**应用到系统**：
```bash
# 临时生效
echo "net.core.somaxconn = 65535" | sudo tee -a /etc/sysctl.conf

# 永久生效
cat >> /etc/sysctl.conf << EOF
# Web服务器优化参数
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.core.netdev_max_backlog = 32768
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 65536 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 15
EOF

# 应用配置
sysctl -p
```

### 9.2 文件系统参数优化


**文件描述符限制**：
```bash
# 系统级别限制
echo "fs.file-max = 2097152" >> /etc/sysctl.conf

# 用户级别限制
cat >> /etc/security/limits.conf << EOF
* soft nofile 65535
* hard nofile 65535
* soft nproc 65535
* hard nproc 65535
EOF

# 会话级别
echo "session required pam_limits.so" >> /etc/pam.d/common-session
```

**文件系统缓存**：
```bash
# 虚拟内存参数
vm.swappiness = 10              # 减少swap使用
vm.dirty_ratio = 15             # 脏页比例
vm.dirty_background_ratio = 5   # 后台写入阈值
vm.vfs_cache_pressure = 50      # 目录和inode缓存回收
```

### 9.3 内存管理参数


**内存分配优化**：
```bash
# 内存过量分配
vm.overcommit_memory = 1

# 内存映射区域数量
vm.max_map_count = 262144

# 共享内存段大小
kernel.shmmax = 4294967296
kernel.shmall = 1048576

# 透明大页
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```

### 9.4 参数调优验证


**参数生效检查**：
```bash
# 检查当前参数值
sysctl net.core.somaxconn
sysctl -a | grep net.ipv4.tcp

# 监控参数效果
cat /proc/sys/net/core/somaxconn
cat /proc/sys/net/ipv4/tcp_max_syn_backlog

# 网络统计
netstat -s | grep -i listen
ss -lnt
```

**性能对比测试**：
```bash
#!/bin/bash
# 参数调优前后性能对比

echo "=== 调优前测试 ==="
ab -n 1000 -c 100 http://localhost/ > before.txt

echo "=== 应用调优参数 ==="
sysctl -p

echo "=== 调优后测试 ==="
ab -n 1000 -c 100 http://localhost/ > after.txt

echo "=== 性能对比 ==="
echo "调优前："
grep "Requests per second" before.txt
echo "调优后："
grep "Requests per second" after.txt
```

---

## 10. 📊 性能监控指标


### 10.1 关键性能指标（KPI）


**响应时间指标**：
```
响应时间分类：
• 平均响应时间 (Average Response Time)
• 50%分位响应时间 (P50)  
• 95%分位响应时间 (P95)
• 99%分位响应时间 (P99)
• 最大响应时间 (Max Response Time)

性能标准：
网站类型          P95响应时间目标
电商网站         < 500ms
企业应用         < 1000ms
内容网站         < 300ms
API服务          < 200ms
```

**吞吐量指标**：
```
QPS (Queries Per Second):      每秒查询数
TPS (Transactions Per Second): 每秒事务数
PV (Page Views):               页面浏览量
UV (Unique Visitors):          独立访客数

计算公式：
并发用户数 = QPS × 平均响应时间
系统容量 = QPS × 响应时间 / 1000
```

### 10.2 系统资源监控


**CPU监控**：
```bash
# 实时CPU监控
top -p `pgrep nginx`
htop

# CPU使用率历史
sar -u 1 60

# 进程CPU使用排序
ps aux --sort=-%cpu | head -10

# CPU负载监控
uptime
cat /proc/loadavg
```

**内存监控**：
```bash
# 内存使用概况
free -h
cat /proc/meminfo

# 进程内存使用
ps aux --sort=-%mem | head -10
pmap -x `pgrep nginx`

# 内存使用趋势
sar -r 1 60
```

**磁盘I/O监控**：
```bash
# I/O统计
iostat -x 1 5
iotop -o

# 磁盘使用率
df -h
du -sh /var/log/*

# I/O等待时间
sar -b 1 60
```

### 10.3 Web服务器专用监控


**Nginx状态监控**：
```nginx
# 启用状态模块
server {
    listen 80;
    server_name localhost;
    
    location /nginx_status {
        stub_status on;
        access_log off;
        allow 127.0.0.1;
        deny all;
    }
}
```

**状态信息解读**：
```bash
# 获取Nginx状态
curl http://localhost/nginx_status

输出示例：
Active connections: 291 
server accepts handled requests
 16630948 16630948 31070465 
Reading: 6 Writing: 179 Waiting: 106

解释：
Active connections: 当前活跃连接数
accepts: 总接受连接数
handled: 总处理连接数  
requests: 总请求数
Reading: 正在读取请求头的连接数
Writing: 正在发送响应的连接数
Waiting: 等待请求的空闲连接数
```

**Apache状态监控**：
```apache
# mod_status配置
<Location "/server-status">
    SetHandler server-status
    Require ip 127.0.0.1
</Location>

<Location "/server-info">
    SetHandler server-info
    Require ip 127.0.0.1
</Location>
```

### 10.4 监控自动化脚本


**综合监控脚本**：
```bash
#!/bin/bash
# Web服务器性能监控脚本

LOG_FILE="/var/log/webserver_monitor.log"
DATE=$(date "+%Y-%m-%d %H:%M:%S")

# 系统负载
LOAD=$(uptime | awk -F'load average:' '{print $2}')

# CPU使用率
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)

# 内存使用率
MEM_USAGE=$(free | grep Mem | awk '{printf("%.2f", $3/$2 * 100)}')

# 磁盘使用率
DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | cut -d'%' -f1)

# Nginx连接数
if pgrep nginx > /dev/null; then
    NGINX_CONN=$(curl -s http://localhost/nginx_status | grep "Active" | awk '{print $3}')
else
    NGINX_CONN="N/A"
fi

# 记录监控数据
echo "$DATE|Load:$LOAD|CPU:${CPU_USAGE}%|MEM:${MEM_USAGE}%|DISK:${DISK_USAGE}%|CONN:$NGINX_CONN" >> $LOG_FILE

# 告警检查
if (( $(echo "$CPU_USAGE > 80" | bc -l) )); then
    echo "警告: CPU使用率过高 ${CPU_USAGE}%" | mail -s "服务器告警" admin@example.com
fi

if (( $(echo "$MEM_USAGE > 90" | bc -l) )); then
    echo "警告: 内存使用率过高 ${MEM_USAGE}%" | mail -s "服务器告警" admin@example.com
fi
```

**定时监控设置**：
```bash
# 添加到crontab
crontab -e

# 每5分钟执行一次监控
*/5 * * * * /usr/local/bin/webserver_monitor.sh

# 每小时生成报告
0 * * * * /usr/local/bin/generate_hourly_report.sh

# 每日凌晨清理日志
0 2 * * * find /var/log -name "*.log" -mtime +7 -delete
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的优化概念


```
🔸 性能瓶颈识别：CPU、内存、I/O、网络四大资源监控
🔸 并发模型选择：根据场景选择进程、线程或事件驱动模型
🔸 缓存策略配置：多层缓存提升访问速度
🔸 连接保持优化：Keep-Alive减少连接开销
🔸 系统参数调优：内核参数匹配应用需求
🔸 监控指标体系：建立完整的性能监控体系
```

### 11.2 关键优化策略


**🔹 硬件资源优化**
```
CPU优化：
• 选择合适的进程/线程模型
• 绑定CPU核心提升缓存命中
• 避免CPU密集型操作阻塞

内存优化：
• 合理分配缓冲区大小
• 控制进程数量避免内存不足
• 使用内存缓存减少磁盘访问

I/O优化：
• 使用SSD提升磁盘性能
• 启用异步I/O和sendfile
• 优化网络参数减少延迟
```

**🔹 软件配置优化**
```
Web服务器配置：
• 根据负载调整worker数量
• 配置合适的超时时间
• 启用压缩减少传输量

缓存配置：
• 静态资源长期缓存
• 动态内容短期缓存
• 使用CDN分散访问压力

连接管理：
• 启用Keep-Alive复用连接
• 设置合理的连接数限制
• 配置连接池减少建连开销
```

### 11.3 监控运维要点


**监控指标优先级**：
```
L1 - 关键指标（必须监控）：
• 响应时间（P95 < 1秒）
• 错误率（< 0.1%）
• 可用性（> 99.9%）

L2 - 重要指标（建议监控）：
• QPS/TPS吞吐量
• CPU/内存使用率
• 磁盘I/O等待时间

L3 - 辅助指标（可选监控）：
• 网络流量
• 缓存命中率
• 连接池状态
```

**运维最佳实践**：
```
预防性维护：
• 定期检查系统资源使用情况
• 更新安全补丁和配置
• 清理日志文件释放空间

容量规划：
• 根据业务增长预测资源需求
• 提前扩容避免性能问题
• 建立性能基准对比分析

应急响应：
• 建立完善的告警机制
• 准备性能问题排查工具
• 制定应急处理流程
```

### 11.4 实际应用场景


- **小型网站**：注重成本控制，选择基础优化方案
- **电商平台**：注重并发处理，多层缓存+负载均衡
- **内容网站**：注重访问速度，CDN+静态缓存优化
- **API服务**：注重响应时间，连接池+内存缓存
- **企业应用**：注重稳定性，监控告警+容灾备份

**核心记忆**：
- 性能优化是系统工程，需要综合考虑
- 监控先行，数据驱动优化决策
- 循序渐进，从瓶颈点开始优化
- 测试验证，确保优化效果达到预期