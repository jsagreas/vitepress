---
title: 12、远程文件系统监控与维护
---
## 📚 目录

1. [NFS统计信息查看详解](#1-NFS统计信息查看详解)
2. [Samba连接状态监控](#2-Samba连接状态监控)
3. [网络流量监控方法](#3-网络流量监控方法)
4. [文件系统使用率监控](#4-文件系统使用率监控)
5. [性能指标收集分析](#5-性能指标收集分析)
6. [日志轮转配置管理](#6-日志轮转配置管理)
7. [定期维护任务设置](#7-定期维护任务设置)
8. [故障预警机制建立](#8-故障预警机制建立)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 NFS统计信息查看详解


### 1.1 nfsstat命令详解

🎯 **简单理解**：nfsstat就像是NFS服务的"体检报告"，告诉你服务运行得怎么样

**🔸 什么是NFS统计信息**
```
NFS运行状态就像汽车仪表盘：
- 速度表 → RPC调用次数
- 油量表 → 缓存命中率  
- 温度表 → 错误计数
- 里程表 → 总操作数量

通过这些指标判断NFS是否健康运行
```

### 1.2 基础统计信息查看

**📋 nfsstat基本用法**

```bash
# 查看所有NFS统计信息
nfsstat

# 只看服务端统计
nfsstat -s

# 只看客户端统计  
nfsstat -c

# 查看特定NFS版本统计
nfsstat -3    # NFSv3统计
nfsstat -4    # NFSv4统计
```

**🔍 统计信息含义解读**
```
服务端重要指标：
calls     - 总RPC调用次数
badcalls  - 失败的RPC调用
badauth   - 认证失败次数
badclnt   - 客户端错误
xdrcall   - XDR解码错误

客户端重要指标：
calls     - 发起的调用次数
retrans   - 重传次数  
authrefrsh - 认证刷新次数
```

### 1.3 详细操作统计分析

**📈 NFS操作类型分析**

| 操作类型 | **含义** | **正常范围** | **异常表现** |
|---------|---------|-------------|-------------|
| **getattr** | `获取文件属性` | `高频正常` | `错误率>5%需关注` |
| **read** | `文件读取操作` | `依业务而定` | `延迟>100ms异常` |
| **write** | `文件写入操作` | `依业务而定` | `失败率>1%需检查` |
| **lookup** | `路径查找操作` | `中等频率` | `大量404需优化` |
| **create** | `文件创建操作` | `相对较少` | `权限错误需修复` |

**💡 实时监控脚本示例**
```bash
#!/bin/bash
# nfs_monitor.sh - NFS状态监控脚本

check_nfs_performance() {
    echo "=== NFS性能检查 $(date) ==="
    
    # 获取当前统计
    nfsstat -s > /tmp/nfs_current.txt
    
    # 检查错误率
    badcalls=$(grep "badcalls" /tmp/nfs_current.txt | awk '{print $2}')
    calls=$(grep "calls" /tmp/nfs_current.txt | awk '{print $2}')
    
    if [ "$calls" -gt 0 ]; then
        error_rate=$(echo "scale=2; $badcalls * 100 / $calls" | bc)
        echo "错误率: ${error_rate}%"
        
        # 错误率超过5%告警
        if (( $(echo "$error_rate > 5.0" | bc -l) )); then
            echo "⚠️ 警告：NFS错误率过高 ($error_rate%)"
        fi
    fi
    
    # 检查重传率（客户端）
    if nfsstat -c &>/dev/null; then
        retrans=$(nfsstat -c | grep retrans | awk '{print $2}')
        rpc_calls=$(nfsstat -c | grep calls | awk '{print $2}')
        
        if [ "$rpc_calls" -gt 0 ]; then
            retrans_rate=$(echo "scale=2; $retrans * 100 / $rpc_calls" | bc)
            echo "重传率: ${retrans_rate}%"
        fi
    fi
}
```

### 1.4 NFS性能分析技巧

**⚡ 性能瓶颈识别方法**

```
性能问题诊断思路：

1. 高错误率问题
   现象：badcalls/calls > 5%
   原因：网络不稳定、权限问题
   解决：检查网络、修复权限配置

2. 高重传率问题  
   现象：retrans/calls > 10%
   原因：网络延迟高、服务器响应慢
   解决：优化网络、调整超时参数

3. 低缓存命中率
   现象：大量getattr调用
   原因：客户端缓存配置不当
   解决：调整attribute cache参数
```

**🔧 性能优化建议**
```bash
# 客户端挂载优化参数
mount -t nfs -o rsize=65536,wsize=65536,timeo=14,intr \
  server:/path /mnt/nfs

# 参数说明：
# rsize/wsize - 读写块大小，影响传输效率
# timeo - 超时时间，影响重传频率  
# intr - 允许中断，提高响应性
```

---

## 2. 🔗 Samba连接状态监控


### 2.1 smbstatus命令详解

🎯 **简单理解**：smbstatus就像查看"谁在访问我的共享文件夹"

**🔸 Samba连接监控的重要性**
```
为什么要监控Samba连接：
- 安全考虑：发现异常访问
- 性能优化：了解使用模式
- 资源管理：控制并发连接数
- 故障排查：定位访问问题
```

### 2.2 基础连接状态查看

**📋 smbstatus基本用法**

```bash
# 查看所有连接状态
smbstatus

# 只显示连接信息，不显示锁信息
smbstatus -b

# 只显示共享状态
smbstatus -S

# 显示详细的锁信息
smbstatus -L

# 以数字形式显示用户ID
smbstatus -n
```

**🔍 输出信息解读**
```
连接状态输出包含：
PID        - Samba进程ID
Username   - 连接用户名
Group      - 用户组
Machine    - 客户端机器名
Protocol   - 使用的协议版本
Connect time - 连接建立时间

共享状态输出包含：
Service    - 共享服务名
PID        - 进程ID  
Machine    - 客户端
Connect time - 连接时间
```

### 2.3 连接状态分析技巧

**📊 连接模式分析**

```bash
# 统计连接数脚本
#!/bin/bash
# samba_connection_stats.sh

analyze_samba_connections() {
    echo "=== Samba连接分析 $(date) ==="
    
    # 总连接数
    total_connections=$(smbstatus -b | grep -v "^$" | wc -l)
    echo "总连接数: $total_connections"
    
    # 按用户统计
    echo -e "\n按用户分组:"
    smbstatus -b | awk 'NR>3 {print $2}' | sort | uniq -c | sort -nr
    
    # 按协议版本统计
    echo -e "\n按协议版本分组:"
    smbstatus -b | awk 'NR>3 {print $5}' | sort | uniq -c
    
    # 检查长时间连接
    echo -e "\n长时间连接检查:"
    smbstatus -b | awk 'NR>3' | while read line; do
        connect_time=$(echo $line | awk '{print $6" "$7}')
        # 这里可以添加时间计算逻辑
        echo "连接时间: $connect_time"
    done
}
```

### 2.4 安全监控策略

**🛡️ 异常连接检测**

| 监控项目 | **正常表现** | **异常表现** | **处理建议** |
|---------|-------------|-------------|-------------|
| **连接数量** | `稳定范围内` | `突然激增` | `检查是否攻击` |
| **用户分布** | `已知用户` | `陌生用户` | `审查权限配置` |
| **连接时间** | `合理范围` | `异常长连接` | `检查会话超时` |
| **协议版本** | `统一版本` | `混杂版本` | `升级客户端` |

**⚠️ 安全告警脚本**
```bash
# samba_security_check.sh
check_samba_security() {
    # 检查异常连接数
    connections=$(smbstatus -b | grep -v "^$" | wc -l)
    if [ $connections -gt 50 ]; then
        echo "⚠️ 警告：连接数异常 ($connections)"
    fi
    
    # 检查root连接（高风险）
    root_connections=$(smbstatus -b | grep " root " | wc -l)
    if [ $root_connections -gt 0 ]; then
        echo "🚨 严重：发现root用户连接"
    fi
    
    # 检查外部IP连接
    smbstatus -b | awk 'NR>3 {print $4}' | while read machine; do
        if [[ ! $machine =~ ^192\.168\. ]]; then
            echo "⚠️ 外部连接: $machine"
        fi
    done
}
```

---

## 3. 🌐 网络流量监控方法


### 3.1 网络流量监控工具对比

🎯 **选择合适的监控工具**

**📊 监控工具特点对比**

| 工具 | **实时性** | **历史数据** | **资源占用** | **适用场景** |
|------|-----------|-------------|-------------|-------------|
| **iftop** | `excellent` | `无` | `低` | `实时问题排查` |
| **vnstat** | `good` | `excellent` | `极低` | `长期趋势分析` |
| **nload** | `excellent` | `无` | `低` | `带宽使用监控` |
| **sar** | `good` | `good` | `中` | `系统综合监控` |

### 3.2 实时流量监控

**⚡ 实时网络流量查看方法**

```bash
# 使用iftop监控网络连接
iftop -i eth0 -P    # -P显示端口号

# 使用nload监控带宽使用
nload eth0

# 使用ss监控连接状态
ss -tuln | grep :2049    # 监控NFS端口
ss -tuln | grep :445     # 监控SMB端口

# 使用netstat监控连接
netstat -an | grep :2049 | wc -l    # NFS连接数
```

**📈 自定义流量监控脚本**
```bash
#!/bin/bash
# network_traffic_monitor.sh

monitor_nfs_traffic() {
    echo "=== NFS网络流量监控 ==="
    
    # 获取网络接口统计
    interface="eth0"
    
    # 读取当前流量统计
    rx_bytes_before=$(cat /sys/class/net/$interface/statistics/rx_bytes)
    tx_bytes_before=$(cat /sys/class/net/$interface/statistics/tx_bytes)
    
    sleep 1
    
    rx_bytes_after=$(cat /sys/class/net/$interface/statistics/rx_bytes)
    tx_bytes_after=$(cat /sys/class/net/$interface/statistics/tx_bytes)
    
    # 计算每秒流量
    rx_rate=$((rx_bytes_after - rx_bytes_before))
    tx_rate=$((tx_bytes_after - tx_bytes_before))
    
    echo "接收流量: $(format_bytes $rx_rate)/s"
    echo "发送流量: $(format_bytes $tx_rate)/s"
}

format_bytes() {
    local bytes=$1
    if [ $bytes -gt 1073741824 ]; then
        echo "$((bytes / 1073741824))GB"
    elif [ $bytes -gt 1048576 ]; then
        echo "$((bytes / 1048576))MB"  
    elif [ $bytes -gt 1024 ]; then
        echo "$((bytes / 1024))KB"
    else
        echo "${bytes}B"
    fi
}
```

### 3.3 历史流量数据分析

**📉 vnstat长期监控配置**

```bash
# 安装vnstat
apt install vnstat    # Ubuntu/Debian
yum install vnstat    # CentOS/RHEL

# 初始化数据库
vnstat -u -i eth0

# 查看不同时间维度的统计
vnstat -h    # 按小时统计
vnstat -d    # 按天统计  
vnstat -m    # 按月统计
vnstat -w    # 按周统计

# 生成图形化报告
vnstati -s -i eth0 -o /var/www/html/traffic.png
```

**📊 流量分析策略**
```
流量模式分析：

正常模式识别：
- 工作时间流量高峰
- 备份时间流量突增
- 周末流量降低

异常模式告警：
- 非工作时间大流量
- 流量突然断崖式下降
- 长时间超高流量
```

---

## 4. 💾 文件系统使用率监控


### 4.1 磁盘空间监控基础

🎯 **防止磁盘空间不足导致服务中断**

**🔸 为什么要监控磁盘使用率**
```
磁盘空间耗尽的后果：
- NFS服务无法写入新文件
- 日志无法正常记录
- 系统性能急剧下降
- 可能导致数据损坏

预防措施：
- 设置使用率告警阈值
- 自动清理临时文件
- 扩容或迁移数据
```

### 4.2 基础磁盘监控命令

**📋 常用磁盘监控工具**

```bash
# 查看磁盘使用率
df -h               # 人类可读格式
df -i               # 查看inode使用情况
df -T               # 显示文件系统类型

# 查看目录大小
du -sh /path/*      # 查看目录下各子目录大小
du -h --max-depth=1 /path    # 限制显示深度

# 实时监控磁盘IO
iostat -x 1         # 每秒更新一次IO统计
iotop               # 类似top的IO监控工具
```

**🔍 关键指标解读**
```
df命令输出指标：
Filesystem - 文件系统设备
Size       - 总容量
Used       - 已使用空间
Avail      - 可用空间  
Use%       - 使用百分比
Mounted on - 挂载点

inode使用率同样重要：
- 小文件多时可能inode耗尽
- 即使有空间也无法创建新文件
```

### 4.3 自动化监控脚本

**🤖 磁盘使用率监控自动化**

```bash
#!/bin/bash
# disk_monitor.sh - 磁盘使用率监控脚本

# 配置告警阈值
WARNING_THRESHOLD=80
CRITICAL_THRESHOLD=90

check_disk_usage() {
    echo "=== 磁盘使用率检查 $(date) ==="
    
    # 检查所有挂载点
    df -h | awk 'NR>1 {print $5" "$6}' | while read output; do
        usage=$(echo $output | awk '{print $1}' | sed 's/%//')
        mountpoint=$(echo $output | awk '{print $2}')
        
        if [ $usage -ge $CRITICAL_THRESHOLD ]; then
            echo "🚨 严重：$mountpoint 使用率 ${usage}%"
            # 发送紧急告警
            send_alert "critical" "$mountpoint" "$usage"
        elif [ $usage -ge $WARNING_THRESHOLD ]; then
            echo "⚠️ 警告：$mountpoint 使用率 ${usage}%"
            # 发送警告通知
            send_alert "warning" "$mountpoint" "$usage"
        else
            echo "✅ 正常：$mountpoint 使用率 ${usage}%"
        fi
    done
    
    # 检查inode使用率
    check_inode_usage
}

check_inode_usage() {
    echo -e "\n=== Inode使用率检查 ==="
    
    df -i | awk 'NR>1 {print $5" "$6}' | while read output; do
        usage=$(echo $output | awk '{print $1}' | sed 's/%//')
        mountpoint=$(echo $output | awk '{print $2}')
        
        if [ $usage -ge $WARNING_THRESHOLD ]; then
            echo "⚠️ Inode警告：$mountpoint 使用率 ${usage}%"
        fi
    done
}

send_alert() {
    local level=$1
    local mountpoint=$2  
    local usage=$3
    
    # 这里添加具体的告警发送逻辑
    echo "发送${level}级别告警：$mountpoint使用率${usage}%"
}
```

### 4.4 磁盘清理策略

**🧹 自动化磁盘空间清理**

| 清理对象 | **清理策略** | **风险等级** | **自动化程度** |
|---------|-------------|-------------|--------------|
| **临时文件** | `定期清理/tmp` | `低` | `全自动` |
| **日志文件** | `日志轮转压缩` | `低` | `全自动` |
| **缓存文件** | `LRU策略清理` | `中` | `半自动` |
| **备份文件** | `按保留策略清理` | `高` | `人工确认` |

```bash
# 自动清理脚本示例
#!/bin/bash
# disk_cleanup.sh

cleanup_temp_files() {
    echo "清理临时文件..."
    
    # 清理/tmp下超过7天的文件
    find /tmp -type f -mtime +7 -delete
    
    # 清理用户临时目录
    find /home/*/tmp -type f -mtime +3 -delete 2>/dev/null
    
    echo "临时文件清理完成"
}

cleanup_old_logs() {
    echo "清理过期日志..."
    
    # 清理系统日志（保留30天）
    find /var/log -name "*.log" -mtime +30 -delete
    
    # 压缩旧日志文件
    find /var/log -name "*.log" -mtime +7 -exec gzip {} \;
    
    echo "日志文件清理完成"
}
```

---

## 5. 📈 性能指标收集分析


### 5.1 性能监控指标体系

🎯 **建立完整的性能监控体系**

**🔸 关键性能指标（KPI）分类**
```
系统层面指标：
- CPU使用率和负载
- 内存使用率和交换分区
- 磁盘IO读写速度和延迟
- 网络带宽和数据包统计

服务层面指标：
- NFS/Samba响应时间
- 并发连接数
- 错误率和成功率
- 缓存命中率

业务层面指标：
- 文件传输速度
- 用户访问模式
- 高峰时段性能
- 服务可用性
```

### 5.2 系统性能数据收集

**📊 使用sar命令收集系统指标**

```bash
# CPU使用率监控
sar -u 1 10    # 每秒采样，共10次

# 内存使用监控  
sar -r 1 10

# 磁盘IO监控
sar -d 1 10

# 网络统计监控
sar -n DEV 1 10

# 综合性能报告
sar -A > system_performance_$(date +%Y%m%d).txt
```

**⚡ 性能数据解读技巧**
```
CPU指标解读：
%user   - 用户态CPU时间，高表示应用负载重
%system - 内核态CPU时间，高表示IO或系统调用多
%iowait - IO等待时间，高表示存储性能瓶颈
%idle   - 空闲时间，低表示CPU资源紧张

内存指标解读：
kbmemfree  - 空闲内存，过低需关注
kbavail    - 可用内存（包括可回收）
%memused   - 内存使用率，>90%需注意
kbswpused  - 交换分区使用，>0持续需优化
```

### 5.3 自定义性能监控脚本

**🔧 综合性能监控解决方案**

```bash
#!/bin/bash
# performance_monitor.sh - 性能监控脚本

LOGDIR="/var/log/performance"
mkdir -p $LOGDIR

collect_system_metrics() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local logfile="$LOGDIR/system_metrics_$(date +%Y%m%d).log"
    
    echo "[$timestamp] 系统性能指标收集" >> $logfile
    
    # CPU使用率
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')
    echo "CPU使用率: ${cpu_usage}%" >> $logfile
    
    # 内存使用率
    mem_usage=$(free | grep Mem | awk '{printf "%.1f", $3/$2 * 100.0}')
    echo "内存使用率: ${mem_usage}%" >> $logfile
    
    # 磁盘使用率
    disk_usage=$(df -h / | awk 'NR==2 {print $5}')
    echo "根分区使用率: $disk_usage" >> $logfile
    
    # 负载平均值
    load_avg=$(uptime | awk -F'load average:' '{print $2}')
    echo "负载平均值:$load_avg" >> $logfile
    
    echo "---" >> $logfile
}

collect_nfs_metrics() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local logfile="$LOGDIR/nfs_metrics_$(date +%Y%m%d).log"
    
    echo "[$timestamp] NFS性能指标收集" >> $logfile
    
    # NFS调用统计
    if command -v nfsstat >/dev/null; then
        nfsstat -s | grep "calls\|retrans\|badcalls" >> $logfile
    fi
    
    # NFS连接数
    nfs_connections=$(ss -tuln | grep :2049 | wc -l)
    echo "NFS连接数: $nfs_connections" >> $logfile
    
    echo "---" >> $logfile
}

analyze_performance_trends() {
    echo "=== 性能趋势分析 ==="
    
    # 分析最近7天的CPU使用率趋势
    grep "CPU使用率" $LOGDIR/system_metrics_*.log | tail -168 | \
    awk -F': ' '{sum += $2; count++} END {printf "平均CPU使用率: %.1f%%\n", sum/count}'
    
    # 分析内存使用趋势
    grep "内存使用率" $LOGDIR/system_metrics_*.log | tail -168 | \
    awk -F': ' '{gsub(/%/, "", $2); sum += $2; count++} END {printf "平均内存使用率: %.1f%%\n", sum/count}'
}
```

### 5.4 性能瓶颈识别方法

**🔍 系统性能瓶颈诊断流程**

```
性能问题诊断决策树：

响应慢？
├─ CPU使用率高？
│  ├─ 是 → 检查进程占用，优化或扩容
│  └─ 否 → 继续检查
├─ 内存不足？  
│  ├─ 是 → 增加内存或优化内存使用
│  └─ 否 → 继续检查
├─ 磁盘IO高？
│  ├─ 是 → 优化存储或使用SSD
│  └─ 否 → 继续检查
└─ 网络延迟？
   ├─ 是 → 检查网络配置和带宽
   └─ 否 → 检查应用层逻辑
```

**⚠️ 性能告警阈值设置**
```bash
# 性能告警配置
cat > /etc/performance_alerts.conf << EOF
# CPU告警阈值
CPU_WARNING=80
CPU_CRITICAL=95

# 内存告警阈值  
MEMORY_WARNING=85
MEMORY_CRITICAL=95

# 磁盘告警阈值
DISK_WARNING=80
DISK_CRITICAL=90

# 负载告警阈值（基于CPU核数）
LOAD_WARNING=2.0
LOAD_CRITICAL=4.0
EOF
```

---

## 6. 📋 日志轮转配置管理


### 6.1 日志轮转的重要性

🎯 **防止日志文件无限增长占满磁盘**

**🔸 为什么需要日志轮转**
```
日志轮转解决的问题：
- 防止单个日志文件过大
- 控制日志占用的磁盘空间
- 便于日志文件的管理和备份
- 提高日志查询和分析效率

轮转策略考虑因素：
- 日志产生的速度
- 磁盘空间限制
- 法规要求的保留期限
- 查询和分析需求
```

### 6.2 logrotate配置详解

**⚙️ logrotate配置语法和选项**

```bash
# 主配置文件
cat /etc/logrotate.conf

# 服务特定配置目录
ls /etc/logrotate.d/

# NFS日志轮转配置示例
cat > /etc/logrotate.d/nfs << EOF
/var/log/nfsd.log {
    daily                    # 每天轮转
    rotate 30               # 保留30份
    compress                # 压缩旧日志
    delaycompress          # 延迟压缩
    missingok              # 文件不存在不报错
    notifempty             # 空文件不轮转
    postrotate
        systemctl reload nfs-server
    endscript
}
EOF
```

**📊 轮转配置选项详解**

| 选项 | **作用** | **示例** | **适用场景** |
|------|---------|---------|-------------|
| **daily/weekly/monthly** | `轮转频率` | `daily` | `高频日志使用daily` |
| **rotate N** | `保留份数` | `rotate 30` | `根据空间和需求调整` |
| **size** | `按大小轮转` | `size 100M` | `日志增长不规律时` |
| **compress** | `压缩旧日志` | `compress` | `节省存储空间` |
| **copytruncate** | `复制后清空` | `copytruncate` | `服务无法重新打开日志` |

### 6.3 Samba日志轮转配置

**🔗 Samba服务日志管理**

```bash
# Samba日志轮转配置
cat > /etc/logrotate.d/samba << EOF
/var/log/samba/*.log {
    weekly                  # 每周轮转
    rotate 52              # 保留一年
    compress               # 压缩旧文件
    delaycompress         # 延迟一个周期再压缩
    missingok             # 忽略丢失文件
    notifempty            # 空文件不轮转
    sharedscripts         # 多文件共享脚本
    postrotate
        # 重新加载Samba配置
        systemctl reload smbd
        systemctl reload nmbd
    endscript
}

# 针对特定用户的详细日志
/var/log/samba/audit.log {
    daily
    rotate 90             # 审计日志保留更久
    compress
    missingok
    notifempty
    create 640 root adm   # 创建新文件的权限
}
EOF
```

### 6.4 自定义日志轮转策略

**🔧 根据业务需求定制轮转策略**

```bash
#!/bin/bash
# custom_log_rotation.sh - 自定义日志轮转脚本

# 基于磁盘使用率的动态轮转
dynamic_log_rotation() {
    local log_dir="/var/log"
    local disk_usage=$(df $log_dir | awk 'NR==2 {print $5}' | sed 's/%//')
    
    if [ $disk_usage -gt 80 ]; then
        echo "磁盘使用率过高，执行紧急日志清理"
        
        # 压缩所有未压缩的日志
        find $log_dir -name "*.log" -mtime +1 -exec gzip {} \;
        
        # 删除超过7天的压缩日志
        find $log_dir -name "*.gz" -mtime +7 -delete
        
        echo "紧急清理完成"
    fi
}

# 智能日志保留策略
intelligent_log_retention() {
    local service=$1
    local log_path="/var/log/$service"
    
    # 根据日志重要性设置不同保留期
    case $service in
        "auth")
            # 认证日志保留更久（安全要求）
            rotate_count=90
            ;;
        "access")
            # 访问日志中等保留期
            rotate_count=30
            ;;
        "debug")
            # 调试日志短期保留
            rotate_count=7
            ;;
        *)
            rotate_count=14
            ;;
    esac
    
    # 生成动态配置
    cat > /etc/logrotate.d/$service-custom << EOF
$log_path/*.log {
    daily
    rotate $rotate_count
    compress
    delaycompress
    missingok
    notifempty
}
EOF
}
```

---

## 7. ⏰ 定期维护任务设置


### 7.1 维护任务规划策略

🎯 **建立系统化的维护计划**

**🔸 维护任务分类和频率**
```
按紧急程度分类：

日常维护（每日）：
- 监控系统状态
- 检查日志错误
- 备份关键数据
- 清理临时文件

周期维护（每周）：
- 系统更新检查
- 性能趋势分析
- 用户权限审查
- 存储空间整理

专项维护（每月）：
- 完整系统备份
- 安全策略评估
- 软件版本升级
- 硬件状态检查
```

### 7.2 cron定时任务配置

**⏰ 自动化维护任务调度**

```bash
# 查看和编辑cron任务
crontab -l      # 查看当前用户的cron任务
crontab -e      # 编辑cron任务

# 系统级cron任务
ls /etc/cron.*  # 查看系统cron目录

# NFS/Samba维护任务示例
cat > /etc/cron.d/remote-fs-maintenance << EOF
# 每小时检查服务状态
0 * * * * root /usr/local/bin/check_nfs_samba_status.sh

# 每天凌晨2点清理临时文件
0 2 * * * root /usr/local/bin/cleanup_temp_files.sh

# 每周日凌晨3点进行完整检查
0 3 * * 0 root /usr/local/bin/weekly_maintenance.sh

# 每月1号凌晨4点生成月度报告
0 4 1 * * root /usr/local/bin/monthly_report.sh
EOF
```

**📋 cron时间格式说明**
```
cron时间格式：分 时 日 月 星期
* * * * *
│ │ │ │ │
│ │ │ │ └── 星期几 (0-7, 0和7都表示星期日)
│ │ │ └──── 月份 (1-12)
│ │ └────── 日期 (1-31)
│ └──────── 小时 (0-23)
└────────── 分钟 (0-59)

特殊符号：
* - 任意值
, - 列举值 (1,3,5)
- - 范围值 (1-5)  
/ - 步进值 (*/5表示每5分钟)
```

### 7.3 服务状态检查脚本

**🔍 自动化服务健康检查**

```bash
#!/bin/bash
# check_nfs_samba_status.sh - 服务状态检查脚本

LOGFILE="/var/log/service_check.log"
EMAIL="admin@company.com"

check_nfs_service() {
    echo "=== NFS服务检查 $(date) ===" >> $LOGFILE
    
    # 检查NFS服务状态
    if systemctl is-active --quiet nfs-server; then
        echo "✅ NFS服务运行正常" >> $LOGFILE
    else
        echo "❌ NFS服务异常" >> $LOGFILE
        send_alert "NFS服务异常"
        
        # 尝试重启服务
        systemctl restart nfs-server
        sleep 5
        
        if systemctl is-active --quiet nfs-server; then
            echo "✅ NFS服务重启成功" >> $LOGFILE
        else
            echo "❌ NFS服务重启失败" >> $LOGFILE
        fi
    fi
    
    # 检查NFS挂载点
    if mountpoint -q /nfs/share; then
        echo "✅ NFS挂载点正常" >> $LOGFILE
    else
        echo "❌ NFS挂载点异常" >> $LOGFILE
        send_alert "NFS挂载点异常"
    fi
    
    # 检查NFS端口
    if ss -tuln | grep -q ":2049"; then
        echo "✅ NFS端口监听正常" >> $LOGFILE
    else
        echo "❌ NFS端口未监听" >> $LOGFILE
        send_alert "NFS端口异常"
    fi
}

check_samba_service() {
    echo "=== Samba服务检查 $(date) ===" >> $LOGFILE
    
    # 检查SMB和NMB服务
    for service in smbd nmbd; do
        if systemctl is-active --quiet $service; then
            echo "✅ $service 服务运行正常" >> $LOGFILE
        else
            echo "❌ $service 服务异常" >> $LOGFILE
            send_alert "$service 服务异常"
            
            systemctl restart $service
        fi
    done
    
    # 检查Samba端口
    if ss -tuln | grep -q ":445"; then
        echo "✅ Samba端口监听正常" >> $LOGFILE
    else
        echo "❌ Samba端口未监听" >> $LOGFILE
        send_alert "Samba端口异常"
    fi
    
    # 测试Samba连接
    if smbclient -L localhost -N >/dev/null 2>&1; then
        echo "✅ Samba连接测试正常" >> $LOGFILE
    else
        echo "❌ Samba连接测试失败" >> $LOGFILE
        send_alert "Samba连接异常"
    fi
}

send_alert() {
    local message=$1
    echo "发送告警: $message" >> $LOGFILE
    
    # 发送邮件告警
    echo "服务异常告警: $message" | mail -s "服务状态告警" $EMAIL
    
    # 记录到系统日志
    logger "SERVICE_ALERT: $message"
}

# 主检查流程
main() {
    check_nfs_service
    check_samba_service
    
    echo "===========================================" >> $LOGFILE
}

main
```

### 7.4 自动化维护脚本框架

**🤖 完整的维护任务自动化框架**

```bash
#!/bin/bash
# weekly_maintenance.sh - 周维护脚本

MAINTENANCE_LOG="/var/log/weekly_maintenance.log"
BACKUP_DIR="/backup/weekly"

perform_weekly_maintenance() {
    echo "=== 周维护任务开始 $(date) ===" >> $MAINTENANCE_LOG
    
    # 1. 系统状态检查
    check_system_health
    
    # 2. 清理和优化
    cleanup_system
    
    # 3. 备份重要配置
    backup_configurations
    
    # 4. 性能数据分析
    analyze_performance
    
    # 5. 安全检查
    security_audit
    
    echo "=== 周维护任务完成 $(date) ===" >> $MAINTENANCE_LOG
}

check_system_health() {
    echo "执行系统健康检查..." >> $MAINTENANCE_LOG
    
    # 检查磁盘使用率
    df -h >> $MAINTENANCE_LOG
    
    # 检查内存使用情况
    free -h >> $MAINTENANCE_LOG
    
    # 检查系统负载
    uptime >> $MAINTENANCE_LOG
    
    # 检查关键服务状态
    systemctl status nfs-server smbd nmbd >> $MAINTENANCE_LOG
}

cleanup_system() {
    echo "执行系统清理..." >> $MAINTENANCE_LOG
    
    # 清理包管理器缓存
    apt clean
    yum clean all
    
    # 清理临时文件
    find /tmp -type f -mtime +7 -delete
    
    # 清理旧的日志文件
    find /var/log -name "*.log" -mtime +30 -delete
    
    echo "系统清理完成" >> $MAINTENANCE_LOG
}

backup_configurations() {
    echo "备份系统配置..." >> $MAINTENANCE_LOG
    
    mkdir -p $BACKUP_DIR/$(date +%Y%m%d)
    
    # 备份NFS配置
    cp /etc/exports $BACKUP_DIR/$(date +%Y%m%d)/
    
    # 备份Samba配置
    cp /etc/samba/smb.conf $BACKUP_DIR/$(date +%Y%m%d)/
    
    # 备份系统配置
    tar -czf $BACKUP_DIR/$(date +%Y%m%d)/system_configs.tar.gz \
        /etc/fstab /etc/hosts /etc/passwd /etc/group
    
    echo "配置备份完成" >> $MAINTENANCE_LOG
}
```

---

## 8. 🚨 故障预警机制建立


### 8.1 故障预警体系设计

🎯 **建立主动式故障预警系统**

**🔸 预警机制的价值**
```
被动响应 vs 主动预警：

被动响应模式：
- 故障发生后才知道
- 影响用户体验
- 恢复时间长
- 可能导致数据丢失

主动预警模式：
- 提前发现潜在问题
- 防患于未然
- 快速响应处理
- 保护数据安全
```

### 8.2 多层次预警策略

**📊 分级预警机制设计**

| 预警级别 | **触发条件** | **响应时间** | **通知方式** | **处理策略** |
|---------|-------------|-------------|-------------|-------------|
| **信息** | `使用率>70%` | `24小时内` | `邮件通知` | `关注监控` |
| **警告** | `使用率>80%` | `4小时内` | `邮件+短信` | `制定处理计划` |
| **严重** | `使用率>90%` | `1小时内` | `电话+短信` | `立即处理` |
| **紧急** | `服务中断` | `立即` | `电话+现场` | `紧急恢复` |

### 8.3 智能预警脚本

**🧠 基于趋势分析的预警系统**

```bash
#!/bin/bash
# intelligent_alert.sh - 智能预警脚本

ALERT_CONFIG="/etc/alert_config.conf"
METRICS_DIR="/var/log/metrics"
ALERT_LOG="/var/log/alerts.log"

# 加载配置
source $ALERT_CONFIG

analyze_disk_trend() {
    local mountpoint=$1
    local current_usage=$(df $mountpoint | awk 'NR==2 {print $5}' | sed 's/%//')
    
    # 获取过去7天的使用率数据
    local usage_history=$(grep "$mountpoint" $METRICS_DIR/disk_usage_*.log | \
                          tail -7 | awk '{print $3}' | sed 's/%//')
    
    if [ -n "$usage_history" ]; then
        # 计算增长趋势
        local growth_rate=$(echo "$usage_history" | \
                           awk '{sum+=$1; count++} END {
                               if(count>1) print (sum/count - $1)/(count-1)
                               else print 0
                           }')
        
        # 预测未来使用率
        local predicted_usage=$(echo "$current_usage + $growth_rate * 7" | bc)
        
        if (( $(echo "$predicted_usage > 95" | bc -l) )); then
            send_predictive_alert "disk" "$mountpoint" "$predicted_usage"
        fi
    fi
}

analyze_service_stability() {
    local service=$1
    local error_count=$(systemctl status $service | grep -c "error\|failed")
    local restart_count=$(journalctl -u $service --since "1 day ago" | grep -c "Started\|Stopped")
    
    # 服务不稳定预警
    if [ $restart_count -gt 3 ]; then
        send_stability_alert "$service" "频繁重启" "$restart_count"
    fi
    
    if [ $error_count -gt 0 ]; then
        send_stability_alert "$service" "服务错误" "$error_count"
    fi
}

send_predictive_alert() {
    local type=$1
    local target=$2
    local predicted_value=$3
    
    local message="预测性告警: $type $target 预计将达到 $predicted_value%"
    
    echo "$(date): $message" >> $ALERT_LOG
    
    # 发送告警通知
    case $type in
        "disk")
            if (( $(echo "$predicted_value > 90" | bc -l) )); then
                send_notification "warning" "$message"
            fi
            ;;
    esac
}

send_stability_alert() {
    local service=$1
    local issue=$2
    local count=$3
    
    local message="稳定性告警: $service 服务 $issue，计数: $count"
    
    echo "$(date): $message" >> $ALERT_LOG
    send_notification "warning" "$message"
}

send_notification() {
    local level=$1
    local message=$2
    
    case $level in
        "info")
            echo "$message" | mail -s "信息通知" $EMAIL_INFO
            ;;
        "warning")
            echo "$message" | mail -s "警告通知" $EMAIL_WARNING
            # 可以添加短信通知
            ;;
        "critical")
            echo "$message" | mail -s "严重告警" $EMAIL_CRITICAL
            # 可以添加电话通知
            ;;
    esac
}
```

### 8.4 集成监控解决方案

**🔧 企业级监控系统集成**

```bash
# Prometheus + Grafana 监控配置示例

# Node Exporter 配置（收集系统指标）
cat > /etc/systemd/system/node_exporter.service << EOF
[Unit]
Description=Node Exporter
After=network.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/node_exporter

[Install]
WantedBy=multi-user.target
EOF

# 自定义NFS监控指标收集
cat > /usr/local/bin/nfs_exporter.sh << 'EOF'
#!/bin/bash
# nfs_exporter.sh - NFS指标导出器

METRICS_FILE="/var/lib/node_exporter/textfile_collector/nfs_metrics.prom"

collect_nfs_metrics() {
    # NFS调用次数
    nfs_calls=$(nfsstat -s | grep "calls" | awk '{print $2}')
    echo "nfs_total_calls $nfs_calls" > $METRICS_FILE
    
    # NFS错误次数
    nfs_badcalls=$(nfsstat -s | grep "badcalls" | awk '{print $2}')
    echo "nfs_bad_calls $nfs_badcalls" >> $METRICS_FILE
    
    # NFS连接数
    nfs_connections=$(ss -tuln | grep :2049 | wc -l)
    echo "nfs_connections $nfs_connections" >> $METRICS_FILE
}

collect_nfs_metrics
EOF

chmod +x /usr/local/bin/nfs_exporter.sh

# 添加到cron中定期收集
echo "*/1 * * * * /usr/local/bin/nfs_exporter.sh" | crontab -
```

**📊 Grafana仪表板配置**
```json
{
  "dashboard": {
    "title": "NFS/Samba监控",
    "panels": [
      {
        "title": "NFS调用统计",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(nfs_total_calls[5m])",
            "legendFormat": "调用频率"
          }
        ]
      },
      {
        "title": "错误率",
        "type": "singlestat",
        "targets": [
          {
            "expr": "nfs_bad_calls / nfs_total_calls * 100",
            "legendFormat": "错误率 %"
          }
        ]
      }
    ]
  }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 统计监控：nfsstat和smbstatus是基础监控工具
🔸 流量监控：网络流量反映服务使用状况和性能瓶颈
🔸 空间监控：磁盘使用率直接影响服务可用性
🔸 性能分析：系统资源和服务指标的综合分析
🔸 日志管理：合理的日志轮转策略平衡存储和可查性
🔸 自动维护：定时任务减少人工干预，提高可靠性
🔸 预警机制：主动发现问题，防患于未然
🔸 监控集成：企业级监控系统提供完整解决方案
```

### 9.2 关键理解要点


**🔹 监控的层次化思维**
```
基础设施层：
- 硬件资源（CPU、内存、磁盘、网络）
- 操作系统指标（负载、进程、连接）

服务层：
- NFS/Samba服务状态和性能
- 错误率、响应时间、吞吐量

业务层：
- 用户访问模式和体验
- 业务连续性和可用性

数据驱动决策：
- 基于监控数据优化配置
- 预测性维护降低故障风险
```

**🔹 预防性维护的价值**
```
成本效益分析：
预防成本 << 故障损失
- 定期维护的人力成本
- 监控系统的建设成本
- vs 业务中断造成的损失
- vs 数据丢失的恢复成本

最佳实践原则：
- 自动化减少人为错误
- 标准化提高维护效率  
- 文档化便于知识传承
- 监控化实现及时响应
```

**🔹 告警系统的智能化**
```
传统告警问题：
- 阈值告警容易误报
- 缺乏趋势分析能力
- 告警风暴影响响应

智能告警优势：
- 基于趋势的预测性告警
- 多指标关联减少误报
- 分级处理提高效率
- 自动化响应降低MTTR
```

### 9.3 实际应用价值


**🎯 生产环境应用场景**
- **文件服务器**：确保共享文件系统的高可用性和性能
- **开发环境**：监控代码仓库和构建环境的存储使用
- **备份系统**：监控备份进度和存储空间使用情况
- **多媒体服务**：监控大文件传输的网络性能和稳定性

**🔧 运维实践建议**
- **监控粒度**：根据业务重要性调整监控频率和精度
- **告警策略**：建立分级告警机制，避免告警疲劳
- **自动化程度**：逐步提高自动化维护的覆盖范围
- **文档化**：建立完整的故障处理知识库

**📈 技术发展趋势**
- **AI运维**：机器学习预测故障和优化配置
- **云原生监控**：容器化环境的监控方案
- **可观测性**：从监控到全链路可观测性
- **自愈系统**：自动故障检测和恢复机制

**核心记忆口诀**：
- 统计监控看服务，流量空间看资源
- 性能分析找瓶颈，日志轮转控空间  
- 定期维护保稳定，预警机制防未然
- 监控集成全方位，自动运维提效率