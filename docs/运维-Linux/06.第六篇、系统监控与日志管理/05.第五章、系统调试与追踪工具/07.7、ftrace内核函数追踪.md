---
title: 7、ftrace内核函数追踪
---
## 📚 目录

1. [ftrace框架基础概念](#1-ftrace框架基础概念)
2. [tracing接口详解](#2-tracing接口详解)
3. [函数追踪器配置使用](#3-函数追踪器配置使用)
4. [内核函数调用图分析](#4-内核函数调用图分析)
5. [系统事件追踪](#5-系统事件追踪)
6. [文件系统操作追踪](#6-文件系统操作追踪)
7. [网络栈函数追踪](#7-网络栈函数追踪)
8. [自定义追踪点设置](#8-自定义追踪点设置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 ftrace框架基础概念


### 1.1 什么是ftrace


**📋 核心定义**
```
ftrace = Function Tracer（函数追踪器）
本质：Linux内核内置的动态追踪框架
目的：实时监控内核函数调用和系统行为
位置：内核空间的调试工具，无需额外安装
```

> 💡 **通俗理解**：想象ftrace就像给内核装了一个"透视镜"，可以实时看到内核内部各个函数在做什么，就像医生用X光看人体内部一样。

### 1.2 ftrace能做什么


**🎯 主要功能**
```
函数调用监控：
┌─────────────────────────────────┐
│ 用户程序调用 open("/tmp/test")   │
│            ↓                   │
│ 内核函数：sys_open()           │
│            ↓                   │
│ 文件系统：ext4_file_open()     │
│            ↓                   │
│ 磁盘驱动：block_read()         │
└─────────────────────────────────┘
ftrace可以追踪这整个调用链！
```

**实际应用场景**：
- **性能分析**：找出系统慢在哪个函数
- **故障诊断**：查看崩溃前内核在做什么
- **行为理解**：学习内核是如何工作的
- **安全分析**：监控可疑的内核活动

### 1.3 ftrace vs 其他工具


```
┌──────────────┬─────────────┬─────────────┬─────────────┐
│   工具类型   │   工作层面  │   性能开销  │   使用难度  │
├──────────────┼─────────────┼─────────────┼─────────────┤
│ ftrace       │ 内核层      │ 很低        │ 中等        │
│ strace       │ 系统调用层  │ 高          │ 简单        │
│ perf         │ 硬件+内核   │ 低          │ 高          │
│ gdb          │ 用户空间    │ 极高        │ 高          │
└──────────────┴─────────────┴─────────────┴─────────────┘
```

> 🎯 **选择建议**：需要深入了解内核行为且对性能影响要求低时，选择ftrace

---

## 2. 🗂️ tracing接口详解


### 2.1 tracing文件系统位置


**📁 接口路径**
```bash
# ftrace的控制接口位置
/sys/kernel/debug/tracing/

# 如果没有挂载，需要先挂载debugfs
mount -t debugfs none /sys/kernel/debug
```

> 📌 **重要说明**：这个路径就是ftrace的"控制室"，所有的配置和查看都在这里进行

### 2.2 核心文件说明


**🔧 主要控制文件**
```
/sys/kernel/debug/tracing/
├── available_tracers          ← 可用的追踪器列表
├── current_tracer             ← 当前使用的追踪器
├── tracing_on                 ← 追踪开关（0关闭，1开启）
├── trace                      ← 追踪结果输出
├── trace_pipe                 ← 实时追踪输出（类似tail -f）
├── available_filter_functions ← 可追踪的函数列表
├── set_ftrace_filter         ← 设置要追踪的函数
├── set_ftrace_notrace        ← 设置不追踪的函数
└── tracing_max_latency       ← 最大延迟记录
```

### 2.3 基本操作流程


**⚡ 快速上手步骤**
```bash
# 1. 进入tracing目录
cd /sys/kernel/debug/tracing

# 2. 查看可用追踪器
cat available_tracers
# 输出示例：function_graph function nop

# 3. 设置追踪器
echo function > current_tracer

# 4. 开启追踪
echo 1 > tracing_on

# 5. 查看追踪结果
cat trace | head -20

# 6. 关闭追踪
echo 0 > tracing_on
```

> ⚠️ **注意事项**：追踪会产生大量数据，记得及时关闭避免影响系统性能

---

## 3. ⚙️ 函数追踪器配置使用


### 3.1 function追踪器


**📊 基础函数追踪**
```bash
# 设置为函数追踪器
echo function > current_tracer

# 开启追踪
echo 1 > tracing_on

# 执行一个简单命令触发内核调用
ls /tmp

# 查看追踪结果
cat trace
```

**追踪输出格式解读**：
```
# tracer: function
#
# entries-in-buffer/entries-written: 140/140   #P:4
#
#           TASK-PID    CPU#    TIMESTAMP  FUNCTION
#              | |       |         |         |
            bash-1234  [000] 12345.678901: do_sys_open <-SyS_open
            bash-1234  [000] 12345.678902: getname <-do_sys_open
            bash-1234  [000] 12345.678903: path_openat <-do_filp_open
```

> 💡 **字段含义**：
> - `bash-1234`：进程名和PID
> - `[000]`：CPU编号
> - `12345.678901`：时间戳（秒.微秒）
> - `do_sys_open <-SyS_open`：被调用函数 ← 调用者函数

### 3.2 function_graph追踪器


**🌳 函数调用图追踪**
```bash
# 设置为图形追踪器
echo function_graph > current_tracer

# 开启追踪
echo 1 > tracing_on

# 执行命令
echo "test" > /tmp/ftrace_test

# 查看调用图
cat trace
```

**调用图输出示例**：
```
 0)               |  sys_write() {
 0)               |    vfs_write() {
 0)               |      rw_verify_area() {
 0)   0.342 us    |        security_file_permission();
 0)   1.105 us    |      }
 0)               |      ext4_file_write() {
 0)   0.525 us    |        generic_write_checks();
 0)               |        __generic_file_aio_write() {
 0)   2.108 us    |          generic_perform_write();
 0)   3.406 us    |        }
 0)   4.829 us    |      }
 0)   7.542 us    |    }
 0)   8.304 us    |  }
```

> 🎯 **图形说明**：
> - `0)`：CPU编号
> - `{}`：函数的开始和结束
> - `2.108 us`：函数执行时间
> - 缩进层次：显示函数调用的深度

### 3.3 精确函数过滤


**🔍 追踪特定函数**
```bash
# 只追踪sys_open相关函数
echo 'sys_open*' > set_ftrace_filter

# 排除某些函数（避免追踪输出函数本身）
echo '*printk*' > set_ftrace_notrace

# 查看当前过滤设置
cat set_ftrace_filter

# 清空过滤器（追踪所有函数）
echo > set_ftrace_filter
```

**过滤器语法**：
```
通配符使用：
- sys_*        ← 追踪所有sys_开头的函数
- *_open       ← 追踪所有_open结尾的函数  
- ext4_*_write ← 追踪ext4开头且包含write的函数

多个函数：
echo 'sys_open' > set_ftrace_filter
echo 'sys_read' >> set_ftrace_filter  # 注意使用>>追加
```

---

## 4. 📈 内核函数调用图分析


### 4.1 系统调用完整链路追踪


**🔗 文件操作调用链分析**
```bash
# 设置深度限制，避免输出过多
echo 10 > max_graph_depth

# 设置追踪器
echo function_graph > current_tracer

# 只追踪文件操作相关函数
echo 'sys_open*' > set_ftrace_filter
echo 'vfs_*' >> set_ftrace_filter
echo 'ext4_*' >> set_ftrace_filter

# 开启追踪
echo 1 > tracing_on

# 执行文件操作
cat /etc/passwd > /dev/null

# 查看结果
cat trace
```

**调用链路图示**：
```
用户空间                内核空间调用链路
    |
    |  open("/etc/passwd")
    |        ↓
    |   [系统调用层]
    |     sys_open()
    |        ↓
    |   [VFS虚拟文件系统层]  
    |     vfs_open()
    |        ↓
    |   [具体文件系统层]
    |     ext4_file_open()
    |        ↓
    |   [块设备层]
    |     block_read()
    ↓
 硬件设备
```

### 4.2 性能热点分析


**⏱️ 找出耗时函数**
```bash
# 设置追踪器显示时间
echo function_graph > current_tracer

# 只看耗时超过100微秒的函数
echo 100 > tracing_thresh

# 开启追踪
echo 1 > tracing_on

# 执行可能慢的操作
find /home -name "*.log" 2>/dev/null

# 分析耗时函数
cat trace | grep -E '[0-9]+\.[0-9]+ ms|[0-9]+ us' | head -10
```

> 📊 **性能分析技巧**：
> - 设置`tracing_thresh`过滤掉快速函数
> - 关注毫秒级别的函数调用
> - 分析调用频率和单次耗时

---

## 5. 🔄 系统事件追踪


### 5.1 中断处理函数追踪


**⚡ 中断事件监控**
```bash
# 查看可用事件
cat available_events | grep irq

# 启用中断相关事件
echo 1 > events/irq/irq_handler_entry/enable
echo 1 > events/irq/irq_handler_exit/enable

# 设置事件追踪器
echo nop > current_tracer

# 开启追踪
echo 1 > tracing_on

# 产生一些中断（比如网络活动）
ping -c 3 127.0.0.1

# 查看中断处理
cat trace
```

**中断追踪输出示例**：
```
ping-1234  [000] 12345.678: irq_handler_entry: irq=1 name=i8042
ping-1234  [000] 12345.679: irq_handler_exit: irq=1 ret=handled
ping-1234  [001] 12345.680: irq_handler_entry: irq=24 name=eth0
ping-1234  [001] 12345.681: irq_handler_exit: irq=24 ret=handled
```

### 5.2 调度器事件追踪


**📋 进程调度监控**
```bash
# 启用调度相关事件
echo 1 > events/sched/sched_switch/enable
echo 1 > events/sched/sched_wakeup/enable

# 开启追踪
echo 1 > tracing_on

# 运行一个会切换的程序
sleep 1 &

# 查看调度事件
cat trace | grep sched
```

**调度事件说明**：
```
sched_switch: 进程切换事件
- prev_comm: 之前运行的进程
- next_comm: 即将运行的进程
- prev_state: 进程状态（R运行，S睡眠，D不可中断睡眠）

sched_wakeup: 进程唤醒事件  
- comm: 被唤醒的进程名
- target_cpu: 目标CPU
```

---

## 6. 📁 文件系统操作追踪


### 6.1 VFS层操作监控


**🗂️ 虚拟文件系统追踪**
```bash
# 追踪VFS层函数
echo 'vfs_*' > set_ftrace_filter
echo function_graph > current_tracer

# 开启追踪
echo 1 > tracing_on

# 执行文件操作
echo "test content" > /tmp/vfs_test
cat /tmp/vfs_test
rm /tmp/vfs_test

# 查看VFS操作
cat trace
```

**VFS操作层次图**：
```
应用层操作           VFS层函数              具体文件系统
    |                    |                      |
  open()        →    vfs_open()         →   ext4_file_open()
  read()        →    vfs_read()         →   ext4_file_read()  
  write()       →    vfs_write()        →   ext4_file_write()
  close()       →    vfs_close()        →   ext4_file_release()
  unlink()      →    vfs_unlink()       →   ext4_unlink()
```

### 6.2 特定文件系统追踪


**📦 ext4文件系统深度追踪**
```bash
# 只追踪ext4相关函数
echo 'ext4_*' > set_ftrace_filter

# 设置函数图追踪
echo function_graph > current_tracer

# 开启追踪
echo 1 > tracing_on

# 创建文件测试
dd if=/dev/zero of=/tmp/bigfile bs=1M count=10

# 分析ext4内部操作
cat trace | grep -A5 -B5 "ext4_"
```

> 💡 **文件系统追踪用途**：
> - 理解文件系统内部工作机制
> - 诊断文件系统性能问题
> - 分析磁盘I/O操作模式

---

## 7. 🌐 网络栈函数追踪


### 7.1 TCP/IP协议栈追踪


**📡 网络函数监控**
```bash
# 追踪网络相关函数
echo 'tcp_*' > set_ftrace_filter
echo 'ip_*' >> set_ftrace_filter
echo 'netif_*' >> set_ftrace_filter

# 设置追踪器
echo function > current_tracer

# 开启追踪
echo 1 > tracing_on

# 产生网络活动
curl http://www.baidu.com > /dev/null

# 查看网络栈调用
cat trace | head -50
```

**网络栈调用层次**：
```
应用层
  ↓
Socket层: sock_sendmsg() → sock_recvmsg()
  ↓  
TCP层: tcp_sendmsg() → tcp_recvmsg() → tcp_v4_rcv()
  ↓
IP层: ip_output() → ip_input() → ip_route_input()
  ↓
网络设备层: netif_rx() → dev_queue_xmit()
  ↓
驱动层: e1000_xmit_frame()
```

### 7.2 网络包处理追踪


**📦 数据包追踪**
```bash
# 启用网络事件
echo 1 > events/net/netif_rx/enable
echo 1 > events/net/net_dev_xmit/enable

# 开启追踪
echo 1 > tracing_on

# 网络通信测试
ping -c 5 8.8.8.8

# 查看包处理过程
cat trace | grep -E "(netif_rx|net_dev_xmit)"
```

---

## 8. 🎯 自定义追踪点设置


### 8.1 动态函数探测


**🔧 kprobe动态追踪**
```bash
# 在特定函数入口设置探测点
echo 'p:myprobe sys_open filename=+0(%si):string' > kprobe_events

# 启用自定义探测点
echo 1 > events/kprobes/myprobe/enable

# 开启追踪
echo 1 > tracing_on

# 执行操作
ls /etc

# 查看自定义追踪结果
cat trace | grep myprobe
```

**kprobe语法说明**：
```
p:myprobe sys_open filename=+0(%si):string
│ │       │        │
│ │       │        └─ 参数定义：从%si寄存器读取字符串
│ │       └─ 探测的函数名
│ └─ 探测点名称
└─ p表示探测点类型（p=probe, r=return probe）
```

### 8.2 用户自定义事件


**📝 创建追踪事件**
```bash
# 创建自定义追踪点
echo 'syscall_monitor pid filename' > /sys/kernel/debug/tracing/synthetic_events

# 创建触发器
echo 'hist:keys=pid:vals=filename' > events/synthetic/syscall_monitor/trigger

# 启用事件
echo 1 > events/synthetic/syscall_monitor/enable
```

### 8.3 追踪脚本自动化


**🚀 批量追踪脚本**
```bash
#!/bin/bash
# ftrace_monitor.sh - 自动化追踪脚本

TRACE_DIR="/sys/kernel/debug/tracing"

# 清理之前的设置
echo 0 > $TRACE_DIR/tracing_on
echo > $TRACE_DIR/trace
echo > $TRACE_DIR/set_ftrace_filter

# 设置追踪目标
echo 'sys_*' > $TRACE_DIR/set_ftrace_filter
echo function_graph > $TRACE_DIR/current_tracer

# 开始追踪
echo 1 > $TRACE_DIR/tracing_on

# 执行被监控的命令
"$@"

# 停止追踪并输出结果
echo 0 > $TRACE_DIR/tracing_on
cat $TRACE_DIR/trace > "trace_$(date +%Y%m%d_%H%M%S).log"

echo "追踪完成，结果保存到: trace_$(date +%Y%m%d_%H%M%S).log"
```

**使用方法**：
```bash
# 给脚本执行权限
chmod +x ftrace_monitor.sh

# 追踪特定命令
./ftrace_monitor.sh ls -la /home
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 ftrace本质：内核内置的动态追踪框架，用于监控内核函数调用
🔸 接口位置：/sys/kernel/debug/tracing/ 目录下的文件接口
🔸 追踪器类型：function（基础函数追踪）、function_graph（调用图追踪）
🔸 过滤机制：set_ftrace_filter 控制追踪范围，避免信息过载
🔸 事件系统：可追踪系统事件如中断、调度、网络等
```

### 9.2 关键操作流程


**🔹 标准追踪流程**
```
1. 选择追踪器 → echo function > current_tracer
2. 设置过滤器 → echo 'sys_*' > set_ftrace_filter  
3. 开启追踪   → echo 1 > tracing_on
4. 执行操作   → 运行要分析的程序
5. 查看结果   → cat trace
6. 关闭追踪   → echo 0 > tracing_on
```

**🔹 性能优化要点**
```
- 使用过滤器减少追踪范围
- 设置tracing_thresh过滤快速函数
- 限制max_graph_depth避免过深追踪
- 及时关闭追踪避免影响系统性能
```

### 9.3 实际应用价值


**🎯 问题诊断应用**
- **系统性能分析**：找出系统调用中的性能瓶颈函数
- **内核崩溃调试**：追踪崩溃前的函数调用链路
- **文件系统问题**：分析文件操作缓慢的根本原因
- **网络问题诊断**：追踪网络包的处理路径

**🛠️ 学习研究用途**
- **内核机制理解**：通过追踪了解内核工作原理
- **系统调用学习**：观察用户操作如何映射到内核函数
- **驱动开发调试**：分析设备驱动的函数调用
- **性能优化指导**：为代码优化提供数据支持

### 9.4 使用建议与注意事项


> ⚠️ **重要提醒**：
> - ftrace会产生大量数据，在生产环境中谨慎使用
> - 追踪本身有性能开销，不适合长期开启
> - 使用过滤器精确控制追踪范围
> - 大量追踪数据可能快速填满磁盘空间

> 💡 **最佳实践**：
> - 从简单的function追踪开始学习
> - 逐步掌握function_graph的调用图分析
> - 学会使用事件追踪分析特定系统行为
> - 编写自动化脚本提高追踪效率

**核心记忆**：
- ftrace是内核的"透视镜"，让内核函数调用可视化
- 通过/sys/kernel/debug/tracing接口进行所有操作
- 追踪器+过滤器+事件系统构成完整的追踪体系
- 合理使用过滤和限制，平衡信息量和性能影响