---
title: 14、dmesg内核日志管理
---
## 📚 目录

1. [dmesg命令基础概念](#1-dmesg命令基础概念)
2. [内核日志级别系统](#2-内核日志级别系统)
3. [dmesg使用技巧详解](#3-dmesg使用技巧详解)
4. [硬件故障日志分析](#4-硬件故障日志分析)
5. [驱动加载日志查看](#5-驱动加载日志查看)
6. [内核环形缓冲区机制](#6-内核环形缓冲区机制)
7. [启动时序日志分析](#7-启动时序日志分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🖥️ dmesg命令基础概念


### 1.1 什么是dmesg

**dmesg的本质**：dmesg就像是内核的"自言自语日记本"

> 📌 **核心概念**  
> dmesg = display message，显示内核消息的命令
> 它读取内核的环形缓冲区，显示系统启动和运行过程中内核产生的所有消息

**生活化理解**：
```
就像汽车的行车记录仪：
🚗 汽车行驶 = Linux系统运行
📹 记录仪 = 内核环形缓冲区  
📱 回放视频 = dmesg命令查看日志

记录内容：启动过程、硬件检测、驱动加载、错误警告等
```

### 1.2 dmesg的作用和用途

**主要功能**：
```
🔍 系统诊断工具：
- 查看系统启动过程
- 检测硬件故障
- 监控驱动程序状态
- 分析内核错误信息

🛠️ 故障排除助手：
- USB设备插拔检测
- 网卡、声卡等硬件问题
- 内存、磁盘错误诊断
- 内核模块加载失败分析
```

### 1.3 dmesg与其他日志的区别

```
日志类型对比：

/var/log/messages     ← 系统综合日志(经过syslog处理)
/var/log/kern.log     ← 内核日志(syslog格式化后)
dmesg输出            ← 内核原始消息(直接从缓冲区读取)

特点对比：
dmesg：实时、原始、内核直接输出
syslog：格式化、持久存储、经过处理
```

---

## 2. 📊 内核日志级别系统


### 2.1 内核日志级别详解

**8个日志级别**：就像医院的紧急程度分级

```
级别分类（数字越小越紧急）：

0 - EMERG (紧急)    🚨 系统不可用，立即处理
1 - ALERT (警告)    ⚠️  必须立即采取行动
2 - CRIT (严重)     🔥 严重错误条件
3 - ERR (错误)      ❌ 错误条件，但系统可运行
4 - WARNING (警告)  ⚡ 警告条件，需要注意
5 - NOTICE (注意)   📢 正常但重要的条件
6 - INFO (信息)     💡 一般信息性消息
7 - DEBUG (调试)    🔧 调试级别信息
```

### 2.2 日志级别的实际意义

**级别使用场景**：
```
🚨 EMERG示例：
[    0.000000] Kernel panic - not syncing: No working init found.

⚠️ ALERT示例： 
[  120.345678] Out of memory: Kill process 1234 (chrome)

🔥 CRIT示例：
[  89.123456] Machine check events logged

❌ ERR示例：
[  45.678901] ata1.00: failed command: READ FPDMA QUEUED

⚡ WARNING示例：
[  67.890123] WARNING: CPU: 0 PID: 1234 at drivers/gpu/drm/...

💡 INFO示例：
[    2.345678] eth0: link up, 1000Mbps, full-duplex
```

### 2.3 控制显示级别

```bash
# 查看当前日志级别设置
cat /proc/sys/kernel/printk
# 输出：4  4  1  7
# 含义：控制台级别 默认级别 最小级别 启动时级别

# 只显示严重错误(级别0-3)
dmesg -l err,crit,alert,emerg

# 只显示警告和错误(级别0-4)  
dmesg -l 0-4

# 实时监控重要消息
dmesg -w -l 0-4
```

---

## 3. 🔧 dmesg使用技巧详解


### 3.1 基本查看命令

```bash
# 最基本用法：显示所有内核消息
dmesg

# 分页显示（推荐）
dmesg | less

# 显示最新50条消息
dmesg | tail -50

# 实时监控新消息（类似tail -f）
dmesg -w
```

### 3.2 时间格式化显示

**让时间更易读**：
```bash
# 显示人类可读的时间格式
dmesg -T
# 输出示例：
# [Mon Sep 15 10:30:25 2025] USB disconnect, address 1

# 显示相对时间（从启动开始的秒数）
dmesg -t
# 输出示例：
# [  120.345678] usb 1-1: new high-speed USB device

# 不显示时间戳
dmesg -t | head -10
```

### 3.3 过滤和搜索技巧

```bash
# 搜索USB相关消息
dmesg | grep -i usb

# 搜索错误和警告
dmesg | grep -E "(error|warning|fail)" -i

# 搜索特定硬件(网卡)
dmesg | grep -i "eth0\|nic\|network"

# 查看内存相关信息
dmesg | grep -i "memory\|mem:"

# 组合过滤：最近的USB错误
dmesg -T | grep -i usb | grep -i error | tail -5
```

### 3.4 输出格式化选项

```bash
# 彩色显示（便于区分级别）
dmesg --color=always | less -R

# 显示日志来源设施
dmesg -f kern

# 原始格式（不处理转义字符）
dmesg -r

# JSON格式输出（便于脚本处理）
dmesg -J
```

---

## 4. 🔍 硬件故障日志分析


### 4.1 常见硬件故障特征

**硬件故障的"症状"**：

```bash
# 💽 硬盘故障特征
dmesg | grep -i "ata\|sata\|disk\|bad block"
# 典型输出：
# ata1.00: exception Emask 0x0 SAct 0x0 SErr 0x0 action 0x0
# end_request: I/O error, dev sda, sector 123456

# 🧠 内存故障特征  
dmesg | grep -i "memory\|ecc\|machine check"
# 典型输出：
# EDAC MC0: 1 CE memory read error on CPU_SrcID#0_Channel#0_DIMM#0

# 🌡️ CPU温度过热
dmesg | grep -i "thermal\|temperature\|cpu.*hot"
# 典型输出：
# thermal thermal_zone0: critical temperature reached(105 C)
```

### 4.2 硬件故障分析实例

**实际故障案例分析**：

> 🔥 **案例1：硬盘坏道**
```bash
$ dmesg | grep sda
[  456.789] ata1.00: failed command: READ FPDMA QUEUED
[  456.790] ata1.00: cmd 60/08:00:40:02:00/00:00:00:00:00/40 tag 0
[  456.791] end_request: I/O error, dev sda, sector 512

# 分析：硬盘sda在512扇区出现读取错误，可能是坏道
# 建议：立即备份数据，考虑更换硬盘
```

> ⚠️ **案例2：USB设备故障**
```bash
$ dmesg | grep -i usb | tail -5
[  789.123] usb 1-1: device descriptor read/64, error -110
[  789.345] usb 1-1: device not accepting address 2, error -110
[  789.567] usb 1-1-port1: cannot reset (err = -110)

# 分析：USB设备无法正常识别，可能是设备损坏或供电不足
# 建议：更换USB口或检查设备状态
```

### 4.3 硬件监控脚本

```bash
#!/bin/bash
# 硬件健康监控脚本

echo "=== 硬件故障检查报告 ==="
echo "检查时间: $(date)"
echo

# 检查硬盘错误
echo "💽 硬盘状态检查:"
dmesg | grep -i "ata.*error\|bad block\|I/O error" | tail -5

# 检查内存错误
echo -e "\n🧠 内存状态检查:"
dmesg | grep -i "memory.*error\|ecc.*error" | tail -3

# 检查温度警告
echo -e "\n🌡️ 温度状态检查:"
dmesg | grep -i "thermal.*critical\|temperature.*high" | tail -3

echo -e "\n=== 检查完成 ==="
```

---

## 5. 🔌 驱动加载日志查看


### 5.1 驱动加载过程分析

**驱动加载就像"安装翻译官"**：

```
硬件设备 ←→ 驱动程序 ←→ 操作系统

过程类比：
1. 硬件："我是网卡，请与我通信"
2. 内核："我需要网卡驱动来理解你"  
3. 驱动："我来做翻译，建立通信桥梁"
4. 系统："连接成功，可以上网了"
```

### 5.2 查看驱动加载日志

```bash
# 查看所有驱动加载信息
dmesg | grep -i "driver\|module"

# 查看网卡驱动加载
dmesg | grep -E "(eth|wlan|wifi|driver.*net)"

# 查看显卡驱动加载
dmesg | grep -i "drm\|gpu\|nvidia\|radeon"

# 查看USB驱动加载
dmesg | grep -i "usb.*driver\|usbcore"

# 查看声卡驱动加载
dmesg | grep -i "sound\|audio\|alsa"
```

### 5.3 驱动问题诊断

**常见驱动问题和解决**：

```bash
# 🔍 检查驱动加载失败
dmesg | grep -i "driver.*fail\|module.*error"

# 典型输出分析：
[    5.678] nvidia: module license 'NVIDIA' taints kernel.
[    5.679] nvidia: unknown symbol in module, or unknown parameter
[    5.680] nvidia: disagrees about version of symbol module_layout

# 问题分析：NVIDIA驱动与内核版本不匹配
# 解决方案：重新编译驱动或更新到匹配版本
```

> 💡 **驱动问题排查步骤**
> 1. 确认硬件是否被识别：`lspci` 或 `lsusb`
> 2. 查看驱动加载状态：`lsmod | grep 驱动名`
> 3. 检查驱动错误信息：`dmesg | grep 驱动名`
> 4. 手动加载驱动测试：`modprobe 驱动名`

### 5.4 驱动加载成功示例

```bash
# ✅ 网卡驱动加载成功示例
$ dmesg | grep eth0
[    2.345] e1000e 0000:00:19.0 eth0: registered as PCnet/PCI II 79C970A
[    2.346] e1000e 0000:00:19.0 eth0: link up, 1000Mbps, full-duplex
[    2.347] e1000e 0000:00:19.0 eth0: IPv4 address: 192.168.1.100

# ✅ 声卡驱动加载成功示例  
$ dmesg | grep audio
[    3.456] snd_hda_intel 0000:00:1b.0: chipset global capabilities = 0x4401
[    3.457] snd_hda_intel 0000:00:1b.0: codec #0 found
[    3.458] input: HDA Intel PCH Front Mic as /devices/...
```

---

## 6. 🔄 内核环形缓冲区机制


### 6.1 环形缓冲区原理

**环形缓冲区就像"录音机的磁带"**：

```
环形缓冲区工作原理：

开始位置 ────────────────── 结束位置
    ↓                        ↓
   [老数据][新数据][新数据][老数据]
              ↑       ↑
           写入位置  读取位置

特点：
✅ 固定大小：通常128KB-1MB
✅ 循环覆盖：新数据覆盖旧数据  
✅ 实时更新：内核持续写入
✅ 快速访问：内存中直接读取
```

### 6.2 查看缓冲区状态

```bash
# 查看缓冲区大小设置
cat /proc/sys/kernel/dmesg_restrict
# 0=所有用户可读，1=仅root可读

# 查看当前缓冲区使用情况
dmesg -s
# 显示缓冲区大小信息

# 清空缓冲区（需要root权限）
dmesg -c
# 清空后再查看dmesg将为空
```

### 6.3 缓冲区大小配置

```bash
# 查看内核编译时的缓冲区大小
grep CONFIG_LOG_BUF_SHIFT /boot/config-$(uname -r)
# CONFIG_LOG_BUF_SHIFT=17 表示 2^17 = 128KB

# 启动时修改缓冲区大小
# 在GRUB配置中添加：log_buf_len=1M

# 运行时查看实际大小
dmesg | wc -l  # 查看消息行数
dmesg | wc -c  # 查看字符总数
```

### 6.4 环形缓冲区的局限性

> ⚠️ **重要限制**
> - **数据会丢失**：旧消息被新消息覆盖
> - **无持久化**：重启后全部清空
> - **大小有限**：无法存储所有历史消息
> - **实时性强**：适合当前状态诊断

**解决方案**：
```bash
# 重要消息自动保存到文件
dmesg -w >> /var/log/dmesg.log &

# 定期保存快照
(crontab -l; echo "*/5 * * * * dmesg > /tmp/dmesg.$(date +%H%M)") | crontab -
```

---

## 7. ⏰ 启动时序日志分析


### 7.1 系统启动过程解析

**启动过程就像"开车启动"**：

```
系统启动时序：

🔧 BIOS/UEFI  ──→  🐧 内核加载  ──→  🏗️ 驱动初始化  ──→  🎯 用户空间启动
   (0-1秒)         (1-3秒)          (3-10秒)           (10秒+)
      │               │                │                  │
   硬件检测        内核解压         硬件驱动加载        服务启动
   内存测试        进程调度         文件系统挂载        用户登录
```

### 7.2 启动时间分析

```bash
# 查看启动时间线
dmesg -T | head -20

# 查看内核启动耗时
dmesg | grep "Freeing unused kernel memory"
# [    2.345678] Freeing unused kernel memory: 1234K

# 查看第一个用户进程启动
dmesg | grep "init:"
# [    3.456789] Run /sbin/init as init process

# 分析启动慢的原因
dmesg | grep -E "(delay|timeout|waiting|slow)"
```

### 7.3 启动故障诊断

**常见启动问题**：

```bash
# 🚫 文件系统错误
dmesg | grep -i "filesystem\|fsck\|ext4.*error"
# 典型输出：
# EXT4-fs error (device sda1): ext4_journal_check_start:56

# ⏳ 硬件初始化超时
dmesg | grep -i "timeout\|timed out"
# 典型输出：
# ata1.00: qc timeout (cmd 0xec)
# ata1.00: failed to IDENTIFY (I/O error, err_mask=0x4)

# 🔌 USB设备初始化问题
dmesg | grep -i "usb.*fail\|usb.*timeout"
```

### 7.4 启动性能优化分析

```bash
#!/bin/bash
# 启动性能分析脚本

echo "=== 启动性能分析报告 ==="

# 内核启动时间
kernel_time=$(dmesg | grep "Freeing unused kernel memory" | awk '{print $2}' | tr -d '[]')
echo "内核启动时间: ${kernel_time}秒"

# 第一个进程启动时间  
init_time=$(dmesg | grep "init:" | head -1 | awk '{print $2}' | tr -d '[]')
echo "init进程启动时间: ${init_time}秒"

# 查找启动慢的设备
echo -e "\n启动耗时较长的设备:"
dmesg | grep -E "([5-9]\.[0-9]{6}|[1-9][0-9]\.[0-9]{6})" | head -5

# 查找启动错误
echo -e "\n启动过程中的错误:"
dmesg | grep -i "error\|fail" | head -3
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念

```
🔸 dmesg本质：读取内核环形缓冲区的消息显示工具
🔸 日志级别：8个级别从紧急(0)到调试(7)，数字越小越重要
🔸 环形缓冲区：固定大小的循环存储，新数据覆盖旧数据
🔸 时间格式：支持多种时间显示格式，-T选项最常用
🔸 过滤技巧：结合grep进行精确搜索和问题定位
```

### 8.2 关键使用技巧

**🔹 日常检查命令**：
```bash
# 基础检查套装
dmesg -T | tail -20           # 查看最新消息
dmesg | grep -i error         # 查找错误信息  
dmesg | grep -i "usb\|disk"   # 查看硬件状态
dmesg -w                      # 实时监控新消息
```

**🔹 故障排查思路**：
```
问题分析步骤：
1. 现象确认：系统出现什么问题？
2. 时间定位：dmesg -T 找到问题发生时间
3. 关键词搜索：grep 相关硬件或错误关键词
4. 日志级别筛选：-l 选项过滤重要消息
5. 持续监控：-w 选项观察问题重现
```

**🔹 硬件诊断要点**：
```
硬件问题特征词：
💽 硬盘：ata, sata, disk, bad block, I/O error
🧠 内存：memory error, ecc, machine check  
🔌 USB：usb, device descriptor, cannot reset
🌡️ 温度：thermal, temperature, critical
📶 网络：eth, wlan, link up/down, driver
```

### 8.3 实际应用场景

- **系统启动慢**：分析启动时序，找出瓶颈设备
- **硬件故障**：通过错误信息定位故障硬件
- **驱动问题**：检查模块加载状态和错误信息
- **性能诊断**：监控内核级别的性能警告
- **安全检查**：查看异常的内核行为和警告

### 8.4 最佳实践建议

> 💡 **使用建议**
> - **定期检查**：每天查看dmesg输出，及时发现问题
> - **保存重要日志**：关键错误信息及时备份到文件
> - **组合使用**：dmesg配合系统其他日志工具综合分析
> - **脚本自动化**：编写脚本定期检查和报告硬件状态

**核心记忆口诀**：
```
dmesg内核日志查，环形缓冲存消息
八级日志分轻重，硬件故障它来报  
启动时序可分析，驱动加载状态明
grep过滤定问题，-T时间更清晰
```