---
title: 2、CPU性能监控与分析
---
## 📚 目录

1. [CPU使用率基础概念](#1-cpu使用率基础概念)
2. [Load Average负载平均值详解](#2-load-average负载平均值详解)
3. [CPU上下文切换监控](#3-cpu上下文切换监控)
4. [中断与软中断分析](#4-中断与软中断分析)
5. [CPU亲和性设置](#5-cpu亲和性设置)
6. [多核系统性能特征](#6-多核系统性能特征)
7. [CPU调度器类型与特性](#7-cpu调度器类型与特性)
8. [CPU性能计数器使用](#8-cpu性能计数器使用)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 💻 CPU使用率基础概念


### 1.1 CPU使用率是什么

**简单理解**：CPU使用率就像工人的忙碌程度 - 工人一天8小时，干活6小时，那忙碌率就是75%

CPU有四种主要状态，就像工人的四种工作状态：

```
工人状态类比          CPU状态              含义
正常干活      →      user时间       →   运行用户程序
帮老板办事    →      system时间     →   执行系统调用
休息等待      →      idle时间       →   空闲状态  
等材料到货    →      iowait时间     →   等待磁盘IO
```

### 1.2 四种CPU时间详解


**🔸 User时间（用户态）**
- **含义**：CPU执行用户程序的时间
- **例子**：运行计算器程序做数学运算
- **特点**：这是应用程序真正"干活"的时间

**🔸 System时间（内核态）**  
- **含义**：CPU执行系统调用和内核程序的时间
- **例子**：程序要读文件，需要调用系统的文件读取功能
- **特点**：为用户程序"服务"的时间

**🔸 Idle时间（空闲）**
- **含义**：CPU无事可做的时间
- **例子**：没有程序需要运行，CPU在"打盹"
- **特点**：系统轻松的标志

**🔸 IOWait时间（IO等待）**
- **含义**：CPU等待磁盘、网络等IO操作完成的时间
- **例子**：程序要读大文件，CPU等着硬盘把数据找出来
- **特点**：**不是CPU忙**，是CPU在"等快递"

### 1.3 使用率计算原理


```
CPU总时间 = user + system + idle + iowait + 其他

CPU使用率 = (user + system) / CPU总时间 × 100%

系统繁忙度 = (user + system + iowait) / CPU总时间 × 100%
```

**重要理解**：
- ⚠️ **IOWait≠CPU忙** - 高IOWait说明磁盘慢，不是CPU慢
- ✅ **真正的CPU忙碌** = User + System时间占比高
- 📊 **理想状态** = User高、System低、IOWait低

### 1.4 常用监控命令


**`top`命令解读**：
```bash
top - 14:30:25 up 5 days,  2:15,  3 users,  load average: 0.15, 0.25, 0.30
%Cpu(s):  5.2 us,  2.1 sy,  0.0 ni, 91.2 id,  1.5 wa,  0.0 hi,  0.0 si,  0.0 st

解释：
us = user     → 用户程序占用5.2%
sy = system   → 系统调用占用2.1%  
id = idle     → 空闲时间91.2%
wa = iowait   → IO等待1.5%
```

**实用监控技巧**：
```bash
# 查看实时CPU使用率
top -d 1

# 查看平均CPU使用率
sar -u 1 10

# 按CPU使用率排序进程
top -o %CPU
```

---

## 2. ⚖️ Load Average负载平均值详解


### 2.1 Load Average是什么


**生动比喻**：Load Average就像银行排队情况
- **负载1.0** = 正好1个窗口服务1个客户，刚好忙完
- **负载2.0** = 1个窗口要服务2个客户，有人要等待
- **负载0.5** = 1个窗口只服务0.5个客户，窗口还有空闲

```
单核CPU系统的负载理解：

负载值     系统状态            实际情况
0.00      完全空闲      →    CPU无事可做
0.70      正常繁忙      →    CPU利用充分，响应及时  
1.00      满负荷运行    →    CPU持续工作，无空闲
1.50      轻度超载      →    有任务排队等待
2.00      中度超载      →    排队任务较多
5.00      严重超载      →    系统响应缓慢
```

### 2.2 三个时间段的含义


**Load Average显示三个数字**：
```bash
load average: 1.15, 0.78, 0.65
             ↑     ↑     ↑
           1分钟  5分钟  15分钟
```

**时间段意义**：
- **1分钟平均值** - 系统当前的瞬时状态
- **5分钟平均值** - 最近的短期趋势  
- **15分钟平均值** - 系统长期运行状态

**趋势分析技巧**：
```
1.50, 1.20, 0.80  →  负载在上升，需要关注
0.60, 0.80, 1.20  →  负载在下降，系统在好转
1.00, 1.00, 1.00  →  负载稳定，系统状态平稳
```

### 2.3 多核系统的负载计算


**关键理解**：多核系统的负载上限 = CPU核心数

```
系统配置对比：

单核系统：
- 负载1.0 = 满负荷
- 负载2.0 = 超载100%

四核系统：  
- 负载1.0 = 轻度负荷（25%）
- 负载4.0 = 满负荷（100%）
- 负载8.0 = 超载100%
```

**实用判断标准**：
- ✅ **负载 < 核心数** - 系统正常
- ⚠️ **负载 = 核心数** - 系统满负荷
- 🔥 **负载 > 核心数** - 系统超载

### 2.4 负载高的原因分析


```
高负载原因排查流程：

1️⃣ CPU密集型任务
   → 大量计算程序在运行
   → 特征：user时间高，iowait低

2️⃣ IO密集型任务  
   → 频繁读写磁盘或网络
   → 特征：iowait时间高，user低

3️⃣ 进程数过多
   → 大量进程争抢CPU资源
   → 特征：运行队列长，上下文切换频繁

4️⃣ 系统调用过多
   → 程序频繁调用系统功能
   → 特征：system时间高
```

---

## 3. 🔄 CPU上下文切换监控


### 3.1 什么是上下文切换


**通俗解释**：上下文切换就像工人换工作台

```
工人工作场景：                 CPU上下文切换：
工人A在1号台做零件    →      进程A在CPU上运行
老板说：去2号台帮忙   →      操作系统调度器介入  
工人A收拾工具材料     →      保存进程A的状态
工人A走到2号台       →      切换到进程B
工人A在2号台开始干活  →      进程B开始在CPU上运行
```

**切换过程包含**：
- **保存现场** - 保存当前进程的寄存器、内存状态
- **加载现场** - 恢复要运行进程的寄存器、内存状态  
- **重新执行** - 新进程从上次停止的地方继续运行

### 3.2 上下文切换的类型


**🔸 进程切换（Process Context Switch）**
- **发生时机**：时间片用完、进程阻塞、优先级抢占
- **开销**：较大，需要切换内存空间
- **例子**：从浏览器切换到音乐播放器

**🔸 线程切换（Thread Context Switch）**  
- **发生时机**：同进程内线程间切换
- **开销**：较小，共享内存空间
- **例子**：浏览器内从网页渲染线程切换到脚本执行线程

**🔸 中断切换（Interrupt Context Switch）**
- **发生时机**：硬件中断发生
- **开销**：最小，只保存少量寄存器
- **例子**：网卡收到数据包触发中断

### 3.3 监控上下文切换


**使用`vmstat`命令**：
```bash
vmstat 1 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0 754232  98324 286840    0    0    12    8   85  182  6  2 91  1  0
 
重要字段解释：
cs = context switches  → 每秒上下文切换次数
in = interrupts       → 每秒中断次数
```

**使用`pidstat`查看进程级别**：
```bash
pidstat -w 1
# -w参数显示上下文切换信息

输出解释：
cswch/s  → 每秒主动上下文切换（进程主动让出CPU）
nvcswch/s → 每秒被动上下文切换（被操作系统强制切换）
```

### 3.4 上下文切换性能影响


**正常切换频率**：
- **<1000次/秒** - 正常范围
- **1000-10000次/秒** - 需要关注  
- **>10000次/秒** - 性能问题

**高切换的危害**：
```
问题影响链：

过多上下文切换
    ↓
CPU花大量时间做切换
    ↓  
真正处理业务的时间减少
    ↓
系统响应速度变慢
    ↓
用户感受到卡顿
```

---

## 4. ⚡ 中断与软中断分析


### 4.1 中断机制原理


**生活类比**：中断就像突发事件处理

```
日常生活场景：              计算机中断机制：
你在专心工作         →     CPU在执行程序
突然电话响了         →     硬件发出中断信号
暂停工作接电话       →     CPU暂停当前程序
处理电话事务         →     执行中断处理程序  
电话结束继续工作     →     返回原程序继续执行
```

### 4.2 硬中断（Hard Interrupt）


**特点**：
- **触发者**：硬件设备（网卡、磁盘、键盘等）
- **处理方式**：立即响应，不能被打断
- **处理时间**：尽可能短，只做最关键的工作

**常见硬中断**：
```
中断类型          触发设备              处理内容
网络中断    →    网卡收发数据     →    接收数据包到内核
磁盘中断    →    硬盘读写完成     →    通知IO操作完成
时钟中断    →    系统定时器       →    更新系统时间
键盘中断    →    键盘按键         →    读取按键信息
```

### 4.3 软中断（Soft Interrupt）


**设计目的**：把硬中断中不紧急的工作延后处理

**工作流程**：
```
1️⃣ 硬中断发生
   → 只做最紧急的事（比如接收数据包）
   
2️⃣ 设置软中断标记  
   → 告诉系统"稍后还有事要做"
   
3️⃣ 硬中断处理完成
   → 恢复正常程序执行
   
4️⃣ 合适时机处理软中断
   → 完成剩余的工作（比如协议栈处理）
```

**常见软中断类型**：
- **NET_TX** - 网络数据发送
- **NET_RX** - 网络数据接收  
- **TIMER** - 定时器处理
- **TASKLET** - 任务调度

### 4.4 中断监控方法


**查看中断统计**：
```bash
# 查看硬中断统计
cat /proc/interrupts

# 查看软中断统计  
cat /proc/softirqs

# 实时监控中断
watch -n 1 'cat /proc/interrupts'
```

**`top`命令中的中断信息**：
```bash
%Cpu(s): 5.2 us, 2.1 sy, 0.0 ni, 91.2 id, 1.5 wa, 0.0 hi, 0.0 si, 0.0 st

hi = 硬中断时间占比
si = 软中断时间占比
```

**中断优化技巧**：
- **中断绑定** - 将特定中断绑定到特定CPU核心
- **中断合并** - 减少中断频率，批量处理
- **NAPI机制** - 网络设备的轮询与中断混合模式

---

## 5. 🎯 CPU亲和性设置


### 5.1 CPU亲和性概念


**简单理解**：CPU亲和性就是给进程指定"专用服务员"

```
餐厅服务类比：                CPU亲和性：
顾客可以被任何服务员服务  →   进程可以在任何CPU核心运行
顾客指定1号服务员专门服务  →   进程绑定到特定CPU核心运行
```

**亲和性的好处**：
- **缓存命中率高** - 进程数据留在固定CPU的缓存中
- **减少缓存失效** - 避免在不同CPU间搬移数据
- **性能更稳定** - 避免跨核心的性能波动

### 5.2 NUMA架构影响


**NUMA结构图**：
```
CPU架构示意：

       Memory0              Memory1
          |                   |
    ┌─────────────┐     ┌─────────────┐
    │  CPU0 CPU1  │     │  CPU2 CPU3  │
    │             │     │             │  
    │    Node0    │────▶│    Node1    │
    └─────────────┘     └─────────────┘
          ▲                   ▲
          │                   │
       Local访问            Remote访问
       (速度快)              (速度慢)
```

**NUMA亲和性原则**：
- ✅ **本地内存访问** - 进程在同Node的CPU运行
- ❌ **跨Node访问** - 进程访问远程Node的内存

### 5.3 设置CPU亲和性


**使用`taskset`命令**：
```bash
# 查看进程的CPU亲和性
taskset -p [PID]

# 设置进程只在CPU 0和1上运行  
taskset -p 0x3 [PID]

# 启动程序时指定CPU亲和性
taskset -c 0,1 ./my_program

# CPU掩码对照表：
0x1 = 二进制0001 = 只使用CPU0
0x3 = 二进制0011 = 使用CPU0和CPU1  
0xF = 二进制1111 = 使用CPU0-3
```

**设置中断亲和性**：
```bash
# 查看网卡中断号
cat /proc/interrupts | grep eth0

# 设置中断只在CPU0处理
echo 1 > /proc/irq/24/smp_affinity
```

### 5.4 亲和性应用场景


| 应用场景 | **设置策略** | **效果** |
|---------|------------|----------|
| **高性能计算** | `绑定连续CPU核心` | `提高缓存命中率` |
| **网络服务** | `中断与应用分离` | `减少中断干扰` |
| **数据库** | `绑定NUMA本地内存` | `降低内存访问延迟` |
| **实时应用** | `独占CPU核心` | `保证响应时间` |

---

## 6. 🔧 多核系统性能特征


### 6.1 并行与并发的区别


**概念澄清**：
```
并发(Concurrency)：          并行(Parallelism)：
一个人同时处理多个任务        多个人同时处理多个任务
   
┌─任务A─┐                    ┌─任务A─┐ CPU0
│  ──── │切换                │  ──── │
└───────┘                    └───────┘
┌─任务B─┐                    ┌─任务B─┐ CPU1  
│  ──── │切换                │  ──── │
└───────┘                    └───────┘
单核心多任务                  多核心多任务
```

### 6.2 多核架构类型


**🔸 SMP（对称多处理）**
```
SMP架构特点：
    CPU0    CPU1    CPU2    CPU3
     │       │       │       │
     └───────┼───────┼───────┘
             │       │
         共享总线和内存
         
优点：编程简单，所有CPU地位相等
缺点：总线成为瓶颈，扩展性差
```

**🔸 NUMA（非一致内存访问）**
```
NUMA架构特点：
Node0                    Node1
CPU0-CPU1               CPU2-CPU3
   │                       │
Memory0 ←─────互联─────→ Memory1

优点：扩展性好，内存带宽高
缺点：程序需要考虑内存位置
```

### 6.3 多核性能优化策略


**🎯 任务分配策略**
- **CPU密集型任务** - 分配到不同物理核心
- **IO密集型任务** - 可以共享物理核心  
- **缓存敏感任务** - 绑定到固定核心

**⚖️ 负载均衡考虑**
```bash
# 查看各CPU核心负载
mpstat -P ALL 1

# 输出示例：
CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
all    12.50    0.00    2.50    0.00    0.00    0.00    0.00    0.00    0.00   85.00
0      25.00    0.00    5.00    0.00    0.00    0.00    0.00    0.00    0.00   70.00
1       0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
```

**🔧 优化实践**：
- **避免False Sharing** - 防止多核心争抢同一缓存行
- **合理设置线程数** - 通常 = CPU核心数
- **使用线程池** - 减少线程创建销毁开销

---

## 7. 📊 CPU调度器类型与特性


### 7.1 Linux调度器演进


**调度器发展历史**：
```
时间线               调度器                主要特点
1991-2003     →    O(n)调度器      →    简单但效率低
2003-2007     →    O(1)调度器      →    固定时间复杂度  
2007-至今     →    CFS调度器       →    完全公平调度
```

### 7.2 CFS（完全公平调度器）


**核心思想**：让每个进程获得公平的CPU时间

**工作原理**：
```
CFS调度原理：

1️⃣ 虚拟运行时间
   每个进程有vruntime（虚拟运行时间）
   vruntime = 实际运行时间 × 权重系数

2️⃣ 红黑树排序
   按vruntime从小到大排列进程
   vruntime最小的进程优先运行

3️⃣ 自动平衡
   运行时间越长，vruntime越大
   排队位置越靠后，实现公平
```

**调度参数**：
```bash
# 查看调度器信息
cat /proc/sched_debug

# 重要参数：
sched_latency_ns     # 调度延迟（默认6ms）
sched_min_granularity_ns  # 最小时间片（默认0.75ms）
sched_wakeup_granularity_ns  # 唤醒抢占粒度（默认1ms）
```

### 7.3 实时调度策略


**🔸 SCHED_FIFO（先进先出）**
- **特点**：一旦运行就独占CPU，直到主动让出
- **适用**：最高优先级的实时任务
- **风险**：可能导致系统卡死

**🔸 SCHED_RR（时间片轮转）**  
- **特点**：相同优先级进程轮流执行
- **适用**：多个实时任务需要公平调度
- **时间片**：默认100ms

**🔸 SCHED_DEADLINE（截止期调度）**
- **特点**：基于任务截止期的调度
- **适用**：硬实时系统
- **参数**：运行时间、截止期、周期

### 7.4 调度器配置实例


```bash
# 查看进程调度策略
chrt -p [PID]

# 设置进程为实时优先级
chrt -f -p 50 [PID]    # FIFO策略，优先级50
chrt -r -p 50 [PID]    # RR策略，优先级50

# 设置进程nice值（影响CFS权重）
nice -n 10 ./program   # 启动时设置
renice 5 [PID]         # 运行时调整
```

---

## 8. 📈 CPU性能计数器使用


### 8.1 性能计数器概念


**什么是性能计数器**：CPU内置的硬件监控功能，可以统计各种性能事件

**监控能力**：
```
硬件事件类别：

指令相关：
- instructions          → 执行的指令总数
- cycles                → CPU时钟周期数
- branches              → 分支指令数
- branch-misses         → 分支预测失误数

缓存相关：
- cache-references      → 缓存访问次数  
- cache-misses          → 缓存失误次数
- L1-dcache-loads       → L1数据缓存加载
- LLC-loads             → 最后级缓存加载

内存相关：
- page-faults           → 页面错误数
- minor-faults          → 轻微页面错误
- major-faults          → 严重页面错误
```

### 8.2 使用perf工具


**基础监控命令**：
```bash
# 监控系统整体性能
perf stat -a sleep 10

# 监控特定进程
perf stat -p [PID] sleep 10

# 监控特定命令执行
perf stat ./my_program

# 示例输出：
Performance counter stats for 'sleep 10':
          0.50 msec task-clock                #    0.000 CPUs utilized          
             1      context-switches          #    0.002 M/sec                  
             0      cpu-migrations            #    0.000 K/sec                  
            49      page-faults               #    0.098 M/sec                  
     1,574,173      cycles                    #    3.148 GHz                    
       735,453      instructions              #    0.47  insn per cycle         
```

### 8.3 性能分析实例


**🔍 缓存命中率分析**：
```bash
# 监控缓存性能
perf stat -e cache-references,cache-misses ./program

# 计算缓存命中率
缓存命中率 = (cache-references - cache-misses) / cache-references × 100%

# 优秀的缓存命中率：
L1缓存：>95%
L2缓存：>85%  
L3缓存：>70%
```

**🔍 分支预测分析**：
```bash
# 监控分支预测
perf stat -e branches,branch-misses ./program

# 分支预测成功率
预测成功率 = (branches - branch-misses) / branches × 100%

# 优秀的预测成功率：>90%
```

### 8.4 性能调优建议


**基于计数器的优化方向**：

| 指标 | **问题特征** | **优化建议** |
|------|-------------|-------------|
| **高缓存失误率** | `cache-misses很高` | `优化数据结构布局，减少内存跳跃访问` |
| **高分支失误率** | `branch-misses很高` | `减少条件分支，使用查表法替代` |
| **低IPC比率** | `instructions/cycles<1` | `减少数据依赖，增加指令级并行` |
| **高页面错误** | `page-faults很高` | `优化内存使用模式，预分配内存` |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 CPU使用率 = User + System时间，IOWait不算CPU忙碌
🔸 Load Average = 系统负载，多核系统上限 = 核心数  
🔸 上下文切换 = 进程间切换开销，过多影响性能
🔸 中断机制 = 硬中断处理紧急事件，软中断处理后续工作
🔸 CPU亲和性 = 绑定进程到特定核心，提高缓存效率
🔸 多核特征 = 理解NUMA架构，合理分配任务
🔸 调度器 = CFS保证公平，实时调度保证响应
🔸 性能计数器 = 硬件级性能监控，精确分析瓶颈
```

### 9.2 关键理解要点


**🔹 性能监控的层次思维**
```
系统层面 → Load Average整体负载
进程层面 → CPU使用率分布  
硬件层面 → 性能计数器详细分析
```

**🔹 优化策略的优先级**
```
1️⃣ 减少不必要的计算（算法优化）
2️⃣ 提高缓存命中率（数据局部性）
3️⃣ 减少上下文切换（合理并发）
4️⃣ 利用多核并行（任务分解）
```

### 9.3 实际应用指导


**🎯 性能问题诊断流程**：
```
发现问题 → 查看Load Average判断整体负载
         ↓
      分析top输出确定CPU使用类型
         ↓  
    使用perf/pidstat定位具体进程
         ↓
   性能计数器分析微观性能问题
         ↓
     制定针对性优化方案
```

**⚡ 常用监控命令速查**：
- **实时监控** - `top`, `htop`
- **历史数据** - `sar -u`  
- **上下文切换** - `vmstat`, `pidstat -w`
- **中断统计** - `/proc/interrupts`, `/proc/softirqs`
- **性能计数器** - `perf stat`
- **CPU亲和性** - `taskset`

**核心记忆**：
- CPU性能监控要看懂四种时间使用情况
- Load Average反映系统整体繁忙程度  
- 上下文切换过多是性能杀手
- 合理利用多核和缓存是优化关键