---
title: 11、性能监控与数据采集
---
## 📚 目录

1. [性能监控基础概念](#1-性能监控基础概念)
2. [系统性能监控工具详解](#2-系统性能监控工具详解)
3. [sar性能数据采集](#3-sar性能数据采集)
4. [iostat I/O统计监控](#4-iostat-io统计监控)
5. [vmstat内存统计监控](#5-vmstat内存统计监控)
6. [网络流量监控](#6-网络流量监控)
7. [应用性能指标采集](#7-应用性能指标采集)
8. [实时性能数据展示](#8-实时性能数据展示)
9. [性能数据存储管理](#9-性能数据存储管理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 性能监控基础概念


### 1.1 什么是性能监控


**📋 核心定义**
```
性能监控：实时收集和分析系统运行状态的过程
目标：发现性能瓶颈，优化系统效率，预防故障
本质：把看不见的系统状态"可视化"
```

> 💡 **通俗理解**：就像医生给病人做体检，通过各种指标了解身体状况

### 1.2 为什么需要性能监控


**🎯 监控的价值**
```
发现问题：系统变慢了？哪里出了问题？
预防故障：资源快用完了，提前扩容
优化性能：找到瓶颈，针对性优化
容量规划：评估现有资源，规划未来需求
```

**💼 实际应用场景**
- **网站响应慢**：通过监控发现是CPU还是内存问题
- **数据库卡顿**：监控磁盘IO找到读写瓶颈
- **网络异常**：监控网络流量发现带宽不足

### 1.3 监控的四个维度


**📊 系统资源四大件**
```
┌─────────────────────────────────────────┐
│                  CPU                    │ ← 处理器使用率
├─────────────────────────────────────────┤
│                 内存                    │ ← 内存使用情况
├─────────────────────────────────────────┤
│                 磁盘                    │ ← 存储IO性能
├─────────────────────────────────────────┤
│                 网络                    │ ← 网络流量状态
└─────────────────────────────────────────┘
```

**🔍 每个维度关注什么**
- **CPU监控**：使用率、负载、进程队列
- **内存监控**：使用率、交换分区、缓存
- **磁盘监控**：读写速度、队列长度、使用率
- **网络监控**：带宽使用、连接数、错误率

---

## 2. 🛠️ 系统性能监控工具详解


### 2.1 Linux性能监控工具全景图


```
系统监控工具分类：

实时监控类：
├─ top/htop     ← CPU和进程实时监控
├─ iostat       ← 磁盘IO实时统计
├─ vmstat       ← 内存和虚拟内存统计
├─ netstat      ← 网络连接状态
└─ iftop        ← 网络流量实时监控

历史数据类：
├─ sar          ← 系统活动报告器
├─ atop         ← 高级top工具
└─ dstat        ← 多维度统计工具

专业分析类：
├─ perf         ← 性能分析工具
├─ strace       ← 系统调用跟踪
└─ tcpdump      ← 网络包分析
```

### 2.2 测试期间系统监控策略


**🎯 监控时机规划**
```
测试前：
✓ 建立基线：记录系统正常状态的各项指标
✓ 准备工具：确保监控工具正常运行
✓ 设置告警：配置关键指标的告警阈值

测试中：
✓ 实时监控：观察系统状态变化
✓ 数据记录：保存详细的性能数据
✓ 异常处理：及时发现和处理异常情况

测试后：
✓ 数据分析：对比测试前后的性能数据
✓ 报告生成：生成详细的性能分析报告
✓ 优化建议：基于数据提出改进建议
```

> 📌 **重点提醒**：监控就像拍电影，要从多个角度同时记录，这样才能还原真实情况

### 2.3 监控数据的价值


**📈 数据告诉我们什么**
```
趋势分析：
- 系统负载是否在增长？
- 哪个时间段压力最大？
- 资源使用有什么规律？

瓶颈识别：
- CPU经常100%？处理能力不足
- 内存不够用？需要加内存
- 磁盘IO很高？存储成为瓶颈

容量规划：
- 按照当前增长速度，多久需要扩容？
- 哪种资源最先成为瓶颈？
```

---

## 3. 📊 sar性能数据采集


### 3.1 sar工具概述


**🔸 什么是sar**
```
sar = System Activity Reporter（系统活动报告器）
作用：收集、报告和保存系统活动信息
特点：可以实时监控，也可以查看历史数据
优势：数据全面、格式规范、便于分析
```

> 💡 **形象比喻**：sar就像系统的"行车记录仪"，记录系统运行的全过程

### 3.2 sar基本使用方法


**⚡ 常用sar命令**
```bash
# 每2秒采集一次，共采集10次
sar 2 10

# 查看CPU使用情况
sar -u 1 5

# 查看内存使用情况  
sar -r 1 5

# 查看磁盘IO情况
sar -d 1 5

# 查看网络统计
sar -n DEV 1 5
```

### 3.3 sar数据采集详解


**📋 CPU使用率监控**
```bash
sar -u 2 5
```

**输出解读**：
```
时间        CPU     %user   %nice   %system  %iowait  %steal   %idle
14:30:01    all      2.5     0.0      1.2      0.3      0.0     96.0
```

**🔍 各指标含义**：
- **%user**：用户进程占用CPU的时间
- **%system**：系统内核占用CPU的时间  
- **%iowait**：等待IO操作完成的时间
- **%idle**：CPU空闲时间

> ⚠️ **注意事项**：%iowait高说明磁盘可能是瓶颈

**📋 内存使用监控**
```bash
sar -r 2 5
```

**关键指标**：
- **kbmemfree**：可用内存
- **kbmemused**：已用内存
- **%memused**：内存使用率
- **kbbuffers**：缓冲区大小

### 3.4 sar历史数据查看


**📅 查看历史性能数据**
```bash
# 查看昨天的数据
sar -f /var/log/sa/sa$(date -d yesterday +%d)

# 查看指定时间段的CPU数据
sar -u -s 09:00:00 -e 18:00:00

# 查看本月15号的数据
sar -f /var/log/sa/sa15
```

> 💡 **实用技巧**：Linux系统默认每10分钟自动收集一次sar数据

---

## 4. 💾 iostat I/O统计监控


### 4.1 iostat工具介绍


**🔸 iostat的作用**
```
iostat = Input/Output Statistics（输入输出统计）
功能：监控系统磁盘IO性能
重点：磁盘读写速度、IO等待时间、设备利用率
价值：发现存储瓶颈，优化磁盘性能
```

### 4.2 iostat基本用法


**⚡ 常用iostat命令**
```bash
# 每秒显示一次，显示5次
iostat 1 5

# 显示扩展统计信息
iostat -x 1 5

# 只显示设备统计，不显示CPU
iostat -d 1 5

# 以MB为单位显示
iostat -m 1 5
```

### 4.3 iostat输出详解


**📊 标准输出格式**
```
Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s
sda               0.0      0.5    1.2    2.3     0.1      0.2
```

**🔍 关键指标解析**：

| 指标 | 含义 | 理想值 | 说明 |
|------|------|--------|------|
| **r/s** | `每秒读请求数` | `<100` | 磁盘每秒处理的读操作 |
| **w/s** | `每秒写请求数` | `<100` | 磁盘每秒处理的写操作 |
| **rMB/s** | `每秒读MB数` | `视需求而定` | 读取数据的速度 |
| **wMB/s** | `每秒写MB数` | `视需求而定` | 写入数据的速度 |
| **%util** | `设备利用率` | `<80%` | 磁盘忙碌程度 |

**📊 扩展统计信息**
```bash
iostat -x 1 5
```

**重要扩展指标**：
- **await**：平均IO等待时间（毫秒）
- **svctm**：平均服务时间（毫秒）
- **%util**：设备利用率

> ⚠️ **性能判断标准**：
> - await > 20ms：IO响应较慢
> - %util > 80%：磁盘接近饱和
> - svctm过高：磁盘性能不足

### 4.4 IO性能分析实例


**🔍 场景分析：数据库服务器IO监控**
```
观察结果：
Device:   r/s    w/s   rMB/s   wMB/s   await   %util
sda      156.2   23.4    12.3     2.1    45.2    95.6

分析：
✗ await=45.2ms（正常<10ms）IO等待时间过长
✗ %util=95.6%（正常<80%）磁盘几乎满负荷
✓ 读多写少，符合数据库特征

结论：磁盘成为性能瓶颈，需要优化
```

---

## 5. 🧠 vmstat内存统计监控


### 5.1 vmstat工具概述


**🔸 vmstat的含义**
```
vmstat = Virtual Memory Statistics（虚拟内存统计）
功能：监控系统内存、交换分区、进程、CPU使用情况
特点：信息密集，一屏显示系统核心指标
适用：快速了解系统整体状况
```

### 5.2 vmstat基本使用


**⚡ 常用vmstat命令**
```bash
# 每2秒显示一次，显示10次
vmstat 2 10

# 显示内存统计信息
vmstat -s

# 显示磁盘统计信息
vmstat -d

# 以MB为单位显示内存
vmstat -S M 2 5
```

### 5.3 vmstat输出详解


**📊 vmstat标准输出**
```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 123456   8912  45678    0    0    12    34  156  298  5  2 92  1  0
```

**🔍 各部分详细解释**：

**进程信息（procs）**：
- **r**：运行队列中的进程数（正在运行+等待运行）
- **b**：不可中断睡眠的进程数（通常是等待IO）

**内存信息（memory）**：
- **swpd**：虚拟内存使用量（KB）
- **free**：空闲内存（KB）
- **buff**：缓冲区内存（KB）
- **cache**：缓存内存（KB）

**交换分区（swap）**：
- **si**：每秒从磁盘交换到内存的数据（KB/s）
- **so**：每秒从内存交换到磁盘的数据（KB/s）

**IO信息**：
- **bi**：每秒从块设备读取的数据（blocks/s）
- **bo**：每秒写入块设备的数据（blocks/s）

**CPU信息**：
- **us**：用户时间占比
- **sy**：系统时间占比
- **id**：空闲时间占比
- **wa**：IO等待时间占比

### 5.4 vmstat性能判断标准


**⚡ 关键指标告警阈值**

| 指标 | 正常范围 | 注意阈值 | 危险阈值 | 说明 |
|------|----------|----------|----------|------|
| **r** | `0-2` | `>5` | `>10` | 运行队列过长说明CPU不足 |
| **b** | `0` | `>2` | `>5` | 大量进程等待IO |
| **si/so** | `0` | `>100` | `>1000` | 频繁交换说明内存不足 |
| **wa** | `<5%` | `>10%` | `>20%` | IO等待时间过长 |

> 💡 **经验法则**：
> - r值持续大于CPU核数：CPU压力大
> - si/so不为0：内存不够用，在使用交换分区
> - wa高：磁盘IO成为瓶颈

**🔍 实际案例分析**
```
vmstat输出：
procs           memory                   cpu
 r  b   free    cache    si  so  wa
15  3  12345   234567    50 120  25

分析：
✗ r=15（CPU核数8）运行队列过长，CPU不足
✗ b=3 有进程在等待IO
✗ si=50, so=120 内存不足，在使用交换分区
✗ wa=25% IO等待时间过长

结论：系统压力很大，CPU、内存、IO都是瓶颈
```

---

## 6. 🌐 网络流量监控


### 6.1 网络监控的重要性


**🔸 为什么要监控网络**
```
网络瓶颈识别：带宽是否足够？
连接状态监控：有多少活跃连接？
流量分析：哪些应用占用带宽最多？
异常检测：是否有异常流量或攻击？
```

### 6.2 基本网络监控工具


**⚡ 常用网络监控命令**

**查看网络接口统计**：
```bash
# 查看网络接口信息
ifconfig

# 查看网络统计
cat /proc/net/dev

# 使用sar监控网络
sar -n DEV 1 5
```

**查看网络连接状态**：
```bash
# 查看所有网络连接
netstat -an

# 查看TCP连接统计
netstat -s

# 查看监听端口
netstat -tlnp
```

### 6.3 sar网络监控详解


**📊 网络接口监控**
```bash
sar -n DEV 1 5
```

**输出示例**：
```
网络接口    rxpck/s   txpck/s    rxkB/s    txkB/s
eth0         1234.5    987.2      156.7     89.3
lo             12.1     12.1        1.2      1.2
```

**🔍 指标含义**：
- **rxpck/s**：每秒接收的数据包数
- **txpck/s**：每秒发送的数据包数  
- **rxkB/s**：每秒接收的千字节数
- **txkB/s**：每秒发送的千字节数

**网络错误监控**：
```bash
sar -n EDEV 1 5
```

**关注指标**：
- **rxerr/s**：每秒接收错误包数
- **txerr/s**：每秒发送错误包数
- **rxdrop/s**：每秒接收丢弃包数

### 6.4 实时网络流量监控


**🔍 使用iftop监控实时流量**
```bash
# 安装iftop
yum install iftop -y

# 监控指定网卡
iftop -i eth0

# 按端口显示
iftop -P
```

**iftop界面解读**：
```
                    12.5Kb  25.0Kb  37.5Kb  50.0Kb  62.5Kb
┌───────────────────────────────────────────────────────
│server1                    => client1.com    1.2MB  2.3MB  1.8MB
│                           <=                 560KB  890KB  720KB
│server1                    => database.com   234KB  456KB  345KB
│                           <=                 123KB  234KB  178KB
└───────────────────────────────────────────────────────
Peak rates (sent/received/total):  2.3MB  890KB  3.2MB
Cumulative (sent/received/total):  45.6MB 23.4MB 69.0MB
```

> 💡 **iftop优势**：实时显示每个连接的流量，便于识别高流量连接

### 6.5 网络性能判断标准


**📈 网络性能指标**

| 指标类型 | 正常范围 | 需要关注 | 说明 |
|----------|----------|----------|------|
| **带宽利用率** | `<70%` | `>80%` | 超过80%需要考虑扩容 |
| **数据包丢失率** | `<0.1%` | `>1%` | 丢包率高影响性能 |
| **网络延迟** | `<50ms` | `>100ms` | 延迟过高影响用户体验 |
| **连接数** | `视应用而定` | `接近系统限制` | 需要调整系统参数 |

---

## 7. 📱 应用性能指标采集


### 7.1 应用监控的维度


**🎯 应用性能监控重点**
```
业务指标：
├─ 响应时间：用户请求处理时长
├─ 吞吐量：单位时间处理的请求数
├─ 错误率：失败请求占总请求的比例
└─ 并发数：同时处理的请求数量

技术指标：
├─ CPU使用率：应用进程CPU占用
├─ 内存使用：应用占用的内存量
├─ 数据库连接：数据库连接池状态
└─ 缓存命中率：缓存使用效率
```

### 7.2 应用进程监控


**⚡ 监控特定应用进程**
```bash
# 查看Java应用的资源使用
ps -eo pid,ppid,cmd,%mem,%cpu | grep java

# 持续监控进程资源使用
top -p $(pgrep java)

# 查看进程详细信息
cat /proc/PID/status
```

**🔍 进程监控关键指标**：
- **%CPU**：进程CPU使用率
- **%MEM**：进程内存使用率
- **VSZ**：虚拟内存大小
- **RSS**：物理内存使用量

### 7.3 数据库性能监控


**📊 MySQL性能监控**
```bash
# 查看MySQL进程状态
mysqladmin processlist

# 查看MySQL状态变量
mysqladmin extended-status

# 监控MySQL连接数
mysqladmin status
```

**关键MySQL指标**：
- **Threads_connected**：当前连接数
- **Queries**：查询总数
- **Slow_queries**：慢查询数量
- **Innodb_buffer_pool_read_requests**：缓冲池读请求

### 7.4 Web服务器监控


**🌐 Apache/Nginx监控**

**Apache状态监控**：
```bash
# 启用Apache状态模块
# 在httpd.conf中添加：
# LoadModule status_module modules/mod_status.so
# <Location "/server-status">
#     SetHandler server-status
# </Location>

# 查看Apache状态
curl http://localhost/server-status?auto
```

**Nginx状态监控**：
```bash
# 在nginx.conf中配置状态页面
# location /nginx_status {
#     stub_status on;
#     access_log off;
# }

# 查看Nginx状态
curl http://localhost/nginx_status
```

**输出示例**：
```
Active connections: 123
server accepts handled requests
 456789 456789 1234567
Reading: 12 Writing: 34 Waiting: 77
```

---

## 8. 📺 实时性能数据展示


### 8.1 命令行实时监控


**⚡ 多窗口监控方案**

**使用screen创建监控会话**：
```bash
# 创建监控会话
screen -S monitor

# 创建多个窗口
# Ctrl+A, C 创建新窗口
# Ctrl+A, 数字 切换窗口

# 窗口1：系统总览
top

# 窗口2：IO监控  
iostat -x 1

# 窗口3：内存监控
vmstat 1

# 窗口4：网络监控
iftop -i eth0
```

**使用tmux分屏监控**：
```bash
# 创建tmux会话
tmux new-session -s monitor

# 水平分屏：Ctrl+B, "
# 垂直分屏：Ctrl+B, %
# 切换面板：Ctrl+B, 方向键

# 在不同面板运行不同监控命令
```

### 8.2 组合监控脚本


**📜 自定义监控脚本**
```bash
#!/bin/bash
# 系统性能监控脚本

while true; do
    clear
    echo "=== 系统性能监控 $(date) ==="
    echo
    
    # CPU和负载
    echo "CPU使用率和系统负载："
    top -bn1 | head -3
    echo
    
    # 内存使用
    echo "内存使用情况："
    free -h
    echo
    
    # 磁盘使用
    echo "磁盘使用率："
    df -h | head -5
    echo
    
    # 网络连接
    echo "网络连接统计："
    netstat -an | awk '/^tcp/ {print $6}' | sort | uniq -c
    
    sleep 5
done
```

### 8.3 性能数据可视化


**📊 简单图表生成**

**使用gnuplot生成图表**：
```bash
# 收集CPU数据
sar -u 1 60 | grep -v "^$" | grep -v "Average" > cpu_data.txt

# 生成CPU使用率图表
gnuplot << EOF
set terminal png
set output 'cpu_usage.png'
set title 'CPU Usage Over Time'
plot 'cpu_data.txt' using 4 with lines title '%user'
EOF
```

> 💡 **现代方案**：企业环境建议使用专业监控工具如Prometheus + Grafana

---

## 9. 💾 性能数据存储管理


### 9.1 数据存储策略


**📋 存储规划原则**
```
数据分类存储：
├─ 实时数据：最近24小时，秒级精度
├─ 近期数据：最近30天，分钟级精度  
├─ 历史数据：超过30天，小时级精度
└─ 归档数据：超过1年，天级精度

存储位置：
├─ 本地存储：/var/log/performance/
├─ 共享存储：NFS或分布式文件系统
└─ 数据库：MySQL、InfluxDB等时序数据库
```

### 9.2 sar数据管理


**🔧 sar数据存储配置**

**自动收集配置**：
```bash
# 编辑crontab，配置数据收集频率
crontab -e

# 每分钟收集一次数据（高频率监控）
* * * * * /usr/lib64/sa/sa1 1 1

# 每10分钟生成报告（默认配置）  
*/10 * * * * /usr/lib64/sa/sa1

# 每天23:53生成日报告
53 23 * * * /usr/lib64/sa/sa2 -A
```

**数据文件管理**：
```bash
# sar数据存储路径
ls /var/log/sa/

# 文件命名规则
sa01  sa02  sa03  ...  sa31    # 每日原始数据
sar01 sar02 sar03 ... sar31    # 每日报告文件

# 数据保留策略
find /var/log/sa/ -name "sa*" -mtime +30 -delete
```

### 9.3 自定义数据收集


**📊 创建性能数据收集脚本**
```bash
#!/bin/bash
# 性能数据收集脚本

LOG_DIR="/var/log/performance"
DATE=$(date +%Y%m%d)
TIME=$(date +%H:%M:%S)

# 创建日志目录
mkdir -p $LOG_DIR

# 收集系统基本信息
{
    echo "[$TIME] CPU使用率:"
    top -bn1 | grep "Cpu(s)" 
    
    echo "[$TIME] 内存使用:"
    free -m | grep Mem
    
    echo "[$TIME] 磁盘IO:"
    iostat -x 1 1 | tail -n +4
    
    echo "[$TIME] 网络流量:"
    sar -n DEV 1 1 | tail -n +4
    
    echo "---"
} >> $LOG_DIR/perf_$DATE.log
```

**定时执行收集**：
```bash
# 每分钟执行一次数据收集
echo "* * * * * /usr/local/bin/collect_perf.sh" | crontab -
```

### 9.4 数据分析与报告


**📈 性能报告生成**
```bash
#!/bin/bash
# 性能分析报告生成

REPORT_DATE=$(date -d yesterday +%Y%m%d)
REPORT_FILE="/var/log/performance/report_$REPORT_DATE.txt"

{
    echo "性能分析报告 - $REPORT_DATE"
    echo "================================"
    
    # CPU使用率统计
    echo "CPU使用率统计："
    sar -u -f /var/log/sa/sa$(date -d yesterday +%d) | \
    awk '/Average/ {print "平均CPU使用率:", $3"%"}'
    
    # 内存使用统计
    echo "内存使用统计："
    sar -r -f /var/log/sa/sa$(date -d yesterday +%d) | \
    awk '/Average/ {print "平均内存使用率:", $4"%"}'
    
    # IO统计
    echo "磁盘IO统计："
    sar -d -f /var/log/sa/sa$(date -d yesterday +%d) | \
    awk '/Average/ && $2=="sda" {print "平均IO利用率:", $10"%"}'
    
} > $REPORT_FILE

# 发送报告邮件
mail -s "系统性能日报 $REPORT_DATE" admin@company.com < $REPORT_FILE
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的监控工具


```
🔸 sar：系统活动报告器，全面的历史数据
🔸 iostat：专业的磁盘IO监控工具
🔸 vmstat：内存和系统状态的综合监控
🔸 top/htop：实时进程和资源监控
🔸 netstat/iftop：网络连接和流量监控
```

### 10.2 关键性能指标速查


**⚡ 快速判断系统健康度**

| 类型 | 关键指标 | 正常值 | 告警值 | 检查命令 |
|------|----------|--------|--------|----------|
| **CPU** | `CPU使用率` | `<80%` | `>90%` | `top` |
| **内存** | `内存使用率` | `<80%` | `>90%` | `free -h` |
| **磁盘** | `IO等待时间` | `<10ms` | `>20ms` | `iostat -x` |
| **网络** | `带宽利用率` | `<70%` | `>80%` | `iftop` |

### 10.3 监控最佳实践


**🎯 监控策略建议**
```
监控频率：
✓ 实时监控：1秒间隔，用于问题诊断
✓ 常规监控：5-10秒间隔，日常观察
✓ 历史数据：10分钟间隔，趋势分析

数据保留：
✓ 详细数据：保留7天
✓ 汇总数据：保留30天  
✓ 归档数据：保留1年

告警设置：
✓ 预警线：资源使用率70%
✓ 告警线：资源使用率85%
✓ 严重告警：资源使用率95%
```

> 💡 **核心理念**：监控不是目的，发现问题和优化性能才是目标

### 10.4 故障排查思路


**🔍 性能问题诊断流程**
```
第一步：确认问题现象
├─ 用户反映什么问题？
├─ 什么时候开始的？
└─ 影响范围有多大？

第二步：收集监控数据
├─ CPU使用率如何？
├─ 内存是否充足？
├─ 磁盘IO是否正常？
└─ 网络流量是否异常？

第三步：分析根本原因
├─ 哪个资源是瓶颈？
├─ 是什么进程导致的？
└─ 问题的根本原因是什么？

第四步：制定解决方案
├─ 立即缓解措施
├─ 根本解决方案
└─ 预防措施
```

### 10.5 实用技巧总结


**🚀 提高监控效率的技巧**

> 📌 **快速上手技巧**：
> - 记住核心命令：`top`、`iostat -x`、`vmstat`、`sar -u`
> - 设置常用别名：`alias perf='iostat -x 1'`
> - 使用组合命令：`watch -n 1 'free -h && df -h'`

> ⚠️ **常见误区避免**：
> - 不要只看CPU，要综合分析所有资源
> - 不要忽略网络监控，网络往往是隐藏瓶颈
> - 不要只看当前值，要关注趋势变化

**核心记忆口诀**：
```
性能监控四大类，CPU内存网络盘
sar统计iostat盘，vmstat内存要记全
实时监控用top看，历史数据sar来管
数据采集要持续，分析报告助决断
```