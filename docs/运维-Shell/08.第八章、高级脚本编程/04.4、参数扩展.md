---
title: 4、参数扩展
---
## 📚 目录

1. [参数扩展基础概念](#1-参数扩展基础概念)
2. [基本扩展语法](#2-基本扩展语法)
3. [默认值处理机制](#3-默认值处理机制)
4. [条件替换与错误处理](#4-条件替换与错误处理)
5. [模式匹配删除](#5-模式匹配删除)
6. [模式匹配替换](#6-模式匹配替换)
7. [数组参数扩展](#7-数组参数扩展)
8. [高级扩展技巧](#8-高级扩展技巧)
9. [实际应用场景](#9-实际应用场景)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 参数扩展基础概念


### 1.1 什么是参数扩展


💭 **简单理解**：参数扩展就是Shell提供的一套"变量处理工具箱"，让你可以灵活地获取、修改、处理变量的值。

🏷️ **专业术语**：`参数扩展（Parameter Expansion）` = Shell内置的变量值处理和转换机制

```
生活类比：
参数扩展就像一个多功能工具箱：
📦 工具箱（Shell）
├── 🔧 基本取值工具（${var}）
├── 🛠️ 默认值工具（${var:-default}）
├── ✂️ 字符串剪切工具（${var#pattern}）
├── 🔄 字符串替换工具（${var/old/new}）
└── 📏 长度测量工具（${#var}）
```

### 1.2 为什么需要参数扩展


**🤔 解决的问题**：
- **变量为空怎么办**？→ 设置默认值
- **字符串太长想截取**？→ 模式匹配删除
- **需要批量替换内容**？→ 模式匹配替换
- **不确定变量是否存在**？→ 错误处理机制

**⚡ 传统方法 vs 参数扩展**：
```bash
# 传统方法：需要多行代码
if [ -z "$name" ]; then
    name="default"
fi

# 参数扩展：一行搞定
name=${name:-"default"}
```

### 1.3 参数扩展的基本形式


**📋 语法结构**：
```
基本格式：${参数名操作符值}
         ↑    ↑     ↑
        变量  操作  参数
```

**🏗️ 扩展类型架构**：
```
参数扩展
├── 基础扩展
│   └── ${var} - 获取变量值
├── 默认值扩展
│   ├── ${var:-default} - 临时默认值
│   ├── ${var:=default} - 永久设置默认值
│   └── ${var:+alternate} - 存在时替换值
├── 错误处理扩展
│   └── ${var:?error} - 未设置时报错
├── 字符串操作扩展
│   ├── ${var#pattern} - 前缀删除
│   ├── ${var%pattern} - 后缀删除
│   └── ${var/pattern/replacement} - 内容替换
└── 特殊扩展
    ├── ${#var} - 获取长度
    └── ${!var} - 间接引用
```

---

## 2. 🔧 基本扩展语法


### 2.1 标准变量引用


**🏷️ 基本语法**：`${变量名}` = 获取变量的值

💡 **为什么要用花括号**？
```bash
# 不用花括号的问题
name="John"
echo "Hello $nameWorld"    # 错误！Shell找不到变量nameWorld
echo "Hello ${name}World"  # 正确！输出：Hello JohnWorld
```

**🔍 使用场景**：
```bash
#!/bin/bash

# 基本使用
user="admin"
echo "当前用户：${user}"

# 避免歧义
prefix="data"
echo "文件名：${prefix}_backup.txt"

# 数字变量
count=5
echo "总计：${count}个文件"
```

### 2.2 参数长度获取


**🏷️ 长度语法**：`${#变量名}` = 获取变量值的字符长度

```bash
#!/bin/bash

text="Hello World"
echo "字符串长度：${#text}"        # 输出：11

# 实际应用：验证输入长度
password="123456"
if [ ${#password} -lt 8 ]; then
    echo "密码太短，至少需要8位"
fi
```

**📊 长度获取对比表**：

| 内容类型 | 变量值 | `${#var}` 结果 | 说明 |
|----------|--------|---------------|------|
| 英文字符串 | `"hello"` | `5` | 每个字符占1位 |
| 中文字符串 | `"你好"` | `6` | 每个中文字符占3字节 |
| 空字符串 | `""` | `0` | 空值长度为0 |
| 数字 | `12345` | `5` | 数字按字符计算 |

---

## 3. 🛡️ 默认值处理机制


### 3.1 临时默认值（:-）


**🏷️ 语法含义**：`${变量:-默认值}` = 如果变量为空或未设置，临时使用默认值

💭 **理解要点**：这种方式不会改变原变量的值，只是在这次使用时提供默认值。

```bash
#!/bin/bash

# 变量未设置的情况
echo "用户名：${username:-"匿名用户"}"    # 输出：匿名用户
echo "username变量值：'$username'"      # 输出：''（仍然为空）

# 变量为空的情况
config_file=""
actual_config=${config_file:-"/etc/default.conf"}
echo "使用配置文件：$actual_config"      # 输出：/etc/default.conf
```

**🌰 实际应用场景**：
```bash
#!/bin/bash
# 脚本配置管理

LOG_LEVEL=${LOG_LEVEL:-"INFO"}      # 默认日志级别
MAX_RETRIES=${MAX_RETRIES:-3}       # 默认重试次数
TIMEOUT=${TIMEOUT:-30}              # 默认超时时间

echo "日志级别：$LOG_LEVEL"
echo "最大重试：$MAX_RETRIES次"
echo "超时设置：${TIMEOUT}秒"
```

### 3.2 永久设置默认值（:=）


**🏷️ 语法含义**：`${变量:=默认值}` = 如果变量为空或未设置，设置默认值并记住这个值

💭 **与:-的区别**：这种方式会永久改变变量的值。

```bash
#!/bin/bash

# 第一次使用时设置默认值
echo "数据库路径：${DB_PATH:="/var/lib/database"}"
echo "DB_PATH现在的值：$DB_PATH"        # 已经被设置为默认值

# 第二次使用时直接使用已设置的值
echo "再次获取：${DB_PATH:="/tmp/db"}"   # 不会使用/tmp/db，因为已有值
```

**📊 两种默认值方式对比**：

| 特性 | `${var:-default}` | `${var:=default}` |
|------|------------------|------------------|
| **作用** | 临时提供默认值 | 永久设置默认值 |
| **改变变量** | ❌ 不改变 | ✅ 永久改变 |
| **使用场景** | 一次性取值 | 需要记住默认值 |
| **性能** | 每次都判断 | 只在第一次设置 |

### 3.3 条件替换值（:+）


**🏷️ 语法含义**：`${变量:+替换值}` = 如果变量不为空，使用替换值；为空时返回空

💭 **理解要点**：这个操作符的行为和默认值相反，变量有值时才生效。

```bash
#!/bin/bash

# 变量有值的情况
DEBUG="true"
debug_flag=${DEBUG:+"-v"}           # DEBUG有值，使用-v
echo "调试参数：$debug_flag"         # 输出：-v

# 变量为空的情况  
VERBOSE=""
verbose_flag=${VERBOSE:+"-verbose"} # VERBOSE为空，返回空
echo "详细参数：$verbose_flag"       # 输出：（空）
```

**🛠️ 实际应用**：
```bash
#!/bin/bash
# 构建命令行参数

PROXY_HOST="proxy.company.com"
SSL_VERIFY=""

# 根据配置动态构建参数
proxy_param=${PROXY_HOST:+"--proxy $PROXY_HOST"}
ssl_param=${SSL_VERIFY:+"--verify-ssl"}

curl $proxy_param $ssl_param https://api.example.com
# 实际执行：curl --proxy proxy.company.com https://api.example.com
```

---

## 4. ⚠️ 条件替换与错误处理


### 4.1 错误处理机制（:?）


**🏷️ 语法含义**：`${变量:?错误信息}` = 如果变量未设置或为空，显示错误信息并退出脚本

🚨 **重要提醒**：这个操作符会导致脚本立即退出，用于强制要求某些变量必须有值。

```bash
#!/bin/bash

# 要求必须设置的配置
API_KEY=${API_KEY:?"错误：必须设置API_KEY环境变量"}
DATABASE_URL=${DATABASE_URL:?"错误：数据库连接字符串不能为空"}

echo "配置检查通过，开始执行任务..."
```

**🔧 实际错误处理示例**：
```bash
#!/bin/bash
# 服务启动脚本

set -e  # 遇到错误立即退出

SERVICE_NAME=${SERVICE_NAME:?"服务名称不能为空"}
CONFIG_FILE=${CONFIG_FILE:?"配置文件路径不能为空"}
LOG_DIR=${LOG_DIR:?"日志目录不能为空"}

echo "启动服务：$SERVICE_NAME"
echo "配置文件：$CONFIG_FILE" 
echo "日志目录：$LOG_DIR"
```

**💥 容易出错的地方**：
```bash
# 错误用法：在管道中使用
echo "test" | grep "pattern" && echo ${VAR:?"VAR未设置"}
# 问题：管道中的错误处理可能不会按预期工作

# 正确用法：在脚本开头检查
VAR=${VAR:?"VAR必须设置"}
echo "test" | grep "pattern"
```

### 4.2 综合默认值处理策略


**🎯 最佳实践组合**：
```bash
#!/bin/bash

# 1. 强制要求的变量（必须有值）
API_SECRET=${API_SECRET:?"API密钥是必需的"}

# 2. 有合理默认值的变量
LOG_LEVEL=${LOG_LEVEL:-"INFO"}
MAX_CONNECTIONS=${MAX_CONNECTIONS:-100}

# 3. 可选功能的变量（有值时启用）
debug_mode=${DEBUG:+"--debug"}
verbose_mode=${VERBOSE:+"--verbose"}

echo "配置完成：日志级别=$LOG_LEVEL，最大连接=$MAX_CONNECTIONS"
```

---

## 5. ✂️ 模式匹配删除


### 5.1 前缀删除操作


**🏷️ 基本语法**：
- `${变量#模式}` = 删除**最短**匹配的**前缀**
- `${变量##模式}` = 删除**最长**匹配的**前缀**

💭 **记忆技巧**：`#`符号在键盘上靠左，表示删除左边（前缀）的内容。

```bash
#!/bin/bash

filename="/usr/local/bin/myapp.tar.gz"

# 删除最短前缀（一层路径）
echo ${filename#*/}      # 输出：usr/local/bin/myapp.tar.gz

# 删除最长前缀（所有路径）  
echo ${filename##*/}     # 输出：myapp.tar.gz

# 实际应用：获取文件名
path="/home/user/documents/report.pdf"
just_filename=${path##*/}
echo "文件名：$just_filename"    # 输出：report.pdf
```

**🔍 匹配模式详解**：
```bash
#!/bin/bash

url="https://www.example.com/path/to/file.html"

# 删除协议前缀
echo ${url#http://}      # 如果是http://开头就删除
echo ${url#https://}     # 输出：www.example.com/path/to/file.html

# 使用通配符
echo ${url#*://}         # 删除任意协议，输出：www.example.com/path/to/file.html
```

### 5.2 后缀删除操作


**🏷️ 基本语法**：
- `${变量%模式}` = 删除**最短**匹配的**后缀**
- `${变量%%模式}` = 删除**最长**匹配的**后缀**

💭 **记忆技巧**：`%`符号在键盘上靠右，表示删除右边（后缀）的内容。

```bash
#!/bin/bash

filename="document.backup.tar.gz"

# 删除最短后缀（最后一个扩展名）
echo ${filename%.*}      # 输出：document.backup.tar

# 删除最长后缀（所有扩展名）
echo ${filename%%.*}     # 输出：document

# 实际应用：获取文件basename
path="/home/user/report.pdf"
basename=${path##*/}        # 先获取文件名：report.pdf
name_only=${basename%.*}    # 再删除扩展名：report
echo "纯文件名：$name_only"
```

### 5.3 前后缀删除对照表


**📊 操作符对比**：

| 操作符 | 作用 | 匹配方式 | 示例 | 结果 |
|--------|------|----------|------|------|
| `#` | 删除前缀 | 最短匹配 | `${path#*/}` | 删除第一个`/`之前的内容 |
| `##` | 删除前缀 | 最长匹配 | `${path##*/}` | 删除最后一个`/`之前的内容 |
| `%` | 删除后缀 | 最短匹配 | `${file%.*}` | 删除最后一个`.`之后的内容 |
| `%%` | 删除后缀 | 最长匹配 | `${file%%.*}` | 删除第一个`.`之后的内容 |

**🌰 综合实例**：
```bash
#!/bin/bash

full_path="/var/log/system/app.log.2024"

echo "原始路径：$full_path"
echo "删除目录路径：${full_path##*/}"      # app.log.2024
echo "删除文件名：${full_path%/*}"        # /var/log/system  
echo "删除扩展名：${full_path%.*}"        # /var/log/system/app.log
echo "只保留文件名：${full_path%%.*}"      # /var/log/system/app
```

---

## 6. 🔄 模式匹配替换


### 6.1 基本替换操作


**🏷️ 基本语法**：
- `${变量/模式/替换}` = 替换**第一个**匹配项
- `${变量//模式/替换}` = 替换**所有**匹配项

💭 **理解要点**：这个功能就像文本编辑器的"查找替换"功能。

```bash
#!/bin/bash

text="apple,banana,apple,orange"

# 替换第一个匹配
echo ${text/apple/fruit}     # 输出：fruit,banana,apple,orange

# 替换所有匹配
echo ${text//apple/fruit}    # 输出：fruit,banana,fruit,orange

# 实际应用：处理路径分隔符
windows_path="C:\\Users\\Admin\\Documents"
unix_path=${windows_path//\\//}
echo "Unix路径：$unix_path"   # 输出：C:/Users/Admin/Documents
```

### 6.2 位置特定替换


**🏷️ 位置语法**：
- `${变量/#模式/替换}` = 替换**开头**的匹配项
- `${变量/%模式/替换}` = 替换**结尾**的匹配项

```bash
#!/bin/bash

filename="test.log"

# 替换开头匹配
echo ${filename/#test/debug}     # 输出：debug.log

# 替换结尾匹配  
echo ${filename/%.log/.txt}      # 输出：test.txt

# 实际应用：标准化文件扩展名
process_file() {
    local file=$1
    # 确保文件以.txt结尾
    normalized=${file/%.*/}.txt
    echo "处理文件：$normalized"
}

process_file "document.doc"      # 输出：document.txt
process_file "script.sh"        # 输出：script.txt
```

### 6.3 删除匹配内容


**🏷️ 删除语法**：省略替换部分，相当于删除匹配的内容

```bash
#!/bin/bash

# 删除特定字符
text="Hello, World!"
clean_text=${text//,/}          # 删除所有逗号
echo "$clean_text"              # 输出：Hello World!

# 删除空格
spaced_text="a b c d e"
no_spaces=${spaced_text// /}    # 删除所有空格
echo "$no_spaces"               # 输出：abcde

# 实际应用：清理用户输入
clean_input() {
    local input=$1
    # 删除首尾空格和特殊字符
    cleaned=${input// /}        # 删除空格
    cleaned=${cleaned//[^a-zA-Z0-9]/}  # 只保留字母数字
    echo "$cleaned"
}
```

**📊 替换操作总结表**：

| 语法格式 | 替换范围 | 位置要求 | 应用场景 |
|----------|----------|----------|----------|
| `/pattern/replacement` | 第一个匹配 | 任意位置 | 单次修正 |
| `//pattern/replacement` | 所有匹配 | 任意位置 | 批量替换 |
| `/#pattern/replacement` | 第一个匹配 | 仅开头 | 前缀替换 |
| `/%pattern/replacement` | 第一个匹配 | 仅结尾 | 后缀替换 |
| `/pattern/` | 所有匹配 | 任意位置 | 删除内容 |

---

## 7. 📊 数组参数扩展


### 7.1 数组基础扩展


**🏷️ 数组扩展语法**：
- `${数组[@]}` = 获取数组所有元素
- `${数组[*]}` = 获取数组所有元素（单字符串）
- `${#数组[@]}` = 获取数组长度

💭 **[@]和[*]的区别**：`[@]`保持元素独立，`[*]`将所有元素合并为一个字符串。

```bash
#!/bin/bash

fruits=("apple" "banana" "orange cherry")

echo "数组长度：${#fruits[@]}"           # 输出：3
echo "所有元素（独立）：${fruits[@]}"    # apple banana orange cherry  
echo "所有元素（合并）：${fruits[*]}"    # apple banana orange cherry

# 关键区别：在循环中的表现
for item in "${fruits[@]}"; do
    echo "项目：[$item]"
done
# 输出：
# 项目：[apple]
# 项目：[banana] 
# 项目：[orange cherry]

for item in "${fruits[*]}"; do
    echo "项目：[$item]"
done
# 输出：
# 项目：[apple banana orange cherry]
```

### 7.2 数组切片操作


**🏷️ 切片语法**：`${数组[@]:起始位置:长度}`

```bash
#!/bin/bash

numbers=(1 2 3 4 5 6 7 8 9 10)

echo "原数组：${numbers[@]}"
echo "从索引2开始取3个：${numbers[@]:2:3}"      # 3 4 5
echo "从索引5开始到末尾：${numbers[@]:5}"       # 6 7 8 9 10
echo "最后3个元素：${numbers[@]: -3}"           # 8 9 10

# 实际应用：处理命令行参数
process_args() {
    local args=("$@")
    local command=${args[0]}
    local options=("${args[@]:1}")    # 除第一个外的所有参数
    
    echo "命令：$command"
    echo "选项：${options[@]}"
}

process_args "git" "commit" "-m" "Initial commit"
# 输出：
# 命令：git
# 选项：commit -m Initial commit
```

### 7.3 数组元素扩展操作


**🔧 数组元素的模式操作**：
```bash
#!/bin/bash

files=("document.txt" "script.sh" "image.png" "backup.tar.gz")

# 获取所有文件的扩展名
echo "扩展名："
for file in "${files[@]}"; do
    echo "  ${file##*.}"    # 删除最长前缀，保留扩展名
done

# 获取所有文件的basename（无扩展名）
echo "文件名："
for file in "${files[@]}"; do
    echo "  ${file%.*}"     # 删除最短后缀，保留basename
done

# 批量重命名：添加前缀
prefixed_files=("${files[@]/#/backup_}")
echo "添加前缀后：${prefixed_files[@]}"
# 输出：backup_document.txt backup_script.sh backup_image.png backup_backup.tar.gz
```

**📊 数组扩展操作汇总**：

| 操作类型 | 语法格式 | 功能描述 | 示例结果 |
|----------|----------|----------|----------|
| 获取所有元素 | `${arr[@]}` | 保持元素独立性 | 用于循环遍历 |
| 合并为字符串 | `${arr[*]}` | 元素用空格连接 | 用于字符串操作 |
| 数组长度 | `${#arr[@]}` | 元素个数 | 数值类型 |
| 数组切片 | `${arr[@]:start:len}` | 截取部分元素 | 新数组 |
| 模式删除 | `${arr[@]#pattern}` | 对每个元素删除前缀 | 处理后的数组 |
| 模式替换 | `${arr[@]/old/new}` | 对每个元素执行替换 | 处理后的数组 |

---

## 8. 🚀 高级扩展技巧


### 8.1 间接参数引用


**🏷️ 间接引用语法**：`${!变量名}` = 使用变量的值作为另一个变量的名字

💭 **理解要点**：这就像"变量的变量"，通过一个变量存储另一个变量的名字。

```bash
#!/bin/bash

# 基本间接引用
var_name="username"
username="admin"

echo "直接引用：$var_name"        # 输出：username
echo "间接引用：${!var_name}"     # 输出：admin

# 实际应用：动态配置读取
read_config() {
    local env=$1
    local setting=$2
    local var_name="${env}_${setting}"
    
    echo "配置值：${!var_name}"
}

# 定义不同环境的配置
DEV_HOST="dev.example.com"
DEV_PORT="3000"
PROD_HOST="api.example.com" 
PROD_PORT="443"

read_config "DEV" "HOST"     # 输出：dev.example.com
read_config "PROD" "PORT"    # 输出：443
```

### 8.2 参数扩展嵌套使用


**🔧 嵌套扩展技巧**：
```bash
#!/bin/bash

# 多层默认值嵌套
PRIMARY_CONFIG="production"
FALLBACK_CONFIG="development"

config=${PRIMARY_CONFIG:-${FALLBACK_CONFIG:-"default"}}
echo "最终配置：$config"

# 复杂的模式匹配组合
filename="/var/log/app.log.2024-01-15"

# 同时获取目录、文件名、日期
directory=${filename%/*}                    # /var/log
basename=${filename##*/}                    # app.log.2024-01-15  
name_part=${basename%%.*}                   # app
date_part=${basename##*.}                   # 2024-01-15

echo "目录：$directory"
echo "文件名：$name_part"
echo "日期：$date_part"
```

### 8.3 动态变量名构建


**🛠️ 动态处理技巧**：
```bash
#!/bin/bash

# 动态创建和访问变量
create_dynamic_vars() {
    local prefix=$1
    shift
    local counter=1
    
    for value in "$@"; do
        local var_name="${prefix}_${counter}"
        declare -g "$var_name=$value"    # 创建全局变量
        echo "创建变量：$var_name = $value"
        ((counter++))
    done
}

# 动态访问变量
access_dynamic_vars() {
    local prefix=$1
    local max_count=$2
    
    for ((i=1; i<=max_count; i++)); do
        local var_name="${prefix}_${i}"
        echo "变量 $var_name 的值：${!var_name}"
    done
}

# 使用示例
create_dynamic_vars "server" "web01" "web02" "db01"
access_dynamic_vars "server" 3
```

### 8.4 错误处理与参数验证


**✅ 参数验证最佳实践**：
```bash
#!/bin/bash

validate_params() {
    # 必需参数检查
    local api_key=${API_KEY:?"环境变量API_KEY必须设置"}
    local config_file=${CONFIG_FILE:?"配置文件路径不能为空"}
    
    # 参数格式验证
    local email=${EMAIL:-""}
    if [[ -n "$email" && ! "$email" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
        echo "错误：邮箱格式不正确：$email" >&2
        return 1
    fi
    
    # 数值范围验证
    local port=${PORT:-"8080"}
    if [[ ! "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        echo "错误：端口号必须在1-65535之间：$port" >&2
        return 1
    fi
    
    echo "参数验证通过"
    return 0
}

# 使用验证函数
if validate_params; then
    echo "开始执行主程序..."
else
    echo "参数验证失败，程序退出" >&2
    exit 1
fi
```

---

## 9. 💼 实际应用场景


### 9.1 文件名批量处理


**🗂️ 文件操作脚本**：
```bash
#!/bin/bash

batch_rename() {
    local source_dir=$1
    local old_ext=${2:-"txt"}
    local new_ext=${3:-"bak"}
    
    echo "批量重命名：$source_dir 中的 .$old_ext 文件为 .$new_ext"
    
    for file in "$source_dir"/*."$old_ext"; do
        [ -f "$file" ] || continue
        
        local basename=${file%.*}           # 删除扩展名
        local new_name="${basename}.${new_ext}"
        
        echo "重命名：${file##*/} → ${new_name##*/}"
        mv "$file" "$new_name"
    done
}

# 日志文件归档
archive_logs() {
    local log_dir=${1:-"/var/log"}
    local days_old=${2:-7}
    local archive_suffix="archived"
    
    find "$log_dir" -name "*.log" -mtime +$days_old -print0 | 
    while IFS= read -r -d '' logfile; do
        local archived_name="${logfile%.*}.${archive_suffix}.${logfile##*.}"
        echo "归档日志：$logfile → $archived_name"
        mv "$logfile" "$archived_name"
    done
}
```

### 9.2 配置文件解析


**⚙️ 配置管理脚本**：
```bash
#!/bin/bash

parse_config() {
    local config_file=${1:?"配置文件路径不能为空"}
    
    [ -f "$config_file" ] || {
        echo "配置文件不存在：$config_file" >&2
        return 1
    }
    
    while IFS='=' read -r key value; do
        # 跳过注释和空行
        [[ $key =~ ^[[:space:]]*# ]] && continue
        [[ -z $key ]] && continue
        
        # 清理键值对
        key=${key// /}                      # 删除空格
        value=${value//\"/}                 # 删除引号
        value=${value#"${value%%[![:space:]]*}"}  # 删除前导空格
        value=${value%"${value##*[![:space:]]}"}  # 删除尾随空格
        
        # 动态创建变量
        declare -g "CONFIG_$key=$value"
        echo "加载配置：CONFIG_$key = $value"
        
    done < "$config_file"
}

# 使用配置值
use_config() {
    local host=${CONFIG_HOST:-"localhost"}
    local port=${CONFIG_PORT:-"8080"}
    local debug=${CONFIG_DEBUG:+"--debug"}
    
    echo "服务器配置：$host:$port $debug"
}
```

### 9.3 URL和路径处理


**🌐 URL处理工具**：
```bash
#!/bin/bash

parse_url() {
    local url=$1
    
    # 提取协议
    local protocol=${url%%://*}
    echo "协议：$protocol"
    
    # 删除协议部分
    local remaining=${url#*://}
    
    # 提取主机和路径
    local host=${remaining%%/*}
    local path=${remaining#*/}
    
    echo "主机：$host"
    echo "路径：/${path}"
    
    # 提取端口（如果有）
    if [[ $host == *:* ]]; then
        local hostname=${host%:*}
        local port=${host#*:}
        echo "主机名：$hostname"
        echo "端口：$port"
    fi
}

# 路径规范化
normalize_path() {
    local path=$1
    
    # 删除重复的斜杠
    path=${path//\/\//\/}
    
    # 删除尾随斜杠（除非是根目录）
    [[ ${#path} -gt 1 ]] && path=${path%/}
    
    # 确保以斜杠开头
    path=${path/#/\/}
    
    echo "$path"
}

# 使用示例
parse_url "https://api.example.com:8443/v1/users"
echo "规范化路径：$(normalize_path "//api//v1//users//")"
```

### 9.4 数据验证和清理


**🧹 数据处理脚本**：
```bash
#!/bin/bash

validate_and_clean() {
    local input=$1
    local type=${2:-"string"}
    
    case $type in
        "email")
            # 邮箱验证
            input=${input// /}              # 删除空格
            input=${input,,}                # 转小写
            if [[ $input =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
                echo "$input"
            else
                echo "无效邮箱格式" >&2
                return 1
            fi
            ;;
            
        "phone")
            # 电话号码清理
            input=${input//[^0-9]/}         # 只保留数字
            if [ ${#input} -eq 11 ]; then
                echo "${input:0:3}-${input:3:4}-${input:7:4}"
            else
                echo "无效电话号码" >&2
                return 1
            fi
            ;;
            
        "string")
            # 字符串清理
            input=${input#"${input%%[![:space:]]*}"}  # 删除前导空格
            input=${input%"${input##*[![:space:]]}"}  # 删除尾随空格
            echo "$input"
            ;;
    esac
}

# 批量处理数据
process_user_data() {
    local name email phone
    
    read -p "姓名: " name
    read -p "邮箱: " email  
    read -p "电话: " phone
    
    name=$(validate_and_clean "$name" "string")
    email=$(validate_and_clean "$email" "email")
    phone=$(validate_and_clean "$phone" "phone")
    
    if [[ $? -eq 0 ]]; then
        echo "处理后的数据："
        echo "姓名：$name"
        echo "邮箱：$email"
        echo "电话：$phone"
    fi
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


**🎯 参数扩展本质**：
```
参数扩展 = Shell内置的变量处理工具箱
• 比外部命令更高效
• 语法紧凑，功能强大
• 减少管道和子进程调用
• 提供丰富的字符串操作能力
```

**🔧 核心操作分类**：
- **基础扩展**：`${var}` - 获取变量值
- **默认值处理**：`${var:-default}` `${var:=default}` `${var:?error}`
- **字符串删除**：`${var#pattern}` `${var%pattern}` - 删除前缀/后缀
- **字符串替换**：`${var/old/new}` - 查找替换内容
- **数组操作**：`${arr[@]}` `${#arr[@]}` - 数组元素和长度
- **高级技巧**：`${!var}` - 间接引用

### 10.2 关键理解要点


**💭 记忆规律**：
```
位置记忆法：
# 在键盘左侧 → 删除左边（前缀）
% 在键盘右侧 → 删除右边（后缀）

符号数量规律：
单个符号（#, %） → 最短匹配（贪婪度低）
双个符号（##, %%） → 最长匹配（贪婪度高）

操作方向记忆：
: 后面的是默认值/替换值/错误信息
/ 中间的是查找和替换模式
```

**⚡ 效率优势**：
```
参数扩展 vs 外部命令对比：

${filename##*/}           # 获取文件名
basename "$filename"      # 需要启动外部进程

${text//old/new}         # 字符串替换
echo "$text" | sed 's/old/new/g'  # 需要管道和sed进程

${#string}               # 获取长度  
echo "$string" | wc -c   # 需要管道和wc进程
```

### 10.3 最佳实践指南


**✅ 使用建议**：
```bash
# 1. 参数验证：脚本开头进行参数检查
API_KEY=${API_KEY:?"API密钥是必需的"}
CONFIG_FILE=${CONFIG_FILE:-"/etc/default.conf"}

# 2. 路径处理：使用模式匹配而不是外部命令
filename=${path##*/}        # 而不是 basename "$path"
dirname=${path%/*}          # 而不是 dirname "$path"

# 3. 字符串清理：直接处理而不是管道
clean=${input// /}          # 删除空格
lower=${input,,}            # 转换小写（Bash 4+）

# 4. 条件构建：根据变量状态构建参数
debug_flag=${DEBUG:+"--debug"}
config_param=${CONFIG_FILE:+"--config=$CONFIG_FILE"}
```

**❌ 避免的误区**：
```bash
# 错误：过度嵌套，难以阅读
result=${${var#prefix}%suffix}  # 不支持这种嵌套语法

# 正确：分步处理
temp=${var#prefix}
result=${temp%suffix}

# 错误：忽略引号保护
files=${path//* /}             # 可能出现意外的分词

# 正确：适当使用引号
files="${path//* /}"           # 保护结果不被分词
```

**🎯 性能优化**：
```bash
# 优化前：多次调用外部命令
name=$(basename "$file")
ext="${name##*.}"
base=$(basename "$name" ".$ext")

# 优化后：纯Shell参数扩展
name=${file##*/}
ext=${name##*.}
base=${name%.*}
```

### 10.4 实际应用价值


**💼 工作场景应用**：
- **系统脚本编写**：配置文件解析、路径处理、参数验证
- **自动化运维**：批量文件处理、日志分析、服务管理
- **DevOps实践**：构建脚本、部署工具、环境配置
- **数据处理**：文本清理、格式转换、内容提取

**🚀 进阶发展**：
- 结合正则表达式进行复杂模式匹配
- 与数组操作结合实现批量处理
- 配合函数封装实现可复用的工具库
- 结合条件判断实现智能化脚本逻辑

**🔑 核心记忆**：
- 参数扩展是Shell脚本的"瑞士军刀"
- 语法虽多但规律明显，多练习就能熟练掌握
- 优先使用参数扩展而不是外部命令，提高脚本效率
- 合理的参数处理是编写健壮脚本的基础

**📚 学习建议**：
1. **从基础开始**：先掌握`${var:-default}`等常用语法
2. **动手实践**：编写小脚本测试每种语法的效果  
3. **对比学习**：理解不同操作符之间的区别和适用场景
4. **项目应用**：在实际项目中使用，加深理解和记忆