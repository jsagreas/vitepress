---
title: 3、输入输出
---
## 📚 目录

1. [输出命令基础](#1-输出命令基础)
2. [格式化输出详解](#2-格式化输出详解)
3. [用户输入处理](#3-用户输入处理)
4. [命令行参数处理](#4-命令行参数处理)
5. [文件输入输出](#5-文件输入输出)
6. [用户交互设计](#6-用户交互设计)
7. [高级显示技巧](#7-高级显示技巧)
8. [数据验证与错误处理](#8-数据验证与错误处理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🖨️ 输出命令基础


### 1.1 echo命令详解


**🔸 什么是echo**
```
echo：Shell中最基本的输出命令
作用：将文本内容显示到屏幕上
理解：就像让电脑"说话"，把你想展示的内容打印出来
```

**💡 基本用法**
```bash
# 最简单的输出
echo "Hello World"

# 输出变量
name="张三"
echo "你好，$name"
```

**🔧 重要选项详解**

**echo -n 选项（不换行输出）**
```bash
# 默认情况（会自动换行）
echo "第一行"
echo "第二行"
# 输出：
# 第一行
# 第二行

# 使用-n选项（不换行）
echo -n "请输入密码："
read password
# 光标会停在"请输入密码："后面，用户体验更好
```

> **💡 实际应用**：`-n`选项常用于创建提示符，让用户输入紧跟在提示文字后面

**echo -e 选项（启用转义字符）**
```bash
# 不使用-e（转义字符不生效）
echo "姓名：\t张三\n年龄：\t25"
# 输出：姓名：\t张三\n年龄：\t25

# 使用-e（转义字符生效）
echo -e "姓名：\t张三\n年龄：\t25"
# 输出：
# 姓名：	张三
# 年龄：	25
```

**📋 常用转义字符**
| 转义字符 | 含义 | 实际效果 |
|---------|------|----------|
| `\n` | 换行符 | 光标移到下一行开头 |
| `\t` | 制表符 | 相当于按一次Tab键 |
| `\r` | 回车符 | 光标回到本行开头 |
| `\\` | 反斜杠 | 输出一个\ |
| `\"` | 双引号 | 输出一个" |

### 1.2 实用输出技巧


**创建分隔线**
```bash
echo "===================="
echo -e "\n程序开始执行...\n"
echo "===================="
```

**输出多行文本**
```bash
echo -e "系统信息：\n用户：$(whoami)\n主机：$(hostname)\n时间：$(date)"
```

---

## 2. 📊 格式化输出详解


### 2.1 printf命令基础


**🔸 printf vs echo的区别**
```
echo：简单输出，类似日常说话
printf：精确格式化输出，类似正式报告
```

**printf的优势：**
- 🎯 **精确控制**：可以控制小数位数、对齐方式
- 🎯 **格式统一**：让输出整齐美观
- 🎯 **跨平台**：不同系统行为一致

### 2.2 printf格式化详解


**基本语法**
```bash
printf "格式字符串" 参数1 参数2 ...
```

**🔢 数字格式化**
```bash
# 整数格式化
printf "用户ID：%d\n" 1001        # 输出：用户ID：1001
printf "进度：%03d%%\n" 5         # 输出：进度：005%

# 浮点数格式化
score=87.56789
printf "考试成绩：%.2f分\n" $score  # 输出：考试成绩：87.57分
printf "圆周率：%.4f\n" 3.14159    # 输出：圆周率：3.1416
```

**📝 字符串格式化**
```bash
# 字符串对齐
printf "姓名：%-10s 年龄：%3d\n" "张三" 25
printf "姓名：%-10s 年龄：%3d\n" "李四四" 30
# 输出：
# 姓名：张三       年龄： 25
# 姓名：李四四     年龄： 30
```

**📋 printf格式说明符**
| 格式符 | 含义 | 示例 | 输出 |
|--------|------|------|------|
| `%d` | 十进制整数 | `printf "%d" 100` | 100 |
| `%f` | 浮点数 | `printf "%.2f" 3.14159` | 3.14 |
| `%s` | 字符串 | `printf "%s" "hello"` | hello |
| `%c` | 单个字符 | `printf "%c" 65` | A |
| `%x` | 十六进制 | `printf "%x" 255` | ff |

### 2.3 实用格式化示例


**创建表格输出**
```bash
#!/bin/bash
printf "%-10s %-6s %-8s\n" "姓名" "年龄" "成绩"
printf "%-10s %-6s %-8s\n" "----" "----" "----"
printf "%-10s %-6d %-8.1f\n" "张三" 25 87.5
printf "%-10s %-6d %-8.1f\n" "李四" 28 92.3
```

**进度显示**
```bash
for i in {1..100}; do
    printf "\r进度: %3d%% [" $i
    for ((j=1; j<=i/2; j++)); do printf "#"; done
    printf "]"
    sleep 0.1
done
printf "\n完成！\n"
```

---

## 3. 📥 用户输入处理


### 3.1 read命令基础


**🔸 什么是read命令**
```
read：从用户那里"听取"输入的命令
作用：让脚本暂停，等待用户输入信息
理解：就像问问题然后等待回答
```

**基本用法**
```bash
#!/bin/bash
echo "请输入您的姓名："
read name
echo "欢迎你，$name！"
```

### 3.2 read命令选项详解


**read -p 选项（显示提示）**
```bash
# 传统写法（两行）
echo "请输入年龄："
read age

# 使用-p选项（一行搞定）
read -p "请输入年龄：" age
```

> **💡 用户体验提升**：`-p`选项让界面更简洁，用户知道该输入什么

**read -s 选项（静默输入）**
```bash
#!/bin/bash
read -p "用户名：" username
read -sp "密码：" password  # -s让密码不显示在屏幕上
echo  # 输入密码后换行
echo "登录中..."
```

**read -t 选项（超时处理）**
```bash
#!/bin/bash
if read -t 10 -p "请在10秒内输入您的选择：" choice; then
    echo "您选择了：$choice"
else
    echo -e "\n超时了！使用默认选项..."
    choice="default"
fi
```

> **🎯 实际应用**：超时功能适合自动化脚本，避免无限等待

### 3.3 读取多个值


**一次读取多个变量**
```bash
#!/bin/bash
read -p "请输入姓名和年龄（用空格分隔）：" name age
echo "姓名：$name，年龄：$age"

# 如果输入超过变量数量，多余的会给最后一个变量
read -p "输入三个数字：" num1 num2 num3
# 输入：1 2 3 4 5
# 结果：num1=1, num2=2, num3="3 4 5"
```

**读取到数组**
```bash
#!/bin/bash
read -p "输入几个爱好（空格分隔）：" -a hobbies
echo "您的爱好有：${#hobbies[@]}个"
for hobby in "${hobbies[@]}"; do
    echo "- $hobby"
done
```

---

## 4. 🔧 命令行参数处理


### 4.1 位置参数详解


**🔸 什么是位置参数**
```
位置参数：脚本运行时从外部传入的参数
理解：就像函数的参数，让脚本更灵活
使用：./script.sh 参数1 参数2 参数3
```

**内置变量说明**
```bash
#!/bin/bash
echo "脚本名称：$0"        # 脚本文件名
echo "第一个参数：$1"      # 第1个参数
echo "第二个参数：$2"      # 第2个参数
echo "参数总数：$#"        # 参数个数
echo "所有参数：$@"        # 所有参数（分别输出）
echo "所有参数：$*"        # 所有参数（整体输出）
```

**📋 特殊变量对比**
| 变量 | 含义 | 示例 |
|------|------|------|
| `$0` | 脚本名 | `./test.sh` |
| `$1-$9` | 位置参数 | 第1到第9个参数 |
| `$#` | 参数个数 | `3` |
| `$@` | 所有参数（数组形式） | `"arg1" "arg2" "arg3"` |
| `$*` | 所有参数（字符串形式） | `"arg1 arg2 arg3"` |

### 4.2 参数验证


**检查参数数量**
```bash
#!/bin/bash
if [ $# -eq 0 ]; then
    echo "错误：请提供至少一个参数"
    echo "用法：$0 <文件名> [操作]"
    exit 1
fi

filename=$1
operation=${2:-"查看"}  # 第二个参数，默认为"查看"
echo "对文件 $filename 执行 $operation 操作"
```

**参数类型检查**
```bash
#!/bin/bash
read -p "请输入一个数字：" input

# 检查是否为数字
if [[ $input =~ ^[0-9]+$ ]]; then
    echo "$input 是一个有效的数字"
else
    echo "错误：$input 不是数字"
    exit 1
fi
```

### 4.3 高级参数处理


**使用getopts处理选项**
```bash
#!/bin/bash
# 处理类似 -f filename -v 这样的选项

while getopts "f:vh" opt; do
    case $opt in
        f) filename="$OPTARG";;
        v) verbose=true;;
        h) echo "用法：$0 -f 文件名 [-v] [-h]"; exit 0;;
        \?) echo "无效选项"; exit 1;;
    esac
done

echo "文件名：$filename"
[ "$verbose" = true ] && echo "详细模式已启用"
```

---

## 5. 📁 文件输入输出


### 5.1 重定向基础


**🔸 什么是重定向**
```
重定向：改变数据的流向
理解：就像改变水管的方向，让数据流到不同地方
标准流：stdin(输入) stdout(输出) stderr(错误)
```

**基本重定向操作**
```bash
# 输出重定向
echo "Hello World" > output.txt      # 覆盖写入
echo "新内容" >> output.txt          # 追加写入

# 输入重定向
sort < names.txt                     # 从文件读取输入

# 错误重定向
ls /不存在的目录 2> error.log        # 错误信息写入文件
```

### 5.2 实用文件操作


**创建日志文件**
```bash
#!/bin/bash
logfile="system_check_$(date +%Y%m%d).log"

{
    echo "系统检查开始：$(date)"
    echo "磁盘使用情况："
    df -h
    echo "内存使用情况："
    free -h
    echo "系统检查结束：$(date)"
} > "$logfile"

echo "日志已保存到：$logfile"
```

**读取配置文件**
```bash
#!/bin/bash
config_file="app.conf"

if [ ! -f "$config_file" ]; then
    echo "配置文件不存在，创建默认配置..."
    cat > "$config_file" << EOF
username=admin
password=123456
host=localhost
port=8080
EOF
fi

# 读取配置
while IFS='=' read -r key value; do
    case $key in
        username) USERNAME="$value";;
        password) PASSWORD="$value";;
        host) HOST="$value";;
        port) PORT="$value";;
    esac
done < "$config_file"

echo "连接到：$HOST:$PORT，用户：$USERNAME"
```

---

## 6. 🎯 用户交互设计


### 6.1 select语句菜单


**🔸 什么是select语句**
```
select：创建选择菜单的专用语句
作用：让用户从列表中选择选项
理解：就像餐厅菜单，用户选择想要的
```

**基本菜单示例**
```bash
#!/bin/bash
echo "请选择操作："

select operation in "查看文件" "创建文件" "删除文件" "退出"; do
    case $operation in
        "查看文件")
            read -p "请输入文件名：" filename
            cat "$filename" 2>/dev/null || echo "文件不存在"
            ;;
        "创建文件")
            read -p "请输入文件名：" filename
            touch "$filename"
            echo "文件 $filename 已创建"
            ;;
        "删除文件")
            read -p "请输入文件名：" filename
            rm -i "$filename"
            ;;
        "退出")
            echo "再见！"
            break
            ;;
        *)
            echo "无效选择，请重新选择"
            ;;
    esac
done
```

### 6.2 用户友好的交互


**确认对话框**
```bash
#!/bin/bash
confirm_action() {
    local message="$1"
    local response
    
    while true; do
        read -p "$message (y/n): " response
        case $response in
            [Yy]|[Yy][Ee][Ss]) return 0;;
            [Nn]|[Nn][Oo]) return 1;;
            *) echo "请输入 y 或 n";;
        esac
    done
}

if confirm_action "确定要删除所有日志文件吗？"; then
    rm -f *.log
    echo "日志文件已删除"
else
    echo "操作已取消"
fi
```

**进度提示**
```bash
#!/bin/bash
show_progress() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local completed=$((current * width / total))
    
    printf "\r["
    printf "%${completed}s" | tr ' ' '='
    printf "%$((width - completed))s" | tr ' ' '-'
    printf "] %d%% (%d/%d)" $percentage $current $total
}

# 使用示例
total=100
for i in $(seq 1 $total); do
    show_progress $i $total
    sleep 0.05
done
echo -e "\n任务完成！"
```

---

## 7. 🌈 高级显示技巧


### 7.1 彩色输出控制


**🔸 ANSI转义序列**
```
ANSI转义序列：控制终端显示的特殊代码
作用：改变文字颜色、样式、光标位置
理解：就像给文字化妆，让输出更生动
```

**颜色代码定义**
```bash
#!/bin/bash
# 定义颜色常量
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'  # No Color (重置颜色)

# 使用彩色输出
echo -e "${GREEN}成功：${NC}操作已完成"
echo -e "${RED}错误：${NC}文件未找到"
echo -e "${YELLOW}警告：${NC}磁盘空间不足"
```

**📋 常用颜色代码**
| 颜色 | 前景色代码 | 背景色代码 |
|------|------------|------------|
| 黑色 | `\033[0;30m` | `\033[40m` |
| 红色 | `\033[0;31m` | `\033[41m` |
| 绿色 | `\033[0;32m` | `\033[42m` |
| 黄色 | `\033[1;33m` | `\033[43m` |
| 蓝色 | `\033[0;34m` | `\033[44m` |

### 7.2 状态显示函数


**通用状态输出函数**
```bash
#!/bin/bash
# 状态输出函数
print_status() {
    local status=$1
    local message=$2
    
    case $status in
        "success"|"ok")
            echo -e "[\033[0;32m✓\033[0m] $message"
            ;;
        "error"|"fail")
            echo -e "[\033[0;31m✗\033[0m] $message"
            ;;
        "warning"|"warn")
            echo -e "[\033[1;33m!\033[0m] $message"
            ;;
        "info")
            echo -e "[\033[0;34mi\033[0m] $message"
            ;;
        *)
            echo "[ ] $message"
            ;;
    esac
}

# 使用示例
print_status "info" "开始系统检查..."
print_status "success" "网络连接正常"
print_status "warning" "磁盘使用率超过80%"
print_status "error" "服务启动失败"
```

### 7.3 动态进度条


**旋转进度指示器**
```bash
#!/bin/bash
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# 使用示例
sleep 5 &
pid=$!
echo -n "处理中"
spinner $pid
echo -e "\n完成！"
```

---

## 8. ✅ 数据验证与错误处理


### 8.1 输入验证技巧


**数字验证**
```bash
#!/bin/bash
validate_number() {
    local input=$1
    local min=${2:-0}
    local max=${3:-100}
    
    if [[ ! $input =~ ^[0-9]+$ ]]; then
        echo "错误：请输入数字"
        return 1
    fi
    
    if [ $input -lt $min ] || [ $input -gt $max ]; then
        echo "错误：数字必须在 $min-$max 之间"
        return 1
    fi
    
    return 0
}

# 获取有效输入
get_valid_number() {
    local prompt=$1
    local min=$2
    local max=$3
    local input
    
    while true; do
        read -p "$prompt ($min-$max): " input
        if validate_number "$input" "$min" "$max"; then
            echo $input
            return
        fi
    done
}

age=$(get_valid_number "请输入年龄" 1 120)
echo "您的年龄是：$age"
```

**邮箱验证**
```bash
#!/bin/bash
validate_email() {
    local email=$1
    local pattern="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    
    if [[ $email =~ $pattern ]]; then
        return 0
    else
        return 1
    fi
}

while true; do
    read -p "请输入邮箱地址：" email
    if validate_email "$email"; then
        echo "邮箱格式正确：$email"
        break
    else
        echo "邮箱格式错误，请重新输入"
    fi
done
```

### 8.2 错误处理策略


**错误处理函数**
```bash
#!/bin/bash
# 错误处理函数
handle_error() {
    local error_code=$1
    local error_message=$2
    local line_number=${3:-"unknown"}
    
    echo -e "\033[0;31m错误 [$error_code]：\033[0m$error_message"
    echo "发生在第 $line_number 行"
    
    # 记录到日志
    echo "$(date '+%Y-%m-%d %H:%M:%S') ERROR: $error_message (Line: $line_number)" >> error.log
    
    exit $error_code
}

# 设置错误陷阱
trap 'handle_error $? "脚本执行出错" $LINENO' ERR

# 文件操作示例
copy_file() {
    local source=$1
    local target=$2
    
    [ ! -f "$source" ] && handle_error 1 "源文件不存在：$source" $LINENO
    
    cp "$source" "$target" || handle_error 2 "文件复制失败" $LINENO
    
    echo "文件复制成功：$source -> $target"
}
```

### 8.3 用户友好的错误提示


**分类错误处理**
```bash
#!/bin/bash
show_error() {
    local category=$1
    local message=$2
    
    case $category in
        "file")
            echo -e "\033[0;31m📁 文件错误：\033[0m$message"
            echo "💡 建议：检查文件路径和权限"
            ;;
        "network")
            echo -e "\033[0;31m🌐 网络错误：\033[0m$message"
            echo "💡 建议：检查网络连接"
            ;;
        "input")
            echo -e "\033[0;31m⌨️  输入错误：\033[0m$message"
            echo "💡 建议：检查输入格式是否正确"
            ;;
        "permission")
            echo -e "\033[0;31m🔒 权限错误：\033[0m$message"
            echo "💡 建议：使用 sudo 或检查文件权限"
            ;;
        *)
            echo -e "\033[0;31m❌ 错误：\033[0m$message"
            ;;
    esac
}

# 使用示例
if [ ! -r "$filename" ]; then
    show_error "file" "无法读取文件 $filename"
    exit 1
fi
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 输出命令：echo 简单输出，printf 格式化输出
🔸 输入命令：read 用户输入，支持提示、静默、超时
🔸 参数处理：位置参数 $1 $2，特殊变量 $# $@ $*
🔸 文件操作：重定向 > >> <，管道处理数据流
🔸 用户交互：select 菜单，确认对话，进度显示
🔸 显示增强：ANSI 颜色控制，状态图标，进度条
🔸 数据验证：输入检查，错误处理，用户友好提示
```

### 9.2 关键理解要点


**🔹 输出命令的选择**
```
简单文本输出 → 使用 echo
格式化输出 → 使用 printf  
表格数据 → 使用 printf + 格式控制
状态信息 → 使用彩色输出增强
```

**🔹 用户输入最佳实践**
```
提供清晰提示 → 使用 read -p
密码输入 → 使用 read -s
超时控制 → 使用 read -t
输入验证 → 检查格式和范围
错误处理 → 提供友好的错误信息
```

**🔹 交互设计原则**
```
用户友好 → 清晰的提示和反馈
容错性强 → 输入验证和错误处理  
视觉美观 → 彩色输出和进度显示
操作便利 → 菜单选择和默认值
```

### 9.3 实际应用价值


**📌 日常脚本开发**
- 系统管理脚本的用户交互
- 自动化任务的进度显示
- 配置文件的读取和处理
- 日志记录和错误报告

**📌 用户体验提升**
- 彩色输出让信息更清晰
- 进度条显示任务状态
- 输入验证防止错误操作
- 友好提示改善用户感受

**📌 脚本健壮性**
- 参数验证确保输入正确
- 错误处理提高稳定性
- 日志记录便于问题诊断
- 超时机制避免无限等待

### 9.4 学习建议


**🎯 练习重点**
```
基础练习：
• 编写带颜色输出的系统信息脚本
• 创建用户注册表单（包含输入验证）
• 制作文件管理菜单程序

进阶练习：
• 开发备份脚本（带进度条和日志）
• 创建系统监控脚本（彩色状态显示）
• 编写配置管理工具（交互式设置）
```

**🔧 常用代码模板**
```bash
# 通用脚本开头模板
#!/bin/bash
set -euo pipefail  # 严格模式

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# 状态输出函数
print_status() { ... }

# 输入验证函数
validate_input() { ... }

# 错误处理函数
handle_error() { ... }
```

**核心记忆**：
- echo 输出文本，printf 格式化更精确
- read 获取输入，选项控制交互方式
- 参数处理用 $1 $2，验证输入保安全
- 彩色输出美观，进度显示很直观
- 用户交互要友好，错误处理不能少