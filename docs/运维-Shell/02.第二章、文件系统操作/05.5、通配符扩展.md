---
title: 5、通配符扩展
---
## 📚 目录

1. [通配符基础概念](#1-通配符基础概念)
2. [星号通配符详解](#2-星号通配符详解)
3. [问号单字符匹配](#3-问号单字符匹配)
4. [方括号字符集匹配](#4-方括号字符集匹配)
5. [大括号扩展机制](#5-大括号扩展机制)
6. [波浪号主目录扩展](#6-波浪号主目录扩展)
7. [路径名扩展原理](#7-路径名扩展原理)
8. [通配符转义处理](#8-通配符转义处理)
9. [实际应用场景](#9-实际应用场景)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 通配符基础概念


### 1.1 什么是通配符


**通配符**就是Shell中的"万能卡"，用特殊符号代表多个文件名或路径。就像打牌时的万能牌一样，一个符号可以匹配多种情况。

```
现实类比：
电话号码：138****1234  (* 代表任意数字)
身份证号：320***********1X  (* 代表任意字符)

Shell中：
文件名：*.txt  (* 代表任意字符，匹配所有txt文件)
```

**🔸 核心作用**
- **批量操作**：一次性处理多个文件
- **模式匹配**：按照规则找到目标文件
- **提高效率**：避免逐个指定文件名

### 1.2 通配符工作原理


通配符扩展是Shell在执行命令前的**预处理步骤**，Shell会先把通配符替换成实际的文件名，然后再执行命令。

```
工作流程：
用户输入：ls *.txt
    ↓
Shell扩展：ls file1.txt file2.txt readme.txt
    ↓  
执行命令：显示三个txt文件
```

**⚠️ 重要理解**
- 通配符是**Shell的功能**，不是命令的功能
- 命令执行时看到的已经是扩展后的结果
- 如果没有匹配的文件，通配符会保持原样

### 1.3 通配符分类概览


| 符号类型 | **符号** | **作用** | **示例** |
|---------|---------|----------|----------|
| 🌟 **星号** | `*` | 匹配任意长度字符 | `*.log` |
| ❓ **问号** | `?` | 匹配单个字符 | `file?.txt` |
| 📦 **方括号** | `[]` | 匹配字符集合 | `[abc].txt` |
| 🔄 **大括号** | `{}` | 列举多个选项 | `{jpg,png}` |
| 🏠 **波浪号** | `~` | 用户主目录 | `~/Documents` |

---

## 2. 🌟 星号通配符详解


### 2.1 星号通配符基本用法


**星号（\*）**是最常用的通配符，可以匹配**零个或多个任意字符**（除了隐藏文件的开头点号）。

```bash
# 匹配所有文件
ls *

# 匹配所有txt文件  
ls *.txt

# 匹配以data开头的文件
ls data*

# 匹配包含log的文件
ls *log*
```

### 2.2 星号匹配规则详解


**🔸 匹配范围**
```
文件列表：
file.txt
data.log  
image.jpg
.hidden
README

ls * 结果：
file.txt data.log image.jpg README
# 注意：.hidden 不被匹配（隐藏文件）
```

**🔸 零长度匹配**
```bash
# 创建测试文件
touch file file.txt fileabc.txt

# 使用 file* 匹配
ls file*
# 结果：file file.txt fileabc.txt
# file 也被匹配（* 匹配零个字符）
```

### 2.3 星号的位置应用


```
应用场景图示：

前缀匹配：    data*
              ├── data.txt
              ├── data.log
              └── database.sql

后缀匹配：    *.jpg
              ├── photo.jpg  
              ├── image.jpg
              └── avatar.jpg

中间匹配：    *config*
              ├── app.config.js
              ├── user-config.xml  
              └── config.ini

全匹配：      *.*
              └── 所有带扩展名的文件
```

### 2.4 多个星号使用


```bash
# 多级目录匹配（需要特殊设置）
ls */*.txt        # 匹配子目录中的txt文件
ls */images/*.jpg # 匹配子目录images中的jpg文件

# 多段匹配
ls *data*file*    # 匹配包含data和file的文件
```

---

## 3. ❓ 问号单字符匹配


### 3.1 问号通配符基本概念


**问号（?）**匹配**恰好一个字符**，不多不少。就像填空题的一个空格，必须填入一个字符。

```bash
# 匹配单个字符
ls file?.txt
# 可能匹配：file1.txt, filea.txt, file_.txt
# 不匹配：file.txt (缺少字符), file10.txt (多个字符)
```

### 3.2 问号与星号对比


```
对比示例：

文件列表：
a.txt
ab.txt  
abc.txt
abcd.txt

使用 a*.txt：
✅ a.txt ab.txt abc.txt abcd.txt (全部匹配)

使用 a?.txt：  
❌ a.txt (字符不够)
✅ ab.txt (恰好一个字符)
❌ abc.txt (字符太多)
❌ abcd.txt (字符太多)
```

### 3.3 多个问号组合


```bash
# 创建测试文件
touch file1.txt file22.txt file333.txt

# 使用多个问号
ls file?.txt      # 匹配：file1.txt
ls file??.txt     # 匹配：file22.txt  
ls file???.txt    # 匹配：file333.txt

# 混合使用
ls file??.*       # 匹配两个字符后缀的文件
```

### 3.4 问号实际应用


**📋 常见使用场景**

```bash
# 1. 匹配固定位数的文件
ls IMG_????.jpg   # 匹配4位数字的图片：IMG_0001.jpg

# 2. 匹配日期格式文件  
ls 2024-??-??.log # 匹配日期日志：2024-01-15.log

# 3. 匹配版本文件
ls app_v?.?.tar   # 匹配版本：app_v1.2.tar

# 4. 匹配临时文件
ls temp?.tmp      # 匹配：temp1.tmp, tempA.tmp
```

---

## 4. 📦 方括号字符集匹配


### 4.1 方括号基本用法


**方括号（[]）**用来匹配**指定字符集合中的一个字符**。就像多选题，从给定选项中选择一个。

```bash
# 基本语法
[字符集合]

# 匹配a、b、c中的任意一个
ls file[abc].txt
# 可能匹配：filea.txt, fileb.txt, filec.txt
```

### 4.2 字符集合定义方式


**🔸 直接列举字符**
```bash
# 匹配数字
ls file[123].txt      # 匹配：file1.txt, file2.txt, file3.txt

# 匹配字母
ls [abc]*.log         # 匹配a、b、c开头的log文件

# 匹配混合字符
ls data[1a2b].txt     # 匹配：data1.txt, dataa.txt, data2.txt, datab.txt
```

**🔸 字符范围表示**
```bash
# 数字范围
ls file[0-9].txt      # 匹配：file0.txt 到 file9.txt

# 字母范围  
ls [a-z]*.doc         # 匹配小写字母开头的doc文件
ls [A-Z]*.doc         # 匹配大写字母开头的doc文件
ls [a-zA-Z]*.txt      # 匹配字母开头的txt文件

# 组合范围
ls [0-9a-f]*.hex      # 匹配十六进制字符开头的文件
```

### 4.3 否定字符集


**感叹号（!）或插入号（^）**表示**不匹配**指定字符集合。

```bash
# 不匹配数字开头
ls [!0-9]*.txt        # 匹配非数字开头的txt文件

# 不匹配元音字母
ls [!aeiou]*.log      # 匹配非元音字母开头的log文件

# 两种写法等价
ls [!abc]*.txt        # 等同于
ls [^abc]*.txt        # 不匹配a、b、c开头
```

### 4.4 特殊字符集


**📋 常用预定义字符集**

```bash
# POSIX字符类（需要双层方括号）
ls [[:digit:]]*.txt   # 匹配数字开头 [0-9]
ls [[:alpha:]]*.txt   # 匹配字母开头 [a-zA-Z]  
ls [[:alnum:]]*.txt   # 匹配字母数字开头
ls [[:upper:]]*.txt   # 匹配大写字母开头
ls [[:lower:]]*.txt   # 匹配小写字母开头
```

### 4.5 方括号高级应用


```bash
# 复杂匹配示例
ls IMG_[0-9][0-9][0-9][0-9].jpg    # 匹配4位数字图片

# 日期格式匹配
ls 202[0-9]-[01][0-9]-[0-3][0-9].log  # 匹配日期格式日志

# 混合使用
ls [Dd]ata[0-9]*.txt               # 匹配Data或data开头，后跟数字的txt文件
```

---

## 5. 🔄 大括号扩展机制


### 5.1 大括号扩展基本概念


**大括号扩展（{}）**不是通配符，而是Shell的**扩展机制**，用来生成多个字符串组合。它会把大括号中的选项逐个展开。

```bash
# 基本语法
{选项1,选项2,选项3}

# 扩展示例
echo file{1,2,3}.txt
# 扩展结果：file1.txt file2.txt file3.txt
```

### 5.2 列表扩展应用


**🔸 文件格式扩展**
```bash
# 匹配多种图片格式
ls image.{jpg,png,gif}
# 等价于：ls image.jpg image.png image.gif

# 备份文件扩展
cp config.{conf,conf.bak}  
# 等价于：cp config.conf config.conf.bak

# 批量创建文件
touch report{1,2,3}.txt
# 创建：report1.txt report2.txt report3.txt
```

**🔸 路径扩展**
```bash
# 多目录操作
ls {/var/log,/tmp,/home}/*.txt

# 多级目录创建
mkdir -p project/{src,doc,test}/{js,css,img}
# 创建完整目录结构
```

### 5.3 数字序列扩展


**🔸 基本数字序列**
```bash
# 连续数字
echo {1..5}           # 输出：1 2 3 4 5
echo file{1..10}.txt  # 生成：file1.txt 到 file10.txt

# 步长设置（Bash 4.0+）
echo {1..10..2}       # 输出：1 3 5 7 9 (步长为2)
echo {0..100..10}     # 输出：0 10 20 30 ... 100
```

**🔸 字母序列扩展**
```bash
# 字母序列
echo {a..e}           # 输出：a b c d e
echo {A..Z}           # 输出：A B C ... Z

# 反向序列
echo {5..1}           # 输出：5 4 3 2 1
echo {z..a}           # 输出：z y x ... a
```

### 5.4 嵌套大括号扩展


```bash
# 嵌套扩展
echo {a,b}{1,2}
# 扩展结果：a1 a2 b1 b2

# 复杂嵌套
mkdir {2023,2024}/{01..12}/{week{1..4}}
# 创建年份/月份/周次目录结构

# 三层嵌套示例
echo {dev,test,prod}.{web,api}.{conf,log}
# 生成：dev.web.conf dev.web.log test.web.conf ... 等12个组合
```

### 5.5 大括号实际应用


**📋 批量操作场景**

```bash
# 1. 批量重命名
for file in image{1..10}.jpg; do
    mv "$file" "photo_$file"
done

# 2. 多环境配置
cp app.conf app.{dev,test,prod}.conf

# 3. 批量下载
wget http://example.com/file{001..100}.zip

# 4. 日志归档
tar -czf logs_$(date +%Y%m%d).tar.gz /var/log/{apache,nginx,mysql}/*.log
```

---

## 6. 🏠 波浪号主目录扩展


### 6.1 波浪号基本概念


**波浪号（~）**是Shell中表示**用户主目录**的快捷符号。相当于环境变量`$HOME`的简写形式。

```bash
# 基本用法
echo ~              # 输出当前用户主目录：/home/username
echo ~/Documents    # 输出：/home/username/Documents

# 等价写法
echo ~              # 等同于 echo $HOME
cd ~                # 等同于 cd $HOME
```

### 6.2 不同用户的主目录


```bash
# 当前用户主目录
~                   # /home/currentuser

# 指定用户主目录  
~root               # /root (root用户主目录)
~alice              # /home/alice (alice用户主目录)
~bob                # /home/bob (bob用户主目录)

# 实际应用
ls ~alice/Documents # 查看alice用户的Documents目录
cp file.txt ~bob/   # 复制文件到bob用户目录
```

### 6.3 波浪号扩展规则


**🔸 扩展时机**
```bash
# Shell会在扩展通配符之前先处理波浪号
~/Pictures/*.jpg    # 先扩展为 /home/user/Pictures/*.jpg
                    # 再扩展为具体的jpg文件列表
```

**🔸 引号中的波浪号**
```bash
# 单引号：不扩展
echo '~'            # 输出：~（字面意思）

# 双引号：不扩展  
echo "~"            # 输出：~（字面意思）

# 无引号：扩展
echo ~              # 输出：/home/username
```

### 6.4 波浪号实际应用


**📋 常见使用场景**

```bash
# 1. 快速返回主目录
cd ~                # 或者直接 cd

# 2. 访问常用目录
ls ~/Desktop        # 查看桌面文件
cd ~/Documents      # 进入文档目录
cp file.txt ~/      # 复制到主目录

# 3. 配置文件路径
vim ~/.bashrc       # 编辑bash配置
ls ~/.ssh/          # 查看SSH配置

# 4. 跨用户操作（需要权限）
sudo cp config.conf ~www-data/
```

**⚠️ 注意事项**
- 波浪号只能在路径开头使用
- 用户名不存在时不会扩展
- 需要相应的访问权限

---

## 7. 📂 路径名扩展原理


### 7.1 什么是路径名扩展


**路径名扩展（Globbing）**是Shell将通配符转换为实际文件路径的过程。这个过程发生在命令执行之前。

```
扩展过程示意：

用户输入：    ls *.txt
              ↓
Shell扫描：   查找当前目录所有.txt文件  
              ↓
扩展结果：    ls file1.txt readme.txt notes.txt
              ↓  
命令执行：    显示三个文件信息
```

### 7.2 扩展机制工作原理


**🔸 扩展顺序**
```
1. 波浪号扩展     ~/file → /home/user/file
2. 大括号扩展     {a,b} → a b  
3. 参数扩展       $var → value
4. 通配符扩展     *.txt → 具体文件列表
5. 路径名扩展     处理完整路径
```

**🔸 目录遍历过程**
```bash
# 扫描当前目录
ls *              # 扫描当前目录所有文件

# 扫描子目录  
ls */*.txt        # 扫描所有子目录中的txt文件

# 递归模式（需要特殊设置）
shopt -s globstar # 启用递归glob
ls **/*.txt       # 递归匹配所有层级的txt文件
```

### 7.3 匹配失败处理


**🔸 无匹配文件时的行为**
```bash
# 当没有匹配的文件时
ls *.xyz          # 如果没有.xyz文件

# 默认行为：保持原样
# 输出：ls: cannot access '*.xyz': No such file or directory

# 设置空匹配行为
shopt -s nullglob # 无匹配时返回空
ls *.xyz          # 无输出，不报错
```

### 7.4 扩展控制选项


**📋 Shell选项控制**

```bash
# 查看当前glob选项
shopt | grep glob

# 常用选项
shopt -s nullglob     # 无匹配时返回空列表
shopt -s failglob     # 无匹配时报错退出
shopt -s globstar     # 启用 ** 递归匹配
shopt -s nocaseglob   # 忽略大小写匹配
shopt -s extglob      # 启用扩展glob模式

# 禁用选项
shopt -u nullglob     # 恢复默认行为
```

**🔸 扩展glob模式**
```bash
# 需要先启用：shopt -s extglob

# 零个或一个匹配
ls file?(s).txt       # 匹配：file.txt 或 files.txt

# 零个或多个匹配  
ls file*(s).txt       # 匹配：file.txt files.txt filess.txt

# 一个或多个匹配
ls file+(s).txt       # 匹配：files.txt filess.txt (不匹配file.txt)

# 恰好一个匹配
ls file@(1|2|3).txt   # 匹配：file1.txt file2.txt file3.txt

# 排除匹配
ls file!(backup).txt  # 匹配除了filebackup.txt以外的文件
```

---

## 8. 🛡️ 通配符转义处理


### 8.1 为什么需要转义


当文件名中包含通配符字符时，或者想要**字面意思**使用通配符符号时，需要进行转义处理。

```bash
# 问题场景：文件名包含特殊字符
touch "file*.txt"     # 创建名为 file*.txt 的文件
ls *.txt              # 这会匹配所有txt文件，而不是file*.txt这个文件
```

### 8.2 转义方法详解


**🔸 反斜杠转义**
```bash
# 转义单个字符
ls file\*.txt         # 匹配名为 file*.txt 的文件
ls \*                 # 匹配名为 * 的文件

# 转义多个字符
ls file\?\[test\].txt # 匹配 file?[test].txt 文件
```

**🔸 单引号转义**
```bash
# 单引号内所有字符都是字面意思
ls 'file*.txt'        # 匹配名为 file*.txt 的文件
ls '*.txt'            # 匹配名为 *.txt 的文件（不是通配符）
```

**🔸 双引号转义**
```bash
# 双引号内大部分字符是字面意思（但变量和命令替换仍生效）
ls "file*.txt"        # 匹配名为 file*.txt 的文件
ls "file$USER.txt"    # 会扩展$USER变量
```

### 8.3 转义字符对照表


| 字符 | **含义** | **转义方法** | **示例** |
|------|----------|-------------|----------|
| `*` | 任意字符通配符 | `\*` 或 `'*'` | `ls \*.bak` |
| `?` | 单字符通配符 | `\?` 或 `'?'` | `ls file\?.txt` |
| `[]` | 字符集匹配 | `\[\]` 或 `'[]'` | `ls \[test\].txt` |
| `{}` | 大括号扩展 | `\{\}` 或 `'{}'` | `echo \{1,2\}` |
| `~` | 主目录扩展 | `\~` 或 `'~'` | `ls \~backup` |
| `$` | 变量扩展 | `\$` 或 `'$'` | `echo \$PATH` |

### 8.4 实际转义应用


**📋 常见转义场景**

```bash
# 1. 处理包含空格的文件名
ls "My Document.txt"
ls My\ Document.txt

# 2. 处理特殊字符文件名
touch "file[backup].txt"
ls "file[backup].txt"      # 正确：匹配确切文件名
ls file\[backup\].txt      # 正确：转义方式

# 3. 在脚本中安全处理
filename="data*.log"
ls "$filename"             # 正确：作为字面文件名处理
ls $filename               # 错误：会进行通配符扩展

# 4. find命令中的转义
find . -name "*.tmp"       # 正确：引号保护通配符传递给find
find . -name \*.tmp        # 正确：转义保护通配符
find . -name *.tmp         # 错误：Shell先扩展通配符
```

---

## 9. 🚀 实际应用场景


### 9.1 文件管理场景


**🔸 批量文件操作**
```bash
# 清理临时文件
rm *.tmp *.bak *~         # 删除临时和备份文件

# 图片文件整理  
mkdir photos
mv *.{jpg,png,gif} photos/  # 移动所有图片到photos目录

# 日志文件压缩
tar -czf logs_$(date +%Y%m%d).tar.gz *.log

# 批量重命名（添加前缀）
for file in *.txt; do
    mv "$file" "backup_$file"
done
```

**🔸 查找特定文件**
```bash
# 查找配置文件
ls *.conf *.config        # 查找配置文件
ls ~/.{bash,zsh}*          # 查找shell配置文件

# 查找可执行文件
ls /usr/bin/[a-c]*         # 查找a-c开头的命令

# 查找特定日期文件
ls 2024-01-??.log          # 查找1月份的日志文件
ls backup_{1..31}.tar      # 查找按日期命名的备份文件
```

### 9.2 系统管理场景


**🔸 日志分析**
```bash
# 分析不同类型日志
tail -f /var/log/{apache,nginx}/*.log

# 清理旧日志文件
find /var/log -name "*.log.[0-9]*" -mtime +30 -delete

# 监控系统文件
ls /etc/*.{conf,cfg} | wc -l    # 统计配置文件数量
```

**🔸 用户管理**
```bash
# 查看用户目录
ls /home/*/              # 查看所有用户目录
ls ~*/Desktop            # 查看所有用户桌面（需要权限）

# 查找用户配置
ls ~*/.bashrc            # 查看所有用户bash配置
```

### 9.3 开发项目场景


**🔸 代码文件操作**
```bash
# 查找源码文件
ls src/**/*.{js,ts,jsx,tsx}     # 查找所有JavaScript/TypeScript文件
find . -name "*.py" | wc -l      # 统计Python文件数量

# 清理编译文件
rm *.{o,obj,class,pyc}          # 删除编译生成文件

# 备份项目文件
tar -czf project_$(date +%Y%m%d).tar.gz \
    --exclude="*.tmp" \
    --exclude="node_modules" \
    ./*
```

**🔸 测试和部署**
```bash
# 运行测试文件
pytest test_*.py              # 运行所有测试文件

# 部署多环境配置
cp config.template config.{dev,test,prod}.json

# 清理构建目录
rm -rf build/* dist/*         # 清理构建输出
```

### 9.4 数据处理场景


**🔸 数据文件处理**
```bash
# 合并CSV文件
cat data_*.csv > merged_data.csv

# 处理不同格式数据
for file in data.{csv,json,xml}; do
    echo "Processing $file..."
    # 处理逻辑
done

# 按日期处理数据
ls data_2024-??-??.txt | sort | while read file; do
    echo "Processing $file"
    # 数据处理逻辑
done
```

### 9.5 通配符组合技巧


**🔸 复杂匹配模式**
```bash
# 多层条件匹配
ls [Dd]ata_[0-9][0-9][0-9][0-9]_*.{csv,txt}
# 匹配：Data_2024_report.csv, data_2023_summary.txt

# 排除特定文件
ls *.txt | grep -v backup     # 显示所有txt文件但排除包含backup的

# 按大小写匹配
shopt -s nocaseglob           # 忽略大小写
ls *.TXT                      # 也能匹配 .txt 文件
```

**⚠️ 实用提醒**
- 使用通配符前先用`echo`测试匹配结果
- 处理文件名包含空格的情况要加引号
- 在脚本中使用时考虑无匹配文件的情况
- 复杂匹配考虑使用`find`命令替代

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 通配符本质：Shell的模式匹配机制，命令执行前预处理
🔸 扩展时机：Shell处理通配符 → 生成文件列表 → 执行命令
🔸 五大类型：* ? [] {} ~ 各有不同的匹配规则
🔸 转义需求：文件名包含特殊字符时需要转义保护
🔸 实用原则：提高效率、批量操作、模式匹配
```

### 10.2 关键理解要点


**🔹 通配符vs正则表达式**
```
通配符（Shell）：
- 用于文件名匹配
- * 匹配任意字符
- ? 匹配单个字符
- [] 字符集匹配

正则表达式（文本处理）：  
- 用于文本内容匹配
- .* 匹配任意字符
- . 匹配单个字符  
- [] 字符集匹配
- 更复杂的模式表达
```

**🔹 扩展机制理解**
```
大括号扩展：{} 不是匹配，是生成
- echo {a,b}.txt → a.txt b.txt（生成多个参数）

通配符匹配：* ? [] 是匹配现有文件  
- ls *.txt → 匹配现存的txt文件

波浪号扩展：~ 是路径替换
- ~/file → /home/user/file（路径转换）
```

**🔹 匹配失败行为**
```
默认行为：无匹配时保持原样
ls *.xyz → ls: cannot access '*.xyz'

nullglob选项：无匹配时返回空
shopt -s nullglob
ls *.xyz → （无输出，不报错）

failglob选项：无匹配时脚本退出
shopt -s failglob  
ls *.xyz → 脚本直接退出
```

### 10.3 实际应用价值


**🎯 提升工作效率**
- **批量操作**：一次处理多个文件，避免重复命令
- **模式匹配**：按规则查找文件，精确定位目标
- **路径简化**：使用~简化路径输入，提高操作速度

**🔧 系统管理应用**
- **日志管理**：`*.log`匹配日志文件，便于分析清理
- **配置管理**：`*.conf`查找配置文件，批量操作
- **备份操作**：组合通配符实现智能备份策略

**💻 开发项目应用**
- **代码管理**：`*.{js,css,html}`匹配前端文件
- **构建清理**：`*.{o,tmp,bak}`清理临时文件  
- **测试运行**：`test_*.py`运行所有测试文件

### 10.4 最佳实践建议


```bash
# 1. 先测试再执行
echo *.txt                    # 查看匹配结果
rm *.txt                      # 确认无误后删除

# 2. 处理特殊文件名
ls "My File.txt"              # 空格文件名用引号
ls file\*.txt                 # 特殊字符转义

# 3. 脚本中安全使用
for file in *.txt; do
    [[ -f "$file" ]] || continue  # 检查文件存在
    echo "Processing $file"
done

# 4. 结合其他命令
find . -name "*.log" -exec rm {} \;  # 复杂匹配用find
ls *.txt | head -5              # 管道处理匹配结果
```

**核心记忆口诀**：
- **星号万能配，问号单字代**
- **方括号选字符，大括号列选择**  
- **波浪号回家门，转义护特殊**
- **Shell先扩展，命令后执行**