---
title: 1、错误处理
---
## 📚 目录

1. [错误处理基本概念](#1-错误处理基本概念)
2. [退出状态码机制](#2-退出状态码机制)
3. [Shell选项控制](#3-shell选项控制)
4. [信号捕获与处理](#4-信号捕获与处理)
5. [错误输出与日志记录](#5-错误输出与日志记录)
6. [脚本健壮性设计](#6-脚本健壮性设计)
7. [调试技巧与最佳实践](#7-调试技巧与最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 错误处理基本概念


### 1.1 什么是错误处理


**简单理解**：错误处理就像给脚本装上"安全气囊"，当出问题时能自动保护和恢复，而不是直接崩溃。

```
没有错误处理的脚本：
用户输入错误 → 脚本崩溃 → 数据丢失 → 用户懵逼

有错误处理的脚本：
用户输入错误 → 检测到错误 → 提示用户 → 重新输入 → 继续执行
```

### 1.2 为什么需要错误处理


**现实场景对比**：
```
生活场景：开车时遇到红灯
❌ 无处理：直接冲过去（危险）
✅ 有处理：停车等待，安全通过

脚本场景：文件不存在
❌ 无处理：直接读取文件崩溃
✅ 有处理：检查文件，提示并创建
```

### 1.3 错误处理的核心要素


```
错误检测：发现问题
    ↓
错误报告：记录问题
    ↓  
错误处理：解决问题
    ↓
错误恢复：继续执行
```

**三个关键问题**：
- **发生了什么？**（错误检测）
- **为什么发生？**（错误分析）
- **怎么处理？**（错误恢复）

---

## 2. 📊 退出状态码机制


### 2.1 退出状态码的含义


**`$?` 变量**：每个命令执行后都会产生一个退出状态码，存储在特殊变量 `$?` 中。

```bash
# 状态码含义
0     # 成功执行
1-255 # 各种错误情况
```

**通俗解释**：就像考试分数，`0` 分代表完美，其他分数代表各种问题。

### 2.2 常见状态码含义


| 状态码 | **含义** | **典型场景** | **记忆方法** |
|--------|----------|-------------|-------------|
| `0` | ✅ 成功 | `命令正常执行` | `零错误 = 完美` |
| `1` | ❌ 一般错误 | `语法错误、权限问题` | `第一类错误` |
| `2` | ⚠️ 滥用内置命令 | `参数使用错误` | `用错了工具` |
| `126` | 🚫 不可执行 | `文件存在但无执行权限` | `看得见摸不着` |
| `127` | ❓ 命令未找到 | `输入错误的命令` | `找不到北` |
| `130` | 🛑 Ctrl+C中断 | `用户手动中断` | `人为终止` |

### 2.3 检查退出状态的实用方法


```bash
#!/bin/bash

# 方法1：立即检查
cp /etc/passwd /tmp/backup
if [ $? -eq 0 ]; then
    echo "✅ 文件复制成功"
else
    echo "❌ 文件复制失败，状态码：$?"
fi

# 方法2：逻辑运算符（更简洁）
cp /etc/passwd /tmp/backup && echo "✅ 复制成功" || echo "❌ 复制失败"

# 方法3：函数封装检查
check_result() {
    if [ $? -eq 0 ]; then
        echo "✅ $1 执行成功"
    else
        echo "❌ $1 执行失败，错误码：$?"
        exit 1
    fi
}

mkdir /tmp/test
check_result "创建目录"
```

### 2.4 自定义退出状态码


```bash
#!/bin/bash

# 检查参数数量
if [ $# -lt 2 ]; then
    echo "用法：$0 <源文件> <目标文件>"
    exit 1  # 参数错误
fi

# 检查源文件存在性
if [ ! -f "$1" ]; then
    echo "错误：源文件 '$1' 不存在"
    exit 2  # 文件不存在错误
fi

# 检查目标目录权限
target_dir=$(dirname "$2")
if [ ! -w "$target_dir" ]; then
    echo "错误：无法写入目标目录 '$target_dir'"
    exit 3  # 权限错误
fi

# 执行复制
cp "$1" "$2"
if [ $? -eq 0 ]; then
    echo "✅ 文件复制成功"
    exit 0  # 成功
else
    echo "❌ 复制过程中发生错误"
    exit 4  # 复制失败错误
fi
```

---

## 3. ⚙️ Shell选项控制


### 3.1 `set -e` 选项：遇错即停


**作用**：当任何命令返回非零状态码时立即退出脚本。

```bash
#!/bin/bash

# 不使用 set -e
echo "开始执行脚本"
ls /不存在的目录        # 这里会出错，但脚本继续执行
echo "这行还会执行"      # 危险：可能在错误状态下继续
rm -rf /重要文件         # 可能造成灾难

# 使用 set -e  
set -e                  # 开启严格模式
echo "开始执行脚本"
ls /不存在的目录        # 这里出错后脚本立即退出
echo "这行不会执行"      # 安全：错误后立即停止
```

**通俗理解**：就像汽车的安全系统，一检测到危险立即刹车，不让事故扩大。

### 3.2 `set -u` 选项：未定义变量检查


**作用**：引用未定义变量时报错退出。

```bash
#!/bin/bash

# 不使用 set -u
echo "用户名：$username"    # 输出空白，可能引起逻辑错误
rm -rf /$username/temp      # 危险：变成了 rm -rf /temp

# 使用 set -u
set -u                      # 开启未定义变量检查
echo "用户名：$username"    # 立即报错退出，避免危险操作
```

### 3.3 `set -o pipefail` 选项：管道错误检查


**作用**：管道中任何命令失败时，整个管道返回失败状态码。

```bash
#!/bin/bash

# 不使用 pipefail
cat 不存在的文件 | grep "pattern" | wc -l
echo "管道状态码：$?"  # 显示 0（wc 成功），但实际 cat 失败了

# 使用 pipefail
set -o pipefail
cat 不存在的文件 | grep "pattern" | wc -l  
echo "管道状态码：$?"  # 显示非零（cat 失败），正确反映错误
```

### 3.4 组合使用：终极安全模式


```bash
#!/bin/bash

# Shell 脚本安全三件套
set -euo pipefail

# 现在脚本具有以下特性：
# ✅ 任何命令出错立即退出（-e）
# ✅ 使用未定义变量立即报错（-u）  
# ✅ 管道中的错误能被正确检测（-o pipefail）

echo "脚本在安全模式下运行"

# 实际使用示例
backup_file() {
    local source="$1"
    local target="$2"
    
    # 这些检查在安全模式下更加严格
    cp "$source" "$target"
    chmod 644 "$target"
    echo "备份完成：$source -> $target"
}

backup_file "/etc/passwd" "/tmp/passwd.bak"
```

**记忆技巧**：
- **`-e`**：**E**rror 时退出
- **`-u`**：**U**ndefined 变量报错  
- **`-o pipefail`**：管道**失败**时报错

---

## 4. 🎭 信号捕获与处理


### 4.1 什么是信号和trap


**信号**：就像生活中的各种"通知"，比如闹钟、门铃、电话铃声。系统通过信号告诉程序发生了什么事。

**trap**：就像给这些"通知"设置处理程序，决定听到不同信号时该做什么。

```
生活场景：
闹钟响了 → 起床洗漱
门铃响了 → 去开门  
电话响了 → 接听电话

脚本场景：
收到 SIGTERM → 清理临时文件后退出
收到 SIGINT → 询问用户是否确认退出
脚本退出 → 记录日志和清理工作
```

### 4.2 常见信号类型


| 信号 | **触发时机** | **默认行为** | **使用场景** |
|------|-------------|-------------|-------------|
| `SIGINT (2)` | `Ctrl+C` | `终止程序` | `用户中断处理` |
| `SIGTERM (15)` | `kill命令` | `终止程序` | `优雅关闭处理` |  
| `SIGKILL (9)` | `kill -9` | `强制终止` | `无法捕获` |
| `SIGHUP (1)` | `终端关闭` | `终止程序` | `配置重载` |
| `EXIT` | `脚本退出` | `无` | `清理工作` |
| `ERR` | `命令出错` | `无` | `错误处理` |

### 4.3 trap 基本用法


```bash
#!/bin/bash

# 基本语法：trap '处理命令' 信号
trap 'echo "收到中断信号，正在清理..."' SIGINT

# 模拟长时间运行的任务
echo "任务开始，按 Ctrl+C 测试中断处理"
for i in {1..30}; do
    echo "处理第 $i 项任务..."
    sleep 1
done
echo "任务完成"
```

### 4.4 EXIT信号：脚本清理守护者


**EXIT信号**：无论脚本怎么退出（正常、出错、被中断），都会触发，非常适合做清理工作。

```bash
#!/bin/bash

# 临时文件管理
TEMP_FILE="/tmp/script_$$.tmp"
LOG_FILE="/var/log/script.log"

# 设置退出清理
cleanup() {
    echo "清理工作开始..." >&2
    # 删除临时文件
    [ -f "$TEMP_FILE" ] && rm -f "$TEMP_FILE" && echo "临时文件已清理"
    # 记录退出日志
    echo "$(date): 脚本退出" >> "$LOG_FILE"
    echo "清理完成" >&2
}

trap cleanup EXIT

# 创建临时文件
echo "创建临时文件：$TEMP_FILE"
echo "初始数据" > "$TEMP_FILE"

# 模拟工作
echo "开始处理任务..."
sleep 5

# 无论如何退出，cleanup 都会执行
echo "任务完成"
```

### 4.5 ERR信号：错误处理专家


```bash
#!/bin/bash

set -e  # 启用错误退出

# 错误处理函数
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "❌ 错误发生在第 $line_number 行，退出码：$exit_code" >&2
    echo "$(date): 脚本在第 $line_number 行出错" >> /var/log/error.log
    
    # 可以在这里添加错误恢复逻辑
    echo "正在尝试错误恢复..." >&2
}

# 绑定错误处理（$LINENO 获取当前行号）
trap 'handle_error $LINENO' ERR

echo "开始执行任务..."
ls /不存在的目录  # 这里会触发 ERR 信号
echo "这行不会执行"
```

### 4.6 综合信号处理示例


```bash
#!/bin/bash

set -euo pipefail

# 全局变量
SCRIPT_NAME=$(basename "$0")
PID_FILE="/tmp/${SCRIPT_NAME}.pid"
LOG_FILE="/var/log/${SCRIPT_NAME}.log"
INTERRUPTED=false

# 日志函数
log_message() {
    local level="$1"
    shift
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $*" | tee -a "$LOG_FILE"
}

# 清理函数
cleanup() {
    log_message "INFO" "开始清理工作..."
    
    # 清理PID文件
    [ -f "$PID_FILE" ] && rm -f "$PID_FILE"
    
    # 如果是中断退出，记录特殊日志
    if [ "$INTERRUPTED" = true ]; then
        log_message "WARN" "脚本被用户中断"
    else
        log_message "INFO" "脚本正常结束"
    fi
}

# 中断处理
interrupt_handler() {
    log_message "WARN" "收到中断信号，准备退出..."
    INTERRUPTED=true
    exit 130  # Ctrl+C 的标准退出码
}

# 错误处理  
error_handler() {
    local exit_code=$?
    log_message "ERROR" "脚本在第 $1 行发生错误，退出码：$exit_code"
    exit $exit_code
}

# 设置信号处理
trap cleanup EXIT
trap interrupt_handler SIGINT SIGTERM
trap 'error_handler $LINENO' ERR

# 记录启动
echo $$ > "$PID_FILE"
log_message "INFO" "脚本启动，PID：$$"

# 主要工作逻辑
main() {
    log_message "INFO" "开始执行主要任务..."
    
    # 模拟任务
    for i in {1..10}; do
        log_message "DEBUG" "处理任务 $i/10"
        sleep 1
        
        # 模拟偶然错误（演示用）
        if [ $i -eq 7 ]; then
            log_message "ERROR" "模拟错误发生"
            false  # 触发错误
        fi
    done
    
    log_message "INFO" "所有任务完成"
}

# 执行主函数
main "$@"
```

---

## 5. 📝 错误输出与日志记录


### 5.1 标准输出与错误输出


**概念理解**：程序有两个"嘴巴"说话，一个说正常消息，一个说错误消息。

```
标准输出（stdout）：正常信息的"嘴"，文件描述符 1
标准错误（stderr）：错误信息的"嘴"，文件描述符 2

生活比喻：
stdout = 正常说话的嘴
stderr = 紧急警报的嘴
```

### 5.2 错误输出重定向技巧


```bash
#!/bin/bash

# 基本重定向操作
echo "正常消息"                    # 输出到 stdout
echo "错误消息" >&2               # 输出到 stderr

# 重定向示例
ls /存在的目录 > output.log 2> error.log    # 分别重定向
ls /不存在的目录 > output.log 2>&1          # 错误输出重定向到标准输出
ls /目录 &> all.log                         # 所有输出到同一文件

# 实用函数
info() {
    echo "ℹ️  $*" 
}

warn() {
    echo "⚠️  $*" >&2
}

error() {
    echo "❌ $*" >&2
}

# 使用示例
info "程序开始运行"
warn "这是一个警告信息"  
error "发生了严重错误"
```

### 5.3 分级日志记录系统


```bash
#!/bin/bash

# 日志配置
LOG_FILE="/var/log/$(basename "$0" .sh).log"
LOG_LEVEL="${LOG_LEVEL:-INFO}"  # 默认INFO级别

# 日志级别定义（数字越小级别越高）
declare -A LOG_LEVELS=(
    ["ERROR"]=1
    ["WARN"]=2  
    ["INFO"]=3
    ["DEBUG"]=4
)

# 核心日志函数
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 检查日志级别
    if [ ${LOG_LEVELS[$level]} -le ${LOG_LEVELS[$LOG_LEVEL]} ]; then
        # 根据级别选择输出方式
        case $level in
            ERROR|WARN)
                echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" >&2
                ;;
            *)  
                echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
                ;;
        esac
    fi
}

# 便捷函数
log_error() { log "ERROR" "$@"; }
log_warn()  { log "WARN"  "$@"; }  
log_info()  { log "INFO"  "$@"; }
log_debug() { log "DEBUG" "$@"; }

# 使用示例
log_info "应用程序启动"
log_debug "调试信息：变量值 x=$x"  
log_warn "配置文件使用默认值"
log_error "数据库连接失败"
```

### 5.4 结构化日志记录


```bash
#!/bin/bash

# 结构化日志函数
structured_log() {
    local level="$1"
    local event="$2"  
    local message="$3"
    local extra_data="${4:-}"
    
    local log_entry=$(cat << EOF
{
    "timestamp": "$(date -Iseconds)",
    "level": "$level",
    "event": "$event", 
    "message": "$message",
    "pid": $$,
    "script": "$(basename "$0")",
    "extra": $extra_data
}
EOF
)
    
    echo "$log_entry" >> "$LOG_FILE"
    
    # 同时输出人类可读格式
    case $level in
        ERROR) echo "❌ [$event] $message" >&2 ;;
        WARN)  echo "⚠️  [$event] $message" >&2 ;;
        INFO)  echo "ℹ️  [$event] $message" ;;
    esac
}

# 使用示例
structured_log "INFO" "APP_START" "应用程序启动" '{"version":"1.0"}'
structured_log "ERROR" "DB_CONNECT" "数据库连接失败" '{"host":"localhost","port":3306}'
```

### 5.5 日志轮转和管理


```bash
#!/bin/bash

LOG_FILE="/var/log/myapp.log"
MAX_LOG_SIZE=10485760  # 10MB

# 检查和轮转日志
rotate_log_if_needed() {
    if [ -f "$LOG_FILE" ] && [ $(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE") -gt $MAX_LOG_SIZE ]; then
        local backup_file="${LOG_FILE}.$(date +%Y%m%d_%H%M%S)"
        mv "$LOG_FILE" "$backup_file"
        touch "$LOG_FILE"
        echo "日志文件已轮转：$backup_file"
        
        # 保留最近5个日志文件
        ls -t "${LOG_FILE}".* | tail -n +6 | xargs rm -f
    fi
}

# 每次记录日志前检查
log_with_rotation() {
    rotate_log_if_needed
    echo "$(date '+%Y-%m-%d %H:%M:%S') $*" >> "$LOG_FILE"
}
```

---

## 6. 🛡️ 脚本健壮性设计


### 6.1 多层级错误处理策略


```
第1层：预防性检查（事前）
第2层：运行时监控（事中）  
第3层：异常恢复机制（事后）
第4层：失败通知机制（善后）
```

### 6.2 预防性检查清单


```bash
#!/bin/bash

# 第1层：预防性检查函数
pre_check() {
    local errors=0
    
    echo "🔍 开始预检查..."
    
    # 检查必要参数
    if [ $# -lt 1 ]; then
        log_error "缺少必要参数"
        ((errors++))
    fi
    
    # 检查依赖命令
    for cmd in curl jq awk; do
        if ! command -v $cmd >/dev/null 2>&1; then
            log_error "缺少依赖命令: $cmd"
            ((errors++))
        fi
    done
    
    # 检查文件权限
    for file in "/etc/config.conf" "/var/log/app.log"; do
        if [ ! -r "$file" ]; then
            log_error "无法读取文件: $file"
            ((errors++))
        fi
    done
    
    # 检查磁盘空间
    local free_space=$(df /tmp | awk 'NR==2 {print $4}')
    if [ $free_space -lt 1048576 ]; then  # 1GB
        log_error "磁盘空间不足"
        ((errors++))
    fi
    
    # 检查网络连接
    if ! ping -c 1 google.com >/dev/null 2>&1; then
        log_warn "网络连接检查失败，部分功能可能不可用"
    fi
    
    if [ $errors -gt 0 ]; then
        log_error "预检查发现 $errors 个问题，脚本退出"
        exit 1
    fi
    
    log_info "✅ 预检查通过"
}
```

### 6.3 运行时监控机制


```bash
#!/bin/bash

# 第2层：运行时监控
monitor_execution() {
    local start_time=$(date +%s)
    local max_execution_time=300  # 5分钟超时
    
    # 启动监控子进程
    (
        while true; do
            sleep 30
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            
            if [ $elapsed -gt $max_execution_time ]; then
                log_error "脚本执行超时，强制终止"
                kill -TERM $$ 2>/dev/null || kill -KILL $$
                break
            fi
            
            log_debug "脚本已运行 ${elapsed} 秒"
        done
    ) &
    
    local monitor_pid=$!
    
    # 主程序结束时清理监控进程
    trap "kill $monitor_pid 2>/dev/null || true" EXIT
    
    return 0
}
```

### 6.4 异常恢复机制


```bash
#!/bin/bash

# 第3层：异常恢复机制
retry_with_backoff() {
    local max_attempts="$1"
    local delay="$2"
    local command="$3"
    
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        log_info "尝试执行（第 $attempt/$max_attempts 次）: $command"
        
        if eval "$command"; then
            log_info "✅ 命令执行成功"
            return 0
        else
            local exit_code=$?
            log_warn "❌ 命令执行失败，退出码: $exit_code"
            
            if [ $attempt -lt $max_attempts ]; then
                local wait_time=$((delay * attempt))
                log_info "等待 $wait_time 秒后重试..."
                sleep $wait_time
            fi
        fi
        
        ((attempt++))
    done
    
    log_error "所有重试都失败了"
    return 1
}

# 智能恢复示例
safe_download() {
    local url="$1"
    local output="$2"
    local temp_file="${output}.tmp"
    
    # 第1次尝试：curl
    if retry_with_backoff 3 2 "curl -sSL '$url' -o '$temp_file'"; then
        mv "$temp_file" "$output"
        return 0
    fi
    
    # 第2次尝试：wget（备用方案）
    log_info "尝试备用下载方法..."
    if retry_with_backoff 2 3 "wget -q '$url' -O '$temp_file'"; then
        mv "$temp_file" "$output"  
        return 0
    fi
    
    # 清理失败的临时文件
    rm -f "$temp_file"
    return 1
}
```

### 6.5 失败通知机制


```bash
#!/bin/bash

# 第4层：失败通知机制
notify_failure() {
    local error_message="$1"
    local script_name=$(basename "$0")
    local hostname=$(hostname)
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 构建通知消息
    local notification=$(cat << EOF
🚨 脚本执行失败通知

脚本: $script_name
主机: $hostname  
时间: $timestamp
错误: $error_message

请及时检查和处理。
EOF
)
    
    # 方式1：邮件通知
    if command -v mail >/dev/null 2>&1; then
        echo "$notification" | mail -s "[$hostname] 脚本执行失败" admin@company.com
    fi
    
    # 方式2：企业微信/钉钉通知
    if [ -n "${WEBHOOK_URL:-}" ]; then
        curl -s -X POST "$WEBHOOK_URL" \
            -H 'Content-Type: application/json' \
            -d "{\"text\":\"$notification\"}"
    fi
    
    # 方式3：系统日志
    logger -t "$script_name" "CRITICAL: $error_message"
    
    # 方式4：写入故障文件
    echo "$notification" >> "/var/log/script_failures.log"
}

# 全局错误处理器
global_error_handler() {
    local exit_code=$?
    local line_number=$1
    local error_message="脚本在第 $line_number 行异常退出，退出码: $exit_code"
    
    log_error "$error_message"
    notify_failure "$error_message"
    
    exit $exit_code
}

trap 'global_error_handler $LINENO' ERR
```

---

## 7. 🔧 调试技巧与最佳实践


### 7.1 调试模式开关


```bash
#!/bin/bash

# 调试开关
DEBUG="${DEBUG:-false}"
VERBOSE="${VERBOSE:-false}"

# 调试函数
debug() {
    [ "$DEBUG" = "true" ] && echo "🐛 DEBUG: $*" >&2
}

verbose() {
    [ "$VERBOSE" = "true" ] && echo "📝 VERBOSE: $*" >&2
}

# 使用方法
# DEBUG=true ./script.sh
# VERBOSE=true ./script.sh
```

### 7.2 Shell内置调试选项


```bash
#!/bin/bash

# 脚本开头添加调试选项
set -x    # 显示每条命令的执行（xtrace）
set +x    # 关闭命令显示

# 更精细的控制
if [ "${DEBUG:-}" = "true" ]; then
    set -x
fi

# 局部调试
debug_section() {
    set -x
    echo "这部分会显示详细执行过程"
    ls -la /tmp
    set +x
}
```

### 7.3 性能监控和分析


```bash
#!/bin/bash

# 执行时间统计
time_command() {
    local start=$(date +%s.%N)
    "$@"
    local exit_code=$?
    local end=$(date +%s.%N)
    local duration=$(echo "$end - $start" | bc)
    
    log_info "命令 '$*' 执行时间: ${duration}s"
    return $exit_code
}

# 内存使用监控
monitor_memory() {
    local pid=$$
    while kill -0 $pid 2>/dev/null; do
        local mem=$(ps -o pid,rss --pid=$pid --no-headers | awk '{print $2}')
        log_debug "内存使用: ${mem}KB"
        sleep 10
    done &
    echo $!  # 返回监控进程PID
}

# 使用示例
monitor_pid=$(monitor_memory)
trap "kill $monitor_pid 2>/dev/null || true" EXIT

time_command find /var/log -name "*.log" -type f
```

### 7.4 调试最佳实践模板


```bash
#!/bin/bash

# 完整的调试友好脚本模板
set -euo pipefail

# 配置和变量
SCRIPT_NAME=$(basename "$0")
SCRIPT_DIR=$(dirname "$0")
LOG_LEVEL="${LOG_LEVEL:-INFO}"
DEBUG="${DEBUG:-false}"

# 调试模式
if [ "$DEBUG" = "true" ]; then
    set -x
    LOG_LEVEL="DEBUG"
fi

# 帮助信息
show_help() {
    cat << EOF
用法: $SCRIPT_NAME [选项] 参数

选项:
    -h, --help      显示此帮助信息
    -v, --verbose   详细输出
    -d, --debug     调试模式
    --dry-run       试运行（不实际执行）

示例:
    DEBUG=true $SCRIPT_NAME        # 调试模式运行
    $SCRIPT_NAME --dry-run         # 试运行模式
    
EOF
}

# 参数解析
DRY_RUN=false
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=true
            LOG_LEVEL="DEBUG"
            shift
            ;;
        -d|--debug)
            DEBUG=true
            set -x
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# 试运行模式
execute() {
    if [ "$DRY_RUN" = "true" ]; then
        echo "🔍 DRY-RUN: $*"
    else
        "$@"
    fi
}

# 主程序逻辑
main() {
    log_info "脚本开始执行"
    log_debug "调试模式: $DEBUG, 试运行: $DRY_RUN"
    
    # 实际工作
    execute mkdir -p /tmp/test
    execute echo "Hello World" > /tmp/test/file.txt
    
    log_info "脚本执行完成"
}

# 执行主程序
main "$@"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 退出状态码：$? 变量，0表示成功，非零表示各种错误
🔸 Shell选项：set -euo pipefail 构成脚本安全模式
🔸 信号捕获：trap命令处理各种系统信号和脚本事件
🔸 错误输出：>&2 重定向错误信息到stderr
🔸 日志记录：分级日志系统便于问题定位
🔸 健壮设计：多层级错误处理和自动恢复机制
```

### 8.2 关键理解要点


**🔹 错误处理的核心思想**
```
预防胜于治疗：
- 事前检查：参数、依赖、权限、资源
- 事中监控：执行状态、时间、资源使用
- 事后恢复：重试机制、备用方案
- 善后处理：清理、通知、记录
```

**🔹 信号处理的实用价值**
```
EXIT信号：最重要，任何退出都触发
- 清理临时文件
- 记录结束日志  
- 释放资源锁定

ERR信号：配合set -e使用
- 记录错误位置
- 执行错误恢复
- 发送失败通知
```

**🔹 日志记录的分层思想**
```
ERROR：系统错误，需要立即关注
WARN：警告信息，需要留意
INFO：一般信息，记录关键步骤
DEBUG：调试信息，开发时使用
```

### 8.3 实际应用价值


**💼 生产环境脚本必备**
- **自动化运维脚本**：服务部署、数据备份、系统维护
- **定时任务脚本**：日志清理、数据同步、健康检查
- **部署发布脚本**：应用更新、配置变更、回滚操作

**🛠️ 开发调试利器**
- **快速问题定位**：详细日志和错误信息
- **脚本质量保证**：多重检查和验证机制
- **用户体验提升**：友好的错误提示和帮助信息

### 8.4 记忆要点和实践建议


**🎯 核心记忆公式**
```bash
# 脚本安全模式
set -euo pipefail

# 清理机制
trap cleanup EXIT

# 错误处理
trap 'handle_error $LINENO' ERR

# 日志记录
log_error "错误信息" >&2
```

**📝 最佳实践清单**
- ✅ **总是使用** `set -euo pipefail` 开启安全模式
- ✅ **必须设置** EXIT trap 进行清理工作  
- ✅ **区分输出**：正常信息到stdout，错误信息到stderr
- ✅ **记录日志**：关键操作和错误都要记录
- ✅ **参数检查**：脚本开始时检查所有必要条件
- ✅ **重试机制**：网络操作和关键命令要有重试
- ✅ **用户友好**：提供清晰的错误信息和帮助

**🚫 常见误区**
- ❌ 忽略命令的返回状态码
- ❌ 错误信息输出到stdout而非stderr
- ❌ 没有清理临时文件和资源
- ❌ 缺少必要的参数和环境检查
- ❌ 硬编码路径和配置信息
- ❌ 没有提供调试和试运行选项

**核心记忆**：
- Shell错误处理是脚本稳定运行的保障
- 好的错误处理让脚本更专业更可靠  
- 预防检查、监控执行、异常恢复、失败通知四个层次
- 调试友好的脚本更容易维护和改进