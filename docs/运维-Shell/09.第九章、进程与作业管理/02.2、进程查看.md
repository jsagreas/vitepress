---
title: 2、进程查看
---
## 📚 目录

1. [进程概念基础](#1-进程概念基础)
2. [ps命令详解](#2-ps命令详解)
3. [top实时监控](#3-top实时监控)
4. [进程树与关系查看](#4-进程树与关系查看)
5. [进程搜索与过滤](#5-进程搜索与过滤)
6. [文件与系统调用跟踪](#6-文件与系统调用跟踪)
7. [进程资源分析](#7-进程资源分析)
8. [实战应用技巧](#8-实战应用技巧)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 进程概念基础


### 1.1 什么是进程

> **💡 核心理解**  
> 进程就像是正在运行的程序。想象一下：程序是菜谱，进程就是按照菜谱正在做菜的过程

**进程的本质**：
- **程序**：存在硬盘上的静态文件（比如 `/bin/ls`）
- **进程**：程序加载到内存中运行的动态实例
- **一个程序**：可以同时运行多个进程（比如开多个浏览器窗口）

### 1.2 进程的重要属性


**进程标识**：
```
PID（进程ID）：每个进程的唯一编号，就像身份证号
PPID（父进程ID）：谁启动了这个进程
UID（用户ID）：进程属于哪个用户
```

**进程状态**：
```
R (Running)：正在运行或等待运行 → 活跃状态
S (Sleeping)：可中断睡眠，等待事件 → 休眠状态  
D (Disk sleep)：不可中断睡眠，通常等待IO → 深度休眠
Z (Zombie)：僵尸进程，已死但未清理 → 需要关注
T (Stopped)：被信号停止 → 暂停状态
```

> **⚠️ 常见误区**  
> 很多人以为进程状态S表示有问题，其实大部分时候进程都是S状态，这是正常的！

---

## 2. 🔎 ps命令详解


### 2.1 ps基本用法


**ps命令**就像给所有进程拍个"集体照"，显示某个时刻的进程状态。

**最常用的三种格式**：

#### 📊 BSD风格：`ps aux`

```bash
ps aux
```

**输出解释**：
```
USER    PID  %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
root      1   0.0  0.1  19356  1234 ?     Ss   09:00   0:01 /sbin/init
john   1234   2.1  5.2 123456 12345 pts/0 S+   10:30   0:05 firefox
```

**字段含义速记**：
- **USER**：谁的进程（用户名）
- **PID**：进程身份证号
- **%CPU**：CPU使用百分比
- **%MEM**：内存使用百分比  
- **VSZ**：虚拟内存大小（KB）
- **RSS**：实际物理内存（KB）
- **TTY**：终端类型（？表示后台进程）
- **STAT**：进程状态（S=睡眠，R=运行）
- **COMMAND**：完整命令

#### 📋 System V风格：`ps -ef`

```bash
ps -ef
```

**输出特点**：
- 显示**完整的命令行参数**
- 显示**父子进程关系**（PPID列）
- 适合查看进程**启动参数**

#### 🎯 详细信息：`ps -ely`

```bash
ps -ely
```

**特殊用途**：显示更多系统级信息，包括优先级、Nice值等

### 2.2 ps实用选项组合


**常用过滤技巧**：

```bash
# 查看特定用户的进程
ps -u john

# 查看不包含终端的进程（后台服务）
ps -ax

# 显示进程的环境变量
ps -eww

# 按CPU使用率排序
ps aux --sort=-%cpu

# 按内存使用率排序  
ps aux --sort=-%mem
```

**📌 实用技巧**：
- 想看**谁在占用CPU**？用 `ps aux --sort=-%cpu | head -10`
- 想看**内存大户**？用 `ps aux --sort=-%mem | head -10`
- 想看**某个程序的所有进程**？用 `ps aux | grep 程序名`

---

## 3. ⚡ top实时监控


### 3.1 top基本使用


**top**就像是进程的"实时仪表盘"，持续更新显示系统状态。

```bash
top
```

**界面布局解读**：

```
系统概况区域：
┌─────────────────────────────────────┐
│ top - 14:30:15 up 5 days, 2:15...  │ ← 当前时间，运行时间
│ Tasks: 285 total, 2 running...     │ ← 进程统计
│ %Cpu(s): 12.5 us, 3.2 sy...       │ ← CPU使用情况  
│ MiB Mem: 8192 total, 2048 free...  │ ← 内存使用情况
└─────────────────────────────────────┘

进程详情区域：
  PID USER   PR  NI    VIRT    RES  %CPU %MEM     TIME+ COMMAND
 1234 john   20   0  123456  12345  25.3  5.2   0:15.67 firefox
 5678 root   20   0   67890   6789   8.7  2.1   0:05.23 nginx
```

### 3.2 top核心指标解读


**📊 CPU使用率详解**：
```
%Cpu(s): 12.5 us, 3.2 sy, 0.0 ni, 84.1 id, 0.2 wa

us (user)：用户程序占用 → 应用软件在工作
sy (system)：系统内核占用 → 操作系统在忙
ni (nice)：低优先级程序 → 后台任务
id (idle)：空闲时间 → 系统很轻松
wa (wait)：等待IO → 磁盘/网络较慢
```

**💾 内存使用详解**：
```
MiB Mem: 8192 total, 2048 free, 3072 used, 3072 buff/cache

total：总内存
free：完全空闲内存  
used：程序使用内存
buff/cache：系统缓存（可释放给程序用）

实际可用 = free + buff/cache
```

### 3.3 top交互式操作


**实时操作技巧**：
```
在top运行时按键：

h：显示帮助
q：退出top
k：杀死进程（输入PID）
r：改变进程优先级
M：按内存使用排序
P：按CPU使用排序（默认）
T：按运行时间排序
u：只显示指定用户进程
1：显示每个CPU核心的使用情况
```

**📈 查看多核CPU**：
```bash
top然后按1键
```
显示每个CPU核心的单独使用率，帮助发现是否有程序只用单核。

### 3.4 htop增强版


**htop相比top的优势**：
- **彩色显示**：不同颜色区分不同信息
- **鼠标支持**：可以用鼠标点击操作
- **树状显示**：F5显示进程父子关系
- **更直观**：进度条显示CPU和内存使用

```bash
htop
```

> **💡 安装htop**  
> Ubuntu/Debian: `sudo apt install htop`  
> CentOS/RHEL: `sudo yum install htop`

---

## 4. 🌳 进程树与关系查看


### 4.1 pstree进程树


**pstree**把进程的父子关系画成一棵树，就像家族族谱一样。

```bash
# 显示所有进程的树状关系
pstree

# 显示指定用户的进程树
pstree john

# 显示进程ID
pstree -p

# 显示完整命令
pstree -a
```

**典型输出示例**：
```
systemd(1)─┬─NetworkManager(756)─┬─{NetworkManager}(832)
           │                     └─{NetworkManager}(847)
           ├─sshd(1234)───sshd(5678)───bash(5679)───vim(5680)
           ├─nginx(2345)─┬─nginx(2346)
           │             ├─nginx(2347)
           │             └─nginx(2348)
           └─cron(3456)
```

**树状图解读**：
- `systemd(1)` 是所有进程的祖先（PID=1）
- `sshd(1234)` 启动了 `sshd(5678)`，形成父子关系
- `nginx` 主进程启动了3个工作进程
- `{}` 表示线程，不是独立进程

### 4.2 查看进程父子关系


**查看特定进程的父子关系**：
```bash
# 查看进程5678的所有子进程
pstree -p 5678

# 查看进程5678的父进程链
pstree -p -s 5678
```

**实际应用场景**：
- **调试程序**：看程序启动了哪些子进程
- **系统分析**：理解服务的进程结构
- **资源管理**：一次性杀死进程组

---

## 5. 🎯 进程搜索与过滤


### 5.1 pgrep进程搜索


**pgrep**是专门用来搜索进程的命令，比 `ps | grep` 更高效。

```bash
# 根据进程名搜索
pgrep firefox

# 根据用户搜索  
pgrep -u john

# 根据完整命令搜索
pgrep -f "python script.py"

# 显示进程名（不只是PID）
pgrep -l nginx

# 计数匹配的进程
pgrep -c firefox
```

### 5.2 进程搜索实用技巧


**组合搜索条件**：
```bash
# 搜索用户john运行的python进程
pgrep -u john python

# 搜索包含特定参数的进程
pgrep -f "nginx.*worker"

# 排除某些进程
pgrep -v -f "grep"
```

**与其他命令结合**：
```bash
# 查看匹配进程的详细信息
ps -p $(pgrep firefox)

# 监控特定进程
top -p $(pgrep -d, nginx)

# 一次性查看某类进程的资源使用
ps -o pid,comm,%cpu,%mem -p $(pgrep python)
```

### 5.3 进程过滤最佳实践


**常用过滤模式**：

```bash
# 查看占用CPU最多的10个进程
ps aux --sort=-%cpu | head -11

# 查看占用内存最多的10个进程  
ps aux --sort=-%mem | head -11

# 查看特定端口的进程
ss -tlnp | grep :80 | awk '{print $7}' | cut -d: -f2

# 查看僵尸进程
ps aux | awk '$8 ~ /^Z/ { print $0 }'

# 查看长时间运行的进程
ps -eo pid,etime,comm --sort=-etime | head -10
```

---

## 6. 🔧 文件与系统调用跟踪


### 6.1 lsof查看打开文件


**lsof**（list open files）显示进程打开了哪些文件，在Linux中"一切皆文件"。

```bash
# 查看所有打开的文件
lsof

# 查看特定进程打开的文件
lsof -p 1234

# 查看特定文件被谁打开
lsof /var/log/syslog

# 查看特定用户打开的文件
lsof -u john

# 查看网络连接
lsof -i

# 查看特定端口
lsof -i :80
```

**📊 lsof输出解读**：
```
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
firefox  1234 john    5r   REG    8,1   123456  789012 /home/john/file.txt
nginx    5678 root    6u  IPv4   12345      0t0     TCP *:80 (LISTEN)
```

**字段含义**：
- **FD**：文件描述符（0=stdin, 1=stdout, 2=stderr）
- **TYPE**：文件类型（REG=普通文件，IPv4=网络）
- **r/w/u**：读/写/读写模式

### 6.2 系统调用跟踪


**strace跟踪系统调用**：
```bash
# 跟踪程序的所有系统调用
strace ls /home

# 跟踪正在运行的进程
strace -p 1234

# 只跟踪文件操作
strace -e file ls

# 只跟踪网络操作
strace -e network curl google.com

# 统计系统调用
strace -c ls /home
```

**ltrace跟踪库函数调用**：
```bash
# 跟踪程序的库函数调用
ltrace ls /home

# 跟踪特定库函数
ltrace -e malloc,free ./my_program
```

> **💡 实用场景**  
> - **调试程序**：看程序在读写哪些文件
> - **性能分析**：找出程序慢在哪里
> - **安全审计**：监控程序的行为
> - **学习系统**：理解程序如何与系统交互

---

## 7. 📈 进程资源分析


### 7.1 CPU使用分析


**查看CPU密集型进程**：
```bash
# 按CPU使用率排序
ps aux --sort=-%cpu | head -10

# 持续监控CPU使用
top -o %CPU

# 查看CPU使用历史（需要sar工具）
sar -u 1 10
```

**📊 CPU使用率解读**：
- **25%以下**：轻度使用，正常情况
- **25-50%**：中度使用，需要关注
- **50-80%**：高度使用，可能影响性能
- **80%以上**：系统负载很高，需要优化

### 7.2 内存使用分析


**内存分析命令**：
```bash
# 按内存使用排序
ps aux --sort=-%mem | head -10

# 查看系统内存概况
free -h

# 查看详细内存信息
cat /proc/meminfo

# 查看每个进程的内存映射
pmap 1234
```

**💾 内存指标对比**：

| 指标 | VSZ | RSS | 含义 |
|------|-----|-----|------|
| **VSZ** | 虚拟内存 | 123456KB | 进程申请的总内存空间 |
| **RSS** | 物理内存 | 45678KB | 实际占用的物理内存 |
| **关系** | VSZ ≥ RSS | 总是成立 | 虚拟内存包含未实际使用的部分 |

### 7.3 IO使用分析


**IO监控工具**：
```bash
# 实时查看IO使用情况
iotop

# 查看磁盘IO统计
iostat 1 10

# 查看进程IO信息
cat /proc/1234/io
```

**🔍 IO问题诊断**：
- **高wa值**：系统等待IO时间长，磁盘可能是瓶颈
- **D状态进程**：进程在等待IO，可能磁盘故障
- **大量读写**：检查是否有程序异常读写文件

---

## 8. ⚡ 实战应用技巧


### 8.1 系统性能排查


**性能问题诊断流程**：

```
系统运行缓慢排查：
第1步：top 查看整体负载
     ↓
第2步：ps aux --sort=-%cpu 找CPU大户
     ↓  
第3步：ps aux --sort=-%mem 找内存大户
     ↓
第4步：iotop 查看IO情况  
     ↓
第5步：lsof -i 查看网络连接
```

**一键性能检查脚本思路**：
```bash
echo "=== CPU负载 ==="
uptime

echo "=== 内存使用 ==="
free -h

echo "=== CPU占用前5 ==="
ps aux --sort=-%cpu | head -6

echo "=== 内存占用前5 ==="  
ps aux --sort=-%mem | head -6
```

### 8.2 进程管理技巧


**批量进程操作**：
```bash
# 杀死所有firefox进程
pkill firefox

# 杀死用户john的所有进程
pkill -u john

# 优雅停止nginx（发送TERM信号）
pkill -TERM nginx

# 强制杀死僵尸进程的父进程
ps aux | awk '$8 ~ /^Z/ {print $3}' | xargs kill
```

**进程监控脚本思路**：
```bash
# 监控特定进程是否存在
if pgrep nginx > /dev/null; then
    echo "nginx正在运行"
else
    echo "nginx已停止"
    # 可以在这里重启服务
fi
```

### 8.3 日常维护检查


**📋 系统巡检清单**：
- [ ] 检查CPU使用率是否正常
- [ ] 检查内存使用率是否过高
- [ ] 检查是否有僵尸进程
- [ ] 检查关键服务是否运行
- [ ] 检查是否有异常的网络连接

**自动化检查命令**：
```bash
# 检查僵尸进程
ps aux | awk '$8 ~ /^Z/ {count++} END {print "僵尸进程数量:", count+0}'

# 检查高CPU使用的进程
ps aux --sort=-%cpu | awk 'NR==2 {if($3>80) print "警告: 进程"$11"CPU使用率过高:"$3"%"}'

# 检查高内存使用的进程  
ps aux --sort=-%mem | awk 'NR==2 {if($4>50) print "警告: 进程"$11"内存使用率过高:"$4"%"}'
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的命令


```
🔸 ps aux: 查看所有进程快照，最常用的进程查看命令
🔸 top: 实时监控系统和进程状态，系统性能的第一选择
🔸 pstree: 显示进程父子关系，理解进程结构
🔸 pgrep: 搜索进程，比grep更精确高效
🔸 lsof: 查看文件打开情况，诊断文件和网络问题
```

### 9.2 关键理解要点


**🔹 进程状态的含义**：
- **S状态**：大多数时候是正常的，表示进程在等待
- **D状态**：需要关注，可能是IO问题
- **Z状态**：僵尸进程，需要清理
- **R状态**：正在运行，CPU使用率通常较高

**🔹 内存指标的区别**：
- **VSZ**：进程申请的虚拟内存总量
- **RSS**：实际占用的物理内存
- **系统可用内存** = free + buff/cache

**🔹 CPU使用率分析**：
- **us高**：用户程序繁忙，检查应用性能
- **sy高**：系统调用频繁，可能有IO瓶颈
- **wa高**：IO等待严重，检查磁盘性能

### 9.3 实际应用价值


**🎯 系统运维**：
- **性能监控**：及时发现系统瓶颈
- **故障排查**：快速定位问题进程
- **资源规划**：了解系统资源使用情况
- **安全监控**：发现异常进程和连接

**🔧 开发调试**：
- **程序调试**：跟踪程序行为和资源使用
- **性能优化**：找出程序的性能瓶颈
- **依赖分析**：理解程序的系统调用和文件访问

### 9.4 学习建议


> **💪 动手实践**  
> 1. 每天用`top`查看系统状态
> 2. 用`ps aux`了解系统中运行的程序
> 3. 用`pstree`理解进程的父子关系
> 4. 遇到问题时用`lsof`查看文件打开情况

> **🧠 记忆技巧**  
> - **ps aux**：Process Status All Users eXtended
> - **top**：Table Of Processes  
> - **lsof**：List Open Files
> - **pgrep**：Process Global Regular Expression Print

**核心记忆口诀**：
- 看进程用ps aux，实时监控就用top
- 找进程用pgrep好，进程树用pstree描
- 文件打开lsof查，系统调用strace跟踪
- 性能分析要综合，CPU内存IO一起看