---
title: 2、资源监控
---
## 📚 目录

1. [磁盘监控基础](#1-磁盘监控基础)
2. [内存与虚拟内存监控](#2-内存与虚拟内存监控)
3. [CPU与系统负载分析](#3-CPU与系统负载分析)
4. [I/O性能监控](#4-I/O性能监控)
5. [系统活动综合报告](#5-系统活动综合报告)
6. [设备信息查看](#6-设备信息查看)
7. [实战监控脚本](#7-实战监控脚本)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💽 磁盘监控基础


### 1.1 df命令 - 磁盘使用情况


**🔸 核心概念**
`df`命令就像是查看你电脑硬盘容量的工具，告诉你每个分区用了多少空间，还剩多少。

**💡 基本用法**
```bash
# 最常用的人性化显示
df -h

# 示例输出：
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        20G   15G  4.2G  78% /
/dev/sda2       100G   45G   50G  48% /home
tmpfs           2.0G     0  2.0G   0% /dev/shm
```

**📊 参数详解**

| 参数 | **含义** | **使用场景** | **示例** |
|------|---------|-------------|----------|
| `-h` | `人性化显示(KB/MB/GB)` | `日常查看，最常用` | `df -h` |
| `-i` | `显示inode使用情况` | `文件数量过多时诊断` | `df -i` |
| `-T` | `显示文件系统类型` | `了解分区格式` | `df -hT` |

**⚠️ inode监控的重要性**
```bash
# 查看inode使用情况
df -i

# 输出示例：
Filesystem      Inodes   IUsed   IFree IUse% Mounted on
/dev/sda1      1310720  156789 1153931   12% /
/dev/sda2      6553600  234567 6319033    4% /home
```

> **💡 什么是inode？**
> inode就像文件的"身份证"，每个文件都需要一个。即使磁盘空间还有很多，但inode用完了也无法创建新文件！

**🎯 实用技巧**
```bash
# 只显示本地文件系统（排除网络挂载）
df -hlT --local

# 显示特定目录所在的文件系统
df -h /var/log

# 按使用率排序（结合其他命令）
df -h | sort -k5 -nr
```

### 1.2 du命令 - 目录大小统计


**🔸 核心概念**
`du`命令是用来查看文件夹占用多少空间的工具，就像给文件夹"称重"。

**💡 常用组合**
```bash
# 查看当前目录总大小
du -sh

# 查看子目录大小（一层）
du -sh */

# 查看指定深度
du -h --max-depth=2 /var/log
```

**📈 大小排序技巧**
```bash
# 找出最大的目录（前10个）
du -sh */ | sort -hr | head -10

# 找出超过1GB的目录
du -sh */ | awk '$1 ~ /G/ {print}'
```

**🔍 深度控制对比**
```
目录结构：
project/
├── src/          (500MB)
├── build/        (2GB)
├── node_modules/ (800MB)
└── docs/         (50MB)

du -sh project/           # 3.3GB (总计)
du -sh project/*/         # 显示一级子目录大小
du -h --max-depth=1 project/  # 同上，但格式更规范
```

---

## 2. 🧠 内存与虚拟内存监控


### 2.1 free命令 - 内存使用状况


**🔸 核心概念**
`free`命令就像查看电脑内存条的使用情况，告诉你有多少内存在用，多少空闲。

**💡 基本使用**
```bash
# 人性化显示内存
free -h

# 示例输出：
              total        used        free      shared  buff/cache   available
Mem:           7.8G        2.1G        1.2G        234M        4.5G        5.2G
Swap:          2.0G          0B        2.0G
```

**📊 内存状态解读**

```
内存使用情况图示：
┌─────────────────── 物理内存总量 ──────────────────┐
│ 已使用 │  缓存/缓冲  │      真正空闲     │
└─────────┴───────────┴──────────────────┘
   2.1G      4.5G           1.2G

实际可用内存 = 空闲 + 缓存 = 5.2G
```

**🎯 参数对比**

| 参数 | **显示效果** | **使用场景** |
|------|-------------|-------------|
| `-h` | `单位自适应(GB/MB)` | `日常查看` |
| `-m` | `以MB为单位` | `脚本计算` |
| `-g` | `以GB为单位` | `大内存服务器` |
| `-s 5` | `每5秒更新一次` | `实时监控` |

### 2.2 vmstat命令 - 虚拟内存统计


**🔸 核心概念**
`vmstat`是系统性能的"体检报告"，显示CPU、内存、IO等综合状况。

**💡 基本语法**
```bash
# 每2秒显示一次，共显示5次
vmstat 2 5

# 示例输出：
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1245632  86412 4524836    0    0    12    28  156  298  5  2 92  1  0
 0  0      0 1245488  86412 4524836    0    0     0     0  142  276  3  1 96  0  0
```

**📈 字段含义详解**

**进程状态 (procs)**：
- `r`: 运行队列长度（等待CPU的进程数）
- `b`: 等待IO的进程数

**内存状态 (memory)**：
- `swpd`: 虚拟内存使用量
- `free`: 空闲内存
- `buff`: 用作缓冲的内存
- `cache`: 用作缓存的内存

**交换分区 (swap)**：
- `si`: 每秒从磁盘交换到内存的数据量
- `so`: 每秒从内存交换到磁盘的数据量

> **⚠️ 性能警告信号**
> - `r > CPU核数` → CPU负载过高
> - `si/so > 0` → 内存不足，开始使用交换分区
> - `wa > 20` → IO等待时间过长

---

## 3. ⚡ CPU与系统负载分析


### 3.1 系统负载的理解


**🔸 什么是系统负载？**
系统负载就像高速公路的车流量：
- 负载1.0 = 单核CPU完全被占用（像单车道刚好满员）
- 负载2.0 = 双核CPU完全被占用，或单核CPU超载100%
- 负载0.5 = CPU只用了一半

```
负载值图示：
单核CPU情况下：
0.0 ────────── 空闲
0.5 ██████──── 半负载
1.0 ██████████ 满负载
1.5 ██████████ 超载50%（有等待）
```

**💡 查看系统负载**
```bash
# 三个数字分别代表：1分钟、5分钟、15分钟平均负载
uptime
# 输出：14:25:03 up 5 days, 2:15, 3 users, load average: 0.45, 0.38, 0.42

# 实时查看负载变化
watch -n 1 uptime
```

### 3.2 lscpu命令 - CPU信息查看


**🔸 核心概念**
`lscpu`命令显示CPU的详细"规格参数"，就像查看处理器的产品说明书。

```bash
lscpu

# 关键输出信息：
Architecture:        x86_64
CPU(s):             4                # 总逻辑CPU数
Thread(s) per core: 2                # 每核心线程数
Core(s) per socket: 2                # 每插槽核心数
Socket(s):          1                # CPU插槽数
Model name:         Intel Core i5-8250U
```

**📊 CPU配置计算**
```
CPU计算公式：
总逻辑CPU数 = 插槽数 × 每插槽核心数 × 每核心线程数

示例：1个插槽 × 2个核心 × 2个线程 = 4个逻辑CPU
```

**🎯 负载评估标准**
```bash
# 获取CPU核心数
CORES=$(nproc)

# 负载评估脚本片段
LOAD=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',')
if (( $(echo "$LOAD > $CORES" | bc -l) )); then
    echo "警告：系统负载过高 ($LOAD > $CORES)"
fi
```

---

## 4. 💿 I/O性能监控


### 4.1 iostat命令 - I/O统计分析


**🔸 核心概念**
`iostat`监控磁盘读写性能，就像测量硬盘的"工作效率"。

> **📦 安装说明**
> `iostat`属于`sysstat`包，如未安装：
> ```bash
> # CentOS/RHEL
> yum install sysstat
> # Ubuntu/Debian  
> apt install sysstat
> ```

**💡 基本使用**
```bash
# 每2秒显示一次I/O统计
iostat -x 2

# 示例输出：
Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %util
sda              2.45    8.32    45.67    156.78     0.12     2.34   15.6
sdb              0.23    0.45     8.91     12.34     0.01     0.08    2.1
```

**📈 关键指标解读**

| 指标 | **含义** | **正常范围** | **异常信号** |
|------|---------|-------------|-------------|
| `r/s, w/s` | `每秒读写次数` | `< 磁盘最大IOPS` | `持续接近上限` |
| `rkB/s, wkB/s` | `每秒读写KB数` | `根据应用而定` | `异常突增` |
| `%util` | `磁盘使用率` | `< 80%` | `> 90%需关注` |
| `await` | `平均等待时间(ms)` | `< 20ms` | `> 100ms很慢` |

**⚡ 性能诊断技巧**
```bash
# 只显示活跃的磁盘设备
iostat -x 2 | grep -v '^$\|^Device\|^Linux'

# 监控特定设备
iostat -x -d sda 2 5
```

---

## 5. 📊 系统活动综合报告


### 5.1 sar命令 - 系统活动报告器


**🔸 核心概念**
`sar`是系统监控的"瑞士军刀"，可以监控CPU、内存、IO、网络等几乎所有系统活动。

**💡 主要监控类型**

**CPU监控**：
```bash
# 每秒显示CPU使用率
sar -u 1 5

# 输出示例：
03:25:01 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
03:25:02 PM     all      5.24      0.00      2.13      1.25      0.00     91.38
```

**内存监控**：
```bash
# 内存和交换分区使用情况
sar -r 2 3

# 网络监控
sar -n DEV 2 3    # 网络接口统计
```

**📈 关键性能指标**

```
CPU性能阈值：
%user   < 70%    # 用户进程CPU使用率
%system < 30%    # 系统进程CPU使用率  
%iowait < 20%    # IO等待时间
%idle   > 20%    # 空闲时间

内存性能阈值：
%memused < 80%   # 内存使用率
%swpused < 10%   # 交换分区使用率
```

**🎯 历史数据查看**
```bash
# 查看昨天的CPU统计
sar -u -f /var/log/sa/sa$(date -d yesterday +%d)

# 查看今天上午10点的系统活动
sar -A -s 10:00:00 -e 11:00:00
```

---

## 6. 🔌 设备信息查看


### 6.1 lsblk命令 - 块设备信息


**🔸 核心概念**
`lsblk`以树状结构显示所有块设备，就像显示硬盘的"家族树"。

```bash
lsblk

# 示例输出：
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   20G  0 disk 
├─sda1   8:1    0    1G  0 part /boot
├─sda2   8:2    0    2G  0 part [SWAP]
└─sda3   8:3    0   17G  0 part /
sr0     11:0    1 1024M  0 rom  
```

**📊 设备层次结构图示**
```
磁盘设备关系：
sda (整块硬盘)
├── sda1 (分区1) → /boot
├── sda2 (分区2) → [SWAP]
└── sda3 (分区3) → /

设备类型说明：
disk = 整块磁盘
part = 磁盘分区  
rom  = 光驱设备
```

**🎯 实用参数**
```bash
# 显示文件系统信息
lsblk -f

# 显示权限信息
lsblk -m

# 只显示物理设备
lsblk -d
```

---

## 7. 🛠️ 实战监控脚本


### 7.1 综合监控脚本示例


```bash
#!/bin/bash
# 系统资源监控脚本

echo "=== 系统资源监控报告 ==="
echo "时间：$(date)"
echo

# 1. 系统负载检查
echo "【系统负载】"
LOAD_1=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',')
CORES=$(nproc)
echo "当前负载：$LOAD_1 (CPU核心数：$CORES)"

# 负载状态判断
if (( $(echo "$LOAD_1 > $CORES" | bc -l) )); then
    echo "⚠️  警告：系统负载过高！"
else
    echo "✅ 系统负载正常"
fi
echo

# 2. 磁盘空间检查
echo "【磁盘空间】"
df -h | grep -v tmpfs | grep -v udev | while read filesystem size used avail percent mount; do
    if [[ $filesystem != "Filesystem" ]]; then
        usage=$(echo $percent | tr -d '%')
        if [[ $usage -gt 80 ]]; then
            echo "⚠️  $mount: $percent 使用率过高！"
        else
            echo "✅ $mount: $percent"
        fi
    fi
done
echo

# 3. 内存使用检查
echo "【内存使用】"
MEM_TOTAL=$(free -m | grep Mem | awk '{print $2}')
MEM_USED=$(free -m | grep Mem | awk '{print $3}')
MEM_PERCENT=$(( MEM_USED * 100 / MEM_TOTAL ))

echo "内存使用：${MEM_USED}MB / ${MEM_TOTAL}MB (${MEM_PERCENT}%)"

if [[ $MEM_PERCENT -gt 80 ]]; then
    echo "⚠️  内存使用率过高！"
else
    echo "✅ 内存使用正常"
fi
echo

# 4. 高CPU占用进程
echo "【CPU占用TOP5】"
ps aux --sort=-%cpu | head -6
```

### 7.2 自动化监控部署


**定期执行监控**：
```bash
# 添加到crontab，每5分钟执行一次
crontab -e

# 添加以下行：
*/5 * * * * /path/to/monitor.sh >> /var/log/system_monitor.log 2>&1
```

**实时监控仪表板**：
```bash
#!/bin/bash
# 实时监控仪表板

while true; do
    clear
    echo "=============== 系统实时监控 ==============="
    echo "更新时间: $(date)"
    echo
    
    # CPU使用率
    echo "CPU使用率: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)%"
    
    # 内存使用率  
    echo "内存使用率: $(free | grep Mem | awk '{printf("%.1f%%", $3/$2 * 100.0)}')"
    
    # 磁盘使用率
    echo "根分区使用率: $(df / | tail -1 | awk '{print $5}')"
    
    # 系统负载
    echo "系统负载: $(uptime | awk -F'load average:' '{print $2}')"
    
    echo
    echo "按 Ctrl+C 退出监控"
    sleep 3
done
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的监控命令


```bash
🔸 磁盘监控：df -h (空间), du -sh (大小)  
🔸 内存监控：free -h (内存), vmstat (虚拟内存)
🔸 CPU监控：lscpu (信息), uptime (负载)
🔸 I/O监控：iostat -x (性能)
🔸 综合监控：sar (系统报告)
🔸 设备信息：lsblk (块设备)
```

### 8.2 关键性能指标阈值


| 监控项 | **正常范围** | **警告阈值** | **危险阈值** |
|-------|-------------|-------------|-------------|
| **磁盘使用率** | `< 70%` | `70-85%` | `> 85%` |
| **内存使用率** | `< 70%` | `70-85%` | `> 85%` |
| **CPU负载** | `< 核心数` | `= 核心数` | `> 核心数×1.5` |
| **IO等待时间** | `< 10%` | `10-20%` | `> 20%` |

### 8.3 监控最佳实践


**日常巡检命令组合**：
```bash
# 快速系统健康检查
df -h && free -h && uptime
```

**性能问题排查流程**：
```
1. uptime     → 查看系统负载
2. free -h    → 检查内存使用  
3. df -h      → 检查磁盘空间
4. iostat -x  → 分析I/O性能
5. vmstat     → 综合性能分析
```

**自动化监控要点**：
- 设置合理的告警阈值
- 记录历史数据便于分析
- 结合多个指标综合判断
- 及时清理监控日志避免占用空间

**核心记忆口诀**：
- df看磁盘，du算大小
- free查内存，vmstat更详细  
- uptime看负载，iostat查I/O
- sar最全能，lsblk看设备