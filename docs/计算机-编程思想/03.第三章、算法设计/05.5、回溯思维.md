---
title: 5ã€å›æº¯æ€ç»´
---
## ğŸ“š ç›®å½•

1. [å›æº¯æ€ç»´åŸºç¡€æ¦‚å¿µ](#1-å›æº¯æ€ç»´åŸºç¡€æ¦‚å¿µ)
2. [è¯•æ¢æ€§æœç´¢ç­–ç•¥](#2-è¯•æ¢æ€§æœç´¢ç­–ç•¥)
3. [å‰ªæä¼˜åŒ–æŠ€å·§](#3-å‰ªæä¼˜åŒ–æŠ€å·§)
4. [çŠ¶æ€ç©ºé—´æ ‘ç†è§£](#4-çŠ¶æ€ç©ºé—´æ ‘ç†è§£)
5. [çº¦æŸæ¡ä»¶å¤„ç†](#5-çº¦æŸæ¡ä»¶å¤„ç†)
6. [ç»å…¸é—®é¢˜æ¡ˆä¾‹åˆ†æ](#6-ç»å…¸é—®é¢˜æ¡ˆä¾‹åˆ†æ)
7. [å›æº¯ç®—æ³•ä¼˜åŒ–ç­–ç•¥](#7-å›æº¯ç®—æ³•ä¼˜åŒ–ç­–ç•¥)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ§© å›æº¯æ€ç»´åŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯å›æº¯æ€ç»´


**ğŸ”¸ é€šä¿—ç†è§£**
å›æº¯æ€ç»´å°±åƒèµ°è¿·å®«æ—¶çš„ç­–ç•¥ï¼šé‡åˆ°æ­»è·¯å°±é€€å›ä¸Šä¸€ä¸ªåˆ†å‰å£ï¼Œå°è¯•å…¶ä»–è·¯å¾„ã€‚

```
ç°å®åœºæ™¯ç±»æ¯”ï¼š
ğŸ¯ æ‰¾å·¥ä½œé¢è¯•ï¼š
   â†’ æŠ•ç®€å†ç»™å…¬å¸A â†’ é¢è¯•å¤±è´¥ â†’ é€€å›é‡æ–°é€‰æ‹©
   â†’ æŠ•ç®€å†ç»™å…¬å¸B â†’ é¢è¯•æˆåŠŸ â†’ æ‰¾åˆ°å·¥ä½œ

ğŸ§© è§£æ•°ç‹¬æ¸¸æˆï¼š
   â†’ åœ¨æŸæ ¼å¡«å…¥æ•°å­—5 â†’ å‘ç°åç»­æ— è§£ â†’ é€€å›é‡æ–°å¡«å…¶ä»–æ•°å­—
   â†’ åœ¨æŸæ ¼å¡«å…¥æ•°å­—7 â†’ ç»§ç»­ä¸‹å»èƒ½è§£å‡ºæ¥ â†’ æˆåŠŸ
```

**ğŸ”¸ ç®—æ³•æœ¬è´¨**
å›æº¯ç®—æ³•æ˜¯ä¸€ç§`è¯•é”™æ€ç»´`çš„ç³»ç»ŸåŒ–å®ç°ï¼š
- **è¯•æ¢**ï¼šå°è¯•ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆ
- **éªŒè¯**ï¼šæ£€æŸ¥æ˜¯å¦æ»¡è¶³æ¡ä»¶
- **å›é€€**ï¼šå¦‚æœä¸è¡Œå°±æ’¤é”€ï¼Œå°è¯•ä¸‹ä¸€ç§

### 1.2 å›æº¯æ€ç»´çš„é€‚ç”¨åœºæ™¯


**âœ… ä»€ä¹ˆæ—¶å€™ç”¨å›æº¯**
```
ğŸ”¸ ç»„åˆé—®é¢˜ï¼šä»nä¸ªå…ƒç´ ä¸­é€‰kä¸ªçš„æ‰€æœ‰ç»„åˆ
ğŸ”¸ æ’åˆ—é—®é¢˜ï¼šnä¸ªå…ƒç´ çš„æ‰€æœ‰æ’åˆ—æ–¹å¼
ğŸ”¸ å­é›†é—®é¢˜ï¼šæ±‚ä¸€ä¸ªé›†åˆçš„æ‰€æœ‰å­é›†
ğŸ”¸ æœç´¢é—®é¢˜ï¼šåœ¨çº¦æŸæ¡ä»¶ä¸‹æ‰¾åˆ°æ‰€æœ‰å¯èƒ½è§£
ğŸ”¸ æ¸¸æˆé—®é¢˜ï¼šæ•°ç‹¬ã€å…«çš‡åã€è¿·å®«æ±‚è§£
```

**âŒ ä»€ä¹ˆæ—¶å€™ä¸é€‚åˆç”¨å›æº¯**
```
ğŸ”¸ åªéœ€è¦ä¸€ä¸ªæœ€ä¼˜è§£ï¼ˆç”¨åŠ¨æ€è§„åˆ’æˆ–è´ªå¿ƒï¼‰
ğŸ”¸ é—®é¢˜è§„æ¨¡ç‰¹åˆ«å¤§ä¸”æ²¡æœ‰å‰ªæç©ºé—´
ğŸ”¸ æœ‰æ›´ç›´æ¥é«˜æ•ˆçš„ç®—æ³•å¯é€‰æ‹©
```

### 1.3 å›æº¯ç®—æ³•çš„åŸºæœ¬æ¡†æ¶


**ğŸ“‹ ä¸‡èƒ½æ¨¡æ¿**
```python
def backtrack(path, choices):
    # ğŸ¯ ç»“æŸæ¡ä»¶ï¼šæ‰¾åˆ°ä¸€ä¸ªè§£
    if æ»¡è¶³ç»“æŸæ¡ä»¶:
        result.append(path.copy())  # ä¿å­˜å½“å‰è§£
        return
    
    # ğŸ”„ éå†æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©
    for choice in choices:
        # âœ… åšé€‰æ‹©ï¼šå°†é€‰æ‹©æ·»åŠ åˆ°è·¯å¾„ä¸­
        path.append(choice)
        
        # ğŸš€ é€’å½’ï¼šåœ¨å‰©ä½™é€‰æ‹©ä¸­ç»§ç»­æœç´¢
        backtrack(path, æ›´æ–°åçš„choices)
        
        # â†©ï¸ æ’¤é”€é€‰æ‹©ï¼šå›æº¯åˆ°ä¸Šä¸€çŠ¶æ€
        path.pop()
```

---

## 2. ğŸ¯ è¯•æ¢æ€§æœç´¢ç­–ç•¥


### 2.1 è¯•æ¢æ€§æœç´¢çš„æ ¸å¿ƒæ€æƒ³


**ğŸ”¸ ä»€ä¹ˆæ˜¯è¯•æ¢æ€§æœç´¢**
è¯•æ¢æ€§æœç´¢å°±æ˜¯`"å¤§èƒ†å‡è®¾ï¼Œå°å¿ƒéªŒè¯"`çš„è¿‡ç¨‹ï¼š

```
æœç´¢è¿‡ç¨‹ç¤ºæ„ï¼š
å¼€å§‹çŠ¶æ€ â†’ é€‰æ‹©1 â†’ çŠ¶æ€A â†’ é€‰æ‹©2 â†’ çŠ¶æ€B (æ— è§£)
                           â†‘
                       å›é€€åˆ°çŠ¶æ€A
                           â†“
                      é€‰æ‹©3 â†’ çŠ¶æ€C â†’ ç»§ç»­æœç´¢...
```

### 2.2 æœç´¢ç­–ç•¥çš„å…·ä½“æ­¥éª¤


**ğŸ”¸ ä¸‰æ­¥èµ°ç­–ç•¥**

**ç¬¬ä¸€æ­¥ï¼šå°è¯•ï¼ˆTryï¼‰**
```python
# ç¤ºä¾‹ï¼šæ±‚æ•°ç»„çš„æ‰€æœ‰å­é›†
def generate_subsets(nums):
    result = []
    current_subset = []
    
    def backtrack(index):
        # æ¯ä¸ªä½ç½®éƒ½æœ‰ä¸¤ç§é€‰æ‹©ï¼šé€‰æˆ–ä¸é€‰
        if index == len(nums):
            result.append(current_subset.copy())
            return
        
        # ğŸ¯ å°è¯•é€‰æ‹©å½“å‰å…ƒç´ 
        current_subset.append(nums[index])
        backtrack(index + 1)
        
        # â†©ï¸ æ’¤é”€é€‰æ‹©ï¼Œå°è¯•ä¸é€‰å½“å‰å…ƒç´ 
        current_subset.pop()
        backtrack(index + 1)
    
    backtrack(0)
    return result
```

**ç¬¬äºŒæ­¥ï¼šéªŒè¯ï¼ˆValidateï¼‰**
```python
def is_valid(choice, current_path):
    """æ£€æŸ¥å½“å‰é€‰æ‹©æ˜¯å¦åˆæ³•"""
    # ä¾‹å¦‚ï¼šæ£€æŸ¥æ•°ç‹¬ä¸­æ•°å­—æ˜¯å¦å†²çª
    # ä¾‹å¦‚ï¼šæ£€æŸ¥å…«çš‡åä¸­æ˜¯å¦äº’ç›¸æ”»å‡»
    # ä¾‹å¦‚ï¼šæ£€æŸ¥æ˜¯å¦è¿åçº¦æŸæ¡ä»¶
    pass
```

**ç¬¬ä¸‰æ­¥ï¼šå›é€€ï¼ˆBacktrackï¼‰**
```python
def search_with_validation():
    for choice in available_choices:
        if is_valid(choice, current_path):
            # âœ… åˆæ³•é€‰æ‹©ï¼šç»§ç»­æœç´¢
            make_choice(choice)
            search_with_validation()
            undo_choice(choice)  # ğŸ”„ å…³é”®ï¼šæ’¤é”€é€‰æ‹©
```

### 2.3 æœç´¢é¡ºåºçš„é‡è¦æ€§


**ğŸ”¸ ä¸åŒæœç´¢é¡ºåºçš„å½±å“**
```
æ¡ˆä¾‹ï¼šç”Ÿæˆæ‰€æœ‰3ä½æ•°çš„æ’åˆ—

æ–¹æ³•1 - æŒ‰ä½ç½®æœç´¢ï¼š
ç¬¬1ä½é€‰æ‹© â†’ ç¬¬2ä½é€‰æ‹© â†’ ç¬¬3ä½é€‰æ‹©
[1,_,_] â†’ [1,2,_] â†’ [1,2,3] âœ“

æ–¹æ³•2 - æŒ‰æ•°å­—æœç´¢ï¼š
é€‰æ•°å­—1 â†’ é€‰æ•°å­—2 â†’ é€‰æ•°å­—3
ä½ç½®ï¼Ÿ â†’ ä½ç½®ï¼Ÿ â†’ ä½ç½®ï¼Ÿ

ğŸ’¡ æŒ‰ä½ç½®æœç´¢é€šå¸¸æ›´ç›´è§‚æ˜“æ‡‚
```

---

## 3. âœ‚ï¸ å‰ªæä¼˜åŒ–æŠ€å·§


### 3.1 ä»€ä¹ˆæ˜¯å‰ªæ


**ğŸ”¸ å‰ªæçš„é€šä¿—ç†è§£**
å‰ªæå°±åƒä¿®å‰ªæ ‘æä¸€æ ·ï¼ŒæŠŠé‚£äº›`æ˜æ˜¾ä¸ä¼šç»“æœ`çš„åˆ†æ”¯æå‰ç æ‰ï¼Œé¿å…æµªè´¹æ—¶é—´ã€‚

```
ä¸å‰ªæçš„æœç´¢æ ‘ï¼š                å‰ªæåçš„æœç´¢æ ‘ï¼š
        æ ¹                          æ ¹
       /|\                         /|
      A B C                       A B (Cè¢«å‰ªæ‰)
     /| ||\                      /|
    D E F G H                   D E (F,G,Hè¢«å‰ªæ‰)
   
æœç´¢èŠ‚ç‚¹ï¼š8ä¸ª                    æœç´¢èŠ‚ç‚¹ï¼š4ä¸ª
æ•ˆç‡æå‡ï¼š50%
```

### 3.2 å¸¸ç”¨å‰ªæç­–ç•¥


**ğŸ”¸ å¯è¡Œæ€§å‰ªæ**
æå‰åˆ¤æ–­å½“å‰è·¯å¾„æ˜¯å¦å¯èƒ½è¾¾åˆ°ç›®æ ‡ï¼š

```python
def backtrack_with_pruning(path, target):
    # ğŸš¨ å‰ªæï¼šå¦‚æœå½“å‰è·¯å¾„å·²ç»ä¸å¯èƒ½è¾¾åˆ°ç›®æ ‡
    if impossible_to_reach_target(path, target):
        return  # ç›´æ¥è¿”å›ï¼Œä¸ç»§ç»­æœç´¢
    
    if reached_target(path, target):
        save_solution(path)
        return
    
    for choice in get_choices():
        path.append(choice)
        backtrack_with_pruning(path, target)
        path.pop()
```

**ğŸ”¸ æœ€ä¼˜æ€§å‰ªæ**
å¦‚æœå½“å‰è§£å·²ç»æ¯”å·²çŸ¥æœ€ä¼˜è§£æ›´å·®ï¼š

```python
best_cost = float('inf')  # å½“å‰æœ€ä¼˜è§£

def backtrack_with_optimal_pruning(path, current_cost):
    global best_cost
    
    # ğŸš¨ å‰ªæï¼šå½“å‰æˆæœ¬å·²ç»è¶…è¿‡æœ€ä¼˜è§£
    if current_cost >= best_cost:
        return
    
    if is_complete_solution(path):
        best_cost = current_cost
        save_solution(path)
        return
```

**ğŸ”¸ é‡å¤å‰ªæ**
é¿å…æœç´¢é‡å¤çš„çŠ¶æ€ï¼š

```python
def backtrack_with_duplicate_pruning(path, visited):
    state = get_current_state(path)
    
    # ğŸš¨ å‰ªæï¼šè¿™ä¸ªçŠ¶æ€å·²ç»æœç´¢è¿‡äº†
    if state in visited:
        return
    
    visited.add(state)
    # ... ç»§ç»­æœç´¢
    visited.remove(state)  # å›æº¯æ—¶ç§»é™¤
```

### 3.3 å‰ªæä¼˜åŒ–æ¡ˆä¾‹


**ğŸ”¸ æ•°å­—ç»„åˆé—®é¢˜çš„å‰ªæ**
```python
def combination_sum(candidates, target):
    """æ‰¾å‡ºæ‰€æœ‰å’Œä¸ºtargetçš„æ•°å­—ç»„åˆ"""
    result = []
    candidates.sort()  # ğŸ¯ æ’åºä¸ºå‰ªæåšå‡†å¤‡
    
    def backtrack(start, path, current_sum):
        # æ‰¾åˆ°ç›®æ ‡ç»„åˆ
        if current_sum == target:
            result.append(path.copy())
            return
        
        for i in range(start, len(candidates)):
            num = candidates[i]
            
            # ğŸš¨ å‰ªæï¼šå¦‚æœåŠ ä¸Šå½“å‰æ•°å­—ä¼šè¶…è¿‡ç›®æ ‡
            if current_sum + num > target:
                break  # ç”±äºæ•°ç»„å·²æ’åºï¼Œåé¢çš„æ•°å­—éƒ½ä¼šè¶…è¿‡
            
            path.append(num)
            backtrack(i + 1, path, current_sum + num)
            path.pop()
    
    backtrack(0, [], 0)
    return result
```

---

## 4. ğŸŒ³ çŠ¶æ€ç©ºé—´æ ‘ç†è§£


### 4.1 ä»€ä¹ˆæ˜¯çŠ¶æ€ç©ºé—´æ ‘


**ğŸ”¸ çŠ¶æ€ç©ºé—´æ ‘çš„æ¦‚å¿µ**
çŠ¶æ€ç©ºé—´æ ‘æ˜¯æŠŠæ‰€æœ‰å¯èƒ½çš„`æœç´¢è·¯å¾„`ç”»æˆä¸€æ£µæ ‘çš„å½¢çŠ¶ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ª`ä¸­é—´çŠ¶æ€`ã€‚

```
ä¾‹å­ï¼šä»[1,2,3]ä¸­é€‰2ä¸ªæ•°çš„ç»„åˆ

çŠ¶æ€ç©ºé—´æ ‘ï¼š
                    []  (æ ¹èŠ‚ç‚¹ - ç©ºé›†åˆ)
                   / \
              é€‰1/     \ä¸é€‰1
                /       \
           [1]           []
           / \           / \
      é€‰2/   \ä¸é€‰2  é€‰2/   \ä¸é€‰2
        /     \       /     \
    [1,2]     [1]   [2]     []
      |        |     |       |
      âœ“       é€‰3   é€‰3     é€‰3
             / |     |       |
          [1,3] |   [2,3]   [3]
            âœ“   âœ“     âœ“      |
                            é€‰æ‹©ç»“æŸ
```

### 4.2 çŠ¶æ€ç©ºé—´æ ‘çš„å±‚æ¬¡ç»“æ„


**ğŸ”¸ æ ‘çš„å±‚æ¬¡å«ä¹‰**
```
ç¬¬0å±‚ï¼šåˆå§‹çŠ¶æ€ï¼ˆæ ¹èŠ‚ç‚¹ï¼‰
ç¬¬1å±‚ï¼šåšäº†1ä¸ªé€‰æ‹©åçš„çŠ¶æ€
ç¬¬2å±‚ï¼šåšäº†2ä¸ªé€‰æ‹©åçš„çŠ¶æ€
...
ç¬¬nå±‚ï¼šåšäº†nä¸ªé€‰æ‹©åçš„çŠ¶æ€ï¼ˆé€šå¸¸æ˜¯å¶å­èŠ‚ç‚¹ï¼‰
```

**ğŸ”¸ èŠ‚ç‚¹ç±»å‹åˆ†æ**
```
ğŸ”µ å†…éƒ¨èŠ‚ç‚¹ï¼šè¿˜éœ€è¦ç»§ç»­åšé€‰æ‹©çš„çŠ¶æ€
ğŸŸ¢ å¶å­èŠ‚ç‚¹ï¼šå·²ç»å¾—åˆ°å®Œæ•´è§£çš„çŠ¶æ€
ğŸ”´ æ­»èŠ‚ç‚¹ï¼š  è¿åçº¦æŸï¼Œè¢«å‰ªæçš„çŠ¶æ€
```

### 4.3 æœç´¢è·¯å¾„çš„ç†è§£


**ğŸ”¸ ä»æ ¹åˆ°å¶çš„è·¯å¾„**
```python
class SearchPath:
    def __init__(self):
        self.path = []  # è®°å½•ä»æ ¹åˆ°å½“å‰èŠ‚ç‚¹çš„é€‰æ‹©åºåˆ—
        self.level = 0  # å½“å‰åœ¨ç¬¬å‡ å±‚
    
    def make_choice(self, choice):
        """åšä¸€ä¸ªé€‰æ‹©ï¼Œå‘ä¸‹èµ°ä¸€å±‚"""
        self.path.append(choice)
        self.level += 1
    
    def undo_choice(self):
        """æ’¤é”€é€‰æ‹©ï¼Œå‘ä¸Šå›é€€ä¸€å±‚"""
        if self.path:
            self.path.pop()
            self.level -= 1
```

**ğŸ”¸ æ·±åº¦ä¼˜å…ˆéå†**
å›æº¯ç®—æ³•å®é™…ä¸Šæ˜¯å¯¹çŠ¶æ€ç©ºé—´æ ‘çš„`æ·±åº¦ä¼˜å…ˆéå†`ï¼š

```
éå†é¡ºåºç¤ºä¾‹ï¼š
1. ä»æ ¹èŠ‚ç‚¹å¼€å§‹
2. å°½å¯èƒ½æ·±åœ°æ¢ç´¢ä¸€æ¡è·¯å¾„
3. åˆ°è¾¾å¶å­èŠ‚ç‚¹æˆ–æ­»èŠ‚ç‚¹åå›é€€
4. å°è¯•å…„å¼ŸèŠ‚ç‚¹
5. é‡å¤ç›´åˆ°éå†å®Œæ•´æ£µæ ‘
```

---

## 5. âš–ï¸ çº¦æŸæ¡ä»¶å¤„ç†


### 5.1 çº¦æŸæ¡ä»¶çš„åˆ†ç±»


**ğŸ”¸ ç¡¬çº¦æŸ vs è½¯çº¦æŸ**
```
ğŸ”´ ç¡¬çº¦æŸï¼ˆå¿…é¡»æ»¡è¶³ï¼‰ï¼š
   - æ•°ç‹¬ä¸­åŒè¡ŒåŒåˆ—ä¸èƒ½æœ‰é‡å¤æ•°å­—
   - å…«çš‡åä¸­çš‡åä¸èƒ½äº’ç›¸æ”»å‡»
   - å›¾ç€è‰²ä¸­ç›¸é‚»èŠ‚ç‚¹ä¸èƒ½åŒè‰²

ğŸŸ¡ è½¯çº¦æŸï¼ˆå¸Œæœ›æ»¡è¶³ï¼‰ï¼š
   - è¯¾ç¨‹å®‰æ’ä¸­å°½é‡é¿å…è¿ç»­ä¸Šè¯¾
   - å‘˜å·¥æ’ç­ä¸­å°½é‡å…¬å¹³åˆ†é…
   - èµ„æºåˆ†é…ä¸­å°½é‡å¹³è¡¡
```

### 5.2 çº¦æŸæ£€æŸ¥çš„æ—¶æœº


**ğŸ”¸ ä¸‰ç§æ£€æŸ¥æ—¶æœº**
```python
def backtrack_with_constraints():
    # ğŸ• é€‰æ‹©å‰æ£€æŸ¥ï¼šé¿å…æ— æ•ˆé€‰æ‹©
    for choice in get_valid_choices():  # é¢„è¿‡æ»¤
        
        # ğŸ•‘ é€‰æ‹©æ—¶æ£€æŸ¥ï¼šç¡®ä¿å½“å‰çŠ¶æ€åˆæ³•
        if is_valid_choice(choice, current_state):
            make_choice(choice)
            
            # ğŸ•’ é€‰æ‹©åæ£€æŸ¥ï¼šæ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¸Œæœ›
            if has_potential_solution(current_state):
                backtrack_with_constraints()
            
            undo_choice(choice)
```

### 5.3 å¤æ‚çº¦æŸçš„å¤„ç†æŠ€å·§


**ğŸ”¸ çº¦æŸåˆ†è§£**
æŠŠå¤æ‚çº¦æŸåˆ†è§£ä¸ºå¤šä¸ªç®€å•çº¦æŸï¼š

```python
def check_complex_constraint(state):
    """æ£€æŸ¥å¤æ‚çº¦æŸï¼šå°†å…¶åˆ†è§£ä¸ºå¤šä¸ªç®€å•çº¦æŸ"""
    
    # åˆ†è§£ä¸ºå¤šä¸ªå­çº¦æŸ
    if not check_basic_constraint_1(state):
        return False
    
    if not check_basic_constraint_2(state):
        return False
    
    if not check_basic_constraint_3(state):
        return False
    
    return True
```

**ğŸ”¸ çº¦æŸä¼ æ’­**
ä¸€ä¸ªçº¦æŸçš„æ»¡è¶³å¯èƒ½å½±å“å…¶ä»–çº¦æŸï¼š

```python
def propagate_constraints(choice, state):
    """çº¦æŸä¼ æ’­ï¼šä¸€ä¸ªé€‰æ‹©å¯èƒ½é™åˆ¶åç»­é€‰æ‹©"""
    
    # æ›´æ–°å¯ç”¨é€‰æ‹©é›†åˆ
    update_available_choices(choice, state)
    
    # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¯è¡Œè§£
    if no_solution_possible(state):
        return False
    
    return True
```

---

## 6. ğŸ‘‘ ç»å…¸é—®é¢˜æ¡ˆä¾‹åˆ†æ


### 6.1 å…«çš‡åé—®é¢˜è¯¦è§£


**ğŸ”¸ é—®é¢˜æè¿°**
åœ¨8Ã—8çš„æ£‹ç›˜ä¸Šæ”¾ç½®8ä¸ªçš‡åï¼Œä½¿å¾—å¥¹ä»¬ä¸èƒ½äº’ç›¸æ”»å‡»ï¼ˆåŒè¡Œã€åŒåˆ—ã€åŒå¯¹è§’çº¿éƒ½ä¸è¡Œï¼‰ã€‚

```
æ£‹ç›˜ç¤ºæ„ï¼ˆä¸€ç§è§£æ³•ï¼‰ï¼š
  1 2 3 4 5 6 7 8
1 â™› Â· Â· Â· Â· Â· Â· Â·
2 Â· Â· Â· Â· â™› Â· Â· Â·
3 Â· Â· Â· Â· Â· Â· Â· â™›
4 Â· Â· Â· Â· Â· â™› Â· Â·
5 Â· Â· â™› Â· Â· Â· Â· Â·
6 Â· Â· Â· Â· Â· Â· â™› Â·
7 Â· â™› Â· Â· Â· Â· Â· Â·
8 Â· Â· Â· â™› Â· Â· Â· Â·
```

**ğŸ”¸ å›æº¯è§£æ³•æ€è·¯**
```python
def eight_queens():
    """å…«çš‡åé—®é¢˜çš„å›æº¯è§£æ³•"""
    result = []
    board = [-1] * 8  # board[i]è¡¨ç¤ºç¬¬iè¡Œçš‡åçš„åˆ—ä½ç½®
    
    def is_safe(row, col):
        """æ£€æŸ¥åœ¨(row,col)æ”¾ç½®çš‡åæ˜¯å¦å®‰å…¨"""
        for i in range(row):
            # æ£€æŸ¥åŒåˆ—
            if board[i] == col:
                return False
            
            # æ£€æŸ¥å¯¹è§’çº¿
            if abs(board[i] - col) == abs(i - row):
                return False
        
        return True
    
    def backtrack(row):
        """åœ¨ç¬¬rowè¡Œæ”¾ç½®çš‡å"""
        if row == 8:
            # æ‰¾åˆ°ä¸€ä¸ªè§£
            result.append(board.copy())
            return
        
        # å°è¯•åœ¨æ¯ä¸€åˆ—æ”¾ç½®çš‡å
        for col in range(8):
            if is_safe(row, col):
                # ğŸ¯ åšé€‰æ‹©
                board[row] = col
                # ğŸš€ é€’å½’å¤„ç†ä¸‹ä¸€è¡Œ
                backtrack(row + 1)
                # â†©ï¸ æ’¤é”€é€‰æ‹©ï¼ˆè¿™é‡Œä¸éœ€è¦æ˜¾å¼æ’¤é”€ï¼Œå› ä¸ºä¼šè¢«è¦†ç›–ï¼‰
    
    backtrack(0)
    return result
```

### 6.2 æ•°ç‹¬æ±‚è§£é—®é¢˜


**ğŸ”¸ æ•°ç‹¬è§„åˆ™**
åœ¨9Ã—9çš„æ ¼å­ä¸­å¡«å…¥1-9çš„æ•°å­—ï¼Œä½¿å¾—ï¼š
- æ¯è¡Œéƒ½åŒ…å«1-9çš„æ•°å­—
- æ¯åˆ—éƒ½åŒ…å«1-9çš„æ•°å­—  
- æ¯ä¸ª3Ã—3çš„å°æ ¼éƒ½åŒ…å«1-9çš„æ•°å­—

**ğŸ”¸ å›æº¯è§£æ³•**
```python
def solve_sudoku(board):
    """æ•°ç‹¬æ±‚è§£å™¨"""
    
    def is_valid(row, col, num):
        """æ£€æŸ¥åœ¨(row,col)å¡«å…¥numæ˜¯å¦åˆæ³•"""
        # æ£€æŸ¥è¡Œ
        for x in range(9):
            if board[row][x] == num:
                return False
        
        # æ£€æŸ¥åˆ—
        for x in range(9):
            if board[x][col] == num:
                return False
        
        # æ£€æŸ¥3Ã—3å°æ ¼
        start_row, start_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(3):
            for j in range(3):
                if board[start_row + i][start_col + j] == num:
                    return False
        
        return True
    
    def backtrack():
        """å›æº¯æ±‚è§£"""
        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:  # æ‰¾åˆ°ç©ºæ ¼
                    for num in range(1, 10):  # å°è¯•1-9
                        if is_valid(i, j, num):
                            # ğŸ¯ åšé€‰æ‹©
                            board[i][j] = num
                            # ğŸš€ é€’å½’æ±‚è§£
                            if backtrack():
                                return True
                            # â†©ï¸ æ’¤é”€é€‰æ‹©
                            board[i][j] = 0
                    return False  # æ‰€æœ‰æ•°å­—éƒ½è¯•è¿‡äº†ï¼Œæ— è§£
        return True  # æ‰€æœ‰æ ¼å­éƒ½å¡«æ»¡äº†
    
    return backtrack()
```

### 6.3 ç»„åˆé—®é¢˜æ¡ˆä¾‹


**ğŸ”¸ ç”µè¯å·ç çš„å­—æ¯ç»„åˆ**
```python
def letter_combinations(digits):
    """ç”µè¯å·ç å¯¹åº”çš„å­—æ¯ç»„åˆ"""
    if not digits:
        return []
    
    # æ•°å­—åˆ°å­—æ¯çš„æ˜ å°„
    phone_map = {
        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
    }
    
    result = []
    
    def backtrack(index, current_combination):
        """ç”Ÿæˆå­—æ¯ç»„åˆ"""
        # ğŸ¯ åˆ°è¾¾ç»“å°¾ï¼Œæ‰¾åˆ°ä¸€ä¸ªç»„åˆ
        if index == len(digits):
            result.append(current_combination)
            return
        
        # è·å–å½“å‰æ•°å­—å¯¹åº”çš„å­—æ¯
        digit = digits[index]
        letters = phone_map[digit]
        
        # å°è¯•æ¯ä¸ªå­—æ¯
        for letter in letters:
            # ğŸ¯ åšé€‰æ‹©
            backtrack(index + 1, current_combination + letter)
            # â†©ï¸ è¿™é‡Œä¸éœ€è¦æ˜¾å¼æ’¤é”€ï¼Œå› ä¸ºå­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„
    
    backtrack(0, "")
    return result

# ä½¿ç”¨ç¤ºä¾‹
result = letter_combinations("23")
# è¾“å‡ºï¼š['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']
```

---

## 7. ğŸš€ å›æº¯ç®—æ³•ä¼˜åŒ–ç­–ç•¥


### 7.1 é€‰æ‹©é¡ºåºä¼˜åŒ–


**ğŸ”¸ æœ€å°‘å‰©ä½™å€¼å¯å‘å¼**
ä¼˜å…ˆé€‰æ‹©`å‰©ä½™å¯é€‰é¡¹æœ€å°‘`çš„å˜é‡ï¼š

```python
def choose_next_variable(state):
    """é€‰æ‹©ä¸‹ä¸€ä¸ªè¦èµ‹å€¼çš„å˜é‡"""
    min_remaining = float('inf')
    best_var = None
    
    for var in unassigned_variables:
        remaining_values = get_valid_values(var, state)
        if len(remaining_values) < min_remaining:
            min_remaining = len(remaining_values)
            best_var = var
    
    return best_var
```

**ğŸ”¸ æœ€çº¦æŸå˜é‡å¯å‘å¼**
ä¼˜å…ˆé€‰æ‹©`çº¦æŸå…¶ä»–å˜é‡æœ€å¤š`çš„å˜é‡ï¼š

```python
def choose_most_constraining_variable(state):
    """é€‰æ‹©çº¦æŸå…¶ä»–å˜é‡æœ€å¤šçš„å˜é‡"""
    max_constraints = 0
    best_var = None
    
    for var in unassigned_variables:
        constraint_count = count_constraints_on_others(var)
        if constraint_count > max_constraints:
            max_constraints = constraint_count
            best_var = var
    
    return best_var
```

### 7.2 æœç´¢ç­–ç•¥ä¼˜åŒ–


**ğŸ”¸ éšæœºåŒ–æœç´¢**
é¿å…åœ¨ç‰¹å®šæ¨¡å¼ä¸Šå¡ä½ï¼š

```python
import random

def randomized_backtrack(choices):
    """éšæœºåŒ–çš„å›æº¯æœç´¢"""
    # ğŸ² éšæœºæ‰“ä¹±é€‰æ‹©é¡ºåº
    random.shuffle(choices)
    
    for choice in choices:
        if is_valid(choice):
            make_choice(choice)
            if randomized_backtrack(get_next_choices()):
                return True
            undo_choice(choice)
    
    return False
```

**ğŸ”¸ è¿­ä»£åŠ æ·±æœç´¢**
é™åˆ¶æœç´¢æ·±åº¦ï¼Œé€æ­¥åŠ æ·±ï¼š

```python
def iterative_deepening_search(max_depth):
    """è¿­ä»£åŠ æ·±æœç´¢"""
    for depth in range(1, max_depth + 1):
        result = depth_limited_search(depth)
        if result is not None:
            return result
    return None

def depth_limited_search(depth_limit):
    """æ·±åº¦é™åˆ¶æœç´¢"""
    if depth_limit == 0:
        return None
    
    for choice in choices:
        make_choice(choice)
        result = depth_limited_search(depth_limit - 1)
        if result is not None:
            return result
        undo_choice(choice)
    
    return None
```

### 7.3 è®°å¿†åŒ–ä¼˜åŒ–


**ğŸ”¸ çŠ¶æ€è®°å¿†**
è®°ä½å·²ç»æœç´¢è¿‡çš„çŠ¶æ€ï¼š

```python
def backtrack_with_memoization():
    """å¸¦è®°å¿†åŒ–çš„å›æº¯æœç´¢"""
    memo = {}  # è®°å¿†å·²æœç´¢çš„çŠ¶æ€
    
    def search(state):
        # ğŸ§  æ£€æŸ¥æ˜¯å¦å·²ç»æœç´¢è¿‡è¿™ä¸ªçŠ¶æ€
        state_key = get_state_key(state)
        if state_key in memo:
            return memo[state_key]
        
        # æ­£å¸¸çš„å›æº¯æœç´¢
        for choice in get_choices(state):
            new_state = apply_choice(state, choice)
            result = search(new_state)
            if result:
                memo[state_key] = True
                return True
        
        memo[state_key] = False
        return False
    
    return search(initial_state)
```

### 7.4 å¹¶è¡ŒåŒ–ä¼˜åŒ–


**ğŸ”¸ å¤šçº¿ç¨‹æœç´¢**
```python
import threading
from concurrent.futures import ThreadPoolExecutor

def parallel_backtrack(choices):
    """å¹¶è¡Œå›æº¯æœç´¢"""
    
    def search_branch(choice):
        """æœç´¢ä¸€ä¸ªåˆ†æ”¯"""
        make_choice(choice)
        result = single_thread_backtrack()
        undo_choice(choice)
        return result
    
    # ğŸ”„ å¹¶è¡Œæœç´¢å¤šä¸ªåˆ†æ”¯
    with ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(search_branch, choice) 
                  for choice in choices[:4]]  # é™åˆ¶å¹¶è¡Œæ•°é‡
        
        for future in futures:
            result = future.result()
            if result:
                return result
    
    return None
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ å›æº¯æœ¬è´¨ï¼šè¯•é”™ + æ’¤é”€çš„ç³»ç»ŸåŒ–æœç´¢æ–¹æ³•
ğŸ”¸ æœç´¢ç­–ç•¥ï¼šæ·±åº¦ä¼˜å…ˆéå†çŠ¶æ€ç©ºé—´æ ‘
ğŸ”¸ ä¸‰ä¸ªè¦ç´ ï¼šé€‰æ‹©ã€çº¦æŸã€ç›®æ ‡
ğŸ”¸ æ ¸å¿ƒæ“ä½œï¼šmake_choice() å’Œ undo_choice()
ğŸ”¸ ä¼˜åŒ–å…³é”®ï¼šå‰ªæç­–ç•¥å’Œæœç´¢é¡ºåº
```

### 8.2 å›æº¯æ€ç»´çš„åº”ç”¨åœºæ™¯


**âœ… é€‚åˆç”¨å›æº¯çš„é—®é¢˜**
```
ğŸ¯ éœ€è¦æ‰¾åˆ°æ‰€æœ‰å¯èƒ½è§£çš„é—®é¢˜
ğŸ¯ æœ‰æ˜ç¡®çº¦æŸæ¡ä»¶çš„æœç´¢é—®é¢˜  
ğŸ¯ å¯ä»¥åˆ†è§£ä¸ºå­é—®é¢˜çš„ç»„åˆé—®é¢˜
ğŸ¯ è§£ç©ºé—´å¯ä»¥ç”¨æ ‘å½¢ç»“æ„è¡¨ç¤ºçš„é—®é¢˜
```

**ğŸ”§ å›æº¯ç®—æ³•è®¾è®¡æ­¥éª¤**
```
1ï¸âƒ£ å®šä¹‰çŠ¶æ€ç©ºé—´ï¼šæ˜ç¡®æœç´¢çš„çŠ¶æ€è¡¨ç¤º
2ï¸âƒ£ ç¡®å®šé€‰æ‹©é›†åˆï¼šæ¯ä¸€æ­¥å¯ä»¥åšå“ªäº›é€‰æ‹©
3ï¸âƒ£ è®¾è®¡çº¦æŸæ¡ä»¶ï¼šä»€ä¹ˆæƒ…å†µä¸‹é€‰æ‹©æ— æ•ˆ
4ï¸âƒ£ å®šä¹‰ç›®æ ‡çŠ¶æ€ï¼šä»€ä¹ˆæ—¶å€™æ‰¾åˆ°äº†è§£
5ï¸âƒ£ è®¾è®¡å‰ªæç­–ç•¥ï¼šå¦‚ä½•æå‰ç»ˆæ­¢æ— æ•ˆæœç´¢
```

### 8.3 å›æº¯æ€ç»´çš„æ ¸å¿ƒä»·å€¼


**ğŸ¯ åŸ¹å…»ç³»ç»Ÿæ€§æ€ç»´**
- å­¦ä¼šæŠŠå¤æ‚é—®é¢˜åˆ†è§£ä¸ºç®€å•çš„é€‰æ‹©åºåˆ—
- åŸ¹å…»"è¯•é”™-æ€»ç»“-æ”¹è¿›"çš„é—®é¢˜è§£å†³æ¨¡å¼
- ç†è§£çº¦æŸæ¡ä»¶åœ¨é—®é¢˜æ±‚è§£ä¸­çš„é‡è¦ä½œç”¨

**ğŸš€ å®é™…ç¼–ç¨‹åº”ç”¨**
- ç®—æ³•ç«èµ›ä¸­çš„æœç´¢é—®é¢˜
- æ¸¸æˆå¼€å‘ä¸­çš„AIå†³ç­–
- èµ„æºåˆ†é…å’Œè°ƒåº¦ä¼˜åŒ–
- ç»„åˆä¼˜åŒ–é—®é¢˜çš„æ±‚è§£

**ğŸ’¡ æ€ç»´æ¨¡å¼è¿ç§»**
- é¡¹ç›®ç®¡ç†ï¼šåˆ¶å®šæ–¹æ¡ˆâ†’éªŒè¯å¯è¡Œæ€§â†’è°ƒæ•´æ–¹æ¡ˆ
- å­¦ä¹ è§„åˆ’ï¼šé€‰æ‹©æ–¹å‘â†’å®è·µéªŒè¯â†’è°ƒæ•´è·¯å¾„  
- ç”Ÿæ´»å†³ç­–ï¼šåˆ—ä¸¾é€‰é¡¹â†’è¯„ä¼°ç»“æœâ†’é€‰æ‹©æœ€ä¼˜

**æ ¸å¿ƒè®°å¿†**ï¼š
- å›æº¯å°±æ˜¯æœ‰ç»„ç»‡çš„è¯•é”™ï¼Œè¯•ä¸é€šå°±é€€å›æ¥
- å‰ªææ˜¯å›æº¯çš„çµé­‚ï¼Œå†³å®šç®—æ³•çš„æ•ˆç‡
- çŠ¶æ€ç©ºé—´æ ‘å¸®åŠ©ç†è§£æœç´¢çš„å®Œæ•´è¿‡ç¨‹
- çº¦æŸæ¡ä»¶æ˜¯æœç´¢çš„æŒ‡å—é’ˆï¼ŒæŒ‡å¼•æ­£ç¡®æ–¹å‘