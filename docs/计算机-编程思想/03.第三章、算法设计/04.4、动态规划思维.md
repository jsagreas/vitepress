---
title: 4、动态规划思维
---
## 📚 目录

1. [动态规划思维概述](#1-动态规划思维概述)
2. [状态定义技巧](#2-状态定义技巧)
3. [状态转移方程](#3-状态转移方程)
4. [最优子结构](#4-最优子结构)
5. [重叠子问题](#5-重叠子问题)
6. [从递归到DP](#6-从递归到DP)
7. [DP问题分类](#7-DP问题分类)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧠 动态规划思维概述


### 1.1 什么是动态规划


**通俗理解**：动态规划（Dynamic Programming，简称DP）就像是一个"智能的记忆本"，它能记住之前解决过的小问题答案，然后用这些答案来解决更大的问题。

```
生活中的例子：
爬楼梯 → 第10层 = 第8层的方法数 + 第9层的方法数
计算斐波那契 → F(10) = F(8) + F(9)
买股票 → 今天的最佳收益 = 昨天的最佳收益 + 今天是否交易
```

**核心思想**：把一个复杂问题拆分成若干个相互关联的小问题，解决这些小问题，然后用小问题的答案组合出大问题的答案。

### 1.2 为什么需要动态规划


**问题场景**：很多实际问题都具有"最优化"特征
- 🎯 **路径问题**：从A到B的最短路径
- 💰 **资源分配**：有限资源下的最大收益
- 🔄 **序列决策**：一步步决策达到最优结果

**传统方法的困境**：
```
暴力枚举：
- 斐波那契F(40)需要计算20亿次
- 时间复杂度O(2^n)，指数级爆炸

动态规划：
- 记住每个F(i)的值，只算一次
- 时间复杂度O(n)，线性增长
```

### 1.3 动态规划的本质特征


**核心特征**：
```
🔸 最优子结构：大问题的最优解包含小问题的最优解
🔸 重叠子问题：同样的小问题会被重复计算
🔸 状态转移：从小问题的解推导出大问题的解
🔸 记忆化存储：避免重复计算，提高效率
```

---

## 2. 🎯 状态定义技巧


### 2.1 什么是状态


**状态定义**：状态就是用来描述问题在某个时刻的"情况"或"条件"的变量。

```
生活中的状态例子：
🏃‍♂️ 跑步状态：当前位置、剩余体力、已跑时间
🎮 游戏状态：当前等级、血量、装备、金币
📈 股票状态：当前价格、持有状态、交易次数
```

### 2.2 状态定义的关键原则


**🔸 完整性原则**：状态要能完整描述问题的当前情况
```java
// 背包问题状态定义
// 不完整：dp[i] = 前i个物品的最大价值 ❌
// 完整：dp[i][w] = 前i个物品，背包容量为w时的最大价值 ✅

// 为什么？因为最大价值还要考虑背包剩余容量
```

**🔸 最小化原则**：状态维度越少越好，但不能丢失关键信息
```java
// 爬楼梯问题
// 冗余：dp[i][j][k] = 第i天，走j步，方向为k ❌
// 精简：dp[i] = 到达第i级台阶的方法数 ✅
```

**🔸 可转移原则**：状态之间要能建立转移关系
```java
// 股票问题状态设计
dp[i][0] = 第i天不持有股票的最大收益
dp[i][1] = 第i天持有股票的最大收益

// 这样设计能很好地转移：
// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
// dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
```

### 2.3 常见状态定义模式


**📊 状态定义模式分类**

| 问题类型 | **状态表示** | **含义** | **典型例子** |
|---------|------------|---------|-------------|
| **位置类** | `dp[i]` | `到达位置i的最优值` | `爬楼梯、跳跃游戏` |
| **选择类** | `dp[i][j]` | `前i个元素，状态为j的最优值` | `背包问题、股票问题` |
| **区间类** | `dp[i][j]` | `区间[i,j]的最优值` | `回文子串、矩阵链乘法` |
| **状态机** | `dp[i][state]` | `第i步，处于state状态的最优值` | `股票交易、打家劫舍` |

### 2.4 状态定义实战技巧


**🎯 技巧1：从问题答案倒推状态**
```
问题：最长递增子序列的长度
思考：答案是什么？→ 某个长度值
状态：dp[i] = 以第i个元素结尾的最长递增子序列长度
```

**🎯 技巧2：考虑决策点**
```
问题：买卖股票最大收益
思考：每天的决策是什么？→ 买、卖、不动
状态：dp[i][0/1] = 第i天持有/不持有股票的最大收益
```

**🎯 技巧3：增加状态维度**
```
问题：最多进行k次交易的股票收益
原状态：dp[i][0/1] 不够用
新状态：dp[i][k][0/1] = 第i天，最多k次交易，持有/不持有的最大收益
```

---

## 3. ⚡ 状态转移方程


### 3.1 什么是状态转移方程


**通俗理解**：状态转移方程就是描述"今天的状态"和"昨天的状态"之间关系的数学公式。

```
生活例子：
银行存款：今天余额 = 昨天余额 + 今天收入 - 今天支出
爬楼梯：到第n层方法 = 到第(n-1)层方法 + 到第(n-2)层方法
```

### 3.2 状态转移方程的构建步骤


**🔸 步骤1：明确当前状态**
```java
// 以斐波那契数列为例
当前状态：F(n) - 第n个斐波那契数
```

**🔸 步骤2：分析可能的前置状态**
```java
// 分析：F(n)可能从哪些状态转移而来？
前置状态：F(n-1) 和 F(n-2)
```

**🔸 步骤3：建立转移关系**
```java
// 转移方程
F(n) = F(n-1) + F(n-2)
```

**🔸 步骤4：确定边界条件**
```java
// 基础情况
F(0) = 0, F(1) = 1
```

### 3.3 状态转移方程的常见模式


**🔸 累加型转移**
```java
// 爬楼梯问题
dp[i] = dp[i-1] + dp[i-2]  // 方法数累加

// 背包问题
dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
```

**🔸 最值型转移**
```java
// 最长递增子序列
dp[i] = max(dp[j] + 1) for all j < i and arr[j] < arr[i]

// 股票问题
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
```

**🔸 条件型转移**
```java
// 打家劫舍
dp[i] = max(dp[i-1], dp[i-2] + nums[i])  // 抢或不抢
```

### 3.4 状态转移方程的推导技巧


**💡 技巧1：分情况讨论**
```
问题：股票买卖
分析：今天结束后，我可能处于什么状态？
情况1：手里有股票 → 昨天有股票 或 今天买入
情况2：手里没股票 → 昨天没股票 或 今天卖出

转移方程：
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
```

**💡 技巧2：考虑最后一步**
```
问题：最长公共子序列
分析：最优解的最后一步是什么？
情况1：s1[i] == s2[j] → LCS长度 = dp[i-1][j-1] + 1
情况2：s1[i] != s2[j] → LCS长度 = max(dp[i-1][j], dp[i][j-1])
```

---

## 4. 🏗️ 最优子结构


### 4.1 什么是最优子结构


**通俗理解**：最优子结构就是说"大问题的最佳答案里，包含着小问题的最佳答案"。

```
生活例子：
🚗 最短路径：从北京到上海的最短路径，必然包含北京到某中转城市的最短路径
📈 最大收益：今年最大收益的策略，必然包含前几个月最大收益的策略
🎯 最优决策：整体最优决策，必然基于局部最优决策
```

### 4.2 最优子结构的判断标准


**🔸 判断标准**：
1. **问题可以分解**：大问题能拆成小问题
2. **小问题独立**：小问题的解不会因为在不同大问题中而改变
3. **最优性传递**：小问题的最优解能推出大问题的最优解

```
✅ 具有最优子结构的问题：
- 最短路径：A→C最短 = A→B最短 + B→C最短
- 斐波那契：F(n)最优 = F(n-1)最优 + F(n-2)最优

❌ 不具有最优子结构的问题：
- 最长简单路径：A→C最长 ≠ A→B最长 + B→C最长
  （因为可能形成环，违反"简单路径"约束）
```

### 4.3 最优子结构的验证方法


**🔍 反证法验证**：
```
假设：大问题的最优解不包含小问题的最优解
推论：我们可以用小问题的最优解替换当前解中的小问题部分
结果：得到更优的大问题解，与假设矛盾
结论：最优子结构成立
```

**🔍 实际例子验证**：
```java
// 背包问题验证
问题：背包容量10，物品[重量3价值4, 重量4价值5, 重量5价值6]
假设最优解：选择物品[1,3]，总价值10

验证子结构：
- 去掉物品1后，剩余容量7，最优选择是物品3（价值6）
- 去掉物品3后，剩余容量5，最优选择是物品1（价值4）
- 都是对应子问题的最优解 ✅
```

### 4.4 最优子结构的应用


**🎯 设计状态转移**：
```java
// 有了最优子结构，状态转移就很自然
dp[i][w] = max(
    dp[i-1][w],  // 不选第i个物品的最优解
    dp[i-1][w-weight[i]] + value[i]  // 选第i个物品的最优解
);
```

**🎯 确保正确性**：
```java
// 最优子结构保证了递推的正确性
如果dp[i-1][w]已经是最优的，
那么dp[i][w]也必然是最优的
```

---

## 5. 🔄 重叠子问题


### 5.1 什么是重叠子问题


**通俗理解**：重叠子问题就是说在解决大问题的过程中，同样的小问题会被重复计算很多次。

```
经典例子：斐波那契数列计算

计算F(5)的递归过程：
F(5)
├─ F(4)
│  ├─ F(3)
│  │  ├─ F(2) ← 重复计算
│  │  └─ F(1)
│  └─ F(2) ← 重复计算
└─ F(3) ← 重复计算
   ├─ F(2) ← 重复计算
   └─ F(1)

F(2)被计算了3次，F(3)被计算了2次！
```

### 5.2 重叠子问题带来的性能问题


**🚨 指数级时间复杂度**：
```java
// 朴素递归的斐波那契
public int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 大量重复计算
}

时间复杂度：O(2^n) - 指数级爆炸
计算F(40)需要约20亿次递归调用！
```

**📊 重复计算的规模**：
```
F(10) → 177次调用
F(20) → 21,891次调用  
F(30) → 2,692,537次调用
F(40) → 331,160,281次调用

但实际上只需要计算F(0)到F(n)各一次就够了！
```

### 5.3 解决重叠子问题的方法


**🔸 方法1：记忆化搜索（自顶向下）**
```java
// 用Map存储已计算的结果
Map<Integer, Integer> memo = new HashMap<>();

public int fib(int n) {
    if (n <= 1) return n;
    
    // 如果已经计算过，直接返回
    if (memo.containsKey(n)) {
        return memo.get(n);
    }
    
    // 计算并存储结果
    int result = fib(n-1) + fib(n-2);
    memo.put(n, result);
    return result;
}
```

**🔸 方法2：动态规划（自底向上）**
```java
public int fib(int n) {
    if (n <= 1) return n;
    
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    
    // 从小到大依次计算
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

### 5.4 记忆化的设计技巧


**💡 选择合适的存储结构**：
```java
// 一维问题：数组或Map
int[] memo = new int[n+1];

// 二维问题：二维数组或Map
int[][] memo = new int[m+1][n+1];
Map<String, Integer> memo = new HashMap<>();  // key = "i,j"

// 复杂状态：自定义类作为key
Map<State, Integer> memo = new HashMap<>();
```

**💡 初始化技巧**：
```java
// 用特殊值标记未计算状态
Arrays.fill(memo, -1);  // -1表示未计算
if (memo[i] != -1) return memo[i];  // 已计算过
```

**💡 空间优化**：
```java
// 如果只依赖前几个状态，可以用滚动数组
int prev2 = 0, prev1 = 1;
for (int i = 2; i <= n; i++) {
    int curr = prev1 + prev2;
    prev2 = prev1;
    prev1 = curr;
}
```

---

## 6. 🔄 从递归到DP


### 6.1 递归到DP的转化思路


**🔄 转化的核心思想**：
```
递归：从大问题开始，层层分解到小问题（自顶向下）
DP：从小问题开始，逐步构建大问题（自底向上）

本质：都是利用子问题的解来构建原问题的解
区别：计算顺序和存储方式不同
```

### 6.2 转化的标准步骤


**🔸 步骤1：写出朴素递归**
```java
// 爬楼梯的递归解法
public int climbStairs(int n) {
    if (n <= 2) return n;
    return climbStairs(n-1) + climbStairs(n-2);
}
```

**🔸 步骤2：识别重叠子问题**
```
分析：climbStairs(n-1)和climbStairs(n-2)会重复计算相同的子问题
```

**🔸 步骤3：添加记忆化**
```java
// 记忆化递归版本
Map<Integer, Integer> memo = new HashMap<>();

public int climbStairs(int n) {
    if (n <= 2) return n;
    if (memo.containsKey(n)) return memo.get(n);
    
    int result = climbStairs(n-1) + climbStairs(n-2);
    memo.put(n, result);
    return result;
}
```

**🔸 步骤4：转为自底向上DP**
```java
// 动态规划版本
public int climbStairs(int n) {
    if (n <= 2) return n;
    
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

### 6.3 转化过程中的关键要点


**🎯 状态定义保持一致**：
```java
// 递归函数的参数 → DP数组的下标
递归：climbStairs(n) 表示爬n层楼梯的方法数
DP：dp[n] 表示爬n层楼梯的方法数
```

**🎯 递归关系变为转移方程**：
```java
// 递归调用关系 → 状态转移方程
递归：climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)
DP：dp[n] = dp[n-1] + dp[n-2]
```

**🎯 边界条件变为初始状态**：
```java
// 递归的基础情况 → DP的初始值
递归：if (n <= 2) return n;
DP：dp[1] = 1; dp[2] = 2;
```

### 6.4 复杂例子：最长公共子序列


**🔸 递归版本**：
```java
public int lcs(String s1, String s2, int i, int j) {
    // 边界条件
    if (i == 0 || j == 0) return 0;
    
    // 字符相等
    if (s1.charAt(i-1) == s2.charAt(j-1)) {
        return 1 + lcs(s1, s2, i-1, j-1);
    }
    
    // 字符不等
    return Math.max(
        lcs(s1, s2, i-1, j),
        lcs(s1, s2, i, j-1)
    );
}
```

**🔸 DP版本**：
```java
public int lcs(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    // 边界条件：dp[0][j] = dp[i][0] = 0 (默认值)
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1.charAt(i-1) == s2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
```

---

## 7. 📊 DP问题分类


### 7.1 线性DP


**📏 特点**：状态转移具有明显的线性关系，通常是一维或二维的顺序依赖。

**🔸 一维线性DP**：
```java
// 典型例子：爬楼梯、打家劫舍
// 状态：dp[i] 表示到第i个位置的最优值
// 转移：dp[i] = f(dp[i-1], dp[i-2], ...)

// 打家劫舍
public int rob(int[] nums) {
    int n = nums.length;
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    int[] dp = new int[n];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    
    for (int i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
    }
    return dp[n-1];
}
```

**🔸 二维线性DP**：
```java
// 典型例子：最长公共子序列、编辑距离
// 状态：dp[i][j] 表示关于两个序列前i个和前j个元素的最优值

// 编辑距离
public int editDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    // 初始化边界
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1.charAt(i-1) == s2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1];  // 不需要操作
            } else {
                dp[i][j] = Math.min(
                    dp[i-1][j] + 1,    // 删除
                    Math.min(
                        dp[i][j-1] + 1,    // 插入
                        dp[i-1][j-1] + 1   // 替换
                    )
                );
            }
        }
    }
    return dp[m][n];
}
```

### 7.2 区间DP


**📐 特点**：按照区间长度从小到大进行动态规划，适用于区间上的最优化问题。

```java
// 典型例子：矩阵链乘法、回文子串
// 状态：dp[i][j] 表示区间[i,j]的最优值
// 转移：dp[i][j] = min/max(dp[i][k] + dp[k+1][j] + cost)

// 最长回文子序列
public int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];
    
    // 长度为1的区间
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
    }
    
    // 按区间长度从2到n
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i+1][j-1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
            }
        }
    }
    return dp[0][n-1];
}
```

**🔄 区间DP的计算顺序**：
```
按区间长度递增：
长度1：[0,0], [1,1], [2,2], ...
长度2：[0,1], [1,2], [2,3], ...
长度3：[0,2], [1,3], [2,4], ...
...
```

### 7.3 树形DP


**🌳 特点**：在树结构上进行动态规划，通常需要考虑子树的信息。

```java
// 典型例子：树的直径、打家劫舍III
// 状态：通常定义在节点上，考虑该节点选择/不选择的情况

// 打家劫舍III（树上版本）
class TreeNode {
    int val;
    TreeNode left, right;
}

public int rob(TreeNode root) {
    int[] result = robHelper(root);
    return Math.max(result[0], result[1]);
}

// 返回[不抢该节点的最大值, 抢该节点的最大值]
private int[] robHelper(TreeNode node) {
    if (node == null) return new int[]{0, 0};
    
    int[] left = robHelper(node.left);
    int[] right = robHelper(node.right);
    
    // 不抢当前节点：子节点可抢可不抢
    int notRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    
    // 抢当前节点：子节点不能抢
    int rob = node.val + left[0] + right[0];
    
    return new int[]{notRob, rob};
}
```

### 7.4 状态机DP


**🔄 特点**：问题具有明显的状态转换特征，通常用有限状态自动机建模。

```java
// 典型例子：股票买卖、字符串匹配
// 状态：dp[i][state] 表示第i天/第i个字符处于某种状态的最优值

// 股票买卖（最多k次交易）
public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    if (k >= n / 2) {
        // k足够大，等价于无限次交易
        return maxProfitInfinite(prices);
    }
    
    // dp[i][t][0] = 第i天，最多t次交易，不持有股票的最大收益
    // dp[i][t][1] = 第i天，最多t次交易，持有股票的最大收益
    int[][][] dp = new int[n][k + 1][2];
    
    for (int i = 0; i < n; i++) {
        for (int t = k; t >= 1; t--) {
            if (i == 0) {
                dp[i][t][0] = 0;
                dp[i][t][1] = -prices[i];
                continue;
            }
            dp[i][t][0] = Math.max(dp[i-1][t][0], dp[i-1][t][1] + prices[i]);
            dp[i][t][1] = Math.max(dp[i-1][t][1], dp[i-1][t-1][0] - prices[i]);
        }
    }
    return dp[n-1][k][0];
}
```

### 7.5 背包类DP


**🎒 特点**：涉及容量限制和物品选择的优化问题。

```java
// 0-1背包
public int knapsack(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n + 1][capacity + 1];
    
    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= capacity; w++) {
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(
                    dp[i-1][w],  // 不选第i个物品
                    dp[i-1][w-weights[i-1]] + values[i-1]  // 选第i个物品
                );
            } else {
                dp[i][w] = dp[i-1][w];
            }
        }
    }
    return dp[n][capacity];
}

// 空间优化版本
public int knapsackOptimized(int[] weights, int[] values, int capacity) {
    int[] dp = new int[capacity + 1];
    
    for (int i = 0; i < weights.length; i++) {
        // 从后往前遍历，避免重复使用
        for (int w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    return dp[capacity];
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 动态规划本质：利用子问题最优解构建原问题最优解
🔸 状态定义：完整描述问题情况的变量组合
🔸 状态转移方程：描述状态间转移关系的数学公式
🔸 最优子结构：大问题最优解包含小问题最优解
🔸 重叠子问题：同样子问题被重复计算多次
🔸 记忆化优化：存储已计算结果避免重复计算
```

### 8.2 关键理解要点


**🔹 动态规划的思维模式**
```
分解思维：
- 大问题 → 小问题
- 复杂决策 → 简单决策
- 整体最优 → 局部最优

记忆思维：
- 已解决过的不再重复
- 用空间换时间
- 自底向上构建解
```

**🔹 状态设计的关键原则**
```
完整性：状态要能完整描述问题
最小性：状态维度尽可能少
可转移性：状态间要能建立转移关系
```

**🔹 从递归到DP的转化思路**
```
递归思路：如何分解问题？
DP思路：如何从小问题构建大问题？
优化思路：如何避免重复计算？
```

### 8.3 实际应用价值


**🎯 算法优化价值**
- **性能提升**：从指数级优化到多项式级
- **空间利用**：合理的空间换时间策略
- **可扩展性**：处理大规模数据的能力

**🎯 思维训练价值**
- **分解能力**：复杂问题的分解思维
- **抽象能力**：状态抽象和建模能力
- **优化意识**：性能优化的系统思维

### 8.4 学习建议


**📚 学习路径**
```
第一阶段：理解基本概念和简单问题
推荐题目：爬楼梯、斐波那契、打家劫舍

第二阶段：掌握常见DP模式
推荐题目：背包问题、最长公共子序列、编辑距离

第三阶段：练习复杂DP问题
推荐题目：股票问题、区间DP、树形DP
```

**🎯 解题方法论**
```
1. 确定是否适合用DP（最优子结构+重叠子问题）
2. 设计状态（考虑完整性和最小性）
3. 找出状态转移方程（分情况讨论）
4. 确定边界条件（基础情况）
5. 考虑空间优化（如果可能）
```

**💡 常见陷阱提醒**
```
⚠️ 状态定义不完整：漏掉关键信息
⚠️ 转移方程错误：没有考虑所有情况
⚠️ 边界条件遗漏：特殊情况处理不当
⚠️ 空间浪费：没有考虑空间优化
⚠️ 时间复杂度估算错误：循环嵌套层数计算错误
```

**核心记忆口诀**：
- 动态规划解最优，状态转移是关键
- 重叠子问题要记忆，最优子结构传递
- 从小到大建答案，空间时间双优化
- 分类练习多总结，思维模式要形成