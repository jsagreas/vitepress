---
title: 13、动态计算：运行时计算换预存储
---
## 📚 目录

1. [动态计算基本概念](#1-动态计算基本概念)
2. [动态计算原理与权衡](#2-动态计算原理与权衡)
3. [动态SQL生成技术](#3-动态SQL生成技术)
4. [实时报表设计](#4-实时报表设计)
5. [动态配置系统](#5-动态配置系统)
6. [表达式求值引擎](#6-表达式求值引擎)
7. [核心应用场景](#7-核心应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧮 动态计算基本概念


### 1.1 什么是动态计算


**简单理解**：动态计算就像现做现卖的餐厅，客人点什么就现场制作什么，而不是提前把所有菜品都做好放着。

```
传统预存储方式（空间换时间）：
餐厅把所有菜品都提前做好 → 客人点餐立即上菜 → 快速但占用大量存储空间

动态计算方式（时间换空间）：
客人点餐后现场制作 → 等待制作时间 → 慢一些但节省存储空间
```

**核心定义**：
```
动态计算：在需要结果时才进行计算，而不是预先计算并存储结果
目的：通过增加计算时间来减少存储空间的占用
适用：结果变化频繁、存储成本高、访问频率低的场景
```

### 1.2 动态计算的本质特征


**⚡ 核心特点**
```
🔸 按需计算
• 只有在真正需要结果时才开始计算
• 避免了大量预计算的资源浪费
• 类似于"懒加载"的思想

🔸 实时性强
• 每次计算都基于最新的数据
• 不存在数据过期的问题
• 结果始终保持最新状态

🔸 空间效率高
• 不需要存储大量预计算结果
• 只存储原始数据和计算逻辑
• 存储空间需求大幅降低

🔸 灵活性强
• 计算逻辑可以随时调整
• 支持复杂的个性化需求
• 易于适应业务变化
```

### 1.3 生活化类比理解


**🏪 便利店 vs 定制服务**
```
预存储模式（便利店）：
✅ 商品齐全，随时可取
✅ 服务速度快
❌ 需要大量库存空间
❌ 商品可能过期

动态计算模式（定制服务）：
✅ 按需定制，不浪费
✅ 产品始终最新
❌ 等待制作时间
❌ 服务速度相对慢
```

---

## 2. ⚖️ 动态计算原理与权衡


### 2.1 权衡体现分析


**📊 时间 vs 空间的具体体现**

| 方面 | **预存储方案** | **动态计算方案** |
|------|---------------|----------------|
| 🕐 **响应时间** | `毫秒级，极快` | `秒级，需要计算时间` |
| 💾 **存储空间** | `大量，存储所有结果` | `很少，只存原始数据` |
| 🔄 **数据新鲜度** | `可能过期` | `始终最新` |
| ⚙️ **系统复杂度** | `同步更新复杂` | `计算逻辑复杂` |
| 💰 **成本结构** | `存储成本高` | `计算成本高` |

### 2.2 权衡决策模型


**🎯 选择动态计算的条件**
```
适合动态计算的场景：
📍 数据变化频繁（每分钟都在变）
📍 访问频率较低（不是热点数据）
📍 存储成本很高（大数据量）
📍 个性化需求强（每个用户不同）
📍 实时性要求高（必须是最新数据）

不适合动态计算的场景：
🚫 访问非常频繁（高并发查询）
🚫 计算逻辑极复杂（耗时过长）
🚫 数据相对稳定（变化不频繁）
🚫 响应时间要求严格（毫秒级）
```

### 2.3 权衡计算公式


**💡 成本效益分析**
```
预存储总成本 = 存储成本 + 维护成本 + 数据一致性成本
动态计算总成本 = 计算成本 + 响应延迟成本

选择原则：
当 动态计算总成本 < 预存储总成本 时，选择动态计算

实际考虑因素：
• 存储成本：存储设备、备份、维护费用
• 计算成本：CPU资源、电力消耗
• 时间成本：用户等待时间的价值
• 维护成本：数据同步、一致性保证的开发维护成本
```

---

## 3. 🗃️ 动态SQL生成技术


### 3.1 动态SQL基本概念


**什么是动态SQL**：根据不同的查询条件，在程序运行时动态构建SQL语句，而不是预先写好所有可能的SQL。

**🔄 静态 vs 动态对比**
```
静态SQL方式：
SELECT * FROM products WHERE category = 'electronics'
SELECT * FROM products WHERE price > 1000  
SELECT * FROM products WHERE category = 'electronics' AND price > 1000
→ 需要为每种查询组合准备SQL语句

动态SQL方式：
根据用户输入的筛选条件，动态构建一条SQL语句
→ 一套逻辑处理所有查询组合
```

### 3.2 动态SQL实现示例


**📝 基础动态查询实现**
```java
public class DynamicQueryBuilder {
    public String buildProductQuery(SearchCriteria criteria) {
        StringBuilder sql = new StringBuilder("SELECT * FROM products WHERE 1=1");
        
        // 动态添加分类条件
        if (criteria.getCategory() != null) {
            sql.append(" AND category = '").append(criteria.getCategory()).append("'");
        }
        
        // 动态添加价格条件
        if (criteria.getMinPrice() != null) {
            sql.append(" AND price >= ").append(criteria.getMinPrice());
        }
        
        // 动态添加排序
        if (criteria.getSortBy() != null) {
            sql.append(" ORDER BY ").append(criteria.getSortBy());
        }
        
        return sql.toString();
    }
}

// 使用示例
SearchCriteria criteria = new SearchCriteria();
criteria.setCategory("electronics");
criteria.setMinPrice(500);
criteria.setSortBy("price DESC");

// 动态生成SQL：
// SELECT * FROM products WHERE 1=1 AND category = 'electronics' AND price >= 500 ORDER BY price DESC
```

### 3.3 动态SQL的优势与应用


**✅ 主要优势**
```
🔸 灵活性强
• 支持任意条件组合
• 无需预写大量SQL模板
• 易于扩展新的查询条件

🔸 代码简洁
• 一套逻辑处理多种场景
• 减少重复代码
• 降低维护成本

🔸 性能优化
• 只查询必要的数据
• 避免不必要的条件判断
• 数据库执行计划更优
```

**🎯 典型应用场景**
```
电商网站商品筛选：
• 分类、品牌、价格区间、评分等多维度筛选
• 用户可能选择任意条件组合
• 动态构建最优查询SQL

报表查询系统：
• 时间范围、部门、项目等多个维度
• 管理员需要灵活的数据分析能力
• 根据选择的维度动态生成统计SQL
```

---

## 4. 📊 实时报表设计


### 4.1 实时报表 vs 预聚合报表


**📈 两种报表策略对比**

```
预聚合报表（空间换时间）：
数据仓库 → 定时ETL → 预聚合表 → 快速查询展示
优点：查询速度快，用户体验好
缺点：占用大量存储，数据有延迟

实时报表（时间换空间）：
原始数据 → 实时查询计算 → 动态生成报表
优点：数据实时性强，存储占用少
缺点：查询速度慢，计算压力大
```

### 4.2 实时报表架构设计


**🏗️ 系统架构图示**
```
用户请求                实时计算引擎                数据源
    |                       |                      |
    |--[1]报表请求---------->|                      |
    |   (时间范围+维度)       |                      |
    |                       |--[2]查询原始数据----->|
    |                       |<-[3]返回明细数据------|
    |                       |                      |
    |                       |--[4]实时聚合计算----->|
    |                       |   (SUM/COUNT/AVG)    |
    |                       |                      |
    |<--[5]返回报表结果-------|                      |
    |   (图表+数据)          |                      |
```

**💡 核心组件说明**
```
🔸 查询解析器
• 解析用户的报表查询请求
• 提取时间范围、统计维度、指标类型
• 生成对应的数据查询逻辑

🔸 实时计算引擎  
• 从数据源获取原始明细数据
• 按照指定维度进行分组聚合
• 计算SUM、COUNT、AVG等统计指标

🔸 缓存优化层
• 缓存近期的查询结果
• 避免重复的相同查询计算
• 提高整体响应速度
```

### 4.3 实时报表实现示例


**📋 销售报表动态生成**
```java
public class RealTimeReportService {
    
    public ReportData generateSalesReport(ReportQuery query) {
        // 1. 解析查询条件
        String dateRange = query.getDateRange();
        String[] dimensions = query.getDimensions(); // 如：["region", "product"]
        String[] metrics = query.getMetrics();       // 如：["sales_amount", "order_count"]
        
        // 2. 动态构建SQL
        String sql = buildDynamicReportSQL(dateRange, dimensions, metrics);
        
        // 3. 执行查询并计算
        List<Map<String, Object>> rawData = executeQuery(sql);
        
        // 4. 实时聚合计算
        return aggregateData(rawData, dimensions, metrics);
    }
    
    private String buildDynamicReportSQL(String dateRange, String[] dimensions, String[] metrics) {
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT ");
        
        // 添加维度字段
        for (String dim : dimensions) {
            sql.append(dim).append(", ");
        }
        
        // 添加指标计算
        for (String metric : metrics) {
            switch (metric) {
                case "sales_amount":
                    sql.append("SUM(amount) as total_sales, ");
                    break;
                case "order_count":
                    sql.append("COUNT(*) as total_orders, ");
                    break;
            }
        }
        
        sql.append("FROM orders WHERE order_date BETWEEN ? AND ? ");
        sql.append("GROUP BY ").append(String.join(", ", dimensions));
        
        return sql.toString();
    }
}

// 使用示例
ReportQuery query = new ReportQuery();
query.setDateRange("2024-01-01", "2024-01-31");
query.setDimensions(new String[]{"region", "product_category"});
query.setMetrics(new String[]{"sales_amount", "order_count"});

// 动态生成的SQL类似：
// SELECT region, product_category, SUM(amount) as total_sales, COUNT(*) as total_orders
// FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
// GROUP BY region, product_category
```

**📈 性能优化策略**
```
🔸 分区查询
• 按时间分区存储数据
• 只查询相关时间范围的分区
• 大幅减少扫描的数据量

🔸 索引优化
• 为常用的查询维度建立索引
• 组合索引覆盖多个查询条件
• 提高查询执行效率

🔸 并行计算
• 将大查询拆分为多个小查询
• 并行执行后合并结果
• 充分利用多核CPU资源
```

---

## 5. ⚙️ 动态配置系统


### 5.1 动态配置基本概念


**配置管理的两种方式**：

```
静态配置（配置缓存）：
应用启动时加载配置 → 内存缓存 → 直接使用缓存值
优点：访问速度极快
缺点：配置变更需要重启应用

动态配置（运行时解析）：
每次需要配置时 → 实时读取配置源 → 解析后使用
优点：配置立即生效，无需重启
缺点：每次都要读取解析，性能较低
```

### 5.2 动态配置架构设计


**🔧 配置系统架构图**
```
应用程序              配置管理器              配置存储
    |                     |                     |
    |--[1]获取配置-------->|                     |
    |   getConfig("db")   |                     |
    |                     |--[2]查询配置------->|
    |                     |<-[3]返回配置值------|
    |                     |                     |
    |                     |--[4]解析配置------->|
    |                     |   (JSON/YAML)      |
    |                     |                     |
    |<--[5]返回解析结果----|                     |
    |   {host:"db1"...}   |                     |

配置变更流程：
管理员 → 配置中心 → 实时推送 → 应用程序立即生效
```

### 5.3 动态配置实现示例


**📝 动态配置管理器**
```java
public class DynamicConfigManager {
    private ConfigStorage configStorage;
    
    public <T> T getConfig(String configKey, Class<T> type) {
        // 1. 实时从存储中获取配置
        String configValue = configStorage.getValue(configKey);
        
        // 2. 动态解析配置内容
        return parseConfig(configValue, type);
    }
    
    private <T> T parseConfig(String configValue, Class<T> type) {
        if (type == DatabaseConfig.class) {
            // 动态解析数据库配置
            return (T) parseDatabaseConfig(configValue);
        } else if (type == RedisConfig.class) {
            // 动态解析Redis配置
            return (T) parseRedisConfig(configValue);
        }
        return null;
    }
    
    private DatabaseConfig parseDatabaseConfig(String jsonConfig) {
        // 实时解析JSON配置
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(jsonConfig, DatabaseConfig.class);
    }
}

// 使用示例
public class OrderService {
    private DynamicConfigManager configManager;
    
    public void processOrder(Order order) {
        // 每次处理订单时，动态获取数据库配置
        DatabaseConfig dbConfig = configManager.getConfig("database", DatabaseConfig.class);
        
        // 使用最新的配置连接数据库
        DataSource dataSource = createDataSource(dbConfig);
        
        // 业务处理...
    }
}
```

**🚀 性能优化技巧**
```
🔸 智能缓存
• 配置较少变化时短期缓存
• 设置合理的缓存过期时间
• 平衡实时性和性能

🔸 变更通知
• 配置变更时主动通知应用
• 应用收到通知后刷新缓存
• 避免轮询带来的性能损耗

🔸 分层配置
• 全局配置 + 应用配置 + 环境配置
• 根据变更频率采用不同策略
• 稳定配置缓存，易变配置动态获取
```

---

## 6. 🧮 表达式求值引擎


### 6.1 表达式求值概念


**什么是表达式求值**：将字符串形式的数学或逻辑表达式，在程序运行时解析并计算出结果。

**💭 两种处理方式对比**
```
预编译方式：
表达式 → 编译时转换为代码 → 编译后直接执行
例：price * 0.8 → 编译成 multiply(price, 0.8)

动态求值方式：
表达式 → 运行时解析 → 动态计算结果
例：用户输入"price * 0.8" → 解析器计算 → 返回结果
```

### 6.2 表达式引擎架构


**🔍 求值过程图示**
```
输入表达式                解析器                  计算引擎
     |                     |                      |
"price*0.8+tax"            |                      |
     |                     |                      |
     |--[1]词法分析------->|                      |
     |                    |tokens: [price,*,0.8,+,tax]
     |                     |                      |
     |                     |--[2]语法分析------->|
     |                     |  AST语法树          |
     |                     |      +              |
     |                     |     / \             |
     |                     |    *   tax          |
     |                     |   / \               |
     |                     | price 0.8           |
     |                     |                     |
     |                     |--[3]求值计算------->|
     |                     |  遍历AST计算        |
     |                     |                     |
     |<--[4]返回结果-------|<-[求值完成]---------|
     |    108.5            |                     |
```

### 6.3 表达式引擎实现示例


**📋 简单表达式解析器**
```java
public class ExpressionEvaluator {
    private Map<String, Double> variables;
    
    public ExpressionEvaluator() {
        this.variables = new HashMap<>();
    }
    
    // 设置变量值
    public void setVariable(String name, Double value) {
        variables.put(name, value);
    }
    
    // 动态计算表达式
    public double evaluate(String expression) {
        // 1. 替换变量
        String processedExpr = replaceVariables(expression);
        
        // 2. 解析并计算
        return parseAndCalculate(processedExpr);
    }
    
    private String replaceVariables(String expression) {
        String result = expression;
        for (Map.Entry<String, Double> entry : variables.entrySet()) {
            result = result.replace(entry.getKey(), entry.getValue().toString());
        }
        return result;
    }
    
    private double parseAndCalculate(String expression) {
        // 简化版本：使用JavaScript引擎求值
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("JavaScript");
        
        try {
            Object result = engine.eval(expression);
            return ((Number) result).doubleValue();
        } catch (ScriptException e) {
            throw new RuntimeException("表达式计算错误: " + expression, e);
        }
    }
}

// 使用示例
public class PricingService {
    private ExpressionEvaluator evaluator;
    
    public double calculatePrice(Product product, Customer customer) {
        // 设置动态变量
        evaluator.setVariable("basePrice", product.getBasePrice());
        evaluator.setVariable("discountRate", customer.getDiscountRate());
        evaluator.setVariable("taxRate", getTaxRate(customer.getRegion()));
        
        // 动态计算定价表达式
        String pricingFormula = getPricingFormula(product.getCategory());
        // 例如：pricingFormula = "basePrice * (1 - discountRate) * (1 + taxRate)"
        
        return evaluator.evaluate(pricingFormula);
    }
}
```

**🎯 表达式引擎应用场景**
```
🔸 动态定价系统
• 根据客户等级、促销活动动态计算价格
• 表达式：basePrice * discountFactor + premiumFee
• 运营人员可以灵活调整定价规则

🔸 业务规则引擎
• 动态评估复杂的业务规则
• 表达式：age >= 18 && income > 50000 && creditScore > 600
• 支持规则的灵活配置和调整

🔸 报表计算引擎
• 支持用户自定义计算字段
• 表达式：(revenue - cost) / revenue * 100
• 让业务人员可以创建个性化的分析指标
```

---

## 7. 🎯 核心应用场景


### 7.1 个性化推荐系统


**🤖 推荐算法的动态计算**
```
传统预计算推荐：
用户画像 + 物品特征 → 批量计算推荐分数 → 存储推荐列表
问题：用户行为变化后，推荐结果不能及时更新

动态计算推荐：
用户实时行为 + 当前物品库存 → 实时计算推荐分数 → 生成推荐列表
优势：推荐结果始终基于最新的用户行为和商品状态
```

**💡 实现思路示例**
```java
public class DynamicRecommendationEngine {
    
    public List<Product> recommend(User user, int count) {
        // 1. 获取用户实时行为特征
        UserProfile profile = buildRealTimeProfile(user);
        
        // 2. 获取当前可推荐商品池
        List<Product> candidates = getAvailableProducts();
        
        // 3. 动态计算每个商品的推荐分数
        List<ProductScore> scores = new ArrayList<>();
        for (Product product : candidates) {
            double score = calculateRecommendScore(profile, product);
            scores.add(new ProductScore(product, score));
        }
        
        // 4. 排序并返回Top N
        return scores.stream()
                .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
                .limit(count)
                .map(ProductScore::getProduct)
                .collect(Collectors.toList());
    }
    
    private double calculateRecommendScore(UserProfile profile, Product product) {
        // 动态计算推荐分数，考虑多个因素
        double categoryInterest = profile.getCategoryInterest(product.getCategory());
        double pricePreference = calculatePriceMatch(profile, product);
        double trendFactor = product.getCurrentPopularity();
        double inventoryFactor = product.getInventoryLevel() > 0 ? 1.0 : 0.0;
        
        return categoryInterest * 0.4 + pricePreference * 0.3 + 
               trendFactor * 0.2 + inventoryFactor * 0.1;
    }
}
```

### 7.2 动态定价系统


**💰 智能定价策略**
```
定价影响因素的实时计算：
🔸 供需关系：当前库存量 + 实时需求热度
🔸 竞争态势：竞品价格监控 + 市场定位
🔸 用户特征：购买力 + 忠诚度 + 历史行为  
🔸 时间因素：季节性 + 促销活动 + 库存周转

动态定价公式示例：
最终价格 = 基础价格 × 供需系数 × 竞争系数 × 用户系数 × 时间系数
```

**📈 动态定价实现**
```java
public class DynamicPricingService {
    
    public BigDecimal calculatePrice(Product product, Customer customer, PricingContext context) {
        // 基础价格
        BigDecimal basePrice = product.getBasePrice();
        
        // 1. 供需系数 (库存越少，价格越高)
        double supplyDemandFactor = calculateSupplyDemandFactor(product);
        
        // 2. 竞争系数 (基于竞品价格调整)
        double competitiveFactor = calculateCompetitiveFactor(product);
        
        // 3. 用户系数 (VIP用户、新客户等)
        double customerFactor = calculateCustomerFactor(customer);
        
        // 4. 时间系数 (促销期、节假日等)
        double timeFactor = calculateTimeFactor(context.getCurrentTime());
        
        // 动态计算最终价格
        double finalFactor = supplyDemandFactor * competitiveFactor * customerFactor * timeFactor;
        
        return basePrice.multiply(BigDecimal.valueOf(finalFactor));
    }
    
    private double calculateSupplyDemandFactor(Product product) {
        int currentStock = product.getCurrentStock();
        int averageDailyDemand = product.getAverageDailyDemand();
        
        // 库存天数
        double stockDays = (double) currentStock / averageDailyDemand;
        
        if (stockDays < 3) {
            return 1.2; // 库存紧张，价格上调20%
        } else if (stockDays > 30) {
            return 0.9; // 库存过多，价格下调10%
        } else {
            return 1.0; // 正常库存，不调整
        }
    }
}
```

### 7.3 实时分析系统


**📊 业务指标的实时监控**
```
实时计算的业务场景：
🔸 网站流量分析：PV、UV、转化率的实时统计
🔸 销售业绩监控：实时销售额、订单量、客单价
🔸 系统性能监控：响应时间、错误率、吞吐量
🔸 用户行为分析：页面停留时间、跳出率、路径分析
```

**⚡ 实时指标计算引擎**
```java
public class RealTimeMetricsCalculator {
    
    public MetricsReport calculateWebMetrics(String timeRange) {
        MetricsReport report = new MetricsReport();
        
        // 1. 实时查询访问日志
        List<AccessLog> logs = getAccessLogs(timeRange);
        
        // 2. 动态计算各项指标
        report.setPv(calculatePV(logs));
        report.setUv(calculateUV(logs));
        report.setConversionRate(calculateConversionRate(logs));
        report.setBounceRate(calculateBounceRate(logs));
        
        return report;
    }
    
    private long calculatePV(List<AccessLog> logs) {
        // 页面浏览量 = 所有页面访问次数
        return logs.size();
    }
    
    private long calculateUV(List<AccessLog> logs) {
        // 独立访客数 = 不重复的用户ID数量
        return logs.stream()
                   .map(AccessLog::getUserId)
                   .distinct()
                   .count();
    }
    
    private double calculateConversionRate(List<AccessLog> logs) {
        // 转化率 = 完成目标行为的用户数 / 总访问用户数
        long totalUsers = calculateUV(logs);
        long convertedUsers = logs.stream()
                                  .filter(log -> "order_success".equals(log.getAction()))
                                  .map(AccessLog::getUserId)
                                  .distinct()
                                  .count();
        
        return totalUsers > 0 ? (double) convertedUsers / totalUsers * 100 : 0;
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 动态计算本质：运行时按需计算，用时间换空间
🔸 权衡核心：计算时间成本 vs 存储空间成本  
🔸 适用场景：数据变化频繁、访问频率低、存储成本高
🔸 技术实现：动态SQL、实时报表、配置解析、表达式求值
🔸 应用领域：个性化推荐、动态定价、实时分析
```

### 8.2 关键理解要点


**🔹 何时选择动态计算**
```
选择动态计算的判断标准：
✅ 数据更新频繁 (分钟级别变化)
✅ 查询模式多样 (无法预测所有查询组合)
✅ 存储成本敏感 (大数据量场景)
✅ 实时性要求高 (必须是最新结果)

避免动态计算的情况：
❌ 高频访问场景 (毫秒级响应要求)
❌ 计算复杂度极高 (耗时过长)
❌ 数据相对稳定 (小时级别才变化一次)
```

**🔹 性能优化策略**
```
缓存策略：
• 结果缓存：缓存常用查询的计算结果
• 中间结果缓存：缓存计算过程中的中间步骤
• 智能失效：数据变更时精确失效相关缓存

计算优化：
• 并行计算：将大计算任务拆分并行执行
• 增量计算：只计算变化的部分
• 索引优化：为动态查询建立合适的索引
```

**🔹 系统设计考虑**
```
架构设计：
• 计算层与存储层分离
• 支持水平扩展的计算集群
• 完善的监控和告警机制

容错机制：
• 计算超时保护
• 异常情况下的降级策略  
• 备份计算节点

资源控制：
• CPU和内存使用限制
• 并发计算任务数控制
• 优先级队列管理
```

### 8.3 实际应用价值


**💼 业务价值**
- **成本控制**：大幅减少存储成本，特别是大数据场景
- **业务灵活性**：支持快速的业务规则调整和个性化需求
- **数据实时性**：确保业务决策基于最新数据
- **系统扩展性**：避免预计算的组合爆炸问题

**🔧 技术价值**  
- **架构简化**：减少复杂的数据同步和一致性维护
- **开发效率**：一套逻辑处理多种业务场景
- **运维简化**：减少大量预计算任务的调度和监控

**核心记忆**：
- 动态计算是用计算时间换存储空间的设计思想
- 适用于数据变化频繁、查询灵活、存储敏感的场景  
- 核心技术包括动态SQL、实时报表、配置解析、表达式求值
- 关键是在响应时间和存储成本间找到最优平衡点