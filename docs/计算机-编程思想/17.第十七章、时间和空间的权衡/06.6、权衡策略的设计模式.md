---
title: 6、权衡策略的设计模式
---
## 📚 目录

1. [预计算模式：空间换时间的典型应用](#1-预计算模式空间换时间的典型应用)
2. [缓存模式：多级缓存的空间时间分配](#2-缓存模式多级缓存的空间时间分配)
3. [延迟加载模式：时间换空间的常见实现](#3-延迟加载模式时间换空间的常见实现)
4. [批处理模式：时间空间的批量优化](#4-批处理模式时间空间的批量优化)
5. [分治模式：递归中的空间时间权衡](#5-分治模式递归中的空间时间权衡)
6. [流水线模式：时间空间的并行优化](#6-流水线模式时间空间的并行优化)
7. [自适应模式：动态调整权衡策略](#7-自适应模式动态调整权衡策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 预计算模式：空间换时间的典型应用


### 1.1 什么是预计算模式


**🎯 核心思想**：把将来可能用到的结果提前算好存起来，用的时候直接拿，不用现算。

```
传统方式：每次需要时现场计算
用户请求 → 计算结果 → 返回结果 (耗时)

预计算方式：提前算好存储
初始化时 → 计算所有结果 → 存储
用户请求 → 直接查表 → 返回结果 (快速)
```

### 1.2 经典应用场景


**🔸 斐波那契数列优化**
```javascript
// ❌ 传统递归：每次都要重复计算
function fib(n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 大量重复计算
}

// ✅ 预计算：一次计算，多次使用  
class FibCalculator {
    constructor(maxN) {
        this.cache = [0, 1];  // 预先存储前两个值
        this.precompute(maxN);  // 预计算到最大值
    }
    
    precompute(maxN) {
        for (let i = 2; i <= maxN; i++) {
            this.cache[i] = this.cache[i-1] + this.cache[i-2];
        }
    }
    
    get(n) {
        return this.cache[n];  // O(1)直接获取
    }
}
```

**🔸 质数表预计算**
```javascript
// 用埃拉托色尼筛法预计算质数
class PrimeTable {
    constructor(limit) {
        this.isPrime = new Array(limit + 1).fill(true);
        this.primes = [];
        this.sieve(limit);
    }
    
    sieve(limit) {
        this.isPrime[0] = this.isPrime[1] = false;
        
        for (let i = 2; i * i <= limit; i++) {
            if (this.isPrime[i]) {
                // 标记i的倍数为非质数
                for (let j = i * i; j <= limit; j += i) {
                    this.isPrime[j] = false;
                }
            }
        }
        
        // 收集所有质数
        for (let i = 2; i <= limit; i++) {
            if (this.isPrime[i]) {
                this.primes.push(i);
            }
        }
    }
    
    // O(1)判断质数
    checkPrime(n) {
        return this.isPrime[n];
    }
}
```

### 1.3 权衡分析


```
预计算模式的权衡表：

┌─────────────┬──────────────┬──────────────┐
│    方面     │   传统计算   │   预计算     │
├─────────────┼──────────────┼──────────────┤
│ 查询时间    │   O(复杂度)  │    O(1)      │
│ 存储空间    │     少       │    多        │
│ 初始化时间  │     快       │    慢        │
│ 内存占用    │     低       │    高        │
│ 适用场景    │ 偶尔查询     │ 频繁查询     │
└─────────────┴──────────────┴──────────────┘
```

**💡 使用建议**
- ✅ **频繁查询**：同样的计算会被调用很多次
- ✅ **结果稳定**：计算结果不经常变化
- ✅ **可预知范围**：知道需要计算的数据范围
- ❌ **内存紧张**：可用内存很少的情况
- ❌ **数据量巨大**：预计算结果占用空间过大

---

## 2. 🗄️ 缓存模式：多级缓存的空间时间分配


### 2.1 缓存模式的本质


**🎯 核心理念**：把经常用到的数据放在"更近"的地方，避免重复的昂贵操作。

```
数据获取的成本层级：
内存变量 < 内存缓存 < 磁盘缓存 < 数据库查询 < 网络请求

缓存就是在这个链条中选择合适的存储位置
```

### 2.2 多级缓存架构


```
多级缓存示意图：

应用程序
    ↓ 查询请求
┌─────────────┐
│  L1: 内存   │ ← 最快，最小，最贵
│   (几MB)    │
├─────────────┤
│  L2: Redis  │ ← 快速，中等，中等
│   (几GB)    │
├─────────────┤
│ L3: 磁盘缓存 │ ← 较慢，大容量，便宜
│   (几TB)    │
└─────────────┘
    ↓ 缓存未命中
  数据库/API
```

### 2.3 实际缓存实现


**🔸 简单LRU缓存**
```javascript
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();  // 保持插入顺序
    }
    
    get(key) {
        if (this.cache.has(key)) {
            // 访问过的数据移到最后（最新）
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return null;
    }
    
    set(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.capacity) {
            // 删除最久未使用的（第一个）
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
}
```

**🔸 多级缓存管理器**
```javascript
class MultiLevelCache {
    constructor() {
        this.l1 = new LRUCache(100);      // 小而快的内存缓存
        this.l2 = new LRUCache(1000);     // 大一些的内存缓存
    }
    
    async get(key) {
        // 先查L1缓存
        let value = this.l1.get(key);
        if (value) return value;
        
        // 再查L2缓存
        value = this.l2.get(key);
        if (value) {
            this.l1.set(key, value);  // 提升到L1
            return value;
        }
        
        // 最后查数据库
        value = await this.queryDatabase(key);
        if (value) {
            this.l2.set(key, value);
            this.l1.set(key, value);
        }
        
        return value;
    }
    
    set(key, value) {
        this.l1.set(key, value);
        this.l2.set(key, value);
    }
}
```

### 2.4 缓存策略选择


| 策略类型 | **适用场景** | **优点** | **缺点** |
|---------|-------------|---------|---------|
| 🔄 **LRU** | `通用场景，访问有时间局部性` | `简单有效，符合直觉` | `可能频繁换出热点数据` |
| 🎯 **LFU** | `有明显热点数据` | `保护真正热点数据` | `实现复杂，冷启动慢` |
| ⏰ **TTL** | `数据有时效性` | `自动过期，内存可控` | `可能过早过期有用数据` |
| 🎲 **Random** | `访问模式随机` | `实现简单，无偏见` | `可能换出重要数据` |

---

## 3. ⏳ 延迟加载模式：时间换空间的常见实现


### 3.1 延迟加载的核心思想


**🎯 基本理念**：不要一开始就加载所有东西，用到的时候再加载。

```
传统加载方式：
程序启动 → 加载所有资源 → 占用大量内存 → 启动慢

延迟加载方式：
程序启动 → 只加载必需资源 → 启动快
需要时 → 动态加载具体资源 → 按需占用内存
```

### 3.2 常见延迟加载场景


**🔸 懒汉式单例模式**
```javascript
class DatabaseConnection {
    constructor() {
        this._connection = null;  // 不立即创建连接
    }
    
    // 用到的时候才创建
    getConnection() {
        if (!this._connection) {
            console.log('创建数据库连接...');
            this._connection = this.createConnection();
        }
        return this._connection;
    }
    
    createConnection() {
        // 模拟创建昂贵的数据库连接
        return { id: Date.now(), status: 'connected' };
    }
}

const db = new DatabaseConnection();  // 这时还没有真正连接
const conn = db.getConnection();       // 这时才真正建立连接
```

**🔸 图片延迟加载**
```javascript
class LazyImageLoader {
    constructor() {
        this.imageCache = new Map();
    }
    
    // 只有真正需要显示时才加载图片
    async loadImage(url) {
        if (this.imageCache.has(url)) {
            return this.imageCache.get(url);
        }
        
        console.log(`开始加载图片: ${url}`);
        const img = new Image();
        
        return new Promise((resolve) => {
            img.onload = () => {
                this.imageCache.set(url, img);
                resolve(img);
            };
            img.src = url;
        });
    }
    
    // 预先注册图片，但不加载
    registerImage(url) {
        return {
            url,
            loaded: false,
            load: () => this.loadImage(url)
        };
    }
}
```

### 3.3 延迟加载的实现模式


**🔸 Virtual Proxy（虚拟代理）**
```javascript
// 重量级对象
class ExpensiveObject {
    constructor(data) {
        console.log('创建重量级对象，很耗时...');
        this.data = this.processData(data);  // 假设这很耗时
    }
    
    processData(data) {
        // 模拟复杂的数据处理
        return data.map(item => item * 2);
    }
    
    getData() {
        return this.data;
    }
}

// 虚拟代理：延迟创建真实对象
class LazyExpensiveObject {
    constructor(data) {
        this._data = data;
        this._realObject = null;
    }
    
    // 只有真正调用方法时才创建对象
    getData() {
        if (!this._realObject) {
            this._realObject = new ExpensiveObject(this._data);
        }
        return this._realObject.getData();
    }
}

const lazyObj = new LazyExpensiveObject([1, 2, 3]);  // 很快，没有真正创建
const result = lazyObj.getData();                     // 这时才真正创建并计算
```

### 3.4 延迟加载权衡分析


```
延迟加载的权衡：

时间方面：
┌──────────────┬──────────────┬──────────────┐
│    阶段      │   立即加载   │   延迟加载   │
├──────────────┼──────────────┼──────────────┤
│   启动时间   │      慢      │      快      │
│   首次使用   │      快      │      慢      │
│   后续使用   │      快      │      快      │
└──────────────┴──────────────┴──────────────┘

空间方面：
- 延迟加载：用多少占多少内存
- 立即加载：一次性占用所有内存
```

**💡 适用场景判断**
- ✅ **大型应用**：有很多功能模块，用户可能只用其中一部分
- ✅ **资源昂贵**：创建对象的成本很高（时间、内存、网络）
- ✅ **使用不确定**：不确定某些功能是否会被使用
- ❌ **必需资源**：程序运行必需的核心资源
- ❌ **频繁访问**：会被频繁访问的资源

---

## 4. 📦 批处理模式：时间空间的批量优化


### 4.1 批处理的核心理念


**🎯 基本思想**：把多个小操作攒起来一起做，减少重复的开销成本。

```
单个处理方式：
操作1 → 开销 → 结果1
操作2 → 开销 → 结果2  
操作3 → 开销 → 结果3
总开销 = 3 × 单次开销

批量处理方式：
[操作1, 操作2, 操作3] → 一次开销 → [结果1, 结果2, 结果3]
总开销 = 1 × 单次开销 + 批处理额外成本
```

### 4.2 典型批处理应用


**🔸 数据库批量操作**
```javascript
class BatchProcessor {
    constructor(batchSize = 100) {
        this.batchSize = batchSize;
        this.pendingOperations = [];
        this.timer = null;
    }
    
    // 添加操作到批次中
    addOperation(operation) {
        this.pendingOperations.push(operation);
        
        // 达到批次大小或设置定时器
        if (this.pendingOperations.length >= this.batchSize) {
            this.processBatch();
        } else if (!this.timer) {
            // 设置最大等待时间，避免无限等待
            this.timer = setTimeout(() => this.processBatch(), 1000);
        }
    }
    
    // 批量处理操作
    async processBatch() {
        if (this.pendingOperations.length === 0) return;
        
        const batch = this.pendingOperations.splice(0);
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        
        try {
            // 批量执行数据库操作
            await this.executeBatch(batch);
            console.log(`批量处理了 ${batch.length} 个操作`);
        } catch (error) {
            console.error('批处理失败:', error);
            // 可以考虑重试或单个处理
        }
    }
    
    async executeBatch(operations) {
        // 模拟批量数据库操作
        const sql = this.buildBatchSQL(operations);
        return await this.database.query(sql);
    }
    
    buildBatchSQL(operations) {
        const values = operations.map(op => `('${op.name}', ${op.age})`).join(',');
        return `INSERT INTO users (name, age) VALUES ${values}`;
    }
}
```

**🔸 日志批量写入**
```javascript
class BatchLogger {
    constructor() {
        this.logBuffer = [];
        this.bufferSize = 50;
        this.flushInterval = 5000; // 5秒
        this.setupAutoFlush();
    }
    
    log(level, message) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            level,
            message
        };
        
        this.logBuffer.push(logEntry);
        
        // 缓冲区满了立即写入
        if (this.logBuffer.length >= this.bufferSize) {
            this.flush();
        }
    }
    
    // 批量写入日志文件
    flush() {
        if (this.logBuffer.length === 0) return;
        
        const logs = this.logBuffer.splice(0);
        const logText = logs.map(entry => 
            `[${entry.timestamp}] ${entry.level}: ${entry.message}`
        ).join('\n');
        
        // 一次性写入文件
        this.writeToFile(logText + '\n');
    }
    
    setupAutoFlush() {
        setInterval(() => this.flush(), this.flushInterval);
    }
    
    writeToFile(content) {
        // 模拟文件写入操作
        console.log('批量写入日志:', content.split('\n').length - 1, '条');
    }
}
```

### 4.3 批处理权衡考虑


| 方面 | **单个处理** | **批量处理** | **说明** |
|------|-------------|-------------|---------|
| 🚀 **响应时间** | `立即` | `延迟` | `批处理需要等待凑够批次` |
| 💾 **内存占用** | `低` | `高` | `需要缓存待处理的数据` |
| 🔧 **吞吐量** | `低` | `高` | `批量操作提高整体效率` |
| ⚡ **资源利用** | `低` | `高` | `减少重复的系统调用开销` |

**🎯 批处理策略**
- **按数量触发**：达到一定数量就处理
- **按时间触发**：超过最大等待时间就处理
- **按大小触发**：数据大小达到阈值就处理
- **混合策略**：结合多种触发条件

---

## 5. 🌳 分治模式：递归中的空间时间权衡


### 5.1 分治模式的本质


**🎯 核心思想**：把大问题分解成小问题，解决小问题后合并结果。

```
分治思想示意：

    大问题
    /    \
  子问题1 子问题2
  /  \    /  \
小问题 小问题 小问题 小问题

每层都需要：时间（计算）+ 空间（递归栈）
```

### 5.2 经典分治算法分析


**🔸 快速排序的空间权衡**
```javascript
// 标准快速排序：使用递归栈
function quickSort(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        const pivotIndex = partition(arr, left, right);
        
        quickSort(arr, left, pivotIndex - 1);    // 递归左半部分
        quickSort(arr, pivotIndex + 1, right);   // 递归右半部分
    }
}

function partition(arr, left, right) {
    const pivot = arr[right];
    let i = left - 1;
    
    for (let j = left; j < right; j++) {
        if (arr[j] <= pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
    return i + 1;
}

// 空间优化版本：迭代实现，避免递归栈
function quickSortIterative(arr) {
    const stack = [{left: 0, right: arr.length - 1}];
    
    while (stack.length > 0) {
        const {left, right} = stack.pop();
        
        if (left < right) {
            const pivotIndex = partition(arr, left, right);
            
            // 把待处理的区间压入栈
            stack.push({left: left, right: pivotIndex - 1});
            stack.push({left: pivotIndex + 1, right: right});
        }
    }
}
```

**🔸 归并排序的权衡选择**
```javascript
// 传统归并：需要额外数组空间
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));      // 额外空间
    const right = mergeSort(arr.slice(mid));        // 额外空间
    
    return merge(left, right);                      // 又需要额外空间
}

function merge(left, right) {
    const result = [];                              // 额外数组
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}

// 原地归并：节省空间但增加时间复杂度
function mergeSortInPlace(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        const mid = Math.floor((left + right) / 2);
        mergeSortInPlace(arr, left, mid);
        mergeSortInPlace(arr, mid + 1, right);
        mergeInPlace(arr, left, mid, right);
    }
}

function mergeInPlace(arr, left, mid, right) {
    // 原地合并，时间复杂度更高但节省空间
    let start = left, end = mid + 1;
    
    while (start <= mid && end <= right) {
        if (arr[start] <= arr[end]) {
            start++;
        } else {
            // 需要移动元素，比较耗时
            const value = arr[end];
            let index = end;
            while (index !== start) {
                arr[index] = arr[index - 1];
                index--;
            }
            arr[start] = value;
            start++;
            mid++;
            end++;
        }
    }
}
```

### 5.3 递归深度的空间管理


```
递归空间使用示意：

调用栈层次：
┌─────────────┐ ← 第n层递归
│  局部变量   │
├─────────────┤ ← 第n-1层递归  
│  局部变量   │
├─────────────┤ ← 第n-2层递归
│  局部变量   │
└─────────────┘ ← 第1层递归

空间使用 = 递归深度 × 每层变量空间
```

**🔸 尾递归优化**
```javascript
// 普通递归：每层都需要保存状态
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);  // 需要保存n的值等待递归返回
}

// 尾递归：可以优化为循环
function factorialTail(n, acc = 1) {
    if (n <= 1) return acc;
    return factorialTail(n - 1, n * acc);  // 所有计算在参数中完成
}

// 手动优化为循环
function factorialIterative(n) {
    let result = 1;
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

### 5.4 分治策略选择


| 算法类型 | **时间复杂度** | **空间复杂度** | **适用场景** |
|---------|---------------|---------------|-------------|
| 🚀 **快速排序(递归)** | `O(n log n)平均` | `O(log n)` | `一般排序需求` |
| 🚀 **快速排序(迭代)** | `O(n log n)平均` | `O(1)` | `内存受限环境` |
| 📊 **归并排序(标准)** | `O(n log n)` | `O(n)` | `稳定排序需求` |
| 📊 **归并排序(原地)** | `O(n log n)` | `O(log n)` | `空间受限但要稳定` |

---

## 6. 🔄 流水线模式：时间空间的并行优化


### 6.1 流水线模式的核心理念


**🎯 基本思想**：把一个复杂任务分解为多个阶段，不同阶段可以并行处理不同的数据。

```
传统串行处理：
数据1: 阶段A → 阶段B → 阶段C → 完成
数据2:               阶段A → 阶段B → 阶段C → 完成
数据3:                              阶段A → 阶段B → 阶段C

流水线并行处理：
时刻1: 数据1-阶段A
时刻2: 数据1-阶段B  数据2-阶段A  
时刻3: 数据1-阶段C  数据2-阶段B  数据3-阶段A
时刻4: 数据1-完成   数据2-阶段C  数据3-阶段B  数据4-阶段A
```

### 6.2 数据处理流水线实现


**🔸 简单流水线处理器**
```javascript
class Pipeline {
    constructor() {
        this.stages = [];
        this.buffers = [];  // 各阶段之间的缓冲区
    }
    
    // 添加处理阶段
    addStage(processor, bufferSize = 10) {
        this.stages.push(processor);
        this.buffers.push(new Queue(bufferSize));
        return this;
    }
    
    // 启动流水线
    start(inputData) {
        // 将输入数据放入第一个缓冲区
        inputData.forEach(data => this.buffers[0].enqueue(data));
        
        // 启动各个阶段的处理
        this.stages.forEach((processor, index) => {
            this.startStage(processor, index);
        });
    }
    
    startStage(processor, stageIndex) {
        const inputBuffer = this.buffers[stageIndex];
        const outputBuffer = this.buffers[stageIndex + 1];
        
        // 持续处理数据
        setInterval(() => {
            if (!inputBuffer.isEmpty()) {
                const data = inputBuffer.dequeue();
                const result = processor(data);
                
                if (outputBuffer) {
                    outputBuffer.enqueue(result);
                } else {
                    // 最后一个阶段，输出结果
                    console.log('处理完成:', result);
                }
            }
        }, 100);  // 每100ms检查一次
    }
}

// 使用示例
const pipeline = new Pipeline()
    .addStage(data => ({ ...data, parsed: true }))           // 解析阶段
    .addStage(data => ({ ...data, validated: true }))        // 验证阶段  
    .addStage(data => ({ ...data, processed: new Date() })); // 处理阶段

pipeline.start([
    { id: 1, content: 'data1' },
    { id: 2, content: 'data2' },
    { id: 3, content: 'data3' }
]);
```

**🔸 图片处理流水线**
```javascript
class ImagePipeline {
    constructor() {
        this.workers = {
            resize: new Worker('resize-worker.js'),
            filter: new Worker('filter-worker.js'),
            compress: new Worker('compress-worker.js')
        };
        this.setupPipeline();
    }
    
    setupPipeline() {
        // 配置worker之间的数据流转
        this.workers.resize.onmessage = (e) => {
            this.workers.filter.postMessage(e.data);
        };
        
        this.workers.filter.onmessage = (e) => {
            this.workers.compress.postMessage(e.data);
        };
        
        this.workers.compress.onmessage = (e) => {
            this.onImageProcessed(e.data);
        };
    }
    
    processImage(imageData) {
        // 启动流水线处理
        this.workers.resize.postMessage({
            type: 'resize',
            imageData,
            width: 800,
            height: 600
        });
    }
    
    onImageProcessed(result) {
        console.log('图片处理完成:', result);
    }
}
```

### 6.3 流水线的权衡分析


```
流水线模式权衡：

吞吐量：
┌──────────────┬──────────────┬──────────────┐
│    处理方式  │   串行处理   │   流水线     │
├──────────────┼──────────────┼──────────────┤
│ 单个任务时间 │      T       │      T       │
│ N个任务时间  │     N×T      │  T+(N-1)×t   │
│ 吞吐量       │     1/T      │     1/t      │
└──────────────┴──────────────┴──────────────┘
其中t是流水线节拍时间（通常t < T）

空间开销：
- 需要额外的缓冲区空间
- 可能需要多个处理单元同时工作
- 内存使用量 = 缓冲区数量 × 缓冲区大小
```

**💡 流水线优化策略**
- **平衡各阶段**：避免出现瓶颈阶段
- **缓冲区调优**：合适的缓冲区大小平衡内存和性能
- **异常处理**：某阶段故障不影响整个流水线
- **反压机制**：下游处理慢时的流量控制

---

## 7. 🎛️ 自适应模式：动态调整权衡策略


### 7.1 自适应模式的核心思想


**🎯 基本理念**：根据实际运行情况动态调整时间空间的权衡策略，找到当前环境下的最优平衡。

```
自适应调整流程：

监控指标 → 分析性能 → 调整策略 → 观察效果 → 继续监控
   ↑                                          ↓
   ←─────────── 反馈循环 ──────────────────────←
```

### 7.2 自适应缓存管理


**🔸 动态缓存大小调整**
```javascript
class AdaptiveCache {
    constructor(initialSize = 100) {
        this.cache = new Map();
        this.maxSize = initialSize;
        this.hitCount = 0;
        this.missCount = 0;
        this.adjustmentInterval = 10000; // 10秒调整一次
        
        this.startMonitoring();
    }
    
    get(key) {
        if (this.cache.has(key)) {
            this.hitCount++;
            // LRU更新
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        } else {
            this.missCount++;
            return null;
        }
    }
    
    set(key, value) {
        // 如果缓存满了，删除最老的
        if (this.cache.size >= this.maxSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
    
    // 根据命中率动态调整缓存大小
    adjustCacheSize() {
        const totalAccess = this.hitCount + this.missCount;
        if (totalAccess === 0) return;
        
        const hitRate = this.hitCount / totalAccess;
        const memoryUsage = this.getMemoryUsage();
        
        console.log(`当前命中率: ${(hitRate * 100).toFixed(1)}%`);
        console.log(`当前内存使用: ${memoryUsage}MB`);
        
        if (hitRate < 0.6 && memoryUsage < 100) {
            // 命中率低且内存充足，增加缓存
            this.maxSize = Math.floor(this.maxSize * 1.2);
            console.log(`增加缓存大小至: ${this.maxSize}`);
        } else if (hitRate > 0.9 && memoryUsage > 150) {
            // 命中率很高但内存紧张，减少缓存
            this.maxSize = Math.floor(this.maxSize * 0.9);
            console.log(`减少缓存大小至: ${this.maxSize}`);
        }
        
        // 重置统计
        this.hitCount = 0;
        this.missCount = 0;
    }
    
    startMonitoring() {
        setInterval(() => {
            this.adjustCacheSize();
        }, this.adjustmentInterval);
    }
    
    getMemoryUsage() {
        // 模拟内存使用量检测
        return this.cache.size * 0.1; // 假设每项占用0.1MB
    }
}
```

### 7.3 自适应算法选择


**🔸 动态排序算法选择器**
```javascript
class AdaptiveSorter {
    constructor() {
        this.performanceHistory = new Map();
        this.algorithms = {
            quick: this.quickSort,
            merge: this.mergeSort,
            heap: this.heapSort,
            insertion: this.insertionSort
        };
    }
    
    // 根据数据特征选择最优算法
    sort(arr) {
        const dataProfile = this.analyzeData(arr);
        const bestAlgorithm = this.selectAlgorithm(dataProfile);
        
        console.log(`数据规模: ${arr.length}, 选择算法: ${bestAlgorithm}`);
        
        const startTime = performance.now();
        const result = this.algorithms[bestAlgorithm].call(this, [...arr]);
        const endTime = performance.now();
        
        // 记录性能数据
        this.recordPerformance(bestAlgorithm, dataProfile, endTime - startTime);
        
        return result;
    }
    
    analyzeData(arr) {
        return {
            size: arr.length,
            sortedness: this.calculateSortedness(arr),
            duplicates: this.calculateDuplicates(arr)
        };
    }
    
    selectAlgorithm(profile) {
        const { size, sortedness, duplicates } = profile;
        
        // 小数组用插入排序
        if (size < 50) {
            return 'insertion';
        }
        
        // 已经基本有序用插入排序
        if (sortedness > 0.8) {
            return 'insertion';
        }
        
        // 大数组且需要稳定排序用归并
        if (size > 10000 && duplicates > 0.3) {
            return 'merge';
        }
        
        // 一般情况用快排
        return 'quick';
    }
    
    calculateSortedness(arr) {
        let orderedPairs = 0;
        for (let i = 0; i < arr.length - 1; i++) {
            if (arr[i] <= arr[i + 1]) {
                orderedPairs++;
            }
        }
        return orderedPairs / (arr.length - 1);
    }
    
    calculateDuplicates(arr) {
        const unique = new Set(arr);
        return 1 - (unique.size / arr.length);
    }
    
    recordPerformance(algorithm, profile, time) {
        const key = `${algorithm}_${profile.size}`;
        if (!this.performanceHistory.has(key)) {
            this.performanceHistory.set(key, []);
        }
        this.performanceHistory.get(key).push(time);
    }
    
    // 简化的排序算法实现
    quickSort(arr) {
        if (arr.length <= 1) return arr;
        const pivot = arr[Math.floor(arr.length / 2)];
        const left = arr.filter(x => x < pivot);
        const middle = arr.filter(x => x === pivot);
        const right = arr.filter(x => x > pivot);
        return [...this.quickSort(left), ...middle, ...this.quickSort(right)];
    }
    
    insertionSort(arr) {
        for (let i = 1; i < arr.length; i++) {
            let key = arr[i];
            let j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
        return arr;
    }
    
    mergeSort(arr) {
        if (arr.length <= 1) return arr;
        const mid = Math.floor(arr.length / 2);
        const left = this.mergeSort(arr.slice(0, mid));
        const right = this.mergeSort(arr.slice(mid));
        return this.merge(left, right);
    }
    
    merge(left, right) {
        const result = [];
        let i = 0, j = 0;
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                result.push(left[i++]);
            } else {
                result.push(right[j++]);
            }
        }
        return result.concat(left.slice(i)).concat(right.slice(j));
    }
    
    heapSort(arr) {
        // 简化的堆排序实现
        return arr.sort((a, b) => a - b);
    }
}
```

### 7.4 自适应负载均衡


**🔸 动态负载分配**
```javascript
class AdaptiveLoadBalancer {
    constructor(servers) {
        this.servers = servers.map(url => ({
            url,
            load: 0,
            responseTime: 0,
            errorCount: 0,
            weight: 1
        }));
        this.requestCount = 0;
        this.adjustmentInterval = 5000; // 5秒调整一次
        
        this.startAdaptation();
    }
    
    // 选择最优服务器
    selectServer() {
        // 根据当前权重和负载情况选择
        let bestServer = null;
        let bestScore = -1;
        
        for (const server of this.servers) {
            // 综合考虑响应时间、错误率、当前负载
            const score = this.calculateScore(server);
            if (score > bestScore) {
                bestScore = score;
                bestServer = server;
            }
        }
        
        bestServer.load++;
        return bestServer;
    }
    
    calculateScore(server) {
        const errorRate = server.errorCount / (this.requestCount + 1);
        const loadFactor = 1 / (server.load + 1);
        const speedFactor = server.responseTime > 0 ? 1000 / server.responseTime : 1;
        
        return server.weight * loadFactor * speedFactor * (1 - errorRate);
    }
    
    // 记录请求结果
    recordResponse(server, responseTime, isError = false) {
        server.load = Math.max(0, server.load - 1);
        server.responseTime = (server.responseTime * 0.8) + (responseTime * 0.2); // 移动平均
        
        if (isError) {
            server.errorCount++;
        }
        
        this.requestCount++;
    }
    
    // 动态调整服务器权重
    adjustWeights() {
        const avgResponseTime = this.calculateAverageResponseTime();
        const avgErrorRate = this.calculateAverageErrorRate();
        
        for (const server of this.servers) {
            const responseRatio = avgResponseTime / (server.responseTime || avgResponseTime);
            const errorRatio = (server.errorCount / this.requestCount) / avgErrorRate;
            
            // 响应快、错误少的服务器增加权重
            const newWeight = responseRatio * (1 / (errorRatio || 1));
            server.weight = Math.max(0.1, Math.min(5, newWeight));
            
            console.log(`服务器 ${server.url} 权重调整为: ${server.weight.toFixed(2)}`);
        }
    }
    
    calculateAverageResponseTime() {
        const total = this.servers.reduce((sum, s) => sum + s.responseTime, 0);
        return total / this.servers.length || 1;
    }
    
    calculateAverageErrorRate() {
        const total = this.servers.reduce((sum, s) => sum + s.errorCount, 0);
        return (total / this.requestCount) / this.servers.length || 0.01;
    }
    
    startAdaptation() {
        setInterval(() => {
            this.adjustWeights();
        }, this.adjustmentInterval);
    }
}
```

### 7.5 自适应模式的设计原则


| 设计原则 | **说明** | **实现要点** |
|---------|---------|-------------|
| 📊 **监控为先** | `持续收集性能指标` | `响应时间、吞吐量、资源使用率` |
| 🎯 **渐进调整** | `小步快跑，避免剧烈变化` | `使用衰减系数，限制调整幅度` |
| 🔄 **反馈闭环** | `调整后观察效果` | `A/B测试，效果评估机制` |
| 🛡️ **稳定优先** | `保证系统稳定性` | `设置调整边界，异常检测` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的设计模式


```
🔸 预计算模式：提前算好存起来，查询时O(1)获取
🔸 缓存模式：把常用数据放在快速访问的地方
🔸 延迟加载：用到时才加载，节省启动时间和内存
🔸 批处理模式：多个操作一起做，减少重复开销
🔸 分治模式：大问题拆小问题，注意递归栈空间
🔸 流水线模式：多阶段并行处理，提高整体吞吐量
🔸 自适应模式：根据运行情况动态调整策略
```

### 8.2 权衡决策的关键因素


**🔹 应用场景分析**
- **数据规模**：小数据简单方法，大数据复杂优化
- **访问模式**：频繁访问用缓存，偶尔访问按需加载
- **资源约束**：内存紧张省空间，CPU紧张省时间
- **响应要求**：实时性要求高优先时间，离线处理可优先空间

**🔹 性能监控指标**
```
时间相关：
- 响应时间（RT）：单次操作耗时
- 吞吐量（TPS）：单位时间处理请求数
- 延迟分布：P50、P95、P99延迟

空间相关：  
- 内存使用量：峰值和平均值
- 存储空间：磁盘占用情况
- 缓存命中率：缓存效果评估
```

### 8.3 实际应用指导原则


**💡 选择策略的经验法则**

```
数据量级指导：
┌─────────────┬─────────────┬─────────────┐
│   数据规模  │  推荐策略   │    理由     │
├─────────────┼─────────────┼─────────────┤
│   < 1K      │   简单方法  │ 优化收益小  │
│  1K - 10K   │   基础缓存  │ 平衡收益   │
│ 10K - 100K  │  多级缓存   │ 明显收益   │
│  > 100K     │  复合策略   │ 必须优化   │
└─────────────┴─────────────┴─────────────┘
```

**🎯 组合使用建议**
- **预计算 + 缓存**：预算热点数据，缓存计算结果
- **延迟加载 + 批处理**：按需加载，批量处理减少开销
- **分治 + 流水线**：分解任务，流水线并行执行
- **自适应调节**：根据实际情况动态切换策略

### 8.4 常见误区与注意事项


**⚠️ 设计误区**
- **过度优化**：不考虑实际需求盲目优化
- **单一策略**：只使用一种模式，不考虑组合
- **忽视监控**：缺乏性能数据支撑决策
- **静态设计**：不根据实际运行情况调整

**✅ 最佳实践**
- **测量优先**：先测量再优化，有数据支撑
- **渐进改进**：小步快跑，逐步优化
- **监控告警**：建立完善的监控体系
- **文档记录**：记录权衡决策的原因和效果

**核心记忆口诀**：
- 预计算空间换时间，缓存就近放常用
- 延迟加载省启动，批处理减少重复功  
- 分治递归要小心，流水并行提吞吐
- 自适应根据场景调，权衡策略要灵活