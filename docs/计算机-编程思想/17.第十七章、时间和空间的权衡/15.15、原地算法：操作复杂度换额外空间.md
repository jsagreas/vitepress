---
title: 15、原地算法：操作复杂度换额外空间
---
## 📚 目录

1. [原地算法基本概念](#1-原地算法基本概念)
2. [权衡设计思想](#2-权衡设计思想)
3. [原地排序算法对比](#3-原地排序算法对比)
4. [数组原地操作](#4-数组原地操作)
5. [字符串原地处理](#5-字符串原地处理)
6. [矩阵原地变换](#6-矩阵原地变换)
7. [应用场景分析](#7-应用场景分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ 原地算法基本概念


### 1.1 什么是原地算法


**🔸 定义理解**
```
原地算法（In-place Algorithm）：
直接在输入的数据结构上进行操作，不需要额外的存储空间
就像在原来的位置上直接改造，而不是搬到别的地方重新建造
```

**💡 生活类比**
```
传统做法：装修房子时先搬出去，租个临时住处
原地做法：边住边装修，在原房子里直接改造

传统算法：需要额外空间存储中间结果
原地算法：直接在原数据上修改，省下额外空间
```

### 1.2 原地算法的核心特征


**📊 空间复杂度要求**
```
严格原地：O(1) 额外空间
- 只能使用常数个额外变量
- 不能申请与输入规模相关的空间

宽松原地：O(log n) 额外空间  
- 允许递归调用栈占用空间
- 允许少量辅助变量

示例对比：
非原地：需要 O(n) 额外数组
原地：只需要几个临时变量
```

**⚡ 基本操作方式**
```
核心思想：就地修改
1. 交换元素位置
2. 覆盖原有数据
3. 利用数据本身存储信息
4. 巧妙利用索引关系

典型操作：
- 双指针移动
- 数据交换
- 标记位设置
- 循环移位
```

---

## 2. ⚖️ 权衡设计思想


### 2.1 时间vs空间的权衡本质


**🔸 权衡体现**
```
牺牲的"时间"：
✗ 算法设计更复杂
✗ 编程实现难度增加
✗ 代码可读性下降  
✗ 调试难度加大
✗ 有时执行时间也会增加

获得的"空间"：
✓ 节省额外存储空间
✓ 降低内存使用峰值
✓ 减少内存分配开销
✓ 提高缓存命中率
✓ 适合大数据处理
```

### 2.2 设计复杂度分析


**🧠 算法设计复杂度对比**

| 算法类型 | **设计难度** | **实现复杂度** | **调试难度** | **空间效率** |
|---------|------------|---------------|-------------|-------------|
| 🔸 **传统算法** | `简单直观` | `容易实现` | `容易调试` | `需要额外空间` |
| 🔸 **原地算法** | `需要巧思` | `实现复杂` | `调试困难` | `节省空间` |

**💭 设计思维转变**
```
传统思维：
输入 → 辅助空间处理 → 输出结果

原地思维：  
输入 → 就地变换 → 直接输出
需要考虑：如何不破坏有用信息的前提下进行变换
```

### 2.3 何时选择原地算法


**✅ 适合使用原地算法的场景**
```
🔸 内存受限环境
- 嵌入式系统
- 移动设备应用
- 内存紧张的服务器

🔸 大数据处理
- 数据量超过可用内存
- 需要处理TB级别数据
- 内存分配成本高

🔸 性能敏感场景  
- 实时系统要求
- 高频交易系统
- 游戏引擎渲染

🔸 系统级编程
- 操作系统内核
- 数据库系统
- 网络协议栈
```

---

## 3. 📊 原地排序算法对比


### 3.1 快速排序 vs 归并排序


**⚡ 快速排序（原地实现）**
```java
// 原地快速排序
public void quickSort(int[] arr, int left, int right) {
    if (left < right) {
        int pivot = partition(arr, left, right);  // 原地分区
        quickSort(arr, left, pivot - 1);
        quickSort(arr, pivot + 1, right);
    }
}

private int partition(int[] arr, int left, int right) {
    int pivot = arr[right];  // 选择最后一个元素作为基准
    int i = left - 1;        // 小于基准的元素的索引
    
    for (int j = left; j < right; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);  // 原地交换，无额外空间
        }
    }
    swap(arr, i + 1, right);
    return i + 1;
}
```

**🔄 归并排序（非原地实现）**
```java
// 传统归并排序需要额外空间
public void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);  // 需要额外数组
    }
}

private void merge(int[] arr, int left, int mid, int right) {
    int[] temp = new int[right - left + 1];  // 需要O(n)额外空间
    // 合并逻辑...
}
```

**📈 对比分析**

| 排序算法 | **空间复杂度** | **是否原地** | **稳定性** | **平均时间** | **适用场景** |
|---------|---------------|-------------|-----------|-------------|-------------|
| 🔸 **快速排序** | `O(log n)` | `✅ 是` | `❌ 不稳定` | `O(n log n)` | `内存受限` |
| 🔸 **归并排序** | `O(n)` | `❌ 否` | `✅ 稳定` | `O(n log n)` | `稳定性要求` |

### 3.2 其他原地排序算法


**🔄 堆排序（原地实现）**
```java
public void heapSort(int[] arr) {
    int n = arr.length;
    
    // 构建最大堆（原地操作）
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个提取元素（原地操作）
    for (int i = n - 1; i > 0; i--) {
        swap(arr, 0, i);        // 将最大值放到末尾
        heapify(arr, i, 0);     // 重新调整堆
    }
}
```

**💡 原地排序的巧妙之处**
```
核心技巧：
🔸 双指针技术：两端向中间移动
🔸 交换操作：直接交换元素位置
🔸 分治思想：递归处理子问题
🔸 堆结构：利用数组索引关系

空间节省计算：
1000万个整数排序
传统归并：需要额外40MB内存
原地快排：只需要几个变量（几百字节）
节省空间：99.99%+
```

---

## 4. 🔄 数组原地操作


### 4.1 数组原地反转


**🔄 基本反转操作**
```java
// 原地反转数组
public void reverse(int[] arr) {
    int left = 0, right = arr.length - 1;
    
    while (left < right) {
        // 交换两端元素
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        
        left++;
        right--;
    }
}
```

**🎯 操作过程图解**
```
初始状态：[1, 2, 3, 4, 5]
          ↑           ↑
        left        right

第1步：   [5, 2, 3, 4, 1]  交换1和5
             ↑     ↑
           left  right

第2步：   [5, 4, 3, 2, 1]  交换2和4
                ↑
            left=right (结束)

结果：     [5, 4, 3, 2, 1]
```

### 4.2 数组原地去重


**✅ 有序数组去重**
```java
// 原地移除有序数组中的重复元素
public int removeDuplicates(int[] arr) {
    if (arr.length <= 1) return arr.length;
    
    int writeIndex = 1;  // 写入位置
    
    for (int readIndex = 1; readIndex < arr.length; readIndex++) {
        if (arr[readIndex] != arr[readIndex - 1]) {
            arr[writeIndex] = arr[readIndex];  // 原地覆盖
            writeIndex++;
        }
    }
    
    return writeIndex;  // 返回新长度
}
```

**📊 去重过程演示**
```
输入数组：[1, 1, 2, 2, 2, 3, 4, 4]
读写指针：  r w

步骤1：[1, 1, 2, 2, 2, 3, 4, 4]  读到重复的1，跳过
           r w

步骤2：[1, 2, 2, 2, 2, 3, 4, 4]  读到不同的2，写入
              r  w

步骤3：[1, 2, 3, 2, 2, 3, 4, 4]  读到不同的3，写入
                 r     w

最终：[1, 2, 3, 4, 2, 3, 4, 4]  前4个元素为结果
                    w

有效长度：4
```

### 4.3 数组原地重排


**🔄 奇偶数分离**
```java
// 原地将奇数放前面，偶数放后面
public void partitionOddEven(int[] arr) {
    int left = 0, right = arr.length - 1;
    
    while (left < right) {
        // 从左找偶数
        while (left < right && arr[left] % 2 == 1) {
            left++;
        }
        
        // 从右找奇数
        while (left < right && arr[right] % 2 == 0) {
            right--;
        }
        
        // 交换奇偶数
        if (left < right) {
            swap(arr, left, right);
        }
    }
}
```

**🎯 重排策略对比**

| 策略类型 | **空间复杂度** | **时间复杂度** | **稳定性** | **实现难度** |
|---------|---------------|---------------|-----------|-------------|
| 🔸 **原地双指针** | `O(1)` | `O(n)` | `不稳定` | `中等` |
| 🔸 **辅助数组** | `O(n)` | `O(n)` | `稳定` | `简单` |

---

## 5. 📝 字符串原地处理


### 5.1 字符数组 vs 字符串对象


**🔸 可变性差异**
```java
// Java中字符串不可变，需要用字符数组
String str = "hello";        // 不可修改
char[] chars = str.toCharArray(); // 可以原地修改

// 错误做法：字符串拼接（非原地）
String result = "";
for (char c : chars) {
    result += c;  // 每次创建新字符串对象
}

// 正确做法：原地修改字符数组
public void processInPlace(char[] chars) {
    // 直接修改字符数组内容
}
```

### 5.2 原地字符串反转


**🔄 字符数组原地反转**
```java
// 原地反转字符数组
public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;
    
    while (left < right) {
        // 交换字符
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        
        left++;
        right--;
    }
}
```

### 5.3 原地字符替换


**🔧 空格替换示例**
```java
// 将字符数组中的空格替换为%20
public void replaceSpaces(char[] chars, int trueLength) {
    int spaceCount = 0;
    
    // 统计空格数量
    for (int i = 0; i < trueLength; i++) {
        if (chars[i] == ' ') {
            spaceCount++;
        }
    }
    
    // 从后往前替换（避免覆盖）
    int newLength = trueLength + spaceCount * 2;
    int i = newLength - 1;
    
    for (int j = trueLength - 1; j >= 0; j--) {
        if (chars[j] == ' ') {
            chars[i--] = '0';
            chars[i--] = '2';  
            chars[i--] = '%';
        } else {
            chars[i--] = chars[j];
        }
    }
}
```

**💡 原地替换的关键技巧**
```
核心策略：从后往前处理
原因分析：
- 替换后长度增加，从前往后会覆盖未处理的数据
- 从后往前处理，已处理的位置不会再被访问
- 避免了数据覆盖的问题

示例："a b" → "a%20b"
从后往前：b → %20 → a，不会覆盖
从前往后：a → %20会覆盖b的位置
```

---

## 6. 🔄 矩阵原地变换


### 6.1 矩阵原地旋转


**🔄 90度顺时针旋转**
```java
// 原地旋转矩阵90度（顺时针）
public void rotate(int[][] matrix) {
    int n = matrix.length;
    
    // 第一步：沿主对角线翻转（转置）
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    
    // 第二步：每行水平翻转
    for (int i = 0; i < n; i++) {
        int left = 0, right = n - 1;
        while (left < right) {
            int temp = matrix[i][left];
            matrix[i][left] = matrix[i][right];
            matrix[i][right] = temp;
            left++;
            right--;
        }
    }
}
```

**🎯 旋转过程图解**
```
原始矩阵：          转置后：            最终结果：
[1, 2, 3]          [1, 4, 7]          [7, 4, 1]
[4, 5, 6]    →     [2, 5, 8]    →     [8, 5, 2]
[7, 8, 9]          [3, 6, 9]          [9, 6, 3]

步骤分解：
1. 转置：matrix[i][j] ↔ matrix[j][i]
2. 水平翻转：每行左右对称交换
```

### 6.2 矩阵原地转置


**🔄 方阵原地转置**
```java
// 原地转置方阵（行列互换）
public void transpose(int[][] matrix) {
    int n = matrix.length;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            // 只处理上三角区域，避免重复交换
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
```

### 6.3 螺旋矩阵填充


**🌀 原地螺旋遍历**
```java
// 将一维数组原地重排为螺旋矩阵
public int[][] generateMatrix(int n) {
    int[][] matrix = new int[n][n];
    int num = 1;
    
    int top = 0, bottom = n - 1;
    int left = 0, right = n - 1;
    
    while (top <= bottom && left <= right) {
        // 从左到右填充上边
        for (int j = left; j <= right; j++) {
            matrix[top][j] = num++;
        }
        top++;
        
        // 从上到下填充右边
        for (int i = top; i <= bottom; i++) {
            matrix[i][right] = num++;
        }
        right--;
        
        // 从右到左填充下边
        for (int j = right; j >= left; j--) {
            matrix[bottom][j] = num++;
        }
        bottom--;
        
        // 从下到上填充左边
        for (int i = bottom; i >= top; i--) {
            matrix[i][left] = num++;
        }
        left++;
    }
    
    return matrix;
}
```

---

## 7. 🎯 应用场景分析


### 7.1 内存受限环境


**🔸 嵌入式系统应用**
```
场景特点：
- RAM只有几KB到几MB
- 每字节内存都很珍贵
- 不能频繁分配释放内存

典型应用：
✓ 传感器数据处理：原地滤波算法
✓ 图像处理：原地图像变换
✓ 音频处理：原地音频效果
✓ 控制算法：原地PID计算

优势体现：
- 避免内存碎片
- 减少分配开销
- 提高实时性能
```

### 7.2 大数据处理场景


**🔸 海量数据处理**
```java
// 处理TB级别数据的原地操作示例
public class BigDataInPlace {
    
    // 原地数据清洗：移除无效记录
    public int cleanDataInPlace(DataRecord[] records) {
        int writeIndex = 0;
        
        for (int readIndex = 0; readIndex < records.length; readIndex++) {
            if (isValid(records[readIndex])) {
                records[writeIndex] = records[readIndex];
                writeIndex++;
            }
        }
        
        return writeIndex;  // 有效数据长度
    }
    
    // 原地数据分区：按某个键值分组
    public void partitionByKey(DataRecord[] records, String key) {
        // 原地分区逻辑，避免创建新数组
    }
}
```

**📊 大数据场景效益分析**

| 数据规模 | **传统方法内存** | **原地方法内存** | **节省比例** | **处理时间** |
|---------|-----------------|-----------------|-------------|-------------|
| 🔸 **1GB数据** | `2GB` | `1GB` | `50%` | `相当` |
| 🔸 **10GB数据** | `20GB` | `10GB` | `50%` | `更快` |
| 🔸 **100GB数据** | `内存不足` | `100GB` | `可处理` | `可接受` |

### 7.3 实时系统应用


**⚡ 实时性能要求**
```
实时系统特点：
- 严格的时间约束
- 内存分配延迟不可控
- 垃圾回收影响实时性

原地算法优势：
✓ 避免动态内存分配
✓ 减少垃圾回收压力  
✓ 提高时间确定性
✓ 降低延迟抖动

应用实例：
- 游戏引擎：原地物理计算
- 交易系统：原地价格计算
- 音视频：原地编解码
- 控制系统：原地反馈计算
```

### 7.4 性能优化场景


**🚀 缓存友好性分析**
```
内存访问模式对比：

传统算法：
输入数据 → 辅助内存 → 输出数据
缓存命中率：较低（跨内存区域访问）

原地算法：
输入数据 → 就地修改 → 直接输出  
缓存命中率：较高（局部性访问）

性能提升：
- L1缓存命中率：+20-40%
- 内存带宽利用：+30-50%
- 整体性能：+15-25%
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 原地算法本质：在原数据结构上直接操作，节省额外空间
🔸 权衡思想：牺牲算法设计复杂度，换取空间效率
🔸 基本技巧：双指针、数据交换、巧妙利用索引
🔸 适用场景：内存受限、大数据处理、实时系统
🔸 设计原则：保证正确性的前提下最小化空间使用
```

### 8.2 关键理解要点


**🔹 时间与空间权衡的本质**
```
权衡不仅仅是运行时间：
- 开发时间：设计和实现更复杂
- 调试时间：问题定位更困难
- 维护时间：代码理解和修改更难

但换来的空间收益：
- 内存使用：显著减少
- 缓存效率：明显提升  
- 系统可扩展性：大幅改善
```

**🔹 原地算法的设计思维**
```
核心转变：
从"创建新的"到"修改原有的"
从"空间换时间"到"时间换空间"
从"简单直观"到"巧妙精致"

设计要点：
- 如何在不破坏有用信息的前提下进行变换
- 如何利用已处理的空间存储中间结果
- 如何设计操作顺序避免数据覆盖
```

**🔹 算法选择的实际考量**
```
选择原地算法的时机：
✅ 内存是稀缺资源
✅ 数据规模巨大
✅ 性能要求严格
✅ 系统级编程

选择传统算法的时机：
✅ 内存充足
✅ 开发效率优先
✅ 代码可读性重要
✅ 稳定性要求高
```

### 8.3 实际应用价值


**🎯 工程实践意义**
- **系统设计**：在资源受限环境下的最佳选择
- **算法优化**：深度优化的重要手段
- **面试准备**：考查算法设计能力的经典题型
- **技能提升**：培养精细化编程思维

**🔧 学习建议**
- **理解本质**：先理解权衡思想，再学习具体技巧
- **多练习**：通过大量练习培养原地操作的直觉
- **对比分析**：对比原地与非原地方法的优劣
- **实际应用**：在真实项目中尝试应用原地算法

**核心记忆**：
- 原地算法核心是就地修改，省空间但增加设计复杂度
- 双指针、交换、覆盖是三大基本技巧
- 适用于内存受限、大数据、实时系统等场景
- 权衡的不只是运行时间，更是整个软件生命周期的成本