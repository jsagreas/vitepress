---
title: 15、模块化设计
---
## 📚 目录

1. [模块化设计核心理念](#1-模块化设计核心理念)
2. [高内聚低耦合原则](#2-高内聚低耦合原则)
3. [模块边界划分策略](#3-模块边界划分策略)
4. [接口与实现分离](#4-接口与实现分离)
5. [依赖管理策略](#5-依赖管理策略)
6. [模块协作与通信机制](#6-模块协作与通信机制)
7. [组合优于继承的设计思维](#7-组合优于继承的设计思维)
8. [分而治之的问题分解](#8-分而治之的问题分解)
9. [模块生命周期管理](#9-模块生命周期管理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🧩 模块化设计核心理念


### 1.1 什么是模块化设计


> **模块化设计**：把复杂的大问题分解成多个小的、独立的、可管理的模块，每个模块专注解决特定的问题。

**🏠 生活中的模块化例子**
```
现代住宅设计：
┌─────────────────────────────────┐
│            整栋房子              │
├─────────┬─────────┬─────────────┤
│  客厅   │  厨房   │    卧室     │ ← 每个房间是一个功能模块
├─────────┼─────────┼─────────────┤
│  卫生间 │  书房   │   储藏室    │
└─────────┴─────────┴─────────────┘

特点：
• 每个房间功能明确（高内聚）
• 房间之间通过门连接（低耦合）
• 可以独立装修改造（独立性）
• 组合起来形成完整住宅（协作性）
```

### 1.2 为什么需要模块化


**🎯 核心价值**
- **降低复杂度**：把大问题变成小问题
- **提高可维护性**：修改一个模块不影响其他模块
- **增强复用性**：模块可以在不同地方重复使用
- **便于团队协作**：不同人可以负责不同模块

**📈 项目规模对比**
```
非模块化代码（1000行）：
┌─────────────────────────────────┐
│  所有功能混在一起的大文件        │ ← 难以理解和维护
│  用户管理+订单处理+支付+...     │
└─────────────────────────────────┘

模块化代码：
┌─────────┬─────────┬─────────┬─────────┐
│用户模块 │订单模块 │支付模块 │通知模块 │ ← 清晰明确
│(200行) │(250行) │(300行) │(150行) │
└─────────┴─────────┴─────────┴─────────┘
```

---

## 2. 🎯 高内聚低耦合原则


### 2.1 什么是内聚和耦合


**🔸 内聚（Cohesion）**：模块内部元素之间的紧密程度
- **高内聚**：模块内的东西都是为了同一个目标服务
- **低内聚**：模块内的东西各干各的，关系松散

**🔸 耦合（Coupling）**：模块与模块之间的依赖程度
- **低耦合**：模块之间依赖关系简单清晰
- **高耦合**：模块之间关系复杂，互相纠缠

### 2.2 高内聚的具体表现


**✅ 好的高内聚示例**
```javascript
// 用户管理模块 - 所有功能都围绕"用户"
class UserManager {
    createUser(userData) { /* 创建用户 */ }
    updateUser(userId, newData) { /* 更新用户信息 */ }
    deleteUser(userId) { /* 删除用户 */ }
    findUser(userId) { /* 查找用户 */ }
    validateUser(userData) { /* 验证用户数据 */ }
}
```

**❌ 坏的低内聚示例**
```javascript
// 混乱的模块 - 什么都干
class MessyManager {
    createUser(userData) { /* 创建用户 */ }
    sendEmail(email) { /* 发送邮件 */ }
    calculateTax(amount) { /* 计算税费 */ }
    drawChart(data) { /* 绘制图表 */ }
}
```

### 2.3 低耦合的设计方法


**🎯 关键策略**
1. **明确接口**：模块间通过定义好的接口交流
2. **减少依赖**：一个模块不需要知道另一个模块的内部细节
3. **数据传递**：通过参数传递数据，而不是直接访问

**✅ 低耦合示例**
```javascript
// 订单模块不直接依赖用户模块的内部实现
class OrderService {
    createOrder(userId, products) {
        // 通过接口获取用户信息，不关心内部实现
        const user = UserService.getUser(userId);
        if (user) {
            return this.processOrder(user, products);
        }
    }
}
```

---

## 3. 🗺️ 模块边界划分策略


### 3.1 按业务功能划分


**🏢 电商系统模块划分示例**
```
电商系统模块结构：
┌─────────────────────────────────────────┐
│              电商平台                    │
├─────────┬─────────┬─────────┬─────────────┤
│用户模块 │商品模块 │订单模块 │  支付模块   │
├─────────┼─────────┼─────────┼─────────────┤
│库存模块 │物流模块 │评价模块 │  通知模块   │
└─────────┴─────────┴─────────┴─────────────┘

每个模块负责：
• 用户模块：注册、登录、个人信息管理
• 订单模块：下单、订单状态管理、订单查询
• 支付模块：支付处理、退款、账单
```

### 3.2 模块边界判断标准


**📏 划分原则**
1. **职责单一**：一个模块只做一类事情
2. **数据相关**：经常一起使用的数据放在同一模块
3. **变化频率**：变化频率相近的功能放在一起
4. **团队结构**：考虑团队的组织结构

**🎯 边界划分检验**
```
好的模块边界特征：
✅ 模块内部数据流动频繁
✅ 模块间数据传递较少
✅ 修改一个功能只影响一个模块
✅ 模块可以独立测试

坏的模块边界特征：
❌ 模块间频繁调用
❌ 修改一个功能需要改多个模块
❌ 数据在多个模块间来回传递
```

### 3.3 边界精细化管理


**🔧 边界控制策略**
```javascript
// 清晰的模块边界定义
class UserModule {
    // 对外接口 - 其他模块可以调用
    static getUser(userId) { }
    static updateUser(userId, data) { }
    
    // 内部方法 - 其他模块不能直接调用
    #validateUserData(data) { }
    #saveToDatabase(userData) { }
}

// 其他模块只能通过公开接口访问
class OrderModule {
    createOrder(userId, products) {
        // 只能调用 UserModule 的公开接口
        const user = UserModule.getUser(userId);
        // 不能调用 UserModule.#validateUserData() 
    }
}
```

---

## 4. 🎭 接口与实现分离


### 4.1 接口分离的核心思想


> **接口与实现分离**：定义"做什么"和"怎么做"是两回事，使用者只需要知道"做什么"，不需要关心"怎么做"。

**🚗 生活中的例子**
```
开车的接口：
┌─────────────────┐
│  油门踏板       │ ← 加速（做什么）
│  刹车踏板       │ ← 减速（做什么）  
│  方向盘         │ ← 转向（做什么）
└─────────────────┘

汽车内部实现：
┌─────────────────────────────────┐
│ 发动机、变速箱、制动系统...     │ ← 怎么做（隐藏细节）
└─────────────────────────────────┘

驾驶员不需要了解发动机原理，只需要知道踩油门能加速
```

### 4.2 代码中的接口设计


**📋 接口定义示例**
```javascript
// 数据存储接口 - 定义"能做什么"
class DataStorage {
    save(key, data) {
        throw new Error("子类必须实现 save 方法");
    }
    
    load(key) {
        throw new Error("子类必须实现 load 方法");
    }
    
    delete(key) {
        throw new Error("子类必须实现 delete 方法");
    }
}

// 具体实现1：文件存储
class FileStorage extends DataStorage {
    save(key, data) {
        // 保存到文件的具体实现
        fs.writeFileSync(`${key}.json`, JSON.stringify(data));
    }
    
    load(key) {
        // 从文件加载的具体实现
        return JSON.parse(fs.readFileSync(`${key}.json`));
    }
}

// 具体实现2：数据库存储
class DatabaseStorage extends DataStorage {
    save(key, data) {
        // 保存到数据库的具体实现
        database.insert({ key: key, data: data });
    }
    
    load(key) {
        // 从数据库加载的具体实现
        return database.findOne({ key: key });
    }
}
```

### 4.3 接口分离的好处


**🎯 核心优势**
```
1. 可替换性：
   使用者 → 接口 → 实现A
              ↘   ↗ 实现B  (可以轻松切换)

2. 可测试性：
   真实环境 → 接口 → 真实数据库
   测试环境 → 接口 → 模拟数据库

3. 可扩展性：
   新需求时只需要新增实现，不影响使用者
```

---

## 5. 📦 依赖管理策略


### 5.1 什么是依赖


> **依赖**：当模块A需要使用模块B的功能时，我们说A依赖于B。

**🔗 依赖关系图**
```
订单模块的依赖关系：
    订单模块
    ↙  ↓  ↘
用户模块 商品模块 支付模块
    ↓    ↓     ↓
 数据库  缓存   外部API

箭头表示依赖方向：订单模块依赖用户模块
```

### 5.2 循环依赖问题


**❌ 循环依赖的危害**
```javascript
// 模块A依赖模块B
class ModuleA {
    doSomething() {
        return ModuleB.process();  // A依赖B
    }
}

// 模块B又依赖模块A  
class ModuleB {
    process() {
        return ModuleA.calculate(); // B依赖A，形成循环
    }
}

问题：
• 难以理解模块关系
• 无法独立测试
• 可能导致无限循环
• 难以复用模块
```

### 5.3 避免循环依赖的方法


**✅ 解决方案**

**方法1：提取共同依赖**
```javascript
// 将共同功能提取到新模块
class CommonUtils {
    static calculate(data) { /* 计算逻辑 */ }
    static process(data) { /* 处理逻辑 */ }
}

// 两个模块都依赖公共模块，避免互相依赖
class ModuleA {
    doSomething() {
        return CommonUtils.calculate(this.data);
    }
}

class ModuleB {
    process() {
        return CommonUtils.process(this.data);
    }
}
```

**方法2：使用事件机制**
```javascript
// 通过事件解耦，避免直接依赖
class ModuleA {
    doSomething() {
        // 发布事件，不直接调用ModuleB
        EventBus.emit('dataReady', this.data);
    }
}

class ModuleB {
    constructor() {
        // 监听事件，不直接依赖ModuleA
        EventBus.on('dataReady', (data) => {
            this.process(data);
        });
    }
}
```

### 5.4 依赖注入策略


**🎯 依赖注入的基本思想**
```javascript
// ❌ 硬编码依赖 - 难以测试和替换
class OrderService {
    constructor() {
        this.userService = new UserService(); // 硬依赖
        this.paymentService = new PaymentService(); // 硬依赖
    }
}

// ✅ 依赖注入 - 灵活可测试
class OrderService {
    constructor(userService, paymentService) {
        this.userService = userService; // 外部注入
        this.paymentService = paymentService; // 外部注入
    }
}

// 使用时注入具体依赖
const orderService = new OrderService(
    new UserService(),
    new PaymentService()
);
```

---

## 6. 🤝 模块协作与通信机制


### 6.1 模块协作原则


> **模块协作原则**：模块内部紧密协作，模块之间松散联系，通过明确的接口进行交流。

**🏢 团队协作类比**
```
公司部门协作：
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   研发部    │  │   市场部    │  │   财务部    │
│   ┌─────┐   │  │   ┌─────┐   │  │   ┌─────┐   │
│   │程序员│   │  │   │销售│   │  │   │会计│   │
│   │测试员│   │  │   │策划│   │  │   │出纳│   │
│   │架构师│   │  │   │运营│   │  │   │审计│   │
│   └─────┘   │  │   └─────┘   │  │   └─────┘   │
└─────────────┘  └─────────────┘  └─────────────┘
      ↕              ↕              ↕
   通过正式会议、邮件、文档等方式协作

特点：
• 部门内部频繁交流（高内聚）
• 部门间通过正式渠道交流（低耦合）
• 每个部门职责明确（单一职责）
```

### 6.2 模块通信机制设计


**📡 通信方式对比**

| 通信方式 | **适用场景** | **优点** | **缺点** |
|---------|-------------|---------|---------|
| 🔗 **直接调用** | `简单依赖关系` | `直接明了` | `强耦合` |
| 📨 **事件机制** | `解耦通信` | `松耦合` | `难以追踪` |
| 📬 **消息队列** | `异步处理` | `高性能` | `复杂度高` |
| 🎭 **接口契约** | `标准化交互` | `可替换` | `需要设计` |

**📡 事件机制示例**
```javascript
// 事件总线 - 模块间松耦合通信
class EventBus {
    static events = {};
    
    static on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }
    
    static emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(data));
        }
    }
}

// 用户模块：发布事件
class UserModule {
    createUser(userData) {
        const user = this.saveUser(userData);
        // 通知其他模块用户创建完成
        EventBus.emit('userCreated', user);
        return user;
    }
}

// 通知模块：监听事件
class NotificationModule {
    constructor() {
        EventBus.on('userCreated', (user) => {
            this.sendWelcomeEmail(user);
        });
    }
}

// 统计模块：监听同一事件
class AnalyticsModule {
    constructor() {
        EventBus.on('userCreated', (user) => {
            this.trackUserRegistration(user);
        });
    }
}
```

---

## 7. 🧩 组合优于继承的设计思维


### 7.1 继承vs组合的区别


**🌳 继承（Is-A关系）**
```
动物继承体系：
        动物
       /    \
    哺乳动物  鸟类
    /    \    /  \
   狗    猫  鹰  鸭

特点：
• 狗"是一种"哺乳动物（Is-A关系）
• 子类继承父类的所有特性
• 关系固定，难以改变
```

**🧩 组合（Has-A关系）
```
汽车组合设计：
     汽车
   /  |  |  \
发动机 轮胎 座椅 音响

特点：
• 汽车"有一个"发动机（Has-A关系）
• 可以选择不同的组件
• 关系灵活，可以替换
```

### 7.2 继承的问题


**❌ 继承的局限性**
```javascript
// 继承方式的问题
class Bird {
    fly() { console.log("飞行"); }
    eat() { console.log("吃食"); }
}

class Duck extends Bird {
    swim() { console.log("游泳"); }
}

class Penguin extends Bird {
    // 问题：企鹅不会飞，但继承了fly方法
    fly() { 
        throw new Error("企鹅不会飞!"); 
    }
}

问题分析：
• 企鹅继承了不需要的fly方法
• 违反了里氏替换原则
• 继承关系过于僵硬
```

### 7.3 组合的优势


**✅ 组合方式的解决方案**
```javascript
// 将行为抽象为独立的能力
class FlyingAbility {
    fly() { console.log("飞行"); }
}

class SwimmingAbility {
    swim() { console.log("游泳"); }
}

class EatingAbility {
    eat() { console.log("吃食"); }
}

// 通过组合构建不同的鸟类
class Duck {
    constructor() {
        this.flyingAbility = new FlyingAbility();
        this.swimmingAbility = new SwimmingAbility();
        this.eatingAbility = new EatingAbility();
    }
    
    fly() { this.flyingAbility.fly(); }
    swim() { this.swimmingAbility.swim(); }
    eat() { this.eatingAbility.eat(); }
}

class Penguin {
    constructor() {
        // 企鹅只组合需要的能力
        this.swimmingAbility = new SwimmingAbility();
        this.eatingAbility = new EatingAbility();
        // 不包含flyingAbility
    }
    
    swim() { this.swimmingAbility.swim(); }
    eat() { this.eatingAbility.eat(); }
    // 没有fly方法，符合实际情况
}
```

### 7.4 组合的实际应用


**🎯 实际项目中的组合设计**
```javascript
// 支付功能的组合设计
class PaymentProcessor {
    constructor(validator, calculator, notifier) {
        this.validator = validator;     // 验证组件
        this.calculator = calculator;   // 计算组件  
        this.notifier = notifier;       // 通知组件
    }
    
    processPayment(paymentData) {
        // 组合各个组件完成支付流程
        if (!this.validator.validate(paymentData)) {
            throw new Error("支付数据无效");
        }
        
        const amount = this.calculator.calculateTotal(paymentData);
        const result = this.executePayment(amount);
        
        this.notifier.sendConfirmation(result);
        return result;
    }
}

// 可以灵活组合不同的实现
const wechatPayment = new PaymentProcessor(
    new WechatValidator(),
    new WechatCalculator(), 
    new SMSNotifier()
);

const alipayPayment = new PaymentProcessor(
    new AlipayValidator(),
    new AlipayCalculator(),
    new EmailNotifier()
);
```

---

## 8. ⚡ 分而治之的问题分解


### 8.1 分而治之的基本思想


> **分而治之**：把大问题分解成小问题，分别解决小问题，再把小问题的解合并成大问题的解。

**🍕 生活中的分而治之**
```
做一顿晚餐的分解：
┌─────────────────────────────────┐
│           准备晚餐               │
├─────────┬─────────┬─────────────┤
│  主菜   │  配菜   │     汤      │
├─────────┼─────────┼─────────────┤
│买食材   │洗菜切菜 │   调味品    │
│烹饪     │炒制     │   煮制      │
└─────────┴─────────┴─────────────┘

策略：
• 大任务：做晚餐
• 分解：主菜 + 配菜 + 汤
• 再分解：每道菜的具体步骤
• 并行执行：同时处理多道菜
• 最终合并：摆盘上桌
```

### 8.2 软件开发中的分而治之


**🏗️ 项目开发的分解策略**
```javascript
// 大型项目的分解
const projectStructure = {
    "电商系统": {
        "前端模块": {
            "用户界面": ["登录页", "商品页", "购物车"],
            "组件库": ["按钮", "表单", "弹窗"],
            "状态管理": ["用户状态", "购物车状态"]
        },
        "后端模块": {
            "用户服务": ["注册", "登录", "个人信息"],
            "商品服务": ["商品列表", "商品详情", "库存管理"],
            "订单服务": ["下单", "支付", "物流跟踪"]
        },
        "数据库模块": {
            "用户表": "存储用户信息",
            "商品表": "存储商品信息", 
            "订单表": "存储订单信息"
        }
    }
};
```

### 8.3 分解的具体方法


**📋 分解步骤**
1. **识别主要功能**：确定系统的核心功能
2. **功能分组**：将相关功能归类
3. **定义接口**：确定模块间的交互方式
4. **逐步细化**：将大模块继续分解
5. **验证完整性**：确保没有遗漏

**🎯 分解示例：用户管理系统**
```javascript
// 第一层分解：按功能域
const userManagementSystem = {
    authentication: "身份认证模块",
    profile: "个人信息模块", 
    permissions: "权限管理模块"
};

// 第二层分解：按具体功能
const authenticationModule = {
    login: {
        validateCredentials: "验证用户凭证",
        generateToken: "生成访问令牌",
        recordLoginHistory: "记录登录历史"
    },
    register: {
        validateUserData: "验证注册数据",
        checkUserExists: "检查用户是否存在", 
        createUserAccount: "创建用户账户"
    },
    logout: {
        invalidateToken: "使令牌失效",
        clearSession: "清理会话信息"
    }
};

// 第三层分解：具体实现
function validateCredentials(username, password) {
    // 1. 检查输入格式
    if (!isValidFormat(username, password)) {
        return { success: false, message: "格式错误" };
    }
    
    // 2. 查询用户信息
    const user = findUserByUsername(username);
    if (!user) {
        return { success: false, message: "用户不存在" };
    }
    
    // 3. 验证密码
    const isValid = verifyPassword(password, user.passwordHash);
    return { success: isValid, user: isValid ? user : null };
}
```

---

## 9. 🔄 模块生命周期管理


### 9.1 模块生命周期概念


> **模块生命周期**：模块从被创建到被销毁的整个过程，包括初始化、使用、维护和清理等阶段。

**📈 模块生命周期图**
```
模块生命周期：
创建 → 初始化 → 运行 → 维护 → 升级 → 销毁
 ↓      ↓      ↓     ↓     ↓      ↓
资源   配置    提供   监控   更新    清理
分配   加载    服务   状态   版本    资源
```

### 9.2 模块创建阶段


**🏗️ 创建阶段的关键任务**
```javascript
class UserModule {
    constructor(config) {
        // 1. 保存配置
        this.config = config;
        
        // 2. 初始化资源
        this.database = null;
        this.cache = null;
        this.logger = null;
        
        // 3. 设置状态
        this.isInitialized = false;
        this.isRunning = false;
    }
    
    // 异步初始化方法
    async initialize() {
        try {
            console.log("开始初始化用户模块...");
            
            // 1. 连接数据库
            this.database = await connectDatabase(this.config.database);
            
            // 2. 初始化缓存
            this.cache = await initializeCache(this.config.cache);
            
            // 3. 设置日志
            this.logger = createLogger(this.config.logging);
            
            // 4. 验证模块完整性
            await this.validateModule();
            
            this.isInitialized = true;
            this.logger.info("用户模块初始化完成");
            
        } catch (error) {
            this.logger.error("模块初始化失败:", error);
            throw error;
        }
    }
}
```

### 9.3 模块运行阶段


**⚙️ 运行阶段的管理**
```javascript
class UserModule {
    // 启动模块
    async start() {
        if (!this.isInitialized) {
            throw new Error("模块未初始化");
        }
        
        // 1. 开始提供服务
        this.isRunning = true;
        
        // 2. 启动健康检查
        this.startHealthCheck();
        
        // 3. 注册到服务发现
        await this.registerService();
        
        this.logger.info("用户模块开始运行");
    }
    
    // 健康检查
    startHealthCheck() {
        setInterval(() => {
            const health = this.checkHealth();
            if (!health.isHealthy) {
                this.logger.warn("模块健康状况异常:", health.issues);
                this.handleHealthIssues(health.issues);
            }
        }, 30000); // 每30秒检查一次
    }
    
    checkHealth() {
        const issues = [];
        
        // 检查数据库连接
        if (!this.database.isConnected()) {
            issues.push("数据库连接断开");
        }
        
        // 检查缓存状态
        if (!this.cache.isAvailable()) {
            issues.push("缓存不可用");
        }
        
        // 检查内存使用
        const memoryUsage = process.memoryUsage();
        if (memoryUsage.heapUsed > this.config.maxMemory) {
            issues.push("内存使用过高");
        }
        
        return {
            isHealthy: issues.length === 0,
            issues: issues
        };
    }
}
```

### 9.4 模块销毁阶段


**🗑️ 优雅关闭和资源清理**
```javascript
class UserModule {
    // 优雅关闭
    async shutdown() {
        this.logger.info("开始关闭用户模块...");
        
        try {
            // 1. 停止接受新请求
            this.isRunning = false;
            
            // 2. 等待现有请求完成
            await this.waitForActiveRequests();
            
            // 3. 从服务发现中注销
            await this.unregisterService();
            
            // 4. 关闭数据库连接
            if (this.database) {
                await this.database.close();
            }
            
            // 5. 清理缓存
            if (this.cache) {
                await this.cache.flush();
                this.cache.close();
            }
            
            // 6. 清理定时器和监听器
            this.clearTimers();
            this.removeListeners();
            
            this.logger.info("用户模块已安全关闭");
            
        } catch (error) {
            this.logger.error("模块关闭时出错:", error);
            throw error;
        }
    }
    
    // 等待活跃请求完成
    async waitForActiveRequests(timeout = 30000) {
        const startTime = Date.now();
        
        while (this.activeRequestCount > 0) {
            if (Date.now() - startTime > timeout) {
                this.logger.warn(`等待超时，强制关闭。剩余请求: ${this.activeRequestCount}`);
                break;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 模块化本质：将复杂问题分解为简单、独立、可管理的模块
🔸 高内聚低耦合：模块内部紧密相关，模块之间松散连接
🔸 接口分离：定义清晰的接口，隐藏实现细节
🔸 依赖管理：避免循环依赖，使用依赖注入提高灵活性
🔸 组合优于继承：通过组合构建复杂功能，保持灵活性
🔸 分而治之：将大问题逐层分解为小问题
🔸 生命周期管理：妥善管理模块的创建、运行和销毁
```

### 10.2 关键理解要点


**🔹 模块化思维的核心**
```
问题解决思路：
大问题 → 分解 → 小问题 → 独立解决 → 组合 → 完整解决方案

设计原则：
• 单一职责：一个模块只做一件事
• 开放封闭：对扩展开放，对修改封闭  
• 依赖倒置：依赖接口而不是具体实现
```

**🔹 边界设计的重要性**
```
好的边界特征：
✅ 内部数据流动频繁，外部数据传递较少
✅ 修改功能只影响一个模块
✅ 模块可以独立开发和测试
✅ 接口简单清晰，职责明确

边界设计检验：
• 能否独立测试？
• 能否独立部署？
• 能否轻松替换？
• 修改是否局部化？
```

### 10.3 实际应用指导


**📊 模块划分策略**
```
按业务功能划分：
• 用户管理、订单处理、支付系统
• 优点：符合业务逻辑，易于理解
• 适用：业务导向的应用系统

按技术层次划分：
• 数据层、业务层、表现层
• 优点：技术职责清晰，便于维护
• 适用：技术导向的基础框架

按变化频率划分：
• 稳定核心、活跃业务、UI界面
• 优点：降低变更影响，提高稳定性
• 适用：快速迭代的产品系统
```

**🔧 实践建议**
```
设计阶段：
• 先定义模块边界和接口
• 再考虑具体实现细节
• 画出模块依赖关系图

开发阶段：
• 优先开发核心模块
• 使用接口和模拟数据测试
• 逐步集成各个模块

维护阶段：
• 监控模块健康状况
• 及时处理依赖问题
• 持续优化模块边界
```

### 10.4 常见问题与解决方案


**⚠️ 常见问题**
```
问题1：模块粒度过细
现象：很多只有几行代码的小模块
解决：合并相关性强的小模块

问题2：模块粒度过粗  
现象：模块内部功能杂乱，难以维护
解决：按职责重新拆分模块

问题3：循环依赖
现象：模块A依赖B，B又依赖A
解决：提取公共部分或使用事件解耦

问题4：接口不稳定
现象：接口频繁变更，影响其他模块
解决：设计更抽象稳定的接口
```

**核心记忆口诀**：
- 模块设计有边界，高聚低耦是核心
- 接口分离藏细节，依赖注入增灵活  
- 组合胜过继承链，分治思维解难题
- 生命周期要管理，优雅启停保稳定