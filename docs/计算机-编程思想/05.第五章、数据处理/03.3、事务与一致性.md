---
title: 3、事务与一致性
---
## 📚 目录

1. [事务基础概念](#1-事务基础概念)
2. [ACID特性详解](#2-ACID特性详解)
3. [事务边界设计](#3-事务边界设计)
4. [事务传播机制](#4-事务传播机制)
5. [幂等性设计](#5-幂等性设计)
6. [数据一致性策略](#6-数据一致性策略)
7. [分布式事务处理](#7-分布式事务处理)
8. [实战应用场景](#8-实战应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 💡 事务基础概念


### 1.1 什么是事务


**简单理解**：事务就像银行转账一样，要么全部成功，要么全部失败

```
生活中的例子：
张三给李四转账100元
1. 张三账户减少100元
2. 李四账户增加100元

这两步必须同时成功，不能只完成一步！
```

**📋 核心定义**
```
事务（Transaction）：
把多个数据库操作打包成一个整体单位
要么全部执行成功，要么全部撤销
确保数据的正确性和一致性
```

### 1.2 为什么需要事务


**🎯 解决的问题**
- **数据不一致**：防止操作执行一半就出错
- **并发冲突**：多人同时操作数据时的冲突
- **系统故障**：程序崩溃、断电等意外情况
- **数据完整性**：保证业务逻辑的完整执行

**💭 没有事务会怎样**
```
转账场景：
1. 张三账户 -100 ✅ (成功)
2. 系统崩溃 💥
3. 李四账户 +100 ❌ (未执行)

结果：张三的钱没了，李四也没收到
这就是数据不一致问题！
```

---

## 2. ⚖️ ACID特性详解


### 2.1 原子性（Atomicity）


**🔸 核心含义**：事务是不可分割的最小单位

```java
// 转账操作示例
@Transactional
public void transfer(String fromAccount, String toAccount, BigDecimal amount) {
    // 这三步要么全成功，要么全失败
    accountService.deduct(fromAccount, amount);    // 扣款
    accountService.add(toAccount, amount);         // 加款
    logService.recordTransfer(fromAccount, toAccount, amount); // 记录日志
}
```

**💡 通俗理解**
```
就像吃药片：
- 不能只吃半颗药，要么吃完整一颗，要么不吃
- 事务也一样，要么全部操作都完成，要么全部都不做
```

### 2.2 一致性（Consistency）


**🔸 核心含义**：事务前后数据必须保持一致状态

```
转账前：张三1000元 + 李四500元 = 1500元
转账后：张三900元 + 李四600元 = 1500元
总金额不变，这就是一致性！
```

**📊 一致性规则**
- **业务规则**：账户余额不能为负数
- **完整性约束**：外键关系必须正确
- **数据关联**：相关表的数据必须匹配

### 2.3 隔离性（Isolation）


**🔸 核心含义**：多个事务同时执行时不能相互干扰

```
场景：张三和李四同时查看账户余额
┌─────────────┬─────────────┐
│   张三操作   │   李四操作   │
├─────────────┼─────────────┤
│ 查询余额1000 │ 查询余额1000 │
│ 转出200     │ 转出300     │
│ 余额变800   │ 余额变700   │
└─────────────┴─────────────┘

问题：最终余额应该是500，不是700或800！
```

**🔒 隔离级别**
```
读未提交 < 读已提交 < 可重复读 < 串行化
   ↑         ↑         ↑         ↑
 性能高     常用级别   MySQL默认  最安全
```

### 2.4 持久性（Durability）


**🔸 核心含义**：事务提交后，数据永久保存

```
提交事务后：
✅ 数据写入磁盘
✅ 即使停电、重启也不会丢失
✅ 可以通过日志恢复数据
```

---

## 3. 🎯 事务边界设计


### 3.1 什么是事务边界


**📋 定义**：确定哪些操作需要放在同一个事务里

**🤔 设计原则**
```
一个完整的业务操作 = 一个事务
例如：下订单包括
- 检查库存
- 扣减库存  
- 创建订单
- 扣减余额
- 生成物流信息

这些步骤必须在一个事务里！
```

### 3.2 事务边界设计策略


**✅ 合理的事务边界**
```java
@Transactional
public void createOrder(OrderRequest request) {
    // 1. 检查库存
    if (!stockService.checkStock(request.getProductId(), request.getQuantity())) {
        throw new BusinessException("库存不足");
    }
    
    // 2. 扣减库存
    stockService.deductStock(request.getProductId(), request.getQuantity());
    
    // 3. 创建订单
    Order order = orderService.createOrder(request);
    
    // 4. 扣减用户余额
    accountService.deductBalance(request.getUserId(), order.getAmount());
    
    // 5. 发送消息通知（这步可以放在事务外）
    // messageService.sendOrderNotification(order);
}
```

**❌ 不合理的事务边界**
```java
// 事务太大 - 包含不必要的操作
@Transactional
public void processOrder(OrderRequest request) {
    createOrder(request);           // 核心业务
    sendEmail(request.getEmail());  // 发邮件 - 不应该在事务里
    updateStatistics();             // 更新统计 - 可以异步处理
    generateReport();               // 生成报表 - 耗时操作
}

// 事务太小 - 拆分了不应该拆分的操作
public void transferMoney(String from, String to, BigDecimal amount) {
    deductMoney(from, amount);      // 事务1
    addMoney(to, amount);           // 事务2 - 错误！应该在同一个事务
}
```

### 3.3 事务边界最佳实践


**🎯 设计要点**
```
事务范围设计：
✅ 包含：必须同时成功的操作
❌ 排除：外部系统调用、文件操作、邮件发送
❌ 排除：耗时的计算、报表生成
❌ 排除：日志记录（可选操作）

时间控制：
✅ 事务执行时间 < 5秒
❌ 避免长时间持有数据库连接
❌ 避免在事务内等待用户输入
```

---

## 4. 🔄 事务传播机制


### 4.1 什么是事务传播


**📋 简单理解**：方法A调用方法B时，事务如何传递

```
情况1：A有事务，B也要事务，怎么处理？
情况2：A没事务，B需要事务，怎么处理？
情况3：A有事务，B不想要事务，怎么处理？
```

### 4.2 常用传播行为


**🔸 REQUIRED（默认）**
```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
    // 如果A有事务，就加入A的事务
    // 如果A没事务，就创建新事务
}

场景：
A调用B → A和B在同一个事务里
A出错 → B也回滚
B出错 → A也回滚
```

**🔸 REQUIRES_NEW**
```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // 无论A是否有事务，都创建新事务
    // A的事务被挂起
}

场景：
A调用B → B有自己独立的事务
A出错 → B不会回滚（已经提交）
B出错 → A可以选择是否回滚
```

**🔸 SUPPORTS**
```java
@Transactional(propagation = Propagation.SUPPORTS)
public void methodB() {
    // 如果A有事务，就加入
    // 如果A没事务，就不用事务
}

场景：查询操作常用
```

### 4.3 传播行为选择指南


| 场景 | 推荐传播行为 | 说明 |
|------|-------------|------|
| 🏪 **主业务流程** | `REQUIRED` | 主流程操作必须在同一事务 |
| 📝 **日志记录** | `REQUIRES_NEW` | 即使主业务失败，日志也要保存 |
| 📊 **查询操作** | `SUPPORTS` | 有事务就用，没有也不强求 |
| 🚫 **不需事务** | `NOT_SUPPORTED` | 明确不需要事务的操作 |

---

## 5. 🛡️ 幂等性设计


### 5.1 什么是幂等性


**📋 定义**：同一个操作执行多次，结果完全一样

```
生活例子：
按电梯按钮 - 按1次和按10次效果一样
数学例子：
f(f(x)) = f(x) - 这就是幂等性
```

**💡 为什么需要幂等性**
```
常见问题：
1. 用户重复点击提交按钮
2. 网络超时导致重复请求
3. 系统重试机制
4. 消息队列重复消费

后果：
❌ 订单重复创建
❌ 重复扣款
❌ 库存多次扣减
```

### 5.2 幂等性实现策略


**🔸 唯一性约束**
```java
@Entity
public class Order {
    @Column(unique = true)
    private String orderNo;  // 订单号唯一
    
    @Column(unique = true)
    private String idempotentKey;  // 幂等键
}

// 业务层
public void createOrder(OrderRequest request) {
    try {
        orderRepository.save(order);
    } catch (DataIntegrityViolationException e) {
        // 订单已存在，直接返回
        return getExistingOrder(request.getOrderNo());
    }
}
```

**🔸 Token机制**
```java
// 1. 获取Token
@GetMapping("/getToken")
public String getSubmitToken() {
    String token = UUID.randomUUID().toString();
    redisTemplate.setex("token:" + token, 300, "1");  // 5分钟过期
    return token;
}

// 2. 提交时验证Token
@PostMapping("/submit")
public void submitOrder(@RequestParam String token, @RequestBody OrderRequest request) {
    // 原子操作：检查并删除token
    String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
    Long result = redisTemplate.execute(script, Collections.singletonList("token:" + token), "1");
    
    if (result == 0) {
        throw new BusinessException("请勿重复提交");
    }
    
    // 处理业务逻辑
    orderService.createOrder(request);
}
```

**🔸 状态机控制**
```java
public enum OrderStatus {
    PENDING("待处理"),
    PROCESSING("处理中"),
    COMPLETED("已完成"),
    CANCELLED("已取消");
}

public void processOrder(String orderNo) {
    Order order = orderRepository.findByOrderNo(orderNo);
    
    // 只有待处理状态才能处理
    if (order.getStatus() != OrderStatus.PENDING) {
        log.info("订单{}已处理，跳过", orderNo);
        return;  // 幂等性保证
    }
    
    // 先更新状态，防止并发
    order.setStatus(OrderStatus.PROCESSING);
    orderRepository.save(order);
    
    try {
        // 执行业务逻辑
        doProcessOrder(order);
        order.setStatus(OrderStatus.COMPLETED);
    } catch (Exception e) {
        order.setStatus(OrderStatus.PENDING);  // 回到初始状态
        throw e;
    }
}
```

### 5.3 幂等性最佳实践


**🎯 设计原则**
```
选择策略：
📝 表单提交 → Token机制
💰 支付订单 → 唯一性约束
📦 状态变更 → 状态机控制
🔄 消息消费 → 业务键去重

注意事项：
✅ 幂等键要有业务意义
✅ 考虑并发访问场景
✅ 合理设置过期时间
❌ 不要把所有操作都做成幂等
```

---

## 6. 📊 数据一致性策略


### 6.1 一致性级别


**🔸 强一致性**
```
特点：所有节点在同一时刻看到的数据完全一致
代价：性能较低，可用性较差
适用：金融交易、库存管理

银行转账例子：
张三转账给李四，必须保证：
1. 张三账户立即扣款
2. 李四账户立即到账
3. 所有查询都能看到最新状态
```

**🔸 最终一致性**
```
特点：允许短暂的数据不一致，但最终会达到一致
优点：性能好，可用性高
适用：社交媒体、商品推荐

朋友圈点赞例子：
1. 用户A点赞成功
2. 其他用户可能暂时看不到
3. 几秒后所有用户都能看到点赞
4. 这种延迟是可以接受的
```

### 6.2 实现策略对比


| 一致性级别 | 实现方式 | 优点 | 缺点 | 适用场景 |
|-----------|---------|------|------|---------|
| **强一致性** | 同步复制、分布式锁 | 数据绝对准确 | 性能差、可用性低 | 💰 金融、📦 库存 |
| **最终一致性** | 异步消息、补偿机制 | 性能好、可用性高 | 编程复杂、短暂不一致 | 👥 社交、📊 统计 |
| **弱一致性** | 缓存、批量同步 | 性能最好 | 可能长期不一致 | 📈 推荐、🔍 搜索 |

### 6.3 一致性实现模式


**🔸 Saga模式**
```java
// 订单处理的Saga流程
public class OrderSaga {
    
    public void processOrder(OrderRequest request) {
        try {
            // 步骤1：扣减库存
            stockService.deductStock(request.getProductId(), request.getQuantity());
            
            // 步骤2：创建订单
            Order order = orderService.createOrder(request);
            
            // 步骤3：扣减余额
            accountService.deductBalance(request.getUserId(), order.getAmount());
            
            // 步骤4：发货
            logisticsService.ship(order);
            
        } catch (Exception e) {
            // 补偿操作：逐步回滚
            compensate(request);
        }
    }
    
    private void compensate(OrderRequest request) {
        // 回滚库存
        stockService.addStock(request.getProductId(), request.getQuantity());
        // 回滚余额
        accountService.addBalance(request.getUserId(), request.getAmount());
        // 取消订单
        orderService.cancelOrder(request.getOrderNo());
    }
}
```

**🔸 事件驱动模式**
```java
// 发布事件
@EventListener
public class OrderEventHandler {
    
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 事务提交后执行，保证一致性
        inventoryService.updateInventory(event.getOrderId());
        notificationService.sendConfirmation(event.getUserId());
        analyticsService.recordOrderMetrics(event);
    }
}
```

---

## 7. 🌐 分布式事务处理


### 7.1 分布式事务挑战


**🤔 什么是分布式事务**
```
单机事务：
应用 → 数据库 (一个系统内)

分布式事务：
订单系统 → 订单数据库
库存系统 → 库存数据库  
支付系统 → 支付数据库
(多个系统协作)
```

**⚠️ 面临的问题**
- **网络延迟**：系统间通信不稳定
- **服务故障**：某个服务可能宕机
- **数据不一致**：部分操作成功，部分失败
- **性能影响**：分布式协议开销大

### 7.2 分布式事务解决方案


**🔸 TCC模式（Try-Confirm-Cancel）**
```java
public interface PaymentTccService {
    
    // Try：尝试执行，预留资源
    boolean tryPay(String userId, BigDecimal amount);
    
    // Confirm：确认执行，提交资源
    boolean confirmPay(String userId, BigDecimal amount);
    
    // Cancel：取消执行，释放资源
    boolean cancelPay(String userId, BigDecimal amount);
}

@Service
public class PaymentTccServiceImpl implements PaymentTccService {
    
    @Override
    public boolean tryPay(String userId, BigDecimal amount) {
        // 冻结用户余额，不实际扣除
        return accountService.freezeBalance(userId, amount);
    }
    
    @Override
    public boolean confirmPay(String userId, BigDecimal amount) {
        // 实际扣除冻结的余额
        return accountService.deductFrozenBalance(userId, amount);
    }
    
    @Override
    public boolean cancelPay(String userId, BigDecimal amount) {
        // 解冻余额
        return accountService.unfreezeBalance(userId, amount);
    }
}
```

**🔸 消息队列保证最终一致性**
```java
@Transactional
public void createOrder(OrderRequest request) {
    // 1. 本地事务：创建订单
    Order order = orderRepository.save(new Order(request));
    
    // 2. 发送消息（在同一个事务内）
    TransactionSynchronizationManager.registerSynchronization(
        new TransactionSynchronization() {
            @Override
            public void afterCommit() {
                // 事务提交成功后发送消息
                messageProducer.send("order.created", order);
            }
        }
    );
}

// 消息消费者
@RabbitListener(queues = "order.created")
public void handleOrderCreated(Order order) {
    try {
        // 扣减库存
        stockService.deductStock(order.getProductId(), order.getQuantity());
        // 发送发货消息
        logisticsService.prepareShipment(order);
    } catch (Exception e) {
        // 失败重试或补偿
        log.error("处理订单失败：{}", order.getId(), e);
        // 可以发送到死信队列进行人工处理
    }
}
```

### 7.3 分布式事务选择指南


```
选择原则：
🎯 强一致性要求 → 2PC/3PC（性能差）
⚡ 性能优先 → 最终一致性 + 消息队列
🔄 复杂业务流程 → Saga模式
💰 资金相关 → TCC模式
📊 数据分析 → 允许弱一致性

实际建议：
1. 优先考虑业务是否真的需要强一致性
2. 能用异步解决的，不要用同步
3. 设计时考虑补偿和重试机制
4. 监控和告警必不可少
```

---

## 8. 🚀 实战应用场景


### 8.1 电商下单场景


**📦 业务流程**
```
用户下单包含：
1. 检查商品库存
2. 检查用户余额
3. 创建订单
4. 扣减库存
5. 扣减余额
6. 生成支付流水
7. 发送通知
```

**🔧 技术实现**
```java
@Service
@Transactional
public class OrderService {
    
    public OrderResult createOrder(CreateOrderRequest request) {
        // 1. 参数验证
        validateRequest(request);
        
        // 2. 检查库存（读操作，不需要锁）
        if (!stockService.hasEnoughStock(request.getProductId(), request.getQuantity())) {
            throw new BusinessException("库存不足");
        }
        
        // 3. 检查余额
        if (!accountService.hasEnoughBalance(request.getUserId(), request.getAmount())) {
            throw new BusinessException("余额不足");
        }
        
        // 4. 创建订单（生成唯一订单号）
        Order order = Order.builder()
            .orderNo(generateOrderNo())
            .userId(request.getUserId())
            .productId(request.getProductId())
            .quantity(request.getQuantity())
            .amount(request.getAmount())
            .status(OrderStatus.PENDING)
            .build();
        
        orderRepository.save(order);
        
        // 5. 扣减库存（原子操作）
        stockService.deductStock(request.getProductId(), request.getQuantity());
        
        // 6. 扣减余额
        accountService.deductBalance(request.getUserId(), request.getAmount());
        
        // 7. 更新订单状态
        order.setStatus(OrderStatus.PAID);
        orderRepository.save(order);
        
        // 8. 异步发送通知（事务外执行）
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    notificationService.sendOrderConfirmation(order);
                    logisticsService.prepareShipment(order);
                }
            }
        );
        
        return OrderResult.success(order);
    }
    
    private String generateOrderNo() {
        // 时间戳 + 随机数，保证唯一性
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss")) 
               + RandomUtils.nextInt(1000, 9999);
    }
}
```

### 8.2 支付重复处理


**💰 防重复支付设计**
```java
@Service
public class PaymentService {
    
    @Transactional
    public PaymentResult processPayment(PaymentRequest request) {
        String idempotentKey = request.getOrderNo() + "_" + request.getAmount();
        
        // 1. 幂等性检查
        Payment existingPayment = paymentRepository.findByIdempotentKey(idempotentKey);
        if (existingPayment != null) {
            if (existingPayment.getStatus() == PaymentStatus.SUCCESS) {
                return PaymentResult.success(existingPayment);  // 已成功，直接返回
            }
            if (existingPayment.getStatus() == PaymentStatus.PROCESSING) {
                throw new BusinessException("支付处理中，请稍后查询");
            }
        }
        
        // 2. 创建支付记录
        Payment payment = Payment.builder()
            .paymentNo(generatePaymentNo())
            .orderNo(request.getOrderNo())
            .amount(request.getAmount())
            .userId(request.getUserId())
            .idempotentKey(idempotentKey)
            .status(PaymentStatus.PROCESSING)
            .build();
        
        paymentRepository.save(payment);
        
        try {
            // 3. 调用第三方支付
            ThirdPartyPaymentResult result = thirdPartyPaymentService.pay(request);
            
            if (result.isSuccess()) {
                payment.setStatus(PaymentStatus.SUCCESS);
                payment.setThirdPartyPaymentId(result.getPaymentId());
            } else {
                payment.setStatus(PaymentStatus.FAILED);
                payment.setFailureReason(result.getErrorMessage());
            }
            
            paymentRepository.save(payment);
            return PaymentResult.of(payment);
            
        } catch (Exception e) {
            // 4. 异常处理
            payment.setStatus(PaymentStatus.FAILED);
            payment.setFailureReason(e.getMessage());
            paymentRepository.save(payment);
            throw new BusinessException("支付失败：" + e.getMessage());
        }
    }
}
```

### 8.3 库存超卖问题


**📦 防止超卖的方案**
```java
@Service
public class StockService {
    
    // 方案1：悲观锁
    @Transactional
    public boolean deductStockWithPessimisticLock(Long productId, Integer quantity) {
        // 加行锁查询
        Product product = productRepository.findByIdForUpdate(productId);
        
        if (product.getStock() < quantity) {
            throw new BusinessException("库存不足");
        }
        
        product.setStock(product.getStock() - quantity);
        productRepository.save(product);
        return true;
    }
    
    // 方案2：乐观锁
    @Transactional
    public boolean deductStockWithOptimisticLock(Long productId, Integer quantity) {
        for (int i = 0; i < 3; i++) {  // 最多重试3次
            Product product = productRepository.findById(productId).orElseThrow();
            
            if (product.getStock() < quantity) {
                throw new BusinessException("库存不足");
            }
            
            // 使用版本号更新
            int updatedRows = productRepository.updateStockWithVersion(
                productId, quantity, product.getVersion()
            );
            
            if (updatedRows > 0) {
                return true;  // 更新成功
            }
            
            // 更新失败，说明有并发修改，等待后重试
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new BusinessException("操作被中断");
            }
        }
        
        throw new BusinessException("系统繁忙，请稍后重试");
    }
    
    // 方案3：Redis分布式锁
    @Transactional
    public boolean deductStockWithRedisLock(Long productId, Integer quantity) {
        String lockKey = "stock:lock:" + productId;
        String lockValue = UUID.randomUUID().toString();
        
        try {
            // 获取分布式锁
            boolean lockAcquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(10));
            
            if (!lockAcquired) {
                throw new BusinessException("系统繁忙，请稍后重试");
            }
            
            // 执行库存扣减
            Product product = productRepository.findById(productId).orElseThrow();
            
            if (product.getStock() < quantity) {
                throw new BusinessException("库存不足");
            }
            
            product.setStock(product.getStock() - quantity);
            productRepository.save(product);
            
            return true;
            
        } finally {
            // 释放锁
            String script = """
                if redis.call('get', KEYS[1]) == ARGV[1] then
                    return redis.call('del', KEYS[1])
                else
                    return 0
                end
                """;
            redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), 
                Collections.singletonList(lockKey), lockValue);
        }
    }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 事务基础：ACID特性是事务的基本要求
🔸 事务边界：合理设计事务范围，不能太大也不能太小
🔸 传播机制：理解方法调用时事务如何传递
🔸 幂等性：防止重复操作，保证系统稳定性
🔸 一致性策略：根据业务需求选择合适的一致性级别
🔸 分布式事务：复杂场景下的数据一致性保障
```

### 9.2 关键理解要点


**🔹 事务设计思维**
```
设计原则：
✅ 一个完整业务操作 = 一个事务
✅ 事务要尽可能短小精悍
✅ 避免在事务内调用外部系统
✅ 考虑并发访问的影响

常见误区：
❌ 事务范围过大，影响性能
❌ 事务范围过小，数据不一致
❌ 忽略并发问题
❌ 不考虑异常回滚
```

**🔹 一致性设计思维**
```
强一致性 vs 最终一致性：
💰 金融交易 → 强一致性
👥 社交功能 → 最终一致性
📊 数据统计 → 弱一致性

选择依据：
- 业务容忍度
- 性能要求
- 系统复杂度
- 开发成本
```

### 9.3 实际应用指导


**🎯 设计检查清单**
- [ ] 确定事务边界是否合理
- [ ] 检查是否有并发安全问题
- [ ] 验证幂等性设计是否完善
- [ ] 确认异常处理和回滚策略
- [ ] 评估性能影响和优化方案
- [ ] 设计监控和告警机制

**⚠️ 常见陷阱**
```
事务陷阱：
❌ 在事务内执行耗时操作
❌ 事务方法被非事务方法调用
❌ 异常被捕获但没有抛出
❌ 使用错误的传播行为

一致性陷阱：
❌ 过度追求强一致性
❌ 忽略分布式系统的CAP定理
❌ 没有设计补偿机制
❌ 缺乏数据核对和修复手段
```

### 9.4 最佳实践总结


**💡 核心记忆要点**
```
事务四特性：原子一致隔离持久
边界设计：业务完整最小化
传播机制：按需选择不盲目
幂等设计：防重复保稳定
一致策略：强弱选择看业务
分布式：最终一致是主流
```

**🚀 进阶学习方向**
- **分布式系统理论**：CAP定理、BASE理论
- **数据库事务实现**：MVCC、锁机制
- **微服务事务**：Saga、TCC深入学习
- **性能优化**：事务调优、监控告警