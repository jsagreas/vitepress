---
title: 6、缓存问题处理
---
## 📚 目录

1. [缓存问题处理概述](#1-缓存问题处理概述)
2. [缓存穿透解决方案](#2-缓存穿透解决方案)
3. [缓存击穿防护策略](#3-缓存击穿防护策略)
4. [缓存雪崩应对方案](#4-缓存雪崩应对方案)
5. [缓存一致性保证](#5-缓存一致性保证)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 缓存问题处理概述


### 1.1 什么是缓存问题处理


**定义简单说**：缓存问题处理就是当我们使用缓存系统时，遇到的各种异常情况和解决办法。

```
生活中的缓存例子：
你在家里冰箱放食物 → 这就是缓存
- 缓存穿透：有人要吃冰箱里没有的东西
- 缓存击穿：冰箱里最受欢迎的食物突然没了
- 缓存雪崩：冰箱突然坏了，所有食物都没了
```

### 1.2 为什么要处理缓存问题


**核心问题**：缓存本来是为了提高性能，但如果处理不当，反而会拖垮系统。

```
没有缓存问题处理的后果：

用户请求 → 缓存（没数据）→ 数据库（被压垮）
    ↓
系统崩溃，用户无法使用

有了缓存问题处理：

用户请求 → 缓存（智能处理）→ 数据库（正常运行）
    ↓
系统稳定，用户体验良好
```

### 1.3 常见缓存问题分类


| 问题类型 | **简单描述** | **影响程度** | **解决难度** |
|---------|------------|-------------|-------------|
| **缓存穿透** | `查询不存在的数据` | `⭐⭐` | `⭐` |
| **缓存击穿** | `热点数据突然失效` | `⭐⭐⭐` | `⭐⭐` |
| **缓存雪崩** | `大量缓存同时失效` | `⭐⭐⭐⭐⭐` | `⭐⭐⭐` |
| **缓存一致性** | `缓存和数据库数据不同步` | `⭐⭐⭐⭐` | `⭐⭐⭐⭐` |

---

## 2. 🕳️ 缓存穿透解决方案


### 2.1 什么是缓存穿透


**通俗解释**：缓存穿透就像有人故意要你冰箱里根本没有的东西，你每次都要去超市找，但超市也没有。

```
缓存穿透流程：

用户查询ID=999的用户信息
    ↓
缓存：没有ID=999的数据
    ↓
数据库：也没有ID=999的数据
    ↓
返回空结果，但下次还会重复这个过程
```

### 2.2 缓存穿透的危害


**🚨 主要危害**：
- **数据库压力大**：每次无效请求都会查询数据库
- **系统性能下降**：大量无效查询占用资源
- **可能被恶意攻击**：故意查询不存在的数据

```
危害示例：

正常情况：1000个请求 → 900个命中缓存，100个查数据库
穿透情况：1000个请求 → 0个命中缓存，1000个查数据库
```

### 2.3 解决方案一：缓存空值


**核心思想**：既然查不到数据，那就把"没有数据"这个结果也缓存起来。

```java
// 缓存空值解决缓存穿透
public User getUserById(Long userId) {
    // 1. 先查缓存
    String cacheKey = "user:" + userId;
    String userJson = redis.get(cacheKey);
    
    if (userJson != null) {
        if ("null".equals(userJson)) {
            return null; // 缓存的空值
        }
        return JSON.parseObject(userJson, User.class);
    }
    
    // 2. 查数据库
    User user = userDao.selectById(userId);
    
    if (user != null) {
        // 缓存真实数据
        redis.setex(cacheKey, 3600, JSON.toJSONString(user));
    } else {
        // 缓存空值，设置较短过期时间
        redis.setex(cacheKey, 300, "null");
    }
    
    return user;
}
```

**🎯 关键要点**：
- **缓存空值**：把null结果也存入缓存
- **较短过期时间**：空值缓存时间要短一些
- **特殊标识**：用"null"字符串表示空值

### 2.4 解决方案二：布隆过滤器


**通俗解释**：布隆过滤器就像一个"黑名单检查器"，能快速告诉你某个数据"肯定不存在"。

```
布隆过滤器工作原理：

系统启动时：把所有存在的用户ID放入布隆过滤器
    ↓
用户查询：先问布隆过滤器这个ID存在吗？
    ↓
如果布隆过滤器说"不存在" → 直接返回空，不查数据库
如果布隆过滤器说"可能存在" → 继续查缓存和数据库
```

```java
// 布隆过滤器解决缓存穿透
public class UserService {
    private BloomFilter<Long> userBloomFilter;
    
    // 系统启动时初始化
    @PostConstruct
    public void initBloomFilter() {
        // 创建布隆过滤器，预计100万用户，误判率1%
        userBloomFilter = BloomFilter.create(
            Funnels.longFunnel(), 1000000, 0.01);
        
        // 将所有存在的用户ID加入过滤器
        List<Long> allUserIds = userDao.getAllUserIds();
        for (Long userId : allUserIds) {
            userBloomFilter.put(userId);
        }
    }
    
    public User getUserById(Long userId) {
        // 1. 先检查布隆过滤器
        if (!userBloomFilter.mightContain(userId)) {
            return null; // 肯定不存在，直接返回
        }
        
        // 2. 可能存在，继续正常流程
        return getUserFromCacheOrDB(userId);
    }
}
```

### 2.5 解决方案对比


```
┌──────────────┬──────────────┬──────────────┐
│   解决方案   │   缓存空值   │ 布隆过滤器   │
├──────────────┼──────────────┼──────────────┤
│   实现复杂度 │     简单     │     中等     │
│   内存占用   │     较大     │     很小     │
│   准确性     │    100%      │   99%左右    │
│   适用场景   │  数据变化少  │  数据量大    │
└──────────────┴──────────────┴──────────────┘
```

---

## 3. 💥 缓存击穿防护策略


### 3.1 什么是缓存击穿


**通俗解释**：缓存击穿就像超市里最受欢迎的商品突然卖完了，所有想买这个商品的人都涌向仓库拿货。

```
缓存击穿场景：

热门用户信息缓存过期
    ↓
同时有1000个请求查询这个用户
    ↓
1000个请求都去查数据库
    ↓
数据库瞬间压力巨大
```

### 3.2 缓存击穿的特点


**🔍 识别特征**：
- **热点数据**：被频繁访问的数据
- **瞬间失效**：缓存突然过期或被删除
- **并发量大**：同时有很多请求访问

```
击穿示例：

正常情况：
请求1 → 缓存命中 → 返回结果
请求2 → 缓存命中 → 返回结果
...

击穿情况：
请求1 → 缓存miss → 查数据库
请求2 → 缓存miss → 查数据库  
请求3 → 缓存miss → 查数据库
... (同时发生)
```

### 3.3 解决方案一：互斥锁


**核心思想**：同一时间只允许一个请求去重建缓存，其他请求等待。

```java
// 互斥锁防止缓存击穿
public User getUserById(Long userId) {
    String cacheKey = "user:" + userId;
    
    // 1. 查缓存
    User user = getFromCache(cacheKey);
    if (user != null) {
        return user;
    }
    
    // 2. 缓存miss，尝试获取锁
    String lockKey = "lock:" + cacheKey;
    
    try {
        // 获取分布式锁，过期时间10秒
        boolean getLock = redis.setnx(lockKey, "1", 10);
        
        if (getLock) {
            // 获取到锁，查数据库并重建缓存
            user = userDao.selectById(userId);
            if (user != null) {
                redis.setex(cacheKey, 3600, JSON.toJSONString(user));
            }
            return user;
        } else {
            // 没获取到锁，等待一下再查缓存
            Thread.sleep(100);
            return getFromCache(cacheKey); // 可能其他线程已经更新了缓存
        }
    } finally {
        // 释放锁
        redis.del(lockKey);
    }
}
```

### 3.4 解决方案二：热点数据永不过期


**核心思想**：热点数据逻辑上永不过期，通过后台异步更新。

```java
// 热点数据永不过期方案
public User getUserById(Long userId) {
    String cacheKey = "user:" + userId;
    
    // 从缓存获取数据
    String userJson = redis.get(cacheKey);
    if (userJson != null) {
        CacheData cacheData = JSON.parseObject(userJson, CacheData.class);
        
        // 检查是否需要更新
        if (cacheData.getExpireTime() < System.currentTimeMillis()) {
            // 数据过期了，异步更新
            asyncUpdateCache(userId);
        }
        
        return cacheData.getData(); // 返回旧数据
    }
    
    // 缓存没有数据，同步查询
    return updateCacheSync(userId);
}

// 异步更新缓存
private void asyncUpdateCache(Long userId) {
    threadPool.execute(() -> {
        User user = userDao.selectById(userId);
        if (user != null) {
            CacheData cacheData = new CacheData();
            cacheData.setData(user);
            cacheData.setExpireTime(System.currentTimeMillis() + 3600000); // 1小时后过期
            
            redis.set("user:" + userId, JSON.toJSONString(cacheData));
        }
    });
}
```

### 3.5 两种方案对比


```
互斥锁方案：
优点：保证数据一致性，实现简单
缺点：有锁等待时间，可能影响性能

永不过期方案：
优点：性能好，没有等待时间
缺点：可能返回过期数据，实现复杂
```

---

## 4. ❄️ 缓存雪崩应对方案


### 4.1 什么是缓存雪崩


**通俗解释**：缓存雪崩就像整个超市的货架突然都空了，所有顾客都涌向仓库，把仓库挤爆了。

```
缓存雪崩场景：

大量缓存同时过期
    ↓
大量请求同时涌向数据库
    ↓
数据库承受不住压力
    ↓
系统崩溃
```

### 4.2 缓存雪崩的原因


**🔍 常见原因**：
- **相同过期时间**：大批数据设置了相同的过期时间
- **缓存服务器故障**：Redis服务器宕机
- **大量数据同时失效**：缓存清理或重启

```
雪崩示例：

系统启动时，批量设置缓存：
用户1缓存：过期时间 2024-08-16 10:00:00
用户2缓存：过期时间 2024-08-16 10:00:00
用户3缓存：过期时间 2024-08-16 10:00:00
...

到了10:00:00，所有缓存同时失效！
```

### 4.3 解决方案一：错峰失效


**核心思想**：让缓存在不同时间过期，避免同时失效。

```java
// 错峰失效防止缓存雪崩
public void setUserCache(Long userId, User user) {
    String cacheKey = "user:" + userId;
    
    // 基础过期时间：1小时
    int baseExpire = 3600;
    
    // 随机增加0-300秒，实现错峰
    int randomExpire = new Random().nextInt(300);
    int finalExpire = baseExpire + randomExpire;
    
    redis.setex(cacheKey, finalExpire, JSON.toJSONString(user));
}

// 批量设置时也要错峰
public void batchSetCache(Map<Long, User> users) {
    for (Map.Entry<Long, User> entry : users.entrySet()) {
        // 每个缓存都有不同的过期时间
        setUserCache(entry.getKey(), entry.getValue());
        
        // 设置间隔，避免同时设置
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            // 处理异常
        }
    }
}
```

### 4.4 解决方案二：多级缓存


**核心思想**：建立多层缓存，一层失效还有其他层兜底。

```
多级缓存架构：

请求 → 本地缓存(L1) → Redis缓存(L2) → 数据库(L3)

如果Redis宕机：
请求 → 本地缓存 → 数据库 (跳过Redis)
```

```java
// 多级缓存实现
@Service
public class UserService {
    
    // 本地缓存
    private LoadingCache<Long, User> localCache;
    
    @PostConstruct
    public void initLocalCache() {
        localCache = Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .build(this::loadUserFromRedisOrDB);
    }
    
    public User getUserById(Long userId) {
        try {
            // 从本地缓存获取
            return localCache.get(userId);
        } catch (Exception e) {
            // 本地缓存失败，直接查数据库
            return userDao.selectById(userId);
        }
    }
    
    private User loadUserFromRedisOrDB(Long userId) {
        // 先查Redis
        String userJson = redis.get("user:" + userId);
        if (userJson != null) {
            return JSON.parseObject(userJson, User.class);
        }
        
        // Redis没有，查数据库
        User user = userDao.selectById(userId);
        if (user != null) {
            // 重新设置Redis缓存
            redis.setex("user:" + userId, 3600, JSON.toJSONString(user));
        }
        
        return user;
    }
}
```

### 4.5 解决方案三：熔断降级


**核心思想**：当检测到缓存故障时，暂时停止使用缓存，避免系统崩溃。

```java
// 熔断降级防止缓存雪崩
@Component
public class CacheCircuitBreaker {
    
    private AtomicInteger failureCount = new AtomicInteger(0);
    private volatile boolean circuitOpen = false;
    private volatile long lastFailureTime = 0;
    
    public User getUserWithCircuitBreaker(Long userId) {
        
        // 检查熔断器状态
        if (circuitOpen) {
            // 熔断器打开，尝试恢复
            if (System.currentTimeMillis() - lastFailureTime > 60000) { // 1分钟后尝试恢复
                circuitOpen = false;
                failureCount.set(0);
            } else {
                // 熔断期间，直接查数据库
                return userDao.selectById(userId);
            }
        }
        
        try {
            // 尝试查缓存
            String userJson = redis.get("user:" + userId);
            if (userJson != null) {
                return JSON.parseObject(userJson, User.class);
            }
            
            // 缓存没有，查数据库
            User user = userDao.selectById(userId);
            if (user != null) {
                redis.setex("user:" + userId, 3600, JSON.toJSONString(user));
            }
            return user;
            
        } catch (Exception e) {
            // 缓存操作失败
            handleCacheFailure();
            return userDao.selectById(userId);
        }
    }
    
    private void handleCacheFailure() {
        lastFailureTime = System.currentTimeMillis();
        
        // 失败次数超过阈值，打开熔断器
        if (failureCount.incrementAndGet() >= 5) {
            circuitOpen = true;
        }
    }
}
```

---

## 5. 🔄 缓存一致性保证


### 5.1 什么是缓存一致性


**通俗解释**：缓存一致性就是确保缓存里的数据和数据库里的数据是一样的，就像确保你手机上的通讯录和实际的联系方式一致。

```
一致性问题示例：

数据库：用户张三的年龄是25岁
缓存：用户张三的年龄还是24岁
    ↓
用户看到的是错误信息
```

### 5.2 一致性问题的来源


**🔍 主要原因**：
- **更新时序问题**：先更新缓存还是先更新数据库
- **并发操作冲突**：多个线程同时修改数据
- **网络故障**：更新过程中网络中断

```
时序问题示例：

线程A：更新数据库(年龄=25) → 更新缓存(年龄=25)
线程B：在A更新缓存前查询 → 得到旧缓存(年龄=24)
    ↓
出现了数据不一致
```

### 5.3 解决方案一：Cache Aside模式


**核心思想**：更新数据时先更新数据库，再删除缓存。

```java
// Cache Aside 模式
@Service
public class UserService {
    
    public boolean updateUser(User user) {
        try {
            // 1. 先更新数据库
            boolean dbSuccess = userDao.updateById(user);
            if (!dbSuccess) {
                return false;
            }
            
            // 2. 删除缓存（让下次查询时重新加载）
            String cacheKey = "user:" + user.getId();
            redis.del(cacheKey);
            
            return true;
            
        } catch (Exception e) {
            // 如果删除缓存失败，记录日志，后续补偿
            log.error("删除缓存失败，userId: {}", user.getId(), e);
            return false;
        }
    }
    
    public User getUserById(Long userId) {
        String cacheKey = "user:" + userId;
        
        // 1. 查缓存
        String userJson = redis.get(cacheKey);
        if (userJson != null) {
            return JSON.parseObject(userJson, User.class);
        }
        
        // 2. 缓存没有，查数据库
        User user = userDao.selectById(userId);
        if (user != null) {
            // 3. 设置缓存
            redis.setex(cacheKey, 3600, JSON.toJSONString(user));
        }
        
        return user;
    }
}
```

### 5.4 解决方案二：Write Through模式


**核心思想**：写入数据时同时更新缓存和数据库。

```java
// Write Through 模式
@Service
public class UserServiceWriteThrough {
    
    public boolean updateUser(User user) {
        String cacheKey = "user:" + user.getId();
        
        try {
            // 使用事务确保数据一致性
            return transactionTemplate.execute(status -> {
                // 1. 更新数据库
                boolean dbSuccess = userDao.updateById(user);
                if (!dbSuccess) {
                    throw new RuntimeException("数据库更新失败");
                }
                
                // 2. 更新缓存
                redis.setex(cacheKey, 3600, JSON.toJSONString(user));
                
                return true;
            });
            
        } catch (Exception e) {
            log.error("更新用户失败，userId: {}", user.getId(), e);
            return false;
        }
    }
}
```

### 5.5 解决方案三：Write Behind模式


**核心思想**：先更新缓存，异步更新数据库。

```java
// Write Behind 模式（适合写多读少的场景）
@Service
public class UserServiceWriteBehind {
    
    // 异步队列
    private BlockingQueue<User> updateQueue = new LinkedBlockingQueue<>();
    
    @PostConstruct
    public void startAsyncWorker() {
        // 启动异步工作线程
        Thread worker = new Thread(() -> {
            while (true) {
                try {
                    User user = updateQueue.take();
                    // 批量更新数据库
                    userDao.updateById(user);
                } catch (InterruptedException e) {
                    break;
                } catch (Exception e) {
                    log.error("异步更新数据库失败", e);
                }
            }
        });
        worker.setDaemon(true);
        worker.start();
    }
    
    public boolean updateUser(User user) {
        String cacheKey = "user:" + user.getId();
        
        try {
            // 1. 立即更新缓存
            redis.setex(cacheKey, 3600, JSON.toJSONString(user));
            
            // 2. 异步更新数据库
            updateQueue.offer(user);
            
            return true;
            
        } catch (Exception e) {
            log.error("更新缓存失败，userId: {}", user.getId(), e);
            return false;
        }
    }
}
```

### 5.6 一致性方案选择


```
┌─────────────┬─────────────┬─────────────┬─────────────┐
│    方案     │ Cache Aside │Write Through│Write Behind │
├─────────────┼─────────────┼─────────────┼─────────────┤
│  一致性保证 │    较好     │     最好    │     较差    │
│  性能表现   │    较好     │     较差    │     最好    │
│  实现复杂度 │    简单     │     中等    │     复杂    │
│  适用场景   │   通用场景  │  强一致性   │   高并发    │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 缓存穿透：查询不存在的数据，解决方案是缓存空值或布隆过滤器
🔸 缓存击穿：热点数据失效导致大量请求涌向数据库，用锁或永不过期解决
🔸 缓存雪崩：大量缓存同时失效，通过错峰失效、多级缓存、熔断降级解决
🔸 缓存一致性：保证缓存和数据库数据同步，有多种模式可选
```

### 6.2 关键理解要点


**🔹 问题识别和预防思维**
```
预防胜于治疗：
- 设计缓存时就要考虑这些问题
- 监控和预警机制很重要
- 压力测试验证解决方案的有效性
```

**🔹 方案选择的权衡思维**
```
没有完美的解决方案：
- 简单 vs 完善：简单方案易实现，完善方案更可靠
- 性能 vs 一致性：高性能可能牺牲一致性
- 成本 vs 收益：解决方案的复杂度要匹配实际需求
```

### 6.3 实际应用指导


**🎯 问题排查思路**
```
遇到缓存问题时的检查步骤：
1. 确定是哪种类型的问题（穿透/击穿/雪崩/一致性）
2. 分析问题的严重程度和影响范围
3. 选择合适的解决方案
4. 实施解决方案并验证效果
5. 建立监控和预警机制
```

**🔧 最佳实践建议**
```
日常开发中的注意事项：
- 缓存设计时就考虑失效策略
- 热点数据要特别关注
- 建立完善的监控体系
- 定期进行缓存性能评估
- 准备降级和兜底方案
```

**💡 核心记忆口诀**：
```
缓存问题四大类，穿透击穿雪崩来
一致性问题别忘记，方案选择要权衡
预防监控最重要，降级兜底保稳定
```