---
title: 3、链表思维
---
## 📚 目录

1. [指针连接模型](#1-指针连接模型)
2. [动态内存分配](#2-动态内存分配)
3. [链表操作技巧](#3-链表操作技巧)
4. [双向链表设计](#4-双向链表设计)
5. [循环链表应用](#5-循环链表应用)
6. [链表vs数组选择](#6-链表vs数组选择)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔗 指针连接模型


### 1.1 什么是指针连接


**通俗理解**：想象一串珠子，每颗珠子都记住下一颗珠子在哪里

```
现实生活中的类比：
寻宝游戏 → 每个地点都有线索指向下一个地点
地点A → "去图书馆" → 地点B → "去咖啡厅" → 地点C

链表原理：
节点A → 指针指向节点B → 节点B → 指针指向节点C → 节点C
[数据|指针] → [数据|指针] → [数据|NULL]
```

### 1.2 指针连接的核心思想


**🔸 链式存储模式**
```
数组存储（连续内存）：
内存：[A][B][C][D][E] ← 必须连在一起

链表存储（分散内存）：
内存：[A]→ [C]→ [B]→ [E]→ [D] ← 可以分散存放
```

**💡 基本链表节点结构**
```java
// 最简单的链表节点
class ListNode {
    int data;           // 存储的数据
    ListNode next;      // 指向下一个节点的指针
    
    // 构造函数
    ListNode(int data) {
        this.data = data;
        this.next = null;
    }
}
```

### 1.3 指针连接的优势特性


**🎯 动态性**
```
数组：大小固定，编译时就要确定
链表：大小灵活，运行时随意增减

实际应用场景：
• 播放列表：随时添加/删除歌曲
• 购物车：随时增加/移除商品
• 浏览器历史：动态记录访问页面
```

**⚡ 插入删除效率**
```
数组插入元素：需要移动后面所有元素
[1][2][3][4] → 在位置1插入5
[1][5][2][3][4] ← 需要移动2,3,4

链表插入元素：只需要修改指针
A→B→C → 在A和B之间插入X
A→X→B→C ← 只需要修改两个指针
```

---

## 2. 💾 动态内存分配


### 2.1 什么是动态内存分配


**通俗解释**：就像租房子，需要时就租，不需要时就退租

```
静态内存（数组）：
像买房子 → 一次性买下固定大小的房子
int arr[100]; // 无论用不用，都占用100个位置

动态内存（链表）：
像租房子 → 需要时租一间，不需要时退租
ListNode node = new ListNode(10); // 只在需要时分配内存
```

### 2.2 动态内存的工作原理


**🏗️ 内存分配过程**
```
创建新节点的过程：

步骤1：申请内存空间
new ListNode(10) → 向系统申请一块内存

步骤2：初始化数据
内存布局：[data: 10 | next: null]

步骤3：建立连接
将新节点连接到链表中
```

**🔄 内存回收机制**
```java
// Java中的自动内存管理
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head = null; // 失去引用，垃圾回收器会自动清理

// C语言中需要手动管理
struct Node* node = malloc(sizeof(struct Node));
free(node); // 必须手动释放内存
```

### 2.3 动态内存的优势


**📊 内存使用效率对比**
```
场景：存储学生信息，数量不确定

数组方式：
Student students[1000]; // 预分配1000个位置
实际只用了50个 → 浪费950个位置的内存

链表方式：
只分配实际需要的50个节点 → 节省95%的内存
```

**🎯 适应性强**
```
实际应用：
• 在线聊天记录：消息数量不可预知
• 文件目录：文件数量动态变化
• 游戏中的怪物列表：根据关卡动态生成
```

---

## 3. 🛠️ 链表操作技巧


### 3.1 基本操作技巧


**🔸 头插法创建链表**
```java
// 在链表头部插入新节点
public ListNode insertAtHead(ListNode head, int data) {
    ListNode newNode = new ListNode(data);
    newNode.next = head;  // 新节点指向原来的头节点
    return newNode;       // 新节点成为新的头节点
}

// 演示过程
原链表：1→2→3
插入0：  0→1→2→3  ← 0成为新的头节点
```

**🔸 尾插法创建链表**
```java
// 在链表尾部插入新节点
public void insertAtTail(ListNode head, int data) {
    ListNode newNode = new ListNode(data);
    
    // 找到最后一个节点
    ListNode current = head;
    while (current.next != null) {
        current = current.next;
    }
    
    current.next = newNode;  // 最后一个节点指向新节点
}
```

### 3.2 高效查找技巧


**🔍 双指针技巧**
```java
// 查找链表的中间节点（快慢指针）
public ListNode findMiddle(ListNode head) {
    ListNode slow = head;    // 慢指针，每次走一步
    ListNode fast = head;    // 快指针，每次走两步
    
    while (fast != null && fast.next != null) {
        slow = slow.next;      // 慢指针走一步
        fast = fast.next.next; // 快指针走两步
    }
    
    return slow; // 当快指针走完时，慢指针正好在中间
}

// 原理：兔子和乌龟赛跑，兔子跑完全程时，乌龟跑了一半
```

**🎯 查找倒数第k个节点**
```java
public ListNode findKthFromEnd(ListNode head, int k) {
    ListNode first = head;
    ListNode second = head;
    
    // 第一个指针先走k步
    for (int i = 0; i < k; i++) {
        first = first.next;
    }
    
    // 两个指针同时走，直到第一个指针到末尾
    while (first != null) {
        first = first.next;
        second = second.next;
    }
    
    return second; // 第二个指针就是倒数第k个节点
}
```

### 3.3 删除操作技巧


**🗑️ 删除指定值的节点**
```java
public ListNode deleteValue(ListNode head, int val) {
    // 处理头节点就是要删除的情况
    while (head != null && head.data == val) {
        head = head.next;
    }
    
    ListNode current = head;
    while (current != null && current.next != null) {
        if (current.next.data == val) {
            current.next = current.next.next; // 跳过要删除的节点
        } else {
            current = current.next;
        }
    }
    
    return head;
}
```

**💡 使用虚拟头节点简化操作**
```java
public ListNode deleteValueWithDummy(ListNode head, int val) {
    ListNode dummy = new ListNode(0); // 虚拟头节点
    dummy.next = head;
    
    ListNode current = dummy;
    while (current.next != null) {
        if (current.next.data == val) {
            current.next = current.next.next;
        } else {
            current = current.next;
        }
    }
    
    return dummy.next; // 返回真正的头节点
}
```

---

## 4. ↔️ 双向链表设计


### 4.1 双向链表的基本概念


**通俗理解**：像双向街道，可以前进也可以后退

```
单向链表：只能向前走
A → B → C → D

双向链表：可以前进后退
A ⇄ B ⇄ C ⇄ D
```

**🔸 双向链表节点结构**
```java
class DoublyListNode {
    int data;
    DoublyListNode prev; // 指向前一个节点
    DoublyListNode next; // 指向后一个节点
    
    DoublyListNode(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}
```

### 4.2 双向链表的设计考虑


**🎯 双向连接的优势**
```
单向链表的局限：
要删除某个节点，必须从头开始找到它的前驱节点

双向链表的优势：
每个节点都知道自己的前驱，可以直接删除
```

**🔧 双向链表的插入操作**
```java
// 在指定节点后插入新节点
public void insertAfter(DoublyListNode node, int data) {
    DoublyListNode newNode = new DoublyListNode(data);
    
    newNode.next = node.next;   // 新节点的下一个 = 当前节点的下一个
    newNode.prev = node;        // 新节点的上一个 = 当前节点
    
    if (node.next != null) {
        node.next.prev = newNode; // 后继节点的前驱 = 新节点
    }
    node.next = newNode;        // 当前节点的下一个 = 新节点
}

// 插入过程图示：
// 原状态：A ⇄ B ⇄ C
// 在B后插入X：A ⇄ B ⇄ X ⇄ C
```

### 4.3 双向链表的应用场景


**📚 实际应用示例**
```
浏览器历史记录：
首页 ⇄ 搜索页 ⇄ 详情页 ⇄ 结果页
可以前进，也可以后退

音乐播放器：
歌曲1 ⇄ 歌曲2 ⇄ 歌曲3 ⇄ 歌曲4
支持上一首和下一首

文本编辑器的撤销/重做：
操作1 ⇄ 操作2 ⇄ 操作3 ⇄ 操作4
可以撤销，也可以重做
```

---

## 5. 🔄 循环链表应用


### 5.1 循环链表的基本概念


**通俗理解**：像圆桌会议，最后一个人的旁边又是第一个人

```
普通链表：A → B → C → D → NULL

循环链表：A → B → C → D → A（尾部指向头部）
          ↑__________________|
```

**🔸 循环链表的特点**
```java
class CircularList {
    ListNode head;
    
    // 判断是否为循环链表
    public boolean isCircular() {
        if (head == null) return false;
        
        ListNode current = head.next;
        while (current != null && current != head) {
            current = current.next;
        }
        
        return current == head; // 如果回到头节点，说明是循环的
    }
}
```

### 5.2 循环链表的特殊应用场景


**🎮 约瑟夫环问题**
```
问题：n个人围成圆圈，从第1个人开始数，数到第m个人就出列，
      然后从下一个人继续数，直到所有人出列

使用循环链表解决：
1 → 2 → 3 → 4 → 5 → 1 （5个人的圆圈）
如果m=3，则出列顺序为：3, 1, 5, 2, 4
```

```java
// 约瑟夫环解决方案
public int josephus(int n, int m) {
    // 创建循环链表
    ListNode head = new ListNode(1);
    ListNode current = head;
    
    for (int i = 2; i <= n; i++) {
        current.next = new ListNode(i);
        current = current.next;
    }
    current.next = head; // 形成循环
    
    // 开始淘汰
    current = head;
    while (current.next != current) {
        // 数m-1次
        for (int i = 1; i < m; i++) {
            current = current.next;
        }
        // 删除下一个节点
        current.next = current.next.next;
    }
    
    return current.data; // 最后剩下的人
}
```

**🔄 轮询调度算法**
```
服务器负载均衡：
服务器A → 服务器B → 服务器C → 服务器A ...
每次请求按顺序分配给下一台服务器

时间片轮转调度：
进程1 → 进程2 → 进程3 → 进程1 ...
每个进程轮流获得CPU时间片
```

### 5.3 循环链表vs普通链表


| 特性 | **普通链表** | **循环链表** |
|------|-------------|-------------|
| **遍历** | `简单，遇到NULL结束` | `需要记录起始点，避免无限循环` |
| **插入** | `在任意位置插入相对简单` | `在尾部插入需要特殊处理` |
| **删除** | `删除尾节点简单` | `删除尾节点需要找到倒数第二个节点` |
| **应用** | `一般的数据存储` | `轮询、循环调度等场景` |

---

## 6. ⚖️ 链表vs数组选择


### 6.1 性能对比分析


**📊 时间复杂度对比**

| 操作类型 | **数组** | **链表** | **使用建议** |
|---------|---------|---------|-------------|
| **随机访问** | `O(1)` | `O(n)` | `需要频繁随机访问选数组` |
| **头部插入** | `O(n)` | `O(1)` | `频繁头部操作选链表` |
| **尾部插入** | `O(1)` | `O(n)` | `已知尾指针时链表也是O(1)` |
| **中间插入** | `O(n)` | `O(1)` | `已知位置时链表更快` |
| **删除操作** | `O(n)` | `O(1)` | `已知节点时链表更快` |
| **查找元素** | `O(n)` | `O(n)` | `都需要遍历，差异不大` |

### 6.2 内存使用对比


**💾 空间效率分析**
```
数组存储：
[data1][data2][data3][data4] ← 连续存储，无额外开销

链表存储：
[data1|ptr]→[data2|ptr]→[data3|ptr]→[data4|NULL]
每个节点额外需要存储指针（4-8字节）

空间开销：
• 数组：只存储数据本身
• 链表：数据 + 指针，额外开销20-50%
```

### 6.3 选择策略指南


**🎯 选择数组的场景**
```
✅ 需要频繁随机访问元素
   例：图像处理、矩阵运算、游戏地图

✅ 数据大小相对固定
   例：一周的天气数据、一年的月份数据

✅ 内存使用要求严格
   例：嵌入式系统、移动设备应用

✅ 需要高效的数学运算
   例：向量计算、信号处理
```

**🎯 选择链表的场景**
```
✅ 数据大小动态变化
   例：用户的购物车、播放列表

✅ 频繁的插入删除操作
   例：任务队列、事件处理队列

✅ 不需要随机访问
   例：日志记录、消息队列

✅ 内存分配更灵活
   例：大型数据处理、动态数据结构
```

### 6.4 实际选择建议


**💡 具体应用场景分析**
```
📱 移动App开发：
联系人列表 → 链表（频繁增删）
图片缓存 → 数组（需要快速访问）

🎮 游戏开发：
游戏地图 → 数组（需要坐标访问）
技能列表 → 链表（技能数量动态）

💻 Web开发：
用户Session → 链表（动态管理）
静态配置 → 数组（固定数据）

🏢 企业系统：
员工档案 → 数组（需要快速查询）
审批流程 → 链表（流程可能变化）
```

---

## 7. 📋 核心要点总结


### 7.1 链表思维的本质


```
🔸 指针连接：通过指针建立节点间的逻辑关系
🔸 动态性质：运行时动态分配和释放内存
🔸 非连续存储：物理上分散，逻辑上连续
🔸 灵活操作：插入删除操作灵活高效
🔸 空间换时间：用额外指针空间换取操作灵活性
```

### 7.2 关键理解要点


**🔹 链表的核心优势**
```
动态大小：不需要预先确定大小
高效插删：O(1)时间复杂度的插入删除
内存灵活：只在需要时分配内存
```

**🔹 链表的主要缺陷**
```
无随机访问：不能像数组一样直接访问第i个元素
额外空间：每个节点需要额外的指针空间
缓存局部性差：节点在内存中可能分散，影响性能
```

**🔹 设计选择原则**
```
数据量可预知且相对固定 → 选择数组
数据量动态变化且插删频繁 → 选择链表
需要频繁随机访问 → 选择数组
主要是顺序访问 → 可以选择链表
```

### 7.3 实际应用指导


**🛠️ 工程实践建议**
```
1. 根据操作频率选择：
   • 查询多 → 数组
   • 增删多 → 链表

2. 根据数据特点选择：
   • 大小固定 → 数组
   • 大小动态 → 链表

3. 根据性能要求选择：
   • 极致性能 → 数组
   • 灵活性优先 → 链表
```

**🎯 学习建议**
```
🧠 理解本质：
链表是一种思维模式，重在理解指针连接的思想

💻 多练习：
通过实际编程加深对指针操作的理解

🔄 对比学习：
经常对比数组和链表的优缺点，加深印象

📊 性能意识：
时刻考虑时间复杂度和空间复杂度的权衡
```

**核心记忆口诀**：
```
链表思维重指针，动态分配很灵活
插删操作效率高，随机访问是短板
双向循环有特色，选择关键看场景
数组链表各有优，按需选择是王道
```