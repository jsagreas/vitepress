---
title: 4、栈思维
---
## 📚 目录

1. [后进先出原理](#1-后进先出原理)
2. [函数调用栈](#2-函数调用栈)
3. [表达式求值](#3-表达式求值)
4. [括号匹配](#4-括号匹配)
5. [栈的应用场景](#5-栈的应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📦 后进先出原理


### 1.1 什么是栈？


**栈**就像一个**只有一个开口的箱子**，你只能从箱子顶部放东西进去，也只能从顶部拿东西出来。

```
想象一下叠盘子：
        ↓ 放入
    ┌─────────┐
    │   盘子3  │ ← 最后放的，最先拿出来
    ├─────────┤
    │   盘子2  │
    ├─────────┤
    │   盘子1  │ ← 最先放的，最后拿出来
    └─────────┘
        ↑ 拿出
```

### 1.2 后进先出（LIFO）原理


**🔸 核心概念**
```
LIFO = Last In, First Out
- 最后进去的，最先出来
- 最先进去的，最后出来
- 就像叠书：最上面的书最容易拿到
```

**💡 生活中的栈**
```
浏览器的后退按钮：
访问顺序：首页 → 新闻 → 体育 → 娱乐
后退顺序：娱乐 → 体育 → 新闻 → 首页

函数调用：
A函数调用B函数，B函数调用C函数
执行完毕：C函数结束 → B函数结束 → A函数结束
```

### 1.3 栈的基本操作


**🔧 核心操作**
```
入栈（Push）：把元素放到栈顶
出栈（Pop）：从栈顶取出元素
查看栈顶（Peek/Top）：看看栈顶是什么，但不取出
判断空栈（isEmpty）：检查栈是否为空
```

**📊 操作示例**
```java
// 简单的栈操作演示
Stack<Integer> stack = new Stack<>();

// 入栈操作
stack.push(1);    // 栈: [1]
stack.push(2);    // 栈: [1, 2]
stack.push(3);    // 栈: [1, 2, 3] ← 3在栈顶

// 查看栈顶
int top = stack.peek();  // 返回3，但不移除

// 出栈操作
int a = stack.pop();     // 返回3，栈变成: [1, 2]
int b = stack.pop();     // 返回2，栈变成: [1]
```

---

## 2. 🏗️ 函数调用栈


### 2.1 什么是函数调用栈？


**函数调用栈**就是程序记录函数调用过程的地方，就像一个**待办事项清单**。

```
程序执行过程：
main函数 → 调用A函数 → A函数调用B函数 → B函数调用C函数

调用栈的变化：
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│   main  │    │    A    │    │    B    │    │    C    │
└─────────┘    ├─────────┤    ├─────────┤    ├─────────┤
               │   main  │    │    A    │    │    B    │
               └─────────┘    ├─────────┤    ├─────────┤
                              │   main  │    │    A    │
                              └─────────┘    ├─────────┤
                                             │   main  │
                                             └─────────┘
```

### 2.2 调用栈的工作原理


**🔸 入栈时机**：每当调用一个函数时
```java
public void main() {
    System.out.println("main开始");
    functionA();                    // ← 这里A函数入栈
    System.out.println("main结束");
}

public void functionA() {
    System.out.println("A开始");
    functionB();                    // ← 这里B函数入栈
    System.out.println("A结束");
}

public void functionB() {
    System.out.println("B执行");    // ← B函数执行完毕，准备出栈
}
```

**🔸 出栈时机**：每当函数执行完毕时
```
执行过程：
1. main函数入栈，开始执行
2. 调用functionA，A函数入栈
3. 调用functionB，B函数入栈
4. B函数执行完毕，B函数出栈，回到A函数
5. A函数执行完毕，A函数出栈，回到main函数
6. main函数执行完毕，程序结束
```

### 2.3 栈溢出问题


**🚨 什么是栈溢出？**

当函数调用层次太深，栈空间不够用了，就会发生**栈溢出**。

```java
// 危险的递归调用 - 会导致栈溢出
public void badRecursion() {
    System.out.println("调用中...");
    badRecursion();  // 无限递归，永远不会结束
}

// 正确的递归调用 - 有终止条件
public void goodRecursion(int n) {
    if (n <= 0) {
        return;  // 递归终止条件
    }
    System.out.println("n = " + n);
    goodRecursion(n - 1);  // 递归调用，参数递减
}
```

**💡 避免栈溢出的方法**
- 确保递归有**明确的终止条件**
- 控制递归**深度**不要太大
- 考虑用**循环**代替深度递归

---

## 3. 🧮 表达式求值


### 3.1 为什么需要栈来计算表达式？


人类看表达式：`3 + 4 * 2` 我们知道先算乘法，再算加法
计算机看表达式：从左到右一个一个字符，不知道优先级

**栈的作用**：帮助计算机**正确处理运算优先级**。

### 3.2 中缀表达式转后缀表达式


**🔸 什么是中缀和后缀？**
```
中缀表达式：3 + 4 * 2      (运算符在中间，人类习惯)
后缀表达式：3 4 2 * +      (运算符在后面，计算机喜欢)

为什么计算机喜欢后缀？
- 没有括号
- 没有优先级问题
- 从左到右直接计算
```

**🔧 转换过程（用栈）**
```java
// 转换算法简化版
public String infixToPostfix(String infix) {
    Stack<Character> stack = new Stack<>();
    StringBuilder result = new StringBuilder();
    
    for (char c : infix.toCharArray()) {
        if (Character.isDigit(c)) {
            result.append(c);  // 数字直接输出
        } else if (c == '+' || c == '-' || c == '*' || c == '/') {
            // 处理运算符优先级
            while (!stack.isEmpty() && 
                   getPriority(stack.peek()) >= getPriority(c)) {
                result.append(stack.pop());
            }
            stack.push(c);
        }
    }
    
    // 输出剩余运算符
    while (!stack.isEmpty()) {
        result.append(stack.pop());
    }
    
    return result.toString();
}
```

### 3.3 计算后缀表达式


**🎯 计算规则很简单**
1. 遇到数字，入栈
2. 遇到运算符，取出两个数字计算，结果入栈
3. 最后栈里剩下的就是答案

```java
// 计算后缀表达式
public int calculatePostfix(String postfix) {
    Stack<Integer> stack = new Stack<>();
    
    for (char c : postfix.toCharArray()) {
        if (Character.isDigit(c)) {
            stack.push(c - '0');  // 数字入栈
        } else {
            // 取出两个数字计算
            int b = stack.pop();
            int a = stack.pop();
            
            switch (c) {
                case '+': stack.push(a + b); break;
                case '-': stack.push(a - b); break;
                case '*': stack.push(a * b); break;
                case '/': stack.push(a / b); break;
            }
        }
    }
    
    return stack.pop();  // 最终结果
}
```

**📊 计算过程示例**
```
计算：3 4 2 * +

步骤1：读取3    栈：[3]
步骤2：读取4    栈：[3, 4]
步骤3：读取2    栈：[3, 4, 2]
步骤4：读取*    计算4*2=8    栈：[3, 8]
步骤5：读取+    计算3+8=11   栈：[11]
结果：11
```

---

## 4. 🎯 括号匹配


### 4.1 括号匹配问题


**问题描述**：判断字符串中的括号是否正确匹配

```
正确的括号：
()            ✅
()()          ✅
(())          ✅
([{}])        ✅

错误的括号：
(             ❌ 缺少右括号
())           ❌ 多了右括号
([)]          ❌ 交叉不匹配
```

### 4.2 栈解决括号匹配


**🔸 解题思路**
1. 遇到**左括号**，入栈
2. 遇到**右括号**，和栈顶的左括号匹配
3. 如果匹配，出栈；如果不匹配，返回false
4. 最后检查栈是否为空

```java
public boolean isValidParentheses(String s) {
    Stack<Character> stack = new Stack<>();
    
    for (char c : s.toCharArray()) {
        // 左括号入栈
        if (c == '(' || c == '[' || c == '{') {
            stack.push(c);
        }
        // 右括号匹配
        else if (c == ')' || c == ']' || c == '}') {
            if (stack.isEmpty()) {
                return false;  // 没有左括号匹配
            }
            
            char left = stack.pop();
            if (!isMatching(left, c)) {
                return false;  // 括号类型不匹配
            }
        }
    }
    
    return stack.isEmpty();  // 栈为空说明完全匹配
}

private boolean isMatching(char left, char right) {
    return (left == '(' && right == ')') ||
           (left == '[' && right == ']') ||
           (left == '{' && right == '}');
}
```

**📊 匹配过程示例**
```
检查字符串：([{}])

步骤1：读取(    栈：[(]
步骤2：读取[    栈：[(, []
步骤3：读取{    栈：[(, [, {]
步骤4：读取}    与{匹配，出栈    栈：[(, []
步骤5：读取]    与[匹配，出栈    栈：[(]
步骤6：读取)    与(匹配，出栈    栈：[]
结果：栈为空，括号匹配 ✅
```

---

## 5. 🚀 栈的应用场景


### 5.1 浏览器历史记录


**🌐 浏览器后退功能**

每次访问新页面，把当前页面压入栈；点击后退，从栈中弹出上一个页面。

```java
class BrowserHistory {
    private Stack<String> history = new Stack<>();
    
    public void visit(String url) {
        history.push(url);
        System.out.println("访问: " + url);
    }
    
    public String back() {
        if (history.size() > 1) {
            history.pop();  // 移除当前页面
            return history.peek();  // 返回上一页
        }
        return "无法后退";
    }
}
```

### 5.2 编辑器的撤销功能


**📝 Ctrl+Z 撤销操作**

每次编辑操作都压入栈，撤销时从栈中弹出最近的操作。

```java
class TextEditor {
    private Stack<String> operations = new Stack<>();
    private String content = "";
    
    public void type(String text) {
        operations.push("type:" + text);
        content += text;
    }
    
    public void delete(int count) {
        operations.push("delete:" + count);
        content = content.substring(0, content.length() - count);
    }
    
    public void undo() {
        if (!operations.isEmpty()) {
            String lastOp = operations.pop();
            // 根据操作类型进行相反操作
            // ... 具体实现略
        }
    }
}
```

### 5.3 算法中的栈应用


**🔸 深度优先搜索（DFS）**
```
迷宫探索：
1. 把起点压入栈
2. 从栈顶取出位置，探索周围
3. 把能走的新位置压入栈
4. 重复直到找到出口或栈为空

这样保证了先走最深的路径
```

**🔸 程序语法分析**
```
编译器检查代码语法：
- 检查括号是否匹配
- 检查代码块是否正确嵌套
- 分析表达式是否合法
```

**🔸 内存管理**
```
程序运行时：
- 局部变量存储在栈中
- 函数参数通过栈传递
- 函数返回地址保存在栈中
```

### 5.4 栈与递归的关系


**💡 递归本质上就是在使用栈**

```java
// 递归计算阶乘
public int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// 等价的栈实现
public int factorialStack(int n) {
    Stack<Integer> stack = new Stack<>();
    
    // 模拟递归调用，把参数压入栈
    while (n > 1) {
        stack.push(n);
        n--;
    }
    
    int result = 1;
    // 模拟递归返回，从栈中取出计算
    while (!stack.isEmpty()) {
        result *= stack.pop();
    }
    
    return result;
}
```

**🔍 为什么递归容易理解栈？**

因为递归的**函数调用过程**本身就是在使用系统的调用栈！

---

## 6. 📋 核心要点总结


### 6.1 栈思维的本质


**🔸 栈思维就是"先处理最近的事情"**
```
生活场景：
- 处理邮件：先处理最新的邮件
- 穿衣服：先脱最外面的衣服
- 吃饭：先吃盛在最上面的食物

编程场景：
- 函数调用：先完成最内层的函数
- 括号匹配：先匹配最近的左括号
- 撤销操作：先撤销最近的操作
```

### 6.2 栈的核心特点


| 特点 | 说明 | 应用场景 |
|------|------|----------|
| **LIFO** | 后进先出 | 函数调用、撤销操作 |
| **单端操作** | 只能从一端存取 | 括号匹配、表达式求值 |
| **临时存储** | 保存中间状态 | DFS算法、递归实现 |
| **自动清理** | 使用完自动移除 | 内存管理、作用域控制 |

### 6.3 栈思维解决问题的模式


**🎯 识别栈问题的信号**
- 需要**最近优先**处理的场景
- 存在**嵌套结构**的问题
- 需要**临时保存**中间结果
- 涉及**递归**或**回溯**的算法

**🔧 栈思维解题步骤**
```
1. 识别问题：是否需要记住"最近的"状态？
2. 确定入栈时机：什么时候需要保存状态？
3. 确定出栈时机：什么时候需要恢复状态？
4. 设计匹配规则：如何判断栈顶元素是否符合条件？
```

### 6.4 栈思维的实践价值


**💡 培养栈思维的好处**
- **简化复杂问题**：把复杂的嵌套问题分解成简单的匹配问题
- **理解程序执行**：深入理解函数调用和内存管理
- **优化算法设计**：很多递归算法可以用栈优化避免溢出
- **提升调试能力**：理解调用栈有助于定位程序错误

**🚀 从栈思维到编程思维**

栈思维教会我们：
- **状态管理**：如何保存和恢复程序状态
- **问题分解**：如何把大问题分解成小问题
- **顺序控制**：如何控制程序执行顺序
- **资源管理**：如何合理分配和回收资源

**核心记忆**：
> 栈思维就是"后进先出"的思维方式，先处理最近的、最内层的、最紧急的事情。无论是函数调用、括号匹配还是撤销操作，都体现了这种"最近优先"的处理策略。掌握栈思维，就是掌握了一种重要的问题分解和状态管理方法。