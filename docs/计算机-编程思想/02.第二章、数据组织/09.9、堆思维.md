---
title: 9、堆思维
---
## 📚 目录

1. [堆的本质概念](#1-堆的本质概念)
2. [完全二叉树结构](#2-完全二叉树结构)
3. [堆序性质](#3-堆序性质)
4. [堆操作实现](#4-堆操作实现)
5. [优先队列应用](#5-优先队列应用)
6. [堆排序算法](#6-堆排序算法)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🧠 堆的本质概念


### 1.1 什么是堆？


**🔸 生活中的堆**
```
想象一个积木堆：
- 大的积木在下面，小的在上面（稳定结构）
- 每次只能从顶部取走最小的积木
- 新积木总是按规则放到合适位置

这就是堆的思维！
```

**🔸 数据结构中的堆**
堆是一种**特殊的二叉树**，它有两个核心特点：
- **结构特性**：必须是完全二叉树
- **堆序特性**：父节点和子节点有固定的大小关系

### 1.2 堆解决什么问题？


**💡 核心问题**：如何快速找到一堆数据中的**最大值**或**最小值**？

```
传统方法的困扰：
数组：[5, 2, 8, 1, 9, 3]
找最大值：需要遍历整个数组 O(n)
插入新数：可能需要重新排序

堆的优势：
- 最大值永远在堆顶 O(1)
- 插入新元素 O(log n)
- 删除最大值 O(log n)
```

### 1.3 堆的两种类型


**🔺 大顶堆（最大堆）**
```
父节点 ≥ 子节点
       9
     /   \
    6     8
   / \   / \
  2   5 3   7

特点：堆顶是最大值
```

**🔻 小顶堆（最小堆）**
```
父节点 ≤ 子节点
       1
     /   \
    3     2
   / \   / \
  6   5 8   4

特点：堆顶是最小值
```

---

## 2. 🏗️ 完全二叉树结构


### 2.1 什么是完全二叉树？


**🔸 完全二叉树的特点**
```
完全二叉树（正确）：
       1
     /   \
    2     3
   / \   /
  4   5 6

除了最后一层，其他层都填满
最后一层从左到右连续填充
```

```
不是完全二叉树（错误）：
       1
     /   \
    2     3
   /     / \
  4     5   6

最后一层不是从左到右连续的
```

### 2.2 为什么堆要用完全二叉树？


**💡 核心原因**：可以用**数组**完美表示！

```
堆的数组表示：
       1        数组：[0, 1, 2, 3, 4, 5, 6]
     /   \      索引： 0  1  2  3  4  5  6
    2     3     
   / \   / \    节点值对应数组值：
  4   5 6   7   下标0不用，从下标1开始
```

**🔧 数组索引的神奇关系**
```java
对于数组中索引为 i 的节点：
父节点索引：i / 2
左子节点索引：i * 2
右子节点索引：i * 2 + 1

例如：节点5（索引5）
父节点：5/2 = 2（节点2）
左子节点：5*2 = 10（不存在）
右子节点：5*2+1 = 11（不存在）
```

### 2.3 数组实现的优势


**⚡ 为什么不用指针？**
```
指针方式：
class TreeNode {
    int val;
    TreeNode left, right;  // 需要额外存储指针
}

数组方式：
int[] heap = new int[100];  // 只存储值，通过计算找到父子关系

优势：
✅ 节省内存（不需要存指针）
✅ 缓存友好（数组连续存储）
✅ 索引计算简单快速
```

---

## 3. ⚖️ 堆序性质


### 3.1 堆序性质是什么？


**🔸 大顶堆的堆序性质**
```
每个父节点的值 ≥ 其子节点的值

       50
     /    \
   30      40    ✅ 50≥30, 50≥40
  /  \    /  \
 10  20  15  25  ✅ 30≥10, 30≥20, 40≥15, 40≥25
```

**⚠️ 注意**：堆序性质**不要求**左右子树之间有大小关系！
```
这是合法的大顶堆：
       50
     /    \
   40      30    ✅ 左子树40 > 右子树30，但仍然合法
  /  \    /  \
 20  35  15  25
```

### 3.2 堆序性质的维护


**💡 核心思想**：当堆序性质被破坏时，需要**调整**来恢复

**🔄 两种调整方向**
```
向上调整（上浮）：
新插入的元素可能比父节点大
需要向上交换直到满足堆序性质

向下调整（下沉）：
删除根节点后，可能破坏堆序性质
需要向下交换直到满足堆序性质
```

### 3.3 堆序性质的好处


**🎯 快速访问极值**
```java
// 获取最大值（大顶堆）
public int getMax() {
    return heap[1];  // O(1) 时间复杂度
}

// 获取最小值（小顶堆）
public int getMin() {
    return heap[1];  // O(1) 时间复杂度
}
```

**🔍 部分有序的智慧**
堆不是完全排序的，但足够解决"找极值"问题：
- 比完全排序更高效
- 比无序数组更有结构

---

## 4. 🔧 堆操作实现


### 4.1 堆的基本结构


```java
public class MaxHeap {
    private int[] heap;
    private int size;        // 当前堆中元素个数
    private int capacity;    // 堆的最大容量
    
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.heap = new int[capacity + 1];  // 索引0不使用
        this.size = 0;
    }
}
```

### 4.2 插入操作（上浮）


**🔸 插入思路**
1. 把新元素放到堆的**末尾**
2. 与父节点比较，如果比父节点大就**交换**
3. 重复步骤2，直到满足堆序性质

```java
public void insert(int value) {
    if (size >= capacity) {
        throw new IllegalStateException("堆已满");
    }
    
    // 1. 放到末尾
    size++;
    heap[size] = value;
    
    // 2. 上浮调整
    swim(size);
}

// 上浮操作
private void swim(int k) {
    while (k > 1 && heap[k] > heap[k/2]) {
        // 与父节点交换
        swap(k, k/2);
        k = k/2;  // 继续向上
    }
}
```

**📊 插入过程示例**
```
插入前：        插入35：         上浮调整：
    50              50              50
   /  \            /  \            /  \
  30  40          30  40          35  40
 /  \            /  \  \         /  \  \
10  20          10  20  35      10  30  20
```

### 4.3 删除操作（下沉）


**🔸 删除思路**
1. 保存堆顶元素（要返回的值）
2. 把**最后一个元素**移到堆顶
3. 删除最后一个元素，size减1
4. 堆顶元素**下沉**，恢复堆序性质

```java
public int deleteMax() {
    if (size == 0) {
        throw new IllegalStateException("堆为空");
    }
    
    // 1. 保存最大值
    int max = heap[1];
    
    // 2. 最后元素移到堆顶
    heap[1] = heap[size];
    size--;
    
    // 3. 下沉调整
    sink(1);
    
    return max;
}

// 下沉操作
private void sink(int k) {
    while (2 * k <= size) {  // 存在左子节点
        int j = 2 * k;  // 左子节点
        
        // 找到较大的子节点
        if (j < size && heap[j] < heap[j+1]) {
            j++;  // 右子节点更大
        }
        
        // 如果父节点已经比子节点大，停止
        if (heap[k] >= heap[j]) {
            break;
        }
        
        // 与较大子节点交换
        swap(k, j);
        k = j;
    }
}
```

### 4.4 辅助方法


```java
// 交换两个元素
private void swap(int i, int j) {
    int temp = heap[i];
    heap[i] = heap[j];
    heap[j] = temp;
}

// 获取堆大小
public int size() {
    return size;
}

// 判断堆是否为空
public boolean isEmpty() {
    return size == 0;
}
```

---

## 5. 🎯 优先队列应用


### 5.1 什么是优先队列？


**🔸 普通队列 vs 优先队列**
```
普通队列（FIFO）：
进队：A → B → C → D
出队：A ← B ← C ← D

优先队列：
进队：任务A(优先级3) → 任务B(优先级1) → 任务C(优先级5)
出队：任务C(优先级5) ← 任务A(优先级3) ← 任务B(优先级1)
     （优先级高的先出队）
```

**💡 核心特点**：不是先进先出，而是**优先级高的先出**

### 5.2 堆实现优先队列


```java
public class PriorityQueue {
    private MaxHeap heap;
    
    public PriorityQueue(int capacity) {
        heap = new MaxHeap(capacity);
    }
    
    // 入队（插入）
    public void enqueue(int priority) {
        heap.insert(priority);
    }
    
    // 出队（删除最大优先级）
    public int dequeue() {
        return heap.deleteMax();
    }
    
    // 查看最高优先级
    public int peek() {
        return heap.getMax();
    }
}
```

### 5.3 实际应用场景


**🏥 医院急诊系统**
```java
class Patient {
    String name;
    int urgency;  // 紧急程度1-10，10最紧急
    
    public Patient(String name, int urgency) {
        this.name = name;
        this.urgency = urgency;
    }
}

// 急诊优先队列
PriorityQueue<Patient> emergency = new PriorityQueue<>(
    (a, b) -> b.urgency - a.urgency  // 紧急程度高的优先
);

emergency.add(new Patient("张三", 3));  // 普通病人
emergency.add(new Patient("李四", 9));  // 重症病人
emergency.add(new Patient("王五", 5));  // 中等病人

// 出队顺序：李四(9) → 王五(5) → 张三(3)
```

**🖥️ 操作系统任务调度**
```
CPU任务调度：
- 系统任务（优先级9）
- 用户交互任务（优先级7）
- 后台任务（优先级3）

优先队列确保重要任务先执行
```

**🗂️ 实时数据处理**
```
股票交易系统：
- 大额交易订单（高优先级）
- 普通交易订单（中优先级）
- 查询请求（低优先级）
```

---

## 6. 📊 堆排序算法


### 6.1 堆排序的基本思想


**💡 核心思路**
1. 把无序数组构建成一个大顶堆
2. 将堆顶（最大值）与堆尾交换
3. 堆大小减1，对新堆顶进行下沉调整
4. 重复步骤2-3，直到堆大小为1

```
排序过程：
原数组：[4, 6, 8, 5, 9]

1. 构建大顶堆：
       9
     /   \
    6     8
   / \
  5   4

2. 交换堆顶与堆尾：
       4
     /   \
    6     8    [9] (已排序)
   /
  5

3. 下沉调整，重复...
```

### 6.2 堆排序实现


```java
public class HeapSort {
    
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // 1. 构建大顶堆（从最后一个非叶子节点开始）
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 2. 依次取出堆顶元素
        for (int i = n - 1; i > 0; i--) {
            // 堆顶与末尾交换
            swap(arr, 0, i);
            
            // 重新调整堆
            heapify(arr, i, 0);
        }
    }
    
    // 堆化（下沉调整）
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;    // 假设父节点最大
        int left = 2 * i + 1;   // 左子节点
        int right = 2 * i + 2;  // 右子节点
        
        // 找到最大值的索引
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // 如果最大值不是父节点，需要交换并继续调整
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 6.3 堆排序的特点


**📊 时间复杂度分析**
```
构建堆：O(n)
每次调整：O(log n)
总共n-1次调整：O(n log n)
整体时间复杂度：O(n log n)
```

**🎯 堆排序优缺点**
```
优点：
✅ 时间复杂度稳定 O(n log n)
✅ 空间复杂度 O(1)（原地排序）
✅ 不会出现最坏情况的性能退化

缺点：
❌ 不稳定排序（相同元素位置可能改变）
❌ 常数因子较大，实际速度不如快排
❌ 缓存局部性不好
```

### 6.4 什么时候用堆排序？


**🎯 适用场景**
```
✅ 内存受限，需要原地排序
✅ 要求时间复杂度稳定
✅ 不关心排序稳定性
✅ 只需要找到前K个最大/最小值

❌ 不适用场景：
❌ 需要稳定排序
❌ 小数据量（开销大）
❌ 对缓存性能要求高
```

---

## 7. 📋 核心要点总结


### 7.1 必须理解的核心概念


**🔸 堆的本质**
```
堆 = 完全二叉树 + 堆序性质
目的：快速找到最大值/最小值
实现：用数组模拟完全二叉树
```

**🔸 堆的核心操作**
```
插入：末尾添加 → 上浮调整
删除：保存堆顶 → 末尾移到堆顶 → 下沉调整
查看：直接返回堆顶元素
```

**🔸 堆序性质的理解**
```
大顶堆：父节点 ≥ 子节点
小顶堆：父节点 ≤ 子节点
注意：兄弟节点之间没有大小要求！
```

### 7.2 关键思维要点


**🧠 堆思维的精髓**
```
不追求完全有序：
- 只保证"部分有序"
- 极值总在堆顶
- 比完全排序更高效

结构与性质的平衡：
- 完全二叉树保证操作效率
- 堆序性质保证极值访问
- 数组表示节省空间
```

**🎯 应用场景的选择**
```
选择堆的时机：
✅ 频繁需要最大/最小值
✅ 动态数据（插入删除频繁）
✅ 优先级队列需求
✅ Top K 问题

不选择堆的时机：
❌ 需要完全排序
❌ 频繁查找任意元素
❌ 数据量很小
❌ 需要稳定排序
```

### 7.3 实践应用指导


**💡 堆的使用技巧**
```
大顶堆 vs 小顶堆的选择：
- 求最大值、Top K最大 → 大顶堆
- 求最小值、Top K最小 → 小顶堆
- 求中位数 → 大小顶堆配合使用

性能优化要点：
- 预估容量，避免频繁扩容
- 合理选择初始堆大小
- 注意数组索引从1开始的约定
```

**🔧 常见问题解决**
```
Q: 为什么数组索引从1开始？
A: 方便计算父子关系，父=i/2，子=2*i

Q: 堆和优先队列什么关系？
A: 堆是实现优先队列的最佳数据结构

Q: 什么时候用堆排序？
A: 内存受限且需要O(n log n)稳定性能时
```

### 7.4 记忆要点


**📝 堆思维口诀**
```
堆是树来数组装，
父大子小有规章。
插入末尾往上浮，
删除堆顶向下降。
优先队列堆来建，
极值查找最在行！
```

**🎯 核心公式**
```
数组索引关系（从1开始）：
父节点：i / 2
左子节点：i * 2  
右子节点：i * 2 + 1

时间复杂度：
插入/删除：O(log n)
查看极值：O(1)
构建堆：O(n)
```

**💭 思维转换**
从"完全排序"思维转向"极值优先"思维，这是理解堆的关键！堆不是为了让所有数据有序，而是为了让我们能快速找到最重要的那个数据。