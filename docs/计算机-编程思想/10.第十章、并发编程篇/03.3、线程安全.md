---
title: 3、线程安全
---
## 📚 目录

1. [线程安全基本概念](#1-线程安全基本概念)
2. [竞态条件](#2-竞态条件)
3. [原子操作](#3-原子操作)
4. [可见性问题](#4-可见性问题)
5. [有序性问题](#5-有序性问题)
6. [内存模型](#6-内存模型)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔒 线程安全基本概念


### 1.1 什么是线程安全


**📋 通俗理解**
```
线程安全就像多人同时使用一个银行账户：
- 安全的情况：每个人操作都是正确的，不会出错
- 不安全的情况：多人同时取钱可能导致账户余额错乱

编程中的线程安全：
多个线程同时访问同一个数据时，程序的行为是正确和可预期的
```

**🎯 核心特征**
- **`正确性`**：无论多少个线程同时运行，结果都是正确的
- **`一致性`**：数据状态始终保持一致，不会出现中间状态
- **`可预期性`**：程序行为是确定的，不会因为线程调度而改变

### 1.2 为什么需要线程安全


**🔄 多线程的现实场景**
```
网上购物系统：
线程A：用户查看商品库存 → 显示还有10件
线程B：另一用户购买商品 → 库存减1变成9件  
线程A：用户下单购买 → 基于之前看到的10件库存

如果没有线程安全保护：
可能出现超卖，库存变成负数的情况
```

**⚠️ 线程不安全的后果**
- **数据错乱**：计算结果不正确
- **状态不一致**：程序处于无效状态
- **业务逻辑错误**：违反业务规则
- **系统崩溃**：严重时可能导致程序崩溃

---

## 2. 🏃‍♂️ 竞态条件


### 2.1 什么是竞态条件


**📝 定义说明**
```
竞态条件（Race Condition）：
多个线程同时访问和修改共享数据，最终结果取决于线程的执行顺序

就像两个人同时伸手去拿桌上最后一个苹果：
- 谁先抢到取决于动作快慢
- 结果不可预测
- 可能发生冲突
```

### 2.2 竞态条件的经典示例


**💰 银行账户例子**
```java
public class BankAccount {
    private int balance = 1000; // 账户余额
    
    // 不安全的取款方法
    public void withdraw(int amount) {
        if (balance >= amount) {    // 步骤1：检查余额
            // 假设这里发生线程切换...
            balance = balance - amount; // 步骤2：扣除金额
            System.out.println("取款成功，余额：" + balance);
        }
    }
}

// 危险场景：
// 线程A：取款500，检查余额1000 >= 500 ✓
// 线程B：取款600，检查余额1000 >= 600 ✓  
// 线程A：扣除500，余额变成500
// 线程B：扣除600，余额变成-100 ❌ 透支了！
```

**📊 计数器例子**
```java
public class Counter {
    private int count = 0;
    
    // 不安全的递增操作
    public void increment() {
        count++; // 看似简单，实际包含3个步骤
    }
    
    public int getCount() {
        return count;
    }
}

// count++ 实际分解为：
// 1. 读取count的值到临时变量
// 2. 临时变量加1  
// 3. 将结果写回count变量
// 
// 多线程环境下可能出现：
// 线程A读取count=5
// 线程B读取count=5  
// 线程A计算5+1=6，写入count
// 线程B计算5+1=6，写入count
// 结果：两次increment()操作，count只增加了1
```

### 2.3 如何解决竞态条件


**🔐 使用同步锁**
```java
public class SafeBankAccount {
    private int balance = 1000;
    private final Object lock = new Object(); // 锁对象
    
    public void withdraw(int amount) {
        synchronized (lock) { // 同步块，确保原子性
            if (balance >= amount) {
                balance = balance - amount;
                System.out.println("取款成功，余额：" + balance);
            }
        }
    }
}
```

**🎯 解决方案原理**
```
同步锁的作用：
1. 互斥性：同一时间只有一个线程能执行同步代码
2. 原子性：整个操作要么全部完成，要么全部不执行
3. 有序性：确保操作按预期顺序执行

就像银行柜台：
- 同一时间只能服务一个客户
- 一个客户的业务必须完整处理完才能服务下一个
- 不会出现业务办一半就换人的情况
```

---

## 3. ⚛️ 原子操作


### 3.1 什么是原子操作


**🔬 基本概念**
```
原子操作（Atomic Operation）：
不可分割的操作，要么全部完成，要么全部不执行

就像吞药片：
- 药片要么完整吞下去，要么没吞
- 不会出现吞了一半的状态
- 这就是"原子性"
```

**📋 原子操作的特点**
- **`不可中断`**：执行过程中不会被其他线程干扰
- **`状态一致`**：操作前后数据状态都是有效的
- **`线程安全`**：天然具备线程安全性

### 3.2 哪些操作是原子的


**✅ 原子操作示例**
```java
// 基本类型的简单赋值（32位以下）
int a = 10;        // 原子操作
boolean flag = true; // 原子操作
Object obj = new Object(); // 引用赋值，原子操作

// 读取操作
int value = a;     // 原子操作
boolean status = flag; // 原子操作
```

**❌ 非原子操作示例**
```java
// 64位类型在32位系统上
long bigNumber = 123456789L; // 可能非原子（分两次写入）
double decimal = 3.14;       // 可能非原子

// 复合操作
count++;           // 非原子：读取->计算->写入
count += 5;        // 非原子：读取->计算->写入
array[index]++;    // 非原子：数组访问+递增
```

### 3.3 Java中的原子类


**🛠️ AtomicInteger示例**
```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    // 原子递增
    public void increment() {
        count.incrementAndGet(); // 原子操作，线程安全
    }
    
    // 原子获取
    public int getCount() {
        return count.get(); // 原子操作
    }
    
    // 原子的比较并设置
    public boolean setIfEquals(int expect, int update) {
        return count.compareAndSet(expect, update);
    }
}

// 使用示例
AtomicCounter counter = new AtomicCounter();
// 多个线程同时调用increment()是安全的
counter.increment(); // 线程安全的递增
```

**🔄 CAS操作原理**
```
CAS（Compare And Swap）比较并交换：
1. 比较：检查内存中的值是否等于期望值
2. 交换：如果相等，则更新为新值
3. 返回：告诉调用者操作是否成功

比如更新count从5到6：
compareAndSet(5, 6) → 如果当前值是5，就改成6，返回true
                   → 如果当前值不是5，就不改，返回false

这个操作是CPU指令级的原子操作，天然线程安全
```

---

## 4. 👁️ 可见性问题


### 4.1 什么是可见性问题


**🔍 基本概念**
```
可见性问题：
一个线程修改了共享变量，其他线程看不到这个修改

就像两个房间的人通过窗户交流：
- A房间的人在白板上写了新内容
- B房间的人因为角度问题看不到更新
- B房间的人还在基于旧内容做决定
```

**🖥️ CPU缓存导致的可见性问题**
```
现代计算机的内存结构：
CPU1 → L1缓存 → L2缓存 ↘
                         → 主内存
CPU2 → L1缓存 → L2缓存 ↗

问题：
1. 线程1修改变量，先写入自己的缓存
2. 线程2读取变量，从自己的缓存读取
3. 线程2看到的还是旧值，看不到线程1的修改
```

### 4.2 可见性问题示例


**🔄 经典的停止标志问题**
```java
public class VisibilityProblem {
    private boolean running = true; // 共享变量
    
    public void worker() {
        while (running) { // 线程可能一直循环
            // 执行工作...
            doWork();
        }
        System.out.println("工作线程停止");
    }
    
    public void shutdown() {
        running = false; // 主线程设置停止标志
        System.out.println("发送停止信号");
    }
    
    private void doWork() {
        // 模拟工作
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// 可能的问题：
// 主线程调用shutdown()设置running=false
// 工作线程可能看不到这个修改，继续运行
// 导致程序无法正常停止
```

### 4.3 解决可见性问题


**⚡ 使用volatile关键字**
```java
public class VolatileSolution {
    private volatile boolean running = true; // 保证可见性
    
    public void worker() {
        while (running) { // 能及时看到running的变化
            doWork();
        }
        System.out.println("工作线程停止");
    }
    
    public void shutdown() {
        running = false; // 修改立即对其他线程可见
        System.out.println("发送停止信号");
    }
}
```

**🔐 使用同步机制**
```java
public class SynchronizedSolution {
    private boolean running = true;
    private final Object lock = new Object();
    
    public void worker() {
        while (isRunning()) { // 通过同步方法读取
            doWork();
        }
        System.out.println("工作线程停止");
    }
    
    public void shutdown() {
        synchronized (lock) {
            running = false; // 同步写入
        }
        System.out.println("发送停止信号");
    }
    
    private boolean isRunning() {
        synchronized (lock) {
            return running; // 同步读取
        }
    }
}
```

**💡 volatile vs synchronized的区别**
```
volatile：
✓ 保证可见性
✓ 禁止指令重排序
✗ 不保证原子性
✓ 性能开销小
适用：状态标志、配置参数等简单场景

synchronized：
✓ 保证可见性
✓ 保证原子性
✓ 保证有序性
✗ 性能开销大
适用：复杂的同步控制场景
```

---

## 5. 📐 有序性问题


### 5.1 什么是有序性问题


**🔄 基本概念**
```
有序性问题（指令重排序）：
为了提高性能，CPU和编译器可能会调整指令的执行顺序

就像做菜的步骤：
原计划：1.洗菜 → 2.切菜 → 3.热锅 → 4.炒菜
优化后：1.热锅 → 2.洗菜 → 3.切菜 → 4.炒菜
单线程下结果一样，但多线程可能出问题
```

**🔧 为什么会重排序**
- **`编译器优化`**：编译时调整代码顺序提高效率
- **`CPU优化`**：处理器级别的指令重排序
- **`内存系统优化`**：缓存和内存访问优化

### 5.2 有序性问题示例


**🏗️ 单例模式的双重检查锁定问题**
```java
public class Singleton {
    private static Singleton instance;
    
    public static Singleton getInstance() {
        if (instance == null) {           // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {   // 第二次检查
                    instance = new Singleton(); // 问题出现在这里！
                }
            }
        }
        return instance;
    }
}

// new Singleton() 可能被重排序为：
// 1. 分配内存空间
// 2. 将instance指向内存空间（但对象还没初始化完成）
// 3. 初始化对象
//
// 如果步骤2和3重排序：
// 线程A：执行到步骤2，instance不为null但对象未初始化
// 线程B：检查instance != null，直接返回未初始化的对象
// 结果：使用了不完整的对象，可能导致程序错误
```

**📊 变量赋值顺序问题**
```java
public class ReorderingExample {
    private int a = 0;
    private boolean flag = false;
    
    // 线程1执行
    public void writer() {
        a = 1;          // 操作1
        flag = true;    // 操作2
    }
    
    // 线程2执行  
    public void reader() {
        if (flag) {     // 操作3
            int result = a * 2; // 操作4：期望a=1，result=2
            System.out.println(result);
        }
    }
}

// 可能的重排序：
// 编译器可能调整writer()中的顺序：
// flag = true;  // 先设置标志
// a = 1;        // 后赋值
//
// 导致问题：
// 线程2看到flag=true但a还是0，result=0而不是期望的2
```

### 5.3 解决有序性问题


**⚡ 使用volatile防止重排序**
```java
public class VolatileOrdering {
    private int a = 0;
    private volatile boolean flag = false; // volatile防止重排序
    
    public void writer() {
        a = 1;          // 在volatile写之前的操作不会重排序到之后
        flag = true;    // volatile写
    }
    
    public void reader() {
        if (flag) {     // volatile读
            int result = a * 2; // 在volatile读之后的操作不会重排序到之前
            System.out.println(result); // 保证看到a=1
        }
    }
}
```

**🔐 修复单例模式**
```java
public class SafeSingleton {
    private static volatile Singleton instance; // 关键：使用volatile
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // 现在是安全的
                }
            }
        }
        return instance;
    }
}
```

**📋 happens-before规则**
```
Java内存模型定义的有序性保证：

1. 程序顺序规则：单线程内，按代码顺序执行
2. 锁规则：unlock操作 happens-before 后续的lock操作
3. volatile规则：volatile写 happens-before 后续的volatile读
4. 线程启动规则：Thread.start() happens-before 线程内的所有操作
5. 线程终止规则：线程内所有操作 happens-before Thread.join()

这些规则保证了特定情况下的执行顺序
```

---

## 6. 🧠 内存模型


### 6.1 什么是内存模型


**🏗️ 基本概念**
```
内存模型（Memory Model）：
定义了多线程程序中内存访问的规则和行为

就像交通规则：
- 规定了车辆如何行驶
- 保证交通有序进行
- 避免事故发生

内存模型规定了：
- 线程如何访问共享内存
- 什么时候能看到其他线程的修改
- 操作的执行顺序
```

### 6.2 Java内存模型（JMM）


**🔄 JMM的基本结构**
```
Java内存模型抽象结构：

线程1                     线程2
 ↓                        ↓
工作内存1                 工作内存2
(本地变量副本)            (本地变量副本)
 ↓                        ↓
        ↘              ↙
          主内存（共享）
      (所有共享变量)

工作流程：
1. 线程从主内存读取变量到工作内存
2. 线程在工作内存中操作变量
3. 线程将修改后的变量写回主内存
```

**📊 内存操作的原子动作**
```
JMM定义了8种内存操作：

主内存操作：
- read：从主内存读取变量
- write：向主内存写入变量  
- lock：锁定主内存变量
- unlock：解锁主内存变量

工作内存操作：
- load：将read的值载入工作内存
- store：将工作内存值传送给主内存
- use：将工作内存变量传递给执行引擎
- assign：将执行引擎的值赋给工作内存变量
```

### 6.3 内存模型的作用


**🎯 解决的核心问题**
```
1. 可见性：何时能看到其他线程的修改
   volatile、synchronized、final等机制保证

2. 原子性：哪些操作是不可分割的
   synchronized、原子类等保证

3. 有序性：操作的执行顺序
   volatile、synchronized等防止重排序

4. 一致性：内存状态的一致性视图
   happens-before关系保证
```

**⚡ 同步机制在内存模型中的作用**
```java
public class MemoryModelExample {
    private int sharedVar = 0;
    private volatile boolean flag = false;
    
    // synchronized的内存语义
    public synchronized void syncMethod() {
        sharedVar++; // 进入sync时从主内存刷新，退出时写回主内存
    }
    
    // volatile的内存语义
    public void volatileExample() {
        sharedVar = 1;   // 普通写
        flag = true;     // volatile写，强制前面的写操作刷新到主内存
    }
    
    public void readExample() {
        if (flag) {      // volatile读，强制后面的读操作从主内存读取
            int local = sharedVar; // 保证能看到最新值
        }
    }
}
```

### 6.4 实际编程指导


**📋 选择合适的同步机制**
```
场景分析：

简单状态标志：
✓ 使用volatile
int status;
volatile boolean ready = false;

计数器操作：
✓ 使用AtomicInteger
AtomicInteger counter = new AtomicInteger();

复杂状态更新：
✓ 使用synchronized
synchronized(lock) {
    // 多步操作
    balance -= amount;
    transactions++;
}

高性能读取：
✓ 读写锁
ReadWriteLock lock = new ReentrantReadWriteLock();
```

**⚠️ 常见误区和注意事项**
```
误区1：以为volatile保证原子性
volatile int count = 0;
count++; // 仍然不是原子操作！

误区2：以为synchronized很重
// 现代JVM对synchronized优化很好，性能不错

误区3：过度使用volatile
// 只有确实需要可见性保证时才使用

正确做法：
1. 理解需要解决的具体问题（可见性/原子性/有序性）
2. 选择最简单有效的解决方案
3. 在性能和安全之间找到平衡
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔒 线程安全的本质：
- 多线程环境下程序行为的正确性和可预期性
- 需要解决竞态条件、可见性、有序性三大问题

⚛️ 原子操作的重要性：
- 不可分割的操作，要么全部完成要么全部不执行
- Java提供AtomicXXX类支持原子操作
- CAS是实现原子操作的重要机制

👁️ 可见性问题的根源：
- CPU缓存导致线程间数据不可见
- volatile和synchronized可以保证可见性
- 选择合适的机制很重要

📐 有序性问题的影响：
- 指令重排序可能导致程序行为异常
- volatile可以防止特定的重排序
- happens-before规则定义了有序性保证

🧠 内存模型的作用：
- 定义多线程内存访问规则
- 提供各种同步机制的语义保证
- 是并发编程的理论基础
```

### 7.2 实际编程指导原则


**🎯 问题诊断步骤**
```
1. 识别共享数据：找出多线程访问的变量
2. 分析访问模式：读多写少？频繁修改？
3. 确定需要的保证：原子性？可见性？有序性？
4. 选择合适方案：volatile？synchronized？原子类？
5. 测试验证：编写测试确保线程安全
```

**🔧 解决方案选择指南**
```
简单标志变量：
volatile boolean flag; ✓

简单计数器：
AtomicInteger counter; ✓

复杂状态更新：
synchronized (lock) { ... } ✓

高频读取，偶尔写入：
ReadWriteLock ✓

无锁高性能：
CAS + 重试 ✓
```

**⚠️ 常见陷阱避免**
```
1. volatile不能替代synchronized
   volatile只保证可见性，不保证原子性

2. 不要忽略64位变量的特殊性
   long和double在32位系统上可能不是原子的

3. 理解happens-before关系
   不要依赖侥幸，要有明确的同步保证

4. 性能不是唯一考虑
   正确性比性能更重要，先保证正确再优化

5. 测试无法完全保证线程安全
   需要通过代码审查和理论分析
```

### 7.3 学习建议


**📚 知识体系建设**
```
基础概念 → 实际问题 → 解决方案 → 性能优化

1. 理解基本概念：什么是线程安全
2. 识别常见问题：竞态条件、可见性、有序性  
3. 掌握解决工具：synchronized、volatile、原子类
4. 学会选择方案：根据场景选择最适合的方法
5. 关注性能优化：在保证正确的基础上提升性能
```

**🎪 实践练习建议**
```
1. 编写简单的多线程计数器程序
2. 实现线程安全的单例模式
3. 练习使用不同的同步机制
4. 分析现有代码的线程安全问题
5. 阅读优秀开源项目的并发代码
```

**核心记忆口诀**：
```
线程安全三要素，原子可见加有序
竞态条件要避免，同步机制来保护
volatile轻量级，synchronized重保险
原子类CAS好，内存模型是基础
```