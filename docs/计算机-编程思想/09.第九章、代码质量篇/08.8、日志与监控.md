---
title: 8、日志与监控
---
## 📚 目录

1. [日志级别设计](#1-日志级别设计)
2. [结构化日志](#2-结构化日志) 
3. [性能监控](#3-性能监控)
4. [错误追踪](#4-错误追踪)
5. [调试信息记录](#5-调试信息记录)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📊 日志级别设计


### 1.1 什么是日志级别


**💡 核心概念**：日志级别就像医院的紧急程度分级，帮我们区分哪些信息重要，哪些不重要。

```
就像医院分诊：
🚨 急诊 (ERROR)   - 生命危险，立即处理
⚠️  普通门诊 (WARN) - 需要关注，但不紧急  
ℹ️  体检 (INFO)    - 常规检查，了解状况
🔍 化验 (DEBUG)   - 详细检查，找问题原因
```

### 1.2 标准日志级别详解


**🎯 五大核心级别**

| 级别 | **英文名** | **中文含义** | **使用场景** | **是否影响用户** |
|------|-----------|-------------|-------------|----------------|
| 🔥 **ERROR** | `错误` | `系统出错了` | `支付失败、数据库连不上` | `直接影响用户` |
| ⚠️ **WARN** | `警告` | `有问题但还能工作` | `磁盘空间不足、接口响应慢` | `可能影响用户` |
| ℹ️ **INFO** | `信息` | `正常的重要事件` | `用户登录、订单创建` | `不影响用户` |
| 🔍 **DEBUG** | `调试` | `程序内部详细信息` | `变量值、执行路径` | `不影响用户` |
| 📝 **TRACE** | `跟踪` | `最详细的执行信息` | `每一步执行细节` | `不影响用户` |

### 1.3 日志级别使用策略


**🎯 ERROR级别 - 必须立即处理**
```java
// ✅ 正确使用ERROR
try {
    paymentService.processPayment(order);
} catch (PaymentException e) {
    logger.error("支付处理失败，订单ID: {}, 错误: {}", 
                 order.getId(), e.getMessage(), e);
    // 这会直接影响用户，必须记录ERROR
}

// ❌ 错误使用ERROR  
if (user.getAge() < 18) {
    logger.error("用户年龄小于18岁"); // 这不是错误，应该用INFO
}
```

**⚠️ WARN级别 - 需要关注但不紧急**
```java
// ✅ 正确使用WARN
if (dbConnectionPool.getActiveConnections() > 80) {
    logger.warn("数据库连接池使用率过高: {}%", 
                dbConnectionPool.getUsagePercent());
}

// 接口响应时间过长
if (responseTime > 3000) {
    logger.warn("接口响应时间过长: {}ms, API: {}", 
                responseTime, apiName);
}
```

**ℹ️ INFO级别 - 重要的业务事件**
```java
// ✅ 正确使用INFO - 记录重要业务事件
logger.info("用户登录成功，用户ID: {}, IP: {}", 
            userId, request.getRemoteAddr());

logger.info("订单创建成功，订单号: {}, 用户: {}, 金额: {}", 
            order.getOrderNo(), order.getUserId(), order.getAmount());

// ❌ 不要滥用INFO
logger.info("进入getUserById方法"); // 太琐碎了，应该用DEBUG
```

### 1.4 生产环境级别配置


**🎯 不同环境的建议配置**

```yaml
# 开发环境 - 看到所有信息
logging:
  level:
    root: DEBUG
    com.yourcompany: TRACE

# 测试环境 - 关注业务流程    
logging:
  level:
    root: INFO
    com.yourcompany: DEBUG

# 生产环境 - 只看重要信息
logging:
  level:
    root: WARN
    com.yourcompany: INFO
```

**💡 级别选择原则**
```
生产环境日志原则：
✅ ERROR - 立即报警，半夜也要起床处理
✅ WARN  - 工作时间关注，可能需要优化
✅ INFO  - 业务统计分析，了解系统运行状况
❌ DEBUG - 生产环境一般不开启（占用资源）
❌ TRACE - 生产环境绝对不开启（信息过多）
```

---

## 2. 🔧 结构化日志


### 2.1 什么是结构化日志


**💡 通俗理解**：结构化日志就像把散乱的便条整理成表格，让信息更容易查找和分析。

```
传统日志（像散乱便条）：
2024-08-17 14:30:00 用户张三登录失败，IP地址192.168.1.100，原因密码错误

结构化日志（像整齐表格）：
{
  "timestamp": "2024-08-17T14:30:00",
  "level": "WARN", 
  "event": "login_failed",
  "user": "张三",
  "ip": "192.168.1.100", 
  "reason": "wrong_password"
}
```

### 2.2 结构化日志的优势


**🎯 为什么要用结构化日志**

| 对比项 | **传统日志** | **结构化日志** |
|--------|-------------|---------------|
| **搜索** | `只能文本搜索` | `可以按字段精确搜索` |
| **统计** | `需要写复杂正则` | `直接SQL式查询` |
| **分析** | `人工分析，效率低` | `机器自动分析` |
| **可读性** | `格式不统一` | `格式统一，清晰` |

### 2.3 结构化日志实现


**📝 JSON格式设计**
```java
// ✅ 标准结构化日志格式
public class LogEvent {
    private String timestamp;     // 时间戳
    private String level;         // 日志级别  
    private String service;       // 服务名称
    private String event;         // 事件类型
    private String userId;        // 用户ID
    private String ip;           // IP地址
    private Map<String, Object> data; // 扩展数据
}

// 实际使用示例
@Component
public class StructuredLogger {
    
    public void logUserLogin(String userId, String ip, boolean success) {
        LogEvent event = LogEvent.builder()
            .timestamp(Instant.now().toString())
            .level(success ? "INFO" : "WARN")
            .service("user-service")
            .event(success ? "user_login_success" : "user_login_failed")
            .userId(userId)
            .ip(ip)
            .build();
            
        logger.info(JSON.toJSONString(event));
    }
}
```

**🔍 查询优势展示**
```bash
# 传统日志查询（困难）
grep "登录失败" app.log | grep "张三" | wc -l

# 结构化日志查询（简单）
SELECT COUNT(*) FROM logs 
WHERE event='login_failed' AND user='张三'
AND timestamp > '2024-08-17'
```

### 2.4 结构化日志最佳实践


**🎯 字段设计原则**
```json
{
  // 必须字段 - 每条日志都要有
  "timestamp": "2024-08-17T14:30:00Z",
  "level": "INFO",
  "service": "order-service",
  "event": "order_created",
  
  // 业务字段 - 根据具体业务
  "userId": "user123", 
  "orderId": "order456",
  "amount": 99.99,
  
  // 技术字段 - 调试和追踪用
  "requestId": "req-789",
  "duration": 120,
  "ip": "192.168.1.100"
}
```

---

## 3. 📈 性能监控


### 3.1 什么是性能监控


**💡 通俗理解**：性能监控就像给汽车装仪表盘，随时看速度、油耗、温度，及时发现问题。

```
汽车仪表盘对应系统监控：
🚗 车速 → 🖥️ 请求处理速度(QPS)
⛽ 油耗 → 💾 内存使用率  
🌡️ 水温 → 🔥 CPU使用率
🔧 故障灯 → 🚨 错误率
```

### 3.2 核心性能指标


**🎯 四大黄金指标**

| 指标 | **含义** | **正常范围** | **监控意义** |
|------|---------|-------------|-------------|
| **🚀 延迟(Latency)** | `请求响应时间` | `< 200ms` | `用户体验直接感受` |
| **📊 流量(Traffic)** | `每秒请求数(QPS)` | `根据业务` | `系统负载情况` |
| **❌ 错误率(Errors)** | `失败请求占比` | `< 1%` | `系统稳定性` |
| **💾 饱和度(Saturation)** | `资源使用率` | `< 80%` | `系统容量评估` |

### 3.3 监控实现方案


**⚡ 延迟监控 - 最直观的用户体验**
```java
@Component
public class PerformanceMonitor {
    
    @Around("@annotation(MonitorPerformance)")
    public Object monitorExecutionTime(ProceedingJoinPoint point) {
        long startTime = System.currentTimeMillis();
        String methodName = point.getSignature().getName();
        
        try {
            Object result = point.proceed();
            long duration = System.currentTimeMillis() - startTime;
            
            // 记录性能日志
            logger.info("性能监控: {}, 耗时: {}ms", methodName, duration);
            
            // 如果超过阈值，记录警告
            if (duration > 1000) {
                logger.warn("方法执行超时: {}, 耗时: {}ms", methodName, duration);
            }
            
            return result;
        } catch (Throwable e) {
            long duration = System.currentTimeMillis() - startTime;
            logger.error("方法执行异常: {}, 耗时: {}ms, 错误: {}", 
                        methodName, duration, e.getMessage());
            throw e;
        }
    }
}
```

**📊 流量监控 - 了解系统负载**
```java
@Component
public class TrafficMonitor {
    private final AtomicLong requestCount = new AtomicLong(0);
    private final AtomicLong lastResetTime = new AtomicLong(System.currentTimeMillis());
    
    public void recordRequest() {
        requestCount.incrementAndGet();
        
        // 每分钟统计一次QPS
        long now = System.currentTimeMillis();
        long lastReset = lastResetTime.get();
        
        if (now - lastReset > 60000) { // 60秒
            if (lastResetTime.compareAndSet(lastReset, now)) {
                long count = requestCount.getAndSet(0);
                double qps = count / 60.0;
                
                logger.info("系统QPS: {:.2f}, 总请求数: {}", qps, count);
                
                if (qps > 1000) {
                    logger.warn("系统QPS过高: {:.2f}", qps);
                }
            }
        }
    }
}
```

### 3.4 监控告警策略


**🚨 告警级别设计**
```yaml
# 告警配置示例
alerts:
  # 🔥 紧急告警 - 立即处理
  critical:
    - 错误率 > 5%
    - 平均响应时间 > 3秒
    - CPU使用率 > 90%
    
  # ⚠️ 警告告警 - 需要关注  
  warning:
    - 错误率 > 1%
    - 平均响应时间 > 1秒
    - CPU使用率 > 80%
    
  # ℹ️ 信息告警 - 了解即可
  info:
    - QPS突然下降50%
    - 内存使用率 > 70%
```

---

## 4. 🔍 错误追踪


### 4.1 什么是错误追踪


**💡 通俗理解**：错误追踪就像医生看病，不仅要知道哪里疼，还要知道为什么疼，什么时候开始疼的。

```
医生诊断过程：
👨‍⚕️ 症状 → 🔍 原因 → 📝 病史 → 💊 治疗

错误追踪过程：  
🚨 错误现象 → 🔍 错误原因 → 📝 错误历史 → 🔧 修复方案
```

### 4.2 错误信息的完整记录


**🎯 错误信息五要素**

| 要素 | **含义** | **示例** | **重要性** |
|------|---------|---------|-----------|
| **❓ What** | `发生了什么错误` | `数据库连接超时` | `⭐⭐⭐⭐⭐` |
| **⏰ When** | `什么时候发生的` | `2024-08-17 14:30:15` | `⭐⭐⭐⭐⭐` |
| **📍 Where** | `在哪里发生的` | `UserService.login()方法` | `⭐⭐⭐⭐⭐` |
| **👤 Who** | `哪个用户触发的` | `用户ID: user123` | `⭐⭐⭐⭐` |
| **🔍 Why** | `为什么发生错误` | `数据库连接池已满` | `⭐⭐⭐⭐⭐` |

### 4.3 错误追踪实现


**📝 完整错误记录模板**
```java
@Component
public class ErrorTracker {
    
    public void trackError(Exception e, String context, String userId) {
        ErrorDetail error = ErrorDetail.builder()
            // What - 错误基本信息
            .errorType(e.getClass().getSimpleName())
            .errorMessage(e.getMessage())
            .errorCode(getErrorCode(e))
            
            // When - 时间信息
            .timestamp(Instant.now().toString())
            .timeZone(ZoneId.systemDefault().toString())
            
            // Where - 位置信息  
            .className(getCallerClass())
            .methodName(getCallerMethod())
            .lineNumber(getCallerLine())
            .stackTrace(getFormattedStackTrace(e))
            
            // Who - 用户信息
            .userId(userId)
            .sessionId(getSessionId())
            .ip(getClientIp())
            
            // Why - 上下文信息
            .context(context)
            .systemState(getSystemState())
            .requestParams(getRequestParams())
            
            .build();
            
        logger.error("错误追踪: {}", JSON.toJSONString(error, true));
    }
}
```

**🔗 关联信息追踪**
```java
// 为每个请求生成唯一ID，方便追踪
@Component
public class RequestTracker {
    
    @PostConstruct
    public void init() {
        // 为每个线程设置请求ID
        MDC.put("requestId", generateRequestId());
        MDC.put("startTime", String.valueOf(System.currentTimeMillis()));
    }
    
    // 所有日志自动包含requestId
    public void logWithContext(String message, Object... args) {
        // 自动包含请求ID和耗时
        long duration = System.currentTimeMillis() - 
                       Long.parseLong(MDC.get("startTime"));
        
        logger.info("[{}] [{}ms] " + message, 
                   MDC.get("requestId"), duration, args);
    }
}
```

### 4.4 错误分类与优先级


**🎯 错误分类处理策略**

```java
public enum ErrorSeverity {
    CRITICAL("严重", "影响核心功能，需要立即处理"),
    HIGH("高级", "影响用户体验，需要优先处理"),  
    MEDIUM("中级", "功能异常，需要及时处理"),
    LOW("轻微", "不影响功能，可以延后处理");
    
    // 根据错误类型自动分级
    public static ErrorSeverity categorizeError(Exception e) {
        if (e instanceof DatabaseException) {
            return CRITICAL; // 数据库问题很严重
        } else if (e instanceof PaymentException) {
            return CRITICAL; // 支付问题很严重
        } else if (e instanceof ValidationException) {
            return MEDIUM; // 参数校验问题中等
        } else {
            return LOW; // 其他问题轻微
        }
    }
}
```

---

## 5. 🛠️ 调试信息记录


### 5.1 什么是调试信息


**💡 通俗理解**：调试信息就像录制做菜过程的视频，出了问题可以回放看哪一步出错了。

```
做菜出问题：
👨‍🍳 "菜怎么糊了？" 
📹 回放视频："第3分钟火开太大了"

程序出问题：
👨‍💻 "为什么登录失败？"
📝 查看调试日志："第5行密码校验失败"
```

### 5.2 调试信息的层次设计


**🎯 调试信息三个层次**

| 层次 | **记录内容** | **使用场景** | **开启时机** |
|------|-------------|-------------|-------------|
| **🔍 DEBUG** | `方法执行路径、变量值` | `开发调试、测试验证` | `开发和测试环境` |
| **📝 TRACE** | `详细执行步骤、循环详情` | `深度问题分析` | `只在需要时临时开启` |
| **💾 DUMP** | `完整对象状态、内存快照` | `严重问题诊断` | `生产环境紧急情况` |

### 5.3 有效调试信息设计


**📝 DEBUG级别 - 记录关键执行路径**
```java
@Service
public class UserService {
    
    public User login(String username, String password) {
        logger.debug("开始用户登录流程，用户名: {}", username);
        
        // 1. 查找用户
        User user = userRepository.findByUsername(username);
        if (user == null) {
            logger.debug("用户不存在: {}", username);
            throw new UserNotFoundException("用户不存在");
        }
        logger.debug("找到用户: {}, ID: {}", username, user.getId());
        
        // 2. 验证密码
        logger.debug("开始密码验证");
        boolean passwordValid = passwordEncoder.matches(password, user.getPassword());
        if (!passwordValid) {
            logger.debug("密码验证失败，用户: {}", username);
            throw new BadCredentialsException("密码错误");
        }
        logger.debug("密码验证成功");
        
        // 3. 更新登录时间
        user.setLastLoginTime(new Date());
        userRepository.save(user);
        logger.debug("更新用户登录时间成功");
        
        logger.debug("用户登录流程完成，用户: {}", username);
        return user;
    }
}
```

**📊 变量状态记录**
```java
public class OrderProcessor {
    
    public void processOrder(Order order) {
        logger.debug("处理订单开始，订单状态: {}", order.getStatus());
        
        // 记录关键变量的变化
        BigDecimal originalAmount = order.getAmount();
        logger.debug("原始金额: {}", originalAmount);
        
        // 应用折扣
        BigDecimal discount = calculateDiscount(order);
        logger.debug("计算折扣: {}", discount);
        
        BigDecimal finalAmount = originalAmount.subtract(discount);
        order.setAmount(finalAmount);
        logger.debug("最终金额: {} (原始: {} - 折扣: {})", 
                    finalAmount, originalAmount, discount);
        
        // 记录状态变化
        OrderStatus oldStatus = order.getStatus();
        order.setStatus(OrderStatus.PROCESSED);
        logger.debug("订单状态变化: {} -> {}", oldStatus, order.getStatus());
    }
}
```

### 5.4 调试信息的智能开关


**🎛️ 动态调试级别控制**
```java
@Component
public class DebugController {
    
    // 可以动态调整某个用户的调试级别
    private final Map<String, String> userDebugLevels = new ConcurrentHashMap<>();
    
    public boolean shouldDebug(String userId, String level) {
        String userLevel = userDebugLevels.get(userId);
        if (userLevel == null) {
            return false; // 默认不开启调试
        }
        
        return isLevelEnabled(userLevel, level);
    }
    
    // 为特定用户开启调试
    public void enableDebugForUser(String userId, String level, int durationMinutes) {
        userDebugLevels.put(userId, level);
        
        // 定时关闭，避免忘记
        scheduler.schedule(() -> {
            userDebugLevels.remove(userId);
            logger.info("自动关闭用户{}的调试模式", userId);
        }, durationMinutes, TimeUnit.MINUTES);
        
        logger.info("为用户{}开启{}级别调试，{}分钟后自动关闭", 
                   userId, level, durationMinutes);
    }
}

// 使用示例
public void someBusinessMethod(String userId) {
    if (debugController.shouldDebug(userId, "DEBUG")) {
        logger.debug("用户{}执行业务方法，参数: {}", userId, params);
    }
    
    // 业务逻辑...
}
```

**⚡ 性能友好的调试设计**
```java
// ✅ 好的做法 - 先判断再计算
if (logger.isDebugEnabled()) {
    logger.debug("复杂计算结果: {}", expensiveCalculation());
}

// ❌ 坏的做法 - 总是计算
logger.debug("复杂计算结果: {}", expensiveCalculation()); // 即使不输出也会计算

// ✅ 更好的做法 - 使用Lambda延迟计算  
logger.debug("复杂计算结果: {}", () -> expensiveCalculation());
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 日志级别：ERROR(立即处理) > WARN(需关注) > INFO(业务事件) > DEBUG(调试信息)
🔸 结构化日志：用JSON格式让日志更易搜索和分析
🔸 性能监控：关注延迟、流量、错误率、饱和度四大指标  
🔸 错误追踪：记录What、When、Where、Who、Why五要素
🔸 调试信息：分层记录，动态控制，性能友好
```

### 6.2 关键理解要点


**🔹 日志不是越多越好**
```
原则：记录有价值的信息，避免信息噪音
✅ 好日志：帮助定位问题、了解业务状况
❌ 坏日志：无意义的细节、重复的信息
```

**🔹 生产环境和开发环境要区别对待**
```
开发环境：可以详细记录，方便调试
生产环境：只记录必要信息，关注性能影响
```

**🔹 监控要主动，不要被动**
```
主动监控：设置告警，问题早发现
被动处理：用户投诉才知道问题
```

### 6.3 实际应用指导


**🎯 日志与监控实施步骤**
1. **📊 设计日志级别策略** - 明确各级别使用场景
2. **🔧 实现结构化日志** - 统一格式，便于分析  
3. **📈 建立监控体系** - 覆盖关键指标
4. **🚨 配置告警规则** - 及时发现问题
5. **🔍 完善错误追踪** - 快速定位根因
6. **🛠️ 优化调试流程** - 提高问题解决效率

**💡 最佳实践建议**
- **分环境配置**：开发、测试、生产使用不同的日志级别
- **结构化设计**：统一日志格式，便于自动化分析
- **性能考虑**：避免日志影响系统性能
- **安全意识**：不要记录敏感信息（密码、身份证等）
- **持续优化**：根据实际使用效果调整日志策略

### 6.4 常见误区避免


```
❌ 常见错误：
- 所有地方都记录DEBUG日志
- 日志信息不规范，难以分析
- 生产环境开启过多日志影响性能
- 错误信息不完整，难以定位问题

✅ 正确做法：
- 合理使用日志级别
- 设计结构化日志格式  
- 根据环境调整日志策略
- 记录完整的错误上下文信息
```

**核心记忆口诀**：
- 日志分级用途明，结构统一易分析
- 监控指标要关键，错误追踪要完整  
- 调试信息分层记，性能影响要考虑
- 主动监控早发现，被动处理问题多