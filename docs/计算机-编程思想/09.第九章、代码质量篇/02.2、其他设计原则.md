---
title: 2、其他设计原则
---
## 📚 目录

1. [DRY原则（不重复）](#1-DRY原则不重复)
2. [KISS原则（保持简单）](#2-KISS原则保持简单)
3. [YAGNI原则（你不会需要它）](#3-YAGNI原则你不会需要它)
4. [组合优于继承](#4-组合优于继承)
5. [最少知识原则](#5-最少知识原则)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔄 DRY原则（不重复）


### 1.1 DRY原则的核心含义


**DRY全称**：Don't Repeat Yourself（不要重复你自己）

> 💡 **简单理解**：同样的代码逻辑，不要在程序中写两遍或多遍

**生活中的类比**：
```
就像做菜的配方：
❌ 每次做菜都重新思考步骤
✅ 把配方写下来，每次按配方做

编程也是如此：
❌ 同样的逻辑在多个地方重复写
✅ 把逻辑提取出来，需要时直接调用
```

### 1.2 为什么要避免重复代码


**重复代码的问题**：
- 🔸 **维护困难**：改一个地方，要记得改所有重复的地方
- 🔸 **容易出错**：可能只改了一部分，忘记改其他地方
- 🔸 **代码冗余**：程序变得又大又臃肿
- 🔸 **理解困难**：阅读代码时会困惑"为什么这里又写一遍"

### 1.3 违反DRY原则的例子


**❌ 不好的写法（重复代码）**：
```java
// 计算员工工资 - 第一处
public void calculateSalaryForManager() {
    double baseSalary = 8000;
    double bonus = baseSalary * 0.2;  // 20%奖金
    double tax = (baseSalary + bonus) * 0.1;  // 10%税率
    double finalSalary = baseSalary + bonus - tax;
    System.out.println("经理工资: " + finalSalary);
}

// 计算员工工资 - 第二处（重复的计算逻辑！）
public void calculateSalaryForDeveloper() {
    double baseSalary = 6000;
    double bonus = baseSalary * 0.2;  // 20%奖金（重复）
    double tax = (baseSalary + bonus) * 0.1;  // 10%税率（重复）
    double finalSalary = baseSalary + bonus - tax;  // 重复计算
    System.out.println("开发者工资: " + finalSalary);
}
```

**✅ 遵循DRY原则的写法**：
```java
// 把重复的计算逻辑提取出来
public double calculateFinalSalary(double baseSalary) {
    double bonus = baseSalary * 0.2;        // 奖金计算
    double tax = (baseSalary + bonus) * 0.1; // 税收计算
    return baseSalary + bonus - tax;         // 最终工资
}

// 使用提取的方法
public void calculateSalaryForManager() {
    double salary = calculateFinalSalary(8000);
    System.out.println("经理工资: " + salary);
}

public void calculateSalaryForDeveloper() {
    double salary = calculateFinalSalary(6000);
    System.out.println("开发者工资: " + salary);
}
```

### 1.4 DRY原则的应用层面


**🔸 代码层面**：
- 相同的方法逻辑
- 重复的计算公式
- 相似的数据处理流程

**🔸 数据层面**：
- 数据库表结构设计
- 配置信息管理
- 常量定义

**🔸 知识层面**：
- 业务规则只在一个地方定义
- 算法逻辑统一实现
- 系统架构决策集中管理

---

## 2. 💎 KISS原则（保持简单）


### 2.1 KISS原则的核心含义


**KISS全称**：Keep It Simple, Stupid（保持简单，笨蛋）

> 💡 **简单理解**：能用简单方法解决的问题，就不要用复杂方法

**生活中的类比**：
```
开门的方式：
❌ 复杂方式：先转3圈，再跳一下，然后拍手，最后推门
✅ 简单方式：直接推门或拉门

编程也是如此：
❌ 复杂代码：用很多设计模式，写很多抽象层
✅ 简单代码：直接解决问题，逻辑清晰明了
```

### 2.2 为什么简单性很重要


**简单代码的好处**：
- ✅ **容易理解**：新人能快速看懂
- ✅ **容易维护**：出问题容易找到原因
- ✅ **容易测试**：逻辑简单，测试用例好写
- ✅ **容易调试**：问题排查更快速

### 2.3 违反KISS原则的例子


**❌ 复杂的写法**：
```java
// 过度复杂的判断用户年龄分组
public class AgeClassificationStrategy {
    private Map<Predicate<Integer>, String> ageClassificationRules;
    
    public AgeClassificationStrategy() {
        ageClassificationRules = new HashMap<>();
        ageClassificationRules.put(age -> age >= 0 && age < 18, "未成年");
        ageClassificationRules.put(age -> age >= 18 && age < 65, "成年人");
        ageClassificationRules.put(age -> age >= 65, "老年人");
    }
    
    public String classify(int age) {
        return ageClassificationRules.entrySet().stream()
            .filter(entry -> entry.getKey().test(age))
            .map(Map.Entry::getValue)
            .findFirst()
            .orElse("未知");
    }
}
```

**✅ 简单的写法**：
```java
// 简单直接的年龄分组
public String classifyAge(int age) {
    if (age < 18) {
        return "未成年";
    } else if (age < 65) {
        return "成年人";
    } else {
        return "老年人";
    }
}
```

### 2.4 如何保持代码简单


**🔸 方法简单化**：
- 一个方法只做一件事
- 方法名要见名知意
- 参数不要太多（一般不超过3-4个）

**🔸 逻辑简单化**：
- 减少嵌套层次
- 避免复杂的条件判断
- 优先使用直观的算法

**🔸 结构简单化**：
- 不要过度设计架构
- 先实现功能，再考虑优化
- 避免为了技术而技术

---

## 3. 🚫 YAGNI原则（你不会需要它）


### 3.1 YAGNI原则的核心含义


**YAGNI全称**：You Aren't Gonna Need It（你不会需要它）

> 💡 **简单理解**：不要为了"可能会用到"而提前写代码，只写当前确实需要的功能

**生活中的类比**：
```
买东西的心理：
❌ "这个以后可能会用到，先买了放着"（结果永远用不到）
✅ "现在需要什么就买什么"

编程也是如此：
❌ "这个功能将来可能需要，先做了备着"
✅ "现在需求明确要什么功能，就做什么"
```

### 3.2 为什么要避免过度设计


**过度设计的问题**：
- 🔸 **浪费时间**：开发用不到的功能
- 🔸 **增加复杂性**：代码变得复杂难懂
- 🔸 **维护负担**：更多代码意味着更多bug
- 🔸 **需求变更**：提前写的功能可能与实际需求不符

### 3.3 违反YAGNI原则的例子


**❌ 过度设计的写法**：
```java
// 为了"将来可能的需求"，做了很多现在用不到的功能
public class UserService {
    // 现在只需要按ID查用户，但提前做了各种查询方式
    public User findById(Long id) { /* 实现 */ }
    public User findByEmail(String email) { /* 暂时用不到 */ }
    public User findByPhone(String phone) { /* 暂时用不到 */ }
    public List<User> findByAge(int minAge, int maxAge) { /* 暂时用不到 */ }
    public List<User> findByCity(String city) { /* 暂时用不到 */ }
    
    // 为了"将来可能的扩展"，做了复杂的配置系统
    private Map<String, SearchStrategy> searchStrategies; /* 现在用不到 */
    public void configureSearchStrategy(String key, SearchStrategy strategy) { /* 用不到 */ }
}
```

**✅ 遵循YAGNI原则的写法**：
```java
// 只实现当前确实需要的功能
public class UserService {
    // 现在的需求只需要按ID查用户
    public User findById(Long id) {
        // 简单直接的实现
        return userRepository.findById(id);
    }
    
    // 当将来真正需要其他查询方式时，再添加对应方法
}
```

### 3.4 如何应用YAGNI原则


**🔸 需求驱动开发**：
- 有明确需求才写代码
- 不要猜测未来可能的需求
- 当需求真正出现时再扩展

**🔸 渐进式开发**：
- 先做最基本的功能
- 根据反馈逐步完善
- 避免一次性做太多功能

**🔸 重构意识**：
- 相信代码可以重构
- 不怕推倒重来
- 先满足当前需求，后续再优化

---

## 4. 🧩 组合优于继承


### 4.1 组合优于继承的核心含义


> 💡 **简单理解**：与其让一个类继承另一个类的所有特性，不如让一个类包含另一个类的对象，只使用需要的功能

**生活中的类比**：
```
获得交通能力的方式：

继承方式（人类继承汽车）：
❌ 人类变成汽车人，拥有汽车的所有特性
   - 好处：直接就是汽车，速度快
   - 坏处：变得很重，不能游泳，失去人类特性

组合方式（人类使用汽车）：
✅ 人类拥有一辆汽车，需要时使用
   - 好处：保持人类特性，还能使用汽车
   - 可以换不同的交通工具（汽车、自行车、飞机）
```

### 4.2 继承的问题


**继承的缺点**：
- 🔸 **紧耦合**：子类与父类关系固定，难以改变
- 🔸 **全盘接收**：继承了父类的所有东西，包括不需要的
- 🔸 **脆弱基类**：父类的改动可能破坏子类
- 🔸 **单一继承**：Java等语言只能继承一个父类

### 4.3 对比示例：继承 vs 组合


**❌ 使用继承的方式**：
```java
// 鸟类基类
class Bird {
    public void eat() { System.out.println("吃东西"); }
    public void fly() { System.out.println("飞行"); }
}

// 企鹅继承鸟类
class Penguin extends Bird {
    // 问题：企鹅不会飞，但继承了fly方法
    @Override
    public void fly() {
        throw new RuntimeException("企鹅不会飞！");
    }
}

// 鸵鸟继承鸟类
class Ostrich extends Bird {
    // 问题：鸵鸟也不会飞
    @Override
    public void fly() {
        throw new RuntimeException("鸵鸟不会飞！");
    }
}
```

**✅ 使用组合的方式**：
```java
// 把能力拆分成独立的接口
interface EatingBehavior {
    void eat();
}

interface FlyingBehavior {
    void fly();
}

// 具体的能力实现
class NormalEating implements EatingBehavior {
    public void eat() { System.out.println("正常吃东西"); }
}

class CanFly implements FlyingBehavior {
    public void fly() { System.out.println("在天空飞行"); }
}

class CannotFly implements FlyingBehavior {
    public void fly() { System.out.println("不能飞行"); }
}

// 鸟类使用组合
class Bird {
    private EatingBehavior eatingBehavior;
    private FlyingBehavior flyingBehavior;
    
    public Bird(EatingBehavior eating, FlyingBehavior flying) {
        this.eatingBehavior = eating;
        this.flyingBehavior = flying;
    }
    
    public void eat() { eatingBehavior.eat(); }
    public void fly() { flyingBehavior.fly(); }
}

// 使用时灵活组合
Bird sparrow = new Bird(new NormalEating(), new CanFly());     // 麻雀会飞
Bird penguin = new Bird(new NormalEating(), new CannotFly());  // 企鹅不会飞
```

### 4.4 组合的优势


**组合的好处**：
- ✅ **灵活性高**：可以在运行时改变行为
- ✅ **松耦合**：各部分相对独立
- ✅ **可重用**：同一个组件可以被多个类使用
- ✅ **易测试**：可以单独测试每个组件

### 4.5 什么时候用继承，什么时候用组合


**使用继承的情况**：
- 真正的"是一个"关系（Cat 是一个 Animal）
- 需要多态性
- 父类的所有方法都有意义

**使用组合的情况**：
- "有一个"关系（Car 有一个 Engine）
- 需要灵活的功能组合
- 避免继承层次过深

---

## 5. 🔒 最少知识原则


### 5.1 最少知识原则的核心含义


**别名**：迪米特法则（Law of Demeter）

> 💡 **简单理解**：一个对象应该对其他对象有尽可能少的了解，只与直接的朋友交流

**生活中的类比**：
```
社交关系：
❌ 你要买东西，直接跑到商店老板的家里找老板的妻子要钱包
✅ 你要买东西，只跟商店的收银员交流

编程也是如此：
❌ 类A直接操作类B内部对象C的属性
✅ 类A只调用类B提供的方法，不关心B内部怎么实现
```

### 5.2 为什么要减少对象间的知识


**过多知识的问题**：
- 🔸 **耦合度高**：对象之间关系复杂，牵一发动全身
- 🔸 **难以维护**：改一个地方可能影响很多其他地方
- 🔸 **难以理解**：需要了解太多细节才能明白代码
- 🔸 **难以测试**：测试一个功能需要准备很多环境

### 5.3 违反最少知识原则的例子


**❌ 违反原则的写法（知道太多）**：
```java
// 用户类
class User {
    private Wallet wallet;
    
    public Wallet getWallet() { return wallet; }
}

// 钱包类
class Wallet {
    private Money money;
    
    public Money getMoney() { return money; }
}

// 钱类
class Money {
    private double amount;
    
    public double getAmount() { return amount; }
    public void setAmount(double amount) { this.amount = amount; }
}

// 购买服务 - 知道了太多内部细节！
class PurchaseService {
    public void buyItem(User user, double price) {
        // 需要深入了解User的内部结构
        Money money = user.getWallet().getMoney();  // 链式调用暴露内部结构
        
        if (money.getAmount() >= price) {
            money.setAmount(money.getAmount() - price);  // 直接操作内部对象
        }
    }
}
```

**✅ 遵循原则的写法（知道最少）**：
```java
// 用户类 - 提供高层次的接口
class User {
    private Wallet wallet;
    
    // 只暴露需要的操作，隐藏内部细节
    public boolean canAfford(double amount) {
        return wallet.hasEnoughMoney(amount);
    }
    
    public void spend(double amount) {
        wallet.deduct(amount);
    }
}

// 钱包类 - 封装具体操作
class Wallet {
    private Money money;
    
    public boolean hasEnoughMoney(double amount) {
        return money.getAmount() >= amount;
    }
    
    public void deduct(double amount) {
        if (hasEnoughMoney(amount)) {
            money.setAmount(money.getAmount() - amount);
        }
    }
}

// 购买服务 - 只需要知道User提供的接口
class PurchaseService {
    public void buyItem(User user, double price) {
        // 简单清晰，不需要了解内部实现
        if (user.canAfford(price)) {
            user.spend(price);
        }
    }
}
```

### 5.4 最少知识原则的实践方法


**🔸 只与朋友交谈**：
- 自己的成员变量
- 方法参数
- 方法内创建的对象
- 直接组合的对象

**🔸 避免链式调用**：
```java
❌ user.getAddress().getCity().getName();  // 知道太多层级
✅ user.getCityName();                      // 封装后的简单接口
```

**🔸 使用门面模式**：
- 为复杂的子系统提供简单的接口
- 客户端只需要知道门面接口，不需要了解内部实现

### 5.5 最少知识原则的好处


**遵循原则的好处**：
- ✅ **降低耦合**：对象间依赖关系简单
- ✅ **提高维护性**：修改内部实现不影响外部
- ✅ **增强可读性**：代码逻辑更清晰
- ✅ **便于测试**：依赖关系简单，容易模拟

---

## 6. 📋 核心要点总结


### 6.1 五大设计原则速记


```
🔄 DRY原则：同样的事情不要做两遍
    - 重复代码 → 提取公共方法
    - 重复配置 → 统一配置管理
    - 重复业务逻辑 → 抽象通用组件

💎 KISS原则：简单就是美
    - 复杂设计 → 简单直接的解决方案
    - 过度抽象 → 具体明确的实现
    - 炫技代码 → 清晰易懂的逻辑

🚫 YAGNI原则：不要提前做用不到的功能
    - 猜测需求 → 明确需求驱动
    - 过度设计 → 渐进式开发
    - 复杂框架 → 满足当前需要即可

🧩 组合优于继承：用组合代替继承
    - 继承关系 → 组合关系
    - 僵化结构 → 灵活配置
    - 全盘接收 → 按需使用

🔒 最少知识原则：只知道需要知道的
    - 深度依赖 → 浅层接口
    - 链式调用 → 封装方法
    - 内部细节 → 公开接口
```

### 6.2 设计原则的相互关系


```
设计原则协同工作：

DRY + KISS：
提取重复代码时，保持提取后的代码简单明了

KISS + YAGNI：
不做复杂的设计，不做用不到的功能

组合优于继承 + 最少知识原则：
使用组合时，只暴露必要的接口，隐藏内部实现

DRY + 最少知识原则：
提取公共代码时，注意不要让调用者了解太多细节
```

### 6.3 实际应用指导


**🎯 日常开发检查清单**：
- [ ] 有没有重复的代码可以提取？（DRY）
- [ ] 这个设计是不是太复杂了？（KISS）
- [ ] 这个功能现在真的需要吗？（YAGNI）
- [ ] 这里用继承合适吗，还是组合更好？（组合优于继承）
- [ ] 这个类是不是知道了太多其他类的细节？（最少知识）

**🔧 重构时的应用**：
- **发现重复代码** → 应用DRY原则提取
- **代码过于复杂** → 应用KISS原则简化
- **功能用不到** → 应用YAGNI原则删除
- **继承层次深** → 考虑组合优于继承
- **耦合度高** → 应用最少知识原则解耦

**📝 设计时的思考顺序**：
1. **先想简单方案**（KISS原则）
2. **只做当前需要的**（YAGNI原则）
3. **避免重复代码**（DRY原则）
4. **优先考虑组合**（组合优于继承）
5. **减少对象间依赖**（最少知识原则）

### 6.4 常见误区提醒


**⚠️ 应用原则时的注意事项**：

```
DRY原则误区：
❌ 为了避免重复，过度抽象
✅ 真正相同的逻辑才需要提取

KISS原则误区：
❌ 为了简单，不考虑扩展性
✅ 在简单和灵活之间找平衡

YAGNI原则误区：
❌ 完全不考虑未来，代码无法扩展
✅ 不提前实现，但保持代码可扩展

组合优于继承误区：
❌ 完全不用继承
✅ 在合适的场景使用合适的方式

最少知识原则误区：
❌ 过度封装，接口复杂
✅ 适度封装，接口简洁明了
```

**核心记忆口诀**：
- DRY：重复是罪恶，提取是美德
- KISS：简单至上，复杂有害
- YAGNI：现在不需要，就不要做
- 组合优于继承：有比是更灵活
- 最少知识：知道越少，耦合越低