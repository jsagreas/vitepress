---
title: 5、测试驱动开发
---
## 📚 目录

1. [TDD基本概念](#1-TDD基本概念)
2. [红绿重构循环](#2-红绿重构循环)
3. [测试用例设计](#3-测试用例设计)
4. [测试覆盖率](#4-测试覆盖率)
5. [Mock对象应用](#5-Mock对象应用)
6. [测试数据管理](#6-测试数据管理)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 TDD基本概念


### 1.1 什么是测试驱动开发


**核心理念**：先写测试，再写代码，最后重构优化

```
传统开发方式：
设计 → 编码 → 测试 → 修复

TDD开发方式：
测试 → 编码 → 重构 → 下一个功能
```

**💡 简单理解**：
- 就像盖房子先画图纸一样
- 测试就是你的"图纸"，告诉你要实现什么功能
- 代码就是按"图纸"盖房子
- 重构就是装修优化，让房子更美观实用

### 1.2 TDD的核心优势


**🔸 质量保障**
```
好处：
✅ 代码质量更高：每一行代码都有测试保护
✅ bug更少：问题在开发阶段就被发现
✅ 重构更安全：有测试兜底，改代码不怕出错
```

**🔸 设计改善**
```
设计思维转变：
- 传统方式：我要实现什么功能？
- TDD方式：别人要怎么使用我的代码？

结果：
✅ 接口设计更合理
✅ 代码耦合度更低
✅ 可测试性更好
```

### 1.3 TDD适用场景


| 适合TDD | 不太适合TDD |
|---------|------------|
| 💼 **业务逻辑复杂** | 🎨 **UI界面开发** |
| 🔧 **工具函数开发** | 🧪 **原型验证** |
| 📊 **算法实现** | ⚡ **性能调优** |
| 🔌 **API接口** | 🎮 **交互效果** |

---

## 2. 🔄 红绿重构循环


### 2.1 循环的三个阶段


**🔴 红色阶段（Red）**：写一个失败的测试

```javascript
// 例子：开发一个计算器的加法功能
describe('Calculator', () => {
  test('should add two numbers', () => {
    const calc = new Calculator();
    // 这时Calculator类还不存在，测试会失败（红色）
    expect(calc.add(2, 3)).toBe(5);
  });
});
```

**🟢 绿色阶段（Green）**：写最简单的代码让测试通过

```javascript
// 最简单的实现，只为让测试通过
class Calculator {
  add(a, b) {
    return 5; // 硬编码！但测试通过了
  }
}
```

**🔵 重构阶段（Refactor）**：改进代码质量

```javascript
// 重构：写出正确的实现
class Calculator {
  add(a, b) {
    return a + b; // 正确的逻辑
  }
}
```

### 2.2 为什么要这样做？


**🤔 为什么先写失败测试？**
```
原因：
1. 确保测试真的在测试功能
2. 避免写出永远通过的"假测试"
3. 明确需求，知道要实现什么

就像：
- 先确定目标，再开始行动
- 先问"要到哪里"，再问"怎么走"
```

**🤔 为什么先写最简单代码？**
```
原因：
1. 快速获得反馈
2. 避免过度设计
3. 逐步完善功能

就像：
- 先搭个简陋的房子能住人
- 再慢慢装修升级
```

### 2.3 循环实战示例


**需求**：实现一个字符串反转功能

```javascript
// 🔴 步骤1：写失败测试
test('should reverse string', () => {
  expect(reverseString('hello')).toBe('olleh');
});

// 🟢 步骤2：最简实现
function reverseString(str) {
  if (str === 'hello') return 'olleh'; // 硬编码
}

// 🔴 步骤3：添加更多测试
test('should reverse different strings', () => {
  expect(reverseString('world')).toBe('dlrow');
  expect(reverseString('abc')).toBe('cba');
});

// 🟢 步骤4：改进实现
function reverseString(str) {
  return str.split('').reverse().join('');
}

// 🔵 步骤5：重构优化
function reverseString(str) {
  // 添加参数验证
  if (typeof str !== 'string') {
    throw new Error('Input must be a string');
  }
  return str.split('').reverse().join('');
}
```

---

## 3. 📝 测试用例设计


### 3.1 好测试用例的特点


**🎯 FIRST原则**

| 原则 | 含义 | 举例 |
|------|------|------|
| **F**ast | 快速 | 测试应该秒级完成 |
| **I**ndependent | 独立 | 测试之间不相互影响 |
| **R**epeatable | 可重复 | 任何环境都能运行 |
| **S**elf-validating | 自验证 | 明确的通过/失败结果 |
| **T**imely | 及时 | 在产品代码之前编写 |

### 3.2 测试用例设计策略


**🔸 边界值测试**
```javascript
// 测试数字范围函数
function isValidAge(age) {
  return age >= 0 && age <= 120;
}

// 测试边界值
test('age boundary values', () => {
  expect(isValidAge(-1)).toBe(false);  // 下边界-1
  expect(isValidAge(0)).toBe(true);    // 下边界
  expect(isValidAge(120)).toBe(true);  // 上边界
  expect(isValidAge(121)).toBe(false); // 上边界+1
});
```

**🔸 等价类测试**
```javascript
// 测试密码强度
function getPasswordStrength(password) {
  if (password.length < 6) return 'weak';
  if (password.length < 12) return 'medium';
  return 'strong';
}

// 等价类测试
test('password strength categories', () => {
  expect(getPasswordStrength('123')).toBe('weak');      // 短密码类
  expect(getPasswordStrength('12345678')).toBe('medium'); // 中等密码类
  expect(getPasswordStrength('123456789012')).toBe('strong'); // 长密码类
});
```

**🔸 异常情况测试**
```javascript
// 测试除法函数
function divide(a, b) {
  if (b === 0) throw new Error('Cannot divide by zero');
  return a / b;
}

// 异常测试
test('should handle division by zero', () => {
  expect(() => divide(10, 0)).toThrow('Cannot divide by zero');
});
```

### 3.3 测试命名规范


**📋 清晰的测试名称**
```javascript
// ❌ 不好的命名
test('test user', () => {});
test('check password', () => {});

// ✅ 好的命名
test('should create user with valid email', () => {});
test('should reject password shorter than 6 characters', () => {});
test('should return error when user not found', () => {});
```

**🔤 命名模式**
```
推荐格式：should + 期望行为 + when + 条件

例子：
- should return true when email is valid
- should throw error when password is empty
- should save user when all fields are provided
```

---

## 4. 📊 测试覆盖率


### 4.1 测试覆盖率的含义


**💡 什么是测试覆盖率？**
```
简单理解：
测试覆盖率 = 被测试执行的代码行数 / 总代码行数

就像：
- 考试覆盖了教材的70%内容
- 测试覆盖了代码的80%行数
```

### 4.2 覆盖率的类型


**🔸 行覆盖率（Line Coverage）**
```javascript
function checkNumber(num) {
  if (num > 0) {
    return 'positive';  // 这行被测试了吗？
  } else {
    return 'non-positive';  // 这行被测试了吗？
  }
}

// 测试只测了正数情况，行覆盖率50%
test('positive number', () => {
  expect(checkNumber(5)).toBe('positive');
});
```

**🔸 分支覆盖率（Branch Coverage）**
```javascript
function getDiscount(age, isMember) {
  let discount = 0;
  
  if (age > 65) {        // 分支1：老年人
    discount += 0.1;
  }
  
  if (isMember) {        // 分支2：会员
    discount += 0.05;
  }
  
  return discount;
}

// 需要测试所有分支组合
test('discount combinations', () => {
  expect(getDiscount(70, true)).toBe(0.15);   // 老年会员
  expect(getDiscount(70, false)).toBe(0.1);   // 老年非会员
  expect(getDiscount(30, true)).toBe(0.05);   // 年轻会员
  expect(getDiscount(30, false)).toBe(0);     // 年轻非会员
});
```

### 4.3 覆盖率管理策略


**📈 覆盖率目标设定**

| 项目类型 | 推荐覆盖率 | 说明 |
|----------|-----------|------|
| 🏦 **金融系统** | 90%+ | 容错率极低 |
| 🛒 **电商平台** | 80%+ | 业务逻辑复杂 |
| 📱 **移动应用** | 70%+ | UI测试困难 |
| 🧪 **原型项目** | 50%+ | 快速迭代 |

**⚠️ 覆盖率陷阱**
```javascript
// ❌ 为了覆盖率而写的无意义测试
test('should call function', () => {
  const result = someFunction();
  // 没有断言，只是调用了函数
});

// ✅ 有意义的测试
test('should return correct result when valid input', () => {
  const result = someFunction('valid input');
  expect(result).toBe('expected output');
});
```

**🎯 关注重要代码**
```
优先测试：
✅ 核心业务逻辑
✅ 复杂算法
✅ 异常处理
✅ 边界条件

可以忽略：
➖ 简单的getter/setter
➖ 第三方库调用
➖ 配置文件
➖ 纯UI展示
```

---

## 5. 🎭 Mock对象应用


### 5.1 什么是Mock对象


**💡 Mock对象的本质**
```
Mock = 模拟 = 替身演员

就像电影里：
- 真演员太贵，用替身演员
- 真服务太慢，用Mock对象

Mock对象：
- 模拟真实对象的行为
- 控制返回结果
- 记录调用情况
```

### 5.2 为什么需要Mock


**🔸 隔离外部依赖**
```javascript
// 真实的用户服务（依赖数据库）
class UserService {
  async getUser(id) {
    // 需要连接数据库，很慢
    return await database.findUser(id);
  }
}

// 使用Mock，测试更快更稳定
test('should process user data', async () => {
  // 创建Mock对象
  const mockUserService = {
    getUser: jest.fn().mockResolvedValue({
      id: 1,
      name: 'John',
      email: 'john@example.com'
    })
  };
  
  const processor = new UserProcessor(mockUserService);
  const result = await processor.processUser(1);
  
  expect(result.processed).toBe(true);
});
```

**🔸 测试异常情况**
```javascript
// 模拟网络错误
test('should handle network error', async () => {
  const mockApiService = {
    fetchData: jest.fn().mockRejectedValue(new Error('Network error'))
  };
  
  const handler = new DataHandler(mockApiService);
  
  expect(async () => {
    await handler.getData();
  }).rejects.toThrow('Network error');
});
```

### 5.3 Mock的类型和用法


**🔸 函数Mock**
```javascript
// 简单函数Mock
const mockCallback = jest.fn();
mockCallback('arg1', 'arg2');

// 验证调用
expect(mockCallback).toHaveBeenCalledWith('arg1', 'arg2');
expect(mockCallback).toHaveBeenCalledTimes(1);
```

**🔸 模块Mock**
```javascript
// Mock整个模块
jest.mock('./emailService', () => ({
  sendEmail: jest.fn().mockResolvedValue({ sent: true })
}));

// 在测试中使用
test('should send welcome email', async () => {
  const { sendEmail } = require('./emailService');
  
  await userRegistration.register('user@example.com');
  
  expect(sendEmail).toHaveBeenCalledWith('user@example.com', 'Welcome!');
});
```

**🔸 部分Mock**
```javascript
// 只Mock部分方法
const userService = new UserService();
userService.getUser = jest.fn().mockResolvedValue({ id: 1, name: 'John' });

// 其他方法保持原样
```

### 5.4 Mock最佳实践


**✅ 好的Mock实践**
```javascript
// 1. Mock返回真实的数据结构
const mockUser = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  createdAt: new Date('2023-01-01')
};

// 2. 使用有意义的测试数据
const mockApiResponse = {
  status: 200,
  data: { users: [mockUser] },
  message: 'Success'
};

// 3. 验证重要的交互
expect(mockEmailService.sendEmail).toHaveBeenCalledWith(
  'user@example.com',
  'Welcome to our service!',
  { template: 'welcome' }
);
```

**❌ 避免的Mock陷阱**
```javascript
// ❌ 过度Mock，测试变成了Mock的测试
const mockEverything = {
  method1: jest.fn(),
  method2: jest.fn(),
  method3: jest.fn(),
  // ... Mock了太多东西
};

// ❌ Mock返回不真实的数据
const fakeUser = { name: 'fake' }; // 缺少真实对象的属性

// ❌ 没有验证Mock的调用
mockService.doSomething();
// 忘记验证是否真的调用了
```

---

## 6. 📋 测试数据管理


### 6.1 测试数据的挑战


**🤔 测试数据问题**
```
常见问题：
❌ 测试之间数据污染
❌ 数据准备复杂耗时
❌ 真实数据泄露风险
❌ 数据状态不一致
```

### 6.2 测试数据管理策略


**🔸 数据工厂模式**
```javascript
// 创建测试数据工厂
class UserFactory {
  static create(overrides = {}) {
    return {
      id: Math.random(),
      name: 'Test User',
      email: 'test@example.com',
      age: 25,
      createdAt: new Date(),
      ...overrides  // 允许覆盖默认值
    };
  }
  
  static createMany(count, overrides = {}) {
    return Array(count).fill().map(() => this.create(overrides));
  }
}

// 使用工厂创建测试数据
test('should process users', () => {
  const users = UserFactory.createMany(3, { age: 30 });
  const result = processUsers(users);
  expect(result.length).toBe(3);
});
```

**🔸 测试夹具（Fixtures）**
```javascript
// fixtures/users.js
export const validUser = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com'
};

export const invalidUser = {
  id: null,
  name: '',
  email: 'invalid-email'
};

// 在测试中使用
import { validUser, invalidUser } from './fixtures/users';

test('should validate user', () => {
  expect(validateUser(validUser)).toBe(true);
  expect(validateUser(invalidUser)).toBe(false);
});
```

**🔸 数据库测试策略**
```javascript
// 测试前准备数据，测试后清理
describe('User API', () => {
  beforeEach(async () => {
    // 清空数据库
    await database.clearAll();
    // 插入测试数据
    await database.seed(testUsers);
  });
  
  afterEach(async () => {
    // 清理测试数据
    await database.clearAll();
  });
  
  test('should get user by id', async () => {
    const user = await userApi.getUser(1);
    expect(user.name).toBe('Test User');
  });
});
```

### 6.3 测试环境隔离


**🔸 环境分离**
```javascript
// 不同环境使用不同数据库
const config = {
  development: {
    database: 'app_dev'
  },
  test: {
    database: 'app_test'  // 专门的测试数据库
  },
  production: {
    database: 'app_prod'
  }
};
```

**🔸 内存数据库**
```javascript
// 使用内存数据库进行测试
const testConfig = {
  database: {
    type: 'sqlite',
    database: ':memory:',  // 内存数据库，快速且隔离
    synchronize: true
  }
};
```

### 6.4 敏感数据处理


**🔒 数据脱敏**
```javascript
// 生成测试用的假数据
const testData = {
  users: [
    {
      id: 1,
      name: 'Test User 1',
      email: 'test1@example.com',
      phone: '555-0001',        // 假电话号码
      ssn: '123-45-6789'        // 假社保号码
    }
  ]
};

// 避免使用真实的敏感数据
const realUserData = {
  name: 'John Smith',
  email: 'john.smith@realcompany.com',  // ❌ 真实邮箱
  phone: '555-1234',                    // ❌ 可能是真实号码
  ssn: '987-65-4321'                    // ❌ 绝对不能用真实SSN
};
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 TDD本质：测试先行，驱动设计，保障质量
🔸 红绿重构：失败→通过→优化的开发循环
🔸 测试设计：边界值、等价类、异常情况全覆盖
🔸 覆盖率管理：关注重要代码，避免为了覆盖率而测试
🔸 Mock应用：隔离依赖，控制环境，模拟各种情况
🔸 数据管理：工厂模式，环境隔离，敏感数据保护
```

### 7.2 关键理解要点


**🔹 TDD的价值在于思维转变**
```
传统思维：我要实现什么功能？
TDD思维：别人要如何使用我的代码？

结果：
- 接口设计更合理
- 代码耦合度更低
- 质量更有保障
```

**🔹 测试是代码的安全网**
```
好的测试像安全网：
✅ 让你敢于重构代码
✅ 快速发现回归问题
✅ 文档化代码行为
✅ 提高开发信心
```

**🔹 工具服务于目标，不是目的**
```
记住：
- 覆盖率不是越高越好，要有意义
- Mock不是万能的，过度使用反而有害
- 测试要快速、稳定、有价值
```

### 7.3 实际应用指导


**🎯 TDD实施建议**
```
从这些地方开始：
✅ 工具函数：纯函数，容易测试
✅ 业务逻辑：复杂度高，价值大
✅ API接口：边界清晰，容易验证
✅ 核心算法：逻辑复杂，容易出错

暂时跳过：
➖ UI组件：测试复杂，变化频繁
➖ 第三方集成：依赖外部，难以控制
➖ 配置文件：简单静态，价值有限
```

**🛠️ 实践步骤**
```
1️⃣ 从小功能开始：选择简单的纯函数练习
2️⃣ 建立测试习惯：每天至少写几个测试
3️⃣ 逐步扩大范围：从函数到类到模块
4️⃣ 改进工具链：配置好测试工具和环境
5️⃣ 团队推广：分享经验，建立规范
```

**⚠️ 常见错误避免**
```
❌ 测试写得太复杂：测试应该简单明了
❌ 测试依赖太多：测试应该独立运行
❌ 为了覆盖率而写测试：关注测试价值
❌ 把测试当作文档：测试和文档各有用途
❌ 忽略测试维护：测试代码也需要重构
```

### 7.4 进阶学习方向


**📚 深入主题**
- **BDD行为驱动开发**：用业务语言写测试
- **契约测试**：微服务间的接口测试
- **性能测试**：负载测试和压力测试
- **安全测试**：漏洞扫描和渗透测试

**🔧 工具生态**
- **测试框架**：Jest、Mocha、Jasmine
- **断言库**：Chai、Should.js
- **Mock工具**：Sinon、Nock
- **覆盖率工具**：Istanbul、nyc

**核心记忆**：
- 测试驱动开发，质量有保障
- 红绿重构循环，步步要稳当  
- Mock隔离依赖，数据要管好
- 覆盖率有意义，别为数字跑