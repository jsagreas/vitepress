---
title: 3、URL路径模式与匹配规则
---
## 📚 目录

1. [URL路径模式基础](#1-URL路径模式基础)
2. [通配符匹配详解](#2-通配符匹配详解)
3. [路径变量@PathVariable](#3-路径变量PathVariable)
4. [正则表达式约束](#4-正则表达式约束)
5. [路径匹配优先级](#5-路径匹配优先级)
6. [精确匹配与模糊匹配](#6-精确匹配与模糊匹配)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 URL路径模式基础


### 1.1 什么是URL路径模式


**通俗理解**：URL路径模式就像是给请求地址设置"门牌号规则"，告诉Spring MVC哪些请求该由哪个方法来处理。

```
现实类比：
快递员送快递 → 根据门牌号找对应的家
Spring MVC   → 根据URL路径找对应的处理方法

例如：
/user/123    → 查询ID为123的用户
/user/list   → 查询用户列表
/user/*      → 匹配/user/开头的所有请求
```

**🔸 核心作用**
- **请求分发**：根据URL把请求发给对应的控制器方法
- **参数提取**：从URL中提取需要的数据（如用户ID）
- **灵活匹配**：支持精确、模糊、通配符等多种匹配方式

### 1.2 路径模式语法基础


**基本语法规则**：

| 模式类型 | **语法** | **说明** | **示例** |
|---------|---------|---------|---------|
| 精确路径 | `/user/list` | 完全匹配，一个字都不能差 | 只匹配 `/user/list` |
| 单层通配符 | `/user/*` | `*` 匹配一层路径 | 匹配 `/user/123`、`/user/add` |
| 多层通配符 | `/user/**` | `**` 匹配多层路径 | 匹配 `/user/a/b/c` |
| 路径变量 | `/user/{id}` | `{}` 提取路径中的值 | `/user/123` 提取 id=123 |

**💡 新手提示**：
- `*` 只能匹配一层路径，比如 `/user/*` 不能匹配 `/user/info/detail`
- `**` 能匹配任意多层，比如 `/user/**` 可以匹配 `/user/info/detail`
- `{}` 是用来"抓取"URL里的值的，后面会详细讲

---

## 2. 🔍 通配符匹配详解


### 2.1 单层通配符 `*` 的用法


**含义**：`*` 代表"这里可以是任意一段内容"，但只能是一层路径。

**🔸 基本使用**

```java
@RestController
@RequestMapping("/product")
public class ProductController {
    
    // 匹配 /product/phone、/product/laptop 等
    @GetMapping("/*")
    public String getProduct() {
        return "获取商品信息";
    }
    
    // 匹配 /product/123.html、/product/456.json 等
    @GetMapping("/*.html")
    public String getProductPage() {
        return "商品页面";
    }
}
```

**✅ 能匹配的情况**：
```
/product/phone      ✓ (一层路径)
/product/123        ✓ (一层路径)
/product/new.html   ✓ (一层路径，且以.html结尾)
```

**❌ 不能匹配的情况**：
```
/product/phone/detail  ✗ (两层路径，*只能匹配一层)
/product               ✗ (没有后面的一层)
```

### 2.2 多层通配符 `**` 的用法


**含义**：`**` 代表"这里可以是任意多层路径"，非常灵活。

**🔸 基本使用**

```java
@RestController
public class FileController {
    
    // 匹配所有 /files/ 开头的请求，无论有多少层
    @GetMapping("/files/**")
    public String getFile() {
        return "获取文件";
    }
}
```

**✅ 能匹配的情况**：
```
/files/doc              ✓ 
/files/2024/01/report   ✓ (多层路径都可以)
/files/a/b/c/d/e        ✓ (无限层级)
```

**📌 实际应用场景**：
- **静态资源处理**：`/static/**` 匹配所有静态文件
- **文件下载**：`/download/**` 处理任意路径的文件下载
- **API版本管理**：`/api/v1/**` 匹配v1版本的所有接口

### 2.3 通配符组合使用


**🔸 混合搭配示例**

```java
@RestController
public class ApiController {
    
    // 场景1：匹配特定扩展名
    @GetMapping("/api/*.json")
    public String getJson() {
        return "JSON数据";
    }
    
    // 场景2：多层路径 + 扩展名
    @GetMapping("/download/**/*.pdf")
    public String downloadPdf() {
        return "下载PDF文件";
    }
    
    // 场景3：中间通配
    @GetMapping("/user/*/profile")
    public String getUserProfile() {
        return "用户资料";
    }
}
```

**匹配示例对照**：

```
/api/user.json          → 匹配 *.json
/api/data/user.json     → 不匹配 *.json (多层了)

/download/2024/report.pdf    → 匹配 **/*.pdf
/download/doc/a/b/file.pdf   → 匹配 **/*.pdf

/user/123/profile       → 匹配 /user/*/profile
/user/admin/profile     → 匹配 /user/*/profile
/user/123/edit          → 不匹配 (末尾不是profile)
```

---

## 3. 📦 路径变量@PathVariable


### 3.1 什么是路径变量


**通俗解释**：路径变量就像是URL里的"占位符"，可以把URL的一部分当作参数传给方法。

**现实类比**：
```
快递单号：SF1234567890
↓
把 1234567890 这个编号提取出来查询快递

URL：/order/1234567890
↓  
把 1234567890 这个订单号提取出来查询订单
```

### 3.2 基本使用方法


**🔸 单个路径变量**

```java
@RestController
@RequestMapping("/user")
public class UserController {
    
    // {id} 是路径变量，会把URL里的值赋给参数id
    @GetMapping("/{id}")
    public String getUserById(@PathVariable Long id) {
        return "查询用户ID: " + id;
    }
}
```

**访问测试**：
```
GET /user/123    → getUserById(123)  返回"查询用户ID: 123"
GET /user/456    → getUserById(456)  返回"查询用户ID: 456"
```

**🔸 多个路径变量**

```java
@RestController
public class OrderController {
    
    // 同时提取用户ID和订单ID
    @GetMapping("/user/{userId}/order/{orderId}")
    public String getOrder(
        @PathVariable Long userId,
        @PathVariable Long orderId
    ) {
        return String.format("用户%d的订单%d", userId, orderId);
    }
}
```

**访问测试**：
```
GET /user/100/order/5001  
→ getOrder(100, 5001)  
→ 返回"用户100的订单5001"
```

### 3.3 路径变量命名技巧


**场景1：变量名与参数名不一致**

```java
@GetMapping("/product/{productId}")
public String getProduct(
    @PathVariable("productId") Long id  // 指定路径变量名
) {
    return "商品ID: " + id;
}
```

**场景2：可选路径变量**

```java
// 注意：路径变量默认是必需的，要让它可选需要特殊处理
@GetMapping({"/article/{id}", "/article"})
public String getArticle(
    @PathVariable(required = false) Long id
) {
    if (id == null) {
        return "获取所有文章";
    }
    return "获取文章ID: " + id;
}
```

**📌 实际应用场景**：

| 场景 | URL示例 | 说明 |
|------|---------|------|
| 查询详情 | `/user/{id}` | 获取指定用户 |
| 删除操作 | `/delete/{id}` | 删除指定记录 |
| 层级关系 | `/dept/{deptId}/emp/{empId}` | 部门下的员工 |
| RESTful API | `/api/books/{isbn}` | 符合REST风格 |

---

## 4. 🎨 正则表达式约束


### 4.1 为什么需要正则约束


**问题场景**：
```java
@GetMapping("/user/{id}")
public String getUser(@PathVariable Long id) {
    return "用户ID: " + id;
}

访问 /user/abc  → 报错！abc不是数字
访问 /user/123  → 正常
```

**解决方案**：用正则表达式限制路径变量的格式。

### 4.2 正则约束语法


**🔸 基本语法**

```java
@GetMapping("/path/{变量名:正则表达式}")
```

**常用正则模式**：

| 约束需求 | 正则表达式 | 说明 |
|---------|-----------|------|
| 纯数字 | `\\d+` | 至少1个数字 |
| 字母数字 | `[a-zA-Z0-9]+` | 字母和数字组合 |
| 指定长度 | `\\d{6}` | 恰好6位数字 |
| 手机号 | `1[3-9]\\d{9}` | 中国手机号格式 |
| 邮箱格式 | `[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]+` | 简单邮箱验证 |

### 4.3 实际应用示例


**🔸 示例1：用户ID必须是数字**

```java
@GetMapping("/user/{id:\\d+}")
public String getUser(@PathVariable Long id) {
    return "用户ID: " + id;
}

// 访问测试
/user/123   ✓ 匹配成功
/user/abc   ✗ 404错误，不符合\\d+规则
```

**🔸 示例2：订单号格式限制**

```java
// 订单号：2位字母 + 8位数字，如：OR12345678
@GetMapping("/order/{orderNo:[A-Z]{2}\\d{8}}")
public String getOrder(@PathVariable String orderNo) {
    return "订单号: " + orderNo;
}

// 访问测试
/order/OR12345678  ✓ 匹配成功
/order/AB87654321  ✓ 匹配成功
/order/123456789   ✗ 不匹配（缺少字母）
/order/ORD1234567  ✗ 不匹配（字母3位）
```

**🔸 示例3：手机号验证**

```java
@GetMapping("/sms/{phone:1[3-9]\\d{9}}")
public String sendSms(@PathVariable String phone) {
    return "发送短信到: " + phone;
}

// 访问测试
/sms/13812345678  ✓ 匹配成功
/sms/19987654321  ✓ 匹配成功
/sms/12345678901  ✗ 不匹配（不是1开头）
/sms/138123456    ✗ 不匹配（位数不够）
```

**💡 新手提醒**：
- 正则表达式中的 `\` 要写成 `\\`（Java转义规则）
- 正则约束只影响路径匹配，不影响参数验证
- 不符合正则的请求会直接返回404

---

## 5. ⚖️ 路径匹配优先级


### 5.1 匹配规则的优先级顺序


**Spring MVC的匹配优先级**（从高到低）：

```
1. 精确匹配       最高优先级
   ↓
2. 路径变量       次高优先级
   ↓
3. 单层通配符*     中等优先级
   ↓
4. 多层通配符**    最低优先级
```

### 5.2 优先级对照示例


**场景设置**：
```java
@RestController
public class PriorityController {
    
    @GetMapping("/user/list")           // ① 精确匹配
    public String exact() {
        return "精确匹配";
    }
    
    @GetMapping("/user/{id}")           // ② 路径变量
    public String pathVar() {
        return "路径变量";
    }
    
    @GetMapping("/user/*")              // ③ 单层通配符
    public String singleWild() {
        return "单层通配符";
    }
    
    @GetMapping("/user/**")             // ④ 多层通配符
    public String multiWild() {
        return "多层通配符";
    }
}
```

**匹配结果对照表**：

| 请求URL | 匹配到的方法 | 原因 |
|---------|------------|------|
| `/user/list` | ① exact() | 精确匹配优先 |
| `/user/123` | ② pathVar() | 路径变量优先于通配符 |
| `/user/add` | ② pathVar() | 路径变量优先于通配符 |
| `/user/info/detail` | ④ multiWild() | 只有`**`能匹配多层 |

### 5.3 优先级陷阱与解决


**⚠️ 常见问题**：路径变量"吃掉"了本该精确匹配的路径

```java
// 错误示范
@GetMapping("/user/{id}")        // 会匹配 /user/list
public String getUser(@PathVariable String id) {
    // id 会等于 "list"，不是我们想要的！
    return "用户ID: " + id;
}

@GetMapping("/user/list")        // 这个方法永远不会被调用
public String getUserList() {
    return "用户列表";
}
```

**✅ 正确做法**：用正则约束限制路径变量

```java
// 正确示范：限制id必须是数字
@GetMapping("/user/{id:\\d+}")
public String getUser(@PathVariable Long id) {
    return "用户ID: " + id;
}

@GetMapping("/user/list")
public String getUserList() {
    return "用户列表";
}

// 现在匹配正常了：
// /user/123  → getUser(123)
// /user/list → getUserList()
```

**📌 最佳实践建议**：

> 🔥 **重点**：路径变量尽量使用正则约束，避免"误伤"其他路径

```java
// 推荐做法
@GetMapping("/api/{version:\\d+}/users")    // 版本号必须是数字
@GetMapping("/file/{filename:.+\\.pdf}")    // 文件名必须以.pdf结尾
@GetMapping("/product/{id:[A-Z]{2}\\d+}")   // 商品ID特定格式
```

---

## 6. 🎯 精确匹配与模糊匹配


### 6.1 精确匹配详解


**含义**：URL必须完全一致，一个字符都不能差。

**🔸 精确匹配特点**

```java
@GetMapping("/api/v1/user/list")
public String getUserList() {
    return "用户列表";
}

访问对比：
/api/v1/user/list      ✓ 完全匹配
/api/v1/user/list/     ✗ 多了斜杠
/api/v1/user/lists     ✗ 多了字母s
/api/v1/users/list     ✗ user写成了users
```

**📌 精确匹配的应用场景**：

| 场景 | 示例 | 原因 |
|------|------|------|
| 关键操作 | `/admin/delete` | 避免误匹配导致误删 |
| 固定端点 | `/api/login` | 登录路径不能模糊 |
| 特定资源 | `/index.html` | 精确访问首页 |

### 6.2 模糊匹配详解


**含义**：使用通配符或路径变量，匹配一类URL。

**🔸 模糊匹配类型对比**

```
类型A：单层通配符
@GetMapping("/product/*")
→ 匹配 /product/phone、/product/laptop

类型B：多层通配符  
@GetMapping("/static/**")
→ 匹配 /static/css/style.css、/static/js/app.js

类型C：路径变量
@GetMapping("/user/{id}")
→ 匹配 /user/123、/user/456
```

**📊 精确 vs 模糊选择指南**

| 需求 | 选择 | 示例 |
|------|------|------|
| 固定的业务路径 | 精确匹配 | `/order/submit` |
| 动态的资源ID | 路径变量 | `/user/{id}` |
| 同类型资源 | 单层通配符 | `/api/v1/*` |
| 静态文件目录 | 多层通配符 | `/static/**` |

### 6.3 混合使用策略


**实际项目常见组合**：

```java
@RestController
@RequestMapping("/api")
public class ApiController {
    
    // 1. 精确匹配：核心业务接口
    @PostMapping("/v1/user/register")
    public String register() {
        return "用户注册";
    }
    
    // 2. 路径变量：资源操作
    @GetMapping("/v1/user/{id:\\d+}")
    public String getUser(@PathVariable Long id) {
        return "获取用户: " + id;
    }
    
    // 3. 通配符：批量处理
    @GetMapping("/v1/*/export")
    public String exportData() {
        return "导出数据";
    }
    
    // 4. 多层通配符：文档访问
    @GetMapping("/docs/**")
    public String getDocs() {
        return "API文档";
    }
}
```

**访问示例**：
```
POST /api/v1/user/register      → register()      (精确)
GET  /api/v1/user/123           → getUser(123)    (变量)
GET  /api/v1/order/export       → exportData()    (通配)
GET  /api/docs/guide/start.html → getDocs()       (多层)
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 路径模式：定义URL匹配规则的语法
🔸 通配符*：匹配单层路径，如 /user/*
🔸 通配符**：匹配多层路径，如 /static/**
🔸 路径变量：提取URL中的值，如 /user/{id}
🔸 正则约束：限制路径变量格式，如 {id:\\d+}
🔸 匹配优先级：精确 > 变量 > * > **
```

### 7.2 关键理解要点


**🔹 通配符的区别**
```
*  → 单层匹配，相当于一个"槽位"
**  → 多层匹配，相当于"无限槽位"

记忆技巧：
* 一个星星管一层
** 两个星星管所有层
```

**🔹 路径变量的本质**
```
作用：把URL的一部分当作参数传给方法
本质：占位符 + 参数绑定

实际场景：
/user/123    → id = 123
/order/5001  → orderId = 5001
```

**🔹 正则约束的价值**
```
问题：路径变量太灵活，可能匹配不该匹配的
解决：正则表达式限制格式

示例：
{id}         → 任何值都行（太宽松）
{id:\\d+}    → 必须是数字（刚刚好）
```

### 7.3 实际应用建议


**✅ 推荐做法**：

```java
// 1. 核心业务用精确路径
@PostMapping("/api/order/submit")

// 2. 资源操作用路径变量 + 正则
@GetMapping("/api/user/{id:\\d+}")

// 3. 静态资源用多层通配符
@GetMapping("/static/**")

// 4. 同类接口用单层通配符
@GetMapping("/api/v1/*/list")
```

**❌ 避免的陷阱**：

```java
// 陷阱1：路径变量不加约束
@GetMapping("/user/{id}")  // id可能是"list"，导致冲突

// 陷阱2：过度使用通配符
@GetMapping("/**")  // 太宽泛，容易误匹配

// 陷阱3：忽略优先级
// 先定义 /user/{id}，后定义 /user/list
// 导致 /user/list 永远匹配不到
```

### 7.4 快速记忆口诀


```
精确路径要优先，核心业务不能乱
路径变量加正则，格式约束更安全
单星匹配一层路，双星管理全路径
优先级别要记清，精确最高通配低
```

### 7.5 常见问题速查


| 问题 | 解决方案 |
|------|---------|
| 路径变量与固定路径冲突 | 给路径变量加正则约束 |
| 不知道用*还是** | 单层用*，多层用** |
| 正则表达式报错 | 记得用`\\`转义 |
| 优先级搞不清 | 记住：精确>变量>*>** |
| 路径匹配不到 | 检查是否被其他模式"抢"了 |

**🎯 核心记忆**：
- URL路径模式是Spring MVC请求分发的"导航地图"
- 灵活运用精确、变量、通配符三种模式
- 正则约束是路径变量的"安全带"
- 优先级规则是避免冲突的"交通规则"