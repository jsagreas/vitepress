---
title: 2、Spring MVC完整工作流程
---
## 📚 目录

1. [Spring MVC工作流程概述](#1-Spring-MVC工作流程概述)
2. [核心组件角色详解](#2-核心组件角色详解)
3. [完整请求处理流程](#3-完整请求处理流程)
4. [执行链管理机制](#4-执行链管理机制)
5. [实战代码演示](#5-实战代码演示)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 Spring MVC工作流程概述


### 1.1 什么是Spring MVC工作流程


🌰 **生活类比**：想象你去餐厅点餐的过程
- 你(客户端)向服务员(DispatcherServlet)点餐
- 服务员查菜单(HandlerMapping)找到对应的厨师(Controller)
- 厨师做好菜(业务处理)
- 服务员把菜端给你(返回响应)

**核心定义**：Spring MVC工作流程就是从接收用户请求到返回响应结果的完整过程，整个过程由多个组件协同完成。

### 1.2 为什么需要了解工作流程


> 💡 **学习价值**  
> 理解工作流程可以帮你：
> - 快速定位问题出在哪个环节
> - 知道在什么地方添加自己的处理逻辑
> - 更好地进行性能优化和调试

### 1.3 流程架构全景图


```
浏览器发起请求
    │
    ▼
┌─────────────────────────────────────────────┐
│        DispatcherServlet (前端控制器)        │
│              "总指挥官"                       │
└─────────────────────────────────────────────┘
    │                                    ▲
    ▼                                    │
┌──────────────┐                  ┌──────────────┐
│ HandlerMapping│                  │  ViewResolver │
│  "地图导航"   │                  │  "视图翻译器" │
└──────────────┘                  └──────────────┘
    │                                    ▲
    ▼                                    │
┌──────────────┐                  ┌──────────────┐
│HandlerAdapter│  ──处理请求──▶   │  Controller   │
│  "适配器"     │                  │  "业务处理"   │
└──────────────┘                  └──────────────┘
```

---

## 2. 🔧 核心组件角色详解


### 2.1 DispatcherServlet - 前端控制器


**🔸 角色定位**：整个流程的总指挥官，所有请求的入口

**通俗理解**：就像公司前台，所有来访的人都先经过前台，前台负责：
- 接待来访者(接收请求)
- 查找负责人(查找处理器)
- 安排会议室(调用处理器)
- 送客(返回响应)

**核心职责**：
```
1️⃣ 接收所有HTTP请求
2️⃣ 根据请求查找对应的处理器
3️⃣ 调用处理器执行业务逻辑
4️⃣ 处理视图渲染
5️⃣ 返回最终响应
```

> ⚠️ **重要提示**  
> DispatcherServlet本身不处理业务逻辑，它只负责调度协调

### 2.2 HandlerMapping - 处理器映射器


**🔸 角色定位**：请求地址与处理器的"地图导航"

**通俗理解**：就像外卖平台的地址匹配系统
- 你输入地址(请求URL)
- 系统找到对应的商家(Controller方法)

**工作原理**：
```
请求URL: /user/login
         ↓
HandlerMapping查找映射关系
         ↓
找到: UserController的login()方法
```

**映射方式示例**：

| 请求路径 | 映射到的处理器 | 说明 |
|---------|--------------|------|
| `/user/list` | `UserController.listUsers()` | 查询用户列表 |
| `/user/add` | `UserController.addUser()` | 添加用户 |
| `/product/detail` | `ProductController.detail()` | 商品详情 |

### 2.3 HandlerAdapter - 处理器适配器


**🔸 角色定位**：让不同类型的处理器都能被调用的"万能插座"

**通俗理解**：就像电源转换器
- 不同国家的插头(不同类型的Controller)
- 通过转换器(HandlerAdapter)
- 都能插到同一个插座上(被DispatcherServlet调用)

**为什么需要适配器？**

```
Controller的写法有很多种：
✅ 注解方式: @Controller + @RequestMapping
✅ 实现接口: implements Controller
✅ 实现HttpRequestHandler接口

适配器的作用就是：
无论你用哪种方式写Controller，
我都能正确调用它！
```

### 2.4 Controller - 控制器


**🔸 角色定位**：实际处理业务逻辑的"工人"

**通俗理解**：就像餐厅的厨师
- 接收订单(请求参数)
- 制作菜品(执行业务逻辑)
- 返回成品(返回数据或视图)

**主要工作**：
```
1️⃣ 接收请求参数
2️⃣ 调用Service层处理业务
3️⃣ 准备返回数据
4️⃣ 指定视图名称或直接返回数据
```

### 2.5 ViewResolver - 视图解析器


**🔸 角色定位**：把逻辑视图名转换成真实页面的"翻译官"

**通俗理解**：就像快递地址解析
- Controller返回："userList"(逻辑视图名)
- ViewResolver翻译成："/WEB-INF/views/userList.jsp"(真实路径)

**解析过程**：
```
Controller返回: "success"
               ↓
ViewResolver处理
               ↓
前缀: /WEB-INF/views/
逻辑名: success
后缀: .jsp
               ↓
最终路径: /WEB-INF/views/success.jsp
```

---

## 3. 🚀 完整请求处理流程


### 3.1 流程步骤详解


**完整的9步处理流程**：

```
用户浏览器
    │
    │ 1️⃣ 发送HTTP请求
    ▼
┌─────────────────────────────────────┐
│     DispatcherServlet               │
│     (接收请求，开始调度)             │
└─────────────────────────────────────┘
    │
    │ 2️⃣ 查询处理器
    ▼
┌─────────────────────────────────────┐
│     HandlerMapping                  │
│     (返回Handler执行链)              │
└─────────────────────────────────────┘
    │
    │ 3️⃣ 获取执行链(包含拦截器)
    ▼
┌─────────────────────────────────────┐
│     HandlerAdapter                  │
│     (调用真正的处理器)               │
└─────────────────────────────────────┘
    │
    │ 4️⃣ 执行拦截器前置方法
    │ 5️⃣ 调用Controller处理
    │ 6️⃣ 执行拦截器后置方法
    ▼
┌─────────────────────────────────────┐
│     Controller                      │
│     (执行业务逻辑，返回ModelAndView) │
└─────────────────────────────────────┘
    │
    │ 7️⃣ 返回ModelAndView
    ▼
┌─────────────────────────────────────┐
│     ViewResolver                    │
│     (解析视图)                       │
└─────────────────────────────────────┘
    │
    │ 8️⃣ 渲染视图
    ▼
┌─────────────────────────────────────┐
│     View                            │
│     (生成HTML响应)                   │
└─────────────────────────────────────┘
    │
    │ 9️⃣ 返回响应
    ▼
用户浏览器(显示页面)
```

### 3.2 每一步的详细说明


**步骤1：用户发送请求**
```
浏览器输入：http://localhost:8080/user/list
发送GET请求到服务器
```

**步骤2：DispatcherServlet接收请求**
- DispatcherServlet作为前端控制器拦截所有请求
- 开始协调整个处理流程

**步骤3：查找处理器(HandlerMapping)**
- DispatcherServlet询问HandlerMapping："/user/list这个请求该谁处理？"
- HandlerMapping回答："UserController的listUsers()方法"
- 同时返回一个执行链(包含拦截器和处理器)

**步骤4：获取适配器(HandlerAdapter)**
- DispatcherServlet找到合适的HandlerAdapter
- 适配器负责实际调用Controller方法

**步骤5：执行拦截器前置方法**
- 在调用Controller之前
- 依次执行拦截器的preHandle()方法
- 可以做权限检查、日志记录等

**步骤6：调用Controller处理请求**
- HandlerAdapter调用Controller的方法
- Controller执行业务逻辑
- 返回ModelAndView对象(包含数据和视图名)

**步骤7：执行拦截器后置方法**
- 在Controller执行完之后
- 依次执行拦截器的postHandle()方法

**步骤8：处理视图(ViewResolver)**
- DispatcherServlet把逻辑视图名交给ViewResolver
- ViewResolver找到真实的视图文件
- 返回View对象

**步骤9：渲染视图并返回**
- View对象渲染页面(把数据填充到页面)
- 生成最终的HTML
- DispatcherServlet把HTML返回给浏览器

### 3.3 两种常见的处理方式


**方式1：返回页面(传统方式)**
```
Controller返回 → ModelAndView → 视图解析 → 渲染页面 → HTML响应
适用场景：传统的网页应用
```

**方式2：返回数据(前后端分离)**
```
Controller返回 → @ResponseBody → 直接返回JSON → 不需要视图解析
适用场景：前后端分离项目、提供API接口
```

---

## 4. ⚙️ 执行链管理机制


### 4.1 什么是执行链


**通俗理解**：执行链就像安检流程
- 你要登机(访问Controller)
- 必须经过安检(拦截器检查)
- 检查通过才能登机(执行Controller)
- 下飞机时也要检查(拦截器后置处理)

**执行链组成**：
```
HandlerExecutionChain(执行链)
├── Handler(处理器) - 真正的Controller方法
└── Interceptor[](拦截器数组) - 多个拦截器
    ├── 拦截器1
    ├── 拦截器2
    └── 拦截器3
```

### 4.2 拦截器的执行顺序


**完整执行流程**：

```
请求到达
    ↓
拦截器1.preHandle()  ← 前置处理
    ↓
拦截器2.preHandle()
    ↓
拦截器3.preHandle()
    ↓
Controller.method()  ← 核心处理
    ↓
拦截器3.postHandle() ← 后置处理(倒序)
    ↓
拦截器2.postHandle()
    ↓
拦截器1.postHandle()
    ↓
渲染视图
    ↓
拦截器3.afterCompletion() ← 完成处理(倒序)
    ↓
拦截器2.afterCompletion()
    ↓
拦截器1.afterCompletion()
    ↓
响应返回
```

> 💡 **记忆技巧**  
> - preHandle：正序执行(像进门安检)
> - postHandle：倒序执行(像出门检查，后进先出)
> - afterCompletion：倒序执行(像关门，最后开的先关)

### 4.3 拦截器的应用场景


**常见用途**：

| 拦截器类型 | **作用** | **示例** |
|-----------|---------|---------|
| 🔐 **权限拦截器** | 检查用户是否登录 | 未登录跳转登录页 |
| 📝 **日志拦截器** | 记录请求信息 | 记录访问时间、IP |
| 🌍 **国际化拦截器** | 切换语言 | 根据请求设置语言 |
| ⏱️ **性能监控拦截器** | 统计处理时间 | 记录接口响应时间 |

### 4.4 执行链的中断机制


**中断规则**：
```
如果拦截器1.preHandle()返回false
    ↓
执行链中断，不会继续往下执行
    ↓
直接执行已完成的拦截器的afterCompletion()
    ↓
返回响应(通常是错误页面或重定向)
```

**中断示例场景**：
```
用户访问需要登录的页面
    ↓
权限拦截器.preHandle()检查登录状态
    ↓
发现未登录，返回false
    ↓
执行链中断，不会执行Controller
    ↓
拦截器内部重定向到登录页
```

---

## 5. 💻 实战代码演示


### 5.1 基础Controller示例


```java
@Controller
@RequestMapping("/user")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // 场景1：返回页面
    @RequestMapping("/list")
    public ModelAndView listUsers() {
        // 1. 调用业务层获取数据
        List<User> users = userService.findAll();
        
        // 2. 创建ModelAndView对象
        ModelAndView mv = new ModelAndView();
        
        // 3. 添加数据到模型(相当于request.setAttribute)
        mv.addObject("userList", users);
        
        // 4. 设置视图名称
        mv.setViewName("userList"); // 会被解析成 /WEB-INF/views/userList.jsp
        
        return mv;
    }
    
    // 场景2：返回JSON数据(前后端分离)
    @RequestMapping("/info")
    @ResponseBody  // 关键注解：直接返回JSON，不走视图解析
    public User getUserInfo(@RequestParam Integer id) {
        // 直接返回对象，Spring会自动转成JSON
        return userService.findById(id);
    }
}
```

**代码说明**：
- `@Controller`：标记这是一个控制器类
- `@RequestMapping`：映射请求路径
- `ModelAndView`：包含数据和视图的对象
- `@ResponseBody`：直接返回数据，不需要视图解析

### 5.2 自定义拦截器示例


```java
// 登录检查拦截器
public class LoginInterceptor implements HandlerInterceptor {
    
    // 前置处理：Controller执行之前调用
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        
        // 1. 检查session中是否有用户信息
        Object user = request.getSession().getAttribute("user");
        
        // 2. 如果已登录，放行
        if (user != null) {
            return true; // 返回true，继续执行
        }
        
        // 3. 未登录，重定向到登录页
        response.sendRedirect("/login");
        return false; // 返回false，中断执行链
    }
    
    // 后置处理：Controller执行之后，视图渲染之前调用
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) throws Exception {
        
        // 可以修改ModelAndView，添加公共数据
        if (modelAndView != null) {
            modelAndView.addObject("currentTime", new Date());
        }
    }
    
    // 完成处理：整个请求完成之后调用
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) throws Exception {
        
        // 清理资源、记录日志等
        System.out.println("请求处理完成");
    }
}
```

### 5.3 配置拦截器


```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 注册拦截器
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns("/user/**")  // 拦截哪些路径
                .excludePathPatterns("/user/login"); // 排除哪些路径
    }
}
```

### 5.4 配置视图解析器


```java
@Configuration
public class ViewResolverConfig {
    
    @Bean
    public InternalResourceViewResolver viewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        
        // 设置前缀
        resolver.setPrefix("/WEB-INF/views/");
        
        // 设置后缀
        resolver.setSuffix(".jsp");
        
        return resolver;
        // 现在返回"userList"会被解析成"/WEB-INF/views/userList.jsp"
    }
}
```

---

## 6. 📋 核心要点总结


### 6.1 工作流程口诀


```
🧠 记忆口诀：
请求到达找前端，DispatcherServlet是关键
HandlerMapping来导航，找到处理器不迷茫
HandlerAdapter做适配，调用Controller真处理
拦截器前后都经过，权限日志样样行
ModelAndView装数据，ViewResolver来翻译
View渲染成页面，响应返回到客户端
```

### 6.2 核心组件对照表


| 组件 | **通俗比喻** | **主要职责** | **关键方法** |
|-----|------------|------------|------------|
| 🎯 **DispatcherServlet** | 总指挥 | 协调整个流程 | `doDispatch()` |
| 🗺️ **HandlerMapping** | 导航系统 | URL映射查找 | `getHandler()` |
| 🔌 **HandlerAdapter** | 万能插座 | 适配不同处理器 | `handle()` |
| 👨‍💼 **Controller** | 业务处理 | 执行业务逻辑 | 自定义方法 |
| 🔍 **ViewResolver** | 地址翻译 | 解析视图名称 | `resolveViewName()` |
| 🚪 **Interceptor** | 安检门 | 前后拦截处理 | `preHandle()` |

### 6.3 两种开发模式对比


**传统模式(返回页面)**
```
✅ 适合：后端渲染的传统Web应用
✅ 流程：Controller → ModelAndView → 视图解析 → 渲染页面
✅ 特点：SEO友好，但前后端耦合
```

**前后端分离(返回JSON)**
```
✅ 适合：现代Web应用、移动端APP
✅ 流程：Controller → @ResponseBody → 直接返回JSON
✅ 特点：前后端独立开发，但需要处理跨域
```

### 6.4 常见问题快速诊断


**🔸 404错误**
```
可能原因：
1. HandlerMapping没找到对应的处理器
   → 检查@RequestMapping路径是否正确
2. 视图文件不存在
   → 检查视图文件路径和名称
```

**🔸 405错误(方法不允许)**
```
可能原因：
请求方式(GET/POST)与@RequestMapping不匹配
→ 检查method属性配置
```

**🔸 500错误(服务器内部错误)**
```
可能原因：
1. Controller方法执行异常
   → 检查业务逻辑代码
2. 视图渲染异常
   → 检查JSP语法或模板引擎配置
```

### 6.5 学习建议


**📈 学习路径**
```
1️⃣ 先理解整体流程(本节内容)
2️⃣ 掌握基本的Controller写法
3️⃣ 学习拦截器的使用
4️⃣ 了解视图解析机制
5️⃣ 实战项目中灵活运用
```

**💪 实践建议**
- [ ] 画出完整的流程图加深理解
- [ ] 自己写一个登录拦截器
- [ ] 实现一个简单的CRUD操作
- [ ] 调试代码观察执行顺序

> 🎯 **核心理解**  
> Spring MVC的工作流程就是一个"流水线"，每个组件各司其职，相互配合完成请求处理。理解了这个流程，你就掌握了Spring MVC的精髓！