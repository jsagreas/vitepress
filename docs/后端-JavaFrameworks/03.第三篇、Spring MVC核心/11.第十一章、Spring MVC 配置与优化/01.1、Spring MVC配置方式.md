---
title: 1、Spring MVC配置方式
---
## 📚 目录

1. [配置方式概述](#1-配置方式概述)
2. [Java配置方式](#2-Java配置方式)
3. [XML配置方式](#3-XML配置方式)
4. [注解配置方式](#4-注解配置方式)
5. [WebMvcConfigurer详解](#5-WebMvcConfigurer详解)
6. [配置优先级与组合](#6-配置优先级与组合)
7. [环境配置管理](#7-环境配置管理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 配置方式概述


### 1.1 为什么需要配置Spring MVC


**生活类比**：
```
就像装修房子一样：
🏠 毛坯房 = 原始Spring框架（只有基础功能）
🎨 装修方案 = Spring MVC配置（定制你需要的功能）
🛠️ 装修方式 = 配置方式（Java/XML/注解）

你可以选择：
- 找装修公司（XML配置）：传统方式，配置文件清晰
- 自己动手（Java配置）：灵活度高，现代推荐
- 智能家居（注解配置）：自动化，省心省力
```

### 1.2 三种主要配置方式对比


| 配置方式 | **特点** | **适用场景** | **学习难度** |
|---------|---------|-------------|-------------|
| 🟦 **Java配置** | `类型安全、灵活强大` | `新项目、微服务` | `⭐⭐☆☆☆` |
| 🟨 **XML配置** | `配置集中、可视化好` | `老项目维护` | `⭐⭐⭐☆☆` |
| 🟩 **注解配置** | `简洁高效、开发快` | `快速开发` | `⭐☆☆☆☆` |

### 1.3 配置的核心内容


**必须配置的内容**：
```
┌─ Spring MVC配置项 ──────────┐
│                           │
│ 📍 视图解析器              │
│    ↓ 决定页面去哪找        │
│                           │
│ 🔄 拦截器                  │
│    ↓ 请求的守门员          │
│                           │
│ 📝 消息转换器              │
│    ↓ 数据格式的翻译官      │
│                           │
│ 🗂️ 静态资源处理            │
│    ↓ 图片CSS的管家         │
│                           │
└───────────────────────────┘
```

---

## 2. ☕ Java配置方式


### 2.1 什么是Java配置


**通俗解释**：
用Java代码代替XML文件来配置Spring MVC，就像用编程语言来"说明书"，而不是写文档。

**核心优势**：
- ✅ **类型安全**：编译时就能发现错误
- ✅ **IDE友好**：代码提示、重构方便
- ✅ **灵活强大**：可以写逻辑判断

### 2.2 基础Java配置实现


**配置类示例**：
```java
@Configuration
@EnableWebMvc
@ComponentScan("com.example.controller")
public class WebConfig {
    
    // 配置视图解析器
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = 
            new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
}
```

**代码解读**：
```
@Configuration        → 告诉Spring：这是配置类
@EnableWebMvc        → 开启Spring MVC功能
@ComponentScan       → 扫描Controller在哪
@Bean                → 创建并管理视图解析器
```

### 2.3 WebApplicationInitializer方式


**什么是WebApplicationInitializer**：
这是Spring提供的接口，用来替代传统的`web.xml`配置文件。

**实现示例**：
```java
public class MyWebInit implements WebApplicationInitializer {
    
    @Override
    public void onStartup(ServletContext context) {
        // 创建Spring容器
        AnnotationConfigWebApplicationContext ctx = 
            new AnnotationConfigWebApplicationContext();
        ctx.register(WebConfig.class);
        
        // 注册DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(ctx);
        ServletRegistration.Dynamic registration = 
            context.addServlet("dispatcher", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}
```

**工作流程**：
```
应用启动
    ↓
Servlet容器找到WebApplicationInitializer实现类
    ↓
执行onStartup方法
    ↓
创建Spring容器 + 注册DispatcherServlet
    ↓
Spring MVC开始工作
```

### 2.4 配置类的组织方式


**分层配置结构**：
```
项目配置架构：

WebConfig.java           ← 主配置类
    ↓
├── ViewConfig.java      ← 视图相关配置
├── InterceptorConfig.java ← 拦截器配置  
├── ResourceConfig.java  ← 静态资源配置
└── MessageConfig.java   ← 消息转换配置

优点：职责清晰，易于维护
```

**配置类导入**：
```java
@Configuration
@Import({
    ViewConfig.class,
    InterceptorConfig.class,
    ResourceConfig.class
})
public class WebConfig {
    // 主配置内容
}
```

---

## 3. 📄 XML配置方式


### 3.1 XML配置的本质


**通俗理解**：
XML配置就像写一份详细的"说明书"，告诉Spring每个组件怎么创建、怎么使用。

**传统但经典**：
- 📋 配置集中，一目了然
- 🔍 适合查看整体架构
- 🛠️ 老项目常用方式

### 3.2 基础XML配置


**spring-mvc.xml配置文件**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context">

    <!-- 开启注解驱动 -->
    <mvc:annotation-driven/>
    
    <!-- 扫描Controller -->
    <context:component-scan base-package="com.example.controller"/>
    
    <!-- 视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
    
    <!-- 静态资源处理 -->
    <mvc:default-servlet-handler/>
</beans>
```

**配置说明**：
```
<mvc:annotation-driven/>     → 开启Spring MVC的注解功能
<context:component-scan/>    → 告诉Spring去哪找Controller
<bean>标签                   → 创建视图解析器对象
<mvc:default-servlet-handler/> → 处理静态文件（CSS/JS/图片）
```

### 3.3 web.xml配置


**web.xml示例**：
```xml
<web-app>
    <!-- 配置DispatcherServlet -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

**配置流程图**：
```
Tomcat启动
    ↓
读取web.xml
    ↓
创建DispatcherServlet
    ↓
加载spring-mvc.xml
    ↓
初始化Spring MVC组件
    ↓
准备处理请求
```

### 3.4 XML vs Java配置选择


**选择建议**：
```
┌─ 项目情况判断 ────────────────┐
│                             │
│ 新项目？                     │
│  ↓ YES → 选Java配置         │
│                             │
│ 老项目维护？                 │
│  ↓ YES → 保持XML配置        │
│                             │
│ 团队习惯XML？                │
│  ↓ YES → 继续用XML          │
│                             │
│ 需要动态配置？               │
│  ↓ YES → 选Java配置         │
│                             │
└─────────────────────────────┘
```

---

## 4. 🏷️ 注解配置方式


### 4.1 注解配置的核心思想


**通俗理解**：
注解就像给代码贴"标签"，Spring看到标签就知道该做什么，自动帮你配置。

**主要注解**：
- `@Configuration` - 这是配置类
- `@EnableWebMvc` - 开启MVC功能
- `@ComponentScan` - 自动扫描组件
- `@Bean` - 手动创建Bean

### 4.2 常用配置注解详解


**@EnableWebMvc注解**：
```java
@Configuration
@EnableWebMvc  // 一个注解开启所有MVC功能
public class WebConfig {
    // 自动配置了：
    // - 请求映射处理
    // - 数据绑定
    // - 类型转换
    // - 数据校验
    // - 消息转换等
}
```

**它做了什么**：
```
@EnableWebMvc 注解的魔法：

自动注册 → HandlerMapping（找Controller）
         ↓
自动注册 → HandlerAdapter（执行方法）
         ↓
自动注册 → HandlerExceptionResolver（处理异常）
         ↓
自动注册 → MessageConverter（转换JSON/XML）
```

### 4.3 Controller层注解


**控制器注解**：
```java
@RestController  // = @Controller + @ResponseBody
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")  // GET请求
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    @PostMapping  // POST请求
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
}
```

**注解说明**：
```
@RestController      → 返回JSON数据的Controller
@RequestMapping      → 设置URL路径
@GetMapping         → 处理GET请求
@PostMapping        → 处理POST请求
@PathVariable       → 获取URL中的参数
@RequestBody        → 接收JSON数据
```

### 4.4 配置类中的Bean注解


**创建自定义Bean**：
```java
@Configuration
public class WebConfig {
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        // 自定义JSON转换规则
        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));
        return mapper;
    }
    
    @Bean
    public RestTemplate restTemplate() {
        // 创建HTTP客户端工具
        return new RestTemplate();
    }
}
```

---

## 5. 🔧 WebMvcConfigurer详解


### 5.1 什么是WebMvcConfigurer


**核心概念**：
WebMvcConfigurer是Spring MVC提供的配置接口，用来自定义MVC的各种行为。

**生活类比**：
```
就像手机的设置界面：
📱 手机系统 = Spring MVC框架
⚙️ 设置界面 = WebMvcConfigurer
🎨 个性化选项 = 各种配置方法

你可以设置：
- 主题颜色（拦截器）
- 默认应用（视图解析器）
- 文件存储（静态资源）
```

### 5.2 实现WebMvcConfigurer


**两种实现方式**：

**方式1：实现接口**
```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // 配置视图控制器
        registry.addViewController("/").setViewName("home");
    }
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 配置静态资源
        registry.addResourceHandler("/static/**")
                .addResourceLocations("/static/");
    }
}
```

**方式2：继承适配器（Spring 5.0前）**
```java
@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {
    // 只重写需要的方法
}
```

### 5.3 常用配置方法


**配置方法速查表**：

| 方法名 | **作用** | **使用场景** |
|-------|---------|-------------|
| `addInterceptors` | `添加拦截器` | `权限检查、日志记录` |
| `addResourceHandlers` | `静态资源处理` | `CSS/JS/图片访问` |
| `addViewControllers` | `简单页面跳转` | `不需要Controller的页面` |
| `configureMessageConverters` | `消息转换器` | `JSON/XML格式转换` |
| `addCorsMappings` | `跨域配置` | `前后端分离项目` |
| `configurePathMatch` | `路径匹配` | `URL后缀处理` |

### 5.4 实战配置示例


**完整配置类**：
```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    
    // 1. 拦截器配置
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns("/admin/**")    // 拦截路径
                .excludePathPatterns("/admin/login"); // 排除路径
    }
    
    // 2. 静态资源配置
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**")
                .addResourceLocations("/static/")
                .setCachePeriod(3600);  // 缓存1小时
    }
    
    // 3. 跨域配置
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE");
    }
    
    // 4. 视图解析器
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/WEB-INF/views/", ".jsp");
    }
}
```

**配置说明**：
```
拦截器 → 对/admin/**路径进行权限检查
静态资源 → /static/下的文件直接访问，缓存1小时
跨域 → 允许localhost:3000访问API
视图解析器 → JSP文件放在/WEB-INF/views/目录
```

---

## 6. 📊 配置优先级与组合


### 6.1 配置加载顺序


**优先级规则**：
```
配置优先级（从高到低）：

1. @Bean方法中的配置
   ↓ 优先级最高
   
2. WebMvcConfigurer中的配置
   ↓ 次之
   
3. @EnableWebMvc的默认配置
   ↓ 优先级最低
```

**实际效果**：
```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    
    // 优先级1：手动创建Bean
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = 
            new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
    
    // 优先级2：WebMvcConfigurer配置
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/templates/", ".html");
    }
    
    // 最终生效：@Bean方法的配置
    // prefix = /WEB-INF/views/
    // suffix = .jsp
}
```

### 6.2 配置组合策略


**混合配置示例**：
```java
// 主配置类
@Configuration
@EnableWebMvc
@ComponentScan("com.example")
@Import({ViewConfig.class, InterceptorConfig.class})
public class RootConfig {
    // 核心配置
}

// 视图配置类
@Configuration
public class ViewConfig implements WebMvcConfigurer {
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/WEB-INF/views/", ".jsp");
    }
}

// 拦截器配置类
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LogInterceptor());
    }
}
```

**组合优势**：
```
┌─ 配置分离的好处 ────────────┐
│                           │
│ ✅ 职责清晰               │
│ ✅ 易于维护               │
│ ✅ 可复用配置             │
│ ✅ 团队协作方便           │
│                           │
└───────────────────────────┘
```

### 6.3 避免配置冲突


**常见冲突场景**：

**场景1：多个视图解析器**
```java
// 问题：两个视图解析器冲突
@Bean
public ViewResolver jspResolver() {
    InternalResourceViewResolver resolver = 
        new InternalResourceViewResolver();
    resolver.setPrefix("/WEB-INF/jsp/");
    resolver.setSuffix(".jsp");
    resolver.setOrder(1);  // 设置优先级
    return resolver;
}

@Bean
public ViewResolver thymeleafResolver() {
    ThymeleafViewResolver resolver = new ThymeleafViewResolver();
    resolver.setTemplateEngine(templateEngine());
    resolver.setOrder(2);  // 优先级低于JSP
    return resolver;
}
```

**解决方案**：
```
使用Order属性指定优先级：
- Order值越小，优先级越高
- 数字1 > 数字2 > 数字3...
```

---

## 7. 🌍 环境配置管理


### 7.1 多环境配置概念


**为什么需要多环境**：
```
开发过程的不同阶段：

开发环境（dev）    → 本地开发，调试方便
    ↓
测试环境（test）   → 功能测试，模拟真实
    ↓
生产环境（prod）   → 正式上线，稳定高效

每个环境的配置不同：
- 数据库地址
- 日志级别  
- 文件路径
- API密钥
```

### 7.2 使用@Profile管理环境


**Profile配置示例**：
```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Profile("dev")  // 开发环境
    public DataSource devDataSource() {
        // 本地数据库
        return DataSourceBuilder.create()
            .url("jdbc:mysql://localhost:3306/mydb")
            .username("root")
            .password("123456")
            .build();
    }
    
    @Bean
    @Profile("prod")  // 生产环境
    public DataSource prodDataSource() {
        // 生产数据库
        return DataSourceBuilder.create()
            .url("jdbc:mysql://prod-server:3306/mydb")
            .username("admin")
            .password("******")
            .build();
    }
}
```

**激活Profile的方式**：

**方式1：配置文件**
```properties
# application.properties
spring.profiles.active=dev
```

**方式2：启动参数**
```bash
java -jar myapp.jar --spring.profiles.active=prod
```

**方式3：环境变量**
```bash
export SPRING_PROFILES_ACTIVE=test
```

### 7.3 配置文件分离


**文件组织结构**：
```
src/main/resources/
  ├── application.properties          ← 公共配置
  ├── application-dev.properties      ← 开发环境
  ├── application-test.properties     ← 测试环境
  └── application-prod.properties     ← 生产环境
```

**配置示例**：

**application.properties（公共）**
```properties
# 应用名称
spring.application.name=myapp

# 日志配置
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
```

**application-dev.properties（开发）**
```properties
# 开发数据库
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=123456

# 开发日志级别（详细）
logging.level.root=DEBUG
```

**application-prod.properties（生产）**
```properties
# 生产数据库
spring.datasource.url=jdbc:mysql://prod-server:3306/mydb
spring.datasource.username=admin
spring.datasource.password=${DB_PASSWORD}

# 生产日志级别（简洁）
logging.level.root=WARN
```

### 7.4 配置优先级


**加载顺序**：
```
配置优先级（从高到低）：

1. 命令行参数
   java -jar app.jar --server.port=8080
   ↓ 优先级最高
   
2. 操作系统环境变量
   export SERVER_PORT=8080
   ↓
   
3. application-{profile}.properties
   application-prod.properties
   ↓
   
4. application.properties
   ↓ 优先级最低
```

**实际应用**：
```java
@Configuration
public class WebConfig {
    
    @Value("${server.port:8080}")  // 默认8080
    private int port;
    
    @Value("${app.name:MyApp}")    // 默认MyApp
    private String appName;
    
    // 配置来源优先级：
    // 命令行 > 环境变量 > 配置文件 > 默认值
}
```

---

## 8. 📋 核心要点总结


### 8.1 配置方式选择指南


**🎯 快速决策树**：
```
开始新项目？
  ↓ YES
  └→ 使用Java配置 + 注解
      ├─ 类型安全
      ├─ 灵活强大
      └─ 现代推荐
      
  ↓ NO（维护老项目）
  └→ 保持XML配置
      ├─ 配置集中
      ├─ 可视化好
      └─ 团队熟悉
```

**配置方式对比总结**：

| 特性 | **Java配置** | **XML配置** | **注解配置** |
|-----|------------|------------|-------------|
| 🎓 学习曲线 | `中等` | `较高` | `较低` |
| 🔧 灵活性 | `⭐⭐⭐⭐⭐` | `⭐⭐⭐☆☆` | `⭐⭐⭐⭐☆` |
| 📝 代码量 | `中等` | `较多` | `最少` |
| 🛠️ 维护性 | `好` | `中等` | `好` |
| 💼 企业应用 | `主流` | `传统` | `快速开发` |

### 8.2 必须掌握的核心知识


**🔸 基础配置三要素**：
```
1. 组件扫描 → 找到Controller
   @ComponentScan / <context:component-scan>
   
2. 视图解析器 → 返回页面
   ViewResolver配置
   
3. 静态资源 → 访问CSS/JS
   addResourceHandlers / <mvc:resources>
```

**🔸 WebMvcConfigurer核心方法**：
```
┌─ 必会配置方法 ─────────────┐
│                          │
│ addInterceptors()        │ ← 拦截器
│ addResourceHandlers()    │ ← 静态资源
│ addCorsMappings()        │ ← 跨域
│ configureViewResolvers() │ ← 视图解析
│                          │
└──────────────────────────┘
```

### 8.3 实战经验总结


**💡 最佳实践**：

**1. 配置分离原则**
```java
// ✅ 推荐：按功能分离
@Configuration
@Import({
    WebConfig.class,      // Web配置
    SecurityConfig.class, // 安全配置
    DataConfig.class      // 数据配置
})
public class AppConfig {}

// ❌ 不推荐：所有配置混在一起
@Configuration
public class MassiveConfig {
    // 上百行配置代码...
}
```

**2. 环境配置管理**
```
开发技巧：
- 敏感信息（密码）使用环境变量
- 公共配置提取到父配置文件
- Profile命名清晰：dev/test/prod
- 测试环境尽量接近生产环境
```

**3. 配置优先级理解**
```
记忆口诀：
"手动Bean最优先，接口配置次一级，
 注解默认最后用，命令参数压一切"

实际顺序：
@Bean方法 > WebMvcConfigurer > @EnableWebMvc默认 > 命令行参数覆盖全部
```

### 8.4 常见问题与解决


**❓ 问题1：配置不生效**
```
检查清单：
☐ @Configuration注解是否添加
☐ 配置类是否被扫描到
☐ Profile是否激活正确
☐ 配置优先级是否被覆盖
```

**❓ 问题2：静态资源404**
```
解决步骤：
1. 检查路径配置是否正确
2. 确认文件确实存在
3. 查看是否被拦截器拦截
4. 验证DispatcherServlet映射
```

**❓ 问题3：视图解析失败**
```
排查方向：
1. 检查前缀后缀配置
2. 确认视图文件位置
3. 验证ViewResolver顺序
4. 查看是否有多个解析器冲突
```

### 8.5 进阶学习路线


**📚 学习路径**：
```
阶段1：掌握基础配置（当前）
  ├─ 三种配置方式
  ├─ WebMvcConfigurer使用
  └─ 环境配置管理
  
阶段2：深入源码理解
  ├─ DispatcherServlet初始化
  ├─ @EnableWebMvc工作原理
  └─ 配置加载机制
  
阶段3：性能优化实战
  ├─ 拦截器性能优化
  ├─ 静态资源缓存策略
  └─ 异步请求处理配置
```

**🎯 学习建议**：
- 🟦 **初学者**：从注解配置开始，快速上手
- 🟨 **进阶者**：掌握Java配置，理解配置原理
- 🟫 **高级者**：研究源码，自定义配置扩展

---

## 🧠 记忆要点


**核心记忆口诀**：
```
三种配置各有用，Java注解XML分工
WebMvcConfigurer是核心，方法重写定制行
环境配置Profile管，开发测试生产分
优先级别要记牢，手动Bean最优先
```

**关键概念速记**：
- **@EnableWebMvc** = 开启MVC全功能
- **WebMvcConfigurer** = MVC定制接口
- **@Profile** = 环境切换开关
- **@Bean优先级最高** = 手动配置优先