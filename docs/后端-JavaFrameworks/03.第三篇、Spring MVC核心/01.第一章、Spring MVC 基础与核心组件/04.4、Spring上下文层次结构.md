---
title: 4、Spring上下文层次结构
---
## 📚 目录

1. [什么是上下文层次结构](#1-什么是上下文层次结构)
2. [ContextLoaderListener详解](#2-contextloaderlistener详解)
3. [Root WebApplicationContext根容器](#3-root-webapplicationcontext根容器)
4. [Servlet WebApplicationContext子容器](#4-servlet-webapplicationcontext子容器)
5. [父子容器关系深度理解](#5-父子容器关系深度理解)
6. [Bean查找机制](#6-bean查找机制)
7. [上下文启动顺序](#7-上下文启动顺序)
8. [多模块应用架构](#8-多模块应用架构)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌳 什么是上下文层次结构


### 1.1 先理解"上下文"是什么


**🔸 上下文的本质**
```
通俗理解：
上下文(Context) = Spring的"大管家"

就像一个大型公司：
- 需要一个总管理部门（Root上下文）
- 每个业务部门有自己的小管家（Servlet上下文）
- 小管家遇到解决不了的问题，找总管家帮忙
```

**💡 为什么需要上下文？**
- 管理所有的Bean（Spring创建的对象）
- 提供配置信息
- 协调各个组件工作
- 提供依赖注入能力

### 1.2 什么是"层次结构"


**🔸 层次结构的含义**

```
简单比喻：
就像家庭关系树：

        爷爷奶奶（Root容器）
           ↓
      父母（Servlet容器）
           ↓
      子女（具体的Bean）

- 子女找不到的东西，找父母
- 父母找不到的东西，找爷爷奶奶
- 但爷爷奶奶不能用子女的东西（单向查找）
```

**📊 Spring MVC的层次结构**

```
┌──────────────────────────────────┐
│   Root WebApplicationContext     │  ← 父容器（全局）
│   管理：Service、DAO、数据源等    │
└──────────────────────────────────┘
                ↑
                │ 父子关系
                ↓
┌──────────────────────────────────┐
│ Servlet WebApplicationContext    │  ← 子容器（Web层）
│ 管理：Controller、视图解析器等    │
└──────────────────────────────────┘
```

**🎯 为什么要分两层？**

| 设计原因 | 说明 | 实际好处 |
|---------|------|---------|
| **职责分离** | 业务逻辑和Web层分开 | 代码更清晰，易维护 |
| **资源共享** | 业务层可被多个Web层共用 | 避免重复创建对象 |
| **模块隔离** | Web层不能影响业务层 | 更安全，更稳定 |
| **便于测试** | 业务逻辑可独立测试 | 不依赖Web环境 |

---

## 2. 🎬 ContextLoaderListener详解


### 2.1 ContextLoaderListener是什么


**🔸 核心定义**
```
ContextLoaderListener = Spring的"开机启动程序"

职责：在Web应用启动时，创建和初始化Root容器

通俗理解：
就像电脑开机时自动启动的后台程序，
它在Web应用启动时，把Spring的根容器启动起来。
```

### 2.2 工作原理


**⚙️ 启动流程**

```
Web应用启动
    ↓
Tomcat加载web.xml配置
    ↓
发现ContextLoaderListener监听器
    ↓
触发contextInitialized事件
    ↓
ContextLoaderListener开始工作：
    1. 读取spring配置文件位置
    2. 创建Root WebApplicationContext
    3. 加载业务层Bean（Service、DAO等）
    4. 将Root容器存入ServletContext
    ↓
Root容器创建完成，等待使用
```

### 2.3 配置示例


**📝 web.xml配置方式**

```xml
<!-- 1. 指定Spring配置文件位置 -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>

<!-- 2. 配置监听器 -->
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>
```

**💡 配置说明**
- `contextConfigLocation`：告诉Spring去哪找配置文件
- `ContextLoaderListener`：负责启动Root容器的监听器
- 如果不指定位置，默认找：`/WEB-INF/applicationContext.xml`

### 2.4 关键特性


**🔑 核心特点**

| 特性 | 说明 | 作用 |
|-----|------|-----|
| **全局唯一** | 一个Web应用只有一个Root容器 | 避免重复创建 |
| **优先启动** | 在Servlet之前初始化 | 保证业务层先准备好 |
| **长期存活** | 应用运行期间一直存在 | 提供持续服务 |
| **全局可访问** | 存储在ServletContext中 | 任何地方都能获取 |

---

## 3. 🌍 Root WebApplicationContext根容器


### 3.1 根容器的定位


**🔸 什么是Root容器**
```
Root容器 = Spring的"中央仓库"

管理内容：
- Service层：业务逻辑处理
- DAO层：数据库访问
- 数据源：数据库连接池
- 事务管理器：管理数据库事务
- 其他基础设施Bean

不管理：
- Controller：属于Web层
- 视图解析器：属于Web层
```

### 3.2 管理的Bean类型


**📦 典型Bean清单**

```
Root容器管理的Bean：

🔹 业务服务层
   UserService -----> 处理用户业务逻辑
   OrderService ----> 处理订单业务逻辑
   
🔹 数据访问层
   UserDAO ---------> 访问用户表
   OrderDAO --------> 访问订单表
   
🔹 基础设施
   DataSource ------> 数据库连接池
   TransactionManager -> 事务管理
   
🔹 工具类
   EmailService ----> 发送邮件
   CacheManager ----> 缓存管理
```

### 3.3 生命周期


**⏰ 存活时间线**

```
Web应用启动 ━━━━━━━━━━━━━━━━━━━━ Web应用关闭
              ↑                    ↑
          Root容器创建          Root容器销毁
              
整个应用运行期间，Root容器一直存在
```

### 3.4 配置文件示例


**📄 applicationContext.xml典型配置**

```xml
<!-- 业务层Bean -->
<bean id="userService" class="com.example.service.UserService">
    <property name="userDAO" ref="userDAO"/>
</bean>

<!-- 数据访问层Bean -->
<bean id="userDAO" class="com.example.dao.UserDAO">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- 数据源配置 -->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="123456"/>
</bean>

<!-- 事务管理器 -->
<bean id="transactionManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

---

## 4. 🌐 Servlet WebApplicationContext子容器


### 4.1 子容器的定位


**🔸 什么是Servlet容器**
```
Servlet容器 = Spring MVC的"前台服务部门"

管理内容：
- Controller：处理Web请求
- 视图解析器：处理页面渲染
- 拦截器：请求拦截处理
- 参数解析器：处理请求参数
- 异常处理器：处理Web异常

依赖Root容器：
需要调用Service时，从Root容器获取
```

### 4.2 创建方式


**⚙️ DispatcherServlet启动创建**

```xml
<!-- web.xml配置 -->
<servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

**💡 配置说明**
- `DispatcherServlet`：Spring MVC的核心Servlet
- `contextConfigLocation`：指定MVC配置文件
- `load-on-startup`：启动时就初始化（而不是第一次访问时）

### 4.3 管理的Bean类型


**📦 典型Bean清单**

```
Servlet容器管理的Bean：

🔹 控制器层
   UserController -----> 处理用户相关请求
   OrderController ----> 处理订单相关请求
   
🔹 视图处理
   ViewResolver -------> 解析视图名称
   
🔹 请求处理
   HandlerMapping -----> URL映射
   HandlerAdapter -----> 处理器适配
   
🔹 拦截器
   LoginInterceptor ---> 登录拦截
   LogInterceptor -----> 日志记录
```

### 4.4 配置文件示例


**📄 spring-mvc.xml典型配置**

```xml
<!-- 启用注解驱动 -->
<mvc:annotation-driven/>

<!-- 扫描Controller -->
<context:component-scan base-package="com.example.controller"/>

<!-- 视图解析器 -->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/"/>
    <property name="suffix" value=".jsp"/>
</bean>

<!-- 拦截器配置 -->
<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/**"/>
        <bean class="com.example.interceptor.LoginInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>
```

---

## 5. 👨‍👦 父子容器关系深度理解


### 5.1 父子关系的本质


**🔸 关系特点**

```
父容器（Root）         子容器（Servlet）
     ↑                      ↓
     └──────────单向依赖─────┘

关键规则：
✅ 子容器可以访问父容器的Bean
❌ 父容器不能访问子容器的Bean
```

**💡 为什么是单向关系？**

```
设计考虑：

场景1：Controller需要调用Service
     Controller（子容器）→ Service（父容器）✅
     这是正常的，Web层调用业务层

场景2：Service需要调用Controller  
     Service（父容器）→ Controller（子容器）❌
     这是不合理的，业务层不应该依赖Web层
```

### 5.2 实际工作示例


**🔄 请求处理流程**

```
用户访问 /user/list
         ↓
    DispatcherServlet接收请求
         ↓
    查找UserController（在子容器中）
         ↓
    UserController.listUsers()执行
         ↓
    需要调用UserService
         ↓
    从子容器查找 → 找不到
         ↓
    向上查找父容器 → 找到UserService
         ↓
    注入UserService到Controller
         ↓
    执行业务逻辑
         ↓
    返回结果
```

### 5.3 容器关系图解


**📊 完整结构图**

```
ServletContext（Web应用全局对象）
    │
    ├─ 存储 Root WebApplicationContext
    │       │
    │       ├── UserService
    │       ├── OrderService  
    │       ├── UserDAO
    │       └── DataSource
    │
    └─ 存储 Servlet WebApplicationContext
            │  (设置parent指向Root容器)
            │
            ├── UserController
            ├── OrderController
            └── ViewResolver
```

### 5.4 隔离性的好处


**✨ 设计优势**

| 优势 | 说明 | 实际效果 |
|-----|------|---------|
| **避免循环依赖** | Service不能引用Controller | 架构更清晰 |
| **职责明确** | Web层和业务层各司其职 | 代码更规范 |
| **便于测试** | Service可脱离Web环境测试 | 提高测试效率 |
| **支持多前端** | 同一业务层可服务多个Web层 | 架构更灵活 |

---

## 6. 🔍 Bean查找机制


### 6.1 查找规则


**🔸 核心查找逻辑**

```
步骤流程：

1️⃣ 先在当前容器中查找
   ├─ 找到了 → 直接使用 ✅
   └─ 没找到 → 继续下一步

2️⃣ 如果有父容器，向父容器查找  
   ├─ 找到了 → 使用父容器的Bean ✅
   └─ 没找到 → 继续向上查找

3️⃣ 所有容器都找不到
   └─ 抛出NoSuchBeanDefinitionException ❌
```

### 6.2 实际查找案例


**📝 案例1：Controller注入Service**

```java
// UserController在子容器中
@Controller
public class UserController {
    
    @Autowired
    private UserService userService;  // 需要注入Service
    
    // 查找过程：
    // 1. 在子容器(Servlet容器)找UserService → 找不到
    // 2. 向上查找父容器(Root容器) → 找到了！
    // 3. 将Root容器的UserService注入到Controller
}
```

**📝 案例2：Service之间互相注入**

```java
// UserService在父容器中
@Service
public class UserService {
    
    @Autowired
    private OrderService orderService;  // 需要注入另一个Service
    
    // 查找过程：
    // 1. 在当前容器(Root容器)找OrderService → 找到了！
    // 2. 直接注入，无需向上查找
}
```

### 6.3 常见问题场景


**⚠️ 问题1：Bean重复定义**

```
问题描述：
在Root容器和Servlet容器都配置了UserService

结果：
- 子容器会优先使用自己的UserService
- 不会使用父容器的（就近原则）

建议：
避免在两个容器中定义相同的Bean
```

**⚠️ 问题2：扫描包重叠**

```xml
<!-- Root容器配置 -->
<context:component-scan base-package="com.example"/>

<!-- Servlet容器配置 -->  
<context:component-scan base-package="com.example.controller"/>

问题：
Root容器会扫描所有包，包括controller
导致Controller被两个容器都创建

解决：
Root容器排除controller包
<context:component-scan base-package="com.example">
    <context:exclude-filter type="annotation" 
                           expression="org.springframework.stereotype.Controller"/>
</context:component-scan>
```

---

## 7. ⏱️ 上下文启动顺序


### 7.1 启动时序图


**📋 完整启动流程**

```
Tomcat启动
    ↓
加载web.xml配置
    ↓
【第一步】ContextLoaderListener初始化
    ├─ 读取contextConfigLocation参数
    ├─ 加载applicationContext.xml
    ├─ 创建Root WebApplicationContext
    ├─ 初始化Service、DAO等Bean
    └─ 将Root容器存入ServletContext
    ↓
【第二步】DispatcherServlet初始化
    ├─ 读取spring-mvc.xml配置
    ├─ 创建Servlet WebApplicationContext  
    ├─ 设置parent为Root容器
    ├─ 初始化Controller等Bean
    └─ 将Servlet容器注册到DispatcherServlet
    ↓
【第三步】应用启动完成
    └─ 开始接收和处理请求
```

### 7.2 启动顺序的重要性


**🎯 为什么顺序很重要？**

```
正确顺序：Root容器 → Servlet容器

原因1：依赖关系
Controller需要Service，必须先有Service

原因2：父子关系
子容器需要引用父容器，必须先创建父容器

原因3：配置加载
全局配置(数据源、事务)要先准备好
```

### 7.3 启动参数配置


**⚙️ load-on-startup作用**

```xml
<servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
```

**💡 参数说明**

| 值 | 含义 | 效果 |
|---|------|------|
| **负数或不配置** | 第一次请求时初始化 | 首次访问慢 |
| **0或正数** | 启动时就初始化 | 提前加载，首次访问快 |
| **数字大小** | 多个Servlet的加载顺序 | 数字小的先加载 |

---

## 8. 🏢 多模块应用架构


### 8.1 典型架构设计


**🔸 企业级应用结构**

```
大型Web应用架构：

┌─────────────────────────────────────┐
│     Root WebApplicationContext      │
│                                     │
│  ┌─────────────────────────────┐  │
│  │    核心业务模块              │  │
│  │  - UserService               │  │
│  │  - OrderService              │  │
│  │  - ProductService            │  │
│  └─────────────────────────────┘  │
│                                     │
│  ┌─────────────────────────────┐  │
│  │    数据访问模块              │  │
│  │  - UserDAO                   │  │
│  │  - OrderDAO                  │  │
│  └─────────────────────────────┘  │
│                                     │
│  ┌─────────────────────────────┐  │
│  │    基础设施模块              │  │
│  │  - DataSource                │  │
│  │  - TransactionManager        │  │
│  │  - CacheManager              │  │
│  └─────────────────────────────┘  │
└─────────────────────────────────────┘
                ↑
                │ 父容器
                ↓
┌─────────────────────────────────────┐
│   Servlet WebApplicationContext     │
│                                     │
│  ┌──────────────┐  ┌──────────────┐│
│  │  前台模块     │  │  后台模块     ││
│  │ UserController│  │AdminController││
│  └──────────────┘  └──────────────┘│
└─────────────────────────────────────┘
```

### 8.2 多Servlet配置


**📝 配置多个DispatcherServlet**

```xml
<!-- 前台Servlet -->
<servlet>
    <servlet-name>front</servlet-name>
    <servlet-class>DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc-front.xml</param-value>
    </init-param>
</servlet>
<servlet-mapping>
    <servlet-name>front</servlet-name>
    <url-pattern>/front/*</url-pattern>
</servlet-mapping>

<!-- 后台Servlet -->
<servlet>
    <servlet-name>admin</servlet-name>
    <servlet-class>DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc-admin.xml</param-value>
    </init-param>
</servlet>
<servlet-mapping>
    <servlet-name>admin</servlet-name>
    <url-pattern>/admin/*</url-pattern>
</servlet-mapping>
```

**🌳 容器层次结构**

```
            Root容器
          (共享业务层)
               ↑
        ┌──────┴──────┐
        │             │
   Front容器      Admin容器
  (前台Controller) (后台Controller)
```

### 8.3 模块化的优势


**✨ 架构优势**

| 优势 | 说明 | 实际价值 |
|-----|------|---------|
| **业务复用** | Service只需要一份 | 减少重复代码 |
| **职责清晰** | 前后台分离管理 | 便于团队协作 |
| **独立部署** | 可以分开部署更新 | 降低风险 |
| **性能优化** | 不同模块可独立调优 | 提升效率 |

### 8.4 实际应用场景


**🎯 典型使用场景**

```
场景1：电商平台
├─ Root容器：商品、订单、用户等核心业务
├─ 前台Servlet：用户购物、浏览商品  
└─ 后台Servlet：商家管理、订单处理

场景2：内容管理系统
├─ Root容器：文章、评论、用户管理
├─ 网站Servlet：前台展示
└─ 管理Servlet：后台编辑

场景3：移动应用后端
├─ Root容器：核心业务逻辑
├─ API Servlet：RESTful接口
└─ Web Servlet：管理后台
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的概念


**🔸 关键知识点**

```
1️⃣ 两个容器的定位
   Root容器 = 业务层管家（Service、DAO、数据源）
   Servlet容器 = Web层管家（Controller、视图解析器）

2️⃣ 父子关系特点
   子容器可访问父容器 ✅
   父容器不能访问子容器 ❌
   
3️⃣ 启动顺序
   Root容器先启动 → Servlet容器后启动
   
4️⃣ Bean查找规则
   先找自己 → 找不到找父亲 → 都找不到报错
```

### 9.2 配置要点对照


**📊 配置检查清单**

| 配置项 | Root容器 | Servlet容器 |
|-------|---------|------------|
| **配置文件** | applicationContext.xml | spring-mvc.xml |
| **加载方式** | ContextLoaderListener | DispatcherServlet |
| **扫描范围** | service、dao包 | controller包 |
| **管理Bean** | Service、DAO、数据源 | Controller、拦截器 |

### 9.3 常见问题速查


**❓ 问题解决指南**

```
问题1：Controller注入Service失败
原因：Root容器没有启动或配置错误
解决：检查ContextLoaderListener配置

问题2：Service注入Controller失败  
原因：父容器不能访问子容器
解决：重新设计，不应该这样依赖

问题3：Bean被创建两次
原因：两个容器都扫描了同一个包
解决：明确划分扫描范围，互相排除

问题4：启动顺序错误
原因：load-on-startup配置不当
解决：确保DispatcherServlet的值≥1
```

### 9.4 最佳实践建议


**✨ 开发建议**

```
推荐做法：

1. 明确职责划分
   Root容器：业务和数据访问
   Servlet容器：仅Web相关

2. 避免重复扫描
   Root容器：排除@Controller
   Servlet容器：只扫描@Controller

3. 统一配置管理  
   数据源、事务等基础配置放Root容器
   
4. 按模块组织
   大型应用考虑多Servlet架构
```

**🧠 记忆口诀**

```
父子容器要分清，Root业务Servlet控制层
子找父来父不理，单向依赖记心间
先有父来后有子，启动顺序不能乱
Bean查找先己后父，找不到时就报错
```