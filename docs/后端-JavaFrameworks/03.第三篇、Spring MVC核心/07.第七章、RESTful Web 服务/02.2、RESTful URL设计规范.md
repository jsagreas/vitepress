---
title: 2、RESTful URL设计规范
---
## 📚 目录

1. [RESTful基础概念](#1-RESTful基础概念)
2. [资源命名规范](#2-资源命名规范)
3. [URL路径设计原则](#3-URL路径设计原则)
4. [HTTP方法的正确使用](#4-HTTP方法的正确使用)
5. [资源层次结构设计](#5-资源层次结构设计)
6. [查询参数的使用场景](#6-查询参数的使用场景)
7. [版本控制策略](#7-版本控制策略)
8. [HTTP状态码规范](#8-HTTP状态码规范)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 RESTful基础概念


### 1.1 什么是RESTful


> 📖 **核心理解**  
> RESTful是一种Web服务的设计风格，它把网络上的一切内容都看作"资源"，通过URL来定位资源，用HTTP方法来操作资源

**💡 生活类比**
```
想象一个图书馆系统：
- 每本书是一个资源 📚
- 书的位置（书架号）就是URL 
- 借书、还书、查询就是HTTP方法

传统方式：
/getBook?id=123        获取书籍
/addBook               添加书籍
/deleteBook?id=123     删除书籍

RESTful方式：
GET    /books/123      获取书籍
POST   /books          添加书籍  
DELETE /books/123      删除书籍

看出区别了吗？RESTful用URL表示资源，用方法表示操作！
```

### 1.2 REST的核心原则


**🎯 REST六大原则**

① **资源导向（Resource-Based）**
```
一切皆资源：用户、订单、商品都是资源
每个资源有唯一标识：通过URL访问
资源有表现形式：JSON、XML等格式
```

② **统一接口（Uniform Interface）**
```
使用标准HTTP方法操作资源：
GET    → 获取资源
POST   → 创建资源
PUT    → 完整更新资源
PATCH  → 部分更新资源
DELETE → 删除资源
```

③ **无状态（Stateless）**
```
服务器不保存客户端状态
每次请求都是独立的
请求包含所有必要信息（如认证令牌）
```

④ **可缓存（Cacheable）**
```
响应可以标记为可缓存或不可缓存
客户端可以复用缓存数据
提升性能和可扩展性
```

---

## 2. 📝 资源命名规范


### 2.1 资源命名基本规则


> ⚠️ **重要原则**  
> URL应该表示资源（名词），而不是操作（动词）

**✅ 推荐做法**
```
使用名词复数表示资源集合：
/users          用户列表
/products       商品列表
/orders         订单列表

使用名词单数表示特定资源：
/users/123      特定用户
/products/456   特定商品
```

**❌ 避免做法**
```
不要在URL中使用动词：
/getUser        ❌ 错误
/createOrder    ❌ 错误  
/deleteProduct  ❌ 错误

应该改为：
GET    /users/123     ✅ 正确
POST   /orders        ✅ 正确
DELETE /products/456  ✅ 正确
```

### 2.2 命名风格规范


**🔤 统一使用小写字母**
```
✅ 推荐：
/api/users
/api/product-categories

❌ 避免：
/api/Users           大小写混用
/api/ProductCategories  驼峰命名
```

**🔗 单词分隔符选择**

| 分隔方式 | 示例 | 推荐度 | 说明 |
|---------|------|--------|------|
| **短横线** | `/product-categories` | ⭐⭐⭐⭐⭐ | 最推荐，URL友好 |
| **下划线** | `/product_categories` | ⭐⭐⭐ | 可用，但不如短横线 |
| **驼峰** | `/productCategories` | ❌ | 不推荐，易混淆 |

**💡 记忆技巧**：就像写英文地址一样，用短横线连接单词

---

## 3. 🛣️ URL路径设计原则


### 3.1 路径层次设计


**📊 路径层次示例**
```
基础结构：
/资源集合             获取所有资源
/资源集合/ID          获取特定资源
/资源集合/ID/子资源   获取特定资源的子资源

实际案例：
GET /users                    所有用户
GET /users/123                用户123的信息
GET /users/123/orders         用户123的所有订单
GET /users/123/orders/456     用户123的订单456
```

### 3.2 资源关系表达


**🔗 表达资源间关系的方式**

① **嵌套路径（推荐用于强关联）**
```
用户的订单：
GET /users/123/orders

订单的商品：
GET /orders/456/items

适用场景：
- 子资源强依赖父资源
- 需要在父资源上下文中访问子资源
```

② **独立路径 + 查询参数（推荐用于弱关联）**
```
查询用户的订单：
GET /orders?user_id=123

查询分类的商品：
GET /products?category_id=5

适用场景：
- 子资源可以独立存在
- 需要灵活的查询条件
```

**🎯 选择建议**
```
强关联关系 → 使用嵌套路径
    /users/123/addresses/1

弱关联关系 → 使用查询参数
    /products?category=electronics

多对多关系 → 优先查询参数
    /courses?student_id=123
```

---

## 4. ⚡ HTTP方法的正确使用


### 4.1 标准HTTP方法语义


**📋 核心方法对比**

| 方法 | 用途 | 幂等性 | 安全性 | 常见场景 |
|------|------|--------|--------|----------|
| **GET** | 获取资源 | ✅ 是 | ✅ 是 | 查询数据 |
| **POST** | 创建资源 | ❌ 否 | ❌ 否 | 提交表单 |
| **PUT** | 完整更新 | ✅ 是 | ❌ 否 | 替换资源 |
| **PATCH** | 部分更新 | ❌ 否 | ❌ 否 | 修改字段 |
| **DELETE** | 删除资源 | ✅ 是 | ❌ 否 | 删除数据 |

> 💡 **概念解释**  
> **幂等性**：多次执行相同操作，结果一样  
> **安全性**：不会修改服务器资源状态

### 4.2 GET - 获取资源


**✅ 正确用法**
```
获取单个资源：
GET /users/123

获取资源集合：
GET /users

带条件查询：
GET /users?role=admin&status=active
```

**❌ 常见错误**
```
不要用GET修改数据：
GET /users/123/delete    ❌ 违反安全性原则
GET /orders/456/approve  ❌ 应该用POST或PUT
```

### 4.3 POST - 创建资源


**✅ 正确用法**
```java
// 创建新用户
POST /users
Content-Type: application/json

{
  "username": "john",
  "email": "john@example.com"
}

// 响应
HTTP/1.1 201 Created
Location: /users/123

{
  "id": 123,
  "username": "john",
  "email": "john@example.com"
}
```

**💡 POST的特殊场景**
```
复杂查询（查询条件太多）：
POST /users/search
{
  "filters": {...},
  "sort": {...}
}

非标准操作：
POST /orders/123/cancel    取消订单
POST /users/123/activate   激活用户
```

### 4.4 PUT vs PATCH - 更新资源


**🔄 PUT - 完整替换**
```java
PUT /users/123
{
  "username": "john",
  "email": "newemail@example.com",
  "age": 30,
  "address": "New York"
}

特点：
- 必须提供完整的资源数据
- 未提供的字段会被清空或设为默认值
- 幂等：多次执行结果相同
```

**🔧 PATCH - 部分更新**
```java
PATCH /users/123
{
  "email": "newemail@example.com"
}

特点：
- 只需提供要修改的字段
- 其他字段保持不变
- 更灵活，减少数据传输
```

**🎯 选择建议**
```
更新整个资源 → PUT
    PUT /users/123 {完整用户数据}

只改几个字段 → PATCH  
    PATCH /users/123 {"email": "new@email.com"}

记忆口诀：
PUT = 全部替换（Put all）
PATCH = 打补丁（只修改一部分）
```

### 4.5 DELETE - 删除资源


**✅ 正确用法**
```
删除单个资源：
DELETE /users/123

返回：
HTTP/1.1 204 No Content

或：
HTTP/1.1 200 OK
{
  "message": "User deleted successfully"
}
```

**💡 软删除处理**
```
逻辑删除（推荐）：
PATCH /users/123
{
  "status": "deleted"
}

物理删除（谨慎使用）：
DELETE /users/123
```

---

## 5. 🏗️ 资源层次结构设计


### 5.1 扁平化 vs 深层嵌套


**🎯 设计原则**
```
URL层级控制在 2-3 层
避免过深的嵌套路径
保持简洁和可读性
```

**✅ 推荐的层次设计**
```
2层结构（最常见）：
/resources/id
/users/123
/products/456

3层结构（合理）：
/resources/id/sub-resources
/users/123/orders
/posts/456/comments
```

**❌ 避免的深层嵌套**
```
/users/123/orders/456/items/789/reviews/111   ❌ 太深了

应该改为：
/reviews/111                                   ✅ 直接访问
或
/orders/456/items/789/reviews                  ✅ 减少层级
```

### 5.2 复杂关系处理


**场景1：多对多关系**
```
学生选课系统：

方式1 - 从学生角度：
GET /students/123/courses      学生123的所有课程

方式2 - 从课程角度：
GET /courses/456/students      课程456的所有学生

方式3 - 独立资源：
GET /enrollments?student_id=123
GET /enrollments?course_id=456
```

**场景2：跨资源操作**
```
用户收藏商品：

添加收藏：
POST /users/123/favorites
{
  "product_id": 456
}

查看收藏：
GET /users/123/favorites

取消收藏：
DELETE /users/123/favorites/456
```

---

## 6. 🔍 查询参数的使用场景


### 6.1 过滤（Filtering）


**📊 基本过滤**
```
单条件过滤：
GET /products?category=electronics

多条件过滤：
GET /products?category=electronics&price_min=100&price_max=500

状态过滤：
GET /orders?status=pending&date_from=2024-01-01
```

### 6.2 排序（Sorting）


**🔄 排序参数设计**
```
单字段排序：
GET /users?sort=created_at        默认升序
GET /users?sort=-created_at       降序（用-号）

多字段排序：
GET /products?sort=price,-rating  价格升序，评分降序

参数格式规范：
sort=field           升序
sort=-field          降序
sort=field1,-field2  组合排序
```

### 6.3 分页（Pagination）


**📄 分页方案对比**

**方式1：基于偏移量（Offset-based）**
```
GET /users?page=2&size=20

优点：
- 简单直观
- 可以跳转到任意页

缺点：
- 数据变化时可能重复或遗漏
- 大偏移量性能差
```

**方式2：基于游标（Cursor-based）**
```
GET /users?cursor=xxx&limit=20

响应：
{
  "data": [...],
  "next_cursor": "yyy"
}

优点：
- 性能稳定
- 适合实时数据

缺点：
- 不能跳页
- 实现稍复杂
```

**💡 选择建议**
```
普通列表查询 → Offset分页
    GET /users?page=1&size=20

实时数据流 → Cursor分页  
    GET /feeds?cursor=xxx&limit=20

搜索结果 → Offset分页
    GET /search?q=keyword&page=1
```

### 6.4 字段筛选（Fields Selection）


**🎯 减少数据传输**
```
只获取需要的字段：
GET /users/123?fields=id,username,email

排除敏感字段：
GET /users/123?exclude=password,secret_key

嵌套资源控制：
GET /posts/123?fields=title,author.name,comments.count
```

### 6.5 搜索（Searching）


**🔎 搜索参数设计**
```
简单搜索：
GET /products?q=laptop

高级搜索：
GET /products?search={"name":"laptop","category":"electronics"}

全文搜索：
GET /articles?q=spring boot&fields=title,content
```

---

## 7. 🔄 版本控制策略


### 7.1 为什么需要版本控制


> 💡 **核心原因**  
> API会不断演进，版本控制确保旧客户端继续工作，同时支持新功能

**实际场景**
```
版本1：用户只有姓名
{
  "name": "John Doe"
}

版本2：拆分为姓和名
{
  "first_name": "John",
  "last_name": "Doe"
}

没有版本控制 → 所有旧客户端崩溃 💥
有版本控制 → 新旧客户端共存 ✅
```

### 7.2 版本控制方案对比


**方案1：URL路径版本（推荐）⭐⭐⭐⭐⭐**
```
GET /v1/users
GET /v2/users

优点：
- 清晰直观
- 易于路由和缓存
- 最常用的方案

缺点：
- URL变化较大
```

**方案2：请求头版本 ⭐⭐⭐**
```
GET /users
Accept: application/vnd.company.v1+json

优点：
- URL保持不变
- 符合HTTP规范

缺点：
- 不够直观
- 测试和调试不便
```

**方案3：查询参数版本 ⭐⭐**
```
GET /users?version=1

优点：
- 实现简单

缺点：
- 语义不清晰
- 容易被忽略
```

**💡 推荐做法**
```
新项目 → URL路径版本
    /api/v1/users
    /api/v2/users

特殊场景 → 请求头版本
    需要精细控制时使用

避免使用 → 查询参数版本
    语义不明确
```

### 7.3 版本演进策略


**🔄 向后兼容原则**
```
✅ 可以做的改动：
- 添加新字段
- 添加新端点
- 添加可选参数

❌ 不兼容的改动：
- 删除字段
- 修改字段类型
- 修改URL路径

不兼容改动 → 发布新版本
```

**版本生命周期管理**
```
开发阶段：
/api/v1/...           稳定版本
/api/v2-beta/...      测试版本

弃用流程：
1. 发布新版本 v2
2. 标记旧版本 v1 为弃用（6-12个月过渡期）
3. 停止支持 v1

响应头提示：
HTTP/1.1 200 OK
Warning: 299 - "API v1 is deprecated, please migrate to v2"
```

---

## 8. 📊 HTTP状态码规范


### 8.1 状态码分类


**🎯 五大类别**
```
1xx 信息响应 → 少用
2xx 成功响应 → 重点
3xx 重定向   → 了解
4xx 客户端错误 → 重点
5xx 服务器错误 → 重点
```

### 8.2 常用成功状态码（2xx）


| 状态码 | 含义 | 使用场景 | 示例 |
|--------|------|----------|------|
| **200** | `成功` | GET、PUT、PATCH成功 | `GET /users/123` |
| **201** | `已创建` | POST创建成功 | `POST /users` |
| **204** | `无内容` | DELETE成功 | `DELETE /users/123` |

**💡 实际应用**
```java
// 200 OK - 查询成功
GET /users/123
→ 200 OK
{
  "id": 123,
  "name": "John"
}

// 201 Created - 创建成功
POST /users
→ 201 Created
Location: /users/124
{
  "id": 124,
  "name": "Jane"
}

// 204 No Content - 删除成功
DELETE /users/123
→ 204 No Content
(无响应体)
```

### 8.3 常用客户端错误（4xx）


| 状态码 | 含义 | 使用场景 | 返回信息 |
|--------|------|----------|----------|
| **400** | `请求错误` | 参数格式错误 | `详细错误信息` |
| **401** | `未认证` | 缺少认证信息 | `需要登录` |
| **403** | `无权限` | 认证通过但无权限 | `权限不足` |
| **404** | `未找到` | 资源不存在 | `资源ID不存在` |
| **409** | `冲突` | 资源状态冲突 | `用户名已存在` |
| **422** | `无法处理` | 语义错误 | `业务规则违反` |

**实际错误响应示例**
```json
// 400 Bad Request
{
  "error": "Validation Failed",
  "message": "Invalid input parameters",
  "details": [
    {
      "field": "email",
      "message": "Invalid email format"
    },
    {
      "field": "age",
      "message": "Age must be greater than 0"
    }
  ]
}

// 404 Not Found
{
  "error": "Not Found",
  "message": "User with id 123 not found"
}

// 409 Conflict
{
  "error": "Conflict",
  "message": "Username 'john' already exists"
}
```

### 8.4 常用服务器错误（5xx）


| 状态码 | 含义 | 使用场景 |
|--------|------|----------|
| **500** | `服务器错误` | 未预期的错误 |
| **503** | `服务不可用` | 维护或过载 |

**💡 错误处理原则**
```
客户端问题 → 4xx
    请求格式错误 → 400
    认证失败 → 401
    权限不足 → 403
    资源不存在 → 404

服务器问题 → 5xx
    代码异常 → 500
    服务不可用 → 503
```

---

## 9. 📋 核心要点总结


### 9.1 设计原则速查


**🎯 核心记忆点**

```
✅ URL设计三大原则：
1. 名词表示资源，动词用HTTP方法
2. 使用小写字母和短横线
3. 保持简洁，避免深层嵌套

✅ HTTP方法对应关系：
GET    → 查询（安全、幂等）
POST   → 创建（不安全、非幂等）
PUT    → 全量更新（不安全、幂等）
PATCH  → 部分更新（不安全、非幂等）
DELETE → 删除（不安全、幂等）

✅ 状态码使用规则：
2xx → 成功（200查询、201创建、204删除）
4xx → 客户端错误（400、401、403、404）
5xx → 服务器错误（500、503）
```

### 9.2 快速决策指南


**🔍 URL设计决策树**
```
需要操作资源？
  ├─ 查询 → GET /resources 或 GET /resources/id
  ├─ 创建 → POST /resources
  ├─ 更新全部 → PUT /resources/id
  ├─ 更新部分 → PATCH /resources/id
  └─ 删除 → DELETE /resources/id

资源有层级关系？
  ├─ 强依赖 → /users/123/orders
  └─ 弱依赖 → /orders?user_id=123

需要过滤、排序、分页？
  └─ 使用查询参数 → ?filter=value&sort=field&page=1

API需要演进？
  └─ URL版本控制 → /v1/resources
```

### 9.3 常见场景最佳实践


**📌 实用案例对照表**

| 业务需求 | RESTful设计 | 说明 |
|---------|------------|------|
| 获取用户列表 | `GET /users` | 使用GET方法 |
| 获取单个用户 | `GET /users/123` | 资源ID在路径中 |
| 创建用户 | `POST /users` | 返回201+Location |
| 更新用户 | `PUT /users/123` | 完整替换 |
| 修改邮箱 | `PATCH /users/123` | 部分更新 |
| 删除用户 | `DELETE /users/123` | 返回204 |
| 用户的订单 | `GET /users/123/orders` | 嵌套资源 |
| 查询订单 | `GET /orders?status=pending` | 查询参数 |
| 搜索商品 | `GET /products?q=laptop` | 搜索参数 |
| 分页查询 | `GET /users?page=1&size=20` | 分页参数 |

### 9.4 避坑指南


> ⚠️ **新手常犯错误**

```
❌ 错误1：在URL中使用动词
/getUserById?id=123  
→ GET /users/123 ✅

❌ 错误2：滥用POST
POST /users/delete
→ DELETE /users/123 ✅

❌ 错误3：返回错误的状态码  
删除成功返回200
→ 应该返回204 ✅

❌ 错误4：URL层级过深
/users/123/orders/456/items/789/reviews
→ /reviews?order_item_id=789 ✅

❌ 错误5：不做版本控制
直接修改现有API
→ 发布新版本 /v2/users ✅
```

### 9.5 学习进阶路线


**📚 进阶学习建议**

```
🟢 基础阶段（当前）
✓ 理解RESTful核心概念
✓ 掌握URL设计规范  
✓ 熟悉HTTP方法和状态码

🟡 中级阶段
□ 学习HATEOAS（超媒体）
□ 掌握API安全（OAuth2、JWT）
□ 了解API网关和限流

🔴 高级阶段  
□ 微服务架构下的API设计
□ GraphQL vs REST对比
□ API文档自动化（Swagger）
```

**🧠 记忆口诀**

```
资源名词路径清，HTTP方法表操作
GET查POST增要分明，PUT全改PATCH补丁
层级不深参数活，版本控制莫忘记
状态码中藏信息，2成4客5服务器
```

---

**🎯 实践建议**

1. **从简单开始**：先设计基本的CRUD接口
2. **保持一致性**：团队统一命名和格式规范  
3. **文档先行**：用Swagger等工具记录API
4. **持续优化**：根据实际使用反馈改进设计
5. **学习经典案例**：研究GitHub、Twitter等知名API设计

记住：RESTful是一种设计风格，不是严格的规范，重要的是保持一致性和可理解性！