---
title: 3、调试与问题排查技巧
---
## 📚 目录

1. [调试与排查概述](#1-调试与排查概述)
2. [断点调试技巧](#2-断点调试技巧)
3. [日志分析方法](#3-日志分析方法)
4. [请求跟踪追踪](#4-请求跟踪追踪)
5. [性能分析诊断](#5-性能分析诊断)
6. [内存问题分析](#6-内存问题分析)
7. [网络抓包调试](#7-网络抓包调试)
8. [错误定位策略](#8-错误定位策略)
9. [常用调试工具](#9-常用调试工具)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 调试与排查概述


### 1.1 什么是调试与问题排查


**通俗理解**：就像医生给病人看病一样，当你的Spring MVC应用出现问题时，需要通过各种"检查手段"找出病因并解决。

```
生活中的类比：

汽车抛锚了 → 需要检查哪里出问题
├─ 打不着火 → 检查电瓶
├─ 发动机异响 → 检查机油
└─ 刹车失灵 → 检查刹车片

应用出问题了 → 需要调试排查
├─ 页面报错 → 查看日志
├─ 响应慢 → 性能分析
└─ 数据错误 → 断点调试
```

**核心目的**：
- 🎯 **快速定位问题**：在众多代码中找到bug所在
- 🎯 **理解运行逻辑**：搞清楚程序实际是怎么跑的
- 🎯 **验证修复效果**：确保问题真的被解决了

### 1.2 常见问题分类


| 问题类型 | **典型表现** | **排查方向** |
|---------|------------|-------------|
| 🔴 **功能性错误** | `页面500错误、数据不对` | `断点调试、日志分析` |
| 🟡 **性能问题** | `响应慢、卡顿` | `性能分析、SQL优化` |
| 🟠 **内存问题** | `内存溢出、频繁GC` | `内存分析、对象监控` |
| 🟢 **网络问题** | `接口超时、连接失败` | `网络抓包、请求跟踪` |

### 1.3 调试的基本思路


**排查问题的通用步骤**：

```
步骤1: 重现问题
   ↓
能稳定重现吗？
├─ 能 → 进入步骤2
└─ 不能 → 收集更多信息（日志、环境）
   ↓
步骤2: 收集信息
   ↓
查看错误提示、日志、用户操作
   ↓
步骤3: 假设原因
   ↓
根据信息猜测可能的原因
   ↓
步骤4: 验证假设
   ↓
通过调试手段验证猜测
   ↓
步骤5: 解决问题
   ↓
修复代码并测试
```

---

## 2. 🐛 断点调试技巧


### 2.1 什么是断点调试


**通俗解释**：断点就像给程序按下"暂停键"，让代码停在某一行，这时你可以：
- 看看变量的值是多少
- 一步一步执行，观察每一步的变化
- 判断程序是不是按你想的方式在跑

**生活类比**：
```
看电影时想看清某个细节 → 按暂停键 → 仔细观察
调试代码时想看清逻辑 → 打断点 → 查看变量
```

### 2.2 IDEA断点调试基础


**打断点的方法**：
1. 在代码行号左侧点击，出现红点 🔴
2. 右键断点可以设置条件（比如只在某个值时停）

**调试按钮含义**：

```
┌─────────────────────调试工具栏─────────────────────┐
│                                                     │
│  [▶] Resume      → 继续运行到下一个断点            │
│  [⏸] Step Over   → 执行当前行，不进入方法内部      │
│  [⏬] Step Into   → 进入方法内部看详细逻辑          │
│  [⏫] Step Out    → 跳出当前方法                    │
│  [⏹] Stop        → 停止调试                        │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 2.3 Controller调试实战


**场景：用户提交表单，数据没保存成功**

```java
@PostMapping("/user/save")
public String saveUser(@ModelAttribute User user) {
    // 第1个断点：看看接收到的数据对不对
    System.out.println("接收到的用户：" + user);
    
    // 第2个断点：看看验证逻辑有没有问题
    if (user.getAge() < 18) {
        return "error";
    }
    
    // 第3个断点：看看保存有没有成功
    userService.save(user);
    
    return "success";
}
```

**调试步骤**：
1. 在第1个断点停下 → 查看 `user` 对象的值
2. 继续执行到第2个断点 → 看看年龄判断对不对
3. 进入 `save` 方法内部 → 看看SQL有没有执行

> 💡 **新手技巧**：不确定哪里有问题时，多打几个断点，一步步排查！

### 2.4 条件断点的妙用


**什么是条件断点**：只在满足某个条件时才暂停，避免无效停顿。

**使用场景示例**：

```java
@GetMapping("/users")
public List<User> getUsers() {
    List<User> users = userService.findAll();
    
    // 问题：列表里有1000个用户，但只有id=888的有问题
    // 普通断点 → 要手动点999次"继续"
    // 条件断点 → 直接在id=888时停下
    
    for (User user : users) {
        // 右键断点，设置条件：user.getId() == 888
        processUser(user); // 只在id=888时停在这里
    }
    
    return users;
}
```

**设置方法**：
1. 右键点击断点红点
2. 输入条件：`user.getId() == 888`
3. 勾选"Condition"选项

### 2.5 远程调试技巧


**什么是远程调试**：程序跑在服务器上，但你在本地电脑上调试。

**使用场景**：
- 本地环境正常，但服务器上报错
- 只有在生产数据下才能重现的问题

**配置步骤**：

```bash
# 1. 服务器启动时加上调试参数
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar app.jar

# 参数解释：
# transport=dt_socket  → 使用socket连接
# server=y             → 作为调试服务器
# suspend=n            → 启动时不暂停（改成y则等待调试器连接后才运行）
# address=5005         → 调试端口号
```

**IDEA连接配置**：
1. Run → Edit Configurations
2. 添加 Remote JVM Debug
3. 填写服务器IP和端口（5005）
4. 点击Debug按钮连接

> ⚠️ **注意事项**：生产环境慎用！会暂停服务影响用户访问。

---

## 3. 📝 日志分析方法


### 3.1 日志是什么


**通俗理解**：日志就像程序的"日记本"，记录了程序运行过程中发生的事情。

```
人的日记：
2025年1月1日 晴
今天早上7点起床，吃了早饭，8点出门上班...

程序的日志：
2025-01-01 07:00:00 [INFO] 应用启动成功
2025-01-01 08:15:23 [INFO] 用户张三登录系统
2025-01-01 08:16:45 [ERROR] 保存数据失败：数据库连接超时
```

**日志的作用**：
- 🔍 **问题排查**：出错时知道哪里出了问题
- 📊 **运行监控**：了解系统运行状态
- 🎯 **行为分析**：分析用户操作习惯

### 3.2 日志级别详解


**五个日志级别**（从轻到重）：

| 级别 | **含义** | **使用场景** | **示例** |
|------|---------|-------------|---------|
| `DEBUG` | 调试信息 | `开发时详细调试` | `"进入saveUser方法，参数：{}"` |
| `INFO` | 一般信息 | `重要操作记录` | `"用户登录成功"` |
| `WARN` | 警告信息 | `可能有问题但不影响运行` | `"缓存未命中，查询数据库"` |
| `ERROR` | 错误信息 | `出错了但程序还能跑` | `"保存失败，数据库连接异常"` |
| `FATAL` | 致命错误 | `严重错误，程序要崩溃` | `"系统初始化失败，即将退出"` |

**生产环境建议**：
- 开发环境：`DEBUG` 级别（看到所有细节）
- 测试环境：`INFO` 级别（看到重要操作）
- 生产环境：`WARN` 级别（只看警告和错误）

### 3.3 在Spring MVC中使用日志


**引入日志框架**（以Logback为例）：

```xml
<!-- pom.xml -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.4.14</version>
</dependency>
```

**Controller中使用日志**：

```java
@RestController
@RequestMapping("/order")
public class OrderController {
    
    // 创建日志对象
    private static final Logger log = LoggerFactory.getLogger(OrderController.class);
    
    @PostMapping("/create")
    public Result createOrder(@RequestBody OrderDTO orderDTO) {
        // 记录请求信息
        log.info("收到创建订单请求，用户ID：{}，商品数量：{}", 
                 orderDTO.getUserId(), orderDTO.getItems().size());
        
        try {
            Order order = orderService.create(orderDTO);
            
            // 记录成功信息
            log.info("订单创建成功，订单号：{}", order.getOrderNo());
            
            return Result.success(order);
            
        } catch (Exception e) {
            // 记录错误信息（包含异常堆栈）
            log.error("订单创建失败，用户ID：{}", orderDTO.getUserId(), e);
            
            return Result.fail("订单创建失败");
        }
    }
}
```

> 💡 **占位符 `{}` 的妙用**：自动把变量值填进去，比字符串拼接更高效！

### 3.4 日志配置技巧


**logback.xml 配置示例**：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- 日志格式：时间 级别 类名 - 消息 -->
            <pattern>%d{HH:mm:ss.SSS} [%level] %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/app.log</file>
        <!-- 按天分割，每天一个文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/app-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory> <!-- 保留30天 -->
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%level] %logger - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 指定包的日志级别 -->
    <logger name="com.example.controller" level="DEBUG"/>
    <logger name="org.springframework" level="INFO"/>
    
    <!-- 根日志级别 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
    
</configuration>
```

**配置说明**：
- `CONSOLE` 输出到控制台（开发时方便看）
- `FILE` 输出到文件（生产环境留存）
- 不同包可以设置不同级别

### 3.5 日志分析实战


**场景：用户反馈下单失败，如何排查**

**步骤1：找到相关日志**
```bash
# 搜索用户ID相关的日志
grep "userId=12345" logs/app.log

# 或者搜索错误日志
grep "ERROR" logs/app.log | grep "order"
```

**步骤2：分析日志内容**
```
08:15:23 [INFO] OrderController - 收到创建订单请求，userId=12345
08:15:24 [DEBUG] OrderService - 开始库存检查
08:15:24 [WARN] StockService - 商品ID=888库存不足，当前库存：0
08:15:24 [ERROR] OrderController - 订单创建失败，userId=12345
  com.example.exception.StockException: 库存不足
    at com.example.service.StockService.check(StockService.java:45)
    at com.example.service.OrderService.create(OrderService.java:78)
    ...
```

**分析结论**：
1. 请求正常到达Controller
2. 进入库存检查逻辑
3. 发现商品888库存为0
4. 抛出库存不足异常

> 💡 **排查技巧**：看日志要从上往下看，找到第一个ERROR，再往上找原因！

---

## 4. 🔗 请求跟踪追踪


### 4.1 什么是请求跟踪


**通俗理解**：当用户点击一个按钮，请求在系统里经过了哪些地方？就像快递的物流信息一样，追踪请求的完整路径。

```
快递物流：
广州发货 → 途径武汉 → 到达北京 → 派送中 → 已签收

请求跟踪：
浏览器发起 → 到达Controller → 调用Service → 访问数据库 → 返回结果
```

**为什么需要请求跟踪**：
- 🎯 看看请求经过了哪些模块
- 🎯 每个模块耗时多少（找性能瓶颈）
- 🎯 出错在哪个环节

### 4.2 使用拦截器记录请求


**创建请求追踪拦截器**：

```java
public class RequestTraceInterceptor implements HandlerInterceptor {
    
    private static final Logger log = LoggerFactory.getLogger(RequestTraceInterceptor.class);
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) {
        // 生成唯一的请求ID
        String traceId = UUID.randomUUID().toString().substring(0, 8);
        request.setAttribute("traceId", traceId);
        
        // 记录请求开始
        long startTime = System.currentTimeMillis();
        request.setAttribute("startTime", startTime);
        
        log.info("[{}] 请求开始 → {} {}", 
                traceId, request.getMethod(), request.getRequestURI());
        
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, Exception ex) {
        String traceId = (String) request.getAttribute("traceId");
        long startTime = (Long) request.getAttribute("startTime");
        long endTime = System.currentTimeMillis();
        
        // 记录请求结束和耗时
        log.info("[{}] 请求结束 → 状态码：{}，耗时：{}ms", 
                traceId, response.getStatus(), (endTime - startTime));
    }
}
```

**注册拦截器**：

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new RequestTraceInterceptor())
                .addPathPatterns("/**");  // 拦截所有请求
    }
}
```

**日志效果**：
```
[a1b2c3d4] 请求开始 → POST /order/create
[a1b2c3d4] 请求结束 → 状态码：200，耗时：235ms
```

### 4.3 分布式链路追踪


**什么是分布式链路追踪**：当一个请求要调用多个微服务时，如何追踪整个调用链？

```
单体应用的请求：
用户 → Controller → Service → Dao → 数据库
（容易追踪）

分布式应用的请求：
用户 → 订单服务 → 库存服务 → 支付服务 → 物流服务
                ↓          ↓         ↓
              订单DB     库存DB    支付DB
（难以追踪，需要统一的TraceID）
```

**TraceID的作用**：

```java
// 订单服务
@GetMapping("/create")
public Result createOrder() {
    String traceId = MDC.get("traceId"); // 获取追踪ID
    
    // 调用库存服务时传递TraceID
    HttpHeaders headers = new HttpHeaders();
    headers.add("X-Trace-Id", traceId);
    
    restTemplate.exchange("http://stock-service/check", 
                         HttpMethod.POST, 
                         new HttpEntity<>(headers), 
                         String.class);
}
```

**所有服务的日志都带上相同的TraceID**：
```
[traceId=abc123] 订单服务：开始创建订单
[traceId=abc123] 库存服务：检查库存
[traceId=abc123] 支付服务：创建支付单
[traceId=abc123] 订单服务：订单创建成功
```

> 💡 **实际工具**：企业里常用SkyWalking、Zipkin等专业的链路追踪工具。

---

## 5. ⚡ 性能分析诊断


### 5.1 什么是性能问题


**通俗理解**：性能问题就是"慢"，用户等得不耐烦了。

**常见表现**：
- 页面加载超过3秒
- 点击按钮半天没反应
- 接口响应时间超过1秒

**性能问题的根源**：

```
可能的慢点：
┌─────────┐
│ 前端慢？ │ → JS执行慢、资源加载慢
├─────────┤
│ 网络慢？ │ → 带宽不足、请求太多
├─────────┤
│ 后端慢？ │ → 代码逻辑慢、数据库慢
├─────────┤
│ 数据库慢？│ → SQL慢、索引缺失
└─────────┘
```

### 5.2 定位慢的位置


**步骤1：确定慢在哪个层面**

```java
@GetMapping("/users")
public List<User> getUsers() {
    long start = System.currentTimeMillis();
    
    // 测试点1：数据库查询耗时
    long dbStart = System.currentTimeMillis();
    List<User> users = userDao.findAll();
    log.info("数据库查询耗时：{}ms", System.currentTimeMillis() - dbStart);
    
    // 测试点2：数据处理耗时
    long processStart = System.currentTimeMillis();
    users.forEach(user -> {
        user.setPassword("***"); // 隐藏密码
        user.setAvatar(cdnUrl + user.getAvatar()); // 拼接头像URL
    });
    log.info("数据处理耗时：{}ms", System.currentTimeMillis() - processStart);
    
    log.info("总耗时：{}ms", System.currentTimeMillis() - start);
    return users;
}
```

**日志输出示例**：
```
数据库查询耗时：850ms  ← 瓶颈在这里！
数据处理耗时：15ms
总耗时：865ms
```

### 5.3 常见性能问题及解决


**问题1：N+1查询问题**

```java
// ❌ 性能差的写法
@GetMapping("/orders")
public List<Order> getOrders() {
    List<Order> orders = orderDao.findAll(); // 1次查询
    
    for (Order order : orders) {
        // 每个订单都查一次用户信息，100个订单=100次查询
        User user = userDao.findById(order.getUserId());
        order.setUser(user);
    }
    return orders; // 总共101次查询！
}

// ✅ 性能好的写法
@GetMapping("/orders")
public List<Order> getOrders() {
    List<Order> orders = orderDao.findAll(); // 1次查询
    
    // 一次性查出所有用户
    List<Long> userIds = orders.stream()
        .map(Order::getUserId)
        .collect(Collectors.toList());
    
    List<User> users = userDao.findByIds(userIds); // 1次查询
    Map<Long, User> userMap = users.stream()
        .collect(Collectors.toMap(User::getId, u -> u));
    
    orders.forEach(order -> 
        order.setUser(userMap.get(order.getUserId()))
    );
    
    return orders; // 总共2次查询！
}
```

**问题2：大数据量查询**

```java
// ❌ 一次加载所有数据
@GetMapping("/users")
public List<User> getAllUsers() {
    return userDao.findAll(); // 如果有100万条数据，内存爆了！
}

// ✅ 分页查询
@GetMapping("/users")
public Page<User> getUsers(@RequestParam(defaultValue = "1") int page,
                           @RequestParam(defaultValue = "20") int size) {
    return userDao.findPage(page, size); // 每次只加载20条
}
```

### 5.4 使用Spring Boot Actuator监控


**引入依赖**：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**开启监控端点**：

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,httptrace
  endpoint:
    health:
      show-details: always
```

**访问监控信息**：
- `http://localhost:8080/actuator/health` - 健康状态
- `http://localhost:8080/actuator/metrics` - 性能指标
- `http://localhost:8080/actuator/metrics/http.server.requests` - 请求统计

**响应示例**：
```json
{
  "name": "http.server.requests",
  "measurements": [
    { "statistic": "COUNT", "value": 1523 },
    { "statistic": "TOTAL_TIME", "value": 45.6 },
    { "statistic": "MAX", "value": 2.3 }
  ]
}
```

---

## 6. 💾 内存问题分析


### 6.1 什么是内存问题


**通俗理解**：程序用的内存越来越多，最后把内存用完了，就像水杯装满了会溢出一样。

**常见内存问题**：

| 问题类型 | **表现** | **后果** |
|---------|---------|---------|
| **内存泄漏** | `内存一直增长不释放` | `最终OOM崩溃` |
| **内存溢出** | `突然申请很大内存` | `直接OOM崩溃` |
| **频繁GC** | `垃圾回收太频繁` | `系统卡顿` |

**典型错误信息**：
```
java.lang.OutOfMemoryError: Java heap space
（堆内存不够了）

java.lang.OutOfMemoryError: GC overhead limit exceeded
（GC花了太多时间，但回收的内存很少）
```

### 6.2 内存泄漏的常见原因


**原因1：静态集合类持有对象**

```java
// ❌ 危险的写法
public class UserCache {
    // 静态集合，一旦放进去就不会被GC
    private static Map<Long, User> cache = new HashMap<>();
    
    public void cacheUser(User user) {
        cache.put(user.getId(), user); // 越积越多，永不释放
    }
}

// ✅ 正确的写法：使用弱引用或定时清理
public class UserCache {
    private Map<Long, User> cache = new WeakHashMap<>(); // 内存不足时会自动清理
    
    // 或者设置过期时间
    private Map<Long, CacheEntry> cache = new HashMap<>();
    
    @Scheduled(fixedRate = 60000) // 每分钟清理一次
    public void cleanExpired() {
        cache.entrySet().removeIf(e -> e.getValue().isExpired());
    }
}
```

**原因2：未关闭资源**

```java
// ❌ 忘记关闭流
public void readFile(String path) {
    FileInputStream fis = new FileInputStream(path);
    // ... 读取文件
    // 忘记关闭，文件句柄泄漏
}

// ✅ 使用try-with-resources自动关闭
public void readFile(String path) {
    try (FileInputStream fis = new FileInputStream(path)) {
        // ... 读取文件
    } // 自动关闭
}
```

### 6.3 使用JVM工具分析内存


**查看内存使用情况**：

```bash
# jmap - 查看堆内存概况
jmap -heap <pid>

# 输出示例：
Heap Configuration:
   MinHeapFreeRatio = 40
   MaxHeapFreeRatio = 70
   MaxHeapSize      = 2147483648 (2048.0MB)
   
Heap Usage:
   New Generation (Eden + 1 Survivor):
      used = 156MB (15%)
   Old Generation:
      used = 845MB (82%)  ← 老年代占用82%，接近满了！
```

**生成堆内存快照**：

```bash
# 生成dump文件
jmap -dump:live,format=b,file=heap.dump <pid>

# 使用MAT(Memory Analyzer Tool)工具打开heap.dump分析
# 可以看到哪些对象占用内存最多
```

**查看GC情况**：

```bash
# jstat - 查看GC统计
jstat -gc <pid> 1000 10  # 每秒打印一次，共10次

# 输出示例：
S0C    S1C    S0U    S1U      EC       EU        OC         OU       YGC    YGCT    FGC    FGCT
1024   1024    0     512    8192     4096     20480      15360      45    0.120    3     0.350
                                                                    ↑          ↑
                                              Young GC次数=45    Full GC次数=3
```

### 6.4 内存优化实战


**场景：导出大量数据导致OOM**

```java
// ❌ 一次性加载所有数据
@GetMapping("/export")
public void export(HttpServletResponse response) {
    // 100万条数据，内存爆了！
    List<User> users = userDao.findAll();
    
    // 写入Excel
    ExcelWriter writer = new ExcelWriter(response.getOutputStream());
    writer.write(users);
}

// ✅ 分批处理
@GetMapping("/export")
public void export(HttpServletResponse response) {
    ExcelWriter writer = new ExcelWriter(response.getOutputStream());
    
    int pageSize = 1000;
    int page = 1;
    
    while (true) {
        List<User> users = userDao.findPage(page, pageSize);
        if (users.isEmpty()) break;
        
        writer.write(users); // 写一批
        users.clear();       // 释放内存
        page++;
    }
    
    writer.close();
}
```

---

## 7. 🌐 网络抓包调试


### 7.1 什么是网络抓包


**通俗理解**：抓包就是把网络上传输的数据"抓"下来看看，就像偷看两个人之间传递的纸条。

```
客户端 ←→ 服务器

正常情况：你看不到他们之间传了什么
抓包后：可以看到每个请求和响应的详细内容
```

**为什么需要抓包**：
- 看看请求参数有没有传对
- 看看响应数据是什么样的
- 分析接口调用是否正常

### 7.2 浏览器开发者工具


**最简单的抓包工具：Chrome DevTools**

**打开方式**：
1. 按F12键
2. 选择"Network"（网络）标签
3. 刷新页面，就能看到所有请求

**看到的信息**：

```
请求列表：
Name           Status   Type        Size      Time
─────────────────────────────────────────────────
login          200      xhr         1.2KB     235ms
getUserInfo    200      xhr         3.5KB     89ms
avatar.jpg     200      image       45KB      120ms

点击某个请求，可以看到详细信息：

Headers（请求头）：
  Request URL: http://localhost:8080/api/login
  Request Method: POST
  Status Code: 200 OK
  
Payload（请求参数）：
  {
    "username": "admin",
    "password": "123456"
  }
  
Response（响应内容）：
  {
    "code": 0,
    "message": "登录成功",
    "data": { ... }
  }
```

**常见问题排查**：

| 问题现象 | **查看位置** | **可能原因** |
|---------|------------|-------------|
| `接口404` | `Status Code` | `URL写错了` |
| `参数没传` | `Payload` | `前端没传参数` |
| `响应慢` | `Time` | `后端处理慢` |
| `跨域错误` | `Response Headers` | `CORS配置问题` |

### 7.3 使用Postman测试接口


**Postman是什么**：模拟浏览器发送请求的工具，测试接口很方便。

**测试POST请求示例**：

```
1. 选择请求方法：POST
2. 填写URL：http://localhost:8080/api/user/save
3. 选择Body → raw → JSON
4. 填写请求体：
   {
     "username": "test",
     "age": 25,
     "email": "test@example.com"
   }
5. 点击Send发送

查看响应：
Status: 200 OK
Time: 156ms
Response:
{
  "code": 0,
  "message": "保存成功",
  "data": {
    "id": 123,
    "username": "test"
  }
}
```

**保存测试用例**：
- 可以把常用的接口保存成Collection（集合）
- 下次直接点击发送，不用重新填参数

### 7.4 使用Wireshark深度抓包


**Wireshark是什么**：网络协议分析工具，可以抓取所有网络数据包（包括HTTP、TCP、IP层）。

**使用场景**：
- 分析TCP连接问题（三次握手失败）
- 查看SSL/TLS加密握手过程
- 诊断网络丢包、延迟问题

**基本使用**：

```
1. 启动Wireshark
2. 选择网络接口（如：WLAN）
3. 开始抓包
4. 使用过滤器：
   http                     → 只看HTTP协议
   ip.addr == 192.168.1.100 → 只看某个IP的包
   tcp.port == 8080         → 只看8080端口的包

5. 停止抓包，分析数据
```

**查看HTTP请求详情**：
```
Frame 123: HTTP Request
  Hypertext Transfer Protocol
    POST /api/login HTTP/1.1
    Host: localhost:8080
    Content-Type: application/json
    Content-Length: 45
    
    {"username":"admin","password":"123456"}

Frame 124: HTTP Response
  Hypertext Transfer Protocol
    HTTP/1.1 200 OK
    Content-Type: application/json
    
    {"code":0,"message":"success"}
```

> ⚠️ **注意**：Wireshark功能强大但也复杂，新手建议先用Chrome DevTools和Postman。

---

## 8. 🎯 错误定位策略


### 8.1 错误的分类


**按影响范围分类**：

```
┌─────────────────错误金字塔─────────────────┐
│                                            │
│              语法错误                       │
│           （编译时发现）                     │
│          ↓                                 │
│         逻辑错误                            │
│      （功能不对，难排查）                    │
│          ↓                                 │
│        运行时错误                           │
│     （空指针、数组越界）                     │
│          ↓                                 │
│       系统级错误                            │
│   （内存溢出、网络超时）                     │
│                                            │
└────────────────────────────────────────────┘
```

### 8.2 快速定位错误的方法


**方法1：看异常堆栈**

```java
// 异常信息示例
java.lang.NullPointerException: Cannot invoke "User.getName()" because "user" is null
    at com.example.service.UserService.getUserName(UserService.java:25)
    at com.example.controller.UserController.getUser(UserController.java:45)
    ↑                                                              ↑
    异常类型                                                    出错位置
```

**阅读技巧**：
1. 第1行：看异常类型（NullPointerException）和原因（user是null）
2. 第2行：看第一个出错位置（UserService.java:25）
3. 第3行：看调用链，理解调用路径

**方法2：二分法定位**

```java
@GetMapping("/test")
public String test() {
    System.out.println("步骤1：进入方法"); // 打印1
    
    User user = getUser();
    System.out.println("步骤2：获取用户"); // 打印2
    
    String name = user.getName();
    System.out.println("步骤3：获取姓名"); // 打印3
    
    return name;
}

// 如果只打印了1和2，没打印3
// 说明问题在第3步：user.getName()
```

**方法3：排除法**

```java
// 场景：保存用户时报错，不确定哪里有问题

@PostMapping("/save")
public Result saveUser(@RequestBody User user) {
    // 步骤1：先注释掉所有逻辑
    // validateUser(user);
    // enrichUser(user);
    // userDao.save(user);
    return Result.success(); // 测试能否正常返回
    
    // 步骤2：逐个取消注释
    validateUser(user);  // 取消注释后测试，OK
    // enrichUser(user);
    // userDao.save(user);
    
    // 步骤3：继续
    validateUser(user);
    enrichUser(user);    // 取消注释后测试，报错了！
    // 定位到问题：enrichUser方法有问题
}
```

### 8.3 常见错误及解决


**错误1：NullPointerException（空指针）**

```java
// ❌ 错误代码
@GetMapping("/user/{id}")
public User getUser(@PathVariable Long id) {
    User user = userDao.findById(id); // 可能返回null
    return user.getName(); // 如果user是null，报错！
}

// ✅ 修复方式1：判空
@GetMapping("/user/{id}")
public User getUser(@PathVariable Long id) {
    User user = userDao.findById(id);
    if (user == null) {
        throw new NotFoundException("用户不存在");
    }
    return user.getName();
}

// ✅ 修复方式2：使用Optional
@GetMapping("/user/{id}")
public User getUser(@PathVariable Long id) {
    return userDao.findById(id)
        .orElseThrow(() -> new NotFoundException("用户不存在"));
}
```

**错误2：ClassCastException（类型转换）**

```java
// ❌ 错误代码
Object obj = request.getAttribute("user");
User user = (User) obj; // 如果obj不是User类型，报错！

// ✅ 修复方式：类型检查
Object obj = request.getAttribute("user");
if (obj instanceof User) {
    User user = (User) obj;
    // ...
}
```

**错误3：ConcurrentModificationException（并发修改）**

```java
// ❌ 错误代码
List<User> users = getUsers();
for (User user : users) {
    if (user.getAge() < 18) {
        users.remove(user); // 遍历时删除，报错！
    }
}

// ✅ 修复方式：使用迭代器
List<User> users = getUsers();
Iterator<User> iterator = users.iterator();
while (iterator.hasNext()) {
    User user = iterator.next();
    if (user.getAge() < 18) {
        iterator.remove(); // 安全删除
    }
}
```

### 8.4 错误处理最佳实践


**统一异常处理**：

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    public Result handleBusinessException(BusinessException e) {
        log.error("业务异常：{}", e.getMessage());
        return Result.fail(e.getMessage());
    }
    
    // 处理参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result handleValidException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldError().getDefaultMessage();
        log.error("参数校验失败：{}", message);
        return Result.fail("参数错误：" + message);
    }
    
    // 处理系统异常
    @ExceptionHandler(Exception.class)
    public Result handleException(Exception e) {
        log.error("系统异常", e);
        return Result.fail("系统繁忙，请稍后再试");
    }
}
```

**好处**：
- 统一的错误响应格式
- 避免敏感信息泄露
- 便于监控和告警

---

## 9. 🛠️ 常用调试工具


### 9.1 开发工具对比


| 工具 | **类型** | **适用场景** | **优势** | **学习成本** |
|------|---------|-------------|---------|-------------|
| **IDEA Debugger** | `IDE调试` | `代码逻辑调试` | `功能强大，集成度高` | `⭐⭐` |
| **Chrome DevTools** | `浏览器调试` | `前后端联调` | `免费，方便` | `⭐` |
| **Postman** | `接口测试` | `API测试` | `简单易用` | `⭐` |
| **Arthas** | `在线诊断` | `生产问题排查` | `无需重启` | `⭐⭐⭐` |
| **JProfiler** | `性能分析` | `性能优化` | `专业强大` | `⭐⭐⭐⭐` |
| **Wireshark** | `网络抓包` | `网络问题诊断` | `深度分析` | `⭐⭐⭐⭐` |

### 9.2 Arthas在线诊断


**Arthas是什么**：阿里开源的Java诊断工具，可以在不重启应用的情况下排查问题。

**安装使用**：

```bash
# 下载arthas
curl -O https://arthas.aliyun.com/arthas-boot.jar

# 启动（会列出所有Java进程）
java -jar arthas-boot.jar

# 选择要诊断的进程
[1] 12345 com.example.Application
请输入编号：1
```

**常用命令**：

```bash
# 1. 查看JVM信息
dashboard

# 输出示例：
Thread: 25      Memory: heap=1024M
CPU: 15.2%      GC: YGC=45, FGC=3

# 2. 反编译类（看源码）
jad com.example.service.UserService

# 3. 监控方法执行
watch com.example.service.UserService getUser "{params,returnObj}" -x 2

# 输出：
method=UserService.getUser
params=[@Long[12345]]
returnObj=@User[
  id=12345,
  name="张三"
]

# 4. 追踪方法调用链
trace com.example.service.OrderService createOrder

# 输出：
OrderService.createOrder() [1256ms]
  ├─ StockService.check() [856ms]  ← 耗时最多
  ├─ UserService.get() [45ms]
  └─ OrderDao.save() [355ms]
```

**实战案例：定位慢接口**

```bash
# 监控所有请求超过1秒的方法
trace com.example.controller.* * '#cost > 1000'

# 找到慢方法后，查看参数
watch com.example.service.UserService findUsers "{params,returnObj,cost}" -x 2

# 发现是因为参数导致的慢查询，优化代码
```

### 9.3 日志分析工具


**ELK技术栈（企业常用）**：

```
日志收集流程：
应用日志 → Filebeat → Logstash → Elasticsearch → Kibana展示
          （采集）   （处理）     （存储）      （可视化）
```

**Kibana查询日志**：

```
# 搜索错误日志
level: ERROR AND message: "订单创建失败"

# 按时间范围搜索
@timestamp: [2025-01-01 TO 2025-01-02] AND userId: 12345

# 聚合分析
按接口统计错误次数、按用户统计操作记录
```

### 9.4 性能分析工具


**JProfiler使用步骤**：

```
1. 启动JProfiler
2. 连接到目标Java进程
3. 选择分析类型：
   - CPU分析：找耗时方法
   - 内存分析：找内存泄漏
   - 线程分析：找死锁

4. 查看火焰图：
   ┌─────────────────────火焰图─────────────────────┐
   │                                                │
   │  main                                          │
   │  ├─ createOrder [60%]                          │
   │  │  ├─ checkStock [45%] ← 占用时间最多          │
   │  │  └─ saveOrder [15%]                         │
   │  └─ sendNotify [40%]                           │
   │                                                │
   └────────────────────────────────────────────────┘
   横向宽度 = 耗时占比
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的调试技能


```
🔸 断点调试：快速定位代码逻辑问题
🔸 日志分析：从日志中找出错误线索
🔸 请求跟踪：追踪请求的完整路径
🔸 性能诊断：找出系统性能瓶颈
🔸 内存分析：排查内存泄漏和OOM问题
🔸 网络抓包：分析接口调用是否正常
🔸 错误定位：快速找到错误根源
🔸 工具使用：熟练使用各类调试工具
```

### 10.2 调试技巧总结


**新手常用技巧**：
1. **看日志** - 70%的问题都能从日志找到线索
2. **打断点** - 不确定逻辑时，用断点一步步走
3. **分段测试** - 把复杂逻辑拆开，逐段测试
4. **对比正常情况** - 和正常的请求对比，找差异

**进阶调试技巧**：
1. **条件断点** - 只在特定条件下暂停，提高效率
2. **远程调试** - 在服务器上调试生产问题
3. **链路追踪** - 分布式环境下追踪完整调用链
4. **性能分析** - 使用专业工具定位性能瓶颈

### 10.3 问题排查检查清单


**遇到问题时的思考步骤**：

☑️ **Step 1：能复现吗？**
- 能稳定复现 → 好办，进入下一步
- 偶发问题 → 收集更多日志，找规律

☑️ **Step 2：查看错误信息**
- 看异常堆栈的第一行
- 找到最接近业务代码的位置

☑️ **Step 3：缩小范围**
- 确定是前端还是后端问题
- 确定是哪个模块的问题

☑️ **Step 4：验证假设**
- 用断点验证代码逻辑
- 用日志验证数据流向

☑️ **Step 5：解决并测试**
- 修复代码
- 测试多种场景确保真的解决了

### 10.4 实用工具速查


**日常开发必备**：
- `IDEA Debugger` - 代码调试第一选择
- `Chrome DevTools` - 前后端联调必备
- `Postman` - 接口测试利器

**性能优化必备**：
- `Spring Boot Actuator` - 应用监控
- `Arthas` - 在线诊断神器
- `JProfiler` - 深度性能分析

**生产问题排查**：
- `ELK` - 日志分析平台
- `SkyWalking` - 链路追踪
- `Prometheus + Grafana` - 监控告警

### 10.5 避坑指南


**调试时的常见错误**：

❌ **依赖System.out.println**
- 问题：生产环境看不到控制台输出
- 正确：使用日志框架

❌ **不看日志直接改代码**
- 问题：可能改错地方
- 正确：先看日志定位问题

❌ **生产环境开DEBUG日志**
- 问题：日志太多，影响性能
- 正确：只在需要时临时开启

❌ **忽略警告信息**
- 问题：警告可能是错误的前兆
- 正确：重视每一个警告

**核心记忆口诀**：
```
调试先看日志找线索，
断点定位代码逻辑流。
性能问题看耗时分布，
内存泄漏查对象引用。
网络抓包看请求响应，
工具结合效率更高。
```

**实战建议**：
- 💡 多练习断点调试，培养代码直觉
- 💡 养成写日志的习惯，方便排查问题
- 💡 学会使用一两个专业工具深度分析
- 💡 保持好奇心，搞清楚每个错误的根本原因