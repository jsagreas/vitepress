---
title: 3、starter-parent与BOM依赖对齐
---
## 📚 目录

1. [Spring Boot工程骨架理念](#1-Spring-Boot工程骨架理念)
2. [starter-parent继承机制](#2-starter-parent继承机制)
3. [BOM物料清单深度解析](#3-BOM物料清单深度解析)
4. [版本对齐机制原理](#4-版本对齐机制原理)
5. [依赖冲突化解策略](#5-依赖冲突化解策略)
6. [平台依赖管理实践](#6-平台依赖管理实践)
7. [第三方BOM集成应用](#7-第三方BOM集成应用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ Spring Boot工程骨架理念


### 1.1 什么是Spring Boot的工程骨架


**🤔 为什么需要工程骨架？**

想象一下，你要盖一座房子。传统的方式是：
- 自己买水泥、砖头、钢筋
- 自己找各种工人
- 自己协调各个环节
- 确保材料质量和规格统一

这就像传统的Java项目一样，需要你：
```
❌ 传统Spring项目的痛点：
• 手动配置各种XML文件
• 手动管理jar包版本
• 版本冲突时不知道怎么解决
• 项目结构每个人都不一样
• 配置复杂，新手很难上手
```

而Spring Boot就像**精装修房子**：
```
✅ Spring Boot提供的便利：
• 标准化的项目结构
• 自动配置大部分功能
• 统一管理所有依赖版本
• 开箱即用，几行代码就能启动
• 约定大于配置的设计理念
```

### 1.2 核心设计理念


**📌 约定大于配置（Convention over Configuration）**

这是Spring Boot最重要的设计思想，用大白话说就是：
> 💡 **通俗解释**：我们预先帮你做好了99%的标准选择，你只需要关注剩下1%的特殊需求

```
传统方式：                   Spring Boot方式：
你：我要用数据库             你：我要用数据库  
系统：用什么数据库？          系统：默认给你配好MySQL
你：MySQL                   你：直接写业务代码
系统：什么版本？              系统：自动选择兼容版本
你：8.0.25                  结果：项目直接能跑
系统：连接池用什么？
你：HikariCP
系统：什么配置？
你：还要配置一大堆参数...
```

**🎯 自动装配（Auto Configuration）**

简单理解就是：**系统会根据你项目里有什么jar包，自动猜测你要做什么，然后自动配置好**

```
你的项目里有：spring-boot-starter-web
Spring Boot想：哦，你要做web项目
自动配置：
• 内嵌Tomcat服务器
• SpringMVC框架
• JSON转换器
• 错误页面处理
• 静态资源处理
结果：你的web服务直接就能启动！
```

---

## 2. 🎯 starter-parent继承机制


### 2.1 什么是spring-boot-starter-parent


**📋 定义**：`spring-boot-starter-parent`是Spring Boot提供的**标准父项目**，你的项目继承它就能获得Spring Boot的所有基础能力。

**🔍 通俗比喻**：
```
就像你继承了一个有钱的爹：
• 爹已经帮你买好了房子（项目结构）
• 准备好了家具（基础配置）
• 办好了各种会员卡（依赖管理）
• 你只需要住进去开始生活（写业务代码）
```

### 2.2 继承配置方式


```xml
<!-- 你的pom.xml文件 -->
<project>
    <!-- 继承Spring Boot父项目 -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
        <relativePath/> <!-- 从仓库查找parent -->
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>my-project</artifactId>
    <version>1.0.0</version>
</project>
```

**🤔 这个继承给你带来了什么？**

| 继承项目 | **获得的能力** | **具体作用** |
|---------|-------------|-------------|
| 🔧 **编译配置** | `Java版本、编码格式、编译参数` | `不用自己配置Java 8/11/17` |
| 📦 **插件管理** | `Maven插件版本统一管理` | `打包、测试插件自动配置` |
| 📚 **依赖版本** | `数百个常用jar包版本预定义` | `不用担心版本冲突问题` |
| ⚙️ **构建配置** | `资源文件处理、打包规则` | `application.yml自动识别` |

### 2.3 parent继承层次结构


```
你的项目 my-project
    ↑ 继承
spring-boot-starter-parent (2.7.0)
    ↑ 继承  
spring-boot-dependencies (2.7.0)
    ↑ 继承
一些Spring基础配置...
```

**📊 继承链分析**：

🔸 **你的项目**：
- 专注业务代码
- 只需要声明用到的starter

🔸 **starter-parent**：
- 提供Maven构建配置
- 定义Java编译版本
- 配置各种Maven插件

🔸 **spring-boot-dependencies**：
- **这里是核心！** 定义了所有依赖的版本号
- 就是我们后面要重点讲的BOM

---

## 3. 📦 BOM物料清单深度解析


### 3.1 什么是BOM


**🎯 BOM全称**：Bill of Materials（物料清单）

**🔍 通俗理解**：
想象你在网上买电脑：
```
传统方式：                    BOM方式：
你：我要买CPU                你：我要买游戏配置
商家：什么型号？              商家：游戏配置包含：
你：Intel i7-12700K            • CPU: Intel i7-12700K
你：我要买主板                 • 主板: 华硕B660M  
商家：什么型号？               • 内存: 金士顿32GB
你：要兼容这个CPU的            • 显卡: RTX 3070
你：我要买内存...              • 硬盘: 西数1TB SSD
      (选择困难症)              你：好的，就这个配置！
```

**💡 BOM的核心作用**：**预定义一套兼容的组件版本清单，让你不用操心版本匹配问题**

### 3.2 Spring Boot BOM结构


```xml
<!-- spring-boot-dependencies项目的pom.xml（简化版） -->
<project>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.7.0</version>
    <packaging>pom</packaging>
    
    <properties>
        <!-- 定义各个组件的版本号 -->
        <spring.version>5.3.21</spring.version>
        <mysql.version>8.0.29</mysql.version>
        <redis.version>4.2.1</redis.version>
        <jackson.version>2.13.3</jackson.version>
        <!-- ...几百个版本定义 -->
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <!-- Spring框架相关 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-core</artifactId>
                <version>${spring.version}</version>
            </dependency>
            
            <!-- 数据库相关 -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql.version}</version>
            </dependency>
            
            <!-- 更多依赖... -->
        </dependencies>
    </dependencyManagement>
</project>
```

### 3.3 BOM工作原理图解


```
Spring Boot BOM 版本管理原理：

你的项目pom.xml:                 BOM文件 (spring-boot-dependencies):
┌─────────────────────┐          ┌──────────────────────────────────┐
│<dependency>         │          │<dependencyManagement>           │
│  <groupId>mysql     │   查询    │  <dependency>                    │
│  <artifactId>...    │  ────→   │    <groupId>mysql</groupId>      │
│  <!-- 不写版本号 -->  │          │    <artifactId>...</artifactId>  │
│</dependency>        │          │    <version>8.0.29</version>     │
└─────────────────────┘          │  </dependency>                   │
                                 │</dependencyManagement>           │
结果：自动使用8.0.29版本           └──────────────────────────────────┘
```

### 3.4 BOM的优势分析


| 方面 | **不用BOM** | **使用BOM** |
|------|------------|-------------|
| 🎯 **版本管理** | `每个依赖都要指定版本` | `自动使用兼容版本` |
| ⚡ **升级维护** | `逐个更新，容易遗漏` | `只需升级BOM版本` |
| 🛡️ **兼容性** | `版本冲突需要手工解决` | `预先测试好的兼容版本` |
| 📚 **学习成本** | `需要了解各组件版本关系` | `专注业务，无需关心版本` |

---

## 4. ⚖️ 版本对齐机制原理


### 4.1 什么是版本对齐


**📌 版本对齐**：确保项目中所有相关的jar包版本都是互相兼容的，不会出现版本冲突。

**🔍 生活中的例子**：
```
就像组装家具：
❌ 版本不对齐的后果：
• 买了宜家的螺丝钉
• 买了无印良品的木板  
• 买了MUJI的五金件
结果：螺丝钉规格不匹配，组装不起来

✅ 版本对齐的好处：
• 买宜家的全套配件
• 所有零件都是配套设计的
结果：按照说明书就能顺利组装
```

### 4.2 Maven依赖传递原理


```
依赖传递示意图：

你的项目
    ├── spring-boot-starter-web
    │   ├── spring-webmvc (5.3.21)      ← 间接依赖
    │   ├── spring-web (5.3.21)         ← 间接依赖  
    │   └── tomcat-embed-core (9.0.63)  ← 间接依赖
    │
    └── spring-boot-starter-data-jpa
        ├── spring-data-jpa (2.7.0)     ← 间接依赖
        ├── spring-orm (5.3.21)         ← 间接依赖
        └── hibernate-core (5.6.9)      ← 间接依赖

注意：spring-web和spring-orm都依赖spring-core
如果版本不一致就会出现冲突！
```

**⚠️ 版本冲突的典型场景**：
```xml
<!-- 冲突示例 -->
<dependencies>
    <!-- 这个starter依赖Spring 5.3.21 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- 你手动引入了旧版本的Spring -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>4.3.25</version> <!-- 版本太老！ -->
    </dependency>
</dependencies>
```

**💥 可能的问题**：
- 新版本的功能在旧版本中不存在
- 方法签名发生了变化
- 运行时出现`NoSuchMethodError`或`ClassNotFoundException`

### 4.3 BOM如何解决版本对齐


**🔧 解决机制**：

1️⃣ **统一版本源**：
```
所有相关依赖的版本号都在同一个地方定义
spring.version = 5.3.21

相关的所有Spring组件都使用这个版本：
• spring-core: 5.3.21
• spring-context: 5.3.21  
• spring-web: 5.3.21
• spring-webmvc: 5.3.21
```

2️⃣ **版本锁定**：
```xml
<dependencyManagement>
    <!-- 锁定版本，子项目不需要指定版本号 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${spring.version}</version>
    </dependency>
</dependencyManagement>
```

3️⃣ **版本覆盖规则**：
```
Maven依赖版本选择优先级：
1. 直接依赖的版本号（你在pom.xml中直接写的）
2. dependencyManagement中定义的版本  
3. 传递依赖中的版本号

BOM通过第2级来统一管理版本
```

---

## 5. 🛠️ 依赖冲突化解策略


### 5.1 依赖冲突的类型


**📊 常见冲突类型分析**：

| 冲突类型 | **产生原因** | **典型症状** | **解决难度** |
|---------|-------------|-------------|-------------|
| 🔄 **版本冲突** | `同一个jar包的不同版本` | `NoSuchMethodError` | `⭐⭐` |
| 🎭 **包名冲突** | `不同jar包有相同的类` | `类加载异常` | `⭐⭐⭐` |
| 🔗 **传递冲突** | `间接依赖版本不匹配` | `运行时异常` | `⭐⭐⭐⭐` |

### 5.2 冲突排查工具


**🔍 Maven依赖树分析**：
```bash
# 查看完整依赖树
mvn dependency:tree

# 查看冲突分析
mvn dependency:tree -Dverbose

# 只看特定包的依赖
mvn dependency:tree -Dincludes=org.springframework:*
```

**📋 依赖树示例**：
```
[INFO] com.example:my-project:jar:1.0.0
[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.7.0
[INFO] |  +- org.springframework:spring-web:jar:5.3.21
[INFO] |  \- org.springframework:spring-webmvc:jar:5.3.21
[INFO] +- org.springframework.boot:spring-boot-starter-data-jpa:jar:2.7.0  
[INFO] |  \- org.springframework:spring-orm:jar:5.3.21
[INFO] \- mysql:mysql-connector-java:jar:8.0.29

看到了吗？所有spring相关的包都是5.3.21版本，完美对齐！
```

### 5.3 冲突解决策略


**🎯 策略1：使用BOM管理（推荐）**
```xml
<!-- 让BOM帮你管理版本，不要手动指定 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <!-- 不写version，使用BOM中的版本 -->
</dependency>
```

**🎯 策略2：显式排除冲突依赖**
```xml
<dependency>
    <groupId>some.third.party</groupId>
    <artifactId>some-library</artifactId>
    <version>1.0.0</version>
    <exclusions>
        <!-- 排除它带来的旧版本Spring -->
        <exclusion>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

**🎯 策略3：版本属性覆盖**
```xml
<properties>
    <!-- 覆盖BOM中的默认版本 -->
    <mysql.version>8.0.30</mysql.version>
</properties>
```

### 5.4 实战案例


**🔥 案例：解决Jackson版本冲突**

**问题现象**：
```java
// 运行时报错
com.fasterxml.jackson.databind.exc.InvalidDefinitionException: 
Cannot construct instance of `java.time.LocalDateTime`
```

**排查过程**：
```bash
# 1. 查看Jackson相关依赖
mvn dependency:tree -Dincludes=com.fasterxml.jackson.*

# 发现问题：
[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.13.3
[INFO] \- some-old-lib:jackson-databind:jar:2.9.8 (冲突！)
```

**解决方案**：
```xml
<dependency>
    <groupId>some-old-lib</groupId>
    <artifactId>some-library</artifactId>
    <version>1.0.0</version>
    <exclusions>
        <!-- 排除旧版本Jackson -->
        <exclusion>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

---

## 6. 🏢 平台依赖管理实践


### 6.1 什么是平台依赖管理


**🎯 定义**：在大型企业或团队中，统一管理所有项目的依赖版本，确保不同项目之间的兼容性。

**🔍 企业场景**：
```
传统问题：
项目A：使用Spring Boot 2.5.0 + MySQL 8.0.25
项目B：使用Spring Boot 2.6.0 + MySQL 8.0.28  
项目C：使用Spring Boot 2.7.0 + MySQL 8.0.30
结果：
• 不同项目无法共享组件
• 升级维护各自为政
• 安全漏洞修复不同步

平台化管理：
统一BOM：公司内部所有项目使用相同的技术栈版本
结果：
• 组件可以复用
• 统一升级维护  
• 安全策略一致
```

### 6.2 企业级BOM设计


**📦 分层BOM架构**：

```
企业BOM架构设计：

┌─────────────────────────────────────┐
│        业务应用层                    │
│    my-user-service                  │  
│    my-order-service                 │
└──────────┬──────────────────────────┘
           │ 继承
┌──────────▼──────────────────────────┐
│        企业平台BOM                   │
│   company-platform-dependencies    │
│   • 业务组件版本                     │  
│   • 监控组件版本                     │
│   • 安全组件版本                     │
└──────────┬──────────────────────────┘
           │ 继承  
┌──────────▼──────────────────────────┐
│      Spring Boot BOM               │
│  spring-boot-dependencies          │
│   • 基础框架版本                     │
│   • 第三方库版本                     │
└─────────────────────────────────────┘
```

**🔧 企业BOM示例**：
```xml
<!-- company-platform-dependencies -->
<project>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>2.7.0</version>
    </parent>
    
    <groupId>com.company</groupId>
    <artifactId>platform-dependencies</artifactId>
    <version>1.2.0</version>
    <packaging>pom</packaging>
    
    <properties>
        <!-- 企业级组件版本 -->
        <company-common.version>2.1.0</company-common.version>
        <company-security.version>1.5.0</company-security.version>
        <!-- 覆盖Spring Boot默认版本 -->
        <mysql.version>8.0.30</mysql.version>
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <!-- 企业内部组件 -->
            <dependency>
                <groupId>com.company</groupId>
                <artifactId>common-utils</artifactId>
                <version>${company-common.version}</version>
            </dependency>
            
            <!-- 统一的监控组件 -->
            <dependency>
                <groupId>io.micrometer</groupId>
                <artifactId>micrometer-registry-prometheus</artifactId>
                <version>1.9.1</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

### 6.3 平台BOM使用方式


**✅ 业务项目继承企业BOM**：
```xml
<!-- 业务项目的pom.xml -->
<project>
    <parent>
        <groupId>com.company</groupId>
        <artifactId>platform-dependencies</artifactId>
        <version>1.2.0</version>
    </parent>
    
    <groupId>com.company</groupId>
    <artifactId>user-service</artifactId>
    <version>1.0.0</version>
    
    <dependencies>
        <!-- 直接使用，版本由平台BOM管理 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>com.company</groupId>
            <artifactId>common-utils</artifactId>
        </dependency>
    </dependencies>
</project>
```

### 6.4 版本升级策略


**📈 渐进式升级流程**：

```
版本升级流程：

第1步：升级测试环境
├── 更新platform-dependencies版本
├── 运行全量测试用例  
└── 验证各服务兼容性

第2步：灰度发布
├── 选择1-2个低风险服务
├── 部署到生产环境
└── 观察运行状态

第3步：全面推广  
├── 逐步升级所有服务
├── 监控系统稳定性
└── 回滚机制准备

第4步：版本清理
├── 移除旧版本依赖
├── 更新文档和规范
└── 培训团队成员
```

---

## 7. 🔌 第三方BOM集成应用


### 7.1 什么是第三方BOM


**📌 定义**：除了Spring Boot官方BOM外，其他技术厂商也提供BOM来管理自己生态的组件版本。

**🌟 主流第三方BOM**：

| BOM名称 | **提供商** | **管理范围** | **使用场景** |
|---------|-----------|-------------|-------------|
| 🌩️ **Spring Cloud BOM** | `Spring官方` | `微服务组件` | `分布式系统开发` |
| ☁️ **Spring Cloud Alibaba BOM** | `阿里巴巴` | `阿里云组件` | `使用阿里云服务` |
| 📊 **Testcontainers BOM** | `Testcontainers` | `测试容器` | `集成测试` |
| 🔍 **Jackson BOM** | `FasterXML` | `JSON处理` | `复杂JSON场景` |

### 7.2 Spring Cloud BOM集成


**🚀 微服务场景**：
```xml
<project>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
    </parent>
    
    <properties>
        <spring-cloud.version>2021.0.3</spring-cloud.version>
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <!-- 引入Spring Cloud BOM -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- 微服务组件，版本由Cloud BOM管理 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
    </dependencies>
</project>
```

**🔗 版本兼容性对照**：
```
Spring Boot与Spring Cloud版本对应关系：

Spring Boot 2.6.x  ←→  Spring Cloud 2021.0.x
Spring Boot 2.7.x  ←→  Spring Cloud 2021.0.x  
Spring Boot 3.0.x  ←→  Spring Cloud 2022.0.x

重要：版本必须匹配，否则会出现不兼容问题！
```

### 7.3 多BOM组合使用


**🧩 复杂项目的BOM组合**：
```xml
<dependencyManagement>
    <dependencies>
        <!-- Spring Cloud微服务 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2021.0.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- 阿里巴巴微服务组件 -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2021.0.1.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- 测试框架 -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers-bom</artifactId>
            <version>1.17.2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### 7.4 BOM冲突处理


**⚠️ BOM间的版本冲突**：

```
冲突场景：
Spring Boot BOM定义：jackson-databind 2.13.3
Spring Cloud BOM定义：jackson-databind 2.13.2

结果：后导入的BOM会覆盖前面的定义

解决方案1：调整BOM导入顺序
解决方案2：显式指定版本
```

```xml
<!-- 解决方案：显式版本覆盖 -->
<dependencyManagement>
    <dependencies>
        <!-- 先导入BOM -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2021.0.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- 再显式指定想要的版本 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.13.3</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🎯 Spring Boot工程理念：
• 约定大于配置：预设标准选择，减少配置复杂度
• 自动装配：根据classpath自动配置功能
• starter机制：开箱即用的功能模块

🔧 parent继承机制：
• 继承spring-boot-starter-parent获得标准配置
• 自动获得Maven插件、Java版本、编码等配置
• 通过继承链获得BOM依赖管理能力

📦 BOM核心作用：
• 统一管理相关组件的版本号
• 解决依赖版本冲突问题  
• 简化项目依赖配置
```

### 8.2 关键理解要点


**🔹 为什么BOM这么重要？**
```
现实问题：
• Java生态组件繁多，版本关系复杂
• 手动管理版本容易出错
• 版本冲突调试困难

BOM解决方案：
• 专业团队测试版本兼容性
• 一次配置，处处使用
• 升级维护简单可控
```

**🔹 依赖管理的最佳实践**
```
✅ 推荐做法：
• 优先使用官方BOM管理版本
• 不要手动指定框架核心组件版本
• 企业项目建立统一的平台BOM
• 定期升级BOM版本保持安全性

❌ 避免做法：  
• 随意指定依赖版本号
• 忽略依赖冲突警告
• 混用不兼容的BOM版本
• 在业务代码中硬编码版本号
```

**🔹 版本冲突排查思路**
```
排查步骤：
1. 使用maven dependency:tree查看依赖树
2. 识别冲突的jar包和版本
3. 分析冲突根源（直接依赖vs传递依赖）
4. 选择合适的解决策略（排除、覆盖、BOM管理）
5. 验证修复效果并测试功能
```

### 8.3 实际应用指导


**🎯 新项目创建步骤**：
```
1. 选择合适的Spring Boot版本
2. 继承spring-boot-starter-parent
3. 根据需要引入第三方BOM（如Spring Cloud）
4. 添加业务需要的starter依赖
5. 验证依赖树没有版本冲突
```

**🔧 现有项目改造建议**：
```
1. 分析现有依赖，识别版本管理痛点
2. 逐步引入BOM管理核心依赖
3. 清理手动指定的版本号
4. 建立版本升级和测试流程
5. 培训团队成员BOM使用方法
```

**💡 企业级实践要点**：
```
• 建立企业统一的技术栈BOM
• 制定版本升级的标准流程
• 设立技术债务清理计划
• 建立依赖安全漏洞监控机制
```

**核心记忆口诀**：
```
Spring Boot项目要规范，
parent继承是关键。
BOM管理版本号，
冲突问题不再烦。
依赖树里找问题，
排除覆盖有策略。
企业项目建平台，
统一管理更简单。
```