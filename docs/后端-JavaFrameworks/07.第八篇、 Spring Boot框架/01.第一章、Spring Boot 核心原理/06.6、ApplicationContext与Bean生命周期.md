---
title: 6、ApplicationContext与Bean生命周期
---
## 📚 目录

1. [BeanFactory核心容器](#1-BeanFactory核心容器)
2. [Bean实例化过程](#2-Bean实例化过程)
3. [初始化与销毁回调](#3-初始化与销毁回调)
4. [BeanPostProcessor扩展点](#4-BeanPostProcessor扩展点)
5. [循环依赖解决机制](#5-循环依赖解决机制)
6. [Bean作用域管理](#6-Bean作用域管理)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏭 BeanFactory核心容器


### 1.1 什么是BeanFactory


**💡 通俗理解**：BeanFactory就像一个超级工厂，专门负责生产和管理各种Java对象（Bean）

```
生活中的工厂：                Spring中的BeanFactory：
原材料 → 生产线 → 成品        Class → Spring容器 → Bean对象
  ↓                              ↓
管理生产过程                    管理Bean的创建和生命周期
```

**🔍 BeanFactory的核心职责**：
- **📦 对象创建**：根据配置创建Java对象
- **🔧 依赖注入**：自动装配对象之间的关系
- **♻️ 生命周期管理**：管理对象从创建到销毁的全过程
- **🎯 作用域控制**：控制对象是单例还是多例

### 1.2 BeanFactory与ApplicationContext的关系


```
容器层次结构：

           ApplicationContext
                  ↓ (扩展)
             BeanFactory
                  ↓ (核心)
              Bean管理
```

| 特性 | **BeanFactory** | **ApplicationContext** |
|------|----------------|----------------------|
| **定位** | 🔧 基础容器 | 🚀 高级容器 |
| **功能** | Bean的基本管理 | Bean管理 + 企业级功能 |
| **加载方式** | 懒加载（用时创建） | 立即加载（启动时创建） |
| **适用场景** | 资源受限环境 | 企业级应用 |

**🎯 新手理解**：
- BeanFactory = 基础版工厂（只管生产）
- ApplicationContext = 豪华版工厂（生产 + 各种增值服务）

### 1.3 容器的初始化过程


**📋 容器启动流程**：

```
Spring Boot启动过程：

1. 📖 读取配置
   ├── application.yml/properties
   ├── @Configuration配置类
   └── @Component注解扫描

2. 🏗️ 创建容器
   ├── 创建ApplicationContext
   ├── 注册BeanDefinition
   └── 准备Bean工厂

3. 🚀 实例化Bean
   ├── 实例化单例Bean
   ├── 处理依赖注入
   └── 执行初始化方法

4. ✅ 容器就绪
   └── 应用可以正常使用
```

---

## 2. 🔄 Bean实例化过程


### 2.1 Bean的创建时机


**⏰ 不同作用域的创建时机**：

```
单例Bean (Singleton)：
应用启动时 → 立即创建 → 容器销毁时销毁

原型Bean (Prototype)：
每次获取时 → 创建新实例 → 使用完自行销毁

请求Bean (Request)：
HTTP请求开始 → 创建实例 → 请求结束销毁

会话Bean (Session)：
会话开始 → 创建实例 → 会话结束销毁
```

### 2.2 Bean实例化的详细步骤


**🔢 Bean创建的完整流程**：

```
Bean创建的8个步骤：

① 📋 读取BeanDefinition
   └── 从配置中获取Bean的定义信息

② 🏗️ 实例化Bean
   └── 使用构造函数创建对象实例

③ 🔧 设置Bean属性
   └── 通过setter方法注入依赖

④ 🔌 处理Aware接口
   └── 如BeanNameAware、ApplicationContextAware

⑤ ⚙️ BeanPostProcessor前置处理
   └── 调用postProcessBeforeInitialization

⑥ 🚀 执行初始化方法
   └── @PostConstruct、InitializingBean、init-method

⑦ ⚙️ BeanPostProcessor后置处理
   └── 调用postProcessAfterInitialization

⑧ ✅ Bean创建完成
   └── 注册销毁回调，Bean可以使用
```

### 2.3 实例化过程代码示例


```java
@Component
public class UserService {
    
    @Autowired
    private UserRepository userRepository;  // ③ 属性注入
    
    @PostConstruct
    public void init() {  // ⑥ 初始化方法
        System.out.println("UserService 初始化完成");
    }
    
    @PreDestroy
    public void destroy() {  // 销毁时调用
        System.out.println("UserService 即将销毁");
    }
}
```

**💡 新手理解**：Spring就像一个智能组装工厂，它会：
1. 先造出空白对象（实例化）
2. 再装入各种零件（依赖注入）
3. 最后启动设备（初始化）

---

## 3. 🔄 初始化与销毁回调


### 3.1 三种初始化方式


Spring提供了三种方式来定义Bean的初始化逻辑：

**方式一：@PostConstruct注解**
```java
@Component
public class DatabaseService {
    
    @PostConstruct
    public void initDatabase() {  // ✅ 推荐方式
        System.out.println("数据库连接初始化");
    }
}
```

**方式二：实现InitializingBean接口**
```java
@Component
public class CacheService implements InitializingBean {
    
    @Override
    public void afterPropertiesSet() {  // ⚡ 接口方式
        System.out.println("缓存服务初始化");
    }
}
```

**方式三：XML配置init-method**
```xml
<!-- 📄 XML配置方式（较少使用） -->
<bean id="emailService" class="com.example.EmailService" 
      init-method="initEmailConnection"/>
```

### 3.2 三种销毁方式


**方式一：@PreDestroy注解**
```java
@Component
public class DatabaseService {
    
    @PreDestroy
    public void cleanupDatabase() {  // ✅ 推荐方式
        System.out.println("关闭数据库连接");
    }
}
```

**方式二：实现DisposableBean接口**
```java
@Component
public class ConnectionPool implements DisposableBean {
    
    @Override
    public void destroy() {  // ⚡ 接口方式
        System.out.println("关闭连接池");
    }
}
```

### 3.3 执行顺序规律


**📊 初始化执行顺序**：
```
1️⃣ @PostConstruct        ← 最先执行
2️⃣ InitializingBean      ← 其次执行  
3️⃣ init-method          ← 最后执行
```

**📊 销毁执行顺序**：
```
1️⃣ @PreDestroy          ← 最先执行
2️⃣ DisposableBean       ← 其次执行
3️⃣ destroy-method       ← 最后执行
```

> **💡 新手贴士**：推荐使用`@PostConstruct`和`@PreDestroy`注解，因为它们简单直观，不需要实现接口

---

## 4. 🔧 BeanPostProcessor扩展点


### 4.1 什么是BeanPostProcessor


**🎯 通俗理解**：BeanPostProcessor就像生产线上的质检员，在Bean创建的关键节点进行检查和加工

```
Bean创建流程中的BeanPostProcessor：

实例化 → 属性注入 → 【前置处理】→ 初始化 → 【后置处理】→ 完成
                        ↑                    ↑
                   质检点1                 质检点2
                 可以修改Bean              可以替换Bean
```

### 4.2 BeanPostProcessor的作用


**🔍 主要用途**：
- **🔧 属性修改**：在初始化前修改Bean的属性
- **🎭 代理创建**：创建Bean的代理对象（如AOP）
- **✅ 验证检查**：验证Bean是否符合要求
- **📝 日志记录**：记录Bean的创建过程

### 4.3 自定义BeanPostProcessor示例


```java
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) 
            throws BeansException {
        // 🔧 初始化前的处理
        if (bean instanceof UserService) {
            System.out.println("准备初始化: " + beanName);
        }
        return bean; // 返回原Bean或修改后的Bean
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) 
            throws BeansException {
        // ✅ 初始化后的处理
        if (bean instanceof UserService) {
            System.out.println("初始化完成: " + beanName);
            // 可以返回代理对象
            return createProxy(bean);
        }
        return bean;
    }
}
```

### 4.4 Spring内置的重要BeanPostProcessor


| BeanPostProcessor | **作用** | **应用场景** |
|------------------|---------|-------------|
| **AutowiredAnnotationBeanPostProcessor** | 处理`@Autowired`注解 | 依赖注入 |
| **CommonAnnotationBeanPostProcessor** | 处理`@PostConstruct`等注解 | 生命周期回调 |
| **AnnotationAwareAspectJAutoProxyCreator** | 创建AOP代理 | 切面编程 |

> **⚠️ 注意事项**：BeanPostProcessor会影响所有Bean的创建，使用时要谨慎，避免性能问题

---

## 5. 🔄 循环依赖解决机制


### 5.1 什么是循环依赖


**🎯 通俗理解**：循环依赖就像"鸡生蛋，蛋生鸡"的问题

```
循环依赖示例：

UserService → UserRepository
     ↑              ↓
     ←──────────────
```

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;  // UserService需要UserRepository
}

@Repository  
public class UserRepository {
    @Autowired
    private UserService userService;  // UserRepository也需要UserService
}
```

### 5.2 Spring如何解决循环依赖


**🧠 Spring的聪明解决方案：三级缓存**

```
三级缓存机制：

一级缓存 (singletonObjects)：
├── 存储：完全初始化好的Bean
└── 作用：正常获取Bean的地方

二级缓存 (earlySingletonObjects)：
├── 存储：实例化但未完全初始化的Bean
└── 作用：解决循环依赖的中转站

三级缓存 (singletonFactories)：
├── 存储：Bean的工厂对象
└── 作用：在需要时创建Bean的早期引用
```

### 5.3 循环依赖解决过程


**📋 解决步骤**：

```
解决UserService ↔ UserRepository循环依赖：

第1步：创建UserService
├── 🏗️ 实例化UserService（调用构造函数）
├── 📝 将UserService工厂存入三级缓存
└── 🔧 开始属性注入，发现需要UserRepository

第2步：创建UserRepository  
├── 🏗️ 实例化UserRepository
├── 📝 将UserRepository工厂存入三级缓存
└── 🔧 开始属性注入，发现需要UserService

第3步：获取早期UserService引用
├── 🔍 从三级缓存获取UserService工厂
├── 🏭 通过工厂创建UserService早期引用
├── 📦 将早期引用存入二级缓存
└── ✅ 注入给UserRepository

第4步：完成创建
├── ✅ UserRepository创建完成，存入一级缓存
├── ✅ 注入给UserService
└── ✅ UserService创建完成，存入一级缓存
```

### 5.4 循环依赖的限制


**✅ 可以解决的情况**：
- **属性注入**：`@Autowired`在字段上
- **Setter注入**：`@Autowired`在setter方法上
- **单例Bean**：默认的singleton作用域

**❌ 无法解决的情况**：
- **构造函数注入**：`@Autowired`在构造函数上
- **原型Bean**：prototype作用域
- **代理Bean**：某些代理情况下

```java
// ❌ 构造函数循环依赖 - Spring无法解决
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {  // 构造函数注入
        this.userRepository = userRepository;
    }
}
```

> **💡 最佳实践**：尽量避免循环依赖，通过重新设计类结构来解决

---

## 6. 📦 Bean作用域管理


### 6.1 Bean作用域概述


**🎯 什么是Bean作用域**：作用域决定了Bean实例的创建方式和生存周期

```
Bean作用域类型：

🔹 singleton (单例)     ← 默认作用域，整个应用共享一个实例
🔹 prototype (原型)     ← 每次获取都创建新实例  
🔹 request (请求)       ← Web环境下，每个HTTP请求一个实例
🔹 session (会话)       ← Web环境下，每个用户会话一个实例
🔹 application (应用)   ← Web环境下，整个Web应用一个实例
```

### 6.2 单例作用域 (Singleton)


**📝 特点**：
- **默认作用域**：不指定时就是单例
- **共享实例**：整个应用只有一个实例
- **线程安全**：需要考虑多线程访问问题

```java
@Service  // 默认就是单例
public class UserService {
    private int counter = 0;  // ⚠️ 需要考虑线程安全
    
    public void incrementCounter() {
        counter++;  // 多线程环境下可能有问题
    }
}
```

**📊 单例Bean的生命周期**：
```
应用启动 → 创建实例 → 使用期间共享 → 应用关闭销毁
```

### 6.3 原型作用域 (Prototype)


**📝 特点**：
- **每次新建**：每次获取都创建新实例
- **无销毁回调**：Spring不管理销毁过程
- **适用场景**：有状态的Bean或需要隔离的场景

```java
@Service
@Scope("prototype")  // 或 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class TaskProcessor {
    private String taskId;
    private int progress;
    
    // 每个任务都有独立的处理器实例
    public void processTask(String taskId) {
        this.taskId = taskId;
        // 处理任务...
    }
}
```

### 6.4 Web作用域


**🌐 Request作用域**：
```java
@Controller
@Scope("request")
public class RequestController {
    private String requestData;  // 每个HTTP请求都有独立的数据
    
    @GetMapping("/process")
    public String processRequest() {
        // 处理请求...
        return "result";
    }
}
```

**📊 Web作用域的生命周期**：
```
Request:  HTTP请求开始 → 创建 → 请求结束销毁
Session:  用户会话开始 → 创建 → 会话结束销毁  
Application: Web应用启动 → 创建 → 应用关闭销毁
```

### 6.5 作用域选择指南


| 场景 | **推荐作用域** | **原因** |
|------|---------------|----------|
| **无状态服务** | `singleton` | 性能好，资源节约 |
| **有状态处理** | `prototype` | 避免数据混乱 |
| **请求相关数据** | `request` | 自动管理生命周期 |
| **用户相关数据** | `session` | 跨请求共享用户数据 |

> **💡 性能提示**：单例Bean性能最好，原型Bean每次创建有开销，Web作用域介于两者之间

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 BeanFactory：Spring的核心容器，负责Bean的创建和管理
🔸 ApplicationContext：BeanFactory的增强版，提供更多企业级功能
🔸 Bean生命周期：实例化 → 属性注入 → 初始化 → 使用 → 销毁
🔸 BeanPostProcessor：Bean创建过程中的扩展点，可以修改Bean
🔸 循环依赖：通过三级缓存机制解决属性注入的循环依赖
🔸 Bean作用域：控制Bean实例的创建方式和生存周期
```

### 7.2 关键理解要点


**🔹 容器的本质**
```
Spring容器就像一个智能工厂：
- 根据图纸（配置）生产产品（Bean）
- 自动组装零件（依赖注入）
- 管理产品生命周期（创建到销毁）
- 提供质量检查（BeanPostProcessor）
```

**🔹 Bean生命周期的意义**
```
为什么要管理Bean生命周期？
- 🚀 性能优化：合理的创建时机
- 🔧 资源管理：及时释放资源
- 🎯 业务需求：在特定时机执行逻辑
- 🛡️ 系统稳定：避免内存泄漏
```

**🔹 循环依赖解决的巧妙**
```
三级缓存的设计思想：
- 先创建半成品（实例化）
- 再完善功能（属性注入）
- 最后质量检查（初始化）
- 分步骤解决了"鸡蛋问题"
```

### 7.3 实际应用价值


**💼 在微服务中的应用**：
- **服务发现**：Bean的自动装配简化了服务间调用
- **配置管理**：通过Bean作用域管理不同级别的配置
- **资源管理**：生命周期回调用于连接池等资源管理
- **切面编程**：BeanPostProcessor是AOP实现的基础

**🔧 开发最佳实践**：
- **优先使用注解**：`@PostConstruct`比实现接口更简洁
- **避免循环依赖**：通过重新设计类结构来避免
- **合理选择作用域**：根据业务需求选择合适的作用域
- **谨慎使用BeanPostProcessor**：它会影响所有Bean的性能

**🎯 学习建议**：
- **理解概念**：先理解为什么需要这些机制
- **动手实践**：写代码验证理论知识
- **观察日志**：通过日志了解Bean的创建过程
- **逐步深入**：从简单例子开始，逐步学习复杂场景

**核心记忆口诀**：
- 容器工厂管Bean创建，生命周期有规律
- 三级缓存解循环，作用域控制实例数
- 后处理器是扩展，初始销毁有回调
- 理解原理重实践，微服务基础要打牢