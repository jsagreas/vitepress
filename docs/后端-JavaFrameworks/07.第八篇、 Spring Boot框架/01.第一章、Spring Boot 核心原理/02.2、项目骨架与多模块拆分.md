---
title: 2、项目骨架与多模块拆分
---
## 📚 目录

1. [项目结构基础理念](#1-项目结构基础理念)
2. [单体 vs 多模块结构对比](#2-单体-vs-多模块结构对比)
3. [父子模块关系详解](#3-父子模块关系详解)
4. [核心模块划分策略](#4-核心模块划分策略)
5. [依赖版本统一管理](#5-依赖版本统一管理)
6. [可执行JAR构建原理](#6-可执行jar构建原理)
7. [构建工具选择指南](#7-构建工具选择指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ 项目结构基础理念


### 1.1 什么是项目骨架

**项目骨架**就像盖房子的框架结构，它决定了整个项目的组织方式和代码分布。

```
传统单个项目：
my-app/
├── src/main/java/
├── src/main/resources/
└── pom.xml

多模块项目：
my-parent/
├── my-common/        ← 公共工具模块
├── my-core/          ← 核心业务模块  
├── my-web/           ← Web接口模块
├── my-api/           ← API定义模块
└── pom.xml           ← 父项目配置
```

### 1.2 为什么需要多模块结构


**🔸 现实场景类比**
```
想象一家公司的组织架构：

单体结构 = 所有人挤在一个办公室
- 人员混杂，职责不清
- 沟通混乱，协作困难
- 扩展受限，维护复杂

多模块结构 = 按部门分工的现代企业
- 职责分明，各司其职
- 接口清晰，协作高效
- 独立发展，灵活扩展
```

**🎯 多模块的核心价值**
- **职责分离**：每个模块负责特定功能
- **代码复用**：公共代码可以被多个模块使用
- **独立开发**：不同团队可以并行开发不同模块
- **灵活部署**：可以单独部署某个模块

---

## 2. ⚖️ 单体 vs 多模块结构对比


### 2.1 单体项目结构


**🔸 典型单体项目**
```
single-app/
├── src/main/java/com/example/
│   ├── controller/          ← 所有控制器
│   ├── service/             ← 所有业务逻辑
│   ├── dao/                 ← 所有数据访问
│   ├── entity/              ← 所有实体类
│   └── util/                ← 所有工具类
├── src/main/resources/
└── pom.xml
```

### 2.2 多模块项目结构


**🔸 标准多模块结构**
```
microservice-parent/
├── common-module/           ← 通用工具和基础组件
│   ├── src/main/java/
│   └── pom.xml
├── core-module/             ← 核心业务逻辑
│   ├── src/main/java/
│   └── pom.xml
├── web-module/              ← Web层接口
│   ├── src/main/java/
│   └── pom.xml
├── api-module/              ← API定义和文档
│   ├── src/main/java/
│   └── pom.xml
└── pom.xml                  ← 父项目统一管理
```

### 2.3 结构对比分析


| **对比维度** | **单体结构** | **多模块结构** |
|-------------|-------------|---------------|
| **🏗️ 项目复杂度** | `简单直接` | `结构清晰但稍复杂` |
| **👥 团队协作** | `容易冲突` | `并行开发，冲突少` |
| **🔄 代码复用** | `复制粘贴多` | `模块间引用，复用性好` |
| **⚡ 启动速度** | `快速` | `相对较慢` |
| **📦 部署方式** | `整体部署` | `可独立部署模块` |
| **🔧 维护成本** | `初期低，后期高` | `初期高，后期低` |

---

## 3. 👨‍👩‍👧‍👦 父子模块关系详解


### 3.1 父子关系的本质


**🔸 家庭关系类比**
```
父模块 = 家长
- 制定家庭规则（依赖版本）
- 提供公共资源（公共配置）
- 统一管理子女（子模块）

子模块 = 孩子  
- 继承家庭规则（继承父配置）
- 可以有自己的特色（特定依赖）
- 受父模块统一管理
```

### 3.2 父模块配置示例


```xml
<!-- 父模块 pom.xml -->
<project>
    <groupId>com.example</groupId>
    <artifactId>microservice-parent</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>
    
    <!-- 子模块列表 -->
    <modules>
        <module>common-module</module>
        <module>core-module</module>
        <module>web-module</module>
        <module>api-module</module>
    </modules>
    
    <!-- 版本统一管理 -->
    <properties>
        <spring.boot.version>2.7.0</spring.boot.version>
        <mysql.version>8.0.28</mysql.version>
    </properties>
</project>
```

### 3.3 子模块配置示例


```xml
<!-- 子模块 pom.xml -->
<project>
    <!-- 继承父模块 -->
    <parent>
        <groupId>com.example</groupId>
        <artifactId>microservice-parent</artifactId>
        <version>1.0.0</version>
    </parent>
    
    <artifactId>common-module</artifactId>
    
    <!-- 子模块特有依赖 -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
    </dependencies>
</project>
```

### 3.4 继承关系图示


```
                    父模块 (microservice-parent)
                           │
                    ┌──────┼──────┐
                    │      │      │
              common-module │  web-module
                           │
                    ┌──────┼──────┐  
                    │      │      │
               core-module │  api-module
                           │
                    其他子模块...

继承内容：
- 版本信息 (version)
- 依赖管理 (dependencyManagement)
- 插件配置 (pluginManagement)  
- 项目属性 (properties)
```

---

## 4. 🎯 核心模块划分策略


### 4.1 common/公共模块


**🔸 作用说明**
`common`模块就像一个**工具箱**，存放所有模块都可能用到的通用工具和基础组件。

**📦 包含内容**
- **工具类**：日期处理、字符串操作、加密解密等
- **基础异常**：自定义异常类
- **常量定义**：系统级别的常量
- **通用配置**：日志配置、基础注解等

```java
// 示例：公共工具类
public class DateUtils {
    public static String formatDate(Date date) {
        // 日期格式化逻辑
    }
}

// 示例：自定义异常
public class BusinessException extends RuntimeException {
    private int code;
    private String message;
}
```

### 4.2 core/核心模块


**🔸 作用说明**
`core`模块是系统的**大脑**，包含核心业务逻辑，不依赖于具体的展示方式。

**📦 包含内容**
- **实体类**：业务对象定义
- **业务服务**：核心业务逻辑
- **数据访问**：Repository/DAO层
- **领域模型**：业务规则和约束

```java
// 示例：核心业务服务
@Service
public class UserService {
    public User createUser(String username, String email) {
        // 核心业务逻辑：用户创建
        // 验证、处理、保存
    }
}
```

### 4.3 web/接口模块


**🔸 作用说明**
`web`模块是系统的**门面**，负责对外提供HTTP接口，处理用户请求。

**📦 包含内容**
- **控制器**：REST API接口
- **请求响应**：DTO对象
- **参数验证**：输入参数校验
- **异常处理**：全局异常处理

```java
// 示例：Web控制器
@RestController
public class UserController {
    @PostMapping("/users")
    public Result<User> createUser(@RequestBody CreateUserRequest request) {
        // 调用core模块的业务逻辑
        User user = userService.createUser(request.getUsername(), request.getEmail());
        return Result.success(user);
    }
}
```

### 4.4 api/接口定义模块


**🔸 作用说明**
`api`模块是系统的**合同**，定义了系统对外提供的接口规范。

**📦 包含内容**
- **接口定义**：Service接口
- **数据传输对象**：DTO/VO类
- **接口文档**：API说明文档
- **版本管理**：API版本控制

### 4.5 模块依赖关系图


```
                        依赖关系流向图
                             
    web-module  ────────┐
        │               │
        ▼               ▼
    core-module ──► common-module ◄── api-module
        │                              │
        └──────────────────────────────┘

说明：
• web-module：依赖 core-module 和 common-module
• core-module：依赖 common-module 和 api-module  
• api-module：依赖 common-module
• common-module：不依赖其他模块（基础模块）
```

### 4.6 模块划分最佳实践


**✅ 正确的划分方式**
```
按职责分离：
- common：通用工具（人人都用）
- core：业务逻辑（系统核心）
- web：接口层（对外门面）
- api：接口定义（规范合同）

按层次分离：
- 上层依赖下层
- 下层不知道上层
- 避免循环依赖
```

**❌ 错误的划分方式**
```
按功能分离：
- user-module（用户模块）
- order-module（订单模块）
× 这样分离在微服务中更合适，单体应用中会增加复杂度

按技术分离：
- dao-module（数据库模块）
- util-module（工具模块）
× 这样分离缺乏业务内聚性
```

---

## 5. 📋 依赖版本统一管理


### 5.1 dependencyManagement 的作用


**🔸 什么是 dependencyManagement**
`dependencyManagement` 就像是一个**版本字典**，它告诉所有子模块："如果你要用这个依赖，就用我指定的版本"。

**💡 生活类比**
```
想象你是一个大型连锁餐厅的总经理：

没有统一管理 = 各个分店自己采购食材
- A店用的番茄酱是1.0版本
- B店用的番茄酱是2.0版本  
- C店用的番茄酱是1.5版本
→ 结果：口味不一致，管理混乱

有统一管理 = 总部统一采购标准
- 总部规定：番茄酱统一用2.0版本
- 各分店按标准使用
→ 结果：口味一致，管理规范
```

### 5.2 父模块版本管理配置


```xml
<!-- 父模块的版本统一管理 -->
<project>
    <properties>
        <!-- 版本号定义 -->
        <spring.boot.version>2.7.0</spring.boot.version>
        <mysql.connector.version>8.0.28</mysql.connector.version>
        <lombok.version>1.18.24</lombok.version>
        <hutool.version>5.8.3</hutool.version>
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <!-- Spring Boot BOM -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring.boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            
            <!-- MySQL驱动版本 -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql.connector.version}</version>
            </dependency>
            
            <!-- Lombok版本 -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

### 5.3 子模块中的使用


```xml
<!-- 子模块中引用依赖（不需要写版本号） -->
<dependencies>
    <!-- 版本由父模块管理 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <!-- 不写version，自动使用父模块定义的版本 -->
    </dependency>
    
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <!-- 不写version，使用父模块指定的8.0.28版本 -->
    </dependency>
</dependencies>
```

### 5.4 版本管理的好处


**🎯 统一管理的优势**
- **避免冲突**：所有模块使用相同版本，避免jar包冲突
- **升级简单**：只需要在父模块修改一处，所有子模块自动生效
- **管理清晰**：版本信息集中管理，一目了然
- **减少错误**：避免子模块使用不兼容的版本

### 5.5 版本冲突处理


**⚠️ 常见版本冲突场景**
```
场景：A模块用Spring Boot 2.6.0，B模块用Spring Boot 2.7.0

问题：
- 运行时可能出现方法找不到
- 配置文件格式不兼容  
- 功能行为不一致

解决：
- 在父模块统一指定Spring Boot版本
- 所有子模块自动使用统一版本
```

---

## 6. 📦 可执行JAR构建原理


### 6.1 什么是可执行JAR


**🔸 传统JAR vs 可执行JAR**
```
传统JAR包：
- 只包含自己的代码
- 需要外部提供依赖库
- 不能直接运行

可执行JAR包（Fat JAR）：
- 包含自己的代码 + 所有依赖库
- 自包含，可以独立运行  
- 一个文件搞定所有依赖
```

**💡 生活类比**
```
传统JAR = 只带了主菜的套餐
- 你点了一个汉堡
- 但是需要自己准备面包、蔬菜、酱料
- 麻烦且容易缺东西

可执行JAR = 完整的套餐盒
- 汉堡、薯条、可乐、餐具全部包含
- 拿到就能直接吃
- 方便且不会缺东西
```

### 6.2 Spring Boot 打包插件


```xml
<!-- Spring Boot Maven插件配置 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <version>${spring.boot.version}</version>
            <configuration>
                <!-- 指定主启动类 -->
                <mainClass>com.example.Application</mainClass>
                <!-- 包含所有依赖 -->
                <includeSystemScope>true</includeSystemScope>
            </configuration>
            <executions>
                <execution>
                    <goals>
                        <goal>repackage</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

### 6.3 可执行JAR内部结构


```
my-app.jar                     ← 可执行JAR包
├── META-INF/
│   ├── MANIFEST.MF           ← 清单文件（指定启动类）
│   └── maven/               
├── BOOT-INF/
│   ├── classes/              ← 你的应用代码
│   │   └── com/example/
│   ├── lib/                  ← 所有依赖的JAR包
│   │   ├── spring-core-5.3.21.jar
│   │   ├── mysql-connector-8.0.28.jar
│   │   └── ...
│   └── classpath.idx         ← 类路径索引
└── org/
    └── springframework/
        └── boot/loader/      ← Spring Boot启动器类
```

### 6.4 启动原理解析


**🔸 启动流程**
```
步骤1：java -jar my-app.jar
      ↓
步骤2：读取MANIFEST.MF找到Main-Class  
      ↓
步骤3：启动Spring Boot Loader
      ↓  
步骤4：Loader加载BOOT-INF/lib下的所有JAR
      ↓
步骤5：创建自定义ClassLoader
      ↓
步骤6：启动你的主应用类
```

**📋 MANIFEST.MF 文件内容**
```
Manifest-Version: 1.0
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: com.example.Application
Spring-Boot-Version: 2.7.0
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
```

### 6.5 构建命令


```bash
# Maven构建
mvn clean package

# 生成的文件
target/
├── my-app-1.0.0.jar          ← 原始JAR（不可执行）
└── my-app-1.0.0.jar.original ← 可执行JAR

# 运行可执行JAR
java -jar target/my-app-1.0.0.jar

# 指定配置文件
java -jar my-app.jar --spring.config.location=config/application.yml

# 指定启动参数
java -Xms512m -Xmx1024m -jar my-app.jar
```

---

## 7. 🔧 构建工具选择指南


### 7.1 Maven vs Gradle 对比


| **对比维度** | **Maven** | **Gradle** |
|-------------|-----------|------------|
| **📖 学习难度** | `XML配置，相对简单` | `DSL语法，灵活但复杂` |
| **⚡ 构建速度** | `较慢` | `增量构建，更快` |
| **🎯 项目生态** | `生态成熟，插件丰富` | `新兴但发展迅速` |
| **📋 配置文件** | `pom.xml` | `build.gradle` |
| **🏢 企业采用** | `广泛使用，业界标准` | `Google、Spring官方推荐` |

### 7.2 Maven 配置示例


**🔸 父模块 pom.xml**
```xml
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>microservice-parent</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>
    
    <modules>
        <module>common-module</module>
        <module>core-module</module>
        <module>web-module</module>
    </modules>
    
    <properties>
        <java.version>11</java.version>
        <spring.boot.version>2.7.0</spring.boot.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
</project>
```

### 7.3 Gradle 配置示例


**🔸 根项目 build.gradle**
```gradle
// 定义子项目
subprojects {
    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    
    // 统一版本管理
    ext {
        springBootVersion = '2.7.0'
        mysqlVersion = '8.0.28'
    }
    
    // 公共依赖
    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
    }
}
```

**🔸 settings.gradle**
```gradle
rootProject.name = 'microservice-parent'

include 'common-module'
include 'core-module'
include 'web-module'
include 'api-module'
```

### 7.4 选择建议


**✅ 选择Maven的场景**
- 团队对Maven更熟悉
- 项目结构相对固定
- 需要稳定的构建环境
- 企业级项目，需要成熟生态

**✅ 选择Gradle的场景**  
- 构建速度要求高
- 需要复杂的构建逻辑
- 团队技术能力较强
- Android开发项目

### 7.5 构建优化技巧


**🚀 Maven构建优化**
```xml
<!-- 并行构建 -->
<properties>
    <maven.build.threads>4</maven.build.threads>
</properties>

<!-- 跳过测试加速构建 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
        <skipTests>true</skipTests>
    </configuration>
</plugin>
```

**🚀 Gradle构建优化**
```gradle
// gradle.properties
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.daemon=true

// 并行构建
gradle build --parallel

// 构建缓存
gradle build --build-cache
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 项目骨架：决定项目组织结构的基础框架
🔸 多模块拆分：按职责和层次划分项目模块
🔸 父子关系：父模块统一管理，子模块继承配置
🔸 模块职责：common/core/web/api各模块的明确分工  
🔸 版本管理：dependencyManagement统一版本控制
🔸 可执行JAR：包含所有依赖的独立运行包
🔸 构建工具：Maven/Gradle的选择和配置
```

### 8.2 关键理解要点


**🔹 为什么要多模块**
```
职责分离：
- 不同模块负责不同功能
- 降低模块间的耦合度
- 提高代码的可维护性

团队协作：  
- 不同团队开发不同模块
- 减少代码冲突
- 提高开发效率

复用和扩展：
- 公共代码可以被多个模块使用  
- 新功能可以通过添加模块实现
- 便于系统的横向扩展
```

**🔹 模块划分原则**
```
单一职责：
- 每个模块只负责一类功能
- 避免模块功能过于复杂

低耦合高内聚：
- 模块间依赖关系清晰简单
- 模块内部功能紧密相关

分层依赖：
- 上层模块依赖下层模块
- 避免循环依赖
- 保持依赖关系的清晰
```

### 8.3 实际应用指导


**🎯 项目搭建步骤**
```
步骤1：创建父项目
- 定义 packaging 为 pom
- 配置 modules 列表
- 设置公共属性和依赖管理

步骤2：创建子模块
- 设置 parent 继承关系
- 定义模块特有依赖
- 实现模块功能

步骤3：配置构建
- 选择合适的构建工具
- 配置可执行JAR打包
- 设置构建优化参数
```

**🔧 常见问题解决**
```
版本冲突：
- 在父模块统一管理版本
- 使用 dependencyManagement
- 避免子模块随意指定版本

循环依赖：
- 检查模块间依赖关系
- 重新设计模块职责
- 提取公共部分到独立模块

构建失败：
- 检查依赖配置是否正确
- 确认主启动类路径
- 验证插件配置
```

### 8.4 最佳实践建议


**✅ 推荐做法**
- 按业务职责划分模块，不是按技术层次
- 保持模块依赖关系简单清晰
- 使用统一的代码规范和工具版本
- 定期review和优化模块结构

**❌ 避免做法**
- 过度拆分导致模块过多过细
- 模块间存在循环依赖关系
- 不同模块使用不同版本的相同依赖
- 忽略模块间的接口设计

**核心记忆**：
- 多模块就像现代企业的部门分工，各司其职、协作高效
- 父子关系就像家庭规则，父模块制定标准，子模块继承遵守  
- 可执行JAR就像完整套餐，一个包含所有依赖，拿来就能用
- 构建工具选择要考虑团队熟悉程度和项目复杂度