---
title: 14、测试数据与Mock策略
---
## 📚 目录

1. [测试配置基础](#1-测试配置基础)
2. [Mock策略详解](#2-Mock策略详解)
3. [测试数据库配置](#3-测试数据库配置)
4. [容器化测试](#4-容器化测试)
5. [测试事务管理](#5-测试事务管理)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔧 测试配置基础


### 1.1 什么是测试配置


**📋 基本概念**
```
测试配置就像给你的代码准备一个"演习环境"
- 正式环境：真实的数据库、真实的服务
- 测试环境：模拟的数据库、模拟的服务
- 目的：让测试更快、更安全、更可控
```

**🎯 为什么需要测试配置**
> 就像演员排练需要道具一样，代码测试也需要"道具"——这些道具就是测试配置

### 1.2 @TestConfiguration 测试配置


**🔸 核心作用**
```
@TestConfiguration = 专门为测试准备的配置类
- 只在测试时生效
- 可以覆盖正式配置
- 提供测试专用的Bean
```

**💡 简单示例**
```java
// 测试专用配置类
@TestConfiguration
public class TestConfig {
    
    // 为测试提供一个假的邮件服务
    @Bean
    @Primary  // 优先使用这个Bean
    public EmailService emailService() {
        return new FakeEmailService(); // 假的邮件服务，不会真的发邮件
    }
    
    // 提供测试用的数据源
    @Bean
    public DataSource testDataSource() {
        return new H2DataSource(); // 内存数据库，速度快
    }
}
```

**🔄 配置原理图示**
```
正式环境配置：
┌─────────────────┐    ┌─────────────────┐
│   真实数据库     │    │   真实邮件服务   │
│  MySQL/Oracle   │    │   Gmail/QQ邮箱   │
└─────────────────┘    └─────────────────┘
         ↑                       ↑
    ┌─────────────────────────────────┐
    │        生产环境应用             │
    └─────────────────────────────────┘

测试环境配置：
┌─────────────────┐    ┌─────────────────┐
│   测试数据库     │    │   模拟邮件服务   │
│   H2内存库      │    │   不真实发送     │
└─────────────────┘    └─────────────────┘
         ↑                       ↑
    ┌─────────────────────────────────┐
    │        测试环境应用             │
    └─────────────────────────────────┘
```

**📝 使用场景对比**

| 场景 | **正式配置** | **测试配置** | **为什么这样做** |
|------|-------------|-------------|-----------------|
| 数据库 | `MySQL真实库` | `H2内存库` | `测试速度快，不污染真实数据` |
| 邮件服务 | `真实发送邮件` | `模拟发送` | `避免测试时发送垃圾邮件` |
| 外部API | `调用真实接口` | `返回固定数据` | `测试结果可预期，不依赖网络` |
| 文件存储 | `真实文件系统` | `内存存储` | `测试后自动清理，无副作用` |

---

## 2. 🎭 Mock策略详解


### 2.1 Mock的概念理解


**🔸 什么是Mock**
```
Mock = 模拟/替身
就像电影中的替身演员一样：
- 替身演员：代替真演员完成危险动作
- Mock对象：代替真实对象完成测试任务
```

**💡 生活化类比**
> 想象你要测试一个"取钱"功能，但不想真的从银行卡扣钱。Mock就像一个"假银行"，会按照你的要求返回"余额充足"或"余额不足"，但不会真的动你的钱。

### 2.2 @MockBean 模拟Bean


**🔸 基本用法**
```java
@SpringBootTest
public class UserServiceTest {
    
    @MockBean
    private EmailService emailService; // 创建一个假的邮件服务
    
    @Autowired
    private UserService userService; // 真实的用户服务（会使用假邮件服务）
    
    @Test
    public void testRegisterUser() {
        // 告诉假邮件服务：当发送邮件时，返回成功
        when(emailService.sendEmail(anyString(), anyString()))
            .thenReturn(true);
            
        // 测试用户注册
        boolean result = userService.registerUser("张三", "zhangsan@qq.com");
        
        // 验证结果
        assertTrue(result);
        
        // 验证邮件服务被调用了一次
        verify(emailService, times(1)).sendEmail(anyString(), anyString());
    }
}
```

**🔄 MockBean工作流程**
```
测试执行流程：
用户服务 ──调用──> 邮件服务(Mock)
    ↓                   ↓
 registerUser()    sendEmail() 
    ↓                   ↓
  执行注册逻辑      返回预设结果(true)
    ↓                   ↑
  收到邮件发送成功 ←──────┘
    ↓
  返回注册成功
```

**📊 Mock vs 真实对象对比**

| 特性 | **真实对象** | **Mock对象** |
|------|-------------|-------------|
| 🎯 **行为** | `执行真实逻辑` | `返回预设结果` |
| ⚡ **速度** | `可能很慢` | `极快响应` |
| 🔒 **控制性** | `结果不可控` | `结果完全可控` |
| 💾 **副作用** | `可能有副作用` | `无任何副作用` |
| 🌐 **依赖** | `需要外部资源` | `无外部依赖` |

### 2.3 @SpyBean 监听Bean


**🔸 Spy与Mock的区别**
```
Mock = 完全的假货（所有行为都是模拟的）
Spy = 真货+监控（大部分行为是真实的，但可以监控和部分替换）
```

**💡 形象比喻**
> Mock像是一个演员的替身，完全按剧本演出
> Spy像是给真演员装了个监控器，大部分时候是真演员在表演，但关键时刻可以"导演干预"

**🔧 SpyBean示例**
```java
@SpringBootTest
public class OrderServiceTest {
    
    @SpyBean
    private PaymentService paymentService; // 真实的支付服务+监控
    
    @Autowired
    private OrderService orderService;
    
    @Test
    public void testCreateOrder() {
        // 大部分方法用真实逻辑，但这个方法返回固定结果
        doReturn(true).when(paymentService).processPayment(anyDouble());
        
        // 测试创建订单
        Order order = orderService.createOrder("商品A", 100.0);
        
        // 验证支付方法被调用
        verify(paymentService).processPayment(100.0);
        
        // 其他方法如计算手续费等仍然使用真实逻辑
    }
}
```

**🔄 Spy工作机制**
```
OrderService 调用 PaymentService(Spy)
    ↓
┌─────────────────────────────┐
│       PaymentService        │
│  (真实对象+监控装置)          │
│                            │
│  processPayment() ← 被替换   │
│  calculateFee()   ← 真实逻辑 │
│  validateCard()   ← 真实逻辑 │
│  sendReceipt()    ← 真实逻辑 │
└─────────────────────────────┘
```

---

## 3. 💾 测试数据库配置


### 3.1 为什么需要测试数据库


**🎯 核心问题**
```
真实数据库的问题：
❌ 速度慢（磁盘IO）
❌ 数据污染（测试数据混入真实数据）
❌ 并发冲突（多人测试互相影响）
❌ 环境依赖（需要安装配置数据库）
```

**✅ 测试数据库的优势**
```
内存数据库的优势：
✅ 速度快（内存操作）
✅ 隔离性好（每次测试独立）
✅ 无副作用（测试结束自动清理）
✅ 零配置（无需安装）
```

### 3.2 H2数据库配置


**🔸 H2数据库特点**
```
H2 = 纯Java编写的内存数据库
特点：
- 轻量级：只有几MB大小
- 零配置：无需安装，引入依赖即可使用
- 兼容性好：支持标准SQL语法
- 模式丰富：可以模拟MySQL、Oracle等
```

**🔧 配置示例**
```yaml
# application-test.yml（测试环境配置）
spring:
  datasource:
    url: jdbc:h2:mem:testdb  # 内存数据库
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  jpa:
    hibernate:
      ddl-auto: create-drop  # 测试结束后自动删除表
    show-sql: true  # 显示SQL语句（方便调试）
  
  h2:
    console:
      enabled: true  # 启用H2控制台（可以查看数据）
```

**📊 数据库选择对比**

| 数据库类型 | **速度** | **配置复杂度** | **适用场景** |
|-----------|---------|---------------|-------------|
| 🚀 **H2内存** | `极快` | `零配置` | `单元测试、集成测试` |
| 💾 **H2文件** | `快` | `简单配置` | `需要数据持久化的测试` |
| 🐳 **TestContainers** | `中等` | `中等配置` | `真实环境模拟` |
| 🗄️ **真实数据库** | `慢` | `复杂配置` | `生产环境测试` |

### 3.3 测试数据准备策略


**🔸 数据准备方式**
```
方式1：@Sql注解（推荐新手使用）
方式2：@DataJpaTest + TestEntityManager
方式3：自定义数据工厂类
```

**💡 @Sql注解使用**
```java
@SpringBootTest
@Sql("/test-data.sql") // 测试前执行SQL文件
@Sql(scripts = "/cleanup.sql", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public class UserRepositoryTest {
    
    @Test
    public void testFindByEmail() {
        // test-data.sql已经插入了测试数据
        // 可以直接测试查询功能
    }
}
```

**📝 测试数据SQL示例**
```sql
-- test-data.sql
INSERT INTO users (id, name, email, status) VALUES 
(1, '张三', 'zhangsan@qq.com', 'ACTIVE'),
(2, '李四', 'lisi@qq.com', 'INACTIVE'),
(3, '王五', 'wangwu@qq.com', 'ACTIVE');

INSERT INTO orders (id, user_id, product_name, amount) VALUES
(1, 1, '苹果手机', 5999.00),
(2, 1, '苹果耳机', 1299.00),
(3, 2, '小米手机', 2999.00);
```

---

## 4. 🐳 容器化测试


### 4.1 TestContainers简介


**🔸 什么是TestContainers**
```
TestContainers = 用Docker容器进行测试
特点：
- 真实环境：使用真实的数据库、消息队列等
- 自动管理：自动启动和停止容器
- 隔离性好：每个测试用独立的容器
```

**💡 容器测试的优势**
> 就像在真实的舞台上彩排，而不是在排练厅里练习

```
传统测试 vs 容器测试：

传统测试（模拟环境）:
应用 ──> H2数据库（内存）
  ↓
有些数据库特性无法测试

容器测试（真实环境）:
应用 ──> MySQL容器（真实）
  ↓
可以测试所有数据库特性
```

### 4.2 TestContainers基本用法


**🔧 配置示例**
```java
@SpringBootTest
@Testcontainers  // 启用容器测试
public class DatabaseIntegrationTest {
    
    // 启动一个MySQL容器
    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    // 动态配置数据库连接
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);
    }
    
    @Test
    public void testDatabaseOperations() {
        // 这里的测试使用真实的MySQL数据库
        // 可以测试MySQL特有的功能，如JSON字段、全文搜索等
    }
}
```

**🔄 容器生命周期**
```
测试执行流程：
1. 测试开始
   ↓
2. 启动MySQL容器 (自动)
   ↓
3. 等待容器就绪
   ↓
4. 配置应用连接到容器
   ↓
5. 执行测试
   ↓
6. 测试结束
   ↓
7. 停止并删除容器 (自动)
```

**⚖️ 容器测试权衡考虑**

| 考虑因素 | **优势** | **劣势** |
|---------|---------|---------|
| 🎯 **真实性** | `完全真实的环境` | `启动时间较长` |
| 🔧 **功能测试** | `可测试所有特性` | `资源消耗较大` |
| 🚀 **CI/CD** | `容易集成` | `需要Docker环境` |
| 💰 **成本** | `发现更多问题` | `测试执行时间长` |

---

## 5. 🔄 测试事务管理


### 5.1 为什么需要事务回滚


**🔸 核心问题**
```
测试数据污染问题：
❌ 测试A插入数据 → 影响测试B的结果
❌ 测试失败后数据残留 → 影响后续测试
❌ 多次运行测试 → 数据越来越多
```

**✅ 事务回滚的好处**
```
每个测试都像"平行宇宙"：
✅ 测试开始 → 开启事务
✅ 执行测试 → 操作数据
✅ 测试结束 → 回滚事务（数据恢复原样）
```

### 5.2 @Transactional测试事务


**💡 事务回滚机制**
```java
@SpringBootTest
@Transactional  // 测试方法运行在事务中
public class UserServiceTransactionTest {
    
    @Autowired
    private UserService userService;
    
    @Test
    public void testCreateUser() {
        // 1. 事务开始
        
        // 2. 创建用户（数据写入数据库）
        User user = userService.createUser("测试用户", "test@qq.com");
        assertNotNull(user.getId());
        
        // 3. 验证用户已创建
        User found = userService.findById(user.getId());
        assertEquals("测试用户", found.getName());
        
        // 4. 测试结束，事务自动回滚
        // 5. 数据库恢复到测试前的状态
    }
    
    @Test
    public void testUpdateUser() {
        // 这个测试看不到上一个测试创建的用户
        // 因为上一个测试的数据已经回滚了
    }
}
```

**🔄 事务回滚流程图**
```
测试事务生命周期：

测试开始
   ↓
┌─────────────────┐
│  开启事务        │ ← @Transactional
└─────────────────┘
   ↓
┌─────────────────┐
│  执行测试代码    │ ── 数据操作都在事务内
└─────────────────┘
   ↓
┌─────────────────┐
│  测试完成        │
└─────────────────┘
   ↓
┌─────────────────┐
│  自动回滚事务    │ ← 数据库恢复原状
└─────────────────┘
   ↓
准备下一个测试
```

### 5.3 @Rollback控制回滚行为


**🔧 回滚控制**
```java
@SpringBootTest
public class TransactionControlTest {
    
    @Test
    @Transactional
    @Rollback(false)  // 不回滚，数据会保留
    public void testCreateTestData() {
        // 这个测试的数据会保留，可以用来准备测试数据
        userService.createUser("永久测试用户", "permanent@test.com");
    }
    
    @Test
    @Transactional
    // 默认 @Rollback(true)，会自动回滚
    public void testNormalOperation() {
        // 这个测试的数据会自动清理
    }
    
    @Test
    @Transactional
    @Commit  // 等同于 @Rollback(false)
    public void testDataSetup() {
        // 另一种方式指定不回滚
    }
}
```

**📊 回滚策略选择**

| 测试类型 | **回滚设置** | **使用场景** | **注意事项** |
|---------|-------------|-------------|-------------|
| 🧪 **单元测试** | `@Rollback(true)` | `测试业务逻辑` | `默认选择，保持环境干净` |
| 🔧 **数据准备** | `@Rollback(false)` | `准备测试数据` | `需要手动清理数据` |
| 📊 **性能测试** | `@Rollback(false)` | `需要大量数据` | `测试后清理数据库` |
| 🔍 **调试测试** | `@Rollback(false)` | `查看测试数据` | `临时使用，记得改回来` |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 测试配置：@TestConfiguration 为测试准备专用配置
🔸 Mock策略：@MockBean 创建假对象，@SpyBean 监控真对象
🔸 测试数据库：H2内存数据库，快速、干净、零配置
🔸 容器测试：TestContainers 提供真实环境测试
🔸 事务回滚：@Transactional 确保测试数据不污染
```

### 6.2 关键理解要点


**🔹 何时使用Mock vs Spy**
```
选择Mock：
✅ 外部服务（邮件、短信、支付）
✅ 耗时操作（文件上传、网络请求）
✅ 不可控结果（随机数、时间戳）

选择Spy：
✅ 部分功能需要真实逻辑
✅ 只需要监控方法调用
✅ 大部分功能正常，少数需要替换
```

**🔹 数据库测试策略**
```
开发阶段：H2内存数据库
- 速度快，适合频繁测试

集成阶段：TestContainers
- 真实环境，发现兼容性问题

发布前：真实数据库
- 最终验证，确保生产环境正常
```

### 6.3 最佳实践建议


**🎯 测试编写原则**
```
FIRST原则：
F - Fast（快速）：测试要快，使用内存数据库
I - Independent（独立）：测试之间不相互影响
R - Repeatable（可重复）：任何环境都能重复运行
S - Self-Validating（自验证）：明确的成功/失败标准
T - Timely（及时）：及时编写测试，不要事后补
```

**🔧 实用测试模板**
```java
// 标准测试类模板
@SpringBootTest
@ActiveProfiles("test")  // 使用测试配置
@Transactional          // 自动回滚
public class ServiceTest {
    
    @MockBean
    private ExternalService externalService; // Mock外部依赖
    
    @Autowired
    private BusinessService businessService; // 被测试的服务
    
    @BeforeEach
    void setUp() {
        // 准备测试数据和Mock行为
    }
    
    @Test
    void should_ReturnSuccess_When_ValidInput() {
        // Given - 准备数据
        // When - 执行操作
        // Then - 验证结果
    }
}
```

**💡 调试技巧**
```
遇到测试问题时：
1. 查看测试日志：show-sql: true
2. 使用H2控制台：查看数据状态
3. 禁用事务回滚：@Rollback(false)
4. 单步调试：在IDE中打断点
5. 简化测试：先写最简单的case
```

### 6.4 常见问题与解决


**❓ 常见问题清单**

| 问题 | **原因** | **解决方案** |
|------|---------|-------------|
| 🐛 **测试数据互相影响** | `没有使用事务回滚` | `添加@Transactional` |
| 🚫 **Mock不生效** | `没有用@MockBean注解` | `检查注解和导入` |
| 💾 **数据库连接失败** | `配置文件错误` | `检查test配置文件` |
| ⏰ **测试运行很慢** | `使用了真实数据库` | `改用H2内存数据库` |
| 🔄 **容器启动失败** | `Docker环境问题` | `检查Docker是否运行` |

**🎓 学习路径建议**
```
新手学习顺序：
1️⃣ 先掌握@MockBean和@Transactional
2️⃣ 学会配置H2测试数据库
3️⃣ 了解@TestConfiguration的使用
4️⃣ 进阶学习TestContainers
5️⃣ 最后学习复杂的测试策略
```

**核心记忆口诀**：
- 测试配置专用途，Mock模拟真替身
- 数据库用H2快，事务回滚保干净
- 容器测试环境真，质量保证靠测试