---
title: 6、Prometheus与Grafana集成
---
## 📚 目录

1. [监控系统概述](#1-监控系统概述)
2. [Prometheus集成配置](#2-Prometheus集成配置)  
3. [Grafana仪表盘搭建](#3-Grafana仪表盘搭建)
4. [常用监控面板配置](#4-常用监控面板配置)
5. [告警规则设置](#5-告警规则设置)
6. [SLO/SLA指标定义](#6-SLO-SLA指标定义)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 监控系统概述


### 1.1 什么是应用监控


**🎯 监控的本质**
监控就像给你的应用装了一个"体检仪"，随时告诉你应用的健康状况。想象一下：
- 你开车时需要看仪表盘（速度、油量、水温）
- 应用运行时也需要看"仪表盘"（CPU、内存、请求量、错误率）

**💡 为什么需要监控**
```
没有监控的应用 = 蒙着眼睛开车
- 不知道系统负载高不高
- 不知道哪里出了问题  
- 用户投诉了才知道系统挂了
- 问题排查全靠猜

有监控的应用 = 开着导航开车
- 实时掌握系统状态
- 问题早发现早处理
- 性能瓶颈一目了然
- 用数据说话，不再靠感觉
```

### 1.2 监控体系架构


**🏗️ 完整监控链路**
```
Spring Boot应用
       ↓ (暴露指标)
   /actuator/prometheus端点
       ↓ (数据抓取)
    Prometheus服务器
       ↓ (数据查询)
    Grafana仪表盘
       ↓ (可视化展示)
    运维人员/开发人员
```

**🔸 各组件职责分工**

| 组件 | **作用** | **比喻** |
|------|----------|----------|
| `Spring Boot Actuator` | 暴露应用指标 | 汽车的传感器，收集各种数据 |
| `Prometheus` | 收集存储指标 | 数据仓库，定期去各个地方收集数据 |
| `Grafana` | 数据可视化 | 仪表盘，把数据变成好看的图表 |
| `AlertManager` | 告警通知 | 警报系统，有问题就通知相关人员 |

### 1.3 监控指标分类


**📊 四大监控维度（RED方法）**
```
🔸 Request Rate（请求速率）
- QPS：每秒处理多少个请求
- TPS：每秒处理多少个事务
- 就像统计超市每分钟进来多少顾客

🔸 Error Rate（错误率）  
- 错误请求占总请求的比例
- HTTP 4xx、5xx错误数量
- 就像统计超市收银出错的比例

🔸 Duration（响应时间）
- 平均响应时间、99分位响应时间
- 就像统计顾客排队等待的时间

🔸 Saturation（饱和度）
- CPU使用率、内存使用率
- 就像统计超市的繁忙程度
```

---

## 2. ⚙️ Prometheus集成配置


### 2.1 什么是Prometheus


**🔸 Prometheus简介**
```
Prometheus是一个开源的系统监控工具，就像一个勤劳的数据收集员：
- 定时去各个应用"询问"：你现在状态如何？
- 把收集的数据存储起来
- 提供查询接口给其他工具使用

核心特点：
✅ Pull模式：主动拉取数据，不用应用推送
✅ 时间序列：按时间顺序存储数据，可以看趋势
✅ 强大查询：支持复杂的数据查询和计算
✅ 高可用：支持集群部署
```

### 2.2 添加Prometheus依赖


**🔧 项目配置**
首先在Spring Boot项目中添加必要的依赖：

```xml
<dependencies>
    <!-- Spring Boot Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Micrometer Prometheus -->
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>
</dependencies>
```

**💡 依赖说明**
- `actuator`：Spring Boot的监控端点
- `micrometer-registry-prometheus`：将监控数据转换成Prometheus格式

### 2.3 配置Prometheus端点


**📝 application.yml配置**
```yaml
# 管理端点配置
management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,prometheus"  # 暴露需要的端点
      base-path: "/actuator"  # 端点基础路径
  endpoint:
    prometheus:
      enabled: true  # 启用prometheus端点
    health:
      show-details: always  # 显示详细健康信息
  
  # 指标配置
  metrics:
    tags:
      application: "my-service"  # 为所有指标添加应用标签
      environment: "production"   # 环境标签
```

**🔍 配置解释**
```
🔸 include: "prometheus" 
- 暴露/actuator/prometheus端点
- 这个端点提供Prometheus格式的监控数据

🔸 show-details: always
- health端点显示详细信息
- 包括数据库连接、磁盘空间等状态

🔸 tags配置
- 给所有指标加上统一标签
- 便于在Grafana中区分不同应用和环境
```

### 2.4 验证端点配置


**🧪 测试配置是否生效**

启动应用后，访问以下端点验证：

| 端点 | **URL** | **用途** |
|------|---------|----------|
| 健康检查 | `http://localhost:8080/actuator/health` | 查看应用健康状态 |
| 指标概览 | `http://localhost:8080/actuator/metrics` | 查看所有可用指标 |
| **Prometheus数据** | `http://localhost:8080/actuator/prometheus` | **Prometheus格式的监控数据** |

**📊 Prometheus端点数据示例**
访问`/actuator/prometheus`会看到类似这样的数据：
```
# HELP jvm_memory_used_bytes The amount of used memory
# TYPE jvm_memory_used_bytes gauge
jvm_memory_used_bytes{application="my-service",area="heap",id="PS Eden Space"} 1.2345678E7

# HELP http_server_requests_seconds  
# TYPE http_server_requests_seconds summary
http_server_requests_seconds_count{application="my-service",method="GET",status="200",uri="/api/users"} 1547.0
http_server_requests_seconds_sum{application="my-service",method="GET",status="200",uri="/api/users"} 15.274
```

> 💡 **小贴士**：这些看起来复杂的数据，Prometheus会自动解析并存储，你不需要手动处理

---

## 3. 📊 Grafana仪表盘搭建


### 3.1 什么是Grafana


**🎨 Grafana的作用**
```
如果说Prometheus是数据仓库，那Grafana就是数据的"美工师"：
- 把枯燥的数字变成直观的图表
- 把复杂的趋势变成一目了然的曲线
- 把散乱的指标整理成专业的仪表盘

就像把Excel表格数据做成PPT图表一样！
```

### 3.2 Docker快速部署


**🐳 使用Docker Compose快速搭建**
```yaml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
    volumes:
      - grafana-storage:/var/lib/grafana

volumes:
  grafana-storage:
```

### 3.3 Prometheus配置


**📝 prometheus.yml配置文件**
```yaml
global:
  scrape_interval: 15s  # 每15秒抓取一次数据

scrape_configs:
  - job_name: 'spring-boot-app'
    static_configs:
      - targets: ['host.docker.internal:8080']  # Spring Boot应用地址
    metrics_path: '/actuator/prometheus'  # 抓取路径
    scrape_interval: 10s  # 这个应用10秒抓取一次
```

**🔍 配置说明**
```
🔸 scrape_interval: 15s
- Prometheus多久去"询问"一次应用状态
- 类似体检频率，15秒检查一次

🔸 targets: ['host.docker.internal:8080']  
- 告诉Prometheus去哪里收集数据
- host.docker.internal是Docker访问宿主机的地址

🔸 metrics_path: '/actuator/prometheus'
- 具体的数据接口路径
- 就像告诉快递员具体送到哪个门牌号
```

### 3.4 Grafana初始化


**🚀 首次登录配置**
1. **访问Grafana**：浏览器打开`http://localhost:3000`
2. **登录账号**：用户名`admin`，密码`admin123`
3. **添加数据源**：
   - 点击设置图标 → Data Sources → Add data source
   - 选择Prometheus
   - URL填写：`http://prometheus:9090`
   - 点击"Save & Test"测试连接

> ⚠️ **注意**：因为使用Docker Compose，Grafana访问Prometheus使用服务名`prometheus`

**✅ 验证连接成功**
连接成功会显示绿色的"Data source is working"提示。

---

## 4. 📈 常用监控面板配置


### 4.1 JVM监控面板


**🔧 创建JVM监控仪表盘**

**内存使用情况面板**
```
面板类型：Graph/Time Series
查询语句：sum(jvm_memory_used_bytes{application="my-service"}) by (area)
标题：JVM内存使用情况
说明：监控堆内存和非堆内存的使用情况
```

**垃圾回收面板**
```
面板类型：Stat
查询语句：rate(jvm_gc_pause_seconds_count{application="my-service"}[5m])
标题：GC频率（次/秒）  
说明：监控垃圾回收的频率，频率过高说明内存压力大
```

### 4.2 HTTP请求监控面板


**📊 请求量监控**
```
┌─────────────────────────────────┐
│        HTTP请求量趋势图          │
│   ┌─┐                          │
│ 100│ │    ┌─┐                   │
│    │ │    │ │  ┌─┐               │
│  50│ │    │ │  │ │               │  
│    │ └─┐  │ │  │ │               │
│   0└───┴──┴─┴──┴─┴──────────────┤
│     9:00   10:00   11:00        │
└─────────────────────────────────┘
```

**配置参数**
```yaml
面板配置：
  类型: Time Series
  查询: sum(rate(http_server_requests_seconds_count{application="my-service"}[5m])) by (method, status)
  说明: 按HTTP方法和状态码分组显示请求速率
  Y轴: requests/second
  图例: {{method}} - {{status}}
```

**🔥 关键指标说明**
- `rate()`函数：计算每秒的增长率
- `[5m]`：基于最近5分钟的数据计算
- `by (method, status)`：按请求方法和状态码分组

### 4.3 响应时间监控面板


**⏱️ 响应时间分位数**
```
面板类型：Graph
查询语句：
  - P99: histogram_quantile(0.99, sum(rate(http_server_requests_seconds_bucket{application="my-service"}[5m])) by (le))
  - P95: histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket{application="my-service"}[5m])) by (le))  
  - P50: histogram_quantile(0.50, sum(rate(http_server_requests_seconds_bucket{application="my-service"}[5m])) by (le))
```

**💡 分位数解释**
```
P99: 99%的请求响应时间都在这个值以下
P95: 95%的请求响应时间都在这个值以下  
P50: 50%的请求响应时间都在这个值以下（中位数）

举例：P99 = 500ms 意思是99%的用户请求都在500ms内得到响应
```

### 4.4 系统资源监控面板  


**💻 CPU使用率**
```yaml
面板配置：
  类型: Gauge (仪表盘)
  查询: system_cpu_usage{application="my-service"} * 100
  单位: percent (0-100)
  阈值设置:
    - 绿色: 0-70%
    - 黄色: 70-85%  
    - 红色: 85-100%
```

**📊 系统负载概览**
```
┌──────────────────────────────────────────┐
│              系统负载概览                 │
├──────────────┬──────────────┬─────────────┤
│   CPU使用率   │   内存使用率  │  磁盘使用率  │
│              │              │             │
│    ⭕ 45%    │    ⭕ 62%    │   ⭕ 23%    │
│              │              │             │
├──────────────┼──────────────┼─────────────┤
│   JVM堆内存   │   活跃线程数  │   数据库连接 │
│              │              │             │
│   ⭕ 78%     │    📊 45     │   ✅ 正常    │
└──────────────┴──────────────┴─────────────┘
```

---

## 5. 🚨 告警规则设置


### 5.1 告警系统架构


**📢 告警流程**
```
监控指标异常
       ↓
Prometheus评估告警规则  
       ↓
触发告警 → AlertManager
       ↓
发送通知（邮件/钉钉/微信）
       ↓  
相关人员收到告警
```

### 5.2 Prometheus告警规则


**⚠️ 创建告警规则文件 alerts.yml**
```yaml
groups:
  - name: spring-boot-alerts
    rules:
      # 应用服务不可用告警
      - alert: ServiceDown
        expr: up{job="spring-boot-app"} == 0
        for: 1m
        labels:
          severity: critical
          team: backend
        annotations:
          summary: "Spring Boot应用服务不可用"
          description: "应用 {{$labels.instance}} 已经下线超过1分钟"

      # 高错误率告警  
      - alert: HighErrorRate
        expr: rate(http_server_requests_seconds_count{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
          team: backend
        annotations:
          summary: "HTTP错误率过高"
          description: "应用 {{$labels.application}} 5xx错误率超过10%"

      # 响应时间过慢告警
      - alert: SlowResponse  
        expr: histogram_quantile(0.99, sum(rate(http_server_requests_seconds_bucket[5m])) by (le)) > 2
        for: 3m
        labels:
          severity: warning
          team: backend
        annotations:
          summary: "响应时间过慢"
          description: "P99响应时间超过2秒，当前值: {{$value}}s"
```

### 5.3 告警规则详解


**🔍 规则组成部分**
```
🔸 alert: 告警名称
- 给告警起个容易识别的名字

🔸 expr: 告警条件  
- 什么情况下触发告警
- 使用PromQL查询语言

🔸 for: 持续时间
- 条件满足多长时间后才发送告警
- 避免偶发性问题导致的误报

🔸 labels: 告警标签
- severity: 告警级别（critical/warning/info）
- team: 负责团队

🔸 annotations: 告警描述
- summary: 简短摘要
- description: 详细描述，可以使用变量
```

### 5.4 常用告警场景


**📋 推荐告警规则**

| 告警类型 | **触发条件** | **告警级别** | **说明** |
|----------|-------------|-------------|----------|
| 服务下线 | `up == 0` | 🔴 Critical | 应用完全不可访问 |
| 高错误率 | `5xx错误率 > 5%` | 🟡 Warning | 系统异常，需要关注 |
| 响应缓慢 | `P99 > 3秒` | 🟡 Warning | 用户体验下降 |
| 内存不足 | `JVM堆内存 > 90%` | 🟡 Warning | 可能出现OOM |
| CPU过高 | `CPU > 80%` | 🟡 Warning | 系统负载过高 |

> 💡 **告警设置原则**：宁可少报也不要误报，频繁的误报会让人忽视真正的问题

---

## 6. 📏 SLO/SLA指标定义


### 6.1 SLO与SLA概念


**🎯 概念区别**
```
SLA (Service Level Agreement) - 服务级别协议  
- 对外承诺：我们向用户/客户保证的服务水平
- 法律约束：写进合同里的，违反要赔钱
- 例子：承诺99.9%的可用性，每月故障时间不超过43分钟

SLO (Service Level Objective) - 服务级别目标
- 内部目标：我们团队内部设定的服务目标  
- 技术指标：用来指导技术团队工作的具体数值
- 例子：P99响应时间小于200ms，错误率小于0.1%
```

**💡 通俗理解**
```
想象你开了一家快餐店：

SLA = 对顾客的承诺
- "我们承诺5分钟内出餐，超时免费"
- 这是写在菜单上，对顾客的正式承诺

SLO = 内部管理目标  
- "厨师目标3分钟内完成制作"
- "收银员目标30秒内完成点餐"
- 这是内部管理用的具体指标
```

### 6.2 核心SLO指标


**📊 可用性指标**
```yaml
可用性 SLO:
  目标: 99.9% (每月允许停机43分钟)
  计算公式: 
    availability = (total_time - downtime) / total_time * 100%
  
  Prometheus查询:
    up{job="spring-boot-app"}
  
  监控维度:
    - 服务是否响应 (HTTP 200状态)
    - 健康检查是否通过
    - 核心功能是否正常
```

**⚡ 性能指标** 
```yaml
响应时间 SLO:
  目标: 
    - P95 < 500ms (95%的请求500ms内响应)
    - P99 < 1000ms (99%的请求1秒内响应)
  
  Prometheus查询:
    # P95响应时间
    histogram_quantile(0.95, 
      sum(rate(http_server_requests_seconds_bucket[5m])) by (le)
    )
    
    # P99响应时间  
    histogram_quantile(0.99,
      sum(rate(http_server_requests_seconds_bucket[5m])) by (le)
    )
```

**🎯 准确性指标**
```yaml
错误率 SLO:
  目标: < 0.1% (1000个请求中最多1个错误)
  
  计算公式:
    error_rate = error_requests / total_requests * 100%
  
  Prometheus查询:
    # 总体错误率
    sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) / 
    sum(rate(http_server_requests_seconds_count[5m])) * 100
    
    # 按接口分组的错误率
    sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) by (uri) /
    sum(rate(http_server_requests_seconds_count[5m])) by (uri) * 100
```

### 6.3 SLO监控仪表盘


**📈 SLO Dashboard设计**
```
┌─────────────────────────────────────────────────────┐
│                 SLO监控仪表盘                        │
├─────────────────┬─────────────────┬─────────────────┤
│   可用性 SLO     │   性能 SLO       │   准确性 SLO     │
│                │                │                │
│  ✅ 99.95%     │  ⚠️  P95: 650ms │  ✅ 0.05%      │
│  目标: 99.9%   │  目标: 500ms    │  目标: 0.1%     │
│  ✅ 达标       │  ❌ 超标        │  ✅ 达标        │
├─────────────────┼─────────────────┼─────────────────┤
│              本月SLO达标情况趋势图                   │
│   100% ┌─┐                                        │
│        │ │    ┌─┐                                 │
│    99% │ │────│ │──┐                              │
│        │ │    │ │  │                              │
│    98% └─┘    └─┘  └──────────────────────────────│
│        1日    10日   20日   30日                    │
└─────────────────────────────────────────────────────┘
```

### 6.4 错误预算概念


**💰 错误预算 (Error Budget)**
```
错误预算 = SLO允许的最大错误量

举例说明：
如果可用性SLO是99.9%，那么：
- 错误预算 = 100% - 99.9% = 0.1%
- 每月允许故障时间 = 30天 × 24小时 × 0.1% = 43.2分钟

错误预算的作用：
✅ 平衡可靠性与新功能开发
✅ 量化风险承受能力  
✅ 指导发布决策

错误预算使用策略：
🔸 预算充足：可以加快功能迭代
🔸 预算不足：专注可靠性改进，暂停非关键功能
🔸 预算耗尽：停止发布，全力修复问题
```

**📊 错误预算监控**
```yaml
错误预算消耗率:
  计算公式: (实际错误率 / SLO错误率) * 100%
  
  示例:
    - SLO错误率: 0.1%
    - 实际错误率: 0.05%  
    - 预算消耗率: 50% (还剩50%预算)
    
  Grafana面板:
    类型: Gauge
    查询: 实际错误率监控查询
    阈值: 
      - 绿色: 0-70% (预算充足)
      - 黄色: 70-90% (需要关注)
      - 红色: 90-100% (预算告急)
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 监控体系：应用暴露指标 → Prometheus收集 → Grafana展示 → 告警通知
🔸 关键端点：/actuator/prometheus 是Spring Boot应用暴露指标的核心端点  
🔸 监控维度：请求量、错误率、响应时间、系统资源（RED + 系统指标）
🔸 告警原则：准确性优于及时性，避免告警疲劳
🔸 SLO/SLA：SLO是内部目标，SLA是对外承诺，错误预算平衡可靠性与开发效率
```

### 7.2 关键配置要点


**🔧 Spring Boot配置**
```yaml
# 最小化必要配置
management:
  endpoints:
    web:
      exposure:
        include: "prometheus"
  endpoint:
    prometheus:
      enabled: true
  metrics:
    tags:
      application: "your-app-name"  # 必须设置，用于区分不同应用
```

**📊 Grafana面板优先级**
```
必备面板：
1️⃣ 应用健康状态 - 服务是否正常运行
2️⃣ 请求量趋势 - 业务流量变化  
3️⃣ 响应时间分位数 - 用户体验指标
4️⃣ 错误率统计 - 系统稳定性

可选面板：
5️⃣ JVM内存监控 - 内存泄漏排查
6️⃣ 垃圾回收统计 - 性能优化参考
7️⃣ 线程池状态 - 并发处理能力
8️⃣ 数据库连接池 - 数据库访问监控
```

### 7.3 实践建议


**✅ 最佳实践**
```
监控设计：
- 从用户角度出发，优先监控用户可感知的指标
- 建立分层监控：业务层 → 应用层 → 系统层
- 告警分级：Critical必须立即处理，Warning需要关注

仪表盘设计：
- 一个屏幕能看完核心指标
- 颜色有意义：红色=异常，黄色=警告，绿色=正常  
- 图表类型选择：趋势用折线图，当前值用仪表盘，对比用柱状图

团队协作：
- 明确告警责任人和处理流程
- 定期review告警规则，调整阈值
- 记录故障处理过程，形成知识库
```

**⚠️ 常见误区**
```
❌ 监控指标越多越好
✅ 监控核心业务指标，避免信息过载

❌ 告警阈值设置过低  
✅ 基于历史数据设置合理阈值

❌ 只关注技术指标
✅ 技术指标与业务指标结合

❌ 监控系统故障时无人知晓
✅ 监控系统本身也要监控
```

### 7.4 学习进阶建议


**📚 知识扩展路径**
```
基础掌握 → 进阶学习 → 高级实践

基础：掌握本文内容，能搭建基本监控
进阶：学习PromQL查询语言，自定义复杂监控规则  
高级：多集群监控，监控数据治理，AI辅助运维

相关技术栈：
- ELK Stack：日志收集分析
- Jaeger/Zipkin：分布式链路追踪
- APM工具：应用性能监控
```

**核心记忆**：
- 监控不是目的，解决问题才是目标
- 好的监控能让问题在用户发现之前就被解决
- SLO不是越高越好，要在可靠性和效率间找平衡
- 告警要准确，宁可漏报也不要频繁误报