---
title: 2、早期MVC框架（Struts1时代）
---
## 📚 目录


1. [什么是Struts1框架](#1-什么是struts1框架)
2. [Struts1核心组件详解](#2-struts1核心组件详解)
3. [前端控制器模式原理](#3-前端控制器模式原理)
4. [XML配置驱动机制](#4-xml配置驱动机制)
5. [Struts1工作流程](#5-struts1工作流程)
6. [框架局限性分析](#6-框架局限性分析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏛️ 什么是Struts1框架


### 1.1 框架诞生背景


在早期的Java Web开发中，开发者面临着一个大难题：**如何组织代码结构？**

```
传统Servlet开发的痛点：
┌─────────────────────┐
│ 用户请求 → Servlet   │ ← 处理业务逻辑
│          ↓          │
│ Servlet → JSP      │ ← 显示页面
│          ↓          │
│ JSP → 数据库        │ ← 数据操作
└─────────────────────┘

问题：代码混乱，维护困难，职责不清
```

**Struts1的解决方案**就是引入了**MVC设计模式**，把混乱的代码进行分工：

> 🌰 **生活类比**  
> 就像餐厅的分工：服务员(View)负责与客人交流，厨师(Controller)负责处理订单，仓库(Model)负责提供食材。每个人各司其职，井然有序。

### 1.2 MVC模式在Struts1中的体现


**🔸 M (Model) - 数据层**
- **是什么**: 负责处理数据和业务逻辑
- **实际对应**: JavaBean、ActionForm表单对象
- **通俗理解**: 就是你的"数据仓库"和"业务规则"

**🔸 V (View) - 视图层**  
- **是什么**: 负责展示数据给用户看
- **实际对应**: JSP页面、HTML
- **通俗理解**: 就是用户看到的"界面"

**🔸 C (Controller) - 控制层**
- **是什么**: 负责接收用户请求，协调Model和View
- **实际对应**: Action控制器类
- **通俗理解**: 就是"指挥官"，决定调用哪些业务，显示哪个页面

---

## 2. 🧩 Struts1核心组件详解


### 2.1 Action控制器 - 大脑中枢


**Action是什么？**
Action就是Struts1的"大脑"，所有用户请求都会经过它来处理。

```java
// 这就是一个Action控制器的样子
public class LoginAction extends Action {
    public ActionForward execute(ActionMapping mapping,
                               ActionForm form,
                               HttpServletRequest request,
                               HttpServletResponse response) {
        
        // 1. 获取用户提交的表单数据
        LoginForm loginForm = (LoginForm) form;
        String username = loginForm.getUsername();
        String password = loginForm.getPassword();
        
        // 2. 进行业务处理（比如验证用户名密码）
        if ("admin".equals(username) && "123456".equals(password)) {
            // 3. 决定跳转到哪个页面
            return mapping.findForward("success");
        } else {
            return mapping.findForward("failure");
        }
    }
}
```

**🔹 Action的工作职责**
1. **接收数据**: 从表单获取用户输入
2. **处理业务**: 调用业务逻辑进行处理
3. **决定去向**: 选择跳转到哪个页面

### 2.2 ActionForm表单 - 数据载体


**ActionForm是什么？**
ActionForm就像一个"数据容器"，专门用来装用户在网页上填写的信息。

```java
// 登录表单的ActionForm
public class LoginForm extends ActionForm {
    private String username;  // 用户名
    private String password;  // 密码
    
    // 提供获取和设置方法
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    // 数据验证方法
    public ActionErrors validate(ActionMapping mapping, 
                                HttpServletRequest request) {
        ActionErrors errors = new ActionErrors();
        
        if (username == null || username.trim().length() == 0) {
            errors.add("username", new ActionMessage("用户名不能为空"));
        }
        
        return errors;
    }
}
```

**🔹 ActionForm的作用**
- **数据封装**: 把网页表单数据装进Java对象
- **数据验证**: 检查用户输入是否合法
- **数据传递**: 在各个组件之间传递数据

### 2.3 ActionMapping配置 - 路线图


**ActionMapping是什么？**
ActionMapping就像一张"路线图"，告诉Struts1：
- 什么样的请求应该交给哪个Action处理
- 处理完后应该跳转到哪个页面

```xml
<!-- struts-config.xml 配置文件中的映射 -->
<action-mappings>
    <action path="/login"                    <!-- 请求路径 -->
            type="com.example.LoginAction"   <!-- 处理的Action类 -->
            name="loginForm"                 <!-- 使用的表单 -->
            scope="request">                 <!-- 作用域 -->
        
        <!-- 结果页面配置 -->
        <forward name="success" path="/welcome.jsp"/>    <!-- 成功页面 -->
        <forward name="failure" path="/login.jsp"/>      <!-- 失败页面 -->
    </action>
</action-mappings>
```

**🔹 配置要素解释**
- `path`: 用户访问的URL路径
- `type`: 负责处理的Action类
- `name`: 关联的ActionForm
- `forward`: 可能跳转的页面

---

## 3. 🎯 前端控制器模式原理


### 3.1 前端控制器是什么


**传统方式 vs 前端控制器**

```
传统方式（各自为政）：
用户请求1 ──▶ Servlet1 ──▶ JSP1
用户请求2 ──▶ Servlet2 ──▶ JSP2  
用户请求3 ──▶ Servlet3 ──▶ JSP3
问题：每个请求都要写一个Servlet，代码重复

前端控制器方式（统一管理）：
用户请求1 ──┐
用户请求2 ──┼▶ ActionServlet ──▶ 分发给对应Action ──▶ JSP
用户请求3 ──┘    (前端控制器)
优势：统一入口，统一处理
```

### 3.2 ActionServlet - 总指挥


**ActionServlet的工作原理**

```
请求处理流程：
┌─────────────────────────────────────────────────────────┐
│                   ActionServlet                         │
│  1. 接收所有请求                                          │
│  2. 根据URL找到对应的ActionMapping                       │
│  3. 创建ActionForm并填充数据                             │
│  4. 调用对应的Action处理业务                             │  
│  5. 根据返回结果跳转到指定页面                            │
└─────────────────────────────────────────────────────────┘
```

**🔹 前端控制器的优势**
- **统一入口**: 所有请求都从一个地方进入
- **统一处理**: 公共逻辑（如权限检查、日志记录）可以统一处理
- **配置驱动**: 通过配置文件控制请求分发，不需要修改代码

---

## 4. ⚙️ XML配置驱动机制


### 4.1 struts-config.xml - 框架大脑


**为什么需要配置文件？**
配置文件就像"说明书"，告诉Struts1框架：
- 有哪些Action可以处理请求
- 有哪些表单用来接收数据
- 请求处理完后跳转到哪里

```xml
<?xml version="1.0" encoding="UTF-8"?>
<struts-config>
    
    <!-- 1. 表单Bean配置 -->
    <form-beans>
        <form-bean name="loginForm" 
                   type="com.example.LoginForm"/>
        <form-bean name="userForm" 
                   type="com.example.UserForm"/>
    </form-beans>
    
    <!-- 2. Action映射配置 -->
    <action-mappings>
        <action path="/login"
                type="com.example.LoginAction"
                name="loginForm"
                validate="true">
            <forward name="success" path="/main.jsp"/>
            <forward name="input" path="/login.jsp"/>
        </action>
    </action-mappings>
    
    <!-- 3. 全局异常处理 -->
    <global-exceptions>
        <exception key="error.database"
                   type="java.sql.SQLException"
                   path="/error.jsp"/>
    </global-exceptions>
    
</struts-config>
```

### 4.2 配置驱动的工作机制


**配置文件如何发挥作用？**

```
启动时：
1. Struts1读取struts-config.xml
2. 解析配置，建立"路径→Action"的映射关系
3. 将映射关系存储在内存中

运行时：
1. 用户访问 /login
2. ActionServlet在内存中查找 /login 对应的Action
3. 找到LoginAction，调用其execute方法
4. 根据返回的forward名称，跳转到对应页面
```

**🔹 配置驱动的优势**
- **灵活性**: 修改配置就能改变程序行为，无需重新编译
- **可维护性**: 路由规则集中管理，一目了然
- **解耦性**: 业务逻辑和请求映射分离

---

## 5. 🔄 Struts1工作流程


### 5.1 完整请求处理流程


```
用户操作：填写登录表单，点击提交
     ↓
┌─────────────────────────────────────────┐
│              浏览器                      │
│  POST /login?username=admin&password=123 │
└─────────────────────────────────────────┘
     ↓ HTTP请求
┌─────────────────────────────────────────┐
│           Web服务器                      │
│         ActionServlet                   │
│  1. 接收请求 /login                      │
│  2. 查找ActionMapping配置               │
└─────────────────────────────────────────┘
     ↓ 创建并填充表单
┌─────────────────────────────────────────┐
│            ActionForm                   │
│  username = "admin"                     │
│  password = "123"                       │  
│  执行validate()验证                      │
└─────────────────────────────────────────┘
     ↓ 传递给Action
┌─────────────────────────────────────────┐
│            LoginAction                  │
│  execute()方法执行业务逻辑               │
│  返回ActionForward("success")          │
└─────────────────────────────────────────┘
     ↓ 根据forward跳转
┌─────────────────────────────────────────┐
│             JSP页面                     │
│         /main.jsp                       │
│      显示登录成功页面                    │
└─────────────────────────────────────────┘
```

### 5.2 核心处理步骤详解


**🔸 第1步：请求接收**
- ActionServlet接收所有*.do请求
- 解析请求URL，确定要调用的Action

**🔸 第2步：表单处理**
- 根据配置创建ActionForm实例
- 将请求参数自动填充到ActionForm属性中
- 调用validate()方法进行数据验证

**🔸 第3步：业务处理**
- 实例化对应的Action类
- 调用execute()方法处理业务逻辑
- Action返回ActionForward指示跳转页面

**🔸 第4步：视图渲染**
- 根据ActionForward找到目标JSP
- 转发请求到JSP页面
- JSP渲染最终的HTML返回给用户

---

## 6. ⚠️ 框架局限性分析


### 6.1 设计层面的问题


**🔸 ActionForm的累赘**

传统开发中，每个表单都需要创建对应的ActionForm类：

```java
// 用户注册需要一个ActionForm
public class RegisterForm extends ActionForm {
    private String username, password, email;
    // ...大量的getter/setter方法
}

// 用户修改资料又需要另一个ActionForm  
public class UpdateProfileForm extends ActionForm {
    private String username, email, phone;
    // ...又是大量的getter/setter方法
}
```

**问题所在**：
- **代码冗余**: 大量重复的getter/setter方法
- **维护困难**: 修改表单字段需要同时修改ActionForm
- **开发效率低**: 简单的表单也需要写很多代码

### 6.2 技术架构的限制


**🔸 继承式设计的弊端**

```java
// 所有Action都必须继承Action类
public class UserAction extends Action {
    // 只能有一个execute方法，处理所有相关操作
    public ActionForward execute(...) {
        String method = request.getParameter("method");
        if ("add".equals(method)) {
            // 添加用户逻辑
        } else if ("delete".equals(method)) {
            // 删除用户逻辑  
        } else if ("update".equals(method)) {
            // 更新用户逻辑
        }
    }
}
```

**问题分析**：
- **单一方法**: 一个Action只能有一个execute方法，导致方法过于臃肿
- **强制继承**: 必须继承Action类，限制了设计灵活性
- **难以测试**: Action与Servlet API耦合紧密，单元测试困难

### 6.3 配置管理的复杂性


**🔸 XML配置的维护难题**

```xml
<!-- 随着项目增大，配置文件变得巨大且难以维护 -->
<struts-config>
    <action-mappings>
        <action path="/user/add" type="..."/>
        <action path="/user/delete" type="..."/>
        <action path="/user/update" type="..."/>
        <action path="/order/create" type="..."/>
        <action path="/order/cancel" type="..."/>
        <!-- ...数百个配置项 -->
    </action-mappings>
</struts-config>
```

**实际问题**：
- **配置臃肿**: 大项目的配置文件动辄几千行
- **维护困难**: 添加功能需要同时修改Java代码和XML配置
- **错误频发**: XML配置错误在运行时才能发现

### 6.4 与现代开发理念的差距


**🔸 注解 vs XML配置**

```
Struts1时代（XML配置）:
Java代码 ←→ XML配置文件 ←→ JSP页面
   ↑              ↑             ↑
 分散在三个地方，维护困难

现代框架（注解配置）:
@RequestMapping("/user")
@Controller  
public class UserController {
    // 配置和代码在一起，维护方便
}
```

**发展趋势**：
- **约定优于配置**: 减少不必要的配置文件
- **注解驱动**: 配置信息直接写在代码中
- **依赖注入**: 松耦合的组件设计

---

## 7. 📋 核心要点总结


### 7.1 Struts1的历史价值


**🔸 框架演进的里程碑**
```
Servlet/JSP混乱时代 → Struts1规范化 → 现代框架百花齐放
                    ↑
                引入MVC模式
                统一开发规范
```

> 💡 **重要理解**  
> Struts1虽然现在看起来笨重，但它在Java Web发展史上的作用不可忽视。它第一次让Java开发者有了统一的MVC框架，为后续框架的发展奠定了基础。

### 7.2 必须掌握的核心概念


**🔹 核心组件关系**
```
用户请求 → ActionServlet → ActionMapping → Action → ActionForm → JSP
   ↑          ↑            ↑         ↑         ↑        ↑
 入口点    前端控制器    路径映射   业务处理   数据载体  视图展示
```

**🔹 关键知识点**
- `#Struts1框架` `#MVC模式` `#前端控制器`
- Action控制器：处理业务逻辑的核心类
- ActionForm表单：封装用户输入数据的容器
- ActionMapping配置：URL与Action的映射关系
- XML配置驱动：通过配置文件控制框架行为

### 7.3 学习价值与现实意义


**🔸 为什么还要学习Struts1？**

1️⃣ **理解框架演进**：知道现代框架是如何从Struts1发展而来的  
2️⃣ **掌握MVC思想**：MVC模式是Web开发的基础设计模式  
3️⃣ **维护遗留系统**：很多老项目还在使用Struts1  
4️⃣ **对比学习价值**：通过对比了解现代框架的优势

**🔸 从Struts1到现代框架的演进**

| 特性对比 | **Struts1** | **现代框架(Spring MVC)** | **改进点** |
|---------|------------|------------------------|----------|
| **配置方式** | `XML配置` | `注解配置` | `开发效率提升` |
| **Action设计** | `继承Action类` | `普通Java类` | `设计更灵活` |
| **表单处理** | `ActionForm类` | `直接绑定对象` | `减少代码量` |
| **测试友好性** | `难以测试` | `容易测试` | `可测试性改进` |

> 🎯 **学习建议**  
> 学习Struts1的重点不在于掌握具体的API使用，而在于理解MVC模式、前端控制器模式等设计思想，这些思想在现代框架中依然适用。

### 7.4 技能掌握检验


**📈 掌握程度自测**
- [ ] 能说出Struts1解决了什么问题 (理解层面)
- [ ] 能画出Struts1的工作流程图 (掌握层面)  
- [ ] 能分析Struts1的优缺点 (分析层面)
- [ ] 能对比Struts1和现代框架的区别 (评价层面)

**🤔 思考题**
1. 为什么说Struts1是"配置驱动"的框架？
2. 前端控制器模式解决了什么问题？
3. ActionForm的设计有什么优缺点？

**🧠 记忆要点**
- **MVC分层**："数据-视图-控制器，各司其职不混乱"
- **前端控制器**："统一入口处理请求，分发到具体Action执行"  
- **配置驱动**："XML文件是路线图，指明请求处理的方向"

**核心记忆口诀**：
- Struts1开创MVC先河，Action控制业务不含糊
- ActionForm封装表单数据，XML配置驱动路径清
- 前端控制统一入口，虽有局限功不可没