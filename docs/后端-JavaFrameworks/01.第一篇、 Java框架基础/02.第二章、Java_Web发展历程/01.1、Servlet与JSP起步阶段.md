---
title: 1、Servlet与JSP起步阶段
---
## 📚 目录

1. [Servlet技术核心](#1-servlet技术核心)
2. [JSP动态网页技术](#2-jsp动态网页技术)
3. [过滤器与监听器](#3-过滤器与监听器)
4. [Session会话管理](#4-session会话管理)
5. [MVC设计模式雏形](#5-mvc设计模式雏形)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🌟 Servlet技术核心


### 1.1 什么是Servlet


**🔸 简单理解**
```
Servlet = Server + Applet
就是运行在服务器端的小程序

传统静态网页：
用户访问 → 服务器直接返回HTML文件 → 内容固定不变

Servlet动态网页：
用户访问 → Servlet程序处理 → 生成动态HTML → 返回给用户
```

**💡 为什么需要Servlet**
- **动态内容生成**：根据用户请求产生不同的网页内容
- **数据库交互**：连接数据库查询、更新数据
- **业务逻辑处理**：处理用户登录、购物车、订单等业务
- **跨平台运行**：Java语言的跨平台特性

### 1.2 Servlet容器概念


**🏗️ 容器是什么**
```
想象一个饭店的厨房：
- 厨师（Servlet）负责做菜
- 厨房（容器）提供环境：炉灶、调料、餐具
- 服务员（容器）负责传递订单和上菜

Servlet容器就是为Servlet提供运行环境的"厨房"
常见容器：Tomcat、Jetty、WebLogic等
```

**⚙️ 容器的核心职责**
- **生命周期管理**：创建、初始化、销毁Servlet
- **请求处理**：接收HTTP请求，调用对应Servlet
- **多线程支持**：为每个请求创建新线程
- **安全管理**：提供安全认证和授权

### 1.3 Servlet规范详解


**📋 Servlet接口结构**
```java
public interface Servlet {
    // 初始化方法，只执行一次
    void init(ServletConfig config);
    
    // 处理请求的核心方法
    void service(ServletRequest req, ServletResponse res);
    
    // 销毁方法，服务器关闭时执行
    void destroy();
}
```

**🔄 Servlet生命周期**
```
第一次访问时：
实例化 → init()初始化 → service()处理请求

后续访问时：
直接调用service()方法

服务器关闭时：
调用destroy()方法 → 对象被销毁

记忆要点：生一次，服务多次，死一次
```

### 1.4 HttpServlet实用开发


**🎯 实际开发模式**
```java
// 继承HttpServlet类，重写doGet/doPost方法
public class UserServlet extends HttpServlet {
    
    @Override
    protected void doGet(HttpServletRequest req, 
                        HttpServletResponse resp) {
        // 处理GET请求：通常用于查询数据
        String userId = req.getParameter("id");
        // 查询用户信息...
        resp.getWriter().write("用户信息：" + userInfo);
    }
    
    @Override
    protected void doPost(HttpServletRequest req, 
                         HttpServletResponse resp) {
        // 处理POST请求：通常用于提交数据
        String username = req.getParameter("username");
        // 保存用户信息...
    }
}
```

**📝 web.xml配置说明**
```xml
<servlet>
    <servlet-name>userServlet</servlet-name>
    <servlet-class>com.example.UserServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>userServlet</servlet-name>
    <url-pattern>/user</url-pattern>
</servlet-mapping>

<!-- 
配置解释：
- servlet-name：给Servlet起个名字，方便引用
- servlet-class：指定Servlet类的完整路径
- url-pattern：设置访问路径，如 http://localhost/user
-->
```

---

## 2. 📄 JSP动态网页技术


### 2.1 JSP基本概念


**🔸 JSP是什么**
```
JSP = Java Server Pages
本质：在HTML中嵌入Java代码的技术

传统做法：
Servlet中写HTML → 代码混乱，难以维护
out.println("<html>");
out.println("<body>Hello</body>");
out.println("</html>");

JSP做法：
HTML中嵌入Java → 结构清晰，易于开发
<html>
<body>
    Hello, <%= username %>!
    今天是 <%= new Date() %>
</body>
</html>
```

**💡 JSP工作原理**
```
用户访问JSP页面的过程：
1. 浏览器请求 .jsp 文件
2. 容器将JSP转换为Servlet源码
3. 编译Servlet源码为.class文件
4. 执行Servlet，生成HTML响应
5. 返回HTML给浏览器

关键理解：JSP最终还是变成了Servlet运行
```

### 2.2 JSP语法要素


**🔧 JSP基本语法**

| 语法类型 | **写法** | **作用** | **示例** |
|---------|---------|---------|---------|
| **JSP表达式** | `<%= %>` | `输出值到页面` | `<%= "Hello World" %>` |
| **JSP脚本** | `<% %>` | `编写Java代码` | `<% String name = "张三"; %>` |
| **JSP声明** | `<%! %>` | `声明成员变量/方法` | `<%! int count = 0; %>` |
| **JSP注释** | `<%-- --%>` | `服务器端注释` | `<%-- 这是注释 --%>` |

**⭐ 实际使用示例**
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" %>
<html>
<head><title>用户信息</title></head>
<body>
    <%-- 声明变量 --%>
    <% 
        String username = request.getParameter("name");
        if(username == null) username = "游客";
    %>
    
    <h1>欢迎，<%= username %>！</h1>
    
    <%-- 循环显示数据 --%>
    <ul>
    <% for(int i = 1; i <= 5; i++) { %>
        <li>第 <%= i %> 条消息</li>
    <% } %>
    </ul>
</body>
</html>
```

### 2.3 EL表达式简化开发


**🎯 EL表达式概念**
```
EL = Expression Language（表达式语言）
目的：简化JSP中的Java代码，让页面更清爽

传统JSP写法：
<%= request.getParameter("username") %>

EL表达式写法：
${param.username}

优势：语法简洁，自动处理null值，更安全
```

**📊 EL常用内置对象**

| 内置对象 | **作用** | **使用示例** |
|---------|---------|-------------|
| **param** | `获取请求参数` | `${param.username}` |
| **sessionScope** | `获取session属性` | `${sessionScope.user}` |
| **requestScope** | `获取request属性` | `${requestScope.message}` |
| **cookie** | `获取Cookie值` | `${cookie.loginName.value}` |

### 2.4 JSTL标签库增强功能


**🏷️ JSTL核心概念**
```
JSTL = JSP Standard Tag Library（JSP标准标签库）
作用：用标签替代JSP中的Java代码，页面更像HTML

传统方式：
<% if(user != null) { %>
    <p>欢迎，${user.name}</p>
<% } %>

JSTL方式：
<c:if test="${user != null}">
    <p>欢迎，${user.name}</p>
</c:if>
```

**⚡ JSTL常用标签**

| 标签 | **功能** | **使用示例** |
|-----|---------|-------------|
| **c:if** | `条件判断` | `<c:if test="${user.age >= 18}">成年人</c:if>` |
| **c:forEach** | `循环遍历` | `<c:forEach var="item" items="${list}">...</c:forEach>` |
| **c:choose** | `多分支选择` | `<c:choose><c:when>...</c:when></c:choose>` |
| **c:set** | `设置变量` | `<c:set var="name" value="张三"/>` |

---

## 3. 🛡️ 过滤器与监听器


### 3.1 Filter过滤器机制


**🔸 过滤器概念**
```
Filter = 过滤器，像机场安检一样
所有请求在到达Servlet之前，都要经过Filter检查

实际应用场景：
- 字符编码统一处理
- 用户登录权限检查
- 敏感词汇过滤
- 访问日志记录

工作流程：
请求 → Filter1 → Filter2 → Servlet → Filter2 → Filter1 → 响应
        (预处理)              (后处理)
```

**⚙️ 过滤器开发步骤**
```java
// 1. 实现Filter接口
public class EncodingFilter implements Filter {
    
    public void init(FilterConfig config) {
        // 过滤器初始化
        System.out.println("编码过滤器初始化");
    }
    
    public void doFilter(ServletRequest request, 
                        ServletResponse response, 
                        FilterChain chain) {
        // 请求预处理
        request.setCharacterEncoding("UTF-8");
        response.setCharacterEncoding("UTF-8");
        
        // 继续执行下一个过滤器或Servlet
        chain.doFilter(request, response);
        
        // 响应后处理（可选）
        System.out.println("请求处理完成");
    }
    
    public void destroy() {
        // 清理资源
    }
}
```

**📝 过滤器配置**
```xml
<!-- web.xml中配置 -->
<filter>
    <filter-name>encodingFilter</filter-name>
    <filter-class>com.example.EncodingFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>encodingFilter</filter-name>
    <url-pattern>/*</url-pattern>  <!-- 所有请求都过滤 -->
</filter-mapping>
```

### 3.2 Listener监听器机制


**🔸 监听器概念**
```
Listener = 监听器，像门卫一样监控各种事件
监控对象：ServletContext、HttpSession、ServletRequest

监听事件类型：
- 对象创建和销毁
- 属性添加、删除、修改
- Session激活和钝化

实际用途：
- 统计在线用户数量
- 定时任务调度
- 资源初始化和清理
- 系统启动时加载配置
```

**📊 监听器分类**

| 监听器类型 | **监听对象** | **典型应用** |
|-----------|-------------|-------------|
| **ServletContextListener** | `应用程序生命周期` | `系统启动初始化配置` |
| **HttpSessionListener** | `Session创建销毁` | `统计在线用户数` |
| **ServletRequestListener** | `请求创建销毁` | `记录访问日志` |

**⚡ 实际开发示例**
```java
// 统计在线用户数
public class OnlineUserListener implements HttpSessionListener {
    
    private static int onlineCount = 0;
    
    // 用户上线（创建Session）
    public void sessionCreated(HttpSessionEvent se) {
        onlineCount++;
        System.out.println("用户上线，当前在线：" + onlineCount);
        
        // 将在线人数存到应用域
        ServletContext context = se.getSession().getServletContext();
        context.setAttribute("onlineCount", onlineCount);
    }
    
    // 用户下线（Session销毁）
    public void sessionDestroyed(HttpSessionEvent se) {
        onlineCount--;
        System.out.println("用户下线，当前在线：" + onlineCount);
    }
}
```

---

## 4. 🍪 Session会话管理


### 4.1 Session技术原理


**🔸 会话概念理解**
```
会话 = 用户从打开浏览器到关闭浏览器的整个过程
问题：HTTP协议是无状态的，服务器如何记住用户？

现实类比：
去银行办业务 → 取号排队 → 叫号办理 → 离开
银行通过号码牌记住你是哪个客户

Session原理：
用户首次访问 → 服务器创建Session对象 → 分配SessionID
→ SessionID存储到Cookie → 后续请求携带SessionID
→ 服务器根据SessionID找到对应Session
```

**🔄 Session工作流程图**
```
客户端                     服务器端
   |                         |
   |--[1]首次请求------------>|
   |                         |--创建Session对象
   |                         |--生成SessionID
   |<--[2]响应+SessionID-----|
   |  (通过Cookie传递)        |
   |                         |
   |--[3]后续请求+SessionID-->|
   |                         |--根据ID找到Session
   |<--[4]处理结果-----------|--获取用户信息
```

### 4.2 Session实际应用


**⚙️ Session基本操作**
```java
// 获取或创建Session
HttpSession session = request.getSession();

// 存储用户信息
User user = new User("张三", "admin");
session.setAttribute("currentUser", user);

// 获取用户信息
User loginUser = (User) session.getAttribute("currentUser");

// 判断用户是否登录
if (loginUser != null) {
    // 已登录用户
    response.getWriter().write("欢迎，" + loginUser.getName());
} else {
    // 未登录，跳转到登录页
    response.sendRedirect("login.jsp");
}

// 用户注销，清除Session
session.invalidate();
```

**🎯 登录验证完整流程**
```java
// 登录处理Servlet
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        
        // 验证用户名密码（连接数据库查询）
        if ("admin".equals(username) && "123456".equals(password)) {
            // 登录成功，创建Session
            HttpSession session = req.getSession();
            session.setAttribute("username", username);
            session.setAttribute("loginTime", new Date());
            
            // 跳转到主页
            resp.sendRedirect("main.jsp");
        } else {
            // 登录失败，返回登录页
            req.setAttribute("errorMsg", "用户名或密码错误");
            req.getRequestDispatcher("login.jsp").forward(req, resp);
        }
    }
}
```

### 4.3 Request/Response处理详解


**📨 Request对象核心功能**

| 功能类别 | **方法** | **作用说明** |
|---------|---------|-------------|
| **获取参数** | `getParameter("name")` | `获取单个参数值` |
| **获取多值** | `getParameterValues("hobby")` | `获取复选框等多值参数` |
| **请求信息** | `getMethod()` | `获取请求方式GET/POST` |
| **路径信息** | `getContextPath()` | `获取应用程序路径` |

**📤 Response对象核心功能**

| 功能类别 | **方法** | **作用说明** |
|---------|---------|-------------|
| **页面跳转** | `sendRedirect("url")` | `重定向到新页面` |
| **输出内容** | `getWriter().write()` | `向页面输出文本` |
| **设置编码** | `setCharacterEncoding()` | `设置响应字符编码` |
| **设置头信息** | `setHeader()` | `设置HTTP响应头` |

---

## 5. 🏗️ MVC设计模式雏形


### 5.1 MVC模式基本概念


**🔸 什么是MVC**
```
MVC = Model（模型） + View（视图） + Controller（控制器）

生活类比：餐厅点餐系统
- View（视图）：菜单，顾客看到的界面
- Controller（控制器）：服务员，处理点餐请求
- Model（模型）：厨房，处理业务逻辑和数据

MVC的核心思想：分离关注点，各司其职
```

**🎯 MVC在Java Web中的体现**
```
传统混乱模式：
JSP页面 = HTML + Java代码 + 数据库操作
→ 代码混乱，难以维护

MVC模式分工：
- Model：JavaBean（实体类） + DAO（数据访问）
- View：JSP页面（只负责显示）  
- Controller：Servlet（控制请求流程）
```

### 5.2 MVC架构图解


**📊 MVC工作流程**
```
       用户请求
          ↓
    ┌─────────────┐
    │ Controller  │  ← Servlet控制器
    │ (Servlet)   │    处理请求，调用业务逻辑
    └─────────────┘
          ↓                ↑
    调用业务逻辑          返回处理结果
          ↓                ↑
    ┌─────────────┐  ┌─────────────┐
    │    Model    │  │    View     │
    │  (JavaBean) │  │    (JSP)    │
    │   数据处理   │  │   页面显示   │
    └─────────────┘  └─────────────┘
```

### 5.3 MVC实践示例


**🔧 Model层设计**
```java
// 用户实体类
public class User {
    private String username;
    private String password;
    private String email;
    
    // 构造方法、getter/setter方法...
}

// 用户数据访问类
public class UserDAO {
    // 模拟数据库操作
    public User findUser(String username, String password) {
        // 实际开发中这里连接数据库查询
        if ("admin".equals(username) && "123".equals(password)) {
            return new User(username, password, "admin@example.com");
        }
        return null;
    }
}
```

**🎮 Controller层设计**
```java
public class UserController extends HttpServlet {
    private UserDAO userDAO = new UserDAO();
    
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
        String action = req.getParameter("action");
        
        if ("login".equals(action)) {
            // 处理登录请求
            handleLogin(req, resp);
        } else if ("register".equals(action)) {
            // 处理注册请求  
            handleRegister(req, resp);
        }
    }
    
    private void handleLogin(HttpServletRequest req, HttpServletResponse resp) {
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        
        // 调用Model层处理业务
        User user = userDAO.findUser(username, password);
        
        if (user != null) {
            // 登录成功，存储用户信息，跳转到View
            req.getSession().setAttribute("user", user);
            req.getRequestDispatcher("welcome.jsp").forward(req, resp);
        } else {
            // 登录失败，返回登录页面显示错误
            req.setAttribute("error", "用户名或密码错误");
            req.getRequestDispatcher("login.jsp").forward(req, resp);
        }
    }
}
```

**🖼️ View层设计**
```jsp
<!-- welcome.jsp 欢迎页面 -->
<%@ page contentType="text/html;charset=UTF-8" %>
<html>
<head><title>欢迎页面</title></head>
<body>
    <!-- 使用EL表达式显示数据，不包含业务逻辑 -->
    <h1>欢迎，${user.username}!</h1>
    <p>您的邮箱：${user.email}</p>
    <p>登录时间：${sessionScope.loginTime}</p>
    
    <a href="logout?action=logout">退出登录</a>
</body>
</html>
```

### 5.4 MVC模式优势分析


**✅ MVC带来的好处**

| 优势 | **传统模式问题** | **MVC解决方案** |
|-----|----------------|----------------|
| **职责分离** | `JSP中混杂HTML和Java代码` | `各层专注自己的职责` |
| **易于维护** | `修改页面影响业务逻辑` | `修改View不影响Controller` |
| **团队协作** | `前端后端代码耦合` | `前后端可并行开发` |
| **代码复用** | `业务逻辑重复编写` | `Model层可复用` |

**🔍 理解要点**
- **分离关注点**：每一层只关注自己的事情
- **降低耦合**：层与层之间依赖关系清晰
- **提高复用**：业务逻辑可以被多个控制器使用
- **便于测试**：可以单独测试每一层的功能

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 Servlet本质：运行在服务器端的Java程序，处理HTTP请求
🔸 JSP作用：在HTML中嵌入Java代码，简化动态网页开发  
🔸 过滤器用途：对请求进行预处理和后处理，如编码、权限检查
🔸 监听器功能：监控Web应用中各种事件，如用户上线统计
🔸 Session原理：通过SessionID在多个请求间保持用户状态
🔸 MVC思想：分离视图、控制和模型，提高代码可维护性
```

### 6.2 关键理解要点


**🔹 Servlet生命周期记忆法**
```
记忆口诀：生一次，服务多次，死一次
- init()：出生时执行一次
- service()：工作中执行多次  
- destroy()：退休时执行一次
```

**🔹 JSP与Servlet关系**
```
理解要点：
JSP本质上就是Servlet，只是写法不同
JSP让我们在HTML中写Java，而不是在Java中写HTML
最终都会被容器转换成Servlet执行
```

**🔹 过滤器链执行顺序**
```
请求时：Filter1 → Filter2 → Servlet
响应时：Servlet → Filter2 → Filter1
像洋葱一样，层层包裹，层层返回
```

### 6.3 实际应用指导


**💼 技术选型建议**

| 场景 | **推荐技术** | **原因** |
|-----|-------------|---------|
| **简单查询展示** | `JSP + EL + JSTL` | `开发快速，代码简洁` |
| **复杂业务处理** | `Servlet + JSP` | `业务逻辑清晰分离` |
| **权限控制** | `Filter` | `统一处理，无需重复编码` |
| **系统监控** | `Listener` | `事件驱动，自动执行` |

**🔧 最佳实践建议**
- **编码规范**：统一使用UTF-8编码，通过Filter处理
- **错误处理**：合理使用try-catch，提供友好错误页面  
- **安全考虑**：对用户输入进行验证和过滤
- **性能优化**：合理设置Session超时时间，避免内存泄漏

### 6.4 向更高级框架过渡


**🚀 技术演进路径**
```
Servlet/JSP基础技术
        ↓
    MVC模式雏形
        ↓  
    Struts框架（完善的MVC）
        ↓
    Spring MVC（更强大的MVC）
        ↓
    Spring Boot（约定优于配置）
```

**💡 学习建议**
- **基础要扎实**：深入理解Servlet/JSP原理
- **多动手练习**：完成登录、增删改查等基本功能
- **理解MVC思想**：为学习后续框架打基础
- **关注最佳实践**：养成良好的编程习惯

**🎯 核心记忆**
- Servlet是Java Web的基石，所有框架都基于它构建
- JSP简化了动态网页开发，但本质还是Servlet
- Filter和Listener提供了面向切面的编程思想
- Session解决了HTTP无状态协议的用户状态保持问题
- MVC模式是Web开发的经典架构，分离关注点是核心思想

通过掌握这些基础技术，你已经具备了理解更高级Java Web框架的能力！