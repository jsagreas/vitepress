---
title: 7、MyBatis缓存机制
---
## 📚 目录

1. [缓存机制核心概念](#1-缓存机制核心概念)
2. [一级缓存机制](#2-一级缓存机制)
3. [二级缓存机制](#3-二级缓存机制)
4. [缓存配置与管理](#4-缓存配置与管理)
5. [集成第三方缓存](#5-集成第三方缓存)
6. [缓存问题与解决方案](#6-缓存问题与解决方案)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💡 缓存机制核心概念


### 1.1 什么是MyBatis缓存


> **通俗理解**：缓存就像你的笔记本，第一次从课本（数据库）抄写知识点很慢，但记在笔记本后，下次直接翻笔记本就很快了。MyBatis缓存就是把查询结果暂时"记下来"，下次要用时直接拿，不用再去数据库查询。

**缓存的本质作用**：
- 🎯 **减少数据库访问**：相同查询不用反复执行SQL
- ⚡ **提升查询速度**：从内存读取比从数据库快几十倍
- 💰 **降低数据库压力**：特别是高并发场景下

```
没有缓存的查询流程：
用户请求 → MyBatis → 数据库 → 返回结果
         ↓
      每次都要走数据库，慢！

有缓存的查询流程：
第一次：用户请求 → MyBatis → 数据库 → 缓存 → 返回结果
第二次：用户请求 → MyBatis → 缓存（直接返回，快！）
```

### 1.2 MyBatis缓存体系结构


```
MyBatis缓存分级架构：

┌─────────────────────────────────────────────────┐
│              应用程序层                          │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────────┐    ┌──────────────────┐  │
│  │   一级缓存       │    │   二级缓存       │  │
│  │  (SqlSession级)  │    │  (Mapper级)      │  │
│  │                  │    │                  │  │
│  │  • 默认开启      │    │  • 需手动开启    │  │
│  │  • 作用域小      │    │  • 作用域大      │  │
│  │  • 生命周期短    │    │  • 可跨Session   │  │
│  └──────────────────┘    └──────────────────┘  │
│           ↓                       ↓             │
├─────────────────────────────────────────────────┤
│                  数据库层                        │
└─────────────────────────────────────────────────┘
```

**两级缓存的区别理解**：

| 特性 | 一级缓存 | 二级缓存 |
|-----|---------|---------|
| **范围** | `一个SqlSession内` | `整个Mapper（命名空间）内` |
| **生命周期** | `Session开启到关闭` | `应用运行期间` |
| **默认状态** | `自动开启，无需配置` | `需要手动开启` |
| **形象比喻** | `个人笔记本（私有）` | `班级黑板（共享）` |

---

## 2. 📝 一级缓存机制


### 2.1 一级缓存工作原理


> **核心理解**：一级缓存是SqlSession级别的缓存，你可以把SqlSession想象成一次"数据库办事流程"，在这个流程没结束前，查过的数据会被记住。

**一级缓存的生命周期**：

```
SqlSession生命周期与一级缓存：

创建SqlSession ────────────────────────┐
    ↓                                  │
第一次查询 → 数据库 → 存入缓存          │ 缓存有效期
    ↓                                  │
第二次相同查询 → 直接从缓存返回         │
    ↓                                  │
关闭SqlSession ────────────────────────┘ 缓存清空
```

### 2.2 一级缓存触发场景


**🔍 什么时候会用到缓存**：

```java
// 场景1：同一个SqlSession内重复查询
SqlSession session = factory.openSession();
UserMapper mapper = session.getMapper(UserMapper.class);

// 第一次查询：会去数据库，并缓存结果
User user1 = mapper.selectById(1);  // 执行SQL

// 第二次查询：直接从缓存拿，不执行SQL
User user2 = mapper.selectById(1);  // 不执行SQL，从缓存获取

// user1 和 user2 是同一个对象
System.out.println(user1 == user2);  // true
```

**⚠️ 什么时候缓存会失效**：

```java
// 情况1：执行了增删改操作
User user1 = mapper.selectById(1);  // 缓存
mapper.updateUser(user);             // 缓存被清空！
User user2 = mapper.selectById(1);  // 重新查数据库

// 情况2：手动清空缓存
User user1 = mapper.selectById(1);  // 缓存
session.clearCache();                // 手动清空
User user2 = mapper.selectById(1);  // 重新查数据库

// 情况3：不同的SqlSession
SqlSession session1 = factory.openSession();
SqlSession session2 = factory.openSession();
User user1 = session1.getMapper(UserMapper.class).selectById(1); // 缓存在session1
User user2 = session2.getMapper(UserMapper.class).selectById(1); // 缓存在session2
// 两个缓存互不影响
```

### 2.3 一级缓存的关键特性


**🔸 缓存的判断依据**：

MyBatis判断是否命中缓存，看这4个条件：
1. **SQL语句必须完全相同**
2. **参数值必须相同**
3. **必须是相同的StatementId**（即同一个Mapper方法）
4. **RowBounds（分页参数）必须相同**

```java
// 这两个查询能命中缓存
User user1 = mapper.selectById(1);
User user2 = mapper.selectById(1);  // ✓ 命中缓存

// 这两个查询不能命中缓存
User user1 = mapper.selectById(1);
User user2 = mapper.selectById(2);  // ✗ 参数不同，不命中
```

---

## 3. 🌐 二级缓存机制


### 3.1 二级缓存核心概念


> **通俗理解**：如果说一级缓存是你个人的笔记本，那二级缓存就是班级的公共黑板。所有同学（SqlSession）都可以从黑板上看信息，共享查询结果。

**二级缓存的特点**：

```
二级缓存作用域示意：

┌────────────────────────────────────────────┐
│          UserMapper命名空间（二级缓存）     │
│                                            │
│  SqlSession1 ──┐                          │
│                ├──→ 共享的二级缓存 ←──┐    │
│  SqlSession2 ──┘                      │    │
│                                       │    │
│  SqlSession3 ────────────────────────┘    │
└────────────────────────────────────────────┘
```

**一级缓存 vs 二级缓存对比**：

| 对比维度 | 一级缓存 | 二级缓存 |
|---------|---------|---------|
| **作用范围** | `单个SqlSession` | `整个Mapper命名空间` |
| **数据共享** | `不共享` | `可以跨SqlSession共享` |
| **开启方式** | `默认开启` | `需要配置开启` |
| **使用场景** | `事务内查询` | `跨事务查询相同数据` |

### 3.2 二级缓存配置启用


**开启二级缓存的三步骤**：

```xml
<!-- 步骤1：全局配置文件开启（mybatis-config.xml） -->
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```

```xml
<!-- 步骤2：Mapper XML中启用缓存 -->
<mapper namespace="com.example.mapper.UserMapper">
    <!-- 最简配置：使用默认参数 -->
    <cache/>
    
    <!-- 或者自定义配置 -->
    <cache 
        eviction="LRU"           
        flushInterval="60000"    
        size="512"               
        readOnly="false"/>
</mapper>
```

```java
// 步骤3：实体类实现序列化（如果readOnly=false）
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    private Integer id;
    private String name;
    // ...
}
```

### 3.3 二级缓存配置详解


**🔧 cache标签属性说明**：

| 属性 | 含义 | 可选值 | 推荐设置 |
|-----|------|-------|---------|
| **eviction** | `缓存清除策略` | `LRU/FIFO/SOFT/WEAK` | `LRU（最近最少使用）` |
| **flushInterval** | `自动刷新时间(毫秒)` | `数字，如60000` | `根据业务定，60秒左右` |
| **size** | `缓存对象数量` | `正整数，默认1024` | `512或1024` |
| **readOnly** | `是否只读` | `true/false` | `false（安全但慢）` |

**清除策略详解**：

```
缓存清除策略说明：

LRU（Least Recently Used）：
最近最少使用 → 优先删除最久没用的
适用：大部分场景

FIFO（First In First Out）：
先进先出 → 按加入顺序删除
适用：有明确时效性的数据

SOFT（软引用）：
内存不足时清除
适用：可容忍偶尔失效的场景

WEAK（弱引用）：
垃圾回收时就清除
适用：临时性数据
```

### 3.4 二级缓存的工作流程


```
二级缓存查询流程：

用户查询请求
     ↓
查二级缓存
     ↓
  命中？
   /  \
  是   否
  ↓    ↓
返回  查一级缓存
      ↓
   命中？
    /  \
   是   否
   ↓    ↓
  返回  查数据库
        ↓
      存入一级缓存
        ↓
    SqlSession提交/关闭
        ↓
    一级缓存数据 → 二级缓存
```

**重要理解**：
- 二级缓存必须在SqlSession **提交或关闭** 后才生效
- 一级缓存的数据会"晋升"到二级缓存

```java
// 示例：二级缓存生效过程
SqlSession session1 = factory.openSession();
UserMapper mapper1 = session1.getMapper(UserMapper.class);

User user = mapper1.selectById(1);  // 查数据库，存入一级缓存
session1.commit();  // 提交后，数据进入二级缓存

SqlSession session2 = factory.openSession();
UserMapper mapper2 = session2.getMapper(UserMapper.class);

User user2 = mapper2.selectById(1);  // 从二级缓存获取
```

---

## 4. ⚙️ 缓存配置与管理


### 4.1 缓存作用域控制


**单个语句禁用缓存**：

```xml
<!-- 场景：某些查询不想使用缓存 -->
<select id="selectRealTimeData" resultType="User" useCache="false">
    SELECT * FROM user WHERE id = #{id}
</select>
```

**增删改操作刷新缓存**：

```xml
<!-- 默认：增删改会清空二级缓存 -->
<update id="updateUser" flushCache="true">
    UPDATE user SET name = #{name} WHERE id = #{id}
</update>

<!-- 特殊场景：不想清空缓存 -->
<update id="updateUserLog" flushCache="false">
    UPDATE user_log SET count = count + 1 WHERE user_id = #{userId}
</update>
```

### 4.2 缓存刷新策略


**自动刷新机制**：

```xml
<!-- 方式1：定时刷新（每60秒清空一次） -->
<cache flushInterval="60000"/>

<!-- 方式2：大小限制刷新 -->
<cache size="512"/>  <!-- 超过512个对象自动清理 -->
```

**手动刷新机制**：

```java
// 方式1：SqlSession级别刷新
session.clearCache();  // 清空一级缓存

// 方式2：执行操作时刷新
mapper.updateUser(user);  // 会自动清空缓存
session.commit();         // 提交也会刷新
```

### 4.3 缓存清理机制


**缓存清理的触发时机**：

```
缓存清理时机图：

┌─────────────────────┐
│  自动清理触发条件    │
├─────────────────────┤
│ ① 执行增删改操作     │
│ ② 缓存数量超限       │
│ ③ 定时刷新时间到     │
│ ④ 内存不足(SOFT/WEAK)│
└─────────────────────┘
        ↓
  清理策略执行
   (LRU/FIFO)
        ↓
    释放内存空间
```

---

## 5. 🔌 集成第三方缓存


### 5.1 为什么需要第三方缓存


> **实际问题**：MyBatis自带缓存只存在内存里，应用重启就丢了，而且不能在分布式环境下共享。就像你的笔记只能你自己看，别人看不到。

**引入第三方缓存的好处**：

| 需求场景 | MyBatis缓存 | 第三方缓存(Redis/EhCache) |
|---------|------------|-------------------------|
| **数据持久化** | ❌ 重启就丢 | ✅ 可以持久化到磁盘 |
| **分布式共享** | ❌ 单机独享 | ✅ 多服务器共享 |
| **缓存容量** | ❌ 受JVM限制 | ✅ 独立部署，容量大 |
| **高级功能** | ❌ 功能简单 | ✅ 过期策略、监控等 |

### 5.2 Redis缓存集成


**步骤1：添加依赖**

```xml
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-redis</artifactId>
    <version>1.0.0-beta2</version>
</dependency>
```

**步骤2：配置Redis连接**

```properties
# redis.properties
redis.host=localhost
redis.port=6379
redis.password=
redis.database=0
redis.timeout=3000
```

**步骤3：Mapper中启用**

```xml
<mapper namespace="com.example.mapper.UserMapper">
    <!-- 使用Redis作为二级缓存 -->
    <cache type="org.mybatis.caches.redis.RedisCache"/>
    
    <select id="selectById" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>
</mapper>
```

**工作原理简图**：

```
使用Redis缓存的流程：

MyBatis查询
     ↓
检查Redis缓存
     ↓
  存在？
   / \
  是  否
  ↓   ↓
返回  查数据库
      ↓
    存入Redis
      ↓
    返回结果
```

### 5.3 EhCache缓存集成


**EhCache特点**：本地缓存，性能高，配置灵活

```xml
<!-- 步骤1：添加依赖 -->
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-ehcache</artifactId>
    <version>1.2.1</version>
</dependency>
```

```xml
<!-- 步骤2：ehcache.xml配置 -->
<ehcache>
    <diskStore path="java.io.tmpdir/ehcache"/>
    
    <defaultCache
        maxElementsInMemory="1000"
        eternal="false"
        timeToIdleSeconds="120"
        timeToLiveSeconds="300"
        overflowToDisk="true"/>
</ehcache>
```

```xml
<!-- 步骤3：Mapper中使用 -->
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
```

---

## 6. ⚠️ 缓存问题与解决方案


### 6.1 缓存穿透问题


> **什么是缓存穿透**：查询一个数据库里根本不存在的数据，缓存里也没有，每次都会去查数据库。就像你找一本图书馆根本没有的书，每次都要去找，很浪费时间。

**问题场景**：

```
缓存穿透流程：

查询id=9999的用户（不存在）
        ↓
    检查缓存 → 没有
        ↓
    查询数据库 → 也没有
        ↓
    不缓存null值
        ↓
下次查询id=9999 → 又去数据库（重复无效查询）
```

**解决方案**：

```java
// 方案1：缓存空值（简单有效）
public User selectById(Integer id) {
    // 先查缓存
    User user = cache.get(id);
    
    if (user == null) {
        user = mapper.selectById(id);
        
        // 即使查询结果为null，也缓存起来
        if (user == null) {
            cache.put(id, new User());  // 缓存空对象，标记为"不存在"
        } else {
            cache.put(id, user);
        }
    }
    
    return user;
}

// 方案2：布隆过滤器（高级方案）
// 启动时把所有存在的ID加入布隆过滤器
// 查询前先判断，ID不在过滤器中直接返回null
if (!bloomFilter.contains(id)) {
    return null;  // 直接返回，不查数据库
}
```

### 6.2 缓存雪崩问题


> **什么是缓存雪崩**：大量缓存同时失效，所有请求瞬间打到数据库，就像雪山崩塌一样，数据库扛不住。

**问题场景**：

```
缓存雪崩示意：

正常情况：
请求 → 缓存(95%) → 返回
请求 → 数据库(5%) → 返回

雪崩时刻（缓存集体失效）：
请求 ↘
请求 → 数据库(100%) → 压力过大 → 崩溃
请求 ↗
```

**解决方案**：

```java
// 方案1：缓存时间加随机值
<cache flushInterval="#{60000 + random(0, 10000)}"/>  // 60-70秒随机

// 方案2：多级缓存（热点数据永不过期）
public User selectById(Integer id) {
    // 先查本地缓存
    User user = localCache.get(id);
    if (user != null) return user;
    
    // 再查Redis
    user = redisCache.get(id);
    if (user != null) {
        localCache.put(id, user);
        return user;
    }
    
    // 最后查数据库，并重建缓存
    user = mapper.selectById(id);
    redisCache.put(id, user);
    localCache.put(id, user);
    return user;
}

// 方案3：限流降级
// 数据库压力大时，部分请求直接返回默认值或错误
```

### 6.3 缓存一致性问题


> **核心问题**：数据库更新了，但缓存还是旧数据，用户看到的信息不准确。

**常见场景**：

```
数据不一致场景：

时间线：
t1: 用户A查询余额100元 → 缓存100元
t2: 用户B充值50元 → 数据库150元，但缓存还是100元
t3: 用户A再查询 → 从缓存拿，还是100元（错误！）
```

**解决方案对比**：

| 方案 | 做法 | 优点 | 缺点 | 适用场景 |
|-----|------|-----|------|---------|
| **先删缓存，再更新库** | `删除缓存 → 更新数据库` | `实现简单` | `短暂不一致` | `一致性要求不高` |
| **先更新库，再删缓存** | `更新数据库 → 删除缓存` | `数据较新` | `可能删除失败` | `读多写少场景` |
| **延迟双删** | `删缓存 → 更新库 → 等待 → 再删缓存` | `较强一致性` | `逻辑复杂` | `一致性要求高` |

```java
// 推荐方案：先更新库，再删缓存
@Transactional
public void updateUser(User user) {
    // 1. 更新数据库
    userMapper.updateUser(user);
    
    // 2. 删除缓存
    cache.remove(user.getId());
    
    // 下次查询会重新加载最新数据
}

// 高级方案：使用Canal监听数据库变更
// Canal监听MySQL binlog → 发现数据变更 → 自动删除/更新缓存
```

---

## 7. 📋 核心要点总结


### 7.1 缓存机制核心理解


```
🔸 一级缓存：个人笔记本，SqlSession内有效，默认开启
🔸 二级缓存：公共黑板，Mapper内共享，需手动开启
🔸 缓存目的：减少数据库访问，提升查询性能
🔸 缓存失效：增删改操作、手动清理、超时清理
🔸 第三方缓存：Redis分布式、EhCache本地化
🔸 缓存问题：穿透、雪崩、一致性要谨慎处理
```

### 7.2 使用建议与最佳实践


**📌 什么时候用一级缓存**：
- ✅ 同一个事务内多次查询相同数据
- ✅ 临时性的重复查询场景
- ✅ 不需要跨Session共享的数据

**📌 什么时候用二级缓存**：
- ✅ 查询频繁但修改少的数据（如：字典表、配置表）
- ✅ 多个用户查询相同的热点数据
- ✅ 对数据实时性要求不高的场景

**📌 什么时候用第三方缓存**：
- ✅ 分布式系统，多台服务器需要共享缓存
- ✅ 缓存数据需要持久化，应用重启不丢失
- ✅ 需要更精细的缓存控制和监控

**⚠️ 缓存使用注意事项**：

| 场景 | 建议 | 原因 |
|-----|------|------|
| **金融交易** | ❌ 不建议用缓存 | `实时性要求极高` |
| **用户信息** | ✅ 可以用短期缓存 | `查询多，偶尔更新` |
| **配置数据** | ✅ 推荐用二级缓存 | `极少变化` |
| **实时库存** | ⚠️ 谨慎使用 | `数据变化频繁` |

### 7.3 缓存配置速查表


```java
// 一级缓存（默认开启，无需配置）
SqlSession session = factory.openSession();
// 自动启用一级缓存

// 二级缓存（需要配置）
// 1. mybatis-config.xml
<setting name="cacheEnabled" value="true"/>

// 2. Mapper.xml
<cache 
    eviction="LRU"           // 清除策略
    flushInterval="60000"    // 60秒刷新
    size="512"               // 最多512个对象
    readOnly="false"/>       // 非只读（安全）

// 3. 实体类
public class User implements Serializable { }

// Redis缓存
<cache type="org.mybatis.caches.redis.RedisCache"/>

// EhCache缓存
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
```

### 7.4 问题排查清单


**🔍 缓存不生效排查步骤**：

```
Step 1: 检查配置
□ cacheEnabled是否为true？
□ Mapper是否配置<cache/>？
□ 实体类是否实现Serializable？

Step 2: 检查使用方式
□ 是否在同一个SqlSession？（一级缓存）
□ SqlSession是否提交/关闭？（二级缓存）
□ 查询参数是否完全一致？

Step 3: 检查失效条件
□ 是否执行了增删改操作？
□ 是否手动清空了缓存？
□ 缓存是否超时？
```

**核心记忆口诀**：
```
一级缓存默认开，Session内来循环
二级缓存要配置，Mapper内共分享
Redis分布式为王，EhCache本地强
穿透雪崩要防范，一致性是保障
实时数据别缓存，字典配置最适当
```