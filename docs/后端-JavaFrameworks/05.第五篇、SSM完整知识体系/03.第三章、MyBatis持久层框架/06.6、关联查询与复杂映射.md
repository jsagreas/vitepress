---
title: 6、关联查询与复杂映射
---
## 📚 目录

1. [关联查询基础概念](#1-关联查询基础概念)
2. [一对一关联查询](#2-一对一关联查询)
3. [一对多关联查询](#3-一对多关联查询)
4. [多对多关联查询](#4-多对多关联查询)
5. [嵌套查询vs嵌套结果](#5-嵌套查询vs嵌套结果)
6. [延迟加载机制](#6-延迟加载机制)
7. [性能优化策略](#7-性能优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 关联查询基础概念


### 1.1 什么是关联查询


**生活化理解**：
> 想象你在查学生信息，学生有班级，班级有老师。你不仅想知道学生叫什么名字，还想知道他在哪个班，班主任是谁。这就需要把多张表的数据"关联"起来查询。

**专业定义**：
关联查询是指在查询一个实体时，**同时查询与之相关的其他实体**的数据，MyBatis通过特殊的映射配置来处理这种关系。

### 1.2 三种关联关系对比


| 关联类型 | **生活例子** | **数据库关系** | **应用场景** |
|---------|------------|--------------|------------|
| **一对一** | `一个人 ↔ 一张身份证` | `主表主键 = 从表外键` | 用户详情、订单详情 |
| **一对多** | `一个班级 ↔ 多个学生` | `一条记录对应多条` | 部门员工、文章评论 |
| **多对多** | `多个学生 ↔ 多门课程` | `需要中间表关联` | 角色权限、商品标签 |

**关系图示**：
```
一对一：           一对多：           多对多：
 用户 → 详情        部门 → 员工        学生 ←→ 课程
  1:1              1:N               M:N
                                  (通过中间表)
```

### 1.3 为什么需要关联查询


**核心价值**：
- **减少查询次数**：一次SQL查出所有需要的数据
- **提高开发效率**：不用手动拼装对象关系
- **保证数据一致性**：在事务中一次性获取完整数据

---

## 2. 👤 一对一关联查询


### 2.1 业务场景理解


**现实案例**：
```
场景：查询用户信息时，同时获取用户的详细资料

用户表(user)          用户详情表(user_detail)
+----+------+         +----+---------+----------+
| id | name |         | id | user_id | address  |
+----+------+         +----+---------+----------+
| 1  | 张三 |  ←→     | 1  |    1    | 北京市   |
+----+------+         +----+---------+----------+

关系：一个用户只有一份详细资料
```

### 2.2 嵌套结果方式（推荐）


**实现原理**：一条SQL通过JOIN查出所有字段，然后映射到两个对象

**Java实体类**：
```java
// 用户类
public class User {
    private Integer id;
    private String name;
    private UserDetail detail;  // 关联的详情对象
}

// 用户详情类
public class UserDetail {
    private Integer id;
    private String address;
    private String phone;
}
```

**映射配置**：
```xml
<resultMap id="UserWithDetail" type="User">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    
    <!-- association标签：配置一对一关联 -->
    <association property="detail" javaType="UserDetail">
        <id property="id" column="detail_id"/>
        <result property="address" column="address"/>
        <result property="phone" column="phone"/>
    </association>
</resultMap>

<select id="getUserById" resultMap="UserWithDetail">
    SELECT 
        u.id, u.name,
        d.id as detail_id, d.address, d.phone
    FROM user u
    LEFT JOIN user_detail d ON u.id = d.user_id
    WHERE u.id = #{id}
</select>
```

**执行流程**：
```
1. 执行一条JOIN查询 → 返回一行结果
2. MyBatis看到association标签
3. 自动把前面字段映射给User，后面字段映射给UserDetail
4. 把UserDetail对象设置到User的detail属性中
```

### 2.3 嵌套查询方式


**实现原理**：先查主表，再根据外键查从表（执行两次SQL）

```xml
<resultMap id="UserWithDetail" type="User">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    
    <!-- column指定传给子查询的参数，select指定子查询的statement -->
    <association property="detail" 
                 column="id" 
                 select="selectDetailByUserId"/>
</resultMap>

<select id="getUserById" resultMap="UserWithDetail">
    SELECT id, name FROM user WHERE id = #{id}
</select>

<!-- 子查询：根据user_id查询详情 -->
<select id="selectDetailByUserId" resultType="UserDetail">
    SELECT * FROM user_detail WHERE user_id = #{id}
</select>
```

**执行流程**：
```
第1步：SELECT id, name FROM user WHERE id = 1
       ↓
第2步：拿到user.id = 1，执行子查询
       SELECT * FROM user_detail WHERE user_id = 1
       ↓
第3步：组装成完整的User对象（包含detail）
```

### 2.4 两种方式对比


| 对比项 | **嵌套结果（JOIN）** | **嵌套查询（子查询）** |
|-------|-------------------|---------------------|
| **SQL次数** | `1次` | `1+N次`（N是结果数） |
| **性能** | `高` | `低（可能N+1问题）` |
| **配置复杂度** | `稍复杂` | `简单` |
| **延迟加载** | `不支持` | `支持` |
| **推荐场景** | `数据量大、性能要求高` | `需要延迟加载` |

---

## 3. 👥 一对多关联查询


### 3.1 业务场景理解


**现实案例**：
```
场景：查询部门信息时，同时获取该部门的所有员工

部门表(dept)          员工表(employee)
+----+--------+       +----+---------+---------+
| id | name   |       | id | name    | dept_id |
+----+--------+       +----+---------+---------+
| 1  | 研发部 | ←┐    | 1  | 张三    |    1    |
+----+--------+  └─→  | 2  | 李四    |    1    |
                      | 3  | 王五    |    1    |
                      +----+---------+---------+

关系：一个部门有多个员工
```

### 3.2 嵌套结果方式（推荐）


**Java实体类**：
```java
public class Department {
    private Integer id;
    private String name;
    private List<Employee> employees;  // 一对多，用集合
}

public class Employee {
    private Integer id;
    private String name;
}
```

**映射配置**：
```xml
<resultMap id="DeptWithEmployees" type="Department">
    <id property="id" column="dept_id"/>
    <result property="name" column="dept_name"/>
    
    <!-- collection标签：配置一对多关联 -->
    <collection property="employees" ofType="Employee">
        <id property="id" column="emp_id"/>
        <result property="name" column="emp_name"/>
    </collection>
</resultMap>

<select id="getDeptById" resultMap="DeptWithEmployees">
    SELECT 
        d.id as dept_id, d.name as dept_name,
        e.id as emp_id, e.name as emp_name
    FROM dept d
    LEFT JOIN employee e ON d.id = e.dept_id
    WHERE d.id = #{id}
</select>
```

**关键理解**：
- `association` 用于**一对一**（属性是单个对象）
- `collection` 用于**一对多**（属性是集合List）
- `ofType` 指定集合中元素的类型

### 3.3 嵌套查询方式


```xml
<resultMap id="DeptWithEmployees" type="Department">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    
    <collection property="employees" 
                column="id" 
                select="selectEmployeesByDeptId"/>
</resultMap>

<select id="getDeptById" resultMap="DeptWithEmployees">
    SELECT * FROM dept WHERE id = #{id}
</select>

<!-- 子查询：根据dept_id查询员工列表 -->
<select id="selectEmployeesByDeptId" resultType="Employee">
    SELECT * FROM employee WHERE dept_id = #{id}
</select>
```

**执行流程可视化**：
```
查询部门ID=1的信息：

第1步：SELECT * FROM dept WHERE id = 1
       ↓ 得到部门对象
第2步：执行子查询
       SELECT * FROM employee WHERE dept_id = 1
       ↓ 得到3个员工
第3步：把3个员工设置到部门的employees集合中
```

---

## 4. 🔗 多对多关联查询


### 4.1 业务场景理解


**现实案例**：
```
场景：学生选课系统，一个学生选多门课，一门课被多个学生选

学生表(student)      中间表(student_course)    课程表(course)
+----+------+        +----+------------+----------+   +----+--------+
| id | name |        | id | student_id | course_id|   | id | name   |
+----+------+        +----+------------+----------+   +----+--------+
| 1  | 张三 | ←──→   | 1  |     1      |    1     |   | 1  | Java   |
| 2  | 李四 |        | 2  |     1      |    2     |   | 2  | MySQL  |
+----+------+        | 3  |     2      |    1     |   +----+--------+
                     +----+------------+----------+

解析：张三选了Java和MySQL，李四选了Java
```

### 4.2 多对多映射配置


**Java实体类**：
```java
public class Student {
    private Integer id;
    private String name;
    private List<Course> courses;  // 学生选的多门课程
}

public class Course {
    private Integer id;
    private String name;
}
```

**映射配置**：
```xml
<resultMap id="StudentWithCourses" type="Student">
    <id property="id" column="student_id"/>
    <result property="name" column="student_name"/>
    
    <!-- 通过中间表关联课程 -->
    <collection property="courses" ofType="Course">
        <id property="id" column="course_id"/>
        <result property="name" column="course_name"/>
    </collection>
</resultMap>

<select id="getStudentById" resultMap="StudentWithCourses">
    SELECT 
        s.id as student_id, s.name as student_name,
        c.id as course_id, c.name as course_name
    FROM student s
    LEFT JOIN student_course sc ON s.id = sc.student_id
    LEFT JOIN course c ON sc.course_id = c.id
    WHERE s.id = #{id}
</select>
```

**关键理解**：
- 多对多本质是**两个一对多的组合**
- 必须通过**中间表**连接
- 配置方式和一对多类似，都用`collection`

---

## 5. ⚙️ 嵌套查询vs嵌套结果


### 5.1 核心区别对比


**嵌套结果（Nested Results）**：
> 就像去超市一次性买齐所有东西，推着购物车逛一圈全拿到

```
执行方式：一条JOIN SQL
数据获取：一次性查出所有字段
性能：高（只执行一次数据库交互）
适用：数据量大、性能要求高的场景
```

**嵌套查询（Nested Select）**：
> 就像网购分开下单，先买主商品，再根据需要买配件

```
执行方式：主查询 + N次子查询
数据获取：分步骤查询
性能：低（可能产生N+1问题）
适用：需要延迟加载、数据不一定用到的场景
```

### 5.2 配置标签对比


| 配置方式 | **嵌套结果** | **嵌套查询** |
|---------|------------|-------------|
| **association** | `<association javaType="...">` | `<association select="..." column="..."/>` |
| **collection** | `<collection ofType="...">` | `<collection select="..." column="..."/>` |
| **特点** | `在resultMap内部定义映射` | `通过select属性调用另一个查询` |

### 5.3 选择建议


**🟢 优先使用嵌套结果**：
- 数据量较大（100+条记录）
- 关联数据必定会用到
- 性能要求高的场景

**🟡 考虑使用嵌套查询**：
- 关联数据不一定用到（需要延迟加载）
- 配置简单性优先
- 数据量很小的场景

---

## 6. ⏱️ 延迟加载机制


### 6.1 什么是延迟加载


**生活化理解**：
> 就像外卖APP，你点击"商家详情"才会加载评价和菜单，不点击就不加载，节省流量和时间。

**专业定义**：
延迟加载（Lazy Loading）是指关联对象**不会立即查询**，只有在真正访问该属性时才去数据库查询。

### 6.2 延迟加载配置


**全局配置（mybatis-config.xml）**：
```xml
<settings>
    <!-- 开启延迟加载 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    
    <!-- 按需加载（推荐）：只有调用具体属性才加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

**局部配置（Mapper.xml）**：
```xml
<!-- fetchType属性控制该关联是否延迟加载 -->
<association property="detail" 
             select="selectDetail" 
             column="id"
             fetchType="lazy"/>  <!-- lazy=延迟  eager=立即 -->
```

### 6.3 延迟加载原理


**执行流程对比**：
```
立即加载：
user = getUser(1)  → 执行2条SQL → user和detail都有数据
访问user.getDetail() → 直接返回（数据已加载）

延迟加载：
user = getUser(1)  → 只执行1条SQL → 只有user有数据
访问user.getName() → 直接返回（不触发）
访问user.getDetail() → 此时才执行SQL加载detail
```

**底层实现**：
- MyBatis使用**CGLIB或Javassist动态代理**
- 当访问延迟属性时，代理对象拦截调用
- 执行对应的SQL查询并返回结果

### 6.4 延迟加载应用场景


**🟢 适合延迟加载**：
```java
// 场景：查询用户列表，不一定展示详情
List<User> users = userMapper.getAllUsers();
for(User user : users) {
    System.out.println(user.getName());  // 只需要名字
    // user.getDetail() 不调用，就不查询detail表
}
```

**🔴 不适合延迟加载**：
```java
// 场景：必然要用到关联数据
User user = userMapper.getUserById(1);
System.out.println(user.getDetail().getAddress());  
// 反而多了一次数据库交互，不如直接JOIN
```

### 6.5 立即加载配置


**配置方式**：
```xml
<!-- fetchType="eager" 强制立即加载 -->
<association property="detail" 
             select="selectDetail" 
             column="id"
             fetchType="eager"/>
```

**使用场景**：
- 全局开启了延迟加载
- 但某个关联数据必须立即查询
- 通过`fetchType="eager"`覆盖全局配置

---

## 7. 🚀 性能优化策略


### 7.1 N+1查询问题


**问题描述**：
```
查询10个部门，每个部门查询员工列表
第1条SQL：SELECT * FROM dept (查10个部门)
第2-11条SQL：SELECT * FROM emp WHERE dept_id=? (每个部门执行1次)

总共执行：1 + 10 = 11 条SQL
这就是 N+1 问题（1条主查询 + N条子查询）
```

**性能影响**：
```
执行10条SQL   → 约10次数据库交互  → 网络延迟10次
执行100条SQL  → 约100次数据库交互 → 网络延迟100次
执行1000条SQL → 系统可能卡死！
```

### 7.2 解决方案1：嵌套结果


**优化前（N+1问题）**：
```xml
<collection property="employees" 
            select="selectEmployees" 
            column="id"/>
<!-- 执行：1 + N 条SQL -->
```

**优化后（JOIN查询）**：
```xml
<select id="getDepartments" resultMap="DeptWithEmployees">
    SELECT 
        d.id, d.name,
        e.id as emp_id, e.name as emp_name
    FROM dept d
    LEFT JOIN employee e ON d.id = e.dept_id
</select>
<!-- 只执行：1 条SQL -->
```

### 7.3 解决方案2：批量查询


**优化思路**：
```
原来：查10个部门 → 执行10次 SELECT * FROM emp WHERE dept_id=?
优化：查10个部门 → 执行1次  SELECT * FROM emp WHERE dept_id IN (1,2,3...10)
```

**配置方式**：
```xml
<collection property="employees" 
            column="{deptIds=id}"
            select="selectEmployeesBatch"/>

<select id="selectEmployeesBatch" resultType="Employee">
    SELECT * FROM employee 
    WHERE dept_id IN
    <foreach collection="deptIds" item="id" 
             open="(" separator="," close=")">
        #{id}
    </foreach>
</select>
```

### 7.4 优化策略总结


| 优化方法 | **适用场景** | **优化效果** | **实现难度** |
|---------|------------|------------|------------|
| **嵌套结果** | `关联数据必用` | `最佳（1条SQL）` | `中等` |
| **批量查询** | `嵌套查询优化` | `较好（2条SQL）` | `较高` |
| **延迟加载** | `关联数据可选` | `较好（按需查询）` | `低` |
| **分页查询** | `数据量大` | `必需（减少数据量）` | `低` |

### 7.5 最佳实践建议


**🔸 设计阶段**：
- 明确哪些关联数据是必需的
- 评估数据量级（是100条还是10000条）
- 选择合适的加载策略

**🔸 开发阶段**：
```java
// ✅ 推荐：按需选择查询方法
getUserBasicInfo()      // 只查用户基本信息
getUserWithDetail()     // 查用户+详情
getUserWithOrders()     // 查用户+订单

// ❌ 不推荐：一个方法查所有
getUser() // 查用户+详情+订单+地址+...（太重了）
```

**🔸 监控阶段**：
- 开启MyBatis SQL日志
- 监控慢SQL（超过100ms）
- 分析是否存在N+1问题

---

## 8. 📋 核心要点总结


### 8.1 关键概念回顾


**🔸 三种关联关系**：
```
一对一：用 association + javaType
一对多：用 collection + ofType  
多对多：两个一对多 + 中间表
```

**🔸 两种查询方式**：
```
嵌套结果：一条JOIN SQL（高性能）
嵌套查询：主查询+子查询（支持延迟加载）
```

**🔸 加载策略**：
```
立即加载（eager）：查询时就加载关联数据
延迟加载（lazy）：访问时才加载关联数据
```

### 8.2 配置标签速查


| 标签 | **作用** | **关键属性** |
|------|---------|------------|
| `<association>` | `一对一关联` | `property, javaType, select, column` |
| `<collection>` | `一对多关联` | `property, ofType, select, column` |
| `fetchType` | `加载策略` | `lazy(延迟), eager(立即)` |
| `column` | `传参` | `传单个值或{key=value}` |

### 8.3 性能优化记忆


**⚠️ N+1问题识别**：
```
看到嵌套查询 + 循环 → 警惕N+1
主查询返回N条 → 子查询执行N次 → 性能杀手
```

**✅ 优化方案选择**：
```
必用关联数据 → 嵌套结果（JOIN）
可选关联数据 → 延迟加载
无法JOIN → 批量查询（IN语句）
```

### 8.4 实战开发建议


**🎯 关联查询三步法**：
1. **明确关系**：一对一？一对多？多对多？
2. **选择方式**：嵌套结果还是嵌套查询？
3. **优化性能**：是否延迟加载？是否有N+1？

**📝 配置检查清单**：
- [ ] resultMap的id和property是否对应
- [ ] column别名是否避免冲突
- [ ] 一对多是否用了collection而不是association
- [ ] 延迟加载是否全局和局部配置一致
- [ ] SQL是否有性能问题（用EXPLAIN分析）

---

**💡 核心记忆口诀**：
```
一对一用association，一对多collection分
嵌套结果JOIN快，嵌套查询能延迟
N+1是大坑，批量JOIN解决它
延迟加载按需用，性能优化要记心
```