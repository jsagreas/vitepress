---
title: 8、MyBatis插件与扩展
---
## 📚 目录

1. [插件机制原理](#1-插件机制原理)
2. [四大拦截器详解](#2-四大拦截器详解)
3. [自定义插件开发](#3-自定义插件开发)
4. [分页插件PageHelper](#4-分页插件pagehelper)
5. [性能监控插件](#5-性能监控插件)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔧 插件机制原理


### 1.1 什么是MyBatis插件


**通俗理解**：就像给汽车加装改装件一样，MyBatis插件就是在框架运行过程中"插入"一些自定义功能

```
原始MyBatis流程：
SQL准备 → 执行SQL → 处理结果

加入插件后：
SQL准备 → [插件1拦截] → 执行SQL → [插件2拦截] → 处理结果
          ↑ 可以修改SQL         ↑ 可以修改结果
```

**核心概念**：
- `插件(Plugin)`：扩展MyBatis功能的组件
- `拦截器(Interceptor)`：插件的实现接口
- `拦截点`：可以"插手"的关键位置

> **💡 生活类比**：插件就像快递中转站的安检员，可以在包裹运输过程中检查、记录、甚至修改包裹内容

### 1.2 插件的工作原理


**拦截链机制**：
```
执行流程：
                   拦截器A
                     ↓
原始对象 → 代理对象 → 拦截器B → 目标方法
                     ↓
                   拦截器C

每个拦截器就像一层"包装纸"，层层嵌套
```

**代理模式应用**：
- MyBatis使用`动态代理`技术
- 在目标对象外面"包"一层代理
- 调用方法时先经过代理层的拦截处理

**关键特点**：
- ✅ 非侵入式：不修改MyBatis源码
- ✅ 灵活扩展：可随时添加或移除
- ✅ 责任链模式：多个插件按顺序执行

---

## 2. 🎯 四大拦截器详解


### 2.1 四大核心拦截点


MyBatis提供了**4个关键位置**可以进行拦截，就像高速公路的4个收费站：

```
SQL执行全流程：

1️⃣ Executor(执行器)
   ↓ [拦截点1：控制SQL执行流程]
   
2️⃣ StatementHandler(语句处理器)  
   ↓ [拦截点2：控制SQL语句准备]
   
3️⃣ ParameterHandler(参数处理器)
   ↓ [拦截点3：控制参数设置]
   
4️⃣ ResultSetHandler(结果处理器)
   ↓ [拦截点4：控制结果转换]
   
最终结果返回
```

### 2.2 Executor执行器拦截


**作用场景**：在SQL执行的最外层拦截

**能做什么**：
- 🔸 控制事务管理
- 🔸 实现缓存功能
- 🔸 SQL执行日志记录
- 🔸 数据权限控制

**可拦截的方法**：

| 方法名 | 说明 | 使用场景 |
|--------|------|----------|
| `update()` | 执行增删改操作 | 记录数据变更日志 |
| `query()` | 执行查询操作 | 实现缓存、分页 |
| `commit()` | 提交事务 | 事务监控 |
| `rollback()` | 回滚事务 | 异常处理 |

**通俗解释**：
> Executor就像工厂的总管，管理整个生产流程。在这里拦截，可以控制整个SQL执行的"大方向"

### 2.3 StatementHandler语句处理器拦截


**作用场景**：在SQL语句准备阶段拦截

**能做什么**：
- 🔸 修改SQL语句（如添加分页）
- 🔸 SQL审计和监控
- 🔸 动态SQL改写
- 🔸 SQL执行统计

**可拦截的方法**：

| 方法名 | 说明 | 典型应用 |
|--------|------|----------|
| `prepare()` | 准备Statement对象 | SQL监控 |
| `parameterize()` | 设置参数 | 参数加密 |
| `query()` | 执行查询 | 添加分页逻辑 |
| `update()` | 执行更新 | SQL改写 |

**通俗解释**：
> StatementHandler就像厨师准备菜品，可以在这里调整"菜谱"（SQL语句），比如加点调料（添加WHERE条件）

### 2.4 ParameterHandler参数处理器拦截


**作用场景**：在设置SQL参数时拦截

**能做什么**：
- 🔸 参数加密/解密
- 🔸 参数格式转换
- 🔸 敏感信息脱敏
- 🔸 参数校验

**可拦截的方法**：

```
setParameters(PreparedStatement ps)
↓
作用：为SQL语句中的 ? 占位符赋值
```

**实际应用举例**：
```
原始SQL：SELECT * FROM user WHERE phone = ?
参数值：13800138000

经过拦截器处理：
→ 加密后：138****8000（脱敏显示）
→ 或者：加密存储到数据库
```

**通俗解释**：
> ParameterHandler就像快递员填写面单，可以在这里对信息进行"打码"处理（脱敏）

### 2.5 ResultSetHandler结果处理器拦截


**作用场景**：在处理SQL执行结果时拦截

**能做什么**：
- 🔸 结果加密/解密
- 🔸 数据脱敏展示
- 🔸 结果格式转换
- 🔸 敏感数据过滤

**可拦截的方法**：

```
handleResultSets(Statement stmt)
↓
作用：将ResultSet结果集转换为Java对象
```

**实际应用场景**：
```
数据库原始数据：
name: "张三"
phone: "13800138000"
idCard: "110101199001011234"

经过拦截器处理后返回：
name: "张三"
phone: "138****8000"     ← 手机号脱敏
idCard: "1101**********34" ← 身份证脱敏
```

**通俗解释**：
> ResultSetHandler就像收银台打印小票，可以决定哪些信息显示完整，哪些信息需要"打码"

---

## 3. 🛠️ 自定义插件开发


### 3.1 核心注解说明


**@Intercepts 注解**：
- **作用**：标记这是一个拦截器
- **位置**：写在拦截器类上
- **通俗理解**：告诉MyBatis"我要拦截某些操作"

**@Signature 注解**：
- **作用**：指定拦截的具体方法
- **位置**：写在@Intercepts里面
- **包含信息**：
  - `type`：拦截哪个类（四大类型之一）
  - `method`：拦截哪个方法
  - `args`：方法的参数类型

**注解关系图**：
```
@Intercepts({
    @Signature(
        type = Executor.class,      ← 拦截执行器
        method = "query",           ← 拦截查询方法
        args = {参数类型列表}        ← 指定方法签名
    )
})
```

### 3.2 开发步骤详解


**步骤1️⃣ 实现Interceptor接口**
```java
// Interceptor是所有插件的"父类接口"
public class MyPlugin implements Interceptor {
    // 三个必须实现的方法
}
```

**步骤2️⃣ 重写三个核心方法**

| 方法名 | 作用 | 通俗解释 |
|--------|------|----------|
| `intercept()` | 拦截逻辑实现 | 真正干活的地方 |
| `plugin()` | 创建代理对象 | 包装目标对象 |
| `setProperties()` | 设置插件参数 | 接收配置信息 |

**步骤3️⃣ 配置插件**
```xml
<!-- 在mybatis-config.xml中注册插件 -->
<plugins>
    <plugin interceptor="com.example.MyPlugin">
        <!-- 可选：传递配置参数 -->
        <property name="param1" value="value1"/>
    </plugin>
</plugins>
```

### 3.3 完整示例：SQL日志插件


**需求**：记录每条SQL的执行时间

**实现思路**：
```
执行前：记录开始时间
  ↓
执行SQL：让原方法继续执行
  ↓
执行后：计算耗时并打印日志
```

**关键代码**：
```java
@Intercepts({
    @Signature(
        type = Executor.class,
        method = "query",
        args = {MappedStatement.class, Object.class, 
                RowBounds.class, ResultHandler.class}
    )
})
public class SqlTimingPlugin implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) {
        long start = System.currentTimeMillis();
        
        // 执行原方法
        Object result = invocation.proceed();
        
        long end = System.currentTimeMillis();
        System.out.println("SQL执行耗时: " + (end - start) + "ms");
        
        return result;
    }
}
```

**通俗理解**：
> 就像给运动员计时，在起跑时按下秒表，到达终点时停止，然后公布成绩

---

## 4. 📄 分页插件PageHelper


### 4.1 为什么需要分页插件


**问题场景**：
```
没有分页：
SELECT * FROM user             ← 查询100万条数据
↓
结果：内存溢出，系统崩溃 ❌

使用分页：
SELECT * FROM user LIMIT 0,10  ← 只查10条数据
↓
结果：快速响应，用户体验好 ✅
```

**传统分页的痛点**：
- ❌ 每个SQL都要手写`LIMIT`语句
- ❌ 不同数据库分页语法不同（MySQL、Oracle、SQL Server）
- ❌ 分页参数计算容易出错

**PageHelper解决方案**：
- ✅ 自动添加分页SQL
- ✅ 自动适配不同数据库
- ✅ 简化分页参数设置

### 4.2 PageHelper工作原理


**拦截时机**：在`StatementHandler`层拦截

**工作流程**：
```
1. 调用PageHelper.startPage(1, 10)
   ↓ 设置分页参数到ThreadLocal
   
2. 执行查询方法
   ↓ 插件拦截到查询操作
   
3. 改写SQL语句
   ↓ 自动添加 LIMIT 0, 10
   
4. 执行改写后的SQL
   ↓ 获取分页数据
   
5. 封装分页结果
   ↓ 返回PageInfo对象
```

**SQL改写示例**：
```
原始SQL：
SELECT * FROM user WHERE age > 18

MySQL改写后：
SELECT * FROM user WHERE age > 18 LIMIT 0, 10

Oracle改写后：
SELECT * FROM (
  SELECT ROWNUM rn, t.* FROM user t WHERE age > 18
) WHERE rn BETWEEN 1 AND 10
```

### 4.3 使用方法详解


**核心API**：

| 方法 | 参数 | 说明 |
|------|------|------|
| `PageHelper.startPage(pageNum, pageSize)` | 页码、每页条数 | 开始分页 |
| `PageInfo<T>(list)` | 查询结果List | 封装分页信息 |

**标准使用流程**：
```java
// 1. 设置分页参数
PageHelper.startPage(1, 10);  // 第1页，每页10条

// 2. 执行查询（无需修改Mapper）
List<User> userList = userMapper.selectAll();

// 3. 封装分页结果
PageInfo<User> pageInfo = new PageInfo<>(userList);
```

**PageInfo提供的信息**：
```
pageInfo对象包含：
├── list          ← 当前页数据
├── pageNum       ← 当前页码
├── pageSize      ← 每页条数
├── total         ← 总记录数
├── pages         ← 总页数
├── isFirstPage   ← 是否首页
├── isLastPage    ← 是否末页
└── navigatepageNums ← 导航页码数组 [1,2,3,4,5]
```

**前端展示应用**：
```
获取分页数据：pageInfo.getList()
显示页码导航：共 pageInfo.getPages() 页
上一页按钮：pageInfo.isFirstPage() ? 禁用 : 启用
下一页按钮：pageInfo.isLastPage() ? 禁用 : 启用
```

### 4.4 配置说明


**Spring Boot配置**：
```properties
# 指定数据库类型（可选，自动检测）
pagehelper.helper-dialect=mysql

# 分页合理化（防止页码超出范围）
pagehelper.reasonable=true

# 支持通过Mapper接口参数传递分页参数
pagehelper.support-methods-arguments=true
```

**关键配置项解释**：

| 配置项 | 说明 | 示例 |
|--------|------|------|
| `reasonable=true` | 页码修正（超出范围自动调整） | 请求第100页但只有10页→返回第10页 |
| `support-methods-arguments=true` | 支持方法参数分页 | 方法参数直接传pageNum和pageSize |

---

## 5. 📊 性能监控插件


### 5.1 为什么需要性能监控


**实际问题**：
```
开发环境：一切正常 ✅
↓
上线后：
- 某个页面加载超过10秒 ❌
- 数据库CPU飙升到100% ❌
- 用户投诉系统卡顿 ❌

原因：慢SQL导致的性能问题
```

**性能监控的价值**：
- 🔍 **发现慢SQL**：找出执行时间长的语句
- 📈 **统计分析**：分析SQL执行频率
- ⚠️ **预警机制**：超过阈值自动告警
- 🔧 **优化依据**：提供优化方向

### 5.2 监控插件实现思路


**核心功能**：
1. 记录SQL执行时间
2. 统计SQL执行次数
3. 慢SQL日志记录
4. 性能指标收集

**拦截位置选择**：

```
Executor层拦截：
✅ 优点：统计更全面（包括缓存命中）
✅ 适合：整体性能监控

StatementHandler层拦截：
✅ 优点：SQL信息更详细
✅ 适合：SQL级别分析
```

**监控指标**：

| 指标 | 说明 | 阈值建议 |
|------|------|----------|
| **执行时间** | SQL执行耗时 | >1000ms需优化 |
| **执行次数** | SQL调用频率 | 高频SQL需缓存 |
| **影响行数** | 更新/删除的行数 | 大批量操作需分批 |
| **连接等待** | 获取连接耗时 | >100ms检查连接池 |

### 5.3 慢SQL日志插件示例


**功能说明**：记录超过指定时间的SQL

**核心逻辑**：
```java
@Intercepts({
    @Signature(
        type = Executor.class,
        method = "query",
        args = {MappedStatement.class, Object.class, 
                RowBounds.class, ResultHandler.class}
    )
})
public class SlowSqlPlugin implements Interceptor {
    
    private long slowSqlThreshold = 1000; // 慢SQL阈值：1秒
    
    @Override
    public Object intercept(Invocation invocation) {
        long start = System.currentTimeMillis();
        
        Object result = invocation.proceed();
        
        long duration = System.currentTimeMillis() - start;
        
        if (duration > slowSqlThreshold) {
            // 记录慢SQL
            logSlowSql(invocation, duration);
        }
        
        return result;
    }
}
```

**日志输出示例**：
```
[慢SQL告警] 执行时间: 1523ms
SQL: SELECT * FROM order WHERE user_id = ?
参数: [10086]
建议: 为user_id字段添加索引
```

### 5.4 性能监控最佳实践


**分级告警策略**：

| 级别 | 耗时 | 处理方式 |
|------|------|----------|
| 🟢 正常 | <500ms | 仅记录日志 |
| 🟡 警告 | 500-1000ms | 日志+监控 |
| 🟠 严重 | 1000-3000ms | 日志+告警+记录 |
| 🔴 紧急 | >3000ms | 日志+告警+记录+人工介入 |

**监控数据应用**：
```
日常运维：
- 定期查看慢SQL报表
- 分析高频SQL是否需要优化
- 监控数据库负载趋势

性能优化：
- 找出TOP10慢SQL进行优化
- 分析执行计划添加索引
- 考虑缓存高频查询结果
```

---

## 6. 📋 核心要点总结


### 6.1 插件机制理解


**核心概念回顾**：
```
插件本质：
- 基于代理模式的拦截机制
- 在关键节点"插入"自定义逻辑
- 非侵入式扩展框架功能

四大拦截点：
1️⃣ Executor      → 控制执行流程（最外层）
2️⃣ StatementHandler → 修改SQL语句（核心层）
3️⃣ ParameterHandler → 处理参数（细节层）
4️⃣ ResultSetHandler → 处理结果（输出层）
```

### 6.2 常用插件场景


| 插件类型 | 拦截位置 | 典型应用 | 重要程度 |
|----------|----------|----------|----------|
| **分页插件** | StatementHandler | PageHelper自动分页 | ⭐⭐⭐ |
| **性能监控** | Executor | SQL执行时间统计 | ⭐⭐⭐ |
| **数据脱敏** | ResultSetHandler | 敏感信息隐藏 | ⭐⭐ |
| **参数加密** | ParameterHandler | 密码加密存储 | ⭐⭐ |
| **权限控制** | Executor | 数据权限过滤 | ⭐⭐ |

### 6.3 开发注意事项


**⚠️ 关键要点**：
- 性能影响：插件会增加额外开销，避免过度使用
- 拦截顺序：多个插件按配置顺序执行（先配置先执行）
- 线程安全：注意ThreadLocal的使用和清理
- 异常处理：拦截器中的异常要妥善处理

**✅ 最佳实践**：
```
1. 选择合适的拦截点
   → 根据需求选择最合适的层级

2. 控制插件数量
   → 不超过3个插件（性能考虑）

3. 参数化配置
   → 插件参数通过配置文件管理

4. 完善日志记录
   → 方便问题排查和性能分析
```

### 6.4 学习路径建议


**新手学习顺序**：
```
第1步：理解插件原理
  ↓ 掌握代理模式和拦截机制
  
第2步：使用现成插件
  ↓ PageHelper分页插件实践
  
第3步：简单插件开发
  ↓ 开发SQL日志插件
  
第4步：复杂功能实现
  ↓ 性能监控、数据脱敏等
```

**实践建议**：
- 📖 先用成熟插件（PageHelper）
- 🔧 再学简单插件开发（日志插件）
- 🚀 最后挑战复杂场景（性能监控）

---

## 📌 快速记忆口诀


```
MyBatis插件四大员，
执行器、语句、参数、结果都能拦。
Executor管流程事务缓存全，
StatementHandler改SQL分页来实现。
ParameterHandler参数脱敏和加密，
ResultSetHandler结果格式任你转。
PageHelper分页最常用，
性能监控慢SQL现。
拦截注解要配对，
插件开发三步走不难！
```

**核心记住**：
- 🎯 4个拦截点各有分工
- 🔧 PageHelper解决分页问题
- 📊 性能监控发现慢SQL
- 🛠️ 自定义插件三步走：实现接口→配置注解→注册使用