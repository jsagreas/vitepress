---
title: 2、SQL映射文件详解
---
## 📚 目录

1. [Mapper命名空间详解](#1-Mapper命名空间详解)
2. [查询语句配置](#2-查询语句配置)
3. [增删改语句配置](#3-增删改语句配置)
4. [参数传递机制](#4-参数传递机制)
5. [结果映射处理](#5-结果映射处理)
6. [自动映射机制](#6-自动映射机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 Mapper命名空间详解


### 1.1 什么是命名空间

🎯 **简单理解**：命名空间就像"门牌号"，告诉MyBatis这个配置文件对应哪个接口

```
生活中的例子：
楼栋编号：用来区分不同的楼
门牌号码：用来找到具体的住户

MyBatis中的类比：
包名+类名：com.example.mapper.UserMapper
命名空间：把配置文件和接口对应起来
```

**🔸 命名空间的作用**
```
核心功能：
✅ 绑定关系：将XML配置文件与Mapper接口关联
✅ 防止冲突：不同Mapper的SQL语句ID可以重复
✅ 调用标识：通过"命名空间.方法名"调用SQL语句
```

### 1.2 命名空间配置示例

**📝 基础配置结构**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace必须是Mapper接口的全限定名 -->
<mapper namespace="com.example.mapper.UserMapper">
    
    <!-- 这里配置SQL语句 -->
    
</mapper>
```

**💡 配置要点说明**
```
命名空间规则：
1. 必须写接口的完整路径（包名+类名）
2. 路径要和实际的接口位置完全一致
3. 一个配置文件只能有一个命名空间
4. 命名空间值要区分大小写

错误示例：
❌ namespace="UserMapper"           # 缺少包名
❌ namespace="com.example.UserMapper" # 路径不对
❌ namespace不写                     # 必须要有

正确示例：
✅ namespace="com.example.mapper.UserMapper"
```

### 1.3 命名空间与接口对应关系

**🔗 配置文件与接口的关联**

```
项目结构示例：
src/main/java/
  └── com/example/mapper/
      └── UserMapper.java          ← 接口文件

src/main/resources/
  └── mapper/
      └── UserMapper.xml           ← 配置文件

关联关系：
UserMapper.xml的namespace值 = UserMapper.java的全路径
```

**Mapper接口定义**
```java
package com.example.mapper;

public interface UserMapper {
    User findById(Long id);      // 方法名
    List<User> findAll();        
    int insert(User user);
}
```

**对应的XML配置**
```xml
<mapper namespace="com.example.mapper.UserMapper">
    
    <!-- id必须和接口中的方法名一致 -->
    <select id="findById" resultType="User">
        SELECT * FROM users WHERE id = #{id}
    </select>
    
    <select id="findAll" resultType="User">
        SELECT * FROM users
    </select>
    
    <insert id="insert">
        INSERT INTO users VALUES(...)
    </insert>
</mapper>
```

---

## 2. 🔍 查询语句配置


### 2.1 select查询的基本结构

🎯 **核心理解**：select标签用来配置查询SQL语句

**📋 select标签的属性说明**

| 属性 | **作用** | **是否必填** | **示例值** |
|-----|---------|------------|-----------|
| `id` | `方法名标识` | `必填` | `findById` |
| `parameterType` | `参数类型` | `可选` | `Long`、`User` |
| `resultType` | `返回类型` | `二选一` | `User`、`Map` |
| `resultMap` | `结果映射` | `二选一` | `userResultMap` |

**🔸 最简单的查询配置**
```xml
<!-- 根据ID查询用户 -->
<select id="findById" resultType="com.example.entity.User">
    SELECT id, username, email 
    FROM users 
    WHERE id = #{id}
</select>
```

**💡 配置说明（新手必看）**
```
这段配置的含义：
1. id="findById"
   → 对应接口中的findById方法

2. resultType="com.example.entity.User"  
   → 查询结果封装成User对象
   → MyBatis会自动把数据库字段映射到User的属性

3. #{id}
   → 这是参数占位符
   → 会自动从方法参数中获取id的值
   → 等价于JDBC中的 ?
```

### 2.2 查询结果的处理方式

**📊 单个对象 vs 集合对象**

```xml
<!-- 场景1：查询单个用户 -->
<select id="findById" resultType="User">
    SELECT * FROM users WHERE id = #{id}
</select>

<!-- 对应接口方法 -->
User findById(Long id);

<!-- 场景2：查询用户列表 -->
<select id="findAll" resultType="User">
    SELECT * FROM users
</select>

<!-- 对应接口方法 -->
List<User> findAll();
```

**💡 返回值类型说明**
```
resultType配置规则：

1. 返回单个对象
   resultType="User"              # 简写（需要配置别名）
   resultType="com.example.entity.User"  # 完整类名

2. 返回集合
   resultType仍然写单个对象的类型
   ✅ resultType="User"            # 正确
   ❌ resultType="List<User>"      # 错误，不要写List

3. MyBatis自动判断
   如果方法返回List，自动封装为List
   如果方法返回单个对象，只取第一条记录
```

### 2.3 条件查询配置

**🔎 动态条件查询示例**

```xml
<!-- 根据用户名模糊查询 -->
<select id="findByName" resultType="User">
    SELECT * FROM users 
    WHERE username LIKE concat('%', #{username}, '%')
</select>

<!-- 多条件查询 -->
<select id="findByCondition" resultType="User">
    SELECT * FROM users 
    WHERE age > #{minAge} 
      AND city = #{city}
</select>

<!-- 动态SQL查询（可选条件） -->
<select id="findByDynamicCondition" resultType="User">
    SELECT * FROM users
    <where>
        <if test="username != null">
            AND username = #{username}
        </if>
        <if test="email != null">
            AND email = #{email}
        </if>
    </where>
</select>
```

**🔸 动态SQL的理解**
```
场景说明：
有时候查询条件不是固定的，可能有的参数传了，有的没传

例如搜索功能：
- 用户可能只输入用户名
- 用户可能只输入邮箱
- 用户可能两个都输入

解决方案：
使用<if>标签判断参数是否存在
只有参数不为空时，才添加这个查询条件
```

---

## 3. ✏️ 增删改语句配置


### 3.1 insert插入语句

**📝 新增数据配置示例**

```xml
<!-- 基础插入 -->
<insert id="insert">
    INSERT INTO users(username, email, age) 
    VALUES(#{username}, #{email}, #{age})
</insert>

<!-- 插入并返回主键 -->
<insert id="insertAndGetId" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO users(username, email, age) 
    VALUES(#{username}, #{email}, #{age})
</insert>
```

**💡 主键回填说明**
```
useGeneratedKeys="true" 的作用：

问题场景：
插入数据后，想知道这条记录的ID是多少
比如：插入用户后，立即用这个用户ID插入其他关联数据

解决方案：
useGeneratedKeys="true"   → 开启主键回填
keyProperty="id"          → 把生成的ID设置到对象的id属性

实际效果：
User user = new User("张三", "zhangsan@qq.com", 25);
userMapper.insert(user);
System.out.println(user.getId());  // 可以直接获取到新插入数据的ID
```

### 3.2 update更新语句

**🔄 数据更新配置**

```xml
<!-- 全字段更新 -->
<update id="update">
    UPDATE users 
    SET username = #{username},
        email = #{email},
        age = #{age}
    WHERE id = #{id}
</update>

<!-- 动态更新（只更新有值的字段） -->
<update id="updateSelective">
    UPDATE users
    <set>
        <if test="username != null">username = #{username},</if>
        <if test="email != null">email = #{email},</if>
        <if test="age != null">age = #{age}</if>
    </set>
    WHERE id = #{id}
</update>
```

**🔸 动态更新的应用场景**
```
为什么需要动态更新？

场景1：修改用户资料
用户只修改了邮箱，不想影响其他字段
如果用全字段更新，其他字段会被设置为null

场景2：批量修改
只想修改符合条件的某些字段
其他字段保持原值不变

动态更新的好处：
✅ 只更新传入的字段
✅ 没有传入的字段保持原值
✅ 避免误操作覆盖数据
```

### 3.3 delete删除语句

**🗑️ 数据删除配置**

```xml
<!-- 根据ID删除 -->
<delete id="deleteById">
    DELETE FROM users WHERE id = #{id}
</delete>

<!-- 批量删除 -->
<delete id="deleteByIds">
    DELETE FROM users 
    WHERE id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</delete>

<!-- 条件删除 -->
<delete id="deleteByCondition">
    DELETE FROM users 
    WHERE age > #{age} AND status = #{status}
</delete>
```

**💡 批量删除的理解**
```
<foreach>标签的作用：
遍历集合，拼接SQL语句

假设传入的ids = [1, 2, 3]

执行流程：
collection="ids"    → 要遍历的集合参数名
item="id"          → 每次遍历的元素叫id
open="("           → 开始时加上 (
separator=","      → 每个元素之间用 , 分隔
close=")"          → 结束时加上 )

最终生成的SQL：
DELETE FROM users WHERE id IN (1, 2, 3)
```

---

## 4. 🔗 参数传递机制


### 4.1 #{}参数占位符（推荐）

**🎯 核心理解**：`#{}`是预编译占位符，安全且高效

**📋 #{}的工作原理**
```
#{} 会做这些事情：

1. 预编译处理
   SQL: SELECT * FROM users WHERE id = #{id}
   转换: SELECT * FROM users WHERE id = ?
   
2. 参数类型转换
   自动根据Java类型转换为数据库类型
   
3. 防SQL注入
   把参数作为值处理，而不是SQL语句的一部分
```

**🔸 常见使用场景**
```xml
<!-- 场景1：单个简单参数 -->
<select id="findById" resultType="User">
    SELECT * FROM users WHERE id = #{id}
</select>

<!-- 场景2：对象参数 -->
<insert id="insert">
    INSERT INTO users(username, email) 
    VALUES(#{username}, #{email})
</insert>

<!-- 场景3：多个参数（使用@Param注解） -->
<select id="findByNameAndAge" resultType="User">
    SELECT * FROM users 
    WHERE username = #{name} AND age = #{age}
</select>

<!-- 对应接口方法 -->
List<User> findByNameAndAge(@Param("name") String username, 
                            @Param("age") Integer age);
```

**💡 参数传递说明**
```
参数获取规则：

1. 单个参数
   直接写 #{任意名称} 都可以
   但建议写成有意义的名称

2. 对象参数  
   #{属性名}，自动调用get方法
   User对象有username属性 → #{username}

3. 多个参数
   必须在接口方法上加@Param注解
   @Param("name") → #{name}
   不加注解会报错！
```

### 4.2 ${}字符串替换（谨慎使用）

**⚠️ 核心理解**：`${}`是字符串替换，存在SQL注入风险

**🔸 ${}的工作原理**
```
${} 的处理方式：

1. 直接拼接字符串
   SQL: SELECT * FROM users WHERE name = '${name}'
   name传入 "张三"
   结果: SELECT * FROM users WHERE name = '张三'

2. 不做类型转换
   原样拼接到SQL中

3. 不防SQL注入
   ⚠️ 危险：用户可以注入恶意SQL代码
```

**📊 #{} vs ${} 对比**

| 特性 | **#{}占位符** | **${}替换** |
|------|-------------|-----------|
| 🔸 **处理方式** | `预编译?占位` | `直接字符串拼接` |
| 🔸 **SQL注入** | `安全，防注入` | `不安全，有风险` |
| 🔸 **性能** | `高，有缓存` | `低，每次都编译` |
| 🔸 **使用场景** | `参数值` | `表名、列名` |
| 🔸 **建议** | `优先使用` | `谨慎使用` |

**💡 ${}的合理使用场景**
```xml
<!-- 场景1：动态表名（表名不能用?占位符） -->
<select id="findFromTable" resultType="Map">
    SELECT * FROM ${tableName}
</select>

<!-- 场景2：动态排序字段 -->
<select id="findWithOrder" resultType="User">
    SELECT * FROM users 
    ORDER BY ${orderColumn} ${orderType}
</select>

<!-- 场景3：动态列名 -->
<select id="findByColumn" resultType="User">
    SELECT * FROM users 
    WHERE ${columnName} = #{columnValue}
</select>
```

**🚨 安全提醒**
```
使用${}时必须注意：

危险示例（不要这样做）：
<select id="login" resultType="User">
    SELECT * FROM users 
    WHERE username = '${username}' AND password = '${password}'
</select>

攻击方式：
username传入：admin' OR '1'='1
最终SQL：SELECT * FROM users WHERE username = 'admin' OR '1'='1' AND password = '...'
结果：绕过密码验证！

安全做法：
参数值必须用 #{}
只在确定安全的地方用 ${}（如表名、列名）
```

---

## 5. 🗺️ 结果映射处理


### 5.1 resultType简单映射

**🎯 核心理解**：resultType用于简单的结果映射

**📝 自动映射原理**
```
MyBatis的自动映射机制：

1. 字段名和属性名完全一致
   数据库字段: username
   Java属性:   username
   → 自动映射 ✅

2. 字段名和属性名不一致  
   数据库字段: user_name
   Java属性:   username
   → 映射失败 ❌（可用驼峰转换解决）
```

**🔸 resultType使用示例**
```xml
<!-- 映射到实体类 -->
<select id="findById" resultType="com.example.entity.User">
    SELECT id, username, email FROM users WHERE id = #{id}
</select>

<!-- 映射到Map -->
<select id="findByIdToMap" resultType="map">
    SELECT * FROM users WHERE id = #{id}
</select>

<!-- 映射到基本类型 -->
<select id="count" resultType="int">
    SELECT COUNT(*) FROM users
</select>

<select id="findUsername" resultType="string">
    SELECT username FROM users WHERE id = #{id}
</select>
```

**💡 resultType适用场景**
```
推荐使用情况：
✅ 字段名与属性名一致
✅ 开启了驼峰命名转换
✅ 查询结果简单，不需要复杂映射
✅ 临时查询，返回Map就够用

不适用情况：
❌ 字段名与属性名差异很大
❌ 需要关联查询（一对多、多对一）
❌ 需要自定义映射逻辑
→ 这些情况用resultMap
```

### 5.2 resultMap高级映射

**🗺️ 核心理解**：resultMap用于复杂的结果映射配置

**📋 resultMap基础结构**
```xml
<!-- 定义结果映射 -->
<resultMap id="userResultMap" type="com.example.entity.User">
    <!-- 主键映射 -->
    <id property="id" column="user_id"/>
    
    <!-- 普通字段映射 -->
    <result property="username" column="user_name"/>
    <result property="email" column="user_email"/>
    <result property="age" column="user_age"/>
</resultMap>

<!-- 使用结果映射 -->
<select id="findById" resultMap="userResultMap">
    SELECT user_id, user_name, user_email, user_age 
    FROM users 
    WHERE user_id = #{id}
</select>
```

**🔸 配置说明（新手必看）**
```
resultMap的组成部分：

1. <resultMap>标签属性
   id="userResultMap"     → 映射配置的唯一标识
   type="...User"         → 映射到哪个Java类

2. <id>标签（主键映射）
   property="id"          → Java对象的属性名
   column="user_id"       → 数据库的字段名

3. <result>标签（普通字段映射）
   property="username"    → Java属性
   column="user_name"     → 数据库字段

为什么这样设计？
数据库字段常用下划线：user_name
Java属性常用驼峰：username
resultMap手动建立对应关系
```

### 5.3 复杂映射场景

**🔗 关联查询映射**

```xml
<!-- 场景：查询用户及其订单（一对多） -->
<resultMap id="userWithOrdersMap" type="User">
    <id property="id" column="user_id"/>
    <result property="username" column="username"/>
    
    <!-- collection：一对多关联 -->
    <collection property="orders" ofType="Order">
        <id property="id" column="order_id"/>
        <result property="orderNo" column="order_no"/>
        <result property="amount" column="amount"/>
    </collection>
</resultMap>

<select id="findUserWithOrders" resultMap="userWithOrdersMap">
    SELECT 
        u.id as user_id,
        u.username,
        o.id as order_id,
        o.order_no,
        o.amount
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    WHERE u.id = #{id}
</select>
```

**💡 关联映射理解**
```
一对多映射说明：

User对象结构：
- id
- username  
- orders (List<Order>)  ← 一个用户有多个订单

<collection>标签的作用：
property="orders"   → User类的orders属性
ofType="Order"      → 集合中的元素类型是Order

最终效果：
查询一个用户时，自动把该用户的所有订单也查出来
封装到User对象的orders列表中
```

---

## 6. 🔄 自动映射机制


### 6.1 自动映射原理

**🎯 核心理解**：MyBatis会自动匹配字段名和属性名

**📋 自动映射的规则**
```
MyBatis的映射逻辑：

1. 完全匹配
   数据库字段: username
   Java属性:   username
   → 自动映射成功 ✅

2. 忽略大小写匹配
   数据库字段: USERNAME
   Java属性:   username
   → 也能自动映射 ✅

3. 不匹配的情况
   数据库字段: user_name
   Java属性:   username
   → 映射失败，属性为null ❌
```

### 6.2 下划线转驼峰配置

**🐫 驼峰命名自动转换**

**开启驼峰转换配置**
```xml
<!-- mybatis-config.xml 中配置 -->
<configuration>
    <settings>
        <!-- 开启驼峰命名自动映射 -->
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
</configuration>
```

**🔸 转换规则说明**
```
开启后的映射规则：

数据库字段          →    Java属性
user_id            →    userId
user_name          →    userName  
create_time        →    createTime
is_deleted         →    isDeleted

转换逻辑：
1. 下划线后的字母变大写
2. 去掉下划线
3. 其他字母保持小写
```

**💡 实际应用示例**
```xml
<!-- 开启驼峰转换前：需要手动映射 -->
<resultMap id="userMap" type="User">
    <id property="id" column="user_id"/>
    <result property="userName" column="user_name"/>
    <result property="createTime" column="create_time"/>
</resultMap>

<!-- 开启驼峰转换后：直接用resultType -->
<select id="findById" resultType="User">
    SELECT user_id, user_name, create_time 
    FROM users 
    WHERE user_id = #{id}
</select>

<!-- MyBatis自动完成映射：
   user_id      → userId
   user_name    → userName
   create_time  → createTime
-->
```

**📊 驼峰转换的适用场景**

| 场景 | **是否开启** | **说明** |
|-----|------------|---------|
| 🔸 **规范的数据库设计** | `推荐开启` | `数据库字段用下划线命名` |
| 🔸 **Java代码规范** | `推荐开启` | `Java属性用驼峰命名` |
| 🔸 **字段名完全一致** | `可不开启` | `已经完全匹配了` |
| 🔸 **特殊映射需求** | `配合resultMap` | `复杂映射仍需手动配置` |

**🚀 最佳实践建议**
```
推荐的配置组合：

1. 开启驼峰转换
   适用于90%的常规场景
   减少手动映射配置

2. 简单查询用resultType
   字段名规范的情况
   依赖自动映射

3. 复杂查询用resultMap
   关联查询
   字段名特殊的情况
   需要自定义映射逻辑
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 命名空间：XML配置文件与Mapper接口的绑定关系
🔸 SQL语句：select/insert/update/delete四种基本操作
🔸 参数传递：#{}预编译占位，${}字符串替换
🔸 结果映射：resultType简单映射，resultMap复杂映射
🔸 自动映射：驼峰转换解决命名差异问题
```

### 7.2 关键理解要点


**🔹 namespace的本质作用**
```
为什么需要命名空间？

1. 绑定关系
   让MyBatis知道XML配置对应哪个接口
   namespace必须是接口的完整类名

2. 唯一标识  
   通过"命名空间.方法id"定位SQL语句
   避免不同Mapper的SQL冲突

3. 调用方式
   接口方法 → MyBatis → 找到namespace → 找到对应SQL
```

**🔹 #{}和${}的核心区别**
```
选择建议：

优先使用 #{}：
✅ 安全性高，防止SQL注入
✅ 性能好，支持预编译
✅ 用于所有参数值

谨慎使用 ${}：
⚠️ 只用于表名、列名等SQL关键字
⚠️ 确保值来源可信
⚠️ 不要用于用户输入的参数

记忆口诀：
参数用井号，关键词用美元
安全第一位，注入要防住
```

**🔹 resultType vs resultMap选择**
```
使用场景对比：

resultType适合：
✅ 字段名和属性名一致
✅ 开启了驼峰转换
✅ 简单的单表查询
✅ 返回Map或基本类型

resultMap适合：
✅ 字段名和属性名差异大
✅ 需要关联查询（一对多、多对一）
✅ 需要类型转换处理
✅ 复杂的结果映射逻辑

实际开发策略：
能用resultType就用resultType（简单）
必要时才用resultMap（灵活）
```

### 7.3 实际开发建议


**🎯 新手避坑指南**
```
常见错误及解决：

1. 命名空间路径写错
   ❌ namespace="UserMapper"
   ✅ namespace="com.example.mapper.UserMapper"

2. 方法名和id不一致
   ❌ <select id="findUser">  → 接口方法叫findById
   ✅ <select id="findById">  → 必须完全一致

3. 参数占位符用错
   ❌ WHERE id = ${id}  → 用户输入的参数
   ✅ WHERE id = #{id}  → 安全的占位符

4. resultType写成List
   ❌ resultType="List<User>"
   ✅ resultType="User"  → 即使返回List也写单个

5. 忘记开启驼峰转换
   数据库: user_name
   Java:   userName
   → 开启mapUnderscoreToCamelCase
```

**🚀 开发最佳实践**
```
配置优化建议：

1. 统一命名规范
   接口: UserMapper
   配置: UserMapper.xml  
   放在同名目录下

2. 善用驼峰转换
   全局配置一次
   减少手动映射工作

3. 合理使用别名
   mybatis-config.xml配置类型别名
   resultType直接写"User"而不是全路径

4. SQL语句可读性
   复杂SQL分行书写
   添加适当注释
   关键字大写

5. 参数命名规范
   多个参数必须用@Param
   参数名要有意义
   避免用arg0, arg1这种
```

**🔍 调试技巧**
```
遇到问题时的检查步骤：

1. 检查namespace是否正确
   → 与接口全路径完全一致

2. 检查方法id是否匹配
   → 与接口方法名完全相同

3. 检查参数传递
   → 多参数是否加@Param
   → 参数名是否对应

4. 检查结果映射
   → resultType是否正确
   → 字段名是否能自动映射

5. 开启SQL日志
   → 查看实际执行的SQL
   → 确认参数是否正确传入
```

**核心记忆口诀**：
- 命名空间要对齐，接口路径不能离
- 增删改查四兄弟，井号美元分清楚
- 简单映射用Type，复杂映射用Map
- 驼峰转换真方便，下划线字段不用管