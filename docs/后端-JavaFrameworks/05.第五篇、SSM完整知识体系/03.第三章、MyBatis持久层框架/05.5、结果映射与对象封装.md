---
title: 5、结果映射与对象封装
---
## 📚 目录

1. [结果映射概述](#1-结果映射概述)
2. [基本类型映射](#2-基本类型映射)
3. [对象类型映射](#3-对象类型映射)
4. [集合类型映射](#4-集合类型映射)
5. [Map结果映射](#5-Map结果映射)
6. [resultMap高级映射](#6-resultMap高级映射)
7. [关联映射详解](#7-关联映射详解)
8. [性能优化配置](#8-性能优化配置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 结果映射概述


### 1.1 什么是结果映射


**通俗理解**：
```
想象一下：
数据库查询就像从仓库提货
结果映射就是把货物装进合适的箱子里

数据库返回：id=1, name="张三", age=25
Java需要：User对象，有id、name、age属性

结果映射的作用：把数据库的列 → 对应到Java对象的属性
```

**核心定义**：
- **作用**：将数据库查询结果自动转换为Java对象
- **目标**：解决数据库字段名与Java属性名的映射关系
- **优势**：自动封装，减少手动赋值的繁琐操作

### 1.2 为什么需要结果映射


**实际场景对比**：

```
❌ 没有结果映射（传统JDBC）：
ResultSet rs = stmt.executeQuery("SELECT * FROM user");
while(rs.next()) {
    User user = new User();
    user.setId(rs.getInt("id"));        // 手动取值
    user.setName(rs.getString("name"));  // 手动赋值
    user.setAge(rs.getInt("age"));       // 重复劳动
}

✅ 有了结果映射（MyBatis）：
List<User> users = userMapper.selectAll();  // 自动封装完成
```

**核心价值**：
- 🚀 **提高效率**：自动封装，减少重复代码
- 🛡️ **减少错误**：避免手动赋值时的拼写错误
- 🔧 **灵活配置**：支持复杂的对象关系映射

### 1.3 映射的三种方式


```
🔸 方式一：自动映射（最简单）
数据库字段名 = Java属性名 → 自动对应

🔸 方式二：别名映射（常用）
SQL中用 AS 给列起别名 → 匹配属性名

🔸 方式三：resultMap（最强大）
手动定义完整的映射规则 → 处理复杂场景
```

---

## 2. 📦 基本类型映射


### 2.1 单个基本类型返回


**应用场景**：查询统计数量、求和、单个字段值

**实现方式**：

```xml
<!-- 返回整数：统计用户数量 -->
<select id="countUsers" resultType="int">
    SELECT COUNT(*) FROM user
</select>

<!-- 返回字符串：查询用户名 -->
<select id="getUserName" resultType="string">
    SELECT name FROM user WHERE id = #{id}
</select>

<!-- 返回Long：查询ID -->
<select id="getMaxId" resultType="long">
    SELECT MAX(id) FROM user
</select>
```

**使用方法**：

```java
// Mapper接口定义
public interface UserMapper {
    int countUsers();           // 返回int
    String getUserName(Long id); // 返回String
    Long getMaxId();            // 返回Long
}

// 使用示例
int total = userMapper.countUsers();
String name = userMapper.getUserName(1L);
```

**🔑 关键点**：
- `resultType` 指定返回类型：`int`、`string`、`long` 等
- MyBatis会自动把查询结果转换为对应的基本类型
- 查询必须只返回一个值（一行一列）

### 2.2 基本类型数组


**实际需求**：查询所有用户的年龄列表

```xml
<!-- 返回整数列表 -->
<select id="getAllAges" resultType="int">
    SELECT age FROM user
</select>
```

```java
// 返回List<Integer>
List<Integer> ages = userMapper.getAllAges();
// 结果：[25, 30, 28, 35, ...]
```

**理解要点**：
- 虽然 `resultType="int"`，但接口返回 `List<Integer>`
- MyBatis会自动把多行结果封装成集合
- 每行的 age 字段值都会被转换为 Integer 对象

---

## 3. 👤 对象类型映射


### 3.1 简单对象映射（自动映射）


**前提条件**：数据库字段名与Java属性名一致

**实体类定义**：

```java
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
    
    // getter和setter省略
}
```

**Mapper配置**：

```xml
<!-- 自动映射：字段名与属性名一致 -->
<select id="selectById" resultType="com.example.entity.User">
    SELECT id, name, age, email 
    FROM user 
    WHERE id = #{id}
</select>
```

**工作原理**：
```
数据库列名    →    Java属性名
─────────────────────────────
id           →    id       ✅ 自动匹配
name         →    name     ✅ 自动匹配
age          →    age      ✅ 自动匹配
email        →    email    ✅ 自动匹配
```

### 3.2 驼峰命名映射


**实际问题**：数据库用下划线，Java用驼峰

```
数据库字段：user_name, create_time
Java属性：  userName, createTime
```

**解决方案一：开启驼峰映射**

```xml
<!-- mybatis-config.xml 全局配置 -->
<settings>
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

**自动转换规则**：
```
user_name   → userName   ✅ 自动转换
create_time → createTime ✅ 自动转换
user_id     → userId     ✅ 自动转换
```

**解决方案二：SQL别名**

```xml
<select id="selectUser" resultType="User">
    SELECT 
        id,
        user_name AS userName,
        create_time AS createTime
    FROM user
</select>
```

### 3.3 对象列表映射


**场景**：查询所有用户，返回用户列表

```xml
<select id="selectAll" resultType="User">
    SELECT * FROM user
</select>
```

```java
// Mapper接口
List<User> selectAll();

// 使用
List<User> users = userMapper.selectAll();
// 自动封装多个User对象
```

**理解过程**：
```
数据库返回多行：
Row1: id=1, name="张三", age=25
Row2: id=2, name="李四", age=30
Row3: id=3, name="王五", age=28
         ↓
MyBatis自动封装
         ↓
List<User>包含3个User对象
```

---

## 4. 📋 集合类型映射


### 4.1 List集合映射


**应用场景**：查询一对多关系，如一个部门的所有员工

**实体类设计**：

```java
public class Department {
    private Long id;
    private String deptName;
    private List<Employee> employees;  // 员工列表
}

public class Employee {
    private Long id;
    private String name;
    private Long deptId;
}
```

**resultMap配置**：

```xml
<resultMap id="DeptWithEmployees" type="Department">
    <id property="id" column="dept_id"/>
    <result property="deptName" column="dept_name"/>
    
    <!-- collection：映射List集合 -->
    <collection property="employees" ofType="Employee">
        <id property="id" column="emp_id"/>
        <result property="name" column="emp_name"/>
        <result property="deptId" column="dept_id"/>
    </collection>
</resultMap>

<select id="getDeptWithEmployees" resultMap="DeptWithEmployees">
    SELECT 
        d.id AS dept_id,
        d.dept_name,
        e.id AS emp_id,
        e.name AS emp_name,
        e.dept_id
    FROM department d
    LEFT JOIN employee e ON d.id = e.dept_id
    WHERE d.id = #{id}
</select>
```

**🔑 关键理解**：
- `collection`：表示集合属性
- `property="employees"`：对应Java中的List属性名
- `ofType="Employee"`：集合中元素的类型
- MyBatis会自动把多行结果组装成List

### 4.2 Set集合映射


**场景**：需要去重的集合，如用户的角色列表

```xml
<resultMap id="UserWithRoles" type="User">
    <id property="id" column="user_id"/>
    <result property="name" column="user_name"/>
    
    <!-- Set集合映射 -->
    <collection property="roles" ofType="Role" javaType="java.util.HashSet">
        <id property="id" column="role_id"/>
        <result property="roleName" column="role_name"/>
    </collection>
</resultMap>
```

**区别点**：
- 添加 `javaType="java.util.HashSet"` 指定Set类型
- Set会自动去重（根据equals和hashCode）

---

## 5. 🗺️ Map结果映射


### 5.1 单个Map返回


**应用场景**：动态查询，不想创建实体类

```xml
<!-- resultType直接指定为map -->
<select id="selectUserMap" resultType="map">
    SELECT id, name, age FROM user WHERE id = #{id}
</select>
```

```java
Map<String, Object> userMap = userMapper.selectUserMap(1L);
// 结果：{id=1, name="张三", age=25}

// 使用
String name = (String) userMap.get("name");
Integer age = (Integer) userMap.get("age");
```

**特点**：
- 列名作为Map的key
- 列值作为Map的value
- 灵活但需要类型转换

### 5.2 Map列表返回


**场景**：返回多行动态结果

```xml
<select id="selectAllMaps" resultType="map">
    SELECT id, name, age FROM user
</select>
```

```java
List<Map<String, Object>> users = userMapper.selectAllMaps();
// 结果：[{id=1, name="张三"}, {id=2, name="李四"}, ...]
```

### 5.3 @MapKey注解


**高级用法**：把List<Map>转为Map<Key, Map>

```java
// 以id作为外层Map的key
@MapKey("id")
Map<Long, Map<String, Object>> selectUserMapById();
```

```xml
<select id="selectUserMapById" resultType="map">
    SELECT id, name, age FROM user
</select>
```

**结果结构**：
```java
{
    1: {id=1, name="张三", age=25},
    2: {id=2, name="李四", age=30},
    3: {id=3, name="王五", age=28}
}
```

---

## 6. 🔧 resultMap高级映射


### 6.1 为什么需要resultMap


**自动映射的局限**：
- ❌ 字段名与属性名不一致时无法映射
- ❌ 复杂对象关系（一对一、一对多）无法处理
- ❌ 需要特殊处理的字段（主键、外键）无法标识

**resultMap的优势**：
- ✅ 完全掌控映射规则
- ✅ 支持复杂对象关系
- ✅ 可以优化查询性能

### 6.2 id主键映射


**作用**：明确标识主键字段，提升性能

```xml
<resultMap id="UserMap" type="User">
    <!-- id标签：映射主键 -->
    <id property="id" column="user_id"/>
    
    <!-- result标签：映射普通字段 -->
    <result property="name" column="user_name"/>
    <result property="age" column="age"/>
</resultMap>
```

**🔑 id vs result 的区别**：

| 对比项 | `<id>` | `<result>` |
|--------|--------|------------|
| 🎯 **用途** | 映射主键 | 映射普通字段 |
| ⚡ **性能** | 用于对象去重，提升性能 | 普通映射 |
| 🔍 **识别** | MyBatis会特殊对待 | 普通处理 |
| 📝 **推荐** | 主键必须用id | 其他字段用result |

**性能影响**：
```
场景：一对多查询，返回重复的主表数据
用id标识主键 → MyBatis识别重复对象 → 只创建一次
不用id标识 → 每行都创建新对象 → 浪费内存
```

### 6.3 result普通字段映射


**基本语法**：

```xml
<resultMap id="UserResultMap" type="User">
    <id property="id" column="user_id"/>
    
    <!-- property：Java属性名 -->
    <!-- column：数据库列名 -->
    <result property="userName" column="user_name"/>
    <result property="email" column="email"/>
    <result property="createTime" column="create_time"/>
</resultMap>
```

**使用场景**：
```
数据库设计：user_name, create_time (下划线命名)
Java设计：  userName, createTime (驼峰命名)
          ↓
需要result明确映射关系
```

---

## 7. 🔗 关联映射详解


### 7.1 association一对一关联


**业务场景**：用户与身份证是一对一关系

**实体类设计**：

```java
public class User {
    private Long id;
    private String name;
    private IdCard idCard;  // 一对一关联
}

public class IdCard {
    private Long id;
    private String cardNo;
    private Long userId;
}
```

**方式一：嵌套结果映射**

```xml
<resultMap id="UserWithIdCard" type="User">
    <id property="id" column="user_id"/>
    <result property="name" column="user_name"/>
    
    <!-- association：一对一关联 -->
    <association property="idCard" javaType="IdCard">
        <id property="id" column="card_id"/>
        <result property="cardNo" column="card_no"/>
        <result property="userId" column="user_id"/>
    </association>
</resultMap>

<select id="getUserWithIdCard" resultMap="UserWithIdCard">
    SELECT 
        u.id AS user_id,
        u.name AS user_name,
        c.id AS card_id,
        c.card_no,
        c.user_id
    FROM user u
    LEFT JOIN id_card c ON u.id = c.user_id
    WHERE u.id = #{id}
</select>
```

**执行流程**：
```
1. 执行SQL查询（一次查询）
2. 返回结果：user_id=1, user_name="张三", card_id=101, card_no="123456"
3. MyBatis封装：
   User对象 {
       id = 1
       name = "张三"
       idCard = IdCard {
           id = 101
           cardNo = "123456"
       }
   }
```

**方式二：嵌套查询（分步查询）**

```xml
<resultMap id="UserWithIdCard2" type="User">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    
    <!-- select：指定另一个查询 -->
    <!-- column：传递给下一个查询的参数 -->
    <association property="idCard" 
                 select="getIdCardByUserId" 
                 column="id"/>
</resultMap>

<select id="getUser" resultMap="UserWithIdCard2">
    SELECT id, name FROM user WHERE id = #{id}
</select>

<select id="getIdCardByUserId" resultType="IdCard">
    SELECT * FROM id_card WHERE user_id = #{userId}
</select>
```

**执行流程**：
```
1. 先查user表：SELECT id, name FROM user WHERE id = 1
2. 再查id_card表：SELECT * FROM id_card WHERE user_id = 1
3. 组装成完整的User对象
```

**两种方式对比**：

| 对比项 | 嵌套结果 | 嵌套查询 |
|--------|----------|----------|
| 🔍 **SQL次数** | 1次 | 2次（N+1问题） |
| ⚡ **性能** | 高（推荐） | 较低 |
| 🎯 **适用场景** | 数据量大 | 需要懒加载 |
| 📝 **复杂度** | SQL复杂 | 配置简单 |

### 7.2 collection一对多关联


**业务场景**：部门与员工是一对多关系

**实体类**：

```java
public class Department {
    private Long id;
    private String deptName;
    private List<Employee> employees;  // 一对多
}
```

**配置方式**：

```xml
<resultMap id="DeptWithEmps" type="Department">
    <id property="id" column="dept_id"/>
    <result property="deptName" column="dept_name"/>
    
    <!-- collection：一对多集合 -->
    <!-- ofType：集合中元素的类型 -->
    <collection property="employees" ofType="Employee">
        <id property="id" column="emp_id"/>
        <result property="name" column="emp_name"/>
        <result property="salary" column="salary"/>
    </collection>
</resultMap>

<select id="getDeptWithEmps" resultMap="DeptWithEmps">
    SELECT 
        d.id AS dept_id,
        d.dept_name,
        e.id AS emp_id,
        e.name AS emp_name,
        e.salary
    FROM department d
    LEFT JOIN employee e ON d.id = e.dept_id
    WHERE d.id = #{id}
</select>
```

**数据封装过程**：
```
SQL返回多行：
dept_id | dept_name | emp_id | emp_name | salary
1       | 研发部    | 101    | 张三     | 8000
1       | 研发部    | 102    | 李四     | 9000
1       | 研发部    | 103    | 王五     | 8500
              ↓
MyBatis识别dept_id=1是同一个部门（通过<id>标签）
              ↓
创建一个Department对象，包含3个Employee对象
```

### 7.3 discriminator鉴别器


**应用场景**：根据某个字段值决定不同的映射规则

**实际案例**：用户类型不同，关联的信息不同

```java
public class User {
    private Long id;
    private String name;
    private Integer userType;  // 1=普通用户, 2=VIP用户
    private Object extraInfo;  // 不同类型有不同的扩展信息
}
```

**配置示例**：

```xml
<resultMap id="UserWithType" type="User">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="userType" column="user_type"/>
    
    <!-- discriminator：鉴别器 -->
    <discriminator javaType="int" column="user_type">
        <!-- userType=1时的映射 -->
        <case value="1">
            <association property="extraInfo" javaType="NormalUser">
                <result property="level" column="level"/>
            </association>
        </case>
        
        <!-- userType=2时的映射 -->
        <case value="2">
            <association property="extraInfo" javaType="VipUser">
                <result property="vipLevel" column="vip_level"/>
                <result property="discount" column="discount"/>
            </association>
        </case>
    </discriminator>
</resultMap>
```

**工作原理**：
```
查询结果：id=1, name="张三", user_type=1, level=3
              ↓
discriminator检查user_type的值
              ↓
值为1 → 使用case value="1"的映射规则
              ↓
extraInfo封装为NormalUser对象
```

---

## 8. ⚙️ 性能优化配置


### 8.1 自动映射配置


**全局配置**：

```xml
<settings>
    <!-- 自动映射级别 -->
    <setting name="autoMappingBehavior" value="PARTIAL"/>
    
    <!-- 驼峰命名自动映射 -->
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

**autoMappingBehavior可选值**：

| 级别 | 说明 | 适用场景 |
|------|------|----------|
| `NONE` | 关闭自动映射 | 完全手动控制 |
| `PARTIAL` | 部分自动映射（默认） | 推荐使用 |
| `FULL` | 全部自动映射 | 可能有问题 |

**PARTIAL vs FULL 的区别**：
```
PARTIAL：只映射简单字段，嵌套对象需要手动配置
FULL：   包括嵌套对象也自动映射（可能导致意外）

推荐PARTIAL，避免自动映射带来的不可控问题
```

### 8.2 懒加载配置


**什么是懒加载**：
```
普通查询：一次性加载所有关联数据
懒加载：  用到关联数据时才去查询

例如：查询部门信息
- 不开启懒加载：同时查出所有员工信息
- 开启懒加载：  只有访问employees属性时才查询员工
```

**全局配置**：

```xml
<settings>
    <!-- 开启懒加载 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    
    <!-- 关闭立即加载（配合懒加载使用） -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

**具体使用**：

```xml
<resultMap id="DeptLazy" type="Department">
    <id property="id" column="id"/>
    <result property="deptName" column="dept_name"/>
    
    <!-- fetchType="lazy"：指定为懒加载 -->
    <collection property="employees" 
                select="getEmployeesByDeptId"
                column="id"
                fetchType="lazy"/>
</resultMap>
```

**懒加载效果**：

```java
Department dept = deptMapper.getDept(1);
System.out.println(dept.getDeptName());  // 只查部门表

// 访问employees时才触发第二次查询
List<Employee> emps = dept.getEmployees();  // 此时查询员工表
```

**fetchType可选值**：

| 值 | 说明 | 使用场景 |
|----|------|----------|
| `lazy` | 懒加载 | 关联数据不常用 |
| `eager` | 立即加载 | 关联数据必需 |
| 不设置 | 使用全局配置 | 默认方式 |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 结果映射本质：将数据库列映射到Java对象属性
🔸 映射层次：基本类型 → 对象 → 集合 → 复杂关系
🔸 核心标签：<resultMap>、<id>、<result>
🔸 关联映射：<association>（一对一）、<collection>（一对多）
🔸 性能优化：自动映射、懒加载
```

### 9.2 技术选型建议


**🔹 简单场景**：
```
✅ 使用自动映射（resultType）
✅ 开启驼峰映射
✅ 少量SQL别名处理差异
```

**🔹 复杂场景**：
```
✅ 使用resultMap手动映射
✅ 明确标识主键（<id>）
✅ 嵌套结果优于嵌套查询（性能）
```

**🔹 性能优先**：
```
✅ 优先使用嵌套结果（一次SQL）
✅ 合理使用懒加载
✅ 避免N+1查询问题
```

### 9.3 常见问题与解决


**❓ 问题1：查询结果为null**
```
原因：字段名与属性名不匹配
解决：
1. 开启驼峰映射
2. 使用SQL别名
3. 配置resultMap
```

**❓ 问题2：一对多查询数据重复**
```
原因：没有正确标识主键
解决：在resultMap中用<id>标签标识主键
```

**❓ 问题3：关联查询性能差**
```
原因：使用嵌套查询导致N+1问题
解决：改用嵌套结果（JOIN查询）
```

**❓ 问题4：懒加载不生效**
```
原因：
1. 未开启全局懒加载配置
2. aggressiveLazyLoading=true
3. 序列化导致提前加载

解决：检查配置，避免过早序列化
```

### 9.4 最佳实践建议


```
💡 实践1：优先使用自动映射
- 遵循命名约定（驼峰或下划线）
- 减少手动配置工作量

💡 实践2：主键必须用<id>标签
- 提升对象去重性能
- 避免一对多查询时对象重复创建

💡 实践3：合理选择关联方式
- 数据量大 → 嵌套结果（JOIN）
- 需懒加载 → 嵌套查询（分步）

💡 实践4：懒加载谨慎使用
- 明确业务需求再开启
- 避免序列化问题
- 考虑N+1问题

💡 实践5：复杂映射拆分resultMap
- 定义可复用的基础resultMap
- 通过extends继承扩展
```

### 9.5 学习检查清单


✅ **基础级别**：
- [ ] 能说出resultType和resultMap的区别
- [ ] 理解自动映射的原理和条件
- [ ] 掌握基本类型和对象映射

✅ **应用级别**：
- [ ] 能配置一对一、一对多关联
- [ ] 理解嵌套结果和嵌套查询的区别
- [ ] 掌握懒加载的配置和使用

✅ **进阶级别**：
- [ ] 能优化复杂查询的映射配置
- [ ] 理解并避免N+1查询问题
- [ ] 能根据场景选择最佳映射方案

🧠 **核心记忆口诀**：
```
结果映射三层次：基本对象和集合
自动手动两方式：简单复杂分场景
关联映射分一多：association和collection
性能优化两关键：嵌套结果配懒加载
```