---
title: 7、MyBatis核心
---
## 📚 目录

1. [MyBatis核心概念](#1-mybatis核心概念)
2. [SQL映射与动态SQL](#2-sql映射与动态sql)
3. [结果映射与关联查询](#3-结果映射与关联查询)
4. [缓存机制与性能优化](#4-缓存机制与性能优化)
5. [插件扩展机制](#5-插件扩展机制)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 MyBatis核心概念


### 1.1 什么是MyBatis


**通俗理解**：MyBatis就像是Java和数据库之间的"翻译官"。

想象一下：
- 你（Java程序）说中文
- 数据库说英文（SQL语言）
- MyBatis就是帮你们翻译交流的工具

```
传统JDBC方式：
你需要自己写SQL → 自己执行 → 自己处理结果 → 非常繁琐

MyBatis方式：
你只需要写SQL和映射规则 → MyBatis帮你执行和转换 → 简单高效
```

**核心定位**：
- 🔸 **半自动ORM框架**：需要你手写SQL，但自动处理结果映射
- 🔸 **持久层框架**：专门负责和数据库打交道
- 🔸 **SQL映射框架**：把Java对象和SQL语句关联起来

### 1.2 MyBatis的工作流程


**整体流程图**：
```
                MyBatis工作流程
                
程序员写代码              MyBatis自动处理              数据库
    │                          │                        │
    ├─[1]调用Mapper接口         │                        │
    │    getUserById(1)        │                        │
    │                          │                        │
    │                         [2]找到SQL映射文件          │
    │                          └─UserMapper.xml         │
    │                          │                        │
    │                         [3]读取SQL语句             │
    │                          └─SELECT * FROM user...  │
    │                          │                        │
    │                         [4]执行SQL─────────────→  数据库
    │                          │                        │
    │                         [5]获取结果←───────────── 返回数据
    │                          │                        │
    │                         [6]自动封装对象            │
    │                          └─转成User对象            │
    │                          │                        │
    │←─────[7]返回User对象───────┘                        │
```

**关键步骤说明**：
- **步骤1-2**：你调用方法，MyBatis找到对应的SQL配置
- **步骤3-4**：读取SQL并执行
- **步骤5-6**：自动把查询结果转成Java对象
- **步骤7**：你拿到封装好的对象，直接用

### 1.3 核心组件认识


**MyBatis的核心角色**：

| 组件 | 通俗比喻 | 实际作用 | 重要度 |
|------|---------|---------|--------|
| **SqlSessionFactory** | 工厂老板 | 负责创建SqlSession | ⭐⭐⭐⭐⭐ |
| **SqlSession** | 工人 | 执行具体的数据库操作 | ⭐⭐⭐⭐⭐ |
| **Mapper接口** | 操作手册 | 定义数据库操作方法 | ⭐⭐⭐⭐⭐ |
| **XML映射文件** | 说明书 | 写具体的SQL语句 | ⭐⭐⭐⭐⭐ |

**组件关系图**：
```
SqlSessionFactory (工厂)
        │
        │ 创建
        ↓
   SqlSession (会话)
        │
        │ 获取
        ↓
   Mapper接口 (操作接口)
        │
        │ 对应
        ↓
   XML映射文件 (SQL配置)
```

---

## 2. 📝 SQL映射与动态SQL


### 2.1 什么是SQL映射


**通俗理解**：SQL映射就是把"Java方法"和"SQL语句"关联起来。

举个生活例子：
```
你去饭店点菜：
- 你说："来份宫保鸡丁"（Java方法）
- 厨师知道怎么做这道菜（SQL语句）
- 中间的菜单就是"映射"（XML配置）
```

**映射配置示例**：
```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    
    <!-- 根据ID查询用户 -->
    <select id="getUserById" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>
    
</mapper>
```

**对应的Java接口**：
```java
public interface UserMapper {
    User getUserById(Integer id);  // 方法名对应XML中的id
}
```

**映射关系**：
- `namespace` → 对应接口的完整路径
- `id` → 对应接口中的方法名
- `resultType` → 返回值类型
- `#{id}` → 方法参数

### 2.2 动态SQL是什么


**问题场景**：
假设你要写一个搜索功能，用户可以：
- 只输入名字搜索
- 只输入年龄搜索  
- 名字和年龄都输入
- 什么都不输入

传统方式你需要写4条不同的SQL，很麻烦！

**动态SQL的作用**：根据不同条件，自动拼接不同的SQL语句。

**核心动态标签**：

| 标签 | 通俗理解 | 使用场景 |
|------|---------|---------|
| `<if>` | 如果...就... | 条件判断 |
| `<choose>` | 多选一 | 类似switch |
| `<where>` | 智能WHERE | 自动处理AND/OR |
| `<foreach>` | 循环 | 批量操作 |

### 2.3 动态SQL实战


**场景1：条件查询（if标签）**

> 💡 **场景说明**：用户搜索时可能只填部分条件

```xml
<select id="searchUser" resultType="User">
    SELECT * FROM user
    <where>
        <!-- 如果传了name参数，就加这个条件 -->
        <if test="name != null and name != ''">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        
        <!-- 如果传了age参数，就加这个条件 -->
        <if test="age != null">
            AND age = #{age}
        </if>
    </where>
</select>
```

**执行效果**：
```
情况1：只传name="张三"
生成SQL：SELECT * FROM user WHERE name LIKE '%张三%'

情况2：只传age=20  
生成SQL：SELECT * FROM user WHERE age = 20

情况3：都传name="张三", age=20
生成SQL：SELECT * FROM user WHERE name LIKE '%张三%' AND age = 20

情况4：都不传
生成SQL：SELECT * FROM user
```

> ⚠️ **注意**：`<where>`标签会自动去掉多余的AND/OR，非常智能！

**场景2：多选一（choose标签）**

> 💡 **场景说明**：按优先级选择查询条件

```xml
<select id="getUserByCondition" resultType="User">
    SELECT * FROM user
    <where>
        <choose>
            <!-- 如果有ID，优先用ID查 -->
            <when test="id != null">
                id = #{id}
            </when>
            <!-- 其次用用户名查 -->
            <when test="username != null">
                username = #{username}
            </when>
            <!-- 都没有就查所有 -->
            <otherwise>
                1 = 1
            </otherwise>
        </choose>
    </where>
</select>
```

**场景3：批量操作（foreach标签）**

> 💡 **场景说明**：一次性查询多个ID

```xml
<select id="getUserByIds" resultType="User">
    SELECT * FROM user WHERE id IN
    <foreach collection="ids" item="id" open="(" close=")" separator=",">
        #{id}
    </foreach>
</select>
```

**参数说明**：
- `collection="ids"` → 传入的集合参数名
- `item="id"` → 循环中每个元素的变量名
- `open="("` → 开始符号
- `close=")"` → 结束符号
- `separator=","` → 元素之间的分隔符

**执行效果**：
```java
List<Integer> ids = Arrays.asList(1, 2, 3);
// 生成SQL：SELECT * FROM user WHERE id IN (1, 2, 3)
```

---

## 3. 🔗 结果映射与关联查询


### 3.1 什么是结果映射


**通俗理解**：结果映射就是告诉MyBatis"数据库的列"对应"Java对象的哪个属性"。

**简单情况**：列名和属性名一致
```
数据库列：id, name, age
Java属性：id, name, age
→ 自动映射，不需要配置
```

**复杂情况**：列名和属性名不一致
```
数据库列：user_name, create_time
Java属性：userName, createTime
→ 需要手动配置映射关系
```

### 3.2 ResultMap详解


**基础映射配置**：

```xml
<resultMap id="userResultMap" type="User">
    <!-- 主键映射 -->
    <id column="id" property="id"/>
    
    <!-- 普通字段映射 -->
    <result column="user_name" property="userName"/>
    <result column="create_time" property="createTime"/>
</resultMap>

<select id="getUser" resultMap="userResultMap">
    SELECT id, user_name, create_time FROM user
</select>
```

**映射要素**：
- `id` → 主键映射（性能更好）
- `result` → 普通字段映射
- `column` → 数据库列名
- `property` → Java属性名

### 3.3 关联查询详解


**什么是关联查询**：
一个对象里包含另一个对象的信息，需要关联多张表查询。

**生活例子**：
```
查询用户信息，同时要知道用户的部门信息

用户表：id, name, dept_id
部门表：dept_id, dept_name

用户对象需要包含部门对象：
User {
    id, 
    name,
    Department dept  // 包含部门对象
}
```

**关联关系类型**：

| 关系类型 | 说明 | 举例 |
|---------|------|------|
| **一对一** | 一个对应一个 | 用户-身份证 |
| **一对多** | 一个对应多个 | 部门-员工 |
| **多对多** | 多个对应多个 | 学生-课程 |

### 3.4 一对一关联（association）


**场景**：查询用户及其身份证信息

```xml
<resultMap id="userCardMap" type="User">
    <id column="id" property="id"/>
    <result column="name" property="name"/>
    
    <!-- 一对一关联：用户的身份证 -->
    <association property="idCard" javaType="IdCard">
        <id column="card_id" property="cardId"/>
        <result column="card_number" property="cardNumber"/>
    </association>
</resultMap>

<select id="getUserWithCard" resultMap="userCardMap">
    SELECT 
        u.id, u.name,
        c.card_id, c.card_number
    FROM user u
    LEFT JOIN id_card c ON u.id = c.user_id
</select>
```

**关键点理解**：
- `association` → 表示"包含一个"对象
- `property="idCard"` → User类中的属性名
- `javaType="IdCard"` → 属性的类型

### 3.5 一对多关联（collection）


**场景**：查询部门及其所有员工

```xml
<resultMap id="deptEmpMap" type="Department">
    <id column="dept_id" property="deptId"/>
    <result column="dept_name" property="deptName"/>
    
    <!-- 一对多关联：部门的多个员工 -->
    <collection property="employees" ofType="Employee">
        <id column="emp_id" property="empId"/>
        <result column="emp_name" property="empName"/>
    </collection>
</resultMap>

<select id="getDeptWithEmps" resultMap="deptEmpMap">
    SELECT 
        d.dept_id, d.dept_name,
        e.emp_id, e.emp_name
    FROM department d
    LEFT JOIN employee e ON d.dept_id = e.dept_id
</select>
```

**关键点理解**：
- `collection` → 表示"包含多个"对象（集合）
- `ofType="Employee"` → 集合中元素的类型

**关联查询策略对比**：

| 策略 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **嵌套查询** | 分多次SQL查询 | 灵活、易维护 | 可能N+1问题 |
| **嵌套结果** | 一次SQL联表 | 性能好 | SQL复杂 |

---

## 4. ⚡ 缓存机制与性能优化


### 4.1 为什么需要缓存


**通俗理解**：缓存就像"记忆力"。

**生活例子**：
```
没缓存：每次都问数据库 = 每次都查字典
有缓存：记住查过的内容 = 记在脑子里，下次直接用
```

**性能对比**：
```
不用缓存：
查询1次 → 访问数据库1次（慢）
查询100次相同数据 → 访问数据库100次（超慢！）

使用缓存：
查询1次 → 访问数据库1次 → 存入缓存
查询100次相同数据 → 从缓存读99次（快！）
```

### 4.2 MyBatis的两级缓存


**缓存层级结构**：
```
                   缓存体系
                      
一级缓存(默认开启)          二级缓存(需要配置)
     │                         │
 SqlSession级别            Mapper级别
     │                         │
 会话内有效                全局有效
     │                         │
 自动管理                  手动配置
```

### 4.3 一级缓存详解


**作用范围**：SqlSession内部有效

**工作原理**：
```
第一次查询：
SqlSession.getUser(1) 
  → 查数据库 
  → 结果存入缓存
  → 返回结果

第二次查询（同一个SqlSession）：
SqlSession.getUser(1)
  → 直接从缓存取
  → 不查数据库
  → 返回结果
```

**失效情况**：

| 失效场景 | 说明 |
|---------|------|
| 执行增删改 | 缓存会清空 |
| 手动清空 | 调用`clearCache()` |
| SqlSession关闭 | 缓存消失 |

**代码示例**：
```java
SqlSession session = factory.openSession();
UserMapper mapper = session.getMapper(UserMapper.class);

// 第一次查询 - 查数据库
User user1 = mapper.getUser(1);

// 第二次查询 - 走缓存，不查数据库
User user2 = mapper.getUser(1);

// user1 和 user2 是同一个对象
System.out.println(user1 == user2); // true
```

### 4.4 二级缓存详解


**作用范围**：Mapper级别（跨SqlSession）

**开启步骤**：

1️⃣ **在mapper.xml中配置**：
```xml
<mapper namespace="com.example.mapper.UserMapper">
    <!-- 开启二级缓存 -->
    <cache/>
    
    <select id="getUser" resultType="User" useCache="true">
        SELECT * FROM user WHERE id = #{id}
    </select>
</mapper>
```

2️⃣ **实体类实现序列化**：
```java
public class User implements Serializable {
    private Integer id;
    private String name;
    // ...
}
```

**工作流程**：
```
SqlSession1:
  查询用户1 → 数据库 → 关闭时存入二级缓存

SqlSession2:
  查询用户1 → 直接从二级缓存获取 → 不查数据库
```

**缓存配置参数**：

```xml
<cache 
    eviction="LRU"           <!-- 淘汰策略 -->
    flushInterval="60000"    <!-- 刷新间隔(毫秒) -->
    size="512"               <!-- 最多缓存对象数 -->
    readOnly="false"/>       <!-- 是否只读 -->
```

| 参数 | 可选值 | 说明 |
|------|--------|------|
| `eviction` | LRU/FIFO/SOFT/WEAK | 缓存回收策略 |
| `flushInterval` | 毫秒数 | 多久刷新一次 |
| `size` | 数字 | 最多存多少对象 |
| `readOnly` | true/false | 只读性能更好 |

### 4.5 性能优化技巧


**优化策略清单**：

> 🎯 **批量操作优化**

```xml
<!-- 批量插入 -->
<insert id="batchInsert">
    INSERT INTO user(name, age) VALUES
    <foreach collection="users" item="user" separator=",">
        (#{user.name}, #{user.age})
    </foreach>
</insert>
```

> 🎯 **延迟加载配置**

```xml
<!-- 全局配置 -->
<settings>
    <setting name="lazyLoadingEnabled" value="true"/>
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>

<!-- 关联查询时用到 -->
<association property="dept" fetchType="lazy">
    ...
</association>
```

**延迟加载说明**：
- 不是一开始就查所有数据
- 用到的时候才去查
- 减少不必要的数据库访问

> ⚠️ **注意事项**

| 优化点 | 建议 | 原因 |
|--------|------|------|
| 只查需要的字段 | 避免`SELECT *` | 减少数据传输 |
| 合理使用缓存 | 读多写少场景 | 提升查询性能 |
| 避免N+1问题 | 用联表或批量查询 | 减少SQL执行次数 |

---

## 5. 🔌 插件扩展机制


### 5.1 什么是MyBatis插件


**通俗理解**：插件就像给MyBatis"加装备"。

**生活类比**：
```
MyBatis = 手机
插件 = 各种APP
- 想要分页？装个分页插件
- 想要日志？装个日志插件
- 想要性能监控？装个监控插件
```

**插件能做什么**：
- 📄 **自动分页** → PageHelper
- 📊 **SQL日志** → 打印执行的SQL
- 🔒 **数据权限** → 自动过滤数据
- ⏱️ **性能监控** → 记录SQL执行时间

### 5.2 插件工作原理


**拦截点**：MyBatis提供4个拦截点

```
MyBatis执行流程：

Executor (执行器)
    │
    ↓ [拦截点1：可以拦截执行器]
StatementHandler (语句处理器)  
    │
    ↓ [拦截点2：可以拦截语句处理]
ParameterHandler (参数处理器)
    │
    ↓ [拦截点3：可以拦截参数设置]
ResultSetHandler (结果处理器)
    │
    ↓ [拦截点4：可以拦截结果处理]
返回结果
```

**可拦截的对象**：

| 对象 | 作用时机 | 常用场景 |
|------|---------|---------|
| `Executor` | 执行SQL前后 | 缓存、事务 |
| `StatementHandler` | 准备SQL语句 | SQL重写、分页 |
| `ParameterHandler` | 设置参数 | 参数加密 |
| `ResultSetHandler` | 处理结果 | 结果转换 |

### 5.3 自定义插件开发


**插件开发步骤**：

1️⃣ **实现Interceptor接口**
2️⃣ **添加@Intercepts注解**
3️⃣ **注册插件**

**示例：SQL耗时监控插件**

```java
@Intercepts({
    @Signature(
        type = StatementHandler.class,
        method = "query",
        args = {Statement.class, ResultHandler.class}
    )
})
public class SqlTimeInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        
        // 执行原方法
        Object result = invocation.proceed();
        
        // 计算耗时
        long endTime = System.currentTimeMillis();
        long sqlCost = endTime - startTime;
        
        // 打印日志
        System.out.println("SQL执行耗时: " + sqlCost + "ms");
        
        return result;
    }
}
```

**注解参数说明**：
- `type` → 要拦截的对象类型
- `method` → 要拦截的方法名
- `args` → 方法的参数类型

**注册插件**：
```xml
<plugins>
    <plugin interceptor="com.example.SqlTimeInterceptor"/>
</plugins>
```

### 5.4 常用插件介绍


**PageHelper分页插件** ⭐⭐⭐⭐⭐

> 💡 **作用**：自动实现分页功能，不用手写`LIMIT`

**使用步骤**：

```java
// 1. 开启分页（在查询前调用）
PageHelper.startPage(1, 10); // 第1页，每页10条

// 2. 执行查询
List<User> users = userMapper.getUsers();

// 3. 封装分页结果
PageInfo<User> pageInfo = new PageInfo<>(users);

// 4. 获取分页信息
int total = pageInfo.getTotal();        // 总记录数
int pages = pageInfo.getPages();        // 总页数
List<User> list = pageInfo.getList();   // 当前页数据
```

**工作原理**：
```
原始SQL：SELECT * FROM user

自动改成：SELECT * FROM user LIMIT 0, 10

完全自动，不需要改SQL！
```

**通用Mapper插件** ⭐⭐⭐⭐

> 💡 **作用**：提供单表CRUD通用方法，不用写XML

```java
public interface UserMapper extends Mapper<User> {
    // 不用写任何方法，自动拥有：
    // - selectByPrimaryKey
    // - insert
    // - updateByPrimaryKey  
    // - deleteByPrimaryKey
    // - selectAll
    // 等常用方法
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 MyBatis定位：半自动ORM框架，Java和数据库的翻译官
🔸 核心组件：SqlSessionFactory → SqlSession → Mapper
🔸 SQL映射：把Java方法和SQL语句关联起来
🔸 动态SQL：根据条件自动拼接SQL（if/choose/where/foreach）
🔸 结果映射：数据库结果自动封装成Java对象
🔸 关联查询：一对一用association，一对多用collection
🔸 缓存机制：一级缓存默认开启，二级缓存需配置
🔸 插件扩展：4个拦截点，可以增强MyBatis功能
```

### 6.2 关键理解要点


**🔹 动态SQL的价值**
```
核心价值：让SQL更灵活
- 不同条件生成不同SQL
- 避免写多个重复的SQL
- 代码更简洁优雅

记住：<where>标签会智能处理AND/OR
```

**🔹 缓存的使用场景**
```
适合用缓存：
- 查询频繁的数据
- 很少修改的数据
- 允许短暂的数据不一致

不适合缓存：
- 实时性要求高的数据
- 频繁修改的数据
```

**🔹 关联查询的选择**
```
场景判断：
- 数据量小 → 嵌套查询（灵活）
- 数据量大 → 嵌套结果（性能好）
- 需要延迟加载 → 嵌套查询
```

### 6.3 实践建议


**📌 新手学习路径**：
```
第1步：掌握基础配置和简单查询
第2步：学会使用动态SQL
第3步：理解关联查询
第4步：合理使用缓存
第5步：尝试使用插件
```

**📌 开发规范建议**：

| 规范 | 说明 | 原因 |
|------|------|------|
| SQL放XML中 | 不要在注解里写复杂SQL | 易维护 |
| 避免`SELECT *` | 明确指定需要的列 | 性能好 |
| 善用动态SQL | 减少重复代码 | 代码简洁 |
| 合理使用缓存 | 读多写少才用 | 避免脏数据 |

**核心记忆口诀**：
```
MyBatis映射很简单，
XML配置把SQL关联，
动态标签拼SQL灵活，
缓存插件提升性能好，
关联查询要选对，
一对多collection找！
```