---
title: 4、实战阶段
---
## 📚 目录

1. [完整项目开发实战](#1-完整项目开发实战)
2. [前后端分离架构](#2-前后端分离架构)
3. [系统监控与运维](#3-系统监控与运维)
4. [生产环境部署](#4-生产环境部署)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🚀 完整项目开发实战


### 1.1 项目整体认知


**什么是完整项目？**
```
简单理解：就像盖一栋完整的房子
- 不是只建一面墙（单个功能）
- 而是有地基、墙壁、屋顶、水电（完整系统）

完整项目包含：
前端界面 → 后端接口 → 数据库 → 业务逻辑 → 部署上线
```

**🎯 实战项目架构图**
```
用户浏览器
    ↓ HTTP请求
前端Vue/React
    ↓ API调用
后端Spring Boot
    ↓ 数据操作
MySQL数据库
```

### 1.2 项目开发流程


**📋 完整开发步骤**

```
第一步：需求分析（明确要做什么）
├─ 用户能做什么？（登录、购物、评论等）
├─ 系统要实现什么功能？
└─ 数据怎么存储？

第二步：数据库设计（数据怎么放）
├─ 创建表结构（用户表、订单表等）
├─ 设计表关系（谁和谁有关联）
└─ 添加索引（让查询更快）

第三步：后端接口开发（功能实现）
├─ Controller层：接收请求
├─ Service层：业务逻辑
└─ Mapper层：数据库操作

第四步：前端页面开发（用户看到的）
├─ 页面布局设计
├─ 调用后端接口
└─ 数据展示交互

第五步：联调测试（确保能用）
├─ 前后端接口对接
├─ 功能测试
└─ 修复bug

第六步：部署上线（让别人用）
```

### 1.3 核心业务模块设计


**🔐 用户管理模块**

```
功能清单：
✅ 用户注册：新用户创建账号
✅ 用户登录：验证身份，生成token
✅ 权限控制：不同用户有不同权限
✅ 个人信息：修改资料、头像等

实现要点：
密码加密 → BCrypt加密存储
登录验证 → JWT token认证
权限管理 → 基于角色的权限控制
```

**📦 核心业务模块示例**

| 模块名称 | **核心功能** | **技术要点** | **难点** |
|---------|------------|------------|---------|
| 🔐 **用户模块** | `注册登录、权限管理` | `JWT认证、密码加密` | `token刷新机制` |
| 📦 **商品模块** | `商品管理、分类检索` | `分页查询、图片上传` | `多条件搜索优化` |
| 🛒 **订单模块** | `下单支付、订单管理` | `事务控制、状态机` | `并发库存扣减` |
| 💰 **支付模块** | `支付宝/微信支付` | `异步回调、加密签名` | `支付安全验证` |

### 1.4 实际开发示例


**登录功能完整实现**

```java
// 第一步：Controller接收请求
@RestController
@RequestMapping("/user")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // 用户登录接口
    @PostMapping("/login")
    public Result login(@RequestBody LoginDTO loginDTO) {
        // DTO：数据传输对象，就是个装数据的盒子
        String token = userService.login(loginDTO);
        return Result.success(token);
    }
}

// 第二步：Service处理业务逻辑
@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    public String login(LoginDTO loginDTO) {
        // 1. 查询用户（去数据库找这个人）
        User user = userMapper.findByUsername(loginDTO.getUsername());
        
        // 2. 验证密码（检查密码对不对）
        if (!BCrypt.checkpw(loginDTO.getPassword(), user.getPassword())) {
            throw new RuntimeException("密码错误");
        }
        
        // 3. 生成token（发一个通行证）
        String token = JwtUtil.createToken(user.getId());
        return token;
    }
}
```

**💡 代码理解要点**
```
DTO是什么？
→ Data Transfer Object（数据传输对象）
→ 就像快递盒子，专门用来传递数据
→ 前端传来的数据装在这个盒子里

BCrypt是什么？
→ 一种加密算法，把密码加密存储
→ 即使数据库泄露，也看不到真实密码
→ checkpw：校验密码是否匹配

JWT Token是什么？
→ 像门禁卡，证明你已经登录
→ 后续请求带上这个token就不用重复登录
→ 服务器通过token知道你是谁
```

---

## 2. 🌐 前后端分离架构


### 2.1 什么是前后端分离


**传统方式 vs 前后端分离**

```
传统方式（耦合在一起）：
浏览器 → Java代码生成HTML → 返回完整网页
缺点：前端改页面要改Java代码，太麻烦

前后端分离（各干各的）：
浏览器 → 前端Vue/React → 调用API → 后端Spring Boot → 返回JSON数据
         (负责页面展示)         (只负责数据)

优点：
✅ 前端专注界面，后端专注逻辑
✅ 同时开发，互不影响
✅ 接口可以给多个端用（网页、App、小程序）
```

**🔄 数据交互流程**
```
用户操作 → 前端发起请求 → 后端处理 → 返回JSON → 前端渲染页面

示例：用户点击"商品列表"
1️⃣ 前端：发送 GET /api/products 请求
2️⃣ 后端：查询数据库，返回 {code:200, data:[商品数组]}
3️⃣ 前端：接收数据，渲染成漂亮的卡片展示
```

### 2.2 RESTful接口规范


**什么是RESTful？**
```
REST：表现层状态转换（听起来复杂，其实很简单）
→ 就是一套设计接口的规则
→ 让接口更清晰、更统一

核心规则：
📌 URL表示资源（名词）
📌 HTTP方法表示动作（动词）
```

**🎯 RESTful设计对照表**

| 操作 | **传统方式** | **RESTful方式** | **HTTP方法** |
|------|------------|----------------|-------------|
| 查询列表 | `/getUserList` | `/users` | `GET` |
| 查询单个 | `/getUserById?id=1` | `/users/1` | `GET` |
| 新增 | `/addUser` | `/users` | `POST` |
| 修改 | `/updateUser` | `/users/1` | `PUT` |
| 删除 | `/deleteUser` | `/users/1` | `DELETE` |

**💡 理解要点**
```
为什么要用RESTful？
→ 接口一看就懂：GET /users 一定是查用户列表
→ 统一规范：所有开发者都按这个规则来
→ 维护方便：新人接手项目也能快速理解

HTTP方法含义：
GET    → 获取数据（查询）
POST   → 提交数据（新增）
PUT    → 更新数据（修改）
DELETE → 删除数据（删除）
```

### 2.3 跨域问题解决


**什么是跨域？**
```
简单理解：浏览器的安全限制
→ 前端在 localhost:8080 运行
→ 后端在 localhost:9090 运行
→ 域名或端口不一样，浏览器不让访问

这就像：你在A小区，不能随便进B小区
```

**🔧 跨域解决方案**

```java
// 方案1：后端配置CORS（推荐）
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        
        // 允许哪些网站访问
        config.addAllowedOrigin("http://localhost:8080");
        
        // 允许哪些方法
        config.addAllowedMethod("*");  // GET, POST等都可以
        
        // 允许哪些请求头
        config.addAllowedHeader("*");
        
        // 允许携带cookie
        config.setAllowCredentials(true);
        
        // 应用到所有路径
        UrlBasedCorsConfigurationSource source = 
            new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        
        return new CorsFilter(source);
    }
}
```

**解决方案对比**

```
方案1：后端CORS配置 ✅推荐
优点：简单直接，适合生产环境
配置：后端加一个配置类即可

方案2：前端代理
优点：开发环境方便
缺点：只能在开发时用

方案3：Nginx反向代理
优点：生产环境最佳方案
用法：前后端请求都转发到同一个域名下
```

---

## 3. 📊 系统监控与运维


### 3.1 为什么要监控系统


**监控的重要性**
```
就像给系统装上"健康监测仪"
→ 实时了解系统运行状态
→ 及时发现问题
→ 提前预防故障

不监控的后果：
❌ 系统崩了才知道
❌ 不知道哪里出问题
❌ 用户投诉才发现
```

### 3.2 Spring Boot Actuator监控


**什么是Actuator？**
```
Actuator：Spring Boot自带的健康检查工具
→ 像汽车的仪表盘
→ 显示系统各项指标
→ 无需额外开发
```

**🔧 快速集成步骤**

```xml
<!-- 第一步：添加依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```yaml
# 第二步：配置文件开启监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"  # 开放所有监控端点
  endpoint:
    health:
      show-details: always  # 显示详细健康信息
```

**📈 监控端点说明**

| 端点 | **访问地址** | **作用说明** |
|------|------------|------------|
| 健康检查 | `/actuator/health` | `查看系统是否健康` |
| 详细信息 | `/actuator/info` | `应用基本信息` |
| 性能指标 | `/actuator/metrics` | `内存、CPU等指标` |
| 日志配置 | `/actuator/loggers` | `动态修改日志级别` |

**💡 实际使用场景**
```
场景1：系统变慢了
访问：/actuator/metrics/jvm.memory.used
查看：内存使用情况，是否内存泄漏

场景2：接口响应慢
访问：/actuator/metrics/http.server.requests
查看：哪个接口调用次数多、响应时间长

场景3：线上排查问题
访问：/actuator/loggers
临时调整：把日志级别改为DEBUG，查看详细日志
```

### 3.3 日志管理


**日志的作用**
```
日志就像系统的"黑匣子"
→ 记录系统运行轨迹
→ 出问题时回溯查看
→ 分析用户行为
```

**🎯 日志级别使用指南**

```
ERROR：严重错误，系统可能无法继续
示例：数据库连接失败、支付失败

WARN：警告信息，不影响运行但需注意
示例：参数校验失败、缓存未命中

INFO：重要业务流程记录
示例：用户登录成功、订单创建

DEBUG：调试信息，开发时用
示例：方法参数、中间变量值

使用原则：
生产环境：只开INFO及以上
开发环境：可开DEBUG
```

**实用日志配置**

```xml
<!-- logback-spring.xml -->
<configuration>
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出（按日期分割） -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/app.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天一个文件 -->
            <fileNamePattern>logs/app-%d{yyyy-MM-dd}.log</fileNamePattern>
            <!-- 保留30天 -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 根日志级别 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
</configuration>
```

---

## 4. 🚢 生产环境部署


### 4.1 部署方式选择


**常见部署方式对比**

```
方式1：传统部署（直接在服务器运行）
服务器 → 安装JDK → 运行jar包
优点：简单直接
缺点：环境配置麻烦，不好管理

方式2：Docker容器化（推荐）
服务器 → Docker → 容器运行应用
优点：环境隔离，一键部署
缺点：需要学习Docker

方式3：云平台部署
上传代码 → 云平台自动部署
优点：最省心，自动扩容
缺点：需要花钱
```

### 4.2 Docker容器化部署


**什么是Docker？**
```
Docker就像一个"集装箱"
→ 把应用和环境打包在一起
→ 到哪里都能运行
→ 不用担心"我电脑上能跑，你电脑上不行"

核心概念：
镜像(Image)：打包好的应用模板
容器(Container)：镜像运行起来的实例
仓库(Registry)：存放镜像的地方
```

**🐳 Docker部署完整流程**

```dockerfile
# 第一步：创建Dockerfile
FROM openjdk:8-jdk-alpine

# 设置工作目录
WORKDIR /app

# 复制jar包
COPY target/myapp.jar app.jar

# 暴露端口
EXPOSE 8080

# 启动命令
ENTRYPOINT ["java", "-jar", "app.jar"]
```

```bash
# 第二步：构建镜像
docker build -t myapp:1.0 .

# 第三步：运行容器
docker run -d \
  -p 8080:8080 \
  --name myapp \
  -e SPRING_PROFILES_ACTIVE=prod \
  myapp:1.0
```

**💡 Docker命令理解**
```
docker build：根据Dockerfile制作镜像（打包）
-t myapp:1.0：给镜像起名字和版本号

docker run：启动容器（运行应用）
-d：后台运行
-p 8080:8080：端口映射（外部8080→容器8080）
--name：给容器起名字
-e：设置环境变量（指定用生产环境配置）
```

### 4.3 环境配置管理


**多环境配置**
```
开发环境 → application-dev.yml
测试环境 → application-test.yml
生产环境 → application-prod.yml

不同环境用不同配置：
开发：本地MySQL，DEBUG日志
测试：测试服务器MySQL，INFO日志
生产：线上MySQL，WARN日志，开启监控
```

**🔐 敏感信息管理**

```yaml
# 生产环境配置示例
spring:
  datasource:
    # ❌ 错误：明文写在配置文件
    # password: 123456
    
    # ✅ 正确：使用环境变量
    password: ${DB_PASSWORD}
    
  redis:
    # 从环境变量读取
    password: ${REDIS_PASSWORD}

# 运行时传入：
# java -jar app.jar --DB_PASSWORD=真实密码
```

### 4.4 部署检查清单


**📋 上线前必查项**

```
配置检查 ✅
□ 数据库连接正确
□ Redis连接正确
□ 日志级别设为INFO
□ 监控端点已开启
□ 敏感信息已加密

性能检查 ✅
□ 数据库索引已创建
□ 慢SQL已优化
□ 缓存已启用
□ 连接池已配置

安全检查 ✅
□ HTTPS已配置
□ 跨域已限制
□ SQL注入已防护
□ XSS攻击已防护

运维准备 ✅
□ 备份方案已制定
□ 监控告警已配置
□ 回滚方案已准备
□ 应急预案已制定
```

**🚀 部署后验证**

```bash
# 1. 检查容器运行状态
docker ps | grep myapp

# 2. 查看应用日志
docker logs -f myapp

# 3. 健康检查
curl http://localhost:8080/actuator/health

# 4. 测试核心接口
curl http://localhost:8080/api/test
```

---

## 5. 📋 核心要点总结


### 5.1 项目开发要点


**🎯 完整项目流程记忆**
```
需求分析 → 数据库设计 → 后端开发 → 前端开发 → 联调测试 → 部署上线

关键点：
✅ 先设计数据库再写代码
✅ 接口遵循RESTful规范
✅ 前后端分离，各司其职
✅ 业务逻辑写在Service层
```

### 5.2 架构设计要点


**🏗️ 系统架构核心**
```
分层架构：
Controller → Service → Mapper → Database
(接收请求)  (业务逻辑) (数据访问) (数据存储)

前后端分离：
前端Vue → HTTP → 后端Spring Boot → MySQL
        (JSON)
        
关键技术：
认证：JWT Token
跨域：CORS配置
接口：RESTful规范
```

### 5.3 运维部署要点


**📊 监控部署核心**
```
监控三要素：
1️⃣ Actuator健康检查
2️⃣ 日志记录追踪
3️⃣ 性能指标分析

部署三步骤：
1️⃣ Docker打包镜像
2️⃣ 环境配置管理
3️⃣ 上线检查验证

生产环境注意：
⚠️ 敏感信息要加密
⚠️ 日志级别用INFO
⚠️ 监控告警要配置
⚠️ 备份方案要准备
```

### 5.4 学习路径建议


**📈 实战进阶路线**

```
入门阶段（1-2周）
├─ 理解前后端分离概念
├─ 掌握RESTful接口设计
└─ 完成简单CRUD项目

进阶阶段（1个月）
├─ 实现用户登录认证
├─ 掌握事务和异常处理
├─ 学会接口文档编写
└─ 完成电商项目核心模块

高级阶段（1-2个月）
├─ 系统性能优化
├─ 分布式架构入门
├─ 容器化部署实践
└─ 完整项目上线运维
```

**💡 学习建议**
```
🔸 先做后学：边做项目边学技术
🔸 问题驱动：遇到问题再深入研究
🔸 循序渐进：从简单到复杂
🔸 注重实战：理论必须结合实践
```

### 5.5 常见问题解答


**❓ 新手常见困惑**

```
Q1：前后端分离是必须的吗？
A：不是必须，但是主流趋势
→ 小项目可以不分离
→ 大项目强烈建议分离
→ 学习时建议都接触

Q2：Docker部署很难吗？
A：入门简单，精通需时间
→ 基础用法几天就会
→ 先用起来，慢慢深入
→ 实际项目中学习

Q3：监控是必须配置的吗？
A：生产环境必须要有
→ 开发环境可以简单点
→ 至少要有日志记录
→ Actuator开箱即用很方便

Q4：怎么学习最有效？
A：动手实践最重要
→ 看10遍不如做1遍
→ 遇到问题查文档
→ 跟着项目走完整流程
```

**🎓 下一步学习方向**
```
掌握SSM后可以学：
→ 微服务架构（Spring Cloud）
→ 消息队列（RabbitMQ、Kafka）
→ 搜索引擎（Elasticsearch）
→ 容器编排（Kubernetes）
→ 分布式解决方案

记住：基础打牢最重要！
```