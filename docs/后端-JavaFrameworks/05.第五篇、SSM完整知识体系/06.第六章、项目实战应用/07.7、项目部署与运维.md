---
title: 7、项目部署与运维
---
## 📚 目录

1. [项目打包构建](#1-项目打包构建)
2. [Tomcat服务器部署](#2-tomcat服务器部署)
3. [Nginx反向代理配置](#3-nginx反向代理配置)
4. [数据库与环境配置](#4-数据库与环境配置)
5. [日志管理配置](#5-日志管理配置)
6. [性能优化调优](#6-性能优化调优)
7. [安全加固策略](#7-安全加固策略)
8. [备份与恢复](#8-备份与恢复)
9. [灰度发布实践](#9-灰度发布实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📦 项目打包构建


### 1.1 什么是WAR包？


**通俗理解**：WAR包就像一个"打包好的行李箱"

```
开发时的项目：
项目文件夹/
├── src/          ← Java源代码
├── webapp/       ← 网页资源
├── lib/          ← 依赖的jar包
└── 配置文件

打包成WAR：
myproject.war     ← 压缩成一个文件，方便运输
```

**WAR包（Web Archive）** = 网页应用的归档文件
- 把所有项目文件压缩成一个包
- 就像把衣服装进旅行箱，方便携带
- 服务器收到后会自动"解压"使用

### 1.2 使用Maven打包


**Maven是什么？** 就像一个"自动打包机器人"

```xml
<!-- pom.xml中的打包配置 -->
<packaging>war</packaging>

<build>
    <finalName>myproject</finalName>  <!-- 生成的WAR包名字 -->
</build>
```

**打包命令**：
```bash
# 在项目根目录执行
mvn clean package

# 打包过程说明：
# clean  → 清理之前的编译文件
# package → 编译代码并打包成WAR
```

**打包流程图示**：
```
源代码 → [Maven编译] → Class文件 → [Maven打包] → WAR文件
  ↓                      ↓                      ↓
检查依赖              复制资源              生成到target/
```

### 1.3 打包注意事项


| 检查项 | 说明 | 为什么重要 |
|--------|------|-----------|
| **依赖范围** | `provided`的依赖不打包 | Tomcat自带servlet，不需要重复 |
| **配置文件** | 区分开发/生产环境 | 避免用测试数据库 |
| **静态资源** | 图片、CSS、JS要包含 | 否则页面显示不正常 |
| **日志配置** | 生产环境用文件日志 | 控制台日志服务器看不到 |

**实用技巧**：
```
打包前检查清单：
□ 数据库地址改为生产环境
□ 日志级别调整为INFO或WARN
□ 敏感信息移除（密码、密钥等）
□ 测试代码和注释清理
□ 依赖版本锁定
```

---

## 2. 🚀 Tomcat服务器部署


### 2.1 Tomcat是什么？


**通俗比喻**：Tomcat就像一个"应用程序的房东"

```
没有Tomcat的WAR包 = 无家可归的程序
  ↓
部署到Tomcat = 给程序安了个家
  ↓
程序在Tomcat里运行 = 可以对外提供服务了
```

**Tomcat的作用**：
- 🏠 提供运行环境（Java Web容器）
- 🔌 处理HTTP请求
- 📡 管理应用生命周期

### 2.2 部署方式对比


**方式一：直接复制WAR包**
```
步骤：
1. 将 myproject.war 复制到 tomcat/webapps/
2. 启动Tomcat（自动解压WAR包）
3. 访问 http://localhost:8080/myproject

优点：简单直接，适合快速部署
缺点：需要手动重启服务器
```

**方式二：Manager管理界面**
```
访问路径：
http://localhost:8080/manager

操作步骤：
1. 登录管理界面
2. 选择WAR文件上传
3. 点击部署按钮
4. 立即生效，无需重启

优点：可视化操作，支持热部署
```

### 2.3 Tomcat配置要点


**server.xml - 核心配置**：
```xml
<!-- 修改端口号 -->
<Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" />

<!-- 配置虚拟主机 -->
<Host name="www.myproject.com" appBase="webapps"
      unpackWARs="true" autoDeploy="true">
    <Context path="" docBase="myproject" />
</Host>
```

**配置解释**：
- `port="8080"` → 访问端口（类似门牌号）
- `connectionTimeout` → 超时时间（等待用户的耐心）
- `unpackWARs="true"` → 自动解压WAR包
- `autoDeploy="true"` → 监控新应用自动部署

**性能调优参数**：
```
核心参数说明：
maxThreads="200"        ← 最多同时处理200个请求
minSpareThreads="25"    ← 保持25个空闲线程待命
acceptCount="100"       ← 等待队列容量
```

---

## 3. 🔄 Nginx反向代理配置


### 3.1 为什么需要Nginx？


**场景问题**：
```
直接访问Tomcat的问题：
❌ 用户要记住端口号（http://xxx.com:8080）
❌ 静态资源（图片、CSS）也走Tomcat，浪费资源
❌ 无法做负载均衡
❌ HTTPS配置复杂

使用Nginx解决：
✅ 标准80端口访问（http://xxx.com）
✅ 静态资源由Nginx直接处理
✅ 可以部署多个Tomcat分担压力
✅ 统一管理SSL证书
```

### 3.2 反向代理原理


**正向代理 vs 反向代理**：
```
正向代理（科学上网）：
用户 → 代理服务器 → 目标网站
帮用户访问外网

反向代理（Nginx）：
用户 → Nginx → 后端服务器
帮服务器接待用户
```

**工作流程图**：
```
浏览器                Nginx              Tomcat
  |                     |                  |
  |--[1]请求页面------->|                  |
  |   www.myapp.com     |                  |
  |                     |                  |
  |                     |--[2]转发请求---->|
  |                     |                  |
  |                     |<-[3]返回数据-----|
  |                     |                  |
  |<--[4]返回给用户-----|                  |
```

### 3.3 Nginx配置实例


**基础配置**：
```nginx
# nginx.conf
server {
    listen 80;                        # 监听80端口
    server_name www.myproject.com;    # 域名
    
    # 处理静态资源（图片、CSS、JS）
    location /static/ {
        root /var/www/myproject;      # 直接返回文件
        expires 7d;                   # 缓存7天
    }
    
    # 动态请求转发给Tomcat
    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

**负载均衡配置**：
```nginx
# 定义后端服务器组
upstream tomcat_backend {
    server 192.168.1.10:8080 weight=3;  # 权重3
    server 192.168.1.11:8080 weight=1;  # 权重1
    server 192.168.1.12:8080 backup;    # 备用服务器
}

server {
    listen 80;
    
    location / {
        proxy_pass http://tomcat_backend;  # 使用服务器组
    }
}
```

**配置解释**：
- `weight` → 权重值，数字越大分配的请求越多
- `backup` → 备用服务器，其他挂了才用
- `proxy_set_header` → 传递用户真实IP给后端

---

## 4. 🔗 数据库与环境配置


### 4.1 数据库连接配置


**为什么要区分环境？**
```
开发环境：
数据库：localhost（本机）
数据：测试数据，可以随便改

生产环境：
数据库：远程服务器
数据：真实数据，不能出错！
```

**配置文件区分**：
```
项目结构：
├── application.yml              ← 公共配置
├── application-dev.yml          ← 开发环境
└── application-prod.yml         ← 生产环境
```

**生产环境配置示例**：
```yaml
# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://192.168.1.100:3306/mydb?useSSL=true
    username: ${DB_USER}           # 从环境变量读取
    password: ${DB_PASSWORD}       # 密码不写死在配置里
    
    # 连接池配置
    hikari:
      maximum-pool-size: 20        # 最多20个连接
      minimum-idle: 5              # 至少保持5个空闲
      connection-timeout: 30000    # 30秒超时
```

### 4.2 环境变量配置


**为什么用环境变量？**
```
硬编码密码的问题：
❌ 配置文件里写明文密码不安全
❌ 代码提交到Git会泄露
❌ 换环境要改代码重新打包

用环境变量的好处：
✅ 敏感信息不出现在代码里
✅ 同一个WAR包适配多个环境
✅ 运维可以独立管理配置
```

**Linux设置环境变量**：
```bash
# 方式一：临时设置（当次有效）
export DB_USER=root
export DB_PASSWORD=MyPass123

# 方式二：永久设置（写入配置文件）
vim /etc/profile
# 添加：
export DB_USER=root
export DB_PASSWORD=MyPass123
# 生效：
source /etc/profile
```

**Tomcat启动脚本设置**：
```bash
# catalina.sh 开头添加
export DB_USER="prod_user"
export DB_PASSWORD="SecurePass@2024"
export REDIS_HOST="192.168.1.101"
```

### 4.3 配置管理最佳实践


**配置优先级**：
```
加载顺序（优先级从高到低）：
1. 启动命令行参数    ← 最高优先级
2. 环境变量          
3. application-{profile}.yml
4. application.yml    ← 最低优先级

示例：
java -jar app.war --spring.profiles.active=prod --server.port=8081
```

**敏感信息处理**：
```
✅ 推荐做法：
- 数据库密码 → 环境变量
- API密钥 → 配置中心
- 证书文件 → 独立目录，权限控制

❌ 避免做法：
- 密码写在配置文件
- 敏感信息提交到Git
- 所有环境用同一套配置
```

---

## 5. 📋 日志管理配置


### 5.1 日志的作用


**日志就像"飞机黑匣子"**：
```
系统正常运行时：
日志记录 → 了解系统状态
        → 分析用户行为
        → 统计业务数据

系统出问题时：
日志记录 → 查找错误原因
        → 定位问题位置
        → 还原事故现场
```

### 5.2 日志级别配置


**日志级别从低到高**：
```
TRACE → DEBUG → INFO → WARN → ERROR

开发环境：用DEBUG
├── 看到详细的执行过程
└── 方便调试问题

生产环境：用INFO或WARN
├── 只记录关键信息
└── 避免日志文件太大
```

**Logback配置示例**：
```xml
<!-- logback-spring.xml -->
<configuration>
    <!-- 控制台输出（开发环境） -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss} [%thread] %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出（生产环境） -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>/var/log/myapp/app.log</file>
        
        <!-- 滚动策略：每天一个文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>/var/log/myapp/app.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>  <!-- 保留30天 -->
        </rollingPolicy>
        
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 根据环境切换 -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE" />
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="FILE" />
        </root>
    </springProfile>
</configuration>
```

### 5.3 日志文件管理


**日志分类策略**：
```
按功能分类：
├── app.log        ← 应用主日志
├── error.log      ← 错误日志（单独记录）
├── access.log     ← 访问日志
└── sql.log        ← SQL执行日志

按时间归档：
├── app.2024-09-23.log
├── app.2024-09-22.log
└── app.2024-09-21.log
```

**日志清理策略**：
```bash
# 定时清理脚本（crontab配置）
0 2 * * * find /var/log/myapp -name "*.log" -mtime +30 -delete

# 说明：
# 每天凌晨2点执行
# 删除30天前的日志文件
# 避免磁盘被撑满
```

---

## 6. ⚡ 性能优化调优


### 6.1 JVM内存调优


**为什么要调JVM参数？**
```
默认配置的问题：
- 堆内存太小 → 频繁GC，性能下降
- 堆内存太大 → GC时间长，影响响应
- 没设置监控 → 问题发生了才知道

合理配置的好处：
- 减少GC频率
- 提升响应速度
- 便于问题诊断
```

**推荐配置**：
```bash
# Tomcat启动参数（catalina.sh）
JAVA_OPTS="-Xms2048m -Xmx2048m \
           -XX:MetaspaceSize=256m \
           -XX:MaxMetaspaceSize=512m \
           -XX:+UseG1GC \
           -XX:MaxGCPauseMillis=200 \
           -XX:+HeapDumpOnOutOfMemoryError \
           -XX:HeapDumpPath=/var/log/myapp/heapdump.hprof"
```

**参数解释**：
| 参数 | 含义 | 推荐值 |
|------|------|--------|
| `-Xms` | 初始堆内存 | 和Xmx设置相同 |
| `-Xmx` | 最大堆内存 | 物理内存的60-70% |
| `-XX:MetaspaceSize` | 元空间初始值 | 256m |
| `+UseG1GC` | 使用G1垃圾回收器 | 推荐使用 |
| `+HeapDumpOnOutOfMemoryError` | OOM时自动dump | 必须开启 |

### 6.2 数据库连接池优化


**连接池配置要点**：
```yaml
spring:
  datasource:
    hikari:
      # 核心参数
      maximum-pool-size: 20      # 最大连接数
      minimum-idle: 5            # 最小空闲连接
      connection-timeout: 30000  # 获取连接超时时间
      
      # 连接保活
      max-lifetime: 1800000      # 连接最大存活时间（30分钟）
      idle-timeout: 600000       # 空闲连接超时（10分钟）
```

**如何确定连接数？**
```
计算公式：
连接数 = ((核心数 × 2) + 有效磁盘数)

示例：
4核CPU，1块磁盘
连接数 = (4 × 2) + 1 = 9

实际建议：
- 起始值：10-20
- 观察监控指标
- 根据压测结果调整
```

### 6.3 缓存策略优化


**多级缓存架构**：
```
请求流程：
用户请求 → Nginx缓存（静态资源）
         ↓ 未命中
         → Redis缓存（热点数据）
         ↓ 未命中
         → 数据库（源数据）

性能提升：
Nginx: 响应时间 < 1ms
Redis: 响应时间 < 10ms  
MySQL: 响应时间 > 100ms
```

**Redis缓存配置**：
```java
@Configuration
public class RedisConfig {
    @Bean
    public RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))     // 缓存1小时
            .disableCachingNullValues()        // 不缓存null值
            .serializeValuesWith(              // JSON序列化
                RedisSerializationContext.SerializationPair
                    .fromSerializer(new GenericJackson2JsonRedisSerializer())
            );
    }
}
```

---

## 7. 🔒 安全加固策略


### 7.1 常见安全隐患


**新手容易犯的错误**：
```
❌ 危险操作：
1. 数据库密码写在代码里
2. 管理后台没有权限验证
3. 直接拼接SQL（SQL注入风险）
4. 用户输入不过滤（XSS攻击）
5. 敏感信息明文传输

✅ 安全做法：
1. 密码用环境变量 + 加密存储
2. 所有接口都要权限验证
3. 使用MyBatis的#{}（预编译）
4. 输入输出都要转义过滤
5. 全站HTTPS加密传输
```

### 7.2 Tomcat安全配置


**隐藏版本信息**：
```xml
<!-- server.xml -->
<Connector port="8080" protocol="HTTP/1.1"
           server="MyServer" />  <!-- 隐藏Tomcat版本 -->
```

**禁用不必要的功能**：
```xml
<!-- 删除默认的示例应用 -->
删除 webapps/docs
删除 webapps/examples
删除 webapps/host-manager
删除 webapps/manager（或严格限制访问IP）
```

### 7.3 应用层安全措施


**SQL注入防护**：
```java
// ❌ 危险写法（SQL注入）
String sql = "SELECT * FROM user WHERE name = '" + userName + "'";

// ✅ 安全写法（预编译）
@Select("SELECT * FROM user WHERE name = #{userName}")
User findByName(String userName);
```

**XSS攻击防护**：
```java
// 输出时转义HTML
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
${fn:escapeXml(userInput)}

// Spring配置全局过滤
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new XssInterceptor());
    }
}
```

**密码安全存储**：
```java
// 使用BCrypt加密密码
@Service
public class UserService {
    @Autowired
    private BCryptPasswordEncoder encoder;
    
    public void register(String password) {
        String hashedPassword = encoder.encode(password);
        // 存储加密后的密码
    }
}
```

---

## 8. 💾 备份与恢复


### 8.1 备份策略设计


**备份的重要性**：
```
没有备份的风险：
- 服务器硬盘损坏 → 数据全丢
- 误操作删除数据 → 无法恢复
- 黑客攻击勒索 → 束手无策

有备份的保障：
- 定期自动备份 → 安心睡觉
- 多地存储备份 → 容灾保障
- 定期验证恢复 → 确保可用
```

**备份类型对比**：
```
全量备份：
├── 备份所有数据
├── 恢复速度快
└── 占用空间大

增量备份：
├── 只备份变化的数据
├── 节省存储空间
└── 恢复需要多个备份文件

推荐策略：
- 每周一次全量备份
- 每天一次增量备份
```

### 8.2 数据库备份脚本


**MySQL自动备份**：
```bash
#!/bin/bash
# backup_db.sh

# 配置
DB_USER="backup_user"
DB_PASS="backup_pass"
DB_NAME="myproject"
BACKUP_DIR="/data/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份
mysqldump -u${DB_USER} -p${DB_PASS} ${DB_NAME} \
    | gzip > ${BACKUP_DIR}/db_${DATE}.sql.gz

# 只保留最近7天的备份
find ${BACKUP_DIR} -name "db_*.sql.gz" -mtime +7 -delete

# 备份到远程服务器（可选）
# rsync -avz ${BACKUP_DIR} backup@remote:/backup/
```

**定时任务配置**：
```bash
# crontab -e 添加
0 2 * * * /scripts/backup_db.sh      # 每天凌晨2点备份
0 3 * * 0 /scripts/backup_full.sh    # 每周日凌晨3点全量备份
```

### 8.3 应用备份与恢复


**备份内容清单**：
```
需要备份的内容：
✓ WAR包（应用程序）
✓ 配置文件（Tomcat、Nginx）
✓ 上传的文件（用户头像、附件等）
✓ 日志文件（近期的重要日志）
✓ 数据库备份文件

存储位置：
1. 本地磁盘（快速恢复）
2. 远程服务器（异地容灾）
3. 云存储（长期归档）
```

**快速恢复流程**：
```
恢复步骤：
1. 停止Tomcat服务
2. 还原数据库备份
3. 部署WAR包
4. 恢复配置文件
5. 恢复用户上传文件
6. 启动服务验证
```

---

## 9. 🚦 灰度发布实践


### 9.1 什么是灰度发布？


**通俗比喻**：就像"试吃新菜"
```
传统发布（全量发布）：
新版本 → 一次性给所有用户
       ↓
       出问题全体受影响

灰度发布：
新版本 → 先给5%用户试用
       ↓ 观察一段时间
       → 再给20%用户
       ↓ 没问题继续
       → 最后全量放开

好处：
- 降低发布风险
- 快速发现问题
- 随时可以回滚
```

### 9.2 基于Nginx的灰度方案


**原理图示**：
```
用户访问
   ↓
Nginx判断
   ├─→ 5%流量 → 新版本服务器（v2.0）
   └─→ 95%流量 → 旧版本服务器（v1.0）
```

**Nginx配置实现**：
```nginx
# 定义新旧版本服务器
upstream backend_v1 {
    server 192.168.1.10:8080;  # 旧版本
}

upstream backend_v2 {
    server 192.168.1.11:8080;  # 新版本
}

# 根据用户IP灰度
split_clients "${remote_addr}" $backend {
    5%     backend_v2;    # 5%用户走新版本
    *      backend_v1;    # 其他用户走旧版本
}

server {
    listen 80;
    location / {
        proxy_pass http://$backend;
    }
}
```

### 9.3 灰度发布流程


**完整发布流程**：
```
阶段一：灰度准备（第0天）
├── 部署新版本到灰度服务器
├── 配置Nginx规则（5%流量）
└── 准备监控和回滚预案

阶段二：小流量验证（第1-2天）
├── 开启5%流量到新版本
├── 密切监控错误日志
├── 对比新旧版本指标
└── 收集用户反馈

阶段三：逐步放量（第3-5天）
├── 无问题 → 调整至20%
├── 继续监控 → 调整至50%
└── 稳定运行 → 调整至100%

阶段四：全量发布（第6天）
├── 新版本承载100%流量
├── 保留旧版本服务器（备用）
└── 观察7天后下线旧版本
```

**监控指标对比**：
| 指标 | 旧版本 | 新版本 | 判断 |
|------|--------|--------|------|
| **响应时间** | 200ms | 180ms | ✅ 性能提升 |
| **错误率** | 0.1% | 0.08% | ✅ 更稳定 |
| **CPU使用** | 60% | 55% | ✅ 资源优化 |
| **内存占用** | 2GB | 2.2GB | ⚠️ 需观察 |

### 9.4 回滚策略


**快速回滚方案**：
```nginx
# 发现问题立即回滚
split_clients "${remote_addr}" $backend {
    0%     backend_v2;    # 关闭新版本流量
    *      backend_v1;    # 全部走旧版本
}

# 重新加载配置（1秒内生效）
nginx -s reload
```

**回滚决策标准**：
```
立即回滚的情况：
🚨 错误率超过1%
🚨 关键功能不可用
🚨 数据一致性问题
🚨 严重性能下降

观察处理的情况：
⚠️ 小范围功能异常
⚠️ 非关键路径问题
⚠️ 轻微性能波动
```

---

## 10. 📋 核心要点总结


### 10.1 部署流程图


**完整部署链路**：
```
开发完成
   ↓
Maven打包 → 生成WAR包
   ↓
上传服务器 → 部署到Tomcat
   ↓
配置Nginx → 反向代理
   ↓
环境配置 → 数据库、日志
   ↓
性能调优 → JVM、连接池
   ↓
安全加固 → 权限、加密
   ↓
备份设置 → 自动备份
   ↓
灰度发布 → 稳定上线
```

### 10.2 运维检查清单


**上线前检查**：
```
□ WAR包构建无误
□ 数据库连接测试通过
□ 环境变量配置正确
□ 日志目录有写权限
□ 静态资源路径正确
□ Nginx配置语法检查
□ 防火墙端口开放
□ 备份脚本测试通过
□ 监控告警配置完成
□ 回滚方案准备就绪
```

**上线后监控**：
```
实时监控指标：
📊 QPS（每秒请求数）
📊 响应时间
📊 错误率
📊 CPU使用率
📊 内存使用率
📊 数据库连接数
📊 磁盘IO
📊 网络流量
```

### 10.3 常见问题处理


| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|---------|
| **端口已被占用** | Tomcat未正常关闭 | `kill -9 进程ID` 强制停止 |
| **数据库连接失败** | 配置错误或防火墙 | 检查配置，开放3306端口 |
| **内存溢出OOM** | 堆内存不足 | 增大-Xmx参数 |
| **静态资源404** | Nginx路径配置错误 | 检查root路径和文件权限 |
| **响应超时** | 数据库慢查询 | 检查SQL性能，添加索引 |

### 10.4 核心知识回顾


**🎯 必知必会清单**：
1. **打包部署** - Maven打包，Tomcat部署方式
2. **反向代理** - Nginx配置，负载均衡原理
3. **环境配置** - 数据库连接，环境变量使用
4. **日志管理** - 日志级别，文件分类与归档
5. **性能优化** - JVM调优，连接池配置
6. **安全加固** - SQL注入防护，XSS防护
7. **备份恢复** - 备份策略，恢复流程
8. **灰度发布** - 流量控制，快速回滚

**🔑 关键理解**：
```
部署的本质：
把开发环境的代码，安全稳定地迁移到生产环境

运维的核心：
保障系统稳定运行，快速响应和处理问题

灰度的价值：
降低发布风险，让新版本平稳过渡
```

**💡 实战建议**：
- 部署前做好充分测试
- 配置文件分环境管理
- 日志要详细但不冗余
- 性能调优要基于监控数据
- 安全永远是第一位
- 备份是最后一道防线
- 灰度发布是稳定上线的保障

---

**记忆口诀**：
```
打包部署走流程，环境配置要区分
日志监控不能少，性能优化看数据
安全防护要做好，备份恢复是保险
灰度发布降风险，运维稳定最重要
```