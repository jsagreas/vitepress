---
title: 1、SpringMVC架构与执行流程
---
## 📚 目录

1. [MVC设计模式基础](#1-mvc设计模式基础)
2. [SpringMVC核心组件详解](#2-springmvc核心组件详解)
3. [请求处理完整流程](#3-请求处理完整流程)
4. [配置文件详解](#4-配置文件详解)
5. [父子容器关系](#5-父子容器关系)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎨 MVC设计模式基础


### 1.1 什么是MVC模式


**🔸 通俗理解**

想象你去餐厅吃饭：
- **服务员（Controller）**：接待你，记录点餐，传达给后厨
- **厨师（Model）**：负责做菜，处理食材
- **菜品展示（View）**：把做好的菜装盘呈现给你

MVC就是这样一个分工合作的模式！

```
传统开发问题：
一个人既当服务员，又当厨师，还要负责摆盘
→ 代码混乱，难以维护

MVC解决方案：
把职责分开，各司其职
→ 代码清晰，易于维护
```

### 1.2 MVC三层架构


**📋 核心组成**

```
用户请求 → Controller → Model → View → 响应结果

🔹 Model（模型层）
作用：处理业务逻辑和数据
比如：查询数据库、计算结果、处理订单
职责：专注做事情，不管怎么展示

🔹 View（视图层）  
作用：展示数据给用户看
比如：网页、手机界面、报表
职责：专注展示，不管数据怎么来的

🔹 Controller（控制层）
作用：接收请求，调度指挥
比如：接收用户点击、调用业务、选择页面
职责：像个导演，协调Model和View
```

**💡 实际开发对照**

| MVC层 | **实际对应** | **举例** |
|-------|------------|---------|
| **Model** | Service层 + DAO层 | `UserService.findUser()` |
| **View** | JSP/HTML/JSON | `user.jsp` 或 JSON数据 |
| **Controller** | Controller类 | `UserController` |

### 1.3 为什么要用MVC


**✅ 好处清单**

```
职责分离：
前端人员专注View，后端人员专注Model
→ 团队协作更高效

易于维护：
修改页面不影响业务逻辑
修改业务不影响页面展示
→ 改一处不牵连其他

代码复用：
同一个业务逻辑，可以用不同View展示
→ 一套代码，多端使用
```

---

## 2. ⚙️ SpringMVC核心组件详解


### 2.1 前端控制器 DispatcherServlet


**🔸 它是什么**

DispatcherServlet就像是一个**总调度员**，所有请求都先到它这里，然后它负责分配任务。

```
形象比喻：
就像公司前台接待员
→ 客户来访先找前台
→ 前台判断找哪个部门
→ 引导客户去对应部门

SpringMVC中：
→ 所有请求先到DispatcherServlet
→ 它判断该找哪个Controller
→ 调用对应的Controller处理
```

**🔹 核心职责**

```
①接收请求：拦截所有符合规则的请求
②分发任务：找到对应的Controller
③处理结果：把结果转换成响应
④统一管理：异常处理、拦截器等
```

**📝 配置示例**

```xml
<!-- web.xml中配置 -->
<servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
    <!-- 加载SpringMVC配置文件 -->
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <url-pattern>/</url-pattern>  <!-- 拦截所有请求 -->
</servlet-mapping>
```

### 2.2 处理器映射器 HandlerMapping


**🔸 它是什么**

HandlerMapping是个**导航器**，它知道每个请求应该找哪个Controller处理。

```
形象理解：
像商场的导购图
→ 你想买衣服，导购图告诉你在3楼
→ 你想买电器,导购图告诉你在2楼

HandlerMapping：
→ 请求/user/list，它知道找UserController
→ 请求/order/add，它知道找OrderController
```

**🔹 工作原理**

```
请求URL：/user/findById?id=1

HandlerMapping做什么：
①解析URL路径：/user/findById
②查找映射关系：这个路径对应哪个Controller的哪个方法
③返回处理器：UserController.findById()方法
```

**💡 常见映射方式**

```java
// 方式1：类级别 + 方法级别
@Controller
@RequestMapping("/user")  // 类级别路径
public class UserController {
    
    @RequestMapping("/list")  // 方法级别路径
    public String list() {
        // 完整路径：/user/list
    }
}

// 方式2：精确匹配
@RequestMapping("/user/findById")  // 只匹配这个路径

// 方式3：通配符匹配  
@RequestMapping("/user/*")  // 匹配/user/开头的所有
```

### 2.3 处理器适配器 HandlerAdapter


**🔸 它是什么**

HandlerAdapter是个**翻译官**，它把DispatcherServlet的调用翻译成Controller能理解的方式。

```
为什么需要适配器：

问题：Controller的写法五花八门
→ 有的返回ModelAndView
→ 有的返回String
→ 有的返回JSON
→ 有的用@ResponseBody

DispatcherServlet不知道怎么调用这些不同写法

HandlerAdapter的作用：
→ 分析Controller的写法
→ 用正确的方式调用它
→ 把结果统一返回给DispatcherServlet
```

**🔹 适配过程**

```
DispatcherServlet：我要调用UserController.findById()

HandlerAdapter检查：
①这个方法有@ResponseBody吗？
  有 → 返回JSON，不需要视图
  
②这个方法返回什么类型？
  String → 视图名称
  ModelAndView → 包含数据和视图
  void → 不返回视图
  
③方法参数是什么？
  自动注入：请求参数、Session、Model等

根据检查结果，用对应方式调用
```

**📝 实际例子**

```java
// 例子1：返回视图名
@RequestMapping("/list")
public String list(Model model) {
    // HandlerAdapter知道：
    // ① 注入Model对象
    // ② 返回值是视图名
    return "user/list";
}

// 例子2：返回JSON
@RequestMapping("/getUser")
@ResponseBody
public User getUser() {
    // HandlerAdapter知道：
    // ① 有@ResponseBody注解
    // ② 把返回对象转成JSON
    return new User();
}
```

### 2.4 视图解析器 ViewResolver


**🔸 它是什么**

ViewResolver是个**地址翻译器**，它把简短的视图名翻译成完整的页面路径。

```
为什么需要视图解析器：

Controller返回："user/list"
实际页面位置：/WEB-INF/views/user/list.jsp

如果每次都写完整路径：
→ 太长，容易出错
→ 路径改变要改很多地方

有了ViewResolver：
→ 只写简短名称
→ 自动拼接前缀后缀
```

**🔹 配置示例**

```xml
<!-- SpringMVC配置文件 -->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <!-- 前缀：页面文件所在目录 -->
    <property name="prefix" value="/WEB-INF/views/"/>
    <!-- 后缀：页面文件扩展名 -->
    <property name="suffix" value=".jsp"/>
</bean>
```

**💡 解析过程**

```
Controller返回："user/list"

ViewResolver处理：
①拼接前缀：/WEB-INF/views/ + user/list
②拼接后缀：/WEB-INF/views/user/list + .jsp
③最终路径：/WEB-INF/views/user/list.jsp

转发到这个JSP页面
```

**🎯 多视图解析器**

```xml
<!-- JSP视图解析器 -->
<bean class="InternalResourceViewResolver">
    <property name="order" value="1"/>  <!-- 优先级 -->
    <property name="prefix" value="/WEB-INF/views/"/>
    <property name="suffix" value=".jsp"/>
</bean>

<!-- FreeMarker视图解析器 -->
<bean class="FreeMarkerViewResolver">
    <property name="order" value="0"/>  <!-- 优先级更高 -->
    <property name="suffix" value=".ftl"/>
</bean>

执行顺序：order值小的先执行
```

### 2.5 视图View渲染


**🔸 什么是View渲染**

View渲染就是**把数据填到页面模板里**，生成最终的HTML展示给用户。

```
理解渲染过程：

①Controller准备数据：
List<User> users = userService.findAll();
model.addAttribute("users", users);

②选择视图模板：
return "user/list";  // list.jsp页面

③View渲染：
把users数据填充到list.jsp中
<c:forEach items="${users}" var="user">
    ${user.name}
</c:forEach>

④生成HTML：
最终生成完整的HTML发给浏览器
```

**🔹 常见View类型**

| View类型 | **说明** | **使用场景** |
|---------|---------|------------|
| **JSP视图** | `InternalResourceView` | 传统Web页面 |
| **重定向视图** | `RedirectView` | 跳转到其他URL |
| **转发视图** | `ForwardView` | 服务器内部跳转 |
| **JSON视图** | `MappingJackson2JsonView` | 返回JSON数据 |

**📝 不同视图示例**

```java
// 1. JSP视图
@RequestMapping("/list")
public String list(Model model) {
    model.addAttribute("users", userList);
    return "user/list";  // 渲染user/list.jsp
}

// 2. 重定向（浏览器地址栏会变）
@RequestMapping("/delete")
public String delete() {
    // 删除后重定向到列表页
    return "redirect:/user/list";
}

// 3. 转发（浏览器地址栏不变）
@RequestMapping("/add")
public String add() {
    // 转发到其他Controller
    return "forward:/user/list";
}

// 4. JSON视图
@RequestMapping("/getUser")
@ResponseBody
public User getUser() {
    // 自动渲染成JSON
    return new User("张三", 20);
}
```

---

## 3. 🔄 请求处理完整流程


### 3.1 流程图示


```
浏览器                DispatcherServlet              SpringMVC组件
  |                          |                              |
  |--[1]发送请求------------>|                              |
  |   /user/list            |                              |
  |                          |                              |
  |                         |--[2]查找处理器--------------->|HandlerMapping
  |                         |   哪个Controller处理?         |
  |                         |<-[3]返回处理器---------------|
  |                         |   UserController.list()       |
  |                          |                              |
  |                         |--[4]调用处理器--------------->|HandlerAdapter
  |                         |   执行Controller方法          |
  |                         |<-[5]返回ModelAndView---------|
  |                         |   包含数据和视图名            |
  |                          |                              |
  |                         |--[6]解析视图名--------------->|ViewResolver
  |                         |   "user/list" → 完整路径      |
  |                         |<-[7]返回View对象-------------|
  |                         |   user/list.jsp              |
  |                          |                              |
  |                         |--[8]渲染视图----------------->|View
  |                         |   填充数据到JSP               |
  |                         |<-[9]返回HTML-----------------|
  |                          |                              |
  |<--[10]响应HTML----------|                              |
  |                          |                              |
```

### 3.2 详细执行步骤


**🔸 步骤详解**

```
第1步：用户发送请求
→ 浏览器访问：http://localhost:8080/user/list
→ 请求到达Tomcat服务器

第2步：DispatcherServlet拦截请求
→ web.xml配置的url-pattern="/"
→ 所有请求先到DispatcherServlet

第3步：查找处理器（HandlerMapping）
→ 根据URL路径：/user/list
→ 找到对应的Controller和方法
→ 返回：UserController.list()方法

第4步：调用处理器（HandlerAdapter）
→ 分析方法签名和注解
→ 准备参数（注入Model等）
→ 执行Controller方法
→ 获取返回值

第5步：处理返回值
→ 如果是String：视图名称
→ 如果是ModelAndView：包含数据和视图
→ 如果有@ResponseBody：直接返回数据

第6步：解析视图名（ViewResolver）
→ 视图名："user/list"
→ 拼接：/WEB-INF/views/user/list.jsp
→ 返回View对象

第7步：渲染视图（View）
→ 获取Model中的数据
→ 填充到JSP页面
→ 生成最终HTML

第8步：响应结果
→ 将HTML返回给浏览器
→ 浏览器解析HTML显示页面
```

### 3.3 核心对象传递


```
请求参数 → HttpServletRequest
        ↓
Controller方法参数（自动绑定）
        ↓
Model（存放返回数据）
        ↓
ModelAndView（数据+视图名）
        ↓
View（渲染后的HTML）
        ↓
HttpServletResponse（返回浏览器）
```

**📝 实际代码跟踪**

```java
// Controller代码
@RequestMapping("/list")
public String list(
    @RequestParam(required = false) String name,  // ← 第4步：参数绑定
    Model model) {                                 // ← 第4步：注入Model
    
    // 业务处理
    List<User> users = userService.findByName(name);
    
    // 存放数据
    model.addAttribute("users", users);  // ← 第5步：准备数据
    
    // 返回视图名
    return "user/list";  // ← 第5步：返回视图名
}

// JSP页面（user/list.jsp）
<c:forEach items="${users}" var="user">  ← 第7步：渲染数据
    <tr>
        <td>${user.id}</td>
        <td>${user.name}</td>
    </tr>
</c:forEach>
```

---

## 4. ⚙️ 配置文件详解


### 4.1 web.xml配置文件


**🔸 作用说明**

web.xml是**Web应用的总配置**，它告诉Tomcat服务器：
- 应用启动时要做什么
- 哪些Servlet要加载
- 请求怎么分配

```
理解web.xml：
就像公司的组织架构图
→ 定义有哪些部门（Servlet）
→ 每个部门负责什么（url-pattern）
→ 启动顺序是什么（load-on-startup）
```

**📝 完整配置**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         version="3.1">
    
    <!-- ====== 1. 配置Spring容器（父容器） ====== -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>
    
    <!-- Spring容器监听器：启动时加载Spring配置 -->
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
    
    <!-- ====== 2. 配置SpringMVC（子容器） ====== -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        
        <!-- SpringMVC配置文件位置 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>
        
        <!-- 启动顺序：1表示服务器启动时就加载 -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    
    <!-- URL映射：哪些请求交给SpringMVC -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>  <!-- 拦截所有请求 -->
    </servlet-mapping>
    
    <!-- ====== 3. 编码过滤器（解决中文乱码） ====== -->
    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>
            org.springframework.web.filter.CharacterEncodingFilter
        </filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    
</web-app>
```

**🔹 配置项解释**

```
① contextConfigLocation
→ 指定Spring配置文件位置
→ 通常配置Service、DAO层

② DispatcherServlet
→ SpringMVC的核心Servlet
→ 处理所有Web请求

③ url-pattern
→ "/" ：拦截所有请求（推荐）
→ "*.do"：只拦截.do结尾的请求
→ "/*"：拦截所有，包括JSP（不推荐）

④ load-on-startup
→ 数字越小，启动越早
→ 1表示服务器启动就加载
→ 不配置则第一次请求才加载
```

### 4.2 SpringMVC配置文件


**🔸 作用说明**

springmvc.xml是**SpringMVC的专属配置**，主要配置Web层的东西：
- 扫描Controller
- 配置视图解析器
- 静态资源处理
- 拦截器等

**📝 核心配置**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context">

    <!-- ====== 1. 扫描Controller包 ====== -->
    <context:component-scan base-package="com.example.controller"/>
    
    <!-- ====== 2. 开启注解驱动 ====== -->
    <mvc:annotation-driven/>
    <!-- 
    作用：
    ①自动注册HandlerMapping和HandlerAdapter
    ②支持@RequestMapping注解
    ③自动转换JSON
    -->
    
    <!-- ====== 3. 视图解析器 ====== -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
    
    <!-- ====== 4. 静态资源处理 ====== -->
    <mvc:resources mapping="/static/**" location="/static/"/>
    <!-- 
    mapping：浏览器访问路径
    location：实际文件位置
    /static/** 表示 /static/下所有文件
    -->
    
    <!-- ====== 5. 默认Servlet处理 ====== -->
    <mvc:default-servlet-handler/>
    <!-- 
    作用：没有Controller处理的请求，交给Tomcat默认Servlet
    用于：访问静态资源（图片、CSS、JS）
    -->
    
</beans>
```

**🔹 常用配置组合**

```xml
<!-- 组合1：基础配置（必须） -->
<context:component-scan base-package="com.example.controller"/>
<mvc:annotation-driven/>

<!-- 组合2：静态资源访问 -->
<mvc:resources mapping="/css/**" location="/static/css/"/>
<mvc:resources mapping="/js/**" location="/static/js/"/>
<mvc:resources mapping="/images/**" location="/static/images/"/>

<!-- 组合3：文件上传 -->
<bean id="multipartResolver" 
      class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="maxUploadSize" value="10485760"/>  <!-- 10MB -->
</bean>

<!-- 组合4：拦截器 -->
<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/**"/>
        <mvc:exclude-mapping path="/login"/>
        <bean class="com.example.interceptor.LoginInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>
```

---

## 5. 🏗️ 父子容器关系


### 5.1 什么是父子容器


**🔸 通俗理解**

想象一个**大公司的组织结构**：
```
总公司（父容器 - Spring容器）
├── 管理部门（Service、DAO）
├── 财务部门
└── 技术部门
    
分公司（子容器 - SpringMVC容器）
└── 业务部门（Controller）
```

**核心概念**：
- 子容器可以访问父容器的Bean
- 父容器不能访问子容器的Bean
- 各自管理各自的Bean

**🔹 容器关系图**

```
┌─────────────────────────────────────┐
│     Spring父容器                     │
│  （applicationContext.xml）          │
│                                      │
│  ┌──────────┐  ┌──────────┐         │
│  │ Service  │  │   DAO    │         │
│  └──────────┘  └──────────┘         │
│         ↑            ↑               │
└─────────|────────────|───────────────┘
          |            |
          可以访问      |
          |            |
┌─────────|────────────|───────────────┐
│         |            |                │
│  ┌──────────┐   需要注入             │
│  │Controller│                         │
│  └──────────┘                         │
│                                       │
│     SpringMVC子容器                   │
│   （springmvc.xml）                   │
└───────────────────────────────────────┘
```

### 5.2 为什么要父子容器


**🔸 设计目的**

```
职责分离：
父容器：管理业务层（Service、DAO）
子容器：管理表现层（Controller）
→ 各司其职，互不干扰

依赖方向：
Controller需要调用Service ✓
Service不应该调用Controller ✗
→ 单向依赖，符合设计原则

容器隔离：
Web层变化不影响业务层
可以独立测试Service层
→ 降低耦合
```

**💡 实际场景**

```java
// ❌ 错误：Service不应该知道Controller
@Service
public class UserService {
    @Autowired
    private UserController controller;  // 不应该依赖Controller
}

// ✅ 正确：Controller调用Service
@Controller
public class UserController {
    @Autowired
    private UserService userService;  // 可以注入Service
}
```

### 5.3 配置父子容器


**📝 父容器配置（applicationContext.xml）**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans">

    <!-- 扫描Service和DAO，排除Controller -->
    <context:component-scan base-package="com.example">
        <context:exclude-filter type="annotation" 
                expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    
    <!-- 数据源、事务等配置 -->
    <bean id="dataSource" class="..."/>
    <bean id="sqlSessionFactory" class="..."/>
    
</beans>
```

**📝 子容器配置（springmvc.xml）**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans">

    <!-- 只扫描Controller -->
    <context:component-scan base-package="com.example.controller"/>
    
    <!-- 视图解析器等Web配置 -->
    <bean class="...ViewResolver"/>
    
</beans>
```

**🔹 扫描规则对比**

| 配置文件 | **扫描内容** | **排除内容** |
|---------|------------|------------|
| **applicationContext.xml** | Service、DAO、Component | Controller |
| **springmvc.xml** | Controller | 其他都不扫 |

### 5.4 Bean的访问规则


**🔸 访问关系**

```
场景1：Controller注入Service（✅ 可以）
@Controller
public class UserController {
    @Autowired
    private UserService userService;  // 子容器找父容器
}

场景2：Service注入DAO（✅ 可以）  
@Service
public class UserService {
    @Autowired
    private UserDao userDao;  // 同一个父容器
}

场景3：Service注入Controller（❌ 不行）
@Service
public class UserService {
    @Autowired
    private UserController controller;  // 父容器找不到子容器
}
```

**💡 查找顺序**

```
Controller中注入Bean的查找顺序：

第1步：在SpringMVC子容器中找
→ 找到：直接使用
→ 找不到：继续第2步

第2步：到Spring父容器中找
→ 找到：使用父容器的Bean
→ 找不到：报错NoSuchBeanDefinitionException
```

### 5.5 常见问题


**⚠️ 问题1：Service被扫描两次**

```xml
<!-- 错误配置 -->
<!-- applicationContext.xml -->
<context:component-scan base-package="com.example"/>  ← 扫描全部

<!-- springmvc.xml -->
<context:component-scan base-package="com.example"/>  ← 又扫描全部

结果：Service被创建两次，事务失效！
```

**✅ 正确配置**

```xml
<!-- applicationContext.xml -->
<context:component-scan base-package="com.example">
    <!-- 排除Controller -->
    <context:exclude-filter type="annotation" 
            expression="org.springframework.stereotype.Controller"/>
</context:component-scan>

<!-- springmvc.xml -->
<context:component-scan base-package="com.example.controller"/>
```

**⚠️ 问题2：事务不生效**

```
原因：
Service在子容器中被扫描
事务配置在父容器
→ 父容器的事务无法代理子容器的Service

解决：
确保Service只在父容器中扫描
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 MVC模式：Model-View-Controller三层分离
🔸 DispatcherServlet：前端控制器，总调度
🔸 HandlerMapping：URL映射，找Controller
🔸 HandlerAdapter：执行适配，调Controller
🔸 ViewResolver：视图解析，拼路径
🔸 View渲染：数据填充，生成HTML
```

### 6.2 请求处理流程（重点记忆）


```
① 请求到达 DispatcherServlet
② HandlerMapping 查找处理器
③ HandlerAdapter 调用Controller
④ Controller 处理业务
⑤ 返回 ModelAndView
⑥ ViewResolver 解析视图
⑦ View 渲染数据
⑧ 响应给浏览器
```

### 6.3 配置文件要点


```
web.xml（Web应用配置）：
→ 配置DispatcherServlet
→ 加载Spring容器
→ 设置URL映射

springmvc.xml（SpringMVC配置）：
→ 扫描Controller
→ 配置视图解析器
→ 静态资源处理

applicationContext.xml（Spring配置）：
→ 扫描Service/DAO
→ 数据源和事务
```

### 6.4 父子容器关键点


```
父容器（Spring）：
→ 管理Service、DAO
→ 不能访问Controller

子容器（SpringMVC）：
→ 管理Controller
→ 可以访问Service、DAO

Bean查找规则：
→ 先找子容器
→ 再找父容器
→ 都没有就报错
```

### 6.5 实际开发建议


**✅ 最佳实践**

```
1. URL映射统一用"/"
   → <url-pattern>/</url-pattern>

2. 分开扫描包
   → 父容器扫Service/DAO
   → 子容器只扫Controller

3. 必开注解驱动
   → <mvc:annotation-driven/>

4. 静态资源要处理
   → <mvc:resources/> 或 <mvc:default-servlet-handler/>
```

**⚠️ 常见坑点**

```
1. Service被扫描两次
   → 检查扫描配置，要互斥

2. 事务不生效
   → Service要在父容器

3. 静态资源404
   → 配置静态资源处理

4. 中文乱码
   → 配置编码过滤器
```

### 6.6 核心记忆口诀


```
DispatcherServlet总调度，
HandlerMapping找处理器，
HandlerAdapter去执行，
Controller业务处理好。
ViewResolver解析视图，
View渲染数据呈现妙。
父子容器要分清，
Service、Controller莫搞混。
```