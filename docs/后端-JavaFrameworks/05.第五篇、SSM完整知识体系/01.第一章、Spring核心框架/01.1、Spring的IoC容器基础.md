---
title: 1、Spring的IoC容器基础
---
## 📚 目录

1. [IoC控制反转核心概念](#1-IoC控制反转核心概念)
2. [DI依赖注入原理详解](#2-DI依赖注入原理详解)
3. [Spring容器体系](#3-Spring容器体系)
4. [Bean的生命周期管理](#4-Bean的生命周期管理)
5. [依赖注入的三种方式](#5-依赖注入的三种方式)
6. [自动装配机制](#6-自动装配机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔄 IoC控制反转核心概念


### 1.1 什么是IoC？用人话说


> **IoC（Inversion of Control）控制反转**：简单说就是"不要你自己new对象了，我来帮你创建和管理"。

**🏠 生活化理解：租房的例子**

```
传统方式（自己控制）：
你要住房子 → 自己找房源 → 自己谈价格 → 自己签合同 → 自己装修
问题：太累了，什么都要自己操心

IoC方式（控制反转）：
你要住房子 → 告诉中介需求 → 中介帮你找 → 中介谈好价格 → 拎包入住
好处：你只管提需求，剩下的中介（Spring容器）帮你搞定
```

**💡 编程中的实际体现**

```
传统方式写代码：
public class UserService {
    // 自己new对象，自己管理
    private UserDao userDao = new UserDao();
    
    public void saveUser() {
        userDao.save();
    }
}
问题：UserService和UserDao耦合太紧，UserDao一变UserService也得改

IoC方式写代码：
public class UserService {
    // 不自己new，等着Spring给我注入
    private UserDao userDao;
    
    // Spring会自动把userDao对象给你
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
好处：UserService不用关心UserDao怎么来的，Spring帮你搞定
```

### 1.2 为什么要用IoC？解决什么问题？


**🎯 IoC解决的核心问题**

| **传统方式的痛点** | **IoC的解决方案** | **实际收益** |
|------------------|------------------|-------------|
| 对象之间耦合严重 | 对象创建交给容器 | 代码更灵活，易于替换 |
| 依赖关系难管理 | 容器统一管理依赖 | 依赖清晰，便于维护 |
| 测试困难 | 可以注入模拟对象 | 单元测试更简单 |
| 对象生命周期难控制 | 容器管理生命周期 | 资源管理更高效 |

**📊 控制权的转移**

```
传统开发模式：
开发者 ──控制──> 对象创建
开发者 ──控制──> 对象依赖
开发者 ──控制──> 对象销毁

IoC容器模式：
开发者 ──配置──> Spring容器 ──控制──> 对象创建
开发者 ──声明──> Spring容器 ──控制──> 对象依赖
开发者 ──不管──> Spring容器 ──控制──> 对象销毁

"控制"从开发者手中"反转"到了Spring容器手中
```

### 1.3 IoC容器到底是什么？


**🗂️ 容器的本质：对象的大管家**

```
可以把IoC容器想象成一个超级仓库：

┌─────────────────────────────────────────────┐
│            Spring IoC 容器仓库              │
├─────────────────────────────────────────────┤
│  货架A：UserService对象（已创建好）         │
│  货架B：UserDao对象（已创建好）             │
│  货架C：OrderService对象（已创建好）        │
│  货架D：各种配置信息                        │
├─────────────────────────────────────────────┤
│  功能：                                     │
│  1. 根据配置创建对象（工厂功能）            │
│  2. 管理对象之间的依赖关系（组装功能）      │
│  3. 控制对象的生命周期（管理功能）          │
└─────────────────────────────────────────────┘
```

**容器做的三件大事**：
1. **对象创建**：你要什么对象，我帮你new出来
2. **依赖注入**：对象需要依赖，我帮你装配进去
3. **生命周期管理**：对象什么时候生，什么时候死，我说了算

---

## 2. 💉 DI依赖注入原理详解


### 2.1 什么是依赖注入？


> **DI（Dependency Injection）依赖注入**：就是IoC的具体实现方式，容器把对象需要的依赖"注入"进去。

**🔌 插座和插头的比喻**

```
你的电脑（对象）需要电源（依赖）：

传统方式：
电脑自己发电 → 笨重、不灵活

依赖注入方式：
电脑设计一个插口（接口） → 等着别人插电源线（注入依赖）
→ 无论是220V还是110V，只要符合接口标准都能用
```

**🎯 依赖注入的核心思想**

```java
// A依赖B的关系：
public class A {
    private B b;  // A需要B才能工作
}

传统方式（主动获取）：
A自己创建B：b = new B();
问题：A和B紧紧绑在一起

依赖注入方式（被动接收）：
外部把B传给A：a.setB(b);
优势：A不关心B怎么来的，解耦了
```

### 2.2 依赖注入的工作原理


**⚙️ 注入过程详解**

```
依赖注入的完整流程：

第一步：开发者配置
├─ 告诉Spring：我有UserService类，需要UserDao
└─ 配置方式：XML配置 或 注解配置

第二步：Spring解析配置
├─ 读取配置信息
├─ 分析依赖关系：谁依赖谁
└─ 构建依赖关系图

第三步：创建对象
├─ 先创建被依赖的对象（UserDao）
├─ 再创建依赖它的对象（UserService）
└─ 创建顺序自动排好

第四步：注入依赖
├─ 把UserDao对象注入到UserService中
├─ 可以通过构造器、setter等方式
└─ 完成对象组装

第五步：对象可用
└─ UserService拿到了UserDao，可以正常工作了
```

**📋 配置示例对比**

```xml
<!-- XML配置方式（传统） -->
<bean id="userDao" class="com.example.UserDao"/>

<bean id="userService" class="com.example.UserService">
    <!-- 通过属性注入userDao -->
    <property name="userDao" ref="userDao"/>
</bean>
```

```java
// 注解配置方式（现代）
@Component
public class UserDao {
    // UserDao的实现
}

@Component
public class UserService {
    @Autowired  // 自动注入
    private UserDao userDao;
}
```

### 2.3 DI和IoC的关系


**🔗 两者关系图**

```
IoC（控制反转）
    │
    ├─ 是一种设计思想/原则
    │  "对象的控制权要反转"
    │
    └─ 实现方式 ↓
           │
           DI（依赖注入）
           │
           ├─ 是IoC的具体技术实现
           │  "通过注入方式提供依赖"
           │
           └─ 三种注入方式 ↓
                  │
                  ├─ 构造器注入
                  ├─ Setter注入
                  └─ 接口注入
```

> **记忆要点**：IoC是思想，DI是实现。就像"节能"是思想，"LED灯"是实现方式。

---

## 3. 🏛️ Spring容器体系


### 3.1 BeanFactory：Spring容器的老祖宗


**🔧 BeanFactory基础容器**

> **BeanFactory**：Spring最基础的IoC容器接口，提供最基本的对象管理功能。

```
BeanFactory的特点：

┌─────────────────────────────────┐
│        BeanFactory              │
├─────────────────────────────────┤
│ 功能：                          │
│ ✓ 管理Bean（获取、创建）        │
│ ✓ 延迟加载（用时才创建）        │
│ ✓ 基础的依赖注入                │
├─────────────────────────────────┤
│ 特点：                          │
│ • 轻量级，占用内存少            │
│ • 功能简单                      │
│ • 适合资源受限环境              │
└─────────────────────────────────┘
```

**核心方法**：
- `getBean(String name)`：根据名称获取Bean
- `containsBean(String name)`：判断是否包含某个Bean
- `isSingleton(String name)`：判断Bean是否单例

### 3.2 ApplicationContext：功能强大的高级容器


**🚀 ApplicationContext企业级容器**

> **ApplicationContext**：继承BeanFactory，提供更多企业级功能的高级容器。

```
ApplicationContext功能对比：

BeanFactory（基础版）        ApplicationContext（豪华版）
     │                              │
     ├─ Bean管理               ────→├─ Bean管理（继承来的）
     │                              ├─ 国际化支持
     │                              ├─ 事件发布机制
     │                              ├─ 资源加载
     │                              ├─ AOP集成
     │                              └─ 自动装配
```

**🎯 三种常用实现类**

| **实现类** | **配置来源** | **使用场景** | **特点说明** |
|-----------|-------------|-------------|-------------|
| `ClassPathXmlApplicationContext` | XML文件（类路径） | 传统项目 | 从classpath读取配置 |
| `FileSystemXmlApplicationContext` | XML文件（文件系统） | 指定路径配置 | 从磁盘绝对路径读取 |
| `AnnotationConfigApplicationContext` | Java配置类 | 现代项目 | 基于注解的配置 |

**🔍 使用示例**

```java
// 方式1：基于XML配置
ApplicationContext context = 
    new ClassPathXmlApplicationContext("applicationContext.xml");
UserService userService = context.getBean("userService", UserService.class);

// 方式2：基于注解配置（推荐）
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);
UserService userService = context.getBean(UserService.class);
```

### 3.3 容器启动过程（重要但不复杂）


**📋 容器启动的五个阶段**

```
容器启动流程：

阶段1：加载配置
  ├─ 读取XML或扫描注解
  └─ 解析成BeanDefinition（Bean的定义信息）

阶段2：注册BeanDefinition
  ├─ 把Bean定义信息存入容器
  └─ 建立Bean名称和定义的映射关系

阶段3：实例化Bean
  ├─ 根据定义创建Bean实例
  └─ 调用构造方法

阶段4：属性赋值
  ├─ 依赖注入
  └─ 给Bean的属性赋值

阶段5：初始化Bean
  ├─ 执行初始化方法
  └─ Bean准备就绪，可以使用
```

**⚡ 关键区别：何时创建Bean**

- **BeanFactory**：延迟加载，调用`getBean()`时才创建
- **ApplicationContext**：饿汉式加载，容器启动时就创建所有Bean

> **新手提示**：ApplicationContext启动慢一点，但运行时获取Bean更快，企业开发基本都用它。

---

## 4. 🌱 Bean的生命周期管理


### 4.1 什么是Bean？


> **Bean**：在Spring容器中管理的对象就叫Bean，说白了就是Spring帮你创建的Java对象。

```
普通对象 vs Spring Bean：

普通对象：
MyClass obj = new MyClass();  // 你自己new的
obj.method();                  // 你自己管理
obj = null;                    // 你自己销毁

Spring Bean：
@Component                     // 告诉Spring这是个Bean
public class MyClass { }       
                              // Spring帮你创建
MyClass bean = context.getBean(MyClass.class);
                              // Spring帮你管理
                              // Spring负责销毁
```

### 4.2 Bean定义与注册


**📝 Bean定义的两种方式**

```xml
<!-- 方式1：XML配置 -->
<bean id="userService" 
      class="com.example.UserService"
      scope="singleton"
      init-method="init"
      destroy-method="cleanup">
    <property name="userDao" ref="userDao"/>
</bean>
```

```java
// 方式2：注解配置（推荐）
@Component  // 或@Service、@Repository、@Controller
@Scope("singleton")  // 可选，默认单例
public class UserService {
    
    @Autowired
    private UserDao userDao;
    
    @PostConstruct  // 初始化方法
    public void init() {
        System.out.println("UserService初始化");
    }
    
    @PreDestroy  // 销毁方法
    public void cleanup() {
        System.out.println("UserService销毁");
    }
}
```

**🎯 常用注解说明**

| **注解** | **含义** | **使用位置** | **作用说明** |
|---------|---------|-------------|-------------|
| `@Component` | 通用组件 | 类上 | 标记为Spring管理的Bean |
| `@Service` | 业务层组件 | 类上 | 语义化的@Component |
| `@Repository` | 数据层组件 | 类上 | 语义化的@Component |
| `@Controller` | 控制层组件 | 类上 | 语义化的@Component |
| `@Scope` | 作用域 | 类上 | 定义Bean的作用范围 |

### 4.3 Bean的作用域


**🔄 五种作用域详解**

| **作用域** | **含义** | **创建时机** | **使用场景** |
|-----------|---------|-------------|-------------|
| `singleton` | 单例（默认） | 容器启动时 | 无状态Bean，如Service |
| `prototype` | 多例 | 每次获取时 | 有状态Bean，如POJO |
| `request` | 请求级 | 每次HTTP请求 | Web应用，请求数据 |
| `session` | 会话级 | 每个Session | Web应用，用户会话 |
| `application` | 应用级 | ServletContext生命周期 | 全局共享数据 |

```java
// 单例模式（默认）
@Component
@Scope("singleton")  // 可省略
public class SingletonBean {
    // 整个应用只有一个实例
}

// 多例模式
@Component
@Scope("prototype")
public class PrototypeBean {
    // 每次getBean都创建新实例
}
```

> **新手易错点**：单例Bean是线程不安全的，不要在单例Bean中使用成员变量存储请求相关的数据。

---

## 5. 💉 依赖注入的三种方式


### 5.1 构造器注入（推荐⭐⭐⭐⭐⭐）


**🏗️ 通过构造方法注入依赖**

```java
@Service
public class UserService {
    
    private final UserDao userDao;  // 注意：final修饰
    private final EmailService emailService;
    
    // 构造器注入
    @Autowired  // Spring 4.3+可省略
    public UserService(UserDao userDao, EmailService emailService) {
        this.userDao = userDao;
        this.emailService = emailService;
    }
}
```

**✅ 优点**：
- 依赖不可变（final修饰）
- 必须依赖不能为null
- 完全初始化后才能使用
- 更好的可测试性

**❌ 缺点**：
- 参数多时构造器复杂
- 循环依赖无法解决

> **最佳实践**：强制依赖用构造器注入，可选依赖用setter注入。

### 5.2 Setter方法注入


**🔧 通过setter方法注入依赖**

```java
@Service
public class OrderService {
    
    private OrderDao orderDao;
    private NotificationService notificationService;  // 可选依赖
    
    // Setter注入
    @Autowired
    public void setOrderDao(OrderDao orderDao) {
        this.orderDao = orderDao;
    }
    
    @Autowired(required = false)  // 可选依赖
    public void setNotificationService(NotificationService service) {
        this.notificationService = service;
    }
}
```

**✅ 优点**：
- 灵活，可选依赖
- 可以在运行时重新注入
- 解决循环依赖

**❌ 缺点**：
- 依赖可能为null
- 对象可能处于部分初始化状态

### 5.3 字段注入（不推荐）


**⚡ 直接在字段上注入**

```java
@Service
public class ProductService {
    
    @Autowired  // 直接在字段上
    private ProductDao productDao;
    
    @Autowired
    private CacheService cacheService;
}
```

**✅ 优点**：
- 代码简洁

**❌ 缺点**：
- 无法使用final
- 难以单元测试
- 隐藏依赖关系
- IDE会警告

> **新手提示**：虽然字段注入最简单，但不推荐。学习阶段可以用，实际项目建议用构造器注入。

### 5.4 接口注入（了解即可）


**🔌 通过接口方法注入**

```java
// 定义注入接口
public interface UserDaoAware {
    void setUserDao(UserDao userDao);
}

// 实现注入接口
@Service
public class UserService implements UserDaoAware {
    
    private UserDao userDao;
    
    @Override
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

> **注意**：Spring本身很少用接口注入，了解概念即可，实际开发基本不用。

---

## 6. 🤖 自动装配机制


### 6.1 什么是自动装配？


> **自动装配（Autowiring）**：Spring自动分析依赖关系，把需要的Bean注入进去，不用手动配置。

**🎯 自动装配的本质**

```
手动装配（传统）：
<bean id="userService" class="UserService">
    <property name="userDao" ref="userDao"/>  ← 手动指定
</bean>

自动装配（现代）：
@Service
public class UserService {
    @Autowired  ← Spring自动找到合适的Bean注入
    private UserDao userDao;
}
```

### 6.2 @Autowired注解详解


**⚙️ @Autowired的工作原理**

```
@Autowired装配流程：

第1步：扫描依赖
  └─ 发现UserService需要UserDao

第2步：查找候选Bean
  └─ 在容器中找UserDao类型的Bean

第3步：确定注入对象
  ├─ 只有1个：直接注入
  ├─ 有多个：按名称匹配
  └─ 没有：报错（除非required=false）

第4步：完成注入
  └─ 把找到的Bean注入到UserService
```

**🔍 处理多个候选Bean**

```java
// 情况1：容器中有多个UserDao的实现
@Repository
public class MysqlUserDao implements UserDao { }

@Repository
public class OracleUserDao implements UserDao { }

// 解决方案1：使用@Qualifier指定
@Service
public class UserService {
    @Autowired
    @Qualifier("mysqlUserDao")  // 指定具体的Bean名称
    private UserDao userDao;
}

// 解决方案2：使用@Primary标记主要实现
@Repository
@Primary  // 标记为主要实现
public class MysqlUserDao implements UserDao { }

@Service
public class UserService {
    @Autowired  // 自动注入Primary的Bean
    private UserDao userDao;
}
```

### 6.3 自动装配的模式


**📋 XML时代的装配模式（了解）**

| **模式** | **匹配方式** | **说明** |
|---------|-------------|---------|
| `no` | 不自动装配 | 手动配置依赖 |
| `byName` | 按属性名 | 属性名=Bean的id |
| `byType` | 按属性类型 | 属性类型=Bean的class |
| `constructor` | 按构造器参数类型 | 构造器参数类型匹配 |

**现代开发基本用注解**：
- `@Autowired`：按类型装配
- `@Resource`：按名称装配（Java标准）
- `@Inject`：按类型装配（Java标准）

### 6.4 注解对比


**🔄 三个注入注解的区别**

```java
// @Autowired - Spring的注解（最常用）
@Autowired
@Qualifier("mysqlUserDao")
private UserDao userDao;

// @Resource - Java标准注解
@Resource(name = "mysqlUserDao")  // 默认按名称
private UserDao userDao;

// @Inject - Java标准注解
@Inject
@Named("mysqlUserDao")
private UserDao userDao;
```

| **注解** | **来源** | **装配方式** | **推荐度** |
|---------|---------|-------------|-----------|
| `@Autowired` | Spring | 先按类型，再按名称 | ⭐⭐⭐⭐⭐ |
| `@Resource` | Java | 先按名称，再按类型 | ⭐⭐⭐⭐ |
| `@Inject` | Java | 按类型 | ⭐⭐⭐ |

> **新手建议**：Spring项目就用@Autowired，简单直接。

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 IoC控制反转：对象创建控制权从开发者转移到Spring容器
🔸 DI依赖注入：IoC的实现方式，容器自动注入依赖
🔸 BeanFactory：基础容器，延迟加载
🔸 ApplicationContext：高级容器，功能丰富，立即加载
🔸 Bean生命周期：创建 → 依赖注入 → 初始化 → 使用 → 销毁
🔸 三种注入方式：构造器注入（推荐）、setter注入、字段注入
🔸 自动装配：@Autowired按类型自动注入依赖
```

### 7.2 关键理解要点


**🔹 IoC和DI的关系**
```
IoC是设计思想："把控制权交出去"
DI是技术实现："通过注入提供依赖"
关系：DI是IoC的一种实现方式
```

**🔹 容器的选择**
```
开发阶段：用ApplicationContext，功能全面
生产环境：用ApplicationContext，性能稳定
资源受限：用BeanFactory，节省内存（很少见）
```

**🔹 注入方式的选择**
```
必须依赖 → 构造器注入
可选依赖 → setter注入  
快速开发 → 字段注入（但不推荐生产环境用）
```

### 7.3 实际应用场景


**💼 企业开发实践**
- **分层架构**：Controller → Service → Dao，层层依赖注入
- **解耦设计**：面向接口编程，实现类可随时替换
- **单元测试**：通过注入Mock对象，方便测试
- **配置管理**：统一在容器中管理Bean的配置

**🎯 开发建议**
- 优先使用注解配置，简洁清晰
- 构造器注入保证依赖不可变
- 合理使用作用域，避免内存泄漏
- 充分利用自动装配，减少配置代码

### 7.4 新手常见问题


**❓ 循环依赖怎么办？**
```
问题：A依赖B，B又依赖A
解决：
1. 重新设计，避免循环依赖
2. 使用setter注入代替构造器注入
3. 使用@Lazy延迟加载
```

**❓ Bean找不到怎么办？**
```
排查步骤：
1. 检查是否添加了@Component等注解
2. 检查包扫描路径是否正确
3. 检查Bean的名称是否匹配
4. 检查是否有多个候选Bean冲突
```

**❓ 什么时候用单例，什么时候用多例？**
```
单例（singleton）：
- 无状态的Service、Dao
- 工具类、配置类
- 占用资源大的对象

多例（prototype）：
- 有状态的Bean
- 每次使用需要独立实例的对象
```

**核心记忆口诀**：
```
IoC反转控制权，对象创建我不管
DI注入来实现，依赖自动送上前
容器分为两大类，BeanFactory是祖先
ApplicationContext功能全，企业开发它当先
Bean生命有五步，创建注入初始化
三种注入各有长，构造器注入是首选
自动装配真方便，@Autowired最常见
```