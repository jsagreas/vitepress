---
title: 6、AOP切面编程详解
---
## 📚 目录

1. [AOP是什么](#1-AOP是什么)
2. [AOP核心概念理解](#2-AOP核心概念理解)
3. [通知类型详解](#3-通知类型详解)
4. [切入点表达式](#4-切入点表达式)
5. [AOP实现原理](#5-AOP实现原理)
6. [实战应用场景](#6-实战应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 AOP是什么


### 1.1 从生活场景理解AOP


🌰 **生活类比**：想象你是一家餐厅的老板

```
普通做法（没有AOP）：
- 厨师A做菜：洗手 → 做菜 → 记录菜单 → 收拾厨房
- 厨师B做菜：洗手 → 做菜 → 记录菜单 → 收拾厨房
- 厨师C做菜：洗手 → 做菜 → 记录菜单 → 收拾厨房

问题：每个厨师都要重复做"洗手、记录、收拾"这些事

使用AOP的做法：
- 厨师只管做菜（核心业务）
- 安排专人负责：做菜前提醒洗手、做菜后记录菜单、最后收拾厨房
- 这个"专人"就像AOP切面，统一处理重复的事情
```

### 1.2 AOP的本质含义


**AOP = Aspect Oriented Programming（面向切面编程）**

通俗理解：
- **面向切面** = 把重复的公共功能抽出来，统一管理
- **编程** = 用代码实现这个"统一管理"的思想

🎯 **核心目的**：让你专注写核心业务代码，那些重复的、辅助性的功能（日志、权限、事务）交给AOP处理

### 1.3 为什么需要AOP


**传统方式的问题**：

```java
// 每个方法都要写这些重复代码
public void 转账() {
    开启事务;           // 重复代码
    记录日志;           // 重复代码
    检查权限;           // 重复代码
    
    执行转账业务;       // 真正的核心代码
    
    提交事务;           // 重复代码
    记录日志;           // 重复代码
}

public void 查询余额() {
    开启事务;           // 又重复了
    记录日志;           // 又重复了
    检查权限;           // 又重复了
    
    执行查询业务;       // 核心代码
    
    提交事务;           // 又重复了
    记录日志;           // 又重复了
}
```

**使用AOP后**：

```java
// 你只需要写核心业务
public void 转账() {
    执行转账业务;  // 只写核心代码
}

public void 查询余额() {
    执行查询业务;  // 只写核心代码
}

// AOP切面自动帮你加上那些重复的功能
```

---

## 2. 🧩 AOP核心概念理解


### 2.1 切面 Aspect


**是什么**：切面就是那个"统一管理重复功能的类"

🌰 **类比理解**：
- 就像学校的门卫大叔，负责检查每个进出学校的人
- 切面就是这个"门卫"，负责在代码执行前后做检查和处理

**代码表现**：

```java
@Aspect  // 这个注解告诉Spring：这是一个切面类
@Component
public class LogAspect {
    // 这个类就是"切面"
    // 专门负责处理日志记录的功能
}
```

### 2.2 连接点 JoinPoint


**是什么**：程序执行过程中能够插入切面的点

🌰 **通俗理解**：
- 就像地铁线路上的每一站，都可以上下乘客
- 连接点就是程序执行中的每个"站点"，都可以插入额外功能

**实际含义**：
- 方法调用时 → 可以插入
- 方法执行时 → 可以插入
- 异常抛出时 → 可以插入

```java
public class UserService {
    
    public void login() {     // ← 这是一个连接点
        // 登录逻辑
    }
    
    public void register() {  // ← 这也是一个连接点
        // 注册逻辑
    }
}

// 每个方法执行的时候，都是一个"连接点"
// 你可以在这些点上插入日志、权限检查等功能
```

### 2.3 切入点 Pointcut


**是什么**：指定在哪些连接点上应用切面

🌰 **类比理解**：
- 地铁有100个站（连接点），但你只想在"天安门站"和"王府井站"下车
- 切入点就是你选择的这几个站

**实际作用**：从众多连接点中，选择你真正需要的那些

```java
@Aspect
@Component
public class LogAspect {
    
    // 切入点表达式：指定在哪些方法上生效
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayer() {}
    
    // 意思：service包下的所有类的所有方法，都是我的切入点
}
```

**区别理解**：
- **连接点**：所有可以插入的地方（理论上的所有点）
- **切入点**：你实际选择插入的地方（你真正用的点）

### 2.4 通知 Advice


**是什么**：切面在切入点上要执行的具体操作

🌰 **类比理解**：
- 门卫要做的事情：检查证件、登记信息、测量体温
- 通知就是这些"具体要做的事情"

**5种通知类型**：

```
方法执行流程：

    ↓
[前置通知] Before          → 方法执行前做的事
    ↓
[环绕通知-前半段]          → 方法执行前后都能控制
    ↓
  执行方法
    ↓
[环绕通知-后半段]
    ↓
[返回通知] AfterReturning  → 方法成功返回后做的事
[异常通知] AfterThrowing   → 方法抛异常后做的事
    ↓
[后置通知] After           → 无论如何最后都做的事
```

---

## 3. 🔔 通知类型详解


### 3.1 前置通知 @Before


**什么时候执行**：目标方法执行之前

**典型应用**：权限检查、参数验证、记录开始日志

```java
@Aspect
@Component
public class SecurityAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void checkPermission(JoinPoint joinPoint) {
        // 获取方法名
        String methodName = joinPoint.getSignature().getName();
        System.out.println("开始执行方法：" + methodName);
        
        // 可以在这里检查用户权限
        // 如果权限不足，可以抛出异常阻止方法执行
    }
}
```

🌰 **生活例子**：进门前门卫检查你的证件

### 3.2 后置通知 @After


**什么时候执行**：目标方法执行之后（无论成功还是失败）

**典型应用**：资源释放、记录结束日志

```java
@Aspect
@Component
public class LogAspect {
    
    @After("execution(* com.example.service.*.*(..))")
    public void afterMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("方法执行结束：" + methodName);
        
        // 无论方法成功还是失败，这里都会执行
        // 类似于 finally 代码块
    }
}
```

🌰 **生活例子**：出门后门卫记录你的离开时间

### 3.3 返回通知 @AfterReturning


**什么时候执行**：目标方法成功返回结果之后

**典型应用**：记录返回值、数据处理、成功日志

```java
@Aspect
@Component
public class ResultAspect {
    
    @AfterReturning(
        pointcut = "execution(* com.example.service.*.*(..))",
        returning = "result"  // 接收返回值
    )
    public void afterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + " 执行成功，返回值：" + result);
        
        // 可以对返回值进行处理或记录
    }
}
```

🌰 **生活例子**：考试成功通过后，老师记录你的成绩

### 3.4 异常通知 @AfterThrowing


**什么时候执行**：目标方法抛出异常之后

**典型应用**：异常日志记录、异常处理、发送告警

```java
@Aspect
@Component
public class ExceptionAspect {
    
    @AfterThrowing(
        pointcut = "execution(* com.example.service.*.*(..))",
        throwing = "ex"  // 接收异常对象
    )
    public void afterThrowing(JoinPoint joinPoint, Exception ex) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + " 执行失败，异常：" + ex.getMessage());
        
        // 可以记录异常日志、发送告警邮件等
    }
}
```

🌰 **生活例子**：考试不及格后，老师记录你的错误原因

### 3.5 环绕通知 @Around（最强大）


**什么时候执行**：包围整个目标方法，完全控制方法执行

**典型应用**：性能监控、事务控制、缓存处理

```java
@Aspect
@Component
public class PerformanceAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        String methodName = pjp.getSignature().getName();
        
        // 方法执行前
        long startTime = System.currentTimeMillis();
        System.out.println("开始执行：" + methodName);
        
        Object result = null;
        try {
            // 执行目标方法（重要：必须调用这个）
            result = pjp.proceed();
            
            // 方法执行后（成功的情况）
            long endTime = System.currentTimeMillis();
            System.out.println(methodName + " 执行成功，耗时：" + (endTime - startTime) + "ms");
            
        } catch (Exception e) {
            // 方法执行后（异常的情况）
            System.out.println(methodName + " 执行失败：" + e.getMessage());
            throw e;  // 继续抛出异常
        }
        
        return result;  // 返回结果
    }
}
```

🌰 **生活例子**：全程陪同你考试，从开始到结束全程监控

**通知类型对比**：

| 通知类型 | **执行时机** | **能否阻止方法执行** | **能否修改返回值** | **典型用途** |
|---------|------------|------------------|-----------------|-------------|
| 🔸 **@Before** | `方法执行前` | `能（抛异常）` | `不能` | `权限检查、参数验证` |
| 🔸 **@After** | `方法执行后(无论成败)` | `不能` | `不能` | `资源释放、清理工作` |
| 🔸 **@AfterReturning** | `方法成功返回后` | `不能` | `不能` | `记录返回值、统计` |
| 🔸 **@AfterThrowing** | `方法抛异常后` | `不能` | `不能` | `异常日志、告警` |
| 🔸 **@Around** | `方法执行前后` | `能` | `能` | `性能监控、事务控制` |

---

## 4. 🎯 切入点表达式


### 4.1 切入点表达式语法


**基本格式**：

```
execution(修饰符? 返回类型 包名.类名.方法名(参数) 异常?)

?号表示可选项
*号表示通配符
..表示任意多个
```

### 4.2 常用表达式示例


**① 匹配所有方法**：

```java
@Pointcut("execution(* com.example.service.*.*(..))")
```

**解释**：
- 第一个`*`：任意返回类型
- `com.example.service`：包名
- 第二个`*`：包下的任意类
- 第三个`*`：类中的任意方法
- `(..)`：任意参数

**② 匹配指定类的所有方法**：

```java
@Pointcut("execution(* com.example.service.UserService.*(..))")
```

**解释**：只匹配 UserService 类中的所有方法

**③ 匹配指定方法名**：

```java
@Pointcut("execution(* com.example.service.*.save*(..))")
```

**解释**：匹配所有以 save 开头的方法（如 saveUser、saveOrder）

**④ 匹配特定参数的方法**：

```java
@Pointcut("execution(* com.example.service.*.*(String))")
```

**解释**：匹配只有一个 String 参数的方法

**⑤ 匹配返回类型**：

```java
@Pointcut("execution(String com.example.service.*.*(..))")
```

**解释**：匹配返回值为 String 的方法

### 4.3 切入点表达式组合


**使用 && （并且）**：

```java
@Pointcut("execution(* com.example.service.*.*(..)) && args(userId)")
public void serviceMethodWithUserId(Long userId) {}
```

**解释**：service包的方法 并且 参数包含userId

**使用 || （或者）**：

```java
@Pointcut("execution(* com.example.service.UserService.*(..)) || execution(* com.example.service.OrderService.*(..))")
```

**解释**：UserService 或 OrderService 中的方法

### 4.4 @Pointcut 注解定义


**为什么要定义切入点**：避免重复写表达式

```java
@Aspect
@Component
public class LogAspect {
    
    // 定义一个切入点，可以重复使用
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    // 多个通知使用同一个切入点
    @Before("serviceMethods()")
    public void before() {
        System.out.println("前置通知");
    }
    
    @After("serviceMethods()")
    public void after() {
        System.out.println("后置通知");
    }
}
```

**🎯 切入点表达式速查**：

```
// 常用通配符
*          → 匹配任意字符
..         → 匹配任意多个（包、参数）
+          → 匹配子类

// 示例对照
execution(public * *(..))               → 所有public方法
execution(* set*(..))                   → 所有set开头的方法
execution(* com.example.service.*.*(..))→ service包下所有方法
execution(* com.example.service..*.*(..))→ service包及子包所有方法
```

---

## 5. ⚙️ AOP实现原理


### 5.1 代理模式基础


**AOP的实现本质**：通过代理对象来增强目标对象

🌰 **生活类比**：
- 你是明星（目标对象），有经纪人（代理对象）
- 粉丝找你签名，实际是找经纪人
- 经纪人帮你做筛选、安排时间，最后才让你签名

```
没有代理：
粉丝 ──直接找──▶ 明星

有代理：
粉丝 ──找──▶ 经纪人 ──安排后──▶ 明星
              (做各种处理)
```

### 5.2 JDK动态代理


**使用条件**：目标对象必须实现接口

**工作原理**：

```
原始对象（实现接口）
      ↓
Spring创建代理对象（也实现同样的接口）
      ↓
调用方法时，实际调用代理对象的方法
      ↓
代理对象执行切面逻辑 + 调用原始对象方法
```

**代码示例**：

```java
// 接口
public interface UserService {
    void save(String name);
}

// 实现类
@Service
public class UserServiceImpl implements UserService {
    @Override
    public void save(String name) {
        System.out.println("保存用户：" + name);
    }
}

// Spring自动创建的代理对象（简化理解）
public class UserServiceProxy implements UserService {
    private UserService target;  // 原始对象
    
    @Override
    public void save(String name) {
        // 前置通知
        System.out.println("开始执行");
        
        // 调用原始方法
        target.save(name);
        
        // 后置通知
        System.out.println("执行结束");
    }
}
```

### 5.3 CGLIB代理


**使用条件**：目标对象没有实现接口

**工作原理**：通过继承目标类来创建代理

```
原始类（没有接口）
      ↓
CGLIB创建子类作为代理
      ↓
重写父类方法，加入切面逻辑
```

**代码理解**：

```java
// 没有接口的类
@Service
public class OrderService {
    public void create(String orderId) {
        System.out.println("创建订单：" + orderId);
    }
}

// CGLIB创建的代理类（简化理解）
public class OrderService$Proxy extends OrderService {
    
    @Override
    public void create(String orderId) {
        // 前置通知
        System.out.println("开始执行");
        
        // 调用父类方法
        super.create(orderId);
        
        // 后置通知
        System.out.println("执行结束");
    }
}
```

### 5.4 两种代理方式对比


| 特性 | **JDK动态代理** | **CGLIB代理** |
|-----|----------------|--------------|
| 🔸 **实现方式** | `基于接口` | `基于继承` |
| 🔸 **使用条件** | `必须有接口` | `不需要接口` |
| 🔸 **性能** | `略快` | `略慢` |
| 🔸 **限制** | `只能代理接口方法` | `不能代理final方法` |
| 🔸 **Spring默认** | `有接口用JDK` | `无接口用CGLIB` |

**Spring如何选择**：

```
判断目标对象
    ↓
有实现接口？
   ├─ 是 → 使用JDK动态代理
   └─ 否 → 使用CGLIB代理
```

---

## 6. 💼 实战应用场景


### 6.1 统一日志记录


**业务需求**：记录所有service层方法的执行日志

```java
@Aspect
@Component
public class LogAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object logMethod(ProceedingJoinPoint pjp) throws Throwable {
        // 获取类名和方法名
        String className = pjp.getTarget().getClass().getSimpleName();
        String methodName = pjp.getSignature().getName();
        
        // 获取参数
        Object[] args = pjp.getArgs();
        
        // 执行前日志
        System.out.println("【日志】" + className + "." + methodName + " 开始执行，参数：" + Arrays.toString(args));
        
        long startTime = System.currentTimeMillis();
        Object result = pjp.proceed();
        long endTime = System.currentTimeMillis();
        
        // 执行后日志
        System.out.println("【日志】" + className + "." + methodName + " 执行完成，耗时：" + (endTime - startTime) + "ms");
        
        return result;
    }
}
```

### 6.2 权限控制


**业务需求**：某些方法需要管理员权限才能执行

```java
@Aspect
@Component
public class PermissionAspect {
    
    @Before("@annotation(com.example.annotation.RequireAdmin)")
    public void checkAdmin(JoinPoint joinPoint) {
        // 获取当前用户（实际项目从session或token获取）
        String currentUser = getCurrentUser();
        
        if (!"admin".equals(currentUser)) {
            throw new RuntimeException("权限不足，需要管理员权限");
        }
        
        System.out.println("权限检查通过");
    }
    
    private String getCurrentUser() {
        // 实际项目中从登录信息获取
        return "admin";
    }
}

// 自定义注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireAdmin {
}

// 使用
@Service
public class UserService {
    
    @RequireAdmin  // 需要管理员权限
    public void deleteUser(Long userId) {
        System.out.println("删除用户：" + userId);
    }
}
```

### 6.3 异常统一处理


**业务需求**：统一捕获和处理service层异常

```java
@Aspect
@Component
public class ExceptionHandlerAspect {
    
    @AfterThrowing(
        pointcut = "execution(* com.example.service.*.*(..))",
        throwing = "ex"
    )
    public void handleException(JoinPoint joinPoint, Exception ex) {
        String methodName = joinPoint.getSignature().getName();
        
        // 记录异常日志
        System.err.println("【异常】方法 " + methodName + " 发生异常：" + ex.getMessage());
        
        // 可以发送告警邮件、钉钉消息等
        sendAlert(methodName, ex);
    }
    
    private void sendAlert(String methodName, Exception ex) {
        // 发送告警通知
        System.out.println("发送告警：" + methodName + " 异常");
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 核心概念记忆


🧠 **记忆口诀**：
```
切面管重复，连接点是位，
切入选需要，通知定时机。
代理做增强，表达选方法，
前后环绕转，异常返回清。
```

### 7.2 概念对应关系


```
现实世界                  AOP概念
─────────────────────────────────────
门卫大叔        ────▶    切面 Aspect
所有进出的人    ────▶    连接点 JoinPoint
需要检查的人    ────▶    切入点 Pointcut
检查的动作      ────▶    通知 Advice
门卫的分身      ────▶    代理对象 Proxy
```

### 7.3 通知类型选择


**🔹 需要事前检查** → 用 @Before
```
场景：权限验证、参数校验
```

**🔹 需要记录结果** → 用 @AfterReturning
```
场景：成功日志、数据统计
```

**🔹 需要处理异常** → 用 @AfterThrowing
```
场景：异常日志、告警通知
```

**🔹 需要清理资源** → 用 @After
```
场景：关闭连接、释放资源
```

**🔹 需要完全控制** → 用 @Around
```
场景：性能监控、事务管理、缓存
```

### 7.4 学习检查清单


**📈 自我检测**：
- [ ] 能说清楚AOP是用来解决什么问题的
- [ ] 能区分切面、切入点、连接点的区别
- [ ] 能说出5种通知的执行时机
- [ ] 会写基本的切入点表达式
- [ ] 理解JDK代理和CGLIB代理的区别
- [ ] 能举出3个AOP的实际应用场景

### 7.5 常见问题答疑


**❓ AOP和拦截器有什么区别**？
```
AOP：更底层，基于代理，可以拦截所有方法
拦截器：基于Web，只能拦截Controller请求
```

**❓ 为什么要用@Pointcut定义切入点**？
```
避免重复：一个表达式可以被多个通知使用
便于维护：修改表达式只需改一处
```

**❓ @Around通知必须调用proceed()吗**？
```
是的！不调用proceed()，目标方法就不会执行
可以在proceed()前后加入自己的逻辑
```

**核心理解**：
- AOP就是把重复的代码抽出来统一管理
- 通过代理对象来增强原有功能
- 核心思想是"分离关注点"，让代码更清爽