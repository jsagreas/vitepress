---
title: 4、Spring多种配置方式
---
## 📚 目录

1. [配置方式概述](#1-配置方式概述)
2. [XML配置文件方式](#2-XML配置文件方式)
3. [注解驱动配置](#3-注解驱动配置)
4. [Java配置类方式](#4-Java配置类方式)
5. [混合配置策略](#5-混合配置策略)
6. [核心配置注解详解](#6-核心配置注解详解)
7. [实战应用指南](#7-实战应用指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 配置方式概述


### 1.1 什么是Spring配置


**通俗理解**：Spring配置就像是给Spring容器写"使用说明书"，告诉它：
- 需要管理哪些对象（Bean）
- 这些对象之间是什么关系
- 对象的属性值是什么

```
类比生活场景：
开一家餐厅需要配置：
├─ 需要哪些员工（厨师、服务员）
├─ 员工之间的协作关系  
├─ 每个员工的工作内容
└─ 餐厅的营业参数

Spring配置也是同样道理！
```

### 1.2 配置方式的演进历程


**🕐 发展时间线**：

```
2004年 Spring 1.0          2009年 Spring 3.0         2014年 Spring 4.0         现在
   ↓                          ↓                        ↓                       ↓
XML配置为主      →      XML + 注解混用      →      Java配置类兴起      →     注解+Java配置
笨重但规范              开始便捷化                 类型安全                  主流方式
```

**📊 三种配置方式对比**：

| 配置方式 | **出现时期** | **优势** | **劣势** | **适用场景** |
|---------|------------|---------|---------|------------|
| **XML配置** | Spring 1.x | 集中管理、清晰直观 | 繁琐、不灵活 | 大型项目、配置复杂 |
| **注解配置** | Spring 2.5+ | 简洁、开发快 | 分散、不够集中 | 快速开发、小项目 |
| **Java配置** | Spring 3.0+ | 类型安全、重构友好 | 学习成本高 | 现代项目、推荐方式 |

---

## 2. 📄 XML配置文件方式


### 2.1 XML配置的本质


**💡 核心思想**：用XML文件描述Bean的定义和依赖关系

**基本结构**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="...">
    
    <!-- 这里定义Bean -->
    <bean id="唯一标识" class="完整类名">
        <!-- 这里配置属性 -->
    </bean>
    
</beans>
```

### 2.2 XML配置实战示例


**场景说明**：配置一个用户服务

```
需求：创建UserService对象，它依赖UserDao
传统写法：new UserService(new UserDao())
Spring写法：通过XML配置自动创建和注入
```

**XML配置文件**（applicationContext.xml）：

```xml
<!-- 1. 先定义UserDao -->
<bean id="userDao" class="com.example.dao.UserDaoImpl"/>

<!-- 2. 再定义UserService，并注入UserDao -->
<bean id="userService" class="com.example.service.UserServiceImpl">
    <!-- 通过构造器注入 -->
    <constructor-arg ref="userDao"/>
    
    <!-- 或者通过setter注入 -->
    <!-- <property name="userDao" ref="userDao"/> -->
</bean>
```

**🔍 配置详解**：
- `id`：Bean的唯一标识，相当于变量名
- `class`：Bean的完整类名，Spring通过反射创建对象
- `ref`：引用其他Bean，实现依赖注入

### 2.3 XML配置的优缺点


**✅ 优点**：
- **集中管理**：所有配置在一个文件，一目了然
- **解耦彻底**：配置与代码完全分离
- **修改方便**：改配置不需要重新编译代码

**❌ 缺点**：
- **繁琐冗长**：配置代码量大，重复性高
- **类型不安全**：字符串配置，编译期无法检查错误
- **重构不友好**：类名改变需要同步修改XML

---

## 3. 🏷️ 注解驱动配置


### 3.1 注解配置的核心理念


**💡 什么是注解配置**：
直接在Java类上使用注解标记，告诉Spring这个类需要被管理

**通俗类比**：
```
XML配置：在外部文件写"使用说明书"
注解配置：在类本身贴"标签"说明用途
```

### 3.2 核心注解说明


**🔸 @Component - 通用组件标记**

```java
// 作用：告诉Spring"我是一个Bean，请管理我"
@Component
public class UserService {
    // Spring会自动创建这个类的对象
}
```

**💡 理解要点**：
- `@Component`是最基础的注解，相当于XML中的`<bean>`
- Spring会自动扫描并创建标记了此注解的类的对象

**🔸 衍生注解 - 语义化标记**

```
@Component（通用组件）
    ↓
    ├─ @Controller（控制层）  → 处理Web请求
    ├─ @Service（服务层）     → 业务逻辑处理  
    └─ @Repository（持久层）  → 数据访问

功能完全相同，只是名字不同，增强代码可读性！
```

**实际使用**：

```java
@Controller  // 标记为控制器
public class UserController { }

@Service    // 标记为服务层
public class UserService { }

@Repository // 标记为数据访问层
public class UserDao { }
```

**🔸 @Autowired - 自动装配依赖**

```java
@Service
public class UserService {
    
    // 方式1：字段注入（最常用，简洁）
    @Autowired
    private UserDao userDao;
    
    // 方式2：构造器注入（推荐，不可变）
    private final UserDao userDao;
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
    
    // 方式3：Setter注入（可选依赖）
    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

**💡 自动装配原理**：
1. Spring扫描到`@Autowired`注解
2. 去容器中找匹配的Bean（按类型查找）
3. 自动注入到标记的位置

### 3.3 启用注解扫描


**⚠️ 重要**：使用注解前必须告诉Spring扫描哪些包

**方式1：XML中启用**

```xml
<!-- 扫描com.example包及其子包下的所有注解 -->
<context:component-scan base-package="com.example"/>
```

**方式2：Java配置启用**

```java
@Configuration
@ComponentScan("com.example")  // 扫描指定包
public class AppConfig {
}
```

---

## 4. ☕ Java配置类方式


### 4.1 Java配置的核心概念


**💡 什么是Java配置类**：
用纯Java代码替代XML配置，通过方法返回Bean对象

**对比理解**：
```
XML配置：用标签定义Bean
注解配置：用注解标记Bean  
Java配置：用方法创建Bean（最灵活！）
```

### 4.2 @Configuration - 配置类标记


**🔸 基本用法**：

```java
// @Configuration告诉Spring：这是一个配置类
@Configuration
public class AppConfig {
    // 这里定义Bean创建方法
}
```

**💡 理解要点**：
- `@Configuration`让普通类变成配置类
- 配置类相当于XML配置文件
- 一个项目可以有多个配置类

### 4.3 @Bean - 定义Bean方法


**🔸 核心用法**：

```java
@Configuration
public class AppConfig {
    
    // @Bean方法：方法名=Bean的id，返回值=Bean对象
    @Bean
    public UserDao userDao() {
        return new UserDaoImpl();
    }
    
    @Bean
    public UserService userService() {
        UserServiceImpl service = new UserServiceImpl();
        service.setUserDao(userDao());  // 手动注入依赖
        return service;
    }
}
```

**🔍 方法解析**：
- **方法名**：默认作为Bean的id（可通过`@Bean("自定义名称")`修改）
- **返回值类型**：Bean的类型
- **方法体**：创建和配置Bean的逻辑

**💡 依赖注入方式**：

```java
// 方式1：直接调用方法（Spring会处理单例）
@Bean
public UserService userService() {
    return new UserServiceImpl(userDao());
}

// 方式2：通过参数注入（推荐，更清晰）
@Bean
public UserService userService(UserDao userDao) {
    return new UserServiceImpl(userDao);
}
```

### 4.4 Java配置的优势


**✅ 为什么推荐Java配置**：

| 优势 | **说明** | **实际价值** |
|-----|---------|------------|
| 🔒 **类型安全** | 编译期检查错误 | 减少运行时错误 |
| 🔄 **重构友好** | IDE自动重构支持 | 维护成本低 |
| 🎯 **灵活性高** | 可以写复杂逻辑 | 满足复杂配置需求 |
| 📖 **易于理解** | 纯Java代码 | 学习曲线平缓 |

---

## 5. 🔀 混合配置策略


### 5.1 为什么需要混合配置


**实际场景**：
- 老项目用XML配置，新功能想用注解
- 第三方库配置用Java Config，自己代码用注解
- 不同模块用不同配置方式

**💡 核心思想**：各配置方式可以互相引用和组合！

### 5.2 混合配置的实现方式


**🔸 场景1：在Java配置中引入XML**

```java
@Configuration
@ImportResource("classpath:beans.xml")  // 导入XML配置
public class AppConfig {
    
    @Bean
    public UserService userService() {
        // 可以使用XML中定义的Bean
        return new UserServiceImpl();
    }
}
```

**🔸 场景2：在XML中引入Java配置**

```xml
<!-- 将Java配置类作为Bean注册 -->
<bean class="com.example.config.AppConfig"/>

<!-- 或者扫描配置类所在包 -->
<context:component-scan base-package="com.example.config"/>
```

**🔸 场景3：多个Java配置类组合**

```java
@Configuration
@Import({DataSourceConfig.class, SecurityConfig.class})
public class AppConfig {
    // 导入其他配置类
}
```

### 5.3 混合配置最佳实践


**📋 推荐策略**：

```
项目结构建议：
├─ 基础设施配置（数据源、缓存）   → Java Config
├─ 第三方库配置                  → Java Config  
├─ 业务Bean配置                 → 注解
└─ 遗留系统配置                  → XML（逐步迁移）
```

**⚡ 实战经验**：
- **新项目**：优先使用注解 + Java配置
- **老项目迁移**：先用`@ImportResource`引入XML，逐步改造
- **模块化**：每个模块独立配置类，主配置类通过`@Import`组合

---

## 6. 🔧 核心配置注解详解


### 6.1 @ComponentScan - 组件扫描


**💡 作用**：告诉Spring扫描哪些包来查找Bean

**🔸 基础用法**：

```java
@Configuration
@ComponentScan("com.example")  // 扫描单个包
public class AppConfig { }

// 扫描多个包
@ComponentScan({"com.example.service", "com.example.dao"})
public class AppConfig { }
```

**🔸 高级配置**：

```java
@ComponentScan(
    basePackages = "com.example",
    // 包含哪些：只扫描@Service和@Repository
    includeFilters = @Filter(
        type = FilterType.ANNOTATION,
        classes = {Service.class, Repository.class}
    ),
    // 排除哪些：不扫描@Controller
    excludeFilters = @Filter(
        type = FilterType.ANNOTATION,
        classes = Controller.class
    )
)
```

**💡 理解要点**：
- 不配置`@ComponentScan`，注解不会生效
- 默认扫描配置类所在包及子包
- 可以精确控制扫描规则

### 6.2 @Import - 导入配置


**💡 作用**：导入其他配置类，实现配置模块化

**🔸 导入配置类**：

```java
// 数据库配置类
@Configuration
public class DatabaseConfig {
    @Bean
    public DataSource dataSource() { }
}

// 主配置类
@Configuration
@Import(DatabaseConfig.class)  // 导入数据库配置
public class AppConfig { }
```

**🔸 导入多个配置**：

```java
@Import({
    DatabaseConfig.class,
    RedisConfig.class,
    SecurityConfig.class
})
public class AppConfig { }
```

### 6.3 @Profile - 环境配置


**💡 作用**：不同环境使用不同配置（开发、测试、生产）

**🔸 定义环境配置**：

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Profile("dev")  // 开发环境
    public DataSource devDataSource() {
        // 使用H2内存数据库
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
    
    @Bean
    @Profile("prod")  // 生产环境
    public DataSource prodDataSource() {
        // 使用MySQL数据库
        DruidDataSource ds = new DruidDataSource();
        ds.setUrl("jdbc:mysql://...");
        return ds;
    }
}
```

**🔸 激活环境**：

```java
// 方式1：启动时指定
-Dspring.profiles.active=dev

// 方式2：代码中设置
AnnotationConfigApplicationContext ctx = 
    new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles("dev");
ctx.register(AppConfig.class);
ctx.refresh();
```

**💡 实际价值**：
- 一套代码，多环境部署
- 开发用轻量数据库，生产用真实数据库
- 避免配置文件频繁修改

### 6.4 @Conditional - 条件装配


**💡 作用**：根据条件决定是否创建Bean

**🔸 基本使用**：

```java
// 自定义条件：Windows系统才创建Bean
public class WindowsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, 
                          AnnotatedTypeMetadata metadata) {
        return context.getEnvironment()
            .getProperty("os.name")
            .contains("Windows");
    }
}

@Configuration
public class AppConfig {
    
    @Bean
    @Conditional(WindowsCondition.class)  // 满足条件才创建
    public MyService windowsService() {
        return new WindowsServiceImpl();
    }
}
```

**🔸 常用条件注解**：

```java
@ConditionalOnClass(DataSource.class)  // 存在某个类
@ConditionalOnMissingBean(DataSource.class)  // 不存在某个Bean
@ConditionalOnProperty(name="app.feature", havingValue="true")  // 配置值满足
```

### 6.5 @PropertySource - 属性源


**💡 作用**：加载外部properties配置文件

**🔸 基本用法**：

```java
@Configuration
@PropertySource("classpath:app.properties")
public class AppConfig {
    
    @Value("${db.url}")  // 读取配置值
    private String dbUrl;
    
    @Bean
    public DataSource dataSource(
        @Value("${db.url}") String url,
        @Value("${db.username}") String username) {
        // 使用配置值创建Bean
    }
}
```

**app.properties内容**：
```properties
db.url=jdbc:mysql://localhost:3306/test
db.username=root
db.password=123456
```

### 6.6 @Value - 属性注入


**💡 作用**：将配置值注入到Bean属性中

**🔸 注入方式**：

```java
@Component
public class AppConfig {
    
    // 1. 注入配置文件的值
    @Value("${app.name}")
    private String appName;
    
    // 2. 注入默认值（配置不存在时使用）
    @Value("${app.timeout:30}")
    private int timeout;  // 默认30
    
    // 3. 注入表达式结果
    @Value("#{systemProperties['user.home']}")
    private String userHome;
    
    // 4. 注入静态值
    @Value("1024")
    private int bufferSize;
}
```

**💡 SpEL表达式支持**：

```java
// 调用其他Bean的方法
@Value("#{userService.getUserCount()}")
private int userCount;

// 数学运算
@Value("#{100 * 1024}")
private int maxSize;

// 三元运算
@Value("#{app.debug ? 'DEBUG' : 'INFO'}")
private String logLevel;
```

---

## 7. 🚀 实战应用指南


### 7.1 实战场景1：Web项目配置


**需求**：配置一个典型的Web应用

```
Web应用分层：
Controller层 → Service层 → Dao层 → 数据库
    ↓           ↓          ↓         ↓
  @Controller  @Service  @Repository  DataSource
```

**配置方案**：

```java
// 1. 数据源配置类
@Configuration
@PropertySource("classpath:db.properties")
public class DatabaseConfig {
    
    @Bean
    public DataSource dataSource(
        @Value("${db.url}") String url,
        @Value("${db.username}") String username,
        @Value("${db.password}") String password) {
        
        DruidDataSource ds = new DruidDataSource();
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}

// 2. 主配置类
@Configuration
@ComponentScan("com.example")  // 扫描业务Bean
@Import(DatabaseConfig.class)   // 导入数据库配置
public class AppConfig {
}

// 3. 业务层使用注解
@Controller
public class UserController {
    @Autowired
    private UserService userService;
}

@Service
public class UserService {
    @Autowired
    private UserDao userDao;
}

@Repository
public class UserDao {
    @Autowired
    private DataSource dataSource;
}
```

### 7.2 实战场景2：多环境配置


**需求**：开发、测试、生产环境使用不同配置

**🔸 配置结构**：

```
配置文件：
├─ application.properties          # 公共配置
├─ application-dev.properties      # 开发环境
├─ application-test.properties     # 测试环境  
└─ application-prod.properties     # 生产环境
```

**🔸 Java配置**：

```java
@Configuration
public class MultiEnvConfig {
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        // 开发环境：H2内存数据库
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript("classpath:schema.sql")
            .build();
    }
    
    @Bean
    @Profile("test")
    public DataSource testDataSource() {
        // 测试环境：MySQL测试库
        DruidDataSource ds = new DruidDataSource();
        ds.setUrl("jdbc:mysql://test-db:3306/test");
        return ds;
    }
    
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        // 生产环境：MySQL生产库 + 连接池优化
        DruidDataSource ds = new DruidDataSource();
        ds.setUrl("jdbc:mysql://prod-db:3306/prod");
        ds.setInitialSize(10);
        ds.setMaxActive(100);
        return ds;
    }
}
```

**🔸 启动配置**：

```bash
# 开发环境启动
java -jar app.jar --spring.profiles.active=dev

# 生产环境启动
java -jar app.jar --spring.profiles.active=prod
```

### 7.3 配置方式选择指南


**📋 决策树**：

```
需要配置的场景
    ↓
是自己写的业务类吗？
    ├─ 是 → 使用注解（@Service/@Repository）
    └─ 否 → 是第三方库吗？
            ├─ 是 → 使用@Bean方法（Java Config）
            └─ 否 → 是遗留XML配置吗？
                    ├─ 是 → @ImportResource引入
                    └─ 否 → 推荐Java Config
```

**⚡ 实战建议**：

| 场景 | **推荐方式** | **理由** |
|-----|------------|---------|
| 业务Bean | 注解（@Component系列） | 简洁快速 |
| 第三方库 | Java Config（@Bean） | 灵活可控 |
| 配置参数 | @PropertySource + @Value | 外部化配置 |
| 多环境 | @Profile | 环境隔离 |
| 复杂逻辑 | Java Config | 编程式配置 |
| 遗留项目 | 混合配置 | 平滑迁移 |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 三种配置方式对比**：

```
XML配置（传统）
  优点：集中管理、配置清晰
  缺点：繁琐、不灵活
  场景：大型项目、复杂配置
    ↓
注解配置（便捷）
  优点：简洁、开发快
  缺点：分散、不够直观
  场景：快速开发、业务Bean
    ↓
Java配置（现代）
  优点：类型安全、重构友好、灵活
  缺点：学习成本稍高
  场景：推荐方式、新项目首选
```

### 8.2 核心注解速查


| 注解 | **作用** | **使用场景** |
|-----|---------|------------|
| `@Configuration` | 声明配置类 | 替代XML配置文件 |
| `@ComponentScan` | 组件扫描 | 启用注解扫描 |
| `@Bean` | 定义Bean | 创建第三方类对象 |
| `@Import` | 导入配置 | 模块化配置 |
| `@Profile` | 环境配置 | 多环境支持 |
| `@Conditional` | 条件装配 | 按条件创建Bean |
| `@PropertySource` | 加载配置文件 | 外部化配置 |
| `@Value` | 属性注入 | 注入配置值 |

### 8.3 学习要点梳理


**🎯 理解层次**：

```
基础层：
  ✅ 理解Spring配置的本质（告诉容器如何管理Bean）
  ✅ 掌握三种配置方式的使用

进阶层：
  ✅ 理解各配置方式的优缺点和适用场景
  ✅ 掌握混合配置策略

高级层：
  ✅ 掌握条件装配、环境配置等高级特性
  ✅ 能根据项目需求选择最佳配置方案
```

### 8.4 实战记忆口诀


```
配置方式三兄弟，各有优势要牢记
XML配置最传统，集中管理配置清
注解配置最便捷，贴在类上就生效
Java配置最灵活，类型安全易重构

@Configuration配置类，@Bean方法定义Bean
@ComponentScan要扫描，@Import组合配置全
@Profile分环境配，@Value注入属性值
混合配置灵活用，按需选择效率高
```

### 8.5 下一步学习建议


**📚 学习路径**：

```
当前：Spring配置方式 ✅
  ↓
下一步：Spring IoC容器
  ├─ 容器启动流程
  ├─ Bean生命周期
  └─ 依赖注入原理
  ↓
再进阶：Spring AOP
  ├─ 切面编程概念
  ├─ 动态代理原理
  └─ 事务管理
```

**🔥 学习重点**：
- 理解每种配置方式的**本质**和**使用场景**
- 多动手**实践**，在项目中应用
- 关注**新特性**，Spring Boot已成主流
- 掌握**混合配置**，应对复杂项目

---

> 💡 **学习提示**：配置只是手段，理解Spring容器的工作原理才是核心。建议结合实际项目练习，从简单配置开始，逐步掌握高级特性！