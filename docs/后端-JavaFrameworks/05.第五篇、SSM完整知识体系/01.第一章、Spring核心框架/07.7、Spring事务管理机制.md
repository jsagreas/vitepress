---
title: 7、Spring事务管理机制
---
## 📚 目录

1. [事务基本概念](#1-事务基本概念)
2. [Spring事务管理方式](#2-Spring事务管理方式)
3. [声明式事务核心注解](#3-声明式事务核心注解)
4. [事务传播行为详解](#4-事务传播行为详解)
5. [事务隔离级别详解](#5-事务隔离级别详解)
6. [事务其他配置](#6-事务其他配置)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💡 事务基本概念


### 1.1 什么是事务


**通俗理解**：事务就像是"一件完整的事情"，要么全部做完，要么全部不做。

```
现实例子：银行转账
张三给李四转账1000元，需要两个步骤：
步骤1：从张三账户扣除1000元
步骤2：给李四账户增加1000元

如果步骤1成功，步骤2失败 → 钱凭空消失了！
这就需要事务：两步要么都成功，要么都失败回滚
```

**数据库事务定义**：一组数据库操作，作为一个整体执行，要么全部成功，要么全部失败。

### 1.2 事务的四大特性（ACID）


| 特性 | 英文 | 通俗解释 | 实际意义 |
|------|------|----------|----------|
| **原子性** | `Atomicity` | 要么全做，要么全不做 | 转账时，扣钱和加钱必须同时成功 |
| **一致性** | `Consistency` | 数据前后保持合理状态 | 转账前后，总金额不变 |
| **隔离性** | `Isolation` | 多个事务互不干扰 | 你转账时，别人看不到中间状态 |
| **持久性** | `Durability` | 提交后永久保存 | 转账成功后，断电也不会丢失 |

### 1.3 为什么需要事务管理


**没有事务的问题**：
```java
// 危险操作：没有事务保护
public void transfer(String from, String to, int money) {
    accountDao.deduct(from, money);  // 扣钱成功
    // 如果这里抛出异常，钱就凭空消失了！
    int result = 1 / 0;  // 模拟异常
    accountDao.add(to, money);       // 加钱失败
}
```

**有事务的保护**：
```java
// 安全操作：有事务保护
@Transactional
public void transfer(String from, String to, int money) {
    accountDao.deduct(from, money);  // 扣钱
    int result = 1 / 0;              // 异常发生
    accountDao.add(to, money);       // 这行不会执行
    // 事务自动回滚，扣的钱会退回！
}
```

> 💡 **核心理解**：事务就是给一组操作加上"保险"，确保要么全成功，要么全失败回到原点。

---

## 2. 🔧 Spring事务管理方式


Spring提供了两种事务管理方式，就像开车有"手动挡"和"自动挡"。

### 2.1 编程式事务管理（手动挡）


**什么是编程式事务**：自己写代码控制事务的开启、提交、回滚。

```java
@Service
public class UserService {
    
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    // 手动控制事务
    public void saveUser(User user) {
        transactionTemplate.execute(status -> {
            try {
                userDao.save(user);
                // 其他操作...
                return true;
            } catch (Exception e) {
                status.setRollbackOnly();  // 手动回滚
                return false;
            }
        });
    }
}
```

**特点分析**：
- ✅ **灵活度高**：可以精确控制事务范围
- ❌ **代码侵入**：业务代码和事务代码混在一起
- ❌ **维护困难**：事务逻辑重复，难以统一管理

> ⚠️ **实际应用**：编程式事务现在很少用，除非有特别复杂的事务控制需求。

### 2.2 声明式事务管理（自动挡）⭐


**什么是声明式事务**：用注解或配置告诉Spring哪些方法需要事务，Spring自动管理。

```java
@Service
public class UserService {
    
    // 只需要加一个注解，事务自动管理！
    @Transactional
    public void saveUser(User user) {
        userDao.save(user);
        // 如果这里抛异常，自动回滚
        // 如果正常结束，自动提交
    }
}
```

**工作原理图示**：
```
调用saveUser()方法
       ↓
Spring代理拦截
       ↓
开启事务 → 执行方法 → 成功？ → 提交事务
                         ↓
                      失败 → 回滚事务
```

**优势对比**：
- ✅ **代码简洁**：一个注解搞定
- ✅ **易于维护**：事务配置集中管理
- ✅ **非侵入性**：业务代码纯净
- ✅ **推荐使用**：99%的场景都用这种方式

> 🎯 **实际开发**：声明式事务是主流，掌握`@Transactional`注解是重点！

---

## 3. 📝 声明式事务核心注解


### 3.1 @Transactional注解详解


**基本用法**：
```java
// 可以加在类上：整个类的所有public方法都有事务
@Transactional
@Service
public class OrderService {
    
    public void createOrder() { }
    public void updateOrder() { }
}

// 也可以加在方法上：只给特定方法加事务
@Service
public class UserService {
    
    @Transactional
    public void saveUser(User user) { }
    
    // 这个方法没有事务
    public User getUser(Long id) { }
}
```

### 3.2 @Transactional注解属性


**常用属性一览**：

| 属性 | 作用 | 默认值 | 使用场景 |
|------|------|--------|----------|
| `propagation` | 传播行为 | REQUIRED | 控制方法间事务如何传递 |
| `isolation` | 隔离级别 | DEFAULT | 控制并发事务的影响 |
| `timeout` | 超时时间 | -1(不限) | 防止长时间占用资源 |
| `readOnly` | 只读事务 | false | 查询操作性能优化 |
| `rollbackFor` | 回滚异常 | RuntimeException | 指定哪些异常回滚 |

**属性使用示例**：
```java
@Transactional(
    propagation = Propagation.REQUIRED,      // 传播行为
    isolation = Isolation.READ_COMMITTED,    // 隔离级别
    timeout = 30,                            // 30秒超时
    readOnly = false,                        // 可读写
    rollbackFor = Exception.class            // 所有异常都回滚
)
public void complexOperation() {
    // 业务代码
}
```

### 3.3 注解配置要点


**配置开启步骤**：

1️⃣ **添加依赖**（Spring Boot自动配置）
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

2️⃣ **启用事务**（Spring Boot默认已开启）
```java
@SpringBootApplication
@EnableTransactionManagement  // 开启事务支持（Boot可省略）
public class Application { }
```

3️⃣ **使用注解**
```java
@Transactional  // 直接使用即可
public void businessMethod() { }
```

> 💡 **提示**：Spring Boot项目中，配置数据源后，事务功能自动可用，直接用`@Transactional`即可。

---

## 4. 🔄 事务传播行为详解


### 4.1 什么是事务传播行为


**通俗理解**：当一个有事务的方法，调用另一个有事务的方法时，这两个事务怎么配合？

```
场景：方法A调用方法B
methodA() {             ← 这个方法有事务
    // 做一些事
    methodB();          ← 这个方法也有事务
    // 继续做事
}

问题：B是用A的事务？还是新开一个事务？还是不用事务？
答案：由传播行为决定！
```

### 4.2 七种传播行为对比


**快速记忆图示**：
```
REQUIRED        → 没事务就新建，有事务就加入 ⭐最常用
REQUIRES_NEW    → 总是新建事务，暂停外层事务
NESTED          → 嵌套事务，外层回滚影响内层
SUPPORTS        → 有事务就用，没有就算了
NOT_SUPPORTED   → 不用事务，有事务就暂停
MANDATORY       → 必须有事务，否则报错
NEVER           → 不能有事务，有就报错
```

### 4.3 REQUIRED传播行为 ⭐


**定义**：如果当前存在事务，就加入该事务；如果没有事务，就新建一个事务。

**使用场景**：默认值，99%的情况都用这个。

```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // 操作1
    methodB();  // B也是REQUIRED
    // 操作2
}

@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
    // 操作3
}
```

**执行流程图**：
```
情况1：单独调用methodA
开启事务T1 → 操作1 → 调用methodB(加入T1) → 操作3 → 操作2 → 提交T1
全部成功或全部回滚

情况2：单独调用methodB  
开启事务T2 → 操作3 → 提交T2
```

**关键理解**：
- 多个REQUIRED方法在同一个事务中
- 任何一个操作失败，全部回滚
- 就像大家在一条船上，一起成功或一起失败

> 🎯 **实际应用**：订单系统中，创建订单、扣库存、扣余额，要么全成功，要么全回滚。

### 4.4 REQUIRES_NEW传播行为


**定义**：总是新建一个事务，如果当前存在事务，就把当前事务暂停。

```java
@Transactional
public void methodA() {
    // 操作1（事务T1）
    methodB();  // B是REQUIRES_NEW
    // 操作2（事务T1）
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // 操作3（新事务T2）
}
```

**执行流程图**：
```
开启事务T1 → 操作1 → 暂停T1 → 开启新事务T2 → 操作3 → 提交T2 → 恢复T1 → 操作2 → 提交T1
```

**关键特点**：
- B的事务独立于A，各自提交/回滚
- B提交后，A回滚不影响B
- A回滚时，B已经成功保存

**实际场景**：
```java
// 转账业务
@Transactional
public void transfer(String from, String to, int money) {
    accountDao.deduct(from, money);
    accountDao.add(to, money);
    
    // 记录日志，无论转账成功失败，都要记录
    logService.saveLog(log);  // 这个方法用REQUIRES_NEW
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveLog(Log log) {
    logDao.save(log);  // 独立事务，一定会保存
}
```

> 💡 **使用场景**：日志记录、消息发送等，需要独立提交的操作。

### 4.5 NESTED嵌套事务


**定义**：如果当前存在事务，就在当前事务中创建一个嵌套事务（保存点）。

```java
@Transactional
public void methodA() {
    // 操作1
    try {
        methodB();  // NESTED嵌套事务
    } catch (Exception e) {
        // B失败了，但A可以继续
    }
    // 操作2
}

@Transactional(propagation = Propagation.NESTED)
public void methodB() {
    // 操作3（嵌套事务）
}
```

**嵌套事务特点图示**：
```
事务T1
  ├── 操作1
  ├── 保存点Savepoint
  │    └── 操作3（嵌套事务）
  └── 操作2

B失败 → 回滚到Savepoint → A可以继续
A失败 → 整个事务回滚 → B也回滚
```

**与REQUIRES_NEW的区别**：

| 对比点 | NESTED | REQUIRES_NEW |
|--------|--------|--------------|
| 事务数量 | 1个事务，内部有保存点 | 2个独立事务 |
| 内层失败 | 回滚到保存点，外层可继续 | 内层独立回滚 |
| 外层失败 | 全部回滚 | 内层已提交不受影响 |
| 使用场景 | 部分操作允许失败 | 操作完全独立 |

> ⚠️ **注意**：NESTED依赖数据库的保存点功能，MySQL的InnoDB支持。

### 4.6 SUPPORTS支持事务


**定义**：如果当前存在事务，就加入事务；如果没有事务，就以非事务方式执行。

```java
@Transactional(propagation = Propagation.SUPPORTS)
public User getUser(Long id) {
    return userDao.findById(id);
}
```

**行为说明**：
- 有事务时：加入当前事务
- 无事务时：普通执行，不开启事务

**使用场景**：
- 查询方法，可能被事务方法调用，也可能单独调用
- 灵活适应，有事务就用，没有也不影响

> 💡 **实际应用**：某些查询方法，既在事务中用，也在普通场景用。

### 4.7 NOT_SUPPORTED不支持事务


**定义**：以非事务方式执行，如果当前存在事务，就把当前事务暂停。

```java
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void sendEmail(String email) {
    emailService.send(email);  // 不需要事务
}
```

**使用场景**：
- 发送邮件、短信等不需要事务的操作
- 性能优化，避免不必要的事务开销

### 4.8 MANDATORY强制事务


**定义**：必须在事务中执行，如果当前没有事务，就抛出异常。

```java
@Transactional(propagation = Propagation.MANDATORY)
public void updateStock(Long productId, int quantity) {
    // 这个方法必须在事务中调用
    stockDao.update(productId, quantity);
}
```

**使用场景**：
- 强制业务规则，某些操作必须在事务环境中
- 防止误用，确保数据一致性

### 4.9 NEVER禁止事务


**定义**：必须在非事务中执行，如果当前存在事务，就抛出异常。

```java
@Transactional(propagation = Propagation.NEVER)
public void statisticsReport() {
    // 这个方法不能在事务中调用
    // 统计报表，不需要事务
}
```

**使用场景**：
- 长时间运行的操作，不适合放在事务中
- 明确不需要事务的业务逻辑

### 4.10 传播行为选择指南


**快速决策表**：

| 场景 | 推荐传播行为 | 原因 |
|------|-------------|------|
| 普通业务操作 | `REQUIRED` ⭐ | 默认值，最常用 |
| 日志记录 | `REQUIRES_NEW` | 独立提交，不受外层影响 |
| 部分失败可接受 | `NESTED` | 失败回滚到保存点 |
| 查询操作 | `SUPPORTS` | 灵活适应有无事务 |
| 发送邮件/短信 | `NOT_SUPPORTED` | 不需要事务 |
| 必须在事务中 | `MANDATORY` | 强制规范 |
| 禁止在事务中 | `NEVER` | 明确不需要 |

---

## 5. 🔒 事务隔离级别详解


### 5.1 为什么需要隔离级别


**并发问题场景**：
```
用户A和用户B同时操作数据库：
时间  用户A                用户B
T1    读取余额：1000元
T2                        读取余额：1000元
T3    转出500元
T4    余额变成500元
T5                        转出300元
T6                        余额变成700元(错误！应该是200)

问题：B读到的是旧数据，导致数据不一致
解决：设置合适的隔离级别
```

### 5.2 并发引发的三大问题


**问题类型图示**：

**1. 脏读（Dirty Read）**
```
事务A                    事务B
                        开始事务
读取余额：1000元
                        修改余额：500元(未提交)
读取余额：500元 ← 脏读！
                        回滚事务
读取余额：1000元 ← 数据变了
```
> ❌ **脏读**：读到了别人未提交的数据，这个数据可能会回滚。

**2. 不可重复读（Non-Repeatable Read）**
```
事务A                    事务B
开始事务
读取余额：1000元
                        修改余额：500元并提交
读取余额：500元 ← 不可重复读！
同一个事务，两次读结果不同
```
> ⚠️ **不可重复读**：同一个事务中，多次读取同一数据，结果不一样。

**3. 幻读（Phantom Read）**
```
事务A                    事务B
开始事务
查询用户数：10条
                        插入1条用户并提交
查询用户数：11条 ← 幻读！
同一个事务，数据条数变了
```
> 🔮 **幻读**：同一个事务中，多次查询，记录数量变了（像产生了幻觉）。

### 5.3 四种隔离级别


**隔离级别对比表**：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 使用场景 |
|---------|------|-----------|------|------|---------|
| **READ_UNCOMMITTED** | ❌可能 | ❌可能 | ❌可能 | ⭐⭐⭐⭐⭐ | 几乎不用 |
| **READ_COMMITTED** | ✅避免 | ❌可能 | ❌可能 | ⭐⭐⭐⭐ | Oracle默认 |
| **REPEATABLE_READ** | ✅避免 | ✅避免 | ❌可能 | ⭐⭐⭐ | MySQL默认⭐ |
| **SERIALIZABLE** | ✅避免 | ✅避免 | ✅避免 | ⭐ | 严格场景 |

### 5.4 READ_UNCOMMITTED未提交读


**定义**：最低隔离级别，可以读取未提交的数据。

```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void query() {
    // 可能读到脏数据
}
```

**特点**：
- ❌ 可能脏读、不可重复读、幻读
- ⭐ 性能最好
- 🚫 实际几乎不用

> ⚠️ **风险极高**：读到的数据可能是错误的，不建议使用。

### 5.5 READ_COMMITTED提交读 ⭐


**定义**：只能读取已提交的数据，避免脏读。

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void query() {
    // 只读已提交的数据
}
```

**特点**：
- ✅ 避免脏读
- ❌ 可能不可重复读、幻读
- ⚖️ 性能和安全平衡
- 🎯 Oracle默认隔离级别

**实际场景**：
```java
// 查询账户余额，确保不读到未提交的错误数据
@Transactional(isolation = Isolation.READ_COMMITTED)
public BigDecimal getBalance(Long accountId) {
    return accountDao.getBalance(accountId);
}
```

> 💡 **适用场景**：大部分业务查询，既保证数据准确，又有较好性能。

### 5.6 REPEATABLE_READ可重复读 ⭐⭐


**定义**：确保在同一事务中，多次读取相同数据结果一致。

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void processOrder() {
    // 第一次查询
    BigDecimal balance = accountDao.getBalance(accountId);
    
    // 中间有其他操作
    doSomething();
    
    // 第二次查询，结果和第一次一样
    BigDecimal balance2 = accountDao.getBalance(accountId);
    // balance == balance2 一定相等
}
```

**特点**：
- ✅ 避免脏读、不可重复读
- ❌ 可能幻读（MySQL的InnoDB实际也解决了）
- ⚖️ 性能较好
- 🎯 MySQL默认隔离级别

**MySQL特殊优化**：
```
MySQL的InnoDB引擎通过MVCC（多版本并发控制）
实际上也解决了幻读问题
所以MySQL的REPEATABLE_READ是最常用的！
```

> 🎯 **推荐使用**：MySQL数据库的默认且推荐的隔离级别。

### 5.7 SERIALIZABLE串行化


**定义**：最高隔离级别，事务串行执行，完全隔离。

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void criticalOperation() {
    // 完全隔离，但性能最差
}
```

**特点**：
- ✅ 避免所有并发问题
- ❌ 性能最差（串行执行）
- 🔒 事务排队执行

**工作原理图示**：
```
事务A → 执行 → 提交 → 事务B → 执行 → 提交 → 事务C
                         ↑
                    必须等待前面的完成
```

> ⚠️ **慎用场景**：只在对数据一致性要求极高，且并发量很低的场景使用。

### 5.8 隔离级别选择指南


**决策流程**：
```
需要最高数据一致性？
├─ 是 → SERIALIZABLE（性能差）
└─ 否 → 需要避免不可重复读？
        ├─ 是 → REPEATABLE_READ（MySQL推荐⭐）
        └─ 否 → 需要避免脏读？
                ├─ 是 → READ_COMMITTED（Oracle推荐）
                └─ 否 → READ_UNCOMMITTED（不推荐）
```

**实际开发建议**：
- 🎯 **首选**：使用数据库默认隔离级别（MySQL用REPEATABLE_READ）
- 🔧 **特殊需求**：根据业务场景调整
- ⚠️ **性能优化**：查询操作可以降低隔离级别
- 🔒 **关键操作**：重要业务可以提高隔离级别

---

## 6. ⚙️ 事务其他配置


### 6.1 事务回滚规则


**默认回滚行为**：
```java
@Transactional
public void defaultRollback() {
    // 默认只回滚RuntimeException和Error
    throw new RuntimeException("回滚");  // ✅ 会回滚
    throw new Exception("不回滚");      // ❌ 不会回滚
}
```

**自定义回滚规则**：
```java
// 指定所有异常都回滚
@Transactional(rollbackFor = Exception.class)
public void rollbackAll() {
    throw new Exception("回滚");  // ✅ 会回滚
}

// 指定特定异常不回滚
@Transactional(noRollbackFor = BusinessException.class)
public void noRollback() {
    throw new BusinessException();  // ❌ 不会回滚
}
```

**实际应用场景**：
```java
// 文件上传业务
@Transactional(
    rollbackFor = Exception.class,           // 所有异常都回滚
    noRollbackFor = FileNotFoundException.class  // 文件不存在不回滚
)
public void uploadFile(File file) {
    // 保存文件信息到数据库
    fileDao.save(fileInfo);
    
    // 上传文件到服务器
    // 如果文件不存在，记录日志但不回滚数据库操作
    fileService.upload(file);
}
```

> 💡 **最佳实践**：明确指定`rollbackFor = Exception.class`，避免漏掉检查异常。

### 6.2 只读事务设置


**什么是只读事务**：告诉数据库这是一个查询操作，不会修改数据。

```java
@Transactional(readOnly = true)
public List<User> getAllUsers() {
    return userDao.findAll();
}
```

**只读事务的好处**：
```
性能优化：
1. 数据库可以进行查询优化
2. 不需要维护事务日志
3. 减少锁的开销

实际提升：
- MySQL：查询性能提升5%-15%
- 大量查询场景效果明显
```

**使用场景**：
```java
// ✅ 查询操作，设置只读
@Transactional(readOnly = true)
public User getUserById(Long id) {
    return userDao.findById(id);
}

// ❌ 更新操作，不能设置只读
@Transactional(readOnly = false)  // 或不设置
public void updateUser(User user) {
    userDao.update(user);
}
```

> 🎯 **优化建议**：所有查询方法都加上`readOnly = true`，养成好习惯。

### 6.3 事务超时设置


**什么是事务超时**：限制事务执行的最长时间，超时自动回滚。

```java
@Transactional(timeout = 30)  // 30秒超时
public void longTimeOperation() {
    // 如果30秒内没完成，自动回滚
}
```

**超时设置的意义**：
```
防止问题：
1. 避免长时间占用数据库连接
2. 防止死锁导致永久等待
3. 及时发现性能问题

实际场景：
批量导入 → timeout = 300（5分钟）
普通业务 → timeout = 30（30秒）
快速查询 → timeout = 5（5秒）
```

**实际应用示例**：
```java
// 批量导入，设置较长超时
@Transactional(timeout = 300)
public void batchImport(List<Data> dataList) {
    for (Data data : dataList) {
        dataDao.save(data);
    }
}

// 普通业务，30秒超时
@Transactional(timeout = 30)
public void createOrder(Order order) {
    orderDao.save(order);
    stockDao.reduce(order.getProductId());
}
```

> ⚠️ **注意**：超时时间单位是秒，-1表示不限时（默认值）。

### 6.4 事务配置最佳实践


**完整配置示例**：
```java
@Service
public class OrderService {
    
    // 查询操作：只读事务，降低隔离级别
    @Transactional(
        readOnly = true,
        isolation = Isolation.READ_COMMITTED,
        timeout = 5
    )
    public Order getOrder(Long orderId) {
        return orderDao.findById(orderId);
    }
    
    // 普通业务：标准事务配置
    @Transactional(
        propagation = Propagation.REQUIRED,
        isolation = Isolation.REPEATABLE_READ,
        rollbackFor = Exception.class,
        timeout = 30
    )
    public void createOrder(Order order) {
        orderDao.save(order);
        stockService.reduceStock(order.getProductId());
    }
    
    // 日志记录：独立事务，必须成功
    @Transactional(
        propagation = Propagation.REQUIRES_NEW,
        rollbackFor = Exception.class,
        timeout = 10
    )
    public void saveLog(Log log) {
        logDao.save(log);
    }
}
```

**配置选择清单**：

- [ ] **传播行为**：99%用REQUIRED，日志用REQUIRES_NEW
- [ ] **隔离级别**：使用数据库默认（MySQL用REPEATABLE_READ）
- [ ] **回滚规则**：明确指定rollbackFor = Exception.class
- [ ] **只读优化**：查询方法设置readOnly = true
- [ ] **超时设置**：根据业务设置合理超时时间

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 事务本质：一组操作要么全成功，要么全失败
🔸 ACID特性：原子性、一致性、隔离性、持久性
🔸 管理方式：声明式事务（@Transactional）是主流
🔸 传播行为：控制方法间事务如何传递
🔸 隔离级别：控制并发事务的影响
🔸 回滚规则：指定哪些异常触发回滚
```

### 7.2 传播行为速记口诀


```
REQUIRED常用默认值，没事务建，有就加入
REQUIRES_NEW总新建，暂停外层独立跑
NESTED嵌套带保存点，内层失败外可续
SUPPORTS随机应变灵活用
NOT_SUPPORTED不要事务暂停它
MANDATORY必须有，NEVER不能有
```

### 7.3 隔离级别速记口诀


```
未提交读最危险，脏读重读幻读全
提交读能防脏读，Oracle最常见
可重复读MySQL选，防脏防重性能好
串行化最安全，性能最差要慎用
```

### 7.4 实际开发经验总结


**常见场景配置模板**：

**1. 普通业务方法（最常用）**
```java
@Transactional(rollbackFor = Exception.class)
public void normalBusiness() { }
```

**2. 查询方法（性能优化）**
```java
@Transactional(readOnly = true, timeout = 5)
public List<Data> queryData() { }
```

**3. 日志记录（独立事务）**
```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveLog(Log log) { }
```

**4. 批量操作（长时间）**
```java
@Transactional(timeout = 300, rollbackFor = Exception.class)
public void batchProcess(List<Data> dataList) { }
```

### 7.5 事务失效常见坑


**坑点1：方法不是public**
```java
// ❌ 事务不生效
@Transactional
private void method() { }

// ✅ 必须是public
@Transactional
public void method() { }
```

**坑点2：同类方法调用**
```java
@Service
public class UserService {
    // ❌ this.methodB()不会触发事务
    @Transactional
    public void methodA() {
        this.methodB();  // 直接调用，事务失效
    }
    
    @Transactional
    public void methodB() { }
}
```

**坑点3：异常被捕获**
```java
// ❌ 事务不会回滚
@Transactional
public void method() {
    try {
        // 操作
        throw new Exception();
    } catch (Exception e) {
        // 异常被捕获了，事务不知道
    }
}

// ✅ 手动回滚或抛出异常
@Transactional
public void method() {
    try {
        // 操作
        throw new Exception();
    } catch (Exception e) {
        throw new RuntimeException(e);  // 重新抛出
    }
}
```

### 7.6 学习检查清单


- [ ] 理解事务的ACID特性
- [ ] 掌握@Transactional注解的使用
- [ ] 理解7种传播行为的区别
- [ ] 掌握4种隔离级别的应用场景
- [ ] 知道事务回滚规则的配置
- [ ] 了解只读事务和超时设置
- [ ] 避免事务失效的常见坑

**核心记忆**：
- Spring事务管理，声明式最方便
- 传播行为REQUIRED最常用
- 隔离级别用默认，MySQL选REPEATABLE_READ
- 回滚异常要明确，Exception.class最稳妥
- 查询方法加只读，超时设置防长占
- 注意失效三大坑，public方法不捕获异常不内部调用