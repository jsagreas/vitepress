---
title: 23、传播行为实战场景
---
## 📚 目录

1. [业务场景分析](#1-业务场景分析)
2. [父子方法调用详解](#2-父子方法调用详解)
3. [传播行为组合策略](#3-传播行为组合策略)
4. [异常传播机制](#4-异常传播机制)
5. [回滚影响范围](#5-回滚影响范围)
6. [嵌套事务场景](#6-嵌套事务场景)
7. [独立事务场景](#7-独立事务场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 业务场景分析


### 1.1 什么是业务场景中的事务传播


**生活化理解**：想象你在办理银行业务

```
场景一：转账业务
你去银行办理转账，这个过程包含：
1. 从你的账户扣钱
2. 向对方账户加钱
3. 记录转账日志

问题来了：这三个操作应该怎么处理？
• 能不能扣了钱但没加钱？❌ 不行
• 能不能扣钱和加钱成功，但日志没记录？🤔 看需求
• 如果中途出错，已经执行的操作要不要撤销？✅ 要撤销

这就是事务传播要解决的问题！
```

**🎯 事务传播的本质**：
```
当一个方法调用另一个方法时，事务该如何处理？

情况分析：
外层方法有事务 + 内层方法有事务 = ?
外层方法有事务 + 内层方法无事务 = ?
外层方法无事务 + 内层方法有事务 = ?

传播机制就是定义这些组合的规则
```

### 1.2 典型业务场景分类


**💼 场景类型对照表**：

| 场景类型 | **业务描述** | **事务需求** | **推荐传播行为** |
|---------|------------|------------|----------------|
| **订单支付** | `下单 + 扣库存 + 支付 + 发货` | `全部成功或全部失败` | `REQUIRED` |
| **日志记录** | `业务操作 + 记录日志` | `业务失败不影响日志` | `REQUIRES_NEW` |
| **批量操作** | `处理多条数据` | `单条失败不影响其他` | `REQUIRES_NEW` |
| **审计跟踪** | `操作 + 审计记录` | `操作成功才记录` | `REQUIRED` |
| **消息发送** | `业务成功 + 发送通知` | `通知失败不影响业务` | `REQUIRES_NEW` |

### 1.3 场景一：电商订单处理


这是最经典的业务场景，我们详细分析一下：

**📦 订单业务流程**：
```
用户下单流程：
┌─────────────┐
│  创建订单   │ ← 主事务开始
└──────┬──────┘
       ↓
┌─────────────┐
│  扣减库存   │ ← 需要参与主事务
└──────┬──────┘
       ↓
┌─────────────┐
│  扣减积分   │ ← 需要参与主事务
└──────┬──────┘
       ↓
┌─────────────┐
│  记录日志   │ ← 独立事务（失败不影响订单）
└──────┬──────┘
       ↓
┌─────────────┐
│  发送通知   │ ← 独立事务（失败不影响订单）
└─────────────┘
```

**💡 代码实现思路**：
```java
// 订单服务 - 主事务方法
@Service
public class OrderService {
    
    @Autowired
    private InventoryService inventoryService;
    @Autowired
    private PointService pointService;
    @Autowired
    private LogService logService;
    
    @Transactional  // 主事务：REQUIRED
    public void createOrder(Order order) {
        // 1. 创建订单
        orderMapper.insert(order);
        
        // 2. 扣减库存（加入当前事务）
        inventoryService.reduceStock(order.getProductId(), order.getQuantity());
        
        // 3. 扣减积分（加入当前事务）
        pointService.reducePoints(order.getUserId(), order.getPoints());
        
        // 4. 记录日志（独立事务，不受影响）
        logService.saveOrderLog(order);
        
        // 5. 发送通知（独立事务，不受影响）
        notificationService.sendOrderNotification(order);
    }
}

// 库存服务 - 参与主事务
@Service
public class InventoryService {
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void reduceStock(Long productId, Integer quantity) {
        // 扣减库存
        inventoryMapper.reduce(productId, quantity);
        // 如果库存不足会抛异常，整个订单回滚
    }
}

// 日志服务 - 独立事务
@Service
public class LogService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveOrderLog(Order order) {
        // 记录日志
        logMapper.insert(new OrderLog(order));
        // 即使日志失败，订单也不受影响
    }
}
```

**🔍 场景分析**：
```
问：为什么库存和积分用REQUIRED？
答：它们是订单的核心，必须和订单一起成功或失败
    如果库存扣了但订单失败，就会造成数据不一致

问：为什么日志用REQUIRES_NEW？
答：日志是辅助功能，日志失败不应该影响订单
    但订单成功时，我们希望尽量记录日志

问：如果日志抛异常怎么办？
答：虽然日志是独立事务，但异常会传播到主方法
    如果不想影响订单，需要try-catch捕获异常
```

### 1.4 场景二：批量数据导入


**📥 批量导入流程**：
```
导入1000条用户数据：
┌─────────────────┐
│  开始批量导入   │
└────────┬────────┘
         ↓
    ┌────────┐
    │ 循环   │
    └───┬────┘
        ↓
┌───────────────┐
│ 导入单条数据  │ ← 每条数据独立事务
└───────┬───────┘
        ↓
   导入成功？
    是 ↓   否 ↓
   继续   记录失败，继续处理下一条
```

**💡 实现策略**：
```java
@Service
public class UserImportService {
    
    @Autowired
    private UserService userService;
    
    // 批量导入 - 不使用事务
    public ImportResult batchImport(List<User> users) {
        int success = 0;
        int failed = 0;
        List<String> errors = new ArrayList<>();
        
        for (User user : users) {
            try {
                // 每条数据独立事务
                userService.saveUser(user);
                success++;
            } catch (Exception e) {
                failed++;
                errors.add("用户" + user.getName() + "导入失败：" + e.getMessage());
            }
        }
        
        return new ImportResult(success, failed, errors);
    }
}

@Service
public class UserService {
    
    // 单条保存 - 独立事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveUser(User user) {
        // 数据校验
        validateUser(user);
        // 保存用户
        userMapper.insert(user);
    }
}
```

**⚙️ 为什么这样设计**：
```
批量操作的关键：
✅ 单条失败不影响其他数据
✅ 能够统计成功和失败的数量
✅ 记录失败原因，便于后续处理

使用REQUIRES_NEW的好处：
• 每条数据是独立事务
• 某条失败只回滚该条，不影响其他
• 可以精确控制每条数据的事务边界
```

---

## 2. 🔄 父子方法调用详解


### 2.1 什么是父子方法调用


**通俗解释**：就像套娃一样，一个方法调用另一个方法

```
生活类比：
你打电话给银行客服（父方法）
  ↓
客服帮你转接理财部门（子方法）
  ↓
理财部门又转接基金经理（孙方法）

每一级都可能有自己的"事务"规则
```

### 2.2 调用方式对事务的影响


**🎯 关键理解**：事务传播只在Spring代理下有效

```
调用方式分析：

方式一：通过Spring注入调用 ✅
ServiceA → Spring代理 → ServiceB
  ↓
事务传播生效

方式二：同类内部调用 ❌  
ServiceA.methodA() → this.methodB()
  ↓
事务传播失效！绕过了代理
```

**💡 代码对比**：
```java
@Service
public class OrderService {
    
    @Autowired
    private OrderService self;  // 注入自己的代理
    
    // ❌ 错误示例：内部调用，事务传播失效
    @Transactional
    public void createOrder() {
        // ... 创建订单
        this.saveLog();  // 直接this调用，事务传播失效
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog() {
        // ... 保存日志
    }
    
    // ✅ 正确示例：通过代理调用
    @Transactional
    public void createOrderCorrect() {
        // ... 创建订单
        self.saveLog();  // 通过Spring代理调用，事务传播生效
    }
}
```

### 2.3 父子事务的传播规则


**📊 传播组合效果表**：

| 父方法 | 子方法 | **最终效果** | **说明** |
|-------|-------|------------|---------|
| `有事务` | `REQUIRED` | `共用一个事务` | `一起提交，一起回滚` |
| `有事务` | `REQUIRES_NEW` | `挂起父事务，新建事务` | `各自独立提交回滚` |
| `有事务` | `NESTED` | `父事务内的嵌套点` | `子可独立回滚，父影响子` |
| `无事务` | `REQUIRED` | `新建事务` | `子方法有自己的事务` |
| `无事务` | `REQUIRES_NEW` | `新建事务` | `与REQUIRED效果相同` |

**🔍 详细分析各种组合**：

```
组合1：REQUIRED + REQUIRED（最常用）
┌─────────────────────┐
│   父事务 (REQUIRED)  │
│  ┌─────────────────┐│
│  │ 子事务(REQUIRED)││ ← 加入父事务
│  └─────────────────┘│
└─────────────────────┘
结果：只有一个物理事务

组合2：REQUIRED + REQUIRES_NEW
┌─────────────────────┐
│   父事务 (REQUIRED)  │ ← 被挂起
└─────────────────────┘
       ↓ 挂起
┌─────────────────────┐
│ 子事务(REQUIRES_NEW) │ ← 新建独立事务
└─────────────────────┘
       ↓ 恢复
┌─────────────────────┐
│   父事务继续执行     │
└─────────────────────┘
结果：两个独立的物理事务

组合3：REQUIRED + NESTED
┌─────────────────────┐
│   父事务 (REQUIRED)  │
│  ┌─────────────────┐│
│  │子事务(NESTED)   ││ ← 父事务的保存点
│  └─────────────────┘│
└─────────────────────┘
结果：一个物理事务，子有独立保存点
```

---

## 3. 🎯 传播行为组合策略


### 3.1 组合策略选择原则


**如何选择合适的组合？**

```
决策树：
开始
  ↓
子方法必须和父方法一起成功/失败？
  是 → 使用REQUIRED
  否 ↓
子方法失败后父方法要继续？
  是 → 使用REQUIRES_NEW（需要try-catch）
  否 ↓
子方法需要部分回滚能力？
  是 → 使用NESTED
  否 → 使用REQUIRED（最保险）
```

### 3.2 实战组合模式


**模式一：核心业务 + 日志（REQUIRED + REQUIRES_NEW）**

```java
@Service
public class PaymentService {
    
    @Autowired
    private AccountService accountService;
    @Autowired
    private AuditService auditService;
    
    @Transactional  // REQUIRED
    public void processPayment(Payment payment) {
        // 核心业务：扣款
        accountService.deduct(payment.getAmount());  // REQUIRED
        
        // 辅助功能：记录审计日志（即使失败也要记录）
        try {
            auditService.logPayment(payment);  // REQUIRES_NEW
        } catch (Exception e) {
            // 日志失败不影响支付
            log.error("审计日志记录失败", e);
        }
    }
}

@Service
public class AuditService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logPayment(Payment payment) {
        auditMapper.insert(new AuditLog(payment));
    }
}
```

**🔍 为什么这样设计**：
```
核心逻辑：
• 支付成功 + 日志成功 ✅ 完美
• 支付成功 + 日志失败 ✅ 可接受（日志不是核心）
• 支付失败 + 日志成功 ✅ 可接受（记录失败原因）
• 支付失败 + 日志失败 ✅ 都失败也正常

关键点：
• 日志用REQUIRES_NEW保证独立性
• try-catch防止日志异常影响支付
• 支付失败时日志也能记录（便于排查）
```

**模式二：主流程 + 多个子流程（REQUIRED + NESTED）**

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderService self;
    
    @Transactional  // REQUIRED
    public void processOrder(Order order) {
        // 创建订单
        orderMapper.insert(order);
        
        // 处理订单项（允许部分失败）
        for (OrderItem item : order.getItems()) {
            try {
                self.processOrderItem(item);  // NESTED
            } catch (Exception e) {
                // 单个商品失败，记录但继续处理其他商品
                order.addFailedItem(item, e.getMessage());
            }
        }
        
        // 如果全部失败才抛异常
        if (order.getAllItemsFailed()) {
            throw new BusinessException("订单处理完全失败");
        }
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void processOrderItem(OrderItem item) {
        // 处理单个订单项
        // 失败会回滚到嵌套点，不影响其他订单项
    }
}
```

**⚙️ NESTED的优势**：
```
场景特点：
• 需要部分回滚能力
• 允许一部分失败
• 但整体还是在一个事务内

适用情况：
✅ 批量处理允许部分失败
✅ 需要记录哪些成功哪些失败
✅ 失败后需要继续处理其他数据
```

### 3.3 反模式警示


**❌ 常见错误组合**：

```java
// 错误1：过度使用REQUIRES_NEW
@Service
public class BadService {
    
    @Transactional
    public void processOrder() {
        step1();  // REQUIRES_NEW
        step2();  // REQUIRES_NEW
        step3();  // REQUIRES_NEW
        // 问题：失去了事务整体性，step1成功但step3失败时无法回滚
    }
}

// 错误2：忘记处理REQUIRES_NEW的异常
@Transactional
public void process() {
    coreLogic();
    logService.saveLog();  // REQUIRES_NEW，但没有try-catch
    // 问题：日志失败会导致整个事务回滚
}

// 错误3：同类内部调用期望传播生效
@Service
public class WrongService {
    
    @Transactional
    public void parent() {
        // ...
        this.child();  // 期望REQUIRES_NEW生效
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void child() {
        // 实际上传播失效！还是在父事务中
    }
}
```

**✅ 正确做法**：
```
原则：
1. 核心业务用REQUIRED保证一致性
2. 辅助功能用REQUIRES_NEW保证独立性
3. 使用REQUIRES_NEW时记得try-catch
4. 避免过度拆分事务
5. 跨类调用才能保证传播生效
```

---

## 4. ⚠️ 异常传播机制


### 4.1 异常如何影响事务


**基本原理**：异常就像"导火索"，会触发事务回滚

```
异常传播路径：
子方法抛异常 → 异常向上传播 → 父方法处理 → 影响事务

关键问题：
1. 什么异常会导致回滚？
2. 子方法异常会影响父事务吗？
3. 如何阻止异常传播？
```

### 4.2 异常类型与回滚规则


**📋 默认回滚规则**：

| 异常类型 | **是否回滚** | **说明** |
|---------|------------|---------|
| `RuntimeException` | `✅ 回滚` | `非检查异常，默认回滚` |
| `Error` | `✅ 回滚` | `严重错误，默认回滚` |
| `Exception` | `❌ 不回滚` | `检查异常，默认不回滚` |
| `自定义异常` | `看继承关系` | `继承RuntimeException则回滚` |

**💡 为什么检查异常不回滚？**
```
Spring的设计理念：
• 检查异常(Exception)：通常是可预期的业务异常
  例如：找不到用户、余额不足等
  这些情况可能需要特殊处理，不一定要回滚

• 运行时异常(RuntimeException)：通常是编程错误
  例如：空指针、数组越界等
  这些错误应该回滚事务

实际开发：
• 业务异常建议继承RuntimeException
• 或者通过rollbackFor指定要回滚的异常
```

### 4.3 不同传播行为的异常影响


**🔍 REQUIRED传播行为的异常处理**：

```java
@Service
public class ServiceA {
    
    @Autowired
    private ServiceB serviceB;
    
    @Transactional
    public void methodA() {
        // 操作1
        operationA();
        
        try {
            // 操作2：调用B服务
            serviceB.methodB();
        } catch (Exception e) {
            // 捕获了异常，但事务已被标记为回滚！
            log.error("B服务调用失败", e);
        }
        
        // 操作3：这里会抛出UnexpectedRollbackException
        operationC();
    }
}

@Service  
public class ServiceB {
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodB() {
        // ... 
        throw new RuntimeException("B方法失败");
        // 异常会标记整个事务为回滚
    }
}
```

**⚠️ 关键理解**：
```
REQUIRED的异常传播特点：
1. 子方法和父方法共用一个事务
2. 子方法抛异常 → 整个事务被标记为"只能回滚"
3. 即使父方法catch了异常也没用
4. 最终提交时会抛UnexpectedRollbackException

为什么这样设计？
• 保证事务完整性
• 防止部分提交的数据不一致
• 一旦任何部分失败，整体都不能成功
```

**🔍 REQUIRES_NEW传播行为的异常处理**：

```java
@Service
public class ServiceA {
    
    @Autowired
    private ServiceB serviceB;
    
    @Transactional
    public void methodA() {
        operationA();  // 操作1
        
        try {
            serviceB.methodB();  // 操作2：独立事务
        } catch (Exception e) {
            // 可以正常捕获处理，不影响父事务
            log.error("B服务调用失败", e);
        }
        
        operationC();  // 操作3：正常执行
        // 整个方法可以正常提交
    }
}

@Service
public class ServiceB {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // ... 
        throw new RuntimeException("B方法失败");
        // 只回滚B方法自己的事务，不影响A
    }
}
```

**✅ REQUIRES_NEW的优势**：
```
异常隔离效果：
• B方法有独立事务
• B方法失败只回滚B的事务
• 异常可以被父方法正常捕获
• 父事务可以继续执行

适用场景：
✅ 记录日志（失败不影响主业务）
✅ 发送通知（失败不影响主业务）
✅ 辅助功能（失败不影响核心流程）
```

### 4.4 异常处理最佳实践


**🎯 实战建议**：

```java
// 建议1：明确定义业务异常
public class BusinessException extends RuntimeException {
    private String errorCode;
    
    public BusinessException(String message) {
        super(message);
    }
}

// 建议2：合理设置回滚规则
@Transactional(
    rollbackFor = Exception.class,  // 所有异常都回滚
    noRollbackFor = IgnoreException.class  // 忽略某些异常
)
public void process() {
    // ...
}

// 建议3：REQUIRES_NEW配合try-catch
@Transactional
public void mainProcess() {
    coreLogic();
    
    // 辅助功能用try-catch包裹
    try {
        auxiliaryService.doSomething();  // REQUIRES_NEW
    } catch (Exception e) {
        // 记录日志，不影响主流程
        log.error("辅助功能失败", e);
    }
}

// 建议4：使用TransactionAspectSupport手动回滚
@Transactional
public void complexProcess() {
    try {
        riskyOperation();
    } catch (SpecialException e) {
        // 某些特殊情况不回滚
        if (e.canIgnore()) {
            log.warn("可忽略的异常", e);
            return;
        }
        // 需要回滚
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        throw e;
    }
}
```

---

## 5. 🔄 回滚影响范围


### 5.1 回滚范围的概念


**通俗理解**：回滚范围就是"影响波及面"

```
生活类比：
你在超市购物：
• 买了面包 ✅
• 买了牛奶 ✅  
• 买了鸡蛋但发现过期 ❌

问题：发现鸡蛋过期后怎么办？
方案1：只退鸡蛋 ← 类似REQUIRES_NEW
方案2：整单都退 ← 类似REQUIRED
方案3：退鸡蛋，其他保留 ← 类似NESTED
```

### 5.2 不同传播行为的回滚范围


**📊 回滚范围对照**：

```
场景1：REQUIRED传播
┌────────────────────────┐
│   父事务               │
│  ┌──────────────────┐ │
│  │  子事务(REQUIRED) │ │ ← 子回滚导致父也回滚
│  └──────────────────┘ │
└────────────────────────┘
回滚范围：整个事务

场景2：REQUIRES_NEW传播  
┌────────────────────────┐
│   父事务               │ ← 不受影响
└────────────────────────┘
┌────────────────────────┐
│ 子事务(REQUIRES_NEW)   │ ← 只回滚自己
└────────────────────────┘
回滚范围：仅子事务

场景3：NESTED传播
┌────────────────────────┐
│   父事务               │
│  ┌──────────────────┐ │
│  │ 子事务(NESTED)    │ │ ← 回滚到保存点
│  └──────────────────┘ │
│  后续操作可继续        │
└────────────────────────┘
回滚范围：子事务到保存点
```

### 5.3 实际回滚场景分析


**场景：订单处理的回滚策略**

```java
@Service
public class OrderService {
    
    @Autowired
    private StockService stockService;
    @Autowired
    private PointService pointService;
    @Autowired
    private LogService logService;
    
    @Transactional
    public void createOrder(Order order) {
        // 1. 创建订单
        orderMapper.insert(order);
        
        // 2. 扣减库存（REQUIRED - 加入当前事务）
        stockService.reduceStock(order);
        // 如果库存不足抛异常 → 整个订单回滚
        
        // 3. 扣减积分（REQUIRED - 加入当前事务）
        pointService.reducePoints(order);
        // 如果积分不足抛异常 → 整个订单回滚
        
        // 4. 记录操作日志（REQUIRES_NEW - 独立事务）
        try {
            logService.saveLog(order);
        } catch (Exception e) {
            // 日志失败不影响订单
        }
    }
}
```

**🔍 各种失败情况分析**：

| 失败点 | **已完成操作** | **回滚范围** | **最终结果** |
|-------|--------------|------------|------------|
| `库存不足` | `创建订单` | `整个事务` | `订单未创建，库存未扣` |
| `积分不足` | `订单、库存` | `整个事务` | `订单未创建，库存未扣，积分未扣` |
| `日志失败` | `订单、库存、积分` | `仅日志事务` | `订单创建成功，无日志记录` |

### 5.4 控制回滚范围的技巧


**💡 技巧1：使用NESTED实现部分回滚**

```java
@Service
public class BatchService {
    
    @Autowired
    private BatchService self;
    
    @Transactional
    public BatchResult batchProcess(List<Item> items) {
        int success = 0;
        int failed = 0;
        
        for (Item item : items) {
            try {
                // 使用NESTED，失败只回滚当前项
                self.processItem(item);
                success++;
            } catch (Exception e) {
                failed++;
                // 继续处理下一项
            }
        }
        
        return new BatchResult(success, failed);
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void processItem(Item item) {
        // 处理单项
        // 失败会回滚到保存点，不影响其他项
    }
}
```

**💡 技巧2：使用编程式事务精确控制**

```java
@Service
public class PreciseControlService {
    
    @Autowired
    private PlatformTransactionManager txManager;
    
    public void complexProcess() {
        // 手动控制事务
        TransactionStatus tx1 = txManager.getTransaction(
            new DefaultTransactionDefinition()
        );
        
        try {
            // 核心操作
            coreOperation();
            txManager.commit(tx1);
        } catch (Exception e) {
            txManager.rollback(tx1);
            throw e;
        }
        
        // 辅助操作 - 独立事务
        TransactionStatus tx2 = txManager.getTransaction(
            new DefaultTransactionDefinition()
        );
        try {
            auxiliaryOperation();
            txManager.commit(tx2);
        } catch (Exception e) {
            txManager.rollback(tx2);
            // 不抛异常，不影响主流程
        }
    }
}
```

---

## 6. 🏗️ 嵌套事务场景


### 6.1 嵌套事务的本质


**什么是真正的嵌套？**

```
误区：很多人认为嵌套就是"事务套事务"
真相：NESTED是通过保存点(Savepoint)实现的

数据库保存点机制：
开始事务
  ↓
操作A
  ↓
设置保存点S1
  ↓
操作B
  ↓
如果B失败 → 回滚到S1 → 继续操作C
如果B成功 → 继续操作C
  ↓
提交整个事务
```

**🔍 NESTED vs REQUIRES_NEW的区别**：

| 特性 | **NESTED** | **REQUIRES_NEW** |
|------|-----------|-----------------|
| **事务数量** | `1个物理事务` | `2个独立物理事务` |
| **实现机制** | `保存点` | `挂起和新建` |
| **子失败影响** | `可独立回滚到保存点` | `完全独立，不影响父` |
| **父失败影响** | `父回滚，子也回滚` | `父回滚，子不影响` |
| **提交时机** | `随父事务一起提交` | `立即提交` |

### 6.2 NESTED的典型应用场景


**场景：批量导入数据**

```java
@Service
public class DataImportService {
    
    @Autowired
    private DataImportService self;
    
    @Transactional
    public ImportResult importData(List<DataRow> rows) {
        ImportResult result = new ImportResult();
        
        for (DataRow row : rows) {
            try {
                // NESTED：失败回滚到保存点
                self.importSingleRow(row);
                result.addSuccess();
            } catch (Exception e) {
                // 记录失败，继续处理下一条
                result.addFailure(row, e.getMessage());
            }
        }
        
        // 如果失败率超过50%，整体回滚
        if (result.getFailureRate() > 0.5) {
            throw new BusinessException("失败率过高，导入中止");
        }
        
        return result;
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void importSingleRow(DataRow row) {
        // 验证数据
        validateRow(row);
        // 插入数据
        dataMapper.insert(row);
        // 更新关联表
        relatedMapper.update(row);
    }
}
```

**⚙️ 为什么用NESTED？**
```
优势：
✅ 单条失败不影响其他数据
✅ 允许部分成功，部分失败
✅ 最后可以统一决定是否整体回滚
✅ 所有操作在一个事务内，性能好

对比REQUIRES_NEW：
• NESTED：一次性提交，性能更好
• REQUIRES_NEW：每条都提交，开销大
```

**场景：订单退款流程**

```java
@Service
public class RefundService {
    
    @Autowired
    private RefundService self;
    
    @Transactional
    public void processRefund(Refund refund) {
        // 1. 创建退款记录
        refundMapper.insert(refund);
        
        // 2. 尝试退款到原支付方式（可能失败）
        try {
            self.refundToOriginal(refund);
        } catch (Exception e) {
            // 原路退款失败，尝试退款到余额
            try {
                self.refundToBalance(refund);
            } catch (Exception ex) {
                // 余额退款也失败，整个退款流程失败
                throw new BusinessException("退款失败", ex);
            }
        }
        
        // 3. 发送退款通知（独立事务）
        notificationService.sendRefundNotice(refund);
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void refundToOriginal(Refund refund) {
        // 调用支付网关退款
        paymentGateway.refund(refund);
        refund.setMethod("ORIGINAL");
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void refundToBalance(Refund refund) {
        // 退款到用户余额
        balanceService.increase(refund);
        refund.setMethod("BALANCE");
    }
}
```

**🔍 流程分析**：
```
退款流程分支：
退款 → 原路退款(NESTED)
        ↓ 失败
     回滚到保存点
        ↓
     退款到余额(NESTED)
        ↓ 成功
     整体提交

关键点：
• 两种退款方式都是NESTED
• 失败可以回滚尝试另一种方式
• 最终只有一个事务提交
```

### 6.3 NESTED的注意事项


**⚠️ 限制和注意点**：

```
1. 数据库支持要求：
   ✅ MySQL (InnoDB)：支持保存点
   ✅ PostgreSQL：支持保存点
   ❌ MySQL (MyISAM)：不支持事务
   ❌ 某些老版本数据库：不支持

2. 嵌套层次限制：
   • 理论上可以多层嵌套
   • 实际建议不超过3层
   • 过深嵌套影响代码可读性

3. 性能考虑：
   • 保存点操作有开销
   • 大量嵌套会影响性能
   • 合理控制嵌套深度
```

---

## 7. 🚦 独立事务场景


### 7.1 什么时候需要独立事务


**独立事务的应用场景**：

```
需要独立事务的典型情况：

1. 辅助功能：
   ✅ 操作日志记录
   ✅ 审计信息记录
   ✅ 统计数据更新

2. 通知类操作：
   ✅ 发送邮件
   ✅ 发送短信
   ✅ 推送消息

3. 异步任务：
   ✅ 创建异步任务记录
   ✅ 消息队列发送

核心原则：
这些操作失败不应该影响主业务
```

### 7.2 REQUIRES_NEW实战应用


**场景一：操作日志记录**

```java
@Service
public class UserService {
    
    @Autowired
    private OperationLogService logService;
    
    @Transactional
    public void updateUserInfo(User user) {
        // 1. 更新用户信息
        userMapper.update(user);
        
        // 2. 记录操作日志（独立事务）
        try {
            logService.saveLog(
                "UPDATE_USER",
                "更新用户：" + user.getName()
            );
        } catch (Exception e) {
            // 日志失败不影响用户更新
            log.error("记录日志失败", e);
        }
    }
}

@Service
public class OperationLogService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String operation, String detail) {
        OperationLog log = new OperationLog();
        log.setOperation(operation);
        log.setDetail(detail);
        log.setCreateTime(new Date());
        
        logMapper.insert(log);
    }
}
```

**💡 为什么日志要独立事务？**
```
场景分析：
用户更新成功 + 日志记录成功 ✅ 最好情况
用户更新成功 + 日志记录失败 ✅ 可接受（日志不是核心）
用户更新失败 + 日志记录成功 ✅ 可接受（记录失败原因）
用户更新失败 + 日志记录失败 ✅ 正常失败

关键：
• 日志是辅助功能，不能影响主业务
• 即使主业务失败，也希望记录失败日志
• 使用REQUIRES_NEW + try-catch实现
```

**场景二：发送通知**

```java
@Service
public class OrderService {
    
    @Autowired
    private NotificationService notificationService;
    
    @Transactional
    public void confirmOrder(Long orderId) {
        // 1. 更新订单状态
        Order order = orderMapper.selectById(orderId);
        order.setStatus("CONFIRMED");
        orderMapper.update(order);
        
        // 2. 发送确认通知（独立事务）
        try {
            notificationService.sendOrderConfirm(order);
        } catch (Exception e) {
            // 通知失败不影响订单确认
            // 可以后续重试或手动发送
            log.error("发送通知失败，订单号：" + orderId, e);
        }
    }
}

@Service
public class NotificationService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void sendOrderConfirm(Order order) {
        // 1. 记录通知任务
        NotificationTask task = new NotificationTask();
        task.setOrderId(order.getId());
        task.setType("ORDER_CONFIRM");
        task.setStatus("PENDING");
        taskMapper.insert(task);
        
        // 2. 调用第三方接口发送
        smsService.send(order.getUserPhone(), "订单已确认");
        
        // 3. 更新任务状态
        task.setStatus("SENT");
        taskMapper.update(task);
    }
}
```

**⚙️ 独立事务的好处**：
```
优势：
1. 即使主业务回滚，通知记录仍然保存
2. 便于后续重试或人工处理
3. 不影响主业务的成功

注意：
• 必须用try-catch捕获异常
• 否则异常会传播，导致主事务回滚
• 合理记录失败信息，便于后续处理
```

### 7.3 独立事务的最佳实践


**🎯 实践模式总结**：

```java
// 模式1：日志记录模式
@Transactional
public void businessMethod() {
    // 核心业务逻辑
    doCoreLogic();
    
    // 记录日志（失败不影响业务）
    try {
        logService.log(info);  // REQUIRES_NEW
    } catch (Exception e) {
        log.error("日志记录失败", e);
    }
}

// 模式2：通知发送模式
@Transactional
public void businessMethod() {
    // 核心业务逻辑
    doCoreLogic();
    
    // 发送通知（失败不影响业务）
    try {
        notificationService.send(message);  // REQUIRES_NEW
    } catch (Exception e) {
        // 记录失败，后续重试
        failureService.recordFailure(message);
    }
}

// 模式3：异步任务创建模式
@Transactional
public void businessMethod() {
    // 核心业务逻辑
    doCoreLogic();
    
    // 创建异步任务（保证任务创建成功）
    try {
        asyncTaskService.createTask(task);  // REQUIRES_NEW
    } catch (Exception e) {
        log.error("创建异步任务失败", e);
        // 可以考虑是否需要回滚主业务
    }
}
```

**✅ 独立事务的使用原则**：
```
何时使用REQUIRES_NEW：
1. 辅助功能，失败不影响主业务
2. 需要保证操作一定被记录
3. 不关心主业务的最终结果

使用时注意：
• 务必使用try-catch捕获异常
• 合理记录失败信息
• 考虑失败后的补偿机制
• 避免过度使用，影响性能
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 传播行为本质：定义方法调用时事务如何传播
🔸 REQUIRED：加入现有事务，最常用，保证一致性
🔸 REQUIRES_NEW：创建独立事务，适合辅助功能
🔸 NESTED：保存点机制，允许部分回滚
🔸 异常传播：理解异常如何影响事务回滚
🔸 回滚范围：不同传播行为的回滚影响不同
🔸 最佳实践：根据业务场景选择合适的传播行为
```

### 8.2 关键理解要点


**🔹 如何选择传播行为**：
```
决策流程：
1. 子方法必须和父方法同生共死？
   → 是：使用REQUIRED
   → 否：继续判断

2. 子方法失败是否影响父方法？
   → 不影响：使用REQUIRES_NEW + try-catch
   → 影响：使用REQUIRED

3. 需要部分回滚能力？
   → 是：使用NESTED
   → 否：使用REQUIRED

4. 不确定？
   → 默认使用REQUIRED（最安全）
```

**🔹 异常处理要点**：
```
异常类型：
• RuntimeException：默认回滚
• Exception：默认不回滚
• 建议业务异常继承RuntimeException

异常传播：
• REQUIRED：子异常影响父事务
• REQUIRES_NEW：子异常可被隔离
• NESTED：子异常可回滚到保存点

处理原则：
• REQUIRES_NEW必须配合try-catch
• 合理使用rollbackFor配置
• 注意UnexpectedRollbackException
```

**🔹 实战经验总结**：
```
常用组合模式：
1. 核心业务 + 核心业务 → REQUIRED + REQUIRED
2. 核心业务 + 日志记录 → REQUIRED + REQUIRES_NEW
3. 核心业务 + 通知发送 → REQUIRED + REQUIRES_NEW
4. 批量处理 + 单条处理 → REQUIRED + NESTED

避免的陷阱：
❌ 过度使用REQUIRES_NEW
❌ 忘记处理REQUIRES_NEW的异常
❌ 同类内部调用期望传播生效
❌ 不理解NESTED的限制
```

### 8.3 实际应用指导


**💼 业务场景应对策略**：

```
场景1：订单支付
问题：订单、库存、积分必须一致
方案：全部使用REQUIRED，保证原子性

场景2：订单+日志
问题：日志失败不应影响订单
方案：订单REQUIRED，日志REQUIRES_NEW + try-catch

场景3：批量导入
问题：允许部分成功，部分失败
方案：外层REQUIRED，内层NESTED

场景4：多步骤流程
问题：某步骤失败尝试其他方案
方案：使用NESTED，失败回滚到保存点
```

**🛠️ 代码实现要点**：

```java
// 1. 确保跨类调用
@Autowired
private OtherService otherService;  // ✅ 通过注入调用

// 2. 合理处理异常
@Transactional
public void process() {
    coreLogic();
    try {
        logService.log();  // REQUIRES_NEW
    } catch (Exception e) {
        // 捕获异常，不影响主流程
    }
}

// 3. 明确回滚规则
@Transactional(
    propagation = Propagation.REQUIRED,
    rollbackFor = Exception.class
)
public void process() {
    // ...
}

// 4. 使用NESTED注意数据库支持
@Transactional(propagation = Propagation.NESTED)
public void nestedMethod() {
    // 确保数据库支持保存点
}
```

**🎯 学习建议**：
```
学习路径：
1. 先理解事务的ACID特性
2. 掌握Spring事务的基本用法
3. 深入理解各种传播行为
4. 实践不同场景的组合应用
5. 总结经验，形成自己的方法论

实践建议：
• 从简单场景开始
• 使用日志观察事务行为
• 多做实验验证理解
• 关注生产环境的问题
• 持续优化和改进
```

**🧠 记忆口诀**：
```
REQUIRED同生死，一荣俱荣
REQUIRES_NEW独自立，成败自知
NESTED有保存点，可退可进
异常要处理，捕获是关键
跨类调用生效，同类调用失效
选择看场景，理解最重要
```

**核心理念**：
事务传播不是孤立的技术点，而是解决实际业务问题的工具。理解业务需求，选择合适的传播行为，合理处理异常，才能写出健壮可靠的事务代码！