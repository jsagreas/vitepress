---
title: 26、多数据源配置基础
---
## 📚 目录

1. [多数据源应用场景](#1-多数据源应用场景)
2. [多数据源配置方式](#2-多数据源配置方式)
3. [动态数据源切换](#3-动态数据源切换)
4. [多数据源事务管理](#4-多数据源事务管理)
5. [最佳实践与注意事项](#5-最佳实践与注意事项)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 多数据源应用场景


### 1.1 什么是多数据源


**通俗理解**：就像一个公司有多个仓库，不同的商品存放在不同的仓库里

```
单数据源（一个仓库）：          多数据源（多个仓库）：
     应用                          应用
      ↓                          ↙  ↓  ↘
    数据库                   数据库A 数据库B 数据库C
                            (用户库) (订单库) (商品库)

单数据源：所有数据都在一个数据库
多数据源：数据分散在多个数据库中
```

**核心概念**：
- **数据源（DataSource）**：连接数据库的配置信息（地址、用户名、密码等）
- **多数据源**：应用程序同时连接和使用多个数据库
- **数据源切换**：在不同数据库之间自由切换进行操作

### 1.2 为什么需要多数据源


**实际业务场景**：

```
场景1：业务拆分
电商系统：
├─ 用户数据库（UserDB）    → 存用户信息、登录数据
├─ 订单数据库（OrderDB）   → 存订单、支付记录
└─ 商品数据库（ProductDB） → 存商品、库存信息

原因：数据量太大，拆分成多个库更好管理

场景2：读写分离
主从架构：
├─ 主库（Master）  → 处理写操作（增删改）
└─ 从库（Slave）   → 处理读操作（查询）

原因：分担数据库压力，提升性能

场景3：多租户系统
SaaS平台：
├─ 租户A的数据库
├─ 租户B的数据库
└─ 租户C的数据库

原因：不同客户的数据需要隔离存储
```

> 💡 **核心价值**：多数据源让系统更灵活、性能更好、数据更安全

### 1.3 多数据源的核心挑战


**面临的问题**：

```
问题1：如何配置多个数据库连接？
问题2：如何在代码中指定使用哪个数据库？
问题3：如何在多个数据库之间切换？
问题4：跨多个数据库的事务如何保证一致性？
```

---

## 2. ⚙️ 多数据源配置方式


### 2.1 配置文件准备


**第一步：在application.yml中配置多个数据源**

```yaml
spring:
  datasource:
    # 主数据源（用户库）
    primary:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/user_db
      username: root
      password: 123456
    
    # 从数据源（订单库）
    secondary:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/order_db
      username: root
      password: 123456
```

> 📌 **配置说明**：
> - `primary`和`secondary`是自定义名称，你可以叫任何名字
> - 每个数据源都有自己的连接信息
> - 实际项目中密码要加密处理

### 2.2 使用@Primary指定主数据源


**方式一：手动配置多个DataSource**

```java
@Configuration
public class DataSourceConfig {
    
    // 配置主数据源
    @Primary  // 这个注解表示：默认用这个数据源
    @Bean(name = "primaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    // 配置从数据源
    @Bean(name = "secondaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }
}
```

**关键点解释**：

| 注解/配置 | **作用** | **通俗理解** |
|---------|---------|------------|
| `@Primary` | 标记主数据源 | 就像默认仓库，不指定就用这个 |
| `@Bean(name = "xxx")` | 给数据源起名字 | 方便后面根据名字找到对应的数据源 |
| `@ConfigurationProperties` | 绑定配置文件 | 自动把yml里的配置读进来 |

> ⚠️ **重要提示**：@Primary只能有一个，表示默认数据源

### 2.3 使用@Qualifier精确指定数据源


**为每个数据源配置事务管理器**

```java
@Configuration
public class TransactionConfig {
    
    // 主数据源的事务管理器
    @Primary
    @Bean(name = "primaryTransactionManager")
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier("primaryDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
    
    // 从数据源的事务管理器
    @Bean(name = "secondaryTransactionManager")
    public PlatformTransactionManager secondaryTransactionManager(
            @Qualifier("secondaryDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

**在Service中使用指定的数据源**

```java
@Service
public class UserService {
    
    // 使用主数据源的事务
    @Transactional(transactionManager = "primaryTransactionManager")
    public void createUser(User user) {
        // 这里的操作会在主数据库执行
        userMapper.insert(user);
    }
}

@Service
public class OrderService {
    
    // 使用从数据源的事务
    @Transactional(transactionManager = "secondaryTransactionManager")
    public void createOrder(Order order) {
        // 这里的操作会在订单数据库执行
        orderMapper.insert(order);
    }
}
```

> 💡 **核心理解**：
> - `@Qualifier`就像门牌号，告诉Spring用哪个数据源
> - 每个数据源对应一个事务管理器
> - 在@Transactional中指定事务管理器名称

---

## 3. 🔄 动态数据源切换


### 3.1 什么是动态数据源


**静态 vs 动态对比**：

```
静态配置：
UserService  → 写死用主库
OrderService → 写死用从库
缺点：不够灵活，代码写死了

动态切换：
同一个Service可以根据需要切换数据源
┌─────────────┐
│ UserService │
└──────┬──────┘
       ├─ 有时用主库
       └─ 有时用从库
优点：灵活，可以在运行时决定用哪个库
```

### 3.2 AbstractRoutingDataSource原理


**核心原理**：就像一个智能路由器，根据条件决定走哪个数据源

```
请求进来 → 看当前线程标记 → 选择对应数据源 → 执行操作

线程标记 = "master" → 走主库
线程标记 = "slave"  → 走从库
```

**实现步骤**：

```
步骤1：定义数据源路由器（继承AbstractRoutingDataSource）
      └─ 实现 determineCurrentLookupKey() 方法
         作用：返回当前要用的数据源标识

步骤2：用ThreadLocal存储数据源标识
      └─ 每个线程记录自己要用哪个数据源

步骤3：提供切换数据源的方法
      └─ 设置和清除数据源标识
```

### 3.3 动态数据源完整实现


**步骤1：数据源上下文（用ThreadLocal存储）**

```java
public class DataSourceContextHolder {
    
    // ThreadLocal：每个线程独立存储，互不影响
    private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();
    
    // 数据源标识常量
    public static final String MASTER = "master";
    public static final String SLAVE = "slave";
    
    // 设置数据源
    public static void setDataSource(String dataSource) {
        CONTEXT.set(dataSource);
    }
    
    // 获取当前数据源
    public static String getDataSource() {
        return CONTEXT.get();
    }
    
    // 清除数据源（用完必须清理，防止内存泄漏）
    public static void clear() {
        CONTEXT.remove();
    }
}
```

> 📌 **ThreadLocal简单理解**：
> - 就像每个人有自己的储物柜
> - 你存的东西别人拿不到，互不干扰
> - 用完要清空，不然会占用空间

**步骤2：动态数据源路由器**

```java
public class DynamicDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        // 返回当前线程的数据源标识
        // Spring会根据这个标识找到对应的数据源
        return DataSourceContextHolder.getDataSource();
    }
}
```

**步骤3：配置动态数据源**

```java
@Configuration
public class DynamicDataSourceConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @Primary
    public DataSource dynamicDataSource() {
        DynamicDataSource dataSource = new DynamicDataSource();
        
        // 设置默认数据源
        dataSource.setDefaultTargetDataSource(masterDataSource());
        
        // 配置多个数据源
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("master", masterDataSource());
        targetDataSources.put("slave", slaveDataSource());
        dataSource.setTargetDataSources(targetDataSources);
        
        return dataSource;
    }
}
```

> 💡 **配置理解**：
> - `defaultTargetDataSource`：默认数据源（没指定时用这个）
> - `targetDataSources`：所有可用的数据源（像个数据源仓库）
> - key对应数据源标识，value是实际的数据源对象

### 3.4 使用自定义注解切换数据源


**方式一：手动切换（比较繁琐）**

```java
@Service
public class UserService {
    
    public void queryUser() {
        // 手动设置用从库
        DataSourceContextHolder.setDataSource("slave");
        try {
            // 查询操作
            userMapper.selectById(1);
        } finally {
            // 用完必须清除
            DataSourceContextHolder.clear();
        }
    }
}
```

**方式二：注解切换（推荐，更优雅）**

```java
// 自定义注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DataSource {
    String value() default "master";  // 默认主库
}

// AOP拦截器
@Aspect
@Component
public class DataSourceAspect {
    
    @Around("@annotation(dataSource)")
    public Object around(ProceedingJoinPoint point, DataSource dataSource) 
            throws Throwable {
        try {
            // 设置数据源
            DataSourceContextHolder.setDataSource(dataSource.value());
            // 执行方法
            return point.proceed();
        } finally {
            // 清除数据源
            DataSourceContextHolder.clear();
        }
    }
}

// 使用示例
@Service
public class UserService {
    
    @DataSource("slave")  // 一个注解搞定，用从库查询
    public User queryUser(Long id) {
        return userMapper.selectById(id);
    }
    
    @DataSource("master")  // 用主库写入
    public void createUser(User user) {
        userMapper.insert(user);
    }
}
```

**切换流程图示**：

```
方法调用
   ↓
AOP拦截
   ↓
读取@DataSource注解 → 设置数据源标识到ThreadLocal
   ↓
执行方法 → DynamicDataSource根据标识选数据源
   ↓
finally清除标识 → 防止影响下次请求
```

---

## 4. 🔐 多数据源事务管理


### 4.1 单数据源事务（简单情况）


**场景**：一个方法只操作一个数据库

```java
@Service
public class UserService {
    
    @DataSource("master")
    @Transactional  // 只在master库开事务
    public void createUser(User user) {
        userMapper.insert(user);
        // 如果出错，只回滚master库的操作
    }
}
```

> ✅ **适用场景**：业务只涉及一个数据库，直接用@Transactional即可

### 4.2 跨数据源事务（复杂情况）


**问题场景**：一个方法需要操作多个数据库

```java
@Service
public class OrderService {
    
    @Transactional  // 这个事务管不了多个数据库！
    public void createOrder(Order order) {
        // 操作1：在order_db创建订单
        DataSourceContextHolder.setDataSource("order");
        orderMapper.insert(order);
        
        // 操作2：在product_db扣减库存
        DataSourceContextHolder.setDataSource("product");
        productMapper.updateStock(order.getProductId());
        
        // 问题：这两个库的事务无法保证一致性！
    }
}
```

**问题分析**：

```
场景：下订单+扣库存

正常流程：
订单库 → 创建订单 ✓
商品库 → 扣减库存 ✓
结果：都成功 ✓

异常流程：
订单库 → 创建订单 ✓
商品库 → 扣减库存 ✗（出错了）
结果：订单创建了，库存没扣 ✗
问题：数据不一致！
```

### 4.3 分布式事务解决方案


**方案对比表格**：

| 方案 | **原理** | **优点** | **缺点** | **适用场景** |
|-----|---------|---------|---------|------------|
| **JTA/XA** | 两阶段提交 | 强一致性 | 性能差，复杂 | 金融等强一致性要求 |
| **消息队列** | 最终一致性 | 性能好，解耦 | 需要MQ，复杂度高 | 允许短暂不一致 |
| **SAGA** | 补偿机制 | 灵活，性能好 | 业务代码复杂 | 长流程业务 |
| **本地消息表** | 本地事务+定时任务 | 简单可靠 | 延迟较高 | 中小型系统 |

**推荐方案：本地消息表（最实用）**

```java
@Service
public class OrderService {
    
    @Transactional("orderTransactionManager")
    public void createOrder(Order order) {
        // 步骤1：在订单库创建订单
        orderMapper.insert(order);
        
        // 步骤2：在订单库保存消息（库存扣减任务）
        Message msg = new Message();
        msg.setType("DEDUCT_STOCK");
        msg.setContent(order.getProductId() + ":" + order.getQuantity());
        messageMapper.insert(msg);
        
        // 这两步在同一个事务，要么都成功，要么都失败
    }
}

// 定时任务：处理消息
@Scheduled(fixedDelay = 1000)
public void processMessages() {
    List<Message> messages = messageMapper.selectPending();
    for (Message msg : messages) {
        if ("DEDUCT_STOCK".equals(msg.getType())) {
            // 调用商品服务扣减库存
            productService.deductStock(...);
            // 标记消息已处理
            messageMapper.markProcessed(msg.getId());
        }
    }
}
```

**流程图示**：

```
创建订单事务（订单库）：
┌──────────────────────┐
│ 1. 创建订单记录       │
│ 2. 创建扣库存消息     │  ← 同一个事务
└──────────────────────┘
         ↓
定时任务（异步处理）：
┌──────────────────────┐
│ 1. 读取待处理消息     │
│ 2. 调用商品服务扣库存  │
│ 3. 标记消息已处理     │
└──────────────────────┘
```

> 💡 **优势说明**：
> - 订单和消息在同一个事务，保证本地一致性
> - 定时任务保证最终会执行库存扣减
> - 如果扣库存失败，可以重试

---

## 5. 🎯 最佳实践与注意事项


### 5.1 多数据源配置建议


**配置清单**：

```
✅ 推荐做法：
- 主数据源用@Primary标记
- 给每个数据源起清晰的名字
- 配置独立的事务管理器
- 用连接池（HikariCP、Druid）
- 配置合理的超时时间

❌ 避免做法：
- 不标记@Primary导致找不到默认数据源
- 数据源名字混乱（db1、db2这种）
- 多个数据源共用一个事务管理器
- 不配置连接池
- 不设置超时参数
```

**完整配置示例**：

```yaml
spring:
  datasource:
    master:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/master_db
      username: root
      password: 123456
      hikari:
        minimum-idle: 5          # 最小空闲连接
        maximum-pool-size: 20    # 最大连接数
        connection-timeout: 30000  # 连接超时（毫秒）
    
    slave:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/slave_db
      username: root
      password: 123456
      hikari:
        minimum-idle: 3
        maximum-pool-size: 10
        connection-timeout: 30000
```

### 5.2 数据源切换注意事项


**重要提醒**：

> ⚠️ **必须清除ThreadLocal**

```java
// 错误示例（内存泄漏）
public void badExample() {
    DataSourceContextHolder.setDataSource("slave");
    userMapper.select();
    // 忘记清除，下次请求可能还是slave！
}

// 正确示例
public void goodExample() {
    try {
        DataSourceContextHolder.setDataSource("slave");
        userMapper.select();
    } finally {
        DataSourceContextHolder.clear();  // 必须清除
    }
}
```

> ⚠️ **事务中不能切换数据源**

```java
@Transactional
public void wrongExample() {
    // 已经在master库开启事务
    userMapper.insert(user);
    
    // 切换到slave库（无效！事务已经开启了）
    DataSourceContextHolder.setDataSource("slave");
    orderMapper.select();  // 还是在master库执行
}

// 正确做法：在事务外切换
@DataSource("slave")
@Transactional
public void correctExample() {
    // 注解在外层，事务开启前就确定了数据源
    orderMapper.select();
}
```

### 5.3 读写分离实践


**实现读写分离**：

```java
@Aspect
@Component
public class ReadWriteSplitAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        String methodName = point.getSignature().getName();
        
        // 根据方法名判断读写
        if (methodName.startsWith("select") || 
            methodName.startsWith("get") || 
            methodName.startsWith("query")) {
            // 读操作 → 从库
            DataSourceContextHolder.setDataSource("slave");
        } else {
            // 写操作 → 主库
            DataSourceContextHolder.setDataSource("master");
        }
        
        try {
            return point.proceed();
        } finally {
            DataSourceContextHolder.clear();
        }
    }
}
```

**读写分离架构图**：

```
          应用服务器
         ┌─────────┐
         │ Service │
         └────┬────┘
              │
      AOP自动判断读写
              │
        ┌─────┴─────┐
        ↓           ↓
   写操作(增删改)  读操作(查询)
        ↓           ↓
    ┌──────┐    ┌──────┐
    │ 主库  │→复制→│ 从库  │
    └──────┘    └──────┘
     Master       Slave
```

### 5.4 常见问题解决


**问题1：数据源无法切换**

```
原因：事务已开启，无法切换
解决：@DataSource注解放在@Transactional外层

错误：
@Transactional
@DataSource("slave")
public void query() { }

正确：
@DataSource("slave")
@Transactional
public void query() { }
```

**问题2：主从延迟导致查不到数据**

```
场景：
1. 主库写入数据
2. 立即从从库查询
3. 查不到（数据还没同步过来）

解决方案：
- 写入后短时间内强制读主库
- 增加重试机制
- 使用缓存过渡
```

**问题3：连接池耗尽**

```
现象：等待获取连接超时
原因：连接没有正确释放

排查：
1. 检查是否有长事务
2. 检查连接池配置是否合理
3. 监控连接使用情况

解决：
- 调大连接池
- 优化慢SQL
- 设置合理的超时时间
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 多数据源：应用连接多个数据库的技术方案
🔸 @Primary：标记默认数据源，系统找不到时用这个
🔸 @Qualifier：精确指定要用哪个数据源/事务管理器
🔸 动态数据源：运行时根据条件切换数据源
🔸 AbstractRoutingDataSource：Spring提供的数据源路由器
🔸 ThreadLocal：线程隔离存储，用于保存数据源标识
```

### 6.2 关键理解要点


**🔹 多数据源配置流程**

```
1. 配置文件定义多个数据源
   ↓
2. 创建DataSource Bean（用@Primary标记主库）
   ↓
3. 为每个数据源配置事务管理器
   ↓
4. 使用@Qualifier或动态路由选择数据源
```

**🔹 动态切换核心机制**

```
ThreadLocal存标识 → AbstractRoutingDataSource读标识 → 选择数据源

重点：
- 用ThreadLocal保证线程隔离
- 用完必须clear()防止内存泄漏
- 不能在事务中切换数据源
```

**🔹 多数据源事务处理**

```
单库事务：
- 直接用@Transactional
- 指定对应的事务管理器

跨库事务：
- 简单场景：本地消息表
- 复杂场景：分布式事务（JTA、SAGA等）
- 核心：保证最终一致性
```

### 6.3 实际应用建议


**适用场景判断**：

```
✅ 适合用多数据源：
- 业务拆分（用户库、订单库分开）
- 读写分离（主从架构）
- 多租户系统（每个租户独立库）
- 历史数据归档（冷热数据分离）

❌ 不建议用多数据源：
- 业务高度耦合，经常跨库查询
- 对事务一致性要求极高
- 团队经验不足，运维能力弱
```

**最佳实践清单**：

```
1. 配置规范
   ✓ 主库用@Primary标记
   ✓ 配置独立的事务管理器
   ✓ 使用连接池并合理配置参数

2. 代码规范
   ✓ ThreadLocal用完必须清除
   ✓ 用注解切换比手动切换更优雅
   ✓ 事务注解在数据源注解内层

3. 事务处理
   ✓ 单库事务直接用@Transactional
   ✓ 跨库事务用本地消息表或MQ
   ✓ 读写分离注意主从延迟

4. 运维监控
   ✓ 监控各数据源连接池状态
   ✓ 记录数据源切换日志
   ✓ 设置合理的超时和重试
```

### 6.4 知识点掌握自检


**基础级别**（⭐必知必会）：
- [ ] 理解什么是多数据源及应用场景
- [ ] 会配置多个DataSource
- [ ] 知道@Primary和@Qualifier的作用
- [ ] 能手动切换数据源

**进阶级别**（⭐⭐实用技能）：
- [ ] 理解AbstractRoutingDataSource原理
- [ ] 会用注解+AOP实现动态切换
- [ ] 掌握读写分离的实现
- [ ] 理解ThreadLocal的作用和清除时机

**高级级别**（⭐⭐⭐生产实战）：
- [ ] 能处理跨数据源事务问题
- [ ] 理解分布式事务解决方案
- [ ] 能排查多数据源常见问题
- [ ] 能设计合理的多数据源架构

**核心记忆口诀**：
```
多数据源要配好，Primary主库不能少
Qualifier精确指，动态切换更灵巧
ThreadLocal存标识，用完清除很重要
跨库事务需谨慎，最终一致是王道
读写分离提性能，主从延迟要知道
```