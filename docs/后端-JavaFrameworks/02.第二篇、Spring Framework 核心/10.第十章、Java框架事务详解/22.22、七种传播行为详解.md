---
title: 22、七种传播行为详解
---
## 📚 目录

1. [事务传播机制是什么](#1-事务传播机制是什么)
2. [REQUIRED - 最常用的传播行为](#2-REQUIRED-最常用的传播行为)
3. [REQUIRES_NEW - 独立事务](#3-REQUIRES_NEW-独立事务)
4. [NESTED - 嵌套事务](#4-NESTED-嵌套事务)
5. [SUPPORTS - 支持型传播](#5-SUPPORTS-支持型传播)
6. [MANDATORY - 强制要求事务](#6-MANDATORY-强制要求事务)
7. [NOT_SUPPORTED - 非事务执行](#7-NOT_SUPPORTED-非事务执行)
8. [NEVER - 禁止事务](#8-NEVER-禁止事务)
9. [传播行为如何选择](#9-传播行为如何选择)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🤔 事务传播机制是什么


### 1.1 生活中的例子理解传播机制


**想象你在公司办事：**

```
场景1：你去财务部报销
- 如果财务部正在处理账务（有事务），你的报销就加入他们的账务处理中
- 如果财务部没在处理账务（无事务），会专门为你开启一个账务处理流程

这就是 REQUIRED 传播行为的逻辑！
```

**核心问题**：当一个有事务的方法A调用另一个有事务的方法B时，B应该：
- 加入A的事务？
- 还是开启自己的新事务？
- 还是不要事务？

> 💡 **简单理解**：传播行为就是定义"方法调用时，事务该如何传递"的规则

### 1.2 为什么需要传播机制


**实际开发场景：**

```
订单服务                      积分服务
createOrder() {              addPoints() {
    // 创建订单               // 增加积分
    // 需要事务               // 需要事务
    
    addPoints();  ← 这里调用了另一个事务方法
}
```

**关键问题**：
- `addPoints()` 要不要加入 `createOrder()` 的事务？
- 如果积分添加失败，订单要不要回滚？
- 如果订单创建失败，积分要不要回滚？

> ⚠️ **注意**：不同的业务需求，需要不同的传播行为来处理

### 1.3 七种传播行为概览


| 传播行为 | 说明 | 使用频率 |
|---------|------|---------|
| **REQUIRED** | 有事务就加入，没有就新建 | ⭐⭐⭐⭐⭐ 最常用 |
| **REQUIRES_NEW** | 总是开启新事务 | ⭐⭐⭐⭐ 常用 |
| **NESTED** | 嵌套事务，有保存点 | ⭐⭐⭐ 较常用 |
| **SUPPORTS** | 有事务就加入，没有就非事务执行 | ⭐⭐ 少用 |
| **MANDATORY** | 必须在事务中运行，否则抛异常 | ⭐ 很少用 |
| **NOT_SUPPORTED** | 挂起当前事务，以非事务方式执行 | ⭐ 很少用 |
| **NEVER** | 不能在事务中运行，否则抛异常 | ⭐ 很少用 |

---

## 2. 🔵 REQUIRED - 最常用的传播行为


### 2.1 REQUIRED是什么


**官方定义**：支持当前事务，如果当前没有事务，就新建一个事务

**通俗理解**：
```
像是"搭便车"机制：
- 有车（事务）就上车，大家一起到终点
- 没车就自己开一辆
- 多个方法共享一辆车，同生共死
```

### 2.2 REQUIRED工作原理


**场景1：外层方法有事务**

```
方法A (有事务)                方法B (REQUIRED)
    |                            |
    |------ 调用 B ------>       |
    |                            | 加入A的事务
    |<----- 返回 ------         |
    |                            |
共用同一个事务，A和B要么一起成功，要么一起失败
```

**场景2：外层方法无事务**

```
方法A (无事务)                方法B (REQUIRED)
    |                            |
    |------ 调用 B ------>       | 新建事务
    |                            | 在新事务中执行
    |<----- 返回 ------         |
```

### 2.3 代码示例


```java
@Service
public class OrderService {
    
    @Autowired
    private PointService pointService;
    
    // 默认就是 REQUIRED
    @Transactional
    public void createOrder(Order order) {
        // 1. 保存订单
        orderRepository.save(order);
        
        // 2. 增加积分（也是REQUIRED）
        pointService.addPoints(order.getUserId(), 100);
        
        // 两个方法在同一个事务中
        // 任何一个失败，都会一起回滚
    }
}

@Service
public class PointService {
    
    @Transactional  // 默认REQUIRED
    public void addPoints(Long userId, int points) {
        Point point = pointRepository.findByUserId(userId);
        point.setAmount(point.getAmount() + points);
        pointRepository.save(point);
    }
}
```

**执行流程图：**

```
createOrder() 开启事务
    |
    ├─> 保存订单（在事务中）
    |
    ├─> 调用 addPoints()
    |      └─> 加入当前事务
    |      └─> 增加积分（在同一事务中）
    |
    └─> 提交事务（订单和积分一起提交）
    
如果任何地方出错 → 全部回滚
```

### 2.4 REQUIRED的特点


**优点：**
- ✅ 简单直观，符合大多数业务需求
- ✅ 数据一致性好，要么全成功，要么全失败
- ✅ Spring默认的传播行为，不需要额外配置

**缺点：**
- ❌ 耦合度高，一个方法失败会导致所有方法回滚
- ❌ 不适合部分成功的业务场景

> 🎯 **使用建议**：当你需要"全部成功或全部失败"的强一致性时使用

---

## 3. 🟢 REQUIRES_NEW - 独立事务


### 3.1 REQUIRES_NEW是什么


**官方定义**：总是创建新事务，如果当前存在事务，就把当前事务挂起

**通俗理解**：
```
像是"开新车"机制：
- 不管外面有没有车（事务），我都自己开一辆新车
- 我的车和别人的车互不影响
- 我到不到终点，不影响别人
```

### 3.2 REQUIRES_NEW工作原理


**事务挂起示意图：**

```
外层事务A
    |
    ├─> 执行业务逻辑
    |
    ├─> 调用方法B (REQUIRES_NEW)
    |      |
    |      ├─> 挂起事务A  ⏸️
    |      |
    |      ├─> 开启新事务B  🆕
    |      |
    |      ├─> 执行业务逻辑
    |      |
    |      └─> 提交/回滚事务B  ✅
    |
    ├─> 恢复事务A  ▶️
    |
    └─> 继续执行
```

### 3.3 典型应用场景


**场景：记录操作日志**

```java
@Service
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    @Transactional
    public void createOrder(Order order) {
        try {
            // 1. 创建订单
            orderRepository.save(order);
            
            // 2. 记录日志（REQUIRES_NEW）
            logService.saveLog("创建订单: " + order.getId());
            
            // 3. 其他业务逻辑
            // ...
            
        } catch (Exception e) {
            // 即使订单创建失败，日志也要保存
        }
    }
}

@Service
public class LogService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String message) {
        Log log = new Log();
        log.setMessage(message);
        log.setCreateTime(new Date());
        logRepository.save(log);
        // 这个方法在独立的事务中执行
        // 不受外层事务影响
    }
}
```

**关键特性：**

```
订单事务失败 → 回滚        ❌ 订单不保存
   ↓
日志事务成功 → 提交        ✅ 日志依然保存
```

> 💡 **核心价值**：实现"部分失败不影响全部"的业务需求

### 3.4 注意事项


**重要警告：**

> ⚠️ **注意1**：REQUIRES_NEW会真正开启新的数据库连接，消耗连接池资源

> ⚠️ **注意2**：外层事务失败回滚时，REQUIRES_NEW的内层事务已经提交，不会回滚

**死锁风险示例：**

```java
@Transactional
public void methodA() {
    // 获取了表A的锁
    updateTableA();
    
    // 调用REQUIRES_NEW方法
    methodB();  // 这里想获取表A的锁，但被methodA占用
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    updateTableA();  // ⚠️ 可能造成死锁！
}
```

---

## 4. 🟡 NESTED - 嵌套事务


### 4.1 NESTED是什么


**官方定义**：如果当前存在事务，则在嵌套事务内执行；如果没有事务，则表现像REQUIRED

**通俗理解**：
```
像是"保存游戏进度"机制：
- 外层事务是游戏整体进度
- 内层事务是一个关卡
- 关卡失败可以回到关卡开始（保存点）
- 但整个游戏失败，所有进度都丢失
```

### 4.2 NESTED的核心机制


**保存点(Savepoint)工作原理：**

```
外层事务开始
    |
    ├─> 执行业务逻辑A
    |
    ├─> 设置保存点 📍 Savepoint
    |
    ├─> 执行嵌套事务B
    |      |
    |      └─> 成功 → 继续
    |      └─> 失败 → 回滚到保存点 📍
    |
    ├─> 继续执行业务逻辑C
    |
    └─> 提交整个事务
```

### 4.3 NESTED vs REQUIRES_NEW对比


```
┌─────────────────────────────────────────────┐
│              NESTED（嵌套事务）              │
├─────────────────────────────────────────────┤
│  外层事务                                    │
│    ├─> 逻辑A                                │
│    ├─> [保存点]                             │
│    ├─> 嵌套事务（可回滚到保存点）            │
│    └─> 逻辑B                                │
│                                             │
│  特点：共享同一个物理事务，使用保存点        │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│           REQUIRES_NEW（独立事务）           │
├─────────────────────────────────────────────┤
│  外层事务（挂起）⏸️                          │
│                                             │
│  新事务（完全独立）🆕                        │
│    └─> 执行完毕，提交/回滚                  │
│                                             │
│  外层事务（恢复）▶️                          │
│                                             │
│  特点：开启新的物理事务，完全独立            │
└─────────────────────────────────────────────┘
```

### 4.4 NESTED使用场景


**场景：批量导入数据**

```java
@Service
public class ImportService {
    
    @Transactional
    public void importUsers(List<User> users) {
        int successCount = 0;
        
        for (User user : users) {
            try {
                // 使用嵌套事务导入单个用户
                importSingleUser(user);
                successCount++;
            } catch (Exception e) {
                // 单个用户失败，回滚到保存点
                // 不影响其他用户的导入
                log.error("导入用户失败: " + user.getName(), e);
            }
        }
        
        log.info("成功导入 {} 个用户", successCount);
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void importSingleUser(User user) {
        // 验证用户
        validateUser(user);
        
        // 保存用户
        userRepository.save(user);
        
        // 保存用户扩展信息
        saveUserProfile(user);
    }
}
```

**执行效果：**

```
导入100个用户：
✅ 用户1 导入成功
✅ 用户2 导入成功  
❌ 用户3 导入失败 → 仅回滚用户3，继续导入
✅ 用户4 导入成功
...

最终：97个成功，3个失败
```

### 4.5 NESTED特点总结


**特点对比表：**

| 特性 | NESTED | REQUIRES_NEW |
|-----|--------|--------------|
| **事务数量** | 1个物理事务 | 2个物理事务 |
| **回滚影响** | 内层回滚不影响外层 | 完全独立 |
| **外层回滚** | 内层一起回滚 | 内层已提交，不回滚 |
| **数据库连接** | 共享连接 | 需要新连接 |
| **性能开销** | 较小 | 较大 |

> 🎯 **使用建议**：适合"部分失败可接受，但整体失败要全部回滚"的场景

---

## 5. ⚪ SUPPORTS - 支持型传播


### 5.1 SUPPORTS是什么


**官方定义**：支持当前事务，如果当前没有事务，就以非事务方式执行

**通俗理解**：
```
像是"随遇而安"机制：
- 有事务我就加入（搭车）
- 没事务我就走路（非事务执行）
- 对事务要求不高，灵活适应
```

### 5.2 SUPPORTS工作场景


**场景1：有外层事务**

```java
@Service
public class UserService {
    
    @Transactional
    public void updateUser(User user) {
        userRepository.save(user);
        
        // 查询用户信息，加入当前事务
        getUserInfo(user.getId());
    }
    
    @Transactional(propagation = Propagation.SUPPORTS)
    public User getUserInfo(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
```

**场景2：无外层事务**

```java
// 直接调用查询方法，以非事务方式执行
User user = userService.getUserInfo(123L);
// 此时没有事务，直接查询数据库
```

### 5.3 SUPPORTS的实际价值


**查询方法的典型用法：**

```java
@Service
public class ProductService {
    
    // 查询方法使用SUPPORTS
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public Product getProduct(Long id) {
        return productRepository.findById(id).orElse(null);
    }
    
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public List<Product> listProducts() {
        return productRepository.findAll();
    }
}
```

**优势：**
- ✅ 在事务中调用：共享事务，减少连接开销
- ✅ 非事务中调用：不创建事务，提高性能
- ✅ 适合读操作，灵活性高

> 💡 **使用建议**：适合查询方法，可能在事务内外都会被调用

---

## 6. 🔴 MANDATORY - 强制要求事务


### 6.1 MANDATORY是什么


**官方定义**：必须在现有事务中运行，如果当前没有事务，则抛出异常

**通俗理解**：
```
像是"必须有车票才能上车"机制：
- 有票（事务）就上车
- 没票（无事务）就不让上车，抛异常
```

### 6.2 使用场景


**强制业务规则检查：**

```java
@Service
public class PaymentService {
    
    @Transactional
    public void processPayment(Order order) {
        // 开启事务
        
        // 调用强制需要事务的方法
        deductInventory(order);
    }
    
    // 必须在事务中执行
    @Transactional(propagation = Propagation.MANDATORY)
    public void deductInventory(Order order) {
        // 扣减库存必须在事务中进行
        // 防止数据不一致
        
        if (当前没有事务) {
            throw new IllegalTransactionStateException(
                "扣减库存必须在事务中执行！"
            );
        }
        
        inventoryRepository.deduct(order.getProductId(), order.getQuantity());
    }
}
```

**错误示例：**

```java
// ❌ 错误：直接调用MANDATORY方法
paymentService.deductInventory(order);
// 抛出异常：No existing transaction found for transaction marked with propagation 'mandatory'
```

> ⚠️ **使用场景**：用于强制某些关键操作必须在事务上下文中执行

---

## 7. ⚫ NOT_SUPPORTED - 非事务执行


### 7.1 NOT_SUPPORTED是什么


**官方定义**：以非事务方式执行，如果当前存在事务，则挂起当前事务

**通俗理解**：
```
像是"我要走路，不坐车"机制：
- 有车（事务）我也不坐，让车等着（挂起）
- 我走路完成任务（非事务执行）
- 完事后车再开（恢复事务）
```

### 7.2 使用场景


**场景：批量统计或日志记录**

```java
@Service
public class ReportService {
    
    @Transactional
    public void generateReport() {
        // 在事务中处理核心业务
        processData();
        
        // 调用非事务方法生成报表
        // 避免长时间占用数据库连接
        generateStatistics();
    }
    
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void generateStatistics() {
        // 挂起外层事务
        // 以非事务方式执行
        
        // 执行耗时的统计操作
        // 不影响主事务的性能
        
        List<Data> data = fetchLargeDataSet();
        calculateStatistics(data);
        saveReport(data);
    }
}
```

**适用场景：**
- 📊 耗时的统计分析操作
- 📝 大量数据的批量处理
- 🔍 不需要事务保证的查询操作

> 💡 **核心价值**：避免长事务，提高系统性能

---

## 8. 🔵 NEVER - 禁止事务


### 8.1 NEVER是什么


**官方定义**：以非事务方式执行，如果当前存在事务，则抛出异常

**通俗理解**：
```
像是"禁止开车"机制：
- 如果有车（事务），就报错
- 只能走路（非事务）
```

### 8.2 使用场景


**强制非事务执行：**

```java
@Service
public class CacheService {
    
    // 缓存操作禁止在事务中执行
    @Transactional(propagation = Propagation.NEVER)
    public void refreshCache() {
        if (当前有事务) {
            throw new IllegalTransactionStateException(
                "缓存刷新不能在事务中执行！"
            );
        }
        
        // 刷新缓存
        cache.clear();
        cache.loadData();
    }
}
```

> ⚠️ **使用场景极少**：主要用于明确禁止在事务中执行的操作

---

## 9. 🎯 传播行为如何选择


### 9.1 选择决策树


```
开始选择传播行为
    |
    ├─> 是否需要事务保证？
    |      |
    |      ├─> 是 → 继续判断
    |      └─> 否 → SUPPORTS 或 NOT_SUPPORTED
    |
    ├─> 是否需要独立提交/回滚？
    |      |
    |      ├─> 是 → REQUIRES_NEW
    |      └─> 否 → 继续判断
    |
    ├─> 是否允许部分失败？
    |      |
    |      ├─> 是 → NESTED
    |      └─> 否 → REQUIRED
    |
    └─> 是否强制要求/禁止事务？
           |
           ├─> 强制要求 → MANDATORY
           └─> 强制禁止 → NEVER
```

### 9.2 常见业务场景推荐


| 业务场景 | 推荐传播行为 | 原因 |
|---------|-------------|------|
| **普通业务方法** | `REQUIRED` | 默认选择，保证数据一致性 |
| **操作日志记录** | `REQUIRES_NEW` | 日志独立保存，不受业务回滚影响 |
| **批量导入数据** | `NESTED` | 单条失败不影响整体，整体失败全部回滚 |
| **查询方法** | `SUPPORTS` | 灵活适应，提高性能 |
| **扣库存/扣款** | `MANDATORY` | 强制在事务中执行，保证安全 |
| **统计报表** | `NOT_SUPPORTED` | 避免长事务，提高性能 |
| **缓存操作** | `NEVER` | 禁止在事务中执行 |

### 9.3 实际项目案例


**电商订单场景完整示例：**

```java
@Service
public class OrderService {
    
    @Autowired
    private InventoryService inventoryService;
    @Autowired
    private PaymentService paymentService;
    @Autowired
    private LogService logService;
    @Autowired
    private NotificationService notificationService;
    
    @Transactional  // REQUIRED：主业务事务
    public void createOrder(OrderDTO dto) {
        // 1. 创建订单
        Order order = new Order();
        // ... 设置订单信息
        orderRepository.save(order);
        
        // 2. 扣减库存（MANDATORY：必须在事务中）
        inventoryService.deductInventory(order);
        
        // 3. 处理支付（REQUIRES_NEW：独立事务）
        paymentService.processPayment(order);
        
        // 4. 记录日志（REQUIRES_NEW：独立事务）
        logService.saveLog("订单创建", order.getId());
        
        // 5. 发送通知（NOT_SUPPORTED：非事务）
        notificationService.sendOrderNotification(order);
    }
}

@Service
public class InventoryService {
    @Transactional(propagation = Propagation.MANDATORY)
    public void deductInventory(Order order) {
        // 必须在事务中执行
    }
}

@Service
public class PaymentService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void processPayment(Order order) {
        // 独立事务，不受订单事务影响
    }
}

@Service
public class LogService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String action, Long orderId) {
        // 独立事务，确保日志一定保存
    }
}

@Service
public class NotificationService {
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void sendOrderNotification(Order order) {
        // 非事务执行，避免影响主流程
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 七种传播行为速记


**口诀记忆：**

> 🧠 **REQUIRED最常用，有无事务都能行**  
> **REQUIRES_NEW开新车，独立事务不相干**  
> **NESTED像关卡，失败回到保存点**  
> **SUPPORTS随遇安，有无事务都不管**  
> **MANDATORY强要求，无事务就报错**  
> **NOT_SUPPORTED不要事务，挂起等待慢慢走**  
> **NEVER最严格,有事务就抛异常**

### 10.2 传播行为对比表


| 传播行为 | 外层有事务 | 外层无事务 | 独立性 | 使用频率 |
|---------|----------|----------|-------|---------|
| **REQUIRED** | 加入 | 新建 | 不独立 | ⭐⭐⭐⭐⭐ |
| **REQUIRES_NEW** | 新建（挂起外层） | 新建 | 完全独立 | ⭐⭐⭐⭐ |
| **NESTED** | 嵌套执行 | 新建 | 部分独立 | ⭐⭐⭐ |
| **SUPPORTS** | 加入 | 非事务执行 | 不独立 | ⭐⭐ |
| **MANDATORY** | 加入 | 抛异常 | 不独立 | ⭐ |
| **NOT_SUPPORTED** | 挂起，非事务执行 | 非事务执行 | 独立 | ⭐ |
| **NEVER** | 抛异常 | 非事务执行 | 独立 | ⭐ |

### 10.3 选择建议


**🎯 新手建议：**

1. **80%的场景用REQUIRED**
   - 最常用，最安全
   - 保证数据一致性

2. **需要独立提交用REQUIRES_NEW**
   - 日志记录
   - 独立的子流程

3. **批量操作考虑NESTED**
   - 数据导入
   - 批量处理

4. **其他三种谨慎使用**
   - 了解特性后再用
   - 避免滥用

### 10.4 常见误区


> ❌ **误区1**：所有方法都用REQUIRED  
> ✅ **正确**：根据业务需求选择合适的传播行为

> ❌ **误区2**：REQUIRES_NEW可以解决所有问题  
> ✅ **正确**：REQUIRES_NEW会增加连接消耗，可能导致死锁

> ❌ **误区3**：NESTED和REQUIRES_NEW是一样的  
> ✅ **正确**：NESTED是嵌套事务（保存点），REQUIRES_NEW是独立事务

> ❌ **误区4**：传播行为可以随便改  
> ✅ **正确**：改变传播行为可能影响数据一致性，需要充分测试

### 10.5 实战检查清单


**使用传播行为前的检查：**

- [ ] 是否真的需要事务？
- [ ] 是否需要独立提交/回滚？
- [ ] 是否允许部分失败？
- [ ] 是否会影响性能？
- [ ] 是否会导致死锁？
- [ ] 异常处理是否正确？

**核心记住：**
- 📌 传播行为决定事务如何传递
- 📌 REQUIRED是默认且最常用的
- 📌 REQUIRES_NEW用于独立事务
- 📌 NESTED适合部分失败场景
- 📌 其他四种根据特殊需求使用
- 📌 选择传播行为要考虑业务场景和性能影响