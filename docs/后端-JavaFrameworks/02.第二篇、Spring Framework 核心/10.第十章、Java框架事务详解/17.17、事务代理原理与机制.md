---
title: 17、事务代理原理与机制
---
## 📚 目录

1. [什么是事务代理](#1-什么是事务代理)
2. [Spring的两种代理方式](#2-Spring的两种代理方式)
3. [事务代理的创建过程](#3-事务代理的创建过程)
4. [TransactionInterceptor拦截器](#4-TransactionInterceptor拦截器)
5. [代理创建时机分析](#5-代理创建时机分析)
6. [AOP增强原理](#6-AOP增强原理)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎭 什么是事务代理


### 1.1 为什么需要代理


**现实场景类比：**
```
你去银行转账 → 不是直接操作数据库
              ↓
            银行柜员（代理）帮你操作
              ↓
            柜员会检查余额、记录日志、处理异常
```

在Spring中，事务代理就像这个"银行柜员"，它帮你的业务方法加上事务管理功能。

**核心问题：**
```java
// 你写的原始方法
public void transfer(String from, String to, int money) {
    accountDao.deduct(from, money);  // 扣钱
    accountDao.add(to, money);       // 加钱
}

// 问题：如果加钱失败，扣的钱怎么办？
// 需要：开启事务 → 执行方法 → 提交/回滚
```

**代理的作用：**
- 🔸 **不修改原始代码**：你的业务方法保持简洁
- 🔸 **自动添加事务逻辑**：代理帮你加上开启、提交、回滚
- 🔸 **透明化处理**：你感觉不到代理的存在

### 1.2 代理的工作原理


**简单理解：**
```
客户端调用                代理对象                  真实对象
   |                        |                        |
   |--调用方法------------->|                        |
   |                        |--1.开启事务            |
   |                        |--2.调用真实方法------->|
   |                        |                        |--执行业务逻辑
   |                        |<--3.返回结果----------|
   |                        |--4.提交/回滚事务       |
   |<--返回最终结果---------|                        |
```

**关键理解：**
- 代理对象是**真实对象的替身**
- 客户端以为调用的是真实对象，实际调用的是代理
- 代理在调用真实方法前后，添加了事务管理逻辑

---

## 2. 🔧 Spring的两种代理方式


### 2.1 代理方式对比


| 代理方式 | 实现原理 | 使用条件 | 性能 | 常见场景 |
|---------|---------|---------|------|---------|
| **JDK动态代理** | 基于接口，使用反射 | 目标类必须实现接口 | 较快 | Service实现了接口 |
| **CGLIB代理** | 基于继承，生成子类 | 目标类不能是final | 稍慢 | Service没有接口 |

### 2.2 JDK动态代理详解


**工作原理：**
```
接口：UserService
        ↑ 实现
真实类：UserServiceImpl
        ↑ 代理
代理类：$Proxy0 (JDK自动生成)
```

**适用场景示例：**
```java
// 场景1：有接口的Service
public interface UserService {
    void save(User user);
}

@Service
public class UserServiceImpl implements UserService {
    @Transactional
    public void save(User user) {
        // 业务逻辑
    }
}
```

**Spring会这样做：**
1. 发现`UserServiceImpl`实现了接口`UserService`
2. 使用JDK动态代理创建代理对象
3. 代理对象实现了`UserService`接口
4. 在`save()`方法前后加上事务逻辑

**核心代码逻辑：**
```java
// Spring内部简化逻辑
Object proxy = Proxy.newProxyInstance(
    classLoader,
    new Class[]{UserService.class},  // 实现的接口
    new InvocationHandler() {
        public Object invoke(Object proxy, Method method, Object[] args) {
            // 1. 开启事务
            TransactionStatus status = transactionManager.getTransaction();
            try {
                // 2. 调用真实方法
                Object result = method.invoke(target, args);
                // 3. 提交事务
                transactionManager.commit(status);
                return result;
            } catch (Exception e) {
                // 4. 回滚事务
                transactionManager.rollback(status);
                throw e;
            }
        }
    }
);
```

### 2.3 CGLIB代理详解


**工作原理：**
```
真实类：UserService (没有接口)
         ↑ 继承
代理类：UserService$$EnhancerByCGLIB$$123 (CGLIB生成的子类)
```

**适用场景示例：**
```java
// 场景2：没有接口的Service
@Service
public class OrderService {
    @Transactional
    public void createOrder(Order order) {
        // 业务逻辑
    }
}
```

**Spring会这样做：**
1. 发现`OrderService`没有实现接口
2. 使用CGLIB创建`OrderService`的子类作为代理
3. 在子类中重写`createOrder()`方法
4. 在重写的方法中加入事务逻辑

**关键限制：**
- ⚠️ 类不能是`final`（无法被继承）
- ⚠️ 方法不能是`final`（无法被重写）
- ⚠️ 方法不能是`private`（子类无法访问）

### 2.4 Spring如何选择代理方式


**自动选择逻辑：**
```
Spring扫描到带@Transactional的Bean
            ↓
    是否实现了接口？
      ↙        ↘
    是          否
    ↓           ↓
JDK动态代理   CGLIB代理
```

**强制指定方式：**
```java
// 配置类中指定
@EnableTransactionManagement(proxyTargetClass = true)
public class AppConfig {
    // proxyTargetClass = false: 优先使用JDK代理（默认）
    // proxyTargetClass = true:  强制使用CGLIB代理
}
```

---

## 3. 🏗️ 事务代理的创建过程


### 3.1 核心配置类


**ProxyTransactionManagementConfiguration的作用：**

这是Spring启用声明式事务时的核心配置类，它负责准备创建代理所需的"工具"。

**简单理解：**
```
@EnableTransactionManagement 注解
            ↓ 导入
ProxyTransactionManagementConfiguration
            ↓ 注册三个核心Bean
    ┌───────┴────────┐
    ↓                ↓
事务通知器         事务拦截器
(Advisor)        (Interceptor)
```

**核心Bean注册：**
```java
@Configuration
public class ProxyTransactionManagementConfiguration {
    
    // Bean1: 事务增强器 - 决定哪些方法需要事务
    @Bean
    public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() {
        BeanFactoryTransactionAttributeSourceAdvisor advisor = 
            new BeanFactoryTransactionAttributeSourceAdvisor();
        advisor.setTransactionAttributeSource(transactionAttributeSource());
        advisor.setAdvice(transactionInterceptor());  // 设置拦截器
        return advisor;
    }
    
    // Bean2: 事务属性源 - 解析@Transactional注解
    @Bean
    public TransactionAttributeSource transactionAttributeSource() {
        return new AnnotationTransactionAttributeSource();
    }
    
    // Bean3: 事务拦截器 - 实际执行事务逻辑
    @Bean
    public TransactionInterceptor transactionInterceptor() {
        TransactionInterceptor interceptor = new TransactionInterceptor();
        interceptor.setTransactionAttributeSource(transactionAttributeSource());
        return interceptor;
    }
}
```

**通俗解释各个Bean：**

- **TransactionAttributeSource（属性源）**
  - 作用：读取和解析`@Transactional`注解的配置
  - 类比：就像一本"说明书"，告诉你每个方法的事务要求

- **TransactionInterceptor（拦截器）**
  - 作用：真正执行事务开启、提交、回滚的逻辑
  - 类比：就像"执行者"，按照说明书执行具体操作

- **BeanFactoryTransactionAttributeSourceAdvisor（通知器）**
  - 作用：把属性源和拦截器组合起来，告诉Spring哪些类需要代理
  - 类比：就像"调度员"，决定谁需要事务管理

### 3.2 代理创建流程


**完整流程图：**
```
1. Spring启动，扫描Bean
         ↓
2. 发现@Transactional注解
         ↓
3. 触发AOP代理创建
         ↓
4. 选择代理方式（JDK/CGLIB）
         ↓
5. 创建代理对象
         ↓
6. 将代理对象注册到容器
         ↓
7. 替换原始Bean
```

**详细步骤说明：**

**步骤1-2：Bean扫描与识别**
```java
// Spring扫描到这个类
@Service
public class UserServiceImpl implements UserService {
    @Transactional  // ← Spring识别到这个注解
    public void saveUser(User user) {
        userDao.insert(user);
    }
}
```

**步骤3-4：判断代理方式**
```java
// Spring内部判断逻辑（简化版）
if (UserServiceImpl实现了接口) {
    if (强制使用CGLIB) {
        使用CGLIB代理;
    } else {
        使用JDK动态代理;
    }
} else {
    使用CGLIB代理;
}
```

**步骤5-6：创建并注册代理**
```java
// 创建代理对象
Object proxy = 代理工厂.createProxy(UserServiceImpl.class);

// 把代理对象放入Spring容器
容器.registerBean("userServiceImpl", proxy);
```

**步骤7：替换原始Bean**
```
容器中的对象：
┌─────────────────────┐
│ Bean名称：userServiceImpl │
│ 实际对象：Proxy代理对象   │  ← 不是原始的UserServiceImpl
│ 类型：UserService接口    │
└─────────────────────┘
```

### 3.3 关键时机点


**Q: 什么时候创建代理？**

**A: Bean初始化之后，放入容器之前**

```
Bean生命周期：
实例化 → 属性赋值 → 初始化 → [创建代理] → 放入容器 → 使用
                              ↑
                          就在这里！
```

**为什么是这个时机？**
- ✅ Bean已经完全初始化，属性都设置好了
- ✅ 还没放入容器，可以用代理替换原始对象
- ✅ 后续使用时，拿到的就是代理对象

---

## 4. 🎯 TransactionInterceptor拦截器


### 4.1 拦截器的核心职责


**TransactionInterceptor是事务的"实际执行者"**

它负责：
- 🔸 在方法执行前：开启事务
- 🔸 方法执行中：监控异常
- 🔸 方法执行后：提交或回滚事务

### 4.2 拦截器工作流程


**执行流程图：**
```
客户端调用方法
      ↓
TransactionInterceptor.invoke()
      ↓
[1] 获取事务属性（@Transactional配置）
      ↓
[2] 获取事务管理器
      ↓
[3] 开启事务
      ↓
[4] 调用目标方法
      ↓
   成功？
  ↙    ↘
 是      否
 ↓       ↓
提交    回滚
 ↓       ↓
返回结果  抛出异常
```

### 4.3 核心方法解析


**简化版源码逻辑：**
```java
public class TransactionInterceptor {
    
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 1. 获取目标方法的事务配置
        TransactionAttribute txAttr = getTransactionAttribute(invocation.getMethod());
        
        // 2. 获取事务管理器
        PlatformTransactionManager tm = determineTransactionManager(txAttr);
        
        // 3. 开启事务
        TransactionStatus status = tm.getTransaction(txAttr);
        
        try {
            // 4. 执行目标方法
            Object result = invocation.proceed();
            
            // 5. 提交事务
            tm.commit(status);
            return result;
            
        } catch (Throwable ex) {
            // 6. 判断是否需要回滚
            if (txAttr.rollbackOn(ex)) {
                tm.rollback(status);  // 回滚
            } else {
                tm.commit(status);    // 提交
            }
            throw ex;
        }
    }
}
```

**逐步解释：**

**第1步：获取事务属性**
```java
// 从@Transactional注解中读取配置
@Transactional(
    propagation = Propagation.REQUIRED,
    isolation = Isolation.READ_COMMITTED,
    timeout = 30,
    rollbackFor = Exception.class
)
public void saveUser(User user) { ... }

// 拦截器会读取这些配置：
// - 传播行为：REQUIRED
// - 隔离级别：READ_COMMITTED  
// - 超时时间：30秒
// - 回滚异常：Exception.class
```

**第2步：获取事务管理器**
```java
// 自动查找合适的事务管理器
// 如果是JDBC → DataSourceTransactionManager
// 如果是JPA  → JpaTransactionManager
```

**第3步：开启事务**
```java
// 根据传播行为决定是否开启新事务
// REQUIRED: 如果当前有事务就加入，没有就新建
// REQUIRES_NEW: 总是开启新事务
```

**第4步：执行目标方法**
```java
// 调用真实的业务方法
invocation.proceed() → userDao.insert(user)
```

**第5-6步：提交或回滚**
```java
// 正常执行 → 提交事务
// 抛出异常 → 判断异常类型
//   - RuntimeException → 默认回滚
//   - Exception → 默认不回滚（除非指定rollbackFor）
```

### 4.4 异常处理机制


**默认回滚规则：**

| 异常类型 | 是否回滚 | 说明 |
|---------|---------|------|
| `RuntimeException` | ✅ 回滚 | 运行时异常默认回滚 |
| `Error` | ✅ 回滚 | 严重错误默认回滚 |
| `Exception` | ❌ 不回滚 | 检查型异常默认不回滚 |

**自定义回滚规则：**
```java
// 指定Exception也回滚
@Transactional(rollbackFor = Exception.class)
public void saveUser(User user) throws Exception {
    userDao.insert(user);
}

// 指定某些异常不回滚
@Transactional(noRollbackFor = BusinessException.class)
public void processOrder(Order order) {
    // 业务异常不回滚，其他异常回滚
}
```

---

## 5. ⏰ 代理创建时机分析


### 5.1 创建时机详解


**Bean的完整生命周期：**
```
1. 实例化（创建对象）
         ↓
2. 属性赋值（@Autowired注入）
         ↓
3. 初始化前置处理
         ↓
4. 初始化（@PostConstruct）
         ↓
5. 初始化后置处理  ← 代理在这里创建！
         ↓
6. 放入Spring容器
         ↓
7. 使用Bean
         ↓
8. 销毁（@PreDestroy）
```

### 5.2 为什么选择这个时机


**原因1：Bean已完全初始化**
```java
@Service
public class UserService {
    @Autowired
    private UserDao userDao;  // 已经注入
    
    @PostConstruct
    public void init() {
        // 已经执行
    }
    
    @Transactional
    public void saveUser(User user) {
        userDao.insert(user);  // 可以正常使用
    }
}
```

**原因2：可以安全替换Bean**
```
初始化后置处理阶段：
  输入：原始UserService对象
  输出：UserService的代理对象
         ↓
  容器中保存的是代理对象
```

**原因3：符合AOP设计**
```
AOP的本质：在不修改原始代码的情况下增强功能
         ↓
需要：在Bean准备好后，再创建增强版（代理）
```

### 5.3 关键接口


**BeanPostProcessor接口：**
```java
public interface BeanPostProcessor {
    
    // 初始化前调用
    default Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean;
    }
    
    // 初始化后调用 - 创建代理的时机！
    default Object postProcessAfterInitialization(Object bean, String beanName) {
        return bean;  // 这里可以返回代理对象替换原始bean
    }
}
```

**Spring事务的实现：**
```java
// AbstractAutoProxyCreator简化逻辑
public Object postProcessAfterInitialization(Object bean, String beanName) {
    // 1. 判断是否需要代理
    if (需要代理(bean)) {
        // 2. 创建代理
        Object proxy = createProxy(bean);
        // 3. 返回代理对象（替换原始bean）
        return proxy;
    }
    // 4. 不需要代理，返回原始bean
    return bean;
}
```

---

## 6. 🔗 AOP增强原理


### 6.1 什么是AOP增强


**AOP（面向切面编程）的核心概念：**

```
原始方法：
public void saveUser(User user) {
    userDao.insert(user);
}

AOP增强后：
[前置增强] → 开启事务
    ↓
[目标方法] → userDao.insert(user)
    ↓
[后置增强] → 提交事务
    ↓
[异常增强] → 回滚事务
```

**通俗理解：**
- **切面（Aspect）**：事务管理功能
- **切点（Pointcut）**：带`@Transactional`的方法
- **增强（Advice）**：开启、提交、回滚事务的逻辑
- **织入（Weaving）**：把增强逻辑加到方法中

### 6.2 事务增强的类型


**Spring支持的增强类型：**

| 增强类型 | 执行时机 | 事务中的应用 |
|---------|---------|------------|
| **前置增强** | 方法执行前 | 开启事务 |
| **后置增强** | 方法正常返回后 | 提交事务 |
| **异常增强** | 方法抛出异常后 | 回滚事务 |
| **环绕增强** | 方法前后都执行 | 事务使用这种（最灵活） |

**事务使用环绕增强：**
```java
// TransactionInterceptor就是一个环绕增强
public Object invoke(MethodInvocation invocation) {
    // 前置：开启事务
    TransactionStatus status = tm.getTransaction();
    
    try {
        // 执行目标方法
        Object result = invocation.proceed();
        // 后置：提交事务
        tm.commit(status);
        return result;
    } catch (Throwable ex) {
        // 异常：回滚事务
        tm.rollback(status);
        throw ex;
    }
}
```

### 6.3 增强与代理的关系


**整体架构：**
```
@Transactional注解
       ↓
Spring扫描识别
       ↓
创建AOP代理
       ↓
代理对象 = 原始对象 + 事务增强
       ↓
客户端调用代理对象
       ↓
代理对象调用增强逻辑
       ↓
增强逻辑调用原始方法
```

**具体实现：**
```
代理对象内部结构：
┌──────────────────────┐
│   代理对象（Proxy）    │
│  ┌────────────────┐  │
│  │ 增强逻辑链      │  │
│  │ - 事务增强      │  │
│  │ - 日志增强      │  │
│  │ - 权限增强      │  │
│  └────────────────┘  │
│  ┌────────────────┐  │
│  │ 目标对象        │  │
│  │ (原始Service)  │  │
│  └────────────────┘  │
└──────────────────────┘
```

### 6.4 切点匹配机制


**如何判断方法需要事务？**

**匹配规则：**
```java
// 规则1：方法上有@Transactional
@Transactional
public void saveUser(User user) {  // ✅ 匹配
    // ...
}

// 规则2：类上有@Transactional
@Transactional
public class UserService {
    public void saveUser(User user) {  // ✅ 匹配（继承类上的）
        // ...
    }
}

// 规则3：接口上有@Transactional
@Transactional
public interface UserService {
    void saveUser(User user);  // ✅ 匹配
}

// 规则4：私有方法不匹配
@Transactional
private void saveUser(User user) {  // ❌ 不匹配（代理无法增强）
    // ...
}
```

**优先级：**
```
方法上的注解 > 类上的注解 > 接口上的注解

示例：
@Transactional(readOnly = true)  // 类上：只读
public class UserService {
    
    @Transactional(readOnly = false)  // 方法上：可写
    public void saveUser(User user) {  
        // 最终使用：readOnly = false（方法上的优先）
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🔸 事务代理的本质**
```
代理对象 = 原始对象的替身
作用：在不修改原始代码的情况下，添加事务管理功能
客户端调用的是代理对象，感知不到代理的存在
```

**🔸 两种代理方式的区别**
```
JDK动态代理：基于接口，使用反射，目标类必须实现接口
CGLIB代理：基于继承，生成子类，目标类不能是final
Spring自动选择：有接口用JDK，无接口用CGLIB
```

**🔸 代理创建的关键时机**
```
Bean生命周期：实例化 → 属性赋值 → 初始化 → [创建代理] → 放入容器
创建时机：初始化后置处理阶段（postProcessAfterInitialization）
原因：此时Bean已完全准备好，可以安全地用代理替换原始对象
```

### 7.2 关键理解要点


**🔹 ProxyTransactionManagementConfiguration的作用**
```
这是启用事务的核心配置类，注册三个关键Bean：
1. TransactionAttributeSource - 解析@Transactional注解
2. TransactionInterceptor - 执行事务开启/提交/回滚
3. BeanFactoryTransactionAttributeSourceAdvisor - 决定哪些类需要代理
```

**🔹 TransactionInterceptor的执行流程**
```
1. 获取事务属性（从@Transactional读取配置）
2. 获取事务管理器
3. 开启事务
4. 执行目标方法
5. 提交事务（成功）或回滚事务（异常）
```

**🔹 AOP增强与代理的关系**
```
AOP增强：定义要添加的额外功能（事务管理）
代理对象：承载增强功能的载体
关系：代理对象 = 原始对象 + AOP增强逻辑
```

### 7.3 实际应用要点


**✅ 开发中的注意事项**

1. **接口设计建议**
   ```java
   // 推荐：Service层使用接口
   public interface UserService {
       void saveUser(User user);
   }
   
   @Service
   public class UserServiceImpl implements UserService {
       @Transactional
       public void saveUser(User user) { ... }
   }
   ```

2. **避免代理失效**
   ```java
   // ❌ 错误：内部调用，事务失效
   @Service
   public class UserService {
       @Transactional
       public void saveUser(User user) {
           this.updateUser(user);  // 直接调用，没走代理
       }
       
       @Transactional
       public void updateUser(User user) { ... }
   }
   
   // ✅ 正确：通过代理调用
   @Service
   public class UserService {
       @Autowired
       private UserService self;  // 注入自己（实际是代理）
       
       @Transactional
       public void saveUser(User user) {
           self.updateUser(user);  // 通过代理调用
       }
   }
   ```

3. **方法可见性要求**
   ```java
   // ✅ public方法 - 可以被代理
   @Transactional
   public void saveUser(User user) { ... }
   
   // ❌ private方法 - 无法被代理
   @Transactional
   private void saveUser(User user) { ... }
   
   // ❌ final方法 - CGLIB无法代理
   @Transactional
   public final void saveUser(User user) { ... }
   ```

### 7.4 核心记忆口诀


```
🎯 代理创建记心间：
Bean初始化后创建代理，有接口用JDK，无接口用CGLIB

🎯 拦截器执行流程：
获取属性找管理器，开启事务调方法，成功提交失败回滚

🎯 增强织入要点：
AOP增强加功能，代理对象是载体，切点匹配决定谁

🎯 开发注意事项：
接口设计优先选，内部调用要注意，方法可见性要求高
```

### 7.5 深入理解建议


**后续学习方向：**
1. 研究Spring AOP的完整机制
2. 了解不同事务传播行为的代理处理
3. 学习如何自定义AOP切面
4. 掌握代理失效的各种场景及解决方案

**实践建议：**
- Debug跟踪代理创建过程
- 查看代理对象的实际类型（getClass()）
- 测试不同场景下的代理行为
- 分析事务失效的原因并解决