---
title: 32、事务配置最佳实践
---
## 📚 目录

1. [事务配置核心原则](#1-事务配置核心原则)
2. [只读事务配置](#2-只读事务配置)
3. [超时设置策略](#3-超时设置策略)
4. [传播行为配置](#4-传播行为配置)
5. [隔离级别配置](#5-隔离级别配置)
6. [异常回滚规则](#6-异常回滚规则)
7. [事务边界设计](#7-事务边界设计)
8. [事务粒度控制](#8-事务粒度控制)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 事务配置核心原则


### 1.1 什么是事务配置最佳实践


**通俗理解**：就像开车要遵守交通规则一样，使用事务也有一套"最优方案"，能让系统既安全又高效。

**核心思想**：
```
事务配置 = 安全性 + 性能 + 可维护性

安全性：保证数据不出错
性能：  不让系统变慢
可维护性：代码易读易改
```

**配置三原则**：
```
1️⃣ 能只读就只读 → 提升性能
2️⃣ 事务要尽量短 → 减少锁等待
3️⃣ 异常要明确处理 → 避免数据混乱
```

### 1.2 为什么需要最佳实践


**生活类比**：
```
不好的配置 = 开车不看路
好的配置   = 既安全又快速到达目的地

┌─ 💭 现实例子 ─────────────┐
│ 去超市买东西：           │
│ ❌ 每买一样就结账一次     │
│ ✅ 选好所有商品一起结账   │
│                          │
│ 事务也是这个道理：       │
│ ❌ 频繁开启关闭事务       │
│ ✅ 合理规划事务边界       │
└──────────────────────────┘
```

**常见问题对比**：

| 错误配置 | 后果 | 正确做法 |
|---------|------|---------|
| 所有方法都加事务 | 性能差，锁多 | 只给需要的方法加 |
| 不设置超时时间 | 可能永久等待 | 合理设置超时 |
| 事务范围太大 | 锁定时间长 | 缩小事务边界 |
| 不处理异常 | 数据不一致 | 明确回滚规则 |

---

## 2. 📖 只读事务配置


### 2.1 什么是只读事务


**通俗解释**：只读事务就是"只看不改"的操作，告诉数据库"我只是来查数据的，不会修改"。

**为什么要用只读事务**：
```
想象图书馆借书：

只读 = 只在馆内阅读
好处：
• 不用登记借阅记录
• 不用担心书被损坏
• 其他人也可以同时看
• 效率更高

只读事务同理：
• 数据库不用记录修改日志
• 不用加写锁
• 允许更多并发查询
• 性能提升明显
```

### 2.2 只读事务配置方法


**基础配置**：
```java
// 方式1：注解配置（推荐）
@Transactional(readOnly = true)
public User getUserById(Long id) {
    return userDao.findById(id);
}

// 方式2：编程式配置
public List<User> searchUsers(String keyword) {
    TransactionTemplate template = new TransactionTemplate(transactionManager);
    template.setReadOnly(true);
    
    return template.execute(status -> {
        return userDao.search(keyword);
    });
}
```

**使用场景判断**：
```
📋 什么时候用只读事务？

✅ 查询用户信息
✅ 生成报表数据
✅ 统计分析
✅ 搜索功能
✅ 展示列表

❌ 什么时候不能用？
• 需要修改数据
• 需要插入数据
• 需要删除数据
```

### 2.3 只读事务优化技巧


**性能对比**：
```
普通事务查询：
User → [开启事务] → [加锁] → [查询] → [记录日志] → [提交]
耗时：~50ms

只读事务查询：
User → [开启只读事务] → [查询] → [直接返回]
耗时：~20ms

性能提升：约60%
```

**实战示例**：
```java
@Service
public class OrderQueryService {
    
    // ✅ 正确：查询订单使用只读事务
    @Transactional(readOnly = true)
    public OrderDTO getOrderDetail(Long orderId) {
        Order order = orderDao.findById(orderId);
        List<OrderItem> items = itemDao.findByOrderId(orderId);
        
        return buildOrderDTO(order, items);
    }
    
    // ❌ 错误：查询也用可写事务（浪费性能）
    @Transactional
    public OrderDTO getOrderDetailBad(Long orderId) {
        // 明明只是查询，却用了可写事务
        return orderDao.findById(orderId);
    }
}
```

> **💡 重要提示**：如果方法内部既有查询又有修改，不能用只读事务！

---

## 3. ⏰ 超时设置策略


### 3.1 为什么需要超时设置


**生活类比**：
```
打电话等人接听：

没有超时 = 一直等下去
问题：
• 手机一直占线
• 浪费时间
• 无法做其他事

设置超时 = 等30秒没人接就挂断
好处：
• 及时释放资源
• 可以尝试其他方式
• 不会永久阻塞

数据库事务超时同理！
```

**超时的作用**：
```
防止问题：
1. 死锁导致永久等待
2. 慢查询占用连接
3. 网络故障导致挂起
4. 资源耗尽
```

### 3.2 超时时间配置


**配置方法**：
```java
// 方式1：注解配置（推荐）
@Transactional(timeout = 30) // 单位：秒
public void createOrder(Order order) {
    orderDao.save(order);
    // 如果30秒内没完成，自动回滚
}

// 方式2：全局配置
@Bean
public PlatformTransactionManager transactionManager() {
    DataSourceTransactionManager manager = new DataSourceTransactionManager();
    manager.setDefaultTimeout(30); // 默认30秒
    return manager;
}
```

**超时时间参考表**：

| 操作类型 | 推荐超时 | 说明 |
|---------|---------|------|
| 🔍 简单查询 | 5-10秒 | 一般1-2秒就完成 |
| 💾 单条插入 | 10-15秒 | 正常几秒内完成 |
| 📦 批量操作 | 30-60秒 | 数据量大需要更多时间 |
| 📊 复杂统计 | 60-120秒 | 计算密集型操作 |
| 🔄 定时任务 | 300-600秒 | 允许较长时间 |

### 3.3 超时处理最佳实践


**场景化配置**：
```java
@Service
public class PaymentService {
    
    // 快速操作：短超时
    @Transactional(timeout = 10)
    public void deductBalance(Long userId, BigDecimal amount) {
        User user = userDao.findById(userId);
        user.setBalance(user.getBalance().subtract(amount));
        userDao.update(user);
    }
    
    // 复杂操作：长超时
    @Transactional(timeout = 60)
    public void monthlyBilling(Long userId) {
        // 计算月账单
        List<Order> orders = orderDao.findMonthlyOrders(userId);
        BigDecimal total = calculateTotal(orders);
        
        // 生成账单
        Bill bill = new Bill();
        bill.setAmount(total);
        billDao.save(bill);
    }
}
```

**超时异常处理**：
```java
try {
    paymentService.processPayment(orderId);
} catch (TransactionTimedOutException e) {
    // 超时了，该怎么处理？
    
    // 方案1：重试
    log.warn("Payment timeout, retry...");
    retryService.scheduleRetry(orderId);
    
    // 方案2：通知用户
    notifyService.sendMessage(userId, "支付处理中，请稍后查看结果");
    
    // 方案3：记录失败
    failureLog.record(orderId, "timeout");
}
```

> **⚠️ 注意**：超时时间不是越长越好，要根据实际业务设置合理值。

---

## 4. 🔄 传播行为配置


### 4.1 什么是事务传播


**通俗理解**：事务传播就是"事务之间的调用规则"，决定一个方法调用另一个方法时，事务该怎么处理。

**生活类比**：
```
公司开会的规则：

REQUIRED（加入现有会议）：
老板在开会 → 你进去参加同一个会议
老板没开会 → 你自己开个新会议

REQUIRES_NEW（开新会议）：
老板在开会 → 你去另一个会议室开新会
老板没开会 → 你自己开个会议

NOT_SUPPORTED（不开会）：
老板在开会 → 你先出去，等会议结束
老板没开会 → 你直接办事，不开会
```

### 4.2 常用传播行为配置


**七种传播行为速查**：

| 传播类型 | 说明 | 使用场景 |
|---------|------|---------|
| **REQUIRED** | 有事务就加入，没有就新建 | ✅ 默认选择，最常用 |
| **REQUIRES_NEW** | 永远创建新事务 | 🔸 需要独立提交的操作 |
| **SUPPORTS** | 有事务就用，没有就算了 | 🔸 可选的事务操作 |
| **NOT_SUPPORTED** | 挂起当前事务，不用事务执行 | 🔸 不需要事务的操作 |
| **MANDATORY** | 必须有事务，否则报错 | 🔸 强制要求事务 |
| **NEVER** | 不能有事务，有就报错 | 🔸 禁止事务的操作 |
| **NESTED** | 嵌套事务（保存点） | 🔸 部分回滚场景 |

### 4.3 传播行为实战配置


**场景1：独立事务（REQUIRES_NEW）**
```java
// 典型场景：记录日志，不能因为业务失败而回滚日志
@Service
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    @Transactional
    public void createOrder(Order order) {
        // 保存订单
        orderDao.save(order);
        
        // 记录操作日志（独立事务）
        logService.saveLog("创建订单：" + order.getId());
        
        // 如果这里出错，订单回滚，但日志已保存
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("金额必须大于0");
        }
    }
}

@Service
public class LogService {
    
    // 独立事务：不管外层事务成功或失败，日志都要保存
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String content) {
        OperateLog log = new OperateLog();
        log.setContent(content);
        log.setCreateTime(new Date());
        logDao.save(log);
    }
}
```

**传播行为决策流程**：
```
需要配置传播行为时问自己：

1. 这个方法必须在事务中执行吗？
   YES → 用 REQUIRED 或 MANDATORY
   NO  → 用 SUPPORTS 或 NOT_SUPPORTED

2. 这个方法的失败能影响调用方吗？
   不能影响 → 用 REQUIRES_NEW（独立事务）
   必须影响 → 用 REQUIRED（加入事务）

3. 这个方法能不能有事务？
   绝对不能 → 用 NEVER
   可以有   → 用其他类型
```

**实用配置示例**：
```java
@Service
public class UserService {
    
    // 默认配置：最常用
    @Transactional
    public void updateUser(User user) {
        userDao.update(user);
    }
    
    // 独立事务：发送通知
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void sendNotification(String message) {
        notificationDao.save(new Notification(message));
        // 即使调用方回滚，通知也要发送
    }
    
    // 不需要事务：查询缓存
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public User getUserFromCache(Long id) {
        return cache.get(id);
    }
}
```

> **💡 选择建议**：90%的场景用默认的REQUIRED就够了，特殊需求才考虑其他传播行为。

---

## 5. 🔒 隔离级别配置


### 5.1 什么是隔离级别


**通俗理解**：隔离级别就是"事务之间的隔离程度"，决定一个事务能不能看到另一个事务的修改。

**生活类比**：
```
在图书馆学习：

READ_UNCOMMITTED（读未提交）：
= 能看到别人草稿纸上的内容
问题：别人可能会擦掉重写，你看到的可能是错的

READ_COMMITTED（读已提交）：
= 只能看到别人正式写完的内容  
问题：别人可能会修改已写好的内容

REPEATABLE_READ（可重复读）：
= 你第一次看到什么，之后就一直是什么
问题：别人新加的内容你看不到

SERIALIZABLE（串行化）：
= 一次只允许一个人在图书馆学习
好处：绝对准确
问题：效率太低
```

### 5.2 四种隔离级别详解


**隔离级别对比表**：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 使用场景 |
|---------|-----|-----------|------|------|---------|
| **READ_UNCOMMITTED** | ❌ 会发生 | ❌ 会发生 | ❌ 会发生 | ⚡⚡⚡⚡ | 几乎不用 |
| **READ_COMMITTED** | ✅ 避免 | ❌ 会发生 | ❌ 会发生 | ⚡⚡⚡ | 一般查询 |
| **REPEATABLE_READ** | ✅ 避免 | ✅ 避免 | ❌ 会发生 | ⚡⚡ | MySQL默认 |
| **SERIALIZABLE** | ✅ 避免 | ✅ 避免 | ✅ 避免 | ⚡ | 金融场景 |

**三大问题解释**：
```
📌 脏读（Dirty Read）：
读到了别人还没提交的数据

例子：
A：把商品价格改成100元（未提交）
B：看到价格是100元
A：改错了，回滚到200元
B：用100元下单 → 💥 出错了！

📌 不可重复读（Non-Repeatable Read）：
同一个查询，前后结果不一样

例子：
A：查询余额1000元
B：扣款100元并提交
A：再查询余额900元 → 💥 怎么变了？

📌 幻读（Phantom Read）：
查询的数据条数变了

例子：
A：查询有3个订单
B：插入1个新订单并提交
A：再查询有4个订单 → 💥 多出来了？
```

### 5.3 隔离级别配置实战


**配置方法**：
```java
// 方式1：方法级别配置
@Transactional(isolation = Isolation.READ_COMMITTED)
public Order getOrderDetail(Long orderId) {
    return orderDao.findById(orderId);
}

// 方式2：类级别配置
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class AccountService {
    
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        // 所有方法默认使用可重复读
    }
}
```

**场景化选择**：
```java
@Service
public class FinanceService {
    
    // 场景1：统计报表（允许不一致）
    @Transactional(
        readOnly = true,
        isolation = Isolation.READ_COMMITTED
    )
    public ReportData generateReport() {
        // 读已提交就够了，性能好
        return reportDao.queryData();
    }
    
    // 场景2：扣款操作（要求一致）
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void deductAmount(Long userId, BigDecimal amount) {
        // 可重复读，避免余额被别人修改
        User user = userDao.findById(userId);
        BigDecimal balance = user.getBalance();
        
        if (balance.compareTo(amount) < 0) {
            throw new InsufficientBalanceException();
        }
        
        user.setBalance(balance.subtract(amount));
        userDao.update(user);
    }
    
    // 场景3：银行转账（绝对准确）
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void bankTransfer(Long fromId, Long toId, BigDecimal amount) {
        // 串行化，确保绝对准确（性能会降低）
        Account from = accountDao.findById(fromId);
        Account to = accountDao.findById(toId);
        
        from.deduct(amount);
        to.add(amount);
        
        accountDao.update(from);
        accountDao.update(to);
    }
}
```

**选择建议流程**：
```
如何选择隔离级别？

1. 是否涉及金钱？
   YES → 用 REPEATABLE_READ 或 SERIALIZABLE
   NO  → 往下看

2. 能否接受数据暂时不一致？
   能接受 → 用 READ_COMMITTED（性能好）
   不能   → 用 REPEATABLE_READ

3. 是否需要绝对准确？
   需要 → 用 SERIALIZABLE（慎用，性能差）
   不需要 → 用 REPEATABLE_READ
```

> **⚠️ 重要**：隔离级别越高越安全，但性能越差。MySQL默认用REPEATABLE_READ，一般够用了。

---

## 6. 🚨 异常回滚规则


### 6.1 什么是异常回滚


**通俗理解**：异常回滚就是"出错了怎么办"的规则，决定什么情况下要撤销已做的操作。

**生活类比**：
```
网购下单流程：

1. 选商品 ✅
2. 填地址 ✅
3. 支付... ❌ 失败了！

回滚规则：
• 如果支付失败 → 取消整个订单（回滚）
• 如果只是地址格式错误 → 让用户重新填（不回滚）

事务回滚同理：
• RuntimeException → 默认回滚
• Checked Exception → 默认不回滚（可配置）
```

### 6.2 Spring默认回滚规则


**默认行为**：
```
✅ 这些异常会自动回滚：
• RuntimeException（运行时异常）
• Error（系统错误）

❌ 这些异常不会自动回滚：
• Checked Exception（检查异常，如IOException）

为什么这样设计？
• RuntimeException通常是编程错误，应该回滚
• Checked Exception可能是业务异常，需要自己决定
```

**异常分类**：
```
Exception（异常）
├── RuntimeException（运行时异常）← 默认回滚
│   ├── NullPointerException
│   ├── IllegalArgumentException
│   └── ArithmeticException
│
└── Checked Exception（检查异常）← 默认不回滚
    ├── IOException
    ├── SQLException
    └── 自定义业务异常
```

### 6.3 自定义回滚规则


**配置方法**：
```java
// 方式1：指定回滚异常类型
@Transactional(rollbackFor = Exception.class)
public void processOrder(Order order) throws Exception {
    orderDao.save(order);
    // 所有异常都回滚（包括检查异常）
}

// 方式2：指定不回滚的异常
@Transactional(noRollbackFor = BusinessException.class)
public void updateUser(User user) {
    userDao.update(user);
    // 业务异常不回滚，其他异常回滚
}

// 方式3：组合配置
@Transactional(
    rollbackFor = {SQLException.class, IOException.class},
    noRollbackFor = {BusinessWarningException.class}
)
public void complexOperation() {
    // SQL异常和IO异常回滚
    // 业务警告异常不回滚
}
```

### 6.4 回滚规则最佳实践


**场景1：业务异常处理**
```java
// 自定义业务异常
public class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

@Service
public class PaymentService {
    
    @Transactional(rollbackFor = Exception.class)
    public void pay(Long orderId, BigDecimal amount) {
        Order order = orderDao.findById(orderId);
        User user = userDao.findById(order.getUserId());
        
        // 余额不足：抛出业务异常，自动回滚
        if (user.getBalance().compareTo(amount) < 0) {
            throw new InsufficientBalanceException("余额不足");
        }
        
        // 扣款
        user.setBalance(user.getBalance().subtract(amount));
        userDao.update(user);
        
        // 更新订单
        order.setStatus("PAID");
        orderDao.update(order);
    }
}
```

**场景2：部分失败不回滚**
```java
@Service
public class NotificationService {
    
    @Transactional(noRollbackFor = MessageSendException.class)
    public void createOrderAndNotify(Order order) {
        // 保存订单
        orderDao.save(order);
        
        try {
            // 发送通知（失败了也没关系）
            messageService.send("订单创建成功");
        } catch (MessageSendException e) {
            // 记录日志，不影响订单保存
            log.error("通知发送失败", e);
            // 不会回滚订单
        }
    }
}
```

**回滚规则决策表**：

| 场景 | 异常类型 | 是否回滚 | 配置 |
|-----|---------|---------|------|
| 💰 支付失败 | 业务异常 | ✅ 必须回滚 | `rollbackFor = Exception.class` |
| 📧 发送通知失败 | 通知异常 | ❌ 不回滚 | `noRollbackFor = NotifyException.class` |
| 🔍 数据校验失败 | 校验异常 | ✅ 回滚 | 使用RuntimeException |
| 📝 记录日志失败 | IO异常 | ❌ 不回滚 | `noRollbackFor = IOException.class` |

**完整示例**：
```java
@Service
public class OrderService {
    
    @Autowired
    private NotificationService notificationService;
    
    // ✅ 推荐做法：明确所有异常的处理方式
    @Transactional(
        rollbackFor = {
            BusinessException.class,    // 业务异常回滚
            SQLException.class,         // 数据库异常回滚
            IOException.class          // IO异常回滚
        },
        noRollbackFor = {
            NotificationException.class // 通知异常不回滚
        }
    )
    public void createOrder(Order order) {
        // 1. 保存订单
        orderDao.save(order);
        
        // 2. 扣减库存
        productService.deductStock(order.getProductId(), order.getQuantity());
        
        // 3. 发送通知（失败不影响订单）
        try {
            notificationService.sendOrderNotification(order);
        } catch (NotificationException e) {
            log.warn("通知发送失败，订单已创建成功", e);
        }
    }
}
```

> **💡 最佳实践**：建议配置`rollbackFor = Exception.class`，让所有异常都回滚，然后用`noRollbackFor`排除特定的业务异常。

---

## 7. 🎯 事务边界设计


### 7.1 什么是事务边界


**通俗理解**：事务边界就是"事务的范围"，决定哪些操作要放在一个事务里，哪些要拆开。

**生活类比**：
```
做一顿饭的步骤：

方案1：全部算一件事（事务边界太大）
[买菜 + 洗菜 + 切菜 + 炒菜 + 装盘] → 一个事务
问题：时间太长，别人都在等

方案2：每步都单独算（事务边界太小）
[买菜] [洗菜] [切菜] [炒菜] [装盘] → 5个事务
问题：中间出错难以协调

方案3：合理划分（推荐）
[买菜] → 单独
[洗菜+切菜+炒菜] → 一个事务
[装盘] → 单独
```

### 7.2 事务边界设计原则


**核心原则**：
```
1️⃣ 事务要尽量短
原因：减少锁等待，提高并发

2️⃣ 事务要完整
原因：保证数据一致性

3️⃣ 只包含必要操作
原因：不相关的操作不要放进来

4️⃣ 避免跨系统调用
原因：外部调用很慢，会拖累事务
```

**边界设计对比**：

| 设计方式 | 示例 | 优点 | 缺点 |
|---------|------|------|------|
| **粗粒度** | 整个业务流程一个事务 | 保证一致性 | 锁时间长，性能差 |
| **细粒度** | 每个操作一个事务 | 性能好 | 难以保证一致性 |
| **合理粒度** | 核心操作一个事务 | ✅ 平衡性能和一致性 | 需要仔细设计 |

### 7.3 事务边界设计实战


**❌ 错误示例：边界太大**
```java
@Service
public class OrderService {
    
    // 问题：事务包含了太多不必要的操作
    @Transactional
    public void processOrder(OrderRequest request) {
        // 1. 查询商品信息（只读，不需要事务）
        Product product = productService.getProduct(request.getProductId());
        
        // 2. 调用第三方接口检查库存（很慢！不应该在事务里）
        boolean available = externalService.checkStock(product.getSkuId());
        
        // 3. 保存订单（需要事务）
        Order order = new Order();
        orderDao.save(order);
        
        // 4. 发送邮件（很慢！不应该在事务里）
        emailService.sendOrderEmail(order);
        
        // 5. 记录日志（不需要事务）
        logService.log("订单创建成功");
    }
}
```

**✅ 正确示例：合理边界**
```java
@Service
public class OrderService {
    
    // 主流程：不加事务
    public void processOrder(OrderRequest request) {
        // 1. 查询商品（不需要事务）
        Product product = productService.getProduct(request.getProductId());
        
        // 2. 检查库存（不需要事务）
        boolean available = externalService.checkStock(product.getSkuId());
        if (!available) {
            throw new OutOfStockException();
        }
        
        // 3. 创建订单（核心操作，需要事务）
        Order order = createOrderInTransaction(request, product);
        
        // 4. 后续操作（异步处理，不在事务里）
        asyncService.sendEmail(order);
        asyncService.recordLog(order);
    }
    
    // 只有核心操作才加事务
    @Transactional
    private Order createOrderInTransaction(OrderRequest request, Product product) {
        // 保存订单
        Order order = new Order();
        order.setProductId(product.getId());
        order.setAmount(product.getPrice());
        orderDao.save(order);
        
        // 扣减库存
        productService.deductStock(product.getId(), request.getQuantity());
        
        return order;
    }
}
```

### 7.4 事务边界优化技巧


**技巧1：提取查询操作**
```java
// ❌ 不好的做法
@Transactional
public void updateUserInfo(Long userId, String newName) {
    User user = userDao.findById(userId);        // 查询在事务里
    validateUserName(newName);                   // 校验在事务里
    user.setName(newName);
    userDao.update(user);
}

// ✅ 优化后
public void updateUserInfo(Long userId, String newName) {
    User user = userDao.findById(userId);        // 查询在事务外
    validateUserName(newName);                   // 校验在事务外
    
    updateUserInTransaction(user, newName);      // 只有更新在事务里
}

@Transactional
private void updateUserInTransaction(User user, String newName) {
    user.setName(newName);
    userDao.update(user);                        // 事务只包含更新
}
```

**技巧2：拆分复杂事务**
```java
// ❌ 不好的做法：一个大事务
@Transactional
public void processPayment(PaymentRequest request) {
    // 订单处理
    orderService.processOrder(request.getOrderId());
    
    // 支付处理
    paymentService.doPayment(request.getAmount());
    
    // 积分处理
    pointService.addPoints(request.getUserId(), request.getPoints());
    
    // 优惠券处理
    couponService.useCoupon(request.getCouponId());
}

// ✅ 优化后：按业务拆分，每个独立事务
public void processPayment(PaymentRequest request) {
    try {
        // 各自独立的事务
        orderService.processOrder(request.getOrderId());
        paymentService.doPayment(request.getAmount());
        pointService.addPoints(request.getUserId(), request.getPoints());
        couponService.useCoupon(request.getCouponId());
    } catch (Exception e) {
        // 如果某个失败，手动补偿
        compensateService.rollback(request);
        throw e;
    }
}
```

**边界设计检查清单**：
```
📋 事务边界设计检查

□ 是否包含了只读查询？ → 提取到事务外
□ 是否调用了外部接口？ → 移到事务外或用异步
□ 是否有文件IO操作？  → 移到事务外
□ 是否发送了消息？    → 用异步或独立事务
□ 事务执行时间超过3秒？→ 考虑拆分
□ 是否涉及多个业务？  → 考虑分开
```

> **💡 黄金法则**：事务里只做数据库修改，其他操作能移出去就移出去。

---

## 8. ⚖️ 事务粒度控制


### 8.1 什么是事务粒度


**通俗理解**：事务粒度就是"事务的大小"，决定一个事务包含多少操作。

**粒度对比**：
```
粗粒度事务：
┌──────────────────────────────┐
│ [订单] [支付] [库存] [积分]  │ → 一个大事务
└──────────────────────────────┘
优点：保证强一致性
缺点：锁时间长，性能差

细粒度事务：
┌────┐ ┌────┐ ┌────┐ ┌────┐
│订单│ │支付│ │库存│ │积分│ → 多个小事务
└────┘ └────┘ └────┘ └────┘
优点：性能好，锁时间短
缺点：难以保证一致性
```

### 8.2 粒度控制策略


**策略选择**：

| 场景 | 推荐粒度 | 原因 |
|-----|---------|------|
| 💰 金融交易 | 粗粒度 | 必须保证强一致性 |
| 📦 电商下单 | 中等粒度 | 平衡性能和一致性 |
| 📝 内容发布 | 细粒度 | 允许最终一致性 |
| 📊 数据统计 | 无事务 | 只读操作 |

**粒度决策流程**：
```
1. 这些操作必须同时成功或失败吗？
   YES → 放在一个事务（粗粒度）
   NO  → 往下看

2. 操作之间有强依赖关系吗？
   YES → 放在一个事务
   NO  → 往下看

3. 能接受短暂的数据不一致吗？
   能接受 → 用多个事务（细粒度）
   不能   → 用一个事务（粗粒度）
```

### 8.3 粒度控制实战


**场景1：电商下单（中等粒度）**
```java
@Service
public class OrderService {
    
    // 核心事务：订单和库存（必须一致）
    @Transactional
    public Order createCoreOrder(OrderRequest request) {
        // 1. 创建订单
        Order order = new Order();
        order.setUserId(request.getUserId());
        order.setProductId(request.getProductId());
        order.setAmount(request.getAmount());
        orderDao.save(order);
        
        // 2. 扣减库存（必须和订单在一个事务）
        productService.deductStock(
            request.getProductId(), 
            request.getQuantity()
        );
        
        return order;
    }
    
    // 扩展操作：独立事务或异步
    public void processOrderExtensions(Order order) {
        // 3. 增加积分（独立事务，失败不影响订单）
        try {
            pointService.addPoints(order.getUserId(), order.getAmount());
        } catch (Exception e) {
            log.error("积分添加失败", e);
        }
        
        // 4. 发送通知（异步，不在事务里）
        asyncService.sendNotification(order);
    }
}
```

**场景2：批量操作（细粒度）**
```java
@Service
public class BatchService {
    
    // ❌ 不好的做法：一个大事务处理所有数据
    @Transactional
    public void batchUpdateBad(List<User> users) {
        for (User user : users) {
            userDao.update(user);
        }
        // 问题：如果有10000条数据，事务会锁很久
    }
    
    // ✅ 优化后：分批处理，每批一个小事务
    public void batchUpdateGood(List<User> users) {
        int batchSize = 100;  // 每批100条
        
        for (int i = 0; i < users.size(); i += batchSize) {
            int end = Math.min(i + batchSize, users.size());
            List<User> batch = users.subList(i, end);
            
            // 每100条数据一个事务
            updateBatch(batch);
        }
    }
    
    @Transactional
    private void updateBatch(List<User> batch) {
        for (User user : batch) {
            userDao.update(user);
        }
    }
}
```

**场景3：分布式场景（细粒度+补偿）**
```java
@Service
public class DistributedOrderService {
    
    // 主流程：不用事务，用补偿机制
    public void createDistributedOrder(OrderRequest request) {
        String transactionId = UUID.randomUUID().toString();
        
        try {
            // 步骤1：创建订单（独立事务）
            Order order = orderService.createOrder(request);
            
            // 步骤2：扣减库存（独立事务）
            inventoryService.deductStock(
                request.getProductId(), 
                request.getQuantity(),
                transactionId
            );
            
            // 步骤3：扣减余额（独立事务）
            accountService.deductBalance(
                request.getUserId(),
                order.getAmount(),
                transactionId
            );
            
        } catch (Exception e) {
            // 失败补偿：回滚已完成的操作
            compensateService.compensate(transactionId);
            throw new OrderCreateException("订单创建失败", e);
        }
    }
}

@Service
public class CompensateService {
    
    public void compensate(String transactionId) {
        // 查找该事务已完成的操作
        List<Operation> operations = operationDao.findByTransactionId(transactionId);
        
        // 逐个补偿（逆序执行）
        for (int i = operations.size() - 1; i >= 0; i--) {
            Operation op = operations.get(i);
            switch (op.getType()) {
                case "DEDUCT_STOCK":
                    inventoryService.addStock(op.getProductId(), op.getQuantity());
                    break;
                case "DEDUCT_BALANCE":
                    accountService.addBalance(op.getUserId(), op.getAmount());
                    break;
            }
        }
    }
}
```

### 8.4 粒度优化建议


**优化原则**：
```
📊 性能优先场景：
• 查询操作    → 不用事务
• 统计分析    → 只读事务
• 批量导入    → 小批量事务

🔒 一致性优先场景：
• 金融交易    → 粗粒度事务
• 库存扣减    → 粗粒度事务
• 账务处理    → 粗粒度事务

⚖️ 平衡场景：
• 电商下单    → 核心操作粗粒度，扩展操作细粒度
• 用户注册    → 主流程粗粒度,通知细粒度
• 内容发布    → 核心数据粗粒度，索引细粒度
```

**实用建议**：
```
1. 从粗粒度开始，性能有问题再优化
2. 核心数据用粗粒度，扩展数据用细粒度
3. 能用异步就异步，能延迟就延迟
4. 批量操作要分批，避免长事务
5. 分布式场景用补偿，不用大事务
```

> **💡 记住**：事务粒度没有绝对的对错，关键是找到性能和一致性的平衡点。

---

## 9. 📋 核心要点总结


### 9.1 配置速查表


**事务配置快速参考**：

| 配置项 | 推荐配置 | 使用场景 |
|-------|---------|---------|
| **只读** | `readOnly=true` | 所有查询操作 |
| **超时** | `timeout=30` | 一般业务操作 |
| **传播** | `REQUIRED` | 90%的场景 |
| **隔离** | `REPEATABLE_READ` | 数据一致性要求高 |
| **回滚** | `rollbackFor=Exception.class` | 所有异常都回滚 |

### 9.2 最佳实践清单


```
✅ 事务配置检查清单：

📌 基础配置
□ 查询方法配置了 readOnly=true
□ 设置了合理的超时时间
□ 明确了异常回滚规则

📌 性能优化
□ 事务边界尽量小
□ 避免在事务里调用外部接口
□ 批量操作分批处理

📌 数据安全
□ 金融操作用较高隔离级别
□ 关键操作有异常处理
□ 分布式场景有补偿机制

📌 代码质量
□ 事务方法职责单一
□ 避免过深的调用层次
□ 有完善的日志记录
```

### 9.3 常见问题处理


**问题1：事务不生效**
```
原因：
• 方法不是public
• 类内部调用（没走代理）
• 异常被捕获了没抛出

解决：
• 确保方法是public
• 用注入的对象调用
• 异常要抛出去
```

**问题2：事务超时**
```
原因：
• 超时时间设置太短
• 慢SQL或外部调用
• 锁等待时间过长

解决：
• 调整超时时间
• 优化慢SQL
• 外部调用移出事务
```

**问题3：并发问题**
```
原因：
• 隔离级别太低
• 没有加锁
• 更新丢失

解决：
• 提高隔离级别
• 使用悲观锁/乐观锁
• 用版本号控制并发
```

### 9.4 核心记忆要点


```
🎯 三个核心原则：
1. 事务要短：减少锁等待
2. 配置要明确：不要依赖默认值
3. 异常要处理：明确回滚规则

🔑 五个关键配置：
• readOnly    → 查询必配
• timeout     → 防止卡死
• propagation → 控制传播
• isolation   → 保证一致
• rollbackFor → 异常回滚

💡 记忆口诀：
"查询只读性能好，超时设置不能少
传播默认REQUIRED，隔离级别要知道
异常回滚要明确，事务边界要合理
粒度控制讲策略，优化性能有妙招"
```

**最终建议**：
- 🎯 新手先用默认配置+只读事务
- 📈 遇到性能问题再针对性优化
- 🔒 涉及金钱必须提高隔离级别
- 📝 所有配置都要加注释说明原因