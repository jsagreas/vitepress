---
title: 37、事务与缓存一致性
---
## 📚 目录

1. [缓存一致性问题的本质](#1-缓存一致性问题的本质)
2. [缓存更新的时机选择](#2-缓存更新的时机选择)
3. [Cache-Aside模式详解](#3-Cache-Aside模式详解)
4. [Write-Through模式详解](#4-Write-Through模式详解)
5. [事务提交后更新缓存](#5-事务提交后更新缓存)
6. [缓存穿透问题与防护](#6-缓存穿透问题与防护)
7. [Spring缓存注解与事务](#7-Spring缓存注解与事务)
8. [数据一致性保障方案](#8-数据一致性保障方案)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 缓存一致性问题的本质


### 1.1 什么是缓存一致性问题


**问题场景理解**

想象一个电商系统的商品库存场景:
```
数据库中: 商品A库存 = 100件
缓存中:   商品A库存 = 100件

用户下单购买1件:
1. 更新数据库: 库存 = 99件 ✅
2. 更新缓存: 库存 = ??? 🤔

如果缓存没更新,用户看到的还是100件
如果更新失败,数据库和缓存就不一致了
```

**🔸 本质原因**
```
缓存一致性问题的根源在于:

两个数据存储位置:
- 数据库: 持久化存储,但读写较慢
- 缓存:   内存存储,读写很快但易失

更新不同步:
- 数据库更新了,缓存没更新
- 缓存更新了,数据库回滚了
- 两个更新时间不一致

结果:
用户读缓存 → 拿到旧数据 → 业务出错
```

### 1.2 事务与缓存的矛盾关系


**时序问题图示**
```
正常流程:                   出问题的流程:
────────────────           ────────────────
开启事务                    开启事务
  ↓                          ↓
更新数据库                  更新数据库
  ↓                          ↓
[事务未提交]                [事务未提交]
  ↓                          ↓
提交事务 ✅                  更新缓存 ❌ (事务可能回滚!)
  ↓                          ↓
更新缓存 ✅                  提交事务
  ↓                          ↓
完成                        缓存是脏数据
```

**💡 核心矛盾点**

| 特性对比 | 数据库事务 | 缓存操作 |
|---------|-----------|---------|
| **是否支持回滚** | ✅ 支持 | ❌ 不支持 |
| **操作原子性** | ✅ 保证 | ❌ 独立操作 |
| **一致性保障** | ✅ ACID | ❌ 最终一致性 |
| **更新时机** | 提交时生效 | 立即生效 |

---

## 2. ⏰ 缓存更新的时机选择


### 2.1 四种常见时机对比


**时机分析表**

| 更新时机 | 优势 | 劣势 | 适用场景 |
|---------|------|------|----------|
| **先删缓存,再更新DB** | 简单直接 | 并发时有脏读风险 | 读多写少 |
| **先更新DB,再删缓存** | 数据库优先保证 | 删除失败导致不一致 | 常用方案 |
| **先更新DB,再更新缓存** | 缓存总是最新 | 更新失败、浪费资源 | 缓存必须实时 |
| **事务提交后更新** | ✅ 最安全 | 实现复杂 | **推荐方案** |

### 2.2 错误时机示例


**❌ 在事务中直接更新缓存**
```java
@Transactional
public void updateProduct(Long id, Integer stock) {
    // 更新数据库
    productMapper.updateStock(id, stock);
    
    // ❌ 错误: 事务还没提交就更新缓存
    redisTemplate.opsForValue().set("product:" + id, stock);
    
    // 如果这里抛异常,数据库回滚,但缓存已经更新了!
    if (stock < 0) {
        throw new RuntimeException("库存不能为负");
    }
}
```

**问题分析**
```
时间线分析:

T1: 更新数据库 stock=50
T2: 更新缓存 stock=50  ← 缓存已生效
T3: 业务检查发现错误
T4: 抛出异常
T5: 数据库回滚 stock=100  ← 数据库恢复
T6: 缓存还是50  ← 出现脏数据!

结果: 数据库100,缓存50 → 不一致!
```

---

## 3. 🔄 Cache-Aside模式详解


### 3.1 Cache-Aside模式原理


**🔸 什么是Cache-Aside**
```
Cache-Aside(旁路缓存)模式:
应用程序直接操作缓存和数据库

读流程:
1. 先查缓存
2. 缓存命中 → 返回
3. 缓存未命中 → 查数据库 → 写入缓存 → 返回

写流程:
1. 更新数据库
2. 删除(或更新)缓存
```

**流程图示**
```
读取数据流程:
应用 ────1. 查询────> 缓存
         ↓ 未命中
         2. 查询────> 数据库
         ↓ 返回数据
         3. 写入────> 缓存
         ↓
       返回数据

更新数据流程:
应用 ────1. 更新────> 数据库
         ↓ 更新成功
         2. 删除────> 缓存
         ↓
       更新完成
```

### 3.2 实现代码示例


**基础实现**
```java
@Service
public class ProductService {
    
    @Autowired
    private ProductMapper productMapper;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    // 读取商品信息(Cache-Aside读)
    public Product getProduct(Long id) {
        String key = "product:" + id;
        
        // 1. 先查缓存
        Product product = redisTemplate.opsForValue().get(key);
        if (product != null) {
            return product; // 缓存命中
        }
        
        // 2. 缓存未命中,查数据库
        product = productMapper.selectById(id);
        if (product != null) {
            // 3. 写入缓存,设置过期时间
            redisTemplate.opsForValue().set(key, product, 30, TimeUnit.MINUTES);
        }
        
        return product;
    }
    
    // 更新商品(Cache-Aside写)
    @Transactional
    public void updateProduct(Product product) {
        // 1. 先更新数据库
        productMapper.updateById(product);
        
        // 2. 删除缓存(让下次读取时重新加载)
        String key = "product:" + product.getId();
        redisTemplate.delete(key);
    }
}
```

### 3.3 Cache-Aside的问题


**并发问题场景**
```
两个线程同时操作:

线程A(读):              线程B(写):
T1: 查缓存 miss
T2: 查数据库(旧值)
                        T3: 更新数据库(新值)
                        T4: 删除缓存
T5: 写入缓存(旧值)      
T6: 缓存是旧数据 ❌

问题: 虽然几率很小,但确实会出现缓存写入旧数据
```

**💡 解决方案**
- 设置缓存过期时间(容忍短暂不一致)
- 使用分布式锁控制并发
- 采用延迟双删策略

---

## 4. 📝 Write-Through模式详解


### 4.1 Write-Through模式原理


**🔸 工作机制**
```
Write-Through(直写)模式:
应用程序只操作缓存,由缓存层负责同步到数据库

写流程:
1. 应用写入缓存
2. 缓存层同步写入数据库
3. 两个都成功才返回成功

特点:
- 写入较慢(同步等待)
- 数据一致性好
- 实现复杂度高
```

**架构对比**
```
Cache-Aside:           Write-Through:
应用                   应用
 ↓  ↓                   ↓
缓存 数据库             缓存
                        ↓
                      数据库

区别:
左边: 应用直接操作两者
右边: 应用只操作缓存,缓存负责同步
```

### 4.2 实现示例


**自定义Write-Through缓存层**
```java
@Component
public class WriteThroughCache {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProductMapper productMapper;
    
    // Write-Through写入
    @Transactional
    public void set(String key, Product product) {
        try {
            // 1. 先写数据库(在事务中)
            productMapper.updateById(product);
            
            // 2. 再写缓存
            redisTemplate.opsForValue().set(key, product);
            
            // 两个都成功事务才提交
        } catch (Exception e) {
            // 任何失败都回滚
            throw new RuntimeException("Write-Through失败", e);
        }
    }
    
    // Write-Through读取
    public Product get(String key, Long id) {
        // 先查缓存
        Product product = (Product) redisTemplate.opsForValue().get(key);
        
        if (product == null) {
            // 缓存未命中,查数据库并写入缓存
            product = productMapper.selectById(id);
            if (product != null) {
                redisTemplate.opsForValue().set(key, product);
            }
        }
        
        return product;
    }
}
```

### 4.3 模式选择建议


| 场景特征 | 推荐模式 | 原因 |
|---------|---------|------|
| **读多写少** | Cache-Aside | 性能好,实现简单 |
| **写多读少** | Write-Through | 保证一致性 |
| **强一致性要求** | Write-Through | 同步写入 |
| **性能优先** | Cache-Aside | 异步更新 |

---

## 5. ✅ 事务提交后更新缓存


### 5.1 为什么要在事务提交后更新


**时序保证**
```
错误方式(事务中更新):          正确方式(事务后更新):
──────────────────           ──────────────────
开始事务                      开始事务
更新数据库                    更新数据库
更新缓存 ❌                   提交事务 ✅
提交事务                      更新缓存 ✅
(如果回滚,缓存已污染)          (确保DB已持久化)
```

**💡 核心原则**
```
缓存更新必须在事务提交成功之后!

原因:
1. 事务可能回滚 → 缓存不应更新
2. 事务提交前数据未持久化 → 缓存不能先更新
3. 保证数据库是唯一可信数据源
```

### 5.2 TransactionSynchronization实现


**使用Spring事务同步机制**
```java
@Service
public class ProductService {
    
    @Autowired
    private ProductMapper productMapper;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    @Transactional
    public void updateProductWithCache(Product product) {
        // 1. 更新数据库
        productMapper.updateById(product);
        
        // 2. 注册事务同步回调
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    // 3. 事务提交成功后才执行
                    String key = "product:" + product.getId();
                    
                    // 可以选择删除缓存
                    redisTemplate.delete(key);
                    
                    // 或者更新缓存
                    // redisTemplate.opsForValue().set(key, product);
                }
            }
        );
    }
}
```

**完整示例(带异常处理)**
```java
@Transactional
public void updateStock(Long productId, Integer quantity) {
    // 更新数据库
    int rows = productMapper.updateStock(productId, quantity);
    
    if (rows == 0) {
        throw new BusinessException("库存不足");
    }
    
    // 注册事务提交后的缓存清理
    if (TransactionSynchronizationManager.isSynchronizationActive()) {
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    try {
                        // 删除商品缓存
                        redisTemplate.delete("product:" + productId);
                        // 删除库存缓存
                        redisTemplate.delete("stock:" + productId);
                    } catch (Exception e) {
                        // 缓存删除失败不影响主流程
                        log.error("缓存删除失败", e);
                    }
                }
            }
        );
    }
}
```

### 5.3 延迟双删策略


**解决并发问题**
```java
@Transactional
public void updateWithDoubleDelete(Product product) {
    String key = "product:" + product.getId();
    
    // 1. 第一次删除缓存
    redisTemplate.delete(key);
    
    // 2. 更新数据库
    productMapper.updateById(product);
    
    // 3. 事务提交后延迟删除
    TransactionSynchronizationManager.registerSynchronization(
        new TransactionSynchronization() {
            @Override
            public void afterCommit() {
                // 延迟一小段时间后再次删除
                CompletableFuture.runAsync(() -> {
                    try {
                        Thread.sleep(500); // 延迟500ms
                        redisTemplate.delete(key);
                    } catch (Exception e) {
                        log.error("延迟删除失败", e);
                    }
                });
            }
        }
    );
}
```

**原理说明**
```
为什么要延迟删除?

T1: 删除缓存
T2: 更新数据库
T3: 其他线程读取(可能读到旧数据并写入缓存)
T4: 延迟500ms后再删除一次
T5: 确保脏数据被清理

延迟时间的选择:
- 要大于一次查询的时间
- 一般设置为 100-500ms
```

---

## 6. 🛡️ 缓存穿透问题与防护


### 6.1 什么是缓存穿透


**问题场景**
```
正常情况:
用户请求 → 缓存命中 → 返回数据 ✅

缓存穿透:
用户请求(id=-1) → 缓存未命中 → 查数据库 → 数据不存在 
→ 返回null → 下次请求又查数据库 → 无限循环 ❌

危害:
- 大量无效请求打到数据库
- 缓存完全失效
- 可能被恶意攻击利用
```

**图示说明**
```
正常流程:                缓存穿透:
请求(id=1)               请求(id=-999)
   ↓                       ↓
缓存命中 ✅               缓存未命中
   ↓                       ↓
返回数据                 查数据库
                           ↓
                         数据不存在
                           ↓
                         返回null
                           ↓
                         每次都查DB ❌
```

### 6.2 防护方案一:缓存空值


**实现方式**
```java
public Product getProduct(Long id) {
    String key = "product:" + id;
    
    // 1. 查缓存(包括空值)
    Product product = redisTemplate.opsForValue().get(key);
    
    // 2. 如果缓存了空值标记,直接返回null
    if (product != null && product.getId() == null) {
        return null; // 空对象标记
    }
    
    if (product != null) {
        return product;
    }
    
    // 3. 查数据库
    product = productMapper.selectById(id);
    
    if (product != null) {
        // 存在则缓存实际数据
        redisTemplate.opsForValue().set(key, product, 30, TimeUnit.MINUTES);
    } else {
        // 不存在则缓存空对象标记(设置较短过期时间)
        Product empty = new Product();
        redisTemplate.opsForValue().set(key, empty, 5, TimeUnit.MINUTES);
    }
    
    return product;
}
```

**优化版本(使用特殊值)**
```java
public Product getProduct(Long id) {
    String key = "product:" + id;
    String value = stringRedisTemplate.opsForValue().get(key);
    
    // 使用特殊字符串标记空值
    if ("NULL".equals(value)) {
        return null;
    }
    
    if (value != null) {
        return JSON.parseObject(value, Product.class);
    }
    
    Product product = productMapper.selectById(id);
    
    if (product != null) {
        stringRedisTemplate.opsForValue().set(
            key, JSON.toJSONString(product), 30, TimeUnit.MINUTES);
    } else {
        // 缓存"NULL"字符串标记,过期时间短
        stringRedisTemplate.opsForValue().set(
            key, "NULL", 2, TimeUnit.MINUTES);
    }
    
    return product;
}
```

### 6.3 防护方案二:布隆过滤器


**原理说明**
```
布隆过滤器特点:
- 判断元素一定不存在 → 100%准确 ✅
- 判断元素可能存在 → 有误判概率
- 内存占用极小

使用流程:
1. 系统启动时,将所有商品ID加入布隆过滤器
2. 请求到来,先问布隆过滤器:这个ID存在吗?
3. 不存在 → 直接返回,不查缓存和数据库
4. 可能存在 → 继续查缓存和数据库
```

**Redisson实现**
```java
@Configuration
public class BloomFilterConfig {
    
    @Bean
    public RBloomFilter<Long> productBloomFilter(RedissonClient redisson) {
        RBloomFilter<Long> bloomFilter = redisson.getBloomFilter("product:bloom");
        // 预期元素数量100万,误判率1%
        bloomFilter.tryInit(1000000L, 0.01);
        return bloomFilter;
    }
}

@Service
public class ProductService {
    
    @Autowired
    private RBloomFilter<Long> productBloomFilter;
    
    // 新增商品时加入过滤器
    @Transactional
    public void addProduct(Product product) {
        productMapper.insert(product);
        productBloomFilter.add(product.getId());
    }
    
    // 查询时先过滤
    public Product getProduct(Long id) {
        // 1. 先问布隆过滤器
        if (!productBloomFilter.contains(id)) {
            return null; // 一定不存在,直接返回
        }
        
        // 2. 可能存在,继续正常查询流程
        String key = "product:" + id;
        Product product = redisTemplate.opsForValue().get(key);
        
        if (product == null) {
            product = productMapper.selectById(id);
            if (product != null) {
                redisTemplate.opsForValue().set(key, product);
            }
        }
        
        return product;
    }
}
```

---

## 7. 🏷️ Spring缓存注解与事务


### 7.1 @CacheEvict注解详解


**基本使用**
```java
@Service
public class ProductService {
    
    // 查询时自动缓存
    @Cacheable(value = "products", key = "#id")
    public Product getById(Long id) {
        return productMapper.selectById(id);
    }
    
    // 更新时清除缓存
    @CacheEvict(value = "products", key = "#product.id")
    @Transactional
    public void updateProduct(Product product) {
        productMapper.updateById(product);
    }
    
    // 删除时清除缓存
    @CacheEvict(value = "products", key = "#id")
    @Transactional
    public void deleteProduct(Long id) {
        productMapper.deleteById(id);
    }
}
```

**注解参数说明**

| 参数 | 说明 | 示例 |
|-----|------|------|
| `value` | 缓存名称 | `"products"` |
| `key` | 缓存key,支持SpEL | `"#id"`, `"#product.id"` |
| `allEntries` | 是否清空所有缓存 | `true` |
| `beforeInvocation` | 是否在方法前执行 | `false`(默认方法后) |

### 7.2 缓存注解的事务问题


**⚠️ 默认行为的问题**
```java
@CacheEvict(value = "products", key = "#id")
@Transactional
public void updateProduct(Long id, String name) {
    productMapper.updateName(id, name);
    
    // 如果这里抛异常
    if (name.length() > 50) {
        throw new RuntimeException("名称过长");
    }
}

问题分析:
1. @CacheEvict默认在方法执行后清除缓存
2. 但如果方法抛异常,事务回滚
3. 缓存却已经被清除了
4. 下次读取会重新加载数据库(回滚后的旧数据)
5. 表面上看没问题,但缓存被不必要地清除了
```

**✅ 正确配置**
```java
// 方案1: 使用beforeInvocation=true
@CacheEvict(value = "products", key = "#id", beforeInvocation = true)
@Transactional
public void updateProduct(Long id, String name) {
    // 先清缓存,再更新
    // 即使失败,缓存也已清除,下次会重新加载
    productMapper.updateName(id, name);
}

// 方案2: 手动在事务提交后清除(最安全)
@Transactional
public void updateProductSafe(Long id, String name) {
    productMapper.updateName(id, name);
    
    TransactionSynchronizationManager.registerSynchronization(
        new TransactionSynchronization() {
            @Override
            public void afterCommit() {
                cacheManager.getCache("products").evict(id);
            }
        }
    );
}
```

### 7.3 @CachePut更新缓存


**实时更新缓存**
```java
// @CachePut: 每次都执行方法,并更新缓存
@CachePut(value = "products", key = "#product.id")
@Transactional
public Product updateAndRefresh(Product product) {
    productMapper.updateById(product);
    // 方法返回值会更新到缓存
    return productMapper.selectById(product.getId());
}
```

**⚠️ 注意事项**
```
@CachePut的坑:
1. 总是执行方法(不会走缓存)
2. 用返回值更新缓存
3. 如果方法返回null,缓存也是null

所以不适合:
- 删除操作(返回void)
- 不需要返回最新数据的更新

适合:
- 需要返回最新数据的更新操作
```

---

## 8. 🎯 数据一致性保障方案


### 8.1 一致性级别选择


**一致性要求分类**

| 一致性级别 | 容忍程度 | 实现复杂度 | 适用场景 |
|-----------|---------|-----------|---------|
| **强一致性** | 0秒延迟 | ⭐⭐⭐⭐⭐ | 金融交易 |
| **准实时一致** | 秒级延迟 | ⭐⭐⭐⭐ | 库存扣减 |
| **最终一致性** | 分钟级延迟 | ⭐⭐⭐ | 商品详情 |
| **弱一致性** | 小时级延迟 | ⭐⭐ | 浏览历史 |

### 8.2 强一致性方案


**分布式锁保证**
```java
@Service
public class StrongConsistencyService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    @Transactional
    public void updateWithLock(Long productId, Integer stock) {
        String lockKey = "lock:product:" + productId;
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            // 获取分布式锁
            if (lock.tryLock(10, TimeUnit.SECONDS)) {
                // 1. 删除缓存
                redisTemplate.delete("product:" + productId);
                
                // 2. 更新数据库
                productMapper.updateStock(productId, stock);
                
                // 3. 事务提交后再删一次(双删)
                TransactionSynchronizationManager.registerSynchronization(
                    new TransactionSynchronization() {
                        @Override
                        public void afterCommit() {
                            redisTemplate.delete("product:" + productId);
                        }
                    }
                );
            }
        } finally {
            lock.unlock();
        }
    }
}
```

### 8.3 最终一致性方案


**异步补偿机制**
```java
@Service
public class EventualConsistencyService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Transactional
    public void updateWithMQ(Product product) {
        // 1. 更新数据库
        productMapper.updateById(product);
        
        // 2. 事务提交后发送MQ消息
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    // 发送缓存刷新消息
                    CacheRefreshEvent event = new CacheRefreshEvent();
                    event.setProductId(product.getId());
                    event.setOperation("DELETE");
                    
                    rabbitTemplate.convertAndSend(
                        "cache.exchange",
                        "cache.refresh",
                        event
                    );
                }
            }
        );
    }
}

// 消费端
@Component
public class CacheRefreshListener {
    
    @RabbitListener(queues = "cache.refresh.queue")
    public void handleRefresh(CacheRefreshEvent event) {
        String key = "product:" + event.getProductId();
        
        if ("DELETE".equals(event.getOperation())) {
            redisTemplate.delete(key);
        } else if ("UPDATE".equals(event.getOperation())) {
            // 重新加载数据
            Product product = productMapper.selectById(event.getProductId());
            if (product != null) {
                redisTemplate.opsForValue().set(key, product);
            }
        }
    }
}
```

### 8.4 实用方案总结


**推荐实践**
```
根据业务选择方案:

🔸 金融/交易类(强一致):
  → 分布式锁 + 延迟双删
  → 不使用缓存,直接读数据库

🔸 电商库存(准实时):  
  → 事务提交后删除缓存
  → 布隆过滤器防穿透
  → MQ异步刷新

🔸 商品详情(最终一致):
  → 先更新DB,后删缓存
  → 设置合理过期时间
  → 定时任务兜底刷新

🔸 用户行为(弱一致):
  → 只写缓存,异步持久化
  → 丢失数据可接受
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 缓存一致性本质: 数据库和缓存两个存储的同步问题
🔸 时机最关键: 必须在事务提交后更新缓存
🔸 Cache-Aside: 应用直接操作缓存和DB,最常用
🔸 Write-Through: 缓存层负责同步,保证一致性更好
🔸 缓存穿透: 恶意请求不存在的数据,用布隆过滤器防护
🔸 @CacheEvict: 配合事务使用要注意执行时机
```

### 9.2 关键实践要点


**🔹 缓存更新的金科玉律**
```
1. 永远不要在事务中直接更新缓存
   → 事务可能回滚,缓存已污染

2. 更新优先级: 数据库 > 缓存
   → DB是唯一可信数据源

3. 删除优于更新
   → 删除缓存让下次读取时加载最新数据
   → 更新缓存可能浪费资源(数据不一定被访问)

4. 容忍短暂不一致
   → 设置缓存过期时间
   → 最终一致性对大多数场景够用
```

**🔹 常见问题防护清单**
```
✅ 缓存穿透: 布隆过滤器 + 空值缓存
✅ 缓存击穿: 热点数据永不过期 + 互斥锁
✅ 缓存雪崩: 过期时间加随机值 + 多级缓存
✅ 数据不一致: 事务提交后更新 + 延迟双删
✅ 并发问题: 分布式锁 + 乐观锁
```

### 9.3 方案选择指南


**根据业务场景选择**

```
场景1: 交易金额、账户余额
  → 强一致性要求
  → 方案: 不用缓存或使用分布式锁
  
场景2: 商品库存  
  → 准实时一致性
  → 方案: 事务后删缓存 + MQ刷新

场景3: 商品详情、评论
  → 最终一致性
  → 方案: 定时刷新 + 设置过期时间

场景4: 浏览记录、推荐
  → 弱一致性
  → 方案: 异步更新 + 容错设计
```

### 9.4 核心记忆口诀


```
💡 缓存更新三原则:
数据库改完再删缓存,
事务提交才能真生效,
删除总比更新更安全

💡 问题防护三板斧:
穿透用过滤器来挡,
击穿靠锁来控制,  
雪崩设随机过期时间

💡 一致性保障三步走:
明确业务一致性要求,
选择合适技术方案,
兜底机制不能少
```

**最后提醒** ⚠️
```
记住这个核心:
"宁可查一次数据库,不可让缓存脏数据"

实践中:
- 优先保证数据库正确性
- 缓存只是性能优化手段
- 出问题时缓存可以牺牲
- 监控和告警要做好
```