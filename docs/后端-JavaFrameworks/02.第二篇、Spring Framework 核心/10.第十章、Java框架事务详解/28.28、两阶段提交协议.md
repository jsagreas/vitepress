---
title: 28、两阶段提交协议
---
## 📚 目录

1. [什么是两阶段提交](#1-什么是两阶段提交)
2. [核心角色与职责](#2-核心角色与职责)
3. [2PC工作流程详解](#3-2PC工作流程详解)
4. [XA协议标准](#4-XA协议标准)
5. [三阶段提交(3PC)](#5-三阶段提交3PC)
6. [实际应用与问题](#6-实际应用与问题)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 什么是两阶段提交


### 1.1 为什么需要两阶段提交


**生活中的场景类比**
```
想象你和朋友约好一起去看电影：
第一步：先问大家"能不能来？"（准备阶段）
      朋友A："可以"
      朋友B："可以"  
      朋友C："不行，有事"
      
第二步：根据回复决定
      如果全部OK → "那就去吧！"（提交阶段）
      如果有人不行 → "那算了，取消"（回滚阶段）
```

> 💡 **核心思想**  
> 在分布式系统中，多个数据库要同时完成一件事，就像多个朋友要一起做决定。要么大家都成功，要么大家都放弃，不能出现"有人去了，有人没去"的情况。

### 1.2 分布式事务的挑战


**单机事务 vs 分布式事务**
```
单机事务（简单）：
数据库A：转账 → 成功/失败

分布式事务（复杂）：
数据库A：扣款  ──┐
                 ├─ 要么都成功，要么都失败
数据库B：到账  ──┘

问题：
• A成功了，B失败了怎么办？
• A失败了，B成功了怎么办？  
• 网络断了怎么办？
```

**2PC要解决的核心问题**
- ✅ **原子性保证**：多个数据库操作要么全成功，要么全失败
- ✅ **一致性协调**：统一各个数据库的最终状态
- ✅ **故障恢复**：处理网络故障、节点宕机等异常

---

## 2. 👥 核心角色与职责


### 2.1 三个关键角色


```
分布式事务参与者：

        应用程序
           ↓
    ┌──────────────┐
    │ 事务协调器(TM)│ ← 总指挥官
    │ Transaction  │
    │  Manager     │
    └──────┬───────┘
           ↓ 协调
    ┌──────┴───────────────┐
    ↓                      ↓
┌─────────┐          ┌─────────┐
│资源管理器│          │资源管理器│ ← 执行者
│   RM1   │          │   RM2   │
│(数据库A) │          │(数据库B) │
└─────────┘          └─────────┘
```

### 2.2 角色详解


**🎯 事务协调器(Transaction Manager)**
```
作用：分布式事务的"总指挥"
职责：
• 发起事务准备请求
• 收集各个资源管理器的响应
• 决定最终提交还是回滚
• 通知所有参与者执行决定

就像：电影约局的发起人，负责询问和最终决策
```

**🛠️ 资源管理器(Resource Manager)**  
```
作用：具体执行事务操作的"执行者"
职责：
• 执行本地事务操作
• 响应协调器的准备请求
• 根据协调器指令提交或回滚
• 记录事务日志便于恢复

就像：每个被邀请的朋友，负责确认和执行
```

**📱 应用程序**
```
作用：业务发起方
职责：
• 定义业务逻辑
• 调用事务协调器开始分布式事务
• 处理事务结果

就像：你自己，想要组织这次活动的人
```

---

## 3. ⚙️ 2PC工作流程详解


### 3.1 完整流程图


```
应用程序          协调器(TM)         RM1(数据库A)    RM2(数据库B)
   ↓                ↓                    ↓              ↓
开始事务
   |
   |--[1]请求执行-->|
   |                |
   |                |--[2]准备请求------->|
   |                |                     |--执行但不提交
   |                |                     |--写Undo日志
   |                |<--[3]准备成功-------|
   |                |
   |                |--[4]准备请求---------------------->|
   |                |                                    |--执行但不提交
   |                |                                    |--写Undo日志
   |                |<--[5]准备成功-----------------------|
   |                |
   |                |--[6]决策：提交
   |                |
   |                |--[7]提交指令-------->|
   |                |                     |--正式提交
   |                |<--[8]提交完成-------|
   |                |
   |                |--[9]提交指令---------------------->|
   |                |                                    |--正式提交
   |                |<--[10]提交完成----------------------|
   |                |
   |<--[11]事务成功--|
```

### 3.2 阶段一：准备阶段(Prepare)


**📝 做什么？**
```
协调器问所有参与者："你们能完成任务吗？"
参与者回答："可以" 或 "不可以"
```

**🔧 具体步骤**

1. **协调器发送准备请求**
   ```
   协调器 → 所有RM："请准备执行事务"
   ```

2. **资源管理器执行准备操作**
   ```
   每个RM做三件事：
   
   ✅ 执行事务操作（但不提交）
      - 检查数据
      - 加锁
      - 执行SQL
   
   ✅ 记录Undo日志
      - 保存原始数据
      - 记录回滚信息
   
   ✅ 记录Redo日志  
      - 保存新数据
      - 记录提交信息
   ```

3. **返回准备结果**
   ```
   RM → 协调器：
   • "Yes, 准备好了" (投票同意)
   • "No, 无法执行" (投票拒绝)
   ```

> ⚠️ **注意事项**  
> 准备阶段执行完后，资源是被锁定的！就像你已经坐在电影院门口等着，但还没进去。

### 3.3 阶段二：提交阶段(Commit)


**📝 做什么？**
```
协调器根据投票结果，通知所有参与者最终决定：
• 所有人都同意 → "执行提交"
• 有人拒绝 → "执行回滚"
```

**✅ 情况1：全部同意，执行提交**

```
协调器的决策逻辑：
if (所有RM都返回Yes) {
    发送 "Commit" 指令
    等待所有RM完成提交
    返回事务成功
}
```

```
流程：
1. 协调器 → 所有RM："正式提交"
2. 每个RM：
   - 正式提交本地事务
   - 释放锁定的资源
   - 删除Undo日志
3. RM → 协调器："提交完成"
4. 协调器：事务成功结束
```

**❌ 情况2：有人拒绝，执行回滚**

```
协调器的决策逻辑：
if (任何一个RM返回No || 超时未响应) {
    发送 "Rollback" 指令
    等待所有RM完成回滚
    返回事务失败
}
```

```
流程：
1. 协调器 → 所有RM："执行回滚"
2. 每个RM：
   - 使用Undo日志回滚数据
   - 释放锁定的资源  
   - 删除Redo日志
3. RM → 协调器："回滚完成"
4. 协调器：事务失败结束
```

### 3.4 实际案例演示


**场景：跨行转账**
```
小明(账户A)向小红(账户B)转账1000元
数据库1：小明的银行
数据库2：小红的银行
```

**阶段一：准备阶段**
```
协调器 → 数据库1："准备从小明账户扣1000元"
数据库1：
  - 检查余额够不够 ✓
  - 锁定小明账户
  - 执行扣款SQL（未提交）
  - 记录日志：原余额5000 → 新余额4000
  - 返回："准备好了"

协调器 → 数据库2："准备给小红账户加1000元"  
数据库2：
  - 检查账户是否存在 ✓
  - 锁定小红账户
  - 执行加款SQL（未提交）
  - 记录日志：原余额3000 → 新余额4000
  - 返回："准备好了"
```

**阶段二：提交阶段**
```
协调器判断：两个数据库都准备好了 ✓

协调器 → 数据库1："提交"
数据库1：
  - 正式提交事务
  - 小明余额变成4000
  - 释放账户锁
  - 返回："提交成功"

协调器 → 数据库2："提交"
数据库2：
  - 正式提交事务  
  - 小红余额变成4000
  - 释放账户锁
  - 返回："提交成功"

最终结果：转账成功！
```

---

## 4. 🔗 XA协议标准


### 4.1 什么是XA协议


**📖 基本概念**
```
XA协议 = X/Open DTP（分布式事务处理）标准
作用：定义了事务协调器和资源管理器之间的接口规范
由来：X/Open组织制定的工业标准
```

> 💡 **通俗理解**  
> XA协议就像是一套"通用语言"，让不同的数据库都能按照同样的方式参与分布式事务。就像大家都说普通话，就能一起交流。

### 4.2 XA接口函数


**核心接口方法**

| 方法 | 阶段 | 作用 | 通俗解释 |
|------|------|------|----------|
| `xa_start` | 准备 | 开始事务分支 | "开始你的任务" |
| `xa_end` | 准备 | 结束事务分支 | "任务执行完了" |
| `xa_prepare` | 准备 | 准备提交 | "准备好了吗？" |
| `xa_commit` | 提交 | 提交事务 | "正式提交" |
| `xa_rollback` | 回滚 | 回滚事务 | "全部撤销" |
| `xa_recover` | 恢复 | 恢复未完成事务 | "查看未完成的任务" |

**简化的Java示例**
```java
// XA事务的基本使用流程
public void xaTransaction() {
    // 1. 获取XA资源
    XADataSource xaDS1 = getXADataSource1();
    XADataSource xaDS2 = getXADataSource2();
    
    XAConnection xaConn1 = xaDS1.getXAConnection();
    XAConnection xaConn2 = xaDS2.getXAConnection();
    
    XAResource xaRes1 = xaConn1.getXAResource();
    XAResource xaRes2 = xaConn2.getXAResource();
    
    // 2. 开始XA事务
    Xid xid1 = createXid();
    Xid xid2 = createXid();
    
    xaRes1.start(xid1, XAResource.TMNOFLAGS);
    xaRes2.start(xid2, XAResource.TMNOFLAGS);
    
    // 3. 执行业务操作
    executeSQL1(xaConn1); // 数据库1操作
    executeSQL2(xaConn2); // 数据库2操作
    
    // 4. 结束XA分支
    xaRes1.end(xid1, XAResource.TMSUCCESS);
    xaRes2.end(xid2, XAResource.TMSUCCESS);
    
    // 5. 准备阶段
    int vote1 = xaRes1.prepare(xid1);
    int vote2 = xaRes2.prepare(xid2);
    
    // 6. 提交阶段
    if (vote1 == XA_OK && vote2 == XA_OK) {
        xaRes1.commit(xid1, false);
        xaRes2.commit(xid2, false);
    } else {
        xaRes1.rollback(xid1);
        xaRes2.rollback(xid2);
    }
}
```

### 4.3 XA事务ID(Xid)


**Xid组成结构**
```
XA事务ID包含三部分：

┌─────────────────────────┐
│  格式标识(formatId)      │ ← 标识XA事务的格式
├─────────────────────────┤
│  全局事务ID(gtrid)       │ ← 全局唯一的事务标识
├─────────────────────────┤  
│  分支限定符(bqual)       │ ← 区分同一事务的不同分支
└─────────────────────────┘

作用：
• gtrid - 标识整个分布式事务
• bqual - 标识事务在某个数据库上的分支
```

**为什么需要Xid？**
```
场景：一个事务操作3个数据库

全局事务ID(gtrid)：TX-2025092301
                     ↓
        ┌────────────┼────────────┐
        ↓            ↓            ↓
    分支1(bqual)  分支2(bqual)  分支3(bqual)
    数据库A       数据库B       数据库C
    TX-01        TX-02        TX-03

每个分支有独立标识，但都属于同一个全局事务
```

---

## 5. 🔄 三阶段提交(3PC)


### 5.1 为什么要有3PC


**2PC的问题**
```
问题场景：
阶段二时，协调器发出提交指令后突然崩溃

数据库A：收到提交指令 → 已提交 ✓
数据库B：没收到指令 → 一直等待 ⏳ (阻塞！)

后果：
• 数据库B被锁定资源无法释放
• 系统陷入不确定状态
• 只能人工介入处理
```

> ⚠️ **2PC的致命缺陷**  
> - **同步阻塞**：参与者在等待协调器指令期间，资源被锁定
> - **单点故障**：协调器崩溃导致所有参与者阻塞
> - **数据不一致**：网络分区可能导致部分提交部分回滚

### 5.2 3PC改进思路


**核心改进：增加超时机制**
```
2PC：参与者会一直等待协调器指令（可能永久阻塞）
3PC：参与者等待超时后，可以自己决定提交（减少阻塞）
```

**三个阶段**
```
阶段一：CanCommit（询问）
       ↓
阶段二：PreCommit（预提交）
       ↓
阶段三：DoCommit（正式提交）
```

### 5.3 3PC详细流程


**阶段一：CanCommit(询问阶段)**
```
协调器 → 所有RM："你们能执行这个事务吗？"
                （仅询问，不执行）

RM检查：
• 资源是否可用？
• 数据是否满足条件？  
• 返回 Yes 或 No

特点：轻量级检查，不加锁，不执行
```

**阶段二：PreCommit(预提交阶段)**
```
如果阶段一全部同意：

协调器 → 所有RM："执行预提交"

RM执行：
• 执行事务操作（但不提交）
• 加锁
• 记录日志
• 返回 "预提交成功"

这一步和2PC的准备阶段类似
```

**阶段三：DoCommit(正式提交阶段)**
```
如果阶段二全部成功：

协调器 → 所有RM："正式提交"

RM执行：
• 正式提交事务
• 释放锁
• 返回 "提交完成"
```

### 5.4 3PC的超时机制


**关键改进点**
```
场景：阶段三时协调器崩溃

2PC做法：
参与者：一直等待... (阻塞)

3PC做法：
参与者：等待超时 → 自动提交
理由：既然已经预提交成功，说明大家都准备好了
```

**流程对比**
```
         2PC                    3PC
          ↓                      ↓
    ┌─────────┐           ┌──────────┐
    │ 准备阶段 │           │询问阶段   │(不加锁)
    └─────────┘           └──────────┘
          ↓                      ↓
    ┌─────────┐           ┌──────────┐
    │ 提交阶段 │           │预提交阶段 │(加锁执行)
    └─────────┘           └──────────┘
                                ↓
                          ┌──────────┐
                          │正式提交   │(释放锁)
                          └──────────┘
                                
优势：减少阻塞时间，提高可用性
劣势：实现更复杂，仍可能数据不一致
```

---

## 6. 🚀 实际应用与问题


### 6.1 2PC在Java中的实现


**主流实现方式**

`#JTA` `#Atomikos` `#Narayana`

**使用Spring + Atomikos实现**
```java
@Configuration
public class AtomikosConfig {
    
    // 配置第一个数据源
    @Bean
    public DataSource dataSource1() {
        AtomikosDataSourceBean ds = new AtomikosDataSourceBean();
        ds.setUniqueResourceName("ds1");
        ds.setXaDataSourceClassName("com.mysql.cj.jdbc.MysqlXADataSource");
        // ... 其他配置
        return ds;
    }
    
    // 配置第二个数据源
    @Bean
    public DataSource dataSource2() {
        AtomikosDataSourceBean ds = new AtomikosDataSourceBean();
        ds.setUniqueResourceName("ds2");
        ds.setXaDataSourceClassName("com.mysql.cj.jdbc.MysqlXADataSource");
        // ... 其他配置
        return ds;
    }
    
    // 配置JTA事务管理器
    @Bean
    public JtaTransactionManager transactionManager() {
        UserTransactionManager utm = new UserTransactionManager();
        UserTransactionImp uti = new UserTransactionImp();
        return new JtaTransactionManager(uti, utm);
    }
}

// 业务代码使用
@Service
public class TransferService {
    
    @Autowired
    private DataSource dataSource1;
    
    @Autowired  
    private DataSource dataSource2;
    
    @Transactional // 自动管理分布式事务
    public void transfer(String from, String to, int amount) {
        // 操作数据源1
        jdbcTemplate1.update("UPDATE account SET balance = balance - ? WHERE id = ?", 
                            amount, from);
        
        // 操作数据源2
        jdbcTemplate2.update("UPDATE account SET balance = balance + ? WHERE id = ?", 
                            amount, to);
        
        // 如果任何操作失败，自动回滚两个数据库
    }
}
```

### 6.2 2PC的性能问题


**问题清单**

| 问题 | 原因 | 影响 | 通俗解释 |
|------|------|------|----------|
| **同步阻塞** | 准备阶段锁定资源 | 并发性能下降 | 像排队等人，后面的人都堵着 |
| **单点故障** | 协调器崩溃 | 参与者长时间阻塞 | 总指挥不在了，大家不知道怎么办 |
| **数据不一致** | 网络分区导致部分提交 | 数据状态不一致 | 有人提交了，有人没提交 |
| **性能开销** | 两阶段通信+日志记录 | 响应时间增加 | 来回沟通耗时长 |

**性能对比**
```
单机事务：
执行时间：10ms
吞吐量：1000 TPS

2PC分布式事务：
执行时间：50-100ms (增加5-10倍)
吞吐量：100-200 TPS (降低80%)

主要开销：
• 网络通信：2轮通信 × 参与者数量
• 资源锁定：准备阶段到提交阶段
• 日志写入：每个参与者都要写日志
```

### 6.3 实际应用建议


**✅ 适合使用2PC的场景**
```
强一致性要求：
• 金融转账系统
• 订单支付系统  
• 库存扣减操作

参与者较少：
• 2-3个数据库
• 操作时间短
• 并发量不大

允许性能损耗：
• 对延迟不敏感
• 数据准确性优先
```

**❌ 不适合使用2PC的场景**
```
高并发系统：
• 电商秒杀
• 抢红包活动
• 高频交易系统

跨地域部署：
• 网络延迟大
• 故障率高
• 通信成本高

微服务架构：
• 服务数量多
• 链路复杂
• 建议用最终一致性方案(Saga、TCC)
```

### 6.4 优化建议


**🔧 性能优化策略**

1. **减少参与者数量**
   ```
   原方案：订单服务 + 库存服务 + 积分服务 (3个参与者)
   优化：将积分改为异步消息 (减少到2个参与者)
   ```

2. **缩短事务时间**
   ```
   ❌ 不要在事务中：
   • 调用外部API
   • 执行复杂计算  
   • 进行文件操作
   
   ✅ 事务中只做：
   • 数据库读写
   • 必要的数据验证
   ```

3. **合理设置超时时间**
   ```java
   @Transactional(timeout = 5) // 5秒超时
   public void transfer() {
       // 如果5秒内未完成，自动回滚
   }
   ```

4. **使用连接池**
   ```
   避免：每次事务都创建新连接
   使用：连接池复用连接
   
   配置示例：
   - 最小连接数：10
   - 最大连接数：50
   - 连接超时：30秒
   ```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


`#2PC` `#3PC` `#XA协议` `#分布式事务`

**🔸 两阶段提交(2PC)**
```
本质：协调多个数据库保证事务原子性的协议
核心：准备阶段 + 提交阶段
优点：强一致性保证
缺点：性能差、同步阻塞、单点故障
```

**🔸 三个关键角色**
```
• 事务协调器(TM)：总指挥，发起和协调事务
• 资源管理器(RM)：执行者，具体操作数据库
• 应用程序：业务发起方
```

**🔸 XA协议**
```
定义：分布式事务处理的工业标准
作用：统一不同数据库参与分布式事务的接口
核心接口：xa_prepare、xa_commit、xa_rollback
```

**🔸 三阶段提交(3PC)**
```
改进点：增加超时机制，减少阻塞
三阶段：CanCommit → PreCommit → DoCommit
优势：降低阻塞概率，提高可用性
劣势：实现复杂，仍可能不一致
```

### 7.2 关键理解要点


**🔹 为什么需要两个阶段？**
```
一个阶段不行吗？

假设只有一个阶段：
协调器："你们都提交吧"
数据库A：提交成功 ✓
数据库B：提交失败 ✗ (但A已经提交了！)

结果：数据不一致

两个阶段的价值：
阶段一：先问能不能做（试探）
阶段二：确定都能做了再执行（行动）
```

**🔹 2PC vs 3PC 如何选择？**
```
使用2PC：
• 参与者少(2-3个)
• 网络稳定
• 强一致性要求
• 实现简单

使用3PC：  
• 参与者多
• 网络不稳定
• 需要更高可用性
• 可接受实现复杂度
```

**🔹 为什么性能差？**
```
性能瓶颈分析：

网络通信：
• 准备阶段：1次请求 + N次响应
• 提交阶段：1次请求 + N次响应
• 总计：2轮通信，N个参与者就是2N次

资源锁定：
• 准备阶段开始锁定
• 提交完成才释放
• 锁定时间 = 两个阶段总时长

日志开销：
• 每个RM都要写Undo/Redo日志
• 磁盘IO操作，较慢
```

### 7.3 实际应用价值


**💼 业务场景应用**
```
✅ 适用场景：
• 银行转账：跨行转账必须强一致
• 订单支付：订单和支付必须同步
• 库存扣减：下单和减库存必须原子

❌ 不适用场景：
• 高并发秒杀：性能无法承受
• 微服务调用链：参与者过多
• 跨地域部署：网络延迟太大
```

**🔧 工程实践建议**
```
设计原则：
• 尽量减少分布式事务
• 优先考虑业务层面解决
• 实在必要才用2PC

实施要点：
• 合理设置超时时间
• 做好异常处理和补偿
• 监控事务执行情况
• 准备回滚和恢复方案
```

### 7.4 学习路径指引


```
📚 学习进度：新手 ▶ 入门 ▶ 熟练 ▷ 精通

第1步：理解基本概念 ⭐
• 什么是分布式事务
• 为什么需要2PC
• 三个角色的职责

第2步：掌握工作流程 ⭐⭐
• 准备阶段详细过程
• 提交/回滚决策机制  
• 异常情况处理

第3步：实践应用 ⭐⭐⭐
• 使用JTA实现2PC
• Spring集成Atomikos
• 实际项目应用

第4步：深入优化 ⭐⭐⭐⭐
• 性能调优策略
• 故障恢复方案
• 替代方案选型
```

**核心记忆口诀**
```
两阶段提交保一致，准备提交分两步
先问能否后决定，要么全成要么无
XA协议做标准，三个角色配合舞
虽然可靠性能差，强一致性首选路
```

---

## 📖 延伸学习


**相关主题**
- 🔗 [最终一致性方案(Saga模式)](/pages/saga-pattern/) - 性能更好的替代方案
- 🔗 [TCC分布式事务](/pages/tcc-transaction/) - 灵活的补偿型事务
- 🔗 [本地消息表方案](/pages/local-message/) - 基于消息的最终一致性

**实践建议**
> 💡 建议先用2PC理解分布式事务的本质，再学习其他方案。2PC虽然性能差，但概念最清晰，是理解其他方案的基础。