---
title: 8、PlatformTransactionManager接口
---
## 📚 目录

1. [什么是PlatformTransactionManager](#1-什么是PlatformTransactionManager)
2. [三大核心方法详解](#2-三大核心方法详解)
3. [TransactionDefinition事务定义](#3-TransactionDefinition事务定义)
4. [TransactionStatus事务状态](#4-TransactionStatus事务状态)
5. [常用实现类介绍](#5-常用实现类介绍)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 什么是PlatformTransactionManager


### 1.1 接口的作用


**通俗理解**：想象你去银行办理转账业务，PlatformTransactionManager就像是银行的"业务窗口"，它负责：
- 开启转账业务（开启事务）
- 确认转账成功（提交事务）
- 取消转账操作（回滚事务）

```
现实场景                    Spring事务管理
银行业务窗口        ←→    PlatformTransactionManager
开始办理业务        ←→    getTransaction()开启事务
确认业务完成        ←→    commit()提交事务
业务出错取消        ←→    rollback()回滚事务
```

### 1.2 为什么需要这个接口


**核心问题**：不同的数据库访问技术有不同的事务处理方式

```
使用JDBC：     需要Connection来管理事务
使用Hibernate： 需要Session来管理事务
使用JPA：      需要EntityManager来管理事务
```

**Spring的解决方案**：提供统一的接口，屏蔽底层差异

```java
// Spring提供的统一接口
public interface PlatformTransactionManager {
    // 获取事务（开启事务）
    TransactionStatus getTransaction(TransactionDefinition definition);
    
    // 提交事务
    void commit(TransactionStatus status);
    
    // 回滚事务
    void rollback(TransactionStatus status);
}
```

> 💡 **核心价值**：无论你用JDBC、Hibernate还是JPA，都用同样的方式管理事务，这就是"抽象"的威力

### 1.3 接口设计的精妙之处


**设计模式**：策略模式的典型应用

```
抽象层（接口）
    ↓
PlatformTransactionManager
    ↓
    ├── DataSourceTransactionManager（JDBC/MyBatis专用）
    ├── HibernateTransactionManager（Hibernate专用）
    └── JpaTransactionManager（JPA专用）
```

> ⭐ **好处**：更换数据访问技术时，只需要更换实现类，业务代码完全不用改

---

## 2. ⚙️ 三大核心方法详解


### 2.1 getTransaction()方法


**方法签名**：
```java
TransactionStatus getTransaction(TransactionDefinition definition)
```

**通俗解释**：这个方法就像"开启业务"的按钮

**① 方法作用**
- 获取一个事务对象
- 如果当前已有事务，根据传播行为决定是加入还是新建
- 返回事务状态对象，记录事务信息

**② 参数详解：TransactionDefinition**

```
TransactionDefinition就像"业务办理单"，上面写着：
┌────────────────────────────┐
│  业务办理要求单              │
├────────────────────────────┤
│ • 隔离级别：READ_COMMITTED  │
│ • 传播行为：REQUIRED        │
│ • 超时时间：30秒            │
│ • 是否只读：否              │
└────────────────────────────┘
```

**③ 返回值：TransactionStatus**

```java
TransactionStatus status = manager.getTransaction(definition);
// status记录了：
// - 这是新事务还是已有事务
// - 事务是否已完成
// - 是否需要回滚
```

**④ 实际使用示例**

```java
// 创建事务定义
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

// 获取事务
TransactionStatus status = transactionManager.getTransaction(def);
```

> 💡 **记忆要点**：getTransaction就是"开门迎客"，准备好为你办理业务

### 2.2 commit()方法


**方法签名**：
```java
void commit(TransactionStatus status)
```

**通俗解释**：业务办理成功，盖章确认

**① 方法作用**
- 将所有数据库操作真正写入数据库
- 释放事务占用的资源（锁、连接等）
- 让其他事务可以看到你的修改

**② 提交的前提条件**

```
能提交的情况：
✅ 所有操作都执行成功
✅ 没有标记为回滚（setRollbackOnly）
✅ 事务还没有完成

不能提交的情况：
❌ 有操作执行失败
❌ 已标记为仅回滚
❌ 事务已经完成
```

**③ 提交的执行流程**

```
用户调用commit()
    ↓
检查事务状态
    ↓
    ├── 需要回滚？ → 执行rollback()
    └── 可以提交？ → 真正提交到数据库
                      ↓
                   释放资源
                      ↓
                   标记事务完成
```

**④ 实际使用示例**

```java
TransactionStatus status = null;
try {
    status = transactionManager.getTransaction(def);
    
    // 执行数据库操作
    accountDao.deduct(fromId, money);  // 扣钱
    accountDao.add(toId, money);       // 加钱
    
    // 提交事务
    transactionManager.commit(status);  // ← 这里盖章确认
    
} catch (Exception e) {
    // 出错了，下面会回滚
}
```

> ⚠️ **注意**：commit方法不抛异常，如果需要回滚会自动执行rollback

### 2.3 rollback()方法


**方法签名**：
```java
void rollback(TransactionStatus status)
```

**通俗解释**：业务办理出错，撤销所有操作

**① 方法作用**
- 撤销所有未提交的数据库操作
- 恢复到事务开始前的状态
- 释放事务资源

**② 什么时候需要回滚**

```
必须回滚的场景：
🚨 代码抛出异常
🚨 手动调用setRollbackOnly()
🚨 超时未完成
🚨 违反数据库约束（主键冲突等）
```

**③ 回滚的执行流程**

```
发生异常
    ↓
捕获异常
    ↓
调用rollback(status)
    ↓
撤销所有操作
    ↓
    ├── JDBC：执行connection.rollback()
    ├── Hibernate：执行session.rollback()
    └── JPA：执行entityManager.rollback()
    ↓
释放资源
    ↓
恢复到事务前状态
```

**④ 实际使用示例**

```java
TransactionStatus status = null;
try {
    status = transactionManager.getTransaction(def);
    
    accountDao.deduct(fromId, money);  // 扣钱成功
    
    // 模拟出错
    int result = 10 / 0;  // 除零异常！
    
    accountDao.add(toId, money);       // 这行不会执行
    
    transactionManager.commit(status);
    
} catch (Exception e) {
    if (status != null) {
        // 回滚：扣的钱会退回去
        transactionManager.rollback(status);  // ← 撤销操作
    }
}
```

> 💡 **核心理解**：rollback就像"ctrl+z"撤销键，让数据库回到操作前的状态

### 2.4 三个方法的协作关系


```
正常流程（成功）：
getTransaction() → 执行业务 → commit()
      ↓              ↓           ↓
    开启事务      操作数据库    确认提交

异常流程（失败）：
getTransaction() → 执行业务 → 发生异常 → rollback()
      ↓              ↓           ↓            ↓
    开启事务      操作数据库    捕获错误    撤销操作
```

---

## 3. 📋 TransactionDefinition事务定义


### 3.1 接口的作用


**通俗理解**：TransactionDefinition就像"办业务的规则说明书"

```
定义事务的4个重要属性：
┌─────────────────────────────┐
│  📋 事务办理规则              │
├─────────────────────────────┤
│  ① 隔离级别                  │
│     防止数据混乱             │
│                              │
│  ② 传播行为                  │
│     多个业务如何配合         │
│                              │
│  ③ 超时时间                  │
│     最多等多久               │
│                              │
│  ④ 是否只读                  │
│     只查询不修改             │
└─────────────────────────────┘
```

### 3.2 四大核心属性详解


**① 隔离级别（Isolation Level）**

**作用**：控制多个事务之间能否看到对方的数据

| 隔离级别 | **说明** | **解决的问题** | **性能** |
|---------|---------|---------------|---------|
| `READ_UNCOMMITTED` | 读未提交：能看到别人没提交的数据 | 无 | ⚡⚡⚡最快 |
| `READ_COMMITTED` | 读已提交：只能看到别人提交后的数据 | 脏读 | ⚡⚡较快 |
| `REPEATABLE_READ` | 可重复读：同一事务多次读取结果一致 | 脏读、不可重复读 | ⚡一般 |
| `SERIALIZABLE` | 串行化：事务排队执行，完全隔离 | 脏读、不可重复读、幻读 | 🐌最慢 |

**生活例子理解**：

```
READ_UNCOMMITTED（读未提交）：
你在ATM机取钱，能看到别人还没确认的转账
→ 可能看到"假"数据

READ_COMMITTED（读已提交）：
你在ATM机取钱，只能看到别人确认后的转账
→ 数据是真的，但可能前后不一致

REPEATABLE_READ（可重复读）：
你查询账户余额，多次查询结果一样
→ 你查询期间，别人的修改你看不到

SERIALIZABLE（串行化）：
你办业务时，别人只能等你办完
→ 最安全，但排队时间长
```

**② 传播行为（Propagation Behavior）**

**作用**：定义多个事务方法互相调用时的行为

**核心传播行为**：

| 传播行为 | **通俗解释** | **使用场景** |
|---------|-------------|-------------|
| `REQUIRED` | 有事务就加入，没有就新建 | ⭐最常用，默认选择 |
| `REQUIRES_NEW` | 总是开启新事务，暂停当前事务 | 需要独立事务时 |
| `SUPPORTS` | 有事务就加入，没有就不用事务 | 查询操作 |
| `NOT_SUPPORTED` | 总是不用事务，有就暂停 | 不需要事务的操作 |
| `NESTED` | 嵌套事务，可以独立回滚 | 部分回滚场景 |

**生活例子理解**：

```
REQUIRED（默认）：
你去银行办业务，前面有人在办，你就排队等
→ 加入已有事务

REQUIRES_NEW：
你办VIP业务，不管前面有没有人，开新窗口
→ 开启新事务

SUPPORTS：
你只是问问情况，有窗口就问，没有也行
→ 支持事务但不强制

NESTED：
你办业务中又办了个子业务，子业务可以单独取消
→ 嵌套事务
```

**③ 超时时间（Timeout）**

```java
// 设置超时30秒
def.setTimeout(30);

如果30秒内没完成：
    ↓
自动回滚
    ↓
抛出异常：TransactionTimedOutException
```

> ⚠️ **注意**：超时时间是从事务开始计算，不是从方法调用开始

**④ 是否只读（Read-only）**

```java
// 设置为只读事务
def.setReadOnly(true);

只读事务的好处：
✅ 数据库可以优化查询性能
✅ 防止误操作修改数据
✅ 某些数据库会加读锁而非写锁
```

> 💡 **使用建议**：纯查询操作设置为只读，能提升性能

### 3.3 实际配置示例


```java
// 创建事务定义对象
DefaultTransactionDefinition def = new DefaultTransactionDefinition();

// 设置隔离级别为：读已提交
def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);

// 设置传播行为为：必须有事务
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

// 设置超时时间：30秒
def.setTimeout(30);

// 设置只读：false（可以修改数据）
def.setReadOnly(false);
```

---

## 4. 📊 TransactionStatus事务状态


### 4.1 接口的作用


**通俗理解**：TransactionStatus就像"业务办理进度单"

```
记录事务执行的状态信息：
┌─────────────────────────────┐
│  📊 事务进度单                │
├─────────────────────────────┤
│  • 是否是新事务              │
│  • 是否有保存点              │
│  • 是否已完成                │
│  • 是否只能回滚              │
└─────────────────────────────┘
```

### 4.2 核心方法详解


**① isNewTransaction()方法**

```java
boolean isNew = status.isNewTransaction();

返回true：
→ 这是新开启的事务
→ commit时会真正提交
→ rollback时会真正回滚

返回false：
→ 这是加入的已有事务
→ commit时可能不提交（等外层提交）
→ rollback时标记回滚（由外层回滚）
```

**生活例子**：
```
新事务：你自己开了个窗口办业务
→ 你决定提交还是取消

加入事务：你加入别人的窗口一起办
→ 要等主办人决定提交还是取消
```

**② hasSavepoint()方法**

```java
boolean hasSavepoint = status.hasSavepoint();

有保存点：
→ 可以回滚到保存点
→ 不影响保存点之前的操作
→ NESTED传播行为会创建保存点
```

**通俗理解**：
```
保存点就像游戏存档：
你玩游戏打到BOSS前存了档
    ↓
打BOSS失败了
    ↓
可以读档重来
    ↓
不用从头开始
```

**③ isCompleted()方法**

```java
boolean isCompleted = status.isCompleted();

返回true：事务已完成（提交或回滚过了）
返回false：事务还在进行中
```

**④ setRollbackOnly()方法**

```java
status.setRollbackOnly();

作用：
→ 标记当前事务必须回滚
→ commit时也会回滚
→ 用于在嵌套方法中标记回滚
```

**实际使用场景**：

```java
public void outerMethod() {
    TransactionStatus status = txManager.getTransaction(def);
    try {
        innerMethod(status);  // 调用内部方法
        
        // 即使这里commit，也会回滚（因为内部标记了）
        txManager.commit(status);
    } catch (Exception e) {
        txManager.rollback(status);
    }
}

public void innerMethod(TransactionStatus status) {
    if (someCondition) {
        // 标记需要回滚
        status.setRollbackOnly();
    }
}
```

### 4.3 状态判断流程


```
获取TransactionStatus
    ↓
执行业务逻辑
    ↓
检查状态
    ↓
    ├── isCompleted() = true？
    │   → 事务已完成，不能再操作
    │
    ├── isRollbackOnly() = true？
    │   → 只能回滚，不能提交
    │
    └── isNewTransaction() = true？
        → 我是主事务，我决定提交或回滚
```

---

## 5. 🔧 常用实现类介绍


### 5.1 DataSourceTransactionManager


**适用场景**：使用JDBC或MyBatis时

**通俗理解**：专门管理数据库连接（Connection）的事务

```java
// 配置示例
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
```

**工作原理**：
```
DataSourceTransactionManager
    ↓
管理Connection对象
    ↓
    ├── getTransaction() → connection.setAutoCommit(false)
    ├── commit()        → connection.commit()
    └── rollback()      → connection.rollback()
```

> 💡 **记忆要点**：用JDBC/MyBatis操作数据库，就用DataSourceTransactionManager

### 5.2 HibernateTransactionManager


**适用场景**：使用Hibernate框架时

```java
// 配置示例
@Bean
public PlatformTransactionManager transactionManager(SessionFactory sessionFactory) {
    return new HibernateTransactionManager(sessionFactory);
}
```

**工作原理**：
```
HibernateTransactionManager
    ↓
管理Hibernate的Session对象
    ↓
    ├── getTransaction() → session.beginTransaction()
    ├── commit()        → transaction.commit()
    └── rollback()      → transaction.rollback()
```

### 5.3 JpaTransactionManager


**适用场景**：使用JPA（Java持久化API）时

```java
// 配置示例
@Bean
public PlatformTransactionManager transactionManager(EntityManagerFactory factory) {
    return new JpaTransactionManager(factory);
}
```

**工作原理**：
```
JpaTransactionManager
    ↓
管理JPA的EntityManager对象
    ↓
    ├── getTransaction() → entityManager.getTransaction().begin()
    ├── commit()        → transaction.commit()
    └── rollback()      → transaction.rollback()
```

### 5.4 如何选择实现类


```
你用的技术          →    选择的实现类
─────────────────────────────────────────
JDBC原生           →    DataSourceTransactionManager
MyBatis            →    DataSourceTransactionManager
Hibernate          →    HibernateTransactionManager
Spring Data JPA    →    JpaTransactionManager
```

> ⚠️ **重要提醒**：一个项目通常只配置一个事务管理器

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 PlatformTransactionManager：Spring事务管理的核心接口
🔸 三大方法：getTransaction()、commit()、rollback()
🔸 TransactionDefinition：定义事务的4个属性（隔离级别、传播行为、超时、只读）
🔸 TransactionStatus：记录事务执行状态
🔸 常用实现类：DataSource、Hibernate、JPA三种
```

### 6.2 关键理解要点


**🔹 接口设计的精妙**
```
统一抽象：
→ 用同样的方式管理不同技术的事务
→ 换技术只需换实现类，业务代码不变
→ 这就是"面向接口编程"的威力
```

**🔹 方法调用顺序**
```
固定流程（编程式事务）：
getTransaction() → 执行业务 → commit()/rollback()
     ↓               ↓              ↓
   开启事务       操作数据库      提交或回滚
```

**🔹 传播行为的本质**
```
REQUIRED（最常用）：
→ 有事务就用已有的
→ 没事务就新建一个
→ 保证一定在事务中执行

REQUIRES_NEW（特殊需求）：
→ 总是新建事务
→ 暂停当前事务
→ 子事务独立提交或回滚
```

### 6.3 实际应用建议


**✅ 最佳实践**
- 默认使用`REQUIRED`传播行为
- 查询操作设置`readOnly=true`
- 合理设置超时时间（防止长时间占用资源）
- 根据数据访问技术选择对应的实现类

**⚠️ 常见错误**
- 不要在一个事务中调用另一个`REQUIRES_NEW`的方法（会暂停当前事务）
- 不要忘记处理异常（否则事务不会回滚）
- 不要在事务方法中捕获所有异常不抛出（会导致事务无法回滚）

**核心记忆口诀**：
```
三个方法记心间：获取、提交、回滚
四个属性要配全：隔离、传播、超时、只读
状态对象很重要：新旧、保存点、是否完成
实现类要选对：JDBC用DataSource
```