---
title: 3、事务并发问题与现象
---
## 📚 目录

1. [为什么会出现并发问题](#1-为什么会出现并发问题)
2. [三大经典读问题](#2-三大经典读问题)
3. [丢失更新问题](#3-丢失更新问题)
4. [数据不一致问题](#4-数据不一致问题)
5. [并发控制机制](#5-并发控制机制)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🤔 为什么会出现并发问题


### 1.1 生活中的并发场景


想象一下这个场景：

```
📱 抢票场景：春运12306抢票
════════════════════════════════════
时间轴：
10:00:00  →  小明查询：有票！准备购买
10:00:01  →  小红查询：有票！准备购买  
10:00:02  →  小明下单：成功！
10:00:03  →  小红下单：失败！票已售出

问题：小红看到有票，但实际已经被卖了
```

这就是**并发问题**的本质！多个人同时操作同一份数据，就可能出现问题。

### 1.2 数据库中的并发本质


**🔸 核心概念**
```
单个事务操作：    多个事务并发：
用户A              用户A    用户B
  ↓                 ↓        ↓
读取数据           读取数据  读取数据
  ↓                 ↓        ↓
修改数据           修改数据  修改数据
  ↓                 ↓   ×    ↓
保存数据           保存数据  保存数据
  ↓                        ↙  ↘
✅正常           ❌可能冲突  ❌可能覆盖
```

**为什么会并发？**
- 💻 **多用户系统**：成千上万用户同时访问
- ⚡ **高性能要求**：不能让用户排队等待
- 🔄 **并发执行**：数据库同时处理多个请求

---

## 2. 📖 三大经典读问题


### 2.1 脏读（Dirty Read）- 读到了不该读的数据


**🎯 什么是脏读？**

> 💡 **通俗理解**
> 
> 就像你看到朋友发了条朋友圈，你刚点赞，他又删了。你点的赞成了"幽灵赞"——你读到了一个"不存在"的数据。

**场景演示**

```
银行转账场景：
═══════════════════════════════════════════════════════════

时间  事务A（转账）              事务B（查询余额）      数据库余额
────────────────────────────────────────────────────────────
T1    开始转账                                        1000元
T2    余额-500元                                      500元 
T3                              读取余额：500元✓      500元
T4    转账失败！回滚                                  1000元
T5                              以为余额是500 ❌      1000元

问题：事务B读到了事务A还没提交的数据（脏数据）！
```

**🔸 问题本质**
- 事务A修改了数据但**还没提交**
- 事务B读取了这个**未提交的数据**
- 事务A最后**回滚了**
- 事务B读到的数据成了"**幽灵数据**"

### 2.2 不可重复读（Non-repeatable Read）- 同一个数据读两次结果不同


**🎯 什么是不可重复读？**

> 💡 **通俗理解**
> 
> 就像你在网上看商品价格是99元，加购物车时再看变成了199元。同一个商品，价格变了！

**场景演示**

```
电商促销场景：
═══════════════════════════════════════════════════════════

时间  事务A（用户购物）          事务B（运营改价）      商品价格
────────────────────────────────────────────────────────────
T1    查询商品价格：99元✓                             99元
T2                              修改价格为199元        
T3                              提交成功✓              199元
T4    准备下单，再次查询                              
T5    发现价格：199元 ❌                              199元
      
问题：同一个事务内，两次读取同一数据，结果不一样！
```

**🔸 问题本质**
- 事务A **第一次读**：数据是A值
- 事务B在中间**修改并提交**了数据
- 事务A **第二次读**：数据变成B值
- 同一个事务内，**读取结果不一致**

**🆚 脏读 vs 不可重复读**

| 对比项 | 脏读 | 不可重复读 |
|--------|------|-----------|
| 读到的数据 | **未提交**的数据 | **已提交**的数据 |
| 问题根源 | 读到脏数据 | 数据被修改 |
| 影响范围 | 可能读到错误数据 | 数据前后不一致 |
| 场景 | 转账回滚 | 价格调整 |

### 2.3 幻读（Phantom Read）- 数据条数变了


**🎯 什么是幻读？**

> 💡 **通俗理解**
> 
> 就像你清点仓库商品，第一次数有10件，刚想记录，再数一次变成了12件。明明没人动，怎么多了？

**场景演示**

```
库存盘点场景：
═══════════════════════════════════════════════════════════

时间  事务A（盘点统计）          事务B（入库操作）      库存记录数
────────────────────────────────────────────────────────────
T1    统计：SELECT COUNT(*)                          10条
T2    结果：10件商品✓                                10条
T3                              新增2件入库           
T4                              提交成功✓             12条
T5    再次统计确认                                    
T6    结果：12件商品 ❌                               12条
      
问题：同一个事务内，两次统计，记录数变了！
```

**🔸 问题本质**
- 事务A **第一次查询**：符合条件的有N条
- 事务B **插入或删除**了符合条件的数据
- 事务A **第二次查询**：符合条件的变成M条
- 查询结果的**数量变化**，像出现了"幻觉"

**🆚 不可重复读 vs 幻读**

| 对比项 | 不可重复读 | 幻读 |
|--------|-----------|------|
| 关注点 | **某条数据的值** | **符合条件的记录数** |
| 变化内容 | 数据值改变 | 数据条数改变 |
| 典型操作 | UPDATE | INSERT / DELETE |
| 解决难度 | 相对容易 | 相对困难 |

**📊 三大读问题对比总结**

```
问题层级：脏读 > 不可重复读 > 幻读
严重程度：🔴    🟡        🟢

┌─────────────────────────────────────────────────┐
│ 脏读（Dirty Read）                              │
│ ├─ 读到未提交数据                               │
│ ├─ 最严重：可能读到错误数据                     │
│ └─ 场景：转账回滚、订单取消                     │
├─────────────────────────────────────────────────┤
│ 不可重复读（Non-repeatable Read）               │
│ ├─ 同一数据两次读取值不同                       │
│ ├─ 中等严重：前后数据不一致                     │
│ └─ 场景：价格变动、状态更新                     │
├─────────────────────────────────────────────────┤
│ 幻读（Phantom Read）                            │
│ ├─ 同一查询两次记录数不同                       │
│ ├─ 相对轻微：统计结果不准                       │
│ └─ 场景：库存盘点、数据统计                     │
└─────────────────────────────────────────────────┘
```

---

## 3. 💥 丢失更新问题


### 3.1 什么是丢失更新


**🎯 核心定义**

> ⚠️ **丢失更新（Lost Update）**
> 
> 两个事务同时修改同一数据，后提交的事务覆盖了先提交的事务的修改，导致第一个事务的更新"丢失"了。

**生活场景类比**

```
文档协作场景：
════════════════════════════════════════════════════
小明和小红同时编辑同一份报告

10:00  小明打开文档：内容是"版本1"
10:01  小红打开文档：内容是"版本1"
10:02  小明修改内容：改成"小明的版本2"
10:03  小明保存成功✓
10:04  小红修改内容：改成"小红的版本2"  
10:05  小红保存成功✓
       
结果：文档最终是"小红的版本2"
问题：小明的修改丢失了！❌
```

### 3.2 丢失更新的两种类型


**🔸 第一类丢失更新（回滚覆盖）**

```
库存扣减场景：
═══════════════════════════════════════════════════════════

时间  事务A（用户A下单）         事务B（用户B下单）      库存数量
────────────────────────────────────────────────────────────
T1    读取库存：100件                                  100
T2                              读取库存：100件         100
T3    扣减1件：99件                                     99
T4                              扣减1件：99件           99
T5    提交失败！回滚                                    100
T6                              提交成功✓               99

问题：事务A的回滚覆盖了事务B的修改！
实际：应该是99件，但回滚后变成100件
```

**🔸 第二类丢失更新（提交覆盖）**

```
账户余额场景：
═══════════════════════════════════════════════════════════

时间  事务A（存款）              事务B（取款）          账户余额
────────────────────────────────────────────────────────────
T1    读取余额：1000元                                 1000
T2                              读取余额：1000元        1000
T3    存入500：1500元                                   
T4                              取出200：800元          
T5    提交成功✓                                        1500
T6                              提交成功✓               800

问题：事务B的提交覆盖了事务A的修改！
实际：应该是1300元（1000+500-200）
结果：变成800元，存款操作丢失了！
```

### 3.3 丢失更新的危害


**📊 影响程度分析**

```
危害等级：🔴🔴🔴🔴🔴 极其严重！

┌─ 数据层面 ──────────────────────┐
│ ├─ 数据不准确                   │
│ ├─ 业务计算错误                 │
│ └─ 历史记录缺失                 │
├─ 业务层面 ──────────────────────┤
│ ├─ 库存统计错误                 │
│ ├─ 财务金额不符                 │
│ └─ 用户权益受损                 │
├─ 系统层面 ──────────────────────┤
│ ├─ 数据完整性破坏               │
│ ├─ 业务逻辑混乱                 │
│ └─ 系统可信度下降               │
└──────────────────────────────────┘
```

---

## 4. 🔄 数据不一致问题


### 4.1 什么是数据不一致


**🎯 核心概念**

> 💡 **数据不一致**
> 
> 指同一份数据在不同事务中呈现不同的状态，或者相关联的数据之间出现矛盾。

### 4.2 常见不一致场景


**场景一：主从数据不一致**

```
订单与库存场景：
════════════════════════════════════════════════════

操作序列：
1. 用户下单：订单创建成功 ✓
2. 扣减库存：库存-1 
3. 网络异常：库存扣减失败 ❌

结果状态：
├─ 订单表：有订单记录 ✓
└─ 库存表：库存未减少 ❌

问题：订单和库存数据不一致！
```

**场景二：统计数据不一致**

```
商品评分场景：
════════════════════════════════════════════════════

商品详情表：
├─ 评分总和：450分
├─ 评价数量：100条
└─ 平均评分：4.5分 ✓

新增评价：+5分（用户好评）

并发问题：
├─ 事务A：更新评分总和 455分 ✓
└─ 事务B：更新评价数量 101条 ✓

最终状态：
├─ 评分总和：455分 ✓
├─ 评价数量：101条 ✓  
└─ 平均评分：4.5分 ❌（应该是4.5049）

问题：平均评分未同步更新！
```

### 4.3 不一致的分类


| 类型 | 描述 | 典型场景 | 严重程度 |
|------|------|----------|---------|
| **暂时不一致** | 短期内数据状态不同步 | 缓存与数据库 | 🟡 中等 |
| **永久不一致** | 数据永久性错误 | 订单与库存 | 🔴 严重 |
| **逻辑不一致** | 业务规则被破坏 | 余额与流水 | 🔴 严重 |
| **统计不一致** | 汇总数据计算错误 | 总数与明细 | 🟡 中等 |

---

## 5. 🛡️ 并发控制机制


### 5.1 悲观锁控制


**🎯 核心思想**

> 🔒 **悲观锁**
> 
> "我很悲观，我觉得数据一定会被别人改，所以我先锁住，用完再解锁"

**工作原理**

```
悲观锁流程：
══════════════════════════════════════════

用户A操作：                    数据库：
  ↓                              
读取数据 ────────────→ 🔒加锁（其他人等待）
  ↓                              
修改数据                        
  ↓                              
保存数据 ────────────→ ✓更新成功
  ↓                              
提交事务 ────────────→ 🔓解锁（其他人可用）

特点：一次只能一个人操作
```

**Java代码示例**

```java
// 悲观锁示例：SELECT ... FOR UPDATE
public void updateStock(Long productId, int quantity) {
    // 开启事务
    // 加锁查询：其他事务必须等待
    Product product = productMapper.selectByIdForUpdate(productId);
    
    // 检查库存
    if (product.getStock() >= quantity) {
        // 扣减库存
        product.setStock(product.getStock() - quantity);
        productMapper.updateById(product);
    }
    
    // 提交事务，自动释放锁
}
```

**优缺点分析**

```
✅ 优点：
├─ 数据安全性高：完全避免并发冲突
├─ 适合冲突频繁场景：如抢购、秒杀
└─ 实现简单：数据库原生支持

❌ 缺点：  
├─ 性能开销大：需要等待锁释放
├─ 可能死锁：多个锁相互等待
└─ 并发度低：一次只能一个事务
```

### 5.2 乐观锁控制


**🎯 核心思想**

> ✨ **乐观锁**
> 
> "我很乐观，我觉得数据不会被改，大家都去读，提交时再检查"

**工作原理**

```
乐观锁流程：
══════════════════════════════════════════

用户A操作：                    数据库：
  ↓                              
读取数据+版本号 ──────→ version=1
  ↓                              
修改数据（本地）                
  ↓                              
提交时检查版本 ────────→ 比对version
  ↓                        ↙      ↘
保存数据              version=1  version≠1
  ↓                       ↓         ↓
                       ✓成功      ❌失败

特点：提交时才检查冲突
```

**版本号机制**

```sql
-- 数据表结构
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    stock INT,
    version INT DEFAULT 0  -- 版本号字段
);

-- 乐观锁更新SQL
UPDATE product 
SET stock = stock - 1,
    version = version + 1  -- 版本号+1
WHERE id = 1001 
  AND version = 5;  -- 检查版本号

-- 返回影响行数：
-- 1 表示更新成功
-- 0 表示版本号已变，更新失败
```

**Java代码示例**

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductMapper productMapper;
    
    // 乐观锁扣减库存
    public boolean reduceStock(Long productId, int quantity) {
        // 最多重试3次
        for (int i = 0; i < 3; i++) {
            // 1. 查询商品和版本号
            Product product = productMapper.selectById(productId);
            
            // 2. 检查库存
            if (product.getStock() < quantity) {
                return false; // 库存不足
            }
            
            // 3. 尝试更新（带版本号检查）
            int rows = productMapper.updateStockWithVersion(
                productId, 
                quantity, 
                product.getVersion()
            );
            
            // 4. 更新成功
            if (rows > 0) {
                return true;
            }
            
            // 5. 版本冲突，重试
            Thread.sleep(10); // 短暂等待
        }
        
        return false; // 重试失败
    }
}
```

**优缺点分析**

```
✅ 优点：
├─ 并发性能好：不需要等待锁
├─ 不会死锁：没有锁机制
└─ 适合读多写少：大部分操作无冲突

❌ 缺点：
├─ 可能更新失败：需要重试机制
├─ ABA问题：版本号相同但数据变化
└─ 不适合高冲突：频繁重试影响性能
```

### 5.3 悲观锁 vs 乐观锁选择


**📊 对比总结**

| 对比项 | 悲观锁 | 乐观锁 |
|--------|--------|--------|
| **加锁时机** | 读取时加锁 | 提交时检查 |
| **并发性能** | 🔴 低（串行执行） | 🟢 高（并行读取） |
| **适用场景** | 写操作频繁 | 读操作频繁 |
| **冲突处理** | 等待锁释放 | 重试或失败 |
| **死锁风险** | ⚠️ 可能死锁 | ✅ 不会死锁 |
| **典型应用** | 秒杀、抢购 | 商品浏览、下单 |

**🎯 选择策略**

```
选择悲观锁：
├─ ✓ 写操作非常频繁
├─ ✓ 冲突概率很高（>50%）
├─ ✓ 必须保证数据一致性
└─ ✓ 典型：秒杀、抢红包

选择乐观锁：
├─ ✓ 读操作远多于写操作
├─ ✓ 冲突概率较低（<10%）
├─ ✓ 可以接受重试
└─ ✓ 典型：商品下单、库存扣减

混合使用：
├─ ✓ 先乐观锁尝试
├─ ✓ 失败后转悲观锁
└─ ✓ 兼顾性能和可靠性
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 三大读问题：
   ├─ 脏读：读到未提交数据
   ├─ 不可重复读：同一数据值变化
   └─ 幻读：查询结果数量变化

🔸 丢失更新：
   ├─ 回滚覆盖：回滚导致更新丢失
   └─ 提交覆盖：后提交覆盖先提交

🔸 数据不一致：
   ├─ 主从不一致
   ├─ 统计不一致
   └─ 逻辑不一致

🔸 并发控制：
   ├─ 悲观锁：先锁后用
   └─ 乐观锁：先用后检查
```

### 6.2 问题严重程度排序


```
并发问题严重程度：
════════════════════════════════════

🔴🔴🔴🔴🔴 丢失更新
├─ 最严重：数据直接丢失
└─ 必须解决：使用锁机制

🔴🔴🔴🔴 脏读  
├─ 非常严重：读到错误数据
└─ 需要避免：提高隔离级别

🔴🔴🔴 不可重复读
├─ 比较严重：数据前后不一致
└─ 看场景：部分场景可接受

🔴🔴 幻读
├─ 相对较轻：统计可能不准
└─ 可容忍：非关键业务
```

### 6.3 实际开发建议


**🎯 新手开发指南**

```
Step 1️⃣：识别并发场景
├─ ❓ 是否多用户同时操作？
├─ ❓ 是否修改同一数据？
└─ ✓ 是 → 需要并发控制

Step 2️⃣：评估冲突概率
├─ 高冲突（>50%）→ 悲观锁
├─ 低冲突（<10%）→ 乐观锁
└─ 中等冲突 → 混合策略

Step 3️⃣：选择隔离级别
├─ 金融系统 → SERIALIZABLE
├─ 电商系统 → REPEATABLE READ
└─ 一般系统 → READ COMMITTED

Step 4️⃣：添加重试机制
├─ 乐观锁失败 → 自动重试
├─ 设置最大次数 → 3-5次
└─ 最终失败 → 友好提示
```

**⚠️ 常见陷阱提醒**

```
❌ 错误做法：
├─ 不加任何并发控制
├─ 盲目使用悲观锁
├─ 忽略死锁问题
└─ 不处理重试失败

✅ 正确做法：
├─ 根据场景选择锁策略
├─ 设置合理的超时时间
├─ 实现完善的重试机制
└─ 监控并发冲突率
```

### 6.4 记忆口诀


> 🧠 **并发问题记忆法**
> 
> *"脏读读脏未提交，*  
> *重复读值前后异，*  
> *幻读条数会变化，*  
> *更新丢失最要命。*  
> *悲观先锁再使用，*  
> *乐观后查版本号，*  
> *冲突多时用悲观，*  
> *读多写少乐观好。"*

**🔖 快速查询表**

| 遇到问题 | 可能原因 | 解决方案 |
|---------|---------|---------|
| 数据莫名消失 | 丢失更新 | 加锁控制 |
| 读到错误数据 | 脏读 | 提高隔离级别 |
| 前后数据不同 | 不可重复读 | 使用快照读 |
| 统计数量不对 | 幻读 | 间隙锁 |
| 库存扣成负数 | 并发扣减 | 悲观锁 |
| 更新总是失败 | 版本冲突 | 乐观锁重试 |

**核心记忆**：
- 并发问题源于多事务同时操作
- 问题类型有读问题、更新问题、一致性问题
- 解决方案是合理使用锁机制
- 根据场景选择悲观锁或乐观锁
- 重要系统必须严格控制并发