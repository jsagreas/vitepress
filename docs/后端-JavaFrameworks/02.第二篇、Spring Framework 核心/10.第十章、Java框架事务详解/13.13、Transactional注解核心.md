---
title: 13、Transactional注解核心
---
## 📚 目录

1. [@Transactional注解概述](#1-Transactional注解概述)
2. [注解使用位置详解](#2-注解使用位置详解)
3. [注解继承与优先级规则](#3-注解继承与优先级规则)
4. [AOP事务拦截机制](#4-AOP事务拦截机制)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🎯 @Transactional注解概述


### 1.1 什么是@Transactional注解


**📋 核心理解**
```
@Transactional就像是给方法贴一个"事务标签"
告诉Spring：这个方法需要事务保护

简单类比：
就像银行转账业务，给柜员一个指令单：
"这笔业务要么全部成功，要么全部取消"
```

**🔸 本质含义**
- **声明式标记**：只需要加个注解，不用写事务代码
- **自动管理**：Spring会自动开启、提交、回滚事务
- **配置化**：通过注解参数配置事务行为

### 1.2 为什么需要这个注解


**传统编程式事务的问题**：
```java
// 传统方式：代码繁琐，容易出错
TransactionStatus status = transactionManager.getTransaction(definition);
try {
    // 业务逻辑
    userDao.save(user);
    accountDao.update(account);
    
    transactionManager.commit(status);  // 手动提交
} catch (Exception e) {
    transactionManager.rollback(status); // 手动回滚
}
```

**使用@Transactional后**：
```java
// 声明式方式：简洁清晰
@Transactional
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 只关注业务逻辑，事务自动管理
    userDao.save(user);
    accountDao.update(account);
}
```

> 💡 **核心优势**：把事务管理从业务代码中分离出来，让代码更清晰

---

## 2. 📍 注解使用位置详解


### 2.1 类级别注解


**🔸 什么是类级别**

在类上加@Transactional，表示这个类的所有public方法都需要事务

```java
@Service
@Transactional  // ← 类级别注解，作用于整个类
public class UserService {
    
    // 这个方法会有事务
    public void createUser(User user) {
        userDao.save(user);
    }
    
    // 这个方法也会有事务
    public void updateUser(User user) {
        userDao.update(user);
    }
}
```

**适用场景**：
- ✅ 当一个Service类的大部分方法都需要事务时
- ✅ 统一管理，避免遗漏
- ✅ 减少重复代码

**实际案例**：
```
订单服务(OrderService)：
- 创建订单 → 需要事务 ✓
- 取消订单 → 需要事务 ✓
- 修改订单 → 需要事务 ✓
- 查询订单 → 可能不需要事务

→ 适合在类上加@Transactional，查询方法单独配置
```

### 2.2 方法级别注解


**🔸 什么是方法级别**

在具体方法上加@Transactional，只对这一个方法生效

```java
@Service
public class UserService {
    
    // 只有这个方法有事务
    @Transactional
    public void createUser(User user) {
        userDao.save(user);
        sendEmail(user);  // 发送邮件
    }
    
    // 这个方法没有事务
    public User getUser(Long id) {
        return userDao.findById(id);
    }
}
```

**适用场景**：
- ✅ 只有个别方法需要事务
- ✅ 需要为特定方法定制事务配置
- ✅ 查询为主的Service类

### 2.3 类级别 vs 方法级别对比


| 对比维度 | **类级别注解** | **方法级别注解** |
|---------|--------------|----------------|
| **作用范围** | `整个类的所有public方法` | `单个方法` |
| **使用场景** | `大部分方法都需要事务` | `少数方法需要事务` |
| **配置灵活性** | `统一配置，不够灵活` | `每个方法可单独配置` |
| **代码简洁度** | `代码简洁，减少重复` | `需要多次添加注解` |
| **推荐用法** | `写操作为主的Service` | `读操作为主的Service` |

**🎯 实战建议**：
```
选择原则：
- 写操作多 → 类级别 + 特殊方法覆盖
- 读操作多 → 方法级别 + 按需添加
- 混合场景 → 类级别(readOnly=true) + 写方法覆盖
```

---

## 3. ⚖️ 注解继承与优先级规则


### 3.1 注解继承机制


**🔸 什么是注解继承**

接口或父类上的@Transactional会被实现类/子类继承

```java
// 场景1：接口上的注解
public interface UserService {
    @Transactional  // 接口方法的注解
    void createUser(User user);
}

@Service
public class UserServiceImpl implements UserService {
    // 自动继承接口的@Transactional
    @Override
    public void createUser(User user) {
        userDao.save(user);
    }
}
```

```java
// 场景2：父类上的注解
@Transactional
public abstract class BaseService {
    // 父类方法有事务
}

@Service
public class UserService extends BaseService {
    // 继承父类的事务配置
    public void createUser(User user) {
        userDao.save(user);
    }
}
```

> ⚠️ **注意**：Spring官方**不推荐**在接口上加@Transactional，建议加在实现类上

### 3.2 注解优先级规则


**🔸 优先级顺序（从高到低）**

```
优先级排序：
1. 方法级别注解（最高优先级）
2. 类级别注解
3. 接口方法注解
4. 接口类级别注解（最低优先级）
```

**实际案例演示**：

```java
@Service
@Transactional(timeout = 30)  // 类级别：超时30秒
public class OrderService {
    
    // 使用类级别配置：超时30秒
    public void createOrder(Order order) {
        orderDao.save(order);
    }
    
    // 方法级别覆盖类级别：超时60秒
    @Transactional(timeout = 60)
    public void batchCreateOrders(List<Order> orders) {
        for (Order order : orders) {
            orderDao.save(order);
        }
    }
}
```

**🎯 优先级规则图示**：

```
优先级覆盖关系：

┌─────────────────────────┐
│  方法级别@Transactional  │ ← 最高优先级（如果存在）
└─────────────────────────┘
            ↓ 覆盖
┌─────────────────────────┐
│   类级别@Transactional   │ ← 次优先级
└─────────────────────────┘
            ↓ 覆盖
┌─────────────────────────┐
│ 接口/父类@Transactional  │ ← 最低优先级
└─────────────────────────┘
```

### 3.3 配置属性的覆盖规则


**🔸 属性级别的覆盖**

方法级注解的每个属性都会覆盖类级注解的对应属性

```java
@Service
@Transactional(
    propagation = Propagation.REQUIRED,    // 传播行为
    isolation = Isolation.DEFAULT,         // 隔离级别
    timeout = 30,                          // 超时时间
    readOnly = false                       // 只读标记
)
public class UserService {
    
    // 部分覆盖：只改超时时间，其他属性继承类级别
    @Transactional(timeout = 60)
    public void batchUpdate(List<User> users) {
        // 最终配置：
        // propagation = REQUIRED (继承)
        // isolation = DEFAULT (继承)
        // timeout = 60 (覆盖)
        // readOnly = false (继承)
    }
    
    // 完全覆盖：所有属性都重新定义
    @Transactional(
        propagation = Propagation.REQUIRES_NEW,
        readOnly = true
    )
    public User getUser(Long id) {
        // 使用方法级别的全新配置
    }
}
```

**关键理解**：
- 方法级注解**不是合并**，而是**覆盖**
- 没指定的属性会用默认值，不是继承类级别的值

---

## 4. 🔄 AOP事务拦截机制


### 4.1 代理模式基础


**🔸 什么是代理模式**

Spring不是直接调用你的方法，而是创建一个"代理对象"来调用

```
没有代理时的调用：
客户端 → 直接调用 → 目标方法

有代理时的调用：
客户端 → 代理对象 → 添加事务逻辑 → 目标方法
                   ↑
              这里加入事务管理
```

**实际工作流程**：

```java
// 你写的代码
@Service
public class UserService {
    @Transactional
    public void createUser(User user) {
        userDao.save(user);  // 业务逻辑
    }
}

// Spring实际执行的伪代码
public class UserServiceProxy {
    private UserService target;
    
    public void createUser(User user) {
        // 1. 开启事务
        beginTransaction();
        
        try {
            // 2. 调用真正的业务方法
            target.createUser(user);
            
            // 3. 提交事务
            commitTransaction();
        } catch (Exception e) {
            // 4. 回滚事务
            rollbackTransaction();
            throw e;
        }
    }
}
```

### 4.2 AOP拦截机制详解


**🔸 拦截过程图示**

```
方法调用流程：

客户端调用
    ↓
┌─────────────────────────┐
│  Spring AOP代理拦截器    │
├─────────────────────────┤
│ 1. 检查@Transactional   │
│ 2. 开启事务             │
│ 3. 设置事务属性         │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│   执行目标方法          │
│   (你的业务代码)        │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│   处理事务结果          │
├─────────────────────────┤
│ 成功 → 提交事务         │
│ 异常 → 回滚事务         │
└─────────────────────────┘
```

**🔸 核心组件**

| 组件 | **作用** | **说明** |
|------|---------|---------|
| `TransactionInterceptor` | `事务拦截器` | `拦截带@Transactional的方法` |
| `TransactionAttributeSource` | `事务属性解析器` | `解析注解的配置信息` |
| `PlatformTransactionManager` | `事务管理器` | `真正执行事务操作` |

### 4.3 两种代理方式


**🔸 JDK动态代理 vs CGLIB代理**

```
JDK动态代理：
- 要求：目标类必须实现接口
- 原理：基于接口创建代理
- 性能：创建快，执行稍慢

    接口UserService
         ↑
         │实现
    UserServiceImpl ← 有接口，使用JDK代理
```

```
CGLIB代理：
- 要求：目标类不能是final
- 原理：通过继承创建子类代理
- 性能：创建慢，执行快

    UserService ← 没接口，使用CGLIB代理
         ↑
         │继承
    UserService$$Proxy
```

**实际配置**：

```java
// Spring Boot默认配置（优先使用CGLIB）
@SpringBootApplication
@EnableTransactionManagement(proxyTargetClass = true)
public class Application {
    // proxyTargetClass = true → 强制使用CGLIB
    // proxyTargetClass = false → 有接口用JDK，无接口用CGLIB
}
```

### 4.4 代理失效的常见情况


> ⚠️ **重要警告**：以下情况事务会失效！

**情况1：同类内部调用**

```java
@Service
public class UserService {
    
    // ❌ 错误：内部调用不走代理，事务失效
    public void outerMethod() {
        this.innerMethod();  // 直接调用，绕过代理
    }
    
    @Transactional
    public void innerMethod() {
        userDao.save(user);  // 事务不会生效！
    }
    
    // ✅ 正确：通过Spring容器调用
    @Autowired
    private UserService self;
    
    public void outerMethodFixed() {
        self.innerMethod();  // 通过代理调用，事务生效
    }
}
```

**情况2：非public方法**

```java
@Service
public class UserService {
    
    // ❌ 错误：private方法事务不生效
    @Transactional
    private void privateMethod() {
        userDao.save(user);
    }
    
    // ❌ 错误：protected方法事务也不生效
    @Transactional
    protected void protectedMethod() {
        userDao.save(user);
    }
    
    // ✅ 正确：必须是public方法
    @Transactional
    public void publicMethod() {
        userDao.save(user);
    }
}
```

> 💡 **核心原因**：Spring AOP代理只能拦截public方法的外部调用

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 @Transactional本质：声明式事务标记，告诉Spring自动管理事务
🔸 使用位置：类级别（整个类）和方法级别（单个方法）
🔸 优先级规则：方法 > 类 > 接口，方法级别会覆盖类级别
🔸 代理机制：Spring通过AOP代理拦截方法，加入事务逻辑
🔸 失效场景：内部调用、非public方法会导致事务失效
```

### 5.2 关键理解要点


**🔹 为什么要用声明式事务**
```
传统方式的问题：
- 事务代码和业务代码混在一起
- 容易忘记提交或回滚
- 代码重复，难以维护

声明式事务的优势：
- 业务代码和事务管理分离
- 配置简单，一个注解搞定
- Spring自动管理，不易出错
```

**🔹 类级别和方法级别如何选择**
```
判断依据：
→ 大部分方法需要事务：用类级别
→ 少数方法需要事务：用方法级别
→ 需要不同配置：方法级别覆盖类级别

实战技巧：
→ 写操作为主：类级别 + 查询方法特殊配置
→ 读操作为主：方法级别 + 按需添加
```

**🔹 代理机制为什么重要**
```
核心理解：
- 事务不是"魔法"，是通过代理实现的
- 只有通过代理调用才能触发事务
- 内部调用绕过了代理，所以事务失效

记忆技巧：
代理 = 中间商，必须通过中间商才能加入事务控制
```

### 5.3 实战应用指南


**📌 最佳实践**

```java
// ✅ 推荐写法1：写操作为主的Service
@Service
@Transactional  // 类级别，统一管理
public class OrderService {
    
    public void createOrder(Order order) { }
    public void updateOrder(Order order) { }
    
    @Transactional(readOnly = true)  // 查询方法优化
    public Order getOrder(Long id) { }
}

// ✅ 推荐写法2：读操作为主的Service
@Service
@Transactional(readOnly = true)  // 默认只读
public class ProductService {
    
    public List<Product> listProducts() { }
    
    @Transactional  // 写操作单独配置
    public void updateStock(Long id, int qty) { }
}
```

**❌ 常见错误**

```java
// 错误1：内部调用
@Service
public class UserService {
    public void methodA() {
        this.methodB();  // ❌ 不走代理，事务失效
    }
    
    @Transactional
    public void methodB() { }
}

// 错误2：非public方法
@Service
public class UserService {
    @Transactional
    private void saveUser() { }  // ❌ 事务不生效
}

// 错误3：异常被捕获
@Service
public class UserService {
    @Transactional
    public void createUser(User user) {
        try {
            userDao.save(user);
        } catch (Exception e) {
            // ❌ 异常被吃掉，事务不会回滚
            log.error("error", e);
        }
    }
}
```

### 5.4 学习要点回顾


**核心记忆口诀**：
```
注解加在类或方法，声明事务很简单
方法优先级高于类，覆盖规则要记牢
代理拦截才生效，内部调用会失效
公开方法才能用，私有方法不管用
```

**实战检查清单**：
- [ ] @Transactional加在public方法上了吗？
- [ ] 有内部调用的情况吗？
- [ ] 异常有没有被catch吞掉？
- [ ] 类级别和方法级别的配置冲突了吗？
- [ ] 代理模式配置正确吗？