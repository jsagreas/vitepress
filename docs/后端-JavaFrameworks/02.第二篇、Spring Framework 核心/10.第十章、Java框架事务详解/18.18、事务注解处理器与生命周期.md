---
title: 18、事务注解处理器与生命周期
---
## 📚 目录


1. [事务注解处理核心概念](#1-事务注解处理核心概念)
2. [TransactionAttributeSource详解](#2-TransactionAttributeSource详解)
3. [AnnotationTransactionAttributeSource解析](#3-AnnotationTransactionAttributeSource解析)
4. [事务属性解析流程](#4-事务属性解析流程)
5. [注解处理全流程](#5-注解处理全流程)
6. [事务生命周期管理](#6-事务生命周期管理)
7. [事务状态管理机制](#7-事务状态管理机制)
8. [核心要点总结](#8-核心要点总结)

---

# 1. 🎯 事务注解处理核心概念



## 1.1 什么是事务注解处理器



💡 **通俗理解**：想象你在银行办业务，柜员要先看你的身份证、银行卡等信息，才能决定给你办什么业务、需要什么权限。事务注解处理器就像这个"识别器"，它负责读取方法上的`@Transactional`注解，理解你想要什么样的事务管理。

**🔸 核心作用**
```
业务方法                    事务注解处理器                    实际事务管理
   ↓                            ↓                              ↓
@Transactional     →      读取注解配置信息        →      按配置执行事务控制
(传播行为、隔离级别)        (解析成事务属性对象)           (开启、提交、回滚)
```

**专业定义**：事务注解处理器是Spring事务框架中负责**解析事务注解**并**转换为事务属性对象**的核心组件，它是声明式事务实现的基础。

## 1.2 为什么需要注解处理器



**❓ 问题场景**
```java
// 你写的代码
@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED)
public void transferMoney(Long from, Long to, BigDecimal amount) {
    // 转账逻辑
}
```

**🤔 Spring面临的问题**：
- 怎么知道这个方法需要事务？→ **需要识别注解**
- 怎么知道用什么传播行为？→ **需要解析注解属性**
- 怎么知道用什么隔离级别？→ **需要提取配置信息**

**✅ 解决方案**：事务注解处理器就是专门干这个活的！

## 1.3 处理器的核心任务



| 任务阶段 | 具体工作 | 输入 | 输出 |
|---------|---------|------|------|
| **1️⃣ 注解识别** | 判断方法/类是否有事务注解 | `Method对象` | `true/false` |
| **2️⃣ 属性解析** | 提取注解中的配置信息 | `@Transactional注解` | `TransactionAttribute对象` |
| **3️⃣ 属性缓存** | 缓存解析结果避免重复解析 | `方法签名` | `缓存的事务属性` |
| **4️⃣ 属性应用** | 将属性传递给事务管理器 | `TransactionAttribute` | `事务执行策略` |

---

# 2. 📦 TransactionAttributeSource详解



## 2.1 TransactionAttributeSource是什么



💡 **通俗类比**：就像图书馆的图书管理系统，你输入书名（方法），它告诉你这本书的详细信息（事务属性）—— 在哪个书架（传播行为）、借阅规则是什么（隔离级别）、能借多久（超时时间）。

**🔸 接口定义**
```java
public interface TransactionAttributeSource {
    // 核心方法：根据方法和目标类获取事务属性
    TransactionAttribute getTransactionAttribute(Method method, Class<?> targetClass);
    
    // 判断是否为候选Bean（是否需要事务代理）
    default boolean isCandidateClass(Class<?> targetClass) {
        return true;
    }
}
```

## 2.2 核心功能详解



**功能1：获取事务属性**

```
输入：
- Method: 业务方法对象（如 transferMoney 方法）
- Class: 目标类的Class对象

处理流程：
1. 检查方法上是否有 @Transactional
2. 如果没有，检查类上是否有 @Transactional  
3. 解析注解信息，构建 TransactionAttribute 对象

输出：
- TransactionAttribute：包含所有事务配置
- null：如果该方法不需要事务
```

**功能2：候选类判断**

💡 **作用说明**：不是所有类都需要事务代理，这个方法帮助Spring快速过滤。

```
示例场景：
✅ @Service 类 → 可能需要事务 → isCandidateClass 返回 true
✅ @Repository 类 → 可能需要事务 → isCandidateClass 返回 true
❌ 普通POJO → 不需要事务 → isCandidateClass 返回 false
❌ Spring内部类 → 不需要事务 → isCandidateClass 返回 false
```

## 2.3 实现类体系



```
TransactionAttributeSource (接口)
         ↑
         |
    ┌────┴────┬──────────────┐
    |         |              |
抽象实现    注解实现       自定义实现
    ↓         ↓              ↓
Abstract    Annotation     其他扩展
   TS          TS         实现类
```

**常用实现类对比**

| 实现类 | 作用 | 使用场景 |
|-------|------|---------|
| `AnnotationTransactionAttributeSource` | **注解驱动**事务 | 🔥 最常用，通过`@Transactional`声明 |
| `NameMatchTransactionAttributeSource` | **方法名匹配**事务 | XML配置方式，按方法名规则匹配 |
| `MatchAlwaysTransactionAttributeSource` | **通配符匹配**事务 | 特殊场景，所有方法都应用事务 |

---

# 3. 🔍 AnnotationTransactionAttributeSource解析



## 3.1 核心职责



💡 **通俗理解**：这是专门负责读取`@Transactional`注解的"翻译官"，把注解信息翻译成Spring能理解的事务属性对象。

**🔸 工作原理示意**
```
@Transactional(propagation = REQUIRED, timeout = 30)
                    ↓ 解析
              AnnotationTransactionAttributeSource
                    ↓ 翻译
         RuleBasedTransactionAttribute 对象
                    ↓
         {
           传播行为: REQUIRED,
           隔离级别: DEFAULT,
           超时时间: 30秒,
           只读: false,
           回滚规则: [RuntimeException, Error]
         }
```

## 3.2 关键组件



**组件1：注解解析器集合**

```java
// 内部维护一个解析器集合
private final Set<TransactionAnnotationParser> annotationParsers;

// 默认支持三种注解解析器
annotationParsers = {
    SpringTransactionAnnotationParser,    // Spring 的 @Transactional
    JtaTransactionAnnotationParser,       // JTA 的 @Transactional
    Ejb3TransactionAnnotationParser       // EJB3 的事务注解
}
```

💡 **为什么有多个解析器**：支持不同的事务注解标准，保证兼容性。就像手机支持多种充电接口一样。

**组件2：属性缓存机制**

```
缓存结构：
Map<CacheKey, TransactionAttribute>
    ↓
{
  "UserService.transferMoney(Long,Long,BigDecimal)": TransactionAttribute实例,
  "OrderService.createOrder(OrderDTO)": TransactionAttribute实例,
  ...
}

缓存优势：
✅ 避免重复解析注解
✅ 提升方法调用性能
✅ 减少反射操作开销
```

## 3.3 解析优先级规则



📋 **注解查找顺序**（从上到下，找到即停止）

```
1️⃣ 方法上的注解        ← 优先级最高
   ↓ (如果没找到)
2️⃣ 方法所在类上的注解   ← 次优先级
   ↓ (如果没找到)
3️⃣ 接口方法上的注解     ← 再次之
   ↓ (如果没找到)
4️⃣ 接口上的注解         ← 优先级最低
```

**实际案例**

```java
// 接口定义
@Transactional(readOnly = true)  // ← 4️⃣ 最低优先级
public interface UserService {
    
    @Transactional(propagation = REQUIRED)  // ← 3️⃣ 接口方法级别
    void updateUser(User user);
}

// 实现类
@Transactional(timeout = 60)  // ← 2️⃣ 类级别
public class UserServiceImpl implements UserService {
    
    @Transactional(isolation = SERIALIZABLE)  // ← 1️⃣ 最高优先级（实际生效）
    public void updateUser(User user) {
        // 实际使用的事务配置：
        // isolation = SERIALIZABLE (来自方法注解)
        // propagation = REQUIRED (继承默认)
        // timeout = 60 (从类注解继承)
    }
}
```

⚠️ **注意事项**：
- 方法注解会**完全覆盖**类注解（不是合并）
- 建议在实现类上加注解，不要在接口上加（更清晰）

---

# 4. 🔄 事务属性解析流程



## 4.1 完整解析流程图



```
业务方法调用
    ↓
AOP拦截器启动
    ↓
① 调用 getTransactionAttribute(method, targetClass)
    ↓
② 构建缓存Key (类名+方法签名)
    ↓
③ 检查缓存
    ├─→ 命中缓存 → 直接返回
    └─→ 未命中 ↓
           ④ 遍历注解解析器集合
               ↓
           ⑤ 解析注解信息
               ├─ 读取传播行为
               ├─ 读取隔离级别
               ├─ 读取超时设置
               ├─ 读取只读标志
               └─ 读取回滚规则
               ↓
           ⑥ 构建 TransactionAttribute 对象
               ↓
           ⑦ 存入缓存
               ↓
           ⑧ 返回事务属性对象
```

## 4.2 解析步骤详解



**步骤1：缓存Key构建**

```
缓存Key组成：
- 目标类的全限定名
- 方法名称
- 参数类型列表

示例：
com.example.UserServiceImpl.transferMoney(Long,Long,BigDecimal)
```

💡 **为什么要缓存**：一个方法可能被调用成千上万次，每次都解析注解太浪费性能。

**步骤2：注解信息提取**

```java
// 伪代码展示解析过程
TransactionAttribute parseAnnotation(@Transactional annotation) {
    
    RuleBasedTransactionAttribute attr = new RuleBasedTransactionAttribute();
    
    // 提取传播行为
    attr.setPropagationBehavior(annotation.propagation().value());
    
    // 提取隔离级别
    attr.setIsolationLevel(annotation.isolation().value());
    
    // 提取超时时间
    if (annotation.timeout() != -1) {
        attr.setTimeout(annotation.timeout());
    }
    
    // 提取只读标志
    attr.setReadOnly(annotation.readOnly());
    
    // 提取回滚规则
    List<RollbackRuleAttribute> rollbackRules = new ArrayList<>();
    // 处理 rollbackFor
    for (Class<?> rbRule : annotation.rollbackFor()) {
        rollbackRules.add(new RollbackRuleAttribute(rbRule));
    }
    // 处理 noRollbackFor
    for (Class<?> nrbRule : annotation.noRollbackFor()) {
        rollbackRules.add(new NoRollbackRuleAttribute(nrbRule));
    }
    attr.setRollbackRules(rollbackRules);
    
    return attr;
}
```

## 4.3 TransactionAttribute对象结构



**🔸 核心属性清单**

| 属性名 | 类型 | 默认值 | 说明 |
|-------|------|--------|------|
| `propagationBehavior` | `int` | `REQUIRED` | 事务传播行为 |
| `isolationLevel` | `int` | `DEFAULT` | 事务隔离级别 |
| `timeout` | `int` | `-1`（无限制） | 事务超时时间（秒） |
| `readOnly` | `boolean` | `false` | 是否只读事务 |
| `rollbackRules` | `List` | `[RuntimeException, Error]` | 回滚规则列表 |
| `qualifier` | `String` | `""` | 事务管理器限定符 |

**示例对象内容**

```
TransactionAttribute 实例：
{
    "propagationBehavior": 0,          // REQUIRED
    "isolationLevel": 2,               // READ_COMMITTED
    "timeout": 30,                     // 30秒超时
    "readOnly": false,                 // 非只读
    "rollbackRules": [
        { "exceptionType": "SQLException" },
        { "exceptionType": "IOException", "rollbackOn": false }
    ],
    "qualifier": "primaryTransactionManager"
}
```

---

# 5. ⚙️ 注解处理全流程



## 5.1 从注解到事务执行的完整链路



```
开发阶段                    启动阶段                    运行阶段
    ↓                          ↓                          ↓
1️⃣ 编写业务代码        →   2️⃣ Spring容器启动     →   3️⃣ 方法被调用
@Transactional注解           扫描Bean                   AOP拦截
    ↓                          ↓                          ↓
                        创建代理对象                获取事务属性
                        注册拦截器链                开启事务
                              ↓                          ↓
                        初始化注解处理器            执行业务逻辑
                              ↓                          ↓
                        缓存事务属性                提交/回滚事务
```

## 5.2 启动阶段：代理对象创建



**🔸 Bean初始化过程**

```
普通Bean
   ↓
BeanPostProcessor 处理
   ↓
检测 @Transactional 注解
   ↓
创建 TransactionInterceptor 拦截器
   ↓
创建代理对象（JDK动态代理 或 CGLIB代理）
   ↓
代理对象注册到容器
```

💡 **关键点**：代理对象在启动时就创建好了，不是运行时创建。

**代理对象结构示意**

```
UserServiceProxy（代理对象）
    |
    ├─ target: UserServiceImpl（真实对象）
    |
    └─ interceptors: [
         TransactionInterceptor（事务拦截器）
            ├─ transactionAttributeSource（注解处理器）
            └─ transactionManager（事务管理器）
       ]
```

## 5.3 运行阶段：拦截器执行



**🔸 方法调用拦截流程**

```
用户调用: userService.transferMoney(1L, 2L, 100)
              ↓
进入代理对象的 transferMoney 方法
              ↓
TransactionInterceptor.invoke() 被调用
              ↓
步骤1: 获取事务属性
    transactionAttribute = attributeSource.getTransactionAttribute(method, targetClass)
              ↓
步骤2: 确定事务管理器
    txManager = determineTransactionManager(transactionAttribute)
              ↓
步骤3: 创建事务信息对象
    txInfo = createTransactionIfNecessary(txManager, transactionAttribute, joinpointIdentification)
              ↓
步骤4: 执行目标方法
    retVal = invocation.proceed()
              ↓
步骤5: 处理返回结果
    commitTransactionAfterReturning(txInfo)
              ↓
步骤6: 清理事务上下文
    cleanupTransactionInfo(txInfo)
```

## 5.4 关键对象协作



**🔸 核心对象关系图**

```
TransactionInterceptor（事务拦截器）
        |
        ├─── uses ───→ TransactionAttributeSource（注解处理器）
        |                      |
        |                      └─ 解析注解，返回事务属性
        |
        ├─── uses ───→ PlatformTransactionManager（事务管理器）
        |                      |
        |                      └─ 实际执行事务操作
        |
        └─── creates ─→ TransactionInfo（事务信息对象）
                               |
                               └─ 保存当前事务状态
```

---

# 6. 🔄 事务生命周期管理



## 6.1 事务生命周期完整阶段



💡 **通俗理解**：事务就像一次旅行，有启程（开启）、旅途（执行）、返程（提交）和意外处理（回滚）。

**📋 生命周期阶段图**

```
1️⃣ 准备阶段
   ├─ 获取事务属性
   ├─ 获取事务管理器
   └─ 检查是否需要新事务
       ↓
2️⃣ 开启阶段
   ├─ 开启数据库连接
   ├─ 设置隔离级别
   ├─ 关闭自动提交
   └─ 绑定连接到线程
       ↓
3️⃣ 执行阶段
   ├─ 执行业务逻辑
   └─ 可能触发嵌套事务
       ↓
4️⃣ 完成阶段
   ├─ 正常完成 → 提交事务
   └─ 异常发生 → 回滚事务
       ↓
5️⃣ 清理阶段
   ├─ 解绑线程资源
   ├─ 释放数据库连接
   └─ 恢复事务上下文
```

## 6.2 阶段详细说明



### 阶段1：准备阶段



**核心任务**：判断是否需要开启新事务

```
决策流程：
当前有事务吗？
├─ 有 → 根据传播行为决定
│       ├─ REQUIRED → 加入当前事务
│       ├─ REQUIRES_NEW → 挂起当前事务，开启新事务
│       ├─ NESTED → 创建嵌套事务（保存点）
│       └─ ...
│
└─ 无 → 根据传播行为决定
        ├─ REQUIRED → 开启新事务
        ├─ SUPPORTS → 以非事务方式执行
        ├─ MANDATORY → 抛出异常（要求必须有事务）
        └─ ...
```

### 阶段2：开启阶段



**关键操作步骤**

```java
// 伪代码展示事务开启过程
void beginTransaction(TransactionAttribute attr) {
    
    // 1. 获取数据库连接
    Connection conn = dataSource.getConnection();
    
    // 2. 关闭自动提交（重要！）
    conn.setAutoCommit(false);
    
    // 3. 设置隔离级别（如果指定）
    if (attr.getIsolationLevel() != DEFAULT) {
        conn.setTransactionIsolation(attr.getIsolationLevel());
    }
    
    // 4. 设置只读标志（优化）
    if (attr.isReadOnly()) {
        conn.setReadOnly(true);
    }
    
    // 5. 绑定连接到当前线程（重要！）
    TransactionSynchronizationManager.bindResource(dataSource, conn);
    
    // 6. 设置超时时间（如果指定）
    if (attr.getTimeout() != -1) {
        // 注册超时检测任务
        registerTimeoutTask(attr.getTimeout());
    }
}
```

⚠️ **关键点说明**：
- `setAutoCommit(false)` 是事务的基础，没有这个就没有事务
- 连接绑定到线程，同一线程内的多个DAO都用同一个连接

### 阶段3：执行阶段



**业务逻辑执行**

```
try {
    // 执行业务方法
    Object result = method.invoke(target, args);
    
    // 可能的嵌套调用
    if (hasNestedTransactionalMethod) {
        // 处理嵌套事务
        handleNestedTransaction();
    }
    
    return result;
    
} catch (Exception e) {
    // 进入异常处理流程
    handleException(e);
}
```

### 阶段4：完成阶段



**提交 vs 回滚决策**

```
方法执行完成
    ↓
检查是否有异常
    ├─ 无异常
    │    ↓
    │  检查回滚规则
    │    ├─ 默认：提交事务
    │    └─ 特殊标记：回滚事务
    │
    └─ 有异常
         ↓
       检查异常类型
         ├─ RuntimeException → 默认回滚
         ├─ Error → 默认回滚
         ├─ Checked Exception → 默认提交
         └─ 自定义规则 → 按规则处理
```

**提交操作**

```java
void commit(Connection conn) {
    try {
        conn.commit();  // 提交事务
        logger.debug("Transaction committed successfully");
    } catch (SQLException e) {
        rollback(conn);  // 提交失败，回滚
        throw e;
    }
}
```

**回滚操作**

```java
void rollback(Connection conn) {
    try {
        conn.rollback();  // 回滚事务
        logger.debug("Transaction rolled back");
    } catch (SQLException e) {
        logger.error("Failed to rollback transaction", e);
    }
}
```

### 阶段5：清理阶段



**资源释放清单**

```
清理步骤：
1️⃣ 解绑线程资源
   TransactionSynchronizationManager.unbindResource(dataSource)
   
2️⃣ 恢复连接状态
   conn.setAutoCommit(true)  // 恢复自动提交
   
3️⃣ 归还连接到连接池
   conn.close()  // 实际是归还给连接池
   
4️⃣ 清除事务同步
   TransactionSynchronizationManager.clear()
   
5️⃣ 恢复挂起的事务（如果有）
   resume(suspendedTransaction)
```

## 6.3 生命周期中的线程绑定



💡 **核心机制**：Spring使用 `ThreadLocal` 实现事务的线程绑定

**🔸 ThreadLocal存储内容**

```
TransactionSynchronizationManager (ThreadLocal容器)
    |
    ├─ resources: Map<DataSource, Connection>
    |    └─ 存储当前线程的数据库连接
    |
    ├─ synchronizations: Set<TransactionSynchronization>
    |    └─ 存储事务同步回调
    |
    ├─ currentTransactionName: String
    |    └─ 当前事务名称
    |
    ├─ currentTransactionReadOnly: Boolean
    |    └─ 当前事务是否只读
    |
    ├─ currentTransactionIsolationLevel: Integer
    |    └─ 当前事务隔离级别
    |
    └─ actualTransactionActive: Boolean
         └─ 是否有实际的事务激活
```

**工作原理示意**

```
线程A                          线程B
  |                              |
开启事务A                      开启事务B
  |                              |
绑定连接1到ThreadLocal          绑定连接2到ThreadLocal
  |                              |
执行DAO操作                     执行DAO操作
  |                              |
获取连接1（从ThreadLocal）      获取连接2（从ThreadLocal）
  |                              |
提交事务A                       提交事务B
  |                              |
清除ThreadLocal                 清除ThreadLocal
```

✅ **优势**：不同线程互不干扰，自动隔离

---

# 7. 📊 事务状态管理机制



## 7.1 事务状态对象



💡 **通俗理解**：就像旅行时的行李标签，记录了这趟旅程（事务）的所有重要信息。

**🔸 TransactionStatus核心属性**

```java
public interface TransactionStatus {
    
    // 是否是新事务（重要！）
    boolean isNewTransaction();
    
    // 是否有保存点（嵌套事务使用）
    boolean hasSavepoint();
    
    // 设置仅回滚标记
    void setRollbackOnly();
    
    // 是否已标记为仅回滚
    boolean isRollbackOnly();
    
    // 是否已完成（提交或回滚）
    boolean isCompleted();
}
```

**实际存储内容示例**

```
TransactionStatus 实例：
{
    "newTransaction": true,           // 是新开启的事务
    "hasSavepoint": false,            // 没有保存点
    "rollbackOnly": false,            // 未标记为仅回滚
    "completed": false,               // 尚未完成
    "transaction": {                  // 底层事务对象
        "connection": Connection实例,
        "previousIsolationLevel": 2,  // 之前的隔离级别
        "savepointManager": null
    },
    "suspendedResources": null        // 被挂起的资源（如果有）
}
```

## 7.2 事务状态转换



**🔸 状态机模型**

```
                   开始
                    ↓
            ┌─────────────┐
            │   PREPARED   │ ← 准备阶段
            │  (准备就绪)   │
            └─────────────┘
                    ↓
            ┌─────────────┐
            │    ACTIVE    │ ← 活跃阶段
            │  (事务进行中)  │
            └─────────────┘
                    ↓
              ┌─────┴─────┐
              ↓           ↓
      ┌─────────────┐ ┌─────────────┐
      │  COMMITTED   │ │ ROLLED_BACK │ ← 完成阶段
      │   (已提交)    │ │  (已回滚)    │
      └─────────────┘ └─────────────┘
              ↓           ↓
            ┌─────────────┐
            │  COMPLETED   │ ← 清理阶段
            │   (已完成)    │
            └─────────────┘
```

## 7.3 嵌套事务的状态管理



**🔸 保存点机制**

💡 **通俗理解**：就像玩游戏时的存档点，可以回退到这个点，而不是从头开始。

```
主事务开始
    ↓
执行操作A（成功）
    ↓
创建保存点1 ← 嵌套事务开始
    ↓
执行操作B（成功）
    ↓
创建保存点2 ← 再次嵌套
    ↓
执行操作C（失败！）
    ↓
回滚到保存点2 ← 只回滚操作C
    ↓
继续执行
    ↓
释放保存点1
    ↓
主事务提交
```

**代码示例**

```java
@Transactional
public void outerMethod() {
    // 主事务开始
    operationA();  // 成功
    
    // 嵌套事务
    try {
        innerMethod();  // 可能失败
    } catch (Exception e) {
        // 嵌套事务失败，但不影响主事务
        logger.error("Inner transaction failed", e);
    }
    
    operationB();  // 继续执行
    // 主事务提交
}

@Transactional(propagation = Propagation.NESTED)
public void innerMethod() {
    // 创建保存点
    operationC();  // 如果这里失败，只回滚到保存点
}
```

## 7.4 状态传播与隔离



**🔸 父子事务的状态关系**

| 传播行为 | 子方法状态 | 父方法状态 | 相互影响 |
|---------|----------|----------|---------|
| **REQUIRED** | 共享 | 共享 | 任一回滚，全部回滚 |
| **REQUIRES_NEW** | 独立 | 独立 | 互不影响 |
| **NESTED** | 依赖父 | 独立 | 子回滚不影响父，父回滚影响子 |
| **SUPPORTS** | 可选 | 不变 | 跟随父事务 |

**实际场景对比**

```
场景1: REQUIRED（共享状态）
主事务 ─┬─ 子方法调用
        │    ↓
        └─ 共享同一个TransactionStatus
           任一设置rollbackOnly，整体回滚

场景2: REQUIRES_NEW（独立状态）  
主事务 ──→ 挂起
             ↓
        新事务开启（独立TransactionStatus）
             ↓
        新事务提交/回滚
             ↓
        主事务恢复
        
场景3: NESTED（嵌套状态）
主事务 ─┬─ 创建保存点
        │    ↓
        └─ 子事务（SavepointStatus）
           子失败 → 回滚到保存点
           子成功 → 释放保存点
```

---

# 8. 📋 核心要点总结



## 8.1 必须掌握的核心概念



**🔸 三大核心组件**
```
1️⃣ TransactionAttributeSource
   → 负责解析注解，获取事务属性
   
2️⃣ TransactionAttribute  
   → 存储事务配置信息（传播行为、隔离级别等）
   
3️⃣ TransactionStatus
   → 记录事务执行状态（是否新事务、是否完成等）
```

## 8.2 关键流程记忆



**🔸 注解处理流程**
```
注解编写 → 容器启动扫描 → 创建代理对象 → 运行时拦截 → 解析注解 → 开启事务 → 执行业务 → 提交/回滚 → 清理资源
```

**🔸 优先级规则**
```
方法注解 > 类注解 > 接口方法注解 > 接口注解
```

## 8.3 事务生命周期记忆口诀



```
准备阶段：获属性，定管理器
开启阶段：拿连接，绑线程
执行阶段：跑业务，可嵌套  
完成阶段：提交滚，看异常
清理阶段：解绑源，还连接
```

## 8.4 实战要点



**✅ 最佳实践**
- 在实现类上加注解，不要在接口上
- 方法注解优先于类注解，配置更精确
- 注意异常类型，Checked异常默认不回滚
- 合理使用传播行为，避免事务嵌套问题

**❌ 常见错误**
- 内部方法调用事务失效（绕过代理）
- 异常被捕获导致事务不回滚
- 多线程环境下事务失效（ThreadLocal机制）
- 事务方法不能是private（代理无法拦截）

## 8.5 核心记忆图



```
        @Transactional注解
              ↓
   AnnotationTransactionAttributeSource
              ↓ (解析)
      TransactionAttribute对象
              ↓ (驱动)
      TransactionInterceptor拦截器
              ↓ (执行)
      TransactionStatus状态管理
              ↓ (控制)
         事务生命周期
    (准备→开启→执行→完成→清理)
```

---

**🎯 学习建议**
1. 先理解概念，再看源码
2. 结合实际业务场景理解传播行为
3. 动手写Demo验证事务行为
4. 关注日志输出，观察事务执行过程