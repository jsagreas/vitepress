---
title: 10、SpEL高级特性
---
## 📚 目录

1. [自定义函数注册](#1-自定义函数注册)
2. [方法引用详解](#2-方法引用详解)
3. [模板表达式](#3-模板表达式)
4. [占位符解析机制](#4-占位符解析机制)
5. [字符串模板应用](#5-字符串模板应用)
6. [复合表达式技巧](#6-复合表达式技巧)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔧 自定义函数注册


### 1.1 什么是自定义函数


**通俗理解**：就像你可以在Excel里自定义函数一样，SpEL也允许你注册自己的函数，在表达式中直接调用。

```
好比：
数学公式中：y = f(x)  ← f是函数
SpEL表达式中：#myFunc(value)  ← myFunc是你自定义的函数

作用：把复杂的Java逻辑包装成简单的函数，在表达式中重复使用
```

### 1.2 为什么需要自定义函数


**实际场景**：
- 📋 **复杂计算**：比如计算税费、折扣价格
- 🔄 **数据转换**：日期格式化、字符串处理
- ✅ **业务规则**：会员等级判断、权限验证

```java
// 场景1：价格计算
// 不用自定义函数（表达式很长）
price * 0.9 - (price * 0.9 > 100 ? 10 : 0)

// 用自定义函数（简洁明了）
#calcFinalPrice(price)
```

### 1.3 如何注册自定义函数


**核心步骤**：
1. 创建Java方法（必须是static静态方法）
2. 通过SpEL上下文注册这个方法
3. 在表达式中使用 `#函数名()` 调用

```java
// 步骤1：创建工具类和静态方法
public class PriceUtils {
    // 计算最终价格：打9折，满100再减10
    public static double calcFinalPrice(double price) {
        double discount = price * 0.9;
        return discount > 100 ? discount - 10 : discount;
    }
}

// 步骤2：注册函数到SpEL上下文
ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();

// 注册方法：参数1是函数名，参数2是Java方法对象
Method method = PriceUtils.class.getMethod("calcFinalPrice", double.class);
context.registerFunction("calcPrice", method);

// 步骤3：在表达式中使用
Expression exp = parser.parseExpression("#calcPrice(150)");
Double result = exp.getValue(context, Double.class);
System.out.println(result); // 输出：125.0
```

### 1.4 实用示例


**场景：会员等级判断**

```java
public class MemberUtils {
    // 根据积分判断会员等级
    public static String getLevel(int points) {
        if (points >= 10000) return "钻石会员";
        if (points >= 5000) return "黄金会员";
        if (points >= 1000) return "白银会员";
        return "普通会员";
    }
}

// 使用示例
context.registerFunction("memberLevel", 
    MemberUtils.class.getMethod("getLevel", int.class));

// 表达式中使用
String level = parser.parseExpression("#memberLevel(8000)")
                     .getValue(context, String.class);
// 结果："黄金会员"
```

**要点说明**：
- ⚠️ **必须是静态方法**：`public static`
- 📝 **函数名自定义**：注册时可以起别名
- 🔄 **支持任意参数**：可以传入多个参数

---

## 2. 🎯 方法引用详解


### 2.1 方法引用是什么


**简单理解**：直接在SpEL表达式里调用对象的方法，就像在Java代码里调用一样。

```
Java代码：        user.getName()
SpEL表达式：      #user.getName()

区别：SpEL需要用#开头引用变量
```

### 2.2 方法引用的三种形式


**形式1：对象实例方法**

```java
// 假设有User对象
public class User {
    private String name;
    private int age;
    
    public String getName() { return name; }
    public boolean isAdult() { return age >= 18; }
}

// SpEL使用
User user = new User("张三", 20);
context.setVariable("user", user);

// 调用方法
String name = parser.parseExpression("#user.getName()")
                    .getValue(context, String.class);
// 结果："张三"

Boolean adult = parser.parseExpression("#user.isAdult()")
                      .getValue(context, Boolean.class);
// 结果：true
```

**形式2：静态方法引用**

```java
// 引用Java内置的静态方法
Expression exp = parser.parseExpression(
    "T(java.lang.Math).random() * 100"
);
Double random = exp.getValue(Double.class);
// 结果：0-100之间的随机数

// 引用自定义静态方法
Expression exp2 = parser.parseExpression(
    "T(com.example.Utils).formatDate(#date)"
);
```

**形式3：链式调用**

```java
// 连续调用多个方法
Expression exp = parser.parseExpression(
    "#user.getName().toUpperCase()"
);
String upperName = exp.getValue(context, String.class);
// "张三" → "张三"（中文无大小写变化）

// 实际例子
Expression exp2 = parser.parseExpression(
    "#user.getName().length() > 3"
);
// 判断姓名长度是否超过3个字符
```

### 2.3 方法引用的安全访问


**安全导航操作符 `?.`**：当对象可能为null时使用

```java
// 普通调用：如果user为null会报错
#user.getName()  ❌ NullPointerException

// 安全调用：如果user为null返回null，不报错
#user?.getName() ✅ 返回null

// 实际应用
Expression exp = parser.parseExpression(
    "#user?.getName()?.toUpperCase()"
);
// 只有user和getName()都不为null才执行toUpperCase()
```

**使用场景对比**：

| 场景 | 使用方式 | 说明 |
|------|---------|------|
| **对象一定存在** | `#user.getName()` | 直接调用，性能好 |
| **对象可能为null** | `#user?.getName()` | 安全调用，避免异常 |
| **链式调用** | `#user?.getAddress()?.getCity()` | 任何一环为null都返回null |

---

## 3. 📝 模板表达式


### 3.1 什么是模板表达式


**通俗解释**：就像填空题一样，在固定的文本中嵌入动态的表达式值。

```
模板：      "您好，#{#name}，您的订单金额是#{#amount}元"
变量值：    name="张三", amount=99.5
结果：      "您好，张三，您的订单金额是99.5元"

语法：用 #{表达式} 标记动态部分
```

### 3.2 模板表达式的语法


**基本语法**：

```java
// 模板格式：普通文本 + #{表达式}
ParserContext template = new TemplateParserContext();
ExpressionParser parser = new SpelExpressionParser();

// 定义变量
context.setVariable("name", "李四");
context.setVariable("score", 95);

// 解析模板
Expression exp = parser.parseExpression(
    "学生#{#name}的成绩是#{#score}分",
    template  // 注意：需要传入ParserContext
);

String result = exp.getValue(context, String.class);
// 结果："学生李四的成绩是95分"
```

### 3.3 模板中的复杂表达式


**可以在模板中使用任何SpEL表达式**：

```java
// 模板中使用运算
Expression exp = parser.parseExpression(
    "#{#name}同学，您的总分是#{#math + #english}分",
    template
);

// 模板中使用三元运算
Expression exp2 = parser.parseExpression(
    "#{#score >= 60 ? '及格' : '不及格'}",
    template
);

// 模板中调用方法
Expression exp3 = parser.parseExpression(
    "当前时间：#{T(java.time.LocalDateTime).now()}",
    template
);
```

### 3.4 实际应用场景


**场景1：订单通知消息**

```java
context.setVariable("userName", "王五");
context.setVariable("orderId", "20240115001");
context.setVariable("amount", 299.00);

String template = "尊敬的#{#userName}，" +
                 "您的订单#{#orderId}已支付成功，" +
                 "支付金额#{#amount}元";

Expression exp = parser.parseExpression(template, 
                                        new TemplateParserContext());
String message = exp.getValue(context, String.class);
```

**场景2：动态SQL构建**

```java
context.setVariable("tableName", "users");
context.setVariable("condition", "age > 18");

String sqlTemplate = "SELECT * FROM #{#tableName} WHERE #{#condition}";
Expression exp = parser.parseExpression(sqlTemplate, 
                                        new TemplateParserContext());
String sql = exp.getValue(context, String.class);
// 结果："SELECT * FROM users WHERE age > 18"
```

---

## 4. 🔑 占位符解析机制


### 4.1 占位符vs模板表达式


**核心区别**：

```
占位符：     ${property.name}     ← 只能取值，不能计算
模板表达式：  #{#value * 2}       ← 可以计算和处理

占位符用途：  配置文件取值
模板表达式：  动态计算和拼接
```

### 4.2 占位符的工作原理


**基本概念**：
- 占位符就是从配置源（如properties文件）中取值
- 格式：`${key}` 或 `${key:defaultValue}`
- 由Spring的PropertyPlaceholderConfigurer处理

```java
// application.properties文件
app.name=我的应用
app.version=1.0.0
server.port=8080

// Spring配置中使用
@Value("${app.name}")
private String appName;  // 值："我的应用"

@Value("${app.timeout:30}")  
private int timeout;  // 如果app.timeout不存在，默认30
```

### 4.3 SpEL中使用占位符


**混合使用占位符和SpEL**：

```java
// 先解析占位符${...}，再计算SpEL表达式#{...}
@Value("#{${server.port} + 1000}")
private int adminPort;
// 如果server.port=8080，结果：9080

@Value("#{T(java.lang.Integer).parseInt('${app.max.users}')}")
private int maxUsers;
// 将配置值转换为整数
```

### 4.4 占位符的默认值机制


**语法**：`${key:defaultValue}`

```java
// 基本默认值
@Value("${db.timeout:30}")
private int timeout;  // db.timeout不存在时用30

// 空字符串作为默认值
@Value("${app.desc:}")
private String description;  // 不存在时为空字符串

// 复杂默认值
@Value("${app.level:INFO}")
private String logLevel;  // 默认日志级别INFO
```

**要点总结**：

| 特性 | 占位符 `${...}` | 模板表达式 `#{...}` |
|------|----------------|-------------------|
| **用途** | 读取配置值 | 动态计算 |
| **语法** | `${key:default}` | `#{表达式}` |
| **能力** | 只能取值 | 可以运算、调用方法 |
| **常见场景** | 配置参数 | 动态逻辑 |

---

## 5. 📄 字符串模板应用


### 5.1 字符串模板是什么


**本质理解**：字符串模板是模板表达式在文本处理中的具体应用。

```
普通字符串：  "Hello, World"           ← 固定文本
字符串模板：  "Hello, #{#userName}"   ← 动态文本

作用：      根据变量动态生成文本内容
```

### 5.2 字符串模板的实现方式


**方式1：使用TemplateParserContext**

```java
// 创建模板解析器
ParserContext templateContext = new TemplateParserContext();
ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();

// 设置变量
context.setVariable("user", "小明");
context.setVariable("score", 88);

// 解析模板
Expression exp = parser.parseExpression(
    "#{#user}同学考了#{#score}分，#{#score >= 60 ? '及格了' : '未及格'}！",
    templateContext
);

String result = exp.getValue(context, String.class);
// 结果："小明同学考了88分，及格了！"
```

**方式2：自定义模板占位符**

```java
// 自定义#{...}为{{...}}
public class CustomTemplateContext implements ParserContext {
    @Override
    public boolean isTemplate() { return true; }
    
    @Override
    public String getExpressionPrefix() { return "{{"; }
    
    @Override
    public String getExpressionSuffix() { return "}}"; }
}

// 使用自定义模板
Expression exp = parser.parseExpression(
    "{{#name}}的年龄是{{#age}}岁",
    new CustomTemplateContext()
);
```

### 5.3 实际应用案例


**案例1：邮件内容生成**

```java
public class EmailTemplate {
    public static String generateEmail(String userName, String orderId, 
                                      double amount) {
        ParserContext template = new TemplateParserContext();
        ExpressionParser parser = new SpelExpressionParser();
        StandardEvaluationContext context = new StandardEvaluationContext();
        
        context.setVariable("user", userName);
        context.setVariable("order", orderId);
        context.setVariable("money", amount);
        
        String emailTemplate = """
            尊敬的#{#user}：
            
            您的订单#{#order}已确认，订单金额#{#money}元。
            #{#money >= 100 ? '您已享受包邮服务' : '运费10元'}。
            
            感谢您的购买！
            """;
        
        Expression exp = parser.parseExpression(emailTemplate, template);
        return exp.getValue(context, String.class);
    }
}

// 使用
String email = EmailTemplate.generateEmail("张三", "ORD123", 150.0);
```

**案例2：动态生成配置文件**

```java
// 根据环境生成不同的配置
context.setVariable("env", "production");
context.setVariable("dbHost", "192.168.1.100");
context.setVariable("dbPort", 3306);

String configTemplate = """
    # #{#env}环境配置
    database.url=jdbc:mysql://#{#dbHost}:#{#dbPort}/mydb
    database.pool.size=#{#env == 'production' ? 50 : 10}
    cache.enabled=#{#env == 'production' ? 'true' : 'false'}
    """;

Expression exp = parser.parseExpression(configTemplate, 
                                        new TemplateParserContext());
String config = exp.getValue(context, String.class);
```

### 5.4 字符串模板的高级技巧


**技巧1：嵌套表达式**

```java
// 表达式中调用表达式
context.setVariable("list", Arrays.asList(1, 2, 3));

String template = "列表长度：#{#list.size()}，" +
                 "总和：#{#list.?[true].![#this].sum()}";
```

**技巧2：条件模板**

```java
// 根据条件显示不同内容
String template = "#{#vip ? '尊贵的VIP客户' : '普通客户'}，" +
                 "您好！#{#vip ? '专属客服为您服务' : ''}";
```

---

## 6. 🔗 复合表达式技巧


### 6.1 什么是复合表达式


**通俗理解**：把多个简单表达式组合在一起，形成更强大的表达式。

```
简单表达式：  #price > 100
             #vip == true

复合表达式：  #price > 100 && #vip == true
             (#price > 100 ? #price * 0.9 : #price) - #coupon
```

### 6.2 逻辑复合


**AND运算（&&）**：

```java
// 同时满足多个条件
Expression exp = parser.parseExpression(
    "#age >= 18 && #score >= 60"
);

context.setVariable("age", 20);
context.setVariable("score", 75);
Boolean result = exp.getValue(context, Boolean.class);
// 结果：true（年龄达标且成绩及格）
```

**OR运算（||）**：

```java
// 满足任意条件
Expression exp = parser.parseExpression(
    "#isVip || #amount > 1000"
);
// VIP客户或订单金额超1000都可以享受优惠
```

**NOT运算（!）**：

```java
// 条件取反
Expression exp = parser.parseExpression(
    "!#isBanned && #age >= 18"
);
// 未被禁止且成年
```

### 6.3 计算复合


**四则运算组合**：

```java
// 复杂价格计算
Expression exp = parser.parseExpression(
    "(#price * #quantity - #coupon) * #discount"
);

context.setVariable("price", 100.0);      // 单价
context.setVariable("quantity", 3);        // 数量
context.setVariable("coupon", 50.0);      // 优惠券
context.setVariable("discount", 0.9);     // 折扣

Double total = exp.getValue(context, Double.class);
// 计算：(100*3 - 50) * 0.9 = 225
```

**三元运算符嵌套**：

```java
// 多级判断
Expression exp = parser.parseExpression(
    "#score >= 90 ? '优秀' : " +
    "#score >= 80 ? '良好' : " +
    "#score >= 60 ? '及格' : '不及格'"
);
```

### 6.4 集合复合


**过滤 + 投影 + 聚合**：

```java
// 假设有订单列表
List<Order> orders = Arrays.asList(
    new Order(100, "已完成"),
    new Order(200, "已完成"),
    new Order(150, "待支付")
);

context.setVariable("orders", orders);

// 复合操作：筛选已完成订单 → 取金额 → 求和
Expression exp = parser.parseExpression(
    "#orders.?[status=='已完成'].![amount].sum()"
);

Double totalAmount = exp.getValue(context, Double.class);
// 结果：300（100+200）
```

**解释说明**：
- `?[...]` ：过滤集合（选择符合条件的元素）
- `![...]` ：投影集合（提取指定属性）
- `.sum()` ：求和聚合

### 6.5 方法链复合


**连续调用多个方法**：

```java
// 字符串处理链
Expression exp = parser.parseExpression(
    "#text.trim().toUpperCase().substring(0, 5)"
);

context.setVariable("text", "  hello world  ");
String result = exp.getValue(context, String.class);
// 结果："HELLO"（去空格→大写→截取前5个字符）
```

**安全链式调用**：

```java
// 使用?.避免NullPointerException
Expression exp = parser.parseExpression(
    "#user?.getAddress()?.getCity()?.getName()"
);
// 任何一环为null都返回null，不报错
```

### 6.6 复合表达式最佳实践


**实践1：可读性优先**

```java
// ❌ 不推荐：过于复杂
"#list.?[#this > 10].![#this * 2].sum() / #list.size()"

// ✅ 推荐：拆分为多个表达式
Expression filterExp = parser.parseExpression("#list.?[#this > 10]");
Expression mapExp = parser.parseExpression("#filtered.![#this * 2]");
Expression avgExp = parser.parseExpression("#mapped.sum() / #filtered.size()");
```

**实践2：合理使用括号**

```java
// 明确运算优先级
Expression exp = parser.parseExpression(
    "(#basePrice + #tax) * #discount - #coupon"
);
// 括号让计算逻辑更清晰
```

**实践3：提取公共子表达式**

```java
// 重复计算
"#price * 0.9 > 100 ? #price * 0.9 - 10 : #price * 0.9"

// 优化：用变量存储中间结果
context.setVariable("discountPrice", price * 0.9);
"#discountPrice > 100 ? #discountPrice - 10 : #discountPrice"
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 自定义函数：注册静态方法到SpEL，表达式中#函数名()调用
🔸 方法引用：对象实例方法、静态方法、链式调用三种形式
🔸 模板表达式：#{...}在文本中嵌入动态表达式
🔸 占位符：${key}从配置文件取值，支持默认值
🔸 字符串模板：模板表达式在文本生成中的应用
🔸 复合表达式：多个表达式组合实现复杂逻辑
```

### 7.2 关键区别理解


**占位符 vs 模板表达式**

| 特性 | 占位符`${...}` | 模板表达式`#{...}` |
|------|--------------|------------------|
| **功能** | 取配置值 | 动态计算 |
| **示例** | `${server.port}` | `#{#price * 0.9}` |
| **场景** | 读取properties | 业务逻辑计算 |
| **默认值** | `${key:default}` | 表达式内三元运算 |

**方法引用 vs 自定义函数**

| 特性 | 方法引用 | 自定义函数 |
|------|---------|-----------|
| **调用方式** | `#obj.method()` | `#funcName()` |
| **方法要求** | 实例方法或静态方法 | 必须是静态方法 |
| **使用场景** | 已有对象的方法 | 通用工具函数 |

### 7.3 实际应用指南


**场景1：配置管理**
- 使用占位符`${...}`读取配置
- 使用SpEL计算配置衍生值
- 示例：`#{${base.port} + 1000}`

**场景2：动态文本生成**
- 使用字符串模板生成通知消息
- 结合条件表达式实现个性化内容
- 示例：订单确认邮件、短信通知

**场景3：业务规则表达**
- 注册自定义函数封装业务逻辑
- 使用复合表达式组合多个规则
- 示例：价格计算、权限判断

**场景4：数据处理**
- 使用集合操作过滤和转换数据
- 方法链处理字符串和数值
- 示例：订单统计、数据清洗

### 7.4 注意事项和技巧


**⚠️ 常见陷阱**
- 自定义函数必须是`public static`方法
- 安全访问符`?.`避免NullPointerException
- 模板表达式需要传入`ParserContext`
- 占位符解析在SpEL之前执行

**💡 优化建议**
- 复杂表达式拆分为多步执行
- 提取重复子表达式到变量
- 合理使用括号明确优先级
- 表达式过于复杂时考虑Java代码实现

**🔧 调试技巧**
```java
// 打印表达式结果
Expression exp = parser.parseExpression("复杂表达式");
Object result = exp.getValue(context);
System.out.println("表达式结果：" + result);

// 检查变量值
System.out.println("变量值：" + context.lookupVariable("varName"));
```

### 7.5 学习路径建议


```
1️⃣ 基础阶段
   ├── 掌握基本语法和运算符
   ├── 熟悉方法引用和属性访问
   └── 理解占位符和模板表达式区别

2️⃣ 进阶阶段
   ├── 学习自定义函数注册
   ├── 掌握复合表达式编写
   └── 实践字符串模板应用

3️⃣ 高级阶段
   ├── 集合操作和Lambda表达式
   ├── 性能优化和缓存策略
   └── 自定义PropertyAccessor扩展
```

**核心记忆口诀**：
```
自定义函数static注册，井号调用方便快
方法引用点号连，安全问号避空险
模板表达式井号嵌，动态文本很简单
占位符取配置值，美元符号记心间
复合表达式组合用，业务规则好实现
```