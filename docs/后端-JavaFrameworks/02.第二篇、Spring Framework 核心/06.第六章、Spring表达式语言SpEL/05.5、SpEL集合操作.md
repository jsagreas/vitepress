---
title: 5、SpEL集合操作
---
## 📚 目录

1. [SpEL集合操作概述](#1-SpEL集合操作概述)
2. [集合选择?[]操作符](#2-集合选择操作符)
3. [集合投影![]操作符](#3-集合投影操作符)
4. [过滤操作详解](#4-过滤操作详解)
5. [聚合函数应用](#5-聚合函数应用)
6. [Map字典访问](#6-Map字典访问)
7. [数组索引操作](#7-数组索引操作)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 SpEL集合操作概述


### 1.1 什么是SpEL集合操作


**简单理解**：就像你在Excel中筛选、汇总数据一样，SpEL让你在Spring中用表达式直接操作集合数据。

```
日常场景类比：
你有一个学生名单，想要：
✅ 找出所有成绩>80分的学生 → 这就是"选择"
✅ 只取出所有学生的名字 → 这就是"投影"
✅ 计算平均分 → 这就是"聚合"

SpEL就是用简洁的表达式帮你做这些事！
```

### 1.2 为什么需要集合操作


**传统Java代码的痛点**：
```java
// ❌ 传统写法：繁琐冗长
List<Student> result = new ArrayList<>();
for(Student s : students) {
    if(s.getScore() > 80) {
        result.add(s);
    }
}

// ✅ SpEL写法：一行搞定
#students.?[score > 80]
```

> 💡 **核心价值**
> 
> SpEL集合操作让配置文件、注解中的逻辑表达更简洁，不用写大量Java代码

### 1.3 集合操作符速览


| 操作符 | 名称 | 作用 | 记忆方法 |
|--------|------|------|----------|
| `?[]` | **选择** | 过滤符合条件的元素 | **问号=提问**：哪些符合？ |
| `![]` | **投影** | 提取特定属性 | **感叹号=强调**：只要这个！ |
| `^[]` | **第一个** | 取第一个符合的 | **尖角朝上**：最前面 |
| `$[]` | **最后一个** | 取最后一个符合的 | **美元符**：最后结算 |
| `[]` | **索引** | 按位置访问 | **方括号**：数组下标 |

---

## 2. 🔍 集合选择?[]操作符


### 2.1 基本概念解析


**选择（Selection）**：从集合中挑出符合条件的元素，就像用筛子筛东西。

```
现实类比：
🍎🍊🍋🍎🍊  (一筐水果)
      ↓ 选择操作：?[type == '苹果']
    🍎🍎      (只留苹果)
```

**语法格式**：
```
集合.?[条件表达式]
```

### 2.2 基础使用示例


**场景1：筛选成绩优秀的学生**

```java
// Java对象定义
public class Student {
    private String name;
    private int score;
    // getter/setter...
}

// SpEL表达式
#students.?[score >= 90]
```

**通俗解释**：
- `#students` - 获取学生集合
- `.?[]` - 开始选择操作
- `score >= 90` - 条件：分数大于等于90
- 结果：返回所有高分学生的列表

**场景2：筛选特定状态的订单**

```java
// 订单状态：PENDING(待付款), PAID(已付款), SHIPPED(已发货)
#orders.?[status == 'PAID']
```

> ⚠️ **新手注意**
> 
> - 条件中的`score`、`status`是对象的属性名
> - 字符串要用**单引号**括起来：`'PAID'`
> - 返回的是一个新集合，不会改变原集合

### 2.3 复杂条件筛选


**多条件组合**：用 `and`、`or`、`not` 连接

```java
// ✅ 且条件：成绩优秀且出勤率高
#students.?[score >= 90 and attendance > 0.9]

// ✅ 或条件：语文或数学及格
#students.?[chinese >= 60 or math >= 60]

// ✅ 非条件：不及格的学生
#students.?[not(score >= 60)]
// 或者简写
#students.?[score < 60]
```

**嵌套对象条件**：

```java
// 学生有班级对象
public class Student {
    private String name;
    private Class classInfo;  // 班级信息
}

// 筛选：一年级的学生
#students.?[classInfo.grade == 1]
```

### 2.4 首尾元素快捷选择


**获取第一个符合的元素**：`^[]`

```java
// 找第一个及格的学生
#students.^[score >= 60]
```

**获取最后一个符合的元素**：`$[]`

```java
// 找最后一个优秀学生
#students.$[score >= 90]
```

**对比总结**：

| 操作符 | 返回结果 | 使用场景 |
|--------|----------|----------|
| `?[]` | **所有**符合的元素（List） | 需要全部结果 |
| `^[]` | **第一个**符合的元素（单个对象） | 只需最早的一个 |
| `$[]` | **最后一个**符合的元素（单个对象） | 只需最新的一个 |

---

## 3. 🎯 集合投影![]操作符


### 3.1 投影概念通俗解释


**投影（Projection）**：从对象中"抽取"某个属性，就像拍照只拍人脸一样。

```
现实类比：
学生档案：{姓名: 张三, 年龄: 18, 成绩: 95}
         {姓名: 李四, 年龄: 19, 成绩: 88}
              ↓ 投影操作：![name]
         只要名字：[张三, 李四]
```

**语法格式**：
```
集合.![属性表达式]
```

### 3.2 基础投影操作


**场景1：提取所有学生姓名**

```java
// 学生对象列表
List<Student> students = ...

// SpEL表达式
#students.![name]

// 结果：[张三, 李四, 王五]
```

**场景2：提取多个属性**

```java
// 提取姓名和成绩（返回Map）
#students.![{name: name, score: score}]

// 结果：
// [{name: "张三", score: 95}, 
//  {name: "李四", score: 88}]
```

> 💡 **理解要点**
> 
> - 投影**不改变**集合大小，每个元素对应一个结果
> - 单属性投影返回简单列表
> - 多属性用`{}`包裹，返回Map列表

### 3.3 投影与选择组合使用


**先筛选后提取**：最常用的组合模式

```java
// 找出优秀学生的名字
#students.?[score >= 90].![name]
```

**执行流程图解**：

```
原始数据：
  [{name: 张三, score: 95},
   {name: 李四, score: 88},
   {name: 王五, score: 92}]
         ↓
  ?[score >= 90]  (选择操作)
         ↓
  [{name: 张三, score: 95},
   {name: 王五, score: 92}]
         ↓
  ![name]  (投影操作)
         ↓
  [张三, 王五]
```

**更多组合示例**：

```java
// ✅ 一年级优秀学生的名字
#students.?[classInfo.grade == 1 and score >= 90].![name]

// ✅ 已付款订单的订单号
#orders.?[status == 'PAID'].![orderNo]

// ✅ 活跃用户的邮箱地址
#users.?[isActive == true].![email]
```

### 3.4 复杂投影表达式


**计算型投影**：在投影时进行计算

```java
// 计算每个学生的总分（语文+数学）
#students.![chinese + math]

// 拼接字符串
#students.!['姓名：' + name + '，成绩：' + score]
```

**条件型投影**：投影时使用三元表达式

```java
// 成绩等级转换
#students.![score >= 90 ? '优秀' : (score >= 60 ? '及格' : '不及格')]
```

---

## 4. 🔎 过滤操作详解


### 4.1 过滤操作的本质


**过滤 = 选择的另一种说法**，在SpEL中主要通过`?[]`实现。

```
过滤流程：
  输入集合 → [条件判断] → 输出符合条件的子集
```

### 4.2 常见过滤场景


**🔸 数值范围过滤**

```java
// 成绩在60-80之间
#students.?[score >= 60 and score <= 80]

// 简化写法（如果支持）
#students.?[score between {60, 80}]
```

**🔸 字符串匹配过滤**

```java
// 名字包含"张"的学生
#students.?[name.contains('张')]

// 邮箱以某域名结尾
#users.?[email.endsWith('@gmail.com')]

// 姓名长度过滤
#students.?[name.length() == 2]
```

**🔸 null值过滤**

```java
// 过滤掉null值
#list.?[#this != null]

// 过滤属性非null的对象
#students.?[phone != null]
```

> ⚠️ **关键变量说明**
> 
> `#this` - 代表当前遍历的元素本身

**🔸 集合属性过滤**

```java
// 学生选修课程超过3门
#students.?[courses.size() > 3]

// 订单商品包含某类别
#orders.?[items.?[category == '电子产品'].size() > 0]
```

### 4.3 过滤性能优化建议


| 场景 | ❌ 不推荐 | ✅ 推荐 |
|------|----------|---------|
| 简单条件 | 多次过滤 | 合并条件一次过滤 |
| 大集合 | 复杂嵌套表达式 | 先在Java层预处理 |
| 频繁使用 | 每次都计算 | 缓存过滤结果 |

---

## 5. 📊 聚合函数应用


### 5.1 什么是聚合函数


**聚合**：把多个值"合并"成一个值，就像把一堆数字求总和。

```
数据聚合示意：
  [95, 88, 92, 76] 
       ↓ sum()求和
      351
       ↓ avg()平均
      87.75
```

### 5.2 常用聚合操作


**🔸 求和 sum()**

```java
// 所有学生成绩总和
#students.![score].sum()

// 优秀学生成绩总和
#students.?[score >= 90].![score].sum()
```

**🔸 平均值 average()**

```java
// 班级平均分
#students.![score].average()
```

**🔸 计数 size() / count()**

```java
// 学生总数
#students.size()

// 及格人数
#students.?[score >= 60].size()
```

**🔸 最大/最小值**

```java
// 最高分
#students.![score].max()

// 最低分
#students.![score].min()
```

### 5.3 聚合函数组合使用


**统计分析示例**：

```java
// 优秀率计算
#students.?[score >= 90].size() / #students.size() * 100
```

**分组聚合思路**：

```java
// 虽然SpEL不直接支持groupBy，但可以这样思考：
// 1. 先按条件选择
// 2. 再对结果聚合

// 一年级平均分
#students.?[classInfo.grade == 1].![score].average()

// 二年级平均分  
#students.?[classInfo.grade == 2].![score].average()
```

### 5.4 聚合结果应用


**在注解中使用**：

```java
@Value("#{ students.?[score >= 90].size() }")
private int excellentCount;

@Value("#{ students.![score].average() }")
private double avgScore;
```

> 💡 **实用技巧**
> 
> 聚合结果可以直接注入到Bean属性中，实现配置化的统计逻辑

---

## 6. 🗂️ Map字典访问


### 6.1 Map访问基础


**Map是什么**：键值对集合，像字典一样通过"key"查"value"。

```
Map结构示意：
  姓名 → 张三
  年龄 → 18    ← 通过key获取value
  城市 → 北京
```

### 6.2 Map访问语法


**🔸 点号访问**（推荐）

```java
// 假设有Map: {name: "张三", age: 18}
#map.name      // 结果: "张三"
#map.age       // 结果: 18
```

**🔸 方括号访问**

```java
#map['name']   // 结果: "张三"
#map['age']    // 结果: 18
```

**🔸 动态key访问**

```java
// key来自变量
#map[#keyName]

// key是表达式结果
#map['user_' + #id]
```

> ⚠️ **访问方式选择**
> 
> - key是**固定字符串** → 用点号 `.name`
> - key是**变量或表达式** → 用方括号 `[#keyName]`
> - key包含**特殊字符** → 必须用方括号 `['user-name']`

### 6.3 Map集合操作


**Map的选择操作**：

```java
// 假设Map<String, Student>
// 选出成绩>80的学生条目
#studentMap.?[value.score > 80]
```

**关键变量说明**：

| 变量 | 含义 | 使用示例 |
|------|------|----------|
| `key` | 当前键 | `key.startsWith('user')` |
| `value` | 当前值 | `value.score > 80` |

**Map的投影操作**：

```java
// 提取所有value的名字
#studentMap.![value.name]

// 提取所有key
#studentMap.![key]
```

### 6.4 嵌套Map访问


**多层级访问**：

```java
// 结构：{user: {profile: {name: "张三"}}}
#data.user.profile.name

// 或者
#data['user']['profile']['name']
```

**安全访问（避免空指针）**：

```java
// 使用?.安全导航
#data?.user?.profile?.name

// 如果user或profile为null，整个表达式返回null而不报错
```

---

## 7. 🔢 数组索引操作


### 7.1 数组访问基础


**数组索引**：通过位置编号访问元素，**从0开始计数**。

```
数组示意：
  索引:  0    1    2    3    4
  元素: [95, 88, 92, 76, 84]
         ↑              ↑
      第1个元素      第5个元素
```

### 7.2 基本索引访问


**🔸 正向索引**

```java
// 获取第一个元素（索引0）
#students[0]

// 获取第三个元素（索引2）
#students[2]
```

**🔸 负向索引**（部分实现支持）

```java
// 最后一个元素
#students[-1]

// 倒数第二个
#students[-2]
```

> 💡 **下标规则**
> 
> - 正数：从头开始数，0是第一个
> - 负数：从尾开始数，-1是最后一个

### 7.3 数组切片操作


**范围访问**（语法因实现而异）：

```java
// 伪代码示意（具体语法看Spring版本）
#students[0..3]    // 前4个元素
#students[2..-1]   // 第3个到最后
```

> ⚠️ **兼容性提示**
> 
> 数组切片语法在不同Spring版本中支持度不同，建议使用基本索引

### 7.4 多维数组访问


**二维数组示例**：

```java
// 班级成绩表 class[班级][学生]
int[][] scores = {{95,88}, {76,92}};

// 访问第1个班级的第2个学生成绩
#scores[0][1]  // 结果: 88
```

### 7.5 集合与数组混合操作


**先选择后索引**：

```java
// 找出优秀学生后取第一个
#students.?[score >= 90][0]

// 等价于
#students.^[score >= 90]
```

**先索引后访问属性**：

```java
// 第一个学生的名字
#students[0].name

// 最后一个学生的成绩
#students[#students.size()-1].score
```

---

## 8. 📋 核心要点总结


### 8.1 操作符速记卡


```
┌─────────────────────────────────────────────┐
│  SpEL集合操作符快速参考                      │
├─────────────────────────────────────────────┤
│  ?[]  → 选择：过滤符合条件的元素             │
│  ![]  → 投影：提取指定属性                   │
│  ^[]  → 首选：第一个符合的                   │
│  $[]  → 尾选：最后一个符合的                 │
│  []   → 索引：按位置访问                     │
└─────────────────────────────────────────────┘
```

### 8.2 组合使用模式


**最佳实践流程**：

```
数据源 → 选择?[] → 投影![] → 聚合函数
                              ↓
                         或直接索引[]
```

**典型模式表**：

| 需求 | SpEL表达式模式 | 示例 |
|------|---------------|------|
| 条件筛选 | `集合.?[条件]` | `#list.?[score>80]` |
| 属性提取 | `集合.![属性]` | `#list.![name]` |
| 组合查询 | `集合.?[].![]` | `#list.?[score>80].![name]` |
| 聚合统计 | `集合.![].函数()` | `#list.![score].avg()` |
| 字典访问 | `map.key` 或 `map['key']` | `#map.username` |
| 数组定位 | `数组[索引]` | `#arr[0]` |

### 8.3 常见错误与解决


| ❌ 错误写法 | ✅ 正确写法 | 说明 |
|-----------|-----------|------|
| `#list?[条件]` | `#list.?[条件]` | 问号前要有**点号** |
| `#list![属性]` | `#list.![属性]` | 感叹号前要有**点号** |
| `#map[name]` | `#map['name']` 或 `#map.name` | 字符串key要**加引号** |
| `#list.?[score>80][name]` | `#list.?[score>80].![name]` | 投影要用`![]` |

### 8.4 性能优化建议


**🔸 减少嵌套层级**

```java
// ❌ 过度嵌套
#list.?[items.?[status=='ACTIVE'].size()>0]

// ✅ 简化逻辑
#list.?[hasActiveItem==true]  // 在对象中预处理
```

**🔸 避免重复计算**

```java
// ❌ 多次执行同样的选择
#students.?[score>=90].size()
#students.?[score>=90].![name]

// ✅ 先选择再复用
#excellent = #students.?[score>=90]
#excellent.size()
#excellent.![name]
```

**🔸 合理使用缓存**

```java
@Value("#{ T(java.util.Collections).unmodifiableList(
         students.?[score >= 90]) }")
private List<Student> excellentStudents;  // 结果缓存到Bean
```

### 8.5 实战应用场景


**场景1：配置文件动态过滤**

```yaml
# application.yml
active-users: "#{ users.?[status == 'ACTIVE'] }"
user-emails: "#{ users.?[subscribed == true].![email] }"
```

**场景2：注解条件判断**

```java
@ConditionalOnExpression(
  "#{ environment['db.mode'] == 'master' and 
      systemProperties['os.name'].contains('Linux') }")
public class MasterDbConfig { ... }
```

**场景3：数据校验规则**

```java
@AssertTrue(message = "至少有一个管理员")
public boolean hasAdmin() {
    // 使用SpEL表达式验证
    return evaluator.parseExpression(
      "#users.?[role == 'ADMIN'].size() > 0"
    ).getValue(context, Boolean.class);
}
```

### 8.6 学习记忆口诀


```
问号筛选条件判，感叹提取属性看
尖角首个美元尾，方框索引位置关
点号字典属性访，组合使用威力显
先选后投是常道，聚合统计在后面
```

### 8.7 进阶学习路径


```
第一步：掌握基础操作符
  ↓
第二步：理解组合使用逻辑
  ↓  
第三步：实践业务场景应用
  ↓
第四步：优化表达式性能
  ↓
第五步：集成到Spring生态
```

> 🎯 **核心要领**
> 
> SpEL集合操作的本质是：
> 1. **选择** - 筛选数据（`?[]`）
> 2. **投影** - 转换数据（`![]`）
> 3. **聚合** - 汇总数据（函数）
> 
> 掌握这三点，就能灵活应对90%的场景！