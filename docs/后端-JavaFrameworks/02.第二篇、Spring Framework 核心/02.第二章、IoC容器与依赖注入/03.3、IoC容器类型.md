---
title: 3、IoC容器类型
---
## 📚 目录

1. [IoC容器是什么](#1-IoC容器是什么)
2. [BeanFactory接口详解](#2-BeanFactory接口详解)
3. [ApplicationContext接口详解](#3-ApplicationContext接口详解)
4. [两大容器功能对比](#4-两大容器功能对比)
5. [实际应用场景选择](#5-实际应用场景选择)
6. [容器层次体系](#6-容器层次体系)
7. [容器扩展点机制](#7-容器扩展点机制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏭 IoC容器是什么


### 1.1 通俗理解IoC容器


**生活场景类比**：
```
传统方式（自己做饭）：
你 → 买菜 → 洗菜 → 切菜 → 炒菜 → 装盘
自己控制每一步，很累！

IoC方式（餐厅点餐）：
你 → 点菜 → 等待 → 吃饭
厨房（容器）帮你准备好一切，你只管用！
```

**IoC容器的本质**：
> 💡 **简单理解**：IoC容器就像一个"智能工厂"，你需要什么对象，它就帮你创建、配置、组装好，然后交给你使用。你不用关心对象是怎么创建的，只需要告诉容器"我要这个"。

### 1.2 为什么需要容器


**问题场景**：
```
没有容器时的困境：
                    你的代码
                       ↓
    需要创建对象A → new A()
                       ↓
    A需要依赖B → new B()
                       ↓
    B需要依赖C → new C()
                       ↓
    C需要依赖D → new D()

问题：依赖关系复杂，代码耦合严重！
```

**有容器后的解决**：
```
使用容器：
    你的代码 → 告诉容器"我要A"
                       ↓
              容器自动处理：
              - 发现A需要B
              - 发现B需要C  
              - 发现C需要D
              - 按顺序创建D→C→B→A
              - 自动注入依赖关系
                       ↓
              返回配置好的A给你

优势：依赖关系由容器管理，代码解耦！
```

### 1.3 Spring提供的两大容器类型


```
Spring IoC容器家族：
                 IoC容器接口
                      │
          ┌───────────┴───────────┐
          │                       │
    BeanFactory              ApplicationContext
    （基础容器）              （高级容器）
          │                       │
    ┌─────┴─────┐         ┌───────┴────────┐
    │           │         │                │
 XmlBean   Default    ClassPath      Web
 Factory   ListableBean  Xml          Application
           Factory     Application    Context
                       Context
```

**核心区别一句话**：
- **BeanFactory**：最基础的容器，功能简单，适合资源受限环境
- **ApplicationContext**：功能丰富的容器，是BeanFactory的增强版，实际开发首选

---

## 2. 🔧 BeanFactory接口详解


### 2.1 BeanFactory是什么


**定义理解**：
> 📖 **BeanFactory**：Spring IoC容器的"老祖宗"，提供最基本的容器功能——创建和管理Bean对象。就像一个简易版的对象工厂，只有核心功能，没有花里胡哨的附加服务。

### 2.2 BeanFactory的核心能力


**基础功能清单**：
```
BeanFactory能做什么？

✅ 创建对象：根据配置创建Bean实例
✅ 存储对象：把创建的Bean存起来
✅ 获取对象：通过名称或类型获取Bean
✅ 管理生命周期：控制Bean的创建和销毁
✅ 依赖注入：自动注入Bean之间的依赖

不能做什么？
❌ 自动注册后处理器
❌ 国际化支持
❌ 事件发布机制
❌ 资源加载功能
```

### 2.3 BeanFactory工作机制


**延迟加载特性**：
```java
// BeanFactory的懒加载机制
BeanFactory factory = new XmlBeanFactory(new ClassPathResource("beans.xml"));

// 此时：只加载了配置文件，Bean还没创建！
System.out.println("配置文件已加载");

// 第一次getBean时才真正创建对象
UserService service = factory.getBean("userService", UserService.class);
// 这一刻：UserService对象才被创建
```

**对比理解**：
```
餐厅类比：

BeanFactory = 点菜后现做的餐厅
- 你点什么，厨房才开始做什么
- 节省资源，但等待时间长
- 适合资源紧张的情况

优点：
- 启动快（不预先创建对象）
- 内存占用小

缺点：
- 首次使用时响应慢
- 配置错误要运行时才发现
```

### 2.4 BeanFactory的基本使用


**典型代码示例**：
```java
// 创建BeanFactory容器
Resource resource = new ClassPathResource("applicationContext.xml");
BeanFactory factory = new XmlBeanFactory(resource);

// 获取Bean对象
UserService userService = (UserService) factory.getBean("userService");

// 检查Bean是否存在
if (factory.containsBean("userService")) {
    System.out.println("Bean存在");
}

// 判断是否单例
boolean isSingleton = factory.isSingleton("userService");
```

### 2.5 BeanFactory的接口方法


| 方法名 | **作用说明** | **使用场景** |
|-------|------------|------------|
| `getBean(String name)` | `根据Bean名称获取对象` | `最常用的获取方式` |
| `getBean(Class<T> type)` | `根据类型获取对象` | `类型唯一时使用` |
| `containsBean(String)` | `判断容器中是否有该Bean` | `避免获取不存在的Bean` |
| `isSingleton(String)` | `判断Bean是否单例` | `了解Bean的作用域` |
| `isPrototype(String)` | `判断Bean是否原型` | `每次获取都创建新对象` |
| `getType(String)` | `获取Bean的类型` | `动态判断Bean类型` |

---

## 3. 🚀 ApplicationContext接口详解


### 3.1 ApplicationContext是什么


**定义理解**：
> 📖 **ApplicationContext**：Spring的"高级容器"，是BeanFactory的增强版。除了基本的对象管理功能，还提供了企业级应用需要的各种高级特性。就像从简易工厂升级到了现代化智能工厂。

**继承关系**：
```
ApplicationContext的家谱：

           BeanFactory（爷爷辈）
                 ↑
                 │ 继承
                 │
         ListableBeanFactory（父辈）
         HierarchicalBeanFactory
         MessageSource
         ApplicationEventPublisher
         ResourcePatternResolver
                 ↑
                 │ 综合继承
                 │
         ApplicationContext（本尊）
                 ↑
                 │ 具体实现
                 │
    ┌────────────┼────────────┐
    │            │            │
ClassPath    FileSystem     Web
Xml          Xml        Application
Application  Application   Context
Context      Context
```

### 3.2 ApplicationContext的增强功能


**功能全景图**：
```
ApplicationContext = BeanFactory + 企业级增强

核心增强：
┌─────────────────────────────────────┐
│ 🔸 BeanFactory基础功能             │
│   ✓ Bean创建与管理                 │
│   ✓ 依赖注入                       │
├─────────────────────────────────────┤
│ 🔸 自动化功能                       │
│   ✓ 自动注册Bean后处理器            │
│   ✓ 自动注册Bean工厂后处理器        │
├─────────────────────────────────────┤
│ 🔸 国际化支持（i18n）               │
│   ✓ 多语言消息处理                 │
│   ✓ 资源文件加载                   │
├─────────────────────────────────────┤
│ 🔸 事件发布机制                     │
│   ✓ 应用事件监听                   │
│   ✓ 自定义事件发布                 │
├─────────────────────────────────────┤
│ 🔸 资源访问                         │
│   ✓ 统一资源加载                   │
│   ✓ 多种资源格式支持               │
├─────────────────────────────────────┤
│ 🔸 环境抽象                         │
│   ✓ Profile配置                    │
│   ✓ 属性管理                       │
└─────────────────────────────────────┘
```

### 3.3 ApplicationContext的预加载机制


**即时加载特性**：
```java
// ApplicationContext的即时加载
ApplicationContext context = 
    new ClassPathXmlApplicationContext("beans.xml");

// 此时：所有单例Bean已经创建完成！
System.out.println("容器启动完成，Bean已准备就绪");

// 直接获取，无需等待
UserService service = context.getBean("userService", UserService.class);
// 立即返回，因为对象早就创建好了
```

**对比理解**：
```
餐厅类比：

ApplicationContext = 自助餐厅
- 开门前把所有菜都做好
- 你来了直接拿，无需等待
- 资源充足时的最佳选择

优点：
- 使用时响应快（对象已创建）
- 启动时发现所有配置错误
- 支持更多企业级功能

缺点：
- 启动慢（预先创建所有对象）
- 内存占用大
```

### 3.4 ApplicationContext的常用实现类


**实现类对比**：

| 实现类 | **配置来源** | **使用场景** | **路径说明** |
|-------|------------|------------|------------|
| `ClassPathXmlApplicationContext` | `类路径XML` | `独立应用，配置在classpath下` | `相对于类路径的相对路径` |
| `FileSystemXmlApplicationContext` | `文件系统XML` | `配置文件在磁盘绝对路径` | `文件系统的绝对/相对路径` |
| `AnnotationConfigApplicationContext` | `Java配置类` | `纯注解配置，无XML` | `扫描带@Configuration的类` |
| `WebApplicationContext` | `Web环境` | `Web应用专用容器` | `Servlet上下文中` |

**使用示例**：
```java
// 方式1：从类路径加载XML
ApplicationContext ctx1 = 
    new ClassPathXmlApplicationContext("applicationContext.xml");

// 方式2：从文件系统加载XML
ApplicationContext ctx2 = 
    new FileSystemXmlApplicationContext("/config/beans.xml");

// 方式3：使用Java配置类（现代推荐）
ApplicationContext ctx3 = 
    new AnnotationConfigApplicationContext(AppConfig.class);
```

### 3.5 ApplicationContext特有功能演示


**国际化支持**：
```java
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");

// 获取不同语言的消息
String msg_cn = context.getMessage("greeting", null, Locale.CHINA);
// 输出：你好！

String msg_en = context.getMessage("greeting", null, Locale.US);
// 输出：Hello!
```

**事件发布**：
```java
// 发布自定义事件
context.publishEvent(new UserRegisteredEvent(this, user));

// 监听器会自动接收并处理
// @EventListener注解的方法会被调用
```

---

## 4. ⚖️ 两大容器功能对比


### 4.1 核心差异对照表


| 对比维度 | **BeanFactory** | **ApplicationContext** |
|---------|----------------|----------------------|
| **定位** | `基础容器，轻量级` | `企业级容器，功能全面` |
| **加载时机** | `延迟加载（用时创建）` | `即时加载（启动创建）` |
| **启动速度** | `快（不预创建Bean）` | `慢（预创建所有Bean）` |
| **内存占用** | `小（按需创建）` | `大（预先创建）` |
| **功能完整性** | `基础功能` | `基础+增强功能` |
| **Bean后处理器** | `需手动注册` | `自动注册` |
| **国际化** | `❌ 不支持` | `✅ 支持` |
| **事件机制** | `❌ 不支持` | `✅ 支持` |
| **资源访问** | `❌ 不支持` | `✅ 支持` |
| **适用场景** | `资源受限环境` | `企业级应用（推荐）` |

### 4.2 加载方式对比图


```
BeanFactory 延迟加载：
启动阶段          使用阶段
   ↓                ↓
加载配置 ──────→ 第一次getBean
   │                ↓
   │             创建Bean
   │                ↓
   │             注入依赖
   │                ↓
   └─────────→  返回Bean对象

特点：启动快，首次使用慢


ApplicationContext 即时加载：
启动阶段                   使用阶段
   ↓                         ↓
加载配置                  直接getBean
   ↓                         ↓
扫描所有Bean定义        立即返回对象
   ↓
创建所有单例Bean
   ↓
注入所有依赖
   ↓
调用初始化方法
   ↓
容器启动完成

特点：启动慢，使用快
```

### 4.3 功能范围对比


**功能集合对比**：
```
BeanFactory 能力范围：
┌──────────────────┐
│  Bean生命周期管理 │
│  依赖注入        │
│  Bean作用域控制  │
└──────────────────┘
     基础功能层


ApplicationContext 能力范围：
┌────────────────────────────┐
│  国际化 │ 事件发布 │ 资源访问│
├────────────────────────────┤
│  自动后处理器 │ 环境抽象    │
├────────────────────────────┤
│  Bean生命周期 │ 依赖注入    │
└────────────────────────────┘
   增强功能层 + 基础功能层
```

### 4.4 使用代码对比


**BeanFactory使用**：
```java
// 创建容器
BeanFactory factory = new XmlBeanFactory(
    new ClassPathResource("beans.xml")
);

// 手动注册后处理器（如果需要）
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// 获取Bean（此时才创建）
UserService service = factory.getBean("userService", UserService.class);
```

**ApplicationContext使用**：
```java
// 创建容器（启动时就创建所有Bean）
ApplicationContext context = 
    new ClassPathXmlApplicationContext("beans.xml");

// 直接获取Bean（已经创建好）
UserService service = context.getBean("userService", UserService.class);

// 使用增强功能
String message = context.getMessage("welcome", null, Locale.CHINA);
context.publishEvent(new CustomEvent(this));
```

---

## 5. 🎯 实际应用场景选择


### 5.1 选择BeanFactory的场景


> ⚠️ **注意**：实际开发中极少直接使用BeanFactory，主要用于理解Spring底层机制或特殊资源受限环境。

**适合场景**：
```
✅ 移动设备应用
   - 内存极度受限
   - 需要最小化启动时间
   
✅ 嵌入式系统
   - 资源紧张
   - 只需基础IoC功能

✅ 学习Spring原理
   - 理解容器底层机制
   - 研究IoC核心实现
```

**典型案例**：
```
案例：低配置嵌入式设备

设备限制：
- 内存：64MB
- 启动时间要求：<2秒
- 功能需求：简单对象管理

解决方案：
使用BeanFactory
- 延迟加载节省内存
- 快速启动满足要求
- 基础功能够用
```

### 5.2 选择ApplicationContext的场景


> 💡 **推荐**：99%的实际开发场景都应该使用ApplicationContext。

**适合场景**：
```
✅ 企业级Web应用
   - 需要完整功能
   - 性能要求高
   
✅ 微服务架构
   - 依赖注入复杂
   - 需要事件机制

✅ Spring Boot应用
   - 默认使用
   - 自动配置依赖

✅ 需要高级特性
   - 国际化支持
   - AOP功能
   - 事务管理
```

**典型案例**：
```
案例：电商系统后台

业务需求：
- 用户、订单、商品等模块
- 多语言支持
- 订单状态变更通知
- 事务一致性

解决方案：
使用ApplicationContext
- 自动依赖注入管理复杂关系
- 国际化支持多语言
- 事件机制处理订单通知
- AOP实现事务管理
```

### 5.3 实现类选择指南


**选择决策树**：
```
开始选择容器实现类
         │
         ▼
    使用XML配置？
    ┌────┴────┐
   是          否
   │           │
   ▼           ▼
配置文件      使用注解
在哪里？      配置？
   │           │
┌──┴──┐       是
│     │        │
类    文件     ▼
路    系统   Annotation
径             Config
│     │      Application
▼     ▼       Context
ClassPath  FileSystem
Xml        Xml
Application Application
Context    Context
```

**具体场景推荐**：

| 场景 | **推荐容器** | **原因** |
|------|------------|---------|
| `Spring Boot项目` | `AnnotationConfigApplicationContext` | `默认注解配置，无XML` |
| `传统Spring Web` | `WebApplicationContext` | `Web环境专用，集成Servlet` |
| `配置在resources下` | `ClassPathXmlApplicationContext` | `打包在jar/war中，方便部署` |
| `配置在外部文件` | `FileSystemXmlApplicationContext` | `便于运维修改配置` |
| `纯Java配置` | `AnnotationConfigApplicationContext` | `现代化，类型安全` |

---

## 6. 🏗️ 容器层次体系


### 6.1 父子容器概念


**什么是父子容器**：
> 📖 **父子容器**：Spring允许创建多个容器，它们之间可以建立父子关系。子容器可以访问父容器的Bean，但父容器不能访问子容器的Bean。就像家庭关系，孩子可以用父母的东西，但父母不能随便用孩子的东西。

**层次结构图**：
```
Spring容器层次结构：

        父容器（Root Context）
        ┌──────────────────┐
        │  公共服务层Bean   │
        │  - DataSource    │
        │  - Service       │
        │  - Repository    │
        └────────┬─────────┘
                 │ 父子关系
        ┌────────┴─────────┐
        │                  │
    子容器1            子容器2
  ┌──────────┐      ┌──────────┐
  │Web层Bean │      │Web层Bean │
  │- Controller│    │- Controller│
  └──────────┘      └──────────┘

访问规则：
✅ 子容器 → 父容器 ：可以访问
❌ 父容器 → 子容器 ：不能访问
❌ 子容器 ↔ 子容器 ：不能互访
```

### 6.2 为什么需要父子容器


**隔离与共享的平衡**：
```
实际场景：Spring MVC应用

问题：
- Service层Bean应该被多个Controller共享
- 不同模块的Controller不应该互相访问
- Web层配置不应该污染业务层

解决：父子容器
           Root容器
         （业务层Bean）
              ↑
              │ 共享访问
              │
         Servlet容器
         （Web层Bean）
              
优势：
✅ 业务层Bean集中管理
✅ Web层隔离
✅ 职责清晰
```

### 6.3 典型父子容器应用


**Spring MVC中的父子容器**：
```java
// 父容器配置（applicationContext.xml）
<beans>
    <!-- 业务层Bean -->
    <bean id="userService" class="com.example.service.UserServiceImpl"/>
    <bean id="userDao" class="com.example.dao.UserDaoImpl"/>
</beans>

// 子容器配置（spring-mvc.xml）
<beans>
    <!-- Web层Bean -->
    <bean id="userController" class="com.example.controller.UserController">
        <!-- 可以注入父容器的Service -->
        <property name="userService" ref="userService"/>
    </bean>
</beans>
```

**加载顺序**：
```
Web应用启动流程：

1. Servlet容器启动
        ↓
2. 加载web.xml
        ↓
3. ContextLoaderListener启动
        ↓
4. 创建Root容器（父容器）
   加载applicationContext.xml
        ↓
5. DispatcherServlet初始化
        ↓
6. 创建Servlet容器（子容器）
   加载spring-mvc.xml
   设置父容器引用
        ↓
7. 应用启动完成
```

### 6.4 容器层次的Bean查找


**Bean查找机制**：
```
查找Bean的流程：

子容器.getBean("beanName")
         ↓
   在本容器查找？
    ┌────┴────┐
   找到      没找到
    │          │
   返回       继续
    Bean       │
              ▼
         在父容器查找？
         ┌────┴────┐
        找到      没找到
         │          │
        返回       抛出
        Bean    NoSuchBean
                Exception

关键点：
- 优先本容器
- 找不到再找父容器
- 递归向上查找
- 不会向下或平级查找
```

---

## 7. 🔌 容器扩展点机制


### 7.1 什么是扩展点


**扩展点定义**：
> 💡 **扩展点**：Spring容器提供的"钩子"接口，允许我们在容器启动、Bean创建等关键时刻插入自定义逻辑。就像家里装修时预留的插座，方便后期扩展功能。

**扩展点分类**：
```
Spring容器扩展点体系：

┌────────────────────────────────┐
│     Bean级别扩展点             │
│  - BeanPostProcessor           │
│  - InstantiationAwareBeanPost..│
│  - InitializingBean            │
│  - DisposableBean              │
├────────────────────────────────┤
│     容器级别扩展点             │
│  - BeanFactoryPostProcessor    │
│  - BeanDefinitionRegistryPost..│
├────────────────────────────────┤
│     生命周期扩展点             │
│  - ApplicationListener         │
│  - SmartLifecycle              │
└────────────────────────────────┘
```

### 7.2 BeanPostProcessor（Bean后处理器）


**作用说明**：
> 📖 在Bean初始化前后插入自定义逻辑，可以修改Bean实例或返回代理对象。AOP就是通过这个机制实现的。

**执行时机图**：
```
Bean生命周期与BeanPostProcessor：

Bean创建流程
     ↓
1. 实例化Bean
     ↓
2. 属性注入
     ↓
3. ⭐ BeanPostProcessor.postProcessBeforeInitialization()
     ↓
4. 调用初始化方法
     ↓
5. ⭐ BeanPostProcessor.postProcessAfterInitialization()
     ↓
6. Bean就绪，可以使用
```

**简单示例**：
```java
// 自定义Bean后处理器
public class MyBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        System.out.println("Bean初始化前：" + beanName);
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("Bean初始化后：" + beanName);
        // 可以返回原Bean，也可以返回代理对象
        return bean;
    }
}
```

### 7.3 BeanFactoryPostProcessor（容器后处理器）


**作用说明**：
> 📖 在容器实例化任何Bean之前，修改Bean的定义信息。可以修改Bean的属性值、类名等元数据。

**执行时机**：
```
容器启动流程：

1. 加载Bean定义
        ↓
2. ⭐ BeanFactoryPostProcessor执行
   （修改Bean定义）
        ↓
3. 实例化Bean
        ↓
4. Bean初始化
        ↓
5. 容器就绪
```

**典型应用**：
```java
// 修改Bean定义的后处理器
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // 获取Bean定义
        BeanDefinition bd = beanFactory.getBeanDefinition("userService");
        
        // 修改Bean定义
        bd.getPropertyValues().add("timeout", 5000);
        
        System.out.println("已修改Bean定义：userService");
    }
}
```

### 7.4 两种后处理器对比


| 对比项 | **BeanFactoryPostProcessor** | **BeanPostProcessor** |
|-------|----------------------------|---------------------|
| **执行时机** | `Bean实例化之前` | `Bean初始化前后` |
| **操作对象** | `Bean定义（元数据）` | `Bean实例（对象）` |
| **作用范围** | `容器级别` | `Bean级别` |
| **典型应用** | `属性占位符解析` | `AOP代理创建` |
| **能否修改Bean定义** | `✅ 可以` | `❌ 不可以` |
| **能否修改Bean实例** | `❌ 不可以` | `✅ 可以` |

**对比图示**：
```
容器启动时间轴：

    容器启动
       │
       ▼
   加载配置文件
       │
       ▼
  ┌──────────────────┐
  │BeanFactoryPost   │ ← 修改Bean定义
  │Processor执行     │
  └────────┬─────────┘
           ▼
     实例化Bean
           │
           ▼
    ┌──────────────┐
    │BeanPost      │ ← 处理Bean实例
    │Processor执行 │
    └──────┬───────┘
           ▼
      Bean就绪
```

### 7.5 ApplicationContext自动注册机制


**自动注册说明**：
```
ApplicationContext的智能之处：

BeanFactory：
- 需要手动注册后处理器
- factory.addBeanPostProcessor(processor)

ApplicationContext：
- 自动扫描并注册
- 只要定义成Bean就会自动生效

示例：
<!-- 只需配置成Bean -->
<bean class="com.example.MyBeanPostProcessor"/>
<!-- ApplicationContext会自动识别并注册 -->
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 IoC容器本质：对象工厂，负责创建、管理、组装Bean
🔸 两大容器类型：BeanFactory（基础）vs ApplicationContext（企业级）
🔸 加载机制差异：延迟加载 vs 即时加载
🔸 功能范围差异：基础功能 vs 基础+增强功能
🔸 父子容器：实现Bean的隔离与共享
🔸 扩展点机制：在关键时刻插入自定义逻辑
```

### 8.2 容器选择决策


**选择流程图**：
```
选择Spring容器
      │
      ▼
  是否资源极度受限？
   ┌────┴────┐
  是         否
  │          │
  ▼          ▼
BeanFactory  ApplicationContext
             │
             ▼
         使用什么配置？
         ┌────┴────┐
        XML       注解
         │         │
         ▼         ▼
    是否在类路径？  Annotation
    ┌────┴────┐   Config
   是         否
   │          │
   ▼          ▼
ClassPath  FileSystem
Xml        Xml
```

### 8.3 实际应用建议


**最佳实践**：
```
✅ 推荐做法：
- 使用ApplicationContext（99%场景）
- Spring Boot项目用注解配置
- Web项目利用父子容器隔离
- 通过扩展点实现自定义功能

❌ 避免做法：
- 直接使用BeanFactory（除非特殊需求）
- 混用多种配置方式造成混乱
- 滥用扩展点增加复杂度
```

### 8.4 关键知识点记忆


**记忆要点**：
```
容器对比：
- BeanFactory = 简易工厂，延迟加载，功能基础
- ApplicationContext = 智能工厂，即时加载，功能全面

父子容器：
- 子访问父：✅ 可以
- 父访问子：❌ 不可以
- 子访问子：❌ 不可以

扩展点：
- BeanFactoryPostProcessor：改定义，Bean创建前
- BeanPostProcessor：改实例，Bean初始化时
```

**核心理解**：
> 💎 Spring IoC容器是整个Spring框架的基础。理解容器的工作原理和扩展机制，是掌握Spring的关键。ApplicationContext作为企业级容器，提供了完善的功能体系，是实际开发的首选。