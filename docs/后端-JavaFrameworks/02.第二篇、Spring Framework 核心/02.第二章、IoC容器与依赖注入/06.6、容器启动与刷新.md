---
title: 6、容器启动与刷新
---
## 📚 目录

1. [容器启动流程概述](#1-容器启动流程概述)
2. [Bean定义加载机制](#2-Bean定义加载机制)
3. [refresh方法核心流程](#3-refresh方法核心流程)
4. [Bean实例化过程](#4-Bean实例化过程)
5. [容器生命周期管理](#5-容器生命周期管理)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🚀 容器启动流程概述


### 1.1 什么是容器启动


**通俗理解**：启动Spring容器就像开一家餐厅
```
餐厅开业准备过程              Spring容器启动过程
=================            ===================
1. 阅读菜单配置              1. 读取配置文件
2. 准备食材和设备            2. 加载Bean定义
3. 培训厨师和服务员          3. 创建Bean实例
4. 开门营业                  4. 容器就绪，提供服务
```

**核心作用**：
- 🔸 **读取配置**：从XML、注解、Java配置类中读取Bean信息
- 🔸 **创建对象**：根据配置创建所有需要的Bean对象
- 🔸 **注入依赖**：把对象之间的依赖关系建立好
- 🔸 **准备服务**：让应用程序可以正常使用这些对象

### 1.2 启动方式对比


| 启动方式 | **使用场景** | **代码示例** | **特点** |
|---------|------------|------------|---------|
| `ClassPathXmlApplicationContext` | XML配置 | `new ClassPathXmlApplicationContext("beans.xml")` | 传统方式，配置在XML文件 |
| `AnnotationConfigApplicationContext` | 注解配置 | `new AnnotationConfigApplicationContext(AppConfig.class)` | 现代方式，基于Java配置 |
| `SpringApplication.run()` | SpringBoot | `SpringApplication.run(App.class, args)` | 自动配置，开箱即用 |

### 1.3 启动阶段划分


```
容器启动完整流程：

阶段1：准备阶段                阶段2：核心阶段               阶段3：完成阶段
┌─────────────┐              ┌─────────────┐             ┌─────────────┐
│ 创建容器对象  │              │ 加载Bean定义 │             │ 发布启动事件  │
│             │              │             │             │             │
│ 设置环境信息  │─────────────→│ 实例化Bean   │────────────→│ 容器就绪     │
│             │              │             │             │             │
│ 预处理器准备  │              │ 依赖注入     │             │ 可以使用     │
└─────────────┘              └─────────────┘             └─────────────┘
```

---

## 2. 📦 Bean定义加载机制


### 2.1 什么是Bean定义


**生活类比**：Bean定义就像食谱
```
食谱（Bean定义）告诉你：
- 菜名是什么           → Bean的名称
- 需要什么食材         → 需要哪些依赖
- 怎么做这道菜         → 如何创建对象
- 什么时候做           → 何时实例化（懒加载？）
- 做几份               → 单例还是多例
```

**Bean定义包含的信息**：
- ✅ **类的全限定名**：`com.example.UserService`
- ✅ **作用域**：单例（singleton）还是原型（prototype）
- ✅ **依赖关系**：需要注入哪些其他Bean
- ✅ **初始化方法**：创建后要调用的方法
- ✅ **销毁方法**：容器关闭时要执行的清理

### 2.2 Bean定义的加载方式


**方式一：XML配置加载**
```xml
<!-- beans.xml -->
<beans>
    <bean id="userService" class="com.example.UserService">
        <property name="userDao" ref="userDao"/>
    </bean>
    
    <bean id="userDao" class="com.example.UserDao"/>
</beans>
```

**方式二：注解扫描加载**
```java
// 配置类
@Configuration
@ComponentScan("com.example")  // 扫描这个包下的所有组件
public class AppConfig {
    // Spring会自动扫描并加载带@Component等注解的类
}

// 业务类
@Service
public class UserService {
    @Autowired
    private UserDao userDao;
}
```

**方式三：Java配置类加载**
```java
@Configuration
public class AppConfig {
    
    @Bean
    public UserDao userDao() {
        return new UserDao();
    }
    
    @Bean
    public UserService userService() {
        UserService service = new UserService();
        service.setUserDao(userDao());  // 手动注入依赖
        return service;
    }
}
```

### 2.3 加载过程详解


```
Bean定义加载流程：

步骤1：定位配置文件
┌─────────────────────┐
│  找到配置文件位置      │
│  - XML文件           │
│  - 注解配置类         │
│  - 扫描的包路径       │
└──────────┬──────────┘
           ↓
步骤2：读取配置信息
┌─────────────────────┐
│  解析配置内容         │
│  - XML标签解析       │
│  - 注解信息读取       │
│  - @Bean方法发现     │
└──────────┬──────────┘
           ↓
步骤3：注册Bean定义
┌─────────────────────┐
│  存入BeanDefinition  │
│  Map中，等待实例化    │
└─────────────────────┘
```

**重点理解**：
- 💡 加载Bean定义≠创建对象，只是读取配置信息
- 💡 此时只知道"要创建什么对象"，还没真正创建
- 💡 所有Bean定义会存储在一个Map容器中

---

## 3. 🔄 refresh方法核心流程


### 3.1 refresh方法是什么


**形象理解**：refresh方法是容器的"总指挥"
```
就像建房子的总工程师：
1. 准备施工现场          → prepareRefresh()
2. 获取建材清单          → obtainFreshBeanFactory()
3. 准备施工工具          → prepareBeanFactory()
4. 施工前的最后检查      → postProcessBeanFactory()
5. 执行特殊施工任务      → invokeBeanFactoryPostProcessors()
6. 注册质量监督员        → registerBeanPostProcessors()
7. 开始实际施工          → finishBeanFactoryInitialization()
8. 竣工验收              → finishRefresh()
```

### 3.2 refresh方法的12个步骤


```java
public void refresh() throws BeansException {
    synchronized (this.startupShutdownMonitor) {
        
        // 【步骤1】准备刷新：设置启动时间、标记状态
        prepareRefresh();
        
        // 【步骤2】获取Bean工厂：加载Bean定义
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
        
        // 【步骤3】准备Bean工厂：设置类加载器、表达式解析器
        prepareBeanFactory(beanFactory);
        
        try {
            // 【步骤4】Bean工厂后置处理（子类可重写）
            postProcessBeanFactory(beanFactory);
            
            // 【步骤5】执行Bean工厂后置处理器
            invokeBeanFactoryPostProcessors(beanFactory);
            
            // 【步骤6】注册Bean后置处理器
            registerBeanPostProcessors(beanFactory);
            
            // 【步骤7】初始化消息源（国际化）
            initMessageSource();
            
            // 【步骤8】初始化事件广播器
            initApplicationEventMulticaster();
            
            // 【步骤9】特定上下文子类初始化其他Bean
            onRefresh();
            
            // 【步骤10】注册监听器
            registerListeners();
            
            // 【步骤11】实例化所有非懒加载的单例Bean
            finishBeanFactoryInitialization(beanFactory);
            
            // 【步骤12】完成刷新，发布事件
            finishRefresh();
        }
        catch (BeansException ex) {
            // 销毁已创建的Bean
            destroyBeans();
            cancelRefresh(ex);
            throw ex;
        }
    }
}
```

### 3.3 关键步骤详解


**🔸 步骤2：obtainFreshBeanFactory（获取Bean工厂）**
```
作用：创建或刷新BeanFactory，加载Bean定义

具体工作：
1. 如果是第一次启动 → 创建新的BeanFactory
2. 如果是刷新 → 销毁旧的，创建新的
3. 从配置文件/注解中加载所有Bean定义
4. 返回可用的BeanFactory对象

输出结果：一个装满Bean定义的工厂，但Bean还没创建
```

**🔸 步骤5：invokeBeanFactoryPostProcessors（执行工厂后置处理器）**
```
作用：在Bean实例化之前，修改Bean定义

典型应用：
- PropertyPlaceholderConfigurer：替换配置中的占位符
  例如：${database.url} → jdbc:mysql://localhost:3306/test
  
- ConfigurationClassPostProcessor：处理@Configuration类
  扫描@Bean方法，注册更多Bean定义

时间点：Bean定义已加载，但对象还未创建
```

**🔸 步骤6：registerBeanPostProcessors（注册Bean后置处理器）**
```
作用：注册在Bean创建过程中的"拦截器"

后置处理器能做什么：
- 在Bean初始化之前修改Bean
- 在Bean初始化之后添加额外逻辑
- 实现AOP、事务等功能

关键点：此步骤只是"注册"，真正执行在Bean创建时
```

**🔸 步骤11：finishBeanFactoryInitialization（实例化Bean）**
```
作用：创建所有非懒加载的单例Bean

这是最核心的步骤：
1. 遍历所有Bean定义
2. 逐个调用getBean()创建Bean实例
3. 处理依赖注入
4. 调用初始化方法
5. 存入单例池

完成后：所有单例Bean都可以直接使用了
```

### 3.4 refresh流程图示


```
容器启动refresh完整流程：

开始
 │
 ├─→ [1] prepareRefresh()              准备工作
 │      └─ 设置启动时间、状态标记
 │
 ├─→ [2] obtainFreshBeanFactory()      获取Bean工厂
 │      └─ 创建BeanFactory、加载Bean定义
 │
 ├─→ [3] prepareBeanFactory()          准备Bean工厂
 │      └─ 设置类加载器、添加内置处理器
 │
 ├─→ [4-6] 后置处理器相关               扩展点处理
 │      ├─ 执行工厂后置处理器
 │      └─ 注册Bean后置处理器
 │
 ├─→ [7-10] 初始化组件                 容器基础设施
 │      ├─ 消息源（国际化）
 │      ├─ 事件广播器
 │      └─ 监听器
 │
 ├─→ [11] finishBeanFactoryInitialization()  【核心】创建Bean
 │      └─ 实例化所有非懒加载单例Bean
 │
 └─→ [12] finishRefresh()              完成刷新
        └─ 发布启动完成事件
        
结束：容器就绪，可以使用
```

---

## 4. 🏭 Bean实例化过程


### 4.1 实例化与初始化的区别


**关键区分**：
```
实例化（Instantiation）     ≠     初始化（Initialization）
创建对象，分配内存                   给对象属性赋值，执行初始化逻辑

类比：
实例化 = 买了一台新手机（空壳）
初始化 = 安装系统、设置账号、导入数据（可用）
```

### 4.2 Bean创建的完整生命周期


```
Bean创建流程（getBean方法内部）：

1. 实例化阶段
   ┌──────────────────────────┐
   │  创建Bean实例             │
   │  - 调用构造方法           │
   │  - 分配内存空间           │
   └────────┬─────────────────┘
            ↓
2. 属性填充阶段
   ┌──────────────────────────┐
   │  依赖注入                 │
   │  - @Autowired字段注入     │
   │  - setter方法注入         │
   │  - 构造器注入             │
   └────────┬─────────────────┘
            ↓
3. 初始化阶段
   ┌──────────────────────────┐
   │  执行初始化逻辑           │
   │  - Aware接口回调          │
   │  - @PostConstruct方法    │
   │  - afterPropertiesSet()  │
   │  - 自定义init方法         │
   └────────┬─────────────────┘
            ↓
4. 后置处理阶段
   ┌──────────────────────────┐
   │  Bean后置处理器           │
   │  - AOP代理生成            │
   │  - 事务增强               │
   └────────┬─────────────────┘
            ↓
5. 就绪阶段
   ┌──────────────────────────┐
   │  Bean可以使用             │
   │  - 放入单例池             │
   │  - 应用程序可获取         │
   └──────────────────────────┘
```

### 4.3 实例化方式


**方式一：构造器实例化（最常用）**
```java
@Service
public class UserService {
    
    private UserDao userDao;
    
    // Spring调用这个构造器创建对象
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
        System.out.println("UserService实例化完成");
    }
}
```

**方式二：工厂方法实例化**
```java
@Configuration
public class AppConfig {
    
    // Spring调用这个方法创建对象
    @Bean
    public UserService userService() {
        System.out.println("通过工厂方法创建UserService");
        return new UserService();
    }
}
```

**方式三：FactoryBean实例化（特殊场景）**
```java
public class UserServiceFactoryBean implements FactoryBean<UserService> {
    
    @Override
    public UserService getObject() throws Exception {
        // 自定义创建逻辑
        UserService service = new UserService();
        service.setCustomProperty("特殊配置");
        return service;
    }
    
    @Override
    public Class<?> getObjectType() {
        return UserService.class;
    }
}
```

### 4.4 依赖注入时机


```
Bean创建过程中的依赖注入：

时机1：构造器注入（实例化时）
┌─────────────────────────────┐
│  new UserService(userDao)   │  ← 创建对象时就注入
│  此时UserDao必须已经准备好   │
└─────────────────────────────┘

时机2：字段/Setter注入（实例化后）
┌─────────────────────────────┐
│  UserService service = new  │  ← 先创建对象
│  service.setUserDao(dao)    │  ← 再注入依赖
└─────────────────────────────┘

Spring的处理策略：
1. 先创建无依赖或依赖已就绪的Bean
2. 再创建有依赖的Bean，注入已创建好的依赖
3. 如果出现循环依赖，通过三级缓存解决
```

### 4.5 三级缓存解决循环依赖


**循环依赖问题**：
```
A依赖B，B依赖A，怎么办？

UserService → UserDao → UserService（死循环）
```

**三级缓存解决方案**：
```
缓存级别                    存储内容                    作用
=========                 =========                 =========
一级缓存（singletonObjects）  完整的Bean对象              提供最终可用的Bean

二级缓存（earlySingletonObjects）  提前暴露的Bean对象   解决循环依赖的中转站

三级缓存（singletonFactories）  Bean工厂对象           生成提前暴露的Bean

解决流程：
1. 创建A对象（半成品，还没注入依赖）
2. 把A放入三级缓存
3. 处理A的依赖，发现需要B
4. 创建B对象，发现需要A
5. 从三级缓存取出A的早期引用，注入给B
6. B创建完成，注入给A
7. A创建完成
```

---

## 5. 🔄 容器生命周期管理


### 5.1 启动钩子


**什么是启动钩子**：容器启动完成后自动执行的逻辑

**方式一：实现ApplicationRunner接口**
```java
@Component
public class MyApplicationRunner implements ApplicationRunner {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("容器启动完成，执行启动任务...");
        // 初始化缓存、预热数据等
    }
}
```

**方式二：实现CommandLineRunner接口**
```java
@Component
public class MyCommandLineRunner implements CommandLineRunner {
    
    @Override
    public void run(String... args) throws Exception {
        System.out.println("容器启动完成，命令行参数：" + Arrays.toString(args));
        // 处理启动参数
    }
}
```

**方式三：监听ContextRefreshedEvent事件**
```java
@Component
public class StartupListener {
    
    @EventListener
    public void onApplicationEvent(ContextRefreshedEvent event) {
        System.out.println("容器刷新完成！");
        // 执行启动后的初始化工作
    }
}
```

### 5.2 关闭钩子


**什么是关闭钩子**：容器关闭前自动执行的清理逻辑

**注册关闭钩子**：
```java
public static void main(String[] args) {
    ConfigurableApplicationContext context = 
        SpringApplication.run(Application.class, args);
    
    // 注册JVM关闭钩子
    context.registerShutdownHook();
    
    // 当JVM退出时，会自动调用context.close()
}
```

**Bean销毁回调**：
```java
@Component
public class DatabaseConnection {
    
    private Connection connection;
    
    @PostConstruct
    public void init() {
        // 初始化连接
        connection = createConnection();
    }
    
    @PreDestroy  // 容器关闭时自动调用
    public void destroy() {
        if (connection != null) {
            connection.close();
            System.out.println("数据库连接已关闭");
        }
    }
}
```

### 5.3 容器完整生命周期


```
Spring容器生命周期全景图：

启动阶段 ════════════════════════════════════════════
  ↓
【1】创建容器对象
  new AnnotationConfigApplicationContext()
  ↓
【2】加载配置、扫描Bean
  读取配置类、扫描组件
  ↓
【3】执行refresh()方法
  - 准备BeanFactory
  - 加载Bean定义
  - 创建Bean实例
  - 依赖注入
  ↓
【4】发布启动完成事件
  ContextRefreshedEvent
  ↓
【5】执行启动钩子
  ApplicationRunner、CommandLineRunner
  ↓
运行阶段 ════════════════════════════════════════════
  容器就绪，应用程序正常运行
  Bean可以通过getBean()获取使用
  ↓
关闭阶段 ════════════════════════════════════════════
  ↓
【6】触发关闭（手动调用close()或JVM退出）
  ↓
【7】发布关闭事件
  ContextClosedEvent
  ↓
【8】销毁Bean
  - 调用@PreDestroy方法
  - 调用destroy()方法
  - 关闭资源
  ↓
【9】容器销毁完成
```

### 5.4 优雅关闭实践


```java
@SpringBootApplication
public class Application {
    
    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(Application.class, args);
        
        // 注册关闭钩子，确保优雅关闭
        context.registerShutdownHook();
        
        // 也可以通过Runtime注册
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            System.out.println("应用即将关闭，执行清理工作...");
            context.close();
        }));
    }
}
```

**关闭时会发生什么**：
- ✅ 停止接收新请求
- ✅ 等待正在处理的请求完成
- ✅ 调用所有Bean的销毁方法
- ✅ 关闭线程池、数据库连接等资源
- ✅ 发布关闭事件通知监听器

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 容器启动 = 读配置 + 创建Bean + 注入依赖
🔸 Bean定义 = Bean的配方，包含类名、依赖、作用域等信息
🔸 refresh方法 = 容器启动的总指挥，12个步骤完成容器初始化
🔸 Bean实例化 = 创建对象 + 注入依赖 + 初始化
🔸 三级缓存 = 解决循环依赖的核心机制
🔸 启动钩子 = 容器启动后执行的任务
🔸 关闭钩子 = 容器关闭前的清理工作
```

### 6.2 关键理解要点


**🔹 Bean定义加载 ≠ Bean创建**
```
误区：以为读取配置就创建了Bean
真相：只是把"菜谱"记录下来，还没开始做菜

加载Bean定义：读取信息，存入Map
创建Bean实例：根据定义，真正new对象
```

**🔹 refresh方法的核心作用**
```
为什么叫refresh（刷新）？
- 可以重复调用，每次都重新初始化
- 销毁旧的Bean，创建新的Bean
- 实现配置的热更新

步骤11最关键：
finishBeanFactoryInitialization()
真正创建所有Bean的地方
```

**🔹 实例化过程的时序**
```
正确的顺序：
1. 实例化（new对象）
2. 属性填充（注入依赖）
3. 初始化（调用init方法）
4. 后置处理（AOP增强）
5. 使用Bean

记忆要点：先有对象（实例化），再填内容（注入），最后初始化
```

### 6.3 实际应用场景


**场景一：应用启动时预加载数据**
```java
@Component
public class DataPreloader implements ApplicationRunner {
    
    @Autowired
    private CacheService cacheService;
    
    @Override
    public void run(ApplicationArguments args) {
        // 容器启动完成后，预加载缓存数据
        cacheService.preloadCache();
    }
}
```

**场景二：资源的优雅关闭**
```java
@Component
public class ResourceManager {
    
    private ExecutorService executor = Executors.newFixedThreadPool(10);
    
    @PreDestroy
    public void cleanup() {
        // 容器关闭时，优雅关闭线程池
        executor.shutdown();
        try {
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }
}
```

**场景三：监控容器启动过程**
```java
@Component
public class StartupMonitor {
    
    @EventListener
    public void handleContextRefresh(ContextRefreshedEvent event) {
        System.out.println("容器刷新完成，耗时：" + getStartupTime() + "ms");
    }
    
    @EventListener
    public void handleContextClosed(ContextClosedEvent event) {
        System.out.println("容器即将关闭，执行清理...");
    }
}
```

### 6.4 常见问题与解决


| 问题 | **原因** | **解决方案** |
|------|---------|------------|
| 启动很慢 | Bean太多，都在启动时创建 | 使用`@Lazy`懒加载，按需创建 |
| 循环依赖报错 | 构造器注入导致无法解决 | 改用字段注入或Setter注入 |
| Bean未初始化 | 在启动钩子中过早使用 | 确保Bean完全初始化后再使用 |
| 资源未释放 | 没注册关闭钩子 | 调用`registerShutdownHook()` |

**核心记忆口诀**：
```
容器启动三步走：读配置、造对象、注依赖
refresh方法是核心，十二步骤要记清
Bean定义先加载，真正创建在十一
启动关闭有钩子，资源管理要优雅
```