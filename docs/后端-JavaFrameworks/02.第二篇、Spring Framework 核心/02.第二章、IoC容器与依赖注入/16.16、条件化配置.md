---
title: 16、条件化配置
---
## 📚 目录

1. [条件化配置是什么](#1-条件化配置是什么)
2. [@Conditional注解详解](#2-conditional注解详解)
3. [自定义条件判断](#3-自定义条件判断)
4. [@Profile环境管理](#4-profile环境管理)
5. [环境切换实战](#5-环境切换实战)
6. [多套Bean配置策略](#6-多套bean配置策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 条件化配置是什么


### 1.1 生活中的类比理解


**想象一个场景**：你开发了一个电商系统，需要在不同环境下运行：

```
开发环境（自己电脑）：
├── 使用内存数据库（H2）→ 方便测试
├── 打印详细日志 → 便于调试
└── 关闭缓存 → 看到最新代码效果

生产环境（正式服务器）：
├── 使用MySQL数据库 → 数据持久化
├── 只记录错误日志 → 减少开销
└── 开启Redis缓存 → 提升性能
```

**问题来了**：怎么让系统自动识别当前环境，加载对应的配置呢？

> 💡 **这就是条件化配置要解决的问题**：根据不同条件，让Spring容器决定是否创建某个Bean，或者选择性地加载配置。

### 1.2 核心概念解释


**条件化配置（Conditional Configuration）**：
- **是什么**：根据特定条件决定Bean是否创建的机制
- **做什么用**：让同一套代码在不同环境下有不同表现
- **解决什么**：避免写多套配置文件，实现配置的智能化

**举个通俗例子**：
```
就像空调的自动模式：
- 检测温度 > 26°C → 开启制冷
- 检测温度 < 18°C → 开启制热
- 检测温度在18-26°C → 待机

Spring的条件化配置也是这个道理：
- 检测到开发环境 → 创建开发用的Bean
- 检测到生产环境 → 创建生产用的Bean
- 检测到某个类存在 → 创建对应的Bean
```

### 1.3 为什么需要条件化配置


**传统方式的问题**：
```java
// 😓 传统做法：写死在代码里
public class DatabaseConfig {
    public DataSource dataSource() {
        // 手动判断环境
        String env = System.getenv("ENV");
        if ("dev".equals(env)) {
            return new H2DataSource();  // 开发用
        } else {
            return new MySQLDataSource();  // 生产用
        }
    }
}
```

**问题在哪**：
- ❌ 代码耦合严重，不灵活
- ❌ 添加新环境要改代码
- ❌ 测试困难，不好模拟环境

**条件化配置的优势**：
- ✅ 配置与代码分离
- ✅ 扩展性强，易于维护
- ✅ 测试友好，环境隔离清晰

---

## 2. 🎯 @Conditional注解详解


### 2.1 @Conditional基本用法


`@Conditional`是Spring条件化配置的**核心注解**，它的作用就是：**满足条件才创建Bean**。

**基本语法**：
```java
@Configuration
public class MyConfig {
    
    // 只有条件满足时，才会创建这个Bean
    @Bean
    @Conditional(MyCondition.class)  // ← 指定判断条件
    public MyService myService() {
        return new MyService();
    }
}
```

> 📝 **理解要点**：
> - `@Conditional`接收一个条件类
> - 条件类实现`Condition`接口
> - Spring会调用条件类判断是否满足
> - 满足→创建Bean，不满足→跳过

### 2.2 工作流程图示


```
Spring容器启动
    ↓
扫描到@Bean方法
    ↓
发现@Conditional注解
    ↓
调用指定的Condition类
    ↓
┌─────────────────────┐
│ matches()方法返回值？│
└─────────────────────┘
    ↙          ↘
  true        false
    ↓            ↓
创建Bean      跳过Bean
    ↓            ↓
注册到容器    不注册
```

### 2.3 Spring内置条件注解


Spring提供了很多现成的条件注解，开箱即用：

| 注解 | **含义** | **使用场景** |
|------|---------|------------|
| `@ConditionalOnClass` | 类路径存在某个类 | 当引入了某个jar包时生效 |
| `@ConditionalOnMissingClass` | 类路径不存在某个类 | 防止重复配置 |
| `@ConditionalOnBean` | 容器中存在某个Bean | 依赖其他Bean存在 |
| `@ConditionalOnMissingBean` | 容器中不存在某个Bean | 提供默认实现 |
| `@ConditionalOnProperty` | 配置文件属性匹配 | 根据配置开关功能 |

**实战示例**：
```java
@Configuration
public class CacheConfig {
    
    // 当Redis的jar包存在时，才创建Redis缓存
    @Bean
    @ConditionalOnClass(name = "redis.clients.jedis.Jedis")
    public CacheManager redisCacheManager() {
        return new RedisCacheManager();
    }
    
    // 当Redis不存在时，使用简单的Map缓存
    @Bean
    @ConditionalOnMissingClass("redis.clients.jedis.Jedis")
    public CacheManager simpleCacheManager() {
        return new SimpleCacheManager();
    }
}
```

> 💡 **这样的好处**：
> - 引入Redis依赖 → 自动用Redis缓存
> - 不引入Redis → 自动降级到简单缓存
> - 无需改代码，只需加减依赖

---

## 3. 🔧 自定义条件判断


### 3.1 实现Condition接口


当Spring内置的条件注解不够用时，可以自己写判断逻辑。

**核心步骤**：
1. 创建一个类实现`Condition`接口
2. 重写`matches()`方法，返回true/false
3. 用`@Conditional`指定这个条件类

**完整示例**：
```java
// 步骤1：自定义条件类
public class LinuxCondition implements Condition {
    
    @Override
    public boolean matches(ConditionContext context, 
                          AnnotatedTypeMetadata metadata) {
        // 获取环境信息
        Environment env = context.getEnvironment();
        
        // 判断操作系统
        String osName = env.getProperty("os.name");
        
        // 如果是Linux系统，返回true
        return osName != null && osName.toLowerCase().contains("linux");
    }
}

// 步骤2：使用条件
@Configuration
public class OsConfig {
    
    @Bean
    @Conditional(LinuxCondition.class)
    public FileService linuxFileService() {
        return new LinuxFileService();  // Linux专用
    }
    
    @Bean
    @Conditional(WindowsCondition.class)
    public FileService windowsFileService() {
        return new WindowsFileService();  // Windows专用
    }
}
```

### 3.2 ConditionContext详解


`matches()`方法的第一个参数`ConditionContext`很有用，可以获取很多信息：

```java
public boolean matches(ConditionContext context, ...) {
    
    // 1. 获取Bean定义注册器（可以查询已注册的Bean）
    BeanDefinitionRegistry registry = context.getRegistry();
    boolean hasBean = registry.containsBeanDefinition("myBean");
    
    // 2. 获取Bean工厂（可以查询Bean实例）
    ConfigurableListableBeanFactory factory = context.getBeanFactory();
    
    // 3. 获取环境信息（系统属性、环境变量、配置文件）
    Environment env = context.getEnvironment();
    String dbUrl = env.getProperty("spring.datasource.url");
    
    // 4. 获取资源加载器（可以加载类路径资源）
    ResourceLoader loader = context.getResourceLoader();
    
    // 5. 获取类加载器（可以检查类是否存在）
    ClassLoader classLoader = context.getClassLoader();
    
    // 基于这些信息做判断
    return dbUrl != null && dbUrl.contains("mysql");
}
```

> 📝 **理解要点**：
> - `ConditionContext`就是Spring容器的"体检报告"
> - 包含了环境、Bean、配置等所有信息
> - 基于这些信息可以做各种判断

### 3.3 实战案例：数据库类型判断


**需求**：根据配置的数据库类型，创建不同的数据源

```java
// 判断是否配置了MySQL
public class MySQLCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, 
                          AnnotatedTypeMetadata metadata) {
        String driver = context.getEnvironment()
            .getProperty("spring.datasource.driver-class-name");
        
        return driver != null && driver.contains("mysql");
    }
}

// 判断是否配置了PostgreSQL
public class PostgreSQLCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, 
                          AnnotatedTypeMetadata metadata) {
        String driver = context.getEnvironment()
            .getProperty("spring.datasource.driver-class-name");
        
        return driver != null && driver.contains("postgresql");
    }
}

// 配置类
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Conditional(MySQLCondition.class)
    public DataSource mysqlDataSource() {
        // MySQL专用配置
        HikariConfig config = new HikariConfig();
        config.setMaximumPoolSize(20);
        return new HikariDataSource(config);
    }
    
    @Bean
    @Conditional(PostgreSQLCondition.class)
    public DataSource postgresDataSource() {
        // PostgreSQL专用配置
        HikariConfig config = new HikariConfig();
        config.setMaximumPoolSize(10);
        return new HikariDataSource(config);
    }
}
```

**效果**：
```yaml
# application.yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver  # ← 自动用MySQL配置
    # driver-class-name: org.postgresql.Driver   # ← 改成这个自动用PostgreSQL
```

---

## 4. 🌍 @Profile环境管理


### 4.1 @Profile是什么


`@Profile`是Spring专门用来**区分环境**的注解，比自己写条件判断更简单。

**通俗理解**：
```
就像手机的"情景模式"：
- 工作模式 → 振动、允许部分来电
- 休息模式 → 静音、拒绝所有来电
- 户外模式 → 铃声最大、屏幕最亮

@Profile就是给Bean配置"情景模式"：
- @Profile("dev") → 开发环境才激活
- @Profile("prod") → 生产环境才激活
- @Profile("test") → 测试环境才激活
```

### 4.2 @Profile基本用法


**方式一：标注在类上**
```java
// 整个配置类只在dev环境生效
@Configuration
@Profile("dev")
public class DevConfig {
    
    @Bean
    public DataSource devDataSource() {
        return new H2DataSource();  // 内存数据库
    }
    
    @Bean
    public Logger devLogger() {
        return new DetailLogger();  // 详细日志
    }
}
```

**方式二：标注在方法上**
```java
@Configuration
public class DataSourceConfig {
    
    // 开发环境的数据源
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new H2DataSource();
    }
    
    // 生产环境的数据源
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        return new MySQLDataSource();
    }
}
```

### 4.3 Profile激活方式


**激活Profile有多种方式**，灵活选择：

**方式1：配置文件激活**
```yaml
# application.yml
spring:
  profiles:
    active: dev  # ← 激活dev环境
```

**方式2：启动参数激活**
```bash
# 命令行启动
java -jar myapp.jar --spring.profiles.active=prod

# IDEA中配置VM options
-Dspring.profiles.active=prod
```

**方式3：代码激活（不推荐，测试时用）**
```java
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(App.class);
    app.setAdditionalProfiles("dev");  // 代码设置
    app.run(args);
}
```

**方式4：环境变量激活**
```bash
# Linux/Mac
export SPRING_PROFILES_ACTIVE=prod

# Windows
set SPRING_PROFILES_ACTIVE=prod
```

### 4.4 多Profile组合使用


**可以同时激活多个Profile**：
```yaml
spring:
  profiles:
    active: dev,local,debug  # 激活3个
```

**逻辑运算**：
```java
// dev 或 test 环境生效
@Profile({"dev", "test"})

// 不是 prod 环境就生效
@Profile("!prod")

// dev 且 local 环境生效（Spring 5.1+）
@Profile("dev & local")
```

---

## 5. 🔄 环境切换实战


### 5.1 典型三环境配置


**企业常见做法：开发、测试、生产三环境分离**

```
项目结构：
src/main/resources/
├── application.yml           # 公共配置
├── application-dev.yml       # 开发环境
├── application-test.yml      # 测试环境
└── application-prod.yml      # 生产环境
```

**公共配置**（`application.yml`）：
```yaml
spring:
  application:
    name: my-app
  profiles:
    active: @profileActive@  # Maven打包时替换

# 所有环境共用的配置
logging:
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

**开发环境**（`application-dev.yml`）：
```yaml
server:
  port: 8080

spring:
  datasource:
    driver-class-name: org.h2.Driver
    url: jdbc:h2:mem:testdb
    username: sa
    password: 

logging:
  level:
    root: DEBUG  # 开发环境打印所有日志
```

**生产环境**（`application-prod.yml`）：
```yaml
server:
  port: 80

spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://prod-db:3306/mydb
    username: ${DB_USER}      # 从环境变量读取
    password: ${DB_PASSWORD}

logging:
  level:
    root: WARN  # 生产只记录警告和错误
```

### 5.2 Bean级别的环境配置


**不同环境使用不同的实现类**：
```java
// 定义接口
public interface PaymentService {
    void pay(BigDecimal amount);
}

// 开发环境：模拟支付
@Service
@Profile("dev")
public class MockPaymentService implements PaymentService {
    @Override
    public void pay(BigDecimal amount) {
        System.out.println("模拟支付：" + amount + "元");
        // 不真实扣款
    }
}

// 生产环境：真实支付
@Service
@Profile("prod")
public class RealPaymentService implements PaymentService {
    @Override
    public void pay(BigDecimal amount) {
        // 调用真实支付接口
        AlipayClient.transfer(amount);
    }
}
```

**使用时无需关心环境**：
```java
@RestController
public class OrderController {
    
    @Autowired
    private PaymentService paymentService;  // 自动注入对应环境的实现
    
    @PostMapping("/pay")
    public void pay(@RequestBody Order order) {
        paymentService.pay(order.getAmount());
        // dev环境 → 模拟支付
        // prod环境 → 真实支付
    }
}
```

### 5.3 环境切换流程图


```
应用启动
    ↓
读取spring.profiles.active配置
    ↓
确定当前激活的Profile
    ↓
┌──────────────────────────┐
│  扫描所有@Profile注解    │
└──────────────────────────┘
    ↓
┌──────────────────────────────────┐
│ 判断Profile是否与激活的Profile匹配│
└──────────────────────────────────┘
    ↙                          ↘
  匹配                        不匹配
    ↓                            ↓
创建对应的Bean              跳过Bean创建
    ↓                            ↓
加载对应的配置文件          忽略配置文件
    ↓
应用正常运行
```

---

## 6. 🎯 多套Bean配置策略


### 6.1 场景分析


**实际开发中常见的配置需求**：

```
场景1：数据源配置
├── 开发环境 → H2内存数据库
├── 测试环境 → MySQL测试库
└── 生产环境 → MySQL主从集群

场景2：缓存配置
├── 开发环境 → 简单Map缓存
├── 测试环境 → Redis单机
└── 生产环境 → Redis集群

场景3：消息队列
├── 开发环境 → 内存队列
├── 测试环境 → RabbitMQ单机
└── 生产环境 → Kafka集群
```

### 6.2 策略一：Profile配置分离


**适用场景**：不同环境配置差异大

```java
// 开发环境配置
@Configuration
@Profile("dev")
public class DevConfig {
    
    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
            .driverClassName("org.h2.Driver")
            .url("jdbc:h2:mem:testdb")
            .build();
    }
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager();
    }
}

// 生产环境配置
@Configuration
@Profile("prod")
public class ProdConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://prod-db/mydb");
        config.setMaximumPoolSize(50);
        return new HikariDataSource(config);
    }
    
    @Bean
    public CacheManager cacheManager() {
        RedisCacheConfiguration config = RedisCacheConfiguration
            .defaultCacheConfig()
            .entryTtl(Duration.ofHours(1));
        return RedisCacheManager.builder(redisConnectionFactory())
            .cacheDefaults(config)
            .build();
    }
}
```

> ✅ **优点**：配置清晰，环境隔离彻底
> ❌ **缺点**：有重复代码，维护成本高

### 6.3 策略二：属性注入 + 条件判断


**适用场景**：配置差异小，只是参数不同

```java
@Configuration
public class DataSourceConfig {
    
    @Value("${db.url}")
    private String url;
    
    @Value("${db.pool.size:10}")  // 默认值10
    private int poolSize;
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(url);
        config.setMaximumPoolSize(poolSize);
        return new HikariDataSource(config);
    }
}
```

**配置文件**：
```yaml
# application-dev.yml
db:
  url: jdbc:h2:mem:testdb
  pool:
    size: 5

# application-prod.yml
db:
  url: jdbc:mysql://prod-db/mydb
  pool:
    size: 50
```

> ✅ **优点**：代码复用，只需配置文件不同
> ❌ **缺点**：复杂逻辑不好处理

### 6.4 策略三：条件注解组合


**适用场景**：基于功能开关，而非环境

```java
@Configuration
public class FeatureConfig {
    
    // 当配置了Redis才创建
    @Bean
    @ConditionalOnProperty(name = "feature.cache.enabled", havingValue = "true")
    public CacheManager cacheManager() {
        return new RedisCacheManager(...);
    }
    
    // Redis不可用时的降级方案
    @Bean
    @ConditionalOnMissingBean(CacheManager.class)
    public CacheManager defaultCacheManager() {
        return new ConcurrentMapCacheManager();
    }
    
    // 当引入了ElasticSearch依赖才创建
    @Bean
    @ConditionalOnClass(name = "org.elasticsearch.client.RestHighLevelClient")
    public SearchService elasticSearchService() {
        return new ElasticSearchService();
    }
}
```

**配置开关**：
```yaml
feature:
  cache:
    enabled: true  # 开启缓存功能
  search:
    enabled: false  # 关闭搜索功能
```

> ✅ **优点**：灵活，可随时开关功能
> ❌ **缺点**：配置项多了容易混乱

### 6.5 最佳实践建议


**组合使用多种策略**：

```
📋 推荐配置层次：

第1层：Profile环境隔离
├── dev   → 开发环境基础配置
├── test  → 测试环境基础配置
└── prod  → 生产环境基础配置

第2层：功能开关（ConditionalOnProperty）
├── feature.cache  → 缓存功能开关
├── feature.mq     → 消息队列开关
└── feature.search → 搜索功能开关

第3层：依赖检测（ConditionalOnClass）
├── 有Redis → 用Redis缓存
├── 无Redis → 用Map缓存
└── 自动降级
```

**配置示例**：
```java
@Configuration
@Profile("prod")  // 第1层：只在生产环境生效
public class ProdCacheConfig {
    
    @Bean
    @ConditionalOnProperty(  // 第2层：功能开关
        name = "feature.cache.enabled", 
        havingValue = "true"
    )
    @ConditionalOnClass(  // 第3层：依赖检测
        name = "redis.clients.jedis.Jedis"
    )
    public CacheManager redisCacheManager() {
        return new RedisCacheManager(...);
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 关键概念回顾


```
🔸 条件化配置：根据条件决定Bean是否创建
🔸 @Conditional：核心注解，指定判断条件
🔸 Condition接口：自定义条件的实现方式
🔸 @Profile：专门用于环境区分
🔸 环境切换：通过配置文件或启动参数激活
🔸 多套配置：不同策略适用不同场景
```

### 7.2 使用场景速查


| 场景 | **推荐方案** | **示例** |
|------|------------|---------|
| 开发/测试/生产环境切换 | `@Profile` | `@Profile("dev")` |
| 根据配置开关功能 | `@ConditionalOnProperty` | 缓存开关、限流开关 |
| 根据依赖是否存在 | `@ConditionalOnClass` | 有Redis用Redis，无则降级 |
| 防止Bean重复创建 | `@ConditionalOnMissingBean` | 提供默认实现 |
| 复杂自定义判断 | 自定义`Condition` | 多条件组合判断 |

### 7.3 实战要点


**✅ 推荐做法**：
- Profile用于环境隔离，不要用于功能开关
- 功能开关用`@ConditionalOnProperty`
- 自动配置用`@ConditionalOnClass`
- 提供默认值用`@ConditionalOnMissingBean`
- 配置文件分层：公共配置 + 环境专属配置

**❌ 避免踩坑**：
- 不要Profile和Conditional混用太多，会很乱
- 不要在条件判断中写复杂逻辑
- 不要忘记提供默认配置（fallback）
- 不要在生产环境用代码激活Profile

### 7.4 调试技巧


**查看哪些Bean被创建了**：
```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(Application.class, args);
        
        // 打印所有Bean名称
        String[] beans = context.getBeanDefinitionNames();
        for (String bean : beans) {
            System.out.println(bean);
        }
    }
}
```

**查看Profile激活情况**：
```yaml
# application.yml
logging:
  level:
    org.springframework.boot.autoconfigure: DEBUG
```

启动日志会显示：
```
Activating profiles: dev
Conditional evaluation report:
  Positive matches:
    - DevDataSource matched (profile dev is active)
  Negative matches:
    - ProdDataSource did not match (profile prod is not active)
```

### 7.5 核心记忆口诀


> 💡 **条件配置三板斧**：
> - **环境隔离用Profile** → 开发测试生产分
> - **功能开关用Property** → 配置文件控开关
> - **依赖检测用OnClass** → 有啥用啥自适应

---

🎯 **小结**：条件化配置让Spring应用更智能、更灵活，掌握好这些技巧，能大大简化配置管理工作！