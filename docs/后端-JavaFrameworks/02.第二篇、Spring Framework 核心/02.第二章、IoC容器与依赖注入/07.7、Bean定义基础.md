---
title: 7、Bean定义基础
---
## 📚 目录

1. [什么是Bean定义](#1-什么是Bean定义)
2. [BeanDefinition元数据](#2-BeanDefinition元数据)
3. [Bean的基本属性配置](#3-Bean的基本属性配置)
4. [Bean作用域详解](#4-Bean作用域详解)
5. [Bean的延迟初始化](#5-Bean的延迟初始化)
6. [Primary主要Bean机制](#6-Primary主要Bean机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌱 什么是Bean定义


### 1.1 Bean的本质理解


**通俗解释**：Bean就是Spring容器管理的对象。想象Spring容器是一个"对象工厂"，Bean就是这个工厂生产和管理的"产品"。

```
传统Java开发：                Spring开发：
你手动new对象                  Spring帮你创建对象
你自己管理对象生命周期          Spring管理对象的一切
你自己处理对象依赖              Spring自动注入依赖

UserService service = new UserService();    →    @Autowired UserService service;
```

**核心概念**：
- **Bean** = Spring容器中的对象
- **Bean定义** = 告诉Spring如何创建和管理这个对象的"说明书"
- **容器** = 负责创建、配置、管理Bean的"工厂"

### 1.2 为什么需要Bean定义


**实际问题场景**：
```
问题1：对象创建复杂
- 需要设置很多参数
- 需要调用多个初始化方法
- 需要处理依赖关系

问题2：对象生命周期管理
- 什么时候创建？
- 创建几个实例？
- 什么时候销毁？

Bean定义的作用：
✅ 统一描述对象的创建方式
✅ 集中管理对象的配置信息
✅ 让Spring自动处理复杂的创建过程
```

### 1.3 Bean定义的三种方式对比


| 配置方式 | **描述** | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|---------|-------------|
| 🔧 **XML配置** | `在XML文件中定义Bean` | `配置集中，一目了然` | `配置繁琐，不够灵活` | `传统项目，配置较少时` |
| 🎯 **注解配置** | `@Component等注解` | `简洁方便，开发快` | `配置分散在代码中` | `现代开发，推荐使用` |
| ⚙️ **Java配置** | `@Bean方法配置` | `类型安全，易重构` | `需要编写配置类` | `复杂Bean，需要逻辑时` |

---

## 2. 📋 BeanDefinition元数据


### 2.1 什么是BeanDefinition


**通俗理解**：BeanDefinition就像是Bean的"身份证"或"档案"，记录了这个Bean的所有重要信息。

```
Bean的"身份证"包含：
┌─────────────────────────┐
│  BeanDefinition元数据    │
├─────────────────────────┤
│ 📛 Bean名称(id/name)     │
│ 🏷️  Bean类型(class)      │
│ 🔄 作用域(scope)         │
│ 🔗 依赖关系(dependencies)│
│ ⚙️  初始化方法           │
│ 🗑️  销毁方法             │
│ ⏰ 是否延迟加载          │
│ 🎯 是否Primary           │
└─────────────────────────┘
```

### 2.2 元数据的核心信息


**🔸 Class类全限定名**
```
含义：告诉Spring要创建哪个类的对象
示例：com.example.service.UserService
作用：Spring通过反射创建对象

通俗理解：就像告诉工厂"要生产什么产品"
```

**🔸 Bean的行为特征**
- **作用域**：这个Bean是单例还是每次都新建？
- **生命周期回调**：创建后要做什么？销毁前要做什么？
- **依赖关系**：这个Bean需要哪些其他Bean？

**🔸 配置元数据示例**

XML方式：
```xml
<!-- Bean定义的XML元数据 -->
<bean id="userService" 
      class="com.example.service.UserService"
      scope="singleton"
      lazy-init="true"
      primary="true">
    <property name="userDao" ref="userDao"/>
</bean>
```

注解方式：
```java
@Component("userService")  // Bean名称
@Scope("singleton")        // 作用域
@Lazy                      // 延迟初始化
@Primary                   // 主要Bean
public class UserService {
    @Autowired
    private UserDao userDao;  // 依赖注入
}
```

### 2.3 元数据的内部存储


**Spring内部处理流程**：
```
1. 读取配置
   ↓
2. 解析成BeanDefinition对象
   ↓
3. 注册到BeanDefinitionRegistry
   ↓
4. 根据BeanDefinition创建Bean实例
```

**BeanDefinition核心属性**：
- `beanClassName` - 类的全限定名
- `scope` - 作用域
- `lazyInit` - 是否延迟初始化
- `primary` - 是否为主Bean
- `dependsOn` - 依赖的其他Bean名称
- `initMethodName` - 初始化方法名
- `destroyMethodName` - 销毁方法名

---

## 3. 🔧 Bean的基本属性配置


### 3.1 id与name属性详解


**🔸 id属性**
```
作用：Bean的唯一标识符
特点：
- 必须在容器中唯一
- 遵循XML ID命名规则（字母开头，不能有特殊字符）
- 如果不指定，Spring自动生成

示例：
<bean id="userService" class="com.example.UserService"/>

通俗理解：就像人的身份证号，全局唯一
```

**🔸 name属性**
```
作用：Bean的别名，可以有多个
特点：
- 可以包含特殊字符
- 多个名称用逗号、分号或空格分隔
- 更灵活的命名方式

示例：
<bean id="userService" 
      name="userSvc,user-service,/userService" 
      class="com.example.UserService"/>

通俗理解：就像人的外号，可以有好几个
```

**id与name的区别**：

| 特性 | **id** | **name** |
|------|--------|----------|
| 数量 | `只能有1个` | `可以有多个` |
| 命名规则 | `严格限制` | `更灵活` |
| 用途 | `主要标识` | `别名` |

### 3.2 class属性


**基本用法**：
```
作用：指定Bean的Java类
格式：类的全限定名（包名.类名）

示例：
class="com.example.service.UserService"

Spring做的事：
1. 通过反射Class.forName()加载类
2. 调用构造方法创建对象
3. 管理对象的生命周期
```

**特殊情况**：

**🔹 工厂方法创建Bean**
```xml
<!-- 静态工厂方法 -->
<bean id="userService" 
      class="com.example.ServiceFactory"
      factory-method="createUserService"/>

<!-- 实例工厂方法 -->
<bean id="serviceFactory" class="com.example.ServiceFactory"/>
<bean id="userService"
      factory-bean="serviceFactory"
      factory-method="createService"/>
```

**🔹 抽象Bean定义**
```xml
<!-- 抽象Bean，不会实例化，用于继承 -->
<bean id="abstractService" 
      class="com.example.BaseService"
      abstract="true">
    <property name="timeout" value="3000"/>
</bean>

<!-- 子Bean继承配置 -->
<bean id="userService"
      class="com.example.UserService"
      parent="abstractService"/>
```

### 3.3 Bean属性注入


**三种注入方式对比**：

```
注入方式对比：

1️⃣ 构造器注入（推荐）
优点：依赖明确，对象不可变，保证必需依赖
缺点：参数过多时不够灵活

2️⃣ Setter注入
优点：灵活，可选依赖
缺点：对象可变，可能遗漏必需依赖

3️⃣ 字段注入（不推荐）
优点：代码简洁
缺点：难以测试，违反封装原则
```

**构造器注入示例**：
```java
@Service
public class UserService {
    private final UserDao userDao;  // final保证不可变
    
    // 构造器注入
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

XML配置：
```xml
<bean id="userService" class="com.example.UserService">
    <constructor-arg ref="userDao"/>
</bean>
```

**Setter注入示例**：
```java
@Service
public class OrderService {
    private EmailService emailService;
    
    @Autowired  // 可选依赖
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

---

## 4. 🔄 Bean作用域详解


### 4.1 什么是作用域


**通俗理解**：作用域决定了Spring容器要创建多少个Bean实例，以及这些实例的生命周期。

```
生活类比：

singleton（单例）：
就像一个公司只有一个CEO，所有人共享这个对象

prototype（原型）：
就像复印机，每次请求都给你一个新的副本

request（请求）：
就像餐厅的订单，每个请求一个独立的对象

session（会话）：
就像用户的购物车，每个会话一个独立对象
```

### 4.2 六种作用域类型


**🔸 singleton - 单例作用域（默认）**

```
特点：
✅ 容器中只有一个Bean实例
✅ 所有请求共享同一个对象
✅ 容器启动时创建（非懒加载）
✅ 容器关闭时销毁

适用场景：
- 无状态的Service层
- 无状态的DAO层
- 工具类Bean

注意事项：
⚠️ 不要在单例Bean中存储状态信息
⚠️ 线程安全问题需要自己处理
```

配置方式：
```java
@Component
@Scope("singleton")  // 或 @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
public class UserService {
    // 无状态服务
}
```

**🔸 prototype - 原型作用域**

```
特点：
✅ 每次请求创建新实例
✅ 不共享对象
✅ Spring不管理完整生命周期
✅ 不会自动销毁

适用场景：
- 有状态的对象
- 需要隔离的对象
- 临时使用的对象

注意事项：
⚠️ 需要自己管理销毁
⚠️ 频繁创建可能影响性能
```

配置方式：
```java
@Component
@Scope("prototype")
public class OrderForm {
    private String orderId;
    private Date createTime;
    // 有状态对象
}
```

**🔸 Web相关作用域**

| 作用域 | **生命周期** | **应用场景** |
|--------|------------|-------------|
| `request` | `一次HTTP请求` | `请求参数封装对象` |
| `session` | `一次HTTP会话` | `用户会话信息` |
| `application` | `整个ServletContext` | `全局配置信息` |
| `websocket` | `一次WebSocket会话` | `WebSocket数据` |

### 4.3 作用域配置实战


**XML配置**：
```xml
<!-- 单例作用域 -->
<bean id="userService" class="com.example.UserService" scope="singleton"/>

<!-- 原型作用域 -->
<bean id="orderForm" class="com.example.OrderForm" scope="prototype"/>

<!-- Web作用域 -->
<bean id="loginBean" class="com.example.LoginBean" scope="session"/>
```

**注解配置**：
```java
// 使用常量
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)

// 使用字符串
@Scope("request")

// Web作用域
@Scope(value = WebApplicationContext.SCOPE_SESSION, 
       proxyMode = ScopedProxyMode.TARGET_CLASS)
```

### 4.4 作用域混用问题


**问题场景**：
```
单例Bean注入原型Bean会失效！

原因：
单例Bean只创建一次
  ↓
注入的原型Bean也只创建一次
  ↓
原型Bean变成了"假单例"
```

**解决方案**：

**方案1：方法注入**
```java
@Component
public abstract class SingletonBean {
    
    // 每次调用都获取新的原型Bean
    @Lookup
    protected abstract PrototypeBean getPrototypeBean();
    
    public void doSomething() {
        PrototypeBean bean = getPrototypeBean();  // 新实例
        bean.execute();
    }
}
```

**方案2：ApplicationContext**
```java
@Component
public class SingletonBean {
    @Autowired
    private ApplicationContext context;
    
    public void doSomething() {
        // 手动获取新实例
        PrototypeBean bean = context.getBean(PrototypeBean.class);
        bean.execute();
    }
}
```

**方案3：代理模式**
```java
@Component
@Scope(value = "prototype", 
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class PrototypeBean {
    // Spring会创建代理，每次调用都返回新实例
}
```

---

## 5. ⏰ Bean的延迟初始化


### 5.1 什么是延迟初始化


**通俗解释**：延迟初始化就是"用到时再创建"，而不是容器启动时就创建。

```
正常模式（立即初始化）：         延迟模式（lazy-init）：
Spring容器启动                   Spring容器启动
   ↓                                ↓
创建所有单例Bean                  不创建Bean
   ↓                                ↓
应用就绪                          应用就绪
                                    ↓
                                 第一次使用Bean
                                    ↓
                                 创建Bean实例
```

### 5.2 延迟初始化的配置


**XML配置**：
```xml
<!-- 单个Bean延迟 -->
<bean id="userService" 
      class="com.example.UserService" 
      lazy-init="true"/>

<!-- 全局延迟配置 -->
<beans default-lazy-init="true">
    <bean id="service1" class="com.example.Service1"/>
    <bean id="service2" class="com.example.Service2"/>
</beans>
```

**注解配置**：
```java
// 单个Bean延迟
@Component
@Lazy
public class UserService {
    public UserService() {
        System.out.println("UserService创建了");
    }
}

// 配置类全局延迟
@Configuration
@Lazy
public class AppConfig {
    @Bean
    public ServiceA serviceA() { return new ServiceA(); }
    
    @Bean
    public ServiceB serviceB() { return new ServiceB(); }
}
```

### 5.3 延迟初始化的优缺点


**✅ 优点**：
```
1. 加快启动速度
   - 容器启动时不创建Bean
   - 减少启动时间
   
2. 节省内存
   - 不用的Bean不占用内存
   - 按需加载
   
3. 避免不必要的初始化
   - 某些Bean可能永远不会用到
```

**❌ 缺点**：
```
1. 延迟发现错误
   - 配置错误在首次使用时才暴露
   - 不利于早期发现问题
   
2. 首次访问慢
   - 第一次使用时需要创建Bean
   - 可能影响用户体验
   
3. 依赖关系复杂
   - 非延迟Bean依赖延迟Bean会失效
```

### 5.4 延迟初始化的注意事项


**🔸 依赖关系影响**
```java
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;  // 即使ServiceB是lazy，也会立即创建
}

@Component
@Lazy
public class ServiceB {
    // ServiceA依赖它，所以会立即初始化
}

⚠️ 非延迟Bean依赖延迟Bean，延迟会失效！
```

**🔸 最佳实践**
```
✅ 适合延迟的场景：
- 不常用的功能模块
- 占用资源多的Bean
- 条件性使用的Bean

❌ 不适合延迟的场景：
- 核心业务Bean
- 需要预热的Bean（如连接池）
- 启动时需要初始化的Bean
```

---

## 6. 🎯 Primary主要Bean机制


### 6.1 什么是Primary


**问题场景**：
```
同一个接口有多个实现类：

UserService接口
   ├── UserServiceImpl
   ├── CachedUserServiceImpl
   └── MockUserServiceImpl

问题：@Autowired时Spring不知道注入哪个！

错误提示：
No qualifying bean of type 'UserService' available: 
expected single matching bean but found 3
```

**Primary的作用**：
```
@Primary：标记一个Bean为"首选Bean"
当有多个候选Bean时，优先选择标记了@Primary的Bean

就像：多个候选人中，有一个是"默认推荐"
```

### 6.2 Primary配置方式


**注解配置**：
```java
public interface UserService {
    void saveUser(User user);
}

@Service
@Primary  // 标记为主要Bean
public class UserServiceImpl implements UserService {
    @Override
    public void saveUser(User user) {
        // 主要实现
    }
}

@Service
public class CachedUserServiceImpl implements UserService {
    @Override
    public void saveUser(User user) {
        // 缓存实现
    }
}

// 注入时会选择UserServiceImpl
@Controller
public class UserController {
    @Autowired
    private UserService userService;  // 自动注入UserServiceImpl
}
```

**XML配置**：
```xml
<!-- 主要Bean -->
<bean id="userServiceImpl" 
      class="com.example.UserServiceImpl" 
      primary="true"/>

<!-- 备选Bean -->
<bean id="cachedUserServiceImpl" 
      class="com.example.CachedUserServiceImpl"/>
```

**Java配置**：
```java
@Configuration
public class ServiceConfig {
    
    @Bean
    @Primary  // 主要Bean
    public UserService userServiceImpl() {
        return new UserServiceImpl();
    }
    
    @Bean
    public UserService cachedUserServiceImpl() {
        return new CachedUserServiceImpl();
    }
}
```

### 6.3 Primary的优先级规则


**优先级顺序**：
```
1. @Qualifier明确指定 > @Primary
2. @Primary > 普通Bean
3. 多个@Primary会报错

示例：
```

```java
@Service
@Primary
public class ServiceA implements MyService { }

@Service  
public class ServiceB implements MyService { }

// 情况1：使用Primary
@Autowired
private MyService service;  // 注入ServiceA

// 情况2：Qualifier覆盖Primary
@Autowired
@Qualifier("serviceB")
private MyService service;  // 注入ServiceB，忽略Primary
```

### 6.4 Primary使用场景


**✅ 适用场景**：
```
1. 默认实现模式
   - 有一个主要实现
   - 其他是特殊场景实现
   
2. 降级方案
   - Primary是正常实现
   - 其他是降级/模拟实现
   
3. 版本切换
   - Primary是新版本
   - 保留旧版本兼容
```

**实战示例**：
```java
// 支付服务接口
public interface PaymentService {
    void pay(Order order);
}

// 微信支付（主要）
@Service
@Primary
public class WeChatPayService implements PaymentService {
    @Override
    public void pay(Order order) {
        // 微信支付逻辑
    }
}

// 支付宝支付（备选）
@Service
public class AliPayService implements PaymentService {
    @Override
    public void pay(Order order) {
        // 支付宝支付逻辑
    }
}

// 模拟支付（测试用）
@Service
@Profile("test")
public class MockPayService implements PaymentService {
    @Override
    public void pay(Order order) {
        // 模拟支付
    }
}

// 业务代码
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;  // 自动注入WeChatPayService
    
    public void processOrder(Order order) {
        paymentService.pay(order);
    }
}
```

### 6.5 Primary vs Qualifier


**对比选择**：

| 特性 | **@Primary** | **@Qualifier** |
|------|-------------|---------------|
| 作用范围 | `全局默认` | `局部指定` |
| 配置位置 | `Bean定义处` | `注入点` |
| 灵活性 | `低（一个主Bean）` | `高（任意选择）` |
| 使用场景 | `有明确主实现` | `需要灵活切换` |

**组合使用**：
```java
@Service
@Primary
public class DefaultEmailService implements EmailService { }

@Service
@Qualifier("sms")
public class SmsService implements NotificationService { }

// 默认使用Primary
@Autowired
private EmailService emailService;  // DefaultEmailService

// 明确指定
@Autowired
@Qualifier("sms")
private NotificationService notificationService;  // SmsService
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Bean定义：Spring管理对象的"说明书"
🔸 BeanDefinition：存储Bean元数据的内部对象
🔸 id/name：Bean的标识符，id唯一，name可多个
🔸 class：指定Bean的Java类全限定名
🔸 作用域：控制Bean实例的数量和生命周期
🔸 lazy-init：延迟初始化，用到时再创建
🔸 primary：多个候选Bean时的首选Bean
```

### 7.2 重点理解要点


**🔹 作用域选择原则**
```
使用singleton：
✅ 无状态的Service、DAO层
✅ 工具类、配置类
✅ 共享的对象

使用prototype：
✅ 有状态的对象
✅ 每次需要新实例的对象
✅ 不能共享的对象

作用域混用：
⚠️ 单例注入原型会失效
⚠️ 使用@Lookup或代理解决
```

**🔹 延迟初始化权衡**
```
使用lazy-init的时机：
✅ 不常用的Bean
✅ 启动速度要求高
✅ 节省内存

不使用lazy-init的时机：
✅ 核心业务Bean
✅ 需要预热的Bean（连接池等）
✅ 希望启动时发现错误
```

**🔹 Primary使用策略**
```
何时使用@Primary：
✅ 有明确的主实现
✅ 其他是特殊场景实现
✅ 简化自动注入

何时使用@Qualifier：
✅ 需要灵活切换
✅ 没有明确主实现
✅ 明确知道要注入哪个
```

### 7.3 实际应用建议


**📌 Bean定义最佳实践**
```
1. 推荐使用注解配置
   @Component, @Service, @Repository, @Controller
   
2. id命名规范
   - 类名首字母小写（userService）
   - 见名知意
   
3. 合理选择作用域
   - 默认singleton即可
   - 有状态才用prototype
   
4. 谨慎使用延迟初始化
   - 核心Bean不要lazy
   - 非核心功能可以lazy
   
5. Primary配合Qualifier
   - 设置合理的默认实现
   - 特殊场景用Qualifier指定
```

**📌 常见问题避坑**
```
❌ 避免：单例Bean中有状态字段
✅ 改为：使用ThreadLocal或方法参数

❌ 避免：单例直接注入原型Bean
✅ 改为：使用@Lookup或代理模式

❌ 避免：多个@Primary同一类型
✅ 改为：只保留一个Primary

❌ 避免：核心Bean使用lazy-init
✅ 改为：让它正常初始化，尽早发现问题
```

**核心记忆口诀**：
```
Bean定义三要素：id、class、scope要记清
单例无状态，原型有状态，混用要小心
延迟初始化快启动，核心功能别偷懒
Primary设默认，Qualifier来明辨
```