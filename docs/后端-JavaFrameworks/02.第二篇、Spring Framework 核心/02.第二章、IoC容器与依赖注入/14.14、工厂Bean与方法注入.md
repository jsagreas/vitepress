---
title: 14、工厂Bean与方法注入
---
## 📚 目录

1. [FactoryBean工厂Bean详解](#1-FactoryBean工厂Bean详解)
2. [方法注入机制](#2-方法注入机制)
3. [lookup方法注入](#3-lookup方法注入)
4. [replaced-method方法替换](#4-replaced-method方法替换)
5. [动态代理原理](#5-动态代理原理)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🏭 FactoryBean工厂Bean详解


### 1.1 什么是FactoryBean


**通俗理解**：FactoryBean就像一个"对象工厂"，它不是直接给你一个Bean，而是给你一个"能生产Bean的工厂"

```
普通Bean：就像买成品，直接拿来用
FactoryBean：就像买生产线，可以定制生产你想要的对象

举个例子：
- 普通Bean：你买了一台组装好的电脑
- FactoryBean：你买了一条电脑生产线，可以按需生产各种配置的电脑
```

**💡 为什么需要FactoryBean？**
```
有些对象的创建过程很复杂：
- 需要读取配置文件
- 需要进行复杂的初始化
- 需要根据条件创建不同的对象
- 需要对第三方类进行封装

这时候用FactoryBean就很方便，把复杂的创建逻辑封装在工厂里
```

### 1.2 FactoryBean接口详解


**🔸 接口定义**
```java
public interface FactoryBean<T> {
    // 核心方法：返回工厂创建的对象
    T getObject() throws Exception;
    
    // 返回创建对象的类型
    Class<?> getObjectType();
    
    // 是否单例（true=单例，false=每次创建新对象）
    default boolean isSingleton() {
        return true;
    }
}
```

**📝 方法说明**

**getObject()** - 工厂的核心方法
```
作用：返回工厂真正要创建的对象
理解：这个方法里写你的对象创建逻辑
特点：每次从容器获取Bean时，都会调用这个方法
```

**getObjectType()** - 声明对象类型
```
作用：告诉Spring这个工厂生产什么类型的对象
理解：就像工厂门口的牌子，写着"本厂生产汽车"
用途：Spring需要知道类型来进行依赖注入
```

**isSingleton()** - 控制单例还是多例
```
返回true：工厂只生产一次，后续都返回同一个对象（单例）
返回false：每次都生产新对象（多例）
默认：true（单例模式）
```

### 1.3 实战案例：创建数据库连接池


**场景说明**：数据库连接池的创建需要复杂配置，用FactoryBean封装很合适

```java
// 数据库连接池工厂Bean
public class DataSourceFactoryBean implements FactoryBean<DataSource> {
    
    // 配置属性
    private String driverClassName;
    private String url;
    private String username;
    private String password;
    
    @Override
    public DataSource getObject() throws Exception {
        // 创建数据源的复杂逻辑
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driverClassName);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        
        // 其他复杂配置
        dataSource.setInitialSize(5);
        dataSource.setMaxActive(20);
        
        return dataSource;
    }
    
    @Override
    public Class<?> getObjectType() {
        return DataSource.class;
    }
    
    @Override
    public boolean isSingleton() {
        return true; // 连接池是单例
    }
    
    // setter方法用于注入配置...
}
```

**XML配置使用**
```xml
<!-- 配置工厂Bean -->
<bean id="dataSource" class="com.example.DataSourceFactoryBean">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/test"/>
    <property name="username" value="root"/>
    <property name="password" value="123456"/>
</bean>

<!-- 使用时，获取到的是DataSource对象，不是工厂本身 -->
<bean id="userDao" class="com.example.UserDao">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

### 1.4 工厂Bean与普通Bean的区别


**🔸 获取对象的区别**

```
场景：有个FactoryBean叫 "carFactory"

方式1：通过Bean名称获取
context.getBean("carFactory")  
→ 返回：Car对象（工厂生产的对象）

方式2：通过&符号获取工厂本身
context.getBean("&carFactory")  
→ 返回：CarFactoryBean对象（工厂本身）

记忆技巧：
- 不加&：拿产品
- 加&：拿工厂
```

**📊 对比表格**

| 特性 | **普通Bean** | **FactoryBean** |
|------|-------------|----------------|
| `定义方式` | 直接定义类 | 实现FactoryBean接口 |
| `获取对象` | 直接返回配置的类实例 | 返回getObject()方法的返回值 |
| `使用场景` | 简单对象创建 | 复杂对象创建、第三方类封装 |
| `容器管理` | 直接管理这个Bean | 管理工厂，间接管理产品 |
| `获取工厂` | - | 通过&前缀获取 |

---

## 2. 💉 方法注入机制


### 2.1 为什么需要方法注入


**🤔 问题场景：单例Bean依赖多例Bean**

```
现实场景类比：
- 你有一个长期使用的工具箱（单例）
- 工具箱里需要螺丝钉（多例，用完就扔）
- 但工具箱是单例，创建一次后不会重新注入新螺丝钉

问题：如何让单例Bean每次都能获取到新的多例Bean？
```

**❌ 传统方式的问题**
```java
// 单例Bean
@Component
@Scope("singleton")
public class OrderService {
    
    @Autowired
    private OrderRequest request; // 多例Bean
    
    public void createOrder() {
        // 问题：request永远是第一次注入的那个对象
        // 无法获取新的request实例
    }
}
```

**💡 解决方案对比**

| 方案 | **实现方式** | **优缺点** |
|------|------------|-----------|
| `方式1` | 每次从容器获取 | ✅简单 ❌代码侵入性强 |
| `方式2` | 实现ApplicationContextAware | ✅灵活 ❌与Spring耦合 |
| `方式3` | lookup方法注入 | ✅优雅 ✅无侵入 |

### 2.2 方法注入的类型


**🔸 Spring提供的两种方法注入**

```
1. lookup-method（查找方法注入）
   作用：让方法每次返回新对象
   场景：单例依赖多例

2. replaced-method（方法替换）
   作用：替换原有方法的实现
   场景：方法增强、切面编程
```

---

## 3. 🔍 lookup方法注入


### 3.1 lookup-method基本概念


**定义**：lookup方法注入让Spring在运行时动态覆盖一个方法，使其每次调用都返回容器中的Bean实例

```
通俗理解：
就像一个"魔法方法"：
- 你写个抽象方法或空方法
- Spring在运行时给你"填充"实现
- 每次调用都去容器里拿新对象
```

### 3.2 XML配置方式


**🔸 完整示例**

```java
// 多例Bean：订单请求
@Component
@Scope("prototype")
public class OrderRequest {
    private String orderId;
    private Date createTime = new Date();
    
    public OrderRequest() {
        System.out.println("创建新的OrderRequest");
    }
}

// 单例Bean：订单服务（抽象类）
public abstract class OrderService {
    
    // 抽象方法：Spring会在运行时实现这个方法
    protected abstract OrderRequest createOrderRequest();
    
    public void processOrder() {
        // 每次调用createOrderRequest()都返回新对象
        OrderRequest request = createOrderRequest();
        System.out.println("处理订单：" + request.getCreateTime());
    }
}
```

**XML配置**
```xml
<!-- 多例Bean -->
<bean id="orderRequest" class="com.example.OrderRequest" scope="prototype"/>

<!-- 单例Bean，配置lookup方法 -->
<bean id="orderService" class="com.example.OrderService">
    <!-- 
        name：要覆盖的方法名
        bean：每次调用该方法时返回的Bean
    -->
    <lookup-method name="createOrderRequest" bean="orderRequest"/>
</bean>
```

**运行效果**
```java
// 测试代码
OrderService service = context.getBean(OrderService.class);

service.processOrder(); // 创建新的OrderRequest + 处理订单：xxx
service.processOrder(); // 创建新的OrderRequest + 处理订单：yyy
service.processOrder(); // 创建新的OrderRequest + 处理订单：zzz

// 每次都是新对象！
```

### 3.3 注解配置方式


**🔸 使用@Lookup注解**

```java
@Component
public abstract class OrderService {
    
    // 使用@Lookup注解，不需要XML配置
    @Lookup
    protected abstract OrderRequest createOrderRequest();
    
    public void processOrder() {
        OrderRequest request = createOrderRequest();
        System.out.println("处理订单：" + request.getCreateTime());
    }
}
```

**⚡ 原理说明**
```
Spring如何实现的？
1. 发现@Lookup注解或lookup-method配置
2. 使用CGLIB创建子类代理
3. 在子类中覆盖标记的方法
4. 方法实现：从容器中获取Bean并返回

代理类大致长这样：
public class OrderService$$EnhancerBySpringCGLIB extends OrderService {
    @Override
    protected OrderRequest createOrderRequest() {
        return applicationContext.getBean(OrderRequest.class);
    }
}
```

### 3.4 lookup方法的注意事项


**📋 使用要求**

```
✅ 正确做法：
- 方法必须是抽象的或返回null
- 方法不能是private（代理无法覆盖）
- 方法不能是final（代理无法覆盖）
- 包含lookup方法的类不能是final

❌ 常见错误：
public final class OrderService {  // ❌ final类
    
    private OrderRequest getRequest() { // ❌ private方法
        return null;
    }
    
    public final OrderRequest getRequest2() { // ❌ final方法
        return null;
    }
}
```

**🎯 最佳实践**

| 场景 | **推荐方案** | **说明** |
|------|------------|---------|
| `单例依赖多例` | lookup方法注入 | 最优雅的解决方案 |
| `需要每次获取新对象` | lookup方法注入 | 避免手动从容器获取 |
| `复杂对象创建` | FactoryBean | 封装创建逻辑 |

---

## 4. 🔄 replaced-method方法替换


### 4.1 replaced-method基本概念


**定义**：方法替换允许你用自定义实现替换Bean中的任意方法

```
通俗理解：
就像"偷梁换柱"：
- 原本方法做A
- 你写个新实现做B
- Spring运行时把A换成B
```

### 4.2 实现步骤


**步骤1：原始Bean类**
```java
public class Calculator {
    
    public int add(int a, int b) {
        System.out.println("原始add方法");
        return a + b;
    }
}
```

**步骤2：方法替换器**
```java
// 实现MethodReplacer接口
public class AddMethodReplacer implements MethodReplacer {
    
    @Override
    public Object reimplement(Object obj, Method method, Object[] args) {
        System.out.println("替换后的add方法");
        
        // 可以执行完全不同的逻辑
        int a = (Integer) args[0];
        int b = (Integer) args[1];
        
        // 比如：改成乘法
        return a * b;
    }
}
```

**步骤3：XML配置**
```xml
<!-- 替换器 -->
<bean id="addMethodReplacer" class="com.example.AddMethodReplacer"/>

<!-- 目标Bean -->
<bean id="calculator" class="com.example.Calculator">
    <replaced-method name="add" replacer="addMethodReplacer">
        <!-- 可选：指定参数类型，用于方法重载 -->
        <arg-type>int</arg-type>
        <arg-type>int</arg-type>
    </replaced-method>
</bean>
```

**运行效果**
```java
Calculator calc = context.getBean(Calculator.class);

int result = calc.add(3, 4);
// 输出：替换后的add方法
// 结果：12（执行的是乘法，不是加法）
```

### 4.3 应用场景


**🎯 实际应用**

```
场景1：方法增强
- 在不修改源码的情况下增强方法功能
- 比如：添加日志、权限检查

场景2：热修复
- 运行时替换有bug的方法
- 快速修复问题

场景3：单元测试
- 替换依赖的外部方法
- 模拟测试场景

⚠️ 注意：replaced-method用得少
- 现在更多用AOP实现方法增强
- 更灵活、更强大
```

---

## 5. 🎭 动态代理原理


### 5.1 为什么需要动态代理


**问题引入**
```
lookup方法和replaced-method都是抽象/空方法
Spring怎么"凭空"给它们加上实现的？

答案：动态代理技术
```

**💡 代理模式理解**
```
现实类比：
你是明星（目标对象）
经纪人是代理（代理对象）

粉丝找你 → 实际找到经纪人 → 经纪人安排 → 最后到你

好处：
- 控制访问
- 增强功能
- 解耦逻辑
```

### 5.2 Spring使用的两种代理


**🔸 JDK动态代理 vs CGLIB代理**

```
                目标对象
                   ↓
         有接口？ 
       ↙        ↘
    是            否
     ↓            ↓
JDK动态代理    CGLIB代理
(基于接口)    (基于继承)
```

**📊 对比分析**

| 特性 | **JDK动态代理** | **CGLIB代理** |
|------|---------------|--------------|
| `实现方式` | 基于接口实现 | 基于继承生成子类 |
| `要求` | 必须有接口 | 不能是final类 |
| `性能` | 较快 | 较慢（首次生成类） |
| `适用场景` | 目标类实现了接口 | 目标类没有接口 |

### 5.3 CGLIB代理原理（lookup使用）


**🔸 CGLIB工作流程**

```
1. 分析目标类（OrderService）
   ↓
2. 动态生成子类（OrderService$$CGLIB）
   ↓
3. 覆盖标记的方法（createOrderRequest）
   ↓
4. 新方法从容器获取Bean返回
   ↓
5. 返回子类实例给容器
```

**代码模拟**
```java
// Spring实际生成的代理类（简化版）
public class OrderService$$CGLIB extends OrderService {
    
    private ApplicationContext context;
    
    @Override
    protected OrderRequest createOrderRequest() {
        // 直接从容器获取Bean
        return context.getBean("orderRequest", OrderRequest.class);
    }
    
    @Override
    public void processOrder() {
        // 调用父类方法
        super.processOrder();
    }
}
```

### 5.4 代理的应用场景


**🎯 Spring中代理的使用**

| 场景 | **代理类型** | **作用** |
|------|------------|---------|
| `lookup方法注入` | CGLIB | 动态实现抽象方法 |
| `replaced-method` | CGLIB | 替换方法实现 |
| `@Transactional` | JDK/CGLIB | 事务管理 |
| `@Async` | JDK/CGLIB | 异步调用 |
| `@Cacheable` | JDK/CGLIB | 缓存管理 |

**💭 理解要点**
```
只要你看到Spring的功能：
- 不修改原始类
- 却能增强功能
- 十有八九用了代理

记住：
代理 = 中间人 = 在不改变原对象的前提下，增强或控制访问
```

---

## 6. 📋 核心要点总结


### 6.1 知识体系梳理


**🔸 FactoryBean工厂Bean**
```
本质：对象创建工厂
作用：封装复杂对象的创建逻辑
使用：实现FactoryBean接口，重写getObject()

核心接口：
- getObject()：返回真正的对象
- getObjectType()：返回对象类型
- isSingleton()：是否单例

记忆：工厂生产产品，&符号拿工厂
```

**🔸 方法注入机制**
```
问题：单例Bean如何获取多例Bean
方案：lookup方法注入

实现方式：
- XML：<lookup-method>
- 注解：@Lookup

要求：方法必须抽象/返回null，不能private/final
```

**🔸 方法替换**
```
作用：替换Bean方法的实现
实现：MethodReplacer接口

使用场景：
- 方法增强（现在用AOP更多）
- 热修复
- 测试模拟
```

**🔸 动态代理**
```
原理：Spring实现方法注入的底层技术

两种方式：
- JDK代理：基于接口
- CGLIB代理：基于继承

应用：AOP、事务、缓存、异步等
```

### 6.2 实战应用建议


**📝 选择指南**

```
场景1：需要复杂对象创建
→ 使用FactoryBean
→ 示例：数据源、连接池、复杂配置对象

场景2：单例依赖多例
→ 使用lookup方法注入
→ 示例：服务类需要每次创建新的请求对象

场景3：方法功能增强
→ 优先使用AOP
→ 不推荐replaced-method（太底层）

场景4：第三方类封装
→ 使用FactoryBean
→ 示例：整合MyBatis、Hibernate
```

### 6.3 常见问题解答


**❓ Q1：FactoryBean和BeanFactory的区别？**
```
FactoryBean：
- 是一个Bean
- 用于创建其他Bean
- 你来实现

BeanFactory：
- 是Spring容器
- 管理所有Bean
- Spring提供

记忆：
- FactoryBean是"工人"（创建对象）
- BeanFactory是"工厂"（管理对象）
```

**❓ Q2：什么时候用FactoryBean？**
```
✅ 适合用：
- 对象创建需要复杂配置
- 需要根据条件创建不同对象
- 封装第三方库的对象创建

❌ 不需要用：
- 简单对象直接用@Component
- 配置不复杂用@Bean方法
```

**❓ Q3：lookup方法为什么要抽象？**
```
原因：Spring用CGLIB生成子类
- 子类需要覆盖方法
- 抽象方法强制子类实现
- 或者返回null，让代理覆盖

如果方法有实现且不抽象：
- 可能执行原方法
- 达不到每次获取新对象的效果
```

### 6.4 学习路线建议


**🎯 进阶路径**
```
第1步：掌握FactoryBean
→ 理解接口三个方法
→ 实践：创建数据源工厂

第2步：理解方法注入
→ 解决单例依赖多例问题
→ 实践：订单服务案例

第3步：了解动态代理
→ 理解JDK代理和CGLIB代理
→ 为学习AOP打基础

第4步：深入Spring AOP
→ 学习切面编程
→ 理解代理在AOP中的应用
```

**核心记忆**：
```
工厂Bean生产对象，复杂创建它来搞
lookup方法真神奇，单例多例不用愁
代理技术是基础，Spring功能全靠它
灵活运用这些招，IoC容器你最牛
```