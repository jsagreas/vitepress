---
title: 1、控制反转原理
---
## 📚 目录

1. [什么是控制反转](#1-什么是控制反转)
2. [为什么需要控制反转](#2-为什么需要控制反转)
3. [依赖倒置原则](#3-依赖倒置原则)
4. [IoC容器的作用](#4-IoC容器的作用)
5. [对象创建控制权的转移](#5-对象创建控制权的转移)
6. [解耦合的实现](#6-解耦合的实现)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 什么是控制反转


### 1.1 控制反转的基本概念


**控制反转（Inversion of Control，简称IoC）**听起来很高大上，其实用大白话说就是：**以前你自己干的事，现在交给别人帮你干**。

```
传统方式（你自己控制）：
我要用一辆车 → 我自己去造车 → 造好了才能开

控制反转（别人帮你控制）：
我要用一辆车 → 告诉4S店我要车 → 4S店直接给我一辆现成的车
```

> 💡 **简单理解**：控制反转就是把"对象创建和管理"的权力，从你的代码手里交给了Spring容器。你只需要告诉容器"我要什么"，容器就给你准备好。

### 1.2 "控制"和"反转"分别指什么


让我们把这个词拆开来理解：

**🔸 控制（Control）**
```
控制的是什么？
→ 对象的创建
→ 对象的生命周期
→ 对象之间的依赖关系

举例：
就像你要开车，传统方式你得自己：
- 造车（创建对象）
- 加油保养（管理生命周期）
- 找轮胎、发动机、座椅组装（处理依赖）
```

**🔸 反转（Inversion）**
```
反转的是什么？
→ 控制权的方向反过来了
→ 以前是"你主动创建对象"
→ 现在是"容器帮你创建对象"

举例：
现在你只需要：
- 告诉4S店你要什么车（声明依赖）
- 4S店给你准备好（容器创建）
- 你直接开走（直接使用）
```

### 1.3 生活中的类比理解


**传统方式就像自己做饭：**
```
肚子饿了 → 买菜 → 洗菜 → 切菜 → 炒菜 → 吃饭
              ↑_____ 这些全是你自己控制 _____↑
```

**控制反转就像去餐厅：**
```
肚子饿了 → 告诉服务员要什么菜 → 厨房做好送上来 → 直接吃
                                    ↑___ 控制权在餐厅 ___↑
```

> 📝 **核心思想**：你不再关心"怎么做"，只需要关心"要什么"。这就是控制反转的本质。

---

## 2. 🤔 为什么需要控制反转


### 2.1 传统方式的痛点


**问题1：代码耦合度高**

```java
// 传统方式：直接new对象
public class UserService {
    // 我自己创建依赖对象
    private UserDao userDao = new UserDaoImpl();
    
    public User getUser(int id) {
        return userDao.findById(id);
    }
}
```

**这样写有什么问题？**
- ❌ UserService和UserDaoImpl紧紧绑在一起了
- ❌ 想换个实现（比如换成MySQL版本）？必须改代码
- ❌ 测试的时候想用假数据？也得改代码
- ❌ 一个类的改动会影响其他类

**问题2：对象创建分散，难以管理**

```
应用中有100个类，每个类都自己new对象：
├─ UserService自己new UserDao
├─ OrderService自己new OrderDao  
├─ ProductService自己new ProductDao
└─ ...

结果：
- 对象创建逻辑到处都是
- 修改起来要改100个地方
- 容易出错，难以维护
```

**问题3：资源浪费**

```java
// 每次使用都创建新对象
public void doSomething() {
    UserDao dao1 = new UserDaoImpl(); // 创建对象1
    // 用完了
}

public void doOtherThing() {
    UserDao dao2 = new UserDaoImpl(); // 又创建对象2
    // 用完了
}

// 其实这两个对象可以共用一个！
```

### 2.2 控制反转的优势


**优势1：降低耦合度** ⭐⭐⭐⭐⭐
```
以前：UserService直接依赖UserDaoImpl（具体实现）
现在：UserService只依赖UserDao接口
     具体用哪个实现？交给Spring容器决定

就像：
以前：你指定必须用"本田雅阁"
现在：你只说"要一辆车"，4S店决定给你什么车
```

**优势2：统一管理** ⭐⭐⭐⭐⭐
```
所有对象都由Spring容器创建和管理：
├─ 创建时机：容器控制
├─ 生命周期：容器控制
├─ 依赖关系：容器控制
└─ 销毁时机：容器控制

你只需要配置一次，剩下的Spring全帮你搞定
```

**优势3：方便测试** ⭐⭐⭐⭐
```java
// 测试时可以轻松替换实现
@Test
public void testUserService() {
    // 用假的Dao进行测试
    UserDao mockDao = new MockUserDao();
    UserService service = new UserService(mockDao);
    // 进行测试...
}
```

**优势4：灵活配置** ⭐⭐⭐⭐
```xml
<!-- 想换实现？改配置文件就行，不用改代码 -->
<bean id="userDao" class="com.example.UserDaoMySQLImpl"/>
<!-- 改成这个就换实现了 -->
<bean id="userDao" class="com.example.UserDaoOracleImpl"/>
```

### 2.3 对比总结


| 维度 | **传统方式** | **控制反转方式** |
|------|-------------|-----------------|
| **对象创建** | 代码里到处new | 容器统一创建 ✅ |
| **依赖关系** | 代码写死 | 配置灵活 ✅ |
| **耦合度** | 高耦合❌ | 低耦合✅ |
| **可测试性** | 难测试❌ | 易测试✅ |
| **可维护性** | 难维护❌ | 易维护✅ |
| **灵活性** | 不灵活❌ | 很灵活✅ |

---

## 3. 📐 依赖倒置原则


### 3.1 什么是依赖倒置原则


**依赖倒置原则（Dependency Inversion Principle，DIP）**是面向对象设计的重要原则，它说的是：

> 🎯 **核心思想**：高层模块不应该依赖低层模块，两者都应该依赖抽象（接口）

**用人话说就是：**
```
错误做法：老板直接依赖具体员工
老板 → 张三（具体的人）
问题：张三离职了，老板就傻眼了

正确做法：老板依赖"员工"这个角色
老板 → 员工接口 ← 张三、李四、王五
好处：谁来都行，换人不影响老板工作
```

### 3.2 传统依赖关系（错误示范）


```java
// 低层模块：具体实现
public class MySQLUserDao {
    public User findById(int id) {
        // 从MySQL查询
        return user;
    }
}

// 高层模块：业务逻辑
public class UserService {
    // ❌ 直接依赖具体实现
    private MySQLUserDao userDao = new MySQLUserDao();
    
    public User getUser(int id) {
        return userDao.findById(id);
    }
}
```

**依赖关系图：**
```
UserService（高层）
     ↓ 直接依赖
MySQLUserDao（低层）

问题：
- 想换成Oracle数据库？改UserService代码
- 想换成MongoDB？还得改UserService代码
- UserService被具体实现绑架了
```

### 3.3 依赖倒置后的关系（正确示范）


```java
// 抽象层：接口
public interface UserDao {
    User findById(int id);
}

// 低层模块：具体实现
public class MySQLUserDao implements UserDao {
    public User findById(int id) {
        // MySQL实现
        return user;
    }
}

public class OracleUserDao implements UserDao {
    public User findById(int id) {
        // Oracle实现
        return user;
    }
}

// 高层模块：业务逻辑
public class UserService {
    // ✅ 依赖抽象接口
    private UserDao userDao;
    
    // 通过构造器注入具体实现
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
    
    public User getUser(int id) {
        return userDao.findById(id);
    }
}
```

**依赖关系图：**
```
        UserService（高层）
             ↓ 依赖
        UserDao接口（抽象层）
             ↑ 实现
    ┌────────┴────────┐
MySQLUserDao    OracleUserDao
  （低层）         （低层）

好处：
- 高层和低层都依赖接口
- 换实现只需要换注入的对象
- 代码更灵活、更稳定
```

### 3.4 依赖倒置与控制反转的关系


```
依赖倒置原则（DIP）：设计原则，告诉你"应该怎么设计"
     ↓ 指导
控制反转（IoC）：设计模式，告诉你"怎么实现设计"
     ↓ 具体实现
依赖注入（DI）：技术手段，告诉你"具体怎么做"

就像：
DIP是建筑设计理念
IoC是建筑设计图纸
DI是施工队具体施工
```

> 💡 **记忆技巧**：依赖倒置是"思想"，控制反转是"方法"，依赖注入是"技术"。

---

## 4. 🏭 IoC容器的作用


### 4.1 什么是IoC容器


**IoC容器就是Spring框架的核心**，可以把它想象成一个"智能对象工厂"：

```
IoC容器的角色：

           IoC容器（Spring容器）
                  |
     ┌───────────┼───────────┐
     ↓           ↓           ↓
  创建对象    管理对象    提供对象
     |           |           |
  [工厂]      [管家]      [仓库]
```

**用生活场景类比：**
```
IoC容器 = 大型超市

超市的作用：
1. 进货（创建对象）
   - 从厂家进货各种商品
   
2. 仓储（管理对象）
   - 分类存放
   - 保质期管理
   - 库存管理
   
3. 售货（提供对象）
   - 顾客需要什么就给什么
   - 顾客不用关心商品怎么来的
```

### 4.2 IoC容器的核心功能


**功能1：对象创建工厂** 🏭
```java
// 传统方式：你自己new
UserService service = new UserService();
UserDao dao = new UserDaoImpl();
// ...要new很多对象

// Spring方式：容器帮你创建
// 你只需要配置告诉容器"我需要什么"
@Component
public class UserService {
    // 容器自动创建UserService对象
}
```

**功能2：依赖关系装配工** 🔧
```java
// 容器自动处理对象之间的依赖关系
@Service
public class UserService {
    @Autowired  // 告诉容器：我需要UserDao
    private UserDao userDao;
    
    // 容器会自动找到UserDao的实现并注入进来
}
```

**功能3：对象生命周期管理员** ⏰
```
对象从出生到死亡，容器全程照顾：

创建 → 初始化 → 使用 → 销毁
 ↑                        ↑
容器控制              容器控制

你不用关心：
- 什么时候创建对象
- 对象用完后怎么销毁
- 对象在内存中存在多久
```

**功能4：配置中心管理员** 📋
```xml
<!-- 所有对象的配置都在这里 -->
<beans>
    <bean id="userDao" class="com.example.UserDaoImpl"/>
    <bean id="userService" class="com.example.UserService">
        <property name="userDao" ref="userDao"/>
    </bean>
</beans>

修改配置 → 容器重新装配 → 应用生效
```

### 4.3 容器的工作流程


```
应用启动时：

1. 读取配置
   容器 → 读取XML/注解配置 → 知道要创建哪些对象
   
2. 创建对象
   容器 → 根据配置创建对象 → 放入容器中
   
3. 注入依赖
   容器 → 分析对象依赖关系 → 自动装配
   
4. 初始化
   容器 → 调用初始化方法 → 对象准备就绪
   
5. 提供服务
   应用 → 向容器要对象 → 容器返回现成对象

应用关闭时：

6. 销毁对象
   容器 → 调用销毁方法 → 释放资源 → 容器关闭
```

**流程图示：**
```
启动阶段：
┌──────────┐
│ 读取配置  │
└─────┬────┘
      ↓
┌──────────┐
│ 创建对象  │
└─────┬────┘
      ↓
┌──────────┐
│ 注入依赖  │
└─────┬────┘
      ↓
┌──────────┐
│  初始化   │
└─────┬────┘
      ↓
┌──────────┐
│ 对象就绪  │← 应用使用
└─────┬────┘
      ↓
┌──────────┐
│ 销毁对象  │
└──────────┘
```

### 4.4 容器的类型


Spring提供了两种主要的容器类型：

| 容器类型 | **说明** | **适用场景** | **功能** |
|---------|---------|------------|---------|
| **BeanFactory** | 基础容器 | 资源受限环境 | 基本的IoC功能 |
| **ApplicationContext** | 高级容器 | 企业级应用 | IoC + AOP + 事件发布等 |

```
BeanFactory（简易版）：
- 像小便利店
- 功能简单
- 占用资源少

ApplicationContext（豪华版）：
- 像大型购物中心
- 功能齐全
- 提供更多服务
```

> 💡 **实际开发建议**：99%的情况用ApplicationContext，它功能更强大，也是Spring推荐的。

---

## 5. 🔄 对象创建控制权的转移


### 5.1 控制权转移的本质


**以前的控制权在你手里：**
```java
public class UserController {
    public void handleRequest() {
        // 我说了算：我要什么对象，我自己创建
        UserService service = new UserService();
        UserDao dao = new UserDaoImpl();
        
        // 我自己组装依赖关系
        service.setUserDao(dao);
        
        // 我自己调用
        service.doSomething();
    }
}
```

**现在的控制权在容器手里：**
```java
@Controller
public class UserController {
    // 我只是声明：我需要UserService
    @Autowired
    private UserService userService;
    
    public void handleRequest() {
        // 容器已经创建好对象并注入了
        // 我直接用就行
        userService.doSomething();
    }
}
```

### 5.2 控制权转移的对比


**创建时机的控制权：**
```
传统方式：
你的代码执行到new语句 → 对象才创建
你控制什么时候创建对象

IoC方式：
容器启动时就创建好了 → 你要用时直接拿
容器控制什么时候创建对象
```

**依赖关系的控制权：**
```
传统方式：
UserService service = new UserService();
UserDao dao = new UserDaoImpl();
service.setUserDao(dao);  // 你手动装配
     ↑ 你说了算用哪个实现

IoC方式：
@Autowired
private UserDao userDao;  // 容器自动装配
                ↑ 容器决定用哪个实现
```

**生命周期的控制权：**
```
传统方式：
{
    UserDao dao = new UserDao();  // 你创建
    dao.query();                  // 你使用
    dao = null;                   // 你销毁
}  // 作用域结束，GC回收

IoC方式：
容器创建 → 容器管理 → 容器销毁
你完全不用管对象的生死
```

### 5.3 控制权转移的好处


**好处1：你的代码更简单** ✅
```java
// 以前：要写很多创建和管理代码
public class OrderService {
    private OrderDao orderDao;
    private UserDao userDao;
    private ProductDao productDao;
    
    public OrderService() {
        this.orderDao = new OrderDaoImpl();
        this.userDao = new UserDaoImpl();
        this.productDao = new ProductDaoImpl();
        // 还要处理这些对象的初始化...
    }
}

// 现在：只需要声明依赖
@Service
public class OrderService {
    @Autowired
    private OrderDao orderDao;
    @Autowired
    private UserDao userDao;
    @Autowired
    private ProductDao productDao;
    
    // 容器全帮你搞定！
}
```

**好处2：修改更灵活** ✅
```
需求变更：UserDao要换个实现

传统方式：
1. 找到所有new UserDaoImpl()的地方
2. 一个个改成new UserDaoOracleImpl()
3. 漏改一个就出bug

IoC方式：
1. 改一个配置：@Primary注解或配置文件
2. 全部自动生效
3. 不会遗漏
```

**好处3：测试更方便** ✅
```java
// 测试时可以轻松替换依赖
@Test
public void testOrderService() {
    // 创建测试用的Mock对象
    OrderDao mockDao = mock(OrderDao.class);
    
    // 用测试对象替换真实依赖
    OrderService service = new OrderService(mockDao);
    
    // 进行测试
    service.createOrder(...);
}
```

### 5.4 控制权转移示意图


```
传统模式（你掌控一切）：
    
    你的代码
       ↓
   创建对象A
       ↓
   创建对象B
       ↓
   A和B建立关系
       ↓
   管理生命周期
       ↓
   销毁对象

所有控制权都在你手里，累不累？


IoC模式（容器掌控）：

    配置文件/注解
         ↓
    Spring容器
    ├─ 创建A
    ├─ 创建B  
    ├─ A和B建立关系
    ├─ 管理生命周期
    └─ 销毁对象
         ↓
    你的代码直接用

你只需要声明需要什么，剩下的交给容器
```

> 🎯 **关键理解**：控制权转移不是你失去了控制，而是你把"繁琐的控制"交给了专业的容器，你专注于业务逻辑就好。

---

## 6. 🔗 解耦合的实现


### 6.1 什么是耦合


**耦合度**就是模块之间的依赖程度，用生活化的例子来理解：

```
高耦合（紧密绑定）：
你和女朋友用情侣手机卡
- 你换号 → 她也得换号
- 你换运营商 → 她也得换
- 牵一发而动全身

低耦合（松散关联）：
你们各用各的手机卡
- 你换号 → 不影响她
- 你换运营商 → 她无所谓
- 互不影响
```

### 6.2 代码中的耦合问题


**高耦合的代码示例：**
```java
// UserService强依赖MySQLUserDao
public class UserService {
    // 写死了具体实现类
    private MySQLUserDao userDao = new MySQLUserDao();
    
    public User getUser(int id) {
        return userDao.findById(id);
    }
}

问题分析：
❌ UserService直接依赖MySQLUserDao这个具体类
❌ 要换数据库？必须改UserService代码
❌ 要测试？必须连接真实数据库
❌ MySQLUserDao的任何改动都影响UserService
```

**耦合带来的问题：**
```
1. 代码僵化
   └─ 一处改动，多处修改

2. 难以扩展
   └─ 添加新功能要改旧代码

3. 难以测试
   └─ 依赖具体实现，无法隔离测试

4. 难以维护
   └─ 牵一发而动全身，改不动
```

### 6.3 IoC如何解耦


**解耦步骤1：依赖接口而非实现**
```java
// 定义接口（抽象）
public interface UserDao {
    User findById(int id);
}

// 具体实现1
public class MySQLUserDao implements UserDao {
    public User findById(int id) {
        // MySQL实现
    }
}

// 具体实现2
public class MongoUserDao implements UserDao {
    public User findById(int id) {
        // MongoDB实现
    }
}

// UserService只依赖接口
public class UserService {
    private UserDao userDao;  // 依赖接口，不是具体类
    
    public User getUser(int id) {
        return userDao.findById(id);
    }
}
```

**解耦步骤2：由容器注入依赖**
```java
@Service
public class UserService {
    // 不自己new，由Spring注入
    @Autowired
    private UserDao userDao;
    
    public User getUser(int id) {
        return userDao.findById(id);
    }
}

// 配置决定用哪个实现
@Configuration
public class AppConfig {
    @Bean
    public UserDao userDao() {
        // 想换实现？改这里就行
        return new MySQLUserDao();
        // return new MongoUserDao();  // 换实现只需改这一行
    }
}
```

### 6.4 解耦合的层次


**第1层：编译期解耦**
```java
// UserService编译时不需要知道UserDao的具体实现
public class UserService {
    private UserDao userDao;  // 只知道接口
    // 编译通过，不管UserDao有几个实现类
}
```

**第2层：运行期解耦**
```java
// 运行时由容器决定使用哪个实现
@Service
public class UserService {
    @Autowired
    private UserDao userDao;  // 运行时Spring注入具体实现
}

// 配置文件或注解决定具体使用哪个
@Primary  // 标记这个是主要实现
@Repository
public class MySQLUserDao implements UserDao {
    // ...
}
```

**第3层：配置解耦**
```
不同环境用不同实现：

开发环境：
application-dev.yml → 使用H2内存数据库

测试环境：
application-test.yml → 使用MySQL测试库

生产环境：
application-prod.yml → 使用Oracle生产库

代码一行不改，只改配置文件
```

### 6.5 解耦合的实际效果


**场景1：切换数据库实现**
```java
// 以前（高耦合）：
修改代码：
UserService.java中所有new UserDaoImpl()
→ 改成new OracleUserDaoImpl()
→ 重新编译、测试、发布

// 现在（低耦合）：
修改配置：
@Bean
public UserDao userDao() {
    return new OracleUserDao();  // 只改这一行
}
→ 不用重新编译业务代码
```

**场景2：单元测试**
```java
// 以前（高耦合）：
@Test
public void testUserService() {
    UserService service = new UserService();
    // service内部new了真实的Dao
    // 必须连接真实数据库才能测试
}

// 现在（低耦合）：
@Test
public void testUserService() {
    UserDao mockDao = mock(UserDao.class);
    UserService service = new UserService(mockDao);
    // 用假的Dao测试，不需要真实数据库
}
```

**场景3：功能扩展**
```java
// 添加Redis缓存功能

// 以前（高耦合）：
修改UserService代码，添加Redis调用逻辑
→ 业务代码和缓存代码混在一起

// 现在（低耦合）：
@Repository
public class CachedUserDao implements UserDao {
    @Autowired
    private RedisTemplate redis;
    @Autowired
    private MySQLUserDao mysqlDao;
    
    public User findById(int id) {
        // 先查缓存
        User user = redis.get(id);
        if (user == null) {
            user = mysqlDao.findById(id);
            redis.set(id, user);
        }
        return user;
    }
}

// UserService代码完全不用改！
```

### 6.6 解耦合关系图


```
高耦合模式：
UserService ──直接依赖──> MySQLUserDao
                            ↑
                         写死了

问题：换实现必须改UserService


低耦合模式：
              UserDao接口
                /    \
               /      \
   UserService        MySQLUserDao
       ↑               MongoUserDao
       |               RedisUserDao
    只依赖接口           ↑
                    具体实现可随意切换

优势：UserService不用改，只需配置选择用哪个实现
```

> 💡 **核心理解**：解耦不是让模块之间没有关系，而是让它们之间的关系变得灵活可控。接口就是这个"灵活的纽带"。

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🔸 控制反转（IoC）**
```
定义：对象创建和管理的控制权从代码转移到容器
本质：以前你自己干的事，现在交给容器帮你干
好处：降低耦合、统一管理、方便测试、灵活配置
```

**🔸 依赖倒置原则（DIP）**
```
定义：高层模块和低层模块都应该依赖抽象
本质：不依赖具体实现，依赖接口或抽象类
关系：DIP是设计思想，IoC是实现方法
```

**🔸 IoC容器**
```
作用：Spring的核心，负责创建、管理、装配对象
功能：对象工厂 + 依赖装配 + 生命周期管理
类型：BeanFactory（基础）、ApplicationContext（推荐）
```

**🔸 控制权转移**
```
创建权：从代码new → 容器创建
装配权：从手动装配 → 容器自动装配
管理权：从手动管理 → 容器统一管理
```

**🔸 解耦合**
```
原理：依赖接口不依赖实现
实现：通过IoC容器注入依赖
效果：修改配置不改代码，灵活可扩展
```

### 7.2 关键理解要点


**🔹 三个核心关系**
```
依赖倒置原则（设计思想）
         ↓ 指导
控制反转（设计模式）
         ↓ 实现
依赖注入（具体技术）

记忆：思想→模式→技术
```

**🔹 对象控制权的三个维度**
```
1. 创建时机
   传统：代码执行到new才创建
   IoC：容器启动时创建

2. 依赖装配
   传统：手动set依赖
   IoC：容器自动注入

3. 生命周期
   传统：代码管理对象生死
   IoC：容器管理整个生命周期
```

**🔹 解耦的三个层次**
```
编译期解耦：依赖接口不依赖实现
运行期解耦：容器决定具体实现
配置解耦：配置文件控制行为
```

### 7.3 实际应用价值


**开发效率提升** ⭐⭐⭐⭐⭐
```
- 不用写对象创建代码
- 不用手动管理依赖关系
- 专注于业务逻辑开发
```

**代码质量提升** ⭐⭐⭐⭐⭐
```
- 低耦合、高内聚
- 易于维护和扩展
- 符合设计原则
```

**测试友好** ⭐⭐⭐⭐
```
- 轻松替换依赖
- 隔离测试更简单
- Mock对象容易注入
```

**灵活性提升** ⭐⭐⭐⭐⭐
```
- 切换实现无需改代码
- 配置文件控制行为
- 适应需求变化
```

### 7.4 学习建议


**🎯 理解顺序**
```
1. 先理解"为什么需要IoC"（传统方式的痛点）
2. 再理解"IoC是什么"（控制反转的概念）
3. 然后理解"怎么实现IoC"（容器的作用）
4. 最后理解"IoC的好处"（解耦合的价值）
```

**🎯 实践建议**
```
1. 先用传统方式写代码，体会痛点
2. 再改成Spring IoC方式，对比差异
3. 尝试切换不同实现，感受灵活性
4. 写单元测试，体会测试的便利
```

**🎯 常见误区**
```
❌ 误区1：以为IoC很复杂
   → 其实就是"不自己new，让容器创建"

❌ 误区2：以为失去了控制
   → 只是把繁琐的控制交给了容器

❌ 误区3：以为要记很多注解
   → 先理解原理，注解只是语法糖

❌ 误区4：以为IoC是Spring独有
   → IoC是设计思想，Spring只是实现之一
```

### 7.5 核心记忆口诀


```
控制反转降耦合，对象创建容器做
依赖倒置是原则，依赖接口不依赖具体
容器管理对象生死，配置决定用哪个
编译运行配置三解耦，灵活扩展不改代码
```

---

> 📌 **下一步学习**：了解了IoC的原理后，接下来学习**依赖注入的具体实现方式**（构造器注入、Setter注入、字段注入），以及**Spring IoC容器的使用方法**。