---
title: 1、观察者模式应用
---
## 📚 目录

1. [什么是事件驱动](#1-什么是事件驱动)
2. [观察者模式在Spring中的应用](#2-观察者模式在Spring中的应用)
3. [Spring事件机制核心组件](#3-Spring事件机制核心组件)
4. [事件发布与监听实战](#4-事件发布与监听实战)
5. [事件驱动的优势与应用场景](#5-事件驱动的优势与应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 什么是事件驱动


### 1.1 事件驱动的生活类比


**生活中的例子**：你订了外卖，不需要一直盯着手机等，外卖到了会有通知提醒你

```
传统方式（主动等待）：
你 → 不停查看外卖到没到 → 浪费时间

事件驱动（被动通知）：
你 → 做自己的事 → 外卖到了收到通知 → 去取外卖
```

**在程序中的体现**：
- 🔸 **传统方式**：代码A执行完，直接调用代码B，紧密耦合
- 🔸 **事件驱动**：代码A发出一个"事件"，谁关心谁去处理，松散耦合

### 1.2 事件驱动架构的核心理念


> **事件驱动**：程序的执行流程由事件的发生来决定，而不是按照固定顺序执行

**三个核心角色**：

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│  事件发布者  │ ─发布─→ │    事件     │ ─监听─→ │  事件监听器  │
│ (Publisher) │         │   (Event)   │         │ (Listener)  │
└─────────────┘         └─────────────┘         └─────────────┘

发布者：不关心谁来处理
事件：携带必要信息
监听器：自己决定是否处理
```

### 1.3 为什么需要事件驱动


**问题场景**：用户注册成功后，需要做很多事情

```java
// ❌ 传统方式：代码耦合严重
public void userRegister(User user) {
    // 保存用户
    userService.save(user);
    
    // 发送欢迎邮件
    emailService.sendWelcome(user);
    
    // 赠送积分
    pointService.addPoints(user);
    
    // 发送短信
    smsService.sendNotice(user);
    
    // 记录日志
    logService.recordRegister(user);
}
```

**存在的问题**：
- ⚠️ 注册逻辑和其他业务强绑定
- ⚠️ 新增需求要修改原有代码
- ⚠️ 某个服务出错会影响整个流程
- ⚠️ 代码维护困难

**事件驱动方式**：

```java
// ✅ 事件驱动：解耦灵活
public void userRegister(User user) {
    // 1. 保存用户
    userService.save(user);
    
    // 2. 发布注册事件
    eventPublisher.publish(new UserRegisterEvent(user));
    // 后续处理由各个监听器自己决定
}
```

**优势对比**：

| 对比维度 | **传统方式** | **事件驱动** |
|---------|------------|------------|
| **耦合度** | `高度耦合` | `松散耦合` |
| **扩展性** | `修改原代码` | `增加监听器` |
| **容错性** | `一环出错全崩` | `独立处理` |
| **维护性** | `牵一发动全身` | `职责清晰` |

---

## 2. 🔍 观察者模式在Spring中的应用


### 2.1 观察者模式基础


**观察者模式**：一个对象状态改变时，所有依赖它的对象都会自动收到通知

**生活类比**：
```
场景：微信公众号

公众号(被观察者)                     粉丝(观察者)
      │                               │
      │ ────发布新文章───→            │
      │                          粉丝A收到通知
      │                          粉丝B收到通知
      │                          粉丝C收到通知
```

### 2.2 观察者模式的组成


```
基础结构：

┌──────────────┐
│   Subject    │ ← 被观察者(主题)
│ (被观察者)    │
├──────────────┤
│ +attach()    │ ← 添加观察者
│ +detach()    │ ← 移除观察者  
│ +notify()    │ ← 通知所有观察者
└──────────────┘
        ↑
        │ 持有
        ↓
┌──────────────┐
│   Observer   │ ← 观察者接口
│  (观察者)     │
├──────────────┤
│ +update()    │ ← 收到通知后的处理
└──────────────┘
```

### 2.3 Spring对观察者模式的实现


Spring框架对观察者模式做了优雅的封装：

**核心映射关系**：

| 观察者模式概念 | **Spring实现** | **说明** |
|--------------|---------------|---------|
| **Subject(主题)** | `ApplicationEventPublisher` | `事件发布器` |
| **Event(事件)** | `ApplicationEvent` | `事件对象` |
| **Observer(观察者)** | `ApplicationListener` | `事件监听器` |
| **notify(通知)** | `publishEvent()` | `发布事件方法` |

**Spring的改进**：
- ✨ **自动注册**：监听器自动注册到容器
- ✨ **类型匹配**：根据事件类型自动分发
- ✨ **异步支持**：可异步处理事件
- ✨ **顺序控制**：支持监听器执行顺序

---

## 3. 🧩 Spring事件机制核心组件


### 3.1 ApplicationEvent - 事件对象


**作用**：封装事件信息，作为发布者和监听者之间的数据载体

```java
// Spring内置的事件基类
public abstract class ApplicationEvent extends EventObject {
    private final long timestamp;  // 事件发生时间
    
    public ApplicationEvent(Object source) {
        super(source);  // source是事件源
        this.timestamp = System.currentTimeMillis();
    }
}
```

**自定义事件示例**：

```java
// 用户注册事件
public class UserRegisterEvent extends ApplicationEvent {
    
    private User user;  // 携带用户信息
    
    public UserRegisterEvent(Object source, User user) {
        super(source);  // source通常是发布事件的Service
        this.user = user;
    }
    
    public User getUser() {
        return user;
    }
}
```

**事件对象要点**：
- 🔸 必须继承`ApplicationEvent`
- 🔸 `source`参数代表事件来源
- 🔸 可以携带业务需要的数据
- 🔸 事件对象是不可变的（线程安全）

### 3.2 ApplicationEventPublisher - 事件发布器


**作用**：负责发布事件，通知所有相关监听器

```java
@Service
public class UserService {
    
    // Spring自动注入事件发布器
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void registerUser(User user) {
        // 1. 业务逻辑：保存用户
        saveUser(user);
        
        // 2. 发布事件
        UserRegisterEvent event = new UserRegisterEvent(this, user);
        eventPublisher.publishEvent(event);
        
        // 发布后立即返回，后续由监听器处理
    }
}
```

**发布器特点**：
- ✅ 由Spring容器提供，直接注入使用
- ✅ `publishEvent()`方法发布事件
- ✅ 发布是同步的（默认），监听器执行完才返回
- ✅ 支持发布任意对象作为事件（Spring 4.2+）

### 3.3 ApplicationListener - 事件监听器


**作用**：监听感兴趣的事件，做出相应处理

**方式一：实现接口**

```java
// 监听用户注册事件 - 发送欢迎邮件
@Component
public class EmailListener implements ApplicationListener<UserRegisterEvent> {
    
    @Override
    public void onApplicationEvent(UserRegisterEvent event) {
        User user = event.getUser();
        // 发送欢迎邮件
        System.out.println("发送欢迎邮件给：" + user.getName());
    }
}
```

**方式二：使用@EventListener注解（推荐）**

```java
@Component
public class UserEventHandler {
    
    // 监听用户注册事件 - 赠送积分
    @EventListener
    public void handleRegister(UserRegisterEvent event) {
        User user = event.getUser();
        // 赠送新人积分
        System.out.println("赠送积分给：" + user.getName());
    }
    
    // 可以在一个类中监听多个事件
    @EventListener
    public void handleLogin(UserLoginEvent event) {
        // 处理登录事件
    }
}
```

**监听器要点**：
- 🔹 监听器必须是Spring Bean（`@Component`等）
- 🔹 泛型指定监听的事件类型
- 🔹 可以有多个监听器监听同一事件
- 🔹 默认按注册顺序执行

### 3.4 核心组件协作流程


```
完整事件流程：

  ┌─────────────┐
  │ UserService │ ← 业务代码
  └──────┬──────┘
         │ 1.发布事件
         ↓
  ┌─────────────────────┐
  │ EventPublisher      │ ← 事件发布器
  │ publishEvent()      │
  └──────┬──────────────┘
         │ 2.分发事件
         ↓
  ┌─────────────────────┐
  │ ApplicationContext  │ ← Spring容器
  │ (事件广播器)         │
  └──────┬──────────────┘
         │ 3.找到匹配的监听器
         ↓
  ┌──────────────┬──────────────┬──────────────┐
  │              │              │              │
  ↓              ↓              ↓              ↓
EmailListener  PointListener  SmsListener  LogListener
发送邮件       赠送积分       发送短信     记录日志
```

---

## 4. 🚀 事件发布与监听实战


### 4.1 基础事件发布


**场景**：用户注册成功，需要发送欢迎邮件和赠送积分

**步骤①：定义事件**

```java
// 用户注册事件
public class UserRegisterEvent extends ApplicationEvent {
    
    private final User user;
    private final String ip;  // 注册IP
    
    public UserRegisterEvent(Object source, User user, String ip) {
        super(source);
        this.user = user;
        this.ip = ip;
    }
    
    public User getUser() { return user; }
    public String getIp() { return ip; }
}
```

**步骤②：发布事件**

```java
@Service
public class UserService {
    
    @Autowired
    private ApplicationEventPublisher publisher;
    
    public void register(User user, String ip) {
        // 保存用户到数据库
        userRepository.save(user);
        
        // 发布注册事件
        publisher.publishEvent(new UserRegisterEvent(this, user, ip));
    }
}
```

**步骤③：监听处理**

```java
@Component
public class UserEventListener {
    
    // 监听器1：发送欢迎邮件
    @EventListener
    public void sendWelcomeEmail(UserRegisterEvent event) {
        User user = event.getUser();
        emailService.sendWelcome(user.getEmail());
        System.out.println("✉️ 欢迎邮件已发送给：" + user.getName());
    }
    
    // 监听器2：赠送新人积分
    @EventListener
    public void givePoints(UserRegisterEvent event) {
        User user = event.getUser();
        pointService.add(user.getId(), 100);
        System.out.println("💰 新人积分已赠送：" + user.getName());
    }
}
```

### 4.2 异步事件处理


**问题**：默认事件处理是**同步**的，监听器执行完才返回

**解决**：使用`@Async`注解实现异步处理

**配置异步支持**：

```java
@Configuration
@EnableAsync  // 开启异步支持
public class AsyncConfig {
    
    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);    // 核心线程数
        executor.setMaxPoolSize(10);    // 最大线程数
        executor.setQueueCapacity(100); // 队列容量
        executor.setThreadNamePrefix("event-");
        executor.initialize();
        return executor;
    }
}
```

**异步监听器**：

```java
@Component
public class AsyncEventListener {
    
    @Async  // 异步执行
    @EventListener
    public void handleAsync(UserRegisterEvent event) {
        System.out.println("异步处理开始，线程：" + Thread.currentThread().getName());
        // 耗时操作
        sendEmail(event.getUser());
        System.out.println("异步处理完成");
    }
}
```

**同步 vs 异步对比**：

```
同步执行：
register() → publishEvent() → Listener1 → Listener2 → 返回
                             (阻塞等待)

异步执行：
register() → publishEvent() → 返回
                    ↓
               (后台线程)
            Listener1、Listener2
```

### 4.3 条件监听与事件过滤


**场景**：只有VIP用户注册才发送豪华礼包

```java
@Component
public class VipEventListener {
    
    // 使用SpEL表达式过滤
    @EventListener(condition = "#event.user.vip == true")
    public void handleVipRegister(UserRegisterEvent event) {
        User user = event.getUser();
        System.out.println("🎁 VIP用户专属礼包：" + user.getName());
    }
}
```

**常用条件表达式**：

| 条件 | **SpEL表达式** | **说明** |
|-----|---------------|---------|
| **属性判断** | `#event.user.age > 18` | `年龄大于18` |
| **类型判断** | `#event.type == 'VIP'` | `类型为VIP` |
| **多条件** | `#event.user.vip && #event.amount > 1000` | `且关系` |
| **调用方法** | `#event.user.isActive()` | `调用对象方法` |

### 4.4 监听器执行顺序


**问题**：多个监听器的执行顺序不确定

**解决**：使用`@Order`注解指定顺序

```java
@Component
public class OrderedListener {
    
    @Order(1)  // 数字越小优先级越高
    @EventListener
    public void first(UserRegisterEvent event) {
        System.out.println("1️⃣ 第一个执行：验证用户信息");
    }
    
    @Order(2)
    @EventListener
    public void second(UserRegisterEvent event) {
        System.out.println("2️⃣ 第二个执行：赠送积分");
    }
    
    @Order(3)
    @EventListener
    public void third(UserRegisterEvent event) {
        System.out.println("3️⃣ 第三个执行：发送通知");
    }
}
```

**执行顺序规则**：
- 🔹 `@Order`值越小，优先级越高
- 🔹 默认优先级：`Ordered.LOWEST_PRECEDENCE`（最低）
- 🔹 同优先级：按注册顺序执行
- 🔹 异步监听器：`@Order`无效

---

## 5. 💡 事件驱动的优势与应用场景


### 5.1 发布订阅模式的优势


**核心优势**：

```
1️⃣ 组件松耦合
   发布者 ←→ 监听器  (互不依赖)
   
2️⃣ 易于扩展
   新增监听器 → 无需修改发布者代码
   
3️⃣ 职责单一
   每个监听器只关心自己的事
   
4️⃣ 异步处理
   主流程快速返回，后台慢慢处理
   
5️⃣ 响应式编程
   事件流驱动业务逻辑
```

**代码对比**：

```java
// ❌ 紧耦合方式
class OrderService {
    @Autowired EmailService emailService;
    @Autowired SmsService smsService;
    @Autowired LogService logService;
    
    void createOrder(Order order) {
        save(order);
        emailService.send(order);  // 强依赖
        smsService.send(order);    // 强依赖
        logService.record(order);  // 强依赖
    }
}

// ✅ 事件驱动方式
class OrderService {
    @Autowired ApplicationEventPublisher publisher;
    
    void createOrder(Order order) {
        save(order);
        publisher.publishEvent(new OrderCreatedEvent(order));
        // 其他服务自己决定怎么处理
    }
}
```

### 5.2 实际应用场景


**场景①：用户行为追踪**

```
用户操作 → 发布事件 → 多个系统响应

登录成功 → LoginEvent → 记录日志
                      → 更新登录时间
                      → 发送登录通知
                      → 风控检测
```

**场景②：订单业务流程**

```
订单创建 → OrderCreatedEvent → 发送确认邮件
                             → 扣减库存
                             → 通知物流
                             → 记录操作日志
                             → 数据统计
```

**场景③：系统集成**

```
本地业务 → 发布事件 → 同步到其他系统

用户信息变更 → UserUpdateEvent → CRM系统同步
                              → 数据仓库同步
                              → 推荐系统更新
```

### 5.3 事件驱动 vs 传统调用


| 维度 | **传统方法调用** | **事件驱动** |
|-----|----------------|------------|
| **耦合性** | `强耦合，直接依赖` | `松耦合，通过事件` |
| **扩展性** | `修改原代码` | `增加监听器` |
| **执行方式** | `同步执行` | `可同步可异步` |
| **错误影响** | `一环出错全崩` | `隔离处理` |
| **复杂度** | `简单直接` | `需要理解事件流` |
| **适用场景** | `简单流程` | `复杂解耦场景` |

### 5.4 使用事件机制的最佳实践


**✅ 适合使用事件的场景**：
- 一个操作需要触发多个后续动作
- 后续动作之间互不依赖
- 需要解耦不同模块
- 异步处理非关键业务

**❌ 不适合使用事件的场景**：
- 简单的方法调用
- 强依赖的业务流程
- 需要事务一致性的操作
- 调试困难时

**注意事项**：
> ⚠️ **事务问题**：事件监听器默认在同一事务中，监听器异常会导致发布者回滚
> 
> ⚠️ **性能考虑**：同步事件会阻塞主流程，耗时操作使用异步
> 
> ⚠️ **异常处理**：监听器异常不要影响其他监听器

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 事件驱动：程序执行由事件触发，而非固定流程
🔸 观察者模式：一对多依赖，状态变化自动通知
🔸 发布订阅：发布者和订阅者解耦，通过事件通信
🔸 三大组件：Event(事件)、Publisher(发布者)、Listener(监听器)
🔸 同步异步：默认同步，可用@Async实现异步
```

### 6.2 关键理解要点


**🔹 为什么需要事件机制**
```
问题：代码耦合严重，扩展困难
解决：通过事件解耦，各模块独立
效果：易扩展、易维护、可异步
```

**🔹 事件发布的本质**
```
本质：不是方法调用，是消息通知
特点：发布者不关心谁来处理
好处：新增处理逻辑不影响发布者
```

**🔹 监听器的执行机制**
```
触发：容器自动匹配事件类型
执行：默认同步，可配置异步
顺序：@Order控制，数字越小越优先
```

### 6.3 实战开发指南


**基础使用步骤**：
```
1️⃣ 定义事件类（继承ApplicationEvent）
2️⃣ 发布事件（注入ApplicationEventPublisher）
3️⃣ 监听事件（@EventListener注解）
4️⃣ 异步处理（@Async注解 + @EnableAsync配置）
```

**常见应用场景**：
- 🎯 用户行为：注册、登录、下单等触发多个后续操作
- 🎯 系统集成：本地操作同步到其他系统
- 🎯 日志审计：关键操作自动记录日志
- 🎯 消息通知：业务变更自动推送消息

**避坑指南**：
```
❌ 避免事件链过长（事件触发事件）
❌ 避免循环事件（A→B→A）
❌ 注意事务边界（监听器异常处理）
❌ 异步事件无法参与事务回滚
```

### 6.4 进阶扩展方向


**响应式编程**：
- Spring的事件机制是响应式编程的基础
- 可以结合Reactor、RxJava实现更强大的事件流处理

**分布式事件**：
- 结合消息队列（RabbitMQ、Kafka）实现跨系统事件
- Spring Cloud Stream提供统一的事件驱动模型

**事件溯源**：
- Event Sourcing模式，用事件记录所有状态变化
- 可以重放事件恢复系统状态

**核心记忆口诀**：
```
事件驱动解耦合，观察模式做支撑
发布订阅三角色，Event发布Listener听
同步异步自选择，条件过滤更精准
场景合适威力大，滥用反而添麻烦
```