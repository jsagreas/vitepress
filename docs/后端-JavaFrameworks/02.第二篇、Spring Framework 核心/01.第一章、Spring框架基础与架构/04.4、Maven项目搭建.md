---
title: 4、Maven项目搭建
---
## 📚 目录

1. [Maven与Spring的关系](#1-Maven与Spring的关系)
2. [核心依赖配置详解](#2-核心依赖配置详解)
3. [BOM版本管理机制](#3-BOM版本管理机制)
4. [依赖传递原理](#4-依赖传递原理)
5. [版本冲突解决方案](#5-版本冲突解决方案)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔗 Maven与Spring的关系


### 1.1 Maven是什么？为什么需要它？


**通俗理解**：Maven就像是Java项目的"自动化管家"

```
传统方式的痛点：
程序员A：我需要Spring框架！
        → 去官网下载jar包
        → 手动复制到项目lib目录
        → 配置classpath
        → 发现还缺其他依赖...😫

使用Maven后：
程序员B：我需要Spring框架！
        → 在pom.xml写一行配置
        → Maven自动下载Spring及其所有依赖
        → 全部配置好，开箱即用！😊
```

**核心作用**：
- **依赖管理**：自动下载和管理项目所需的jar包
- **项目构建**：统一的编译、测试、打包流程
- **版本控制**：统一管理所有依赖的版本号

### 1.2 Maven项目结构


```
spring-demo/
├── pom.xml                 ← Maven配置文件（核心！）
├── src/
│   ├── main/
│   │   ├── java/          ← 存放Java源代码
│   │   └── resources/     ← 存放配置文件
│   └── test/
│       └── java/          ← 存放测试代码
└── target/                ← 编译后的文件（自动生成）
```

**为什么这样设计？**
- 📁 **约定优于配置**：大家都用这个结构，团队协作更方便
- 🔄 **自动化处理**：Maven知道去哪找源码、去哪输出结果
- 🧹 **清晰分离**：代码、资源、测试各司其职

---

## 2. 📦 核心依赖配置详解


### 2.1 spring-context依赖


**🔸 是什么？**
`spring-context`是Spring框架的"大管家"，提供了Spring容器的核心功能。

**通俗比喻**：
```
Spring容器 = 智能工厂
spring-context = 工厂的管理系统

你只需要告诉它"我要一个用户服务"
它会自动：
1. 创建用户服务对象
2. 找到它需要的数据库连接
3. 把数据库连接注入进去
4. 返回配置好的用户服务给你
```

**配置方式**：
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.1.3</version>
</dependency>
```

**配置解读**：
- `groupId`：组织名称（就像公司名）
- `artifactId`：项目名称（就像产品名）
- `version`：版本号（选择需要的版本）

### 2.2 spring-core依赖


**🔸 是什么？**
`spring-core`是Spring框架的"基础设施"，提供最底层的核心工具类。

**它与spring-context的关系**：
```
建房子的比喻：
spring-core     = 砖头、水泥、钢筋（基础材料）
spring-context  = 完整的房子（可以直接住）

关键理解：
你只需要添加spring-context依赖
Maven会自动帮你下载spring-core（依赖传递）
不需要手动添加spring-core！
```

**为什么通常不直接配置？**
```xml
<!-- ❌ 不推荐：手动添加spring-core -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>6.1.3</version>
</dependency>

<!-- ✅ 推荐：只添加spring-context -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.1.3</version>
    <!-- spring-core会被自动下载 -->
</dependency>
```

### 2.3 完整的Spring基础配置


```xml
<project>
    <modelVersion>4.0.0</modelVersion>
    
    <!-- 项目基本信息 -->
    <groupId>com.example</groupId>
    <artifactId>spring-demo</artifactId>
    <version>1.0-SNAPSHOT</version>
    
    <dependencies>
        <!-- Spring核心容器 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>6.1.3</version>
        </dependency>
        
        <!-- 日志框架（Spring需要） -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.4.14</version>
        </dependency>
    </dependencies>
</project>
```

---

## 3. 🎯 BOM版本管理机制


### 3.1 什么是BOM？


**BOM = Bill of Materials（物料清单）**

**通俗理解**：
```
买电脑的比喻：
传统方式：
- CPU选Intel i7（自己查价格）
- 内存选金士顿16G（自己查价格）
- 硬盘选三星1T（自己查价格）
→ 需要自己确保兼容性！

使用BOM：
- 选择"游戏本套餐2024版"
- 所有配件版本已经配好
- 保证100%兼容
→ 省心省力！
```

### 3.2 Spring BOM配置


**🔸 为什么需要BOM？**

| 问题场景 | **不用BOM** | **使用BOM** |
|---------|------------|------------|
| **版本指定** | `每个依赖都要写版本号` | `统一由BOM管理版本` |
| **版本冲突** | `可能出现版本不兼容` | `版本已测试兼容` |
| **升级维护** | `每个版本都要手动改` | `只改BOM版本号` |

**配置方式**：
```xml
<dependencyManagement>
    <dependencies>
        <!-- Spring BOM：统一管理所有Spring依赖版本 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-framework-bom</artifactId>
            <version>6.1.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- 不需要写version，由BOM统一管理 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-web</artifactId>
    </dependency>
</dependencies>
```

### 3.3 BOM工作原理


```
版本管理流程：

1. 定义阶段（dependencyManagement）
   ┌─────────────────────────────┐
   │ Spring BOM 6.1.3            │
   │ ├─ spring-context: 6.1.3    │
   │ ├─ spring-core: 6.1.3       │
   │ ├─ spring-web: 6.1.3        │
   │ └─ ...                      │
   └─────────────────────────────┘

2. 使用阶段（dependencies）
   我要：spring-context
   ↓
   查BOM：找到版本6.1.3
   ↓
   自动使用：spring-context:6.1.3
```

**关键理解**：
- `dependencyManagement`：只是**定义**版本，不会真正下载
- `dependencies`：真正**使用**依赖，版本从BOM继承

---

## 4. 🔄 依赖传递原理


### 4.1 什么是依赖传递？


**通俗比喻**：
```
请客吃饭的连锁反应：

你邀请了张三（spring-context）
张三说：我要带李四（spring-core）
李四说：我要带王五（spring-jcl）

结果：
你只邀请了1个人（spring-context）
实际来了3个人（依赖传递）
```

### 4.2 依赖层级示例


```
你的项目
└── spring-context (6.1.3)           ← 直接依赖
    ├── spring-aop (6.1.3)           ← 传递依赖（自动下载）
    ├── spring-beans (6.1.3)         ← 传递依赖
    ├── spring-core (6.1.3)          ← 传递依赖
    │   └── spring-jcl (6.1.3)       ← 传递依赖的传递依赖
    └── spring-expression (6.1.3)     ← 传递依赖
```

**为什么需要这些？**
- `spring-beans`：创建和管理对象
- `spring-aop`：面向切面编程支持
- `spring-core`：核心工具类
- `spring-expression`：表达式语言支持

### 4.3 依赖范围（Scope）


| Scope类型 | **何时生效** | **是否传递** | **典型用途** |
|----------|------------|------------|------------|
| **compile** | `编译+测试+运行` | `✅ 是` | `Spring框架核心` |
| **test** | `仅测试` | `❌ 否` | `JUnit测试框架` |
| **provided** | `编译+测试` | `❌ 否` | `Servlet API（服务器提供）` |
| **runtime** | `测试+运行` | `✅ 是` | `MySQL驱动` |

**实际配置**：
```xml
<!-- 编译、测试、运行都需要 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <scope>compile</scope> <!-- 默认值，可省略 -->
</dependency>

<!-- 只在测试时需要 -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <scope>test</scope>
</dependency>
```

---

## 5. ⚠️ 版本冲突解决方案


### 5.1 版本冲突是如何产生的？


**场景模拟**：
```
你的项目依赖：
├── 模块A → 依赖 spring-core 5.3.0
└── 模块B → 依赖 spring-core 6.1.3

问题：Maven该选哪个版本？🤔
```

### 5.2 Maven的仲裁机制


**🔸 规则1：最短路径优先**
```
依赖路径对比：

路径1：你的项目 → 模块A → spring-core 5.3.0  (长度2)
路径2：你的项目 → spring-core 6.1.3          (长度1)

结果：选择6.1.3（路径更短）
```

**🔸 规则2：声明顺序优先**
```xml
<!-- 路径长度相同时，看谁先声明 -->
<dependencies>
    <dependency><!-- 这个先声明，优先级高 --></dependency>
    <dependency><!-- 这个后声明 --></dependency>
</dependencies>
```

### 5.3 冲突解决实战


**方法1：使用BOM统一版本**
```xml
<!-- ✅ 最佳实践：让BOM管理所有Spring版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-framework-bom</artifactId>
            <version>6.1.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**方法2：显式排除冲突依赖**
```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>module-a</artifactId>
    <version>1.0</version>
    <exclusions>
        <!-- 排除它自带的旧版本Spring -->
        <exclusion>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

**方法3：强制指定版本**
```xml
<!-- 在dependencyManagement中强制指定 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>6.1.3</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### 5.4 冲突检测工具


**🔧 使用Maven命令查看依赖树**
```bash
# 查看完整依赖树
mvn dependency:tree

# 查看特定依赖的冲突
mvn dependency:tree -Dverbose -Dincludes=org.springframework:spring-core
```

**输出示例解读**：
```
[INFO] com.example:spring-demo:jar:1.0-SNAPSHOT
[INFO] \- org.springframework:spring-context:jar:6.1.3:compile
[INFO]    +- org.springframework:spring-core:jar:6.1.3:compile
[INFO]    |  \- org.springframework:spring-jcl:jar:6.1.3:compile
[INFO]    +- (org.springframework:spring-core:jar:5.3.0:compile - omitted for conflict with 6.1.3)
                                                                   ↑
                                                        这里显示被忽略的版本
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的基本概念


```
🔸 Maven作用：自动化的依赖管理和项目构建工具
🔸 核心依赖：spring-context（会自动引入spring-core等）
🔸 BOM管理：统一管理Spring全家桶的版本，避免冲突
🔸 依赖传递：添加一个依赖，相关依赖自动下载
🔸 冲突解决：优先使用BOM，必要时用exclusion排除
```

### 6.2 最佳实践建议


**✅ 推荐做法**：
```xml
<!-- 1. 使用BOM管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-framework-bom</artifactId>
            <version>6.1.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- 2. 依赖不写版本号 -->
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
    </dependency>
</dependencies>
```

**❌ 避免做法**：
- 手动添加spring-core（会自动传递）
- 每个依赖都手写版本号（难以维护）
- 混用不同版本的Spring模块（容易冲突）

### 6.3 快速上手检查清单


| 检查项 | **说明** |
|-------|---------|
| ✅ `pom.xml存在` | `Maven项目必备文件` |
| ✅ `添加spring-context` | `Spring核心依赖` |
| ✅ `配置BOM管理` | `版本统一管理（可选但推荐）` |
| ✅ `添加日志依赖` | `logback或log4j2` |
| ✅ `运行dependency:tree` | `检查依赖是否正常` |

### 6.4 常见问题速查


**Q1：为什么只添加spring-context就够了？**
> A：因为spring-context会通过依赖传递自动引入spring-core、spring-beans等核心模块

**Q2：BOM是必须的吗？**
> A：不是必须，但强烈推荐。它能避免版本冲突，简化配置

**Q3：如何升级Spring版本？**
> A：使用BOM时，只需修改BOM的version即可，所有Spring依赖自动升级

**Q4：遇到版本冲突怎么办？**
> A：优先使用BOM；如果还冲突，用`<exclusion>`排除，或在`<dependencyManagement>`强制指定版本

---

**🧠 记忆口诀**
```
Maven管理真方便，pom文件是关键
spring-context最核心，自动传递不用烦
BOM统一管版本，冲突问题不再见
依赖树工具常查看，问题排查更简单
```