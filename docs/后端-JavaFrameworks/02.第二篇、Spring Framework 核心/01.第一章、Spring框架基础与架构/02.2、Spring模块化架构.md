---
title: 2、Spring模块化架构
---
## 📚 目录

1. [Spring框架是什么](#1-Spring框架是什么)
2. [Core Container核心容器](#2-Core-Container核心容器)
3. [AOP模块面向切面编程](#3-AOP模块面向切面编程)
4. [Data Access数据访问层](#4-Data-Access数据访问层)
5. [Web模块](#5-Web模块)
6. [Testing测试模块](#6-Testing测试模块)
7. [模块依赖关系](#7-模块依赖关系)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌱 Spring框架是什么


### 1.1 Spring的本质理解


**🔸 用大白话说Spring**
```
想象你在搭积木：
❌ 传统方式：每块积木都要自己手工制作，还要自己拼接
✅ Spring方式：积木都准备好了，你只需要告诉Spring怎么组装

Spring就是一个"智能管家"，帮你：
• 管理各种对象（不用你new来new去）
• 处理对象之间的关系（自动帮你连接）
• 提供各种现成工具（数据库、网络等）
```

**💡 Spring解决什么问题**
```
没有Spring的痛苦：
程序员A：我需要一个数据库连接
程序员A：我要手动创建连接对象
程序员A：用完要记得关闭
程序员A：每个地方都要重复写这些代码...😫

有了Spring之后：
程序员B：@Autowired DataSource dataSource （Spring自动给你）
程序员B：直接用就行，Spring会自动管理 😊
```

### 1.2 Spring的模块化思想


**🏗️ 为什么要模块化**
```
类比：装修房子

不模块化（一锅炖）：
┌─────────────────────────┐
│ 所有功能混在一起         │
│ 电线、水管、装饰都杂乱   │
│ 想改一个地方，全部受影响 │
└─────────────────────────┘

模块化（各司其职）：
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 水电模块 │  │ 装修模块 │  │ 家具模块 │
│ 独立维护 │  │ 独立维护 │  │ 独立维护 │
└─────────┘  └─────────┘  └─────────┘

想换沙发？只动家具模块，其他不影响！
```

**📦 Spring模块全景图**
```
                    Spring Framework
                           |
        ┌──────────────────┼──────────────────┐
        |                  |                  |
   Core Container         AOP              Data Access
   （核心容器）         （切面编程）        （数据访问）
        |                  |                  |
    管理对象            处理通用功能         操作数据库
        |                  |                  |
        └──────────────────┼──────────────────┘
                           |
                    ┌──────┴──────┐
                    |             |
                  Web         Testing
               （网络层）      （测试）
```

---

## 2. 🎯 Core Container核心容器


### 2.1 什么是核心容器


**🔸 用生活例子理解**
```
核心容器 = 智能仓库管理员

传统写代码：
你要用什么对象，就new一个
UserService userService = new UserService();
OrderService orderService = new OrderService();
// 自己管理这些对象的创建和销毁

有了核心容器：
容器说："你告诉我需要什么，我来给你准备好"
@Autowired UserService userService;  // 容器自动给你
// 你只管用，创建和销毁都是容器负责
```

### 2.2 核心容器的四大组件


#### 📦 spring-core（核心工具包）


**作用**：提供最基础的工具类
```
像工具箱里的基础工具：
🔧 锤子、螺丝刀、扳手 → 最基本的工具
📏 各种辅助工具类 → 帮你处理琐碎事情

实际包含：
• 资源访问工具
• 类型转换工具
• 工具类和常量定义
```

#### 🫘 spring-beans（对象工厂）


**作用**：专门用来创建和管理对象
```
理解Bean（豆子）：
在Spring里，每个对象都叫Bean（像一颗颗豆子）

spring-beans做什么：
1. 🏭 Bean工厂：批量生产对象
2. 📋 Bean定义：记录每个对象怎么创建
3. 🔗 Bean关系：处理对象之间的依赖

举例：
<bean id="userService" class="com.example.UserService"/>
↑ 告诉Spring："我需要一个UserService对象"
Spring："好的，我帮你创建并管理好"
```

#### 🎯 spring-context（上下文环境）


**作用**：提供运行环境和高级功能
```
context = 应用程序的运行环境

就像手机系统：
📱 iOS/Android = Spring Context
📦 各个App = 你的Bean对象
🔌 系统服务 = Spring提供的各种功能

提供功能：
• 国际化（多语言支持）
• 事件传播（消息通知）
• 资源加载（读取配置文件）
• 上下文管理（应用环境）
```

**💡 ApplicationContext示例**
```java
// 创建Spring容器（应用上下文）
ApplicationContext context = 
    new ClassPathXmlApplicationContext("applicationContext.xml");

// 从容器中获取对象（不用new了）
UserService userService = context.getBean(UserService.class);

/* 背后发生了什么：
 * 1. Spring读取配置文件
 * 2. 自动创建所有需要的对象
 * 3. 自动处理对象之间的依赖关系
 * 4. 你直接用就行！
 */
```

#### 🔍 spring-expression（表达式语言）


**作用**：用简单表达式访问和操作对象
```
SpEL（Spring表达式语言）= 简化版的查询语言

类比SQL：
SQL：SELECT name FROM user WHERE id=1
SpEL：#{user.name} → 直接获取user对象的name属性

实际用处：
@Value("#{systemProperties['user.name']}")  // 获取系统属性
@Value("#{userBean.age > 18}")              // 判断条件
```

### 2.3 核心容器工作原理


**🔄 从创建到使用的完整流程**
```
第一步：定义Bean（告诉Spring你需要什么对象）
┌─────────────────────────────┐
│ @Component                  │
│ public class UserService {  │
│     // 你的业务代码          │
│ }                           │
└─────────────────────────────┘
         ↓
第二步：Spring扫描并创建对象
┌─────────────────────────────┐
│ Spring容器启动              │
│ → 扫描@Component注解        │
│ → 创建UserService对象       │
│ → 放入容器中保存             │
└─────────────────────────────┘
         ↓
第三步：需要时自动注入
┌─────────────────────────────┐
│ @Controller                 │
│ public class UserController {│
│   @Autowired               │
│   UserService userService; │ ← Spring自动注入
│ }                          │
└─────────────────────────────┘
```

---

## 3. ✂️ AOP模块面向切面编程


### 3.1 AOP到底是什么


**🔸 用生活例子理解AOP**
```
场景：你开了一家餐厅

没有AOP的做法：
服务员A：迎接客人 → 点菜 → 记录日志 → 上菜 → 记录日志 → 结账
服务员B：迎接客人 → 点菜 → 记录日志 → 上菜 → 记录日志 → 结账
服务员C：迎接客人 → 点菜 → 记录日志 → 上菜 → 记录日志 → 结账
↑ 每个人都要重复"记录日志"这个动作

有了AOP：
经理："所有服务员，只管做自己的事（点菜、上菜）"
经理："记录日志的事，我安排专人在旁边统一做"
专员："我在每个关键步骤自动记录，你们不用管"

结果：
• 服务员专注核心工作
• 日志统一管理
• 代码不重复
```

### 3.2 AOP解决什么问题


**❌ 没有AOP的痛苦**
```java
public class UserService {
    public void addUser(User user) {
        System.out.println("开始记录日志...");  // 重复代码
        
        // 核心业务：添加用户
        userDao.save(user);
        
        System.out.println("结束记录日志...");  // 重复代码
    }
    
    public void deleteUser(int id) {
        System.out.println("开始记录日志...");  // 又重复了！
        
        // 核心业务：删除用户
        userDao.delete(id);
        
        System.out.println("结束记录日志...");  // 还是重复！
    }
}
```

**✅ 有了AOP之后**
```java
public class UserService {
    // 只写核心业务逻辑，日志由AOP自动添加
    public void addUser(User user) {
        userDao.save(user);  // 干净清爽
    }
    
    public void deleteUser(int id) {
        userDao.delete(id);  // 同样干净
    }
}

// 日志功能统一定义在切面中
@Aspect
public class LogAspect {
    @Before("所有Service方法")
    public void logBefore() {
        System.out.println("开始记录日志...");
    }
    
    @After("所有Service方法")
    public void logAfter() {
        System.out.println("结束记录日志...");
    }
}
```

### 3.3 AOP核心概念通俗解释


**📋 AOP术语对照表**

| 专业术语 | 大白话 | 生活例子 |
|---------|--------|---------|
| **切面 (Aspect)** | `一个功能模块` | `餐厅的"记录员"这个角色` |
| **切入点 (Pointcut)** | `在哪些地方生效` | `"所有上菜环节"都要记录` |
| **通知 (Advice)** | `具体做什么事` | `"写下时间和菜名"这个动作` |
| **连接点 (JoinPoint)** | `可以插入的时机` | `点菜前、上菜后、结账时` |
| **织入 (Weaving)** | `把功能加进去` | `把记录员安排到工作流程中` |

**🎯 通知类型详解**
```
通知 = 在什么时候执行额外操作

@Before（前置通知）：方法执行之前
    例：进门先测体温

@After（后置通知）：方法执行之后
    例：离开时说"谢谢光临"

@AfterReturning（返回通知）：方法正常返回后
    例：考试及格才发奖状

@AfterThrowing（异常通知）：方法抛异常后
    例：摔倒了赶紧扶起来

@Around（环绕通知）：方法执行前后都可以控制
    例：进门和出门都要刷卡
```

### 3.4 AOP实际应用场景


**🔥 最常见的5大用途**
```
1️⃣ 日志记录
   • 自动记录谁在什么时间做了什么操作
   • 不用每个方法都写日志代码

2️⃣ 性能监控
   • 自动统计每个方法执行时间
   • 发现哪个方法慢

3️⃣ 事务管理
   • 自动开启/提交/回滚事务
   • 不用手动管理

4️⃣ 权限检查
   • 方法执行前自动检查用户权限
   • 统一鉴权逻辑

5️⃣ 异常处理
   • 统一捕获和处理异常
   • 避免到处写try-catch
```

---

## 4. 💾 Data Access数据访问层


### 4.1 为什么需要数据访问层


**🔸 数据访问的本质问题**
```
程序要和数据库打交道，就像：

原始方式（JDBC）：
你："我要去北京"
你：自己买票、查路线、订酒店、安排行程...
↑ 麻烦、容易出错、重复工作多

Spring Data Access：
你："我要去北京"
旅行社：机票、酒店、行程全包，你直接出发
↑ 简单、不易出错、专注旅游本身
```

### 4.2 spring-jdbc模块


**🔧 JDBC的痛点与解决**
```
原生JDBC写法（痛苦）：
1. 加载驱动
2. 获取连接
3. 创建Statement
4. 执行SQL
5. 处理结果集
6. 关闭资源（必须放在finally）
7. 处理各种异常

每次操作数据库都要重复这7步！😫
```

**💡 JdbcTemplate简化版**
```java
// 原生JDBC：至少30行代码
Connection conn = null;
PreparedStatement ps = null;
ResultSet rs = null;
try {
    conn = dataSource.getConnection();
    ps = conn.prepareStatement("SELECT * FROM user WHERE id = ?");
    ps.setInt(1, userId);
    rs = ps.executeQuery();
    // ... 处理结果
} catch (SQLException e) {
    // ... 异常处理
} finally {
    // ... 关闭资源（容易忘记）
}

// Spring JdbcTemplate：2行代码搞定
User user = jdbcTemplate.queryForObject(
    "SELECT * FROM user WHERE id = ?",
    new BeanPropertyRowMapper<>(User.class),
    userId
);
```

### 4.3 spring-orm模块


**🔸 ORM是什么**
```
ORM = Object-Relational Mapping（对象关系映射）

大白话：让你用Java对象的方式操作数据库

传统方式：
你要写SQL → "SELECT * FROM user WHERE name = ?"
        → 手动把查询结果转成User对象

ORM方式：
你直接操作对象 → userRepository.findByName("张三")
                → 自动查询并返回User对象

就像：
❌ 传统：你要自己翻译中英文
✅ ORM：有个翻译官自动帮你翻译
```

**🔗 支持的ORM框架**
```
Spring-ORM支持整合：

1️⃣ Hibernate（最流行）
   • 功能强大、成熟稳定
   • 自动生成SQL

2️⃣ JPA（Java规范）
   • 标准化接口
   • 可以切换不同实现

3️⃣ MyBatis（国内最爱）
   • SQL可控、灵活
   • 半自动ORM
```

### 4.4 spring-tx事务管理


**🔸 什么是事务**
```
事务 = 要么全做，要么全不做

生活例子：转账
1. 从A账户扣100元
2. 给B账户加100元

问题：如果扣钱成功，加钱失败怎么办？
答案：用事务！要么都成功，要么都撤销

┌─────────────────────┐
│ 开始事务            │
│  ↓                 │
│ A账户 -100         │
│  ↓                 │
│ B账户 +100 ✗失败   │
│  ↓                 │
│ 回滚事务（A的钱还回去）│
└─────────────────────┘
```

**💡 Spring事务管理示例**
```java
// 不用Spring：手动管理事务（容易出错）
Connection conn = null;
try {
    conn = dataSource.getConnection();
    conn.setAutoCommit(false);  // 开启事务
    
    // 业务操作
    accountDao.deduct(accountA, 100);
    accountDao.add(accountB, 100);
    
    conn.commit();  // 提交事务
} catch (Exception e) {
    conn.rollback();  // 回滚事务
}

// 用Spring：一个注解搞定
@Transactional
public void transfer(int accountA, int accountB, int amount) {
    accountDao.deduct(accountA, amount);
    accountDao.add(accountB, amount);
    // 异常自动回滚，成功自动提交
}
```

---

## 5. 🌐 Web模块


### 5.1 Web模块的作用


**🔸 处理网络请求**
```
Web模块 = 网站的前台接待员

用户在浏览器输入网址 → Web模块接收请求
用户提交表单数据     → Web模块处理数据
用户点击按钮         → Web模块响应操作

流程图：
用户浏览器 → Spring Web模块 → 业务逻辑 → 数据库
         ←               ←          ←
       返回网页         处理结果    查询数据
```

### 5.2 spring-web基础模块


**🔧 提供的核心功能**
```
1️⃣ 多部分文件上传
   • 处理用户上传的图片、文档
   • 自动解析文件流

2️⃣ Servlet监听器
   • 监听应用启动/关闭
   • 监听会话创建/销毁

3️⃣ Web应用上下文
   • Web环境专用的Spring容器
   • 管理Web相关的Bean
```

### 5.3 spring-webmvc核心框架


**🎯 什么是MVC**
```
MVC = Model-View-Controller（模型-视图-控制器）

用餐厅比喻：
┌──────────┐    ┌──────────┐    ┌──────────┐
│ 顾客     │───→│ 服务员   │───→│ 厨师     │
│ (View)   │    │(Controller)│   │ (Model)  │
│          │←───│          │←───│          │
│ 看菜单   │    │ 传达需求 │    │ 做菜     │
│ 吃饭     │    │ 上菜     │    │ 准备食材 │
└──────────┘    └──────────┘    └──────────┘

对应到代码：
• Model（模型）：数据和业务逻辑
• View（视图）：展示页面
• Controller（控制器）：接收请求，调用业务，返回视图
```

**💡 SpringMVC处理流程**
```
用户请求：http://localhost:8080/user/list

第1步：DispatcherServlet接收请求
      ↓
第2步：查找对应的Controller
      ↓
第3步：Controller处理业务逻辑
      ↓  
第4步：返回ModelAndView（数据+视图）
      ↓
第5步：渲染视图，返回HTML给用户

代码示例：
@Controller
public class UserController {
    @RequestMapping("/user/list")
    public ModelAndView getUserList() {
        List<User> users = userService.findAll();
        ModelAndView mv = new ModelAndView("userList");
        mv.addObject("users", users);
        return mv;  // 返回视图和数据
    }
}
```

### 5.4 spring-websocket实时通信


**🔸 什么是WebSocket**
```
传统HTTP：一问一答（单向通信）
客户端：请求数据
服务器：返回数据
客户端：又请求...（反复轮询，浪费资源）

WebSocket：建立持久连接（双向通信）
客户端 ←→ 服务器
    实时消息推送
    服务器主动发送

应用场景：
• 💬 在线聊天（微信网页版）
• 📊 实时数据（股票行情）
• 🎮 在线游戏（实时对战）
• 📢 消息通知（系统提醒）
```

---

## 6. 🧪 Testing测试模块


### 6.1 为什么需要测试


**🔸 测试的重要性**
```
没有测试的开发：
写代码 → 部署上线 → 用户发现Bug → 紧急修复 → 又出Bug...
       ↑ 在生产环境发现问题，代价巨大！

有测试的开发：
写代码 → 写测试 → 发现Bug → 修复 → 再测试 → 上线稳定
              ↑ 在开发阶段发现问题，成本低！

就像：
❌ 房子盖好了才发现地基有问题
✅ 盖房过程中每一步都检查质量
```

### 6.2 spring-test功能


**🔧 提供的测试支持**
```
1️⃣ 单元测试支持
   • 测试单个类、方法
   • 快速验证逻辑正确性

2️⃣ 集成测试支持
   • 测试多个模块配合
   • 验证整体功能

3️⃣ Mock对象支持
   • 模拟外部依赖
   • 隔离测试环境
```

**💡 测试示例**
```java
// 传统测试（麻烦）
public class UserServiceTest {
    public static void main(String[] args) {
        UserService service = new UserService();
        User user = service.findById(1);
        if (user != null) {
            System.out.println("测试通过");
        } else {
            System.out.println("测试失败");
        }
    }
}

// Spring测试（简单）
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserServiceTest {
    @Autowired
    private UserService userService;
    
    @Test
    public void testFindById() {
        User user = userService.findById(1);
        assertNotNull(user);  // 自动判断，自动报告
    }
}
```

---

## 7. 🔗 模块依赖关系


### 7.1 依赖关系图


**🏗️ 模块之间的依赖**
```
            ┌─────────────┐
            │   Testing   │
            │   (测试)    │
            └──────┬──────┘
                   │ 依赖所有模块
        ┌──────────┼──────────┐
        │          │          │
   ┌────▼────┐ ┌──▼───┐ ┌────▼─────┐
   │   Web   │ │ AOP  │ │Data Access│
   │ (网络)  │ │(切面)│ │ (数据)   │
   └────┬────┘ └──┬───┘ └────┬─────┘
        │         │          │
        └─────────┼──────────┘
                  │ 都依赖
           ┌──────▼──────┐
           │Core Container│
           │  (核心容器)  │
           └─────────────┘
                  ↑
            最底层、最核心
```

### 7.2 核心依赖规则


**📋 依赖层级说明**
```
第1层：Core Container（核心容器）
   • 最基础的层
   • 所有其他模块都依赖它
   • 提供IoC和DI功能

第2层：AOP、Data Access、Web
   • 建立在核心容器之上
   • 提供具体功能
   • 可以独立使用

第3层：Testing
   • 用于测试其他所有模块
   • 依赖所有需要测试的模块
```

**🔸 实际使用建议**
```
基础项目（只需要IoC/DI）：
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
</dependency>

Web项目（需要MVC）：
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <!-- 会自动引入spring-context等依赖 -->
</dependency>

数据库项目（需要数据访问）：
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <!-- 会自动引入spring-tx等依赖 -->
</dependency>
```

### 7.3 模块选择指南


**🎯 根据需求选择模块**

| 项目类型 | 必选模块 | 可选模块 | 说明 |
|---------|---------|---------|------|
| **纯Java应用** | `Core Container` | `AOP` | `只需要对象管理` |
| **Web应用** | `Core + Web` | `AOP + Data Access` | `处理HTTP请求` |
| **数据库应用** | `Core + Data Access` | `AOP + Web` | `操作数据库` |
| **企业级应用** | `全部模块` | - | `完整功能支持` |

---

## 8. 📋 核心要点总结


### 8.1 必须记住的关键点


**🔸 Spring模块化架构精髓**
```
1️⃣ Core Container（核心中的核心）
   • IoC容器：管理对象生命周期
   • DI注入：自动处理对象依赖
   • 记忆：Spring的"心脏"

2️⃣ AOP（解决代码重复）
   • 切面编程：统一处理通用功能
   • 应用：日志、事务、权限、监控
   • 记忆：让代码更"干净"

3️⃣ Data Access（数据访问简化）
   • JDBC：简化数据库操作
   • ORM：对象方式操作数据
   • TX：自动事务管理
   • 记忆：让数据库操作更"简单"

4️⃣ Web（处理网络请求）
   • MVC：清晰的三层架构
   • RESTful：现代API设计
   • WebSocket：实时通信
   • 记忆：让Web开发更"规范"

5️⃣ Testing（保证质量）
   • 单元测试：测试单个功能
   • 集成测试：测试整体流程
   • 记忆：让代码更"可靠"
```

### 8.2 学习建议


**📚 学习路线推荐**
```
第一阶段（基础）：
→ Core Container（2-3天）
  掌握IoC和DI概念
  会配置Bean和注入

第二阶段（进阶）：
→ AOP（1-2天）
  理解切面编程思想
  会写基本切面

→ Data Access（2-3天）
  掌握JdbcTemplate
  理解事务管理

第三阶段（实战）：
→ Web（3-5天）
  掌握SpringMVC
  能写完整的Web应用

第四阶段（提升）：
→ Testing（1-2天）
  会写单元测试
  会写集成测试
```

### 8.3 记忆口诀


**🎯 快速记忆法**
```
Spring模块五大家，
核心容器是老大。
AOP切面除重复，
数据访问靠它俩（JDBC+ORM）。
Web模块做网站，
测试保证不出差。
模块组合随意搭，
按需选择顶呱呱！
```

**💡 核心理念**
```
• 模块化：各司其职，互不干扰
• 低耦合：模块独立，灵活组合
• 高内聚：功能集中，便于维护
• 易测试：支持完善，质量保证
```

---

> **⭐ 学习小贴士**
> 
> 1. 先理解Core Container，这是基础中的基础
> 2. 不要急于掌握所有模块，按需学习
> 3. 多动手写代码，理论要结合实践
> 4. 遇到问题先查官方文档，再问AI
> 5. 加入开发社区，和大家一起学习进步