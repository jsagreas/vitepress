---
title: 9、JavaConfig基础
---
## 📚 目录导航

1. [JavaConfig是什么](#1-JavaConfig是什么)
2. [@Configuration配置类](#2-Configuration配置类)
3. [@Bean方法定义](#3-Bean方法定义)
4. [方法间依赖调用](#4-方法间依赖调用)
5. [生命周期方法](#5-生命周期方法)
6. [作用域配置](#6-作用域配置)
7. [条件判断](#7-条件判断)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 JavaConfig是什么


### 1.1 通俗理解JavaConfig


**🌰 生活场景类比**
想象你在开一家咖啡店，传统XML配置就像写一份详细的文字说明书，而JavaConfig就像直接用代码"搭建"这个咖啡店。

```
传统方式（XML）：写一份配置文件
"我需要一个咖啡机，品牌是XXX，型号是YYY..."

JavaConfig方式：直接用Java代码创建
public CoffeeMachine coffeeMachine() {
    return new CoffeeMachine("XXX品牌", "YYY型号");
}
```

### 1.2 核心概念


**JavaConfig = 用Java类来做Spring配置**

- **本质**：用纯Java代码代替XML配置文件
- **优势**：类型安全、支持IDE提示、便于重构
- **理念**：让配置也变成代码的一部分

**📊 配置方式对比**

| 配置方式 | **表现形式** | **优点** | **缺点** | **适用场景** |
|---------|------------|---------|---------|-------------|
| **XML配置** | `*.xml文件` | `配置与代码分离` | `不支持类型检查、冗长` | `老项目维护` |
| **JavaConfig** | `@Configuration类` | `类型安全、IDE友好` | `配置与代码耦合` | `新项目推荐` |
| **注解配置** | `@Component等` | `最简洁` | `配置分散` | `简单场景` |

---

## 2. 📝 @Configuration配置类


### 2.1 什么是@Configuration


**🔸 核心定义**  
`@Configuration`是一个类级别的注解，告诉Spring："这个类是用来做配置的，请把它当作配置文件来处理"。

**通俗理解**：就像给一个普通Java类贴了个标签，说"嘿，我是专门管理Bean的配置管家"。

### 2.2 基础使用


```java
import org.springframework.context.annotation.Configuration;

// 这个注解让Spring知道：这是个配置类
@Configuration
public class AppConfig {
    // 这里面可以定义Bean
}
```

**🔍 工作原理简述**

```
普通Java类 ──加上@Configuration──▶ Spring配置类
     │                              │
     ▼                              ▼
只是个类                    Spring会特殊处理它
                          1. 扫描@Bean方法
                          2. 创建Bean实例
                          3. 管理Bean生命周期
```

### 2.3 配置类的特点


**✅ 配置类必须是类，不能是接口或抽象类**
```java
// ✅ 正确写法
@Configuration
public class MyConfig {
}

// ❌ 错误写法
@Configuration
public interface MyConfig {  // 接口不行
}
```

**✅ 配置类会被Spring代理增强**

> 💡 **重要提示**  
> Spring会给配置类创建一个"增强版"（代理对象），这样可以保证单例Bean只创建一次

---

## 3. 🔧 @Bean方法定义


### 3.1 @Bean注解的作用


**🎯 核心作用**：告诉Spring"这个方法返回的对象，请帮我管理起来"

**通俗理解**：
- 方法名 = Bean的名字（身份证）
- 返回值 = Bean的类型（是什么东西）
- 方法体 = 怎么创建这个Bean（制造过程）

### 3.2 基础示例


```java
@Configuration
public class CoffeeConfig {
    
    // 定义一个Bean：咖啡机
    @Bean
    public CoffeeMachine coffeeMachine() {
        // 这里是创建Bean的逻辑
        return new CoffeeMachine("德龙", "ECAM23.460");
    }
    
    // 定义另一个Bean：咖啡豆研磨器
    @Bean
    public Grinder grinder() {
        return new Grinder("意式研磨");
    }
}
```

**📋 方法签名解析**

```java
@Bean  // ← 注解标记
public CoffeeMachine  // ← 返回类型（Bean的类型）
coffeeMachine()       // ← 方法名（Bean的默认名称）
{
    return new CoffeeMachine();  // ← 创建并返回实例
}
```

### 3.3 Bean的命名


**方式1：使用方法名作为Bean名称（默认）**
```java
@Bean
public CoffeeMachine coffeeMachine() {  // Bean名称是"coffeeMachine"
    return new CoffeeMachine();
}
```

**方式2：通过name属性指定名称**
```java
@Bean(name = "myCoffeeMachine")  // 明确指定名称
public CoffeeMachine createMachine() {
    return new CoffeeMachine();
}

// 也可以指定多个别名
@Bean(name = {"machine1", "machine2"})
public CoffeeMachine machine() {
    return new CoffeeMachine();
}
```

### 3.4 实用技巧


**🔸 构造器注入参数**
```java
@Bean
public CoffeeMachine coffeeMachine() {
    CoffeeMachine machine = new CoffeeMachine();
    machine.setBrand("德龙");
    machine.setModel("ECAM23.460");
    machine.setPressure(15);  // 15帕压力
    return machine;
}
```

> ⚠️ **注意事项**  
> @Bean方法可以有参数，Spring会自动从容器中查找对应类型的Bean注入进来

---

## 4. 🔗 方法间依赖调用


### 4.1 什么是方法间依赖


**🌰 实际场景**  
咖啡机需要用到研磨器，一个Bean依赖另一个Bean，怎么办？

**传统思维（错误）**：直接new一个？  
**Spring方式**：让Spring帮你注入依赖的Bean

### 4.2 依赖注入的方式


**方式1：直接调用配置类中的其他@Bean方法（推荐）**

```java
@Configuration
public class CoffeeConfig {
    
    // 定义研磨器Bean
    @Bean
    public Grinder grinder() {
        return new Grinder("意式研磨");
    }
    
    // 定义咖啡机Bean，需要研磨器
    @Bean
    public CoffeeMachine coffeeMachine() {
        CoffeeMachine machine = new CoffeeMachine();
        // 直接调用grinder()方法 - Spring会智能处理
        machine.setGrinder(grinder());  
        return machine;
    }
}
```

**🔍 工作原理**
```
调用grinder()方法
     │
     ▼
Spring拦截这次调用
     │
     ▼
检查容器中是否已有grinder实例
     │
     ├─有 ──▶ 直接返回已有实例（单例保证）
     │
     └─没有 ──▶ 执行方法创建新实例
```

**方式2：方法参数注入（更灵活）**

```java
@Configuration
public class CoffeeConfig {
    
    @Bean
    public Grinder grinder() {
        return new Grinder("意式研磨");
    }
    
    // Spring会自动注入Grinder类型的Bean
    @Bean
    public CoffeeMachine coffeeMachine(Grinder grinder) {
        CoffeeMachine machine = new CoffeeMachine();
        machine.setGrinder(grinder);  // 使用注入的参数
        return machine;
    }
}
```

### 4.3 多个依赖的处理


```java
@Configuration
public class CoffeeShopConfig {
    
    @Bean
    public Grinder grinder() {
        return new Grinder();
    }
    
    @Bean
    public WaterHeater heater() {
        return new WaterHeater();
    }
    
    @Bean
    public MilkFrother frother() {
        return new MilkFrother();
    }
    
    // 同时依赖多个Bean
    @Bean
    public CoffeeMachine coffeeMachine(
        Grinder grinder,      // 研磨器
        WaterHeater heater,   // 加热器  
        MilkFrother frother   // 奶泡机
    ) {
        CoffeeMachine machine = new CoffeeMachine();
        machine.setGrinder(grinder);
        machine.setHeater(heater);
        machine.setFrother(frother);
        return machine;
    }
}
```

> 💡 **最佳实践**  
> 推荐使用"方法参数注入"方式，代码更清晰，依赖关系一目了然

---

## 5. ⏰ 生命周期方法


### 5.1 什么是生命周期方法


**通俗理解**：Bean的"出生"和"死亡"时刻可以执行一些特定操作

```
Bean创建 ──▶ 初始化方法 ──▶ 使用Bean ──▶ 销毁方法 ──▶ Bean销毁
           （做准备工作）              （做清理工作）
```

**🌰 实际场景**
- **初始化**：数据库连接池创建后，建立连接
- **销毁**：关闭数据库连接，释放资源

### 5.2 定义生命周期方法


**方式1：通过@Bean的属性指定**

```java
@Configuration
public class DatabaseConfig {
    
    @Bean(initMethod = "init", destroyMethod = "cleanup")
    public DataSource dataSource() {
        return new MyDataSource();
    }
}

// DataSource类中定义的方法
public class MyDataSource {
    
    public void init() {
        System.out.println("数据库连接池初始化...");
        // 建立数据库连接
    }
    
    public void cleanup() {
        System.out.println("数据库连接池关闭...");
        // 关闭数据库连接
    }
}
```

**方式2：实现Spring接口**

```java
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.DisposableBean;

public class MyDataSource implements InitializingBean, DisposableBean {
    
    @Override
    public void afterPropertiesSet() throws Exception {
        // Bean属性设置完成后调用（初始化）
        System.out.println("初始化数据源");
    }
    
    @Override
    public void destroy() throws Exception {
        // Bean销毁前调用
        System.out.println("销毁数据源");
    }
}
```

**方式3：使用JSR-250注解（推荐）**

```java
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

public class MyDataSource {
    
    @PostConstruct  // 初始化方法
    public void init() {
        System.out.println("@PostConstruct: 初始化");
    }
    
    @PreDestroy  // 销毁方法
    public void cleanup() {
        System.out.println("@PreDestroy: 清理资源");
    }
}
```

### 5.3 执行顺序


**📊 生命周期方法执行顺序**

```
1. 构造器执行
      ↓
2. 属性注入
      ↓
3. @PostConstruct方法
      ↓
4. InitializingBean.afterPropertiesSet()
      ↓
5. @Bean(initMethod)指定的方法
      ↓
   【Bean可以使用】
      ↓
6. @PreDestroy方法
      ↓
7. DisposableBean.destroy()
      ↓
8. @Bean(destroyMethod)指定的方法
```

> ⚠️ **重要提醒**  
> 销毁方法只对单例Bean有效，原型Bean的销毁方法不会被调用

---

## 6. 🎨 作用域配置


### 6.1 什么是作用域


**通俗理解**：决定Bean是"独享"还是"共享"

```
单例（singleton）：整个应用只有一个实例，大家共享
            就像公司只有一台打印机，所有人共用

原型（prototype）：每次获取都创建新实例，各用各的
            就像每个人有自己的笔记本，互不影响
```

### 6.2 作用域类型


**🔸 常用作用域**

| 作用域 | **说明** | **生命周期** | **使用场景** |
|-------|---------|------------|-------------|
| `singleton` | `单例（默认）` | `容器启动到关闭` | `无状态Bean、工具类` |
| `prototype` | `原型，多例` | `获取时创建，用完不管` | `有状态Bean、需隔离` |
| `request` | `Web请求范围` | `单次HTTP请求` | `Web应用` |
| `session` | `会话范围` | `用户会话期间` | `用户相关数据` |

### 6.3 配置作用域


**使用@Scope注解**

```java
import org.springframework.context.annotation.Scope;

@Configuration
public class ScopeConfig {
    
    // 单例Bean（默认，可以不写）
    @Bean
    @Scope("singleton")  // 或 @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    public SharedService sharedService() {
        return new SharedService();
    }
    
    // 原型Bean
    @Bean
    @Scope("prototype")  // 或 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
    public UserTask userTask() {
        return new UserTask();
    }
}
```

### 6.4 作用域实际效果


**单例测试**
```java
@Bean
@Scope("singleton")
public Counter counter() {
    return new Counter();
}

// 测试代码
Counter c1 = context.getBean(Counter.class);
Counter c2 = context.getBean(Counter.class);
System.out.println(c1 == c2);  // true，是同一个对象
```

**原型测试**
```java
@Bean
@Scope("prototype")
public Counter counter() {
    return new Counter();
}

// 测试代码
Counter c1 = context.getBean(Counter.class);
Counter c2 = context.getBean(Counter.class);
System.out.println(c1 == c2);  // false，是不同对象
```

> 💡 **选择建议**  
> - 大多数情况用`singleton`（默认）
> - 有状态的Bean用`prototype`
> - 线程安全问题优先考虑设计，而非作用域

---

## 7. 🔀 条件判断


### 7.1 什么是条件判断


**通俗理解**：根据条件决定是否创建某个Bean

**🌰 实际场景**
- Windows系统用这个Bean，Linux系统用那个Bean
- 开发环境用内存数据库，生产环境用MySQL
- 有某个类才创建Bean，没有就不创建

### 7.2 @Conditional基础使用


**核心注解：@Conditional**

```java
import org.springframework.context.annotation.Conditional;

@Configuration
public class ConditionalConfig {
    
    // 只有条件满足时才创建这个Bean
    @Bean
    @Conditional(WindowsCondition.class)  // 条件类
    public FileService windowsFileService() {
        return new WindowsFileService();
    }
    
    @Bean
    @Conditional(LinuxCondition.class)
    public FileService linuxFileService() {
        return new LinuxFileService();
    }
}
```

**自定义条件类**
```java
import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

public class WindowsCondition implements Condition {
    
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 判断是否是Windows系统
        String os = context.getEnvironment().getProperty("os.name");
        return os != null && os.toLowerCase().contains("windows");
    }
}
```

### 7.3 常用条件注解


**Spring Boot提供的便捷注解**

```java
import org.springframework.boot.autoconfigure.condition.*;

@Configuration
public class AutoConfig {
    
    // 当类路径下有指定类时才创建
    @Bean
    @ConditionalOnClass(name = "com.mysql.cj.jdbc.Driver")
    public DataSource mysqlDataSource() {
        return new MysqlDataSource();
    }
    
    // 当容器中没有指定Bean时才创建
    @Bean
    @ConditionalOnMissingBean(DataSource.class)
    public DataSource defaultDataSource() {
        return new H2DataSource();
    }
    
    // 当配置属性存在时才创建
    @Bean
    @ConditionalOnProperty(name = "app.feature.enabled", havingValue = "true")
    public FeatureService featureService() {
        return new FeatureService();
    }
}
```

**📋 常用条件注解清单**

| 注解 | **作用** | **示例场景** |
|-----|---------|------------|
| `@ConditionalOnClass` | `类路径有某类` | `有MySQL驱动才创建MySQL数据源` |
| `@ConditionalOnMissingClass` | `类路径没有某类` | `没有Redis时用本地缓存` |
| `@ConditionalOnBean` | `容器中有某Bean` | `有数据源才创建事务管理器` |
| `@ConditionalOnMissingBean` | `容器中没有某Bean` | `没有自定义Bean时用默认` |
| `@ConditionalOnProperty` | `配置属性满足条件` | `开关功能` |

### 7.4 环境配置条件


**使用@Profile按环境创建Bean**

```java
import org.springframework.context.annotation.Profile;

@Configuration
public class EnvConfig {
    
    // 开发环境用这个
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new H2DataSource();  // 内存数据库
    }
    
    // 生产环境用这个
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        return new MysqlDataSource();  // MySQL
    }
    
    // 多个环境都用
    @Bean
    @Profile({"dev", "test"})
    public MockService mockService() {
        return new MockService();
    }
}
```

**激活Profile**
```properties
# application.properties

spring.profiles.active=dev
```

> 💡 **实用技巧**  
> 配合Spring Boot的配置文件，可以实现不同环境不同配置，非常方便

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 JavaConfig核心理念**
```
用Java代码替代XML配置
- @Configuration标记配置类  
- @Bean定义Bean创建方法
- 类型安全，IDE友好
```

**🔸 依赖注入方式**
```
方式1：直接调用@Bean方法（简单场景）
方式2：方法参数注入（推荐，清晰）
```

**🔸 生命周期管理**
```
初始化：@PostConstruct、initMethod
销毁：@PreDestroy、destroyMethod
```

**🔸 作用域选择**
```
singleton：默认，单例共享
prototype：每次新建，状态隔离
```

**🔸 条件化配置**
```
@Conditional：自定义条件
@Profile：环境切换
@ConditionalOnXxx：便捷条件判断
```

### 8.2 关键理解要点


**🔹 @Configuration的特殊性**
- Spring会对配置类做代理增强
- 保证多次调用@Bean方法返回同一实例（单例）
- 这是JavaConfig的核心机制

**🔹 方法间调用的原理**
```
@Bean方法互相调用 → Spring拦截 → 返回容器中的实例
不是普通的方法调用，而是从容器获取Bean
```

**🔹 作用域的本质**
```
singleton = 容器级别共享
prototype = 不共享，每次新建
选择依据：是否有状态、是否需要隔离
```

### 8.3 最佳实践建议


**✅ 推荐做法**
```
1. 配置类按功能模块划分
   - DatabaseConfig（数据库配置）
   - CacheConfig（缓存配置）
   - WebConfig（Web配置）

2. Bean命名清晰有意义
   - 方法名即Bean名，要见名知义

3. 依赖注入用方法参数
   - 依赖关系更清晰
   - 便于单元测试

4. 合理使用条件注解
   - 不同环境不同配置
   - 按需加载，避免冗余
```

**❌ 避免的错误**
```
1. 在@Bean方法内直接new依赖对象
   ❌ new Grinder()  
   ✅ 通过参数注入或调用@Bean方法

2. 混淆作用域使用场景
   ❌ 有状态Bean用singleton
   ✅ 有状态Bean用prototype

3. 过度使用条件判断
   ❌ 每个Bean都加条件
   ✅ 只在必要时使用
```

### 8.4 记忆要诀


**🧠 核心记忆口诀**
```
Configuration是配置类，
Bean方法定义要清晰。
依赖注入用参数，
生命周期有钩子。
作用域看是否共享，
条件判断按需建。
```

**🎯 学习检查清单**
- [ ] 理解JavaConfig的作用和优势
- [ ] 会用@Configuration和@Bean
- [ ] 掌握Bean依赖注入的方式
- [ ] 了解生命周期方法的使用
- [ ] 知道作用域的区别和选择
- [ ] 能用条件注解实现灵活配置

**🔗 扩展学习**
- 进阶：组件扫描与自动配置
- 进阶：@Import导入其他配置
- 实战：Spring Boot自动配置原理