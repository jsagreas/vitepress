---
title: 3、XML高级配置
---
## 📚 目录

1. [import导入配置](#1-import导入配置)
2. [profile环境配置](#2-profile环境配置)
3. [placeholder占位符](#3-placeholder占位符)
4. [SpEL表达式](#4-spel表达式)
5. [条件配置](#5-条件配置)
6. [模块化配置](#6-模块化配置)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📥 import导入配置


### 1.1 为什么需要import


**生活场景类比**：
```
想象你在装修房子：
❌ 把所有设计图纸画在一张纸上 → 太乱，难以管理
✅ 分成客厅设计图、卧室设计图、厨房设计图 → 清晰明了

Spring配置也是同样道理：
❌ 所有Bean都写在一个XML文件 → applicationContext.xml有几千行
✅ 按模块拆分成多个XML文件 → 每个文件职责清晰
```

**实际问题**：
- 单个配置文件太长，难以维护
- 团队协作时容易冲突
- 不同模块的配置混在一起

### 1.2 import基本用法


**核心语法**：
```xml
<!-- 主配置文件：applicationContext.xml -->
<beans>
    <!-- 导入其他配置文件 -->
    <import resource="spring-dao.xml"/>
    <import resource="spring-service.xml"/>
    <import resource="spring-web.xml"/>
</beans>
```

**通俗解释**：
- `<import>`就像是"引用其他文件"
- `resource`属性指定要导入的文件路径
- Spring会把所有导入的配置合并成一个完整的配置

### 1.3 路径写法详解


**相对路径 vs 绝对路径**：

| 路径类型 | 写法示例 | 说明 | 使用场景 |
|---------|---------|------|---------|
| **相对路径** | `spring-dao.xml` | 同一目录下 | 最常用 |
| **子目录相对路径** | `config/spring-dao.xml` | 子目录 | 配置分层 |
| **父目录相对路径** | `../common/spring-common.xml` | 上级目录 | 跨模块引用 |
| **classpath路径** | `classpath:spring-dao.xml` | 类路径下 | 推荐使用 |
| **通配符路径** | `classpath*:spring-*.xml` | 匹配多个文件 | 批量导入 |

**路径示例**：
```xml
<!-- 项目结构 -->
src/
  └── main/
      └── resources/
          ├── applicationContext.xml (主配置)
          ├── spring-dao.xml
          ├── spring-service.xml
          └── config/
              └── spring-web.xml

<!-- 主配置文件中的导入 -->
<beans>
    <!-- 方式1：同目录相对路径 -->
    <import resource="spring-dao.xml"/>
    
    <!-- 方式2：子目录相对路径 -->
    <import resource="config/spring-web.xml"/>
    
    <!-- 方式3：classpath路径（推荐） -->
    <import resource="classpath:spring-service.xml"/>
    
    <!-- 方式4：通配符批量导入 -->
    <import resource="classpath:spring-*.xml"/>
</beans>
```

### 1.4 模块化配置实践


**按功能拆分配置**：

```
配置文件拆分策略：

1. spring-dao.xml        → 数据访问层配置
   ├── 数据源配置
   ├── MyBatis配置
   └── 事务管理器

2. spring-service.xml    → 业务层配置
   ├── Service Bean定义
   ├── 事务配置
   └── AOP配置

3. spring-web.xml        → Web层配置
   ├── Controller Bean
   ├── 视图解析器
   └── 文件上传配置

4. spring-common.xml     → 公共配置
   ├── 工具类Bean
   ├── 缓存配置
   └── 定时任务
```

**实际应用示例**：
```xml
<!-- spring-dao.xml - 数据层配置 -->
<beans>
    <!-- 数据源 -->
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="${db.url}"/>
    </bean>
    
    <!-- MyBatis SqlSessionFactory -->
    <bean id="sqlSessionFactory" class="...SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
    </bean>
</beans>

<!-- spring-service.xml - 业务层配置 -->
<beans>
    <!-- 自动扫描Service层 -->
    <context:component-scan base-package="com.example.service"/>
    
    <!-- 事务管理 -->
    <tx:annotation-driven/>
</beans>

<!-- applicationContext.xml - 主配置 -->
<beans>
    <!-- 统一导入所有配置 -->
    <import resource="classpath:spring-dao.xml"/>
    <import resource="classpath:spring-service.xml"/>
    <import resource="classpath:spring-web.xml"/>
</beans>
```

### 1.5 import常见问题


**⚠️ 循环导入问题**：
```xml
<!-- 错误示例 - 会导致循环引用 -->

<!-- A.xml -->
<beans>
    <import resource="B.xml"/>
    <bean id="beanA" class="..."/>
</beans>

<!-- B.xml -->
<beans>
    <import resource="A.xml"/>  ❌ 循环导入！
    <bean id="beanB" class="..."/>
</beans>

解决方案：
✅ 创建一个主配置文件统一导入
✅ 避免配置文件之间相互引用
```

**💡 最佳实践**：
- 使用`classpath:`前缀，更清晰
- 主配置文件只负责导入，不定义Bean
- 配置文件命名规范：`spring-模块名.xml`
- 通配符要谨慎使用，避免导入不必要的文件

---

## 2. 🌍 profile环境配置


### 2.1 什么是profile


**生活场景类比**：
```
你的手机有多种模式：
📱 静音模式 → 开会时使用
🔊 响铃模式 → 正常使用
🌙 勿扰模式 → 睡觉时使用

根据不同场景自动切换设置，这就是profile的作用！

在开发中：
💻 开发环境 → 本地数据库，详细日志
🧪 测试环境 → 测试数据库，调试信息
🏭 生产环境 → 正式数据库，精简日志
```

**核心概念**：
- **profile**：一套环境配置方案
- 同一个应用，不同环境使用不同配置
- 部署时只需切换profile，无需修改代码

### 2.2 profile基本使用


**定义profile配置**：
```xml
<!-- 开发环境配置 -->
<beans profile="dev">
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="jdbc:mysql://localhost:3306/test"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
</beans>

<!-- 生产环境配置 -->
<beans profile="prod">
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="jdbc:mysql://192.168.1.100:3306/prod"/>
        <property name="username" value="prod_user"/>
        <property name="password" value="prod_password"/>
    </bean>
</beans>
```

**通俗理解**：
- `profile="dev"` 表示"这是开发环境专用配置"
- `profile="prod"` 表示"这是生产环境专用配置"
- 同样的Bean id（dataSource），不同环境使用不同配置

### 2.3 激活profile的方式


**方式对比**：

| 激活方式 | 使用场景 | 示例 |
|---------|---------|------|
| **JVM参数** | 本地开发、测试 | `-Dspring.profiles.active=dev` |
| **web.xml配置** | Web应用 | 在`web.xml`中配置 |
| **代码方式** | 单元测试 | `@ActiveProfiles("test")` |
| **环境变量** | 服务器部署 | `export SPRING_PROFILES_ACTIVE=prod` |

**JVM参数方式**：
```bash
# 启动应用时指定profile
java -jar myapp.jar -Dspring.profiles.active=dev
```

**web.xml配置方式**：
```xml
<context-param>
    <param-name>spring.profiles.active</param-name>
    <param-value>dev</param-value>
</context-param>
```

**代码激活方式**：
```java
// 在测试类中指定profile
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
@ActiveProfiles("test")  // 激活测试环境配置
public class UserServiceTest {
    // 测试代码
}
```

### 2.4 多环境配置实战


**典型三环境配置**：

```
环境划分：
├── 开发环境(dev)   → 本地开发使用
├── 测试环境(test)  → 集成测试使用
└── 生产环境(prod)  → 正式上线使用

配置差异：
          开发环境           测试环境           生产环境
数据库：  localhost         test.db.com       prod.db.com
日志：    DEBUG级别         INFO级别          WARN级别
缓存：    不启用            启用              启用
邮件：    不发送真实邮件    发送测试邮件      发送真实邮件
```

**完整配置示例**：
```xml
<!-- 开发环境 -->
<beans profile="dev">
    <!-- 数据源 -->
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>
    
    <!-- 日志级别 -->
    <bean id="logLevel" class="java.lang.String">
        <constructor-arg value="DEBUG"/>
    </bean>
    
    <!-- 邮件服务（开发环境不发送真实邮件） -->
    <bean id="mailService" class="com.example.MockMailService"/>
</beans>

<!-- 生产环境 -->
<beans profile="prod">
    <!-- 数据源 -->
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="${db.url}"/>
        <property name="username" value="${db.username}"/>
        <property name="password" value="${db.password}"/>
    </bean>
    
    <!-- 日志级别 -->
    <bean id="logLevel" class="java.lang.String">
        <constructor-arg value="WARN"/>
    </bean>
    
    <!-- 邮件服务（生产环境发送真实邮件） -->
    <bean id="mailService" class="com.example.RealMailService"/>
</beans>
```

### 2.5 default profile


**默认profile概念**：
```xml
<!-- 没有指定profile的Bean，属于default profile -->
<beans>
    <!-- 这些Bean在任何环境下都会加载 -->
    <bean id="commonService" class="...CommonService"/>
    
    <!-- 开发环境特定配置 -->
    <beans profile="dev">
        <bean id="devService" class="...DevService"/>
    </beans>
    
    <!-- 生产环境特定配置 -->
    <beans profile="prod">
        <bean id="prodService" class="...ProdService"/>
    </beans>
</beans>
```

**理解要点**：
- 没有`profile`属性的Bean → 默认在所有环境加载
- 有`profile`属性的Bean → 只在指定环境加载
- 可以组合使用：`profile="dev,test"` 表示开发和测试都加载

---

## 3. 🔤 placeholder占位符


### 3.1 什么是占位符


**生活场景类比**：
```
填空题：我的名字是____，今年____岁
配置文件：数据库地址是${db.url}，用户名是${db.username}

占位符就是"留空待填"：
1. 配置文件中写${变量名}
2. 运行时从属性文件读取真实值
3. Spring自动替换占位符
```

**为什么使用占位符**：
- ✅ 配置和代码分离（敏感信息不写死在XML）
- ✅ 不同环境切换方便（只需修改属性文件）
- ✅ 敏感信息保护（密码不直接暴露在配置文件）

### 3.2 占位符基本配置


**步骤1：创建属性文件**
```properties
# db.properties
db.url=jdbc:mysql://localhost:3306/mydb
db.username=root
db.password=123456
db.driver=com.mysql.jdbc.Driver
```

**步骤2：加载属性文件**
```xml
<!-- 方式1：使用context命名空间（推荐） -->
<context:property-placeholder location="classpath:db.properties"/>

<!-- 方式2：使用Bean定义 -->
<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
    <property name="location" value="classpath:db.properties"/>
</bean>
```

**步骤3：使用占位符**
```xml
<bean id="dataSource" class="...DruidDataSource">
    <property name="url" value="${db.url}"/>
    <property name="username" value="${db.username}"/>
    <property name="password" value="${db.password}"/>
    <property name="driverClassName" value="${db.driver}"/>
</bean>
```

### 3.3 占位符高级特性


**多个属性文件加载**：
```xml
<!-- 方式1：逗号分隔 -->
<context:property-placeholder 
    location="classpath:db.properties,classpath:redis.properties"/>

<!-- 方式2：通配符 -->
<context:property-placeholder 
    location="classpath:*.properties"/>

<!-- 方式3：多个路径 -->
<context:property-placeholder>
    <property name="locations">
        <list>
            <value>classpath:db.properties</value>
            <value>classpath:redis.properties</value>
            <value>classpath:mq.properties</value>
        </list>
    </property>
</context:property-placeholder>
```

**占位符默认值**：
```xml
<!-- 语法：${变量名:默认值} -->
<bean id="dataSource" class="...DruidDataSource">
    <!-- 如果db.port不存在，使用默认值3306 -->
    <property name="port" value="${db.port:3306}"/>
    
    <!-- 如果db.maxActive不存在，使用默认值20 -->
    <property name="maxActive" value="${db.maxActive:20}"/>
</bean>
```

**属性文件优先级**：
```
配置属性查找顺序：
1. 系统属性（-D参数）        优先级最高
2. 环境变量
3. 属性文件                  优先级最低

示例：
properties文件：db.url=jdbc:mysql://localhost
JVM参数：-Ddb.url=jdbc:mysql://192.168.1.100

最终使用：jdbc:mysql://192.168.1.100（JVM参数覆盖）
```

### 3.4 实际应用场景


**场景1：数据库配置**
```properties
# database.properties
# 开发环境配置
db.dev.url=jdbc:mysql://localhost:3306/dev_db
db.dev.username=dev_user
db.dev.password=dev_pass

# 生产环境配置
db.prod.url=jdbc:mysql://192.168.1.100:3306/prod_db
db.prod.username=prod_user
db.prod.password=prod_pass
```

```xml
<!-- 根据profile选择不同配置 -->
<beans profile="dev">
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="${db.dev.url}"/>
        <property name="username" value="${db.dev.username}"/>
        <property name="password" value="${db.dev.password}"/>
    </bean>
</beans>

<beans profile="prod">
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="${db.prod.url}"/>
        <property name="username" value="${db.prod.username}"/>
        <property name="password" value="${db.prod.password}"/>
    </bean>
</beans>
```

**场景2：第三方服务配置**
```properties
# app.properties
# Redis配置
redis.host=localhost
redis.port=6379
redis.password=

# 邮件服务配置
mail.host=smtp.qq.com
mail.username=example@qq.com
mail.password=secret

# 文件上传配置
upload.path=/upload
upload.maxSize=10485760
```

---

## 4. 💫 SpEL表达式


### 4.1 SpEL是什么


**Spring Expression Language（Spring表达式语言）**：
```
如果说占位符是"填空题"，那SpEL就是"计算题"

占位符：${db.url}           → 简单替换
SpEL：  #{user.age > 18}     → 可以计算、判断、调用方法

SpEL能做什么：
✅ 调用对象方法
✅ 访问对象属性
✅ 数学运算
✅ 逻辑判断
✅ 正则匹配
✅ 集合操作
```

### 4.2 SpEL基本语法


**语法格式对比**：

| 用途 | 占位符 | SpEL | 说明 |
|-----|-------|------|------|
| **引用属性** | `${name}` | `#{systemProperties['name']}` | SpEL更灵活 |
| **数学运算** | 不支持 | `#{10 * 2}` | 可以计算 |
| **调用方法** | 不支持 | `#{str.toUpperCase()}` | 可以调用方法 |
| **逻辑判断** | 不支持 | `#{age > 18 ? '成年' : '未成年'}` | 支持三元运算 |

**基础用法示例**：
```xml
<!-- 1. 字面量值 -->
<property name="count" value="#{10}"/>
<property name="price" value="#{99.9}"/>
<property name="name" value="#{'张三'}"/>

<!-- 2. 引用其他Bean -->
<property name="user" value="#{userBean}"/>

<!-- 3. 调用Bean的方法 -->
<property name="upperName" value="#{userBean.getName().toUpperCase()}"/>

<!-- 4. 访问Bean的属性 -->
<property name="userAge" value="#{userBean.age}"/>

<!-- 5. 数学运算 -->
<property name="total" value="#{price * count}"/>
<property name="average" value="#{(score1 + score2) / 2}"/>
```

### 4.3 SpEL常用操作


**算术运算**：
```xml
<bean id="calculator" class="...Calculator">
    <!-- 加减乘除 -->
    <property name="add" value="#{10 + 5}"/>         <!-- 15 -->
    <property name="subtract" value="#{10 - 5}"/>    <!-- 5 -->
    <property name="multiply" value="#{10 * 5}"/>    <!-- 50 -->
    <property name="divide" value="#{10 / 5}"/>      <!-- 2 -->
    <property name="mod" value="#{10 % 3}"/>         <!-- 1 -->
    
    <!-- 幂运算 -->
    <property name="power" value="#{2 ^ 3}"/>        <!-- 8 -->
</bean>
```

**逻辑运算**：
```xml
<bean id="validator" class="...Validator">
    <!-- 比较运算 -->
    <property name="greater" value="#{age > 18}"/>       <!-- true/false -->
    <property name="less" value="#{score < 60}"/>
    <property name="equal" value="#{name == 'admin'}"/>
    
    <!-- 逻辑运算 -->
    <property name="and" value="#{age > 18 and score > 60}"/>
    <property name="or" value="#{isVIP or score > 90}"/>
    <property name="not" value="#{!isBanned}"/>
    
    <!-- 三元运算 -->
    <property name="level" value="#{score >= 60 ? '及格' : '不及格'}"/>
</bean>
```

**字符串操作**：
```xml
<bean id="stringBean" class="...StringBean">
    <!-- 字符串拼接 -->
    <property name="fullName" value="#{firstName + ' ' + lastName}"/>
    
    <!-- 调用字符串方法 -->
    <property name="upper" value="#{name.toUpperCase()}"/>
    <property name="length" value="#{name.length()}"/>
    <property name="contains" value="#{email.contains('@')}"/>
    
    <!-- 正则匹配 -->
    <property name="matches" value="#{phone matches '\\d{11}'}"/>
</bean>
```

### 4.4 SpEL引用Bean


**引用其他Bean及其属性**：
```xml
<!-- 定义用户Bean -->
<bean id="user" class="com.example.User">
    <property name="name" value="张三"/>
    <property name="age" value="25"/>
    <property name="email" value="zhangsan@example.com"/>
</bean>

<!-- 定义配置Bean -->
<bean id="config" class="com.example.Config">
    <property name="maxAge" value="60"/>
    <property name="minAge" value="18"/>
</bean>

<!-- 使用SpEL引用Bean -->
<bean id="service" class="com.example.Service">
    <!-- 引用整个Bean -->
    <property name="user" value="#{user}"/>
    
    <!-- 引用Bean的属性 -->
    <property name="userName" value="#{user.name}"/>
    <property name="userAge" value="#{user.age}"/>
    
    <!-- 调用Bean的方法 -->
    <property name="emailDomain" value="#{user.email.substring(user.email.indexOf('@') + 1)}"/>
    
    <!-- 组合使用多个Bean -->
    <property name="isAdult" value="#{user.age >= config.minAge and user.age < config.maxAge}"/>
</bean>
```

### 4.5 SpEL高级特性


**集合操作**：
```xml
<bean id="listBean" class="...ListBean">
    <!-- 创建List -->
    <property name="numbers" value="#{'{1,2,3,4,5'}"/>
    
    <!-- 访问集合元素 -->
    <property name="first" value="#{numbers[0]}"/>
    
    <!-- 集合方法 -->
    <property name="size" value="#{numbers.size()}"/>
    <property name="contains" value="#{numbers.contains(3)}"/>
    
    <!-- 集合筛选（选择表达式） -->
    <property name="evenNumbers" value="#{numbers.?[#this % 2 == 0]}"/>
</bean>
```

**系统属性访问**：
```xml
<bean id="systemBean" class="...SystemBean">
    <!-- 访问系统属性 -->
    <property name="javaVersion" value="#{systemProperties['java.version']}"/>
    <property name="osName" value="#{systemProperties['os.name']}"/>
    <property name="userHome" value="#{systemProperties['user.home']}"/>
    
    <!-- 访问环境变量 -->
    <property name="path" value="#{systemEnvironment['PATH']}"/>
</bean>
```

**类型转换**：
```xml
<bean id="converterBean" class="...ConverterBean">
    <!-- SpEL会自动转换类型 -->
    <property name="intValue" value="#{'100'}"/>        <!-- String → int -->
    <property name="boolValue" value="#{'true'}"/>      <!-- String → boolean -->
    <property name="dateValue" value="#{'2024-01-01'}"/> <!-- String → Date -->
</bean>
```

### 4.6 SpEL实战应用


**动态配置场景**：
```xml
<!-- 根据环境动态选择配置 -->
<bean id="dataSource" class="...DruidDataSource">
    <!-- 开发环境用本地，生产环境用配置的地址 -->
    <property name="url" value="#{systemProperties['env'] == 'dev' ? 
        'jdbc:mysql://localhost:3306/test' : 
        '${db.prod.url}'}"/>
    
    <!-- 根据是否开启缓存决定连接池大小 -->
    <property name="maxActive" value="#{cacheConfig.enabled ? 50 : 20}"/>
</bean>

<!-- 根据条件创建Bean -->
<bean id="mailService" 
      class="#{systemProperties['mail.enabled'] == 'true' ? 
              'com.example.RealMailService' : 
              'com.example.MockMailService'}"/>
```

---

## 5. ❓ 条件配置


### 5.1 条件配置概念


**什么是条件配置**：
```
生活场景：
如果今天是周末 → 睡懒觉
如果今天是工作日 → 早起上班

Spring条件配置：
如果在Windows系统 → 使用WindowsFileService
如果在Linux系统 → 使用LinuxFileService

核心思想：根据条件动态决定是否加载某个Bean
```

**为什么需要条件配置**：
- 不同操作系统使用不同实现
- 不同环境加载不同组件
- 根据配置开关控制功能

### 5.2 基于profile的条件配置


**这是最常用的条件配置方式**：
```xml
<!-- 开发环境：使用内存数据库 -->
<beans profile="dev">
    <bean id="dataSource" class="...EmbeddedDataSource">
        <property name="type" value="H2"/>
    </bean>
</beans>

<!-- 生产环境：使用真实数据库 -->
<beans profile="prod">
    <bean id="dataSource" class="...DruidDataSource">
        <property name="url" value="${db.url}"/>
    </bean>
</beans>

<!-- 原理：只有激活对应profile，Bean才会被加载 -->
```

### 5.3 基于SpEL的条件配置


**使用SpEL实现条件判断**：
```xml
<!-- 方式1：使用profile + SpEL -->
<beans profile="#{systemProperties['app.env']}">
    <!-- 根据系统属性app.env的值决定加载哪个profile -->
</beans>

<!-- 方式2：Bean定义中使用条件 -->
<bean id="fileService" 
      class="#{systemProperties['os.name'].startsWith('Windows') ? 
              'com.example.WindowsFileService' : 
              'com.example.UnixFileService'}"/>
```

### 5.4 条件配置实战


**场景1：操作系统相关配置**
```xml
<!-- Windows系统专用配置 -->
<beans profile="windows">
    <bean id="fileService" class="com.example.WindowsFileService">
        <property name="basePath" value="C:/data"/>
    </bean>
</beans>

<!-- Linux系统专用配置 -->
<beans profile="linux">
    <bean id="fileService" class="com.example.LinuxFileService">
        <property name="basePath" value="/var/data"/>
    </bean>
</beans>

<!-- 激活方式：-Dspring.profiles.active=windows -->
```

**场景2：功能开关配置**
```xml
<!-- 缓存启用时的配置 -->
<beans profile="cache-enabled">
    <bean id="cacheManager" class="...RedisCacheManager">
        <property name="host" value="${redis.host}"/>
    </bean>
</beans>

<!-- 缓存禁用时的配置 -->
<beans profile="cache-disabled">
    <bean id="cacheManager" class="...NoOpCacheManager"/>
</beans>
```

**场景3：多条件组合**
```xml
<!-- profile支持表达式 -->

<!-- 开发或测试环境 -->
<beans profile="dev | test">
    <bean id="debugService" class="...DebugService"/>
</beans>

<!-- 非生产环境 -->
<beans profile="!prod">
    <bean id="mockService" class="...MockService"/>
</beans>

<!-- 同时满足多个条件 -->
<beans profile="prod & cache-enabled">
    <bean id="service" class="...ProductionCachedService"/>
</beans>
```

---

## 6. 🧩 模块化配置


### 6.1 什么是模块化配置


**核心理念**：
```
大型项目配置文件管理：

❌ 不好的方式：
applicationContext.xml (5000行配置)
├── 数据层配置
├── 业务层配置  
├── Web层配置
├── 缓存配置
├── 消息队列配置
└── ... (难以维护！)

✅ 模块化方式：
config/
├── applicationContext.xml (主配置，只负责导入)
├── spring-dao.xml (数据层配置)
├── spring-service.xml (业务层配置)
├── spring-web.xml (Web层配置)
├── spring-cache.xml (缓存配置)
└── spring-mq.xml (消息队列配置)

优势：
• 职责清晰，易于维护
• 团队协作不冲突
• 按需加载，提高性能
```

### 6.2 模块化配置策略


**按技术层次划分**：
```
经典三层架构划分：

spring-dao.xml          → 数据访问层
├── 数据源配置
├── MyBatis/Hibernate配置
├── DAO Bean定义
└── 事务管理器

spring-service.xml      → 业务逻辑层
├── Service Bean定义
├── 事务配置
├── AOP配置
└── 业务规则Bean

spring-web.xml          → 表现层
├── Controller配置
├── 视图解析器
├── 拦截器配置
└── 文件上传配置
```

**按业务模块划分**：
```
电商系统示例：

spring-user.xml         → 用户模块
├── UserService
├── UserDao
└── 用户相关配置

spring-order.xml        → 订单模块
├── OrderService
├── OrderDao
└── 订单相关配置

spring-product.xml      → 商品模块
├── ProductService
├── ProductDao
└── 商品相关配置

spring-payment.xml      → 支付模块
├── PaymentService
└── 支付相关配置
```

### 6.3 模块化配置实现


**主配置文件**：
```xml
<!-- applicationContext.xml - 主配置文件 -->
<beans>
    <!-- 1. 加载公共配置 -->
    <import resource="classpath:spring-common.xml"/>
    
    <!-- 2. 加载基础设施配置 -->
    <import resource="classpath:spring-datasource.xml"/>
    <import resource="classpath:spring-cache.xml"/>
    <import resource="classpath:spring-mq.xml"/>
    
    <!-- 3. 加载业务模块配置 -->
    <import resource="classpath:modules/spring-user.xml"/>
    <import resource="classpath:modules/spring-order.xml"/>
    <import resource="classpath:modules/spring-product.xml"/>
    
    <!-- 4. 加载环境相关配置 -->
    <import resource="classpath:env/spring-${spring.profiles.active}.xml"/>
</beans>
```

**公共配置模块**：
```xml
<!-- spring-common.xml - 公共配置 -->
<beans>
    <!-- 加载配置文件 -->
    <context:property-placeholder location="classpath:*.properties"/>
    
    <!-- 公共工具Bean -->
    <bean id="dateUtil" class="com.example.util.DateUtil"/>
    <bean id="stringUtil" class="com.example.util.StringUtil"/>
    
    <!-- 全局异常处理 -->
    <bean id="exceptionHandler" class="...GlobalExceptionHandler"/>
</beans>
```

**数据层配置模块**：
```xml
<!-- spring-datasource.xml - 数据源配置 -->
<beans>
    <!-- 主数据源 -->
    <bean id="masterDataSource" class="...DruidDataSource">
        <property name="url" value="${db.master.url}"/>
        <property name="username" value="${db.master.username}"/>
        <property name="password" value="${db.master.password}"/>
    </bean>
    
    <!-- 从数据源（读写分离） -->
    <bean id="slaveDataSource" class="...DruidDataSource">
        <property name="url" value="${db.slave.url}"/>
        <property name="username" value="${db.slave.username}"/>
        <property name="password" value="${db.slave.password}"/>
    </bean>
    
    <!-- 动态数据源 -->
    <bean id="dataSource" class="...DynamicDataSource">
        <property name="targetDataSources">
            <map>
                <entry key="master" value-ref="masterDataSource"/>
                <entry key="slave" value-ref="slaveDataSource"/>
            </map>
        </property>
        <property name="defaultTargetDataSource" ref="masterDataSource"/>
    </bean>
</beans>
```

**业务模块配置**：
```xml
<!-- modules/spring-user.xml - 用户模块 -->
<beans>
    <!-- 自动扫描用户模块的组件 -->
    <context:component-scan base-package="com.example.user"/>
    
    <!-- 用户模块特定配置 -->
    <bean id="userCache" class="...UserCacheService">
        <property name="cacheManager" ref="cacheManager"/>
    </bean>
    
    <!-- 用户模块AOP配置 -->
    <aop:config>
        <aop:aspect ref="userAspect">
            <aop:pointcut id="userServicePointcut" 
                          expression="execution(* com.example.user.service.*.*(..))"/>
            <aop:before pointcut-ref="userServicePointcut" method="before"/>
        </aop:aspect>
    </aop:config>
</beans>
```

### 6.4 模块化配置最佳实践


**命名规范**：
```
配置文件命名约定：

spring-{模块名}.xml        → 业务模块配置
spring-{技术名}.xml        → 技术组件配置

示例：
spring-user.xml            ✅ 用户模块
spring-order.xml           ✅ 订单模块
spring-datasource.xml      ✅ 数据源配置
spring-cache.xml           ✅ 缓存配置
spring-redis.xml           ✅ Redis配置

避免命名：
config.xml                 ❌ 太笼统
beans.xml                  ❌ 无意义
applicationContext-1.xml   ❌ 无业务含义
```

**目录组织**：
```
resources/
├── applicationContext.xml              (主配置)
├── spring-common.xml                   (公共配置)
│
├── infrastructure/                     (基础设施配置)
│   ├── spring-datasource.xml
│   ├── spring-cache.xml
│   └── spring-mq.xml
│
├── modules/                            (业务模块配置)
│   ├── spring-user.xml
│   ├── spring-order.xml
│   └── spring-product.xml
│
└── env/                                (环境配置)
    ├── spring-dev.xml
    ├── spring-test.xml
    └── spring-prod.xml
```

**加载顺序控制**：
```xml
<!-- applicationContext.xml -->
<beans>
    <!-- 1. 先加载公共配置和工具类 -->
    <import resource="classpath:spring-common.xml"/>
    
    <!-- 2. 再加载基础设施（数据源等） -->
    <import resource="classpath:infrastructure/spring-*.xml"/>
    
    <!-- 3. 最后加载业务模块（依赖前面的基础） -->
    <import resource="classpath:modules/spring-*.xml"/>
    
    <!-- 注意：被依赖的配置要先加载 -->
</beans>
```

**循环依赖避免**：
```
避免循环依赖的原则：

✅ 主配置文件导入子配置
✅ 子配置之间不要相互导入
✅ 使用懒加载解决部分依赖问题

示例：
applicationContext.xml
    ├── import spring-dao.xml
    └── import spring-service.xml

❌ 错误做法：
spring-dao.xml import spring-service.xml
spring-service.xml import spring-dao.xml
(形成循环)

✅ 正确做法：
applicationContext.xml 统一导入两者
```

---

## 7. 📋 核心要点总结


### 7.1 六大配置方式对比


| 配置方式 | 核心作用 | 使用场景 | 优势 |
|---------|---------|---------|------|
| **import导入** | 拆分配置文件 | 大型项目 | 模块化管理 |
| **profile环境** | 多环境切换 | 开发/测试/生产 | 一套代码多环境 |
| **placeholder占位符** | 外部化配置 | 敏感信息、环境差异 | 配置与代码分离 |
| **SpEL表达式** | 动态计算 | 复杂逻辑配置 | 灵活强大 |
| **条件配置** | 按条件加载 | 可选功能 | 精确控制 |
| **模块化配置** | 组织结构 | 团队协作 | 清晰易维护 |

### 7.2 核心理解要点


**🔹 import导入**
```
记忆要点：
• 作用：把一个大配置文件拆成多个小文件
• 语法：<import resource="路径"/>
• 推荐：使用classpath:前缀
• 注意：避免循环导入
```

**🔹 profile环境配置**
```
记忆要点：
• 作用：同一应用不同环境用不同配置
• 定义：<beans profile="dev">
• 激活：-Dspring.profiles.active=dev
• 场景：开发/测试/生产环境切换
```

**🔹 placeholder占位符**
```
记忆要点：
• 作用：从外部文件读取配置值
• 语法：${配置项名称}
• 优势：敏感信息不写死在XML
• 配置：<context:property-placeholder location="..."/>
```

**🔹 SpEL表达式**
```
记忆要点：
• 作用：在配置中进行计算和判断
• 语法：#{表达式}
• 能力：调用方法、逻辑运算、访问属性
• 对比：比占位符功能更强大
```

**🔹 条件配置**
```
记忆要点：
• 作用：满足条件才加载Bean
• 实现：主要通过profile实现
• 场景：可选功能、环境差异
• 技巧：可以用SpEL做条件判断
```

**🔹 模块化配置**
```
记忆要点：
• 作用：组织和管理大型项目配置
• 方式：按技术层次或业务模块划分
• 原则：职责清晰、避免循环
• 实践：主配置只做导入，子配置负责具体功能
```

### 7.3 实际应用建议


**配置组织建议**：
```
小型项目（<10个Bean）：
└── applicationContext.xml (单文件即可)

中型项目（10-50个Bean）：
├── applicationContext.xml
├── spring-dao.xml
└── spring-service.xml

大型项目（>50个Bean）：
├── applicationContext.xml
├── infrastructure/
│   ├── spring-datasource.xml
│   ├── spring-cache.xml
│   └── spring-mq.xml
└── modules/
    ├── spring-user.xml
    ├── spring-order.xml
    └── spring-product.xml
```

**环境配置建议**：
```
开发阶段：
✅ 使用profile区分开发/测试/生产
✅ 敏感信息用placeholder
✅ 本地开发用dev profile

上线部署：
✅ 通过JVM参数激活profile
✅ 生产配置独立管理
✅ 敏感信息加密存储
```

**学习路径建议**：
```
第1阶段：掌握基础
• 理解import导入的作用
• 掌握placeholder的使用
• 了解profile的概念

第2阶段：深入应用  
• 灵活使用SpEL表达式
• 掌握条件配置技巧
• 实践模块化配置

第3阶段：最佳实践
• 设计合理的配置结构
• 制定配置规范
• 优化配置性能
```

### 7.4 常见问题答疑


**Q1：什么时候用import，什么时候用component-scan？**
```
import：导入XML配置文件
<import resource="spring-dao.xml"/>

component-scan：扫描Java类上的注解
<context:component-scan base-package="com.example"/>

区别：
• import用于组织XML配置
• component-scan用于识别注解Bean
• 两者互补，常常一起使用
```

**Q2：placeholder和SpEL有什么区别？**
```
placeholder（占位符）：
• 语法：${key}
• 作用：从properties文件读取值
• 特点：简单替换，不能计算
• 用途：外部化配置

SpEL（表达式）：
• 语法：#{expression}
• 作用：动态计算和判断
• 特点：功能强大，支持运算
• 用途：复杂逻辑配置

选择建议：
• 简单配置用placeholder
• 需要计算用SpEL
```

**Q3：如何选择配置拆分方式？**
```
按技术层次拆分：
✅ 适合：传统三层架构项目
✅ 优势：技术边界清晰
示例：spring-dao.xml, spring-service.xml

按业务模块拆分：
✅ 适合：微服务、DDD项目
✅ 优势：业务逻辑内聚
示例：spring-user.xml, spring-order.xml

混合方式：
✅ 适合：大型复杂项目
✅ 优势：兼顾技术和业务
示例：基础设施+业务模块分离
```

**核心记忆口诀**：
```
import导入拆配置，模块清晰好管理
profile环境来切换，开发生产都不难
placeholder占位符，配置分离更安全
SpEL表达式功能强，计算判断都能上
条件配置按需加，功能开关很灵活
模块化是好习惯，团队协作效率高
```