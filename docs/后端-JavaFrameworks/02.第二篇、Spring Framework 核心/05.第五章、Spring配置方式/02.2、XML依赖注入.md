---
title: 2、XML依赖注入
---
## 📚 目录

1. [什么是依赖注入](#1-什么是依赖注入)
2. [property属性注入](#2-property属性注入)
3. [constructor-arg构造器注入](#3-constructor-arg构造器注入)
4. [ref引用与value值的使用](#4-ref引用与value值的使用)
5. [内部Bean的妙用](#5-内部Bean的妙用)
6. [集合类型注入](#6-集合类型注入)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 什么是依赖注入


### 1.1 生活中的例子理解依赖注入


> 💡 **通俗理解**
> 
> 想象你要泡一杯咖啡：
> - **传统方式**：自己去买咖啡豆、磨豆机、咖啡杯（自己创建依赖）
> - **依赖注入**：咖啡店直接给你一杯泡好的咖啡（别人帮你准备好依赖）

**依赖注入（DI）就是"别人帮你准备好需要的东西"**

### 1.2 技术概念解释


**🔸 依赖是什么？**
- 一个类需要用到另一个类，这种"需要"就是依赖
- 比如：汽车需要引擎，汽车就**依赖**引擎

**🔸 注入是什么？**
- 不是自己创建依赖对象，而是由外部传递进来
- Spring框架帮你创建对象，然后"注入"到需要的地方

```
传统方式（自己new）：
我需要引擎 → 我自己new一个引擎 → 不灵活

依赖注入方式：
我需要引擎 → Spring帮我创建引擎 → Spring注入给我 → 灵活可配置
```

### 1.3 XML配置的作用


**XML配置文件就像"配方单"**：
- 告诉Spring要创建哪些对象
- 这些对象之间的关系是什么
- 怎么把它们组装起来

---

## 2. 🔧 property属性注入


### 2.1 什么是属性注入


**属性注入 = 通过setter方法给对象的属性赋值**

> 📖 **类比理解**
> 
> 就像组装电脑：
> - 电脑主机（对象）已经造好了
> - 后期添加内存条（属性）
> - 通过内存插槽（setter方法）安装

### 2.2 基本使用方法


**Java类准备**：
```java
public class UserService {
    private String serviceName;  // 需要注入的属性
    private int maxConnections;
    
    // 必须有setter方法，Spring才能注入
    public void setServiceName(String serviceName) {
        this.serviceName = serviceName;
    }
    
    public void setMaxConnections(int maxConnections) {
        this.maxConnections = maxConnections;
    }
}
```

**XML配置**：
```xml
<bean id="userService" class="com.example.UserService">
    <!-- 注入String类型属性 -->
    <property name="serviceName" value="用户管理服务"/>
    
    <!-- 注入int类型属性 -->
    <property name="maxConnections" value="100"/>
</bean>
```

**🔑 关键点理解**：
- `name="serviceName"` → 对应setter方法去掉set，首字母小写
- `value="xxx"` → 给属性赋的具体值
- Spring会自动调用`setServiceName()`方法完成注入

### 2.3 属性注入的工作流程


```
Spring容器启动
    ↓
读取XML配置
    ↓
创建UserService对象（调用无参构造）
    ↓
看到<property>标签
    ↓
调用setServiceName("用户管理服务")
    ↓
调用setMaxConnections(100)
    ↓
对象注入完成，放入容器
```

---

## 3. 🏗️ constructor-arg构造器注入


### 3.1 构造器注入是什么


**构造器注入 = 在创建对象时就通过构造方法传入依赖**

> 💡 **类比理解**
> 
> 就像买手机：
> - 属性注入：先买裸机，后期自己贴膜、装壳
> - 构造器注入：买的时候就配好膜和壳，一步到位

### 3.2 基本使用示例


**Java类准备**：
```java
public class OrderService {
    private String orderType;
    private double discountRate;
    
    // 带参数的构造方法
    public OrderService(String orderType, double discountRate) {
        this.orderType = orderType;
        this.discountRate = discountRate;
    }
}
```

**XML配置方式1 - 按参数位置**：
```xml
<bean id="orderService" class="com.example.OrderService">
    <!-- 第1个参数 -->
    <constructor-arg index="0" value="在线订单"/>
    <!-- 第2个参数 -->
    <constructor-arg index="1" value="0.85"/>
</bean>
```

**XML配置方式2 - 按参数名称**（推荐）：
```xml
<bean id="orderService" class="com.example.OrderService">
    <constructor-arg name="orderType" value="在线订单"/>
    <constructor-arg name="discountRate" value="0.85"/>
</bean>
```

### 3.3 构造器注入的优势


**✅ 为什么要用构造器注入？**

| 特点 | 说明 | 实际意义 |
|------|------|----------|
| **强制依赖** | 对象创建时必须提供 | 保证对象一创建就可用 |
| **不可变性** | 依赖传入后不再改变 | 更安全，不会被意外修改 |
| **清晰明确** | 一看构造方法就知道依赖 | 代码更容易理解 |

⚠️ **注意事项**：
- 构造方法的参数顺序要和XML中`index`或实际参数对应
- 如果参数很多（超过3个），建议用属性注入，否则构造方法太复杂

---

## 4. 🔗 ref引用与value值的使用


### 4.1 value和ref的区别


**这是新手最容易混淆的地方！**

```
value - 给简单类型赋值（直接写值）
用于：String、int、double、boolean等基本类型

ref - 引用其他Bean（引用对象）
用于：自定义的类、复杂对象
```

### 4.2 value值注入（简单类型）


**适用场景**：配置文件路径、端口号、开关等简单值

```xml
<bean id="config" class="com.example.Config">
    <!-- 字符串 -->
    <property name="appName" value="我的应用"/>
    
    <!-- 数字 -->
    <property name="port" value="8080"/>
    
    <!-- 布尔值 -->
    <property name="enabled" value="true"/>
</bean>
```

### 4.3 ref引用注入（对象类型）


**实际业务场景**：
```java
// UserService需要用到UserDao
public class UserService {
    private UserDao userDao;  // 这是一个对象，不是简单类型
    
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

**XML配置**：
```xml
<!-- 先定义UserDao -->
<bean id="userDao" class="com.example.UserDao"/>

<!-- UserService引用上面的userDao -->
<bean id="userService" class="com.example.UserService">
    <!-- 用ref引用，不能用value -->
    <property name="userDao" ref="userDao"/>
</bean>
```

**🔑 记忆技巧**：
- 能直接写出来的值 → 用`value`
- 需要引用别的Bean → 用`ref`

### 4.4 混合使用示例


```xml
<bean id="emailService" class="com.example.EmailService">
    <!-- 简单值用value -->
    <property name="smtpHost" value="smtp.qq.com"/>
    <property name="smtpPort" value="587"/>
    
    <!-- 引用对象用ref -->
    <property name="mailSender" ref="mailSenderBean"/>
</bean>

<bean id="mailSenderBean" class="com.example.MailSender"/>
```

---

## 5. 🎁 内部Bean的妙用


### 5.1 什么是内部Bean


**内部Bean = 只在当前Bean内部使用的Bean，不需要单独定义**

> 💡 **生活类比**
> 
> - 普通Bean：买一个共用的打印机，放在办公室，大家都能用
> - 内部Bean：买一个私人打印机，只放在你办公桌下，只有你能用

### 5.2 使用场景


**什么时候用内部Bean？**
- ✅ 这个对象只被一个地方使用
- ✅ 不需要复用
- ✅ 让配置更清晰集中

### 5.3 实际代码示例


**不用内部Bean的写法**：
```xml
<!-- 定义一个单独的Bean -->
<bean id="address" class="com.example.Address">
    <property name="city" value="北京"/>
    <property name="street" value="朝阳路100号"/>
</bean>

<!-- Person引用address -->
<bean id="person" class="com.example.Person">
    <property name="name" value="张三"/>
    <property name="address" ref="address"/>
</bean>
```

**用内部Bean的写法**（推荐，当address只给person用）：
```xml
<bean id="person" class="com.example.Person">
    <property name="name" value="张三"/>
    
    <!-- 直接在这里定义Bean，不需要单独的id -->
    <property name="address">
        <bean class="com.example.Address">
            <property name="city" value="北京"/>
            <property name="street" value="朝阳路100号"/>
        </bean>
    </property>
</bean>
```

**🔸 优势对比**：

| 方式 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **外部Bean** | 可复用、可被多处引用 | 配置分散 | 需要共享的对象 |
| **内部Bean** | 配置集中、一目了然 | 不能复用 | 专属某个Bean的依赖 |

---

## 6. 📦 集合类型注入


### 6.1 为什么需要集合注入


**实际业务中经常遇到的场景**：
- 配置多个数据库地址
- 配置允许访问的IP白名单
- 配置系统支持的多种支付方式

这些都需要用到集合！

### 6.2 List列表注入


**Java类**：
```java
public class SystemConfig {
    private List<String> allowedIPs;  // IP白名单
    
    public void setAllowedIPs(List<String> allowedIPs) {
        this.allowedIPs = allowedIPs;
    }
}
```

**XML配置**：
```xml
<bean id="config" class="com.example.SystemConfig">
    <property name="allowedIPs">
        <list>
            <value>192.168.1.100</value>
            <value>192.168.1.101</value>
            <value>192.168.1.102</value>
        </list>
    </property>
</bean>
```

**🔸 如果List里是对象呢？**
```xml
<property name="userList">
    <list>
        <ref bean="user1"/>
        <ref bean="user2"/>
        <!-- 或者用内部bean -->
        <bean class="com.example.User">
            <property name="name" value="李四"/>
        </bean>
    </list>
</property>
```

### 6.3 Set集合注入


**Set和List的区别**：
- List：允许重复，有顺序
- Set：不允许重复，无顺序

```xml
<bean id="config" class="com.example.Config">
    <property name="uniqueValues">
        <set>
            <value>值1</value>
            <value>值2</value>
            <value>值1</value> <!-- 重复值会被自动去除 -->
        </set>
    </property>
</bean>
```

### 6.4 Map键值对注入


**实际应用场景**：配置错误码和错误信息

**Java类**：
```java
public class ErrorConfig {
    private Map<String, String> errorMessages;
    
    public void setErrorMessages(Map<String, String> errorMessages) {
        this.errorMessages = errorMessages;
    }
}
```

**XML配置**：
```xml
<bean id="errorConfig" class="com.example.ErrorConfig">
    <property name="errorMessages">
        <map>
            <!-- key是错误码，value是错误信息 -->
            <entry key="404" value="页面不存在"/>
            <entry key="500" value="服务器错误"/>
            <entry key="403" value="没有权限"/>
        </map>
    </property>
</bean>
```

**🔸 Map的value是对象怎么办？**
```xml
<map>
    <entry key="userService" value-ref="userServiceBean"/>
    <entry key="orderService" value-ref="orderServiceBean"/>
</map>
```

### 6.5 Properties属性注入


**Properties是特殊的Map（key和value都是String）**

**典型用途**：配置数据库连接信息

```xml
<bean id="dataSource" class="com.example.DataSource">
    <property name="properties">
        <props>
            <prop key="driver">com.mysql.jdbc.Driver</prop>
            <prop key="url">jdbc:mysql://localhost:3306/mydb</prop>
            <prop key="username">root</prop>
            <prop key="password">123456</prop>
        </props>
    </property>
</bean>
```

### 6.6 集合注入完整示例


```xml
<bean id="appConfig" class="com.example.AppConfig">
    <!-- List：多个数据库地址 -->
    <property name="dbHosts">
        <list>
            <value>192.168.1.10</value>
            <value>192.168.1.11</value>
        </list>
    </property>
    
    <!-- Set：支持的支付方式（不重复） -->
    <property name="paymentMethods">
        <set>
            <value>支付宝</value>
            <value>微信</value>
            <value>银联</value>
        </set>
    </property>
    
    <!-- Map：服务配置 -->
    <property name="serviceConfig">
        <map>
            <entry key="timeout" value="30"/>
            <entry key="retry" value="3"/>
        </map>
    </property>
    
    <!-- Properties：系统属性 -->
    <property name="systemProps">
        <props>
            <prop key="app.version">1.0.0</prop>
            <prop key="app.env">production</prop>
        </props>
    </property>
</bean>
```

---

## 7. 📋 核心要点总结


### 7.1 依赖注入方式速查


| 注入方式 | 标签 | 适用场景 | 记忆口诀 |
|----------|------|----------|----------|
| **属性注入** | `<property>` | 可选依赖，后期可修改 | 后装配，灵活调 |
| **构造器注入** | `<constructor-arg>` | 必须依赖，创建就要有 | 建造时，一步到位 |
| **内部Bean** | 嵌套`<bean>` | 专属依赖，不复用 | 专人专用，不外借 |
| **集合注入** | `<list>/<set>/<map>` | 多值配置 | 批量配，集中管 |

### 7.2 value和ref的区别


```
📌 记住这个对比：

value - 直接值
• String、int、double、boolean
• 能直接写出来的
• 示例：value="8080"

ref - 引用对象  
• 其他Bean
• 需要Spring创建的对象
• 示例：ref="userDao"
```

### 7.3 最佳实践建议


**🟢 必知必会**：
- 简单值用`value`，对象用`ref`
- 强制依赖用构造器，可选依赖用属性
- 只用一次的对象用内部Bean
- 批量配置用集合注入

**⚡ 实战技巧**：
```xml
<!-- 好习惯：注释清楚每个配置的作用 -->
<bean id="userService" class="com.example.UserService">
    <!-- 数据访问层依赖 -->
    <property name="userDao" ref="userDao"/>
    
    <!-- 缓存配置 -->
    <property name="cacheEnabled" value="true"/>
    
    <!-- 超时时间（秒） -->
    <property name="timeout" value="30"/>
</bean>
```

**❌ 常见错误**：
```xml
<!-- 错误1：对象用了value -->
<property name="userDao" value="userDao"/>  <!-- 错误！应该用ref -->

<!-- 错误2：简单值用了ref -->
<property name="port" ref="8080"/>  <!-- 错误！应该用value -->

<!-- 错误3：setter方法名不匹配 -->
<property name="userName" value="张三"/>  
<!-- Java类里必须有setUserName方法，不是setusername -->
```

### 7.4 学习路线图


```
🎯 学习建议：

第1步：掌握基础
└─ property和constructor-arg的基本用法

第2步：理解原理  
└─ 为什么有value和ref？什么时候用哪个？

第3步：实战应用
└─ 内部Bean和集合注入的实际场景

第4步：灵活运用
└─ 根据业务需求选择最合适的注入方式
```

### 7.5 一句话记忆


> 🧠 **核心记忆**
> 
> **"Spring当保姆，帮我组装对象"**
> - 简单值直接给（value）
> - 复杂对象帮我找（ref）
> - 创建时给叫构造，创建后给叫属性
> - 只用一次包里装（内部Bean）
> - 批量配置用集合

---

## 🔖 快速参考卡


```
┌─────────────────────────────────────┐
│ XML依赖注入速查                      │
├─────────────────────────────────────┤
│ 属性注入：<property name="" value=""/>│
│ 构造注入：<constructor-arg value=""/> │
│ 引用对象：ref="beanId"               │
│ 内部Bean：<property><bean/></property>│
│ List集合：<list><value/></list>      │
│ Set集合： <set><value/></set>        │
│ Map映射： <map><entry/></map>        │
│ Properties：<props><prop/></props>   │
└─────────────────────────────────────┘
```