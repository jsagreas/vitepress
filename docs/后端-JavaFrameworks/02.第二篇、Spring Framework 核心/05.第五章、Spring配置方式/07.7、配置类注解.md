---
title: 7、配置类注解
---
## 📚 目录

1. [@Configuration配置类](#1-configuration配置类)
2. [@Bean方法配置](#2-bean方法配置)
3. [@Import导入配置](#3-import导入配置)
4. [@ComponentScan组件扫描](#4-componentscan组件扫描)
5. [@Conditional条件配置](#5-conditional条件配置)
6. [@Profile环境配置](#6-profile环境配置)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔧 @Configuration配置类


### 1.1 什么是@Configuration


**📋 核心理解**

`@Configuration` 就是告诉Spring："这个类是专门用来做配置的"。你可以把它想象成传统XML配置文件的Java版本。

```
传统方式（XML文件）：          现代方式（Java类）：
┌─────────────────┐          ┌──────────────────┐
│ applicationContext.xml │    │ @Configuration   │
│ <beans>          │          │ public class Config {
│   <bean id="..." │          │   @Bean          │
│   class="..."/>  │          │   public User user()
│ </beans>         │          │ }                │
└─────────────────┘          └──────────────────┘
```

**🎯 为什么要用它**
- **类型安全**：编译期就能发现错误，不像XML要运行才知道
- **代码提示**：IDE能提供完整的代码提示和重构支持
- **灵活性**：可以用Java的全部特性来做配置

### 1.2 基础使用示例


```java
// 这就是一个配置类
@Configuration
public class AppConfig {
    
    // 创建一个数据源对象
    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setUrl("jdbc:mysql://localhost:3306/mydb");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
```

**💡 理解要点**
- `@Configuration`：标记这是个配置类
- 配置类本身也会被Spring管理（成为Bean）
- 配置类里可以定义多个`@Bean`方法

### 1.3 配置类的特殊性


**🔸 CGLIB代理增强**

Spring会对`@Configuration`类做特殊处理：

```
普通类调用方法：                配置类调用方法：
┌─────────────┐              ┌──────────────────┐
│ 每次调用    │              │ Spring拦截调用   │
│ 都创建新对象 │   ====>     │ 返回容器中的单例 │
│ obj1 != obj2│              │ obj1 == obj2     │
└─────────────┘              └──────────────────┘
```

```java
@Configuration
public class Config {
    
    @Bean
    public User user() {
        return new User();
    }
    
    @Bean
    public Order order() {
        // 这里调用user()方法，Spring会确保返回同一个User实例
        User u = user(); // 不会创建新对象，返回容器中的单例
        return new Order(u);
    }
}
```

**⚠️ 注意事项**

| 配置方式 | Bean单例保证 | 类代理 | 适用场景 |
|---------|------------|--------|---------|
| `@Configuration` | ✅ 保证单例 | ✅ CGLIB代理 | `Bean间有依赖关系` |
| `@Component` + `@Bean` | ❌ 每次新建 | ❌ 无代理 | `简单Bean定义` |

---

## 2. 🎯 @Bean方法配置


### 2.1 @Bean的本质含义


**📋 核心概念**

`@Bean` 注解的方法相当于告诉Spring："请把这个方法的返回值对象放到容器中管理"。

```
你的代码：                    Spring的理解：
┌─────────────────┐        ┌─────────────────────┐
│ @Bean           │        │ 1. 调用这个方法     │
│ public User user() {│ ==> │ 2. 拿到返回的对象   │
│   return new User();│    │ 3. 放入Spring容器   │
│ }               │        │ 4. 以后需要就给你   │
└─────────────────┘        └─────────────────────┘
```

### 2.2 Bean的命名规则


**🔸 默认命名**
```java
@Bean
public DataSource dataSource() {
    // Bean的名字就是方法名：dataSource
    return new HikariDataSource();
}
```

**🔸 自定义名称**
```java
@Bean(name = "mainDB")  // 或 @Bean("mainDB")
public DataSource dataSource() {
    // Bean的名字是：mainDB
    return new HikariDataSource();
}

// 还可以指定多个名字（别名）
@Bean({"db", "dataSource", "mainDatabase"})
public DataSource dataSource() {
    return new HikariDataSource();
}
```

### 2.3 Bean的依赖注入


**🔸 方法参数自动注入**

Spring会自动从容器中找到匹配的Bean注入进来：

```java
@Configuration
public class AppConfig {
    
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
    
    @Bean
    // Spring会自动把上面的dataSource注入到这个参数
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
    
    @Bean
    // 可以注入多个参数
    public UserService userService(UserDao userDao, EmailService emailService) {
        return new UserService(userDao, emailService);
    }
}
```

**💡 注入方式对比**

```
方法参数注入（推荐）：
✅ 简洁清晰
✅ 依赖关系明确
✅ 方便测试

直接调用方法：
@Bean
public UserService userService() {
    return new UserService(userDao()); // 也可以，但不推荐
}
```

### 2.4 Bean的初始化和销毁


**🔸 生命周期回调**

```java
@Bean(initMethod = "init", destroyMethod = "cleanup")
public DataSource dataSource() {
    return new MyDataSource();
}

// MyDataSource类中需要有这两个方法
public class MyDataSource {
    public void init() {
        System.out.println("数据源初始化...");
    }
    
    public void cleanup() {
        System.out.println("数据源关闭连接...");
    }
}
```

**🔸 执行时机**

```
Spring容器启动流程：
┌─────────────────────────────────┐
│ 1. 创建Bean对象                  │
│ 2. 设置属性（依赖注入）          │
│ 3. 调用initMethod               │  ← Bean可以使用了
│ 4. Bean准备就绪                  │
│ ...                             │
│ 5. 容器关闭                      │
│ 6. 调用destroyMethod            │  ← 清理资源
└─────────────────────────────────┘
```

---

## 3. 📦 @Import导入配置


### 3.1 为什么需要@Import


**📋 实际场景**

随着项目变大，配置会越来越多，不可能都写在一个配置类里。`@Import`就是用来组织多个配置类的。

```
大型项目配置结构：
┌─────────────────┐
│ MainConfig      │  ← 主配置
│ @Import({       │
│   DataConfig,   │  ← 数据库配置
│   WebConfig,    │  ← Web配置
│   SecurityConfig│  ← 安全配置
│ })              │
└─────────────────┘
```

### 3.2 基础用法


**🔸 导入单个配置类**

```java
@Configuration
@Import(DatabaseConfig.class)
public class AppConfig {
    // AppConfig会自动包含DatabaseConfig中的所有Bean
}
```

**🔸 导入多个配置类**

```java
@Configuration
@Import({
    DatabaseConfig.class,
    CacheConfig.class,
    MessageConfig.class
})
public class AppConfig {
    // 一次导入多个配置
}
```

### 3.3 高级用法：导入普通类


**🔸 导入后自动注册为Bean**

```java
// 这是一个普通类，没有任何注解
public class MyService {
    public void doSomething() {
        System.out.println("执行业务逻辑");
    }
}

// 在配置类中导入
@Configuration
@Import(MyService.class)  // 直接导入普通类
public class AppConfig {
    // MyService会自动成为Bean，可以被注入使用
}
```

**💡 三种导入方式对比**

| 导入类型 | 示例 | 说明 |
|---------|------|------|
| `配置类` | `@Import(DatabaseConfig.class)` | `导入其他@Configuration类` |
| `普通类` | `@Import(MyService.class)` | `普通类自动变成Bean` |
| `ImportSelector` | `@Import(MyImportSelector.class)` | `动态决定导入哪些类` |

### 3.4 ImportSelector动态导入


**🔸 使用场景**

当你需要根据条件动态决定导入哪些配置时使用：

```java
// 1. 实现ImportSelector接口
public class MyImportSelector implements ImportSelector {
    
    @Override
    public String[] selectImports(AnnotationMetadata metadata) {
        // 可以根据条件返回不同的配置类名
        if (某个条件) {
            return new String[]{"com.example.ConfigA"};
        } else {
            return new String[]{"com.example.ConfigB"};
        }
    }
}

// 2. 使用
@Configuration
@Import(MyImportSelector.class)
public class AppConfig {
}
```

---

## 4. 🔍 @ComponentScan组件扫描


### 4.1 什么是组件扫描


**📋 核心理解**

`@ComponentScan`的作用是告诉Spring："去这些包里找带注解的类，自动注册成Bean"。

```
手动配置方式：                  组件扫描方式：
┌─────────────────┐          ┌──────────────────────┐
│ @Bean           │          │ @ComponentScan("com.example")
│ public UserService() {...} │ ====> Spring自动找到：
│ @Bean           │          │ @Service UserService
│ public OrderService(){...} │ @Repository UserDao
│ ...             │          │ @Controller UserController
│ 要写很多@Bean   │          │ 自动全部注册         │
└─────────────────┘          └──────────────────────┘
```

### 4.2 基础使用


**🔸 扫描当前包及子包**

```java
@Configuration
@ComponentScan  // 不指定路径，扫描当前类所在包及子包
public class AppConfig {
}
```

**🔸 指定扫描路径**

```java
@Configuration
@ComponentScan("com.example.service")  // 扫描指定包
public class AppConfig {
}

// 扫描多个包
@Configuration
@ComponentScan({"com.example.service", "com.example.dao"})
public class AppConfig {
}
```

### 4.3 过滤规则


**🔸 排除某些类**

```java
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.ANNOTATION,
        classes = Controller.class  // 不扫描@Controller注解的类
    )
)
```

**🔸 只包含某些类**

```java
@ComponentScan(
    basePackages = "com.example",
    includeFilters = @ComponentScan.Filter(
        type = FilterType.ANNOTATION,
        classes = Service.class  // 只扫描@Service注解的类
    ),
    useDefaultFilters = false  // 必须设为false，否则includeFilters不生效
)
```

**🔸 常用过滤类型**

| 过滤类型 | 说明 | 示例 |
|---------|------|------|
| `ANNOTATION` | `按注解过滤` | `classes = Service.class` |
| `ASSIGNABLE_TYPE` | `按类型过滤` | `classes = UserService.class` |
| `REGEX` | `正则表达式` | `pattern = ".*Service"` |
| `CUSTOM` | `自定义过滤器` | `classes = MyFilter.class` |

### 4.4 实际应用场景


**🎯 典型配置示例**

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            classes = {Controller.class, Configuration.class}
        )
    }
)
public class ServiceConfig {
    // 扫描所有业务类，但排除Controller和其他配置类
}
```

---

## 5. ✅ @Conditional条件配置


### 5.1 条件配置的作用


**📋 核心理解**

`@Conditional`就像是给Bean加了一个"开关"，只有满足条件才会创建这个Bean。

```
无条件创建：                    条件创建：
┌──────────┐                ┌─────────────────┐
│ @Bean    │                │ @Bean           │
│ public User user() {│ VS   │ @Conditional(...)│
│   return new User();│      │ public User user() {
│ }        │                │   // 条件满足才创建
│ 总是创建  │                │ }               │
└──────────┘                └─────────────────┘
```

### 5.2 常用条件注解


**🔸 根据配置文件决定**

```java
// 只有配置文件中有这个属性才创建
@Bean
@ConditionalOnProperty(name = "feature.email.enabled", havingValue = "true")
public EmailService emailService() {
    return new EmailService();
}
```

**配置文件（application.properties）：**
```properties
# 设置为true，EmailService才会被创建
feature.email.enabled=true
```

**🔸 根据类是否存在**

```java
// 只有项目中有Redis相关的类才创建
@Bean
@ConditionalOnClass(name = "redis.clients.jedis.Jedis")
public RedisCache redisCache() {
    return new RedisCache();
}
```

**🔸 根据Bean是否存在**

```java
// 容器中没有DataSource时才创建默认的
@Bean
@ConditionalOnMissingBean(DataSource.class)
public DataSource defaultDataSource() {
    return new H2DataSource();  // 默认用H2数据库
}

// 容器中已有DataSource时才创建这个
@Bean
@ConditionalOnBean(DataSource.class)
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}
```

### 5.3 自定义条件


**🔸 实现Condition接口**

```java
// 1. 自定义条件类
public class WindowsCondition implements Condition {
    
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 判断是否是Windows系统
        String osName = context.getEnvironment().getProperty("os.name");
        return osName != null && osName.contains("Windows");
    }
}

// 2. 使用
@Bean
@Conditional(WindowsCondition.class)
public FileService windowsFileService() {
    return new WindowsFileService();
}

@Bean
@Conditional(LinuxCondition.class)
public FileService linuxFileService() {
    return new LinuxFileService();
}
```

**💡 条件判断流程**

```
Bean创建前：
┌─────────────────────────┐
│ 1. 检查@Conditional条件  │
│    ↓                    │
│ 2. 条件满足？            │
│    ├─ 是 → 创建Bean     │
│    └─ 否 → 跳过         │
└─────────────────────────┘
```

### 5.4 实际应用场景


**🎯 多环境配置示例**

```java
@Configuration
public class DataSourceConfig {
    
    // 开发环境：使用H2内存数据库
    @Bean
    @ConditionalOnProperty(name = "spring.profiles.active", havingValue = "dev")
    public DataSource devDataSource() {
        return new H2DataSource();
    }
    
    // 生产环境：使用MySQL
    @Bean
    @ConditionalOnProperty(name = "spring.profiles.active", havingValue = "prod")
    public DataSource prodDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setUrl("jdbc:mysql://prod-server:3306/mydb");
        return ds;
    }
}
```

---

## 6. 🌍 @Profile环境配置


### 6.1 Profile的作用


**📋 核心理解**

`@Profile`用于区分不同环境（开发、测试、生产）的配置。同一个Bean在不同环境可能需要不同的实现。

```
开发环境：                     生产环境：
┌────────────────┐          ┌────────────────────┐
│ 数据库：H2内存库│          │ 数据库：MySQL集群   │
│ 日志：DEBUG级别 │   ≠      │ 日志：ERROR级别     │
│ 缓存：本地缓存  │          │ 缓存：Redis集群     │
└────────────────┘          └────────────────────┘
```

### 6.2 基础使用


**🔸 在配置类上使用**

```java
// 开发环境配置
@Configuration
@Profile("dev")
public class DevConfig {
    
    @Bean
    public DataSource dataSource() {
        // 开发环境用H2数据库
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}

// 生产环境配置
@Configuration
@Profile("prod")
public class ProdConfig {
    
    @Bean
    public DataSource dataSource() {
        // 生产环境用MySQL
        HikariDataSource ds = new HikariDataSource();
        ds.setUrl("jdbc:mysql://localhost:3306/mydb");
        return ds;
    }
}
```

**🔸 在Bean方法上使用**

```java
@Configuration
public class AppConfig {
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new H2DataSource();
    }
    
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        return new MySQLDataSource();
    }
}
```

### 6.3 激活Profile


**🔸 方式1：配置文件**

```properties
# application.properties
spring.profiles.active=dev
```

**🔸 方式2：命令行参数**

```bash
java -jar myapp.jar --spring.profiles.active=prod
```

**🔸 方式3：代码中设置**

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext context = 
        new AnnotationConfigApplicationContext();
    
    // 设置激活的profile
    context.getEnvironment().setActiveProfiles("dev");
    context.register(AppConfig.class);
    context.refresh();
}
```

### 6.4 多Profile组合


**🔸 同时激活多个Profile**

```properties
# 同时激活dev和debug两个环境
spring.profiles.active=dev,debug
```

```java
@Configuration
@Profile({"dev", "test"})  // dev或test环境都会加载
public class DevTestConfig {
}

@Configuration
@Profile("!prod")  // 非生产环境加载（dev、test等）
public class NonProdConfig {
}
```

**💡 Profile匹配规则**

| 表达式 | 含义 | 示例 |
|--------|------|------|
| `"dev"` | `激活dev环境时加载` | `@Profile("dev")` |
| `"!prod"` | `非prod环境加载` | `@Profile("!prod")` |
| `"dev \| test"` | `dev或test加载` | `@Profile({"dev","test"})` |
| `"dev & debug"` | `同时激活才加载` | `需组合使用` |

### 6.5 实际应用场景


**🎯 完整的多环境配置**

```java
@Configuration
public class AppConfig {
    
    // 开发环境：内存数据库 + 详细日志
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        System.out.println("使用开发环境配置");
        return new H2DataSource();
    }
    
    // 测试环境：独立测试库
    @Bean
    @Profile("test")
    public DataSource testDataSource() {
        System.out.println("使用测试环境配置");
        HikariDataSource ds = new HikariDataSource();
        ds.setUrl("jdbc:mysql://test-server:3306/testdb");
        return ds;
    }
    
    // 生产环境：主从复制 + 连接池优化
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        System.out.println("使用生产环境配置");
        HikariDataSource ds = new HikariDataSource();
        ds.setUrl("jdbc:mysql://master:3306/proddb");
        ds.setMaximumPoolSize(50);
        return ds;
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🔸 六大注解的作用**

```
@Configuration    → 声明这是配置类
@Bean            → 定义Bean对象
@Import          → 导入其他配置
@ComponentScan   → 自动扫描组件
@Conditional     → 条件化配置
@Profile         → 环境区分
```

### 7.2 配置方式选择指南


| 场景 | 推荐方式 | 原因 |
|------|---------|------|
| `第三方类无法修改` | `@Bean` | `无法添加@Component等注解` |
| `自己的业务类` | `@Component + @ComponentScan` | `简单方便，自动注册` |
| `需要复杂初始化` | `@Bean方法` | `可以编写初始化逻辑` |
| `不同环境不同配置` | `@Profile` | `环境隔离` |
| `条件化创建Bean` | `@Conditional` | `按需创建` |

### 7.3 实际开发建议


**✅ 最佳实践**

1. **配置类分层**
   ```
   MainConfig（主配置）
     ├─ DatabaseConfig（数据库）
     ├─ WebConfig（Web）
     └─ SecurityConfig（安全）
   ```

2. **环境配置分离**
   ```properties
   # 公共配置：application.properties
   # 开发配置：application-dev.properties  
   # 生产配置：application-prod.properties
   ```

3. **合理使用注解**
   - 简单Bean → `@Component`
   - 第三方Bean → `@Bean`
   - 复杂逻辑 → `@Bean`方法
   - 条件创建 → `@Conditional`
   - 环境区分 → `@Profile`

### 7.4 常见问题解答


**❓ @Configuration和@Component的区别**

> @Configuration会被CGLIB代理，保证Bean单例；@Component不会，方法调用会创建新对象

**❓ 什么时候用@Bean，什么时候用@Component**

> 自己写的类用@Component；第三方类或需要复杂初始化逻辑用@Bean

**❓ @Import和@ComponentScan的区别**

> @Import精确导入指定类；@ComponentScan扫描包下所有符合条件的类

**🧠 记忆口诀**

```
配置类用Configuration，Bean方法把对象装
Import导入好帮手，ComponentScan包里找
Conditional按条件来，Profile环境要分清
组合使用更灵活，Spring配置不再难
```