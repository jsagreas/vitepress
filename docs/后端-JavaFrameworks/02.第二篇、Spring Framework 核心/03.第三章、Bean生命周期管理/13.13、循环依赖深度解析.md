---
title: 13、循环依赖深度解析
---
## 📚 目录

1. [循环依赖问题认知](#1-循环依赖问题认知)
2. [三级缓存核心机制](#2-三级缓存核心机制)
3. [早期引用暴露原理](#3-早期引用暴露原理)
4. [循环依赖的类型与处理](#4-循环依赖的类型与处理)
5. [解决方案与最佳实践](#5-解决方案与最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔄 循环依赖问题认知


### 1.1 什么是循环依赖


**💡 生活化理解**
```
想象这样一个场景：
- 小明说："我要等小红准备好了，我才能出发"
- 小红说："我要等小明准备好了，我才能出发"
→ 结果：两个人都在等对方，谁也出发不了！

这就是循环依赖的本质：相互等待，陷入死锁
```

**🔸 代码层面的循环依赖**
```java
// 类A需要类B
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;  // A依赖B
}

// 类B需要类A  
@Component
public class ServiceB {
    @Autowired
    private ServiceA serviceA;  // B依赖A
}

问题：
创建A → 需要B → 去创建B → 又需要A → 回到创建A...
形成闭环，无法完成对象创建
```

### 1.2 循环依赖的类型


**📊 三种常见类型**

| 依赖类型 | **示例代码** | **Spring处理** | **原因说明** |
|---------|------------|--------------|-------------|
| **属性注入循环** | `@Autowired private ServiceB b;` | ✅ **能解决** | 可以先创建对象，后注入属性 |
| **构造器循环** | `public A(ServiceB b) {...}` | ❌ **无法解决** | 创建对象必须先有参数 |
| **Setter循环** | `public void setB(ServiceB b) {...}` | ✅ **能解决** | 类似属性注入 |

**🔍 为什么构造器循环依赖无法解决？**
```
构造器循环的困境：

创建A对象 → new A(b) → 需要b参数
   ↑                        ↓
   ↑                    创建B对象
   ↑                        ↓
   ↑                    new B(a) → 需要a参数
   └──────────────────────┘

问题核心：
- 构造器调用时，对象还不存在
- 无法提前暴露"半成品对象"
- 陷入"先有鸡还是先有蛋"的困境
```

### 1.3 Spring为什么要解决循环依赖


**🎯 实际开发中的必要性**
```
业务场景举例：

1️⃣ 服务层互相调用
UserService ←→ OrderService
用户服务需要查询订单，订单服务需要查询用户

2️⃣ DAO层循环引用
UserDao ←→ RoleDao  
用户表关联角色表，相互查询

3️⃣ 控制器相互依赖
UserController ←→ AuthController
用户控制器需要认证，认证控制器需要用户信息

如果不解决：这些常见场景都会报错，开发效率极低
```

---

## 2. 🔐 三级缓存核心机制


### 2.1 三级缓存的设计思想


**💡 核心理念：用空间换时间，分阶段存储Bean**

```
创建Bean的三个阶段：

阶段1：实例化 → 对象创建了，但属性都是null
阶段2：属性填充 → 给对象的属性赋值  
阶段3：初始化 → 执行初始化方法，对象完全可用

三级缓存对应三个阶段的存储：
一级缓存：存放完全初始化好的Bean（成品）
二级缓存：存放实例化但未完成属性填充的Bean（半成品）
三级缓存：存放Bean工厂，用于生成早期引用（备用方案）
```

### 2.2 三级缓存的实现结构


**🔸 源码中的三个Map**
```java
public class DefaultSingletonBeanRegistry {
    
    // 一级缓存：单例池，存放完整的Bean（成品仓库）
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
    
    // 二级缓存：早期单例，存放半成品Bean（加工车间）
    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
    
    // 三级缓存：单例工厂，存放Bean工厂（原材料仓库）
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
}
```

**📊 三级缓存对比**

| 缓存级别 | **存储内容** | **Bean状态** | **作用** | **使用场景** |
|---------|------------|------------|---------|------------|
| **一级缓存** | `完整Bean对象` | ✅ 完全可用 | 提供最终可用的Bean | 正常获取Bean |
| **二级缓存** | `半成品Bean对象` | ⚠️ 仅实例化 | 暴露早期引用 | 解决循环依赖 |
| **三级缓存** | `Bean工厂函数` | 🔧 工厂模式 | 延迟生成代理 | AOP场景 |

### 2.3 三级缓存工作流程


**🔄 获取Bean的完整流程**
```
步骤解析（以获取ServiceA为例）：

① 先查一级缓存（singletonObjects）
   └─ 有？→ 直接返回（最快路径）
   └─ 无？→ 继续

② 再查二级缓存（earlySingletonObjects）  
   └─ 有？→ 返回半成品Bean
   └─ 无？→ 继续

③ 最后查三级缓存（singletonFactories）
   └─ 有？→ 调用工厂创建Bean，放入二级缓存
   └─ 无？→ 开始创建Bean

④ 创建Bean流程
   实例化 → 放入三级缓存 → 属性填充 → 初始化 → 放入一级缓存
```

**📝 流程图示**
```
获取Bean "serviceA"
   |
   ├─→ [一级缓存] 有完整Bean？
   |      YES → 直接返回 ✅
   |      NO ↓
   |
   ├─→ [二级缓存] 有半成品Bean？
   |      YES → 返回半成品 ⚠️
   |      NO ↓
   |
   ├─→ [三级缓存] 有工厂函数？
   |      YES → 调用工厂 → 放入二级缓存 → 返回
   |      NO ↓
   |
   └─→ [创建新Bean]
        ① 实例化对象 (new)
        ② 放入三级缓存 (工厂函数)
        ③ 填充属性 (@Autowired)
        ④ 初始化完成
        ⑤ 放入一级缓存
        ⑥ 返回Bean ✅
```

---

## 3. 🔓 早期引用暴露原理


### 3.1 什么是早期引用


**💡 通俗理解**
```
类比装修房子：
- 完整Bean = 装修好的房子（能住）
- 早期引用 = 毛坯房（结构有了，但没装修）

循环依赖的解决：
A需要B → B还没装修好，但先给A一个"毛坯B"的钥匙
B需要A → A也先给B一个"毛坯A"的钥匙  
双方拿到钥匙后，继续各自装修完成
```

**🔸 早期引用的本质**
```java
什么是早期引用？
→ 对象已经在内存中创建了（new出来了）
→ 但属性还没填充（都是null或默认值）
→ 初始化方法还没执行

为什么可以这样做？
→ Java对象引用的特性：只要对象存在，引用就有效
→ 先把"空对象"的引用给出去
→ 后续Spring会自动填充属性
```

### 3.2 早期引用暴露时机


**⏰ 关键时间点：实例化之后，属性填充之前**

```java
// Spring创建Bean的伪代码流程
protected Object doCreateBean(String beanName) {
    
    // ① 实例化：创建对象（此时属性都是null）
    Object bean = createBeanInstance(beanName);
    
    // ② 【关键】提前暴露早期引用
    if (允许循环依赖) {
        addSingletonFactory(beanName, () -> getEarlyBeanReference(bean));
        //                              ↑
        //                    把bean包装成工厂放入三级缓存
    }
    
    // ③ 属性填充（@Autowired注入）
    populateBean(bean);
    
    // ④ 初始化（调用init方法）
    initializeBean(bean);
    
    return bean;
}
```

**🔍 暴露时机的重要性**
```
为什么必须在属性填充前暴露？

时间线分析：
t1: 创建A对象 → 实例化完成
t2: 暴露A的早期引用（放入三级缓存）✅ 关键步骤
t3: 填充A的属性 → 需要B
t4: 去创建B → 实例化B
t5: 暴露B的早期引用  
t6: 填充B的属性 → 需要A
t7: 从缓存拿到A的早期引用 ✅ 打破循环
t8: B创建完成
t9: A拿到完整的B
t10: A创建完成

如果不在t2暴露A：
→ t7时找不到A
→ 又回去创建A
→ 死循环 ❌
```

### 3.3 早期引用的生成机制


**🔧 ObjectFactory工厂模式**
```java
// 三级缓存存储的是工厂函数
singletonFactories.put(beanName, () -> {
    return getEarlyBeanReference(beanName, bean);
});

// 为什么用工厂而不是直接存对象？
// → 延迟处理AOP代理

// getEarlyBeanReference的作用
protected Object getEarlyBeanReference(String beanName, Object bean) {
    Object exposedObject = bean;
    
    // 如果有AOP，这里会创建代理对象
    for (BeanPostProcessor bp : getBeanPostProcessors()) {
        if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
            exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);
        }
    }
    
    return exposedObject;  // 返回原对象或代理对象
}
```

**💡 为什么需要三级缓存？**
```
只用二级缓存行不行？

二级缓存方案的问题：
实例化后直接放二级缓存 → 如果需要AOP代理怎么办？
→ 需要提前创建代理，但不知道是否真的需要

三级缓存的优势：
实例化后放入工厂函数（三级缓存）
→ 被其他Bean引用时才调用工厂
→ 工厂判断是否需要AOP
→ 需要就创建代理，不需要返回原对象
→ 结果放入二级缓存

结论：三级缓存 = 懒加载策略 + AOP支持
```

---

## 4. 🔄 循环依赖的类型与处理


### 4.1 属性注入的循环依赖


**✅ Spring可以解决的场景**

```java
// 场景：A和B互相通过@Autowired注入
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
    
    public void doSomething() {
        serviceB.process();
    }
}

@Component  
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
    
    public void process() {
        serviceA.doSomething();
    }
}
```

**🔄 解决过程详解**
```
完整时间线：

1️⃣ Spring启动，准备创建ServiceA
   └─ getBean("serviceA")

2️⃣ 实例化ServiceA
   └─ new ServiceA() 
   └─ serviceB属性还是null

3️⃣ 暴露ServiceA早期引用
   └─ 三级缓存.put("serviceA", () -> serviceA)

4️⃣ 填充ServiceA的属性
   └─ 需要注入serviceB
   └─ getBean("serviceB") 去创建B

5️⃣ 实例化ServiceB  
   └─ new ServiceB()
   └─ serviceA属性还是null

6️⃣ 暴露ServiceB早期引用
   └─ 三级缓存.put("serviceB", () -> serviceB)

7️⃣ 填充ServiceB的属性
   └─ 需要注入serviceA
   └─ getBean("serviceA") ✨关键时刻

8️⃣ 从缓存获取ServiceA
   └─ 一级缓存没有
   └─ 二级缓存没有  
   └─ 三级缓存有！调用工厂获取早期引用
   └─ 将早期引用放入二级缓存
   └─ 返回ServiceA的早期引用给B ✅

9️⃣ ServiceB属性填充完成
   └─ serviceA字段 = ServiceA早期引用
   └─ 继续初始化ServiceB
   └─ ServiceB完全创建成功
   └─ 放入一级缓存

🔟 回到步骤4，ServiceA拿到完整的ServiceB
   └─ serviceB字段 = 完整的ServiceB对象
   └─ 继续初始化ServiceA  
   └─ ServiceA完全创建成功
   └─ 放入一级缓存

✅ 循环依赖解决完成！
```

### 4.2 构造器循环依赖


**❌ Spring无法解决的场景**

```java
// 场景：通过构造器互相依赖
@Component
public class ServiceA {
    private final ServiceB serviceB;
    
    @Autowired
    public ServiceA(ServiceB serviceB) {  // 构造器注入
        this.serviceB = serviceB;
    }
}

@Component
public class ServiceB {
    private final ServiceA serviceA;
    
    @Autowired  
    public ServiceB(ServiceA serviceA) {  // 构造器注入
        this.serviceA = serviceA;
    }
}
```

**🚫 为什么无法解决？**
```
问题分析：

创建A: new ServiceA(serviceB)
         ↓ 需要serviceB参数
         |
创建B: new ServiceB(serviceA)  
         ↓ 需要serviceA参数
         |
创建A: new ServiceA(???)
         ↑ 回到起点，陷入死循环

核心矛盾：
① 构造器执行前，对象不存在
② 不存在的对象无法暴露早期引用
③ 无法提前放入三级缓存
④ 另一个Bean无法获取到引用

结论：构造器循环依赖 = 无解的鸡生蛋问题
```

**⚠️ 启动报错信息**
```
Error creating bean with name 'serviceA': 
Requested bean is currently in creation: 
Is there an unresolvable circular reference?

翻译：
创建serviceA时出错：
请求的Bean正在创建中：
是否存在无法解决的循环引用？
```

### 4.3 Setter方法循环依赖


**✅ 可以解决（原理同属性注入）**

```java
@Component
public class ServiceA {
    private ServiceB serviceB;
    
    @Autowired
    public void setServiceB(ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}

@Component
public class ServiceB {
    private ServiceA serviceA;
    
    @Autowired
    public void setServiceA(ServiceA serviceA) {
        this.serviceA = serviceA;
    }
}
```

**💡 为什么Setter可以？**
```
与属性注入的本质相同：

① 先创建对象（无参构造器）
   └─ new ServiceA() → 对象已存在 ✅

② 暴露早期引用
   └─ 三级缓存.put("serviceA", factory)

③ 调用Setter注入
   └─ setServiceB(b) → 这时B可以从缓存拿A

核心：对象先存在，后填充
```

### 4.4 原型Bean的循环依赖


**❌ 无法解决（每次都是新对象）**

```java
@Component
@Scope("prototype")  // 原型作用域
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Component  
@Scope("prototype")
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
}
```

**🚫 原型Bean的特殊性**
```
为什么原型Bean无法解决循环依赖？

单例Bean（默认）：
→ 只创建一次，可以缓存早期引用
→ A和B相互引用的是同一个对象

原型Bean：
→ 每次getBean都创建新对象
→ 无法缓存，无法复用早期引用
→ 获取A → 创建A1 → 需要B → 创建B1 → 需要A → 创建A2 ❌
→ 陷入无限创建循环

结论：原型Bean + 循环依赖 = 必然失败
```

---

## 5. 🛠️ 解决方案与最佳实践


### 5.1 @Lazy延迟注入


**✅ 最简单的解决方案**

```java
// 场景：构造器循环依赖
@Component
public class ServiceA {
    private final ServiceB serviceB;
    
    @Autowired
    public ServiceA(@Lazy ServiceB serviceB) {  // 加@Lazy
        this.serviceB = serviceB;
    }
}

@Component
public class ServiceB {
    private final ServiceA serviceA;
    
    @Autowired
    public ServiceB(ServiceA serviceA) {
        this.serviceA = serviceA;
    }
}
```

**💡 @Lazy的工作原理**
```
延迟注入机制：

正常注入：
ServiceA构造器需要真实的ServiceB对象
→ 必须先创建ServiceB
→ 导致循环

@Lazy注入：
① 给ServiceA注入一个ServiceB的代理对象
② 代理对象是"空壳"，立即可用
③ ServiceA创建完成
④ 当真正调用serviceB方法时，代理才去获取真实对象

代理对象结构：
ServiceB代理 {
    private ServiceB target;  // 真实对象（延迟获取）
    
    public void method() {
        if (target == null) {
            target = getBean("serviceB");  // 第一次使用时获取
        }
        target.method();
    }
}

优势：打破了"创建时必须有依赖"的限制
```

**⚙️ 使用建议**
```
✅ 适用场景：
- 构造器循环依赖
- 不想改变注入方式
- 快速解决问题

⚠️ 注意事项：
- 第一次调用时才真正注入，可能有轻微性能损失
- 注入的是代理对象，调试时看到的是代理
```

### 5.2 重构代码消除循环


**🎯 最佳实践：从设计上避免循环依赖**

**方案1：提取公共依赖**
```java
// 原始循环依赖
class UserService {
    @Autowired OrderService orderService;
}
class OrderService {
    @Autowired UserService userService;
}

// 重构：提取公共服务
@Component
class CommonService {
    // 共同依赖的逻辑
}

@Component
class UserService {
    @Autowired CommonService commonService;  // 不再依赖Order
}

@Component  
class OrderService {
    @Autowired CommonService commonService;  // 不再依赖User
}
```

**方案2：使用事件驱动**
```java
// 原始循环依赖
class ServiceA {
    @Autowired ServiceB b;
    public void doA() { b.afterA(); }
}
class ServiceB {
    @Autowired ServiceA a;
    public void doB() { a.afterB(); }
}

// 重构：用事件解耦
@Component
class ServiceA {
    @Autowired ApplicationEventPublisher publisher;
    
    public void doA() {
        // 发布事件，不直接调用B
        publisher.publishEvent(new AFinishedEvent());
    }
}

@Component
class ServiceB {
    @EventListener
    public void onAFinished(AFinishedEvent event) {
        // 监听事件，不依赖A
        // 处理逻辑
    }
}
```

**方案3：引入中介者模式**
```java
// 原始循环
class A { @Autowired B b; }  
class B { @Autowired A a; }

// 重构：引入中介者
@Component
class Mediator {
    public void coordinateAB(A a, B b) {
        // 协调A和B的交互
    }
}

@Component
class A {
    @Autowired Mediator mediator;  // 只依赖中介
}

@Component
class B {
    @Autowired Mediator mediator;  // 只依赖中介
}
```

### 5.3 使用ApplicationContext延迟获取


**🔧 手动控制Bean获取时机**

```java
@Component
public class ServiceA {
    @Autowired
    private ApplicationContext context;
    
    private ServiceB serviceB;
    
    public void useServiceB() {
        // 使用时才获取，避免循环
        if (serviceB == null) {
            serviceB = context.getBean(ServiceB.class);
        }
        serviceB.doSomething();
    }
}
```

**💡 适用场景**
```
✅ 何时使用：
- 依赖不是必需的，可以延迟获取
- 只在特定方法中使用依赖
- 需要根据条件选择不同Bean

⚠️ 缺点：
- 代码不够优雅
- 丢失了依赖注入的便利性
- 需要手动管理依赖获取逻辑
```

### 5.4 @PostConstruct初始化


**🔧 将依赖注入延迟到初始化阶段**

```java
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
    
    private String calculatedValue;
    
    @PostConstruct
    public void init() {
        // 在这里使用serviceB，此时循环已解决
        this.calculatedValue = serviceB.calculate();
    }
}
```

**💡 工作原理**
```
Bean创建流程：
① 实例化
② 依赖注入（可能有循环）
③ @PostConstruct执行（此时依赖已注入）✅

优势：
→ 不改变注入方式
→ 保证使用时依赖已就绪
→ 适合需要初始化计算的场景
```

### 5.5 排错策略与诊断


**🔍 如何快速定位循环依赖**

**步骤1：查看启动日志**
```
ERROR: Error creating bean with name 'serviceA': 
Requested bean is currently in creation: 
Is there an unresolvable circular reference?

关键信息：
→ bean名称: serviceA
→ 状态: currently in creation（正在创建中）
→ 问题: circular reference（循环引用）
```

**步骤2：分析依赖链路**
```java
// Spring会打印依赖路径
┌─────┐
|  serviceA defined in file [ServiceA.class]
↑     ↓
|  serviceB defined in file [ServiceB.class]
↑     ↓
|  serviceA defined in file [ServiceA.class]
└─────┘

解读：
A → B → A 形成闭环
```

**步骤3：检查注入方式**
```
❌ 构造器注入循环 → 无法解决
   └─ 方案：改为属性注入或使用@Lazy

✅ 属性注入循环 → 应该能解决
   └─ 检查是否是原型作用域
   └─ 检查是否关闭了循环依赖支持
```

**步骤4：开启调试日志**
```properties
# application.properties
logging.level.org.springframework.beans=DEBUG

# 会打印Bean创建的详细过程
Creating shared instance of singleton bean 'serviceA'
Eagerly caching bean 'serviceA' to allow for resolving potential circular references
Creating shared instance of singleton bean 'serviceB'
...
```

**🔧 常用排查技巧**
```
技巧1：画出依赖关系图
A → B → C → A  （找到闭环）

技巧2：检查作用域
@Scope("prototype") + 循环依赖 = 必然报错

技巧3：查看是否手动关闭了循环依赖支持
setAllowCircularReferences(false)  // 如果设为false会报错

技巧4：IDE辅助
IDEA插件：Spring Boot Helper
可视化展示Bean依赖关系
```

### 5.6 解决方案对比


| 解决方案 | **难度** | **适用场景** | **优点** | **缺点** |
|---------|---------|------------|---------|---------|
| **@Lazy注入** | ⭐ 简单 | 构造器循环依赖 | 改动小，快速解决 | 注入的是代理对象 |
| **改为属性注入** | ⭐⭐ 中等 | 构造器循环依赖 | 彻底解决，无副作用 | 丢失final语义 |
| **提取公共依赖** | ⭐⭐⭐ 复杂 | 设计不合理导致的循环 | 优化设计，长期受益 | 需要重构代码 |
| **事件驱动** | ⭐⭐⭐ 复杂 | 业务流程循环调用 | 解耦彻底，可扩展 | 增加复杂度 |
| **ApplicationContext获取** | ⭐⭐ 中等 | 临时方案 | 灵活控制 | 代码不优雅 |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 循环依赖本质：Bean之间相互依赖形成闭环
🔸 三级缓存机制：一级成品、二级半成品、三级工厂
🔸 早期引用暴露：实例化后立即暴露，属性填充前
🔸 解决原理：用早期引用打破循环，后续填充属性
🔸 构造器循环：无法解决，因为对象未创建无法暴露
```

### 6.2 三级缓存的核心理解


**🔹 为什么需要三级缓存？**
```
一级缓存：存放完全可用的Bean
→ 作用：提供最终的Bean给应用使用

二级缓存：存放半成品Bean
→ 作用：解决循环依赖时提供早期引用

三级缓存：存放Bean工厂
→ 作用：支持AOP代理的延迟创建
→ 如果没有AOP，理论上二级缓存就够了

关键点：
• 三级缓存让Spring能够"延迟决策"
• 被循环依赖时才创建代理，没有循环就用原对象
• 避免不必要的代理创建
```

**🔹 早期引用的时机把握**
```
关键时间点：实例化后，属性填充前

为什么这个时机？
✅ 实例化后：对象已存在，可以获取引用
✅ 属性填充前：还没开始注入依赖，不会触发新的循环

如果在属性填充后暴露？
❌ 太晚了，循环依赖已经发生
❌ 无法提供早期引用给其他Bean
```

### 6.3 实战应用指南


**🎯 开发建议**
```
1️⃣ 优先使用属性注入
@Autowired private ServiceB serviceB;  ✅
→ Spring能自动解决循环依赖

2️⃣ 如果必须用构造器注入
@Autowired public ServiceA(@Lazy ServiceB b) {}  ✅
→ 加@Lazy让Spring延迟注入

3️⃣ 设计层面避免循环
→ 提取公共服务
→ 使用事件驱动
→ 引入中介者模式

4️⃣ 不要滥用循环依赖
→ 虽然Spring能解决，但不代表设计合理
→ 过多循环依赖是代码设计问题的信号
```

**⚠️ 常见误区**
```
❌ 误区1：所有循环依赖Spring都能解决
   → 构造器循环、原型Bean循环都不行

❌ 误区2：三级缓存只是为了性能优化
   → 主要是为了支持AOP的延迟代理

❌ 误区3：循环依赖是正常现象
   → 能解决不代表设计合理，应尽量避免

✅ 正确认知：
   → Spring提供了解决方案，但不应依赖它
   → 好的设计应该避免循环依赖
```

### 6.4 快速排查清单


```
遇到循环依赖错误时：

□ 第1步：确认依赖类型
  ├─ 构造器循环？→ 改属性注入或加@Lazy
  ├─ 属性注入循环？→ 检查作用域
  └─ 原型Bean？→ 改为单例或重构

□ 第2步：查看依赖链路  
  └─ 分析日志中的依赖路径，找到闭环

□ 第3步：选择解决方案
  ├─ 快速修复：@Lazy / 改属性注入
  └─ 长期优化：重构代码消除循环

□ 第4步：验证解决方案
  └─ 启动应用，查看日志，测试功能
```

**核心记忆口诀**：
```
三级缓存分层存，早期引用破循环
构造依赖无法解，属性注入能周全
设计合理最重要，循环依赖要避免
实在必需用延迟，@Lazy注解来实现
```