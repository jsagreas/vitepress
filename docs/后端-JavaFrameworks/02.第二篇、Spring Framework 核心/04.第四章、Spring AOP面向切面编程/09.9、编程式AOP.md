---
title: 9、编程式AOP
---
## 📚 目录

1. [编程式AOP基本概念](#1-编程式AOP基本概念)
2. [ProxyFactory代理工厂详解](#2-ProxyFactory代理工厂详解)
3. [核心组件深入理解](#3-核心组件深入理解)
4. [实战应用与最佳实践](#4-实战应用与最佳实践)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🎯 编程式AOP基本概念


### 1.1 什么是编程式AOP


**通俗理解**：
想象你是一个厨师，做菜的时候：
- **声明式AOP**：就像用菜谱（配置文件或注解），告诉助手"所有炒菜前都要热锅"
- **编程式AOP**：就像你自己动手，精确控制"这道菜需要热锅，那道菜不需要"

```
生活场景类比：

声明式AOP：
老板说："所有员工上班都要打卡" 
→ 统一规则，自动应用

编程式AOP：  
你自己决定："张三需要打卡，李四不需要，王五只记录下班时间"
→ 灵活控制，手动配置
```

**核心定义**：
```
编程式AOP = 通过代码手动创建和配置AOP代理对象

特点对比：
📌 声明式AOP：
   - 使用@Aspect注解或XML配置
   - Spring自动创建代理
   - 适合统一的切面逻辑

📌 编程式AOP：
   - 使用ProxyFactory等API
   - 手动创建代理对象
   - 适合需要灵活控制的场景
```

### 1.2 为什么需要编程式AOP


**实际应用场景**：

| 场景 | 说明 | 为什么用编程式 |
|------|------|---------------|
| **动态代理** | 运行时决定是否代理某个对象 | 配置文件无法做到运行时判断 |
| **多样化增强** | 同一对象的不同实例应用不同切面 | 声明式AOP是统一配置 |
| **第三方集成** | 为外部库的对象添加AOP | 无法修改第三方代码加注解 |
| **测试环境** | 单元测试中模拟AOP行为 | 需要精确控制代理逻辑 |

**优势说明**：
```
🔸 灵活性更高
   - 运行时动态决定代理策略
   - 可以为单个对象定制切面

🔸 控制更精确
   - 精确控制代理创建时机
   - 可以手动选择JDK或CGLIB代理

🔸 适用范围广
   - 不受注解或XML限制
   - 可以代理任何对象
```

### 1.3 编程式AOP的核心流程


**整体流程图示**：
```
创建代理的完整流程：

步骤1：准备目标对象
   ↓
[UserService对象] ← 需要被增强的业务对象
   ↓
步骤2：创建ProxyFactory
   ↓
[ProxyFactory] ← Spring提供的代理工厂
   ↓
步骤3：设置目标对象
   ↓
factory.setTarget(userService)
   ↓
步骤4：添加增强逻辑
   ↓
factory.addAdvice(拦截器)
   ↓
步骤5：获取代理对象
   ↓
[代理对象] ← 带有增强功能的对象
   ↓
步骤6：使用代理对象
   ↓
proxy.method() → 自动执行增强逻辑
```

---

## 2. 🏭 ProxyFactory代理工厂详解


### 2.1 ProxyFactory是什么


**通俗解释**：
ProxyFactory就像一个"代理对象制造工厂"：
- 你把原材料（目标对象）交给工厂
- 告诉工厂需要什么功能（添加拦截器）
- 工厂给你生产出增强版的产品（代理对象）

**核心作用**：
```
ProxyFactory的三大职责：

1️⃣ 管理目标对象
   - setTarget()：设置要代理的对象
   - setTargetClass()：设置目标类型

2️⃣ 配置增强逻辑  
   - addAdvice()：添加通知
   - addAdvisor()：添加顾问

3️⃣ 创建代理对象
   - getProxy()：生成最终的代理对象
   - 自动选择JDK或CGLIB代理方式
```

### 2.2 ProxyFactory基本使用


**入门示例**：
```java
// 业务接口
public interface UserService {
    void saveUser(String name);
}

// 业务实现类
public class UserServiceImpl implements UserService {
    public void saveUser(String name) {
        System.out.println("保存用户：" + name);
    }
}

// 创建代理的完整代码
public class ProxyFactoryDemo {
    public static void main(String[] args) {
        // 1. 创建目标对象（原始业务对象）
        UserService target = new UserServiceImpl();
        
        // 2. 创建代理工厂
        ProxyFactory factory = new ProxyFactory();
        
        // 3. 设置目标对象
        factory.setTarget(target);
        
        // 4. 添加拦截器（增强逻辑）
        factory.addAdvice(new MethodInterceptor() {
            public Object invoke(MethodInvocation invocation) throws Throwable {
                System.out.println("方法执行前：记录日志");
                Object result = invocation.proceed(); // 执行原方法
                System.out.println("方法执行后：清理资源");
                return result;
            }
        });
        
        // 5. 获取代理对象
        UserService proxy = (UserService) factory.getProxy();
        
        // 6. 使用代理对象
        proxy.saveUser("张三");
    }
}
```

**执行结果**：
```
方法执行前：记录日志
保存用户：张三
方法执行后：清理资源
```

### 2.3 ProxyFactory的配置选项


**关键配置说明**：

| 配置方法 | 作用 | 使用场景 |
|---------|------|----------|
| `setTarget(Object)` | 设置目标对象 | 代理具体实例对象 |
| `setTargetClass(Class)` | 设置目标类 | 代理类而非实例 |
| `setInterfaces(Class[])` | 指定代理接口 | 强制使用JDK代理 |
| `setProxyTargetClass(true)` | 强制使用CGLIB | 目标对象没有接口时 |
| `setOptimize(true)` | 优化代理性能 | 高性能要求场景 |
| `setExposeProxy(true)` | 暴露当前代理 | 解决内部调用问题 |

**配置示例**：
```java
ProxyFactory factory = new ProxyFactory();

// 基础配置
factory.setTarget(targetObject);              // 设置目标
factory.setProxyTargetClass(true);           // 使用CGLIB代理

// 高级配置
factory.setExposeProxy(true);                // 暴露代理对象
factory.setFrozen(true);                     // 冻结配置，提升性能
factory.setOptimize(true);                   // 优化代理
```

---

## 3. 🔧 核心组件深入理解


### 3.1 Advisor顾问机制


**Advisor是什么**：
```
生活场景类比：

Advice（通知）= 保安的工作内容
"检查证件、登记信息、放行"

Pointcut（切点）= 保安的工作范围  
"只检查外来人员，公司员工直接放行"

Advisor（顾问）= Advice + Pointcut
"在特定范围内执行特定工作"
```

**Advisor的作用**：
```
🔸 Advice（通知）：
   - 定义"做什么"
   - 拦截器的具体逻辑
   
🔸 Pointcut（切点）：
   - 定义"在哪做"
   - 匹配哪些方法需要拦截

🔸 Advisor（顾问）：
   - 组合Advice和Pointcut
   - 精确控制增强的应用范围
```

**Advisor使用示例**：
```java
// 创建切点：只拦截save开头的方法
Pointcut pointcut = new NameMatchMethodPointcut() {{
    setMappedName("save*");
}};

// 创建通知：定义拦截逻辑
MethodInterceptor advice = invocation -> {
    System.out.println("执行前：开启事务");
    Object result = invocation.proceed();
    System.out.println("执行后：提交事务");
    return result;
};

// 创建顾问：组合切点和通知
DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice);

// 添加到代理工厂
ProxyFactory factory = new ProxyFactory();
factory.setTarget(target);
factory.addAdvisor(advisor);  // 使用顾问而非直接添加通知

UserService proxy = (UserService) factory.getProxy();
```

### 3.2 MethodInterceptor方法拦截器


**MethodInterceptor的本质**：
```
MethodInterceptor = AOP中最强大的拦截器

核心能力：
1️⃣ 完全控制方法执行
   - 可以决定是否执行原方法
   - 可以修改方法参数
   - 可以修改返回值

2️⃣ 环绕整个方法调用
   - 方法执行前后都能增强
   - 可以捕获异常并处理
```

**MethodInvocation详解**：
```java
public interface MethodInvocation {
    // 继续执行：调用下一个拦截器或目标方法
    Object proceed() throws Throwable;
    
    // 获取方法信息
    Method getMethod();          // 被调用的方法
    Object[] getArguments();     // 方法参数
    Object getThis();            // 目标对象
}
```

**实用拦截器示例**：
```java
// 示例1：性能监控拦截器
public class PerformanceInterceptor implements MethodInterceptor {
    public Object invoke(MethodInvocation invocation) throws Throwable {
        long start = System.currentTimeMillis();
        
        Object result = invocation.proceed();  // 执行方法
        
        long end = System.currentTimeMillis();
        System.out.println(invocation.getMethod().getName() + 
                          " 执行耗时：" + (end - start) + "ms");
        return result;
    }
}

// 示例2：异常处理拦截器
public class ExceptionHandlerInterceptor implements MethodInterceptor {
    public Object invoke(MethodInvocation invocation) throws Throwable {
        try {
            return invocation.proceed();
        } catch (Exception e) {
            System.err.println("方法执行异常：" + e.getMessage());
            // 可以选择：重新抛出、返回默认值、记录日志等
            return null;
        }
    }
}
```

### 3.3 AdvisedSupport配置支持


**AdvisedSupport是什么**：
```
AdvisedSupport = ProxyFactory的配置管理器

它负责：
🔸 存储所有配置信息
   - 目标对象
   - 拦截器列表
   - 代理接口
   
🔸 管理Advisor链
   - 维护拦截器执行顺序
   - 支持动态添加/删除拦截器
```

**ProxyFactory的继承关系**：
```
          AdvisedSupport（配置管理）
                  ↑
                  |
          ProxyCreatorSupport（代理创建）
                  ↑
                  |
            ProxyFactory（代理工厂）
```

**配置信息的访问**：
```java
ProxyFactory factory = new ProxyFactory(target);
factory.addAdvice(interceptor);

// 访问配置信息
AdvisedSupport config = factory;
Advisor[] advisors = config.getAdvisors();           // 获取所有顾问
boolean proxyTargetClass = config.isProxyTargetClass(); // 是否CGLIB代理
Class<?>[] interfaces = config.getProxiedInterfaces();  // 代理的接口
```

---

## 4. 🚀 实战应用与最佳实践


### 4.1 动态代理场景


**场景：根据用户权限动态决定是否代理**

```java
public class DynamicProxyService {
    
    public Object createProxy(Object target, String userRole) {
        ProxyFactory factory = new ProxyFactory(target);
        
        // 根据角色添加不同的拦截器
        if ("ADMIN".equals(userRole)) {
            // 管理员：添加审计日志
            factory.addAdvice(new AuditLogInterceptor());
        } else if ("USER".equals(userRole)) {
            // 普通用户：添加权限检查
            factory.addAdvice(new PermissionCheckInterceptor());
        }
        
        return factory.getProxy();
    }
}

// 使用示例
Object adminProxy = service.createProxy(userService, "ADMIN");
Object userProxy = service.createProxy(userService, "USER");
```

### 4.2 拦截器链组合


**多个拦截器的执行顺序**：
```
拦截器链执行流程：

客户端调用
    ↓
┌─────────────────┐
│ 拦截器1-前置逻辑 │ ← factory.addAdvice(interceptor1)
└─────────────────┘
    ↓
┌─────────────────┐
│ 拦截器2-前置逻辑 │ ← factory.addAdvice(interceptor2)
└─────────────────┘
    ↓
┌─────────────────┐
│   目标方法执行   │
└─────────────────┘
    ↓
┌─────────────────┐
│ 拦截器2-后置逻辑 │
└─────────────────┘
    ↓
┌─────────────────┐
│ 拦截器1-后置逻辑 │
└─────────────────┘
    ↓
返回给客户端
```

**实战示例：事务+日志+性能监控**
```java
ProxyFactory factory = new ProxyFactory(target);

// 按顺序添加拦截器（先添加的先执行前置逻辑）
factory.addAdvice(new TransactionInterceptor());   // 事务管理
factory.addAdvice(new LoggingInterceptor());       // 日志记录
factory.addAdvice(new PerformanceInterceptor());   // 性能监控

UserService proxy = (UserService) factory.getProxy();
```

### 4.3 实用工具类封装


**封装通用代理创建器**：
```java
public class ProxyFactoryHelper {
    
    // 创建简单代理
    public static <T> T createSimpleProxy(T target, MethodInterceptor interceptor) {
        ProxyFactory factory = new ProxyFactory(target);
        factory.addAdvice(interceptor);
        return (T) factory.getProxy();
    }
    
    // 创建带切点的代理
    public static <T> T createPointcutProxy(T target, 
                                           String methodPattern, 
                                           MethodInterceptor interceptor) {
        ProxyFactory factory = new ProxyFactory(target);
        
        // 创建名称匹配切点
        NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
        pointcut.setMappedName(methodPattern);
        
        // 创建顾问
        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, interceptor);
        factory.addAdvisor(advisor);
        
        return (T) factory.getProxy();
    }
    
    // 创建多拦截器代理
    public static <T> T createMultiProxy(T target, MethodInterceptor... interceptors) {
        ProxyFactory factory = new ProxyFactory(target);
        for (MethodInterceptor interceptor : interceptors) {
            factory.addAdvice(interceptor);
        }
        return (T) factory.getProxy();
    }
}

// 使用示例
UserService proxy = ProxyFactoryHelper.createPointcutProxy(
    userService,
    "save*",  // 只拦截save开头的方法
    new LoggingInterceptor()
);
```

### 4.4 最佳实践建议


**使用建议**：

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 统一的切面逻辑 | 声明式AOP（@Aspect） | 配置简单，易于维护 |
| 动态决定是否代理 | 编程式AOP | 运行时灵活控制 |
| 第三方对象代理 | 编程式AOP | 无法修改第三方代码 |
| 复杂的拦截逻辑 | MethodInterceptor | 功能最强大 |
| 单一增强逻辑 | 直接addAdvice | 简单直接 |
| 精确方法匹配 | 使用Advisor | 可以指定切点 |

**注意事项**：
```
⚠️ 代理对象注意事项：

1️⃣ 类型转换问题
   - 代理对象可能不是原对象的子类
   - 建议转换为接口类型而非实现类

2️⃣ 内部调用问题
   - 代理对象内部方法互相调用不会触发AOP
   - 需要使用setExposeProxy(true)暴露代理

3️⃣ 性能考虑
   - 每次调用都要经过拦截器链
   - 避免在高频方法上添加过多拦截器

4️⃣ 线程安全
   - ProxyFactory不是线程安全的
   - 不要在多线程环境共享ProxyFactory实例
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 编程式AOP的本质
   - 通过代码手动创建代理对象
   - 相比声明式更加灵活可控
   - 适合动态、复杂的代理场景

🔸 ProxyFactory的作用
   - Spring提供的代理工厂
   - 管理目标对象和增强逻辑
   - 自动选择合适的代理方式

🔸 核心组件关系
   - Advice：定义增强逻辑（做什么）
   - Pointcut：定义切点范围（在哪做）
   - Advisor：组合Advice和Pointcut
   - MethodInterceptor：最强大的拦截器
```

### 5.2 关键理解要点


**🔹 编程式 vs 声明式**
```
编程式AOP：
✅ 灵活性高，完全手动控制
✅ 可以动态决定代理策略
✅ 适合复杂、特殊场景
❌ 代码量多，维护成本高

声明式AOP：
✅ 配置简单，易于维护
✅ 统一管理，清晰直观
✅ 适合大多数常规场景
❌ 灵活性受限，无法动态控制
```

**🔹 何时使用编程式AOP**
```
必须用编程式AOP的场景：
1. 运行时动态决定是否代理
2. 为第三方库对象添加AOP
3. 单元测试中精确控制代理
4. 需要在代码中灵活组合拦截器

建议用声明式AOP的场景：
1. 统一的日志、事务、权限控制
2. 固定的切面逻辑
3. 简单的方法拦截
```

**🔹 拦截器链的执行逻辑**
```
记忆技巧：
拦截器链就像"剥洋葱"

添加顺序：拦截器1 → 拦截器2 → 拦截器3

执行顺序：
前置逻辑：1 → 2 → 3 → 目标方法
后置逻辑：3 → 2 → 1

最先添加的拦截器，最外层包裹
```

### 5.3 实际应用价值


**应用场景总结**：

```
🎯 动态代理场景
- 根据用户权限动态添加拦截器
- 根据环境配置选择不同的增强逻辑
- 运行时决定代理策略

🎯 测试场景
- 为测试对象添加Mock行为
- 监控方法调用情况
- 模拟特定的执行场景

🎯 框架集成场景
- 为第三方对象添加Spring特性
- 桥接不同框架的代理机制
- 实现自定义的代理策略

🎯 性能优化场景
- 精确控制代理范围
- 减少不必要的拦截
- 优化拦截器链执行
```

### 5.4 学习检验


**自检清单**：
- [ ] 能用自己的话解释编程式AOP和声明式AOP的区别
- [ ] 理解ProxyFactory的基本使用流程
- [ ] 掌握MethodInterceptor的核心方法
- [ ] 能说出Advisor的作用和使用场景
- [ ] 知道何时应该使用编程式AOP

**核心记忆口诀**：
```
编程式AOP灵活强，手动创建可定制
ProxyFactory是工厂，目标对象加增强
MethodInterceptor最核心，环绕通知全控制
Advisor组合切点通知，精确匹配更高效
声明式简单易维护，编程式场景要灵活
```