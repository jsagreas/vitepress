---
title: 4、代理技术对比
---
## 📚 目录

1. [代理技术概述](#1-代理技术概述)
2. [JDK动态代理详解](#2-JDK动态代理详解)
3. [CGLIB代理详解](#3-CGLIB代理详解)
4. [两种代理技术对比](#4-两种代理技术对比)
5. [Spring的代理选择策略](#5-Spring的代理选择策略)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 代理技术概述


### 1.1 什么是代理


> 💡 **生活类比**：代理就像找中介买房
> - 你（客户）不直接接触房东（目标对象）
> - 中介（代理对象）帮你和房东打交道
> - 中介可以在交易前后做一些额外的事（验房、签合同）

**专业定义**：代理是为其他对象提供一个替身或占位符，以控制对这个对象的访问。

```
正常调用：
客户端 ──直接调用──> 目标对象

代理模式：
客户端 ──调用──> 代理对象 ──调用──> 目标对象
                   ↑
                增强功能
```

### 1.2 为什么需要代理


**核心作用**：在不修改原有代码的前提下，增强功能

🔸 **实际应用场景**：
- **权限控制**：访问前检查用户权限
- **日志记录**：方法执行前后记录日志
- **性能监控**：统计方法执行时间
- **事务管理**：自动开启和提交事务
- **异常处理**：统一处理异常

### 1.3 Spring AOP中的两种代理方式


Spring AOP默认使用两种代理技术：

| 代理类型 | **适用场景** | **核心特点** |
|---------|------------|-------------|
| 🔷 **JDK动态代理** | `目标对象实现了接口` | `基于接口代理，JDK原生支持` |
| 🔶 **CGLIB代理** | `目标对象没有接口` | `基于类继承，需要第三方库` |

---

## 2. 🔷 JDK动态代理详解


### 2.1 JDK动态代理是什么


**一句话理解**：JDK动态代理是Java原生提供的代理方式，通过反射机制在运行时创建接口的代理实现类。

**工作原理**：
```
接口（UserService）
   ↓ 实现
实现类（UserServiceImpl）
   ↓ JDK动态代理
代理对象（$Proxy0）──实现同一接口──> UserService
```

🔸 **关键特征**：
- 必须基于**接口**才能代理
- 代理对象和目标对象实现**相同接口**
- 使用Java反射API：`java.lang.reflect.Proxy`

### 2.2 JDK动态代理实现原理


**核心API**：
- `Proxy.newProxyInstance()`：创建代理对象
- `InvocationHandler`：定义增强逻辑

```java
// 1. 定义接口
public interface UserService {
    void addUser(String name);
}

// 2. 实现类
public class UserServiceImpl implements UserService {
    public void addUser(String name) {
        System.out.println("添加用户：" + name);
    }
}

// 3. 创建代理
UserService proxy = (UserService) Proxy.newProxyInstance(
    UserService.class.getClassLoader(),  // 类加载器
    new Class[]{UserService.class},      // 代理哪些接口
    new InvocationHandler() {            // 增强逻辑
        public Object invoke(Object proxy, Method method, Object[] args) {
            System.out.println("权限检查");  // 前置增强
            Object result = method.invoke(target, args);  // 执行原方法
            System.out.println("记录日志");  // 后置增强
            return result;
        }
    }
);
```

### 2.3 JDK动态代理执行流程


```
客户端调用
    ↓
proxy.addUser("张三")
    ↓
进入InvocationHandler.invoke()
    ↓
执行前置增强（权限检查）
    ↓
反射调用目标方法：method.invoke(target, args)
    ↓
执行后置增强（记录日志）
    ↓
返回结果
```

> ⚠️ **注意事项**：
> - 目标类必须实现接口，否则无法使用JDK代理
> - 只能代理接口中定义的方法
> - 性能相对CGLIB略低（反射调用）

### 2.4 JDK动态代理优缺点


✅ **优点**：
- JDK原生支持，不需要额外依赖
- 代码量少，实现简单
- 稳定性好，官方维护

❌ **缺点**：
- 必须基于接口，限制较大
- 只能代理接口方法，不能代理类
- 反射调用性能略低

---

## 3. 🔶 CGLIB代理详解


### 3.1 CGLIB代理是什么


**一句话理解**：CGLIB代理是通过继承目标类，在运行时动态生成子类来实现代理的技术。

> 💭 **类比理解**：
> - JDK代理：要求目标是"合同工"（必须有接口契约）
> - CGLIB代理：目标可以是"正式员工"（直接继承类）

**工作原理**：
```
目标类（UserService）
   ↓ CGLIB继承
代理子类（UserService$$EnhancerByCGLIB$$123）
   ↓ 重写方法
增强后的方法
```

🔸 **关键特征**：
- 基于**类继承**，不需要接口
- 通过**字节码技术**动态生成子类
- 使用第三方库：`cglib.jar`（Spring已内置）

### 3.2 CGLIB代理实现原理


**核心API**：
- `Enhancer`：字节码增强器
- `MethodInterceptor`：方法拦截器

```java
// 1. 目标类（无需接口）
public class UserService {
    public void addUser(String name) {
        System.out.println("添加用户：" + name);
    }
}

// 2. 创建CGLIB代理
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(UserService.class);  // 设置父类
enhancer.setCallback(new MethodInterceptor() {
    public Object intercept(Object obj, Method method, Object[] args, 
                          MethodProxy proxy) {
        System.out.println("权限检查");  // 前置增强
        Object result = proxy.invokeSuper(obj, args);  // 调用父类方法
        System.out.println("记录日志");  // 后置增强
        return result;
    }
});

UserService proxy = (UserService) enhancer.create();
```

### 3.3 CGLIB代理执行流程


```
客户端调用
    ↓
proxy.addUser("张三")
    ↓
进入MethodInterceptor.intercept()
    ↓
执行前置增强（权限检查）
    ↓
调用父类方法：proxy.invokeSuper(obj, args)
    ↓
执行后置增强（记录日志）
    ↓
返回结果
```

> ⚠️ **重要限制**：
> - `final`类无法被继承，不能使用CGLIB代理
> - `final`方法无法被重写，不会被增强
> - `private`方法无法被子类访问，不会被增强

### 3.4 CGLIB代理优缺点


✅ **优点**：
- 不需要接口，适用范围广
- 性能优于JDK动态代理（直接调用方法）
- 可以代理类的所有非final方法

❌ **缺点**：
- 需要第三方库支持
- 无法代理final类和final方法
- 创建代理对象耗时较长（字节码生成）

---

## 4. ⚖️ 两种代理技术对比


### 4.1 核心差异对比


| 对比维度 | **JDK动态代理** | **CGLIB代理** |
|---------|----------------|---------------|
| 🔸 **代理方式** | `基于接口，实现接口` | `基于类继承，生成子类` |
| 🔸 **使用限制** | `目标必须实现接口` | `目标不能是final类` |
| 🔸 **方法限制** | `只能代理接口方法` | `不能代理final/private方法` |
| 🔸 **依赖库** | `JDK原生支持` | `需要cglib.jar` |
| 🔸 **创建速度** | `快` | `慢（字节码生成）` |
| 🔸 **执行速度** | `慢（反射调用）` | `快（直接调用）` |
| 🔸 **适用场景** | `基于接口的设计` | `没有接口的类` |

### 4.2 性能对比分析


**创建性能**：
```
JDK代理：创建快 ⚡⚡⚡⚡⚡
CGLIB代理：创建慢 ⚡⚡⚡☆☆
原因：CGLIB需要动态生成字节码
```

**执行性能**：
```
JDK代理：执行慢 🚀🚀🚀☆☆
CGLIB代理：执行快 🚀🚀🚀🚀🚀
原因：JDK使用反射，CGLIB直接调用
```

> 💡 **性能建议**：
> - 代理对象创建频繁 → 优先JDK代理
> - 代理方法调用频繁 → 优先CGLIB代理
> - Spring环境下 → 默认策略已优化，无需关注

### 4.3 使用场景对比


**JDK动态代理适合**：
- ✅ 系统设计基于接口（推荐）
- ✅ 需要代理多个接口
- ✅ 代理对象创建频繁的场景
- ✅ 对字节码操作敏感的环境

**CGLIB代理适合**：
- ✅ 没有实现接口的遗留代码
- ✅ 代理方法调用非常频繁
- ✅ 需要代理类的所有方法
- ✅ 对性能要求极高的场景

---

## 5. 🎯 Spring的代理选择策略


### 5.1 Spring默认选择规则


**自动选择机制**：
```
目标对象实现了接口？
    ↓ YES
使用JDK动态代理
    ↓ NO
使用CGLIB代理
```

🔸 **Spring的智能判断**：
- 发现目标类实现了接口 → JDK代理
- 目标类没有接口 → CGLIB代理
- 开发者无需关心，Spring自动处理

### 5.2 强制指定代理方式


**方式1：全局配置**
```xml
<!-- Spring XML配置 -->
<aop:config proxy-target-class="true">
    <!-- true=强制CGLIB，false=优先JDK -->
</aop:config>
```

**方式2：注解配置**
```java
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true)  // 强制CGLIB
public class AopConfig {
    // ...
}
```

**方式3：SpringBoot配置**
```properties
# application.properties
spring.aop.proxy-target-class=true  # true=CGLIB，false=JDK
```

> ⚠️ **配置影响**：
> - `proxy-target-class=false`：有接口用JDK，无接口用CGLIB
> - `proxy-target-class=true`：统一使用CGLIB

### 5.3 实际项目选择建议


**推荐策略**：

🎯 **优先基于接口设计**
- 遵循面向接口编程原则
- 使用JDK动态代理（Spring默认）
- 代码更易测试和维护

🔧 **特殊情况使用CGLIB**
- 无法修改的遗留代码
- 性能要求极高的场景
- 明确需要代理所有方法

⚙️ **SpringBoot 2.x+ 变化**
- 默认使用CGLIB代理
- 更好的性能表现
- 减少接口强制要求

```
Spring 5.x之前：默认JDK代理
SpringBoot 2.x+：默认CGLIB代理
原因：CGLIB性能优化 + 使用更灵活
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 代理模式：在不修改原代码的情况下增强功能
🔸 JDK代理：基于接口，使用反射，JDK原生支持
🔸 CGLIB代理：基于继承，使用字节码，需要第三方库
🔸 Spring策略：有接口用JDK，无接口用CGLIB（可配置）
```

### 6.2 关键理解要点


> 💡 **JDK代理核心**：
> - 必须有接口才能代理
> - 创建快、执行慢（反射）
> - 适合基于接口的设计

> 💡 **CGLIB代理核心**：
> - 通过继承实现代理
> - 创建慢、执行快（直接调用）
> - final类和方法无法代理

> 💡 **Spring选择策略**：
> - 默认智能选择，开发者无需关心
> - 可通过配置强制使用某种方式
> - SpringBoot 2.x后默认CGLIB

### 6.3 实际应用价值


**开发实践**：
- **理解代理原理** → 排查AOP不生效问题
- **掌握选择策略** → 优化应用性能
- **熟悉配置方式** → 应对特殊需求

**常见问题**：
- ❓ AOP增强不生效？→ 检查是否有接口、是否final方法
- ❓ 性能瓶颈？→ 考虑切换代理方式
- ❓ 测试困难？→ 基于接口设计更易mock

**面试重点**：
- 🔥 两种代理的区别和适用场景
- 🔥 Spring如何选择代理方式
- 🔥 为什么SpringBoot改用CGLIB

### 6.4 学习检查清单


- [ ] 理解代理模式的核心作用
- [ ] 掌握JDK动态代理的实现原理
- [ ] 掌握CGLIB代理的工作机制
- [ ] 清楚两种代理的性能差异
- [ ] 会配置Spring的代理方式
- [ ] 能解决常见的AOP问题

**核心记忆**：
- JDK代理靠接口，反射调用慢一点
- CGLIB继承类，字节码快但不能final
- Spring智能选，有接口JDK无接口CGLIB
- 特殊需求可配置，默认策略已优化