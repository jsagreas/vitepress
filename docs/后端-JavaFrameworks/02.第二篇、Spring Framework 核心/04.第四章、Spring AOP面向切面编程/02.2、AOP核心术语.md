---
title: 2、AOP核心术语
---
## 📚 目录

1. [AOP是什么](#1-AOP是什么)
2. [切面Aspect](#2-切面Aspect)
3. [连接点JoinPoint](#3-连接点JoinPoint)
4. [切入点Pointcut](#4-切入点Pointcut)
5. [通知Advice](#5-通知Advice)
6. [织入Weaving](#6-织入Weaving)
7. [目标对象Target](#7-目标对象Target)
8. [术语关系图解](#8-术语关系图解)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 AOP是什么


### 1.1 通俗理解AOP


**🔸 生活中的类比**

想象你是一家餐厅的老板，你有很多服务员（业务代码）：

```
正常服务流程：
服务员A：点菜 → 上菜 → 结账
服务员B：点菜 → 上菜 → 结账  
服务员C：点菜 → 上菜 → 结账

老板的新要求：
- 每次服务前要洗手（统一规范）
- 每次服务后要记录客户反馈（统一规范）

传统做法：
✗ 每个服务员都要记住这些额外步骤
✗ 容易遗漏，难以统一管理

AOP做法：
✓ 安排一个专门的质检员
✓ 在服务开始前统一检查洗手
✓ 在服务结束后统一收集反馈
✓ 服务员只关注核心工作
```

**💡 AOP的核心思想**

AOP（Aspect-Oriented Programming）= **面向切面编程**

> 🎯 **核心理念**：把那些与业务无关，但又被多个业务模块共同调用的功能（如日志、事务、权限检查）抽取出来，统一管理。

**现实开发场景**：
```
假设你有100个方法都需要：
- 记录日志
- 检查权限
- 开启事务
- 处理异常

不用AOP：
❌ 每个方法都要写重复代码
❌ 修改起来要改100个地方

使用AOP：
✅ 只需要定义一次这些功能
✅ 自动应用到所有需要的方法上
✅ 修改只需要改一个地方
```

### 1.2 AOP的实际应用价值


**📊 典型应用场景**

| 场景 | 传统方式的问题 | AOP的解决方案 |
|------|---------------|--------------|
| **日志记录** | 每个方法都写日志代码 | 统一的日志切面自动记录 |
| **权限检查** | 每个接口都要判断权限 | 统一的权限切面自动检查 |
| **事务管理** | 手动开启和提交事务 | 声明式事务自动管理 |
| **性能监控** | 每个方法都要计时 | 统一的性能切面自动统计 |
| **异常处理** | 重复的try-catch代码 | 统一的异常处理切面 |

---

## 2. 🎨 切面Aspect


### 2.1 什么是切面


**🔸 通俗解释**

切面就像是一个"服务管家"，它把那些通用的功能打包在一起。

```
生活类比：
商场的安保系统就是一个"安全切面"
- 它不管你是买衣服还是买电器（业务不同）
- 但进门都要安检（统一功能）
- 所有商铺都受它保护（自动织入）

代码世界：
日志切面 = 一个专门负责记录日志的模块
- 不管你是用户服务还是订单服务（业务不同）
- 但都需要记录操作日志（统一功能）
- 自动在方法执行前后记录（自动织入）
```

### 2.2 切面的组成


**📦 切面包含什么**

一个切面主要包含两部分：

```
切面 = 在哪里做（切入点） + 做什么（通知）

形象理解：
1. 在哪里做：就像设置监控摄像头的位置
   → 选择在哪些方法上应用这个功能

2. 做什么：就像摄像头要录像还是只拍照
   → 定义具体要执行的功能代码
```

**🔧 代码示例**

```java
// 这是一个日志切面
@Aspect  // 表明这是一个切面类
@Component
public class LogAspect {
    
    // 切入点：定义在哪些方法上记录日志
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayer() {}
    
    // 通知：定义具体做什么（记录日志）
    @Before("serviceLayer()")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("开始执行：" + joinPoint.getSignature().getName());
    }
}
```

**💡 理解要点**：
- `@Aspect`：告诉Spring这是一个切面
- `@Pointcut`：定义在哪里生效
- `@Before`：定义做什么事情

### 2.3 常见的切面类型


**🌟 实际开发中的切面**

```
日志切面：
作用：自动记录方法的调用信息
好处：不用在每个方法里写日志代码

权限切面：
作用：自动检查用户是否有操作权限
好处：统一管理权限验证逻辑

事务切面：
作用：自动管理数据库事务
好处：不用手动开启和提交事务

性能切面：
作用：自动统计方法执行时间
好处：方便性能分析和优化

缓存切面：
作用：自动缓存方法返回结果
好处：提高系统性能
```

---

## 3. 🎯 连接点JoinPoint


### 3.1 连接点的含义


**🔸 通俗理解**

连接点就是程序执行过程中的一个个"时刻点"，就像时间轴上的刻度。

```
程序执行的时间轴：
启动 → 方法开始 → 方法执行中 → 方法结束 → 异常处理 → ...
       ↑           ↑            ↑          ↑
     连接点      连接点       连接点     连接点

生活类比：
地铁线路图上的每一站都可以是"连接点"
- 起点站（方法开始）
- 中间站（方法执行）
- 终点站（方法结束）
- 换乘站（异常处理）

你可以选择在任何一站做某些事情
但实际只在部分站点设置功能（切入点）
```

### 3.2 Spring AOP支持的连接点


**📍 可以"插入"功能的位置**

Spring AOP主要支持方法级别的连接点：

```
方法执行的生命周期：

┌─────────────────────────────────┐
│     1. 方法调用前              │ ← 可以插入功能
├─────────────────────────────────┤
│     2. 方法参数传入            │ ← 可以插入功能
├─────────────────────────────────┤
│     3. 方法开始执行            │ ← 可以插入功能
├─────────────────────────────────┤
│     4. 方法正常返回            │ ← 可以插入功能
├─────────────────────────────────┤
│     5. 方法抛出异常            │ ← 可以插入功能
├─────────────────────────────────┤
│     6. 方法最终结束            │ ← 可以插入功能
└─────────────────────────────────┘
```

**🔍 连接点的信息**

连接点对象包含了当前执行点的所有信息：

```java
public void logMethod(JoinPoint joinPoint) {
    // 获取方法名
    String methodName = joinPoint.getSignature().getName();
    
    // 获取参数
    Object[] args = joinPoint.getArgs();
    
    // 获取目标对象
    Object target = joinPoint.getTarget();
    
    System.out.println("方法：" + methodName);
    System.out.println("参数：" + Arrays.toString(args));
}
```

**💡 实用场景**：
- 记录方法调用信息时需要方法名
- 参数校验时需要参数值
- 权限检查时需要目标对象信息

### 3.3 连接点 vs 切入点


**🔄 两者的关系**

```
连接点（JoinPoint）：
→ 所有可能的位置（候选点）
→ 就像地图上所有的地点

切入点（Pointcut）：
→ 实际选中的位置（真正使用的点）
→ 就像你实际要去的地点

形象比喻：
连接点 = 一条路上的所有路口（可能的位置）
切入点 = 你决定在哪几个路口设红绿灯（实际选择）

代码关系：
所有方法执行 = 连接点（潜在的）
匹配表达式的方法 = 切入点（实际的）
```

---

## 4. 📍 切入点Pointcut


### 4.1 切入点的作用


**🔸 简单理解**

切入点就是"选择器"，用来选择在哪些方法上应用切面功能。

```
生活类比：
超市里的安保摄像头不可能装在每个角落（太浪费）
需要选择重要位置：收银台、出入口、贵重商品区

代码世界：
不是所有方法都需要日志记录（太浪费性能）
需要选择重要方法：Controller层、Service层的关键业务
```

### 4.2 切入点表达式


**📝 如何表达"在哪里"**

Spring使用表达式来精确描述要拦截的方法：

**🔹 基础语法结构**
```
execution(修饰符? 返回值 包路径.类名.方法名(参数) 异常?)

解释：
- ?号表示可选项
- *号表示通配符
- ..表示任意层级

通俗理解就像写地址：
省.市.区.街道.门牌号
com.example.service.UserService.save(User)
```

**🔹 常用表达式示例**

| 表达式 | 含义 | 通俗解释 |
|--------|------|----------|
| `execution(* com.example.service.*.*(..))` | 匹配service包下所有类的所有方法 | "service包里的所有事情都管" |
| `execution(public * com.example..*.*(..))` | 匹配example包及子包的所有public方法 | "所有公开的方法都管" |
| `execution(* com.example.service.*Service.*(..))` | 匹配所有以Service结尾的类 | "只管服务类" |
| `execution(* save*(..))` | 匹配所有save开头的方法 | "只管保存相关的方法" |
| `execution(* com.example..*.*(String, *))` | 第一个参数是String的方法 | "只管第一个参数是文本的方法" |

**💡 实用技巧**
```java
// 示例1：只拦截Service层
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceLayer() {}

// 示例2：只拦截Controller层
@Pointcut("execution(* com.example.controller.*.*(..))")
public void controllerLayer() {}

// 示例3：组合使用 - Service和Controller都拦截
@Pointcut("serviceLayer() || controllerLayer()")
public void businessLayer() {}
```

### 4.3 切入点的组合


**🔗 多种匹配方式**

除了execution表达式，还有其他方式：

```java
// 1. 基于注解匹配 - 更灵活
@Pointcut("@annotation(com.example.Log)")
public void logAnnotation() {}
// 只有加了@Log注解的方法才会被拦截

// 2. 基于类型匹配
@Pointcut("within(com.example.service.*)")
public void inServicePackage() {}
// 匹配service包下的所有方法

// 3. 组合条件
@Pointcut("serviceLayer() && @annotation(com.example.Log)")
public void serviceWithLog() {}
// 既要在service包，又要有@Log注解
```

**🎯 选择建议**：

```
简单项目：
→ 用execution匹配包路径即可
→ execution(* com.example.service.*.*(..))

复杂项目：
→ 推荐用注解方式
→ @annotation(com.example.Log)
→ 更灵活，可以精确控制每个方法
```

---

## 5. 🔔 通知Advice


### 5.1 通知的含义


**🔸 通俗解释**

通知就是"要做的事情"，是切面的具体行为。

```
形象比喻：
切入点 = 在哪个路口设红绿灯（位置）
通知   = 红绿灯要做什么（变红、变绿、闪烁）

代码理解：
切入点 = 选择了哪些方法
通知   = 在这些方法上执行什么代码
```

### 5.2 通知的类型


**📋 五种通知时机**

Spring AOP提供了5种通知类型，对应方法执行的不同时刻：

```
方法执行流程：
                              
    @Before               开始前执行
       ↓                  
   ┌────────┐             
   │        │             
   │ 方法   │  @Around    环绕整个方法
   │ 执行   │             
   │        │             
   └────────┘             
       ↓                  
    正常返回 ──→ @AfterReturning   返回后执行
       ↓                  
    抛出异常 ──→ @AfterThrowing    异常后执行
       ↓                  
    @After                最终都会执行
```

**🔹 1. @Before - 前置通知**

在方法执行之前运行

```java
@Before("serviceLayer()")
public void logBefore(JoinPoint joinPoint) {
    System.out.println("【前置】准备执行：" + joinPoint.getSignature().getName());
}

// 实际应用场景：
// - 参数校验
// - 权限检查  
// - 记录操作日志
```

**🔹 2. @AfterReturning - 返回通知**

方法正常返回后运行（没有异常）

```java
@AfterReturning(
    pointcut = "serviceLayer()",
    returning = "result"  // 可以获取返回值
)
public void logAfterReturning(JoinPoint joinPoint, Object result) {
    System.out.println("【返回】方法返回值：" + result);
}

// 实际应用场景：
// - 记录返回结果
// - 缓存处理
// - 数据转换
```

**🔹 3. @AfterThrowing - 异常通知**

方法抛出异常后运行

```java
@AfterThrowing(
    pointcut = "serviceLayer()",
    throwing = "ex"  // 可以获取异常对象
)
public void logAfterThrowing(JoinPoint joinPoint, Exception ex) {
    System.out.println("【异常】发生错误：" + ex.getMessage());
}

// 实际应用场景：
// - 异常日志记录
// - 异常通知（发邮件、短信）
// - 异常统计
```

**🔹 4. @After - 后置通知**

方法执行后一定会运行（finally的效果）

```java
@After("serviceLayer()")
public void logAfter(JoinPoint joinPoint) {
    System.out.println("【最终】方法执行结束");
}

// 实际应用场景：
// - 资源清理
// - 性能统计
// - 状态重置
```

**🔹 5. @Around - 环绕通知**

最强大的通知，可以完全控制方法执行

```java
@Around("serviceLayer()")
public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
    System.out.println("【环绕-前】方法开始");
    
    // 执行原方法
    Object result = joinPoint.proceed();
    
    System.out.println("【环绕-后】方法结束");
    return result;
}

// 实际应用场景：
// - 性能监控（计算执行时间）
// - 事务管理
// - 缓存处理
// - 重试机制
```

### 5.3 通知的执行顺序


**📊 多个通知的执行流程**

```
完整的执行顺序：

@Around前半部分
    ↓
@Before
    ↓
【目标方法执行】
    ↓
@Around后半部分
    ↓
@After（无论如何都执行）
    ↓
@AfterReturning（正常返回）或 @AfterThrowing（异常）

记忆技巧：
Around像个大括号 { }
Before在方法前
After一定执行
AfterReturning和AfterThrowing二选一
```

### 5.4 实用案例对比


**🎯 不同通知的使用场景**

```java
// 场景1：性能监控 - 用@Around
@Around("serviceLayer()")
public Object monitor(ProceedingJoinPoint pjp) throws Throwable {
    long start = System.currentTimeMillis();
    Object result = pjp.proceed();
    long end = System.currentTimeMillis();
    System.out.println("耗时：" + (end - start) + "ms");
    return result;
}

// 场景2：参数校验 - 用@Before
@Before("serviceLayer()")
public void validate(JoinPoint jp) {
    Object[] args = jp.getArgs();
    if (args == null || args.length == 0) {
        throw new IllegalArgumentException("参数不能为空");
    }
}

// 场景3：异常处理 - 用@AfterThrowing
@AfterThrowing(pointcut = "serviceLayer()", throwing = "ex")
public void handleException(Exception ex) {
    // 发送告警邮件
    sendAlertEmail(ex.getMessage());
}
```

---

## 6. ⚙️ 织入Weaving


### 6.1 织入的概念


**🔸 通俗理解**

织入就是把切面功能"安装"到目标方法上的过程。

```
生活类比：
织入 = 给衣服缝上扣子的过程
- 衣服是原本的（目标对象）
- 扣子是额外的（切面功能）
- 缝制是过程（织入）
- 成品衣服可以用（代理对象）

代码理解：
织入 = 把日志、事务等功能加到业务方法上
- 业务方法是原本的
- 日志、事务是额外的
- Spring自动完成这个过程
- 最终得到增强的对象
```

### 6.2 织入的时机


**⏰ 什么时候"安装"功能**

Spring AOP主要在运行时织入：

```
三种织入时机：

1. 编译时织入（Compile-time）
   ├─ 在代码编译时就把切面织入
   ├─ 工具：AspectJ编译器
   └─ Spring AOP不用这种方式

2. 类加载时织入（Load-time）
   ├─ 在类加载到JVM时织入
   ├─ 工具：特殊的类加载器
   └─ Spring AOP不常用

3. 运行时织入（Runtime）★
   ├─ 程序运行时动态生成代理对象
   ├─ 工具：Spring AOP默认方式
   └─ 灵活但性能略低
```

**💡 Spring AOP的织入方式**

Spring在运行时通过**代理模式**实现织入：

```
原始调用流程：
客户端 → 目标对象.方法()

织入后的流程：
客户端 → 代理对象.方法() 
           ↓
        【切面功能】
           ↓
        目标对象.方法()
           ↓
        【切面功能】
           ↓
         返回结果
```

### 6.3 代理方式


**🔧 Spring的两种代理技术**

Spring根据目标对象的类型选择代理方式：

**方式1：JDK动态代理**
```
使用条件：
✓ 目标对象实现了接口

工作原理：
┌─────────────┐
│   接口API   │
└─────────────┘
       ↑
       │实现
┌─────────────┐      ┌─────────────┐
│ 目标对象    │ ←─── │ JDK代理对象 │
└─────────────┘      └─────────────┘
                           ↑
                        客户端调用

特点：
- Java原生支持
- 必须有接口
- 性能较好
```

**方式2：CGLIB动态代理**
```
使用条件：
✓ 目标对象没有实现接口

工作原理：
┌─────────────┐
│ 目标类      │
└─────────────┘
       ↑
       │继承
┌─────────────┐
│ CGLIB代理   │
│  (子类)     │
└─────────────┘
       ↑
    客户端调用

特点：
- 通过继承实现
- 不需要接口
- 不能代理final类和方法
```

**🎯 实际应用**

```java
// 有接口的情况 - 使用JDK代理
public interface UserService {
    void save(User user);
}

@Service
public class UserServiceImpl implements UserService {
    public void save(User user) {
        // 业务代码
    }
}

// 没接口的情况 - 使用CGLIB代理
@Service
public class OrderService {
    public void createOrder(Order order) {
        // 业务代码
    }
}

// Spring会自动选择合适的代理方式
// 你不需要关心具体用哪种，Spring都帮你搞定了
```

---

## 7. 🎯 目标对象Target


### 7.1 目标对象的定义


**🔸 简单理解**

目标对象就是被切面"盯上"的对象，也就是真正执行业务逻辑的对象。

```
形象比喻：
如果切面是"保镖"
那么目标对象就是被保护的"明星"

保镖（切面）的职责：
- 在明星出门前检查安全（@Before）
- 全程跟随保护（@Around）
- 处理突发状况（@AfterThrowing）

明星（目标对象）的职责：
- 专注做自己的事（业务逻辑）
- 不用关心保镖的事（切面逻辑）
```

### 7.2 目标对象的特点


**📋 核心特征**

```
目标对象的本质：
1. 包含核心业务逻辑的对象
2. 通常是Service层、Dao层的Bean
3. 被Spring管理的普通Java对象

工作方式：
原始对象                代理对象
┌──────────┐          ┌──────────┐
│          │          │  切面    │
│  业务    │  被包装   │  ┌────┐ │
│  逻辑    │  ───→    │  │业务│ │
│          │          │  └────┘ │
└──────────┘          └──────────┘
    ↑                      ↑
  目标对象              客户端看到的对象
```

### 7.3 目标对象示例


**💼 实际业务代码**

```java
// 这是一个目标对象
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // 这个方法会被切面增强
    public void registerUser(User user) {
        // 纯粹的业务逻辑
        // 不包含日志、事务、权限等代码
        userRepository.save(user);
    }
    
    public User findUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}

// Spring会做这些事：
// 1. 创建UserService对象（目标对象）
// 2. 根据切面配置创建代理对象
// 3. 把代理对象注入到需要的地方
// 4. 客户端实际使用的是代理对象
```

### 7.4 目标对象与代理对象的关系


**🔗 两者的协作**

```
调用过程详解：

步骤1：客户端调用
Controller controller = new UserController();
controller.register(user);  
         ↓
步骤2：实际调用的是代理对象
UserServiceProxy.register(user)
         ↓
步骤3：执行切面逻辑（前置）
logAspect.before();  // 记录日志
         ↓
步骤4：调用真正的目标对象
userService.register(user);  // 执行业务
         ↓
步骤5：执行切面逻辑（后置）
logAspect.after();  // 记录完成

关键理解：
- 代理对象是"外壳"（负责切面功能）
- 目标对象是"内核"（负责业务逻辑）
- 客户端只看到代理，感知不到目标对象
```

**💡 验证代理关系**

```java
@RestController
public class TestController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/test")
    public String test() {
        // 打印对象类型
        System.out.println(userService.getClass().getName());
        // 输出可能是：
        // com.example.UserService$$EnhancerBySpringCGLIB$$xxxxx
        // 这个复杂的名字说明这是代理对象，不是原始对象
        
        return "ok";
    }
}
```

---

## 8. 🗺️ 术语关系图解


### 8.1 完整关系图


```
                    AOP完整流程图
                    
    ┌─────────────────────────────────────────┐
    │            切面 (Aspect)                │
    │  ┌─────────────┐    ┌────────────────┐ │
    │  │  切入点      │    │    通知        │ │
    │  │ (Pointcut)  │    │  (Advice)      │ │
    │  │             │    │                │ │
    │  │ 选择在哪些  │    │  定义做什么    │ │
    │  │ 方法上应用  │    │  事情          │ │
    │  └─────────────┘    └────────────────┘ │
    └─────────────────────────────────────────┘
                    ↓
              【织入 (Weaving)】
                    ↓
    ┌─────────────────────────────────────────┐
    │          代理对象 (Proxy)               │
    │  ┌────────────────────────────────────┐ │
    │  │          切面功能                  │ │
    │  │  ┌──────────────────────────────┐ │ │
    │  │  │    目标对象 (Target)         │ │ │
    │  │  │                              │ │ │
    │  │  │    在连接点(JoinPoint)      │ │ │
    │  │  │    执行业务逻辑              │ │ │
    │  │  └──────────────────────────────┘ │ │
    │  └────────────────────────────────────┘ │
    └─────────────────────────────────────────┘
                    ↓
              客户端调用
```

### 8.2 术语协作流程


**📊 实际运行流程**

```
1. 定义阶段（开发时）
   ├─ 编写目标对象（Service类）
   ├─ 定义切面（@Aspect类）
   ├─ 设置切入点（哪些方法需要增强）
   └─ 编写通知（要做什么增强）

2. 启动阶段（Spring容器启动）
   ├─ 扫描所有Bean
   ├─ 识别切面配置
   ├─ 匹配切入点表达式
   └─ 创建代理对象（织入）

3. 运行阶段（调用方法时）
   ├─ 客户端调用方法
   ├─ 代理对象拦截调用
   ├─ 执行通知（前置、环绕等）
   ├─ 调用目标对象方法（业务逻辑）
   ├─ 执行通知（返回、异常等）
   └─ 返回结果给客户端
```

### 8.3 记忆口诀


**🎯 快速记忆**

```
切面是总管，定义做什么
切入点是筛选，选择在哪做
通知是执行，具体怎么做
连接点是时刻，可能的位置
织入是过程，组装到一起
目标对象核心，业务逻辑在

记忆顺序：
定义切面 → 选择切入点 → 编写通知 
→ Spring织入 → 生成代理 → 增强目标对象
```

---

## 9. 📋 核心要点总结


### 9.1 六大术语速记


| 术语 | 通俗理解 | 核心作用 | 实际对应 |
|------|----------|----------|----------|
| **Aspect<br>切面** | 一个功能模块 | 把通用功能打包 | `@Aspect`类 |
| **JoinPoint<br>连接点** | 可以插入的时刻 | 所有可能增强的地方 | 方法执行的各个阶段 |
| **Pointcut<br>切入点** | 实际选中的位置 | 精确选择哪些方法 | `execution()`表达式 |
| **Advice<br>通知** | 具体要做的事 | 定义增强的行为 | `@Before`等注解 |
| **Weaving<br>织入** | 组装的过程 | 把切面加到对象上 | Spring自动完成 |
| **Target<br>目标对象** | 被增强的对象 | 执行业务逻辑 | Service类实例 |

### 9.2 关键理解要点


**🔹 核心思想**
```
AOP的本质：
就是把那些到处重复的代码（日志、事务、权限等）
抽取出来单独管理
然后自动"插入"到需要的地方

好处：
✓ 业务代码更纯粹（只关注业务）
✓ 通用功能统一管理（改一处全生效）
✓ 代码复用性高（写一次到处用）
```

**🔹 工作流程**
```
1. 你写业务代码（目标对象）
2. 你写切面配置（定义增强）
3. Spring自动织入（生成代理）
4. 客户端调用（自动增强）

你只需要关心：
- 业务逻辑怎么写
- 切面功能怎么定义
- 在哪些方法上应用

Spring帮你搞定：
- 创建代理对象
- 拦截方法调用
- 执行切面逻辑
```

### 9.3 实践建议


**💡 新手入门建议**

```
学习步骤：
1. 先理解为什么需要AOP（解决重复代码问题）
2. 理解切面和目标对象的关系（增强者和被增强者）
3. 掌握切入点表达式（选择要增强的方法）
4. 熟悉五种通知类型（不同时机做不同的事）
5. 最后理解织入和代理（Spring的魔法）

常见应用场景：
✓ 日志记录：@Around 或 @Before + @AfterReturning
✓ 权限验证：@Before
✓ 事务管理：@Around（Spring已提供）
✓ 异常处理：@AfterThrowing
✓ 性能监控：@Around
```

**⚠️ 注意事项**
```
1. 切入点表达式要精确
   ❌ execution(* *.*(..))  // 太宽泛
   ✅ execution(* com.example.service.*.*(..))  // 合适

2. 通知类型要选对
   ❌ 用@Before做性能监控（无法计算时间）
   ✅ 用@Around做性能监控（可以控制前后）

3. 代理的限制
   ❌ 同一个类内部方法调用不会触发AOP
   ✅ 通过Spring容器注入的Bean调用才会触发
```

### 9.4 知识拓展


**🚀 进阶方向**

```
掌握基础后可以学习：

1. Spring声明式事务（基于AOP）
   @Transactional注解的原理

2. Spring Security权限控制（基于AOP）
   @PreAuthorize注解的实现

3. 自定义注解+AOP
   创建自己的功能注解

4. AspectJ完整特性
   Spring AOP的增强版本

5. 性能优化
   减少AOP带来的性能损耗
```

**核心记忆**：
- AOP让代码解耦，通用功能统一管理
- 切面定义功能，切入点选择位置，通知决定行为
- Spring自动织入，运行时生成代理对象
- 理解六大术语，掌握AOP精髓