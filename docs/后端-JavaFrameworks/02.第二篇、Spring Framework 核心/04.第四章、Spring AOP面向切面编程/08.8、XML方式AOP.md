---
title: 8、XML方式AOP
---
## 📚 目录

1. [XML方式AOP概述](#1-XML方式AOP概述)
2. [AOP命名空间配置](#2-AOP命名空间配置)
3. [切面配置详解](#3-切面配置详解)
4. [切入点表达式](#4-切入点表达式)
5. [通知类型配置](#5-通知类型配置)
6. [Advisor顾问配置](#6-Advisor顾问配置)
7. [完整实战案例](#7-完整实战案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 XML方式AOP概述


### 1.1 什么是XML配置AOP


> **💡 通俗理解**
> 
> XML配置AOP就像用一份"配置清单"来告诉Spring：
> - 哪些类是切面（提供额外功能的类）
> - 在哪些方法执行时触发切面（切入点）
> - 什么时候执行切面方法（通知类型）
> 
> 不需要在代码里写注解，全部写在XML文件里

**🔸 核心特点**：
- **配置集中**：所有AOP配置写在XML文件中
- **代码无侵入**：业务类不需要任何注解
- **灵活调整**：修改切面逻辑不用改Java代码
- **适合场景**：老项目维护、需要动态配置的场景

### 1.2 XML配置 vs 注解配置


**对比理解**：

```
注解方式（@Aspect）：
├─ 优点：配置简单，代码和配置在一起
├─ 缺点：修改需要重新编译
└─ 适用：新项目，配置相对固定

XML方式（<aop:config>）：
├─ 优点：配置灵活，不侵入代码
├─ 缺点：配置稍显繁琐
└─ 适用：老项目，需要动态调整
```

**📊 特性对比表**：

| 特性 | XML配置 | 注解配置 |
|------|---------|----------|
| **配置位置** | `applicationContext.xml` | `Java类中` |
| **代码侵入性** | 无侵入 ✅ | 需要注解 |
| **灵活性** | 高（可热修改）⭐⭐⭐ | 中（需重编译）⭐⭐ |
| **可读性** | 集中管理 📋 | 分散在类中 |
| **学习难度** | 稍高 ⭐⭐⭐ | 简单 ⭐⭐ |
| **推荐场景** | 老项目/动态配置 | 新项目/快速开发 |

---

## 2. 📝 AOP命名空间配置


### 2.1 引入AOP命名空间


> **⚠️ 重要前提**
> 
> 使用XML配置AOP，必须先引入AOP的命名空间，否则Spring无法识别`<aop:config>`等标签

**配置步骤**：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd">
    
    <!-- AOP配置写在这里 -->
    
</beans>
```

**🔍 配置说明**：

```
关键部分解析：

xmlns:aop="..." 
→ 定义aop命名空间前缀，让我们可以使用<aop:xxx>标签

xsi:schemaLocation中的aop部分
→ 告诉Spring去哪里验证aop标签的语法规则
→ spring-aop.xsd是规则文件
```

### 2.2 Maven依赖检查


**必需依赖**：

```xml
<!-- Spring AOP核心 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>5.3.20</version>
</dependency>

<!-- AspectJ织入器（XML方式必需） -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.7</version>
</dependency>
```

> **💡 为什么需要aspectjweaver？**
> 
> XML配置方式底层使用AspectJ来解析切入点表达式，所以必须引入这个依赖

---

## 3. 🔧 切面配置详解


### 3.1 `<aop:config>`根元素


**🔸 基本结构**：

```xml
<aop:config>
    <!-- 所有AOP配置都写在这里面 -->
    <!-- 可以配置多个切面 -->
    <!-- 可以配置多个切入点 -->
</aop:config>
```

**作用说明**：
- `<aop:config>`是所有AOP配置的根容器
- 一个XML文件可以有多个`<aop:config>`块
- 每个`<aop:config>`可以包含多个切面定义

### 3.2 `<aop:aspect>`切面定义


> **💡 什么是切面？**
> 
> 切面就是"提供额外功能的类"，比如：
> - 日志记录切面：记录方法调用日志
> - 性能监控切面：统计方法执行时间
> - 事务管理切面：自动开启和提交事务

**基本配置**：

```xml
<!-- 1. 先定义切面类Bean -->
<bean id="logAspect" class="com.example.aspect.LogAspect"/>

<!-- 2. 在aop:config中配置切面 -->
<aop:config>
    <aop:aspect ref="logAspect">
        <!-- 切面的具体配置 -->
    </aop:aspect>
</aop:config>
```

**🔍 属性详解**：

| 属性 | 说明 | 示例 |
|------|------|------|
| **ref** | 指向切面类的Bean ID | `ref="logAspect"` |
| **id** | 切面的唯一标识（可选） | `id="myAspect"` |
| **order** | 多切面执行顺序（可选） | `order="1"` |

**📋 切面类示例**：

```java
// 这是一个普通的Java类，不需要任何注解
public class LogAspect {
    
    // 前置通知方法
    public void beforeLog() {
        System.out.println("方法执行前：记录日志");
    }
    
    // 后置通知方法
    public void afterLog() {
        System.out.println("方法执行后：记录日志");
    }
}
```

### 3.3 `<aop:pointcut>`切入点配置


> **🎯 什么是切入点？**
> 
> 切入点就是"在哪些方法上应用切面"的规则，比如：
> - "所有service包下的方法"
> - "所有以save开头的方法"
> - "所有返回值是User类型的方法"

**两种配置位置**：

```xml
<aop:config>
    <!-- 位置1：全局切入点（可被多个切面共用） -->
    <aop:pointcut id="globalPoint" 
                  expression="execution(* com.example.service.*.*(..))"/>
    
    <aop:aspect ref="logAspect">
        <!-- 位置2：切面内部切入点（只能当前切面用） -->
        <aop:pointcut id="localPoint" 
                      expression="execution(* com.example.dao.*.*(..))"/>
        
        <aop:before method="beforeLog" pointcut-ref="globalPoint"/>
    </aop:aspect>
</aop:config>
```

**📊 位置对比**：

```
全局切入点：
┌─────────────────┐
│ <aop:config>    │
│  <aop:pointcut> │ ← 定义在这里，所有切面都能用
│  <aop:aspect>   │
│    ...          │
│  </aop:aspect>  │
└─────────────────┘

局部切入点：
┌─────────────────┐
│ <aop:config>    │
│  <aop:aspect>   │
│   <aop:pointcut>│ ← 定义在这里，只有当前切面能用
│   ...           │
│  </aop:aspect>  │
└─────────────────┘
```

---

## 4. 🎯 切入点表达式


### 4.1 execution表达式语法


**完整语法格式**：

```
execution(modifiers? return-type declaring-type? method-name(params) throws?)

execution(访问修饰符? 返回类型 包名.类名? 方法名(参数) 异常?)
         ↑可省略     ↑必填   ↑可省略   ↑必填  ↑必填  ↑可省略
```

**🔍 各部分详解**：

| 部分 | 说明 | 示例 | 是否必填 |
|------|------|------|----------|
| **访问修饰符** | public/private等 | `public` | ❌ 可省略 |
| **返回类型** | 方法返回值类型 | `void`、`String`、`*` | ✅ 必填 |
| **包名.类名** | 方法所在的类 | `com.example.UserService` | ❌ 可省略 |
| **方法名** | 要匹配的方法名 | `save`、`find*` | ✅ 必填 |
| **参数** | 方法参数列表 | `()`、`(..)` | ✅ 必填 |
| **异常** | 抛出的异常 | `throws Exception` | ❌ 可省略 |

### 4.2 通配符使用


**常用通配符**：

```
* → 匹配任意字符
.. → 匹配任意多个参数或包

示例说明：

* com.example.*.save(..) 
  ↓
  * → 任意返回值
  com.example.* → example包下的任意类
  save → 方法名必须是save
  (..) → 任意参数
```

**📋 实用表达式示例**：

```xml
<!-- 示例1：匹配service包下所有方法 -->
<aop:pointcut id="p1" 
    expression="execution(* com.example.service.*.*(..))"/>
    
<!-- 示例2：匹配所有save开头的方法 -->
<aop:pointcut id="p2" 
    expression="execution(* com.example.service.*ServiceImpl.save*(..))"/>
    
<!-- 示例3：匹配返回User类型的方法 -->
<aop:pointcut id="p3" 
    expression="execution(com.example.domain.User com.example..*.*(..))"/>
    
<!-- 示例4：匹配单个参数的方法 -->
<aop:pointcut id="p4" 
    expression="execution(* com.example.service.*.*(String))"/>
    
<!-- 示例5：匹配第一个参数是String的方法 -->
<aop:pointcut id="p5" 
    expression="execution(* com.example.service.*.*(String, ..))"/>
```

> **🔔 注意事项**
> 
> - 返回类型不能省略，最少要写`*`
> - `..`在参数位置表示任意参数，在包名位置表示任意子包
> - 方法名支持通配符，如`save*`匹配saveUser、saveOrder等

### 4.3 表达式组合


**逻辑运算符**：

```xml
<!-- AND：同时满足多个条件 -->
<aop:pointcut id="p1" 
    expression="execution(* com.example.service.*.*(..)) 
                and execution(* *..User*(..))"/>

<!-- OR：满足任意条件 -->
<aop:pointcut id="p2" 
    expression="execution(* *..save*(..)) 
                or execution(* *..update*(..))"/>

<!-- NOT：排除某些方法 -->
<aop:pointcut id="p3" 
    expression="execution(* com.example.service.*.*(..)) 
                and !execution(* *..get*(..))"/>
```

**📊 组合示例图解**：

```
场景：给service层的增删改方法添加事务

execution(* com.example.service.*.*(..))  ← 所有service方法
        AND
( execution(* *..save*(..))               ← save开头
        OR
  execution(* *..update*(..))             ← update开头
        OR
  execution(* *..delete*(..)) )           ← delete开头
```

---

## 5. 📢 通知类型配置


### 5.1 五种通知类型


**🔸 通知类型概览**：

```
方法执行流程：

  [前置通知] 
      ↓
  try {
    [目标方法]
      ↓
    [返回通知]
  } catch(Exception e) {
    [异常通知]
  } finally {
    [后置通知]
  }
      ↓
  [环绕通知]（可控制整个流程）
```

**📋 通知对比表**：

| 通知类型 | XML标签 | 执行时机 | 能否阻止方法执行 | 典型应用 |
|----------|---------|----------|------------------|----------|
| **前置通知** | `<aop:before>` | 方法执行前 | ❌ | 参数验证、权限检查 |
| **后置通知** | `<aop:after>` | 方法执行后（无论成功失败） | ❌ | 资源清理、日志记录 |
| **返回通知** | `<aop:after-returning>` | 方法正常返回后 | ❌ | 结果处理、缓存更新 |
| **异常通知** | `<aop:after-throwing>` | 方法抛出异常后 | ❌ | 异常处理、错误日志 |
| **环绕通知** | `<aop:around>` | 方法执行前后 | ✅ | 事务管理、性能统计 |

### 5.2 前置通知（Before）


> **💡 什么时候用？**
> 
> 在方法执行前做一些准备工作，比如：
> - 检查用户是否登录
> - 验证方法参数是否合法
> - 记录方法调用日志

**配置示例**：

```xml
<aop:config>
    <aop:aspect ref="logAspect">
        <!-- 基本配置 -->
        <aop:before method="beforeLog" 
                    pointcut-ref="servicePointcut"/>
        
        <!-- 或者直接写表达式 -->
        <aop:before method="beforeLog" 
                    pointcut="execution(* com.example.service.*.*(..))"/>
    </aop:aspect>
</aop:config>
```

**对应的切面方法**：

```java
public class LogAspect {
    
    // 无参前置通知
    public void beforeLog() {
        System.out.println("方法执行前");
    }
    
    // 带JoinPoint参数（可获取目标方法信息）
    public void beforeLogWithJoinPoint(JoinPoint jp) {
        String methodName = jp.getSignature().getName();
        Object[] args = jp.getArgs();
        System.out.println("执行方法：" + methodName);
        System.out.println("方法参数：" + Arrays.toString(args));
    }
}
```

### 5.3 后置通知（After）


> **💡 什么时候用？**
> 
> 在方法执行后做清理工作，**无论方法成功还是失败都会执行**，类似finally块

**配置示例**：

```xml
<aop:after method="afterLog" 
           pointcut-ref="servicePointcut"/>
```

**切面方法**：

```java
public void afterLog() {
    System.out.println("方法执行完毕（无论成功失败）");
    // 适合做资源释放、连接关闭等操作
}
```

### 5.4 返回通知（After-Returning）


> **💡 什么时候用？**
> 
> 只在方法**正常返回**时执行，可以获取方法的返回值

**配置示例**：

```xml
<aop:after-returning method="afterReturning" 
                     pointcut-ref="servicePointcut"
                     returning="result"/>
```

**切面方法**：

```java
// result参数名要和returning属性一致
public void afterReturning(Object result) {
    System.out.println("方法返回值：" + result);
    // 可以对返回值做处理，比如缓存结果
}

// 也可以限定返回值类型
public void afterReturningUser(User result) {
    System.out.println("返回用户：" + result.getName());
}
```

### 5.5 异常通知（After-Throwing）


> **💡 什么时候用？**
> 
> 只在方法**抛出异常**时执行，可以获取异常对象

**配置示例**：

```xml
<aop:after-throwing method="afterThrowing" 
                    pointcut-ref="servicePointcut"
                    throwing="ex"/>
```

**切面方法**：

```java
// ex参数名要和throwing属性一致
public void afterThrowing(Exception ex) {
    System.out.println("方法异常：" + ex.getMessage());
    // 可以做异常日志记录、发送告警等
}

// 可以指定具体异常类型
public void afterThrowingSQL(SQLException ex) {
    System.out.println("数据库异常：" + ex.getSQLState());
}
```

### 5.6 环绕通知（Around）


> **💡 什么时候用？**
> 
> **功能最强大**的通知，可以：
> - 控制目标方法是否执行
> - 修改方法参数
> - 修改返回值
> - 捕获并处理异常

**配置示例**：

```xml
<aop:around method="aroundLog" 
            pointcut-ref="servicePointcut"/>
```

**切面方法**：

```java
public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println("环绕通知：方法执行前");
    
    try {
        // 执行目标方法
        Object result = pjp.proceed();
        
        System.out.println("环绕通知：方法执行后");
        return result;
        
    } catch (Exception e) {
        System.out.println("环绕通知：捕获异常 " + e.getMessage());
        throw e;
    }
}
```

**🔍 环绕通知的特殊之处**：

```
环绕通知的执行流程：

[环绕通知开始]
    ↓
pjp.proceed() → 执行目标方法
    ↓
[环绕通知结束]

关键点：
• 必须调用pjp.proceed()才会执行目标方法
• 可以不调用proceed()来阻止方法执行
• 必须返回proceed()的结果（或处理后的结果）
• 必须声明throws Throwable
```

---

## 6. 🎓 Advisor顾问配置


### 6.1 Advisor vs Aspect


> **🤔 两者有什么区别？**
> 
> - **Aspect（切面）**：一个切面类里可以有多个通知方法，每个通知可以有不同的切入点
> - **Advisor（顾问）**：一个通知 + 一个切入点 = 一个Advisor，更简单直接

**对比理解**：

```
Aspect方式（一对多）：
LogAspect类
├─ beforeLog() → pointcut1
├─ afterLog()  → pointcut2
└─ aroundLog() → pointcut3

Advisor方式（一对一）：
LogAdvisor
└─ 通知方法 → 切入点（固定绑定）
```

### 6.2 `<aop:advisor>`配置


**基本配置**：

```xml
<!-- 1. 定义通知Bean（必须实现特定接口） -->
<bean id="logAdvice" class="com.example.advice.LogAdvice"/>

<!-- 2. 配置Advisor -->
<aop:config>
    <aop:advisor advice-ref="logAdvice" 
                 pointcut="execution(* com.example.service.*.*(..))"/>
</aop:config>
```

**🔸 属性说明**：

| 属性 | 说明 | 必填 |
|------|------|------|
| **advice-ref** | 指向通知Bean的ID | ✅ |
| **pointcut** | 切入点表达式 | ✅ |
| **pointcut-ref** | 引用已定义的切入点 | 或 |
| **order** | 执行顺序 | ❌ |

### 6.3 通知接口类型


**Spring提供的通知接口**：

```java
// 1. 前置通知接口
public class LogAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] args, Object target) {
        System.out.println("前置：" + method.getName());
    }
}

// 2. 后置返回通知接口
public class AfterAdvice implements AfterReturningAdvice {
    @Override
    public void afterReturning(Object returnValue, Method method, 
                               Object[] args, Object target) {
        System.out.println("返回：" + returnValue);
    }
}

// 3. 异常通知接口
public class ThrowsAdvice implements ThrowsAdvice {
    public void afterThrowing(Exception ex) {
        System.out.println("异常：" + ex.getMessage());
    }
}

// 4. 环绕通知接口
public class AroundAdvice implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("环绕开始");
        Object result = invocation.proceed();
        System.out.println("环绕结束");
        return result;
    }
}
```

**📊 Advisor使用场景**：

```
何时使用Advisor：
✅ 通知逻辑简单，只需要一个切入点
✅ 使用Spring内置的通知接口
✅ 需要更精确的控制（如事务管理）

何时使用Aspect：
✅ 一个切面有多个通知方法
✅ 需要更灵活的配置
✅ 通知方法可以是普通方法（不实现接口）
```

---

## 7. 💼 完整实战案例


### 7.1 需求场景


**业务需求**：
- 为UserService的所有方法添加日志记录
- 为UserService的增删改方法添加事务管理
- 统计方法执行时间

**项目结构**：

```
com.example
├── service
│   ├── UserService.java          // 业务接口
│   └── UserServiceImpl.java      // 业务实现
├── aspect
│   ├── LogAspect.java            // 日志切面
│   └── TransactionAspect.java    // 事务切面
└── applicationContext.xml         // Spring配置
```

### 7.2 业务代码


**业务接口和实现**：

```java
// UserService.java
public interface UserService {
    User findById(Long id);
    void saveUser(User user);
    void updateUser(User user);
    void deleteUser(Long id);
}

// UserServiceImpl.java
public class UserServiceImpl implements UserService {
    
    @Override
    public User findById(Long id) {
        System.out.println("查询用户：" + id);
        return new User(id, "张三");
    }
    
    @Override
    public void saveUser(User user) {
        System.out.println("保存用户：" + user.getName());
    }
    
    @Override
    public void updateUser(User user) {
        System.out.println("更新用户：" + user.getName());
    }
    
    @Override
    public void deleteUser(Long id) {
        System.out.println("删除用户：" + id);
    }
}
```

### 7.3 切面类


**日志切面**：

```java
public class LogAspect {
    
    // 前置通知：记录方法调用
    public void beforeLog(JoinPoint jp) {
        String methodName = jp.getSignature().getName();
        Object[] args = jp.getArgs();
        System.out.println("[日志] 调用方法：" + methodName + 
                          "，参数：" + Arrays.toString(args));
    }
    
    // 返回通知：记录返回值
    public void afterReturning(Object result) {
        System.out.println("[日志] 返回结果：" + result);
    }
    
    // 环绕通知：统计执行时间
    public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = pjp.proceed();
        long end = System.currentTimeMillis();
        System.out.println("[日志] 执行耗时：" + (end - start) + "ms");
        return result;
    }
}
```

**事务切面**：

```java
public class TransactionAspect {
    
    public Object transactionManage(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("[事务] 开启事务");
        try {
            Object result = pjp.proceed();
            System.out.println("[事务] 提交事务");
            return result;
        } catch (Exception e) {
            System.out.println("[事务] 回滚事务");
            throw e;
        }
    }
}
```

### 7.4 完整XML配置


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 1. 注册业务Bean -->
    <bean id="userService" class="com.example.service.UserServiceImpl"/>

    <!-- 2. 注册切面Bean -->
    <bean id="logAspect" class="com.example.aspect.LogAspect"/>
    <bean id="txAspect" class="com.example.aspect.TransactionAspect"/>

    <!-- 3. AOP配置 -->
    <aop:config>
        <!-- 定义全局切入点 -->
        <aop:pointcut id="serviceMethods" 
            expression="execution(* com.example.service.*.*(..))"/>
        
        <aop:pointcut id="modifyMethods" 
            expression="execution(* com.example.service.*ServiceImpl.save*(..)) 
                        or execution(* com.example.service.*ServiceImpl.update*(..))
                        or execution(* com.example.service.*ServiceImpl.delete*(..))"/>

        <!-- 日志切面 -->
        <aop:aspect ref="logAspect" order="2">
            <aop:before method="beforeLog" pointcut-ref="serviceMethods"/>
            <aop:after-returning method="afterReturning" 
                                 pointcut-ref="serviceMethods" 
                                 returning="result"/>
            <aop:around method="aroundLog" pointcut-ref="serviceMethods"/>
        </aop:aspect>

        <!-- 事务切面（优先级更高） -->
        <aop:aspect ref="txAspect" order="1">
            <aop:around method="transactionManage" pointcut-ref="modifyMethods"/>
        </aop:aspect>
    </aop:config>

</beans>
```

### 7.5 测试运行


**测试代码**：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext context = 
            new ClassPathXmlApplicationContext("applicationContext.xml");
        
        UserService userService = context.getBean(UserService.class);
        
        // 测试查询（只有日志，没有事务）
        System.out.println("===== 测试查询 =====");
        userService.findById(1L);
        
        System.out.println("\n===== 测试保存 =====");
        userService.saveUser(new User(2L, "李四"));
    }
}
```

**输出结果**：

```
===== 测试查询 =====
[日志] 调用方法：findById，参数：[1]
查询用户：1
[日志] 返回结果：User(id=1, name=张三)
[日志] 执行耗时：5ms

===== 测试保存 =====
[事务] 开启事务
[日志] 调用方法：saveUser，参数：[User(id=2, name=李四)]
保存用户：李四
[事务] 提交事务
[日志] 返回结果：null
[日志] 执行耗时：3ms
```

**🔍 执行顺序分析**：

```
保存方法执行流程：

1. [事务切面-环绕开始] order=1优先
    ↓
2. [日志切面-前置通知]
    ↓
3. [日志切面-环绕开始]
    ↓
4. [目标方法执行]
    ↓
5. [日志切面-环绕结束]
    ↓
6. [日志切面-返回通知]
    ↓
7. [事务切面-环绕结束]
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


> **🎯 XML配置AOP的本质**
> 
> 通过XML文件告诉Spring：
> 1. 哪个类是切面（`<aop:aspect>`）
> 2. 在哪些方法上应用（`<aop:pointcut>`）
> 3. 什么时候执行切面方法（通知类型）

**🔸 核心配置元素**：

```
<aop:config>                    根配置
├─ <aop:pointcut>              切入点（全局）
├─ <aop:aspect>                切面
│  ├─ <aop:pointcut>           切入点（局部）
│  ├─ <aop:before>             前置通知
│  ├─ <aop:after>              后置通知
│  ├─ <aop:after-returning>    返回通知
│  ├─ <aop:after-throwing>     异常通知
│  └─ <aop:around>             环绕通知
└─ <aop:advisor>               顾问
```

### 8.2 关键理解要点


**🔹 切入点表达式记忆**：

```
execution(返回类型 包名.类名.方法名(参数))

常用模式：
• execution(* com.example.service.*.*(..))
  ↑     ↑            ↑         ↑  ↑  ↑
  任意  任意         service  任意 任意
  返回  包下         包      类  方法 参数
```

**🔹 通知类型选择**：

| 需求 | 选择通知 | 理由 |
|------|----------|------|
| 参数校验 | `before` | 方法执行前检查 |
| 资源释放 | `after` | 无论成功失败都执行 |
| 结果缓存 | `after-returning` | 只缓存成功的结果 |
| 异常记录 | `after-throwing` | 只记录异常情况 |
| 事务管理 | `around` | 需要控制执行流程 |

**🔹 Aspect vs Advisor**：

```
使用Aspect：
✅ 一个切面多个通知
✅ 灵活的切入点配置
✅ 方法不需要实现接口

使用Advisor：
✅ 通知和切入点一对一
✅ 使用Spring内置接口
✅ 更精确的控制
```

### 8.3 实际应用价值


**💼 典型应用场景**：

- **日志记录**：记录所有service方法的调用和返回
- **性能监控**：统计关键方法的执行时间
- **事务管理**：为增删改方法自动添加事务
- **权限控制**：检查用户是否有权限调用方法
- **缓存管理**：自动缓存查询结果

**🔧 配置建议**：

```
新项目：
→ 优先使用注解配置（@Aspect）
→ 配置简单，开发效率高

老项目：
→ 使用XML配置
→ 不侵入原有代码

混合使用：
→ 核心切面用注解
→ 动态配置用XML
```

**📚 学习路径**：

```
学习进度：
[████████░░] 80%

✅ 已掌握：XML配置基础
✅ 已掌握：切入点表达式
✅ 已掌握：五种通知类型
🔄 进行中：复杂场景实战
⏭️ 下一步：注解配置方式
```

**核心记忆口诀**：
```
XML配置AOP不难记，
config里面写配置。
aspect切面ref引用，
pointcut定义切入点。
五种通知各有用，
advisor简单一对一。
表达式里星号多，
两点代表任意数。
```