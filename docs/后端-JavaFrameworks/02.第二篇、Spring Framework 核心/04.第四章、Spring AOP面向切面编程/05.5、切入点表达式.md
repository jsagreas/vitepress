---
title: 5、切入点表达式
---
## 📚 目录


1. [切入点表达式基础概念](#1-切入点表达式基础概念)
2. [execution表达式详解](#2-execution表达式详解)
3. [within范围限定](#3-within范围限定)
4. [this代理对象匹配](#4-this代理对象匹配)
5. [target目标对象匹配](#5-target目标对象匹配)
6. [args参数匹配](#6-args参数匹配)
7. [@annotation注解匹配](#7-annotation注解匹配)
8. [组合表达式与最佳实践](#8-组合表达式与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

# 🎯 **学习导航**


**前置知识**：需要了解Spring AOP基本概念、切面编程思想 → **当前内容**：切入点表达式 → **后续学习**：建议学习通知类型、AOP实战应用

⏱️ **预计学习时间**：本章预计45分钟 | 实践练习30分钟

---

## 1. 🎯 切入点表达式基础概念



### 1.1 什么是切入点表达式



**🔸 核心定义**
切入点表达式（Pointcut Expression）：告诉Spring在哪些方法上应用切面逻辑的"筛选条件"

**💡 生活化理解**
```
想象你是一个交通警察：
- 切入点表达式 = 执勤规则
- "所有闯红灯的车" = 匹配规则
- 具体的违章车辆 = 被匹配到的方法

切入点表达式就是定义"哪些方法需要被拦截"的规则
```

### 1.2 切入点表达式的作用



**🎯 主要用途**
```
精确控制切面生效范围：
✅ 指定哪些类的方法需要增强
✅ 限定方法的访问权限（public/private）
✅ 匹配特定的方法参数
✅ 根据注解筛选方法
✅ 组合多个条件进行复杂匹配
```

### 1.3 切入点表达式类型速览



| **表达式类型** | **匹配依据** | **使用场景** | **常用程度** |
|---------------|------------|-------------|-------------|
| **execution** | 方法签名 | 通用场景，最常用 | ⭐⭐⭐⭐⭐ |
| **within** | 类或包 | 批量匹配某个包下的类 | ⭐⭐⭐⭐ |
| **this** | 代理对象类型 | 区分JDK/CGLIB代理 | ⭐⭐⭐ |
| **target** | 目标对象类型 | 匹配实际业务类 | ⭐⭐⭐ |
| **args** | 方法参数 | 根据参数类型匹配 | ⭐⭐⭐ |
| **@annotation** | 方法注解 | 统一处理标注注解的方法 | ⭐⭐⭐⭐ |

---

## 2. 🔍 execution表达式详解



### 2.1 execution表达式基本语法



**📋 完整语法格式**
```
execution(修饰符? 返回值类型 包名.类名?.方法名(参数) 异常?)

说明：
? 表示可选部分
* 表示任意
.. 表示多个或任意
```

**🔑 语法拆解理解**
```
execution(public * com.example.service.*.*(..))
         ↓      ↓ ↓                    ↓  ↓
         │      │ │                    │  │
      修饰符  返回值 包路径              方法 参数
```

### 2.2 通配符详细说明



**⭐ 常用通配符含义**

| **通配符** | **含义** | **使用示例** |
|-----------|---------|-------------|
| `*` | 匹配任意单个元素 | `*Service` 匹配XxxService |
| `..` | 匹配任意多个元素 | `com.example..` 匹配该包及子包 |
| `+` | 匹配指定类及其子类 | `UserService+` 包含子类 |

**💡 通配符实例对比**
```java
// 示例1：匹配service包下所有类的所有方法
execution(* com.example.service.*.*(..))

// 示例2：匹配service包及子包下所有类的所有方法  
execution(* com.example.service..*.*(..))

// 示例3：匹配所有以Service结尾的类的所有方法
execution(* com.example..*Service.*(..))
```

### 2.3 execution表达式实战案例



**🎯 案例1：匹配特定方法**
```java
// 需求：只在saveUser方法上应用切面
@Pointcut("execution(* com.example.service.UserService.saveUser(..))")
public void saveUserMethod() {}

// 解读：
// * - 任意返回值类型
// com.example.service.UserService - 指定类
// saveUser - 指定方法名
// (..) - 任意参数
```

**🎯 案例2：匹配指定返回值类型**
```java
// 需求：匹配所有返回User对象的方法
@Pointcut("execution(com.example.entity.User com.example.service.*.*(..))")
public void returnUserMethods() {}

// 解读：明确指定返回值类型为User
// 第一个* - service包下的任意类
// 第二个* - 类中的任意方法
```

**🎯 案例3：匹配特定参数**
```java
// 需求：匹配所有参数为(String, int)的方法
@Pointcut("execution(* com.example..*.*(String, int))")
public void twoParamMethods() {}

// 需求：匹配第一个参数是String的方法
@Pointcut("execution(* com.example..*.*(String, ..))")
public void firstParamStringMethods() {}
```

### 2.4 常见execution模式



**📝 实用模式速查**

```java
// 模式1：匹配service层所有方法
execution(* com.example.service.*.*(..))

// 模式2：匹配以save/update/delete开头的方法
execution(* com.example.service.*.(save*|update*|delete*)(..))

// 模式3：匹配所有公开方法
execution(public * com.example..*.*(..))

// 模式4：匹配指定包及子包的所有方法
execution(* com.example.service..*.*(..))

// 模式5：匹配返回List的所有方法
execution(java.util.List com.example..*.*(..))
```

---

## 3. 📦 within范围限定



### 3.1 within表达式基本用法



**🔸 核心概念**
within表达式：按照类或包的粒度来匹配切入点，比execution更简洁

**💡 对比理解**
```
execution - 细粒度，精确到方法
within    - 粗粒度，精确到类或包

类比：
execution像点菜 - 精确到每道菜
within像套餐 - 整个分类一起选
```

### 3.2 within实战示例



**🎯 按类匹配**
```java
// 需求：匹配UserService类的所有方法
@Pointcut("within(com.example.service.UserService)")
public void userServiceMethods() {}

// 等价于execution写法：
// execution(* com.example.service.UserService.*(..))
```

**🎯 按包匹配**
```java
// 需求：匹配service包下所有类的所有方法
@Pointcut("within(com.example.service.*)")
public void servicePackage() {}

// 需求：匹配service包及子包下所有类
@Pointcut("within(com.example.service..*)")
public void servicePackageAndSubPackage() {}
```

**🎯 匹配实现接口的类**
```java
// 需求：匹配所有实现BaseService接口的类
@Pointcut("within(com.example.service.BaseService+)")
public void baseServiceImpl() {}

// + 表示匹配该类型及其所有子类
```

### 3.3 within与execution对比



| **对比维度** | **within** | **execution** |
|-------------|-----------|--------------|
| **匹配粒度** | 类或包级别 | 方法级别 |
| **灵活性** | 较低 | 很高 |
| **性能** | 较好 | 稍差 |
| **适用场景** | 批量匹配整个类 | 精确匹配特定方法 |

**💡 选择建议**
```
使用within的场景：
✅ 需要对整个类的所有方法应用切面
✅ 需要对某个包下所有类应用切面
✅ 追求简洁的表达式

使用execution的场景：
✅ 需要精确匹配特定方法
✅ 需要根据参数或返回值过滤
✅ 需要复杂的匹配条件
```

---

## 4. 🎭 this代理对象匹配



### 4.1 this表达式核心概念



**🔸 基础理解**
this表达式：匹配的是Spring AOP生成的**代理对象**的类型

**💡 代理对象理解**
```
Spring AOP的工作原理：
原始对象(Target) → Spring包装 → 代理对象(Proxy)
                               ↑
                          this指的就是它
调用流程：
客户端 → 代理对象 → 切面逻辑 → 目标对象
```

### 4.2 JDK代理与CGLIB代理



**🔍 两种代理方式对比**

```
JDK动态代理：
接口 UserService
  ↓ 实现
类 UserServiceImpl
  ↓ Spring代理
代理类 $Proxy0 (实现UserService接口)

CGLIB代理：
类 UserServiceImpl
  ↓ Spring代理  
代理类 UserServiceImpl$$EnhancerBySpringCGLIB (继承UserServiceImpl)
```

| **代理方式** | **前提条件** | **代理对象类型** | **this匹配** |
|-------------|------------|----------------|-------------|
| **JDK代理** | 目标类实现接口 | 接口类型 | 匹配接口 |
| **CGLIB代理** | 目标类没有接口 | 子类类型 | 匹配实现类 |

### 4.3 this表达式实战



**🎯 案例1：匹配JDK代理**
```java
// UserService接口
public interface UserService {
    void saveUser();
}

// 实现类
@Service
public class UserServiceImpl implements UserService {
    public void saveUser() { }
}

// 切面配置
@Pointcut("this(com.example.service.UserService)")
public void proxyIsInterface() {}
// ✅ 匹配成功（JDK代理，代理对象实现了UserService接口）

@Pointcut("this(com.example.service.UserServiceImpl)")  
public void proxyIsImpl() {}
// ❌ 匹配失败（代理对象不是UserServiceImpl类型）
```

**🎯 案例2：匹配CGLIB代理**
```java
// 没有接口的类
@Service
public class OrderService {
    public void createOrder() { }
}

// 切面配置
@Pointcut("this(com.example.service.OrderService)")
public void cglibProxy() {}
// ✅ 匹配成功（CGLIB代理，代理对象是OrderService的子类）
```

### 4.4 使用建议



**⚠️ 注意事项**
```
this表达式使用场景：
✅ 需要区分JDK代理和CGLIB代理时
✅ 需要匹配特定代理类型时

不推荐场景：
❌ 不关心代理类型，只关心目标对象（用target）
❌ 只需匹配方法签名（用execution）
```

---

## 5. 🎯 target目标对象匹配



### 5.1 target表达式核心概念



**🔸 基础定义**
target表达式：匹配的是被代理的**原始目标对象**的类型

**💡 this与target对比**
```
this   - 看代理对象的"外表"
target - 看目标对象的"内在"

示意图：
        代理对象           目标对象
       (this匹配)        (target匹配)
          [代理]    →      [实现类]
            ↓                 ↓
       可能是接口        一定是具体类
```

### 5.2 target表达式实战



**🎯 案例1：匹配目标对象类型**
```java
// 接口
public interface UserService {
    void saveUser();
}

// 实现类
@Service
public class UserServiceImpl implements UserService {
    public void saveUser() { }
}

// 切面配置
@Pointcut("target(com.example.service.UserServiceImpl)")
public void targetIsImpl() {}
// ✅ 匹配成功（目标对象就是UserServiceImpl）

@Pointcut("target(com.example.service.UserService)")
public void targetIsInterface() {}
// ❌ 匹配失败（UserService是接口，不是具体类）
```

**🎯 案例2：匹配继承关系**
```java
// 基类
public class BaseService {
    public void commonMethod() { }
}

// 子类
@Service
public class UserService extends BaseService {
    public void saveUser() { }
}

// 切面配置
@Pointcut("target(com.example.service.BaseService+)")
public void targetBaseService() {}
// ✅ 匹配成功（UserService是BaseService的子类）
```

### 5.3 this与target选择指南



**📊 选择决策表**

| **需求场景** | **使用建议** |
|-------------|------------|
| 匹配接口类型 | 用`this` |
| 匹配实现类 | 用`target` |
| 不关心代理方式 | 用`target` |
| 区分代理类型 | 用`this` |
| 匹配继承体系 | 用`target` |

**💡 实用建议**
```
推荐使用target的场景（更常见）：
✅ 大部分业务场景不需要关心代理类型
✅ target匹配目标对象，语义更清晰
✅ 对JDK代理和CGLIB代理都生效

使用this的特殊场景：
✅ 需要明确区分代理方式
✅ 针对接口编程，只匹配接口类型
```

---

## 6. 📝 args参数匹配



### 6.1 args表达式基本用法



**🔸 核心概念**
args表达式：根据方法的**运行时参数类型**进行匹配

**💡 execution参数 vs args参数**
```
execution(* *.*(String, int))
- 编译时匹配
- 必须精确匹配参数类型
- 不支持运行时类型判断

args(String, int)  
- 运行时匹配
- 支持参数类型继承关系
- 可以捕获参数值
```

### 6.2 args表达式实战



**🎯 案例1：基本参数匹配**
```java
// 需求：匹配参数为(String, Integer)的方法
@Pointcut("args(String, Integer)")
public void stringAndIntArgs() {}

// 匹配示例
public void saveUser(String name, Integer age) { }  // ✅ 匹配
public void updateUser(String id, Integer status) { }  // ✅ 匹配
public void deleteUser(String id, int code) { }  // ❌ 不匹配(int≠Integer)
```

**🎯 案例2：通配符参数匹配**
```java
// 需求：匹配第一个参数是String的所有方法
@Pointcut("args(String, ..)")
public void firstArgString() {}

// 需求：匹配至少有一个参数的方法
@Pointcut("args(.., *)")
public void atLeastOneArg() {}

// 需求：匹配最后一个参数是Long的方法
@Pointcut("args(.., Long)")
public void lastArgLong() {}
```

**🎯 案例3：参数值捕获**
```java
// 需求：获取方法的参数值进行处理
@Pointcut("args(username, ..)")
public void withUsername(String username) {}

@Before("withUsername(username)")
public void logUsername(String username) {
    System.out.println("操作用户: " + username);
}

// 调用方法时
userService.saveUser("张三", 25);  
// 输出: 操作用户: 张三
```

### 6.3 参数类型继承匹配



**🔍 继承关系匹配示例**
```java
// 父类
class BaseEntity { }

// 子类
class User extends BaseEntity { }

// 切面配置
@Pointcut("args(com.example.entity.BaseEntity)")
public void baseEntityArg() {}

// 方法调用
public void save(User user) { }  
// ✅ 匹配成功（User是BaseEntity的子类）

public void save(BaseEntity entity) { }  
// ✅ 匹配成功（精确匹配）
```

**💡 args使用建议**
```
适合使用args的场景：
✅ 需要根据运行时参数类型匹配
✅ 需要捕获参数值进行处理
✅ 参数有继承关系需要统一处理

不适合的场景：
❌ 简单的参数类型匹配（用execution更高效）
❌ 参数类型不确定（性能影响）
```

---

## 7. 🏷️ @annotation注解匹配



### 7.1 @annotation表达式核心概念



**🔸 基础定义**
@annotation表达式：匹配标注了**指定注解**的方法

**💡 注解驱动理解**
```
传统方式：在切面中写匹配规则
注解方式：在方法上打标签

类比：
传统 = 门卫看名单拦人
注解 = 看胸牌放行

优势：更灵活，无需修改切面配置
```

### 7.2 自定义注解与切面



**🎯 完整实战示例**

**步骤1：定义自定义注解**
```java
@Target(ElementType.METHOD)  // 只能用在方法上
@Retention(RetentionPolicy.RUNTIME)  // 运行时有效
public @interface OperationLog {
    String value() default "";  // 操作描述
    String type() default "其他";  // 操作类型
}
```

**步骤2：配置切面**
```java
@Aspect
@Component
public class OperationLogAspect {
    
    // 匹配所有标注了@OperationLog的方法
    @Pointcut("@annotation(com.example.annotation.OperationLog)")
    public void logPointcut() {}
    
    @Around("logPointcut()")
    public Object recordLog(ProceedingJoinPoint pjp) throws Throwable {
        // 获取方法上的注解
        MethodSignature signature = (MethodSignature) pjp.getSignature();
        Method method = signature.getMethod();
        OperationLog log = method.getAnnotation(OperationLog.class);
        
        System.out.println("操作描述: " + log.value());
        System.out.println("操作类型: " + log.type());
        
        return pjp.proceed();
    }
}
```

**步骤3：在业务方法上使用**
```java
@Service
public class UserService {
    
    @OperationLog(value = "新增用户", type = "添加")
    public void saveUser(User user) {
        // 业务逻辑
    }
    
    @OperationLog(value = "删除用户", type = "删除")
    public void deleteUser(Long id) {
        // 业务逻辑
    }
    
    // 没有注解的方法不会被拦截
    public void queryUser(Long id) {
        // 业务逻辑
    }
}
```

### 7.3 注解参数提取



**🔧 获取注解参数的两种方式**

**方式1：在切入点直接绑定**
```java
@Pointcut("@annotation(operationLog)")
public void logPointcut(OperationLog operationLog) {}

@Around("logPointcut(operationLog)")
public Object recordLog(ProceedingJoinPoint pjp, OperationLog operationLog) {
    // 直接使用注解对象
    System.out.println("操作: " + operationLog.value());
    return pjp.proceed();
}
```

**方式2：通过反射获取**
```java
@Around("@annotation(com.example.annotation.OperationLog)")
public Object recordLog(ProceedingJoinPoint pjp) throws Throwable {
    MethodSignature signature = (MethodSignature) pjp.getSignature();
    OperationLog log = signature.getMethod()
                                .getAnnotation(OperationLog.class);
    // 使用注解
    return pjp.proceed();
}
```

### 7.4 注解匹配实战场景



**📋 常见应用场景**

```java
// 场景1：权限校验
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String value();  // 所需权限
}

@Before("@annotation(permission)")
public void checkPermission(RequirePermission permission) {
    // 检查用户是否有该权限
}

// 场景2：接口限流
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    int limit() default 100;  // 每秒限制次数
}

@Before("@annotation(rateLimit)")
public void limitRate(RateLimit rateLimit) {
    // 实现限流逻辑
}

// 场景3：缓存处理
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Cacheable {
    String key();
    int expire() default 3600;
}

@Around("@annotation(cacheable)")
public Object handleCache(ProceedingJoinPoint pjp, Cacheable cacheable) {
    // 缓存逻辑
}
```

**💡 注解匹配优势**
```
为什么推荐使用@annotation：
✅ 声明式编程，代码更清晰
✅ 无需修改切面配置，扩展性好
✅ 可以携带参数，更灵活
✅ IDE友好，易于查找使用位置

注意事项：
⚠️ 注解的保留策略必须是RUNTIME
⚠️ 注意注解的作用范围（METHOD/TYPE）
⚠️ 避免注解滥用，保持代码简洁
```

---

## 8. 🔗 组合表达式与最佳实践



### 8.1 逻辑运算符



**🔸 表达式组合方式**

| **运算符** | **含义** | **使用示例** |
|-----------|---------|-------------|
| `&&` | 与（同时满足） | `execution(..) && within(..)` |
| `||` | 或（满足之一） | `@annotation(A) || @annotation(B)` |
| `!` | 非（取反） | `!within(com.example.test..)` |

### 8.2 组合表达式实战



**🎯 案例1：精确控制范围**
```java
// 需求：匹配service包下所有public方法，但排除test包
@Pointcut("execution(public * com.example.service..*.*(..)) " +
          "&& !within(com.example.service.test..*)")
public void serviceExcludeTest() {}
```

**🎯 案例2：多条件匹配**
```java
// 需求：匹配标注了@Log或@Monitor注解的方法
@Pointcut("@annotation(com.example.annotation.Log) || " +
          "@annotation(com.example.annotation.Monitor)")
public void logOrMonitor() {}

// 需求：匹配UserService中标注了@Transactional的方法
@Pointcut("within(com.example.service.UserService) && " +
          "@annotation(org.springframework.transaction.annotation.Transactional)")
public void userServiceTransactional() {}
```

**🎯 案例3：参数与类型组合**
```java
// 需求：匹配service层中第一个参数是Long的所有方法
@Pointcut("within(com.example.service..*) && args(Long, ..)")
public void serviceWithLongId() {}

// 需求：匹配返回User对象且在service包下的方法
@Pointcut("execution(com.example.entity.User com.example.service..*.*(..))")
public void serviceReturnUser() {}
```

### 8.3 切入点复用



**📝 定义可复用的切入点**
```java
@Aspect
@Component
public class CommonPointcuts {
    
    // 定义通用的service层切入点
    @Pointcut("within(com.example.service..*)")
    public void inServiceLayer() {}
    
    // 定义通用的controller层切入点
    @Pointcut("within(com.example.controller..*)")
    public void inControllerLayer() {}
    
    // 定义公开方法切入点
    @Pointcut("execution(public * *(..))")
    public void publicMethod() {}
    
    // 定义标注@Transactional的切入点
    @Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
    public void transactionalMethod() {}
}

// 在其他切面中复用
@Aspect
@Component
public class LogAspect {
    
    @Before("com.example.aspect.CommonPointcuts.inServiceLayer() && " +
            "com.example.aspect.CommonPointcuts.publicMethod()")
    public void logServicePublicMethod() {
        // 日志逻辑
    }
}
```

### 8.4 最佳实践建议



**📋 表达式编写规范**

```java
// ✅ 好的做法
@Pointcut("execution(* com.example.service..*.*(..))")  // 清晰明确
public void serviceLayer() {}

@Pointcut("@annotation(com.example.annotation.Log)")  // 语义化
public void logMethod() {}

// ❌ 不好的做法
@Pointcut("execution(* *(..))")  // 过于宽泛，影响性能
public void allMethods() {}

@Pointcut("execution(* com..*..*Service.*(..))")  // 太复杂，难维护
public void complexPattern() {}
```

**🎯 性能优化建议**

```
表达式性能优先级（从快到慢）：
1. execution - 编译时确定，最快
2. within - 类级别匹配，较快
3. this/target - 运行时类型检查，中等
4. args - 运行时参数检查，较慢
5. @annotation - 反射获取注解，较慢

优化策略：
✅ 优先使用execution或within
✅ 用&&缩小匹配范围
✅ 避免过度使用通配符
✅ 复杂表达式提取为独立切入点
```

**📝 编码建议清单**

- [ ] 表达式尽可能精确，避免误匹配
- [ ] 使用有意义的切入点方法名
- [ ] 复杂表达式拆分为多个简单切入点组合
- [ ] 统一定义通用切入点便于复用
- [ ] 添加注释说明切入点的用途
- [ ] 定期review切入点配置，移除无用的

---

## 9. 📋 核心要点总结



### 9.1 必须掌握的核心概念



```
🔸 切入点表达式：定义在哪些方法上应用切面逻辑的规则
🔸 execution：最常用，按方法签名匹配
🔸 within：按类或包匹配，批量处理
🔸 this：匹配代理对象类型
🔸 target：匹配目标对象类型
🔸 args：匹配运行时参数类型
🔸 @annotation：匹配标注特定注解的方法
```

### 9.2 表达式选择速查表



| **使用场景** | **推荐表达式** | **示例** |
|-------------|--------------|---------|
| 匹配特定方法 | `execution` | `execution(* saveUser(..))` |
| 匹配整个包 | `within` | `within(com.example.service..*)` |
| 按注解匹配 | `@annotation` | `@annotation(Log)` |
| 获取参数值 | `args` | `args(userId, ..)` |
| 匹配接口实现 | `target` | `target(BaseService+)` |

### 9.3 关键理解要点



**🔹 execution最全能但要精确**
```
优势：
- 可以匹配方法的各个维度
- 支持通配符灵活匹配
- 性能好，编译时确定

注意：
- 表达式不要写太宽泛
- 注意包路径的..和*区别  
- 参数匹配要考虑精确类型
```

**🔹 @annotation最灵活推荐使用**
```
为什么推荐：
- 声明式，代码清晰
- 扩展方便，无需改切面
- 可携带参数

使用建议：
- 定义语义化的注解
- 注解保留策略设为RUNTIME
- 合理设计注解参数
```

**🔹 this与target容易混淆**
```
记忆方法：
this   - 代理对象的"马甲"（可能是接口）
target - 目标对象的"真身"（一定是类）

使用原则：
- 不确定用哪个就用target
- 需要区分代理类型才用this
```

### 9.4 实战应用建议



**🎯 日常开发场景**

```java
// 场景1：service层统一日志
@Pointcut("execution(* com.example.service..*.*(..))")
public void serviceLog() {}

// 场景2：controller层统一异常处理
@Pointcut("within(com.example.controller..*)")  
public void controllerException() {}

// 场景3：权限校验
@Pointcut("@annotation(com.example.annotation.RequireAuth)")
public void authCheck() {}

// 场景4：性能监控
@Pointcut("execution(* com.example..*Service.*(..)) && " +
          "@annotation(org.springframework.transaction.annotation.Transactional)")
public void performanceMonitor() {}
```

**🛠️ 调试技巧**

```
切入点不生效排查步骤：

1. 检查包路径是否正确
   - 注意..和*的区别
   - 检查是否有拼写错误

2. 确认方法是否被代理
   - @Transactional等可能产生代理
   - 检查是否配置了@EnableAspectJAutoProxy

3. 验证表达式语法
   - 使用execution先简化测试
   - 逐步添加条件缩小范围

4. 查看Spring日志
   - 开启debug日志查看匹配信息
   - logging.level.org.springframework.aop=DEBUG
```

**🔑 核心记忆口诀**
> execution最全能，方法签名它能行  
> within按包匹配快，整批处理真方便  
> annotation最灵活，声明式编程好理解  
> args捕获参数值，运行时类型要记清  
> this看代理外表，target看目标内在  
> 组合使用更强大，逻辑运算要会用

**💡 进阶学习建议**
- 深入理解Spring AOP代理原理（JDK vs CGLIB）
- 学习AspectJ完整语法（更强大的切入点表达式）
- 实践编写自定义注解和切面处理器
- 了解Spring AOP性能优化技巧