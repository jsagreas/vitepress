---
title: 5、通配符支持
---
## 📚 目录

1. [通配符基础概念](#1-通配符基础概念)
2. [Ant风格模式详解](#2-Ant风格模式详解)
3. [通配符组合使用](#3-通配符组合使用)
4. [实际应用场景](#4-实际应用场景)
5. [性能优化建议](#5-性能优化建议)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 通配符基础概念


### 1.1 什么是通配符


**通俗理解**：通配符就像"万能钥匙"，可以一次性匹配多个文件或路径。

```
日常生活类比：
❌ 精确找人："请叫张三来"           → 只能找到张三
✅ 通配符找人："请叫所有姓张的来"    → 能找到张三、张四、张五...

文件系统类比：
❌ 精确路径："找到report.txt"        → 只能找到这一个文件
✅ 通配符路径："找到所有.txt文件"     → 能找到所有文本文件
```

**Spring中的作用**：
- 🔸 **批量加载配置文件**：一次性加载多个XML或properties文件
- 🔸 **扫描组件**：自动发现特定包下的所有类
- 🔸 **资源定位**：灵活查找符合条件的资源

### 1.2 为什么需要通配符


**实际问题场景**：

```
场景1：配置文件分散
项目结构：
  config/
    ├── database.xml
    ├── cache.xml
    ├── security.xml
    └── message.xml

❌ 不用通配符：
需要一个个手动加载：
- classpath:config/database.xml
- classpath:config/cache.xml  
- classpath:config/security.xml
- classpath:config/message.xml

✅ 使用通配符：
一行搞定：classpath:config/*.xml
```

**核心优势**：
- ✅ **减少配置代码**：一行代替多行
- ✅ **动态扩展**：新增文件自动被识别
- ✅ **维护简单**：不需要每次修改配置列表

---

## 2. 🔧 Ant风格模式详解


### 2.1 Ant模式是什么


**简单解释**：Ant模式是一套文件路径匹配规则，来源于Apache Ant构建工具。

**三大核心通配符**：

```
通配符对照表：
┌──────────┬────────────────┬──────────────────┐
│ 通配符   │ 含义           │ 匹配范围         │
├──────────┼────────────────┼──────────────────┤
│ *        │ 单级通配       │ 一个目录层级     │
│ **       │ 递归通配       │ 任意多层目录     │
│ ?        │ 单字符匹配     │ 恰好一个字符     │
└──────────┴────────────────┴──────────────────┘
```

### 2.2 `*` 单级通配符


**作用**：匹配**一个**目录层级中的**任意内容**。

**实例讲解**：

```
模式：classpath:config/*.xml

目录结构：
config/
  ├── app.xml          ✅ 匹配（同一层级）
  ├── db.xml           ✅ 匹配（同一层级）
  └── sub/
      └── other.xml    ❌ 不匹配（在子目录中）

理解要点：
* 只看当前目录层级
* 不会递归进入子目录
* 可以匹配任意长度的文件名
```

**常见使用场景**：

```java
// 场景1：加载同一目录下所有配置
"classpath:config/*.xml"           // config目录下所有xml
"classpath:properties/*.properties" // properties目录下所有配置

// 场景2：匹配特定前缀或后缀
"classpath:beans/user-*.xml"       // user-开头的xml文件
"classpath:dao/*Mapper.xml"        // Mapper结尾的xml文件
```

### 2.3 `**` 递归通配符


**作用**：匹配**任意多层**目录结构。

**实例讲解**：

```
模式：classpath:com/**/dao/*.xml

目录结构：
com/
  ├── project/
  │   └── dao/
  │       └── UserDao.xml      ✅ 匹配（2层目录）
  ├── module/
  │   ├── sub/
  │   │   └── dao/
  │   │       └── OrderDao.xml ✅ 匹配（3层目录）
  │   └── dao/
  │       └── ProductDao.xml   ✅ 匹配（2层目录）
  └── dao/
      └── BaseDao.xml          ✅ 匹配（1层目录）

理解要点：
** 会递归匹配所有层级
不管中间有多少层目录
只要最终路径符合模式就匹配
```

**重要提醒**：
> ⚠️ **性能注意**：`**` 会扫描所有子目录，路径越深性能开销越大

**实际应用**：

```java
// 场景1：扫描所有Mapper文件（不管在哪个包）
"classpath*:com/**/mapper/*Mapper.xml"

// 场景2：加载所有模块的配置文件
"classpath*:modules/**/config/*.xml"

// 场景3：扫描所有测试资源
"classpath:test/**/*.properties"
```

### 2.4 `?` 单字符匹配符


**作用**：精确匹配**恰好一个**字符。

**实例讲解**：

```
模式：classpath:config/app-?.xml

文件匹配情况：
app-1.xml    ✅ 匹配（恰好1个字符）
app-2.xml    ✅ 匹配（恰好1个字符）
app-a.xml    ✅ 匹配（恰好1个字符）
app-10.xml   ❌ 不匹配（2个字符）
app-.xml     ❌ 不匹配（0个字符）

多个?组合：
模式：config/log-????.xml
匹配：log-2024.xml  ✅（恰好4个字符）
匹配：log-info.xml  ✅（恰好4个字符）
不匹配：log-1.xml   ❌（只有1个字符）
```

**实际使用场景**：

```java
// 场景1：环境配置文件（dev/prod/test）
"classpath:application-????.properties"  // 匹配4字符环境名

// 场景2：版本化配置
"classpath:config/v?.xml"                // v1.xml, v2.xml等
```

---

## 3. 🔄 通配符组合使用


### 3.1 多通配符协作


**核心规则**：三种通配符可以**自由组合**使用。

**组合示例解析**：

```
模式1：classpath:com/*/service/**/*Service.xml
分解理解：
  com/          → 固定前缀
  */            → 任意一层目录（如project/、module/）
  service/      → 固定目录名
  **/           → 任意多层子目录
  *Service.xml  → Service结尾的xml文件

匹配路径示例：
✅ com/project/service/UserService.xml
✅ com/project/service/order/OrderService.xml
✅ com/module/service/sub/deep/PayService.xml
❌ com/project/dao/UserDao.xml（不在service目录）
```

**复杂场景示例**：

```
项目结构：
src/main/resources/
  ├── mybatis/
  │   ├── user/
  │   │   ├── UserMapper.xml
  │   │   └── UserDao.xml
  │   └── order/
  │       └── OrderMapper.xml
  └── config/
      └── app-dev.xml

需求1：只要Mapper文件
模式：classpath:mybatis/**/*Mapper.xml
结果：✅ UserMapper.xml, OrderMapper.xml
     ❌ UserDao.xml（不是Mapper结尾）

需求2：user目录下所有xml
模式：classpath:mybatis/user/*.xml
结果：✅ UserMapper.xml, UserDao.xml

需求3：所有环境配置文件
模式：classpath:config/app-*.xml
结果：✅ app-dev.xml（如果有app-prod.xml也会匹配）
```

### 3.2 classpath vs classpath*


**关键区别**：

```
对照表：
┌─────────────┬──────────────────┬────────────────┐
│ 前缀        │ 扫描范围         │ 使用场景       │
├─────────────┼──────────────────┼────────────────┤
│ classpath:  │ 第一个匹配的资源 │ 单个JAR包      │
│ classpath*: │ 所有匹配的资源   │ 多个JAR包      │
└─────────────┴──────────────────┴────────────────┘
```

**实例对比**：

```
场景：多个JAR包都有相同路径的配置文件

项目依赖：
  app.jar!/config/db.xml          ← JAR1中的配置
  common.jar!/config/db.xml       ← JAR2中的配置

使用 classpath:config/db.xml
结果：只加载 ✅ app.jar中的db.xml
     忽略 ❌ common.jar中的db.xml

使用 classpath*:config/db.xml  
结果：同时加载 ✅ app.jar和common.jar中的db.xml
```

**最佳实践**：
> 💡 **推荐规则**：
> - 确定只有一个资源时 → 用 `classpath:`
> - 需要加载所有匹配资源 → 用 `classpath*:`
> - 扫描多个JAR包 → 必须用 `classpath*:`

---

## 4. 🚀 实际应用场景


### 4.1 配置文件加载


**场景1：分模块配置加载**

```java
@Configuration
@ImportResource({
    "classpath:config/datasource-*.xml",     // 数据源配置
    "classpath:config/cache-*.xml",          // 缓存配置
    "classpath:config/security-*.xml"        // 安全配置
})
public class AppConfig {
    // 一次性加载所有模块配置
}
```

**场景2：环境配置切换**

```java
// 开发环境
@PropertySource("classpath:config/app-dev.properties")

// 生产环境（支持通配符）
@PropertySource("classpath:config/app-prod-*.properties")
// 能匹配：app-prod-db.properties, app-prod-redis.properties等
```

### 4.2 MyBatis Mapper扫描


**传统做法 vs 通配符做法**：

```java
// ❌ 传统方式：逐个配置
@MapperScan(basePackages = {
    "com.example.user.dao",
    "com.example.order.dao",
    "com.example.product.dao"
})

// ✅ 通配符方式：自动扫描
@MapperScan("com.example.*.dao")
// 或者更灵活的mapper文件扫描
SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
factory.setMapperLocations(
    new PathMatchingResourcePatternResolver()
        .getResources("classpath*:com/**/mapper/*Mapper.xml")
);
```

### 4.3 组件扫描


**包扫描示例**：

```java
// 场景1：扫描所有Service层组件
@ComponentScan(basePackages = "com.example.**.service")

// 场景2：排除测试类
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = @Filter(
        type = FilterType.REGEX,
        pattern = "com\\.example\\..*Test"
    )
)
```

### 4.4 静态资源映射


**Web资源配置**：

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 映射所有静态资源
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/");
        
        // 递归映射所有图片
        registry.addResourceHandler("/images/**")
                .addResourceLocations("classpath:/assets/**/images/");
    }
}
```

---

## 5. ⚡ 性能优化建议


### 5.1 性能影响因素


**扫描成本对照**：

```
性能开销排序（从低到高）：
┌─────────────────────────────┬──────────┐
│ 模式类型                    │ 性能开销 │
├─────────────────────────────┼──────────┤
│ classpath:config/app.xml    │ ⭐       │  ← 精确路径，最快
│ classpath:config/*.xml      │ ⭐⭐     │  ← 单层扫描，较快
│ classpath:config/**/*.xml   │ ⭐⭐⭐   │  ← 递归扫描，较慢
│ classpath*:config/**/*.xml  │ ⭐⭐⭐⭐ │  ← 多JAR递归，最慢
└─────────────────────────────┴──────────┘
```

**性能瓶颈分析**：

```
问题场景：
模式：classpath*:com/**/*.xml

扫描过程：
1. 遍历所有JAR包                    ← 耗时点1
2. 在每个JAR中递归扫描com目录       ← 耗时点2
3. 匹配所有.xml文件                 ← 耗时点3

优化前：扫描100个JAR × 递归5层目录 = 可能需要几秒
优化后：限制扫描范围，毫秒级完成
```

### 5.2 优化策略


**策略1：缩小扫描范围**

```java
// ❌ 不推荐：范围太大
"classpath*:**/*.xml"              // 扫描所有JAR的所有xml

// ✅ 推荐：精确指定
"classpath*:com/example/**/*.xml"  // 只扫描特定包
```

**策略2：减少递归层级**

```java
// ❌ 不推荐：无限递归
"classpath:com/**/*Mapper.xml"

// ✅ 推荐：限制层级
"classpath:com/*/mapper/*Mapper.xml"  // 最多2层
```

**策略3：使用精确匹配**

```java
// 场景：已知具体路径时
// ❌ 不必要的通配符
"classpath:config/*.xml"

// ✅ 能精确就精确
"classpath:config/app.xml,classpath:config/db.xml"
```

**策略4：避免classpath*滥用**

```java
// 单一项目中
// ❌ 过度使用
"classpath*:config/*.xml"  // 单项目不需要*

// ✅ 正确使用
"classpath:config/*.xml"   // 单项目用classpath即可

// 多模块项目中
// ✅ 合理使用
"classpath*:*/config/*.xml" // 扫描所有模块的config
```

### 5.3 最佳实践检查清单


```
✅ 性能优化检查清单：

[ ] 1. 能用精确路径就不用通配符
[ ] 2. 能用单级*就不用递归**
[ ] 3. 能用classpath就不用classpath*
[ ] 4. 通配符尽量靠后（如：com/example/*/config/）
[ ] 5. 避免根路径通配（如：**/*.xml）
[ ] 6. 生产环境监控资源加载时间
[ ] 7. 大型项目考虑拆分配置文件
```

---

## 6. 📋 核心要点总结


### 6.1 通配符速记表


```
┌──────┬─────────────┬──────────────────────┐
│ 符号 │ 名称        │ 记忆口诀             │
├──────┼─────────────┼──────────────────────┤
│ *    │ 单级通配    │ 一星只看一层楼       │
│ **   │ 递归通配    │ 双星递归到底层       │
│ ?    │ 单字符匹配  │ 问号恰好一个字       │
└──────┴─────────────┴──────────────────────┘
```

### 6.2 必知必会要点


**🔸 核心概念**：
- Ant模式 = Spring中文件路径匹配的标准规则
- 三大通配符各有分工，不能混淆
- `classpath` vs `classpath*` 决定扫描范围

**🔸 使用原则**：
- **能精确不通配**：性能第一原则
- **能单层不递归**：避免 `**` 滥用
- **能单包不多包**：优先 `classpath` 而非 `classpath*`

**🔸 常见误区**：
- ❌ 误以为 `*` 能匹配多层目录 → 只能匹配一层
- ❌ 忘记 `classpath*` 会扫描所有JAR → 性能隐患
- ❌ 在单项目中用 `classpath*` → 不必要的开销

### 6.3 实战技巧


**技巧1：调试通配符**

```java
// 调试技巧：先测试匹配结果
ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
Resource[] resources = resolver.getResources("classpath*:com/**/mapper/*.xml");

// 打印实际匹配到的文件
for (Resource resource : resources) {
    System.out.println("找到：" + resource.getURL());
}
```

**技巧2：分阶段扫描**

```java
// 启动时分阶段加载配置
// 第1阶段：核心配置（精确路径）
@Import(CoreConfig.class)

// 第2阶段：模块配置（单级通配）
@ImportResource("classpath:modules/*/config.xml")

// 第3阶段：扩展配置（递归通配，可选）
@ImportResource("classpath*:**/extensions/*.xml")
```

**技巧3：性能监控**

```java
// 监控资源加载时间
long start = System.currentTimeMillis();
Resource[] resources = resolver.getResources(pattern);
long time = System.currentTimeMillis() - start;

if (time > 1000) {
    log.warn("资源扫描耗时过长：{}ms，模式：{}", time, pattern);
}
```

### 6.4 记忆口诀


```
🎯 通配符三字经：

一星（*）配一层，文件名随便
双星（**）往下钻，层层都能看  
问号（?）真严格，一个字符卡
路径（classpath）有学问，带星多包扫
性能要优化，精确是王道
```

**核心记忆**：
- `*` = 横向扩展（同层级所有）
- `**` = 纵向深入（所有层级）
- `?` = 精确控制（恰好一个）
- `classpath*:` = 全局搜索（所有JAR）
- 性能优先 = 能不用通配符就不用