---
title: 9、PlatformTransactionManager编程
---
## 📚 目录

1. [什么是编程式事务管理](#1-什么是编程式事务管理)
2. [PlatformTransactionManager核心接口](#2-PlatformTransactionManager核心接口)
3. [TransactionDefinition事务定义](#3-TransactionDefinition事务定义)
4. [TransactionStatus事务状态](#4-TransactionStatus事务状态)
5. [手动事务管理实战](#5-手动事务管理实战)
6. [事务提交与回滚机制](#6-事务提交与回滚机制)
7. [资源管理最佳实践](#7-资源管理最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 什么是编程式事务管理


### 1.1 编程式事务的本质理解


**💡 通俗解释**：
编程式事务管理就像你在银行柜台办业务时，**自己主动**告诉柜员"开始办理"、"确认提交"或"取消操作"。你完全掌控每一个步骤的时机。

```
生活中的例子：
你去银行转账1000元给朋友

传统方式（手动控制）：
1. 告诉柜员"开始转账业务" ← 开始事务
2. 从你账户扣1000元        ← 执行操作1  
3. 向朋友账户加1000元      ← 执行操作2
4. 检查是否都成功了        ← 检查状态
5. 告诉柜员"确认提交"      ← 提交事务
   或者"取消操作"          ← 回滚事务

编程式事务就是这样：你用代码明确地控制每一步
```

### 1.2 与声明式事务的区别对比


| 特征 | **编程式事务** | **声明式事务** |
|------|---------------|---------------|
| 🎮 **控制方式** | `手动编写代码控制` | `注解或配置自动控制` |
| 📝 **代码量** | `较多，需要显式管理` | `极少，一个@Transactional搞定` |
| 🎯 **灵活性** | `非常灵活，精确控制` | `相对固定，适合常见场景` |
| 🐛 **出错风险** | `容易忘记提交或回滚` | `框架自动处理，不易出错` |
| 📊 **适用场景** | `复杂业务逻辑，需要条件控制` | `简单CRUD操作，标准事务` |

### 1.3 为什么需要编程式事务


**🔸 核心使用场景**：
- **条件性事务**：根据业务结果决定是否提交
- **多步骤事务**：需要在事务中间做检查和判断  
- **复杂控制逻辑**：不是简单的"全成功"或"全失败"
- **资源精确控制**：需要手动管理数据库连接等资源

```
实际业务例子：
电商下单流程 - 需要条件判断

1. 开始事务
2. 检查商品库存
3. 如果库存不足 → 直接回滚，不继续执行
4. 如果库存足够 → 继续执行
5. 扣减库存
6. 创建订单  
7. 发送通知
8. 如果通知失败 → 决定是回滚还是提交（业务决定）
9. 提交事务

这种复杂的条件控制，声明式事务很难处理
```

---

## 2. 🏗️ PlatformTransactionManager核心接口


### 2.1 接口的作用和地位


**🔸 核心定义**：
`PlatformTransactionManager`是Spring事务管理的**核心接口**，就像是事务管理的"总指挥"。它定义了事务管理的标准操作。

```
比喻理解：
PlatformTransactionManager = 银行业务的标准流程

不管你去工商银行、建设银行还是农业银行，
办理转账业务的流程都是一样的：
1. 开始业务（getTransaction）
2. 提交业务（commit）  
3. 取消业务（rollback）

不同银行的具体实现可能不同，但流程标准是统一的
```

### 2.2 接口的三个核心方法


```java
public interface PlatformTransactionManager {
    
    // 🚀 开始一个事务，返回事务状态对象
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition);
    
    // ✅ 提交事务，让所有操作生效
    void commit(TransactionStatus status);
    
    // ❌ 回滚事务，取消所有操作
    void rollback(TransactionStatus status);
}
```

**💡 方法详解**：

**getTransaction() - 开始事务**
- **作用**：就像告诉银行"我要开始办业务了"
- **参数**：`TransactionDefinition` - 事务的具体要求（隔离级别、超时时间等）
- **返回**：`TransactionStatus` - 事务的状态信息，后续操作都需要它

**commit() - 提交事务**  
- **作用**：告诉系统"我的操作都完成了，请保存结果"
- **参数**：之前`getTransaction()`返回的状态对象
- **结果**：所有数据库操作正式生效

**rollback() - 回滚事务**
- **作用**：告诉系统"出问题了，请取消我刚才的所有操作"  
- **参数**：之前`getTransaction()`返回的状态对象
- **结果**：所有数据库操作被撤销，恢复到事务开始前的状态

### 2.3 常见的实现类


```
Spring提供了多种PlatformTransactionManager的实现：

📊 DataSourceTransactionManager
   └─ 用于：单个数据源（最常用）
   └─ 场景：普通的MySQL、Oracle等关系型数据库

📊 JtaTransactionManager  
   └─ 用于：分布式事务（跨多个数据源）
   └─ 场景：同时操作多个数据库或消息队列

📊 HibernateTransactionManager
   └─ 用于：Hibernate ORM框架
   └─ 场景：使用Hibernate作为持久层

📊 JpaTransactionManager
   └─ 用于：JPA规范的实现
   └─ 场景：使用Spring Data JPA
```

---

## 3. 📋 TransactionDefinition事务定义


### 3.1 事务定义的作用


**💡 通俗理解**：
`TransactionDefinition`就像是你去银行办业务时填写的"业务申请单"，上面写明了你的具体要求：

```
银行业务申请单 = TransactionDefinition

☑️ 业务类型：转账（对应事务的传播行为）
☑️ 重要程度：普通/加急（对应隔离级别） 
☑️ 办理时长：最多等待30分钟（对应超时设置）
☑️ 是否只查看：否，需要修改账户（对应只读设置）

银行员工根据你的申请单来处理业务
Spring根据TransactionDefinition来管理事务
```

### 3.2 事务传播行为（Propagation）


**🔸 核心概念**：
传播行为决定了当一个事务方法调用另一个事务方法时，事务应该如何处理。

```
生活场景理解：
你去银行办理"转账+理财购买"的组合业务

情况1 - REQUIRED（默认）：
如果已经在办理业务中 → 继续在当前业务中处理
如果还没开始办理 → 新开启一个业务

情况2 - REQUIRES_NEW：
不管怎样都要单独开启一个新业务来处理
就像"VIP通道"，独立处理

情况3 - SUPPORTS：
如果已经在办理业务中 → 跟着一起处理  
如果还没开始办理 → 不需要特殊业务流程
```

| 传播行为 | **含义说明** | **使用场景** |
|---------|-------------|-------------|
| `REQUIRED` | `有事务就加入，没有就新建` | `最常用，适合大多数业务方法` |
| `REQUIRES_NEW` | `总是新建事务，独立执行` | `日志记录、审计操作` |
| `SUPPORTS` | `有事务就支持，没有也行` | `查询操作，对事务要求不高` |
| `NOT_SUPPORTED` | `不使用事务，挂起当前事务` | `发送邮件等外部调用` |
| `NEVER` | `不允许在事务中执行` | `一些特殊的系统操作` |

### 3.3 事务隔离级别（Isolation）


**🔸 核心概念**：
隔离级别控制并发事务之间的影响程度，就像控制银行业务办理时的"隐私程度"。

```
银行业务隐私级别类比：

🔓 READ_UNCOMMITTED（读未提交）
   = 你能看到别人正在办理但还没完成的业务
   = 风险：可能看到错误信息（脏读）

🔒 READ_COMMITTED（读已提交）  
   = 你只能看到别人已经完成的业务
   = 风险：同一时间多次查看，结果可能不同（不可重复读）

🔐 REPEATABLE_READ（可重复读）
   = 你查看业务期间，看到的信息保持一致
   = 风险：可能出现新的记录（幻读）

🔏 SERIALIZABLE（序列化）
   = 所有业务都要排队一个个处理
   = 最安全但最慢
```

### 3.4 其他重要属性


**超时设置（Timeout）**：
```java
// 设置事务最多执行30秒，超时自动回滚
TransactionDefinition def = new DefaultTransactionDefinition();
def.setTimeout(30);
```

**只读事务（ReadOnly）**：
```java
// 标记为只读，数据库可以进行优化
def.setReadOnly(true);
```

---

## 4. 📊 TransactionStatus事务状态


### 4.1 事务状态的作用


**💡 通俗理解**：
`TransactionStatus`就像是银行给你的"业务办理凭证"，上面记录了当前业务的状态信息。

```
银行业务凭证 = TransactionStatus

凭证信息：
📋 业务编号：TX_20241215_001（事务标识）
📅 办理时间：2024-12-15 10:30（事务开始时间）  
📊 当前状态：进行中/已完成/已取消（事务状态）
🎯 是否新业务：是（是否新事务）
💾 保存点：步骤2完成（回滚保存点）

你后续的提交或取消操作都要出示这个凭证
```

### 4.2 核心状态信息


```java
public interface TransactionStatus {
    
    // 🆔 是否是新开启的事务（不是加入已有事务）
    boolean isNewTransaction();
    
    // 💾 是否有保存点（用于部分回滚）
    boolean hasSavepoint();
    
    // 🚫 设置事务为只能回滚状态
    void setRollbackOnly();
    
    // ❓ 检查事务是否被标记为只能回滚
    boolean isRollbackOnly();
    
    // ✅ 事务是否已经完成（提交或回滚）
    boolean isCompleted();
}
```

### 4.3 状态流转图示


```
事务状态生命周期：

开始事务                执行业务逻辑              结束事务
   ↓                       ↓                      ↓
[创建状态] → [活跃状态] → [准备提交] → [已提交]
    ↓           ↓           ↓         
[异常]     [标记回滚]   [回滚操作] → [已回滚]

关键节点说明：
🟢 创建状态：刚调用getTransaction()
🔵 活跃状态：正在执行业务代码
🟡 准备提交：业务代码执行完，准备commit()
🟢 已提交：commit()成功，数据永久保存
🔴 已回滚：rollback()完成，数据恢复原状
```

---

## 5. 🛠️ 手动事务管理实战


### 5.1 基础配置准备


**Spring配置示例**：

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

### 5.2 标准的编程式事务模板


**🔸 基本使用模式**：

```java
@Service
public class UserService {
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    @Autowired  
    private UserDao userDao;
    
    public void transferMoney(Long fromUserId, Long toUserId, BigDecimal amount) {
        
        // 📋 1. 定义事务参数
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        def.setTimeout(30); // 30秒超时
        
        // 🚀 2. 开始事务
        TransactionStatus status = transactionManager.getTransaction(def);
        
        try {
            // 💼 3. 执行业务逻辑
            userDao.deductBalance(fromUserId, amount);  // 扣款
            userDao.addBalance(toUserId, amount);       // 加款
            
            // ✅ 4. 提交事务
            transactionManager.commit(status);
            
        } catch (Exception e) {
            // ❌ 5. 回滚事务
            transactionManager.rollback(status);
            throw e; // 重新抛出异常
        }
    }
}
```

### 5.3 带条件控制的复杂事务


```java
public void complexBusinessProcess(OrderRequest request) {
    
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    TransactionStatus status = transactionManager.getTransaction(def);
    
    try {
        // 🔍 第一步：检查库存
        Product product = productDao.findById(request.getProductId());
        if (product.getStock() < request.getQuantity()) {
            // 库存不足，直接回滚
            transactionManager.rollback(status);
            throw new InsufficientStockException("库存不足");
        }
        
        // 🔄 第二步：扣减库存
        productDao.updateStock(request.getProductId(), -request.getQuantity());
        
        // 📝 第三步：创建订单
        Order order = new Order(request);
        orderDao.save(order);
        
        // 🔔 第四步：发送通知（可选成功）
        try {
            notificationService.sendOrderNotification(order);
        } catch (Exception e) {
            // 通知失败不影响主业务，记录日志即可
            log.warn("订单通知发送失败: {}", e.getMessage());
        }
        
        // ✅ 所有关键步骤成功，提交事务
        transactionManager.commit(status);
        
    } catch (Exception e) {
        // ❌ 任何异常都回滚
        transactionManager.rollback(status);
        throw e;
    }
}
```

### 5.4 多事务嵌套处理


```java
public void batchProcessOrders(List<OrderRequest> orders) {
    
    // 🏠 外层事务：控制整批处理
    DefaultTransactionDefinition outerDef = new DefaultTransactionDefinition();
    TransactionStatus outerStatus = transactionManager.getTransaction(outerDef);
    
    int successCount = 0;
    
    try {
        for (OrderRequest order : orders) {
            
            // 🏢 内层事务：每个订单独立事务
            DefaultTransactionDefinition innerDef = new DefaultTransactionDefinition();
            innerDef.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
            TransactionStatus innerStatus = transactionManager.getTransaction(innerDef);
            
            try {
                processOrder(order); // 处理单个订单
                transactionManager.commit(innerStatus);
                successCount++;
                
            } catch (Exception e) {
                transactionManager.rollback(innerStatus);
                log.error("订单处理失败: {}", order.getId(), e);
                // 单个订单失败不影响其他订单
            }
        }
        
        // 🎯 根据成功率决定整批事务
        if (successCount == 0) {
            transactionManager.rollback(outerStatus);
            throw new RuntimeException("没有任何订单处理成功");
        } else {
            transactionManager.commit(outerStatus);
            log.info("批处理完成，成功: {}, 失败: {}", successCount, orders.size() - successCount);
        }
        
    } catch (Exception e) {
        transactionManager.rollback(outerStatus);
        throw e;
    }
}
```

---

## 6. 🔄 事务提交与回滚机制


### 6.1 提交机制详解


**💡 提交过程理解**：
事务提交就像是银行业务的"最终确认"，一旦提交就不能反悔。

```
事务提交的内部过程：

阶段1: 准备提交（Pre-commit）
   ├─ 🔍 检查事务状态是否正常
   ├─ 📋 验证所有资源是否准备就绪  
   └─ 🚫 如果标记为rollback-only，抛出异常

阶段2: 执行提交（Do-commit）  
   ├─ 💾 将所有改动写入数据库
   ├─ 📤 释放数据库锁资源
   └─ 🔄 更新事务状态为"已提交"

阶段3: 后续清理（Post-commit）
   ├─ 🧹 清理事务相关资源
   ├─ 📊 更新统计信息
   └─ 🔔 触发事务完成事件
```

**代码示例**：
```java
public void safeCommit(TransactionStatus status) {
    try {
        // 🔍 提交前检查
        if (status.isRollbackOnly()) {
            log.warn("事务被标记为只能回滚，执行回滚操作");
            transactionManager.rollback(status);
            return;
        }
        
        // ✅ 执行提交
        transactionManager.commit(status);
        log.info("事务提交成功");
        
    } catch (Exception e) {
        log.error("事务提交失败", e);
        throw e;
    }
}
```

### 6.2 回滚机制详解


**🔸 回滚触发条件**：

| 触发场景 | **说明** | **处理方式** |
|---------|---------|-------------|
| `程序异常` | `业务代码抛出异常` | `在catch块中调用rollback()` |
| `超时回滚` | `事务执行超过设定时间` | `系统自动回滚` |
| `手动标记` | `调用setRollbackOnly()` | `commit时自动转为回滚` |
| `资源异常` | `数据库连接断开等` | `系统检测到异常自动回滚` |

**回滚过程示意图**：

```
回滚操作流程：

触发回滚
   ↓
🔍 检查事务状态
   ↓
📜 获取回滚点信息  
   ↓
🔄 撤销所有数据变更
   ↓  
🔓 释放所有数据库锁
   ↓
🧹 清理事务资源
   ↓
✅ 标记事务为"已回滚"
```

### 6.3 异常处理最佳实践


```java
public void robustTransactionHandling() {
    
    TransactionStatus status = null;
    
    try {
        // 🚀 开始事务
        status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        
        // 💼 执行业务逻辑
        performBusinessLogic();
        
        // ✅ 正常提交
        transactionManager.commit(status);
        
    } catch (BusinessException e) {
        // 🏢 业务异常：记录日志并回滚
        if (status != null && !status.isCompleted()) {
            transactionManager.rollback(status);
        }
        log.error("业务处理失败: {}", e.getMessage());
        throw e;
        
    } catch (DataAccessException e) {
        // 🗄️ 数据访问异常：数据库相关问题
        if (status != null && !status.isCompleted()) {
            transactionManager.rollback(status);
        }
        log.error("数据库操作失败", e);
        throw new SystemException("数据处理异常，请稍后重试");
        
    } catch (Exception e) {
        // 🚨 未知异常：统一处理
        if (status != null && !status.isCompleted()) {
            transactionManager.rollback(status);
        }
        log.error("系统异常", e);
        throw new SystemException("系统繁忙，请稍后重试");
    }
}
```

---

## 7. 💼 资源管理最佳实践


### 7.1 资源管理的重要性


**💡 核心理念**：
数据库连接、内存缓冲区等都是宝贵的系统资源，必须合理管理，避免资源泄露。

```
资源管理类比：
数据库连接 = 银行的服务窗口

银行只有10个服务窗口（连接池最大10个连接）
如果客户办完业务不离开窗口（事务不释放连接）
后面的客户就只能排队等待（新请求被阻塞）
最终导致银行瘫痪（系统崩溃）

所以必须确保：
✅ 办完业务立即离开窗口（事务完成立即释放连接）
✅ 即使出现异常也要离开窗口（异常时也要释放资源）
```

### 7.2 try-with-resources模式


**🔸 资源自动管理**：

```java
// ❌ 不好的做法：可能导致资源泄露
public void badResourceManagement() {
    TransactionStatus status = transactionManager.getTransaction(def);
    
    // 如果这里抛异常，status可能没有被正确处理
    performBusinessLogic();
    
    transactionManager.commit(status); // 可能永远执行不到
}

// ✅ 好的做法：确保资源总是被释放  
public void goodResourceManagement() {
    TransactionStatus status = transactionManager.getTransaction(def);
    boolean committed = false;
    
    try {
        performBusinessLogic();
        transactionManager.commit(status);
        committed = true;
        
    } finally {
        // 📋 确保资源总是被清理
        if (!committed && !status.isCompleted()) {
            try {
                transactionManager.rollback(status);
            } catch (Exception e) {
                log.error("回滚失败", e);
            }
        }
    }
}
```

### 7.3 使用TransactionTemplate简化管理


**Spring提供的便捷工具**：

```java
@Service
public class UserServiceWithTemplate {
    
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void transferMoneySimplified(Long fromUserId, Long toUserId, BigDecimal amount) {
        
        // 🎯 使用模板自动管理资源
        transactionTemplate.executeWithoutResult(status -> {
            try {
                userDao.deductBalance(fromUserId, amount);
                userDao.addBalance(toUserId, amount);
                
                // 如果需要手动回滚
                if (someCondition) {
                    status.setRollbackOnly();
                }
                
            } catch (Exception e) {
                // 异常会自动触发回滚
                throw new RuntimeException("转账失败", e);
            }
        });
    }
    
    // 🔄 需要返回值的事务
    public Order createOrderWithReturn(OrderRequest request) {
        
        return transactionTemplate.execute(status -> {
            Order order = new Order(request);
            orderDao.save(order);
            
            // 模板会自动提交事务并返回结果
            return order;
        });
    }
}
```

### 7.4 连接池配置优化


```java
// 数据源配置示例
@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        
        // 🏊‍♂️ 连接池基础配置
        dataSource.setMaximumPoolSize(20);        // 最大连接数
        dataSource.setMinimumIdle(5);             // 最小空闲连接
        dataSource.setConnectionTimeout(30000);   // 获取连接超时（30秒）
        
        // ⏰ 连接生命周期管理
        dataSource.setIdleTimeout(600000);        // 空闲连接超时（10分钟）
        dataSource.setMaxLifetime(1800000);       // 连接最大生存时间（30分钟）
        
        // 🔍 连接测试配置
        dataSource.setConnectionTestQuery("SELECT 1");
        dataSource.setValidationTimeout(5000);
        
        return dataSource;
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 编程式事务：手动编写代码控制事务的开始、提交、回滚
🔸 PlatformTransactionManager：Spring事务管理的核心接口
🔸 TransactionDefinition：定义事务的具体参数和行为
🔸 TransactionStatus：记录事务的当前状态信息
🔸 资源管理：确保数据库连接等资源得到正确释放
```

### 8.2 关键理解要点


**🔹 什么时候使用编程式事务**：
```
适合场景：
✅ 需要条件性控制事务提交或回滚
✅ 复杂的多步骤业务流程
✅ 需要在事务中间做业务判断
✅ 对事务边界有精确控制要求

不适合场景：
❌ 简单的CRUD操作（用@Transactional更简单）
❌ 标准的"全成功或全失败"场景
❌ 团队对事务理解不深（容易出错）
```

**🔹 核心使用模式**：
```
标准流程：
1️⃣ 创建TransactionDefinition定义事务参数
2️⃣ 调用getTransaction()开始事务，获取TransactionStatus  
3️⃣ 在try块中执行业务逻辑
4️⃣ 成功时调用commit()提交事务
5️⃣ 异常时调用rollback()回滚事务
6️⃣ 确保资源总是被正确释放
```

**🔹 常见错误避免**：
```
❌ 忘记在异常时回滚事务
❌ 事务提交后继续使用TransactionStatus
❌ 在finally块中抛出新异常覆盖原异常
❌ 不检查事务是否已完成就重复操作
❌ 资源泄露导致连接池耗尽
```

### 8.3 实际应用指导


**💼 典型业务场景**：

```
电商订单处理：
🛒 检查商品库存 → 🏷️ 计算优惠价格 → 💳 验证支付信息
→ 📦 创建订单 → 📉 扣减库存 → 💰 记录支付
→ 🔔 发送通知（失败不回滚）→ ✅ 提交事务

金融转账业务：
👤 验证转出账户 → 👥 验证转入账户 → 💵 检查余额  
→ 🔐 锁定账户 → ➖ 扣减转出金额 → ➕ 增加转入金额
→ 📊 记录流水 → ✅ 提交事务

批量数据处理：  
📥 读取数据批次 → 🔄 逐条处理数据 → 📈 统计处理结果
→ 🎯 根据成功率决定是否提交 → ✅ 提交或回滚
```

**🔧 配置建议**：
```
开发环境：
• 事务超时：较长（便于调试）
• 连接池：较小（节省资源）
• 日志级别：详细（便于排查问题）

生产环境：
• 事务超时：适中（30-60秒）
• 连接池：根据并发量配置
• 日志级别：必要信息（避免性能影响）
```

### 8.4 进阶学习建议


**🎓 学习路径**：
1. 先掌握基础的事务概念和ACID特性
2. 熟练使用声明式事务(@Transactional)
3. 理解事务传播行为和隔离级别
4. 学习编程式事务的具体使用
5. 掌握复杂业务场景下的事务控制
6. 了解分布式事务的处理方式

**📚 相关技术扩展**：
- Spring Boot事务自动配置
- MyBatis与Spring事务集成
- JPA事务管理机制
- 分布式事务解决方案
- 事务监控和性能优化

**核心记忆口诀**：
- 编程事务手动控，开始提交回滚清
- 定义状态管理器，三个核心要记牢  
- 异常处理要周全，资源释放不能忘
- 复杂场景显威力，简单场景用注解