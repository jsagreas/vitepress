---
title: 7、事务回滚规则
---
## 📚 目录

1. [什么是事务回滚规则](#1-什么是事务回滚规则)
2. [Spring默认回滚规则](#2-Spring默认回滚规则)
3. [rollbackFor属性详解](#3-rollbackFor属性详解)
4. [noRollbackFor属性详解](#4-noRollbackFor属性详解)
5. [异常类型与回滚关系](#5-异常类型与回滚关系)
6. [自定义回滚策略](#6-自定义回滚策略)
7. [最佳实践与注意事项](#7-最佳实践与注意事项)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 什么是事务回滚规则


### 1.1 通俗理解事务回滚


想象你在银行转账，从A账户转100元到B账户：
1. **第一步**：从A账户扣除100元
2. **第二步**：向B账户增加100元

如果第二步出现问题（比如网络故障），那么第一步的操作就需要**撤销**，这就是**回滚**。

**🔸 事务回滚的本质**
```
正常情况：A扣钱 → B加钱 → 事务提交 ✅
异常情况：A扣钱 → B加钱失败 → 撤销A的扣钱操作 → 事务回滚 🔄
```

### 1.2 Spring中的回滚规则


**回滚规则**就是告诉Spring："什么情况下需要回滚事务"

```java
// 简单示例：转账方法
@Transactional
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    // 如果这里任何一步出现异常，Spring需要知道是否回滚
    accountService.deduct(fromId, amount);  // 扣钱
    accountService.add(toId, amount);       // 加钱
}
```

**🔹 核心问题**
- 什么异常需要回滚？
- 什么异常不需要回滚？
- 如何自定义回滚规则？

---

## 2. ⚖️ Spring默认回滚规则


### 2.1 默认规则很简单


Spring的默认回滚规则可以用一句话概括：

> 🔥 **核心原则**：**运行时异常**和**Error**会回滚，**检查异常**不会回滚

### 2.2 什么是运行时异常和检查异常？


**🔸 运行时异常（RuntimeException）**
- 程序运行时才能发现的异常
- 不强制处理，可以不用try-catch
- **Spring默认会回滚**

```java
// 常见运行时异常
NullPointerException      // 空指针异常
IllegalArgumentException  // 非法参数异常  
ArrayIndexOutOfBoundsException // 数组越界异常
```

**🔸 检查异常（Checked Exception）**
- 编译时就要求处理的异常
- 必须try-catch或throws声明
- **Spring默认不会回滚**

```java
// 常见检查异常
IOException          // IO异常
SQLException         // SQL异常
ClassNotFoundException // 类未找到异常
```

### 2.3 默认规则示例对比


| 异常类型 | **是否回滚** | **示例** |
|---------|-------------|----------|
| 🔴 **运行时异常** | `✅ 会回滚` | `NullPointerException` |
| 🔴 **Error** | `✅ 会回滚` | `OutOfMemoryError` |
| 🟡 **检查异常** | `❌ 不回滚` | `IOException` |

```java
@Transactional
public void defaultRollbackDemo() {
    accountService.deduct(fromId, amount);
    
    // 这个异常会导致回滚
    throw new RuntimeException("转账失败");
    
    // 这个异常不会导致回滚
    // throw new IOException("网络异常");
}
```

---

## 3. 🎯 rollbackFor属性详解


### 3.1 为什么需要rollbackFor？


有时候我们希望**检查异常也要回滚**，这时就需要`rollbackFor`属性。

**🔸 典型场景**
```
转账操作中，如果数据库连接异常(SQLException)，
我们肯定希望回滚事务，但SQLException是检查异常，
Spring默认不回滚，这就需要我们手动指定。
```

### 3.2 rollbackFor基本用法


**🔹 指定单个异常类**
```java
@Transactional(rollbackFor = SQLException.class)
public void transferWithSQLException() {
    accountService.deduct(fromId, amount);
    accountService.add(toId, amount);
    // SQLException也会导致回滚
}
```

**🔹 指定多个异常类**
```java
@Transactional(rollbackFor = {SQLException.class, IOException.class})
public void transferWithMultipleExceptions() {
    accountService.deduct(fromId, amount);
    accountService.add(toId, amount);
    // SQLException或IOException都会导致回滚
}
```

**🔹 使用异常类名字符串**
```java
@Transactional(rollbackForClassName = {"java.sql.SQLException"})
public void transferWithClassName() {
    // 效果同上，但用字符串指定异常类名
}
```

### 3.3 rollbackFor继承性


rollbackFor遵循异常的继承关系：

```java
// 异常继承关系示意图
Exception
├── IOException
│   └── FileNotFoundException
└── RuntimeException
    ├── NullPointerException  
    └── IllegalArgumentException

@Transactional(rollbackFor = IOException.class)
public void inheritanceDemo() {
    // IOException会回滚
    // FileNotFoundException也会回滚（因为继承自IOException）
}
```

### 3.4 实际应用示例


```java
@Service
public class OrderService {
    
    // 订单处理：文件操作异常也要回滚
    @Transactional(rollbackFor = IOException.class)
    public void processOrder(Order order) {
        // 1. 保存订单到数据库
        orderRepository.save(order);
        
        // 2. 生成订单文件（可能抛出IOException）
        fileService.generateOrderFile(order);
        
        // 3. 发送邮件通知
        emailService.sendConfirmation(order);
    }
}
```

---

## 4. 🚫 noRollbackFor属性详解


### 4.1 什么时候用noRollbackFor？


有时候我们希望**某些运行时异常不要回滚**，这时用`noRollbackFor`。

**🔸 典型场景**
```
用户注册时，如果用户名已存在，抛出RuntimeException，
但这不是系统错误，我们可能希望记录日志但不回滚事务。
```

### 4.2 noRollbackFor基本用法


**🔹 指定不回滚的异常**
```java
@Transactional(noRollbackFor = IllegalArgumentException.class)
public void registerUser(User user) {
    // 保存用户信息
    userRepository.save(user);
    
    // 验证用户名（可能抛出IllegalArgumentException）
    if (userRepository.existsByUsername(user.getUsername())) {
        // 这个异常不会导致回滚
        throw new IllegalArgumentException("用户名已存在");
    }
}
```

**🔹 同时使用rollbackFor和noRollbackFor**
```java
@Transactional(
    rollbackFor = SQLException.class,           // SQL异常要回滚
    noRollbackFor = IllegalArgumentException.class  // 参数异常不回滚
)
public void complexTransaction() {
    // 复杂的业务逻辑
}
```

### 4.3 优先级关系


当同一个异常同时被`rollbackFor`和`noRollbackFor`指定时：

> 💡 **规则**：`noRollbackFor`优先级更高

```java
@Transactional(
    rollbackFor = Exception.class,              // 所有异常都回滚
    noRollbackFor = IllegalArgumentException.class  // 但参数异常不回滚
)
public void priorityDemo() {
    // IllegalArgumentException不会回滚（noRollbackFor优先）
}
```

---

## 5. 📊 异常类型与回滚关系


### 5.1 异常类型全景图


```
Java异常体系：
                    Throwable
                   /         \
              Exception      Error
             /         \         \
    CheckedException  RuntimeException  OutOfMemoryError...
    (检查异常)        (运行时异常)      (系统错误)
         |                 |
   IOException...    NullPointerException...
```

### 5.2 回滚规则决策表


| 异常类型 | **默认行为** | **可配置** | **建议** |
|---------|------------|-----------|----------|
| 🔴 **RuntimeException** | `回滚` | `noRollbackFor`调整 | `大多数情况保持默认` |
| 🔴 **Error** | `回滚` | `noRollbackFor`调整 | `建议保持默认` |
| 🟡 **CheckedException** | `不回滚` | `rollbackFor`调整 | `按业务需求配置` |

### 5.3 常见异常处理策略


**🔸 数据访问异常**
```java
// 数据库相关异常通常需要回滚
@Transactional(rollbackFor = {SQLException.class, DataAccessException.class})
public void dataOperation() {
    // 数据库操作
}
```

**🔸 业务逻辑异常**
```java
// 业务异常可能不需要回滚，只需要提示用户
@Transactional(noRollbackFor = BusinessException.class)
public void businessOperation() {
    // 业务逻辑
    if (someCondition) {
        throw new BusinessException("业务规则不满足");
    }
}
```

**🔸 系统异常**
```java
// 系统级异常通常需要回滚
@Transactional  // 使用默认规则即可
public void systemOperation() {
    // 系统操作，RuntimeException会自动回滚
}
```

---

## 6. 🛠️ 自定义回滚策略


### 6.1 使用rollbackOn回调


Spring还支持更灵活的回滚策略：

```java
@Transactional
public void customRollbackLogic() {
    try {
        // 业务逻辑
        performBusinessLogic();
    } catch (Exception e) {
        // 根据异常消息决定是否回滚
        if (e.getMessage().contains("FATAL")) {
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        }
        throw e;
    }
}
```

### 6.2 自定义异常类


**🔸 定义业务异常基类**
```java
// 需要回滚的业务异常
public class RollbackBusinessException extends RuntimeException {
    public RollbackBusinessException(String message) {
        super(message);
    }
}

// 不需要回滚的业务异常  
public class NoRollbackBusinessException extends RuntimeException {
    public NoRollbackBusinessException(String message) {
        super(message);
    }
}
```

**🔸 使用自定义异常**
```java
@Transactional(noRollbackFor = NoRollbackBusinessException.class)
public void businessMethodWithCustomExceptions() {
    if (criticalError) {
        throw new RollbackBusinessException("严重错误，需要回滚");
    }
    
    if (minorError) {
        throw new NoRollbackBusinessException("轻微错误，无需回滚");
    }
}
```

### 6.3 编程式事务回滚


```java
@Autowired
private TransactionTemplate transactionTemplate;

public void programmaticRollback() {
    transactionTemplate.execute(status -> {
        try {
            // 业务逻辑
            performBusinessLogic();
            return "success";
        } catch (Exception e) {
            // 手动标记回滚
            status.setRollbackOnly();
            return "rollback";
        }
    });
}
```

---

## 7. 💡 最佳实践与注意事项


### 7.1 最佳实践


**🔸 明确异常处理策略**
```java
// 推荐：明确指定需要回滚的检查异常
@Transactional(rollbackFor = {SQLException.class, IOException.class})
public void recommendedApproach() {
    // 业务逻辑
}

// 不推荐：过于宽泛的异常捕获
@Transactional(rollbackFor = Exception.class)  // 太宽泛
public void notRecommended() {
    // 可能导致不必要的回滚
}
```

**🔸 区分系统异常和业务异常**
```java
// 系统异常：通常需要回滚
@Transactional
public void systemMethod() {
    if (systemError) {
        throw new RuntimeException("系统错误");  // 会回滚
    }
}

// 业务异常：可能不需要回滚
@Transactional(noRollbackFor = BusinessException.class)
public void businessMethod() {
    if (businessRuleViolation) {
        throw new BusinessException("业务规则违反");  // 不会回滚
    }
}
```

### 7.2 常见陷阱


**🚨 陷阱1：检查异常默认不回滚**
```java
// 错误示例：SQLException不会导致回滚
@Transactional
public void wrongExample() throws SQLException {
    // SQL操作可能抛出SQLException，但不会回滚！
    jdbcTemplate.update("INSERT INTO ...");
}

// 正确示例：明确指定rollbackFor
@Transactional(rollbackFor = SQLException.class)
public void correctExample() throws SQLException {
    jdbcTemplate.update("INSERT INTO ...");
}
```

**🚨 陷阱2：异常被捕获了**
```java
// 错误示例：异常被捕获，事务不会回滚
@Transactional
public void wrongCatchExample() {
    try {
        riskyOperation();
    } catch (Exception e) {
        log.error("操作失败", e);
        // 异常被吞掉了，事务不会回滚！
    }
}

// 正确示例：重新抛出异常或手动回滚
@Transactional
public void correctCatchExample() {
    try {
        riskyOperation();
    } catch (Exception e) {
        log.error("操作失败", e);
        throw new RuntimeException("处理失败", e);  // 重新抛出
    }
}
```

### 7.3 调试技巧


**🔸 开启事务日志**
```properties
# application.properties
logging.level.org.springframework.transaction=DEBUG
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=DEBUG
```

**🔸 事务状态检查**
```java
@Transactional
public void debugTransaction() {
    TransactionStatus status = TransactionAspectSupport.currentTransactionStatus();
    log.info("事务是否为新事务: {}", status.isNewTransaction());
    log.info("事务是否只读: {}", status.isReadOnly());
    log.info("事务是否回滚: {}", status.isRollbackOnly());
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须记住的关键点


```
🔸 默认回滚规则：RuntimeException和Error会回滚，CheckedException不会回滚
🔸 rollbackFor：指定哪些异常要回滚（通常用于CheckedException）
🔸 noRollbackFor：指定哪些异常不要回滚（通常用于RuntimeException）
🔸 优先级：noRollbackFor > rollbackFor > 默认规则
🔸 继承性：异常的子类也遵循父类的回滚规则
```

### 8.2 实用记忆口诀


```
🎯 回滚规则记忆法：
运行时异常要回滚，检查异常不回滚
rollbackFor让检查异常也回滚
noRollbackFor让运行时异常不回滚
异常捕获要小心，别让回滚失效了
```

### 8.3 配置建议


**🔹 保守策略**（推荐新手）
```java
// 明确指定常见的需要回滚的检查异常
@Transactional(rollbackFor = {SQLException.class, IOException.class})
```

**🔹 灵活策略**（有经验后）
```java
// 结合业务需求，精确控制回滚行为
@Transactional(
    rollbackFor = {SQLException.class, BusinessCriticalException.class},
    noRollbackFor = {BusinessWarningException.class}
)
```

**🔹 调试策略**
```java
// 开发阶段，可以打印事务状态
@Transactional
public void debugMethod() {
    if (log.isDebugEnabled()) {
        TransactionStatus status = TransactionAspectSupport.currentTransactionStatus();
        log.debug("当前事务状态: {}", status);
    }
    // 业务逻辑
}
```

### 8.4 学习路线建议


1. **第一步**：理解默认回滚规则
2. **第二步**：学会使用rollbackFor处理检查异常
3. **第三步**：掌握noRollbackFor的使用场景
4. **第四步**：实践中积累异常处理经验
5. **第五步**：学习自定义回滚策略

> 💭 **学习提示**：事务回滚规则是Spring事务管理的核心概念，掌握好这个知识点，你就能准确控制事务的提交和回滚行为，避免数据不一致的问题！