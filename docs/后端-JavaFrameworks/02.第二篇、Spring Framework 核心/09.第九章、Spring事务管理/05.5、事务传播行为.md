---
title: 5、事务传播行为
---
## 📚 目录

1. [事务传播行为基本概念](#1-事务传播行为基本概念)
2. [REQUIRED传播机制](#2-REQUIRED传播机制)
3. [REQUIRES_NEW传播机制](#3-REQUIRES_NEW传播机制)
4. [SUPPORTS传播机制](#4-SUPPORTS传播机制)
5. [NOT_SUPPORTED传播机制](#5-NOT_SUPPORTED传播机制)
6. [MANDATORY传播机制](#6-MANDATORY传播机制)
7. [NEVER传播机制](#7-NEVER传播机制)
8. [NESTED嵌套传播机制](#8-NESTED嵌套传播机制)
9. [传播行为对比分析](#9-传播行为对比分析)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 事务传播行为基本概念


### 1.1 什么是事务传播行为


想象一个场景：你在银行转账，这个过程需要扣你的钱，给别人加钱。如果有其他操作也需要用到事务，它们之间是什么关系？

**🔸 简单理解**
```
事务传播行为 = 多个事务方法调用时，事务如何传递
核心问题：当一个事务方法调用另一个事务方法时，事务怎么办？

就像接力赛：
- 有人已经在跑了（外层事务）
- 新人要加入（内层事务）  
- 怎么配合？（传播行为）
```

### 1.2 为什么需要事务传播


**💡 实际业务场景**
```
用户下单流程：
1. 创建订单（需要事务）
2. 扣减库存（需要事务）
3. 积分变更（需要事务）
4. 发送通知（可能需要事务）

问题来了：
- 每个步骤都有自己的事务需求
- 但它们又是一个完整的业务流程
- 如何协调这些事务的关系？
```

### 1.3 传播行为的作用机制


```
事务调用关系示意：
方法A（@Transactional）
    │
    └── 调用方法B（@Transactional）
         │
         └── 调用方法C（@Transactional）

问题：B和C的事务与A的事务是什么关系？
答案：取决于传播行为设置
```

> 💡 **核心理解**：事务传播行为决定了当一个已经在事务中的方法调用另一个事务方法时，新方法如何处理自己的事务。

---

## 2. ✅ REQUIRED传播机制


### 2.1 REQUIRED基本含义


**🔸 简单理解**
```
REQUIRED = "我需要事务"
- 有事务就用现有的
- 没事务就创建新的
- 这是默认的传播行为
```

**💭 生活类比**
```
就像坐公交车：
- 如果车上有空位（有事务），我就坐上去
- 如果没有车（没事务），我就打个车（创建新事务）
- 总之，我一定要有交通工具到达目的地
```

### 2.2 REQUIRED工作原理


```java
// 外层方法
@Transactional
public void methodA() {
    // 一些操作...
    methodB();  // 调用B方法
}

// 内层方法
@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
    // B方法的操作...
}
```

**🔄 执行流程分析**
```
情况1：methodA有事务时
methodA开始 → 创建事务T1 → methodB加入T1 → 都在同一个事务中

情况2：直接调用methodB时
methodB开始 → 发现没有事务 → 创建新事务T2 → 在T2中执行
```

### 2.3 REQUIRED实际应用


```java
@Service
public class OrderService {
    
    @Autowired
    private InventoryService inventoryService;
    
    // 外层事务方法
    @Transactional
    public void createOrder(Order order) {
        // 1. 保存订单
        orderRepository.save(order);
        
        // 2. 减库存（会加入当前事务）
        inventoryService.reduceStock(order.getProductId(), order.getQuantity());
        
        // 如果任何一步失败，整个订单创建都会回滚
    }
}

@Service  
public class InventoryService {
    
    // 使用REQUIRED传播行为
    @Transactional(propagation = Propagation.REQUIRED)
    public void reduceStock(Long productId, Integer quantity) {
        // 减库存操作
        Inventory inventory = inventoryRepository.findByProductId(productId);
        inventory.setQuantity(inventory.getQuantity() - quantity);
        inventoryRepository.save(inventory);
    }
}
```

**📊 执行结果分析**

| 调用方式 | 事务情况 | 结果说明 |
|---------|----------|----------|
| `orderService.createOrder()` | 外层有事务 | `reduceStock`加入外层事务 |
| `inventoryService.reduceStock()` | 外层无事务 | `reduceStock`创建新事务 |
| 任何一步失败 | 有事务时 | 整个事务回滚 |

---

## 3. 🔄 REQUIRES_NEW传播机制


### 3.1 REQUIRES_NEW基本含义


**🔸 简单理解**
```
REQUIRES_NEW = "我必须要新事务"
- 不管有没有事务，我都要创建全新的
- 我的事务独立运行，不受外层影响
- 我就是要"独立自主"
```

**💭 生活类比**
```
就像打车：
- 不管朋友开车没开车（有没有外层事务）
- 我就是要自己打车（创建新事务）
- 我的车程独立，不受朋友影响
```

### 3.2 REQUIRES_NEW工作原理


```java
@Transactional
public void methodA() {
    // 在事务T1中
    methodB();  // 调用B
    // 继续在T1中
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // 在全新的事务T2中执行
}
```

**🔄 事务执行图解**
```
时间线：
T1开始 ────────────────────── T1提交/回滚
        │
        T2开始 ── T2提交/回滚
        
T1和T2是完全独立的两个事务！
```

### 3.3 REQUIRES_NEW典型应用


```java
@Service
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    @Transactional
    public void processOrder(Order order) {
        try {
            // 1. 处理订单
            orderRepository.save(order);
            
            // 2. 记录日志（独立事务）
            logService.recordOrderLog(order.getId(), "订单处理开始");
            
            // 3. 复杂的业务处理
            complexBusinessLogic(order);
            
        } catch (Exception e) {
            // 即使订单处理失败，日志也已经保存了
            throw e;
        }
    }
}

@Service
public class LogService {
    
    // 日志记录使用独立事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void recordOrderLog(Long orderId, String message) {
        OrderLog log = new OrderLog();
        log.setOrderId(orderId);
        log.setMessage(message);
        log.setCreateTime(new Date());
        logRepository.save(log);
        
        // 这个事务立即提交，不受外层事务影响
    }
}
```

**⚡ 关键特点**

| 特点 | 说明 | 实际影响 |
|------|------|----------|
| **事务独立** | 内外层事务完全分离 | 内层成功，外层失败也不影响 |
| **立即提交** | 内层事务执行完立即提交 | 数据立即持久化到数据库 |
| **异常隔离** | 内层异常不影响外层 | 需要合理处理异常传播 |

---

## 4. 🤝 SUPPORTS传播机制


### 4.1 SUPPORTS基本含义


**🔸 简单理解**
```
SUPPORTS = "我支持事务，但不强求"
- 有事务我就加入
- 没事务我就不用事务
- 我很随和，适应环境
```

**💭 生活类比**
```
就像聚餐：
- 如果大家一起吃（有事务），我就一起吃
- 如果没人组织（没事务），我就自己吃
- 我不挑剔，随大流就好
```

### 4.2 SUPPORTS工作原理


```java
@Transactional
public void methodA() {
    // 在事务中
    methodB();  // B会加入当前事务
}

public void methodC() {
    // 没有事务
    methodB();  // B以非事务方式执行
}

@Transactional(propagation = Propagation.SUPPORTS)
public void methodB() {
    // 根据调用环境决定是否在事务中
}
```

### 3.3 SUPPORTS应用场景


```java
@Service
public class ReportService {
    
    // 查询方法使用SUPPORTS
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public List<Order> queryOrders(QueryCondition condition) {
        // 这是一个查询方法
        return orderRepository.findByCondition(condition);
    }
}

@Service
public class OrderService {
    
    @Autowired
    private ReportService reportService;
    
    // 场景1：在事务中调用查询
    @Transactional
    public void processOrderWithReport(Long orderId) {
        Order order = orderRepository.findById(orderId);
        
        // 查询会加入当前事务
        List<Order> relatedOrders = reportService.queryOrders(condition);
        
        // 处理业务逻辑...
    }
    
    // 场景2：非事务环境调用
    public void generateReport() {
        // 查询以非事务方式执行，性能更好
        List<Order> orders = reportService.queryOrders(condition);
        
        // 生成报表...
    }
}
```

**📊 执行情况对比**

| 调用场景 | 事务状态 | 性能影响 |
|----------|----------|----------|
| 事务中调用 | 加入外层事务 | 享受事务保护 |
| 非事务调用 | 无事务执行 | 性能更好 |

---

## 5. 🚫 NOT_SUPPORTED传播机制


### 5.1 NOT_SUPPORTED基本含义


**🔸 简单理解**
```
NOT_SUPPORTED = "我不要事务"
- 有事务我就挂起它
- 没事务正好，我本来就不要
- 我坚持非事务执行
```

**💭 生活类比**
```
就像不喝酒的人：
- 朋友们在喝酒（有事务），我选择喝水
- 没人喝酒（没事务）更好，我本来就不喝
- 我坚持自己的选择
```

### 5.2 NOT_SUPPORTED工作原理


```java
@Transactional
public void methodA() {
    // 在事务T1中
    methodB();  // 调用B时，T1被挂起
    // 回到事务T1中
}

@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void methodB() {
    // 以非事务方式执行
    // 此时外层事务T1被挂起
}
```

**🔄 事务挂起图解**
```
T1执行 ────── T1挂起 ────── T1恢复 ────── T1提交
              │      │
              methodB执行
              (非事务方式)
```

### 5.3 NOT_SUPPORTED应用场景


```java
@Service
public class NotificationService {
    
    // 发送邮件不需要事务，且避免事务超时
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void sendEmail(String to, String content) {
        try {
            // 发送邮件可能耗时较长
            emailClient.send(to, content);
            Thread.sleep(5000); // 模拟耗时操作
        } catch (Exception e) {
            // 邮件发送失败不影响主业务
            logger.error("邮件发送失败", e);
        }
    }
}

@Service
public class OrderService {
    
    @Autowired
    private NotificationService notificationService;
    
    @Transactional
    public void createOrder(Order order) {
        // 1. 保存订单（在事务中）
        orderRepository.save(order);
        
        // 2. 发送通知（挂起事务，非事务执行）
        notificationService.sendEmail(order.getEmail(), "订单创建成功");
        
        // 3. 继续其他操作（恢复事务）
        updateInventory(order);
    }
}
```

**⚡ 使用场景**

| 场景 | 原因 | 好处 |
|------|------|------|
| **外部服务调用** | 避免长时间占用连接 | 防止事务超时 |
| **日志记录** | 日志不需要回滚 | 提高性能 |
| **缓存操作** | 缓存独立于业务事务 | 避免意外回滚 |

---

## 6. ❗ MANDATORY传播机制


### 6.1 MANDATORY基本含义


**🔸 简单理解**
```
MANDATORY = "我强制要求事务"
- 必须在事务中调用我
- 没有事务就抛异常
- 我很严格，不容商量
```

**💭 生活类比**
```
就像VIP会员专用服务：
- 你必须是会员（有事务）才能使用
- 不是会员（没事务）直接拒绝服务
- 没有通融的余地
```

### 6.2 MANDATORY工作原理


```java
@Transactional
public void methodA() {
    methodB();  // 正常执行，因为有事务
}

public void methodC() {
    methodB();  // 抛出异常！因为没有事务
}

@Transactional(propagation = Propagation.MANDATORY)
public void methodB() {
    // 必须在事务中才能执行
}
```

### 6.3 MANDATORY应用场景


```java
@Service
public class AccountService {
    
    // 转账操作必须在事务中
    @Transactional(propagation = Propagation.MANDATORY)
    public void transferMoney(Long fromAccount, Long toAccount, BigDecimal amount) {
        // 这是关键操作，必须有事务保护
        Account from = accountRepository.findById(fromAccount);
        Account to = accountRepository.findById(toAccount);
        
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        accountRepository.save(from);
        accountRepository.save(to);
    }
}

@Service
public class BankService {
    
    @Autowired
    private AccountService accountService;
    
    // 正确调用方式
    @Transactional
    public void processTransfer(TransferRequest request) {
        // 验证操作...
        
        // 调用转账（有事务，正常执行）
        accountService.transferMoney(
            request.getFromAccount(), 
            request.getToAccount(), 
            request.getAmount()
        );
    }
    
    // 错误调用方式
    public void directTransfer(TransferRequest request) {
        // 直接调用会抛异常：No existing transaction found for transaction marked with propagation 'mandatory'
        accountService.transferMoney(
            request.getFromAccount(), 
            request.getToAccount(), 
            request.getAmount()
        );
    }
}
```

**⚠️ 异常情况**

当没有事务时调用MANDATORY方法：
```
Exception: No existing transaction found for transaction marked with propagation 'mandatory'
```

**🎯 适用场景**

| 场景 | 原因 | 作用 |
|------|------|------|
| **关键业务操作** | 必须有事务保护 | 防止数据不一致 |
| **子操作方法** | 只能在主流程中调用 | 确保调用规范 |
| **安全要求高** | 强制事务约束 | 避免误用 |

---

## 7. 🚨 NEVER传播机制


### 7.1 NEVER基本含义


**🔸 简单理解**
```
NEVER = "我绝不要事务"  
- 有事务就抛异常
- 没事务才正常执行
- 我坚决拒绝事务
```

**💭 生活类比**
```
就像对酒精过敏的人：
- 有酒的场合（有事务）我就不能参加
- 没酒的聚会（没事务）我才能参与
- 我天生就不能碰酒精（事务）
```

### 7.2 NEVER工作原理


```java
@Transactional
public void methodA() {
    methodB();  // 抛出异常！因为有事务
}

public void methodC() {
    methodB();  // 正常执行，因为没有事务
}

@Transactional(propagation = Propagation.NEVER)
public void methodB() {
    // 绝不能在事务中执行
}
```

### 7.3 NEVER应用场景


```java
@Service
public class StatisticsService {
    
    // 统计操作不能在事务中，避免锁表
    @Transactional(propagation = Propagation.NEVER)
    public StatisticsResult calculateDailyStatistics(Date date) {
        // 复杂的统计查询，可能需要很长时间
        // 在事务中执行会长时间锁定资源
        
        List<Order> orders = orderRepository.findByDate(date);
        
        // 复杂统计计算...
        StatisticsResult result = new StatisticsResult();
        
        return result;
    }
}

@Service
public class ReportService {
    
    @Autowired
    private StatisticsService statisticsService;
    
    // 正确调用方式
    public void generateDailyReport(Date date) {
        // 非事务环境调用统计服务
        StatisticsResult stats = statisticsService.calculateDailyStatistics(date);
        
        // 生成报表...
    }
    
    // 错误调用方式
    @Transactional
    public void processOrderAndGenerateStats(Order order, Date date) {
        orderRepository.save(order);
        
        // 这里会抛异常！因为在事务中调用NEVER方法
        StatisticsResult stats = statisticsService.calculateDailyStatistics(date);
    }
}
```

**⚠️ 异常情况**

当在事务中调用NEVER方法：
```
Exception: Existing transaction found for transaction marked with propagation 'never'
```

**🎯 使用场景**

| 场景 | 原因 | 好处 |
|------|------|------|
| **长时间查询** | 避免长事务锁资源 | 提高并发性能 |
| **缓存预热** | 缓存操作独立于业务 | 避免事务干扰 |
| **批量处理** | 大批量操作避免事务开销 | 提升处理效率 |

---

## 8. 🎭 NESTED嵌套传播机制


### 8.1 NESTED基本含义


**🔸 简单理解**
```
NESTED = "我要嵌套事务"
- 外层有事务，我创建嵌套事务（保存点）
- 外层没事务，我创建新事务
- 我可以独立回滚，但受外层影响
```

**💭 生活类比**
```
就像游戏存档：
- 主游戏进行中（外层事务）
- 做任务前先存档（嵌套事务/保存点）
- 任务失败可以读档重来（嵌套回滚）
- 但如果主游戏崩溃（外层回滚），存档也没用
```

### 8.2 NESTED工作原理


```java
@Transactional
public void methodA() {
    // 外层事务 T1
    
    methodB();  // 创建保存点 S1
    
    // 如果methodB失败，可以回滚到S1
    // 如果methodA失败，整个T1回滚
}

@Transactional(propagation = Propagation.NESTED)
public void methodB() {
    // 在保存点S1中执行
}
```

**🔄 保存点机制图解**
```
T1开始 ─── 创建保存点S1 ─── S1成功/回滚到S1 ─── T1提交/回滚
           │                │
           methodB执行       影响关系：
                           ├ methodB失败 → 回滚到S1，T1继续
                           └ T1失败 → 整个T1回滚，包括S1
```

### 8.3 NESTED典型应用


```java
@Service
public class OrderService {
    
    @Autowired
    private PointService pointService;
    
    @Transactional
    public void createOrder(Order order) {
        try {
            // 1. 保存订单（主要操作）
            orderRepository.save(order);
            
            // 2. 减库存（主要操作）
            reduceInventory(order);
            
            // 3. 积分操作（次要操作，允许失败）
            pointService.addPoints(order.getUserId(), order.getTotalAmount());
            
        } catch (Exception e) {
            // 主要操作失败，整个订单创建失败
            throw e;
        }
    }
}

@Service
public class PointService {
    
    // 积分操作使用嵌套事务
    @Transactional(propagation = Propagation.NESTED)
    public void addPoints(Long userId, BigDecimal amount) {
        try {
            User user = userRepository.findById(userId);
            
            // 计算积分（可能因为规则复杂而失败）
            int points = calculatePoints(amount);
            user.setPoints(user.getPoints() + points);
            
            userRepository.save(user);
            
            // 发送积分变动通知
            sendPointsNotification(userId, points);
            
        } catch (Exception e) {
            // 积分操作失败，但不影响订单创建
            logger.warn("积分添加失败，用户ID：" + userId, e);
            throw e;  // 触发嵌套事务回滚
        }
    }
}
```

**📊 异常处理对比**

| 异常情况 | NESTED行为 | REQUIRES_NEW行为 |
|----------|------------|------------------|
| 内层异常 | 回滚到保存点，外层可继续 | 内层独立回滚，外层可继续 |
| 外层异常 | 整个事务回滚 | 内层已提交，不受影响 |
| 性能开销 | 较小（保存点机制） | 较大（独立事务） |

### 8.4 NESTED使用注意事项


**⚠️ 数据库支持**
```
支持NESTED的数据库：
✅ MySQL（InnoDB引擎）
✅ PostgreSQL
✅ Oracle

不支持的数据库：
❌ MySQL（MyISAM引擎）
❌ 某些版本的SQLServer
```

**🔧 配置示例**
```java
// 需要配置支持保存点
@Bean
public DataSource dataSource() {
    HikariDataSource dataSource = new HikariDataSource();
    dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test");
    // 确保数据库驱动支持保存点
    return dataSource;
}
```

---

## 9. 📊 传播行为对比分析


### 9.1 传播行为总览表


| 传播行为 | 外层有事务 | 外层无事务 | 独立性 | 使用场景 |
|----------|------------|------------|--------|----------|
| **REQUIRED** | 加入外层事务 | 创建新事务 | ❌ | 🎯 最常用，默认选择 |
| **REQUIRES_NEW** | 创建新事务 | 创建新事务 | ✅ | 🎯 日志、审计等独立操作 |
| **SUPPORTS** | 加入外层事务 | 非事务执行 | ❌ | 🎯 查询操作，适应环境 |
| **NOT_SUPPORTED** | 挂起外层事务 | 非事务执行 | ✅ | 🎯 耗时操作，避免锁资源 |
| **MANDATORY** | 加入外层事务 | 抛异常 | ❌ | 🎯 强制事务约束 |
| **NEVER** | 抛异常 | 非事务执行 | ✅ | 🎯 禁止事务场景 |
| **NESTED** | 创建保存点 | 创建新事务 | 🔄 | 🎯 部分回滚场景 |

### 9.2 选择决策树


```
选择传播行为的思考路径：

1. 我是否需要事务？
   ├─ 不需要 → 考虑 NOT_SUPPORTED 或 NEVER
   └─ 需要 → 继续下一步

2. 我是否必须独立于外层事务？
   ├─ 是 → REQUIRES_NEW
   └─ 否 → 继续下一步

3. 我是否强制要求有外层事务？
   ├─ 是 → MANDATORY  
   └─ 否 → 继续下一步

4. 我是否需要部分回滚能力？
   ├─ 是 → NESTED
   └─ 否 → REQUIRED 或 SUPPORTS
```

### 9.3 性能影响对比


```
性能开销排序（从小到大）：
1. SUPPORTS（查询场景）
2. REQUIRED  
3. NESTED
4. NOT_SUPPORTED
5. REQUIRES_NEW（开销最大）

内存占用：
REQUIRES_NEW > NESTED > REQUIRED ≈ SUPPORTS
```

### 9.4 常见误区澄清


**❌ 常见误区1**：以为REQUIRES_NEW性能更好
```
实际情况：REQUIRES_NEW开销最大
原因：需要新建连接、独立提交
建议：非必要不用REQUIRES_NEW
```

**❌ 常见误区2**：以为NESTED就是子事务
```
实际情况：NESTED是保存点机制，不是真正的子事务
区别：嵌套事务受外层事务影响，子事务完全独立
```

**❌ 常见误区3**：所有方法都用REQUIRED
```
问题：没有考虑实际需求
建议：根据业务特点选择合适的传播行为
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 传播行为定义：多个事务方法调用时，事务如何传递和协调
🔸 默认行为：REQUIRED - 有事务加入，无事务创建
🔸 独立性区别：REQUIRES_NEW完全独立，NESTED部分独立
🔸 强制性约束：MANDATORY要求有事务，NEVER禁止事务
🔸 性能考量：根据实际需求选择，避免过度设计
```

### 10.2 实际应用指导原则


**🎯 选择建议**
```
日常开发：90%使用REQUIRED即可
日志审计：使用REQUIRES_NEW保证记录
查询操作：使用SUPPORTS提高灵活性  
耗时操作：使用NOT_SUPPORTED避免长事务
关键操作：使用MANDATORY强制约束
部分回滚：使用NESTED实现灵活控制
```

**⚠️ 使用注意事项**
```
1. 了解数据库支持情况（特别是NESTED）
2. 考虑性能影响（REQUIRES_NEW开销大）
3. 合理处理异常传播
4. 避免过度复杂的嵌套调用
5. 做好单元测试验证行为
```

### 10.3 记忆口诀


```
REQUIRED很常见，有无事务都能办
REQUIRES_NEW要独立，创建新事务不依赖
SUPPORTS很随和，有事务用无则不用
NOT_SUPPORTED挺特别，挂起事务独自行
MANDATORY很严格，没有事务就出错  
NEVER更极端，见到事务就翻脸
NESTED像存档，保存点上建分支
```

### 10.4 学习建议


**📚 深入学习路径**
1. **理解概念**：掌握每种传播行为的基本含义
2. **动手实践**：写代码验证不同传播行为
3. **场景应用**：结合实际业务选择合适行为
4. **性能调优**：了解各种行为的性能特点
5. **异常处理**：掌握异常在不同传播行为下的表现

**核心记忆**：
- 事务传播是Spring事务管理的核心概念
- 选择传播行为要结合具体业务需求
- 默认REQUIRED能满足大部分场景
- 特殊需求才考虑其他传播行为