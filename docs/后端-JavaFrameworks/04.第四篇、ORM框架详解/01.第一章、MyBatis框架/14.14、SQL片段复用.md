---
title: 14、SQL片段复用
---
## 📚 目录

1. [SQL片段是什么](#1-SQL片段是什么)
2. [SQL片段定义与基础使用](#2-SQL片段定义与基础使用)
3. [Include片段引用机制](#3-Include片段引用机制)
4. [片段参数传递详解](#4-片段参数传递详解)
5. [动态SQL片段构建](#5-动态SQL片段构建)
6. [跨文件片段引用](#6-跨文件片段引用)
7. [片段嵌套使用技巧](#7-片段嵌套使用技巧)
8. [代码复用最佳策略](#8-代码复用最佳策略)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 SQL片段是什么


### 1.1 为什么需要SQL片段


**现实问题**：写SQL时经常遇到重复代码

```
场景一：多个查询都要这些字段
SELECT id, username, email, phone, create_time FROM user WHERE ...
SELECT id, username, email, phone, create_time FROM user WHERE ...
SELECT id, username, email, phone, create_time FROM user WHERE ...

场景二：多个地方都用同样的条件
WHERE status = 1 AND deleted = 0
WHERE status = 1 AND deleted = 0
WHERE status = 1 AND deleted = 0

问题：
❌ 代码重复，不好维护
❌ 改一个地方要改好多处
❌ 容易漏改导致bug
```

### 1.2 SQL片段的本质


> 💡 **核心理解**
>
> SQL片段就像是"代码中的变量"，把重复使用的SQL代码段提取出来，起个名字，需要时直接调用这个名字就行。

**类比理解**：
```
就像数学里的公式：
设 a = 2x + 3y
那么：
式子1 = a + 5
式子2 = a × 2
式子3 = a - 1

SQL片段也一样：
定义片段 = SELECT常用字段
查询1 = 片段 + WHERE条件1
查询2 = 片段 + WHERE条件2
查询3 = 片段 + WHERE条件3
```

### 1.3 SQL片段的优势


| 优势 | 说明 | 实际效果 |
|------|------|---------|
| **复用性** | 一次定义，多处使用 | 减少80%的重复代码 |
| **维护性** | 改一处，全部生效 | 字段调整只需改片段定义 |
| **可读性** | 语义化命名，更清晰 | `<include refid="baseColumns"/>` 比写一堆字段清楚 |
| **一致性** | 统一标准，减少错误 | 所有查询用同样的字段顺序 |

---

## 2. 📝 SQL片段定义与基础使用


### 2.1 如何定义SQL片段


**基础语法**：用`<sql>`标签定义片段

```xml
<!-- 最简单的片段定义 -->
<sql id="baseColumns">
    id, username, email, phone, create_time
</sql>
```

**语法拆解**：
- `<sql>` - 定义SQL片段的标签
- `id="baseColumns"` - 给片段起个名字（必须唯一）
- 标签内容 - 要复用的SQL代码

### 2.2 如何使用SQL片段


**使用方式**：用`<include>`标签引用片段

```xml
<!-- 定义片段 -->
<sql id="baseColumns">
    id, username, email, phone, create_time
</sql>

<!-- 使用片段 -->
<select id="findById" resultType="User">
    SELECT <include refid="baseColumns"/>
    FROM user
    WHERE id = #{id}
</select>
```

**效果对比**：

```
原始写法（重复代码）：
SELECT id, username, email, phone, create_time FROM user WHERE id = ?
SELECT id, username, email, phone, create_time FROM user WHERE status = 1
SELECT id, username, email, phone, create_time FROM user WHERE email = ?

使用片段（简洁高效）：
SELECT <include refid="baseColumns"/> FROM user WHERE id = ?
SELECT <include refid="baseColumns"/> FROM user WHERE status = 1  
SELECT <include refid="baseColumns"/> FROM user WHERE email = ?
```

### 2.3 常见片段定义场景


**场景1：公共查询字段**
```xml
<!-- 用户表基础字段 -->
<sql id="baseColumns">
    id, username, email, phone, status, create_time, update_time
</sql>

<!-- 订单表基础字段 -->
<sql id="orderBaseColumns">
    order_id, user_id, total_amount, status, create_time
</sql>
```

**场景2：公共WHERE条件**
```xml
<!-- 有效数据条件 -->
<sql id="validCondition">
    status = 1 AND deleted = 0
</sql>

<select id="findValidUsers" resultType="User">
    SELECT * FROM user
    WHERE <include refid="validCondition"/>
</select>
```

**场景3：公共JOIN语句**
```xml
<!-- 用户订单关联 -->
<sql id="userOrderJoin">
    LEFT JOIN orders o ON u.id = o.user_id
</sql>

<select id="findUserWithOrders" resultType="UserVO">
    SELECT u.*, o.order_id
    FROM user u
    <include refid="userOrderJoin"/>
    WHERE u.id = #{userId}
</select>
```

---

## 3. 🔗 Include片段引用机制


### 3.1 Include标签详解


**基础语法**：
```xml
<include refid="片段id"/>
```

**属性说明**：
- `refid` - ✅ 必填，指定要引用的片段id
- 引用时片段会原样插入到include标签的位置

### 3.2 引用位置灵活性


**可以在SQL的任何位置使用**：

```xml
<!-- 定义片段 -->
<sql id="baseColumns">id, username, email</sql>
<sql id="validCondition">status = 1 AND deleted = 0</sql>
<sql id="orderBy">ORDER BY create_time DESC</sql>

<!-- ①在SELECT子句中使用 -->
<select id="query1" resultType="User">
    SELECT <include refid="baseColumns"/>
    FROM user
</select>

<!-- ②在WHERE子句中使用 -->
<select id="query2" resultType="User">
    SELECT * FROM user
    WHERE <include refid="validCondition"/>
</select>

<!-- ③在ORDER BY子句中使用 -->
<select id="query3" resultType="User">
    SELECT * FROM user
    <include refid="orderBy"/>
</select>

<!-- ④组合使用 -->
<select id="query4" resultType="User">
    SELECT <include refid="baseColumns"/>
    FROM user
    WHERE <include refid="validCondition"/>
    <include refid="orderBy"/>
</select>
```

### 3.3 引用解析时机


**重要理解**：

> ⚠️ **执行时机说明**
> 
> `<include>`标签在MyBatis**解析XML时**就会被替换成实际的SQL内容，不是运行时替换。

**过程演示**：
```
步骤①：写的XML
SELECT <include refid="baseColumns"/> FROM user

步骤②：MyBatis解析后（替换include）
SELECT id, username, email FROM user

步骤③：发送到数据库执行
SELECT id, username, email FROM user
```

---

## 4. 🎛️ 片段参数传递详解


### 4.1 为什么需要参数传递


**问题场景**：有时候片段需要根据情况变化

```
需求：不同查询需要不同的表名
查询1：SELECT id, name FROM user
查询2：SELECT id, name FROM admin
查询3：SELECT id, name FROM customer

如果每个表都定义一个片段，太麻烦了！
能不能让片段接收参数？
```

### 4.2 参数传递语法


**使用`<property>`标签传递参数**：

```xml
<!-- 定义带参数的片段 -->
<sql id="selectFromTable">
    SELECT * FROM ${tableName}
</sql>

<!-- 传递参数使用 -->
<select id="queryUser" resultType="User">
    <include refid="selectFromTable">
        <property name="tableName" value="user"/>
    </include>
    WHERE id = #{id}
</select>

<select id="queryAdmin" resultType="Admin">
    <include refid="selectFromTable">
        <property name="tableName" value="admin"/>
    </include>
    WHERE id = #{id}
</select>
```

**解析结果**：
```sql
-- queryUser解析后
SELECT * FROM user WHERE id = ?

-- queryAdmin解析后  
SELECT * FROM admin WHERE id = ?
```

### 4.3 参数传递原理


**参数替换机制**：

```
流程说明：
①定义片段时用 ${参数名} 占位
②include时用 <property name="参数名" value="实际值"/>
③MyBatis把 ${参数名} 替换成 实际值
```

**示例演示**：
```xml
<!-- 定义：用${prefix}占位 -->
<sql id="columns">
    ${prefix}.id, ${prefix}.name, ${prefix}.email
</sql>

<!-- 使用：传入prefix=u -->
<select id="query" resultType="User">
    SELECT <include refid="columns">
        <property name="prefix" value="u"/>
    </include>
    FROM user u
</select>

<!-- 解析结果 -->
SELECT u.id, u.name, u.email FROM user u
```

### 4.4 多参数传递


**可以传递多个参数**：

```xml
<sql id="baseQuery">
    SELECT ${columns} FROM ${table} WHERE ${condition}
</sql>

<select id="flexQuery" resultType="map">
    <include refid="baseQuery">
        <property name="columns" value="id, name"/>
        <property name="table" value="user"/>
        <property name="condition" value="status = 1"/>
    </include>
</select>
```

> 💡 **参数传递最佳实践**
>
> - ✅ 用于传递表名、列名等SQL结构部分
> - ✅ 让片段更灵活，适应不同场景
> - ⚠️ 注意SQL注入风险，只用于可控的值
> - ❌ 不要用来传递用户输入的数据

---

## 5. 🔄 动态SQL片段构建


### 5.1 片段中使用动态SQL


**重要特性**：SQL片段内部可以包含动态SQL标签

```xml
<!-- 动态WHERE条件片段 -->
<sql id="queryConditions">
    <where>
        <if test="username != null">
            AND username = #{username}
        </if>
        <if test="email != null">
            AND email = #{email}
        </if>
        <if test="status != null">
            AND status = #{status}
        </if>
    </where>
</sql>

<!-- 使用动态片段 -->
<select id="findUsers" resultType="User">
    SELECT * FROM user
    <include refid="queryConditions"/>
</select>
```

**效果说明**：
```
传入参数 {username: "张三"}
生成SQL：SELECT * FROM user WHERE username = ?

传入参数 {username: "张三", status: 1}
生成SQL：SELECT * FROM user WHERE username = ? AND status = ?

传入参数 {email: "test@qq.com"}
生成SQL：SELECT * FROM user WHERE email = ?
```

### 5.2 动态片段实战案例


**场景：灵活的排序片段**

```xml
<!-- 动态排序片段 -->
<sql id="dynamicOrderBy">
    <if test="orderBy != null">
        ORDER BY
        <choose>
            <when test="orderBy == 'time'">create_time</when>
            <when test="orderBy == 'name'">username</when>
            <otherwise>id</otherwise>
        </choose>
        <if test="sortType != null and sortType == 'desc'">DESC</if>
        <if test="sortType == null or sortType == 'asc'">ASC</if>
    </if>
</sql>

<!-- 使用 -->
<select id="queryUsers" resultType="User">
    SELECT * FROM user
    WHERE status = 1
    <include refid="dynamicOrderBy"/>
</select>
```

**测试效果**：

| 传入参数 | 生成的ORDER BY |
|---------|---------------|
| `{orderBy: "time", sortType: "desc"}` | `ORDER BY create_time DESC` |
| `{orderBy: "name"}` | `ORDER BY username ASC` |
| `{}` | 不生成ORDER BY |

### 5.3 条件判断片段


**动态字段选择**：

```xml
<!-- 根据参数选择查询字段 -->
<sql id="selectColumns">
    id, username, email
    <if test="includePhone != null and includePhone == true">
        , phone
    </if>
    <if test="includeAddress != null and includeAddress == true">
        , address
    </if>
</sql>

<select id="getUser" resultType="User">
    SELECT <include refid="selectColumns"/>
    FROM user
    WHERE id = #{id}
</select>
```

---

## 6. 🌐 跨文件片段引用


### 6.1 为什么需要跨文件引用


**实际场景**：

```
项目结构：
├── UserMapper.xml       (用户相关SQL)
├── OrderMapper.xml      (订单相关SQL)
├── ProductMapper.xml    (商品相关SQL)
└── CommonMapper.xml     (公共SQL片段)

问题：有些片段在多个Mapper中都要用
比如：分页片段、通用条件片段等

需求：能不能定义在一个地方，其他文件都能用？
```

### 6.2 跨文件引用语法


**语法格式**：`namespace.片段id`

```xml
<!-- ========== CommonMapper.xml ========== -->
<mapper namespace="com.example.mapper.CommonMapper">
    
    <!-- 公共分页片段 -->
    <sql id="pageSql">
        LIMIT #{offset}, #{pageSize}
    </sql>
    
    <!-- 公共有效条件 -->
    <sql id="validCondition">
        status = 1 AND deleted = 0
    </sql>
    
</mapper>

<!-- ========== UserMapper.xml ========== -->
<mapper namespace="com.example.mapper.UserMapper">
    
    <select id="findUsers" resultType="User">
        SELECT * FROM user
        WHERE <include refid="com.example.mapper.CommonMapper.validCondition"/>
        <include refid="com.example.mapper.CommonMapper.pageSql"/>
    </select>
    
</mapper>

<!-- ========== OrderMapper.xml ========== -->
<mapper namespace="com.example.mapper.OrderMapper">
    
    <select id="findOrders" resultType="Order">
        SELECT * FROM orders
        WHERE <include refid="com.example.mapper.CommonMapper.validCondition"/>
        <include refid="com.example.mapper.CommonMapper.pageSql"/>
    </select>
    
</mapper>
```

### 6.3 引用路径说明


**路径格式详解**：

```
完整路径 = namespace + "." + 片段id

组成部分：
①namespace：定义片段的Mapper的namespace
②片段id：<sql>标签的id属性

示例：
com.example.mapper.CommonMapper.pageSql
└─────────┬────────────────┘  └──┬──┘
      namespace              片段id
```

### 6.4 跨文件引用最佳实践


**组织结构建议**：

```
策略①：专门的公共片段文件
CommonSqlFragment.xml
├── 通用分页片段
├── 通用排序片段
├── 通用条件片段
└── 通用字段片段

策略②：按业务模块组织
UserCommon.xml      → 用户相关公共片段
OrderCommon.xml     → 订单相关公共片段
ProductCommon.xml   → 商品相关公共片段
```

**实际示例**：
```xml
<!-- ========== CommonSqlFragment.xml ========== -->
<mapper namespace="com.example.common.SqlFragment">
    
    <!-- 通用分页 -->
    <sql id="mysqlPage">
        LIMIT #{offset}, #{limit}
    </sql>
    
    <!-- 通用排序 -->
    <sql id="commonOrderBy">
        <if test="orderBy != null">
            ORDER BY ${orderBy}
            <if test="sortType != null">${sortType}</if>
        </if>
    </sql>
    
</mapper>

<!-- ========== 各业务Mapper引用 ========== -->
<select id="anyQuery" resultType="...">
    SELECT * FROM table
    <include refid="com.example.common.SqlFragment.commonOrderBy"/>
    <include refid="com.example.common.SqlFragment.mysqlPage"/>
</select>
```

---

## 7. 🔁 片段嵌套使用技巧


### 7.1 什么是片段嵌套


**概念理解**：片段内部可以引用其他片段

```
就像俄罗斯套娃：
大片段 包含 中片段 包含 小片段

或者像函数调用：
functionA() {
    functionB();  // A调用B
}
functionB() {
    functionC();  // B调用C
}
```

### 7.2 嵌套使用示例


**基础嵌套**：

```xml
<!-- 最小粒度片段 -->
<sql id="baseId">id</sql>
<sql id="baseName">username</sql>
<sql id="baseEmail">email</sql>

<!-- 组合片段（嵌套引用） -->
<sql id="userBaseColumns">
    <include refid="baseId"/>,
    <include refid="baseName"/>,
    <include refid="baseEmail"/>
</sql>

<!-- 完整查询片段（再次嵌套） -->
<sql id="userQuery">
    SELECT <include refid="userBaseColumns"/>
    FROM user
</sql>

<!-- 最终使用 -->
<select id="findUser" resultType="User">
    <include refid="userQuery"/>
    WHERE id = #{id}
</select>
```

**解析过程**：
```
步骤①：解析最内层
<include refid="baseId"/> → id
<include refid="baseName"/> → username
<include refid="baseEmail"/> → email

步骤②：解析中层
<include refid="userBaseColumns"/> → id, username, email

步骤③：解析外层
<include refid="userQuery"/> → SELECT id, username, email FROM user

步骤④：最终SQL
SELECT id, username, email FROM user WHERE id = ?
```

### 7.3 实战嵌套案例


**场景：构建复杂查询**

```xml
<!-- 层次1：原子片段 -->
<sql id="userColumns">u.id, u.username, u.email</sql>
<sql id="orderColumns">o.order_id, o.total_amount</sql>

<!-- 层次2：组合片段 -->
<sql id="allColumns">
    <include refid="userColumns"/>,
    <include refid="orderColumns"/>
</sql>

<!-- 层次3：JOIN片段 -->
<sql id="userOrderJoin">
    FROM user u
    LEFT JOIN orders o ON u.id = o.user_id
</sql>

<!-- 层次4：完整查询片段 -->
<sql id="userOrderQuery">
    SELECT <include refid="allColumns"/>
    <include refid="userOrderJoin"/>
</sql>

<!-- 最终使用 -->
<select id="getUserOrders" resultType="UserOrderVO">
    <include refid="userOrderQuery"/>
    WHERE u.id = #{userId}
</select>
```

### 7.4 嵌套的注意事项


> ⚠️ **嵌套使用要点**
>
> ✅ **优点**：高度复用，灵活组合
> ⚠️ **注意**：不要嵌套太深（建议≤3层）
> ❌ **禁止**：循环引用（A引用B，B又引用A）

**循环引用错误示例**：
```xml
<!-- ❌ 错误：会导致无限循环 -->
<sql id="fragmentA">
    SELECT * FROM table
    <include refid="fragmentB"/>
</sql>

<sql id="fragmentB">
    WHERE <include refid="fragmentA"/>
</sql>
```

---

## 8. 🎯 代码复用最佳策略


### 8.1 片段粒度设计原则


**粒度分类**：

| 粒度级别 | 定义 | 适用场景 | 示例 |
|---------|------|---------|------|
| **细粒度** | 单个字段/条件 | 灵活组合 | `<sql id="idColumn">id</sql>` |
| **中粒度** | 字段组/条件组 | 常用组合 | `<sql id="baseColumns">id, name, email</sql>` |
| **粗粒度** | 完整子句 | 固定模式 | `<sql id="userJoin">FROM user u LEFT JOIN...</sql>` |

**设计建议**：

```
推荐策略：中粒度为主，细粒度辅助

✅ 好的设计：
<sql id="userBase">id, username, email, phone</sql>
<sql id="userDetail">address, birthday, gender</sql>
<sql id="userFull">
    <include refid="userBase"/>, <include refid="userDetail"/>
</sql>

❌ 过细粒度：
<sql id="id">id</sql>
<sql id="comma">,</sql>
<sql id="username">username</sql>
// 太碎片化，反而不好维护
```

### 8.2 命名规范建议


**统一命名风格**：

```
推荐命名模式：

①【表名】+【用途】
userBaseColumns      - 用户基础字段
orderQueryConditions - 订单查询条件

②【功能】+【范围】
commonPageSql        - 通用分页
validDataCondition   - 有效数据条件

③【操作】+【对象】
selectUserColumns    - 查询用户字段
joinOrderTable      - 关联订单表
```

**实际示例**：
```xml
<!-- 清晰的命名 -->
<sql id="userBaseColumns">...</sql>
<sql id="userDetailColumns">...</sql>
<sql id="orderListColumns">...</sql>
<sql id="commonValidCondition">...</sql>
<sql id="mysqlPageLimit">...</sql>
```

### 8.3 维护性最佳实践


**策略①：按功能分组**

```xml
<mapper namespace="...">
    
    <!-- ========== 字段片段 ========== -->
    <sql id="baseColumns">...</sql>
    <sql id="detailColumns">...</sql>
    
    <!-- ========== 条件片段 ========== -->
    <sql id="validCondition">...</sql>
    <sql id="activeCondition">...</sql>
    
    <!-- ========== JOIN片段 ========== -->
    <sql id="userOrderJoin">...</sql>
    <sql id="orderProductJoin">...</sql>
    
</mapper>
```

**策略②：添加注释说明**

```xml
<!--
    片段：userBaseColumns
    用途：用户表基础查询字段
    包含：id, username, email, phone, status
    使用场景：列表查询、详情查询
    维护人：张三
    更新时间：2025-09-20
-->
<sql id="userBaseColumns">
    id, username, email, phone, status
</sql>
```

**策略③：版本管理**

```xml
<!-- 版本1：基础版本 -->
<sql id="userColumnsV1">
    id, username, email
</sql>

<!-- 版本2：扩展版本（向后兼容） -->
<sql id="userColumnsV2">
    id, username, email, phone, address
</sql>

<!-- 新查询用V2，旧查询继续用V1 -->
<select id="newQuery">
    SELECT <include refid="userColumnsV2"/> FROM user
</select>

<select id="oldQuery">
    SELECT <include refid="userColumnsV1"/> FROM user
</select>
```

### 8.4 常见问题与解决方案


**问题1：片段修改影响范围不明确**

```
解决方案：
①修改前全局搜索片段id
②查看所有引用位置
③评估影响范围
④必要时创建新版本片段
```

**问题2：片段太多不好找**

```
解决方案：
①建立片段清单文档
②统一命名规范
③按功能分类组织
④使用IDE的搜索功能
```

**问题3：跨文件引用路径太长**

```
解决方案：
①给公共片段用短namespace
②在文件头部用注释说明引用路径

示例：
<!-- 公共片段引用路径：com.example.common.Sql -->
<select id="...">
    <include refid="com.example.common.Sql.page"/>
</select>
```

---

## 9. 📋 核心要点总结


### 9.1 SQL片段核心概念


```
🔸 SQL片段本质：可复用的SQL代码块
🔸 定义方式：<sql id="唯一标识">SQL代码</sql>
🔸 使用方式：<include refid="片段id"/>
🔸 作用范围：同文件直接用id，跨文件用namespace.id
🔸 核心价值：减少重复、便于维护、提高一致性
```

### 9.2 关键技术点


**技术点1：基础使用**
```xml
<!-- 定义 -->
<sql id="baseColumns">id, name, email</sql>

<!-- 引用 -->
<include refid="baseColumns"/>
```

**技术点2：参数传递**
```xml
<!-- 定义 -->
<sql id="query">SELECT ${columns} FROM ${table}</sql>

<!-- 使用 -->
<include refid="query">
    <property name="columns" value="*"/>
    <property name="table" value="user"/>
</include>
```

**技术点3：动态片段**
```xml
<sql id="conditions">
    <where>
        <if test="name != null">AND name = #{name}</if>
        <if test="status != null">AND status = #{status}</if>
    </where>
</sql>
```

**技术点4：跨文件引用**
```xml
<include refid="com.example.common.SqlFragment.pageSql"/>
```

**技术点5：片段嵌套**
```xml
<sql id="outer">
    <include refid="inner1"/>, <include refid="inner2"/>
</sql>
```

### 9.3 使用建议速查


| 场景 | 建议做法 | 不建议做法 |
|------|---------|-----------|
| **字段定义** | 中粒度组合：`id, name, email` | ❌ 单字段片段：`<sql id="id">id</sql>` |
| **参数传递** | 传递表名、列名等结构 | ❌ 传递用户输入数据 |
| **跨文件引用** | 公共片段集中管理 | ❌ 随意跨文件引用 |
| **片段嵌套** | 控制在3层以内 | ❌ 嵌套层级过深 |
| **命名规范** | `表名+用途`：userBaseColumns | ❌ 无意义命名：sql1, abc |

### 9.4 实战记忆口诀


```
SQL片段用<sql>，复用代码不重复
include引用很简单，refid指定片段名
参数传递用property，灵活配置更强大
跨文件引用加namespace，公共片段集中管
动态片段加if/choose，条件组合随心造
嵌套使用需谨慎，层次清晰好维护
```

### 9.5 注意事项清单


> ⚠️ **重要提醒**
>
> - ✅ 片段id在同一个Mapper中必须唯一
> - ✅ 跨文件引用要写完整路径：namespace.id
> - ✅ 参数用`${}`接收，注意SQL注入风险
> - ⚠️ 避免循环引用导致无限递归
> - ⚠️ 嵌套不要超过3层，影响可读性
> - ❌ 不要把片段当万能工具，简单SQL直接写

---

## 📚 学习检查清单


**掌握程度自测**：

- [ ] 能说出SQL片段的作用和优势
- [ ] 会使用`<sql>`定义片段
- [ ] 会使用`<include>`引用片段  
- [ ] 理解参数传递的语法和用途
- [ ] 知道如何跨文件引用片段
- [ ] 了解片段嵌套的使用方法
- [ ] 掌握片段命名和组织规范
- [ ] 能独立设计片段复用方案

**实践任务**：

```
任务1：为用户表设计一套基础片段
- baseColumns（基础字段）
- detailColumns（详细字段）
- validCondition（有效条件）

任务2：创建公共分页片段
- 支持传递offset和limit参数
- 能被多个Mapper引用

任务3：设计动态排序片段
- 支持多字段排序
- 支持ASC/DESC切换
```