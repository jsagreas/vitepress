---
title: 9、主键生成策略
---
## 📚 目录

1. [主键生成策略概述](#1-主键生成策略概述)
2. [useGeneratedKeys自动获取主键](#2-useGeneratedKeys自动获取主键)
3. [selectKey查询主键方式](#3-selectKey查询主键方式)
4. [不同数据库的主键策略](#4-不同数据库的主键策略)
5. [批量插入的主键处理](#5-批量插入的主键处理)
6. [自定义主键生成器](#6-自定义主键生成器)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 主键生成策略概述


### 1.1 什么是主键生成策略


**通俗理解**：当你往数据库插入一条新数据时，通常需要一个唯一的"身份证号"来标识这条记录，这个"身份证号"就是主键。主键生成策略就是决定这个"身份证号"怎么来的规则。

```
现实场景类比：
学生入学注册 → 需要分配学号
    ├─ 自动编号：2025001、2025002...（数据库自增）
    ├─ 手动指定：由管理员输入（程序控制）
    └─ 统一生成：UUID、雪花算法等（自定义策略）
```

### 1.2 为什么需要主键生成策略


**核心问题**：插入数据后，程序经常需要知道这条数据的主键值，比如：

```
用户注册流程：
第1步：插入用户信息 → 生成用户ID
第2步：需要用这个ID去创建用户的详细资料
第3步：需要用这个ID建立用户关联关系

问题：第1步插入后，怎么拿到数据库自动生成的ID？
```

> 💡 **关键点**：主键生成策略解决的就是"插入数据后如何获取主键值"的问题

### 1.3 MyBatis支持的主键策略


| 策略类型 | **适用场景** | **优点** | **缺点** |
|---------|------------|---------|---------|
| 🔸 **数据库自增** | MySQL、SQL Server | 简单高效，数据库保证唯一 | 依赖数据库，分布式不友好 |
| 🔸 **序列生成** | Oracle、PostgreSQL | 灵活可控，支持预分配 | 需要额外维护序列对象 |
| 🔸 **UUID** | 分布式系统 | 全局唯一，不依赖数据库 | 占用空间大，无序 |
| 🔸 **自定义生成器** | 特殊业务需求 | 灵活定制 | 开发复杂度高 |

---

## 2. ⚡ useGeneratedKeys自动获取主键


### 2.1 核心概念解析


**useGeneratedKeys** 是什么？
- 这是MyBatis提供的一个配置属性，字面意思是"使用生成的键"
- 它的作用是：告诉MyBatis在插入数据后，自动从数据库获取刚生成的主键值
- 获取到的主键值会自动填充到你的Java对象中

**keyProperty** 是什么？
- 这是配置"主键值要填充到Java对象的哪个属性"
- 比如你的User对象有个`id`属性，就配置`keyProperty="id"`
- MyBatis会把数据库生成的主键值赋给这个属性

**keyColumn** 是什么？
- 这是配置"数据库表中哪个列是主键列"
- 通常数据库表只有一个主键，MyBatis能自动识别
- 只有在某些特殊情况（比如联合主键）才需要明确指定

### 2.2 基础使用方式


**最简单的配置**（MySQL环境）：

```xml
<!-- 用户注册插入示例 -->
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO user (username, password, email)
    VALUES (#{username}, #{password}, #{email})
</insert>
```

**工作流程图解**：

```
代码执行流程：
程序端                          数据库端
  |                               |
  |--[1]创建User对象------------->|
  |   user.id = null              |
  |   user.username = "张三"       |
  |                               |
  |--[2]执行插入SQL-------------->|
  |                               |
  |                               |--[3]生成主键ID=1001
  |                               |
  |<-[4]返回主键ID=1001-----------|
  |                               |
  |--[5]自动赋值----------------->|
  |   user.id = 1001              |
```

**Java代码调用示例**：

```java
// 创建用户对象
User user = new User();
user.setUsername("张三");
user.setPassword("123456");
user.setEmail("zhangsan@example.com");

// 插入前：user.getId() 为 null
System.out.println("插入前ID: " + user.getId()); // 输出：null

// 执行插入
userMapper.insertUser(user);

// 插入后：user.getId() 自动被赋值
System.out.println("插入后ID: " + user.getId()); // 输出：1001
```

> ⚠️ **重要提醒**：useGeneratedKeys只对支持自增主键的数据库有效（MySQL、SQL Server等），Oracle需要用selectKey方式

### 2.3 完整配置说明


**带所有参数的完整配置**：

```xml
<insert id="insertUser" 
        useGeneratedKeys="true"    ← 开启自动获取主键
        keyProperty="id"           ← 主键值填充到id属性
        keyColumn="user_id">       ← 数据库主键列名（可选）
    INSERT INTO user (username, password, email)
    VALUES (#{username}, #{password}, #{email})
</insert>
```

**参数详解表格**：

| 参数 | **类型** | **必填** | **说明** |
|------|---------|---------|---------|
| `useGeneratedKeys` | `boolean` | 是 | 是否使用JDBC的getGeneratedKeys方法获取主键 |
| `keyProperty` | `String` | 是 | 主键对应的Java对象属性名 |
| `keyColumn` | `String` | 否 | 数据库主键列名（通常自动识别） |

### 2.4 全局配置方式


如果项目中大部分表都用自增主键，可以在MyBatis配置文件开启全局设置：

```xml
<!-- mybatis-config.xml -->
<settings>
    <!-- 全局开启自动获取主键 -->
    <setting name="useGeneratedKeys" value="true"/>
</settings>
```

> 💡 **使用建议**：全局开启后，单个Mapper也可以通过`useGeneratedKeys="false"`关闭

---

## 3. 🔍 selectKey查询主键方式


### 3.1 selectKey是什么


**概念理解**：
- `selectKey` 是MyBatis提供的另一种获取主键的方式
- 它的原理是：通过执行一条SQL查询语句来获取主键值
- 适用于不支持自增主键的数据库（如Oracle）或需要自定义主键生成逻辑的场景

**与useGeneratedKeys的区别**：

```
useGeneratedKeys：          selectKey：
    ↓                          ↓
依赖数据库自增功能          执行SQL查询获取主键
    ↓                          ↓
插入后自动返回              可以在插入前/后执行
    ↓                          ↓
配置简单                   更灵活但稍复杂
```

### 3.2 基本使用方式


**Oracle数据库获取序列值**：

```xml
<insert id="insertUser">
    <!-- 先查询序列获取主键 -->
    <selectKey keyProperty="id" resultType="long" order="BEFORE">
        SELECT user_seq.NEXTVAL FROM dual
    </selectKey>
    
    <!-- 再执行插入（此时id已经有值了） -->
    INSERT INTO user (id, username, password, email)
    VALUES (#{id}, #{username}, #{password}, #{email})
</insert>
```

**执行顺序图解**：

```
程序执行顺序（order="BEFORE"）：
  |
  |--[1] 执行selectKey查询序列
  |      SELECT user_seq.NEXTVAL → 得到 1001
  |
  |--[2] 将1001赋值给user.id
  |      user.id = 1001
  |
  |--[3] 执行insert语句
  |      INSERT ... VALUES (1001, ...)
  |
  ✓ 完成
```

### 3.3 selectKey核心属性


**属性详解表格**：

| 属性 | **必填** | **说明** | **示例值** |
|------|---------|---------|-----------|
| `keyProperty` | ✅ | 主键值赋给哪个Java属性 | `id` 或 `userId` |
| `resultType` | ✅ | 主键的数据类型 | `long`、`String`、`int` |
| `order` | ✅ | 执行时机 | `BEFORE`（插入前）或 `AFTER`（插入后） |
| `statementType` | ❌ | SQL执行类型 | `STATEMENT`、`PREPARED`（默认） |

**order属性详解**：

```
BEFORE（插入前执行）：
   适用场景：需要先生成主键，再插入数据
   典型例子：Oracle序列、UUID生成
   
AFTER（插入后执行）：
   适用场景：数据库自动生成主键，插入后查询
   典型例子：MySQL的LAST_INSERT_ID()
```

### 3.4 不同场景的selectKey用法


**场景1：MySQL获取自增主键**（不推荐，建议用useGeneratedKeys）

```xml
<insert id="insertUser">
    <selectKey keyProperty="id" resultType="long" order="AFTER">
        SELECT LAST_INSERT_ID()
    </selectKey>
    INSERT INTO user (username, password, email)
    VALUES (#{username}, #{password}, #{email})
</insert>
```

**场景2：使用UUID作为主键**

```xml
<insert id="insertUser">
    <selectKey keyProperty="id" resultType="String" order="BEFORE">
        SELECT REPLACE(UUID(), '-', '')
    </selectKey>
    INSERT INTO user (id, username, password, email)
    VALUES (#{id}, #{username}, #{password}, #{email})
</insert>
```

**场景3：PostgreSQL序列主键**

```xml
<insert id="insertUser">
    <selectKey keyProperty="id" resultType="long" order="BEFORE">
        SELECT nextval('user_id_seq')
    </selectKey>
    INSERT INTO user (id, username, password, email)
    VALUES (#{id}, #{username}, #{password}, #{email})
</insert>
```

> 🔧 **实践建议**：
> - MySQL环境：优先使用 `useGeneratedKeys`
> - Oracle环境：使用 `selectKey` 配合序列
> - 需要自定义主键生成逻辑：使用 `selectKey` 配合自定义SQL

---

## 4. 💾 不同数据库的主键策略


### 4.1 MySQL自增主键策略


**数据库层面配置**：

```sql
-- 创建表时定义自增主键
CREATE TABLE user (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,  ← 自增主键
    username VARCHAR(50),
    password VARCHAR(100)
);

-- 查看当前自增值
SHOW TABLE STATUS LIKE 'user';

-- 修改自增起始值
ALTER TABLE user AUTO_INCREMENT = 10000;
```

**MyBatis配置**：

```xml
<!-- 方式1：推荐方式 -->
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO user (username, password) 
    VALUES (#{username}, #{password})
</insert>

<!-- 方式2：selectKey方式 -->
<insert id="insertUser">
    <selectKey keyProperty="id" resultType="long" order="AFTER">
        SELECT LAST_INSERT_ID()
    </selectKey>
    INSERT INTO user (username, password) 
    VALUES (#{username}, #{password})
</insert>
```

> ⭐ **重要程度**：🔥🔥🔥🔥🔥（最常用）

### 4.2 Oracle序列主键策略


**数据库层面配置**：

```sql
-- 1. 创建序列对象
CREATE SEQUENCE user_seq
    START WITH 1000      -- 起始值
    INCREMENT BY 1       -- 增长步长
    NOCACHE             -- 不缓存（安全但慢）
    NOCYCLE;            -- 不循环

-- 2. 创建表（无自增）
CREATE TABLE user (
    id NUMBER(19) PRIMARY KEY,
    username VARCHAR2(50),
    password VARCHAR2(100)
);

-- 3. 手动使用序列
INSERT INTO user (id, username, password)
VALUES (user_seq.NEXTVAL, '张三', '123456');
```

**MyBatis配置**：

```xml
<insert id="insertUser">
    <!-- 插入前先从序列获取主键 -->
    <selectKey keyProperty="id" resultType="long" order="BEFORE">
        SELECT user_seq.NEXTVAL FROM dual
    </selectKey>
    INSERT INTO user (id, username, password)
    VALUES (#{id}, #{username}, #{password})
</insert>
```

**序列策略对比**：

| 配置项 | **CACHE** | **NOCACHE** |
|--------|----------|------------|
| 性能 | 快（预分配内存） | 慢（每次查数据库） |
| 安全性 | 低（数据库重启可能跳号） | 高（严格连续） |
| 适用场景 | 高并发插入 | 严格要求连续性 |

### 4.3 PostgreSQL序列主键策略


**数据库层面配置**：

```sql
-- 方式1：使用SERIAL类型（自动创建序列）
CREATE TABLE user (
    id SERIAL PRIMARY KEY,        ← 等同于自增
    username VARCHAR(50),
    password VARCHAR(100)
);

-- 方式2：手动创建序列
CREATE SEQUENCE user_id_seq START 1000;

CREATE TABLE user (
    id BIGINT PRIMARY KEY DEFAULT nextval('user_id_seq'),
    username VARCHAR(50),
    password VARCHAR(100)
);
```

**MyBatis配置**：

```xml
<!-- 使用SERIAL类型 -->
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO user (username, password) 
    VALUES (#{username}, #{password})
</insert>

<!-- 使用手动序列 -->
<insert id="insertUser">
    <selectKey keyProperty="id" resultType="long" order="BEFORE">
        SELECT nextval('user_id_seq')
    </selectKey>
    INSERT INTO user (id, username, password)
    VALUES (#{id}, #{username}, #{password})
</insert>
```

### 4.4 UUID主键生成策略


**什么是UUID**：
- UUID是Universally Unique Identifier（通用唯一识别码）的缩写
- 它是一个128位的数字，通常表示为32个16进制数字的字符串
- 格式示例：`550e8400-e29b-41d4-a716-446655440000`

**UUID的优缺点**：

```
✅ 优点：
  ├─ 全局唯一：不依赖数据库，分布式环境友好
  ├─ 安全性高：无法推测下一个ID值
  └─ 易于合并：多数据库数据合并不会冲突

❌ 缺点：
  ├─ 占用空间大：32/36字节 vs 数字8字节
  ├─ 无序性：影响索引性能（B+树频繁分裂）
  └─ 可读性差：不便于人工识别
```

**数据库层面配置**：

```sql
-- MySQL表结构
CREATE TABLE user (
    id CHAR(32) PRIMARY KEY,      ← 存储UUID（去掉横杠）
    username VARCHAR(50),
    password VARCHAR(100)
);

-- 或使用VARCHAR(36)保留横杠
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(100)
);
```

**MyBatis配置方式**：

```xml
<!-- 方式1：数据库函数生成 -->
<insert id="insertUser">
    <selectKey keyProperty="id" resultType="String" order="BEFORE">
        SELECT REPLACE(UUID(), '-', '')   ← 去掉横杠
    </selectKey>
    INSERT INTO user (id, username, password)
    VALUES (#{id}, #{username}, #{password})
</insert>

<!-- 方式2：Java代码生成 -->
<insert id="insertUser">
    INSERT INTO user (id, username, password)
    VALUES (#{id}, #{username}, #{password})
</insert>
```

**Java代码生成UUID**：

```java
// 插入前手动生成UUID
User user = new User();
user.setId(UUID.randomUUID().toString().replace("-", ""));
user.setUsername("张三");
user.setPassword("123456");

userMapper.insertUser(user);
```

> 💡 **选择建议**：
> - 单库应用 → 数字自增主键
> - 分布式系统 → UUID或雪花算法
> - 对外展示ID → 避免用自增（安全考虑）

---

## 5. 📦 批量插入的主键处理


### 5.1 批量插入的挑战


**问题场景**：

```
普通场景：插入1条数据 → 获取1个主键ID ✓

批量场景：插入100条数据 → 获取100个主键ID ？
    ├─ 如何让每个对象都拿到自己的主键？
    ├─ 性能如何保证？
    └─ 不同数据库如何处理？
```

### 5.2 MySQL批量插入获取主键


**方式1：useGeneratedKeys批量获取**（推荐）

```xml
<insert id="batchInsertUsers" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO user (username, password, email) VALUES
    <foreach collection="list" item="user" separator=",">
        (#{user.username}, #{user.password}, #{user.email})
    </foreach>
</insert>
```

**Java调用示例**：

```java
// 批量插入用户
List<User> users = new ArrayList<>();
users.add(new User("张三", "123456", "zhang@example.com"));
users.add(new User("李四", "123456", "li@example.com"));
users.add(new User("王五", "123456", "wang@example.com"));

// 插入前：所有user的id都是null
users.forEach(u -> System.out.println("插入前: " + u.getId()));

// 执行批量插入
userMapper.batchInsertUsers(users);

// 插入后：每个user的id都被自动赋值
users.forEach(u -> System.out.println("插入后: " + u.getId()));
// 输出：
// 插入后: 1001
// 插入后: 1002  
// 插入后: 1003
```

**原理解析**：

```
MyBatis批量获取主键的内部机制：

第1步：拼接批量插入SQL
   INSERT INTO user (...) VALUES 
   ('张三',...), ('李四',...), ('王五',...)

第2步：执行插入，数据库返回3个主键
   返回：[1001, 1002, 1003]

第3步：按顺序赋值给List中的对象
   users.get(0).id = 1001
   users.get(1).id = 1002
   users.get(2).id = 1003
```

> ⚠️ **注意事项**：批量插入的顺序必须和List中对象的顺序一致，否则主键赋值会错乱

**方式2：循环单条插入**（不推荐）

```xml
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO user (username, password, email)
    VALUES (#{username}, #{password}, #{email})
</insert>
```

```java
// 循环调用单条插入
for (User user : users) {
    userMapper.insertUser(user);  // 每次都能获取主键
    System.out.println("插入ID: " + user.getId());
}
```

**性能对比**：

| 方式 | **SQL执行次数** | **网络交互** | **性能** |
|------|---------------|------------|---------|
| 批量插入 | 1次 | 1次 | ⭐⭐⭐⭐⭐ |
| 循环单条 | N次 | N次 | ⭐⭐☆☆☆ |

### 5.3 Oracle批量插入获取主键


**方式1：循环selectKey**（常用）

```xml
<insert id="batchInsertUsers">
    <foreach collection="list" item="user" separator=";">
        <selectKey keyProperty="user.id" resultType="long" order="BEFORE">
            SELECT user_seq.NEXTVAL FROM dual
        </selectKey>
        INSERT INTO user (id, username, password)
        VALUES (#{user.id}, #{user.username}, #{user.password})
    </foreach>
</insert>
```

**方式2：预先批量获取序列**（性能更好）

```java
// Java层面处理
public void batchInsert(List<User> users) {
    // 1. 批量获取序列值
    List<Long> ids = userMapper.getNextIds(users.size());
    
    // 2. 手动赋值ID
    for (int i = 0; i < users.size(); i++) {
        users.get(i).setId(ids.get(i));
    }
    
    // 3. 批量插入（ID已经有了）
    userMapper.batchInsertWithIds(users);
}
```

```xml
<!-- 批量获取序列 -->
<select id="getNextIds" resultType="long">
    SELECT user_seq.NEXTVAL FROM dual 
    CONNECT BY LEVEL &lt;= #{count}
</select>

<!-- 批量插入 -->
<insert id="batchInsertWithIds">
    INSERT ALL
    <foreach collection="list" item="user">
        INTO user (id, username, password) 
        VALUES (#{user.id}, #{user.username}, #{user.password})
    </foreach>
    SELECT 1 FROM dual
</insert>
```

### 5.4 UUID批量插入处理


**方式1：Java代码预生成**（推荐）

```java
// 批量插入前，先生成所有UUID
List<User> users = new ArrayList<>();
for (int i = 0; i < 100; i++) {
    User user = new User();
    user.setId(UUID.randomUUID().toString().replace("-", ""));
    user.setUsername("user" + i);
    user.setPassword("123456");
    users.add(user);
}

// 批量插入
userMapper.batchInsertUsers(users);
```

**方式2：数据库函数生成**

```xml
<insert id="batchInsertUsers">
    INSERT INTO user (id, username, password) VALUES
    <foreach collection="list" item="user" separator=",">
        (REPLACE(UUID(),'-',''), #{user.username}, #{user.password})
    </foreach>
</insert>
```

> 💡 **推荐做法**：UUID建议在Java层面生成，便于后续业务逻辑使用ID

---

## 6. 🔧 自定义主键生成器


### 6.1 为什么需要自定义主键生成器


**典型业务场景**：

```
业务需求：订单号规则
  ├─ 格式：yyyyMMdd + 流水号
  ├─ 示例：20250923001、20250923002
  └─ 要求：每天从001重新开始

传统主键方案的问题：
  ├─ 自增ID：无法体现业务规则
  ├─ UUID：不满足格式要求
  └─ 序列：无法每天重置
```

### 6.2 实现自定义KeyGenerator


**步骤1：创建主键生成器类**

```java
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.mapping.MappedStatement;

public class OrderIdGenerator implements KeyGenerator {
    
    @Override
    public void processBefore(Executor executor, MappedStatement ms, 
                              Statement stmt, Object parameter) {
        // 在插入前生成主键
        if (parameter instanceof Order) {
            Order order = (Order) parameter;
            String orderId = generateOrderId();
            order.setOrderId(orderId);
        }
    }
    
    @Override
    public void processAfter(Executor executor, MappedStatement ms, 
                             Statement stmt, Object parameter) {
        // 插入后处理（本例不需要）
    }
    
    // 自定义订单号生成逻辑
    private String generateOrderId() {
        // 日期部分：20250923
        String date = new SimpleDateFormat("yyyyMMdd").format(new Date());
        
        // 流水号部分：从Redis获取今日计数器
        long sequence = redisTemplate.opsForValue()
            .increment("order:sequence:" + date);
        
        // 拼接订单号：20250923001
        return date + String.format("%03d", sequence);
    }
}
```

**步骤2：注册到MyBatis**

```xml
<!-- mybatis-config.xml -->
<configuration>
    <plugins>
        <plugin interceptor="com.example.OrderIdGenerator"/>
    </plugins>
</configuration>
```

**步骤3：Mapper中使用**

```xml
<insert id="insertOrder" keyProperty="orderId">
    INSERT INTO t_order (order_id, user_id, total_amount)
    VALUES (#{orderId}, #{userId}, #{totalAmount})
</insert>
```

```java
// Java调用
Order order = new Order();
order.setUserId(1001L);
order.setTotalAmount(new BigDecimal("99.99"));

// 插入前：orderId为null
orderMapper.insertOrder(order);

// 插入后：orderId自动赋值为 20250923001
System.out.println(order.getOrderId());
```

### 6.3 基于注解的实现方式


**方式1：使用MyBatis-Plus的IdGenerator**

```java
import com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator;
import org.springframework.stereotype.Component;

@Component
public class CustomIdGenerator implements IdentifierGenerator {
    
    @Override
    public Long nextId(Object entity) {
        // 自定义ID生成逻辑
        return generateId();
    }
    
    private Long generateId() {
        // 雪花算法、Redis、数据库等方式生成
        return SnowflakeIdWorker.nextId();
    }
}
```

**方式2：使用JPA的@GeneratedValue**

```java
import javax.persistence.*;

@Entity
@Table(name = "user")
public class User {
    
    @Id
    @GeneratedValue(generator = "custom-id")
    @GenericGenerator(name = "custom-id", 
                     strategy = "com.example.CustomIdGenerator")
    private String id;
    
    private String username;
}
```

### 6.4 常见自定义主键算法


**算法1：雪花算法（Snowflake）**

```
雪花算法ID结构（64位）：
┌─────────┬──────┬──────┬────────────┐
│  时间戳  │ 机器ID │ 序列号 │
│  41位   │ 10位  │ 12位  │ = 64位Long
└─────────┴──────┴──────┴────────────┘

特点：
✅ 趋势递增：按时间排序
✅ 分布式友好：机器ID保证唯一
✅ 高性能：单机每毫秒4096个ID
```

**算法2：数据库+Redis组合**

```
生成流程：
  ┌─────────┐
  │  应用   │
  └────┬────┘
       │
       ├─→ [1] 从Redis获取今日计数
       │    Redis: order:count:20250923 = 156
       │
       ├─→ [2] 拼接业务前缀
       │    前缀: ORD + 20250923 + 156
       │
       └─→ [3] 返回最终ID
            ID: ORD20250923000156
```

**算法3：时间戳+随机数**

```java
public String generateId() {
    // 时间戳（毫秒）：1695456789123
    long timestamp = System.currentTimeMillis();
    
    // 4位随机数：1234
    int random = new Random().nextInt(10000);
    
    // 拼接：1695456789123_1234
    return timestamp + "_" + String.format("%04d", random);
}
```

> 🚀 **选择建议**：
> - 性能要求极高 → 雪花算法
> - 需要业务含义 → 自定义规则
> - 分布式环境 → Redis + 业务规则

---

## 7. 📋 核心要点总结


### 7.1 主键策略选择指南


```
选择流程图：
                开始
                 ↓
          是否分布式系统？
         ／          ＼
       是              否
       ↓               ↓
   UUID/雪花算法    是否MySQL？
       ↓            ／      ＼
   全局唯一         是        否
                    ↓         ↓
              useGeneratedKeys  是否Oracle？
                    ↓         ／      ＼
                自增主键      是        否
                           ↓          ↓
                      selectKey    自定义
                         ↓
                       序列主键
```

### 7.2 配置方式速查表


| 数据库 | **推荐方式** | **配置示例** | **适用场景** |
|--------|------------|------------|-------------|
| **MySQL** | `useGeneratedKeys` | `useGeneratedKeys="true" keyProperty="id"` | 90%的场景 |
| **Oracle** | `selectKey` | `SELECT seq.NEXTVAL FROM dual` | 序列主键 |
| **PostgreSQL** | `useGeneratedKeys` | 配合SERIAL类型 | 自增主键 |
| **分布式** | UUID/雪花算法 | Java代码生成 | 多数据库部署 |

### 7.3 批量插入最佳实践


```
性能优化建议：
✅ MySQL → 使用useGeneratedKeys + foreach批量插入
✅ Oracle → 预先批量获取序列 + INSERT ALL
✅ UUID → Java层面预生成 + 批量插入
❌ 避免 → 循环调用单条插入（性能差）
```

### 7.4 必须掌握的知识点


**基础必会**：
- ✅ useGeneratedKeys的作用和使用场景
- ✅ keyProperty和keyColumn的区别
- ✅ selectKey的执行时机（BEFORE/AFTER）
- ✅ 不同数据库的主键策略差异

**进阶掌握**：
- ✅ 批量插入如何获取主键
- ✅ UUID主键的优缺点
- ✅ 自定义主键生成器的实现
- ✅ 雪花算法的基本原理

**实战技巧**：
- ✅ 根据业务场景选择合适的主键策略
- ✅ 处理批量操作的主键回填问题
- ✅ 分布式环境下的主键设计
- ✅ 主键生成性能优化

### 7.5 常见问题与解决方案


**问题1：批量插入主键赋值错乱**
```
原因：插入顺序与List顺序不一致
解决：确保foreach的顺序和集合顺序一致
```

**问题2：Oracle无法获取主键**
```
原因：Oracle不支持自增，useGeneratedKeys无效
解决：使用selectKey配合序列
```

**问题3：UUID影响查询性能**
```
原因：UUID无序，B+树索引频繁分裂
解决：使用有序UUID变种（如MySQL的UUID_TO_BIN）
```

**问题4：分布式环境主键冲突**
```
原因：多数据库使用相同自增序列
解决：使用UUID、雪花算法或统一ID生成服务
```

---

## 📚 参考资源


**官方文档**：
- MyBatis官方文档：https://mybatis.org/mybatis-3/
- MySQL主键文档：https://dev.mysql.com/doc/

**学习建议**：
- ⭐⭐⭐⭐⭐ useGeneratedKeys：最常用，必须熟练
- ⭐⭐⭐⭐☆ selectKey：Oracle环境必备
- ⭐⭐⭐☆☆ UUID策略：分布式场景了解
- ⭐⭐☆☆☆ 自定义生成器：特殊需求时使用

**核心记忆口诀**：
```
MySQL自增用useGeneratedKeys，
Oracle序列selectKey配，
批量插入别循环调，
分布式场景UUID好，
业务主键自定义造。
```