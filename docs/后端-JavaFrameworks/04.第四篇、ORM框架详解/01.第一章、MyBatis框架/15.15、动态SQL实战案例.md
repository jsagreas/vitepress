---
title: 15、动态SQL实战案例
---
## 📚 目录


1. [什么是动态SQL实战](#1-什么是动态SQL实战)
2. [多条件查询实战](#2-多条件查询实战)
3. [分页查询构建](#3-分页查询构建)
4. [排序条件处理](#4-排序条件处理)
5. [模糊搜索优化](#5-模糊搜索优化)
6. [范围查询处理](#6-范围查询处理)
7. [复合条件组合](#7-复合条件组合)
8. [性能优化技巧](#8-性能优化技巧)
9. [常见问题解决](#9-常见问题解决)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 什么是动态SQL实战



### 1.1 实战案例的重要性



**为什么要学实战案例？**
```
理论知识 → 知道有哪些标签
实战案例 → 知道怎么用这些标签解决真实问题

就像学做菜：
📖 理论：知道盐、糖、醋的作用
🍳 实战：知道炒菜时该放多少，什么时候放
```

**实战案例能解决什么问题？**
- **场景1**：用户搜索商品，可能输入名称，可能选价格区间，可能都不填
- **场景2**：数据列表需要分页，每页显示数量不固定
- **场景3**：用户可以按价格、销量、时间等多种方式排序
- **场景4**：搜索功能支持模糊匹配，比如搜"手机"能找到"智能手机"

### 1.2 实战案例的核心思路



**解决问题的思维流程：**
```
步骤1：分析需求
   ↓ 用户可能输入什么条件？条件之间什么关系？
步骤2：设计SQL结构  
   ↓ 哪些部分是固定的？哪些是动态的？
步骤3：选择合适标签
   ↓ 用<if>、<choose>还是<foreach>？
步骤4：优化性能
   ↓ SQL会不会很慢？怎么让它快起来？
```

---

## 2. 🔍 多条件查询实战



### 2.1 真实业务场景



**电商商品搜索功能：**
```
用户可能的操作：
✅ 只输入商品名称搜索
✅ 只选择价格区间筛选  
✅ 同时输入名称和选择价格
✅ 什么都不输入，查看全部商品
```

**问题分析：**
```
传统做法：写4条SQL
if (有名称) { SQL1 }
else if (有价格) { SQL2 }  
else if (都有) { SQL3 }
else { SQL4 }

问题：代码重复、难维护、容易出错

动态SQL做法：写1条SQL，自动适配所有情况
```

### 2.2 基础版本：简单条件组合



```xml
<!-- 商品查询：支持按名称和价格筛选 -->
<select id="searchProducts" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 如果传入了商品名称，就添加名称条件 -->
        <if test="productName != null and productName != ''">
            AND product_name LIKE CONCAT('%', #{productName}, '%')
        </if>
        
        <!-- 如果传入了最低价格，就添加价格下限 -->
        <if test="minPrice != null">
            AND price &gt;= #{minPrice}
        </if>
        
        <!-- 如果传入了最高价格，就添加价格上限 -->
        <if test="maxPrice != null">
            AND price &lt;= #{maxPrice}
        </if>
    </where>
</select>
```

**工作原理解释：**
```
情况1：只传商品名称="手机"
生成SQL：SELECT * FROM products WHERE product_name LIKE '%手机%'

情况2：只传价格范围 minPrice=1000, maxPrice=5000  
生成SQL：SELECT * FROM products WHERE price >= 1000 AND price <= 5000

情况3：都传了
生成SQL：SELECT * FROM products 
         WHERE product_name LIKE '%手机%' 
         AND price >= 1000 
         AND price <= 5000

情况4：都不传
生成SQL：SELECT * FROM products
```

**关键点说明：**
| 技术点 | 说明 | 作用 |
|--------|------|------|
| **`<where>`标签** | 智能处理WHERE关键字 | 自动去掉多余的AND，条件都不满足时不加WHERE |
| **`test`属性** | 判断条件是否成立 | `!=null`检查是否传值，`!=''`检查是否空字符串 |
| **`&gt;`和`&lt;`** | XML转义字符 | 在XML中不能直接写`>`和`<`，要用转义 |
| **`CONCAT`函数** | 字符串拼接 | 拼接百分号实现模糊查询 |

### 2.3 进阶版本：多种条件类型



```xml
<!-- 高级商品搜索：支持分类、品牌、状态等多种筛选 -->
<select id="advancedSearch" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 按分类筛选 -->
        <if test="categoryId != null">
            AND category_id = #{categoryId}
        </if>
        
        <!-- 按品牌筛选：支持多个品牌 -->
        <if test="brandIds != null and brandIds.size() > 0">
            AND brand_id IN
            <foreach collection="brandIds" item="brandId" 
                     open="(" separator="," close=")">
#                #{brandId}
            </foreach>
        </if>
        
        <!-- 按状态筛选：使用choose实现单选 -->
        <choose>
            <when test="status == 'sale'">
                AND status = 1 AND stock > 0
            </when>
            <when test="status == 'soldout'">
                AND stock = 0
            </when>
            <otherwise>
                AND status = 1
            </otherwise>
        </choose>
        
        <!-- 按关键词搜索：名称或描述包含关键词 -->
        <if test="keyword != null and keyword != ''">
            AND (product_name LIKE CONCAT('%', #{keyword}, '%')
                 OR description LIKE CONCAT('%', #{keyword}, '%'))
        </if>
    </where>
</select>
```

**实际运行示例：**
```
假设传入参数：
{
  categoryId: 10,
  brandIds: [1, 3, 5],
  status: "sale",
  keyword: "无线"
}

生成的SQL：
SELECT * FROM products
WHERE category_id = 10
  AND brand_id IN (1, 3, 5)
  AND status = 1 AND stock > 0
  AND (product_name LIKE '%无线%' OR description LIKE '%无线%')
```

**核心技巧总结：**
```
🔸 单个值判断 → 用<if>
🔸 多个值判断 → 用<if> + <foreach>
🔸 互斥选择 → 用<choose>
🔸 复杂条件 → 用括号组合
```

---

## 3. 📄 分页查询构建



### 3.1 分页的基本概念



**什么是分页？**
```
假设有1000条商品数据：

不分页：一次性查出1000条 → 网页加载慢、体验差
分页查询：每次只查10条

第1页：1-10条    LIMIT 0, 10
第2页：11-20条   LIMIT 10, 10  
第3页：21-30条   LIMIT 20, 10
```

**分页的核心参数：**
```
pageNum：当前第几页（从1开始）
pageSize：每页显示多少条

计算公式：
offset = (pageNum - 1) × pageSize
limit = pageSize

示例：第3页，每页10条
offset = (3-1) × 10 = 20
limit = 10
SQL: LIMIT 20, 10
```

### 3.2 基础分页实现



```xml
<!-- 分页查询商品列表 -->
<select id="findProductsByPage" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 可选的筛选条件 -->
        <if test="categoryId != null">
            AND category_id = #{categoryId}
        </if>
    </where>
    <!-- 分页部分 -->
    LIMIT #{offset}, #{pageSize}
</select>
```

**Java代码调用：**
```java
// 计算offset
int pageNum = 3;  // 查第3页
int pageSize = 10; // 每页10条
int offset = (pageNum - 1) * pageSize; // offset = 20

// 封装参数
Map<String, Object> params = new HashMap<>();
params.put("offset", offset);
params.put("pageSize", pageSize);
params.put("categoryId", 5);

// 执行查询
List<Product> products = mapper.findProductsByPage(params);
```

### 3.3 动态分页优化



**问题：**不同场景需要不同的每页数量
```
✅ 手机端：每页5条（屏幕小）
✅ 电脑端：每页20条（屏幕大）
✅ 导出数据：每页1000条（批量处理）
```

**优化方案：**
```xml
<select id="dynamicPage" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="categoryId != null">
            AND category_id = #{categoryId}
        </if>
    </where>
    
    <!-- 动态分页：允许不传分页参数 -->
    <if test="offset != null and pageSize != null">
        LIMIT #{offset}, #{pageSize}
    </if>
</select>
```

**安全性处理：**
```xml
<!-- 防止恶意传入超大pageSize导致数据库压力 -->
<select id="safePage" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 条件省略 -->
    </where>
    
    <!-- 限制最大每页数量 -->
    <if test="pageSize != null">
        <choose>
            <when test="pageSize &lt;= 100">
                LIMIT #{offset}, #{pageSize}
            </when>
            <otherwise>
                LIMIT #{offset}, 100
            </otherwise>
        </choose>
    </if>
</select>
```

**分页查询流程图：**
```
用户请求
   ↓
接收pageNum和pageSize
   ↓
计算offset = (pageNum-1) × pageSize
   ↓
执行SQL查询（带LIMIT）
   ↓
返回当前页数据
   ↓
展示给用户
```

---

## 4. 🔄 排序条件处理



### 4.1 排序的业务需求



**电商列表常见排序方式：**
```
📊 综合排序：默认排序（销量×评分×时间综合）
💰 价格排序：从低到高 或 从高到低
🔥 销量排序：卖得最好的在前面
⭐ 评分排序：评价最高的在前面  
🕐 时间排序：最新上架的在前面
```

**技术难点：**
```
问题1：排序字段不固定（用户可选）
问题2：排序方向不固定（升序ASC/降序DESC）
问题3：多字段组合排序（先按价格，再按销量）
```

### 4.2 单字段排序实现



```xml
<!-- 基础排序：按指定字段排序 -->
<select id="findWithSort" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 条件省略 -->
    </where>
    
    <!-- 动态排序 -->
    <if test="sortField != null and sortField != ''">
        ORDER BY
        <choose>
            <when test="sortField == 'price'">
                price
            </when>
            <when test="sortField == 'sales'">
                sales_count
            </when>
            <when test="sortField == 'rating'">
                rating
            </when>
            <otherwise>
                create_time
            </otherwise>
        </choose>
        
        <!-- 排序方向 -->
        <if test="sortOrder != null and sortOrder == 'desc'">
            DESC
        </if>
        <if test="sortOrder == null or sortOrder == 'asc'">
            ASC
        </if>
    </if>
</select>
```

**调用示例：**
```java
// 按价格从低到高排序
params.put("sortField", "price");
params.put("sortOrder", "asc");
生成SQL：ORDER BY price ASC

// 按销量从高到低排序  
params.put("sortField", "sales");
params.put("sortOrder", "desc");
生成SQL：ORDER BY sales_count DESC
```

### 4.3 多字段组合排序



**业务场景：**
```
需求：先按价格升序，价格相同时按销量降序

传统写法：
ORDER BY price ASC, sales_count DESC

动态SQL实现：
支持用户选择多种组合方式
```

**实现方案：**
```xml
<select id="multiSort" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 条件省略 -->
    </where>
    
    ORDER BY
    <!-- 主排序字段 -->
    <choose>
        <when test="primarySort == 'price'">price</when>
        <when test="primarySort == 'sales'">sales_count</when>
        <otherwise>create_time</otherwise>
    </choose>
    <if test="primaryOrder == 'desc'">DESC</if>
    <if test="primaryOrder != 'desc'">ASC</if>
    
    <!-- 次要排序字段 -->
    <if test="secondarySort != null and secondarySort != ''">
        ,
        <choose>
            <when test="secondarySort == 'price'">price</when>
            <when test="secondarySort == 'sales'">sales_count</when>
            <when test="secondarySort == 'rating'">rating</when>
        </choose>
        <if test="secondaryOrder == 'desc'">DESC</if>
        <if test="secondaryOrder != 'desc'">ASC</if>
    </if>
</select>
```

**⚠️ 安全性警告：**
```
❌ 错误做法：直接拼接用户输入
ORDER BY ${sortField} ${sortOrder}

风险：SQL注入攻击
用户传入：sortField = "1; DROP TABLE products--"

✅ 正确做法：使用<choose>白名单验证
只允许预定义的字段名
```

### 4.4 排序性能优化



**优化建议：**
| 场景 | 问题 | 解决方案 |
|------|------|---------|
| **频繁排序字段** | 查询慢 | 为排序字段建立索引 |
| **多字段排序** | 索引不生效 | 建立联合索引 |
| **大数据量排序** | 内存消耗大 | 使用覆盖索引 |
| **默认排序** | 每次都要写ORDER BY | 设置默认排序逻辑 |

```xml
<!-- 性能优化示例：有默认排序 -->
<select id="optimizedSort" resultType="Product">
    SELECT * FROM products
    <where>
        status = 1
    </where>
    
    <!-- 有指定排序就用指定的，否则用默认排序 -->
    <choose>
        <when test="sortField != null and sortField != ''">
            ORDER BY
            <!-- 用户指定的排序 -->
            <if test="sortField == 'price'">price</if>
            <if test="sortField == 'sales'">sales_count</if>
            <if test="sortOrder == 'desc'">DESC</if>
        </when>
        <otherwise>
            <!-- 默认：销量降序，相同销量按时间降序 -->
            ORDER BY sales_count DESC, create_time DESC
        </otherwise>
    </choose>
</select>
```

---

## 5. 🔎 模糊搜索优化



### 5.1 模糊搜索的常见问题



**什么是模糊搜索？**
```
精确搜索：搜"手机" → 只找product_name = "手机"
模糊搜索：搜"手机" → 找到"智能手机""手机壳""苹果手机"等

实现方式：LIKE关键字
```

**模糊搜索的三种模式：**
```
前缀匹配：LIKE '手机%'   → 找"手机壳""手机膜"
后缀匹配：LIKE '%手机'   → 找"智能手机""苹果手机"  
包含匹配：LIKE '%手机%'  → 找所有包含"手机"的
```

**性能对比：**
| 模式 | SQL示例 | 能用索引？ | 性能 |
|------|---------|----------|------|
| 前缀匹配 | `LIKE '手机%'` | ✅ 能 | 快 |
| 后缀匹配 | `LIKE '%手机'` | ❌ 不能 | 慢 |
| 包含匹配 | `LIKE '%手机%'` | ❌ 不能 | 很慢 |

### 5.2 基础模糊搜索实现



```xml
<!-- 商品名称模糊搜索 -->
<select id="searchByKeyword" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="keyword != null and keyword != ''">
            <!-- 方式1：使用CONCAT函数 -->
            product_name LIKE CONCAT('%', #{keyword}, '%')
        </if>
    </where>
</select>
```

**为什么用CONCAT函数？**
```
❌ 错误写法：
LIKE '%${keyword}%'
问题：${} 是字符串拼接，有SQL注入风险

✅ 正确写法：  
LIKE CONCAT('%', #{keyword}, '%')
优势：#{} 使用预编译，安全
```

### 5.3 多字段模糊搜索



**业务需求：**
```
搜索"手机" → 在商品名称、描述、品牌中都搜索
只要任何一个字段匹配就返回结果
```

**实现代码：**
```xml
<select id="multiFieldSearch" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="keyword != null and keyword != ''">
            (
                product_name LIKE CONCAT('%', #{keyword}, '%')
                OR description LIKE CONCAT('%', #{keyword}, '%')
                OR brand_name LIKE CONCAT('%', #{keyword}, '%')
            )
        </if>
    </where>
</select>
```

**注意事项：**
```
🔸 用括号包裹OR条件，避免逻辑错误
🔸 每个字段都要单独写LIKE
🔸 OR太多会影响性能，考虑全文索引
```

### 5.4 模糊搜索性能优化



**问题：**包含匹配`LIKE '%关键词%'`不走索引，大数据量时很慢

**优化方案1：前缀匹配优先**
```xml
<!-- 如果用户输入内容适合前缀匹配，就用前缀 -->
<select id="smartSearch" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="keyword != null and keyword != ''">
            <choose>
                <!-- 如果是型号搜索（通常前缀匹配），走索引 -->
                <when test="searchType == 'model'">
                    product_code LIKE CONCAT(#{keyword}, '%')
                </when>
                <!-- 其他情况用包含匹配 -->
                <otherwise>
                    product_name LIKE CONCAT('%', #{keyword}, '%')
                </otherwise>
            </choose>
        </if>
    </where>
</select>
```

**优化方案2：关键词预处理**
```xml
<!-- 去除特殊字符，提高匹配准确性 -->
<select id="cleanSearch" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="keyword != null and keyword != ''">
            <!-- 使用REPLACE去除空格等干扰字符 -->
            REPLACE(product_name, ' ', '') LIKE 
            CONCAT('%', REPLACE(#{keyword}, ' ', ''), '%')
        </if>
    </where>
</select>
```

**优化方案3：分词搜索**
```xml
<!-- 将关键词拆分成多个词，分别搜索 -->
<select id="tokenSearch" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="keywords != null and keywords.size() > 0">
            <foreach collection="keywords" item="word" 
                     open="(" separator=" AND " close=")">
                product_name LIKE CONCAT('%', #{word}, '%')
            </foreach>
        </if>
    </where>
</select>
```

**调用示例：**
```java
// 搜索"苹果手机"
String input = "苹果手机";
String[] words = input.split(" "); // ["苹果", "手机"]

// 生成SQL：
WHERE (product_name LIKE '%苹果%' AND product_name LIKE '%手机%')
// 必须同时包含"苹果"和"手机"
```

**大数据量解决方案：**
```
数据量 < 10万   → 普通LIKE搜索
数据量 10-100万 → 使用全文索引（FULLTEXT）
数据量 > 100万  → 引入搜索引擎（Elasticsearch）
```

---

## 6. 📏 范围查询处理



### 6.1 范围查询的类型



**常见的范围查询场景：**
```
📅 时间范围：查询2024-01-01 到 2024-12-31 的订单
💰 价格范围：查询1000-5000元的商品
📊 评分范围：查询评分4-5星的商品
📦 库存范围：查询库存10-100件的商品
```

**范围查询的SQL写法：**
```sql
-- 方式1：使用BETWEEN
WHERE price BETWEEN 1000 AND 5000

-- 方式2：使用比较运算符  
WHERE price >= 1000 AND price <= 5000

-- 方式3：只有下限或上限
WHERE price >= 1000
WHERE price <= 5000
```

### 6.2 基础范围查询



```xml
<!-- 价格区间查询 -->
<select id="findByPriceRange" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 最低价格 -->
        <if test="minPrice != null">
            AND price &gt;= #{minPrice}
        </if>
        
        <!-- 最高价格 -->
        <if test="maxPrice != null">
            AND price &lt;= #{maxPrice}
        </if>
    </where>
</select>
```

**使用场景分析：**
```
场景1：只传最低价 minPrice=1000
SQL：WHERE price >= 1000
含义：查找1000元以上的商品

场景2：只传最高价 maxPrice=5000
SQL：WHERE price <= 5000  
含义：查找5000元以下的商品

场景3：两个都传 minPrice=1000, maxPrice=5000
SQL：WHERE price >= 1000 AND price <= 5000
含义：查找1000-5000元的商品
```

### 6.3 时间范围查询



**日期类型的范围查询：**
```xml
<!-- 按创建时间范围查询订单 -->
<select id="findOrdersByDateRange" resultType="Order">
    SELECT * FROM orders
    <where>
        <!-- 开始时间 -->
        <if test="startDate != null">
            AND create_time &gt;= #{startDate}
        </if>
        
        <!-- 结束时间：注意要包含当天的23:59:59 -->
        <if test="endDate != null">
            AND create_time &lt;= DATE_ADD(#{endDate}, INTERVAL 1 DAY)
        </if>
    </where>
</select>
```

**时间范围常见问题：**
```
❌ 错误：结束时间直接用 <= endDate
问题：如果endDate是2024-01-01，会漏掉当天的数据

✅ 正确：结束时间加一天
DATE_ADD(#{endDate}, INTERVAL 1 DAY)
这样2024-01-01的数据也能查到
```

**时间范围快捷查询：**
```xml
<!-- 支持"今天""本周""本月"等快捷选项 -->
<select id="quickDateRange" resultType="Order">
    SELECT * FROM orders
    <where>
        <choose>
            <!-- 今天 -->
            <when test="dateRange == 'today'">
                AND DATE(create_time) = CURDATE()
            </when>
            
            <!-- 本周 -->
            <when test="dateRange == 'week'">
                AND YEARWEEK(create_time) = YEARWEEK(NOW())
            </when>
            
            <!-- 本月 -->
            <when test="dateRange == 'month'">
                AND DATE_FORMAT(create_time, '%Y-%m') = DATE_FORMAT(NOW(), '%Y-%m')
            </when>
            
            <!-- 自定义范围 -->
            <otherwise>
                <if test="startDate != null">
                    AND create_time &gt;= #{startDate}
                </if>
                <if test="endDate != null">
                    AND create_time &lt;= #{endDate}
                </if>
            </otherwise>
        </choose>
    </where>
</select>
```

### 6.4 多维度范围组合



**复杂业务场景：**
```
需求：查询商品
- 价格1000-5000元
- 库存50-200件
- 评分4-5星
- 创建时间最近30天
```

**实现代码：**
```xml
<select id="multiRangeQuery" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 价格范围 -->
        <if test="minPrice != null">
            AND price &gt;= #{minPrice}
        </if>
        <if test="maxPrice != null">
            AND price &lt;= #{maxPrice}
        </if>
        
        <!-- 库存范围 -->
        <if test="minStock != null">
            AND stock &gt;= #{minStock}
        </if>
        <if test="maxStock != null">
            AND stock &lt;= #{maxStock}
        </if>
        
        <!-- 评分范围 -->
        <if test="minRating != null">
            AND rating &gt;= #{minRating}
        </if>
        <if test="maxRating != null">
            AND rating &lt;= #{maxRating}
        </if>
        
        <!-- 时间范围：最近N天 -->
        <if test="recentDays != null">
            AND create_time &gt;= DATE_SUB(NOW(), INTERVAL #{recentDays} DAY)
        </if>
    </where>
</select>
```

**范围查询性能优化：**
```
🔸 为范围查询字段建立索引
CREATE INDEX idx_price ON products(price);
CREATE INDEX idx_create_time ON products(create_time);

🔸 使用联合索引优化多条件
CREATE INDEX idx_price_rating ON products(price, rating);

🔸 避免在范围字段上使用函数
❌ WHERE YEAR(create_time) = 2024  （不走索引）
✅ WHERE create_time >= '2024-01-01' （走索引）
```

---

## 7. 🔗 复合条件组合



### 7.1 什么是复合条件



**复合条件的定义：**
```
简单条件：单个筛选条件
WHERE price > 1000

复合条件：多个条件组合，有逻辑关系
WHERE (price > 1000 AND stock > 0) 
   OR (discount > 0 AND vip_price > 0)
```

**复合条件的逻辑关系：**
```
AND关系：必须同时满足
WHERE 条件1 AND 条件2 AND 条件3

OR关系：满足任意一个即可
WHERE 条件1 OR 条件2 OR 条件3

混合关系：AND和OR组合
WHERE (条件1 OR 条件2) AND 条件3
```

### 7.2 基础复合条件实现



**场景1：促销商品查询**
```
需求：查询正在促销的商品
条件1：有折扣（discount > 0）
条件2：或者有会员价（vip_price > 0）
条件3：并且库存充足（stock > 10）
```

```xml
<select id="findPromotionProducts" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 必须在售 -->
        status = 1
        
        <!-- 促销条件：有折扣或有会员价 -->
        AND (
            <trim prefixOverrides="OR">
                <if test="hasDiscount">
                    OR discount > 0
                </if>
                <if test="hasVipPrice">
                    OR vip_price > 0
                </if>
            </trim>
        )
        
        <!-- 库存条件 -->
        AND stock > 10
    </where>
</select>
```

**生成SQL示例：**
```sql
-- 都选时：
WHERE status = 1 
  AND (discount > 0 OR vip_price > 0)
  AND stock > 10

-- 只选有折扣：
WHERE status = 1
  AND (discount > 0)
  AND stock > 10
```

### 7.3 高级复合条件：多组条件



**场景2：VIP用户专享商品**
```
需求：查询VIP可购买的商品
条件组1（普通商品）：
  - 没有VIP限制
  - 库存 > 0
  
条件组2（VIP专享）：
  - 有VIP价格
  - 用户是VIP会员
```

```xml
<select id="findVipProducts" resultType="Product">
    SELECT * FROM products
    <where>
        status = 1
        AND (
            <!-- 条件组1：普通商品 -->
            (vip_only = 0 AND stock > 0)
            
            <!-- 条件组2：VIP专享商品 -->
            <if test="isVip">
                OR (vip_only = 1 AND vip_price > 0)
            </if>
        )
    </where>
</select>
```

**逻辑分析：**
```
普通用户：isVip = false
SQL：WHERE (vip_only = 0 AND stock > 0)
结果：只能看到普通商品

VIP用户：isVip = true  
SQL：WHERE (vip_only = 0 AND stock > 0) 
         OR (vip_only = 1 AND vip_price > 0)
结果：普通商品 + VIP专享商品
```

### 7.4 动态复合条件构建



**场景3：灵活的搜索组合**
```
用户可以选择：
✅ 搜索条件1：按名称或描述搜索
✅ 搜索条件2：指定分类
✅ 搜索条件3：价格区间
✅ 搜索条件4：库存状态

这些条件可以任意组合
```

```xml
<select id="flexibleSearch" resultType="Product">
    SELECT * FROM products
    <where>
        <trim prefix="(" suffix=")" prefixOverrides="AND|OR">
            <!-- 条件1：关键词搜索（OR关系） -->
            <if test="keyword != null and keyword != ''">
                (
                    product_name LIKE CONCAT('%', #{keyword}, '%')
                    OR description LIKE CONCAT('%', #{keyword}, '%')
                )
            </if>
            
            <!-- 条件2：分类筛选 -->
            <if test="categoryId != null">
                AND category_id = #{categoryId}
            </if>
            
            <!-- 条件3：价格区间 -->
            <if test="minPrice != null or maxPrice != null">
                AND (
                    <trim prefixOverrides="AND">
                        <if test="minPrice != null">
                            AND price &gt;= #{minPrice}
                        </if>
                        <if test="maxPrice != null">
                            AND price &lt;= #{maxPrice}
                        </if>
                    </trim>
                )
            </if>
            
            <!-- 条件4：库存状态 -->
            <if test="stockStatus != null">
                AND 
                <choose>
                    <when test="stockStatus == 'in_stock'">
                        stock > 0
                    </when>
                    <when test="stockStatus == 'low_stock'">
                        stock > 0 AND stock &lt;= 10
                    </when>
                    <when test="stockStatus == 'out_stock'">
                        stock = 0
                    </when>
                </choose>
            </if>
        </trim>
    </where>
</select>
```

**复合条件关系图：**
```
复合条件结构：

┌─────────────────────────────────────┐
│         WHERE 子句                  │
├─────────────────────────────────────┤
│                                     │
│  ┌──────────────┐                  │
│  │ 关键词搜索   │ (OR内部)         │
│  │ 名称 OR 描述 │                   │
│  └──────────────┘                  │
│         AND                         │
│  ┌──────────────┐                  │
│  │ 分类筛选     │                   │
│  └──────────────┘                  │
│         AND                         │
│  ┌──────────────┐                  │
│  │ 价格区间     │ (AND内部)        │
│  │ 最低 AND 最高│                   │
│  └──────────────┘                  │
│         AND                         │
│  ┌──────────────┐                  │
│  │ 库存状态     │ (CHOOSE选择)     │
│  └──────────────┘                  │
│                                     │
└─────────────────────────────────────┘
```

### 7.5 复合条件的注意事项



**常见错误和解决方案：**

| 问题 | 错误示例 | 正确做法 |
|------|---------|---------|
| **括号遗漏** | `WHERE a=1 OR b=2 AND c=3` | `WHERE a=1 OR (b=2 AND c=3)` |
| **逻辑混乱** | AND和OR混用不加括号 | 用括号明确优先级 |
| **空条件** | OR后面没有条件 | 用`<trim>`去除多余OR |
| **性能问题** | 太多OR导致全表扫描 | 考虑用IN或分开查询 |

**性能优化建议：**
```
🔸 把能走索引的条件放在AND的最前面
🔸 减少OR的使用，OR多了索引可能失效
🔸 复杂条件考虑分步查询后合并结果
🔸 使用EXPLAIN分析SQL执行计划
```

---

## 8. ⚡ 性能优化技巧



### 8.1 动态SQL的性能问题



**为什么动态SQL可能变慢？**
```
问题1：条件太多导致SQL复杂
WHERE a=1 AND b=2 AND c=3 AND d=4 ... (20个条件)

问题2：OR条件不走索引  
WHERE name LIKE '%关键词%' OR desc LIKE '%关键词%'

问题3：每次SQL都不同，缓存失效
第1次：WHERE category_id = 10
第2次：WHERE category_id = 10 AND price > 100
每次都要重新解析SQL
```

**性能问题的表现：**
```
⏱️ 查询响应时间 > 1秒
📈 数据库CPU使用率高
🔄 大量慢SQL日志
💾 执行计划频繁变化
```

### 8.2 索引优化策略



**核心原则：让SQL走索引**

**策略1：单字段索引**
```sql
-- 频繁作为查询条件的字段建索引
CREATE INDEX idx_category_id ON products(category_id);
CREATE INDEX idx_price ON products(price);
CREATE INDEX idx_create_time ON products(create_time);
```

**策略2：联合索引**
```sql
-- 多个条件经常一起使用，建联合索引
CREATE INDEX idx_category_price ON products(category_id, price);

-- 使用规则：遵循最左前缀原则
WHERE category_id = 10  -- 走索引✅
WHERE category_id = 10 AND price > 100  -- 走索引✅
WHERE price > 100  -- 不走索引❌（price不是最左）
```

**策略3：覆盖索引**
```sql
-- 查询的字段都在索引中，不需要回表
CREATE INDEX idx_cover ON products(category_id, price, product_name);

-- 这个查询不需要回表，速度快
SELECT product_name, price 
FROM products 
WHERE category_id = 10;
```

**MyBatis中的索引优化示例：**
```xml
<!-- 优化前：字段顺序不对，索引失效 -->
<select id="badQuery" resultType="Product">
    SELECT * FROM products
    WHERE price > #{minPrice}  -- price不是联合索引的最左字段
      AND category_id = #{categoryId}
</select>

<!-- 优化后：调整条件顺序，匹配索引 -->
<select id="goodQuery" resultType="Product">
    SELECT * FROM products
    WHERE category_id = #{categoryId}  -- 最左字段在前
      AND price > #{minPrice}
</select>
```

### 8.3 SQL语句优化



**优化1：避免SELECT ***
```xml
<!-- ❌ 不好的做法 -->
<select id="badSelect" resultType="Product">
    SELECT * FROM products WHERE id = #{id}
</select>

<!-- ✅ 好的做法：只查需要的字段 -->
<select id="goodSelect" resultType="Product">
    SELECT id, product_name, price, stock 
    FROM products 
    WHERE id = #{id}
</select>
```

**为什么不用SELECT *？**
```
问题1：传输数据量大，网络IO高
问题2：无法使用覆盖索引优化
问题3：字段变更时影响所有查询
```

**优化2：减少子查询**
```xml
<!-- ❌ 不好：使用子查询 -->
<select id="badSubQuery" resultType="Product">
    SELECT * FROM products
    WHERE category_id IN (
        SELECT id FROM categories WHERE parent_id = #{parentId}
    )
</select>

<!-- ✅ 好：使用JOIN -->
<select id="goodJoin" resultType="Product">
    SELECT p.* FROM products p
    INNER JOIN categories c ON p.category_id = c.id
    WHERE c.parent_id = #{parentId}
</select>
```

**优化3：优化LIKE查询**
```xml
<!-- ❌ 慢：前置通配符不走索引 -->
<select id="slowLike" resultType="Product">
    SELECT * FROM products
    WHERE product_name LIKE CONCAT('%', #{keyword}, '%')
</select>

<!-- ✅ 快：前缀匹配走索引 -->
<select id="fastLike" resultType="Product">
    SELECT * FROM products
    WHERE product_name LIKE CONCAT(#{keyword}, '%')
</select>

<!-- ✅ 更快：使用全文索引 -->
<select id="fulltextSearch" resultType="Product">
    SELECT * FROM products
    WHERE MATCH(product_name, description) AGAINST(#{keyword})
</select>
```

### 8.4 条件判断优化



**优化1：提前终止无效查询**
```xml
<!-- 添加必要性检查，避免无意义查询 -->
<select id="smartQuery" resultType="Product">
    <!-- 如果没有任何条件，直接返回空 -->
    <if test="categoryId == null and keyword == null and minPrice == null">
        SELECT * FROM products WHERE 1=0
    </if>
    
    <if test="categoryId != null or keyword != null or minPrice != null">
        SELECT * FROM products
        <where>
            <if test="categoryId != null">
                AND category_id = #{categoryId}
            </if>
            <if test="keyword != null">
                AND product_name LIKE CONCAT('%', #{keyword}, '%')
            </if>
            <if test="minPrice != null">
                AND price >= #{minPrice}
            </if>
        </where>
    </if>
</select>
```

**优化2：条件顺序优化**
```xml
<!-- 把最能过滤数据的条件放在前面 -->
<select id="orderOptimized" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 1. 先用索引字段过滤（快） -->
        <if test="categoryId != null">
            category_id = #{categoryId}
        </if>
        
        <!-- 2. 再用范围条件（较快） -->
        <if test="minPrice != null">
            AND price >= #{minPrice}
        </if>
        
        <!-- 3. 最后用模糊查询（慢） -->
        <if test="keyword != null">
            AND product_name LIKE CONCAT('%', #{keyword}, '%')
        </if>
    </where>
</select>
```

### 8.5 批量操作优化



**优化：批量查询代替循环查询**
```xml
<!-- ❌ 不好：循环调用，产生N条SQL -->
for (Integer id : idList) {
    Product product = mapper.findById(id);  // 循环查询
}

<!-- ✅ 好：一次性查询 -->
<select id="findByIds" resultType="Product">
    SELECT * FROM products
    WHERE id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
#        #{id}
    </foreach>
</select>
```

**性能对比：**
```
场景：查询100个商品

方式1：循环100次
耗时：100次 × 10ms = 1000ms

方式2：批量1次
耗时：1次 × 50ms = 50ms

提升：20倍速度
```

### 8.6 缓存策略



**MyBatis二级缓存配置：**
```xml
<!-- 在Mapper.xml中开启二级缓存 -->
<cache 
    eviction="LRU"           <!-- 缓存淘汰策略：最近最少使用 -->
    flushInterval="60000"    <!-- 刷新间隔：60秒 -->
    size="512"               <!-- 缓存对象数量 -->
    readOnly="true"/>        <!-- 只读缓存，性能更好 -->

<!-- 查询语句标记使用缓存 -->
<select id="findById" resultType="Product" useCache="true">
    SELECT * FROM products WHERE id = #{id}
</select>
```

**缓存使用建议：**
```
✅ 适合用缓存：
- 数据更新频率低（配置数据、字典表）
- 查询频率高（热点数据）
- 允许短时间数据不一致

❌ 不适合用缓存：
- 实时性要求高（订单状态、库存）
- 数据更新频繁
- 数据量特别大
```

**性能优化总结表：**

| 优化点 | 问题 | 解决方案 | 效果 |
|--------|------|---------|------|
| **索引** | 查询慢 | 建立合适的索引 | 查询提速10-100倍 |
| **SELECT** | 数据量大 | 只查必要字段 | 减少50%网络IO |
| **JOIN** | 子查询慢 | 改用JOIN | 提速2-5倍 |
| **LIKE** | 前置%不走索引 | 用前缀匹配或全文索引 | 提速10倍以上 |
| **批量** | 循环查询 | 批量IN查询 | 提速10-100倍 |
| **缓存** | 重复查询 | 使用MyBatis缓存 | 减少90%数据库访问 |

---

## 9. ❓ 常见问题解决



### 9.1 SQL注入问题



**什么是SQL注入？**
```
正常查询：WHERE username = 'admin'
恶意输入：username = "admin' OR '1'='1"
生成SQL：WHERE username = 'admin' OR '1'='1'
结果：OR '1'='1' 永远成立，绕过认证
```

**MyBatis中的安全问题：**
```xml
<!-- ❌ 危险：使用${} 直接拼接 -->
<select id="dangerous" resultType="User">
    SELECT * FROM users WHERE username = '${username}'
</select>

<!-- ✅ 安全：使用#{} 预编译 -->
<select id="safe" resultType="User">
    SELECT * FROM users WHERE username = #{username}
</select>
```

**#{}和${}的区别：**
| 符号 | 处理方式 | 是否安全 | 适用场景 |
|------|---------|---------|---------|
| `#{}` | 预编译参数 | ✅ 安全 | 传值（WHERE条件、INSERT值） |
| `${}` | 字符串替换 | ❌ 危险 | 传SQL片段（表名、字段名） |

**安全使用${}的场景：**
```xml
<!-- 动态表名：必须用${}，但要做白名单校验 -->
<select id="dynamicTable" resultType="Map">
    SELECT * FROM ${tableName}  <!-- 传入前要验证表名合法性 -->
    WHERE id = #{id}
</select>
```

**Java端白名单校验：**
```java
// Service层验证
public List<Map> queryDynamicTable(String tableName, Integer id) {
    // 白名单校验
    List<String> allowedTables = Arrays.asList("products", "orders", "users");
    if (!allowedTables.contains(tableName)) {
        throw new IllegalArgumentException("非法的表名");
    }
    
    return mapper.dynamicTable(tableName, id);
}
```

### 9.2 XML特殊字符问题



**问题：XML中不能直接写 < > &**
```xml
<!-- ❌ 错误：XML解析报错 -->
<if test="price > 100">
    AND price > #{maxPrice}
</if>

<!-- ✅ 方式1：使用转义字符 -->
<if test="price &gt; 100">
    AND price &gt; #{maxPrice}
</if>

<!-- ✅ 方式2：使用CDATA -->
<if test="price > 100">
    <![CDATA[
        AND price > #{maxPrice}
    ]]>
</if>
```

**常用转义字符表：**
| 符号 | 转义写法 | 说明 |
|------|---------|------|
| `<` | `&lt;` | 小于 |
| `>` | `&gt;` | 大于 |
| `&` | `&amp;` | 与 |
| `'` | `&apos;` | 单引号 |
| `"` | `&quot;` | 双引号 |

### 9.3 空值和NULL判断



**问题：空字符串和NULL的区别**
```java
String keyword = "";     // 空字符串，不是NULL
String keyword2 = null;  // NULL值
```

**正确的判断方式：**
```xml
<!-- ❌ 不完整：只判断NULL -->
<if test="keyword != null">
    AND product_name LIKE CONCAT('%', #{keyword}, '%')
</if>

<!-- ✅ 完整：同时判断NULL和空串 -->
<if test="keyword != null and keyword != ''">
    AND product_name LIKE CONCAT('%', #{keyword}, '%')
</if>

<!-- ✅ 更严谨：去除空格后判断 -->
<if test="keyword != null and keyword.trim() != ''">
    AND product_name LIKE CONCAT('%', #{keyword}, '%')
</if>
```

**集合类型的判断：**
```xml
<!-- List/Array的判断 -->
<if test="categoryIds != null and categoryIds.size() > 0">
    AND category_id IN
    <foreach collection="categoryIds" item="id" open="(" close=")" separator=",">
#        #{id}
    </foreach>
</if>
```

### 9.4 参数传递问题



**问题1：单个参数不需要@Param**
```java
// Mapper接口
Product findById(Integer id);

// XML中可以直接用任意名称
<select id="findById" resultType="Product">
    SELECT * FROM products WHERE id = #{id}
    <!-- 或者 #{value}、#{abc} 都可以 -->
</select>
```

**问题2：多个参数必须用@Param**
```java
// ❌ 错误：多参数不用@Param
List<Product> search(String name, Integer categoryId);

// ✅ 正确：使用@Param注解
List<Product> search(
    @Param("name") String name,
    @Param("categoryId") Integer categoryId
);
```

```xml
<select id="search" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="name != null">
            AND product_name = #{name}
        </if>
        <if test="categoryId != null">
            AND category_id = #{categoryId}
        </if>
    </where>
</select>
```

**问题3：Map传参的注意事项**
```java
// 使用Map传参
Map<String, Object> params = new HashMap<>();
params.put("keyword", "手机");
params.put("minPrice", 1000);
List<Product> list = mapper.search(params);
```

```xml
<!-- Map的key就是参数名 -->
<select id="search" parameterType="map" resultType="Product">
    SELECT * FROM products
    <where>
        <if test="keyword != null">
            AND product_name LIKE CONCAT('%', #{keyword}, '%')
        </if>
        <if test="minPrice != null">
            AND price >= #{minPrice}
        </if>
    </where>
</select>
```

### 9.5 性能调试技巧



**技巧1：开启SQL日志**
```properties
# application.properties

# 打印完整SQL（包括参数值）

mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# 或者配置log4j

log4j.logger.com.yourpackage.mapper=DEBUG
```

**输出效果：**
```
==>  Preparing: SELECT * FROM products WHERE category_id = ? AND price >= ?
==> Parameters: 10(Integer), 1000(Integer)
<==      Total: 25
```

**技巧2：使用EXPLAIN分析SQL**
```xml
<!-- 在SQL前加EXPLAIN查看执行计划 -->
<select id="analyze" resultType="Product">
    EXPLAIN SELECT * FROM products
    WHERE category_id = #{categoryId}
      AND price >= #{minPrice}
</select>
```

**技巧3：记录慢SQL**
```xml
<!-- MyBatis拦截器记录慢SQL -->
<plugins>
    <plugin interceptor="com.example.SlowSqlInterceptor">
        <property name="slowSqlTime" value="1000"/> <!-- 超过1秒记录 -->
    </plugin>
</plugins>
```

**常见性能问题排查：**
```
问题现象              可能原因                   解决方案
────────────────────────────────────────────────────
查询超过1秒          缺少索引                   添加索引
返回数据过多         没有分页                   添加LIMIT
CPU占用高            全表扫描                   优化WHERE条件
内存占用大           一次查询太多数据           分批查询
连接数过多           没有使用连接池             配置连接池
```

---

## 10. 📋 核心要点总结



### 10.1 必须掌握的核心技能



**🎯 动态SQL的四大应用场景：**
```
1️⃣ 多条件查询：用<if>、<where>灵活组合条件
2️⃣ 分页查询：计算offset，使用LIMIT分页
3️⃣ 排序查询：用<choose>安全处理ORDER BY
4️⃣ 批量操作：用<foreach>处理IN查询和批量插入
```

**🔑 五个关键技术点：**

| 技术点 | 核心要点 | 记忆口诀 |
|--------|---------|---------|
| **<if>标签** | 条件判断，支持and/or逻辑 | 有条件才加WHERE |
| **<where>标签** | 智能去掉多余AND | WHERE自动管理 |
| **<trim>标签** | 灵活处理前缀后缀 | 前后缀修剪器 |
| **<choose>标签** | 类似switch，单选 | 多选一用choose |
| **<foreach>标签** | 循环处理集合 | 批量靠循环 |

### 10.2 实战经验总结



**✅ 最佳实践清单：**
```
🔸 安全性：永远用#{}不用${}传值
🔸 性能：为查询条件字段建索引
🔸 可读性：复杂条件用括号分组
🔸 健壮性：NULL和空串都要判断
🔸 效率：批量操作替代循环查询
🔸 维护性：SQL片段用<sql>复用
```

**❌ 常见错误避坑：**
```
❌ 忘记判断空字符串，只判断NULL
❌ XML中直接写 < > 不转义
❌ 动态排序用${}不做白名单验证
❌ 多个参数不加@Param注解
❌ 模糊查询前置%导致索引失效
❌ 循环调用Mapper造成N+1问题
```

### 10.3 性能优化要点



**🚀 性能优化三板斧：**
```
第一步：建索引
✅ 单字段索引：频繁查询的字段
✅ 联合索引：组合查询的字段
✅ 覆盖索引：包含查询所需全部字段

第二步：优化SQL
✅ 避免SELECT *，只查需要的字段
✅ 用JOIN代替子查询
✅ 前缀匹配代替包含匹配（LIKE）

第三步：减少查询
✅ 批量查询代替循环
✅ 使用MyBatis二级缓存
✅ 提前终止无效查询
```

### 10.4 知识体系架构



**动态SQL知识体系图：**
```
                    动态SQL实战
                        │
        ┌───────────────┼───────────────┐
        │               │               │
    基础应用        进阶技巧        性能优化
        │               │               │
    ┌───┴───┐       ┌───┴───┐       ┌───┴───┐
    │       │       │       │       │       │
  多条件  分页    排序   模糊     索引   批量
  查询    查询    处理   搜索     优化   操作
    │       │       │       │       │       │
  <if>   LIMIT  <choose> LIKE   字段   <foreach>
  <where> offset  白名单  前缀   顺序   IN查询
```

### 10.5 学习路径建议



**📚 从入门到精通：**
```
第一阶段：基础掌握（1-2周）
→ 熟练使用<if>、<where>、<choose>标签
→ 理解#{}和${}的区别
→ 掌握基础多条件查询

第二阶段：进阶应用（2-3周）
→ 实现分页、排序、模糊搜索
→ 掌握<foreach>批量操作
→ 学会复合条件组合

第三阶段：性能优化（持续）
→ 学习索引优化原理
→ 掌握SQL性能分析
→ 熟悉缓存使用场景
```

### 10.6 快速参考手册



**🔖 标签速查表：**

```
标签              用途                   示例
──────────────────────────────────────────────────────
<if>            条件判断              test="id != null"
<where>         智能WHERE            自动去掉AND/OR
<trim>          前后缀处理            prefix="WHERE"
<choose>        多分支选择            类似switch
<foreach>       循环集合              处理IN/批量
<set>           智能UPDATE           自动去掉逗号
<sql>           SQL片段复用          include引用
<bind>          变量定义              name="pattern"
```

**🎯 常用判断条件：**

```java
// NULL判断
test="param != null"

// 空字符串判断  
test="param != null and param != ''"

// 集合判断
test="list != null and list.size() > 0"

// 数值判断
test="price > 1000"
test="price >= minPrice and price <= maxPrice"

// 字符串判断
test="status == 'active'"
test="type.equals('vip')"

// 逻辑组合
test="(a != null and a > 0) or (b != null and b > 0)"
```

**💡 实用SQL片段：**

```xml
<!-- 通用分页 -->
<sql id="pagination">
    <if test="offset != null and pageSize != null">
        LIMIT #{offset}, #{pageSize}
    </if>
</sql>

<!-- 通用排序 -->
<sql id="orderBy">
    <if test="sortField != null and sortField != ''">
        ORDER BY ${sortField}
        <if test="sortOrder == 'desc'">DESC</if>
        <if test="sortOrder != 'desc'">ASC</if>
    </if>
</sql>

<!-- 时间范围 -->
<sql id="dateRange">
    <if test="startDate != null">
        AND create_time >= #{startDate}
    </if>
    <if test="endDate != null">
        AND create_time &lt;= #{endDate}
    </if>
</sql>

<!-- 使用方式 -->
<select id="query" resultType="Product">
    SELECT * FROM products
    <where>
        <!-- 其他条件 -->
    </where>
    <include refid="orderBy"/>
    <include refid="pagination"/>
</select>
```

### 10.7 调试技巧总结



**🔍 问题排查流程：**

```
遇到问题时的排查步骤：

步骤1：查看SQL日志
    ↓
确认生成的SQL是否正确
    ↓
步骤2：检查参数值
    ↓  
确认传入的参数是否符合预期
    ↓
步骤3：简化条件测试
    ↓
逐个去掉条件，找出问题条件
    ↓
步骤4：使用EXPLAIN分析
    ↓
查看SQL执行计划，找性能瓶颈
    ↓
步骤5：检查索引使用
    ↓
确认查询是否走索引
```

**🛠️ 常用调试命令：**

```sql
-- 查看SQL执行计划
EXPLAIN SELECT * FROM products WHERE category_id = 10;

-- 查看索引使用情况
SHOW INDEX FROM products;

-- 查看表结构
DESC products;

-- 分析表
ANALYZE TABLE products;

-- 查看慢查询
SHOW VARIABLES LIKE 'slow_query%';
```

### 10.8 实战案例总结



**📝 典型应用场景回顾：**

**场景1：电商商品搜索**
```
需求：支持名称、分类、价格、品牌等多条件组合搜索
技术：<if> + <where> + <foreach>
优化：索引 + 前缀匹配LIKE
```

**场景2：后台管理列表**
```
需求：分页、排序、筛选、导出
技术：LIMIT分页 + <choose>排序 + 动态条件
优化：覆盖索引 + 批量查询
```

**场景3：数据统计报表**
```
需求：按时间、分类、状态等维度统计
技术：GROUP BY + 动态条件 + 日期函数
优化：避免子查询 + 合理使用临时表
```

**场景4：批量数据处理**
```
需求：批量插入、更新、删除
技术：<foreach> + BATCH模式
优化：控制批次大小 + 事务处理
```

### 10.9 核心记忆口诀



```
🎵 动态SQL记忆歌：

条件判断用if，空值检查要仔细
where标签管AND，多余连接自动去
choose好比是switch，多选一来很适宜
foreach循环集合用，批量操作效率奇

井号#防注入，美元$要慎用
特殊字符要转义，小于大于别忘记
索引优化是关键，前缀匹配走得快
批量查询代循环，性能提升立竿影

参数传递加Param，多个参数不能忘
SQL片段可复用，include引用真方便
日志开启好调试，EXPLAIN分析要常用
安全性能都兼顾，动态SQL用得妙
```

### 10.10 进阶学习资源



**📖 推荐学习路径：**

```
当前阶段：动态SQL实战 ✅

下一步学习：
1️⃣ MyBatis缓存机制（一级/二级缓存）
2️⃣ MyBatis插件开发（拦截器）
3️⃣ MyBatis-Plus（增强工具）
4️⃣ 分库分表方案（ShardingSphere）

实战项目建议：
→ 电商搜索系统（多条件+分页+排序）
→ 后台管理系统（CRUD+动态查询）
→ 数据报表系统（复杂统计查询）
```

**🎓 能力提升检查表：**

```
✅ 基础能力：
□ 能独立完成多条件查询
□ 能实现分页和排序功能
□ 能处理模糊搜索和范围查询
□ 理解动态SQL的工作原理

✅ 进阶能力：
□ 能优化复杂SQL的性能
□ 能处理SQL注入安全问题
□ 能设计合理的索引方案
□ 能解决常见的性能瓶颈

✅ 高级能力：
□ 能设计大型项目的数据访问层
□ 能进行SQL执行计划分析
□ 能实现MyBatis拦截器
□ 能处理分库分表场景
```

---

# 🎊 学习总结



恭喜你完成了 **MyBatis动态SQL实战案例** 的学习！

**你已经掌握：**
- ✅ 8种核心实战场景的解决方案
- ✅ 动态SQL的性能优化技巧
- ✅ 常见问题的排查和解决方法
- ✅ 生产环境的最佳实践经验

**实践建议：**
```
理论 + 实践 = 真正掌握

1. 找个实际项目练手
2. 遇到问题查文档
3. 性能问题用EXPLAIN分析
4. 多看优秀代码的写法
5. 总结自己的最佳实践
```

**记住核心原则：**
```
🔸 安全第一：防止SQL注入
🔸 性能优先：合理使用索引
🔸 可读性好：代码清晰易维护
🔸 健壮性强：处理各种边界情况
```

继续加油，祝你在MyBatis的学习道路上越走越远！🚀