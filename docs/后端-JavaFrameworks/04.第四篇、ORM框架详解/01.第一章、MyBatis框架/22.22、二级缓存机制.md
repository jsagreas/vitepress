---
title: 22、二级缓存机制
---
## 📚 目录

1. [什么是二级缓存](#1-什么是二级缓存)
2. [二级缓存的配置与使用](#2-二级缓存的配置与使用)
3. [缓存淘汰策略详解](#3-缓存淘汰策略详解)
4. [序列化与缓存一致性](#4-序列化与缓存一致性)
5. [缓存问题与解决方案](#5-缓存问题与解决方案)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🌐 什么是二级缓存


### 1.1 二级缓存的本质理解


**🔸 通俗理解：二级缓存就像"部门共享的资料柜"**

想象一个公司场景：
```
一级缓存 = 个人办公桌（每个人自己用）
  张三查文件 → 放在自己桌上 → 下次直接拿

二级缓存 = 部门资料柜（整个部门共享）
  张三查的文件 → 放进部门柜子 → 李四也能直接拿
```

**核心区别**：
- **一级缓存**：`SqlSession`级别，只有当前会话能用
- **二级缓存**：`namespace`级别，同一个Mapper的所有会话都能共享

### 1.2 作用范围对比


```
数据库层面的缓存关系：

┌─────────────────────────────────────┐
│         应用程序                     │
│  ┌─────────┐      ┌─────────┐      │
│  │SqlSession1│    │SqlSession2│    │
│  │(一级缓存)│    │(一级缓存)│    │
│  └─────────┘      └─────────┘      │
│         ↓              ↓            │
│  ┌─────────────────────────┐       │
│  │   二级缓存(namespace)    │       │
│  │   UserMapper共享区域     │       │
│  └─────────────────────────┘       │
│              ↓                      │
└──────────────────────────────────────┘
               ↓
        ┌──────────┐
        │  数据库   │
        └──────────┘

数据流向：
1. SqlSession先查一级缓存
2. 未命中查二级缓存
3. 都没有才查数据库
```

### 1.3 为什么需要二级缓存


**实际应用场景**：

🔸 **场景1：用户信息查询**
```
张三登录系统 → 查询用户信息 → 放入一级缓存
张三退出登录 → SqlSession关闭 → 一级缓存消失

李四登录系统 → 查询同样的用户信息 → 又要查数据库？
如果有二级缓存 → 直接从缓存拿 → 节省数据库压力
```

🔸 **场景2：字典数据查询**
```
系统中的省市区数据、状态码等很少变化
多个用户频繁查询这些数据
使用二级缓存可以大幅提升性能
```

**性能提升对比**：
```
无缓存：    1000次查询 → 1000次数据库访问
一级缓存：  1000次查询 → 10个Session → 10次数据库访问
二级缓存：  1000次查询 → 共享缓存 → 1次数据库访问
```

---

## 2. ⚙️ 二级缓存的配置与使用


### 2.1 开启二级缓存的三步曲


**步骤一：开启全局缓存开关**

在 `mybatis-config.xml` 中配置：

```xml
<settings>
    <!-- 开启二级缓存总开关，默认就是true -->
    <setting name="cacheEnabled" value="true"/>
</settings>
```

> 💡 **说明**：这是全局开关，控制整个MyBatis是否支持二级缓存

**步骤二：在Mapper文件中添加cache标签**

```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    
    <!-- 开启当前Mapper的二级缓存 -->
    <cache/>
    
    <!-- 你的SQL语句 -->
    <select id="getUserById" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>
</mapper>
```

**步骤三：实体类实现序列化接口**

```java
// User实体类必须实现Serializable
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private Integer id;
    private String username;
    private String email;
    
    // getter/setter...
}
```

> ⚠️ **为什么要序列化？**
> 
> 缓存数据需要存储和传输，序列化就是把对象转成可以保存的格式

### 2.2 cache标签详细配置


**🔧 完整配置示例**：

```xml
<cache
    eviction="LRU"           <!-- 淘汰策略 -->
    flushInterval="60000"    <!-- 刷新间隔(毫秒) -->
    size="512"               <!-- 缓存对象数量 -->
    readOnly="false"/>       <!-- 是否只读 -->
```

**各参数详解**：

| 参数 | 含义 | 可选值 | 默认值 |
|------|------|--------|--------|
| `eviction` | 淘汰策略 | LRU/FIFO/SOFT/WEAK | LRU |
| `flushInterval` | 刷新间隔 | 毫秒数 | 不自动刷新 |
| `size` | 缓存大小 | 正整数 | 1024 |
| `readOnly` | 只读模式 | true/false | false |

### 2.3 readOnly参数详解


**只读模式的区别**：

```
readOnly="true" (只读模式)
┌─────────────────────────────────┐
│ 缓存 → 直接返回引用 → 速度快     │
│                                 │
│ 优点：性能高                     │
│ 缺点：所有人拿到同一个对象引用   │
│      一人修改，所有人都受影响    │
└─────────────────────────────────┘

readOnly="false" (读写模式，默认)
┌─────────────────────────────────┐
│ 缓存 → 序列化复制 → 返回副本     │
│                                 │
│ 优点：每人拿到独立副本，安全     │
│ 缺点：需要序列化，性能稍低       │
└─────────────────────────────────┘
```

**使用建议**：
- 只查询不修改的数据 → 可用 `readOnly="true"`
- 查询后可能修改的数据 → 必须用 `readOnly="false"`

---

## 3. 🔄 缓存淘汰策略详解


### 3.1 四种淘汰策略对比


**策略选择就像整理房间**：

```
房间满了，要扔东西，怎么选择扔什么？

LRU  → 扔掉最久没用的东西
FIFO → 扔掉最早放进来的东西  
SOFT → 等内存不够时系统自动扔
WEAK → 随时可能被系统扔掉
```

**🔸 LRU（Least Recently Used）最近最少使用**

```
工作原理：记录每个数据的使用时间，淘汰最久没用的

示例过程：
缓存容量=3，依次访问：A→B→C→D

步骤1: 访问A   [A]
步骤2: 访问B   [A, B]
步骤3: 访问C   [A, B, C]    缓存满了
步骤4: 访问D   [B, C, D]    淘汰A(最久没用)
步骤5: 访问B   [C, D, B]    B移到最新
步骤6: 访问E   [D, B, E]    淘汰C
```

**配置方式**：
```xml
<cache eviction="LRU"/>  <!-- 默认策略，最常用 -->
```

**🔸 FIFO（First In First Out）先进先出**

```
工作原理：像排队，先来的先走

示例过程：
缓存容量=3，依次访问：A→B→C→D

步骤1: 访问A   [A]
步骤2: 访问B   [A, B]
步骤3: 访问C   [A, B, C]    缓存满了
步骤4: 访问D   [B, C, D]    淘汰A(最早进入)
步骤5: 访问A   [C, D, A]    淘汰B(最早的)
```

**配置方式**：
```xml
<cache eviction="FIFO"/>  <!-- 简单粗暴，不常用 -->
```

**🔸 SOFT（软引用）与 WEAK（弱引用）**

```
SOFT软引用：
- JVM内存不足时才清理
- 适合缓存大对象
- 更长的生命周期

WEAK弱引用：
- 垃圾回收就清理
- 缓存生命周期很短
- 几乎不用
```

**配置方式**：
```xml
<cache eviction="SOFT"/>  <!-- 内存敏感场景 -->
<cache eviction="WEAK"/>  <!-- 基本不用 -->
```

### 3.2 淘汰策略选择指南


| 场景 | 推荐策略 | 原因 |
|------|----------|------|
| **热点数据查询** | LRU | 常用数据保留，冷数据淘汰 |
| **顺序数据处理** | FIFO | 按时间顺序淘汰即可 |
| **大对象缓存** | SOFT | 内存紧张时才释放 |
| **一般情况** | LRU | 默认即可，适用性最广 |

### 3.3 刷新间隔配置


**flushInterval：定时清空缓存**

```xml
<!-- 每60秒自动清空缓存 -->
<cache flushInterval="60000"/>
```

**使用场景**：
```
适合：数据有定时更新规律
例如：每小时更新一次的统计数据

不适合：实时性要求高的数据
例如：订单状态、库存数量
```

**完整配置示例**：

```xml
<!-- 电商商品分类缓存配置 -->
<cache 
    eviction="LRU"           <!-- 最近最少使用 -->
    flushInterval="1800000"  <!-- 30分钟刷新 -->
    size="256"               <!-- 缓存256个对象 -->
    readOnly="true"/>        <!-- 只读，性能更好 -->
```

---

## 4. 🔐 序列化与缓存一致性


### 4.1 为什么必须序列化


**🔸 序列化的本质理解**

```
不序列化的问题：
┌──────────────────────────────┐
│ 内存中的对象                  │
│ User user = new User();      │
│ ↓                            │
│ 缓存如何存储这个对象？        │
│ 对象关闭后内存地址就失效了    │
└──────────────────────────────┘

序列化后：
┌──────────────────────────────┐
│ 对象 → 转成字节流 → 可以存储  │
│ 需要时 → 反序列化 → 恢复对象  │
│ 这样缓存才能长期保存数据      │
└──────────────────────────────┘
```

**正确的实体类写法**：

```java
public class User implements Serializable {
    // 序列化版本号，用于版本控制
    private static final long serialVersionUID = 1L;
    
    private Integer id;
    private String username;
    private String email;
    private Date createTime;
    
    // getter和setter方法
}
```

> 💡 **serialVersionUID的作用**：
> - 标识类的版本
> - 升级类结构时，如果版本号一致，可以兼容旧缓存
> - 如果不一致，旧缓存会失效

### 4.2 缓存一致性问题


**🔸 问题1：跨会话的数据不一致**

```
场景演示：

会话1：查询用户 → 缓存User(name=张三)
会话2：更新用户 → 数据库改成name=李四
会话3：查询用户 → 从缓存拿到User(name=张三)  ❌ 脏数据！
```

**解决方案：自动刷新缓存**

MyBatis的智能处理：
```
任何 INSERT、UPDATE、DELETE 操作
↓
自动清空该namespace的二级缓存
↓
下次查询重新从数据库加载
```

**代码示例**：

```xml
<mapper namespace="com.example.mapper.UserMapper">
    <cache/>
    
    <!-- 查询语句，会使用缓存 -->
    <select id="getUserById" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>
    
    <!-- 更新语句，会清空缓存 -->
    <update id="updateUser">
        UPDATE user SET username = #{username} 
        WHERE id = #{id}
    </update>
</mapper>
```

**🔸 问题2：多表关联的缓存一致性**

```
场景：用户表 + 订单表

UserMapper缓存了用户数据
OrderMapper更新了订单（包含用户ID）
UserMapper缓存的用户订单数量还是旧的！
```

**解决方案：使用cache-ref**

```xml
<!-- OrderMapper.xml -->
<mapper namespace="com.example.mapper.OrderMapper">
    <!-- 引用UserMapper的缓存 -->
    <cache-ref namespace="com.example.mapper.UserMapper"/>
    
    <!-- 更新订单时，也会清空UserMapper的缓存 -->
    <update id="createOrder">
        INSERT INTO order VALUES (...)
    </update>
</mapper>
```

### 4.3 控制缓存的使用


**🔸 禁用某个查询的二级缓存**

```xml
<!-- 实时性要求高的查询，不使用缓存 -->
<select id="getUserBalance" useCache="false">
    SELECT balance FROM user WHERE id = #{id}
</select>
```

**🔸 控制是否刷新缓存**

```xml
<!-- 更新操作默认刷新缓存 -->
<update id="updateUser" flushCache="true">
    UPDATE user SET username = #{username} WHERE id = #{id}
</update>

<!-- 特殊情况：查询也可以刷新缓存 -->
<select id="getLatestData" flushCache="true">
    SELECT * FROM realtime_data
</select>
```

---

## 5. 🛡️ 缓存问题与解决方案


### 5.1 缓存穿透问题


**🔸 什么是缓存穿透？**

```
缓存穿透：查询不存在的数据

正常流程：
查询ID=1 → 缓存没有 → 查数据库有 → 放入缓存 ✓

穿透流程：
查询ID=9999 → 缓存没有 → 查数据库也没有 → 不缓存
下次查ID=9999 → 缓存还是没有 → 又查数据库 ❌
恶意用户疯狂查询不存在的ID → 缓存失效 → 数据库崩溃
```

**解决方案1：缓存空值**

```java
// Mapper接口
User getUserById(Integer id);

// Service层处理
public User getUserById(Integer id) {
    User user = userMapper.getUserById(id);
    
    // 即使查不到，也返回一个空对象
    if (user == null) {
        user = new User();  // 空对象
        user.setId(id);
    }
    return user;
}
```

**解决方案2：布隆过滤器**

```
在缓存前加一层布隆过滤器：

请求 → 布隆过滤器判断 → 数据库中肯定不存在 → 直接拒绝
                     → 可能存在 → 查缓存/数据库
```

### 5.2 缓存雪崩问题


**🔸 什么是缓存雪崩？**

```
缓存雪崩：大量缓存同时失效

场景：
1. 系统启动，所有缓存都是空的
2. 突然大量请求涌入
3. 所有请求都打到数据库
4. 数据库瞬间压力巨大，可能崩溃
```

**防护方案：**

**方案1：设置随机过期时间**

```xml
<!-- 不要让所有缓存同时过期 -->
<cache flushInterval="60000"/>  ❌ 所有缓存60秒后同时过期

<!-- 在应用层加随机时间 -->
```

```java
// 在刷新间隔基础上加随机时间
int baseTime = 60000;  // 60秒
int randomTime = new Random().nextInt(10000);  // 0-10秒
int actualTime = baseTime + randomTime;
```

**方案2：缓存预热**

```java
// 系统启动时，提前加载热点数据
@PostConstruct
public void cacheWarmUp() {
    // 加载常用的省市区数据
    List<Province> provinces = provinceMapper.getAllProvinces();
    
    // 加载热门商品
    List<Product> hotProducts = productMapper.getHotProducts();
    
    // 这些数据会进入缓存，避免启动时的雪崩
}
```

**方案3：限流降级**

```
使用Sentinel等框架：

大量请求涌入 → 限流 → 部分请求排队
            → 降级 → 返回默认数据
            → 保护数据库不被打垮
```

### 5.3 多级缓存架构


**实际生产环境的缓存方案**：

```
完整的缓存架构：

┌────────────────────────────────────┐
│         浏览器缓存（前端）          │
└────────────────────────────────────┘
                ↓
┌────────────────────────────────────┐
│         Nginx缓存（静态资源）       │
└────────────────────────────────────┘
                ↓
┌────────────────────────────────────┐
│         Redis缓存（分布式）         │  ← 推荐用这个
└────────────────────────────────────┘
                ↓
┌────────────────────────────────────┐
│      MyBatis二级缓存（本地）        │  ← 辅助使用
└────────────────────────────────────┘
                ↓
┌────────────────────────────────────┐
│      MyBatis一级缓存（会话）        │  ← 默认开启
└────────────────────────────────────┘
                ↓
┌────────────────────────────────────┐
│            数据库                   │
└────────────────────────────────────┘
```

**使用建议**：

| 缓存类型 | 适用场景 | 注意事项 |
|----------|----------|----------|
| **一级缓存** | 事务内重复查询 | 默认开启，不需配置 |
| **二级缓存** | 单应用，读多写少 | 注意一致性问题 |
| **Redis缓存** | 分布式系统必用 | 性能好，功能强大 |
| **CDN缓存** | 静态资源 | 图片、CSS、JS等 |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 二级缓存作用域：namespace级别，同一Mapper共享
🔸 开启条件：全局开关 + Mapper标签 + 实体序列化
🔸 淘汰策略：LRU最常用，FIFO简单，SOFT内存敏感
🔸 序列化要求：实体类必须实现Serializable接口
🔸 自动刷新：增删改操作自动清空缓存
```

### 6.2 配置参数速查表


| 参数 | 作用 | 推荐值 | 说明 |
|------|------|--------|------|
| `cacheEnabled` | 全局开关 | true | mybatis-config.xml配置 |
| `eviction` | 淘汰策略 | LRU | 最近最少使用 |
| `flushInterval` | 刷新间隔 | 不设置 | 依靠增删改自动刷新 |
| `size` | 缓存大小 | 512-1024 | 根据数据量调整 |
| `readOnly` | 只读模式 | false | 安全第一，性能其次 |

### 6.3 关键理解要点


**🔹 什么时候用二级缓存？**
```
适合场景：
✅ 读多写少的数据（字典表、配置表）
✅ 单应用系统
✅ 数据一致性要求不是特别高

不适合场景：
❌ 分布式系统（用Redis替代）
❌ 实时性要求高的数据
❌ 频繁更新的数据
```

**🔹 缓存一致性如何保证？**
```
MyBatis的处理：
1. 同namespace的增删改 → 自动清空缓存
2. 不同namespace关联 → 使用cache-ref
3. 实时数据 → 设置useCache="false"
```

**🔹 为什么需要序列化？**
```
序列化的作用：
对象 → 字节流 → 可以存储和传输
字节流 → 对象 → 可以恢复使用

不序列化的后果：
缓存无法保存对象数据
readOnly=false模式无法工作
```

### 6.4 实战最佳实践


**推荐的缓存配置模板**：

```xml
<!-- 适合大多数场景的配置 -->
<cache 
    eviction="LRU"      <!-- 最常用的淘汰策略 -->
    size="512"          <!-- 中等缓存容量 -->
    readOnly="false"/>  <!-- 安全模式 -->
```

**分场景配置建议**：

```xml
<!-- 场景1：字典数据（省市区、状态码） -->
<cache 
    eviction="LRU"
    size="256"
    readOnly="true"           <!-- 只读数据，性能优先 -->
    flushInterval="3600000"/> <!-- 1小时刷新 -->

<!-- 场景2：用户数据 -->
<cache 
    eviction="LRU"
    size="1024"
    readOnly="false"/>        <!-- 可能被修改，安全优先 -->

<!-- 场景3：实时数据 -->
<!-- 不开启二级缓存，或单个查询禁用 -->
<select id="getRealTimeData" useCache="false">
    SELECT * FROM realtime_table
</select>
```

### 6.5 常见问题速查


**Q1：为什么开启了二级缓存还是查数据库？**
```
检查清单：
□ cacheEnabled=true？
□ Mapper中有<cache/>标签？
□ 实体类实现了Serializable？
□ SqlSession提交了事务？（commit()）
```

**Q2：如何调试缓存是否生效？**
```
开启日志：
<setting name="logImpl" value="STDOUT_LOGGING"/>

观察日志：
Cache Hit Ratio [com.example.mapper.UserMapper]: 0.5
命中率0.5 = 50%的查询走了缓存
```

**Q3：多表关联如何保证缓存一致性？**
```
使用cache-ref：
<cache-ref namespace="主表的Mapper"/>

这样子表的修改也会清空主表缓存
```

---

**🧠 核心记忆口诀**：

```
二级缓存namespace管，三步开启别忘完
全局开关加cache标签，实体序列化是关键
LRU策略最常见，淘汰最久不常用
增删改后自动刷，保证数据不出错
只读模式性能好，读写模式更安全
穿透雪崩要防范，生产环境用Redis换
```

**⚡ 使用建议**：
- 小型单应用可以用MyBatis二级缓存
- 分布式系统强烈推荐Redis
- 缓存不是万能的，合理使用才是王道
- 出现问题优先检查：序列化、提交事务、日志输出