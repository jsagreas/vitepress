---
title: 17、SQL执行流程分析
---
## 📚 目录

1. [SQL执行流程概述](#1-SQL执行流程概述)
2. [SQL解析过程](#2-SQL解析过程)
3. [参数映射流程](#3-参数映射流程)
4. [语句执行过程](#4-语句执行过程)
5. [结果映射流程](#5-结果映射流程)
6. [异常处理机制](#6-异常处理机制)
7. [资源管理机制](#7-资源管理机制)
8. [事务处理流程](#8-事务处理流程)
9. [连接池管理](#9-连接池管理)
10. [性能监控点](#10-性能监控点)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔄 SQL执行流程概述


### 1.1 什么是SQL执行流程


**通俗理解：** 就像你去餐厅点菜，从你说出菜名，到服务员记录、厨师做菜、上菜到你面前，这整个过程就是一个完整的流程。MyBatis执行SQL也是类似的：你调用方法 → 框架解析SQL → 执行查询 → 返回结果。

**专业定义：** SQL执行流程是指从应用程序调用Mapper方法开始，到MyBatis框架解析SQL、设置参数、执行数据库操作、映射结果，最终返回数据给应用程序的完整处理过程。

### 1.2 完整执行流程图


```
应用层                    MyBatis框架层              数据库层
  |                           |                        |
  |--[1]调用Mapper方法-------->|                        |
  |   selectUser(1)           |                        |
  |                           |                        |
  |                      [2]解析SQL语句                |
  |                      找到对应的SQL配置              |
  |                           |                        |
  |                      [3]参数映射                   |
  |                      将Java参数转换                |
  |                           |                        |
  |                           |--[4]执行SQL----------->|
  |                           |  PreparedStatement     |
  |                           |                        |
  |                           |<--[5]返回结果集--------|
  |                           |  ResultSet             |
  |                           |                        |
  |                      [6]结果映射                   |
  |                      将数据转为Java对象             |
  |                           |                        |
  |<--[7]返回最终对象----------|                        |
  |   User对象                |                        |
```

### 1.3 核心处理组件


**四大核心组件关系：**
```
SqlSession（会话管理器）
    ↓ 委托
Executor（执行器）
    ↓ 使用
StatementHandler（语句处理器）
    ↓ 协作
ParameterHandler + ResultSetHandler
（参数处理器 + 结果处理器）
```

**各组件职责：**
- **SqlSession**：对外接口，用户直接调用的API
- **Executor**：真正的执行引擎，负责缓存和事务
- **StatementHandler**：操作JDBC的Statement对象
- **ParameterHandler**：设置SQL参数
- **ResultSetHandler**：处理查询结果

---

## 2. 🔍 SQL解析过程


### 2.1 解析的本质含义


**什么是解析？** 就像你给外国人翻译中文，MyBatis要把你写的Mapper方法调用，翻译成数据库能理解的SQL语句。

**解析过程包含：**
- 找到对应的SQL配置（XML或注解）
- 识别SQL语句类型（SELECT、INSERT等）
- 处理动态SQL标签（if、foreach等）
- 构建最终可执行的SQL

### 2.2 SQL定位过程


**如何找到SQL配置？**

```
步骤1：获取Mapper接口的全限定名
例如：com.example.mapper.UserMapper

步骤2：获取调用的方法名
例如：selectById

步骤3：组合成Statement ID
结果：com.example.mapper.UserMapper.selectById

步骤4：从Configuration中查找
Configuration内部维护了一个Map：
statementId → MappedStatement对象
```

**示例说明：**
```java
// 你调用的代码
User user = userMapper.selectById(1);

// MyBatis内部执行
String statementId = "com.example.mapper.UserMapper.selectById";
MappedStatement ms = configuration.getMappedStatement(statementId);
```

### 2.3 动态SQL解析


**动态SQL是什么？** 就是根据不同条件生成不同的SQL语句，像搭积木一样拼接SQL。

**解析示例：**

原始配置：
```xml
<select id="findUsers" resultType="User">
  SELECT * FROM user WHERE 1=1
  <if test="name != null">
    AND name = #{name}
  </if>
  <if test="age != null">
    AND age = #{age}
  </if>
</select>
```

解析过程：
```
情况1：name="张三", age=null
最终SQL：SELECT * FROM user WHERE 1=1 AND name = ?

情况2：name=null, age=20
最终SQL：SELECT * FROM user WHERE 1=1 AND age = ?

情况3：name="张三", age=20
最终SQL：SELECT * FROM user WHERE 1=1 AND name = ? AND age = ?
```

### 2.4 SQL类型识别


**MyBatis支持的SQL类型：**

| SQL类型 | 作用 | 返回值特点 |
|---------|------|-----------|
| **SELECT** | 查询数据 | 返回结果集（单个对象或列表） |
| **INSERT** | 插入数据 | 返回影响行数 |
| **UPDATE** | 更新数据 | 返回影响行数 |
| **DELETE** | 删除数据 | 返回影响行数 |

**识别依据：**
- 通过XML标签：`<select>、<insert>、<update>、<delete>`
- 通过注解：`@Select、@Insert、@Update、@Delete`

---

## 3. 🔗 参数映射流程


### 3.1 参数映射是什么


**通俗解释：** 就像把你说的话（Java参数）翻译成数据库听得懂的语言（SQL参数）。比如你说"查ID为1的用户"，要翻译成数据库的`WHERE id = 1`。

**技术含义：** 参数映射是将Java方法的参数值，设置到SQL语句的占位符中的过程，涉及类型转换和位置匹配。

### 3.2 参数类型分类


**三种参数传递方式：**

**方式1：单个基本参数**
```java
// Mapper方法
User selectById(Integer id);

// SQL配置
SELECT * FROM user WHERE id = #{id}

// 映射过程
参数名：id → 参数值：1 → SQL占位符：第1个?
```

**方式2：多个参数**
```java
// Mapper方法
List<User> findByNameAndAge(String name, Integer age);

// SQL配置（使用@Param注解）
SELECT * FROM user WHERE name = #{name} AND age = #{age}

// 映射过程
参数1：name → "张三" → 第1个?
参数2：age → 20 → 第2个?
```

**方式3：对象参数**
```java
// Mapper方法
int insert(User user);

// SQL配置
INSERT INTO user(name, age) VALUES(#{name}, #{age})

// 映射过程
user.getName() → "张三" → 第1个?
user.getAge() → 20 → 第2个?
```

### 3.3 参数映射详细过程


```
Java参数                     参数处理                    JDBC参数
   |                           |                           |
Integer id = 1          [1]参数解析                      |
   |                    识别参数类型                      |
   |                           |                          |
   |                    [2]类型转换                       |
   |                    Java类型 → JDBC类型               |
   |                    Integer → java.sql.Types.INTEGER  |
   |                           |                          |
   |                    [3]参数设置                       |
   |                    调用PreparedStatement             |
   |                           |                          |
   |                           |----------------------->  |
   |                    ps.setInt(1, 1)            参数绑定完成
```

### 3.4 类型转换机制


**MyBatis的类型处理器（TypeHandler）：**

**内置常用类型映射：**

| Java类型 | JDBC类型 | 说明 |
|----------|---------|------|
| `Integer` | `INTEGER` | 整数 |
| `String` | `VARCHAR` | 字符串 |
| `Date` | `TIMESTAMP` | 日期时间 |
| `Boolean` | `BOOLEAN` | 布尔值 |
| `BigDecimal` | `DECIMAL` | 精确小数 |

**自定义类型处理：**
```java
// 假设你要处理性别：1-男，2-女
public class GenderTypeHandler implements TypeHandler<String> {
    
    // 设置参数时：将"男"转为1
    public void setParameter(PreparedStatement ps, int i, String gender) {
        ps.setInt(i, "男".equals(gender) ? 1 : 2);
    }
    
    // 获取结果时：将1转为"男"
    public String getResult(ResultSet rs, String columnName) {
        int value = rs.getInt(columnName);
        return value == 1 ? "男" : "女";
    }
}
```

---

## 4. ⚙️ 语句执行过程


### 4.1 执行器的作用


**什么是执行器？** 就像快递公司的分拣系统，决定用什么方式把你的SQL"快递"到数据库。

**三种执行器类型：**

**1. SimpleExecutor（简单执行器）**
```
特点：每次执行都创建新的Statement
适用：一次性操作

执行流程：
创建Statement → 执行SQL → 关闭Statement → 完成
```

**2. ReuseExecutor（重用执行器）**
```
特点：重用相同SQL的Statement
适用：频繁执行相同SQL

执行流程：
检查缓存 → 有：复用Statement
        → 无：创建新Statement并缓存
```

**3. BatchExecutor（批处理执行器）**
```
特点：批量提交SQL
适用：大批量插入/更新

执行流程：
添加SQL到批次 → 达到阈值 → 批量提交 → 完成
```

### 4.2 Statement创建过程


**三种Statement类型：**

```
Statement（普通语句）
    ↓ 性能提升
PreparedStatement（预编译语句）← MyBatis默认使用
    ↓ 功能扩展
CallableStatement（存储过程调用）
```

**PreparedStatement优势：**
- ✅ **防止SQL注入**：参数自动转义
- ✅ **性能更好**：SQL预编译，可重用
- ✅ **代码更清晰**：参数占位符明确

**创建示例：**
```
原始SQL：
SELECT * FROM user WHERE id = #{id}

处理后：
SQL模板：SELECT * FROM user WHERE id = ?
参数：[1]

执行：
PreparedStatement ps = conn.prepareStatement(
    "SELECT * FROM user WHERE id = ?"
);
ps.setInt(1, 1);
ResultSet rs = ps.executeQuery();
```

### 4.3 SQL执行时机


**何时真正执行？**

```
延迟执行（查询操作）：
调用Mapper方法 → 准备SQL → 设置参数 → 调用executeQuery() → 执行

立即执行（更新操作）：
调用Mapper方法 → 准备SQL → 设置参数 → 调用executeUpdate() → 执行 → 提交事务
```

**执行时序图：**
```
应用代码         Executor        StatementHandler      数据库
   |                |                   |                |
   |--执行方法------>|                   |                |
   |                |--准备Statement---->|                |
   |                |                   |--创建连接------>|
   |                |                   |                |
   |                |--设置参数-------->|                |
   |                |                   |--绑定参数------>|
   |                |                   |                |
   |                |--执行SQL--------->|                |
   |                |                   |--发送SQL------->|
   |                |                   |                |
   |                |                   |<--返回结果------|
   |                |<--处理结果集------|                |
   |<--返回对象------|                   |                |
```

---

## 5. 🎯 结果映射流程


### 5.1 结果映射是什么


**通俗比喻：** 数据库返回的是一张Excel表，结果映射就是把表格数据填充到你的Java对象中，就像把成绩单的数据录入到学生信息系统。

**技术含义：** 结果映射是将数据库返回的ResultSet结果集，转换为Java对象的过程，包括字段匹配、类型转换、嵌套映射等。

### 5.2 基本映射方式


**自动映射（最简单）：**
```java
// 数据库字段：id, user_name, age
// Java属性：  id, userName,  age

// 配置开启驼峰命名（默认开启）
<setting name="mapUnderscoreToCamelCase" value="true"/>

// 自动映射：
user_name → userName ✓
```

**手动映射（精确控制）：**
```xml
<resultMap id="userResultMap" type="User">
  <id property="id" column="user_id"/>
  <result property="userName" column="user_name"/>
  <result property="age" column="age"/>
</resultMap>

<select id="selectById" resultMap="userResultMap">
  SELECT user_id, user_name, age FROM user WHERE user_id = #{id}
</select>
```

### 5.3 映射详细过程


**单对象映射流程：**

```
ResultSet（数据库结果）         映射处理             Java对象
     |                           |                    |
row: [1, "张三", 20]        [1]创建对象              |
     |                      new User()               |
     |                           |                   |
     |                      [2]字段映射               |
     |                      id列 → setId(1)          |
     |                      name列 → setName("张三")  |
     |                      age列 → setAge(20)       |
     |                           |                   |
     |                           |---------------->  |
     |                                          User对象创建完成
```

**列表映射流程：**
```
ResultSet（多行数据）
     |
row1: [1, "张三", 20] ──→ User对象1 ──┐
row2: [2, "李四", 25] ──→ User对象2 ──┼──→ List<User>
row3: [3, "王五", 30] ──→ User对象3 ──┘
```

### 5.4 嵌套结果映射


**一对一映射示例：**

```
场景：用户与身份证信息（一对一）

数据库结构：
user表：id, name
id_card表：id, user_id, card_number

Java对象：
class User {
    private Integer id;
    private String name;
    private IdCard idCard;  // 嵌套对象
}
```

**映射配置：**
```xml
<resultMap id="userWithCard" type="User">
  <id property="id" column="id"/>
  <result property="name" column="name"/>
  
  <!-- 一对一关联 -->
  <association property="idCard" javaType="IdCard">
    <id property="id" column="card_id"/>
    <result property="cardNumber" column="card_number"/>
  </association>
</resultMap>
```

**一对多映射示例：**

```
场景：用户与订单（一对多）

Java对象：
class User {
    private Integer id;
    private String name;
    private List<Order> orders;  // 集合
}
```

**映射配置：**
```xml
<resultMap id="userWithOrders" type="User">
  <id property="id" column="user_id"/>
  <result property="name" column="user_name"/>
  
  <!-- 一对多关联 -->
  <collection property="orders" ofType="Order">
    <id property="id" column="order_id"/>
    <result property="orderNo" column="order_no"/>
  </collection>
</resultMap>
```

### 5.5 结果处理器工作原理


**ResultSetHandler核心方法：**

```
处理流程：

1. 获取ResultSet
   rs = ps.executeQuery();

2. 遍历结果集
   while(rs.next()) {
       
3. 创建目标对象
       Object obj = createResultObject(rs);
       
4. 自动映射字段
       autoMapping(rs, obj);
       
5. 手动映射字段
       manualMapping(rs, obj);
       
6. 添加到结果列表
       resultList.add(obj);
   }

7. 返回最终结果
   return resultList;
```

---

## 6. ⚠️ 异常处理机制


### 6.1 异常处理的重要性


**为什么需要异常处理？** 就像开车要系安全带，程序执行SQL也可能出问题（网络断了、SQL写错了、数据类型不匹配等），需要妥善处理这些异常。

**MyBatis异常体系：**
```
Exception（Java异常基类）
    ↓
PersistenceException（持久层异常基类）
    ↓
MyBatisException（MyBatis异常）
    ├── SqlSessionException（会话异常）
    ├── BindingException（绑定异常）
    ├── ResultMapException（结果映射异常）
    └── ... 其他异常
```

### 6.2 常见异常类型


**参数绑定异常：**
```java
// 问题代码
User selectById(Integer id);  // 没有@Param注解

// XML中使用
WHERE id = #{id}  // ❌ 报错：BindingException

// 解决方案
User selectById(@Param("id") Integer id);  // ✓ 正确
```

**结果映射异常：**
```java
// 数据库字段类型：age INT
// Java属性类型：age String

// 查询时报错：TypeException
// 原因：类型不匹配，无法将Integer转为String

// 解决：修改Java属性类型为Integer
```

**SQL语法错误：**
```xml
<!-- 错误SQL -->
<select id="selectAll">
  SELEC * FROM user  ❌ 拼写错误
</select>

<!-- 运行时报错：BadSqlGrammarException -->
```

### 6.3 异常捕获与处理


**异常处理最佳实践：**

```java
public User getUserById(Integer id) {
    try {
        // 执行查询
        return userMapper.selectById(id);
        
    } catch (DataAccessException e) {
        // 数据访问异常
        log.error("查询用户失败，ID：{}", id, e);
        throw new BusinessException("用户信息查询失败");
        
    } catch (Exception e) {
        // 其他未知异常
        log.error("系统异常", e);
        throw new SystemException("系统繁忙，请稍后重试");
    }
}
```

**事务回滚处理：**
```java
@Transactional
public void transferMoney(Integer fromId, Integer toId, BigDecimal amount) {
    try {
        // 扣款
        accountMapper.deduct(fromId, amount);
        
        // 模拟异常
        if (amount.compareTo(BigDecimal.ZERO) > 0) {
            // int i = 1 / 0;  // 故意制造异常
        }
        
        // 加款
        accountMapper.add(toId, amount);
        
    } catch (Exception e) {
        // 异常时自动回滚事务
        log.error("转账失败", e);
        throw e;  // 重新抛出，触发事务回滚
    }
}
```

---

## 7. 🔧 资源管理机制


### 7.1 资源是什么


**通俗解释：** 资源就是程序运行时向系统借用的东西，比如数据库连接、内存空间、文件句柄等。用完必须还回去，否则就像借书不还，系统资源会被耗尽。

**MyBatis管理的核心资源：**
- **数据库连接（Connection）**：最宝贵的资源
- **Statement对象**：执行SQL的工具
- **ResultSet对象**：查询结果集
- **事务资源**：事务上下文信息

### 7.2 资源生命周期


**完整生命周期流程：**

```
资源创建                 资源使用                资源释放
    |                      |                       |
[1]获取连接            [4]执行SQL              [7]关闭ResultSet
从连接池取出            发送到数据库            释放结果集
    ↓                      ↓                       ↓
[2]创建Statement      [5]处理结果              [8]关闭Statement
准备执行器              映射数据                释放执行器
    ↓                      ↓                       ↓
[3]绑定参数            [6]返回对象              [9]归还连接
设置SQL参数            业务处理                 放回连接池
```

### 7.3 自动资源管理


**try-with-resources模式：**

```java
// MyBatis内部实现（简化版）
public <T> T selectOne(String statement, Object parameter) {
    
    // 自动资源管理
    try (SqlSession session = sqlSessionFactory.openSession()) {
        
        return session.selectOne(statement, parameter);
        
    } catch (Exception e) {
        throw new RuntimeException(e);
        
    } // 这里自动关闭session，释放所有资源
}
```

**手动资源管理：**
```java
SqlSession session = null;
try {
    session = sqlSessionFactory.openSession();
    User user = session.selectOne("selectById", 1);
    session.commit();  // 提交事务
    return user;
    
} catch (Exception e) {
    if (session != null) {
        session.rollback();  // 回滚事务
    }
    throw e;
    
} finally {
    if (session != null) {
        session.close();  // 必须关闭！释放资源
    }
}
```

### 7.4 资源泄漏问题


**什么是资源泄漏？** 就像水龙头没关紧，资源一直被占用没有释放，最终导致系统资源耗尽。

**常见泄漏场景：**

❌ **场景1：忘记关闭SqlSession**
```java
public User getUser(Integer id) {
    SqlSession session = sqlSessionFactory.openSession();
    User user = session.selectOne("selectById", id);
    return user;  // 忘记关闭session！
}
```

❌ **场景2：异常时未释放资源**
```java
public void updateUser(User user) {
    SqlSession session = sqlSessionFactory.openSession();
    session.update("updateUser", user);
    // 如果这里抛异常，session未关闭
    session.commit();
}
```

✅ **正确做法：**
```java
public void updateUser(User user) {
    try (SqlSession session = sqlSessionFactory.openSession()) {
        session.update("updateUser", user);
        session.commit();
    } // 无论是否异常，都会自动关闭
}
```

---

## 8. 💳 事务处理流程


### 8.1 事务的本质


**什么是事务？** 就像银行转账，要么全部成功（钱转走了也收到了），要么全部失败（谁的钱都不变）。不能出现钱转走了但对方没收到的情况。

**事务的ACID特性：**
- **A-原子性（Atomicity）**：要么全做，要么全不做
- **C-一致性（Consistency）**：数据从一个正确状态到另一个正确状态
- **I-隔离性（Isolation）**：多个事务互不干扰
- **D-持久性（Durability）**：事务完成后数据永久保存

### 8.2 MyBatis事务管理方式


**两种事务管理器：**

**1. JDBC事务管理器（自己管理）**
```xml
<environment id="development">
  <transactionManager type="JDBC"/>
  <dataSource type="POOLED">
    <!-- 数据源配置 -->
  </dataSource>
</environment>
```

特点：
- 需要手动提交/回滚
- 适合单独使用MyBatis的场景

**2. MANAGED事务管理器（交给容器）**
```xml
<environment id="development">
  <transactionManager type="MANAGED"/>
  <dataSource type="POOLED">
    <!-- 数据源配置 -->
  </dataSource>
</environment>
```

特点：
- 事务由Spring等容器管理
- 适合与Spring集成的场景

### 8.3 事务执行流程


**完整事务流程：**

```
开始事务                  执行操作                  结束事务
    |                        |                        |
[1]开启事务              [3]执行SQL              [5]提交事务
BEGIN                    业务逻辑                 COMMIT
    ↓                        ↓                        ↓
[2]关闭自动提交          [4]检查结果              [6]释放资源
autoCommit=false        成功/失败判断             关闭连接
                             ↓
                        如果失败
                             ↓
                        [回滚事务]
                        ROLLBACK
```

**代码示例：**

```java
// 手动事务管理
SqlSession session = sqlSessionFactory.openSession(); // 开启事务
try {
    // 执行多个操作
    userMapper.insert(user);
    orderMapper.insert(order);
    
    session.commit();  // 全部成功，提交事务
    
} catch (Exception e) {
    session.rollback();  // 出现异常，回滚事务
    throw e;
    
} finally {
    session.close();  // 释放资源
}
```

### 8.4 事务隔离级别


**四种隔离级别：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 说明 |
|---------|-----|-----------|-----|------|
| **READ_UNCOMMITTED** | ✓ | ✓ | ✓ | 读未提交，最低级别 |
| **READ_COMMITTED** | ✗ | ✓ | ✓ | 读已提交，Oracle默认 |
| **REPEATABLE_READ** | ✗ | ✗ | ✓ | 可重复读，MySQL默认 |
| **SERIALIZABLE** | ✗ | ✗ | ✗ | 串行化，最高级别 |

**通俗理解：**
- **脏读**：读到别人没提交的数据（可能会回滚）
- **不可重复读**：前后两次读同一条数据，结果不一样
- **幻读**：前后两次读，发现多了或少了数据

**配置事务隔离级别：**
```xml
<transactionManager type="JDBC">
  <property name="defaultTransactionIsolationLevel" value="2"/>
  <!-- 1-READ_UNCOMMITTED, 2-READ_COMMITTED
       4-REPEATABLE_READ, 8-SERIALIZABLE -->
</transactionManager>
```

---

## 9. 🏊 连接池管理


### 9.1 连接池的作用


**为什么需要连接池？** 

**没有连接池的情况：**
```
每次查询：
创建连接（耗时500ms）→ 执行SQL（耗时10ms）→ 关闭连接（耗时100ms）
总耗时：610ms，其中600ms都在管理连接！
```

**有连接池的情况：**
```
首次查询：
创建连接（耗时500ms）→ 执行SQL（耗时10ms）→ 放回池中（耗时1ms）

后续查询：
从池中取连接（耗时1ms）→ 执行SQL（耗时10ms）→ 放回池中（耗时1ms）
总耗时：12ms，性能提升50倍！
```

### 9.2 MyBatis内置连接池


**PooledDataSource工作原理：**

```
连接池结构：

┌─────────────────────────────┐
│        连接池容器            │
│  ┌────┐ ┌────┐ ┌────┐       │
│  │空闲│ │空闲│ │空闲│       │ 空闲连接（idle）
│  │连接│ │连接│ │连接│       │
│  └────┘ └────┘ └────┘       │
│                              │
│  ┌────┐ ┌────┐              │
│  │活动│ │活动│              │ 活动连接（active）
│  │连接│ │连接│              │
│  └────┘ └────┘              │
└─────────────────────────────┘
```

### 9.3 连接池核心参数


**重要配置参数：**

```xml
<dataSource type="POOLED">
  <!-- 数据库连接信息 -->
  <property name="driver" value="com.mysql.jdbc.Driver"/>
  <property name="url" value="jdbc:mysql://localhost:3306/test"/>
  <property name="username" value="root"/>
  <property name="password" value="123456"/>
  
  <!-- 连接池配置 -->
  <property name="poolMaximumActiveConnections" value="10"/>
  <!-- 最大活动连接数：同时最多10个连接在使用 -->
  
  <property name="poolMaximumIdleConnections" value="5"/>
  <!-- 最大空闲连接数：最多保持5个空闲连接 -->
  
  <property name="poolMaximumCheckoutTime" value="20000"/>
  <!-- 最大借出时间：连接被借出超过20秒强制回收 -->
  
  <property name="poolTimeToWait" value="20000"/>
  <!-- 等待时间：获取不到连接时等待20秒 -->
</dataSource>
```

**参数含义解释：**

| 参数 | 通俗解释 | 建议值 |
|------|---------|--------|
| `poolMaximumActiveConnections` | 饭店最多同时接待多少桌客人 | 10-50 |
| `poolMaximumIdleConnections` | 饭店保留多少空桌子待命 | 5-10 |
| `poolMaximumCheckoutTime` | 客人最多占用桌子多长时间 | 20000ms |
| `poolTimeToWait` | 没有空桌子时，客人愿意等多久 | 20000ms |

### 9.4 连接获取流程


**详细获取步骤：**

```
请求连接
    ↓
检查空闲连接池
    ↓
是否有空闲连接？
    ├─ 有 → 直接返回 ✓
    │
    └─ 无 → 检查活动连接数
            ↓
        是否小于最大值？
            ├─ 是 → 创建新连接 → 返回 ✓
            │
            └─ 否 → 检查是否有超时连接
                    ↓
                是否有超时的？
                    ├─ 有 → 强制回收 → 返回 ✓
                    │
                    └─ 无 → 等待其他连接释放
                            ↓
                        等待超时？
                            ├─ 否 → 继续等待
                            │
                            └─ 是 → 抛出异常 ✗
```

---

## 10. 📈 性能监控点


### 10.1 为什么需要性能监控


**监控的重要性：** 就像医生给病人做体检，定期检查SQL执行情况，及早发现性能问题，避免系统"生病"。

**监控的目标：**
- 发现慢SQL
- 定位性能瓶颈
- 优化执行效率
- 预防系统故障

### 10.2 关键监控指标


**核心性能指标：**

| 指标 | 说明 | 正常范围 | 异常表现 |
|------|------|---------|---------|
| **SQL执行时间** | 单条SQL耗时 | < 100ms | > 1000ms |
| **连接获取时间** | 从池中获取连接的时间 | < 10ms | > 100ms |
| **结果集大小** | 返回的数据量 | < 1000条 | > 10000条 |
| **连接池使用率** | 活动连接/最大连接 | < 80% | > 90% |
| **缓存命中率** | 二级缓存命中比例 | > 70% | < 30% |

### 10.3 SQL执行监控


**使用MyBatis插件监控：**

```java
@Intercepts({
    @Signature(
        type = Executor.class,
        method = "update",
        args = {MappedStatement.class, Object.class}
    ),
    @Signature(
        type = Executor.class,
        method = "query",
        args = {MappedStatement.class, Object.class, 
                RowBounds.class, ResultHandler.class}
    )
})
public class SqlMonitorPlugin implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 执行SQL
            Object result = invocation.proceed();
            
            long endTime = System.currentTimeMillis();
            long executeTime = endTime - startTime;
            
            // 记录慢SQL（超过500ms）
            if (executeTime > 500) {
                MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
                log.warn("慢SQL警告：{}, 耗时：{}ms", ms.getId(), executeTime);
            }
            
            return result;
            
        } catch (Exception e) {
            log.error("SQL执行异常", e);
            throw e;
        }
    }
}
```

### 10.4 性能优化建议


**常见优化策略：**

**1. SQL优化**
```
✓ 避免 SELECT *，只查询需要的字段
✓ 合理使用索引
✓ 避免在WHERE子句中使用函数
✓ 批量操作替代单条操作
```

**2. 缓存优化**
```
✓ 开启一级缓存（默认开启）
✓ 合理使用二级缓存
✓ 设置合适的缓存过期时间
```

**3. 连接池优化**
```
✓ 合理设置最大连接数
✓ 设置连接超时时间
✓ 启用连接有效性检查
```

**4. 分页优化**
```java
// 不推荐：查询全部再分页
List<User> allUsers = userMapper.selectAll();
List<User> pageData = allUsers.subList(0, 10);

// 推荐：数据库层面分页
List<User> pageData = userMapper.selectByPage(0, 10);
```

---

## 11. 📋 核心要点总结


### 11.1 SQL执行完整流程回顾


```
调用Mapper方法
    ↓
[1] SQL解析
    找到对应的SQL配置
    处理动态SQL标签
    构建最终SQL语句
    ↓
[2] 参数映射
    识别参数类型
    类型转换（Java → JDBC）
    设置到PreparedStatement
    ↓
[3] 语句执行
    选择执行器类型
    创建Statement对象
    执行SQL语句
    ↓
[4] 结果映射
    处理ResultSet
    字段映射到对象
    处理嵌套关系
    ↓
[5] 资源清理
    关闭ResultSet
    关闭Statement
    归还数据库连接
    ↓
返回最终结果
```

### 11.2 核心组件职责


| 组件 | 核心职责 | 关键方法 |
|------|---------|---------|
| **SqlSession** | 对外API，会话管理 | `selectOne()、insert()、commit()` |
| **Executor** | 执行引擎，缓存管理 | `query()、update()、commit()` |
| **StatementHandler** | Statement操作 | `prepare()、parameterize()、query()` |
| **ParameterHandler** | 参数设置 | `setParameters()` |
| **ResultSetHandler** | 结果处理 | `handleResultSets()` |

### 11.3 重要概念理解


**🔸 SQL解析：** 把Mapper调用翻译成数据库SQL

**🔸 参数映射：** 把Java参数转换成SQL参数

**🔸 结果映射：** 把数据库结果转换成Java对象

**🔸 事务管理：** 保证操作的原子性和一致性

**🔸 连接池：** 重用连接，提升性能

**🔸 异常处理：** 确保资源正确释放，数据一致性

### 11.4 性能优化要点


```
核心优化原则：

1. SQL层面
   ✓ 只查询必要字段
   ✓ 合理使用索引
   ✓ 批量操作代替循环

2. 映射层面
   ✓ 避免N+1问题
   ✓ 合理使用懒加载
   ✓ 优化结果映射

3. 连接层面
   ✓ 合理配置连接池
   ✓ 及时释放资源
   ✓ 监控连接使用

4. 缓存层面
   ✓ 启用一级缓存
   ✓ 合理使用二级缓存
   ✓ 设置缓存策略
```

### 11.5 最佳实践建议


**开发建议：**
- ✅ 使用`try-with-resources`自动管理资源
- ✅ 合理设置事务边界
- ✅ 配置慢SQL监控
- ✅ 定期检查连接池状态
- ✅ 开启SQL日志，便于调试

**生产环境建议：**
- ✅ 关闭SQL日志，提升性能
- ✅ 配置合理的连接池参数
- ✅ 启用性能监控
- ✅ 设置慢SQL告警
- ✅ 定期分析执行计划

**记忆口诀：**
```
解析定位找SQL，参数映射类型转
执行器创建语句，结果映射变对象
异常处理要完善，资源释放莫遗忘
事务保证一致性，连接池中提性能
监控优化常检查，生产稳定最重要
```