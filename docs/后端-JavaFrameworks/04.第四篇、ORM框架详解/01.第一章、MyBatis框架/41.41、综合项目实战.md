---
title: 41、综合项目实战
---
## 📚 目录

1. [综合项目实战概述](#1-综合项目实战概述)
2. [电商系统案例](#2-电商系统案例)
3. [权限管理系统](#3-权限管理系统)
4. [内容管理系统](#4-内容管理系统)
5. [数据分析平台](#5-数据分析平台)
6. [实时监控系统](#6-实时监控系统)
7. [完整技术栈整合](#7-完整技术栈整合)
8. [性能测试与优化](#8-性能测试与优化)
9. [上线部署方案](#9-上线部署方案)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 综合项目实战概述


### 1.1 什么是综合项目实战


**通俗理解**：就像学了很多菜谱后，终于要做一桌完整的宴席了。

```
学习过程对比：
基础学习    →  学单个菜怎么做（单个功能）
进阶学习    →  学组合菜品（模块整合）
综合实战    →  做一桌宴席（完整项目）

实战价值：
✅ 理解真实项目的复杂度
✅ 掌握技术选型的思路
✅ 学会架构设计的方法
✅ 积累解决问题的经验
```

### 1.2 五大实战项目概览


| 项目类型 | **业务特点** | **技术重点** | **难度等级** | **适合场景** |
|---------|------------|-------------|-------------|-------------|
| 🛒 **电商系统** | `订单多、并发高` | `事务处理、缓存优化` | ⭐⭐⭐⭐ | 学习高并发处理 |
| 🔐 **权限管理** | `层级复杂、安全性高` | `递归查询、动态SQL` | ⭐⭐⭐ | 掌握权限控制 |
| 📝 **内容管理** | `数据多样、检索频繁` | `全文搜索、分页优化` | ⭐⭐⭐ | 练习数据管理 |
| 📊 **数据分析** | `统计复杂、性能要求高` | `聚合查询、批处理` | ⭐⭐⭐⭐⭐ | 提升分析能力 |
| 📈 **实时监控** | `实时性强、数据量大` | `流式处理、定时任务` | ⭐⭐⭐⭐ | 学习实时处理 |

**💡 学习建议**：
- 从**权限管理**或**内容管理**开始（难度适中）
- 再学**电商系统**（涉及高并发）
- 最后挑战**数据分析**和**实时监控**（技术要求高）

### 1.3 项目实战的核心价值


**🎓 技能提升路径**：
```
理论知识
    ↓
单一功能实现
    ↓
模块化开发
    ↓
完整系统搭建  ← 我们在这里
    ↓
架构设计优化
```

**🔑 关键能力培养**：
- **业务理解**：从需求到代码的转化能力
- **技术选型**：为什么用MyBatis而不是其他ORM
- **架构设计**：如何组织代码结构
- **性能优化**：找到并解决性能瓶颈
- **问题解决**：遇到Bug时的排查思路

---

## 2. 🛒 电商系统案例


### 2.1 业务场景分析


**🏢 典型电商系统架构**：
```
用户端                    商家端                    管理端
  │                        │                        │
  ├─ 商品浏览              ├─ 商品管理              ├─ 订单监控
  ├─ 购物车                ├─ 库存管理              ├─ 数据统计
  ├─ 下单支付              ├─ 订单处理              └─ 系统配置
  └─ 订单查询              └─ 财务报表
       │                        │                        │
       └────────────────────────┴────────────────────────┘
                              数据库层
```

**💭 为什么选择MyBatis**：
- **复杂查询多**：商品搜索、订单统计需要灵活的SQL
- **性能要求高**：高并发下需要精细的SQL优化
- **业务变化快**：容易调整查询逻辑

### 2.2 核心数据模型设计


**📊 主要数据表关系**：
```
用户表(user)              订单表(order)
    │                         │
    │  1:N                    │  1:N
    ↓                         ↓
购物车(cart)              订单项(order_item)
    │                         │
    │  N:1                    │  N:1
    ↓                         ↓
商品表(product) ← 1:N ─ 商品SKU(product_sku)
    │
    │  N:1
    ↓
分类表(category)
```

**🔸 表结构示例**（以订单表为例）：

| 字段名 | **类型** | **说明** | **索引** |
|-------|---------|---------|---------|
| `order_id` | BIGINT | 订单ID | 主键 |
| `user_id` | BIGINT | 用户ID | 普通索引 |
| `order_no` | VARCHAR(32) | 订单号 | 唯一索引 |
| `total_amount` | DECIMAL(10,2) | 订单总金额 | - |
| `status` | TINYINT | 订单状态 | 普通索引 |
| `create_time` | DATETIME | 创建时间 | 普通索引 |

### 2.3 架构设计思路


**🏗️ 分层架构设计**：
```
Controller层（接收请求）
    ↓
Service层（业务逻辑）
    ↓
Mapper层（数据访问）← MyBatis在这里
    ↓
Database（数据存储）
```

**💡 为什么要分层**：
- **职责清晰**：每一层只做自己的事
- **易于维护**：修改业务逻辑不影响数据访问
- **可测试性**：可以单独测试每一层

**🔧 技术栈组合**：
- **MyBatis**：数据访问层
- **Spring Boot**：整体框架
- **Redis**：缓存热点数据
- **RabbitMQ**：处理异步订单

### 2.4 订单核心功能实现


**📝 下单流程（简化版）**：
```
1. 用户提交订单
   ↓
2. 检查库存（MyBatis查询）
   ↓
3. 创建订单（MyBatis插入）
   ↓
4. 扣减库存（MyBatis更新）
   ↓
5. 清空购物车（MyBatis删除）
   ↓
6. 返回订单号
```

**⚡ 关键代码片段**（创建订单）：
```java
// OrderMapper.xml - 创建订单
<insert id="createOrder" parameterType="Order">
    INSERT INTO t_order (
        order_no, user_id, total_amount, status, create_time
    ) VALUES (
        #{orderNo}, #{userId}, #{totalAmount}, 0, NOW()
    )
    <selectKey keyProperty="orderId" resultType="long">
        SELECT LAST_INSERT_ID()
    </selectKey>
</insert>

// 扣减库存（带乐观锁）
<update id="deductStock">
    UPDATE product_sku 
    SET stock = stock - #{quantity},
        version = version + 1
    WHERE sku_id = #{skuId} 
      AND stock >= #{quantity}
      AND version = #{version}
</update>
```

**🎯 重点解析**：
- `LAST_INSERT_ID()`：获取刚插入的订单ID
- `version`字段：乐观锁，防止超卖
- `stock >= #{quantity}`：确保库存充足

### 2.5 高并发场景处理


**🚀 秒杀活动优化方案**：

**问题**：1000人同时抢100件商品，数据库扛不住

**解决思路**：
```
传统方式（慢）：
用户请求 → 数据库查库存 → 扣库存

优化方式（快）：
用户请求 → Redis预检查 → 数据库扣库存
              ↓ 没库存了
           直接返回失败
```

**核心技术点**：
- **Redis预减库存**：先在缓存里扣，挡住大部分请求
- **消息队列削峰**：把订单请求放队列，慢慢处理
- **数据库乐观锁**：最后一道防线，确保不超卖

---

## 3. 🔐 权限管理系统


### 3.1 权限系统的基本概念


**🤔 什么是权限管理**：
简单说就是控制"谁能做什么"。比如：
- 普通员工只能查看自己的工资
- 财务可以查看所有人的工资
- 老板可以修改工资

**📋 核心概念解释**：

| 概念 | **通俗理解** | **技术术语** |
|-----|------------|-------------|
| **用户** | 张三、李四 | User |
| **角色** | 经理、员工 | Role |
| **权限** | 查看、修改、删除 | Permission |
| **资源** | 工资表、报表 | Resource |

**🔗 关系模型**（RBAC：基于角色的访问控制）：
```
用户 ←── N:N ──→ 角色 ←── N:N ──→ 权限
张三               经理               查看工资
                                     修改工资
李四               员工               查看自己工资
```

### 3.2 数据库表设计


**📊 五张核心表**：
```
用户表(user)
    │
    ↓ N:N（通过user_role表）
角色表(role)
    │
    ↓ N:N（通过role_permission表）
权限表(permission)
    │
    ↓ 1:N
菜单表(menu) - 树形结构
```

**🌳 菜单树形结构示例**：
```
系统管理 (id=1, parent_id=0)
  ├─ 用户管理 (id=2, parent_id=1)
  │   ├─ 用户列表 (id=3, parent_id=2)
  │   └─ 添加用户 (id=4, parent_id=2)
  └─ 角色管理 (id=5, parent_id=1)
      ├─ 角色列表 (id=6, parent_id=5)
      └─ 分配权限 (id=7, parent_id=5)
```

### 3.3 递归查询实现


**💡 业务需求**：查询用户的所有菜单（包括子菜单）

**🔸 方案一：递归SQL**（MySQL 8.0+）：
```xml
<select id="getUserMenuTree" resultType="Menu">
    WITH RECURSIVE menu_tree AS (
        -- 查询顶级菜单
        SELECT * FROM menu WHERE parent_id = 0
        UNION ALL
        -- 递归查询子菜单
        SELECT m.* FROM menu m
        INNER JOIN menu_tree mt ON m.parent_id = mt.id
    )
    SELECT * FROM menu_tree
    WHERE id IN (
        SELECT menu_id FROM user_menu WHERE user_id = #{userId}
    )
</select>
```

**🔸 方案二：Java递归组装**（兼容性好）：
```java
// 1. 先查出所有菜单（一次查询）
List<Menu> allMenus = menuMapper.findByUserId(userId);

// 2. Java代码组装树形结构
public List<Menu> buildTree(List<Menu> menus) {
    Map<Long, Menu> menuMap = new HashMap<>();
    List<Menu> rootMenus = new ArrayList<>();
    
    // 先放入Map，方便查找
    for (Menu menu : menus) {
        menuMap.put(menu.getId(), menu);
    }
    
    // 组装父子关系
    for (Menu menu : menus) {
        if (menu.getParentId() == 0) {
            rootMenus.add(menu);  // 顶级菜单
        } else {
            Menu parent = menuMap.get(menu.getParentId());
            if (parent != null) {
                parent.getChildren().add(menu);  // 添加到父菜单
            }
        }
    }
    return rootMenus;
}
```

**💭 为什么用方案二**：
- 方案一：SQL简洁，但老版MySQL不支持
- 方案二：兼容性好，只需一次数据库查询

### 3.4 动态权限控制


**🎯 需求**：不同角色看到不同的按钮

**实现步骤**：
```
1. 用户登录
   ↓
2. 查询用户的所有权限（MyBatis）
   ↓
3. 存入Session或Redis
   ↓
4. 前端根据权限显示/隐藏按钮
   ↓
5. 后端接口再次校验权限（防止绕过）
```

**关键代码**（动态SQL根据权限查询）：
```xml
<select id="getUserButtons" resultType="Button">
    SELECT * FROM button
    WHERE 1=1
    <if test="permissions != null">
        AND code IN
        <foreach collection="permissions" item="perm" 
                 open="(" close=")" separator=",">
            #{perm}
        </foreach>
    </if>
</select>
```

---

## 4. 📝 内容管理系统


### 4.1 内容管理系统特点


**📰 什么是CMS**：
内容管理系统（Content Management System），比如：
- 新闻网站（发文章、图片）
- 博客系统（写博客、评论）
- 知识库（文档管理）

**🔑 核心功能**：
- **内容创建**：富文本编辑、图片上传
- **内容分类**：多级分类、标签管理
- **内容检索**：全文搜索、高级筛选
- **版本控制**：草稿、发布、历史版本

### 4.2 数据模型设计


**📊 主要表结构**：
```
文章表(article)
    ├─ article_id (主键)
    ├─ title (标题)
    ├─ content (内容，TEXT类型)
    ├─ category_id (分类ID)
    ├─ status (状态：草稿/发布)
    └─ create_time (创建时间)

分类表(category) - 树形结构
    ├─ category_id
    ├─ name
    └─ parent_id

标签表(tag)
    └─ tag_id, tag_name

文章标签关联表(article_tag)
    ├─ article_id
    └─ tag_id
```

### 4.3 全文搜索优化


**🔍 搜索需求**：用户输入关键词，搜索标题和内容

**方案对比**：

| 方案 | **实现方式** | **优点** | **缺点** |
|-----|------------|---------|---------|
| `LIKE查询` | `WHERE title LIKE '%关键词%'` | 简单 | 慢，不支持分词 |
| `全文索引` | `FULLTEXT INDEX` | 较快，支持中文 | 配置复杂 |
| `Elasticsearch` | 独立搜索引擎 | 快，功能强 | 需要额外部署 |

**💡 推荐方案**：数据量小用FULLTEXT，大了用ES

**MyBatis实现**（全文索引）：
```xml
<!-- 创建全文索引 -->
ALTER TABLE article ADD FULLTEXT INDEX ft_title_content (title, content);

<!-- 搜索查询 -->
<select id="searchArticles" resultType="Article">
    SELECT * FROM article
    WHERE MATCH(title, content) AGAINST(#{keyword} IN NATURAL LANGUAGE MODE)
    <if test="categoryId != null">
        AND category_id = #{categoryId}
    </if>
    ORDER BY create_time DESC
    LIMIT #{offset}, #{pageSize}
</select>
```

### 4.4 分页性能优化


**⚠️ 深度分页问题**：
```
-- 慢查询（第10000页）
SELECT * FROM article 
ORDER BY create_time DESC 
LIMIT 100000, 20;  -- 要跳过10万条数据！
```

**✅ 优化方案（游标分页）**：
```xml
<select id="getArticlesByLastId" resultType="Article">
    SELECT * FROM article
    WHERE article_id < #{lastId}
    ORDER BY article_id DESC
    LIMIT #{pageSize}
</select>
```

**原理**：
- 不用`LIMIT 100000, 20`跳过数据
- 记住上一页最后一条的ID
- 下一页直接从这个ID开始查

---

## 5. 📊 数据分析平台


### 5.1 数据分析的特点


**📈 什么是数据分析平台**：
就像公司的"数据大脑"，回答这些问题：
- 这个月销售额多少？
- 哪个产品卖得最好？
- 用户增长趋势如何？

**🔑 技术挑战**：
- **数据量大**：可能几百万、上千万条记录
- **查询复杂**：GROUP BY、JOIN、子查询
- **实时性要求**：几秒内返回结果

### 5.2 聚合查询优化


**📊 常见分析查询**：

**场景1：销售统计**
```xml
<select id="getSalesSummary" resultType="SalesSummary">
    SELECT 
        DATE_FORMAT(order_time, '%Y-%m') AS month,
        COUNT(*) AS order_count,
        SUM(total_amount) AS total_sales,
        AVG(total_amount) AS avg_order_value
    FROM t_order
    WHERE order_time BETWEEN #{startDate} AND #{endDate}
      AND status = 'paid'
    GROUP BY DATE_FORMAT(order_time, '%Y-%m')
    ORDER BY month DESC
</select>
```

**🎯 关键点**：
- `DATE_FORMAT`：按月分组统计
- `SUM/AVG`：计算总额和平均值
- 确保`order_time`字段有索引

**场景2：商品排行榜**
```xml
<select id="getTopProducts" resultType="ProductRank">
    SELECT 
        p.product_name,
        SUM(oi.quantity) AS total_quantity,
        SUM(oi.subtotal) AS total_revenue
    FROM order_item oi
    INNER JOIN product p ON oi.product_id = p.product_id
    WHERE oi.create_time >= #{startDate}
    GROUP BY oi.product_id, p.product_name
    ORDER BY total_revenue DESC
    LIMIT #{topN}
</select>
```

### 5.3 批量处理策略


**💡 场景**：每天凌晨统计昨天的数据

**方案1：大事务处理**（❌不推荐）
```java
// 一次性处理100万条数据 - 容易内存溢出
List<Order> orders = orderMapper.getYesterdayOrders(); 
processBatch(orders);
```

**方案2：分批处理**（✅推荐）
```java
int pageSize = 1000;
int pageNum = 1;
boolean hasMore = true;

while (hasMore) {
    // 每次只查1000条
    List<Order> batch = orderMapper.getOrdersByPage(pageNum, pageSize);
    if (batch.isEmpty()) {
        hasMore = false;
    } else {
        processBatch(batch);  // 处理这批数据
        pageNum++;
    }
}
```

**MyBatis配置**（流式查询）：
```xml
<select id="streamOrders" resultType="Order" fetchSize="1000">
    SELECT * FROM t_order 
    WHERE create_time >= #{startDate}
</select>
```

### 5.4 实时数据大屏


**📺 数据大屏需求**：
- 实时显示订单数、销售额
- 每5秒刷新一次
- 要快！

**架构设计**：
```
实时数据流：
订单创建 → MQ消息 → Redis计数器 → 前端展示
            ↓
        定时同步到MySQL（每分钟）

历史数据查询：
前端请求 → MyBatis查询 → 返回图表数据
```

**关键技术**：
- **Redis**：存实时计数（快）
- **MyBatis**：查历史趋势（准）
- **定时任务**：同步数据（一致）

---

## 6. 📈 实时监控系统


### 6.1 监控系统的作用


**🔍 为什么需要监控**：
想象你开了一家饭店，你需要知道：
- 有多少客人在等位？（并发数）
- 后厨做菜快不快？（响应时间）
- 有没有菜做坏了？（错误率）

**📊 监控指标分类**：

| 类型 | **具体指标** | **MyBatis相关** |
|-----|------------|----------------|
| **性能** | 响应时间、吞吐量 | SQL执行耗时 |
| **业务** | 订单量、用户活跃 | 业务数据统计 |
| **错误** | 异常次数、失败率 | SQL错误日志 |
| **资源** | CPU、内存、连接数 | 数据库连接池 |

### 6.2 SQL执行监控


**⏱️ 慢SQL检测**：

**MyBatis拦截器实现**：
```java
@Intercepts({
    @Signature(type = Executor.class, method = "query", args = {...})
})
public class SlowSqlInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long start = System.currentTimeMillis();
        
        // 执行SQL
        Object result = invocation.proceed();
        
        long duration = System.currentTimeMillis() - start;
        
        // 超过阈值记录日志
        if (duration > 1000) {  // 1秒
            String sql = getSql(invocation);
            log.warn("慢SQL: {}ms - {}", duration, sql);
        }
        
        return result;
    }
}
```

**💡 作用**：
- 自动检测慢SQL
- 记录执行时间
- 便于性能优化

### 6.3 连接池监控


**🏊 什么是连接池**：
就像停车场，数据库连接就是车位：
- 总共100个车位（最大连接数）
- 现在用了80个（活跃连接）
- 还剩20个（空闲连接）

**监控配置**（Druid连接池）：
```yaml
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      # 初始连接数
      initial-size: 5
      # 最小空闲连接
      min-idle: 5
      # 最大活跃连接
      max-active: 20
      # 监控统计
      stat-view-servlet:
        enabled: true
        url-pattern: /druid/*
```

**📈 关键指标**：
- **连接数使用率**：别超过80%
- **等待线程数**：有人在等说明不够用
- **连接泄漏**：连接没还回来

### 6.4 实时告警机制


**🚨 告警规则示例**：
```
规则1：SQL执行超过3秒 → 发送告警
规则2：数据库连接超过90% → 发送告警  
规则3：5分钟内错误超过100次 → 发送告警
```

**实现方式**：
```java
// 监控数据收集
@Scheduled(fixedRate = 60000)  // 每分钟
public void collectMetrics() {
    // 1. 查询慢SQL统计
    List<SlowSql> slowSqls = monitorMapper.getSlowSqlStats();
    
    // 2. 检查连接池状态
    DataSource ds = (DataSource) applicationContext.getBean("dataSource");
    int activeCount = ds.getActiveCount();
    
    // 3. 触发告警
    if (activeCount > ds.getMaxActive() * 0.9) {
        sendAlert("数据库连接数过高: " + activeCount);
    }
}
```

---

## 7. 🔧 完整技术栈整合


### 7.1 技术栈选型


**🛠️ 后端核心技术**：
```
框架层：
  Spring Boot         - 整体框架（简化配置）
  MyBatis / MyBatis-Plus  - 持久层（数据访问）

缓存层：
  Redis              - 热点数据缓存
  Caffeine           - 本地缓存

消息队列：
  RabbitMQ / Kafka   - 异步处理、削峰

数据库：
  MySQL              - 主数据库
  Elasticsearch      - 搜索引擎（可选）
```

**💡 为什么这样选**：
- **Spring Boot**：开箱即用，配置简单
- **MyBatis**：灵活SQL，适合复杂查询
- **Redis**：速度快，减轻数据库压力
- **消息队列**：解耦系统，提高性能

### 7.2 整合配置示例


**📦 Maven依赖**：
```xml
<dependencies>
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- MyBatis -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.3.0</version>
    </dependency>
    
    <!-- Redis -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
</dependencies>
```

**⚙️ 核心配置**（application.yml）：
```yaml
mybatis:
  mapper-locations: classpath:mapper/*.xml
  configuration:
    map-underscore-to-camel-case: true  # 下划线转驼峰
    cache-enabled: true                 # 开启二级缓存
    
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db
    username: root
    password: 123456
    
  redis:
    host: localhost
    port: 6379
```

### 7.3 多数据源配置


**🔀 什么时候用多数据源**：
- 读写分离（主库写，从库读）
- 业务拆分（订单库、用户库）

**配置示例**：
```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public DynamicDataSource dynamicDataSource() {
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("master", masterDataSource());
        targetDataSources.put("slave", slaveDataSource());
        
        DynamicDataSource dataSource = new DynamicDataSource();
        dataSource.setTargetDataSources(targetDataSources);
        dataSource.setDefaultTargetDataSource(masterDataSource());
        return dataSource;
    }
}
```

**使用方式**：
```java
@Service
public class OrderService {
    
    @DataSource("master")  // 切换到主库
    public void createOrder(Order order) {
        orderMapper.insert(order);
    }
    
    @DataSource("slave")   // 切换到从库
    public List<Order> getOrders() {
        return orderMapper.selectAll();
    }
}
```

---

## 8. ⚡ 性能测试与优化


### 8.1 性能测试指标


**📊 核心指标说明**：

| 指标 | **含义** | **目标值** | **测试工具** |
|-----|---------|-----------|------------|
| **响应时间** | 请求到返回的时间 | <200ms | JMeter |
| **吞吐量** | 每秒处理请求数 | >1000 QPS | JMeter |
| **并发数** | 同时访问的用户数 | 支持500+ | LoadRunner |
| **错误率** | 失败请求占比 | <0.1% | - |

**🎯 测试场景设计**：
```
压力测试：
  模拟100个用户同时下单
  持续10分钟
  观察系统表现

峰值测试：
  模拟1000个用户瞬间访问
  观察系统是否崩溃

稳定性测试：
  模拟200个用户持续访问
  持续24小时
  检查内存泄漏
```

### 8.2 SQL性能分析


**🔍 慢SQL排查步骤**：

**步骤1：开启慢查询日志**
```sql
-- MySQL配置
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 超过1秒记录
```

**步骤2：分析执行计划**
```sql
EXPLAIN SELECT * FROM t_order 
WHERE user_id = 123 
ORDER BY create_time DESC;

-- 关注这些字段：
-- type：访问类型（ALL最差，const最好）
-- key：使用的索引
-- rows：扫描行数
```

**步骤3：优化方案**：

| 问题 | **现象** | **解决方案** |
|-----|---------|------------|
| 全表扫描 | `type=ALL` | 添加索引 |
| 索引失效 | `key=NULL` | 检查WHERE条件 |
| 返回字段太多 | `SELECT *` | 只查需要的字段 |
| JOIN表太多 | `>3个表` | 拆分查询或冗余字段 |

### 8.3 缓存优化策略


**🚀 三级缓存架构**：
```
请求流程：
1. 查本地缓存（Caffeine）- 最快
   ↓ 没有
2. 查Redis缓存 - 较快
   ↓ 没有
3. 查数据库（MyBatis）- 较慢
   ↓
4. 数据写入缓存
```

**实现示例**：
```java
@Service
public class ProductService {
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    @Autowired  
    private ProductMapper productMapper;
    
    public Product getProduct(Long id) {
        String key = "product:" + id;
        
        // 1. 查Redis
        Product product = (Product) redisTemplate.opsForValue().get(key);
        
        if (product == null) {
            // 2. 查数据库
            product = productMapper.selectById(id);
            
            // 3. 写入缓存（1小时过期）
            if (product != null) {
                redisTemplate.opsForValue().set(key, product, 1, TimeUnit.HOURS);
            }
        }
        
        return product;
    }
}
```

**💡 缓存穿透防护**：
```java
// 布隆过滤器拦截不存在的数据
if (!bloomFilter.mightContain(id)) {
    return null;  // 肯定不存在，直接返回
}
```

### 8.4 批量操作优化


**⚠️ 问题场景**：插入10000条数据

**方式1：循环插入**（❌慢）
```java
for (Order order : orders) {
    orderMapper.insert(order);  // 执行10000次SQL
}
```

**方式2：批量插入**（✅快）
```xml
<insert id="batchInsert">
    INSERT INTO t_order (order_no, user_id, total_amount) 
    VALUES
    <foreach collection="list" item="order" separator=",">
        (#{order.orderNo}, #{order.userId}, #{order.totalAmount})
    </foreach>
</insert>
```

**性能对比**：
- 循环插入：10000次网络往返
- 批量插入：1次网络往返
- **速度提升：10-100倍**

---

## 9. 🚀 上线部署方案


### 9.1 部署环境准备


**🏗️ 服务器环境**：
```
生产环境配置：
  服务器：2台应用服务器（负载均衡）
  数据库：1主2从（读写分离）
  缓存：Redis集群（3节点）
  
最低配置：
  CPU：4核
  内存：8GB
  硬盘：100GB SSD
```

**📦 软件环境**：
```bash
# 1. 安装JDK
yum install java-11-openjdk

# 2. 安装MySQL
yum install mysql-server

# 3. 安装Redis
yum install redis

# 4. 安装Nginx（负载均衡）
yum install nginx
```

### 9.2 数据库部署方案


**🗄️ MySQL主从复制**：
```
架构：
  Master（主库）← 写操作
    ↓ 复制
  Slave1（从库）← 读操作
  Slave2（从库）← 读操作
```

**配置步骤**：
```sql
-- 主库配置（my.cnf）
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-do-db=your_database

-- 从库配置
[mysqld]
server-id=2
relay-log=mysql-relay-bin
```

**MyBatis读写分离**：
```java
// 写操作走主库
@DataSource("master")
public void createOrder(Order order) {
    orderMapper.insert(order);
}

// 读操作走从库
@DataSource("slave")
public List<Order> getOrders() {
    return orderMapper.selectAll();
}
```

### 9.3 应用部署方案


**📦 打包配置**（pom.xml）：
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <mainClass>com.example.Application</mainClass>
            </configuration>
        </plugin>
    </plugins>
</build>
```

**🚀 部署步骤**：
```bash
# 1. 打包
mvn clean package -Dmaven.test.skip=true

# 2. 上传到服务器
scp target/app.jar root@server:/app/

# 3. 启动应用
nohup java -jar app.jar \
  --spring.profiles.active=prod \
  > app.log 2>&1 &

# 4. 查看日志
tail -f app.log
```

### 9.4 生产环境配置


**⚙️ 生产配置**（application-prod.yml）：
```yaml
spring:
  datasource:
    master:
      url: jdbc:mysql://db-master:3306/prod_db
      username: ${DB_USER}      # 环境变量
      password: ${DB_PASSWORD}  # 环境变量
    slave:
      url: jdbc:mysql://db-slave:3306/prod_db
      
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
    
logging:
  level:
    root: INFO
    com.example.mapper: WARN  # 生产环境减少日志
```

**🔒 安全配置**：
```yaml
# 数据库连接加密
spring:
  datasource:
    url: jdbc:mysql://...?useSSL=true&requireSSL=true
    
# SQL注入防护（PreparedStatement）
mybatis:
  configuration:
    default-statement-timeout: 30  # 超时时间
```

### 9.5 监控与运维


**📊 监控方案**：
```
应用监控：
  - Spring Boot Actuator（健康检查）
  - Prometheus + Grafana（指标监控）
  
数据库监控：
  - MySQL慢查询日志
  - Druid连接池监控
  
日志收集：
  - ELK（Elasticsearch + Logstash + Kibana）
```

**🚨 告警规则**：
```
CPU使用率 > 80%         → 告警
内存使用率 > 85%         → 告警
数据库连接数 > 90%      → 告警
接口响应时间 > 3秒      → 告警
5分钟错误数 > 100       → 告警
```

**🔄 发布流程**：
```
1. 本地测试通过
   ↓
2. 提交代码到Git
   ↓
3. CI/CD自动打包
   ↓
4. 部署到测试环境验证
   ↓
5. 灰度发布（10%流量）
   ↓
6. 全量发布
   ↓
7. 监控观察
```

---

## 10. 📋 核心要点总结


### 10.1 五大项目核心对比


| 项目 | **核心技术** | **适用场景** | **重点掌握** |
|-----|------------|-------------|------------|
| 🛒 **电商** | 事务、缓存、队列 | 高并发、强一致 | 超卖防护、性能优化 |
| 🔐 **权限** | 递归查询、动态SQL | 复杂权限控制 | 树形数据、RBAC模型 |
| 📝 **CMS** | 全文搜索、分页 | 内容密集型 | 搜索优化、深度分页 |
| 📊 **分析** | 聚合查询、批处理 | 数据密集型 | 复杂统计、大数据量 |
| 📈 **监控** | 拦截器、定时任务 | 运维监控 | 慢SQL检测、告警 |

### 10.2 MyBatis在项目中的作用


**🎯 关键价值**：

**1. 灵活的SQL控制**
```
业务复杂 → 需要复杂SQL → MyBatis动态SQL
电商搜索、数据统计、权限查询都需要这个能力
```

**2. 性能优化能力**
```
- 一级缓存：Session级别
- 二级缓存：Mapper级别  
- 批量操作：减少网络开销
- 延迟加载：按需查询
```

**3. 易于维护**
```
SQL写在XML → 修改不用改代码
业务变化快 → 容易调整查询逻辑
```

### 10.3 项目开发最佳实践


**✅ 开发规范**：

**命名规范**：
- Mapper接口：`XxxMapper`
- XML文件：`XxxMapper.xml`
- 结果映射：`xxxResultMap`

**SQL规范**：
- 避免`SELECT *`，明确列名
- 复杂查询加注释
- 参数用`#{}`而不是`${}`（防注入）

**性能规范**：
- 合理使用索引
- 批量操作用`foreach`
- 大查询用分页
- 热点数据用缓存

**🔒 安全规范**：
```java
// ❌ 错误：SQL注入风险
WHERE name = '${name}'

// ✅ 正确：使用预编译
WHERE name = #{name}

// ✅ 正确：动态表名时要校验
<if test="tableName != null">
    ${@com.example.util.TableValidator@validate(tableName)}
</if>
```

### 10.4 项目上线检查清单


**📋 上线前检查**：

**代码层面**：
- [ ] SQL注入检查
- [ ] 慢SQL优化
- [ ] 异常处理完善
- [ ] 日志级别调整

**配置层面**：
- [ ] 数据库连接池配置
- [ ] 缓存过期时间
- [ ] 事务超时设置
- [ ] 监控告警配置

**测试层面**：
- [ ] 单元测试覆盖
- [ ] 接口测试通过
- [ ] 压力测试达标
- [ ] 回归测试通过

**部署层面**：
- [ ] 数据库备份
- [ ] 灰度发布方案
- [ ] 回滚方案准备
- [ ] 监控看板配置

### 10.5 学习路径建议


**🎓 进阶学习路线**：

**初级阶段**：
1. 完成权限管理系统（树形结构、动态SQL）
2. 完成内容管理系统（搜索、分页）
3. **掌握**：基本CRUD、动态SQL、关联查询

**中级阶段**：
4. 完成电商系统（事务、缓存、并发）
5. 完成监控系统（拦截器、性能优化）
6. **掌握**：性能优化、缓存策略、事务控制

**高级阶段**：
7. 完成数据分析平台（复杂查询、大数据量）
8. 学习分库分表、读写分离
9. **掌握**：架构设计、中间件集成、生产实践

**💡 学习建议**：
- 每个项目都要**自己动手做**
- 遇到问题先**分析原理**再找答案
- **性能优化**是重点，多做压测
- 关注**生产环境**的实际问题

---

**🎯 总结一句话**：
MyBatis不只是一个ORM工具，更是连接业务逻辑和数据存储的桥梁。通过这五个项目的实战，你不仅学会了MyBatis的用法，更重要的是掌握了如何在真实业务场景中解决问题的能力。记住：**技术是为业务服务的，理解业务才能写出好代码**！