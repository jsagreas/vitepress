---
title: 21、一级缓存机制
---
## 📚 目录

1. [一级缓存是什么](#1-一级缓存是什么)
2. [SqlSession级别缓存详解](#2-SqlSession级别缓存详解)
3. [PerpetualCache实现原理](#3-PerpetualCache实现原理)
4. [缓存生命周期管理](#4-缓存生命周期管理)
5. [缓存清除时机详解](#5-缓存清除时机详解)
6. [缓存命中策略](#6-缓存命中策略)
7. [脏数据问题与解决](#7-脏数据问题与解决)
8. [缓存失效场景](#8-缓存失效场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 💡 一级缓存是什么


### 1.1 用生活例子理解一级缓存

🎯 **想象你在图书馆借书**

```
不使用缓存的情况：
每次想看同一本书 → 都要去书架找 → 浪费时间

使用缓存的情况：
第一次去书架找到书 → 放在你的桌子上（缓存）
再想看这本书 → 直接从桌子拿 → 节省时间

MyBatis一级缓存就是这样：
第一次查询数据库 → 把结果放在内存里
再次查询相同数据 → 直接从内存拿 → 不用访问数据库
```

### 1.2 一级缓存的核心特点

**🔸 什么是一级缓存**
```
一级缓存的本质：
- 它是MyBatis自带的缓存功能
- 默认就是开启的，不需要配置
- 缓存存储在SqlSession对象中
- 只在一个SqlSession内有效

通俗理解：
一级缓存 = SqlSession的"临时记事本"
把查询结果暂时记下来，下次直接用
```

**📊 缓存级别对比**

| 特性 | **一级缓存** | **二级缓存** |
|------|-------------|-------------|
| 🔸 **作用范围** | `单个SqlSession` | `整个Mapper/命名空间` |
| 🔸 **默认状态** | `自动开启` | `需要配置开启` |
| 🔸 **生命周期** | `SqlSession创建到关闭` | `应用运行期间` |
| 🔸 **使用场景** | `单次会话内重复查询` | `跨会话共享数据` |
| 🔸 **线程安全** | `天然隔离` | `需要序列化` |

### 1.3 一级缓存的价值

**⚡ 为什么需要一级缓存**

```
性能提升：
场景：用户查看订单详情页面
- 需要查询订单信息
- 需要查询订单商品
- 需要查询用户信息

如果没有缓存：
每个查询都访问数据库 → 3次数据库IO → 慢

有了一级缓存：
相同查询只访问一次数据库 → 其余从内存读取 → 快
```

**💰 实际收益**
```
数据库压力降低：
- 减少重复的SQL执行
- 降低数据库连接消耗
- 提升整体并发能力

响应速度提升：
- 内存访问比磁盘快1000倍以上
- 用户感受更流畅
- 系统吞吐量提高
```

---

## 2. 🔐 SqlSession级别缓存详解


### 2.1 SqlSession的作用域

**🎯 理解SqlSession的生命周期**

```
SqlSession就像一次"会话"：
开始：用户发起请求
过程：执行多次数据库操作
结束：请求处理完毕

生活类比：
SqlSession = 你去银行办业务的一次访问
- 进银行门 = 创建SqlSession
- 办理多项业务 = 执行多次查询
- 离开银行 = 关闭SqlSession
```

**🔧 SqlSession使用示例**
```java
// 典型的SqlSession使用流程
public User getUserInfo(int userId) {
    // 1. 获取SqlSession（进银行）
    SqlSession session = sqlSessionFactory.openSession();
    
    try {
        // 2. 第一次查询用户信息（第一次查数据库）
        User user = session.selectOne("UserMapper.selectById", userId);
        System.out.println("第一次查询：" + user);
        
        // 3. 再次查询相同用户（从缓存读取，不查数据库）
        User user2 = session.selectOne("UserMapper.selectById", userId);
        System.out.println("第二次查询：" + user2);
        
        // 注意：user 和 user2 是同一个对象！
        System.out.println(user == user2);  // 输出：true
        
        return user;
    } finally {
        // 4. 关闭SqlSession（离开银行）
        session.close();  // 缓存被清空
    }
}
```

### 2.2 本地缓存作用域

**📦 缓存的"隔离性"**

```
重要特性：
每个SqlSession都有自己独立的缓存
就像每个人都有自己的笔记本

SqlSession A的缓存 ≠ SqlSession B的缓存

实际表现：
SqlSession A查询用户ID=1 → A的缓存有数据
SqlSession B查询用户ID=1 → B需要重新查数据库
```

**💡 多SqlSession场景演示**
```java
public void demonstrateCacheScope() {
    // 场景：两个独立的SqlSession
    
    // SqlSession A
    SqlSession sessionA = sqlSessionFactory.openSession();
    User userA = sessionA.selectOne("UserMapper.selectById", 1);
    // sessionA的缓存中有了 ID=1 的用户数据
    
    // SqlSession B（完全独立的会话）
    SqlSession sessionB = sqlSessionFactory.openSession();
    User userB = sessionB.selectOne("UserMapper.selectById", 1);
    // sessionB需要重新查询数据库，因为它有自己的缓存
    
    // 关键点：userA 和 userB 是不同的对象
    System.out.println(userA == userB);  // 输出：false
    
    sessionA.close();
    sessionB.close();
}
```

### 2.3 为什么设计成SqlSession级别

**🤔 设计思考**

```
优点：
1. 线程安全
   每个请求用自己的SqlSession → 天然隔离
   不需要考虑并发问题

2. 数据一致性
   单次请求内数据保持一致
   适合事务处理场景

3. 自动清理
   SqlSession关闭 → 缓存自动清空
   不会有内存泄漏问题

缺点：
1. 作用范围有限
   不能跨SqlSession共享缓存
   
2. 缓存利用率低
   每次新的请求都要重新建缓存
```

---

## 3. 🔍 PerpetualCache实现原理


### 3.1 PerpetualCache是什么

**🎯 缓存的底层实现**

```
PerpetualCache的本质：
它是MyBatis内置的缓存实现类
用最简单的HashMap来存储数据

类比理解：
PerpetualCache = 一个大的"字典"
键（Key）= 查询条件
值（Value）= 查询结果
```

**📋 核心结构**
```java
// PerpetualCache的简化实现
public class PerpetualCache implements Cache {
    
    // 核心：用HashMap存储缓存数据
    private Map<Object, Object> cache = new HashMap<>();
    
    // 存入缓存
    public void putObject(Object key, Object value) {
        cache.put(key, value);
    }
    
    // 从缓存获取
    public Object getObject(Object key) {
        return cache.get(key);
    }
    
    // 清空缓存
    public void clear() {
        cache.clear();
    }
}
```

### 3.2 缓存Key的生成规则

**🔑 如何判断两次查询是否相同**

```
MyBatis通过CacheKey来判断查询是否相同
CacheKey包含以下信息：

1. SQL的ID（哪个Mapper的哪个方法）
2. SQL语句本身
3. 参数值
4. 分页信息（RowBounds）
5. SQL执行环境

只有这些信息完全相同，才会命中缓存
```

**💡 缓存Key示例**
```java
// 示例1：两次查询相同，命中缓存
session.selectOne("UserMapper.selectById", 1);  // 第一次查询，查数据库
session.selectOne("UserMapper.selectById", 1);  // 第二次查询，从缓存读

// 示例2：参数不同，不会命中缓存
session.selectOne("UserMapper.selectById", 1);  // 查数据库，缓存ID=1的数据
session.selectOne("UserMapper.selectById", 2);  // 查数据库，参数不同

// 示例3：SQL不同，不会命中缓存
session.selectOne("UserMapper.selectById", 1);      // 查数据库
session.selectOne("UserMapper.selectByName", "张三"); // 查数据库，SQL不同
```

### 3.3 缓存存储结构

**📦 数据如何组织**

```
内存结构示意：

PerpetualCache (HashMap)
├─ CacheKey1 → User对象1
│  └─ [UserMapper.selectById:1:0:0]
│
├─ CacheKey2 → List<Order>
│  └─ [OrderMapper.selectByUserId:1:0:10]
│
└─ CacheKey3 → User对象2
   └─ [UserMapper.selectById:2:0:0]

特点：
- Key是复杂对象（CacheKey）
- Value是查询结果对象
- HashMap提供O(1)的查询速度
```

---

## 4. ⏱️ 缓存生命周期管理


### 4.1 缓存的创建时机

**🚀 缓存什么时候开始工作**

```
缓存创建流程：

1. 创建SqlSession
   SqlSession session = sqlSessionFactory.openSession();
   ↓
2. MyBatis自动创建Executor
   Executor executor = new SimpleExecutor(...);
   ↓
3. Executor自动创建PerpetualCache
   PerpetualCache cache = new PerpetualCache("LocalCache");
   ↓
4. 缓存就绪，可以使用了
```

**🔸 关键点理解**
```
重要：一级缓存是自动创建的
- 不需要任何配置
- SqlSession创建时就有了
- 程序员感知不到创建过程
- 就像你买车时轮胎是自带的
```

### 4.2 缓存的活动期

**💪 缓存的有效时间**

```
缓存的有效期 = SqlSession的生命周期

完整流程：
┌─────────────────────────┐
│ 1. 创建SqlSession        │ ← 缓存创建
├─────────────────────────┤
│ 2. 执行查询操作          │ ← 缓存使用
│    - 第一次查询 → 存缓存 │
│    - 重复查询 → 读缓存   │
├─────────────────────────┤
│ 3. 执行更新操作          │ ← 缓存清空
│    - insert/update/delete│
│    - commit/rollback     │
├─────────────────────────┤
│ 4. 关闭SqlSession        │ ← 缓存销毁
└─────────────────────────┘
```

**⏰ 时间线示例**
```java
// 完整的缓存生命周期演示
public void cacheLifecycleDemo() {
    SqlSession session = sqlSessionFactory.openSession();
    // ↑ 时刻T1：缓存创建
    
    // 时刻T2：第一次查询（查数据库，存入缓存）
    User user1 = session.selectOne("UserMapper.selectById", 1);
    
    // 时刻T3：第二次查询（从缓存读取）
    User user2 = session.selectOne("UserMapper.selectById", 1);
    
    // 时刻T4：执行更新（缓存被清空）
    session.update("UserMapper.updateById", user1);
    
    // 时刻T5：再次查询（缓存已空，重新查数据库）
    User user3 = session.selectOne("UserMapper.selectById", 1);
    
    session.close();
    // ↑ 时刻T6：缓存销毁
}
```

### 4.3 跨方法的缓存共享

**🔄 同一SqlSession内的缓存共享**

```
关键理解：
只要是同一个SqlSession，缓存就是共享的
即使在不同的方法中调用

示例场景：
方法A查询用户 → 缓存中有了用户数据
方法B查询用户 → 可以从缓存读取
前提：方法A和方法B使用同一个SqlSession
```

**💡 实战示例**
```java
// Spring环境下的缓存共享
@Service
public class UserService {
    
    @Autowired
    private SqlSessionFactory sqlSessionFactory;
    
    // 注意：这个方法会创建新的SqlSession
    public void processUserData(int userId) {
        // 手动管理SqlSession
        SqlSession session = sqlSessionFactory.openSession();
        
        try {
            // 步骤1：查询用户基本信息
            getUserInfo(session, userId);
            
            // 步骤2：查询用户订单（内部可能再次查用户信息）
            getUserOrders(session, userId);
            
            // 步骤3：处理业务逻辑
            processBusinessLogic(session, userId);
            
            session.commit();
        } catch (Exception e) {
            session.rollback();
        } finally {
            session.close();
        }
    }
    
    // 这些方法复用同一个SqlSession，缓存可以共享
    private User getUserInfo(SqlSession session, int userId) {
        return session.selectOne("UserMapper.selectById", userId);
        // 第一次查询，数据库 → 缓存
    }
    
    private void getUserOrders(SqlSession session, int userId) {
        // 可能内部又查了用户信息
        User user = session.selectOne("UserMapper.selectById", userId);
        // 从缓存读取，不查数据库！
    }
    
    private void processBusinessLogic(SqlSession session, int userId) {
        // 业务处理...
    }
}
```

---

## 5. 🧹 缓存清除时机详解


### 5.1 commit清除缓存

**💾 提交事务时的缓存处理**

```
为什么commit要清除缓存？

场景分析：
1. 查询用户信息 → 缓存中有数据（余额：100元）
2. 更新用户余额 → 数据库改为200元
3. 提交事务 → 数据库确认修改
4. 如果不清缓存 → 缓存还是100元（脏数据！）

所以必须清除缓存，确保下次查询拿到最新数据
```

**🔧 commit清除示例**
```java
public void updateUserBalance(int userId, BigDecimal amount) {
    SqlSession session = sqlSessionFactory.openSession();
    
    try {
        // 1. 查询用户（数据进入缓存）
        User user = session.selectOne("UserMapper.selectById", userId);
        System.out.println("查询结果：余额 = " + user.getBalance());
        // 假设余额是100元
        
        // 2. 更新余额
        user.setBalance(amount);
        session.update("UserMapper.updateBalance", user);
        // 此时数据库已更新为200元
        
        // 3. 提交事务（关键：清除缓存）
        session.commit();
        // ↑ 这一步会清空所有一级缓存
        
        // 4. 再次查询（从数据库重新查询）
        User updatedUser = session.selectOne("UserMapper.selectById", userId);
        System.out.println("更新后：余额 = " + updatedUser.getBalance());
        // 输出：余额 = 200元（最新数据）
        
    } finally {
        session.close();
    }
}
```

### 5.2 rollback清除缓存

**🔙 回滚事务时的缓存处理**

```
为什么rollback要清除缓存？

场景分析：
1. 查询订单状态 → 缓存中有数据（状态：待支付）
2. 更新订单状态为"已支付"
3. 后续操作出错，回滚事务
4. 数据库恢复到"待支付"状态
5. 如果不清缓存 → 缓存还是"已支付"（错误！）

rollback必须清除缓存，保证数据一致性
```

**⚠️ rollback场景示例**
```java
public void processOrder(int orderId) {
    SqlSession session = sqlSessionFactory.openSession();
    
    try {
        // 1. 查询订单（缓存：状态=待支付）
        Order order = session.selectOne("OrderMapper.selectById", orderId);
        System.out.println("初始状态：" + order.getStatus());
        
        // 2. 更新订单状态
        order.setStatus("已支付");
        session.update("OrderMapper.updateStatus", order);
        
        // 3. 其他业务操作
        doSomeBusiness();  // 假设这里出错了
        
        // 4. 提交
        session.commit();
        
    } catch (Exception e) {
        // 5. 回滚（关键：清除缓存）
        session.rollback();
        // ↑ 这一步会清空所有一级缓存
        
        System.out.println("操作失败，已回滚");
        
        // 6. 再次查询（从数据库重新查，拿到回滚后的数据）
        Order order = session.selectOne("OrderMapper.selectById", orderId);
        System.out.println("回滚后状态：" + order.getStatus());
        // 输出：状态 = 待支付（数据库回滚后的状态）
        
    } finally {
        session.close();
    }
}
```

### 5.3 close清除缓存

**🚪 关闭SqlSession时的缓存处理**

```
close清除缓存是最彻底的：

SqlSession关闭流程：
1. 关闭数据库连接
2. 清空所有缓存
3. 释放所有资源
4. SqlSession对象失效

缓存随着SqlSession一起销毁
```

**🔧 close时机控制**
```java
// 常见的SqlSession使用模式

// 模式1：手动管理（finally确保关闭）
public void manualManagement() {
    SqlSession session = sqlSessionFactory.openSession();
    try {
        // 执行数据库操作
        User user = session.selectOne("UserMapper.selectById", 1);
    } finally {
        session.close();  // 缓存在这里被清除
    }
}

// 模式2：try-with-resources（自动关闭）
public void autoManagement() {
    try (SqlSession session = sqlSessionFactory.openSession()) {
        // 执行数据库操作
        User user = session.selectOne("UserMapper.selectById", 1);
    }  // 代码块结束，自动调用close()
}

// 模式3：Spring集成（容器管理）
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    @Transactional
    public void springManaged() {
        // Spring自动管理SqlSession
        // 方法结束时自动关闭SqlSession
        User user = userMapper.selectById(1);
    }
}
```

### 5.4 update/insert/delete清除缓存

**✏️ 数据变更操作的缓存清除**

```
为什么修改操作要清除缓存？

核心原因：
数据已经改变，缓存中的数据过期了

清除时机：
- insert：新增数据，可能影响列表查询
- update：修改数据，缓存中的数据不准确了
- delete：删除数据，缓存中还有被删除的数据

安全策略：
一旦有写操作，就清空所有缓存
宁可多查几次数据库，也不能用错误数据
```

**💡 写操作清除缓存示例**
```java
public void demonstrateWriteOperationCache() {
    SqlSession session = sqlSessionFactory.openSession();
    
    try {
        // 1. 第一次查询（查数据库 → 缓存）
        User user1 = session.selectOne("UserMapper.selectById", 1);
        System.out.println("第一次查询：" + user1.getName());
        
        // 2. 第二次查询（从缓存读取）
        User user2 = session.selectOne("UserMapper.selectById", 1);
        System.out.println("第二次查询：" + user2.getName());
        System.out.println("是同一对象：" + (user1 == user2));  // true
        
        // 3. 执行更新操作（清除所有缓存）
        user1.setName("新名字");
        session.update("UserMapper.updateById", user1);
        // ↑ 这里会清空缓存
        
        // 4. 再次查询（缓存已空，重新查数据库）
        User user3 = session.selectOne("UserMapper.selectById", 1);
        System.out.println("更新后查询：" + user3.getName());
        System.out.println("是同一对象：" + (user1 == user3));  // false
        
        session.commit();
    } finally {
        session.close();
    }
}
```

---

## 6. 🎯 缓存命中策略


### 6.1 什么情况下命中缓存

**✅ 缓存命中的条件**

```
必须同时满足所有条件：

1. 同一个SqlSession
   ✓ 同一个会话内
   ✗ 不同SqlSession

2. 相同的SQL语句ID
   ✓ UserMapper.selectById
   ✗ UserMapper.selectByName

3. 相同的参数值
   ✓ selectById(1) 和 selectById(1)
   ✗ selectById(1) 和 selectById(2)

4. 相同的分页参数
   ✓ RowBounds(0, 10) 和 RowBounds(0, 10)
   ✗ RowBounds(0, 10) 和 RowBounds(10, 10)

5. 没有执行过更新操作
   ✓ 只有查询操作
   ✗ 执行过insert/update/delete
```

**📊 命中与不命中对比**

| 场景 | **是否命中** | **原因** |
|------|-------------|---------|
| 🔸 **连续查询相同ID用户** | `✅ 命中` | `所有条件都满足` |
| 🔸 **查询不同ID用户** | `❌ 不命中` | `参数值不同` |
| 🔸 **不同Mapper的查询** | `❌ 不命中` | `SQL ID不同` |
| 🔸 **查询后执行了更新** | `❌ 不命中` | `缓存已清空` |
| 🔸 **不同SqlSession查询** | `❌ 不命中` | `缓存隔离` |

### 6.2 CacheKey的判断逻辑

**🔑 MyBatis如何判断两次查询是否相同**

```
CacheKey的组成部分：

CacheKey对象包含：
1. MappedStatement的ID
   例：com.example.UserMapper.selectById

2. 分页参数
   RowBounds的offset和limit

3. SQL语句本身
   SELECT * FROM user WHERE id = ?

4. 参数值
   具体的参数值，如：1, "张三"

5. Environment的ID
   配置环境标识
```

**🔍 CacheKey生成示例**
```java
// MyBatis内部的CacheKey生成过程（简化版）
public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, 
                                RowBounds rowBounds) {
    CacheKey cacheKey = new CacheKey();
    
    // 1. 加入MappedStatement的ID
    cacheKey.update(ms.getId());
    // 示例：com.example.UserMapper.selectById
    
    // 2. 加入分页信息
    cacheKey.update(rowBounds.getOffset());
    cacheKey.update(rowBounds.getLimit());
    // 示例：0, 10
    
    // 3. 加入SQL语句
    cacheKey.update(ms.getBoundSql(parameterObject).getSql());
    // 示例：SELECT * FROM user WHERE id = ?
    
    // 4. 加入参数值
    cacheKey.update(parameterObject);
    // 示例：1
    
    // 5. 加入环境ID
    cacheKey.update(ms.getConfiguration().getEnvironment().getId());
    
    return cacheKey;
}

// 两个CacheKey相等的条件：所有update的值都相同
```

### 6.3 缓存命中的性能提升

**⚡ 命中缓存能节省多少时间**

```
性能对比（典型场景）：

数据库查询（未命中缓存）：
1. 构建SQL语句：~1ms
2. 数据库网络传输：~2ms
3. 数据库执行查询：~5ms
4. 结果集转换：~2ms
总计：约10ms

缓存命中（从内存读取）：
1. 生成CacheKey：~0.1ms
2. HashMap查找：~0.01ms
3. 返回对象：~0.01ms
总计：约0.12ms

性能提升：10ms vs 0.12ms ≈ 80倍！
```

**📈 实际测试数据**
```
模拟10000次查询的性能对比：

未使用缓存：
- 总耗时：10000 * 10ms = 100秒
- 数据库连接：10000次
- CPU使用率：高

使用一级缓存（90%命中率）：
- 缓存命中：9000次 * 0.12ms = 1.08秒
- 数据库查询：1000次 * 10ms = 10秒
- 总耗时：约11秒
- 性能提升：约9倍

结论：
缓存命中率越高，性能提升越明显
即使50%命中率，也能提升近一倍性能
```

---

## 7. ⚠️ 脏数据问题与解决


### 7.1 什么是脏数据

**🎯 通俗理解脏数据**

```
脏数据 = 过期的、不准确的数据

生活例子：
你查看商品库存 → 显示还有10件
实际上已经被别人买了 → 真实库存只有2件
你看到的"10件"就是脏数据

MyBatis中的脏数据：
缓存中的数据 ≠ 数据库中的实际数据
```

### 7.2 脏数据产生的场景

**🚨 典型的脏数据场景**

```
场景1：多SqlSession并发操作

时间线：
T1: SessionA 查询用户余额（100元）→ 缓存中有数据
T2: SessionB 更新用户余额为200元 → SessionB的缓存清空
T3: SessionA 再次查询用户余额 → 从缓存读取，还是100元（脏数据！）

原因：SessionA的缓存没有感知SessionB的更新
```

**💡 场景演示代码**
```java
// 演示脏数据产生过程
public void demonstrateDirtyData() {
    
    // Session A：查询并缓存数据
    SqlSession sessionA = sqlSessionFactory.openSession();
    User userA = sessionA.selectOne("UserMapper.selectById", 1);
    System.out.println("SessionA查询：余额 = " + userA.getBalance());
    // 输出：余额 = 100元（缓存中有数据）
    
    // Session B：更新数据
    SqlSession sessionB = sqlSessionFactory.openSession();
    User userB = sessionB.selectOne("UserMapper.selectById", 1);
    userB.setBalance(new BigDecimal("200"));
    sessionB.update("UserMapper.updateBalance", userB);
    sessionB.commit();  // SessionB提交，数据库变成200元
    sessionB.close();
    
    // Session A：再次查询
    User userA2 = sessionA.selectOne("UserMapper.selectById", 1);
    System.out.println("SessionA再次查询：余额 = " + userA2.getBalance());
    // 输出：余额 = 100元（从缓存读取，脏数据！）
    
    // 真实数据库中的余额已经是200元了
    
    sessionA.close();
}
```

**📋 其他脏数据场景**
```
场景2：不同的应用实例

应用A → 更新数据库
应用B → 使用旧的缓存数据（脏数据）

场景3：外部直接修改数据库

DBA直接在数据库中修改数据
应用缓存中还是旧数据（脏数据）

场景4：分布式环境

服务器A更新数据
服务器B的缓存不知道（脏数据）
```

### 7.3 脏数据的解决方案

**🛡️ 如何避免脏数据**

```
解决方案总览：

方案1：缩短SqlSession生命周期
- 一个请求一个SqlSession
- 尽快关闭SqlSession
- 适合：Web应用

方案2：关闭一级缓存
- 设置LocalCacheScope为STATEMENT
- 每个SQL执行后清空缓存
- 适合：对一致性要求极高的场景

方案3：手动清除缓存
- 调用session.clearCache()
- 在关键点主动清空
- 适合：复杂业务逻辑

方案4：使用二级缓存
- 跨SqlSession共享
- 配合缓存更新策略
- 适合：读多写少场景
```

**🔧 解决方案实现**
```java
// 方案1：缩短生命周期（推荐）
@Service
public class UserService {
    
    @Transactional
    public void updateUser(User user) {
        // Spring管理的SqlSession
        // 方法执行完自动关闭
        userMapper.updateById(user);
    }  // SqlSession在这里关闭，缓存清空
}

// 方案2：关闭一级缓存（mybatis-config.xml）
<settings>
    <setting name="localCacheScope" value="STATEMENT"/>
    <!-- STATEMENT：每个SQL执行后清空缓存 -->
    <!-- SESSION：默认值，SqlSession级别缓存 -->
</settings>

// 方案3：手动清除缓存
public void businessLogic() {
    SqlSession session = sqlSessionFactory.openSession();
    
    try {
        // 查询数据
        User user = session.selectOne("UserMapper.selectById", 1);
        
        // 执行业务逻辑
        doSomething(user);
        
        // 关键点：手动清除缓存
        session.clearCache();
        
        // 重新查询获取最新数据
        User latestUser = session.selectOne("UserMapper.selectById", 1);
        
        session.commit();
    } finally {
        session.close();
    }
}

// 方案4：使用乐观锁（数据库层面保证）
// User实体添加version字段
public class User {
    private Integer id;
    private String name;
    private Integer version;  // 版本号
}

// Mapper中的更新语句
<update id="updateById" parameterType="User">
    UPDATE user 
    SET name = #{name}, 
        version = version + 1
    WHERE id = #{id} 
      AND version = #{version}
</update>

// 如果version不匹配，更新失败，避免脏数据问题
```

---

## 8. 💥 缓存失效场景


### 8.1 主动失效场景

**🔸 什么操作会让缓存失效**

```
会导致缓存失效的操作：

1. 执行insert操作
   原因：新增数据，列表查询结果会变化

2. 执行update操作
   原因：修改数据，缓存中的数据过期

3. 执行delete操作
   原因：删除数据，缓存中可能还有被删除的数据

4. 调用commit()
   原因：事务提交，确保数据一致性

5. 调用rollback()
   原因：事务回滚，缓存数据无效

6. 调用clearCache()
   原因：手动清除缓存

7. 调用close()
   原因：SqlSession关闭，资源释放
```

**📋 失效场景对照表**

| 操作 | **是否失效** | **失效范围** | **原因** |
|------|-------------|-------------|---------|
| 🔸 **SELECT查询** | `❌ 不失效` | `-` | `不改变数据` |
| 🔸 **INSERT插入** | `✅ 失效` | `全部缓存` | `数据变化` |
| 🔸 **UPDATE更新** | `✅ 失效` | `全部缓存` | `数据变化` |
| 🔸 **DELETE删除** | `✅ 失效` | `全部缓存` | `数据变化` |
| 🔸 **commit提交** | `✅ 失效` | `全部缓存` | `确保一致性` |
| 🔸 **rollback回滚** | `✅ 失效` | `全部缓存` | `数据回退` |

### 8.2 被动失效场景

**🔸 什么情况下缓存会"被动"失效**

```
被动失效场景：

1. SqlSession关闭
   - 缓存随对象销毁
   - 无法再使用

2. JVM内存不足
   - 可能触发GC
   - 缓存对象被回收

3. 配置了localCacheScope=STATEMENT
   - 每条SQL执行后清空
   - 等于禁用缓存

4. 使用了ResultHandler
   - 流式处理结果
   - 不会缓存
```

**💡 特殊失效场景示例**
```java
// 场景1：流式查询不走缓存
public void streamQuery() {
    SqlSession session = sqlSessionFactory.openSession();
    
    // 使用ResultHandler处理结果（不会缓存）
    session.select("UserMapper.selectAll", new ResultHandler() {
        @Override
        public void handleResult(ResultContext context) {
            User user = (User) context.getResultObject();
            System.out.println(user);
            // 每条记录单独处理，不会放入缓存
        }
    });
    
    session.close();
}

// 场景2：localCacheScope=STATEMENT配置
// mybatis-config.xml
<settings>
    <setting name="localCacheScope" value="STATEMENT"/>
</settings>

public void statementLevelCache() {
    SqlSession session = sqlSessionFactory.openSession();
    
    // 每条SQL执行后立即清空缓存
    User user1 = session.selectOne("UserMapper.selectById", 1);
    // SQL执行完，缓存清空
    
    User user2 = session.selectOne("UserMapper.selectById", 1);
    // 缓存已空，重新查询数据库
    
    System.out.println(user1 == user2);  // false，不是同一对象
    
    session.close();
}
```

### 8.3 缓存失效的影响

**📊 失效对性能的影响**

```
影响分析：

正面影响：
✅ 保证数据一致性
✅ 避免脏数据问题
✅ 适应数据变化

负面影响：
❌ 缓存命中率下降
❌ 数据库压力增加
❌ 响应时间变长

权衡策略：
在一致性和性能之间找平衡
根据业务特点选择合适的策略
```

**🎯 优化建议**
```
优化方向：

1. 减少不必要的更新操作
   - 只在真正需要时才更新
   - 批量操作减少清空次数

2. 合理安排SQL执行顺序
   - 先查询再更新
   - 避免频繁清空缓存

3. 使用二级缓存补充
   - 跨SqlSession共享
   - 提高整体命中率

4. 业务层面优化
   - 减少重复查询
   - 数据本地化缓存
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 一级缓存本质：SqlSession内部的临时存储，自动开启
🔸 缓存作用域：SqlSession级别，线程隔离，天然安全
🔸 缓存实现：PerpetualCache，底层用HashMap存储
🔸 缓存生命周期：随SqlSession创建而生，关闭而亡
🔸 清除时机：commit、rollback、close、写操作都会清空
🔸 命中条件：SQL相同、参数相同、SqlSession相同
🔸 脏数据风险：多SqlSession场景下可能出现数据不一致
🔸 失效场景：任何写操作都会导致缓存完全清空
```

### 9.2 关键理解要点


**🔹 一级缓存的设计思想**
```
核心理念：
- 单次会话内的优化，不跨会话
- 牺牲跨会话共享，换取线程安全
- 默认开启，无需配置

适用场景：
- 单次请求内的重复查询
- 事务内的数据一致性保证
- 简单的性能优化

不适用场景：
- 长时间运行的会话
- 多个会话需要共享数据
- 对一致性要求极高的场景
```

**🔹 缓存清除的安全策略**
```
MyBatis的保守策略：
宁可多查数据库，不能用错数据

清除规则：
- 任何写操作 → 全部清空
- 不做精确的局部清除
- 避免复杂的依赖分析

优点：
- 实现简单
- 保证一致性
- 避免脏数据

缺点：
- 缓存命中率可能不高
- 部分场景性能损失
```

**🔹 与二级缓存的关系**
```
一级缓存 vs 二级缓存：

一级缓存（Local Cache）：
- 作用范围：单个SqlSession
- 生命周期：短暂
- 线程安全：天然隔离
- 默认状态：自动开启

二级缓存（Second Level Cache）：
- 作用范围：整个Mapper
- 生命周期：应用运行期
- 线程安全：需要序列化
- 默认状态：需要配置

配合使用：
先查一级缓存 → 未命中 → 查二级缓存 → 未命中 → 查数据库
```

### 9.3 实际应用价值


**🎯 生产环境应用建议**
- **Web应用**：一个请求一个SqlSession，自然利用一级缓存
- **批处理任务**：关闭一级缓存避免内存溢出
- **事务处理**：利用一级缓存保证事务内数据一致性
- **分布式系统**：配合二级缓存或外部缓存使用

**🔧 常见问题解决**
- **脏数据问题**：缩短SqlSession生命周期，及时关闭
- **内存占用**：大批量操作时定期调用clearCache()
- **性能优化**：合理安排查询顺序，提高命中率
- **一致性要求**：考虑关闭一级缓存或使用STATEMENT级别

**📈 性能优化要点**
- **提高命中率**：相同查询尽量在同一SqlSession中
- **减少清空次数**：批量操作，减少单次更新
- **合理配置**：根据业务特点选择缓存级别
- **监控优化**：关注缓存命中率，持续调优

**核心记忆口诀**：
- 一级缓存SqlSession内，自动开启默认在
- 查询结果暂存HashMap，相同条件直接拿
- 写操作一律全清空，保证数据不会脏
- 会话一关缓存亡，多会话间不共享