---
title: 24、插件基础原理
---
## 📚 目录

1. [插件机制概述](#1-插件机制概述)
2. [插件基础原理](#2-插件基础原理)
3. [四大拦截对象详解](#3-四大拦截对象详解)
4. [插件开发实战](#4-插件开发实战)
5. [插件执行机制](#5-插件执行机制)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 插件机制概述


### 1.1 什么是MyBatis插件


**🔸 通俗理解**
```
想象一下：
你去餐厅吃饭，服务员端菜给你之前，可以：
• 加点调料（数据加工）
• 记录菜品信息（日志记录）
• 检查菜品质量（权限校验）

MyBatis插件就像这个"服务员"：
在SQL执行的关键环节，插入你的自定义逻辑
不改变原有功能，只是增强它！
```

**💡 插件能做什么**
```
实际应用场景：
📊 性能监控：记录每条SQL的执行时间
🔐 权限控制：拦截敏感数据访问
📝 SQL日志：自动打印格式化的SQL
🔄 分页处理：自动添加分页逻辑
🛡️ 数据脱敏：敏感信息自动加密
```

### 1.2 插件的核心价值


**🎯 为什么需要插件机制**

| 需求场景 | 传统方案 | 插件方案 | 优势对比 |
|---------|---------|---------|---------|
| **SQL日志** | 手动在每个方法打日志 | 统一拦截自动记录 | ⬇️ 减少90%重复代码 |
| **性能监控** | 修改业务代码埋点 | 插件透明监控 | ✅ 业务代码零侵入 |
| **权限校验** | 每个DAO层写判断 | 拦截器统一处理 | 🎯 集中管理更安全 |
| **分页功能** | 手写分页SQL | 插件自动改写 | ⚡ 性能优化更灵活 |

**📈 插件机制的优势**
```
✅ 无侵入性：不修改原有代码
✅ 高复用性：一次编写，处处使用
✅ 易维护性：集中管理，统一升级
✅ 灵活扩展：支持多插件组合
```

---

## 2. ⚙️ 插件基础原理


### 2.1 Interceptor拦截器接口


**🔸 核心接口定义**
```
Interceptor是插件的"灵魂"，就像：
🎭 演员的剧本 → 定义你要做什么
🎬 导演的安排 → 决定什么时候做
🎪 舞台的位置 → 明确在哪里做
```

```java
// MyBatis插件必须实现这个接口
public interface Interceptor {
    // 核心方法：拦截到方法后要执行的逻辑
    Object intercept(Invocation invocation) throws Throwable;
    
    // 包装目标对象，生成代理对象
    Object plugin(Object target);
    
    // 设置插件的配置参数
    void setProperties(Properties properties);
}
```

**💡 三个方法的作用**
```
intercept()：
• 作用：真正执行拦截逻辑的地方
• 类比：门卫检查来访者的工作内容
• 示例：记录SQL执行时间、修改参数等

plugin()：
• 作用：决定是否要拦截这个对象
• 类比：门卫判断是否要检查这个人
• 示例：只拦截Executor，不拦截其他对象

setProperties()：
• 作用：接收配置文件中的参数
• 类比：门卫接收上级的工作指示
• 示例：设置日志级别、超时时间等
```

### 2.2 @Intercepts和@Signature注解


**🔸 @Intercepts注解**
```
作用：告诉MyBatis"我要拦截什么"
位置：写在插件类上
包含：一个或多个@Signature注解
```

**🔸 @Signature注解**
```
作用：精确指定要拦截的方法
必填三要素：
• type：要拦截的接口类型
• method：要拦截的方法名
• args：方法的参数类型列表
```

**📝 注解使用示例**
```java
// 拦截Executor的query方法
@Intercepts({
    @Signature(
        type = Executor.class,              // 拦截Executor接口
        method = "query",                    // 拦截query方法
        args = {MappedStatement.class,      // 第1个参数类型
                Object.class,                // 第2个参数类型
                RowBounds.class,            // 第3个参数类型
                ResultHandler.class}         // 第4个参数类型
    )
})
public class MyPlugin implements Interceptor {
    // 插件实现代码
}
```

**🎯 理解签名匹配**
```
为什么需要精确的签名？

类比说明：
你要拦截"张三去银行取钱"这个动作
• type = 张三      → 必须是这个人
• method = 取钱    → 必须是这个动作
• args = [银行卡]  → 必须带着银行卡

只有三个条件都满足，才会触发拦截！
如果张三去银行存钱，不会被拦截
如果李四去银行取钱，也不会被拦截
```

### 2.3 插件注册机制


**🔸 插件是如何生效的**
```
注册流程：
1️⃣ 配置文件中声明插件
   ↓
2️⃣ MyBatis启动时扫描插件配置
   ↓
3️⃣ 创建插件实例并调用setProperties()
   ↓
4️⃣ 将插件添加到拦截器链中
   ↓
5️⃣ 执行SQL时依次调用插件
```

**📝 XML配置方式**
```xml
<plugins>
    <!-- 插件1：SQL性能监控 -->
    <plugin interceptor="com.example.PerformanceInterceptor">
        <property name="threshold" value="1000"/>
    </plugin>
    
    <!-- 插件2：SQL日志打印 -->
    <plugin interceptor="com.example.SqlLogInterceptor">
        <property name="level" value="DEBUG"/>
    </plugin>
</plugins>
```

**💡 配置说明**
```
<plugin interceptor="...">：
• interceptor：插件的全限定类名
• 必须实现Interceptor接口

<property name="..." value="...">：
• 传递给插件的配置参数
• 在setProperties()方法中接收
• 可以有多个property
```

### 2.4 Plugin工具类


**🔸 Plugin类的作用**
```
Plugin是MyBatis提供的工具类，用于：
• 创建代理对象（核心功能）
• 简化plugin()方法的实现
• 判断是否需要拦截目标对象
```

**📝 Plugin工具类使用**
```java
public class MyPlugin implements Interceptor {
    
    @Override
    public Object plugin(Object target) {
        // 使用Plugin工具类创建代理
        // 它会自动判断是否需要拦截target
        return Plugin.wrap(target, this);
    }
}
```

**💡 工作原理**
```
Plugin.wrap()做了什么：

步骤1：检查target的类型
• 判断是不是要拦截的四大对象之一

步骤2：匹配@Signature
• 检查target的方法是否匹配签名

步骤3：决定是否代理
• 匹配成功 → 返回代理对象
• 不匹配   → 直接返回原对象

结果：
被拦截的对象 → 代理对象（会调用intercept）
不被拦截的对象 → 原对象（不会调用intercept）
```

---

## 3. 🎭 四大拦截对象详解


### 3.1 四大拦截对象概述


**🔸 MyBatis的四大拦截点**
```
SQL执行链路：
用户调用 → Executor → StatementHandler → ParameterHandler
                ↓              ↓                ↓
            执行SQL        设置SQL           设置参数
                                              ↓
                                         ResultSetHandler
                                              ↓
                                          处理结果集
```

**📊 四大对象对比**

| 拦截对象 | 作用阶段 | 典型用途 | 拦截时机 |
|---------|---------|---------|---------|
| **Executor** | SQL执行调度 | 缓存控制、分页处理 | ⭐⭐⭐ 最早 |
| **StatementHandler** | SQL执行准备 | SQL重写、日志记录 | ⭐⭐ 较早 |
| **ParameterHandler** | 参数设置 | 参数加密、类型转换 | ⭐ 执行前 |
| **ResultSetHandler** | 结果处理 | 数据脱敏、类型映射 | 最后 |

### 3.2 Executor拦截点


**🔸 Executor是什么**
```
Executor = 执行器，SQL执行的"总指挥"

职责：
• 管理一级缓存和二级缓存
• 决定何时执行SQL
• 控制事务的提交和回滚
• 批量操作的管理
```

**💡 可拦截的方法**
```java
// 1. 查询方法
query(MappedStatement ms, Object parameter, 
      RowBounds rowBounds, ResultHandler resultHandler)

// 2. 更新方法（包括insert、update、delete）
update(MappedStatement ms, Object parameter)

// 3. 事务提交
commit(boolean required)

// 4. 事务回滚
rollback(boolean required)
```

**🎯 典型应用场景**
```
✅ 分页拦截：
在query()之前，自动改写SQL添加LIMIT

✅ 性能监控：
记录SQL执行开始和结束时间

✅ 缓存控制：
根据业务规则清空缓存

✅ 多数据源路由：
根据参数选择不同的数据库
```

### 3.3 StatementHandler拦截点


**🔸 StatementHandler是什么**
```
StatementHandler = SQL处理器，负责"准备SQL"

职责：
• 创建JDBC的Statement对象
• 设置SQL语句到Statement
• 设置SQL执行的超时时间
• 设置fetchSize等参数
```

**💡 可拦截的方法**
```java
// 1. 准备Statement对象
prepare(Connection connection, Integer transactionTimeout)

// 2. 设置参数
parameterize(Statement statement)

// 3. 执行查询
query(Statement statement, ResultHandler resultHandler)

// 4. 执行更新
update(Statement statement)
```

**🎯 典型应用场景**
```
✅ SQL日志打印：
在prepare()时记录完整SQL

✅ SQL改写：
动态添加WHERE条件、ORDER BY等

✅ 慢SQL告警：
设置超时时间并监控

✅ SQL审计：
记录所有执行的SQL语句
```

### 3.4 ParameterHandler拦截点


**🔸 ParameterHandler是什么**
```
ParameterHandler = 参数处理器，负责"设置参数"

职责：
• 将Java对象转换为JDBC参数
• 设置参数到PreparedStatement
• 处理参数的类型映射
```

**💡 可拦截的方法**
```java
// 获取参数对象
getParameterObject()

// 设置参数到PreparedStatement
setParameters(PreparedStatement ps)
```

**🎯 典型应用场景**
```
✅ 参数加密：
敏感参数（如密码）自动加密

✅ 参数校验：
参数合法性检查

✅ 参数转换：
特殊类型的参数处理

✅ 参数日志：
记录SQL参数值
```

### 3.5 ResultSetHandler拦截点


**🔸 ResultSetHandler是什么**
```
ResultSetHandler = 结果集处理器，负责"处理返回值"

职责：
• 将JDBC的ResultSet转换为Java对象
• 处理结果集的映射关系
• 处理多结果集的情况
```

**💡 可拦截的方法**
```java
// 处理结果集
handleResultSets(Statement stmt)

// 处理存储过程的输出参数
handleOutputParameters(CallableStatement cs)
```

**🎯 典型应用场景**
```
✅ 数据脱敏：
身份证、手机号自动脱敏显示

✅ 数据解密：
加密字段自动解密

✅ 结果增强：
自动添加额外信息

✅ 类型转换：
特殊类型的结果处理
```

---

## 4. 💻 插件开发实战


### 4.1 SQL性能监控插件


**🎯 需求说明**
```
目标：监控每条SQL的执行时间
功能：
• 记录SQL执行开始时间
• 记录SQL执行结束时间
• 计算执行耗时
• 超过阈值时发出警告
```

**📝 完整实现**
```java
@Intercepts({
    @Signature(
        type = Executor.class,
        method = "query",
        args = {MappedStatement.class, Object.class, 
                RowBounds.class, ResultHandler.class}
    )
})
public class PerformanceInterceptor implements Interceptor {
    
    private long threshold = 1000; // 默认阈值1秒
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long start = System.currentTimeMillis();
        
        // 执行原方法
        Object result = invocation.proceed();
        
        long end = System.currentTimeMillis();
        long cost = end - start;
        
        // 超过阈值则警告
        if (cost > threshold) {
            MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
            System.err.println("⚠️ 慢SQL警告:");
            System.err.println("SQL ID: " + ms.getId());
            System.err.println("耗时: " + cost + "ms");
        }
        
        return result;
    }
    
    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
    
    @Override
    public void setProperties(Properties properties) {
        // 从配置文件读取阈值
        String thresholdStr = properties.getProperty("threshold");
        if (thresholdStr != null) {
            this.threshold = Long.parseLong(thresholdStr);
        }
    }
}
```

**💡 代码讲解**
```
关键点1：拦截Executor.query()
• 这是查询的入口，可以监控所有查询

关键点2：Invocation.proceed()
• 调用原方法，让SQL正常执行
• 在前后记录时间差

关键点3：获取SQL信息
• MappedStatement包含SQL的所有信息
• getId()可以获取mapper方法名

关键点4：配置阈值
• 通过setProperties()读取配置
• 灵活调整警告阈值
```

### 4.2 SQL日志打印插件


**🎯 需求说明**
```
目标：自动打印格式化的SQL日志
功能：
• 打印完整的SQL语句
• 打印SQL参数值
• 格式化输出，易于阅读
```

**📝 完整实现**
```java
@Intercepts({
    @Signature(
        type = StatementHandler.class,
        method = "prepare",
        args = {Connection.class, Integer.class}
    )
})
public class SqlLogInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 获取StatementHandler
        StatementHandler handler = (StatementHandler) invocation.getTarget();
        
        // 获取SQL语句
        BoundSql boundSql = handler.getBoundSql();
        String sql = boundSql.getSql();
        
        // 获取参数
        Object params = boundSql.getParameterObject();
        
        // 打印日志
        System.out.println("🔍 执行SQL:");
        System.out.println("   " + formatSql(sql));
        System.out.println("📝 参数值:");
        System.out.println("   " + params);
        
        // 执行原方法
        return invocation.proceed();
    }
    
    // 格式化SQL（去除多余空格和换行）
    private String formatSql(String sql) {
        return sql.replaceAll("\\s+", " ").trim();
    }
    
    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
    
    @Override
    public void setProperties(Properties properties) {
        // 可以配置日志级别等
    }
}
```

**💡 代码讲解**
```
关键点1：拦截StatementHandler.prepare()
• 这个时机SQL已经准备好
• 参数也已经设置完成

关键点2：获取SQL和参数
• BoundSql对象包含SQL和参数
• getParameterObject()获取参数值

关键点3：格式化输出
• 去除SQL中的多余空格
• 让日志更易读
```

### 4.3 分页插件原理


**🎯 分页插件的工作原理**
```
目标：自动为查询SQL添加分页功能

工作流程：
1️⃣ 拦截Executor.query()方法
   ↓
2️⃣ 判断是否需要分页（检查参数）
   ↓
3️⃣ 查询总记录数（执行COUNT查询）
   ↓
4️⃣ 改写原SQL（添加LIMIT语句）
   ↓
5️⃣ 执行改写后的SQL
   ↓
6️⃣ 封装分页结果返回
```

**📝 核心代码示例**
```java
@Intercepts({
    @Signature(type = Executor.class, method = "query",
               args = {MappedStatement.class, Object.class, 
                       RowBounds.class, ResultHandler.class})
})
public class PageInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Object[] args = invocation.getArgs();
        MappedStatement ms = (MappedStatement) args[0];
        Object parameter = args[1];
        RowBounds rowBounds = (RowBounds) args[2];
        
        // 判断是否需要分页
        if (rowBounds != RowBounds.DEFAULT) {
            // 获取原始SQL
            BoundSql boundSql = ms.getBoundSql(parameter);
            String originalSql = boundSql.getSql();
            
            // 改写SQL添加分页
            String pageSql = originalSql + 
                " LIMIT " + rowBounds.getOffset() + 
                ", " + rowBounds.getLimit();
            
            // 创建新的BoundSql
            BoundSql newBoundSql = new BoundSql(
                ms.getConfiguration(), pageSql,
                boundSql.getParameterMappings(),
                parameter
            );
            
            // 执行改写后的SQL（简化代码）
            // ... 实际需要创建新的MappedStatement
        }
        
        return invocation.proceed();
    }
}
```

**💡 分页插件关键点**
```
✅ 拦截时机：Executor.query()
• 这是最早的拦截点
• 可以控制整个查询流程

✅ SQL改写：
• 获取原始SQL
• 根据数据库类型添加分页语法
• MySQL用LIMIT，Oracle用ROWNUM

✅ COUNT查询：
• 先执行COUNT(*)获取总数
• 再执行分页查询获取数据

✅ 性能优化：
• 缓存COUNT结果
• 避免重复查询总数
```

---

## 5. 🔄 插件执行机制


### 5.1 责任链模式


**🔸 什么是责任链模式**
```
责任链模式 = 一个接一个传递处理

生活类比：
公司审批流程：
员工申请 → 组长审批 → 经理审批 → 总监审批

每一级都可以：
• 处理请求（修改、记录）
• 决定是否继续传递
• 直接拒绝请求
```

**💡 MyBatis插件的责任链**
```
插件执行流程：
原始对象 → 插件1代理 → 插件2代理 → 插件3代理
            ↓           ↓           ↓
          拦截处理    拦截处理    拦截处理
            ↓           ↓           ↓
          继续传递    继续传递    执行原方法
```

**📊 执行顺序示意**
```
配置顺序：Plugin1 → Plugin2 → Plugin3

代理包装：
原对象 → Plugin1包装 → Plugin2包装 → Plugin3包装

执行顺序：
Plugin3.intercept() 
  → Plugin2.intercept() 
    → Plugin1.intercept() 
      → 原方法执行

结果：后配置的先执行！
```

### 5.2 插件链执行顺序


**🔸 为什么后配置先执行**
```
原理解释：

配置：
<plugins>
    <plugin interceptor="Plugin1"/>
    <plugin interceptor="Plugin2"/>
</plugins>

包装过程：
原对象 obj
  ↓
obj1 = Plugin1.wrap(obj)    // obj被Plugin1包装
  ↓  
obj2 = Plugin2.wrap(obj1)   // obj1又被Plugin2包装

最终：obj2(Plugin2) → obj1(Plugin1) → obj

调用：obj2.method()
  → Plugin2拦截
    → obj1.method()
      → Plugin1拦截
        → obj.method()
```

**📝 执行顺序验证**
```java
// 插件A
public class PluginA implements Interceptor {
    public Object intercept(Invocation invocation) {
        System.out.println("A - before");
        Object result = invocation.proceed();
        System.out.println("A - after");
        return result;
    }
}

// 插件B  
public class PluginB implements Interceptor {
    public Object intercept(Invocation invocation) {
        System.out.println("B - before");
        Object result = invocation.proceed();
        System.out.println("B - after");
        return result;
    }
}

// 配置顺序：A → B
// 输出结果：
// B - before  ← B先执行
// A - before  ← A后执行
// [原方法执行]
// A - after   ← A先结束
// B - after   ← B后结束
```

**🎯 执行顺序规律**
```
配置顺序：1 → 2 → 3
执行顺序：3 → 2 → 1 → 原方法 → 1 → 2 → 3

记忆方法：
就像穿衣服：
• 先穿内衣，再穿外套
• 脱衣服时，先脱外套，再脱内衣

插件也一样：
• 后配置的像外套，先拦截
• 先配置的像内衣，后拦截
```

### 5.3 插件的生命周期


**🔸 插件从创建到销毁**
```
生命周期阶段：

1️⃣ 创建阶段（启动时）
• MyBatis解析配置文件
• 创建插件实例
• 调用setProperties()设置属性
• 注册到拦截器链

2️⃣ 使用阶段（运行时）
• SQL执行时触发拦截
• 按责任链顺序执行intercept()
• 插件处理完传递给下一个

3️⃣ 销毁阶段（关闭时）
• SqlSessionFactory关闭
• 插件实例随之销毁
• 资源自动释放
```

**💡 注意事项**
```
⚠️ 线程安全：
• 插件实例是单例的
• 多个线程共享同一个插件
• 不要在插件中使用实例变量存储请求数据

✅ 正确做法：
• 使用方法局部变量
• 从Invocation中获取数据
• 避免共享状态

❌ 错误示例：
public class BadPlugin implements Interceptor {
    private long startTime; // 多线程会互相覆盖！
}

✅ 正确示例：
public class GoodPlugin implements Interceptor {
    public Object intercept(Invocation inv) {
        long startTime = System.currentTimeMillis(); // 安全
    }
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 插件三要素**
```
1️⃣ Interceptor接口：
• intercept()：拦截逻辑
• plugin()：生成代理
• setProperties()：接收配置

2️⃣ @Intercepts和@Signature：
• 声明拦截的对象和方法
• 精确匹配方法签名
• 支持拦截多个方法

3️⃣ Plugin工具类：
• 简化代理创建
• 自动判断是否拦截
• wrap()方法生成代理
```

**🔸 四大拦截对象**
```
📊 执行顺序：
Executor → StatementHandler → ParameterHandler → ResultSetHandler

🎯 选择原则：
• 需要控制缓存/事务 → Executor
• 需要改写SQL → StatementHandler  
• 需要处理参数 → ParameterHandler
• 需要处理结果 → ResultSetHandler
```

### 6.2 关键理解要点


**🔹 责任链执行顺序**
```
记住规律：
配置顺序：A → B → C
执行顺序：C → B → A → 原方法 → A → B → C

原因：后配置的插件包装在外层
```

**🔹 线程安全问题**
```
✅ 安全的做法：
• 使用局部变量
• ThreadLocal存储
• 从Invocation获取数据

❌ 危险的做法：
• 实例变量存储请求数据
• 静态变量共享状态
```

**🔹 性能考虑**
```
⚠️ 插件会影响性能：
• 每次SQL都会执行拦截
• 代理调用有额外开销
• 避免在插件中做重操作

💡 优化建议：
• 只拦截必要的方法
• 拦截逻辑尽量简单
• 使用缓存减少计算
```

### 6.3 实际应用建议


**🎯 插件开发最佳实践**
```
✅ 单一职责：
• 一个插件只做一件事
• 职责明确，易于维护

✅ 配置灵活：
• 支持开关控制
• 参数可配置
• 适配不同环境

✅ 异常处理：
• 捕获并处理异常
• 不影响正常SQL执行
• 记录错误日志

✅ 性能优化：
• 避免重复计算
• 使用缓存机制
• 控制日志级别
```

**🔗 学习路径建议**
```
🟢 入门阶段：
• 理解四大拦截对象
• 学会使用@Signature
• 实现简单的日志插件

🟡 进阶阶段：
• 掌握责任链模式
• 理解执行顺序
• 开发性能监控插件

🔴 高级阶段：
• SQL改写技术
• 分页插件原理
• 自定义复杂插件
```

**🧠 记忆口诀**
```
插件拦截有四大，Executor管缓存
Statement准备SQL，Parameter设参数
ResultSet处理果，责任链来传递
后配置的先执行，线程安全要注意
```

---

## 📚 扩展阅读


**🔗 相关知识点**
- MyBatis缓存机制 → 理解Executor的缓存控制
- 动态代理原理 → 深入理解Plugin的实现
- JDBC执行流程 → 了解四大对象的底层

**💡 实战项目推荐**
- PageHelper分页插件 → 学习分页实现
- Druid SQL监控 → 学习性能监控
- MyBatis-Plus → 学习插件扩展

**⚠️ 常见问题**
- Q: 多个插件冲突怎么办？
  A: 调整配置顺序，或合并插件逻辑

- Q: 插件影响性能怎么办？
  A: 优化拦截逻辑，只拦截必要的方法

- Q: 如何调试插件？
  A: 打印Invocation信息，使用断点调试