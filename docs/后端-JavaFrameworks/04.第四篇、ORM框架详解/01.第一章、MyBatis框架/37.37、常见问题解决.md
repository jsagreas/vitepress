---
title: 37、常见问题解决
---
## 📚 目录

1. [配置问题排查](#1-配置问题排查)
2. [映射问题调试](#2-映射问题调试)
3. [SQL执行问题](#3-SQL执行问题)
4. [事务问题处理](#4-事务问题处理)
5. [缓存问题解决](#5-缓存问题解决)
6. [性能问题定位](#6-性能问题定位)
7. [内存泄漏排查](#7-内存泄漏排查)
8. [死锁问题分析](#8-死锁问题分析)
9. [编码问题处理](#9-编码问题处理)
10. [版本兼容问题](#10-版本兼容问题)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔍 配置问题排查


### 1.1 配置文件加载失败


**🔸 问题表现**
```
常见错误信息：
- "Could not find resource mybatis-config.xml"
- "The configuration file is invalid"
- "Error parsing XML configuration"
```

**💡 原因分析**

配置文件找不到，通常有以下几种情况：

**位置不对**：MyBatis默认会在classpath根目录找配置文件。比如在Maven项目中，配置文件应该放在`src/main/resources`目录下，这样编译后会自动到classpath根目录。如果你放在其他地方，程序就找不到了。

**文件名错误**：配置文件名必须和代码中加载的名字完全一致，包括大小写。比如你写的是`mybatis-config.xml`，但实际文件叫`MyBatis-Config.xml`，就会找不到。

**XML格式错误**：配置文件必须是规范的XML格式，标签要正确闭合，属性值要加引号。

**✅ 解决方案**

| 检查项 | 具体操作 | 预期结果 |
|--------|----------|----------|
| **文件位置** | 确认文件在`src/main/resources`下 | IDE能直接找到文件 |
| **加载路径** | 检查代码中的资源路径 | 路径与实际位置匹配 |
| **XML格式** | 使用IDE的XML验证功能 | 无格式错误提示 |

```java
// 正确的配置加载方式
String resource = "mybatis-config.xml";  // 确保这个名字对
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);
```

### 1.2 数据库连接配置错误


**🔸 常见连接问题**

**数据库地址写错**
```
问题示例：
jdbc:mysql://localhost:3306/mydb

常见错误：
- 端口号错误：3306写成了3360
- 数据库名错误：mydb写成了myDB（MySQL区分大小写）
- IP地址错误：localhost写成了127.0.0.1但防火墙有限制
```

**驱动类名不对**
```
MySQL 5：com.mysql.jdbc.Driver
MySQL 8：com.mysql.cj.jdbc.Driver  ← 注意这里多了.cj

如果MySQL版本是8.x，但用了旧的驱动类名，会报ClassNotFoundException
```

**时区问题**（MySQL 8特有）
```
错误信息：
The server time zone value 'XXX' is unrecognized

原因：MySQL 8必须明确指定时区

解决：在URL中添加时区参数
jdbc:mysql://localhost:3306/mydb?serverTimezone=Asia/Shanghai
```

**✅ 完整配置示例**

```xml
<environment id="development">
    <transactionManager type="JDBC"/>
    <dataSource type="POOLED">
        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
        <!-- 注意URL中的参数 -->
        <property name="url" value="jdbc:mysql://localhost:3306/mydb?serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;characterEncoding=utf8"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </dataSource>
</environment>
```

> 💡 **提示**：XML中的`&`符号要写成`&amp;`，这是XML的特殊字符转义规则

### 1.3 Mapper文件未注册


**🔸 问题表现**
```
异常信息：
org.apache.ibatis.binding.BindingException: 
Type interface com.example.mapper.UserMapper is not known to the MapperRegistry
```

**通俗解释**：这个错误就像你去图书馆借书，但这本书根本没登记在图书馆的系统里。MyBatis不知道你的Mapper接口在哪里，因为你没告诉它。

**✅ 三种注册方式**

**方式一：逐个注册**（适合Mapper文件少的情况）
```xml
<mappers>
    <mapper resource="mapper/UserMapper.xml"/>
    <mapper resource="mapper/OrderMapper.xml"/>
</mappers>
```

**方式二：包扫描**（推荐，最方便）
```xml
<mappers>
    <!-- 扫描这个包下的所有Mapper接口 -->
    <mapper package="com.example.mapper"/>
</mappers>
```

**方式三：使用注解**（Mapper接口和XML文件分开时）
```xml
<mappers>
    <mapper class="com.example.mapper.UserMapper"/>
</mappers>
```

> ⚠️ **注意**：使用包扫描时，Mapper接口和XML文件必须**同名同包**

---

## 2. 🎯 映射问题调试


### 2.1 结果映射不生效


**🔸 典型场景**

你从数据库查出了数据，但对象的某些属性总是null，这是新手最常遇到的问题。

**原因分析**

```
数据库字段    →    Java对象属性
user_name           userName

问题：字段名是下划线风格，属性名是驼峰风格，MyBatis默认对不上！

比如：
数据库有字段：user_name, create_time
Java对象属性：userName, createTime

MyBatis会去找：user_name, create_time（完全匹配）
找不到就不赋值，导致属性为null
```

**✅ 解决方案**

**方案一：全局开启驼峰映射**（推荐）
```xml
<settings>
    <!-- 开启后自动转换：user_name → userName -->
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

**方案二：手动映射**（精确控制）
```xml
<resultMap id="userMap" type="User">
    <id property="id" column="id"/>
    <!-- 手动指定对应关系 -->
    <result property="userName" column="user_name"/>
    <result property="createTime" column="create_time"/>
</resultMap>

<select id="findUser" resultMap="userMap">
    SELECT id, user_name, create_time FROM user
</select>
```

**方案三：SQL别名**（临时方案）
```xml
<select id="findUser" resultType="User">
    SELECT 
        id,
        user_name AS userName,    -- 用别名匹配属性名
        create_time AS createTime
    FROM user
</select>
```

### 2.2 参数传递失败


**🔸 单个参数传递**

```xml
<!-- 错误写法 -->
<select id="findById" resultType="User">
    SELECT * FROM user WHERE id = #{userId}  <!-- userId这个名字随便写的 -->
</select>
```

**为什么会错**：当只有一个参数时，MyBatis会用参数的实际名称。你在接口中定义的是`id`，但XML中写的是`userId`，对不上就报错。

**正确写法**：
```java
// 接口定义
User findById(Long id);  // 参数名是id
```

```xml
<!-- XML中也要用id，或者用@Param注解指定名字 -->
<select id="findById" resultType="User">
    SELECT * FROM user WHERE id = #{id}
</select>
```

**🔸 多个参数传递**

```java
// 接口定义
List<User> findByNameAndAge(String name, Integer age);
```

```xml
<!-- 错误：直接用参数名 -->
<select id="findByNameAndAge" resultType="User">
    SELECT * FROM user WHERE name = #{name} AND age = #{age}  <!-- 报错 -->
</select>

<!-- 正确：使用@Param注解 -->
```

```java
// 修改接口
List<User> findByNameAndAge(@Param("name") String name, 
                            @Param("age") Integer age);
```

```xml
<!-- 现在可以用注解指定的名字了 -->
<select id="findByNameAndAge" resultType="User">
    SELECT * FROM user WHERE name = #{name} AND age = #{age}
</select>
```

**📋 参数传递规则总结**

| 参数数量 | 不用注解 | 推荐做法 |
|---------|---------|---------|
| **1个参数** | 可以随便写 | 建议统一用参数名 |
| **2个及以上** | 必须用arg0, arg1... | **必须用@Param注解** |
| **对象参数** | 直接用对象属性名 | 无需注解 |

### 2.3 集合映射问题


**🔸 一对多关联查询**

假设你要查询一个用户和他的所有订单：

```
用户表（user）          订单表（order）
id | name              id | user_id | amount
1  | 张三              1  | 1       | 100
2  | 李四              2  | 1       | 200
                       3  | 2       | 150

期望结果：
User{
    id: 1,
    name: "张三",
    orders: [
        Order{id: 1, amount: 100},
        Order{id: 2, amount: 200}
    ]
}
```

**正确的映射配置**：

```xml
<resultMap id="userWithOrders" type="User">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    
    <!-- collection表示集合属性 -->
    <collection property="orders" ofType="Order">
        <id property="id" column="order_id"/>
        <result property="amount" column="amount"/>
    </collection>
</resultMap>

<select id="findUserWithOrders" resultMap="userWithOrders">
    SELECT 
        u.id,
        u.name,
        o.id AS order_id,    -- 注意别名，避免冲突
        o.amount
    FROM user u
    LEFT JOIN `order` o ON u.id = o.user_id
    WHERE u.id = #{id}
</select>
```

> 💡 **关键点**：多表关联查询时，相同的列名要用别名区分，比如两个表都有id，就要写成`u.id`和`o.id AS order_id`

---

## 3. ⚡ SQL执行问题


### 3.1 SQL注入风险


**🔸 危险示范**

```xml
<!-- 非常危险的写法！ -->
<select id="findByName" resultType="User">
    SELECT * FROM user WHERE name = '${name}'
</select>
```

**为什么危险**：`${}`是直接字符串拼接，用户输入的内容会原样插入SQL中。

```
假设用户输入：' OR '1'='1
最终SQL变成：
SELECT * FROM user WHERE name = '' OR '1'='1'

这会返回所有用户数据！这就是SQL注入攻击
```

**✅ 正确做法**

```xml
<!-- 使用#{}，MyBatis会自动转义特殊字符 -->
<select id="findByName" resultType="User">
    SELECT * FROM user WHERE name = #{name}
</select>
```

**#{} vs ${}的区别**：

```
#{}：预编译，安全
- 实际执行：SELECT * FROM user WHERE name = ?
- MyBatis会用PreparedStatement，自动防止注入

${}：字符串替换，危险
- 直接拼接：SELECT * FROM user WHERE name = '用户输入'
- 用户可以注入恶意SQL代码
```

**什么时候可以用${}**：
- 表名、列名动态时（因为这些不能用?占位符）
- ORDER BY子句中的列名
- **但必须严格校验输入！**

### 3.2 动态SQL标签错误


**🔸 if标签判断失效**

```xml
<!-- 常见错误 -->
<select id="findUser" resultType="User">
    SELECT * FROM user WHERE 1=1
    <if test="name != null">
        AND name = #{name}
    </if>
    <if test="age != null">
        AND age = #{age}
    </if>
</select>
```

**问题场景**：
```java
// 传入空字符串
userMapper.findUser("", null);  

// if test="name != null" 判断通过（空字符串不是null）
// 生成SQL：SELECT * FROM user WHERE 1=1 AND name = ''
// 但你可能期望的是忽略空字符串
```

**✅ 改进写法**

```xml
<select id="findUser" resultType="User">
    SELECT * FROM user
    <where>
        <if test="name != null and name != ''">
            AND name = #{name}
        </if>
        <if test="age != null">
            AND age = #{age}
        </if>
    </where>
</select>
```

**`<where>`标签的作用**：
- 自动去掉第一个AND或OR
- 当所有条件都不成立时，不会生成WHERE关键字
- 让SQL更简洁优雅

### 3.3 批量操作问题


**🔸 批量插入性能差**

```xml
<!-- 性能差的写法 -->
<insert id="batchInsert">
    <foreach collection="list" item="user" separator=";">
        INSERT INTO user (name, age) VALUES (#{user.name}, #{user.age})
    </foreach>
</insert>
```

**问题**：每条记录都是一个独立的INSERT语句，需要多次与数据库交互。

**✅ 优化方案**

```xml
<!-- 一次插入多条记录 -->
<insert id="batchInsert">
    INSERT INTO user (name, age) VALUES
    <foreach collection="list" item="user" separator=",">
        (#{user.name}, #{user.age})
    </foreach>
</insert>
```

**效果对比**：

```
差的方式：
INSERT INTO user (name, age) VALUES ('张三', 20);
INSERT INTO user (name, age) VALUES ('李四', 25);
INSERT INTO user (name, age) VALUES ('王五', 30);
→ 3次数据库交互

好的方式：
INSERT INTO user (name, age) VALUES 
('张三', 20),
('李四', 25),
('王五', 30);
→ 1次数据库交互，性能提升显著
```

---

## 4. 🔄 事务问题处理


### 4.1 事务不生效


**🔸 常见原因**

**自动提交未关闭**
```java
// 错误：没有禁用自动提交
SqlSession session = factory.openSession();  // 默认autoCommit=true
session.insert("insertUser", user);
// 每次操作都自动提交，rollback没用！
```

**正确做法**：
```java
// 明确禁用自动提交
SqlSession session = factory.openSession(false);  // autoCommit=false
try {
    session.insert("insertUser", user);
    session.insert("insertOrder", order);
    session.commit();  // 手动提交
} catch (Exception e) {
    session.rollback();  // 出错回滚
} finally {
    session.close();
}
```

**🔸 多个SqlSession的问题**

```java
// 错误：两个不同的Session
SqlSession session1 = factory.openSession(false);
SqlSession session2 = factory.openSession(false);

session1.insert("insertUser", user);   // Session1的事务
session2.insert("insertOrder", order); // Session2的事务
session1.commit();  // 只提交了Session1

// 问题：两个操作在不同事务中，无法保证一致性！
```

**正确做法**：
```java
// 同一个Session中执行
SqlSession session = factory.openSession(false);
try {
    session.insert("insertUser", user);
    session.insert("insertOrder", order);
    session.commit();  // 一起提交
} catch (Exception e) {
    session.rollback();  // 一起回滚
}
```

### 4.2 事务隔离级别问题


**🔸 脏读、幻读现象**

```
场景说明：

事务A：查询用户余额 → 100元
事务B：给用户充值200元 → 余额变300元（但未提交）
事务A：再次查询余额 → 看到300元（脏读！）
事务B：回滚 → 余额仍是100元
事务A：基于300元进行计算 → 数据错误！
```

**✅ 设置隔离级别**

```xml
<transactionManager type="JDBC">
    <!-- 设置事务隔离级别 -->
    <property name="defaultTransactionIsolationLevel" value="2"/>
</transactionManager>
```

**隔离级别对照表**：

| 级别 | 名称 | 值 | 说明 | 适用场景 |
|-----|------|---|------|---------|
| **READ_UNCOMMITTED** | 读未提交 | 1 | 可能脏读 | 几乎不用 |
| **READ_COMMITTED** | 读已提交 | 2 | 防止脏读 | Oracle默认 |
| **REPEATABLE_READ** | 可重复读 | 4 | 防止脏读和不可重复读 | **MySQL默认，推荐** |
| **SERIALIZABLE** | 串行化 | 8 | 完全隔离但性能差 | 极少使用 |

> 💡 **建议**：大多数情况使用REPEATABLE_READ（级别4）就够了，既保证数据一致性，性能也不错

---

## 5. 🚀 缓存问题解决


### 5.1 一级缓存失效


**🔸 一级缓存工作原理**

```
一级缓存是SqlSession级别的，就像一个临时记事本：

第一次查询：
session.selectOne("findUser", 1);  
→ 去数据库查，结果存到Session的缓存中

第二次相同查询：
session.selectOne("findUser", 1);  
→ 直接从缓存拿，不查数据库了！
```

**什么时候会失效**：

```java
SqlSession session = factory.openSession();

// 第一次查询，进入缓存
User user1 = session.selectOne("findUser", 1);

// 执行了更新操作
session.update("updateUser", user);  // 缓存清空！

// 第二次查询，需要重新从数据库读
User user2 = session.selectOne("findUser", 1);  // 不是从缓存拿的
```

**📋 缓存失效的触发条件**：
- 执行了INSERT、UPDATE、DELETE操作
- 手动调用`session.clearCache()`
- SqlSession关闭

### 5.2 二级缓存导致的数据不一致


**🔸 跨Session的数据更新问题**

```
场景：
Session A：查询用户 → 结果进入二级缓存
Session B：更新该用户 → 提交事务
Session A：再次查询 → 从二级缓存读取（还是旧数据！）

问题：Session B已经修改了数据库，但A读到的还是老数据
```

**✅ 解决方案**

**方案一：合理使用二级缓存**
```xml
<!-- 只在读多写少的场景开启 -->
<cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/>

<!-- 写操作多的Mapper不开启二级缓存 -->
```

**方案二：配置flushCache**
```xml
<update id="updateUser" flushCache="true">
    UPDATE user SET name = #{name} WHERE id = #{id}
</update>
```
这样每次更新都会清空二级缓存，确保数据一致。

**方案三：关键业务不用二级缓存**
```xml
<!-- 需要实时数据的查询，禁用缓存 -->
<select id="findUserBalance" useCache="false" resultType="BigDecimal">
    SELECT balance FROM user WHERE id = #{id}
</select>
```

### 5.3 缓存雪崩问题


**🔸 问题场景**

```
系统启动后：
- 大量请求进来
- 二级缓存是空的
- 所有请求都打到数据库
→ 数据库压力瞬间爆炸！
```

**✅ 预防措施**

**设置合理的缓存时间**：
```xml
<cache 
    eviction="LRU"           <!-- 最少使用算法 -->
    flushInterval="300000"   <!-- 5分钟刷新，别太短 -->
    size="1024"              <!-- 缓存1024个对象 -->
    readOnly="false"/>       <!-- 返回副本，更安全 -->
```

**使用缓存预热**：
```java
// 系统启动时预加载热点数据
@PostConstruct
public void cacheWarmUp() {
    SqlSession session = factory.openSession();
    try {
        // 预查询常用数据，填充缓存
        session.selectList("findHotUsers");
        session.selectList("findHotProducts");
    } finally {
        session.close();
    }
}
```

---

## 6. 📊 性能问题定位


### 6.1 慢SQL诊断


**🔸 开启SQL日志**

```xml
<settings>
    <!-- 打印SQL到控制台 -->
    <setting name="logImpl" value="STDOUT_LOGGING"/>
</settings>
```

**日志输出示例**：
```
==>  Preparing: SELECT * FROM user WHERE age > ? 
==> Parameters: 18(Integer)
<==      Total: 50000        ← 返回了5万条数据，太多了！
<==    Elapsed: 2500ms       ← 花了2.5秒，很慢！
```

**🔸 常见慢SQL原因**

**全表扫描**
```xml
<!-- 没有WHERE条件，查了全表 -->
<select id="findAll" resultType="User">
    SELECT * FROM user  <!-- 如果表有100万数据就炸了 -->
</select>
```

**N+1查询问题**
```xml
<select id="findAllUsers" resultType="User">
    SELECT * FROM user  <!-- 第1次查询，查了100个用户 -->
</select>

<select id="findOrders" resultType="Order">
    SELECT * FROM order WHERE user_id = #{userId}  
    <!-- 上面每个用户都会触发这个查询，又查了100次！ -->
</select>
```

**✅ 优化方案**

**添加分页**：
```xml
<select id="findByPage" resultType="User">
    SELECT * FROM user 
    WHERE age > #{age}
    LIMIT #{offset}, #{pageSize}  <!-- 每次只查20条 -->
</select>
```

**使用JOIN避免N+1**：
```xml
<select id="findUsersWithOrders" resultMap="userOrderMap">
    SELECT u.*, o.* 
    FROM user u
    LEFT JOIN `order` o ON u.id = o.user_id
    <!-- 一次查询搞定，不用循环查了 -->
</select>
```

### 6.2 连接池配置不当


**🔸 连接数不足**

```
现象：
高并发时报错：
java.sql.SQLException: Cannot get a connection, pool error Timeout waiting for idle object
```

**原因分析**：
```
假设配置：
maxActive=10（最多10个连接）

并发请求：
100个用户同时访问
→ 90个请求拿不到连接
→ 等待超时后报错
```

**✅ 优化配置**

```xml
<dataSource type="POOLED">
    <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="123456"/>
    
    <!-- 连接池配置 -->
    <property name="poolMaximumActiveConnections" value="50"/>    <!-- 最大连接数 -->
    <property name="poolMaximumIdleConnections" value="20"/>      <!-- 最大空闲连接 -->
    <property name="poolMaximumCheckoutTime" value="30000"/>      <!-- 最长借用时间30秒 -->
    <property name="poolTimeToWait" value="10000"/>               <!-- 等待超时10秒 -->
</dataSource>
```

**📋 配置建议**：

| 场景 | maxActive | maxIdle | 说明 |
|-----|-----------|---------|------|
| **小型应用** | 20-50 | 5-10 | 用户少，连接少够用 |
| **中型应用** | 50-100 | 10-20 | 并发中等 |
| **大型应用** | 100-300 | 20-50 | 高并发场景 |

> ⚠️ **注意**：连接数也不是越多越好，要考虑数据库服务器的承受能力

---

## 7. 🔥 内存泄漏排查


### 7.1 SqlSession未关闭


**🔸 典型泄漏代码**

```java
// 危险代码！
public List<User> findUsers() {
    SqlSession session = factory.openSession();
    List<User> users = session.selectList("findAll");
    return users;  // session没关闭，内存泄漏！
}

// 每次调用都new一个Session，但都不关闭
// 调用1000次 → 1000个Session对象在内存里 → 内存溢出
```

**✅ 正确做法**

```java
public List<User> findUsers() {
    SqlSession session = null;
    try {
        session = factory.openSession();
        return session.selectList("findAll");
    } finally {
        if (session != null) {
            session.close();  // 无论如何都要关闭
        }
    }
}

// 或者用try-with-resources（推荐）
public List<User> findUsers() {
    try (SqlSession session = factory.openSession()) {
        return session.selectList("findAll");
    }  // 自动关闭，不用担心忘记
}
```

### 7.2 大结果集处理


**🔸 一次查询百万数据**

```java
// 危险：一次查出100万条记录
List<User> users = session.selectList("findAllUsers");
// 100万个User对象全在内存里 → OutOfMemoryError
```

**✅ 使用游标处理**

```java
// 使用Cursor，逐条处理
try (Cursor<User> cursor = session.selectCursor("findAllUsers")) {
    for (User user : cursor) {
        // 处理一条数据
        processUser(user);
        // 处理完这条，内存就释放了，不会堆积
    }
}
```

**对比效果**：
```
普通查询：
- 一次性加载100万对象到内存
- 需要约2GB内存
- 可能内存溢出

游标查询：
- 每次只处理一条记录
- 内存占用稳定在几MB
- 不会内存溢出
```

---

## 8. 🔐 死锁问题分析


### 8.1 数据库死锁


**🔸 死锁场景演示**

```
事务A：
1. 锁定用户ID=1的记录
2. 等待锁定订单ID=100的记录

事务B：
1. 锁定订单ID=100的记录  
2. 等待锁定用户ID=1的记录

结果：A等B，B等A，谁都动不了 → 死锁！
```

**代码示例**：
```java
// 事务A
SqlSession sessionA = factory.openSession(false);
sessionA.update("lockUser", 1);    // 锁住user表的ID=1
sessionA.update("lockOrder", 100); // 想锁order表的ID=100，但被B锁了

// 事务B  
SqlSession sessionB = factory.openSession(false);
sessionB.update("lockOrder", 100); // 锁住order表的ID=100
sessionB.update("lockUser", 1);    // 想锁user表的ID=1，但被A锁了
```

**✅ 预防死锁**

**统一加锁顺序**：
```java
// 规定：所有事务都按 user → order 的顺序加锁
SqlSession session = factory.openSession(false);
try {
    session.update("lockUser", 1);    // 先锁user
    session.update("lockOrder", 100); // 再锁order
    session.commit();
} catch (Exception e) {
    session.rollback();
}
```

**减少锁持有时间**：
```java
// 不要在事务中做耗时操作
SqlSession session = factory.openSession(false);
try {
    User user = session.selectOne("findUser", 1);
    
    // 业务处理放在事务外
    // processUser(user);  ← 这样会长时间持有锁
    
    session.update("updateUser", user);
    session.commit();  // 尽快提交释放锁
} finally {
    session.close();
}
```

### 8.2 死锁检测和恢复


**🔸 开启死锁检测**

```xml
<settings>
    <!-- 查询超时设置 -->
    <setting name="defaultStatementTimeout" value="30"/>
</settings>
```

**捕获死锁异常**：
```java
int retryCount = 0;
while (retryCount < 3) {
    try {
        SqlSession session = factory.openSession(false);
        // 执行业务逻辑
        session.update("updateUser", user);
        session.commit();
        break;  // 成功就退出
        
    } catch (Exception e) {
        if (e.getMessage().contains("Deadlock")) {
            retryCount++;
            Thread.sleep(100);  // 等待一下再重试
        } else {
            throw e;  // 其他异常直接抛出
        }
    }
}
```

---

## 9. 📝 编码问题处理


### 9.1 中文乱码


**🔸 常见乱码场景**

```
数据库存的：张三
查出来显示：???  或者  å¼ ä¸‰
```

**原因分析**：
```
数据从程序到数据库的旅程：

程序（UTF-8）→ JDBC连接（???）→ MySQL（UTF-8）

如果JDBC连接没指定编码，就会出问题！
```

**✅ 完整解决方案**

**1. 数据库表设置UTF-8**
```sql
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  -- 用utf8mb4，支持emoji
```

**2. JDBC连接指定编码**
```xml
<property name="url" 
    value="jdbc:mysql://localhost:3306/mydb?characterEncoding=utf8&amp;useUnicode=true"/>
```

**3. 项目文件编码统一**
```
IDE设置：
- 文件编码：UTF-8
- 项目编码：UTF-8  
- 数据库连接编码：UTF-8

→ 全链路UTF-8，不会乱码
```

### 9.2 特殊字符处理


**🔸 XML特殊字符问题**

```xml
<!-- 错误写法 -->
<select id="findUser" resultType="User">
    SELECT * FROM user WHERE age < 18  <!-- < 符号会报错！ -->
</select>
```

**原因**：`<`在XML中是特殊字符，会被当成标签开始。

**✅ 解决方案**

**方案一：转义字符**
```xml
<select id="findUser" resultType="User">
    SELECT * FROM user WHERE age &lt; 18  <!-- &lt; 表示 < -->
</select>
```

**方案二：CDATA包裹**（推荐）
```xml
<select id="findUser" resultType="User">
    <![CDATA[
        SELECT * FROM user WHERE age < 18 AND score > 60
    ]]>
    <!-- CDATA里的内容不会被XML解析，随便写 -->
</select>
```

**📋 XML特殊字符对照**：

| 字符 | 转义写法 | 说明 |
|-----|---------|------|
| `<` | `&lt;` | 小于号 |
| `>` | `&gt;` | 大于号 |
| `&` | `&amp;` | 与符号 |
| `"` | `&quot;` | 双引号 |
| `'` | `&apos;` | 单引号 |

---

## 10. 🔄 版本兼容问题


### 10.1 MyBatis版本升级问题


**🔸 3.4.x → 3.5.x 升级注意事项**

```
主要变化：

1. 默认Executor改变：
   旧版本：SimpleExecutor
   新版本：ReuseExecutor（复用PreparedStatement）

2. 自动映射行为变化：
   旧版本：宽松映射
   新版本：严格检查列名

3. 缓存机制调整：
   新增更多缓存配置选项
```

**可能遇到的问题**：
```java
// 在MyBatis 3.4中正常的代码
User user = session.selectOne("findUser", id);

// MyBatis 3.5中可能因为严格映射报错：
// org.apache.ibatis.executor.result.ResultMapException: 
// Error attempting to get column 'user_name' from result set
```

**✅ 兼容性配置**

```xml
<settings>
    <!-- 保持旧版本行为 -->
    <setting name="autoMappingBehavior" value="PARTIAL"/>
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

### 10.2 数据库驱动兼容


**🔸 MySQL驱动升级问题**

```
MySQL 5.x驱动：
com.mysql.jdbc.Driver

MySQL 8.x驱动：
com.mysql.cj.jdbc.Driver  ← 包名不同了
```

**常见报错**：
```
旧驱动 + MySQL 8：
The server time zone value 'CST' is unrecognized

新驱动 + MySQL 5：
Loading class 'com.mysql.jdbc.Driver'. This is deprecated.
```

**✅ 版本对应配置**

```xml
<!-- MySQL 5.x 配置 -->
<property name="driver" value="com.mysql.jdbc.Driver"/>
<property name="url" value="jdbc:mysql://localhost:3306/mydb?useSSL=false"/>

<!-- MySQL 8.x 配置 -->  
<property name="driver" value="com.mysql.cj.jdbc.Driver"/>
<property name="url" value="jdbc:mysql://localhost:3306/mydb?serverTimezone=Asia/Shanghai&amp;useSSL=false"/>
```

**📋 驱动版本建议**：

| MySQL版本 | 推荐驱动版本 | 驱动类名 |
|----------|------------|---------|
| **5.5-5.7** | mysql-connector-java:5.1.47 | com.mysql.jdbc.Driver |
| **8.0+** | mysql-connector-java:8.0.28 | com.mysql.cj.jdbc.Driver |

---

## 11. 📋 核心要点总结


### 11.1 问题诊断思路


```
遇到MyBatis问题时的排查顺序：

1️⃣ 检查配置
   → 配置文件是否加载
   → 数据库连接是否正确
   → Mapper是否注册

2️⃣ 检查映射  
   → 参数传递是否正确
   → 结果映射是否匹配
   → SQL语句是否有误

3️⃣ 检查事务
   → 事务是否正确提交
   → 隔离级别是否合适
   → 是否存在死锁

4️⃣ 检查性能
   → SQL执行是否慢
   → 是否有N+1问题
   → 连接池配置是否合理

5️⃣ 检查资源
   → SqlSession是否关闭
   → 是否有内存泄漏
   → 缓存是否正常
```

### 11.2 关键调试技巧


**🔧 开启详细日志**
```xml
<settings>
    <setting name="logImpl" value="STDOUT_LOGGING"/>
</settings>
```

**🔧 使用调试参数**
```java
// 打印实际执行的SQL
Configuration config = session.getConfiguration();
config.setLogImpl(org.apache.ibatis.logging.stdout.StdOutImpl.class);
```

**🔧 异常信息解读**
```
看到异常先看：
1. 异常类型：是配置错误还是SQL错误
2. 异常信息：具体哪里出了问题
3. 堆栈信息：从哪个方法开始出错的
```

### 11.3 最佳实践建议


**📝 配置规范**
- ✅ 所有配置文件用UTF-8编码
- ✅ XML特殊字符用CDATA或转义
- ✅ 数据库连接参数要完整

**📝 编码规范**  
- ✅ 多参数必须用@Param
- ✅ SqlSession用完必须关闭
- ✅ 使用#{}而不是${}（除非必要）

**📝 性能优化**
- ✅ 避免N+1查询
- ✅ 大数据量用分页或游标
- ✅ 合理配置连接池

**📝 安全防护**
- ✅ 防止SQL注入
- ✅ 敏感信息加密存储
- ✅ 事务正确处理

**核心记忆要点**：
- 配置问题先查路径和格式
- 映射问题看参数和结果集
- 性能问题找慢SQL和N+1
- 事务问题确保提交和回滚
- 资源问题记得关闭连接