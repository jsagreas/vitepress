---
title: 31、Spring XML整合
---
## 📚 目录

1. [整合概述与核心思想](#1-整合概述与核心思想)
2. [SqlSessionFactory配置详解](#2-SqlSessionFactory配置详解)
3. [Mapper扫描配置](#3-Mapper扫描配置)
4. [数据源配置方案](#4-数据源配置方案)
5. [事务管理配置](#5-事务管理配置)
6. [声明式事务详解](#6-声明式事务详解)
7. [事务传播行为](#7-事务传播行为)
8. [事务隔离级别](#8-事务隔离级别)
9. [事务回滚规则](#9-事务回滚规则)
10. [多数据源配置](#10-多数据源配置)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔗 整合概述与核心思想


### 1.1 为什么要整合Spring和MyBatis


**💡 生活类比**
```
想象你在餐厅点餐：

不整合的情况：
- 自己去厨房拿食材（手动创建SqlSession）
- 自己洗菜做饭（手动管理资源）
- 自己收拾碗筷（手动关闭连接）
❌ 太累了！容易出错

整合后的情况：
- 只需要告诉服务员想吃什么（注入Mapper）
- 后厨自动准备（Spring自动管理）
- 自动收拾（自动释放资源）
✅ 省心省力！
```

**🎯 整合的核心价值**
```
传统MyBatis代码：
├── 手动创建SqlSessionFactory
├── 手动获取SqlSession
├── 手动执行SQL
├── 手动提交事务
└── 手动关闭资源

整合Spring后：
├── Spring自动创建工厂
├── 自动注入Mapper
├── 自动管理事务
└── 自动释放资源
```

> 📖 **核心理念**  
> Spring负责"管家"工作，MyBatis专注"干活"，各司其职，配合默契

### 1.2 整合架构图


```
应用层
   ↓ 调用
Service层（事务边界）
   ↓ 注入
Mapper接口（代理对象）
   ↓ 执行
MyBatis核心
   ↓ 使用
数据库连接池
   ↓ 访问
数据库

Spring统一管理整个流程 ──→
```

---

## 2. ⚙️ SqlSessionFactory配置详解


### 2.1 核心配置Bean


**SqlSessionFactoryBean**：这是整合的"心脏"

> 💡 **通俗理解**  
> SqlSessionFactoryBean就像一个"工厂建造师"，它帮你把MyBatis工厂建好，不用你自己动手

**基础配置示例**

```xml
<!-- Spring配置文件：applicationContext.xml -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 配置SqlSessionFactory -->
    <bean id="sqlSessionFactory" 
          class="org.mybatis.spring.SqlSessionFactoryBean">
        
        <!-- 1. 指定数据源（必须） -->
        <property name="dataSource" ref="dataSource"/>
        
        <!-- 2. 指定MyBatis配置文件位置（可选） -->
        <property name="configLocation" 
                  value="classpath:mybatis-config.xml"/>
        
        <!-- 3. 指定SQL映射文件位置 -->
        <property name="mapperLocations" 
                  value="classpath:mapper/*.xml"/>
    </bean>
</beans>
```

### 2.2 配置属性详解


| 属性名 | 作用 | 是否必需 | 说明 |
|--------|------|----------|------|
| `dataSource` | 数据源引用 | ✅ 必需 | 告诉MyBatis去哪取数据库连接 |
| `configLocation` | MyBatis配置文件 | ⭐ 可选 | 保留MyBatis原有配置 |
| `mapperLocations` | SQL映射文件 | ✅ 推荐 | 指定XML映射文件位置 |
| `typeAliasesPackage` | 别名包 | ⭐ 可选 | 自动扫描实体类 |
| `plugins` | 插件配置 | ⭐ 可选 | 分页插件等 |

**完整配置示例**

```xml
<bean id="sqlSessionFactory" 
      class="org.mybatis.spring.SqlSessionFactoryBean">
    
    <!-- 数据源 -->
    <property name="dataSource" ref="dataSource"/>
    
    <!-- MyBatis配置文件 -->
    <property name="configLocation" 
              value="classpath:mybatis-config.xml"/>
    
    <!-- 映射文件路径（支持通配符） -->
    <property name="mapperLocations">
        <array>
            <value>classpath:mapper/**/*.xml</value>
        </array>
    </property>
    
    <!-- 类型别名包（实体类） -->
    <property name="typeAliasesPackage" 
              value="com.example.entity"/>
    
    <!-- 插件配置 -->
    <property name="plugins">
        <array>
            <bean class="com.github.pagehelper.PageInterceptor">
                <property name="properties">
                    <value>
                        helperDialect=mysql
                        reasonable=true
                    </value>
                </property>
            </bean>
        </array>
    </property>
</bean>
```

> 🔍 **配置技巧**  
> `mapperLocations`使用`**`可以匹配多级目录，如`mapper/**/*.xml`会扫描mapper下所有子目录的XML文件

---

## 3. 🔍 Mapper扫描配置


### 3.1 MapperScannerConfigurer的作用


> 📖 **通俗理解**  
> MapperScannerConfigurer就像一个"自动招聘系统"，它会扫描你指定的包，把所有Mapper接口都"招进来"，自动创建实现类

**为什么需要它？**

```
不使用扫描器：
UserMapper userMapper = new UserMapperImpl();  ❌ 要手动写实现类
OrderMapper orderMapper = new OrderMapperImpl(); ❌ 每个都要写

使用扫描器：
@Autowired
private UserMapper userMapper;   ✅ 自动注入，直接用
@Autowired  
private OrderMapper orderMapper; ✅ 不用写实现
```

### 3.2 基础配置


```xml
<!-- Mapper接口扫描配置 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    
    <!-- 1. 指定扫描的包路径 -->
    <property name="basePackage" value="com.example.mapper"/>
    
    <!-- 2. 指定使用的SqlSessionFactory（可选） -->
    <property name="sqlSessionFactoryBeanName" 
              value="sqlSessionFactory"/>
</bean>
```

### 3.3 高级配置选项


**多包扫描**

```xml
<!-- 方式1：使用逗号分隔 -->
<property name="basePackage" 
          value="com.example.mapper,com.example.dao"/>

<!-- 方式2：使用分号分隔 -->
<property name="basePackage" 
          value="com.example.mapper;com.example.dao"/>
```

**指定注解过滤**

```xml
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.example"/>
    
    <!-- 只扫描带@Repository注解的接口 -->
    <property name="annotationClass" 
              value="org.springframework.stereotype.Repository"/>
</bean>
```

> ⚠️ **注意事项**  
> 扫描的包路径越具体越好，避免扫描到不相关的接口

---

## 4. 💧 数据源配置方案


### 4.1 常用数据源对比


| 数据源 | 特点 | 适用场景 | 性能 |
|--------|------|----------|------|
| `Druid` | 功能强大，监控完善 | 生产环境首选 | ⭐⭐⭐⭐⭐ |
| `HikariCP` | 速度快，轻量级 | 高并发场景 | ⭐⭐⭐⭐⭐ |
| `C3P0` | 稳定可靠 | 传统项目 | ⭐⭐⭐ |
| `DBCP` | Spring默认 | 小型项目 | ⭐⭐⭐ |

### 4.2 Druid数据源配置（推荐）


**第一步：添加依赖**

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.16</version>
</dependency>
```

**第二步：配置数据源**

```xml
<!-- 加载数据库配置文件 -->
<context:property-placeholder location="classpath:db.properties"/>

<!-- 配置Druid数据源 -->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
      init-method="init" destroy-method="close">
    
    <!-- 基本连接信息 -->
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
    
    <!-- 连接池配置 -->
    <property name="initialSize" value="5"/>        <!-- 初始连接数 -->
    <property name="minIdle" value="5"/>            <!-- 最小空闲连接 -->
    <property name="maxActive" value="20"/>         <!-- 最大活动连接 -->
    <property name="maxWait" value="60000"/>        <!-- 获取连接最大等待时间 -->
    
    <!-- 监控配置 -->
    <property name="filters" value="stat,wall"/>    <!-- 监控统计+防SQL注入 -->
    <property name="timeBetweenEvictionRunsMillis" value="60000"/> <!-- 检测间隔 -->
</bean>
```

**配置文件：db.properties**

```properties
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mydb?useUnicode=true&characterEncoding=utf8
jdbc.username=root
jdbc.password=123456
```

> 💡 **参数说明**  
> - `initialSize`：启动时创建5个连接，快速响应第一批请求  
> - `maxActive`：最多20个连接，防止数据库压力过大  
> - `filters=stat`：开启监控，可以查看SQL执行统计

### 4.3 HikariCP配置（高性能）


```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" 
      destroy-method="close">
    
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="jdbcUrl" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
    
    <!-- 连接池大小 -->
    <property name="minimumIdle" value="5"/>
    <property name="maximumPoolSize" value="20"/>
    
    <!-- 连接超时 -->
    <property name="connectionTimeout" value="30000"/>
    <property name="idleTimeout" value="600000"/>
</bean>
```

---

## 5. 🔐 事务管理配置


### 5.1 事务管理器配置


> 📖 **通俗理解**  
> 事务管理器就像银行的"交易监督员"，确保你的转账要么全成功，要么全失败，不会出现钱转出去了但对方没收到的情况

**基础配置**

```xml
<!-- 配置事务管理器 -->
<bean id="transactionManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

> 🎯 **核心作用**  
> DataSourceTransactionManager负责：
> - 🔸 开启事务（BEGIN）
> - 🔸 提交事务（COMMIT）
> - 🔸 回滚事务（ROLLBACK）
> - 🔸 管理连接的获取和释放

---

## 6. 📢 声明式事务详解


### 6.1 什么是声明式事务


**对比理解**

```
编程式事务（手动挡汽车）：
try {
    开启事务
    执行业务逻辑
    提交事务
} catch(Exception e) {
    回滚事务
}
❌ 代码重复，容易出错

声明式事务（自动挡汽车）：
@Transactional
public void transfer() {
    执行业务逻辑
}
✅ Spring自动管理，简单可靠
```

### 6.2 XML方式配置声明式事务


**完整配置示例**

```xml
<!-- 1. 引入tx命名空间 -->
<beans xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 2. 配置事务通知 -->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <!-- 查询方法：只读，不需要事务 -->
            <tx:method name="get*" read-only="true" propagation="SUPPORTS"/>
            <tx:method name="find*" read-only="true" propagation="SUPPORTS"/>
            <tx:method name="query*" read-only="true" propagation="SUPPORTS"/>
            
            <!-- 修改方法：需要事务 -->
            <tx:method name="save*" propagation="REQUIRED"/>
            <tx:method name="update*" propagation="REQUIRED"/>
            <tx:method name="delete*" propagation="REQUIRED"/>
            <tx:method name="insert*" propagation="REQUIRED"/>
            
            <!-- 其他方法：默认需要事务 -->
            <tx:method name="*" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>

    <!-- 3. 配置AOP切面 -->
    <aop:config>
        <!-- 定义切入点：Service层所有方法 -->
        <aop:pointcut id="servicePointcut" 
                      expression="execution(* com.example.service..*.*(..))"/>
        
        <!-- 关联事务通知和切入点 -->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="servicePointcut"/>
    </aop:config>
</beans>
```

### 6.3 配置详解


**事务方法匹配规则**

```
name="get*"   → 匹配所有get开头的方法（getUser、getUserById等）
name="*"      → 匹配所有方法
name="save*"  → 匹配所有save开头的方法
```

**切入点表达式解析**

```
execution(* com.example.service..*.*(..))
          ↓   ↓                  ↓  ↓  ↓
          |   |                  |  |  └─ 任意参数
          |   |                  |  └─ 任意方法名
          |   |                  └─ 任意类
          |   └─ service包及其子包
          └─ 任意返回值
```

> 💡 **实用技巧**  
> 查询方法设置`read-only="true"`可以提升性能，因为不需要事务管理的开销

---

## 7. 🔄 事务传播行为


### 7.1 什么是事务传播行为


> 📖 **生活类比**  
> 想象你在公司开会（事务A），突然老板让你去另一个会议室处理紧急事情（事务B）：
> - **加入会议**：直接去那个会议室（REQUIRED）
> - **新开会议**：先结束当前会议，再去新会议（REQUIRES_NEW）
> - **不开会**：告诉老板我不去了（NOT_SUPPORTED）

### 7.2 七种传播行为详解


| 传播行为 | 说明 | 使用场景 | 图示 |
|---------|------|----------|------|
| `REQUIRED` | 有事务就加入，没有就新建 | 默认，最常用 | `A(有事务) → B加入A` |
| `SUPPORTS` | 有事务就加入，没有就算了 | 查询方法 | `A(无事务) → B也无事务` |
| `MANDATORY` | 必须有事务，否则报错 | 强制要求事务的方法 | `A(无事务) → B报错❌` |
| `REQUIRES_NEW` | 总是新建事务，挂起当前事务 | 日志记录 | `A(事务) → 暂停A → B(新事务)` |
| `NOT_SUPPORTED` | 不使用事务，挂起当前事务 | 不需要事务的操作 | `A(事务) → 暂停A → B(无事务)` |
| `NEVER` | 不能有事务，有就报错 | 禁止事务的方法 | `A(有事务) → B报错❌` |
| `NESTED` | 嵌套事务 | 部分回滚场景 | `A(事务) → B(嵌套事务)` |

### 7.3 常用场景配置


**场景1：转账业务（REQUIRED）**

```xml
<tx:method name="transfer" propagation="REQUIRED"/>
```

```
转账方法transfer()：
├── 扣减账户A金额（需要事务）
└── 增加账户B金额（需要事务）

两个操作必须在同一个事务中 ✅
```

**场景2：日志记录（REQUIRES_NEW）**

```xml
<tx:method name="saveLog" propagation="REQUIRES_NEW"/>
```

```
业务方法A（事务1）：
├── 执行业务逻辑
├── 调用saveLog()  → 开启新事务2
│   └── 记录日志
├── 继续业务逻辑
└── 事务1提交

即使业务失败回滚，日志依然保存 ✅
```

**场景3：查询方法（SUPPORTS）**

```xml
<tx:method name="query*" propagation="SUPPORTS" read-only="true"/>
```

```
查询用户列表：
- 如果在事务中调用 → 加入事务
- 如果单独调用 → 不开启事务（更高效）
```

> 🎯 **选择建议**  
> - 🟢 增删改：使用`REQUIRED`  
> - 🟡 查询：使用`SUPPORTS`  
> - 🔵 日志/审计：使用`REQUIRES_NEW`

---

## 8. 🔒 事务隔离级别


### 8.1 并发问题理解


> 💡 **银行取款的故事**  
> 你和朋友同时给你妈转账：
> - **脏读**：朋友转了1000但还没确认，你看到余额增加了（实际可能失败）
> - **不可重复读**：你查余额5000，朋友转了1000，你再查变成6000了
> - **幻读**：你查"今天的转账记录"有3条，朋友又转了一笔，你再查变成4条

### 8.2 四种隔离级别


| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 使用场景 |
|---------|------|-----------|------|------|---------|
| `READ_UNCOMMITTED` | ❌ 会发生 | ❌ 会发生 | ❌ 会发生 | ⭐⭐⭐⭐⭐ | 几乎不用 |
| `READ_COMMITTED` | ✅ 防止 | ❌ 会发生 | ❌ 会发生 | ⭐⭐⭐⭐ | Oracle默认 |
| `REPEATABLE_READ` | ✅ 防止 | ✅ 防止 | ❌ 会发生 | ⭐⭐⭐ | MySQL默认 |
| `SERIALIZABLE` | ✅ 防止 | ✅ 防止 | ✅ 防止 | ⭐ | 要求极高场景 |

### 8.3 配置示例


```xml
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <!-- 财务相关：使用最高隔离级别 -->
        <tx:method name="transfer" 
                   propagation="REQUIRED" 
                   isolation="SERIALIZABLE"/>
        
        <!-- 一般业务：使用可重复读 -->
        <tx:method name="save*" 
                   propagation="REQUIRED" 
                   isolation="REPEATABLE_READ"/>
        
        <!-- 查询操作：读已提交即可 -->
        <tx:method name="find*" 
                   propagation="SUPPORTS" 
                   isolation="READ_COMMITTED" 
                   read-only="true"/>
    </tx:attributes>
</tx:advice>
```

> ⚠️ **性能与安全的权衡**  
> - 隔离级别越高 → 数据越安全，但性能越低  
> - 隔离级别越低 → 性能越好，但可能出现脏数据  
> - 默认使用数据库的隔离级别（MySQL是REPEATABLE_READ）

---

## 9. ↩️ 事务回滚规则


### 9.1 默认回滚规则


```
Spring默认行为：
├── RuntimeException（运行时异常） → 自动回滚 ✅
├── Error（错误） → 自动回滚 ✅
└── CheckedException（检查异常） → 不回滚 ❌
```

> 📖 **通俗理解**  
> Spring认为：
> - 运行时异常（如空指针）→ 程序出错了，必须回滚
> - 检查异常（如IO异常）→ 可能是正常业务，不一定回滚

### 9.2 自定义回滚规则


**配置示例**

```xml
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <!-- 遇到任何异常都回滚 -->
        <tx:method name="transfer" 
                   propagation="REQUIRED"
                   rollback-for="java.lang.Exception"/>
        
        <!-- 遇到特定异常不回滚 -->
        <tx:method name="importData" 
                   propagation="REQUIRED"
                   no-rollback-for="java.io.IOException"/>
        
        <!-- 多个异常用逗号分隔 -->
        <tx:method name="process" 
                   propagation="REQUIRED"
                   rollback-for="SQLException,DataAccessException"/>
    </tx:attributes>
</tx:advice>
```

### 9.3 实际业务场景


**场景1：文件导入失败**

```xml
<!-- 文件读取失败不回滚，其他异常回滚 -->
<tx:method name="importUsers" 
           propagation="REQUIRED"
           rollback-for="java.lang.Exception"
           no-rollback-for="java.io.FileNotFoundException"/>
```

```
导入用户数据：
1. 读取文件 → 文件不存在（FileNotFoundException）
   → 不回滚，记录日志，返回错误信息 ✅

2. 保存数据 → 数据库错误（SQLException）  
   → 回滚，保证数据一致性 ✅
```

**场景2：业务异常处理**

```xml
<!-- 自定义业务异常不回滚 -->
<tx:method name="createOrder" 
           propagation="REQUIRED"
           rollback-for="java.lang.Exception"
           no-rollback-for="com.example.exception.BusinessException"/>
```

> 💡 **配置技巧**  
> - `rollback-for`：指定哪些异常要回滚  
> - `no-rollback-for`：指定哪些异常不回滚  
> - 两者可以组合使用，精确控制回滚行为

---

## 10. 🔀 多数据源配置


### 10.1 多数据源应用场景


```
实际业务场景：
📊 主数据库（master）：处理用户下单、支付等核心业务
📈 从数据库（slave）：处理数据统计、报表查询
📦 第三方库（logistics）：对接物流系统数据
```

> 💡 **为什么需要多数据源**  
> - 读写分离：主库写，从库读，提升性能  
> - 业务隔离：不同业务用不同数据库  
> - 异构数据源：同时操作MySQL和Oracle

### 10.2 多数据源配置方案


**第一步：配置多个数据源**

```xml
<!-- 主数据源 -->
<bean id="masterDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="url" value="${master.jdbc.url}"/>
    <property name="username" value="${master.jdbc.username}"/>
    <property name="password" value="${master.jdbc.password}"/>
</bean>

<!-- 从数据源 -->
<bean id="slaveDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="url" value="${slave.jdbc.url}"/>
    <property name="username" value="${slave.jdbc.username}"/>
    <property name="password" value="${slave.jdbc.password}"/>
</bean>

<!-- 物流数据源 -->
<bean id="logisticsDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="url" value="${logistics.jdbc.url}"/>
    <property name="username" value="${logistics.jdbc.username}"/>
    <property name="password" value="${logistics.jdbc.password}"/>
</bean>
```

**第二步：配置多个SqlSessionFactory**

```xml
<!-- 主库SqlSessionFactory -->
<bean id="masterSqlSessionFactory" 
      class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="masterDataSource"/>
    <property name="mapperLocations" value="classpath:mapper/master/*.xml"/>
</bean>

<!-- 从库SqlSessionFactory -->
<bean id="slaveSqlSessionFactory" 
      class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="slaveDataSource"/>
    <property name="mapperLocations" value="classpath:mapper/slave/*.xml"/>
</bean>

<!-- 物流库SqlSessionFactory -->
<bean id="logisticsSqlSessionFactory" 
      class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="logisticsDataSource"/>
    <property name="mapperLocations" value="classpath:mapper/logistics/*.xml"/>
</bean>
```

**第三步：配置多个Mapper扫描器**

```xml
<!-- 主库Mapper扫描 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.example.mapper.master"/>
    <property name="sqlSessionFactoryBeanName" value="masterSqlSessionFactory"/>
</bean>

<!-- 从库Mapper扫描 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.example.mapper.slave"/>
    <property name="sqlSessionFactoryBeanName" value="slaveSqlSessionFactory"/>
</bean>

<!-- 物流库Mapper扫描 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.example.mapper.logistics"/>
    <property name="sqlSessionFactoryBeanName" value="logisticsSqlSessionFactory"/>
</bean>
```

### 10.3 配置多个事务管理器


```xml
<!-- 主库事务管理器 -->
<bean id="masterTransactionManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="masterDataSource"/>
</bean>

<!-- 从库事务管理器 -->
<bean id="slaveTransactionManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="slaveDataSource"/>
</bean>

<!-- 主库事务通知 -->
<tx:advice id="masterTxAdvice" transaction-manager="masterTransactionManager">
    <tx:attributes>
        <tx:method name="save*" propagation="REQUIRED"/>
        <tx:method name="update*" propagation="REQUIRED"/>
        <tx:method name="delete*" propagation="REQUIRED"/>
    </tx:attributes>
</tx:advice>

<!-- 从库事务通知（只读） -->
<tx:advice id="slaveTxAdvice" transaction-manager="slaveTransactionManager">
    <tx:attributes>
        <tx:method name="*" propagation="SUPPORTS" read-only="true"/>
    </tx:attributes>
</tx:advice>

<!-- AOP配置 -->
<aop:config>
    <!-- 主库切面：写操作 -->
    <aop:pointcut id="masterService" 
                  expression="execution(* com.example.service.master..*.*(..))"/>
    <aop:advisor advice-ref="masterTxAdvice" pointcut-ref="masterService"/>
    
    <!-- 从库切面：读操作 -->
    <aop:pointcut id="slaveService" 
                  expression="execution(* com.example.service.slave..*.*(..))"/>
    <aop:advisor advice-ref="slaveTxAdvice" pointcut-ref="slaveService"/>
</aop:config>
```

### 10.4 项目结构组织


```
项目结构：
src/main/java
├── com.example.mapper
│   ├── master/          ← 主库Mapper接口
│   │   ├── UserMapper.java
│   │   └── OrderMapper.java
│   ├── slave/           ← 从库Mapper接口
│   │   └── ReportMapper.java
│   └── logistics/       ← 物流库Mapper接口
│       └── LogisticsMapper.java
│
├── com.example.service
│   ├── master/          ← 主库Service（写操作）
│   │   └── UserService.java
│   └── slave/           ← 从库Service（读操作）
│       └── ReportService.java
│
src/main/resources
└── mapper
    ├── master/          ← 主库SQL映射
    │   └── UserMapper.xml
    ├── slave/           ← 从库SQL映射
    │   └── ReportMapper.xml
    └── logistics/       ← 物流库SQL映射
        └── LogisticsMapper.xml
```

> 🎯 **多数据源最佳实践**  
> ✅ 按数据源划分包结构  
> ✅ 命名清晰（master/slave/logistics）  
> ✅ 每个数据源独立配置事务  
> ✅ 避免跨数据源的事务操作

---

## 11. 📋 核心要点总结


### 11.1 整合配置核心步骤


```
Spring整合MyBatis五步走：

第1步：配置数据源
├── 选择数据源（Druid/HikariCP）
└── 配置连接池参数

第2步：配置SqlSessionFactory
├── 指定数据源
├── 指定映射文件位置
└── 配置MyBatis参数

第3步：配置Mapper扫描
├── 指定扫描包
└── 自动创建Mapper实现

第4步：配置事务管理器
└── 关联数据源

第5步：配置声明式事务
├── 定义事务通知
└── 配置AOP切面
```

### 11.2 事务配置关键点


| 配置项 | 作用 | 推荐值 | 适用场景 |
|--------|------|--------|---------|
| **传播行为** | 控制事务传播方式 | `REQUIRED` | 增删改操作 |
|  |  | `SUPPORTS` | 查询操作 |
|  |  | `REQUIRES_NEW` | 日志记录 |
| **隔离级别** | 控制并发读写 | `REPEATABLE_READ` | 一般业务 |
|  |  | `SERIALIZABLE` | 财务业务 |
| **回滚规则** | 控制异常回滚 | `rollback-for="Exception"` | 安全为主 |
|  |  | `no-rollback-for` | 特殊业务 |
| **只读事务** | 优化查询性能 | `read-only="true"` | 查询方法 |

### 11.3 多数据源配置要点


> 🔍 **多数据源配置检查清单**  
> ✅ 每个数据源独立配置  
> ✅ 每个数据源独立SqlSessionFactory  
> ✅ 每个数据源独立Mapper扫描器  
> ✅ 每个数据源独立事务管理器  
> ✅ 包结构清晰划分  

### 11.4 常见配置问题


**问题1：事务不生效**

```
原因排查：
✅ 检查是否配置了事务管理器
✅ 检查切入点表达式是否正确
✅ 检查方法访问权限（必须是public）
✅ 检查是否在同类中调用（AOP失效）
```

**问题2：Mapper注入失败**

```
原因排查：
✅ 检查basePackage路径是否正确
✅ 检查Mapper接口是否在扫描范围内
✅ 检查SqlSessionFactory配置是否正确
✅ 检查XML映射文件是否能找到
```

**问题3：多数据源冲突**

```
原因排查：
✅ 检查是否指定了sqlSessionFactoryBeanName
✅ 检查包路径是否有重叠
✅ 检查Bean的id是否唯一
✅ 检查事务管理器是否对应正确
```

### 11.5 性能优化建议


```
🚀 性能优化清单：

数据源优化：
├── 合理设置连接池大小（initialSize, maxActive）
├── 启用连接复用（minIdle保持最小空闲）
└── 开启监控（Druid的filters="stat"）

事务优化：
├── 查询方法使用read-only=true
├── 避免事务方法中有耗时操作
├── 合理选择隔离级别（不要都用SERIALIZABLE）
└── 及时提交事务，缩短事务时间

SQL优化：
├── 使用批量操作减少数据库交互
├── 合理使用缓存减少查询
└── 避免在事务中执行大量SQL
```

### 11.6 最佳实践总结


> 🧠 **核心记忆口诀**  
> 数据源配好池，工厂扫描紧相随  
> 事务管理切面配，传播隔离要明白  
> 多源独立各自管，命名规范不混乱  
> 查询只读性能好，异常回滚规则巧

**关键配置模板**

```xml
<!-- 最小化配置模板 -->
<beans>
    <!-- 1. 数据源 -->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/>
    
    <!-- 2. SqlSessionFactory -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    
    <!-- 3. Mapper扫描 -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.example.mapper"/>
    </bean>
    
    <!-- 4. 事务管理器 -->
    <bean id="transactionManager" 
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    
    <!-- 5. 声明式事务 -->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="*" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>
    
    <!-- 6. AOP切面 -->
    <aop:config>
        <aop:advisor advice-ref="txAdvice" 
                     pointcut="execution(* com.example.service..*.*(..))"/>
    </aop:config>
</beans>
```

---

**🎓 学习建议**
1. ⭐ 先掌握基础整合（单数据源）
2. ⭐⭐ 理解事务传播和隔离级别
3. ⭐⭐⭐ 实践多数据源配置
4. 🔥 结合实际项目调优配置