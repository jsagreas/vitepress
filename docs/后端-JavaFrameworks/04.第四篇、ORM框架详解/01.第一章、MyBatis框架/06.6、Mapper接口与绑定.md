---
title: 6、Mapper接口与绑定
---
## 📚 目录

1. [Mapper接口基础理解](#1-Mapper接口基础理解)
2. [接口与XML的绑定机制](#2-接口与XML的绑定机制)
3. [动态代理的工作原理](#3-动态代理的工作原理)
4. [方法调用的完整流程](#4-方法调用的完整流程)
5. [参数与返回值处理](#5-参数与返回值处理)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 Mapper接口基础理解


### 1.1 什么是Mapper接口


**🌰 生活类比**  
想象你去餐厅吃饭，你不需要知道后厨怎么做菜，只需要看菜单（接口）点菜就行。Mapper接口就像这个菜单，定义了"你能做什么操作"，而具体怎么做（SQL语句）写在XML文件里。

**📖 简单定义**
```
Mapper接口 = 数据库操作的菜单
- 接口定义：我能对数据库做什么（查询、新增、修改、删除）
- XML配置：具体怎么做（真正的SQL语句）
- MyBatis负责：把接口和XML连接起来
```

### 1.2 Mapper接口长什么样


**🔸 最简单的例子**
```java
// UserMapper.java - 这是一个接口，不是类！
public interface UserMapper {
    
    // 根据ID查询用户 - 只有方法声明，没有实现
    User findById(Integer id);
    
    // 查询所有用户
    List<User> findAll();
    
    // 新增用户
    void insert(User user);
}
```

**💡 关键理解**
- **只有方法定义**：接口里只写方法名、参数、返回值，不写具体代码
- **没有实现代码**：你看不到任何`{}`里的实现逻辑
- **MyBatis自动实现**：框架会根据XML配置自动生成实现

### 1.3 @Mapper注解的作用


**🔸 两种标记方式**

**方式一：在接口上加@Mapper**
```java
@Mapper  // 告诉Spring：这是一个Mapper接口，帮我管理
public interface UserMapper {
    User findById(Integer id);
}
```

**方式二：在启动类上扫描**
```java
@SpringBootApplication
@MapperScan("com.example.mapper")  // 扫描这个包下所有接口
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**🎯 注解的本质作用**
```
@Mapper的作用就是告诉框架：
1. 这个接口需要MyBatis来处理
2. 框架会自动创建这个接口的实现对象
3. 你可以直接注入使用，不用自己new
```

---

## 2. 🔗 接口与XML的绑定机制


### 2.1 绑定的基本规则


**📋 核心绑定规则**

| 接口元素 | XML元素 | **绑定规则** | **示例** |
|---------|---------|------------|---------|
| 🔸 **接口全限定名** | `namespace` | `必须完全一致` | `com.example.mapper.UserMapper` |
| 🔸 **方法名** | `id` | `必须完全一致` | `findById` |
| 🔸 **返回值类型** | `resultType` | `类型匹配` | `com.example.entity.User` |
| 🔸 **参数类型** | `parameterType` | `类型匹配` | `java.lang.Integer` |

**🔸 完整绑定示例**

接口定义：
```java
package com.example.mapper;

@Mapper
public interface UserMapper {
    // 方法名：findById
    // 参数类型：Integer
    // 返回类型：User
    User findById(Integer id);
}
```

XML配置：
```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    
    <!-- id必须等于方法名 -->
    <select id="findById" 
            parameterType="java.lang.Integer"
            resultType="com.example.entity.User">
        SELECT * FROM user WHERE id = #{id}
    </select>
    
</mapper>
```

### 2.2 绑定过程详解


**🔸 MyBatis如何找到对应关系**

```
第1步：读取XML文件
     ↓
找到 namespace="com.example.mapper.UserMapper"
     ↓
第2步：去Spring容器里找这个接口
     ↓
找到 UserMapper接口
     ↓
第3步：接口的每个方法对应XML的id
     ↓
findById方法 → <select id="findById">
```

**💡 常见绑定错误**

> ⚠️ **错误1：namespace写错**
> ```xml
> <!-- 错误：少写了包名 -->
> <mapper namespace="UserMapper">  ❌
> 
> <!-- 正确：完整的类路径 -->
> <mapper namespace="com.example.mapper.UserMapper">  ✅
> ```

> ⚠️ **错误2：方法名和id不一致**
> ```java
> // 接口方法名
> User findById(Integer id);
> ```
> ```xml
> <!-- 错误：id写成了getUserById -->
> <select id="getUserById">  ❌
> 
> <!-- 正确：id必须是findById -->
> <select id="findById">  ✅
> ```

### 2.3 为什么要这样设计


**🤔 思考：为什么要分接口和XML**

```
接口的好处：
✅ 代码清晰 - 一看就知道有哪些数据库操作
✅ 类型安全 - 编译期就能检查参数和返回值
✅ 易于测试 - 可以用Mock模拟，不依赖真实数据库

XML的好处：
✅ SQL集中管理 - 所有SQL语句都在XML里，方便维护
✅ 灵活配置 - 复杂SQL、动态SQL写起来更清晰
✅ 不用重新编译 - 改SQL不需要重新编译Java代码
```

---

## 3. ⚙️ 动态代理的工作原理


### 3.1 什么是动态代理


**🌰 生活类比**  
你在网上点外卖，实际上是这样的流程：

```
你(客户端) → 外卖平台(代理) → 餐厅后厨(真正执行)
            ↑
         看起来你是直接点餐
         实际上平台帮你转发订单
```

MyBatis的动态代理也是一样：

```
你的代码 → MapperProxy代理对象 → 执行SQL
          ↑
       看起来你调用了接口方法
       实际上代理对象帮你执行SQL
```

### 3.2 MapperProxy代理对象


**🔸 代理对象的创建过程**

```
开发者写的代码：
┌─────────────────────┐
│ UserMapper mapper   │  你只写了接口
│ = getMapper(...)    │  并没有实现类
└─────────────────────┘
           ↓
MyBatis内部处理：
┌─────────────────────┐
│ 1.检查接口是否有    │
│   对应的XML配置     │
│ 2.创建代理对象      │
│   MapperProxy       │
│ 3.返回代理对象      │
└─────────────────────┘
           ↓
你拿到的对象：
┌─────────────────────┐
│ UserMapper实例      │  看起来是UserMapper
│ (实际是代理对象)     │  实际是MapperProxy
└─────────────────────┘
```

**💻 代理创建的关键代码**

```java
// 你的业务代码
@Autowired
private UserMapper userMapper;  // 这里注入的就是代理对象

public void test() {
    // 调用方法时，实际调用的是代理对象的方法
    User user = userMapper.findById(1);
}
```

### 3.3 SqlSession.getMapper()方法


**🔸 获取Mapper的过程**

```java
// 手动获取Mapper的方式（了解原理）
SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
```

**🔍 内部执行流程**

```
sqlSession.getMapper(UserMapper.class)
            ↓
第1步：从Configuration中查找Mapper配置
            ↓
第2步：使用JDK动态代理创建MapperProxy对象
            ↓
第3步：返回代理对象
            ↓
你得到的mapper对象（本质是MapperProxy实例）
```

**💡 关键理解**
```
UserMapper mapper = sqlSession.getMapper(UserMapper.class);

这行代码做了什么：
1. 传入接口的Class对象
2. MyBatis创建一个代理对象（MapperProxy）
3. 这个代理对象实现了UserMapper接口
4. 返回给你使用
```

---

## 4. 🔄 方法调用的完整流程


### 4.1 调用流程图解


```
你的代码调用
   │
   │  userMapper.findById(1)
   ↓
MapperProxy拦截
   │
   │  1.获取方法信息（方法名、参数）
   │  2.找到对应的SQL语句
   ↓
构建SQL执行环境
   │
   │  1.解析参数：id=1
   │  2.替换SQL中的#{id}
   │  3.准备返回值类型
   ↓
执行SQL查询
   │
   │  SELECT * FROM user WHERE id = 1
   ↓
处理结果集
   │
   │  1.获取查询结果
   │  2.封装成User对象
   ↓
返回结果
   │
   │  return user对象
   ↓
你的代码收到结果
```

### 4.2 方法调用的核心步骤


**第1步：方法拦截**
```java
// 当你调用
User user = userMapper.findById(1);

// MapperProxy拦截到：
// - 方法名：findById
// - 参数：[1]
// - 返回类型：User
```

**第2步：定位SQL语句**
```
根据方法信息定位SQL：
namespace: com.example.mapper.UserMapper
id: findById
→ 找到：<select id="findById">...</select>
```

**第3步：参数处理**
```
方法参数：Integer id = 1
SQL中的占位符：#{id}
→ 替换后：WHERE id = 1
```

**第4步：执行SQL**
```
最终执行的SQL：
SELECT * FROM user WHERE id = 1
```

**第5步：结果封装**
```
数据库返回：{id:1, name:"张三", age:20}
根据resultType：com.example.entity.User
→ 创建User对象并赋值
→ 返回给调用方
```

### 4.3 动态代理的核心机制


**🔸 代理的本质**

```java
// 简化的代理逻辑理解
public class MapperProxy implements UserMapper {
    
    @Override
    public User findById(Integer id) {
        // 1.找到对应的SQL语句
        String sql = "SELECT * FROM user WHERE id = #{id}";
        
        // 2.替换参数
        sql = sql.replace("#{id}", id.toString());
        
        // 3.执行查询
        ResultSet rs = executeQuery(sql);
        
        // 4.封装结果
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setName(rs.getString("name"));
        
        // 5.返回结果
        return user;
    }
}
```

> 💡 **重要理解**  
> 上面是简化的伪代码，真实的MyBatis实现更复杂，但核心思想就是这样：
> 1. 拦截方法调用
> 2. 找到SQL配置
> 3. 执行SQL
> 4. 处理结果

---

## 5. 📊 参数与返回值处理


### 5.1 参数解析机制


**🔸 单个参数的情况**

```java
// 接口方法
User findById(Integer id);
```

```xml
<!-- XML中直接使用参数 -->
<select id="findById" resultType="User">
    SELECT * FROM user WHERE id = #{id}
</select>
```

**参数处理过程：**
```
方法调用：findById(1)
         ↓
MyBatis解析：参数名=id, 参数值=1
         ↓
替换SQL：WHERE id = 1
```

**🔸 多个参数的情况**

```java
// 接口方法 - 使用@Param注解
User findByNameAndAge(@Param("name") String name, 
                      @Param("age") Integer age);
```

```xml
<!-- XML中使用注解指定的参数名 -->
<select id="findByNameAndAge" resultType="User">
    SELECT * FROM user 
    WHERE name = #{name} AND age = #{age}
</select>
```

**参数处理过程：**
```
方法调用：findByNameAndAge("张三", 20)
         ↓
MyBatis解析：
  @Param("name") → name="张三"
  @Param("age") → age=20
         ↓
替换SQL：WHERE name = '张三' AND age = 20
```

**🔸 对象参数的情况**

```java
// 接口方法
void insert(User user);
```

```xml
<!-- XML中使用对象属性 -->
<insert id="insert">
    INSERT INTO user (name, age) 
    VALUES (#{name}, #{age})
</insert>
```

**参数处理过程：**
```
方法调用：insert(user对象)
         ↓
MyBatis获取属性：
  user.getName() → #{name}
  user.getAge() → #{age}
         ↓
生成SQL：VALUES ('张三', 20)
```

### 5.2 返回值处理机制


**🔸 返回单个对象**

```java
User findById(Integer id);
```

```xml
<select id="findById" resultType="User">
    SELECT * FROM user WHERE id = #{id}
</select>
```

**处理流程：**
```
执行SQL查询
    ↓
获取结果集：{id:1, name:"张三", age:20}
    ↓
根据resultType创建User对象
    ↓
通过setter方法或反射赋值：
  user.setId(1)
  user.setName("张三")
  user.setAge(20)
    ↓
返回User对象
```

**🔸 返回集合**

```java
List<User> findAll();
```

```xml
<select id="findAll" resultType="User">
    SELECT * FROM user
</select>
```

**处理流程：**
```
执行SQL查询
    ↓
获取多行结果集
    ↓
遍历每一行：
  第1行 → 创建User对象1
  第2行 → 创建User对象2
  第3行 → 创建User对象3
    ↓
所有对象放入List集合
    ↓
返回 List<User>
```

**🔸 返回Map**

```java
Map<String, Object> findByIdAsMap(Integer id);
```

```xml
<select id="findByIdAsMap" resultType="map">
    SELECT * FROM user WHERE id = #{id}
</select>
```

**处理流程：**
```
执行SQL查询
    ↓
获取结果：{id:1, name:"张三", age:20}
    ↓
放入Map：
  map.put("id", 1)
  map.put("name", "张三")
  map.put("age", 20)
    ↓
返回Map对象
```

### 5.3 参数和返回值的类型匹配


**📋 常见类型对照表**

| Java类型 | **数据库类型** | **XML配置** | **说明** |
|---------|--------------|-----------|---------|
| `Integer` | `INT` | `parameterType="int"` | `整数类型` |
| `String` | `VARCHAR` | `parameterType="string"` | `字符串类型` |
| `Date` | `DATETIME` | `parameterType="date"` | `日期类型` |
| `User对象` | `user表` | `resultType="User"` | `实体类` |
| `List<User>` | `多行记录` | `resultType="User"` | `集合，但resultType写单个` |

> ⚠️ **重要提示**  
> - `parameterType`可以省略，MyBatis会自动推断
> - `resultType`写的是单个对象类型，即使返回List也写User
> - 对象属性名要和数据库字段名对应（或用resultMap映射）

---

## 6. 📋 核心要点总结


### 6.1 Mapper接口的本质理解


```
🔸 Mapper接口 = 数据库操作的抽象定义
  - 只定义方法，不写实现
  - 通过@Mapper或@MapperScan让框架识别
  - MyBatis自动生成代理对象来实现功能
```

### 6.2 绑定机制的核心规则


**🎯 三大绑定要素**

```
1️⃣ namespace 必须等于 接口全限定名
   com.example.mapper.UserMapper

2️⃣ id 必须等于 接口方法名
   findById

3️⃣ 参数和返回类型要匹配
   Integer id → parameterType
   User对象 → resultType
```

### 6.3 动态代理的执行流程


```
调用方法 → MapperProxy拦截 → 定位SQL → 解析参数 
       ↓
    执行SQL → 处理结果 → 封装对象 → 返回结果
```

### 6.4 参数处理的三种情况


| 参数类型 | **使用方式** | **XML写法** |
|---------|------------|-----------|
| 🔸 **单个参数** | `直接使用` | `#{参数名}` |
| 🔸 **多个参数** | `@Param注解` | `#{注解名}` |
| 🔸 **对象参数** | `传对象` | `#{属性名}` |

### 6.5 必须掌握的关键点


**🧠 记忆要点**

```
1. Mapper接口：定义做什么
2. XML配置：定义怎么做
3. 动态代理：自动实现接口
4. 方法调用：代理对象拦截处理
5. 参数解析：根据规则替换SQL
6. 结果封装：根据类型创建对象
```

**🔍 学习自检**

- [ ] 能说出Mapper接口的作用
- [ ] 理解@Mapper注解的用途
- [ ] 知道接口和XML如何绑定
- [ ] 明白动态代理的基本原理
- [ ] 掌握参数和返回值的处理方式
- [ ] 能排查常见的绑定错误

**🚀 实践建议**

1. **从简单开始**：先写单表的增删改查
2. **理解原理**：多debug看代理对象和执行流程
3. **注意规范**：namespace、id命名要准确
4. **参数处理**：多个参数记得用@Param

---

**核心理解**：Mapper接口就像遥控器，你按按钮（调用方法），MyBatis通过动态代理这个"中转站"，帮你执行真正的SQL操作，最后把结果返回给你。整个过程你不需要写实现代码，框架自动完成！