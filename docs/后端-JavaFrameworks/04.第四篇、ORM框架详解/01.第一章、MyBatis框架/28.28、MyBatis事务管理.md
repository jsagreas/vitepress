---
title: 28、MyBatis事务管理
---
## 📚 目录

1. [事务是什么？为什么需要事务？](#1-事务是什么为什么需要事务)
2. [MyBatis的事务管理器](#2-mybatis的事务管理器)
3. [JDBC事务管理详解](#3-jdbc事务管理详解)
4. [MANAGED事务管理](#4-managed事务管理)
5. [事务隔离级别](#5-事务隔离级别)
6. [事务传播行为](#6-事务传播行为)
7. [事务回滚机制](#7-事务回滚机制)
8. [分布式事务处理](#8-分布式事务处理)
9. [事务性能优化](#9-事务性能优化)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 事务是什么？为什么需要事务？


### 1.1 生活中的事务例子


**💰 银行转账的故事**
```
小明给小红转账1000元，这个过程包括：
步骤1：从小明账户扣除1000元
步骤2：给小红账户增加1000元

问题来了：如果扣款成功，但加款失败怎么办？
→ 小明的钱没了，小红也没收到！这就乱套了！

事务的作用：
✅ 要么两步都成功（转账完成）
✅ 要么两步都不做（保持原状）
❌ 绝不允许只做一半！
```

**🎯 事务的本质理解**
> **通俗定义**：事务就是把多个操作捆绑成一个整体，要么全部成功，要么全部失败，不能只完成一部分。
>
> **专业定义**：事务（Transaction）是数据库操作的最小工作单元，是一系列操作的集合，这些操作要么全部执行成功，要么全部不执行。

### 1.2 事务的四大特性（ACID）


```
🔸 原子性（Atomicity）- 不可分割
   类比：吃药，要么整颗吞下，不能吃一半
   含义：事务中的操作要么全做，要么全不做

🔸 一致性（Consistency）- 前后一致  
   类比：能量守恒，总金额转账前后不变
   含义：事务前后数据状态必须一致

🔸 隔离性（Isolation）- 互不干扰
   类比：ATM机的独立空间，别人看不到你的操作
   含义：多个事务同时进行互不影响

🔸 持久性（Durability）- 永久保存
   类比：刻在石碑上，不会消失
   含义：事务一旦提交，数据永久保存
```

### 1.3 为什么MyBatis需要事务？


**实际业务场景**
```
场景1：电商下单
├── 创建订单记录
├── 减少商品库存
├── 扣减用户余额
└── 生成物流信息
→ 这4步必须全部成功，否则回滚

场景2：用户注册
├── 插入用户基本信息
├── 创建用户账户
└── 初始化用户权限
→ 任何一步失败都要全部撤销
```

---

## 2. 🔧 MyBatis的事务管理器


### 2.1 事务管理器的作用


**🎯 核心职责**
```
事务管理器就像一个"总指挥"：
1️⃣ 决定什么时候开始事务
2️⃣ 控制什么时候提交事务  
3️⃣ 处理什么时候回滚事务
4️⃣ 管理数据库连接的生命周期
```

### 2.2 两种事务管理器类型


| 类型 | 使用场景 | 谁来管理 | 自动提交 |
|------|---------|---------|---------|
| **JDBC** | 独立使用MyBatis | MyBatis自己管理 | 可配置 |
| **MANAGED** | 集成Spring等容器 | 外部容器管理 | 由容器决定 |

**💡 如何选择？**
```
选择JDBC：
✅ 单独使用MyBatis
✅ 简单项目快速开发
✅ 需要精确控制事务

选择MANAGED：
✅ 使用Spring框架
✅ 需要声明式事务
✅ 企业级应用开发
```

### 2.3 配置事务管理器


**基础配置示例**
```xml
<!-- mybatis-config.xml -->
<environments default="development">
    <environment id="development">
        <!-- JDBC事务管理器 -->
        <transactionManager type="JDBC"/>
        
        <dataSource type="POOLED">
            <property name="driver" value="com.mysql.jdbc.Driver"/>
            <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
            <property name="username" value="root"/>
            <property name="password" value="123456"/>
        </dataSource>
    </environment>
</environments>
```

**🔍 配置说明**
- `type="JDBC"`：使用MyBatis自己的事务管理
- `type="MANAGED"`：把事务管理交给外部容器

---

## 3. ⚙️ JDBC事务管理详解


### 3.1 JDBC事务的工作原理


**事务执行流程图**
```
开始事务 → 执行SQL → 检查结果 → 提交/回滚 → 结束

详细过程：
┌─────────────┐
│ 1.开启事务  │ ← setAutoCommit(false)
└─────────────┘
       ↓
┌─────────────┐
│ 2.执行SQL   │ ← insert/update/delete
└─────────────┘
       ↓
    成功? ──→ 是 ──→ commit()  → 永久保存
       ↓
       否
       ↓
    rollback() → 全部撤销
```

### 3.2 自动提交配置


**🔸 什么是自动提交？**
```
自动提交开启（默认）：
每执行一条SQL就自动提交，无法回滚
示例：
  insert → 自动提交 ✓
  update → 自动提交 ✓
  出错了也无法撤销 ✗

自动提交关闭：
手动控制提交时机，可以回滚
示例：
  insert → 等待
  update → 等待
  commit → 全部生效 ✓
  或 rollback → 全部撤销
```

**配置方式对比**

| 配置方式 | 自动提交 | 适用场景 | 特点 |
|---------|---------|---------|------|
| `openSession()` | ❌ 关闭 | 需要事务控制 | 需手动commit |
| `openSession(true)` | ✅ 开启 | 简单查询 | 自动提交 |

**代码示例**
```java
// 方式1：手动控制事务（推荐）
SqlSession session = sqlSessionFactory.openSession(); // 关闭自动提交
try {
    UserMapper mapper = session.getMapper(UserMapper.class);
    
    mapper.insertUser(user);      // 执行插入
    mapper.updateAccount(account); // 执行更新
    
    session.commit();  // 手动提交 - 两个操作一起生效
} catch (Exception e) {
    session.rollback(); // 出错回滚 - 两个操作都撤销
} finally {
    session.close();
}

// 方式2：自动提交（不推荐用于事务操作）
SqlSession session = sqlSessionFactory.openSession(true);
mapper.insertUser(user); // 立即提交，无法回滚
```

### 3.3 手动事务控制


**🎯 三个核心方法**

**1. commit() - 提交事务**
```java
作用：把所有操作永久保存到数据库
时机：所有SQL执行成功后

session.commit(); // 让改动生效
```

**2. rollback() - 回滚事务**
```java
作用：撤销所有未提交的操作
时机：发生错误或需要取消时

session.rollback(); // 全部撤销
```

**3. close() - 关闭会话**
```java
作用：释放数据库连接资源
注意：关闭前必须先commit或rollback

session.close(); // 释放资源
```

**⚠️ 常见错误**
```java
// ❌ 错误示例：忘记提交
SqlSession session = sqlSessionFactory.openSession();
mapper.insertUser(user);
session.close(); // 直接关闭，数据丢失！

// ✅ 正确示例：先提交再关闭
SqlSession session = sqlSessionFactory.openSession();
try {
    mapper.insertUser(user);
    session.commit();  // 先提交
} finally {
    session.close();   // 再关闭
}
```

### 3.4 实战案例：用户注册事务


**业务需求**
```
用户注册需要：
1. 插入用户基本信息
2. 创建用户账户（初始余额0）
3. 分配默认角色权限

要求：三步必须全部成功，任何一步失败都要回滚
```

**完整实现**
```java
public boolean registerUser(User user) {
    SqlSession session = sqlSessionFactory.openSession(); // 关闭自动提交
    
    try {
        UserMapper userMapper = session.getMapper(UserMapper.class);
        AccountMapper accountMapper = session.getMapper(AccountMapper.class);
        RoleMapper roleMapper = session.getMapper(RoleMapper.class);
        
        // 步骤1：插入用户信息
        userMapper.insertUser(user);
        
        // 步骤2：创建账户
        Account account = new Account();
        account.setUserId(user.getId());
        account.setBalance(0);
        accountMapper.createAccount(account);
        
        // 步骤3：分配角色
        roleMapper.assignRole(user.getId(), "USER");
        
        // 全部成功，提交事务
        session.commit();
        return true;
        
    } catch (Exception e) {
        // 任何步骤失败，回滚所有操作
        session.rollback();
        System.out.println("注册失败，已回滚：" + e.getMessage());
        return false;
        
    } finally {
        // 无论成功失败都要关闭会话
        session.close();
    }
}
```

**🔍 执行流程解析**
```
成功场景：
插入用户 ✓ → 创建账户 ✓ → 分配角色 ✓ → commit → 数据保存

失败场景1（账户创建失败）：
插入用户 ✓ → 创建账户 ✗ → rollback → 用户数据也撤销

失败场景2（角色分配失败）：
插入用户 ✓ → 创建账户 ✓ → 分配角色 ✗ → rollback → 全部撤销
```

---

## 4. 🌐 MANAGED事务管理


### 4.1 什么是MANAGED？


**🎯 核心理解**
```
MANAGED = 被管理的
含义：MyBatis把事务控制权交给外部容器

类比理解：
JDBC模式：自己开车，自己控制油门刹车
MANAGED模式：坐出租车，司机（容器）控制一切
```

**适用场景**
```
✅ 使用Spring框架
✅ 使用JavaEE容器（如Tomcat）
✅ 需要声明式事务
✅ 多个组件共享事务
```

### 4.2 MANAGED配置


**MyBatis配置**
```xml
<transactionManager type="MANAGED">
    <!-- closeConnection属性说明 -->
    <property name="closeConnection" value="false"/>
</transactionManager>
```

**🔍 属性说明**

| 属性 | 值 | 含义 | 使用场景 |
|------|---|------|---------|
| closeConnection | true | MyBatis关闭连接 | 不使用容器连接池 |
| closeConnection | false | 容器管理连接 | 使用Spring等容器 |

### 4.3 Spring集成示例


**Spring配置事务管理器**
```java
@Configuration
@EnableTransactionManagement // 开启事务支持
public class MyBatisConfig {
    
    @Bean
    public DataSourceTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

**使用声明式事务**
```java
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    // @Transactional：Spring自动管理事务
    @Transactional(rollbackFor = Exception.class)
    public void registerUser(User user) {
        userMapper.insertUser(user);
        accountMapper.createAccount(account);
        roleMapper.assignRole(user.getId(), "USER");
        
        // 不需要手动commit/rollback
        // Spring会自动处理
    }
}
```

**💡 两种模式对比**

| 特性 | JDBC模式 | MANAGED+Spring模式 |
|------|---------|-------------------|
| **事务控制** | 手动commit/rollback | 自动管理 |
| **代码复杂度** | 需要try-catch | 简洁清晰 |
| **适用规模** | 小项目 | 企业级应用 |
| **学习成本** | 低 | 需要了解Spring |

---

## 5. 🔒 事务隔离级别


### 5.1 为什么需要隔离级别？


**问题场景**
```
银行系统中：
用户A查询余额：1000元
同时用户A在ATM取款：-500元
此时另一个线程查询用户A余额显示多少？

可能出现的问题：
📌 脏读：读到未提交的数据
📌 不可重复读：同一事务内两次读取结果不同
📌 幻读：突然多出或少了数据
```

### 5.2 四个隔离级别详解


**隔离级别对比表**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 使用场景 |
|---------|------|-----------|------|------|---------|
| **READ_UNCOMMITTED** | ❌可能 | ❌可能 | ❌可能 | ⚡最快 | 几乎不用 |
| **READ_COMMITTED** | ✅避免 | ❌可能 | ❌可能 | ⚡较快 | Oracle默认 |
| **REPEATABLE_READ** | ✅避免 | ✅避免 | ❌可能 | 🐢较慢 | MySQL默认 |
| **SERIALIZABLE** | ✅避免 | ✅避免 | ✅避免 | 🐢最慢 | 关键业务 |

**📖 具体问题解释**

**1. 脏读（Dirty Read）**
```
时间线：
T1: 开始事务
T1: 修改金额为500（未提交）
T2: 读取金额 → 看到500 ← 这是脏读！
T1: 回滚，金额还是1000
T2: 拿到的500是错误数据
```

**2. 不可重复读（Non-Repeatable Read）**
```
时间线：
T1: 读取金额 → 1000
T2: 修改金额为500并提交
T1: 再次读取 → 500 ← 同一事务内结果变了！
```

**3. 幻读（Phantom Read）**
```
时间线：
T1: 查询订单数量 → 10条
T2: 插入新订单并提交
T1: 再次查询 → 11条 ← 凭空多了一条！
```

### 5.3 MyBatis中配置隔离级别


**方式1：全局配置**
```xml
<transactionManager type="JDBC">
    <property name="defaultIsolationLevel" value="2"/>
</transactionManager>
```

**隔离级别数值对照**
```
1 = READ_UNCOMMITTED  （读未提交）
2 = READ_COMMITTED    （读已提交）
4 = REPEATABLE_READ   （可重复读）
8 = SERIALIZABLE      （序列化）
```

**方式2：代码中设置**
```java
// 打开会话时指定隔离级别
SqlSession session = sqlSessionFactory.openSession(
    TransactionIsolationLevel.REPEATABLE_READ
);
```

**🎯 选择建议**
```
一般业务：READ_COMMITTED（Oracle默认）
金融交易：REPEATABLE_READ（MySQL默认）
严格要求：SERIALIZABLE（性能最差）
性能优先：READ_UNCOMMITTED（不推荐）
```

---

## 6. 🔄 事务传播行为


### 6.1 什么是事务传播？


**场景引入**
```
服务A调用服务B：
ServiceA {
    开始事务A
    执行操作A
    调用ServiceB
    提交事务A
}

ServiceB {
    应该加入事务A？
    还是新建事务B？
    → 这就是传播行为要解决的问题
}
```

**🎯 核心理解**
> 事务传播行为决定了：当一个事务方法调用另一个事务方法时，被调用方法如何处理事务。

### 6.2 常见传播行为（Spring）


**传播行为对比表**

| 传播行为 | 含义 | 场景说明 |
|---------|------|---------|
| **REQUIRED** | 有就加入，没有就新建 | 最常用，默认行为 |
| **REQUIRES_NEW** | 总是新建事务 | 独立操作，互不影响 |
| **SUPPORTS** | 有就加入，没有就算了 | 查询等非关键操作 |
| **MANDATORY** | 必须有事务，否则报错 | 强制事务环境 |
| **NEVER** | 不能有事务，否则报错 | 明确非事务操作 |

**🔍 REQUIRED详解（最常用）**
```
场景1：外部有事务
ServiceA {
    开始事务A
    调用ServiceB → 加入事务A（共用一个事务）
    提交事务A
}
→ 结果：AB操作在同一事务，一起提交或回滚

场景2：外部无事务
ServiceA {
    调用ServiceB → 新建事务B
}
→ 结果：B独立运行在自己的事务中
```

**🔍 REQUIRES_NEW详解**
```
ServiceA {
    开始事务A
    执行操作A
    调用ServiceB → 暂停A，新建事务B
    ├── 执行操作B
    └── 提交事务B（独立提交）
    恢复事务A
    提交事务A
}

关键特点：
✅ B的提交不影响A
✅ A回滚不影响B
✅ 适合记录日志等独立操作
```

### 6.3 MyBatis中的应用


**⚠️ 重要说明**
```
MyBatis本身不支持传播行为！
传播行为是Spring提供的特性

MyBatis + Spring组合使用：
→ 使用@Transactional注解
→ 由Spring管理传播行为
```

**Spring集成示例**
```java
@Service
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    // REQUIRED：加入当前事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void createOrder(Order order) {
        orderMapper.insert(order);
        
        // 记录日志（使用REQUIRES_NEW独立事务）
        logService.log("创建订单");
    }
}

@Service
public class LogService {
    
    // REQUIRES_NEW：独立事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void log(String message) {
        logMapper.insert(message);
        // 即使订单创建失败，日志也会保存
    }
}
```

---

## 7. ⚠️ 事务回滚机制


### 7.1 什么时候回滚？


**自动回滚场景**
```
✅ 抛出RuntimeException（运行时异常）
✅ 抛出Error
✅ 抛出指定的检查异常（需配置）
❌ 正常执行完成（自动提交）
```

**手动回滚**
```java
SqlSession session = sqlSessionFactory.openSession();
try {
    // 执行业务逻辑
    mapper.insert(user);
    
    if (某个条件不满足) {
        session.rollback(); // 手动触发回滚
        return;
    }
    
    session.commit();
} catch (Exception e) {
    session.rollback(); // 异常时回滚
}
```

### 7.2 回滚的范围


**🔸 部分回滚（保存点）**
```java
// 设置保存点
Savepoint savepoint = connection.setSavepoint("point1");

try {
    // 执行一些操作
    mapper.insertUser(user);
    
    // 更多操作
    mapper.updateAccount(account);
    
} catch (Exception e) {
    // 回滚到保存点（只撤销updateAccount）
    connection.rollback(savepoint);
}
```

**🔸 完全回滚**
```java
try {
    // 多个操作
    mapper.insert1();
    mapper.insert2();
    mapper.insert3();
    session.commit();
} catch (Exception e) {
    session.rollback(); // 全部撤销
}
```

### 7.3 回滚最佳实践


**🎯 标准模板**
```java
public boolean executeTransaction() {
    SqlSession session = null;
    try {
        session = sqlSessionFactory.openSession();
        
        // 业务逻辑
        doBusinessLogic(session);
        
        session.commit();
        return true;
        
    } catch (Exception e) {
        if (session != null) {
            session.rollback();
        }
        logger.error("事务执行失败", e);
        return false;
        
    } finally {
        if (session != null) {
            session.close();
        }
    }
}
```

**⚠️ 常见陷阱**
```java
// ❌ 错误：吞掉异常，不回滚
try {
    mapper.insert(user);
} catch (Exception e) {
    e.printStackTrace(); // 只打印，不回滚！
}
session.commit(); // 错误数据也提交了

// ✅ 正确：捕获后重新抛出或显式回滚
try {
    mapper.insert(user);
} catch (Exception e) {
    session.rollback();
    throw e; // 重新抛出
}
```

---

## 8. 🌍 分布式事务处理


### 8.1 什么是分布式事务？


**场景引入**
```
电商下单流程（跨多个系统）：
┌──────────┐   ┌──────────┐   ┌──────────┐
│ 订单系统 │   │ 库存系统 │   │ 支付系统 │
│ DB-Order │   │ DB-Stock │   │ DB-Pay   │
└──────────┘   └──────────┘   └──────────┘
     ↓              ↓              ↓
   创建订单       减少库存       扣款支付

问题：三个数据库，如何保证要么全成功要么全失败？
```

**🎯 核心理解**
> **本地事务**：操作在同一个数据库，MyBatis的JDBC事务可以处理
>
> **分布式事务**：操作跨多个数据库或系统，需要特殊方案

### 8.2 分布式事务解决方案


**方案对比**

| 方案 | 实现方式 | 优点 | 缺点 | 适用场景 |
|------|---------|------|------|---------|
| **2PC两阶段提交** | XA协议 | 强一致性 | 性能差，阻塞 | 金融交易 |
| **TCC** | Try-Confirm-Cancel | 性能较好 | 开发复杂 | 重要业务 |
| **本地消息表** | 消息+定时任务 | 最终一致 | 有延迟 | 一般业务 |
| **MQ事务消息** | RocketMQ等 | 解耦好 | 依赖MQ | 高并发 |
| **Seata** | AT/TCC/SAGA | 易用 | 需中间件 | 微服务 |

### 8.3 实战方案：本地消息表


**🔍 原理说明**
```
核心思想：把分布式事务拆成多个本地事务

步骤：
1. 订单系统：创建订单 + 写消息表（同一本地事务）
2. 定时任务：扫描消息表，发送给其他系统
3. 库存系统：收到消息，减库存
4. 支付系统：收到消息，扣款
5. 确认成功后，删除消息记录
```

**实现示例**
```java
@Service
public class OrderService {
    
    @Transactional
    public void createOrder(Order order) {
        // 步骤1：插入订单（本地事务）
        orderMapper.insert(order);
        
        // 步骤2：插入消息表（同一事务）
        Message msg = new Message();
        msg.setContent("REDUCE_STOCK:" + order.getProductId());
        msg.setStatus("PENDING");
        messageMapper.insert(msg);
        
        // 提交事务（订单和消息一起提交）
    }
}

// 定时任务：发送消息
@Scheduled(fixedRate = 5000)
public void sendMessages() {
    List<Message> messages = messageMapper.findPending();
    
    for (Message msg : messages) {
        // 发送到库存系统
        boolean success = stockService.reduceStock(msg);
        
        if (success) {
            msg.setStatus("SUCCESS");
            messageMapper.update(msg);
        }
    }
}
```

**💡 优势**
```
✅ 不需要复杂的分布式事务框架
✅ 最终数据一致（可能有延迟）
✅ 失败可重试
✅ 实现相对简单
```

### 8.4 Seata框架简介


**🔸 什么是Seata？**
```
Seata = Simple Extensible Autonomous Transaction Architecture
阿里开源的分布式事务解决方案

核心优势：
✅ 对业务代码零侵入
✅ 支持多种模式（AT/TCC/SAGA）
✅ 高性能
✅ 易于集成Spring Cloud
```

**简单使用示例**
```java
// 只需加一个注解！
@GlobalTransactional
public void placeOrder(Order order) {
    // 订单服务：创建订单
    orderService.create(order);
    
    // 库存服务：减库存（跨数据库）
    stockService.reduce(order.getProductId());
    
    // 支付服务：扣款（跨数据库）
    payService.deduct(order.getAmount());
    
    // Seata自动协调分布式事务
}
```

---

## 9. ⚡ 事务性能优化


### 9.1 优化策略总览


**性能优化金字塔**
```
        🔺 最高优先级
       /  \
      / 减少 \
     / 事务范围 \
    /___________\
   /  批量操作   \
  /______________\
 /  合理隔离级别  \
/________________\
    连接池优化
```

### 9.2 减少事务范围


**🎯 核心原则：事务越短越好**

**❌ 不好的做法**
```java
@Transactional
public void processOrder(Order order) {
    // 1. 查询商品信息（只读，不需要事务）
    Product product = productService.getById(order.getProductId());
    
    // 2. 调用外部API（耗时，不需要事务）
    boolean result = externalService.validate(order);
    
    // 3. 复杂计算（耗时，不需要事务）
    double price = calculatePrice(product, order.getQuantity());
    
    // 4. 真正需要事务的操作
    orderMapper.insert(order);
    stockMapper.reduce(product.getId(), order.getQuantity());
}
// 整个方法都在事务中，持有连接时间过长！
```

**✅ 优化后**
```java
public void processOrder(Order order) {
    // 步骤1-3：不在事务中执行
    Product product = productService.getById(order.getProductId());
    boolean result = externalService.validate(order);
    double price = calculatePrice(product, order.getQuantity());
    
    // 只在必要时开启事务
    executeInTransaction(() -> {
        orderMapper.insert(order);
        stockMapper.reduce(product.getId(), order.getQuantity());
    });
}
// 事务范围缩小，性能提升！
```

### 9.3 批量操作优化


**🔸 批量插入对比**

**方式1：逐条插入（慢）**
```java
@Transactional
public void importUsers(List<User> users) {
    for (User user : users) {
        userMapper.insert(user); // 每次都是单条SQL
    }
    // 1000条数据 = 1000次数据库交互
}
```

**方式2：批量插入（快）**
```java
@Transactional
public void importUsers(List<User> users) {
    userMapper.batchInsert(users); // 一次性插入
    // 1000条数据 = 1次数据库交互
}
```

**XML配置**
```xml
<insert id="batchInsert" parameterType="list">
    INSERT INTO user (name, age, email) VALUES
    <foreach collection="list" item="user" separator=",">
        (#{user.name}, #{user.age}, #{user.email})
    </foreach>
</insert>
```

**性能对比**
```
数据量：1000条
逐条插入：约 10-15秒
批量插入：约 0.5-1秒
性能提升：10-30倍 ⚡
```

### 9.4 选择合适的隔离级别


**性能与安全的平衡**

| 隔离级别 | 性能 | 并发问题 | 推荐场景 |
|---------|------|---------|---------|
| READ_UNCOMMITTED | ⭐⭐⭐⭐⭐ | 脏读/不可重复读/幻读 | 不推荐 |
| READ_COMMITTED | ⭐⭐⭐⭐ | 不可重复读/幻读 | 统计查询 |
| REPEATABLE_READ | ⭐⭐⭐ | 幻读 | 一般业务 |
| SERIALIZABLE | ⭐ | 无 | 金融交易 |

**🎯 选择建议**
```
非关键业务：READ_COMMITTED（性能优先）
一般业务：REPEATABLE_READ（平衡）
金融交易：SERIALIZABLE（安全优先）
```

### 9.5 连接池优化


**🔸 关键参数配置**

```properties
# 数据源配置（HikariCP示例）
spring.datasource.hikari.maximum-pool-size=20       # 最大连接数
spring.datasource.hikari.minimum-idle=5             # 最小空闲连接
spring.datasource.hikari.connection-timeout=30000   # 连接超时(ms)
spring.datasource.hikari.idle-timeout=600000        # 空闲超时(ms)
spring.datasource.hikari.max-lifetime=1800000       # 最大生命周期(ms)
```

**参数调优建议**
```
maximum-pool-size（最大连接数）：
计算公式：核心数 × 2 + 磁盘数
示例：8核 × 2 + 1 = 17，设置20

minimum-idle（最小空闲）：
建议：最大连接数的 25-50%
示例：20 × 0.25 = 5

connection-timeout：
建议：30秒（避免过长等待）
```

### 9.6 性能监控指标


**关键指标**
```
📊 事务耗时
平均：< 100ms
P99：< 500ms

📊 连接池使用率
正常：50-70%
告警：> 80%

📊 事务回滚率
正常：< 1%
告警：> 5%

📊 死锁次数
正常：0
告警：> 0
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 事务本质：要么全做要么全不做，保证数据一致性
🔸 ACID特性：原子性、一致性、隔离性、持久性
🔸 两种管理器：JDBC（自己管）、MANAGED（容器管）
🔸 隔离级别：解决并发问题，平衡性能与安全
🔸 传播行为：方法调用时事务如何传递（Spring特性）
🔸 回滚机制：异常时撤销所有操作
🔸 分布式事务：跨系统事务，需要特殊方案
🔸 性能优化：缩小事务范围、批量操作、连接池
```

### 10.2 使用场景速查


**🎯 选择JDBC还是MANAGED？**
```
✅ JDBC适用：
• 单独使用MyBatis
• 小型项目
• 需要精确控制事务

✅ MANAGED适用：
• 集成Spring
• 企业级应用
• 需要声明式事务
```

**🎯 选择合适的隔离级别**
```
READ_COMMITTED：
• 统计报表
• 非严格查询
• Oracle环境

REPEATABLE_READ：
• 一般业务
• 订单处理
• MySQL环境

SERIALIZABLE：
• 金融交易
• 账务处理
• 严格一致性要求
```

### 10.3 最佳实践检查清单


**✅ 事务控制**
- [ ] 关闭自动提交（openSession()）
- [ ] 正确使用try-catch-finally
- [ ] 异常时必须rollback
- [ ] 成功时必须commit
- [ ] 完成后必须close

**✅ 性能优化**
- [ ] 缩小事务范围
- [ ] 使用批量操作
- [ ] 选择合适隔离级别
- [ ] 配置连接池参数
- [ ] 监控事务性能

**✅ 异常处理**
- [ ] 捕获所有异常
- [ ] 记录日志
- [ ] 不吞掉异常
- [ ] 及时回滚
- [ ] 释放资源

### 10.4 常见错误及解决


**❌ 错误1：忘记提交**
```java
// 问题代码
SqlSession session = sqlSessionFactory.openSession();
mapper.insert(user);
session.close(); // 数据丢失！

// 解决方案
session.commit(); // 先提交
session.close();  // 再关闭
```

**❌ 错误2：事务范围过大**
```java
// 问题代码
@Transactional
public void process() {
    doQuery();        // 只读，不需要事务
    callExternalAPI(); // 外部调用，慢
    doUpdate();       // 真正需要事务的
}

// 解决方案：只在必要时使用事务
public void process() {
    doQuery();
    callExternalAPI();
    executeInTransaction(() -> doUpdate());
}
```

**❌ 错误3：隔离级别过高**
```java
// 问题代码：查询用了SERIALIZABLE
@Transactional(isolation = Isolation.SERIALIZABLE)
public List<User> queryUsers() {
    return userMapper.selectAll(); // 性能很差
}

// 解决方案：查询用READ_COMMITTED
@Transactional(isolation = Isolation.READ_COMMITTED)
public List<User> queryUsers() {
    return userMapper.selectAll();
}
```

### 10.5 核心记忆口诀


```
🎯 事务要记牢：
事务保一致，要么全做要么停
JDBC自己管，MANAGED交容器
隔离分四级，按需选合适
传播看场景，Spring来帮忙
异常必回滚，成功才提交
分布式复杂，方案要选好
性能要优化，范围要缩小

🔑 关键步骤：
开启 → 执行 → 检查 → 提交/回滚 → 关闭
```

### 10.6 进阶学习路径


**📚 学习建议**
```
基础阶段（1-2周）：
✅ 理解事务概念和ACID
✅ 掌握JDBC事务管理
✅ 熟悉手动控制流程

进阶阶段（2-3周）：
✅ 学习隔离级别应用
✅ 掌握Spring声明式事务
✅ 理解传播行为

高级阶段（1个月）：
✅ 分布式事务方案
✅ 性能优化技巧
✅ 生产问题排查
```

---

**🎓 学习检验**
```
完成以下任务，检验学习效果：

任务1：实现用户注册事务
• 插入用户信息
• 创建账户
• 分配角色
• 要求：任何失败都回滚

任务2：优化批量导入
• 1000条数据批量插入
• 对比逐条和批量性能
• 统计耗时差异

任务3：处理分布式场景
• 设计订单-库存-支付流程
• 选择合适的分布式事务方案
• 实现最终一致性
```

**核心要点**：事务管理是数据一致性的保障，理解原理比记忆配置更重要，实践是最好的学习方式！