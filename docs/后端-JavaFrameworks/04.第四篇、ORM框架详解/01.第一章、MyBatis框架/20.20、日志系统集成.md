---
title: 20、日志系统集成
---
## 📚 目录

1. [什么是日志系统](#1-什么是日志系统)
2. [MyBatis的日志门面适配](#2-MyBatis的日志门面适配)
3. [常用日志框架集成](#3-常用日志框架集成)
4. [SQL日志输出与配置](#4-SQL日志输出与配置)
5. [日志级别与调试技巧](#5-日志级别与调试技巧)
6. [性能日志监控](#6-性能日志监控)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📝 什么是日志系统


### 1.1 日志的作用


**通俗理解**：日志就像程序的"行车记录仪"，记录程序运行过程中发生的各种事件。

```
现实场景类比：
┌─────────────────┐         ┌─────────────────┐
│   开车时        │         │   程序运行时     │
├─────────────────┤         ├─────────────────┤
│ 行车记录仪记录  │   →     │ 日志系统记录     │
│ • 行驶路线      │         │ • SQL执行语句    │
│ • 速度变化      │         │ • 参数值         │
│ • 异常情况      │         │ • 错误信息       │
└─────────────────┘         └─────────────────┘
```

**日志的核心价值**：
- 🔍 **问题排查** - 出错时能看到详细信息
- 📊 **运行监控** - 了解程序运行状态
- 🐛 **调试辅助** - 开发时查看执行流程
- 📈 **性能分析** - 发现性能瓶颈

### 1.2 为什么MyBatis需要日志


**实际问题场景**：

```java
// 执行了一个查询，但结果不对
User user = userMapper.selectById(1);

❓ 疑问：
• SQL到底是怎么执行的？
• 传入的参数值对不对？
• 返回了什么结果？
• 执行用了多长时间？
```

**有日志后的效果**：

```
==> Preparing: SELECT * FROM user WHERE id = ?
==> Parameters: 1(Integer)
<== Total: 1
<== Result: User{id=1, name='张三', age=20}
<== Time: 23ms

💡 一目了然：SQL语句、参数、结果、耗时全部可见
```

### 1.3 日志系统的基本概念


**三个核心角色**：

```
程序代码                日志门面                日志实现
   │                      │                      │
   │ ──写日志──>          │                      │
   │         logger.info()│                      │
   │                      │ ──转发──>            │
   │                      │                      │ 实际写文件
   │                      │                      │ 或控制台

示例说明：
• 程序代码：你的MyBatis代码
• 日志门面：统一的接口（如SLF4J）
• 日志实现：具体的日志框架（如Log4j2、Logback）
```

**为什么要分门面和实现？**

> **类比理解**：就像你用遥控器（门面）控制电视，换个品牌的电视（实现）不用换遥控器

- ✅ **代码解耦** - 换日志框架不用改代码
- ✅ **统一接口** - 所有框架用同样的方式写日志
- ✅ **灵活切换** - 可以随时更换底层日志实现

---

## 2. 🔌 MyBatis的日志门面适配


### 2.1 日志适配器机制


**核心设计思想**：MyBatis不绑定任何具体日志框架，而是提供适配层

```
MyBatis日志适配结构：

MyBatis核心代码
      │
      ├── Log接口（自己定义）
      │        │
      │        ├─> SLF4J适配器 ──> SLF4J
      │        ├─> Log4j2适配器 ──> Log4j2
      │        ├─> Logback适配器 ──> Logback
      │        ├─> JUL适配器 ──> JDK日志
      │        └─> StdOut适配器 ──> 控制台输出

💡 MyBatis会自动检测并使用classpath中的日志框架
```

### 2.2 自动检测顺序


**MyBatis的日志框架查找优先级**：

```
优先级从高到低：
① SLF4J    ← 最常用，优先级最高
② Log4j2   ← Apache的新版本
③ Log4j    ← 老版本（已不推荐）
④ JUL      ← JDK自带
⑤ Commons Logging
⑥ StdOut   ← 默认控制台输出

查找流程：
if (存在SLF4J) {
    使用SLF4J适配器
} else if (存在Log4j2) {
    使用Log4j2适配器
} else if (...) {
    继续往下找
}
```

**实际配置示例**：

```xml
<!-- mybatis-config.xml -->
<settings>
    <!-- 手动指定日志实现，不依赖自动检测 -->
    <setting name="logImpl" value="SLF4J"/>
</settings>
```

**可选值对照表**：

| 配置值 | 对应框架 | 使用场景 |
|--------|----------|----------|
| `SLF4J` | SLF4J门面 | `推荐：标准做法` |
| `LOG4J2` | Log4j2 | `企业级应用` |
| `LOG4J` | Log4j1.x | `老项目维护` |
| `JDK_LOGGING` | JUL | `简单项目` |
| `STDOUT_LOGGING` | 控制台 | `快速调试` |
| `NO_LOGGING` | 无日志 | `生产环境关闭` |

### 2.3 适配器工作原理


**简化版工作流程**：

```
MyBatis执行SQL时：

1. MyBatis调用 → Log.debug("执行SQL...")
              ↓
2. 适配器转换 → slf4j.debug("执行SQL...")
              ↓
3. SLF4J路由 → Logback实际输出日志
              ↓
4. 日志文件  → [2025-09-23 10:30:15] DEBUG - 执行SQL...
```

---

## 3. 🔧 常用日志框架集成


### 3.1 SLF4J + Logback集成（推荐方案）


**为什么推荐这个组合？**

- ✅ **业界标准** - 90%的项目都用这个
- ✅ **性能优秀** - Logback比Log4j快
- ✅ **配置灵活** - 支持自动重载配置
- ✅ **Spring默认** - SpringBoot默认集成

**① 添加依赖**：

```xml
<!-- pom.xml -->
<dependencies>
    <!-- MyBatis -->
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.5.13</version>
    </dependency>
    
    <!-- SLF4J门面 -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.9</version>
    </dependency>
    
    <!-- Logback实现 -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.4.11</version>
    </dependency>
</dependencies>
```

**② 配置Logback**：

```xml
<!-- src/main/resources/logback.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- 日志格式：时间 级别 类名 - 消息 -->
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- MyBatis SQL日志 -->
    <logger name="com.example.mapper" level="DEBUG"/>
    
    <!-- 根日志级别 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

**格式说明**：

| 占位符 | 含义 | 示例 |
|--------|------|------|
| `%d{HH:mm:ss.SSS}` | 时间 | `14:30:25.123` |
| `%thread` | 线程名 | `main` |
| `%-5level` | 日志级别 | `DEBUG` |
| `%logger{36}` | 日志名称 | `com.example.UserMapper` |
| `%msg` | 日志消息 | `执行SQL语句` |

### 3.2 SLF4J + Log4j2集成


**适用场景**：需要更复杂的日志处理（异步、路由等）

**① 添加依赖**：

```xml
<!-- Log4j2核心 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.20.0</version>
</dependency>

<!-- Log4j2的SLF4J桥接 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j2-impl</artifactId>
    <version>2.20.0</version>
</dependency>
```

**② 配置Log4j2**：

```xml
<!-- src/main/resources/log4j2.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n"/>
        </Console>
        
        <!-- 文件输出 -->
        <File name="File" fileName="logs/mybatis.log">
            <PatternLayout pattern="%d %p %c{1.} - %m%n"/>
        </File>
    </Appenders>
    
    <Loggers>
        <!-- MyBatis SQL日志 -->
        <Logger name="com.example.mapper" level="debug"/>
        
        <Root level="info">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="File"/>
        </Root>
    </Loggers>
</Configuration>
```

### 3.3 使用JDK自带日志（JUL）


**适用场景**：简单项目，不想引入额外依赖

**配置方式**：

```properties
# src/main/resources/logging.properties

# 根日志级别
.level=INFO

# 控制台处理器
handlers=java.util.logging.ConsoleHandler

# 控制台级别
java.util.logging.ConsoleHandler.level=ALL
java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter

# MyBatis SQL日志
com.example.mapper.level=FINE

# 日志格式
java.util.logging.SimpleFormatter.format=%1$tF %1$tT %4$s %2$s - %5$s%6$s%n
```

**MyBatis配置**：

```xml
<settings>
    <setting name="logImpl" value="JDK_LOGGING"/>
</settings>
```

---

## 4. 🔍 SQL日志输出与配置


### 4.1 SQL日志的层次结构


**MyBatis日志包名规则**：

```
日志层次结构：
com.example.mapper               ← Mapper接口包
    │
    ├── UserMapper               ← 具体Mapper
    │   ├── selectById           ← 具体方法
    │   ├── updateUser
    │   └── deleteUser
    │
    └── OrderMapper
        ├── selectByUserId
        └── insertOrder

日志配置映射：
• com.example.mapper             → 所有Mapper日志
• com.example.mapper.UserMapper  → UserMapper的日志
• com.example.mapper.UserMapper.selectById → 单个方法日志
```

### 4.2 日志级别详解


**日志级别从低到高**：

```
TRACE ← 最详细（跟踪级别）
  │
DEBUG ← SQL语句和参数（调试级别）★ 开发常用
  │
INFO  ← 一般信息（信息级别）
  │
WARN  ← 警告信息（警告级别）
  │
ERROR ← 错误信息（错误级别）★ 生产常用
  │
FATAL ← 致命错误（严重级别）
```

**不同级别输出的内容**：

| 级别 | MyBatis输出内容 | 使用场景 |
|------|----------------|----------|
| `TRACE` | 完整的JDBC调用细节 | `深度调试` |
| `DEBUG` | SQL语句、参数、结果 | `开发阶段` ⭐ |
| `INFO` | 无SQL日志 | `生产环境` |
| `WARN` | 警告信息 | `监控异常` |
| `ERROR` | 错误异常 | `故障排查` |

### 4.3 SQL日志输出示例


**完整的SQL执行日志**：

```
①准备阶段
==>  Preparing: SELECT * FROM user WHERE id = ? AND status = ?

②参数绑定
==> Parameters: 1(Integer), 1(Integer)

③执行结果
<==      Total: 1

④返回数据（可选）
<==     Result: User{id=1, name='张三', age=20, status=1}

⑤执行时间（需要配置）
<==       Time: 15ms
```

**日志解读**：

- `==>` **箭头向右** - 发送到数据库的内容
- `<==` **箭头向左** - 从数据库返回的内容
- `Preparing` - SQL预编译语句（带`?`占位符）
- `Parameters` - 实际的参数值（带类型）
- `Total` - 影响的行数
- `Result` - 查询的结果对象

### 4.4 参数日志打印配置


**配置参数详细输出**：

```xml
<!-- logback.xml -->
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- 彩色输出（可选） -->
            <pattern>%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 不同级别配置 -->
    
    <!-- 方式1：所有Mapper都DEBUG -->
    <logger name="com.example.mapper" level="DEBUG"/>
    
    <!-- 方式2：只看UserMapper的日志 -->
    <logger name="com.example.mapper.UserMapper" level="DEBUG"/>
    
    <!-- 方式3：只看某个方法的日志 -->
    <logger name="com.example.mapper.UserMapper.selectById" level="DEBUG"/>
    
    <!-- 方式4：关闭某个Mapper的SQL日志 -->
    <logger name="com.example.mapper.OrderMapper" level="INFO"/>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

**实际效果对比**：

```java
// 执行代码
User user = userMapper.selectById(1);

// ✅ DEBUG级别输出：
==> Preparing: SELECT * FROM user WHERE id = ?
==> Parameters: 1(Integer)
<== Total: 1

// ❌ INFO级别输出：
（无SQL日志，只有应用日志）
```

---

## 5. 📊 日志级别与调试技巧


### 5.1 开发环境配置


**推荐的开发环境日志配置**：

```xml
<!-- logback.xml - 开发环境 -->
<configuration>
    <!-- 控制台彩色输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{35}) - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>
    
    <!-- 核心Mapper日志：DEBUG -->
    <logger name="com.example.mapper" level="DEBUG"/>
    
    <!-- Spring框架：INFO -->
    <logger name="org.springframework" level="INFO"/>
    
    <!-- MyBatis内部日志：WARN -->
    <logger name="org.apache.ibatis" level="WARN"/>
    
    <!-- 根日志：INFO -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

**配置说明**：

- 🔸 **Mapper层DEBUG** - 看到所有SQL执行细节
- 🔸 **框架层INFO** - 不被框架日志干扰
- 🔸 **MyBatis内部WARN** - 只看警告和错误

### 5.2 生产环境配置


**生产环境的日志策略**：

```xml
<!-- logback.xml - 生产环境 -->
<configuration>
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出（按日期滚动） -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/mybatis.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/mybatis-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 生产环境关闭SQL日志 -->
    <logger name="com.example.mapper" level="WARN"/>
    
    <!-- 只记录错误和警告 -->
    <root level="WARN">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

**为什么生产环境要关闭SQL日志？**

> ⚠️ **安全风险**：SQL日志可能包含敏感数据（用户密码、身份证等）
> 
> ⚡ **性能影响**：频繁的日志IO会影响系统性能
> 
> 💾 **磁盘占用**：大量SQL日志会快速占满磁盘空间

### 5.3 调试技巧


**技巧1：临时开启SQL日志**

```xml
<!-- 方式1：配置文件（需重启） -->
<logger name="com.example.mapper.UserMapper" level="DEBUG"/>

<!-- 方式2：代码动态设置（不推荐） -->
```

```java
// 临时调试某个方法
import org.apache.ibatis.logging.LogFactory;

// 设置使用控制台日志
LogFactory.useStdOutLogging();

// 执行需要调试的代码
User user = userMapper.selectById(1);
```

**技巧2：定位慢SQL**

```xml
<!-- logback.xml -->
<!-- 添加执行时间记录 -->
<logger name="com.example.mapper" level="DEBUG"/>

<!-- 配合MyBatis拦截器使用（见性能监控章节） -->
```

**技巧3：过滤特定SQL**

```xml
<!-- 只看UPDATE和DELETE操作 -->
<configuration>
    <appender name="SQL_CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%msg%n</pattern>
        </encoder>
        <!-- 过滤器：只显示包含UPDATE或DELETE的日志 -->
        <filter class="ch.qos.logback.core.filter.EvaluatorFilter">
            <evaluator>
                <expression>message.contains("UPDATE") || message.contains("DELETE")</expression>
            </evaluator>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
</configuration>
```

**技巧4：查看完整的JDBC日志**

```xml
<!-- 开启TRACE级别，查看Connection、Statement细节 -->
<logger name="java.sql.Connection" level="TRACE"/>
<logger name="java.sql.Statement" level="TRACE"/>
<logger name="java.sql.PreparedStatement" level="TRACE"/>
<logger name="java.sql.ResultSet" level="TRACE"/>
```

**TRACE级别输出示例**：

```
[TRACE] Connection - ooo Connection Opened
[TRACE] PreparedStatement - ==> Preparing: SELECT * FROM user WHERE id = ?
[TRACE] PreparedStatement - ==> Parameters: 1(Integer)
[TRACE] ResultSet - <== Header: id, name, age
[TRACE] ResultSet - <== Row: 1, 张三, 20
[TRACE] Connection - xxx Connection Closed
```

---

## 6. ⚡ 性能日志监控


### 6.1 慢SQL监控


**为什么需要监控慢SQL？**

```
性能瓶颈分析：
┌─────────────┐
│  用户请求    │
└──────┬──────┘
       │ 100ms总耗时
       ├─ 业务逻辑: 5ms
       ├─ SQL执行: 90ms  ← 慢SQL是主要瓶颈！
       └─ 数据渲染: 5ms
```

**实现慢SQL日志**：

```java
// 自定义MyBatis拦截器
@Intercepts({
    @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),
    @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
public class SlowSqlInterceptor implements Interceptor {
    
    private static final Logger logger = LoggerFactory.getLogger(SlowSqlInterceptor.class);
    private static final long SLOW_SQL_THRESHOLD = 1000; // 1秒阈值
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        // 执行SQL
        Object result = invocation.proceed();
        
        long endTime = System.currentTimeMillis();
        long costTime = endTime - startTime;
        
        // 超过阈值记录慢SQL
        if (costTime > SLOW_SQL_THRESHOLD) {
            MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
            logger.warn("⚠️ 慢SQL警告 - 方法:{}, 耗时:{}ms", ms.getId(), costTime);
        }
        
        return result;
    }
}
```

**注册拦截器**：

```xml
<!-- mybatis-config.xml -->
<plugins>
    <plugin interceptor="com.example.interceptor.SlowSqlInterceptor"/>
</plugins>
```

**慢SQL日志输出示例**：

```
⚠️ 慢SQL警告 - 方法:com.example.mapper.UserMapper.selectList, 耗时:1523ms
==> Preparing: SELECT * FROM user WHERE status = ?
==> Parameters: 1(Integer)
<== Total: 50000

💡 建议：检查索引、优化SQL、考虑分页
```

### 6.2 SQL执行统计


**统计SQL执行次数和总耗时**：

```java
@Intercepts({
    @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
public class SqlStatInterceptor implements Interceptor {
    
    // 统计数据：<SQL ID, <执行次数, 总耗时>>
    private static final Map<String, long[]> sqlStats = new ConcurrentHashMap<>();
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = invocation.proceed();
        long cost = System.currentTimeMillis() - start;
        
        MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
        String sqlId = ms.getId();
        
        // 更新统计
        sqlStats.compute(sqlId, (k, v) -> {
            if (v == null) v = new long[]{0, 0};
            v[0]++; // 次数+1
            v[1] += cost; // 累加耗时
            return v;
        });
        
        return result;
    }
    
    // 定时输出统计报告（可配合定时任务）
    public static void printStats() {
        System.out.println("\n📊 SQL执行统计报告:");
        sqlStats.forEach((sql, stat) -> {
            System.out.printf("SQL: %s\n  执行次数: %d, 总耗时: %dms, 平均耗时: %dms\n", 
                sql, stat[0], stat[1], stat[1]/stat[0]);
        });
    }
}
```

**统计报告示例**：

```
📊 SQL执行统计报告:
SQL: com.example.mapper.UserMapper.selectById
  执行次数: 1500, 总耗时: 3200ms, 平均耗时: 2ms

SQL: com.example.mapper.OrderMapper.selectByUserId  
  执行次数: 800, 总耗时: 25000ms, 平均耗时: 31ms ⚠️

SQL: com.example.mapper.ProductMapper.selectList
  执行次数: 200, 总耗时: 1500ms, 平均耗时: 7ms

💡 发现：OrderMapper.selectByUserId 平均耗时较高，需要优化
```

### 6.3 日志性能优化建议


**优化策略对照**：

| 场景 | 问题 | 解决方案 |
|------|------|----------|
| `频繁IO` | 日志写入太慢 | `使用异步日志` ⭐ |
| `日志太多` | 磁盘占满 | `配置日志滚动和清理` |
| `影响性能` | 日志拖慢系统 | `生产环境降低日志级别` |
| `查找困难` | 日志太分散 | `统一日志收集（ELK）` |

**异步日志配置**：

```xml
<!-- logback.xml - 异步输出 -->
<configuration>
    <!-- 同步Appender -->
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <file>logs/mybatis.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 异步Appender包装 -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
    
    <logger name="com.example.mapper" level="DEBUG">
        <appender-ref ref="ASYNC_FILE"/>
    </logger>
</configuration>
```

**性能提升效果**：

```
同步日志：
写日志 → 等待磁盘IO → 继续执行 ❌ 阻塞影响性能

异步日志：  
写日志 → 放入队列 → 立即继续执行 ✅ 不阻塞
         ↓
      后台线程写磁盘

性能提升：减少50-80%的日志耗时
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 日志系统 = 日志门面 + 日志实现
   • 门面：统一接口（SLF4J）
   • 实现：具体框架（Logback、Log4j2）
   
🔸 MyBatis日志适配器
   • 自动检测classpath中的日志框架
   • 优先级：SLF4J > Log4j2 > JUL > StdOut
   
🔸 SQL日志输出
   • DEBUG级别：看到SQL、参数、结果
   • 配置Mapper包名控制日志范围
   
🔸 日志级别配置
   • 开发：DEBUG（看SQL细节）
   • 生产：WARN/ERROR（只看问题）
```

### 7.2 关键理解要点


**🔹 日志门面的价值**

```
为什么要用SLF4J？

代码层面：
logger.info("用户登录");  // 永远不变

底层切换：
Logback → Log4j2 → JUL  // 只换依赖包，代码不动

好处：解耦、灵活、统一
```

**🔹 日志级别的选择**

```
开发环境：
• Mapper包：DEBUG ← 看SQL执行
• 框架包：INFO ← 不被干扰
• 根日志：INFO

生产环境：
• Mapper包：WARN/ERROR ← 关闭SQL
• 所有包：WARN/ERROR ← 只看问题
• 敏感信息：脱敏处理
```

**🔹 性能监控的要点**

```
监控目标：
① 慢SQL：超过阈值的SQL
② 频繁SQL：执行次数异常多
③ 异常SQL：报错的SQL

实现方式：
• 拦截器 + 日志 ← 简单直接
• 监控平台（Skywalking）← 企业级
```

### 7.3 实际应用指导


**场景1：开发调试**

```xml
<!-- 快速开启SQL日志 -->
<logger name="你的Mapper包名" level="DEBUG"/>

效果：
==> Preparing: SELECT * FROM user WHERE id = ?
==> Parameters: 1(Integer)
<== Total: 1
```

**场景2：生产问题排查**

```xml
<!-- 临时开启DEBUG，定位问题后关闭 -->
<logger name="com.example.mapper.UserMapper" level="DEBUG"/>

步骤：
1. 修改配置文件
2. 重启应用（或热加载）
3. 复现问题，查看日志
4. 定位后改回WARN
```

**场景3：性能优化**

```java
// 使用慢SQL拦截器
1. 配置阈值：1000ms
2. 自动记录慢SQL
3. 分析优化：加索引、改SQL、分表
```

**核心记忆口诀**：

```
日志门面做接口，实现框架随便换
MyBatis自动检测，SLF4J优先选
开发DEBUG看细节，生产WARN保安全
慢SQL监控要做好，性能优化有保障
```

**实战建议**：

- ✅ **统一使用SLF4J + Logback组合**
- ✅ **开发环境DEBUG，生产环境WARN**
- ✅ **配置日志滚动，防止磁盘占满**
- ✅ **敏感信息脱敏，不记录到日志**
- ✅ **使用异步日志，减少性能影响**
- ✅ **监控慢SQL，及时优化性能**