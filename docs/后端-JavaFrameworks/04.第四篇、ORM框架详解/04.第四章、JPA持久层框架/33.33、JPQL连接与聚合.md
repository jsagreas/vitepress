---
title: 33、JPQL连接与聚合
---
## 📚 目录

1. [连接查询基础](#1-连接查询基础)
2. [JOIN内连接详解](#2-JOIN内连接详解)
3. [LEFT JOIN左外连接](#3-LEFT-JOIN左外连接)
4. [RIGHT JOIN右外连接](#4-RIGHT-JOIN右外连接)
5. [FETCH JOIN抓取连接](#5-FETCH-JOIN抓取连接)
6. [聚合函数应用](#6-聚合函数应用)
7. [GROUP BY分组查询](#7-GROUP-BY分组查询)
8. [HAVING分组过滤](#8-HAVING分组过滤)
9. [DISTINCT去重操作](#9-DISTINCT去重操作)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔗 连接查询基础


### 1.1 什么是连接查询


**通俗理解**：连接查询就是把多张表的数据关联起来一起查询

```
现实场景：
你想查询"订单信息和对应的客户姓名"

单表查询：只能查到订单表的客户ID
连接查询：可以同时获取订单信息和客户姓名

就像把两张纸上的信息，通过共同的标记（ID）拼接在一起看
```

### 1.2 为什么需要连接查询


**实际问题**：
```
订单表（Order）              客户表（Customer）
+----+--------+-------+      +----+----------+
| id | amount | custId|      | id | name     |
+----+--------+-------+      +----+----------+
| 1  | 100    | 101   | ---> | 101| 张三     |
| 2  | 200    | 102   | ---> | 102| 李四     |
+----+--------+-------+      +----+----------+

需求：查询订单金额和客户姓名
如果不用连接，需要：
1. 先查订单得到custId
2. 再用custId查客户表
3. 手动拼接结果

用连接查询：一次性搞定！
```

### 1.3 JPQL连接的特点


**核心特点**：
- 🔸 **基于对象关系**：通过实体类的关联字段连接，不是直接写表名
- 🔸 **自动处理外键**：JPA自动识别关联关系，无需手动指定JOIN条件
- 🔸 **类型安全**：编译期就能检查字段是否存在

**与SQL对比**：
```java
// SQL写法（传统数据库查询）
SELECT o.*, c.name 
FROM orders o 
JOIN customers c ON o.customer_id = c.id

// JPQL写法（面向对象查询）
SELECT o, c.name 
FROM Order o 
JOIN o.customer c
// 注意：JOIN后面跟的是对象的属性，不是表名！
```

---

## 2. ⚡ JOIN内连接详解


### 2.1 内连接的含义


**简单理解**：只查询两边都有匹配数据的记录

```
订单表                客户表
订单1 - 客户A  <-匹配->  客户A
订单2 - 客户B  <-匹配->  客户B
订单3 - 客户C  <-没客户->  客户C

内连接结果：只返回订单1和订单2（都能找到对应客户）
订单3因为客户不存在，不会出现在结果中
```

### 2.2 基本语法


**标准格式**：
```java
// 格式：FROM 主实体 别名 JOIN 主实体.关联属性 关联别名
SELECT o FROM Order o JOIN o.customer c

// 解读：
// Order o - 订单实体，别名o
// o.customer - 订单对象的customer属性（关联字段）
// c - 给关联的客户实体起的别名
```

### 2.3 实际应用示例


**示例1：查询订单及其客户信息**
```java
// 实体类定义
@Entity
public class Order {
    @Id
    private Long id;
    private Double amount;
    
    @ManyToOne  // 多个订单对应一个客户
    private Customer customer;
}

@Entity
public class Customer {
    @Id
    private Long id;
    private String name;
}

// JPQL查询
String jpql = "SELECT o FROM Order o JOIN o.customer c WHERE c.name = :name";
List<Order> orders = em.createQuery(jpql, Order.class)
    .setParameter("name", "张三")
    .getResultList();
```

**示例2：同时获取订单和客户数据**
```java
// 查询并返回订单和客户名称
String jpql = "SELECT o.id, o.amount, c.name FROM Order o JOIN o.customer c";
List<Object[]> results = em.createQuery(jpql).getResultList();

for (Object[] row : results) {
    Long orderId = (Long) row[0];
    Double amount = (Double) row[1];
    String customerName = (String) row[2];
    System.out.println("订单" + orderId + "，金额" + amount + "，客户" + customerName);
}
```

### 2.4 多层连接


**场景：订单→客户→地址**
```java
// 实体关系
Order -> Customer -> Address

// JPQL多层连接
String jpql = "SELECT o FROM Order o " +
              "JOIN o.customer c " +
              "JOIN c.address a " +
              "WHERE a.city = '北京'";

// 查询北京地区客户的所有订单
```

---

## 3. 🔄 LEFT JOIN左外连接


### 3.1 左外连接的含义


**通俗解释**：以左边表为主，即使右边没匹配也显示左边的数据

```
订单表（左）              客户表（右）
订单1 - 客户A  <-匹配->  客户A ✓
订单2 - 客户B  <-匹配->  客户B ✓
订单3 - null   <-无匹配->  (客户不存在)

左外连接结果：
订单1，客户A
订单2，客户B
订单3，null（订单保留，客户为空）
```

### 3.2 使用场景


**典型应用**：
- 🔸 **查询所有订单**，即使某些订单没有关联客户
- 🔸 **统计数据**：查询所有客户及其订单数（包括没下过订单的客户）
- 🔸 **数据完整性检查**：找出没有关联数据的记录

### 3.3 基本语法


```java
// 格式：LEFT JOIN 或 LEFT OUTER JOIN
SELECT o FROM Order o LEFT JOIN o.customer c

// 与内连接对比
// 内连接：SELECT o FROM Order o JOIN o.customer c
// 左外连接：SELECT o FROM Order o LEFT JOIN o.customer c
```

### 3.4 实战示例


**示例1：查询所有订单（包括客户已删除的订单）**
```java
String jpql = "SELECT o, c FROM Order o LEFT JOIN o.customer c";
List<Object[]> results = em.createQuery(jpql).getResultList();

for (Object[] row : results) {
    Order order = (Order) row[0];
    Customer customer = (Customer) row[1];
    
    if (customer == null) {
        System.out.println("订单" + order.getId() + "的客户已不存在");
    } else {
        System.out.println("订单" + order.getId() + "，客户" + customer.getName());
    }
}
```

**示例2：统计每个客户的订单数量（包括0个订单的客户）**
```java
String jpql = "SELECT c.name, COUNT(o.id) " +
              "FROM Customer c LEFT JOIN c.orders o " +
              "GROUP BY c.name";

List<Object[]> results = em.createQuery(jpql).getResultList();
// 结果：张三: 5个订单，李四: 0个订单
```

---

## 4. ↔️ RIGHT JOIN右外连接


### 4.1 右外连接的含义


**简单理解**：以右边表为主，即使左边没匹配也显示右边的数据

```
订单表（左）              客户表（右）
订单1 - 客户A  <-匹配->  客户A ✓
订单2 - 客户B  <-匹配->  客户B ✓
            <-无匹配->  客户C（从未下单）

右外连接结果：
订单1，客户A
订单2，客户B
null，客户C（客户保留，订单为空）
```

### 4.2 使用场景


**典型应用**：
- 🔸 **查询所有客户**，即使某些客户没有下过订单
- 🔸 **数据分析**：找出没有产生业务的客户

> ⚠️ **注意**：JPQL中RIGHT JOIN支持有限，很多JPA实现不支持，建议用LEFT JOIN替代

### 4.3 用LEFT JOIN替代RIGHT JOIN


```java
// RIGHT JOIN写法（不推荐）
SELECT o FROM Order o RIGHT JOIN o.customer c

// 等价的LEFT JOIN写法（推荐）
SELECT o FROM Customer c LEFT JOIN c.orders o
// 只需要调换主表和从表的位置即可
```

---

## 5. 🚀 FETCH JOIN抓取连接


### 5.1 什么是FETCH JOIN


**核心作用**：一次性把关联数据全部加载，避免N+1查询问题

**通俗理解**：
```
普通JOIN：只是条件关联，不会自动加载关联对象
FETCH JOIN：在查询时就把关联对象一起"抓取"回来

就像：
普通JOIN - 只拿到了"钥匙"（外键ID）
FETCH JOIN - 直接把"钥匙和对应的房子"一起拿回来
```

### 5.2 N+1查询问题


**问题演示**：
```java
// 不使用FETCH JOIN
String jpql = "SELECT o FROM Order o";
List<Order> orders = em.createQuery(jpql, Order.class).getResultList();

// 遍历订单，访问客户信息
for (Order order : orders) {
    System.out.println(order.getCustomer().getName()); // 每次都会发SQL！
}

// 执行的SQL：
// 1次：SELECT * FROM orders           （查询所有订单）
// N次：SELECT * FROM customers WHERE id = ?  （每个订单查一次客户）
// 如果有100个订单，就会执行101次SQL！
```

### 5.3 FETCH JOIN解决方案


**优化后的查询**：
```java
// 使用FETCH JOIN
String jpql = "SELECT o FROM Order o JOIN FETCH o.customer";
List<Order> orders = em.createQuery(jpql, Order.class).getResultList();

for (Order order : orders) {
    System.out.println(order.getCustomer().getName()); // 不会再发SQL
}

// 只执行1次SQL：
// SELECT o.*, c.* FROM orders o JOIN customers c ON o.customer_id = c.id
// 一次性把订单和客户都查出来
```

### 5.4 FETCH JOIN注意事项


**重要提醒**：

| 特性 | **说明** | **示例** |
|------|---------|---------|
| **不能分页** | `FETCH JOIN集合时无法使用setFirstResult/setMaxResults` | `会导致内存加载全部数据` |
| **不能多个集合** | `同时FETCH JOIN多个集合会产生笛卡尔积` | `应该分开查询或用@BatchSize` |
| **去重问题** | `JOIN集合时可能产生重复数据` | `需要使用DISTINCT关键字` |

**正确用法**：
```java
// ✓ 正确：抓取单个对象
SELECT o FROM Order o JOIN FETCH o.customer

// ✓ 正确：抓取一个集合
SELECT c FROM Customer c JOIN FETCH c.orders

// ✗ 错误：同时抓取多个集合
SELECT c FROM Customer c 
JOIN FETCH c.orders 
JOIN FETCH c.addresses  // 会产生笛卡尔积

// ✓ 解决：使用DISTINCT去重
SELECT DISTINCT c FROM Customer c JOIN FETCH c.orders
```

---

## 6. 📊 聚合函数应用


### 6.1 聚合函数概述


**作用**：对多行数据进行计算，返回单个结果

**常用聚合函数**：

| 函数 | **含义** | **返回类型** | **示例** |
|------|---------|-------------|---------|
| `COUNT()` | `统计数量` | `Long` | `COUNT(o.id)` |
| `SUM()` | `求和` | `Number` | `SUM(o.amount)` |
| `AVG()` | `平均值` | `Double` | `AVG(o.amount)` |
| `MAX()` | `最大值` | `与字段类型相同` | `MAX(o.amount)` |
| `MIN()` | `最小值` | `与字段类型相同` | `MIN(o.amount)` |

### 6.2 COUNT统计数量


**基本用法**：
```java
// 统计订单总数
String jpql = "SELECT COUNT(o) FROM Order o";
Long count = em.createQuery(jpql, Long.class).getSingleResult();

// 统计某个客户的订单数
String jpql = "SELECT COUNT(o) FROM Order o WHERE o.customer.id = :custId";
Long count = em.createQuery(jpql, Long.class)
    .setParameter("custId", 101L)
    .getSingleResult();
```

**COUNT的两种形式**：
```java
// COUNT(*) - 统计所有行（包括NULL）
SELECT COUNT(o) FROM Order o

// COUNT(字段) - 统计非NULL值
SELECT COUNT(o.remark) FROM Order o  // 只统计有备注的订单
```

### 6.3 SUM求和


```java
// 计算订单总金额
String jpql = "SELECT SUM(o.amount) FROM Order o";
Double total = em.createQuery(jpql, Double.class).getSingleResult();

// 计算某个客户的消费总额
String jpql = "SELECT SUM(o.amount) FROM Order o WHERE o.customer.id = :custId";
Double customerTotal = em.createQuery(jpql, Double.class)
    .setParameter("custId", 101L)
    .getSingleResult();
```

### 6.4 AVG平均值


```java
// 计算平均订单金额
String jpql = "SELECT AVG(o.amount) FROM Order o";
Double avgAmount = em.createQuery(jpql, Double.class).getSingleResult();

// 计算VIP客户的平均订单金额
String jpql = "SELECT AVG(o.amount) FROM Order o " +
              "WHERE o.customer.level = 'VIP'";
```

### 6.5 MAX和MIN


```java
// 查询最大和最小订单金额
String jpql = "SELECT MAX(o.amount), MIN(o.amount) FROM Order o";
Object[] result = em.createQuery(jpql).getSingleResult();
Double maxAmount = (Double) result[0];
Double minAmount = (Double) result[1];

// 查询最新订单日期
String jpql = "SELECT MAX(o.createTime) FROM Order o";
Date latestDate = em.createQuery(jpql, Date.class).getSingleResult();
```

---

## 7. 🗂️ GROUP BY分组查询


### 7.1 分组查询的含义


**通俗理解**：把数据按某个字段分类，然后对每一类进行统计

```
订单数据：
客户A - 订单1 - 100元
客户A - 订单2 - 200元
客户B - 订单3 - 150元
客户B - 订单4 - 300元

按客户分组后：
客户A组：订单1(100) + 订单2(200) = 2笔，300元
客户B组：订单3(150) + 订单4(300) = 2笔，450元
```

### 7.2 基本语法


```java
// 格式：SELECT 分组字段, 聚合函数 FROM 实体 GROUP BY 分组字段

// 示例：按客户统计订单数量
SELECT o.customer.id, COUNT(o) 
FROM Order o 
GROUP BY o.customer.id
```

### 7.3 实战应用


**示例1：统计每个客户的订单数量**
```java
String jpql = "SELECT c.name, COUNT(o) " +
              "FROM Order o JOIN o.customer c " +
              "GROUP BY c.id, c.name";

List<Object[]> results = em.createQuery(jpql).getResultList();
for (Object[] row : results) {
    String name = (String) row[0];
    Long count = (Long) row[1];
    System.out.println(name + "的订单数：" + count);
}
```

**示例2：统计每个客户的消费总额**
```java
String jpql = "SELECT c.name, SUM(o.amount) " +
              "FROM Order o JOIN o.customer c " +
              "GROUP BY c.id, c.name " +
              "ORDER BY SUM(o.amount) DESC";  // 按消费额降序

List<Object[]> results = em.createQuery(jpql).getResultList();
// 结果：张三: 5000元，李四: 3000元...
```

**示例3：按日期统计订单**
```java
// 按年月统计订单数量
String jpql = "SELECT YEAR(o.createTime), MONTH(o.createTime), COUNT(o) " +
              "FROM Order o " +
              "GROUP BY YEAR(o.createTime), MONTH(o.createTime)";
```

### 7.4 GROUP BY规则


> 📌 **重要规则**：SELECT中出现的非聚合字段，必须在GROUP BY中出现

```java
// ✓ 正确
SELECT c.name, COUNT(o) FROM Order o JOIN o.customer c GROUP BY c.name

// ✗ 错误：c.email没有在GROUP BY中
SELECT c.name, c.email, COUNT(o) FROM Order o JOIN o.customer c GROUP BY c.name

// ✓ 修正
SELECT c.name, c.email, COUNT(o) 
FROM Order o JOIN o.customer c 
GROUP BY c.name, c.email
```

---

## 8. 🔍 HAVING分组过滤


### 8.1 HAVING与WHERE的区别


**核心区别**：
- **WHERE**：在分组**之前**过滤，过滤的是原始数据行
- **HAVING**：在分组**之后**过滤，过滤的是分组结果

```
执行顺序：
1. FROM - 确定数据来源
2. WHERE - 过滤原始行
3. GROUP BY - 分组
4. HAVING - 过滤分组
5. SELECT - 选择字段
6. ORDER BY - 排序
```

### 8.2 使用场景对比


```java
// WHERE示例：先过滤再分组
// 查询2024年每个客户的订单数
SELECT c.name, COUNT(o) 
FROM Order o JOIN o.customer c 
WHERE YEAR(o.createTime) = 2024  // 先过滤出2024年的订单
GROUP BY c.name

// HAVING示例：先分组再过滤
// 查询订单数超过10的客户
SELECT c.name, COUNT(o) 
FROM Order o JOIN o.customer c 
GROUP BY c.name
HAVING COUNT(o) > 10  // 分组后过滤掉订单数≤10的
```

### 8.3 实战应用


**示例1：找出消费超过1万的客户**
```java
String jpql = "SELECT c.name, SUM(o.amount) " +
              "FROM Order o JOIN o.customer c " +
              "GROUP BY c.id, c.name " +
              "HAVING SUM(o.amount) > 10000";

List<Object[]> vipCustomers = em.createQuery(jpql).getResultList();
```

**示例2：找出只下过1次订单的客户**
```java
String jpql = "SELECT c.name, COUNT(o) " +
              "FROM Order o JOIN o.customer c " +
              "GROUP BY c.id, c.name " +
              "HAVING COUNT(o) = 1";
```

**示例3：WHERE和HAVING组合使用**
```java
// 查询2024年消费超过5000的客户
String jpql = "SELECT c.name, SUM(o.amount) " +
              "FROM Order o JOIN o.customer c " +
              "WHERE YEAR(o.createTime) = 2024 " +  // 先过滤年份
              "GROUP BY c.id, c.name " +
              "HAVING SUM(o.amount) > 5000";        // 再过滤金额
```

### 8.4 HAVING常见错误


```java
// ✗ 错误：HAVING中使用了未分组的字段
SELECT c.name, COUNT(o) 
FROM Order o JOIN o.customer c 
GROUP BY c.name
HAVING c.email LIKE '%@vip.com'  // email未在GROUP BY中

// ✓ 正确：应该放在WHERE中
SELECT c.name, COUNT(o) 
FROM Order o JOIN o.customer c 
WHERE c.email LIKE '%@vip.com'
GROUP BY c.name
```

---

## 9. ✨ DISTINCT去重操作


### 9.1 DISTINCT的作用


**通俗解释**：去除查询结果中的重复数据

```
原始数据：
订单1 - 客户A
订单2 - 客户A
订单3 - 客户B

不使用DISTINCT：客户A, 客户A, 客户B
使用DISTINCT：客户A, 客户B（客户A只出现一次）
```

### 9.2 基本用法


```java
// 查询所有下过订单的客户（不重复）
String jpql = "SELECT DISTINCT c FROM Order o JOIN o.customer c";
List<Customer> customers = em.createQuery(jpql, Customer.class)
    .getResultList();
```

### 9.3 DISTINCT在FETCH JOIN中的应用


**问题场景**：
```java
// 不使用DISTINCT
SELECT c FROM Customer c JOIN FETCH c.orders

// 如果客户A有3个订单，查询结果会返回3个客户A对象
// 结果：[客户A, 客户A, 客户A, 客户B, 客户B]
```

**解决方案**：
```java
// 使用DISTINCT去重
SELECT DISTINCT c FROM Customer c JOIN FETCH c.orders

// 结果：[客户A, 客户B]（每个客户只出现一次）
// 但客户A对象的orders集合中仍然包含3个订单
```

### 9.4 DISTINCT在聚合查询中


```java
// 统计下过订单的客户数量（去重）
String jpql = "SELECT COUNT(DISTINCT o.customer) FROM Order o";
Long customerCount = em.createQuery(jpql, Long.class).getSingleResult();

// 统计订单中涉及的不同城市数量
String jpql = "SELECT COUNT(DISTINCT c.address.city) " +
              "FROM Order o JOIN o.customer c";
```

### 9.5 多字段去重


```java
// 查询不同的客户-产品组合
String jpql = "SELECT DISTINCT o.customer, o.product " +
              "FROM Order o";

// 只有当customer和product都相同时，才认为是重复记录
```

---

## 10. 📋 核心要点总结


### 10.1 连接查询要点


**🔸 连接类型选择**：
- **JOIN（内连接）**：只要两边都有匹配的数据 → 用于必须关联的场景
- **LEFT JOIN（左外连接）**：保留左边所有数据 → 用于统计或数据完整性检查
- **FETCH JOIN（抓取连接）**：避免N+1问题 → 用于需要立即访问关联数据

**🔸 连接语法记忆**：
```java
// 标准格式
SELECT 主实体 FROM 主实体 别名 
[LEFT] JOIN [FETCH] 别名.关联属性 关联别名
WHERE 条件
```

### 10.2 聚合查询要点


**🔸 聚合函数使用**：

| 场景 | **函数** | **用法** |
|------|---------|---------|
| `统计数量` | `COUNT()` | `COUNT(o) 或 COUNT(o.id)` |
| `计算总和` | `SUM()` | `SUM(o.amount)` |
| `求平均值` | `AVG()` | `AVG(o.amount)` |
| `找最大值` | `MAX()` | `MAX(o.amount)` |
| `找最小值` | `MIN()` | `MIN(o.amount)` |

**🔸 分组查询规则**：
```
1. SELECT中的非聚合字段必须出现在GROUP BY中
2. WHERE在分组前过滤，HAVING在分组后过滤
3. 聚合函数只能在SELECT和HAVING中使用
```

### 10.3 常见陷阱与解决


**陷阱1：N+1查询问题**
```java
// ✗ 问题代码
for (Order o : orders) {
    o.getCustomer().getName();  // 每次循环都查数据库
}

// ✓ 解决方案
SELECT o FROM Order o JOIN FETCH o.customer
```

**陷阱2：FETCH JOIN分页失效**
```java
// ✗ 错误：FETCH JOIN集合时分页无效
SELECT c FROM Customer c JOIN FETCH c.orders
setFirstResult(0).setMaxResults(10);

// ✓ 解决：先查ID再FETCH
// 第一步：分页查ID
SELECT c.id FROM Customer c
// 第二步：根据ID FETCH
SELECT c FROM Customer c JOIN FETCH c.orders WHERE c.id IN :ids
```

**陷阱3：笛卡尔积问题**
```java
// ✗ 错误：同时FETCH多个集合
SELECT c FROM Customer c 
JOIN FETCH c.orders 
JOIN FETCH c.addresses

// ✓ 解决：分开查询或用@BatchSize注解
```

### 10.4 性能优化建议


**优化策略**：
- 🚀 **使用FETCH JOIN**：一次性加载关联数据，避免懒加载
- 🚀 **合理使用索引**：WHERE和JOIN的字段应该建立索引
- 🚀 **只查必要字段**：使用`SELECT c.id, c.name`而不是`SELECT c`
- 🚀 **分页优化**：大数据量时先查ID列表，再根据ID查详情

### 10.5 核心记忆口诀


```
连接查询看关系，内连交集左右全
抓取连接解N+1，一次加载不再懒
聚合函数做统计，COUNT SUM AVG配合玩
分组查询用GROUP BY，HAVING过滤在后边
去重操作DISTINCT，重复数据说再见
```

**关键理解**：
- JPQL连接基于**对象关系**，不是表关系
- FETCH JOIN是**性能优化**的关键武器
- 聚合查询要**先过滤后分组**，规则要记清
- 所有语法最终都会转成SQL，理解SQL有助于理解JPQL