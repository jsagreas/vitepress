---
title: 68、生产环境清单
---
## 📚 目录

1. [生产环境配置概述](#1-生产环境配置概述)
2. [数据库连接池配置](#2-数据库连接池配置)
3. [超时与重试机制](#3-超时与重试机制)
4. [死锁与并发控制](#4-死锁与并发控制)
5. [监控告警体系](#5-监控告警体系)
6. [安全配置检查](#6-安全配置检查)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🚀 生产环境配置概述


### 1.1 什么是生产环境


**通俗理解**：开发环境就像你在家里练习做菜，生产环境就是在餐厅给客人做菜。

```
开发环境（Development）：
- 程序员写代码、测试的地方
- 数据可以随便改，出错了重来
- 性能要求不高，调试方便就行

生产环境（Production）：
- 真实用户访问的环境
- 数据非常重要，不能丢失
- 性能要求高，必须稳定可靠
- 需要24小时不间断运行
```

### 1.2 为什么要特殊配置


**核心原因**：开发环境和生产环境的需求完全不同！

| 对比项 | **开发环境** | **生产环境** |
|-------|------------|-------------|
| 🎯 **目标** | `方便调试` | `稳定高效` |
| 👥 **用户量** | `1-10人` | `成千上万人` |
| 💾 **数据价值** | `测试数据` | `真实业务数据` |
| ⚡ **性能要求** | `能跑就行` | `毫秒级响应` |
| 🔒 **安全要求** | `无所谓` | `非常严格` |

### 1.3 配置核心原则


**🔸 稳定性第一**
```
宁可牺牲一点性能，也要保证系统稳定
比如：连接池小一点没关系，但绝不能用完崩溃
```

**🔸 可监控可追溯**
```
每个问题都要能找到原因
比如：详细的日志记录，性能指标收集
```

**🔸 故障自动恢复**
```
出问题了要能自动处理
比如：连接断了自动重连，死锁了自动回退
```

---

## 2. 💧 数据库连接池配置


### 2.1 连接池是什么


**简单比喻**：连接池就像停车场

```
没有连接池的情况：
用户访问 → 临时建立数据库连接（开车进停车场）
处理完成 → 断开连接（开车离开）
下次访问 → 又要重新建立连接（又开车进来）
❌ 问题：每次都要"开车进出"，太慢了！

有连接池的情况：
提前准备好10个连接（停车场有10个车位）
用户访问 → 直接用现成的连接（车已经停好了）
处理完成 → 连接放回池子（车还停着，下次继续用）
✅ 优势：不用反复"开车进出"，速度快多了！
```

### 2.2 核心参数配置


#### 📊 最小连接数（Minimum Pool Size）


**含义**：连接池里至少保持几个连接

```yaml
# application-prod.yml（生产环境配置）
spring:
  datasource:
    hikari:  # HikariCP连接池
      minimum-idle: 10  # 最少保持10个空闲连接
```

**🎯 配置建议**：
- **小网站**：5-10个就够了
- **中等网站**：10-20个
- **大网站**：20-50个

💡 **新手理解**：就像停车场至少要留几个空车位，随时有车来能停

#### 📊 最大连接数（Maximum Pool Size）


**含义**：连接池最多能有几个连接

```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 50  # 最多50个连接
```

**⚠️ 重要原则**：
```
数据库能承受的连接数 ÷ 应用服务器数量 = 每台服务器的最大连接数

例如：
数据库最多200个连接
有4台应用服务器
每台配置：200 ÷ 4 = 50个最大连接
```

#### ⏱️ 连接超时（Connection Timeout）


**含义**：等待获取连接的最长时间

```yaml
spring:
  datasource:
    hikari:
      connection-timeout: 30000  # 30秒（单位毫秒）
```

**通俗解释**：
```
用户请求来了 → 去连接池拿连接
如果连接都被占用了 → 等待有人归还
等了30秒还没拿到 → 报错"获取连接超时"
```

**🔥 生产建议**：设置20-30秒，太短容易误报，太长用户等不了

#### 🔄 连接存活时间


**含义**：一个连接最多用多久就要销毁重建

```yaml
spring:
  datasource:
    hikari:
      max-lifetime: 1800000  # 30分钟（单位毫秒）
```

**为什么要重建**：
```
数据库可能会主动断开长时间不用的连接
连接用久了可能有问题（内存泄漏等）
定期重建保证连接质量
```

### 2.3 完整配置示例


```yaml
# 生产环境完整连接池配置
spring:
  datasource:
    url: jdbc:mysql://db.example.com:3306/myapp
    username: app_user
    password: ${DB_PASSWORD}  # 从环境变量读取，安全
    
    hikari:
      # 连接数配置
      minimum-idle: 10           # 最少10个空闲连接
      maximum-pool-size: 50      # 最多50个连接
      
      # 超时配置
      connection-timeout: 30000  # 获取连接超时30秒
      idle-timeout: 600000       # 空闲连接10分钟后回收
      max-lifetime: 1800000      # 连接最多存活30分钟
      
      # 连接测试
      connection-test-query: SELECT 1  # 测试连接是否有效
      
      # 其他优化
      auto-commit: true          # 自动提交事务
      pool-name: MyAppHikariCP   # 连接池名称，方便监控
```

**📋 参数速查表**：

| 参数 | **建议值** | **作用** | **调整方向** |
|------|----------|---------|------------|
| `minimum-idle` | `10-20` | `保证响应速度` | `并发高→调大` |
| `maximum-pool-size` | `30-100` | `控制资源占用` | `数据库压力大→调小` |
| `connection-timeout` | `20000-30000` | `防止无限等待` | `快速失败→调小` |
| `max-lifetime` | `1800000` | `定期刷新连接` | `数据库超时短→调小` |

---

## 3. ⏰ 超时与重试机制


### 3.1 为什么需要超时控制


**现实场景**：
```
用户点击"提交订单" → 数据库响应慢
没有超时机制 → 用户一直等，页面卡死
有超时机制 → 5秒后提示"系统繁忙，请稍后重试"
```

**🎯 超时的好处**：
- ✅ 避免用户无限等待
- ✅ 释放系统资源
- ✅ 快速发现问题

### 3.2 JPA查询超时


#### 🔸 全局超时配置


```yaml
spring:
  jpa:
    properties:
      javax.persistence.query.timeout: 5000  # 查询5秒超时
```

**含义**：所有数据库查询，超过5秒就中断

#### 🔸 单独方法超时


```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // 这个查询比较慢，给它更长的超时时间
    @QueryHints(@QueryHint(
        name = "javax.persistence.query.timeout", 
        value = "10000"  // 10秒超时
    ))
    List<Order> findComplexOrders();
    
    // 快速查询，短超时
    @QueryHints(@QueryHint(
        name = "javax.persistence.query.timeout", 
        value = "2000"  // 2秒超时
    ))
    Order findById(Long id);
}
```

### 3.3 事务超时


**含义**：整个业务操作的最长时间

```java
@Service
public class OrderService {
    
    // 下单操作最多30秒
    @Transactional(timeout = 30)  // 单位：秒
    public void createOrder(OrderDTO dto) {
        // 1. 检查库存（可能要查询多次）
        // 2. 创建订单
        // 3. 减库存
        // 4. 发送通知
        // 以上操作加起来不能超过30秒
    }
}
```

**⚠️ 注意区别**：
```
查询超时：单条SQL的执行时间
事务超时：整个业务方法的执行时间（包含多条SQL）
```

### 3.4 网络超时配置


```yaml
spring:
  datasource:
    hikari:
      # 建立连接的超时
      connection-timeout: 30000     # 30秒
      
      # 验证连接的超时
      validation-timeout: 5000      # 5秒
      
  # HTTP请求超时（如果调用其他服务）
  http:
    client:
      connect-timeout: 3000         # 连接超时3秒
      read-timeout: 10000           # 读取超时10秒
```

### 3.5 重试机制


**什么时候需要重试**：
```
✅ 应该重试的情况：
- 网络抖动导致的临时失败
- 数据库主从切换
- 短暂的资源占用

❌ 不应该重试的情况：
- 业务逻辑错误（如余额不足）
- 数据格式错误
- 权限不足
```

**重试配置示例**：

```java
@Service
public class OrderService {
    
    // 自动重试3次，每次间隔1秒
    @Retryable(
        value = {SQLException.class},  // 只对SQL异常重试
        maxAttempts = 3,                // 最多3次
        backoff = @Backoff(delay = 1000) // 间隔1秒
    )
    public void createOrder(OrderDTO dto) {
        // 订单创建逻辑
    }
    
    // 重试失败后的兜底方法
    @Recover
    public void recoverCreateOrder(SQLException e, OrderDTO dto) {
        // 记录日志
        log.error("订单创建失败，已重试3次", e);
        // 发送告警
        alertService.sendAlert("订单创建失败");
    }
}
```

**📊 重试策略对比**：

| 策略 | **说明** | **适用场景** |
|------|---------|------------|
| 🔄 **固定间隔** | `每次等待1秒` | `网络抖动` |
| 📈 **指数退避** | `1秒→2秒→4秒` | `系统过载` |
| 🎲 **随机间隔** | `1-3秒随机` | `避免雪崩` |

---

## 4. 🔐 死锁与并发控制


### 4.1 什么是死锁


**生活化比喻**：两个人过独木桥

```
情况1：正常通过
A从左边走 → B等待 → A走完 → B通过 ✅

情况2：死锁
A从左边走，锁住左半段
B从右边走，锁住右半段
A等B让路，B等A让路
两人都过不去，永远僵持 ❌
```

**数据库死锁场景**：
```
事务A：
1. 锁定订单表的行1
2. 尝试锁定库存表的行2 ← 等待B释放

事务B：
1. 锁定库存表的行2
2. 尝试锁定订单表的行1 ← 等待A释放

结果：互相等待，死锁！
```

### 4.2 死锁检测与处理


#### 🔸 JPA死锁异常捕获


```java
@Service
public class OrderService {
    
    @Transactional
    public void createOrder(OrderDTO dto) {
        try {
            // 业务逻辑
            orderRepository.save(order);
            stockRepository.updateStock(dto.getProductId());
            
        } catch (PessimisticLockException e) {
            // 捕获死锁异常
            log.warn("检测到死锁，准备重试", e);
            throw new DeadlockException("订单创建死锁");
        }
    }
}
```

#### 🔸 自动回退配置


```yaml
spring:
  jpa:
    properties:
      # 死锁检测超时
      javax.persistence.lock.timeout: 3000  # 3秒后放弃锁
      
      # MySQL死锁自动回滚
      hibernate.dialect: org.hibernate.dialect.MySQL8Dialect
```

**工作原理**：
```
1. 检测到死锁
2. 选择一个事务作为"受害者"
3. 回滚这个事务
4. 另一个事务继续执行
5. 被回滚的事务可以重试
```

### 4.3 预防死锁的方法


**🎯 方法1：统一加锁顺序**

```java
// ❌ 错误：顺序不一致，容易死锁
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    Account from = accountRepo.findById(fromId, PESSIMISTIC_WRITE);
    Account to = accountRepo.findById(toId, PESSIMISTIC_WRITE);
    // 转账逻辑
}

// ✅ 正确：始终按ID从小到大加锁
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    Long first = Math.min(fromId, toId);
    Long second = Math.max(fromId, toId);
    
    Account acc1 = accountRepo.findById(first, PESSIMISTIC_WRITE);
    Account acc2 = accountRepo.findById(second, PESSIMISTIC_WRITE);
    // 转账逻辑
}
```

**🎯 方法2：使用乐观锁**

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private Integer stock;
    
    @Version  // 版本号，乐观锁
    private Integer version;
}

@Service
public class StockService {
    
    // 不用悲观锁，用版本号控制
    @Transactional
    public void reduceStock(Long productId) {
        Product product = productRepo.findById(productId).get();
        product.setStock(product.getStock() - 1);
        productRepo.save(product);
        // 如果version变了，自动抛异常回滚
    }
}
```

**📋 锁策略选择**：

| 场景 | **推荐策略** | **原因** |
|------|------------|---------|
| 📊 **高并发读** | `乐观锁` | `冲突少，性能好` |
| ✍️ **高并发写** | `悲观锁` | `避免大量重试` |
| 💰 **金融操作** | `悲观锁` | `数据一致性优先` |
| 📈 **统计分析** | `无锁` | `允许脏读` |

### 4.4 并发控制配置


```yaml
spring:
  jpa:
    properties:
      # 隔离级别
      hibernate.connection.isolation: 2  # READ_COMMITTED
      
      # 批处理优化
      hibernate.jdbc.batch_size: 20
      hibernate.order_inserts: true
      hibernate.order_updates: true
      
      # 并发控制
      hibernate.query.plan_cache_max_size: 2048
```

**隔离级别说明**：
```
1 = READ_UNCOMMITTED  脏读（不推荐）
2 = READ_COMMITTED    大多数场景推荐 ✅
4 = REPEATABLE_READ   MySQL默认
8 = SERIALIZABLE      串行化（性能差）
```

---

## 5. 📊 监控告警体系


### 5.1 性能指标收集


#### 🔸 连接池监控


```yaml
spring:
  datasource:
    hikari:
      # 开启JMX监控
      register-mbeans: true
      
# 开启Spring Boot监控端点
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,hikaricp
  metrics:
    enable:
      hikaricp: true
```

**监控指标解读**：
```
hikaricp.connections.active    ← 当前活跃连接数
hikaricp.connections.idle      ← 当前空闲连接数
hikaricp.connections.total     ← 总连接数
hikaricp.connections.timeout   ← 获取连接超时次数

⚠️ 告警规则：
- 活跃连接 > 最大连接数的80% → 警告
- 超时次数 > 10次/分钟 → 紧急
```

#### 🔸 SQL性能监控


```yaml
spring:
  jpa:
    properties:
      # 显示SQL
      hibernate.show_sql: false  # 生产不要true，太多日志
      
      # SQL格式化
      hibernate.format_sql: false
      
      # SQL统计
      hibernate.generate_statistics: true
      
# 配置日志级别
logging:
  level:
    org.hibernate.SQL: DEBUG  # 记录SQL
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE  # 记录参数
    org.hibernate.stat: INFO  # 记录统计信息
```

**关键统计信息**：
```
Session Metrics:
- sessions opened: 会话打开数
- sessions closed: 会话关闭数
- transactions: 事务数量

Entity Statistics:
- entity inserts: 插入次数
- entity updates: 更新次数
- entity deletes: 删除次数
- entity loads: 加载次数
```

#### 🔸 自定义监控指标


```java
@Component
public class DatabaseMetrics {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    // 记录慢查询
    public void recordSlowQuery(String queryName, long duration) {
        Timer.builder("database.query.duration")
            .tag("query", queryName)
            .tag("slow", duration > 1000 ? "yes" : "no")
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    // 记录死锁次数
    public void recordDeadlock(String operation) {
        Counter.builder("database.deadlock.count")
            .tag("operation", operation)
            .register(meterRegistry)
            .increment();
    }
}
```

### 5.2 日志配置


#### 🔸 分级日志策略


```yaml
# logback-spring.xml 配置
logging:
  level:
    root: INFO                    # 根日志级别
    com.myapp: DEBUG              # 应用日志
    org.hibernate: WARN           # Hibernate警告
    org.springframework: INFO    # Spring框架
    
  # 日志文件配置
  file:
    name: /var/log/myapp/application.log
    max-size: 100MB               # 单文件最大100MB
    max-history: 30               # 保留30天
    total-size-cap: 10GB          # 总大小限制
```

**日志级别使用建议**：
```
ERROR ← 系统错误，必须处理
WARN  ← 潜在问题，需要关注
INFO  ← 重要业务操作（订单创建、支付等）
DEBUG ← 详细调试信息（开发环境）
TRACE ← 最详细信息（性能分析）
```

#### 🔸 敏感信息脱敏


```java
@Slf4j
@Service
public class UserService {
    
    public void login(String username, String password) {
        // ❌ 错误：明文记录密码
        log.info("用户登录: {}, 密码: {}", username, password);
        
        // ✅ 正确：脱敏处理
        log.info("用户登录: {}, 密码: {}", username, maskPassword(password));
    }
    
    private String maskPassword(String password) {
        return "******";  // 或 password.replaceAll(".", "*")
    }
}
```

### 5.3 告警配置


#### 🔸 告警规则示例


```yaml
# 告警配置（Prometheus + AlertManager示例）
alerts:
  # 数据库连接池告警
  - name: high_db_connection_usage
    condition: hikaricp.connections.active / hikaricp.connections.max > 0.8
    duration: 5m
    severity: warning
    message: "数据库连接使用率超过80%"
    
  # 慢查询告警
  - name: slow_query_detected
    condition: database.query.duration > 5000
    severity: warning
    message: "检测到慢查询，耗时 {{ $value }}ms"
    
  # 死锁告警
  - name: deadlock_detected
    condition: database.deadlock.count > 0
    severity: critical
    message: "检测到数据库死锁"
```

**📋 告警级别分类**：

| 级别 | **触发条件** | **响应时间** | **通知方式** |
|------|------------|------------|------------|
| 🟢 **Info** | `性能下降10%` | `24小时内` | `邮件` |
| 🟡 **Warning** | `性能下降30%` | `2小时内` | `邮件+钉钉` |
| 🟠 **Error** | `功能异常` | `30分钟内` | `电话+短信` |
| 🔴 **Critical** | `服务宕机` | `立即响应` | `电话` |

---

## 6. 🔒 安全配置检查


### 6.1 数据库连接安全


#### 🔸 密码加密存储


```yaml
# ❌ 错误：明文密码
spring:
  datasource:
    password: MyPassword123

# ✅ 正确：使用环境变量
spring:
  datasource:
    password: ${DB_PASSWORD}

# ✅ 更好：使用配置中心（如Spring Cloud Config）
spring:
  datasource:
    password: ${db.password}  # 从加密的配置中心获取
```

**配置加密方法**：
```bash
# 1. 使用Jasypt加密
java -cp jasypt.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI \
  input="MyPassword123" password="MySecretKey" algorithm=PBEWithMD5AndDES

# 2. 在配置文件中使用
spring:
  datasource:
    password: ENC(加密后的密文)
```

#### 🔸 SSL/TLS连接


```yaml
spring:
  datasource:
    url: jdbc:mysql://db.example.com:3306/myapp?useSSL=true&requireSSL=true
    hikari:
      data-source-properties:
        # 使用SSL
        useSSL: true
        requireSSL: true
        verifyServerCertificate: true
        # 信任的证书路径
        trustCertificateKeyStoreUrl: file:/path/to/truststore.jks
        trustCertificateKeyStorePassword: ${TRUSTSTORE_PASSWORD}
```

### 6.2 SQL注入防护


**JPA自动防护机制**：
```java
// ✅ 安全：使用参数化查询
@Query("SELECT u FROM User u WHERE u.username = :username")
User findByUsername(@Param("username") String username);

// ❌ 危险：字符串拼接（但JPA也会转义）
@Query("SELECT u FROM User u WHERE u.username = '" + username + "'")  // 不推荐
```

**原生SQL防护**：
```java
@Repository
public class UserRepository {
    
    @Autowired
    private EntityManager em;
    
    // ✅ 正确：使用参数绑定
    public User findByUsername(String username) {
        return em.createNativeQuery(
            "SELECT * FROM users WHERE username = :username", User.class)
            .setParameter("username", username)  // 自动转义
            .getSingleResult();
    }
    
    // ❌ 危险：直接拼接
    public User findByUsernameDanger(String username) {
        return em.createNativeQuery(
            "SELECT * FROM users WHERE username = '" + username + "'", User.class)
            .getSingleResult();
    }
}
```

### 6.3 权限控制


#### 🔸 数据库用户权限


```sql
-- ✅ 推荐：应用使用受限用户
CREATE USER 'app_user'@'%' IDENTIFIED BY 'SecurePassword';

-- 只授予必要权限
GRANT SELECT, INSERT, UPDATE, DELETE ON myapp.* TO 'app_user'@'%';

-- ❌ 避免：应用使用root用户
-- GRANT ALL PRIVILEGES ON *.* TO 'app_user'@'%';  不要这样！
```

#### 🔸 应用层权限控制


```java
@Service
public class UserService {
    
    // 方法级权限控制
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(Long userId) {
        userRepository.deleteById(userId);
    }
    
    // 数据级权限控制
    @PostFilter("filterObject.department == authentication.principal.department")
    public List<User> findAllUsers() {
        return userRepository.findAll();
    }
}
```

### 6.4 生产安全检查清单


**📋 上线前必查项目**：

```
✅ 连接配置安全
  □ 数据库密码已加密
  □ 使用专用数据库用户（非root）
  □ 开启SSL连接
  □ IP白名单限制

✅ 代码安全
  □ 无SQL拼接字符串
  □ 敏感信息已脱敏
  □ 异常信息不暴露内部细节
  □ 日志不记录密码等敏感数据

✅ 性能配置
  □ 连接池参数已调优
  □ 查询超时已设置
  □ 慢查询监控已开启
  □ 索引检查已完成

✅ 监控告警
  □ 性能指标已接入监控
  □ 告警规则已配置
  □ 值班电话已设置
  □ 日志收集已开启
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 连接池：数据库连接的"停车场"，提前准备好连接供使用
🔸 超时控制：避免无限等待，快速发现问题
🔸 死锁处理：互相等待资源导致的僵持，需要检测和回退
🔸 监控告警：实时掌握系统状态，及时发现问题
🔸 安全配置：密码加密、权限控制、防止SQL注入
```

### 7.2 关键配置速查


**🔹 连接池核心参数**
```yaml
minimum-idle: 10           # 最少10个连接
maximum-pool-size: 50      # 最多50个连接
connection-timeout: 30000  # 获取连接超时30秒
max-lifetime: 1800000      # 连接最多存活30分钟
```

**🔹 超时配置组合**
```yaml
查询超时: 5000ms           # 单个SQL执行时间
事务超时: 30s              # 整个业务方法时间
连接超时: 30000ms          # 获取连接等待时间
```

**🔹 监控关键指标**
```
连接使用率 > 80%   → 扩容或优化
慢查询 > 5秒       → 添加索引
死锁次数 > 0       → 优化加锁顺序
超时次数 > 10/分钟 → 检查数据库性能
```

### 7.3 生产配置最佳实践


**💡 配置原则**：
```
1. 稳定性优先：宁可慢一点，不能挂掉
2. 可监控：每个指标都要能看到
3. 可回滚：出问题能快速恢复
4. 安全第一：密码加密、权限最小化
```

**🎯 常见问题速查**：

| 问题 | **可能原因** | **解决方案** |
|------|------------|------------|
| 🔴 **获取连接超时** | `连接池太小` | `增大maximum-pool-size` |
| 🔴 **查询很慢** | `没有索引` | `添加索引，优化SQL` |
| 🔴 **频繁死锁** | `加锁顺序不一致` | `统一加锁顺序` |
| 🔴 **内存溢出** | `连接泄漏` | `检查事务是否正确关闭` |

**🔥 生产环境金科玉律**：
```
1. 不要在生产环境开启 show_sql=true（日志太多）
2. 不要使用 create-drop（会删除数据）
3. 必须设置查询超时（避免慢查询拖垮系统）
4. 必须配置监控告警（不能等用户投诉才知道出问题）
5. 密码必须加密（不能明文写在配置文件）
```

**核心记忆口诀**：
```
连接池要配好，超时别忘了
死锁要检测，重试有技巧
监控全覆盖，告警要及时
安全第一位，密码要加密
```