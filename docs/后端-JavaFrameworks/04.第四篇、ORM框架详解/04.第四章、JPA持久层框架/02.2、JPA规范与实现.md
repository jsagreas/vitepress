---
title: 2、JPA规范与实现
---
## 📚 目录

1. [JPA是什么](#1-jpa是什么)
2. [JPA规范的作用](#2-jpa规范的作用)
3. [JPA的主流实现框架](#3-jpa的主流实现框架)
4. [传统JDBC与JPA的对比](#4-传统jdbc与jpa的对比)
5. [JPA与MyBatis的对比](#5-jpa与mybatis的对比)
6. [JPA规范版本演进](#6-jpa规范版本演进)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 JPA是什么


### 1.1 通俗理解JPA


**生活中的类比**：
```
想象你要去不同的餐厅点餐：

传统方式（JDBC）：
- 去麦当劳要说："我要一个巨无霸套餐"
- 去肯德基要说："我要一份吮指原味鸡套餐"
- 每个餐厅的点餐方式都不一样，你得记住所有规则

JPA方式：
- 不管去哪个餐厅，你都说："我要一份汉堡套餐"
- 统一的点餐语言，餐厅会自动理解并提供对应的产品
- 你只需要学会一种点餐方式，到处都能用
```

**JPA的本质**：JPA（Java Persistence API）就是一套**统一的标准规则**，让你用同一种方式操作不同的数据库框架。

### 1.2 JPA的核心定义


> **[核心概念]** JPA是Java官方提供的一套**ORM规范接口**，它只定义标准，不提供具体实现。

**三个关键词理解**：

**1️⃣ 规范（Specification）**
```
JPA = 游戏规则制定者
- 只告诉你"应该怎么做"
- 不告诉你"具体怎么实现"
- 就像交通规则：规定靠右行驶，但不管你开什么车

示例：
JPA规定：必须有 @Entity 注解标记实体类
但具体如何解析这个注解？由实现框架自己决定
```

**2️⃣ 接口（API）**
```
JPA提供的是接口定义
┌─────────────────┐
│  EntityManager  │ ← JPA接口（只有方法签名）
├─────────────────┤
│  + persist()    │
│  + find()       │
│  + remove()     │
└─────────────────┘
        ↑
        │ 实现
        │
┌─────────────────┐
│ SessionImpl     │ ← Hibernate的具体实现类
└─────────────────┘
```

**3️⃣ 持久化（Persistence）**
```
持久化 = 把内存中的数据保存到数据库

内存中的Java对象          数据库中的表记录
     User                    users表
   ┌────────┐              ┌────────────┐
   │id = 1  │   持久化      │id│name│age │
   │name=张三│  ========>   │1 │张三 │25  │
   │age = 25│              └────────────┘
   └────────┘
```

### 1.3 为什么需要JPA规范


**问题背景**：在JPA出现之前的混乱局面

```
场景：你的项目要换ORM框架

使用Hibernate开发：
User user = session.load(User.class, 1);
session.save(user);

换成TopLink框架：
User user = entityManager.find(User.class, 1);
entityManager.persist(user);

问题：
❌ 代码全部要改
❌ API完全不一样
❌ 学习成本高
❌ 切换框架困难
```

**JPA解决的问题**：

| 问题 | JPA的解决方案 | 实际效果 |
|------|--------------|---------|
| **API不统一** | 定义标准接口 | 所有框架用同一套API |
| **学习成本高** | 统一规范 | 学一次到处用 |
| **框架绑定** | 面向接口编程 | 轻松切换实现框架 |
| **代码重写** | 遵循规范实现 | 换框架不用改代码 |

---

## 2. ⚖️ JPA规范的作用


### 2.1 规范的三大核心作用


**🔸 作用1：制定统一标准**

```
就像USB接口标准：

没有标准前：
- 诺基亚手机用圆孔充电器
- 苹果手机用Lightning接口
- 安卓手机用Micro USB
→ 每个手机都要配专用充电器

有了标准后：
- 都使用Type-C接口
- 一根线可以充所有手机
→ 统一标准，方便使用

JPA的标准：
@Entity、@Id、@Column 等注解
EntityManager 操作接口
JPQL 查询语言
```

**🔸 作用2：降低学习成本**

```
传统开发学习路径：
学习Hibernate → 3个月
项目要换框架
学习iBatis → 又要3个月
再换框架
学习TopLink → 再3个月
⏰ 总耗时：9个月

使用JPA后：
学习JPA标准 → 3个月
✅ Hibernate能用
✅ EclipseLink能用
✅ OpenJPA能用
⏰ 总耗时：3个月
```

**🔸 作用3：实现框架解耦**

```java
// 面向接口编程，不依赖具体实现
public class UserService {
    // 依赖JPA接口，不依赖Hibernate
    private EntityManager em;
    
    public User findUser(Long id) {
        // 使用JPA标准API
        return em.find(User.class, id);
    }
}

// 配置文件切换实现框架
<!-- 使用Hibernate -->
<provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

<!-- 切换到EclipseLink，代码无需修改 -->
<provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
```

### 2.2 规范包含的内容


**JPA规范定义了什么**：

```
📋 JPA规范包含的核心内容：

1. 注解标准 ⭐⭐⭐
   @Entity、@Table、@Id、@Column、@OneToMany...
   → 定义实体类和表的映射关系

2. API接口 ⭐⭐⭐
   EntityManager、EntityManagerFactory、Query...
   → 规定操作数据库的方法

3. 查询语言 ⭐⭐⭐
   JPQL（Java Persistence Query Language）
   → 统一的面向对象查询语言

4. 生命周期管理 ⭐⭐
   实体的状态：新建、托管、游离、删除
   → 规定对象状态转换规则

5. 事务管理 ⭐⭐
   如何与JTA集成，事务边界定义
   → 保证数据一致性
```

---

## 3. 🏆 JPA的主流实现框架


### 3.1 三大主流实现对比


**框架关系图**：
```
         JPA规范（制定标准）
              ↓
    ┌─────────┴─────────┐
    │                   │
实现框架              实现框架
    ↓                   ↓
┌─────────┐      ┌──────────────┐
│Hibernate│      │ EclipseLink  │
│最流行   │      │ 官方参考实现  │
└─────────┘      └──────────────┘
                        ↓
                 ┌──────────────┐
                 │   OpenJPA    │
                 │ Apache开源   │
                 └──────────────┘
```

### 3.2 Hibernate - 市场占有率第一 ⭐⭐⭐


**框架特点**：
```
Hibernate = JPA实现中的"老大哥"

核心优势：
✅ 功能最强大：支持各种高级特性
✅ 生态最完善：文档、教程、社区支持丰富
✅ 性能优化好：一级缓存、二级缓存、懒加载
✅ 方言支持全：支持几乎所有主流数据库

适用场景：
🎯 企业级应用开发
🎯 复杂的业务逻辑
🎯 需要高级特性的项目
```

**简单示例**：
```java
// Hibernate作为JPA实现
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
}

// 使用JPA标准API操作
EntityManager em = ...;
User user = em.find(User.class, 1L);  // 查询
em.persist(user);                     // 保存
```

**市场份额**：
```
JPA实现框架市场占比（2024年）：
┌────────────────────────────┐
│ Hibernate    ████████ 70%  │
│ EclipseLink  ███ 20%       │
│ OpenJPA      █ 5%          │
│ 其他         █ 5%          │
└────────────────────────────┘
```

### 3.3 EclipseLink - 官方参考实现 ⭐⭐


**框架特点**：
```
EclipseLink = JPA规范的"模范生"

核心优势：
✅ 官方参考：严格遵循JPA规范
✅ 规范优先：新特性支持最快
✅ 轻量稳定：代码简洁，性能稳定

适用场景：
🎯 标准化要求高的项目
🎯 需要最新JPA特性
🎯 轻量级应用
```

**与Hibernate的区别**：
```
配置方式对比：

Hibernate配置：
<property name="hibernate.dialect" 
          value="org.hibernate.dialect.MySQL5Dialect"/>

EclipseLink配置：
<property name="eclipselink.target-database" 
          value="MySQL"/>

性能对比：
Hibernate：功能多，配置复杂，性能可调优空间大
EclipseLink：功能标准，配置简单，性能稳定
```

### 3.4 OpenJPA - Apache开源实现 ⭐


**框架特点**：
```
OpenJPA = Apache基金会的开源实现

核心优势：
✅ 完全开源：Apache协议
✅ 企业支持：IBM、BEA等企业背书
✅ 规范完整：完整实现JPA规范

使用现状：
⚠️ 社区活跃度下降
⚠️ 新项目使用较少
⚠️ 主要用于历史项目维护
```

### 3.5 实现框架选择建议


**选择决策树**：
```
需要选择JPA实现？
        │
        ↓
    新项目 or 老项目？
        │
   ┌────┴────┐
   ↓         ↓
新项目     老项目
   │         └→ 保持原有实现
   ↓
需要复杂功能？
   │
 ┌─┴─┐
 ↓   ↓
是   否
 │   └→ EclipseLink（轻量、标准）
 ↓
Hibernate（功能强大）
```

| 选择标准 | 推荐框架 | 理由 |
|---------|---------|------|
| **功能需求高** | Hibernate | 功能最全，生态最好 |
| **标准化优先** | EclipseLink | 官方参考，规范标准 |
| **历史项目** | OpenJPA | 保持兼容 |
| **学习入门** | Hibernate | 资料最多，社区活跃 |

---

## 4. 🔄 传统JDBC与JPA的对比


### 4.1 JDBC是什么


**通俗理解**：
```
JDBC = 手工操作数据库
就像自己做饭：
- 买菜（建立连接）
- 洗菜（准备SQL）
- 切菜（设置参数）
- 炒菜（执行SQL）
- 装盘（处理结果）
- 洗碗（关闭连接）
→ 全程手工，累但灵活
```

### 4.2 代码对比：完成同一个查询


**场景**：查询id为1的用户信息

**JDBC实现** ❌ 繁琐：
```java
// 1. 加载驱动（每次都要写）
Class.forName("com.mysql.jdbc.Driver");

// 2. 建立连接
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/db", "root", "password");

// 3. 准备SQL语句
String sql = "SELECT id, name, age FROM users WHERE id = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);

// 4. 设置参数
pstmt.setInt(1, 1);

// 5. 执行查询
ResultSet rs = pstmt.executeQuery();

// 6. 手动封装结果
User user = null;
if (rs.next()) {
    user = new User();
    user.setId(rs.getInt("id"));      // 手动映射
    user.setName(rs.getString("name")); // 手动映射
    user.setAge(rs.getInt("age"));     // 手动映射
}

// 7. 关闭资源（忘记会内存泄漏）
rs.close();
pstmt.close();
conn.close();

// ⚠️ 代码行数：20+ 行
// ⚠️ 容易出错：资源泄漏、SQL注入、类型转换
```

**JPA实现** ✅ 简洁：
```java
// 只需2行代码！
EntityManager em = ...;  // 容器自动管理
User user = em.find(User.class, 1);

// ✅ 代码行数：2行
// ✅ 自动映射：不用手写ResultSet转换
// ✅ 自动管理：连接、事务、缓存都自动处理
```

### 4.3 核心区别对比表


| 对比维度 | **JDBC** | **JPA** |
|---------|---------|---------|
| **开发效率** | `低`<br>手写SQL、手动映射 | `高`<br>自动映射、自动生成SQL |
| **代码量** | `多`<br>20+行完成简单查询 | `少`<br>2行完成简单查询 |
| **学习成本** | `低`<br>直接操作数据库 | `中`<br>需要理解ORM概念 |
| **灵活性** | `高`★★★<br>完全控制SQL | `中`★★<br>复杂查询需原生SQL |
| **维护性** | `差`<br>SQL散落各处 | `好`<br>集中管理，易维护 |
| **数据库移植** | `难`<br>SQL方言不同 | `易`<br>JPA自动适配 |

### 4.4 适用场景对比


```
📊 使用场景决策：

选择JDBC的情况：
✓ 复杂SQL优化（多表联查、子查询嵌套）
✓ 批量数据处理（百万级数据导入）
✓ 存储过程调用
✓ 特定数据库特性使用
🎯 典型场景：数据仓库、报表统计、性能极致优化

选择JPA的情况：
✓ 标准CRUD操作（80%的业务场景）
✓ 面向对象开发
✓ 快速开发需求
✓ 数据库无关性要求
🎯 典型场景：企业应用、Web应用、微服务
```

**实际项目中的组合使用**：
```java
// 常见模式：JPA为主，JDBC为辅

// 日常业务：使用JPA
@Service
public class UserService {
    @Autowired
    private EntityManager em;
    
    // 简单查询用JPA
    public User findById(Long id) {
        return em.find(User.class, id);
    }
    
    // 复杂统计用原生SQL
    public List<Object[]> getStatistics() {
        String sql = "SELECT department, COUNT(*), AVG(salary) " +
                    "FROM users GROUP BY department";
        return em.createNativeQuery(sql).getResultList();
    }
}
```

---

## 5. ⚔️ JPA与MyBatis的对比


### 5.1 两者的定位差异


**本质区别**：
```
JPA = 全自动档汽车
- 你只需要踩油门、刹车
- 换挡、离合器全自动
- 适合城市道路
→ 自动化程度高，上手简单

MyBatis = 半自动档汽车
- 你需要手动换挡
- 油门、刹车自己控制
- 适合复杂路况
→ 手动控制，灵活度高
```

**架构对比图**：
```
JPA工作流程：
Java对象 → JPA自动生成SQL → 数据库
         ←  自动映射结果  ←

MyBatis工作流程：
Java对象 → 手写SQL映射 → 数据库
         ← 配置结果映射 ←
```

### 5.2 详细功能对比


| 对比维度 | **JPA (Hibernate)** | **MyBatis** |
|---------|-------------------|-------------|
| **ORM程度** | `全自动ORM`<br>完全面向对象 | `半自动ORM`<br>需要写SQL |
| **SQL控制** | `弱`<br>自动生成，难优化 | `强`★★★<br>完全掌控SQL |
| **开发效率** | `高`★★★<br>CRUD自动化 | `中`★★<br>需要写XML/注解 |
| **学习曲线** | `陡`<br>概念多，需理解ORM | `缓`<br>接近原生SQL |
| **复杂查询** | `弱`<br>需要HQL或原生SQL | `强`★★★<br>直接写SQL |
| **性能优化** | `依赖框架`<br>缓存、懒加载 | `精细控制`<br>手动优化SQL |
| **数据库移植** | `容易`★★★<br>自动适配方言 | `困难`<br>SQL需改写 |

### 5.3 代码实现对比


**场景**：根据用户名模糊查询并关联查询部门信息

**JPA实现**：
```java
// 1. 实体类关系配置
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    @ManyToOne  // 自动关联
    private Department dept;
}

// 2. 查询（自动生成JOIN SQL）
public List<User> findByName(String name) {
    return em.createQuery(
        "SELECT u FROM User u WHERE u.name LIKE :name", User.class)
        .setParameter("name", "%" + name + "%")
        .getResultList();
}

// 自动生成的SQL：
// SELECT u.*, d.* FROM users u 
// LEFT JOIN departments d ON u.dept_id = d.id
// WHERE u.name LIKE ?
```

**MyBatis实现**：
```java
// 1. Mapper接口
public interface UserMapper {
    List<User> findByName(@Param("name") String name);
}

// 2. XML映射文件（需要手写SQL）
<select id="findByName" resultMap="UserWithDept">
    SELECT u.*, d.id as dept_id, d.name as dept_name
    FROM users u
    LEFT JOIN departments d ON u.dept_id = d.id
    WHERE u.name LIKE CONCAT('%', #{name}, '%')
</select>

<!-- 3. 结果映射（手动配置） -->
<resultMap id="UserWithDept" type="User">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <association property="dept" javaType="Department">
        <id property="id" column="dept_id"/>
        <result property="name" column="dept_name"/>
    </association>
</resultMap>
```

**对比总结**：
```
JPA方式：
✅ 代码少：只需写JPQL
✅ 自动JOIN：配置关系即可
❌ SQL不可见：难以优化

MyBatis方式：
✅ SQL可控：完全掌控
✅ 性能优化：精确调优
❌ 代码多：XML配置繁琐
```

### 5.4 选择建议


**选择决策流程**：
```
你的项目是什么类型？
        │
   ┌────┴────┐
   ↓         ↓
企业应用    互联网应用
   │         │
   ↓         ↓
JPA优先    MyBatis优先
   │         │
   ↓         ↓
快速开发   性能优先
标准CRUD   复杂SQL
对象设计   SQL优化
```

**实际项目选择建议**：

| 项目特征 | 推荐框架 | 核心原因 |
|---------|---------|---------|
| **初创项目** | JPA | 快速开发，标准化 |
| **传统企业应用** | JPA | 业务逻辑复杂，重对象设计 |
| **互联网高并发** | MyBatis | SQL优化需求高 |
| **报表统计** | MyBatis | 复杂查询，性能要求高 |
| **数据库可能更换** | JPA | 跨数据库能力强 |
| **团队SQL能力强** | MyBatis | 发挥团队优势 |

**混合使用方案** ⭐ 推荐：
```java
// Spring Boot项目中同时使用JPA和MyBatis

@Service
public class OrderService {
    @Autowired
    private OrderRepository jpaRepo;  // JPA处理简单CRUD
    
    @Autowired
    private OrderMapper mybatisMapper; // MyBatis处理复杂查询
    
    // 简单操作用JPA
    public Order save(Order order) {
        return jpaRepo.save(order);
    }
    
    // 复杂统计用MyBatis
    public List<OrderStatistics> getStatistics() {
        return mybatisMapper.getOrderStatistics();
    }
}
```

---

## 6. 📅 JPA规范版本演进


### 6.1 版本历史时间线


```
JPA规范发展历程：

2006年  ━━━━━━━━━━━→  2009年  ━━━━━━━━━━━→  2013年  ━━━━━━━━━━━→  2017年  ━━━━━━━━→  现在
  JPA 1.0            JPA 2.0            JPA 2.1            JPA 2.2           JPA 3.x
  基础规范            重大升级            功能增强            维护更新           现代化
```

### 6.2 各版本核心特性


**JPA 1.0 (2006年)** - 奠基版本 ⭐
```
核心内容：
✓ 基础ORM映射（@Entity、@Table、@Id）
✓ 基本CRUD操作
✓ JPQL查询语言
✓ 实体生命周期管理

历史意义：
→ 统一了Java持久化标准
→ 结束了各家框架各自为政的局面
```

**JPA 2.0 (2009年)** - 里程碑版本 ⭐⭐⭐
```
重大新特性：

1. Criteria API（类型安全查询）
   // 不再需要写字符串JPQL
   CriteriaBuilder cb = em.getCriteriaBuilder();
   CriteriaQuery<User> query = cb.createQuery(User.class);
   Root<User> user = query.from(User.class);
   query.where(cb.equal(user.get("name"), "张三"));

2. 二级缓存标准化
   @Cacheable  // 统一的缓存注解
   @Entity
   public class User { }

3. 集合映射增强
   @ElementCollection  // 值类型集合
   private Set<String> tags;

4. 外键控制
   @JoinColumn(foreignKey = @ForeignKey(...))

影响：成为企业级应用的标准选择
```

**JPA 2.1 (2013年)** - 功能完善版 ⭐⭐
```
新增特性：

1. Converter转换器
   @Converter  // 自定义类型转换
   public class BooleanToYNConverter 
       implements AttributeConverter<Boolean, String> {
       // 实现转换逻辑
   }

2. EntityGraph动态查询
   @EntityGraph(attributePaths = {"orders", "address"})
   User findById(Long id);  // 控制关联加载

3. 存储过程支持
   @NamedStoredProcedureQuery(...)

4. Schema生成增强
   更精细的DDL控制

适用：复杂企业应用的精细化控制
```

**JPA 2.2 (2017年)** - Java 8适配 ⭐
```
主要更新：

1. Java 8时间API支持
   private LocalDateTime createTime;  // 直接支持
   private LocalDate birthday;

2. Stream API集成
   Stream<User> users = 
       em.createQuery("...", User.class)
         .getResultStream();  // 返回Stream

3. @Repeatable注解支持
   @NamedQuery(...)
   @NamedQuery(...)  // 可以重复使用

意义：与Java 8生态融合
```

**JPA 3.0/3.1 (2020-2022)** - 现代化版本 ⭐⭐
```
重大变化：

1. 包名变更（Jakarta EE）
   import javax.persistence.*;  // 旧版
   import jakarta.persistence.*; // 新版

2. Java 11+ 支持
   适配现代Java版本

3. 性能优化
   查询性能提升
   启动速度优化

当前状态：
→ Jakarta EE生态的一部分
→ 云原生、微服务友好
→ 持续演进中
```

### 6.3 版本选择建议


**实际项目版本选择**：

| 项目类型 | 推荐版本 | 原因 |
|---------|---------|------|
| **新项目(2024+)** | JPA 3.1 | 最新特性，长期支持 |
| **Spring Boot 3.x** | JPA 3.1 | 框架要求 |
| **Spring Boot 2.x** | JPA 2.2 | 稳定兼容 |
| **老项目维护** | 保持原版本 | 避免升级风险 |
| **Java 8项目** | JPA 2.2 | 最佳适配 |
| **Java 11+项目** | JPA 3.x | 现代化特性 |

**版本升级注意事项**：
```
JPA 2.x → 3.x 升级要点：

1. 包名修改
   javax.persistence.* 
   → jakarta.persistence.*

2. 依赖调整
   <dependency>
       <groupId>jakarta.persistence</groupId>
       <artifactId>jakarta.persistence-api</artifactId>
       <version>3.1.0</version>
   </dependency>

3. 实现框架版本匹配
   Hibernate 6.x → 支持JPA 3.1
   Hibernate 5.x → 支持JPA 2.2

⚠️ 升级建议：
- 新项目直接用JPA 3.x
- 老项目非必要不升级
- 升级前充分测试
```

---

## 7. 📋 核心要点总结


### 7.1 必须理解的核心概念


**🔸 JPA的本质**
```
记住这个公式：
JPA = 规范接口 + 统一标准

不是具体框架，是一套游戏规则
定义"做什么"，不管"怎么做"
所有实现框架必须遵守这套规则
```

**🔸 规范与实现的关系**
```
规范层：JPA标准（接口定义）
         ↓
实现层：Hibernate、EclipseLink...（具体实现）
         ↓
应用层：你的项目代码（面向接口编程）

好处：换实现框架不用改代码
```

**🔸 三大实现框架记忆**
```
Hibernate   → 功能最强，市场第一（70%）⭐⭐⭐
EclipseLink → 官方参考，标准规范 ⭐⭐
OpenJPA     → Apache开源，逐渐边缘 ⭐
```

### 7.2 对比关系总结


**JPA vs JDBC**：
```
JDBC = 手工作坊（灵活但繁琐）
JPA  = 自动化工厂（高效但有限制）

选择原则：
- 常规业务 → JPA（80%场景）
- 复杂SQL → JDBC（20%场景）
- 实际项目 → 混合使用
```

**JPA vs MyBatis**：
```
JPA     = 全自动（面向对象，自动SQL）
MyBatis = 半自动（手写SQL，灵活控制）

选择原则：
- 快速开发 → JPA
- SQL优化 → MyBatis  
- 最佳实践 → 组合使用
```

### 7.3 版本演进关键点


| 版本 | 年份 | 记忆要点 |
|------|------|---------|
| **1.0** | 2006 | 奠基之作，基础功能 |
| **2.0** | 2009 | 里程碑，Criteria API |
| **2.1** | 2013 | 功能完善，Converter |
| **2.2** | 2017 | Java 8适配 |
| **3.x** | 2020+ | Jakarta迁移，现代化 |

### 7.4 学习路线建议


```
JPA学习三阶段：

第一阶段：基础入门（1-2周）
✓ 理解ORM概念
✓ 掌握基本注解
✓ 学会简单CRUD
→ 目标：能用JPA完成基本操作

第二阶段：深入理解（2-3周）
✓ 关系映射（一对多、多对多）
✓ JPQL查询语言
✓ 事务与缓存
→ 目标：处理复杂业务场景

第三阶段：高级特性（1-2周）
✓ Criteria API
✓ 性能优化
✓ 与Spring集成
→ 目标：实战项目应用
```

**核心记忆口诀**：
```
JPA是规范非实现，统一标准降成本
Hibernate最强占七成，EclipseLink官方稳
JDBC灵活但繁琐，MyBatis半自动可控
全自动适合快开发，复杂查询组合用
版本演进看需求，新项目直接三点一
```