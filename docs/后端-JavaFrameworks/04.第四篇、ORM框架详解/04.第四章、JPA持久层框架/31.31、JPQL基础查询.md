---
title: 31、JPQL基础查询
---
## 📚 目录

1. [JPQL是什么](#1-JPQL是什么)
2. [JPQL与SQL的核心区别](#2-JPQL与SQL的核心区别)
3. [SELECT查询语句](#3-SELECT查询语句)
4. [FROM实体子句](#4-FROM实体子句)
5. [WHERE条件查询](#5-WHERE条件查询)
6. [ORDER BY排序](#6-ORDER-BY排序)
7. [GROUP BY分组与HAVING](#7-GROUP-BY分组与HAVING)
8. [实体查询别名](#8-实体查询别名)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 JPQL是什么


### 1.1 通俗理解JPQL


> 💡 **生活类比**  
> 想象你去图书馆找书，SQL就像是告诉管理员"去3号书架第2层拿编号001的书"（直接操作物理位置），而JPQL就像说"帮我找一本《Java编程》"（基于书名查找，不关心具体在哪）。

**JPQL核心定义**：
- **全称**：Java Persistence Query Language（Java持久化查询语言）
- **本质**：面向对象的查询语言，操作的是Java实体类而不是数据库表
- **目标**：让开发者用面向对象的思维来查询数据，而不是SQL的表结构思维

```
传统方式（SQL思维）：
SELECT * FROM user_table WHERE user_id = 1

JPA方式（对象思维）：
SELECT u FROM User u WHERE u.id = 1
                    ↑           ↑
                  实体类      对象属性
```

### 1.2 为什么需要JPQL


**解决的核心问题**：

🔸 **数据库无关性**
```
问题场景：公司要从MySQL切换到Oracle
传统SQL：需要修改很多特定语法
JPQL方案：不需要改代码，JPA自动翻译
```

🔸 **面向对象思维**
```
用户需求：查询所有年龄大于18岁的用户
SQL思维：要知道表名、列名、数据类型
对象思维：直接操作User实体和age属性
```

🔸 **类型安全**
```
SQL查询：字符串拼接，容易写错
JPQL查询：基于实体类，IDE能自动提示
```

---

## 2. 🔄 JPQL与SQL的核心区别


### 2.1 三大本质区别


| 对比维度 | **SQL** | **JPQL** | **通俗理解** |
|---------|---------|----------|-------------|
| 🎯 **操作对象** | `数据库表和列` | `实体类和属性` | `SQL操作仓库货架，JPQL操作商品对象` |
| 📋 **查询目标** | `SELECT * FROM user_table` | `SELECT u FROM User u` | `SQL说"查表"，JPQL说"查对象"` |
| 🔤 **大小写** | `不区分大小写` | `实体类名区分大小写` | `SQL随意写，JPQL要严格匹配类名` |
| 🔗 **关联查询** | `需要写JOIN语句` | `直接访问对象属性` | `SQL手动关联，JPQL自动处理关系` |

### 2.2 对比实例讲解


**场景**：查询购买过商品的所有用户

**SQL方式**（表思维）：
```sql
-- 需要知道表结构、外键关系
SELECT u.* 
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE o.id IS NOT NULL
```

**JPQL方式**（对象思维）：
```java
// 直接通过对象关系访问
SELECT u FROM User u 
WHERE u.orders IS NOT EMPTY
```

💡 **理解要点**：
- SQL：你要清楚`users`表和`orders`表通过`user_id`关联
- JPQL：你只需知道`User`对象有个`orders`属性，JPA自动处理关联

### 2.3 查询结果的差异


```
SQL查询返回：
┌────┬──────┬─────┐
│ id │ name │ age │  ← 返回的是表数据（行和列）
├────┼──────┼─────┤
│ 1  │ 张三 │ 25  │
└────┴──────┴─────┘

JPQL查询返回：
User对象
├─ id = 1          ← 返回的是Java对象
├─ name = "张三"
└─ age = 25
```

---

## 3. 📝 SELECT查询语句


### 3.1 基础SELECT语法


**语法结构**：
```
SELECT 选择内容 FROM 实体类 别名 [WHERE 条件]
```

**三种查询方式对比**：

🔸 **查询完整实体**（最常用）
```java
// 返回User对象列表
SELECT u FROM User u

理解：就像从图书馆借整本书
```

🔸 **查询单个属性**
```java
// 返回String类型的名字列表
SELECT u.name FROM User u

理解：就像只抄书的目录，不要书本身
```

🔸 **查询多个属性**
```java
// 返回Object[]数组
SELECT u.name, u.age FROM User u

理解：只要书名和出版年份，其他信息不要
```

### 3.2 实际应用示例


**场景1：查询所有用户**
```java
@Repository
public class UserRepository {
    @PersistenceContext
    private EntityManager em;
    
    // 最简单的查询
    public List<User> findAll() {
        return em.createQuery("SELECT u FROM User u", User.class)
                 .getResultList();
    }
}
```

**场景2：只查询用户名**（节省内存）
```java
public List<String> findAllUserNames() {
    return em.createQuery(
        "SELECT u.name FROM User u", 
        String.class
    ).getResultList();
}
```

**场景3：查询多个字段**
```java
public List<Object[]> findNameAndAge() {
    return em.createQuery(
        "SELECT u.name, u.age FROM User u"
    ).getResultList();
    
    // 使用方式
    for (Object[] row : results) {
        String name = (String) row[0];
        Integer age = (Integer) row[1];
    }
}
```

### 3.3 SELECT的最佳实践


> ⚠️ **性能建议**  
> - 只查需要的字段，避免`SELECT *`式的完整对象查询
> - 大数据量时，考虑分页查询
> - 关联对象按需加载，避免N+1问题

```
❌ 不推荐：查询全部但只用一个字段
SELECT u FROM User u  // 查询了所有属性
// 实际只用了name

✅ 推荐：按需查询
SELECT u.name FROM User u  // 只查询name字段
```

---

## 4. 🏷️ FROM实体子句


### 4.1 FROM子句的作用


**核心理解**：
- FROM后面跟的是**实体类名**，不是数据库表名
- 必须使用**别名**（虽然语法上可选，但强烈建议使用）
- 别名让查询更简洁清晰

```
数据库表结构：
user_info (表名)
├─ user_id
├─ user_name
└─ user_age

实体类定义：
@Entity
@Table(name = "user_info")
public class User {  ← JPQL用这个类名
    @Id
    private Long id;
    private String name;
    private Integer age;
}

JPQL查询：
SELECT u FROM User u  ← 用实体类名User，不是表名user_info
              ↑
            别名
```

### 4.2 别名的使用规范


🔸 **别名命名建议**
```java
// ✅ 好的命名：简短且有意义
SELECT u FROM User u
SELECT o FROM Order o
SELECT p FROM Product p

// ❌ 避免的命名
SELECT user FROM User user  // 太长
SELECT x FROM User x        // 无意义
SELECT U FROM User U        // 容易混淆大小写
```

🔸 **别名的引用场景**
```java
// WHERE条件中引用
SELECT u FROM User u WHERE u.age > 18
                           ↑ 用别名引用属性

// ORDER BY中引用  
SELECT u FROM User u ORDER BY u.name
                              ↑ 用别名排序

// 多表查询中区分
SELECT u, o FROM User u, Order o WHERE u.id = o.userId
       ↑  ↑                            ↑       ↑
     用别名区分不同实体
```

### 4.3 多实体查询（笛卡尔积）


**理解笛卡尔积**：
```
User表有3条记录：
User1, User2, User3

Order表有2条记录：
Order1, Order2

笛卡尔积结果：3 × 2 = 6条记录
User1-Order1, User1-Order2
User2-Order1, User2-Order2
User3-Order1, User3-Order2
```

**JPQL语法**：
```java
// 基本笛卡尔积（慎用，数据量大时很危险）
SELECT u, o FROM User u, Order o

// 添加关联条件（正确做法）
SELECT u, o FROM User u, Order o 
WHERE u.id = o.userId
```

> ⚠️ **警告**：不加条件的多表查询会产生大量无意义数据，应该用JOIN代替

---

## 5. 🔍 WHERE条件查询


### 5.1 基础条件运算符


**常用运算符对照**：

| 运算符类型 | **JPQL写法** | **含义** | **示例** |
|-----------|-------------|---------|---------|
| 🔢 **比较运算** | `=, <>, >, <, >=, <=` | `等于、不等于、大于、小于等` | `u.age > 18` |
| 🔤 **逻辑运算** | `AND, OR, NOT` | `与、或、非` | `u.age > 18 AND u.age < 60` |
| 📝 **模糊匹配** | `LIKE` | `模糊查询` | `u.name LIKE '张%'` |
| 📋 **范围查询** | `BETWEEN, IN` | `区间、列表` | `u.age BETWEEN 18 AND 30` |
| ❓ **空值判断** | `IS NULL, IS NOT NULL` | `判断空值` | `u.email IS NOT NULL` |

### 5.2 实用查询示例


🔸 **单条件查询**
```java
// 查询成年用户
SELECT u FROM User u WHERE u.age >= 18

// 查询指定姓名
SELECT u FROM User u WHERE u.name = '张三'
```

🔸 **组合条件查询**
```java
// AND条件：同时满足
SELECT u FROM User u 
WHERE u.age > 18 AND u.city = '北京'

💡 理解：年龄大于18且在北京的用户

// OR条件：满足其一
SELECT u FROM User u 
WHERE u.age < 18 OR u.age > 60

💡 理解：未成年或老年用户
```

🔸 **模糊查询技巧**
```java
// % 代表任意多个字符
SELECT u FROM User u WHERE u.name LIKE '张%'
💡 找所有姓张的：张三、张伟、张小明...

SELECT u FROM User u WHERE u.name LIKE '%明%'  
💡 名字中包含"明"：小明、明明、黎明...

SELECT u FROM User u WHERE u.name LIKE '张_'
💡 _ 代表单个字符：张三、张伟，但不包括张小明
```

🔸 **范围查询**
```java
// BETWEEN：区间查询
SELECT u FROM User u WHERE u.age BETWEEN 20 AND 30
💡 等价于：u.age >= 20 AND u.age <= 30

// IN：列表查询
SELECT u FROM User u WHERE u.city IN ('北京', '上海', '深圳')
💡 等价于：u.city = '北京' OR u.city = '上海' OR u.city = '深圳'
```

🔸 **空值判断**
```java
// 查询未填写邮箱的用户
SELECT u FROM User u WHERE u.email IS NULL

// 查询已填写邮箱的用户
SELECT u FROM User u WHERE u.email IS NOT NULL

⚠️ 注意：不能用 u.email = null，必须用IS NULL
```

### 5.3 复杂条件组合


```java
// 多条件组合查询
SELECT u FROM User u 
WHERE (u.age > 18 AND u.age < 60)  -- 年龄段
  AND u.city IN ('北京', '上海')    -- 城市范围
  AND u.email IS NOT NULL          -- 已填邮箱
  AND u.status = 'ACTIVE'          -- 状态激活

💡 理解：
1. 括号控制优先级
2. 条件从左到右依次过滤
3. 多个AND时，顺序影响性能（高筛选率的放前面）
```

---

## 6. 📊 ORDER BY排序


### 6.1 排序基础语法


**语法结构**：
```
ORDER BY 字段 [ASC|DESC]
```

**排序方式**：
- `ASC`：升序（默认，可省略）从小到大 `1,2,3...`
- `DESC`：降序 从大到下 `...3,2,1`

🔸 **单字段排序**
```java
// 按年龄升序（从小到大）
SELECT u FROM User u ORDER BY u.age ASC
💡 结果：18, 20, 25, 30...

// 按年龄降序（从大到小）
SELECT u FROM User u ORDER BY u.age DESC
💡 结果：30, 25, 20, 18...

// 默认升序（ASC可省略）
SELECT u FROM User u ORDER BY u.age
```

### 6.2 多字段排序


**排序优先级**：
```
排序逻辑：先按第一个字段排，相同时再按第二个字段排

示例数据：
姓名    年龄    城市
张三    25     北京
李四    25     上海
王五    30     北京
```

```java
// 先按年龄，年龄相同再按姓名
SELECT u FROM User u ORDER BY u.age DESC, u.name ASC

执行过程：
1. 先按年龄降序：30 → 25 → 25
2. 年龄相同(25)时，按姓名升序：李四 → 张三

最终结果：
王五(30) → 李四(25) → 张三(25)
```

### 6.3 实用排序场景


🔸 **分页查询排序**
```java
// 查询最新注册的10个用户
SELECT u FROM User u 
ORDER BY u.createTime DESC
LIMIT 10

💡 应用：首页显示最新用户
```

🔸 **组合业务排序**
```java
// 商品列表：先按销量降序，销量相同按价格升序
SELECT p FROM Product p 
ORDER BY p.salesCount DESC, p.price ASC

💡 应用：电商推荐逻辑
```

🔸 **空值排序处理**
```java
// MySQL默认：NULL值排在最前
SELECT u FROM User u ORDER BY u.score DESC

// 让NULL排最后（数据库特定语法）
SELECT u FROM User u ORDER BY u.score DESC NULLS LAST
```

> 📋 **最佳实践**  
> - 排序字段建议加索引，提升性能
> - 大数据量排序优先在数据库层完成
> - 多字段排序不超过3个，避免性能问题

---

## 7. 📈 GROUP BY分组与HAVING


### 7.1 分组查询的理解


> 💡 **生活类比**  
> 班级考试成绩统计：把学生按班级分组，计算每个班的平均分、最高分等。GROUP BY就是做这个"分组统计"的工作。

**分组查询流程**：
```
原始数据：
姓名    城市    年龄
张三    北京    25
李四    上海    30
王五    北京    28

按城市分组后：
北京组: 张三(25), 王五(28)  → 平均年龄26.5
上海组: 李四(30)           → 平均年龄30
```

### 7.2 GROUP BY基础语法


🔸 **简单分组统计**
```java
// 统计每个城市的用户数
SELECT u.city, COUNT(u) FROM User u 
GROUP BY u.city

结果示例：
北京  120人
上海  85人
深圳  95人
```

🔸 **常用聚合函数**
```java
// COUNT：计数
SELECT u.city, COUNT(u) FROM User u GROUP BY u.city
💡 统计每个城市有多少用户

// AVG：平均值
SELECT u.city, AVG(u.age) FROM User u GROUP BY u.city
💡 统计每个城市用户的平均年龄

// MAX/MIN：最大/最小值
SELECT u.city, MAX(u.age), MIN(u.age) FROM User u GROUP BY u.city
💡 统计每个城市用户的年龄范围

// SUM：求和
SELECT u.city, SUM(u.orderAmount) FROM User u GROUP BY u.city
💡 统计每个城市的订单总额
```

### 7.3 HAVING条件过滤


**WHERE vs HAVING 的区别**：

```
WHERE:  分组前过滤（过滤原始数据行）
HAVING: 分组后过滤（过滤统计结果）

┌─────────────────────────────────┐
│  原始数据（100万用户）            │
└─────────────────────────────────┘
            ↓ WHERE过滤
┌─────────────────────────────────┐
│  过滤后数据（80万用户）           │
└─────────────────────────────────┘
            ↓ GROUP BY分组
┌─────────────────────────────────┐
│  分组结果（100个城市）            │
└─────────────────────────────────┘
            ↓ HAVING过滤
┌─────────────────────────────────┐
│  最终结果（50个符合条件的城市）   │
└─────────────────────────────────┘
```

**实例对比**：
```java
// ❌ 错误：WHERE不能用聚合函数
SELECT u.city, COUNT(u) FROM User u 
WHERE COUNT(u) > 100  -- 报错！
GROUP BY u.city

// ✅ 正确：HAVING过滤分组结果
SELECT u.city, COUNT(u) FROM User u 
GROUP BY u.city
HAVING COUNT(u) > 100
💡 查询用户数超过100的城市
```

### 7.4 复杂分组查询实例


🔸 **多字段分组**
```java
// 按城市和年龄段分组统计
SELECT u.city, u.ageGroup, COUNT(u) 
FROM User u 
GROUP BY u.city, u.ageGroup
HAVING COUNT(u) > 10

结果示例：
北京  18-25岁  45人
北京  26-35岁  68人
上海  18-25岁  32人
```

🔸 **结合WHERE和HAVING**
```java
// 统计活跃用户（status='ACTIVE'）数量超过50的城市
SELECT u.city, COUNT(u) as userCount
FROM User u
WHERE u.status = 'ACTIVE'        -- 先过滤：只要活跃用户
GROUP BY u.city                  -- 再分组：按城市
HAVING COUNT(u) > 50             -- 最后过滤：超过50人的城市
ORDER BY userCount DESC          -- 排序：用户数降序

💡 查询流程：
1. WHERE过滤出所有活跃用户
2. 按城市分组
3. 过滤掉用户数≤50的城市
4. 按用户数降序排列
```

🔸 **统计排名查询**
```java
// 查询各城市平均订单金额，只显示前10名
SELECT u.city, AVG(u.orderAmount) as avgAmount
FROM User u
GROUP BY u.city
HAVING AVG(u.orderAmount) > 1000
ORDER BY avgAmount DESC
LIMIT 10

💡 应用：分析高消费城市
```

---

## 8. 🏷️ 实体查询别名


### 8.1 别名的作用和必要性


**为什么要用别名**：

```
没有别名的问题：
SELECT User FROM User WHERE User.age > 18
                 ↑              ↑
            类名重复，容易混淆

使用别名后：
SELECT u FROM User u WHERE u.age > 18
       ↑           ↑        ↑
     简洁清晰，一目了然
```

**别名的三大优势**：

✅ **代码简洁**
```java
// 不用别名（繁琐）
SELECT User FROM User WHERE User.name = '张三' AND User.age > 18

// 使用别名（简洁）
SELECT u FROM User u WHERE u.name = '张三' AND u.age > 18
```

✅ **多表区分**
```java
// 关联查询时区分不同实体
SELECT u, o FROM User u 
JOIN u.orders o 
WHERE u.id = 1 AND o.status = 'PAID'
      ↑            ↑
   用户别名      订单别名
```

✅ **属性访问**
```java
// 通过别名访问嵌套属性
SELECT u FROM User u 
WHERE u.address.city = '北京'
      ↑
    用别名访问关联对象的属性
```

### 8.2 别名命名规范


📋 **推荐命名规则**：

```java
// ✅ 类名首字母小写
User    → u
Order   → o  
Product → p

// ✅ 多个单词取首字母
UserOrder      → uo
ProductDetail  → pd
OrderItem      → oi

// ✅ 有意义的简写
customer → c 或 cust
supplier → s 或 sup
```

⚠️ **避免的命名**：
```java
// ❌ 太长
SELECT user FROM User user

// ❌ 无意义
SELECT x FROM User x
SELECT a FROM User a

// ❌ 容易混淆
SELECT U FROM User U  // 大小写易错
```

### 8.3 别名的高级用法


🔸 **子查询中的别名作用域**
```java
// 外层查询别名：u
// 内层查询别名：u2（不能重名）
SELECT u FROM User u 
WHERE u.age > (
    SELECT AVG(u2.age) FROM User u2
                           ↑
                    子查询有自己的别名
)

💡 内外层别名相互独立
```

🔸 **JOIN查询的别名**
```java
// 多表关联时的别名使用
SELECT u.name, o.orderNo, p.productName
FROM User u
JOIN u.orders o          -- 订单别名
JOIN o.products p        -- 商品别名
WHERE u.city = '北京'

💡 理解：
u   → 用户对象
o   → 用户的订单对象
p   → 订单中的商品对象
```

🔸 **别名在SELECT中的应用**
```java
// 为查询结果取别名
SELECT u.name as userName, u.age as userAge
FROM User u
WHERE u.city = '北京'

💡 返回的Map中key为userName和userAge
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基础概念


```
🎯 JPQL本质理解：
• 面向对象的查询语言，操作实体类不是表
• 数据库无关，JPA自动翻译成SQL
• 语法类似SQL，但关注点是对象而非表结构

🔑 关键语法要素：
• SELECT：查什么（实体、属性、多个字段）
• FROM：从哪查（实体类+别名）
• WHERE：查询条件（对象属性的过滤）
• ORDER BY：如何排序（升序/降序）
• GROUP BY + HAVING：分组统计与过滤

📝 别名的价值：
• 简化查询语句
• 区分多表关联
• 访问嵌套属性
```

### 9.2 与SQL的核心差异


| 对比点 | **SQL** | **JPQL** | **记忆要点** |
|-------|---------|----------|------------|
| 📋 **查询对象** | `表名和列名` | `实体类和属性` | `JPQL看对象不看表` |
| 🔤 **大小写** | `不敏感` | `实体类名敏感` | `User和user不同` |
| 🔗 **关联查询** | `手写JOIN` | `对象导航自动` | `u.orders自动JOIN` |
| 📊 **返回结果** | `ResultSet行数据` | `Java对象/属性` | `JPQL返回对象` |

### 9.3 实战最佳实践


🔸 **查询优化建议**
```
性能优先：
✅ 只查需要的字段：SELECT u.name 而非 SELECT u
✅ 添加合理的WHERE条件缩小范围
✅ 排序字段建议加索引
✅ 大数据量用分页（LIMIT）

可读性优先：
✅ 必须使用别名
✅ 复杂条件用括号分组
✅ 多表查询用JOIN而非笛卡尔积
```

🔸 **常见错误避免**
```
❌ WHERE中直接用聚合函数 → 应该用HAVING
❌ 空值判断用 = null → 应该用 IS NULL  
❌ LIKE模糊查询忘记% → 不会匹配任何结果
❌ FROM用表名而非实体类名 → 查询失败
```

### 9.4 学习路径建议


```
第1步：掌握基础SELECT查询
├─ 查询完整实体
├─ 查询单个/多个属性
└─ 理解别名的使用

第2步：熟练WHERE条件
├─ 基础比较运算
├─ 逻辑组合（AND/OR）
├─ 模糊查询（LIKE）
└─ 范围查询（BETWEEN/IN）

第3步：学会排序分组
├─ ORDER BY单字段/多字段
├─ GROUP BY统计
├─ HAVING过滤分组结果
└─ 理解WHERE和HAVING区别

第4步：进阶技巧
├─ 子查询
├─ JOIN关联查询
└─ 复杂统计分析
```

🧠 **记忆口诀**：
```
JPQL查对象，不看数据表
别名要规范，属性导航妙
WHERE过滤行，HAVING筛分组
升序ASC省，降序DESC标
```

💡 **核心要领**：
- 始终用**对象思维**而非表思维
- 别名是**必备习惯**，提升代码质量
- WHERE是**行过滤**，HAVING是**组过滤**
- 多练习，理解JPQL到SQL的**翻译过程**