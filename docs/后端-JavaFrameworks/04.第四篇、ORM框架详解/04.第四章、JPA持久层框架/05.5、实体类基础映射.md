---
title: 5、实体类基础映射
---
## 📚 目录

1. [什么是ORM和JPA](#1-什么是ORM和JPA)
2. [实体类基础概念](#2-实体类基础概念)
3. [@Entity实体注解详解](#3-Entity实体注解详解)
4. [@Table表映射](#4-Table表映射)
5. [实体类规范与要求](#5-实体类规范与要求)
6. [完整实体类示例](#6-完整实体类示例)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 什么是ORM和JPA


### 1.1 ORM是什么？


**🔸 大白话理解**
```
传统开发方式：
你写Java代码 → 手动写SQL语句 → 数据库执行SQL → 手动把结果转成Java对象

ORM方式：
你写Java代码 → ORM框架自动生成SQL → 自动把结果转成Java对象

就像：
以前你要自己做饭（写SQL）
现在有了外卖（ORM），你只需要点菜（写Java对象）
```

**💡 专业定义**
- **ORM**：Object-Relational Mapping（对象关系映射）
- **作用**：在面向对象的Java代码和关系型数据库之间架起一座桥梁
- **核心思想**：用Java类对应数据库表，用对象操作代替SQL操作

### 1.2 JPA又是什么？


**🔸 简单理解**
```
JPA = Java中ORM的统一标准（规范）

就像USB接口：
- JPA是USB标准（定义了接口规范）
- Hibernate、EclipseLink等是具体的USB设备（具体实现）
- 你用USB接口（JPA注解）写代码，底层可以换不同实现
```

**🎯 关键概念**
- **JPA**：Java Persistence API（Java持久化API）
- **本质**：一套接口规范，不是具体实现
- **常用实现**：Hibernate（最流行）、EclipseLink、OpenJPA

### 1.3 为什么要用ORM？


| 传统JDBC开发 | 使用ORM框架 |
|------------|------------|
| `手写SQL语句，容易出错` | `自动生成SQL，减少错误` |
| `手动处理结果集转换` | `自动映射对象` |
| `代码冗余重复` | `代码简洁优雅` |
| `SQL分散在各处` | `集中管理，易维护` |

**✅ 核心优势**
- 🚀 **开发效率高**：不用写繁琐的SQL和数据转换代码
- 🔧 **维护方便**：修改表结构只需改Java类
- 🎯 **面向对象**：用熟悉的Java方式操作数据
- 🔄 **数据库独立**：换数据库不用改代码

---

## 2. 📦 实体类基础概念


### 2.1 什么是实体类？


**🔸 生活化理解**
```
数据库表 = 一个Excel表格
实体类   = 这个表格的模板（定义有哪些列）

例如：用户表
┌─────┬──────┬─────────┬─────┐
│ id  │ name │  email  │ age │
├─────┼──────┼─────────┼─────┤
│  1  │ 张三  │ z@xx.com│  25 │
│  2  │ 李四  │ l@xx.com│  30 │
└─────┴──────┴─────────┴─────┘

对应的Java实体类User：
- id字段    → private Long id;
- name字段  → private String name;
- email字段 → private String email;
- age字段   → private Integer age;
```

**💡 专业定义**
- **实体类（Entity）**：用来映射数据库表的Java类
- **作用**：一个实体类对应数据库中的一张表
- **特点**：每个字段对应表中的一列

### 2.2 实体类和普通Java类的区别


```
普通Java类：
public class User {
    private String name;  // 只是Java对象的属性
}

实体类：
@Entity  // 标记：这个类对应数据库表
public class User {
    @Id  // 标记：这是主键字段
    private Long id;
    private String name;  // 对应数据库的name列
}
```

**🎯 核心区别**
- 📌 **有特殊注解**：`@Entity`、`@Id`等标记作用
- 📌 **有映射关系**：类↔表，属性↔列
- 📌 **被JPA管理**：JPA框架会自动处理这些类

---

## 3. 🏷️ @Entity实体注解详解


### 3.1 @Entity注解的作用


**🔸 大白话**
```
@Entity就像给Java类贴了个标签：
"嘿，JPA！这个类要映射成数据库表，请帮我管理！"
```

**基本使用**
```java
@Entity  // 告诉JPA：这是个实体类
public class User {
    @Id
    private Long id;
    private String name;
}
```

**⚡ 关键要点**
- 🔸 加了`@Entity`的类，JPA会自动创建对应的数据库表
- 🔸 类名默认就是表名（User类 → user表）
- 🔸 必须配合`@Id`注解指定主键

### 3.2 @Entity的name属性


**🔸 什么时候用？**
```
默认情况：
@Entity
public class User {}  
// 实体名称 = 类名 = "User"

自定义实体名称：
@Entity(name = "UserEntity")
public class User {}
// 实体名称 = "UserEntity"（用在JPQL查询中）
```

**💡 实体名称的用途**
```java
// JPQL查询时使用实体名称
String jpql = "SELECT u FROM UserEntity u";  // 用的是@Entity的name
// 不是表名，是实体名！
```

**🤔 注意区分**
- `@Entity(name="xxx")` → 设置**实体名称**（JPQL用）
- `@Table(name="xxx")` → 设置**表名**（数据库用）
- 大多数情况不需要设置name，用默认的类名即可

---

## 4. 📊 @Table表映射


### 4.1 @Table注解的作用


**🔸 通俗理解**
```
@Table = 告诉JPA这个类对应数据库的哪张表

不加@Table：
@Entity
public class User {}  
→ 默认表名 = user（类名小写）

加@Table：
@Entity
@Table(name = "sys_user")
public class User {}  
→ 表名 = sys_user（自己指定）
```

### 4.2 @Table的常用属性


**📋 属性详解**

| 属性 | 作用 | 示例 |
|------|------|------|
| **name** | `指定表名` | `@Table(name="sys_user")` |
| **schema** | `指定数据库模式` | `@Table(schema="test")` |
| **catalog** | `指定数据库目录` | `@Table(catalog="mydb")` |

**🔧 实际使用示例**
```java
@Entity
@Table(name = "sys_user")  // 表名：sys_user
public class User {
    @Id
    private Long id;
    private String name;
}

// 生成的SQL：
// CREATE TABLE sys_user (
//     id BIGINT PRIMARY KEY,
//     name VARCHAR(255)
// );
```

### 4.3 表名命名规范


**🎯 常见命名风格**
```
业务模块前缀：
sys_user    (系统用户表)
sys_role    (系统角色表)
order_info  (订单信息表)
product_spu (商品SPU表)

功能分类前缀：
tb_user     (table_用户)
t_product   (table_商品)
biz_order   (business_订单)
```

**✅ 推荐做法**
- 📌 小写字母 + 下划线分隔
- 📌 见名知意，表达清晰
- 📌 团队统一规范

---

## 5. 📝 实体类规范与要求


### 5.1 必须有无参构造函数


**🔸 为什么必须要？**
```
JPA底层工作原理：
1. 从数据库查询数据
2. 通过反射创建对象：User user = User.class.newInstance()
3. 反射需要无参构造！
4. 然后把数据填充到对象中
```

**✅ 正确写法**
```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    // ✅ 无参构造（必须）
    public User() {
    }
    
    // 有参构造（可选）
    public User(Long id, String name) {
        this.id = id;
        this.name = name;
    }
}
```

**❌ 错误写法**
```java
@Entity
public class User {
    @Id
    private Long id;
    
    // ❌ 只有有参构造，没有无参构造
    public User(Long id) {
        this.id = id;
    }
    // 运行时报错！
}
```

### 5.2 实现Serializable序列化接口


**🔸 为什么要序列化？**
```
场景1：分布式系统
服务A → 网络传输User对象 → 服务B
（需要序列化成字节流传输）

场景2：缓存存储
User对象 → 序列化 → 存入Redis → 反序列化 → 取出对象

场景3：会话存储
User对象 → 存入Session → 服务器重启 → 从磁盘恢复
```

**✅ 标准写法**
```java
@Entity
public class User implements Serializable {
    
    // 序列化版本号（建议显式声明）
    private static final long serialVersionUID = 1L;
    
    @Id
    private Long id;
    private String name;
}
```

**🎯 关键要点**
- `serialVersionUID`：序列化版本号，确保版本兼容
- **建议显式声明**：避免类修改后反序列化失败
- **值可以是1L**：简单起见，通常设为1L

### 5.3 实体命名规范


**🔸 类名规范**
```
✅ 推荐风格：

大驼峰命名：
User          (用户)
UserRole      (用户角色)
OrderInfo     (订单信息)
ProductDetail (商品详情)

实体类后缀（可选）：
UserEntity
OrderEntity
```

**🔸 字段命名规范**
```
✅ 推荐：小驼峰命名
private String userName;    // ✅
private Integer userAge;    // ✅
private Date createTime;    // ✅

❌ 不推荐：
private String user_name;   // ❌ 不符合Java规范
private String UserName;    // ❌ 不是小驼峰
```

**🎯 数据库映射规则**
```
Java字段          →  数据库列名
userName         →  user_name
createTime       →  create_time
orderId          →  order_id

（JPA自动转换：驼峰 → 下划线）
```

### 5.4 逻辑删除列预留


**🔸 什么是逻辑删除？**
```
物理删除（真删除）：
DELETE FROM user WHERE id = 1;  
→ 数据真的没了，无法恢复！

逻辑删除（假删除）：
UPDATE user SET deleted = 1 WHERE id = 1;
→ 数据还在，只是标记为"已删除"
```

**💡 为什么要逻辑删除？**
- 🔸 **数据安全**：误删可以恢复
- 🔸 **数据追溯**：保留历史记录
- 🔸 **业务需要**：订单、用户等重要数据不能真删

**✅ 预留逻辑删除字段**
```java
@Entity
@Table(name = "sys_user")
public class User implements Serializable {
    
    @Id
    private Long id;
    private String name;
    
    // 逻辑删除标记（预留字段）
    private Integer deleted;  // 0=正常，1=已删除
    
    // 或使用布尔类型
    // private Boolean isDeleted;  // false=正常，true=已删除
}
```

**🔧 查询时的处理**
```java
// 查询未删除的用户
SELECT * FROM sys_user WHERE deleted = 0;

// JPA中配置（后续章节会讲）
@Where(clause = "deleted = 0")
public class User { ... }
```

---

## 6. 🎯 完整实体类示例


### 6.1 标准实体类模板


```java
package com.example.entity;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;

/**
 * 用户实体类
 * 对应数据库表：sys_user
 */
@Entity  // ① 标记为JPA实体
@Table(name = "sys_user")  // ② 指定表名
public class User implements Serializable {  // ③ 实现序列化
    
    private static final long serialVersionUID = 1L;  // ④ 序列化版本号
    
    // ⑤ 主键字段
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // ⑥ 普通字段
    private String username;
    private String password;
    private String email;
    private Integer age;
    
    // ⑦ 逻辑删除字段
    private Integer deleted;
    
    // ⑧ 时间字段
    private Date createTime;
    private Date updateTime;
    
    // ⑨ 无参构造（必须）
    public User() {
    }
    
    // ⑩ 有参构造（可选）
    public User(String username, String email) {
        this.username = username;
        this.email = email;
    }
    
    // ⑪ Getter和Setter（必须）
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    // ... 其他getter/setter省略
}
```

### 6.2 生成的数据库表结构


```sql
-- 上面的实体类会生成这样的表
CREATE TABLE sys_user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(255),
    password VARCHAR(255),
    email VARCHAR(255),
    age INT,
    deleted INT,
    create_time DATETIME,
    update_time DATETIME
);
```

**🔍 对应关系**
```
Java类         →  数据库表
User          →  sys_user

Java字段       →  数据库列
id            →  id
username      →  username
createTime    →  create_time  (驼峰自动转下划线)
```

### 6.3 实体类检查清单


**☑ 必备要素检查**
- [ ] ✅ 有`@Entity`注解
- [ ] ✅ 有`@Id`注解标记主键
- [ ] ✅ 有无参构造函数
- [ ] ✅ 实现`Serializable`接口
- [ ] ✅ 有`serialVersionUID`字段
- [ ] ✅ 所有字段有getter/setter
- [ ] ✅ 预留逻辑删除字段（可选但推荐）

**⚠️ 常见错误**
```
❌ 忘记@Entity注解 → JPA不认识这个类
❌ 忘记@Id注解 → 没有主键，报错
❌ 没有无参构造 → 反射创建对象失败
❌ 没有getter/setter → JPA无法访问字段
```

---

## 7. 📋 核心要点总结


### 7.1 必须记住的关键概念


**🎯 ORM和JPA核心理解**
```
ORM  = 对象关系映射，让Java对象和数据库表对应起来
JPA  = Java持久化规范，定义了ORM的标准接口
实体类 = 映射数据库表的Java类
```

**🎯 实体类必备要素**
```
① @Entity注解：标记为实体类
② @Table注解：指定表名（可选，默认用类名）
③ @Id注解：标记主键字段
④ 无参构造函数：JPA反射需要
⑤ Serializable接口：支持序列化
⑥ Getter/Setter方法：JPA访问字段
```

### 7.2 实体类规范速记


| 规范项 | 要求 | 原因 |
|--------|------|------|
| **无参构造** | `必须有` | `JPA反射需要` |
| **序列化** | `实现Serializable` | `支持网络传输和缓存` |
| **类命名** | `大驼峰` | `Java规范` |
| **字段命名** | `小驼峰` | `自动转数据库下划线` |
| **逻辑删除** | `预留deleted字段` | `数据安全和追溯` |

### 7.3 常见问题FAQ


**❓ 为什么必须要无参构造函数？**
```
答：JPA通过反射创建对象，newInstance()方法需要无参构造。
```

**❓ @Entity和@Table的区别？**
```
答：
@Entity：标记这是个实体类，name属性是实体名（JPQL用）
@Table：指定数据库表名，name属性是真正的表名
```

**❓ 字段必须有getter/setter吗？**
```
答：必须！JPA通过getter/setter访问字段，没有会报错。
```

**❓ 逻辑删除字段必须叫deleted吗？**
```
答：不是，名字随意（isDeleted、delFlag都行），
   关键是要有个字段标记删除状态。
```

### 7.4 学习路径指引


```
📍 你现在的位置：实体类基础
   ✅ 理解了什么是实体类
   ✅ 掌握了@Entity和@Table
   ✅ 知道了实体类的规范要求

🚀 下一步学习方向：
   → 主键生成策略（@GeneratedValue）
   → 字段映射注解（@Column）
   → 日期时间处理（@Temporal）
   → 关系映射（@OneToMany等）
```

**💡 学习建议**
- 🔸 先把实体类基础打牢，后续的高级特性都基于此
- 🔸 多写几个实体类练手，熟悉注解使用
- 🔸 对照数据库表结构，理解映射关系
- 🔸 遇到问题先检查"实体类检查清单"

---

**🎉 恭喜完成本章学习！**

你已经掌握了JPA实体类的基础知识，可以开始创建自己的实体类了。记住：**实体类就是数据库表的Java版本，一一对应，理解这个本质就掌握了关键！**