---
title: 65、数据库迁移正确姿势
---
## 📚 目录

1. [什么是数据库迁移](#1-什么是数据库迁移)
2. [为什么需要数据库迁移](#2-为什么需要数据库迁移)
3. [ddl-auto的局限性](#3-ddl-auto的局限性)
4. [Flyway迁移工具](#4-flyway迁移工具)
5. [Liquibase迁移工具](#5-liquibase迁移工具)
6. [版本化脚本管理](#6-版本化脚本管理)
7. [回滚策略设计](#7-回滚策略设计)
8. [生产环境迁移实战](#8-生产环境迁移实战)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 什么是数据库迁移


### 1.1 生活中的类比


想象你在装修房子：
- **第一次装修**：刷墙、铺地板、装家具
- **第二次改造**：想改墙体颜色，但不能把之前的家具全扔了重买
- **第三次升级**：加个书房，但客厅、卧室还得保留

**数据库迁移就是"数据库的装修改造"**：
```
初始状态：           第一次改造：         第二次升级：
用户表(id,name)  →   用户表(id,name,age) → 用户表(id,name,age,email)
                                           订单表(新增)
```

### 1.2 数据库迁移的本质


**核心理解**：数据库迁移就是**有计划、有记录、可追溯**地修改数据库结构。

```
传统做法（危险）：
开发环境：手动改表 → 测试环境：再手动改一遍 → 生产环境：又手动改一遍
问题：容易漏改、改错、不知道改了啥

迁移工具做法（安全）：
写迁移脚本 → 版本控制 → 自动执行 → 记录历史
优势：可追溯、可回滚、团队同步
```

### 1.3 迁移工具的工作原理


**简单理解**：就像Git管理代码一样管理数据库！

```
代码版本控制：                数据库迁移：
├── v1.0 初始提交            ├── V1__init.sql 创建用户表
├── v1.1 新增功能            ├── V2__add_age.sql 添加年龄字段
├── v1.2 修复bug             ├── V3__add_order.sql 新增订单表
└── v2.0 大版本升级          └── V4__add_index.sql 添加索引

都有历史记录，都能回退！
```

---

## 2. 🤔 为什么需要数据库迁移


### 2.1 真实场景问题


**场景1：多人协作的噩梦**
```
周一：小张在本地给用户表加了age字段
周二：小李拉代码，运行报错 - 找不到age字段！
周三：测试环境部署，又忘了加age字段，测试失败
周四：生产环境上线，再次忘记，线上故障！

问题根源：数据库结构变更没有版本控制
```

**场景2：生产数据丢失惨案**
```
开发想法：反正用ddl-auto=update，自动建表多方便
生产现实：手抖改成ddl-auto=create，重启后表全没了！
后果：老板暴怒，数据找不回，程序员失业...

血的教训：生产环境绝不能用自动建表！
```

### 2.2 迁移工具解决的核心问题


| 问题场景 | **传统做法的痛点** | **迁移工具的方案** |
|---------|------------------|------------------|
| 🔧 **环境同步** | `手动在每个环境执行SQL，容易遗漏` | `脚本自动同步，一次编写处处运行` |
| 📜 **变更历史** | `不知道谁改了什么，无法追溯` | `版本化管理，清晰记录每次变更` |
| ↩️ **问题回滚** | `出问题不知道怎么恢复` | `编写回滚脚本，一键回退` |
| 👥 **团队协作** | `你改我也改，互相冲突` | `统一脚本，避免冲突` |
| 🚀 **生产部署** | `手动执行SQL，紧张又危险` | `自动化执行，安全可靠` |

### 2.3 迁移工具的核心价值


**就像给数据库变更买了保险**：

```
没有迁移工具：
改数据库 = 走钢丝（没保护措施）
出问题 = 摔下去（数据丢失）

有迁移工具：
改数据库 = 有安全绳的攀岩
出问题 = 安全降落（可回滚）
```

**三大核心价值**：
- **版本控制**：像Git一样管理数据库变更
- **环境一致**：开发、测试、生产完全一样
- **安全可靠**：有记录、能回滚、可审计

---

## 3. 🚫 ddl-auto的局限性


### 3.1 ddl-auto是什么


**最直白的解释**：ddl-auto是JPA提供的"自动建表"功能。

```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: create  # 每次启动都删表重建
```

**工作原理**：
```
应用启动时：
1. 读取你的@Entity实体类
2. 自动生成建表SQL语句
3. 执行SQL创建/更新数据库表

就像：你画了房子设计图，程序自动帮你盖房子
```

### 3.2 ddl-auto的各种模式


| 模式 | **含义** | **行为** | **适用场景** |
|------|---------|----------|-------------|
| `create` | `创建` | `启动时删除旧表，创建新表` | `❌ 从不使用（会丢数据）` |
| `create-drop` | `创建后删除` | `启动创建，关闭删除表` | `❌ 临时测试（数据不保留）` |
| `update` | `更新` | `只新增字段，不删除` | `⚠️ 本地开发（有风险）` |
| `validate` | `验证` | `只检查不修改` | `✅ 生产环境（最安全）` |
| `none` | `不处理` | `什么都不做` | `✅ 生产环境（推荐）` |

### 3.3 update模式的隐藏陷阱


**看似安全，实则危险**：

```java
// 第一版实体类
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
}

// 第二版：改了字段名
@Entity
public class User {
    @Id
    private Long id;
    private String username;  // 改名了
    private String email;
}
```

**update模式的行为**：
```
预期：把name字段改名为username
实际：
  ✅ 新增username字段（空值）
  ❌ 保留name字段（旧数据）
结果：多了一个废弃字段，数据还丢了！

数据库实际结构：
user表
├── id
├── name（废弃，有旧数据）
├── username（新增，全是null）
└── email
```

**更危险的情况**：
```java
// 改了数据类型
private Integer age;  // 原来是整数
↓
private String age;   // 改成字符串

update模式：
可能报错、可能截断数据、可能静默失败
完全不可预测！
```

### 3.4 为什么生产环境禁用ddl-auto


**血泪教训**：

```
事故案例1：配置失误
开发环境：ddl-auto=update（本地测试）
生产环境：手抖写成ddl-auto=create
后果：重启应用，所有表被删除重建，数据全没了！

事故案例2：字段改名
开发改名：phone → mobile
update执行：新增mobile字段（空值），保留phone字段
生产表现：新用户没有手机号，老用户手机号找不到

事故案例3：实体类删除
开发删除：某个不用的实体类
update行为：什么都不做
生产结果：废弃表一直存在，占用空间，成为"僵尸表"
```

**正确做法**：
```yaml
# 生产环境配置
spring:
  jpa:
    hibernate:
      ddl-auto: none  # 或 validate
```

---

## 4. 🚀 Flyway迁移工具


### 4.1 Flyway是什么


**最简单理解**：Flyway就是数据库的"Git"，管理SQL脚本版本。

```
Git管理代码：              Flyway管理数据库：
git commit v1.0.0         V1__create_user.sql
git commit v1.1.0         V2__add_age_column.sql
git commit v2.0.0         V3__create_order.sql

都是版本化管理，都能追溯历史！
```

### 4.2 快速上手Flyway


**第一步：添加依赖**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

**第二步：配置Flyway**
```yaml
# application.yml
spring:
  flyway:
    enabled: true
    locations: classpath:db/migration  # 脚本位置
    baseline-on-migrate: true          # 首次运行建立基线
```

**第三步：编写迁移脚本**
```
项目结构：
src/main/resources/
└── db/
    └── migration/
        ├── V1__create_user_table.sql
        ├── V2__add_age_to_user.sql
        └── V3__create_order_table.sql
```

### 4.3 Flyway脚本命名规则


**命名格式解析**：
```
V{版本号}__{描述}.sql
│    │      │
│    │      └─ 双下划线后面是描述（用下划线分隔单词）
│    └─ 版本号（递增的数字，可以是1, 2, 3或1.0, 1.1, 2.0）
└─ 固定前缀V（大写）

示例：
V1__create_tables.sql          ✅ 正确
V2__add_user_age.sql          ✅ 正确
V2.1__fix_user_email.sql      ✅ 正确
v3__update.sql                ❌ 错误（v必须大写）
V4_add_column.sql             ❌ 错误（只有一个下划线）
```

### 4.4 编写迁移脚本实例


**V1__create_user_table.sql**（初始建表）
```sql
-- 创建用户表
CREATE TABLE user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_username ON user(username);
```

**V2__add_age_to_user.sql**（添加字段）
```sql
-- 给用户表添加年龄字段
ALTER TABLE user ADD COLUMN age INT;

-- 给现有用户设置默认年龄
UPDATE user SET age = 0 WHERE age IS NULL;
```

**V3__create_order_table.sql**（新增表）
```sql
-- 创建订单表
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    amount DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id)
);
```

### 4.5 Flyway工作流程


**启动时的执行过程**：
```
应用启动
    ↓
检查数据库中是否有flyway_schema_history表
    ↓ 没有
创建flyway_schema_history表（记录迁移历史）
    ↓
扫描db/migration目录找到所有脚本
    ↓
对比flyway_schema_history表，找出未执行的脚本
    ↓
按版本号顺序执行脚本
    ↓
记录执行结果到flyway_schema_history表
    ↓
启动完成
```

**flyway_schema_history表结构**：
```
记录每次迁移的详细信息：

installed_rank | version | description        | script                    | success
1              | 1       | create user table  | V1__create_user_table.sql | true
2              | 2       | add age to user    | V2__add_age_to_user.sql   | true
3              | 3       | create order table | V3__create_order_table.sql| true

作用：
✅ 知道哪些脚本已执行
✅ 避免重复执行
✅ 追溯变更历史
```

### 4.6 Flyway核心特性


**特性1：幂等性保证**
```
同一个脚本不会被执行两次

第一次启动：执行V1, V2, V3
第二次启动：检查发现都执行过了，跳过
新增V4脚本：只执行V4

就像：
已读的书不会再读一遍
只读新出的章节
```

**特性2：顺序保证**
```
严格按版本号顺序执行

错误示例：
V1 → V3 → V2  ❌ 乱序执行会报错

正确执行：
V1 → V2 → V3  ✅ 必须递增

原因：
后面的脚本可能依赖前面的表结构
```

**特性3：失败处理**
```
如果某个脚本执行失败：

行为：
1. 记录失败状态
2. 停止后续脚本执行
3. 应用启动失败

下次启动：
1. 检测到失败记录
2. 必须先修复问题
3. 才能继续执行

保证：数据库状态的一致性
```

### 4.7 常用配置详解


```yaml
spring:
  flyway:
    # 是否启用Flyway
    enabled: true
    
    # 迁移脚本位置（支持多个）
    locations: classpath:db/migration
    
    # 首次运行时建立基线版本
    baseline-on-migrate: true
    
    # 基线版本号
    baseline-version: 1
    
    # 是否在迁移时验证
    validate-on-migrate: true
    
    # 是否允许乱序迁移
    out-of-order: false
    
    # 占位符替换
    placeholder-replacement: true
    placeholders:
      table-prefix: t_
```

**配置说明**：
- `baseline-on-migrate`：对于已有数据库很重要，设为true表示把当前状态作为起点
- `out-of-order`：设为false防止开发人员插入旧版本号的脚本
- `placeholders`：可以在SQL中使用`${table-prefix}`这样的占位符

---

## 5. 🔄 Liquibase迁移工具


### 5.1 Liquibase vs Flyway


**形象对比**：
```
Flyway：
写SQL脚本 → 直接执行
优势：简单直接，SQL熟悉
劣势：数据库方言不同

Liquibase：
写XML/YAML/JSON配置 → 转换成SQL → 执行
优势：跨数据库兼容
劣势：学习成本高
```

**选择建议**：
- **只用MySQL？** → 选Flyway，简单够用
- **多种数据库？** → 选Liquibase，一次编写到处运行
- **团队SQL强？** → 选Flyway
- **追求标准化？** → 选Liquibase

### 5.2 Liquibase快速上手


**添加依赖**：
```xml
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
```

**配置Liquibase**：
```yaml
spring:
  liquibase:
    enabled: true
    change-log: classpath:db/changelog/db.changelog-master.yaml
```

### 5.3 Liquibase脚本格式


**方式1：YAML格式（推荐新手）**
```yaml
# db.changelog-master.yaml
databaseChangeLog:
  - changeSet:
      id: 1
      author: zhangsan
      changes:
        - createTable:
            tableName: user
            columns:
              - column:
                  name: id
                  type: bigint
                  autoIncrement: true
                  constraints:
                    primaryKey: true
              - column:
                  name: username
                  type: varchar(50)
                  constraints:
                    nullable: false
              - column:
                  name: email
                  type: varchar(100)
```

**方式2：XML格式**
```xml
<databaseChangeLog>
    <changeSet id="1" author="zhangsan">
        <createTable tableName="user">
            <column name="id" type="bigint" autoIncrement="true">
                <constraints primaryKey="true"/>
            </column>
            <column name="username" type="varchar(50)">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>
</databaseChangeLog>
```

**方式3：SQL格式（最直接）**
```sql
--liquibase formatted sql
--changeset zhangsan:1
CREATE TABLE user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100)
);
```

### 5.4 Liquibase核心概念


**changeSet的理解**：
```
changeSet = 一个变更单元

类比：
Git commit = 一次代码提交
changeSet = 一次数据库变更

每个changeSet包含：
- id：唯一标识（类似commit hash）
- author：作者
- changes：具体变更内容
```

**示例：添加字段**
```yaml
- changeSet:
    id: 2
    author: lisi
    changes:
      - addColumn:
          tableName: user
          columns:
            - column:
                name: age
                type: int
                defaultValue: 0
```

### 5.5 Liquibase的跨数据库特性


**同一个配置，适配不同数据库**：

```yaml
# 添加当前时间戳字段
- changeSet:
    id: 3
    author: wangwu
    changes:
      - addColumn:
          tableName: user
          columns:
            - column:
                name: created_at
                type: timestamp
                defaultValueComputed: CURRENT_TIMESTAMP
```

**实际生成的SQL**：
```sql
-- MySQL
ALTER TABLE user ADD created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- PostgreSQL  
ALTER TABLE user ADD created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Oracle
ALTER TABLE user ADD created_at TIMESTAMP DEFAULT SYSTIMESTAMP;

Liquibase自动适配！
```

### 5.6 回滚脚本编写


**Liquibase的回滚优势**：

```yaml
- changeSet:
    id: 4
    author: zhaoliu
    changes:
      - addColumn:
          tableName: user
          columns:
            - column:
                name: phone
                type: varchar(20)
    rollback:
      - dropColumn:
          tableName: user
          columnName: phone
```

**回滚命令**：
```bash
# 回滚到指定标签
liquibase rollback tag_v1.0

# 回滚指定数量的changeSet
liquibase rollback-count 3
```

---

## 6. 📁 版本化脚本管理


### 6.1 脚本组织最佳实践


**目录结构设计**：
```
resources/db/
├── migration/              # Flyway脚本
│   ├── V1.0__baseline.sql
│   ├── V1.1__add_user_age.sql
│   └── V2.0__create_order.sql
│
└── changelog/              # Liquibase脚本
    ├── db.changelog-master.yaml
    ├── changes/
    │   ├── v1.0-init.yaml
    │   ├── v1.1-user.yaml
    │   └── v2.0-order.yaml
    └── rollback/
        └── v2.0-rollback.sql
```

### 6.2 版本号命名策略


**语义化版本控制**：
```
版本号格式：V主版本.次版本.修订号

V1.0__init_schema.sql          # 主版本：大功能
V1.1__add_user_fields.sql      # 次版本：新增功能
V1.1.1__fix_user_index.sql     # 修订号：bug修复

规则：
主版本：不兼容的大改动
次版本：兼容的功能增加
修订号：bug修复
```

**环境标识策略**：
```
开发环境：V1.0.0__DEV__init.sql
测试环境：V1.0.0__TEST__init.sql
生产环境：V1.0.0__PROD__init.sql

好处：
- 清楚知道脚本用于哪个环境
- 防止误执行
```

### 6.3 团队协作规范


**多人开发的版本号冲突**：

```
场景：
小张：写了V5__add_user_phone.sql
小李：也写了V5__add_user_email.sql

问题：版本号冲突！

解决方案1：时间戳
V20250923100000__add_user_phone.sql
V20250923110000__add_user_email.sql

解决方案2：开发分支号
V5.1__zhangsan__add_user_phone.sql
V5.2__lisi__add_user_email.sql

解决方案3：功能模块
V5__user__add_phone.sql
V6__order__add_status.sql
```

**分支合并策略**：
```
功能分支：
feature-user/
  └── V100__add_user_vip.sql

主分支合并时：
重新编号为正式版本号
V100 → V6__add_user_vip.sql

避免版本号混乱
```

### 6.4 Git集成管理


**将迁移脚本纳入版本控制**：

```bash
# .gitignore不要忽略迁移脚本
!db/migration/**
!db/changelog/**

# 提交规范
git add db/migration/V6__add_user_vip.sql
git commit -m "feat: 添加用户VIP功能迁移脚本"
git push
```

**代码审查要点**：
```
审查清单：
✅ 版本号是否递增
✅ 命名是否规范
✅ SQL语法是否正确
✅ 是否有回滚脚本
✅ 是否考虑数据迁移
✅ 是否有注释说明
```

---

## 7. ↩️ 回滚策略设计


### 7.1 为什么需要回滚


**生产事故场景**：
```
晚上8点：部署新版本，执行迁移脚本
晚上9点：发现严重bug，必须回滚
问题：数据库已经改了，怎么恢复？

没有回滚脚本：
- 手忙脚乱写临时SQL
- 可能写错，雪上加霜
- 回滚时间长，损失大

有回滚脚本：
- 一键执行回滚
- 快速恢复服务
- 损失最小化
```

### 7.2 Flyway回滚脚本


**Flyway的回滚方案**：

Flyway Community版本不直接支持回滚，需要手动编写：

```
每个迁移脚本对应一个回滚脚本：

正向迁移：
V6__add_user_vip.sql
    ↓
回滚脚本：
V6__add_user_vip_rollback.sql（手动命名）

或使用：
R__rollback_v6.sql（R开头表示可重复执行）
```

**正向脚本示例**：
```sql
-- V6__add_user_vip.sql
ALTER TABLE user ADD COLUMN vip_level INT DEFAULT 0;
CREATE INDEX idx_vip_level ON user(vip_level);
```

**对应回滚脚本**：
```sql
-- R__rollback_v6.sql
DROP INDEX idx_vip_level ON user;
ALTER TABLE user DROP COLUMN vip_level;
```

### 7.3 Liquibase回滚设计


**内置回滚支持**：

```yaml
- changeSet:
    id: 6
    author: developer
    changes:
      # 正向变更
      - addColumn:
          tableName: user
          columns:
            - column:
                name: vip_level
                type: int
                defaultValue: 0
      - createIndex:
          indexName: idx_vip_level
          tableName: user
          columns:
            - column:
                name: vip_level
    
    # 回滚逻辑
    rollback:
      - dropIndex:
          indexName: idx_vip_level
          tableName: user
      - dropColumn:
          tableName: user
          columnName: vip_level
```

**自动回滚（简单操作）**：
```yaml
# Liquibase能自动推断的操作
- changeSet:
    id: 7
    author: dev
    changes:
      - addColumn:  # 自动回滚为dropColumn
          tableName: user
          columns:
            - column:
                name: phone
                type: varchar(20)
    # rollback会自动生成
```

### 7.4 数据迁移的回滚


**涉及数据变更的回滚策略**：

**场景：字段改名**
```sql
-- 正向迁移：V8__rename_phone_to_mobile.sql
-- 步骤1：新增mobile字段
ALTER TABLE user ADD COLUMN mobile VARCHAR(20);

-- 步骤2：复制数据
UPDATE user SET mobile = phone;

-- 步骤3：删除旧字段
ALTER TABLE user DROP COLUMN phone;

-- 问题：删除phone后，数据无法恢复！
```

**安全的数据迁移方案**：
```sql
-- V8__add_mobile_column.sql（第一步）
ALTER TABLE user ADD COLUMN mobile VARCHAR(20);
UPDATE user SET mobile = phone WHERE phone IS NOT NULL;

-- 回滚V8：
ALTER TABLE user DROP COLUMN mobile;

-- V9__deprecate_phone.sql（第二步，观察期）
-- 标记phone字段已废弃，但保留
ALTER TABLE user ADD COLUMN phone_deprecated BOOLEAN DEFAULT TRUE;

-- 观察一段时间没问题后
-- V10__drop_phone.sql（第三步）
ALTER TABLE user DROP COLUMN phone;
```

**核心原则**：
- **不要立即删除数据**
- **分步执行，每步可回滚**
- **保留过渡期，便于恢复**

### 7.5 回滚演练


**定期演练回滚流程**：

```bash
# 开发环境演练

# 1. 执行迁移
应用启动 → 执行V6迁移

# 2. 模拟发现问题
发现bug，需要回滚

# 3. 执行回滚（Flyway）
手动执行回滚脚本：
mysql -u root -p < R__rollback_v6.sql

# 4. 执行回滚（Liquibase）
liquibase rollback-count 1

# 5. 验证回滚结果
检查数据库结构和数据
```

**回滚检查清单**：
```
回滚前确认：
□ 回滚脚本已测试
□ 数据备份已完成
□ 影响范围已评估
□ 回滚时间窗口已确定

回滚后验证：
□ 数据库结构正确
□ 关键数据完整
□ 应用能正常启动
□ 功能测试通过
```

---

## 8. 🏭 生产环境迁移实战


### 8.1 生产迁移前准备


**全面的检查清单**：

```
上线前一天：
✅ 迁移脚本已通过测试环境验证
✅ 回滚脚本已编写并测试
✅ 数据库备份策略已确认
✅ 迁移时间窗口已申请
✅ 相关人员已通知待命

上线前2小时：
✅ 完整备份生产数据库
✅ 验证备份文件可用
✅ 检查数据库磁盘空间
✅ 检查应用服务状态
```

**备份脚本示例**：
```bash
#!/bin/bash
# backup-before-migration.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/db"
DB_NAME="production_db"

# 全量备份
mysqldump -u root -p${DB_PASSWORD} \
  --single-transaction \
  --routines \
  --triggers \
  ${DB_NAME} > ${BACKUP_DIR}/backup_${DATE}.sql

# 压缩备份文件
gzip ${BACKUP_DIR}/backup_${DATE}.sql

# 验证备份文件
if [ -f "${BACKUP_DIR}/backup_${DATE}.sql.gz" ]; then
    echo "备份成功: backup_${DATE}.sql.gz"
else
    echo "备份失败！"
    exit 1
fi
```

### 8.2 迁移执行步骤


**标准迁移流程**：

```
第1步：停止应用服务
systemctl stop myapp

第2步：备份数据库
./backup-before-migration.sh

第3步：执行迁移
方式1（自动）：启动应用，Flyway自动执行
方式2（手动）：先手动执行SQL，再启动应用

第4步：验证迁移结果
检查flyway_schema_history表
查询新表/新字段

第5步：启动应用
systemctl start myapp

第6步：冒烟测试
curl http://localhost:8080/health
测试关键业务功能
```

### 8.3 分批迁移策略


**大表迁移的分批方案**：

```sql
-- 场景：给千万级用户表添加字段

-- ❌ 错误做法（一次性）
ALTER TABLE user ADD COLUMN vip_level INT;  
-- 锁表时间长，影响业务

-- ✅ 正确做法（分批）
-- 第1步：添加字段（允许NULL）
ALTER TABLE user ADD COLUMN vip_level INT NULL;

-- 第2步：分批更新数据（避免长事务）
-- 每次更新10万条
UPDATE user SET vip_level = 0 
WHERE id BETWEEN 1 AND 100000 
AND vip_level IS NULL;

UPDATE user SET vip_level = 0 
WHERE id BETWEEN 100001 AND 200000 
AND vip_level IS NULL;
-- ... 继续分批

-- 第3步：最后设置NOT NULL
ALTER TABLE user MODIFY COLUMN vip_level INT NOT NULL DEFAULT 0;
```

**分批脚本示例**：
```bash
#!/bin/bash
# batch-update.sh

BATCH_SIZE=100000
MAX_ID=$(mysql -u root -p${DB_PASSWORD} -sN -e \
  "SELECT MAX(id) FROM user")

for ((i=1; i<=$MAX_ID; i+=$BATCH_SIZE)); do
    END=$((i + BATCH_SIZE - 1))
    echo "更新ID ${i} 到 ${END}"
    
    mysql -u root -p${DB_PASSWORD} <<EOF
        UPDATE user 
        SET vip_level = 0 
        WHERE id BETWEEN $i AND $END 
        AND vip_level IS NULL;
EOF
    
    sleep 1  # 避免数据库压力过大
done
```

### 8.4 零停机迁移方案


**蓝绿部署 + 数据库迁移**：

```
传统方案（需要停机）：
停服务 → 改数据库 → 启服务

零停机方案：
第1步：数据库向后兼容变更
- 只新增，不删除
- 新旧字段同时存在

第2步：部署新版应用（蓝绿）
- 旧版本继续运行（绿）
- 新版本部署完成（蓝）
- 逐步切流量到新版本

第3步：清理旧字段（下次迁移）
- 确认旧版本完全下线
- 再删除废弃字段
```

**示例：字段改名（零停机）**
```sql
-- V8__add_mobile_keep_phone.sql（向后兼容）
ALTER TABLE user ADD COLUMN mobile VARCHAR(20);

-- 应用层同时写入phone和mobile
UPDATE user SET mobile = phone WHERE mobile IS NULL;

-- 新版本应用：只使用mobile字段
-- 旧版本应用：仍使用phone字段
-- 两个版本共存

-- 等旧版本完全下线后（下个版本）
-- V9__drop_phone.sql
ALTER TABLE user DROP COLUMN phone;
```

### 8.5 迁移监控和报警


**迁移过程监控**：

```yaml
# 监控指标
migration:
  metrics:
    - migration_duration_seconds  # 迁移耗时
    - migration_success_count     # 成功次数
    - migration_failure_count     # 失败次数
    - database_lock_duration      # 锁表时长
```

**报警规则**：
```yaml
alerts:
  - name: MigrationTimeout
    condition: migration_duration > 300s
    action: 发送钉钉/邮件通知
  
  - name: MigrationFailed
    condition: migration_failure_count > 0
    action: 立即通知，自动回滚
```

### 8.6 应急回滚预案


**快速回滚流程**：

```bash
#!/bin/bash
# emergency-rollback.sh

echo "开始应急回滚..."

# 1. 停止应用
systemctl stop myapp
echo "应用已停止"

# 2. 恢复数据库备份
LATEST_BACKUP=$(ls -t /backup/db/*.sql.gz | head -1)
echo "使用备份: $LATEST_BACKUP"

gunzip < $LATEST_BACKUP | mysql -u root -p${DB_PASSWORD} production_db
echo "数据库已回滚"

# 3. 启动应用（旧版本）
systemctl start myapp
echo "应用已启动"

# 4. 验证
curl -f http://localhost:8080/health || echo "健康检查失败！"
```

### 8.7 迁移后验证


**全面的验证清单**：

```
数据库层验证：
✅ 表结构是否正确
   DESCRIBE user;

✅ 索引是否创建
   SHOW INDEX FROM user;

✅ 约束是否生效
   SHOW CREATE TABLE user;

✅ 数据完整性检查
   SELECT COUNT(*) FROM user;
   SELECT COUNT(*) FROM user WHERE mobile IS NULL;

应用层验证：
✅ 应用是否正常启动
✅ 日志无异常错误
✅ 关键接口可用
✅ 业务流程正常

性能验证：
✅ 查询响应时间正常
✅ 数据库CPU/内存正常
✅ 慢查询日志检查
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


**数据库迁移的本质**：
```
🔸 版本化管理数据库结构变更
🔸 团队协作的数据库同步机制  
🔸 可追溯、可回滚的变更记录
🔸 自动化的生产部署流程
```

**工具选择原则**：
```
Flyway适用：
✅ 单一数据库类型（如只用MySQL）
✅ 团队SQL能力强
✅ 追求简单直接

Liquibase适用：
✅ 多种数据库（MySQL + PostgreSQL + Oracle）
✅ 需要跨数据库兼容
✅ 追求标准化
```

### 9.2 关键实践要点


**ddl-auto的正确使用**：
```
开发环境：
spring.jpa.hibernate.ddl-auto=update  # 快速迭代

测试环境：
spring.jpa.hibernate.ddl-auto=validate  # 验证一致性

生产环境：
spring.jpa.hibernate.ddl-auto=none  # 禁用自动建表
使用迁移工具管理！
```

**迁移脚本编写规范**：
```
✅ 命名规范：V版本号__描述.sql
✅ 幂等性：可重复执行不出错
✅ 原子性：一个脚本一个功能
✅ 向后兼容：先加后减
✅ 数据安全：分步删除，保留过渡期
```

**回滚策略设计**：
```
🔸 每个迁移脚本都要有对应回滚脚本
🔸 涉及数据变更的要分步执行
🔸 定期演练回滚流程
🔸 生产迁移前必须备份
```

### 9.3 生产环境最佳实践


**迁移前准备**：
```
必做清单：
□ 完整备份数据库
□ 验证备份可用
□ 编写回滚脚本
□ 在测试环境充分验证
□ 申请维护时间窗口
□ 准备应急回滚预案
```

**执行原则**：
```
🔸 小步快跑：一次改动不要太大
🔸 灰度发布：先小流量验证
🔸 可观测性：记录详细日志
🔸 快速回滚：出问题立即回退
```

### 9.4 常见错误避免


**新手容易犯的错误**：

```
❌ 生产用ddl-auto=update
→ 导致数据丢失、结构错乱

❌ 直接删除字段/表
→ 应该先废弃，观察期后再删

❌ 大表一次性修改
→ 应该分批执行，避免长时间锁表

❌ 没有回滚脚本
→ 出问题手忙脚乱

❌ 迁移脚本版本号冲突
→ 团队协作要规范命名
```

### 9.5 学习路径建议


**从简单到复杂**：

```
第1步：本地开发体验
使用Flyway，编写简单的建表脚本

第2步：团队协作实践
规范版本号，编写回滚脚本

第3步：生产环境部署
完整流程：备份→迁移→验证→回滚演练

第4步：高级特性
零停机迁移、分批更新、监控报警
```

**核心记忆口诀**：
```
数据库迁移像Git管，
版本控制不会乱。
生产环境要谨慎，
备份回滚是关键。
小步快跑分批改，
安全第一记心间！
```