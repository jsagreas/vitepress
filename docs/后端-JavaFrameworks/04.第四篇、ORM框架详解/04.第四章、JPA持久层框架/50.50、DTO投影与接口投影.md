---
title: 50、DTO投影与接口投影
---
## 📚 目录

1. [投影查询是什么](#1-投影查询是什么)
2. [为什么需要投影查询](#2-为什么需要投影查询)
3. [接口投影详解](#3-接口投影详解)
4. [类投影详解](#4-类投影详解)
5. [动态投影](#5-动态投影)
6. [SpEL表达式投影](#6-spel表达式投影)
7. [最佳实践与总结](#7-最佳实践与总结)

---

## 1. 🎯 投影查询是什么


### 1.1 生活中的类比


**想象一下去图书馆借书**：
```
场景1：完整借阅
管理员：把整本书都给你 📚
你：我只想看第3章...

场景2：按需获取
管理员：只复印第3章给你 📄
你：完美！省时省力

投影查询就是"场景2"！
```

**🔸 通俗理解**
- **普通查询**：查整个实体对象，像搬回整本百科全书
- **投影查询**：只查需要的字段，像只复印需要的那几页
- **核心目的**：只拿需要的数据，节省内存和网络传输

### 1.2 什么是投影（Projection）


**投影的本质**：从数据库表中"投射"出部分列，而不是查询所有列

```
数据库表 User（完整数据）
┌────┬──────┬───────┬─────────┬─────┬────────┐
│ id │ name │ email │ address │ age │ phone  │
├────┼──────┼───────┼─────────┼─────┼────────┤
│ 1  │ 张三 │ xxx   │ 北京... │ 25  │ 138... │
└────┴──────┴───────┴─────────┴─────┴────────┘
                ↓ 投影查询
            只取需要的列
                ↓
投影结果（只有name和email）
┌──────┬───────┐
│ name │ email │
├──────┼───────┤
│ 张三 │ xxx   │
└──────┴───────┘

省略了：id、address、age、phone
```

---

## 2. 💡 为什么需要投影查询


### 2.1 解决的核心问题


**问题场景**：假设User实体有20个字段，但页面只需要显示姓名和邮箱

```
❌ 不使用投影的问题：
• 查询了全部20个字段
• 占用更多内存
• 网络传输数据量大
• 前端可能看到不该看的数据

✅ 使用投影的优势：
• 只查询2个需要的字段
• 内存占用减少90%
• 网络传输更快
• 数据安全性更好
```

### 2.2 实际应用价值


| 场景 | **不用投影** | **使用投影** | **提升效果** |
|------|------------|------------|------------|
| 📱 **用户列表** | `查询User全部字段` | `只查name、avatar` | `减少80%数据量` |
| 📊 **数据统计** | `查询Order完整对象` | `只查amount、date` | `查询速度提升3倍` |
| 🔍 **搜索建议** | `返回全部商品信息` | `只返回id、name` | `响应时间减半` |
| 📈 **报表导出** | `加载所有关联数据` | `只取必要字段` | `内存节省70%` |

**🎯 核心收益**
- **性能提升**：减少数据传输，加快查询速度
- **内存优化**：只加载需要的字段到内存
- **安全增强**：避免敏感字段泄露
- **代码清晰**：明确表达查询意图

---

## 3. 🔌 接口投影详解


### 3.1 什么是接口投影


**基本概念**：通过接口定义需要查询的字段，Spring Data JPA自动实现

```
简单理解：
你定义一个"数据模板"（接口）
告诉JPA："我只要这几个字段"
JPA自动帮你查询并封装数据

就像点外卖：
你：我要一份套餐A（接口定义）
店家：好的，按配方准备（JPA自动查询）
你：收到套餐A（结果封装）
```

### 3.2 接口投影的使用方式


**📝 步骤1：定义投影接口**

```java
// 用户基本信息投影（只要姓名和邮箱）
public interface UserBasicInfo {
    String getName();    // 对应User实体的name字段
    String getEmail();   // 对应User实体的email字段
}
```

**💡 命名规则**
- 方法名必须是 `get + 字段名（首字母大写）`
- 字段名要与实体类属性名一致
- 返回值类型要与实体字段类型匹配

**📝 步骤2：在Repository中使用**

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 返回接口投影
    List<UserBasicInfo> findByAge(Integer age);
    
    // 单个结果
    UserBasicInfo findByEmail(String email);
}
```

**📝 步骤3：使用查询结果**

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void showUserList() {
        List<UserBasicInfo> users = userRepository.findByAge(25);
        
        for (UserBasicInfo user : users) {
            // 只能访问接口定义的方法
            System.out.println(user.getName());   // ✓ 可以
            System.out.println(user.getEmail());  // ✓ 可以
            // System.out.println(user.getAge()); // ✗ 编译错误
        }
    }
}
```

### 3.3 接口投影的工作原理


```
执行流程：

1. 你调用：findByAge(25)
   ↓
2. JPA分析：UserBasicInfo接口有哪些方法
   ↓
3. 生成SQL：SELECT name, email FROM user WHERE age = 25
   ↓
4. 查询数据库：只查询name和email两列
   ↓
5. 封装结果：创建代理对象实现UserBasicInfo接口
   ↓
6. 返回给你：List<UserBasicInfo>

关键点：JPA生成的是代理对象，不是真实类！
```

### 3.4 嵌套投影（关联查询）


**场景**：查询用户及其所属部门名称

```java
// 投影接口定义
public interface UserWithDept {
    String getName();
    DeptInfo getDepartment();  // 嵌套投影
    
    interface DeptInfo {
        String getDeptName();
    }
}

// 使用
List<UserWithDept> users = userRepository.findAll();
for (UserWithDept user : users) {
    System.out.println(user.getName());
    System.out.println(user.getDepartment().getDeptName());
}
```

**🔍 生成的SQL**
```sql
SELECT 
    u.name,
    d.dept_name
FROM user u
LEFT JOIN department d ON u.dept_id = d.id
```

---

## 4. 📦 类投影详解


### 4.1 什么是类投影（DTO投影）


**核心概念**：用一个普通Java类（DTO）来接收查询结果

```
对比理解：

接口投影：
• JPA生成代理对象
• 方法名必须严格匹配
• 不能添加自定义逻辑

类投影：
• 使用真实的Java类
• 可以添加自定义方法
• 更灵活，可序列化
```

### 4.2 类投影的实现方式


**📝 步骤1：创建DTO类**

```java
// 用户基本信息DTO
public class UserBasicDTO {
    private String name;
    private String email;
    
    // 必须有对应的构造方法！
    public UserBasicDTO(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    // Getter方法
    public String getName() { return name; }
    public String getEmail() { return email; }
    
    // 可以添加自定义方法
    public String getDisplayName() {
        return "用户：" + name;
    }
}
```

**⚠️ 关键要求**
- 必须有构造方法，参数顺序要与查询字段顺序一致
- 必须有对应的Getter方法
- 可以添加额外的业务方法

**📝 步骤2：使用JPQL查询**

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 使用new关键字指定DTO类
    @Query("SELECT new com.example.dto.UserBasicDTO(u.name, u.email) " +
           "FROM User u WHERE u.age = ?1")
    List<UserBasicDTO> findUserBasicInfo(Integer age);
}
```

**💡 JPQL中的要点**
- 使用 `new` 关键字
- 后面跟DTO类的完整包名
- 括号内是构造方法的参数
- 参数顺序必须与构造方法一致

### 4.3 类投影 vs 接口投影对比


| 特性 | **接口投影** | **类投影（DTO）** |
|------|------------|----------------|
| 📝 **定义方式** | `定义接口` | `定义普通类` |
| 🔧 **实现方式** | `JPA生成代理` | `使用真实对象` |
| 💾 **序列化** | `❌ 代理对象不易序列化` | `✅ 可直接序列化` |
| 🎨 **自定义方法** | `❌ 不能添加` | `✅ 可以添加` |
| 📊 **性能** | `略快（无构造开销）` | `略慢（需构造对象）` |
| 🔍 **查询方式** | `方法名自动推导` | `需写JPQL` |
| 🛠️ **使用场景** | `简单字段查询` | `需要业务处理的场景` |

**🎯 选择建议**
```
使用接口投影：
• 只是简单的字段获取
• 不需要序列化
• 追求极致性能

使用类投影：
• 需要返回给前端（JSON序列化）
• 需要添加业务逻辑
• 需要在多处复用DTO
```

---

## 5. 🔄 动态投影


### 5.1 什么是动态投影


**核心问题**：有时候同一个查询，不同场景需要不同的字段

```
问题场景：

场景A：用户列表页
需要：id、name、email

场景B：用户详情页  
需要：id、name、email、phone、address

场景C：用户统计页
需要：id、name、age

传统做法：写3个方法 😫
动态投影：写1个方法，传入不同类型 😎
```

### 5.2 动态投影的实现


**📝 定义多个投影接口**

```java
// 基本信息
public interface UserBasic {
    String getName();
    String getEmail();
}

// 详细信息
public interface UserDetail {
    String getName();
    String getEmail();
    String getPhone();
    String getAddress();
}

// 统计信息
public interface UserStats {
    String getName();
    Integer getAge();
}
```

**📝 Repository使用泛型**

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 神奇的泛型方法！
    <T> List<T> findByAge(Integer age, Class<T> type);
    
    // 单个结果
    <T> T findByEmail(String email, Class<T> type);
}
```

**📝 灵活调用**

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // 场景A：列表页
    public List<UserBasic> getUserList() {
        return userRepository.findByAge(25, UserBasic.class);
    }
    
    // 场景B：详情页
    public List<UserDetail> getUserDetail() {
        return userRepository.findByAge(25, UserDetail.class);
    }
    
    // 场景C：统计页
    public List<UserStats> getUserStats() {
        return userRepository.findByAge(25, UserStats.class);
    }
}
```

**🔍 执行效果**
```
调用 findByAge(25, UserBasic.class)
→ SQL: SELECT name, email FROM user WHERE age = 25

调用 findByAge(25, UserDetail.class)  
→ SQL: SELECT name, email, phone, address FROM user WHERE age = 25

调用 findByAge(25, UserStats.class)
→ SQL: SELECT name, age FROM user WHERE age = 25

同一个方法，不同的投影类型，生成不同的SQL！
```

### 5.3 动态投影的优势


```
✅ 代码复用
• 一个方法满足多种需求
• 减少Repository方法数量

✅ 灵活性强
• 运行时决定返回哪些字段
• 适应不同业务场景

✅ 维护简单
• 查询逻辑只写一次
• 新增投影类型无需改代码
```

---

## 6. 🎨 SpEL表达式投影


### 6.1 什么是SpEL投影


**SpEL（Spring Expression Language）**：Spring的表达式语言，可以在投影中做计算和拼接

```
普通投影：只能获取字段原值
SpEL投影：可以对字段进行加工处理

类比：
普通投影：菜市场买菜（原材料）
SpEL投影：外卖点餐（加工好的成品）
```

### 6.2 使用@Value注解


**📝 基本使用**

```java
public interface UserProjection {
    
    // 直接获取字段
    String getName();
    
    // 使用SpEL拼接字符串
    @Value("#{target.name + ' (' + target.email + ')'}")
    String getDisplayName();
    
    // 计算年龄段
    @Value("#{target.age >= 18 ? '成年' : '未成年'}")
    String getAgeGroup();
}
```

**💡 SpEL语法说明**
- `#{...}`：SpEL表达式标记
- `target`：代表当前实体对象
- `+`：字符串拼接
- `? :`：三元运算符

**📝 调用示例**

```java
List<UserProjection> users = userRepository.findAll();
for (UserProjection user : users) {
    System.out.println(user.getName());         // 张三
    System.out.println(user.getDisplayName());  // 张三 (zhangsan@example.com)
    System.out.println(user.getAgeGroup());     // 成年
}
```

### 6.3 复杂SpEL表达式


**📊 数值计算**

```java
public interface OrderProjection {
    
    // 原始字段
    BigDecimal getPrice();
    Integer getQuantity();
    
    // 计算总价
    @Value("#{target.price * target.quantity}")
    BigDecimal getTotalAmount();
    
    // 计算折扣后价格
    @Value("#{target.price * 0.8}")
    BigDecimal getDiscountPrice();
}
```

**🔗 调用实体方法**

```java
// User实体类中的方法
public class User {
    private String firstName;
    private String lastName;
    
    public String getFullName() {
        return firstName + " " + lastName;
    }
}

// 投影接口
public interface UserProjection {
    
    // 调用实体的方法
    @Value("#{target.getFullName()}")
    String getFullName();
    
    // 调用并转换
    @Value("#{target.getFullName().toUpperCase()}")
    String getFullNameUpper();
}
```

### 6.4 SpEL投影的适用场景


| 场景 | **SpEL表达式示例** | **说明** |
|------|----------------|---------|
| 🔤 **字符串拼接** | `"#{target.name + ' - ' + target.code}"` | `组合显示` |
| 🔢 **数值计算** | `"#{target.price * target.quantity}"` | `计算总价` |
| 📅 **日期格式化** | `"#{target.date?.format('yyyy-MM-dd')}"` | `格式化日期` |
| ✅ **条件判断** | `"#{target.status == 1 ? '启用' : '禁用'}"` | `状态转换` |
| 🔗 **方法调用** | `"#{target.getName().toUpperCase()}"` | `调用方法` |

**⚠️ 使用注意**
```
优点：
• 灵活处理数据
• 减少业务层代码
• 表达力强

缺点：
• 性能略低于普通投影
• 表达式复杂时难维护
• 调试不够直观

建议：
• 简单计算和拼接 → 使用SpEL
• 复杂业务逻辑 → 放到Service层
```

---

## 7. 📋 最佳实践与总结


### 7.1 投影类型选择指南


```
决策树：

需要返回给前端？
├─ 是 → 使用类投影（DTO）
│         便于JSON序列化
│
└─ 否 → 继续判断
        │
        需要添加自定义逻辑？
        ├─ 是 → 使用类投影（DTO）
        │         可添加业务方法
        │
        └─ 否 → 继续判断
                │
                需要动态选择字段？
                ├─ 是 → 使用动态投影
                │         运行时决定
                │
                └─ 否 → 使用接口投影
                        最简单最快
```

### 7.2 性能优化技巧


**🚀 优化策略**

| 优化点 | **做法** | **效果** |
|-------|---------|---------|
| **选择字段** | `只查询必需字段` | `减少数据传输量` |
| **避免N+1** | `用JOIN FETCH处理关联` | `减少数据库查询次数` |
| **分页查询** | `配合Pageable使用` | `避免一次加载过多数据` |
| **缓存结果** | `@Cacheable标注方法` | `重复查询直接返回缓存` |

**📝 优化示例**

```java
// ❌ 不好的做法
@Query("SELECT u FROM User u")
List<User> findAll();  // 查询所有字段

// ✅ 好的做法
@Query("SELECT new com.example.dto.UserDTO(u.id, u.name) FROM User u")
List<UserDTO> findAllBasic();  // 只查需要的

// ✅ 更好的做法：分页
Page<UserDTO> findAllBasic(Pageable pageable);
```

### 7.3 常见问题与解决方案


**❓ 问题1：接口投影返回null**

```java
// 原因：字段名不匹配
public interface UserInfo {
    String getUserName();  // ❌ 实体字段是name
}

// 解决：使用@Value指定
public interface UserInfo {
    @Value("#{target.name}")
    String getUserName();  // ✅ 明确指定
}
```

**❓ 问题2：类投影构造器报错**

```java
// 原因：JPQL中参数顺序错误
@Query("SELECT new UserDTO(u.email, u.name) ...")  // ❌ 顺序反了

// 解决：与构造器参数顺序一致
public UserDTO(String name, String email) { ... }
@Query("SELECT new UserDTO(u.name, u.email) ...")  // ✅ 顺序正确
```

**❓ 问题3：动态投影类型转换失败**

```java
// 原因：投影接口字段类型不匹配
public interface UserInfo {
    Integer getName();  // ❌ name是String类型
}

// 解决：类型保持一致
public interface UserInfo {
    String getName();   // ✅ 与实体字段类型一致
}
```

### 7.4 核心要点总结


**🔸 投影查询的本质**
```
投影 = 只查询需要的字段
目的 = 降低内存占用 + 提升查询性能
原理 = 生成SELECT指定字段的SQL
```

**🔸 三种投影方式对比**

```
接口投影：
✅ 简单易用，代码最少
✅ 性能最优
❌ 功能有限

类投影（DTO）：
✅ 可添加业务逻辑
✅ 便于序列化
❌ 需要写JPQL

动态投影：
✅ 一个方法多种用途
✅ 运行时决定字段
❌ 需要传入Class参数
```

**🔸 使用建议**

| 场景 | **推荐方案** | **理由** |
|------|-----------|---------|
| 📱 **前端接口** | `类投影（DTO）` | `便于JSON序列化` |
| 📊 **内部查询** | `接口投影` | `简单高效` |
| 🔄 **多场景复用** | `动态投影` | `灵活适配` |
| 🎨 **字段加工** | `SpEL投影` | `表达力强` |

**🎯 记忆口诀**
```
投影查询省内存，只取所需最关键
接口简单类灵活，动态投影一当三
SpEL表达式能计算，选对方式事半功
```

**核心记住**：
- 投影就是"只查需要的列"
- 接口投影最简单，类投影最灵活，动态投影最通用
- 根据场景选择合适的投影方式
- 记得只查询必要字段，避免内存浪费