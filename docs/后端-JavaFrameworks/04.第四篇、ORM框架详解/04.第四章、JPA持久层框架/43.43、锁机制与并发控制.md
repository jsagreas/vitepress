---
title: 43、锁机制与并发控制
---
## 📚 目录

1. [并发问题的本质](#1-并发问题的本质)
2. [乐观锁机制](#2-乐观锁机制)
3. [悲观锁机制](#3-悲观锁机制)
4. [锁模式详解](#4-锁模式详解)
5. [死锁问题处理](#5-死锁问题处理)
6. [并发控制策略](#6-并发控制策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 并发问题的本质


### 1.1 什么是并发问题


> **💡 生活中的例子**
> 
> 想象你和室友同时要用洗衣机：
> - 你看到洗衣机是空的，准备放衣服
> - 室友也看到是空的，也准备放衣服
> - 结果两个人的衣服混在一起洗了
> 
> 这就是典型的**并发冲突**！

**🔸 数据库中的并发问题**

```
情况一：丢失更新
时间线：
9:00  用户A读取账户余额：1000元
9:01  用户B读取账户余额：1000元
9:02  用户A存入500元，更新为1500元
9:03  用户B取出200元，更新为800元
结果：用户A的500元丢失了！

情况二：脏读
时间线：
9:00  用户A将商品价格改为100元（未提交）
9:01  用户B读取到价格100元
9:02  用户A回滚事务，价格恢复200元
结果：用户B读到了不存在的数据！
```

### 1.2 为什么需要锁机制


| 问题类型 | **描述** | **后果** | **解决方案** |
|---------|---------|---------|------------|
| 🔴 **丢失更新** | `两个事务同时修改同一数据` | `后提交的覆盖先提交的` | `加锁控制` |
| 🟡 **脏读** | `读到未提交的数据` | `读到不存在的数据` | `隔离级别控制` |
| 🟠 **不可重复读** | `同一事务内多次读取结果不同` | `数据不一致` | `锁定读取的行` |
| 🟣 **幻读** | `事务中出现新的符合条件的行` | `统计数据错误` | `范围锁` |

**🎯 锁的作用**：
- 保证数据一致性
- 避免并发冲突
- 维护事务隔离性

---

## 2. 🔓 乐观锁机制


### 2.1 乐观锁的核心思想


> **🧠 理解乐观锁**
> 
> **乐观锁就像网购抢票**：
> - 不会提前锁定座位（不加锁）
> - 大家都可以选座位（并发访问）
> - 提交时才检查座位是否被占（版本检查）
> - 被占了就提示"请重新选择"（更新失败）
> 
> 核心理念：**假设冲突很少，发生时再处理**

### 2.2 @Version版本控制


**🔸 什么是版本号**

```
版本控制原理：
┌─────────────────────────────────┐
│ 数据表结构                       │
├─────────────────────────────────┤
│ id  | name   | price | version  │ ← 版本列
│ 1   | 手机   | 3000  | 0        │
└─────────────────────────────────┘

更新流程：
步骤1：读取数据（带版本号）
  SELECT * FROM product WHERE id=1
  得到：price=3000, version=0

步骤2：修改后更新（检查版本号）
  UPDATE product 
  SET price=2800, version=version+1
  WHERE id=1 AND version=0

步骤3：检查影响行数
  - 影响1行 → 更新成功，版本变为1
  - 影响0行 → 其他人已修改，更新失败
```

**📝 实体类配置**

```java
@Entity
public class Product {
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    private BigDecimal price;
    
    // 版本号字段 - JPA自动管理
    @Version
    private Integer version;  // 或 Long、Timestamp
    
    // getter/setter...
}
```

> **⚠️ 重要提示**
> 
> - `@Version`字段由JPA自动维护，不要手动修改
> - 每次更新成功，版本号自动+1
> - 更新失败会抛出`OptimisticLockException`

### 2.3 乐观锁的使用场景


**🎯 适合使用乐观锁的情况**

```
✅ 读多写少的场景
   示例：商品信息、文章内容
   原因：冲突概率低，不需要锁定资源

✅ 冲突不频繁的业务
   示例：用户资料修改、订单备注
   原因：即使失败重试，用户可接受

✅ 对性能要求高
   示例：高并发查询系统
   原因：不加数据库锁，性能更好
```

**❌ 不适合乐观锁的情况**

```
🚫 写操作频繁
   示例：秒杀商品、库存扣减
   原因：频繁失败重试，性能反而差

🚫 必须保证成功
   示例：金融转账、支付操作
   原因：失败重试可能导致业务问题

🚫 更新冲突率高
   示例：热门商品库存
   原因：大量失败浪费资源
```

### 2.4 OptimisticLockException处理


**🔸 异常发生时机**

```
并发更新场景：
用户A                    用户B
  |                        |
读取(version=5)         读取(version=5)
  |                        |
修改数据                  修改数据
  |                        |
更新(version=5)         等待...
  ↓                        |
成功(version→6)          更新(version=5)
                           ↓
                        失败! 抛出异常
                        (version已经是6了)
```

**📝 异常处理代码**

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository repository;
    
    // 方式1：捕获异常并重试
    public void updatePrice(Long id, BigDecimal newPrice) {
        int maxRetry = 3;  // 最多重试3次
        
        for (int i = 0; i < maxRetry; i++) {
            try {
                Product product = repository.findById(id)
                    .orElseThrow();
                    
                product.setPrice(newPrice);
                repository.save(product);
                
                return;  // 成功则返回
                
            } catch (OptimisticLockException e) {
                if (i == maxRetry - 1) {
                    throw new RuntimeException("更新失败，请稍后重试");
                }
                // 继续下一次重试
            }
        }
    }
    
    // 方式2：返回结果让调用者处理
    public boolean tryUpdatePrice(Long id, BigDecimal newPrice) {
        try {
            Product product = repository.findById(id).orElseThrow();
            product.setPrice(newPrice);
            repository.save(product);
            return true;
        } catch (OptimisticLockException e) {
            return false;  // 让调用者决定如何处理
        }
    }
}
```

---

## 3. 🔒 悲观锁机制


### 3.1 悲观锁的核心思想


> **🧠 理解悲观锁**
> 
> **悲观锁就像预定电影院座位**：
> - 选座位时立即锁定（加锁）
> - 别人看到这个座位是锁定的（无法访问）
> - 付款后才释放或确认（提交事务）
> - 中途取消则释放座位（回滚事务）
> 
> 核心理念：**假设一定会冲突，提前锁住资源**

### 3.2 悲观锁的工作流程


```
悲观锁执行流程：

事务A                           事务B
  |                              |
开始事务                        开始事务
  |                              |
查询并加锁                       |
SELECT ... FOR UPDATE           |
  ↓                              |
✓ 锁定成功                       查询相同数据
  |                              |
修改数据                         等待锁释放...
  |                              ⏰ 阻塞中
更新数据                         |
  |                              |
提交事务 ✓                       |
  |                              |
释放锁                          ✓ 获得锁
                                 |
                                执行操作...
```

### 3.3 悲观锁的使用


**📝 基本用法**

```java
@Service
public class AccountService {
    
    @PersistenceContext
    private EntityManager em;
    
    @Transactional
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        // 使用悲观锁查询账户
        Account from = em.find(Account.class, fromId, 
            LockModeType.PESSIMISTIC_WRITE);
        Account to = em.find(Account.class, toId, 
            LockModeType.PESSIMISTIC_WRITE);
        
        // 转账逻辑
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        // 提交时自动释放锁
    }
}
```

> **💡 SQL层面发生了什么**
> 
> ```sql
> -- JPA生成的SQL (MySQL)
> SELECT * FROM account 
> WHERE id = 1 
> FOR UPDATE;  -- 加排他锁
> 
> -- 其他事务执行相同查询时会阻塞
> -- 直到第一个事务提交或回滚
> ```

### 3.4 悲观锁的使用场景


**🎯 适合使用悲观锁**

```
✅ 写操作频繁
   示例：库存扣减、座位预定
   原因：避免大量失败重试

✅ 冲突概率高
   示例：秒杀活动、抢购商品
   原因：提前锁定避免冲突

✅ 后果严重的业务
   示例：金融交易、账户余额
   原因：必须保证数据准确

✅ 短事务操作
   示例：简单的增删改
   原因：锁定时间短，影响小
```

**❌ 不适合悲观锁**

```
🚫 长事务操作
   原因：长时间锁定影响并发

🚫 读多写少
   原因：不必要的锁降低性能

🚫 分布式环境
   原因：数据库锁无法跨库生效
```

---

## 4. ⚙️ 锁模式详解


### 4.1 LockModeType枚举


| 锁模式 | **说明** | **使用场景** | **SQL示例** |
|--------|---------|------------|-----------|
| `NONE` | `无锁` | `普通查询` | `SELECT ...` |
| `OPTIMISTIC` | `乐观锁读` | `读取时检查版本` | `SELECT ... (version)` |
| `OPTIMISTIC_FORCE_INCREMENT` | `强制版本增加` | `即使不修改也增加版本` | `UPDATE version+1` |
| `PESSIMISTIC_READ` | `共享锁` | `允许其他读，阻止写` | `SELECT ... LOCK IN SHARE MODE` |
| `PESSIMISTIC_WRITE` | `排他锁` | `阻止其他读写` | `SELECT ... FOR UPDATE` |
| `PESSIMISTIC_FORCE_INCREMENT` | `排他锁+版本增加` | `悲观锁+乐观锁结合` | `SELECT ... FOR UPDATE; version+1` |

### 4.2 各种锁模式的使用


**🔸 OPTIMISTIC - 乐观读锁**

```java
// 读取时不加锁，提交时检查版本
@Transactional
public Product getProduct(Long id) {
    // 读取时记录版本号
    return em.find(Product.class, id, 
        LockModeType.OPTIMISTIC);
    
    // 事务提交时检查版本是否变化
    // 如果变化则抛出异常
}
```

**🔸 PESSIMISTIC_READ - 共享锁**

```java
// 允许其他事务读取，但不能修改
@Transactional
public List<Product> getProducts() {
    return em.createQuery("SELECT p FROM Product p", Product.class)
        .setLockMode(LockModeType.PESSIMISTIC_READ)
        .getResultList();
    
    // 生成SQL: SELECT ... LOCK IN SHARE MODE
    // 其他事务可以读，但无法修改
}
```

**🔸 PESSIMISTIC_WRITE - 排他锁**

```java
// 完全锁定，其他事务无法读写
@Transactional
public void updateStock(Long productId, int quantity) {
    Product product = em.find(Product.class, productId,
        LockModeType.PESSIMISTIC_WRITE);
    
    // 生成SQL: SELECT ... FOR UPDATE
    // 其他事务无法读写此记录
    
    product.setStock(product.getStock() - quantity);
}
```

### 4.3 锁模式选择指南


```
选择流程图：

需要加锁？
   │
   ├─ 否 → NONE（普通查询）
   │
   └─ 是 → 冲突频繁吗？
          │
          ├─ 否 → 乐观锁
          │      ├─ 只读 → OPTIMISTIC
          │      └─ 修改 → @Version自动处理
          │
          └─ 是 → 悲观锁
                 ├─ 允许其他读 → PESSIMISTIC_READ
                 └─ 完全锁定 → PESSIMISTIC_WRITE
```

---

## 5. ⚠️ 死锁问题处理


### 5.1 什么是死锁


> **🧠 生活中的死锁**
> 
> 两个人过独木桥：
> - A从左边上桥，占据左半边
> - B从右边上桥，占据右半边  
> - A等B让路，B也在等A让路
> - 结果：**谁都过不去！**

**🔸 数据库死锁示例**

```
死锁场景：

时间   事务A                    事务B
─────────────────────────────────────────
9:00   锁定订单1                锁定订单2
       (获得锁A)                (获得锁B)

9:01   准备更新订单2...         准备更新订单1...
       (需要锁B)                (需要锁A)

9:02   等待锁B释放              等待锁A释放
       ⏰ 阻塞                  ⏰ 阻塞

结果：死锁！数据库检测后会回滚其中一个事务
```

### 5.2 死锁的检测


**🔍 数据库死锁检测**

```sql
-- MySQL查看当前锁等待
SHOW ENGINE INNODB STATUS;

-- 查看锁等待超时时间
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';

-- 典型的死锁日志：
------------------------
LATEST DETECTED DEADLOCK
------------------------
Transaction 1:
  LOCK WAIT for table `orders` record id=100
  held by Transaction 2

Transaction 2:  
  LOCK WAIT for table `orders` record id=200
  held by Transaction 1

*** WE ROLL BACK Transaction 2
```

### 5.3 避免死锁的策略


**✅ 策略1：统一加锁顺序**

```java
// ❌ 错误：不同顺序加锁容易死锁
@Transactional
public void transfer1(Long from, Long to, BigDecimal amount) {
    Account a1 = em.find(Account.class, from, PESSIMISTIC_WRITE);
    Account a2 = em.find(Account.class, to, PESSIMISTIC_WRITE);
    // 如果另一个事务以相反顺序加锁，可能死锁
}

// ✅ 正确：按ID大小排序，统一加锁顺序
@Transactional
public void transfer2(Long from, Long to, BigDecimal amount) {
    Long firstId = Math.min(from, to);
    Long secondId = Math.max(from, to);
    
    Account a1 = em.find(Account.class, firstId, PESSIMISTIC_WRITE);
    Account a2 = em.find(Account.class, secondId, PESSIMISTIC_WRITE);
    
    // 所有事务都按相同顺序加锁，避免死锁
}
```

**✅ 策略2：设置锁超时**

```java
@Transactional
public void safeUpdate(Long id) {
    Map<String, Object> hints = new HashMap<>();
    hints.put("javax.persistence.lock.timeout", 3000); // 3秒超时
    
    try {
        Product p = em.find(Product.class, id, 
            LockModeType.PESSIMISTIC_WRITE, hints);
        // 执行更新...
    } catch (LockTimeoutException e) {
        // 超时处理：重试或返回错误
        throw new RuntimeException("系统繁忙，请稍后重试");
    }
}
```

**✅ 策略3：减少锁持有时间**

```java
// ❌ 错误：锁持有时间太长
@Transactional
public void processOrder(Long orderId) {
    Order order = em.find(Order.class, orderId, 
        LockModeType.PESSIMISTIC_WRITE);
    
    // 长时间业务处理...
    sendEmail(order);      // 发送邮件
    callExternalAPI(order); // 调用外部API
    generateReport(order);  // 生成报表
    
    order.setStatus("PROCESSED");
}

// ✅ 正确：只在必要时持有锁
@Transactional
public void processOrder(Long orderId) {
    // 先完成不需要锁的操作
    Order order = em.find(Order.class, orderId);
    sendEmail(order);
    callExternalAPI(order);
    generateReport(order);
    
    // 最后才加锁更新
    order = em.find(Order.class, orderId, 
        LockModeType.PESSIMISTIC_WRITE);
    order.setStatus("PROCESSED");
}
```

### 5.4 死锁异常处理


```java
@Service
public class DeadlockSafeService {
    
    private static final int MAX_RETRY = 3;
    
    @Transactional
    public void executeWithRetry(Runnable task) {
        int retries = 0;
        
        while (retries < MAX_RETRY) {
            try {
                task.run();
                return; // 成功则返回
                
            } catch (PessimisticLockException e) {
                retries++;
                
                if (retries >= MAX_RETRY) {
                    throw new RuntimeException(
                        "操作失败，已重试" + MAX_RETRY + "次");
                }
                
                // 随机等待后重试（避免再次冲突）
                try {
                    Thread.sleep((long)(Math.random() * 100));
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
}
```

---

## 6. 🎯 并发控制策略


### 6.1 选择合适的并发控制方案


**📊 决策流程**

```
业务场景分析：

1. 并发量级？
   ├─ 低并发(QPS<100) → 简单锁即可
   └─ 高并发(QPS>1000) → 需要精细设计

2. 冲突概率？
   ├─ 低(<5%) → 乐观锁
   └─ 高(>20%) → 悲观锁

3. 业务容忍度？
   ├─ 可重试 → 乐观锁
   └─ 必须成功 → 悲观锁

4. 读写比例？
   ├─ 读多写少(>80%读) → 乐观锁 + 缓存
   └─ 写多 → 悲观锁 + 批量处理
```

### 6.2 混合使用策略


**🔸 场景1：商品秒杀**

```java
@Service
public class FlashSaleService {
    
    // 第一步：乐观锁尝试
    public boolean tryBuy(Long productId, Long userId) {
        try {
            Product product = repository.findById(productId)
                .orElseThrow();
            
            if (product.getStock() <= 0) {
                return false; // 库存不足
            }
            
            product.setStock(product.getStock() - 1);
            repository.save(product); // 乐观锁
            
            createOrder(productId, userId);
            return true;
            
        } catch (OptimisticLockException e) {
            // 失败后用悲观锁兜底
            return buyWithPessimisticLock(productId, userId);
        }
    }
    
    // 第二步：悲观锁兜底
    @Transactional
    private boolean buyWithPessimisticLock(Long productId, Long userId) {
        Product product = em.find(Product.class, productId,
            LockModeType.PESSIMISTIC_WRITE);
        
        if (product.getStock() <= 0) {
            return false;
        }
        
        product.setStock(product.getStock() - 1);
        createOrder(productId, userId);
        return true;
    }
}
```

**🔸 场景2：分级锁策略**

```java
@Service
public class OrderService {
    
    // 查询订单：无锁
    public Order getOrder(Long id) {
        return em.find(Order.class, id);
    }
    
    // 修改订单备注：乐观锁
    @Transactional
    public void updateRemark(Long id, String remark) {
        Order order = em.find(Order.class, id, 
            LockModeType.OPTIMISTIC);
        order.setRemark(remark);
    }
    
    // 订单发货：悲观锁（涉及库存和状态）
    @Transactional
    public void shipOrder(Long id) {
        Order order = em.find(Order.class, id,
            LockModeType.PESSIMISTIC_WRITE);
        
        if (order.getStatus() != OrderStatus.PAID) {
            throw new IllegalStateException("订单状态错误");
        }
        
        // 扣减库存
        for (OrderItem item : order.getItems()) {
            Product p = em.find(Product.class, item.getProductId(),
                LockModeType.PESSIMISTIC_WRITE);
            p.setStock(p.getStock() - item.getQuantity());
        }
        
        order.setStatus(OrderStatus.SHIPPED);
    }
}
```

### 6.3 性能优化建议


**⚡ 优化要点**

```
🔹 减少锁范围
   - 只锁必要的数据
   - 避免锁定整个表

🔹 缩短锁时间  
   - 提前准备数据
   - 延迟加锁时机

🔹 降低锁粒度
   - 行锁优于表锁
   - 分段锁提高并发

🔹 避免长事务
   - 拆分大事务
   - 异步处理非关键操作
```

**📝 优化示例**

```java
// ❌ 低效：锁定时间长
@Transactional
public void processLongTask(Long id) {
    Order order = em.find(Order.class, id, 
        LockModeType.PESSIMISTIC_WRITE);
    
    // 耗时操作都在锁内
    complexCalculation(order);    // 5秒
    sendNotification(order);      // 3秒
    updateExternalSystem(order);  // 4秒
    
    order.setProcessed(true);
}

// ✅ 高效：最小化锁时间
@Transactional
public void processLongTask(Long id) {
    // 1. 先读取数据（无锁）
    Order order = em.find(Order.class, id);
    
    // 2. 完成耗时操作（无锁）
    Result result = complexCalculation(order);
    sendNotification(order);
    updateExternalSystem(order);
    
    // 3. 最后才加锁更新（锁持有<1秒）
    order = em.find(Order.class, id, 
        LockModeType.PESSIMISTIC_WRITE);
    order.setResult(result);
    order.setProcessed(true);
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 并发问题本质：多个事务同时操作数据导致的冲突
🔸 乐观锁：通过版本号检测冲突，适合读多写少
🔸 悲观锁：提前锁定资源，适合写多冲突高
🔸 锁模式：6种模式覆盖不同并发场景
🔸 死锁：互相等待资源，需要检测和避免
🔸 并发策略：根据业务特点选择合适方案
```

### 7.2 乐观锁 vs 悲观锁


| 对比维度 | **乐观锁** | **悲观锁** |
|---------|-----------|-----------|
| 🎯 **核心思想** | `假设无冲突，发生时处理` | `假设有冲突，提前锁定` |
| ⚙️ **实现方式** | `版本号机制` | `数据库锁` |
| 📊 **适用场景** | `读多写少` | `写多冲突高` |
| ⚡ **性能影响** | `无锁开销，冲突时重试` | `锁等待，降低并发` |
| 🔧 **使用难度** | `简单，JPA自动处理` | `需要理解锁机制` |
| ⚠️ **失败处理** | `抛异常，需要重试` | `阻塞等待或超时` |

### 7.3 实际应用指导


> **💡 快速选择指南**
> 
> **用乐观锁**：
> - ✅ 商品信息更新（冲突少）
> - ✅ 文章内容编辑（冲突少）
> - ✅ 用户资料修改（冲突少）
> 
> **用悲观锁**：
> - ✅ 库存扣减（冲突多）
> - ✅ 座位预定（必须成功）
> - ✅ 账户转账（不容出错）
> 
> **混合使用**：
> - ✅ 秒杀活动（先乐观后悲观）
> - ✅ 订单处理（查询无锁，更新加锁）

### 7.4 避免常见错误


```
❌ 常见错误1：滥用悲观锁
   问题：所有查询都加FOR UPDATE
   后果：严重降低并发性能
   正确：只在必要时使用悲观锁

❌ 常见错误2：忽略死锁
   问题：不处理死锁异常
   后果：用户看到莫名其妙的错误
   正确：捕获异常，实现重试机制

❌ 常见错误3：锁粒度过大
   问题：锁定整个表或大量数据
   后果：阻塞其他事务
   正确：只锁必要的行

❌ 常见错误4：长事务持有锁
   问题：在事务中执行耗时操作
   后果：锁等待时间过长
   正确：缩短事务时间，延迟加锁
```

### 7.5 核心记忆口诀


```
🎯 锁机制记忆法：

并发冲突要控制，锁是关键来解决
读多写少用乐观，版本检查防冲突
写多冲突用悲观，提前锁定保安全

乐观失败要重试，悲观阻塞会等待
死锁排查找顺序，统一加锁是关键
锁的时间要最短，性能优化很重要

根据场景选策略，混合使用效果好
监控调优不能少，并发控制要做好
```

---

## 📚 扩展学习


**🔗 相关知识点**：
- 数据库事务隔离级别
- Spring事务传播机制
- 分布式锁实现
- 缓存更新策略

**📖 深入理解**：
- MySQL InnoDB锁机制
- MVCC多版本并发控制
- 两阶段锁协议(2PL)
- 无锁数据结构(CAS)

**🎯 学习建议**：
1. 先理解概念，再动手实践
2. 对比测试不同锁的性能
3. 模拟高并发场景验证
4. 总结适合自己业务的模式