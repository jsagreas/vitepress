---
title: 42、JPA事务管理
---
## 📚 目录

1. [事务是什么？为什么需要它？](#1-事务是什么为什么需要它)
2. [JPA事务基础](#2-JPA事务基础)
3. [事务的四大特性ACID](#3-事务的四大特性ACID)
4. [JPA事务的使用方式](#4-JPA事务的使用方式)
5. [事务隔离级别详解](#5-事务隔离级别详解)
6. [事务的常见问题与最佳实践](#6-事务的常见问题与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💡 事务是什么？为什么需要它？


### 1.1 生活中的事务场景


🎯 **难度等级**：⭐ 入门级  
🔥 **重要程度**：必须掌握

**💭 先从生活例子理解：**

想象你在银行转账：
```
小明给小红转账1000元的完整过程：
第1步：检查小明账户余额是否够1000元
第2步：从小明账户扣除1000元
第3步：往小红账户增加1000元
第4步：记录转账流水

❗ 问题来了：
如果第2步成功（小明钱扣了），第3步失败（小红没收到），怎么办？
→ 小明亏了1000元！这是绝对不能接受的！
```

**🔸 事务就是为了解决这个问题：**
- 要么**全部成功**（小明扣钱，小红收钱，都成功）
- 要么**全部失败**（都不执行，回到原来状态）
- **绝不允许**只做一半！

### 1.2 数据库中的事务


**📋 通俗定义：**
```
事务（Transaction）= 一组必须"全做或全不做"的数据库操作

就像一个"保险箱"：
- 里面可以放多个操作
- 关上门之前（提交前），外面的人看不到变化
- 可以选择：锁上（提交），或者扔掉重来（回滚）
```

**🎯 核心作用：**
```
保证数据的正确性和一致性

真实案例：
电商下单 = 1个事务包含多个步骤
  ① 扣减库存
  ② 创建订单
  ③ 减少用户余额
  ④ 增加商家收入
  
→ 这4步必须全部成功，否则全部撤销！
```

---

## 2. 🔧 JPA事务基础


### 2.1 EntityTransaction接口


**📋 核心接口：**
```
EntityTransaction = JPA提供的事务管理接口
作用：控制事务的开始、提交、回滚

可以把它想象成"事务遥控器"：
🟢 begin()   → 开始按钮
🔵 commit()  → 确认按钮  
🔴 rollback()→ 撤销按钮
```

**💡 基本使用模式：**

```java
// 1. 获取事务对象
EntityTransaction tx = entityManager.getTransaction();

// 2. 开启事务
tx.begin();

try {
    // 3. 执行数据库操作
    entityManager.persist(user);
    
    // 4. 提交事务（确认所有操作）
    tx.commit();
} catch (Exception e) {
    // 5. 出错时回滚（撤销所有操作）
    tx.rollback();
    throw e;
}
```

### 2.2 事务边界控制


**🔸 什么是事务边界？**

```
事务边界 = 事务的"起点"和"终点"

就像画画的框框：
开始（begin） → 【在这里面的操作都算事务内容】 → 结束（commit/rollback）

事务外的操作 ┃ 事务内的操作 ┃ 事务外的操作
            ┃              ┃
         begin()        commit()
```

**⚠️ 边界控制的重要性：**

```
✅ 正确示例：
tx.begin();
  操作A;
  操作B;
tx.commit();

❌ 错误示例：
操作A;           ← 这个操作不在事务中！
tx.begin();
  操作B;
tx.commit();
```

### 2.3 资源本地事务


**📋 概念解释：**

```
资源本地事务（Resource Local Transaction）
= 由应用程序自己管理的事务
= 你手动调用 begin/commit/rollback

对比两种事务管理方式：

┌─────────────────────────────────┐
│ 资源本地事务（你当司机）         │
│ • 你自己开车（手动控制）         │
│ • 启动、刹车、方向盘都要自己操作 │
│ • 灵活但需要小心                 │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│ JTA事务（自动驾驶）              │
│ • 容器帮你管理                   │
│ • 只需要加个注解@Transactional   │
│ • 简单但不够灵活                 │
└─────────────────────────────────┘
```

**💡 实际应用场景：**

| 场景 | 适合的事务类型 | 原因 |
|------|---------------|------|
| **简单应用** | 资源本地事务 | 控制简单，够用 |
| **复杂企业应用** | JTA事务 | 自动管理，省心 |
| **多数据源操作** | JTA事务 | 需要分布式事务 |
| **单数据库CRUD** | 资源本地事务 | 手动控制更灵活 |

---

## 3. 🎯 事务的四大特性ACID


### 3.1 ACID是什么？


**🔸 记忆口诀：**
```
A - 原子性（Atomicity）     → "要么全做，要么全不做"
C - 一致性（Consistency）   → "数据始终正确"
I - 隔离性（Isolation）     → "互不干扰"
D - 持久性（Durability）    → "永久保存"

🧠 记忆技巧：ACID → "酸性"化学实验要"原子一致，隔离持久"
```

### 3.2 原子性（Atomicity）


**💭 通俗理解：**

```
原子性 = 不可分割性

就像买一杯奶茶：
✅ 要么成功：你付钱 + 店家给奶茶（两件事都完成）
❌ 要么失败：你不付钱 + 店家不给奶茶（两件事都不做）
🚫 绝不允许：你付钱了，但店家不给奶茶（只做一半）

数据库例子：
转账操作 = 2个步骤
  步骤1：A账户 -100元
  步骤2：B账户 +100元
  
→ 两步必须同时成功，否则同时撤销
```

**📊 代码示例：**

```java
// 原子性演示
tx.begin();
try {
    // 这两个操作绑定在一起
    account1.setBalance(account1.getBalance() - 100); // 扣钱
    account2.setBalance(account2.getBalance() + 100); // 加钱
    
    tx.commit(); // 两个操作一起成功
} catch (Exception e) {
    tx.rollback(); // 出错就两个操作一起撤销
}
```

### 3.3 一致性（Consistency）


**💭 通俗理解：**

```
一致性 = 数据符合现实规则

现实规则举例：
- 账户余额不能是负数
- 学生年龄不能超过150岁
- 订单总价 = 所有商品价格之和

数据库的一致性：
事务前：A账户1000元 + B账户500元 = 总共1500元
事务后：A账户900元 + B账户600元 = 总共1500元 ✓
→ 总金额守恒，符合规则！

如果出现：
事务后：A账户900元 + B账户500元 = 总共1400元 ✗
→ 凭空少了100元，不符合规则！违反一致性！
```

**⚠️ 常见的一致性约束：**

```
📌 业务规则约束：
  • 库存数量 ≥ 0
  • 用户年龄 ≥ 0 且 ≤ 150
  • 商品价格 > 0

📌 关系约束：
  • 外键约束：订单必须关联已存在的用户
  • 唯一约束：用户名不能重复

📌 数据完整性：
  • 主键不能为空
  • 必填字段必须有值
```

### 3.4 隔离性（Isolation）


**💭 通俗理解：**

```
隔离性 = 事务之间互不干扰

就像考试：
- 每个考生独立答题（事务独立执行）
- 不能偷看别人的答案（不能看到别人未提交的修改）
- 考完交卷才能给老师改（提交后才能被看到）

数据库场景：
小明在修改商品价格（事务A）
小红在查看商品价格（事务B）

❓ 问题：小红能看到小明还没提交的价格修改吗？
→ 取决于隔离级别！
```

**🔸 隔离性的必要性：**

```
没有隔离性会出现什么问题？

场景：商品库存=10件

时间线：
10:00 → 小明开始买5件（读到库存10）
10:01 → 小红开始买6件（读到库存10）  ← 都读到10
10:02 → 小明提交（库存变成5）
10:03 → 小红提交（库存变成4）        ← 超卖了！

实际：卖出了11件，但库存只有10件！
→ 这就是隔离性不够导致的问题
```

### 3.5 持久性（Durability）


**💭 通俗理解：**

```
持久性 = 提交后永久保存

就像考试交卷：
- 交卷前：在草稿纸上，可以擦掉重写
- 交卷后：在答题卡上，永久记录，不能修改

数据库的持久性：
✅ commit()后：数据写入磁盘，断电也不会丢失
❌ 未commit：数据在内存，断电就丢失

现实保证：
- 即使数据库崩溃
- 即使服务器断电
- 已提交的数据都能恢复
```

**📊 持久性的实现原理：**

```
数据提交过程：

内存中的修改  →  写入日志(WAL)  →  写入数据文件
   ↓                ↓                  ↓
  快但不安全      安全但慢          最终存储

步骤说明：
1️⃣ 先写日志（Write-Ahead Logging）
   • 快速记录"要做什么"
   • 即使崩溃也能根据日志恢复

2️⃣ 再写数据文件
   • 慢慢将数据写入磁盘
   • 最终持久化存储
```

---

## 4. 🔨 JPA事务的使用方式


### 4.1 手动事务管理（基础方式）


**🔥 重要程度**：必须掌握  
**⭐ 难度等级**：⭐⭐ 进阶级

**📋 标准流程：**

```java
EntityManager em = entityManagerFactory.createEntityManager();
EntityTransaction tx = em.getTransaction();

try {
    tx.begin();           // 1. 开启事务
    
    // 2. 执行业务操作
    User user = new User("张三", 25);
    em.persist(user);
    
    tx.commit();          // 3. 提交事务
    
} catch (Exception e) {
    if (tx.isActive()) {  // 4. 检查事务是否还在进行
        tx.rollback();    // 5. 回滚事务
    }
    throw e;              // 6. 抛出异常
} finally {
    em.close();           // 7. 关闭EntityManager
}
```

**💡 每一步的作用：**

```
begin()    → 打开"保险箱"，准备放东西
persist()  → 往"保险箱"里放操作
commit()   → 锁上"保险箱"，所有操作生效
rollback() → 清空"保险箱"，所有操作作废
```

### 4.2 事务模板方法（推荐方式）


**🌟 为什么推荐？** 避免忘记关闭资源，代码更简洁

```java
public class TransactionUtil {
    
    // 事务模板方法
    public static <T> T executeInTransaction(
        EntityManager em, 
        Function<EntityManager, T> action
    ) {
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            T result = action.apply(em);  // 执行业务逻辑
            tx.commit();
            return result;
        } catch (Exception e) {
            if (tx.isActive()) {
                tx.rollback();
            }
            throw e;
        }
    }
}

// 使用示例
User savedUser = TransactionUtil.executeInTransaction(em, manager -> {
    User user = new User("李四", 30);
    manager.persist(user);
    return user;
});
```

### 4.3 事务边界最佳实践


**✅ 正确做法：**

```java
// ✅ 事务边界清晰明确
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    try {
        Account from = em.find(Account.class, fromId);
        Account to = em.find(Account.class, toId);
        
        from.withdraw(amount);  // 扣钱
        to.deposit(amount);     // 加钱
        
        tx.commit();
    } catch (Exception e) {
        tx.rollback();
        throw e;
    }
}
```

**❌ 错误做法：**

```java
// ❌ 事务边界混乱
public void badTransferMoney(Long fromId, Long toId, BigDecimal amount) {
    Account from = em.find(Account.class, fromId);  // ← 在事务外查询
    
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    
    from.withdraw(amount);  // ← from可能是旧数据！
    
    Account to = em.find(Account.class, toId);
    to.deposit(amount);
    
    tx.commit();
}
```

---

## 5. 🔒 事务隔离级别详解


### 5.1 为什么需要隔离级别？


**💭 生活场景：**

```
想象一个图书馆：

🔸 完全隔离（每人一个房间）
  优点：绝对安全，互不干扰
  缺点：太浪费空间，效率低

🔸 完全不隔离（大家挤一起）
  优点：空间利用率高
  缺点：互相影响，容易出错

🔸 适度隔离（用隔板分开）
  优点：平衡安全和效率
  缺点：需要选择合适的隔离方式

→ 数据库的隔离级别就是在"安全"和"性能"之间找平衡！
```

### 5.2 四种隔离级别


**📊 隔离级别对比：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 适用场景 |
|---------|------|-----------|------|------|---------|
| **READ_UNCOMMITTED** | ❌可能 | ❌可能 | ❌可能 | ⚡最快 | 几乎不用 |
| **READ_COMMITTED** | ✅阻止 | ❌可能 | ❌可能 | ⚡快 | 🔥最常用 |
| **REPEATABLE_READ** | ✅阻止 | ✅阻止 | ❌可能 | 🐢较慢 | 金融系统 |
| **SERIALIZABLE** | ✅阻止 | ✅阻止 | ✅阻止 | 🐌最慢 | 极高要求 |

### 5.3 三大并发问题详解


**🔸 脏读（Dirty Read）**

```
什么是脏读？
读到了别人还没提交的"脏"数据

场景演示：
时间  事务A                事务B
10:00 查询账户余额=1000
10:01                     开始转账，余额改为800（未提交）
10:02 再次查询余额=800    ← 读到了未提交的数据（脏读）
10:03                     出错，回滚，余额恢复1000
10:04 发现余额是1000      ← 刚才读到的800是错的！

💡 通俗理解：
就像看到朋友在购物车加了商品，你以为他会买
结果他清空了购物车，根本没买
→ 你看到的"加购"信息是"脏"的
```

**🔸 不可重复读（Non-Repeatable Read）**

```
什么是不可重复读？
同一个事务内，两次读取同一数据，结果不一样

场景演示：
时间  事务A                    事务B
10:00 开始事务
10:01 查询商品价格=100元
10:02                         修改商品价格为80元
10:03                         提交
10:04 再次查询价格=80元      ← 两次查询结果不一样
10:05 提交

💡 通俗理解：
就像你去超市买东西：
- 第一次看价格：100元
- 去拿其他东西，回来再看：80元（降价了）
→ 同一件商品，两次看到的价格不一样
```

**🔸 幻读（Phantom Read）**

```
什么是幻读？
同一个事务内，两次查询，记录数量变了

场景演示：
时间  事务A                        事务B
10:00 开始事务
10:01 查询订单总数=10条
10:02                             新增1条订单
10:03                             提交
10:04 再次查询订单总数=11条      ← 多了一条（幻读）
10:05 提交

💡 通俗理解：
就像在教室点名：
- 第一次点名：30个学生
- 讲了一会儿课，再点名：31个学生（有人迟到进来了）
→ 像见了"鬼"一样，凭空多了人
```

### 5.4 JPA中设置隔离级别


**📋 配置方式：**

```java
// 方式1：在persistence.xml中配置
<property name="javax.persistence.jdbc.isolation" 
          value="TRANSACTION_READ_COMMITTED"/>

// 方式2：通过代码设置（较少用）
Map<String, Object> props = new HashMap<>();
props.put("javax.persistence.jdbc.isolation", 
          "TRANSACTION_READ_COMMITTED");
EntityManager em = emf.createEntityManager(props);
```

**🎯 隔离级别选择指南：**

```
📌 一般应用（大部分情况）
→ READ_COMMITTED（读已提交）
  • 阻止脏读
  • 性能好
  • Oracle/SQL Server默认

📌 金融/支付系统
→ REPEATABLE_READ（可重复读）
  • 阻止脏读和不可重复读
  • MySQL默认级别
  • 防止金额计算错误

📌 高并发统计
→ READ_UNCOMMITTED（读未提交）
  • 可以读到未提交数据
  • 仅用于统计，不要求100%准确

📌 批量处理/数据迁移
→ SERIALIZABLE（序列化）
  • 完全隔离
  • 保证数据绝对正确
  • 性能最差
```

---

## 6. ⚠️ 事务的常见问题与最佳实践


### 6.1 常见错误


**❌ 错误1：忘记开启事务**

```java
// 错误示例
EntityManager em = emf.createEntityManager();
User user = new User("王五", 28);
em.persist(user);  // ← 报错！没有事务
em.close();

// 正确做法
EntityTransaction tx = em.getTransaction();
tx.begin();
em.persist(user);
tx.commit();
```

**❌ 错误2：事务嵌套**

```java
// 错误示例
tx.begin();
  doSomething();
  tx.begin();     // ← 错误！事务已经开启了
  doOtherThing();
  tx.commit();
tx.commit();
```

**❌ 错误3：忘记关闭资源**

```java
// 错误示例
public void badMethod() {
    EntityManager em = emf.createEntityManager();
    // ... 使用em
    // 忘记 em.close() ← 内存泄漏！
}

// 正确做法：使用try-with-resources
public void goodMethod() {
    try (EntityManager em = emf.createEntityManager()) {
        // ... 使用em
    } // 自动关闭
}
```

### 6.2 最佳实践


**✅ 实践1：事务要短小精悍**

```java
// ✅ 好的做法：事务只包含必要操作
tx.begin();
account.withdraw(100);
account.deposit(100);
tx.commit();

// ❌ 不好的做法：事务包含耗时操作
tx.begin();
account.withdraw(100);
sendEmail();        // ← 发邮件很慢！
callExternalAPI();  // ← 调用外部API很慢！
account.deposit(100);
tx.commit();
```

**✅ 实践2：异常处理要完整**

```java
EntityTransaction tx = em.getTransaction();
try {
    tx.begin();
    // 业务逻辑
    tx.commit();
} catch (Exception e) {
    if (tx != null && tx.isActive()) {  // ← 一定要检查
        tx.rollback();
    }
    // 记录日志
    logger.error("Transaction failed", e);
    throw e;  // ← 向上抛出异常
} finally {
    if (em != null && em.isOpen()) {
        em.close();
    }
}
```

**✅ 实践3：使用乐观锁处理并发**

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private Integer stock;
    
    @Version  // ← 乐观锁版本号
    private Integer version;
}

// 使用
try {
    tx.begin();
    Product product = em.find(Product.class, 1L);
    product.setStock(product.getStock() - 1);  // 减库存
    tx.commit();
} catch (OptimisticLockException e) {
    // 版本冲突，说明有人同时修改了
    // 可以重试或提示用户
}
```

### 6.3 性能优化建议


**🚀 优化技巧：**

```
1️⃣ 批量操作在一个事务中
✅ 好：
tx.begin();
for (User user : users) {
    em.persist(user);
}
tx.commit();

❌ 差：
for (User user : users) {
    tx.begin();
    em.persist(user);
    tx.commit();  // ← 每次都提交，很慢！
}

2️⃣ 只读操作不需要事务
em.setFlushMode(FlushModeType.COMMIT);
List<User> users = em.createQuery("SELECT u FROM User u")
                     .getResultList();  // ← 只读，不需要事务

3️⃣ 合理设置超时时间
tx.begin();
em.setProperty("javax.persistence.query.timeout", 3000);  // 3秒
// ... 执行操作
tx.commit();
```

---

## 7. 📋 核心要点总结


### 7.1 必须记住的核心概念


```
🔸 事务定义：一组必须"全做或全不做"的数据库操作
🔸 事务作用：保证数据的正确性和一致性
🔸 ACID特性：原子性、一致性、隔离性、持久性
🔸 事务控制：begin() → 操作 → commit()/rollback()
🔸 隔离级别：READ_COMMITTED最常用
```

### 7.2 关键理解要点


**🧠 记忆技巧：**

```
事务就像"考试交卷"：
• begin()   → 开始答题
• 操作      → 写答案
• commit()  → 交卷（永久记录）
• rollback()→ 作废重来

ACID记忆口诀：
原子（A）一致（C）要隔离（I），持久（D）保存不会丢
```

**🎯 最佳实践总结：**

| 原则 | 说明 | 示例 |
|------|------|------|
| **事务要短** | 只包含必要操作 | 不在事务中发邮件 |
| **异常处理** | 一定要rollback | try-catch-finally完整 |
| **资源释放** | 用完立即关闭 | 使用try-with-resources |
| **隔离级别** | 根据场景选择 | 普通应用用READ_COMMITTED |
| **并发控制** | 优先用乐观锁 | @Version注解 |

### 7.3 实际应用价值


**💼 真实业务场景：**

```
✅ 转账汇款：事务保证金额正确
✅ 电商下单：事务保证库存准确
✅ 考试系统：事务保证成绩一致
✅ 订票系统：事务防止超卖
✅ 秒杀活动：事务+隔离级别控制并发
```

**核心记忆口诀：**
```
事务ACID要记牢，begin开启commit了
rollback回滚保安全，异常处理不能少
隔离级别看场景，RC最常用性能高
资源记得要关闭，短小精悍效率好
```