---
title: 6、主键生成策略
---
## 📚 目录

1. [主键的基本概念](#1-主键的基本概念)
2. [主键映射注解详解](#2-主键映射注解详解)
3. [四大主键生成策略](#3-四大主键生成策略)
4. [高级主键方案](#4-高级主键方案)
5. [实际应用建议](#5-实际应用建议)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔑 主键的基本概念


### 1.1 什么是主键


**🌰 生活类比**：主键就像身份证号，用来**唯一标识**数据库中的每一条记录。

```
想象一个学生表：
姓名可能重复（张伟、李伟很多）
年龄可能重复（同龄的学生很多）
但学号是唯一的（每个学生只有一个学号）

学号 = 主键
```

**📋 主键的作用**

| 作用 | **说明** | **实际意义** |
|-----|---------|-------------|
| 🔸 **唯一标识** | `每条记录都不同` | `精确定位某条数据` |
| 🔸 **加速查询** | `建立索引提速` | `快速找到目标数据` |
| 🔸 **建立关联** | `外键引用主键` | `表与表之间建立关系` |
| 🔸 **保证完整性** | `不能为空且唯一` | `数据质量有保障` |

### 1.2 ORM中的主键映射


**什么是主键映射？**  
把Java类中的某个字段，对应到数据库表的主键列。

```
Java对象                     数据库表
┌─────────────┐            ┌──────────────┐
│ User类      │            │ user表       │
│ ─────────── │            │ ──────────── │
│ id: Long    │ ───映射───▶ │ id (PRIMARY) │
│ name: String│            │ name         │
│ age: int    │            │ age          │
└─────────────┘            └──────────────┘
```

**🔍 核心问题**：主键的值从哪来？谁来生成？

---

## 2. 📝 主键映射注解详解


### 2.1 @Id注解 - 标记主键


**作用**：告诉JPA这个字段是主键

```java
// ✅ 最简单的主键声明
@Entity
public class User {
    @Id
    private Long id;  // 这就是主键字段
    
    private String name;
}
```

**🎯 使用位置**
- 可以放在字段上
- 也可以放在getter方法上（推荐放字段上，更直观）

### 2.2 @GeneratedValue注解 - 自动生成主键


**为什么需要？**  
手动给每条记录设置主键太麻烦，让数据库或JPA自动生成更方便。

```java
@Entity
public class User {
    @Id
    @GeneratedValue  // 自动生成主键值
    private Long id;
    
    private String name;
}
```

**📊 注解结构**

```
@GeneratedValue(
    strategy = GenerationType.XXX,  // 生成策略
    generator = "生成器名称"          // 可选：指定具体生成器
)
```

---

## 3. ⚙️ 四大主键生成策略


### 3.1 AUTO - 自动选择（默认策略）


**🔸 工作原理**：JPA根据数据库类型自动选择最合适的策略

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
}
```

**📋 自动选择规则**

```
MySQL数据库    → 选择IDENTITY策略（数据库自增）
Oracle数据库   → 选择SEQUENCE策略（序列生成）
其他数据库     → 根据支持情况自动判断
```

**✅ 优点 vs ❌ 缺点**

| 优点 | 缺点 |
|-----|-----|
| `适配性强，换数据库不用改代码` | `不够透明，不知道底层用的哪种方式` |
| `省心省事，新手友好` | `某些场景下性能可能不是最优` |

> 💡 **新手建议**  
> 刚开始学习时用AUTO策略，熟悉后再根据实际需求选择具体策略。

### 3.2 IDENTITY - 数据库自增


**🔸 工作原理**：利用数据库的自增字段功能生成主键

```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
}
```

**📊 数据库层面的实现**

```sql
-- MySQL中的自增字段
CREATE TABLE product (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100)
);

-- 插入数据时不需要指定id
INSERT INTO product (name) VALUES ('商品A');
-- 数据库自动分配id = 1

INSERT INTO product (name) VALUES ('商品B');
-- 数据库自动分配id = 2
```

**🔄 执行流程图示**

```
Java代码                     数据库操作
  │                             │
  │ 创建对象: new Product()      │
  │ product.setName("商品A")     │
  │                             │
  │ save(product)               │
  ├──────INSERT语句─────────────▶│
  │                             │ 执行插入
  │                             │ 自增id=1
  │                             │
  │◀────返回生成的id=1───────────┤
  │                             │
  │ product.getId() = 1         │
```

**⚠️ 注意事项**

- 只有插入数据后才能获得主键值（因为是数据库生成的）
- 批量插入性能可能受影响（需要逐条获取生成的ID）
- 不是所有数据库都支持自增（Oracle就不支持）

**🎯 适用场景**

```
✅ 单体应用，使用MySQL/PostgreSQL等支持自增的数据库
✅ 主键只需保证表内唯一即可
✅ 不需要在插入前就知道主键值
```

### 3.3 SEQUENCE - 序列生成


**🔸 工作原理**：使用数据库序列对象生成主键

**什么是序列？**  
序列是数据库中的一个独立对象，专门用来生成连续的数字。

```
想象一个取号机：
每按一次按钮，就生成一个新号码
1 → 2 → 3 → 4 → 5 ...
数据库序列就是这样的"取号机"
```

**📝 基本使用**

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;
    
    private String orderNo;
}
```

**🔧 自定义序列配置**

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        generator = "order_seq_gen"  // 使用自定义序列生成器
    )
    @SequenceGenerator(
        name = "order_seq_gen",        // 生成器名称
        sequenceName = "order_seq",    // 数据库序列名
        initialValue = 1000,           // 起始值
        allocationSize = 1             // 每次递增量
    )
    private Long id;
}
```

**📊 配置参数说明**

| 参数 | **含义** | **示例** |
|-----|---------|---------|
| `name` | `生成器名称（给@GeneratedValue用）` | `"order_seq_gen"` |
| `sequenceName` | `数据库中实际的序列名` | `"order_seq"` |
| `initialValue` | `序列起始值` | `1000（从1000开始）` |
| `allocationSize` | `每次递增的大小` | `1（每次加1）` |

**🔄 执行流程**

```
Java代码                          数据库操作
  │                                  │
  │ new Order()                      │
  │                                  │
  │ 准备插入数据                      │
  ├────获取序列下一个值───────────────▶│
  │                                  │ SELECT order_seq.nextval
  │                                  │ 返回: 1000
  │◀────返回序列值=1000──────────────┤
  │                                  │
  │ 设置id=1000                      │
  ├────执行INSERT语句────────────────▶│
  │    (id=1000, ...)               │ 插入数据
  │                                  │
  │ 插入完成                         │
```

**✅ 优点 vs ❌ 缺点**

| 优点 | 缺点 |
|-----|-----|
| `插入前就能获得主键值` | `需要额外创建序列对象` |
| `支持批量优化（预分配ID）` | `只有部分数据库支持（Oracle、PostgreSQL）` |
| `可以跨表共享序列` | `配置相对复杂` |

> ⚠️ **MySQL注意**  
> MySQL 8.0之前不支持序列，只能用IDENTITY策略

### 3.4 TABLE - 表生成


**🔸 工作原理**：用一张专门的表来模拟序列，存储主键值

**为什么需要TABLE策略？**  
有些数据库既不支持自增，也不支持序列（比如老版本MySQL），TABLE策略是通用方案。

```
专门的ID生成表：
┌──────────────┬──────────┐
│ 序列名        │ 当前值   │
├──────────────┼──────────┤
│ user_seq     │ 100      │
│ order_seq    │ 5000     │
│ product_seq  │ 230      │
└──────────────┴──────────┘

每次需要ID时：
1. 从表中读取当前值
2. 当前值+1
3. 更新回表中
4. 返回ID给程序
```

**📝 基本使用**

```java
@Entity
public class Customer {
    @Id
    @GeneratedValue(
        strategy = GenerationType.TABLE,
        generator = "customer_gen"
    )
    @TableGenerator(
        name = "customer_gen",           // 生成器名称
        table = "id_generator",          // ID生成表名
        pkColumnName = "gen_name",       // 序列名列
        valueColumnName = "gen_value",   // 当前值列
        pkColumnValue = "customer_seq",  // 本序列的名称
        initialValue = 1,                // 初始值
        allocationSize = 1               // 递增量
    )
    private Long id;
}
```

**📊 @TableGenerator参数详解**

| 参数 | **作用** | **示例值** |
|-----|---------|-----------|
| `name` | `生成器名称` | `"customer_gen"` |
| `table` | `ID生成表名` | `"id_generator"` |
| `pkColumnName` | `序列名称列的列名` | `"gen_name"` |
| `valueColumnName` | `当前值列的列名` | `"gen_value"` |
| `pkColumnValue` | `本序列在表中的名称` | `"customer_seq"` |

**🔄 执行流程**

```
1. 获取ID请求
   ↓
2. SELECT gen_value FROM id_generator 
   WHERE gen_name = 'customer_seq'
   → 返回: 100
   ↓
3. UPDATE id_generator 
   SET gen_value = 101 
   WHERE gen_name = 'customer_seq'
   ↓
4. 使用100作为新记录的ID
   ↓
5. INSERT INTO customer (id, ...) VALUES (100, ...)
```

**✅ 优点 vs ❌ 缺点**

| 优点 | 缺点 |
|-----|-----|
| `所有数据库都支持（通用方案）` | `性能相对较差（多次数据库操作）` |
| `可移植性好` | `并发时可能有锁竞争` |
| `灵活性高` | `需要额外维护ID生成表` |

> 💡 **使用建议**  
> 优先选择IDENTITY或SEQUENCE，只在数据库不支持时才考虑TABLE策略

---

## 4. 🚀 高级主键方案


### 4.1 UUID主键


**什么是UUID？**  
通用唯一识别码（Universally Unique Identifier），是一个128位的数字。

```
UUID示例：
550e8400-e29b-41d4-a716-446655440000
特点：全球唯一，重复概率极低（几乎为0）
```

**📝 实现方式**

```java
@Entity
public class Article {
    @Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(
        name = "uuid2",
        strategy = "org.hibernate.id.UUIDGenerator"
    )
    @Column(columnDefinition = "VARCHAR(36)")
    private String id;  // 注意：UUID主键用String类型
    
    private String title;
}
```

**🔄 生成流程**

```
Java程序生成UUID               数据库
     │                           │
     │ UUID.randomUUID()         │
     │ 生成: 550e8400-e29b...     │
     │                           │
     │ 设置到对象中               │
     ├───INSERT语句──────────────▶│
     │   id='550e8400-e29b...'   │ 直接插入
     │                           │
```

**✅ 优点 vs ❌ 缺点**

| 优点 | 缺点 |
|-----|-----|
| `全局唯一，分布式系统友好` | `占用空间大（36字节字符串）` |
| `生成在程序端，不依赖数据库` | `无序，影响B树索引性能` |
| `插入前就有ID，便于业务处理` | `不够直观，不利于调试` |

**🎯 适用场景**

```
✅ 分布式系统（多个数据库节点）
✅ 数据需要跨库迁移
✅ 对主键可读性要求不高
❌ 数据量特别大且查询频繁（索引性能问题）
```

### 4.2 分布式ID - Snowflake算法


**🤔 为什么需要分布式ID？**

```
传统自增ID在分布式环境的问题：
数据库1： id = 1, 2, 3 ...
数据库2： id = 1, 2, 3 ...  ← ID重复了！

分布式ID要求：
- 全局唯一
- 趋势递增（有利于索引）
- 高性能（本地生成，不依赖数据库）
```

**❄️ Snowflake算法原理**

```
64位Long类型的ID结构：
┌─────┬──────────────┬──────────┬────────────┬──────────┐
│ 1位 │   41位       │  10位    │    12位    │          │
│符号位│   时间戳     │ 机器ID   │   序列号   │          │
└─────┴──────────────┴──────────┴────────────┴──────────┘
  0    当前时间-起始时间  机器编号   同毫秒内递增

示例ID分解：
1234567890123456789 (19位数字)
  ↓
时间戳部分：确保趋势递增
机器ID部分：区分不同服务器
序列号部分：同一毫秒内可生成4096个不同ID
```

**📝 简化实现示例**

```java
@Entity
public class Message {
    @Id
    private Long id;  // 手动设置Snowflake生成的ID
    
    private String content;
    
    @PrePersist  // 插入前自动调用
    public void generateId() {
        if (this.id == null) {
            this.id = SnowflakeIdWorker.generateId();
        }
    }
}

// Snowflake生成器（简化版）
public class SnowflakeIdWorker {
    private static long workerId = 1;  // 机器ID
    private static long sequence = 0;  // 序列号
    
    public static synchronized long generateId() {
        long timestamp = System.currentTimeMillis();
        // 实际实现会更复杂，这里只是示意
        return (timestamp << 22) | (workerId << 12) | sequence++;
    }
}
```

**📊 Snowflake vs UUID 对比**

| 特性 | **Snowflake** | **UUID** |
|-----|--------------|----------|
| **长度** | `64位数字（19位十进制）` | `128位（36字符）` |
| **排序** | `趋势递增，索引友好` | `无序，索引性能差` |
| **可读性** | `纯数字，相对直观` | `带横杠，不直观` |
| **生成位置** | `程序端，高性能` | `程序端，高性能` |

> 💡 **实际开发建议**  
> 互联网大厂常用Snowflake算法，既保证全局唯一，又保持趋势递增特性

---

## 5. 🎯 实际应用建议


### 5.1 如何选择主键策略


**🔍 决策流程图**

```
开始选择主键策略
        │
        ▼
   是否分布式系统？
    ╱        ╲
  是           否
  │            │
  ▼            ▼
Snowflake   数据库类型？
  或           ╱    ╲
UUID      MySQL   Oracle
            │       │
            ▼       ▼
        IDENTITY SEQUENCE
```

**📋 场景推荐表**

| 场景 | **推荐策略** | **理由** |
|-----|------------|---------|
| 🔸 **单机MySQL应用** | `IDENTITY` | `简单高效，数据库原生支持` |
| 🔸 **Oracle数据库** | `SEQUENCE` | `Oracle推荐方式，性能好` |
| 🔸 **需要换数据库** | `AUTO` | `自动适配，灵活性高` |
| 🔸 **分布式系统** | `Snowflake` | `全局唯一，趋势递增` |
| 🔸 **跨库数据迁移** | `UUID` | `绝对唯一，无冲突` |

### 5.2 常见问题解答


**❓ 为什么主键要用Long而不是Integer？**

```
Integer范围：-21亿 ~ 21亿
Long范围：-900万亿 ~ 900万亿

用户表示例：
- Integer：最多21亿用户（微信、抖音早超了）
- Long：几乎用不完

结论：互联网应用统一用Long更保险
```

**❓ 主键能用业务字段吗（如身份证号）？**

```
❌ 不推荐原因：
1. 业务字段可能变化（身份证升位、手机号换运营商）
2. 影响外键关联表（主键变了，关联都要改）
3. 隐私安全问题（URL暴露身份证号）

✅ 推荐做法：
主键用无意义的ID，业务字段加唯一索引
```

**❓ 为什么有些框架主键用String类型？**

```
String主键场景：
- UUID主键（36位字符串）
- 自定义编码规则（如：ORD20250801001）
- 兼容遗留系统（老系统用字符主键）

Long主键场景：
- 数据库自增
- Snowflake算法
- 性能要求高（数字比字符串快）
```

### 5.3 最佳实践建议


**✅ 推荐做法**

```java
// 1. 统一主键基类（所有实体继承）
@MappedSuperclass
public abstract class BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 省略getter/setter
}

// 2. 具体实体只需关注业务字段
@Entity
public class User extends BaseEntity {
    // 自动拥有id字段
    private String username;
    private String email;
}
```

**⚠️ 避免的做法**

```java
// ❌ 错误1：主键可以为null
@Id
private Long id;  // 没有@GeneratedValue，需要手动赋值

// ❌ 错误2：用int做主键
@Id
@GeneratedValue
private int id;  // 范围太小，容易溢出

// ❌ 错误3：忘记配置策略
@Id
@GeneratedValue  // 没指定strategy，依赖默认AUTO
private Long id;  // 不同数据库表现可能不一致
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的概念


**🔸 主键的本质作用**
- 唯一标识每条记录
- 加速查询性能
- 建立表关联关系

**🔸 四大主键生成策略**

| 策略 | **原理** | **适用数据库** | **场景** |
|-----|---------|--------------|---------|
| `AUTO` | `自动选择` | `所有` | `不确定数据库类型` |
| `IDENTITY` | `数据库自增` | `MySQL、SQL Server` | `单机应用最常用` |
| `SEQUENCE` | `序列对象` | `Oracle、PostgreSQL` | `Oracle首选` |
| `TABLE` | `专用表模拟` | `所有` | `兼容性要求高` |

**🔸 高级方案对比**

```
UUID特点：
✅ 全局唯一，分布式友好
❌ 无序，索引性能差

Snowflake特点：
✅ 全局唯一且趋势递增
✅ 性能好，索引友好
❌ 需要配置机器ID
```

### 6.2 记忆要点


**🧠 主键策略选择口诀**
```
单机MySQL用IDENTITY，
Oracle首选SEQUENCE策，
分布式系统Snowflake，
跨库迁移UUID佳。
```

**🎯 学习检查清单**

- [ ] 理解主键的作用和重要性
- [ ] 掌握@Id和@GeneratedValue注解
- [ ] 熟悉四大生成策略的区别
- [ ] 了解UUID和Snowflake的应用场景
- [ ] 能根据实际需求选择合适的策略

### 6.3 实战建议


**💡 新手学习路径**
```
第1步：用IDENTITY策略练手（最简单）
  ↓
第2步：尝试SEQUENCE配置（加深理解）
  ↓
第3步：了解UUID方案（拓展视野）
  ↓
第4步：研究Snowflake（实战必备）
```

**🚀 进阶方向**
- 深入理解数据库索引原理
- 学习分布式ID生成中间件（如美团Leaf）
- 研究主键对查询性能的影响
- 掌握复合主键和联合主键

---

> 💡 **学习提示**  
> 主键策略没有绝对的好坏，关键是根据实际项目需求选择。单机应用IDENTITY够用，分布式系统建议Snowflake，追求绝对唯一可用UUID。实际开发中，团队规范和历史遗留也是重要考虑因素。