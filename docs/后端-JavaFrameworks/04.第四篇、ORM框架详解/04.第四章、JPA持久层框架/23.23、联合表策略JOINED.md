---
title: 23、联合表策略JOINED
---
## 📚 目录

1. [联合表策略基本概念](#1-联合表策略基本概念)
2. [JOINED策略工作原理](#2-JOINED策略工作原理)
3. [数据库表结构设计](#3-数据库表结构设计)
4. [实体类配置详解](#4-实体类配置详解)
5. [查询操作与性能](#5-查询操作与性能)
6. [外键约束与数据一致性](#6-外键约束与数据一致性)
7. [适用场景分析](#7-适用场景分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 联合表策略基本概念


### 1.1 什么是联合表继承策略


**生活化理解**：

想象一个图书馆的分类系统：
```
总档案柜（基础信息）
├── 书籍编号
├── 书名  
├── 作者
└── 类别标记

专业档案柜（详细信息）
├── 技术书柜 → 存放编程语言、技术栈等专业信息
├── 小说柜 → 存放题材、系列等小说特有信息
└── 教材柜 → 存放学科、年级等教材特定信息

查书时：先去总档案柜找基础信息，再根据类别去对应专业柜找详细信息
```

**转换成数据库**：
```
这就是JOINED策略的核心思想！
- 总档案柜 = 父类表（存储共同属性）
- 专业档案柜 = 子类表（存储特有属性）  
- 通过外键关联 = 通过书籍编号关联
```

### 1.2 JOINED与其他策略的区别


**📊 三种继承策略对比**：

| 策略类型 | **表的数量** | **数据存储** | **查询方式** | **优缺点** |
|---------|------------|------------|------------|-----------|
| **SINGLE_TABLE** | `1张表` | `所有数据挤在一起` | `单表查询，快` | `浪费空间，列很多NULL` |
| **JOINED** | `多张表` | `数据分开存储` | `需要JOIN查询` | `规范整洁，查询慢一些` |
| **TABLE_PER_CLASS** | `每个类一张表` | `各自独立存储` | `UNION查询` | `数据冗余，难维护` |

**🔍 为什么需要JOINED策略**：
```
问题场景：
假设你要管理员工信息，有正式员工和实习生

SINGLE_TABLE方式（单表继承）：
员工表 columns: id, name, age, salary, school, mentor, ...
问题：
- 正式员工的school和mentor字段永远是NULL  
- 实习生的salary字段也是NULL
- 表结构臃肿，很多无用字段

JOINED方式（联合表继承）：
员工表: id, name, age（共同属性）
正式员工表: employee_id, salary（特有属性，外键关联员工表）
实习生表: employee_id, school, mentor（特有属性，外键关联员工表）

优势：
✅ 表结构清晰，没有多余的NULL字段
✅ 符合数据库设计规范（第三范式）
✅ 扩展性好，新增类型只需加表
```

### 1.3 核心配置注解


**🔖 关键注解说明**：

```java
@Inheritance(strategy = InheritanceType.JOINED)
```

这行代码告诉JPA：**"用联合表的方式来处理继承关系"**

**通俗解释**：
- `@Inheritance` = 继承策略注解
- `strategy` = 策略选择
- `InheritanceType.JOINED` = 联合表模式

---

## 2. ⚙️ JOINED策略工作原理


### 2.1 数据存储机制


**📦 数据如何存储**：

假设我们有这样的类结构：
```
动物类（Animal）
├── 共同属性：id, name, age
│
├── 猫类（Cat）
│   └── 特有属性：furColor（毛色）
│
└── 鱼类（Fish）
    └── 特有属性：waterType（水质类型）
```

**存储过程详解**：
```
第1步：创建一只猫
Cat cat = new Cat();
cat.setName("小花");
cat.setAge(2);
cat.setFurColor("橙色");

第2步：JPA的存储动作
1. 在Animal表插入一条记录
   INSERT INTO Animal (id, name, age) VALUES (1, '小花', 2)

2. 在Cat表插入一条记录（带外键）
   INSERT INTO Cat (id, furColor) VALUES (1, '橙色')
   
注意：Cat表的id既是主键，也是外键，指向Animal表
```

**🔄 完整数据流程图**：
```
保存Cat对象
    ↓
JPA分析：这是Cat类，继承自Animal
    ↓
步骤1: 保存父类属性 → Animal表
    ↓
步骤2: 保存子类属性 → Cat表（关联父类ID）
    ↓
事务提交：两张表数据关联成功
```

### 2.2 查询数据机制


**🔍 查询过程详解**：

**场景1：查询具体的Cat对象**
```java
Cat cat = entityManager.find(Cat.class, 1L);
```

**JPA自动生成的SQL**：
```sql
SELECT 
    a.id, a.name, a.age,    -- 从Animal表获取
    c.furColor              -- 从Cat表获取
FROM Animal a
INNER JOIN Cat c ON a.id = c.id
WHERE a.id = 1
```

**通俗解释**：
1. JPA知道你要查Cat类
2. 自动去Animal表找基础信息
3. 再去Cat表找特有信息  
4. 用JOIN把两部分数据拼起来
5. 组装成完整的Cat对象返回给你

**场景2：查询所有动物**
```java
List<Animal> animals = entityManager
    .createQuery("FROM Animal", Animal.class)
    .getResultList();
```

**JPA生成的SQL**：
```sql
SELECT 
    a.id, a.name, a.age,
    CASE 
        WHEN c.id IS NOT NULL THEN 'Cat'
        WHEN f.id IS NOT NULL THEN 'Fish'
        ELSE 'Animal'
    END as type
FROM Animal a
LEFT JOIN Cat c ON a.id = c.id
LEFT JOIN Fish f ON a.id = f.id
```

**查询逻辑说明**：
```
1. 从Animal表查所有记录
2. LEFT JOIN所有子类表
3. 通过判断子类表ID是否为NULL来确定类型
4. 根据类型实例化对应的对象（多态）
```

### 2.3 数据关联的关键点


**🔑 外键关联机制**：

```
Animal表（父表）
┌────┬──────┬─────┐
│ ID │ NAME │ AGE │
├────┼──────┼─────┤
│ 1  │ 小花 │ 2   │  ← 主键
│ 2  │ 金鱼 │ 1   │
└────┴──────┴─────┘
        ↑
        │ 外键关联
        │
Cat表（子表）
┌────┬──────────┐
│ ID │ FURCOLOR │
├────┼──────────┤
│ 1  │ 橙色     │  ← 主键+外键
└────┴──────────┘

关系说明：
• Cat表的ID既是主键，也是外键
• 它指向Animal表的ID
• 这样就能找到对应的父类数据
```

**⚠️ 重要理解点**：
```
问：为什么Cat表的ID要关联Animal表？
答：因为一个Cat对象的数据分散在两张表里
    - Animal表存储：id, name, age
    - Cat表存储：id, furColor
    必须通过相同的ID才能把数据关联起来

问：如果删除Animal表的记录会怎样？
答：由于外键约束，Cat表对应记录也必须删除
    这保证了数据的一致性
```

---

## 3. 🗂️ 数据库表结构设计


### 3.1 表结构规范性


**📐 标准的表结构设计**：

以员工管理系统为例，看看JOINED策略如何设计表：

```
业务需求：
- 员工有共同属性：工号、姓名、邮箱
- 正式员工特有：薪资、部门
- 临时工特有：时薪、合同到期日

传统设计（单表，不推荐）：
EMPLOYEE
├── id (PK)
├── name
├── email
├── employee_type        ← 区分类型
├── salary               ← 临时工为NULL
├── department           ← 临时工为NULL  
├── hourly_rate          ← 正式员工为NULL
└── contract_end_date    ← 正式员工为NULL
问题：大量NULL值，浪费空间

JOINED设计（推荐）：
EMPLOYEE (父表)
├── id (PK)
├── name
├── email
└── dtype               ← JPA自动添加的类型区分字段

FULL_TIME_EMPLOYEE (子表)
├── id (PK, FK → EMPLOYEE)
├── salary
└── department

TEMP_EMPLOYEE (子表)
├── id (PK, FK → EMPLOYEE)
├── hourly_rate
└── contract_end_date
```

**✅ 符合数据库三大范式**：
```
第一范式（1NF）：每个字段都是原子性的
• ✓ 没有重复组，每个字段都是单一值

第二范式（2NF）：非主键字段完全依赖主键
• ✓ salary完全依赖employee_id
• ✓ hourly_rate完全依赖employee_id

第三范式（3NF）：非主键字段不存在传递依赖
• ✓ 没有字段依赖于其他非主键字段
• ✓ 每个表只存储与该实体直接相关的属性
```

### 3.2 主键与外键设计


**🔐 主键设计策略**：

```sql
-- 父表主键（独立生成）
CREATE TABLE employee (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100),
    dtype VARCHAR(31)  -- 鉴别器字段
);

-- 子表主键（既是主键也是外键）
CREATE TABLE full_time_employee (
    id BIGINT PRIMARY KEY,
    salary DECIMAL(10,2),
    department VARCHAR(50),
    FOREIGN KEY (id) REFERENCES employee(id)
        ON DELETE CASCADE  -- 级联删除
);

CREATE TABLE temp_employee (
    id BIGINT PRIMARY KEY,
    hourly_rate DECIMAL(10,2),
    contract_end_date DATE,
    FOREIGN KEY (id) REFERENCES employee(id)
        ON DELETE CASCADE
);
```

**🔗 外键约束说明**：
```
ON DELETE CASCADE 的作用：
当删除employee表的记录时，自动删除对应的子表记录

示例：
DELETE FROM employee WHERE id = 1;

执行后：
1. employee表中id=1的记录被删除
2. full_time_employee中id=1的记录自动删除（如果存在）
3. 保证数据一致性，不会出现孤儿记录

其他约束选项：
• ON DELETE RESTRICT：有子记录时禁止删除父记录
• ON DELETE SET NULL：删除父记录时，子记录外键设为NULL
• ON DELETE CASCADE：删除父记录时，级联删除子记录（推荐）
```

### 3.3 鉴别器字段(DTYPE)


**🏷️ 什么是鉴别器字段**：

鉴别器字段就像商品的"分类标签"，告诉系统这条记录属于哪个具体类型。

```
EMPLOYEE表数据示例：
┌────┬────────┬──────────────────┬────────────┐
│ ID │ NAME   │ EMAIL            │ DTYPE      │
├────┼────────┼──────────────────┼────────────┤
│ 1  │ 张三   │ zhang@email.com  │ FullTime   │ ← 正式员工
│ 2  │ 李四   │ li@email.com     │ Temp       │ ← 临时工
│ 3  │ 王五   │ wang@email.com   │ FullTime   │ ← 正式员工
└────┴────────┴──────────────────┴────────────┘

DTYPE字段的作用：
1. JPA查询时判断应该实例化哪个类
2. 确定需要JOIN哪个子表
3. 实现多态查询
```

**自定义鉴别器值**：
```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "dtype")  // 默认名称
public class Employee {
    // ...
}

@Entity
@DiscriminatorValue("FULL_TIME")  // 自定义值
public class FullTimeEmployee extends Employee {
    // ...
}

@Entity  
@DiscriminatorValue("TEMPORARY")  // 自定义值
public class TempEmployee extends Employee {
    // ...
}
```

---

## 4. 💻 实体类配置详解


### 4.1 父类实体配置


**🎓 完整的父类配置示例**：

```java
@Entity
@Table(name = "employee")
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "emp_type", discriminatorType = DiscriminatorType.STRING)
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(unique = true)
    private String email;
    
    // 构造方法、getter/setter
}
```

**📝 注解详细说明**：

| 注解 | **作用** | **参数说明** |
|------|---------|------------|
| `@Entity` | `声明这是JPA实体类` | `无参数` |
| `@Table` | `指定表名` | `name="employee"表名` |
| `@Inheritance` | `声明继承策略` | `strategy=JOINED联合表模式` |
| `@DiscriminatorColumn` | `配置鉴别器字段` | `name字段名,discriminatorType类型` |
| `@Id` | `声明主键` | `无参数` |
| `@GeneratedValue` | `主键生成策略` | `IDENTITY自增长` |

**🔍 配置要点解析**：
```
1. @Inheritance必须放在继承树的根类上
   - 只需要在Employee类配置一次
   - 子类会自动继承这个策略

2. @DiscriminatorColumn配置鉴别器
   - name: 字段名称（默认DTYPE）
   - discriminatorType: 字段类型（STRING、INTEGER、CHAR）
   - 推荐用STRING类型，更直观

3. 主键生成策略要统一
   - 父类和子类共用同一个ID序列
   - 通常用IDENTITY或SEQUENCE
```

### 4.2 子类实体配置


**🔧 子类配置示例**：

```java
@Entity
@Table(name = "full_time_employee")
@DiscriminatorValue("FULL_TIME")
public class FullTimeEmployee extends Employee {
    
    @Column(name = "salary", precision = 10, scale = 2)
    private BigDecimal salary;
    
    @Column(length = 50)
    private String department;
    
    // getter/setter
}

@Entity
@Table(name = "temp_employee")  
@DiscriminatorValue("TEMP")
public class TempEmployee extends Employee {
    
    @Column(name = "hourly_rate", precision = 8, scale = 2)
    private BigDecimal hourlyRate;
    
    @Column(name = "contract_end_date")
    private LocalDate contractEndDate;
    
    // getter/setter
}
```

**📌 子类配置要点**：
```
1. 必须继承父类
   extends Employee

2. 指定子类表名
   @Table(name = "full_time_employee")

3. 配置鉴别器值
   @DiscriminatorValue("FULL_TIME")
   这个值会存入父表的emp_type字段

4. 不需要重复声明ID
   ID字段从父类继承
   数据库会自动设置外键关联

5. 只配置子类特有的属性
   共同属性在父类已经定义
```

### 4.3 关系映射配置


**🔗 子类中的关联关系**：

JOINED策略下，子类也可以有自己的关联关系：

```java
@Entity
@DiscriminatorValue("FULL_TIME")
public class FullTimeEmployee extends Employee {
    
    private BigDecimal salary;
    
    // 正式员工特有的关联：项目组
    @ManyToMany
    @JoinTable(
        name = "employee_project",
        joinColumns = @JoinColumn(name = "employee_id"),
        inverseJoinColumns = @JoinColumn(name = "project_id")
    )
    private Set<Project> projects = new HashSet<>();
    
    // 正式员工特有的关联：直接上级
    @ManyToOne
    @JoinColumn(name = "manager_id")
    private FullTimeEmployee manager;
}
```

**关系映射要点**：
```
1. 关联关系独立于继承策略
   - 父类可以有关联
   - 子类也可以有自己的关联
   - 两者互不影响

2. 外键存储位置
   - @ManyToOne: 外键在当前子类表
   - @OneToMany: 外键在对方表
   - @ManyToMany: 外键在中间表

3. 查询时的JOIN复杂度
   - 继承关系：JOIN父表
   - 关联关系：JOIN关联表
   - 两者叠加可能产生多个JOIN
```

---

## 5. 🔍 查询操作与性能


### 5.1 基本查询操作


**📋 常用查询场景**：

**场景1：根据ID查询具体类型**
```java
// 查询ID为1的正式员工
FullTimeEmployee employee = entityManager.find(FullTimeEmployee.class, 1L);

// JPA生成的SQL：
// SELECT e.id, e.name, e.email, 
//        f.salary, f.department
// FROM employee e
// INNER JOIN full_time_employee f ON e.id = f.id  
// WHERE e.id = 1
```

**场景2：查询所有员工（多态查询）**
```java
List<Employee> allEmployees = entityManager
    .createQuery("FROM Employee", Employee.class)
    .getResultList();

// JPA生成的SQL：
// SELECT e.id, e.name, e.email, e.emp_type,
//        f.salary, f.department,
//        t.hourly_rate, t.contract_end_date
// FROM employee e
// LEFT JOIN full_time_employee f ON e.id = f.id
// LEFT JOIN temp_employee t ON e.id = t.id
```

**💡 查询结果说明**：
```
多态查询的魔法：
1. JPA根据emp_type字段判断类型
2. 实例化对应的子类对象
3. 返回的List中包含不同类型的对象

示例返回结果：
[
    FullTimeEmployee(id=1, name="张三", salary=10000),
    TempEmployee(id=2, name="李四", hourlyRate=50),
    FullTimeEmployee(id=3, name="王五", salary=12000)
]

可以正常使用多态：
for (Employee emp : allEmployees) {
    if (emp instanceof FullTimeEmployee) {
        FullTimeEmployee fte = (FullTimeEmployee) emp;
        System.out.println("月薪: " + fte.getSalary());
    }
}
```

### 5.2 查询性能分析


**⚡ JOIN操作的性能影响**：

**性能开销来源**：
```
1. 多表JOIN操作
   查询一个对象 = 至少1次JOIN
   查询所有员工 = N个LEFT JOIN（N=子类数量）

2. 数据传输量
   需要获取所有子类表的字段
   即使某些字段为NULL也要查询

3. 索引使用
   JOIN字段必须有索引
   否则性能极差

性能对比：
单表查询（SINGLE_TABLE）：
  SELECT * FROM employee WHERE id = 1
  ⚡⚡⚡⚡⚡ 最快

联合表查询（JOINED）：  
  SELECT * FROM employee e
  INNER JOIN full_time_employee f ON e.id = f.id
  WHERE e.id = 1
  ⚡⚡⚡☆☆ 需要JOIN，稍慢

每类一表（TABLE_PER_CLASS）：
  SELECT * FROM full_time_employee WHERE id = 1
  UNION ALL
  SELECT * FROM temp_employee WHERE id = 1
  ⚡⚡☆☆☆ 需要UNION，更慢
```

**📊 性能优化建议**：

```
1. 精确查询类型
   ❌ 不好的做法：
   Employee emp = entityManager.find(Employee.class, 1L);
   // JPA不知道具体类型，要LEFT JOIN所有子表

   ✅ 好的做法：
   FullTimeEmployee emp = entityManager.find(FullTimeEmployee.class, 1L);
   // 明确类型，只JOIN对应子表

2. 使用索引优化
   CREATE INDEX idx_employee_type ON employee(emp_type);
   CREATE INDEX idx_fk_employee ON full_time_employee(id);
   
3. 批量查询优化
   // 使用IN查询代替循环查询
   ✅ entityManager.createQuery(
       "FROM FullTimeEmployee WHERE id IN :ids", 
       FullTimeEmployee.class)
       .setParameter("ids", Arrays.asList(1L, 2L, 3L))
       .getResultList();
```

### 5.3 复杂查询场景


**🔎 带条件的多态查询**：

```java
// 查询薪资大于8000的正式员工
List<FullTimeEmployee> highSalary = entityManager.createQuery(
    "SELECT f FROM FullTimeEmployee f WHERE f.salary > :minSalary", 
    FullTimeEmployee.class)
    .setParameter("minSalary", new BigDecimal("8000"))
    .getResultList();

// 生成的SQL：
// SELECT e.id, e.name, e.email, f.salary, f.department
// FROM employee e
// INNER JOIN full_time_employee f ON e.id = f.id
// WHERE f.salary > 8000
```

**联合查询所有高收入员工**：
```java
// JPQL查询（包括正式员工和临时工高收入者）
List<Employee> highEarners = entityManager.createQuery(
    "SELECT e FROM Employee e " +
    "WHERE TYPE(e) = FullTimeEmployee AND TREAT(e AS FullTimeEmployee).salary > 8000 " +
    "OR TYPE(e) = TempEmployee AND TREAT(e AS TempEmployee).hourlyRate > 100",
    Employee.class)
    .getResultList();
```

**💡 复杂查询说明**：
```
TYPE(e) = 判断实体类型
TREAT(e AS FullTimeEmployee) = 类型转换，访问子类特有属性

生成的SQL会包含：
1. JOIN所有相关子表
2. CASE WHEN判断类型
3. 多个条件的OR组合

性能提示：
• 复杂条件查询建议分开查询后合并
• 避免在WHERE中使用TYPE()和TREAT()
• 考虑使用原生SQL优化性能
```

---

## 6. 🔒 外键约束与数据一致性


### 6.1 外键约束的作用


**🛡️ 为什么需要外键约束**：

外键约束就像"连体婴"的纽带，保证父子数据永远同步。

```
没有外键约束的问题：
EMPLOYEE表
┌────┬────────┐
│ ID │ NAME   │
├────┼────────┤
│ 1  │ 张三   │  ← 被删除了
└────┴────────┘

FULL_TIME_EMPLOYEE表  
┌────┬────────┐
│ ID │ SALARY │
├────┼────────┤
│ 1  │ 10000  │  ← 孤儿记录！找不到对应的员工
└────┴────────┘

有外键约束的保护：
1. 删除父记录 → 自动级联删除子记录
2. 或者禁止删除（如果有子记录存在）
3. 保证数据完整性
```

### 6.2 级联操作配置


**⚙️ JPA中的级联配置**：

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    // 注意：JOINED策略中，级联主要体现在关联关系上
    // 继承关系的级联由数据库外键约束控制
}

@Entity
public class FullTimeEmployee extends Employee {
    
    private BigDecimal salary;
    
    // 如果有关联关系，可以配置级联
    @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Bonus> bonuses;
}
```

**🔧 数据库级别的级联**：

```sql
-- 创建子表时配置外键约束
CREATE TABLE full_time_employee (
    id BIGINT PRIMARY KEY,
    salary DECIMAL(10,2),
    department VARCHAR(50),
    CONSTRAINT fk_employee 
        FOREIGN KEY (id) REFERENCES employee(id)
        ON DELETE CASCADE        -- 删除父记录时级联删除
        ON UPDATE CASCADE        -- 更新父记录ID时级联更新
);

-- 级联策略选择：
-- CASCADE: 级联操作（推荐用于JOINED）
-- RESTRICT: 有子记录时禁止操作（适合重要数据）
-- SET NULL: 设置为NULL（不适合JOINED，因为ID不能为NULL）
```

### 6.3 数据一致性保证


**✅ JOINED策略的一致性机制**：

**机制1：事务保证**
```java
@Transactional
public void saveEmployee(FullTimeEmployee employee) {
    entityManager.persist(employee);
    // JPA在一个事务内完成：
    // 1. INSERT INTO employee (name, email, emp_type) VALUES (...)
    // 2. INSERT INTO full_time_employee (id, salary) VALUES (...)
    // 两个操作要么都成功，要么都失败
}
```

**机制2：外键约束**
```sql
-- 数据库层面保证
-- 子表的ID必须存在于父表中
INSERT INTO full_time_employee (id, salary) VALUES (999, 10000);
-- 错误: 外键约束失败，employee表中不存在id=999的记录
```

**机制3：唯一性约束**
```
一个employee记录只能对应一个子类记录
ID=1的员工：
• 不能同时是FullTimeEmployee和TempEmployee
• 由主键约束保证（子表ID是主键，不能重复）
```

**⚠️ 常见一致性问题**：
```
问题1：手动修改数据库破坏一致性
❌ 直接在数据库删除employee记录
解决：配置ON DELETE CASCADE

问题2：并发修改冲突
❌ 两个事务同时修改同一员工
解决：使用乐观锁(@Version)或悲观锁

问题3：部分更新失败
❌ 更新父类成功，更新子类失败
解决：使用事务保证原子性
```

---

## 7. 📌 适用场景分析


### 7.1 最佳适用场景


**✅ JOINED策略适合的情况**：

**场景1：数据规范性要求高**
```
企业级应用、金融系统、电商平台
要求：
• 数据库设计符合范式
• 没有冗余字段
• 便于数据分析和报表

示例：
- 订单系统（普通订单、团购订单、秒杀订单）
- 商品管理（实体商品、虚拟商品、服务类商品）
- 用户系统（个人用户、企业用户、VIP用户）
```

**场景2：子类属性差异大**
```
当子类有很多特有属性时：
• FullTimeEmployee: 10个特有字段
• TempEmployee: 8个特有字段
• Intern: 6个特有字段

用JOINED：
• Employee表: 3个共同字段
• 3个子类表: 各自的特有字段
• 总共: 3 + 10 + 8 + 6 = 27个字段分布在4张表

用SINGLE_TABLE：  
• 1张表包含所有字段
• 大量NULL值浪费空间
```

**场景3：需要独立查询子类**
```java
// 经常需要单独查询某个子类
List<FullTimeEmployee> fullTime = repository.findAll();
// JOINED: 只JOIN full_time_employee表
// SINGLE_TABLE: 需要扫描整张表并过滤

// 子类数据量大且经常独立统计
long count = entityManager.createQuery(
    "SELECT COUNT(f) FROM FullTimeEmployee f", Long.class)
    .getSingleResult();
// JOINED: 只统计子类表，效率高
```

**场景4：扩展性需求高**
```
业务发展可能新增子类：
Employee
├── FullTimeEmployee
├── TempEmployee  
├── Intern（新增）
├── Contractor（新增）
└── ...

JOINED优势：
• 新增子类：只需创建新表
• 不影响现有表结构
• 符合开闭原则（对扩展开放）
```

### 7.2 不适用的场景


**❌ 不推荐使用JOINED的情况**：

**场景1：查询性能优先**
```
高并发、低延迟系统
问题：
• 每次查询都需要JOIN
• 多表JOIN增加查询时间
• 数据库连接池压力大

替代方案：
• SINGLE_TABLE（查询最快）
• 或使用缓存减少数据库查询
```

**场景2：子类属性很少**
```
如果子类只有1-2个特有属性：
Employee
├── name, age, email（父类）
└── FullTimeEmployee
    └── salary（就1个字段）

问题：
• 为1个字段创建表，JOIN开销不划算
• SINGLE_TABLE更简单高效
```

**场景3：频繁的多态查询**
```java
// 经常需要查询所有类型
List<Employee> all = repository.findAll();

JOINED问题：
• 需要LEFT JOIN所有子类表
• 查询语句复杂
• 性能开销大

SELECT e.*, f.*, t.*, i.*
FROM employee e
LEFT JOIN full_time_employee f ON e.id = f.id
LEFT JOIN temp_employee t ON e.id = t.id  
LEFT JOIN intern i ON e.id = i.id
-- 子类越多，JOIN越多
```

**场景4：遗留系统迁移**
```
从单表系统迁移到JOINED：
• 需要拆分数据到多张表
• 修改所有相关SQL
• 应用代码可能需要调整
• 迁移风险高

建议：
• 新系统：根据需求选择JOINED
• 老系统：谨慎迁移，可能保持原方案
```

### 7.3 性能与规范的权衡


**⚖️ 决策天平**：

```
选择JOINED的理由：
优先级1: 数据规范性 > 查询性能
优先级2: 存储优化 > 查询速度
优先级3: 可维护性 > 开发便利性
优先级4: 长期扩展 > 短期效率

选择其他策略的理由：
优先级1: 查询性能 > 规范性（用SINGLE_TABLE）
优先级2: 简单性 > 复杂性（用SINGLE_TABLE）
优先级3: 独立性 > 关联性（用TABLE_PER_CLASS）
```

**💡 实际决策建议**：
```
1. 评估子类数量和复杂度
   • 2-3个子类，属性差异小 → SINGLE_TABLE
   • 4+个子类,属性差异大 → JOINED
   • 子类完全独立 → TABLE_PER_CLASS

2. 评估查询模式  
   • 多态查询为主 → SINGLE_TABLE
   • 子类独立查询为主 → JOINED
   • 两者都有 → 综合考虑，可能JOINED

3. 评估性能要求
   • 高并发、严格性能要求 → SINGLE_TABLE
   • 中等负载、注重规范 → JOINED
   • 数据分析、报表场景 → JOINED

4. 评估团队能力
   • 团队熟悉JPA → JOINED
   • 新手团队 → SINGLE_TABLE（简单）
   • DBA主导 → JOINED（符合数据库设计）
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 JOINED本质：父类和子类分表存储，通过外键关联
🔸 工作原理：保存时分别INSERT，查询时JOIN获取完整数据
🔸 表结构：符合数据库范式，无冗余字段，结构清晰
🔸 查询机制：具体类型用INNER JOIN，多态查询用LEFT JOIN
🔸 外键约束：保证数据一致性，支持级联操作
🔸 性能特点：规范性好但查询有JOIN开销
🔸 适用场景：子类差异大、规范性要求高、需要扩展
```

### 8.2 关键理解要点


**🔹 JOINED策略的核心思想**：
```
数据库设计视角：
• 遵循第三范式
• 消除数据冗余
• 每个表只存储相关属性
• 通过外键维护关系

面向对象视角：
• 继承关系映射到关联关系
• 父类属性在父表
• 子类属性在子表
• 对象属性分散在多表
```

**🔹 与SINGLE_TABLE的本质区别**：
```
SINGLE_TABLE（单表继承）：
数据存储：一张表存所有数据
查询方式：单表查询，通过DTYPE区分
优势：查询快，实现简单
劣势：大量NULL字段，浪费空间

JOINED（联合表继承）：
数据存储：多张表分别存储
查询方式：JOIN查询组合数据
优势：规范整洁，无冗余
劣势：查询慢，实现复杂

选择依据：
性能优先 → SINGLE_TABLE
规范优先 → JOINED
```

**🔹 查询性能的影响因素**：
```
1. JOIN操作数量
   • 子类越多，LEFT JOIN越多
   • 明确类型查询减少JOIN

2. 索引使用
   • 外键字段必须有索引
   • emp_type鉴别器字段建议索引

3. 数据量大小  
   • 父表数据多，JOIN压力大
   • 考虑分表或缓存策略

4. 查询频率
   • 高频查询考虑缓存
   • 分析查询优化
```

### 8.3 实际应用建议


**💼 开发实践要点**：

```
1. 实体类设计
   ✅ 父类标注@Inheritance(JOINED)
   ✅ 配置合适的@DiscriminatorColumn
   ✅ 子类只定义特有属性
   ✅ 统一主键生成策略

2. 数据库设计
   ✅ 子表ID设为主键+外键
   ✅ 配置ON DELETE CASCADE
   ✅ 所有JOIN字段建索引
   ✅ 合理设计表名和字段名

3. 查询优化  
   ✅ 明确类型避免多余JOIN
   ✅ 使用批量查询
   ✅ 关键查询考虑原生SQL
   ✅ 启用二级缓存

4. 维护性考虑
   ✅ 文档记录继承关系
   ✅ 数据迁移脚本完善
   ✅ 监控JOIN查询性能
   ✅ 建立回滚机制
```

**🎯 常见问题应对**：

```
问题1：查询慢怎么办？
解决：
• 检查索引是否完善
• 考虑查询缓存
• 评估是否改用SINGLE_TABLE
• 使用原生SQL优化关键查询

问题2：如何处理深层继承？
建议：
• 尽量避免超过3层继承
• 考虑组合优于继承
• 深层继承用SINGLE_TABLE可能更好

问题3：扩展新子类注意什么？
步骤：
• 创建子类实体
• 配置@DiscriminatorValue
• 创建对应数据库表
• 添加外键约束
• 更新相关查询

问题4：如何迁移到JOINED策略？
方案：
• 备份现有数据
• 创建新表结构
• 编写数据迁移脚本
• 逐步迁移测试
• 新老并行运行
• 确认无误后切换
```

### 8.4 学习路径建议


**📚 掌握步骤**：

```
阶段一：基础理解
□ 理解JOINED的基本概念
□ 掌握注解配置方法
□ 能创建简单的继承实体
□ 理解JOIN查询原理

阶段二：实践应用  
□ 设计合理的表结构
□ 处理各种查询场景
□ 优化查询性能
□ 解决常见问题

阶段三：深入优化
□ 分析复杂继承设计
□ 对比不同策略优劣
□ 根据场景选择方案
□ 处理性能瓶颈
```

**🧠 记忆口诀**：
```
联合表策略记心间，父子分表外键连
共同属性存父表，特有字段在子端
查询需要JOIN操作，鉴别字段判类型
规范整洁是优势，性能开销要权衡
场景选择需谨慎，适合才是最佳选
```

**最后建议**：
JOINED策略的核心是"**规范性**"和"**扩展性**"，当你的系统更看重数据库设计的规范性、未来的扩展能力，并且能接受一定的查询性能开销时，JOINED就是最好的选择！