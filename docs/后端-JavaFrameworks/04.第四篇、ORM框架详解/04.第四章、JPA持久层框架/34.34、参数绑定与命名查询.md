---
title: 34、参数绑定与命名查询
---
## 📚 目录

1. [参数绑定基础概念](#1-参数绑定基础概念)
2. [命名参数详解](#2-命名参数详解)
3. [位置参数详解](#3-位置参数详解)
4. [参数绑定安全性](#4-参数绑定安全性)
5. [命名查询机制](#5-命名查询机制)
6. [动态查询构建](#6-动态查询构建)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 参数绑定基础概念


### 1.1 什么是参数绑定


**通俗理解**：就像填空题一样，先写好查询语句的框架，把具体的值留成空位，用的时候再填进去。

```
生活类比：
订外卖填地址 → "请送到___小区___号楼___室"
参数绑定    → "SELECT * FROM User WHERE name = ___"

框架固定，内容可变！
```

**专业定义**：参数绑定是指在JPQL查询语句中使用占位符，然后在执行时动态传入实际值的机制。

### 1.2 为什么需要参数绑定


**核心价值**：
- 🔒 **安全性** - 防止SQL注入攻击
- ⚡ **性能** - 查询语句可以被预编译和缓存
- 📝 **可读性** - 代码更清晰，逻辑与数据分离
- 🔄 **复用性** - 同一查询可以传不同参数反复使用

**反面例子（危险做法）**：
```java
❌ 不安全的拼接方式：
String name = userInput; // 用户输入"admin' OR '1'='1"
String jpql = "SELECT u FROM User u WHERE u.name = '" + name + "'";
// 结果：SELECT u FROM User u WHERE u.name = 'admin' OR '1'='1'
// 危险：查出了所有用户！
```

---

## 2. 📝 命名参数详解


### 2.1 命名参数的基本使用


**什么是命名参数**：用**冒号+名字**（`:name`）作为占位符，就像给空格起个名字，方便后面填值。

```java
// 基础语法示例
String jpql = "SELECT u FROM User u WHERE u.name = :userName";
                                               //↑ 命名参数

List<User> users = entityManager
    .createQuery(jpql, User.class)
    .setParameter("userName", "张三")  // 给:userName赋值
    .getResultList();
```

**语法规则**：
```
格式：:参数名
特点：
• 参数名自定义，见名知意
• 同一参数名可以多次使用
• 大小写敏感（:name 和 :Name 是两个参数）
```

### 2.2 多个命名参数


**场景**：需要多个条件筛选时

```java
// 多条件查询
String jpql = """
    SELECT u FROM User u 
    WHERE u.age >= :minAge 
      AND u.city = :cityName
      AND u.status = :userStatus
    """;

List<User> users = entityManager.createQuery(jpql, User.class)
    .setParameter("minAge", 18)        // 最小年龄
    .setParameter("cityName", "北京")   // 城市
    .setParameter("userStatus", "ACTIVE") // 状态
    .getResultList();
```

**参数复用示例**：
```java
// 同一个参数在查询中出现多次
String jpql = """
    SELECT u FROM User u 
    WHERE u.email LIKE :keyword 
       OR u.phone LIKE :keyword
    """;

// 只需要设置一次参数
query.setParameter("keyword", "%138%");
```

### 2.3 命名参数的优势


| 特点 | 说明 | 示例场景 |
|------|------|----------|
| **可读性强** | 参数名有明确含义 | `:userName`比`?1`更清楚 |
| **顺序无关** | 不用担心参数位置 | 条件顺序调整不影响代码 |
| **易于维护** | 参数变化不影响其他参数 | 增删条件很方便 |
| **支持复用** | 同名参数只需设置一次 | 多个地方用同一个值 |

---

## 3. 🔢 位置参数详解


### 3.1 位置参数的基本使用


**什么是位置参数**：用**问号+数字**（`?1`、`?2`）作为占位符，按位置顺序填值，就像按座位号对号入座。

```java
// 基础语法示例
String jpql = "SELECT u FROM User u WHERE u.name = ?1 AND u.age = ?2";
                                               //↑ 位置1  ↑ 位置2

List<User> users = entityManager
    .createQuery(jpql, User.class)
    .setParameter(1, "张三")   // 第1个位置的值
    .setParameter(2, 25)       // 第2个位置的值
    .getResultList();
```

**语法规则**：
```
格式：?位置编号
特点：
• 位置编号从1开始（不是0！）
• 必须按顺序对应
• 顺序调整会影响代码
```

### 3.2 位置参数的注意事项


**❌ 常见错误**：
```java
// 错误1：位置编号从0开始
query.setParameter(0, "value");  // 错误！应该从1开始

// 错误2：位置顺序错乱
String jpql = "... WHERE age = ?1 AND name = ?2";
query.setParameter(1, "张三")    // 错了！age应该是数字
     .setParameter(2, 25);       // 错了！name应该是字符串

// 错误3：跳过位置编号
String jpql = "... WHERE name = ?1 AND city = ?3"; // 缺少?2
```

**✅ 正确做法**：
```java
// 严格按位置顺序
String jpql = "SELECT u FROM User u WHERE u.name = ?1 AND u.age = ?2";
query.setParameter(1, "张三")   // ?1的值
     .setParameter(2, 25);      // ?2的值
```

### 3.3 命名参数 vs 位置参数


```
对比分析：

命名参数（:name）：
优点：
✓ 可读性好，参数含义清晰
✓ 顺序无关，维护方便
✓ 支持参数复用
缺点：
✗ 写法稍长一点

位置参数（?1）：
优点：
✓ 写法简洁
✓ 早期JDBC习惯用法
缺点：
✗ 可读性差，容易混淆
✗ 顺序敏感，维护困难
✗ 不支持参数复用

推荐使用：命名参数！（除非特殊原因）
```

---

## 4. 🔒 参数绑定安全性


### 4.1 SQL注入攻击原理


**什么是SQL注入**：黑客通过特殊构造的输入，改变SQL语句的逻辑，执行恶意操作。

```
攻击示例：

正常登录逻辑：
用户名：admin
密码：123456
SQL：SELECT * FROM User WHERE name='admin' AND password='123456'

SQL注入攻击：
用户名：admin' OR '1'='1
密码：（随便填）
SQL：SELECT * FROM User WHERE name='admin' OR '1'='1' AND password='...'
结果：条件永远为真，登录成功！
```

**攻击流程图**：
```
用户输入 → 字符串拼接 → 恶意SQL → 执行攻击
    ↓
"admin' OR '1'='1"
    ↓
WHERE name='admin' OR '1'='1'
    ↓
条件永远为真，绕过验证
```

### 4.2 参数绑定如何防护


**防护原理**：参数绑定会把用户输入当作**纯数据**处理，不会解释成SQL代码。

```java
// ❌ 不安全：字符串拼接
String name = "admin' OR '1'='1";
String jpql = "SELECT u FROM User u WHERE u.name = '" + name + "'";
// 结果：恶意代码被执行

// ✅ 安全：参数绑定
String jpql = "SELECT u FROM User u WHERE u.name = :name";
query.setParameter("name", "admin' OR '1'='1");
// 结果：把整个字符串当作一个普通的名字查询，查不到结果
```

**安全机制对比**：

| 方式 | 处理过程 | 安全性 |
|------|----------|--------|
| **字符串拼接** | 直接把用户输入嵌入SQL | ❌ 危险 |
| **参数绑定** | 先预编译SQL，后传入数据 | ✅ 安全 |

### 4.3 安全编码最佳实践


**核心原则**：
```
🔸 永远使用参数绑定
🔸 不要拼接用户输入
🔸 不要信任任何外部数据
🔸 双重验证：前端+后端
```

**代码对比**：
```java
// ❌ 危险做法
String searchKeyword = request.getParameter("keyword");
String jpql = "SELECT p FROM Product p WHERE p.name LIKE '%" + searchKeyword + "%'";

// ✅ 安全做法
String jpql = "SELECT p FROM Product p WHERE p.name LIKE :keyword";
query.setParameter("keyword", "%" + searchKeyword + "%");

// ⚠️ 注意：LIKE的通配符要在Java代码中添加，不是在JPQL中
```

---

## 5. 📋 命名查询机制


### 5.1 什么是命名查询


**通俗理解**：把常用的查询语句起个名字存起来，需要时直接调用，就像把常用话术做成快捷回复。

```
生活类比：
手机通讯录 → 存好电话号码，用时直接点名字拨打
命名查询   → 存好JPQL语句，用时直接调用名字查询
```

**专业定义**：在实体类上用注解预定义查询语句，运行时通过名字引用并执行。

### 5.2 @NamedQuery单个命名查询


**基本用法**：在实体类上声明查询

```java
@Entity
@NamedQuery(
    name = "User.findByCity",           // 查询名称
    query = "SELECT u FROM User u WHERE u.city = :city" // JPQL语句
)
public class User {
    @Id
    private Long id;
    private String name;
    private String city;
    // ...
}
```

**使用命名查询**：
```java
// 通过名字调用预定义的查询
List<User> users = entityManager
    .createNamedQuery("User.findByCity", User.class)
    .setParameter("city", "上海")
    .getResultList();
```

**命名规范建议**：
```
格式：实体名.操作描述

推荐：
✓ User.findByCity
✓ User.findActiveUsers
✓ Order.findByDateRange

不推荐：
✗ query1
✗ getUsersByCity
✗ findCity
```

### 5.3 @NamedQueries多个命名查询


**场景**：一个实体需要多个预定义查询

```java
@Entity
@NamedQueries({
    @NamedQuery(
        name = "User.findByCity",
        query = "SELECT u FROM User u WHERE u.city = :city"
    ),
    @NamedQuery(
        name = "User.findByAgeRange",
        query = "SELECT u FROM User u WHERE u.age BETWEEN :minAge AND :maxAge"
    ),
    @NamedQuery(
        name = "User.findActiveUsers",
        query = "SELECT u FROM User u WHERE u.status = 'ACTIVE' ORDER BY u.createTime DESC"
    )
})
public class User {
    // 实体定义...
}
```

**调用示例**：
```java
// 调用不同的命名查询
List<User> cityUsers = entityManager
    .createNamedQuery("User.findByCity", User.class)
    .setParameter("city", "北京")
    .getResultList();

List<User> ageRangeUsers = entityManager
    .createNamedQuery("User.findByAgeRange", User.class)
    .setParameter("minAge", 20)
    .setParameter("maxAge", 30)
    .getResultList();
```

### 5.4 命名查询的优势


**核心优点**：

```
🎯 提前验证：
启动时检查JPQL语法，错误早发现

⚡ 性能优化：
查询语句预编译，执行更快

📝 集中管理：
所有查询集中在实体类，便于维护

🔄 复用性强：
多处调用同一个查询，避免重复代码
```

**对比动态查询**：

| 特性 | 命名查询 | 动态查询 |
|------|----------|----------|
| **定义位置** | 实体类注解 | 业务代码中 |
| **语法检查** | 启动时验证 | 运行时才发现错误 |
| **性能** | 预编译，较快 | 每次编译，稍慢 |
| **灵活性** | 固定语句 | 可动态构建 |
| **适用场景** | 固定查询 | 复杂条件组合 |

---

## 6. 🔧 动态查询构建


### 6.1 为什么需要动态查询


**问题场景**：查询条件不确定，需要根据实际情况组合

```
实际业务需求：
用户搜索商品，可能只填：
• 名称
• 分类
• 价格范围
• 名称+分类
• 名称+价格范围
• ... 多种组合

命名查询的局限：
@NamedQuery只能定义固定语句
无法应对灵活的条件组合
```

### 6.2 StringBuilder动态拼接


**基本思路**：根据条件动态构建JPQL语句

```java
public List<User> searchUsers(String name, String city, Integer minAge) {
    StringBuilder jpql = new StringBuilder("SELECT u FROM User u WHERE 1=1");
    
    // 根据条件动态添加
    if (name != null && !name.isEmpty()) {
        jpql.append(" AND u.name LIKE :name");
    }
    if (city != null && !city.isEmpty()) {
        jpql.append(" AND u.city = :city");
    }
    if (minAge != null) {
        jpql.append(" AND u.age >= :minAge");
    }
    
    // 创建查询
    TypedQuery<User> query = entityManager.createQuery(jpql.toString(), User.class);
    
    // 设置参数（只设置有值的）
    if (name != null && !name.isEmpty()) {
        query.setParameter("name", "%" + name + "%");
    }
    if (city != null && !city.isEmpty()) {
        query.setParameter("city", city);
    }
    if (minAge != null) {
        query.setParameter("minAge", minAge);
    }
    
    return query.getResultList();
}
```

**技巧说明**：
```
WHERE 1=1 的作用：
• 简化逻辑，后面都用AND连接
• 避免判断第一个条件要用WHERE还是AND

示例：
WHERE 1=1 AND u.name LIKE :name
       ↑    ↑
     永真  统一用AND
```

### 6.3 CriteriaBuilder类型安全查询


**什么是Criteria API**：JPA提供的类型安全的动态查询API，用Java代码构建查询而不是字符串。

```java
public List<User> searchUsersTypeSafe(String name, String city, Integer minAge) {
    // 1. 获取查询构建器
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> cq = cb.createQuery(User.class);
    Root<User> user = cq.from(User.class);
    
    // 2. 动态组合条件
    List<Predicate> predicates = new ArrayList<>();
    
    if (name != null && !name.isEmpty()) {
        predicates.add(cb.like(user.get("name"), "%" + name + "%"));
    }
    if (city != null && !city.isEmpty()) {
        predicates.add(cb.equal(user.get("city"), city));
    }
    if (minAge != null) {
        predicates.add(cb.ge(user.get("age"), minAge));
    }
    
    // 3. 组合所有条件（AND关系）
    cq.where(predicates.toArray(new Predicate[0]));
    
    // 4. 执行查询
    return entityManager.createQuery(cq).getResultList();
}
```

**Criteria API优势**：
```
✅ 类型安全：编译期检查，错误早发现
✅ IDE支持：自动补全，减少拼写错误
✅ 重构友好：字段改名IDE自动更新
✅ 复杂查询：支持子查询、联表等复杂场景
```

### 6.4 动态查询最佳实践


**选择建议**：

```
📊 查询复杂度决策树：

简单固定查询
    ↓
使用 @NamedQuery

条件较少且固定
    ↓
使用 StringBuilder 拼接

条件多且复杂
    ↓
使用 Criteria API

超复杂业务逻辑
    ↓
考虑 QueryDSL 或 MyBatis
```

**代码组织建议**：
```java
// 建议：封装到Repository层
@Repository
public class UserRepository {
    
    @PersistenceContext
    private EntityManager em;
    
    // 固定查询用命名查询
    public List<User> findByCity(String city) {
        return em.createNamedQuery("User.findByCity", User.class)
                .setParameter("city", city)
                .getResultList();
    }
    
    // 动态查询用Criteria
    public List<User> searchUsers(UserSearchCriteria criteria) {
        // Criteria API 实现
        // ...
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 参数绑定：占位符机制，数据与SQL分离
🔸 命名参数：:name形式，可读性强，推荐使用
🔸 位置参数：?1形式，简洁但易混淆
🔸 SQL注入：永远使用参数绑定，不要拼接字符串
🔸 命名查询：@NamedQuery预定义，性能好复用强
🔸 动态查询：根据条件灵活组合，适应复杂业务
```

### 7.2 关键理解要点


**🔹 参数绑定为什么安全**
```
原理对比：

字符串拼接：
用户输入 → 直接嵌入SQL → 可能改变SQL逻辑 → 危险

参数绑定：
SQL模板 → 预编译 → 用户输入作为纯数据 → 安全
```

**🔹 命名查询vs动态查询**
```
选择原则：
• 查询固定、复用率高 → @NamedQuery
• 条件灵活、组合多变 → 动态查询
• 可以混合使用，优势互补
```

**🔹 动态查询的技术选型**
```
StringBuilder：
适合：条件少、逻辑简单
优点：容易理解、代码简洁
缺点：字符串拼接、不够安全

Criteria API：
适合：条件多、逻辑复杂
优点：类型安全、IDE友好
缺点：代码稍多、学习成本高
```

### 7.3 实际应用指南


**安全第一原则**：
```java
// ✅ 永远这样做
String jpql = "SELECT u FROM User u WHERE u.name = :name";
query.setParameter("name", userInput);

// ❌ 永远不要这样
String jpql = "SELECT u FROM User u WHERE u.name = '" + userInput + "'";
```

**性能优化建议**：
```
🔸 固定查询使用 @NamedQuery，启动时预编译
🔸 高频查询建议使用缓存（@Cacheable）
🔸 动态查询注意条件数量，避免过度复杂
🔸 适当使用索引优化查询性能
```

**代码组织规范**：
```
Repository层职责：
• 固定查询 → @NamedQuery + 简单方法封装
• 动态查询 → Criteria API + 参数对象封装
• 复杂逻辑 → 拆分多个方法，保持单一职责

Service层职责：
• 调用Repository方法
• 组合多个查询完成业务
• 事务管理和异常处理
```

### 7.4 常见问题与解决


**Q1: 命名参数和位置参数能混用吗？**
```
❌ 不能！同一个查询只能选一种
```

**Q2: 怎么处理IN查询的参数？**
```java
// 直接传集合
List<String> cities = Arrays.asList("北京", "上海", "广州");
String jpql = "SELECT u FROM User u WHERE u.city IN :cities";
query.setParameter("cities", cities);
```

**Q3: LIKE查询的通配符怎么加？**
```java
// ✅ 在Java代码中添加
query.setParameter("keyword", "%" + keyword + "%");

// ❌ 不要在JPQL中拼接
// "... WHERE name LIKE '%:keyword%'" ← 错误
```

**Q4: 动态查询性能会差吗？**
```
Criteria API性能：
• 首次执行稍慢（构建查询树）
• JPA会缓存生成的SQL
• 后续执行性能与普通查询相当
• 关键看索引和SQL本身
```

**核心记忆口诀**：
```
参数绑定保安全，命名位置任你选
固定查询用Named，动态灵活用Criteria
SQL拼接要不得，永远绑定是王道
```