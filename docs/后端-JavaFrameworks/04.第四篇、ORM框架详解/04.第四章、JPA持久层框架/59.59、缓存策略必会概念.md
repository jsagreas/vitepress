---
title: 59、缓存策略必会概念
---
## 📚 目录

1. [缓存基础概念](#1-缓存基础概念)
2. [一级缓存详解](#2-一级缓存详解)
3. [二级缓存详解](#3-二级缓存详解)
4. [查询缓存机制](#4-查询缓存机制)
5. [缓存并发策略](#5-缓存并发策略)
6. [缓存失效与更新](#6-缓存失效与更新)
7. [性能监控与调优](#7-性能监控与调优)
8. [实际集成方案](#8-实际集成方案)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 缓存基础概念


### 1.1 什么是ORM缓存


> 💡 **通俗理解**：缓存就像是把经常用的东西放在手边，不用每次都去远处的仓库拿

**生活场景类比**：
```
没有缓存：
你要查个单词 → 每次都去图书馆翻字典 → 很慢很累

有了缓存：
你要查个单词 → 先看看手边的小字典 → 找到了就直接用
                → 没找到才去图书馆 → 查完后记在小字典上
```

**JPA中的缓存**：
- **本质**：在内存中临时存储数据库查询结果
- **目的**：减少数据库访问次数，提升查询速度
- **原理**：用空间换时间

### 1.2 为什么需要缓存


**性能差距对比**：

| 操作类型 | 耗时 | 速度比 |
|---------|------|--------|
| 内存读取 | `~0.1毫秒` | `基准` |
| 数据库查询 | `~10毫秒` | `慢100倍` |
| 远程数据库 | `~100毫秒` | `慢1000倍` |

**缓存带来的好处**：
- ⚡ **速度提升** - 内存访问比数据库快100-1000倍
- 📉 **降低负载** - 减少数据库压力
- 💰 **节省资源** - 减少网络IO和CPU消耗
- 🚀 **用户体验** - 响应更快

### 1.3 JPA缓存的层次结构


```
应用程序请求数据
        │
        ▼
┌───────────────────┐
│   一级缓存(必有)   │ ← 事务级别，自动开启
│  Persistence      │   Session范围有效
│  Context          │
└─────────┬─────────┘
          │ 未命中
          ▼
┌───────────────────┐
│   二级缓存(可选)   │ ← 应用级别，需要配置
│  SessionFactory   │   跨Session共享
│  Level Cache      │
└─────────┬─────────┘
          │ 未命中
          ▼
┌───────────────────┐
│    查询缓存        │ ← 查询结果级别
│  Query Cache      │   缓存查询结果集
└─────────┬─────────┘
          │ 都未命中
          ▼
     访问数据库
```

---

## 2. 🔥 一级缓存详解


### 2.1 一级缓存是什么


> 📖 **核心概念**：一级缓存是JPA自动提供的事务级缓存，也叫**持久化上下文**

**关键特点**：
- ✅ **自动开启** - 不需要任何配置
- 🔒 **事务隔离** - 每个事务有独立的缓存
- ♻️ **生命周期短** - 事务结束后清空

**作用范围图示**：
```
事务1的一级缓存          事务2的一级缓存
┌─────────────┐          ┌─────────────┐
│ User(id=1)  │          │ Order(id=5) │
│ User(id=2)  │          │ Order(id=6) │
└─────────────┘          └─────────────┘
     ↓                        ↓
  事务提交                  事务提交
     ↓                        ↓
   缓存清空                 缓存清空
```

### 2.2 一级缓存工作原理


**查询流程**：
```
1. 发起查询 findById(1)
   │
   ▼
2. 检查一级缓存
   │
   ├─→ 命中 ──→ 直接返回缓存数据 ✓
   │
   └─→ 未命中
       │
       ▼
3. 查询数据库
   │
   ▼
4. 将结果存入一级缓存
   │
   ▼
5. 返回数据
```

**代码示例**：
```java
@Transactional
public void demonstrateFirstLevelCache() {
    // 第一次查询 - 访问数据库
    User user1 = entityManager.find(User.class, 1L);
    System.out.println("第一次查询");
    
    // 第二次查询 - 命中一级缓存，不访问数据库
    User user2 = entityManager.find(User.class, 1L);
    System.out.println("第二次查询");
    
    // user1 和 user2 是同一个对象
    System.out.println(user1 == user2); // true
}

// 控制台输出：
// Hibernate: select ... from user where id=?  ← 只有一次SQL
// 第一次查询
// 第二次查询
// true
```

### 2.3 一级缓存的管理


**手动控制缓存**：

```java
// 清空一级缓存
entityManager.clear();

// 刷新缓存到数据库
entityManager.flush();

// 分离实体（从缓存移除）
entityManager.detach(user);

// 刷新实体（从数据库重新加载）
entityManager.refresh(user);
```

**常见使用场景**：
```java
// 场景1：批量操作时清空缓存避免内存溢出
for (int i = 0; i < 10000; i++) {
    User user = new User("user" + i);
    entityManager.persist(user);
    
    if (i % 50 == 0) {
        entityManager.flush();  // 同步到数据库
        entityManager.clear();  // 清空缓存
    }
}

// 场景2：确保读取最新数据
User user = entityManager.find(User.class, 1L);
// ... 其他操作可能修改了数据库
entityManager.refresh(user);  // 重新从数据库加载
```

### 2.4 一级缓存的优缺点


**优势** ✅：
- 完全自动，无需配置
- 保证事务内数据一致性
- 减少同一事务内的重复查询

**限制** ⚠️：
- 只在单个事务内有效
- 事务结束后失效
- 无法跨事务共享数据

---

## 3. 🌐 二级缓存详解


### 3.1 二级缓存是什么


> 📖 **核心概念**：二级缓存是应用级别的缓存，可以在不同事务、不同Session之间共享数据

**一级vs二级缓存对比**：

```
一级缓存（事务级）         二级缓存（应用级）
┌─────────────┐           ┌─────────────┐
│  事务A      │           │   全局共享   │
│  Session A  │           │   所有事务   │
└─────────────┘           │   都可访问   │
                          └─────────────┘
┌─────────────┐                 ▲
│  事务B      │                 │
│  Session B  │─────────────────┘
└─────────────┘           可以共享数据
```

**关键特点**：
- 🌍 **全局共享** - 跨Session、跨事务
- ⚙️ **需要配置** - 默认不开启
- 💾 **持久化选项** - 可以存储到磁盘
- 🔄 **生命周期长** - 应用运行期间一直存在

### 3.2 二级缓存配置


**Maven依赖（以Ehcache为例）**：
```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jcache</artifactId>
</dependency>
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
</dependency>
```

**application.yml配置**：
```yaml
spring:
  jpa:
    properties:
      hibernate:
        # 开启二级缓存
        cache.use_second_level_cache: true
        # 指定缓存提供商
        cache.region.factory_class: jcache
        # 缓存配置文件
        javax.cache.provider: org.ehcache.jsr107.EhcacheCachingProvider
        javax.cache.uri: classpath:ehcache.xml
```

**实体类配置**：
```java
@Entity
@Cacheable  // 开启缓存
@org.hibernate.annotations.Cache(
    usage = CacheConcurrencyStrategy.READ_WRITE  // 并发策略
)
public class User {
    @Id
    private Long id;
    private String name;
    
    // 集合也可以缓存
    @OneToMany
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private List<Order> orders;
}
```

### 3.3 二级缓存工作流程


```
请求查询 User(id=1)
        │
        ▼
检查一级缓存（当前事务）
        │
   ┌────┴────┐
   │ 命中？   │
   └────┬────┘
        │ 否
        ▼
检查二级缓存（全局）
        │
   ┌────┴────┐
   │ 命中？   │
   └────┬────┘
        │ 否
        ▼
   查询数据库
        │
        ▼
  存入二级缓存 ──→ 存入一级缓存
        │              │
        └──────────────┘
                │
                ▼
            返回数据
```

**实际效果示例**：
```java
// 事务1
@Transactional
public void transaction1() {
    User user = userRepository.findById(1L);  // 查数据库，存入二级缓存
}

// 事务2（新的Session）
@Transactional
public void transaction2() {
    User user = userRepository.findById(1L);  // 直接从二级缓存获取
    // 不会查询数据库！
}
```

### 3.4 缓存区域配置


**ehcache.xml配置示例**：
```xml
<config>
    <!-- 默认缓存配置 -->
    <cache alias="default">
        <expiry>
            <ttl unit="minutes">10</ttl>  <!-- 10分钟过期 -->
        </expiry>
        <heap unit="entries">1000</heap>  <!-- 最多1000个对象 -->
    </cache>
    
    <!-- User实体专用缓存 -->
    <cache alias="com.example.entity.User">
        <expiry>
            <ttl unit="hours">1</ttl>  <!-- 1小时过期 -->
        </expiry>
        <heap unit="entries">5000</heap>
    </cache>
    
    <!-- 集合缓存 -->
    <cache alias="com.example.entity.User.orders">
        <expiry>
            <ttl unit="minutes">30</ttl>
        </expiry>
        <heap unit="entries">10000</heap>
    </cache>
</config>
```

---

## 4. 🔍 查询缓存机制


### 4.1 查询缓存是什么


> 💡 **通俗理解**：查询缓存存储的不是对象本身，而是查询结果的ID列表

**实体缓存vs查询缓存**：
```
实体缓存（二级缓存）：
存储内容: User对象 {id=1, name="张三", age=25}
缓存键: User#1

查询缓存：
存储内容: [1, 2, 3, 4, 5]  ← 只存ID列表
缓存键: SELECT u FROM User u WHERE u.age > 20
```

**查询缓存的工作方式**：
```
执行: SELECT * FROM user WHERE age > 20
              │
              ▼
1. 检查查询缓存
   │
   ├─ 命中 → 获取ID列表 [1,2,3]
   │              │
   │              ▼
   │         从二级缓存获取User(1), User(2), User(3)
   │
   └─ 未命中 → 执行SQL查询
                │
                ▼
              存储ID列表到查询缓存
```

### 4.2 查询缓存配置


**开启查询缓存**：
```yaml
spring:
  jpa:
    properties:
      hibernate:
        cache.use_query_cache: true  # 开启查询缓存
```

**代码中使用**：
```java
// JPQL查询
List<User> users = entityManager
    .createQuery("SELECT u FROM User u WHERE u.age > :age", User.class)
    .setParameter("age", 20)
    .setHint("org.hibernate.cacheable", true)  // 启用查询缓存
    .getResultList();

// Spring Data JPA
@QueryHints(@QueryHint(
    name = "org.hibernate.cacheable", 
    value = "true"
))
@Query("SELECT u FROM User u WHERE u.age > :age")
List<User> findByAgeGreaterThan(@Param("age") int age);
```

### 4.3 查询缓存的限制


> ⚠️ **重要提醒**：查询缓存非常敏感，表数据任何变化都会导致缓存失效

**失效场景**：
```java
// 缓存了查询结果
List<User> users = queryWithCache("age > 20");  // 缓存命中

// 任何对User表的修改都会使查询缓存失效
userRepository.save(new User());  // 插入
userRepository.delete(user);       // 删除  
user.setAge(30);                   // 更新

// 再次查询会重新执行SQL
users = queryWithCache("age > 20");  // 缓存已失效
```

**适用场景**：
- ✅ 读多写少的数据
- ✅ 相对静态的配置数据
- ❌ 频繁更新的数据
- ❌ 实时性要求高的数据

---

## 5. 🔐 缓存并发策略


### 5.1 并发策略概述


> 📖 **核心概念**：并发策略决定了多个事务同时访问缓存数据时的行为方式

**四种并发策略对比**：

| 策略 | 适用场景 | 性能 | 数据一致性 |
|------|---------|------|-----------|
| `READ_ONLY` | 只读数据 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| `NONSTRICT_READ_WRITE` | 偶尔更新 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| `READ_WRITE` | 经常读写 | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| `TRANSACTIONAL` | 严格一致性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |

### 5.2 READ_ONLY策略


**适用场景**：数据永远不会被修改

```java
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
public class Country {  // 国家数据不会改变
    @Id
    private String code;
    private String name;
}
```

**特点**：
- 🚀 **性能最高** - 不需要任何锁机制
- ⚠️ **限制** - 尝试修改会抛出异常
- ✅ **最佳实践** - 用于参考数据、配置数据

### 5.3 READ_WRITE策略


**适用场景**：读写都很频繁的数据

```java
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Product {  // 商品信息会经常更新
    @Id
    private Long id;
    private String name;
    private BigDecimal price;
}
```

**工作原理**：
```
事务A读取          事务B更新
   │                 │
   ▼                 ▼
获取读锁          等待获取写锁
   │                 │
   ▼                 ▼
读取数据          等待...
   │                 │
   ▼                 ▼
释放读锁    ──→   获取写锁
                    │
                    ▼
                 更新缓存
                    │
                    ▼
                 释放写锁
```

**特点**：
- 🔒 **使用锁机制** - 保证数据一致性
- ⚖️ **性能适中** - 有一定开销
- ✅ **最常用** - 适合大多数场景

### 5.4 NONSTRICT_READ_WRITE策略


**适用场景**：偶尔更新，可以容忍短暂不一致

```java
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Article {  // 文章偶尔更新
    @Id
    private Long id;
    private String title;
    private String content;
}
```

**特点**：
- ⚡ **性能较高** - 没有严格的锁
- ⚠️ **可能读到旧数据** - 短暂延迟
- 💡 **适合场景** - 浏览量、点赞数等

### 5.5 TRANSACTIONAL策略


**适用场景**：需要完全事务支持

```java
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL)
public class BankAccount {  // 银行账户需要严格一致性
    @Id
    private Long id;
    private BigDecimal balance;
}
```

**特点**：
- 🔐 **完全事务化** - 支持回滚
- 📉 **性能最低** - 开销最大
- ⚙️ **需要JTA** - 需要分布式事务支持

---

## 6. ♻️ 缓存失效与更新


### 6.1 缓存失效策略


**三种主要失效方式**：

```
时间失效（TTL）          空间失效（LRU）        手动失效
      │                      │                    │
      ▼                      ▼                    ▼
  设置过期时间            缓存满时淘汰          主动清除缓存
  10分钟后失效            最少使用的数据        程序控制失效
```

**Ehcache配置示例**：
```xml
<cache alias="com.example.User">
    <!-- 时间失效 -->
    <expiry>
        <ttl unit="minutes">30</ttl>  <!-- 30分钟后失效 -->
    </expiry>
    
    <!-- 空间限制 -->
    <heap unit="entries">1000</heap>   <!-- 最多1000个 -->
    
    <!-- 淘汰策略：LRU最少使用 -->
    <eviction-advisor>
        <class>org.ehcache.config.builders.LRUEvictionPrioritizer</class>
    </eviction-advisor>
</cache>
```

### 6.2 缓存更新策略


**常见更新模式**：

┌─ Cache-Aside（旁路缓存）─────────┐
│                                  │
│  读取：先查缓存 → 未命中查DB → 写入缓存  │
│  更新：先更新DB → 删除缓存            │
│                                  │
│  优点：简单可靠                     │
│  缺点：可能有短暂不一致               │
└──────────────────────────────────┘

**代码实现**：
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private CacheManager cacheManager;
    
    // 读取
    public User getUser(Long id) {
        Cache cache = cacheManager.getCache("users");
        User user = cache.get(id, User.class);
        
        if (user == null) {
            user = userRepository.findById(id).orElse(null);
            if (user != null) {
                cache.put(id, user);  // 写入缓存
            }
        }
        return user;
    }
    
    // 更新
    @Transactional
    public void updateUser(User user) {
        userRepository.save(user);  // 更新数据库
        
        Cache cache = cacheManager.getCache("users");
        cache.evict(user.getId());  // 删除缓存
    }
}
```

### 6.3 批量失效处理


```java
// 清空某个缓存区域
@Autowired
private SessionFactory sessionFactory;

public void clearUserCache() {
    Cache cache = sessionFactory.getCache();
    cache.evictEntityData(User.class);  // 清空User缓存
}

// 清空所有二级缓存
public void clearAllCache() {
    Cache cache = sessionFactory.getCache();
    cache.evictAllRegions();
}

// 清空查询缓存
public void clearQueryCache() {
    Cache cache = sessionFactory.getCache();
    cache.evictQueryRegions();
}
```

---

## 7. 📈 性能监控与调优


### 7.1 缓存命中率监控


**关键指标**：
```
命中率 = 缓存命中次数 / 总访问次数

优秀：> 80%
良好：60% - 80%
一般：40% - 60%
较差：< 40%
```

**Hibernate统计配置**：
```yaml
spring:
  jpa:
    properties:
      hibernate:
        generate_statistics: true  # 开启统计
```

**获取统计信息**：
```java
@Service
public class CacheMonitor {
    
    @Autowired
    private EntityManagerFactory emf;
    
    public void printCacheStatistics() {
        SessionFactory sf = emf.unwrap(SessionFactory.class);
        Statistics stats = sf.getStatistics();
        
        // 二级缓存统计
        System.out.println("=== 二级缓存统计 ===");
        System.out.println("缓存命中次数: " + stats.getSecondLevelCacheHitCount());
        System.out.println("缓存未命中次数: " + stats.getSecondLevelCacheMissCount());
        System.out.println("缓存存入次数: " + stats.getSecondLevelCachePutCount());
        
        // 命中率
        long hits = stats.getSecondLevelCacheHitCount();
        long misses = stats.getSecondLevelCacheMissCount();
        double hitRate = (double) hits / (hits + misses) * 100;
        System.out.println("命中率: " + hitRate + "%");
        
        // 查询缓存统计
        System.out.println("\n=== 查询缓存统计 ===");
        System.out.println("查询缓存命中: " + stats.getQueryCacheHitCount());
        System.out.println("查询缓存未命中: " + stats.getQueryCacheMissCount());
    }
}
```

### 7.2 性能调优建议


**调优检查清单**：

✅ **配置优化**
```yaml
# 合理的缓存大小
hibernate:
  cache:
    # 不要设置过大，避免内存溢出
    ehcache.max_entries: 10000
    
    # 合理的过期时间
    ttl_seconds: 600  # 10分钟
```

✅ **选择性缓存**
```java
// 只缓存热点数据
@Cacheable  // ✓ 用户信息
public class User {}

// 不缓存大对象
// @Cacheable  ✗ 文件内容
public class FileContent {}
```

✅ **监控告警**
```java
// 定期检查缓存命中率
@Scheduled(fixedRate = 300000)  // 每5分钟
public void monitorCache() {
    double hitRate = calculateHitRate();
    if (hitRate < 40) {
        logger.warn("缓存命中率过低: {}%", hitRate);
        // 发送告警
    }
}
```

### 7.3 常见性能问题


**问题1：缓存穿透**
```
大量查询不存在的数据 → 缓存无效 → 直接打到数据库

解决方案：
// 缓存空值
public User getUser(Long id) {
    User user = cache.get(id);
    if (user == null) {
        user = db.find(id);
        if (user == null) {
            cache.put(id, EMPTY_USER);  // 缓存空对象
        }
    }
    return user == EMPTY_USER ? null : user;
}
```

**问题2：缓存雪崩**
```
大量缓存同时失效 → 瞬间大量请求打到数据库

解决方案：
// 随机过期时间
<expiry>
    <ttl unit="seconds">
        ${random.int(300,600)}  <!-- 5-10分钟随机 -->
    </ttl>
</expiry>
```

---

## 8. 🔌 实际集成方案


### 8.1 Ehcache集成（本地缓存）


**完整配置示例**：

`pom.xml`：
```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jcache</artifactId>
</dependency>
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>3.10.8</version>
</dependency>
```

`application.yml`：
```yaml
spring:
  jpa:
    properties:
      hibernate:
        cache:
          use_second_level_cache: true
          region.factory_class: jcache
        javax:
          cache:
            provider: org.ehcache.jsr107.EhcacheCachingProvider
            uri: classpath:ehcache.xml
```

`ehcache.xml`：
```xml
<config>
    <cache alias="com.example.entity.User">
        <expiry>
            <ttl unit="hours">1</ttl>
        </expiry>
        <heap unit="entries">5000</heap>
    </cache>
</config>
```

### 8.2 Redis集成（分布式缓存）


> 💡 **使用场景**：多个应用实例需要共享缓存时

**依赖配置**：
```xml
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-jcache</artifactId>
</dependency>
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-hibernate-6</artifactId>
    <version>3.24.3</version>
</dependency>
```

**application.yml**：
```yaml
spring:
  jpa:
    properties:
      hibernate:
        cache:
          use_second_level_cache: true
          region.factory_class: org.redisson.hibernate.RedissonRegionFactory
          redisson.config: classpath:redisson.yaml

# Redis配置
redisson:
  singleServerConfig:
    address: "redis://localhost:6379"
    password: null
```

**优缺点对比**：

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **Ehcache** | 简单快速、无需外部依赖 | 无法跨应用共享 | 单机应用 |
| **Redis** | 分布式共享、持久化 | 需要维护Redis | 集群环境 |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 一级缓存：事务级别，自动开启，事务结束即失效
🔸 二级缓存：应用级别，需配置，跨事务共享数据
🔸 查询缓存：存储查询结果ID列表，配合二级缓存使用
🔸 并发策略：READ_ONLY/READ_WRITE/NONSTRICT/TRANSACTIONAL
🔸 失效策略：时间失效、空间限制、手动清除
🔸 监控指标：缓存命中率是最关键的性能指标
```

### 9.2 缓存使用决策树


```
需要使用缓存吗？
        │
   ┌────┴────┐
   │  是/否？ │
   └────┬────┘
        │
   ┌────▼──────────────┐
   │ 读多写少？          │
   │ 数据量大？          │
   │ 查询频繁？          │ ──是──→ 使用缓存
   └────┬──────────────┘
        │ 否
        ▼
    不使用缓存

使用哪种缓存？
        │
   ┌────▼────────────────┐
   │ 单机 → Ehcache      │
   │ 集群 → Redis        │
   │ 分布式 → Hazelcast   │
   └─────────────────────┘

选择并发策略？
        │
   ┌────▼─────────────────┐
   │ 只读 → READ_ONLY     │
   │ 常读写 → READ_WRITE   │
   │ 偶尔写 → NONSTRICT    │
   │ 事务性 → TRANSACTIONAL│
   └──────────────────────┘
```

### 9.3 最佳实践建议


> ✅ **推荐做法**

- 优先使用一级缓存（自动、免费）
- 二级缓存只用于热点数据
- 查询缓存谨慎使用（易失效）
- 定期监控缓存命中率
- 设置合理的过期时间
- 避免缓存大对象

> ⚠️ **注意事项**

- 不要缓存所有实体（浪费内存）
- 注意缓存一致性问题
- 警惕缓存雪崩和穿透
- 及时清理过期缓存
- 考虑缓存预热

### 9.4 快速记忆口诀


```
一级缓存事务内，二级缓存跨事务；
查询缓存存ID列，三级缓存互配合。

只读数据READ_ONLY，读写频繁READ_WRITE；
偶尔更新NONSTRICT，严格一致TRANSACTIONAL。

命中率高性能好，定期监控很重要；
热点数据才缓存，大对象类要避免。
```

---

**学习建议** 💡：
1. 先掌握一级缓存（基础）
2. 再学习二级缓存（进阶）
3. 最后了解查询缓存（优化）
4. 通过实际项目练习监控和调优