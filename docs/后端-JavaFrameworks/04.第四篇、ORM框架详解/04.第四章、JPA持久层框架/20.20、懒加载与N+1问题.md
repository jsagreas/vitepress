---
title: 20、懒加载与N+1问题
---
## 📚 目录

1. [懒加载基础概念](#1-懒加载基础概念)
2. [抓取策略详解](#2-抓取策略详解)
3. [代理对象原理](#3-代理对象原理)
4. [N+1查询问题](#4-N+1查询问题)
5. [解决方案与最佳实践](#5-解决方案与最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 懒加载基础概念


### 1.1 什么是懒加载


**通俗理解**：就像网购时"先下单，需要时再发货"

```
现实类比：
图书馆借书：
  饥饿加载 → 一次性把所有相关书籍都搬回家（可能用不到）
  懒加载   → 只借主要的书，需要参考资料时再去图书馆拿

数据库查询：
  饥饿加载 → 查用户时，把用户的所有订单也一起查出来
  懒加载   → 先只查用户信息，真正需要订单时再去数据库查
```

**核心定义**：
- **懒加载（Lazy Loading）**：关联数据**不会立即**从数据库加载，而是在**第一次访问**时才加载
- **饥饿加载（Eager Loading）**：关联数据会**立即**从数据库加载，不管你用不用

**为什么需要懒加载？**
```
假设场景：
用户表(User) 关联 订单表(Order)
一个用户可能有成百上千个订单

❌ 不用懒加载的问题：
   - 每次查用户，都把所有订单查出来
   - 可能只需要用户名，却加载了1000个订单
   - 浪费内存、浪费数据库资源

✅ 使用懒加载的好处：
   - 先只查用户基本信息（快速！）
   - 真正需要订单时再查（按需加载）
   - 节省资源，提高性能
```

### 1.2 懒加载的工作机制


**简单理解**：
```
第1步：查询主对象
  User user = userRepository.findById(1);
  → 只查用户表：SELECT * FROM user WHERE id=1
  → 此时订单数据还在数据库里，没加载

第2步：访问关联对象（触发懒加载）
  List<Order> orders = user.getOrders();
  → 现在才查订单：SELECT * FROM orders WHERE user_id=1
  → 数据按需加载

关键：第2步不调用，第2次查询就不会发生！
```

**执行流程图示**：
```
客户端代码              JPA/Hibernate           数据库
    |                      |                      |
    |--findById(1)-------->|                      |
    |                      |--查用户------------->|
    |                      |<--返回用户数据-------|
    |<--返回User对象-------|                      |
    |                      |                      |
    |--getOrders()-------->|                      |
    |  (触发懒加载)        |--查订单------------->|
    |                      |<--返回订单数据-------|
    |<--返回订单列表-------|                      |
```

---

## 2. ⚙️ 抓取策略详解


### 2.1 两种抓取类型对比


**FetchType.LAZY 懒加载** `🐢 慢但省资源`

**含义**：关联数据**延迟加载**，用到时才查

```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    // 🐢 LAZY：订单数据不会立即查询
    @OneToMany(fetch = FetchType.LAZY)
    private List<Order> orders;
}
```

**特点说明**：
- ✅ **性能好**：初次查询快，只查主表
- ✅ **省内存**：不加载用不到的数据
- ⚠️ **可能N+1**：访问关联数据时会触发额外查询
- ⚠️ **Session依赖**：需要数据库连接还活着才能懒加载

---

**FetchType.EAGER 饥饿加载** `🏃 快但费资源`

**含义**：关联数据**立即加载**，不管用不用

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    // 🏃 EAGER：查订单时立即查用户
    @ManyToOne(fetch = FetchType.EAGER)
    private User user;
}
```

**特点说明**：
- ✅ **使用方便**：数据提前准备好，随时可用
- ✅ **无Session限制**：关联数据已加载，不需要连接
- ⚠️ **性能差**：可能加载大量不需要的数据
- ⚠️ **内存浪费**：全部数据都在内存里

### 2.2 默认抓取策略


| 关联类型 | 默认策略 | 原因说明 |
|---------|---------|---------|
| `@OneToOne` | **EAGER** | 一对一关系，数据量小，通常都需要 |
| `@ManyToOne` | **EAGER** | 多对一关系，"一"的那端通常需要显示 |
| `@OneToMany` | **LAZY** | 一对多关系，"多"的那端可能很多数据 |
| `@ManyToMany` | **LAZY** | 多对多关系，关联数据可能非常多 |

**记忆技巧**：
```
规律：xxxToOne → EAGER（因为"一"的数据少）
     xxxToMany → LAZY（因为"多"的数据可能很多）

现实理解：
  查订单显示用户名 → 用户信息肯定要（EAGER合理）
  查用户显示所有订单 → 订单可能上千条（LAZY合理）
```

### 2.3 如何选择抓取策略


**选择决策树**：
```
需要加载关联数据吗？
  ├─ 是 → 90%以上场景都需要？
  │       ├─ 是 → 关联数据量大吗？
  │       │      ├─ 否 → 用 EAGER ✓
  │       │      └─ 是 → 用 LAZY + fetch join ✓
  │       └─ 否 → 用 LAZY ✓
  └─ 否 → 用 LAZY ✓

结论：默认用LAZY，确实需要立即加载再改EAGER
```

**实际应用建议**：

🎯 **推荐做法**：
```java
// ① 默认全部用LAZY（保守策略）
@OneToMany(fetch = FetchType.LAZY)
private List<Order> orders;

// ② 真正需要立即加载的地方，用查询指定
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
User findByIdWithOrders(@Param("id") Long id);
```

❌ **避免做法**：
```java
// 不要全局EAGER，容易出性能问题
@OneToMany(fetch = FetchType.EAGER) // 危险！
private List<Order> orders;
```

---

## 3. 🔧 代理对象原理


### 3.1 什么是代理对象


**通俗理解**：代理对象就像"占位符"或"提货券"

```
现实类比：
  真实对象  = 真正的商品
  代理对象  = 提货券（凭券提货）

数据库场景：
  真实对象  = 从数据库查出来的完整数据
  代理对象  = 一个"假"对象，访问时才去数据库查真数据
```

**代理对象的本质**：
```
User user = userRepository.findById(1);
List<Order> orders = user.getOrders(); // ← 这里不是真的List

实际上返回的是：
  PersistentBag（Hibernate的代理类）
  └─ 内部记录：user_id=1，订单数据还没查
  └─ 当你真正遍历时，才触发SQL查询
```

### 3.2 代理对象工作流程


**执行过程图解**：
```
步骤1：查询User对象
  User user = userRepository.findById(1);
  
  内存状态：
  ┌─────────────────┐
  │  User对象       │
  │  id: 1          │
  │  name: "张三"   │
  │  orders: [代理]  │ ← 这是代理对象，不是真数据
  └─────────────────┘

步骤2：访问orders（触发懒加载）
  List<Order> orders = user.getOrders();
  
  代理对象检测：
  ┌──────────────┐
  │ 代理对象判断  │
  │ 数据加载了吗？│
  │   └─ 没有！   │
  │   └─ 去数据库查│
  └──────────────┘
         ↓
  执行SQL：SELECT * FROM orders WHERE user_id=1
         ↓
  ┌─────────────────┐
  │  真实订单列表    │
  │  [Order1, Order2]│
  └─────────────────┘
```

### 3.3 代理对象的常见问题


**问题1：LazyInitializationException** `❌ 最常见错误`

**产生原因**：数据库连接已关闭，无法懒加载

```java
// ❌ 错误示例
@Transactional
public User getUser(Long id) {
    return userRepository.findById(id).orElse(null);
} // ← 方法结束，事务关闭，数据库连接断开

// 在Controller里访问
User user = userService.getUser(1);
user.getOrders(); // ← 💥 LazyInitializationException！
// 原因：事务已关闭，无法再查数据库
```

**正确做法**：
```java
// ✅ 方案1：在事务内访问
@Transactional
public void processUser(Long id) {
    User user = userRepository.findById(id).orElse(null);
    user.getOrders(); // ✓ 事务还在，可以懒加载
}

// ✅ 方案2：使用fetch join
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
User findByIdWithOrders(@Param("id") Long id);
```

---

**问题2：代理对象序列化问题**

```java
// ❌ 直接返回代理对象给前端
@GetMapping("/user/{id}")
public User getUser(@PathVariable Long id) {
    return userRepository.findById(id).orElse(null);
    // orders是代理对象，JSON序列化可能出错
}

// ✅ 使用DTO转换
@GetMapping("/user/{id}")
public UserDTO getUser(@PathVariable Long id) {
    User user = userRepository.findById(id).orElse(null);
    return new UserDTO(user); // DTO只包含需要的字段
}
```

---

## 4. 🐛 N+1查询问题


### 4.1 什么是N+1问题


**问题症状**：查1次主表，又查N次关联表（N是主表记录数）

**通俗理解**：
```
场景：显示10个用户及其订单数量

❌ N+1问题的执行过程：
  第1次：SELECT * FROM user              (查出10个用户)
  第2次：SELECT * FROM orders WHERE user_id=1
  第3次：SELECT * FROM orders WHERE user_id=2
  ...
  第11次：SELECT * FROM orders WHERE user_id=10
  
  总共：1 + 10 = 11次查询（性能灾难！）

✅ 理想情况（1次查询）：
  SELECT u.*, o.* FROM user u 
  LEFT JOIN orders o ON u.id = o.user_id
  
  总共：1次查询（性能优秀！）
```

**现实类比**：
```
N+1问题：
  去超市买10样东西，每次只拿1样，跑10趟收银台

理想做法：
  一次性拿齐10样东西，只跑1趟收银台

哪个效率高？显而易见！
```

### 4.2 N+1问题的产生原因


**代码示例**：
```java
// 假设数据库有3个用户
List<User> users = userRepository.findAll(); // 第1次SQL

for (User user : users) {
    int orderCount = user.getOrders().size(); // 触发懒加载
    System.out.println(user.getName() + "的订单数：" + orderCount);
}

执行的SQL：
  1. SELECT * FROM user                    -- 查所有用户
  2. SELECT * FROM orders WHERE user_id=1  -- 用户1的订单
  3. SELECT * FROM orders WHERE user_id=2  -- 用户2的订单
  4. SELECT * FROM orders WHERE user_id=3  -- 用户3的订单
  
  → 1 + N次查询（N=用户数量）
```

**SQL日志示例**：
```
Hibernate: select * from user
Hibernate: select * from orders where user_id=?
Hibernate: select * from orders where user_id=?
Hibernate: select * from orders where user_id=?
...

🚨 看到这种重复查询，就是N+1问题！
```

### 4.3 如何定位N+1问题


**方法1：开启SQL日志** `🔍 最直接`

```yaml
# application.yml
spring:
  jpa:
    show-sql: true  # 显示SQL
    properties:
      hibernate:
        format_sql: true  # 格式化SQL
```

**看到的现象**：
```sql
-- 正常查询（1次）
SELECT * FROM user;

-- N+1问题特征（重复查询）
SELECT * FROM orders WHERE user_id=?;
SELECT * FROM orders WHERE user_id=?;
SELECT * FROM orders WHERE user_id=?;
... (重复N次)
```

---

**方法2：使用性能分析工具** `📊 更专业`

```xml
<!-- pom.xml 添加 -->
<dependency>
    <groupId>com.github.gavlyukovskiy</groupId>
    <artifactId>p6spy-spring-boot-starter</artifactId>
    <version>1.8.1</version>
</dependency>
```

**输出信息**：
```
执行时间：3ms, 影响行数：10
SELECT * FROM user;

执行时间：2ms, 影响行数：5
SELECT * FROM orders WHERE user_id=?;
... (重复10次) ← 🚨 N+1警告！

总耗时：23ms, 总查询：11次 ← 性能统计
```

---

**方法3：代码审查检查点** `👀 预防为主`

```java
// 🚨 危险信号：循环中访问懒加载属性
for (User user : users) {
    user.getOrders().size(); // ← 每次都查数据库！
}

// 🚨 危险信号：没有join fetch的懒加载
@Query("SELECT u FROM user u") // ← 没写JOIN FETCH
List<User> findAll();
```

---

## 5. 💡 解决方案与最佳实践


### 5.1 解决方案1：JOIN FETCH


**核心理解**：一次性把主表和关联表的数据都查出来

**语法示例**：
```java
// ✅ 使用JOIN FETCH（推荐）
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();

// 执行的SQL（只有1次查询）：
// SELECT u.*, o.* FROM user u 
// LEFT JOIN orders o ON u.id = o.user_id
```

**FETCH的含义**：
```
不加FETCH：
  SELECT u FROM User u JOIN u.orders
  → JOIN只是条件，不加载orders数据

加FETCH：
  SELECT u FROM User u JOIN FETCH u.orders
  → JOIN + 加载orders数据到内存
```

**使用场景**：
```java
// 场景1：列表页需要显示关联信息
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllForList();

// 场景2：详情页需要完整数据
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
User findDetailById(@Param("id") Long id);
```

**⚠️ JOIN FETCH注意事项**：
```java
// ❌ 不能同时fetch多个集合（会产生笛卡尔积）
@Query("SELECT u FROM User u " +
       "JOIN FETCH u.orders " +     // 集合1
       "JOIN FETCH u.addresses")    // 集合2 ← 错误！

// ✅ 分次查询或用@EntityGraph
```

---

### 5.2 解决方案2：@EntityGraph


**核心理解**：注解方式指定加载哪些关联

**基础用法**：
```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // ✅ 指定加载orders属性
    @EntityGraph(attributePaths = {"orders"})
    List<User> findAll();
    
    // 等价于：
    // @Query("SELECT u FROM User u JOIN FETCH u.orders")
}
```

**多级关联**：
```java
// 加载 用户 → 订单 → 订单项
@EntityGraph(attributePaths = {"orders", "orders.items"})
List<User> findAll();
```

**动态EntityGraph**：
```java
@Entity
@NamedEntityGraph(
    name = "User.orders",
    attributeNodes = @NamedAttributeNode("orders")
)
public class User {
    // ...
}

// 使用时
@EntityGraph("User.orders")
List<User> findAll();
```

**对比JOIN FETCH**：

| 特性 | JOIN FETCH | @EntityGraph |
|------|------------|--------------|
| **灵活性** | 需要写JPQL | 注解即可，简单 |
| **可读性** | 查询语句清晰 | 声明式，简洁 |
| **复杂查询** | 支持复杂条件 | 功能有限 |
| **推荐场景** | 复杂查询 | 简单关联加载 |

---

### 5.3 解决方案3：批量加载策略


**核心理解**：把N次查询合并成1次

**Hibernate配置**：
```yaml
# application.yml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 10  # 批量大小
```

**工作原理**：
```java
// 假设查询10个用户
List<User> users = userRepository.findAll();

// 不开启批量加载：
for (User user : users) {
    user.getOrders().size(); // 10次查询
}

// 开启批量加载后：
// SELECT * FROM orders WHERE user_id IN (1,2,3,4,5,6,7,8,9,10)
// 只查1次！
```

**批量大小选择**：
```
batch_size = 10：
  - 100个用户 → 10次查询（100/10）
  
batch_size = 50：
  - 100个用户 → 2次查询（100/50）
  
batch_size = 1000：
  - 100个用户 → 1次查询

建议：10-50之间，根据实际数据量调整
```

---

### 5.4 解决方案4：DTO投影


**核心理解**：只查需要的字段，不查关联对象

**示例代码**：
```java
// DTO类
public class UserOrderCountDTO {
    private Long userId;
    private String userName;
    private Long orderCount;
    
    // 构造函数
    public UserOrderCountDTO(Long userId, String userName, Long orderCount) {
        this.userId = userId;
        this.userName = userName;
        this.orderCount = orderCount;
    }
}

// Repository
@Query("SELECT new com.example.dto.UserOrderCountDTO(" +
       "u.id, u.name, COUNT(o)) " +
       "FROM User u LEFT JOIN u.orders o " +
       "GROUP BY u.id, u.name")
List<UserOrderCountDTO> findUserOrderCounts();

// 执行的SQL（1次查询，性能最优）：
// SELECT u.id, u.name, COUNT(o.id) 
// FROM user u LEFT JOIN orders o ON u.id = o.user_id
// GROUP BY u.id, u.name
```

**优势**：
- ✅ **性能最优**：只查需要的字段
- ✅ **避免懒加载**：不涉及实体关联
- ✅ **防止过度获取**：按需查询

---

### 5.5 最佳实践总结


**推荐方案选择流程**：
```
需求分析
  ├─ 只需要统计/聚合数据？
  │   └─ 用 DTO投影 ✓（性能最优）
  │
  ├─ 需要完整对象？
  │   ├─ 关联数据简单？
  │   │   └─ 用 @EntityGraph ✓（简单方便）
  │   │
  │   └─ 关联数据复杂？
  │       └─ 用 JOIN FETCH ✓（功能强大）
  │
  └─ 无法改查询？
      └─ 配置批量加载 ✓（降低影响）
```

**实战组合技**：
```java
// ① 列表查询：DTO投影
@Query("SELECT new UserDTO(u.id, u.name, COUNT(o)) " +
       "FROM User u LEFT JOIN u.orders o GROUP BY u.id")
List<UserDTO> findUserList();

// ② 详情查询：JOIN FETCH
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
User findUserDetail(@Param("id") Long id);

// ③ 导出功能：批量加载
@Query("SELECT u FROM User u")
@QueryHints(@QueryHint(name = "hibernate.default_batch_fetch_size", value = "50"))
List<User> findAllForExport();
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的基本概念


```
🔸 懒加载（LAZY）：用到才查，省资源但可能多次查询
🔸 饥饿加载（EAGER）：立即查询，方便但可能浪费资源
🔸 代理对象：懒加载的实现机制，访问时才触发真实查询
🔸 N+1问题：1次主查询+N次关联查询，性能杀手
🔸 JOIN FETCH：一次查询解决N+1，最常用方案
```

### 6.2 关键理解要点


**🔹 抓取策略选择原则**
```
默认策略：
  xxxToOne  → EAGER（关联数据少）
  xxxToMany → LAZY（关联数据多）

实际使用：
  ✓ 优先用LAZY（按需加载，省资源）
  ✓ 确实需要立即加载，用查询指定（JOIN FETCH）
  ✗ 不要全局改EAGER（容易性能问题）
```

**🔹 N+1问题识别方法**
```
症状特征：
  1. SQL日志出现大量重复查询
  2. 循环中访问懒加载属性
  3. 查询慢，但单个SQL不慢

定位工具：
  - show-sql：看SQL执行
  - p6spy：统计查询次数
  - 代码审查：检查循环中的懒加载
```

**🔹 解决方案优先级**
```
优先级排序：
  1️⃣ DTO投影（只查需要的，性能最优）
  2️⃣ JOIN FETCH（简单场景，功能强大）
  3️⃣ @EntityGraph（声明式，代码简洁）
  4️⃣ 批量加载（无法改查询时的补救）

选择依据：
  - 简单查询 → @EntityGraph
  - 复杂查询 → JOIN FETCH
  - 统计聚合 → DTO投影
  - 历史代码 → 批量加载配置
```

### 6.3 实际应用价值


**性能对比**：
```
场景：查询100个用户的订单数量

❌ N+1问题：
   - 查询次数：101次（1+100）
   - 耗时：~500ms
   
✅ JOIN FETCH：
   - 查询次数：1次
   - 耗时：~50ms
   
✅ DTO投影：
   - 查询次数：1次
   - 耗时：~30ms（最优）
```

**记忆口诀**：
```
懒加载省资源，饥饿加载图方便
代理对象占位置，真用才查不浪费
N+1是性能坑，一次查询变百次
JOIN FETCH来救场，一网打尽效率高
DTO投影更精准，只拿需要性能好
```

**核心记住**：
- 默认用LAZY，避免浪费资源
- 警惕N+1，开启SQL日志监控
- 优先JOIN FETCH，解决大部分问题
- 学会DTO投影，追求极致性能