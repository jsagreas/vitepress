---
title: 34、 全局配置策略
---
## 📚 目录

1. [什么是全局配置](#1-什么是全局配置)
2. [GlobalConfig核心配置项](#2-globalconfig核心配置项)
3. [作者信息设置](#3-作者信息设置)
4. [文件覆盖策略](#4-文件覆盖策略)
5. [输出目录配置](#5-输出目录配置)
6. [日期格式设置](#6-日期格式设置)
7. [文件注释模板](#7-文件注释模板)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💡 什么是全局配置


### 1.1 全局配置的作用


**简单理解：**
```
全局配置就像是给代码生成器设定"统一规则"
- 规定生成的代码放在哪里
- 规定作者是谁
- 规定日期格式怎么写
- 规定文件能不能覆盖

就像你开一家工厂，全局配置就是这个工厂的"标准作业流程"
```

**为什么需要全局配置？**
```
场景1：团队协作
→ 统一的配置让所有人生成的代码风格一致

场景2：项目规范
→ 符合公司的代码标准和文档要求

场景3：提高效率
→ 一次配置，处处生效，不用每次都重复设置
```

### 1.2 全局配置的位置


**在代码生成器中的作用：**
```
代码生成器工作流程：
┌──────────────┐
│  数据库表    │
└──────┬───────┘
       ↓
┌──────────────┐
│  全局配置    │ ← 这里设置统一规则
└──────┬───────┘
       ↓
┌──────────────┐
│  生成代码    │ ← 按照全局配置生成
└──────────────┘
```

---

## 2. 🔧 GlobalConfig核心配置项


### 2.1 GlobalConfig是什么


**通俗理解：**
```
GlobalConfig = 全局配置类
就像一个"设置面板"，包含了所有生成代码的基础规则

类比：装修房子
→ GlobalConfig就是装修的"总体方案"
→ 包括风格、预算、工期等基础设定
```

### 2.2 核心配置项一览


| 配置项 | **作用** | **必填** | **默认值** |
|--------|----------|----------|------------|
| `outputDir` | 代码输出目录 | ✅ | 无 |
| `author` | 作者名称 | ❌ | 无 |
| `fileOverride` | 是否覆盖已有文件 | ❌ | false |
| `open` | 生成后是否打开目录 | ❌ | true |
| `dateType` | 日期类型 | ❌ | TIME_PACK |
| `commentDate` | 注释日期格式 | ❌ | yyyy-MM-dd |

### 2.3 基础配置示例


```java
// 创建全局配置对象
GlobalConfig globalConfig = new GlobalConfig();

// 设置基础信息
globalConfig.setOutputDir("D:/code/auto-generate")  // 代码输出位置
            .setAuthor("张三")                      // 设置作者
            .setFileOverride(true)                 // 允许覆盖文件
            .setOpen(false);                       // 生成后不打开目录
```

**配置解读：**
```
这段配置的意思是：
1. 把生成的代码放到 D盘/code/auto-generate 文件夹
2. 代码的作者标记为"张三"
3. 如果文件已存在，直接覆盖
4. 生成完成后不自动打开文件夹
```

---

## 3. 👤 作者信息设置


### 3.1 为什么要设置作者


**实际意义：**
```
代码规范：
→ 标记代码创建人，方便后续维护
→ 出问题时能快速找到负责人

版权管理：
→ 明确代码所有权
→ 符合公司知识产权管理要求

协作追溯：
→ 多人开发时区分不同人的代码
→ 代码审查时明确责任人
```

### 3.2 设置方式


**方法1：直接设置**
```java
globalConfig.setAuthor("李四");
```

**生成效果：**
```java
/**
 * 用户实体类
 * 
 * @author 李四
 * @since 2025-01-15
 */
public class User {
    // ...
}
```

**方法2：动态获取当前系统用户**
```java
// 自动使用当前登录的系统用户名
String systemUser = System.getProperty("user.name");
globalConfig.setAuthor(systemUser);
```

**使用场景对比：**
```
固定作者名：适合个人项目，作者不变
动态获取：适合团队项目，每个人生成时自动用自己的名字
```

### 3.3 作者信息的显示位置


```
作者信息会出现在：
┌─────────────────────┐
│  Entity实体类       │ ← @author 张三
├─────────────────────┤
│  Mapper接口         │ ← @author 张三
├─────────────────────┤
│  Service接口        │ ← @author 张三
├─────────────────────┤
│  Controller控制器   │ ← @author 张三
└─────────────────────┘
所有生成的类都会带上作者信息
```

---

## 4. 🔄 文件覆盖策略


### 4.1 覆盖策略的重要性


**核心问题：**
```
如果代码文件已经存在，再次生成时怎么办？
→ 直接覆盖原文件？
→ 保留原文件，生成失败？

就像保存Word文档：
已存在同名文件 → 选择"替换"还是"另存为"
```

**风险分析：**
```
覆盖风险：
❌ 可能丢失手动修改的代码
❌ 自定义的业务逻辑被清空

不覆盖问题：
❌ 无法更新代码到最新结构
❌ 数据库改了但代码没变
```

### 4.2 配置方式


**允许覆盖：**
```java
globalConfig.setFileOverride(true);  // 强制覆盖
```

**禁止覆盖：**
```java
globalConfig.setFileOverride(false);  // 保护原文件
```

### 4.3 实际使用建议


**📋 使用场景对比：**

| 场景 | **覆盖设置** | **原因** |
|------|------------|----------|
| 🆕 首次生成 | `true` | 没有旧文件，放心覆盖 |
| 🔧 数据库结构调整 | `true` | 需要同步最新结构 |
| 📝 已有业务代码 | `false` | 保护手写逻辑 |
| 🧪 测试阶段 | `true` | 反复调试配置 |
| 🚀 生产环境 | `false` | 严格保护已有代码 |

**💡 最佳实践：**
```
推荐做法：
1. 第一次生成：设置 true
2. 有修改后：设置 false，手动合并代码
3. 使用版本控制（Git）保护代码
4. 重要文件单独备份

安全策略：
→ 开发环境：可以设置 true
→ 生产环境：必须设置 false
→ 配合Git使用，随时可以回退
```

**代码示例：**
```java
// 开发阶段配置
if (开发环境) {
    globalConfig.setFileOverride(true);   // 允许覆盖
} else {
    globalConfig.setFileOverride(false);  // 生产保护
}
```

---

## 5. 📂 输出目录配置


### 5.1 什么是输出目录


**通俗理解：**
```
输出目录 = 生成的代码文件放在哪个文件夹

类比：
→ 你下载文件要选择保存位置
→ 代码生成器也要指定代码存放位置
```

### 5.2 配置方式


**方法1：绝对路径**
```java
// Windows系统
globalConfig.setOutputDir("D:/project/src/main/java");

// Mac/Linux系统  
globalConfig.setOutputDir("/Users/zhangsan/project/src/main/java");
```

**方法2：相对路径（推荐）**
```java
// 自动获取当前项目路径
String projectPath = System.getProperty("user.dir");
globalConfig.setOutputDir(projectPath + "/src/main/java");
```

### 5.3 路径结构示意


**生成后的目录结构：**
```
项目根目录/
├── src/
│   └── main/
│       └── java/          ← 这是outputDir设置的位置
│           └── com/
│               └── example/
│                   ├── entity/    ← 实体类
│                   ├── mapper/    ← Mapper接口
│                   ├── service/   ← Service接口
│                   └── controller/← Controller类
```

**💡 配置技巧：**
```java
// 获取当前项目路径的标准写法
String projectPath = System.getProperty("user.dir");

// 拼接标准的Java源码路径
String outputPath = projectPath + "/src/main/java";

globalConfig.setOutputDir(outputPath);
```

**为什么推荐相对路径？**
```
绝对路径问题：
→ 换电脑路径就不对了
→ 团队协作每个人路径不同

相对路径优势：
→ 自动适配当前项目
→ 团队成员统一配置
→ 便于项目迁移
```

---

## 6. 📅 日期格式设置


### 6.1 日期格式的作用


**在哪里用到日期？**
```java
/**
 * 用户表
 * 
 * @author 张三
 * @since 2025-01-15  ← 这里就是日期
 */
public class User {
    
    /** 创建时间 */
    private LocalDateTime createTime;  ← 日期类型
}
```

### 6.2 日期类型配置


**支持的日期类型：**

| 类型 | **说明** | **对应Java类** |
|------|----------|----------------|
| `ONLY_DATE` | 只有日期 | `java.util.Date` |
| `SQL_PACK` | SQL类型 | `java.sql.Date` |
| `TIME_PACK` | 时间包（推荐） | `java.time.LocalDateTime` |

**配置示例：**
```java
globalConfig.setDateType(DateType.TIME_PACK);  // 使用Java8时间类
```

**类型对比：**
```java
// ONLY_DATE：传统Date类型
private Date createTime;

// SQL_PACK：SQL专用类型
private java.sql.Date createTime;

// TIME_PACK：Java8新时间API（推荐）
private LocalDateTime createTime;
```

### 6.3 注释日期格式


**设置注释中的日期格式：**
```java
globalConfig.setCommentDate("yyyy-MM-dd");  // 年-月-日
```

**格式说明：**
```
yyyy = 四位年份（2025）
MM   = 两位月份（01-12）
dd   = 两位日期（01-31）
HH   = 24小时制（00-23）
mm   = 分钟（00-59）
ss   = 秒（00-59）
```

**常用格式示例：**
```java
// 只显示日期
.setCommentDate("yyyy-MM-dd")           
// 输出：2025-01-15

// 显示日期和时间
.setCommentDate("yyyy-MM-dd HH:mm:ss")  
// 输出：2025-01-15 10:30:00

// 中文格式
.setCommentDate("yyyy年MM月dd日")       
// 输出：2025年01月15日
```

**生成效果对比：**
```java
// 设置：yyyy-MM-dd
/**
 * @since 2025-01-15
 */

// 设置：yyyy-MM-dd HH:mm:ss  
/**
 * @since 2025-01-15 10:30:00
 */
```

---

## 7. 📝 文件注释模板


### 7.1 什么是注释模板


**通俗理解：**
```
注释模板 = 生成代码时自动添加的说明文字

就像写信的固定格式：
┌─────────────────┐
│ 尊敬的XX：      │ ← 固定开头
│ （正文）        │
│ 此致敬礼        │ ← 固定结尾
│ XXX 2025-01-15 │ ← 固定签名
└─────────────────┘
```

### 7.2 默认注释模板


**MyBatis-Plus默认会生成：**
```java
/**
 * <p>
 * 用户表 实体类
 * </p>
 *
 * @author 张三
 * @since 2025-01-15
 */
public class User {
    // ...
}
```

**注释模板的构成：**
```
┌─────────────────────────┐
│ /** 文档注释开始         │
│  * <p>                  │
│  * [表注释] [文件类型]  │ ← 动态内容
│  * </p>                 │
│  *                      │
│  * @author [作者]       │ ← 作者信息
│  * @since [日期]        │ ← 生成日期
│  */                     │
└─────────────────────────┘
```

### 7.3 自定义注释模板


**通过InjectionConfig注入自定义注释：**
```java
InjectionConfig injectionConfig = new InjectionConfig() {
    @Override
    public void initMap() {
        Map<String, Object> map = new HashMap<>();
        
        // 自定义注释内容
        map.put("copyright", "Copyright © 2025 XX公司");
        map.put("description", "本代码由代码生成器自动生成");
        
        this.setMap(map);
    }
};
```

**注释模板的应用位置：**
```
生成的所有文件都会带上注释：
Entity实体类
├── User.java         ← 带注释
├── Order.java        ← 带注释
└── Product.java      ← 带注释

Mapper接口
├── UserMapper.java   ← 带注释
└── ...

Service/Controller
└── 所有文件都带注释
```

### 7.4 注释模板最佳实践


**💡 推荐的注释内容：**
```java
/**
 * 用户表 实体类
 *
 * 功能说明：
 * - 对应数据库表：t_user
 * - 主要用途：用户信息管理
 *
 * @author 张三
 * @since 2025-01-15
 * @version 1.0
 */
```

**注释模板配置建议：**
```
基础信息（必须）：
✅ 类的作用说明
✅ 作者信息
✅ 创建日期

扩展信息（可选）：
→ 版本号
→ 对应数据库表
→ 业务功能说明
→ 修改记录
```

---

## 8. 📋 核心要点总结


### 8.1 全局配置的作用


```
🎯 统一规范：
→ 所有生成的代码遵循相同标准
→ 团队协作时保持一致性

⚙️ 提高效率：
→ 一次配置，处处生效
→ 减少重复设置工作

🔒 安全保护：
→ 控制文件覆盖行为
→ 保护已有代码不丢失
```

### 8.2 必须掌握的配置项


| 配置项 | **核心作用** | **推荐设置** |
|--------|------------|------------|
| `outputDir` | 代码输出位置 | 使用相对路径 |
| `author` | 作者标识 | 真实姓名或团队名 |
| `fileOverride` | 覆盖策略 | 开发true，生产false |
| `dateType` | 日期类型 | TIME_PACK（Java8） |
| `commentDate` | 日期格式 | yyyy-MM-dd |

### 8.3 实战配置模板


```java
// 完整的全局配置示例
GlobalConfig globalConfig = new GlobalConfig();

// 1. 基础路径（相对路径，自动适配）
String projectPath = System.getProperty("user.dir");
globalConfig.setOutputDir(projectPath + "/src/main/java");

// 2. 作者信息（团队协作推荐动态获取）
globalConfig.setAuthor(System.getProperty("user.name"));

// 3. 文件策略（开发环境允许覆盖）
globalConfig.setFileOverride(true);
globalConfig.setOpen(false);  // 生成后不打开

// 4. 日期配置（使用Java8时间API）
globalConfig.setDateType(DateType.TIME_PACK);
globalConfig.setCommentDate("yyyy-MM-dd");

// 5. 其他优化
globalConfig.setSwagger2(true);  // 开启Swagger注解
```

### 8.4 常见问题解决


**❓ Q1：生成的代码在哪里找？**
```
A：查看outputDir配置的路径
→ 使用相对路径时在项目的src/main/java下
→ 使用绝对路径时在指定的完整路径下
```

**❓ Q2：覆盖策略该怎么选？**
```
A：根据场景选择
→ 首次生成：true（放心覆盖）
→ 已有代码：false（保护原文件）
→ 配合Git：true（可随时回退）
```

**❓ Q3：日期类型选哪个？**
```
A：推荐TIME_PACK
→ Java8新API，功能更强
→ 线程安全
→ 使用方便
```

**❓ Q4：如何自定义注释内容？**
```
A：通过InjectionConfig
→ 可以添加版权信息
→ 可以加功能说明
→ 可以自定义任何内容
```

### 8.5 核心记忆口诀


```
📌 全局配置要点：

路径设置用相对，团队协作不出错
作者信息要规范，责任追溯有依据
覆盖策略需谨慎，开发生产要区分
日期类型选TIME_PACK，Java8时间更好用
注释模板要完整，代码规范要统一
```

**🎯 学习建议：**
```
1. 先掌握基础配置（路径、作者、覆盖）
2. 理解日期格式的应用场景
3. 学习自定义注释模板
4. 结合实际项目练习
5. 配合版本控制工具使用
```