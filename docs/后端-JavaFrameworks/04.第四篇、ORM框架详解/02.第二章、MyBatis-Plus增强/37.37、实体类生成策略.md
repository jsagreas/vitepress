---
title: 37、实体类生成策略
---
## 📚 目录

1. [实体类生成基础概念](#1-实体类生成基础概念)
2. [实体类配置选项详解](#2-实体类配置选项详解)
3. [Lombok注解支持](#3-lombok注解支持)
4. [链式调用支持](#4-链式调用支持)
5. [序列化接口配置](#5-序列化接口配置)
6. [字段注解自动生成](#6-字段注解自动生成)
7. [继承关系设置](#7-继承关系设置)
8. [实战案例演示](#8-实战案例演示)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 实体类生成基础概念


### 1.1 什么是实体类生成器


**🔸 通俗理解**
```
想象一下场景：
你的数据库有一张用户表，包含id、姓名、年龄等字段
传统做法：手写Java实体类，把每个字段对应写成属性

实体类生成器做什么？
→ 自动读取数据库表结构
→ 自动生成对应的Java实体类
→ 自动添加各种注解和配置
→ 节省大量重复劳动

就像"自动翻译"：
数据库表(中文) → 实体类生成器(翻译工具) → Java类(英文)
```

**💡 为什么需要代码生成器**
```
手写实体类的痛点：
- 表有20个字段，要写20个属性，容易出错
- 字段类型对应关系容易弄错（数据库VARCHAR → Java String）
- 注解容易遗漏或写错
- 表结构改了，实体类要同步修改

代码生成器的优势：
✅ 一键生成，准确无误
✅ 格式统一，代码规范
✅ 节省时间，提高效率
✅ 表结构变更可快速同步
```

### 1.2 生成流程示意图


```
数据库表结构                    实体类生成器                生成的Java类
┌─────────────┐                ┌─────────────┐           ┌──────────────┐
│ user表      │                │             │           │ User.java    │
│ ─────────── │   读取表结构    │  配置选项   │  生成代码  │              │
│ id  bigint  │ ────────────> │  ┌────────┐ │ ────────> │ @Data        │
│ name varchar│                │  │Lombok  │ │           │ @TableName   │
│ age  int    │                │  │注解    │ │           │ class User { │
│ create_time │                │  │        │ │           │   Long id;   │
└─────────────┘                │  └────────┘ │           │   String name│
                               │             │           │   ...        │
                               └─────────────┘           └──────────────┘

核心过程：
1. 连接数据库，获取表信息
2. 根据配置选项处理字段
3. 生成符合规范的Java代码
```

---

## 2. ⚙️ 实体类配置选项详解


### 2.1 基础配置项


**📋 核心配置说明**

| 配置项 | 作用说明 | 通俗理解 | 推荐值 |
|-------|---------|---------|--------|
| **fileOverride** | `是否覆盖已存在文件` | 已有User.java要不要重新生成覆盖 | `false(谨慎)` |
| **enableCache** | `启用缓存注解` | 给实体类加@Cacheable缓存注解 | `false` |
| **enableActiveRecord** | `启用AR模式` | 让实体类直接操作数据库 | `false` |
| **naming** | `命名策略` | 表名转类名的规则 | `underline_to_camel` |
| **columnNaming** | `字段命名策略` | 字段名转属性名规则 | `underline_to_camel` |

**🔧 配置代码示例**
```java
// 实体类策略配置
StrategyConfig strategy = new StrategyConfig.Builder()
    .entityBuilder()
    
    // 不覆盖已存在的文件（安全起见）
    .fileOverride(false)
    
    // 命名策略：下划线转驼峰
    // user_name → userName
    .naming(NamingStrategy.underline_to_camel)
    .columnNaming(NamingStrategy.underline_to_camel)
    
    .build();
```

### 2.2 命名策略详解


**🔤 字段命名转换规则**
```
数据库命名 → Java命名转换：

underline_to_camel（下划线转驼峰）：
user_name    → userName     ✅ 推荐
create_time  → createTime
is_deleted   → isDeleted

no_change（不改变）：
user_name    → user_name    ❌ 不规范
create_time  → create_time

remove_prefix（移除前缀）：
t_user       → User
sys_config   → Config
```

---

## 3. 🎨 Lombok注解支持


### 3.1 Lombok是什么


**🔸 新手友好解释**
```
Lombok是一个Java库，通过注解自动生成代码

不用Lombok的传统写法：
class User {
    private Long id;
    
    // 要手写getter
    public Long getId() { return id; }
    
    // 要手写setter
    public void setId(Long id) { this.id = id; }
    
    // 要手写toString、equals等...
}

使用Lombok：
@Data  // 一个注解搞定所有
class User {
    private Long id;
}

Lombok自动帮你生成：
✅ getter/setter方法
✅ toString方法
✅ equals和hashCode方法
```

### 3.2 常用Lombok注解


**📝 注解功能对照表**

| 注解 | 功能说明 | 生成的代码 | 使用场景 |
|-----|---------|-----------|---------|
| **@Data** | `生成全套方法` | getter/setter/toString/equals | `常规实体类` |
| **@Getter** | `只生成getter` | getId()、getName()等 | `只读实体` |
| **@Setter** | `只生成setter` | setId()、setName()等 | `构建实体` |
| **@Builder** | `建造者模式` | User.builder().id(1L).build() | `链式创建对象` |
| **@NoArgsConstructor** | `无参构造` | new User() | `框架要求` |
| **@AllArgsConstructor** | `全参构造` | new User(id, name, age) | `便捷初始化` |

**⚙️ 生成器中启用Lombok**
```java
StrategyConfig strategy = new StrategyConfig.Builder()
    .entityBuilder()
    
    // 启用Lombok
    .enableLombok()
    
    // 生成@Data注解
    .addTableFills(
        new Column("create_time", FieldFill.INSERT),
        new Column("update_time", FieldFill.INSERT_UPDATE)
    )
    
    .build();
```

**📄 生成效果对比**
```java
// 不启用Lombok - 代码冗长
public class User {
    private Long id;
    private String name;
    
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    // ... 省略20行代码
}

// 启用Lombok - 简洁清爽
@Data
@TableName("user")
public class User {
    private Long id;
    private String name;
}
```

---

## 4. 🔗 链式调用支持


### 4.1 链式调用概念


**🔸 直观理解**
```
普通方式创建对象（一步一步来）：
User user = new User();
user.setId(1L);
user.setName("张三");
user.setAge(25);

链式调用方式（一气呵成）：
User user = new User()
    .setId(1L)
    .setName("张三")
    .setAge(25);

关键区别：
普通setter返回void → 不能连续调用
链式setter返回this → 可以连续调用
```

### 4.2 启用链式调用


**⚙️ 配置方式**
```java
StrategyConfig strategy = new StrategyConfig.Builder()
    .entityBuilder()
    
    // 开启链式调用
    .enableChainModel()
    
    // 通常和Lombok一起用
    .enableLombok()
    
    .build();
```

**📄 生成的代码效果**
```java
// 启用链式调用后生成：
@Data
@Accessors(chain = true)  // Lombok的链式注解
@TableName("user")
public class User {
    private Long id;
    private String name;
    private Integer age;
}

// 使用效果：
User user = new User()
    .setId(1L)
    .setName("张三")
    .setAge(25)
    .setEmail("zhangsan@example.com");
```

### 4.3 链式调用的优势


```
代码可读性：
❌ 传统方式：
User user = new User();
user.setId(1L);
user.setName("张三");
user.setAge(25);
user.setEmail("zhangsan@qq.com");

✅ 链式调用：
User user = new User()
    .setId(1L).setName("张三")
    .setAge(25).setEmail("zhangsan@qq.com");

Builder模式配合：
User user = User.builder()
    .id(1L)
    .name("张三")
    .age(25)
    .build();

优势总结：
- 代码更紧凑流畅
- 赋值过程一目了然
- 符合函数式编程风格
```

---

## 5. 📦 序列化接口配置


### 5.1 序列化是什么


**🔸 通俗解释**
```
序列化：把Java对象变成可以存储/传输的格式
反序列化：把存储/传输的格式还原成Java对象

生活中的例子：
快递打包  = 序列化（把物品装箱，贴标签）
快递拆包  = 反序列化（从箱子取出物品）

Java中的序列化：
User对象 → 字节流 → 保存到文件/网络传输
文件/网络 → 字节流 → 还原成User对象
```

**💡 什么时候需要序列化**
```
常见应用场景：

1. 对象保存到磁盘：
   User对象 → 序列化 → 保存到user.dat文件

2. 网络传输：
   User对象 → 序列化 → 通过网络发送给远程服务器

3. 缓存存储：
   User对象 → 序列化 → 存入Redis缓存

4. 分布式系统：
   微服务A的User对象 → 序列化 → 传给微服务B
```

### 5.2 配置序列化接口


**⚙️ 生成器配置**
```java
StrategyConfig strategy = new StrategyConfig.Builder()
    .entityBuilder()
    
    // 实现Serializable接口
    .enableSerialVersionUID()
    
    .build();
```

**📄 生成效果**
```java
// 生成的实体类会自动实现Serializable
@Data
@TableName("user")
public class User implements Serializable {
    
    // 自动生成序列化版本号
    private static final long serialVersionUID = 1L;
    
    private Long id;
    private String name;
    private Integer age;
}
```

### 5.3 序列化版本号的作用


**⚠️ 为什么需要serialVersionUID**
```
版本控制机制：

场景：你序列化了一个User对象保存到文件
User对象 → 序列化 → 保存user.dat

后来你修改了User类（加了个字段）
class User {
    private Long id;
    private String name;
    private String email;  // 新加的
}

反序列化时：
user.dat → 读取 → 能否还原成新的User？

有serialVersionUID：
- 版本号一致 → 正常反序列化 ✅
- 版本号不一致 → 抛出异常 ⚠️

没有serialVersionUID：
- JVM自动生成版本号
- 类结构变化会导致版本号变化
- 反序列化失败 ❌
```

---

## 6. 🏷️ 字段注解自动生成


### 6.1 MyBatis-Plus核心注解


**📋 实体类常用注解**

| 注解 | 作用 | 使用场景 | 示例 |
|-----|------|---------|------|
| **@TableName** | `指定表名` | 表名和类名不一致 | `@TableName("sys_user")` |
| **@TableId** | `标记主键` | 指定主键字段和策略 | `@TableId(type=IdType.AUTO)` |
| **@TableField** | `指定字段` | 字段名不一致或特殊配置 | `@TableField("user_name")` |
| **@TableLogic** | `逻辑删除` | 标记删除字段 | `@TableLogic` |
| **@Version** | `乐观锁` | 版本号字段 | `@Version` |

### 6.2 主键注解配置


**🔑 @TableId策略详解**
```java
// 生成器配置主键策略
StrategyConfig strategy = new StrategyConfig.Builder()
    .entityBuilder()
    
    // 设置主键ID生成策略
    .idType(IdType.AUTO)  // 数据库自增
    
    .build();
```

**📝 主键策略对照表**

| 策略类型 | 说明 | 适用场景 | 值示例 |
|---------|------|---------|--------|
| **AUTO** | `数据库自增` | MySQL自增主键 | `1, 2, 3...` |
| **ASSIGN_ID** | `雪花算法` | 分布式系统 | `1523456789012345678` |
| **ASSIGN_UUID** | `UUID` | 需要全局唯一 | `550e8400-e29b-41d4` |
| **INPUT** | `手动输入` | 自定义ID值 | `用户指定` |

**📄 生成效果**
```java
@Data
@TableName("user")
public class User {
    
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    
    @TableField("user_name")
    private String userName;
}
```

### 6.3 字段填充注解


**🕐 自动填充时间字段**
```java
// 配置自动填充
StrategyConfig strategy = new StrategyConfig.Builder()
    .entityBuilder()
    
    // 创建时间填充
    .addTableFills(
        new Column("create_time", FieldFill.INSERT)
    )
    
    // 更新时间填充
    .addTableFills(
        new Column("update_time", FieldFill.INSERT_UPDATE)
    )
    
    .build();
```

**📄 生成的注解效果**
```java
@Data
@TableName("user")
public class User {
    
    private Long id;
    private String name;
    
    // 插入时自动填充
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    // 插入和更新时都填充
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
}
```

---

## 7. 🏗️ 继承关系设置


### 7.1 为什么要设置父类


**🔸 问题场景**
```
每个实体类都有这些字段：
- id（主键）
- createTime（创建时间）
- updateTime（更新时间）
- isDeleted（逻辑删除）

如果每个类都写一遍：
class User {
    private Long id;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private Integer isDeleted;
    // ... 业务字段
}

class Product {
    private Long id;  // 重复
    private LocalDateTime createTime;  // 重复
    private LocalDateTime updateTime;  // 重复
    private Integer isDeleted;  // 重复
    // ... 业务字段
}

解决方案：提取公共父类
class BaseEntity {  // 公共父类
    private Long id;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private Integer isDeleted;
}

class User extends BaseEntity {
    // 只写特有字段
    private String name;
    private Integer age;
}
```

### 7.2 配置父类


**⚙️ 设置超类配置**
```java
StrategyConfig strategy = new StrategyConfig.Builder()
    .entityBuilder()
    
    // 设置父类
    .superClass("com.example.common.BaseEntity")
    
    // 父类中的公共字段（生成时会忽略）
    .addSuperEntityColumns(
        "id", 
        "create_time", 
        "update_time", 
        "is_deleted"
    )
    
    .build();
```

### 7.3 父类定义示例


**📄 创建BaseEntity父类**
```java
package com.example.common;

@Data
public class BaseEntity implements Serializable {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    @TableLogic
    @TableField("is_deleted")
    private Integer deleted;
}
```

**📄 生成的子类实体**
```java
@Data
@EqualsAndHashCode(callSuper = true)  // 调用父类equals/hashCode
@TableName("user")
public class User extends BaseEntity {
    
    // 只包含业务字段，公共字段在父类中
    private String name;
    private Integer age;
    private String email;
}
```

### 7.4 继承的优势


```
代码复用优势：

❌ 不用父类：
- 每个实体类重复相同字段
- 修改公共字段要改所有类
- 代码冗余，维护困难

✅ 使用父类：
- 公共字段统一管理
- 修改一处，所有子类生效
- 代码简洁，易于维护

实际效果对比：

不用父类（50个实体类）：
每个类50行 × 50个类 = 2500行代码

用父类：
父类30行 + 每个子类20行 × 50个类 = 1030行代码
节省近60%代码量！
```

---

## 8. 🚀 实战案例演示


### 8.1 完整配置代码


**📝 综合示例**
```java
public class CodeGenerator {
    
    public static void main(String[] args) {
        // 数据源配置
        DataSourceConfig dataSourceConfig = new DataSourceConfig
            .Builder("jdbc:mysql://localhost:3306/demo", 
                     "root", "password")
            .build();
        
        // 全局配置
        GlobalConfig globalConfig = new GlobalConfig
            .Builder()
            .outputDir(System.getProperty("user.dir") + "/src/main/java")
            .author("开发者姓名")
            .enableSwagger()  // 开启Swagger注解
            .build();
        
        // 包配置
        PackageConfig packageConfig = new PackageConfig
            .Builder()
            .parent("com.example")
            .entity("entity")
            .mapper("mapper")
            .service("service")
            .controller("controller")
            .build();
        
        // 策略配置（实体类配置重点）
        StrategyConfig strategyConfig = new StrategyConfig
            .Builder()
            .addInclude("user", "product", "order")  // 要生成的表
            .entityBuilder()
                // Lombok支持
                .enableLombok()
                // 链式调用
                .enableChainModel()
                // 序列化
                .enableSerialVersionUID()
                // 命名策略
                .naming(NamingStrategy.underline_to_camel)
                .columnNaming(NamingStrategy.underline_to_camel)
                // 父类设置
                .superClass("com.example.common.BaseEntity")
                .addSuperEntityColumns("id", "create_time", "update_time")
                // 主键策略
                .idType(IdType.AUTO)
                // 自动填充
                .addTableFills(
                    new Column("create_time", FieldFill.INSERT),
                    new Column("update_time", FieldFill.INSERT_UPDATE)
                )
            .build();
        
        // 执行生成
        AutoGenerator generator = new AutoGenerator(dataSourceConfig);
        generator.global(globalConfig)
                 .packageInfo(packageConfig)
                 .strategy(strategyConfig)
                 .execute();
    }
}
```

### 8.2 生成结果展示


**📂 生成的目录结构**
```
src/main/java/com/example/
├── entity/          # 实体类包
│   ├── User.java
│   ├── Product.java
│   └── Order.java
├── mapper/          # Mapper接口
│   ├── UserMapper.java
│   ├── ProductMapper.java
│   └── OrderMapper.java
└── service/         # Service层
    ├── IUserService.java
    └── impl/
        └── UserServiceImpl.java
```

**📄 生成的User实体类**
```java
package com.example.entity;

import com.baomidou.mybatisplus.annotation.*;
import com.example.common.BaseEntity;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;
import java.io.Serializable;

/**
 * 用户表实体类
 */
@Data
@EqualsAndHashCode(callSuper = true)
@Accessors(chain = true)
@TableName("user")
public class User extends BaseEntity implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 用户名
     */
    private String userName;

    /**
     * 年龄
     */
    private Integer age;

    /**
     * 邮箱
     */
    private String email;
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 实体类生成器：自动读取数据库表，生成Java实体类
🔸 Lombok注解：通过注解简化getter/setter等样板代码
🔸 链式调用：让setter返回this，支持连续调用
🔸 序列化接口：让对象可以存储和网络传输
🔸 字段注解：@TableName、@TableId等标记数据库映射
🔸 继承父类：抽取公共字段，避免代码重复
```

### 9.2 配置选项速查表


| 功能 | 配置方法 | 作用效果 |
|-----|---------|---------|
| **Lombok** | `.enableLombok()` | `自动生成@Data等注解` |
| **链式调用** | `.enableChainModel()` | `支持user.setId().setName()` |
| **序列化** | `.enableSerialVersionUID()` | `实现Serializable接口` |
| **命名转换** | `.naming(NamingStrategy)` | `下划线转驼峰等规则` |
| **父类继承** | `.superClass("BaseEntity")` | `继承公共父类` |
| **主键策略** | `.idType(IdType.AUTO)` | `设置主键生成方式` |

### 9.3 最佳实践建议


**💡 实用技巧**
```
✅ 推荐做法：

1. 始终启用Lombok
   - 减少代码量90%
   - 提高开发效率

2. 根据需求选择链式调用
   - 构建复杂对象时很有用
   - 代码更流畅易读

3. 分布式系统必须序列化
   - 对象要网络传输
   - 缓存要存储对象

4. 使用父类管理公共字段
   - id、创建时间等
   - 统一管理，方便维护

5. 合理配置主键策略
   - 单机用AUTO（数据库自增）
   - 分布式用ASSIGN_ID（雪花算法）
```

**⚠️ 注意事项**
```
避免的坑：

❌ 不要轻易开启文件覆盖
   - fileOverride(true)会覆盖已有代码
   - 手写的代码会丢失

❌ 父类字段要明确排除
   - addSuperEntityColumns必须配置
   - 否则子类会重复生成

❌ 注意数据库字段类型映射
   - tinyint(1) → Boolean
   - bigint → Long
   - datetime → LocalDateTime
```

### 9.4 学习路径建议


```
新手学习顺序：

第1步：理解基本概念
└─> 知道实体类生成器是干什么的

第2步：掌握基础配置
└─> Lombok、命名策略、序列化

第3步：学习高级特性  
└─> 链式调用、父类继承、字段注解

第4步：实战练习
└─> 自己配置生成器，生成实体类

第5步：优化改进
└─> 根据项目需求调整配置
```

**核心记忆口诀**：
- 生成器读表结构，实体类自动生成
- Lombok简化代码，注解替代方法
- 链式调用流畅，父类复用字段
- 序列化支持传输，注解标记映射