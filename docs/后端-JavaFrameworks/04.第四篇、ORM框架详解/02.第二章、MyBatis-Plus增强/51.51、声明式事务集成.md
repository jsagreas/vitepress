---
title: 51、声明式事务集成
---
## 📚 目录

1. [事务管理基础概念](#1-事务管理基础概念)
2. [Spring声明式事务详解](#2-Spring声明式事务详解)
3. [事务传播机制深入](#3-事务传播机制深入)
4. [事务隔离级别实战](#4-事务隔离级别实战)
5. [回滚策略与异常处理](#5-回滚策略与异常处理)
6. [事务失效场景解析](#6-事务失效场景解析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💡 事务管理基础概念


### 1.1 什么是事务？


> **通俗理解**：事务就像是一个"要么全做，要么全不做"的任务包。比如银行转账，扣钱和加钱必须同时成功，不能只做一半。

**🔸 事务的本质**
- 就是把**多个数据库操作**打包成一个整体
- 这些操作要么**全部成功**，要么**全部失败**
- 不会出现做了一半的情况

**生活化类比**：
```
网购下单流程（就是一个事务）：
① 扣减库存
② 生成订单
③ 扣减余额
④ 发送通知

→ 如果第③步余额不足，前面的①②都要撤销
→ 这就是事务的"全有或全无"特性
```

### 1.2 事务的四大特性（ACID）


**📋 ACID特性通俗解释**

| 特性 | 英文 | 白话解释 | 生活例子 |
|------|------|----------|---------|
| **原子性** | `Atomicity` | 要么全做，要么全不做 | 转账不能只扣钱不加钱 |
| **一致性** | `Consistency` | 数据前后保持合理状态 | 转账前后总金额不变 |
| **隔离性** | `Isolation` | 多个事务互不干扰 | 两个人同时转账不会乱 |
| **持久性** | `Durability` | 完成后永久保存 | 转账成功就真的到账了 |

**💡 原子性举例**：
```java
// 转账操作必须是原子的
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 这两个操作必须同时成功或同时失败
    accountMapper.deduct(fromId, amount);  // 扣钱
    accountMapper.add(toId, amount);       // 加钱
}
// 如果加钱失败，扣钱也要撤销
```

### 1.3 为什么需要事务管理？


**🎯 没有事务会怎样**：

```
场景：电商订单创建
① 扣减库存（成功）
② 生成订单（成功）
③ 扣减余额（失败：余额不足）

❌ 没有事务：库存已扣，订单已生成，但没付钱
✅ 有事务：第③步失败，自动撤销①②步操作
```

**核心问题解决**：
- **数据一致性**：保证业务逻辑的完整性
- **并发控制**：多人同时操作不会出错
- **错误恢复**：出错时能自动回滚

---

## 2. 🔧 Spring声明式事务详解


### 2.1 什么是声明式事务？


> **通俗理解**：不用写一堆开启事务、提交事务的代码，只要加个**注解**，Spring自动帮你管理事务。

**对比理解**：

```
编程式事务（手动档）：
public void transfer() {
    TransactionStatus status = transactionManager.getTransaction(...);
    try {
        // 业务代码
        transactionManager.commit(status);
    } catch (Exception e) {
        transactionManager.rollback(status);
    }
}

声明式事务（自动档）：
@Transactional  // 就这一个注解，剩下的Spring全包了
public void transfer() {
    // 只写业务代码即可
}
```

### 2.2 @Transactional核心用法


**🔸 基础使用**

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private StockMapper stockMapper;
    
    // 最简单的用法：方法级别事务
    @Transactional
    public void createOrder(OrderDTO dto) {
        // 1. 扣减库存
        stockMapper.deduct(dto.getProductId(), dto.getQuantity());
        
        // 2. 创建订单
        orderMapper.insert(dto.toEntity());
        
        // 如果任何一步出错，两步都会回滚
    }
}
```

**📍 常用属性配置**

```java
@Transactional(
    // 事务传播行为
    propagation = Propagation.REQUIRED,
    
    // 事务隔离级别
    isolation = Isolation.DEFAULT,
    
    // 超时时间（秒）
    timeout = 30,
    
    // 只读事务（优化性能）
    readOnly = false,
    
    // 遇到哪些异常回滚
    rollbackFor = Exception.class,
    
    // 遇到哪些异常不回滚
    noRollbackFor = BusinessException.class
)
public void complexOperation() {
    // 业务逻辑
}
```

### 2.3 类级别 vs 方法级别


```java
// 类级别：所有public方法都有事务
@Service
@Transactional  // 对整个类生效
public class UserService {
    
    public void saveUser(User user) {
        // 自动有事务
    }
    
    public void updateUser(User user) {
        // 自动有事务
    }
    
    // 方法级别配置会覆盖类级别
    @Transactional(readOnly = true)
    public User getUser(Long id) {
        // 只读事务，性能更好
    }
}
```

**⚠️ 使用建议**：
- 查询操作：用 `readOnly = true`
- 写操作：用默认配置
- 复杂操作：根据需要精细配置

---

## 3. 🔄 事务传播机制深入


### 3.1 什么是事务传播？


> **通俗理解**：当一个有事务的方法A，调用另一个有事务的方法B时，B是加入A的事务，还是开启新事务？这就是传播机制要解决的问题。

**生活化类比**：
```
你在坐地铁（事务A）：
- 你朋友上车坐同一趟 → 加入已有事务（REQUIRED）
- 你朋友坐下一趟 → 开启新事务（REQUIRES_NEW）
- 你朋友打车走 → 不用事务（NOT_SUPPORTED）
```

### 3.2 七种传播行为详解


**📊 传播行为对比表**

| 传播行为 | 说明 | 使用场景 |
|---------|------|---------|
| **REQUIRED** ⭐ | `有事务就加入，没事务就新建` | **最常用，默认值** |
| **REQUIRES_NEW** | `总是开启新事务，挂起当前事务` | 记录操作日志（不受主业务影响） |
| **SUPPORTS** | `有事务就用，没事务就不用` | 查询操作 |
| **NOT_SUPPORTED** | `总是不用事务，挂起当前事务` | 不需要事务的操作 |
| **MANDATORY** | `必须有事务，否则抛异常` | 强制事务上下文 |
| **NEVER** | `必须没事务，否则抛异常` | 禁止事务场景 |
| **NESTED** | `嵌套事务，可独立回滚` | 部分失败可回滚 |

### 3.3 REQUIRED - 最常用的传播方式


**🔸 场景示例**：

```java
@Service
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    // 外层事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void createOrder(OrderDTO dto) {
        // 1. 创建订单
        orderMapper.insert(dto.toEntity());
        
        // 2. 记录日志（加入外层事务）
        logService.saveLog("订单创建成功");
        
        // 如果saveLog出错，订单创建也会回滚
    }
}

@Service
public class LogService {
    // 加入外层事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void saveLog(String message) {
        logMapper.insert(new Log(message));
    }
}
```

**执行流程图示**：
```
createOrder开启事务
    ↓
orderMapper.insert (在事务中)
    ↓
logService.saveLog (加入同一事务)
    ↓
任何一步失败 → 全部回滚
全部成功 → 一起提交
```

### 3.4 REQUIRES_NEW - 独立事务


**🔸 实战场景：操作日志必须保存**

```java
@Service
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    @Transactional
    public void createOrder(OrderDTO dto) {
        try {
            // 创建订单
            orderMapper.insert(dto.toEntity());
            
            // 记录成功日志（独立事务）
            logService.saveSuccessLog("订单创建成功");
            
        } catch (Exception e) {
            // 记录失败日志（独立事务，不受影响）
            logService.saveErrorLog("订单创建失败：" + e.getMessage());
            throw e;
        }
    }
}

@Service
public class LogService {
    
    // 新建独立事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveSuccessLog(String message) {
        logMapper.insert(new Log(message, "SUCCESS"));
    }
    
    // 新建独立事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveErrorLog(String message) {
        logMapper.insert(new Log(message, "ERROR"));
    }
}
```

**关键理解**：
```
主事务失败 → 订单回滚
日志事务独立 → 日志仍然保存 ✅

这样即使订单创建失败，也能知道失败原因
```

### 3.5 NESTED - 嵌套事务


**🔸 场景：部分失败可回滚**

```java
@Transactional
public void processOrder(OrderDTO dto) {
    // 主流程：创建订单
    orderMapper.insert(dto.toEntity());
    
    try {
        // 子流程：发送优惠券（可能失败）
        couponService.sendCoupon(dto.getUserId());
    } catch (Exception e) {
        // 优惠券发送失败，只回滚优惠券操作
        // 订单仍然创建成功
        log.error("优惠券发送失败", e);
    }
}

@Service  
public class CouponService {
    @Transactional(propagation = Propagation.NESTED)
    public void sendCoupon(Long userId) {
        // 优惠券逻辑
    }
}
```

**流程说明**：
```
订单创建 → 成功
    ↓
发优惠券 → 失败（NESTED事务）
    ↓
只回滚优惠券 → 订单保留 ✅
```

---

## 4. 🔒 事务隔离级别实战


### 4.1 为什么需要隔离级别？


> **通俗理解**：多个人同时操作数据库，就像多人同时编辑同一个文档，需要规定谁能看到谁的修改。

**🎯 并发问题演示**：

```
场景：两个用户同时查询余额并转账

时间线：
T1: 用户A查询余额 = 1000元
T2: 用户B查询余额 = 1000元
T3: 用户A转出500元，余额 = 500元
T4: 用户B转出600元，余额 = 400元

❌ 问题：最后余额400元，但实际转出1100元！
```

### 4.2 四种隔离级别详解


**📋 隔离级别对比**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 使用建议 |
|---------|-----|-----------|-----|------|---------|
| **READ_UNCOMMITTED** | ❌可能 | ❌可能 | ❌可能 | ⚡最快 | 不建议用 |
| **READ_COMMITTED** | ✅避免 | ❌可能 | ❌可能 | ⚡较快 | Oracle默认 |
| **REPEATABLE_READ** ⭐ | ✅避免 | ✅避免 | ❌可能 | 🐢较慢 | **MySQL默认** |
| **SERIALIZABLE** | ✅避免 | ✅避免 | ✅避免 | 🐢最慢 | 极少使用 |

### 4.3 三大并发问题解释


**🔸 脏读（读到未提交的数据）**

```java
// 事务A
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void transferMoney() {
    accountMapper.deduct(1L, 100);  // 扣100元
    // 还没提交
}

// 事务B（同时进行）
@Transactional(isolation = Isolation.READ_UNCOMMITTED)  
public BigDecimal getBalance() {
    return accountMapper.getBalance(1L);  
    // 读到了扣除后的金额（但A可能回滚！）
}

问题：如果A回滚，B读到的是"脏"数据
```

**🔸 不可重复读（同一查询结果不一致）**

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void checkBalance() {
    // 第一次查询
    BigDecimal balance1 = accountMapper.getBalance(1L); 
    // 余额 = 1000
    
    // 此时另一个事务修改了余额并提交
    
    // 第二次查询
    BigDecimal balance2 = accountMapper.getBalance(1L);
    // 余额 = 500（变了！）
    
    // balance1 != balance2 → 不可重复读
}
```

**🔸 幻读（查询行数不一致）**

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void countOrders() {
    // 第一次统计
    int count1 = orderMapper.selectCount(null);
    // count = 10
    
    // 此时另一个事务插入了新订单
    
    // 第二次统计
    int count2 = orderMapper.selectCount(null);
    // count = 11（多了一行，像幻觉）
}
```

### 4.4 实际应用配置


```java
@Service
public class AccountService {
    
    // 转账：需要高隔离级别
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void transfer(Long from, Long to, BigDecimal amount) {
        // 确保余额查询和扣减的一致性
        BigDecimal balance = accountMapper.getBalance(from);
        if (balance.compareTo(amount) < 0) {
            throw new BusinessException("余额不足");
        }
        accountMapper.deduct(from, amount);
        accountMapper.add(to, amount);
    }
    
    // 查询统计：可用较低隔离级别
    @Transactional(
        isolation = Isolation.READ_COMMITTED,
        readOnly = true
    )
    public OrderStatistics getStatistics() {
        // 对数据一致性要求不高的统计
        return orderMapper.getStatistics();
    }
}
```

**💡 选择建议**：
- **金融交易**：用 `REPEATABLE_READ` 或 `SERIALIZABLE`
- **普通查询**：用 `READ_COMMITTED`（性能更好）
- **实时统计**：根据精度要求选择
- **默认配置**：MySQL的 `REPEATABLE_READ` 已足够

---

## 5. ⚠️ 回滚策略与异常处理


### 5.1 默认回滚规则


> **关键点**：Spring事务默认只对**运行时异常**回滚，**检查异常**不回滚。

**🔸 异常分类理解**：

```
Java异常体系：
                 Throwable
                /          \
           Error          Exception
                         /         \
                RuntimeException   检查异常(Checked)
                /      |      \
     NullPointer  IllegalArg  业务异常
     
默认回滚：RuntimeException及其子类 ✅
默认不回滚：检查异常 ❌
```

**实际表现**：

```java
@Transactional
public void saveUser(User user) {
    userMapper.insert(user);
    
    // 这会回滚
    throw new NullPointerException();
    
    // 这不会回滚！
    throw new IOException();
}
```

### 5.2 自定义回滚策略


**🔸 指定回滚异常**

```java
@Service
public class OrderService {
    
    // 遇到所有Exception都回滚
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(OrderDTO dto) throws Exception {
        orderMapper.insert(dto.toEntity());
        
        // 即使是检查异常，也会回滚
        if (dto.getAmount() == null) {
            throw new Exception("金额不能为空");
        }
    }
    
    // 遇到特定异常不回滚
    @Transactional(
        rollbackFor = Exception.class,
        noRollbackFor = BusinessException.class
    )
    public void processOrder(OrderDTO dto) {
        orderMapper.insert(dto.toEntity());
        
        // 业务异常不回滚（比如库存不足，订单已创建）
        if (stockMapper.getStock(dto.getProductId()) < dto.getQuantity()) {
            throw new BusinessException("库存不足");
        }
    }
}
```

### 5.3 手动控制回滚


**🔸 编程式回滚控制**

```java
@Transactional
public void complexOperation(OrderDTO dto) {
    try {
        // 业务操作
        orderMapper.insert(dto.toEntity());
        stockMapper.deduct(dto.getProductId(), dto.getQuantity());
        
    } catch (StockNotEnoughException e) {
        // 手动标记回滚
        TransactionAspectSupport.currentTransactionStatus()
            .setRollbackOnly();
        
        // 记录日志但不抛异常
        log.error("库存不足，事务已回滚", e);
    }
}
```

### 5.4 异常处理最佳实践


**✅ 推荐做法**：

```java
// 1. 统一配置回滚所有异常
@Transactional(rollbackFor = Exception.class)
public void standardMethod() {
    // 业务逻辑
}

// 2. 自定义业务异常
public class BusinessException extends RuntimeException {
    private String errorCode;
    
    public BusinessException(String message) {
        super(message);
    }
}

// 3. 区分业务异常和系统异常
@Transactional
public void processWithException(OrderDTO dto) {
    // 系统异常：回滚
    if (dto == null) {
        throw new IllegalArgumentException("参数不能为空");
    }
    
    // 业务异常：根据需要决定是否回滚
    if (dto.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
        throw new BusinessException("金额必须大于0");
    }
}
```

---

## 6. 🚨 事务失效场景解析


### 6.1 场景一：方法非public


**❌ 错误示例**：

```java
@Service
public class UserService {
    
    // 事务不生效！
    @Transactional
    private void saveUser(User user) {
        userMapper.insert(user);
    }
    
    // 事务也不生效！
    @Transactional
    protected void updateUser(User user) {
        userMapper.updateById(user);
    }
}
```

**✅ 正确做法**：

```java
@Service
public class UserService {
    
    // 必须是public方法
    @Transactional
    public void saveUser(User user) {
        userMapper.insert(user);
    }
}
```

**原理**：Spring AOP代理只能拦截public方法

### 6.2 场景二：同类方法调用


**❌ 最常见的失效场景**：

```java
@Service
public class OrderService {
    
    // 外层方法没有事务
    public void createOrder(OrderDTO dto) {
        // 直接调用，事务不生效！
        this.saveOrder(dto);
    }
    
    @Transactional
    public void saveOrder(OrderDTO dto) {
        orderMapper.insert(dto.toEntity());
    }
}
```

**✅ 解决方案一：外层方法加事务**

```java
@Service
public class OrderService {
    
    @Transactional  // 外层加事务
    public void createOrder(OrderDTO dto) {
        this.saveOrder(dto);  // 现在生效了
    }
    
    @Transactional
    public void saveOrder(OrderDTO dto) {
        orderMapper.insert(dto.toEntity());
    }
}
```

**✅ 解决方案二：通过代理对象调用**

```java
@Service
public class OrderService {
    
    // 注入自己
    @Autowired
    private OrderService self;
    
    public void createOrder(OrderDTO dto) {
        // 通过代理调用，事务生效
        self.saveOrder(dto);
    }
    
    @Transactional
    public void saveOrder(OrderDTO dto) {
        orderMapper.insert(dto.toEntity());
    }
}
```

### 6.3 场景三：异常被捕获


**❌ 吞掉异常导致不回滚**：

```java
@Transactional
public void saveUser(User user) {
    try {
        userMapper.insert(user);
        // 发生异常
        int result = 1 / 0;
    } catch (Exception e) {
        // 异常被捕获，事务不会回滚！
        log.error("保存失败", e);
    }
}
```

**✅ 正确处理方式**：

```java
@Transactional
public void saveUser(User user) {
    try {
        userMapper.insert(user);
        int result = 1 / 0;
    } catch (Exception e) {
        log.error("保存失败", e);
        // 手动回滚或重新抛出异常
        throw new RuntimeException("保存用户失败", e);
    }
}
```

### 6.4 场景四：数据库引擎不支持


**❌ MyISAM引擎不支持事务**：

```sql
-- 查看表引擎
SHOW CREATE TABLE user;

-- 如果是MyISAM，改为InnoDB
ALTER TABLE user ENGINE = InnoDB;
```

**✅ 确保使用InnoDB**：

```yaml
# application.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db?useSSL=false
    # MySQL 5.5+ 默认就是InnoDB
```

### 6.5 场景五：多线程调用


**❌ 子线程中事务失效**：

```java
@Transactional
public void processAsync(List<User> users) {
    users.forEach(user -> {
        // 新线程中，事务失效！
        new Thread(() -> {
            userMapper.insert(user);
        }).start();
    });
}
```

**✅ 正确做法**：

```java
@Transactional
public void processBatch(List<User> users) {
    // 在同一事务中批量处理
    users.forEach(user -> {
        userMapper.insert(user);
    });
}

// 或者使用@Async配合事务传播
@Async
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void processAsync(User user) {
    userMapper.insert(user);
}
```

### 6.6 失效场景总结


| 失效原因 | 表现 | 解决方案 |
|---------|------|---------|
| **方法非public** | 注解不生效 | 改为public方法 |
| **类内部调用** | 代理失效 | 通过代理对象调用 |
| **异常被捕获** | 不触发回滚 | 重新抛出或手动回滚 |
| **引擎不支持** | 事务无效 | 使用InnoDB引擎 |
| **多线程** | 事务上下文丢失 | 避免新线程或传播新事务 |
| **传播属性错误** | 行为异常 | 选择正确的传播级别 |

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 事务本质：一组操作要么全做，要么全不做（原子性）
🔸 声明式事务：通过@Transactional注解实现，简化事务管理
🔸 传播机制：控制事务方法间的调用关系（7种传播行为）
🔸 隔离级别：解决并发问题（脏读、不可重复读、幻读）
🔸 回滚策略：默认RuntimeException回滚，可自定义配置
🔸 失效场景：非public、内部调用、异常捕获等6大场景
```

### 7.2 关键理解要点


**🔹 @Transactional的工作原理**
```
Spring AOP代理机制：
① 扫描到@Transactional注解
② 创建代理对象
③ 拦截方法调用
④ 开启事务 → 执行方法 → 提交/回滚
```

**🔹 传播机制的选择原则**
```
REQUIRED：    适合大多数场景（默认）
REQUIRES_NEW：日志记录、审计等独立操作
NESTED：      部分失败可回滚的场景
NOT_SUPPORTED：不需要事务的操作
```

**🔹 隔离级别的权衡**
```
性能 vs 一致性：
READ_UNCOMMITTED → 最快，但不安全
REPEATABLE_READ  → 平衡点（MySQL默认）
SERIALIZABLE     → 最安全，但最慢
```

### 7.3 实战应用建议


**💼 开发规范**
- **统一配置**：`@Transactional(rollbackFor = Exception.class)`
- **只读优化**：查询方法用 `readOnly = true`
- **细粒度控制**：根据业务需要选择传播行为
- **避免大事务**：控制事务粒度，避免长时间持有

**🎯 常见业务场景**

```java
// 场景1：订单创建（标准事务）
@Transactional(rollbackFor = Exception.class)
public void createOrder(OrderDTO dto) {
    // 扣库存、生成订单、扣余额
}

// 场景2：日志记录（独立事务）
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveLog(String msg) {
    // 无论主业务成败，日志都要保存
}

// 场景3：批量导入（可部分失败）
@Transactional(propagation = Propagation.NESTED)
public void importUser(User user) {
    // 某个用户导入失败，不影响其他
}

// 场景4：统计查询（只读事务）
@Transactional(readOnly = true, 
    isolation = Isolation.READ_COMMITTED)
public Statistics getStatistics() {
    // 提升查询性能
}
```

**⚠️ 避免的坑**
```
1. 不要在事务方法中做耗时操作（如远程调用）
2. 不要在循环中开启大量事务
3. 注意同类方法调用的事务失效问题
4. 异常捕获后要么重新抛出，要么手动回滚
5. 确保数据库引擎支持事务（InnoDB）
```

### 7.4 学习检查清单


**✓ 基础概念**
- [ ] 理解事务的ACID特性
- [ ] 掌握@Transactional的基本用法
- [ ] 了解7种事务传播行为
- [ ] 理解4种事务隔离级别

**✓ 实战应用**
- [ ] 能正确配置事务属性
- [ ] 会处理事务回滚策略
- [ ] 能解决事务失效问题
- [ ] 掌握常见业务场景的事务设计

**✓ 进阶理解**
- [ ] 理解Spring事务的AOP原理
- [ ] 掌握事务与数据源的关系
- [ ] 了解分布式事务的基本概念
- [ ] 能进行事务性能优化

**核心记忆**：
```
事务四特性ACID要牢记，原子一致隔离持久性
声明式事务加注解，Spring代理自动管理
传播机制七种行为，REQUIRED最常用
隔离级别四层次，脏读幻读要区分
回滚策略要配置，异常捕获别吞掉
事务失效六场景，public代理是关键
```