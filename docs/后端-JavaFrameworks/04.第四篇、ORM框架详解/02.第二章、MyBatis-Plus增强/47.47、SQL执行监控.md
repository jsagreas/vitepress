---
title: 47、SQL执行监控
---
## 📚 目录


1. [SQL监控基础概念](#1-SQL监控基础概念)
2. [SQL日志打印配置](#2-SQL日志打印配置)
3. [执行时间统计](#3-执行时间统计)
4. [参数绑定监控](#4-参数绑定监控)
5. [结果集分析](#5-结果集分析)
6. [慢查询定位](#6-慢查询定位)
7. [性能监控指标](#7-性能监控指标)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 SQL监控基础概念



### 1.1 什么是SQL监控



**通俗理解**：就像给汽车装了个行车记录仪，SQL监控就是记录数据库操作的"黑匣子"

```
生活类比：
看病时医生问诊 ≈ SQL监控
- 医生：你哪里不舒服？多久了？
- 监控：哪条SQL慢了？执行了多久？

目的都是：找出问题，对症下药
```

**核心作用**：
- 🔎 **看见问题**：哪些SQL在执行
- ⏱️ **发现瓶颈**：哪条SQL最慢
- 🐛 **定位错误**：SQL语句是否正确
- 📊 **优化依据**：提供性能改进方向

### 1.2 为什么需要SQL监控



**实际场景问题**：

```
❌ 没有监控时的困境：
开发：老板，系统好慢啊！
老板：哪里慢？
开发：不知道...整体都慢
老板：那怎么优化？
开发：😭 不知道从哪下手

✅ 有监控后的清晰：
监控：订单查询SQL耗时3秒
开发：找到了！是这条SQL没加索引
老板：👍 立即优化
```

**监控的价值**：

| **场景** | **没有监控** | **有监控后** |
|---------|------------|------------|
| 系统慢 | 😵 不知道哪慢 | ✅ 精准定位慢查询 |
| 出错了 | 🤔 不知道错在哪 | ✅ 看到完整SQL |
| 优化 | 💭 凭感觉改 | ✅ 数据驱动决策 |

---

## 2. 📝 SQL日志打印配置



### 2.1 基础日志配置



**什么是SQL日志**：就是把执行的SQL语句打印出来，像看电影字幕一样能看到发生了什么

**三种日志级别**：

```
┌─ 日志级别选择 ─────────────┐
│ DEBUG - 详细信息(开发用)   │
│ INFO  - 一般信息(测试用)   │  
│ WARN  - 警告信息(生产用)   │
└────────────────────────────┘
```

### 2.2 配置方式对比



**方式一：application.yml配置**
```yaml
# 开发环境：打印完整SQL

mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  # 控制台输出

# 生产环境：使用专业日志框架

logging:
  level:
    com.example.mapper: debug  # 只监控mapper包
```

**方式二：使用p6spy增强（推荐）**

```
为什么推荐p6spy？
普通日志：SELECT * FROM user WHERE id = ?
p6spy日志：SELECT * FROM user WHERE id = 1  ← 参数已替换，一眼看懂
```

**p6spy配置步骤**：

```xml
<!-- 1. 添加依赖 -->
<dependency>
    <groupId>p6spy</groupId>
    <artifactId>p6spy</artifactId>
    <version>3.9.1</version>
</dependency>
```

```yaml
# 2. 修改数据源配置

spring:
  datasource:
    driver-class-name: com.p6spy.engine.spy.P6SpyDriver  # 用p6spy驱动
    url: jdbc:p6spy:mysql://localhost:3306/test         # URL加p6spy前缀
```

```properties
# 3. spy.properties配置文件

# 日志输出到控制台

appender=com.p6spy.engine.spy.appender.StdoutLogger
# 自定义日志格式（易读）

logMessageFormat=com.p6spy.engine.spy.appender.CustomLineFormat
customLogMessageFormat=耗时:%(executionTime)ms | SQL:%(sql)
# 过滤系统SQL

excludecategories=info,debug,result,resultset
```

### 2.3 日志格式优化



**优化前 vs 优化后**：

```
❌ 默认格式（难读）：
Preparing: SELECT * FROM user WHERE id = ? AND status = ?
Parameters: 1(Integer), 1(Integer)

✅ 优化格式（清晰）：
━━━━━━━━━━━━━━━━━━━━━━
⏱ 耗时: 15ms
📝 SQL: SELECT * FROM user WHERE id = 1 AND status = 1
📊 结果: 1条记录
━━━━━━━━━━━━━━━━━━━━━━
```

**自定义日志拦截器**：

```java
@Slf4j
@Component
public class SqlLogInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long start = System.currentTimeMillis();
        
        try {
            Object result = invocation.proceed();
            long cost = System.currentTimeMillis() - start;
            
            // 只打印慢查询（超过100ms）
            if (cost > 100) {
                log.warn("慢查询告警 | 耗时:{}ms | SQL:{}", cost, getSql(invocation));
            }
            
            return result;
        } catch (Exception e) {
            log.error("SQL执行失败 | {}", getSql(invocation), e);
            throw e;
        }
    }
    
    private String getSql(Invocation invocation) {
        // 提取SQL语句的逻辑
        return "具体SQL内容";
    }
}
```

---

## 3. ⏱️ 执行时间统计



### 3.1 时间统计的重要性



**为什么要统计时间**：

```
类比：
做饭时看表 → 知道哪道菜最耗时 → 下次提前准备
SQL计时  → 知道哪条最慢   → 优先优化
```

**关键时间节点**：

```
SQL执行完整流程：
准备阶段 → 执行阶段 → 结果处理
   ↓          ↓          ↓
  5ms       50ms       10ms
         (主要耗时)
```

### 3.2 性能插件配置



**使用MyBatis-Plus性能分析插件**：

```java
@Configuration
public class MybatisPlusConfig {
    
    @Bean
    @Profile({"dev", "test"})  // 只在开发测试环境启用
    public PerformanceInterceptor performanceInterceptor() {
        PerformanceInterceptor interceptor = new PerformanceInterceptor();
        interceptor.setMaxTime(1000);      // 超过1秒报警
        interceptor.setFormat(true);       // SQL格式化
        return interceptor;
    }
}
```

**效果展示**：

```
✅ 正常SQL（200ms）：
Time：200 ms
SQL：SELECT * FROM user WHERE age > 18

⚠️ 慢查询告警（1200ms）：
⚠️⚠️⚠️ SQL执行超时！⚠️⚠️⚠️
Time：1200 ms  ← 超过限制
SQL：SELECT * FROM order o LEFT JOIN user u ON o.user_id = u.id
```

### 3.3 执行时间分段统计



**时间区间分类**：

```
执行时间分布：
🟢 优秀 (0-100ms)   : ████████████ 60%
🟡 良好 (100-500ms) : ████████     40%
🟠 较慢 (500-1000ms): ███          15%
🔴 慢查询(>1000ms)  : █            5%  ← 需要优化
```

**统计代码实现**：

```java
@Component
public class SqlTimeStatistics {
    
    private final Map<String, List<Long>> timeRecords = new ConcurrentHashMap<>();
    
    public void record(String sqlId, long time) {
        timeRecords.computeIfAbsent(sqlId, k -> new ArrayList<>()).add(time);
    }
    
    public String getReport() {
        StringBuilder report = new StringBuilder();
        report.append("\n========== SQL执行时间统计 ==========\n");
        
        timeRecords.forEach((sqlId, times) -> {
            long avg = times.stream().mapToLong(Long::longValue).sum() / times.size();
            long max = times.stream().mapToLong(Long::longValue).max().orElse(0);
            
            report.append(String.format(
                "SQL: %s\n平均耗时: %dms | 最大耗时: %dms | 执行次数: %d\n",
                sqlId, avg, max, times.size()
            ));
        });
        
        return report.toString();
    }
}
```

---

## 4. 🔗 参数绑定监控



### 4.1 参数绑定是什么



**通俗解释**：

```
SQL模板：SELECT * FROM user WHERE name = ?
参数绑定：把"张三"填到?的位置

就像：
问卷模板：我叫____，今年____岁
填写过程：我叫张三，今年25岁  ← 这就是"参数绑定"
```

### 4.2 为什么要监控参数



**常见问题**：

```
❌ 类型错误：
SQL: WHERE age = ?
传入: "25"  ← 字符串，应该是数字
结果: 😵 索引失效，查询变慢

❌ SQL注入风险：
传入: "1' OR '1'='1"
SQL: WHERE id = 1' OR '1'='1  ← 危险！
```

### 4.3 参数监控配置



**完整参数日志**：

```java
@Aspect
@Component
public class ParameterMonitor {
    
    @Around("execution(* com.example.mapper..*(..))")
    public Object monitor(ProceedingJoinPoint point) throws Throwable {
        Object[] args = point.getArgs();
        
        // 记录参数信息
        log.info("┌─ 参数监控 ─────────────");
        log.info("│ 方法: {}", point.getSignature().getName());
        log.info("│ 参数类型: {}", getParamTypes(args));
        log.info("│ 参数值: {}", getParamValues(args));
        log.info("└────────────────────────");
        
        return point.proceed();
    }
    
    private String getParamTypes(Object[] args) {
        return Arrays.stream(args)
            .map(arg -> arg.getClass().getSimpleName())
            .collect(Collectors.joining(", "));
    }
    
    private String getParamValues(Object[] args) {
        return Arrays.stream(args)
            .map(this::safeToString)
            .collect(Collectors.joining(", "));
    }
    
    private String safeToString(Object obj) {
        if (obj instanceof String && ((String) obj).length() > 100) {
            return ((String) obj).substring(0, 100) + "...(已截断)";
        }
        return String.valueOf(obj);
    }
}
```

**输出效果**：

```
┌─ 参数监控 ─────────────
│ 方法: selectById
│ 参数类型: Long
│ 参数值: 1001
│ ✅ 类型正确，值有效
└────────────────────────

┌─ 参数监控 ─────────────  
│ 方法: selectByName
│ 参数类型: String
│ 参数值: 张三'OR'1'='1
│ ⚠️ 检测到可疑字符：OR, '
└────────────────────────
```

---

## 5. 📊 结果集分析



### 5.1 什么是结果集分析



**通俗理解**：

```
就像网购：
下单 → 等待 → 收货 → 验货

SQL查询：
执行 → 等待 → 返回结果 → 分析结果
                      ↑
                   结果集分析
```

### 5.2 结果集关键指标



**核心监控点**：

```
结果集健康检查清单：
✅ 返回行数：是否合理？
✅ 数据大小：是否过大？
✅ 字段数量：是否查询了不需要的字段？
✅ 空值比例：是否有很多null？
```

**问题示例**：

| **症状** | **原因** | **影响** | **解决** |
|---------|---------|---------|---------|
| 返回10万行 | 缺少分页 | 内存溢出 | 加LIMIT |
| 查询20个字段 | SELECT * | 网络浪费 | 只选需要的 |
| 50%字段为空 | 表设计问题 | 存储浪费 | 优化表结构 |

### 5.3 结果集监控实现



```java
@Component
public class ResultSetAnalyzer {
    
    public void analyze(Object result) {
        if (result instanceof List) {
            analyzeList((List<?>) result);
        } else if (result != null) {
            analyzeSingle(result);
        }
    }
    
    private void analyzeList(List<?> list) {
        int size = list.size();
        
        System.out.println("━━━━━━━━━ 结果集分析 ━━━━━━━━━");
        System.out.println("📊 返回行数: " + size);
        
        // 大结果集告警
        if (size > 1000) {
            System.out.println("⚠️ 大结果集告警：返回" + size + "行");
            System.out.println("💡 建议：添加分页或优化查询条件");
        }
        
        // 分析字段使用情况
        if (!list.isEmpty()) {
            Object first = list.get(0);
            analyzeFields(first);
        }
        
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
    
    private void analyzeFields(Object obj) {
        Field[] fields = obj.getClass().getDeclaredFields();
        int nullCount = 0;
        
        for (Field field : fields) {
            field.setAccessible(true);
            try {
                if (field.get(obj) == null) {
                    nullCount++;
                }
            } catch (Exception e) {
                // 忽略
            }
        }
        
        if (nullCount > fields.length / 2) {
            System.out.println("⚠️ 字段空值率: " + 
                (nullCount * 100 / fields.length) + "%");
            System.out.println("💡 建议：检查是否查询了不必要的字段");
        }
    }
}
```

---

## 6. 🐌 慢查询定位



### 6.1 什么是慢查询



**生活类比**：

```
快递配送：
正常：1天送到  → 快查询
慢的：7天送到  → 慢查询

慢查询：就是执行时间明显超过正常水平的SQL
```

**慢查询的危害**：

```
一条慢查询的连锁反应：
慢查询(3秒) → 数据库连接占用 → 其他请求等待 → 
系统卡顿 → 用户抱怨 → 老板生气 😡
```

### 6.2 慢查询阈值设置



**如何定义"慢"**：

```
根据业务场景设置：
简单查询：    > 100ms  算慢
复杂统计：    > 500ms  算慢  
报表查询：    > 1000ms 算慢

生产环境建议：200ms 作为告警线
```

**配置示例**：

```java
@Configuration
public class SlowQueryConfig {
    
    @Bean
    public SlowQueryInterceptor slowQueryInterceptor() {
        return new SlowQueryInterceptor()
            .setSlowThreshold(200)      // 慢查询阈值200ms
            .setAlertThreshold(1000)    // 严重慢查询1秒
            .setEnableAlert(true);      // 开启告警
    }
}
```

### 6.3 慢查询日志分析



**完整慢查询记录**：

```
━━━━━━━━━ 慢查询告警 ━━━━━━━━━
🔴 严重性: 高
⏱ 执行时间: 1500ms
📅 发生时间: 2025-01-15 10:30:25
📝 SQL语句:
   SELECT o.*, u.name 
   FROM order o 
   LEFT JOIN user u ON o.user_id = u.id
   WHERE o.create_time > '2025-01-01'

🔍 问题分析:
   ❌ 缺少索引: create_time字段无索引
   ❌ 表连接: 全表扫描10万条记录
   
💡 优化建议:
   1. 在create_time字段创建索引
   2. 考虑添加分页限制
   3. 评估是否需要所有字段
━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**慢查询统计报表**：

```java
@Service
public class SlowQueryReporter {
    
    private List<SlowQueryRecord> records = new ArrayList<>();
    
    public String generateReport() {
        Map<String, List<SlowQueryRecord>> grouped = records.stream()
            .collect(Collectors.groupingBy(SlowQueryRecord::getSqlPattern));
        
        StringBuilder report = new StringBuilder();
        report.append("\n========== 慢查询TOP 10 ==========\n");
        
        grouped.entrySet().stream()
            .sorted((e1, e2) -> Integer.compare(
                e2.getValue().size(), 
                e1.getValue().size()
            ))
            .limit(10)
            .forEach(entry -> {
                String pattern = entry.getKey();
                List<SlowQueryRecord> list = entry.getValue();
                long avgTime = list.stream()
                    .mapToLong(SlowQueryRecord::getExecutionTime)
                    .sum() / list.size();
                
                report.append(String.format(
                    "SQL模式: %s\n" +
                    "出现次数: %d次\n" +
                    "平均耗时: %dms\n" +
                    "─────────────────\n",
                    pattern, list.size(), avgTime
                ));
            });
        
        return report.toString();
    }
}
```

---

## 7. 📈 性能监控指标



### 7.1 核心监控指标体系



**完整监控仪表盘**：

```
性能监控四大维度：
┌─────────────────────────────┐
│ ⏱ 时间指标                  │
│   - 平均响应时间             │
│   - 最大响应时间             │
│   - TP99/TP95响应时间       │
├─────────────────────────────┤
│ 📊 吞吐量指标                │
│   - QPS(每秒查询数)          │
│   - TPS(每秒事务数)          │
├─────────────────────────────┤
│ 🎯 准确性指标                │
│   - 错误率                   │
│   - 超时率                   │
├─────────────────────────────┤
│ 💾 资源指标                  │
│   - 连接池使用率             │
│   - 内存占用                 │
└─────────────────────────────┘
```

### 7.2 关键指标详解



**指标说明**：

| **指标** | **含义** | **正常范围** | **告警值** |
|---------|---------|-------------|-----------|
| 平均响应时间 | SQL平均执行时长 | < 50ms | > 200ms |
| TP99 | 99%的请求响应时间 | < 100ms | > 500ms |
| QPS | 每秒SQL执行数 | 1000-5000 | > 10000 |
| 错误率 | SQL执行失败比例 | < 0.1% | > 1% |
| 连接池使用率 | 活跃连接占比 | < 70% | > 90% |

**TP99解释**：

```
通俗理解TP99：
如果100个用户访问：
- 99个用户响应时间在100ms内 ✅
- 1个用户可能慢一点也没关系

为什么关注TP99？
因为平均值会被极端值影响：
99次10ms + 1次1000ms = 平均19ms
看起来很快，实际有用户体验很差！
```

### 7.3 监控数据收集



```java
@Component
public class MetricsCollector {
    
    private final AtomicLong totalCount = new AtomicLong(0);
    private final AtomicLong errorCount = new AtomicLong(0);
    private final List<Long> responseTimes = new CopyOnWriteArrayList<>();
    
    public void record(long executeTime, boolean success) {
        totalCount.incrementAndGet();
        if (!success) {
            errorCount.incrementAndGet();
        }
        responseTimes.add(executeTime);
        
        // 定期清理旧数据（保留最近1000条）
        if (responseTimes.size() > 1000) {
            responseTimes.remove(0);
        }
    }
    
    public MetricsSnapshot getSnapshot() {
        List<Long> times = new ArrayList<>(responseTimes);
        Collections.sort(times);
        
        return MetricsSnapshot.builder()
            .totalCount(totalCount.get())
            .errorRate(errorCount.get() * 100.0 / totalCount.get())
            .avgTime(times.stream().mapToLong(Long::longValue).average().orElse(0))
            .tp99(getPercentile(times, 0.99))
            .tp95(getPercentile(times, 0.95))
            .maxTime(times.isEmpty() ? 0 : times.get(times.size() - 1))
            .build();
    }
    
    private long getPercentile(List<Long> sortedList, double percentile) {
        if (sortedList.isEmpty()) return 0;
        int index = (int) Math.ceil(sortedList.size() * percentile) - 1;
        return sortedList.get(Math.max(0, index));
    }
}
```

### 7.4 监控告警策略



**多级告警机制**：

```
告警级别设置：
🟢 正常 (avgTime < 100ms)
   → 无操作，继续监控

🟡 预警 (100ms ≤ avgTime < 200ms)  
   → 日志记录，关注趋势

🟠 告警 (200ms ≤ avgTime < 500ms)
   → 发送通知，准备优化

🔴 严重 (avgTime ≥ 500ms)
   → 紧急通知，立即处理
```

**告警通知实现**：

```java
@Service
public class AlertService {
    
    @Scheduled(fixedRate = 60000)  // 每分钟检查
    public void checkMetrics() {
        MetricsSnapshot snapshot = metricsCollector.getSnapshot();
        
        if (snapshot.getAvgTime() > 500) {
            sendAlert(AlertLevel.CRITICAL, 
                "严重告警：SQL平均响应时间" + snapshot.getAvgTime() + "ms");
        } else if (snapshot.getAvgTime() > 200) {
            sendAlert(AlertLevel.WARNING, 
                "性能告警：SQL响应时间偏高");
        }
        
        if (snapshot.getErrorRate() > 1.0) {
            sendAlert(AlertLevel.ERROR, 
                "错误率告警：当前错误率" + snapshot.getErrorRate() + "%");
        }
    }
    
    private void sendAlert(AlertLevel level, String message) {
        // 发送钉钉/企业微信/邮件通知
        log.warn("[{}] {}", level, message);
        // notificationService.send(message);
    }
}
```

---

## 8. 📋 核心要点总结



### 8.1 必须掌握的基本概念



```
🎯 SQL监控核心价值：
   - 发现问题：实时看到SQL执行情况
   - 定位瓶颈：找出慢查询和性能问题
   - 优化依据：提供数据支持决策
   
🔧 监控三大要素：
   - 日志记录：看到SQL和参数
   - 性能统计：知道快慢和趋势
   - 异常告警：问题及时通知
```

### 8.2 实战配置清单



**开发环境配置**：

```yaml
# 详细日志，便于调试

mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# 性能分析

performance:
  enabled: true
  max-time: 1000
```

**生产环境配置**：

```yaml
# 只记录慢查询

logging:
  level:
    com.example.mapper: warn
    
# 慢查询监控  

slow-query:
  threshold: 200
  alert: true
```

### 8.3 监控最佳实践



**监控配置建议**：

```
环境策略：
开发环境 → 全量日志 + 详细分析
测试环境 → 性能监控 + 压测
生产环境 → 慢查询 + 核心指标

关键原则：
✅ 分环境配置，避免生产环境日志爆炸
✅ 设置合理阈值，减少误报
✅ 关注核心指标，不要贪多
✅ 定期分析报告，持续优化
```

### 8.4 问题排查思路



**性能问题诊断流程**：

```
1. 发现问题
   └→ 监控告警：某个接口响应慢

2. 定位SQL
   └→ 查看日志：找到慢查询SQL

3. 分析原因  
   └→ 检查参数、结果集、执行计划

4. 优化方案
   ├→ 加索引
   ├→ 优化SQL
   ├→ 调整业务逻辑
   └→ 加缓存

5. 验证效果
   └→ 对比监控数据
```

### 8.5 新手避坑指南



**常见错误**：

| **错误** | **后果** | **正确做法** |
|---------|---------|------------|
| 生产环境开DEBUG日志 | 😵 日志爆炸，磁盘打满 | 只记录WARN及以上 |
| 不设置慢查询阈值 | 😕 无法发现性能问题 | 根据业务设置合理值 |
| 忽略参数监控 | 🐛 SQL注入风险 | 开启参数验证 |
| 不做定期分析 | 📉 问题积累恶化 | 每周查看监控报告 |

**监控检查清单**：

```
上线前检查：
☐ 是否配置了慢查询监控？
☐ 告警阈值是否合理？
☐ 日志级别是否正确？
☐ 是否有性能统计报告？

日常运维：
☐ 每天查看慢查询报告
☐ 每周分析性能趋势
☐ 定期优化TOP慢查询
☐ 关注告警并及时处理
```

---

# 💡 学习建议



**循序渐进学习路径**：

```
第一步：理解概念
- 知道什么是SQL监控
- 明白为什么需要监控

第二步：基础配置  
- 配置SQL日志输出
- 学会看懂日志信息

第三步：进阶监控
- 设置慢查询告警
- 收集性能指标

第四步：实战优化
- 根据监控数据优化SQL
- 建立监控体系
```

**实践建议**：

```
🎯 **动手练习**：
1. 在本地项目配置p6spy
2. 故意写一个慢查询，观察监控
3. 优化后对比监控数据

📊 **建立习惯**：
- 开发时随时查看SQL日志
- 发布前检查慢查询
- 定期分析性能报告
```

**核心记忆**：
- SQL监控是性能优化的眼睛
- 慢查询是性能问题的信号
- 监控数据是优化的依据
- 定期分析才能持续改进