---
title: 9、逻辑删除机制
---
## 📚 目录

1. [逻辑删除是什么](#1-逻辑删除是什么)
2. [@TableLogic注解详解](#2-tablelogic注解详解)
3. [逻辑删除工作机制](#3-逻辑删除工作机制)
4. [逻辑删除配置方案](#4-逻辑删除配置方案)
5. [物理删除使用场景](#5-物理删除使用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🤔 逻辑删除是什么


### 1.1 为什么需要逻辑删除


**现实场景理解**：
```
你在淘宝买东西，后来想查看以前的订单，但商家已经"删除"了商品
→ 如果是真删除，你的订单数据就乱了，找不到商品信息
→ 实际上商品只是"下架"了，数据还在，所以你能看到完整订单
```

这就是**逻辑删除**的核心思想：**数据不是真的删掉，只是打个标记说"我被删了"**

**对比理解**：

| 删除方式 | 物理删除 | 逻辑删除 |
|---------|---------|---------|
| **操作** | `DELETE FROM user WHERE id=1` | `UPDATE user SET deleted=1 WHERE id=1` |
| **数据** | 真的删掉，找不回来了 | 还在数据库，只是标记为删除状态 |
| **恢复** | ❌ 无法恢复（除非有备份） | ✅ 改回标记就能恢复 |
| **查询** | 查不到这条数据 | 默认过滤掉，需要时能查出来 |

### 1.2 逻辑删除的实际价值


**业务场景举例**：

```
📱 电商平台：
   用户删除收货地址 → 只是标记删除，订单记录还能看到地址
   
📝 内容管理系统：
   管理员删除文章 → 标记删除，可以恢复，有审计记录
   
💰 金融系统：
   删除交易记录 → 绝对不能真删，只能标记作废
```

**核心优势**：
- ✅ **数据安全**：误删可以恢复，不怕丢数据
- ✅ **关联完整**：其他表引用这条数据不会出错
- ✅ **审计追溯**：能查到谁删的，什么时候删的
- ✅ **业务需求**：很多业务要求保留历史数据

---

## 2. 🏷️ @TableLogic注解详解


### 2.1 基本用法


**最简单的使用方式**：
```java
@Data
@TableName("user")
public class User {
    private Long id;
    private String name;
    
    @TableLogic  // 就这一个注解，搞定逻辑删除！
    private Integer deleted;  // 0表示正常，1表示删除
}
```

**工作原理图示**：
```
没加@TableLogic之前：
    删除 → DELETE FROM user WHERE id=1
    ↓
    数据真的没了 ❌

加了@TableLogic之后：
    删除 → UPDATE user SET deleted=1 WHERE id=1
    ↓
    数据还在，只是标记为删除 ✅
```

### 2.2 注解属性配置


**@TableLogic的两个核心属性**：

```java
public class User {
    @TableLogic(
        value = "0",    // 未删除的值（正常状态）
        delval = "1"    // 已删除的值（删除状态）
    )
    private Integer deleted;
}
```

**属性含义**：
- `value`：表示**正常数据**的标记值（默认是0）
- `delval`：表示**已删除数据**的标记值（默认是1）

**常见的标记方式**：

```
方式1：数字标记（最常用）
    deleted: 0=正常  1=删除
    
方式2：状态标记
    status: 1=正常  0=删除
    
方式3：时间戳标记
    deleteTime: NULL=正常  具体时间=删除
```

### 2.3 字段类型选择


**三种常见的字段类型**：

> 💡 **推荐：Integer类型**
> ```java
> @TableLogic
> private Integer deleted;  // 0正常 1删除
> ```
> 优点：简单直观，占用空间小，索引效率高

> 📝 **备选：时间戳类型**
> ```java
> @TableLogic(value = "NULL", delval = "NOW()")
> private LocalDateTime deleteTime;  // NULL正常 有值=删除时间
> ```
> 优点：能记录删除时间，方便审计

> ⚠️ **不推荐：字符串类型**
> ```java
> @TableLogic
> private String deleted;  // "0"正常 "1"删除
> ```
> 缺点：占用空间大，索引效率低

---

## 3. ⚙️ 逻辑删除工作机制


### 3.1 删除操作的转换


**自动SQL转换过程**：

```
你写的代码：
    userMapper.deleteById(1L);
    
MyBatis-Plus做的事：
    第1步：检测到User实体有@TableLogic注解
    第2步：不执行DELETE语句
    第3步：转换成UPDATE语句
    第4步：执行 UPDATE user SET deleted=1 WHERE id=1
    
最终结果：
    数据库：id=1的记录，deleted字段从0变成1
    用户感知：调用删除方法，数据"消失"了
```

**操作流程图**：
```
调用删除方法
    ↓
检测实体类
    ↓
有@TableLogic? 
    ├─ 是 → 转换成UPDATE语句 → 标记为删除
    └─ 否 → 执行DELETE语句 → 真的删除
```

### 3.2 查询操作的过滤


**自动添加查询条件**：

```
你写的代码：
    List<User> users = userMapper.selectList(null);
    
MyBatis-Plus做的事：
    第1步：检测到User实体有@TableLogic注解
    第2步：自动在WHERE条件加上 deleted=0
    第3步：执行 SELECT * FROM user WHERE deleted=0
    
最终结果：
    只查出未删除的数据
    已删除的数据自动被过滤掉
```

**查询条件对比**：

| 查询类型 | 没有逻辑删除 | 有逻辑删除 |
|---------|------------|----------|
| **查全部** | `SELECT * FROM user` | `SELECT * FROM user WHERE deleted=0` |
| **按ID查** | `SELECT * FROM user WHERE id=1` | `SELECT * FROM user WHERE id=1 AND deleted=0` |
| **条件查询** | `SELECT * FROM user WHERE name='张三'` | `SELECT * FROM user WHERE name='张三' AND deleted=0` |

### 3.3 更新操作的影响


**逻辑删除对更新的影响**：

```java
// 场景：更新一个已经被逻辑删除的用户
User user = new User();
user.setId(1L);  // 这个用户已经被逻辑删除了（deleted=1）
user.setName("新名字");

userMapper.updateById(user);
// 执行的SQL：
// UPDATE user SET name='新名字' WHERE id=1 AND deleted=0
// 
// 结果：更新失败！因为deleted=1的数据被自动过滤了
```

**关键理解**：
- ✅ 逻辑删除的数据**不能被更新**
- ✅ 逻辑删除的数据**不能被查询**
- ✅ 想操作它，必须先"恢复"（把deleted改回0）

---

## 4. 🔧 逻辑删除配置方案


### 4.1 全局配置方式


**application.yml配置**：
```yaml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted  # 全局逻辑删除字段名
      logic-delete-value: 1        # 删除后的值
      logic-not-delete-value: 0    # 未删除的值
```

**配置后的效果**：
```
配置之前：
    每个实体类都要写 @TableLogic
    
配置之后：
    只要字段名叫 deleted，自动启用逻辑删除
    不用每个类都加注解了
```

### 4.2 注解配置与全局配置对比


**两种配置方式的优先级**：

```
┌─────────────────────────────────┐
│    优先级：注解 > 全局配置        │
├─────────────────────────────────┤
│                                 │
│  情况1：都没配置                 │
│    → 逻辑删除不生效              │
│                                 │
│  情况2：只配全局                 │
│    → 字段名匹配的自动生效         │
│                                 │
│  情况3：只配注解                 │
│    → 只有加注解的生效            │
│                                 │
│  情况4：都配了                   │
│    → 注解配置覆盖全局配置         │
│                                 │
└─────────────────────────────────┘
```

**实际使用建议**：

> 🎯 **推荐方案**：全局配置 + 个别注解
> ```yaml
> # application.yml - 全局配置
> mybatis-plus:
>   global-config:
>     db-config:
>       logic-delete-field: deleted
>       logic-delete-value: 1
>       logic-not-delete-value: 0
> ```
> ```java
> // 大部分表都用deleted字段，不用加注解
> public class User {
>     private Integer deleted;  // 自动生效
> }
> 
> // 个别表用特殊字段，加注解覆盖
> public class Order {
>     @TableLogic(value = "1", delval = "0")
>     private Integer status;  // 1正常 0删除
> }
> ```

### 4.3 数据库设计建议


**表结构设计示例**：
```sql
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50),
    deleted TINYINT DEFAULT 0,  -- 逻辑删除标记
    create_time DATETIME,
    update_time DATETIME,
    
    INDEX idx_deleted (deleted)  -- 重要：给deleted加索引！
);
```

**设计要点**：
- ✅ **默认值设为0**：新数据自动是"未删除"状态
- ✅ **建立索引**：查询时`WHERE deleted=0`能用到索引
- ✅ **字段类型**：用`TINYINT`或`INT`，不建议用`CHAR`
- ✅ **命名统一**：全公司统一用`deleted`或`del_flag`

---

## 5. 🗑️ 物理删除使用场景


### 5.1 什么时候必须物理删除


**需要真删除的场景**：

```
场景1：用户注销账号（法律要求）
    用户要求删除个人信息 → 必须真删，不能只标记
    示例：欧盟GDPR法规，用户有"被遗忘权"
    
场景2：测试数据清理
    开发/测试环境的脏数据 → 定期清理，不需要保留
    
场景3：临时数据过期
    验证码、临时token → 过期后没有保留价值
    
场景4：数据量优化
    10年前的日志数据 → 归档后物理删除，释放空间
```

### 5.2 如何实现物理删除


**方法1：使用原生SQL**
```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    
    // 自定义SQL，强制物理删除
    @Delete("DELETE FROM user WHERE id = #{id}")
    int physicalDeleteById(@Param("id") Long id);
}
```

**方法2：临时移除逻辑删除**
```java
// 方案A：使用原生Wrapper（不推荐，容易出错）
userMapper.delete(
    new QueryWrapper<User>()
        .eq("id", 1L)
        .last("AND 1=1")  // 绕过逻辑删除，但很危险！
);

// 方案B：直接用SQL（推荐）
@Delete("DELETE FROM user WHERE id = #{id}")
int realDelete(@Param("id") Long id);
```

**方法3：条件控制**
```java
public class UserService {
    
    // 逻辑删除（给用户用）
    public void deleteUser(Long id) {
        userMapper.deleteById(id);  // 自动转成UPDATE
    }
    
    // 物理删除（给管理员用）
    public void physicalDeleteUser(Long id) {
        userMapper.physicalDeleteById(id);  // 真的DELETE
    }
}
```

### 5.3 逻辑删除数据清理策略


**定期清理机制**：

```
步骤1：数据归档
    将deleted=1的旧数据，导出到历史库或文件
    
步骤2：物理删除
    删除已归档的数据，释放主库空间
    
步骤3：定期执行
    每月/每季度执行一次清理任务
```

**示例代码**：
```java
@Scheduled(cron = "0 0 2 1 * ?")  // 每月1号凌晨2点执行
public void cleanDeletedData() {
    // 1. 查出3个月前删除的数据
    List<User> oldDeleted = userMapper.selectList(
        new QueryWrapper<User>()
            .eq("deleted", 1)
            .lt("update_time", LocalDateTime.now().minusMonths(3))
    );
    
    // 2. 归档到历史表
    archiveToHistory(oldDeleted);
    
    // 3. 物理删除
    oldDeleted.forEach(user -> 
        userMapper.physicalDeleteById(user.getId())
    );
}
```

---

## 6. 📋 核心要点总结


### 6.1 逻辑删除核心理解


**一句话总结**：
> 逻辑删除就是"假装删除"，数据还在数据库，只是打个标记说它被删了

**工作流程**：
```
用户调用删除方法
    ↓
MyBatis-Plus检测到@TableLogic
    ↓
DELETE转换成UPDATE（把deleted改成1）
    ↓
以后查询自动加WHERE deleted=0
    ↓
用户看不到这条数据了（但数据还在）
```

### 6.2 配置方式选择


**推荐配置策略**：

| 场景 | 配置方式 | 说明 |
|------|---------|------|
| **统一规范** | 全局配置 | 所有表都用`deleted`字段，yml配一次搞定 |
| **个别特殊** | 注解配置 | 某个表用不同字段，加`@TableLogic`覆盖 |
| **灵活控制** | 混合使用 | 全局配置打底，特殊情况用注解 |

### 6.3 注意事项清单


> ⚠️ **重要提醒**
> 
> - ✅ 逻辑删除的数据**不能被更新**
> - ✅ 逻辑删除的数据**不能被查询**（除非手动指定）
> - ✅ `deleted`字段**必须加索引**，否则性能差
> - ✅ 外键关联要考虑**级联问题**
> - ✅ 定期清理**避免数据膨胀**

### 6.4 最佳实践建议


**数据库层面**：
```sql
-- ✅ 推荐的表结构
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50),
    deleted TINYINT DEFAULT 0,    -- 逻辑删除标记
    delete_time DATETIME,          -- 删除时间（可选）
    INDEX idx_deleted (deleted)    -- 必须加索引！
);
```

**代码层面**：
```java
// ✅ 推荐的实体配置
@Data
@TableName("user")
public class User {
    private Long id;
    private String name;
    
    @TableLogic  // 简单一个注解搞定
    private Integer deleted;
    
    @TableField(fill = FieldFill.UPDATE)
    private LocalDateTime deleteTime;  // 删除时自动填充
}
```

**业务层面**：
- 💾 **重要数据**：用逻辑删除，保证可恢复
- 🗑️ **临时数据**：用物理删除，节省空间  
- 📊 **审计需求**：逻辑删除 + 删除时间戳
- 🔄 **定期清理**：归档后物理删除旧数据

---

**核心记忆口诀**：
```
逻辑删除不是真删除，打个标记说删了
查询自动过滤删除数据，更新也会被拦截
@TableLogic一个注解，DELETE变UPDATE不操心
重要数据用逻辑删，临时数据物理删
```