---
title: 18、排序与分组聚合
---
## 📚 目录

1. [排序查询基础](#1-排序查询基础)
2. [分组查询详解](#2-分组查询详解)
3. [聚合函数应用](#3-聚合函数应用)
4. [高级查询技巧](#4-高级查询技巧)
5. [实战案例精讲](#5-实战案例精讲)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📊 排序查询基础


### 1.1 什么是排序查询


**💡 通俗理解**
```
就像你整理书架一样：
- 按书名A-Z排列 → 升序排序 (orderByAsc)
- 按出版时间新到旧 → 降序排序 (orderByDesc)
- 先按类型再按价格 → 多字段排序

MyBatis-Plus帮你自动生成SQL的ORDER BY语句
```

**🎯 核心概念**
- **升序(ASC)** - Ascending，从小到大、从A到Z
- **降序(DESC)** - Descending，从大到小、从Z到A
- **多字段排序** - 先按第一个条件排，相同时再按第二个条件排

### 1.2 升序排序 - orderByAsc


**📖 基本用法**

单字段升序：按年龄从小到大排序
```java
// 查询所有用户，按年龄升序排列
List<User> users = new LambdaQueryWrapper<User>()
    .orderByAsc(User::getAge)  // age ASC
    .list();

// 生成SQL: SELECT * FROM user ORDER BY age ASC
```

**⭐ 实际场景示例**

| 场景 | 代码示例 | 说明 |
|------|---------|------|
| `商品价格排序` | `.orderByAsc(Product::getPrice)` | 价格从低到高 |
| `文章发布时间` | `.orderByAsc(Article::getCreateTime)` | 最早的文章排前面 |
| `考试成绩排序` | `.orderByAsc(Score::getScore)` | 成绩从低到高 |

**💡 小贴士**：升序就是"数字变大"或"字母往后"的顺序

### 1.3 降序排序 - orderByDesc


**📖 基本用法**

单字段降序：按创建时间从新到旧排序
```java
// 查询文章列表，最新发布的排最前面
List<Article> articles = new LambdaQueryWrapper<Article>()
    .orderByDesc(Article::getCreateTime)  // create_time DESC
    .list();

// 生成SQL: SELECT * FROM article ORDER BY create_time DESC
```

**🎯 常见应用场景**

```
📱 微博热搜 → 按热度降序
🛒 商品销量榜 → 按销量降序
💰 收入排行榜 → 按收入降序
⏰ 最新消息 → 按时间降序
```

**❌ 新手易错点 vs ✅ 正确写法**

```java
// ❌ 错误：想要降序却写成了升序
.orderByAsc(User::getSalary)  // 工资从低到高❌

// ✅ 正确：工资排行榜应该用降序
.orderByDesc(User::getSalary)  // 工资从高到低✅
```

### 1.4 多字段排序


**📖 排序优先级理解**

```
想象一个班级成绩单：
1️⃣ 先按总分排序（主要条件）
2️⃣ 总分相同时按语文分数排序（次要条件）
3️⃣ 语文也相同时按数学分数排序（第三条件）

代码就是把这个逻辑翻译成链式调用
```

**💻 实战代码示例**

```java
// 场景：电商商品排序 - 先按销量降序，销量相同按价格升序
List<Product> products = new LambdaQueryWrapper<Product>()
    .orderByDesc(Product::getSales)    // 1️⃣ 销量高的优先
    .orderByAsc(Product::getPrice)     // 2️⃣ 销量相同时价格低的优先
    .list();

// 生成SQL: SELECT * FROM product ORDER BY sales DESC, price ASC
```

**📊 多字段排序效果对比表**

| 商品ID | 销量 | 价格 | 排序结果(销量↓价格↑) |
|--------|------|------|---------------------|
| `001` | `1000` | `99.9` | 第1名 ⭐ |
| `002` | `1000` | `199.9` | 第2名（销量相同，价格低优先）|
| `003` | `800` | `59.9` | 第3名 |
| `004` | `500` | `299.9` | 第4名 |

**🔥 复杂场景示例**

```java
// 企业员工排序：部门 → 级别 → 入职时间
List<Employee> employees = new LambdaQueryWrapper<Employee>()
    .orderByAsc(Employee::getDepartment)   // 1️⃣ 按部门升序
    .orderByDesc(Employee::getLevel)       // 2️⃣ 同部门按级别降序
    .orderByAsc(Employee::getHireDate)     // 3️⃣ 同级别按入职早晚升序
    .list();
```

---

## 2. 🔍 分组查询详解


### 2.1 什么是分组查询


**💡 生活化理解**

```
就像统计班级成绩：
原始数据：张三90分、李四85分、王五90分、赵六85分...

按分数分组后：
📌 90分组：张三、王五 (2人)
📌 85分组：李四、赵六 (2人)

这样就能快速知道每个分数段有多少人！
```

**📊 分组查询的本质**

```
数据仓库                           分组后
┌─────────────┐                   ┌─────────────┐
│ 商品A 分类A  │                   │ 分类A (3个)  │
│ 商品B 分类B  │   groupBy        │ 分类B (2个)  │
│ 商品C 分类A  │  ========>       │ 分类C (1个)  │
│ 商品D 分类A  │                   └─────────────┘
│ 商品E 分类B  │
│ 商品F 分类C  │
└─────────────┘
```

### 2.2 groupBy 分组基础


**📖 基本语法**

```java
// 场景：统计每个部门有多少员工
List<Map<String, Object>> result = new QueryWrapper<Employee>()
    .select("department, COUNT(*) as count")  // 选择字段
    .groupBy("department")                    // 按部门分组
    .list();

// 生成SQL: SELECT department, COUNT(*) as count 
//          FROM employee 
//          GROUP BY department
```

**🎯 查询结果展示**

```
[
  {department: "技术部", count: 15},
  {department: "销售部", count: 20},
  {department: "财务部", count: 8}
]
```

**⚠️ 重要规则**

```
分组查询的铁律：
✅ SELECT后面只能出现：
   - 分组字段本身
   - 聚合函数(COUNT、SUM、AVG等)
   
❌ 不能直接查询其他字段：
   SELECT name, department  ← 错误！name不是分组字段
   GROUP BY department
```

### 2.3 having 分组过滤


**💡 having vs where 的区别**

```
📍 where → 分组前过滤（过滤行）
   先筛选数据，再分组
   
📍 having → 分组后过滤（过滤组）
   先分组，再筛选分组结果

类比：
where  = 入场前检票（过滤不合格的人）
having = 组队后淘汰（过滤不合格的组）
```

**🔄 执行顺序图示**

```
原始数据
   ↓
WHERE过滤  ← 第1步：过滤单条记录
   ↓
GROUP BY   ← 第2步：分组
   ↓
HAVING过滤 ← 第3步：过滤分组结果
   ↓
最终结果
```

**💻 实战代码对比**

```java
// 场景：查询平均工资超过8000的部门

// ✅ 正确写法 - 用having
List<Map<String, Object>> depts = new QueryWrapper<Employee>()
    .select("department, AVG(salary) as avg_salary")
    .groupBy("department")
    .having("AVG(salary) > 8000")  // 分组后过滤
    .list();

// ❌ 错误写法 - 用where（语法错误）
// .where("AVG(salary) > 8000")  // WHERE里不能用聚合函数
```

**📊 having高级用法**

```java
// 复杂条件：部门人数≥5 且 平均年龄<35
new QueryWrapper<Employee>()
    .select("department, COUNT(*) as count, AVG(age) as avg_age")
    .groupBy("department")
    .having("COUNT(*) >= 5 AND AVG(age) < 35")
    .list();
```

**🎯 应用场景对照表**

| 需求 | 使用方式 | 示例 |
|------|---------|------|
| `筛选个人记录` | **WHERE** | `年龄>18的员工` |
| `筛选分组结果` | **HAVING** | `平均年龄>30的部门` |
| `组合使用` | **WHERE + HAVING** | `男性员工中，平均工资>1w的部门` |

---

## 3. 📈 聚合函数应用


### 3.1 常用聚合函数一览


**📊 五大核心聚合函数**

| 函数 | 中文含义 | 作用 | 示例场景 |
|------|---------|------|---------|
| `COUNT()` | **计数** | 统计记录数量 | 统计员工总数 |
| `SUM()` | **求和** | 数值相加 | 计算总销售额 |
| `AVG()` | **平均值** | 数值平均 | 计算平均工资 |
| `MAX()` | **最大值** | 找最大数 | 找最高分数 |
| `MIN()` | **最小值** | 找最小数 | 找最低价格 |

### 3.2 COUNT 计数统计


**💡 通俗理解**：数有多少个

```java
// 场景1：统计每个城市有多少用户
new QueryWrapper<User>()
    .select("city, COUNT(*) as user_count")
    .groupBy("city")
    .list();

// 场景2：统计每个分类的商品数量
new QueryWrapper<Product>()
    .select("category, COUNT(id) as product_count")
    .groupBy("category")
    .list();
```

**⚠️ COUNT(*) vs COUNT(字段) 区别**

```
COUNT(*)      → 统计所有行（包括NULL）
COUNT(字段)   → 统计该字段非NULL的行

示例数据：
id  name   age
1   张三   25
2   李四   NULL
3   王五   30

COUNT(*)     = 3  ← 3行数据
COUNT(age)   = 2  ← 只有2个非NULL的age
```

### 3.3 SUM 求和计算


**💡 通俗理解**：把数值加起来

```java
// 场景：统计每个部门的工资总和
new QueryWrapper<Employee>()
    .select("department, SUM(salary) as total_salary")
    .groupBy("department")
    .list();

// 实际结果示例：
// [
//   {department: "研发部", total_salary: 500000},
//   {department: "销售部", total_salary: 300000}
// ]
```

**🎯 常见应用场景**

```
💰 财务统计 → SUM(amount) 总金额
📦 库存统计 → SUM(quantity) 总数量
📊 流量统计 → SUM(views) 总浏览量
```

### 3.4 AVG 平均值计算


**💡 通俗理解**：算平均数

```java
// 场景：查询各班级的平均成绩
new QueryWrapper<Score>()
    .select("class_name, AVG(score) as avg_score")
    .groupBy("class_name")
    .having("AVG(score) >= 80")  // 只看平均分≥80的班级
    .list();
```

**🔢 AVG与四舍五入**

```java
// 保留2位小数的平均工资
new QueryWrapper<Employee>()
    .select("department, ROUND(AVG(salary), 2) as avg_salary")
    .groupBy("department")
    .list();
```

### 3.5 MAX/MIN 极值查询


**💡 通俗理解**：找最大/最小的那个

```java
// 场景：每个分类中价格最高和最低的商品
new QueryWrapper<Product>()
    .select("category, MAX(price) as max_price, MIN(price) as min_price")
    .groupBy("category")
    .list();

// 结果示例：
// [
//   {category: "手机", max_price: 8999, min_price: 999},
//   {category: "电脑", max_price: 15999, min_price: 3999}
// ]
```

**🎯 实战技巧：找出具体记录**

```java
// ❌ 常见误区：想同时查出最高价格和对应商品名
// 这样写是错误的！
.select("name, MAX(price)")  // 语法错误

// ✅ 正确做法：分两步查询
// 第1步：找出最高价格
Double maxPrice = new QueryWrapper<Product>()
    .select("MAX(price)")
    .one();

// 第2步：查询该价格的商品
Product product = new LambdaQueryWrapper<Product>()
    .eq(Product::getPrice, maxPrice)
    .one();
```

### 3.6 多聚合函数组合


**💻 综合统计示例**

```java
// 场景：部门全面统计报表
new QueryWrapper<Employee>()
    .select(
        "department",                    // 部门名称
        "COUNT(*) as count",             // 人数
        "AVG(salary) as avg_salary",     // 平均工资
        "MAX(salary) as max_salary",     // 最高工资
        "MIN(salary) as min_salary",     // 最低工资
        "SUM(salary) as total_salary"    // 工资总和
    )
    .groupBy("department")
    .having("COUNT(*) >= 3")  // 至少3人的部门
    .orderByDesc("avg_salary")  // 按平均工资降序
    .list();
```

**📊 统计结果展示**

| 部门 | 人数 | 平均工资 | 最高工资 | 最低工资 | 工资总和 |
|------|------|---------|---------|---------|---------|
| `研发部` | `15` | `12000` | `25000` | `8000` | `180000` |
| `销售部` | `20` | `10000` | `30000` | `6000` | `200000` |

---

## 4. 🚀 高级查询技巧


### 4.1 last 自定义SQL片段


**💡 什么是last**

```
last() 就是在SQL语句最后追加你自己写的SQL片段
主要用于MyBatis-Plus不支持的特殊语法
```

**⚠️ 使用警告**

```
🚨 安全风险：last()直接拼接SQL，可能导致SQL注入
🔒 使用原则：
   ✅ 只在可控的、固定的SQL片段中使用
   ❌ 绝不允许拼接用户输入的内容
```

**💻 安全用法示例**

```java
// ✅ 场景1：添加LIMIT限制（固定值，安全）
new LambdaQueryWrapper<User>()
    .orderByDesc(User::getCreateTime)
    .last("LIMIT 10");  // 最新10条记录

// ✅ 场景2：添加索引提示（固定语法，安全）
new QueryWrapper<Product>()
    .last("FORCE INDEX(idx_category)");

// ❌ 危险示例：拼接用户输入（SQL注入风险）
String userInput = request.getParameter("sort");  // 用户输入
.last("ORDER BY " + userInput);  // 危险！可能被注入恶意SQL
```

**🎯 last的典型应用**

```java
// 1️⃣ 排重查询
.last("GROUP BY user_id HAVING COUNT(*) > 1")

// 2️⃣ 分页优化
.last("LIMIT 0, 20")

// 3️⃣ 锁行查询
.last("FOR UPDATE")  // 悲观锁
```

### 4.2 排序+分组组合查询


**📖 组合查询的执行顺序**

```
1️⃣ WHERE   → 过滤数据
2️⃣ GROUP BY → 分组
3️⃣ HAVING  → 过滤分组
4️⃣ ORDER BY → 排序
5️⃣ LIMIT   → 限制数量
```

**💻 实战案例：销售榜单**

```java
// 需求：查询销量前5的商品分类，按总销量降序
List<Map<String, Object>> topCategories = new QueryWrapper<Product>()
    .select("category, SUM(sales) as total_sales")
    .groupBy("category")                      // 按分类分组
    .having("SUM(sales) > 1000")             // 总销量>1000
    .orderByDesc("total_sales")              // 按销量降序
    .last("LIMIT 5")                         // 只要前5
    .list();
```

**📊 查询链路图示**

```
原始商品表(1000条)
        ↓
WHERE过滤(不需要)
        ↓
GROUP BY category → 分组成10个分类
        ↓
HAVING总销量>1000 → 筛选出6个分类
        ↓
ORDER BY销量降序 → 排序6个分类
        ↓
LIMIT 5 → 取前5个分类
        ↓
最终结果(5条记录)
```

### 4.3 Lambda方式的分组统计


**💡 为什么用Lambda**

```
普通方式：.groupBy("department")  ← 字符串，容易拼写错误
Lambda方式：.groupBy("department") ← 等等，分组不支持Lambda？
```

**⚠️ 重要说明**

```
MyBatis-Plus的限制：
❌ LambdaQueryWrapper 不支持 groupBy
❌ 也不支持聚合函数的Lambda写法

✅ 只能用 QueryWrapper + 字符串字段名
```

**💻 正确的写法对照**

```java
// ❌ 错误：Lambda不支持分组
new LambdaQueryWrapper<User>()
    .groupBy(User::getDepartment)  // 编译错误！

// ✅ 正确：用QueryWrapper
new QueryWrapper<User>()
    .select("department, COUNT(*) as count")
    .groupBy("department");  // 字符串形式
```

**🔧 规避字段名错误的技巧**

```java
// 技巧：用实体类的表字段常量
public class User {
    public static final String DEPARTMENT = "department";
    public static final String AGE = "age";
}

// 使用常量避免拼写错误
new QueryWrapper<User>()
    .groupBy(User.DEPARTMENT);  // 有IDE提示，不易出错
```

### 4.4 复杂统计查询实战


**💻 案例：电商多维度销售分析**

```java
// 需求：按地区统计订单情况，只看订单量≥100的地区
List<Map<String, Object>> regionStats = new QueryWrapper<Order>()
    .select(
        "region",                          // 地区
        "COUNT(*) as order_count",        // 订单数
        "SUM(amount) as total_amount",    // 总金额
        "AVG(amount) as avg_amount",      // 平均金额
        "MAX(amount) as max_amount"       // 最大金额
    )
    .ge("create_time", "2024-01-01")     // 2024年的数据
    .groupBy("region")                    // 按地区分组
    .having("COUNT(*) >= 100")           // 订单量≥100
    .orderByDesc("total_amount")         // 按总金额降序
    .last("LIMIT 10");                   // 前10名

// 执行后返回：
// [
//   {region: "华东", order_count: 5000, total_amount: 8000000, ...},
//   {region: "华南", order_count: 3000, total_amount: 5000000, ...}
// ]
```

---

## 5. 🎯 实战案例精讲


### 5.1 案例一：学生成绩统计系统


**📚 需求描述**
```
统计每个班级的成绩情况：
- 平均分、最高分、最低分
- 只显示平均分≥80的班级
- 按平均分降序排列
```

**💻 完整代码实现**

```java
@Service
public class ScoreService {
    
    @Autowired
    private ScoreMapper scoreMapper;
    
    // 班级成绩统计
    public List<Map<String, Object>> getClassStats() {
        return new QueryWrapper<Score>()
            .select(
                "class_name",
                "AVG(score) as avg_score",
                "MAX(score) as max_score",
                "MIN(score) as min_score",
                "COUNT(*) as student_count"
            )
            .groupBy("class_name")
            .having("AVG(score) >= 80")
            .orderByDesc("avg_score")
            .list(scoreMapper::selectMaps);
    }
}
```

**📊 返回结果示例**

```json
[
  {
    "class_name": "高三1班",
    "avg_score": 92.5,
    "max_score": 100,
    "min_score": 85,
    "student_count": 45
  },
  {
    "class_name": "高三2班",
    "avg_score": 88.3,
    "max_score": 98,
    "min_score": 78,
    "student_count": 43
  }
]
```

### 5.2 案例二：商品销售排行榜


**🛒 需求描述**
```
电商平台商品排行：
- 按分类统计总销量
- 显示销量前10的分类
- 同时显示该分类的商品数量
```

**💻 代码实现**

```java
@Service
public class ProductService {
    
    // 分类销量排行榜
    public List<CategorySalesVO> getCategorySalesRank() {
        List<Map<String, Object>> list = new QueryWrapper<Product>()
            .select(
                "category",
                "SUM(sales) as total_sales",
                "COUNT(*) as product_count",
                "AVG(price) as avg_price"
            )
            .groupBy("category")
            .orderByDesc("total_sales")
            .last("LIMIT 10")
            .list(productMapper::selectMaps);
        
        // 转换为VO对象（建议方式）
        return list.stream()
            .map(this::mapToVO)
            .collect(Collectors.toList());
    }
    
    private CategorySalesVO mapToVO(Map<String, Object> map) {
        CategorySalesVO vo = new CategorySalesVO();
        vo.setCategory((String) map.get("category"));
        vo.setTotalSales((Long) map.get("total_sales"));
        vo.setProductCount((Long) map.get("product_count"));
        vo.setAvgPrice((Double) map.get("avg_price"));
        return vo;
    }
}
```

**🎯 关键知识点**
- `Map转VO对象` - 提高代码可维护性
- `Stream流处理` - 优雅的数据转换
- `LIMIT限制` - 只取Top N数据

### 5.3 案例三：用户活跃度分析


**👥 需求描述**
```
分析用户登录活跃度：
- 按年龄段分组（<18, 18-30, 30-50, >50）
- 统计每个年龄段的用户数和平均登录次数
- 找出最活跃的年龄段
```

**💻 SQL实现思路**

```java
public List<Map<String, Object>> getUserActivityByAge() {
    return new QueryWrapper<User>()
        .select(
            // CASE WHEN实现年龄分段
            "CASE " +
            "  WHEN age < 18 THEN '未成年' " +
            "  WHEN age BETWEEN 18 AND 30 THEN '青年' " +
            "  WHEN age BETWEEN 30 AND 50 THEN '中年' " +
            "  ELSE '老年' " +
            "END as age_group",
            "COUNT(*) as user_count",
            "AVG(login_count) as avg_login"
        )
        .groupBy("age_group")
        .orderByDesc("avg_login")
        .list(userMapper::selectMaps);
}
```

**📈 结果可视化**

```
年龄段    用户数    平均登录次数
━━━━━━━━━━━━━━━━━━━━━━━━━
青年      5000     ████████░░ 85次
中年      3000     ██████░░░░ 62次
未成年    1200     ████░░░░░░ 43次
老年       500     ██░░░░░░░░ 25次
```

### 5.4 案例四：部门工资分析报表


**💼 需求描述**
```
HR部门统计需求：
- 各部门工资总览
- 标注高于平均工资的部门
- 按工资总额排序
```

**💻 高级查询实现**

```java
public List<DeptSalaryVO> getDeptSalaryReport() {
    // 1️⃣ 先计算全公司平均工资
    Double companyAvgSalary = new QueryWrapper<Employee>()
        .select("AVG(salary)")
        .one(employeeMapper::selectObjs)
        .get(0);
    
    // 2️⃣ 查询各部门统计数据
    List<Map<String, Object>> deptStats = new QueryWrapper<Employee>()
        .select(
            "department",
            "COUNT(*) as emp_count",
            "AVG(salary) as avg_salary",
            "SUM(salary) as total_salary",
            "MAX(salary) - MIN(salary) as salary_gap"  // 工资差距
        )
        .groupBy("department")
        .having("COUNT(*) >= 3")  // 至少3人
        .orderByDesc("total_salary")
        .list(employeeMapper::selectMaps);
    
    // 3️⃣ 标注高于平均工资的部门
    return deptStats.stream()
        .map(map -> {
            DeptSalaryVO vo = new DeptSalaryVO();
            vo.setDepartment((String) map.get("department"));
            vo.setAvgSalary((Double) map.get("avg_salary"));
            vo.setAboveAverage(vo.getAvgSalary() > companyAvgSalary);
            return vo;
        })
        .collect(Collectors.toList());
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 排序查询**
```
✅ orderByAsc  → 升序排序（小→大）
✅ orderByDesc → 降序排序（大→小）
✅ 多字段排序 → 链式调用，先写的优先级高
```

**🔸 分组查询**
```
✅ groupBy     → 按字段分组
✅ having      → 分组后过滤（区别于where）
✅ 聚合函数    → COUNT/SUM/AVG/MAX/MIN
```

**🔸 执行顺序**
```
WHERE → GROUP BY → HAVING → ORDER BY → LIMIT
```

### 6.2 新手必知的关键点


**💡 排序易错点**

| 错误示例 | 正确写法 | 说明 |
|---------|---------|------|
| `❌ .order("age", true)` | `✅ .orderByAsc(User::getAge)` | 用Lambda更安全 |
| `❌ 先排序后分组` | `✅ 先分组后排序` | 注意执行顺序 |
| `❌ 忘记指定排序方向` | `✅ 明确Asc或Desc` | 默认升序但要明确写 |

**💡 分组易错点**

```
❌ 错误1：SELECT里查询非分组字段
SELECT name, department  -- name不是分组字段❌
GROUP BY department

✅ 正确：只查询分组字段或聚合函数
SELECT department, COUNT(*)  ✅
GROUP BY department

❌ 错误2：WHERE里用聚合函数
WHERE COUNT(*) > 5  -- 语法错误❌

✅ 正确：用HAVING
HAVING COUNT(*) > 5  ✅
```

**💡 聚合函数注意事项**

```
🔸 COUNT(*) vs COUNT(字段)
   COUNT(*)    → 统计所有行
   COUNT(字段) → 统计非NULL行

🔸 聚合函数自动忽略NULL值
   AVG(score) → 只计算非NULL的平均值

🔸 聚合函数不能直接在WHERE中使用
   WHERE AVG(age) > 30  ❌
   HAVING AVG(age) > 30 ✅
```

### 6.3 实战开发建议


**🎯 性能优化建议**

```
1️⃣ 分组字段建索引
   .groupBy("department")  
   → department字段要有索引

2️⃣ 避免SELECT *
   .select("department, COUNT(*)")  
   → 只查需要的字段

3️⃣ 合理使用LIMIT
   .last("LIMIT 100")
   → 避免查询海量数据

4️⃣ 复杂统计考虑缓存
   → Redis缓存统计结果
```

**🔒 安全注意事项**

```
🚨 last()方法的SQL注入风险：

❌ 危险：拼接用户输入
String input = request.getParameter("sort");
.last("ORDER BY " + input)  // 可能被注入

✅ 安全：使用固定SQL或参数化
.last("ORDER BY create_time DESC")
.orderByDesc(User::getCreateTime)
```

**📝 代码规范建议**

```java
// ✅ 推荐：清晰的链式调用格式
List<User> users = new LambdaQueryWrapper<User>()
    .eq(User::getStatus, 1)          // 条件1
    .ge(User::getAge, 18)            // 条件2
    .orderByDesc(User::getCreateTime) // 排序
    .last("LIMIT 10")                // 限制
    .list();

// ❌ 不推荐：一行写完，难以阅读
List<User> users = new LambdaQueryWrapper<User>().eq(User::getStatus, 1).ge(User::getAge, 18).orderByDesc(User::getCreateTime).last("LIMIT 10").list();
```

### 6.4 学习进阶路线


```
📚 基础掌握（当前阶段）
   ├─ 单字段排序
   ├─ 简单分组统计
   └─ 基础聚合函数

📚 进阶应用
   ├─ 多字段组合排序
   ├─ 复杂分组条件
   ├─ 多聚合函数组合
   └─ 子查询与JOIN

📚 高级优化
   ├─ 性能调优
   ├─ 索引优化
   └─ 分库分表场景
```

**核心记忆口诀**：
```
排序分组要分清，先分组来后排序
WHERE过滤在分前，HAVING过滤在分后
聚合函数五兄弟，COUNT SUM AVG MAX MIN
Lambda不支持分组，QueryWrapper字符串
last追加需谨慎，SQL注入要防范
```