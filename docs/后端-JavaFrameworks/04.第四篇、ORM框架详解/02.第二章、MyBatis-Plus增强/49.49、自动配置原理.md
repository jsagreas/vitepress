---
title: 49、自动配置原理
---
## 📚 目录

1. [什么是自动配置](#1-什么是自动配置)
2. [MybatisPlusAutoConfiguration核心类](#2-MybatisPlusAutoConfiguration核心类)
3. [自动装配机制详解](#3-自动装配机制详解)
4. [条件注解的应用](#4-条件注解的应用)
5. [配置属性绑定机制](#5-配置属性绑定机制)
6. [Bean创建时机与顺序](#6-Bean创建时机与顺序)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 什么是自动配置


### 1.1 自动配置的本质理解


**🔸 通俗解释**
```
想象你去餐厅吃饭：
传统方式：你要自己准备碗筷、调料、餐巾纸（手动配置Bean）
自动配置：餐厅自动帮你准备好所有餐具（Spring Boot自动配置）

只要你点了菜（添加依赖），服务员就自动准备好一切！
```

**💡 专业定义**
- **自动配置**：Spring Boot根据项目依赖和配置，自动创建和注入所需的Bean
- **核心价值**：减少重复配置代码，让开发者专注业务逻辑
- **实现原理**：通过条件注解判断是否需要某个配置，满足条件就自动生效

### 1.2 MyBatis-Plus的自动配置位置


**📂 自动配置文件结构**
```
mybatis-plus-boot-starter
    └── spring.factories           ← 自动配置的入口文件
            ↓
    MybatisPlusAutoConfiguration   ← 核心自动配置类
            ↓
    自动创建这些Bean：
    ├── SqlSessionFactory          ← MyBatis核心工厂
    ├── SqlSessionTemplate         ← 线程安全的SqlSession
    ├── MapperScannerConfigurer    ← Mapper接口扫描器
    └── MybatisPlusInterceptor     ← 插件拦截器
```

**🔍 工作流程图示**
```
应用启动
    ↓
Spring Boot扫描spring.factories文件
    ↓
发现MybatisPlusAutoConfiguration
    ↓
检查条件注解（是否有DataSource等）
    ↓
条件满足 → 执行自动配置
    ↓
创建SqlSessionFactory等Bean
    ↓
注入到Spring容器
    ↓
可以直接使用@Autowired注入
```

---

## 2. 🔧 MybatisPlusAutoConfiguration核心类


### 2.1 核心配置类结构


**📋 类定义分析**
```java
@Configuration  // ← 标记这是一个配置类
@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})
// ↑ 条件注解：只有这些类存在时才生效（防止没引入MyBatis依赖就配置）

@ConditionalOnSingleCandidate(DataSource.class)
// ↑ 条件：容器中必须有唯一的DataSource（数据源）

@EnableConfigurationProperties(MybatisPlusProperties.class)
// ↑ 启用配置属性类，读取application.yml中的配置

@AutoConfigureAfter({DataSourceAutoConfiguration.class})
// ↑ 在数据源自动配置之后执行（保证有数据源再配置MyBatis）

public class MybatisPlusAutoConfiguration {
    // 自动配置的核心逻辑
}
```

**🔑 关键点解读**

| 注解 | 作用 | 通俗理解 |
|-----|------|---------|
| `@Configuration` | 声明配置类 | 告诉Spring这是个配置中心 |
| `@ConditionalOnClass` | 类存在时生效 | 只有引入了MyBatis才配置 |
| `@ConditionalOnSingleCandidate` | Bean唯一时生效 | 必须有且只有一个数据源 |
| `@EnableConfigurationProperties` | 绑定配置文件 | 读取yml配置到Java对象 |
| `@AutoConfigureAfter` | 控制配置顺序 | 等数据源配置好再执行 |

### 2.2 核心Bean的创建


**🏗️ SqlSessionFactory创建过程**
```java
@Bean
@ConditionalOnMissingBean  // ← 只有容器中没有时才创建
public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
    
    // 第1步：创建工厂Bean
    MybatisSqlSessionFactoryBean factory = new MybatisSqlSessionFactoryBean();
    
    // 第2步：设置数据源
    factory.setDataSource(dataSource);
    
    // 第3步：设置配置信息
    factory.setConfiguration(configuration);
    
    // 第4步：设置插件（分页、乐观锁等）
    factory.setPlugins(interceptors);
    
    // 第5步：设置Mapper位置
    factory.setMapperLocations(resolveMapperLocations());
    
    // 第6步：返回创建好的工厂
    return factory.getObject();
}
```

**💡 创建逻辑说明**
```
为什么需要SqlSessionFactory？
    ↓
SqlSessionFactory是MyBatis的核心
    ↓
它负责创建SqlSession（操作数据库的会话）
    ↓
相当于数据库操作的"总工厂"
    ↓
所有Mapper接口的方法调用都依赖它
```

---

## 3. ⚙️ 自动装配机制详解


### 3.1 Spring Boot自动装配流程


**📊 装配流程图**
```
应用启动 @SpringBootApplication
    ↓
@EnableAutoConfiguration 注解生效
    ↓
AutoConfigurationImportSelector 选择器启动
    ↓
读取 META-INF/spring.factories 文件
    ↓
加载所有自动配置类列表
    ↓
过滤：根据条件注解判断是否需要
    ↓
创建配置类实例
    ↓
执行配置类中的@Bean方法
    ↓
将Bean注册到Spring容器
```

### 3.2 spring.factories文件解析


**📄 文件内容示例**
```properties
# 自动配置类的注册入口
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.baomidou.mybatisplus.autoconfigure.MybatisPlusAutoConfiguration
```

**🔍 工作原理**
```
这个文件的作用：
1. 告诉Spring Boot有哪些自动配置类
2. Spring Boot启动时会扫描所有jar包的这个文件
3. 把所有配置类收集起来
4. 根据条件注解决定是否启用

相当于：
一个"配置菜单"，Spring Boot启动时翻阅菜单
看到"MyBatis-Plus配置"这道菜
检查材料（条件）是否齐全
材料齐全就"做这道菜"（执行配置）
```

### 3.3 自动装配的触发时机


**⏰ 时间轴说明**
```
应用启动阶段：
T1: 启动类main方法执行
    ↓
T2: Spring Boot开始初始化
    ↓
T3: 扫描@SpringBootApplication注解
    ↓
T4: 触发@EnableAutoConfiguration
    ↓
T5: 加载spring.factories文件
    ↓
T6: 实例化MybatisPlusAutoConfiguration
    ↓
T7: 执行配置类中的@Bean方法
    ↓
T8: SqlSessionFactory等Bean创建完成
    ↓
T9: 可以注入使用了
```

---

## 4. 🎯 条件注解的应用


### 4.1 常用条件注解详解


**📋 条件注解对照表**

| 条件注解 | 生效条件 | 实际案例 | 通俗理解 |
|---------|---------|---------|---------|
| `@ConditionalOnClass` | 类路径存在指定类 | `@ConditionalOnClass(SqlSessionFactory.class)` | 引入了MyBatis依赖才配置 |
| `@ConditionalOnMissingBean` | 容器中没有指定Bean | `@ConditionalOnMissingBean(SqlSessionFactory.class)` | 用户没自己配置就用默认的 |
| `@ConditionalOnBean` | 容器中有指定Bean | `@ConditionalOnBean(DataSource.class)` | 有数据源才配置MyBatis |
| `@ConditionalOnProperty` | 配置文件有指定属性 | `@ConditionalOnProperty("mybatis-plus.enabled")` | 配置开启才生效 |
| `@ConditionalOnSingleCandidate` | 只有一个候选Bean | `@ConditionalOnSingleCandidate(DataSource.class)` | 只有一个数据源才配置 |

### 4.2 条件注解的组合使用


**🔸 实际配置案例**
```java
@Bean
@ConditionalOnMissingBean  // 条件1: 用户没自定义
@ConditionalOnProperty(    // 条件2: 配置文件开启
    prefix = "mybatis-plus",
    name = "enabled",
    havingValue = "true",
    matchIfMissing = true  // 不配置默认true
)
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
    // 添加分页插件
    interceptor.addInnerInterceptor(new PaginationInnerInterceptor());
    return interceptor;
}
```

**💡 条件判断逻辑**
```
判断流程：
1. 检查容器中是否已有MybatisPlusInterceptor
   有 → 不创建（尊重用户配置）
   没有 → 继续检查
   
2. 检查配置文件mybatis-plus.enabled
   配置为true → 创建
   配置为false → 不创建
   没配置 → 创建（matchIfMissing=true）

结果：
✅ 既尊重用户自定义配置
✅ 又提供合理的默认配置
```

### 4.3 条件注解的实战价值


**🎯 解决的问题**

> 💡 **智能配置**
> 根据项目实际情况自动决定配置内容，避免"一刀切"

**场景1：多数据源环境**
```
问题：项目有多个数据源，不能自动选择
解决：@ConditionalOnSingleCandidate检测
     ↓
只有一个数据源 → 自动配置
有多个数据源 → 不自动配置（需要用户明确指定）
```

**场景2：用户自定义优先**
```
问题：用户可能有特殊的SqlSessionFactory配置
解决：@ConditionalOnMissingBean检测
     ↓
用户配置了 → 使用用户的
用户没配置 → 使用自动配置的
```

---

## 5. 🔗 配置属性绑定机制


### 5.1 配置属性类MybatisPlusProperties


**📋 属性类结构**
```java
@ConfigurationProperties(prefix = "mybatis-plus")
// ↑ 绑定前缀：读取application.yml中mybatis-plus开头的配置

public class MybatisPlusProperties {
    
    // 映射文件位置
    private String[] mapperLocations = new String[]{"classpath*:/mapper/**/*.xml"};
    
    // 类型别名包
    private String typeAliasesPackage;
    
    // 配置文件位置
    private String configLocation;
    
    // 全局配置
    private GlobalConfig globalConfig = new GlobalConfig();
    
    // 原生配置
    private Configuration configuration;
    
    // getter/setter方法...
}
```

**🔍 配置绑定过程**
```
application.yml配置：
mybatis-plus:
  mapper-locations: classpath*:/mapper/**/*.xml
  type-aliases-package: com.example.entity
  global-config:
    db-config:
      id-type: auto
      logic-delete-value: 1
      logic-not-delete-value: 0

    ↓ Spring Boot自动绑定

MybatisPlusProperties对象：
mapperLocations = ["classpath*:/mapper/**/*.xml"]
typeAliasesPackage = "com.example.entity"
globalConfig.dbConfig.idType = AUTO
globalConfig.dbConfig.logicDeleteValue = "1"
...
```

### 5.2 配置属性的使用


**🔧 在自动配置类中使用**
```java
@Configuration
@EnableConfigurationProperties(MybatisPlusProperties.class)
// ↑ 启用属性类，Spring会自动创建并注入

public class MybatisPlusAutoConfiguration {
    
    // 直接注入配置对象
    private final MybatisPlusProperties properties;
    
    public MybatisPlusAutoConfiguration(MybatisPlusProperties properties) {
        this.properties = properties;
    }
    
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
        MybatisSqlSessionFactoryBean factory = new MybatisSqlSessionFactoryBean();
        
        // 使用配置属性
        factory.setMapperLocations(
            resolveMapperLocations(properties.getMapperLocations())
        );
        
        factory.setTypeAliasesPackage(
            properties.getTypeAliasesPackage()
        );
        
        // 应用全局配置
        factory.setGlobalConfig(properties.getGlobalConfig());
        
        return factory.getObject();
    }
}
```

### 5.3 配置优先级机制


**⚖️ 优先级顺序**
```
配置生效优先级（从高到低）：

1️⃣ Java代码中的@Bean配置
   用户自定义的SqlSessionFactory
        ↓ 优先级最高
        
2️⃣ application.yml配置文件
   mybatis-plus.xxx的配置
        ↓ 次高优先级
        
3️⃣ 默认配置
   MybatisPlusProperties的默认值
        ↓ 最低优先级（兜底方案）
```

**💡 实际案例**
```yaml
# application.yml
mybatis-plus:
  mapper-locations: classpath*:/custom/**/*.xml  # 自定义路径
  global-config:
    db-config:
      id-type: assign_id  # 自定义主键策略
```

```
配置应用过程：
1. Spring读取yml配置到MybatisPlusProperties
2. 发现mapper-locations有配置 → 使用custom/**/*.xml
3. 发现id-type有配置 → 使用ASSIGN_ID
4. logic-delete-value没配置 → 使用默认值1

最终效果：
✅ 自定义配置生效
✅ 未配置项使用默认值
✅ 配置灵活又安全
```

---

## 6. ⏱️ Bean创建时机与顺序


### 6.1 依赖注入顺序控制


**📊 自动配置顺序图**
```
Spring Boot启动
    ↓
DataSourceAutoConfiguration（数据源配置）
    ↓ @AutoConfigureAfter控制顺序
MybatisPlusAutoConfiguration（MyBatis-Plus配置）
    ↓ 依赖关系
SqlSessionFactory Bean创建
    ↓
MapperScannerConfigurer Bean创建
    ↓
扫描Mapper接口并创建代理对象
    ↓
可以在Service中注入Mapper
```

**🔸 顺序注解详解**

| 注解 | 作用 | 案例 |
|-----|------|-----|
| `@AutoConfigureAfter` | 在指定配置之后执行 | 在DataSource配置后执行 |
| `@AutoConfigureBefore` | 在指定配置之前执行 | 在某些依赖配置前执行 |
| `@AutoConfigureOrder` | 指定配置顺序数值 | 值越小越先执行 |
| `@DependsOn` | Bean依赖关系 | 确保依赖Bean先创建 |

### 6.2 Bean创建的生命周期


**🔄 完整生命周期流程**
```
阶段1: 实例化
    ↓
new MybatisSqlSessionFactoryBean()
创建对象实例

阶段2: 属性赋值
    ↓
setDataSource(dataSource)
setConfiguration(config)
注入依赖属性

阶段3: 初始化前处理
    ↓
BeanPostProcessor.postProcessBeforeInitialization()
执行前置处理器

阶段4: 初始化
    ↓
afterPropertiesSet() / @PostConstruct方法
执行初始化逻辑

阶段5: 初始化后处理
    ↓
BeanPostProcessor.postProcessAfterInitialization()
执行后置处理器（AOP代理在这里创建）

阶段6: Bean可用
    ↓
注册到Spring容器
可以被@Autowired注入使用

阶段7: 销毁
    ↓
destroy() / @PreDestroy方法
应用关闭时清理资源
```

### 6.3 Bean创建时机的实战影响


**⚠️ 常见问题与解决**

**问题1：循环依赖**
```
场景：
ServiceA依赖ServiceB
ServiceB依赖ServiceA
    ↓
Spring无法决定先创建谁
    ↓
抛出循环依赖异常

解决方案：
1. 使用@Lazy延迟加载
2. 重构代码，消除循环依赖
3. 使用@DependsOn明确依赖顺序
```

**问题2：Bean创建顺序错误**
```
问题：在Mapper还没创建时就注入使用
错误信息：
    ↓
NoSuchBeanDefinitionException: No qualifying bean of type 'UserMapper'

原因分析：
    ↓
MapperScannerConfigurer还未执行
Mapper接口代理对象未创建

解决：
    ↓
确保在@PostConstruct或InitializingBean中使用
或者使用@DependsOn("sqlSessionFactory")
```

**问题3：配置覆盖失效**
```
场景：自定义配置没生效
mybatis-plus:
  mapper-locations: classpath*:/custom/**/*.xml

原因：
    ↓
自定义Bean创建时机晚于自动配置

解决：
    ↓
使用@Primary标记自定义Bean优先级
或者在@Bean方法上加@ConditionalOnMissingBean
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 自动配置本质：Spring Boot根据条件自动创建Bean
🔸 核心配置类：MybatisPlusAutoConfiguration负责所有配置
🔸 条件注解：控制配置是否生效的关键机制
🔸 配置绑定：yml配置自动映射到Java对象
🔸 创建顺序：@AutoConfigureAfter控制配置执行顺序
🔸 Bean生命周期：从实例化到销毁的完整过程
```

### 7.2 关键理解要点


**🔹 自动配置的智能性**
```
为什么叫"自动"？
    ↓
1. 自动检测：有MyBatis依赖就配置
2. 自动创建：需要的Bean全自动创建
3. 自动注入：依赖关系自动处理
4. 自动适配：根据环境选择配置

核心价值：
✅ 零配置启动（默认配置）
✅ 配置简化（yml配置即可）
✅ 智能判断（条件注解）
✅ 用户可控（自定义优先）
```

**🔹 条件注解的作用**
```
没有条件注解会怎样？
    ↓
所有配置都会执行
即使环境不满足也创建Bean
导致启动失败或冲突

有了条件注解：
    ↓
环境检查 → 条件满足 → 执行配置
环境检查 → 条件不满足 → 跳过配置
保证配置安全、灵活、智能
```

**🔹 配置优先级的意义**
```
优先级机制的价值：
1. 用户配置优先 → 尊重定制需求
2. 默认配置兜底 → 保证开箱即用
3. 环境自适应 → 根据实际情况调整

实战建议：
• 开发环境：使用默认配置快速启动
• 测试环境：yml配置覆盖部分参数
• 生产环境：Java代码精确控制配置
```

### 7.3 实际应用价值


**💼 在项目中的应用**

**场景1：快速集成MyBatis-Plus**
```
1. 添加依赖
2. 配置数据源
3. 启动项目
   ↓
自动配置完成：
✅ SqlSessionFactory创建
✅ Mapper扫描完成
✅ 插件自动加载
✅ 直接使用BaseMapper
```

**场景2：多数据源配置**
```
自动配置只处理单数据源
检测到多个DataSource → 不自动配置
    ↓
需要手动配置：
@Bean("db1SqlSessionFactory")
public SqlSessionFactory db1Factory(@Qualifier("db1") DataSource ds) {
    // 手动配置第一个数据源
}

@Bean("db2SqlSessionFactory")
public SqlSessionFactory db2Factory(@Qualifier("db2") DataSource ds) {
    // 手动配置第二个数据源
}
```

**场景3：自定义插件加载**
```yaml
# application.yml
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

```java
// 自动配置会读取这个配置
// 创建SqlSessionFactory时应用
// 无需手动编写配置代码
```

### 7.4 学习路径建议


**📚 掌握步骤**
```
第1步：理解自动配置概念
     ↓ 知道"自动"是什么意思
     
第2步：掌握条件注解
     ↓ 理解配置生效条件
     
第3步：熟悉配置属性
     ↓ 会用yml配置MyBatis-Plus
     
第4步：了解Bean创建顺序
     ↓ 避免依赖注入问题
     
第5步：实践自定义配置
     ↓ 覆盖默认配置满足需求
```

**🎯 核心记忆口诀**
```
条件注解把好关，环境满足才配置
配置绑定连yml，属性自动来映射
Bean的顺序有讲究，先后依赖要清楚
自动配置虽智能，自定义配置更优先
```

**🔑 关键点速记**
- `@ConditionalOnClass` → 类存在才配置
- `@ConditionalOnMissingBean` → 没有才创建（用户优先）
- `@EnableConfigurationProperties` → 绑定yml配置
- `@AutoConfigureAfter` → 控制配置顺序
- `spring.factories` → 自动配置入口文件

---

> 💡 **学习提示**
> 自动配置是Spring Boot的核心特性，MyBatis-Plus充分利用了这个机制。理解自动配置原理，不仅能用好MyBatis-Plus，还能应用到其他Spring Boot项目中。建议结合实际项目调试，观察Bean的创建过程，加深理解！