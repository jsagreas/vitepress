---
title: 17、逻辑条件组合
---
## 📚 目录

1. [条件组合基础概念](#1-条件组合基础概念)
2. [AND逻辑与条件](#2-AND逻辑与条件)
3. [OR逻辑或条件](#3-OR逻辑或条件)
4. [嵌套条件与分组](#4-嵌套条件与分组)
5. [复杂查询逻辑实战](#5-复杂查询逻辑实战)
6. [条件优先级控制](#6-条件优先级控制)
7. [动态条件判断](#7-动态条件判断)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 条件组合基础概念


### 1.1 什么是条件组合


**通俗理解**：就像我们日常生活中的筛选条件一样

```
找餐厅的例子：
"我要找【距离近】并且【评分高】的餐厅"  ← AND逻辑（都要满足）
"我要找【川菜】或者【湘菜】的餐厅"      ← OR逻辑（满足一个即可）
"我要找【(川菜或湘菜) 并且 评分>4.5】"  ← 组合逻辑（嵌套条件）
```

**在数据库中**：条件组合就是把多个筛选条件用逻辑关系连接起来

### 1.2 为什么需要条件组合


**实际业务场景**：
- 🔍 **用户搜索**：按多个条件筛选商品（价格区间 + 品牌 + 销量）
- 📊 **报表统计**：复杂的数据筛选（时间范围 + 状态 + 用户类型）
- 🔐 **权限控制**：多条件判断用户访问权限
- 📝 **数据导出**：按组合条件批量导出数据

### 1.3 条件构造器的作用


**MyBatis-Plus提供的能力**：

```
不使用条件构造器（原始SQL）：
SELECT * FROM user 
WHERE (age > 18 AND status = 1) 
   OR (vip_level > 3 AND create_time > '2024-01-01')

使用条件构造器（Java代码）：
更灵活、更安全、更易维护
自动处理SQL注入
支持动态条件拼接
```

---

## 2. ⚡ AND逻辑与条件


### 2.1 AND的基本含义


**核心理解**：AND表示"并且"，所有条件都要满足

```
现实例子：
招聘要求："本科学历 AND 3年经验 AND 会Java"
→ 三个条件必须全部满足才符合要求

数据库查询：
"年龄>18 AND 性别=男 AND 状态=正常"
→ 三个条件同时成立才返回数据
```

### 2.2 默认AND连接


**重要特性**：条件构造器默认就是AND关系

```java
// 示例：查询年龄大于18且状态正常的用户
QueryWrapper<User> wrapper = new QueryWrapper<>();
wrapper.gt("age", 18)        // 第一个条件
       .eq("status", 1);     // 第二个条件（自动AND连接）

// 生成SQL：
// SELECT * FROM user WHERE age > 18 AND status = 1
```

**多条件示例**：

```java
// 查询：VIP用户 且 余额>100 且 最近登录
wrapper.eq("vip_flag", 1)
       .gt("balance", 100)
       .gt("last_login", "2024-01-01");

// SQL: WHERE vip_flag = 1 
//      AND balance > 100 
//      AND last_login > '2024-01-01'
```

### 2.3 显式使用and()方法


**什么时候需要显式and**：嵌套条件或分组时

```java
// 方式1：默认AND（简单条件）
wrapper.eq("status", 1)
       .gt("age", 18);

// 方式2：显式AND（用于嵌套）
wrapper.eq("status", 1)
       .and(w -> w.gt("age", 18)
                  .lt("age", 60));

// 生成SQL：
// WHERE status = 1 AND (age > 18 AND age < 60)
```

**实战案例**：查询活跃的成年用户

```java
// 需求：状态正常 且 (年龄18-60岁 且 最近30天登录过)
wrapper.eq("status", 1)
       .and(w -> w.between("age", 18, 60)
                  .gt("last_login", 
                      LocalDateTime.now().minusDays(30)));
```

---

## 3. 🔀 OR逻辑或条件


### 3.1 OR的基本含义


**核心理解**：OR表示"或者"，满足任意一个条件即可

```
现实例子：
优惠活动："新用户 OR VIP用户 OR 满100元"
→ 三个条件满足任意一个都可以享受优惠

数据库查询：
"状态=待审核 OR 状态=审核中"
→ 两个状态任意一个都会被查出来
```

### 3.2 简单OR条件


```java
// 示例：查询VIP用户或余额大于1000的用户
QueryWrapper<User> wrapper = new QueryWrapper<>();
wrapper.eq("vip_flag", 1)
       .or()  // 使用or()连接下一个条件
       .gt("balance", 1000);

// 生成SQL：
// SELECT * FROM user WHERE vip_flag = 1 OR balance > 1000
```

**多个OR条件**：

```java
// 查询：状态为1 或 状态为2 或 状态为3
wrapper.eq("status", 1)
       .or().eq("status", 2)
       .or().eq("status", 3);

// 更简洁的写法（使用in）：
wrapper.in("status", 1, 2, 3);
```

### 3.3 OR嵌套条件


**复杂OR场景**：OR后面跟一组条件

```java
// 需求：VIP用户 或 (余额>1000 且 信用良好)
wrapper.eq("vip_flag", 1)
       .or(w -> w.gt("balance", 1000)
                 .eq("credit", "good"));

// 生成SQL：
// WHERE vip_flag = 1 
//    OR (balance > 1000 AND credit = 'good')
```

**实战案例**：用户权限判断

```java
// 需求：管理员 或 (VIP用户 且 实名认证)
wrapper.eq("role", "admin")
       .or(w -> w.eq("vip_flag", 1)
                 .eq("verified", 1));

// SQL: WHERE role = 'admin' 
//         OR (vip_flag = 1 AND verified = 1)
```

---

## 4. 🏗️ 嵌套条件与分组


### 4.1 为什么需要嵌套条件


**问题场景**：

```
SQL需求：
WHERE (status = 1 OR status = 2) 
  AND age > 18

如果这样写（错误）：
wrapper.eq("status", 1)
       .or().eq("status", 2)
       .gt("age", 18);

生成SQL（不符合需求）：
WHERE status = 1 OR status = 2 AND age > 18
→ 运算优先级问题！实际执行是：
   status = 1 OR (status = 2 AND age > 18)
```

**正确做法**：使用嵌套分组

### 4.2 nested嵌套方法


**核心作用**：创建括号分组，控制条件优先级

```java
// 需求：(状态1或状态2) 且 年龄>18
wrapper.nested(w -> w.eq("status", 1)
                     .or().eq("status", 2))
       .gt("age", 18);

// 生成SQL：
// WHERE (status = 1 OR status = 2) AND age > 18
```

**嵌套条件结构图**：

```
条件关系树：
         AND
        /   \
    nested   gt(age, 18)
      |
     OR
    /  \
  eq    eq
(status=1) (status=2)
```

### 4.3 条件分组实战


**复杂分组示例**：

```java
// 需求：(VIP或余额>1000) 且 (年龄18-60) 且 状态正常
wrapper.nested(w -> w.eq("vip_flag", 1)
                     .or().gt("balance", 1000))
       .between("age", 18, 60)
       .eq("status", 1);

// SQL: WHERE (vip_flag = 1 OR balance > 1000) 
//        AND age BETWEEN 18 AND 60 
//        AND status = 1
```

**多层嵌套**：

```java
// 需求：((A或B) 且 C) 或 D
wrapper.nested(outer -> 
    outer.nested(inner -> inner.eq("A", 1).or().eq("B", 1))
         .eq("C", 1)
).or().eq("D", 1);

// SQL: WHERE ((A = 1 OR B = 1) AND C = 1) OR D = 1
```

### 4.4 嵌套条件应用场景


| 场景 | **说明** | **示例** |
|------|---------|---------|
| 🔍 **多状态筛选** | `多个状态的OR组合` | `(待支付 OR 支付中) AND 未超时` |
| 👤 **用户分类** | `用户类型组合判断` | `(VIP OR 企业认证) AND 活跃用户` |
| 📊 **复杂报表** | `多维度数据筛选` | `(时间范围 OR 特定日期) AND 业务类型` |
| 🔐 **权限控制** | `多角色权限判断` | `(管理员 OR 所有者) AND 状态正常` |

---

## 5. 🎯 复杂查询逻辑实战


### 5.1 电商订单查询


**业务需求**：查询需要处理的订单

```
条件描述：
1. (待支付 或 待发货) 的订单
2. 且 下单时间在最近7天内
3. 且 (金额>100 或 VIP用户订单)
```

**代码实现**：

```java
QueryWrapper<Order> wrapper = new QueryWrapper<>();

wrapper.nested(w -> w.eq("status", "待支付")
                     .or().eq("status", "待发货"))
       .gt("create_time", LocalDateTime.now().minusDays(7))
       .nested(w -> w.gt("amount", 100)
                     .or().eq("user_vip", 1));

// 生成SQL：
// WHERE (status = '待支付' OR status = '待发货')
//   AND create_time > DATE_SUB(NOW(), INTERVAL 7 DAY)
//   AND (amount > 100 OR user_vip = 1)
```

### 5.2 用户权限查询


**业务需求**：查询有权限访问的用户

```
条件：
1. 管理员用户（直接有权限）
2. 或 (VIP用户 且 实名认证 且 信用良好)
3. 且 账号状态正常
```

**代码实现**：

```java
wrapper.eq("role", "admin")
       .or(w -> w.eq("vip_flag", 1)
                 .eq("verified", 1)
                 .eq("credit", "good"))
       .eq("status", 1);

// SQL: WHERE role = 'admin' 
//         OR (vip_flag = 1 AND verified = 1 AND credit = 'good')
//      AND status = 1
```

### 5.3 数据统计查询


**业务场景**：活跃用户统计

```java
// 定义活跃用户：
// 1. 最近30天登录过
// 2. 且 (发布过内容 或 评论过 或 点赞数>10)
wrapper.gt("last_login", LocalDateTime.now().minusDays(30))
       .nested(w -> w.gt("post_count", 0)
                     .or().gt("comment_count", 0)
                     .or().gt("like_count", 10));
```

---

## 6. ⚖️ 条件优先级控制


### 6.1 SQL运算优先级


**数学运算类比**：

```
数学运算：2 + 3 × 4 = 14  （×优先级高于+）
加括号：(2 + 3) × 4 = 20  （括号改变优先级）

SQL逻辑：
WHERE A OR B AND C  → A OR (B AND C)  (AND优先级高)
加括号：(A OR B) AND C  （括号改变优先级）
```

### 6.2 优先级问题案例


**错误示例**：

```java
// ❌ 错误：想要 (A或B) 且 C
wrapper.eq("A", 1)
       .or().eq("B", 1)
       .eq("C", 1);

// 实际生成：A=1 OR B=1 AND C=1
// 等价于：A=1 OR (B=1 AND C=1)  ← 不符合预期！
```

**正确示例**：

```java
// ✅ 正确：使用nested控制优先级
wrapper.nested(w -> w.eq("A", 1)
                     .or().eq("B", 1))
       .eq("C", 1);

// 生成：(A=1 OR B=1) AND C=1  ← 符合预期！
```

### 6.3 复杂优先级控制


**多层嵌套优先级**：

```java
// 需求：((A或B) 且 C) 或 (D 且 E)
wrapper.nested(left -> 
           left.nested(w -> w.eq("A", 1).or().eq("B", 1))
               .eq("C", 1))
       .or(right -> 
           right.eq("D", 1).eq("E", 1));

// SQL: ((A=1 OR B=1) AND C=1) OR (D=1 AND E=1)
```

**优先级控制对比表**：

| 写法 | **生成SQL** | **优先级** |
|------|-----------|-----------|
| `A.or().B.and(C)` | `A OR B AND C` | `AND优先，等价于 A OR (B AND C)` |
| `nested(A.or().B).C` | `(A OR B) AND C` | `括号优先，先算OR` |
| `A.and(B).or().C` | `A AND B OR C` | `AND优先，等价于 (A AND B) OR C` |

---

## 7. 🔄 动态条件判断


### 7.1 什么是动态条件


**核心概念**：根据前端传入的参数，动态决定是否添加某个查询条件

```
实际场景：
用户搜索页面：
- 如果输入了用户名 → 添加用户名条件
- 如果选择了性别 → 添加性别条件  
- 如果没输入/选择 → 不添加该条件

避免写多个if-else分支
```

### 7.2 条件判断参数


**核心方法**：每个条件方法都支持第一个参数为boolean

```java
// 语法格式：
wrapper.条件方法(boolean condition, 字段, 值)

// condition为true → 添加这个条件
// condition为false → 忽略这个条件
```

**基础示例**：

```java
String username = "张三";  // 用户输入
Integer age = null;        // 用户未输入

wrapper.eq(username != null, "username", username)  // 添加
       .gt(age != null, "age", age);                // 不添加

// 生成SQL：WHERE username = '张三'
// age条件被自动忽略
```

### 7.3 动态条件实战


**搜索功能实现**：

```java
// 前端传入的搜索条件对象
public class UserSearchDTO {
    private String username;  // 可能为null
    private Integer minAge;   // 可能为null
    private Integer maxAge;   // 可能为null
    private String city;      // 可能为null
}

// 动态构建查询
public List<User> search(UserSearchDTO dto) {
    QueryWrapper<User> wrapper = new QueryWrapper<>();
    
    // 动态添加条件（优雅简洁）
    wrapper.like(StrUtil.isNotBlank(dto.getUsername()), 
                 "username", dto.getUsername())
           .ge(dto.getMinAge() != null, 
               "age", dto.getMinAge())
           .le(dto.getMaxAge() != null, 
               "age", dto.getMaxAge())
           .eq(StrUtil.isNotBlank(dto.getCity()), 
               "city", dto.getCity());
    
    return userMapper.selectList(wrapper);
}
```

### 7.4 复杂动态条件


**组合动态条件**：

```java
// 需求：如果有价格范围就按价格筛选，否则按默认条件
wrapper.nested(dto.getMinPrice() != null || dto.getMaxPrice() != null,
    w -> w.ge(dto.getMinPrice() != null, "price", dto.getMinPrice())
          .le(dto.getMaxPrice() != null, "price", dto.getMaxPrice())
).eq(dto.getMinPrice() == null && dto.getMaxPrice() == null,
    "is_recommend", 1);  // 无价格条件时查推荐商品
```

**动态OR条件**：

```java
// 如果传了关键词，在多个字段中搜索
wrapper.and(StrUtil.isNotBlank(keyword),
    w -> w.like("title", keyword)
          .or().like("content", keyword)
          .or().like("author", keyword));
```

### 7.5 动态条件最佳实践


**实用工具方法**：

```java
// 封装动态条件工具
public class WrapperUtil {
    
    // 动态添加like条件
    public static <T> void likeIfNotBlank(
        QueryWrapper<T> wrapper, 
        String column, 
        String value) {
        wrapper.like(StrUtil.isNotBlank(value), column, value);
    }
    
    // 动态添加范围条件
    public static <T> void betweenIfNotNull(
        QueryWrapper<T> wrapper,
        String column,
        Object min,
        Object max) {
        wrapper.ge(min != null, column, min)
               .le(max != null, column, max);
    }
}

// 使用示例
WrapperUtil.likeIfNotBlank(wrapper, "username", dto.getUsername());
WrapperUtil.betweenIfNotNull(wrapper, "age", dto.getMinAge(), dto.getMaxAge());
```

**动态条件检查清单**：

```
✅ 使用boolean判断参数，避免if-else
✅ 字符串用StrUtil.isNotBlank()判空
✅ 数值用 != null 判空
✅ 复杂逻辑封装成工具方法
✅ 注意null值的SQL含义（NULL不等于任何值）
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 AND逻辑：所有条件都要满足，默认就是AND连接
🔸 OR逻辑：满足任意条件即可，使用or()方法
🔸 嵌套条件：使用nested()创建括号分组
🔸 条件优先级：AND高于OR，用括号控制
🔸 动态条件：boolean参数控制条件是否生效
```

### 8.2 关键理解要点


**🔹 条件组合本质**
```
现实类比：
AND = 严格要求（所有条件必须满足）
OR  = 宽松要求（满足一个就行）
嵌套 = 分组控制（改变优先级）
```

**🔹 嵌套的作用**
```
核心价值：
1. 控制条件优先级（括号的作用）
2. 让SQL逻辑更清晰
3. 避免优先级陷阱

记忆要点：
需要括号 → 用nested
简单条件 → 直接链式调用
```

**🔹 动态条件的优势**
```
传统方式（繁琐）：
if (username != null) {
    wrapper.eq("username", username);
}
if (age != null) {
    wrapper.gt("age", age);
}

MP方式（优雅）：
wrapper.eq(username != null, "username", username)
       .gt(age != null, "age", age);
```

### 8.3 实际应用价值


**业务场景对应**：

| 场景 | **使用方式** | **核心要点** |
|------|------------|-------------|
| 🔍 **简单搜索** | `默认AND连接` | `多个条件都要满足` |
| 🎯 **多条件筛选** | `OR + nested组合` | `灵活组合，注意优先级` |
| 📊 **复杂报表** | `多层嵌套` | `理清逻辑关系，善用括号` |
| 🔄 **动态查询** | `boolean参数` | `避免if-else，代码更简洁` |

**开发建议**：

```
1. 先理清业务逻辑
   - 画出条件关系图
   - 确定AND/OR关系
   - 标注优先级

2. 选择合适的方法
   - 简单条件：直接链式
   - 需要分组：用nested
   - 动态条件：加boolean参数

3. 验证SQL正确性
   - 打印生成的SQL
   - 对比预期SQL
   - 测试边界情况
```

**常见陷阱提醒**：

```
⚠️ 优先级陷阱：
A.or().B.eq(C) ≠ (A or B) and C
正确写法：nested(A.or().B).eq(C)

⚠️ 动态条件陷阱：
不要用 value != null 判断空字符串
应该用：StrUtil.isNotBlank(value)

⚠️ 逻辑陷阱：
NOT (A OR B) ≠ NOT A OR NOT B
正确是：NOT A AND NOT B
```

### 8.4 学习路径建议


```
第一步：掌握基础
- AND默认连接
- or()方法使用
- 理解优先级

第二步：学会嵌套
- nested()分组
- 多层嵌套
- 优先级控制

第三步：动态条件
- boolean参数
- 工具方法封装
- 实战应用

第四步：综合运用
- 复杂业务场景
- 性能优化
- 代码优雅性
```

**核心记忆口诀**：
```
条件默认AND相连，OR需要明确添
嵌套分组控优先，括号作用要记牢
动态条件布尔判，代码简洁又优雅
逻辑清晰是关键，实战检验出真知
```