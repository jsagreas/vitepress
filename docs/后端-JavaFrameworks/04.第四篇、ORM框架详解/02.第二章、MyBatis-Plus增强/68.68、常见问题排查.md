---
title: 68、常见问题排查
---
## 📚 目录

1. [分页count查询错误](#1-分页count查询错误)
2. [逻辑删除配置误用](#2-逻辑删除配置误用)
3. [事务失效常见原因](#3-事务失效常见原因)
4. [Wrapper条件拼接异常](#4-Wrapper条件拼接异常)
5. [主键生成策略问题](#5-主键生成策略问题)
6. [字段映射错误处理](#6-字段映射错误处理)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 分页count查询错误


### 1.1 问题现象


**你可能遇到的情况**：
使用 MyBatis-Plus 分页查询时，总数统计不准确，或者分页查询非常慢。

```
实际场景举例：
查询订单列表，前端显示"共100条记录"
但实际数据库只有50条
或者：分页查询特别慢，但不分页很快
```

### 1.2 问题根源


**什么是 count 查询**：
- 分页时需要知道**总共有多少条数据**
- MyBatis-Plus 会自动执行两个 SQL：
  - **数据查询**：`SELECT * FROM user LIMIT 10`（查数据）
  - **总数查询**：`SELECT COUNT(*) FROM user`（查总数）

**常见的错误原因**：

| 问题类型 | 错误表现 | 根本原因 |
|---------|---------|---------|
| **复杂 SQL 解析失败** | count 数量不对 | MyBatis-Plus 无法正确解析你的复杂 SQL |
| **distinct 去重问题** | count 数量偏大 | 数据查询去重了，但 count 没去重 |
| **group by 分组问题** | count 数量错误 | 分组查询的 count 逻辑不对 |
| **left join 关联问题** | count 数量偏多 | 关联查询导致数据膨胀 |

### 1.3 解决方案


**方案一：优化 Wrapper 查询条件**

```java
// ❌ 错误：复杂的嵌套查询会导致 count 解析失败
QueryWrapper<Order> wrapper = new QueryWrapper<>();
wrapper.select("DISTINCT user_id, order_no")  // distinct 去重
       .inSql("id", "SELECT order_id FROM order_detail WHERE amount > 100");

// ✅ 正确：简化查询条件，避免复杂嵌套
QueryWrapper<Order> wrapper = new QueryWrapper<>();
wrapper.eq("status", 1)
       .gt("amount", 100);
```

**方案二：自定义 count 查询**

当 MyBatis-Plus 自动生成的 count 有问题时，你可以手动指定：

```java
// 方式1：关闭自动 count，手动查询总数
Page<Order> page = new Page<>(1, 10);
page.setSearchCount(false);  // 不要自动查询总数

List<Order> records = orderMapper.selectPage(page, wrapper).getRecords();
long total = orderMapper.selectCount(wrapper);  // 手动查询总数
page.setTotal(total);

// 方式2：自定义 count SQL（在 Mapper 中）
@Select("SELECT COUNT(*) FROM t_order WHERE status = #{status}")
Long customCount(@Param("status") Integer status);
```

**方案三：处理 group by 的 count**

```java
// ❌ 错误：group by 会导致 count 结果不准确
QueryWrapper<Order> wrapper = new QueryWrapper<>();
wrapper.groupBy("user_id");
Page<Order> page = orderMapper.selectPage(new Page<>(1, 10), wrapper);
// count 返回的是分组后的总数，不是记录总数！

// ✅ 正确：手动处理 group by 的分页
// 第一步：先查询分组后的总数
Long total = orderMapper.selectCount(
    new QueryWrapper<Order>()
        .select("COUNT(DISTINCT user_id)")
);

// 第二步：查询分页数据
Page<Order> page = new Page<>(1, 10);
page.setSearchCount(false);
page.setTotal(total);
orderMapper.selectPage(page, wrapper);
```

> 💡 **小贴士**  
> 如果你的查询包含 `distinct`、`group by`、`left join` 等复杂操作，建议关闭自动 count，手动查询总数，这样更准确也更可控。

---

## 2. 🗑️ 逻辑删除配置误用


### 2.1 什么是逻辑删除


**通俗理解**：
- **物理删除**：真的把数据从数据库删掉（`DELETE FROM user WHERE id = 1`）
- **逻辑删除**：只是打个"已删除"的标记，数据还在（`UPDATE user SET deleted = 1 WHERE id = 1`）

```
就像扔垃圾：
物理删除 = 直接扔进垃圾桶，彻底没了
逻辑删除 = 放进回收站，还能恢复
```

### 2.2 常见配置错误


**问题1：逻辑删除字段值配置反了**

```java
// ❌ 错误配置
@TableLogic
@TableField(value = "is_deleted")
private Integer deleted;

// 全局配置写反了
mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 0     # 删除值写成了0
      logic-not-delete-value: 1 # 未删除值写成了1
```

**结果**：删除数据后查询不到，未删除的反而查不到了！

**✅ 正确配置**：

```java
@TableLogic
@TableField(value = "is_deleted")
private Integer deleted;

// application.yml 配置
mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 1     # 删除后的值是 1
      logic-not-delete-value: 0 # 未删除的值是 0
```

**问题2：忘记给字段加注解**

```java
// ❌ 错误：字段定义了但没加 @TableLogic
private Integer deleted;

// ✅ 正确：必须加上注解
@TableLogic
private Integer deleted;
```

### 2.3 逻辑删除的坑


**坑点1：逻辑删除会影响所有查询**

```java
// 当配置了逻辑删除后，所有查询都会自动加上 deleted = 0 的条件

// 这个查询
userMapper.selectById(1);

// 实际执行的 SQL
SELECT * FROM user WHERE id = 1 AND deleted = 0

// 如果想查询包括已删除的数据怎么办？
// 答案：需要自己写 SQL
@Select("SELECT * FROM user WHERE id = #{id}")  // 不会自动加 deleted 条件
User selectIncludeDeleted(Long id);
```

**坑点2：批量删除的性能问题**

```java
// ❌ 性能差：逻辑删除是一条条 UPDATE
userMapper.deleteBatchIds(Arrays.asList(1, 2, 3, 4, 5));

// 实际执行 5 条 UPDATE
UPDATE user SET deleted = 1 WHERE id = 1;
UPDATE user SET deleted = 1 WHERE id = 2;
UPDATE user SET deleted = 1 WHERE id = 3;
// ...

// ✅ 性能好：自己写批量 UPDATE
userMapper.update(
    new User().setDeleted(1),
    new QueryWrapper<User>().in("id", Arrays.asList(1, 2, 3, 4, 5))
);

// 只执行 1 条 SQL
UPDATE user SET deleted = 1 WHERE id IN (1, 2, 3, 4, 5);
```

> ⚠️ **注意事项**  
> 逻辑删除会让表数据越来越多，记得定期清理真正删除的数据，或者建立归档表。

---

## 3. 🔄 事务失效常见原因


### 3.1 事务是什么


**通俗理解**：
事务就像**银行转账**，要么全部成功，要么全部失败，不能转一半。

```
比如：A 给 B 转账 100 元

步骤1：A 的账户扣 100 元
步骤2：B 的账户加 100 元

事务保证：
- 两步都成功 ✅
- 或者都不执行 ✅
- 不能只扣了 A 的钱，B 没收到 ❌
```

### 3.2 事务失效的原因


**原因1：方法不是 public**

```java
// ❌ 错误：private 方法，事务不生效
@Transactional
private void transferMoney() {
    // 事务无效！
}

// ✅ 正确：必须是 public
@Transactional
public void transferMoney() {
    // 事务有效
}
```

**为什么**：Spring 事务是基于**代理**实现的，只能代理 public 方法。

**原因2：自己调用自己的方法**

```java
@Service
public class UserService {
    
    // ❌ 错误：内部调用，事务失效
    public void outerMethod() {
        this.innerMethod();  // 这样调用，innerMethod 的事务无效
    }
    
    @Transactional
    public void innerMethod() {
        // 事务失效！
    }
    
    // ✅ 正确：通过注入自己来调用
    @Autowired
    private UserService self;
    
    public void outerMethod() {
        self.innerMethod();  // 这样事务才有效
    }
}
```

**原因3：异常被捕获了**

```java
// ❌ 错误：异常被 catch 了，事务不会回滚
@Transactional
public void saveUser(User user) {
    try {
        userMapper.insert(user);
        int i = 1 / 0;  // 出错
    } catch (Exception e) {
        e.printStackTrace();  // 吃掉异常，事务不回滚
    }
}

// ✅ 正确：让异常抛出去
@Transactional
public void saveUser(User user) {
    userMapper.insert(user);
    int i = 1 / 0;  // 异常抛出，事务回滚
}

// 或者：手动回滚
@Transactional
public void saveUser(User user) {
    try {
        userMapper.insert(user);
        int i = 1 / 0;
    } catch (Exception e) {
        TransactionAspectSupport.currentTransactionStatus()
            .setRollbackOnly();  // 手动标记回滚
        throw e;  // 重新抛出
    }
}
```

**原因4：异常类型不对**

```java
// ❌ 错误：检查异常不会回滚
@Transactional
public void saveUser(User user) throws Exception {
    userMapper.insert(user);
    throw new Exception("出错了");  // 检查异常，不回滚
}

// ✅ 正确：指定回滚的异常类型
@Transactional(rollbackFor = Exception.class)
public void saveUser(User user) throws Exception {
    userMapper.insert(user);
    throw new Exception("出错了");  // 现在会回滚了
}
```

> 💡 **记住**  
> Spring 默认只对**运行时异常**（RuntimeException）和 **Error** 进行回滚，检查异常（Exception）不会回滚，需要手动指定。

---

## 4. 🔧 Wrapper条件拼接异常


### 4.1 常见拼接错误


**错误1：链式调用顺序错了**

```java
// ❌ 错误：or() 的位置不对
QueryWrapper<User> wrapper = new QueryWrapper<>();
wrapper.eq("status", 1)
       .or()                    // or 放这里
       .eq("name", "张三")
       .like("email", "@qq");   // 会变成：status=1 OR name='张三' OR email LIKE '%@qq%'

// 生成的 SQL：WHERE status = 1 OR name = '张三' LIKE email '%@qq%'
// 不符合预期！

// ✅ 正确：用括号明确优先级
wrapper.eq("status", 1)
       .and(w -> w.eq("name", "张三")
                  .or()
                  .like("email", "@qq"));

// 生成的 SQL：WHERE status = 1 AND (name = '张三' OR email LIKE '%@qq%')
```

**错误2：空值判断遗漏**

```java
// ❌ 错误：参数可能为 null，导致 SQL 出错
String name = null;
wrapper.eq("name", name);  // 生成：WHERE name = null（错误！）

// ✅ 正确：使用条件判断
wrapper.eq(StringUtils.isNotBlank(name), "name", name);
// name 为空时不拼接这个条件

// 或者：先判断再拼接
if (StringUtils.isNotBlank(name)) {
    wrapper.eq("name", name);
}
```

### 4.2 复杂条件拼接技巧


**场景：搜索条件组合**

```
需求：查询用户
- 状态必须是启用（status = 1）
- 并且满足以下任一条件：
  1. 姓名包含关键字
  2. 邮箱包含关键字
  3. 手机号包含关键字
```

```java
// 方式1：使用 and 嵌套
QueryWrapper<User> wrapper = new QueryWrapper<>();
wrapper.eq("status", 1)
       .and(w -> w.like("name", keyword)
                  .or().like("email", keyword)
                  .or().like("phone", keyword));

// SQL：WHERE status = 1 AND (name LIKE '%xx%' OR email LIKE '%xx%' OR phone LIKE '%xx%')

// 方式2：使用 lambda 写法（更清晰）
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
wrapper.eq(User::getStatus, 1)
       .and(w -> w.like(User::getName, keyword)
                  .or().like(User::getEmail, keyword)
                  .or().like(User::getPhone, keyword));
```

> 🎯 **推荐做法**  
> 复杂条件优先使用 **lambda 写法**，避免字段名写错，而且 IDE 有提示，不容易出错。

---

## 5. 🔑 主键生成策略问题


### 5.1 主键策略类型


MyBatis-Plus 支持多种主键生成方式：

| 策略 | 说明 | 适用场景 |
|-----|------|---------|
| `AUTO` | 数据库自增 | MySQL 的 AUTO_INCREMENT |
| `NONE` | 不设置（手动输入） | 需要自己设置 ID 的情况 |
| `INPUT` | 手动输入 | 同上 |
| `ASSIGN_ID` | **雪花算法**（默认） | 分布式系统，生成唯一 Long 类型 ID |
| `ASSIGN_UUID` | UUID | 需要字符串类型 ID |

### 5.2 常见问题


**问题1：忘记配置主键策略**

```java
// ❌ 错误：没指定主键策略，使用默认的雪花算法
@TableName("t_user")
public class User {
    private Long id;  // 没有 @TableId 注解
}

// 插入数据时会自动生成雪花 ID
userMapper.insert(user);
// 但如果数据库设置了 AUTO_INCREMENT，会冲突！

// ✅ 正确：明确指定策略
@TableId(type = IdType.AUTO)  // 使用数据库自增
private Long id;
```

**问题2：雪花算法生成的 ID 太长**

```java
// 雪花算法生成的 ID 示例
1234567890123456789  // 19 位数字

// 前端 JavaScript 处理时会丢失精度！
// JavaScript 的 Number 最大安全整数是 2^53-1

// ✅ 解决：转成字符串传给前端
@JsonSerialize(using = ToStringSerializer.class)
@TableId(type = IdType.ASSIGN_ID)
private Long id;
```

**问题3：批量插入时 ID 冲突**

```java
// ❌ 错误：多线程批量插入，可能 ID 重复
List<User> users = new ArrayList<>();
for (int i = 0; i < 1000; i++) {
    users.add(new User().setName("用户" + i));
}
userService.saveBatch(users);  // 在高并发下可能 ID 重复

// ✅ 解决：使用数据库自增或分布式 ID
// 方案1：改用数据库自增
@TableId(type = IdType.AUTO)
private Long id;

// 方案2：使用分布式 ID 生成器（如美团 Leaf、百度 UidGenerator）
```

---

## 6. 🔄 字段映射错误处理


### 6.1 常见映射问题


**问题1：驼峰命名映射失败**

```
数据库字段：user_name
Java 字段：  userName

正常情况会自动映射，但有时不生效
```

```java
// ✅ 检查配置
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true  # 确保开启驼峰映射
```

**问题2：字段名不匹配**

```java
// 数据库字段叫 nick_name
// Java 字段叫 nickname（少了下划线）

// ❌ 会映射失败

// ✅ 方案1：使用 @TableField 指定
@TableField("nick_name")
private String nickname;

// ✅ 方案2：改 Java 字段名
private String nickName;  // 改成驼峰形式
```

**问题3：查询结果字段为 null**

```java
// 执行查询
User user = userMapper.selectById(1);
System.out.println(user.getCreateTime());  // null

// 原因1：数据库字段是 create_time，Java 是 createTime
// 但映射配置没开启

// 原因2：这个字段在 SELECT 时被排除了
@TableField(select = false)  // 这个注解会让字段不被查询
private LocalDateTime createTime;

// ✅ 解决：去掉 select = false，或者明确查询该字段
```

### 6.2 特殊字段处理


**场景：数据库关键字冲突**

```java
// 数据库字段叫 order（是 SQL 关键字）

// ❌ 错误：直接用会报错
private String order;

// ✅ 方案1：使用反引号转义
@TableField("`order`")
private String order;

// ✅ 方案2：改字段名
@TableField("order_no")
private String orderNo;
```

**场景：字段不存在于数据库**

```java
// Java 中的计算字段，数据库没有

// ❌ 错误：查询时会报错"Unknown column"
private String fullName;  // 由 firstName + lastName 计算得出

// ✅ 正确：标记为非数据库字段
@TableField(exist = false)
private String fullName;

// 使用时手动赋值
User user = userMapper.selectById(1);
user.setFullName(user.getFirstName() + user.getLastName());
```

---

## 7. 📋 核心要点总结


### 7.1 问题排查思路


```
遇到问题时的检查顺序：

1️⃣ 看报错信息
   ↓ SQL 语法错误？参数类型不对？
   
2️⃣ 打印实际执行的 SQL  
   ↓ 开启 SQL 日志：mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
   
3️⃣ 检查配置是否生效
   ↓ 配置文件写对了吗？注解加对了吗？
   
4️⃣ 查看官方文档
   ↓ 确认用法是否正确
```

### 7.2 必记检查清单


**分页查询**：
- [x] 复杂查询是否需要自定义 count
- [x] 是否有 distinct、group by、left join
- [x] 是否需要关闭自动 count

**逻辑删除**：
- [x] @TableLogic 注解是否添加
- [x] 删除值和未删除值配置是否正确
- [x] 是否需要查询已删除数据

**事务管理**：
- [x] 方法是否为 public
- [x] 是否有自调用情况
- [x] 异常是否被捕获
- [x] 异常类型是否需要指定 rollbackFor

**条件构造**：
- [x] 空值是否做了判断
- [x] 复杂条件是否加了括号
- [x] 是否使用 lambda 避免字段名错误

**主键策略**：
- [x] 是否明确指定了 IdType
- [x] 前端是否能正确处理 Long 类型
- [x] 分布式环境是否会 ID 冲突

**字段映射**：
- [x] 驼峰映射是否开启
- [x] 字段名是否匹配
- [x] 非数据库字段是否标记 exist = false
- [x] 关键字字段是否加反引号

> 💡 **经验之谈**  
> 80% 的问题都是**配置不对**或**用法不当**，多看日志、多打印 SQL、多看官方文档，大部分问题都能快速解决。

### 7.3 最佳实践建议


**开发环境必做**：
- 开启 SQL 日志打印
- 开启 banner 显示版本信息  
- 配置合理的超时时间

**生产环境注意**：
- 关闭 SQL 日志（性能考虑）
- 设置合理的分页大小限制
- 定期清理逻辑删除的数据
- 监控慢查询和异常

**代码规范**：
- 优先使用 LambdaWrapper（避免字段名错误）
- 复杂条件用 lambda 嵌套（提高可读性）
- 空值判断要完整（防止 SQL 异常）
- 事务方法要简洁（减少长事务）