---
title: 39、乐观锁插件
---
## 📚 目录

1. [什么是乐观锁](#1-什么是乐观锁)
2. [MyBatis-Plus乐观锁插件](#2-MyBatis-Plus乐观锁插件)
3. [版本号控制机制](#3-版本号控制机制)
4. [并发更新处理策略](#4-并发更新处理策略)
5. [失败重试机制](#5-失败重试机制)
6. [性能影响评估](#6-性能影响评估)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔐 什么是乐观锁


### 1.1 从生活例子理解锁


> 💡 **生活类比**：想象你和朋友同时要编辑一份共享文档

**悲观锁（传统方式）**：
```
你正在编辑 → 文档被锁定 → 朋友只能等待 → 你编辑完成 → 朋友才能编辑

就像厕所门上了锁，别人只能在外面等
```

**乐观锁（MyBatis-Plus方式）**：
```
你开始编辑（版本号=1） → 朋友也开始编辑（版本号=1）
你提交保存（检查版本号还是1吗？是的，保存成功，版本号变2）
朋友提交保存（检查版本号还是1吗？不是！已经是2了，保存失败）

就像抢座位，谁先坐下谁就成功
```

### 1.2 为什么需要乐观锁


**🤔 实际问题场景**：

假设你在做一个电商系统，商品库存是100件：

```
时间线：
10:00:00  用户A查询库存：100件
10:00:01  用户B查询库存：100件
10:00:02  用户A购买10件，库存改为90件
10:00:03  用户B购买20件，库存改为80件

问题：实际卖了30件，但库存从100变成80，少算了10件！
```

**没有锁的后果**：
- ❌ 数据不一致：库存对不上
- ❌ 超卖问题：实际卖出超过库存
- ❌ 用户纠纷：订单数据混乱

**乐观锁解决方案**：
```
用户A查询：库存100，版本号V1
用户B查询：库存100，版本号V1
用户A提交：检查版本号是V1？是的！更新成功，版本号变V2
用户B提交：检查版本号是V1？不是！已经是V2了，更新失败
用户B重新查询：库存90，版本号V2，再次尝试购买
```

### 1.3 乐观锁 vs 悲观锁对比


| 对比维度 | **乐观锁** | **悲观锁** |
|---------|-----------|-----------|
| 🧠 **核心思想** | `假设不会冲突，提交时检查` | `假设一定冲突，先锁后操作` |
| ⚡ **性能** | `高并发性能好` | `并发性能差，容易阻塞` |
| 🎯 **适用场景** | `读多写少，冲突少` | `写操作多，冲突频繁` |
| 💻 **实现方式** | `版本号或时间戳` | `数据库行锁/表锁` |
| 🔧 **使用难度** | `需要处理更新失败` | `实现简单，但性能差` |

---

## 2. 🔌 MyBatis-Plus乐观锁插件


### 2.1 插件核心组件


**OptimisticLockerInnerInterceptor**：这是什么？

> 简单理解：这是MyBatis-Plus提供的一个"自动版本号检查器"，你不需要手写SQL，它会自动帮你加上版本号判断

**工作原理图示**：
```
正常更新SQL：
UPDATE user SET name='张三' WHERE id=1

加了乐观锁后：
UPDATE user SET name='张三', version=version+1 
WHERE id=1 AND version=当前版本号

↑ 注意：插件会自动添加 version 相关逻辑
```

### 2.2 快速配置乐观锁


**第一步：添加插件配置**

```java
@Configuration
public class MybatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 添加乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        
        return interceptor;
    }
}
```

> 💡 **配置说明**：这个配置只需要写一次，整个项目所有表都可以用乐观锁

**第二步：实体类添加版本号字段**

```java
public class Product {
    private Long id;
    private String name;
    private Integer stock;  // 库存
    
    @Version  // 这个注解很关键！告诉MyBatis-Plus这是版本号字段
    private Integer version;
    
    // getter/setter省略
}
```

**第三步：数据库表添加版本号列**

```sql
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    stock INT,
    version INT DEFAULT 0  -- 版本号字段，初始值为0
);
```

> ⚠️ **重要提醒**：
> - 版本号字段支持类型：`int`、`Integer`、`long`、`Long`、`Date`、`Timestamp`
> - 推荐使用 `Integer` 类型，从0开始
> - 必须有初始值，否则第一次更新会失败

---

## 3. 🔢 版本号控制机制


### 3.1 版本号如何工作


**完整流程图示**：
```
1. 查询数据                    2. 获取版本号
   ↓                              ↓
SELECT * FROM product          返回：id=1, stock=100, version=5
WHERE id=1                           ↓
                              3. 用户修改数据（在内存中）
                                 stock = 90（减少10）
                                 version = 5（保持不变）
                                      ↓
                              4. 提交更新
                                      ↓
UPDATE product                 5. 执行SQL（插件自动改写）
SET stock=90,                    UPDATE product 
    version=version+1            SET stock=90, version=6
WHERE id=1                       WHERE id=1 AND version=5
AND version=5                          ↓
                              6. 检查影响行数
                                 • 影响1行 → 成功
                                 • 影响0行 → 失败（版本号已变）
```

### 3.2 @Version注解详解


**支持的数据类型**：

| 类型 | **初始值** | **更新方式** | **推荐程度** |
|-----|----------|------------|-------------|
| `Integer/int` | `0或1` | `+1递增` | ⭐⭐⭐⭐⭐ 最推荐 |
| `Long/long` | `0或1` | `+1递增` | ⭐⭐⭐⭐ 大数据量 |
| `Date` | `当前时间` | `更新为当前时间` | ⭐⭐⭐ 需要时间记录 |
| `Timestamp` | `当前时间戳` | `更新为当前时间戳` | ⭐⭐⭐ 精确到毫秒 |

**使用建议**：
```
✅ 一般场景：用 Integer，简单直观
✅ 需要记录更新时间：用 Date 或 Timestamp
❌ 不要用 String：性能差且容易出错
```

### 3.3 版本号自动递增原理


**MyBatis-Plus的魔法**：

```java
// 你写的代码（简单）
Product product = productMapper.selectById(1);
product.setStock(90);
productMapper.updateById(product);  // 就这一行！

// MyBatis-Plus实际执行的SQL（自动改写）
UPDATE product 
SET stock = 90, 
    version = version + 1  -- 自动+1
WHERE id = 1 
  AND version = 5;  -- 自动加上版本号判断
```

> 🔥 **关键理解**：
> - 你只需要正常调用 `updateById()`
> - 插件会自动检测到 `@Version` 字段
> - 自动在SQL中加上版本号判断和递增
> - 返回影响行数，判断更新成功或失败

---

## 4. 🔄 并发更新处理策略


### 4.1 并发冲突场景模拟


**场景：两个用户同时抢购商品**

```
初始状态：库存100件，版本号V1

时间轴：
T1时刻  用户A查询    → stock=100, version=1
T2时刻  用户B查询    → stock=100, version=1
T3时刻  用户A提交-10  → 检查version=1？是！更新成功，version变2
T4时刻  用户B提交-20  → 检查version=1？否！更新失败
        ↓
        用户B需要重新处理
```

**代码演示**：

```java
public class ProductService {
    
    @Autowired
    private ProductMapper productMapper;
    
    // 减少库存的方法
    public boolean reduceStock(Long productId, Integer quantity) {
        // 1. 查询商品（获取当前版本号）
        Product product = productMapper.selectById(productId);
        
        // 2. 检查库存是否充足
        if (product.getStock() < quantity) {
            return false;  // 库存不足
        }
        
        // 3. 减少库存
        product.setStock(product.getStock() - quantity);
        
        // 4. 执行更新（乐观锁自动生效）
        int rows = productMapper.updateById(product);
        
        // 5. 判断更新结果
        if (rows == 0) {
            // 更新失败，说明版本号已变（被别人抢先更新了）
            return false;
        }
        
        return true;  // 更新成功
    }
}
```

> ⚠️ **返回值判断**：
> - `rows = 1`：更新成功
> - `rows = 0`：更新失败，版本号不匹配

### 4.2 处理更新失败的策略


**策略1：直接返回失败（简单粗暴）**

```java
public boolean updateProduct(Product product) {
    int rows = productMapper.updateById(product);
    if (rows == 0) {
        throw new RuntimeException("数据已被修改，请刷新后重试");
    }
    return true;
}
```

✅ 优点：代码简单  
❌ 缺点：用户体验差

**策略2：自动重试（推荐）**

> 见下一节详细讲解

**策略3：提示用户手动处理**

```java
public Result updateProduct(Product product) {
    int rows = productMapper.updateById(product);
    if (rows == 0) {
        return Result.fail("商品信息已更新，请刷新页面重新操作");
    }
    return Result.success("更新成功");
}
```

✅ 优点：让用户知道发生了什么  
✅ 适用：对数据准确性要求高的场景

---

## 5. 🔁 失败重试机制


### 5.1 为什么需要重试


**问题场景**：
```
用户A要购买商品：
第1次尝试 → 失败（被用户B抢先）
直接放弃？  → 用户体验差，可能还有库存

更好的方式：
第1次尝试 → 失败 → 重新查询 → 再次尝试 → 成功！
```

### 5.2 重试策略实现


**方式1：简单循环重试**

```java
public boolean reduceStockWithRetry(Long productId, Integer quantity) {
    int maxRetries = 3;  // 最多重试3次
    
    for (int i = 0; i < maxRetries; i++) {
        // 1. 重新查询最新数据（包含最新版本号）
        Product product = productMapper.selectById(productId);
        
        // 2. 检查库存
        if (product.getStock() < quantity) {
            return false;
        }
        
        // 3. 减少库存
        product.setStock(product.getStock() - quantity);
        
        // 4. 尝试更新
        int rows = productMapper.updateById(product);
        
        // 5. 成功则返回
        if (rows > 0) {
            return true;
        }
        
        // 6. 失败则继续下一次循环（自动重试）
    }
    
    return false;  // 重试次数用完，仍然失败
}
```

> 💡 **重试逻辑解释**：
> - 每次重试前都要 **重新查询** 获取最新版本号
> - 如果库存已不足，立即返回失败，不再重试
> - 重试3次还失败，说明竞争太激烈

**方式2：指数退避重试（高级）**

```java
public boolean reduceStockWithBackoff(Long productId, Integer quantity) {
    int maxRetries = 5;
    long baseDelay = 10;  // 基础延迟10ms
    
    for (int i = 0; i < maxRetries; i++) {
        Product product = productMapper.selectById(productId);
        
        if (product.getStock() < quantity) {
            return false;
        }
        
        product.setStock(product.getStock() - quantity);
        int rows = productMapper.updateById(product);
        
        if (rows > 0) {
            return true;
        }
        
        // 指数退避：等待时间逐渐增加
        try {
            Thread.sleep(baseDelay * (1L << i));  // 10ms, 20ms, 40ms, 80ms...
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
    
    return false;
}
```

> 🚀 **指数退避优势**：
> - 减少无效竞争：每次失败后等待更长时间
> - 提高成功率：给其他线程执行的机会
> - 防止雪崩：避免大量请求同时重试

### 5.3 重试次数建议


| 场景 | **重试次数** | **理由** |
|-----|------------|---------|
| 🛒 **秒杀抢购** | `3-5次` | `竞争激烈，快速失败` |
| 📦 **库存扣减** | `3次` | `平衡性能与成功率` |
| 💰 **账户余额** | `1-2次` | `金额敏感，谨慎重试` |
| 📝 **普通更新** | `不重试` | `冲突少，失败提示即可` |

> ⚠️ **重试注意事项**：
> - 重试次数不是越多越好，过多影响性能
> - 金融相关操作谨慎重试，防止重复扣款
> - 重试前一定要重新查询最新数据

---

## 6. 📊 性能影响评估


### 6.1 乐观锁的性能开销


**SQL层面的影响**：

```sql
-- 没有乐观锁（简单）
UPDATE product SET stock = 90 WHERE id = 1;

-- 有乐观锁（多一个判断条件）
UPDATE product SET stock = 90, version = version + 1 
WHERE id = 1 AND version = 5;
```

**性能对比**：
```
额外开销：
✅ SQL解析：几乎无影响（多一个WHERE条件）
✅ 索引使用：id是主键，version判断很快
✅ 更新操作：version字段+1，开销极小

结论：单次操作性能影响 < 1%
```

### 6.2 高并发场景分析


**场景：1000个用户同时抢购100件商品**

**悲观锁方式**：
```
性能表现：
• 第1个用户获得锁 → 其他999个等待
• 第2个用户获得锁 → 其他998个等待
• ...依次排队

问题：
❌ 平均响应时间：500ms（等待时间长）
❌ 吞吐量：2 TPS（每秒处理2个请求）
❌ 用户体验：卡顿、超时
```

**乐观锁方式**：
```
性能表现：
• 1000个用户同时读取数据 → 无阻塞
• 1000个用户同时提交更新 → 只有100个成功，900个失败
• 900个失败的重试 → 逐渐成功

优势：
✅ 平均响应时间：50ms（大部分无需等待）
✅ 吞吐量：200 TPS（并发处理能力强）
✅ 用户体验：快速响应（成功或失败都快）
```

### 6.3 优化建议


**📌 什么时候用乐观锁**：
```
✅ 读操作远多于写操作（如商品浏览 vs 购买）
✅ 数据冲突概率低（<10%）
✅ 需要高并发性能
✅ 可以接受更新失败（重试或提示）

❌ 什么时候不用：
• 写操作频繁，冲突率高（>30%）
• 不能接受更新失败（如金融核心交易）
• 对实时性要求极高（如实时竞价）
```

**🔧 性能优化技巧**：

1. **减少重试次数**
```java
// 不好：无限重试，可能死循环
while (true) {
    if (update()) break;
}

// 好：限制重试次数
for (int i = 0; i < 3; i++) {
    if (update()) break;
}
```

2. **批量操作优化**
```java
// 不好：循环更新，性能差
for (Product p : products) {
    productMapper.updateById(p);  // 每次都有乐观锁判断
}

// 好：先筛选，再批量（如果业务允许）
List<Product> toUpdate = products.stream()
    .filter(p -> checkCondition(p))
    .collect(Collectors.toList());
// 使用批量更新方法
```

3. **索引优化**
```sql
-- 确保版本号字段有索引（如果查询频繁）
CREATE INDEX idx_version ON product(version);
```

### 6.4 监控指标


**需要关注的指标**：

| 指标 | **正常值** | **异常值** | **处理建议** |
|-----|----------|----------|------------|
| 🔄 **冲突率** | `< 5%` | `> 20%` | `考虑改用悲观锁` |
| ⏱️ **平均重试次数** | `< 1.5次` | `> 3次` | `降低并发或优化业务` |
| ❌ **最终失败率** | `< 1%` | `> 5%` | `增加重试次数或限流` |
| 📈 **响应时间** | `< 100ms` | `> 500ms` | `检查数据库性能` |

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 乐观锁本质：不加锁，提交时检查版本号是否被改过
🔸 适用场景：读多写少，冲突少，需要高并发
🔸 核心组件：OptimisticLockerInnerInterceptor + @Version注解
🔸 工作原理：更新时自动添加版本号判断，版本号+1
🔸 失败处理：检查影响行数，为0则重试或提示用户
```

### 7.2 实战要点记忆


**🎯 配置三步骤**：
```
1️⃣ 注册插件：MybatisPlusInterceptor添加OptimisticLockerInnerInterceptor
2️⃣ 实体类标注：@Version注解标记版本号字段
3️⃣ 数据库建表：添加version字段，初始值为0
```

**🔑 使用关键点**：
```
✅ 更新前必须先查询（获取最新版本号）
✅ 判断updateById返回值（0表示失败）
✅ 失败时重新查询后重试（获取新版本号）
✅ 限制重试次数（防止死循环）
```

**⚠️ 常见错误**：
```
❌ 忘记添加@Version注解 → 乐观锁不生效
❌ version字段无初始值 → 第一次更新失败
❌ 直接使用旧对象重试 → 版本号还是旧的，永远失败
❌ 无限重试 → 性能问题，可能死循环
```

### 7.3 性能与场景选择


| 对比项 | **乐观锁** | **悲观锁** |
|-------|----------|-----------|
| 🎯 **最佳场景** | `读>>写，冲突少` | `写多，冲突频繁` |
| ⚡ **性能** | `高并发性能好` | `并发性能差` |
| 🛡️ **安全性** | `可能更新失败` | `保证更新成功` |
| 🔧 **实现难度** | `需处理失败` | `实现简单` |

**🚀 记忆口诀**：
```
乐观锁，不加锁，版本号来帮忙
读多写少最适合，冲突少时性能高
更新失败要重试，次数限制别忘掉
高并发下显神威，电商秒杀离不了
```

**📖 学习建议**：
1. 先在测试环境模拟并发场景，观察乐观锁效果
2. 对比有无乐观锁的性能差异
3. 实践不同的重试策略，找到最适合的方案
4. 监控生产环境的冲突率，及时调整策略

> 💡 **最终理解**：
> 乐观锁就像"抢座位"，谁先坐下谁成功，后来的人需要找其他座位。这种方式在人少座位多时效率最高，但如果人多座位少，可能需要多次尝试才能成功。MyBatis-Plus帮你自动实现了这个"抢座位"的逻辑，你只需要告诉它版本号字段是哪个，剩下的它都帮你搞定！