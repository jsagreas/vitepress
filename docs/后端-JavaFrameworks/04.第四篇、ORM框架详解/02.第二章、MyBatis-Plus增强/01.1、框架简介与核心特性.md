---
title: 1、框架简介与核心特性
---
## 📚 目录

1. [什么是MyBatis-Plus](#1-什么是MyBatis-Plus)
2. [为什么需要MyBatis-Plus](#2-为什么需要MyBatis-Plus)
3. [核心特性深入理解](#3-核心特性深入理解)
4. [MyBatis-Plus vs MyBatis对比](#4-MyBatis-Plus-vs-MyBatis对比)
5. [适用场景与选型建议](#5-适用场景与选型建议)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 什么是MyBatis-Plus


### 1.1 通俗理解ORM框架


> **先理解ORM是什么**：ORM全称是Object-Relational Mapping（对象关系映射）。简单说就是**让Java对象和数据库表自动对应起来**，不用手写SQL也能操作数据库。

**🔸 生活化比喻**

```
想象你去餐厅点餐：

传统JDBC方式（纯手工）：
你需要自己去厨房，告诉厨师每个菜怎么做，
食材怎么切，调料放多少，火候多大...
非常麻烦，容易出错

MyBatis方式（半自动）：
你有一本菜单（XML配置），可以点菜，
但每道菜的做法还是要你事先写好

MyBatis-Plus方式（全自动）：
餐厅有智能点餐系统，
你说要什么菜，系统自动帮你下单、烹饪、上菜
常见的菜品根本不用你操心
```

### 1.2 MyBatis-Plus的本质定位


**📋 官方定义解读**

MyBatis-Plus是MyBatis的**增强工具**，可以理解为：
- 不是替代品，而是**增强版**
- 保留了MyBatis的所有功能
- 在此基础上**自动化了90%的常见操作**

```
关系类比：

MyBatis     →  手动挡汽车（灵活但费力）
MyBatis-Plus →  自动挡汽车（自动化但保留手动模式）

┌─────────────────────────────────────────────┐
│            MyBatis-Plus 架构              │
├─────────────────────────────────────────────┤
│  ┌─────────────────────────────────────┐  │
│  │      增强功能层                     │  │
│  │  • CRUD自动生成                    │  │
│  │  • 代码生成器                      │  │
│  │  • 分页插件                        │  │
│  │  • Lambda表达式                    │  │
│  └─────────────────────────────────────┘  │
│  ┌─────────────────────────────────────┐  │
│  │      MyBatis核心层（保持原样）      │  │
│  │  • SQL映射                         │  │
│  │  • 动态SQL                         │  │
│  │  • 缓存机制                        │  │
│  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
```

### 1.3 核心理念：只做增强不做改变


**🔸 什么叫"无侵入"**

```java
// 原来的MyBatis代码依然可以用
@Mapper
public interface UserMapper {
    @Select("SELECT * FROM user WHERE id = #{id}")
    User findById(Long id);
}

// MyBatis-Plus新增的功能（不影响原有代码）
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 继承BaseMapper后，自动拥有insert、delete、update、select等方法
    // 原来手写的SQL方法依然有效
}
```

> **关键理解**：你可以把MyBatis-Plus看作是给MyBatis**装了个智能助手**，原来的功能一个不少，还多了很多自动化能力。

---

## 2. 💡 为什么需要MyBatis-Plus


### 2.1 传统开发的痛点


**🔸 场景一：重复代码太多**

传统MyBatis开发中，每个表都要写大量相似代码：

```
用户表需要写：
- UserMapper.java（接口）
- UserMapper.xml（SQL映射）
- 增删改查方法（insert、delete、update、select...）

商品表需要写：
- ProductMapper.java
- ProductMapper.xml
- 增删改查方法...

订单表需要写：
- OrderMapper.java
- OrderMapper.xml
- 增删改查方法...

10张表 = 写10遍相似代码！
```

**🔸 场景二：简单SQL也要手写**

```xml
<!-- 即使是最简单的根据ID查询，也要写XML -->
<select id="selectById" resultType="User">
    SELECT * FROM user WHERE id = #{id}
</select>

<!-- 分页查询要自己拼SQL -->
<select id="selectPage" resultType="User">
    SELECT * FROM user 
    LIMIT #{offset}, #{pageSize}
</select>
```

**🔸 场景三：条件查询很繁琐**

```java
// 多条件查询要写很长的代码
if (name != null) {
    sql += " AND name LIKE '%" + name + "%'";
}
if (age != null) {
    sql += " AND age = " + age;
}
// 拼接SQL容易出错，还有SQL注入风险
```

### 2.2 MyBatis-Plus的解决方案


**✅ 解决方案对比**

| **开发场景** | **传统MyBatis** | **MyBatis-Plus** | **效率提升** |
|-------------|----------------|-----------------|-------------|
| 单表CRUD | 需要写Mapper接口+XML | 继承BaseMapper即可 | 节省80%代码 |
| 分页查询 | 手写分页SQL | 内置分页插件 | 一行配置搞定 |
| 条件查询 | 拼接SQL字符串 | Lambda表达式 | 类型安全+简洁 |
| 代码生成 | 手动创建文件 | 代码生成器 | 自动生成全套代码 |

**🎯 实际效果对比**

```
传统方式开发一个用户模块：
1. 创建User实体类         - 10分钟
2. 创建UserMapper接口     - 5分钟
3. 编写UserMapper.xml     - 30分钟
4. 测试增删改查           - 20分钟
总计：约65分钟

MyBatis-Plus方式：
1. 创建User实体类         - 10分钟
2. 创建UserMapper接口     - 2分钟（继承BaseMapper）
总计：约12分钟

效率提升：约5倍！
```

---

## 3. 🚀 核心特性深入理解


### 3.1 无侵入式设计


**🔸 什么是无侵入**

> **通俗解释**：就像给你的车装个导航仪，不需要改装发动机，原来的功能一点不受影响。

```java
// 原来的MyBatis用法（完全保留）
@Mapper
public interface UserMapper {
    // 自定义的复杂SQL查询
    @Select("SELECT u.*, r.role_name FROM user u " +
            "LEFT JOIN role r ON u.role_id = r.id")
    List<UserVO> getUserWithRole();
}

// 加上MyBatis-Plus后（新增功能，不影响原有）
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 继承后自动拥有这些方法，不用自己写：
    // insert(User user)
    // deleteById(Long id)
    // updateById(User user)
    // selectById(Long id)
    // selectList(Wrapper wrapper)
    // ...
    
    // 原来的自定义方法依然有效
    List<UserVO> getUserWithRole();
}
```

**核心价值**：
- ✅ 老项目可以**平滑升级**，不用改原有代码
- ✅ 团队成员可以**按需使用**，会MyBatis就会MyBatis-Plus
- ✅ 复杂SQL依然可以**手写**，灵活性不减

### 3.2 CRUD自动化


**🔸 最实用的特性**

```java
// 只需要写这一个接口
@Mapper
public interface UserMapper extends BaseMapper<User> {
}

// 自动拥有以下能力：
userMapper.insert(user);              // 插入数据
userMapper.deleteById(1L);            // 根据ID删除
userMapper.updateById(user);          // 根据ID更新
userMapper.selectById(1L);            // 根据ID查询
userMapper.selectBatchIds(List);      // 批量ID查询
userMapper.selectByMap(Map);          // Map条件查询
userMapper.selectList(Wrapper);       // 条件查询列表
userMapper.selectPage(Page, Wrapper); // 分页查询
// ...还有更多
```

**🎯 实际使用示例**

```java
// 场景1：插入一条用户数据
User user = new User();
user.setName("张三");
user.setAge(25);
userMapper.insert(user); // 自动生成INSERT语句

// 场景2：根据ID更新
user.setAge(26);
userMapper.updateById(user); // 自动生成UPDATE语句

// 场景3：查询年龄大于20的用户
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
wrapper.gt(User::getAge, 20); // gt = greater than（大于）
List<User> users = userMapper.selectList(wrapper);
```

### 3.3 Lambda表达式支持


**🔸 告别字符串拼接**

**传统方式的问题**：
```java
// 字段名写错了，编译期发现不了，运行时才报错
wrapper.eq("namee", "张三"); // 拼错了！但编译通过
```

**Lambda方式的优势**：
```java
// 使用方法引用，IDE会自动提示，写错了编译就报错
wrapper.eq(User::getName, "张三"); // 类型安全，不会写错
```

**🎯 常用Lambda条件构造**

```java
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();

// 等值查询：name = '张三'
wrapper.eq(User::getName, "张三");

// 模糊查询：name LIKE '%张%'
wrapper.like(User::getName, "张");

// 范围查询：age BETWEEN 20 AND 30
wrapper.between(User::getAge, 20, 30);

// 排序：ORDER BY age DESC
wrapper.orderByDesc(User::getAge);

// 多条件：name = '张三' AND age > 20
wrapper.eq(User::getName, "张三")
       .gt(User::getAge, 20);
```

### 3.4 分页插件集成


**🔸 一行配置，全局分页**

传统分页需要每个查询都写LIMIT，MyBatis-Plus只需配置一次：

```java
// 配置类中添加分页插件
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor paginationInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(
            new PaginationInnerInterceptor(DbType.MYSQL)
        );
        return interceptor;
    }
}

// 使用时非常简单
Page<User> page = new Page<>(1, 10); // 第1页，每页10条
userMapper.selectPage(page, null);   // 自动分页
System.out.println("总记录数：" + page.getTotal());
System.out.println("总页数：" + page.getPages());
```

### 3.5 代码生成器


**🔸 一键生成全套代码**

```
输入：数据库表信息
输出：自动生成以下文件
├── entity/
│   └── User.java          (实体类)
├── mapper/
│   ├── UserMapper.java    (Mapper接口)
│   └── UserMapper.xml     (SQL映射)
├── service/
│   ├── IUserService.java  (Service接口)
│   └── impl/
│       └── UserServiceImpl.java (Service实现)
└── controller/
    └── UserController.java (Controller)
```

**实际价值**：
- 新建一个表，10秒生成全套代码
- 规范统一，不会遗漏
- 节省大量重复劳动

---

## 4. ⚖️ MyBatis-Plus vs MyBatis对比


### 4.1 核心差异对比


| **对比维度** | **MyBatis** | **MyBatis-Plus** | **适用场景** |
|-------------|------------|-----------------|-------------|
| **定位** | 持久层框架 | MyBatis增强工具 | MP适合快速开发 |
| **代码量** | 需要手写Mapper和XML | 继承接口即可 | MP减少80%代码 |
| **学习成本** | 需要学XML配置 | 会MyBatis即会用 | MP更容易上手 |
| **灵活性** | 完全自定义SQL | 支持自定义+自动 | 各有优势 |
| **复杂查询** | 手写SQL更直观 | 需要Wrapper构造 | 复杂SQL用MyBatis |
| **性能** | 原生性能 | 几乎无损耗 | 性能差距可忽略 |

### 4.2 实际开发对比


**场景：实现用户分页查询**

```java
// ========== MyBatis方式 ==========
// 1. UserMapper.java
public interface UserMapper {
    List<User> selectUserPage(@Param("offset") int offset, 
                              @Param("size") int size);
    int selectUserCount();
}

// 2. UserMapper.xml
<select id="selectUserPage" resultType="User">
    SELECT * FROM user LIMIT #{offset}, #{size}
</select>
<select id="selectUserCount" resultType="int">
    SELECT COUNT(*) FROM user
</select>

// 3. Service调用
public Page<User> getUserPage(int pageNum, int pageSize) {
    int offset = (pageNum - 1) * pageSize;
    List<User> list = userMapper.selectUserPage(offset, pageSize);
    int total = userMapper.selectUserCount();
    // 手动组装分页对象...
}

// ========== MyBatis-Plus方式 ==========
// 1. UserMapper.java（只需继承）
public interface UserMapper extends BaseMapper<User> {
}

// 2. Service调用（一行搞定）
Page<User> page = new Page<>(pageNum, pageSize);
userMapper.selectPage(page, null); // 自动分页，自动统计总数
```

**代码行数对比**：
- MyBatis方式：约30行
- MyBatis-Plus方式：约3行
- **效率提升：10倍**

### 4.3 何时选择MyBatis，何时选择MyBatis-Plus


**🔸 优先选择MyBatis-Plus的场景**：
- ✅ 单表CRUD操作为主
- ✅ 快速开发的项目
- ✅ 标准的业务系统
- ✅ 团队成员水平参差不齐

**🔸 考虑纯MyBatis的场景**：
- 🔹 大量复杂多表关联查询
- 🔹 需要极致SQL优化的项目
- 🔹 对SQL有严格审核要求
- 🔹 团队更熟悉手写SQL

**💡 最佳实践**：
```
推荐方案：MyBatis-Plus为主 + MyBatis为辅

简单CRUD → 用MyBatis-Plus自动方法
复杂查询 → 用MyBatis手写SQL
两者可以完美共存！
```

---

## 5. 🎯 适用场景与选型建议


### 5.1 典型应用场景


**✅ 非常适合的场景**

```
1. 企业管理系统
   - 用户管理、权限管理、部门管理...
   - 大量单表CRUD操作
   - MyBatis-Plus可减少70%开发时间

2. 电商后台系统
   - 商品管理、订单管理、库存管理...
   - 标准的增删改查
   - 代码生成器快速搭建模块

3. 微服务项目
   - 每个服务独立数据库
   - 单表操作为主
   - MyBatis-Plus简化持久层开发

4. 快速原型开发
   - 需要快速验证业务逻辑
   - 减少重复代码
   - 提升开发效率
```

**⚠️ 需要谨慎的场景**

```
1. 报表系统
   - 大量复杂SQL聚合查询
   - 多表关联统计
   - 建议：核心统计用MyBatis手写

2. 数据分析平台
   - 复杂的数据处理逻辑
   - SQL性能要求极高
   - 建议：关键查询手动优化

3. 遗留系统改造
   - 已有大量MyBatis代码
   - 建议：渐进式引入MyBatis-Plus
```

### 5.2 团队技术选型建议


**🔸 技术选型决策树**

```
开始选型
    ↓
是否有大量单表CRUD？
    ├─ 是 → 项目周期紧张吗？
    │       ├─ 是 → 选MyBatis-Plus（快速开发）
    │       └─ 否 → 团队熟悉MyBatis-Plus吗？
    │               ├─ 是 → 选MyBatis-Plus
    │               └─ 否 → 评估学习成本
    └─ 否 → 复杂SQL多吗？
            ├─ 是 → 选MyBatis（灵活可控）
            └─ 否 → 可以考虑MyBatis-Plus
```

**🎯 推荐搭配方案**

| **项目类型** | **推荐方案** | **理由** |
|-------------|-------------|---------|
| 新项目 | MyBatis-Plus为主 | 快速开发，降低成本 |
| 老项目升级 | 逐步引入MP | 平滑升级，风险可控 |
| 大型项目 | MP + MyBatis混用 | 发挥各自优势 |
| 学习项目 | 先学MP再学MyBatis | 降低学习曲线 |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 MyBatis-Plus本质：MyBatis的增强工具，不是替代品
🔸 核心理念：只做增强不做改变，保持无侵入性
🔸 最大价值：自动化单表CRUD，减少90%重复代码
🔸 技术特色：Lambda表达式 + 分页插件 + 代码生成器
🔸 适用场景：标准业务系统、快速开发项目、单表操作为主
🔸 学习路径：会MyBatis基础就能快速上手
```

### 6.2 关键理解要点


**🔹 MyBatis-Plus不是银弹**
```
能解决的：
✅ 单表CRUD自动化
✅ 简单条件查询
✅ 标准分页功能
✅ 代码规范统一

解决不了的：
❌ 复杂多表关联
❌ 特殊业务逻辑
❌ 极致性能优化
这些还是要靠手写SQL
```

**🔹 无侵入的真正含义**
```
不是说"不能手写SQL"
而是说"手写的SQL依然有效"

原来的MyBatis功能：100%保留
新增的增强功能：按需使用
两者完美共存，互不干扰
```

**🔹 何时用MP，何时用MyBatis**
```
简单记忆法：
单表操作 → MyBatis-Plus
复杂查询 → 手写MyBatis SQL

实际开发中，80%用MP，20%手写
这样既提高效率，又保持灵活性
```

### 6.3 新手学习建议


**📚 学习路径**
```
第一步：掌握MyBatis基础（1-2天）
  └─ 理解ORM概念
  └─ 会配置数据源
  └─ 理解SQL映射

第二步：学习MyBatis-Plus核心（2-3天）
  └─ BaseMapper的使用
  └─ Wrapper条件构造
  └─ 分页插件配置

第三步：实战项目练习（1周）
  └─ 搭建完整项目
  └─ 实现增删改查
  └─ 处理复杂业务

第四步：进阶特性探索（持续）
  └─ 代码生成器
  └─ 性能优化
  └─ 最佳实践
```

**💡 学习建议**
- ⭐⭐⭐⭐⭐ 重要：先理解概念，再写代码
- ⭐⭐⭐⭐ 建议：多看官方文档和示例
- ⭐⭐⭐ 推荐：对比MyBatis加深理解
- ⭐⭐ 可选：研究源码实现原理

**🎯 实践检验清单**
- [ ] 能用BaseMapper完成单表CRUD
- [ ] 会用LambdaQueryWrapper构造查询条件
- [ ] 能配置和使用分页插件
- [ ] 理解何时用MP，何时手写SQL
- [ ] 能在项目中灵活运用

**核心记忆**：
```
MyBatis是手动挡，MyBatis-Plus是自动挡
不是替代关系，是增强关系
简单操作用自动，复杂逻辑手动切换
两者结合，开发效率提升5倍以上
```