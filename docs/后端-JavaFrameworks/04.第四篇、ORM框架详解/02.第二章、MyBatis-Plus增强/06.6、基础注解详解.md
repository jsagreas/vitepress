---
title: 6、基础注解详解
---
## 📚 目录导航

1. [实体映射基础概念](#1-实体映射基础概念)
2. [TableName表名映射](#2-tablename表名映射)
3. [TableId主键注解](#3-tableid主键注解)
4. [TableField字段注解](#4-tablefield字段注解)
5. [TableLogic逻辑删除](#5-tablelogic逻辑删除)
6. [字段映射策略](#6-字段映射策略)
7. [驼峰命名转换](#7-驼峰命名转换)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 实体映射基础概念


### 1.1 什么是实体映射


🌰 **生活类比**：想象你有一个Excel表格，里面存着学生信息。现在要把这个表格的数据在Java程序里使用，就需要建立一个"桥梁"——这就是实体映射。

**通俗理解**：
```
数据库表（table）         Java类（Class）
-----------------  对应  ------------------
user_info 表       ←→    UserInfo 类
  ├─ id              ←→    id 属性
  ├─ user_name       ←→    userName 属性
  └─ create_time     ←→    createTime 属性
```

> 💡 **核心概念**  
> 实体映射就是告诉程序："数据库表的这一列，对应Java类的那个属性"

### 1.2 为什么需要注解


**传统方式的问题**：
- 需要写大量XML配置文件
- 表名和类名对应关系要手动配置
- 字段名改了，多处都要修改

**使用注解的好处**：
- ✅ 直接在类上标注，一目了然
- ✅ 修改方便，改一处就行
- ✅ 代码和配置在一起，不容易出错

### 1.3 MyBatis-Plus注解体系


```
核心注解家族：
├─ @TableName    → 管表名的
├─ @TableId      → 管主键的  
├─ @TableField   → 管普通字段的
└─ @TableLogic   → 管逻辑删除的
```

---

## 2. 📋 @TableName表名映射


### 2.1 基本概念


**作用**：告诉MyBatis-Plus这个Java类对应数据库的哪张表

🤔 **什么时候需要用**：
- 表名和类名不一致时
- 表名有特殊前缀时（如：`tb_user`、`sys_user`）

### 2.2 使用场景详解


**场景一：表名和类名完全不同**

```java
// 数据库表名：user_info
// Java类名：User
@TableName("user_info")
public class User {
    private Long id;
    private String name;
}
```

**场景二：表名有统一前缀**

```java
// 数据库表名：tb_product
@TableName("tb_product")
public class Product {
    private Long id;
    private String productName;
}
```

### 2.3 全局配置简化


> 💡 **实用技巧**  
> 如果所有表都有相同前缀，可以全局配置，不用每个类都写

```yaml
# application.yml配置文件

mybatis-plus:
  global-config:
    db-config:
      table-prefix: tb_  # 统一前缀
```

**配置后的效果**：
```java
// 现在不用写@TableName了
// MyBatis-Plus会自动找 tb_user 表
public class User {
    private Long id;
}
```

### 2.4 常用属性说明


| 属性 | **说明** | **示例** | **何时使用** |
|------|---------|---------|-------------|
| `value` | `表名` | `@TableName("sys_user")` | `表名与类名不同` |
| `schema` | `数据库名` | `@TableName(schema="shop")` | `多数据库场景` |
| `keepGlobalPrefix` | `保持全局前缀` | `keepGlobalPrefix=false` | `不想用全局前缀时` |

---

## 3. 🔑 @TableId主键注解


### 3.1 主键是什么


🌰 **生活类比**：就像每个人的身份证号，用来唯一标识一条数据

**数据库中的主键**：
```
user表
id(主键)  name    age
1        张三    20   ← 这条记录的唯一标识是1
2        李四    22   ← 这条记录的唯一标识是2
```

### 3.2 主键生成策略


**AUTO - 数据库自增**
```java
@TableId(type = IdType.AUTO)
private Long id;
```

工作原理：
```
第一次插入 → 数据库自动生成 id=1
第二次插入 → 数据库自动生成 id=2
第三次插入 → 数据库自动生成 id=3
```

> ⚠️ **使用条件**  
> 数据库表的id字段必须设置了AUTO_INCREMENT

**ASSIGN_ID - 雪花算法（默认）**
```java
@TableId(type = IdType.ASSIGN_ID)
private Long id;
```

生成效果：
```
插入数据时自动生成：1524234234234234234
下一条数据生成：    1524234234234234235
```

> 💡 **优势说明**  
> 雪花算法生成的ID全局唯一，适合分布式系统

**ASSIGN_UUID - UUID字符串**
```java
@TableId(type = IdType.ASSIGN_UUID)
private String id;  // 注意：这里是String类型
```

生成效果：
```
32位UUID：a1b2c3d4e5f6789012345678901234ab
```

### 3.3 主键策略对比


| 策略 | **生成方式** | **适用场景** | **优点** | **缺点** |
|------|------------|------------|---------|---------|
| `AUTO` | `数据库自增` | `单库单表` | `简单直观` | `分库分表会重复` |
| `ASSIGN_ID` | `雪花算法` | `分布式系统` | `全局唯一，性能好` | `ID较长` |
| `ASSIGN_UUID` | `UUID算法` | `需要字符串ID` | `全局唯一` | `无序，占空间大` |

### 3.4 自定义主键值


```java
User user = new User();
user.setId(10086L);  // 手动指定ID
user.setName("张三");
userMapper.insert(user);  // 使用指定的ID插入
```

---

## 4. 📝 @TableField字段注解


### 4.1 基本用途


**作用**：处理Java属性名和数据库字段名的对应关系

**三大核心功能**：
1️⃣ 字段名映射
2️⃣ 字段填充策略
3️⃣ 字段查询控制

### 4.2 字段名映射


**场景：属性名和字段名不一致**

```java
public class User {
    // 数据库字段：user_name
    // Java属性：  userName
    @TableField("user_name")
    private String userName;
}
```

**驼峰转换示意**：
```
Java属性          数据库字段
userName    →    user_name
createTime  →    create_time
isDeleted   →    is_deleted
```

### 4.3 字段存在性控制


**场景：类里有个属性，但数据库没这个字段**

```java
public class User {
    private Long id;
    private String name;
    
    // 这个字段数据库表里没有，只是用来临时计算的
    @TableField(exist = false)
    private Integer age;
}
```

> 💡 **实用场景**  
> 比如"总价 = 单价 × 数量"，总价不存数据库，每次算出来就行

### 4.4 查询字段控制


**不查询敏感字段**：
```java
public class User {
    private Long id;
    
    // 密码字段，查询时不返回
    @TableField(select = false)
    private String password;
}
```

执行查询：
```java
// 实际执行：SELECT id, name FROM user
// 不会查询password字段
List<User> users = userMapper.selectList(null);
```

### 4.5 自动填充策略


**场景：创建时间、更新时间自动填充**

```java
public class User {
    // 插入时自动填充
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    // 插入和更新时都自动填充
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
}
```

**填充策略对比**：

| 策略 | **何时填充** | **典型用途** |
|------|------------|-------------|
| `INSERT` | `仅插入时` | `创建时间、创建人` |
| `UPDATE` | `仅更新时` | `修改人` |
| `INSERT_UPDATE` | `插入和更新时` | `更新时间` |

> 🔧 **配置步骤**  
> 需要配合MetaObjectHandler使用，后面章节会详细讲解

---

## 5. 🗑️ @TableLogic逻辑删除


### 5.1 什么是逻辑删除


**物理删除 vs 逻辑删除**：

```
物理删除（真删除）：
DELETE FROM user WHERE id = 1;
→ 数据真的没了，找不回来了 ❌

逻辑删除（假删除）：
UPDATE user SET deleted = 1 WHERE id = 1;
→ 数据还在，只是标记为"已删除" ✅
```

🌰 **生活类比**：
- 物理删除 = 把文件扔进碎纸机
- 逻辑删除 = 把文件放进回收站

### 5.2 为什么用逻辑删除


**业务场景**：
1. **数据恢复**：用户误删可以找回
2. **审计追溯**：查看历史删除记录
3. **关联数据**：删除订单时，不能让商品也没了

### 5.3 使用方式


**实体类配置**：
```java
public class User {
    private Long id;
    private String name;
    
    // 0表示未删除，1表示已删除
    @TableLogic
    private Integer deleted;
}
```

**全局配置**：
```yaml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted  # 全局逻辑删除字段
      logic-delete-value: 1        # 删除后的值
      logic-not-delete-value: 0    # 未删除的值
```

### 5.4 执行效果对比


**配置逻辑删除前**：
```java
userMapper.deleteById(1);
// 执行SQL：DELETE FROM user WHERE id = 1
// 数据真的被删除了
```

**配置逻辑删除后**：
```java
userMapper.deleteById(1);
// 实际执行SQL：UPDATE user SET deleted = 1 WHERE id = 1
// 数据还在，只是标记删除

userMapper.selectById(1);
// 实际执行SQL：SELECT * FROM user WHERE id = 1 AND deleted = 0
// 查不到被逻辑删除的数据
```

### 5.5 逻辑删除的影响范围


**自动处理的操作**：
- ✅ 查询：自动过滤已删除数据
- ✅ 更新：不会更新已删除数据
- ✅ 删除：转为UPDATE操作

**不受影响的操作**：
```java
// 如果确实要物理删除，用SQL方式
userMapper.delete(new QueryWrapper<User>()
    .eq("id", 1)
    .last("LIMIT 1"));
```

---

## 6. ⚙️ 字段映射策略


### 6.1 全局映射策略


**配置位置**：application.yml
```yaml
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true  # 开启驼峰转换
  global-config:
    db-config:
#      # 字段策略配置
      insert-strategy: not_null    # 插入策略
      update-strategy: not_null    # 更新策略
      select-strategy: not_empty   # 查询策略
```

### 6.2 插入策略详解


**NOT_NULL策略**（推荐）：
```java
User user = new User();
user.setName("张三");
user.setAge(null);  // age为null

// 执行插入
userMapper.insert(user);
// 实际SQL：INSERT INTO user (name) VALUES ('张三')
// age字段为null，不插入
```

**NOT_EMPTY策略**：
```java
User user = new User();
user.setName("");     // 空字符串
user.setAge(null);

// 实际SQL：INSERT INTO user DEFAULT VALUES
// name是空字符串，age是null，都不插入
```

**策略对比**：

| 策略 | **null值** | **空字符串** | **适用场景** |
|------|-----------|------------|-------------|
| `NOT_NULL` | `不插入` | `插入` | `一般业务` |
| `NOT_EMPTY` | `不插入` | `不插入` | `字符串字段多的场景` |
| `IGNORED` | `插入` | `插入` | `需要明确插入null` |

### 6.3 更新策略详解


**按需更新**：
```java
User user = new User();
user.setId(1L);
user.setName("李四");  // 只设置name

// 执行更新
userMapper.updateById(user);
// 实际SQL：UPDATE user SET name = '李四' WHERE id = 1
// 只更新设置了值的字段
```

### 6.4 字段级别策略


**覆盖全局策略**：
```java
public class User {
    // 这个字段使用自己的策略
    @TableField(insertStrategy = FieldStrategy.ALWAYS)
    private String remark;  // 即使为null也要插入
}
```

---

## 7. 🔄 驼峰命名转换


### 7.1 命名规范对比


**数据库命名规范**（下划线）：
```sql
user_name
create_time
is_deleted
```

**Java命名规范**（驼峰）：
```java
userName
createTime
isDeleted
```

### 7.2 自动转换机制


**开启配置**：
```yaml
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true  # 默认就是true
```

**转换规则示意**：
```
数据库字段              Java属性
user_name       ←→    userName
create_time     ←→    createTime  
order_id        ←→    orderId
is_vip          ←→    isVip
```

### 7.3 特殊情况处理


**情况一：转换规则不适用**
```java
public class User {
    // 数据库字段：UserName（帕斯卡命名）
    @TableField("UserName")
    private String userName;
}
```

**情况二：多个下划线**
```java
// 数据库：user_login_name
// 自动转换为：userLoginName ✅
private String userLoginName;
```

### 7.4 完整示例


**数据库表结构**：
```sql
CREATE TABLE user_info (
    user_id BIGINT PRIMARY KEY,
    user_name VARCHAR(50),
    create_time DATETIME,
    is_deleted TINYINT
);
```

**Java实体类**：
```java
@TableName("user_info")
public class UserInfo {
    @TableId(value = "user_id", type = IdType.AUTO)
    private Long userId;
    
    // 自动映射：user_name ←→ userName
    private String userName;
    
    // 自动映射：create_time ←→ createTime
    private LocalDateTime createTime;
    
    // 自动映射：is_deleted ←→ isDeleted
    @TableLogic
    private Integer isDeleted;
}
```

---

## 8. 📋 核心要点总结


### 8.1 注解使用速查


**🔸 @TableName - 表名映射**
```java
@TableName("sys_user")  // 指定表名
```
- 用途：类名和表名不一致时使用
- 技巧：可配置全局前缀简化

**🔸 @TableId - 主键配置**
```java
@TableId(type = IdType.AUTO)  // 数据库自增
@TableId(type = IdType.ASSIGN_ID)  // 雪花算法
```
- AUTO：单库场景
- ASSIGN_ID：分布式场景（默认推荐）

**🔸 @TableField - 字段控制**
```java
@TableField("user_name")  // 字段映射
@TableField(exist = false)  // 非表字段
@TableField(select = false)  // 不查询
@TableField(fill = FieldFill.INSERT)  // 自动填充
```

**🔸 @TableLogic - 逻辑删除**
```java
@TableLogic
private Integer deleted;  // 0未删除 1已删除
```

### 8.2 最佳实践建议


> 💡 **新手推荐配置**

```yaml
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true  # 驼峰转换
  global-config:
    db-config:
      table-prefix: tb_              # 表前缀
      id-type: assign_id             # 主键策略
      logic-delete-field: deleted    # 逻辑删除字段
      logic-delete-value: 1
      logic-not-delete-value: 0
```

### 8.3 常见问题解答


**🤔 问题1：什么时候必须用@TableName？**
- 表名和类名不同
- 表名有特殊字符
- 需要指定schema

**🤔 问题2：主键策略怎么选？**
- 单机应用 → AUTO
- 分布式系统 → ASSIGN_ID
- 需要字符串ID → ASSIGN_UUID

**🤔 问题3：逻辑删除字段一定要叫deleted吗？**
- 不一定，可以自定义字段名
- 通过@TableLogic或全局配置指定

### 8.4 学习检查清单


**📈 掌握程度自测**：
- [ ] 能说出四个核心注解的作用
- [ ] 能配置主键生成策略
- [ ] 能实现字段的自动填充
- [ ] 能配置逻辑删除功能
- [ ] 理解驼峰命名转换规则

**🔗 相关知识点**：
- 下一节：[CRUD接口操作](#crud接口)
- 扩展学习：[条件构造器](#条件构造器)
- 高级特性：[自动填充处理器](#自动填充)

---

**🧠 记忆口诀**：
```
TableName管表名，TableId管主键
TableField管字段，TableLogic删不见
驼峰自动转换好，配置一次用到老
```