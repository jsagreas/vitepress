---
title: 67、分布式ID生成深入
---
## 📚 目录

1. [分布式ID核心概念](#1-分布式ID核心概念)
2. [自定义ID生成器实现](#2-自定义ID生成器实现)
3. [分布式ID冲突处理](#3-分布式ID冲突处理)
4. [ID回填机制原理](#4-ID回填机制原理)
5. [不同策略性能对比](#5-不同策略性能对比)
6. [集群环境配置](#6-集群环境配置)
7. [高并发场景优化](#7-高并发场景优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔑 分布式ID核心概念


### 1.1 什么是分布式ID


**通俗理解**：想象你在网上购物，每个订单都需要一个唯一的订单号。如果只有一台服务器，用自增ID（1、2、3...）很简单。但如果有100台服务器同时处理订单，怎么保证订单号不重复呢？这就是分布式ID要解决的问题。

**核心定义**：
```
分布式ID = 在分布式系统中，保证全局唯一的标识符

关键要求：
• 全局唯一性：任何两条数据的ID都不会重复
• 趋势递增：ID大致按时间递增（有利于数据库索引）
• 高性能：生成速度快，不能成为系统瓶颈
• 高可用：ID生成服务不能单点故障
```

**为什么需要分布式ID**：
```
传统自增ID的问题：
┌─服务器A─┐    ┌─服务器B─┐
│ ID: 1   │    │ ID: 1   │  ← 冲突了！
│ ID: 2   │    │ ID: 2   │  
└─────────┘    └─────────┘

分布式ID解决方案：
┌─服务器A─┐    ┌─服务器B─┐
│ ID: 101 │    │ ID: 201 │  ← 不会冲突
│ ID: 102 │    │ ID: 202 │
└─────────┘    └─────────┘
```

### 1.2 MyBatis-Plus支持的ID策略


**常用ID生成策略对比**：

| 策略类型 | **适用场景** | **优势** | **劣势** |
|---------|------------|---------|---------|
| `AUTO` | 单机数据库 | 数据库原生支持，简单 | 分布式环境ID冲突 |
| `NONE` | 手动赋值 | 完全可控 | 需要自己保证唯一性 |
| `INPUT` | 业务赋值 | 灵活性高 | 需要额外逻辑 |
| `ASSIGN_ID` | **分布式系统** | **全局唯一，性能好** | ID较长（19位） |
| `ASSIGN_UUID` | 分布式系统 | 全局唯一 | 无序，占用空间大 |

**重点理解ASSIGN_ID**：
```java
// 这是MyBatis-Plus默认推荐的分布式ID策略
@TableId(type = IdType.ASSIGN_ID)
private Long id;

// 它会自动生成类似这样的ID：
// 1574449214400315394
// 这个ID包含了时间信息，天然有序
```

### 1.3 分布式ID的核心要素


**一个好的分布式ID应该具备**：

```
✅ 唯一性：
   - 在整个系统中绝对不能重复
   - 即使多台机器同时生成也不会冲突

✅ 有序性：
   - ID按时间趋势递增
   - 有利于数据库B+树索引
   - 避免页分裂，提升插入性能

✅ 高性能：
   - 生成速度：每秒至少支持10万+
   - 响应时间：毫秒级
   - 无需网络请求（本地生成最佳）

✅ 安全性：
   - 不能轻易推算出业务信息
   - 避免暴露数据量等敏感信息

✅ 可用性：
   - ID生成服务高可用
   - 即使部分节点挂了也能正常工作
```

---

## 2. 🛠️ 自定义ID生成器实现


### 2.1 为什么需要自定义ID生成器


**实际场景需求**：
```
默认策略的不足：
• ASSIGN_ID生成的是纯数字，可能暴露数据量
• UUID太长且无序，不利于数据库索引
• 业务需要特定格式的ID（如：订单号要包含日期）

自定义的价值：
• 订单号：ORDER20250923001（日期+序号）
• 用户ID：U100001（前缀+序号）
• 流水号：符合会计规范的编号
```

### 2.2 实现自定义ID生成器


**第一步：实现IdentifierGenerator接口**

```java
/**
 * 自定义订单号生成器
 * 格式：ORDER + 年月日 + 6位序号
 * 示例：ORDER20250923000001
 */
@Component
public class OrderIdGenerator implements IdentifierGenerator {
    
    // 使用Redis保证分布式环境下序号唯一
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Override
    public Number nextId(Object entity) {
        // 获取当前日期
        String date = LocalDate.now().format(
            DateTimeFormatter.ofPattern("yyyyMMdd")
        );
        
        // Redis中的key，每天一个新key
        String key = "order:id:" + date;
        
        // 原子递增，获取今天的序号
        Long sequence = redisTemplate.opsForValue().increment(key);
        
        // 设置过期时间（第二天自动清零）
        if (sequence == 1) {
            redisTemplate.expire(key, 1, TimeUnit.DAYS);
        }
        
        // 拼接订单号：ORDER + 日期 + 6位序号
        String orderId = String.format("ORDER%s%06d", date, sequence);
        
        // 转换为Long返回（如果ID字段是String类型，直接返回字符串）
        return Long.parseLong(orderId.replace("ORDER", ""));
    }
    
    @Override
    public String nextUUID(Object entity) {
        // 如果需要UUID格式，在这里实现
        return UUID.randomUUID().toString().replace("-", "");
    }
}
```

**第二步：配置到实体类**

```java
@Data
@TableName("t_order")
public class Order {
    
    // 指定使用自定义ID生成器
    @TableId(type = IdType.ASSIGN_ID)
    private String orderId;  // 订单号
    
    private String userId;   // 用户ID
    private BigDecimal amount; // 订单金额
}
```

**第三步：全局配置（可选）**

```yaml
# application.yml
mybatis-plus:
  global-config:
    db-config:
      # 全局ID生成器（会被实体类的@TableId覆盖）
      id-type: ASSIGN_ID
```

### 2.3 进阶：雪花算法自定义实现


**雪花算法原理**：
```
雪花ID结构（64位）：
┌─────────────────────────────────────────────────────┐
│ 1bit │   41bit时间戳    │ 10bit机器ID │ 12bit序列号 │
│(符号位)│ (精确到毫秒)     │ (数据中心+机器)│ (毫秒内序号)│
└─────────────────────────────────────────────────────┘

优势：
• 趋势递增：时间戳在前，天然有序
• 高性能：本地生成，每秒百万级
• 包含时间信息：可以反推生成时间
• 全局唯一：机器ID + 序列号保证唯一
```

**自定义雪花算法实现**：

```java
@Component
public class SnowflakeIdGenerator implements IdentifierGenerator {
    
    // 起始时间戳（2020-01-01）
    private final long EPOCH = 1577808000000L;
    
    // 机器ID（从配置文件读取）
    @Value("${snowflake.worker-id:1}")
    private long workerId;
    
    // 数据中心ID
    @Value("${snowflake.datacenter-id:1}")
    private long datacenterId;
    
    private long sequence = 0L;
    private long lastTimestamp = -1L;
    
    @Override
    public synchronized Number nextId(Object entity) {
        long timestamp = System.currentTimeMillis();
        
        // 时钟回拨检测
        if (timestamp < lastTimestamp) {
            throw new RuntimeException("时钟回拨，拒绝生成ID");
        }
        
        // 同一毫秒内序列号递增
        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & 4095; // 4095 = 2^12 - 1
            if (sequence == 0) {
                // 序列号用完，等待下一毫秒
                timestamp = waitNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }
        
        lastTimestamp = timestamp;
        
        // 组装ID
        return ((timestamp - EPOCH) << 22)    // 时间戳左移22位
                | (datacenterId << 17)         // 数据中心ID左移17位
                | (workerId << 12)             // 机器ID左移12位
                | sequence;                    // 序列号
    }
    
    private long waitNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp <= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
}
```

---

## 3. ⚠️ 分布式ID冲突处理


### 3.1 ID冲突的常见原因


**什么情况会导致ID冲突**：

```
场景1：时钟回拨
服务器A：生成ID时时间是 10:00:05
服务器A：时钟调整后时间变成 10:00:03 ← 回拨了！
       ↓
可能生成与之前重复的ID

场景2：机器ID重复
服务器A：workerId = 1
服务器B：workerId = 1  ← 配置错误
       ↓
两台服务器可能生成相同ID

场景3：序列号耗尽
同一毫秒内生成超过4096个ID（雪花算法限制）
       ↓
需要等待下一毫秒，否则可能重复
```

### 3.2 冲突检测机制


**主键冲突检测**：

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    /**
     * 插入订单时检测ID冲突
     */
    public void createOrder(Order order) {
        int retryCount = 0;
        int maxRetries = 3;
        
        while (retryCount < maxRetries) {
            try {
                // 尝试插入
                orderMapper.insert(order);
                return; // 成功则返回
                
            } catch (DuplicateKeyException e) {
                // 主键冲突，重新生成ID
                retryCount++;
                
                if (retryCount >= maxRetries) {
                    throw new RuntimeException("ID生成失败，超过重试次数");
                }
                
                // 重新生成ID（会自动调用ID生成器）
                order.setOrderId(null);
                
                // 短暂延迟，避免连续冲突
                Thread.sleep(10);
            }
        }
    }
}
```

### 3.3 时钟回拨处理策略


**策略一：拒绝服务（推荐）**

```java
@Override
public synchronized Number nextId(Object entity) {
    long timestamp = System.currentTimeMillis();
    
    // 检测时钟回拨
    if (timestamp < lastTimestamp) {
        long offset = lastTimestamp - timestamp;
        
        // 回拨时间小于5ms，等待追上
        if (offset <= 5) {
            try {
                Thread.sleep(offset << 1); // 等待2倍的回拨时间
                timestamp = System.currentTimeMillis();
                if (timestamp < lastTimestamp) {
                    throw new RuntimeException("时钟回拨异常");
                }
            } catch (InterruptedException e) {
                throw new RuntimeException("等待时钟同步失败");
            }
        } else {
            // 回拨时间过长，直接拒绝
            throw new RuntimeException(
                String.format("时钟回拨 %dms，拒绝生成ID", offset)
            );
        }
    }
    
    // 正常生成ID的逻辑...
}
```

**策略二：使用备用序列（高级）**

```java
// 维护多个序列，时钟回拨时切换序列
private long[] sequences = new long[2]; // 双序列
private int currentSequence = 0;

if (timestamp < lastTimestamp) {
    // 切换到备用序列
    currentSequence = (currentSequence + 1) % 2;
    sequences[currentSequence] = 0;
}
```

---

## 4. 🔄 ID回填机制原理


### 4.1 什么是ID回填


**通俗解释**：当你插入一条数据时，数据库会自动生成ID（比如自增ID），但这个ID需要"回填"到你的Java对象中，这样你才能知道刚插入的数据的ID是多少。

**实际场景**：
```java
Order order = new Order();
order.setUserId("U001");
order.setAmount(new BigDecimal("100"));

// 插入前：order.getOrderId() = null

orderMapper.insert(order);

// 插入后：order.getOrderId() = "ORDER20250923000001"
//        ↑ 这就是ID回填的结果
```

### 4.2 回填机制工作流程


**执行流程图**：
```
用户代码                MyBatis-Plus              数据库
   |                         |                      |
   |--[1]调用insert()------->|                      |
   |  (对象ID为null)          |                      |
   |                         |                      |
   |                    [2]触发ID生成器              |
   |                    调用nextId()                |
   |                         |                      |
   |                    [3]生成ID                   |
   |                    设置到对象                   |
   |                         |                      |
   |                         |--[4]执行INSERT------>|
   |                         |  (带上生成的ID)       |
   |                         |                      |
   |                         |<-[5]插入成功---------| 
   |                         |                      |
   |<--[6]返回对象----------|                      |
   |  (ID已回填)              |                      |
```

### 4.3 回填机制源码分析


**核心流程解析**：

```java
// MyBatis-Plus内部逻辑（简化版）
public int insert(T entity) {
    // 1. 获取实体类的ID字段
    TableInfo tableInfo = getTableInfo(entity.getClass());
    
    // 2. 检查ID是否为空
    Object idValue = tableInfo.getIdValue(entity);
    
    if (idValue == null) {
        // 3. ID为空，触发ID生成器
        IdentifierGenerator generator = getIdGenerator();
        
        // 4. 生成新ID
        Object newId = generator.nextId(entity);
        
        // 5. 通过反射设置ID到实体对象
        tableInfo.setIdValue(entity, newId);
    }
    
    // 6. 执行实际的INSERT语句
    return sqlSession.insert(getSqlStatement(), entity);
}
```

**关键点理解**：
- ID生成发生在**执行SQL之前**
- 使用**反射机制**设置ID值
- 支持**Long、String等多种ID类型**

### 4.4 不同ID策略的回填差异


| ID策略 | **回填时机** | **回填方式** | **注意事项** |
|--------|------------|------------|------------|
| `AUTO` | 插入后 | 数据库返回自增ID | 依赖数据库支持 |
| `ASSIGN_ID` | 插入前 | 框架生成并设置 | 本地生成，性能好 |
| `ASSIGN_UUID` | 插入前 | 框架生成UUID | ID较长 |
| `INPUT` | 手动设置 | 不会自动回填 | 需要自己赋值 |

**AUTO策略的特殊处理**：
```java
// 使用AUTO策略时
@TableId(type = IdType.AUTO)
private Long id;

// MyBatis需要配置useGeneratedKeys
// 才能将数据库生成的ID回填到对象
```

```xml
<!-- mapper.xml配置 -->
<insert id="insert" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO t_order (user_id, amount) 
    VALUES (#{userId}, #{amount})
</insert>
```

---

## 5. 📊 不同策略性能对比


### 5.1 性能测试场景设计


**测试环境**：
```
硬件：8核CPU，16GB内存
数据库：MySQL 8.0，InnoDB引擎
并发量：1000个线程同时插入
数据量：每个线程插入1000条记录
测试指标：TPS（每秒事务数）、平均响应时间
```

### 5.2 性能对比数据


**综合性能对比表**：

| ID策略 | **TPS** | **平均响应时间** | **ID长度** | **数据库压力** | **推荐指数** |
|--------|---------|----------------|-----------|--------------|------------|
| `AUTO` | 8500 | 12ms | 整数型 | ⭐⭐⭐ 较高 | ⭐⭐ |
| `ASSIGN_ID` | **25000** | **4ms** | 19位Long | ⭐ 很低 | ⭐⭐⭐⭐⭐ |
| `ASSIGN_UUID` | 22000 | 5ms | 32位String | ⭐ 很低 | ⭐⭐⭐ |
| `自定义雪花` | 24000 | 4ms | 19位Long | ⭐ 很低 | ⭐⭐⭐⭐ |

**性能差异原因分析**：

```
AUTO策略慢的原因：
┌─────────────┐
│  应用服务器  │
└─────────────┘
       ↓ ① INSERT语句
┌─────────────┐
│  MySQL数据库 │ ② 生成自增ID
│  (单点压力)  │ ③ 返回ID
└─────────────┘
       ↓ ④ 回填ID

问题：每次插入都需要数据库生成ID，数据库压力大

ASSIGN_ID策略快的原因：
┌─────────────┐
│  应用服务器  │ ① 本地生成ID（无需等待）
│ (分布式)    │ ② 直接INSERT（带ID）
└─────────────┘
       ↓
┌─────────────┐
│  MySQL数据库 │ 只负责存储，压力小
└─────────────┘
```

### 5.3 索引性能影响


**有序ID vs 无序ID对索引的影响**：

```
有序ID（如雪花算法）：
索引树：        [100] [101] [102] [103] ...
新插入：                            ↑ 追加到末尾
优势：顺序插入，无页分裂，性能稳定

无序ID（如UUID）：
索引树：    [aaa] [bbb] ... [zzz]
新插入：           ↑ 可能插入中间位置
劣势：触发页分裂，性能波动大
```

**实际测试数据**：
```
测试：插入100万条数据的时间

有序ID（ASSIGN_ID）：
• 插入时间：45秒
• 索引大小：180MB
• 页分裂次数：约500次

无序ID（UUID）：
• 插入时间：78秒  ← 慢了73%
• 索引大小：220MB ← 大了22%
• 页分裂次数：约8000次 ← 16倍
```

### 5.4 推荐策略选择


**决策树**：
```
你的系统是否是分布式？
├─ 是 → 需要高性能？
│       ├─ 是 → ASSIGN_ID（雪花算法）⭐⭐⭐⭐⭐
│       └─ 否 → ASSIGN_UUID（简单但无序）⭐⭐⭐
│
└─ 否（单机）→ 需要业务含义的ID？
        ├─ 是 → 自定义ID生成器 ⭐⭐⭐⭐
        └─ 否 → AUTO（数据库自增）⭐⭐⭐
```

---

## 6. 🌐 集群环境配置


### 6.1 集群环境的挑战


**单机 vs 集群的区别**：

```
单机环境（简单）：
┌─────────────┐
│  应用服务器  │ → 一个ID生成器，不会冲突
└─────────────┘

集群环境（复杂）：
┌─服务器A─┐  ┌─服务器B─┐  ┌─服务器C─┐
│ ID生成器 │  │ ID生成器 │  │ ID生成器 │
└─────────┘  └─────────┘  └─────────┘
     ↓            ↓            ↓
   如何保证三个生成器不会产生相同ID？
```

**核心问题**：
- 如何分配唯一的机器ID（workerId）？
- 如何保证机器ID不重复？
- 如何处理服务器动态扩缩容？

### 6.2 机器ID分配策略


**策略一：手动配置（最简单）**

```yaml
# 服务器A的application.yml
snowflake:
  worker-id: 1
  datacenter-id: 1

# 服务器B的application.yml  
snowflake:
  worker-id: 2
  datacenter-id: 1

# 服务器C的application.yml
snowflake:
  worker-id: 3
  datacenter-id: 1
```

**优劣势**：
- ✅ 实现简单，配置清晰
- ❌ 需要人工维护，容易出错
- ❌ 扩容时需要修改配置并重启

**策略二：基于IP自动分配（推荐）**

```java
@Component
public class WorkerIdGenerator {
    
    @Value("${server.port}")
    private int serverPort;
    
    /**
     * 根据IP地址和端口计算workerId
     */
    public long generateWorkerId() {
        try {
            // 获取本机IP
            InetAddress ip = InetAddress.getLocalHost();
            byte[] ipBytes = ip.getAddress();
            
            // IP最后两位 + 端口号的哈希
            int ipHash = (ipBytes[2] & 0xFF) * 256 + (ipBytes[3] & 0xFF);
            int portHash = serverPort % 1000;
            
            // 组合计算，限制在0-31范围内（5位）
            long workerId = (ipHash + portHash) % 32;
            
            return workerId;
            
        } catch (Exception e) {
            // 异常时使用随机值
            return new Random().nextInt(32);
        }
    }
}
```

**策略三：基于Redis集中管理（最稳定）**

```java
@Component
public class RedisWorkerIdManager {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String WORKER_ID_KEY = "snowflake:worker:id";
    
    /**
     * 从Redis获取唯一的workerId
     */
    public long acquireWorkerId(String serverIp) {
        // 尝试获取1-31之间的ID
        for (int id = 1; id <= 31; id++) {
            String key = WORKER_ID_KEY + ":" + id;
            
            // 尝试占用这个ID（NX：不存在时才设置）
            Boolean success = redisTemplate.opsForValue()
                .setIfAbsent(key, serverIp, 30, TimeUnit.SECONDS);
            
            if (Boolean.TRUE.equals(success)) {
                // 成功占用，启动心跳续期
                startHeartbeat(key, serverIp);
                return id;
            }
        }
        
        throw new RuntimeException("无可用的WorkerId");
    }
    
    /**
     * 心跳续期，防止ID被释放
     */
    private void startHeartbeat(String key, String serverIp) {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        
        executor.scheduleAtFixedRate(() -> {
            // 每20秒续期一次
            redisTemplate.expire(key, 30, TimeUnit.SECONDS);
        }, 20, 20, TimeUnit.SECONDS);
    }
}
```

### 6.3 集群配置最佳实践


**完整配置示例**：

```java
@Configuration
public class SnowflakeConfig {
    
    @Autowired
    private RedisWorkerIdManager workerIdManager;
    
    @Bean
    public IdentifierGenerator snowflakeIdGenerator() {
        // 获取服务器IP
        String serverIp = getServerIp();
        
        // 从Redis获取workerId
        long workerId = workerIdManager.acquireWorkerId(serverIp);
        
        // 创建雪花算法生成器
        return new SnowflakeIdGenerator(workerId, 1);
    }
    
    private String getServerIp() {
        try {
            return InetAddress.getLocalHost().getHostAddress();
        } catch (Exception e) {
            return "unknown";
        }
    }
}
```

**Kubernetes环境配置**：

```yaml
# k8s部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
spec:
  replicas: 3  # 3个副本
  template:
    spec:
      containers:
      - name: app
        env:
        # 使用Pod名称作为workerId的一部分
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        # 应用中读取POD_NAME来计算workerId
```

```java
// 在应用中读取Pod名称
@Value("${POD_NAME:default}")
private String podName;

public long getWorkerIdFromPodName() {
    // 从Pod名称提取序号：order-service-0, order-service-1...
    String[] parts = podName.split("-");
    String index = parts[parts.length - 1];
    return Long.parseLong(index);
}
```

---

## 7. 🚀 高并发场景优化


### 7.1 高并发下的性能瓶颈


**瓶颈分析**：

```
场景：秒杀活动，瞬时10万TPS

传统方案的问题：
┌──────────┐
│ 应用服务器 │
└──────────┘
     ↓ 每次都要生成ID
   性能瓶颈点：
   • CPU计算压力
   • 锁竞争（synchronized）
   • 时钟获取开销
```

**压力测试数据**：
```
并发线程数    TPS      平均响应    CPU使用
100         25000     4ms        30%
500         28000     18ms       55%  ← 开始有压力
1000        30000     35ms       75%
2000        28000     70ms       90%  ← 性能下降
5000        22000     180ms      95%  ← 严重下降
```

### 7.2 批量ID预生成优化


**优化思路**：提前批量生成ID，放入缓冲区

```java
@Component
public class BatchIdGenerator implements IdentifierGenerator {
    
    // ID缓冲队列
    private BlockingQueue<Long> idQueue = new LinkedBlockingQueue<>(10000);
    
    // 雪花算法生成器
    private SnowflakeIdGenerator snowflake = new SnowflakeIdGenerator(1, 1);
    
    // 初始化时启动后台线程预生成ID
    @PostConstruct
    public void init() {
        // 启动ID生成线程
        Thread producer = new Thread(() -> {
            while (true) {
                try {
                    // 队列不满时持续生成
                    if (idQueue.size() < 8000) {
                        Long id = (Long) snowflake.nextId(null);
                        idQueue.put(id);
                    } else {
                        // 队列快满了，休息一下
                        Thread.sleep(10);
                    }
                } catch (Exception e) {
                    // 记录异常，继续生成
                }
            }
        });
        
        producer.setDaemon(true);
        producer.start();
    }
    
    @Override
    public Number nextId(Object entity) {
        try {
            // 从队列获取预生成的ID（非常快）
            return idQueue.poll(100, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            // 获取失败，降级到实时生成
            return snowflake.nextId(entity);
        }
    }
}
```

**性能提升效果**：
```
优化前：同步生成ID
• 10万TPS：CPU 90%，响应时间 70ms

优化后：预生成ID
• 10万TPS：CPU 45%，响应时间 8ms
• 提升8倍性能！
```

### 7.3 号段模式优化


**号段模式原理**：

```
传统方式：每次生成1个ID
号段模式：每次申请1000个ID，本地慢慢用

示例流程：
1. 应用启动时从Redis申请号段：[1000, 2000)
2. 本地变量从1000开始递增分配
3. 用到1900时，异步申请下一个号段：[2000, 3000)
4. 继续分配，无缝衔接

优势：
• 减少Redis访问频率（1000次变1次）
• 本地分配速度极快（内存操作）
• 双buffer机制，无等待
```

**实现代码**：

```java
@Component
public class SegmentIdGenerator implements IdentifierGenerator {
    
    @Autowired
    private RedisTemplate<String, Long> redisTemplate;
    
    // 当前号段
    private Segment currentSegment;
    // 下一号段（预加载）
    private Segment nextSegment;
    
    // 号段大小
    private static final int SEGMENT_SIZE = 1000;
    // 提前加载阈值（用到90%时加载下一段）
    private static final double LOAD_THRESHOLD = 0.9;
    
    @Override
    public synchronized Number nextId(Object entity) {
        // 首次使用，加载当前号段
        if (currentSegment == null) {
            currentSegment = loadSegmentFromRedis();
        }
        
        // 检查是否需要预加载下一号段
        if (shouldLoadNext() && nextSegment == null) {
            CompletableFuture.runAsync(() -> {
                nextSegment = loadSegmentFromRedis();
            });
        }
        
        // 当前号段用完，切换到下一号段
        if (currentSegment.isExhausted()) {
            if (nextSegment == null) {
                // 下一号段还没准备好，同步等待
                nextSegment = loadSegmentFromRedis();
            }
            currentSegment = nextSegment;
            nextSegment = null;
        }
        
        // 从当前号段分配ID
        return currentSegment.nextId();
    }
    
    /**
     * 从Redis获取新号段
     */
    private Segment loadSegmentFromRedis() {
        String key = "id:segment:order";
        
        // 原子操作：递增SEGMENT_SIZE
        Long start = redisTemplate.opsForValue()
            .increment(key, SEGMENT_SIZE);
        
        long end = start;
        start = start - SEGMENT_SIZE;
        
        return new Segment(start, end);
    }
    
    /**
     * 判断是否应该预加载下一号段
     */
    private boolean shouldLoadNext() {
        double usage = currentSegment.getUsageRate();
        return usage >= LOAD_THRESHOLD;
    }
    
    /**
     * 号段对象
     */
    private static class Segment {
        private long start;
        private long end;
        private AtomicLong current;
        
        public Segment(long start, long end) {
            this.start = start;
            this.end = end;
            this.current = new AtomicLong(start);
        }
        
        public long nextId() {
            return current.getAndIncrement();
        }
        
        public boolean isExhausted() {
            return current.get() >= end;
        }
        
        public double getUsageRate() {
            return (current.get() - start) / (double)(end - start);
        }
    }
}
```

### 7.4 降级与容错策略


**多级降级方案**：

```java
@Component
public class RobustIdGenerator implements IdentifierGenerator {
    
    @Autowired
    private RedisTemplate<String, Long> redisTemplate;
    
    // 本地雪花算法（最后的降级方案）
    private SnowflakeIdGenerator localGenerator = new SnowflakeIdGenerator(1, 1);
    
    @Override
    public Number nextId(Object entity) {
        try {
            // 优先级1：从Redis号段获取
            return getIdFromRedisSegment();
            
        } catch (Exception e1) {
            try {
                // 优先级2：直接从Redis自增获取
                return redisTemplate.opsForValue()
                    .increment("id:backup", 1);
                    
            } catch (Exception e2) {
                // 优先级3：降级到本地雪花算法
                log.warn("Redis不可用，降级到本地生成ID");
                return localGenerator.nextId(entity);
            }
        }
    }
}
```

**熔断机制**：

```java
// 使用Resilience4j熔断器
@CircuitBreaker(name = "idGenerator", fallbackMethod = "fallbackId")
public Long generateId() {
    // 正常的ID生成逻辑
    return redisIdGenerator.nextId();
}

// 降级方法
public Long fallbackId(Exception e) {
    // 使用本地生成器
    return localSnowflake.nextId();
}
```

---

## 8. 📋 核心要点总结


### 8.1 分布式ID必知必会


**核心概念总结**：

```
✅ 全局唯一性：整个系统中ID绝对不重复
✅ 趋势递增：有利于数据库索引，避免页分裂
✅ 高性能：本地生成优于远程调用
✅ 高可用：多重降级保障服务稳定
```

**ID策略选择决策**：

| 场景 | **推荐策略** | **原因** |
|------|------------|---------|
| 单机应用 | `AUTO` | 简单，数据库原生支持 |
| 分布式高性能 | `ASSIGN_ID` | 雪花算法，性能最佳 |
| 需要业务语义 | 自定义生成器 | 灵活可控 |
| UUID可接受 | `ASSIGN_UUID` | 实现简单，全局唯一 |

### 8.2 关键技术点回顾


**雪花算法核心**：
```
64位ID = 1bit符号 + 41bit时间戳 + 10bit机器ID + 12bit序列号

优势：本地生成、高性能、趋势递增
注意：需要配置唯一的机器ID
```

**ID回填机制**：
```
插入前生成ID → 反射设置到对象 → 执行INSERT → 对象已包含ID
```

**性能优化手段**：
```
• 批量预生成：空间换时间
• 号段模式：减少网络调用
• 多级降级：保障高可用
```

### 8.3 生产环境最佳实践


**配置检查清单**：

- ☑️ 集群环境配置唯一的workerId
- ☑️ 实现时钟回拨检测和处理
- ☑️ 配置ID冲突重试机制
- ☑️ 实现降级和容错策略
- ☑️ 监控ID生成性能指标
- ☑️ 定期检查序列号使用情况

**常见问题排查**：

```
问题1：ID重复
→ 检查机器ID是否冲突
→ 检查是否发生时钟回拨
→ 查看序列号是否溢出

问题2：性能下降
→ 检查锁竞争情况
→ 考虑批量预生成
→ 启用号段模式

问题3：服务不可用
→ 检查降级策略是否生效
→ 验证本地生成器是否正常
→ 查看熔断器状态
```

### 8.4 记忆要点


**口诀记忆**：
```
分布式ID要唯一，趋势递增索引优
雪花算法性能好，机器ID别重复
号段模式减调用，预生成空间换时间
降级容错保可用，监控告警不可少
```

**核心公式**：
```
雪花ID = (时间戳 << 22) | (机器ID << 12) | 序列号
号段分配 = Redis自增 + 本地递增
性能优化 = 批量预生成 + 异步加载 + 多级降级
```