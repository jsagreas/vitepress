---
title: 26、链式更新操作
---
## 📚 目录

1. [什么是链式更新](#1-什么是链式更新)
2. [update链式更新基础](#2-update链式更新基础)
3. [lambdaUpdate安全更新](#3-lambdaUpdate安全更新)
4. [条件更新链式操作](#4-条件更新链式操作)
5. [链式调用的核心优势](#5-链式调用的核心优势)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔗 什么是链式更新


### 1.1 传统更新方式的问题


**传统做法**：先构建条件，再执行更新
```java
// 传统方式：分步骤操作
User user = new User();
user.setAge(25);
user.setSalary(8000);

UpdateWrapper<User> wrapper = new UpdateWrapper<>();
wrapper.eq("dept_id", 101);
wrapper.gt("age", 20);

userMapper.update(user, wrapper);
```

**存在的问题**：
```
❌ 步骤分散：需要先创建对象，再设置条件
❌ 代码冗余：多个变量定义，代码量大
❌ 可读性差：逻辑不连贯，难以理解
❌ 易出错：字段名写错不会编译报错
```

### 1.2 链式更新是什么


**核心概念**：将多个操作连接成一条"链子"，一气呵成完成更新

```
传统方式：                     链式方式：
步骤1：创建对象                userService
  ↓                              .update()
步骤2：设置值                     .set(字段, 值)
  ↓                              .eq(条件字段, 值)
步骤3：构建条件                   .update();
  ↓
步骤4：执行更新

就像：                         就像：
买菜→洗菜→切菜→炒菜           买菜.洗().切().炒() ✓
```

**链式更新的本质**：
> 💡 **通俗理解**：就像多米诺骨牌，一个方法调用完自动返回对象本身，可以继续调用下一个方法，形成连续操作

---

## 2. ⚙️ update链式更新基础


### 2.1 基本语法结构


**核心方法**：`update()`
```java
// 基础结构
userService
    .update()                    // 开始链式更新
    .set(字段, 新值)              // 设置要更新的字段
    .eq(条件字段, 条件值)         // 添加更新条件
    .update();                   // 执行更新

// 实际示例
userService
    .update()
    .set("age", 25)              // 将年龄改为25
    .eq("id", 1001)              // 条件：用户ID为1001
    .update();                   // 执行更新
```

**方法说明**：

| 方法 | 作用 | 说明 |
|------|------|------|
| `.update()` | 开启链式 | 返回更新链对象，可继续链式调用 |
| `.set(字段, 值)` | 设置字段 | 指定要更新的字段和新值 |
| `.eq/ne/gt...` | 添加条件 | 设置WHERE条件 |
| `.update()` | 执行更新 | 真正执行SQL更新操作 |

### 2.2 常用更新场景


**场景1：单字段更新**
```java
// 需求：将ID为1001的用户状态改为激活
userService
    .update()
    .set("status", 1)            // 设置状态为1（激活）
    .eq("id", 1001)              // 指定用户ID
    .update();

// 生成SQL：
// UPDATE user SET status = 1 WHERE id = 1001
```

**场景2：多字段更新**
```java
// 需求：更新用户的年龄和工资
userService
    .update()
    .set("age", 26)              // 更新年龄
    .set("salary", 9000)         // 更新工资
    .eq("id", 1001)
    .update();

// 生成SQL：
// UPDATE user SET age = 26, salary = 9000 WHERE id = 1001
```

**场景3：批量更新**
```java
// 需求：将所有技术部门员工的工资增加1000
userService
    .update()
    .setSql("salary = salary + 1000")  // 使用SQL表达式
    .eq("dept_name", "技术部")
    .update();

// 生成SQL：
// UPDATE user SET salary = salary + 1000 WHERE dept_name = '技术部'
```

### 2.3 执行流程图示


```
链式更新执行流程：

userService.update()
    ↓
┌─────────────────────┐
│ 1. 创建更新链对象    │
└─────────────────────┘
    ↓
    .set("age", 25)
    ↓
┌─────────────────────┐
│ 2. 记录要更新的字段  │
│    SET age = 25     │
└─────────────────────┘
    ↓
    .eq("id", 1001)
    ↓
┌─────────────────────┐
│ 3. 记录WHERE条件     │
│    WHERE id = 1001  │
└─────────────────────┘
    ↓
    .update()
    ↓
┌─────────────────────┐
│ 4. 拼装SQL并执行     │
│    UPDATE user      │
│    SET age = 25     │
│    WHERE id = 1001  │
└─────────────────────┘
```

---

## 3. 🔒 lambdaUpdate安全更新


### 3.1 为什么需要Lambda更新


**传统update的隐患**：字段名是字符串，容易写错
```java
// 问题代码
userService
    .update()
    .set("agee", 25)             // ❌ 字段名写错了！
    .eq("idd", 1001)             // ❌ 又写错了！
    .update();

// 编译通过 ✓ 但运行报错 ✗
// 错误：Unknown column 'agee' in 'field list'
```

**Lambda更新的优势**：使用方法引用，编译期检查
```java
// 安全代码
userService
    .lambdaUpdate()
    .set(User::getAge, 25)       // ✓ IDE会检查方法是否存在
    .eq(User::getId, 1001)       // ✓ 字段类型自动匹配
    .update();

// 如果写错，编译就报错 ✓
// .set(User::getAgee, 25)       // ❌ 编译错误：找不到方法
```

> 💡 **通俗理解**：Lambda就像导航仪，直接指向目标；字符串就像手写地址，容易写错

### 3.2 Lambda更新语法


**基本用法**：
```java
// 语法结构
userService
    .lambdaUpdate()                          // 开启Lambda链式
    .set(实体类::get方法, 新值)               // 设置字段
    .eq(实体类::get方法, 条件值)              // 添加条件
    .update();                               // 执行更新

// 实际示例
userService
    .lambdaUpdate()
    .set(User::getAge, 26)                   // 更新年龄
    .set(User::getSalary, 9000)              // 更新工资
    .eq(User::getId, 1001)                   // 条件：ID
    .update();
```

**Lambda方法引用说明**：
```
User::getAge  含义解析：
  ↓      ↓
实体类  get方法

实际对应：
User::getAge    → 对应数据库字段 age
User::getName   → 对应数据库字段 name  
User::getSalary → 对应数据库字段 salary

原理：框架自动将 getAge 转换为 age 字段名
```

### 3.3 Lambda更新的类型安全


**类型自动匹配**：
```java
// 示例1：整数类型
userService
    .lambdaUpdate()
    .set(User::getAge, 25)       // ✓ age是Integer，25自动匹配
    .set(User::getAge, "25")     // ❌ 编译错误：类型不匹配
    .update();

// 示例2：日期类型
userService
    .lambdaUpdate()
    .set(User::getBirthday, new Date())          // ✓ 类型正确
    .set(User::getBirthday, "2000-01-01")        // ❌ 类型错误
    .update();
```

**对比表格**：

| 特性 | update() | lambdaUpdate() |
|------|----------|----------------|
| **字段指定** | `字符串 "age"` | `方法引用 User::getAge` |
| **编译检查** | ❌ 无检查 | ✓ 编译期检查 |
| **类型安全** | ❌ 运行时才知道 | ✓ 编译期保证 |
| **IDE支持** | ❌ 无提示 | ✓ 自动补全 |
| **重构友好** | ❌ 改字段名需手动改字符串 | ✓ 自动同步修改 |

> ⚠️ **最佳实践**：在实际项目中，推荐始终使用`lambdaUpdate()`，避免字段名错误

---

## 4. 🎯 条件更新链式操作


### 4.1 常用条件方法


**等值条件**：
```java
// eq：等于
userService
    .lambdaUpdate()
    .set(User::getStatus, 1)
    .eq(User::getId, 1001)              // WHERE id = 1001
    .update();

// ne：不等于
userService
    .lambdaUpdate()
    .set(User::getStatus, 0)
    .ne(User::getDeptId, 101)           // WHERE dept_id != 101
    .update();
```

**范围条件**：
```java
// gt/ge：大于/大于等于
userService
    .lambdaUpdate()
    .set(User::getLevel, "高级")
    .gt(User::getAge, 30)               // WHERE age > 30
    .update();

// lt/le：小于/小于等于
userService
    .lambdaUpdate()
    .set(User::getSalary, 5000)
    .le(User::getAge, 25)               // WHERE age <= 25
    .update();

// between：区间
userService
    .lambdaUpdate()
    .set(User::getLevel, "中级")
    .between(User::getAge, 25, 35)      // WHERE age BETWEEN 25 AND 35
    .update();
```

**模糊条件**：
```java
// like：模糊匹配
userService
    .lambdaUpdate()
    .set(User::getStatus, 1)
    .like(User::getName, "张")          // WHERE name LIKE '%张%'
    .update();

// likeLeft：左模糊
userService
    .lambdaUpdate()
    .set(User::getType, "VIP")
    .likeLeft(User::getPhone, "138")    // WHERE phone LIKE '%138'
    .update();
```

### 4.2 多条件组合


**AND条件**（默认）：
```java
// 需求：更新年龄大于25且部门为技术部的员工
userService
    .lambdaUpdate()
    .set(User::getSalary, 10000)
    .gt(User::getAge, 25)               // 条件1
    .eq(User::getDeptName, "技术部")    // 条件2（AND连接）
    .update();

// 生成SQL：
// UPDATE user 
// SET salary = 10000 
// WHERE age > 25 AND dept_name = '技术部'
```

**OR条件**：
```java
// 需求：更新技术部或产品部的员工
userService
    .lambdaUpdate()
    .set(User::getStatus, 1)
    .eq(User::getDeptName, "技术部")
    .or()                               // OR连接符
    .eq(User::getDeptName, "产品部")
    .update();

// 生成SQL：
// UPDATE user 
// SET status = 1 
// WHERE dept_name = '技术部' OR dept_name = '产品部'
```

**复杂条件嵌套**：
```java
// 需求：更新(年龄>30的技术部) 或 (工资>8000的产品部) 员工
userService
    .lambdaUpdate()
    .set(User::getLevel, "高级")
    .and(wrapper -> wrapper             // 嵌套条件组1
        .gt(User::getAge, 30)
        .eq(User::getDeptName, "技术部")
    )
    .or(wrapper -> wrapper              // 嵌套条件组2
        .gt(User::getSalary, 8000)
        .eq(User::getDeptName, "产品部")
    )
    .update();

// 生成SQL：
// UPDATE user 
// SET level = '高级'
// WHERE (age > 30 AND dept_name = '技术部') 
//    OR (salary > 8000 AND dept_name = '产品部')
```

### 4.3 动态条件更新


**根据条件动态添加**：
```java
// 需求：根据参数动态构建更新条件
public void updateUserDynamic(Integer age, String deptName) {
    userService
        .lambdaUpdate()
        .set(User::getStatus, 1)
        .gt(age != null, User::getAge, age)           // age不为null才添加
        .eq(deptName != null, User::getDeptName, deptName)  // 同上
        .update();
}

// 调用示例
updateUserDynamic(25, "技术部");    // 两个条件都生效
updateUserDynamic(null, "技术部");  // 只有部门条件生效
updateUserDynamic(25, null);        // 只有年龄条件生效
```

**条件判断流程**：
```
方法调用：.gt(age != null, User::getAge, age)
           ↓
       判断条件
           ↓
    ┌─────┴─────┐
    ↓           ↓
age != null   age == null
    ↓           ↓
  添加条件     忽略此条件
    ↓           ↓
WHERE age>25  （不添加）
```

---

## 5. ⭐ 链式调用的核心优势


### 5.1 代码可读性对比


**传统方式 vs 链式方式**：

```java
// ❌ 传统方式：分散、冗长
User user = new User();
user.setAge(26);
user.setSalary(9000);

UpdateWrapper<User> wrapper = new UpdateWrapper<>();
wrapper.eq("dept_id", 101);
wrapper.gt("age", 25);
wrapper.lt("salary", 10000);

int result = userMapper.update(user, wrapper);

// ✓ 链式方式：连贯、简洁
userService
    .lambdaUpdate()
    .set(User::getAge, 26)
    .set(User::getSalary, 9000)
    .eq(User::getDeptId, 101)
    .gt(User::getAge, 25)
    .lt(User::getSalary, 10000)
    .update();
```

**可读性提升**：
```
传统方式的问题：
📝 需要定义多个变量
📝 逻辑分散在多处
📝 需要记住变量名
📝 容易漏写条件

链式方式的优势：
✓ 一条链完成所有操作
✓ 从上到下顺序阅读
✓ 无需中间变量
✓ 一目了然
```

### 5.2 方法链组合优势


**灵活组合示例**：
```java
// 场景1：简单更新
userService
    .lambdaUpdate()
    .set(User::getStatus, 1)
    .eq(User::getId, 1001)
    .update();

// 场景2：复杂更新（相同的链式风格）
userService
    .lambdaUpdate()
    .set(User::getAge, 26)
    .set(User::getSalary, 9000)
    .set(User::getLevel, "高级")
    .gt(User::getAge, 25)
    .eq(User::getDeptName, "技术部")
    .isNotNull(User::getEmail)
    .update();

// 场景3：带函数的更新
userService
    .lambdaUpdate()
    .setSql("salary = salary * 1.1")    // 工资增加10%
    .setSql("score = score + 10")       // 分数增加10分
    .eq(User::getDeptId, 101)
    .update();
```

**组合规则**：
```
链式方法组合规则：

1. 开始方法
   └─ update() 或 lambdaUpdate()

2. 设置方法（可多个）
   ├─ set(字段, 值)
   ├─ setSql(SQL表达式)
   └─ ...

3. 条件方法（可多个）
   ├─ eq/ne/gt/lt...
   ├─ like/between...
   └─ and/or...

4. 执行方法
   └─ update()

任意组合，顺序灵活 ✓
```

### 5.3 维护性优势


**场景：需求变更**
```java
// 原需求：更新年龄
userService
    .lambdaUpdate()
    .set(User::getAge, 26)
    .eq(User::getId, 1001)
    .update();

// 需求变更：同时更新工资（只需加一行）
userService
    .lambdaUpdate()
    .set(User::getAge, 26)
    .set(User::getSalary, 9000)        // ← 新增一行
    .eq(User::getId, 1001)
    .update();

// 再次变更：增加条件（继续加一行）
userService
    .lambdaUpdate()
    .set(User::getAge, 26)
    .set(User::getSalary, 9000)
    .eq(User::getId, 1001)
    .gt(User::getAge, 20)              // ← 新增条件
    .update();
```

> 💡 **维护优势**：新增、修改、删除字段或条件，只需增删相应的链式方法，不影响整体结构

### 5.4 性能优势


**执行效率**：
```
链式调用的性能特点：

1. 编译优化
   └─ 链式调用会被编译器优化，无额外开销

2. 对象复用
   └─ 内部复用同一个构造器对象，减少创建

3. SQL生成
   └─ 最终只生成一条SQL，与传统方式相同

性能对比：
传统方式  ≈  链式方式  （几乎无差异）
          
链式方式额外收益：
✓ 代码更简洁，减少维护成本
✓ 减少中间变量，降低内存占用
✓ 类型安全，减少运行时错误
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 链式更新：多个操作连成一条链，一气呵成
🔸 update()：字符串方式，简单但不够安全
🔸 lambdaUpdate()：Lambda方式，类型安全推荐使用
🔸 条件方法：eq/ne/gt/lt/like等灵活组合
🔸 执行流程：开始→设置→条件→执行
```

### 6.2 关键对比总结


| 对比项 | 传统方式 | 链式方式 |
|--------|----------|----------|
| **代码行数** | 多（需定义多个变量） | 少（一条链完成） |
| **可读性** | 差（逻辑分散） | 好（顺序阅读） |
| **类型安全** | 弱（字符串字段名） | 强（Lambda方法引用） |
| **维护性** | 差（修改多处） | 好（只改链上一环） |
| **IDE支持** | 弱（无提示） | 强（自动补全） |

### 6.3 最佳实践建议


> 📌 **推荐做法**：
> - 优先使用`lambdaUpdate()`而非`update()`
> - 简单条件直接链式，复杂条件用嵌套
> - 动态条件用布尔值判断
> - 保持链式调用的可读性，必要时换行

> ⚠️ **避免陷阱**：
> - 不要忘记最后调用`.update()`执行
> - Lambda方法引用必须是`get`开头
> - 多条件组合注意`and()`和`or()`的使用
> - 动态条件第一个参数是布尔判断

### 6.4 实战记忆口诀


```
🧠 链式更新记忆法：

开头方法选对路，update或lambda随你走
设置字段用set加，条件方法跟着插
eq ne gt lt要记牢，like between也常用
最后别忘update跑，一条链子全搞定

Lambda更新更安全，方法引用编译检
字段类型自动配，重构维护不用愁
```

**核心记忆**：
- 链式更新 = 连续调用 = 一条龙服务
- Lambda = 安全 + 类型检查 + IDE友好
- 灵活组合 = 简单场景简单写 + 复杂场景嵌套用
- 最佳实践 = 用Lambda + 保持可读 + 记得执行