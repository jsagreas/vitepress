---
title: 28、一级缓存详解
---
## 📚 目录

1. [一级缓存是什么](#1-一级缓存是什么)
2. [Session缓存原理](#2-Session缓存原理)
3. [快照机制](#3-快照机制)
4. [脏检查机制](#4-脏检查机制)
5. [缓存清理](#5-缓存清理)
6. [flush刷新缓存](#6-flush刷新缓存)
7. [缓存管理方法](#7-缓存管理方法)
8. [性能影响与优化](#8-性能影响与优化)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 一级缓存是什么


### 1.1 生活化理解


**想象这个场景：**
```
你去图书馆借书：
第一次借《Java编程》→ 去书架找（查数据库）→ 放在你桌上
第二次要看这本书 → 直接从桌上拿（用缓存）→ 不用再跑书架

你的桌子 = Hibernate的一级缓存
书架 = 数据库
```

### 1.2 专业定义


**一级缓存（First Level Cache）**：Hibernate在Session级别提供的内置缓存机制

🔸 **核心特点**
- **自动开启**：不需要任何配置，默认就有
- **Session级别**：每个Session有自己独立的缓存
- **生命周期**：Session创建时开始，Session关闭时销毁
- **透明使用**：开发者不需要手动操作

### 1.3 为什么需要一级缓存


**解决的问题：**

```
❌ 没有缓存的情况：
User user1 = session.get(User.class, 1L);  // 查询数据库
User user2 = session.get(User.class, 1L);  // 又查询数据库
User user3 = session.get(User.class, 1L);  // 再查询数据库

同一个用户查了3次数据库！浪费资源！

✅ 有一级缓存的情况：
User user1 = session.get(User.class, 1L);  // 查询数据库，放入缓存
User user2 = session.get(User.class, 1L);  // 直接从缓存拿
User user3 = session.get(User.class, 1L);  // 直接从缓存拿

只查了1次数据库！
```

**带来的好处：**
- 🚀 **减少数据库访问**：同一个对象只查一次
- ⚡ **提升性能**：内存访问比数据库快几千倍
- 🔄 **保证一致性**：同一Session内，同一对象只有一个实例

---

## 2. 🏗️ Session缓存原理


### 2.1 缓存的本质


**一级缓存就是一个Map：**

```
Session内部结构（简化理解）：
┌─────────────────────────────┐
│         Session             │
├─────────────────────────────┤
│ persistenceContext (缓存)   │
│    ↓                        │
│  Map<EntityKey, Entity>     │
│    │                        │
│    ├─ User#1 → User对象1    │
│    ├─ User#2 → User对象2    │
│    └─ Order#5 → Order对象   │
└─────────────────────────────┘

EntityKey = 实体类 + 主键值
```

### 2.2 缓存的工作流程


```
查询对象的完整过程：

步骤1：调用get()或load()
   ↓
步骤2：先去一级缓存找
   ├─ 找到了 → 直接返回（缓存命中）
   └─ 没找到 → 继续下一步
   ↓
步骤3：查询数据库
   ↓
步骤4：将查询结果放入缓存
   ↓
步骤5：返回对象
```

### 2.3 实际案例演示


```java
// 案例：同一个Session内多次查询
Session session = sessionFactory.openSession();

// 第一次查询 - 会查数据库
User user1 = session.get(User.class, 1L);
System.out.println("第一次查询：" + user1.getName());
// 输出SQL：SELECT * FROM user WHERE id = 1

// 第二次查询 - 从缓存拿，不查数据库
User user2 = session.get(User.class, 1L);
System.out.println("第二次查询：" + user2.getName());
// 没有SQL输出

// 验证是同一个对象
System.out.println(user1 == user2);  // true（同一个对象引用）

session.close();
```

💡 **关键理解**
- `user1`和`user2`是**同一个Java对象**
- 修改`user1`，`user2`也会变化（因为是同一个对象）
- 第二次查询**完全不访问数据库**

---

## 3. 📸 快照机制


### 3.1 什么是快照


**通俗理解：**
```
快照 = 给对象拍照存档

你从数据库拿到User对象时：
原始状态：name="张三", age=25

Hibernate做两件事：
1. 把User对象放入缓存（当前数据）
2. 拍个照片存起来（原始状态的副本）

这个照片就是"快照"
```

### 3.2 快照的作用


**核心目的：对比数据是否被修改**

```
对象生命周期：

加载时刻：
  User对象：name="张三"
  快照：    name="张三"     两者一致

修改后：
  User对象：name="李四"     ← 被修改了
  快照：    name="张三"     ← 保持原样

提交时刻：
  对比发现：对象 ≠ 快照
  结论：数据被修改了（脏数据）
  动作：生成UPDATE语句
```

### 3.3 快照的存储位置


```
Session的内部结构：

┌──────────────────────────────┐
│         Session              │
├──────────────────────────────┤
│ 实体缓存 (当前状态)           │
│   User#1 → {name:"李四"}     │
├──────────────────────────────┤
│ 快照区 (原始状态)             │
│   User#1 → {name:"张三"}     │
└──────────────────────────────┘

每个对象都有两份数据：
- 当前状态（可以被修改）
- 原始快照（用来对比）
```

---

## 4. 🔍 脏检查机制


### 4.1 脏数据是什么


**脏数据（Dirty Data）**：被修改过但还没同步到数据库的数据

```
干净数据 vs 脏数据：

干净数据：
  对象状态 = 数据库状态 = 快照状态
  不需要更新数据库

脏数据：
  对象状态 ≠ 快照状态
  需要更新数据库
```

### 4.2 脏检查的工作原理


**Dirty Check（脏检查）**：自动检测对象是否被修改

```
脏检查的时机：
1. session.flush() 被调用时
2. 事务提交时（transaction.commit()）
3. 执行查询前（某些情况下）

检查过程：
┌─────────────────────────────┐
│ 遍历Session中的所有对象      │
├─────────────────────────────┤
│ 对比：当前状态 vs 快照       │
├─────────────────────────────┤
│ 发现差异 → 标记为脏数据      │
├─────────────────────────────┤
│ 生成UPDATE语句               │
├─────────────────────────────┤
│ 执行SQL更新数据库            │
└─────────────────────────────┘
```

### 4.3 脏检查实例


```java
// 案例：自动更新数据
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// 1. 加载对象（创建快照）
User user = session.get(User.class, 1L);
System.out.println("原始姓名：" + user.getName());  // 张三

// 2. 修改对象（产生脏数据）
user.setName("李四");
user.setAge(30);

// 3. 提交事务（触发脏检查）
tx.commit();  
// Hibernate自动执行：UPDATE user SET name='李四', age=30 WHERE id=1

session.close();
```

💡 **神奇之处**
- **没有调用update()方法**
- Hibernate**自动检测**到修改
- **自动生成**并执行UPDATE语句

### 4.4 脏检查的判断规则


| 情况 | 对象状态 | 快照状态 | 是否脏数据 | Hibernate操作 |
|------|----------|----------|------------|---------------|
| 刚加载 | `name="张三"` | `name="张三"` | ❌ 否 | 无操作 |
| 修改后 | `name="李四"` | `name="张三"` | ✅ 是 | 生成UPDATE |
| 改回原值 | `name="张三"` | `name="张三"` | ❌ 否 | 无操作 |
| 删除对象 | 标记删除 | `name="张三"` | 🗑️ 删除 | 生成DELETE |

---

## 5. 🧹 缓存清理


### 5.1 为什么要清理缓存


**缓存的问题：**

```
问题1：内存占用
  加载1000个对象 → 缓存里1000个对象 → 占用大量内存

问题2：数据过期
  其他程序修改了数据库 → 缓存里的数据就过期了

问题3：长时间Session
  Session开太久 → 缓存越积越多 → 内存溢出
```

### 5.2 清理缓存的方法


**方法1：清空整个缓存**

```java
// clear() - 清空所有缓存对象
Session session = sessionFactory.openSession();

User user1 = session.get(User.class, 1L);  // 查数据库，放入缓存
User user2 = session.get(User.class, 2L);  // 查数据库，放入缓存

session.clear();  // 清空缓存

User user3 = session.get(User.class, 1L);  // 又要查数据库了！
// 因为缓存被清空了
```

**方法2：移除单个对象**

```java
// evict() - 移除指定对象
Session session = sessionFactory.openSession();

User user = session.get(User.class, 1L);  // 对象在缓存中

session.evict(user);  // 把这个对象从缓存移除

User user2 = session.get(User.class, 1L);  // 重新查数据库
// user 和 user2 是不同的对象
```

### 5.3 清理时机选择


**适合清理缓存的场景：**

✅ **批量操作时：**
```java
for (int i = 0; i < 10000; i++) {
    User user = new User();
    session.save(user);
    
    if (i % 20 == 0) {
        session.flush();   // 刷新到数据库
        session.clear();   // 清理缓存
    }
}
```

✅ **长时间Session：** 定期清理，防止内存溢出

❌ **不适合清理：** 短时间内重复查询同一对象

---

## 6. 💧 flush刷新缓存


### 6.1 flush是什么


**通俗理解：**
```
缓存是个"草稿箱"：
- 你修改对象 → 先记在草稿箱（缓存）
- flush操作 → 把草稿箱内容抄到正式本（数据库）

flush = 同步缓存到数据库
```

### 6.2 flush的触发时机


**自动flush的情况：**

```
时机1：事务提交时
  tx.commit() → 自动flush → 然后提交

时机2：执行查询前（某些情况）
  session.createQuery("FROM User").list();
  // 执行查询前，先flush确保数据最新

时机3：手动调用
  session.flush();
```

### 6.3 flush的工作过程


```
flush的执行步骤：

步骤1：遍历缓存中的所有对象
   ↓
步骤2：执行脏检查
   ├─ 新增对象 → 生成INSERT
   ├─ 修改对象 → 生成UPDATE
   └─ 删除对象 → 生成DELETE
   ↓
步骤3：按顺序执行SQL
   ↓
步骤4：同步快照（更新快照为最新状态）
```

### 6.4 flush实例


```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// 1. 加载对象
User user = session.get(User.class, 1L);

// 2. 修改对象（只在缓存中修改）
user.setName("王五");
System.out.println("修改后，数据库还没变化");

// 3. 手动flush（立即同步到数据库）
session.flush();  
// 执行：UPDATE user SET name='王五' WHERE id=1
System.out.println("现在数据库已经更新了");

// 4. 继续其他操作...

tx.commit();  // 提交事务
session.close();
```

💡 **flush vs commit 的区别**

| 操作 | 作用 | 是否提交事务 |
|------|------|--------------|
| `flush()` | 同步缓存到数据库 | ❌ 不提交 |
| `commit()` | 先flush，再提交事务 | ✅ 提交 |

```
flush()：把改动写到数据库，但可以回滚
commit()：确认改动，不能回滚
```

---

## 7. 🛠️ 缓存管理方法


### 7.1 核心管理方法


**方法速查表：**

| 方法 | 作用 | 使用场景 |
|------|------|----------|
| `flush()` | 同步缓存到数据库 | 立即保存修改 |
| `clear()` | 清空所有缓存对象 | 批量操作、释放内存 |
| `evict(Object)` | 移除指定对象 | 移除过期数据 |
| `refresh(Object)` | 重新加载对象 | 获取最新数据 |
| `contains(Object)` | 检查对象是否在缓存 | 判断缓存状态 |

### 7.2 refresh()重新加载


```java
// refresh() - 从数据库重新加载对象
Session session = sessionFactory.openSession();

User user = session.get(User.class, 1L);  // 加载对象
System.out.println("原始：" + user.getName());  // 张三

// 假设这时候其他程序修改了数据库
// 数据库中name已经变成"赵六"了

session.refresh(user);  // 重新从数据库加载
System.out.println("刷新后：" + user.getName());  // 赵六
```

**使用场景：**
- 多个程序同时操作数据库
- 需要获取其他程序的最新修改
- 放弃当前修改，恢复数据库状态

### 7.3 contains()检查缓存


```java
Session session = sessionFactory.openSession();

User user = session.get(User.class, 1L);
System.out.println(session.contains(user));  // true（在缓存中）

session.evict(user);  // 移除缓存
System.out.println(session.contains(user));  // false（不在缓存中了）
```

### 7.4 实际应用案例


**案例：批量导入数据**

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// 导入10000条数据
for (int i = 0; i < 10000; i++) {
    User user = new User("用户" + i);
    session.save(user);  // 对象会进入缓存
    
    // 每20条就清理一次缓存
    if (i % 20 == 0) {
        session.flush();   // 同步到数据库
        session.clear();   // 清空缓存，释放内存
    }
}

tx.commit();
session.close();
```

💡 **为什么要定期清理：**
- 10000个对象都在缓存 → 占用大量内存
- 定期flush+clear → 保持内存占用稳定

---

## 8. 📈 性能影响与优化


### 8.1 一级缓存的性能优势


**性能对比：**

```
场景：循环查询同一个用户

❌ 没有缓存（假设）：
for (int i = 0; i < 100; i++) {
    User user = 从数据库查询(1L);  // 查询100次数据库
}
耗时：约 1000ms

✅ 有一级缓存：
for (int i = 0; i < 100; i++) {
    User user = session.get(User.class, 1L);  // 只第一次查数据库
}
耗时：约 10ms

性能提升：100倍！
```

### 8.2 性能优化技巧


**技巧1：合理使用批量操作**

```java
// 优化前：每次都触发脏检查
for (User user : users) {
    user.setStatus("active");
    session.update(user);  // 每次都检查
}

// 优化后：批量处理
for (int i = 0; i < users.size(); i++) {
    users.get(i).setStatus("active");
    
    if (i % 50 == 0) {
        session.flush();   // 批量刷新
        session.clear();   // 清理缓存
    }
}
```

**技巧2：只读数据不放缓存**

```java
// 只查询不修改的数据
Query query = session.createQuery("FROM User");
query.setReadOnly(true);  // 标记为只读
List<User> users = query.list();

// 只读对象不会进行脏检查，提升性能
```

### 8.3 常见性能陷阱


**陷阱1：N+1查询问题**

```java
// ❌ 糟糕的写法
List<Order> orders = session.createQuery("FROM Order").list();  // 1次查询
for (Order order : orders) {
    User user = order.getUser();  // 每个订单查一次用户，N次查询
}
// 总共：1 + N 次查询

// ✅ 优化：使用JOIN FETCH
List<Order> orders = session.createQuery(
    "FROM Order o JOIN FETCH o.user"
).list();  // 1次查询搞定
```

**陷阱2：缓存溢出**

```java
// ❌ 危险操作
Session session = sessionFactory.openSession();
for (int i = 0; i < 1000000; i++) {
    User user = session.get(User.class, i);  // 100万个对象进缓存
}
// 结果：内存溢出！

// ✅ 正确做法
Session session = sessionFactory.openSession();
for (int i = 0; i < 1000000; i++) {
    User user = session.get(User.class, i);
    // 处理...
    
    if (i % 100 == 0) {
        session.clear();  // 定期清理
    }
}
```

### 8.4 性能监控指标


📊 **关键指标：**

```
缓存命中率：
命中率 = 缓存命中次数 / 总查询次数

理想值：> 80%
偏低说明：缓存利用率不高

SQL执行次数：
理想：同一对象只查询1次
异常：同一对象多次查询 → 检查是否误清缓存

内存占用：
正常：稳定在合理范围
异常：持续增长 → 检查是否忘记清理缓存
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的概念


```
🔸 一级缓存本质：Session级别的Map，自动开启
🔸 快照机制：保存原始状态，用于脏检查
🔸 脏检查：自动对比对象与快照，生成UPDATE
🔸 flush操作：同步缓存到数据库，不提交事务
🔸 缓存管理：clear清空，evict移除，refresh重载
```

### 9.2 关键理解要点


**生命周期关系：**

```
Session创建
   ↓
加载对象 → 放入缓存 + 创建快照
   ↓
修改对象 → 只改缓存，不改快照
   ↓
flush/commit → 脏检查 → 生成SQL → 更新快照
   ↓
Session关闭 → 缓存销毁
```

**核心记忆：**

```
一级缓存三要素：
1. 缓存（当前状态）- 可以修改
2. 快照（原始状态）- 用来对比
3. 脏检查（对比机制）- 自动更新
```

### 9.3 实际应用指南


**适用场景：**

✅ **适合使用一级缓存：**
- 同一Session内重复查询
- 对象关联关系导航
- 事务内的数据修改

❌ **需要注意的情况：**
- 大批量数据处理 → 定期clear
- 长时间Session → 定期flush+clear
- 分布式环境 → 可能数据不一致

**最佳实践模板：**

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

try {
    // 业务逻辑
    
    // 批量操作时定期清理
    if (/* 批量操作 */) {
        session.flush();
        session.clear();
    }
    
    tx.commit();
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    session.close();  // 确保关闭Session
}
```

---

## 🎯 学习检查清单


完成学习后，你应该能够回答：

- [ ] 一级缓存是什么？为什么需要它？
- [ ] 快照的作用是什么？
- [ ] 脏检查如何工作？何时触发？
- [ ] flush和commit的区别是什么？
- [ ] 如何避免缓存导致的内存溢出？
- [ ] 什么情况下需要清理缓存？

💡 **核心记忆口诀：**
```
一级缓存在Session，自动开启不用管
对象加载先缓存，快照机制记原样
修改对象只改缓存，脏检查时自动更新
flush同步到数据库，commit提交才生效
批量操作记得清，定期flush和clear
```

---

**🔗 相关知识点：**
- 上一节：对象状态详解
- 下一节：二级缓存机制
- 扩展阅读：Hibernate性能优化