---
title: 17、单表继承映射
---
## 📚 目录

1. [继承映射概述](#1-继承映射概述)
2. [单表继承策略](#2-单表继承策略)
3. [实战应用与选择](#3-实战应用与选择)
4. [核心要点总结](#4-核心要点总结)

---

## 1. 🎯 继承映射概述


### 1.1 什么是继承映射


**通俗理解**：在面向对象编程中，我们经常用继承来组织类的层次结构。但数据库表之间没有"继承"这个概念，那如何把Java中的继承关系保存到数据库呢？这就是继承映射要解决的问题。

```
现实场景：员工管理系统

Employee（员工基类）
   ├── FullTimeEmployee（全职员工）
   └── PartTimeEmployee（兼职员工）

问题：如何把这种继承关系映射到数据库表？
```

### 1.2 为什么需要继承映射


**实际需求**：
- 🔸 **代码复用**：子类继承父类的属性和方法，避免重复代码
- 🔸 **多态查询**：可以统一查询所有员工，也可以查询特定类型的员工
- 🔸 **业务建模**：真实反映业务中的继承关系

**核心挑战**：
```
面向对象世界          关系数据库世界
    类继承    ←→    表之间如何关联？
    多态      ←→    如何区分不同类型？
    共享属性  ←→    如何避免数据冗余？
```

### 1.3 Hibernate支持的三种策略


| 策略类型 | **存储方式** | **典型场景** | **特点** |
|---------|------------|------------|---------|
| 🔸 **单表继承** | `所有子类存一张表` | `子类差异小，查询频繁` | `性能好，有冗余字段` |
| 🔸 **表联合继承** | `每个类一张表，外键关联` | `子类差异大，规范要求高` | `规范，但查询需JOIN` |
| 🔸 **表独立继承** | `每个子类独立表，包含所有字段` | `子类完全独立` | `灵活，但数据可能重复` |

> **本章重点**：我们主要讲解最常用的**单表继承策略**，它简单、高效，适合大多数场景。

---

## 2. 📊 单表继承策略


### 2.1 核心概念理解


**什么是单表继承**：
把整个继承体系的所有类的数据都存储在一张表中，通过一个特殊的"类型字段"来区分不同的子类。

**形象比喻**：
```
就像一个大仓库存放不同种类的商品：

仓库表（Employee）：
┌────────┬──────┬────────┬─────────┬──────────┬───────────┐
│ 员工ID │ 姓名 │ 类型   │ 月薪    │ 时薪     │ 工作时长  │
├────────┼──────┼────────┼─────────┼──────────┼───────────┤
│ 1      │ 张三 │ FULL   │ 8000    │ null     │ null      │  ← 全职员工
│ 2      │ 李四 │ PART   │ null    │ 50       │ 160       │  ← 兼职员工
│ 3      │ 王五 │ FULL   │ 10000   │ null     │ null      │  ← 全职员工
└────────┴──────┴────────┴─────────┴──────────┴───────────┘

"类型"列就是鉴别器，用来区分是哪种员工
```

### 2.2 基础配置实现


**步骤一：创建实体类**

```java
// 父类：员工基类
@Entity
@Table(name = "employee")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)  // ← 声明使用单表继承
@DiscriminatorColumn(name = "emp_type", discriminatorType = DiscriminatorType.STRING)  // ← 鉴别器列
public abstract class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;  // 所有员工共有的属性
    
    // getter/setter省略
}
```

```java
// 子类1：全职员工
@Entity
@DiscriminatorValue("FULL")  // ← 这个类的鉴别器值是"FULL"
public class FullTimeEmployee extends Employee {
    
    private Double monthlySalary;  // 月薪（全职员工特有）
    
    // getter/setter省略
}
```

```java
// 子类2：兼职员工
@Entity
@DiscriminatorValue("PART")  // ← 这个类的鉴别器值是"PART"
public class PartTimeEmployee extends Employee {
    
    private Double hourlyRate;    // 时薪（兼职员工特有）
    private Integer hoursWorked;  // 工作时长
    
    // getter/setter省略
}
```

### 2.3 核心注解详解


**@Inheritance - 声明继承策略**
```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
```
- **作用**：告诉Hibernate使用哪种继承映射策略
- **位置**：标注在父类上
- **可选值**：
  - `SINGLE_TABLE`：单表继承（本章重点）
  - `JOINED`：表联合继承
  - `TABLE_PER_CLASS`：表独立继承

**@DiscriminatorColumn - 鉴别器列**
```java
@DiscriminatorColumn(
    name = "emp_type",                        // 数据库列名
    discriminatorType = DiscriminatorType.STRING  // 数据类型
)
```
- **作用**：定义用于区分子类类型的列
- **属性说明**：
  - `name`：数据库中的列名，默认是"DTYPE"
  - `discriminatorType`：数据类型，可选STRING、INTEGER、CHAR
  - `length`：字符串长度（仅STRING类型）

**@DiscriminatorValue - 鉴别器值**
```java
@DiscriminatorValue("FULL")  // 全职员工的标识
```
- **作用**：指定这个子类在鉴别器列中的值
- **位置**：标注在子类上
- **注意**：如果不指定，默认使用类名

### 2.4 数据操作示例


**保存数据**：
```java
// 创建全职员工
FullTimeEmployee fullTime = new FullTimeEmployee();
fullTime.setName("张三");
fullTime.setMonthlySalary(8000.0);
session.save(fullTime);  // emp_type自动设置为"FULL"

// 创建兼职员工
PartTimeEmployee partTime = new PartTimeEmployee();
partTime.setName("李四");
partTime.setHourlyRate(50.0);
partTime.setHoursWorked(160);
session.save(partTime);  // emp_type自动设置为"PART"
```

**查询数据**：
```java
// 查询所有员工（多态查询）
List<Employee> allEmployees = session.createQuery(
    "FROM Employee", Employee.class
).list();
// 返回：[FullTimeEmployee, PartTimeEmployee, ...]

// 只查询全职员工
List<FullTimeEmployee> fullTimeList = session.createQuery(
    "FROM FullTimeEmployee", FullTimeEmployee.class
).list();
// Hibernate自动添加条件：WHERE emp_type = 'FULL'
```

### 2.5 生成的SQL分析


**保存全职员工时的SQL**：
```sql
INSERT INTO employee (emp_type, name, monthly_salary, id)
VALUES ('FULL', '张三', 8000, 1);
```

**保存兼职员工时的SQL**：
```sql
INSERT INTO employee (emp_type, name, hourly_rate, hours_worked, id)
VALUES ('PART', '李四', 50, 160, 2);
```

**查询全职员工时的SQL**：
```sql
SELECT * FROM employee 
WHERE emp_type = 'FULL';  -- Hibernate自动添加鉴别条件
```

### 2.6 优缺点深度分析


**✅ 优点：性能与简单的完美结合**

```
1. 查询性能极佳
   - 无需JOIN操作，单表查询速度快
   - 适合高频查询场景
   
2. 实现简单直观
   - 只需一张表，数据库设计简单
   - 配置清晰，新人容易理解
   
3. 多态查询高效
   - 查询所有子类只需扫描一张表
   - 无需UNION操作
```

**❌ 缺点：空间换时间的代价**

```
1. 字段冗余问题
   问题：子类独有字段会造成空值
   
   示例：
   全职员工记录：hourly_rate和hours_worked为NULL
   兼职员工记录：monthly_salary为NULL
   
   影响：表列数随子类增加而增加

2. 数据完整性限制
   问题：无法对子类特有字段设置NOT NULL约束
   
   原因：同一列在不同类型记录中有的有值，有的为空

3. 表结构膨胀
   问题：子类多时，表会很"宽"
   
   极端情况：
   - 10个子类，每个5个独有字段
   - 最终表有50+列
```

### 2.7 适用场景判断


**✅ 推荐使用的场景**：

```
场景1：子类差异小
示例：
Employee
  ├── FullTimeEmployee（只多了monthly_salary）
  └── PartTimeEmployee（只多了hourly_rate、hours_worked）
  
判断标准：子类独有字段 ≤ 5个

场景2：查询性能要求高
需求：
- 频繁的多态查询
- 按类型筛选频繁
- 响应时间要求<100ms

场景3：子类数量少
建议：子类数量 ≤ 5个
```

**❌ 不推荐使用的场景**：

```
场景1：子类差异大
问题示例：
Animal
  ├── Bird（有翼展、飞行速度等10个特有字段）
  ├── Fish（有游泳深度、鳃类型等8个特有字段）
  └── Mammal（有怀孕周期、哺乳方式等12个特有字段）
  
结果：表会有30+个冗余列

场景2：数据完整性要求严格
需求：
- 子类特有字段必须有值（NOT NULL）
- 需要字段级别的约束检查
  
限制：单表继承无法满足

场景3：子类频繁扩展
问题：
- 每次新增子类 = 修改表结构
- 影响线上业务
- 数据迁移成本高
```

---

## 3. 🛠️ 实战应用与选择


### 3.1 继承策略对比速查


| 对比维度 | **单表继承** | **表联合继承** | **表独立继承** |
|---------|------------|--------------|--------------|
| **表数量** | `1张表` | `N+1张表（N个子类+1个父类）` | `N张表（仅子类表）` |
| **查询性能** | `⭐⭐⭐⭐⭐ 最快` | `⭐⭐⭐ 需要JOIN` | `⭐⭐ 需要UNION` |
| **字段冗余** | `❌ 存在空值` | `✅ 无冗余` | `⚠️ 父类字段重复` |
| **数据完整性** | `❌ 无法NOT NULL约束` | `✅ 支持完整约束` | `✅ 支持完整约束` |
| **扩展性** | `⚠️ 新增子类需改表` | `✅ 新增子类加表即可` | `✅ 新增子类独立` |
| **适用场景** | `子类少、差异小、查询多` | `规范要求高、子类差异大` | `子类完全独立` |

### 3.2 实战选择建议


**决策流程图**：
```
                  开始评估继承映射策略
                         |
                         ↓
              子类数量是否 ≤ 5个？
                    /        \
                  是           否
                  ↓             ↓
         子类独有字段 ≤ 5个？   考虑表联合或表独立
              /        \
            是          否
            ↓            ↓
      查询性能重要？    考虑表联合
          /    \
        是      否
        ↓        ↓
   【单表继承】 【表联合继承】
```

**典型应用案例**：

```
✅ 案例1：用户等级系统（推荐单表继承）
User
  ├── VIPUser（多了vipLevel、expireDate）
  ├── NormalUser（无额外字段）
  
理由：
- 子类只有2个
- VIP用户独有字段仅2个
- 查询"所有用户"非常频繁
  
✅ 案例2：支付方式（推荐单表继承）
Payment
  ├── CreditCardPayment（卡号、CVV）
  ├── AlipayPayment（支付宝账号）
  ├── WechatPayment（微信账号）
  
理由：
- 子类3个，可控
- 每个子类特有字段 ≤ 3个
- 经常需要查询"所有支付记录"

❌ 案例3：复杂动物系统（不推荐单表继承）
Animal
  ├── Bird（10+个独有字段）
  ├── Fish（8+个独有字段）
  ├── Mammal（12+个独有字段）
  ├── Reptile（9+个独有字段）
  
问题：
- 子类多（4个+）
- 每个子类差异大
- 会产生40+个冗余列
  
建议：使用表联合继承或表独立继承
```

### 3.3 性能优化技巧


**优化1：合理设计鉴别器**
```java
// ❌ 不推荐：使用完整类名
@DiscriminatorValue("com.example.FullTimeEmployee")  // 太长，浪费空间

// ✅ 推荐：使用简短标识
@DiscriminatorValue("FULL")  // 简洁高效
```

**优化2：索引优化**
```sql
-- 如果经常按类型查询，为鉴别器列建索引
CREATE INDEX idx_emp_type ON employee(emp_type);

-- 复合索引（类型 + 其他常用查询条件）
CREATE INDEX idx_emp_type_name ON employee(emp_type, name);
```

**优化3：查询优化**
```java
// ❌ 低效：查询所有员工再过滤
List<Employee> all = session.createQuery("FROM Employee", Employee.class).list();
List<FullTimeEmployee> fullTime = all.stream()
    .filter(e -> e instanceof FullTimeEmployee)
    .map(e -> (FullTimeEmployee) e)
    .collect(Collectors.toList());

// ✅ 高效：直接查询特定类型
List<FullTimeEmployee> fullTime = session.createQuery(
    "FROM FullTimeEmployee", 
    FullTimeEmployee.class
).list();  // Hibernate自动添加WHERE emp_type = 'FULL'
```

### 3.4 常见问题与解决


**Q1：为什么父类要声明为abstract？**
```java
// 推荐写法
public abstract class Employee { ... }

原因：
1. 语义清晰：父类只是抽象概念，不应该直接实例化
2. 避免误用：防止直接new Employee()
3. 数据一致性：确保表中记录都有明确的类型

特殊情况：
如果Employee本身也可以实例化，可以不用abstract
但需要给Employee也设置@DiscriminatorValue
```

**Q2：鉴别器列可以不设置吗？**
```java
// 如果不设置@DiscriminatorColumn
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public abstract class Employee { ... }

结果：
- Hibernate会自动创建名为"DTYPE"的列
- 类型为VARCHAR(31)
- 值为类的简单名称（如"FullTimeEmployee"）

建议：
显式配置，更可控，列名更有业务含义
```

**Q3：可以在查询中直接使用鉴别器列吗？**
```java
// ❌ 不推荐：直接操作鉴别器列
session.createQuery("FROM Employee e WHERE e.emp_type = 'FULL'");
// 编译错误：emp_type不是实体字段

// ✅ 推荐：使用TYPE函数
session.createQuery("FROM Employee e WHERE TYPE(e) = FullTimeEmployee");

// ✅ 或直接查询子类
session.createQuery("FROM FullTimeEmployee");
```

---

## 4. 📋 核心要点总结


### 4.1 必须掌握的核心概念


```
🔸 单表继承本质：一张表存储整个继承体系，用鉴别器区分类型
🔸 三大核心注解：
   - @Inheritance：声明继承策略
   - @DiscriminatorColumn：定义鉴别器列
   - @DiscriminatorValue：指定子类标识值
🔸 优势：查询快、配置简单、多态查询高效
🔸 代价：字段冗余、无法NOT NULL约束
🔸 适用场景：子类少、差异小、查询频繁
```

### 4.2 配置要点速记


**父类配置清单**：
- ✅ 添加`@Entity`
- ✅ 添加`@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
- ✅ 添加`@DiscriminatorColumn`（可选，建议配置）
- ✅ 声明为`abstract`（推荐）

**子类配置清单**：
- ✅ 添加`@Entity`
- ✅ 添加`@DiscriminatorValue("标识值")`
- ✅ 继承父类`extends Employee`
- ✅ 定义子类特有字段

### 4.3 最佳实践建议


**设计原则**：
1. **评估先行**：新项目先评估继承层次，选择合适策略
2. **控制层级**：继承层级不超过3层
3. **字段精简**：子类独有字段控制在5个以内
4. **索引优化**：鉴别器列建索引

**编码规范**：
1. **命名清晰**：鉴别器值用业务术语，如"FULL"而非"F"
2. **文档注释**：在父类注释说明各子类的含义
3. **类型检查**：使用`instanceof`前先判空
4. **查询优化**：优先使用子类查询而非过滤

**性能建议**：
```
数据规模          推荐策略
< 10万条         单表继承
10万-100万       评估字段数，考虑表联合
> 100万          根据查询模式选择，可能需要表独立
```

### 4.4 学习路径建议


**已掌握本章，接下来可以学习**：
1. **表联合继承**：了解如何通过JOIN实现更规范的继承映射
2. **表独立继承**：学习完全独立的表结构设计
3. **继承与多态查询**：深入HQL中的TYPE、TREAT等高级特性
4. **性能调优**：针对大数据量场景的优化策略

**核心记忆口诀**：
```
单表继承一张表，
鉴别器列分类型。
配置简单查询快，
子类少时效果好。
字段冗余要注意，
场景合适再选用！
```

---

> **提示**：单表继承是Hibernate最常用的继承策略，掌握它的原理和适用场景，能帮你在实际项目中快速完成ORM设计。记住：没有完美的方案，只有最合适的选择！