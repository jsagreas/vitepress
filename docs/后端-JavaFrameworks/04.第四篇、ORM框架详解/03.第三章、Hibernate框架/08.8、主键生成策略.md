---
title: 8、主键生成策略
---
## 📚 目录

1. [主键生成策略概述](#1-主键生成策略概述)
2. [@GeneratedValue核心配置](#2-generatedvalue核心配置)
3. [AUTO自动选择策略](#3-auto自动选择策略)
4. [IDENTITY自增主键](#4-identity自增主键)
5. [SEQUENCE序列生成](#5-sequence序列生成)
6. [TABLE表生成策略](#6-table表生成策略)
7. [UUID字符串主键](#7-uuid字符串主键)
8. [组合主键详解](#8-组合主键详解)
9. [使用场景与选择](#9-使用场景与选择)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 主键生成策略概述


### 1.1 什么是主键生成策略


**通俗理解**：主键就像每个人的身份证号，必须唯一且不能重复。主键生成策略就是**规定如何自动产生这个"身份证号"的方法**。

```
现实类比：

学生信息表 - 如何分配学号？
方式1：从1开始依次递增 → 1, 2, 3, 4...        (类似IDENTITY)
方式2：用学号生成器统一分配 → S001, S002...    (类似SEQUENCE)
方式3：用专门的号码表记录 → 查表获取下一个号   (类似TABLE)
方式4：用随机唯一码 → UUID-xxxx-xxxx...       (类似UUID)
```

### 1.2 为什么需要主键生成策略


**核心价值**：
- ✅ **自动化**：不用手动指定主键值，框架自动生成
- ✅ **唯一性**：保证主键绝对不重复
- ✅ **高效性**：根据数据库特性选择最优方案
- ✅ **可移植**：代码可在不同数据库间迁移

> 💡 **新手提示**：如果不配置主键策略，每次保存数据都要手动设置ID，非常麻烦且容易出错！

### 1.3 Hibernate支持的主键策略


```
策略家族图谱：

@GeneratedValue(strategy = ?)
            |
    ┌───────┴────────────────┬──────────────┐
    ↓                        ↓              ↓
GenerationType.AUTO    GenerationType    自定义策略
    |                   .IDENTITY
自动选择               .SEQUENCE
                       .TABLE
```

| 策略类型 | **特点** | **适用数据库** | **推荐场景** |
|---------|---------|--------------|-------------|
| **AUTO** | `自动选择最优策略` | `所有数据库` | `快速开发，不关心细节` |
| **IDENTITY** | `数据库自增列` | `MySQL、SQL Server` | `单表高并发插入` |
| **SEQUENCE** | `数据库序列` | `Oracle、PostgreSQL` | `需要预分配ID` |
| **TABLE** | `模拟序列表` | `所有数据库` | `跨数据库兼容` |
| **UUID** | `随机字符串` | `所有数据库` | `分布式系统` |

---

## 2. ⚙️ @GeneratedValue核心配置


### 2.1 基本用法


**@GeneratedValue**是主键生成的核心注解，用于告诉Hibernate"如何自动生成主键值"。

```java
@Entity
public class Student {
    
    @Id  // ← 标记这是主键字段
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // ← 指定生成策略
    private Long id;
    
    private String name;
    
    // getter/setter省略
}
```

**核心要素**：
- **@Id**：标识主键字段（必须有）
- **@GeneratedValue**：配置主键生成方式（可选，不加则需手动赋值）
- **strategy属性**：指定具体的生成策略

> ⚠️ **注意**：`@Id`和`@GeneratedValue`要一起使用在主键字段上，缺一不可！

### 2.2 完整配置示例


```java
@Entity
@Table(name = "tb_user")
public class User {
    
    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,  // 策略类型
        generator = "user_seq_gen"           // 引用生成器名称
    )
    @SequenceGenerator(
        name = "user_seq_gen",               // 生成器名称
        sequenceName = "user_sequence",      // 数据库序列名
        allocationSize = 1                   // 每次递增值
    )
    private Long id;
    
    private String username;
}
```

**配置说明**：
- `strategy`：生成策略类型
- `generator`：关联到具体的生成器配置
- 生成器注解：根据策略不同，使用不同的生成器注解

---

## 3. 🔄 AUTO自动选择策略


### 3.1 AUTO策略的工作原理


**通俗解释**：AUTO就像"智能助手"，它会根据你使用的数据库**自动选择最合适的主键生成方式**。

```
AUTO策略的决策过程：

检测数据库类型
    ↓
MySQL/MariaDB → 选择 IDENTITY (自增)
Oracle/PostgreSQL → 选择 SEQUENCE (序列)
不支持以上的 → 选择 TABLE (表模拟)
```

### 3.2 使用示例


```java
@Entity
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)  // 让Hibernate自动选择
    private Long id;
    
    private String name;
    private Double price;
}
```

**生成效果对比**：

| 数据库 | **AUTO实际选择** | **生成的SQL** |
|--------|-----------------|--------------|
| MySQL | `IDENTITY` | `id BIGINT AUTO_INCREMENT` |
| Oracle | `SEQUENCE` | `CREATE SEQUENCE product_seq` |
| H2 | `SEQUENCE` | `CREATE SEQUENCE hibernate_sequence` |

### 3.3 适用场景


✅ **推荐使用**：
- 快速开发原型，不关心底层细节
- 多数据库兼容的通用项目
- 学习阶段，先跑通流程

❌ **不推荐使用**：
- 生产环境需要精确控制主键
- 性能要求极高的场景
- 需要自定义序列名称

> 💡 **实战建议**：开发初期可用AUTO快速搭建，生产环境建议明确指定策略！

---

## 4. 📈 IDENTITY自增主键


### 4.1 IDENTITY策略原理


**通俗理解**：IDENTITY就是让**数据库的自增列来自动生成主键**，就像MySQL的`AUTO_INCREMENT`。

```
工作流程：

Java代码保存对象
    ↓
Hibernate执行INSERT语句（不包含ID）
    ↓
数据库自增列自动分配ID
    ↓
Hibernate获取生成的ID并回填到对象
```

### 4.2 配置与使用


```java
@Entity
@Table(name = "orders")
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String orderNo;
    private BigDecimal amount;
    
    // 保存时无需设置ID
}
```

**数据库建表语句**：
```sql
-- MySQL
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,  -- ← 自增列
    order_no VARCHAR(50),
    amount DECIMAL(10,2)
);

-- SQL Server
CREATE TABLE orders (
    id BIGINT IDENTITY(1,1) PRIMARY KEY,   -- ← 自增列
    order_no VARCHAR(50),
    amount DECIMAL(10,2)
);
```

### 4.3 使用示例


```java
// 保存订单
Order order = new Order();
order.setOrderNo("ORD20250923001");
order.setAmount(new BigDecimal("299.00"));
// 注意：不设置ID！

session.save(order);

// 保存后，ID已自动生成
System.out.println("生成的ID: " + order.getId());  // 输出：1
```

### 4.4 优缺点分析


**✅ 优点**：
- 简单高效，数据库原生支持
- 插入性能好，无需额外查询
- 主键值连续，便于排序

**❌ 缺点**：
- 无法批量插入优化（每次插入需立即获取ID）
- 数据库移植性差（不是所有数据库都支持）
- 分布式系统中可能ID冲突

> ⚠️ **重要提示**：IDENTITY策略会**禁用Hibernate的批量插入优化**，因为必须立即获取ID！

---

## 5. 🎲 SEQUENCE序列生成


### 5.1 SEQUENCE策略原理


**通俗理解**：SEQUENCE就像一个"号码生成器"，专门用来生成唯一的序号。

```
号码生成器类比：

银行排队机 → 按一下出一个号 → 001, 002, 003...
        ↓
数据库序列 → 调用一次返回一个值 → NEXT VALUE FOR seq_name
```

**工作流程**：
```
Hibernate调用序列获取下一个值
    ↓
数据库返回序列值（如：101）
    ↓
Hibernate将该值作为ID执行INSERT
    ↓
对象ID已确定，无需回查
```

### 5.2 配置与使用


```java
@Entity
@Table(name = "customer")
public class Customer {
    
    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        generator = "customer_seq_gen"  // 引用下面的生成器
    )
    @SequenceGenerator(
        name = "customer_seq_gen",           // 生成器名称
        sequenceName = "customer_id_seq",    // 数据库中的序列名
        initialValue = 1,                    // 起始值
        allocationSize = 50                  // 每次预分配数量
    )
    private Long id;
    
    private String name;
    private String phone;
}
```

**关键配置说明**：

| 配置项 | **含义** | **示例值** | **作用** |
|--------|---------|-----------|---------|
| `name` | `生成器名称` | `"customer_seq_gen"` | `供@GeneratedValue引用` |
| `sequenceName` | `数据库序列名` | `"customer_id_seq"` | `实际的数据库对象名` |
| `initialValue` | `起始值` | `1` | `序列从哪个数字开始` |
| `allocationSize` | `预分配大小` | `50` | `一次性获取多少个号` |

### 5.3 数据库序列创建


```sql
-- Oracle
CREATE SEQUENCE customer_id_seq
    START WITH 1
    INCREMENT BY 1
    NOCACHE;

-- PostgreSQL  
CREATE SEQUENCE customer_id_seq
    START 1
    INCREMENT 1;
```

### 5.4 allocationSize优化原理


**性能优化关键**：`allocationSize`参数

```
普通方式（allocationSize=1）：
保存100条数据 → 调用序列100次 → 100次数据库交互

优化方式（allocationSize=50）：
保存100条数据 → 调用序列2次 → 只需2次数据库交互
        ↓
第1次获取：1-50号（Hibernate内存缓存）
第2次获取：51-100号
```

> 💡 **性能提示**：`allocationSize`设置为50时，性能可提升数十倍！

### 5.5 适用场景


✅ **推荐使用**：
- Oracle、PostgreSQL等支持序列的数据库
- 需要批量插入优化的场景
- 分布式系统（可为每个服务分配不同序列）

❌ **不推荐使用**：
- MySQL 5.7及以下版本（不支持序列）
- 要求主键绝对连续的场景

---

## 6. 📊 TABLE表生成策略


### 6.1 TABLE策略原理


**通俗理解**：TABLE策略是用**一张专门的表来模拟序列生成器**，适用于所有数据库。

```
序列模拟表结构：

hibernate_sequences表
┌─────────────┬────────────┐
│ sequence_name │ next_val  │  ← 记录每个序列的当前值
├─────────────┼────────────┤
│ user_seq     │ 101       │
│ order_seq    │ 505       │
│ product_seq  │ 1001      │
└─────────────┴────────────┘
```

**工作原理**：
```
① Hibernate查询表获取当前值：SELECT next_val FROM ... WHERE sequence_name='user_seq'
② 更新表中的值：UPDATE ... SET next_val = next_val + 50
③ 使用获取的值作为ID范围
```

### 6.2 配置与使用


```java
@Entity
@Table(name = "article")
public class Article {
    
    @Id
    @GeneratedValue(
        strategy = GenerationType.TABLE,
        generator = "article_table_gen"
    )
    @TableGenerator(
        name = "article_table_gen",          // 生成器名称
        table = "id_generator",              // 序列表名
        pkColumnName = "gen_name",           // 序列名称列
        valueColumnName = "gen_value",       // 序列值列
        pkColumnValue = "article_id",        // 本实体的序列名
        allocationSize = 50                  // 预分配大小
    )
    private Long id;
    
    private String title;
    private String content;
}
```

**配置参数详解**：

| 参数 | **作用** | **示例** |
|------|---------|---------|
| `table` | `序列表的表名` | `"id_generator"` |
| `pkColumnName` | `序列名称的列名` | `"gen_name"` |
| `valueColumnName` | `序列值的列名` | `"gen_value"` |
| `pkColumnValue` | `当前实体的序列标识` | `"article_id"` |
| `allocationSize` | `每次递增值` | `50` |

### 6.3 序列表结构


```sql
-- Hibernate会自动创建，也可手动创建
CREATE TABLE id_generator (
    gen_name VARCHAR(50) PRIMARY KEY,  -- 序列名称
    gen_value BIGINT                   -- 当前值
);

-- 初始化数据
INSERT INTO id_generator(gen_name, gen_value) VALUES ('article_id', 0);
```

### 6.4 优缺点分析


**✅ 优点**：
- 所有数据库都支持（移植性最好）
- 可自定义序列表结构
- 支持预分配优化

**❌ 缺点**：
- 性能较IDENTITY和SEQUENCE差
- 需要额外的表和查询
- 高并发时可能有锁竞争

> ⚠️ **使用建议**：除非必须跨数据库兼容，否则优先选择IDENTITY或SEQUENCE！

---

## 7. 🔑 UUID字符串主键


### 7.1 UUID策略原理


**通俗理解**：UUID是一个**全局唯一的随机字符串**，像这样：`550e8400-e29b-41d4-a716-446655440000`

```
UUID生成特点：

时间戳 + 机器码 + 随机数 → 组合成唯一ID
        ↓
几乎不可能重复（重复概率：1/2^128）
```

### 7.2 配置与使用


```java
@Entity
@Table(name = "file_info")
public class FileInfo {
    
    @Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(
        name = "uuid2",
        strategy = "uuid2"  // Hibernate的UUID生成器
    )
    @Column(length = 36)
    private String id;  // ← 注意：类型是String
    
    private String fileName;
    private Long fileSize;
}
```

**保存示例**：
```java
FileInfo file = new FileInfo();
file.setFileName("report.pdf");
file.setFileSize(1024000L);

session.save(file);

// 自动生成UUID
System.out.println(file.getId());  
// 输出：a8f5f167-11e5-4cf6-a229-92bf07ed7e94
```

### 7.3 UUID的几种生成方式


```java
// 方式1：使用Hibernate的uuid2策略
@GeneratedValue(generator = "uuid2")
@GenericGenerator(name = "uuid2", strategy = "uuid2")

// 方式2：使用JPA的UUID策略（需要Hibernate 5.3+）
@GeneratedValue(strategy = GenerationType.UUID)

// 方式3：手动设置UUID
@Id
private String id = UUID.randomUUID().toString();
```

### 7.4 适用场景


✅ **推荐使用**：
- **分布式系统**：多个服务独立生成ID，不会冲突
- **数据合并**：不同来源的数据合并时不担心ID重复
- **安全性要求**：ID不可预测，避免被遍历

❌ **不推荐使用**：
- 主键需要有序的场景
- 对存储空间敏感（36字节 vs 8字节Long）
- 索引性能要求高（字符串索引慢于数字）

> 💡 **性能提示**：UUID作为主键会导致索引碎片化，影响查询性能！

---

## 8. 🔗 组合主键详解


### 8.1 什么是组合主键


**通俗理解**：组合主键就是**用多个字段联合起来作为主键**，比如"学生选课表"用"学生ID + 课程ID"作为主键。

```
单一主键：
学生表 → 学号（唯一）

组合主键：
选课表 → 学号 + 课程号（联合唯一）
        ↓
同一学生可选多门课
同一课程可被多个学生选
但"某学生选某课程"这个组合是唯一的
```

### 8.2 实现方式对比


Hibernate支持两种实现组合主键的方式：

| 方式 | **注解** | **特点** | **推荐度** |
|------|---------|---------|-----------|
| **嵌入式主键** | `@EmbeddedId` | `主键类独立，可复用` | ⭐⭐⭐⭐⭐ |
| **主键类** | `@IdClass` | `字段平铺，符合直觉` | ⭐⭐⭐ |

### 8.3 方式一：@EmbeddedId（推荐）


**步骤1：创建主键类**
```java
@Embeddable  // ← 标记为可嵌入的类
public class CourseSelectionId implements Serializable {
    
    private Long studentId;
    private Long courseId;
    
    // 必须实现equals和hashCode
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CourseSelectionId that = (CourseSelectionId) o;
        return Objects.equals(studentId, that.studentId) &&
               Objects.equals(courseId, that.courseId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(studentId, courseId);
    }
    
    // getter/setter省略
}
```

**步骤2：在实体中使用**
```java
@Entity
@Table(name = "course_selection")
public class CourseSelection {
    
    @EmbeddedId  // ← 使用嵌入式主键
    private CourseSelectionId id;
    
    private LocalDateTime selectionTime;
    private Integer score;
    
    // getter/setter省略
}
```

**使用示例**：
```java
// 创建组合主键
CourseSelectionId id = new CourseSelectionId();
id.setStudentId(1001L);
id.setCourseId(2001L);

// 创建实体
CourseSelection selection = new CourseSelection();
selection.setId(id);
selection.setSelectionTime(LocalDateTime.now());

session.save(selection);
```

### 8.4 方式二：@IdClass


**步骤1：创建主键类**
```java
public class OrderItemId implements Serializable {
    
    private Long orderId;
    private Long productId;
    
    // 必须有无参构造器
    public OrderItemId() {}
    
    public OrderItemId(Long orderId, Long productId) {
        this.orderId = orderId;
        this.productId = productId;
    }
    
    // equals和hashCode省略（必须实现）
}
```

**步骤2：在实体中使用**
```java
@Entity
@Table(name = "order_item")
@IdClass(OrderItemId.class)  // ← 指定主键类
public class OrderItem {
    
    @Id  // ← 注意：主键字段都要标记@Id
    private Long orderId;
    
    @Id
    private Long productId;
    
    private Integer quantity;
    private BigDecimal price;
}
```

**使用示例**：
```java
OrderItem item = new OrderItem();
item.setOrderId(5001L);      // 直接设置字段
item.setProductId(3001L);
item.setQuantity(2);

session.save(item);
```

### 8.5 两种方式对比


```
@EmbeddedId优点：
✅ 主键逻辑封装在一个类中
✅ 可以在多个实体间复用主键类
✅ 实体类更简洁

@IdClass优点：
✅ 字段直接在实体中，更直观
✅ 查询时可直接使用字段名
✅ 不需要额外的嵌入对象
```

> 💡 **实战建议**：推荐使用`@EmbeddedId`，结构更清晰，复用性更好！

### 8.6 组合主键的要求


⚠️ **必须满足的条件**：

```java
// 1. 实现Serializable接口
public class CompositeKey implements Serializable { }

// 2. 必须重写equals方法
@Override
public boolean equals(Object o) { 
    // 比较所有主键字段
}

// 3. 必须重写hashCode方法
@Override
public int hashCode() {
    return Objects.hash(field1, field2);
}

// 4. 必须有无参构造器
public CompositeKey() { }
```

---

## 9. 🎯 使用场景与选择


### 9.1 策略选择决策树


```
开始选择主键策略
    ↓
是否需要分布式环境？
    ↓ 是
  UUID策略 ✓
    ↓ 否
    ↓
数据库类型是什么？
    ↓
MySQL/MariaDB → IDENTITY策略 ✓
    ↓
Oracle/PostgreSQL → SEQUENCE策略 ✓
    ↓
需要跨数据库？ → TABLE策略 ✓
```

### 9.2 场景对照表


| 应用场景 | **推荐策略** | **理由** |
|---------|------------|---------|
| **MySQL单体应用** | `IDENTITY` | `数据库原生支持，性能最佳` |
| **Oracle企业应用** | `SEQUENCE` | `序列性能好，支持批量优化` |
| **分布式微服务** | `UUID` | `各服务独立生成，无冲突` |
| **多数据库支持** | `TABLE` | `所有数据库都兼容` |
| **快速开发原型** | `AUTO` | `自动选择，快速上手` |
| **关联表（中间表）** | `组合主键` | `业务逻辑天然组合` |

### 9.3 性能对比


```
插入性能排名（从快到慢）：
1. IDENTITY      ⭐⭐⭐⭐⭐  数据库原生，最快
2. SEQUENCE      ⭐⭐⭐⭐    预分配优化，接近IDENTITY
3. TABLE         ⭐⭐⭐      额外表查询，稍慢
4. UUID          ⭐⭐        字符串插入，最慢

查询性能排名：
1. IDENTITY      ⭐⭐⭐⭐⭐  数字索引，最快
2. SEQUENCE      ⭐⭐⭐⭐⭐  数字索引，最快
3. TABLE         ⭐⭐⭐⭐    数字索引，快
4. UUID          ⭐⭐        字符串索引，慢且碎片化
```

### 9.4 实战选择建议


**✅ 推荐组合**：

① **互联网应用（MySQL）**
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

② **企业应用（Oracle）**
```java
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq_gen")
@SequenceGenerator(name = "seq_gen", sequenceName = "app_seq", allocationSize = 50)
private Long id;
```

③ **分布式系统**
```java
@Id
@GeneratedValue(generator = "uuid2")
@GenericGenerator(name = "uuid2", strategy = "uuid2")
private String id;
```

④ **关联关系表**
```java
@EmbeddedId
private UserRoleId id;  // 组合主键：用户ID + 角色ID
```

### 9.5 常见错误避免


❌ **错误1：在分布式环境使用IDENTITY**
```java
// 问题：多个服务共享数据库，ID可能冲突
@GeneratedValue(strategy = GenerationType.IDENTITY)
```

❌ **错误2：MySQL使用SEQUENCE**
```java
// 问题：MySQL 5.7不支持序列，会报错
@GeneratedValue(strategy = GenerationType.SEQUENCE)
```

❌ **错误3：不设置allocationSize**
```java
// 问题：每次都查询序列，性能差
@SequenceGenerator(name = "gen", sequenceName = "seq")
// 应该加上 allocationSize = 50
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 主键策略本质：自动化生成唯一标识的规则
🔸 @GeneratedValue：配置主键生成的核心注解
🔸 四大基础策略：AUTO、IDENTITY、SEQUENCE、TABLE
🔸 特殊策略：UUID用于分布式，组合主键用于关联关系
🔸 性能优化：allocationSize预分配是关键
```

### 10.2 策略选择口诀


```
MySQL用IDENTITY，Oracle用SEQUENCE，
分布式系统UUID强，跨库兼容选TABLE。
组合主键看业务，关联关系最适合，
性能优化看预分配，allocationSize别忘记！
```

### 10.3 快速对比表


| 策略 | **数据库要求** | **性能** | **适用场景** | **主键类型** |
|------|--------------|---------|-------------|-------------|
| **IDENTITY** | `MySQL/SQL Server` | ⭐⭐⭐⭐⭐ | `单体应用` | `Long` |
| **SEQUENCE** | `Oracle/PostgreSQL` | ⭐⭐⭐⭐⭐ | `企业应用` | `Long` |
| **TABLE** | `所有数据库` | ⭐⭐⭐ | `跨数据库` | `Long` |
| **UUID** | `所有数据库` | ⭐⭐ | `分布式系统` | `String` |
| **组合主键** | `所有数据库` | ⭐⭐⭐⭐ | `关联关系` | `复合类` |

### 10.4 关键实践要点


> 💡 **新手必记**：
> - IDENTITY和SEQUENCE最常用，性能最好
> - SEQUENCE必须配置allocationSize提升性能
> - UUID适合分布式，但查询性能较差
> - 组合主键必须实现Serializable、equals、hashCode

> ⚠️ **常见陷阱**：
> - 不要在MySQL使用SEQUENCE（不支持）
> - 不要忘记设置allocationSize（默认50）
> - UUID主键避免作为外键（性能差）
> - 组合主键类必须重写equals和hashCode

### 10.5 学习建议


**学习路径**：
```
第1步：理解AUTO和IDENTITY（最简单）
    ↓
第2步：掌握SEQUENCE和优化（重点）
    ↓
第3步：了解TABLE和UUID（特殊场景）
    ↓
第4步：实践组合主键（进阶）
```

**实战检验**：
- [ ] 能说出4种基础策略的区别
- [ ] 会配置SEQUENCE的allocationSize
- [ ] 理解UUID的适用场景
- [ ] 能实现@EmbeddedId组合主键
- [ ] 根据项目选择合适策略