---
title: 33、HQL投影与统计查询
---
## 📚 目录

1. [投影查询概述](#1-投影查询概述)
2. [SELECT投影查询](#2-SELECT投影查询)
3. [构造器表达式](#3-构造器表达式)
4. [聚合函数使用](#4-聚合函数使用)
5. [分组统计查询](#5-分组统计查询)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📊 投影查询概述


### 1.1 什么是投影查询


**通俗理解**：投影查询就是"按需取数据"，不用把整个对象都查出来，只拿需要的字段。

```
类比理解：
就像去图书馆借书，你只想知道书名和作者
你不需要把整本书的所有信息（页数、出版社、ISBN等）都抄下来
只记录你需要的那几项信息就够了

数据库查询也是一样：
完整查询：SELECT * FROM user （把所有字段都查出来）
投影查询：SELECT name, age FROM user （只查需要的字段）
```

**核心概念**：
- **投影（Projection）**：从完整的对象中选择部分属性进行查询
- **目的**：减少数据传输量，提高查询效率
- **应用场景**：只需要对象的某些属性，不需要完整对象

### 1.2 为什么需要投影查询


**实际问题场景**：

```
假设User对象有20个字段：
- id, username, password, email, phone
- address, city, province, country, zipCode
- age, gender, birthday, avatar, status
- createTime, updateTime, lastLogin, loginCount, level

场景1：用户列表页面
只需要：id, username, avatar （3个字段）
如果查询完整对象：浪费了17个字段的查询和传输

场景2：统计报表
只需要：age, city （2个字段）
查询完整对象：浪费了18个字段的资源
```

**投影查询的好处**：

| 优势 | **说明** | **实际效果** |
|------|---------|------------|
| 🚀 **性能提升** | `减少数据库IO和网络传输` | `大数据量时提升明显` |
| 💾 **内存节省** | `只加载需要的数据到内存` | `降低内存占用` |
| ⚡ **响应加快** | `数据量小，处理速度快` | `用户体验更好` |
| 🎯 **业务精准** | `只查询业务需要的字段` | `避免数据冗余` |

---

## 2. 🔍 SELECT投影查询


### 2.1 基本SELECT投影


**核心语法**：`SELECT 属性1, 属性2 FROM 实体名`

```java
// 示例：只查询用户名和邮箱
String hql = "SELECT u.username, u.email FROM User u";
List<Object[]> results = session.createQuery(hql).list();

// 结果处理
for (Object[] row : results) {
    String username = (String) row[0];  // 第一个属性
    String email = (String) row[1];     // 第二个属性
    System.out.println("用户名: " + username + ", 邮箱: " + email);
}
```

**关键理解点**：

🔸 **返回值类型**：
```
单个属性：直接返回该属性类型
SELECT u.username FROM User u
→ List<String>

多个属性：返回Object数组
SELECT u.username, u.email FROM User u  
→ List<Object[]>
```

🔸 **数组顺序**：
- `Object[0]` 对应第一个SELECT的属性
- `Object[1]` 对应第二个SELECT的属性
- 以此类推，顺序和SELECT子句中的顺序一致

### 2.2 不同场景的投影示例


**场景1：用户列表展示**
```java
// 需求：只显示用户ID、用户名、头像
String hql = "SELECT u.id, u.username, u.avatar FROM User u WHERE u.status = 1";
List<Object[]> users = session.createQuery(hql).list();

// 实际应用
for (Object[] user : users) {
    Long id = (Long) user[0];
    String name = (String) user[1];
    String avatar = (String) user[2];
    // 传递给前端显示
}
```

**场景2：数据导出**
```java
// 需求：导出订单号、金额、日期
String hql = "SELECT o.orderNo, o.amount, o.createTime " +
             "FROM Order o WHERE o.status = 'COMPLETED'";
List<Object[]> orders = session.createQuery(hql).list();

// 生成Excel或CSV文件
```

**场景3：下拉选项**
```java
// 需求：获取所有城市名称供用户选择
String hql = "SELECT DISTINCT u.city FROM User u ORDER BY u.city";
List<String> cities = session.createQuery(hql).list();

// 直接得到城市列表，无需额外处理
```

### 2.3 投影查询的注意事项


> ⚠️ **类型转换注意**
> ```
> Object[]中的元素需要手动类型转换
> 建议：先检查null值，再进行转换
> 
> String name = (row[0] != null) ? (String)row[0] : "未知";
> ```

> 💡 **性能建议**
> ```
> 只查询真正需要的字段
> 避免SELECT *这样的写法
> 大数据量时，投影查询能显著提升性能
> ```

---

## 3. 🏗️ 构造器表达式


### 3.1 什么是构造器表达式


**通俗解释**：构造器表达式就是让Hibernate自动把查询结果封装成对象，而不是返回数组。

```
类比理解：
普通投影：就像超市购物，你买了苹果、牛奶、面包，收银员给你装在塑料袋里
构造器表达式：就像网购，你买的东西直接装在一个精美的礼盒里，还帮你分好类

普通投影返回：Object[] {苹果, 牛奶, 面包}
构造器表达式：ShoppingBag {苹果, 牛奶, 面包}
```

**核心作用**：
- 自动封装查询结果到自定义对象
- 避免手动处理Object数组
- 代码更清晰，更面向对象

### 3.2 构造器表达式基本用法


**第一步：创建DTO类**（Data Transfer Object - 数据传输对象）

```java
// DTO类：只包含需要的字段
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    
    // 必须有对应的构造器
    public UserDTO(Long id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }
    
    // getter和setter方法
    // ...
}
```

**第二步：使用构造器表达式查询**

```java
String hql = "SELECT new com.example.dto.UserDTO(u.id, u.username, u.email) " +
             "FROM User u";
             
List<UserDTO> users = session.createQuery(hql, UserDTO.class).list();

// 直接使用DTO对象，无需类型转换
for (UserDTO user : users) {
    System.out.println(user.getUsername());  // 直接调用方法
}
```

**语法关键点**：

🔸 **new关键字**：必须使用`new`关键字
🔸 **全限定类名**：必须写完整的包名+类名
🔸 **构造器匹配**：参数顺序和类型必须与构造器一致
🔸 **返回类型**：直接返回`List<DTO类型>`

### 3.3 构造器表达式实战案例


**案例1：订单统计DTO**

```java
// 订单统计DTO
public class OrderStatDTO {
    private String productName;  // 商品名
    private Long orderCount;     // 订单数量
    private Double totalAmount;  // 总金额
    
    public OrderStatDTO(String productName, Long count, Double amount) {
        this.productName = productName;
        this.orderCount = count;
        this.totalAmount = amount;
    }
}

// HQL查询
String hql = "SELECT new com.example.dto.OrderStatDTO(" +
             "o.productName, COUNT(o), SUM(o.amount)) " +
             "FROM Order o GROUP BY o.productName";
             
List<OrderStatDTO> stats = session.createQuery(hql, OrderStatDTO.class).list();
```

**案例2：用户信息卡片**

```java
// 用户卡片DTO
public class UserCardDTO {
    private String username;
    private Integer age;
    private String city;
    
    public UserCardDTO(String username, Integer age, String city) {
        this.username = username;
        this.age = age;
        this.city = city;
    }
}

// HQL查询
String hql = "SELECT new com.example.dto.UserCardDTO(u.username, u.age, u.city) " +
             "FROM User u WHERE u.age >= :minAge";
             
List<UserCardDTO> cards = session.createQuery(hql, UserCardDTO.class)
                                 .setParameter("minAge", 18)
                                 .list();
```

### 3.4 构造器表达式 vs 普通投影对比


| 对比项 | **普通投影** | **构造器表达式** |
|--------|------------|----------------|
| 返回类型 | `List<Object[]>` | `List<DTO类>` |
| 类型转换 | `需要手动转换` | `自动封装` |
| 代码可读性 | `较差，数组下标不直观` | `优秀，直接调用方法` |
| 维护性 | `字段顺序改变影响大` | `通过构造器控制` |
| 推荐场景 | `临时查询，字段少` | `正式业务，复杂查询` |

> 💡 **最佳实践**
> ```
> 简单查询（1-2个字段）：使用普通投影
> 复杂查询（3个以上字段）：使用构造器表达式
> 需要复用的查询结果：使用构造器表达式+DTO
> ```

---

## 4. 📈 聚合函数使用


### 4.1 聚合函数概述


**什么是聚合函数**：聚合函数就是对一组数据进行计算，得到一个汇总结果。

```
生活中的聚合例子：
班级总人数 → COUNT(统计个数)
平均成绩 → AVG(计算平均值)
最高分 → MAX(找最大值)
最低分 → MIN(找最小值)
总分 → SUM(求和)
```

**HQL支持的5大聚合函数**：

| 函数 | **作用** | **返回类型** | **常用场景** |
|------|---------|------------|------------|
| `COUNT()` | 统计数量 | Long | 统计记录条数 |
| `SUM()` | 求和 | 数值类型 | 计算总金额、总数量 |
| `AVG()` | 平均值 | Double | 计算平均分、平均价格 |
| `MAX()` | 最大值 | 原字段类型 | 找最高分、最高价格 |
| `MIN()` | 最小值 | 原字段类型 | 找最低分、最低价格 |

### 4.2 COUNT - 统计数量


**基本用法**：统计符合条件的记录数

```java
// 统计所有用户数量
String hql1 = "SELECT COUNT(u) FROM User u";
Long totalUsers = (Long) session.createQuery(hql1).uniqueResult();

// 统计活跃用户数量（带条件）
String hql2 = "SELECT COUNT(u) FROM User u WHERE u.status = 1";
Long activeUsers = (Long) session.createQuery(hql2).uniqueResult();

// 统计不重复的城市数量
String hql3 = "SELECT COUNT(DISTINCT u.city) FROM User u";
Long cityCount = (Long) session.createQuery(hql3).uniqueResult();
```

**COUNT的几种形式**：

🔸 **COUNT(\*)**: 统计所有行（包括null）
```java
SELECT COUNT(*) FROM User u
```

🔸 **COUNT(属性)**: 统计非null的行
```java
SELECT COUNT(u.email) FROM User u  // 只统计email不为null的
```

🔸 **COUNT(DISTINCT 属性)**: 统计不重复的值
```java
SELECT COUNT(DISTINCT u.city) FROM User u  // 统计不同城市数量
```

### 4.3 SUM - 求和计算


**应用场景**：计算总金额、总数量等

```java
// 计算订单总金额
String hql1 = "SELECT SUM(o.amount) FROM Order o";
Double totalAmount = (Double) session.createQuery(hql1).uniqueResult();

// 计算某用户的总消费
String hql2 = "SELECT SUM(o.amount) FROM Order o WHERE o.userId = :userId";
Double userTotal = (Double) session.createQuery(hql2)
                                   .setParameter("userId", 1001L)
                                   .uniqueResult();

// 计算本月订单总额
String hql3 = "SELECT SUM(o.amount) FROM Order o " +
              "WHERE YEAR(o.createTime) = YEAR(CURRENT_DATE) " +
              "AND MONTH(o.createTime) = MONTH(CURRENT_DATE)";
```

**注意事项**：
> ⚠️ **空值处理**
> ```
> 如果没有记录，SUM返回null而不是0
> 建议使用COALESCE处理：
> SELECT COALESCE(SUM(o.amount), 0) FROM Order o
> ```

### 4.4 AVG - 平均值计算


**应用场景**：计算平均分、平均价格、平均年龄等

```java
// 计算用户平均年龄
String hql1 = "SELECT AVG(u.age) FROM User u";
Double avgAge = (Double) session.createQuery(hql1).uniqueResult();

// 计算商品平均价格（按分类）
String hql2 = "SELECT p.category, AVG(p.price) FROM Product p " +
              "GROUP BY p.category";
List<Object[]> avgPrices = session.createQuery(hql2).list();

// 计算及格率（配合CASE WHEN）
String hql3 = "SELECT AVG(CASE WHEN s.score >= 60 THEN 1.0 ELSE 0.0 END) " +
              "FROM Score s";
Double passRate = (Double) session.createQuery(hql3).uniqueResult();
```

### 4.5 MAX/MIN - 最值查询


**应用场景**：找最高分、最低价、最新记录等

```java
// 查找最高价格
String hql1 = "SELECT MAX(p.price) FROM Product p";
Double maxPrice = (Double) session.createQuery(hql1).uniqueResult();

// 查找最低价格
String hql2 = "SELECT MIN(p.price) FROM Product p";
Double minPrice = (Double) session.createQuery(hql2).uniqueResult();

// 查找最新订单时间
String hql3 = "SELECT MAX(o.createTime) FROM Order o";
Date latestOrderTime = (Date) session.createQuery(hql3).uniqueResult();

// 查找年龄最大的用户信息（子查询）
String hql4 = "FROM User u WHERE u.age = (SELECT MAX(u2.age) FROM User u2)";
User oldestUser = session.createQuery(hql4, User.class).uniqueResult();
```

### 4.6 多个聚合函数组合使用


**实战案例：商品统计分析**

```java
// 一次查询获取多个统计指标
String hql = "SELECT " +
             "COUNT(p), " +           // 商品总数
             "SUM(p.stock), " +       // 库存总量
             "AVG(p.price), " +       // 平均价格
             "MAX(p.price), " +       // 最高价
             "MIN(p.price) " +        // 最低价
             "FROM Product p";

Object[] stats = (Object[]) session.createQuery(hql).uniqueResult();

Long productCount = (Long) stats[0];
Long totalStock = (Long) stats[1];
Double avgPrice = (Double) stats[2];
Double maxPrice = (Double) stats[3];
Double minPrice = (Double) stats[4];

System.out.println("商品总数: " + productCount);
System.out.println("库存总量: " + totalStock);
System.out.println("平均价格: " + avgPrice);
```

**配合构造器表达式使用**：

```java
// 统计DTO
public class ProductStatDTO {
    private Long count;
    private Long totalStock;
    private Double avgPrice;
    private Double maxPrice;
    private Double minPrice;
    
    public ProductStatDTO(Long count, Long stock, Double avg, Double max, Double min) {
        this.count = count;
        this.totalStock = stock;
        this.avgPrice = avg;
        this.maxPrice = max;
        this.minPrice = min;
    }
}

// HQL查询
String hql = "SELECT new com.example.dto.ProductStatDTO(" +
             "COUNT(p), SUM(p.stock), AVG(p.price), MAX(p.price), MIN(p.price)) " +
             "FROM Product p";
             
ProductStatDTO stat = session.createQuery(hql, ProductStatDTO.class).uniqueResult();
```

---

## 5. 📊 分组统计查询


### 5.1 GROUP BY 分组概念


**什么是分组**：把数据按照某个字段的值进行分类，然后对每一类进行统计。

```
生活中的分组例子：
学生按班级分组 → 统计每个班的人数
订单按日期分组 → 统计每天的销售额
商品按类别分组 → 统计每类商品的数量

数据分组示例：
原始数据：
订单1: 商品A, 100元
订单2: 商品B, 200元  
订单3: 商品A, 150元
订单4: 商品C, 300元
订单5: 商品A, 120元

按商品分组统计：
商品A: 3笔订单, 总额370元
商品B: 1笔订单, 总额200元
商品C: 1笔订单, 总额300元
```

### 5.2 GROUP BY 基本语法


**核心语法**：`SELECT 分组字段, 聚合函数 FROM 实体 GROUP BY 分组字段`

```java
// 按城市分组统计用户数
String hql1 = "SELECT u.city, COUNT(u) FROM User u GROUP BY u.city";
List<Object[]> cityStats = session.createQuery(hql1).list();

for (Object[] row : cityStats) {
    String city = (String) row[0];      // 分组字段
    Long userCount = (Long) row[1];     // 统计结果
    System.out.println(city + ": " + userCount + "人");
}

// 输出示例：
// 北京: 1500人
// 上海: 1200人
// 广州: 800人
```

**语法规则**：

🔸 **SELECT子句规则**：
```
只能出现两类内容：
1. GROUP BY后面的分组字段
2. 聚合函数（COUNT、SUM、AVG等）

正确示例：
SELECT u.city, COUNT(u) FROM User u GROUP BY u.city ✓

错误示例：
SELECT u.city, u.age, COUNT(u) FROM User u GROUP BY u.city ✗
（u.age既不是分组字段，也不是聚合函数）
```

### 5.3 单字段分组统计


**案例1：按类别统计商品**

```java
String hql = "SELECT p.category, COUNT(p), AVG(p.price), SUM(p.stock) " +
             "FROM Product p " +
             "GROUP BY p.category";

List<Object[]> results = session.createQuery(hql).list();

for (Object[] row : results) {
    String category = (String) row[0];
    Long count = (Long) row[1];
    Double avgPrice = (Double) row[2];
    Long totalStock = (Long) row[3];
    
    System.out.printf("%s: 商品%d个, 均价%.2f, 库存%d\n", 
                      category, count, avgPrice, totalStock);
}
```

**案例2：按月份统计订单**

```java
String hql = "SELECT " +
             "YEAR(o.createTime), " +        // 年份
             "MONTH(o.createTime), " +       // 月份
             "COUNT(o), " +                  // 订单数
             "SUM(o.amount) " +              // 总金额
             "FROM Order o " +
             "GROUP BY YEAR(o.createTime), MONTH(o.createTime) " +
             "ORDER BY YEAR(o.createTime), MONTH(o.createTime)";

List<Object[]> monthlyStats = session.createQuery(hql).list();
```

### 5.4 多字段分组统计


**应用场景**：需要按多个维度进行统计

```java
// 按城市和年龄段分组统计用户
String hql = "SELECT " +
             "u.city, " +
             "CASE " +
             "  WHEN u.age < 18 THEN '未成年' " +
             "  WHEN u.age < 30 THEN '青年' " +
             "  WHEN u.age < 50 THEN '中年' " +
             "  ELSE '老年' " +
             "END, " +
             "COUNT(u) " +
             "FROM User u " +
             "GROUP BY u.city, CASE ... END";  // 分组条件要一致

List<Object[]> results = session.createQuery(hql).list();

// 结果示例：
// 北京, 青年, 500人
// 北京, 中年, 300人
// 上海, 青年, 450人
// ...
```

### 5.5 HAVING 条件过滤


**HAVING vs WHERE 的区别**：

```
WHERE: 在分组前过滤，过滤原始数据
HAVING: 在分组后过滤，过滤统计结果

执行顺序：
1. WHERE 过滤原始数据
2. GROUP BY 分组
3. 计算聚合函数
4. HAVING 过滤分组结果
```

**实战案例**：

```java
// 查找订单数量超过10的用户
String hql1 = "SELECT o.userId, COUNT(o) " +
              "FROM Order o " +
              "GROUP BY o.userId " +
              "HAVING COUNT(o) > 10";

List<Object[]> activeUsers = session.createQuery(hql1).list();

// WHERE + HAVING 组合使用
// 查找本月消费超过1000元的用户
String hql2 = "SELECT o.userId, SUM(o.amount) " +
              "FROM Order o " +
              "WHERE MONTH(o.createTime) = MONTH(CURRENT_DATE) " +  // 先过滤本月订单
              "GROUP BY o.userId " +                                 // 按用户分组
              "HAVING SUM(o.amount) > 1000";                        // 再过滤总额

List<Object[]> bigSpenders = session.createQuery(hql2).list();
```

### 5.6 分组统计完整案例


**业务场景**：电商平台销售分析报表

```java
// 销售报表DTO
public class SalesReportDTO {
    private String category;      // 类别
    private Long orderCount;      // 订单数
    private Double totalAmount;   // 总金额
    private Double avgAmount;     // 平均金额
    private Long customerCount;   // 客户数
    
    public SalesReportDTO(String category, Long orderCount, Double totalAmount, 
                          Double avgAmount, Long customerCount) {
        this.category = category;
        this.orderCount = orderCount;
        this.totalAmount = totalAmount;
        this.avgAmount = avgAmount;
        this.customerCount = customerCount;
    }
}

// HQL查询
String hql = "SELECT new com.example.dto.SalesReportDTO(" +
             "p.category, " +                           // 分组字段
             "COUNT(o), " +                             // 订单数
             "SUM(o.amount), " +                        // 总金额
             "AVG(o.amount), " +                        // 平均金额
             "COUNT(DISTINCT o.userId)) " +             // 不重复客户数
             "FROM Order o JOIN o.product p " +
             "WHERE o.status = 'COMPLETED' " +          // 只统计已完成订单
             "GROUP BY p.category " +                   // 按类别分组
             "HAVING SUM(o.amount) > 10000 " +          // 只看销售额大于1万的类别
             "ORDER BY SUM(o.amount) DESC";             // 按销售额降序

List<SalesReportDTO> report = session.createQuery(hql, SalesReportDTO.class).list();

// 使用统计结果
for (SalesReportDTO item : report) {
    System.out.printf("类别: %s, 订单: %d, 总额: %.2f, 均价: %.2f, 客户: %d\n",
                      item.getCategory(), item.getOrderCount(), 
                      item.getTotalAmount(), item.getAvgAmount(), 
                      item.getCustomerCount());
}
```

### 5.7 分组统计最佳实践


**性能优化建议**：

> 💡 **索引优化**
> ```
> GROUP BY字段建议添加索引
> 可以显著提升分组查询性能
> ```

> ⚡ **查询优化**
> ```
> 1. 先用WHERE过滤数据，减少分组数据量
> 2. 避免在GROUP BY中使用复杂表达式
> 3. 大数据量分组考虑分页处理
> ```

**常见错误示例**：

```java
// ❌ 错误：SELECT中包含非分组字段
SELECT u.city, u.username, COUNT(u) FROM User u GROUP BY u.city

// ✓ 正确：只包含分组字段和聚合函数
SELECT u.city, COUNT(u) FROM User u GROUP BY u.city

// ❌ 错误：HAVING中使用WHERE条件
SELECT u.city, COUNT(u) FROM User u 
GROUP BY u.city 
HAVING u.status = 1  // 应该用WHERE

// ✓ 正确：WHERE过滤，HAVING筛选聚合结果
SELECT u.city, COUNT(u) FROM User u 
WHERE u.status = 1 
GROUP BY u.city 
HAVING COUNT(u) > 100
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 投影查询**：
```
本质：按需查询，只取需要的字段
优势：性能提升、内存节省、响应加快
返回：单字段返回对应类型，多字段返回Object[]
```

**🔸 构造器表达式**：
```
作用：自动封装查询结果到DTO对象
语法：new 完整类名(属性1, 属性2, ...)
优势：避免数组操作，代码更优雅
要求：必须有匹配的构造器
```

**🔸 聚合函数**：
```
COUNT：统计数量（注意DISTINCT用法）
SUM：求和（注意null处理）
AVG：平均值（返回Double类型）
MAX/MIN：最值（类型与原字段一致）
```

**🔸 分组统计**：
```
GROUP BY：分组关键字
规则：SELECT只能包含分组字段和聚合函数
HAVING：分组后过滤
执行顺序：WHERE → GROUP BY → HAVING
```

### 6.2 实际应用指南


**选择合适的查询方式**：

| 场景 | **推荐方案** | **理由** |
|------|------------|---------|
| 简单1-2个字段 | 普通投影 | 简单直接 |
| 3个以上字段 | 构造器表达式 | 代码清晰 |
| 需要统计 | 聚合函数 | 数据库层面计算效率高 |
| 分类统计 | GROUP BY | 一次查询得到所有分组结果 |
| 需要复用 | DTO+构造器 | 可维护性好 |

**性能优化技巧**：

```
🚀 查询优化：
1. 只查询必要字段，避免SELECT *
2. 合理使用索引，特别是GROUP BY字段
3. 大数据量使用分页，避免一次加载过多

💾 内存优化：
1. 使用投影减少对象创建
2. 及时关闭Session，释放资源
3. 避免N+1查询问题

⚡ 代码优化：
1. 复杂统计使用构造器表达式
2. 提取常用查询为方法
3. 合理使用参数绑定
```

### 6.3 常见问题解答


**Q1: 什么时候用投影，什么时候查完整对象？**
```
用投影：只需要部分字段、性能要求高、数据量大
查完整对象：需要操作实体、要进行update操作、字段较少
```

**Q2: Object[]操作麻烦，有更好的方式吗？**
```
有！使用构造器表达式封装成DTO
不仅代码清晰，还能提高可维护性
```

**Q3: 聚合函数返回null怎么办？**
```
方法1: 使用COALESCE函数
SELECT COALESCE(SUM(amount), 0) FROM Order

方法2: Java代码判断
Double sum = (result != null) ? result : 0.0;
```

**Q4: GROUP BY后能直接访问其他字段吗？**
```
不能！只能访问：
1. GROUP BY的分组字段
2. 聚合函数的结果

需要其他字段要用子查询或JOIN
```

**核心记忆口诀**：
```
投影查询按需取，构造器封装更优雅
聚合函数五大将，COUNT SUM AVG MAX MIN
分组统计GROUP BY，HAVING过滤在其后
性能优化记心间，索引投影分页全
```