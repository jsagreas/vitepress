---
title: 32、HQL高级语法
---
## 📚 目录


1. [JOIN连接查询](#1-JOIN连接查询)
2. [子查询详解](#2-子查询详解)
3. [聚合函数与分组](#3-聚合函数与分组)
4. [核心要点总结](#4-核心要点总结)

---

# 🎯 本章学习目标



**你将学会：**
- 如何用JOIN把多张表的数据关联起来查询
- 什么是子查询，怎么写嵌套查询
- 如何使用聚合函数统计数据
- 怎样对查询结果进行分组和条件过滤

**学习指南：**
```
📊 难度等级：★★★☆☆
⏱️ 预计时间：3-4小时
📋 前置知识：HQL基础语法、实体关系映射
```

---

## 1. 🔗 JOIN连接查询



### 1.1 什么是JOIN查询



**📌 核心概念：**
JOIN查询就是把多张表的数据"连接"起来一起查询。就像你要查学生和他们选的课程，学生信息在一张表，课程信息在另一张表，JOIN就是把它们关联起来。

**💭 生活类比：**
```
想象你有两个通讯录：
- 通讯录A：朋友的姓名和电话
- 通讯录B：朋友的姓名和地址

用JOIN就像把两个通讯录合并：
姓名 + 电话 + 地址，一次性看到完整信息
```

### 1.2 内连接（INNER JOIN）



**🔸 什么是内连接？**

内连接只返回**两边都有匹配的数据**。如果一边没有对应的数据，就不显示。

**图示说明：**
```
学生表                课程表
┌──────┬──────┐      ┌──────┬──────┐
│ ID   │ 姓名 │      │ ID   │ 课程 │
├──────┼──────┤      ├──────┼──────┤
│ 1    │ 张三 │──┐   │ 1    │ 数学 │
│ 2    │ 李四 │  └──→│ 2    │ 英语 │
│ 3    │ 王五 │      │ 4    │ 物理 │
└──────┴──────┘      └──────┴──────┘

INNER JOIN结果：只有1和2匹配上了
┌──────┬──────┬──────┐
│ ID   │ 姓名 │ 课程 │
├──────┼──────┼──────┤
│ 1    │ 张三 │ 数学 │
│ 2    │ 李四 │ 英语 │
└──────┴──────┴──────┘
(王五和物理都没匹配上，不显示)
```

**代码示例：**
```java
// 查询学生及其选课信息（只显示有选课的学生）
String hql = "FROM Student s INNER JOIN s.courses c";
List<Object[]> results = session.createQuery(hql).list();

// 遍历结果
for(Object[] row : results) {
    Student student = (Student) row[0];  // 学生对象
    Course course = (Course) row[1];     // 课程对象
    System.out.println(student.getName() + " 选了 " + course.getName());
}
```

**⚙️ 简化写法：**
```java
// INNER可以省略，直接写JOIN
String hql = "FROM Student s JOIN s.courses c";
```

### 1.3 左外连接（LEFT JOIN）



**🔸 什么是左外连接？**

左外连接会返回**左表的所有数据**，即使右表没有匹配的，也会显示（右边显示null）。

**图示说明：**
```
学生表(左)            课程表(右)
┌──────┬──────┐      ┌──────┬──────┐
│ ID   │ 姓名 │      │ ID   │ 课程 │
├──────┼──────┤      ├──────┼──────┤
│ 1    │ 张三 │──┐   │ 1    │ 数学 │
│ 2    │ 李四 │  └──→│ 2    │ 英语 │
│ 3    │ 王五 │ ✗    └──────┴──────┘
└──────┴──────┘

LEFT JOIN结果：左表全显示，右表没有就null
┌──────┬──────┬──────┐
│ ID   │ 姓名 │ 课程 │
├──────┼──────┼──────┤
│ 1    │ 张三 │ 数学 │
│ 2    │ 李四 │ 英语 │
│ 3    │ 王五 │ null │← 王五没选课也显示
└──────┴──────┴──────┘
```

**代码示例：**
```java
// 查询所有学生及其选课（没选课的学生也显示）
String hql = "FROM Student s LEFT JOIN s.courses c";
List<Object[]> results = session.createQuery(hql).list();

for(Object[] row : results) {
    Student student = (Student) row[0];
    Course course = (Course) row[1];  // 可能为null
    
    if(course != null) {
        System.out.println(student.getName() + " 选了 " + course.getName());
    } else {
        System.out.println(student.getName() + " 还没选课");
    }
}
```

**🎯 使用场景：**
- 查询所有员工及其部门（包括没分配部门的员工）
- 查询所有订单及其支付信息（包括未支付订单）
- 查询所有学生及其成绩（包括没考试的学生）

### 1.4 右外连接（RIGHT JOIN）



**🔸 什么是右外连接？**

右外连接会返回**右表的所有数据**，即使左表没有匹配的，也会显示（左边显示null）。

**图示说明：**
```
学生表(左)            课程表(右)
┌──────┬──────┐      ┌──────┬──────┐
│ ID   │ 姓名 │      │ ID   │ 课程 │
├──────┼──────┤      ├──────┼──────┤
│ 1    │ 张三 │──┐   │ 1    │ 数学 │
│ 2    │ 李四 │  └──→│ 2    │ 英语 │
└──────┴──────┘      │ 4    │ 物理 │← 没学生选
                      └──────┴──────┘

RIGHT JOIN结果：右表全显示，左表没有就null
┌──────┬──────┬──────┐
│ ID   │ 姓名 │ 课程 │
├──────┼──────┼──────┤
│ 1    │ 张三 │ 数学 │
│ 2    │ 李四 │ 英语 │
│ null │ null │ 物理 │← 物理课没人选也显示
└──────┴──────┴──────┘
```

**代码示例：**
```java
// 查询所有课程及其选课学生（没人选的课程也显示）
String hql = "FROM Student s RIGHT JOIN s.courses c";
List<Object[]> results = session.createQuery(hql).list();
```

**💡 实际应用技巧：**

在实际开发中，**LEFT JOIN用得最多**，RIGHT JOIN相对少见。因为：
```
需求："查询所有课程及选课学生"
方式1：Student RIGHT JOIN Course  (用RIGHT JOIN)
方式2：Course LEFT JOIN Student   (用LEFT JOIN，更清晰)

大多数人习惯用方式2，把要全部显示的表放左边
```

### 1.5 JOIN查询对比表



| JOIN类型 | **返回数据** | **使用场景** | **关键特点** |
|---------|------------|-------------|-------------|
| **INNER JOIN** | 只返回匹配的 | 只要有关联的数据 | 两边都必须有 |
| **LEFT JOIN** | 左表全部 + 右表匹配 | 主表全显示 | 左边必有，右边可null |
| **RIGHT JOIN** | 右表全部 + 左表匹配 | 从表全显示 | 右边必有，左边可null |

**🧠 记忆技巧：**
```
INNER：严格匹配，有一个没有就不要
LEFT：  左边是老大，全部要；右边看情况
RIGHT： 右边是老大，全部要；左边看情况
```

---

## 2. 🔍 子查询详解



### 2.1 什么是子查询



**📌 核心概念：**
子查询就是**查询里面套查询**，内层查询的结果可以给外层查询使用。

**💭 生活类比：**
```
任务：找出成绩最高的学生
步骤1：先找出最高分是多少（子查询）
步骤2：再找分数等于最高分的学生（主查询）

就像：
1. 先问："最贵的商品多少钱？" → 99元
2. 再问："哪些商品是99元？"  → 找出具体商品
```

### 2.2 子查询基本语法



**基本结构：**
```
主查询 WHERE 条件 IN/EXISTS/比较运算符 (子查询)
         ↑                              ↑
      外层查询                        内层查询
```

**代码示例：**
```java
// 查询选了"数学"课的所有学生
String hql = "FROM Student s WHERE s.id IN " +
             "(SELECT c.student.id FROM Course c WHERE c.name = '数学')";
             
List<Student> students = session.createQuery(hql).list();
```

**执行流程：**
```
第1步：执行子查询
SELECT c.student.id FROM Course c WHERE c.name = '数学'
→ 结果：[1, 3, 5] （选了数学课的学生ID）

第2步：执行主查询  
FROM Student s WHERE s.id IN (1, 3, 5)
→ 结果：ID为1、3、5的学生对象
```

### 2.3 EXISTS子查询



**🔸 什么是EXISTS？**

EXISTS用来判断**子查询是否有结果**，有结果就返回true，没结果就返回false。

**💡 EXISTS vs IN的区别：**
```
IN查询：
- 子查询返回具体值
- 主查询判断是否在这些值里面
- 示例：WHERE id IN (1, 2, 3)

EXISTS查询：
- 子查询只判断有没有数据
- 有数据就true，没数据就false  
- 示例：WHERE EXISTS (子查询)
```

**代码示例：**
```java
// 查询至少选了一门课的学生
String hql = "FROM Student s WHERE EXISTS " +
             "(SELECT 1 FROM s.courses c)";
             
List<Student> students = session.createQuery(hql).list();
```

**NOT EXISTS用法：**
```java
// 查询没有选课的学生
String hql = "FROM Student s WHERE NOT EXISTS " +
             "(SELECT 1 FROM s.courses c)";
```

**🎯 性能优化提示：**
```
大数据量场景：
- IN适合：子查询结果少（几十条）
- EXISTS适合：子查询结果多（成千上万条）

原因：EXISTS找到一条就停止，IN要全部找完
```

### 2.4 子查询实战案例



**案例1：找出成绩最高的学生**
```java
// 方法1：使用子查询
String hql = "FROM Student s WHERE s.score = " +
             "(SELECT MAX(score) FROM Student)";

// 方法2：使用ORDER BY（更简单）
String hql2 = "FROM Student ORDER BY score DESC";
List<Student> top = session.createQuery(hql2)
                           .setMaxResults(1)  // 只取第一条
                           .list();
```

**案例2：找出比平均分高的学生**
```java
String hql = "FROM Student s WHERE s.score > " +
             "(SELECT AVG(score) FROM Student)";
```

**案例3：找出同时选了"数学"和"英语"的学生**
```java
String hql = "FROM Student s WHERE " +
             "EXISTS (SELECT 1 FROM s.courses c WHERE c.name = '数学') " +
             "AND EXISTS (SELECT 1 FROM s.courses c WHERE c.name = '英语')";
```

---

## 3. 📊 聚合函数与分组



### 3.1 常用聚合函数



**📌 什么是聚合函数？**
聚合函数就是对一堆数据进行**统计计算**，得出一个汇总结果。

**常用聚合函数表：**

| 函数 | **作用** | **示例** | **返回结果** |
|-----|---------|---------|------------|
| `COUNT()` | 统计数量 | `COUNT(*)` | 总记录数 |
| `SUM()` | 求和 | `SUM(price)` | 价格总和 |
| `AVG()` | 求平均值 | `AVG(score)` | 平均分 |
| `MAX()` | 求最大值 | `MAX(age)` | 最大年龄 |
| `MIN()` | 求最小值 | `MIN(salary)` | 最低工资 |

**代码示例：**
```java
// 统计学生总数
String hql1 = "SELECT COUNT(*) FROM Student";
Long count = (Long) session.createQuery(hql1).uniqueResult();

// 计算平均分
String hql2 = "SELECT AVG(score) FROM Student";
Double avgScore = (Double) session.createQuery(hql2).uniqueResult();

// 找最高分和最低分
String hql3 = "SELECT MAX(score), MIN(score) FROM Student";
Object[] result = (Object[]) session.createQuery(hql3).uniqueResult();
Double maxScore = (Double) result[0];
Double minScore = (Double) result[1];
```

### 3.2 GROUP BY分组查询



**🔸 什么是分组？**

GROUP BY就是把数据**按某个条件分类统计**。

**💭 生活类比：**
```
场景：统计各个班级的平均分
不分组：所有学生的平均分 → 85分
分组：  
- 一班平均分 → 88分
- 二班平均分 → 82分  
- 三班平均分 → 87分
```

**图示说明：**
```
原始数据：
学生    班级    分数
张三    一班    90
李四    一班    80
王五    二班    85
赵六    二班    75

GROUP BY class 之后：
┌────────┬──────────┐
│ 班级   │ 平均分   │
├────────┼──────────┤
│ 一班   │  85      │
│ 二班   │  80      │
└────────┴──────────┘
```

**基本语法：**
```java
// 统计每个班级的学生人数
String hql = "SELECT s.className, COUNT(*) " +
             "FROM Student s " +
             "GROUP BY s.className";
             
List<Object[]> results = session.createQuery(hql).list();

for(Object[] row : results) {
    String className = (String) row[0];
    Long studentCount = (Long) row[1];
    System.out.println(className + "有" + studentCount + "人");
}
```

**🎯 GROUP BY规则：**
```
重要原则：
SELECT后面只能出现：
1. GROUP BY的字段
2. 聚合函数

错误示例：
SELECT s.name, s.className, COUNT(*)  ← name不能出现
FROM Student s
GROUP BY s.className

正确示例：
SELECT s.className, COUNT(*)  ← 只有分组字段和聚合函数
FROM Student s  
GROUP BY s.className
```

### 3.3 HAVING条件过滤



**🔸 HAVING vs WHERE的区别**

```
WHERE：  分组前过滤，过滤原始数据
HAVING： 分组后过滤，过滤统计结果

执行顺序：
1. WHERE  → 先过滤原始数据
2. GROUP BY → 再分组
3. HAVING → 最后过滤分组结果
```

**图示说明：**
```
数据处理流程：

原始数据
   ↓ WHERE（过滤个体）
符合条件的数据  
   ↓ GROUP BY（分组）
分组统计结果
   ↓ HAVING（过滤分组）
最终结果
```

**代码示例：**
```java
// 找出平均分大于80的班级
String hql = "SELECT s.className, AVG(s.score) " +
             "FROM Student s " +
             "GROUP BY s.className " +
             "HAVING AVG(s.score) > 80";
             
List<Object[]> results = session.createQuery(hql).list();
```

**WHERE和HAVING组合使用：**
```java
// 找出2023年入学的学生中，平均分超过85的班级
String hql = "SELECT s.className, AVG(s.score) " +
             "FROM Student s " +
             "WHERE s.enrollYear = 2023 " +      // 先过滤：只要2023年的
             "GROUP BY s.className " +            // 再分组：按班级
             "HAVING AVG(s.score) > 85";         // 最后过滤：平均分>85
```

**🧠 记忆技巧：**
```
WHERE：  筛选"个体"，分组前用
HAVING： 筛选"团队"，分组后用

例子：
WHERE age > 18      → 筛选成年人（个体条件）
HAVING COUNT(*) > 5 → 筛选人数>5的组（团队条件）
```

### 3.4 聚合查询完整示例



**实战案例：学生成绩分析系统**

```java
public class ScoreAnalysisService {
    
    // 1. 统计各班级成绩情况
    public void analyzeByClass() {
        String hql = "SELECT s.className, " +
                     "       COUNT(*), " +
                     "       AVG(s.score), " +
                     "       MAX(s.score), " +
                     "       MIN(s.score) " +
                     "FROM Student s " +
                     "GROUP BY s.className " +
                     "ORDER BY AVG(s.score) DESC";
                     
        List<Object[]> results = session.createQuery(hql).list();
        
        for(Object[] row : results) {
            System.out.println("班级：" + row[0]);
            System.out.println("人数：" + row[1]);
            System.out.println("平均分：" + row[2]);
            System.out.println("最高分：" + row[3]);
            System.out.println("最低分：" + row[4]);
            System.out.println("-------------------");
        }
    }
    
    // 2. 找出优秀班级（平均分>85且人数>30）
    public void findExcellentClasses() {
        String hql = "SELECT s.className, " +
                     "       COUNT(*) as count, " +
                     "       AVG(s.score) as avgScore " +
                     "FROM Student s " +
                     "GROUP BY s.className " +
                     "HAVING AVG(s.score) > 85 " +
                     "   AND COUNT(*) > 30 " +
                     "ORDER BY avgScore DESC";
                     
        List<Object[]> results = session.createQuery(hql).list();
    }
    
    // 3. 分数段统计
    public void analyzeScoreRange() {
        String hql = "SELECT " +
                     "  CASE " +
                     "    WHEN s.score >= 90 THEN '优秀' " +
                     "    WHEN s.score >= 80 THEN '良好' " +
                     "    WHEN s.score >= 60 THEN '及格' " +
                     "    ELSE '不及格' " +
                     "  END as level, " +
                     "  COUNT(*) " +
                     "FROM Student s " +
                     "GROUP BY " +
                     "  CASE " +
                     "    WHEN s.score >= 90 THEN '优秀' " +
                     "    WHEN s.score >= 80 THEN '良好' " +
                     "    WHEN s.score >= 60 THEN '及格' " +
                     "    ELSE '不及格' " +
                     "  END";
    }
}
```

---

## 4. 📋 核心要点总结



### 4.1 必须掌握的核心概念



**🔸 JOIN连接查询**
```
✅ INNER JOIN：只要匹配的，两边都得有
✅ LEFT JOIN：  左表全要，右表看情况（最常用）
✅ RIGHT JOIN： 右表全要，左表看情况（少用）

口诀：内连严格，左连左全，右连右全
```

**🔸 子查询**
```
✅ IN子查询：    主查询值在子查询结果里
✅ EXISTS子查询：只判断子查询有没有结果
✅ 比较运算符：  主查询与子查询结果比较

性能：数据量大时EXISTS比IN快
```

**🔸 聚合与分组**
```
✅ 聚合函数：COUNT、SUM、AVG、MAX、MIN
✅ GROUP BY：按字段分组统计
✅ HAVING：  过滤分组后的结果

执行顺序：WHERE → GROUP BY → HAVING
```

### 4.2 关键理解要点



**🔹 JOIN查询选择技巧**
```
需求分析：
- 只要有关联的数据        → INNER JOIN
- 主表数据都要显示        → LEFT JOIN  
- 从表数据都要显示        → RIGHT JOIN

实际开发：LEFT JOIN用得最多（80%以上）
```

**🔹 子查询优化建议**
```
能用JOIN就用JOIN：
× SELECT * FROM A WHERE id IN (SELECT id FROM B)
✓ SELECT * FROM A INNER JOIN B ON A.id = B.id

原因：JOIN性能通常比子查询好
```

**🔹 分组查询注意事项**
```
SELECT规则：
✓ GROUP BY的字段
✓ 聚合函数
× 其他字段（会报错）

过滤时机：
- 过滤原始数据 → WHERE
- 过滤统计结果 → HAVING
```

### 4.3 实战应用指南



**📋 知识点检查清单**
- [ ] 理解三种JOIN的区别和使用场景
- [ ] 掌握子查询的基本语法
- [ ] 会用EXISTS判断子查询结果
- [ ] 熟悉常用聚合函数
- [ ] 理解GROUP BY分组机制
- [ ] 掌握HAVING过滤条件
- [ ] 能区分WHERE和HAVING的使用时机

**🎯 常见应用场景**

| 场景 | **推荐方案** | **示例** |
|-----|------------|---------|
| 多表关联查询 | JOIN | 学生-课程关联 |
| 条件复杂的查询 | 子查询 | 找高于平均分的学生 |
| 数据统计分析 | 聚合函数 | 计算总分、平均分 |
| 分类汇总 | GROUP BY | 按班级统计人数 |
| 筛选统计结果 | HAVING | 找人数>50的班级 |

**⚠️ 常见错误提醒**

```java
// 错误1：GROUP BY后SELECT不相关字段
× SELECT name, class, COUNT(*) FROM Student GROUP BY class

// 正确写法
✓ SELECT class, COUNT(*) FROM Student GROUP BY class

// 错误2：聚合函数用WHERE过滤
× SELECT class FROM Student WHERE COUNT(*) > 5 GROUP BY class

// 正确写法  
✓ SELECT class FROM Student GROUP BY class HAVING COUNT(*) > 5

// 错误3：HAVING在GROUP BY前面
× SELECT class FROM Student HAVING COUNT(*) > 5 GROUP BY class

// 正确写法
✓ SELECT class FROM Student GROUP BY class HAVING COUNT(*) > 5
```

**🧠 核心记忆口诀**
```
JOIN连接分三种，内左右要分清
子查询套查询，EXISTS判真假
聚合函数五兄弟，统计分析全靠它
GROUP BY来分组，HAVING筛结果
WHERE分组前，HAVING分组后
```

---

## 📚 扩展学习资源



**深入学习建议：**
1. **实践为主**：多写HQL，在实际项目中练习
2. **性能优化**：学习查询计划，了解索引使用
3. **对比学习**：对照SQL语法，理解HQL特点
4. **调试工具**：使用`show_sql`查看生成的SQL

**相关章节链接：**
- [HQL基础语法](../31_HQL基础语法.md)
- [Criteria查询](../33_Criteria查询.md)
- [查询优化技巧](../34_查询优化.md)