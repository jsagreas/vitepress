---
title: 66、内置验证注解详解
---
## 📚 目录

1. [数据验证的本质理解](#1-数据验证的本质理解)
2. [三大非空验证注解详解](#2-三大非空验证注解详解)
3. [长度与数值范围验证](#3-长度与数值范围验证)
4. [格式与模式验证](#4-格式与模式验证)
5. [时间相关验证](#5-时间相关验证)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 数据验证的本质理解


### 1.1 为什么需要数据验证


**现实场景理解**：
```
用户注册表单：
- 用户名不能为空 → 需要验证
- 密码长度要求6-20位 → 需要验证
- 邮箱格式要正确 → 需要验证
- 年龄必须大于18岁 → 需要验证
```

**传统验证的痛点**：
```java
// 传统方式：到处都是if判断，代码重复且难维护
public void register(User user) {
    if (user.getName() == null || user.getName().isEmpty()) {
        throw new Exception("用户名不能为空");
    }
    if (user.getPassword().length() < 6) {
        throw new Exception("密码长度不能少于6位");
    }
    if (!user.getEmail().contains("@")) {
        throw new Exception("邮箱格式不正确");
    }
    // ... 更多验证代码
}
```

**Hibernate Validator的优势**：
```java
// 注解方式：直接在实体类上声明验证规则，简洁清晰
public class User {
    @NotEmpty(message = "用户名不能为空")
    private String name;
    
    @Size(min = 6, max = 20, message = "密码长度必须在6-20位")
    private String password;
    
    @Email(message = "邮箱格式不正确")
    private String email;
}
```

### 1.2 Hibernate Validator是什么


**通俗理解**：
- 🔸 **本质**：一个数据验证框架，帮你检查数据是否符合规则
- 🔸 **作用**：通过注解方式声明验证规则，自动完成数据校验
- 🔸 **好处**：代码简洁、规则集中、易于维护

**工作原理图解**：
```
用户提交数据 → Hibernate Validator检查注解规则 → 返回验证结果
     ↓                      ↓                        ↓
  {name:""}           检查@NotEmpty               验证失败
  {age:15}            检查@Min(18)                验证失败
  {email:"abc"}       检查@Email                  验证失败
```

### 1.3 验证注解的基本使用


**使用步骤**：
```
步骤 ①：添加依赖
步骤 ②：在实体类字段上添加验证注解
步骤 ③：在Controller中使用@Validated触发验证
步骤 ④：处理验证错误信息
```

**最简示例**：
```java
// 实体类
public class User {
    @NotNull  // 验证注解
    private String username;
}

// Controller
@PostMapping("/register")
public String register(@Validated User user) {  // @Validated触发验证
    return "注册成功";
}
```

---

## 2. 🔍 三大非空验证注解详解


### 2.1 为什么有三个非空验证


**核心区别理解**：
```
情况对比：
null值        → 没有对象引用
空字符串 ""    → 有对象但长度为0
空白 "   "    → 有对象但只有空格/制表符等
```

**三个注解的区别**：

| 注解 | null | 空字符串"" | 空白"  " | 典型用途 |
|------|------|-----------|---------|----------|
| **@NotNull** | `❌不通过` | `✅通过` | `✅通过` | `基本数据类型、对象` |
| **@NotEmpty** | `❌不通过` | `❌不通过` | `✅通过` | `字符串、集合` |
| **@NotBlank** | `❌不通过` | `❌不通过` | `❌不通过` | `用户输入的文本` |

### 2.2 @NotNull - 对象不能为空


**含义理解**：
- 🔸 只检查对象引用是否为null
- 🔸 不关心对象内容是什么
- 🔸 适用于任何类型（基本类型、对象、集合等）

**实际应用**：
```java
public class Order {
    @NotNull(message = "订单ID不能为空")
    private Long orderId;
    
    @NotNull(message = "用户信息不能为空")
    private User user;
    
    @NotNull(message = "订单商品不能为空")
    private List<Product> products;
}
```

**验证结果示例**：
```
orderId = null     → ❌ 验证失败："订单ID不能为空"
orderId = 0        → ✅ 验证通过（有值，即使是0）

user = null        → ❌ 验证失败
user = new User()  → ✅ 验证通过（对象不为null）

products = null           → ❌ 验证失败
products = new ArrayList() → ✅ 验证通过（集合不为null，即使是空集合）
```

### 2.3 @NotEmpty - 不能为空且有内容


**含义理解**：
- 🔸 既不能为null，也不能为空
- 🔸 对字符串：不能是 `""`
- 🔸 对集合：不能是空集合 `[]`
- 🔸 对数组：不能是空数组

**适用类型**：
```
✅ String类型
✅ Collection集合（List、Set等）
✅ Map集合
✅ 数组
```

**实际应用**：
```java
public class Article {
    @NotEmpty(message = "文章标题不能为空")
    private String title;
    
    @NotEmpty(message = "文章标签至少要有一个")
    private List<String> tags;
    
    @NotEmpty(message = "作者信息不能为空")
    private Map<String, String> authorInfo;
}
```

**验证结果示例**：
```
title = null        → ❌ 验证失败
title = ""          → ❌ 验证失败
title = "   "       → ✅ 验证通过（有空格，算有内容）
title = "Vue学习"   → ✅ 验证通过

tags = null         → ❌ 验证失败
tags = []           → ❌ 验证失败（空集合）
tags = ["Vue"]      → ✅ 验证通过
```

### 2.4 @NotBlank - 不能为空白（最严格）


**含义理解**：
- 🔸 不能为null
- 🔸 不能为空字符串 `""`
- 🔸 不能只有空白字符 `"   "`、`"\t"`、`"\n"`等
- 🔸 **只能用于String类型**

**为什么最严格**：
```
用户输入场景：
用户名输入："   "（只有空格）
→ @NotEmpty会通过，但这不是有效输入
→ @NotBlank会拦截，这才是我们真正想要的
```

**实际应用**：
```java
public class User {
    @NotBlank(message = "用户名不能为空白")
    private String username;
    
    @NotBlank(message = "真实姓名不能为空白")
    private String realName;
    
    @NotBlank(message = "评论内容不能为空白")
    private String comment;
}
```

**验证结果示例**：
```
username = null      → ❌ 验证失败
username = ""        → ❌ 验证失败
username = "   "     → ❌ 验证失败（这是关键区别！）
username = "  张三 " → ✅ 验证通过（有非空白字符）
username = "admin"   → ✅ 验证通过
```

### 2.5 三者选择建议


**选择原则**：

```
🟢 用@NotNull的场景：
- 对象引用：用户对象、配置对象等
- 数值类型：ID、数量等
- 不关心内容，只要有值

🟡 用@NotEmpty的场景：
- 集合数据：标签列表、商品列表等
- 需要有元素：购物车、订单项等

🔴 用@NotBlank的场景：
- 用户输入：用户名、评论、地址等
- 文本内容：标题、描述、备注等
- 需要真正有意义的文本
```

**最佳实践示例**：
```java
public class UserRegisterDTO {
    // 用户输入的文本 → 用@NotBlank
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    private String password;
    
    // 可选的集合 → 用@NotEmpty（如果必填）
    @NotEmpty(message = "至少选择一个兴趣爱好")
    private List<String> hobbies;
    
    // 对象引用 → 用@NotNull
    @NotNull(message = "必须同意用户协议")
    private Boolean agreeTerms;
}
```

---

## 3. 📏 长度与数值范围验证


### 3.1 @Size - 长度/大小验证


**核心理解**：
- 🔸 验证字符串长度、集合大小、数组长度
- 🔸 可以设置最小值(min)和最大值(max)
- 🔸 min和max都是可选的，可以只设置一个

**适用场景对照表**：

| 验证对象 | 验证的是什么 | 常见应用 |
|---------|-------------|---------|
| **String** | `字符长度` | `用户名、密码、评论` |
| **Collection** | `元素个数` | `标签数量、选项数量` |
| **Array** | `数组长度` | `上传文件数量` |
| **Map** | `键值对数量` | `配置项数量` |

**基础用法**：
```java
public class User {
    // 用户名长度限制
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20个字符之间")
    private String username;
    
    // 密码长度限制
    @Size(min = 6, max = 30, message = "密码长度必须在6-30个字符之间")
    private String password;
    
    // 个人简介长度限制
    @Size(max = 200, message = "个人简介不能超过200字")
    private String bio;
    
    // 兴趣爱好数量限制
    @Size(min = 1, max = 5, message = "请选择1-5个兴趣爱好")
    private List<String> hobbies;
}
```

**验证效果示例**：
```
username = "ab"        → ❌ 失败（只有2个字符，小于min=3）
username = "admin"     → ✅ 通过（5个字符，在范围内）
username = "verylongusername123" → ❌ 失败（超过20个字符）

hobbies = []           → ❌ 失败（0个元素，小于min=1）
hobbies = ["读书"]     → ✅ 通过（1个元素）
hobbies = ["读书","运动","旅游"] → ✅ 通过（3个元素）
hobbies = ["读书","运动","旅游","音乐","电影","摄影"] → ❌ 失败（6个，超过max=5）
```

**实用技巧**：
```java
// 只限制最小值
@Size(min = 1, message = "至少要有一个标签")
private List<String> tags;

// 只限制最大值
@Size(max = 500, message = "评论不能超过500字")
private String comment;

// 精确长度（把min和max设为相同值）
@Size(min = 11, max = 11, message = "手机号必须是11位")
private String mobile;
```

### 3.2 @Min/@Max - 数值范围验证


**核心理解**：
- 🔸 @Min：验证数字不能小于指定值（大于等于）
- 🔸 @Max：验证数字不能大于指定值（小于等于）
- 🔸 只用于数值类型

**适用类型**：
```
✅ 整数类型：int, Integer, long, Long等
✅ 浮点类型：float, Float, double, Double等
✅ 大数类型：BigDecimal, BigInteger
```

**实际应用场景**：
```java
public class Product {
    // 商品价格：最低0.01元
    @Min(value = 0.01, message = "商品价格不能低于0.01元")
    private BigDecimal price;
    
    // 库存数量：至少0件
    @Min(value = 0, message = "库存不能为负数")
    private Integer stock;
    
    // 商品评分：0-5分
    @Min(value = 0, message = "评分不能低于0")
    @Max(value = 5, message = "评分不能高于5")
    private Integer rating;
    
    // 折扣比例：10%-90%
    @Min(value = 10, message = "折扣不能低于10%")
    @Max(value = 90, message = "折扣不能高于90%")
    private Integer discount;
}
```

**常见业务场景**：
```java
// 年龄验证
@Min(value = 18, message = "必须年满18岁")
@Max(value = 120, message = "年龄不能超过120岁")
private Integer age;

// 数量验证
@Min(value = 1, message = "购买数量至少为1")
@Max(value = 999, message = "单次购买不能超过999件")
private Integer quantity;

// 百分比验证
@Min(value = 0, message = "百分比不能为负数")
@Max(value = 100, message = "百分比不能超过100")
private Integer percentage;
```

**验证效果示例**：
```
age = 17     → ❌ 失败（小于18）
age = 18     → ✅ 通过（等于最小值）
age = 25     → ✅ 通过
age = 120    → ✅ 通过（等于最大值）
age = 121    → ❌ 失败（超过120）

price = 0         → ❌ 失败（小于0.01）
price = 0.01      → ✅ 通过
price = 99.99     → ✅ 通过
```

### 3.3 @DecimalMin/@DecimalMax - 精确小数验证


**为什么需要这两个注解**：
```
@Min/@Max的限制：
- 只能用整数作为边界值
- 无法精确控制小数边界

@DecimalMin/@DecimalMax的优势：
- 可以用字符串指定精确的小数值
- 可以控制是否包含边界值（inclusive参数）
```

**实际应用**：
```java
public class Order {
    // 订单金额：最低0.01元（包含）
    @DecimalMin(value = "0.01", message = "订单金额不能低于0.01元")
    private BigDecimal amount;
    
    // 商品重量：不超过100.5kg（不包含100.5）
    @DecimalMax(value = "100.5", inclusive = false, message = "商品重量必须小于100.5kg")
    private BigDecimal weight;
    
    // 折扣率：0.1-0.95之间
    @DecimalMin(value = "0.1", message = "折扣率不能低于0.1")
    @DecimalMax(value = "0.95", message = "折扣率不能高于0.95")
    private BigDecimal discountRate;
}
```

**inclusive参数详解**：
```
inclusive = true（默认）：包含边界值（大于等于/小于等于）
inclusive = false：不包含边界值（大于/小于）

示例：
@DecimalMin(value = "0", inclusive = true)   → 值 >= 0
@DecimalMin(value = "0", inclusive = false)  → 值 > 0

@DecimalMax(value = "100", inclusive = true)  → 值 <= 100
@DecimalMax(value = "100", inclusive = false) → 值 < 100
```

---

## 4. 🎨 格式与模式验证


### 4.1 @Pattern - 正则表达式验证


**核心理解**：
- 🔸 使用正则表达式验证字符串格式
- 🔸 适合复杂的格式验证场景
- 🔸 只能用于String类型

**常见应用场景**：

**① 手机号验证**：
```java
public class User {
    // 中国大陆手机号：11位数字，1开头
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String mobile;
}
```

**② 身份证号验证**：
```java
// 18位身份证号
@Pattern(
    regexp = "^[1-9]\\d{5}(19|20)\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])\\d{3}[0-9Xx]$",
    message = "身份证号格式不正确"
)
private String idCard;
```

**③ 用户名规则验证**：
```java
// 用户名：4-16位字母、数字、下划线
@Pattern(regexp = "^[a-zA-Z0-9_]{4,16}$", message = "用户名必须是4-16位字母、数字或下划线")
private String username;
```

**④ 邮政编码验证**：
```java
// 中国邮政编码：6位数字
@Pattern(regexp = "^\\d{6}$", message = "邮政编码必须是6位数字")
private String zipCode;
```

**正则表达式速查**：
```
常用模式：
^        → 字符串开始
$        → 字符串结束
\\d      → 数字（0-9）
\\w      → 字母、数字、下划线
[a-zA-Z] → 英文字母
{n}      → 重复n次
{n,m}    → 重复n到m次
```

### 4.2 @Email - 邮箱格式验证


**核心理解**：
- 🔸 专门用于验证邮箱格式
- 🔸 内置了邮箱格式的正则规则
- 🔸 比自己写正则更简单、更可靠

**基础用法**：
```java
public class User {
    @Email(message = "邮箱格式不正确")
    private String email;
}
```

**验证规则说明**：
```
✅ 合法的邮箱格式：
- admin@example.com
- user.name@company.com.cn
- support+help@domain.org

❌ 非法的邮箱格式：
- admin@                  （没有域名）
- @example.com            （没有用户名）
- admin@.com              （域名格式错误）
- admin example.com       （缺少@符号）
```

**进阶用法（自定义邮箱规则）**：
```java
// 只允许公司邮箱
@Email(message = "邮箱格式不正确")
@Pattern(regexp = ".*@company\\.com$", message = "只能使用公司邮箱")
private String workEmail;

// 邮箱可以为空，但如果有值必须格式正确
@Email(message = "邮箱格式不正确")
private String optionalEmail;  // null值会通过验证

// 邮箱必填且格式正确
@NotBlank(message = "邮箱不能为空")
@Email(message = "邮箱格式不正确")
private String requiredEmail;
```

### 4.3 @URL - 网址格式验证


**核心理解**：
- 🔸 验证URL地址格式是否正确
- 🔸 支持http、https、ftp等协议
- 🔸 可以自定义允许的协议类型

**基础用法**：
```java
public class Website {
    @URL(message = "网站地址格式不正确")
    private String url;
    
    @URL(message = "个人主页地址格式不正确")
    private String homepage;
}
```

**验证示例**：
```
✅ 合法的URL：
- http://www.example.com
- https://example.com/page
- ftp://files.example.com
- https://example.com:8080/api

❌ 非法的URL：
- www.example.com          （缺少协议）
- http://                  （不完整）
- just some text           （不是URL）
```

**指定协议验证**：
```java
// 只允许https协议
@URL(protocol = "https", message = "必须使用https协议")
private String secureUrl;

// 只允许http或https
@URL(message = "网址格式不正确")
@Pattern(regexp = "^https?://.*", message = "必须使用http或https协议")
private String webUrl;
```

**实际应用场景**：
```java
public class SocialMedia {
    // 个人网站
    @URL(message = "个人网站地址格式不正确")
    private String website;
    
    // 微博链接
    @URL(message = "微博链接格式不正确")
    private String weiboUrl;
    
    // GitHub主页
    @URL(message = "GitHub地址格式不正确")
    @Pattern(regexp = "^https://github\\.com/.*", message = "必须是GitHub地址")
    private String githubUrl;
}
```

---

## 5. 📅 时间相关验证


### 5.1 时间验证的应用场景


**为什么需要时间验证**：
```
实际业务场景：
- 生日必须是过去的日期
- 预约时间必须是将来的日期
- 活动开始时间必须早于结束时间
- 会员到期日期必须晚于注册日期
```

**时间验证注解对照**：

| 注解 | 含义 | 典型应用 |
|------|------|---------|
| **@Past** | `必须是过去的时间` | `生日、入职日期、历史记录` |
| **@PastOrPresent** | `过去或当前时间` | `订单创建时间、更新时间` |
| **@Future** | `必须是将来的时间` | `预约时间、活动时间、到期时间` |
| **@FutureOrPresent** | `将来或当前时间` | `计划开始时间、有效期` |

### 5.2 @Past - 过去时间验证


**核心理解**：
- 🔸 验证的日期/时间必须是过去的
- 🔸 不包括当前时间
- 🔸 适合历史数据验证

**适用类型**：
```
✅ Date类型
✅ LocalDate、LocalDateTime（Java 8+）
✅ Calendar类型
```

**实际应用**：
```java
public class Employee {
    // 出生日期：必须是过去的
    @Past(message = "出生日期必须是过去的日期")
    private LocalDate birthday;
    
    // 入职日期：必须是过去的
    @Past(message = "入职日期必须是过去的日期")
    private LocalDate hireDate;
    
    // 离职日期：如果填写，必须是过去的
    @Past(message = "离职日期必须是过去的日期")
    private LocalDate resignDate;
}
```

**验证效果示例**：
```
当前日期：2025-09-23

birthday = 2000-01-01    → ✅ 通过（过去的日期）
birthday = 2025-09-23    → ❌ 失败（今天，不是过去）
birthday = 2025-09-24    → ❌ 失败（明天，未来的日期）
birthday = null          → ✅ 通过（null值默认通过，需要配合@NotNull）
```

### 5.3 @PastOrPresent - 过去或当前时间


**与@Past的区别**：
```
@Past：           只能是过去，不包括现在
@PastOrPresent：  可以是过去，也可以是现在
```

**应用场景**：
```java
public class Order {
    // 订单创建时间：可以是过去或刚刚创建（现在）
    @PastOrPresent(message = "订单创建时间不能是将来")
    private LocalDateTime createTime;
    
    // 支付时间：可以是过去或刚刚支付
    @PastOrPresent(message = "支付时间不能是将来")
    private LocalDateTime payTime;
}
```

**为什么需要这个注解**：
```
场景理解：
- 用户刚提交订单，创建时间就是现在
- 如果用@Past验证会失败（因为不包括现在）
- 用@PastOrPresent就可以通过
```

### 5.4 @Future - 将来时间验证


**核心理解**：
- 🔸 验证的日期/时间必须是将来的
- 🔸 不包括当前时间
- 🔸 适合预约、计划等场景

**实际应用**：
```java
public class Appointment {
    // 预约时间：必须是将来的时间
    @Future(message = "预约时间必须是将来的时间")
    private LocalDateTime appointmentTime;
    
    // 会议开始时间
    @Future(message = "会议时间必须是将来的时间")
    private LocalDateTime meetingTime;
}

public class Activity {
    // 活动开始时间
    @Future(message = "活动开始时间必须是将来的时间")
    private LocalDateTime startTime;
    
    // 报名截止时间
    @Future(message = "报名截止时间必须是将来的时间")
    private LocalDateTime deadline;
}
```

**验证效果示例**：
```
当前时间：2025-09-23 10:00:00

appointmentTime = 2025-09-22 10:00:00  → ❌ 失败（昨天，过去）
appointmentTime = 2025-09-23 10:00:00  → ❌ 失败（现在，不是将来）
appointmentTime = 2025-09-23 11:00:00  → ✅ 通过（1小时后，将来）
appointmentTime = 2025-09-24 10:00:00  → ✅ 通过（明天，将来）
```

### 5.5 @FutureOrPresent - 将来或当前时间


**应用场景**：
```java
public class Plan {
    // 计划开始时间：可以是现在或将来
    @FutureOrPresent(message = "计划开始时间不能是过去")
    private LocalDateTime startTime;
    
    // 有效期：可以从现在开始
    @FutureOrPresent(message = "有效期不能是过去的时间")
    private LocalDate validUntil;
}
```

**实际使用建议**：
```java
// 组合使用，确保时间逻辑正确
public class Event {
    @NotNull(message = "开始时间不能为空")
    @FutureOrPresent(message = "开始时间不能是过去")
    private LocalDateTime startTime;
    
    @NotNull(message = "结束时间不能为空")
    @Future(message = "结束时间必须是将来")
    private LocalDateTime endTime;
    
    // 自定义验证：结束时间必须晚于开始时间
    @AssertTrue(message = "结束时间必须晚于开始时间")
    public boolean isEndTimeAfterStartTime() {
        if (startTime == null || endTime == null) {
            return true;
        }
        return endTime.isAfter(startTime);
    }
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 三大非空验证的本质区别**：
```
@NotNull    → 只检查是否为null（最宽松）
@NotEmpty   → 检查null + 空内容（字符串""、空集合[]）
@NotBlank   → 检查null + 空内容 + 空白字符（最严格，只用于String）

记忆口诀：
NotNull看对象，NotEmpty看长度，NotBlank看内容
```

**🔸 长度与数值验证的选择**：
```
验证字符串长度、集合大小  → 用 @Size
验证数字范围（整数边界）   → 用 @Min/@Max
验证数字范围（小数边界）   → 用 @DecimalMin/@DecimalMax

记忆技巧：
Size管尺寸，Min/Max管数值
```

**🔸 格式验证的层次**：
```
通用格式验证   → @Pattern（正则表达式，最灵活）
专用格式验证   → @Email、@URL（专门场景，更简单）

选择原则：
有专用注解优先用专用，没有就用@Pattern
```

**🔸 时间验证的记忆方法**：
```
Past系列     → 过去的时间（历史数据）
Future系列   → 将来的时间（预约计划）
OrPresent    → 加上这个后缀就包含当前时间

时间线理解：
Past ← PastOrPresent ← [现在] → FutureOrPresent → Future
```

### 6.2 实际应用的最佳实践


**① 组合使用策略**：
```java
// ✅ 正确做法：根据业务需求组合注解
public class UserRegisterDTO {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度3-20位")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "只能包含字母数字下划线")
    private String username;
}

// ❌ 错误做法：重复验证
@NotNull  // 多余，@NotBlank已经包含了非null验证
@NotBlank
private String username;
```

**② 消息提示技巧**：
```java
// ✅ 清晰的错误提示
@Size(min = 6, max = 20, message = "密码长度必须在6-20位之间")
private String password;

// ❌ 模糊的错误提示
@Size(min = 6, max = 20, message = "密码长度不符合要求")
private String password;
```

**③ 可选字段处理**：
```java
// 邮箱可选，但如果填写必须格式正确
@Email(message = "邮箱格式不正确")  // null值会通过
private String email;

// 邮箱必填且格式正确
@NotBlank(message = "邮箱不能为空")
@Email(message = "邮箱格式不正确")
private String email;
```

### 6.3 常见问题与解决方案


**问题1：三个非空注解该用哪个？**
```
判断流程：
1. 是用户输入的文本吗？ → 用@NotBlank
2. 是集合或数组吗？ → 用@NotEmpty
3. 是对象引用或数值吗？ → 用@NotNull
```

**问题2：@Size和@Length有什么区别？**
```
@Size：   标准的Bean Validation注解（推荐）
@Length： Hibernate Validator特有注解

建议：优先使用@Size，更通用
```

**问题3：如何验证两个字段的关系？**
```java
// 使用@AssertTrue自定义验证方法
public class ChangePassword {
    private String newPassword;
    private String confirmPassword;
    
    @AssertTrue(message = "两次密码输入不一致")
    public boolean isPasswordMatch() {
        if (newPassword == null || confirmPassword == null) {
            return true;  // null值交给@NotNull验证
        }
        return newPassword.equals(confirmPassword);
    }
}
```

**问题4：正则表达式太复杂怎么办？**
```java
// 方案1：提取为常量
public class RegexPatterns {
    public static final String MOBILE = "^1[3-9]\\d{9}$";
    public static final String EMAIL = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
}

@Pattern(regexp = RegexPatterns.MOBILE, message = "手机号格式不正确")
private String mobile;

// 方案2：自定义注解封装
@MobileNumber  // 自定义的简单注解
private String mobile;
```

### 6.4 快速参考表


**验证注解速查表**：

| 需求 | 使用注解 | 示例代码 |
|------|---------|---------|
| `对象不为null` | `@NotNull` | `@NotNull private Long id;` |
| `字符串不为空` | `@NotBlank` | `@NotBlank private String name;` |
| `集合不为空` | `@NotEmpty` | `@NotEmpty private List<String> tags;` |
| `字符串长度` | `@Size` | `@Size(min=3, max=20) private String username;` |
| `数字范围` | `@Min @Max` | `@Min(0) @Max(100) private Integer score;` |
| `手机号` | `@Pattern` | `@Pattern(regexp="^1[3-9]\\d{9}$")` |
| `邮箱` | `@Email` | `@Email private String email;` |
| `网址` | `@URL` | `@URL private String website;` |
| `过去时间` | `@Past` | `@Past private LocalDate birthday;` |
| `将来时间` | `@Future` | `@Future private LocalDateTime appointmentTime;` |

**核心记忆口诀**：
```
非空三兄弟，NotNull最宽松
NotEmpty管长度，NotBlank最严格
Size管尺寸，Min/Max管数值
Email和URL，格式验证不用愁
Past看历史，Future看未来
Pattern万能，正则来帮忙
```