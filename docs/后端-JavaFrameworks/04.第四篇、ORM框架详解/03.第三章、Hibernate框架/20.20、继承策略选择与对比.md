---
title: 20、继承策略选择与对比
---
## 📚 目录

1. [继承映射概述](#1-继承映射概述)
2. [三种继承策略详解](#2-三种继承策略详解)
3. [性能分析对比](#3-性能分析对比)
4. [存储空间对比](#4-存储空间对比)
5. [查询复杂度分析](#5-查询复杂度分析)
6. [策略选择原则](#6-策略选择原则)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 继承映射概述


### 1.1 什么是继承映射


**生活化理解**：就像公司员工分类一样
```
员工（Employee）
├── 正式员工（FullTimeEmployee）
│   ├── 有固定工资
│   └── 有五险一金
└── 兼职员工（PartTimeEmployee）
    ├── 按小时计费
    └── 无五险一金
```

**技术含义**：
- 在**Java代码**中，我们用继承表示"是一个"的关系
- 在**数据库**中，表与表之间没有继承概念
- **继承映射**就是把Java的继承关系映射到数据库表中

> 💡 **核心问题**：如何把面向对象的继承关系存储到关系型数据库的表中？

### 1.2 为什么需要继承映射


**实际场景**：电商系统的商品分类
```
商品（Product）
├── 图书（Book）        → 有作者、ISBN
├── 电子产品（Electronics） → 有保修期、型号
└── 服装（Clothing）     → 有尺码、材质
```

如果不用继承映射：
- ❌ 需要为每种商品建独立表，**代码重复**
- ❌ 查询所有商品很麻烦，**要union多个表**
- ❌ 添加通用字段时，**每个表都要改**

使用继承映射：
- ✅ 代码复用，共同属性在父类
- ✅ 统一查询，一个查询搞定
- ✅ 易于扩展，加子类不影响其他

### 1.3 继承映射的三大策略


Hibernate提供三种方式：

| 策略名称 | 核心思想 | 通俗理解 |
|---------|---------|---------|
| **单表策略** <br> `SINGLE_TABLE` | 所有类存一张表 | 把所有员工信息放一张表，用字段区分类型 |
| **联合表策略** <br> `JOINED` | 父类一张表，子类各一张表 | 基本信息一张表，特有信息分别存 |
| **每类一表策略** <br> `TABLE_PER_CLASS` | 每个具体类独立一张表 | 正式工一张表，兼职工一张表，各存各的 |

---

## 2. 📊 三种继承策略详解


### 2.1 单表策略（SINGLE_TABLE）


**🔸 核心原理**

把**整个继承树的所有类**都存到**一张表**里，用一个**鉴别字段**区分具体类型。

**表结构示意**：
```
员工表（employee）
┌──────┬──────┬─────────┬────────┬──────────┬───────────┐
│ id   │ type │ name    │ salary │ hourRate │ insurance │
├──────┼──────┼─────────┼────────┼──────────┼───────────┤
│ 1    │ FT   │ 张三    │ 8000   │ NULL     │ 五险一金   │  ← 正式工
│ 2    │ PT   │ 李四    │ NULL   │ 50       │ NULL      │  ← 兼职工
│ 3    │ FT   │ 王五    │ 9000   │ NULL     │ 五险一金   │  ← 正式工
└──────┴──────┴─────────┴────────┴──────────┴───────────┘

说明：
- type字段就是鉴别器，FT=正式工，PT=兼职工
- 正式工的hourRate为NULL（用不到）
- 兼职工的salary和insurance为NULL（用不到）
```

**代码配置**：
```java
// 父类：员工
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "type")  // 鉴别字段
public class Employee {
    @Id
    private Long id;
    private String name;
}

// 子类：正式员工
@Entity
@DiscriminatorValue("FT")  // 该类型的鉴别值
public class FullTimeEmployee extends Employee {
    private Double salary;
    private String insurance;
}

// 子类：兼职员工
@Entity
@DiscriminatorValue("PT")
public class PartTimeEmployee extends Employee {
    private Double hourRate;
}
```

**✅ 优点**：
- **性能最好**：查询不需要join，一张表搞定
- **实现简单**：Hibernate默认策略，配置最少
- **多态查询快**：查询所有员工直接扫一张表

**❌ 缺点**：
- **空间浪费**：子类特有字段会有很多NULL值
- **字段爆炸**：子类多了，字段会很多很乱
- **无法非空约束**：子类字段无法设置NOT NULL

**🎯 适用场景**：
- 子类属性**差异不大**
- 子类**数量较少**（3-5个）
- **查询性能要求高**

---

### 2.2 联合表策略（JOINED）


**🔸 核心原理**

父类一张表存**共同属性**，每个子类一张表存**特有属性**，通过**主键关联**。

**表结构示意**：
```
员工表（employee）- 父类表
┌──────┬─────────┐
│ id   │ name    │
├──────┼─────────┤
│ 1    │ 张三    │
│ 2    │ 李四    │
│ 3    │ 王五    │
└──────┴─────────┘
         ↓ (主键关联)
    ┌────────────────┐
    ↓                ↓
正式员工表           兼职员工表
(full_time_emp)      (part_time_emp)
┌──────┬────────┬────────┐  ┌──────┬──────────┐
│ id   │ salary │insurance│  │ id   │ hourRate │
├──────┼────────┼────────┤  ├──────┼──────────┤
│ 1    │ 8000   │五险一金 │  │ 2    │ 50       │
│ 3    │ 9000   │五险一金 │  └──────┴──────────┘
└──────┴────────┴────────┘

说明：
- 共同属性（id, name）在父表
- 特有属性在各自子表
- 通过id关联，id值相同表示是同一个员工
```

**代码配置**：
```java
// 父类
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Employee {
    @Id
    private Long id;
    private String name;
}

// 子类：正式员工
@Entity
@Table(name = "full_time_emp")
public class FullTimeEmployee extends Employee {
    private Double salary;
    private String insurance;
}

// 子类：兼职员工
@Entity
@Table(name = "part_time_emp")
public class PartTimeEmployee extends Employee {
    private Double hourRate;
}
```

**✅ 优点**：
- **表结构规范**：符合数据库范式，没有冗余字段
- **支持约束**：子类字段可以设置NOT NULL等约束
- **扩展性好**：加子类不影响现有表结构

**❌ 缺点**：
- **查询性能差**：每次查询需要JOIN多张表
- **插入复杂**：一个对象要插入多张表
- **SQL复杂**：生成的SQL语句较复杂

**🎯 适用场景**：
- 子类属性**差异很大**
- 需要**严格的表结构**
- **数据完整性**要求高
- 查询性能不是首要考虑

---

### 2.3 每类一表策略（TABLE_PER_CLASS）


**🔸 核心原理**

**每个具体类**（不包括抽象父类）都有**独立的表**，包含所有属性（继承的+自己的）。

**表结构示意**：
```
没有员工表！只有子类表：

正式员工表（full_time_employee）
┌──────┬─────────┬────────┬───────────┐
│ id   │ name    │ salary │ insurance │  ← 包含父类属性
├──────┼─────────┼────────┼───────────┤
│ 1    │ 张三    │ 8000   │ 五险一金   │
│ 3    │ 王五    │ 9000   │ 五险一金   │
└──────┴─────────┴────────┴───────────┘

兼职员工表（part_time_employee）
┌──────┬─────────┬──────────┐
│ id   │ name    │ hourRate │  ← 包含父类属性
├──────┼─────────┼──────────┤
│ 2    │ 李四    │ 50       │
└──────┴─────────┴──────────┘

说明：
- 父类属性（name）在每个子类表中都重复
- 各表完全独立，没有关联
```

**代码配置**：
```java
// 父类
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Employee {  // 通常设为抽象类
    @Id
    private Long id;
    private String name;
}

// 子类：正式员工
@Entity
@Table(name = "full_time_employee")
public class FullTimeEmployee extends Employee {
    private Double salary;
    private String insurance;
}

// 子类：兼职员工
@Entity
@Table(name = "part_time_employee")
public class PartTimeEmployee extends Employee {
    private Double hourRate;
}
```

**✅ 优点**：
- **查询子类快**：查询单个子类不需要JOIN
- **表独立**：各表完全独立，互不影响
- **支持约束**：可以设置完整的表约束

**❌ 缺点**：
- **属性重复**：父类属性在每张表都存一份
- **多态查询慢**：查询所有员工需要UNION多张表
- **修改困难**：改父类属性，所有表都要改
- **不支持标识列**：某些数据库不支持这种方式的自增ID

**🎯 适用场景**：
- **很少进行多态查询**
- 子类**完全独立**，几乎不作为整体查询
- **不推荐使用**（Hibernate官方也不推荐）

---

## 3. ⚡ 性能分析对比


### 3.1 查询性能对比


**场景1：查询单个具体对象**
```
查询一个正式员工（ID=1）

SINGLE_TABLE（单表）：
SELECT * FROM employee WHERE id = 1 AND type = 'FT'
性能：★★★★★ 最快

JOINED（联合表）：
SELECT e.*, f.* 
FROM employee e 
JOIN full_time_emp f ON e.id = f.id 
WHERE e.id = 1
性能：★★★☆☆ 需要JOIN

TABLE_PER_CLASS（每类一表）：
SELECT * FROM full_time_employee WHERE id = 1
性能：★★★★☆ 单表查询，但需要确定具体表
```

**场景2：多态查询（查询所有员工）**
```
查询所有员工

SINGLE_TABLE：
SELECT * FROM employee
性能：★★★★★ 一条SQL搞定

JOINED：
SELECT e.*, f.*, p.*
FROM employee e
LEFT JOIN full_time_emp f ON e.id = f.id
LEFT JOIN part_time_emp p ON e.id = p.id
性能：★★☆☆☆ 多次LEFT JOIN

TABLE_PER_CLASS：
SELECT id, name, salary, insurance, 'FT' as type 
FROM full_time_employee
UNION ALL
SELECT id, name, hourRate, NULL, 'PT' as type 
FROM part_time_employee
性能：★☆☆☆☆ 多个UNION，最慢
```

### 3.2 插入性能对比


| 策略 | SQL数量 | 性能 | 说明 |
|-----|---------|------|------|
| **SINGLE_TABLE** | 1条INSERT | ⭐⭐⭐⭐⭐ | 插入一张表，最快 |
| **JOINED** | 2条INSERT | ⭐⭐⭐☆☆ | 插入父表+子表 |
| **TABLE_PER_CLASS** | 1条INSERT | ⭐⭐⭐⭐☆ | 插入一张表，较快 |

**实际执行示例**：
```java
// 插入一个正式员工

// SINGLE_TABLE：
INSERT INTO employee (id, type, name, salary, insurance) 
VALUES (1, 'FT', '张三', 8000, '五险一金')

// JOINED：
INSERT INTO employee (id, name) VALUES (1, '张三')
INSERT INTO full_time_emp (id, salary, insurance) 
VALUES (1, 8000, '五险一金')

// TABLE_PER_CLASS：
INSERT INTO full_time_employee (id, name, salary, insurance)
VALUES (1, '张三', 8000, '五险一金')
```

### 3.3 更新性能对比


**更新父类属性**（如修改name）：
- `SINGLE_TABLE`：★★★★★ 一条UPDATE
- `JOINED`：★★★★☆ 一条UPDATE（更新父表）
- `TABLE_PER_CLASS`：★☆☆☆☆ 多条UPDATE（更新所有子表）

**更新子类属性**（如修改salary）：
- `SINGLE_TABLE`：★★★★★ 一条UPDATE
- `JOINED`：★★★☆☆ 一条UPDATE（更新子表）
- `TABLE_PER_CLASS`：★★★★☆ 一条UPDATE

---

## 4. 💾 存储空间对比


### 4.1 空间使用分析


**测试数据**：1000个员工（700正式，300兼职）

```
SINGLE_TABLE（单表策略）
employee表：1000行 × 所有字段
┌─────────────────────────────────┐
│ 字段：id, type, name, salary,   │
│       hourRate, insurance       │
│                                 │
│ 空间占用：                       │
│ - 有效数据：合理                 │
│ - NULL值：300行×2字段 = 600个NULL│
│ - 索引：1个主键索引              │
└─────────────────────────────────┘
空间利用率：★★★☆☆（有NULL浪费）

JOINED（联合表策略）
employee表：1000行 × 公共字段
full_time_emp表：700行 × 特有字段
part_time_emp表：300行 × 特有字段
┌─────────────────────────────────┐
│ 空间占用：                       │
│ - 有效数据：最优                 │
│ - NULL值：无                     │
│ - 索引：3个主键 + 2个外键        │
└─────────────────────────────────┘
空间利用率：★★★★★（最优）

TABLE_PER_CLASS（每类一表策略）
full_time_employee：700行 × 所有字段
part_time_employee：300行 × 所有字段
┌─────────────────────────────────┐
│ 空间占用：                       │
│ - 有效数据：合理                 │
│ - 重复数据：name字段重复存储     │
│ - NULL值：无                     │
│ - 索引：2个主键索引              │
└─────────────────────────────────┘
空间利用率：★★★★☆（有字段重复）
```

### 4.2 字段膨胀问题


**单表策略的字段膨胀**：
```
假设有5种员工类型：

员工表字段数 = 公共字段 + Σ各子类特有字段
            = 3 + (5×3) = 18个字段

如果子类数量增加到10种：
            = 3 + (10×3) = 33个字段！

问题：
❌ 表结构臃肿，维护困难
❌ 查询需要扫描大量无用字段
❌ 索引效率降低
```

---

## 5. 🔍 查询复杂度分析


### 5.1 常见查询场景


**场景1：按类型统计**
```sql
-- 统计各类型员工数量

-- SINGLE_TABLE：简单
SELECT type, COUNT(*) FROM employee GROUP BY type

-- JOINED：复杂（需要判断子表）
SELECT 'FT' as type, COUNT(*) FROM full_time_emp
UNION ALL
SELECT 'PT' as type, COUNT(*) FROM part_time_emp

-- TABLE_PER_CLASS：复杂（需要UNION）
SELECT 'FT' as type, COUNT(*) FROM full_time_employee
UNION ALL
SELECT 'PT' as type, COUNT(*) FROM part_time_employee
```

**复杂度**：`SINGLE_TABLE` < `JOINED` < `TABLE_PER_CLASS`

**场景2：条件查询**
```java
// 查询工资大于8000的正式员工

// SINGLE_TABLE：简单直接
SELECT * FROM employee 
WHERE type = 'FT' AND salary > 8000

// JOINED：需要JOIN
SELECT e.*, f.* 
FROM employee e 
JOIN full_time_emp f ON e.id = f.id
WHERE f.salary > 8000

// TABLE_PER_CLASS：简单
SELECT * FROM full_time_employee 
WHERE salary > 8000
```

### 5.2 HQL查询对比


**多态查询**（查询所有员工）：
```java
// HQL：所有策略写法相同
String hql = "FROM Employee";
List<Employee> employees = session.createQuery(hql).list();

// 但生成的SQL大不相同！
// SINGLE_TABLE → 1条简单SQL
// JOINED → 复杂的多表JOIN
// TABLE_PER_CLASS → 多个UNION查询
```

**性能排序**：`SINGLE_TABLE` > `JOINED` > `TABLE_PER_CLASS`

---

## 6. 🎯 策略选择原则


### 6.1 决策流程图


```
开始选择继承策略
        │
        ↓
   [子类数量多吗?]
    /          \
  否(≤3个)      是(>3个)
   │              │
   ↓              ↓
[属性差异大?]   [表结构规范重要?]
 /        \        /          \
否        是       是          否
│          │       │            │
↓          ↓       ↓            ↓
单表策略   联合表   联合表       单表策略
(默认)    策略     策略         (注意字段数)
```

### 6.2 选择建议表


| 场景特征 | 推荐策略 | 理由 |
|---------|---------|------|
| **子类少(≤3个)，属性相似** | `SINGLE_TABLE` | 性能最优，实现简单 |
| **子类多，属性差异大** | `JOINED` | 表结构规范，易维护 |
| **需要频繁多态查询** | `SINGLE_TABLE` | 查询性能最好 |
| **很少多态查询** | `TABLE_PER_CLASS` | 各表独立，灵活 |
| **对性能要求极高** | `SINGLE_TABLE` | 无JOIN，最快 |
| **对数据完整性要求高** | `JOINED` | 支持约束，规范 |
| **表结构可能频繁变化** | `JOINED` | 扩展性最好 |

### 6.3 实战选择案例


**案例1：电商商品分类**
```
商品（Product）
├── 图书（Book）
├── 电子产品（Electronics）
└── 服装（Clothing）

特点：
- 子类3-5个，可能增加
- 属性差异很大（书有ISBN，衣服有尺码）
- 经常查询"所有商品"

推荐：JOINED（联合表）
原因：属性差异大，扩展性好，虽然查询慢但可以优化
```

**案例2：用户账号类型**
```
用户（User）
├── 普通用户（NormalUser）
└── VIP用户（VipUser）

特点：
- 只有2个子类，基本不会增加
- 属性差异小（VIP多几个字段）
- 超高频查询

推荐：SINGLE_TABLE（单表）
原因：子类少，性能最优，NULL值浪费可接受
```

**案例3：支付方式**
```
支付（Payment）
├── 支付宝（Alipay）
├── 微信（Wechat）
├── 银行卡（BankCard）
└── 虚拟货币（Crypto）

特点：
- 子类较多，未来可能更多
- 每种支付方式属性完全不同
- 很少查询"所有支付方式"

推荐：TABLE_PER_CLASS（每类一表）
原因：各表独立，属性不同，少多态查询
```

### 6.4 混合使用策略


**高级技巧**：不同层次用不同策略

```
动物（Animal）- 使用SINGLE_TABLE
├── 哺乳动物（Mammal）
│   ├── 猫（Cat）- 切换为JOINED
│   └── 狗（Dog）
└── 鸟类（Bird）
    ├── 麻雀（Sparrow）
    └── 老鹰（Eagle）
```

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class Animal { ... }

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Mammal extends Animal { ... }
```

---

## 7. 📋 核心要点总结


### 7.1 三策略速记


```
┌─────────────────────────────────────────┐
│           继承策略选择口诀               │
│                                         │
│  子类少且像 → 单表快                     │
│  子类多且杂 → 联合规范                   │
│  各自独立 → 每类一表                     │
│  多态查询频繁 → 单表优先                 │
│  表结构严谨 → 联合优先                   │
└─────────────────────────────────────────┘
```

### 7.2 关键对比记忆


| 对比维度 | SINGLE_TABLE | JOINED | TABLE_PER_CLASS |
|---------|--------------|--------|-----------------|
| **表数量** | 1张 | n+1张 | n张 |
| **查询性能** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐☆☆ | ⭐⭐☆☆☆ |
| **空间效率** | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐☆ |
| **扩展性** | ⭐⭐☆☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐☆☆ |
| **维护难度** | 简单 | 中等 | 复杂 |
| **推荐度** | ⭐⭐⭐⭐☆ | ⭐⭐⭐⭐⭐ | ⭐⭐☆☆☆ |

### 7.3 必记要点


**🔸 SINGLE_TABLE（单表策略）**
- ✅ **优先选择**：性能最好，Hibernate默认
- ⚠️ **注意限制**：子类多了字段会爆炸
- 🎯 **适用**：子类≤5个，属性相似

**🔸 JOINED（联合表策略）**
- ✅ **最规范**：符合数据库设计范式
- ⚠️ **性能代价**：每次查询都JOIN
- 🎯 **适用**：企业级应用，表结构严谨

**🔸 TABLE_PER_CLASS（每类一表）**
- ✅ **独立性好**：各表互不影响
- ⚠️ **很少用**：多态查询太慢
- 🎯 **适用**：几乎不作为整体查询

### 7.4 实战建议


> 💡 **新手建议**：
> 1. 默认使用`SINGLE_TABLE`，简单高效
> 2. 子类超过5个或属性差异大，考虑`JOINED`
> 3. 避免使用`TABLE_PER_CLASS`，除非有特殊需求
> 4. 性能瓶颈时，通过索引、缓存优化，而非频繁换策略

> ⚡ **性能优化提示**：
> - `SINGLE_TABLE`：为type字段建索引
> - `JOINED`：确保外键有索引，考虑二级缓存
> - 多态查询慢：考虑用具体类查询代替

**核心记忆**：
- 继承映射是ORM的核心难点，没有完美策略
- 根据业务特点选择，不要教条主义
- 性能问题先优化查询，再考虑换策略
- 实在不行，可以放弃继承改用组合关系