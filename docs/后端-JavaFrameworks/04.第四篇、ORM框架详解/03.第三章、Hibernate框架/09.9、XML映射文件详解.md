---
title: 9、XML映射文件详解
---
## 📚 目录

1. [什么是映射文件](#1-什么是映射文件)
2. [hbm.xml映射文件基础](#2-hbmxml映射文件基础)
3. [class标签配置详解](#3-class标签配置详解)
4. [property标签使用](#4-property标签使用)
5. [id标签与主键映射](#5-id标签与主键映射)
6. [generator生成器策略](#6-generator生成器策略)
7. [映射策略选择指南](#7-映射策略选择指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 什么是映射文件


### 1.1 映射文件的作用


**通俗理解**：映射文件就像是一个"翻译官"，负责把Java对象和数据库表之间的关系翻译清楚。

```
Java世界              映射文件(翻译官)           数据库世界
┌─────────┐                              ┌─────────────┐
│  User   │          hbm.xml             │ user_table  │
│ ─────── │  ◄─────────────────────►    │ ───────────  │
│ id      │     告诉Hibernate如何转换     │ user_id     │
│ name    │                              │ user_name   │
│ age     │                              │ user_age    │
└─────────┘                              └─────────────┘
```

**核心作用**：
- 🔸 **建立对应关系**：告诉Hibernate哪个类对应哪个表
- 🔸 **字段映射**：说明Java属性对应数据库哪个字段
- 🔸 **类型转换**：规定Java类型如何转换为SQL类型
- 🔸 **主键策略**：定义主键如何生成

### 1.2 为什么需要映射文件


> 💡 **新手疑问**：为什么不能直接存储对象到数据库？

**问题根源**：Java对象和数据库表是两个完全不同的世界

| Java对象 | 数据库表 | 差异说明 |
|---------|---------|---------|
| `String name` | `VARCHAR(50)` | 类型不同，需要转换 |
| `驼峰命名userName` | `下划线命名user_name` | 命名风格不同 |
| `对象引用` | `外键关联` | 关系表达方式不同 |
| `内存存储` | `磁盘存储` | 存储介质不同 |

**映射文件的价值**：
```
没有映射文件：
开发者需要手写SQL → 容易出错 → 维护困难

有了映射文件：
Hibernate自动生成SQL → 减少错误 → 维护简单
```

---

## 2. 📄 hbm.xml映射文件基础


### 2.1 文件命名规范


**标准命名**：`实体类名.hbm.xml`

```
示例规范：
User.java      →  User.hbm.xml
Student.java   →  Student.hbm.xml
Order.java     →  Order.hbm.xml

命名原则：
✅ 见名知意，一看就知道映射哪个类
✅ 放在同一个包下，便于管理
✅ 使用.hbm.xml后缀，Hibernate能自动识别
```

### 2.2 基本文件结构


**完整结构图**：
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping ...>

<hibernate-mapping>              ← 根标签，表示这是映射文件
    
    <class>                       ← 类映射标签
        <id>                      ← 主键映射
            <generator/>          ← 主键生成策略
        </id>
        
        <property/>               ← 普通属性映射
        <property/>
    </class>
    
</hibernate-mapping>
```

**层级关系理解**：
```
hibernate-mapping（最外层）
    └── class（类层）
         ├── id（主键层）
         │    └── generator（策略层）
         └── property（属性层）
```

### 2.3 文件头部配置


```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
```

> 📖 **概念解释**：
> - `<?xml version...?>` - XML文件声明，固定格式
> - `<!DOCTYPE...>` - 文档类型定义，告诉XML解析器这是Hibernate映射文件
> - 这段代码可以直接复制使用，不需要修改

---

## 3. 🏗️ class标签配置详解


### 3.1 class标签的作用


**核心功能**：建立Java类和数据库表的映射关系

```xml
<class name="com.example.User" table="t_user">
    <!-- 映射配置 -->
</class>
```

**图示说明**：
```
Java类                    class标签                  数据库表
┌──────────────┐                               ┌──────────────┐
│ com.example. │         name属性              │              │
│    User      │  ────────────────────►       │   t_user     │
│              │         table属性             │              │
│ 类的全路径    │  ────────────────────►       │   表名        │
└──────────────┘                               └──────────────┘
```

### 3.2 常用属性详解


**name属性** - 指定Java类
```xml
<class name="com.example.User">
```
- 📝 **作用**：告诉Hibernate要映射哪个Java类
- 📝 **值**：类的完全限定名（包名.类名）
- 📝 **必填**：是

**table属性** - 指定数据库表
```xml
<class name="com.example.User" table="t_user">
```
- 📝 **作用**：指定对应的数据库表名
- 📝 **值**：表名（不需要加引号）
- 📝 **可选**：如果不写，默认使用类名作为表名

**catalog属性** - 指定数据库
```xml
<class name="com.example.User" catalog="mydb">
```
- 📝 **作用**：指定数据库名称（多数据库环境使用）
- 📝 **使用场景**：一个系统连接多个数据库时

### 3.3 实际配置示例


```xml
<!-- 基础配置：最常用 -->
<class name="com.example.entity.User" table="user">
    <!-- 后续配置 -->
</class>

<!-- 完整配置：包含可选属性 -->
<class 
    name="com.example.entity.Student" 
    table="t_student"
    catalog="school_db"
    schema="public">
    <!-- 后续配置 -->
</class>
```

> ⚠️ **新手注意**：
> - name属性写类的完整路径，不要只写类名
> - table属性写表名，不是字段名
> - 90%的情况只需要配置name和table就够了

---

## 4. 📝 property标签使用


### 4.1 property标签的作用


**核心功能**：映射Java类的普通属性到数据库字段

```
Java类属性              property标签              数据库字段
┌──────────┐                                ┌──────────────┐
│  name    │         name属性               │              │
│ (String) │  ──────────────────►          │  user_name   │
│          │         column属性             │  (VARCHAR)   │
│          │  ──────────────────►          │              │
└──────────┘         type属性               └──────────────┘
```

### 4.2 基础属性配置


**name属性** - Java属性名
```xml
<property name="username"/>
```
- 🔹 **含义**：Java类中的属性名（变量名）
- 🔹 **规则**：必须和类中的属性名完全一致
- 🔹 **示例**：类中有`private String username;`，这里就写`username`

**column属性** - 数据库字段名
```xml
<property name="username" column="user_name"/>
```
- 🔹 **含义**：对应的数据库字段名
- 🔹 **规则**：和数据库表中的字段名一致
- 🔹 **可选**：不写时默认使用name的值

**type属性** - 数据类型
```xml
<property name="age" type="int"/>
```
- 🔹 **含义**：指定数据类型（Hibernate类型）
- 🔹 **可选**：Hibernate能自动识别大部分类型
- 🔹 **何时使用**：遇到特殊类型或需要明确指定时

### 4.3 类型映射对照表


| Java类型 | Hibernate类型 | 数据库类型(MySQL) | 说明 |
|---------|--------------|-----------------|------|
| `String` | `string` | `VARCHAR` | 字符串 |
| `int/Integer` | `integer` | `INT` | 整数 |
| `long/Long` | `long` | `BIGINT` | 长整数 |
| `double/Double` | `double` | `DOUBLE` | 浮点数 |
| `Date` | `date` | `DATE` | 日期 |
| `Date` | `timestamp` | `DATETIME` | 日期时间 |
| `boolean/Boolean` | `boolean` | `TINYINT(1)` | 布尔值 |

> 💡 **学习提示**：
> - 大部分情况type可以不写，Hibernate会自动匹配
> - String对应VARCHAR，int对应INT，很直观
> - Date类型要注意：date只存日期，timestamp存日期+时间

### 4.4 约束属性配置


**length属性** - 字段长度
```xml
<property name="username" column="user_name" length="50"/>
```
- 🎯 **作用**：限制字符串长度
- 🎯 **影响**：生成表时字段定义为`VARCHAR(50)`

**not-null属性** - 非空约束
```xml
<property name="email" not-null="true"/>
```
- 🎯 **作用**：标记字段不能为空
- 🎯 **值**：`true`或`false`

**unique属性** - 唯一约束
```xml
<property name="email" unique="true"/>
```
- 🎯 **作用**：保证值唯一（如邮箱、手机号）
- 🎯 **效果**：数据库添加唯一索引

### 4.5 完整示例对比


```xml
<!-- 简化写法：让Hibernate自动处理 -->
<property name="username"/>
<property name="age"/>
<property name="email"/>

<!-- 完整写法：明确指定所有配置 -->
<property 
    name="username" 
    column="user_name" 
    type="string"
    length="50"
    not-null="true"/>

<property 
    name="age" 
    column="user_age" 
    type="integer"/>

<property 
    name="email" 
    column="user_email" 
    type="string"
    length="100"
    unique="true"
    not-null="false"/>
```

> ⚠️ **实践建议**：
> - ✅ 初学阶段用简化写法，让Hibernate自动处理
> - ✅ 字段名不一致时才加column属性
> - ✅ 需要约束时才加length、not-null等属性

---

## 5. 🔑 id标签与主键映射


### 5.1 主键的重要性


**为什么需要主键**：
```
数据库表就像一个班级花名册
┌────────────────────────────┐
│ 学号   姓名   年龄   班级    │
│ ────   ────  ────  ────   │
│ 001   张三    18    1班    │  ← 学号是主键，唯一标识
│ 002   李四    19    1班    │
│ 003   张三    18    2班    │  ← 可能重名，但学号不重复
└────────────────────────────┘

主键作用：
✅ 唯一标识每条记录
✅ 建立表之间关联的桥梁
✅ 提高查询效率
```

### 5.2 id标签基础配置


**基本结构**：
```xml
<id name="id" column="user_id" type="int">
    <generator class="native"/>
</id>
```

**标签属性详解**：

**name属性** - Java主键属性名
```xml
<id name="id">
```
- 📌 **含义**：Java类中作为主键的属性名
- 📌 **示例**：类中有`private Integer id;`，这里就写`id`

**column属性** - 数据库主键字段名
```xml
<id name="id" column="user_id">
```
- 📌 **含义**：数据库表中主键字段的名称
- 📌 **可选**：不写时默认使用name的值

**type属性** - 主键数据类型
```xml
<id name="id" type="int">
```
- 📌 **含义**：主键的数据类型
- 📌 **常用类型**：`int`、`long`、`string`

### 5.3 主键类型选择


| 主键类型 | Java类型 | 使用场景 | 优缺点 |
|---------|---------|---------|--------|
| **整数型** | `Integer/Long` | 大部分情况 | ✅ 节省空间 ✅ 查询快 |
| **字符串型** | `String` | UUID场景 | ✅ 全局唯一 ❌ 占空间大 |
| **复合主键** | 自定义类 | 多字段组合 | ❌ 复杂，少用 |

> 💡 **新手建议**：
> - 99%的情况用整数型主键（Integer或Long）
> - 简单、高效、易用
> - 字符串主键一般用UUID，后面会讲

---

## 6. ⚙️ generator生成器策略


### 6.1 生成器的作用


**通俗理解**：generator就是"主键生成器"，告诉Hibernate如何自动生成主键值

```
插入数据流程：
开发者：我要插入一个用户
       ↓
Hibernate：主键是多少？
       ↓
Generator：我来生成！(根据配置的策略)
       ↓
数据库：收到，主键是123
```

### 6.2 常用生成器策略


#### 🔸 increment策略


```xml
<generator class="increment"/>
```

**工作原理**：
```
1. Hibernate查询表中最大主键值：SELECT MAX(id)
2. 在最大值基础上+1
3. 用新值作为主键

示例：
当前最大值：5
新主键：6
再插入：7
```

**适用场景**：
- ✅ 单应用、小项目
- ✅ 学习、测试环境
- ❌ **不适合生产环境**（多个应用并发会重复）

#### 🔸 identity策略


```xml
<generator class="identity"/>
```

**工作原理**：
```
依赖数据库的自增字段（AUTO_INCREMENT）
数据库：我来负责生成主键
Hibernate：好的，我不管了

MySQL示例：
CREATE TABLE user (
    id INT AUTO_INCREMENT PRIMARY KEY,
    ...
);
```

**适用场景**：
- ✅ MySQL、SQL Server等支持自增的数据库
- ✅ 最常用的策略之一
- ❌ Oracle不支持（Oracle没有自增）

#### 🔸 sequence策略


```xml
<generator class="sequence">
    <param name="sequence">user_seq</param>
</generator>
```

**工作原理**：
```
使用数据库序列对象生成主键
Oracle示例：
CREATE SEQUENCE user_seq START WITH 1;

Hibernate：从序列user_seq获取下一个值
数据库：返回1、2、3...
```

**适用场景**：
- ✅ Oracle、PostgreSQL数据库
- ✅ 需要序列对象的数据库
- ❌ MySQL不支持序列

#### 🔸 native策略（推荐）


```xml
<generator class="native"/>
```

**工作原理**：
```
Hibernate根据数据库类型自动选择策略

MySQL     → 自动选择identity
Oracle    → 自动选择sequence  
其他      → 自动选择合适的策略

开发者：我不管用什么数据库
Hibernate：我自己判断，自动适配
```

**适用场景**：
- ✅ **强烈推荐**，适配性最好
- ✅ 数据库可能变更的项目
- ✅ 跨数据库应用

#### 🔸 uuid策略


```xml
<generator class="uuid"/>
```

**工作原理**：
```
生成32位的UUID字符串作为主键
示例值：402880e8-7a2b-4c5f-9f3a-1234567890ab

特点：
✅ 全局唯一，不会重复
✅ 分布式系统友好
❌ 字符串型，占空间大
```

**适用场景**：
- ✅ 分布式系统
- ✅ 需要全局唯一ID
- ✅ 数据合并场景

#### 🔸 assigned策略


```xml
<generator class="assigned"/>
```

**工作原理**：
```
开发者手动赋值主键
Hibernate：主键你自己给，我不管

User user = new User();
user.setId(100);  // 手动设置
session.save(user);
```

**适用场景**：
- ✅ 主键有业务含义（如学号、工号）
- ✅ 需要自定义主键生成规则
- ❌ 一般不推荐，容易冲突

### 6.3 生成器选择指南


```
选择决策树：
                开始
                 │
         需要字符串主键？
         ├── 是 → uuid策略
         │
         └── 否 → 需要自己控制主键？
                 ├── 是 → assigned策略
                 │
                 └── 否 → 不确定数据库类型？
                         ├── 是 → native策略 ⭐推荐
                         │
                         └── 否 → 明确MySQL → identity策略
                                 明确Oracle → sequence策略
```

**推荐配置**：
```xml
<!-- 最通用的配置，99%场景适用 -->
<id name="id" column="id" type="int">
    <generator class="native"/>
</id>

<!-- 分布式场景 -->
<id name="id" column="id" type="string">
    <generator class="uuid"/>
</id>
```

---

## 7. 🎯 映射策略选择指南


### 7.1 映射方式对比


**XML映射 vs 注解映射**：

```
XML映射（本节内容）              注解映射（现代方式）
┌──────────────┐                ┌──────────────┐
│ User.hbm.xml │                │  @Entity     │
│              │                │  @Table      │
│ <class>      │                │  public      │
│   <id/>      │                │  class User  │
│   <property/>│                │              │
│ </class>     │                │              │
└──────────────┘                └──────────────┘

优点：                          优点：
✅ 配置集中，便于统一管理          ✅ 代码和配置在一起
✅ 不侵入Java代码                ✅ 简洁直观
✅ 适合复杂映射                  ✅ 开发效率高

缺点：                          缺点：
❌ 配置文件多，维护麻烦           ❌ 配置分散
❌ 开发效率相对低                ❌ 复杂映射不太方便
```

### 7.2 实际项目建议


**选择依据**：

| 项目特点 | 推荐方式 | 理由 |
|---------|---------|------|
| **新项目** | 注解映射 | 开发快，主流趋势 |
| **老项目** | XML映射 | 已有配置，保持一致 |
| **复杂关联** | XML映射 | 配置灵活，便于调整 |
| **快速开发** | 注解映射 | 减少配置文件 |

> 💡 **学习路径建议**：
> 1. 先学XML映射，理解映射原理
> 2. 再学注解映射，提高开发效率
> 3. 实际项目中两者可以混用

### 7.3 完整映射文件示例


**User.hbm.xml完整示例**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
    
    <!-- 类和表的映射 -->
    <class name="com.example.entity.User" table="t_user">
        
        <!-- 主键映射 -->
        <id name="id" column="user_id" type="int">
            <generator class="native"/>
        </id>
        
        <!-- 普通属性映射 -->
        <property name="username" column="user_name" 
                  type="string" length="50" not-null="true"/>
        
        <property name="password" column="user_pwd" 
                  type="string" length="100" not-null="true"/>
        
        <property name="email" column="user_email" 
                  type="string" length="100" unique="true"/>
        
        <property name="age" column="user_age" type="integer"/>
        
        <property name="createTime" column="create_time" 
                  type="timestamp"/>
        
    </class>
    
</hibernate-mapping>
```

**对应的数据库表**：
```sql
CREATE TABLE t_user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(50) NOT NULL,
    user_pwd VARCHAR(100) NOT NULL,
    user_email VARCHAR(100) UNIQUE,
    user_age INT,
    create_time DATETIME
);
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 映射文件：Java类与数据库表的桥梁
🔸 class标签：建立类和表的映射关系
🔸 property标签：映射普通属性到字段
🔸 id标签：映射主键
🔸 generator：主键生成策略
```

### 8.2 关键配置速查


**最小化配置（初学推荐）**：
```xml
<hibernate-mapping>
    <class name="类的全路径" table="表名">
        <id name="主键属性名">
            <generator class="native"/>
        </id>
        <property name="属性名"/>
        <property name="属性名"/>
    </class>
</hibernate-mapping>
```

**完整配置（生产环境）**：
```xml
<hibernate-mapping>
    <class name="类的全路径" table="表名">
        <id name="主键属性名" column="主键字段名" type="类型">
            <generator class="策略"/>
        </id>
        <property name="属性名" column="字段名" 
                  type="类型" length="长度" 
                  not-null="true/false"/>
    </class>
</hibernate-mapping>
```

### 8.3 常见错误与解决


**错误1：找不到映射文件**
```
原因：文件名不正确或位置不对
解决：确保User.hbm.xml和User.java在同一包下
```

**错误2：主键重复**
```
原因：generator策略选择不当
解决：多应用环境不用increment，改用native或uuid
```

**错误3：字段映射失败**
```
原因：property的name属性写错
解决：name必须和Java类属性名完全一致（区分大小写）
```

### 8.4 学习检查清单


- [ ] 理解映射文件的作用和位置
- [ ] 掌握class标签的基本配置
- [ ] 能够配置property映射普通属性
- [ ] 理解id标签配置主键
- [ ] 熟悉常用的generator策略
- [ ] 能够根据需求选择合适的策略
- [ ] 可以编写完整的映射文件

### 8.5 下一步学习


学完XML映射文件后，建议继续学习：
1. **关联映射**：一对多、多对一、多对多关系
2. **注解映射**：现代化的配置方式
3. **高级映射**：继承映射、组件映射等

**核心记忆口诀**：
```
映射文件搭桥梁，类表对应说得清
class建立总关系，id主键要配好
property属性映射，generator生成策略
native最通用，uuid分布式首选
```