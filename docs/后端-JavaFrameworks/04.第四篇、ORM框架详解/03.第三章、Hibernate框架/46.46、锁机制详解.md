---
title: 46、锁机制详解
---
## 📚 目录

1. [锁机制基础概念](#1-锁机制基础概念)
2. [悲观锁实现](#2-悲观锁实现)
3. [乐观锁实现](#3-乐观锁实现)
4. [版本控制机制](#4-版本控制机制)
5. [时间戳锁](#5-时间戳锁)
6. [LockMode锁模式](#6-LockMode锁模式)
7. [显式锁定操作](#7-显式锁定操作)
8. [锁升级机制](#8-锁升级机制)
9. [死锁问题处理](#9-死锁问题处理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔐 锁机制基础概念


### 1.1 为什么需要锁机制


**生活场景类比**：
```
想象一个银行取款场景：
👤 小明查询余额：1000元
👤 小红也查询余额：1000元
👤 小明取款500元 → 余额应该是500元
👤 小红取款300元 → 余额应该是200元

问题来了：
如果两人同时操作，最后余额可能是：
❌ 700元（小明的操作被覆盖）
❌ 500元（小红的操作被覆盖）
✅ 200元（正确结果）

这就需要"锁"来保证数据一致性！
```

### 1.2 锁的核心概念


**什么是锁**：
- **通俗解释**：就像房间的门锁，谁拿到钥匙谁就能进去操作数据
- **专业定义**：一种并发控制机制，防止多个事务同时修改同一数据造成冲突

**锁的两大类型**：

| 锁类型 | **通俗理解** | **适用场景** | **性能** | **安全性** |
|--------|------------|------------|---------|-----------|
| 🔒 **悲观锁** | `先锁门再操作，确保安全` | `冲突频繁的场景` | `较低` | `很高` |
| 🔓 **乐观锁** | `先操作后检查，发现冲突再处理` | `冲突较少的场景` | `较高` | `中等` |

### 1.3 锁机制工作流程


**悲观锁流程**：
```
用户A                          数据库
  |                              |
  |--[1]请求锁定数据------------>|
  |                              |🔒上锁
  |<--[2]返回锁定成功------------|
  |                              |
  |--[3]读取数据--------------->|
  |<--[4]返回数据---------------|
  |                              |
  |--[5]修改并提交------------->|
  |                              |🔓解锁
  |<--[6]提交成功---------------|
```

**乐观锁流程**：
```
用户A                          数据库
  |                              |
  |--[1]读取数据(版本号=1)----->|
  |<--[2]返回数据---------------|
  |                              |
  |--[3]修改数据--------------->|
  |                              |
  |--[4]提交(检查版本号)------->|
  |                              |
  |<--[5]版本匹配,提交成功------|
  |     (版本号更新为2)          |
```

---

## 2. 🔒 悲观锁实现


### 2.1 悲观锁的核心思想


**通俗理解**：
```
就像去银行办业务：
1️⃣ 排队取号（获取锁）
2️⃣ 叫到号才能办理（持有锁）
3️⃣ 办理过程中别人不能插队（其他人等待）
4️⃣ 办完业务离开（释放锁）

核心理念：宁可等待，也要确保数据安全！
```

### 2.2 Hibernate中的悲观锁使用


**基本用法示例**：

```java
// 实体类
@Entity
public class Account {
    @Id
    private Long id;
    private String owner;
    private BigDecimal balance;
    // getter/setter省略
}

// 悲观锁查询
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

try {
    // 🔒 使用悲观锁查询账户
    Account account = session.get(
        Account.class, 
        1L,
        LockMode.PESSIMISTIC_WRITE  // 悲观写锁
    );
    
    // 现在这条数据被锁定，其他事务无法修改
    account.setBalance(account.getBalance().subtract(new BigDecimal("100")));
    
    tx.commit();  // 提交时释放锁
} catch (Exception e) {
    tx.rollback();
}
```

### 2.3 悲观锁的SQL实现原理


**Hibernate生成的SQL**：
```sql
-- Hibernate在底层会生成这样的SQL
SELECT * FROM account 
WHERE id = 1 
FOR UPDATE;  -- 关键：FOR UPDATE子句锁定行

-- 解释：
-- FOR UPDATE: 数据库层面的行级锁
-- 其他事务查询这行会等待，直到锁释放
```

**锁定范围对比**：

```
场景1：精确锁定（最常用）
SELECT * FROM account WHERE id = 1 FOR UPDATE;
结果：只锁定id=1这一行 ✅

场景2：范围锁定（需谨慎）
SELECT * FROM account WHERE balance > 1000 FOR UPDATE;
结果：锁定所有余额>1000的行 ⚠️

场景3：全表锁定（极少使用）
SELECT * FROM account FOR UPDATE;
结果：锁定整个表 ❌性能差
```

### 2.4 悲观锁的优缺点


**✅ 优点**：
- 数据一致性强：完全避免并发修改冲突
- 逻辑简单：锁住就能改，不用担心冲突
- 适合高冲突场景：如秒杀、库存扣减

**❌ 缺点**：
- 性能开销大：其他事务需要等待
- 可能死锁：两个事务互相等待对方的锁
- 吞吐量低：同一时间只有一个事务能操作数据

**使用建议**：
```
✅ 适合使用悲观锁的场景：
- 库存扣减（电商下单）
- 账户余额修改（转账）
- 秒杀活动
- 数据修改冲突很频繁的情况

❌ 不适合使用悲观锁的场景：
- 读多写少的系统
- 冲突很少发生
- 对性能要求很高的场景
```

---

## 3. 🔓 乐观锁实现


### 3.1 乐观锁的核心思想


**通俗理解**：
```
就像在线文档编辑：
1️⃣ 小明打开文档（版本1）开始编辑
2️⃣ 小红也打开文档（版本1）开始编辑
3️⃣ 小明先保存，文档变成版本2 ✅
4️⃣ 小红保存时发现版本冲突 ⚠️
5️⃣ 系统提示小红：文档已被修改，请重新编辑

核心理念：大部分情况不会冲突，冲突时再处理！
```

### 3.2 乐观锁的实现机制


**版本号机制**：

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private Integer stock;  // 库存
    
    @Version  // 🔑 关键：版本号字段
    private Integer version;
    
    // getter/setter省略
}
```

**工作流程演示**：

```java
// 用户A的操作
Session sessionA = sessionFactory.openSession();
Transaction txA = sessionA.beginTransaction();

// 查询商品（此时version=1）
Product productA = sessionA.get(Product.class, 1L);
System.out.println("用户A读取：库存=" + productA.getStock() + ", 版本=" + productA.getVersion());

// 用户B的操作（在A之前提交）
Session sessionB = sessionFactory.openSession();
Transaction txB = sessionB.beginTransaction();

Product productB = sessionB.get(Product.class, 1L);
productB.setStock(productB.getStock() - 1);  // 库存减1
txB.commit();  // ✅ B先提交成功，版本变为2

// 用户A继续操作
productA.setStock(productA.getStock() - 1);
try {
    txA.commit();  // ❌ 提交失败！版本号不匹配
} catch (OptimisticLockException e) {
    System.out.println("数据已被修改，请重新操作");
    txA.rollback();
}
```

### 3.3 乐观锁的SQL实现


**Hibernate生成的UPDATE语句**：

```sql
-- 查询时（version=1）
SELECT id, name, stock, version 
FROM product WHERE id = 1;

-- 更新时（关键：WHERE条件包含版本号）
UPDATE product 
SET stock = stock - 1,
    version = version + 1  -- 版本号自增
WHERE id = 1 
  AND version = 1;  -- 🔑 必须版本号匹配才能更新

-- 如果version已经变成2，这个UPDATE影响行数=0
-- Hibernate检测到影响行数=0，抛出OptimisticLockException
```

### 3.4 乐观锁冲突处理策略


**策略1：提示用户重新操作**
```java
@Transactional
public void updateProduct(Long id, Integer quantity) {
    try {
        Product product = session.get(Product.class, id);
        product.setStock(product.getStock() - quantity);
        session.update(product);
    } catch (OptimisticLockException e) {
        // 提示用户：数据已被修改，请刷新后重试
        throw new BusinessException("商品信息已更新，请重新操作");
    }
}
```

**策略2：自动重试机制**
```java
public void updateWithRetry(Long id, Integer quantity) {
    int maxRetries = 3;  // 最多重试3次
    int attempt = 0;
    
    while (attempt < maxRetries) {
        try {
            Session session = sessionFactory.openSession();
            Transaction tx = session.beginTransaction();
            
            Product product = session.get(Product.class, id);
            product.setStock(product.getStock() - quantity);
            session.update(product);
            
            tx.commit();
            return;  // ✅ 成功则返回
            
        } catch (OptimisticLockException e) {
            attempt++;
            if (attempt >= maxRetries) {
                throw new BusinessException("操作失败，请稍后重试");
            }
            // 等待一小段时间后重试
            Thread.sleep(50 * attempt);
        }
    }
}
```

### 3.5 乐观锁的优缺点


**✅ 优点**：
- 性能好：不需要加数据库锁，不阻塞其他事务
- 吞吐量高：多个事务可以同时读取数据
- 无死锁风险：不涉及锁等待

**❌ 缺点**：
- 冲突时需要重试：用户体验可能受影响
- 不适合高冲突场景：频繁冲突导致大量重试
- 需要额外字段：version或timestamp字段占用空间

**对比总结**：

| 对比维度 | **悲观锁** | **乐观锁** |
|---------|-----------|-----------|
| 🔑 **核心思想** | `先锁定后操作` | `先操作后检查` |
| ⚡ **性能** | `较低（有锁等待）` | `较高（无锁等待）` |
| 🎯 **适用场景** | `高冲突（秒杀、库存）` | `低冲突（普通业务）` |
| 🔄 **重试机制** | `不需要` | `需要处理冲突` |
| 💾 **额外字段** | `不需要` | `需要version字段` |
| 🚫 **死锁风险** | `可能` | `不会` |

---

## 4. 📋 版本控制机制


### 4.1 @Version注解详解


**基本用法**：

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String orderNo;
    private BigDecimal amount;
    
    @Version  // 版本控制字段
    private Integer version;
    
    // 或者使用Long类型
    // @Version
    // private Long version;
}
```

**版本号的自动维护**：

```
初始状态：
订单创建时 → version = 0 (Hibernate自动设置)

第1次修改：
UPDATE ... SET amount = 1000, version = 1 WHERE id = 1 AND version = 0

第2次修改：
UPDATE ... SET amount = 1200, version = 2 WHERE id = 1 AND version = 1

第3次修改：
UPDATE ... SET amount = 1500, version = 3 WHERE id = 1 AND version = 2

每次更新都会：
✅ 检查版本号是否匹配
✅ 自动递增版本号
❌ 版本不匹配则抛出OptimisticLockException
```

### 4.2 版本号字段类型选择


**支持的类型**：

```java
// 方式1：Integer类型（最常用）
@Version
private Integer version;  // 范围：-2^31 到 2^31-1

// 方式2：Long类型（数据量大时）
@Version
private Long version;  // 范围更大

// 方式3：Short类型（节省空间）
@Version
private Short version;  // 范围小，但通常够用

// ❌ 不支持的类型
// @Version
// private String version;  // 错误！字符串不支持
```

**类型选择建议**：

```
✅ Integer（推荐）
- 适用于绝大多数场景
- 最多支持21亿次修改
- 性能和空间平衡

✅ Long（超大数据量）
- 海量修改的核心数据
- 如：高频交易系统

✅ Short（节省空间）
- 修改次数不多的数据
- 最多支持3万次修改
```

### 4.3 版本号的初始值处理


**自动初始化**：

```java
@Entity
public class Article {
    @Id
    private Long id;
    
    @Version
    @Column(nullable = false)
    private Integer version = 0;  // 可以设置初始值
    
    // Hibernate会自动处理：
    // 插入时：version = 0
    // 首次更新：version = 1
}
```

**手动管理（不推荐）**：

```java
// ❌ 错误做法：手动修改版本号
article.setVersion(article.getVersion() + 1);  
// Hibernate会再次+1，导致版本号错乱

// ✅ 正确做法：让Hibernate自动管理
// 不要手动调用setVersion()
```

### 4.4 版本控制的注意事项


⚠️ **重要提醒**：

```
1. 版本字段只能有一个
   ❌ 一个实体不能有多个@Version字段

2. 不要手动修改版本号
   ❌ setVersion() 会导致版本号混乱
   ✅ 完全交给Hibernate管理

3. 版本号不能为null
   ❌ 版本号为null会导致更新失败
   ✅ 使用@Column(nullable = false)

4. 删除操作不检查版本
   ❌ DELETE操作不会检查version
   ✅ 需要删除前先查询（附带版本检查）

5. 批量更新不生效
   ❌ HQL/SQL批量更新不会检查版本
   ✅ 需要逐条更新或使用其他机制
```

**最佳实践**：

```java
// ✅ 推荐做法
@Entity
public class Document {
    @Id
    private Long id;
    
    @Version
    @Column(nullable = false)  // 不允许为空
    private Integer version = 0;  // 初始值0
    
    private String content;
    
    // 只提供getter，不提供setter
    public Integer getVersion() {
        return version;
    }
    // 不提供setVersion()，防止误用
}
```

---

## 5. ⏰ 时间戳锁


### 5.1 时间戳锁的概念


**通俗理解**：
```
就像文件的"最后修改时间"：
📝 创建文件 → 修改时间：2025-01-01 10:00:00
📝 第1次修改 → 修改时间：2025-01-01 11:00:00
📝 第2次修改 → 修改时间：2025-01-01 12:00:00

更新时检查：
如果修改时间不是你看到的那个时间 = 有人先改过了！
```

### 5.2 时间戳锁的实现


**基本用法**：

```java
@Entity
public class Article {
    @Id
    private Long id;
    
    private String title;
    private String content;
    
    @Version  // 使用时间戳作为版本
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModified;
    
    // Hibernate会自动维护这个时间戳
}
```

**工作原理**：

```sql
-- 查询时记录时间戳
SELECT id, title, content, last_modified 
FROM article WHERE id = 1;
-- 结果：last_modified = '2025-01-01 10:00:00'

-- 更新时检查时间戳
UPDATE article 
SET title = '新标题',
    content = '新内容',
    last_modified = CURRENT_TIMESTAMP  -- 更新为当前时间
WHERE id = 1 
  AND last_modified = '2025-01-01 10:00:00';  -- 🔑 检查时间戳

-- 如果时间戳不匹配 → 影响行数=0 → 抛出异常
```

### 5.3 时间戳 vs 版本号


**对比分析**：

| 特性 | **版本号（Integer）** | **时间戳（Timestamp）** |
|------|---------------------|----------------------|
| 📊 **数据类型** | `整数（0,1,2...）` | `日期时间` |
| 🎯 **业务意义** | `纯版本控制` | `记录最后修改时间` |
| 🔍 **可读性** | `版本序号清晰` | `能看到修改时间` |
| ⚙️ **精度问题** | `无精度问题` | `可能有毫秒精度问题` |
| 💾 **存储空间** | `4字节（Integer）` | `8字节（Timestamp）` |
| 📝 **推荐度** | `✅ 推荐` | `⚠️ 特定场景使用` |

**精度问题说明**：

```
时间戳精度问题：
有些数据库的时间戳精度是秒级：
- 10:00:00.123 → 存储为 10:00:00
- 10:00:00.456 → 存储为 10:00:00
- 两个不同的时间变成了相同的值！

版本号没有这个问题：
- 版本1 → 版本2 → 版本3
- 永远递增，不会重复
```

**使用建议**：

```
✅ 使用版本号的场景（推荐）：
- 纯粹的并发控制
- 不需要记录修改时间
- 追求最高可靠性

✅ 使用时间戳的场景：
- 需要同时记录最后修改时间
- 业务上需要知道何时被修改
- 数据库支持高精度时间戳

⚠️ 注意事项：
- 时间戳精度依赖数据库
- 建议优先使用版本号
- 如需修改时间，可额外加字段
```

---

## 6. 🔐 LockMode锁模式


### 6.1 LockMode概述


**什么是LockMode**：
- **通俗解释**：锁的强度级别，就像门锁有普通锁、防盗锁、保险柜锁
- **专业定义**：Hibernate提供的锁定强度枚举，控制数据的访问和修改权限

### 6.2 LockMode类型详解


**核心锁模式**：

```
锁强度从弱到强：
📖 READ          → 可以读，别人也能读写
📝 WRITE         → 写入时自动获取
🔒 PESSIMISTIC_READ  → 悲观读锁，防止修改
🔐 PESSIMISTIC_WRITE → 悲观写锁，独占访问
⚡ PESSIMISTIC_FORCE_INCREMENT → 强制版本号递增
🚫 NONE          → 不加锁
```

### 6.3 各种LockMode详细说明


#### 🔸 NONE - 不加锁


```java
// 普通查询，不加任何锁
Session session = sessionFactory.openSession();
Account account = session.get(Account.class, 1L);
// 其他事务可以随意读写这条数据
```

#### 🔸 PESSIMISTIC_READ - 悲观读锁


```java
// 加悲观读锁
Account account = session.get(
    Account.class, 
    1L,
    LockMode.PESSIMISTIC_READ
);

// 生成SQL（不同数据库实现不同）
// MySQL: SELECT ... LOCK IN SHARE MODE
// PostgreSQL: SELECT ... FOR SHARE
```

**特点说明**：
```
✅ 允许：其他事务可以读取
❌ 禁止：其他事务不能修改（会等待）
🎯 用途：确保读取的数据在事务期间不被修改
```

#### 🔸 PESSIMISTIC_WRITE - 悲观写锁（最常用）


```java
// 加悲观写锁
Account account = session.get(
    Account.class, 
    1L,
    LockMode.PESSIMISTIC_WRITE
);

// 生成SQL
// SELECT ... FOR UPDATE
```

**特点说明**：
```
✅ 允许：当前事务独占访问
❌ 禁止：其他事务读写都要等待
🎯 用途：需要修改数据时使用，完全独占
```

#### 🔸 PESSIMISTIC_FORCE_INCREMENT - 强制递增


```java
// 强制递增版本号
Account account = session.get(
    Account.class, 
    1L,
    LockMode.PESSIMISTIC_FORCE_INCREMENT
);

// 即使不修改数据，版本号也会+1
```

**特点说明**：
```
特殊能力：结合了悲观锁和乐观锁
- 使用悲观锁锁定数据
- 同时强制递增版本号
- 即使没有修改，版本号也会+1

使用场景：
- 关联关系修改（如订单的商品项）
- 需要标记数据被访问过
```

#### 🔸 OPTIMISTIC - 乐观锁


```java
// 使用乐观锁（需要@Version字段）
Account account = session.get(
    Account.class, 
    1L,
    LockMode.OPTIMISTIC
);

// 不会生成FOR UPDATE
// 只在提交时检查版本号
```

#### 🔸 OPTIMISTIC_FORCE_INCREMENT - 乐观强制递增


```java
Account account = session.get(
    Account.class, 
    1L,
    LockMode.OPTIMISTIC_FORCE_INCREMENT
);

// 即使不修改数据，提交时版本号也会+1
```

### 6.4 LockMode使用示例


**示例1：库存扣减（悲观写锁）**

```java
@Transactional
public void deductStock(Long productId, Integer quantity) {
    Session session = sessionFactory.getCurrentSession();
    
    // 🔐 使用悲观写锁查询商品
    Product product = session.get(
        Product.class, 
        productId,
        LockMode.PESSIMISTIC_WRITE
    );
    
    // 检查库存
    if (product.getStock() < quantity) {
        throw new BusinessException("库存不足");
    }
    
    // 扣减库存
    product.setStock(product.getStock() - quantity);
    
    // 提交时释放锁
}
```

**示例2：订单修改（乐观锁）**

```java
@Transactional
public void updateOrder(Long orderId, OrderDTO dto) {
    Session session = sessionFactory.getCurrentSession();
    
    // 📝 使用乐观锁
    Order order = session.get(
        Order.class, 
        orderId,
        LockMode.OPTIMISTIC
    );
    
    // 修改订单信息
    order.setStatus(dto.getStatus());
    order.setRemark(dto.getRemark());
    
    // 提交时检查版本号
}
```

### 6.5 LockMode选择指南


**决策树**：

```
需要修改数据？
├─ 是 → 冲突频繁？
│   ├─ 是 → PESSIMISTIC_WRITE（悲观写锁）
│   └─ 否 → OPTIMISTIC（乐观锁）
│
└─ 否 → 需要防止数据被修改？
    ├─ 是 → PESSIMISTIC_READ（悲观读锁）
    └─ 否 → NONE（不加锁）
```

**场景对照表**：

| 业务场景 | **推荐LockMode** | **原因** |
|---------|----------------|---------|
| 💰 **库存扣减** | `PESSIMISTIC_WRITE` | `高冲突，需独占` |
| 🎫 **秒杀抢购** | `PESSIMISTIC_WRITE` | `高并发，防超卖` |
| 📝 **订单修改** | `OPTIMISTIC` | `冲突少，性能好` |
| 👤 **用户信息修改** | `OPTIMISTIC` | `一般不冲突` |
| 📊 **报表查询** | `NONE或READ` | `只读数据` |
| 🔗 **关联关系修改** | `OPTIMISTIC_FORCE_INCREMENT` | `需要标记版本变化` |

---

## 7. 🎯 显式锁定操作


### 7.1 什么是显式锁定


**通俗理解**：
```
隐式锁定：Hibernate自动加锁
- session.get(Entity.class, id, LockMode.XX)
- 加载对象时就加锁

显式锁定：手动控制锁定时机
- 先查询对象（不加锁）
- 需要时再手动加锁
- 更灵活的控制
```

### 7.2 显式锁定的使用方法


**方式1：buildLockRequest**

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// 先正常查询（不加锁）
Account account = session.get(Account.class, 1L);

// 执行一些业务逻辑...
if (needToUpdate(account)) {
    // 需要修改时，显式加锁
    session.buildLockRequest(LockOptions.UPGRADE)
           .lock(account);
    
    // 现在数据已被锁定，可以安全修改
    account.setBalance(account.getBalance().subtract(new BigDecimal("100")));
}

tx.commit();
```

**方式2：直接使用lock方法**

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// 查询对象
Product product = session.get(Product.class, 1L);

// 需要时加锁
session.lock(product, LockMode.PESSIMISTIC_WRITE);

// 修改数据
product.setPrice(new BigDecimal("99.99"));

tx.commit();
```

### 7.3 LockOptions详解


**LockOptions提供更精细的锁控制**：

```java
LockOptions lockOptions = new LockOptions()
    .setLockMode(LockMode.PESSIMISTIC_WRITE)  // 锁模式
    .setTimeOut(5000)  // 超时时间（毫秒）
    .setScope(true);   // 是否级联锁定关联对象

session.buildLockRequest(lockOptions).lock(account);
```

**超时控制示例**：

```java
try {
    // 设置5秒超时
    LockOptions options = new LockOptions(LockMode.PESSIMISTIC_WRITE)
        .setTimeOut(5000);  // 等待5秒获取锁
    
    session.buildLockRequest(options).lock(account);
    
    // 获取锁成功，执行业务逻辑
    account.setBalance(newBalance);
    
} catch (PessimisticLockException e) {
    // 超时未获取到锁
    throw new BusinessException("系统繁忙，请稍后重试");
}
```

### 7.4 显式锁定的应用场景


**场景1：条件锁定**

```java
public void processOrder(Long orderId) {
    Session session = sessionFactory.getCurrentSession();
    
    // 先查询订单
    Order order = session.get(Order.class, orderId);
    
    // 根据订单状态决定是否加锁
    if (order.getStatus() == OrderStatus.PENDING) {
        // 待处理订单才加锁
        session.lock(order, LockMode.PESSIMISTIC_WRITE);
        
        // 处理订单...
        order.setStatus(OrderStatus.PROCESSING);
    }
}
```

**场景2：延迟锁定**

```java
public void updateUserBalance(Long userId, BigDecimal amount) {
    Session session = sessionFactory.getCurrentSession();
    
    // 1. 先查询用户（不加锁）
    User user = session.get(User.class, userId);
    
    // 2. 执行业务检查
    if (!validateUser(user)) {
        throw new BusinessException("用户状态异常");
    }
    
    // 3. 通过检查后再加锁
    session.lock(user, LockMode.PESSIMISTIC_WRITE);
    
    // 4. 修改余额
    user.setBalance(user.getBalance().add(amount));
}
```

**场景3：读锁升级为写锁**

```java
public void checkAndUpdate(Long productId) {
    Session session = sessionFactory.getCurrentSession();
    
    // 1. 先用读锁查询
    Product product = session.get(
        Product.class, 
        productId,
        LockMode.PESSIMISTIC_READ
    );
    
    // 2. 检查是否需要修改
    if (product.getStock() < 10) {
        // 3. 升级为写锁
        session.lock(product, LockMode.PESSIMISTIC_WRITE);
        
        // 4. 修改数据
        product.setStock(100);  // 补货
    }
}
```

### 7.5 显式锁定 vs 隐式锁定


**对比说明**：

```java
// 隐式锁定（查询时就加锁）
Account account1 = session.get(
    Account.class, 
    1L,
    LockMode.PESSIMISTIC_WRITE  // 立即加锁
);

// 显式锁定（需要时再加锁）
Account account2 = session.get(Account.class, 1L);  // 不加锁
// ... 执行其他逻辑
session.lock(account2, LockMode.PESSIMISTIC_WRITE);  // 后续加锁
```

**选择建议**：

| 场景 | **推荐方式** | **原因** |
|------|------------|---------|
| 🔒 **确定要修改** | `隐式锁定` | `直接加锁，简单高效` |
| 🤔 **可能要修改** | `显式锁定` | `先检查后加锁，避免不必要的锁` |
| 📊 **只读为主** | `显式锁定` | `大部分不加锁，性能更好` |
| ⚡ **高并发场景** | `隐式锁定` | `尽早加锁，减少冲突` |

---

## 8. 🔄 锁升级机制


### 8.1 什么是锁升级


**通俗理解**：
```
就像门禁系统的升级：
🚪 普通门锁（读锁） → 可以多人同时进入
🔐 防盗门锁（写锁） → 只能一人独占进入

锁升级：
从允许多人读取 → 升级为独占访问
```

### 8.2 锁升级的触发条件


**自动升级场景**：

```java
Session session = sessionFactory.getCurrentSession();

// 1. 先用读锁查询
Account account = session.get(
    Account.class, 
    1L,
    LockMode.PESSIMISTIC_READ  // 读锁
);

// 2. 修改数据时，Hibernate可能自动升级为写锁
account.setBalance(newBalance);

// 具体是否升级取决于：
// - 数据库支持
// - Hibernate配置
// - 锁的当前状态
```

**手动升级示例**：

```java
Session session = sessionFactory.getCurrentSession();

// 1. 初始使用读锁
Product product = session.get(
    Product.class, 
    1L,
    LockMode.PESSIMISTIC_READ
);

// 2. 检查库存
if (product.getStock() < threshold) {
    // 3. 手动升级为写锁
    session.buildLockRequest(
        new LockOptions(LockMode.PESSIMISTIC_WRITE)
    ).lock(product);
    
    // 4. 现在可以安全修改
    product.setStock(newStock);
}
```

### 8.3 锁升级的数据库实现


**MySQL的锁升级**：

```sql
-- 读锁（共享锁）
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE;

-- 升级为写锁（排他锁）需要：
-- 1. 释放读锁
-- 2. 重新获取写锁
SELECT * FROM account WHERE id = 1 FOR UPDATE;
```

**问题**：
```
⚠️ 锁升级可能导致死锁

场景：
事务A：持有行1的读锁，想升级为写锁
事务B：也持有行1的读锁，也想升级为写锁

结果：
两个事务互相等待对方释放读锁
→ 死锁！
```

### 8.4 避免锁升级问题的策略


**策略1：直接使用写锁**

```java
// ✅ 如果确定要修改，直接用写锁
Account account = session.get(
    Account.class, 
    1L,
    LockMode.PESSIMISTIC_WRITE  // 直接写锁，避免升级
);
```

**策略2：使用乐观锁**

```java
// ✅ 低冲突场景用乐观锁
@Entity
public class Account {
    @Version
    private Integer version;
    // ...
}

// 不需要锁升级，用版本号检查
Account account = session.get(Account.class, 1L);
account.setBalance(newBalance);
// 提交时检查版本号
```

**策略3：分离读写操作**

```java
// ✅ 读写分离，避免升级
// 第一步：只读查询（不加锁）
Account account = session.get(Account.class, 1L);
BigDecimal currentBalance = account.getBalance();

// 执行业务计算...
BigDecimal newBalance = calculate(currentBalance);

// 第二步：重新获取写锁并更新
Account accountForUpdate = session.get(
    Account.class, 
    1L,
    LockMode.PESSIMISTIC_WRITE
);
accountForUpdate.setBalance(newBalance);
```

### 8.5 锁降级


**概念说明**：
```
锁降级：从写锁降为读锁
⚠️ 注意：Hibernate/JPA不直接支持锁降级

原因：
- 大多数数据库不支持直接降级
- 锁在事务结束时统一释放
- 降级会增加复杂性，很少需要
```

**变通方案**：

```java
// 如果需要"降级"效果
// 方案：分两个事务

// 事务1：写操作（写锁）
@Transactional
public void updateData(Long id) {
    Account account = session.get(
        Account.class, id, 
        LockMode.PESSIMISTIC_WRITE
    );
    account.setBalance(newBalance);
    // 事务结束，锁释放
}

// 事务2：读操作（读锁或不加锁）
@Transactional(readOnly = true)
public Account readData(Long id) {
    return session.get(Account.class, id);
    // 不加写锁，相当于"降级"
}
```

---

## 9. ⚠️ 死锁问题处理


### 9.1 什么是死锁


**生活场景类比**：
```
两个人过独木桥：
👤 小明从左边上桥
👤 小红从右边上桥
👥 两人在桥中间相遇
💥 谁都不让谁 → 僵持不下 → 死锁！

数据库死锁：
事务A：锁定账户1，等待账户2
事务B：锁定账户2，等待账户1
💥 互相等待 → 死锁！
```

### 9.2 死锁产生的典型场景


**场景1：循环等待**

```java
// 事务A
@Transactional
public void transferA() {
    // 1. 锁定账户1
    Account account1 = session.get(
        Account.class, 1L, 
        LockMode.PESSIMISTIC_WRITE
    );
    
    Thread.sleep(100);  // 模拟业务处理
    
    // 2. 尝试锁定账户2
    Account account2 = session.get(
        Account.class, 2L, 
        LockMode.PESSIMISTIC_WRITE  // 等待...
    );
}

// 事务B（同时执行）
@Transactional
public void transferB() {
    // 1. 锁定账户2
    Account account2 = session.get(
        Account.class, 2L, 
        LockMode.PESSIMISTIC_WRITE
    );
    
    Thread.sleep(100);
    
    // 2. 尝试锁定账户1
    Account account1 = session.get(
        Account.class, 1L, 
        LockMode.PESSIMISTIC_WRITE  // 等待...
    );
}

// 💥 死锁：A等B释放账户2，B等A释放账户1
```

**场景2：锁升级死锁**

```java
// 事务A和B同时执行
@Transactional
public void process(Long id) {
    // 1. 都获取读锁（可以同时持有）
    Account account = session.get(
        Account.class, id, 
        LockMode.PESSIMISTIC_READ
    );
    
    // 2. 都想升级为写锁
    session.lock(account, LockMode.PESSIMISTIC_WRITE);
    // 💥 两者都在等对方释放读锁
}
```

**场景3：不同顺序获取锁**

```java
// 事务A：先锁商品，后锁订单
@Transactional
public void methodA() {
    Product product = session.get(
        Product.class, 1L, 
        LockMode.PESSIMISTIC_WRITE
    );
    Order order = session.get(
        Order.class, 1L, 
        LockMode.PESSIMISTIC_WRITE
    );
}

// 事务B：先锁订单，后锁商品
@Transactional
public void methodB() {
    Order order = session.get(
        Order.class, 1L, 
        LockMode.PESSIMISTIC_WRITE
    );
    Product product = session.get(
        Product.class, 1L, 
        LockMode.PESSIMISTIC_WRITE
    );
}

// 💥 可能死锁：顺序不一致
```

### 9.3 死锁检测与处理


**数据库层面的检测**：

```sql
-- MySQL查看死锁信息
SHOW ENGINE INNODB STATUS;

-- 输出示例（简化）：
------------------------
LATEST DETECTED DEADLOCK
------------------------
TRANSACTION 1234, ACTIVE 5 sec starting index read
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 10, OS thread handle 123, query id 45 localhost root updating
UPDATE account SET balance = 900 WHERE id = 1

TRANSACTION 5678, ACTIVE 5 sec starting index read
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 11, OS thread handle 456, query id 46 localhost root updating
UPDATE account SET balance = 800 WHERE id = 2

*** (1) WAITING FOR THIS LOCK:
RECORD LOCKS on account
*** (2) WAITING FOR THIS LOCK:
RECORD LOCKS on account
*** WE ROLL BACK TRANSACTION (1)
```

**Hibernate异常处理**：

```java
try {
    // 可能发生死锁的操作
    transferMoney(accountId1, accountId2, amount);
    
} catch (PessimisticLockException e) {
    // Hibernate包装的死锁异常
    if (e.getCause() instanceof SQLException) {
        SQLException sqlEx = (SQLException) e.getCause();
        // MySQL死锁错误码：1213
        if (sqlEx.getErrorCode() == 1213) {
            logger.warn("检测到死锁，准备重试");
            // 重试逻辑
            retryTransfer(accountId1, accountId2, amount);
        }
    }
}
```

### 9.4 死锁预防策略


**策略1：统一锁顺序（最重要）**

```java
// ✅ 正确做法：按ID大小顺序获取锁
@Transactional
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 确保总是按照ID从小到大的顺序获取锁
    Long firstId = Math.min(fromId, toId);
    Long secondId = Math.max(fromId, toId);
    
    Account first = session.get(
        Account.class, firstId, 
        LockMode.PESSIMISTIC_WRITE
    );
    
    Account second = session.get(
        Account.class, secondId, 
        LockMode.PESSIMISTIC_WRITE
    );
    
    // 执行转账逻辑...
    if (fromId.equals(firstId)) {
        first.setBalance(first.getBalance().subtract(amount));
        second.setBalance(second.getBalance().add(amount));
    } else {
        second.setBalance(second.getBalance().subtract(amount));
        first.setBalance(first.getBalance().add(amount));
    }
}
```

**策略2：减小事务范围**

```java
// ❌ 错误：事务太大，锁持有时间长
@Transactional
public void processOrder(OrderDTO dto) {
    // 查询商品（加锁）
    Product product = session.get(
        Product.class, dto.getProductId(), 
        LockMode.PESSIMISTIC_WRITE
    );
    
    // 复杂的业务逻辑（持有锁）
    doComplexCalculation();  // 耗时操作
    sendEmail();             // 耗时操作
    callExternalAPI();       // 耗时操作
    
    // 更新数据
    product.setStock(product.getStock() - 1);
}

// ✅ 正确：缩小事务范围
public void processOrder(OrderDTO dto) {
    // 1. 事务外的准备工作
    CalculationResult result = doComplexCalculation();
    sendEmail();
    callExternalAPI();
    
    // 2. 快速的事务操作
    executeInTransaction(() -> {
        Product product = session.get(
            Product.class, dto.getProductId(), 
            LockMode.PESSIMISTIC_WRITE
        );
        product.setStock(product.getStock() - 1);
    });
}
```

**策略3：使用乐观锁替代悲观锁**

```java
// ✅ 低冲突场景用乐观锁
@Entity
public class Order {
    @Version
    private Integer version;
    // ...
}

@Transactional
public void updateOrder(Long orderId, OrderDTO dto) {
    Order order = session.get(Order.class, orderId);
    order.setStatus(dto.getStatus());
    // 提交时检查版本号，不会死锁
}
```

**策略4：设置锁超时**

```java
// 设置超时时间，避免无限等待
@Transactional
public void safeTransfer(Long fromId, Long toId, BigDecimal amount) {
    try {
        // 设置5秒超时
        LockOptions options = new LockOptions(LockMode.PESSIMISTIC_WRITE)
            .setTimeOut(5000);  // 5秒后超时
        
        Account from = session.get(Account.class, fromId);
        session.buildLockRequest(options).lock(from);
        
        Account to = session.get(Account.class, toId);
        session.buildLockRequest(options).lock(to);
        
        // 执行转账
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
    } catch (LockTimeoutException e) {
        // 超时未获取锁，可能是死锁
        throw new BusinessException("系统繁忙，请稍后重试");
    }
}
```

### 9.5 死锁恢复策略


**策略1：自动重试**

```java
public class DeadlockRetryService {
    
    private static final int MAX_RETRIES = 3;
    
    @Transactional
    public void transferWithRetry(Long fromId, Long toId, BigDecimal amount) {
        int attempt = 0;
        
        while (attempt < MAX_RETRIES) {
            try {
                // 尝试执行转账
                doTransfer(fromId, toId, amount);
                return;  // ✅ 成功则返回
                
            } catch (PessimisticLockException e) {
                attempt++;
                
                // 检查是否为死锁
                if (isDeadlock(e)) {
                    if (attempt >= MAX_RETRIES) {
                        throw new BusinessException("操作失败，请稍后重试");
                    }
                    
                    // 随机延迟后重试（避免再次冲突）
                    randomSleep(100, 500);
                    logger.warn("检测到死锁，第{}次重试", attempt);
                } else {
                    throw e;  // 其他锁异常直接抛出
                }
            }
        }
    }
    
    private boolean isDeadlock(Exception e) {
        // 检查是否为死锁异常
        Throwable cause = e.getCause();
        if (cause instanceof SQLException) {
            int errorCode = ((SQLException) cause).getErrorCode();
            // MySQL死锁错误码：1213
            // PostgreSQL: 40P01
            return errorCode == 1213 || errorCode == 40001;
        }
        return false;
    }
    
    private void randomSleep(int min, int max) {
        try {
            int delay = min + new Random().nextInt(max - min);
            Thread.sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

**策略2：事务补偿**

```java
@Service
public class TransferService {
    
    @Transactional
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        try {
            // 执行转账
            doTransfer(fromId, toId, amount);
            
        } catch (PessimisticLockException e) {
            if (isDeadlock(e)) {
                // 记录失败日志
                logFailedTransfer(fromId, toId, amount);
                
                // 发送补偿任务到消息队列
                sendCompensationTask(fromId, toId, amount);
                
                throw new BusinessException("转账失败，系统将自动重试");
            }
        }
    }
    
    // 异步补偿任务
    @Async
    @Transactional
    public void compensateTransfer(TransferTask task) {
        // 延迟后重新执行
        Thread.sleep(1000);
        doTransfer(task.getFromId(), task.getToId(), task.getAmount());
    }
}
```

### 9.6 死锁监控与告警


**监控指标**：

```java
@Component
public class DeadlockMonitor {
    
    private final AtomicLong deadlockCount = new AtomicLong(0);
    private final AtomicLong totalTransactions = new AtomicLong(0);
    
    public void recordDeadlock() {
        deadlockCount.incrementAndGet();
    }
    
    public void recordTransaction() {
        totalTransactions.incrementAndGet();
    }
    
    // 死锁率
    public double getDeadlockRate() {
        long total = totalTransactions.get();
        if (total == 0) return 0;
        return (double) deadlockCount.get() / total * 100;
    }
    
    // 定时检查并告警
    @Scheduled(fixedRate = 60000)  // 每分钟检查
    public void checkAndAlert() {
        double rate = getDeadlockRate();
        
        if (rate > 5.0) {  // 死锁率超过5%
            sendAlert("死锁率过高：" + rate + "%");
        }
        
        // 重置计数器
        deadlockCount.set(0);
        totalTransactions.set(0);
    }
}
```

**日志记录**：

```java
@Aspect
@Component
public class DeadlockLoggingAspect {
    
    @AfterThrowing(
        pointcut = "@annotation(org.springframework.transaction.annotation.Transactional)",
        throwing = "ex"
    )
    public void logDeadlock(JoinPoint joinPoint, Exception ex) {
        if (isDeadlock(ex)) {
            String methodName = joinPoint.getSignature().toShortString();
            Object[] args = joinPoint.getArgs();
            
            logger.error("死锁检测 - 方法: {}, 参数: {}, 异常: {}", 
                methodName, Arrays.toString(args), ex.getMessage());
            
            // 记录详细的死锁信息
            logDeadlockDetails(ex);
        }
    }
    
    private void logDeadlockDetails(Exception ex) {
        // 记录死锁涉及的事务、锁资源等信息
        // 便于后续分析和优化
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔐 锁的本质：
- 并发控制机制，防止数据冲突
- 保证多个事务同时操作时的数据一致性

🔒 悲观锁：
- 先锁定后操作，确保安全
- 适合高冲突场景（秒杀、库存）
- 性能较低，可能死锁

🔓 乐观锁：
- 先操作后检查，发现冲突再处理
- 适合低冲突场景（普通业务）
- 性能较高，无死锁风险

📋 @Version：
- 版本号控制，乐观锁的实现方式
- Hibernate自动维护版本号
- 更新时检查版本号是否匹配

⏰ 时间戳锁：
- 用时间戳代替版本号
- 记录最后修改时间
- 注意精度问题，推荐用版本号

🔐 LockMode：
- 锁的强度级别
- PESSIMISTIC_WRITE（最常用）
- OPTIMISTIC（乐观锁）
```

### 10.2 关键理解要点


**🔹 如何选择锁策略**

```
决策流程：
1. 评估冲突频率
   ├─ 高冲突 → 悲观锁
   └─ 低冲突 → 乐观锁

2. 考虑性能要求
   ├─ 高性能 → 乐观锁
   └─ 强一致性 → 悲观锁

3. 分析业务特点
   ├─ 库存/余额 → 悲观锁
   ├─ 订单/用户信息 → 乐观锁
   └─ 只读查询 → 不加锁或读锁
```

**🔹 死锁预防的关键**

```
核心原则：
✅ 统一锁顺序（最重要！）
✅ 缩小事务范围
✅ 设置锁超时
✅ 使用乐观锁替代
✅ 避免锁升级

记忆口诀：
顺序一致不死锁
事务要小锁要少
超时重试要设好
乐观替代更可靠
```

**🔹 版本号 vs 时间戳**

| 特性 | **版本号（推荐）** | **时间戳** |
|------|------------------|-----------|
| 可靠性 | `✅ 绝对可靠` | `⚠️ 可能有精度问题` |
| 业务意义 | `纯版本控制` | `记录修改时间` |
| 推荐度 | `⭐⭐⭐⭐⭐` | `⭐⭐⭐` |

### 10.3 实战应用指南


**场景1：电商库存扣减**

```java
// ✅ 推荐：悲观写锁
@Transactional
public void deductStock(Long productId, Integer quantity) {
    Product product = session.get(
        Product.class, 
        productId,
        LockMode.PESSIMISTIC_WRITE  // 悲观锁
    );
    
    if (product.getStock() < quantity) {
        throw new BusinessException("库存不足");
    }
    
    product.setStock(product.getStock() - quantity);
}
```

**场景2：用户信息修改**

```java
// ✅ 推荐：乐观锁
@Entity
public class User {
    @Version
    private Integer version;
    // ...
}

@Transactional
public void updateUser(Long userId, UserDTO dto) {
    User user = session.get(User.class, userId);
    user.setName(dto.getName());
    user.setEmail(dto.getEmail());
    // 提交时检查版本号
}
```

**场景3：转账操作**

```java
// ✅ 推荐：统一锁顺序 + 悲观锁
@Transactional
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 按ID排序，避免死锁
    Long firstId = Math.min(fromId, toId);
    Long secondId = Math.max(fromId, toId);
    
    Account first = session.get(
        Account.class, firstId, 
        LockMode.PESSIMISTIC_WRITE
    );
    Account second = session.get(
        Account.class, secondId, 
        LockMode.PESSIMISTIC_WRITE
    );
    
    // 执行转账逻辑...
}
```

### 10.4 常见问题与解决方案


**问题1：频繁的乐观锁冲突**

```
症状：大量OptimisticLockException异常
原因：并发修改同一数据
解决：
✅ 改用悲观锁
✅ 实现自动重试机制
✅ 优化业务逻辑，减少冲突
```

**问题2：悲观锁性能问题**

```
症状：响应时间长，吞吐量低
原因：锁等待时间过长
解决：
✅ 缩小事务范围
✅ 改用乐观锁（如果可以）
✅ 设置合理的锁超时时间
✅ 数据库层面优化索引
```

**问题3：死锁频繁发生**

```
症状：PessimisticLockException异常
原因：锁顺序不一致，事务过大
解决：
✅ 统一锁获取顺序
✅ 减小事务粒度
✅ 实现死锁重试机制
✅ 监控死锁率并告警
```

### 10.5 最佳实践建议


**✅ 推荐做法**

```
1. 优先使用乐观锁
   - 大部分场景冲突少
   - 性能好，无死锁

2. 高冲突场景用悲观锁
   - 库存、余额等核心数据
   - 配合统一锁顺序

3. 显式锁定灵活控制
   - 先查询后决定是否加锁
   - 减少不必要的锁等待

4. 设置锁超时
   - 避免无限等待
   - 快速失败，友好提示

5. 完善监控告警
   - 记录死锁日志
   - 监控死锁率
   - 及时优化调整
```

**❌ 避免的陷阱**

```
1. 手动修改版本号
   - @Version字段交给Hibernate管理
   - 不要手动setVersion()

2. 事务范围过大
   - 锁持有时间过长
   - 增加死锁风险

3. 锁顺序不统一
   - 必须严格按顺序获取锁
   - 防止死锁的关键

4. 忽略异常处理
   - 要捕获锁相关异常
   - 实现重试或补偿逻辑

5. 过度使用悲观锁
   - 评估实际冲突频率
   - 不是所有场景都需要悲观锁
```

**核心记忆口诀**：
```
乐观为主悲观为辅
版本控制自动维护
统一顺序防止死锁
超时重试保证可用
监控告警持续优化
```

---

## 🎓 学习建议


**新手学习路径**：

```
第1步：理解锁的概念
├─ 为什么需要锁
├─ 悲观锁 vs 乐观锁
└─ 生活场景类比理解

第2步：掌握基本用法
├─ @Version注解使用
├─ LockMode类型选择
└─ 显式锁定操作

第3步：处理异常情况
├─ 乐观锁冲突处理
├─ 悲观锁超时处理
└─ 死锁检测与恢复

第4步：性能优化
├─ 选择合适的锁策略
├─ 避免死锁的技巧
└─ 监控与调优
```

**实践建议**：

```
✅ 从简单场景入手
- 先用乐观锁练习
- 理解版本号机制
- 观察冲突异常

✅ 逐步尝试悲观锁
- 理解锁等待原理
- 练习LockMode使用
- 体验性能差异

✅ 模拟并发场景
- 多线程测试
- 观察死锁现象
- 实践解决方案

✅ 总结最佳实践
- 记录踩过的坑
- 整理解决方案
- 形成自己的模式
```

---

**恭喜你完成了Hibernate锁机制的学习！** 🎉

记住：
- **选择合适的锁策略是关键**
- **统一锁顺序防止死锁**
- **监控和优化持续进行**
- **实践出真知，多动手尝试**