---
title: 29、二级缓存配置与使用
---
## 📚 目录

1. [二级缓存的本质理解](#1-二级缓存的本质理解)
2. [二级缓存工作原理](#2-二级缓存工作原理)
3. [缓存提供商选择](#3-缓存提供商选择)
4. [缓存策略配置](#4-缓存策略配置)
5. [缓存区域设置](#5-缓存区域设置)
6. [集群环境缓存](#6-集群环境缓存)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 二级缓存的本质理解


### 1.1 什么是二级缓存


> 📌 **核心概念**  
> 二级缓存是SessionFactory级别的缓存，所有Session共享，用于减少数据库访问次数

**生活化理解**：

```
一级缓存就像你的口袋：
👤 个人专用，随身携带
📱 Session关闭就清空

二级缓存就像图书馆：
🏛️ 大家共享，长期存在
📚 多个Session都能用
🔄 应用不重启就一直在
```

**为什么需要二级缓存**：

```
场景：电商网站查询商品信息

没有二级缓存：
用户A查询商品 → 访问数据库
用户B查询同一商品 → 又访问数据库
用户C查询同一商品 → 还是访问数据库
❌ 重复查询，浪费资源

有了二级缓存：
用户A查询商品 → 访问数据库 → 存入二级缓存
用户B查询同一商品 → 直接从缓存获取 ⚡
用户C查询同一商品 → 直接从缓存获取 ⚡
✅ 大幅减少数据库压力
```

### 1.2 一级缓存 vs 二级缓存


| 🆚 对比项 | **一级缓存** | **二级缓存** | **使用建议** |
|---------|------------|------------|-------------|
| 作用范围 | Session级别 | SessionFactory级别 | 短期用一级，长期用二级 |
| 生命周期 | Session关闭即销毁 | 应用运行期间存在 | 热点数据放二级缓存 |
| 数据共享 | 不共享 | 所有Session共享 | 多用户场景用二级 |
| 默认状态 | 默认开启 | 需要手动配置 | 按需开启二级缓存 |
| 适用数据 | 单次会话临时数据 | 热点数据、不常变化 | 商品信息、配置数据 |

**记忆要点**：
- 一级缓存：个人专用的小本本 📒
- 二级缓存：公共图书馆 🏛️

---

## 2. ⚙️ 二级缓存工作原理


### 2.1 缓存查询流程


**完整的数据查询路径**：

```
用户发起查询请求
        ↓
1. 先查一级缓存（Session缓存）
   ├─ 找到了 → 直接返回 ✅
   └─ 没找到 → 继续往下
        ↓
2. 再查二级缓存（SessionFactory缓存）
   ├─ 找到了 → 放入一级缓存 → 返回 ✅
   └─ 没找到 → 继续往下
        ↓
3. 查询数据库
   ├─ 查到数据 → 放入二级缓存 → 放入一级缓存 → 返回
   └─ 没数据 → 返回null
```

**示例说明**：

```java
// 第一个Session查询
Session session1 = sessionFactory.openSession();
User user1 = session1.get(User.class, 1L);
// ① 一级缓存没有，二级缓存也没有
// ② 查询数据库，获取数据
// ③ 存入二级缓存，也存入session1的一级缓存
session1.close();

// 第二个Session查询（同一个用户）
Session session2 = sessionFactory.openSession();
User user2 = session2.get(User.class, 1L);
// ① session2的一级缓存没有
// ② 二级缓存有 → 直接获取 ⚡（不访问数据库）
// ③ 放入session2的一级缓存
session2.close();
```

> 💡 **理解要点**  
> 二级缓存是"中转站"：数据库的数据先到二级缓存，再分发给各个Session的一级缓存

### 2.2 缓存同步机制


**数据修改时的同步流程**：

```
场景：用户A修改了某个商品信息

1. 更新数据库
   UPDATE product SET price = 99 WHERE id = 1
        ↓
2. 清空相关缓存
   ├─ 清除一级缓存中的该数据
   └─ 清除二级缓存中的该数据
        ↓
3. 下次查询时
   ├─ 缓存中没有
   └─ 重新从数据库加载最新数据
```

**三种同步策略**：

| 策略类型 | **特点** | **适用场景** | **风险** |
|---------|---------|------------|---------|
| 🔄 **读写缓存** | 更新时立即同步 | 实时性要求高 | 性能开销大 |
| 📖 **只读缓存** | 从不更新，只读 | 静态数据 | 数据变化需重启 |
| 🔀 **非严格读写** | 延迟同步 | 允许短暂不一致 | 可能读到旧数据 |

---

## 3. 🛠️ 缓存提供商选择


### 3.1 主流缓存提供商对比


Hibernate本身不提供缓存实现，需要集成第三方缓存框架：

| 🏷️ 提供商 | **特点** | **优势** | **推荐场景** |
|----------|---------|---------|------------|
| **EhCache** | 纯Java实现 | 配置简单、文档丰富 | 🌟 新手入门首选 |
| **Infinispan** | 红帽出品 | 分布式、集群支持强 | 大型分布式系统 |
| **Redis** | 远程缓存 | 性能极高、支持持久化 | 高并发、微服务 |
| **Hazelcast** | 内存数据网格 | 自动集群、易扩展 | 云原生应用 |

> 📌 **新手建议**  
> 先从EhCache开始学习，它是Hibernate官方推荐的缓存实现，配置最简单

### 3.2 EhCache集成配置


**步骤一：添加依赖**

```xml
<!-- EhCache核心库 -->
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-ehcache</artifactId>
    <version>5.6.15.Final</version>
</dependency>

<!-- EhCache 3.x版本（推荐） -->
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>3.10.8</version>
</dependency>
```

**步骤二：启用二级缓存**

```properties
# hibernate.cfg.xml 中配置
hibernate.cache.use_second_level_cache=true
hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
```

**步骤三：创建缓存配置文件** `ehcache.xml`

```xml
<ehcache>
    <!-- 缓存数据存放位置 -->
    <diskStore path="java.io.tmpdir/ehcache"/>
    
    <!-- 默认缓存配置：适用于没有特殊指定的实体 -->
    <defaultCache
        maxEntriesLocalHeap="1000"     ← 最多缓存1000个对象
        eternal="false"                 ← 不是永久缓存
        timeToIdleSeconds="300"        ← 5分钟不访问就清除
        timeToLiveSeconds="600"        ← 最多存活10分钟
        overflowToDisk="true"/>        ← 超出内存写入磁盘
</ehcache>
```

> ⚠️ **配置注意**  
> - `timeToIdleSeconds`：闲置超时（不访问就清除）
> - `timeToLiveSeconds`：存活超时（无论是否访问都清除）
> - `overflowToDisk`：内存不足时是否写入磁盘

---

## 4. 📋 缓存策略配置


### 4.1 四种缓存策略详解


**策略一：READ_ONLY（只读）**

```
适用场景：静态数据、配置数据
特点：性能最高，但数据不能修改

实际例子：
• 国家地区列表
• 系统配置参数
• 字典数据

⚡ 优势：速度最快，无需同步机制
❌ 限制：数据变化需要重启应用
```

**策略二：NONSTRICT_READ_WRITE（非严格读写）**

```
适用场景：允许短暂数据不一致
特点：性能较高，更新有延迟

实际例子：
• 商品浏览次数
• 文章点赞数
• 用户积分（非关键）

⚡ 优势：性能好，适合大部分场景
⚠️ 风险：可能读到稍旧的数据（秒级）
```

**策略三：READ_WRITE（读写）**

```
适用场景：数据一致性要求高
特点：更新立即同步，性能中等

实际例子：
• 订单信息
• 用户账户余额
• 库存数量

✅ 优势：数据一致性强
⏱️ 代价：性能开销较大
```

**策略四：TRANSACTIONAL（事务）**

```
适用场景：需要事务级别一致性
特点：最严格，性能最低

实际例子：
• 金融交易数据
• 支付流水
• 关键业务数据

🔒 优势：完全一致性保证
💰 代价：性能开销最大
```

### 4.2 实体缓存配置


**方式一：注解配置（推荐）**

```java
@Entity
@Table(name = "products")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)  // ← 开启二级缓存
public class Product {
    @Id
    private Long id;
    
    private String name;
    private BigDecimal price;
    
    // 集合也可以缓存
    @OneToMany
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private Set<Review> reviews;
}
```

**方式二：XML配置**

```xml
<class name="com.example.Product" table="products">
    <cache usage="read-write"/>  <!-- 实体缓存 -->
    
    <id name="id" column="id">
        <generator class="identity"/>
    </id>
    
    <set name="reviews">
        <cache usage="read-write"/>  <!-- 集合缓存 -->
        <key column="product_id"/>
        <one-to-many class="com.example.Review"/>
    </set>
</class>
```

> 💡 **选择建议**  
> - **商品信息**：READ_WRITE（价格变化需要立即看到）
> - **分类数据**：READ_ONLY（几乎不变化）
> - **浏览记录**：NONSTRICT_READ_WRITE（允许稍有延迟）

---

## 5. 🎨 缓存区域设置


### 5.1 什么是缓存区域


**缓存区域**就是给不同类型的数据分配不同的"存储空间"，每个空间有独立的配置：

```
想象一个超市：

生鲜区（缓存区域1）：
• 商品：水果蔬菜
• 保质期：1-3天
• 容量：100个商品

干货区（缓存区域2）：
• 商品：米面粮油
• 保质期：30-90天
• 容量：500个商品
```

**在Hibernate中的映射**：

```
用户信息区域：
• 实体：User、UserProfile
• 过期时间：30分钟
• 最大对象：5000个

商品信息区域：
• 实体：Product、Category
• 过期时间：10分钟
• 最大对象：10000个
```

### 5.2 配置缓存区域


**在 ehcache.xml 中定义区域**：

```xml
<ehcache>
    <!-- 用户信息缓存区域 -->
    <cache name="com.example.entity.User"
        maxEntriesLocalHeap="5000"      ← 最多5000个用户
        timeToIdleSeconds="1800"        ← 30分钟不访问清除
        timeToLiveSeconds="3600">       ← 1小时后必清除
    </cache>
    
    <!-- 商品信息缓存区域 -->
    <cache name="com.example.entity.Product"
        maxEntriesLocalHeap="10000"     ← 最多1万个商品
        timeToIdleSeconds="600"         ← 10分钟不访问清除
        timeToLiveSeconds="1800">       ← 30分钟后必清除
    </cache>
    
    <!-- 查询结果缓存区域 -->
    <cache name="query.ProductList"
        maxEntriesLocalHeap="100"       ← 最多100个查询结果
        timeToIdleSeconds="300"         ← 5分钟不访问清除
        timeToLiveSeconds="600">        ← 10分钟后必清除
    </cache>
</ehcache>
```

> ⚠️ **配置原则**  
> - **热点数据**：缓存时间长一些、容量大一些
> - **冷门数据**：缓存时间短一些、容量小一些
> - **查询结果**：过期时间要短（因为可能包含多个实体）

### 5.3 查询缓存配置


除了实体缓存，还可以缓存查询结果：

```java
// 启用查询缓存（全局配置）
hibernate.cache.use_query_cache=true

// 在具体查询中使用
Session session = sessionFactory.openSession();

// 方式一：HQL查询缓存
List<Product> products = session.createQuery(
    "FROM Product WHERE price < :price", Product.class)
    .setParameter("price", 100)
    .setCacheable(true)                    // ← 开启查询缓存
    .setCacheRegion("query.ProductList")   // ← 指定缓存区域
    .list();

// 方式二：Criteria查询缓存
CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<Product> criteria = builder.createQuery(Product.class);
Root<Product> root = criteria.from(Product.class);
criteria.where(builder.lessThan(root.get("price"), 100));

List<Product> products = session.createQuery(criteria)
    .setCacheable(true)                    // ← 开启查询缓存
    .list();
```

**查询缓存的关键点**：

```
查询缓存存储的内容：
✅ 查询条件（HQL语句 + 参数）
✅ 查询结果的ID列表

不存储的内容：
❌ 完整的实体对象

查询流程：
1. 根据HQL + 参数查询缓存
2. 找到ID列表
3. 根据ID从二级缓存获取实体
4. 返回结果
```

---

## 6. 🌐 集群环境缓存


### 6.1 集群缓存的挑战


**单机环境 vs 集群环境**：

```
单机环境（简单）：
服务器A
├─ 本地缓存
└─ 数据库

问题：无

集群环境（复杂）：
服务器A              服务器B
├─ 本地缓存          ├─ 本地缓存
└─ 数据库 ←─────────┘

问题：数据不一致！
```

**不一致的场景**：

```
时间线：
1. 用户访问服务器A，查询商品价格100元
   → 服务器A缓存：商品价格=100

2. 管理员访问服务器B，修改价格为80元
   → 服务器B缓存：商品价格=80
   → 数据库：商品价格=80

3. 用户再次访问服务器A
   → 服务器A缓存：仍然是100 ❌（脏数据）
```

### 6.2 集群缓存解决方案


**方案一：使用分布式缓存（推荐）**

```
架构：
服务器A    服务器B    服务器C
   ↓          ↓          ↓
        共享缓存服务器
      （Redis/Memcached）
              ↓
            数据库

优势：
✅ 所有服务器共享同一个缓存
✅ 数据一致性强
✅ 扩展性好
```

**集成Redis作为二级缓存**：

```xml
<!-- 添加Redis缓存支持 -->
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-hibernate-53</artifactId>
    <version>3.23.5</version>
</dependency>
```

```properties
# Hibernate配置
hibernate.cache.region.factory_class=org.redisson.hibernate.RedissonRegionFactory
hibernate.cache.redisson.config=redisson-config.yaml
```

**方案二：缓存失效通知**

```
服务器A修改数据时：
1. 更新数据库
2. 清除本地缓存
3. 通知其他服务器清除缓存

通知方式：
• 消息队列（RabbitMQ、Kafka）
• 组播消息
• 数据库触发器
```

**方案三：缓存时间控制**

```
策略：设置较短的过期时间

优势：
✅ 配置简单
✅ 自动过期更新

劣势：
❌ 缓存命中率降低
❌ 仍有短暂不一致窗口

适用：
对一致性要求不是特别严格的场景
```

### 6.3 集群缓存配置示例


**使用Infinispan的集群配置**：

```xml
<infinispan>
    <!-- 集群传输配置 -->
    <jgroups>
        <stack-file name="udp" path="jgroups-udp.xml"/>
    </jgroups>
    
    <cache-container default-cache="entity">
        <!-- 复制模式：所有节点都有完整数据 -->
        <replicated-cache name="entity">
            <transaction mode="NONE"/>
            <eviction strategy="LRU" max-entries="10000"/>
            <expiration lifespan="300000"/>  <!-- 5分钟过期 -->
        </replicated-cache>
        
        <!-- 分布式模式：数据分散在各节点 -->
        <distributed-cache name="query">
            <transaction mode="NONE"/>
            <eviction strategy="LRU" max-entries="5000"/>
        </distributed-cache>
    </cache-container>
</infinispan>
```

> 💡 **模式选择**  
> - **复制模式**：数据量小、读多写少、一致性要求高
> - **分布式模式**：数据量大、需要更大容量

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 二级缓存本质：SessionFactory级别的共享缓存
🔸 工作原理：一级缓存 → 二级缓存 → 数据库的三级查询
🔸 缓存提供商：EhCache（新手）、Redis（分布式）、Infinispan（集群）
🔸 缓存策略：只读、非严格读写、读写、事务（按需选择）
🔸 缓存区域：不同数据类型配置不同的过期时间和容量
🔸 集群缓存：使用分布式缓存或失效通知保证一致性
```

### 7.2 实用配置建议


| 📊 数据类型 | **推荐策略** | **过期时间** | **典型场景** |
|-----------|------------|------------|------------|
| 静态配置 | READ_ONLY | 永久/1天 | 国家列表、字典 |
| 商品信息 | READ_WRITE | 10-30分钟 | 电商商品 |
| 用户信息 | READ_WRITE | 30分钟 | 用户资料 |
| 统计数据 | NONSTRICT_READ_WRITE | 5-10分钟 | 浏览量、点赞 |
| 金融数据 | TRANSACTIONAL | 1-5分钟 | 账户余额 |

### 7.3 常见问题与解决


**问题1：缓存不生效**
```
✅ 检查清单：
1. 是否启用了 use_second_level_cache=true
2. 实体类是否添加了 @Cache 注解
3. 缓存提供商依赖是否正确
4. ehcache.xml 配置文件是否在类路径下
```

**问题2：数据不一致**
```
✅ 解决方案：
1. 减少缓存过期时间
2. 使用 READ_WRITE 策略
3. 集群环境使用分布式缓存
4. 关键数据不使用二级缓存
```

**问题3：内存溢出**
```
✅ 优化措施：
1. 设置合理的 maxEntriesLocalHeap
2. 启用 overflowToDisk 磁盘溢出
3. 监控缓存使用情况
4. 及时清理不活跃的缓存区域
```

### 7.4 学习路径建议


```
📚 学习阶段：

第1周：基础理解
- [ ] 理解二级缓存的作用和原理
- [ ] 掌握 EhCache 的基本配置
- [ ] 学会配置实体缓存

第2周：深入应用  
- [ ] 掌握四种缓存策略的选择
- [ ] 学会配置查询缓存
- [ ] 理解缓存区域的划分

第3周：生产实践
- [ ] 学习集群缓存配置
- [ ] 掌握缓存监控和调优
- [ ] 了解常见问题排查
```

**核心记忆口诀**：
> 二级缓存全局享，一级不在它来帮  
> 策略选对很重要，区域划分要记牢  
> 集群环境需分布，监控调优保稳妥

---

## ✅ 自检清单


学完本节后，你应该能够：
- [ ] 清楚解释二级缓存和一级缓存的区别
- [ ] 能够配置 EhCache 并启用二级缓存
- [ ] 知道如何选择合适的缓存策略
- [ ] 会配置不同的缓存区域
- [ ] 了解集群环境下的缓存同步方案
- [ ] 能够排查常见的缓存问题

> 💡 **实践建议**  
> 在开发环境中开启 Hibernate 的统计信息，观察缓存命中率：
> ```properties
> hibernate.generate_statistics=true
> ```
> 然后通过日志分析哪些查询使用了缓存，哪些没有。