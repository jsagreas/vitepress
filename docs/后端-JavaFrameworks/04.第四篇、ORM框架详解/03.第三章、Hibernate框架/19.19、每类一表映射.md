---
title: 19、每类一表映射
---
## 📚 目录

1. [每类一表策略概述](#1-每类一表策略概述)
2. [实现方式与配置](#2-实现方式与配置)
3. [字段重写机制](#3-字段重写机制)
4. [表结构设计详解](#4-表结构设计详解)
5. [查询特点与复杂度](#5-查询特点与复杂度)
6. [适用场景分析](#6-适用场景分析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 每类一表策略概述


### 1.1 什么是每类一表


**通俗理解**：每类一表就像给每个类都单独准备一个"档案柜"，每个类的数据都完整存储在自己的表中。

```
现实类比：
假设你有一个动物管理系统：
- 动物表：存所有动物的共同信息
- 狗表：存狗的所有信息（包括动物的基本信息）
- 猫表：存猫的所有信息（包括动物的基本信息）

每个表都是"自给自足"的，不依赖其他表
```

### 1.2 核心特点


**🔸 基本原理**
```
继承关系：
Animal (父类)
  ├── Dog (子类)
  └── Cat (子类)

数据库映射：
┌─────────────┐
│  dog 表     │  ← 存储Dog的完整数据（包含Animal字段）
└─────────────┘
┌─────────────┐
│  cat 表     │  ← 存储Cat的完整数据（包含Animal字段）
└─────────────┘

注意：没有单独的animal表！
```

**💡 关键特征**
- ✅ **完整独立**：每个子类表包含父类所有字段
- ✅ **无共享表**：不需要父类表，每个表都独立存在
- ✅ **字段重复**：父类字段在每个子类表中重复出现
- ❌ **父类无表**：抽象父类不对应任何表

### 1.3 与其他策略的对比


**策略对比图示**
```
单表策略（SINGLE_TABLE）：
┌─────────────────────────────┐
│  animal 表（一个大表）       │
│  id | type | name | breed   │
│  1  | Dog  | 旺财 | 金毛    │
│  2  | Cat  | 咪咪 | null    │
└─────────────────────────────┘

联合表策略（JOINED）：
┌──────────┐     ┌──────────┐
│ animal表 │────→│  dog表   │
│ id | name│     │id | breed│
└──────────┘     └──────────┘

每类一表策略（TABLE_PER_CLASS）：
┌──────────────┐  ┌──────────────┐
│  dog表       │  │  cat表       │
│id|name|breed │  │id|name|color │
└──────────────┘  └──────────────┘
```

---

## 2. ⚙️ 实现方式与配置


### 2.1 基本配置示例


**Java代码实现**

```java
// 父类：使用TABLE_PER_CLASS策略
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Animal {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    
    private String name;
    private Integer age;
    
    // getter/setter省略
}
```

```java
// 子类1：Dog
@Entity
public class Dog extends Animal {
    private String breed;      // 品种
    private String barkSound;  // 叫声
    
    // getter/setter省略
}
```

```java
// 子类2：Cat
@Entity
public class Cat extends Animal {
    private String furColor;   // 毛色
    private Boolean isIndoor;  // 是否室内猫
    
    // getter/setter省略
}
```

### 2.2 配置要点说明


**🔸 关键注解解析**

| 注解 | 位置 | 作用 | 说明 |
|------|------|------|------|
| `@Inheritance` | 父类 | 指定继承策略 | `strategy = InheritanceType.TABLE_PER_CLASS` |
| `@Entity` | 每个类 | 标记为实体 | 父类和子类都需要 |
| `@Id` | 父类 | 主键标识 | 子类自动继承 |
| `@GeneratedValue` | 父类 | 主键生成策略 | 推荐使用AUTO或TABLE |

**⚠️ 重要提示**

> 💡 **主键生成策略选择**  
> 使用 `TABLE_PER_CLASS` 时，**不要用** `IDENTITY` 策略生成主键！  
> - ✅ 推荐：`GenerationType.AUTO` 或 `GenerationType.TABLE`  
> - ❌ 避免：`GenerationType.IDENTITY`（会导致ID冲突）

### 2.3 生成的表结构


**实际数据库表**

```sql
-- Dog表（包含父类所有字段）
CREATE TABLE dog (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),      -- 继承自Animal
    age INT,                -- 继承自Animal
    breed VARCHAR(100),     -- Dog特有字段
    bark_sound VARCHAR(50)  -- Dog特有字段
);

-- Cat表（包含父类所有字段）
CREATE TABLE cat (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),      -- 继承自Animal
    age INT,                -- 继承自Animal
    fur_color VARCHAR(50),  -- Cat特有字段
    is_indoor BOOLEAN       -- Cat特有字段
);
```

---

## 3. 🔧 字段重写机制


### 3.1 为什么需要字段重写


**问题场景**：有时候子类需要对父类的字段进行调整，比如改变列名、长度或约束。

```
实际需求举例：
- 父类的name字段，在Dog表中想叫dog_name
- 父类的age字段，在Cat表中想设置不同的长度
- 某些字段在不同子类中有不同的约束条件
```

### 3.2 使用@AttributeOverride重写字段


**单个字段重写**

```java
@Entity
@AttributeOverride(
    name = "name",                    // 要重写的父类字段名
    column = @Column(
        name = "dog_name",            // 新的列名
        length = 100,                 // 新的长度
        nullable = false              // 新的约束
    )
)
public class Dog extends Animal {
    private String breed;
}
```

**多个字段重写**

```java
@Entity
@AttributeOverrides({
    @AttributeOverride(
        name = "name",
        column = @Column(name = "cat_name", length = 50)
    ),
    @AttributeOverride(
        name = "age",
        column = @Column(name = "cat_age", nullable = true)
    )
})
public class Cat extends Animal {
    private String furColor;
}
```

### 3.3 字段重写对比表


**重写前后对比**

| 字段 | 重写前（默认） | 重写后（Dog表） | 重写后（Cat表） |
|------|---------------|----------------|----------------|
| `name` | `name` VARCHAR(255) | `dog_name` VARCHAR(100) NOT NULL | `cat_name` VARCHAR(50) |
| `age` | `age` INT | `age` INT | `cat_age` INT NULL |

**💡 使用建议**
- ✅ 当子类对字段有特殊需求时使用
- ✅ 保持字段语义的清晰性
- ⚠️ 不要过度使用，保持简单性

---

## 4. 📊 表结构设计详解


### 4.4 完整的表结构示例


**实体类设计**

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    private Long id;
    
    private String name;
    private BigDecimal price;
    private LocalDateTime createdAt;
}

@Entity
public class Book extends Product {
    private String isbn;
    private String author;
    private Integer pages;
}

@Entity
public class Electronics extends Product {
    private String brand;
    private Integer warrantyMonths;
    private String model;
}
```

**对应的数据库表**

```
Book表结构：
┌────┬──────┬───────┬────────────┬──────┬────────┬───────┐
│ id │ name │ price │ created_at │ isbn │ author │ pages │
├────┼──────┼───────┼────────────┼──────┼────────┼───────┤
│ 1  │《Java》│ 99.00│ 2025-01-01 │123-X │张三    │ 500  │
└────┴──────┴───────┴────────────┴──────┴────────┴───────┘

Electronics表结构：
┌────┬────────┬────────┬────────────┬────────┬────────────┬─────────┐
│ id │ name   │ price  │ created_at │ brand  │ warranty   │ model   │
├────┼────────┼────────┼────────────┼────────┼────────────┼─────────┤
│ 2  │iPhone15│9999.00 │ 2025-01-02 │ Apple  │ 12         │ A2345   │
└────┴────────┴────────┴────────────┴────────┴────────────┴─────────┘
```

### 4.2 表设计的优缺点


**✅ 优点分析**

```
🔸 数据完整性
- 每个表都是独立完整的，不依赖其他表
- 单表查询非常快速，不需要JOIN

🔸 表结构清晰
- 每个子类的表结构一目了然
- 方便单独维护和优化

🔸 扩展性好
- 新增子类不影响已有表
- 可以给不同子类表设置不同的索引
```

**❌ 缺点分析**

```
🔸 字段冗余
- 父类字段在每个子类表中重复存储
- 修改父类字段需要修改所有子类表

🔸 多态查询复杂
- 查询所有类型数据需要UNION操作
- 性能开销较大
```

---

## 5. 🔍 查询特点与复杂度


### 5.1 单类查询


**查询单个子类（简单高效）**

```java
// 查询所有Dog对象
List<Dog> dogs = entityManager
    .createQuery("SELECT d FROM Dog d", Dog.class)
    .getResultList();

// 生成的SQL（简单直接）
SELECT id, name, age, breed, bark_sound 
FROM dog;
```

**性能特点**
- ⚡ **速度快**：直接查询单表，无JOIN
- ✅ **效率高**：索引优化容易
- 💯 **最优选择**：当只需要查询某一种类型时

### 5.2 多态查询


**查询所有子类（复杂度高）**

```java
// 查询所有Animal对象（包括Dog和Cat）
List<Animal> animals = entityManager
    .createQuery("SELECT a FROM Animal a", Animal.class)
    .getResultList();

// 生成的SQL（使用UNION）
SELECT id, name, age, breed, bark_sound, 'Dog' as clazz
FROM dog
UNION ALL
SELECT id, name, age, fur_color, is_indoor, 'Cat' as clazz  
FROM cat;
```

**性能分析图示**

```
查询性能对比：

单类查询：
Dog表 ──→ 结果集（快速）
时间：10ms

多态查询：
Dog表 ──┐
       ├──→ UNION ──→ 结果集（较慢）
Cat表 ──┘
时间：50ms（5倍开销）
```

### 5.3 查询复杂度总结


**复杂度对比表**

| 查询类型 | SQL操作 | 时间复杂度 | 适用场景 |
|---------|---------|-----------|---------|
| **单类查询** | `SELECT FROM dog` | ⭐ **O(1)** | 只查询某一种类型 |
| **多态查询** | `UNION ALL` | ⭐⭐⭐ **O(n)** | 需要查询所有类型 |
| **条件查询** | `WHERE + UNION` | ⭐⭐⭐⭐ **O(n×m)** | 复杂条件筛选 |

> ⚠️ **性能建议**  
> 如果经常需要多态查询，建议考虑使用其他继承策略（如JOINED或SINGLE_TABLE）

---

## 6. 🎯 适用场景分析


### 6.1 最适合的场景


**✅ 推荐使用情况**

```
🔸 场景1：子类差异大
例如：Vehicle继承
- Car：有车门数、座位数
- Boat：有吃水深度、帆类型  
- Plane：有翼展、引擎数
→ 子类之间字段差异很大，独立表更合理

🔸 场景2：很少多态查询
例如：文档管理系统
- 只查询PDF文档
- 只查询Word文档
- 很少需要"查询所有文档"
→ 单类查询为主，性能优秀

🔸 场景3：需要独立优化
例如：日志系统
- ErrorLog表：需要特殊索引
- AccessLog表：需要分区表
→ 每个表可以独立优化
```

### 6.2 不适合的场景


**❌ 不推荐使用情况**

```
🔸 场景1：频繁多态查询
例如：电商商品系统
- 经常需要"查询所有商品"
- 需要跨类型统计分析
→ UNION操作太慢，不适合

🔸 场景2：子类字段相似
例如：用户系统
- VIPUser和NormalUser字段几乎一样
- 只有几个字段不同
→ 字段重复浪费空间，用单表策略更好

🔸 场景3：频繁修改父类
例如：快速迭代的项目
- 父类字段经常变化
- 需要修改所有子类表
→ 维护成本高，不推荐
```

### 6.3 场景选择决策树


```
需要继承映射？
    │
    ├─→ 子类差异大 ──→ 很少多态查询 ──→ ✅ TABLE_PER_CLASS
    │
    ├─→ 频繁多态查询 ──→ 🔄 考虑JOINED策略
    │
    └─→ 子类字段少 ──→ 🔄 考虑SINGLE_TABLE策略
```

### 6.4 实际案例对比


**案例1：内容管理系统（适合）**

```java
// 适合TABLE_PER_CLASS
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Content {
    private String title;
    private LocalDateTime publishDate;
}

@Entity
public class Article extends Content {
    private String body;          // 文章正文
    private String author;
    private Integer wordCount;
}

@Entity  
public class Video extends Content {
    private String videoUrl;      // 视频地址
    private Integer duration;
    private String resolution;
}

// 使用时：通常分别查询文章或视频，很少混合查询
```

**案例2：社交平台（不适合）**

```java
// 不适合TABLE_PER_CLASS，应该用SINGLE_TABLE
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 更好的选择
@DiscriminatorColumn(name = "post_type")
public abstract class Post {
    private String content;
    private LocalDateTime createTime;
    private Integer likes;
}

@Entity
public class TextPost extends Post {
    private String mood; // 只多一个字段
}

@Entity
public class ImagePost extends Post {  
    private String imageUrl; // 只多一个字段
}

// 原因：
// 1. 需要统一展示所有动态（频繁多态查询）
// 2. 子类字段很少，差异不大
// 3. 单表策略查询更快
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 每类一表：每个具体类都有独立的完整表
🔸 字段重复：父类字段在每个子类表中重复存储
🔸 无父类表：抽象父类不生成对应的表
🔸 独立查询：单类查询快，多态查询需要UNION
🔸 字段重写：使用@AttributeOverride自定义字段映射
```

### 7.2 关键理解要点


**🔹 策略本质理解**

```
数据存储方式：
- 每个子类"自给自足"，包含所有需要的数据
- 不依赖其他表，完全独立存在
- 就像每个分店都有完整的商品库存，不需要总仓库

优缺点权衡：
- 优点：单表查询极快，结构清晰
- 缺点：字段重复，多态查询慢
- 选择：看业务是单类查询多还是多态查询多
```

**🔹 与其他策略的选择**

| 策略 | 表数量 | 字段重复 | 单表查询 | 多态查询 | 适用场景 |
|------|--------|---------|---------|---------|---------|
| `TABLE_PER_CLASS` | 每个子类一表 | ❌ 有 | ⭐⭐⭐ | ⭐ | 子类差异大，少多态查询 |
| `JOINED` | n+1个表 | ✅ 无 | ⭐⭐ | ⭐⭐⭐ | 规范化设计，避免冗余 |
| `SINGLE_TABLE` | 1个表 | ✅ 无 | ⭐⭐⭐ | ⭐⭐⭐ | 子类相似，性能优先 |

### 7.3 实际应用指导


**配置检查清单**
- [x] 父类使用 `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`
- [x] 主键生成策略使用 `AUTO` 或 `TABLE`（不用IDENTITY）
- [x] 根据需要使用 `@AttributeOverride` 重写字段
- [x] 评估是否需要多态查询（决定是否适合此策略）

**性能优化建议**
- 💡 为常用查询字段建立索引
- 💡 避免频繁的多态查询
- 💡 考虑业务场景选择合适的继承策略
- 💡 定期分析查询性能，必要时调整策略

**常见问题排查**
- ⚠️ 如果多态查询太慢 → 考虑换成JOINED或SINGLE_TABLE
- ⚠️ 如果表字段修改麻烦 → 考虑换成JOINED策略
- ⚠️ 如果子类字段很少 → 考虑换成SINGLE_TABLE

### 7.4 记忆要点


**核心记忆口诀**：
```
每类一表各自存，
父类字段全重复。
单表查询速度快，
多态查询要UNION。
差异大时最适合，
频繁联查要慎重。
```

**实战建议**：
- 🎯 **优先考虑查询模式**：单类查询多→选此策略；多态查询多→选其他策略
- 🎯 **评估字段重复度**：重复少→可接受；重复多→考虑JOINED
- 🎯 **关注维护成本**：表结构稳定→可用；经常变化→谨慎使用