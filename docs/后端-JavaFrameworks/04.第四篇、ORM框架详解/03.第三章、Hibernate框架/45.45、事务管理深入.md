---
title: 45、事务管理深入
---
## 📚 目录

1. [事务管理深入理解](#1-事务管理深入理解)
2. [事务隔离级别详解](#2-事务隔离级别详解)
3. [事务传播机制](#3-事务传播机制)
4. [并发控制策略](#4-并发控制策略)
5. [分布式事务处理](#5-分布式事务处理)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 💡 事务管理深入理解


### 1.1 什么是事务？


> **🎯 通俗理解**
> 事务就像你去银行转账：要么全部成功（钱转出去了），要么全部失败（钱还在账户里），不会出现钱转出去但对方没收到的情况。

**事务的本质**：
- 把多个数据库操作"打包"成一个整体
- 这些操作要么**全部成功**，要么**全部失败**
- 保证数据的**一致性和完整性**

```
举个例子：
张三给李四转账100元

步骤1：张三账户 -100元
步骤2：李四账户 +100元

如果步骤1成功，步骤2失败 → 钱就丢了！
用事务管理：两步要么都成功，要么都回滚（撤销）
```

### 1.2 事务的ACID特性


**🔸 A - Atomicity（原子性）**
```
含义：事务是不可分割的最小单位
通俗说：要么全做，要么全不做

实际场景：
订单系统：创建订单 + 扣减库存 + 生成支付记录
→ 必须全部成功，任何一步失败都要回滚
```

**🔸 C - Consistency（一致性）**
```
含义：事务前后数据状态保持一致
通俗说：不能破坏数据的规则

实际场景：
转账前：张三1000元 + 李四500元 = 1500元
转账后：张三900元 + 李四600元 = 1500元（总额不变）
```

**🔸 I - Isolation（隔离性）**
```
含义：多个事务互不干扰
通俗说：你的事务看不到别人未完成的修改

实际场景：
用户A和用户B同时抢购最后一件商品
→ 他们的操作互不影响，避免超卖
```

**🔸 D - Durability（持久性）**
```
含义：事务提交后永久保存
通俗说：一旦成功就不会丢失

实际场景：
转账成功后，即使系统崩溃重启
数据也不会丢失或回退
```

### 1.3 Hibernate中的事务管理


**🔧 基本使用方式**

```java
// 方式1：手动管理事务（最基础的方式）
Session session = sessionFactory.openSession();
Transaction tx = null;

try {
    tx = session.beginTransaction();  // 开启事务
    
    // 执行数据库操作
    User user = new User("张三", 25);
    session.save(user);
    
    tx.commit();  // 提交事务
    
} catch (Exception e) {
    if (tx != null) {
        tx.rollback();  // 出错就回滚
    }
    e.printStackTrace();
} finally {
    session.close();
}
```

> **💡 理解要点**
> - `beginTransaction()`：告诉数据库"我要开始干活了，先别保存"
> - `commit()`：告诉数据库"我干完了，可以正式保存了"  
> - `rollback()`：告诉数据库"出错了，刚才的操作全部撤销"

**🔧 Spring整合后的事务管理**

```java
@Service
public class UserService {
    
    @Autowired
    private UserDao userDao;
    
    // 声明式事务：用注解就能管理事务
    @Transactional
    public void transferMoney(Long fromId, Long toId, int amount) {
        // 扣款
        User from = userDao.findById(fromId);
        from.setBalance(from.getBalance() - amount);
        
        // 加钱
        User to = userDao.findById(toId);
        to.setBalance(to.getBalance() + amount);
        
        // 方法执行成功自动提交，出错自动回滚
    }
}
```

> **⚡ Spring事务的好处**
> 不需要写`try-catch-finally`，Spring自动帮你管理事务的开启、提交和回滚

---

## 2. 🔐 事务隔离级别详解


### 2.1 为什么需要隔离级别？


**问题场景**：
```
场景：两个用户同时操作数据库
用户A：正在修改商品价格（100元→80元）
用户B：正在查询商品价格

问题：用户B应该看到100元还是80元？
→ 这就是隔离级别要解决的问题
```

### 2.2 并发问题详解


**🔸 脏读（Dirty Read）**
```
含义：读到了别人还没提交的数据

场景演示：
时间轴  用户A                  用户B
T1     开始事务
T2     修改价格100→80
T3                          读到价格80元（脏读！）
T4     回滚事务（80→100）
T5                          用80元的价格去计算（错了！）

问题：B读到了A还没确认的数据，A后来又撤销了
```

**🔸 不可重复读（Non-Repeatable Read）**
```
含义：同一个事务中，两次读取结果不一样

场景演示：
时间轴  用户A                  用户B
T1     开始事务
T2     读取价格：100元
T3                          开始事务
T4                          修改价格100→80
T5                          提交事务
T6     再读价格：80元（变了！）

问题：A在同一个事务中读了两次，结果不一样
```

**🔸 幻读（Phantom Read）**
```
含义：查询结果的条数变了

场景演示：
时间轴  用户A                      用户B
T1     查询"价格>50的商品"：10条
T2                              插入新商品（价格60元）
T3                              提交
T4     再次查询"价格>50"：11条（多了！）

问题：查询条件没变，但结果条数变了（像见鬼了一样）
```

### 2.3 四种隔离级别


| 隔离级别 | **脏读** | **不可重复读** | **幻读** | **性能** | **使用场景** |
|---------|---------|--------------|---------|---------|-------------|
| `READ_UNCOMMITTED`<br>读未提交 | ❌ 会发生 | ❌ 会发生 | ❌ 会发生 | ⭐⭐⭐⭐⭐<br>最快 | 数据一致性要求极低的场景<br>（几乎不用） |
| `READ_COMMITTED`<br>读已提交 | ✅ 解决 | ❌ 会发生 | ❌ 会发生 | ⭐⭐⭐⭐<br>较快 | 大多数数据库的默认级别<br>（Oracle、SQL Server） |
| `REPEATABLE_READ`<br>可重复读 | ✅ 解决 | ✅ 解决 | ❌ 会发生 | ⭐⭐⭐<br>一般 | MySQL默认级别<br>适合大部分业务场景 |
| `SERIALIZABLE`<br>串行化 | ✅ 解决 | ✅ 解决 | ✅ 解决 | ⭐<br>最慢 | 对数据一致性要求极高<br>（金融核心业务） |

### 2.4 在Hibernate中设置隔离级别


**🔧 配置文件方式**

```xml
<!-- hibernate.cfg.xml -->
<hibernate-configuration>
    <session-factory>
        <!-- 设置隔离级别：2表示READ_COMMITTED -->
        <property name="hibernate.connection.isolation">2</property>
    </session-factory>
</hibernate-configuration>
```

**隔离级别对应的数字**：
- `1` = READ_UNCOMMITTED（读未提交）
- `2` = READ_COMMITTED（读已提交）  
- `4` = REPEATABLE_READ（可重复读）
- `8` = SERIALIZABLE（串行化）

**🔧 Spring中设置隔离级别**

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void updateProduct(Long id, double price) {
    Product product = productDao.findById(id);
    product.setPrice(price);
}
```

> **🎯 选择建议**
> - **一般业务**：用`READ_COMMITTED`或`REPEATABLE_READ`
> - **报表查询**：用`READ_COMMITTED`（性能好）
> - **金融交易**：用`SERIALIZABLE`（安全第一）
> - **分析统计**：用`READ_UNCOMMITTED`（允许脏读但快）

---

## 3. 🔄 事务传播机制


### 3.1 什么是事务传播？


> **🎯 通俗理解**
> 事务传播就是：当一个有事务的方法调用另一个有事务的方法时，事务该怎么处理？

**生活类比**：
```
你正在写作业（事务A）
妈妈让你去买酱油（事务B）

传播行为决定：
- 是继续写作业的同时去买酱油？（用同一个事务）
- 还是放下作业专门去买酱油？（新开一个事务）
- 还是拒绝去买？（不支持事务）
```

### 3.2 七种传播行为详解


**🔸 REQUIRED（必需）- 最常用**
```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // 执行操作A
    methodB();  // 调用B
}

@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
    // 执行操作B
}
```

**工作方式**：
```
如果A有事务 → B加入A的事务（共用一个事务）
如果A没事务 → B新建一个事务

场景：
订单服务调用库存服务
→ 两者必须在同一个事务中（要么都成功，要么都失败）
```

**🔸 REQUIRES_NEW（新建）**
```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void writeLog(String message) {
    // 写日志操作
}
```

**工作方式**：
```
无论调用者有没有事务，都新建一个独立的事务

场景：
记录操作日志
→ 即使业务失败回滚，日志也要保存成功
```

**🔸 SUPPORTS（支持）**
```
如果调用者有事务 → 就用调用者的事务
如果调用者没事务 → 就不用事务（非事务方式执行）

场景：查询操作（有没有事务都行）
```

**🔸 NOT_SUPPORTED（不支持）**
```
无论调用者有没有事务，都以非事务方式执行
如果调用者有事务，就先暂停它

场景：一些不需要事务的批量查询
```

**🔸 MANDATORY（强制）**
```
调用者必须有事务，否则抛出异常

场景：内部方法，必须在事务环境中调用
```

**🔸 NEVER（拒绝）**
```
调用者不能有事务，否则抛出异常

场景：某些特殊的非事务操作
```

**🔸 NESTED（嵌套）**
```
如果调用者有事务 → 创建一个嵌套事务（可以独立回滚）
如果调用者没事务 → 新建一个事务

场景：部分失败不影响整体的操作
```

### 3.3 实际应用示例


**场景：订单系统**

```java
@Service
public class OrderService {
    
    @Autowired
    private StockService stockService;
    
    @Autowired
    private LogService logService;
    
    // 创建订单（主事务）
    @Transactional(propagation = Propagation.REQUIRED)
    public void createOrder(Order order) {
        // 1. 保存订单
        orderDao.save(order);
        
        // 2. 扣减库存（加入主事务，一起成功或失败）
        stockService.reduceStock(order.getProductId(), order.getQuantity());
        
        // 3. 记录日志（独立事务，即使订单失败也要记录）
        logService.writeLog("创建订单：" + order.getId());
    }
}

@Service  
public class StockService {
    
    // 加入调用者的事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void reduceStock(Long productId, int quantity) {
        Stock stock = stockDao.findByProductId(productId);
        stock.setQuantity(stock.getQuantity() - quantity);
    }
}

@Service
public class LogService {
    
    // 独立事务，不受调用者影响
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void writeLog(String message) {
        Log log = new Log(message, new Date());
        logDao.save(log);
    }
}
```

> **💡 理解要点**
> - 订单和库存：用`REQUIRED`（必须一起成功）
> - 日志记录：用`REQUIRES_NEW`（独立保存）
> - 如果库存不足导致订单失败，日志依然会保存成功

---

## 4. 🔒 并发控制策略


### 4.1 为什么需要并发控制？


**问题场景**：
```
场景：两个用户同时修改同一条数据
用户A：把价格从100改成80
用户B：把价格从100改成90

没有并发控制：
T1: A读取价格100
T2: B读取价格100  
T3: A保存价格80
T4: B保存价格90（覆盖了A的修改！）

结果：A的修改丢失了（Lost Update问题）
```

### 4.2 乐观锁（Optimistic Lock）


**🔸 核心思想**
```
理念：大部分情况下不会发生冲突，先修改，提交时再检查

就像：
去图书馆借书，不用预约，直接去拿
到柜台结账时才检查书是否被别人借走了
```

**🔸 实现方式：版本号**

```java
@Entity
public class Product {
    
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    private Double price;
    
    // 版本号字段（Hibernate自动管理）
    @Version
    private Integer version;
}
```

**工作原理**：
```
初始状态：
商品价格=100，版本号=1

用户A的操作：
1. 读取：价格100，版本1
2. 修改：价格改成80
3. 保存：UPDATE product SET price=80, version=2 WHERE id=1 AND version=1

用户B的操作（晚一步）：
1. 读取：价格100，版本1  
2. 修改：价格改成90
3. 保存：UPDATE product SET price=90, version=2 WHERE id=1 AND version=1
   → 失败！因为版本号已经变成2了

结果：B的修改被拒绝，抛出OptimisticLockException
```

**🔧 使用示例**

```java
@Service
public class ProductService {
    
    @Transactional
    public void updatePrice(Long productId, Double newPrice) {
        try {
            Product product = productDao.findById(productId);
            product.setPrice(newPrice);
            // 保存时Hibernate会自动检查版本号
            
        } catch (OptimisticLockException e) {
            // 版本冲突，需要重新读取最新数据
            throw new BusinessException("数据已被他人修改，请刷新后重试");
        }
    }
}
```

> **⭐ 乐观锁的优势**
> - 性能好（不需要加数据库锁）
> - 适合读多写少的场景
> - 不会造成死锁

### 4.3 悲观锁（Pessimistic Lock）


**🔸 核心思想**
```
理念：每次都认为会发生冲突，先锁定再操作

就像：
去图书馆借书，先预约把书锁住
别人就不能借了，你用完再释放
```

**🔸 实现方式**

```java
@Transactional
public void updateProductWithLock(Long productId, Double newPrice) {
    
    // 方式1：查询时加悲观锁
    Product product = entityManager.find(
        Product.class, 
        productId,
        LockModeType.PESSIMISTIC_WRITE  // 加写锁
    );
    
    product.setPrice(newPrice);
    // 其他事务在这期间无法修改这条记录
}
```

**锁的类型**：
```
PESSIMISTIC_READ：共享锁
- 允许其他事务读，但不能写
- 适合：读取后需要保证数据不变

PESSIMISTIC_WRITE：排他锁  
- 其他事务不能读也不能写
- 适合：修改操作

PESSIMISTIC_FORCE_INCREMENT：强制更新版本号
- 结合版本号使用
```

**🔧 使用场景对比**

```
场景1：电商库存扣减
推荐：悲观锁
原因：库存竞争激烈，必须严格控制

@Transactional
public void reduceStock(Long productId, int quantity) {
    // 先锁定库存记录
    Stock stock = entityManager.find(
        Stock.class, productId, 
        LockModeType.PESSIMISTIC_WRITE
    );
    
    if (stock.getQuantity() < quantity) {
        throw new BusinessException("库存不足");
    }
    
    stock.setQuantity(stock.getQuantity() - quantity);
}

场景2：用户信息修改
推荐：乐观锁
原因：并发冲突少，性能优先

@Entity
public class UserProfile {
    @Version
    private Integer version;
    // ... 其他字段
}
```

### 4.4 乐观锁 vs 悲观锁


| 对比项 | **乐观锁** | **悲观锁** |
|-------|-----------|-----------|
| **理念** | 相信不会冲突，冲突时再处理 | 假设会冲突，提前加锁 |
| **实现** | 版本号 | 数据库锁（SELECT FOR UPDATE） |
| **性能** | ⭐⭐⭐⭐⭐ 高 | ⭐⭐⭐ 一般 |
| **冲突处理** | 抛异常，需要重试 | 等待锁释放 |
| **死锁风险** | ❌ 无 | ⚠️ 有 |
| **适用场景** | 读多写少<br>冲突少 | 写多读少<br>冲突频繁 |
| **典型应用** | 用户信息修改<br>文章编辑 | 库存扣减<br>座位预订<br>秒杀系统 |

---

## 5. 🌐 分布式事务处理


### 5.1 什么是分布式事务？


> **🎯 通俗理解**
> 分布式事务就是：操作涉及多个数据库或多个系统，需要保证它们要么都成功，要么都失败。

**生活类比**：
```
你在网上购物，涉及三个系统：
1. 订单系统：创建订单（数据库A）
2. 库存系统：扣减库存（数据库B）
3. 支付系统：扣款（数据库C）

要保证：订单创建、库存扣减、支付扣款 全部成功
任何一个失败，其他的也要回滚
```

### 5.2 分布式事务的难点


**❌ 传统事务不够用了**
```
问题1：跨数据库
订单在MySQL，库存在PostgreSQL
→ 一个事务无法管理两个数据库

问题2：跨服务
订单服务、库存服务、支付服务是独立部署的
→ 它们之间怎么协调事务？

问题3：网络问题  
服务A成功了，通知服务B时网络断了
→ 怎么保证一致性？
```

### 5.3 常见解决方案


**🔸 方案1：两阶段提交（2PC）**

```
原理：引入事务协调者，分两个阶段

阶段1：准备阶段（Prepare）
协调者：大家准备好了吗？
服务A：我准备好了
服务B：我准备好了  
服务C：我准备好了

阶段2：提交阶段（Commit）
协调者：都准备好了，大家一起提交！
服务A：提交成功
服务B：提交成功
服务C：提交成功

如果任何一个服务准备失败：
协调者：有人没准备好，大家全部回滚！
```

**优点**：保证强一致性  
**缺点**：性能差，有阻塞问题

**🔸 方案2：TCC（Try-Confirm-Cancel）**

```
三个阶段：

Try（尝试）：
- 预留资源，不实际扣减
- 订单服务：锁定订单
- 库存服务：冻结库存
- 支付服务：冻结金额

Confirm（确认）：
- 真正执行业务
- 订单服务：确认订单
- 库存服务：真正扣库存  
- 支付服务：真正扣款

Cancel（取消）：
- 如果有失败，释放资源
- 订单服务：取消订单
- 库存服务：恢复库存
- 支付服务：退款
```

**优点**：性能好，无阻塞  
**缺点**：实现复杂，需要编写补偿逻辑

**🔸 方案3：本地消息表**

```java
// 订单服务
@Transactional
public void createOrder(Order order) {
    // 1. 保存订单（本地事务）
    orderDao.save(order);
    
    // 2. 保存消息到本地消息表（同一个事务）
    Message msg = new Message("REDUCE_STOCK", order.toJson());
    messageDao.save(msg);
    
    // 3. 定时任务发送消息给库存服务
    // 发送成功后删除消息
}

// 库存服务  
@Transactional
public void reduceStock(String orderJson) {
    Order order = parse(orderJson);
    
    // 扣减库存（本地事务）
    stockDao.reduce(order.getProductId(), order.getQuantity());
}
```

**优点**：可靠性高，最终一致  
**缺点**：延迟，不是实时的

**🔸 方案4：Saga模式**

```
原理：把大事务拆成多个小事务，每个都能回滚

正向流程：
订单服务：创建订单
  ↓ 成功
库存服务：扣减库存  
  ↓ 成功
支付服务：扣款
  ↓ 成功
完成

如果支付失败：
执行补偿流程（反向）：
支付服务：无需补偿
  ↓
库存服务：恢复库存（补偿操作）
  ↓
订单服务：取消订单（补偿操作）
```

**优点**：性能好，易实现  
**缺点**：需要编写补偿逻辑

### 5.4 方案选择建议


| 场景 | **推荐方案** | **原因** |
|-----|------------|---------|
| **金融核心业务**<br>（转账、支付） | 2PC 或 TCC | 强一致性要求高，性能其次 |
| **电商订单**<br>（订单、库存） | 本地消息表 或 Saga | 允许最终一致，性能优先 |
| **数据同步**<br>（同步用户信息） | 本地消息表 | 实时性要求不高 |
| **复杂业务流程**<br>（多步骤操作） | Saga | 易于编排补偿逻辑 |

---

## 6. 📋 核心要点总结


### 6.1 事务管理记忆要点


```
🔸 ACID四特性：
A - 原子性：要么全做，要么不做
C - 一致性：数据规则不被破坏  
I - 隔离性：事务之间互不干扰
D - 持久性：提交后永久保存

🔸 隔离级别（从低到高）：
读未提交 → 读已提交 → 可重复读 → 串行化
隔离性越高，性能越低

🔸 三大并发问题：
脏读：读到未提交的数据
不可重复读：两次读结果不同
幻读：查询条数变了
```

### 6.2 事务传播速记


```
🎯 最常用的三种：
REQUIRED：有事务就加入，没有就新建（默认）
REQUIRES_NEW：总是新建独立事务
SUPPORTS：有就用，没有就算了

🎯 使用场景：
主业务 + 子业务一起成功 → REQUIRED
日志记录独立保存 → REQUIRES_NEW  
查询操作无所谓 → SUPPORTS
```

### 6.3 并发控制速记


```
🔐 乐观锁：
- 用版本号
- 适合冲突少的场景
- 性能好，无死锁

🔐 悲观锁：
- 用数据库锁
- 适合冲突多的场景  
- 安全但慢，有死锁风险

记忆口诀：
读多写少用乐观，写多读少用悲观
```

### 6.4 分布式事务速记


```
🌐 四种方案：
2PC：强一致，性能差，有阻塞
TCC：性能好，实现复杂
本地消息表：可靠，但有延迟
Saga：灵活，需要补偿逻辑

选择原则：
金融场景 → 2PC/TCC（一致性）
电商场景 → 消息表/Saga（性能）
```

### 6.5 实战建议


> **💡 新手避坑指南**

**✅ 建议做的：**
- 事务范围尽量小（只包含必要操作）
- 优先使用`READ_COMMITTED`隔离级别
- 读多写少用乐观锁，写多用悲观锁
- 分布式优先考虑最终一致性

**❌ 避免踩坑：**
- 不要在事务中调用外部接口（慢，容易超时）
- 不要在事务中做大量计算（占用连接）
- 不要长时间持有事务（容易死锁）
- 不要忽略事务回滚异常

**🔧 调试技巧：**
```properties
# 开启事务日志
logging.level.org.springframework.transaction=DEBUG
logging.level.org.hibernate.engine.transaction=DEBUG

# 查看SQL执行  
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

---

**🎯 核心理解**：
- 事务是保证数据一致性的基础工具
- 隔离级别是性能和安全的权衡
- 传播行为决定事务的组合方式
- 并发控制避免数据冲突
- 分布式事务解决跨系统一致性