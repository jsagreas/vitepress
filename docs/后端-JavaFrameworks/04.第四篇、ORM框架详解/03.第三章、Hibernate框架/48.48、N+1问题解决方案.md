---
title: 48、N+1问题解决方案
---
## 📚 目录

1. [N+1问题是什么](#1-N+1问题是什么)
2. [N+1问题产生的原因](#2-N+1问题产生的原因)
3. [懒加载与N+1的关系](#3-懒加载与N+1的关系)
4. [FETCH JOIN解决方案](#4-FETCH-JOIN解决方案)
5. [批量获取策略](#5-批量获取策略)
6. [@BatchSize注解详解](#6-BatchSize注解详解)
7. [性能监控与分析](#7-性能监控与分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🤔 N+1问题是什么


### 1.1 通俗理解N+1问题


**用生活例子来理解**：

想象你是班主任，要统计班上30个学生的家庭住址：

```
❌ 低效方式（N+1问题）：
1. 先拿到学生花名册（1次查询）
2. 然后逐个给学生打电话问住址（30次查询）
总共：1 + 30 = 31次"查询"

✅ 高效方式：
1. 开班会，让所有学生一起填写信息表（1次查询）
总共：只需要1次"查询"
```

**映射到数据库**：
- 学生花名册 = 查询主表（如User表）
- 打电话问住址 = 查询关联表（如Address表）
- N+1问题 = 1次主查询 + N次关联查询

### 1.2 什么是"N"和"1"


```
🔢 数字含义：
1 → 第一次查询主表数据
N → 针对每条主表记录，再查询一次关联数据

举例：查询10个用户及其订单
1次：SELECT * FROM user（查出10个用户）
N次：SELECT * FROM order WHERE user_id = ? （执行10次）
合计：1 + 10 = 11次数据库查询
```

### 1.3 N+1问题的实际表现


**场景示例：博客系统**

```java
// 查询所有文章及其作者信息
List<Article> articles = session.createQuery(
    "FROM Article", Article.class
).getResultList();

// 遍历显示
for (Article article : articles) {
    System.out.println(article.getTitle());
    System.out.println(article.getAuthor().getName()); // ⚠️ 这里触发额外查询
}
```

**执行的SQL**：
```
第1次查询（获取文章列表）：
SELECT * FROM article

第2-N次查询（每篇文章查一次作者）：
SELECT * FROM user WHERE id = 1
SELECT * FROM user WHERE id = 2
SELECT * FROM user WHERE id = 3
...
```

---

## 2. 🔍 N+1问题产生的原因


### 2.1 根本原因：关联数据的获取时机


**核心矛盾**：
```
问题：什么时候加载关联数据？
选择1：立即加载（Eager） → 可能浪费资源
选择2：延迟加载（Lazy） → 可能产生N+1

这就像：
🎒 旅行打包
选择1：带上所有可能用到的东西 → 包太重
选择2：到了再说 → 可能要跑很多次商店
```

### 2.2 ORM框架的默认行为


**Hibernate默认策略**：

| 关联类型 | 默认加载策略 | 说明 |
|---------|------------|------|
| **@ManyToOne** | `EAGER` | 立即加载 |
| **@OneToOne** | `EAGER` | 立即加载 |
| **@OneToMany** | `LAZY` | 延迟加载 ⚠️ |
| **@ManyToMany** | `LAZY` | 延迟加载 ⚠️ |

```
💡 理解默认策略：
@ManyToOne → 多对一，"多"的一方通常需要"一"的信息
              （订单需要知道客户，所以默认立即加载）

@OneToMany → 一对多，"一"的一方不一定需要"多"的信息
             （客户不一定要看所有订单，所以默认延迟加载）
```

### 2.3 触发N+1的典型场景


**场景1：循环访问关联对象**
```java
// ❌ 危险代码
List<User> users = userRepository.findAll(); // 1次查询
for (User user : users) {
    List<Order> orders = user.getOrders(); // N次查询！
    // 处理订单...
}
```

**场景2：对象图导航**
```java
// ❌ 危险代码
Article article = articleRepository.findById(1);
User author = article.getAuthor();        // 触发查询
List<Comment> comments = author.getComments(); // 又触发查询
```

**场景3：JSON序列化**
```java
// ❌ 危险代码
@GetMapping("/users")
public List<User> getUsers() {
    return userRepository.findAll(); // 看似简单
    // JSON序列化时会访问所有关联对象，触发大量查询！
}
```

---

## 3. 🐌 懒加载与N+1的关系


### 3.1 懒加载的工作原理


**懒加载机制**：
```
工作流程：
1️⃣ 主对象查询：只查主表数据
2️⃣ 关联对象：存储为代理对象（Proxy）
3️⃣ 首次访问：触发实际查询加载数据

就像：
📦 网购商品
1. 下单时只看商品图片（主对象）
2. 商品详情是个"链接"（代理）
3. 点击链接才加载详情（懒加载）
```

**代码示例**：
```java
@Entity
public class User {
    @Id
    private Long id;
    
    private String name;
    
    @OneToMany(fetch = FetchType.LAZY) // 懒加载
    private List<Order> orders;
}

// 使用
User user = session.get(User.class, 1L);
// 此时：user对象已加载，orders是代理对象（未加载）

System.out.println(user.getName()); // ✅ 不触发查询

System.out.println(user.getOrders().size()); // ⚠️ 触发查询！
```

### 3.2 懒加载为什么会导致N+1


**问题分析**：

```
场景：查询100个用户的订单统计

❌ 懒加载产生的问题：
第1次：SELECT * FROM user LIMIT 100  （1次）
循环：
  第2次：SELECT * FROM order WHERE user_id = 1
  第3次：SELECT * FROM order WHERE user_id = 2
  ...
  第101次：SELECT * FROM order WHERE user_id = 100
总计：101次查询！

🔍 问题根源：
懒加载让每个对象独立触发查询，
无法"批量处理"关联数据
```

### 3.3 懒加载的两难困境


**性能 vs 便利性**：

```
⚖️ 权衡选择：

急加载（EAGER）：
✅ 优点：一次查询获取所有数据，避免N+1
❌ 缺点：可能加载不需要的数据，浪费资源

懒加载（LAZY）：
✅ 优点：按需加载，节省资源
❌ 缺点：容易产生N+1问题

💡 最佳实践：
默认使用LAZY，在需要时显式优化
```

---

## 4. 🚀 FETCH JOIN解决方案


### 4.1 什么是FETCH JOIN


**通俗理解**：
```
普通JOIN：合并表格，但只返回一边的数据
FETCH JOIN：合并表格，返回双方完整数据

类比：
普通JOIN：两个班级合并考试，只记录A班成绩
FETCH JOIN：两个班级合并考试，同时记录AB两班成绩
```

**SQL对比**：
```sql
-- 普通JOIN（只获取User数据）
SELECT u.* FROM user u 
JOIN order o ON u.id = o.user_id

-- FETCH JOIN（同时获取User和Order数据）
SELECT u.*, o.* FROM user u 
JOIN order o ON u.id = o.user_id
```

### 4.2 HQL/JPQL中的FETCH JOIN


**基本语法**：
```java
// ✅ 使用FETCH JOIN
String hql = "SELECT u FROM User u " +
             "JOIN FETCH u.orders";  // 关键：JOIN FETCH
List<User> users = session.createQuery(hql, User.class)
                          .getResultList();

// 访问关联对象不再触发额外查询
for (User user : users) {
    user.getOrders().size(); // ✅ 无额外查询
}
```

**执行的SQL**：
```sql
-- 只执行一次查询
SELECT 
    u.id, u.name, u.email,
    o.id, o.order_no, o.total
FROM user u
LEFT JOIN order o ON u.id = o.user_id
```

### 4.3 多层级FETCH JOIN


**嵌套关联加载**：
```java
// 场景：用户 → 订单 → 订单项
String hql = "SELECT u FROM User u " +
             "JOIN FETCH u.orders o " +        // 第1层
             "JOIN FETCH o.orderItems";        // 第2层

// 一次查询加载三层数据
```

**多个关联同时加载**：
```java
// 场景：文章 + 作者 + 评论
String hql = "SELECT a FROM Article a " +
             "JOIN FETCH a.author " +          // 加载作者
             "JOIN FETCH a.comments";          // 加载评论

// ⚠️ 注意：可能产生笛卡尔积，数据量大时慎用
```

### 4.4 FETCH JOIN的注意事项


**使用限制**：

```
⚠️ 常见陷阱：

1️⃣ 集合获取问题：
❌ 不能对多个集合同时FETCH JOIN
// SELECT u FROM User u 
//   JOIN FETCH u.orders 
//   JOIN FETCH u.addresses  
// 会产生笛卡尔积！

2️⃣ 分页问题：
❌ FETCH JOIN + setMaxResults 会有问题
// 分页在内存中进行，效率低

3️⃣ 别名限制：
❌ 被FETCH的关联不能设置WHERE条件
// JOIN FETCH u.orders o WHERE o.status = 'ACTIVE'
// 可能导致数据不一致
```

**解决方案**：
```java
// ✅ 正确做法1：分步查询
List<User> users = findUsersWithOrders();
for (User user : users) {
    loadAddresses(user); // 单独加载地址
}

// ✅ 正确做法2：使用EntityGraph（后面讲）
```

---

## 5. 📦 批量获取策略


### 5.1 什么是批量获取


**核心思想**：
```
把N次单条查询 → 合并成几次批量查询

类比：
❌ 单次购物：需要笔，去一次文具店
            需要本，又去一次文具店
            需要笔袋，再去一次文具店

✅ 批量购物：列好清单，一次性买齐
            （笔、本、笔袋一起买）
```

**效果对比**：
```
场景：100个用户，每人5个订单

❌ N+1方式：
1次查用户 + 100次查订单 = 101次查询

✅ 批量方式（批大小=10）：
1次查用户 + 10次批量查订单 = 11次查询
每次查：WHERE user_id IN (?, ?, ?, ..., ?) 
```

### 5.2 Hibernate批量获取配置


**全局配置**（hibernate.cfg.xml）：
```xml
<!-- 设置批量获取大小 -->
<property name="hibernate.default_batch_fetch_size">16</property>
```

**常用批量大小**：
```
💡 批大小选择建议：

小批量（4-8）：
• 关联数据量小
• 内存敏感场景

中批量（16-32）：
• 通用场景
• 平衡性能和内存

大批量（50-100）：
• 数据量大
• 网络延迟高的环境

⚠️ 不要过大：
批量太大反而会降低效率
建议不超过100
```

### 5.3 批量获取的工作原理


**执行流程图示**：
```
用户查询流程（批大小=3）：

1. 获取用户列表
   ↓
2. 访问第1个用户的订单
   → 触发批量查询（加载用户1、2、3的订单）
   ↓
3. 访问第2、3个用户的订单
   → 命中缓存，无需查询 ✅
   ↓
4. 访问第4个用户的订单
   → 触发批量查询（加载用户4、5、6的订单）
   ↓
...循环
```

**实际SQL**：
```sql
-- 批量查询1（一次获取3个用户的订单）
SELECT * FROM order 
WHERE user_id IN (1, 2, 3);

-- 批量查询2
SELECT * FROM order 
WHERE user_id IN (4, 5, 6);

-- ...
```

---

## 6. 🏷️ @BatchSize注解详解


### 6.1 @BatchSize基本用法


**注解位置**：
```java
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    @BatchSize(size = 10) // 👈 在集合关联上使用
    private List<Order> orders;
}
```

**注解在实体类上**：
```java
@Entity
@BatchSize(size = 10) // 👈 在类上使用
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    private User user;
}
```

### 6.2 两种用法的区别


| 使用位置 | 作用对象 | 适用场景 | 示例 |
|---------|---------|---------|------|
| **集合上** | `批量加载集合元素` | 一对多/多对多集合 | `用户的订单列表` |
| **实体类上** | `批量加载实体本身` | 多对一关联 | `订单的用户对象` |

**实际效果对比**：
```java
// 场景1：@BatchSize在集合上
@OneToMany
@BatchSize(size = 5)
private List<Order> orders;

// 查询10个用户的订单
// SQL：2次批量查询
// WHERE user_id IN (1,2,3,4,5)
// WHERE user_id IN (6,7,8,9,10)

---

// 场景2：@BatchSize在实体上
@Entity
@BatchSize(size = 5)
public class User { ... }

// 查询10个订单的用户
// SQL：2次批量查询
// WHERE id IN (1,2,3,4,5)
// WHERE id IN (6,7,8,9,10)
```

### 6.3 @BatchSize实战示例


**示例：文章评论系统**
```java
@Entity
public class Article {
    @Id
    private Long id;
    
    @OneToMany
    @BatchSize(size = 20) // 每次加载20篇文章的评论
    private List<Comment> comments;
}

@Entity
@BatchSize(size = 50) // 每次加载50个评论的作者
public class Comment {
    @Id
    private Long id;
    
    @ManyToOne
    private User author;
}

// 使用
List<Article> articles = articleRepository.findAll(); // 100篇文章

for (Article article : articles) {
    // 第1次访问：批量加载20篇文章的评论（1条SQL）
    // 第2次访问：批量加载后20篇...（共5条SQL）
    article.getComments().forEach(comment -> {
        // 批量加载评论作者（每50个评论1条SQL）
        comment.getAuthor().getName();
    });
}
```

**性能提升计算**：
```
📊 性能对比：

❌ 无优化：
100篇文章 + 每篇10条评论 = 100 + 1000 = 1100次查询

✅ 使用@BatchSize：
文章查询：1次
评论查询：100/20 = 5次（批量）
作者查询：1000/50 = 20次（批量）
总计：1 + 5 + 20 = 26次查询

⚡ 提升：1100 → 26，性能提升42倍！
```

### 6.4 @BatchSize的最佳实践


```
💡 使用建议：

1️⃣ 批大小选择：
• 小数据集（<100）：size = 10-20
• 中数据集（100-1000）：size = 20-50
• 大数据集（>1000）：size = 50-100

2️⃣ 应用场景：
✅ 适用：循环访问关联对象
✅ 适用：列表页面展示
❌ 不适用：只访问少数对象
❌ 不适用：已经使用FETCH JOIN

3️⃣ 组合使用：
@BatchSize + 二级缓存 = 更好的性能
先批量加载，再缓存复用
```

---

## 7. 📊 性能监控与分析


### 7.1 开启SQL日志


**配置方式**：
```xml
<!-- hibernate.cfg.xml -->
<property name="hibernate.show_sql">true</property>
<property name="hibernate.format_sql">true</property>
<property name="hibernate.use_sql_comments">true</property>
```

**日志示例**：
```sql
/* 显示HQL来源 */
Hibernate: 
    /* SELECT u FROM User u */
    select
        user0_.id as id1_0_,
        user0_.name as name2_0_ 
    from
        user user0_
        
/* 显示参数绑定 */        
binding parameter [1] as [BIGINT] - [123]
```

### 7.2 识别N+1问题的方法


**方法1：查看SQL执行次数**
```
🔍 判断标准：

✅ 正常情况：
执行1-2条SQL完成查询

⚠️ 可疑情况：
执行SQL数量 = 查询结果数量 + 1

❌ N+1问题：
查询10条数据，执行11条SQL
查询100条数据，执行101条SQL
```

**方法2：使用Hibernate Statistics**
```java
SessionFactory sf = ...;
Statistics stats = sf.getStatistics();
stats.setStatisticsEnabled(true);

// 执行业务代码
userService.getAllUsers();

// 查看统计
long queryCount = stats.getQueryExecutionCount();
System.out.println("执行查询次数: " + queryCount);

// 查看详细信息
stats.getEntityStatistics("User").getLoadCount();
```

### 7.3 性能分析工具


**工具1：Hibernate生成的SQL注释**
```java
// 开启后可以在SQL中看到来源
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAll();

// 生成的SQL会显示：
/* SELECT u FROM User u JOIN FETCH u.orders */ 
SELECT ...
```

**工具2：数据库慢查询日志**
```sql
-- MySQL开启慢查询
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1; -- 超过1秒记录

-- 查看慢查询
SHOW VARIABLES LIKE 'slow_query%';
```

**工具3：应用性能监控（APM）**
```
📈 推荐工具：
• Spring Boot Actuator
• P6Spy（SQL性能分析）
• JPA/Hibernate Statistics
• 数据库自带的性能分析工具
```

### 7.4 性能优化检查清单


```
✅ 优化检查清单：

📋 查询阶段：
□ 是否使用了FETCH JOIN？
□ 批量大小是否合理？
□ 是否开启了二级缓存？
□ 查询是否有不必要的关联？

📋 关联配置：
□ 懒加载策略是否合理？
□ @BatchSize是否配置？
□ 是否有循环依赖？

📋 监控分析：
□ SQL日志是否正常？
□ 查询次数是否异常？
□ 响应时间是否达标？

📋 代码层面：
□ 是否在循环中访问关联？
□ DTO投影是否更合适？
□ 是否需要分页？
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 N+1问题本质：
1次主查询 + N次关联查询 = 性能杀手
像打N+1次电话，而不是开一次会

🔸 产生原因：
懒加载（LAZY）+ 循环访问关联对象
= 每次访问触发一次查询

🔸 核心解决方案：
• FETCH JOIN：一次查询获取所有数据
• @BatchSize：批量查询减少次数
• 急加载：特定场景下使用EAGER
```

### 8.2 解决方案选择指南


| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| **固定需要关联数据** | `FETCH JOIN` | 一次查询，最高效 |
| **部分需要关联数据** | `@BatchSize` | 按需批量加载 |
| **多层级关联** | `EntityGraph` | 更灵活的控制 |
| **简单场景** | `EAGER加载` | 配置简单 |
| **复杂业务** | `DTO投影` | 只查需要的字段 |

### 8.3 最佳实践建议


```
💡 记忆口诀：

默认LAZY等按需，
循环访问要当心。
FETCH JOIN一次搞定，
BatchSize批量跟进。
监控日志不能省，
性能优化步步赢。

🎯 实战技巧：

1️⃣ 开发阶段：
• 默认使用LAZY加载
• 开启SQL日志监控
• 及时发现N+1问题

2️⃣ 优化阶段：
• 优先使用FETCH JOIN
• 配置合理的@BatchSize
• 考虑二级缓存

3️⃣ 生产阶段：
• 监控SQL执行次数
• 分析慢查询日志
• 持续性能调优
```

### 8.4 常见错误与避免


```
❌ 常见错误：

错误1：所有关联都用EAGER
→ 加载大量不需要的数据

错误2：忽略N+1问题
→ 随着数据量增长性能急剧下降

错误3：过度使用FETCH JOIN
→ 产生笛卡尔积，数据膨胀

错误4：不监控SQL执行
→ 问题发现太晚

✅ 正确做法：
• 根据场景选择策略
• 开启SQL日志监控
• 定期性能测试
• 使用合适的批量大小
```

**核心记忆**：
- N+1问题是ORM框架最常见的性能陷阱
- 懒加载便利但易触发N+1，需要主动优化
- FETCH JOIN和@BatchSize是两大利器
- 性能优化要监控先行，数据说话