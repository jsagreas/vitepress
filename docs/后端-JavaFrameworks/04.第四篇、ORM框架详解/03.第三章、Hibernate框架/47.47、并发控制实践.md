---
title: 47、并发控制实践
---
## 📚 目录


1. [并发访问问题](#1-并发访问问题)
2. [数据一致性保证](#2-数据一致性保证)
3. [冲突检测机制](#3-冲突检测机制)
4. [重试机制](#4-重试机制)
5. [并发优化策略](#5-并发优化策略)
6. [性能影响分析](#6-性能影响分析)
7. [核心要点总结](#7-核心要点总结)

---

# 1. 🚦 并发访问问题



## 1.1 什么是并发访问问题



**🔸 通俗理解**

想象一下网上抢票的场景：
```
火车票剩余：1张

用户A：查询 → 看到有1张 → 准备购买
用户B：查询 → 看到有1张 → 准备购买
         ↓
      同时提交订单
         ↓
   结果：超卖了！
```

在数据库操作中也会遇到类似的问题，多个用户或程序**同时访问、修改同一条数据**时，就可能出现数据混乱。

**📋 核心定义**
```
并发访问：多个事务同时对同一数据进行读写操作
问题根源：数据在读取和更新之间的时间差
目标：保证数据的正确性和一致性
```

## 1.2 常见的并发问题类型



### 🔴 **问题1：脏读（Dirty Read）**



**什么是脏读？**
```
时间轴：
事务A: 开始 → 修改账户余额为500 → (未提交)
事务B:              ↓ 读到500 → 使用这个数据
事务A:                      回滚（撤销）→ 余额还是1000
事务B: 基于错误数据500继续操作 ❌
```

**通俗解释**：
- 就像你正在写草稿，还没定稿
- 别人看到了你的草稿就拿去用了
- 结果你把草稿删了改成别的了
- 别人用的就是**错误的、作废的数据**

### 🟡 **问题2：不可重复读（Non-repeatable Read）**



**什么是不可重复读？**
```
时间轴：
事务A: 读取账户余额=1000
                ↓
事务B:        修改余额为500 → 提交
                ↓
事务A: 再次读取余额=500 ❌（前后不一致）
```

**生活例子**：
- 你打开淘宝看到商品价格100元
- 准备付款时刷新一下
- 发现价格变成了200元
- **同一个商品，前后读到的价格不一样**

### 🟠 **问题3：幻读（Phantom Read）**



**什么是幻读？**
```
时间轴：
事务A: 查询订单数量=5条
                ↓
事务B:        新增1条订单 → 提交
                ↓
事务A: 再次查询订单数量=6条 ❌（多了数据）
```

**形象比喻**：
- 就像你在数人头，数了10个人
- 突然有人插队进来了
- 你再数一遍变成11个人了
- **感觉出现了"幻影"数据**

### 🔵 **问题4：更新丢失（Lost Update）**



**什么是更新丢失？**
```
时间轴：
事务A: 读取库存=100 → 减10
事务B: 读取库存=100       → 减20
事务A:                写入90 → 提交
事务B:                          写入80 → 提交

最终结果：80（错误！应该是70）
```

**实际场景**：
- 两个人同时修改Word文档
- 保存时后面的人覆盖了前面的修改
- 前面人的修改就**丢失了**

## 1.3 并发问题对比



| 问题类型 | **核心特征** | **影响** | **生活类比** |
|---------|------------|---------|------------|
| 🔴 **脏读** | `读到未提交的数据` | 数据可能无效 | 看到别人的草稿 |
| 🟡 **不可重复读** | `两次读取结果不同` | 数据前后矛盾 | 刷新后价格变了 |
| 🟠 **幻读** | `记录数量变化` | 统计结果不准 | 数人头时有人插队 |
| 🔵 **更新丢失** | `覆盖别人的修改` | 修改被覆盖 | 协同编辑冲突 |

---

# 2. 🛡️ 数据一致性保证



## 2.1 什么是数据一致性



**🔸 通俗理解**

数据一致性就像银行转账：
```
张三账户：1000元
李四账户：500元

转账100元的过程：
1. 张三 -100 = 900  ✓
2. 李四 +100 = 600  ✓
总金额：900 + 600 = 1500 ✓（不变）

如果不一致会怎样：
1. 张三 -100 = 900  ✓
2. 李四 没加上 = 500  ❌
总金额：900 + 500 = 1400 ❌（钱凭空消失了！）
```

**📋 核心定义**
```
数据一致性：数据符合业务规则，前后逻辑正确
ACID特性中的C：Consistency（一致性）
目标：保证数据库从一个正确状态到另一个正确状态
```

## 2.2 Hibernate中的一致性保证方式



### 🎯 **方式1：乐观锁（Optimistic Locking）**



**什么是乐观锁？**

**生活类比**：
- 就像在图书馆借书
- 你拿书的时候不锁住它
- 还书时检查：如果有人改过就重新借
- **假设大部分时候不会冲突**

**工作原理**：
```
┌─ 乐观锁流程 ─────────────┐
│ 1. 读取数据 + 版本号      │
│ 2. 修改数据              │
│ 3. 提交时检查版本号       │
│ 4. 版本号没变→更新成功    │
│    版本号变了→更新失败    │
└──────────────────────────┘
```

**实体类配置**：
```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private Integer stock;  // 库存
    
    @Version  // 关键：版本号字段
    private Integer version;
}
```

**更新流程**：
```java
// 步骤1: 读取商品（version=1）
Product product = session.get(Product.class, 1L);
// 此时：stock=100, version=1

// 步骤2: 修改库存
product.setStock(90);

// 步骤3: 保存（Hibernate自动检查版本）
session.update(product);
// SQL: UPDATE product SET stock=90, version=2 
//      WHERE id=1 AND version=1

// 如果version已经不是1了，更新失败！
```

### 🔒 **方式2：悲观锁（Pessimistic Locking）**



**什么是悲观锁？**

**生活类比**：
- 就像上厕所
- 进去就把门锁上
- 别人只能等你出来
- **假设一定会有冲突，提前锁住**

**工作原理**：
```
┌─ 悲观锁流程 ─────────────┐
│ 1. 读取数据时加锁         │
│ 2. 锁住了别人不能改       │
│ 3. 修改数据              │
│ 4. 提交时释放锁           │
└──────────────────────────┘
```

**使用示例**：
```java
// 读取时就加锁
Product product = session.get(Product.class, 1L, 
    LockMode.PESSIMISTIC_WRITE);

// SQL: SELECT * FROM product WHERE id=1 FOR UPDATE
// 其他事务必须等待

product.setStock(90);
session.update(product);
// 提交时自动释放锁
```

### 📊 **乐观锁 vs 悲观锁对比**



```
┌─ 选择建议 ────────────────┐
│                          │
│ 读多写少 → 乐观锁         │
│ 冲突少、性能好            │
│                          │
│ 写多读少 → 悲观锁         │
│ 冲突多、保证成功          │
│                          │
└──────────────────────────┘
```

| 特性 | **乐观锁** | **悲观锁** |
|-----|----------|----------|
| 🔑 **加锁时机** | 提交时检查 | 读取时就锁 |
| ⚡ **性能** | 高（无锁等待） | 低（需要等待） |
| ✅ **成功率** | 可能失败需重试 | 一定成功 |
| 🎯 **适用场景** | 读多写少 | 写多冲突多 |

## 2.3 事务隔离级别



**🔸 什么是隔离级别？**

就像酒店房间的隔音效果：
- **READ_UNCOMMITTED**：隔音差，隔壁说话都听得见
- **READ_COMMITTED**：一般隔音，大声才听得见
- **REPEATABLE_READ**：隔音好，基本听不见
- **SERIALIZABLE**：完全隔音，什么都听不见

**隔离级别配置**：
```java
// 设置隔离级别
session.doWork(connection -> {
    connection.setTransactionIsolation(
        Connection.TRANSACTION_READ_COMMITTED
    );
});
```

**隔离级别对比**：

| 隔离级别 | **脏读** | **不可重复读** | **幻读** | **性能** |
|---------|---------|-------------|---------|---------|
| READ_UNCOMMITTED | ❌可能 | ❌可能 | ❌可能 | ⚡最高 |
| READ_COMMITTED | ✅避免 | ❌可能 | ❌可能 | ⚡较高 |
| REPEATABLE_READ | ✅避免 | ✅避免 | ❌可能 | ⚡中等 |
| SERIALIZABLE | ✅避免 | ✅避免 | ✅避免 | ⚡最低 |

**💡 实际选择建议**：
- **大部分系统**：用 `READ_COMMITTED`（MySQL默认）
- **金融系统**：用 `REPEATABLE_READ` 或 `SERIALIZABLE`
- **读多写少**：用 `READ_COMMITTED` + 乐观锁
- **写多冲突多**：用 `REPEATABLE_READ` + 悲观锁

---

# 3. 🔍 冲突检测机制



## 3.1 版本号检测（最常用）



**🔸 工作原理**

就像文档的版本号：
```
版本1: 原始文档
版本2: 小明修改后
版本3: 小红修改后

如果小红基于版本1修改，但小明已经提交了版本2
→ 检测到冲突！小红需要基于版本2重新修改
```

**实现方式**：
```java
@Entity
public class Account {
    @Id
    private Long id;
    private BigDecimal balance;
    
    @Version  // 版本号
    private Integer version;
}
```

**执行过程**：
```
时间线：
1. 读取：balance=1000, version=5
2. 修改：balance=900
3. 更新：UPDATE account SET balance=900, version=6 
         WHERE id=1 AND version=5
         
如果version已经不是5：
→ 影响行数=0
→ 抛出 OptimisticLockException
→ 需要重新读取和修改
```

## 3.2 时间戳检测



**🔸 工作原理**

通过最后修改时间判断：
```java
@Entity
public class Article {
    @Id
    private Long id;
    private String content;
    
    @Version
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModified;  // 用时间戳做版本
}
```

**检测逻辑**：
```
读取时：lastModified = 2025-01-01 10:00:00
更新时：WHERE id=1 AND lastModified='2025-01-01 10:00:00'

如果时间戳变了：
→ 说明有人修改过
→ 更新失败
```

## 3.3 全字段比较检测



**🔸 工作原理**

检查所有字段是否被改过：
```java
@Entity
@OptimisticLocking(type = OptimisticLockType.ALL)  // 检查所有字段
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
}
```

**更新SQL**：
```sql
UPDATE user 
SET name='新名字', email='新邮箱'
WHERE id=1 
  AND name='旧名字'      -- 检查name没变
  AND email='旧邮箱'     -- 检查email没变
```

## 3.4 冲突检测方式对比



```
┌─ 选择建议 ────────────────┐
│                          │
│ 推荐：版本号检测          │
│ • 简单高效               │
│ • 数据库支持好           │
│                          │
│ 备选：时间戳检测          │
│ • 需要精确到毫秒          │
│ • 可能有时区问题          │
│                          │
│ 不推荐：全字段比较        │
│ • SQL复杂                │
│ • 性能差                 │
│                          │
└──────────────────────────┘
```

| 检测方式 | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|------------|
| 🔢 **版本号** | 简单、高效、可靠 | 需要额外字段 | 大部分场景 ⭐⭐⭐⭐⭐ |
| ⏰ **时间戳** | 自动更新 | 时区问题、精度问题 | 需要记录修改时间 |
| 📋 **全字段** | 不需要额外字段 | SQL复杂、性能差 | 字段少的简单表 |

---

# 4. 🔄 重试机制



## 4.1 为什么需要重试



**🔸 并发场景下的失败**

想象抢火车票：
```
第一次尝试：
你：查询 → 有票 → 提交订单 → 失败（被别人抢了）

如果放弃：
→ 你买不到票 ❌

如果重试：
你：重新查询 → 还有票 → 再次提交 → 成功 ✅
```

**常见失败原因**：
- 乐观锁冲突：版本号不匹配
- 唯一约束冲突：重复的数据
- 死锁：两个事务互相等待

## 4.2 简单重试实现



**基础重试代码**：
```java
public void updateWithRetry(Long productId, int quantity) {
    int maxRetries = 3;  // 最多重试3次
    int attempt = 0;
    
    while (attempt < maxRetries) {
        try {
            // 尝试更新
            Session session = sessionFactory.openSession();
            Transaction tx = session.beginTransaction();
            
            Product product = session.get(Product.class, productId);
            product.setStock(product.getStock() - quantity);
            
            session.update(product);
            tx.commit();
            
            return;  // 成功就返回
            
        } catch (OptimisticLockException e) {
            attempt++;
            if (attempt >= maxRetries) {
                throw new RuntimeException("重试失败", e);
            }
            // 等待一小段时间再重试
            Thread.sleep(100);
        }
    }
}
```

## 4.3 指数退避重试



**🔸 什么是指数退避？**

**普通重试**：
```
第1次失败 → 等100ms → 重试
第2次失败 → 等100ms → 重试
第3次失败 → 等100ms → 重试
问题：大家都在同一时间重试，还是冲突
```

**指数退避**：
```
第1次失败 → 等100ms → 重试
第2次失败 → 等200ms → 重试  (翻倍)
第3次失败 → 等400ms → 重试  (翻倍)
好处：错开重试时间，减少冲突
```

**实现代码**：
```java
public void updateWithExponentialBackoff(Long id) {
    int maxRetries = 5;
    long baseDelay = 100;  // 基础延迟100ms
    
    for (int i = 0; i < maxRetries; i++) {
        try {
            // 执行更新
            doUpdate(id);
            return;
            
        } catch (OptimisticLockException e) {
            if (i == maxRetries - 1) {
                throw e;  // 最后一次还失败就抛出
            }
            
            // 计算延迟时间：100ms, 200ms, 400ms, 800ms...
            long delay = baseDelay * (1 << i);  // 2^i倍
            Thread.sleep(delay);
        }
    }
}
```

## 4.4 智能重试策略



**根据异常类型决定是否重试**：
```java
public void smartRetry(Runnable task) {
    int maxRetries = 3;
    
    for (int i = 0; i < maxRetries; i++) {
        try {
            task.run();
            return;
            
        } catch (OptimisticLockException e) {
            // 乐观锁冲突 → 可以重试
            continue;
            
        } catch (ConstraintViolationException e) {
            // 约束违反 → 不应该重试，直接抛出
            throw e;
            
        } catch (Exception e) {
            // 其他异常 → 记录日志后抛出
            log.error("执行失败", e);
            throw e;
        }
    }
}
```

**💡 重试最佳实践**：

```
┌─ 重试策略选择 ────────────┐
│                          │
│ ✅ 应该重试：             │
│ • 乐观锁冲突             │
│ • 临时网络问题           │
│ • 数据库连接超时         │
│                          │
│ ❌ 不应该重试：           │
│ • 数据验证失败           │
│ • 权限不足               │
│ • 业务规则违反           │
│                          │
└──────────────────────────┘
```

---

# 5. ⚡ 并发优化策略



## 5.1 减少锁的粒度



**🔸 什么是锁粒度？**

**粗粒度锁**（整张表）：
```
用户A修改订单1 → 锁整个订单表
用户B修改订单2 → 等待（明明是不同订单）
→ 效率低 ❌
```

**细粒度锁**（单条记录）：
```
用户A修改订单1 → 只锁订单1
用户B修改订单2 → 直接操作（不用等）
→ 效率高 ✅
```

**实现方式**：
```java
// 行级锁（细粒度）
Product product = session.get(Product.class, 1L, 
    LockMode.PESSIMISTIC_WRITE);
// SQL: SELECT * FROM product WHERE id=1 FOR UPDATE

// 只锁这一行，不影响其他商品
```

## 5.2 缩短锁持有时间



**优化前**：
```java
// 长时间持有锁
session.beginTransaction();
Product product = session.get(Product.class, 1L, 
    LockMode.PESSIMISTIC_WRITE);

// 复杂的业务逻辑（耗时）
calculateDiscount(product);
sendNotification(product);
updateInventory(product);

session.getTransaction().commit();  // 锁持有时间太长
```

**优化后**：
```java
// 先完成业务逻辑
Product product = session.get(Product.class, 1L);
calculateDiscount(product);
// ... 其他逻辑

// 最后才加锁更新
session.beginTransaction();
Product lockedProduct = session.get(Product.class, 1L, 
    LockMode.PESSIMISTIC_WRITE);
lockedProduct.setPrice(product.getPrice());
session.getTransaction().commit();  // 锁持有时间短
```

## 5.3 读写分离策略



**🔸 核心思想**

```
读操作（不加锁）→ 从库
              ↓
         并发高、速度快

写操作（需要锁）→ 主库
              ↓
         保证一致性
```

**实现示例**：
```java
// 读操作：不加锁，可以从从库读
@Transactional(readOnly = true)
public Product getProduct(Long id) {
    return session.get(Product.class, id);
}

// 写操作：加锁，必须在主库
@Transactional
public void updateProduct(Long id, BigDecimal price) {
    Product product = session.get(Product.class, id, 
        LockMode.PESSIMISTIC_WRITE);
    product.setPrice(price);
}
```

## 5.4 批量操作优化



**问题场景**：
```java
// 一次更新一条（慢）
for (Long id : productIds) {
    Product p = session.get(Product.class, id);
    p.setStatus("ACTIVE");
    session.update(p);
}
// 1000条数据 → 1000次数据库操作
```

**优化方案**：
```java
// 批量更新（快）
session.createQuery(
    "UPDATE Product p SET p.status = :status WHERE p.id IN :ids"
)
.setParameter("status", "ACTIVE")
.setParameter("ids", productIds)
.executeUpdate();
// 1000条数据 → 1次数据库操作
```

## 5.5 缓存策略



**🔸 二级缓存减少数据库访问**

```
┌─ 缓存流程 ────────────────┐
│                          │
│ 1. 先查缓存              │
│    ↓ 命中               │
│ 2. 直接返回（快）         │
│    ↓ 未命中             │
│ 3. 查数据库              │
│ 4. 放入缓存              │
│                          │
└──────────────────────────┘
```

**配置示例**：
```java
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Product {
    // 热点数据放缓存，减少锁竞争
}
```

## 5.6 并发优化对比



| 优化策略 | **优化效果** | **实现难度** | **适用场景** |
|---------|------------|------------|------------|
| 🎯 **减小锁粒度** | ⭐⭐⭐⭐⭐ | ⭐⭐ | 所有场景 |
| ⏱️ **缩短锁时间** | ⭐⭐⭐⭐ | ⭐⭐⭐ | 复杂业务逻辑 |
| 📚 **读写分离** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 读多写少 |
| 🚀 **批量操作** | ⭐⭐⭐⭐⭐ | ⭐⭐ | 大量数据更新 |
| 💾 **缓存策略** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 热点数据 |

---

# 6. 📊 性能影响分析



## 6.1 不同策略的性能对比



**🔸 测试场景**：1000个并发用户同时下单

```
性能测试结果：

无并发控制：
吞吐量: ████████████ 1200 TPS
正确率: ████░░░░░░░░ 40%  ❌

乐观锁：
吞吐量: ████████░░░░ 800 TPS
正确率: ████████████ 100% ✅

悲观锁：
吞吐量: ████░░░░░░░░ 400 TPS
正确率: ████████████ 100% ✅
```

**性能对比表**：

| 策略 | **吞吐量** | **响应时间** | **资源消耗** | **推荐场景** |
|-----|----------|------------|------------|------------|
| 🚫 **无控制** | 很高 | 很低 | 很低 | ❌ 不推荐 |
| 😊 **乐观锁** | 中等 | 低 | 低 | ✅ 读多写少 |
| 🔒 **悲观锁** | 较低 | 中等 | 高 | ✅ 写多冲突多 |
| 🎯 **分布式锁** | 低 | 高 | 很高 | 分布式系统 |

## 6.2 隔离级别的性能影响



**实际测试数据**：

```
并发性能（1000用户）：

READ_UNCOMMITTED:
响应时间: ██░░░░░░░░░░ 50ms
吞吐量:   ████████████ 1000 TPS

READ_COMMITTED:
响应时间: ████░░░░░░░░ 100ms
吞吐量:   ██████████░░ 800 TPS

REPEATABLE_READ:
响应时间: ██████░░░░░░ 150ms
吞吐量:   ████████░░░░ 600 TPS

SERIALIZABLE:
响应时间: ██████████░░ 300ms
吞吐量:   ████░░░░░░░░ 200 TPS
```

**💡 性能vs一致性权衡**：

```
┌─ 性能权衡建议 ────────────┐
│                          │
│ 高并发Web应用：           │
│ → READ_COMMITTED         │
│ → 乐观锁                 │
│                          │
│ 金融交易系统：            │
│ → REPEATABLE_READ        │
│ → 悲观锁                 │
│                          │
│ 电商秒杀场景：            │
│ → READ_COMMITTED         │
│ → 乐观锁 + 重试          │
│                          │
└──────────────────────────┘
```

## 6.3 性能优化建议



**🎯 优化优先级**：

```
优先级排序：
1️⃣ 选对并发策略（乐观/悲观）
2️⃣ 使用合适的隔离级别
3️⃣ 减小锁的粒度
4️⃣ 缩短锁持有时间
5️⃣ 使用缓存减少竞争
6️⃣ 批量操作代替循环
```

**实际案例对比**：

```
优化前（慢）：
for (Order order : orders) {
    session.lock(order, LockMode.PESSIMISTIC_WRITE);
    order.setStatus("PAID");
}
性能：10 TPS

优化后（快）：
session.createQuery(
    "UPDATE Order o SET o.status = 'PAID' 
     WHERE o.id IN :ids"
).setParameter("ids", orderIds)
 .executeUpdate();
性能：500 TPS（提升50倍！）
```

---

# 7. 📋 核心要点总结



## 7.1 必须掌握的核心概念



```
🔸 并发问题：脏读、不可重复读、幻读、更新丢失
🔸 解决方案：乐观锁（版本号）、悲观锁（行锁）
🔸 隔离级别：READ_COMMITTED（常用）、REPEATABLE_READ（严格）
🔸 冲突检测：版本号检测（推荐）、时间戳、全字段比较
🔸 重试机制：指数退避、智能重试
🔸 性能优化：减小粒度、缩短时间、读写分离、批量操作
```

## 7.2 实际应用指南



**🎯 场景选择建议**：

```
┌─ 电商下单场景 ───────────┐
│ 问题：库存超卖            │
│ 方案：乐观锁 + 重试       │
│ 原因：                   │
│ • 读多写少               │
│ • 允许少量重试           │
│ • 性能要求高             │
└──────────────────────────┘

┌─ 银行转账场景 ───────────┐
│ 问题：金额准确性          │
│ 方案：悲观锁 + SERIALIZABLE│
│ 原因：                   │
│ • 绝对不能出错           │
│ • 写操作频繁             │
│ • 一致性优先             │
└──────────────────────────┘

┌─ 文章阅读量场景 ─────────┐
│ 问题：计数不准确          │
│ 方案：乐观锁 + 异步更新   │
│ 原因：                   │
│ • 允许短暂不一致         │
│ • 并发极高               │
│ • 性能优先               │
└──────────────────────────┘
```

## 7.3 常见错误与解决



| 问题 | **原因** | **解决方案** |
|-----|---------|------------|
| ❌ 频繁死锁 | 加锁顺序不一致 | 统一加锁顺序 |
| ❌ 性能很差 | 锁粒度太大 | 改用行级锁 |
| ❌ 数据不一致 | 隔离级别太低 | 提高隔离级别 |
| ❌ 重试失败 | 没有延迟 | 使用指数退避 |

## 7.4 学习检查清单



**💪 自我检测**：

- [ ] 能说出4种并发问题及其区别
- [ ] 理解乐观锁和悲观锁的使用场景
- [ ] 会配置Hibernate版本号检测
- [ ] 能实现带重试的更新逻辑
- [ ] 知道如何优化并发性能
- [ ] 理解不同隔离级别的影响

## 7.5 核心记忆口诀



```
🧠 记忆要点：

并发控制两把锁：
• 乐观假设少冲突，版本检查再提交
• 悲观提前先加锁，安全但慢要权衡

四种问题要分清：
• 脏读读到未提交
• 不可重复两次变
• 幻读记录数量变
• 更新丢失被覆盖

性能优化记心间：
• 粒度要小时间短
• 读写分离用缓存
• 批量操作效率高
```

## 7.6 下一步学习建议



**🚀 进阶方向**：
1. **分布式锁**：Redis实现、Zookeeper方案
2. **MVCC机制**：多版本并发控制原理
3. **性能调优**：慢查询分析、索引优化
4. **高并发架构**：限流、降级、熔断策略

**📚 推荐实践**：
- 实现一个简单的秒杀系统
- 对比测试不同并发策略的性能
- 分析线上并发问题的解决方案