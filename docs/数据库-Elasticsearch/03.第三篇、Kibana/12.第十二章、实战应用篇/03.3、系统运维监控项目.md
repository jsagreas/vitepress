---
title: 3、系统运维监控项目
---
## 📚 目录


1. [系统运维监控概述](#1-系统运维监控概述)
2. [服务器性能监控](#2-服务器性能监控)
3. [应用性能监控APM](#3-应用性能监控APM)
4. [数据库监控指标](#4-数据库监控指标)
5. [网络流量分析](#5-网络流量分析)
6. [容器与微服务监控](#6-容器与微服务监控)
7. [安全事件监控](#7-安全事件监控)
8. [故障预警与容量规划](#8-故障预警与容量规划)
9. [核心要点总结](#9-核心要点总结)

---

# 1. 🎯 系统运维监控概述



## 1.1 什么是系统运维监控



**简单理解**：就像给你的电脑装了个"体检仪"，随时监测系统的健康状况

┌─ 运维监控的作用 ────────────────┐
│ **就像医院的监护设备**          │
│ • 实时监测"生命体征"           │
│ • 发现异常及时报警            │
│ • 记录历史数据分析趋势         │
│ • 帮助做出治疗决策            │
└─────────────────────────────────┘

## 1.2 监控的核心价值



**🔍 为什么需要监控？**
```
没有监控的系统 = 开车不看仪表盘
• 不知道油还剩多少（资源使用情况）
• 不知道车速多快（性能指标）
• 不知道引擎温度（系统健康度）
• 出了故障才发现（被动运维）

有了监控的系统 = 智能汽车
• 实时显示各项指标
• 提前预警潜在问题
• 记录行驶数据分析
• 主动维护系统健康
```

## 1.3 Kibana在监控中的角色



**🎨 Kibana = 监控数据的"翻译官"**

原始监控数据 → Kibana可视化 → 易懂的图表和报告

```
数据采集层：    可视化层：      决策层：
Beats采集   →   Kibana展示  →   运维人员
Logstash处理 →   图表分析   →   业务决策
外部工具    →   告警通知   →   优化改进
```

**📊 监控数据类型**

| 数据类型 | **描述** | **Kibana展示方式** | **实际应用** |
|---------|---------|------------------|-------------|
| 🖥️ **系统指标** | `CPU、内存、磁盘使用率` | `线图、仪表盘` | `性能优化` |
| 📊 **应用指标** | `响应时间、错误率、QPS` | `柱状图、热力图` | `应用调优` |
| 📝 **日志数据** | `错误日志、访问日志` | `表格、时间线` | `故障排查` |
| 🔐 **安全数据** | `登录失败、异常访问` | `地图、告警面板` | `安全防护` |

---

# 2. 🖥️ 服务器性能监控



## 2.1 核心性能指标



**💡 服务器性能 = 电脑的"体检指标"**

### 2.1.1 CPU监控



**🧠 CPU就像人的大脑**
```
CPU使用率含义：
• 0-30%：很轻松，就像休息状态
• 30-70%：正常工作，思维活跃
• 70-90%：有点累了，需要关注
• 90%以上：过度劳累，可能宕机
```

**📈 Kibana CPU监控配置**
```json
{
  "query": {
    "range": {
      "@timestamp": {
        "gte": "now-1h"
      }
    }
  },
  "aggs": {
    "cpu_usage": {
      "avg": {
        "field": "system.cpu.user.pct"
      }
    }
  }
}
```

### 2.1.2 内存监控



**🧠 内存像是工作桌面**
```
内存使用情况：
• 桌面干净（内存充足）→ 工作效率高
• 桌面凌乱（内存紧张）→ 找东西慢
• 桌面爆满（内存不足）→ 无法工作
```

**📊 创建内存监控面板**

1. **选择可视化类型**：Line chart（线图）
2. **配置数据源**：`metricbeat-*`
3. **设置指标**：
   ```
   Y轴：system.memory.used.pct（内存使用率）
   X轴：@timestamp（时间）
   ```
4. **添加阈值线**：80%（警告线）、90%（危险线）

### 2.1.3 磁盘监控



**📁 磁盘像是储物间**
```
磁盘空间管理：
• 储物间空置率 = 磁盘剩余空间
• 东西堆太满 = 系统运行缓慢
• 完全塞满 = 系统无法写入新数据
```

## 2.2 实战：搭建服务器监控面板



### 2.2.1 数据准备



**🔧 配置Metricbeat收集系统指标**
```yaml
# metricbeat.yml 配置示例

metricbeat.config.modules:
  path: ${path.config}/modules.d/*.yml

# 系统模块配置

- module: system
  metricsets:
    - cpu          # CPU使用率
    - memory       # 内存使用率
    - filesystem   # 磁盘使用率
    - network      # 网络流量
  enabled: true
  period: 10s
```

### 2.2.2 创建监控Dashboard



**📊 Dashboard搭建步骤**

```
步骤一：创建新Dashboard
Kibana → Dashboard → Create new dashboard

步骤二：添加CPU监控图表
1. Add panel → Line chart
2. 数据源：metricbeat-*
3. 指标：system.cpu.total.norm.pct
4. 分组：terms aggregation by host.name

步骤三：添加内存监控图表
1. Add panel → Area chart  
2. 指标：system.memory.used.pct
3. 颜色：内存使用率阶梯着色

步骤四：添加磁盘空间监控
1. Add panel → Horizontal bar
2. 指标：system.filesystem.used.pct
3. 分组：by system.filesystem.mount_point
```

**🎨 监控面板布局示例**
```
┌─────────────────────────────────────────────────┐
│                 服务器监控中心                   │
├──────────────────┬──────────────────────────────┤
│   CPU使用率      │        内存使用率             │
│   [折线图]       │        [面积图]              │
├──────────────────┼──────────────────────────────┤
│   磁盘使用率      │        网络流量              │
│   [柱状图]       │        [双轴线图]             │
├──────────────────┴──────────────────────────────┤
│              系统负载趋势分析                    │
│              [多指标组合图]                     │
└─────────────────────────────────────────────────┘
```

## 2.3 性能告警配置



**⚠️ 设置智能告警 = 给系统装个"报警器"**

### 2.3.1 阈值告警规则



| 指标类型 | **正常** | **警告** | **危险** | **处理建议** |
|---------|---------|---------|---------|-------------|
| 🧠 **CPU使用率** | `< 70%` | `70-85%` | `> 85%` | `检查进程，考虑扩容` |
| 🧠 **内存使用率** | `< 80%` | `80-90%` | `> 90%` | `释放内存，增加RAM` |
| 📁 **磁盘使用率** | `< 80%` | `80-90%` | `> 90%` | `清理文件，扩展存储` |
| 🌐 **网络延迟** | `< 50ms` | `50-100ms` | `> 100ms` | `检查网络，优化连接` |

### 2.3.2 Watcher告警配置



```json
{
  "trigger": {
    "schedule": {
      "interval": "1m"
    }
  },
  "input": {
    "search": {
      "request": {
        "search_type": "query_then_fetch",
        "indices": ["metricbeat-*"],
        "body": {
          "query": {
            "bool": {
              "filter": [
                {
                  "range": {
                    "@timestamp": {
                      "gte": "now-2m"
                    }
                  }
                },
                {
                  "range": {
                    "system.cpu.total.norm.pct": {
                      "gte": 0.85
                    }
                  }
                }
              ]
            }
          }
        }
      }
    }
  },
  "condition": {
    "compare": {
      "ctx.payload.hits.total": {
        "gt": 0
      }
    }
  },
  "actions": {
    "send_email": {
      "email": {
        "to": ["admin@company.com"],
        "subject": "服务器CPU使用率过高告警",
        "body": "服务器CPU使用率超过85%，请及时处理！"
      }
    }
  }
}
```

---

# 3. 📱 应用性能监控APM



## 3.1 APM基本概念



**🎯 APM = 应用的"健康体检报告"**

```
传统监控 vs APM监控：

传统监控（看表面）：        APM监控（看内部）：
• 服务器CPU高了           • 哪个代码导致CPU高
• 响应时间慢了            • 哪个函数执行时间长
• 内存不够了              • 哪里发生了内存泄漏
• 数据库查询慢了          • 哪条SQL语句有问题
```

## 3.2 关键性能指标



### 3.2.1 响应时间分析



**⏱️ 响应时间就像餐厅上菜速度**

┌─ 响应时间分解 ─────────────────┐
│ **总响应时间 = 各环节时间总和** │
│ • 网络传输时间（去餐厅路上）    │
│ • 应用处理时间（厨师做菜）      │
│ • 数据库查询时间（采购食材）    │
│ • 第三方接口时间（外卖配送）    │
└───────────────────────────────┘

**📊 创建响应时间分析图表**
```
可视化类型：Histogram（直方图）
数据字段：transaction.duration.us
分组方式：transaction.name
时间范围：Last 24 hours

分析维度：
• P50（中位数）：50%用户的体验
• P95（95分位）：95%用户的体验  
• P99（99分位）：最差用户体验
```

### 3.2.2 错误率监控



**❌ 错误率 = 应用的"故障率"**

错误率计算公式：
```
错误率 = (错误请求数 / 总请求数) × 100%

健康标准：
• 0-0.1%：优秀（几乎无错误）
• 0.1-1%：良好（偶尔有错误）
• 1-5%：一般（需要关注）
• >5%：危险（紧急处理）
```

### 3.2.3 吞吐量监控



**🚗 吞吐量 = 应用的"车流量"**

```
吞吐量含义：
• QPS（每秒查询数）= 每秒通过多少辆车
• TPS（每秒事务数）= 每秒完成多少项业务
• 并发用户数 = 同时在路上的车辆数

监控意义：
• 了解应用负载能力
• 预测扩容需求
• 发现性能瓶颈
```

## 3.3 实战：APM监控面板搭建



### 3.3.1 APM Agent配置



**🔧 Java应用APM配置示例**
```bash
# 下载APM Agent

wget https://oss.sonatype.org/service/local/repositories/releases/content/co/elastic/apm/elastic-apm-agent/1.18.1/elastic-apm-agent-1.18.1.jar

# 启动应用时添加APM参数

java -javaagent:elastic-apm-agent-1.18.1.jar \
     -Delastic.apm.service_name=my-application \
     -Delastic.apm.server_urls=http://localhost:8200 \
     -Delastic.apm.application_packages=com.mycompany \
     -jar my-application.jar
```

### 3.3.2 创建APM Dashboard



**📊 APM面板组件设计**

```
┌─────────────────────────────────────────────────┐
│                 应用性能监控                     │
├─────────────────┬───────────────────────────────┤
│   响应时间趋势   │        错误率变化             │
│   [线图]        │        [面积图]              │
├─────────────────┼───────────────────────────────┤
│   吞吐量统计     │        服务依赖关系           │
│   [柱状图]      │        [网络图]              │
├─────────────────┴───────────────────────────────┤
│              慢查询Top10列表                    │
│              [数据表格]                        │
└─────────────────────────────────────────────────┘
```

**🎨 面板配置步骤**

1. **响应时间趋势图**
   ```
   可视化：Line chart
   索引：apm-*
   Y轴：transaction.duration.us (平均值)
   X轴：@timestamp
   分组：transaction.name (条件)
   ```

2. **错误率统计**
   ```
   可视化：Area chart
   索引：apm-*
   指标：错误事务数/总事务数
   筛选：processor.event: "error"
   ```

3. **服务地图**
   ```
   使用Kibana内置APM服务地图
   APM → Service Map
   显示服务间调用关系和性能指标
   ```

## 3.4 性能优化指导



**🚀 基于APM数据的优化策略**

### 3.4.1 响应时间优化



**📈 发现问题的步骤**
```
步骤1：识别慢接口
• 查看P95响应时间 > 500ms的接口
• 分析这些接口的调用频率
• 优先优化高频慢接口

步骤2：分析慢的原因
• 数据库查询慢？→ 添加索引，优化SQL
• 外部接口慢？→ 增加超时和重试机制
• 代码逻辑慢？→ 优化算法，减少循环

步骤3：验证优化效果
• 部署优化后的代码
• 对比优化前后的APM数据
• 确认响应时间是否改善
```

### 3.4.2 错误处理优化



**❌ 常见错误类型和处理**

| 错误类型 | **原因分析** | **解决方案** | **预防措施** |
|---------|-------------|-------------|-------------|
| 🔌 **连接超时** | `网络不稳定或服务过载` | `增加重试机制，优化连接池` | `监控网络质量，负载均衡` |
| 💾 **内存溢出** | `内存泄漏或数据量过大` | `代码优化，增加内存` | `内存使用监控，定期重启` |
| 🗃️ **数据库错误** | `SQL语法错误或锁等待` | `优化SQL，添加索引` | `代码review，压力测试` |
| 🔐 **权限错误** | `认证失败或权限不足` | `检查权限配置` | `权限管理，定期审计` |

---

# 4. 🗃️ 数据库监控指标



## 4.1 数据库性能核心指标



**🎯 数据库 = 应用的"仓库管理系统"**

### 4.1.1 连接数监控



**🔗 数据库连接就像仓库的"门"**

```
连接数含义：
• 活跃连接 = 正在工作的人数
• 空闲连接 = 待命的工作人员
• 最大连接 = 仓库容纳的最大人数

连接数过多的问题：
• 仓库太拥挤 → 工作效率下降
• 新人进不来 → 业务无法处理
• 资源消耗大 → 服务器压力增加
```

**📊 MySQL连接数监控配置**
```json
{
  "query": {
    "match": {
      "metricset.name": "status"
    }
  },
  "aggs": {
    "max_connections": {
      "max": {
        "field": "mysql.status.max_connections"
      }
    },
    "current_connections": {
      "avg": {
        "field": "mysql.status.threads_connected"
      }
    }
  }
}
```

### 4.1.2 查询性能监控



**⚡ 查询性能 = 仓库的"找货速度"**

重要性能指标：
```
查询时间（Query Time）：
• < 100ms：很快，用户无感知
• 100ms-1s：一般，可以接受
• 1s-5s：较慢，用户开始不耐烦
• > 5s：很慢，用户可能离开

慢查询（Slow Query）：
• 定义：执行时间超过阈值的SQL
• 危害：占用资源，影响其他查询
• 优化：添加索引，重写SQL
```

### 4.1.3 锁等待监控



**🔒 数据库锁 = 仓库的"使用权"**

┌─ 锁的生活类比 ───────────────┐
│ **就像图书馆借书**          │
│ • 有人在看书 = 加了锁       │
│ • 其他人要等 = 锁等待       │
│ • 看完放回 = 释放锁         │
│ • 等太久了 = 锁超时         │
└────────────────────────────┘

## 4.2 实战：数据库监控面板



### 4.2.1 数据采集配置



**🔧 配置Metricbeat采集MySQL指标**
```yaml
# modules.d/mysql.yml

- module: mysql
  metricsets:
    - status        # 状态信息
    - performance   # 性能指标
  enabled: true
  period: 10s
  hosts: ["root:password@tcp(localhost:3306)/"]
  
#  # 采集的关键指标
  queries:
    - query: "SHOW GLOBAL STATUS LIKE 'Threads_connected'"
    - query: "SHOW GLOBAL STATUS LIKE 'Slow_queries'"
    - query: "SHOW PROCESSLIST"
```

### 4.2.2 创建数据库监控Dashboard



**📊 面板设计思路**

```
数据库监控面板布局：

┌─────────────────────────────────────────┐
│              数据库监控中心              │
├──────────────────┬──────────────────────┤
│   连接数趋势      │     查询QPS趋势      │
│   [线图]         │     [面积图]         │
├──────────────────┼──────────────────────┤
│   慢查询统计      │     锁等待监控       │
│   [柱状图]       │     [热力图]         │
├──────────────────┴──────────────────────┤
│             TOP慢查询详情               │
│             [数据表格]                  │
└─────────────────────────────────────────┘
```

**🎨 具体配置示例**

1. **连接数监控**
   ```
   可视化类型：Gauge（仪表盘）
   数据源：metricbeat-*
   指标：mysql.status.threads_connected
   最大值：mysql.status.max_connections
   颜色阈值：绿色(0-70%)、黄色(70-85%)、红色(85-100%)
   ```

2. **慢查询Top10**
   ```
   可视化类型：Data table
   数据源：mysql-slow-*
   字段：query_time, sql_text, timestamp
   排序：按query_time降序
   条目数：10
   ```

## 4.3 数据库性能优化



### 4.3.1 基于监控数据的优化



**🚀 优化决策流程**

```
性能问题诊断流程：

1. 发现问题指标
   ↓
2. 定位具体原因  
   ↓
3. 制定优化方案
   ↓
4. 实施优化措施
   ↓
5. 验证优化效果
```

**📈 常见优化场景**

| 问题现象 | **可能原因** | **优化方案** | **监控验证** |
|---------|-------------|-------------|-------------|
| 🐌 **查询变慢** | `缺少索引，表数据量大` | `添加索引，分表分库` | `查询时间下降` |
| 🔌 **连接数满** | `连接池配置不当` | `优化连接池，代码优化` | `连接数稳定` |
| 🔒 **锁等待多** | `事务时间长，并发冲突` | `缩短事务，优化锁粒度` | `锁等待时间减少` |
| 💾 **内存不足** | `缓存命中率低` | `调整缓存参数` | `内存使用率稳定` |

---

# 5. 🌐 网络流量分析



## 5.1 网络监控基础



**🌍 网络流量 = 数据的"高速公路"**

### 5.1.1 核心网络指标



```
网络性能指标解释：

带宽（Bandwidth）：
• 就像高速公路的车道数
• 车道越多，通行能力越强
• 单位：Mbps、Gbps

延迟（Latency）：  
• 就像从A地到B地的时间
• 距离近延迟低，距离远延迟高
• 单位：毫秒(ms)

丢包率（Packet Loss）：
• 就像快递的丢失率
• 丢包越多，数据传输越不可靠
• 单位：百分比(%)
```

### 5.1.2 网络流量分类



**📊 按流量类型分类**

| 流量类型 | **特征** | **监控重点** | **优化策略** |
|---------|---------|-------------|-------------|
| 🌐 **Web流量** | `HTTP/HTTPS请求` | `响应时间，错误率` | `CDN加速，缓存优化` |
| 📊 **API流量** | `RESTful接口调用` | `QPS，成功率` | `限流，负载均衡` |
| 🗃️ **数据库流量** | `SQL查询请求` | `连接数，查询时间` | `连接池，SQL优化` |
| 📁 **文件传输** | `上传下载操作` | `传输速度，完成率` | `带宽升级，压缩` |

## 5.2 实战：网络流量监控



### 5.2.1 网络数据采集



**🔧 配置Packetbeat采集网络数据**
```yaml
# packetbeat.yml 配置

packetbeat.interfaces.device: eth0

# 监控的协议和端口

packetbeat.protocols:
  http:
    ports: [80, 8080, 8000, 5000, 8002]
    send_headers: true
    send_all_headers: true
    
  mysql:
    ports: [3306]
    
  redis:
    ports: [6379]
    
  dns:
    ports: [53]
```

### 5.2.2 网络流量分析面板



**📊 网络流量Dashboard设计**

```
网络流量分析面板：

┌─────────────────────────────────────────┐
│              网络流量分析               │
├──────────────────┬──────────────────────┤
│   实时流量趋势    │     协议分布饼图     │
│   [线图]         │     [饼图]           │
├──────────────────┼──────────────────────┤
│   响应时间分析    │     错误状态码       │
│   [直方图]       │     [柱状图]         │
├──────────────────┴──────────────────────┤
│             Top访问URL列表              │
│             [数据表格]                  │
└─────────────────────────────────────────┘
```

### 5.2.3 网络安全分析



**🔐 基于流量的安全监控**

异常流量模式识别：
```
可疑流量特征：

DDoS攻击：
• 短时间内大量请求
• 来源IP集中或分散
• 响应状态码异常

SQL注入：
• URL参数包含SQL关键字
• 数据库错误信息增多
• 响应时间异常

恶意爬虫：
• 请求频率异常高
• User-Agent异常
• 忽略robots.txt
```

**⚠️ 安全告警配置**
```json
{
  "trigger": {
    "schedule": {
      "interval": "1m"
    }
  },
  "input": {
    "search": {
      "request": {
        "indices": ["packetbeat-*"],
        "body": {
          "query": {
            "bool": {
              "filter": [
                {
                  "range": {
                    "@timestamp": {
                      "gte": "now-1m"
                    }
                  }
                },
                {
                  "terms": {
                    "http.response.status_code": [400, 401, 403, 500]
                  }
                }
              ]
            }
          },
          "aggs": {
            "error_count": {
              "cardinality": {
                "field": "source.ip"
              }
            }
          }
        }
      }
    }
  },
  "condition": {
    "compare": {
      "ctx.payload.aggregations.error_count.value": {
        "gt": 100
      }
    }
  }
}
```

---

# 6. 🐳 容器与微服务监控



## 6.1 容器监控基础



**🐳 容器 = 应用的"标准化货箱"**

### 6.1.1 容器VS传统部署



```
传统部署 vs 容器部署：

传统部署（一房一户）：         容器部署（公寓楼）：
• 一台服务器一个应用          • 一台服务器多个容器
• 资源利用率低              • 资源利用率高  
• 部署环境差异大            • 环境标准化
• 扩展困难                 • 快速弹性扩展
```

### 6.1.2 容器监控指标



**📊 容器关键性能指标**

| 指标类别 | **监控项目** | **正常范围** | **异常表现** |
|---------|-------------|-------------|-------------|
| 🧠 **CPU** | `容器CPU使用率` | `< 80%` | `持续高CPU，响应慢` |
| 🧠 **内存** | `容器内存使用率` | `< 85%` | `内存泄漏，OOM重启` |
| 📊 **网络** | `网络IO速率` | `正常波动` | `网络拥堵，连接超时` |
| 📁 **存储** | `磁盘IO速率` | `正常读写` | `IO等待，存储瓶颈` |

## 6.2 微服务链路追踪



**🔗 微服务调用 = 接力赛跑**

### 6.2.1 分布式追踪概念



```
单体应用 vs 微服务调用：

单体应用（百米跑）：          微服务（接力赛）：
用户请求 → 应用处理 → 返回结果   用户请求 → 服务A → 服务B → 服务C → 返回结果
       ↑                              ↑
    一个人完成                    多个人协作完成

追踪的作用：
• 记录每一棒的时间（各服务响应时间）
• 找出最慢的一棒（性能瓶颈）
• 分析交棒是否顺利（服务间调用）
```

### 6.2.2 Trace数据结构



**🧩 Trace数据组成**

```
完整的用户请求追踪：

Trace（完整链路）
├── Span（服务A）
│   ├── duration: 100ms
│   └── operation: user-login
├── Span（服务B）  
│   ├── duration: 50ms
│   └── operation: check-auth
└── Span（服务C）
    ├── duration: 200ms
    └── operation: query-database
    
总响应时间：350ms
最慢环节：服务C (数据库查询)
```

## 6.3 实战：容器监控配置



### 6.3.1 Docker监控配置



**🔧 配置Metricbeat监控Docker**
```yaml
# modules.d/docker.yml

- module: docker
  metricsets:
    - container    # 容器基本信息
    - cpu          # CPU使用情况
    - diskio       # 磁盘IO
    - memory       # 内存使用情况
    - network      # 网络流量
  hosts: ["unix:///var/run/docker.sock"]
  period: 10s
```

### 6.3.2 Kubernetes监控



**☸️ K8s集群监控配置**
```yaml
# kubernetes集群监控

- module: kubernetes
  metricsets:
    - node         # 节点状态
    - pod          # Pod状态
    - container    # 容器状态
    - volume       # 存储卷
  period: 10s
  host: ${NODE_NAME}
  hosts: ["https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"]
```

### 6.3.3 容器监控Dashboard



**📊 容器监控面板设计**

```
Container监控Dashboard：

┌─────────────────────────────────────────┐
│              容器集群监控               │
├──────────────────┬──────────────────────┤
│   节点资源概览    │     Pod状态分布      │
│   [仪表盘组]     │     [饼图]           │
├──────────────────┼──────────────────────┤
│   容器CPU/内存    │     网络流量趋势     │
│   [热力图]       │     [面积图]         │
├──────────────────┴──────────────────────┤
│             问题容器Top10               │
│             [数据表格]                  │
└─────────────────────────────────────────┘
```

## 6.4 微服务性能优化



### 6.4.1 基于APM的微服务优化



**🚀 微服务性能优化策略**

```
优化决策树：

发现性能问题
├── 单个服务慢？
│   ├── 代码逻辑优化
│   ├── 数据库查询优化
│   └── 缓存策略优化
├── 服务间调用慢？
│   ├── 网络延迟优化
│   ├── 负载均衡调整
│   └── 服务合并考虑
└── 整体链路慢？
    ├── 异步处理
    ├── 并行调用
    └── 缓存前置
```

### 6.4.2 容量规划



**📈 基于监控数据的容量规划**

| 监控指标 | **扩容触发条件** | **扩容策略** | **监控验证** |
|---------|----------------|-------------|-------------|
| 🧠 **CPU使用率** | `平均>70%，持续5分钟` | `水平扩展Pod数量` | `CPU使用率下降` |
| 🧠 **内存使用率** | `平均>80%，持续3分钟` | `垂直扩展内存限制` | `内存使用率稳定` |
| 📊 **请求QPS** | `超过历史峰值80%` | `预防性扩容` | `响应时间稳定` |
| ⏱️ **响应时间** | `P95>500ms` | `检查瓶颈服务优先扩容` | `响应时间改善` |

---

# 7. 🔐 安全事件监控



## 7.1 安全监控概述



**🛡️ 安全监控 = 系统的"安保系统"**

### 7.1.1 安全威胁分类



```
网络安全威胁类型：

外部攻击（坏人从外面闯入）：
• DDoS攻击 → 门口堵车，正常客人进不来
• SQL注入 → 通过合法入口，做非法事情
• XSS攻击 → 在网站植入恶意代码
• 暴力破解 → 不断尝试密码

内部威胁（内部人员问题）：
• 权限滥用 → 员工越权访问
• 数据泄露 → 内部人员窃取数据
• 误操作 → 无意中造成安全问题
```

### 7.1.2 安全日志来源



**📝 安全相关日志类型**

| 日志来源 | **记录内容** | **安全价值** | **分析重点** |
|---------|-------------|-------------|-------------|
| 🌐 **Web服务器** | `访问请求，错误信息` | `发现攻击尝试` | `异常请求模式` |
| 🔑 **认证系统** | `登录尝试，权限验证` | `发现入侵行为` | `失败登录分析` |
| 🔥 **防火墙** | `网络连接，阻断记录` | `网络安全边界` | `异常连接源` |
| 💾 **数据库** | `查询语句，权限操作` | `数据访问监控` | `SQL注入检测` |

## 7.2 实战：安全监控面板



### 7.2.1 安全日志数据准备



**🔧 配置安全日志收集**
```yaml
# filebeat配置收集安全日志

filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /var/log/nginx/access.log      # Web访问日志
    - /var/log/auth.log              # 系统认证日志
    - /var/log/secure                # 安全相关日志
  
#  # 字段解析
  processors:
    - grok:
        patterns:
          access_log: '%{COMBINEDAPACHELOG}'
          auth_log: '%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:host} %{PROG:program}: %{GREEDYDATA:message}'
```

### 7.2.2 创建安全监控Dashboard



**🔐 安全监控面板设计**

```
安全监控Dashboard：

┌─────────────────────────────────────────┐
│              安全监控中心               │
├──────────────────┬──────────────────────┤
│   攻击尝试趋势    │     攻击来源地图     │
│   [线图]         │     [世界地图]       │
├──────────────────┼──────────────────────┤
│   登录失败统计    │     异常IP Top10     │
│   [柱状图]       │     [数据表格]       │
├──────────────────┴──────────────────────┤
│             安全事件详情列表            │
│             [时间线视图]                │
└─────────────────────────────────────────┘
```

### 7.2.3 攻击检测规则



**⚠️ 常见攻击模式检测**

```json
# SQL注入攻击检测

{
  "query": {
    "bool": {
      "should": [
        {
          "wildcard": {
            "request": "*union select*"
          }
        },
        {
          "wildcard": {
            "request": "*' or '1'='1*"
          }
        },
        {
          "wildcard": {
            "request": "*drop table*"
          }
        }
      ],
      "minimum_should_match": 1
    }
  }
}
```

```json
# 暴力破解检测  

{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "@timestamp": {
              "gte": "now-5m"
            }
          }
        },
        {
          "term": {
            "response_code": 401
          }
        }
      ]
    }
  },
  "aggs": {
    "failed_attempts": {
      "terms": {
        "field": "client_ip",
        "size": 10
      }
    }
  }
}
```

## 7.3 安全告警配置



### 7.3.1 实时安全告警



**🚨 安全事件告警规则**

告警级别定义：
```
安全告警级别：

🔴 紧急（Critical）：
• 正在进行的攻击
• 系统被入侵
• 数据泄露风险
→ 立即处理，电话通知

🟡 高危（High）：
• 攻击尝试增多
• 异常登录行为
• 权限违规操作
→ 15分钟内处理

🟦 中等（Medium）：
• 可疑活动
• 配置异常
• 性能异常
→ 1小时内关注

🟢 低危（Low）：
• 信息收集
• 轻微异常
→ 记录备案
```

### 7.3.2 安全响应流程



**🛡️ 安全事件响应SOP**

```
安全事件响应流程：

1. 事件发现
   ├── 自动化监控告警
   ├── 人工巡检发现
   └── 外部通报

2. 初步评估
   ├── 威胁等级判定
   ├── 影响范围分析
   └── 紧急程度评估

3. 应急响应
   ├── 高危：立即隔离
   ├── 中危：加强监控
   └── 低危：记录跟踪

4. 深入分析
   ├── 攻击手法分析
   ├── 损失评估
   └── 证据保全

5. 处置恢复
   ├── 堵塞漏洞
   ├── 系统恢复
   └── 加固防护

6. 总结改进
   ├── 事件总结
   ├── 流程优化
   └── 预防措施
```

---

# 8. ⚠️ 故障预警与容量规划



## 8.1 故障预警系统



**🔮 故障预警 = 系统的"天气预报"**

### 8.1.1 预警的价值



```
被动运维 vs 主动预警：

被动运维（救火模式）：
故障发生 → 用户投诉 → 紧急修复 → 业务损失

主动预警（预防模式）：
监控发现 → 趋势分析 → 提前处理 → 避免故障

预警的好处：
• 减少业务中断时间
• 降低故障处理成本
• 提升用户体验
• 增强系统稳定性
```

### 8.1.2 预警指标体系



**📊 构建预警指标矩阵**

| 指标类型 | **预警阈值** | **预警时机** | **处理建议** |
|---------|-------------|-------------|-------------|
| 🧠 **CPU使用率** | `> 75%持续10分钟` | `性能下降前` | `检查进程，考虑扩容` |
| 🧠 **内存使用率** | `> 85%持续5分钟` | `OOM发生前` | `释放内存，增加容量` |
| 📁 **磁盘使用率** | `> 85%` | `空间不足前` | `清理文件，扩展存储` |
| ⏱️ **响应时间** | `P95 > 1秒` | `用户体验变差前` | `性能优化，服务扩容` |
| ❌ **错误率** | `> 1%` | `大量错误前` | `检查代码，修复bug` |

## 8.2 智能告警策略



### 8.2.1 避免告警疲劳



**🔕 告警疲劳问题**

```
告警疲劳现象：
• 告警太多 → 重要的被忽略
• 告警太频繁 → 运维人员麻木
• 误报太多 → 失去信任
• 信息不明确 → 不知道怎么处理

解决策略：
• 分级告警：重要的优先通知
• 智能聚合：相关告警合并
• 动态阈值：根据历史数据调整
• 告警抑制：避免重复通知
```

### 8.2.2 动态阈值设置



**📈 基于历史数据的智能阈值**

```json
{
  "trigger": {
    "schedule": {
      "interval": "5m"
    }
  },
  "input": {
    "search": {
      "request": {
        "body": {
          "query": {
            "range": {
              "@timestamp": {
                "gte": "now-7d"
              }
            }
          },
          "aggs": {
            "cpu_stats": {
              "percentiles": {
                "field": "system.cpu.user.pct",
                "percents": [75, 90, 95]
              }
            }
          }
        }
      }
    }
  },
  "condition": {
    "script": {
      "source": "ctx.payload.aggregations.cpu_stats.values['95.0'] > 0.85"
    }
  }
}
```

## 8.3 容量规划



### 8.3.1 容量规划方法论



**📊 容量规划三步法**

```
第一步：现状分析
• 收集当前资源使用数据
• 分析业务增长趋势  
• 识别性能瓶颈点

第二步：需求预测
• 基于历史数据预测
• 考虑业务发展计划
• 加入季节性因素

第三步：方案制定
• 制定扩容时间表
• 评估成本效益
• 准备实施方案
```

### 8.3.2 实战：容量分析Dashboard



**📊 容量规划分析面板**

```
容量规划Dashboard：

┌─────────────────────────────────────────┐
│              容量规划分析               │
├──────────────────┬──────────────────────┤
│   资源使用趋势    │     增长率预测       │
│   [线图]         │     [预测图]         │
├──────────────────┼──────────────────────┤
│   瓶颈分析       │     扩容建议         │
│   [雷达图]       │     [表格]           │
├──────────────────┴──────────────────────┤
│             资源使用效率分析            │
│             [热力图]                    │
└─────────────────────────────────────────┘
```

### 8.3.3 成本优化建议



**💰 基于监控数据的成本优化**

```
成本优化策略：

资源利用率优化：
• 识别低利用率服务器
• 合并部署减少浪费
• 使用容器提高密度

按需扩缩容：
• 业务低峰期缩容
• 突发流量自动扩容
• 定时任务资源调度

云资源优化：
• 选择合适的实例类型
• 使用预留实例降低成本
• 利用Spot实例处理批量任务

监控驱动决策：
• 基于实际使用数据
• 避免过度配置
• 持续优化调整
```

---

# 9. 📋 核心要点总结



## 9.1 必须掌握的核心概念



```
🔸 系统监控本质：通过数据了解系统健康状况，提前发现和解决问题
🔸 Kibana监控价值：将复杂的监控数据转化为直观的图表和告警
🔸 监控数据类型：系统指标、应用性能、安全事件、业务数据
🔸 预警与响应：建立完整的监控→告警→响应→优化闭环
🔸 持续改进：基于监控数据持续优化系统性能和稳定性
```

## 9.2 关键理解要点



**🔹 监控不是目的，是手段**
```
监控的最终目标：
• 保证业务稳定运行
• 提升用户体验
• 降低运维成本
• 支撑业务决策

避免为了监控而监控：
• 关注业务价值，不是技术炫耀
• 重点监控核心指标
• 告警要可执行，不是信息轰炸
```

**🔹 数据驱动的运维决策**
```
传统运维 vs 数据驱动运维：

传统运维（经验驱动）：
• 凭感觉判断系统状态
• 出问题再想办法
• 优化方案拍脑袋决定

数据驱动运维：  
• 用数据说话，客观判断
• 提前预测，主动处理
• 基于监控数据优化
```

**🔹 监控系统的演进**
```
监控系统成熟度：

Level 1（基础监控）：
• 监控服务器基本指标
• 简单阈值告警
• 人工查看处理

Level 2（智能监控）：
• 应用性能深度监控
• 动态阈值和智能告警
• 自动化响应处理

Level 3（预测监控）：
• 基于AI的故障预测
• 自动容量规划
• 智能运维决策
```

## 9.3 实际应用指导



**🎯 监控项目实施路线图**
```
第一阶段：基础设施监控（1-2周）
• 部署Beats采集基础指标
• 创建系统性能监控面板
• 配置基本告警规则

第二阶段：应用性能监控（2-3周）
• 集成APM监控应用性能
• 建立数据库监控体系
• 完善告警通知机制

第三阶段：安全与业务监控（2-4周）
• 部署安全事件监控
• 建立业务指标监控
• 优化告警策略

第四阶段：智能化运维（持续）
• 实施智能告警
• 容量规划自动化
• 持续优化改进
```

**🔧 监控最佳实践**
```
技术实践：
• 选择合适的采集工具
• 设计清晰的Dashboard
• 建立分层告警体系
• 定期评估监控效果

管理实践：
• 明确监控目标和SLA
• 建立标准化流程
• 定期培训和演练
• 持续优化和改进

团队协作：
• 开发团队提供监控接口
• 运维团队负责监控部署
• 业务团队参与指标定义
• 安全团队关注安全监控
```

## 9.4 学习成长建议



**📚 深入学习路径**
```
技术深度：
• 深入理解Elasticsearch查询语法
• 掌握Kibana高级可视化技巧
• 学习监控数据分析方法
• 了解相关开源监控工具

业务理解：
• 理解业务流程和关键指标
• 学习SRE和DevOps理念
• 掌握故障处理和应急响应
• 培养数据分析和决策能力

综合能力：
• 提升问题分析和解决能力
• 加强跨团队沟通协作
• 培养持续学习和创新思维
• 关注行业发展和技术趋势
```

**🚀 职业发展方向**
- **运维工程师**：专注系统稳定性和监控体系建设
- **SRE工程师**：结合开发和运维，关注服务可靠性
- **DevOps工程师**：推动开发运维一体化
- **数据分析师**：专注监控数据分析和业务洞察
- **架构师**：从监控角度设计更好的系统架构

**核心记忆**：
- 监控是保障业务稳定的眼睛和大脑
- Kibana让复杂数据变成直观洞察
- 预警比救火更有价值
- 数据驱动比经验判断更可靠
- 持续优化是监控系统的生命力