---
title: 3、运行时字段与脚本字段
---
## 📚 目录

1. [什么是运行时字段](#1-什么是运行时字段)
2. [脚本字段基础概念](#2-脚本字段基础概念)
3. [Painless脚本语言入门](#3-Painless脚本语言入门)
4. [运行时字段创建与配置](#4-运行时字段创建与配置)
5. [脚本字段创建与配置](#5-脚本字段创建与配置)
6. [字段计算与数据转换](#6-字段计算与数据转换)
7. [两种字段类型对比](#7-两种字段类型对比)
8. [实际应用场景](#8-实际应用场景)
9. [性能优化建议](#9-性能优化建议)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🚀 什么是运行时字段


### 1.1 运行时字段的本质理解


**简单来说**：运行时字段就像是一个"虚拟字段"，它不会真正存储在Elasticsearch索引中，而是在你查询数据的时候才临时计算出来。

```
传统字段 vs 运行时字段：

传统字段（存储字段）：
原始数据 → 写入索引时处理 → 存储到磁盘 → 查询时直接读取

运行时字段（计算字段）：
原始数据 → 存储到磁盘 → 查询时临时计算 → 返回结果
```

**核心优势**：
- ✅ **节省存储空间**：不占用磁盘空间
- ✅ **灵活修改**：可以随时修改计算逻辑
- ✅ **无需重建索引**：修改后立即生效
- ✅ **试验友好**：适合数据探索和分析

### 1.2 运行时字段的工作原理


```
数据流程图：
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│  原始文档    │───▶│  运行时脚本  │───▶│  计算结果    │
│  存储在ES中  │    │  动态执行    │    │  返回给用户  │
└──────────────┘    └──────────────┘    └──────────────┘

举个例子：
原始数据：{price: 100, tax_rate: 0.1}
运行时字段：total_price = price * (1 + tax_rate)
查询结果：total_price = 110
```

**关键理解**：运行时字段就像Excel中的公式，每次打开表格时都会重新计算。

### 1.3 使用场景举例


> 💡 **生活化理解**：想象你有一个商品数据表，里面有商品价格和税率，但你想看含税总价。传统方式是提前算好存起来，运行时字段是每次查看时现算。

**典型应用**：
- **价格计算**：根据基础价格和折扣计算最终价格
- **时间处理**：从时间戳提取小时、星期等信息
- **字符串处理**：从邮箱地址提取域名部分
- **数据分类**：根据数值范围给数据打标签

---

## 2. 📝 脚本字段基础概念


### 2.1 什么是脚本字段


**通俗解释**：脚本字段是Kibana中的一个老功能，它和运行时字段很相似，都是通过脚本来计算新的字段值。可以把它理解为运行时字段的"前辈"。

```
脚本字段的特点：
┌─────────────────────────────────────┐
│  脚本字段 (Scripted Field)          │
├─────────────────────────────────────┤
│  • 在Kibana的Index Pattern中定义   │
│  • 只在Kibana中可见                 │
│  • 使用Painless脚本语言             │
│  • 查询时实时计算                   │
│  • 主要用于可视化和仪表板           │
└─────────────────────────────────────┘
```

### 2.2 脚本字段的工作方式


**简单理解**：脚本字段就像给数据加了一个"计算器"，每当你在Kibana中查看数据时，这个计算器就会自动工作。

```
工作流程：
用户在Kibana中查询数据
    ↓
Kibana发现有脚本字段
    ↓
执行Painless脚本代码
    ↓
计算出新的字段值
    ↓
显示在Kibana界面中
```

### 2.3 适用场景分析


**最适合的情况**：
- 📊 **数据可视化**：在图表中显示计算后的值
- 🔍 **数据探索**：快速尝试不同的数据处理方式
- 📈 **临时分析**：不需要永久保存的一次性计算

**不太适合的情况**：
- ⚠️ **大量数据查询**：性能可能较慢
- ⚠️ **复杂计算**：脚本过于复杂会影响性能
- ⚠️ **频繁使用**：建议考虑转为存储字段

---

## 3. 🔧 Painless脚本语言入门


### 3.1 Painless语言简介


**什么是Painless**：这是Elasticsearch专门设计的脚本语言，名字的意思是"无痛的"，表示它简单易学、安全可靠。

**语言特点**：
- ✅ **语法简单**：类似Java，但更简洁
- ✅ **安全可靠**：防止无限循环和内存泄漏
- ✅ **性能较好**：专为Elasticsearch优化
- ✅ **类型安全**：自动处理数据类型转换

### 3.2 基本语法要点


**变量和数据类型**：
```javascript
// 字符串
String name = "张三";
// 数字
int age = 25;
// 小数
double price = 99.99;
// 布尔值
boolean isActive = true;
```

**常用操作符**：
```javascript
// 数学运算
int total = 10 + 5 * 2;  // 结果：20
// 字符串拼接
String fullName = "姓名：" + name;
// 比较运算
boolean isAdult = age >= 18;
// 逻辑运算
boolean canBuy = isActive && age >= 18;
```

### 3.3 访问文档字段


**核心语法**：在Painless中，使用 `doc['字段名'].value` 来获取字段值

```javascript
// 获取单个值字段
doc['age'].value          // 获取年龄
doc['price'].value        // 获取价格
doc['name'].value         // 获取名称

// 获取数组字段的第一个值
doc['tags'].value         // 获取标签数组的第一个元素

// 安全访问（防止字段不存在报错）
if (doc['price'].size() > 0) {
    return doc['price'].value;
} else {
    return 0;
}
```

### 3.4 常用函数和方法


**字符串处理**：
```javascript
// 转换为大写
doc['name'].value.toUpperCase()
// 转换为小写  
doc['name'].value.toLowerCase()
// 获取长度
doc['name'].value.length()
// 字符串包含判断
doc['email'].value.contains('@gmail.com')
```

**数学计算**：
```javascript
// 绝对值
Math.abs(doc['temperature'].value)
// 四舍五入
Math.round(doc['price'].value)
// 最大值、最小值
Math.max(doc['score1'].value, doc['score2'].value)
```

**时间处理**：
```javascript
// 获取时间戳的小时部分
doc['@timestamp'].value.getHour()
// 获取星期几（1=周一，7=周日）
doc['@timestamp'].value.getDayOfWeek()
// 获取月份
doc['@timestamp'].value.getMonthOfYear()
```

---

## 4. ⚙️ 运行时字段创建与配置


### 4.1 在Kibana中创建运行时字段


**操作步骤**：

```
步骤流程：
Stack Management → Index Patterns → 选择索引模式 → Runtime Fields → Add field

具体操作路径：
1. 打开Kibana主界面
2. 点击左侧菜单的"Stack Management"
3. 在"Kibana"部分点击"Index Patterns"
4. 选择你要添加字段的索引模式
5. 点击"Runtime Fields"标签页
6. 点击"Add field"按钮
```

### 4.2 配置运行时字段


**基本配置项**：

| 配置项 | 说明 | 示例 |
|--------|------|------|
| **Name** | 字段名称 | `total_price` |
| **Type** | 数据类型 | `double`、`keyword`、`date` |
| **Script** | 计算脚本 | `doc['price'].value * 1.1` |

**数据类型选择**：
- `keyword`：文本字符串（如：用户名、分类）
- `long`：整数（如：数量、ID）
- `double`：小数（如：价格、比率）
- `date`：日期时间
- `boolean`：布尔值（true/false）

### 4.3 实际创建示例


**示例1：计算含税价格**
```javascript
// 字段名：total_price
// 类型：double
// 脚本：
if (doc['price'].size() > 0 && doc['tax_rate'].size() > 0) {
    emit(doc['price'].value * (1 + doc['tax_rate'].value));
} else {
    emit(0);
}
```

**示例2：提取邮箱域名**
```javascript
// 字段名：email_domain
// 类型：keyword
// 脚本：
if (doc['email'].size() > 0) {
    String email = doc['email'].value;
    int atIndex = email.indexOf('@');
    if (atIndex > 0) {
        emit(email.substring(atIndex + 1));
    } else {
        emit('invalid');
    }
} else {
    emit('unknown');
}
```

> 💡 **重要提示**：运行时字段使用 `emit()` 函数来输出结果，这是与脚本字段的一个重要区别。

### 4.4 运行时字段的优势特点


**与传统字段对比**：

```
传统存储字段 vs 运行时字段：

存储字段：
┌─────────────┐  写入时处理  ┌─────────────┐
│  原始数据   │ ──────────▶ │  处理后存储 │
└─────────────┘             └─────────────┘
优点：查询快速    缺点：占用存储，难修改

运行时字段：
┌─────────────┐  查询时处理  ┌─────────────┐
│  原始数据   │ ──────────▶ │  临时计算   │
└─────────────┘             └─────────────┘
优点：灵活修改，节省空间    缺点：查询时计算
```

---

## 5. 📊 脚本字段创建与配置


### 5.1 在Kibana中创建脚本字段


**操作路径**：
```
导航路径：
Stack Management → Index Patterns → 选择索引 → Scripted Fields → Add scripted field

详细步骤：
1. 进入Stack Management
2. 选择Index Patterns
3. 点击要编辑的索引模式
4. 切换到"Scripted Fields"标签
5. 点击"Add scripted field"
```

### 5.2 脚本字段配置详解


**主要配置项**：

| 配置项 | 必填 | 说明 | 示例 |
|--------|------|------|------|
| **Name** | ✅ | 字段显示名称 | `用户年龄段` |
| **Language** | ✅ | 脚本语言（选Painless） | `painless` |
| **Type** | ✅ | 返回值类型 | `string`、`number`、`date` |
| **Format** | ❌ | 显示格式 | 数字格式、日期格式等 |
| **Script** | ✅ | 具体脚本代码 | 计算逻辑 |

### 5.3 脚本字段示例详解


**示例1：年龄段分类**
```javascript
// 目标：根据年龄将用户分为不同年龄段
// 字段名：age_group
// 类型：string

int age = doc['age'].value;
if (age < 18) {
    return "青少年";
} else if (age < 35) {
    return "青年";
} else if (age < 60) {
    return "中年";
} else {
    return "老年";
}
```

**示例2：订单状态中文显示**
```javascript
// 目标：将英文状态转换为中文显示
// 字段名：status_cn
// 类型：string

String status = doc['status'].value;
if (status == 'pending') {
    return '待处理';
} else if (status == 'completed') {
    return '已完成';
} else if (status == 'cancelled') {
    return '已取消';
} else {
    return '未知状态';
}
```

**示例3：计算订单折扣率**
```javascript
// 目标：计算实际折扣百分比
// 字段名：discount_percentage
// 类型：number
// 格式：Percentage

if (doc['original_price'].value > 0) {
    double original = doc['original_price'].value;
    double current = doc['current_price'].value;
    return (original - current) / original * 100;
} else {
    return 0;
}
```

### 5.4 脚本字段调试技巧


**常见问题及解决**：

> ⚠️ **字段不存在错误**：
```javascript
// 错误写法（字段可能不存在）
return doc['some_field'].value;

// 正确写法（安全检查）
if (doc['some_field'].size() > 0) {
    return doc['some_field'].value;
} else {
    return "默认值";
}
```

> 🔧 **调试技巧**：
- 先写简单脚本测试基本功能
- 使用Kibana的Dev Tools测试脚本
- 添加日志输出帮助调试（生产环境要删除）

---

## 6. 🔄 字段计算与数据转换


### 6.1 数值计算常用模式


**基础数学运算**：
```javascript
// 价格计算（含税价格）
doc['price'].value * (1 + doc['tax_rate'].value)

// 平均值计算
(doc['score1'].value + doc['score2'].value + doc['score3'].value) / 3

// 百分比计算
doc['completed_tasks'].value / doc['total_tasks'].value * 100

// 增长率计算
(doc['current_value'].value - doc['previous_value'].value) / doc['previous_value'].value * 100
```

**条件计算**：
```javascript
// 分段计算（如：阶梯价格）
double amount = doc['purchase_amount'].value;
if (amount < 100) {
    return amount * 0.95;  // 95折
} else if (amount < 500) {
    return amount * 0.9;   // 9折
} else {
    return amount * 0.85;  // 85折
}
```

### 6.2 字符串处理技巧


**文本提取和拼接**：
```javascript
// 提取文件扩展名
String filename = doc['filename'].value;
int dotIndex = filename.lastIndexOf('.');
if (dotIndex > 0) {
    return filename.substring(dotIndex + 1);
} else {
    return 'unknown';
}

// 生成显示名称
return doc['first_name'].value + " " + doc['last_name'].value;

// URL域名提取
String url = doc['url'].value;
if (url.startsWith('http://')) {
    url = url.substring(7);
} else if (url.startsWith('https://')) {
    url = url.substring(8);
}
int slashIndex = url.indexOf('/');
return slashIndex > 0 ? url.substring(0, slashIndex) : url;
```

### 6.3 时间数据处理


**时间字段常用操作**：
```javascript
// 提取小时（24小时制）
doc['@timestamp'].value.getHour()

// 判断工作日还是周末
int dayOfWeek = doc['@timestamp'].value.getDayOfWeek();
return (dayOfWeek >= 1 && dayOfWeek <= 5) ? "工作日" : "周末";

// 计算时间差（小时）
long currentTime = System.currentTimeMillis();
long recordTime = doc['@timestamp'].value.getMillis();
return (currentTime - recordTime) / (1000 * 60 * 60);

// 时间段分类
int hour = doc['@timestamp'].value.getHour();
if (hour >= 6 && hour < 12) {
    return "上午";
} else if (hour >= 12 && hour < 18) {
    return "下午";
} else if (hour >= 18 && hour < 22) {
    return "晚上";
} else {
    return "深夜";
}
```

### 6.4 数据清洗和标准化


**数据质量处理**：
```javascript
// 邮箱格式验证
String email = doc['email'].value;
if (email.contains('@') && email.contains('.')) {
    return "有效邮箱";
} else {
    return "无效邮箱";
}

// 手机号码格式化
String phone = doc['phone'].value;
// 移除所有非数字字符
phone = phone.replaceAll('[^0-9]', '');
if (phone.length() == 11) {
    return phone.substring(0, 3) + "****" + phone.substring(7);
} else {
    return "格式错误";
}

// 数值范围标准化
double score = doc['score'].value;
if (score >= 90) return "优秀";
else if (score >= 80) return "良好";
else if (score >= 70) return "中等";
else if (score >= 60) return "及格";
else return "不及格";
```

---

## 7. ⚖️ 两种字段类型对比


### 7.1 功能特性对比


| 特性 | **运行时字段 (Runtime Fields)** | **脚本字段 (Scripted Fields)** |
|------|--------------------------------|--------------------------------|
| **存储位置** | 🔹 Elasticsearch索引级别 | 🔸 Kibana索引模式级别 |
| **可见范围** | ✅ 所有连接到ES的应用 | ❌ 仅在Kibana中可见 |
| **创建方式** | API、Kibana、索引模板 | 仅通过Kibana界面 |
| **版本要求** | Elasticsearch 7.11+ | 所有版本支持 |
| **性能** | 🚀 相对较好 | ⚠️ 查询时计算开销大 |
| **脚本语法** | 使用 `emit()` 输出 | 直接 `return` 返回 |

### 7.2 使用场景选择指南


**选择运行时字段的情况**：
- ✅ **新项目**：使用Elasticsearch 7.11以上版本
- ✅ **多客户端**：需要在不同应用中使用同一字段
- ✅ **性能要求**：对查询性能有一定要求
- ✅ **API集成**：需要通过API访问计算字段

**选择脚本字段的情况**：
- ✅ **老版本ES**：使用较老的Elasticsearch版本
- ✅ **仅Kibana使用**：字段只在Kibana中需要
- ✅ **快速原型**：临时测试和数据探索
- ✅ **简单计算**：计算逻辑相对简单

### 7.3 迁移建议


**从脚本字段迁移到运行时字段**：

```javascript
// 脚本字段的写法
if (doc['price'].size() > 0) {
    return doc['price'].value * 1.1;
} else {
    return 0;
}

// 运行时字段的写法（注意使用emit）
if (doc['price'].size() > 0) {
    emit(doc['price'].value * 1.1);
} else {
    emit(0);
}
```

> 💡 **迁移要点**：主要区别是运行时字段用 `emit()` 而不是 `return`

---

## 8. 🎯 实际应用场景


### 8.1 电商数据分析场景


**业务需求**：电商网站需要分析订单数据，包括价格计算、用户分类等

**应用示例**：

```javascript
// 1. 计算订单实际收入（扣除退款）
// 字段名：actual_revenue
if (doc['order_amount'].size() > 0 && doc['refund_amount'].size() > 0) {
    emit(doc['order_amount'].value - doc['refund_amount'].value);
} else {
    emit(doc['order_amount'].value);
}

// 2. 用户价值分级
// 字段名：customer_level
double totalSpent = doc['total_purchase'].value;
if (totalSpent >= 10000) {
    emit("VIP客户");
} else if (totalSpent >= 5000) {
    emit("金牌客户");
} else if (totalSpent >= 1000) {
    emit("银牌客户");
} else {
    emit("普通客户");
}

// 3. 商品类别中文化
// 字段名：category_cn
String category = doc['category'].value;
Map categoryMap = [
    'electronics': '电子产品',
    'clothing': '服装',
    'books': '图书',
    'food': '食品'
];
emit(categoryMap.getOrDefault(category, '其他'));
```

### 8.2 日志分析场景


**业务需求**：分析Web服务器日志，提取有用信息进行监控

**应用示例**：

```javascript
// 1. HTTP状态码分类
// 字段名：status_type
int status = doc['response_code'].value;
if (status >= 200 && status < 300) {
    emit("成功");
} else if (status >= 300 && status < 400) {
    emit("重定向");
} else if (status >= 400 && status < 500) {
    emit("客户端错误");
} else if (status >= 500) {
    emit("服务器错误");
} else {
    emit("未知");
}

// 2. 响应时间等级
// 字段名：response_level
double responseTime = doc['response_time'].value;
if (responseTime <= 100) {
    emit("快速");
} else if (responseTime <= 500) {
    emit("正常");
} else if (responseTime <= 2000) {
    emit("较慢");
} else {
    emit("很慢");
}

// 3. 用户设备类型识别
// 字段名：device_type
String userAgent = doc['user_agent'].value.toLowerCase();
if (userAgent.contains('mobile') || userAgent.contains('android') || userAgent.contains('iphone')) {
    emit("移动设备");
} else if (userAgent.contains('tablet') || userAgent.contains('ipad')) {
    emit("平板设备");
} else {
    emit("桌面设备");
}
```

### 8.3 业务指标计算场景


**业务需求**：实时计算关键业务指标，如转化率、留存率等

**应用示例**：

```javascript
// 1. 页面跳出率标识
// 字段名：bounce_indicator
if (doc['page_views'].value == 1 && doc['session_duration'].value < 30) {
    emit("跳出");
} else {
    emit("正常浏览");
}

// 2. 营销活动效果评估
// 字段名：campaign_performance
double conversionRate = doc['conversions'].value / doc['clicks'].value * 100;
if (conversionRate >= 5) {
    emit("优秀");
} else if (conversionRate >= 2) {
    emit("良好");
} else if (conversionRate >= 1) {
    emit("一般");
} else {
    emit("需要优化");
}
```

---

## 9. 🚀 性能优化建议


### 9.1 脚本优化原则


**核心优化要点**：

> 💡 **记住**：脚本字段是查询时实时计算的，每查询一次就计算一次，所以脚本效率直接影响查询速度。

**优化策略**：

```javascript
// ❌ 低效写法：重复访问字段
double price = doc['price'].value;
double tax = doc['tax_rate'].value;
if (price > 100) {
    return price * tax;
} else {
    return price * (tax + 0.05);
}

// ✅ 高效写法：缓存字段值
double price = doc['price'].value;
double tax = doc['tax_rate'].value;
double finalTax = price > 100 ? tax : tax + 0.05;
return price * finalTax;
```

### 9.2 避免常见性能陷阱


**性能陷阱及解决方案**：

| 问题类型 | 问题描述 | 解决方案 |
|----------|----------|----------|
| **重复字段访问** | 多次调用`doc['field'].value` | 缓存到变量中 |
| **复杂循环** | 在脚本中使用大量循环 | 简化逻辑或预处理数据 |
| **字符串操作** | 大量字符串拼接和处理 | 使用StringBuilder或简化逻辑 |
| **异常处理** | 不检查字段是否存在 | 添加`.size() > 0`检查 |

**安全访问模式**：
```javascript
// 推荐的安全访问模式
if (doc['field_name'].size() > 0) {
    // 字段存在时的处理逻辑
    return doc['field_name'].value;
} else {
    // 字段不存在时的默认值
    return "默认值";
}
```

### 9.3 何时考虑替代方案


**考虑预处理的情况**：
- 🔴 **大量数据查询**：经常查询几万条以上记录
- 🔴 **复杂计算逻辑**：脚本执行时间超过10ms
- 🔴 **高频使用**：同一个计算字段被频繁使用

**替代方案**：
1. **Ingest Pipeline**：在数据写入时预处理
2. **Index Template**：在索引模板中定义运行时字段
3. **应用层计算**：在应用程序中完成计算后存储

### 9.4 监控和调试


**性能监控指标**：
```
关注的性能指标：
• 查询响应时间
• CPU使用率
• 内存使用情况
• 错误率统计
```

**调试技巧**：
```javascript
// 添加简单的日志输出（仅调试时使用）
if (doc['debug_mode'].value == true) {
    // 调试信息
    return "调试：price=" + doc['price'].value;
}
// 正常业务逻辑
return doc['price'].value * 1.1;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 运行时字段：ES 7.11+的新特性，索引级别的虚拟字段
🔸 脚本字段：Kibana传统功能，索引模式级别的计算字段  
🔸 Painless脚本：ES专用的安全脚本语言，类Java语法
🔸 字段访问：使用doc['字段名'].value获取字段值
🔸 安全编程：必须检查字段存在性，避免运行时错误
🔸 性能考虑：查询时计算，大量数据时需要优化
```

### 10.2 关键理解要点


**🔹 两种字段的本质区别**：
```
运行时字段：
• 存储在Elasticsearch中
• 所有应用都能访问
• 性能相对更好
• 使用emit()输出结果

脚本字段：
• 存储在Kibana中
• 仅Kibana可见
• 适合快速测试
• 使用return返回结果
```

**🔹 使用场景判断**：
```
适合使用的情况：
✅ 数据探索和分析
✅ 临时计算需求
✅ 不想修改原始数据
✅ 灵活的业务逻辑

不适合使用的情况：
❌ 大量数据的频繁查询
❌ 复杂的计算逻辑
❌ 对性能要求极高的场景
```

**🔹 Painless脚本要点**：
```
语法特点：
• 类Java语法，但更简洁
• 强类型检查，防止类型错误
• 安全沙箱，防止恶意代码
• 专为ES优化，性能较好

编程技巧：
• 始终检查字段是否存在
• 缓存重复访问的字段值
• 使用简洁的逻辑表达式
• 避免复杂的循环和递归
```

### 10.3 实际应用价值


- **数据分析**：快速创建分析维度，无需修改原始数据
- **业务指标**：实时计算KPI指标，灵活调整计算逻辑
- **数据清洗**：在查询层面处理数据质量问题
- **用户体验**：在Kibana中提供更友好的数据显示
- **成本控制**：避免存储大量计算字段，节省存储空间

**最佳实践原则**：
- 🎯 **简单优先**：优先选择简单的计算逻辑
- 🔍 **测试充分**：在小数据集上充分测试脚本
- 📊 **监控性能**：关注查询响应时间变化
- 🔄 **适时优化**：根据使用情况调整或替换方案
- 📚 **文档记录**：为复杂脚本添加注释和文档

**核心记忆**：
- 运行时字段是ES的，脚本字段是Kibana的
- 查询时计算，灵活但要考虑性能
- Painless语法简单，但要注意安全访问
- 适合分析探索，不适合高频大量查询