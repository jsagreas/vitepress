---
title: 2、Web服务器日志
---
## 📚 目录

1. [Web服务器日志概述](#1-Web服务器日志概述)
2. [Nginx日志采集配置](#2-Nginx日志采集配置)
3. [Apache日志采集配置](#3-Apache日志采集配置)
4. [日志格式解析技巧](#4-日志格式解析技巧)
5. [字段提取与处理](#5-字段提取与处理)
6. [时间戳与IP处理](#6-时间戳与IP处理)
7. [Kibana可视化展示](#7-Kibana可视化展示)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 Web服务器日志概述


### 1.1 什么是Web服务器日志


**简单理解**：Web服务器日志就像网站的"访客记录本"，记录着每一次用户访问的详细信息。

```
想象一下实体店的访客登记：
- 几点来的？(时间戳)
- 谁来的？(IP地址)  
- 要什么？(请求的页面)
- 给了吗？(状态码)
- 买了多少？(响应大小)

Web服务器日志记录的就是这些！
```

**🔸 核心价值**
```
业务监控：
• 网站访问量统计
• 用户行为分析
• 热门页面识别

安全监控：
• 异常访问检测
• 攻击行为识别
• 恶意IP追踪

性能优化：
• 响应时间分析
• 错误率统计
• 资源使用情况
```

### 1.2 常见Web服务器类型


**🔸 主流Web服务器对比**

| 服务器类型 | **市场占有率** | **日志特点** | **适用场景** |
|-----------|-------------|------------|-------------|
| 🔧 **Nginx** | `约35%` | `高性能，配置灵活` | `高并发网站，反向代理` |
| 🏢 **Apache** | `约25%` | `功能丰富，模块众多` | `企业级应用，复杂配置` |
| ⚡ **IIS** | `约10%` | `Windows生态` | `微软技术栈` |

### 1.3 Web日志的重要性


**💡 为什么要分析Web日志？**
```
实际应用场景：

电商网站：
• 哪个商品页面访问最多？
• 用户从哪个页面离开？
• 购买转化率如何？

新闻网站：
• 热门文章排行
• 用户阅读习惯
• 流量高峰时段

企业门户：
• 员工访问行为
• 系统使用情况
• 安全风险识别
```

---

## 2. 🔧 Nginx日志采集配置


### 2.1 Nginx日志格式理解


**🔸 默认访问日志格式**
```nginx
# Nginx默认日志格式
log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for"';
```

**通俗解释**：这就像填写一张表格，每个`$变量`都是表格中的一个字段。

```
实际日志示例：
192.168.1.100 - - [21/Sep/2025:10:30:45 +0800] "GET /index.html HTTP/1.1" 200 1024 "-" "Mozilla/5.0" "-"

字段含义解析：
192.168.1.100        ← 访客IP地址 ($remote_addr)
-                    ← 用户名 ($remote_user，通常为空)
-                    ← 认证用户 (很少使用)
[21/Sep/2025:10:30:45 +0800]  ← 访问时间 ($time_local)
"GET /index.html HTTP/1.1"    ← 请求内容 ($request)
200                  ← 状态码 ($status)
1024                 ← 响应大小 ($body_bytes_sent)
"-"                  ← 来源页面 ($http_referer)
"Mozilla/5.0"        ← 浏览器信息 ($http_user_agent)
```

### 2.2 Filebeat Nginx模块配置


**🔸 基础模块启用**
```yaml
# filebeat.yml
filebeat.modules:
  - module: nginx
    access:
      enabled: true
      var.paths: ["/var/log/nginx/access.log*"]
    error:
      enabled: true  
      var.paths: ["/var/log/nginx/error.log*"]

# 输出到Elasticsearch
output.elasticsearch:
  hosts: ["localhost:9200"]
  index: "nginx-logs-%{+yyyy.MM.dd}"
```

**💡 配置详解**
```
为什么这样配置？

var.paths: ["/var/log/nginx/access.log*"]
• 使用通配符*可以匹配轮转的日志文件
• 比如：access.log, access.log.1, access.log.2.gz

index: "nginx-logs-%{+yyyy.MM.dd}"
• 按日期创建索引，便于管理
• 例如：nginx-logs-2025.09.21
```

### 2.3 自定义Nginx日志格式


**🔸 增强型日志格式**
```nginx
# 自定义详细日志格式
log_format detailed '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" "$http_x_forwarded_for" '
                   '$request_time $upstream_response_time '
                   '$upstream_addr "$http_host"';

access_log /var/log/nginx/access.log detailed;
```

**对应的Filebeat配置**
```yaml
filebeat.inputs:
  - type: log
    paths: ["/var/log/nginx/access.log"]
    fields:
      logtype: nginx_access
      service: web
    fields_under_root: true
    
    # 自定义解析规则
    processors:
      - dissect:
          tokenizer: '%{client_ip} - %{user} [%{timestamp}] "%{method} %{url} %{http_version}" %{response_code} %{bytes} "%{referrer}" "%{user_agent}" "%{x_forwarded_for}" %{request_time} %{upstream_time} %{upstream_addr} "%{host}"'
          field: "message"
          target_prefix: "nginx"
```

### 2.4 Nginx错误日志处理


**🔸 错误日志示例**
```
2025/09/21 10:30:45 [error] 1234#0: *5678 open() "/var/www/html/favicon.ico" failed (2: No such file or directory), client: 192.168.1.100, server: example.com, request: "GET /favicon.ico HTTP/1.1", host: "example.com"
```

**Filebeat错误日志配置**
```yaml
- type: log
  paths: ["/var/log/nginx/error.log"]
  fields:
    logtype: nginx_error
    service: web
  fields_under_root: true
  
  multiline.pattern: '^\d{4}/\d{2}/\d{2}'
  multiline.negate: true
  multiline.match: after
```

**💡 多行日志处理说明**
```
为什么需要多行处理？

错误日志可能跨多行：
2025/09/21 10:30:45 [error] 1234#0: *5678 connect() failed 
(111: Connection refused) while connecting to upstream,
client: 192.168.1.100, server: example.com

multiline.pattern: '^\d{4}/\d{2}/\d{2}'
• 匹配时间戳开头的行
• 将多行合并为一条完整日志
```

---

## 3. 🏢 Apache日志采集配置


### 3.1 Apache日志格式理解


**🔸 Apache Common Log Format (CLF)**
```apache
# Apache默认日志格式
LogFormat "%h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
```

**格式字段对照表**

| Apache变量 | **含义** | **示例值** | **Nginx对应** |
|-----------|---------|-----------|-------------|
| `%h` | `客户端IP` | `192.168.1.100` | `$remote_addr` |
| `%l` | `远程登录名` | `-` | `-` |
| `%u` | `认证用户` | `-` | `$remote_user` |
| `%t` | `时间戳` | `[21/Sep/2025:10:30:45 +0800]` | `$time_local` |
| `%r` | `请求行` | `GET /index.html HTTP/1.1` | `$request` |
| `%>s` | `状态码` | `200` | `$status` |
| `%O` | `响应字节数` | `1024` | `$body_bytes_sent` |

### 3.2 Filebeat Apache模块配置


**🔸 基础Apache模块设置**
```yaml
filebeat.modules:
  - module: apache
    access:
      enabled: true
      var.paths: ["/var/log/apache2/access.log*"]
      var.pipeline: "filebeat-apache-access-pipeline"
    error:
      enabled: true
      var.paths: ["/var/log/apache2/error.log*"]
```

**🔸 多虚拟主机配置**
```yaml
filebeat.inputs:
  - type: log
    paths: 
      - "/var/log/apache2/site1-access.log"
      - "/var/log/apache2/site2-access.log"
    fields:
      service: apache
      environment: production
    fields_under_root: true
    
    processors:
      - add_host_metadata:
          when.not.contains.tags: forwarded
```

### 3.3 Apache错误日志特殊处理


**🔸 Apache错误日志示例**
```
[Mon Sep 21 10:30:45.123456 2025] [error] [pid 1234] [client 192.168.1.100:54321] File does not exist: /var/www/html/missing.php
```

**多行错误日志配置**
```yaml
- type: log
  paths: ["/var/log/apache2/error.log"]
  fields:
    logtype: apache_error
    service: web
  
  multiline.pattern: '^\[[A-Za-z]{3} [A-Za-z]{3}'
  multiline.negate: true
  multiline.match: after
  
  processors:
    - dissect:
        tokenizer: '[%{timestamp}] [%{level}] [pid %{pid}] [client %{client}] %{message}'
        field: "message"
        target_prefix: "apache"
```

---

## 4. 📊 日志格式解析技巧


### 4.1 使用Dissect处理器


**🔸 什么是Dissect？**

简单理解：Dissect就像一个"模板匹配器"，把一行日志按照模板拆分成各个字段。

```
原始日志：
192.168.1.100 - - [21/Sep/2025:10:30:45] "GET /index.html" 200 1024

Dissect模板：
%{ip} - %{user} [%{timestamp}] "%{method} %{url}" %{status} %{bytes}

结果字段：
ip: 192.168.1.100
user: -
timestamp: 21/Sep/2025:10:30:45
method: GET
url: /index.html
status: 200
bytes: 1024
```

**🔸 Dissect配置示例**
```yaml
processors:
  - dissect:
      tokenizer: '%{nginx.remote_addr} - %{nginx.remote_user} [%{nginx.time_local}] "%{nginx.request}" %{nginx.status} %{nginx.body_bytes_sent} "%{nginx.http_referer}" "%{nginx.http_user_agent}"'
      field: "message"
      target_prefix: ""
```

### 4.2 使用Grok处理器


**🔸 Grok vs Dissect 对比**

```
Dissect（推荐）：
优点：性能高，配置简单
缺点：格式必须固定

Grok：
优点：灵活，支持正则表达式
缺点：性能较低，配置复杂
```

**Grok配置示例**
```yaml
processors:
  - grok:
      patterns_dir: "/etc/filebeat/patterns"
      pattern: '%{NGINXACCESS}'
      field: "message"
```

### 4.3 条件处理器使用


**🔸 根据内容类型分别处理**
```yaml
processors:
  # 处理访问日志
  - dissect:
      when.contains:
        message: "GET"
      tokenizer: '%{ip} - - [%{timestamp}] "%{request}" %{status} %{bytes}'
      field: "message"
      
  # 处理错误日志  
  - dissect:
      when.contains:
        message: "[error]"
      tokenizer: '%{timestamp} [%{level}] %{message}'
      field: "message"
```

---

## 5. 🔍 字段提取与处理


### 5.1 常用字段提取


**🔸 用户代理解析**
```yaml
processors:
  - user_agent:
      field: "nginx.http_user_agent"
      target_field: "user_agent"
      
  # 结果示例：
  # user_agent.name: "Chrome"
  # user_agent.version: "94.0.4606.81"
  # user_agent.os.name: "Windows"
```

**🔸 URL参数提取**
```yaml
processors:
  - urldecode:
      field: "nginx.request_uri"
      target_field: "url.decoded"
      
  - extract_array:
      field: "url.decoded"
      separator: "?"
      mappings:
        url.path: 0
        url.query: 1
```

### 5.2 状态码分类


**🔸 HTTP状态码含义**

```
状态码分类理解：

2xx - 成功：
• 200 OK - 请求成功
• 201 Created - 创建成功
• 204 No Content - 无内容

3xx - 重定向：
• 301 Moved Permanently - 永久重定向
• 302 Found - 临时重定向
• 304 Not Modified - 未修改

4xx - 客户端错误：
• 400 Bad Request - 请求错误
• 401 Unauthorized - 未授权
• 403 Forbidden - 禁止访问
• 404 Not Found - 页面不存在

5xx - 服务器错误：
• 500 Internal Server Error - 服务器内部错误
• 502 Bad Gateway - 网关错误
• 503 Service Unavailable - 服务不可用
```

**状态码分类处理**
```yaml
processors:
  - script:
      lang: javascript
      source: >
        function(event) {
          var status = event.Get("nginx.status");
          if (status >= 200 && status < 300) {
            event.Put("http.status_class", "success");
          } else if (status >= 300 && status < 400) {
            event.Put("http.status_class", "redirect");
          } else if (status >= 400 && status < 500) {
            event.Put("http.status_class", "client_error");
          } else if (status >= 500) {
            event.Put("http.status_class", "server_error");
          }
        }
```

### 5.3 响应时间处理


**🔸 响应时间字段转换**
```yaml
processors:
  # 将字符串转换为数字
  - convert:
      fields:
        - {from: "nginx.request_time", to: "http.response_time", type: "float"}
        - {from: "nginx.body_bytes_sent", to: "http.response_size", type: "long"}
        
  # 添加响应时间分类
  - script:
      lang: javascript
      source: >
        function(event) {
          var time = event.Get("http.response_time");
          if (time < 0.1) {
            event.Put("response_time_category", "fast");
          } else if (time < 1.0) {
            event.Put("response_time_category", "normal");
          } else {
            event.Put("response_time_category", "slow");
          }
        }
```

---

## 6. ⏰ 时间戳与IP处理


### 6.1 时间戳标准化


**🔸 常见时间戳格式**

```
不同Web服务器的时间格式：

Nginx: [21/Sep/2025:10:30:45 +0800]
Apache: [Mon Sep 21 10:30:45.123456 2025]
IIS: 2025-09-21 10:30:45

目标：统一转换为标准ISO 8601格式
结果：2025-09-21T10:30:45.000+08:00
```

**时间戳处理配置**
```yaml
processors:
  # Nginx时间戳处理
  - timestamp:
      field: "nginx.time_local"
      layouts:
        - '02/Jan/2006:15:04:05 -0700'
        - 'dd/MMM/yyyy:HH:mm:ss Z'
      test:
        - '21/Sep/2025:10:30:45 +0800'
        
  # Apache时间戳处理  
  - timestamp:
      field: "apache.timestamp"
      layouts:
        - 'Mon Jan 02 15:04:05.000000 2006'
      test:
        - 'Mon Sep 21 10:30:45.123456 2025'
```

### 6.2 IP地址解析与GeoIP


**🔸 IP地址信息补充**
```yaml
processors:
  # 添加地理位置信息
  - add_geoip:
      field: "nginx.remote_addr"
      target_field: "client"
      
  # 检测内网IP
  - script:
      lang: javascript
      source: >
        function(event) {
          var ip = event.Get("nginx.remote_addr");
          var isPrivate = ip.match(/^10\.|^172\.(1[6-9]|2[0-9]|3[0-1])\.|^192\.168\./);
          event.Put("client.is_private", isPrivate !== null);
        }
```

**🔸 GeoIP处理结果示例**
```json
{
  "client": {
    "ip": "203.208.60.1",
    "is_private": false,
    "geo": {
      "country_name": "China",
      "region_name": "Beijing",
      "city_name": "Beijing",
      "latitude": 39.9075,
      "longitude": 116.3972
    }
  }
}
```

### 6.3 X-Forwarded-For处理


**🔸 代理IP链处理**

当网站使用CDN或负载均衡时，真实客户端IP可能在`X-Forwarded-For`头中：

```
X-Forwarded-For: 客户端真实IP, 代理1IP, 代理2IP

示例：
X-Forwarded-For: 203.208.60.1, 10.0.0.1, 192.168.1.1
```

**处理配置**
```yaml
processors:
  - script:
      lang: javascript
      source: >
        function(event) {
          var xff = event.Get("nginx.http_x_forwarded_for");
          if (xff && xff !== "-") {
            var ips = xff.split(",");
            var realIP = ips[0].trim(); // 第一个IP是真实客户端IP
            event.Put("client.real_ip", realIP);
          }
        }
```

---

## 7. 📈 Kibana可视化展示


### 7.1 基础仪表板创建


**🔸 访问量趋势图**

```
可视化类型：Line Chart (折线图)
配置步骤：

1. 选择索引模式：nginx-logs-*
2. X轴配置：
   - 聚合：Date Histogram
   - 字段：@timestamp  
   - 间隔：Auto

3. Y轴配置：
   - 聚合：Count
   - 标签：访问次数

结果：显示网站访问量随时间的变化趋势
```

**🔸 状态码分布饼图**
```
可视化类型：Pie Chart (饼图)
配置：

桶配置：
- 聚合：Terms
- 字段：nginx.status.keyword
- 大小：10
- 排序：Count (降序)

度量：
- 聚合：Count

结果：显示各种HTTP状态码的占比
```

### 7.2 热门页面排行


**🔸 TOP 10访问页面**
```yaml
# 在Kibana的Dev Tools中创建聚合查询
GET nginx-logs-*/_search
{
  "size": 0,
  "aggs": {
    "top_pages": {
      "terms": {
        "field": "nginx.request_uri.keyword",
        "size": 10,
        "order": { "_count": "desc" }
      }
    }
  }
}
```

**Kibana仪表板配置**
```
可视化类型：Data Table (数据表格)

列配置：
1. 页面URL - nginx.request_uri.keyword
2. 访问次数 - Count
3. 平均响应时间 - Average of nginx.request_time
4. 平均响应大小 - Average of nginx.body_bytes_sent

排序：按访问次数降序
```

### 7.3 错误监控仪表板


**🔸 错误率监控**

```
错误率计算逻辑：
错误率 = (4xx + 5xx状态码数量) / 总请求数 × 100%

Kibana配置：
可视化类型：Gauge (仪表盘)

脚本聚合示例：
{
  "aggs": {
    "error_rate": {
      "bucket_script": {
        "buckets_path": {
          "errors": "error_requests>_count",
          "total": "total_requests>_count"
        },
        "script": "params.errors / params.total * 100"
      }
    }
  }
}
```

**🔸 实时错误告警**

通过Kibana的Watcher功能设置告警：

```json
{
  "trigger": {
    "schedule": {
      "interval": "1m"
    }
  },
  "input": {
    "search": {
      "request": {
        "indices": ["nginx-logs-*"],
        "body": {
          "query": {
            "bool": {
              "filter": [
                {
                  "range": {
                    "@timestamp": {
                      "gte": "now-5m"
                    }
                  }
                },
                {
                  "range": {
                    "nginx.status": {
                      "gte": 500
                    }
                  }
                }
              ]
            }
          }
        }
      }
    }
  },
  "condition": {
    "compare": {
      "ctx.payload.hits.total": {
        "gt": 10
      }
    }
  }
}
```

### 7.4 性能分析仪表板


**🔸 响应时间分布**

```
慢请求识别步骤：

1. 创建响应时间直方图：
   - X轴：nginx.request_time (数值范围)
   - Y轴：文档计数
   - 桶间隔：0.1秒

2. 添加阈值线：
   - 1秒线（标记慢请求）
   - 5秒线（标记超慢请求）

3. 结果解读：
   - 大部分请求应在1秒内
   - 超过1秒的请求需要优化
   - 超过5秒的请求属于严重问题
```

**🔸 带宽使用分析**
```
可视化类型：Area Chart (区域图)

配置：
- X轴：@timestamp (时间)
- Y轴：Sum of nginx.body_bytes_sent (响应大小总和)
- 聚合间隔：5分钟

附加信息：
- 添加平均值线
- 标注峰值时段
- 识别异常流量
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Web日志价值：网站访客记录本，记录用户行为和系统状态
🔸 日志格式理解：每个字段的含义和作用，如IP、时间、状态码等
🔸 Filebeat模块：nginx和apache模块的配置和使用方法
🔸 字段处理：使用dissect、grok等处理器解析日志结构
🔸 时间处理：统一时间戳格式，处理时区差异
🔸 可视化展示：创建有意义的仪表板和告警规则
```

### 8.2 关键配置要点


**🔹 性能优化建议**
```
日志采集优化：
• 使用轮转日志避免单文件过大
• 设置合理的harvester_buffer_size
• 启用压缩减少网络传输

解析优化：
• 优先使用dissect而非grok（性能更好）
• 只解析需要的字段，避免过度处理
• 使用条件处理器减少不必要的计算
```

**🔹 生产环境建议**
```
索引管理：
• 按日期创建索引便于管理
• 设置索引生命周期策略
• 定期清理历史数据

监控告警：
• 设置错误率阈值告警
• 监控日志采集状态
• 关注磁盘空间使用
```

### 8.3 常见问题解决


**💡 问题排查思路**

```
日志没有出现：
1. 检查文件路径是否正确
2. 确认Filebeat有读取权限
3. 查看Filebeat日志输出

字段解析错误：
1. 验证dissect模板是否匹配
2. 检查日志格式是否变更
3. 使用测试工具验证正则表达式

性能问题：
1. 检查处理器配置复杂度
2. 监控CPU和内存使用
3. 考虑分片和负载均衡
```

**🔹 最佳实践总结**
```
配置原则：
• 从简单配置开始，逐步增加复杂功能
• 充分测试配置变更，避免生产环境问题
• 定期备份配置文件

数据治理：
• 建立字段命名规范
• 统一时间戳格式
• 规范化状态码和错误信息

安全考虑：
• 避免记录敏感信息（密码、token等）
• 控制日志访问权限
• 考虑数据脱敏需求
```

### 8.4 学习进阶方向


**📚 后续学习建议**
- **应用日志处理**：Java、Python应用程序日志
- **数据库日志分析**：MySQL、PostgreSQL慢查询日志
- **系统日志监控**：syslog、systemd journal
- **容器日志采集**：Docker、Kubernetes环境
- **日志聚合最佳实践**：大规模集群日志管理

**核心记忆口诀**：
- Web日志如访客登记，记录行为便分析
- Nginx Apache配置清，模块启用路径明  
- 字段解析用dissect，性能优于grok选
- 时间IP要处理好，可视化展示更直观