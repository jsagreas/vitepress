---
title: 3、运维最佳实践
---
## 📚 目录

1. [生产环境规范](#1-生产环境规范)
2. [配置文件管理规范](#2-配置文件管理规范)
3. [日志轮转设置](#3-日志轮转设置)
4. [启动脚本编写](#4-启动脚本编写)
5. [运维自动化策略](#5-运维自动化策略)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🏢 生产环境规范


### 1.1 什么是生产环境规范


**通俗理解**：
想象一下餐厅的厨房，家庭厨房可以随意一些，但餐厅厨房必须有严格的卫生标准、操作流程、食材管理等规范。同样，Filebeat在生产环境中也需要遵循严格的规范，确保稳定可靠运行。

**生产环境规范的核心目标**：
- 🎯 **稳定性**：服务不能随便挂掉
- 🎯 **可维护性**：出问题能快速定位和解决  
- 🎯 **可扩展性**：业务增长时能平滑扩容
- 🎯 **安全性**：数据传输和存储安全

### 1.2 服务器资源配置规范


**🔸 硬件资源标准**
```
推荐配置等级：

轻量级业务（日志量 < 1GB/天）：
• CPU：2核心
• 内存：4GB  
• 磁盘：50GB SSD
• 网络：100Mbps

中等业务（日志量 1-10GB/天）：
• CPU：4核心
• 内存：8GB
• 磁盘：200GB SSD  
• 网络：1Gbps

重型业务（日志量 > 10GB/天）：
• CPU：8核心及以上
• 内存：16GB及以上
• 磁盘：500GB+ SSD
• 网络：10Gbps
```

**💡 资源配置实用建议**
> 💡 **新手指南**  
> 不要一开始就配置过高，从中等配置开始，根据实际使用情况调整。过度配置浪费资源，配置不足影响性能。

### 1.3 目录结构标准化


**🗂️ 标准目录布局**
```
生产环境目录结构：

/opt/filebeat/                    # Filebeat主目录
├── bin/                          # 执行文件
│   └── filebeat
├── config/                       # 配置文件目录
│   ├── filebeat.yml             # 主配置文件
│   ├── modules.d/               # 模块配置
│   └── backup/                  # 配置备份
├── data/                        # 数据目录
│   └── registry/                # 注册表文件
├── logs/                        # 日志目录
│   ├── filebeat.log            # 运行日志
│   └── error.log               # 错误日志
└── scripts/                     # 脚本目录
    ├── start.sh                # 启动脚本
    ├── stop.sh                 # 停止脚本
    └── backup.sh               # 备份脚本
```

**为什么要这样组织目录？**
- **职责分离**：每个目录有明确用途，维护时不会搞混
- **权限管理**：不同目录可以设置不同权限，提高安全性
- **备份方便**：知道哪些目录需要备份，哪些不需要

### 1.4 用户权限管理


**🔐 安全用户配置**

创建专门的filebeat用户：
```bash
# 创建系统用户（不能登录shell）
sudo useradd -r -M -s /bin/false filebeat

# 设置目录权限
sudo chown -R filebeat:filebeat /opt/filebeat
sudo chmod 755 /opt/filebeat
sudo chmod 644 /opt/filebeat/config/filebeat.yml
sudo chmod 700 /opt/filebeat/data
```

**权限设置原则**：
- ✅ **最小权限原则**：只给必需的权限，不多给
- ✅ **读写分离**：配置文件只读，数据目录可写
- ✅ **用户隔离**：使用专门用户，不用root运行

---

## 2. 📁 配置文件管理规范


### 2.1 配置文件版本控制


**为什么需要版本控制？**
想象你在写作业，每次修改都保存一个版本，这样改错了可以回到之前的版本。配置文件也是一样，修改前要备份，修改后要记录变更。

**🔄 版本管理实践**

建立配置仓库：
```bash
# 初始化git仓库管理配置
cd /opt/filebeat/config
git init
echo "备份目录和临时文件" > .gitignore
echo "backup/" >> .gitignore
echo "*.tmp" >> .gitignore

# 提交初始配置
git add filebeat.yml
git commit -m "初始配置文件"
```

**配置修改标准流程**：
1. 📋 **修改前备份**：`cp filebeat.yml filebeat.yml.backup`
2. 📝 **记录修改原因**：在注释中写明为什么修改
3. 🧪 **测试验证**：修改后先测试，确认无误
4. 📦 **提交变更**：`git commit -m "修改内容和原因"`

### 2.2 配置文件注释规范


**📝 良好的注释示例**
```yaml
# =================================================
# Filebeat 配置文件
# 最后修改：2024-09-21
# 修改人：运维团队
# 修改原因：增加nginx日志收集
# =================================================

filebeat.inputs:
# ---- Web服务器日志收集 ----
- type: log
  enabled: true
  paths:
    # nginx访问日志，每日轮转
    - /var/log/nginx/access.log
    # nginx错误日志
    - /var/log/nginx/error.log
  
  # 字段标识，用于区分不同服务的日志
  fields:
    service: nginx
    env: production
    
  # 多行日志合并（处理异常堆栈）
  multiline.pattern: '^\['
  multiline.negate: true
  multiline.match: after
```

**注释编写原则**：
- 🎯 **说明目的**：这个配置是为了解决什么问题
- 🎯 **参数解释**：重要参数的含义和取值范围  
- 🎯 **修改记录**：什么时候、为什么修改
- 🎯 **注意事项**：使用时需要特别注意的地方

### 2.3 环境配置分离


**🌍 多环境管理策略**

什么是环境分离？
就像同一个应用在开发、测试、生产环境中的配置不同，比如数据库地址、日志级别等。Filebeat也需要根据环境使用不同配置。

环境配置目录结构：
```
config/
├── filebeat-dev.yml      # 开发环境配置
├── filebeat-test.yml     # 测试环境配置  
├── filebeat-prod.yml     # 生产环境配置
└── common/               # 通用配置
    ├── inputs.yml        # 输入源配置
    ├── outputs.yml       # 输出配置
    └── processors.yml    # 处理器配置
```

**环境配置差异对比**：

| 配置项 | 开发环境 | 测试环境 | 生产环境 |
|-------|---------|---------|---------|
| **日志级别** | `debug` | `info` | `warning` |
| **ES地址** | `localhost:9200` | `test-es:9200` | `prod-es-cluster` |
| **索引名称** | `dev-logs` | `test-logs` | `prod-logs-{+yyyy.MM.dd}` |
| **监控开启** | `false` | `true` | `true` |
| **资源限制** | 无 | 中等 | 严格 |

---

## 3. 🔄 日志轮转设置


### 3.1 什么是日志轮转


**通俗理解**：
想象你每天写日记，如果都写在一个本子里，时间长了本子会很厚，查找困难。日志轮转就像定期换新本子，把旧日记归档保存，这样既保存了历史记录，又保持当前本子轻便好用。

**日志轮转的作用**：
- 📦 **控制大小**：防止单个日志文件过大影响性能
- 🗄️ **历史保留**：保留一定时间的历史日志供查询
- 💾 **节省空间**：自动清理过期日志，释放磁盘空间
- 🔍 **便于查找**：按时间分割的日志更容易定位问题

### 3.2 Filebeat自身日志轮转


**📋 logrotate配置**

创建Filebeat日志轮转规则：
```bash
# 创建轮转配置文件
sudo nano /etc/logrotate.d/filebeat
```

轮转配置内容：
```bash
# Filebeat日志轮转配置
/opt/filebeat/logs/*.log {
    # 每天轮转一次
    daily
    
    # 保留30天的日志
    rotate 30
    
    # 当日志文件不存在时不报错
    missingok
    
    # 轮转后压缩旧日志
    compress
    
    # 第一次轮转时不压缩（保留当天日志）
    delaycompress
    
    # 不轮转空文件
    notifempty
    
    # 使用日期作为后缀
    dateext
    
    # 轮转后重新加载filebeat（发送HUP信号）
    postrotate
        if [ -f /var/run/filebeat.pid ]; then
            kill -HUP `cat /var/run/filebeat.pid`
        fi
    endscript
}
```

**测试轮转配置**：
```bash
# 测试配置语法
sudo logrotate -d /etc/logrotate.d/filebeat

# 强制执行一次轮转（用于测试）
sudo logrotate -f /etc/logrotate.d/filebeat
```

### 3.3 应用日志轮转配置


**🔧 协调应用与Filebeat**

应用日志轮转需要与Filebeat协调：

nginx日志轮转示例：
```bash
/var/log/nginx/*.log {
    daily
    rotate 52
    compress
    delaycompress
    missingok
    notifempty
    
    # 轮转完成后重新加载nginx
    postrotate
        # 重新加载nginx，生成新日志文件
        /bin/kill -USR1 `cat /run/nginx.pid 2>/dev/null` 2>/dev/null || true
        
        # 通知filebeat重新扫描（可选）
        # systemctl reload filebeat
    endscript
}
```

**轮转时机选择**：
- 🕐 **凌晨执行**：选择业务低峰期，如凌晨2点
- 📊 **基于大小**：大文件及时轮转，小文件按时间轮转
- 🎯 **保留策略**：根据法规要求和查询需求确定保留时间

---

## 4. 🚀 启动脚本编写


### 4.1 系统服务配置


**什么是系统服务？**
系统服务就像给Filebeat安排一个管家，负责启动、停止、重启，还能设置开机自启动，让Filebeat像其他系统服务一样稳定运行。

**📝 systemd服务配置**

创建服务文件：
```bash
sudo nano /etc/systemd/system/filebeat.service
```

服务配置内容：
```ini
[Unit]
# 服务描述信息
Description=Filebeat log shipper
Documentation=https://www.elastic.co/products/beats/filebeat
Wants=network-online.target
After=network-online.target

[Service]
# 运行用户和组
User=filebeat
Group=filebeat

# 服务类型（simple表示主进程不会fork）
Type=simple

# 执行文件和参数
ExecStart=/opt/filebeat/bin/filebeat -c /opt/filebeat/config/filebeat.yml -path.home /opt/filebeat -path.config /opt/filebeat/config -path.data /opt/filebeat/data -path.logs /opt/filebeat/logs

# 重启策略（失败时自动重启）
Restart=always
RestartSec=5

# 资源限制
LimitNOFILE=65536
LimitNPROC=4096

# 工作目录
WorkingDirectory=/opt/filebeat

# 环境变量
Environment="GODEBUG=madvdontneed=1"

# 优雅停止超时时间
TimeoutStopSec=30

[Install]
# 开机启动级别
WantedBy=multi-user.target
```

**服务管理命令**：
```bash
# 重新加载systemd配置
sudo systemctl daemon-reload

# 启动服务
sudo systemctl start filebeat

# 设置开机自启
sudo systemctl enable filebeat

# 查看服务状态
sudo systemctl status filebeat

# 停止服务
sudo systemctl stop filebeat

# 重启服务
sudo systemctl restart filebeat
```

### 4.2 启动脚本编写


**🔧 智能启动脚本**

创建启动脚本：
```bash
#!/bin/bash

# ============================================
# Filebeat 启动脚本
# 功能：启动、停止、重启、状态检查
# ============================================

# 配置变量
FILEBEAT_HOME="/opt/filebeat"
FILEBEAT_BIN="$FILEBEAT_HOME/bin/filebeat"
FILEBEAT_CONFIG="$FILEBEAT_HOME/config/filebeat.yml"
FILEBEAT_PID="/var/run/filebeat.pid"
FILEBEAT_USER="filebeat"

# 检查是否为root用户
check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo "请使用sudo运行此脚本"
        exit 1
    fi
}

# 检查Filebeat是否运行
is_running() {
    if [ -f "$FILEBEAT_PID" ]; then
        local pid=$(cat "$FILEBEAT_PID")
        if ps -p "$pid" > /dev/null 2>&1; then
            return 0
        else
            # PID文件存在但进程不存在，清理PID文件
            rm -f "$FILEBEAT_PID"
            return 1
        fi
    else
        return 1
    fi
}

# 启动Filebeat
start_filebeat() {
    echo "正在启动Filebeat..."
    
    if is_running; then
        echo "Filebeat已经在运行中"
        return 1
    fi
    
    # 检查配置文件
    if [ ! -f "$FILEBEAT_CONFIG" ]; then
        echo "错误：配置文件不存在 $FILEBEAT_CONFIG"
        return 1
    fi
    
    # 测试配置文件
    echo "检查配置文件..."
    sudo -u "$FILEBEAT_USER" "$FILEBEAT_BIN" test config -c "$FILEBEAT_CONFIG"
    if [ $? -ne 0 ]; then
        echo "错误：配置文件有问题"
        return 1
    fi
    
    # 启动服务
    sudo -u "$FILEBEAT_USER" nohup "$FILEBEAT_BIN" \
        -c "$FILEBEAT_CONFIG" \
        -path.home "$FILEBEAT_HOME" \
        -path.config "$FILEBEAT_HOME/config" \
        -path.data "$FILEBEAT_HOME/data" \
        -path.logs "$FILEBEAT_HOME/logs" \
        > /dev/null 2>&1 &
    
    local pid=$!
    echo $pid > "$FILEBEAT_PID"
    
    # 等待启动
    sleep 3
    
    if is_running; then
        echo "Filebeat启动成功，PID: $(cat $FILEBEAT_PID)"
        return 0
    else
        echo "Filebeat启动失败"
        rm -f "$FILEBEAT_PID"
        return 1
    fi
}

# 停止Filebeat
stop_filebeat() {
    echo "正在停止Filebeat..."
    
    if ! is_running; then
        echo "Filebeat没有运行"
        return 1
    fi
    
    local pid=$(cat "$FILEBEAT_PID")
    
    # 发送TERM信号优雅停止
    kill -TERM "$pid"
    
    # 等待进程结束
    local count=0
    while ps -p "$pid" > /dev/null 2>&1; do
        sleep 1
        count=$((count + 1))
        
        # 30秒后强制杀死
        if [ $count -ge 30 ]; then
            echo "优雅停止超时，强制结束进程"
            kill -KILL "$pid"
            break
        fi
    done
    
    rm -f "$FILEBEAT_PID"
    echo "Filebeat已停止"
    return 0
}

# 重启Filebeat
restart_filebeat() {
    stop_filebeat
    sleep 2
    start_filebeat
}

# 检查状态
status_filebeat() {
    if is_running; then
        local pid=$(cat "$FILEBEAT_PID")
        echo "Filebeat正在运行，PID: $pid"
        
        # 显示进程信息
        ps -p "$pid" -o pid,ppid,pcpu,pmem,etime,cmd
        
        return 0
    else
        echo "Filebeat没有运行"
        return 1
    fi
}

# 主函数
main() {
    check_root
    
    case "$1" in
        start)
            start_filebeat
            ;;
        stop)
            stop_filebeat
            ;;
        restart)
            restart_filebeat
            ;;
        status)
            status_filebeat
            ;;
        *)
            echo "用法: $0 {start|stop|restart|status}"
            echo "  start   - 启动Filebeat"
            echo "  stop    - 停止Filebeat"
            echo "  restart - 重启Filebeat"
            echo "  status  - 查看状态"
            exit 1
            ;;
    esac
}

# 执行主函数
main "$@"
```

**使用方法**：
```bash
# 给脚本执行权限
sudo chmod +x /opt/filebeat/scripts/filebeat.sh

# 创建软链接方便使用
sudo ln -s /opt/filebeat/scripts/filebeat.sh /usr/local/bin/filebeat-ctl

# 使用脚本管理服务
sudo filebeat-ctl start    # 启动
sudo filebeat-ctl stop     # 停止
sudo filebeat-ctl restart  # 重启
sudo filebeat-ctl status   # 状态
```

---

## 5. 🤖 运维自动化策略


### 5.1 健康检查自动化


**什么是健康检查？**
就像医生定期体检，我们需要定期检查Filebeat是否健康运行，包括进程状态、资源使用、数据传输等情况。

**📋 健康检查脚本**

```bash
#!/bin/bash

# ============================================
# Filebeat 健康检查脚本
# 功能：检查服务状态、资源使用、日志传输
# ============================================

# 配置
FILEBEAT_PID="/var/run/filebeat.pid"
LOG_FILE="/var/log/filebeat-health.log"
ALERT_EMAIL="ops@company.com"
ES_URL="http://elasticsearch:9200"

# 日志函数
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 发送告警
send_alert() {
    local message="$1"
    log_message "ALERT: $message"
    
    # 发送邮件告警（需要配置sendmail或其他邮件工具）
    echo "$message" | mail -s "Filebeat Alert" "$ALERT_EMAIL" 2>/dev/null || true
    
    # 可以添加其他告警方式，如钉钉、企业微信等
}

# 检查进程状态
check_process() {
    log_message "检查Filebeat进程状态..."
    
    if [ -f "$FILEBEAT_PID" ]; then
        local pid=$(cat "$FILEBEAT_PID")
        if ps -p "$pid" > /dev/null 2>&1; then
            log_message "进程检查：正常运行 (PID: $pid)"
            return 0
        else
            send_alert "Filebeat进程异常：PID文件存在但进程不运行"
            return 1
        fi
    else
        send_alert "Filebeat进程异常：PID文件不存在"
        return 1
    fi
}

# 检查资源使用
check_resources() {
    log_message "检查资源使用情况..."
    
    if [ -f "$FILEBEAT_PID" ]; then
        local pid=$(cat "$FILEBEAT_PID")
        
        # 获取CPU和内存使用率
        local stats=$(ps -p "$pid" -o pcpu,pmem --no-headers 2>/dev/null)
        if [ $? -eq 0 ]; then
            local cpu=$(echo "$stats" | awk '{print $1}')
            local mem=$(echo "$stats" | awk '{print $2}')
            
            log_message "资源使用：CPU ${cpu}%, 内存 ${mem}%"
            
            # 检查资源使用是否异常
            if (( $(echo "$cpu > 80" | bc -l) )); then
                send_alert "CPU使用率过高：${cpu}%"
            fi
            
            if (( $(echo "$mem > 50" | bc -l) )); then
                send_alert "内存使用率过高：${mem}%"
            fi
        else
            send_alert "无法获取资源使用信息"
            return 1
        fi
    fi
}

# 检查磁盘空间
check_disk_space() {
    log_message "检查磁盘空间..."
    
    # 检查数据目录磁盘使用率
    local usage=$(df /opt/filebeat | tail -1 | awk '{print $5}' | sed 's/%//')
    
    log_message "磁盘使用率：${usage}%"
    
    if [ "$usage" -gt 85 ]; then
        send_alert "磁盘空间不足：使用率 ${usage}%"
        return 1
    fi
    
    return 0
}

# 检查ES连接
check_elasticsearch() {
    log_message "检查Elasticsearch连接..."
    
    # 检查ES集群状态
    local es_status=$(curl -s -o /dev/null -w "%{http_code}" "$ES_URL/_cluster/health" 2>/dev/null)
    
    if [ "$es_status" = "200" ]; then
        log_message "Elasticsearch连接：正常"
        return 0
    else
        send_alert "Elasticsearch连接异常：HTTP状态码 $es_status"
        return 1
    fi
}

# 检查日志传输
check_log_shipping() {
    log_message "检查日志传输情况..."
    
    # 检查Filebeat注册表文件的修改时间
    local registry_file="/opt/filebeat/data/registry/filebeat/log.json"
    
    if [ -f "$registry_file" ]; then
        local last_modified=$(stat -c %Y "$registry_file")
        local current_time=$(date +%s)
        local diff=$((current_time - last_modified))
        
        # 如果注册表文件超过10分钟没有更新，可能有问题
        if [ $diff -gt 600 ]; then
            send_alert "日志传输可能异常：注册表文件 ${diff} 秒未更新"
            return 1
        else
            log_message "日志传输：正常 (注册表文件 ${diff} 秒前更新)"
            return 0
        fi
    else
        send_alert "日志传输异常：注册表文件不存在"
        return 1
    fi
}

# 主检查函数
main() {
    log_message "开始Filebeat健康检查"
    
    local exit_code=0
    
    check_process || exit_code=1
    check_resources || exit_code=1
    check_disk_space || exit_code=1
    check_elasticsearch || exit_code=1
    check_log_shipping || exit_code=1
    
    if [ $exit_code -eq 0 ]; then
        log_message "健康检查完成：所有检查项正常"
    else
        log_message "健康检查完成：发现异常，请查看详细信息"
    fi
    
    log_message "----------------------------------------"
    
    exit $exit_code
}

main "$@"
```

### 5.2 自动部署与更新


**🚀 部署自动化脚本**

```bash
#!/bin/bash

# ============================================
# Filebeat 自动部署脚本
# 功能：下载、安装、配置、启动
# ============================================

# 配置变量
FILEBEAT_VERSION="8.10.0"
DOWNLOAD_URL="https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-${FILEBEAT_VERSION}-linux-x86_64.tar.gz"
INSTALL_DIR="/opt/filebeat"
CONFIG_TEMPLATE="/tmp/filebeat-template.yml"
BACKUP_DIR="/opt/filebeat-backup"

# 检查root权限
if [ "$EUID" -ne 0 ]; then
    echo "请使用sudo运行此脚本"
    exit 1
fi

# 创建备份
backup_current() {
    if [ -d "$INSTALL_DIR" ]; then
        echo "备份当前Filebeat..."
        local backup_name="filebeat-backup-$(date +%Y%m%d-%H%M%S)"
        mkdir -p "$BACKUP_DIR"
        cp -r "$INSTALL_DIR" "$BACKUP_DIR/$backup_name"
        echo "备份完成：$BACKUP_DIR/$backup_name"
    fi
}

# 下载Filebeat
download_filebeat() {
    echo "下载Filebeat $FILEBEAT_VERSION..."
    
    local temp_dir="/tmp/filebeat-install"
    mkdir -p "$temp_dir"
    cd "$temp_dir"
    
    # 下载
    wget "$DOWNLOAD_URL" -O "filebeat.tar.gz"
    if [ $? -ne 0 ]; then
        echo "下载失败"
        exit 1
    fi
    
    # 解压
    tar -xzf "filebeat.tar.gz"
    local extracted_dir=$(ls -d filebeat-*/ | head -1)
    
    echo "下载完成：$temp_dir/$extracted_dir"
    echo "$temp_dir/$extracted_dir"
}

# 安装Filebeat
install_filebeat() {
    local source_dir="$1"
    
    echo "安装Filebeat到 $INSTALL_DIR..."
    
    # 停止现有服务
    systemctl stop filebeat 2>/dev/null || true
    
    # 创建安装目录
    mkdir -p "$INSTALL_DIR"
    
    # 复制文件
    cp -r "$source_dir"/* "$INSTALL_DIR/"
    
    # 创建用户
    useradd -r -M -s /bin/false filebeat 2>/dev/null || true
    
    # 设置权限
    chown -R filebeat:filebeat "$INSTALL_DIR"
    chmod 755 "$INSTALL_DIR/bin/filebeat"
    
    echo "安装完成"
}

# 配置Filebeat
configure_filebeat() {
    echo "配置Filebeat..."
    
    # 如果有配置模板，使用模板
    if [ -f "$CONFIG_TEMPLATE" ]; then
        cp "$CONFIG_TEMPLATE" "$INSTALL_DIR/config/filebeat.yml"
    fi
    
    # 设置配置文件权限
    chmod 644 "$INSTALL_DIR/config/filebeat.yml"
    chown filebeat:filebeat "$INSTALL_DIR/config/filebeat.yml"
    
    # 测试配置
    echo "测试配置文件..."
    sudo -u filebeat "$INSTALL_DIR/bin/filebeat" test config -c "$INSTALL_DIR/config/filebeat.yml"
    if [ $? -ne 0 ]; then
        echo "配置文件有错误"
        exit 1
    fi
    
    echo "配置完成"
}

# 创建系统服务
create_service() {
    echo "创建系统服务..."
    
    cat > /etc/systemd/system/filebeat.service << 'EOF'
[Unit]
Description=Filebeat log shipper
Documentation=https://www.elastic.co/products/beats/filebeat
Wants=network-online.target
After=network-online.target

[Service]
User=filebeat
Group=filebeat
Type=simple
ExecStart=/opt/filebeat/bin/filebeat -c /opt/filebeat/config/filebeat.yml -path.home /opt/filebeat -path.config /opt/filebeat/config -path.data /opt/filebeat/data -path.logs /opt/filebeat/logs
Restart=always
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable filebeat
    
    echo "系统服务创建完成"
}

# 启动服务
start_service() {
    echo "启动Filebeat服务..."
    
    systemctl start filebeat
    sleep 3
    
    if systemctl is-active --quiet filebeat; then
        echo "Filebeat启动成功"
        systemctl status filebeat --no-pager
    else
        echo "Filebeat启动失败"
        journalctl -u filebeat --no-pager -n 20
        exit 1
    fi
}

# 主函数
main() {
    echo "开始Filebeat自动部署..."
    echo "版本：$FILEBEAT_VERSION"
    echo "安装目录：$INSTALL_DIR"
    echo "----------------------------------------"
    
    backup_current
    
    local source_dir=$(download_filebeat)
    install_filebeat "$source_dir"
    configure_filebeat
    create_service
    start_service
    
    echo "----------------------------------------"
    echo "Filebeat部署完成！"
    echo "使用以下命令管理服务："
    echo "  systemctl start filebeat    # 启动"
    echo "  systemctl stop filebeat     # 停止"
    echo "  systemctl status filebeat   # 状态"
    echo "  systemctl restart filebeat  # 重启"
}

main "$@"
```

### 5.3 定时任务配置


**⏰ 定时任务crontab配置**

```bash
# 编辑定时任务
sudo crontab -e

# 添加以下定时任务
# ============================================
# Filebeat 运维定时任务
# ============================================

# 每5分钟执行健康检查
*/5 * * * * /opt/filebeat/scripts/health-check.sh

# 每天凌晨2点清理过期日志
0 2 * * * /opt/filebeat/scripts/cleanup-logs.sh

# 每天凌晨3点备份配置文件
0 3 * * * /opt/filebeat/scripts/backup-config.sh

# 每周日凌晨4点生成运行报告
0 4 * * 0 /opt/filebeat/scripts/weekly-report.sh

# 每月1号凌晨5点检查磁盘空间并清理
0 5 1 * * /opt/filebeat/scripts/monthly-cleanup.sh
```

**📊 监控指标收集**

```bash
#!/bin/bash

# ============================================
# Filebeat 指标收集脚本
# 收集运行指标并发送到监控系统
# ============================================

# 收集Filebeat运行指标
collect_metrics() {
    local timestamp=$(date +%s)
    
    # 进程信息
    if [ -f "/var/run/filebeat.pid" ]; then
        local pid=$(cat /var/run/filebeat.pid)
        if ps -p "$pid" > /dev/null 2>&1; then
            # CPU和内存使用率
            local stats=$(ps -p "$pid" -o pcpu,pmem,rss --no-headers)
            local cpu=$(echo "$stats" | awk '{print $1}')
            local mem=$(echo "$stats" | awk '{print $2}')
            local rss=$(echo "$stats" | awk '{print $3}')
            
            # 输出指标（可以发送到监控系统）
            echo "filebeat.cpu.usage $cpu $timestamp"
            echo "filebeat.memory.percent $mem $timestamp"
            echo "filebeat.memory.rss $rss $timestamp"
        fi
    fi
    
    # 磁盘使用情况
    local disk_usage=$(df /opt/filebeat | tail -1 | awk '{print $5}' | sed 's/%//')
    echo "filebeat.disk.usage $disk_usage $timestamp"
    
    # 注册表文件大小
    if [ -f "/opt/filebeat/data/registry/filebeat/log.json" ]; then
        local registry_size=$(stat -c%s "/opt/filebeat/data/registry/filebeat/log.json")
        echo "filebeat.registry.size $registry_size $timestamp"
    fi
}

# 发送指标到监控系统（示例：Graphite）
send_to_graphite() {
    local graphite_host="monitoring.company.com"
    local graphite_port="2003"
    
    collect_metrics | nc "$graphite_host" "$graphite_port"
}

# 主函数
main() {
    send_to_graphite
}

main "$@"
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的运维规范


**🔸 生产环境核心规范**
- ✅ **资源配置**：根据日志量选择合适硬件配置
- ✅ **目录结构**：标准化目录布局，职责分离
- ✅ **用户权限**：最小权限原则，专用用户运行
- ✅ **安全配置**：配置文件权限，网络访问控制

**🔸 配置管理最佳实践**
- ✅ **版本控制**：git管理配置变更历史
- ✅ **环境分离**：开发、测试、生产环境配置分离
- ✅ **注释规范**：清晰的配置说明和修改记录
- ✅ **测试验证**：配置修改前必须测试

**🔸 日志轮转关键点**
- ✅ **轮转策略**：基于时间和大小的轮转规则
- ✅ **保留时间**：根据业务需求确定日志保留期
- ✅ **压缩归档**：节省磁盘空间的压缩策略
- ✅ **协调机制**：应用与Filebeat的轮转协调

### 6.2 自动化运维要点


**🔸 服务管理自动化**
```
systemd服务 + 智能启动脚本 = 稳定服务管理
健康检查 + 自动告警 = 主动运维
自动部署 + 配置模板 = 快速扩容
```

**🔸 监控告警体系**
- 📊 **关键指标**：进程状态、资源使用、连接健康
- ⏰ **检查频率**：健康检查5分钟，资源监控1分钟
- 📧 **告警机制**：邮件、短信、即时通讯多渠道
- 🔄 **自动恢复**：简单故障自动重启恢复

### 6.3 故障处理流程


**🚨 故障处理标准流程**

| 阶段 | 操作内容 | 时间要求 | 责任人 |
|------|---------|---------|-------|
| **发现** | 监控告警、用户反馈 | `实时` | 监控系统 |
| **响应** | 确认故障、初步排查 | `5分钟内` | 值班人员 |
| **处理** | 定位问题、应急处理 | `30分钟内` | 技术团队 |
| **恢复** | 服务恢复、验证正常 | `1小时内` | 运维团队 |
| **总结** | 故障分析、改进措施 | `24小时内` | 技术负责人 |

### 6.4 实用运维技巧


**💡 日常运维小贴士**

<kbd>快速检查</kbd> Filebeat状态：
```bash
# 一键检查脚本
alias fb-check='systemctl status filebeat && sudo filebeat test config'
```

<kbd>日志快速分析</kbd>：
```bash
# 查看最近的错误日志
tail -f /opt/filebeat/logs/filebeat.log | grep -i error

# 统计每小时处理的日志条数
grep "$(date +%Y-%m-%d)" /opt/filebeat/logs/filebeat.log | \
  cut -d'T' -f2 | cut -d':' -f1 | sort | uniq -c
```

<kbd>配置快速备份</kbd>：
```bash
# 修改配置前备份
cp filebeat.yml "filebeat.yml.$(date +%Y%m%d-%H%M%S).backup"
```

### 6.5 进阶运维策略


**🚀 企业级运维实践**

- **🏗️ 基础设施即代码**：用Ansible、Terraform管理配置
- **📊 可观测性建设**：日志、指标、链路追踪三位一体
- **🔄 CI/CD集成**：配置变更自动化测试和部署
- **🛡️ 安全合规**：日志脱敏、访问审计、权限管控
- **📈 容量规划**：基于历史数据预测资源需求

**记忆要点**：
> 💡 **运维金科玉律**  
> 预防胜于治疗，自动化胜于手工，监控胜于经验，文档胜于记忆

**核心原则**：
- 🎯 **标准化**：所有环境使用统一标准
- 🎯 **自动化**：减少人工操作，提高效率
- 🎯 **可观测**：及时发现问题，快速定位
- 🎯 **持续改进**：定期回顾，优化流程