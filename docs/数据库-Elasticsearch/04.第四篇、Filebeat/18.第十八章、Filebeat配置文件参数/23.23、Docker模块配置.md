---
title: 23、Docker模块配置
---
## 📚 目录

1. [Docker模块基础概念](#1-Docker模块基础概念)
2. [容器日志收集配置](#2-容器日志收集配置)
3. [JSON日志处理](#3-JSON日志处理)
4. [多行日志合并](#4-多行日志合并)
5. [高级配置技巧](#5-高级配置技巧)
6. [实战配置示例](#6-实战配置示例)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🐳 Docker模块基础概念


### 1.1 什么是Filebeat Docker模块


> **💡 通俗理解**  
> Docker模块就像是专门为Docker容器设计的"日志收集员"，它知道如何从各种容器中收集日志，并且已经预设好了最佳配置

**🔸 核心功能**
- **自动发现**：自动找到运行中的容器
- **智能收集**：根据容器类型选择合适的收集方式
- **格式处理**：自动处理不同格式的日志
- **元数据增强**：添加容器相关信息到日志中

### 1.2 为什么需要Docker模块


```
传统日志收集 vs Docker模块：

❌ 传统方式的问题：
• 容器动态创建销毁，路径不固定
• 每个应用日志格式不同，需要单独配置
• 缺少容器上下文信息，难以定位问题

✅ Docker模块的优势：
• 自动适配容器环境
• 预置常见应用的日志格式
• 自动添加容器元数据
• 配置简单，开箱即用
```

### 1.3 Docker模块的工作原理


```
工作流程图：

容器运行 → Docker API监听 → 自动发现新容器 → 
应用预设规则 → 开始日志收集 → 格式化处理 → 
添加元数据 → 发送到输出端
```

---

## 2. 📋 容器日志收集配置


### 2.1 启用Docker模块


**基础启用方式：**
```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
```

> **🔧 实践说明**  
> 这就像打开一个总开关，告诉Filebeat开始关注Docker容器的日志

### 2.2 容器日志路径配置


**📁 `container_logs.var.paths` 参数详解**

```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.paths:
      - "/var/lib/docker/containers/*/*.log"
      - "/var/log/containers/*.log"
```

**🔹 路径说明**

| 路径类型 | **位置** | **说明** | **适用场景** |
|---------|----------|----------|-------------|
| **Docker原生** | `/var/lib/docker/containers/*/*.log` | Docker默认日志位置 | 直接使用Docker |
| **Kubernetes** | `/var/log/containers/*.log` | K8s容器日志软链接 | Kubernetes环境 |
| **自定义挂载** | `/custom/log/path/*.log` | 用户指定的日志目录 | 特殊挂载需求 |

> **⚠️ 注意事项**  
> 路径中的 `*` 是通配符，代表任意容器ID和文件名，让Filebeat能找到所有容器日志

### 2.3 流输出设置


**📤 `stream` 参数配置**

```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.stream: "all"  # stdout, stderr, all
```

**流类型对比：**

```
stdout (标准输出)：
应用正常运行时的输出信息
例如：web服务器的访问日志

stderr (错误输出)：
应用出错时的错误信息  
例如：异常堆栈、错误提示

all (全部)：
同时收集标准输出和错误输出
例如：完整的应用运行状态
```

---

## 3. 🔧 JSON日志处理


### 3.1 JSON根键设置


**`json.keys_under_root` 参数详解**

> **💡 简单理解**  
> 就像整理文件夹一样，决定是把JSON内容放在子文件夹里，还是直接放在根目录

```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.json.keys_under_root: true
```

**效果对比：**

```
原始JSON日志：
{"level": "info", "message": "用户登录", "user_id": 123}

keys_under_root: false (默认)：
{
  "json": {
    "level": "info",
    "message": "用户登录", 
    "user_id": 123
  }
}

keys_under_root: true：
{
  "level": "info",
  "message": "用户登录",
  "user_id": 123
}
```

### 3.2 错误键添加


**`json.add_error_key` 参数详解**

```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.json.add_error_key: true
```

> **🔧 实用价值**  
> 当JSON格式有问题时，这个设置会添加一个错误标记，帮助你快速找到有问题的日志

**错误处理示例：**

```
正常JSON：
{"status": "success", "data": "操作完成"}
→ 正常解析，无错误标记

异常JSON：
{"status": "success", "data": 操作完成}  # 缺少引号
→ 添加错误标记：
{
  "error": {"message": "JSON解析失败", "type": "json"},
  "message": "原始日志内容"
}
```

---

## 4. 📝 多行日志合并


### 4.1 多行处理概念


> **🎯 生活类比**  
> 就像读一篇文章，有些内容会跨越多行，多行合并就是把这些相关的行组合成完整的段落

**常见多行日志场景：**
- **Java异常堆栈**：错误信息跨越多行
- **SQL查询语句**：复杂查询分多行显示  
- **JSON格式化输出**：美化后的JSON跨多行

### 4.2 多行合并配置


```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.multiline.pattern: '^\d{4}-\d{2}-\d{2}'
    var.multiline.negate: true
    var.multiline.match: after
```

**📋 参数说明**

| 参数 | **含义** | **举例说明** |
|------|----------|-------------|
| **pattern** | 识别模式 | `^\d{4}-\d{2}-\d{2}` = 以日期开头的行 |
| **negate** | 是否取反 | `true` = 不匹配模式的行 |
| **match** | 合并方向 | `after` = 合并到前面的日志 |

### 4.3 多行合并实例


**Java异常日志合并：**

```
原始多行日志：
2024-09-21 10:30:00 ERROR Main - 系统异常
java.lang.NullPointerException: 空指针异常
    at com.example.Service.method(Service.java:25)
    at com.example.Controller.handle(Controller.java:15)
2024-09-21 10:30:01 INFO Main - 系统恢复正常

合并配置：
multiline.pattern: '^\d{4}-\d{2}-\d{2}'  # 匹配时间开头
multiline.negate: true                    # 不匹配的行
multiline.match: after                    # 合并到前面

合并结果：
第一条完整日志：包含异常信息和堆栈
第二条完整日志：系统恢复信息
```

---

## 5. ⚡ 高级配置技巧


### 5.1 部分配置处理


**`partial_config` 参数详解**

> **💡 理解要点**  
> 有些日志可能很长，Docker会分片传输，这个配置决定如何处理这些片段

```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.partial_config:
      enabled: true
      max_size: "64KB"
```

**分片处理示例：**

```
超长日志分片：
片段1: "这是一条很长的日志的开始部分..."
片段2: "...中间部分继续..."  
片段3: "...日志的结束部分"

处理结果：
完整日志: "这是一条很长的日志的开始部分...中间部分继续...日志的结束部分"
```

### 5.2 容器过滤配置


**选择性收集日志：**

```yaml
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.condition: 'contains(docker.container.name, "web")'
```

> **🎯 实用技巧**  
> 这就像设置一个过滤网，只收集名字包含"web"的容器日志，避免无关日志干扰

---

## 6. 🚀 实战配置示例


### 6.1 Web应用日志收集


```yaml
# Web应用完整配置
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.paths:
      - "/var/lib/docker/containers/*/*.log"
    var.stream: "all"
    var.json.keys_under_root: true
    var.json.add_error_key: true
    
output.elasticsearch:
  hosts: ["localhost:9200"]
  index: "web-logs-%{+yyyy.MM.dd}"
```

### 6.2 微服务集群配置


```yaml
# 微服务环境配置
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.paths:
      - "/var/log/containers/*.log"
    var.multiline.pattern: '^\{'
    var.multiline.negate: true
    var.multiline.match: after
    var.json.keys_under_root: true
    
processors:
- add_docker_metadata:
    host: "unix:///var/run/docker.sock"
```

### 6.3 生产环境配置


```yaml
# 生产环境完整配置
filebeat.modules:
- module: docker
  container_logs:
    enabled: true
    var.paths:
      - "/var/lib/docker/containers/*/*.log"
    var.stream: "all"
    var.json.keys_under_root: true
    var.json.add_error_key: true
    var.partial_config:
      enabled: true
      max_size: "128KB"
      
# 性能优化
filebeat.inputs:
- type: container
  paths:
    - '/var/log/containers/*.log'
  processors:
  - add_kubernetes_metadata:
      host: ${NODE_NAME}
      matchers:
      - logs_path:
          logs_path: "/var/log/containers/"
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Docker模块本质：专为容器环境设计的日志收集方案
🔸 容器日志路径：根据部署环境选择正确的日志路径
🔸 JSON处理：决定JSON日志的存储结构
🔸 多行合并：处理跨行的完整日志内容
🔸 流输出控制：选择收集标准输出、错误输出或全部
```

### 7.2 关键配置参数


| 参数类别 | **核心参数** | **作用说明** | **使用场景** |
|---------|-------------|-------------|-------------|
| **基础启用** | `container_logs.enabled` | 开启容器日志收集 | 所有场景 |
| **路径配置** | `var.paths` | 指定日志文件位置 | 根据环境调整 |
| **JSON处理** | `json.keys_under_root` | JSON字段放置位置 | JSON格式日志 |
| **多行合并** | `multiline.pattern` | 识别日志边界 | 异常堆栈等 |
| **流控制** | `var.stream` | 选择输出流类型 | 调试和生产 |

### 7.3 实践应用建议


**🔹 新手入门路径**
1. **从简单开始**：先用基础配置收集所有容器日志
2. **逐步优化**：根据日志格式添加JSON和多行处理
3. **性能调优**：生产环境添加过滤和性能配置
4. **监控完善**：配置告警和仪表板监控

**🔹 常见问题解决**
- **日志收集不到**：检查路径配置和权限设置
- **JSON解析失败**：启用错误键添加功能排查
- **多行日志分散**：配置合适的多行合并规则
- **性能问题**：添加容器过滤和限制配置

**🔹 最佳实践原则**
- **环境隔离**：不同环境使用不同的索引名
- **资源控制**：限制日志大小和收集频率
- **元数据丰富**：添加容器和应用相关标签
- **监控完善**：监控Filebeat自身的运行状态

### 7.4 进阶学习方向


```
基础掌握 → 高级特性 → 生产优化 → 集群管理

下一步学习：
• Filebeat处理器配置
• Elasticsearch模板管理  
• Kibana可视化配置
• 大规模集群部署策略
```

**🎯 核心记忆**
> Docker模块让容器日志收集变得简单，就像有了专业的"翻译官"，能把各种容器的"话"都翻译成统一的"语言"，让我们轻松管理和分析所有应用的日志信息。

**关键成功要素：**
- 选对路径配置，确保能找到日志文件
- 理解JSON处理，让结构化日志更好用  
- 掌握多行合并，完整收集错误信息
- 合理过滤配置，避免无关日志干扰