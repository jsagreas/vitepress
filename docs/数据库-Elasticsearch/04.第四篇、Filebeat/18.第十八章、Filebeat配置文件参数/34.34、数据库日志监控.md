---
title: 34、数据库日志监控
---
## 📚 目录

1. [数据库日志监控概述](#1-数据库日志监控概述)
2. [慢查询日志监控](#2-慢查询日志监控)
3. [错误日志监控](#3-错误日志监控)
4. [二进制日志处理](#4-二进制日志处理)
5. [事务日志分析](#5-事务日志分析)
6. [性能指标提取](#6-性能指标提取)
7. [综合配置案例](#7-综合配置案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 数据库日志监控概述


### 1.1 为什么要监控数据库日志


想象一下，数据库就像是一个繁忙的餐厅，每天有无数顾客点餐（执行SQL查询）。如果没有记录系统，你怎么知道：
- 哪些菜品（查询）制作时间最长？
- 厨师（数据库）是否出现了问题？
- 哪些订单（事务）失败了？

数据库日志就是这个"记录系统"，它帮我们了解数据库的健康状况。

**🔸 数据库日志的重要作用**
```
性能监控：发现慢查询，优化数据库性能
故障诊断：快速定位数据库错误和异常
安全审计：追踪数据访问和修改记录
容量规划：分析使用模式，预测资源需求
```

### 1.2 数据库日志的主要类型


```
📋 MySQL日志类型一览：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   慢查询日志     │    │    错误日志      │    │   二进制日志     │
│ slow query log  │    │   error log     │    │  binary log     │
│   记录慢SQL     │    │  记录错误信息    │    │  记录数据变更    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   性能分析工具             故障诊断系统            数据同步/恢复
```

**🔸 各类日志的通俗解释**
- **慢查询日志**：记录"跑得慢"的SQL语句，就像记录堵车路段
- **错误日志**：记录数据库出现的各种问题，就像医院的病历本
- **二进制日志**：记录数据的所有变化，就像银行的流水账单
- **事务日志**：记录事务的执行情况，确保数据一致性

---

## 2. 🐌 慢查询日志监控


### 2.1 什么是慢查询日志


慢查询日志记录执行时间超过设定阈值的SQL语句。就像监控道路交通，记录哪些路段经常堵车一样。

**🔸 慢查询日志的典型格式**
```
# Time: 2025-09-21T08:30:15.123456Z
# User@Host: app_user[app_user] @ [192.168.1.100]
# Thread_id: 12345  Schema: myapp_db
# Query_time: 5.234567  Lock_time: 0.000123
# Rows_sent: 100  Rows_examined: 50000
SET timestamp=1695286215;
SELECT * FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.created_at > '2025-01-01' 
ORDER BY o.created_at DESC;
```

**💡 关键字段含义解释**
- `Query_time`: SQL执行耗时（秒）
- `Lock_time`: 等待锁的时间
- `Rows_sent`: 返回给客户端的行数
- `Rows_examined`: 数据库扫描的行数

### 2.2 基础慢查询监控配置


```yaml
filebeat.inputs:
- type: log
  id: mysql-slow-query
  enabled: true
  paths:
    - /var/log/mysql/slow.log
  
  # 🔸 多行模式：将完整的SQL语句合并
  multiline.pattern: '^# Time:'
  multiline.negate: true
  multiline.match: after
  
  # 🔸 添加标识字段
  fields:
    log_type: mysql_slow
    service: database
  fields_under_root: true

processors:
  # 🔸 解析查询时间
  - dissect:
      tokenizer: "Query_time: %{query_time} Lock_time: %{lock_time}"
      field: "message"
      target_prefix: "mysql"
```

> 💡 **配置说明**  
> `multiline.pattern`：识别新记录的开始标志  
> `multiline.negate: true`：表示匹配到模式时开始新记录  
> `multiline.match: after`：将后续行合并到当前记录

### 2.3 高级慢查询分析配置


```yaml
filebeat.inputs:
- type: log
  id: mysql-slow-detailed
  enabled: true
  paths:
    - /var/log/mysql/slow.log
  
  multiline.pattern: '^# Time:'
  multiline.negate: true
  multiline.match: after
  
  fields:
    log_type: mysql_slow
    database_type: mysql
    environment: production

processors:
  # 🔸 提取基本信息
  - dissect:
      tokenizer: "# User@Host: %{mysql.user}[%{mysql.user}] @ [%{mysql.host}]"
      field: "message"
      ignore_failure: true
  
  # 🔸 提取性能指标
  - dissect:
      tokenizer: "Query_time: %{mysql.query_time} Lock_time: %{mysql.lock_time}"
      field: "message"
      ignore_failure: true
  
  # 🔸 提取行数信息
  - dissect:
      tokenizer: "Rows_sent: %{mysql.rows_sent} Rows_examined: %{mysql.rows_examined}"
      field: "message"
      ignore_failure: true
  
  # 🔸 转换数据类型
  - convert:
      fields:
        - {from: "mysql.query_time", to: "mysql.query_time_float", type: "float"}
        - {from: "mysql.rows_sent", to: "mysql.rows_sent_int", type: "integer"}
        - {from: "mysql.rows_examined", to: "mysql.rows_examined_int", type: "integer"}
      ignore_missing: true
  
  # 🔸 计算效率比率
  - script:
      lang: javascript
      source: >
        if (ctx.mysql && ctx.mysql.rows_sent_int && ctx.mysql.rows_examined_int) {
          ctx.mysql.efficiency_ratio = ctx.mysql.rows_sent_int / ctx.mysql.rows_examined_int;
        }
```

> ⚠️ **效率比率说明**  
> 效率比率 = 返回行数 / 扫描行数，值越小说明查询越低效。比如扫描10000行只返回10行，效率比率只有0.001。

### 2.4 SQL语句分类配置


```yaml
processors:
  # 🔸 SQL语句类型识别
  - script:
      lang: javascript
      source: >
        var message = ctx.message.toLowerCase();
        if (message.includes('select')) {
          ctx.mysql.query_type = 'select';
        } else if (message.includes('insert')) {
          ctx.mysql.query_type = 'insert';
        } else if (message.includes('update')) {
          ctx.mysql.query_type = 'update';
        } else if (message.includes('delete')) {
          ctx.mysql.query_type = 'delete';
        } else {
          ctx.mysql.query_type = 'other';
        }
  
  # 🔸 表名提取
  - script:
      lang: javascript
      source: >
        var message = ctx.message.toLowerCase();
        var tableMatch = message.match(/from\s+(\w+)/);
        if (tableMatch) {
          ctx.mysql.table_name = tableMatch[1];
        }
        
        var joinMatch = message.match(/join\s+(\w+)/);
        if (joinMatch) {
          ctx.mysql.has_join = true;
          ctx.mysql.join_table = joinMatch[1];
        }
```

---

## 3. ❌ 错误日志监控


### 3.1 MySQL错误日志特点


错误日志记录MySQL服务器的启动、运行和关闭信息，以及遇到的错误。就像汽车的故障警告灯一样。

**🔸 常见错误日志格式**
```
2025-09-21T08:30:15.123456Z 12345 [ERROR] [MY-000123] [Server] 
Table 'myapp.users' doesn't exist

2025-09-21T08:31:20.234567Z 12346 [Warning] [MY-010909] [Server] 
Found 1 prepared statement to be removed

2025-09-21T08:32:25.345678Z 0 [Note] [MY-010116] [Server] 
/usr/sbin/mysqld: ready for connections
```

### 3.2 错误日志监控配置


```yaml
filebeat.inputs:
- type: log
  id: mysql-error-log
  enabled: true
  paths:
    - /var/log/mysql/error.log
    - /var/log/mysql/mysqld.log
  
  fields:
    log_type: mysql_error
    service: database
    criticality: high
  fields_under_root: true

processors:
  # 🔸 解析错误级别
  - dissect:
      tokenizer: "%{mysql.timestamp} %{mysql.thread_id} [%{mysql.level}] %{mysql.details}"
      field: "message"
      ignore_failure: true
  
  # 🔸 错误严重程度分类
  - script:
      lang: javascript
      source: >
        if (ctx.mysql && ctx.mysql.level) {
          var level = ctx.mysql.level.toLowerCase();
          if (level.includes('error')) {
            ctx.mysql.severity = 'critical';
            ctx.mysql.priority = 1;
          } else if (level.includes('warning')) {
            ctx.mysql.severity = 'warning';
            ctx.mysql.priority = 2;
          } else if (level.includes('note')) {
            ctx.mysql.severity = 'info';
            ctx.mysql.priority = 3;
          }
        }
  
  # 🔸 常见错误模式识别
  - script:
      lang: javascript
      source: >
        var message = ctx.message.toLowerCase();
        if (message.includes("doesn't exist")) {
          ctx.mysql.error_category = 'table_not_found';
        } else if (message.includes('access denied')) {
          ctx.mysql.error_category = 'permission_denied';
        } else if (message.includes('connection')) {
          ctx.mysql.error_category = 'connection_issue';
        } else if (message.includes('deadlock')) {
          ctx.mysql.error_category = 'deadlock';
        } else if (message.includes('disk') || message.includes('space')) {
          ctx.mysql.error_category = 'disk_space';
        }
```

> 🚨 **错误分类说明**  
> - `table_not_found`: 表不存在，通常是应用程序问题  
> - `permission_denied`: 权限不足，需要检查用户权限  
> - `connection_issue`: 连接问题，可能是网络或配置问题  
> - `deadlock`: 死锁，需要优化SQL或事务逻辑

---

## 4. 📊 二进制日志处理


### 4.1 二进制日志的作用


二进制日志（Binary Log）记录所有更改数据的语句，主要用于数据复制和恢复。就像银行记录每一笔交易一样。

**🔸 二进制日志示例**
```
# at 154
#250921  8:30:15 server id 1  end_log_pos 219 CRC32 0x1a2b3c4d  Query
SET TIMESTAMP=1695286215/*!*/;
BEGIN/*!*/;
# at 219
#250921  8:30:15 server id 1  end_log_pos 342 CRC32 0x5e6f7a8b  Query
use `myapp`/*!*/;
SET TIMESTAMP=1695286215/*!*/;
UPDATE users SET last_login = NOW() WHERE id = 12345/*!*/;
# at 342
#250921  8:30:15 server id 1  end_log_pos 369 CRC32 0x9c8d7e6f  Xid = 12345
COMMIT/*!*/;
```

### 4.2 二进制日志监控配置


```yaml
filebeat.inputs:
- type: log
  id: mysql-binlog-text
  enabled: true
  paths:
    - /var/log/mysql/mysql-bin.log.*
    - /var/log/mysql/binlog.log.*
  
  # 🔸 排除二进制格式文件
  exclude_files: ['\.bin$']
  
  # 🔸 多行模式处理事务
  multiline.pattern: '^# at \d+'
  multiline.negate: true
  multiline.match: after
  
  fields:
    log_type: mysql_binlog
    service: database
    purpose: replication

processors:
  # 🔸 解析位置信息
  - dissect:
      tokenizer: "# at %{mysql.position}"
      field: "message"
      ignore_failure: true
  
  # 🔸 解析服务器ID和时间戳
  - dissect:
      tokenizer: "server id %{mysql.server_id} end_log_pos %{mysql.end_position}"
      field: "message"
      ignore_failure: true
  
  # 🔸 事务类型识别
  - script:
      lang: javascript
      source: >
        var message = ctx.message.toLowerCase();
        if (message.includes('begin')) {
          ctx.mysql.transaction_type = 'begin';
        } else if (message.includes('commit')) {
          ctx.mysql.transaction_type = 'commit';
        } else if (message.includes('rollback')) {
          ctx.mysql.transaction_type = 'rollback';
        } else if (message.includes('insert')) {
          ctx.mysql.transaction_type = 'insert';
        } else if (message.includes('update')) {
          ctx.mysql.transaction_type = 'update';
        } else if (message.includes('delete')) {
          ctx.mysql.transaction_type = 'delete';
        }
```

---

## 5. 🔄 事务日志分析


### 5.1 事务日志的重要性


事务确保数据的一致性，就像转账操作必须保证"扣款"和"入账"同时成功。事务日志帮我们监控这个过程。

**🔸 事务的ACID特性**
```
原子性 (Atomicity)：事务要么全部成功，要么全部失败
一致性 (Consistency)：数据始终保持一致状态  
隔离性 (Isolation)：并发事务不会互相干扰
持久性 (Durability)：提交的事务永久保存
```

### 5.2 事务监控配置


```yaml
filebeat.inputs:
- type: log
  id: mysql-transaction-log
  enabled: true
  paths:
    - /var/log/mysql/general.log
  
  # 🔸 过滤事务相关日志
  include_lines: ['BEGIN', 'COMMIT', 'ROLLBACK', 'START TRANSACTION']
  
  fields:
    log_type: mysql_transaction
    monitoring_focus: acid_compliance

processors:
  # 🔸 解析事务ID
  - grok:
      patterns_dir: "/etc/filebeat/patterns"
      pattern: "%{TIMESTAMP_ISO8601:mysql.timestamp}%{SPACE}%{NUMBER:mysql.connection_id}%{SPACE}%{WORD:mysql.command}%{SPACE}%{GREEDYDATA:mysql.statement}"
      ignore_failure: true
  
  # 🔸 事务状态跟踪
  - script:
      lang: javascript
      source: >
        var statement = ctx.mysql.statement.toLowerCase().trim();
        if (statement.includes('begin') || statement.includes('start transaction')) {
          ctx.mysql.transaction_status = 'started';
          ctx.mysql.transaction_action = 'begin';
        } else if (statement.includes('commit')) {
          ctx.mysql.transaction_status = 'committed';
          ctx.mysql.transaction_action = 'commit';
        } else if (statement.includes('rollback')) {
          ctx.mysql.transaction_status = 'rolled_back';
          ctx.mysql.transaction_action = 'rollback';
        }
  
  # 🔸 连接ID转换
  - convert:
      fields:
        - {from: "mysql.connection_id", to: "mysql.connection_id_int", type: "integer"}
      ignore_missing: true
```

### 5.3 事务性能分析


```yaml
processors:
  # 🔸 事务时长计算（需要配合Elasticsearch聚合）
  - script:
      lang: javascript
      source: >
        // 标记事务开始时间
        if (ctx.mysql.transaction_action === 'begin') {
          ctx.mysql.transaction_start = ctx['@timestamp'];
        }
        
        // 为每个连接添加唯一标识
        if (ctx.mysql.connection_id_int) {
          ctx.mysql.session_id = 'session_' + ctx.mysql.connection_id_int;
        }
  
  # 🔸 事务类型分类
  - script:
      lang: javascript
      source: >
        // 根据操作复杂度分类
        var statement = ctx.mysql.statement || '';
        if (statement.includes('SELECT') && !statement.includes('UPDATE') && !statement.includes('INSERT')) {
          ctx.mysql.transaction_complexity = 'read_only';
        } else if (statement.includes('INSERT') || statement.includes('UPDATE') || statement.includes('DELETE')) {
          ctx.mysql.transaction_complexity = 'write_operation';
        }
```

---

## 6. 📈 性能指标提取


### 6.1 关键性能指标（KPI）


数据库性能监控就像体检，需要关注各项"健康指标"。

**🔸 核心性能指标**
```
📊 响应时间指标：
- 平均查询时间
- 慢查询占比
- 锁等待时间

📊 吞吐量指标：
- 每秒查询数（QPS）
- 每秒事务数（TPS）
- 连接数使用率

📊 资源利用率：
- 扫描效率（返回行数/扫描行数）
- 索引使用率
- 缓存命中率
```

### 6.2 性能指标提取配置


```yaml
filebeat.inputs:
- type: log
  id: mysql-performance-metrics
  enabled: true
  paths:
    - /var/log/mysql/slow.log
  
  multiline.pattern: '^# Time:'
  multiline.negate: true
  multiline.match: after

processors:
  # 🔸 提取详细性能指标
  - dissect:
      tokenizer: "Query_time: %{perf.query_time} Lock_time: %{perf.lock_time}"
      field: "message"
      ignore_failure: true
  
  - dissect:
      tokenizer: "Rows_sent: %{perf.rows_sent} Rows_examined: %{perf.rows_examined}"
      field: "message"
      ignore_failure: true
  
  # 🔸 计算性能指标
  - script:
      lang: javascript
      source: >
        if (ctx.perf) {
          var queryTime = parseFloat(ctx.perf.query_time || 0);
          var lockTime = parseFloat(ctx.perf.lock_time || 0);
          var rowsSent = parseInt(ctx.perf.rows_sent || 0);
          var rowsExamined = parseInt(ctx.perf.rows_examined || 0);
          
          // 计算实际执行时间（排除锁等待）
          ctx.perf.actual_execution_time = queryTime - lockTime;
          
          // 计算扫描效率
          if (rowsExamined > 0) {
            ctx.perf.scan_efficiency = rowsSent / rowsExamined;
            ctx.perf.scan_efficiency_percent = Math.round(ctx.perf.scan_efficiency * 100);
          }
          
          // 性能等级分类
          if (queryTime > 10) {
            ctx.perf.performance_level = 'critical';
          } else if (queryTime > 2) {
            ctx.perf.performance_level = 'poor';
          } else if (queryTime > 0.5) {
            ctx.perf.performance_level = 'acceptable';
          } else {
            ctx.perf.performance_level = 'good';
          }
          
          // 查询复杂度评估
          if (rowsExamined > 100000) {
            ctx.perf.complexity = 'high';
          } else if (rowsExamined > 10000) {
            ctx.perf.complexity = 'medium';
          } else {
            ctx.perf.complexity = 'low';
          }
        }
```

> 📊 **性能指标解读**  
> - `scan_efficiency < 0.1`: 查询效率很低，可能需要添加索引  
> - `lock_time > query_time * 0.5`: 锁竞争严重  
> - `rows_examined > 1000000`: 大表扫描，需要优化

### 6.3 告警阈值配置


```yaml
processors:
  # 🔸 性能告警规则
  - script:
      lang: javascript
      source: >
        var alerts = [];
        
        if (ctx.perf) {
          var queryTime = parseFloat(ctx.perf.query_time || 0);
          var scanEfficiency = parseFloat(ctx.perf.scan_efficiency || 1);
          var rowsExamined = parseInt(ctx.perf.rows_examined || 0);
          
          // 慢查询告警
          if (queryTime > 5) {
            alerts.push({
              type: 'slow_query',
              severity: 'high',
              message: 'Query execution time exceeds 5 seconds'
            });
          }
          
          // 低效查询告警
          if (scanEfficiency < 0.01 && rowsExamined > 10000) {
            alerts.push({
              type: 'inefficient_query',
              severity: 'medium',
              message: 'Query has very low scan efficiency'
            });
          }
          
          // 大表扫描告警
          if (rowsExamined > 1000000) {
            alerts.push({
              type: 'full_table_scan',
              severity: 'medium',
              message: 'Query scanned more than 1M rows'
            });
          }
          
          if (alerts.length > 0) {
            ctx.mysql.alerts = alerts;
            ctx.mysql.alert_count = alerts.length;
          }
        }
```

---

## 7. 🔧 综合配置案例


### 7.1 生产环境完整配置


```yaml
# ==================== Filebeat 数据库监控配置 ====================

filebeat.inputs:
# 🔸 慢查询日志监控
- type: log
  id: mysql-slow-query-prod
  enabled: true
  paths:
    - /var/log/mysql/slow.log
    - /var/log/mysql/*-slow.log
  
  multiline.pattern: '^# Time:'
  multiline.negate: true
  multiline.match: after
  multiline.max_lines: 500
  
  fields:
    log_type: mysql_slow
    environment: production
    database_instance: mysql-prod-01
    monitoring_team: dba
  fields_under_root: true
  
  # 🔸 排除系统查询
  exclude_lines:
    - 'information_schema'
    - 'performance_schema'
    - 'mysql.proc'

# 🔸 错误日志监控
- type: log
  id: mysql-error-prod
  enabled: true
  paths:
    - /var/log/mysql/error.log
    - /var/log/mysql/mysqld.log
  
  fields:
    log_type: mysql_error
    environment: production
    alert_channel: '#database-alerts'
  fields_under_root: true
  
  # 🔸 只关注错误和警告
  include_lines: ['ERROR', 'WARNING', 'FATAL']

# 🔸 事务日志监控（采样）
- type: log
  id: mysql-transaction-sample
  enabled: true
  paths:
    - /var/log/mysql/general.log
  
  # 🔸 采样配置，避免日志过多
  harvester_limit: 1
  scan_frequency: 30s
  
  include_lines: ['BEGIN', 'COMMIT', 'ROLLBACK']
  
  fields:
    log_type: mysql_transaction
    sampling_rate: 0.1  # 10% 采样
  fields_under_root: true

# ==================== 处理器配置 ====================

processors:
  # 🔸 通用字段添加
  - add_host_metadata:
      when.not.contains.tags: forwarded
  
  - add_docker_metadata: ~
  
  # 🔸 慢查询处理
  - dissect:
      when.equals.log_type: mysql_slow
      tokenizer: "Query_time: %{mysql.query_time} Lock_time: %{mysql.lock_time}"
      field: "message"
      ignore_failure: true
  
  - dissect:
      when.equals.log_type: mysql_slow
      tokenizer: "Rows_sent: %{mysql.rows_sent} Rows_examined: %{mysql.rows_examined}"
      field: "message"
      ignore_failure: true
  
  # 🔸 错误日志处理
  - dissect:
      when.equals.log_type: mysql_error
      tokenizer: "%{mysql.timestamp} %{mysql.thread_id} [%{mysql.level}] %{mysql.details}"
      field: "message"
      ignore_failure: true
  
  # 🔸 性能计算
  - script:
      when.equals.log_type: mysql_slow
      lang: javascript
      source: >
        if (ctx.mysql) {
          var queryTime = parseFloat(ctx.mysql.query_time || 0);
          var rowsSent = parseInt(ctx.mysql.rows_sent || 0);
          var rowsExamined = parseInt(ctx.mysql.rows_examined || 0);
          
          if (rowsExamined > 0) {
            ctx.mysql.efficiency = Math.round((rowsSent / rowsExamined) * 100);
          }
          
          ctx.mysql.performance_category = queryTime > 2 ? 'slow' : 'normal';
        }
  
  # 🔸 删除原始消息（节省空间）
  - drop_fields:
      fields: ["message"]
      when.not.equals.log_type: mysql_error

# ==================== 输出配置 ====================

output.elasticsearch:
  hosts: ["elasticsearch-01:9200", "elasticsearch-02:9200"]
  index: "filebeat-mysql-%{+yyyy.MM.dd}"
  
  # 🔸 根据日志类型路由到不同索引
  indices:
    - index: "mysql-slow-%{+yyyy.MM.dd}"
      when.equals.log_type: mysql_slow
    - index: "mysql-error-%{+yyyy.MM.dd}"
      when.equals.log_type: mysql_error
    - index: "mysql-transaction-%{+yyyy.MM.dd}"
      when.equals.log_type: mysql_transaction

# ==================== 模板配置 ====================

setup.template.settings:
  index.number_of_shards: 2
  index.number_of_replicas: 1
  index.refresh_interval: "5s"

# ==================== 监控配置 ====================

monitoring.enabled: true
monitoring.elasticsearch:
  hosts: ["elasticsearch-01:9200"]

# ==================== 日志配置 ====================

logging.level: info
logging.to_files: true
logging.files:
  path: /var/log/filebeat
  name: filebeat
  keepfiles: 7
  permissions: 0644
```

### 7.2 开发环境简化配置


```yaml
# 开发环境 - 简化版数据库监控

filebeat.inputs:
- type: log
  id: mysql-dev-monitoring
  enabled: true
  paths:
    - /var/log/mysql/*.log
  
  # 🔸 简单的多行合并
  multiline.pattern: '^#'
  multiline.negate: true
  multiline.match: after
  
  fields:
    environment: development
    log_source: mysql
  fields_under_root: true

processors:
  # 🔸 基础解析
  - dissect:
      tokenizer: "Query_time: %{query_time}"
      field: "message"
      ignore_failure: true
  
  # 🔸 简单分类
  - script:
      lang: javascript
      source: >
        var msg = ctx.message.toLowerCase();
        if (msg.includes('error')) {
          ctx.log_level = 'error';
        } else if (msg.includes('warning')) {
          ctx.log_level = 'warning';
        } else if (msg.includes('query_time')) {
          ctx.log_level = 'slow_query';
        } else {
          ctx.log_level = 'info';
        }

output.console:
  pretty: true

logging.level: debug
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 数据库日志类型：慢查询、错误、二进制、事务日志的作用和特点
🔸 多行日志处理：multiline配置处理完整SQL语句和事务
🔸 性能指标提取：查询时间、扫描效率、锁等待等关键指标
🔸 告警规则设计：基于阈值的性能和错误告警机制
🔸 日志采样策略：在高并发环境下合理采样，避免日志爆炸
```

### 8.2 关键理解要点


**🔹 为什么需要多行处理**
```
数据库日志特点：
- 一条SQL可能跨多行显示
- 事务包含多条语句
- 需要将相关行合并为完整记录

解决方案：
- 使用multiline.pattern识别记录边界
- 合理设置max_lines避免内存问题
```

**🔹 性能监控的核心思路**
```
监控维度：
- 时间维度：查询耗时、锁等待时间
- 效率维度：扫描行数vs返回行数
- 频率维度：慢查询发生频率
- 影响维度：影响的用户和业务

优化方向：
- 发现性能瓶颈SQL
- 分析数据库负载模式  
- 预防性能问题
- 指导索引优化
```

**🔹 告警策略设计**
```
分级告警：
- Critical：影响业务的严重错误
- Warning：性能问题和潜在风险
- Info：常规运行信息

避免告警疲劳：
- 设置合理阈值
- 告警去重机制
- 分时段告警策略
```

### 8.3 实际应用建议


**🎯 生产环境最佳实践**
- **分类索引**：不同类型日志使用不同索引，便于管理和查询
- **采样策略**：高频日志采用采样，避免存储爆炸
- **告警集成**：与钉钉、企业微信等集成，及时响应问题
- **定期清理**：设置索引生命周期，自动删除过期日志

**🛠️ 故障排查思路**
- **时间关联**：根据故障时间点查找相关日志
- **性能分析**：对比故障前后的性能指标变化
- **错误聚合**：统计错误类型和频率，找出根本原因
- **趋势分析**：观察性能指标趋势，预测潜在问题

**核心记忆要点**：
- 数据库日志监控重在"防患于未然"
- 多行处理是数据库日志监控的技术关键
- 性能指标提取要关注"效率"而不仅仅是"速度"
- 告警设计要平衡"及时发现"和"避免干扰"
- 生产环境配置要考虑"可维护性"和"资源消耗"