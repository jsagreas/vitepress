---
title: 5、容器日志输入配置
---
## 📚 目录

1. [容器日志输入概述](#1-容器日志输入概述)
2. [基本配置结构](#2-基本配置结构)  
3. [核心配置参数详解](#3-核心配置参数详解)
4. [容器过滤配置](#4-容器过滤配置)
5. [日志解析器配置](#5-日志解析器配置)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🐳 容器日志输入概述


### 1.1 什么是容器日志输入


**通俗理解**：容器日志输入就是让Filebeat专门去读取Docker容器产生的日志文件

```
传统应用 vs 容器应用的日志差异：

传统应用：
应用程序 → 写入文件 → /var/log/app.log
         ↓
    Filebeat直接读取文件

容器应用：
容器内应用 → 标准输出 → Docker引擎 → /var/lib/docker/containers/容器ID/
          ↓
    Filebeat需要特殊处理
```

**为什么需要专门的容器类型**：
- 🔸 **路径复杂**：容器日志路径包含随机的容器ID
- 🔸 **格式特殊**：Docker会给每行日志加上时间戳等元数据  
- 🔸 **动态变化**：容器启停会导致日志文件变化
- 🔸 **多流混合**：标准输出和标准错误可能需要分别处理

### 1.2 容器日志的存储位置


**Docker默认日志位置**：
```
Linux系统：
/var/lib/docker/containers/{容器ID}/{容器ID}-json.log

实际路径示例：
/var/lib/docker/containers/
  └── a1b2c3d4e5f6.../
      ├── a1b2c3d4e5f6...-json.log  ← 实际日志文件
      ├── config.v2.json              ← 容器配置信息
      └── hostconfig.json             ← 主机配置信息
```

> 💡 **新手提示**：这个路径很长很复杂，而且容器ID是随机生成的，所以我们需要用特殊的配置来让Filebeat自动找到这些文件

---

## 2. ⚙️ 基本配置结构


### 2.1 最简单的容器输入配置


```yaml
filebeat.inputs:
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
```

**这段配置的含义**：
- `type: container` → 告诉Filebeat这是容器类型的输入
- `paths` → 指定要读取的日志文件路径模式
- `*/*.log` → 通配符匹配所有容器的日志文件

### 2.2 完整的配置结构框架


```
container输入配置结构：

filebeat.inputs:
- type: container          ← ①声明输入类型
  paths: [...]            ← ②指定日志路径  
  stream: stdout          ← ③选择输出流
  format: auto            ← ④日志格式
  containers.ids: [...]   ← ⑤容器ID过滤
  containers.image: [...]  ← ⑥镜像名过滤
  containers.name: [...]   ← ⑦容器名过滤
  parsers: [...]          ← ⑧解析器配置
  symlinks: true          ← ⑨符号链接处理
```

---

## 3. 🔧 核心配置参数详解


### 3.1 paths - 日志路径配置


**作用**：告诉Filebeat去哪里找容器日志文件

```yaml
# 基础路径配置
filebeat.inputs:
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
```

**路径配置的几种形式**：

| 配置方式 | **适用场景** | **示例** |
|---------|-------------|----------|
| `通配符路径` | `所有容器日志` | `/var/lib/docker/containers/*/*.log` |
| `具体路径` | `特定容器` | `/var/lib/docker/containers/abc123.../abc123...-json.log` |
| `多路径` | `多个Docker实例` | `['/var/lib/docker/containers/*/*.log', '/opt/docker/containers/*/*.log']` |

### 3.2 stream - 输出流选择


**作用**：选择读取标准输出还是标准错误，或者两者都读取

```yaml
# 只读取标准输出
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  stream: stdout

# 只读取标准错误  
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  stream: stderr

# 读取所有输出（默认）
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  stream: all
```

**stream选项详解**：

| 选项值 | **含义** | **使用场景** |
|-------|----------|-------------|
| `stdout` | `只收集标准输出` | `应用正常日志` |
| `stderr` | `只收集标准错误` | `错误和异常日志` |
| `all` | `收集所有输出（默认）` | `完整的应用日志` |

> 💡 **通俗解释**：就像你在命令行运行程序时，有些信息打印在屏幕上（stdout），有些错误信息也打印出来（stderr），stream就是选择你要收集哪种

### 3.3 format - 日志格式配置


**作用**：指定容器日志的格式类型

```yaml
# 自动检测格式（推荐）
- type: container
  format: auto

# 指定为Docker JSON格式
- type: container  
  format: docker

# 指定为CRI格式（Kubernetes常用）
- type: container
  format: cri
```

**format选项说明**：

| 格式 | **特点** | **日志样例** |
|-----|----------|-------------|
| `auto` | `自动检测（推荐）` | `让Filebeat自己判断` |
| `docker` | `Docker标准JSON格式` | `{"log":"应用日志内容\n","stream":"stdout","time":"2023-09-21T..."}` |
| `cri` | `CRI格式（K8s）` | `2023-09-21T... stdout F 应用日志内容` |

> ⭐ **新手建议**：99%的情况下使用`format: auto`就够了，Filebeat会自动识别格式

---

## 4. 🎯 容器过滤配置


### 4.1 为什么需要过滤


**问题场景**：
```
服务器上运行的容器：
├── nginx-web (需要收集)
├── mysql-db (需要收集)  
├── redis-cache (不需要收集)
├── monitoring-agent (不需要收集)
└── temp-container (不需要收集)

如果不过滤 → 所有容器日志都会被收集 → 浪费资源
使用过滤 → 只收集需要的容器日志 → 节省资源
```

### 4.2 containers.ids - 按容器ID过滤


```yaml
# 只收集指定容器ID的日志
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.ids:
    - 'a1b2c3d4e5f6'
    - 'f6e5d4c3b2a1'
```

**实际使用示例**：
```bash
# 先查看容器ID
docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    NAMES
a1b2c3d4e5f6   nginx     ...       2 hours   Up        web-server
f6e5d4c3b2a1   mysql     ...       2 hours   Up        database

# 然后在配置中使用这些ID
```

### 4.3 containers.image - 按镜像名过滤


```yaml
# 只收集特定镜像的容器日志
- type: container  
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.image:
    - 'nginx*'
    - 'mysql:8.0'
    - 'myapp*'
```

**镜像过滤示例**：

| 过滤规则 | **匹配结果** | **说明** |
|---------|-------------|----------|
| `nginx*` | `nginx:latest, nginx:1.20` | `通配符匹配` |
| `mysql:8.0` | `mysql:8.0` | `精确匹配` |
| `myapp*` | `myapp:v1.0, myapp:latest` | `自定义应用匹配` |

### 4.4 containers.name - 按容器名过滤


```yaml
# 只收集特定名称的容器日志
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']  
  containers.name:
    - 'web-*'
    - 'api-server'
    - '*-prod'
```

**容器名过滤的优势**：
- ✅ **直观易懂**：容器名比ID更容易记忆
- ✅ **支持通配符**：可以按命名规则批量匹配
- ✅ **运维友好**：符合运维人员的使用习惯

### 4.5 组合过滤策略


```yaml
# 生产环境的实用配置
filebeat.inputs:
# 收集所有Web服务容器
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.name: ['web-*', 'nginx-*']
  stream: stdout
  
# 单独收集数据库错误日志  
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.image: ['mysql*', 'postgres*']
  stream: stderr
```

---

## 5. 🔍 日志解析器配置


### 5.1 parsers的作用


**通俗解释**：日志解析器就像一个"翻译官"，把原始的日志内容转换成结构化的数据

```
原始日志：
2023-09-21 10:30:15 ERROR [UserService] User login failed: invalid password

解析后：
{
  "timestamp": "2023-09-21 10:30:15",
  "level": "ERROR", 
  "service": "UserService",
  "message": "User login failed: invalid password"
}
```

### 5.2 multiline解析器 - 多行日志处理


**使用场景**：处理异常堆栈、SQL语句等跨多行的日志

```yaml
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  parsers:
    - multiline:
        pattern: '^\d{4}-\d{2}-\d{2}'  # 以日期开头的行
        negate: true                    # 反向匹配
        match: after                    # 匹配的行附加到前一行
```

**multiline配置解析**：

| 参数 | **作用** | **示例值** |
|-----|----------|-----------|
| `pattern` | `匹配模式（正则表达式）` | `^\d{4}-\d{2}-\d{2}` |
| `negate` | `是否反向匹配` | `true/false` |
| `match` | `匹配行的处理方式` | `after/before` |

**实际效果示例**：
```
原始多行日志：
2023-09-21 10:30:15 ERROR Something went wrong
  at com.example.Service.method(Service.java:123)
  at com.example.Controller.handle(Controller.java:45)
  
处理后：
一条完整的日志记录包含了错误信息和完整的堆栈跟踪
```

### 5.3 JSON解析器


```yaml
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  parsers:
    - ndjson:
        keys_under_root: true   # JSON字段放在根级别
        add_error_key: true     # 解析失败时添加错误字段
```

**JSON解析器适用场景**：
- 🔸 应用输出结构化JSON日志
- 🔸 微服务架构中的服务日志
- 🔸 需要对日志字段进行查询和分析

---

## 6. 🛠️ 实际应用场景


### 6.1 场景一：Web应用容器日志收集


**需求**：收集所有Web服务容器的访问日志和错误日志

```yaml
filebeat.inputs:
# Web服务访问日志
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.name: ['nginx-*', 'apache-*', 'web-*']
  stream: stdout
  fields:
    log_type: access
    service_type: web
    
# Web服务错误日志
- type: container  
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.name: ['nginx-*', 'apache-*', 'web-*']
  stream: stderr
  fields:
    log_type: error
    service_type: web
```

### 6.2 场景二：微服务应用日志收集


**需求**：收集微服务架构中各个服务的JSON格式日志

```yaml
filebeat.inputs:
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.name: ['*-service', '*-api']
  parsers:
    - ndjson:
        keys_under_root: true
    - multiline:
        pattern: '^\{'
        negate: false
        match: after
        max_lines: 1000
  fields:
    environment: production
    log_format: json
```

### 6.3 场景三：数据库容器日志收集


**需求**：收集数据库的慢查询日志和错误日志

```yaml
filebeat.inputs:
# 数据库错误日志
- type: container
  paths: ['/var/lib/docker/containers/*/*.log'] 
  containers.image: ['mysql*', 'postgres*', 'mongodb*']
  stream: stderr
  parsers:
    - multiline:
        pattern: '^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}'
        negate: true
        match: after
  fields:
    log_type: database_error
    
# 数据库查询日志
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.image: ['mysql*']
  stream: stdout
  include_lines: ['.*Query.*', '.*Slow query.*']
  fields:
    log_type: database_query
```

### 6.4 场景四：开发环境容器日志


**需求**：开发环境中收集所有容器日志用于调试

```yaml
filebeat.inputs:
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  # 开发环境不做过滤，收集所有日志
  stream: all
  symlinks: true
  parsers:
    - multiline:
        pattern: '^\d{4}-\d{2}-\d{2}'
        negate: true  
        match: after
        max_lines: 500
  fields:
    environment: development
    debug: true
```

---

## 7. ⚠️ 常见问题与最佳实践


### 7.1 性能优化建议


**问题**：容器日志收集会消耗大量系统资源

**优化策略**：

① **精确过滤**：
```yaml
# ❌ 不好的做法 - 收集所有容器
paths: ['/var/lib/docker/containers/*/*.log']

# ✅ 好的做法 - 精确过滤
paths: ['/var/lib/docker/containers/*/*.log']
containers.name: ['important-*']
containers.image: ['myapp*']
```

② **流分离**：
```yaml
# ✅ 分别处理不同的输出流
- type: container
  stream: stdout  # 正常日志
  
- type: container  
  stream: stderr  # 错误日志
```

③ **限制行数**：
```yaml
parsers:
  - multiline:
      max_lines: 500  # 限制多行日志的最大行数
```

### 7.2 symlinks参数说明


**作用**：处理符号链接文件

```yaml
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  symlinks: true   # 跟随符号链接
```

**使用场景**：
- 🔸 Docker使用了符号链接来管理日志文件
- 🔸 某些容器运行时创建日志文件的符号链接
- 🔸 日志轮转后的文件链接处理

> 💡 **建议**：通常设置为`true`，让Filebeat能够正确跟踪日志文件

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 容器日志输入：专门用于收集Docker容器产生的日志
🔸 paths配置：指定容器日志文件的路径模式  
🔸 stream选择：选择收集stdout、stderr或all
🔸 format格式：auto自动检测，docker和cri手动指定
🔸 容器过滤：通过ID、镜像名、容器名进行精确过滤
🔸 解析器：multiline处理多行，ndjson处理JSON格式
🔸 symlinks：符号链接跟随处理
```

### 8.2 配置选择指南


**基础配置选择**：
```yaml
# 新手推荐配置
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  format: auto
  stream: all
  symlinks: true
```

**生产环境选择**：
```yaml
# 生产环境推荐配置  
- type: container
  paths: ['/var/lib/docker/containers/*/*.log']
  containers.name: ['prod-*']  # 精确过滤
  format: auto
  stream: stdout               # 分流处理
  symlinks: true
  parsers:
    - multiline:              # 多行处理
        pattern: '^\d{4}-\d{2}-\d{2}'
        negate: true
        match: after
```

### 8.3 实际应用价值


**核心优势**：
- 🎯 **自动发现**：无需手动指定每个容器的日志路径
- 🎯 **动态适应**：容器启停时自动调整收集范围  
- 🎯 **精确过滤**：避免收集无关日志，节省资源
- 🎯 **格式识别**：自动处理Docker特有的日志格式
- 🎯 **元数据丰富**：自动添加容器相关的元数据信息

**应用场景**：
- **微服务监控**：收集所有微服务容器的日志
- **故障排查**：快速定位特定容器的问题日志
- **性能分析**：分析容器应用的运行状况
- **安全审计**：监控容器的安全相关事件

**核心记忆**：
- 容器日志收集用container类型，路径用通配符自动匹配
- stream分流处理效率高，过滤配置省资源很重要  
- format选auto最省心，parsers处理多行和JSON
- symlinks设为true，容器元数据自动加