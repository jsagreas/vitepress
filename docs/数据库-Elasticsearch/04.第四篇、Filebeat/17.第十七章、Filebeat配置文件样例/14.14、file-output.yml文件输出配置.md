---
title: 14、file-output.yml文件输出配置
---
## 📚 目录

1. [文件输出基本概念](#1-文件输出基本概念)
2. [文件输出路径配置](#2-文件输出路径配置)
3. [文件轮转策略设置](#3-文件轮转策略设置)
4. [文件权限配置](#4-文件权限配置)
5. [编码格式设置](#5-编码格式设置)
6. [缓冲区配置](#6-缓冲区配置)
7. [文件命名模板](#7-文件命名模板)
8. [压缩配置选项](#8-压缩配置选项)
9. [文件保留策略](#9-文件保留策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📁 文件输出基本概念


### 1.1 什么是Filebeat文件输出

🎯 **简单理解**：文件输出就像是给Filebeat安排一个"保管员"，把收集到的日志整理后存放到指定的文件夹里

```
生活中的类比：
邮件分拣员 → 把各种信件按类别整理放入不同文件夹
Filebeat → 把各种日志按规则整理保存到指定文件

为什么需要文件输出：
1. 本地备份：在本地保留一份日志副本
2. 离线分析：当网络不可用时，先存本地
3. 数据归档：长期保存重要日志数据
4. 调试排错：本地查看处理后的日志格式
```

**📊 文件输出的应用场景**

| 应用场景 | **使用目的** | **典型配置** | **注意事项** |
|---------|-------------|-------------|-------------|
| 🔸 **本地备份** | `数据安全保障` | `按日期分文件` | `定期清理旧文件` |
| 🔸 **离线处理** | `网络中断应对` | `大容量配置` | `监控磁盘空间` |
| 🔸 **数据归档** | `长期存储` | `压缩格式保存` | `归档策略规划` |
| 🔸 **开发调试** | `问题排查` | `详细格式输出` | `临时性配置` |

### 1.2 文件输出vs其他输出方式

**💡 输出方式对比**

```
直接发送到Elasticsearch：
优点：实时性好，查询方便
缺点：网络依赖强，数据丢失风险

文件输出：
优点：本地可控，数据安全，支持离线
缺点：需要额外存储空间，后续处理复杂

混合模式（推荐）：
既发送到Elasticsearch，又保存本地文件
```

### 1.3 基础文件输出配置框架

**🔧 最简单的文件输出配置**

```yaml
# filebeat.yml - 基础文件输出配置
filebeat.inputs:
- type: log
  paths:
    - /var/log/nginx/*.log
  
output.file:
  path: "/tmp/filebeat"          # 输出目录
  filename: "filebeat.log"       # 文件名
  
logging.level: info
```

---

## 2. 📂 文件输出路径配置


### 2.1 路径配置基础知识

**🎯 路径配置的核心原理**

```
路径配置就像给快递员指定送货地址：
- 必须是具体的文件夹路径
- 文件夹必须存在或者Filebeat有权限创建
- 路径可以使用变量，实现动态命名

基本配置结构：
output.file:
  path: "目标文件夹路径"
  filename: "文件名（可选）"
```

**🔧 静态路径配置示例**

```yaml
# 示例1：固定路径配置
output.file:
  path: "/var/log/filebeat-output"
  filename: "app-logs.log"
  
# 示例2：Windows系统路径
output.file:
  path: "C:\\logs\\filebeat"
  filename: "application.log"
  
# 示例3：相对路径配置
output.file:
  path: "./output"               # 相对于filebeat执行目录
  filename: "collected-logs.log"
```

### 2.2 动态路径配置

**⚡ 使用变量实现动态路径**

```yaml
# 示例1：按日期创建文件夹
output.file:
  path: "/var/log/filebeat/%{+yyyy.MM.dd}"
  filename: "app-%{+HH}.log"

# 结果示例：
# /var/log/filebeat/2024.01.11/app-14.log
# /var/log/filebeat/2024.01.11/app-15.log

# 示例2：按日志来源分文件夹
filebeat.inputs:
- type: log
  paths:
    - /var/log/nginx/*.log
  fields:
    service: nginx
    
- type: log
  paths:
    - /var/log/mysql/*.log
  fields:
    service: mysql

output.file:
  path: "/var/log/filebeat/%{[fields.service]}"
  filename: "%{[fields.service]}-%{+yyyy.MM.dd}.log"

# 结果示例：
# /var/log/filebeat/nginx/nginx-2024.01.11.log
# /var/log/filebeat/mysql/mysql-2024.01.11.log
```

**📋 常用路径变量**

| 变量类型 | **变量格式** | **说明** | **示例结果** |
|---------|-------------|---------|-------------|
| 🔸 **年份** | `%{+yyyy}` | `四位年份` | `2024` |
| 🔸 **月份** | `%{+MM}` | `两位月份` | `01` |
| 🔸 **日期** | `%{+dd}` | `两位日期` | `11` |
| 🔸 **小时** | `%{+HH}` | `24小时制` | `14` |
| 🔸 **字段值** | `%{[字段名]}` | `自定义字段` | `nginx` |

### 2.3 路径权限和安全

**🔒 文件路径的权限配置**

```bash
# 1. 创建输出目录
sudo mkdir -p /var/log/filebeat-output

# 2. 设置合适的权限
sudo chown filebeat:filebeat /var/log/filebeat-output
sudo chmod 755 /var/log/filebeat-output

# 3. 验证权限设置
ls -la /var/log/ | grep filebeat
# drwxr-xr-x filebeat filebeat filebeat-output
```

**⚠️ 路径配置注意事项**
```
权限问题检查清单：
□ 目标目录是否存在
□ Filebeat进程是否有写入权限
□ 磁盘空间是否充足
□ 路径变量是否正确解析

常见错误及解决：
- 权限不足：调整目录权限或运行用户
- 路径不存在：确保父目录存在
- 磁盘空间不足：清理空间或更换路径
- 变量解析错误：检查变量语法
```

---

## 3. 🔄 文件轮转策略设置


### 3.1 什么是文件轮转

**🎯 文件轮转的通俗解释**

```
文件轮转就像换日记本：
当前日记本写满了 → 开始写新的日记本
旧日记本可以保留 → 也可以丢弃或压缩

文件轮转的好处：
1. 控制单个文件大小
2. 方便文件管理和查找
3. 避免磁盘空间耗尽
4. 提升文件读写性能
```

### 3.2 基于大小的轮转策略

**📏 按文件大小进行轮转**

```yaml
# 按文件大小轮转配置
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  
  # 轮转设置
  rotate_every_kb: 10240        # 10MB轮转（10240KB）
  number_of_files: 7            # 保留7个文件
  
# 轮转结果示例：
# app.log      <- 当前写入文件
# app.log.1    <- 第一个轮转文件
# app.log.2    <- 第二个轮转文件
# ...
# app.log.7    <- 最后一个，之后删除
```

**💡 不同大小单位的配置**
```yaml
# 小型应用（1MB轮转）
rotate_every_kb: 1024

# 中型应用（50MB轮转）  
rotate_every_kb: 51200

# 大型应用（100MB轮转）
rotate_every_kb: 102400

# 注意：1MB = 1024KB
```

### 3.3 基于时间的轮转策略

**⏰ 按时间间隔进行轮转**

```yaml
# 方案1：通过文件名模板实现时间轮转
output.file:
  path: "/var/log/filebeat"
  filename: "app-%{+yyyy.MM.dd-HH}.log"
  
# 结果：每小时生成一个新文件
# app-2024.01.11-14.log
# app-2024.01.11-15.log

# 方案2：日级别轮转
output.file:
  path: "/var/log/filebeat"
  filename: "app-%{+yyyy.MM.dd}.log"
  
# 结果：每天生成一个新文件
# app-2024.01.11.log
# app-2024.01.12.log
```

### 3.4 轮转文件清理策略

**🧹 自动清理旧文件**

```yaml
# 文件数量限制
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  rotate_every_kb: 10240
  number_of_files: 10           # 只保留最近10个文件

# 配合系统工具清理（推荐）
```

**🔧 使用logrotate管理轮转文件**
```bash
# 创建logrotate配置
sudo tee /etc/logrotate.d/filebeat << EOF
/var/log/filebeat/*.log {
    daily                    # 每天轮转
    rotate 30               # 保留30天
    compress                # 压缩旧文件
    delaycompress          # 延迟压缩
    missingok              # 文件不存在不报错
    notifempty             # 空文件不轮转
    create 644 filebeat filebeat  # 新文件权限
}
EOF

# 测试配置
sudo logrotate -d /etc/logrotate.d/filebeat

# 手动执行轮转
sudo logrotate -f /etc/logrotate.d/filebeat
```

---

## 4. 🔐 文件权限配置


### 4.1 文件权限基础知识

**🎯 Linux文件权限简单理解**

```
文件权限就像房门钥匙的分配：
- 读权限(r)：可以查看文件内容
- 写权限(w)：可以修改文件内容  
- 执行权限(x)：可以运行文件（对日志文件通常不需要）

权限对象：
- 所有者(owner)：文件的主人
- 用户组(group)：同组的用户
- 其他人(other)：系统上的其他用户
```

### 4.2 Filebeat文件权限配置

**🔧 权限配置选项**

```yaml
# 基础权限配置
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  
  # 文件权限设置
  permissions: 0644              # 所有者读写，其他人只读
  
# 详细权限说明：
# 0644 = rw-r--r--
# 第一位(6)：所有者权限 = 4(读) + 2(写) = 6
# 第二位(4)：用户组权限 = 4(读)
# 第三位(4)：其他人权限 = 4(读)
```

**📊 常用权限配置**

| 权限值 | **八进制** | **符号表示** | **适用场景** |
|-------|-----------|-------------|-------------|
| 🔸 **0600** | `rw-------` | `仅所有者读写` | `敏感日志文件` |
| 🔸 **0644** | `rw-r--r--` | `所有者读写，其他只读` | `普通日志文件` |
| 🔸 **0664** | `rw-rw-r--` | `所有者和组读写，其他只读` | `团队共享日志` |
| 🔸 **0666** | `rw-rw-rw-` | `所有人都可读写` | `临时调试文件` |

### 4.3 权限配置实践

**💼 实际环境权限配置**

```yaml
# 生产环境配置（安全性优先）
output.file:
  path: "/var/log/filebeat/production"
  filename: "app.log"
  permissions: 0640              # 所有者读写，组只读，其他无权限

# 开发环境配置（便利性优先）
output.file:
  path: "/var/log/filebeat/development"
  filename: "app.log"  
  permissions: 0664              # 所有者和组读写，其他只读
```

**🔒 权限安全最佳实践**
```bash
# 1. 检查当前文件权限
ls -la /var/log/filebeat/

# 2. 批量修改文件权限
find /var/log/filebeat -name "*.log" -exec chmod 644 {} \;

# 3. 设置目录权限
chmod 755 /var/log/filebeat

# 4. 验证权限设置
stat /var/log/filebeat/app.log
```

---

## 5. 📝 编码格式设置


### 5.1 编码格式基础概念

**🎯 编码格式的通俗理解**

```
编码格式就像文字的"方言"：
同样的内容，用不同编码保存会有不同的"口音"
- UTF-8：国际通用"普通话"，支持所有语言
- GBK：中文"方言"，主要支持中文
- ASCII：英文"方言"，只支持英文和基本符号

选择合适编码的重要性：
1. 确保特殊字符正确显示
2. 避免乱码问题
3. 保证数据完整性
```

### 5.2 编码格式配置

**🔧 Filebeat编码配置选项**

```yaml
# UTF-8编码配置（推荐）
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  encoding: "utf-8"              # 支持所有语言字符

# 其他编码格式
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  encoding: "gbk"                # 中文编码
  # encoding: "ascii"            # 基础英文编码
  # encoding: "iso-8859-1"       # 西欧编码
```

**📊 常用编码格式对比**

| 编码格式 | **支持语言** | **文件大小** | **兼容性** | **推荐场景** |
|---------|-------------|-------------|-----------|-------------|
| 🔸 **UTF-8** | `全部语言` | `适中` | `最佳` | `推荐使用` |
| 🔸 **GBK** | `中英文` | `较小` | `中等` | `纯中文环境` |
| 🔸 **ASCII** | `仅英文` | `最小` | `良好` | `纯英文日志` |

### 5.3 编码问题排查

**🔍 编码问题的识别和解决**

```bash
# 1. 检查文件编码
file /var/log/filebeat/app.log
# 输出示例：app.log: UTF-8 Unicode text

# 2. 查看文件内容（检查乱码）
head -n 10 /var/log/filebeat/app.log

# 3. 转换文件编码
iconv -f GBK -t UTF-8 input.log > output.log

# 4. 检查Filebeat日志中的编码错误
tail -f /var/log/filebeat/filebeat.log | grep -i encoding
```

**💡 编码配置最佳实践**
```yaml
# 最佳实践配置
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  encoding: "utf-8"              # 统一使用UTF-8
  
  # 处理编码错误
  # 如果源日志编码不统一，可以在inputs中配置
filebeat.inputs:
- type: log
  paths:
    - /var/log/app/*.log
  encoding: "utf-8"              # 指定输入编码
  exclude_lines: ['^\s*$']       # 排除空行，减少编码问题
```

---

## 6. 💾 缓冲区配置


### 6.1 缓冲区的作用原理

**🎯 缓冲区像什么**

```
缓冲区就像餐厅的传菜台：
- 厨师做好菜先放传菜台（缓冲）
- 服务员统一端菜给客人（批量处理）
- 提高效率，减少来回跑动

Filebeat缓冲区作用：
1. 暂存待写入的日志
2. 批量写入，提高性能
3. 减少磁盘I/O操作
4. 应对突发日志高峰
```

### 6.2 缓冲区大小配置

**📏 缓冲区容量设置**

```yaml
# 基础缓冲区配置
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  
  # 缓冲区设置
  bulk_max_size: 2048            # 批量处理数量（条）
  flush_interval: 1s             # 强制刷新间隔
  
# 高性能配置（大量日志）
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  bulk_max_size: 5120            # 增大批处理量
  flush_interval: 5s             # 延长刷新间隔
  
# 低延迟配置（实时性要求高）
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  bulk_max_size: 512             # 减小批处理量
  flush_interval: 100ms          # 缩短刷新间隔
```

**📊 缓冲区配置策略**

| 应用场景 | **bulk_max_size** | **flush_interval** | **特点** |
|---------|------------------|-------------------|----------|
| 🔸 **高吞吐量** | `5120-10240` | `5-10s` | `高效率，延迟较高` |
| 🔸 **平衡模式** | `2048-4096` | `1-3s` | `效率和延迟平衡` |
| 🔸 **低延迟** | `512-1024` | `100-500ms` | `低延迟，效率较低` |
| 🔸 **调试模式** | `1-10` | `1ms` | `实时输出，性能差` |

### 6.3 缓冲区监控和调优

**📊 缓冲区性能监控**

```yaml
# 启用性能监控
logging.level: info
logging.metrics.enabled: true
logging.metrics.period: 30s

# 监控指标关注点：
# - output.events：输出事件数量
# - output.write.bytes：写入字节数
# - output.write.errors：写入错误数
```

**🔧 根据监控调优缓冲区**
```bash
# 1. 查看Filebeat性能指标
curl -X GET "localhost:5066/stats"

# 2. 分析关键指标
# 如果 bulk_max_size 经常未满就刷新 → 可以增大bulk_max_size
# 如果 flush_interval 经常触发 → 可以增大 bulk_max_size 或减少 flush_interval
# 如果出现大量写入错误 → 检查磁盘性能和空间

# 3. 动态调整配置（重启后生效）
```

---

## 7. 🏷️ 文件命名模板


### 7.1 命名模板基础概念

**🎯 文件命名的重要性**

```
好的文件命名就像图书馆的分类标签：
- 一眼就能看出内容类型
- 方便查找和管理
- 避免文件名冲突
- 支持自动化处理

命名模板的优势：
1. 自动生成有意义的文件名
2. 支持时间、字段等动态变量
3. 便于后续文件管理
4. 支持批量处理脚本
```

### 7.2 时间基础的命名模板

**⏰ 使用时间变量命名**

```yaml
# 按小时命名
output.file:
  path: "/var/log/filebeat"
  filename: "app-%{+yyyy.MM.dd-HH}.log"
# 结果：app-2024.01.11-14.log

# 按天命名  
output.file:
  path: "/var/log/filebeat"
  filename: "daily-%{+yyyy.MM.dd}.log"
# 结果：daily-2024.01.11.log

# 按月命名
output.file:
  path: "/var/log/filebeat"
  filename: "monthly-%{+yyyy.MM}.log"
# 结果：monthly-2024.01.log

# 详细时间命名
output.file:
  path: "/var/log/filebeat"
  filename: "app-%{+yyyy.MM.dd_HH.mm.ss}.log"
# 结果：app-2024.01.11_14.30.25.log
```

**📅 时间变量参考表**

| 时间单位 | **变量格式** | **示例结果** | **说明** |
|---------|-------------|-------------|----------|
| 🔸 **年** | `%{+yyyy}` | `2024` | `四位年份` |
| 🔸 **月** | `%{+MM}` | `01` | `两位月份` |
| 🔸 **日** | `%{+dd}` | `11` | `两位日期` |
| 🔸 **时** | `%{+HH}` | `14` | `24小时制` |
| 🔸 **分** | `%{+mm}` | `30` | `两位分钟` |
| 🔸 **秒** | `%{+ss}` | `25` | `两位秒数` |

### 7.3 字段基础的命名模板

**🏷️ 使用自定义字段命名**

```yaml
# 基于服务名称命名
filebeat.inputs:
- type: log
  paths:
    - /var/log/nginx/*.log
  fields:
    service: nginx
    environment: production

output.file:
  path: "/var/log/filebeat"
  filename: "%{[fields.service]}-%{[fields.environment]}-%{+yyyy.MM.dd}.log"
# 结果：nginx-production-2024.01.11.log

# 基于主机名命名
output.file:
  path: "/var/log/filebeat"
  filename: "%{[host.name]}-%{[agent.name]}-%{+yyyy.MM.dd}.log"
# 结果：web-server-01-filebeat-2024.01.11.log

# 组合多个字段
output.file:
  path: "/var/log/filebeat/%{[fields.service]}"
  filename: "%{[fields.service]}-%{[host.name]}-%{+yyyy.MM.dd-HH}.log"
# 结果路径：/var/log/filebeat/nginx/nginx-web01-2024.01.11-14.log
```

### 7.4 复杂命名模板示例

**🎨 高级命名模板配置**

```yaml
# 多层目录 + 复杂命名
output.file:
  path: "/var/log/filebeat/%{+yyyy}/%{+MM}/%{[fields.service]}"
  filename: "%{[fields.service]}-%{[fields.environment]}-%{[host.name]}-%{+dd-HH}.log"

# 目录结构示例：
# /var/log/filebeat/2024/01/nginx/nginx-prod-web01-11-14.log
# /var/log/filebeat/2024/01/mysql/mysql-prod-db01-11-14.log

# 条件命名（基于字段值）
output.file:
  path: "/var/log/filebeat"
  filename: >-
    %{[fields.log_type]:app}-%{[fields.service]:unknown}-%{+yyyy.MM.dd}.log

# 说明：如果字段不存在，使用默认值
# 结果：app-nginx-2024.01.11.log 或 unknown-unknown-2024.01.11.log
```

---

## 8. 🗜️ 压缩配置选项


### 8.1 压缩的必要性

**💡 为什么需要压缩日志文件**

```
压缩就像打包行李：
- 相同的东西，压缩后占用更少空间
- 方便长期存储和传输
- 节省存储成本

日志压缩的好处：
1. 节省磁盘空间（通常可节省70-90%）
2. 减少备份传输时间
3. 降低存储成本
4. 提高归档效率
```

### 8.2 Filebeat内置压缩

**🔧 启用输出压缩**

```yaml
# 启用gzip压缩
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  codec.format:
    string: '%{[@timestamp]} %{[message]}'
  compression_level: 6           # 压缩级别 1-9

# 注意：Filebeat本身不直接支持文件压缩
# 需要配合外部工具实现
```

### 8.3 配合系统工具压缩

**🛠️ 使用logrotate实现压缩**

```bash
# logrotate配置文件
sudo tee /etc/logrotate.d/filebeat-output << EOF
/var/log/filebeat/*.log {
    daily                        # 每天轮转
    rotate 30                   # 保留30天
    compress                    # 启用压缩
    compresscmd /bin/gzip       # 压缩命令
    compressext .gz             # 压缩扩展名
    compressoptions -9          # 最高压缩比
    delaycompress              # 延迟一天压缩
    missingok                  # 文件缺失不报错
    notifempty                 # 空文件不轮转
    create 644 filebeat filebeat
    postrotate                 # 轮转后执行
        /bin/kill -HUP $(cat /var/run/filebeat.pid 2>/dev/null) 2>/dev/null || true
    endscript
}
EOF
```

**🗜️ 手动压缩脚本**
```bash
#!/bin/bash
# compress_old_logs.sh - 压缩旧日志文件

LOG_DIR="/var/log/filebeat"
DAYS_OLD=1                      # 压缩1天前的文件

# 查找并压缩旧文件
find $LOG_DIR -name "*.log" -mtime +$DAYS_OLD ! -name "*.gz" | while read file; do
    echo "压缩文件: $file"
    gzip "$file"
    echo "压缩完成: $file.gz"
done

# 删除超过30天的压缩文件
find $LOG_DIR -name "*.log.gz" -mtime +30 -delete

echo "日志压缩任务完成"
```

### 8.4 压缩效果监控

**📊 压缩效果评估**

```bash
# 1. 检查压缩比
ls -lh /var/log/filebeat/ | grep -E '\.(log|gz)$'

# 2. 计算压缩率脚本
#!/bin/bash
# calculate_compression_ratio.sh

LOG_DIR="/var/log/filebeat"

original_size=$(find $LOG_DIR -name "*.log" -exec du -cb {} + | tail -1 | cut -f1)
compressed_size=$(find $LOG_DIR -name "*.log.gz" -exec du -cb {} + | tail -1 | cut -f1)

if [ $original_size -gt 0 ]; then
    ratio=$(echo "scale=2; (1 - $compressed_size / $original_size) * 100" | bc)
    echo "压缩率: ${ratio}%"
    echo "原始大小: $(numfmt --to=iec $original_size)"
    echo "压缩后大小: $(numfmt --to=iec $compressed_size)"
fi
```

---

## 9. 📁 文件保留策略


### 9.1 文件保留策略规划

**🎯 为什么需要文件保留策略**

```
文件保留策略就像家里的物品整理：
- 决定什么东西保留多久
- 什么时候清理掉旧东西
- 平衡存储空间和数据价值

保留策略考虑因素：
1. 合规要求（法律法规要求）
2. 业务需求（故障排查需要）
3. 存储成本（磁盘空间限制）
4. 查询频率（访问热度）
```

### 9.2 基于时间的保留策略

**⏰ 时间基础的文件清理**

```yaml
# Filebeat配置中的文件数量限制
output.file:
  path: "/var/log/filebeat"
  filename: "app.log"
  rotate_every_kb: 10240         # 10MB轮转
  number_of_files: 168           # 保留168个文件（约一周）

# 配合cron任务实现时间清理
```

**🗓️ 分层保留策略配置**
```bash
# 创建分层清理脚本
#!/bin/bash
# tiered_retention.sh

LOG_DIR="/var/log/filebeat"

# 第一层：保留最近7天的原始文件
find $LOG_DIR -name "*.log" -mtime +7 -delete

# 第二层：保留最近30天的压缩文件
find $LOG_DIR -name "*.log.gz" -mtime +30 -delete

# 第三层：移动90天前的文件到归档目录
ARCHIVE_DIR="/archive/filebeat"
mkdir -p $ARCHIVE_DIR
find $LOG_DIR -name "*.log.gz" -mtime +30 -mtime -90 -exec mv {} $ARCHIVE_DIR/ \;

# 第四层：删除超过1年的归档文件
find $ARCHIVE_DIR -name "*.log.gz" -mtime +365 -delete

echo "分层保留策略执行完成"
```

### 9.3 基于大小的保留策略

**📏 磁盘空间控制策略**

```bash
#!/bin/bash
# size_based_retention.sh

LOG_DIR="/var/log/filebeat"
MAX_SIZE_GB=50                   # 最大占用50GB

# 计算当前目录大小
current_size=$(du -s $LOG_DIR | cut -f1)
current_size_gb=$(echo "scale=2; $current_size / 1024 / 1024" | bc)

echo "当前日志目录大小: ${current_size_gb}GB"

# 如果超过限制，删除最旧的文件
if (( $(echo "$current_size_gb > $MAX_SIZE_GB" | bc -l) )); then
    echo "超过大小限制，开始清理最旧的文件"
    
    # 按修改时间排序，删除最旧的文件
    while (( $(echo "$(du -s $LOG_DIR | cut -f1) / 1024 / 1024 > $MAX_SIZE_GB" | bc -l) )); do
        oldest_file=$(find $LOG_DIR -type f -printf '%T+ %p\n' | sort | head -1 | cut -d' ' -f2-)
        if [ -n "$oldest_file" ]; then
            echo "删除文件: $oldest_file"
            rm "$oldest_file"
        else
            break
        fi
    done
fi
```

### 9.4 智能保留策略

**🤖 基于业务价值的保留策略**

```bash
#!/bin/bash
# intelligent_retention.sh

LOG_DIR="/var/log/filebeat"

# 1. 保留所有错误日志更长时间
find $LOG_DIR -name "*error*" -mtime +90 -delete    # 错误日志保留90天

# 2. 保留所有访问日志较短时间  
find $LOG_DIR -name "*access*" -mtime +30 -delete   # 访问日志保留30天

# 3. 保留所有应用日志中等时间
find $LOG_DIR -name "*app*" -mtime +60 -delete      # 应用日志保留60天

# 4. 基于文件大小决定保留时间
find $LOG_DIR -name "*.log" -size +100M -mtime +7 -delete   # 大文件保留时间更短

echo "智能保留策略执行完成"
```

**📋 自动化保留策略部署**
```bash
# 1. 添加到crontab
echo "0 2 * * * /usr/local/bin/intelligent_retention.sh" | crontab -

# 2. 创建systemd服务
sudo tee /etc/systemd/system/filebeat-cleanup.service << EOF
[Unit]
Description=Filebeat Log Cleanup Service
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/intelligent_retention.sh
User=filebeat

[Install]
WantedBy=multi-user.target
EOF

# 创建定时器
sudo tee /etc/systemd/system/filebeat-cleanup.timer << EOF
[Unit]
Description=Run Filebeat Log Cleanup Daily
Requires=filebeat-cleanup.service

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOF

# 启用定时器
sudo systemctl enable filebeat-cleanup.timer
sudo systemctl start filebeat-cleanup.timer
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 文件输出：Filebeat将处理后的日志保存到本地文件的机制
🔸 路径配置：支持静态路径和动态变量，实现灵活的文件组织
🔸 文件轮转：控制单个文件大小，便于管理和性能优化
🔸 权限配置：确保文件安全性和访问控制
🔸 编码设置：处理不同字符集，避免乱码问题
🔸 缓冲配置：优化写入性能，平衡延迟和吞吐量
🔸 命名模板：使用变量创建有意义的文件名
🔸 压缩策略：节省存储空间，降低成本
🔸 保留策略：自动化清理，平衡数据价值和存储成本
```

### 10.2 关键理解要点


**🔹 文件输出的核心价值**
```
数据安全：
- 本地备份防止数据丢失
- 离线处理应对网络故障
- 长期归档满足合规要求

性能优化：
- 缓冲区配置提升写入效率
- 文件轮转避免单文件过大
- 压缩存储节省磁盘空间

运维便利：
- 动态命名便于文件管理
- 自动清理减少维护工作
- 权限控制确保数据安全
```

**🔹 配置策略的选择原则**
```
业务场景驱动：
- 高吞吐量场景：大缓冲区、延长刷新间隔
- 低延迟场景：小缓冲区、缩短刷新间隔
- 长期归档：启用压缩、规划保留策略

资源约束考虑：
- 磁盘空间限制：合理设置轮转和清理策略
- 性能要求：平衡缓冲区大小和刷新频率
- 安全要求：设置合适的文件权限

运维复杂度：
- 简单场景：使用默认配置
- 复杂环境：分层策略和自动化脚本
- 企业级：结合监控和告警
```

**🔹 最佳实践模式**
```
配置标准化：
- 统一的命名规范
- 一致的权限设置
- 标准化的保留策略

自动化管理：
- 定时清理脚本
- 监控磁盘使用
- 自动压缩归档

问题预防：
- 权限检查脚本
- 磁盘空间监控
- 配置验证工具
```

### 10.3 实际应用价值


**🎯 生产环境应用场景**
- **电商平台**：订单日志本地备份，确保交易记录完整性
- **金融系统**：操作日志长期归档，满足监管合规要求  
- **在线教育**：学习行为日志分析，支持离线数据挖掘
- **物联网**：设备日志缓存，应对网络不稳定环境

**🔧 运维实践建议**
- **渐进部署**：从简单配置开始，逐步优化复杂策略
- **监控先行**：建立磁盘空间和文件数量监控
- **自动化优先**：使用脚本和定时任务减少手动操作
- **文档完善**：记录配置决策和变更历史

**📈 技术发展趋势**
- **云存储集成**：与对象存储服务的深度集成
- **智能压缩**：基于内容特征的自适应压缩
- **AI驱动管理**：智能化的保留策略和异常检测
- **容器化支持**：更好的容器环境适配性

**核心记忆口诀**：
- 文件输出本地存，路径权限配置准
- 轮转缓冲性能优，编码命名规范清
- 压缩保留空间省，自动管理运维轻