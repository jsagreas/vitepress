---
title: 19、docker.yml.disabled配置
---
## 📚 目录

1. [Docker模块基础概念](#1-Docker模块基础概念)
2. [Docker日志类型详解](#2-Docker日志类型详解)
3. [基础配置文件详解](#3-基础配置文件详解)
4. [容器日志采集配置](#4-容器日志采集配置)
5. [Docker事件监控配置](#5-Docker事件监控配置)
6. [高级配置与优化](#6-高级配置与优化)
7. [生产环境最佳实践](#7-生产环境最佳实践)
8. [故障排查与监控](#8-故障排查与监控)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🐳 Docker模块基础概念


### 1.1 什么是Filebeat Docker模块


**🔸 通俗理解**
```
想象一下：
你有很多Docker容器在运行，每个容器都在产生日志
就像很多工人在不同车间工作，每个人都在记录工作日志
Filebeat Docker模块就像一个专门的"日志收集员"
它会自动去每个容器那里收集日志，然后统一整理

传统方式：手动去每个容器里查看日志
Docker模块：自动收集所有容器的日志到一个地方
```

**🎯 核心作用**
- **自动发现**：自动找到所有正在运行的容器
- **日志采集**：收集容器内应用产生的日志
- **事件监控**：监控容器的启动、停止、重启等事件
- **统一管理**：把分散的日志集中到一个地方

### 1.2 Docker模块的工作原理


**🔄 工作流程图**
```
Docker容器生态          Filebeat Docker模块           目标存储
┌─────────────┐        ┌──────────────────┐        ┌─────────────┐
│ 容器A日志   │───────→│  自动发现容器    │───────→│ Elasticsearch│
├─────────────┤        ├──────────────────┤        ├─────────────┤
│ 容器B日志   │───────→│  采集日志文件    │───────→│ Logstash    │
├─────────────┤        ├──────────────────┤        ├─────────────┤
│ 容器C事件   │───────→│  监控事件变化    │───────→│ Kafka       │
├─────────────┤        ├──────────────────┤        ├─────────────┤
│ Docker守护  │───────→│  解析标准化      │───────→│ 文件        │
└─────────────┘        └──────────────────┘        └─────────────┘
```

**💡 关键理解**
```
Docker API：Filebeat通过Docker API获取容器信息
日志文件：读取容器的日志文件（通常在/var/lib/docker/containers/）
实时监控：持续监控新容器的创建和销毁
自动标签：为每个容器的日志添加标识信息
```

### 1.3 Docker模块的主要数据源


**📊 数据收集范围**
```
容器日志（Container Logs）：
├─ 应用程序标准输出（stdout）
├─ 应用程序标准错误（stderr）  
├─ 容器内部日志文件
└─ 多行日志处理

容器事件（Container Events）：
├─ 容器生命周期：create、start、stop、destroy
├─ 镜像操作：pull、push、tag、untag
├─ 网络事件：connect、disconnect
├─ 卷操作：mount、unmount
└─ 健康检查：health_status变化
```

---

## 2. 📝 Docker日志类型详解


### 2.1 容器标准日志


**🔸 什么是容器标准日志**
```
简单理解：
当你的应用在容器里运行时，所有打印到屏幕的内容
都会被Docker自动保存成日志文件
这就是"标准日志"

例如：
- Python应用的print()输出
- Java应用的System.out.println()输出  
- Node.js应用的console.log()输出
- 错误信息和异常堆栈
```

**📂 日志存储位置**
```
默认路径：/var/lib/docker/containers/<容器ID>/<容器ID>-json.log

日志格式示例：
{"log":"2025-09-21 INFO Starting application\n","stream":"stdout","time":"2025-09-21T07:30:00.123456789Z"}
{"log":"2025-09-21 ERROR Database connection failed\n","stream":"stderr","time":"2025-09-21T07:30:01.234567890Z"}

字段说明：
log: 实际的日志内容
stream: stdout（正常输出）或stderr（错误输出）
time: 时间戳
```

### 2.2 容器事件日志


**🔸 什么是容器事件**
```
容器事件就像容器的"生活记录"：
- 什么时候出生（创建）
- 什么时候开始工作（启动）
- 什么时候休息（停止）
- 什么时候搬家（重启）
- 什么时候消失（删除）

这些"生活记录"对运维监控很重要
```

**📋 常见事件类型**
```
生命周期事件：
├─ create: 容器被创建
├─ start: 容器开始运行
├─ stop: 容器停止运行
├─ restart: 容器重启
├─ pause: 容器暂停
├─ unpause: 容器恢复
├─ kill: 容器被强制终止
└─ destroy: 容器被删除

健康状态事件：
├─ health_status: healthy（健康）
├─ health_status: unhealthy（不健康）
└─ health_status: starting（启动中）
```

### 2.3 Docker系统事件


**🔸 系统级别监控**
```
除了单个容器，还要监控整个Docker系统：
- 镜像的拉取和删除
- 网络的创建和销毁  
- 存储卷的挂载和卸载
- Docker守护进程的状态
```

**🌐 网络和存储事件**
```
网络事件：
├─ network create: 创建网络
├─ network connect: 容器连接到网络
├─ network disconnect: 容器断开网络
└─ network remove: 删除网络

存储事件：
├─ volume create: 创建数据卷
├─ volume mount: 挂载数据卷
├─ volume unmount: 卸载数据卷
└─ volume remove: 删除数据卷
```

---

## 3. ⚙️ 基础配置文件详解


### 3.1 Docker模块配置文件结构


**📁 配置文件位置**
```
默认路径：/etc/filebeat/modules.d/docker.yml.disabled

启用方法：
1. 重命名文件：mv docker.yml.disabled docker.yml
2. 或使用命令：filebeat modules enable docker
```

**🔧 基础配置结构**
```yaml
# Docker模块配置
- module: docker
  # 容器日志采集
  log:
    enabled: true
    var.paths: ["/var/lib/docker/containers/*/*.log"]
    var.stream: "all"
  
  # 容器事件采集  
  container_logs:
    enabled: true
    var.docker_host: "unix:///var/run/docker.sock"
```

### 3.2 容器日志配置详解


**🔸 基础日志配置**
```yaml
- module: docker
  log:
    enabled: true
    
    # 日志文件路径（关键配置）
    var.paths: 
      - "/var/lib/docker/containers/*/*.log"
      - "/var/lib/docker/containers/*/*-json.log"
    
    # 流类型选择
    var.stream: "all"  # 可选：stdout, stderr, all
    
    # 编码设置
    var.encoding: "utf-8"
    
    # 排除特定容器
    var.exclude_lines: ["^DEBUG", "^TRACE"]
```

**💡 配置说明**
```
var.paths 路径解释：
/var/lib/docker/containers/  ← Docker容器数据目录
*/                           ← 每个容器有自己的文件夹
*.log                        ← 日志文件（新版Docker）
*-json.log                   ← JSON格式日志文件（旧版）

var.stream 选项说明：
all: 收集所有输出（推荐）
stdout: 只收集标准输出
stderr: 只收集错误输出
```

### 3.3 容器发现配置


**🔍 自动发现设置**
```yaml
- module: docker
  container_logs:
    enabled: true
    
    # Docker连接设置
    var.docker_host: "unix:///var/run/docker.sock"
    
    # 容器过滤规则
    var.condition: "${docker.container.image} != 'nginx'"
    
    # 标签添加
    var.add_docker_metadata: true
    
    # 刷新间隔
    var.scan_frequency: "10s"
```

**🏷️ 标签和过滤**
```yaml
# 高级过滤配置
processors:
  # 添加Docker元数据
  - add_docker_metadata:
      host: "unix:///var/run/docker.sock"
      
  # 根据容器名过滤
  - drop_event:
      when:
        equals:
          docker.container.name: "logstash"
          
  # 添加自定义标签          
  - add_tags:
      tags: ["docker", "production"]
      when:
        equals:
          docker.container.image: "nginx"
```

---

## 4. 📦 容器日志采集配置


### 4.1 单容器日志配置


**🔸 针对特定应用的配置**
```yaml
# Web应用日志配置
- module: docker
  log:
    enabled: true
    var.paths: ["/var/lib/docker/containers/*/*.log"]
    
    # 只收集特定镜像的容器
    condition: "${docker.container.image} contains 'nginx'"
    
    # 多行日志处理（适用于Java异常堆栈）
    multiline:
      pattern: '^\d{4}-\d{2}-\d{2}'
      negate: true
      match: after
      max_lines: 500
```

**💻 不同应用类型配置示例**

> 📌 **Web服务器日志**：适用于Nginx、Apache等

```yaml
- module: docker
  log:
    enabled: true
    condition: "${docker.container.image} contains 'nginx'"
    var.stream: "stdout"
    
    # Nginx访问日志格式解析
    processors:
      - dissect:
          tokenizer: '%{client_ip} - - [%{timestamp}] "%{method} %{url} %{http_version}" %{status_code} %{bytes}'
          field: "message"
```

> 📌 **应用程序日志**：适用于Java、Python、Node.js应用

```yaml
- module: docker  
  log:
    enabled: true
    condition: "${docker.container.image} contains 'java-app'"
    
    # Java异常堆栈处理
    multiline:
      pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'
      negate: true
      match: after
      max_lines: 1000
```

### 4.2 多容器统一配置


**🏢 微服务架构日志配置**
```yaml
filebeat.inputs:
# 所有微服务容器日志
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
    
  # 容器过滤条件
  condition: >
    ${docker.container.labels.app} != null and
    ${docker.container.labels.environment} == "production"
    
  # 为不同服务添加字段
  processors:
    # 添加服务名称
    - add_fields:
        target: service
        fields:
          name: "${docker.container.labels.app}"
          version: "${docker.container.labels.version}"
          environment: "${docker.container.labels.environment}"
          
    # 解析JSON格式日志
    - decode_json_fields:
        fields: ["message"]
        target: "json"
        when:
          contains:
            message: "{"
```

**🎯 标签驱动的配置**
```yaml
# 基于Docker标签的智能配置
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
    
  # 根据标签选择处理方式
  processors:
    # Web服务日志处理
    - if:
        equals:
          docker.container.labels.log_type: "web"
      then:
        - dissect:
            tokenizer: '%{timestamp} %{level} %{message}'
            field: "message"
            
    # 数据库日志处理
    - if:
        equals:
          docker.container.labels.log_type: "database"  
      then:
        - multiline:
            pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'
            negate: true
            match: after
```

### 4.3 日志解析和处理


**🔍 JSON日志解析**
```yaml
processors:
  # 解析JSON格式的容器日志
  - decode_json_fields:
      fields: ["message"]
      target: "app"
      max_depth: 3
      
  # 提取关键字段
  - copy_fields:
      fields:
        - from: "app.level"
          to: "log.level"
        - from: "app.timestamp"  
          to: "@timestamp"
          
  # 删除原始message（可选）
  - drop_fields:
      fields: ["message"]
      when:
        has_fields: ["app.level"]
```

**🔧 多行日志处理**
```yaml
# Java应用异常堆栈
multiline:
  pattern: '^[[:space:]]+(at|\.{3})[[:space:]]+\b|^Caused by:'
  negate: false
  match: after
  max_lines: 500
  timeout: 5s

# Python应用异常处理  
multiline:
  pattern: '^Traceback|^[[:space:]]+File|^[[:space:]]+[^[:space:]]'
  negate: false  
  match: after
  max_lines: 200
```

---

## 5. 📊 Docker事件监控配置


### 5.1 基础事件监控设置


**🔸 什么是Docker事件监控**
```
简单理解：
Docker事件就像监控摄像头，记录容器的所有"动作"
- 容器启动了：事件
- 容器停止了：事件  
- 容器重启了：事件
- 容器死掉了：事件

这些事件信息对故障诊断和运维监控很重要
```

**⚙️ 基础事件配置**
```yaml
- module: docker
  # 容器事件采集
  container_logs:
    enabled: false  # 如果只要事件，可以关闭日志采集
    
  # Docker事件流
  dockerevent:
    enabled: true
    var.docker_host: "unix:///var/run/docker.sock"
    
    # 事件过滤
    var.event_types: ["container", "image", "network", "volume"]
    
    # 连接超时设置
    var.timeout: "30s"
```

### 5.2 容器生命周期监控


**🔄 生命周期事件配置**
```yaml
- type: docker
  # Docker socket连接
  hosts: ["unix:///var/run/docker.sock"]
  
  # 只监控容器事件
  event_types: ["container"]
  
  # 监控的具体动作
  actions: ["start", "stop", "restart", "die", "kill", "pause", "unpause"]
  
  # 添加处理器
  processors:
    # 为事件添加时间戳
    - timestamp:
        field: "@timestamp"
        layouts:
          - "2006-01-02T15:04:05.999999999Z"
          
    # 添加告警级别
    - add_fields:
        target: alert
        fields:
          level: "info"
        when:
          or:
            - equals.docker.action: "start"
            - equals.docker.action: "stop"
            
    - add_fields:
        target: alert  
        fields:
          level: "warning"
        when:
          or:
            - equals.docker.action: "die"
            - equals.docker.action: "kill"
```

**📈 事件统计和分析**
```yaml
processors:
  # 统计容器重启次数
  - script:
      lang: javascript
      source: >
        function process(event) {
          if (event.Get("docker.action") === "restart") {
            var container = event.Get("docker.container.name");
            // 可以结合外部存储来统计重启次数
            event.Put("container.restart_count", 1);
          }
        }
        
  # 监控频繁重启的容器      
  - drop_event:
      when:
        and:
          - equals.docker.action: "start"
          - range.container.restart_count.gte: 5
```

### 5.3 健康检查监控


**🏥 容器健康状态监控**
```yaml
- type: docker
  hosts: ["unix:///var/run/docker.sock"]
  
  # 专门监控健康检查事件
  event_types: ["container"]
  actions: ["health_status"]
  
  processors:
    # 解析健康状态
    - if:
        equals.docker.action: "health_status"
      then:
        - add_fields:
            target: health
            fields:
              container: "${docker.container.name}"
              image: "${docker.container.image}"
              status: "${docker.attributes.exitCode}"
              
    # 健康状态告警
    - add_fields:
        target: alert
        fields:
          severity: "critical"
          message: "Container ${docker.container.name} is unhealthy"
        when:
          and:
            - equals.docker.action: "health_status"
            - equals.docker.attributes.exitCode: "1"
```

### 5.4 镜像和网络事件监控


**🖼️ 镜像操作监控**
```yaml
- type: docker
  hosts: ["unix:///var/run/docker.sock"]
  
  # 监控镜像相关事件
  event_types: ["image"]
  actions: ["pull", "push", "tag", "untag", "delete"]
  
  processors:
    # 记录镜像操作
    - add_fields:
        target: image_ops
        fields:
          operation: "${docker.action}"
          image_id: "${docker.id}"
          repository: "${docker.attributes.name}"
          
    # 大镜像下载告警
    - add_fields:
        target: alert
        fields:
          type: "image_download"
          size: "${docker.attributes.size}"
        when:
          and:
            - equals.docker.action: "pull"
            - range.docker.attributes.size.gte: 1073741824  # 1GB
```

**🌐 网络事件监控**
```yaml
- type: docker
  hosts: ["unix:///var/run/docker.sock"]
  
  # 网络事件监控
  event_types: ["network"]
  actions: ["create", "connect", "disconnect", "destroy"]
  
  processors:
    # 网络连接变化追踪
    - add_fields:
        target: network
        fields:
          action: "${docker.action}"
          network_name: "${docker.attributes.name}"
          network_id: "${docker.id}"
          container: "${docker.actor.attributes.container}"
```

---

## 6. 🚀 高级配置与优化


### 6.1 性能优化配置


**⚡ 采集性能优化**
```yaml
filebeat.inputs:
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
    
  # 性能优化设置
  scan_frequency: 10s          # 扫描频率
  harvester_buffer_size: 16384 # 读取缓冲区大小
  max_bytes: 10485760         # 单个日志行最大字节数(10MB)
  close_inactive: 5m          # 非活跃文件关闭时间
  close_removed: true         # 删除文件时关闭
  clean_removed: true         # 清理已删除文件的状态
  
  # 忽略旧文件
  ignore_older: 24h
  
  # 减少磁盘IO
  tail_files: true            # 只读取新内容
```

**💾 内存和CPU优化**
```yaml
# 全局性能设置
output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # 批量发送优化
  bulk_max_size: 3200
  flush_interval: 30s
  worker: 2
  
# 队列设置
queue.mem:
  events: 4096
  flush.min_events: 512
  flush.timeout: 5s

# 处理器优化
processors:
  # 限制字段数量
  - drop_fields:
      fields: ["agent", "ecs", "host.architecture"]
      
  # 压缩重复信息
  - fingerprint:
      fields: ["message", "docker.container.name"]
      target_field: "fingerprint"
```

### 6.2 多环境配置管理


**🏢 生产环境配置**
```yaml
# 生产环境严格配置
filebeat.inputs:
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
    
  # 只采集生产容器
  condition: "${docker.container.labels.environment} == 'production'"
  
  # 严格的日志级别过滤
  exclude_lines: ['^DEBUG', '^TRACE', '^INFO.*health']
  include_lines: ['^ERROR', '^WARN', '^FATAL']
  
  processors:
    # 敏感信息脱敏
    - script:
        lang: javascript
        source: >
          function process(event) {
            var msg = event.Get("message");
            if (msg) {
              // 脱敏处理
              msg = msg.replace(/password=\S+/g, "password=***");
              msg = msg.replace(/token=\S+/g, "token=***");
              event.Put("message", msg);
            }
          }
          
    # 添加环境标识
    - add_fields:
        target: environment
        fields:
          name: "production"
          datacenter: "dc1"
```

**🧪 开发测试环境配置**
```yaml
# 开发环境宽松配置
filebeat.inputs:
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
    
  # 采集所有非生产容器
  condition: "${docker.container.labels.environment} != 'production'"
  
  # 包含详细日志
  include_lines: ['^DEBUG', '^INFO', '^WARN', '^ERROR']
  
  # 详细的元数据
  processors:
    - add_docker_metadata:
        host: "unix:///var/run/docker.sock"
        match_fields: ["container.id"]
        
    # 开发环境标识
    - add_fields:
        target: environment
        fields:
          name: "development"
          debug: true
```

### 6.3 安全配置


**🔒 权限和安全设置**
```yaml
# Docker socket安全访问
filebeat.inputs:
- type: docker
  hosts: ["unix:///var/run/docker.sock"]
  
  # TLS安全连接（远程Docker）
  ssl.enabled: true
  ssl.certificate_authorities: ["/path/to/ca.pem"]
  ssl.certificate: "/path/to/cert.pem"  
  ssl.key: "/path/to/key.pem"
  
  # 访问控制
  processors:
    # 只允许特定标签的容器
    - drop_event:
        when:
          not:
            has_fields: ["docker.container.labels.filebeat_enabled"]
            
    # 敏感容器排除
    - drop_event:
        when:
          or:
            - contains.docker.container.image: "database"
            - contains.docker.container.image: "redis"
            - equals.docker.container.labels.security: "high"
```

**🛡️ 数据脱敏处理**
```yaml
processors:
  # 通用敏感信息脱敏
  - script:
      lang: javascript
      source: >
        function process(event) {
          var message = event.Get("message");
          if (message) {
            // IP地址脱敏
            message = message.replace(/\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/g, "xxx.xxx.xxx.xxx");
            
            // 邮箱脱敏  
            message = message.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, "***@***.***");
            
            // 手机号脱敏
            message = message.replace(/\b1[3-9]\d{9}\b/g, "138****1234");
            
            event.Put("message", message);
          }
        }
```

---

## 7. 🏭 生产环境最佳实践


### 7.1 大规模部署配置


**🏢 企业级部署架构**
```
负载分散架构：

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Docker节点1   │    │   Docker节点2   │    │   Docker节点N   │
│   ┌─────────┐   │    │   ┌─────────┐   │    │   ┌─────────┐   │
│   │Filebeat │   │    │   │Filebeat │   │    │   │Filebeat │   │
│   └─────────┘   │    │   └─────────┘   │    │   └─────────┘   │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          └─────────────┬────────────────┬──────────────┘
                        │                │
                ┌───────▼──────┐  ┌──────▼──────┐
                │   Logstash   │  │    Kafka    │
                │   (处理层)    │  │  (消息队列)  │
                └───────┬──────┘  └──────┬──────┘
                        │                │
                        └────────┬───────┘
                                 │
                        ┌────────▼──────┐
                        │ Elasticsearch │
                        │   (存储层)     │
                        └───────────────┘
```

**📊 分布式配置示例**
```yaml
# 节点级别配置
filebeat.inputs:
- type: container
  paths:
    - '/var/lib/docker/containers/*/*.log'
    
  # 添加节点标识
  processors:
    - add_fields:
        target: node
        fields:
          hostname: "${hostname}"
          datacenter: "dc1"
          rack: "rack-a1"
          
    # 负载均衡标记
    - add_fields:
        target: routing
        fields:
          shard_key: "${docker.container.name}"

# 输出到Kafka进行缓冲
output.kafka:
  hosts: ["kafka1:9092", "kafka2:9092", "kafka3:9092"]
  topic: "docker-logs-%{+yyyy.MM.dd}"
  
  # 分区策略
  partition.hash:
    reachable_only: true
    hash: ["docker.container.name"]
    
  # 高可用配置
  required_acks: 1
  max_message_bytes: 1000000
```

### 7.2 监控和告警配置


**📊 关键指标监控**
```yaml
# 监控配置
monitoring:
  enabled: true
  
  # 自定义指标
  processors:
    # 统计日志量
    - add_fields:
        target: metrics
        fields:
          log_bytes: "${event.size}"
          container_name: "${docker.container.name}"
          
    # 错误日志计数
    - add_fields:
        target: metrics
        fields:
          error_count: 1
        when:
          or:
            - contains.message: "ERROR"
            - contains.message: "FATAL"
            - contains.message: "Exception"

# 告警规则
processors:
  # 容器异常重启告警
  - if:
      and:
        - equals.docker.action: "start"
        - script:
            lang: javascript
            source: >
              // 检查容器在短时间内的重启次数
              function process(event) {
                var container = event.Get("docker.container.name");
                // 这里需要结合外部存储来实现复杂逻辑
                return true;
              }
    then:
      - add_fields:
          target: alert
          fields:
            type: "container_restart"
            severity: "warning"
            message: "Container ${docker.container.name} restarted frequently"
```

**🚨 实时告警配置**
```yaml
# 错误日志实时告警
- type: container
  condition: >
    contains(message, "FATAL") or 
    contains(message, "OutOfMemoryError") or
    contains(message, "Connection refused")
    
  processors:
    # 立即告警处理
    - add_fields:
        target: alert
        fields:
          timestamp: "${@timestamp}"
          severity: "critical"
          source_container: "${docker.container.name}"
          source_image: "${docker.container.image}"
          error_message: "${message}"
          
# 输出到告警系统
output.http:
  hosts: ["http://alert-manager:9093/api/v1/alerts"]
  headers:
    Content-Type: "application/json"
  when:
    has_fields: ["alert.severity"]
```

### 7.3 日志轮转和存储管理


**🗄️ 存储优化配置**
```yaml
# 基于时间的索引策略
output.elasticsearch:
  hosts: ["es1:9200", "es2:9200", "es3:9200"]
  
  # 动态索引名称
  index: "docker-logs-%{+yyyy.MM.dd}"
  
  # 索引模板
  template.settings:
    index:
      number_of_shards: 3
      number_of_replicas: 1
      # 7天后删除
      lifecycle.name: "docker-logs-policy"
      
  # ILM策略
  ilm:
    enabled: true
    rollover_alias: "docker-logs"
    pattern: "000001"
    policy: "docker-logs-policy"

# 本地文件轮转
output.file:
  path: "/var/log/filebeat"
  filename: "docker-logs"
  
  # 文件轮转设置
  rotate_every_kb: 100000    # 100MB轮转
  number_of_files: 7         # 保留7个文件
  permissions: 0644
```

**🧹 清理策略配置**
```yaml
# 清理脚本集成
processors:
  # 标记需要清理的日志
  - add_fields:
      target: cleanup
      fields:
        retention_days: 30
        priority: "low"
      when:
        and:
          - contains.docker.container.labels.app: "test"
          - not.contains.message: "ERROR"
          
  # 重要日志延长保留
  - add_fields:
      target: cleanup  
      fields:
        retention_days: 90
        priority: "high"
      when:
        or:
          - contains.message: "ERROR"
          - contains.message: "FATAL"
          - equals.docker.container.labels.critical: "true"
```

---

## 8. 🔍 故障排查与监控


### 8.1 常见问题诊断


**❌ 连接问题排查**
```bash
# 检查Docker socket权限
ls -la /var/run/docker.sock
# 输出应该显示：srw-rw---- 1 root docker

# 测试Docker API连接
curl --unix-socket /var/run/docker.sock http://localhost/version

# 检查Filebeat用户权限
id filebeat
# 确保filebeat用户在docker组中

# 添加用户到docker组
sudo usermod -a -G docker filebeat
```

**🔧 配置验证方法**
```bash
# 验证配置文件语法
filebeat test config -c /etc/filebeat/filebeat.yml

# 测试输出连接
filebeat test output -c /etc/filebeat/filebeat.yml

# 检查模块状态
filebeat modules list

# 详细调试模式
filebeat -e -d "docker" -c /etc/filebeat/filebeat.yml
```

### 8.2 性能问题分析


**📊 性能监控指标**
```yaml
# 内置监控配置
monitoring:
  enabled: true
  elasticsearch:
    hosts: ["localhost:9200"]
    index: "filebeat-monitoring"
    
# 性能统计
processors:
  - add_fields:
      target: performance
      fields:
        processing_time: "${event.processing_time}"
        queue_size: "${queue.size}"
        harvester_count: "${harvester.running}"
        
# 瓶颈检测
- script:
    lang: javascript
    source: >
      function process(event) {
        var queueSize = event.Get("queue.size");
        if (queueSize && queueSize > 1000) {
          event.Put("performance.bottleneck", "queue_full");
        }
        
        var processingTime = event.Get("event.processing_time");
        if (processingTime && processingTime > 5000) {
          event.Put("performance.bottleneck", "slow_processing");
        }
      }
```

**⚡ 性能优化检查清单**
```yaml
# 性能检查配置模板
performance_check:
  # CPU使用率检查
  cpu_threshold: 80
  
  # 内存使用检查  
  memory_threshold: 85
  
  # 队列深度检查
  queue_threshold: 500
  
  # 网络延迟检查
  network_latency_threshold: 100ms
  
  # 磁盘IO检查
  disk_io_threshold: 80
```

### 8.3 日志质量监控


**📈 日志质量指标**
```yaml
processors:
  # 日志格式检查
  - script:
      lang: javascript
      source: >
        function process(event) {
          var message = event.Get("message");
          var quality = {
            has_timestamp: false,
            has_level: false,
            has_structured_data: false,
            format_score: 0
          };
          
          if (message) {
            // 检查时间戳
            if (message.match(/\d{4}-\d{2}-\d{2}/)) {
              quality.has_timestamp = true;
              quality.format_score += 30;
            }
            
            // 检查日志级别
            if (message.match(/(DEBUG|INFO|WARN|ERROR|FATAL)/)) {
              quality.has_level = true;
              quality.format_score += 30;
            }
            
            // 检查结构化数据
            if (message.match(/^\{.*\}$/)) {
              quality.has_structured_data = true;
              quality.format_score += 40;
            }
          }
          
          event.Put("log_quality", quality);
        }
        
  # 异常日志检测
  - add_fields:
      target: anomaly
      fields:
        type: "malformed_log"
        score: 0
      when:
        script:
          lang: javascript
          source: >
            function process(event) {
              var quality = event.Get("log_quality.format_score");
              return quality && quality < 30;
            }
```

**🎯 质量改进建议**
```yaml
# 质量建议生成
processors:
  - script:
      lang: javascript
      source: >
        function process(event) {
          var quality = event.Get("log_quality");
          var suggestions = [];
          
          if (!quality.has_timestamp) {
            suggestions.push("Add timestamp to log format");
          }
          
          if (!quality.has_level) {
            suggestions.push("Include log level in messages");
          }
          
          if (!quality.has_structured_data) {
            suggestions.push("Consider using structured logging (JSON)");
          }
          
          if (suggestions.length > 0) {
            event.Put("quality_suggestions", suggestions);
          }
        }
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 Docker模块本质：专门用来收集Docker容器日志和事件的Filebeat模块
🔸 两大数据源：容器日志（应用输出）和容器事件（生命周期变化）
🔸 自动发现：通过Docker API自动发现容器，无需手动配置每个容器
🔸 元数据丰富：自动添加容器名称、镜像、标签等元数据信息
🔸 实时监控：可以实时监控容器的启动、停止、重启等事件
```

### 9.2 关键配置要点


**🔹 路径配置**
```
容器日志路径：/var/lib/docker/containers/*/*.log
Docker socket：unix:///var/run/docker.sock
权限要求：filebeat用户需要在docker组中
配置文件：/etc/filebeat/modules.d/docker.yml
```

**🔹 过滤和处理**
```
条件过滤：基于容器标签、镜像名称过滤
多行处理：处理Java异常堆栈等多行日志
JSON解析：解析应用程序的JSON格式日志
敏感信息：生产环境需要脱敏处理
```

**🔹 性能优化**
```
批量发送：配置合适的bulk_max_size
内存队列：设置合理的队列大小
文件监控：控制scan_frequency降低IO
索引策略：按时间分片，设置生命周期管理
```

### 9.3 生产环境最佳实践


**🏭 架构设计**
- **分层部署**：Filebeat → Kafka/Logstash → Elasticsearch
- **负载均衡**：多个Filebeat实例分担负载
- **高可用**：多副本配置，故障自动切换
- **监控告警**：实时监控采集状态和性能指标

**🔒 安全考虑**
- **权限控制**：最小权限原则，只读Docker socket
- **数据脱敏**：敏感信息自动脱敏处理
- **传输加密**：TLS加密传输日志数据
- **访问控制**：基于标签控制采集范围

**📊 运维管理**
- **存储规划**：合理的日志保留策略
- **性能调优**：根据容器数量调整配置
- **故障恢复**：完善的备份和恢复机制
- **容量规划**：预估日志量和存储需求

### 9.4 学习进阶路径


**⭐ 基础阶段**：
- [ ] 理解Docker日志机制
- [ ] 掌握基础配置语法
- [ ] 学会启用和禁用模块
- [ ] 熟悉常见故障排查

**⭐⭐ 进阶阶段**：
- [ ] 掌握复杂过滤规则
- [ ] 学会多行日志处理
- [ ] 理解元数据添加机制
- [ ] 掌握性能优化技巧

**⭐⭐⭐ 高级阶段**：
- [ ] 大规模集群部署
- [ ] 自定义处理器开发
- [ ] 监控和告警系统集成
- [ ] 安全和合规性配置

**核心记忆口诀**：
- Docker模块收日志，容器事件全监控
- 自动发现加标签，过滤处理要配好  
- 性能优化抓重点，安全脱敏不可少
- 生产部署需谨慎，监控告警要做好