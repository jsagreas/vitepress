---
title: 26、auth-basic.yml基础认证配置
---
## 📚 目录

1. [安全认证基础概念](#1-安全认证基础概念)
2. [基础用户名密码认证](#2-基础用户名密码认证)
3. [API密钥认证配置](#3-API密钥认证配置)
4. [认证头与Token配置](#4-认证头与Token配置)
5. [认证超时与重试机制](#5-认证超时与重试机制)
6. [认证缓存优化配置](#6-认证缓存优化配置)
7. [多环境认证管理](#7-多环境认证管理)
8. [密码安全存储最佳实践](#8-密码安全存储最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 安全认证基础概念


### 1.1 什么是Filebeat安全认证


**简单理解**：认证就像是门卫检查身份证一样，确保只有合法用户才能访问Elasticsearch

```
日常生活类比：
进入公司大楼 → 需要工卡刷卡
访问银行账户 → 需要密码验证
使用手机APP → 需要指纹或面部识别

Filebeat认证：
发送日志数据 → 需要用户名密码
调用ES API → 需要API密钥
传输安全数据 → 需要证书验证
```

### 1.2 为什么需要认证配置


**🔸 安全保护**
- 防止未授权访问：避免陌生人查看敏感日志
- 数据完整性：确保日志数据不被篡改
- 访问控制：不同用户看到不同级别的数据

**🔸 合规要求**
- 企业安全规范：公司要求所有系统都要有认证
- 法律法规：某些行业必须保护用户隐私数据
- 审计需求：记录谁在什么时候访问了什么数据

### 1.3 Filebeat支持的认证方式


```
认证方式对比：

┌─────────────────┬──────────────┬──────────────┬────────────────┐
│   认证方式       │   安全级别   │   配置难度   │     适用场景    │
├─────────────────┼──────────────┼──────────────┼────────────────┤
│ 用户名密码       │      中      │     简单     │   开发测试环境  │
│ API密钥         │      高      │     中等     │   生产环境     │
│ TLS证书         │     很高     │     复杂     │   高安全要求   │
│ OAuth2          │     很高     │     复杂     │   企业集成     │
└─────────────────┴──────────────┴──────────────┴────────────────┘
```

---

## 2. 👤 基础用户名密码认证


### 2.1 基本概念理解


**什么是用户名密码认证**：就像登录网站一样，输入账号和密码验证身份

**工作原理**：
```
用户操作流程：
1. 管理员在ES中创建用户账号
2. 在Filebeat配置文件中填写用户名和密码
3. Filebeat连接ES时自动提供认证信息
4. ES验证通过后允许数据传输

认证验证过程：
Filebeat → "我是admin用户，密码是123456" → Elasticsearch
Elasticsearch → "验证成功，允许发送数据" → Filebeat
```

### 2.2 基础配置示例


```yaml
# filebeat.yml - 基础用户名密码配置
filebeat.inputs:
- type: log
  paths:
    - /var/log/app/*.log

# Elasticsearch输出配置
output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # 基础认证配置
  username: "filebeat_user"
  password: "your_secure_password"
  
  # 指定索引模板
  index: "filebeat-%{+yyyy.MM.dd}"
```

**配置说明**：
- `username`：在Elasticsearch中创建的用户名
- `password`：对应用户的密码
- `hosts`：ES集群的地址列表

### 2.3 在Elasticsearch中创建用户


**步骤1：创建角色**
```bash
# 创建专门用于Filebeat的角色
curl -X POST "localhost:9200/_security/role/filebeat_writer" \
-H "Content-Type: application/json" -d'
{
  "cluster": ["monitor", "manage_index_templates"],
  "indices": [
    {
      "names": ["filebeat-*"],
      "privileges": ["write", "create_index", "create"]
    }
  ]
}'
```

**步骤2：创建用户**
```bash
# 创建用户并分配角色
curl -X POST "localhost:9200/_security/user/filebeat_user" \
-H "Content-Type: application/json" -d'
{
  "password": "your_secure_password",
  "roles": ["filebeat_writer"],
  "full_name": "Filebeat Service Account"
}'
```

### 2.4 密码安全注意事项


**🔸 密码强度要求**
```
推荐密码格式：
✅ 长度至少12位
✅ 包含大小写字母、数字、特殊字符
✅ 定期更换（建议3个月）
✅ 不使用默认密码

避免的密码：
❌ 123456、password等简单密码
❌ 与用户名相同
❌ 公司名称、生日等可猜测信息
```

**🔸 配置文件保护**
```bash
# 设置配置文件权限，只有root用户可读写
chmod 600 /etc/filebeat/filebeat.yml
chown root:root /etc/filebeat/filebeat.yml

# 验证权限设置
ls -la /etc/filebeat/filebeat.yml
# 应该显示：-rw------- 1 root root
```

---

## 3. 🔑 API密钥认证配置


### 3.1 API密钥认证原理


**什么是API密钥**：把它想象成一张专用的通行证，比用户名密码更安全

**优势对比**：
```
用户名密码 vs API密钥：

用户名密码：
😔 密码可能被猜测或泄露
😔 需要定期手动更换
😔 权限范围较难精确控制

API密钥：
😊 随机生成，无法猜测
😊 可以设置自动过期
😊 可以精确限制访问权限
😊 可以随时撤销
```

### 3.2 创建API密钥


**步骤1：通过Kibana创建**
```
操作路径：
1. 登录Kibana管理界面
2. 进入 Stack Management → Security → API Keys
3. 点击 "Create API key"
4. 填写名称和权限设置
5. 复制生成的密钥ID和Secret
```

**步骤2：通过命令行创建**
```bash
# 创建API密钥
curl -X POST "localhost:9200/_security/api_key" \
-u "elastic:your_password" \
-H "Content-Type: application/json" -d'
{
  "name": "filebeat-api-key",
  "expiration": "30d",
  "role_descriptors": {
    "filebeat_writer": {
      "cluster": ["monitor"],
      "index": [
        {
          "names": ["filebeat-*"],
          "privileges": ["write", "create_index"]
        }
      ]
    }
  }
}'
```

**返回结果示例**：
```json
{
  "id": "VuaCfGcBCdbkQm-e5aOx",
  "name": "filebeat-api-key",
  "api_key": "ui2lp2axTNmsyakw9tvNnw"
}
```

### 3.3 API密钥配置方式


**方式1：直接配置ID和Secret**
```yaml
# filebeat.yml - API密钥配置
output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # API密钥认证
  api_key: "VuaCfGcBCdbkQm-e5aOx:ui2lp2axTNmsyakw9tvNnw"
  
  index: "filebeat-%{+yyyy.MM.dd}"
```

**方式2：使用环境变量**
```yaml
# filebeat.yml
output.elasticsearch:
  hosts: ["localhost:9200"]
  api_key: "${ES_API_KEY}"
  index: "filebeat-%{+yyyy.MM.dd}"
```

```bash
# 设置环境变量
export ES_API_KEY="VuaCfGcBCdbkQm-e5aOx:ui2lp2axTNmsyakw9tvNnw"

# 启动Filebeat
./filebeat -e
```

### 3.4 API密钥管理最佳实践


**🔸 密钥轮换策略**
```yaml
# 配置多个API密钥实现平滑轮换
output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # 主密钥
  api_key: "${CURRENT_API_KEY}"
  
  # 备用配置
  headers:
    Authorization: "ApiKey ${BACKUP_API_KEY}"
```

**🔸 权限最小化原则**
```json
{
  "name": "filebeat-minimal",
  "role_descriptors": {
    "filebeat_only": {
      "cluster": [],
      "index": [
        {
          "names": ["filebeat-*"],
          "privileges": ["write", "create_index"],
          "field_security": {
            "grant": ["*"]
          }
        }
      ]
    }
  }
}
```

---

## 4. 🏷️ 认证头与Token配置


### 4.1 HTTP认证头基础


**什么是认证头**：就像在信封上写收件人地址一样，告诉服务器"我是谁"

**常见认证头类型**：
```
认证头格式对比：

Basic认证：
Authorization: Basic YWRtaW46cGFzc3dvcmQ=
↑ 用户名密码的Base64编码

Bearer Token：
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
↑ JWT或OAuth令牌

API Key：
Authorization: ApiKey VuaCfGcBCdbkQm-e5aOx:ui2lp2axTNmsyakw9tvNnw
↑ Elasticsearch API密钥

自定义头：
X-API-Key: your-custom-api-key
↑ 第三方服务的专用头
```

### 4.2 自定义认证头配置


**基础自定义头配置**
```yaml
# filebeat.yml - 自定义认证头
output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # 自定义HTTP头
  headers:
    Authorization: "Bearer your-jwt-token"
    X-Custom-Auth: "your-custom-value"
    X-Client-ID: "filebeat-client-001"
```

**动态Token配置**
```yaml
# 支持环境变量的Token配置
output.elasticsearch:
  hosts: ["localhost:9200"]
  
  headers:
    Authorization: "Bearer ${JWT_TOKEN}"
    X-Tenant-ID: "${TENANT_ID}"
    X-Environment: "${DEPLOYMENT_ENV}"
```

### 4.3 JWT Token集成


**JWT Token获取流程**
```
JWT认证流程图：

应用程序              认证服务器              Elasticsearch
   |                      |                      |
   |--[1]请求Token-------->|                      |
   |   (用户名+密码)        |                      |
   |<-[2]返回JWT Token-----|                      |
   |                      |                      |
   |--[3]使用Token发送数据---------------->|      |
   |   Authorization: Bearer JWT_TOKEN     |      |
   |<-[4]验证成功，接收数据----------------|      |
```

**JWT Token配置示例**
```yaml
# filebeat.yml - JWT Token配置
filebeat.inputs:
- type: log
  paths:
    - /var/log/app/*.log

output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # JWT Token认证
  headers:
    Authorization: "Bearer ${JWT_TOKEN}"
    Content-Type: "application/json"
  
  # Token刷新配置
  timeout: 30s
  max_retries: 3
```

### 4.4 多种认证方式组合


**混合认证配置**
```yaml
# 同时支持多种认证方式
output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # 主要认证方式
  api_key: "${PRIMARY_API_KEY}"
  
  # 额外认证头
  headers:
    X-Client-Certificate: "${CLIENT_CERT_FINGERPRINT}"
    X-Request-ID: "${FILEBEAT_REQUEST_ID}"
    X-Source-IP: "${HOST_IP}"
  
  # SSL证书认证
  ssl.certificate: "/path/to/client.crt"
  ssl.key: "/path/to/client.key"
```

---

## 5. ⏱️ 认证超时与重试机制


### 5.1 认证超时配置原理


**为什么需要超时设置**：就像排队买票有时间限制一样，避免无限等待

**超时机制说明**：
```
认证超时场景：

网络延迟：
请求发出 → 网络拥堵 → 响应延迟 → 超时重试

服务器负载：
认证请求 → 服务器繁忙 → 处理缓慢 → 超时保护

连接问题：
建立连接 → 防火墙阻拦 → 连接失败 → 重试机制
```

### 5.2 基础超时配置


```yaml
# filebeat.yml - 认证超时配置
output.elasticsearch:
  hosts: ["localhost:9200"]
  username: "filebeat_user"
  password: "your_password"
  
  # 连接超时设置
  timeout: 90s              # 总体超时时间
  dial_timeout: 30s         # 连接建立超时
  
  # 认证相关超时
  headers:
    Connection: "keep-alive"
    Keep-Alive: "timeout=300, max=1000"
```

**超时时间设置建议**：
```
环境类型建议：

本地测试：
timeout: 30s     # 快速反馈
dial_timeout: 10s

内网环境：
timeout: 60s     # 网络稳定
dial_timeout: 20s

跨网络/云环境：
timeout: 120s    # 考虑网络延迟
dial_timeout: 30s

高负载环境：
timeout: 180s    # 给服务器更多处理时间
dial_timeout: 60s
```

### 5.3 重试机制配置


**基础重试配置**
```yaml
# filebeat.yml - 重试机制配置
output.elasticsearch:
  hosts: ["localhost:9200"]
  api_key: "${ES_API_KEY}"
  
  # 重试设置
  max_retries: 5           # 最大重试次数
  backoff.init: 1s         # 初始重试间隔
  backoff.max: 60s         # 最大重试间隔
  
  # 批量发送配置
  bulk_max_size: 50        # 单批最大事件数
  worker: 2                # 并发工作线程数
```

**智能重试策略**
```yaml
# 高级重试配置
output.elasticsearch:
  hosts: ["localhost:9200"]
  api_key: "${ES_API_KEY}"
  
  # 指数退避重试
  max_retries: 10
  backoff.init: 2s
  backoff.max: 300s        # 5分钟最大间隔
  
  # 错误处理
  timeout: 90s
  headers:
    Connection: "close"     # 认证失败时关闭连接
```

### 5.4 认证失败处理策略


**认证错误分类处理**
```yaml
# 不同错误的处理策略
logging.level: info
logging.to_files: true
logging.files:
  path: /var/log/filebeat
  name: filebeat
  keepfiles: 7
  permissions: 0644

# 在配置中添加错误处理
output.elasticsearch:
  hosts: ["localhost:9200"]
  api_key: "${ES_API_KEY}"
  
  # 认证失败时的行为
  max_retries: 3
  backoff.init: 5s
  
  # 错误时的备用输出
  when.contains:
    message: "authentication failed"
  then:
    output.file:
      path: "/var/log/filebeat/failed_auth"
      filename: "auth_failures.log"
```

---

## 6. 💾 认证缓存优化配置


### 6.1 认证缓存的作用


**什么是认证缓存**：就像门卫记住常客一样，避免每次都重新验证身份

**缓存工作原理**：
```
无缓存模式：
每个请求 → 重新认证 → 验证身份 → 处理请求
        ↑ 每次都要验证，速度慢

有缓存模式：
第一次请求 → 认证 → 保存到缓存 → 处理请求
后续请求 → 检查缓存 → 直接处理请求
         ↑ 跳过认证步骤，速度快
```

### 6.2 连接池与缓存配置


```yaml
# filebeat.yml - 连接池优化
output.elasticsearch:
  hosts: ["localhost:9200"]
  api_key: "${ES_API_KEY}"
  
  # 连接池设置
  worker: 4                    # 并发工作线程
  bulk_max_size: 2048         # 批量大小
  
  # 连接保持设置
  headers:
    Connection: "keep-alive"
    Keep-Alive: "timeout=300, max=100"
  
  # HTTP连接复用
  compression_level: 3
  escape_html: false
```

**连接复用配置说明**：
- `worker`：并发连接数，根据服务器性能调整
- `bulk_max_size`：批量发送大小，减少认证频率
- `Keep-Alive`：保持连接活跃，避免重复建立连接

### 6.3 SSL会话缓存


```yaml
# SSL会话复用配置
output.elasticsearch:
  hosts: ["https://localhost:9200"]
  api_key: "${ES_API_KEY}"
  
  # SSL配置
  ssl.enabled: true
  ssl.verification_mode: full
  ssl.certificate_authorities: ["/path/to/ca.crt"]
  
  # SSL会话缓存
  ssl.renegotiation: "never"
  ssl.cipher_suites:
    - "ECDHE-RSA-AES128-GCM-SHA256"
    - "ECDHE-RSA-AES256-GCM-SHA384"
  
  # 连接复用
  timeout: 90s
  headers:
    Connection: "keep-alive"
```

### 6.4 批量处理优化


**批量认证策略**
```yaml
# 优化批量处理减少认证开销
filebeat.inputs:
- type: log
  paths:
    - /var/log/app/*.log
  # 本地缓存配置
  harvester_buffer_size: 16384
  max_bytes: 10485760

output.elasticsearch:
  hosts: ["localhost:9200"]
  api_key: "${ES_API_KEY}"
  
  # 批量优化设置
  bulk_max_size: 1000         # 增大批量大小
  flush_interval: 10s         # 定时刷新
  worker: 2                   # 适度并发
  
  # 内存队列设置
  queue.mem:
    events: 4096
    flush.min_events: 512
    flush.timeout: 5s
```

---

## 7. 🌍 多环境认证管理


### 7.1 多环境配置策略


**环境隔离原则**：不同环境使用不同的认证凭据，就像不同办公室用不同的门禁卡

```
环境分离示意：

开发环境 (DEV)
├── 用户名密码认证
├── 测试数据
└── 宽松安全策略

测试环境 (TEST) 
├── API密钥认证
├── 模拟数据
└── 中等安全策略

生产环境 (PROD)
├── API密钥 + SSL证书
├── 真实数据
└── 严格安全策略
```

### 7.2 环境变量配置管理


**基础环境变量配置**
```yaml
# filebeat.yml - 多环境配置
filebeat.inputs:
- type: log
  paths:
    - ${LOG_PATH:/var/log/app/*.log}

output.elasticsearch:
  # 环境相关配置
  hosts: ["${ES_HOST:localhost:9200}"]
  
  # 根据环境选择认证方式
  username: "${ES_USERNAME:}"
  password: "${ES_PASSWORD:}"
  api_key: "${ES_API_KEY:}"
  
  # 环境特定索引
  index: "${ES_INDEX_PREFIX:filebeat}-%{+yyyy.MM.dd}"
  
  # SSL配置
  ssl.enabled: ${SSL_ENABLED:false}
  ssl.certificate_authorities: ["${SSL_CA_PATH:}"]
```

**环境配置文件示例**：

```bash
# .env.dev - 开发环境
ES_HOST=localhost:9200
ES_USERNAME=dev_user
ES_PASSWORD=dev_password
ES_INDEX_PREFIX=filebeat-dev
SSL_ENABLED=false
LOG_PATH=/var/log/dev/*.log
```

```bash
# .env.prod - 生产环境
ES_HOST=prod-es-cluster:9200
ES_API_KEY=VuaCfGcBCdbkQm-e5aOx:ui2lp2axTNmsyakw9tvNnw
ES_INDEX_PREFIX=filebeat-prod
SSL_ENABLED=true
SSL_CA_PATH=/etc/ssl/certs/es-ca.crt
LOG_PATH=/var/log/production/*.log
```

### 7.3 配置文件模板化


**使用配置模板**
```yaml
# filebeat.template.yml
filebeat.inputs:
- type: log
  paths:
    - {{LOG_PATHS}}

output.elasticsearch:
  hosts: {{ES_HOSTS}}
  
  {{#if USE_API_KEY}}
  api_key: "{{API_KEY}}"
  {{else}}
  username: "{{USERNAME}}"
  password: "{{PASSWORD}}"
  {{/if}}
  
  index: "{{INDEX_PREFIX}}-%{+yyyy.MM.dd}"
  
  {{#if SSL_ENABLED}}
  ssl.enabled: true
  ssl.certificate_authorities: ["{{SSL_CA_PATH}}"]
  {{/if}}
```

**环境特定配置生成脚本**
```bash
#!/bin/bash
# generate-config.sh

ENVIRONMENT=$1

case $ENVIRONMENT in
  "dev")
    sed -e 's/{{ES_HOSTS}}/["localhost:9200"]/g' \
        -e 's/{{USERNAME}}/dev_user/g' \
        -e 's/{{PASSWORD}}/dev_pass/g' \
        -e 's/{{INDEX_PREFIX}}/filebeat-dev/g' \
        filebeat.template.yml > filebeat-dev.yml
    ;;
  "prod")
    sed -e 's/{{ES_HOSTS}}/["prod-cluster:9200"]/g' \
        -e 's/{{API_KEY}}/your-prod-api-key/g' \
        -e 's/{{INDEX_PREFIX}}/filebeat-prod/g' \
        filebeat.template.yml > filebeat-prod.yml
    ;;
esac
```

### 7.4 Docker化多环境部署


**Docker Compose配置**
```yaml
# docker-compose.yml
version: '3.8'

services:
  filebeat-dev:
    image: docker.elastic.co/beats/filebeat:8.10.0
    environment:
      - ES_HOST=elasticsearch-dev:9200
      - ES_USERNAME=dev_user
      - ES_PASSWORD=dev_password
      - ENVIRONMENT=development
    volumes:
      - ./filebeat-dev.yml:/usr/share/filebeat/filebeat.yml:ro
      - /var/log/dev:/var/log/app:ro
    networks:
      - dev-network

  filebeat-prod:
    image: docker.elastic.co/beats/filebeat:8.10.0
    environment:
      - ES_HOST=elasticsearch-prod:9200
      - ES_API_KEY=${PROD_API_KEY}
      - ENVIRONMENT=production
    volumes:
      - ./filebeat-prod.yml:/usr/share/filebeat/filebeat.yml:ro
      - /var/log/prod:/var/log/app:ro
      - ./ssl/ca.crt:/usr/share/filebeat/ca.crt:ro
    networks:
      - prod-network
```

---

## 8. 🔒 密码安全存储最佳实践


### 8.1 密码存储安全原则


**核心安全原则**：永远不要把密码明文写在配置文件里，就像不要把银行卡密码写在卡片上

**常见安全威胁**：
```
密码泄露风险：

配置文件泄露：
config.yml被上传到GitHub → 全世界都能看到密码

日志文件暴露：
错误日志包含密码信息 → 运维人员无意中看到

版本控制泄露：
密码写在代码中 → Git历史记录永久保存

权限配置错误：
文件权限设置不当 → 其他用户可以读取
```

### 8.2 环境变量安全配置


**环境变量最佳实践**
```bash
# 1. 使用专用的环境文件
# /etc/filebeat/secrets.env
ES_USERNAME=filebeat_service
ES_PASSWORD=complex_random_password_2024
ES_API_KEY=VuaCfGcBCdbkQm-e5aOx:ui2lp2axTNmsyakw9tvNnw

# 2. 设置严格的文件权限
chmod 600 /etc/filebeat/secrets.env
chown filebeat:filebeat /etc/filebeat/secrets.env

# 3. 加载环境变量的安全方式
source /etc/filebeat/secrets.env
export ES_USERNAME ES_PASSWORD ES_API_KEY
```

**系统级环境变量配置**
```bash
# /etc/systemd/system/filebeat.service
[Unit]
Description=Filebeat
After=network.target

[Service]
Type=simple
User=filebeat
Group=filebeat
EnvironmentFile=/etc/filebeat/secrets.env
ExecStart=/usr/share/filebeat/bin/filebeat -c /etc/filebeat/filebeat.yml
Restart=always

[Install]
WantedBy=multi-user.target
```

### 8.3 密钥管理服务集成


**HashiCorp Vault集成**
```yaml
# filebeat.yml - Vault集成配置
filebeat.inputs:
- type: log
  paths:
    - /var/log/app/*.log

output.elasticsearch:
  hosts: ["localhost:9200"]
  
  # 从Vault获取密钥
  username: "${vault:secret/filebeat:username}"
  password: "${vault:secret/filebeat:password}"
  
  index: "filebeat-%{+yyyy.MM.dd}"
```

**AWS Secrets Manager集成**
```bash
#!/bin/bash
# get-secrets.sh - 从AWS获取密钥

# 获取密钥
SECRET=$(aws secretsmanager get-secret-value \
  --secret-id "filebeat/elasticsearch/credentials" \
  --query "SecretString" --output text)

# 解析JSON并设置环境变量
export ES_USERNAME=$(echo $SECRET | jq -r '.username')
export ES_PASSWORD=$(echo $SECRET | jq -r '.password')
export ES_API_KEY=$(echo $SECRET | jq -r '.api_key')

# 启动Filebeat
/usr/share/filebeat/bin/filebeat -e
```

### 8.4 密码轮换自动化


**定期密码轮换脚本**
```bash
#!/bin/bash
# rotate-credentials.sh

LOG_FILE="/var/log/filebeat/credential-rotation.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

echo "[$DATE] Starting credential rotation..." >> $LOG_FILE

# 1. 生成新的API密钥
NEW_API_KEY=$(curl -s -X POST "localhost:9200/_security/api_key" \
  -u "admin:${ADMIN_PASSWORD}" \
  -H "Content-Type: application/json" -d'
{
  "name": "filebeat-api-key-'$(date +%Y%m%d)'",
  "expiration": "30d",
  "role_descriptors": {
    "filebeat_writer": {
      "cluster": ["monitor"],
      "index": [{"names": ["filebeat-*"], "privileges": ["write", "create_index"]}]
    }
  }
}' | jq -r '.id + ":" + .api_key')

# 2. 更新环境变量
echo "ES_API_KEY=$NEW_API_KEY" > /etc/filebeat/secrets.env.new
mv /etc/filebeat/secrets.env.new /etc/filebeat/secrets.env

# 3. 重启Filebeat服务
systemctl restart filebeat

# 4. 验证新密钥工作正常
sleep 10
if systemctl is-active --quiet filebeat; then
    echo "[$DATE] Credential rotation successful" >> $LOG_FILE
    # 删除旧密钥（需要实现旧密钥跟踪）
else
    echo "[$DATE] Credential rotation failed" >> $LOG_FILE
    # 回滚到旧密钥
fi
```

**自动化轮换计划任务**
```bash
# 添加到crontab
# 每月第一天凌晨2点执行密钥轮换
0 2 1 * * /etc/filebeat/scripts/rotate-credentials.sh

# 验证计划任务
crontab -l | grep rotate-credentials
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的认证方式


```
🔸 基础认证：用户名密码，适合开发测试环境
🔸 API密钥认证：更安全的生产环境首选方案
🔸 自定义认证头：灵活支持各种第三方认证
🔸 SSL证书认证：最高安全级别的企业方案
```

### 9.2 安全配置检查清单


**📋 配置安全检查**
- ✅ 配置文件权限设置为600
- ✅ 使用环境变量存储敏感信息
- ✅ 定期轮换API密钥和密码
- ✅ 启用SSL/TLS加密传输
- ✅ 设置适当的超时和重试机制
- ✅ 记录认证失败日志用于监控

**📋 生产环境建议**
- ✅ 使用API密钥而非用户名密码
- ✅ 集成企业密钥管理系统
- ✅ 实施最小权限原则
- ✅ 配置监控和告警机制
- ✅ 建立密钥轮换自动化流程

### 9.3 常见问题快速排查


**认证失败排查步骤**：
```
1. 检查连接性：
   curl -k https://your-es-host:9200

2. 验证认证信息：
   curl -u username:password https://your-es-host:9200

3. 查看Filebeat日志：
   tail -f /var/log/filebeat/filebeat

4. 测试API密钥：
   curl -H "Authorization: ApiKey your-api-key" https://your-es-host:9200

5. 检查权限配置：
   GET /_security/user/your-username
```

**性能优化要点**：
- 🔸 **批量处理**：增大bulk_max_size减少认证频率
- 🔸 **连接复用**：使用keep-alive保持连接
- 🔸 **合理并发**：根据服务器性能调整worker数量
- 🔸 **缓存优化**：启用SSL会话复用和连接池

### 9.4 实际应用建议


**🎯 开发环境配置**
- 使用简单的用户名密码认证
- 关闭SSL以简化配置
- 增加详细日志便于调试

**🎯 测试环境配置**  
- 使用API密钥模拟生产环境
- 启用SSL但允许自签名证书
- 配置适中的超时和重试参数

**🎯 生产环境配置**
- 强制使用API密钥+SSL证书
- 集成企业身份认证系统
- 严格的权限控制和审计日志
- 自动化密钥轮换和监控告警

**核心记忆要点**：
- 安全认证如门禁系统，保护数据不被非法访问
- 开发用密码，生产用密钥，企业用证书
- 环境变量存密码，权限设置要严格
- 超时重试要配置，批量缓存提性能