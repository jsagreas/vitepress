---
title: 33、cluster.yml集群配置
---
## 📚 目录


1. [Filebeat集群基础概念](#1-filebeat集群基础概念)
2. [集群节点配置详解](#2-集群节点配置详解)
3. [负载均衡设置策略](#3-负载均衡设置策略)
4. [节点发现配置机制](#4-节点发现配置机制)
5. [集群健康监控](#5-集群健康监控)
6. [故障转移配置](#6-故障转移配置)
7. [数据分片设置](#7-数据分片设置)
8. [集群通信配置](#8-集群通信配置)
9. [选主机制配置](#9-选主机制配置)
10. [核心要点总结](#10-核心要点总结)

---

# 🎯 **学习路径导航**


**前置知识**：需要掌握Filebeat基础配置、Elasticsearch集群概念 → **当前内容**：Filebeat集群配置 → **后续学习**：建议学习Logstash集群、Kibana集群配置

⏱️ **预计学习时间**：本章预计45分钟 | 实践配置30分钟

🏷️ **知识标签**：`#集群配置` `#高可用` `#负载均衡` `#故障转移`

---

## 1. 🌐 Filebeat集群基础概念



### 1.1 什么是Filebeat集群



**🔸 核心定义**
Filebeat集群就是把多个Filebeat实例组织起来，**像一个团队一样协同工作**，而不是各自为政。

**💡 生活化理解**
想象一个快递公司：
- **单个Filebeat**：就像一个快递员，只能处理有限的包裹
- **Filebeat集群**：就像整个快递公司，多个快递员分工合作
- **集群的好处**：包裹多了不怕，有人请假也不影响整体运营

### 1.2 集群架构类型



**📊 三种常见架构对比**

| **架构类型** | **适用场景** | **优点** | **缺点** |
|-------------|-------------|---------|---------|
| **多主架构** | 大型分布式环境 | 无单点故障 | 配置复杂 |
| **主从架构** | 中小型环境 | 配置简单 | 存在单点故障 |
| **联邦架构** | 跨地域部署 | 地理分布好 | 网络延迟大 |

### 1.3 集群部署的好处



**🌟 核心优势**
```
🔸 高可用性：一台机器坏了，其他机器继续工作
🔸 负载分担：多台机器分担数据收集任务
🔸 横向扩展：数据量增加时可以加机器
🔸 故障隔离：单个节点问题不影响整体服务
```

---

## 2. ⚙️ 集群节点配置详解



### 2.1 基础节点配置结构



**📝 节点配置模板**
让我们先看一个最基本的集群节点配置：

```yaml
# cluster.yml - 基础集群配置

name: "filebeat-cluster-node-1"
tags: ["production", "web-logs"]

# 集群发现配置

cluster:
  name: "my-filebeat-cluster"
  initial_master_nodes: ["node-1", "node-2", "node-3"]
  
# 节点角色定义

node:
  name: "node-1"
  master: true
  data: true
  
# 网络配置

network:
  host: "0.0.0.0"
  port: 9200
```

**🔍 配置说明**
- **name**：给这个Filebeat实例起个名字，就像给员工发工牌
- **cluster.name**：集群的名称，相同名称的节点才能组成集群
- **node.name**：节点在集群中的唯一标识
- **initial_master_nodes**：集群启动时的候选主节点列表

### 2.2 节点角色配置



**👥 节点角色类型**

不同的节点可以承担不同的责任，就像公司里有不同岗位的员工：

```yaml
# 主节点配置 - 负责集群管理

node:
  master: true      # 可以当选为主节点
  data: false       # 不存储数据
  ingest: false     # 不处理数据预处理
  
# 数据节点配置 - 负责数据存储

node:
  master: false     # 不参与主节点选举
  data: true        # 存储和搜索数据
  ingest: true      # 可以预处理数据
  
# 协调节点配置 - 负责请求分发

node:
  master: false
  data: false
  ingest: false
#  # 这种配置的节点专门做请求路由
```

### 2.3 资源配置优化



**💾 内存和CPU配置**

不同角色的节点需要不同的资源配置：

```yaml
# 内存配置

bootstrap:
  memory_lock: true    # 锁定内存，避免swap

# JVM堆内存设置（在jvm.options文件中）

# 主节点：较少内存即可

-Xms512m
-Xmx512m

# 数据节点：需要更多内存

-Xms2g
-Xmx2g

# 文件描述符限制

max_file_descriptors: 65535
```

**⚡ 性能调优建议**
- **主节点**：CPU优先，内存适中（512MB-1GB）
- **数据节点**：内存优先，磁盘IO要好（2GB-8GB）
- **协调节点**：CPU和网络优先（1GB-2GB）

---

## 3. ⚖️ 负载均衡设置策略



### 3.1 负载均衡基本概念



**🔄 什么是负载均衡**
负载均衡就像**交通指挥员**，把车流（数据流）合理分配到不同的道路（节点）上，避免某条路堵死，其他路却空着。

### 3.2 输出负载均衡配置



**📤 Elasticsearch输出均衡**

```yaml
# 多个Elasticsearch节点负载均衡

output.elasticsearch:
  hosts: 
    - "elasticsearch-1:9200"
    - "elasticsearch-2:9200" 
    - "elasticsearch-3:9200"
  
#  # 负载均衡策略
  loadbalance: true
  
#  # 连接配置
  worker: 3                    # 并发连接数
  bulk_max_size: 2048         # 批量发送大小
  flush_interval: 10s         # 刷新间隔
  
#  # 故障处理
  max_retries: 3              # 重试次数
  backoff:
    init: 1s                  # 初始重试间隔
    max: 60s                  # 最大重试间隔
```

### 3.3 输入负载均衡策略



**📥 多输入源均衡处理**

```yaml
# 多个日志文件的负载均衡

filebeat.inputs:
#  # Web服务器日志
  - type: log
    paths:
      - "/var/log/nginx/access.log*"
      - "/var/log/apache2/access.log*"
    tags: ["web", "access"]
    
#    # 多行配置避免日志截断
    multiline:
      pattern: '^\d{4}-\d{2}-\d{2}'
      negate: true
      match: after
  
#  # 应用程序日志  
  - type: log
    paths:
      - "/var/log/app/*.log"
    tags: ["application"]
    
#    # 日志解析配置
    json:
      keys_under_root: true
      add_error_key: true
```

### 3.4 队列管理配置



**📦 内部队列负载均衡**

```yaml
# 队列配置

queue:
  mem:
    events: 4096              # 内存队列大小
    flush:
      min_events: 512         # 最小刷新事件数
      timeout: 10s            # 刷新超时时间

# 发布管道配置  

publisher:
  pipeline:
    queue_size: 4096          # 管道队列大小
    batch_size: 2048          # 批处理大小
```

---

## 4. 🔍 节点发现配置机制



### 4.1 节点发现原理



**🔎 发现机制简介**
节点发现就像**新员工入职**，需要知道公司有哪些同事，办公室在哪里。Filebeat集群的节点也需要互相"认识"。

### 4.2 静态发现配置



**📍 固定IP地址发现**

最简单的方式是直接指定其他节点的地址：

```yaml
# 静态节点发现

discovery:
  seed_hosts:
    - "192.168.1.10:9300"     # 节点1的传输端口
    - "192.168.1.11:9300"     # 节点2的传输端口  
    - "192.168.1.12:9300"     # 节点3的传输端口
  
#  # 集群初始化配置
  cluster_initial_master_nodes:
    - "node-1"
    - "node-2" 
    - "node-3"

# 网络传输配置

transport:
  port: 9300                  # 节点间通信端口
  bind_host: "0.0.0.0"        # 绑定所有网卡
  publish_host: "192.168.1.10" # 对外发布的IP
```

### 4.3 DNS发现配置



**🌐 基于DNS的动态发现**

适合云环境或容器化部署：

```yaml
# DNS发现配置

discovery:
  seed_providers: dns
  
#  # DNS查询配置
  dns:
    query: "_elasticsearch._tcp.my-cluster.local"
    timeout: 5s
    
# 替代方案：使用Service名称

discovery:
  seed_hosts:
    - "elasticsearch-service:9300"  # Kubernetes Service
    - "es-cluster.consul:9300"      # Consul Service
```

### 4.4 云平台发现配置



**☁️ 云服务发现插件**

```yaml
# AWS EC2发现

discovery:
  ec2:
    groups: ["elasticsearch-sg"]     # 安全组
    host_type: "private_ip"          # 使用内网IP
    tag:
      Environment: "production"      # 标签过滤
      
# Azure发现      

discovery:
  azure:
    subscription_id: "your-subscription-id"
    resource_group: "elasticsearch-rg"
    
# Google Cloud发现

discovery:
  gce:
    project_id: "your-project-id"
    zone: "us-central1-a"
```

---

## 5. 📊 集群健康监控



### 5.1 健康检查基础



**💓 集群健康状态**
集群健康就像**体检报告**，告诉我们系统运行得怎么样：

- **🟢 绿色（Green）**：一切正常，所有功能都在正常工作
- **🟡 黄色（Yellow）**：基本功能正常，但有些小问题需要注意
- **🔴 红色（Red）**：有严重问题，部分功能无法使用

### 5.2 监控配置设置



**📈 监控数据收集**

```yaml
# 监控配置

monitoring:
  enabled: true
  
#  # 监控数据输出
  elasticsearch:
    hosts: ["monitoring-es:9200"]
    username: "monitoring_user"
    password: "monitoring_pass"
    
#  # 监控指标配置
  cluster_stats_timeout: 10s
  node_stats_timeout: 10s
  index_stats_timeout: 10s
```

### 5.3 健康检查脚本



**🔧 自动化健康检查**

创建一个简单的健康检查脚本：

```bash
#!/bin/bash

# health_check.sh - 集群健康检查脚本


CLUSTER_URL="http://localhost:9200"

# 检查集群状态

check_cluster_health() {
    echo "🔍 检查集群健康状态..."
    
#    # 获取集群健康信息
    health=$(curl -s "$CLUSTER_URL/_cluster/health")
    status=$(echo $health | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
    
    case $status in
        "green")
            echo "✅ 集群状态: 健康"
            ;;
        "yellow") 
            echo "⚠️ 集群状态: 警告"
            ;;
        "red")
            echo "❌ 集群状态: 严重"
            ;;
        *)
            echo "❓ 无法获取集群状态"
            ;;
    esac
}

# 执行检查

check_cluster_health
```

### 5.4 告警配置



**🚨 告警规则设置**

```yaml
# 告警配置

alerting:
#  # 集群状态告警
  cluster_health:
    red_threshold: 1m         # 红色状态持续1分钟告警
    yellow_threshold: 5m      # 黄色状态持续5分钟告警
    
#  # 节点告警
  node_status:
    disconnected_threshold: 30s  # 节点离线30秒告警
    
#  # 磁盘空间告警  
  disk_usage:
    warning_threshold: 85%    # 磁盘使用率85%警告
    critical_threshold: 95%   # 磁盘使用率95%严重告警
```

---

## 6. 🔄 故障转移配置



### 6.1 故障转移基本原理



**🛡️ 什么是故障转移**
故障转移就像**备用司机**，当主司机生病时，备用司机立即接手，保证车辆正常运行。

### 6.2 主节点故障转移



**👑 主节点选举配置**

```yaml
# 主节点选举设置

cluster:
#  # 最小主节点数（防止脑裂）
  minimum_master_nodes: 2
  
#  # 选举超时时间
  election:
    timeout: 30s
    
#  # 节点失联检测
  fault_detection:
    leader_check_interval: 1s      # 检查主节点间隔
    leader_check_timeout: 10s      # 主节点响应超时
    follower_check_interval: 1s    # 检查从节点间隔
    follower_check_timeout: 10s    # 从节点响应超时
```

### 6.3 数据节点故障转移



**💾 数据副本配置**

```yaml
# 索引副本设置

index:
  number_of_replicas: 1           # 每个分片1个副本
  auto_expand_replicas: "0-2"     # 自动调整副本数
  
# 分片分配配置

cluster:
  routing:
    allocation:
#      # 同一个分片的主副本不在同一节点
      same_shard_host: false
#      # 允许分片重新分配
      enable: "all"
      
#    # 故障恢复配置
    recovery:
      node_initial_primaries_recoveries: 4
      node_concurrent_recoveries: 2
```

### 6.4 网络分区处理



**🌐 网络故障处理**

```yaml
# 网络分区检测

discovery:
  zen:
#    # 最小主节点数（必须大于节点总数的一半）
    minimum_master_nodes: 2
    
#    # 节点发现超时
    ping_timeout: 30s
    
#    # 网络故障检测
    fd:
      ping_interval: 1s           # 心跳间隔
      ping_timeout: 30s           # 心跳超时
      ping_retries: 3             # 重试次数
```

---

## 7. 📦 数据分片设置



### 7.1 分片基本概念



**🧩 什么是分片**
数据分片就像**拼图游戏**：
- 一张完整的拼图（数据）被分成多个小块（分片）
- 每个小块可以放在不同的桌子上（节点）
- 所有小块组合起来还原完整图片（完整数据）

### 7.2 分片数量配置



**📊 分片策略设置**

```yaml
# 索引模板配置

index_template:
  name: "filebeat-logs"
  index_patterns: ["filebeat-*"]
  
  settings:
#    # 主分片数量
    number_of_shards: 3
    
#    # 副本分片数量  
    number_of_replicas: 1
    
#    # 分片大小控制
    max_primary_shard_size: "50gb"
    
#    # 自动滚动设置
    rollover:
      max_size: "50gb"
      max_age: "30d"
      max_docs: 100000000
```

### 7.3 分片分配策略



**🎯 智能分片分配**

```yaml
# 分片分配配置

cluster:
  routing:
    allocation:
#      # 感知配置（机架感知）
      awareness:
        attributes: "rack_id"
        force:
          rack_id:
            values: ["rack-1", "rack-2"]
            
#      # 分片平衡配置
      balance:
        shard: 0.45              # 分片平衡权重
        index: 0.55              # 索引平衡权重
        threshold: 1.0           # 平衡阈值
        
#      # 并发控制
      node_concurrent_incoming_recoveries: 2
      node_concurrent_outgoing_recoveries: 2
```

### 7.4 分片监控



**📈 分片状态监控**

```bash
# 查看分片分布

curl -X GET "localhost:9200/_cat/shards?v"

# 查看未分配分片

curl -X GET "localhost:9200/_cluster/allocation/explain"

# 查看分片大小

curl -X GET "localhost:9200/_cat/indices?v&s=store.size:desc"
```

---

## 8. 🔗 集群通信配置



### 8.1 通信基础概念



**📡 集群内部通信**
集群通信就像**公司内部电话系统**，各个部门（节点）需要通过电话（网络）互相沟通协调工作。

### 8.2 传输层配置



**🌐 网络传输设置**

```yaml
# 传输层配置

transport:
#  # 传输端口
  port: 9300
  
#  # 绑定地址
  bind_host: "0.0.0.0"
  
#  # 发布地址（其他节点连接用的地址）
  publish_host: "192.168.1.10"
  
#  # TCP设置
  tcp:
    no_delay: true             # 禁用Nagle算法
    keep_alive: true           # 启用TCP保活
    keep_idle: 300             # 保活间隔（秒）
    keep_interval: 30          # 保活探测间隔
    keep_count: 5              # 保活探测次数
    
#  # 压缩配置
  compress: true               # 启用传输压缩
  compression_scheme: "lz4"    # 压缩算法
```

### 8.3 SSL/TLS安全配置



**🔒 通信加密设置**

```yaml
# TLS安全配置

transport:
  ssl:
    enabled: true
    
#    # 证书配置
    certificate: "/path/to/node.crt"
    key: "/path/to/node.key"
    certificate_authorities: ["/path/to/ca.crt"]
    
#    # 客户端验证
    client_authentication: "required"
    
#    # 协议版本
    supported_protocols: ["TLSv1.2", "TLSv1.3"]
    
#    # 密码套件
    cipher_suites: 
      - "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"
      - "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
```

### 8.4 防火墙配置



**🛡️ 网络安全配置**

```bash
# Linux防火墙规则配置

# 允许Elasticsearch端口

sudo ufw allow 9200/tcp  # HTTP API端口
sudo ufw allow 9300/tcp  # 节点间通信端口

# 仅允许集群内部IP访问

sudo ufw allow from 192.168.1.0/24 to any port 9300

# iptables规则示例

iptables -A INPUT -p tcp --dport 9300 -s 192.168.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 9300 -j DROP
```

---

## 9. 👑 选主机制配置



### 9.1 选主基本原理



**🗳️ 选举过程理解**
主节点选举就像**班级选班长**：
- 候选人（master-eligible nodes）参与选举
- 需要过半数同学（节点）投票才能当选
- 如果班长（主节点）离开，立即重新选举

### 9.2 选举参数配置



**⚙️ 选举规则设置**

```yaml
# 选举配置

cluster:
#  # 候选主节点列表
  initial_master_nodes: 
    - "master-1"
    - "master-2" 
    - "master-3"
    
#  # 选举超时时间
  election:
    duration: 30s             # 选举持续时间
    back_off_time: 100ms      # 选举退避时间
    max_timeout: 30s          # 最大超时时间
    
#  # 最小主节点数（防脑裂）
  minimum_master_nodes: 2     # 必须大于总master节点数/2
```

### 9.3 脑裂防护配置



**🧠 防止集群分裂**

脑裂就像公司里**同时有两个CEO**，大家不知道听谁的：

```yaml
# 脑裂防护

discovery:
  zen:
#    # 最小主节点数
    minimum_master_nodes: 2
    
#    # 发布超时
    publish_timeout: 30s
    
#    # 主节点选举过滤器
    master_election:
      ignore_non_master_pings: true
      
# 节点过滤配置

node:
#  # 节点属性
  attr:
    rack: "rack-1"            # 机架标识
    zone: "zone-a"            # 可用区标识
    
#  # 角色配置
  roles: ["master", "data"]   # 明确节点角色
```

### 9.4 选举监控



**📊 选举状态监控**

```bash
# 查看当前主节点

curl -X GET "localhost:9200/_cat/master?v"

# 查看节点角色

curl -X GET "localhost:9200/_cat/nodes?v&h=name,node.role,master"

# 查看集群状态

curl -X GET "localhost:9200/_cluster/state/master_node"
```

---

## 10. 📋 核心要点总结



### 10.1 必须掌握的核心概念



```
🔸 集群基础：多个Filebeat实例协同工作，提供高可用服务
🔸 节点角色：主节点负责管理，数据节点负责存储，协调节点负责分发
🔸 负载均衡：合理分配工作负载，避免单点过载
🔸 故障转移：当节点故障时自动切换，保证服务不中断
🔸 选主机制：通过选举产生主节点，协调集群运行
```

### 10.2 关键理解要点



**🔹 为什么需要集群**
```
单节点问题：
- 性能瓶颈：处理能力有限
- 单点故障：服务器坏了就全完了
- 扩展困难：数据量大了没办法

集群优势：
- 高可用：一台坏了其他继续工作
- 高性能：多台机器分担负载
- 易扩展：加机器就能提升能力
```

**🔹 集群配置核心原则**
```
安全第一：
- 配置SSL/TLS加密通信
- 设置防火墙规则
- 使用强密码认证

稳定可靠：
- 合理配置分片副本
- 设置故障检测机制
- 配置监控告警

性能优化：
- 根据负载调整分片数
- 配置合适的内存大小
- 启用传输压缩
```

### 10.3 实际应用场景



**🎯 适用场景**
- **大型网站**：多台服务器收集海量日志
- **微服务架构**：每个服务部署独立的Filebeat
- **多地部署**：不同地区的数据中心组成集群
- **高可用要求**：金融、医疗等关键业务系统

### 10.4 常见问题解决



**⚠️ 常见问题和解决方案**

| **问题** | **原因** | **解决方案** |
|---------|---------|-------------|
| 集群分裂 | 网络分区 | 正确配置minimum_master_nodes |
| 节点无法加入 | 配置错误 | 检查cluster.name和网络配置 |
| 数据丢失 | 副本不足 | 增加副本数量 |
| 性能下降 | 分片不合理 | 重新设计分片策略 |

### 10.5 学习检查清单



**📝 掌握程度自测**
- [ ] 能解释集群的基本概念和优势
- [ ] 会配置不同角色的节点
- [ ] 理解负载均衡的工作原理
- [ ] 能设置故障转移机制
- [ ] 掌握选主机制的配置
- [ ] 会监控集群健康状态

**🔑 核心记忆口诀**
> 集群协作效率高，节点分工各司职
> 负载均衡防过载，故障转移保稳定
> 选主机制防分裂，监控告警保健康

**💡 延伸学习建议**
- 学习Elasticsearch集群优化技巧
- 了解容器化部署的集群配置
- 研究大规模集群的运维最佳实践
- 掌握集群性能调优方法