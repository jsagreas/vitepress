---
title: 11、复杂查询与过滤
---
## 📚 目录

1. [复杂查询基础概念](#1-复杂查询基础概念)
2. [布尔查询详解](#2-布尔查询详解)
3. [范围查询实战](#3-范围查询实战)
4. [精确匹配查询](#4-精确匹配查询)
5. [通配符查询技巧](#5-通配符查询技巧)
6. [字段存在性查询](#6-字段存在性查询)
7. [后置过滤器应用](#7-后置过滤器应用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 复杂查询基础概念


### 1.1 什么是复杂查询


**简单理解**：就像我们在搜索引擎里不只是简单搜一个词，而是要组合多个条件来精确找到想要的结果。

```
日常搜索对比：
简单搜索：搜索"手机"
复杂搜索：搜索"价格在2000-5000元的华为手机，且有5G功能"

Elasticsearch也是一样：
简单查询：找包含"elasticsearch"的文档
复杂查询：找标题包含"elasticsearch"且价格大于100且状态为"已发布"的文档
```

### 1.2 为什么需要复杂查询


**🔸 实际业务需求**
- **电商场景**：用户要按价格、品牌、评分等多个条件筛选商品
- **内容管理**：编辑要找特定时间段、特定作者、特定分类的文章
- **日志分析**：运维要找特定时间、特定级别、特定服务的错误日志

### 1.3 复杂查询的基本结构


**核心结构理解**：
```
查询请求的基本框架：
{
  "query": {        ← 这里定义查询条件
    "查询类型": {
      "具体条件": "值"
    }
  }
}
```

---

## 2. 🔧 布尔查询详解


### 2.1 布尔查询是什么


**通俗解释**：布尔查询就像日常说话中的"并且"、"或者"、"但不是"。

```
日常表达                    →    布尔查询类型
"既要A又要B"               →    must (必须满足)
"要么A要么B"               →    should (应该满足)
"要A但不要B"               →    must_not (必须不满足)
"A很重要，B可有可无"       →    filter (过滤条件)
```

### 2.2 布尔查询的四种类型


| 类型 | **含义** | **评分影响** | **使用场景** |
|------|---------|-------------|-------------|
| 🔸 **must** | `必须匹配，相当于"AND"` | `影响评分` | `核心条件，如商品必须是"手机"类别` |
| 🔹 **should** | `应该匹配，相当于"OR"` | `影响评分` | `加分条件，如最好有"5G"功能` |
| ❌ **must_not** | `必须不匹配，相当于"NOT"` | `不影响评分` | `排除条件，如排除"已下架"商品` |
| 🎯 **filter** | `必须匹配但不影响评分` | `不影响评分` | `硬性过滤，如价格在指定范围内` |

### 2.3 布尔查询实战示例


**场景**：在一个商品索引中查找满足条件的手机

```bash
# 查找iPhone手机，价格在3000-8000元，排除已下架商品
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "bool": {
      "must": [
        {"match": {"name": "iPhone"}}
      ],
      "filter": [
        {"range": {"price": {"gte": 3000, "lte": 8000}}}
      ],
      "must_not": [
        {"term": {"status": "offline"}}
      ],
      "should": [
        {"match": {"features": "5G"}}
      ]
    }
  }
}'
```

**逐步解析**：
```
must: name字段必须包含"iPhone"     ← 核心条件
filter: 价格必须在3000-8000元      ← 硬性过滤
must_not: 状态不能是"offline"      ← 排除条件
should: 最好有"5G"功能             ← 加分项
```

### 2.4 布尔查询的嵌套使用


**复杂场景**：查找高端手机或平板

```bash
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "bool": {
      "should": [
        {
          "bool": {
            "must": [
              {"term": {"category": "phone"}},
              {"range": {"price": {"gte": 5000}}}
            ]
          }
        },
        {
          "bool": {
            "must": [
              {"term": {"category": "tablet"}},
              {"range": {"price": {"gte": 3000}}}
            ]
          }
        }
      ]
    }
  }
}'
```

> 💡 **理解要点**：这个查询的意思是"要么是价格>=5000的手机，要么是价格>=3000的平板"

---

## 3. 📊 范围查询实战


### 3.1 范围查询的应用场景


**什么时候用范围查询**：
- 🔸 **价格筛选**：查找100-500元的商品
- 🔸 **时间筛选**：查找最近30天的订单
- 🔸 **数值筛选**：查找评分4分以上的商品
- 🔸 **日期筛选**：查找2023年发布的文章

### 3.2 范围查询操作符详解


| 操作符 | **含义** | **示例** | **说明** |
|--------|---------|---------|---------|
| `gte` | `大于等于` | `"gte": 100` | `>= 100` |
| `gt` | `大于` | `"gt": 100` | `> 100` |
| `lte` | `小于等于` | `"lte": 500` | `<= 500` |
| `lt` | `小于` | `"lt": 500` | `< 500` |

### 3.3 数值范围查询


**价格区间查询**：
```bash
# 查找价格在100-500元的商品
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "range": {
      "price": {
        "gte": 100,
        "lte": 500
      }
    }
  }
}'
```

**单边界查询**：
```bash
# 查找价格大于1000元的高端商品
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "range": {
      "price": {
        "gt": 1000
      }
    }
  }
}'
```

### 3.4 日期范围查询


**日期查询技巧**：
```bash
# 查找最近30天创建的文档
curl -X POST "localhost:9200/articles/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "range": {
      "created_date": {
        "gte": "now-30d",
        "lte": "now"
      }
    }
  }
}'
```

**具体日期范围**：
```bash
# 查找2023年的文章
curl -X POST "localhost:9200/articles/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "range": {
      "publish_date": {
        "gte": "2023-01-01",
        "lt": "2024-01-01"
      }
    }
  }
}'
```

> 📝 **日期格式说明**：Elasticsearch支持多种日期格式，推荐使用ISO格式如"2023-01-01"

---

## 4. 🎯 精确匹配查询


### 4.1 term查询 vs match查询的区别


**核心区别理解**：
```
match查询：会分析文本，支持模糊匹配
- 搜索"red car" → 能匹配"The car is red"

term查询：精确匹配，不分析文本
- 搜索"red car" → 只能匹配完全相同的"red car"
```

### 4.2 term查询的适用场景


**什么时候用term查询**：
- ✅ **状态字段**：`status: "active"`
- ✅ **分类字段**：`category: "electronics"`
- ✅ **ID字段**：`user_id: "12345"`
- ✅ **标签字段**：`tags: "hot"`

### 4.3 单个term查询


```bash
# 查找状态为"published"的文章
curl -X POST "localhost:9200/articles/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "term": {
      "status": "published"
    }
  }
}'
```

### 4.4 多值term查询（terms）


```bash
# 查找分类为"手机"或"平板"的商品
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "terms": {
      "category": ["phone", "tablet"]
    }
  }
}'
```

> ⚠️ **注意事项**：term查询对大小写敏感，"Active"和"active"是不同的值

### 4.5 keyword字段的重要性


**为什么需要keyword字段**：
```
text字段：会被分词器处理
"Red Car" → ["red", "car"]  # 分成多个词

keyword字段：保持原样
"Red Car" → "Red Car"       # 保持完整
```

**建议的字段映射**：
```bash
# 为精确匹配创建keyword字段
curl -X PUT "localhost:9200/products" \
-H "Content-Type: application/json" \
-d '{
  "mappings": {
    "properties": {
      "category": {
        "type": "keyword"
      },
      "status": {
        "type": "keyword"
      }
    }
  }
}'
```

---

## 5. 🔍 通配符查询技巧


### 5.1 通配符查询的基本概念


**通配符理解**：就像电脑文件搜索中的`*`和`?`
- `*` = 匹配任意长度的字符
- `?` = 匹配单个字符

```
日常文件搜索：*.txt（所有txt文件）
ES通配符查询：user_*（所有以user_开头的值）
```

### 5.2 通配符操作符详解


| 符号 | **含义** | **示例** | **匹配结果** |
|------|---------|---------|-------------|
| `*` | `匹配0或多个字符` | `test*` | `test`, `testing`, `tester` |
| `?` | `匹配单个字符` | `test?` | `tests`, `teste`，但不匹配`test` |

### 5.3 前缀匹配查询


```bash
# 查找所有以"admin_"开头的用户
curl -X POST "localhost:9200/users/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "wildcard": {
      "username": "admin_*"
    }
  }
}'
```

### 5.4 后缀匹配查询


```bash
# 查找所有以".jpg"结尾的文件
curl -X POST "localhost:9200/files/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "wildcard": {
      "filename": "*.jpg"
    }
  }
}'
```

### 5.5 中间匹配查询


```bash
# 查找包含"test"的所有文件名
curl -X POST "localhost:9200/files/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "wildcard": {
      "filename": "*test*"
    }
  }
}'
```

> ⚠️ **性能提示**：避免以`*`开头的查询（如`*test`），这会很慢。尽量从已知字符开始匹配。

### 5.6 实际应用场景


**常见使用场景**：
```
📱 手机型号匹配：iPhone* → iPhone12, iPhone13, iPhone14
📧 邮箱域名匹配：*@gmail.com → 所有Gmail邮箱
📁 文件类型匹配：*.pdf → 所有PDF文件
🏷️ 产品编码匹配：PRD-* → 所有产品编码
```

---

## 6. ✅ 字段存在性查询


### 6.1 exists查询的作用


**什么是exists查询**：检查文档中是否存在某个字段，不管该字段的值是什么。

```
类比理解：
检查表格中某列是否有数据（不管是什么数据）
检查用户是否填写了手机号（不管号码是多少）
```

### 6.2 exists查询的基本语法


```bash
# 查找有手机号的用户（不管手机号是什么）
curl -X POST "localhost:9200/users/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "exists": {
      "field": "phone"
    }
  }
}'
```

### 6.3 实际应用场景


**数据完整性检查**：
```bash
# 查找缺少邮箱字段的用户记录
curl -X POST "localhost:9200/users/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "bool": {
      "must_not": [
        {"exists": {"field": "email"}}
      ]
    }
  }
}'
```

**业务逻辑过滤**：
```bash
# 查找有评分的商品（说明有人购买过）
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "exists": {
      "field": "rating"
    }
  }
}'
```

### 6.4 exists查询的判断规则


**什么情况算"存在"**：
- ✅ 字段有任何非null值
- ✅ 字段是空字符串`""`
- ✅ 字段是空数组`[]`
- ❌ 字段不存在
- ❌ 字段值为`null`

### 6.5 组合使用exists查询


**查找完整资料的用户**：
```bash
# 查找同时有邮箱和手机号的用户
curl -X POST "localhost:9200/users/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "bool": {
      "must": [
        {"exists": {"field": "email"}},
        {"exists": {"field": "phone"}}
      ]
    }
  }
}'
```

---

## 7. 🎛️ 后置过滤器应用


### 7.1 post_filter vs query的区别


**理解区别**：
```
query: 主查询，影响评分和聚合
post_filter: 后置过滤，只影响最终结果，不影响聚合

实际场景：
电商网站显示"手机"分类下各品牌数量
- query: 查找所有手机
- post_filter: 用户选择了"华为"品牌后进行过滤
```

### 7.2 为什么需要post_filter


**使用场景对比**：

```
场景1：只用query
问题：用户选择品牌过滤后，聚合结果也被影响
结果：侧边栏的品牌统计变了，用户体验差

场景2：使用post_filter  
优势：聚合基于全部数据，过滤只影响显示结果
结果：侧边栏统计保持不变，用户体验好
```

### 7.3 post_filter基本使用


```bash
# 查询所有手机，但只显示华为品牌的结果
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "term": {"category": "phone"}
  },
  "post_filter": {
    "term": {"brand": "huawei"}
  },
  "aggs": {
    "brands": {
      "terms": {"field": "brand"}
    }
  }
}'
```

**结果解释**：
- 聚合结果包含所有手机品牌的统计
- 文档结果只显示华为手机
- 这样用户能看到完整的品牌选项

### 7.4 复杂post_filter示例


**多条件后置过滤**：
```bash
# 查询所有商品，但过滤特定价格和品牌
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "match_all": {}
  },
  "post_filter": {
    "bool": {
      "must": [
        {"range": {"price": {"gte": 1000, "lte": 5000}}},
        {"terms": {"brand": ["apple", "samsung"]}}
      ]
    }
  }
}'
```

### 7.5 实战：电商筛选功能


**完整的电商筛选实现**：
```bash
curl -X POST "localhost:9200/products/_search" \
-H "Content-Type: application/json" \
-d '{
  "query": {
    "match": {"category": "手机"}
  },
  "post_filter": {
    "bool": {
      "must": [
        {"range": {"price": {"gte": 2000, "lte": 6000}}},
        {"term": {"brand": "apple"}},
        {"term": {"status": "in_stock"}}
      ]
    }
  },
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          {"to": 2000},
          {"from": 2000, "to": 4000},
          {"from": 4000, "to": 6000},
          {"from": 6000}
        ]
      }
    },
    "brands": {
      "terms": {"field": "brand"}
    }
  }
}'
```

> 💡 **最佳实践**：在电商、内容管理等需要侧边栏统计的场景中，优先考虑使用post_filter

---

## 8. 📋 核心要点总结


### 8.1 查询类型选择指南


| 查询需求 | **推荐查询类型** | **使用场景** |
|---------|----------------|-------------|
| 🔸 **多条件组合** | `bool查询` | `同时满足多个条件` |
| 🔸 **数值/日期范围** | `range查询` | `价格、时间区间过滤` |
| 🔸 **精确匹配** | `term查询` | `状态、分类等固定值` |
| 🔸 **模糊匹配** | `wildcard查询` | `文件名、编码模式匹配` |
| 🔸 **字段完整性** | `exists查询` | `数据质量检查` |
| 🔸 **结果过滤** | `post_filter` | `不影响聚合的过滤` |

### 8.2 性能优化建议


**🔹 查询性能技巧**
```
✅ 优先使用filter而不是query（不需要评分时）
✅ 将筛选条件较强的放在前面
✅ 避免以通配符开头的查询
✅ 对经常查询的字段建立合适的映射
```

**🔹 常见错误避免**
```
❌ text字段使用term查询（应该用keyword字段）
❌ 过度使用通配符查询
❌ 忽略字段存在性检查
❌ 混淆query和post_filter的使用场景
```

### 8.3 实际应用记忆要点


**🎯 核心记忆口诀**
```
布尔查询组条件，must should filter分
范围查询gte lte，数值日期都能行
精确匹配用term，keyword字段是关键
通配符*?要慎用，避免开头做匹配
exists检查字段有，post_filter后处理
```

**📚 学习建议**
- 🔸 先掌握bool查询，这是最常用的
- 🔸 理解term和match的区别很重要
- 🔸 实际项目中多练习组合查询
- 🔸 关注查询性能，避免慢查询

> 💪 **实践建议**：建议在实际项目中先从简单查询开始，逐步增加复杂度，这样能更好地理解每种查询的特点和适用场景。