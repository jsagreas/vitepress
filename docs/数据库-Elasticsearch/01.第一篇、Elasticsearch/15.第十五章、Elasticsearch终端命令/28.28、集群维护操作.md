---
title: 28、集群维护操作
---
## 📚 目录

1. [集群维护基础概念](#1-集群维护基础概念)
2. [集群路由重分配操作](#2-集群路由重分配操作)
3. [集群分片分配控制](#3-集群分片分配控制)
4. [安全设置管理](#4-安全设置管理)
5. [数据同步与刷新](#5-数据同步与刷新)
6. [索引收缩操作](#6-索引收缩操作)
7. [实用维护技巧](#7-实用维护技巧)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ 集群维护基础概念


### 1.1 什么是集群维护


**🔧 通俗理解**
```
集群维护就像给一栋大楼做保养：
• 重新分配房间（重路由分片）
• 暂停装修（禁用分片分配）
• 更新安全系统（重载安全设置）
• 清理垃圾（同步刷新）
• 合并房间（索引收缩）
```

**📋 核心维护任务**
- **性能优化**：重新分配分片，平衡负载
- **资源管理**：控制分片分配，节约资源
- **安全更新**：重载配置，保持系统安全
- **数据整理**：同步刷新，清理缓存
- **空间优化**：收缩索引，节省存储

### 1.2 维护操作的重要性


**💡 为什么需要维护**
```
日常问题场景：
❌ 节点负载不均：某些节点压力大，某些很闲
❌ 分片分布混乱：数据分布不合理，影响性能  
❌ 配置需要更新：安全策略变化，需要重新加载
❌ 缓存积压：内存中有过期数据，需要清理
❌ 索引过大：某些索引太大，查询变慢

维护解决方案：
✅ 重新路由 → 平衡负载
✅ 控制分配 → 合理分布
✅ 重载设置 → 更新配置
✅ 同步刷新 → 清理缓存
✅ 收缩索引 → 优化存储
```

---

## 2. 🔄 集群路由重分配操作


### 2.1 什么是集群重路由


**🎯 概念解释**
```
重路由（Reroute）= 重新安排分片位置

类比理解：
就像重新安排班级座位：
• 把学习好的学生分散开（主分片分布）
• 让互补的同学坐一起（副本分片分布）
• 确保每排人数差不多（节点负载均衡）
```

**📊 重路由的作用**
- **负载均衡**：让每个节点的压力差不多
- **故障恢复**：节点宕机后重新分配分片
- **性能优化**：把分片放到最合适的节点上

### 2.2 模拟重路由操作


**🔍 干运行模式（推荐）**
```bash
# 模拟重路由 - 只看效果，不实际执行
curl -X POST "localhost:9200/_cluster/reroute?dry_run=true" \
  -H "Content-Type: application/json" \
  -d '{
    "commands": [
      {
        "move": {
          "index": "my_index",
          "shard": 0,
          "from_node": "node1",
          "to_node": "node2"
        }
      }
    ]
  }'
```

**💡 参数详解**
```
dry_run=true：只模拟，不实际执行
commands：要执行的重路由命令数组
move：移动分片命令
  - index：要移动的索引名
  - shard：分片编号
  - from_node：源节点
  - to_node：目标节点
```

### 2.3 实际执行重路由


**⚡ 真实执行**
```bash
# 实际执行重路由
curl -X POST "localhost:9200/_cluster/reroute" \
  -H "Content-Type: application/json" \
  -d '{
    "commands": [
      {
        "move": {
          "index": "logs",
          "shard": 1,
          "from_node": "node_heavy",
          "to_node": "node_light"
        }
      }
    ]
  }'
```

**📋 重路由命令类型**

| 命令类型 | 作用 | 使用场景 |
|---------|------|----------|
| `move` | 移动分片 | 负载均衡、硬件升级 |
| `cancel` | 取消分片分配 | 停止错误的分配 |
| `allocate_replica` | 分配副本分片 | 增加数据冗余 |
| `allocate_empty_primary` | 分配空主分片 | 数据丢失后重建 |

### 2.4 查看重路由结果


**📊 检查分片分布**
```bash
# 查看分片分布情况
curl -X GET "localhost:9200/_cat/shards?v&s=index"
```

**🔍 预期输出示例**
```
index  shard prirep state    docs store node
logs   0     p      STARTED  1000 1.2mb node1
logs   0     r      STARTED  1000 1.2mb node2
logs   1     p      STARTED   800 980kb node2  ← 已移动到node2
logs   1     r      STARTED   800 980kb node3
```

---

## 3. 🚫 集群分片分配控制


### 3.1 什么是分片分配控制


**🛑 概念理解**
```
分片分配控制 = 控制ES自动分配分片的行为

生活类比：
就像控制超市的自动补货系统：
• none：完全停止补货（禁用所有分配）
• primaries：只补主要商品（只分配主分片）
• new_primaries：只补新商品（只分配新索引的主分片）
• all：正常补货（默认，分配所有分片）
```

### 3.2 禁用分片分配


**🔒 完全禁用分配**
```bash
# 禁用所有分片分配
curl -X PUT "localhost:9200/_cluster/settings" \
  -H "Content-Type: application/json" \
  -d '{
    "persistent": {
      "cluster.routing.allocation.enable": "none"
    }
  }'
```

**⚠️ 使用场景**
```
何时禁用分片分配：
✅ 节点维护：要重启节点时
✅ 网络问题：网络不稳定时
✅ 硬件升级：更换硬件时
✅ 批量操作：大量数据迁移时

注意事项：
❌ 禁用期间新索引无法创建分片
❌ 故障节点的分片不会自动恢复
❌ 记得操作完成后重新启用
```

### 3.3 其他分配控制选项


**🎛️ 分级控制**
```bash
# 只允许主分片分配
curl -X PUT "localhost:9200/_cluster/settings" \
  -H "Content-Type: application/json" \
  -d '{
    "persistent": {
      "cluster.routing.allocation.enable": "primaries"
    }
  }'

# 只允许新索引的主分片分配
curl -X PUT "localhost:9200/_cluster/settings" \
  -H "Content-Type: application/json" \
  -d '{
    "persistent": {
      "cluster.routing.allocation.enable": "new_primaries"
    }
  }'

# 恢复正常分配（重要！）
curl -X PUT "localhost:9200/_cluster/settings" \
  -H "Content-Type: application/json" \
  -d '{
    "persistent": {
      "cluster.routing.allocation.enable": "all"
    }
  }'
```

### 3.4 检查分配设置


**🔍 查看当前设置**
```bash
# 查看集群设置
curl -X GET "localhost:9200/_cluster/settings?include_defaults=true&flat_settings=true"
```

---

## 4. 🔐 安全设置管理


### 4.1 什么是安全设置重载


**🔄 概念说明**
```
安全设置重载 = 在不重启ES的情况下更新安全配置

实际场景：
• 密码策略更新
• 证书文件更换  
• 访问权限调整
• 加密密钥轮换

好处：
✅ 不影响服务运行
✅ 配置立即生效
✅ 避免停机时间
```

### 4.2 重载本地节点安全设置


**🔧 本地节点重载**
```bash
# 重载当前节点的安全设置
curl -X POST "localhost:9200/_nodes/_local/_reload_secure_settings" \
  -H "Content-Type: application/json"
```

**📋 操作说明**
```
_nodes/_local：指定当前连接的节点
_reload_secure_settings：重载安全设置的API

重载内容包括：
• keystore中的密码
• SSL证书配置
• 认证相关设置
• 加密相关配置
```

### 4.3 重载所有节点安全设置


**🌐 集群范围重载**
```bash
# 重载所有节点的安全设置
curl -X POST "localhost:9200/_nodes/_all/_reload_secure_settings" \
  -H "Content-Type: application/json"

# 或者指定特定节点
curl -X POST "localhost:9200/_nodes/node1,node2/_reload_secure_settings" \
  -H "Content-Type: application/json"
```

### 4.4 带密码的安全设置重载


**🔑 需要密码的情况**
```bash
# 如果keystore有密码保护
curl -X POST "localhost:9200/_nodes/_local/_reload_secure_settings" \
  -H "Content-Type: application/json" \
  -d '{
    "secure_settings_password": "your_keystore_password"
  }'
```

**✅ 成功响应示例**
```json
{
  "_nodes": {
    "total": 1,
    "successful": 1,
    "failed": 0
  },
  "cluster_name": "my_cluster",
  "nodes": {
    "node1": {
      "reload_exception": null
    }
  }
}
```

---

## 5. 💾 数据同步与刷新


### 5.1 什么是同步刷新


**🔄 同步刷新解释**
```
同步刷新（Synced Flush）= 让所有分片副本保持数据一致

类比理解：
就像让所有分店的库存信息同步：
• 确保主店和分店的商品记录一致
• 清理过期的临时记录
• 为后续操作做准备

技术含义：
• 将内存中的数据写入磁盘
• 生成同步标识符
• 确保主分片和副本分片一致
```

### 5.2 执行同步刷新


**⚡ 全集群同步刷新**
```bash
# 对整个集群执行同步刷新
curl -X POST "localhost:9200/_flush/synced"
```

**🎯 指定索引同步刷新**
```bash
# 对特定索引执行同步刷新
curl -X POST "localhost:9200/my_index/_flush/synced"

# 对多个索引执行
curl -X POST "localhost:9200/index1,index2/_flush/synced"
```

### 5.3 同步刷新的使用场景


**📋 何时使用同步刷新**
```
✅ 索引迁移前：确保数据一致性
✅ 节点重启前：减少恢复时间  
✅ 备份操作前：保证备份数据完整
✅ 性能测试前：清理缓存影响
✅ 索引收缩前：准备索引操作

注意事项：
⚠️ 同步刷新会暂时影响写入性能
⚠️ 频繁执行可能影响集群性能
⚠️ 在低写入负载时执行效果最佳
```

### 5.4 检查同步刷新结果


**🔍 查看刷新状态**
```bash
# 查看索引的刷新统计信息
curl -X GET "localhost:9200/_stats/flush"
```

**📊 响应示例解读**
```json
{
  "indices": {
    "my_index": {
      "total": {
        "flush": {
          "total": 10,        // 总刷新次数
          "total_time_in_millis": 150  // 总耗时
        }
      }
    }
  }
}
```

---

## 6. 📦 索引收缩操作


### 6.1 什么是索引收缩


**🗜️ 收缩概念**
```
索引收缩（Shrink）= 把一个大索引变成小索引

生活类比：
就像把散装商品重新打包：
• 原来：10个小盒子装商品
• 收缩后：2个大盒子装同样的商品
• 好处：easier管理，节省空间

技术含义：
• 减少分片数量
• 保持数据不变
• 节省系统资源
• 提高查询效率
```

### 6.2 收缩前的准备工作


**📋 收缩条件检查**
```
收缩前必须满足：
✅ 源索引必须是只读的
✅ 源索引的所有分片必须在同一个节点上
✅ 目标分片数必须是源分片数的因子
✅ 集群健康状态必须是绿色

示例：
源索引：6个分片 → 可以收缩为 1、2、3、6个分片
源索引：8个分片 → 可以收缩为 1、2、4、8个分片
```

**🔧 准备步骤**
```bash
# 1. 设置索引为只读
curl -X PUT "localhost:9200/my_index/_settings" \
  -H "Content-Type: application/json" \
  -d '{
    "settings": {
      "index.blocks.write": true
    }
  }'

# 2. 将所有分片移动到一个节点
curl -X PUT "localhost:9200/my_index/_settings" \
  -H "Content-Type: application/json" \
  -d '{
    "settings": {
      "index.routing.allocation.require._name": "target_node_name"
    }
  }'
```

### 6.3 执行索引收缩


**🎯 基本收缩操作**
```bash
# 将my_index收缩为target_index
curl -X POST "localhost:9200/my_index/_shrink/target_index" \
  -H "Content-Type: application/json" \
  -d '{
    "settings": {
      "index.number_of_shards": 1,
      "index.number_of_replicas": 0,
      "index.codec": "best_compression"
    }
  }'
```

**📊 参数详解**
```
my_index：源索引名（要收缩的索引）
target_index：目标索引名（收缩后的新索引）

settings 配置：
• number_of_shards：目标分片数
• number_of_replicas：副本数  
• codec：压缩算法（可选）
```

### 6.4 收缩操作实例


**💡 完整收缩流程**
```bash
# 步骤1：查看原索引状态
curl -X GET "localhost:9200/_cat/indices/logs?v"

# 步骤2：设置只读
curl -X PUT "localhost:9200/logs/_settings" \
  -H "Content-Type: application/json" \
  -d '{"settings": {"index.blocks.write": true}}'

# 步骤3：执行收缩
curl -X POST "localhost:9200/logs/_shrink/logs_small" \
  -H "Content-Type: application/json" \
  -d '{
    "settings": {
      "index.number_of_shards": 1,
      "index.number_of_replicas": 1
    }
  }'

# 步骤4：检查收缩结果
curl -X GET "localhost:9200/_cat/indices/logs_small?v"
```

---

## 7. 🛠️ 实用维护技巧


### 7.1 维护操作最佳实践


**📋 操作前检查清单**
```
🔍 执行前必查：
□ 集群状态是否健康 (GET /_cluster/health)
□ 节点负载是否正常 (GET /_cat/nodes?v)
□ 是否有正在进行的任务 (GET /_cat/tasks?v)
□ 备份是否最新 (确保数据安全)

⏰ 最佳执行时间：
□ 业务低峰期
□ 维护窗口期
□ 用户活动最少时段
```

### 7.2 维护监控指标


**📊 关键监控指标**
```bash
# 集群健康状态
curl -X GET "localhost:9200/_cluster/health?level=indices"

# 节点统计信息
curl -X GET "localhost:9200/_nodes/stats"

# 分片分配状态
curl -X GET "localhost:9200/_cat/allocation?v"

# 正在进行的任务
curl -X GET "localhost:9200/_cat/tasks?v&detailed"
```

### 7.3 故障恢复技巧


**🚨 常见问题处理**

| 问题 | 症状 | 解决方案 |
|------|------|----------|
| 分片未分配 | 红色集群状态 | 检查节点可用性，手动重路由 |
| 节点负载不均 | 某节点CPU/内存高 | 执行分片重平衡 |
| 分配卡住 | 分片一直分配中 | 取消分配，重新分配 |
| 收缩失败 | 收缩操作错误 | 检查收缩条件，重置设置 |

### 7.4 维护脚本示例


**🔧 自动化维护脚本**
```bash
#!/bin/bash
# ES集群健康检查脚本

echo "=== ES集群维护检查 ==="

# 检查集群状态
HEALTH=$(curl -s "localhost:9200/_cluster/health" | jq -r '.status')
echo "集群状态: $HEALTH"

if [ "$HEALTH" != "green" ]; then
    echo "⚠️ 集群状态异常，请检查"
    curl -s "localhost:9200/_cluster/health?level=indices" | jq '.'
fi

# 检查未分配分片
UNASSIGNED=$(curl -s "localhost:9200/_cat/shards" | grep UNASSIGNED | wc -l)
echo "未分配分片数: $UNASSIGNED"

# 检查节点负载
echo "=== 节点负载情况 ==="
curl -s "localhost:9200/_cat/nodes?v&h=name,heap.percent,ram.percent,cpu,load_1m"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的维护操作


**🎯 核心命令速查**
```bash
# 模拟重路由（安全）
curl -X POST "localhost:9200/_cluster/reroute?dry_run=true"

# 禁用分片分配（维护时）
curl -X PUT "localhost:9200/_cluster/settings" \
  -d '{"persistent":{"cluster.routing.allocation.enable":"none"}}'

# 重载安全设置（配置更新）
curl -X POST "localhost:9200/_nodes/_local/_reload_secure_settings"

# 同步刷新（数据一致性）
curl -X POST "localhost:9200/_flush/synced"

# 索引收缩（空间优化）
curl -X POST "localhost:9200/my_index/_shrink/target_index"
```

### 8.2 关键理解要点


**🔹 维护操作的核心原则**
```
安全第一：
• 先模拟再执行（dry_run）
• 维护前检查集群状态
• 备份重要数据

性能考虑：
• 选择业务低峰期
• 监控操作进度
• 及时恢复正常设置

资源管理：
• 合理分配分片
• 定期清理缓存
• 优化索引结构
```

**🔹 维护操作的影响**
```
临时影响：
• 分片分配禁用期间可能影响新索引创建
• 同步刷新会短暂影响写入性能
• 索引收缩期间该索引不可写入

长期好处：
• 集群负载更均衡
• 查询性能得到提升
• 存储空间得到优化
```

### 8.3 实际应用指导


**🎯 维护时机选择**
- **日常维护**：业务低峰期执行重路由和同步刷新
- **版本升级**：升级前禁用分片分配，升级后恢复
- **硬件维护**：节点重启前禁用分配，重启后检查状态
- **性能优化**：定期执行索引收缩，清理历史数据

**💡 维护技巧**
- 使用`dry_run`参数预览操作效果
- 维护前后都要检查集群健康状态
- 记录维护操作日志，便于问题追踪
- 建立监控告警，及时发现异常

### 8.4 新手特别提醒


**⚠️ 重要注意事项**
```
禁用分片分配后一定要记得恢复：
curl -X PUT "localhost:9200/_cluster/settings" \
  -d '{"persistent":{"cluster.routing.allocation.enable":"all"}}'

索引收缩是不可逆操作：
• 收缩前一定要备份
• 确认收缩参数正确
• 测试环境先验证

安全设置重载需要权限：
• 确保有相应的操作权限
• keystore密码要正确
• 证书文件路径要正确
```

**🎯 学习建议**
1. **从模拟开始**：先用`dry_run`熟悉操作
2. **测试环境练习**：在测试集群上反复练习
3. **监控观察**：学会读懂各种状态信息
4. **逐步提升**：从简单操作到复杂维护

**核心记忆口诀**：
- 维护前检查，操作后恢复
- 模拟先行，安全第一  
- 监控到位，问题早知
- 备份充分，心中不慌