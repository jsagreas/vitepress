---
title: 18、缓存与内存管理
---
## 📚 目录

1. [缓存机制基础概念](#1-缓存机制基础概念)
2. [缓存清理操作实战](#2-缓存清理操作实战)
3. [字段数据缓存管理](#3-字段数据缓存管理)
4. [查询缓存优化](#4-查询缓存优化)
5. [内存监控与统计](#5-内存监控与统计)
6. [性能优化实践](#6-性能优化实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🧠 缓存机制基础概念


### 1.1 什么是Elasticsearch缓存


**通俗理解**：缓存就像你的书桌抽屉
```
📚 没有缓存的情况：
每次查资料都要去图书馆翻书 → 很慢

🗂️ 有缓存的情况：
常用资料放在抽屉里 → 随手就能拿到

Elasticsearch缓存原理：
把经常用到的数据和查询结果临时存在内存里
下次需要时直接从内存取，不用重新计算
```

### 1.2 ES中的缓存类型


**🔸 主要缓存类型概览**
```
缓存类型对比表：
┌─────────────────┬──────────────────┬──────────────────┐
│   缓存类型      │    存储内容      │    主要作用      │
├─────────────────┼──────────────────┼──────────────────┤
│ 字段数据缓存    │ 字段的排序聚合值 │ 加速排序和聚合   │
│ 查询缓存        │ 查询结果         │ 重复查询加速     │
│ 请求缓存        │ 整个搜索响应     │ 相同请求加速     │
│ 节点查询缓存    │ 过滤器结果       │ 过滤查询加速     │
└─────────────────┴──────────────────┴──────────────────┘
```

**💡 缓存的生命周期**
```
缓存的一生：
1️⃣ 数据首次查询 → 计算结果并存入缓存
2️⃣ 相同查询发生 → 直接从缓存返回（快！）
3️⃣ 内存不够用了 → 清理最久未使用的缓存
4️⃣ 数据被更新了 → 相关缓存自动失效
```

### 1.3 缓存对性能的影响


**⚡ 性能提升对比**
```
查询速度对比：
无缓存：100ms
有缓存：5ms    ← 提升20倍！

实际场景举例：
❌ 没有缓存：每次统计销售额都要重新计算所有订单
✅ 有了缓存：第一次计算后，后续查询瞬间返回结果
```

---

## 2. 🧹 缓存清理操作实战


### 2.1 清理所有缓存 - 大扫除


**🔸 全局缓存清理**
```bash
curl -X POST "localhost:9200/_cache/clear"
```

**💭 这个命令做了什么？**
- 就像给整个ES集群做大扫除
- 清空所有节点的所有类型缓存
- 释放被缓存占用的内存空间
- 下次查询时会重新建立缓存

**⚠️ 使用场景**
```
✅ 适合使用的时候：
• 系统内存不足时
• 怀疑缓存数据有问题时
• 重大数据更新后
• 定期维护清理时

❌ 不建议使用的时候：
• 业务高峰期（会影响性能）
• 频繁执行（失去缓存意义）
```

### 2.2 清理单个索引缓存 - 精准清理


**🔸 索引级缓存清理**
```bash
curl -X POST "localhost:9200/my_index/_cache/clear"
```

**💡 实际应用场景**
```
假设你有一个商品索引product_index：
1. 商品信息大量更新
2. 只清理product_index的缓存
3. 其他索引缓存保持不变
4. 既清理了问题，又保留了其他缓存
```

**🎯 多索引清理**
```bash
# 清理多个指定索引
curl -X POST "localhost:9200/index1,index2,index3/_cache/clear"

# 使用通配符清理
curl -X POST "localhost:9200/product*/_cache/clear"
```

### 2.3 清理特定类型缓存 - 有的放矢


**🔸 只清理字段数据缓存**
```bash
curl -X POST "localhost:9200/_cache/clear?fielddata=true"
```

**📋 字段数据缓存是什么？**
```
字段数据缓存存储的内容：
• 用于排序的字段值
• 用于聚合的字段值  
• 脚本中访问的字段值

通俗理解：
就像把常用的电话号码背下来
需要时不用翻通讯录，直接说出来
```

**🔸 只清理查询缓存**
```bash
curl -X POST "localhost:9200/_cache/clear?query=true"
```

**🔍 查询缓存是什么？**
```
查询缓存存储的内容：
• 过滤查询的结果
• 聚合查询的中间结果
• 复杂查询的计算结果

实际例子：
第一次查询"价格>100的商品" → 计算并缓存结果
后续相同查询 → 直接返回缓存结果
```

---

## 3. 📊 字段数据缓存管理


### 3.1 字段数据缓存原理


**🔸 什么时候会用到字段数据缓存？**
```
常见使用场景：
1️⃣ 排序操作
   GET /products/_search
   {
     "sort": [{"price": "desc"}]
   }

2️⃣ 聚合分析
   GET /products/_search
   {
     "aggs": {
       "price_ranges": {
         "range": {"field": "price"}
       }
     }
   }

3️⃣ 脚本计算
   使用价格字段进行复杂计算
```

**💾 内存使用特点**
```
字段数据缓存的特性：
• 延迟加载：用到时才加载到内存
• 全量加载：一旦加载，整个字段的所有值都加载
• 持久保存：直到内存不足或手动清理才释放

内存占用估算：
文本字段：每个文档 ~50-200 字节
数值字段：每个文档 ~8-16 字节
日期字段：每个文档 ~8 字节
```

### 3.2 字段数据缓存监控


**🔸 查看字段数据统计**
```bash
curl -X GET "localhost:9200/_nodes/stats/indices/fielddata"
```

**📊 响应结果解读**
```json
{
  "nodes": {
    "node1": {
      "indices": {
        "fielddata": {
          "memory_size_in_bytes": 1048576,    // 🔸 当前占用内存
          "evictions": 0,                     // 🔸 清理次数
          "fields": {
            "price": {
              "memory_size_in_bytes": 524288  // 🔸 单个字段占用
            }
          }
        }
      }
    }
  }
}
```

**📈 关键指标含义**
```
重要监控指标：
┌─────────────────┬──────────────────┬──────────────────┐
│     指标        │      含义        │    关注点        │
├─────────────────┼──────────────────┼──────────────────┤
│ memory_size     │ 当前内存占用     │ 是否过高         │
│ evictions       │ 被清理的次数     │ 频繁清理说明内存不足 │
│ fields          │ 各字段占用详情   │ 找出占用大户     │
└─────────────────┴──────────────────┴──────────────────┘
```

### 3.3 字段数据缓存优化策略


**🎯 优化实践指南**
```
优化策略等级：

🟢 基础优化：
• 避免对text类型字段排序聚合
• 使用keyword类型替代text进行操作
• 合理设置fielddata缓存大小限制

🟡 进阶优化：
• 使用doc_values代替fielddata
• 对高基数字段谨慎使用聚合
• 监控内存使用情况定期清理

🔴 高级优化：
• 设计时考虑缓存友好的数据结构
• 使用预聚合减少实时计算
• 分片设计考虑缓存分布
```

---

## 4. 🔍 查询缓存优化


### 4.1 查询缓存工作机制


**🔸 缓存命中条件**
```
查询缓存的触发条件：
✅ 必须满足的条件：
• 查询是filter context（过滤上下文）
• 查询结果集相对稳定
• 查询被重复执行

❌ 不会缓存的情况：
• query context查询（算分查询）
• 包含now()等时间函数的查询
• 查询结果经常变化
```

**💡 缓存生效示例**
```bash
# ✅ 会被缓存的查询
curl -X GET "localhost:9200/products/_search" -H 'Content-Type: application/json' -d'
{
  "query": {
    "bool": {
      "filter": [
        {"term": {"category": "electronics"}},
        {"range": {"price": {"gte": 100}}}
      ]
    }
  }
}'

# ❌ 不会被缓存的查询
curl -X GET "localhost:9200/products/_search" -H 'Content-Type: application/json' -d'
{
  "query": {
    "match": {"title": "phone"}  // 需要算分，不会缓存
  }
}'
```

### 4.2 查询缓存监控统计


**🔸 查看查询缓存统计**
```bash
curl -X GET "localhost:9200/_nodes/stats/indices/query_cache"
```

**📊 统计数据解读**
```json
{
  "nodes": {
    "node1": {
      "indices": {
        "query_cache": {
          "memory_size_in_bytes": 2097152,    // 当前占用内存
          "total_count": 1000,                // 总缓存条目数
          "hit_count": 750,                   // 命中次数
          "miss_count": 250,                  // 未命中次数
          "cache_size": 100,                  // 当前缓存大小
          "cache_count": 500,                 // 缓存过的查询总数
          "evictions": 50                     // 被清理的条目数
        }
      }
    }
  }
}
```

**📈 缓存效率计算**
```
关键性能指标：

缓存命中率 = hit_count / (hit_count + miss_count)
命中率 = 750 / (750 + 250) = 75%

✅ 良好的命中率：> 80%
🟡 一般的命中率：50% - 80%  
❌ 较差的命中率：< 50%

提升命中率的方法：
• 优化查询，使用更多的filter context
• 避免随机性查询
• 合理设置缓存大小
```

### 4.3 查询缓存配置优化


**⚙️ 缓存大小配置**
```bash
# 设置查询缓存大小（集群级别）
curl -X PUT "localhost:9200/_cluster/settings" -H 'Content-Type: application/json' -d'
{
  "persistent": {
    "indices.queries.cache.size": "20%"  // 使用20%的堆内存
  }
}'
```

**🎛️ 索引级别设置**
```bash
# 关闭特定索引的查询缓存
curl -X PUT "localhost:9200/my_index/_settings" -H 'Content-Type: application/json' -d'
{
  "index.queries.cache.enabled": false
}'
```

---

## 5. 📊 内存监控与统计


### 5.1 综合内存使用统计


**🔸 获取节点内存统计**
```bash
curl -X GET "localhost:9200/_nodes/stats/jvm,indices"
```

**📋 内存分布概览**
```
ES内存使用分布图：
┌─────────────────────────────────────┐
│           JVM堆内存 (100%)          │
├─────────────────┬───────────────────┤
│   ES应用 (70%)  │   系统保留 (30%)  │
├─────────────────┼───────────────────┤
│ 字段数据缓存    │                   │
│ 查询缓存        │   GC、系统操作    │
│ 索引缓存        │   网络缓冲等      │
│ 段内存          │                   │
└─────────────────┴───────────────────┘
```

### 5.2 内存告警阈值设置


**⚠️ 建议的告警阈值**
```
内存使用告警级别：

🟢 正常状态：< 70%
🟡 注意状态：70% - 85%
🔴 危险状态：> 85%

具体监控指标：
• 字段数据缓存：< 40% 堆内存
• 查询缓存：< 10% 堆内存
• 总体JVM堆使用：< 75%
```

**📊 监控命令示例**
```bash
# 简化的内存监控
curl -X GET "localhost:9200/_cat/nodes?v&h=name,heap.percent,ram.percent,fielddata.memory,query_cache.memory"
```

### 5.3 内存问题诊断流程


**🔍 问题诊断步骤**
```
内存问题诊断流程：

1️⃣ 检查总体内存使用
   curl -X GET "localhost:9200/_nodes/stats/jvm"

2️⃣ 检查缓存分布
   curl -X GET "localhost:9200/_nodes/stats/indices"

3️⃣ 找出问题索引
   curl -X GET "localhost:9200/_cat/indices?v&s=store.size:desc"

4️⃣ 检查字段数据详情
   curl -X GET "localhost:9200/_nodes/stats/indices/fielddata?fields=*"

5️⃣ 制定清理策略
   根据结果选择性清理缓存
```

---

## 6. 🚀 性能优化实践


### 6.1 缓存优化最佳实践


**✅ 推荐做法**
```
缓存优化策略：

🎯 数据建模优化：
• 避免对text字段进行排序聚合
• 使用keyword替代text进行terms聚合
• 合理设计字段类型

🎯 查询优化：
• 优先使用filter context而不是query context
• 将稳定的条件放在filter中
• 避免脚本查询中访问大量字段

🎯 缓存管理：
• 定期监控缓存使用情况
• 在业务低峰期清理缓存
• 设置合理的缓存大小限制
```

### 6.2 内存不足应急处理


**🚨 应急处理步骤**
```
内存告警处理SOP：

紧急处理（5分钟内）：
1. 清理查询缓存
   curl -X POST "localhost:9200/_cache/clear?query=true"

2. 清理最大索引的字段数据缓存
   curl -X POST "localhost:9200/largest_index/_cache/clear?fielddata=true"

中期处理（30分钟内）：
3. 分析内存使用分布
4. 识别占用内存最多的字段
5. 清理特定字段缓存

长期优化（1-3天内）：
6. 优化数据模型和查询
7. 调整缓存配置
8. 考虑扩容或分片调整
```

### 6.3 缓存清理自动化脚本


**🤖 自动化清理策略**
```bash
#!/bin/bash
# ES缓存自动清理脚本

ES_HOST="localhost:9200"

# 检查内存使用率
memory_usage=$(curl -s "$ES_HOST/_nodes/stats/jvm" | jq '.nodes[].jvm.mem.heap_used_percent')

if [ "$memory_usage" -gt 80 ]; then
    echo "内存使用率超过80%，开始清理缓存..."
    
    # 清理查询缓存
    curl -X POST "$ES_HOST/_cache/clear?query=true"
    
    # 如果还是很高，清理字段数据缓存
    if [ "$memory_usage" -gt 85 ]; then
        curl -X POST "$ES_HOST/_cache/clear?fielddata=true"
    fi
    
    echo "缓存清理完成"
fi
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🔸 缓存类型与作用**
```
字段数据缓存：加速排序和聚合操作
查询缓存：缓存过滤查询结果
请求缓存：缓存整个搜索响应
节点查询缓存：缓存分片级别的查询结果
```

**🔸 关键命令速查**
```
全局缓存清理：   curl -X POST "localhost:9200/_cache/clear"
索引缓存清理：   curl -X POST "localhost:9200/index_name/_cache/clear"
字段数据清理：   curl -X POST "localhost:9200/_cache/clear?fielddata=true"
查询缓存清理：   curl -X POST "localhost:9200/_cache/clear?query=true"
缓存统计查看：   curl -X GET "localhost:9200/_nodes/stats/indices"
```

### 7.2 实际应用指导原则


**🎯 使用场景判断**
```
什么时候清理缓存：
✅ 内存使用率超过80%
✅ 大量数据更新后
✅ 查询性能明显下降
✅ 定期维护清理

什么时候不要清理：
❌ 业务高峰期
❌ 没有内存压力时
❌ 频繁执行清理
```

**⚡ 性能优化要点**
```
缓存优化核心思路：
1. 监控为先：定期检查缓存使用情况
2. 精准清理：只清理有问题的缓存类型
3. 预防为主：优化查询和数据模型
4. 应急预案：准备内存告警处理流程
```

### 7.3 监控指标与告警阈值


**📊 关键监控指标**
```
核心监控指标：
┌─────────────────┬──────────────┬──────────────┐
│     指标        │   正常范围   │   告警阈值   │
├─────────────────┼──────────────┼──────────────┤
│ 堆内存使用率    │   < 70%      │    > 85%     │
│ 字段数据缓存    │   < 40%      │    > 60%     │
│ 查询缓存使用    │   < 10%      │    > 20%     │
│ 缓存命中率      │   > 80%      │    < 50%     │
│ 缓存清理频率    │   < 1次/小时 │   > 5次/小时 │
└─────────────────┴──────────────┴──────────────┘
```

**🔔 告警处理建议**
```
告警响应流程：
1. 立即检查：内存使用分布情况
2. 快速处理：清理占用最大的缓存类型
3. 根因分析：找出内存激增的原因
4. 长期优化：调整配置和查询策略
```

**💡 记忆要点**
- 缓存是提速神器，但也是内存大户
- 监控先行，精准清理，预防为主
- 字段数据缓存通常是内存占用大户
- 查询缓存优化要从查询设计入手
- 应急处理要快，长期优化要稳