---
title: 9、文档版本与并发控制
---
## 📚 目录

1. [文档版本控制基础概念](#1-文档版本控制基础概念)
2. [版本号控制机制详解](#2-版本号控制机制详解)
3. [序列号并发控制](#3-序列号并发控制)
4. [文档创建模式控制](#4-文档创建模式控制)
5. [冲突处理与重试策略](#5-冲突处理与重试策略)
6. [乐观锁并发控制机制](#6-乐观锁并发控制机制)
7. [版本冲突处理策略](#7-版本冲突处理策略)
8. [实际应用场景与最佳实践](#8-实际应用场景与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 文档版本控制基础概念


### 1.1 什么是文档版本控制


**通俗理解**：想象你在编辑一份Word文档，每次保存时都会生成一个新版本。Elasticsearch的文档版本控制就像这样，每次修改文档时都会记录版本信息。

```
文档修改过程：
第1次创建 → 版本1
第1次修改 → 版本2  
第2次修改 → 版本3
...
```

> 💡 **核心理念**：版本控制是为了**防止数据冲突**和**保证数据一致性**

### 1.2 为什么需要版本控制


**现实问题场景**：
```
时间线    用户A                 用户B
10:00    读取商品价格: 100元
10:01                         读取商品价格: 100元
10:02    修改价格为: 120元
10:03                         修改价格为: 110元
结果：谁的修改生效？
```

**版本控制解决方案**：
- 🔒 **防止覆盖**：确保不会意外覆盖别人的修改
- ✅ **数据一致性**：保证数据的准确性
- 🔄 **冲突检测**：及时发现并处理冲突

### 1.3 Elasticsearch版本控制的两种方式


```
┌─────────────────────────────────────────────┐
│              ES版本控制机制                    │
├─────────────────────┬───────────────────────┤
│    旧版本方式         │      新版本方式          │
│   (ES 6.x及以前)     │    (ES 7.x及以后)      │
├─────────────────────┼───────────────────────┤
│   基于_version字段    │   基于seq_no和         │
│   简单递增数字        │   primary_term        │
│   内部版本号          │   更精确的控制          │
└─────────────────────┴───────────────────────┘
```

---

## 2. 🔢 版本号控制机制详解


### 2.1 传统版本号控制基础


**基本概念**：每个文档都有一个`_version`字段，从1开始，每次修改时自动递增。

> 📖 **概念解释**：`_version`就像文档的"修改次数计数器"

### 2.2 版本号控制的curl命令


**指定版本创建/更新文档**：
```bash
curl -X PUT "localhost:9200/my_index/_doc/1?version=1" \
-H 'Content-Type: application/json' \
-d '{
  "name": "张三",
  "age": 25
}'
```

**命令详解**：
- `version=1`：要求文档当前版本必须是1才能执行操作
- 如果版本不匹配，会返回`409 Conflict`错误

### 2.3 版本号控制实际操作流程


```
操作流程图：
客户端 ──────────── Elasticsearch集群
   │                     │
   │ ①发送version=1请求    │
   ├────────────────────→│
   │                     │ ②检查当前版本
   │                     │ 是否为1？
   │                     │
   │ ③版本匹配：更新成功    │
   │ 版本不匹配：返回409   │
   │←────────────────────┤
```

**实际演示**：
```bash
# 第一次创建文档（版本变为1）
curl -X PUT "localhost:9200/products/_doc/1" \
-H 'Content-Type: application/json' \
-d '{"name": "手机", "price": 2000}'

# 使用版本控制更新（要求当前版本是1）
curl -X PUT "localhost:9200/products/_doc/1?version=1" \
-H 'Content-Type: application/json' \
-d '{"name": "手机", "price": 2200}'

# 如果再次使用version=1，会失败，因为版本已经是2了
```

### 2.4 版本号控制的限制与问题


**主要限制**：
- ⚠️ **不够精确**：只能检查版本号，无法处理分布式环境的复杂情况
- ⚠️ **已废弃**：在ES 7.0+中不推荐使用
- ⚠️ **功能单一**：无法处理分片级别的并发控制

---

## 3. 🎯 序列号并发控制


### 3.1 序列号控制机制原理


**什么是seq_no和primary_term**：

> 📖 **通俗解释**：
> - `seq_no`：就像银行流水号，每个操作都有唯一编号
> - `primary_term`：就像银行营业部编号，标识主分片的"任期"

```
Elasticsearch文档元信息：
┌─────────────────────────────┐
│ 文档ID: product_001          │
│ seq_no: 15 ←─ 操作序列号      │
│ primary_term: 3 ←─ 主分片任期 │
│ 内容: {"name": "手机"}       │
└─────────────────────────────┘
```

### 3.2 序列号控制的curl命令


**基本语法**：
```bash
curl -X PUT "localhost:9200/my_index/_doc/1?if_seq_no=1&if_primary_term=1" \
-H 'Content-Type: application/json' \
-d '{
  "name": "李四",
  "age": 30
}'
```

**参数含义**：
- `if_seq_no=1`：要求文档的当前序列号必须是1
- `if_primary_term=1`：要求主分片任期必须是1
- 两个条件必须**同时满足**才能执行操作

### 3.3 序列号获取与使用流程


```
完整操作流程：
①读取文档 → ②获取seq_no和primary_term → ③带条件更新

步骤详解：
客户端                    Elasticsearch
   │                         │
   │ ①GET获取文档信息          │
   ├────────────────────────→│
   │←─返回seq_no=5,term=2─────┤
   │                         │
   │ ②带条件更新               │
   │ if_seq_no=5&if_term=2   │
   ├────────────────────────→│
   │←─成功/失败───────────────┤
```

**实际操作示例**：
```bash
# 1. 先获取文档当前状态
curl -X GET "localhost:9200/products/_doc/1"

# 返回结果包含：
# "_seq_no": 5,
# "_primary_term": 2

# 2. 基于获取的序列号更新
curl -X PUT "localhost:9200/products/_doc/1?if_seq_no=5&if_primary_term=2" \
-H 'Content-Type: application/json' \
-d '{"name": "智能手机", "price": 2500}'
```

### 3.4 序列号控制的优势


**相比传统版本号的优势**：
- ✅ **分布式友好**：考虑了分片和节点的情况
- ✅ **更精确**：双重检查机制
- ✅ **官方推荐**：ES 7.x+的标准做法

| 特性对比 | 传统version | seq_no+primary_term |
|---------|-------------|-------------------|
| **精确度** | 🔶 一般 | 🔥 很高 |
| **分布式支持** | 🔶 基础 | 🔥 完善 |
| **官方支持** | ❌ 已废弃 | ✅ 推荐 |
| **复杂度** | 🔥 简单 | 🔶 中等 |

---

## 4. 🚀 文档创建模式控制


### 4.1 什么是创建模式控制


**通俗理解**：创建模式控制就像告诉Elasticsearch："我只要创建新文档，如果已经存在就别动它"。

> 💡 **核心用途**：防止意外覆盖已存在的文档

### 4.2 创建模式的curl命令


**基本语法**：
```bash
curl -X PUT "localhost:9200/my_index/_doc/1?op_type=create" \
-H 'Content-Type: application/json' \
-d '{
  "name": "王五",
  "status": "new"
}'
```

**参数说明**：
- `op_type=create`：指定操作类型为"仅创建"
- 如果文档ID已存在，返回`409 Conflict`错误

### 4.3 创建模式的应用场景


**典型场景**：
```
场景1：用户注册系统
- 确保用户ID不会被重复创建
- 防止覆盖已有用户信息

场景2：订单系统  
- 确保订单号唯一性
- 防止重复提交订单

场景3：日志系统
- 确保日志条目不被覆盖
- 保持数据完整性
```

### 4.4 创建模式与普通PUT的区别


```
操作对比图：
普通PUT操作                 创建模式操作
     │                          │
  文档存在？                  文档存在？
   │    │                     │     │
  是│   │否                   是│    │否
   │    │                     │     │
 覆盖更新 创建               返回409  创建
```

**实际测试**：
```bash
# 1. 使用创建模式创建文档（成功）
curl -X PUT "localhost:9200/users/_doc/user001?op_type=create" \
-H 'Content-Type: application/json' \
-d '{"name": "张三", "email": "zhang@example.com"}'

# 2. 再次使用创建模式（失败，返回409）
curl -X PUT "localhost:9200/users/_doc/user001?op_type=create" \
-H 'Content-Type: application/json' \
-d '{"name": "李四", "email": "li@example.com"}'
```

### 4.5 创建模式的替代写法


**使用POST的自动生成ID**：
```bash
# 自动生成文档ID，避免冲突
curl -X POST "localhost:9200/users/_doc" \
-H 'Content-Type: application/json' \
-d '{"name": "自动ID用户", "email": "auto@example.com"}'
```

**使用PUT的_create端点**：
```bash
# 与op_type=create等效的写法
curl -X PUT "localhost:9200/users/_create/user002" \
-H 'Content-Type: application/json' \
-d '{"name": "专用创建", "email": "create@example.com"}'
```

---

## 5. 🔄 冲突处理与重试策略


### 5.1 什么是冲突与重试


**冲突产生的原因**：
```
时间轴示例：
T1: 用户A读取文档 (seq_no=10)
T2: 用户B读取文档 (seq_no=10)  
T3: 用户A成功更新 (seq_no变为11)
T4: 用户B尝试更新 (基于seq_no=10) ←── 冲突！
```

> 📖 **通俗解释**：就像两个人同时编辑同一份文档，后保存的人会发现文档已经被改过了

### 5.2 冲突重试的curl命令


**基本语法**：
```bash
curl -X POST "localhost:9200/my_index/_update/1?retry_on_conflict=3" \
-H 'Content-Type: application/json' \
-d '{
  "doc": {
    "age": 26
  }
}'
```

**参数说明**：
- `retry_on_conflict=3`：发生冲突时最多重试3次
- 只适用于`_update`操作，不适用于PUT操作

### 5.3 重试机制的工作原理


```
重试流程图：
①尝试更新 → ②检测冲突 → ③重新读取 → ④再次尝试 → ⑤成功/失败

详细步骤：
客户端                    Elasticsearch
   │                         │
   │ ①发送update请求          │
   ├────────────────────────→│
   │                         │ ②检测到冲突
   │                         │ ③自动重新读取最新版本
   │                         │ ④基于最新版本重试
   │                         │
   │ ⑤返回成功或最终失败      │
   │←────────────────────────┤
```

### 5.4 重试策略的实际应用


**库存扣减场景**：
```bash
# 商品库存扣减（支持并发重试）
curl -X POST "localhost:9200/products/_update/phone001?retry_on_conflict=5" \
-H 'Content-Type: application/json' \
-d '{
  "script": {
    "source": "ctx._source.stock = ctx._source.stock - params.quantity",
    "params": {
      "quantity": 1
    }
  }
}'
```

**重试次数选择建议**：
- 🔥 **高并发场景**：`retry_on_conflict=5-10`
- 🔶 **一般场景**：`retry_on_conflict=3`
- 🔶 **低并发场景**：`retry_on_conflict=1`

### 5.5 重试失败的处理


**当重试全部失败时**：
```bash
# 返回结果示例
{
  "error": {
    "type": "version_conflict_engine_exception",
    "reason": "[1]: version conflict, current version [15] is different than the one provided [10]"
  }
}
```

**客户端处理策略**：
1. ⏳ **延迟重试**：等待一段时间后重新尝试整个操作
2. 🔄 **业务重试**：重新获取最新数据后再操作
3. ❌ **放弃操作**：向用户提示操作失败

---

## 6. 🔐 乐观锁并发控制机制


### 6.1 什么是乐观锁


**传统锁概念对比**：
```
悲观锁思想："先锁住，再操作"
┌─────────┐    ┌──────┐    ┌─────────┐
│ 获取锁   │ →  │ 操作  │ →  │ 释放锁   │
└─────────┘    └──────┘    └─────────┘

乐观锁思想："先操作，冲突时再处理"  
┌─────────┐    ┌──────┐    ┌─────────┐
│ 记录版本 │ →  │ 操作  │ →  │ 检查冲突 │
└─────────┘    └──────┘    └─────────┘
```

> 💡 **核心理念**：乐观锁假设冲突很少发生，所以不提前加锁，而是在操作时检查是否有冲突

### 6.2 Elasticsearch的乐观锁实现


**实现机制**：
```
Elasticsearch乐观锁 = 版本检查 + 原子操作

操作流程：
①读取文档及其版本信息
②在内存中修改数据  
③提交时检查版本是否变化
④版本一致→成功，版本不一致→冲突
```

### 6.3 乐观锁的完整应用示例


**电商库存管理场景**：
```bash
# 1. 读取商品信息（获取版本）
curl -X GET "localhost:9200/products/_doc/iphone13"

# 假设返回：seq_no=10, primary_term=1, stock=100

# 2. 业务逻辑：检查库存是否足够
# if (stock >= order_quantity) { proceed }

# 3. 执行库存扣减（带版本检查）
curl -X PUT "localhost:9200/products/_doc/iphone13?if_seq_no=10&if_primary_term=1" \
-H 'Content-Type: application/json' \
-d '{
  "name": "iPhone 13",
  "price": 5999,
  "stock": 99
}'
```

### 6.4 乐观锁的优缺点分析


| 特性 | 乐观锁 | 悲观锁 |
|------|--------|--------|
| **性能** | 🔥 高（无锁等待） | 🔶 低（需要等待锁） |
| **冲突处理** | 🔶 需要重试逻辑 | 🔥 自动排队 |
| **适用场景** | 🔥 读多写少 | 🔥 写操作频繁 |
| **实现复杂度** | 🔶 中等 | 🔥 简单 |

**Elasticsearch选择乐观锁的原因**：
- ✅ **分布式友好**：避免分布式锁的复杂性
- ✅ **高性能**：无锁等待，吞吐量高
- ✅ **可扩展**：适合大规模集群

---

## 7. ⚡ 版本冲突处理策略


### 7.1 冲突检测与识别


**冲突的表现形式**：
```bash
# HTTP状态码：409 Conflict
# 错误类型：version_conflict_engine_exception

{
  "error": {
    "type": "version_conflict_engine_exception",
    "reason": "[1]: version conflict, current version [3] is different than the one provided [2]",
    "index": "my_index",
    "shard": "0"
  },
  "status": 409
}
```

### 7.2 客户端冲突处理策略


**策略1：立即重试**
```bash
#!/bin/bash
# 简单重试脚本示例
for i in {1..3}; do
  # 重新获取最新版本
  latest_doc=$(curl -s "localhost:9200/products/_doc/1")
  seq_no=$(echo $latest_doc | jq -r '._seq_no')
  primary_term=$(echo $latest_doc | jq -r '._primary_term')
  
  # 基于最新版本重试
  if curl -X PUT "localhost:9200/products/_doc/1?if_seq_no=$seq_no&if_primary_term=$primary_term" \
     -H 'Content-Type: application/json' \
     -d '{"name": "updated"}'; then
    echo "Success on attempt $i"
    break
  fi
  
  sleep 0.1  # 短暂延迟
done
```

**策略2：指数退避重试**
```
重试间隔规律：
第1次冲突 → 等待100ms → 重试
第2次冲突 → 等待200ms → 重试  
第3次冲突 → 等待400ms → 重试
...
```

**策略3：业务层面处理**
```
用户界面提示："数据已被其他用户修改，请刷新后重试"
自动合并策略：尝试智能合并不冲突的字段
回滚策略：撤销当前操作，恢复到之前状态
```

### 7.3 不同场景的处理策略


**高并发库存扣减**：
- 🔄 **快速重试**：使用`retry_on_conflict`参数
- 📊 **监控告警**：超过阈值时触发告警
- 🎯 **限流保护**：控制并发请求数量

**用户资料更新**：
- 🔔 **用户提示**：告知数据已变更，询问是否覆盖
- 🔄 **字段合并**：只更新用户修改的字段
- 💾 **保存草稿**：保留用户输入，便于重新提交

**批量数据导入**：
- ⏭️ **跳过冲突**：记录冲突文档，继续处理其他数据
- 📝 **错误日志**：详细记录冲突信息便于后续处理
- 🔄 **后续处理**：专门处理冲突的数据

---

## 8. 🎯 实际应用场景与最佳实践


### 8.1 电商系统应用实践


**商品库存管理**：
```bash
# 完整的库存扣减流程
# 1. 查询商品库存
curl -X GET "localhost:9200/products/_doc/phone001" | jq '{stock: ._source.stock, seq_no: ._seq_no, primary_term: ._primary_term}'

# 2. 检查库存充足性（应用层逻辑）
# 3. 扣减库存（原子操作）
curl -X POST "localhost:9200/products/_update/phone001?retry_on_conflict=3" \
-H 'Content-Type: application/json' \
-d '{
  "script": {
    "source": "if (ctx._source.stock >= params.quantity) { ctx._source.stock -= params.quantity } else { ctx.op = \"noop\" }",
    "params": { "quantity": 1 }
  }
}'
```

**订单状态管理**：
```bash
# 订单状态流转控制
curl -X PUT "localhost:9200/orders/_doc/order123?if_seq_no=5&if_primary_term=1" \
-H 'Content-Type: application/json' \
-d '{
  "order_id": "order123",
  "status": "paid",
  "updated_at": "2024-01-20T10:30:00Z"
}'
```

### 8.2 内容管理系统应用


**文章编辑冲突处理**：
```bash
# 获取文章当前版本
curl -X GET "localhost:9200/articles/_doc/article001"

# 基于版本进行更新
curl -X PUT "localhost:9200/articles/_doc/article001?if_seq_no=8&if_primary_term=2" \
-H 'Content-Type: application/json' \
-d '{
  "title": "更新后的标题",
  "content": "更新后的内容",
  "last_modified": "2024-01-20T10:30:00Z",
  "editor": "user123"
}'
```

### 8.3 最佳实践总结


**🔥 核心原则**：
1. **总是使用版本控制**：在生产环境中始终启用并发控制
2. **选择合适的控制方式**：ES 7.x+使用seq_no，旧版本使用version
3. **设计重试逻辑**：客户端必须处理冲突重试
4. **监控冲突频率**：过高的冲突率需要优化设计

**⚠️ 常见陷阱**：
- ❌ **忽略冲突检查**：可能导致数据丢失
- ❌ **无限重试**：可能导致系统资源耗尽
- ❌ **不当的错误处理**：影响用户体验

**✅ 推荐做法**：
- 🎯 **业务层面设计**：减少不必要的冲突
- 📊 **监控和告警**：及时发现异常情况
- 🔄 **优雅降级**：冲突过多时的备选方案

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 版本控制目的：防止数据冲突，保证一致性
🔸 两种控制方式：version字段（旧）vs seq_no+primary_term（新）
🔸 乐观锁机制：ES采用乐观锁而非悲观锁
🔸 冲突处理策略：重试、用户提示、业务处理
🔸 创建模式：op_type=create防止覆盖
```

### 9.2 关键curl命令速查


| 功能 | 命令格式 | 说明 |
|------|----------|------|
| **版本控制** | `?version=N` | 传统版本号控制（已废弃） |
| **序列号控制** | `?if_seq_no=N&if_primary_term=N` | 推荐的并发控制方式 |
| **仅创建** | `?op_type=create` | 防止覆盖已存在文档 |
| **冲突重试** | `?retry_on_conflict=N` | 自动重试N次（仅_update） |

### 9.3 实际应用指导


**🔹 选择合适的控制方式**：
```
ES 7.x+ → 使用 seq_no + primary_term
ES 6.x及以前 → 使用 version
高并发场景 → 启用 retry_on_conflict
严格一致性 → 客户端实现重试逻辑
```

**🔹 冲突处理策略**：
```
系统设计阶段：
- 减少不必要的并发修改
- 设计合理的数据分片策略
- 考虑最终一致性模型

运行时处理：
- 实现智能重试机制
- 提供友好的用户提示
- 监控冲突频率和系统性能
```

### 9.4 记忆要点


**💡 核心记忆**：
- **seq_no + primary_term** 是现代ES的标准做法
- **乐观锁** 提供高性能的并发控制
- **冲突处理** 是客户端的重要责任
- **版本控制** 是数据一致性的重要保障

> 🎯 **学习建议**：在实际项目中多练习并发场景的处理，理解不同策略的适用场景，逐步掌握ES的并发控制精髓。