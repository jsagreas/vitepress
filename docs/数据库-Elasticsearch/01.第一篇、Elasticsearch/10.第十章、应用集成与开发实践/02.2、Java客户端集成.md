---
title: 2ã€Javaå®¢æˆ·ç«¯é›†æˆ
---
## ğŸ“š ç›®å½•

1. [Javaå®¢æˆ·ç«¯æ¦‚è¿°](#1-Javaå®¢æˆ·ç«¯æ¦‚è¿°)
2. [Rest ClientåŸºç¡€ä½¿ç”¨](#2-Rest-ClientåŸºç¡€ä½¿ç”¨)
3. [High Level Rest Clientè¯¦è§£](#3-High-Level-Rest-Clientè¯¦è§£)
4. [Spring Data Elasticsearché›†æˆ](#4-Spring-Data-Elasticsearché›†æˆ)
5. [é«˜çº§ç‰¹æ€§ä¸ä¼˜åŒ–](#5-é«˜çº§ç‰¹æ€§ä¸ä¼˜åŒ–)
6. [å®æˆ˜æœ€ä½³å®è·µ](#6-å®æˆ˜æœ€ä½³å®è·µ)
7. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#7-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸŒ Javaå®¢æˆ·ç«¯æ¦‚è¿°


### 1.1 ä¸ºä»€ä¹ˆéœ€è¦Javaå®¢æˆ·ç«¯


**ç°å®åœºæ™¯**ï¼šæƒ³è±¡ä½ åœ¨å¼€å‘ä¸€ä¸ªç”µå•†ç½‘ç«™ï¼Œéœ€è¦å®ç°å•†å“æœç´¢åŠŸèƒ½

```
ä¼ ç»Ÿæ–¹å¼çš„é—®é¢˜ï¼š
ç”¨æˆ·æœç´¢ â†’ åç«¯ç¨‹åº â†’ æ‰‹å†™HTTPè¯·æ±‚ â†’ Elasticsearch
                 â†“
              å¤æ‚ç¹çï¼Œå®¹æ˜“å‡ºé”™

Javaå®¢æˆ·ç«¯çš„ä¼˜åŠ¿ï¼š
ç”¨æˆ·æœç´¢ â†’ åç«¯ç¨‹åº â†’ Javaå®¢æˆ·ç«¯ â†’ Elasticsearch
                 â†“
              ç®€å•æ˜“ç”¨ï¼Œç±»å‹å®‰å…¨
```

### 1.2 å®¢æˆ·ç«¯é€‰æ‹©æŒ‡å—


**ğŸ”¸ ä¸‰ç§ä¸»è¦é€‰æ‹©**

| å®¢æˆ·ç«¯ç±»å‹ | **é€‚ç”¨åœºæ™¯** | **å­¦ä¹ éš¾åº¦** | **åŠŸèƒ½ç‰¹ç‚¹** |
|-----------|-------------|-------------|-------------|
| `Rest Client` | `åº•å±‚æ§åˆ¶ï¼Œè‡ªå®šä¹‰éœ€æ±‚` | `â­â­â­` | `çµæ´»ä½†ç¹ç` |
| `High Level Client` | `å¹³è¡¡ä½¿ç”¨ï¼Œæ¨èé€‰æ‹©` | `â­â­` | `æ˜“ç”¨ä¸”åŠŸèƒ½å…¨` |
| `Spring Data ES` | `Springé¡¹ç›®ï¼Œå¿«é€Ÿå¼€å‘` | `â­` | `å¼€ç®±å³ç”¨` |

**ğŸ’¡ é€‰æ‹©å»ºè®®**
```
æ–°æ‰‹å…¥é—¨ï¼šSpring Data Elasticsearch
â†’ å­¦ä¼šåŸºæœ¬æ“ä½œåå†æ·±å…¥å…¶ä»–å®¢æˆ·ç«¯

ä¼ä¸šé¡¹ç›®ï¼šHigh Level Rest Client  
â†’ åŠŸèƒ½å®Œæ•´ï¼Œæ€§èƒ½å¯æ§

ç‰¹æ®Šéœ€æ±‚ï¼šLow Level Rest Client
â†’ éœ€è¦å®Œå…¨è‡ªå®šä¹‰HTTPè¯·æ±‚æ—¶ä½¿ç”¨
```

### 1.3 ç¯å¢ƒå‡†å¤‡


**ğŸ“¦ ä¾èµ–ç®¡ç†**
```xml
<!-- Mavenä¾èµ–ç¤ºä¾‹ -->
<dependencies>
    <!-- High Level Rest Client -->
    <dependency>
        <groupId>org.elasticsearch.client</groupId>
        <artifactId>elasticsearch-rest-high-level-client</artifactId>
        <version>7.17.0</version>
    </dependency>
    
    <!-- Spring Data Elasticsearch -->
    <dependency>
        <groupId>org.springframework.data</groupId>
        <artifactId>spring-data-elasticsearch</artifactId>
        <version>4.4.0</version>
    </dependency>
</dependencies>
```

---

## 2. ğŸ”§ Rest ClientåŸºç¡€ä½¿ç”¨


### 2.1 Low Level Rest Clientå…¥é—¨


**ğŸ”¸ åŸºç¡€è¿æ¥**

Low Level Clientå°±åƒ**ç›´æ¥å’ŒElasticsearch"è¯´HTTPè¯­è¨€"**ï¼Œä½ éœ€è¦è‡ªå·±ç»„ç»‡è¯·æ±‚å†…å®¹ã€‚

```java
// åˆ›å»ºè¿æ¥ - å°±åƒå»ºç«‹ç”µè¯çº¿è·¯
RestClient restClient = RestClient.builder(
    new HttpHost("localhost", 9200, "http")
).build();

// å‘é€è¯·æ±‚ - å°±åƒæ‹¨ç”µè¯
Request request = new Request("GET", "/");
Response response = restClient.performRequest(request);

// å¤„ç†å“åº”
String responseBody = EntityUtils.toString(response.getEntity());
System.out.println("ESé›†ç¾¤ä¿¡æ¯: " + responseBody);
```

**ğŸ”¸ åŸºæœ¬CRUDæ“ä½œ**

```java
public class LowLevelClientDemo {
    private RestClient client;
    
    // åˆ›å»ºæ–‡æ¡£ - ç›¸å½“äºå¾€æ•°æ®åº“æ’å…¥ä¸€æ¡è®°å½•
    public void createDocument() throws IOException {
        Request request = new Request("POST", "/products/_doc/1");
        
        // æ„å»ºJSONæ•°æ®
        String jsonString = "{"
            + "\"name\":\"iPhone 14\","
            + "\"price\":5999,"
            + "\"brand\":\"Apple\""
            + "}";
            
        request.setEntity(new NStringEntity(jsonString, ContentType.APPLICATION_JSON));
        
        Response response = client.performRequest(request);
        System.out.println("åˆ›å»ºç»“æœ: " + response.getStatusLine());
    }
    
    // æŸ¥è¯¢æ–‡æ¡£
    public void getDocument() throws IOException {
        Request request = new Request("GET", "/products/_doc/1");
        Response response = client.performRequest(request);
        
        String result = EntityUtils.toString(response.getEntity());
        System.out.println("æŸ¥è¯¢ç»“æœ: " + result);
    }
}
```

**ğŸ’­ Low Level Clientçš„ç‰¹ç‚¹**
- **ä¼˜ç‚¹**ï¼šå®Œå…¨æ§åˆ¶HTTPè¯·æ±‚ï¼Œçµæ´»æ€§æœ€é«˜
- **ç¼ºç‚¹**ï¼šéœ€è¦æ‰‹å†™JSONï¼Œå®¹æ˜“å‡ºé”™ï¼Œä»£ç ç¹ç
- **é€‚ç”¨**ï¼šéœ€è¦å®Œå…¨è‡ªå®šä¹‰è¯·æ±‚çš„ç‰¹æ®Šåœºæ™¯

---

## 3. âš¡ High Level Rest Clientè¯¦è§£


### 3.1 ä¸ºä»€ä¹ˆé€‰æ‹©High Level Client


High Level Clientå°±åƒæœ‰äº†ä¸€ä¸ª**è´´å¿ƒçš„ç¿»è¯‘å®˜**ï¼Œä½ åªéœ€è¦è¯´"æˆ‘è¦æŸ¥è¯¢è‹¹æœæ‰‹æœº"ï¼Œå®ƒä¼šè‡ªåŠ¨ç¿»è¯‘æˆElasticsearchèƒ½ç†è§£çš„è¯­è¨€ã€‚

**ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿**
```
ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶å°±èƒ½å‘ç°é”™è¯¯
APIä¸°å¯Œï¼šè¦†ç›–ESçš„æ‰€æœ‰åŠŸèƒ½  
æ˜“äºä½¿ç”¨ï¼šé¢å‘å¯¹è±¡ï¼Œç¬¦åˆJavaä¹ æƒ¯
æ€§èƒ½ä¼˜ç§€ï¼šå†…ç½®è¿æ¥æ± å’Œä¼˜åŒ–
```

### 3.2 è¿æ¥é…ç½®è¯¦è§£


**ğŸ”¸ åŸºç¡€è¿æ¥**
```java
@Configuration
public class ElasticsearchConfig {
    
    @Bean
    public RestHighLevelClient elasticsearchClient() {
        RestClientBuilder builder = RestClient.builder(
            new HttpHost("localhost", 9200, "http")
        );
        
        // è¿æ¥è¶…æ—¶é…ç½® - å°±åƒè®¾ç½®ç”µè¯æ‹¨å·ç­‰å¾…æ—¶é—´
        builder.setRequestConfigCallback(requestConfigBuilder ->
            requestConfigBuilder
                .setConnectTimeout(5000)    // è¿æ¥è¶…æ—¶5ç§’
                .setSocketTimeout(60000)    // è¯»å–è¶…æ—¶60ç§’
        );
        
        // è¿æ¥æ± é…ç½® - å°±åƒè®¾ç½®åŒæ—¶èƒ½æ‰“å‡ ä¸ªç”µè¯
        builder.setHttpClientConfigCallback(httpClientBuilder ->
            httpClientBuilder
                .setMaxConnTotal(100)       // æœ€å¤§è¿æ¥æ•°
                .setMaxConnPerRoute(10)     // æ¯ä¸ªè·¯ç”±æœ€å¤§è¿æ¥æ•°
        );
        
        return new RestHighLevelClient(builder);
    }
}
```

### 3.3 æ–‡æ¡£æ“ä½œå®æˆ˜


**ğŸ”¸ ç´¢å¼•æ–‡æ¡£ï¼ˆåˆ›å»º/æ›´æ–°ï¼‰**

```java
@Service
public class ProductService {
    
    @Autowired
    private RestHighLevelClient client;
    
    // æ·»åŠ å•†å“ - å°±åƒå¾€å•†å“åº“é‡Œæ”¾æ–°å•†å“
    public boolean addProduct(Product product) {
        try {
            IndexRequest request = new IndexRequest("products")
                .id(product.getId().toString())
                .source(objectToMap(product));
            
            IndexResponse response = client.index(request, RequestOptions.DEFAULT);
            
            // æ£€æŸ¥æ“ä½œç»“æœ
            return response.getResult() == DocWriteResponse.Result.CREATED ||
                   response.getResult() == DocWriteResponse.Result.UPDATED;
                   
        } catch (IOException e) {
            log.error("æ·»åŠ å•†å“å¤±è´¥", e);
            return false;
        }
    }
    
    // å¯¹è±¡è½¬Mapçš„å·¥å…·æ–¹æ³•
    private Map<String, Object> objectToMap(Product product) {
        Map<String, Object> map = new HashMap<>();
        map.put("name", product.getName());
        map.put("price", product.getPrice());
        map.put("brand", product.getBrand());
        map.put("category", product.getCategory());
        return map;
    }
}
```

**ğŸ”¸ æŸ¥è¯¢æ–‡æ¡£**

```java
// æ ¹æ®IDæŸ¥è¯¢å•†å“ - å°±åƒæ ¹æ®å•†å“ç¼–å·æ‰¾å•†å“
public Product getProductById(String id) {
    try {
        GetRequest request = new GetRequest("products", id);
        GetResponse response = client.get(request, RequestOptions.DEFAULT);
        
        if (response.isExists()) {
            Map<String, Object> source = response.getSource();
            return mapToProduct(source);
        }
        return null;
        
    } catch (IOException e) {
        log.error("æŸ¥è¯¢å•†å“å¤±è´¥", e);
        return null;
    }
}

// å¤æ‚æœç´¢æŸ¥è¯¢
public List<Product> searchProducts(String keyword, Double minPrice, Double maxPrice) {
    try {
        SearchRequest request = new SearchRequest("products");
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        
        // æ„å»ºæŸ¥è¯¢æ¡ä»¶ - å°±åƒè®¾ç½®ç­›é€‰æ¡ä»¶
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // å…³é”®è¯åŒ¹é…
        if (keyword != null && !keyword.isEmpty()) {
            boolQuery.must(QueryBuilders.multiMatchQuery(keyword, "name", "brand"));
        }
        
        // ä»·æ ¼èŒƒå›´
        if (minPrice != null || maxPrice != null) {
            RangeQueryBuilder priceRange = QueryBuilders.rangeQuery("price");
            if (minPrice != null) priceRange.gte(minPrice);
            if (maxPrice != null) priceRange.lte(maxPrice);
            boolQuery.filter(priceRange);
        }
        
        sourceBuilder.query(boolQuery);
        request.source(sourceBuilder);
        
        SearchResponse response = client.search(request, RequestOptions.DEFAULT);
        
        // è§£æç»“æœ
        List<Product> products = new ArrayList<>();
        for (SearchHit hit : response.getHits()) {
            products.add(mapToProduct(hit.getSourceAsMap()));
        }
        
        return products;
        
    } catch (IOException e) {
        log.error("æœç´¢å•†å“å¤±è´¥", e);
        return Collections.emptyList();
    }
}
```

### 3.4 æ‰¹é‡æ“ä½œä¼˜åŒ–


**ğŸ”¸ æ‰¹é‡æ’å…¥**

æ‰¹é‡æ“ä½œå°±åƒ**æ‰¹å‘è´­ç‰©**ï¼Œä¸€æ¬¡å¤„ç†å¤šä¸ªå•†å“æ¯”ä¸€ä¸ªä¸€ä¸ªå¤„ç†è¦é«˜æ•ˆå¾—å¤šã€‚

```java
// æ‰¹é‡æ·»åŠ å•†å“
public boolean batchAddProducts(List<Product> products) {
    if (products == null || products.isEmpty()) {
        return true;
    }
    
    try {
        BulkRequest bulkRequest = new BulkRequest();
        
        for (Product product : products) {
            IndexRequest indexRequest = new IndexRequest("products")
                .id(product.getId().toString())
                .source(objectToMap(product));
            bulkRequest.add(indexRequest);
        }
        
        BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¤±è´¥çš„æ“ä½œ
        if (bulkResponse.hasFailures()) {
            log.warn("æ‰¹é‡æ“ä½œéƒ¨åˆ†å¤±è´¥: {}", bulkResponse.buildFailureMessage());
            return false;
        }
        
        log.info("æ‰¹é‡æ·»åŠ {}ä¸ªå•†å“æˆåŠŸ", products.size());
        return true;
        
    } catch (IOException e) {
        log.error("æ‰¹é‡æ·»åŠ å•†å“å¤±è´¥", e);
        return false;
    }
}
```

---

## 4. ğŸŒ¸ Spring Data Elasticsearché›†æˆ


### 4.1 Spring Data ESç®€ä»‹


Spring Data Elasticsearchå°±åƒç»™Elasticsearchç©¿ä¸Šäº†**Springçš„å¤–è¡£**ï¼Œè®©å®ƒçœ‹èµ·æ¥å’Œå…¶ä»–Spring Dataæ¨¡å—ä¸€æ ·äº²åˆ‡ã€‚

**ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿**
```
é›¶é…ç½®ï¼šå¼€ç®±å³ç”¨
Repositoryæ¨¡å¼ï¼šç±»ä¼¼JPAï¼Œå­¦ä¹ æˆæœ¬ä½
è‡ªåŠ¨æ˜ å°„ï¼šå¯¹è±¡å’ŒJSONè‡ªåŠ¨è½¬æ¢
Springé›†æˆï¼šå®Œç¾èå…¥Springç”Ÿæ€
```

### 4.2 å®ä½“æ˜ å°„é…ç½®


**ğŸ”¸ å•†å“å®ä½“å®šä¹‰**

```java
@Document(indexName = "products")  // æŒ‡å®šç´¢å¼•åç§°
@Setting(replicas = 0, shards = 1)  // ç´¢å¼•è®¾ç½®
public class Product {
    
    @Id  // ä¸»é”®æ ‡è¯†
    private String id;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word")  // æ–‡æœ¬å­—æ®µï¼Œä½¿ç”¨ä¸­æ–‡åˆ†è¯
    private String name;
    
    @Field(type = FieldType.Keyword)  // å…³é”®è¯å­—æ®µï¼Œä¸åˆ†è¯
    private String brand;
    
    @Field(type = FieldType.Double)  // æ•°å€¼å­—æ®µ
    private Double price;
    
    @Field(type = FieldType.Keyword)
    private String category;
    
    @Field(type = FieldType.Date, format = DateFormat.date_time)  // æ—¥æœŸå­—æ®µ
    private LocalDateTime createTime;
    
    // æ„é€ å‡½æ•°ã€getterã€setterçœç•¥...
}
```

**ğŸ’¡ å­—æ®µç±»å‹è¯´æ˜**
```
Textï¼šå¯åˆ†è¯çš„æ–‡æœ¬ï¼Œç”¨äºå…¨æ–‡æœç´¢
Keywordï¼šä¸åˆ†è¯çš„æ–‡æœ¬ï¼Œç”¨äºç²¾ç¡®åŒ¹é…ã€æ’åºã€èšåˆ
Double/Longï¼šæ•°å€¼ç±»å‹
Dateï¼šæ—¥æœŸç±»å‹
Booleanï¼šå¸ƒå°”ç±»å‹
Objectï¼šåµŒå¥—å¯¹è±¡
```

### 4.3 Repositoryæ¨¡å¼


**ğŸ”¸ åŸºç¡€Repository**

```java
// ç»§æ‰¿ElasticsearchRepositoryï¼Œè·å¾—åŸºæœ¬CRUDèƒ½åŠ›
public interface ProductRepository extends ElasticsearchRepository<Product, String> {
    
    // æ ¹æ®å“ç‰ŒæŸ¥æ‰¾ - æ–¹æ³•åè‡ªåŠ¨ç”ŸæˆæŸ¥è¯¢
    List<Product> findByBrand(String brand);
    
    // æ ¹æ®ä»·æ ¼èŒƒå›´æŸ¥æ‰¾
    List<Product> findByPriceBetween(Double minPrice, Double maxPrice);
    
    // æ ¹æ®åç§°åŒ…å«å…³é”®è¯æŸ¥æ‰¾
    List<Product> findByNameContaining(String keyword);
    
    // å¤åˆæŸ¥è¯¢ï¼šå“ç‰Œå’Œä»·æ ¼èŒƒå›´
    List<Product> findByBrandAndPriceLessThan(String brand, Double maxPrice);
    
    // è‡ªå®šä¹‰æŸ¥è¯¢
    @Query("{\"bool\":{\"must\":[{\"match\":{\"name\":\"?0\"}}]}}")
    List<Product> findByCustomQuery(String name);
}
```

**ğŸ”¸ Serviceå±‚ä½¿ç”¨**

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    // ä¿å­˜å•†å“ - å°±åƒå¾€ä»“åº“å­˜å•†å“
    public Product saveProduct(Product product) {
        product.setCreateTime(LocalDateTime.now());
        return productRepository.save(product);
    }
    
    // æ‰¹é‡ä¿å­˜
    public List<Product> saveProducts(List<Product> products) {
        products.forEach(p -> p.setCreateTime(LocalDateTime.now()));
        return (List<Product>) productRepository.saveAll(products);
    }
    
    // æ ¹æ®å“ç‰Œæœç´¢
    public List<Product> searchByBrand(String brand) {
        return productRepository.findByBrand(brand);
    }
    
    // ä»·æ ¼åŒºé—´æœç´¢
    public List<Product> searchByPriceRange(Double minPrice, Double maxPrice) {
        return productRepository.findByPriceBetween(minPrice, maxPrice);
    }
}
```

### 4.4 Templateæ¨¡å¼é«˜çº§ä½¿ç”¨


**ğŸ”¸ ElasticsearchRestTemplate**

Templateæ¨¡å¼æä¾›äº†æ›´çµæ´»çš„æŸ¥è¯¢èƒ½åŠ›ï¼Œå°±åƒæœ‰äº†ä¸€ä¸ª**é«˜çº§æœç´¢å·¥å…·**ã€‚

```java
@Service
public class AdvancedProductService {
    
    @Autowired
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    // å¤æ‚æœç´¢ï¼šå¤šæ¡ä»¶ã€é«˜äº®ã€åˆ†é¡µ
    public PageResult<Product> complexSearch(String keyword, String brand, 
            Double minPrice, Double maxPrice, int page, int size) {
        
        // æ„å»ºæŸ¥è¯¢æ¡ä»¶
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // å…³é”®è¯æœç´¢
        if (StringUtils.hasText(keyword)) {
            boolQuery.must(QueryBuilders.multiMatchQuery(keyword, "name", "brand"));
        }
        
        // å“ç‰Œè¿‡æ»¤
        if (StringUtils.hasText(brand)) {
            boolQuery.filter(QueryBuilders.termQuery("brand", brand));
        }
        
        // ä»·æ ¼èŒƒå›´
        if (minPrice != null || maxPrice != null) {
            RangeQueryBuilder priceRange = QueryBuilders.rangeQuery("price");
            if (minPrice != null) priceRange.gte(minPrice);
            if (maxPrice != null) priceRange.lte(maxPrice);
            boolQuery.filter(priceRange);
        }
        
        // æ„å»ºæŸ¥è¯¢
        NativeSearchQuery searchQuery = queryBuilder
            .withQuery(boolQuery)
            .withPageable(PageRequest.of(page, size))
            .withHighlightFields(new HighlightBuilder.Field("name"))
            .build();
        
        // æ‰§è¡Œæœç´¢
        SearchHits<Product> searchHits = elasticsearchTemplate.search(searchQuery, Product.class);
        
        // å¤„ç†ç»“æœ
        List<Product> products = searchHits.stream()
            .map(SearchHit::getContent)
            .collect(Collectors.toList());
        
        return new PageResult<>(products, searchHits.getTotalHits(), page, size);
    }
    
    // èšåˆæŸ¥è¯¢ï¼šæŒ‰å“ç‰Œç»Ÿè®¡å•†å“æ•°é‡
    public Map<String, Long> getBrandStatistics() {
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();
        
        // æ·»åŠ èšåˆ
        queryBuilder.addAggregation(
            AggregationBuilders.terms("brand_count").field("brand")
        );
        
        NativeSearchQuery searchQuery = queryBuilder.build();
        SearchHits<Product> searchHits = elasticsearchTemplate.search(searchQuery, Product.class);
        
        // å¤„ç†èšåˆç»“æœ
        Aggregations aggregations = searchHits.getAggregations();
        Terms brandTerms = aggregations.get("brand_count");
        
        Map<String, Long> result = new HashMap<>();
        for (Terms.Bucket bucket : brandTerms.getBuckets()) {
            result.put(bucket.getKeyAsString(), bucket.getDocCount());
        }
        
        return result;
    }
}
```

---

## 5. ğŸš€ é«˜çº§ç‰¹æ€§ä¸ä¼˜åŒ–


### 5.1 è¿æ¥æ± é…ç½®ä¼˜åŒ–


**ğŸ”¸ ç”Ÿäº§ç¯å¢ƒè¿æ¥æ± é…ç½®**

```java
@Configuration
public class ElasticsearchConfig {
    
    @Bean
    public RestHighLevelClient elasticsearchClient() {
        RestClientBuilder builder = RestClient.builder(
            new HttpHost("es-node1", 9200, "http"),
            new HttpHost("es-node2", 9200, "http"),
            new HttpHost("es-node3", 9200, "http")
        );
        
        // è¯·æ±‚é…ç½®ä¼˜åŒ–
        builder.setRequestConfigCallback(requestConfigBuilder ->
            requestConfigBuilder
                .setConnectTimeout(5000)      // è¿æ¥è¶…æ—¶
                .setSocketTimeout(60000)      // è¯»å–è¶…æ—¶
                .setConnectionRequestTimeout(1000)  // ä»è¿æ¥æ± è·å–è¿æ¥è¶…æ—¶
        );
        
        // HTTPå®¢æˆ·ç«¯é…ç½®ä¼˜åŒ–
        builder.setHttpClientConfigCallback(httpClientBuilder ->
            httpClientBuilder
                .setMaxConnTotal(200)         // æ€»è¿æ¥æ± å¤§å°
                .setMaxConnPerRoute(50)       // æ¯ä¸ªè·¯ç”±æœ€å¤§è¿æ¥æ•°
                .setKeepAliveStrategy((response, context) -> 30 * 1000)  // ä¿æŒè¿æ¥30ç§’
        );
        
        return new RestHighLevelClient(builder);
    }
}
```

### 5.2 å¼‚æ­¥æ“ä½œ


**ğŸ”¸ å¼‚æ­¥æŸ¥è¯¢æå‡æ€§èƒ½**

å¼‚æ­¥æ“ä½œå°±åƒ**åŒæ—¶åšå¤šä»¶äº‹æƒ…**ï¼Œä¸ç”¨ç­‰ä¸€ä¸ªä»»åŠ¡å®Œæˆå†åšä¸‹ä¸€ä¸ªã€‚

```java
@Service
public class AsyncProductService {
    
    @Autowired
    private RestHighLevelClient client;
    
    // å¼‚æ­¥æœç´¢
    public CompletableFuture<List<Product>> asyncSearch(String keyword) {
        CompletableFuture<List<Product>> future = new CompletableFuture<>();
        
        SearchRequest request = new SearchRequest("products");
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        sourceBuilder.query(QueryBuilders.matchQuery("name", keyword));
        request.source(sourceBuilder);
        
        // å¼‚æ­¥æ‰§è¡Œ
        client.searchAsync(request, RequestOptions.DEFAULT, new ActionListener<SearchResponse>() {
            @Override
            public void onResponse(SearchResponse response) {
                List<Product> products = parseSearchResponse(response);
                future.complete(products);
            }
            
            @Override
            public void onFailure(Exception e) {
                future.completeExceptionally(e);
            }
        });
        
        return future;
    }
    
    // å¤šä¸ªå¼‚æ­¥æŸ¥è¯¢å¹¶è¡Œæ‰§è¡Œ
    @Async
    public CompletableFuture<SearchResult> parallelSearch(String keyword) {
        CompletableFuture<List<Product>> productsFuture = asyncSearch(keyword);
        CompletableFuture<Map<String, Long>> statsFuture = asyncGetStatistics();
        
        return CompletableFuture.allOf(productsFuture, statsFuture)
            .thenApply(v -> new SearchResult(
                productsFuture.join(),
                statsFuture.join()
            ));
    }
}
```

### 5.3 å¼‚å¸¸å¤„ç†ä¸é‡è¯•


**ğŸ”¸ å¥å£®çš„å¼‚å¸¸å¤„ç†**

```java
@Service
public class RobustProductService {
    
    @Autowired
    private RestHighLevelClient client;
    
    @Retryable(value = {IOException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public Product getProductWithRetry(String id) {
        try {
            GetRequest request = new GetRequest("products", id);
            GetResponse response = client.get(request, RequestOptions.DEFAULT);
            
            if (response.isExists()) {
                return mapToProduct(response.getSource());
            }
            return null;
            
        } catch (ElasticsearchException e) {
            // ESç‰¹å®šå¼‚å¸¸å¤„ç†
            if (e.status() == RestStatus.NOT_FOUND) {
                log.warn("å•†å“ä¸å­˜åœ¨: {}", id);
                return null;
            }
            throw new ServiceException("æŸ¥è¯¢å•†å“å¤±è´¥", e);
            
        } catch (IOException e) {
            log.error("ç½‘ç»œå¼‚å¸¸ï¼Œå‡†å¤‡é‡è¯•: {}", e.getMessage());
            throw e;  // è§¦å‘é‡è¯•
        }
    }
    
    @Recover
    public Product recover(IOException e, String id) {
        log.error("é‡è¯•å¤±è´¥ï¼Œè¿”å›é»˜è®¤å€¼: {}", e.getMessage());
        return getDefaultProduct(id);
    }
}
```

### 5.4 å¥åº·æ£€æŸ¥ä¸ç›‘æ§


**ğŸ”¸ é›†ç¾¤å¥åº·ç›‘æ§**

```java
@Component
public class ElasticsearchHealthChecker {
    
    @Autowired
    private RestHighLevelClient client;
    
    @Scheduled(fixedRate = 30000)  // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void checkHealth() {
        try {
            ClusterHealthRequest request = new ClusterHealthRequest();
            request.timeout(TimeValue.timeValueSeconds(10));
            
            ClusterHealthResponse response = client.cluster().health(request, RequestOptions.DEFAULT);
            
            ClusterHealthStatus status = response.getStatus();
            log.info("ESé›†ç¾¤çŠ¶æ€: {}, èŠ‚ç‚¹æ•°: {}, æ•°æ®èŠ‚ç‚¹æ•°: {}", 
                status, response.getNumberOfNodes(), response.getNumberOfDataNodes());
            
            if (status == ClusterHealthStatus.RED) {
                log.error("ESé›†ç¾¤çŠ¶æ€å¼‚å¸¸ï¼");
                // å‘é€å‘Šè­¦é€šçŸ¥
                sendAlert("Elasticsearché›†ç¾¤çŠ¶æ€ä¸ºRED");
            }
            
        } catch (Exception e) {
            log.error("ESå¥åº·æ£€æŸ¥å¤±è´¥", e);
            sendAlert("Elasticsearchå¥åº·æ£€æŸ¥å¤±è´¥: " + e.getMessage());
        }
    }
    
    private void sendAlert(String message) {
        // å®ç°å‘Šè­¦é€»è¾‘ï¼šé‚®ä»¶ã€é’‰é’‰ã€çŸ­ä¿¡ç­‰
    }
}
```

---

## 6. ğŸ’¼ å®æˆ˜æœ€ä½³å®è·µ


### 6.1 æ˜ å°„ä¸€è‡´æ€§ç®¡ç†


**ğŸ”¸ ç‰ˆæœ¬åŒ–æ˜ å°„ç®¡ç†**

```java
@Component
public class IndexMappingManager {
    
    @Autowired
    private RestHighLevelClient client;
    
    // æ£€æŸ¥å¹¶æ›´æ–°ç´¢å¼•æ˜ å°„
    @PostConstruct
    public void checkAndUpdateMapping() {
        try {
            String indexName = "products";
            
            // æ£€æŸ¥ç´¢å¼•æ˜¯å¦å­˜åœ¨
            GetIndexRequest getIndexRequest = new GetIndexRequest(indexName);
            boolean exists = client.indices().exists(getIndexRequest, RequestOptions.DEFAULT);
            
            if (!exists) {
                createIndexWithMapping(indexName);
            } else {
                updateMappingIfNeeded(indexName);
            }
            
        } catch (IOException e) {
            log.error("æ˜ å°„ç®¡ç†å¤±è´¥", e);
        }
    }
    
    private void createIndexWithMapping(String indexName) throws IOException {
        CreateIndexRequest request = new CreateIndexRequest(indexName);
        
        // è®¾ç½®æ˜ å°„
        String mapping = """
            {
              "properties": {
                "name": {"type": "text", "analyzer": "ik_max_word"},
                "brand": {"type": "keyword"},
                "price": {"type": "double"},
                "category": {"type": "keyword"},
                "createTime": {"type": "date"}
              }
            }
            """;
        
        request.mapping(mapping, XContentType.JSON);
        
        CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT);
        log.info("åˆ›å»ºç´¢å¼•æˆåŠŸ: {}", response.isAcknowledged());
    }
}
```

### 6.2 æµ‹è¯•æœ€ä½³å®è·µ


**ğŸ”¸ é›†æˆæµ‹è¯•é…ç½®**

```java
@SpringBootTest
@TestPropertySource(properties = {
    "spring.elasticsearch.rest.uris=http://localhost:9200",
    "logging.level.org.elasticsearch=DEBUG"
})
class ProductServiceTest {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private ProductRepository productRepository;
    
    @BeforeEach
    void setUp() {
        // æ¸…ç†æµ‹è¯•æ•°æ®
        productRepository.deleteAll();
    }
    
    @Test
    void testSaveAndSearch() {
        // å‡†å¤‡æµ‹è¯•æ•°æ®
        Product product = new Product();
        product.setId("test-001");
        product.setName("æµ‹è¯•iPhone");
        product.setBrand("Apple");
        product.setPrice(5999.0);
        
        // ä¿å­˜å•†å“
        Product saved = productService.saveProduct(product);
        assertThat(saved.getId()).isEqualTo("test-001");
        
        // ç­‰å¾…ç´¢å¼•åˆ·æ–°
        sleep(1000);
        
        // æœç´¢éªŒè¯
        List<Product> results = productService.searchByBrand("Apple");
        assertThat(results).hasSize(1);
        assertThat(results.get(0).getName()).isEqualTo("æµ‹è¯•iPhone");
    }
    
    @Test
    void testBatchOperation() {
        // æ‰¹é‡æ’å…¥æµ‹è¯•
        List<Product> products = createTestProducts(100);
        List<Product> saved = productService.saveProducts(products);
        
        assertThat(saved).hasSize(100);
        
        // éªŒè¯æœç´¢
        sleep(1000);
        List<Product> allProducts = (List<Product>) productRepository.findAll();
        assertThat(allProducts).hasSize(100);
    }
}
```

### 6.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


**ğŸ”¸ æ‰¹é‡æ“ä½œä¼˜åŒ–**

```java
@Service
public class OptimizedProductService {
    
    private static final int BATCH_SIZE = 1000;
    
    // å¤§æ‰¹é‡æ•°æ®æ’å…¥ä¼˜åŒ–
    public void bulkInsertOptimized(List<Product> products) {
        if (products.isEmpty()) return;
        
        // åˆ†æ‰¹å¤„ç†
        List<List<Product>> batches = partition(products, BATCH_SIZE);
        
        for (List<Product> batch : batches) {
            try {
                BulkRequest bulkRequest = new BulkRequest();
                
                // è®¾ç½®æ‰¹é‡è¯·æ±‚å‚æ•°
                bulkRequest.timeout(TimeValue.timeValueMinutes(2));
                bulkRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);
                
                for (Product product : batch) {
                    IndexRequest request = new IndexRequest("products")
                        .id(product.getId())
                        .source(objectToMap(product));
                    bulkRequest.add(request);
                }
                
                BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT);
                
                if (response.hasFailures()) {
                    handleBulkFailures(response);
                }
                
                log.info("æ‰¹é‡æ’å…¥{}æ¡è®°å½•å®Œæˆ", batch.size());
                
            } catch (Exception e) {
                log.error("æ‰¹é‡æ’å…¥å¤±è´¥", e);
                // å¯ä»¥è€ƒè™‘å•æ¡é‡è¯•æˆ–è€…è®°å½•å¤±è´¥æ—¥å¿—
            }
        }
    }
    
    // åˆ†é¡µå·¥å…·æ–¹æ³•
    private <T> List<List<T>> partition(List<T> list, int size) {
        return IntStream.range(0, (list.size() + size - 1) / size)
            .mapToObj(i -> list.subList(i * size, Math.min((i + 1) * size, list.size())))
            .collect(Collectors.toList());
    }
}
```

---

## 7. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 7.1 å¿…é¡»æŒæ¡çš„åŸºæœ¬æ¦‚å¿µ


```
ğŸ”¸ å®¢æˆ·ç«¯é€‰æ‹©ï¼šæ ¹æ®é¡¹ç›®éœ€æ±‚é€‰æ‹©åˆé€‚çš„å®¢æˆ·ç«¯ç±»å‹
ğŸ”¸ è¿æ¥ç®¡ç†ï¼šæ­£ç¡®é…ç½®è¿æ¥æ± å’Œè¶…æ—¶å‚æ•°
ğŸ”¸ æ–‡æ¡£æ“ä½œï¼šæŒæ¡CRUDçš„åŸºæœ¬æ“ä½œæ–¹æ³•
ğŸ”¸ æ‰¹é‡å¤„ç†ï¼šä½¿ç”¨æ‰¹é‡æ“ä½œæå‡æ€§èƒ½
ğŸ”¸ å¼‚å¸¸å¤„ç†ï¼šå®ç°å¥å£®çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
ğŸ”¸ æ˜ å°„ç®¡ç†ï¼šä¿æŒJavaå¯¹è±¡ä¸ESæ˜ å°„çš„ä¸€è‡´æ€§
```

### 7.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ å®¢æˆ·ç«¯é€‰æ‹©ç­–ç•¥**
```
å­¦ä¹ è·¯å¾„ï¼š
Spring Data ES â†’ High Level Client â†’ Low Level Client

é¡¹ç›®é€‰æ‹©ï¼š
ç®€å•åº”ç”¨ï¼šSpring Data ESï¼ˆå¼€ç®±å³ç”¨ï¼‰
ä¼ä¸šé¡¹ç›®ï¼šHigh Level Clientï¼ˆå¹³è¡¡æ€§èƒ½å’Œæ˜“ç”¨æ€§ï¼‰
ç‰¹æ®Šéœ€æ±‚ï¼šLow Level Clientï¼ˆå®Œå…¨æ§åˆ¶ï¼‰
```

**ğŸ”¹ æ€§èƒ½ä¼˜åŒ–è¦ç‚¹**
```
è¿æ¥æ± ä¼˜åŒ–ï¼šåˆç†è®¾ç½®è¿æ¥æ•°å’Œè¶…æ—¶æ—¶é—´
æ‰¹é‡æ“ä½œï¼šå‡å°‘ç½‘ç»œå¾€è¿”æ¬¡æ•°
å¼‚æ­¥å¤„ç†ï¼šæå‡å¹¶å‘å¤„ç†èƒ½åŠ›
ç´¢å¼•ä¼˜åŒ–ï¼šæ­£ç¡®è®¾ç½®æ˜ å°„å’Œåˆ†æå™¨
```

**ğŸ”¹ ç”Ÿäº§ç¯å¢ƒæ³¨æ„äº‹é¡¹**
```
å¥åº·ç›‘æ§ï¼šå®æ—¶ç›‘æ§é›†ç¾¤çŠ¶æ€
å¼‚å¸¸å¤„ç†ï¼šå®Œå–„çš„é‡è¯•å’Œé™çº§æœºåˆ¶
ç‰ˆæœ¬å…¼å®¹ï¼šæ³¨æ„å®¢æˆ·ç«¯ä¸ESç‰ˆæœ¬çš„å…¼å®¹æ€§
æµ‹è¯•è¦†ç›–ï¼šå®Œæ•´çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
```

### 7.3 å®é™…åº”ç”¨ä»·å€¼


**ğŸ¯ é€‚ç”¨åœºæ™¯**
- **ç”µå•†æœç´¢**ï¼šå•†å“æœç´¢ã€ç­›é€‰ã€æ¨è
- **æ—¥å¿—åˆ†æ**ï¼šåº”ç”¨æ—¥å¿—å­˜å‚¨å’Œåˆ†æ
- **å†…å®¹æ£€ç´¢**ï¼šæ–‡æ¡£ã€æ–°é—»ã€çŸ¥è¯†åº“æœç´¢
- **å®æ—¶åˆ†æ**ï¼šç”¨æˆ·è¡Œä¸ºåˆ†æã€ä¸šåŠ¡ç›‘æ§

**ğŸ”§ å¼€å‘å®è·µ**
- **ä»£ç è§„èŒƒ**ï¼šç»Ÿä¸€çš„å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•
- **æ€§èƒ½ç›‘æ§**ï¼šå…³é”®æŒ‡æ ‡çš„ç›‘æ§å’Œå‘Šè­¦
- **ç‰ˆæœ¬ç®¡ç†**ï¼šæ˜ å°„å˜æ›´çš„ç‰ˆæœ¬åŒ–ç®¡ç†
- **æµ‹è¯•ç­–ç•¥**ï¼šå®Œæ•´çš„æµ‹è¯•è¦†ç›–å’ŒæŒç»­é›†æˆ

**æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
- å®¢æˆ·ç«¯é€‰æ‹©çœ‹éœ€æ±‚ï¼ŒSpringç®€å•ä¼ä¸šå…¨
- è¿æ¥æ± é…ç½®è¦åˆç†ï¼Œæ‰¹é‡å¼‚æ­¥ææ€§èƒ½
- å¼‚å¸¸é‡è¯•è¦å¥å£®ï¼Œç›‘æ§å‘Šè­¦ä¿ç¨³å®š
- æ˜ å°„ä¸€è‡´æµ‹è¯•å…¨ï¼Œç”Ÿäº§ç¯å¢ƒå¿ƒä¸æ…Œ