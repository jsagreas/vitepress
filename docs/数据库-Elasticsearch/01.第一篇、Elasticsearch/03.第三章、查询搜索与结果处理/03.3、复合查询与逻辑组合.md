---
title: 3、复合查询与逻辑组合
---
## 📚 目录

1. [复合查询基础概念](#1-复合查询基础概念)
2. [Bool查询详解](#2-Bool查询详解)
3. [Must子句-必须匹配](#3-Must子句-必须匹配)
4. [Should子句-应该匹配](#4-Should子句-应该匹配)
5. [Must_not子句-必须不匹配](#5-Must_not子句-必须不匹配)
6. [Filter子句-过滤条件](#6-Filter子句-过滤条件)
7. [高级复合查询](#7-高级复合查询)
8. [查询优化与最佳实践](#8-查询优化与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 复合查询基础概念


### 1.1 什么是复合查询


**🔸 简单理解**
复合查询就像是**多个条件的组合**，类似我们平时说话时的逻辑：
- "我要找**既便宜又好用**的手机"（两个条件都要满足）
- "我要找**苹果或者华为**的手机"（满足其中一个就行）
- "我要找手机，**但不要二手的**"（排除某些条件）

```
日常购物逻辑                    Elasticsearch复合查询
─────────────────              ──────────────────────
"既要A又要B"          →         Bool查询 + Must子句
"要么A要么B"          →         Bool查询 + Should子句  
"要A但不要C"          →         Bool查询 + Must_not子句
"只看价格区间"        →         Bool查询 + Filter子句
```

### 1.2 为什么需要复合查询


**🤔 实际场景需求**
```
电商搜索场景：
用户搜索："便宜的苹果手机，不要二手的，最好是红色"

拆解需求：
✓ 必须是：苹果品牌 + 手机类别
✓ 价格：低于某个值
✓ 排除：二手商品
✓ 优先：红色款式

单一查询无法满足 → 需要复合查询组合
```

### 1.3 复合查询的核心组件


**🏗️ 查询构建模块**
```
Bool查询 (布尔查询)
├── Must (必须)     ← "一定要满足的条件"
├── Should (应该)   ← "最好满足的条件" 
├── Must_not (不要) ← "绝对不能满足的条件"
└── Filter (过滤)   ← "用来筛选的条件"

其他复合查询：
├── Dis_max        ← "多个条件中取最佳匹配"
├── Constant_score ← "固定评分查询"
├── Boosting       ← "负向影响查询"
└── Function_score ← "自定义评分查询"
```

---

## 2. 🔗 Bool查询详解


### 2.1 Bool查询的基本概念


**🎯 核心理解**
Bool查询是Elasticsearch中**最重要的复合查询**，它允许你组合多个查询条件，就像编程中的 `if` 语句一样。

```
编程逻辑对比：
if (条件A && 条件B && !条件C) {
    // 返回结果
}

Bool查询逻辑：
{
  "bool": {
    "must": [条件A, 条件B],      // && (必须都满足)
    "must_not": [条件C]          // ! (必须不满足)
  }
}
```

### 2.2 Bool查询的基本结构


**📋 标准语法格式**
```json
{
  "query": {
    "bool": {
      "must": [
        { /* 查询条件1 */ },
        { /* 查询条件2 */ }
      ],
      "should": [
        { /* 可选条件1 */ },
        { /* 可选条件2 */ }
      ],
      "must_not": [
        { /* 排除条件1 */ }
      ],
      "filter": [
        { /* 过滤条件1 */ }
      ],
      "minimum_should_match": 1
    }
  }
}
```

### 2.3 Bool查询的执行逻辑


**⚡ 查询执行流程**
```
Bool查询执行顺序：
1. Filter子句先执行  → 快速过滤数据（不计算分数）
2. Must_not子句执行  → 排除不符合的文档
3. Must子句执行      → 必须匹配的条件（计算分数）
4. Should子句执行    → 可选匹配的条件（影响分数）
5. 最终评分计算     → 综合各子句分数

性能优化要点：
- Filter子句不计算分数，执行最快
- 尽量把精确匹配放在Filter中
- Must_not也不计算分数，执行较快
```

---

## 3. ✅ Must子句-必须匹配


### 3.1 Must子句的作用


**🎯 核心概念**
Must子句就是**硬性要求**，所有条件都必须满足，文档才会被返回。就像招聘要求中的"必需条件"。

```
招聘比喻：
职位要求：
✓ 必须：本科学历 + 3年经验 + Java技能
✓ 加分：有项目经验 + 英语好

对应Bool查询：
Must: [学历匹配, 经验匹配, 技能匹配]     ← 缺一不可
Should: [项目经验, 英语能力]             ← 有更好
```

### 3.2 Must子句实战示例


**📝 基础示例：商品搜索**
```json
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "category": "手机"
          }
        },
        {
          "match": {
            "brand": "苹果"
          }
        },
        {
          "range": {
            "price": {
              "gte": 3000,
              "lte": 8000
            }
          }
        }
      ]
    }
  }
}
```

**解释说明：**
- `category: "手机"`：必须是手机类别
- `brand: "苹果"`：必须是苹果品牌  
- `price: 3000-8000`：价格必须在3000-8000区间
- **三个条件缺一不可**，全部满足才返回

### 3.3 Must子句的评分机制


**📊 分数计算规则**
```
Must子句评分特点：
- 每个Must条件都会产生相关性分数
- 最终分数 = 所有Must条件分数的累加
- 分数越高，文档排名越靠前

示例分析：
文档A: category匹配度0.8 + brand匹配度0.9 + price完全匹配1.0 = 2.7分
文档B: category匹配度0.6 + brand匹配度0.7 + price完全匹配1.0 = 2.3分
结果：文档A排在文档B前面
```

---

## 4. 🎲 Should子句-应该匹配


### 4.1 Should子句的作用机制


**🌟 灵活匹配概念**
Should子句是**可选条件**，满足越多，文档得分越高，排名越靠前。就像购物时的"优先选择"。

```
购物决策比喻：
我要买手机：
- 必须：价格合适 + 品牌可靠      (Must条件)
- 最好：有优惠 + 颜色喜欢 + 评价好  (Should条件)

即使没有优惠、颜色不喜欢，只要价格品牌合适，我还是会买
但如果有优惠、颜色好看、评价高，我更愿意选择这款
```

### 4.2 Should单独使用


**🔸 独立Should查询**
```json
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "title": "Elasticsearch"
          }
        },
        {
          "match": {
            "content": "搜索引擎"
          }
        },
        {
          "match": {
            "tags": "数据库"
          }
        }
      ],
      "minimum_should_match": 1
    }
  }
}
```

**解释说明：**
- 文档只要满足**其中任何一个条件**就会被返回
- `minimum_should_match: 1`：至少要匹配1个Should条件
- 匹配越多条件，分数越高，排名越靠前

### 4.3 Should与Must结合使用


**⚖️ 组合查询示例**
```json
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "category": "笔记本电脑"
          }
        }
      ],
      "should": [
        {
          "match": {
            "brand": "苹果"
          }
        },
        {
          "match": {
            "brand": "华为"
          }
        },
        {
          "range": {
            "discount": {
              "gte": 0.1
            }
          }
        }
      ]
    }
  }
}
```

**执行逻辑：**
1. **首先**：必须是笔记本电脑（Must条件）
2. **然后**：苹果或华为品牌能加分（Should条件）
3. **同时**：有折扣的商品能额外加分（Should条件）
4. **结果**：苹果笔记本有折扣的排名最靠前

### 4.4 最小匹配数量控制


**🎯 minimum_should_match参数**

| 设置值 | 含义 | 使用场景 |
|-------|------|----------|
| `1` | 至少匹配1个Should条件 | 确保至少有一定相关性 |
| `2` | 至少匹配2个Should条件 | 提高匹配质量 |
| `"50%"` | 至少匹配50%的Should条件 | 动态匹配比例 |
| `"2<75%"` | 条件≤2个时全匹配，>2个时匹配75% | 复杂匹配策略 |

---

## 5. 🚫 Must_not子句-必须不匹配


### 5.1 Must_not的排除逻辑


**❌ 排除机制理解**
Must_not就是**黑名单**，凡是匹配这些条件的文档都会被排除，绝对不会出现在结果中。

```
生活场景类比：
找房子的要求：
✓ 必须：地铁附近 + 价格合适          (Must)
✓ 最好：朝南 + 有电梯               (Should)  
✗ 绝不：地下室 + 顶楼 + 临街吵闹      (Must_not)

无论地下室多便宜，都不会考虑！
```

### 5.2 Must_not实际应用


**🔍 常见排除场景**
```json
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "category": "手机"
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "status": "下架"
          }
        },
        {
          "match": {
            "condition": "二手"
          }
        },
        {
          "range": {
            "price": {
              "lt": 100
            }
          }
        }
      ]
    }
  }
}
```

**业务含义：**
- 查找手机商品
- **排除**：已下架的商品
- **排除**：二手商品
- **排除**：价格低于100元的商品（可能是配件）

### 5.3 Must_not的性能特点


**⚡ 性能优势**
```
Must_not执行特点：
✓ 不参与相关性评分计算
✓ 执行速度较快
✓ 可以利用缓存优化
✓ 适合精确匹配的排除条件

使用建议：
- 把明确的排除条件放在Must_not中
- 避免在Must_not中使用复杂的文本匹配
- 优先使用精确值匹配（term查询）
```

---

## 6. 🔍 Filter子句-过滤条件


### 6.1 Filter的核心特点


**🎯 过滤器理解**
Filter就像**筛子**，只负责筛选数据，不影响相关性评分。它关注的是"符合不符合"，不关心"有多符合"。

```
筛选器比喻：
咖啡筛选过程：
1. 粗筛：去掉大颗粒杂质    ← Filter（快速过滤）
2. 细筛：按咖啡豆大小分级  ← Must（精确匹配+ 评分）
3. 手选：挑出优质豆子      ← Should（优化排序）

Filter只做粗筛，速度最快，不评判好坏
```

### 6.2 Filter vs Must的区别


**📊 对比分析表**

| 特性 | **Filter子句** | **Must子句** |
|------|--------------|-------------|
| **评分** | `不计算分数` | `计算相关性分数` |
| **速度** | `很快` | `相对较慢` |
| **缓存** | `可以缓存` | `不能缓存` |
| **用途** | `精确过滤` | `相关性匹配` |
| **适用场景** | `状态、时间、范围` | `文本搜索、模糊匹配` |

### 6.3 Filter实战应用


**🔧 典型过滤场景**
```json
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "Java开发"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "status": "published"
          }
        },
        {
          "range": {
            "publish_date": {
              "gte": "2023-01-01"
            }
          }
        },
        {
          "terms": {
            "category": ["技术", "编程", "教程"]
          }
        }
      ]
    }
  }
}
```

**执行逻辑分析：**
1. **Filter先执行**：快速过滤出状态为"published"、2023年后发布、属于指定分类的文档
2. **Must再执行**：在过滤结果中搜索标题包含"Java开发"的文档并计算相关性分数
3. **性能优化**：Filter结果可以缓存，大大提升查询速度

### 6.4 Filter的最佳实践


**💡 使用建议**
```
什么时候用Filter：
✓ 精确值匹配：状态、ID、分类
✓ 范围查询：时间范围、价格区间、数量范围  
✓ 存在性检查：某字段是否存在
✓ 地理位置过滤：距离、边界范围

什么时候用Must：
✓ 文本搜索：标题、内容、描述
✓ 模糊匹配：用户输入的搜索词
✓ 相关性重要：需要根据匹配程度排序
```

---

## 7. 🚀 高级复合查询


### 7.1 Dis_max查询-最佳匹配


**🎯 Dis_max的核心理念**
Dis_max查询关注的是"**最佳单项匹配**"，而不是累加所有匹配分数。就像选美比赛，只看最突出的那个优点。

```
选美比赛比喻：
传统Bool查询：总分 = 外貌分 + 才艺分 + 气质分
Dis_max查询：总分 = max(外貌分, 才艺分, 气质分)

实际应用：
搜索"Java程序员"时：
- 标题匹配度很高，内容匹配度一般 → 以标题分数为准
- 避免多个字段累加造成的分数虚高
```

**📝 Dis_max查询示例**
```json
{
  "query": {
    "dis_max": {
      "queries": [
        {
          "match": {
            "title": "Java开发"
          }
        },
        {
          "match": {
            "content": "Java开发"
          }
        },
        {
          "match": {
            "summary": "Java开发"
          }
        }
      ],
      "tie_breaker": 0.3
    }
  }
}
```

**参数说明：**
- `tie_breaker: 0.3`：其他字段的分数按30%计入总分
- 最终分数 = 最高分数 + 其他分数 × tie_breaker

### 7.2 Constant_score查询-固定评分


**⚖️ 固定评分的应用场景**
当你只关心"匹配不匹配"，不关心"匹配程度"时，可以使用固定评分。

```json
{
  "query": {
    "constant_score": {
      "filter": {
        "bool": {
          "must": [
            {
              "term": {
                "category": "电子产品"
              }
            },
            {
              "range": {
                "price": {
                  "gte": 100,
                  "lte": 1000
                }
              }
            }
          ]
        }
      },
      "boost": 2.0
    }
  }
}
```

**适用场景：**
- 精确匹配查询
- 不需要相关性排序
- 提升查询性能

### 7.3 Boosting查询-负向影响


**📉 负向权重调整**
Boosting查询可以降低某些匹配文档的分数，而不是完全排除它们。

```json
{
  "query": {
    "boosting": {
      "positive": {
        "match": {
          "content": "Java"
        }
      },
      "negative": {
        "match": {
          "content": "过时的"
        }
      },
      "negative_boost": 0.3
    }
  }
}
```

**业务含义：**
- 查找包含"Java"的文档
- 如果同时包含"过时的"，分数降低到30%

### 7.4 Function_score查询-自定义评分


**🎛️ 自定义评分函数**
Function_score允许你根据业务逻辑自定义文档的相关性分数。

```json
{
  "query": {
    "function_score": {
      "query": {
        "match": {
          "title": "手机"
        }
      },
      "functions": [
        {
          "filter": {
            "range": {
              "sales": {
                "gte": 1000
              }
            }
          },
          "weight": 2
        },
        {
          "field_value_factor": {
            "field": "rating",
            "factor": 1.5,
            "missing": 1
          }
        }
      ],
      "score_mode": "multiply",
      "boost_mode": "multiply"
    }
  }
}
```

**评分策略：**
- 基础分数：标题匹配"手机"的相关性
- 销量加权：销量≥1000的商品权重×2
- 评分加权：评分×1.5倍权重
- 最终分数：基础分数 × 销量权重 × 评分权重

---

## 8. ⚡ 查询优化与最佳实践


### 8.1 查询性能优化策略


**🔧 优化技巧总结**

```
性能优化金字塔：
               Filter (最快)
              ↗
           Must_not (较快)  
          ↗
       Must (较慢)
      ↗
   Should (最慢)

优化原则：
1. 能用Filter就不用Must
2. 先过滤再匹配
3. 精确条件放前面
4. 复杂条件放后面
```

**📊 优化前后对比**
```json
// ❌ 未优化版本
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "Java"
          }
        },
        {
          "term": {
            "status": "published"
          }
        },
        {
          "range": {
            "price": {
              "gte": 100
            }
          }
        }
      ]
    }
  }
}

// ✅ 优化版本
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "Java"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "status": "published"
          }
        },
        {
          "range": {
            "price": {
              "gte": 100
            }
          }
        }
      ]
    }
  }
}
```

### 8.2 查询权重调整技巧


**⚖️ Boost权重设置**
```json
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": {
              "query": "Java开发",
              "boost": 3.0
            }
          }
        },
        {
          "match": {
            "content": {
              "query": "Java开发",
              "boost": 1.0
            }
          }
        }
      ]
    }
  }
}
```

**权重设置建议：**
- **标题字段**：权重2-5（最重要）
- **摘要字段**：权重1-2（较重要）
- **内容字段**：权重1（基准）
- **标签字段**：权重0.5-1.5（辅助）

### 8.3 查询组合策略


**🎯 最佳实践模板**
```json
{
  "query": {
    "bool": {
      "filter": [
        // 第一步：快速过滤（精确条件）
        {"term": {"status": "active"}},
        {"range": {"create_time": {"gte": "2023-01-01"}}}
      ],
      "must": [
        // 第二步：核心匹配（相关性）
        {"match": {"title": "用户输入的关键词"}}
      ],
      "should": [
        // 第三步：优化排序（加分项）
        {"match": {"category": "优先分类"}},
        {"range": {"view_count": {"gte": 100}}}
      ],
      "must_not": [
        // 第四步：排除条件（黑名单）
        {"term": {"hidden": true}},
        {"term": {"deleted": true}}
      ],
      "minimum_should_match": 1
    }
  }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Bool查询：复合查询的核心，组合多个查询条件
🔸 Must子句：硬性要求，必须满足，参与评分
🔸 Should子句：可选要求，满足更好，影响排名
🔸 Must_not子句：排除条件，绝不匹配，不参与评分
🔸 Filter子句：过滤条件，快速筛选，不参与评分
🔸 查询权重：通过boost调整不同条件的重要性
🔸 最小匹配数：控制Should子句的最少匹配数量
```

### 9.2 关键理解要点


**🔹 查询子句的选择原则**
```
Filter优先原则：
- 精确匹配 → Filter
- 范围查询 → Filter  
- 状态检查 → Filter
- 文本搜索 → Must
- 可选条件 → Should
- 排除条件 → Must_not
```

**🔹 性能优化记忆口诀**
```
Filter最快不评分，
Must评分较慢些，
Should可选影响排序，
Must_not排除要记清。
先过滤来后匹配，
精确条件放前面。
```

**🔹 实际应用场景**
```
电商搜索：
Filter: 分类、价格区间、库存状态
Must: 商品名称、品牌
Should: 促销标签、好评率
Must_not: 下架商品、禁售商品

内容搜索：
Filter: 发布状态、时间范围、分类
Must: 标题、内容关键词
Should: 标签匹配、作者匹配  
Must_not: 草稿、删除内容
```

### 9.3 最佳实践清单


**✅ 查询优化检查表**
- [ ] 把精确匹配条件放在Filter中
- [ ] 把排除条件放在Must_not中
- [ ] 合理设置Should的minimum_should_match
- [ ] 为重要字段设置合适的boost权重
- [ ] 避免在Must_not中使用复杂查询
- [ ] 优先使用term查询匹配精确值
- [ ] 定期分析查询性能并优化

**核心记忆**：
- Bool查询是复合查询的基础，掌握四大子句的特点和用法
- Filter不评分但最快，Must评分但较慢，合理选择提升性能
- 查询优化的核心是先过滤再匹配，精确条件优先执行
- 权重调整和最小匹配数是微调搜索结果的重要手段