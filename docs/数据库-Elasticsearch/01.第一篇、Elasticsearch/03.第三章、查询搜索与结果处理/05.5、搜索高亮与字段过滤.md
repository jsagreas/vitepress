---
title: 5、搜索高亮与字段过滤
---
## 📚 目录

1. [搜索高亮基础概念](#1-搜索高亮基础概念)
2. [高亮显示的实现原理](#2-高亮显示的实现原理)
3. [基础高亮配置与使用](#3-基础高亮配置与使用)
4. [高亮标签自定义](#4-高亮标签自定义)
5. [多字段高亮策略](#5-多字段高亮策略)
6. [高亮片段控制](#6-高亮片段控制)
7. [高亮性能优化](#7-高亮性能优化)
8. [字段过滤机制](#8-字段过滤机制)
9. [源字段过滤技术](#9-源字段过滤技术)
10. [存储字段与脚本字段](#10-存储字段与脚本字段)
11. [文档值字段处理](#11-文档值字段处理)
12. [字段折叠与内部命中](#12-字段折叠与内部命中)
13. [核心要点总结](#13-核心要点总结)

---

## 1. 🔍 搜索高亮基础概念


### 1.1 什么是搜索高亮


**🎯 核心定义**
```
搜索高亮：在搜索结果中标记出匹配查询条件的文本片段
目的：让用户快速识别为什么这个文档被搜索到
效果：就像用荧光笔标记重点内容一样
```

**💡 生活中的类比**
```
搜索高亮 = 荧光笔标记重点

普通搜索结果：
"这是一篇关于机器学习的文章，讲述了深度学习的基本原理..."

高亮后的结果：
"这是一篇关于<em>机器学习</em>的文章，讲述了<em>深度学习</em>的基本原理..."

用户一眼就能看出：文档中哪些地方包含了搜索关键词
```

### 1.2 高亮的应用场景


**🌟 典型使用场景**
```
搜索引擎：Google搜索结果中的关键词高亮
电商网站：商品搜索结果中的关键词突出显示
文档系统：文档内容搜索时的匹配文本标记
日志分析：日志内容中的关键信息突出显示
```

**📊 高亮带来的用户体验提升**
```
🔸 快速定位：用户无需阅读全文就能找到相关内容
🔸 提高效率：减少用户筛选信息的时间
🔸 增强信任：用户能清楚看到匹配的依据
🔸 改善体验：视觉化的搜索结果更加友好
```

---

## 2. ⚙️ 高亮显示的实现原理


### 2.1 高亮工作机制


**🔧 技术实现流程**
```
步骤1：执行搜索查询，获取匹配文档
      ↓
步骤2：分析查询条件，提取关键词
      ↓
步骤3：在文档内容中定位关键词位置
      ↓
步骤4：在关键词前后添加HTML标签
      ↓
步骤5：返回带标签的文本片段
```

**💭 简单理解**
```
原理就像用Word的"查找和替换"功能：
1. 找到文档中的关键词
2. 给关键词加上特殊标记
3. 返回加了标记的文本片段

但ES更智能：
- 支持模糊匹配
- 处理同义词
- 智能选择最佳片段
```

### 2.2 高亮器类型对比


| 高亮器类型 | **工作方式** | **性能** | **功能** | **适用场景** |
|-----------|------------|---------|---------|-------------|
| **unified** | `词向量分析` | `高` | `强大` | `默认推荐` |
| **plain** | `原始文本分析` | `中` | `基础` | `简单场景` |
| **fvh** | `快速向量` | `最高` | `中等` | `大量文本` |

### 2.3 高亮标签工作原理


**🏷️ 标签包装机制**
```
默认行为：
输入文本："Elasticsearch是强大的搜索引擎"
搜索词："搜索"
输出结果："Elasticsearch是强大的<em>搜索</em>引擎"

标签解释：
<em> = emphasis（强调标签）
浏览器会将<em>标签内容显示为斜体
可以通过CSS控制最终的显示效果
```

---

## 3. 🚀 基础高亮配置与使用


### 3.1 最简单的高亮配置


```json
{
  "query": {
    "match": {
      "content": "elasticsearch教程"
    }
  },
  "highlight": {
    "fields": {
      "content": {}
    }
  }
}
```

**📝 配置说明**
- `highlight`：开启高亮功能的根节点
- `fields`：指定需要高亮的字段
- `content: {}`：对content字段启用默认高亮设置

### 3.2 基础高亮响应结果


```json
{
  "hits": {
    "hits": [
      {
        "_source": {
          "title": "ES学习指南",
          "content": "这是一个详细的elasticsearch教程文档"
        },
        "highlight": {
          "content": [
            "这是一个详细的<em>elasticsearch</em><em>教程</em>文档"
          ]
        }
      }
    ]
  }
}
```

**🔍 结果解析**
- `highlight`：高亮结果的专门节点
- 数组格式：每个字段的高亮片段都是数组
- `<em>`标签：默认的高亮标记

### 3.3 多字段高亮示例


```json
{
  "query": {
    "multi_match": {
      "query": "python机器学习",
      "fields": ["title", "content", "tags"]
    }
  },
  "highlight": {
    "fields": {
      "title": {},
      "content": {},
      "tags": {}
    }
  }
}
```

**💡 实际应用场景**
```
博客搜索系统：
- 标题中的关键词高亮
- 正文内容的关键词高亮  
- 标签中的关键词高亮

这样用户能全方位看到匹配信息
```

---

## 4. 🎨 高亮标签自定义


### 4.1 自定义HTML标签


```json
{
  "query": {
    "match": {
      "content": "elasticsearch"
    }
  },
  "highlight": {
    "pre_tags": ["<mark class='highlight'>"],
    "post_tags": ["</mark>"],
    "fields": {
      "content": {}
    }
  }
}
```

**🏷️ 标签配置说明**
- `pre_tags`：关键词前面的标签（开始标签）
- `post_tags`：关键词后面的标签（结束标签）
- 可以添加CSS类名，方便前端样式控制

### 4.2 多样化标签样式


```json
{
  "highlight": {
    "pre_tags": [
      "<span class='red'>",
      "<span class='blue'>", 
      "<span class='green'>"
    ],
    "post_tags": ["</span>"],
    "fields": {
      "content": {}
    }
  }
}
```

**🌈 多彩高亮效果**
```
当有多个关键词时：
第1个关键词用红色标签
第2个关键词用蓝色标签
第3个关键词用绿色标签
超过3个关键词时循环使用
```

### 4.3 实际前端样式配合


```css
/* 对应的CSS样式 */
.highlight {
    background-color: yellow;
    font-weight: bold;
    padding: 2px 4px;
    border-radius: 3px;
}

.red { background-color: #ffebee; }
.blue { background-color: #e3f2fd; }
.green { background-color: #e8f5e8; }
```

**🎯 样式效果**
- 黄色背景突出显示
- 加粗字体增强视觉效果
- 圆角边框提升美观度

---

## 5. 🔄 多字段高亮策略


### 5.1 统一多字段高亮


```json
{
  "query": {
    "multi_match": {
      "query": "java开发工程师",
      "fields": ["title^2", "content", "skills"]
    }
  },
  "highlight": {
    "fields": {
      "title": {
        "pre_tags": ["<strong>"],
        "post_tags": ["</strong>"]
      },
      "content": {
        "fragment_size": 150,
        "number_of_fragments": 3
      },
      "skills": {
        "pre_tags": ["<mark>"],
        "post_tags": ["</mark>"]
      }
    }
  }
}
```

**🎛️ 字段级别差异化配置**
- `title`：使用粗体标签，突出标题匹配
- `content`：限制片段大小和数量
- `skills`：使用mark标签，区别于其他字段

### 5.2 高亮字段权重控制


```json
{
  "highlight": {
    "require_field_match": false,
    "fields": {
      "title": {
        "matched_fields": ["title", "title.keyword"],
        "type": "fvh"
      },
      "content": {
        "matched_fields": ["content"],
        "type": "unified"
      }
    }
  }
}
```

**⚖️ 权重策略说明**
- `require_field_match: false`：允许跨字段高亮
- `matched_fields`：指定参与匹配的字段组合
- 不同字段可以使用不同的高亮器类型

### 5.3 条件性字段高亮


```json
{
  "highlight": {
    "fields": {
      "title": {
        "highlight_query": {
          "match": {
            "title": {
              "query": "elasticsearch",
              "minimum_should_match": "75%"
            }
          }
        }
      }
    }
  }
}
```

**🎯 条件高亮的用途**
```
场景：只有当标题匹配度足够高时才高亮
好处：避免无关紧要的匹配被高亮
结果：高亮结果更加精准和有意义
```

---

## 6. ✂️ 高亮片段控制


### 6.1 片段大小控制


```json
{
  "highlight": {
    "fields": {
      "content": {
        "fragment_size": 100,
        "number_of_fragments": 2
      }
    }
  }
}
```

**📏 片段参数详解**
- `fragment_size`：每个片段的字符长度（默认100）
- `number_of_fragments`：返回片段数量（默认5）
- 小技巧：设置为0表示高亮整个字段内容

### 6.2 片段边界控制


```json
{
  "highlight": {
    "fields": {
      "content": {
        "boundary_chars": ".,!? \t\n",
        "boundary_max_scan": 20,
        "fragment_size": 150
      }
    }
  }
}
```

**🔤 边界控制说明**
- `boundary_chars`：片段边界字符（句号、逗号、空格等）
- `boundary_max_scan`：寻找边界字符的最大扫描距离
- 目的：确保片段在合适的位置断开，不会截断单词

### 6.3 片段排序策略


```json
{
  "highlight": {
    "fields": {
      "content": {
        "order": "score",
        "fragment_size": 100,
        "number_of_fragments": 3
      }
    }
  }
}
```

**📊 排序选项**
- `score`：按匹配分数排序（推荐）
- `none`：按在文档中出现的顺序排序
- 高分片段优先：用户先看到最相关的内容

---

## 7. ⚡ 高亮性能优化


### 7.1 高亮器选择策略


**🚀 性能对比分析**
```
unified高亮器（推荐）：
✅ 功能最全面
✅ 性能相对较好
✅ 支持所有查询类型
适用：大多数场景

fast vector highlighter（fvh）：
✅ 性能最高
❌ 需要term_vector支持
❌ 占用更多存储空间
适用：大文本、高并发场景

plain高亮器：
✅ 内存占用最少
❌ 功能相对简单
❌ 性能一般
适用：简单文本高亮
```

### 7.2 term_vector优化配置


```json
{
  "mappings": {
    "properties": {
      "content": {
        "type": "text",
        "term_vector": "with_positions_offsets",
        "analyzer": "standard"
      }
    }
  }
}
```

**⚙️ term_vector配置说明**
- `with_positions_offsets`：存储词条位置和偏移信息
- 好处：大幅提升高亮性能
- 代价：增加约25%的存储空间
- 建议：高频搜索字段启用

### 7.3 高亮缓存策略


```json
{
  "highlight": {
    "fields": {
      "content": {
        "type": "fvh",
        "fragment_size": 100,
        "fragment_offset": 0,
        "no_match_size": 50
      }
    }
  }
}
```

**💾 缓存优化技巧**
- 固定`fragment_size`：便于缓存片段结果
- 合理设置`no_match_size`：无匹配时的返回片段大小
- 避免过大的片段：减少内存压力

---

## 8. 🔧 字段过滤机制


### 8.1 字段过滤的必要性


**🎯 为什么需要字段过滤**
```
问题场景：
文档包含50个字段，用户只需要其中3个字段
不过滤：网络传输50个字段的数据
过滤后：只传输3个字段的数据

效果对比：
数据量：减少90%+
网络耗时：显著降低
前端处理：更简单高效
```

**📊 实际影响分析**
```
大型文档示例：
全字段大小：2MB/文档
过滤后大小：100KB/文档
传输效率：提升20倍
页面渲染：速度显著提升
```

### 8.2 字段过滤的分类


**🗂️ 过滤方式分类**
```
源字段过滤(_source)：
- 控制_source字段的返回内容
- 最常用的过滤方式
- 支持包含/排除模式

存储字段(stored_fields)：
- 返回明确存储的字段
- 需要字段设置store: true
- 性能较好但需要额外存储

脚本字段(script_fields)：
- 通过脚本动态计算字段值
- 灵活但性能开销较大
- 适合临时计算场景

文档值字段(docvalue_fields)：
- 返回用于聚合和排序的字段
- 基于列式存储
- 适合数值和日期字段
```

---

## 9. 📁 源字段过滤技术


### 9.1 基础包含过滤


```json
{
  "query": {
    "match": {
      "title": "elasticsearch"
    }
  },
  "_source": ["title", "author", "publish_date"]
}
```

**🎯 包含过滤说明**
- 只返回指定的字段
- 数组形式列出需要的字段名
- 最简单直接的过滤方式

### 9.2 排除过滤策略


```json
{
  "query": {
    "match_all": {}
  },
  "_source": {
    "excludes": ["internal_id", "metadata.*", "*.raw"]
  }
}
```

**🚫 排除过滤用途**
- 排除不需要的字段
- 支持通配符模式
- 适合字段较多的情况

### 9.3 组合包含排除过滤


```json
{
  "query": {
    "match_all": {}
  },
  "_source": {
    "includes": ["user.*", "post.*"],
    "excludes": ["*.internal", "user.password"]
  }
}
```

**⚖️ 组合过滤优势**
```
执行顺序：
1. 先应用includes规则
2. 再应用excludes规则
3. 最终返回符合条件的字段

实际应用：
includes: ["user.*"] → 包含所有user开头的字段
excludes: ["user.password"] → 但排除敏感的密码字段
结果：安全且完整的用户信息
```

### 9.4 通配符模式详解


```json
{
  "_source": {
    "includes": [
      "product.*",      // 所有product前缀字段
      "*_name",         // 所有name后缀字段
      "category.*.id"   // 嵌套对象的特定字段
    ],
    "excludes": [
      "*.internal.*",   // 所有internal路径字段
      "temp_*"          // 所有临时字段
    ]
  }
}
```

**🎨 通配符规则**
- `*`：匹配任意字符
- `product.*`：匹配product下的所有字段
- `*.name`：匹配任意对象的name字段
- `category.*.id`：匹配category下任意子对象的id字段

---

## 10. 💾 存储字段与脚本字段


### 10.1 存储字段配置与使用


**🗄️ 映射配置**
```json
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "store": true
      },
      "content": {
        "type": "text",
        "store": false
      },
      "summary": {
        "type": "text",
        "store": true
      }
    }
  }
}
```

**📊 查询存储字段**
```json
{
  "query": {
    "match": {
      "content": "elasticsearch"
    }
  },
  "stored_fields": ["title", "summary"],
  "_source": false
}
```

**💡 存储字段的使用场景**
```
适用情况：
✅ 需要快速访问特定字段
✅ 字段内容较小且查询频繁
✅ 减少_source解析开销

不适用情况：
❌ 字段内容很大
❌ 查询频率很低
❌ 存储空间敏感
```

### 10.2 脚本字段动态计算


```json
{
  "query": {
    "match_all": {}
  },
  "script_fields": {
    "full_name": {
      "script": {
        "source": "doc['first_name'].value + ' ' + doc['last_name'].value"
      }
    },
    "price_with_tax": {
      "script": {
        "source": "doc['price'].value * 1.2"
      }
    }
  }
}
```

**🔧 脚本字段特点**
- 实时计算：每次查询都重新计算
- 灵活性高：可以进行复杂逻辑处理
- 性能开销：计算成本相对较高
- 无需存储：不占用额外存储空间

### 10.3 脚本字段实际应用


```json
{
  "script_fields": {
    "age": {
      "script": {
        "source": """
          long birth = doc['birth_date'].value.getMillis();
          long now = System.currentTimeMillis();
          return (int)((now - birth) / (365.25 * 24 * 3600 * 1000));
        """
      }
    },
    "discount_price": {
      "script": {
        "source": """
          double price = doc['original_price'].value;
          double discount = doc['discount_rate'].value;
          return Math.round(price * (1 - discount) * 100.0) / 100.0;
        """
      }
    }
  }
}
```

**🎯 业务场景示例**
- 年龄计算：根据生日实时计算当前年龄
- 价格计算：根据原价和折扣率计算实际价格
- 状态判断：根据多个条件计算综合状态

---

## 11. 📊 文档值字段处理


### 11.1 文档值字段基础


**🔢 什么是文档值字段**
```
文档值(Doc Values)：
- Elasticsearch的列式存储结构
- 专门用于排序、聚合和脚本计算
- 存储在磁盘上，内存效率更高
- 默认对所有字段（除text）启用
```

**📈 工作原理图解**
```
行式存储（_source）：
文档1: {name: "张三", age: 25, city: "北京"}
文档2: {name: "李四", age: 30, city: "上海"}
文档3: {name: "王五", age: 28, city: "北京"}

列式存储（doc_values）：
name: ["张三", "李四", "王五"]
age:  [25, 30, 28]
city: ["北京", "上海", "北京"]

优势：排序和聚合时只需要读取相关列
```

### 11.2 查询文档值字段


```json
{
  "query": {
    "match": {
      "title": "elasticsearch"
    }
  },
  "docvalue_fields": [
    "publish_date",
    "view_count",
    "rating"
  ]
}
```

**⚙️ 基础查询说明**
- 只返回指定的文档值字段
- 适合数值、日期、布尔类型字段
- 不支持text类型字段

### 11.3 格式化文档值字段


```json
{
  "docvalue_fields": [
    {
      "field": "publish_date",
      "format": "yyyy-MM-dd"
    },
    {
      "field": "price",
      "format": "0.00"
    },
    {
      "field": "percentage",
      "format": "0.0%"
    }
  ]
}
```

**🎨 格式化的实际用途**
```
日期格式化：
原始值：1640995200000（时间戳）
格式化后："2022-01-01"

数字格式化：
原始值：123.456
格式化后："123.46"

百分比格式化：
原始值：0.85
格式化后："85.0%"
```

### 11.4 文档值字段性能优化


```json
{
  "mappings": {
    "properties": {
      "description": {
        "type": "text",
        "doc_values": false
      },
      "internal_id": {
        "type": "keyword",
        "doc_values": false
      },
      "timestamp": {
        "type": "date",
        "doc_values": true
      }
    }
  }
}
```

**🔧 优化策略**
- 不需要排序/聚合的字段：关闭doc_values
- 仅用于搜索的text字段：关闭doc_values
- 常用于排序的字段：保持doc_values开启

---

## 12. 🎯 字段折叠与内部命中


### 12.1 字段折叠基础概念


**📚 什么是字段折叠**
```
字段折叠(Field Collapse)：
- 按指定字段值对搜索结果进行分组
- 每组只返回一个代表性文档
- 类似SQL的GROUP BY，但更高效
- 常用于去重和分类展示
```

**🎯 实际应用场景**
```
电商网站：
搜索"手机" → 每个品牌只显示一个最相关的产品

新闻网站：
搜索"疫情" → 每个媒体只显示一篇最新的新闻

招聘网站：
搜索"Java工程师" → 每个公司只显示一个最匹配的职位
```

### 12.2 基础字段折叠实现


```json
{
  "query": {
    "match": {
      "content": "elasticsearch教程"
    }
  },
  "collapse": {
    "field": "author.keyword"
  },
  "sort": [
    {
      "publish_date": {
        "order": "desc"
      }
    }
  ]
}
```

**🔧 配置说明**
- `collapse.field`：折叠依据的字段（必须是keyword类型）
- `sort`：决定每组中哪个文档被选为代表
- 结果：每个作者只返回一篇最新的文章

### 12.3 内部命中配置


```json
{
  "query": {
    "match": {
      "category": "技术"
    }
  },
  "collapse": {
    "field": "author.keyword",
    "inner_hits": {
      "name": "other_posts",
      "size": 3,
      "sort": [
        {
          "view_count": {
            "order": "desc"
          }
        }
      ]
    }
  }
}
```

**📊 内部命中的作用**
```
主结果：每个作者的代表性文档
内部命中：该作者的其他相关文档

示例结果结构：
{
  "hits": [
    {
      "_source": {...},  // 张三的代表性文章
      "inner_hits": {
        "other_posts": {
          "hits": [...]   // 张三的其他2-3篇文章
        }
      }
    }
  ]
}
```

### 12.4 多级字段折叠


```json
{
  "collapse": {
    "field": "category.keyword",
    "inner_hits": {
      "name": "top_in_category",
      "size": 2,
      "collapse": {
        "field": "author.keyword"
      }
    }
  }
}
```

**🎲 多级折叠逻辑**
```
第一级折叠：按分类分组
第二级折叠：每个分类内按作者分组

结果结构：
技术分类 → 
  ├─ 张三的文章（代表）
  └─ 李四的文章（代表）
生活分类 →
  ├─ 王五的文章（代表）  
  └─ 赵六的文章（代表）
```

### 12.5 折叠性能考量


**⚡ 性能优化建议**
```
字段选择：
✅ 使用keyword类型字段
✅ 选择基数适中的字段（不要太多也不要太少唯一值）
❌ 避免使用text字段

查询优化：
✅ 合理设置inner_hits的size
✅ 使用高效的排序字段
✅ 避免过于复杂的查询条件

监控指标：
- 折叠后结果数量
- 查询响应时间
- 内存使用情况
```

---

## 13. 📋 核心要点总结


### 13.1 必须掌握的核心概念


```
🔸 搜索高亮：用HTML标签标记匹配文本，提升用户体验
🔸 高亮配置：pre_tags、post_tags、fragment_size等关键参数
🔸 字段过滤：_source、stored_fields、script_fields等不同方式
🔸 文档值字段：基于列式存储的高效字段访问方式
🔸 字段折叠：按字段值分组，实现结果去重和分类
🔸 内部命中：在折叠结果中包含同组的其他文档
```

### 13.2 关键技术选择指南


**🎯 高亮器选择策略**
```
unified高亮器（默认推荐）：
✅ 功能全面，性能良好
✅ 支持所有查询类型
适用：大多数业务场景

fvh高亮器（高性能场景）：
✅ 性能最优
❌ 需要term_vector支持
适用：大文本、高并发

plain高亮器（简单场景）：
✅ 内存占用少
❌ 功能相对简单
适用：基础文本高亮
```

**📁 字段过滤选择策略**
```
_source过滤：
✅ 最常用，最灵活
✅ 支持通配符模式
适用：绝大多数场景

stored_fields：
✅ 性能最好
❌ 需要额外存储空间
适用：频繁访问的小字段

script_fields：
✅ 最灵活，支持计算
❌ 性能开销较大
适用：动态计算场景

docvalue_fields：
✅ 内存效率高
❌ 仅支持特定类型字段
适用：数值、日期字段
```

### 13.3 性能优化核心要点


**⚡ 高亮性能优化**
```
配置优化：
- 启用term_vector提升fvh性能
- 合理设置fragment_size和number_of_fragments
- 使用require_field_match控制高亮范围

查询优化：
- 避免过于复杂的高亮查询
- 合理使用边界字符控制
- 考虑使用缓存策略
```

**📊 字段过滤优化**
```
网络传输优化：
- 只返回必要的字段
- 使用通配符简化配置
- 排除大字段和敏感字段

存储优化：
- 关闭不需要的doc_values
- 合理使用stored字段
- 避免过度使用script_fields
```

### 13.4 实际应用最佳实践


**🛠️ 搜索高亮最佳实践**
```
用户体验：
- 使用醒目但不刺眼的高亮样式
- 控制高亮片段的长度和数量
- 提供多字段高亮支持

技术实现：
- 统一高亮标签和CSS样式
- 处理HTML转义和安全问题
- 考虑移动端的显示效果
```

**📱 字段过滤最佳实践**
```
API设计：
- 提供灵活的字段选择参数
- 支持预设的字段组合
- 考虑不同客户端的需求差异

性能监控：
- 监控字段过滤的效果
- 分析网络传输优化程度
- 持续优化字段选择策略
```

**核心记忆口诀**：
- 高亮显示提体验，标签片段要配全
- 字段过滤省流量，按需返回最高效
- 折叠去重分类好，内部命中更完整
- 性能优化是关键，监控调优不能停