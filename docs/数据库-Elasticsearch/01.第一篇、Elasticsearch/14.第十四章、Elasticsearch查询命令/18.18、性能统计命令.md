---
title: 18、性能统计命令
---
## 📚 目录

1. [性能监控基础概念](#1-性能监控基础概念)
2. [集群整体统计命令](#2-集群整体统计命令)
3. [索引级别统计命令](#3-索引级别统计命令)
4. [节点性能统计命令](#4-节点性能统计命令)
5. [线程池与资源监控](#5-线程池与资源监控)
6. [段与内存统计命令](#6-段与内存统计命令)
7. [实用监控技巧](#7-实用监控技巧)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 性能监控基础概念


### 1.1 为什么需要性能监控


**🔸 监控的必要性**
```
生产环境问题场景：
• 用户反馈：搜索速度越来越慢
• 系统告警：内存使用率持续上升
• 运维困惑：不知道瓶颈在哪里
• 容量规划：需要扩容还是优化？

监控解决的问题：
✅ 及时发现性能问题
✅ 定位问题根本原因  
✅ 制定优化策略
✅ 预防系统故障
```

### 1.2 Elasticsearch监控体系


**📊 监控层次结构**
```
集群层面监控
├── 整体健康状态
├── 节点数量与状态
├── 索引分布情况
└── 资源使用概况

节点层面监控  
├── CPU、内存使用
├── 磁盘IO性能
├── 网络传输状态
└── JVM垃圾回收

索引层面监控
├── 文档数量变化
├── 索引大小增长
├── 搜索性能指标
└── 写入性能指标
```

### 1.3 关键性能指标说明


**⚡ 核心性能指标**

| 指标类型 | **具体指标** | **含义解释** | **正常范围** |
|---------|------------|-------------|------------|
| 🔍 **搜索性能** | `search.query_time_in_millis` | 查询总耗时 | `<100ms` |
| 📝 **写入性能** | `indexing.index_time_in_millis` | 索引写入耗时 | `<50ms` |
| 🧠 **内存使用** | `jvm.mem.heap_used_percent` | JVM堆内存使用率 | `<75%` |
| 💾 **磁盘使用** | `fs.total.available_in_bytes` | 可用磁盘空间 | `>20%剩余` |
| 🔄 **垃圾回收** | `jvm.gc.collectors.young.collection_time_in_millis` | GC耗时 | `<1000ms` |

---

## 2. 📈 集群整体统计命令


### 2.1 集群统计概览


**🔸 GET /_stats - 获取所有统计信息**

这个命令相当于给整个Elasticsearch集群做一次"全身体检"，能看到集群的整体运行状况。

```bash
# 获取集群所有统计信息
GET /_stats

# 响应示例（核心部分）
{
  "_all": {
    "primaries": {
      "docs": { "count": 1000000 },      # 主分片文档总数
      "store": { "size_in_bytes": 524288000 },  # 存储大小
      "indexing": {
        "index_total": 50000,           # 索引操作总数
        "index_time_in_millis": 25000   # 索引耗时
      },
      "search": {
        "query_total": 100000,          # 查询总数
        "query_time_in_millis": 45000   # 查询耗时
      }
    }
  }
}
```

**💡 关键数据解读**
- **docs.count**: 告诉你集群里总共存了多少条数据
- **store.size_in_bytes**: 所有数据占用的磁盘空间
- **indexing部分**: 写入操作的效率如何
- **search部分**: 搜索操作的性能表现

### 2.2 集群统计详细信息


**🔸 GET /_cluster/stats - 集群统计汇总**

如果说`/_stats`是详细体检报告，那`/_cluster/stats`就是体检结果的汇总表，更适合快速了解集群状态。

```bash
# 获取集群统计汇总
GET /_cluster/stats

# 关键信息解读
{
  "cluster_name": "my-cluster",
  "status": "green",                    # 集群健康状态
  "indices": {
    "count": 15,                        # 索引总数
    "docs": { "count": 1000000 },       # 文档总数
    "store": { "size_in_bytes": 524288000 }  # 总存储大小
  },
  "nodes": {
    "count": { "total": 3 },            # 节点总数
    "versions": ["7.15.0"],             # ES版本
    "jvm": {
      "max_uptime_in_millis": 86400000, # 最长运行时间
      "mem": {
        "heap_used_in_bytes": 2147483648,  # 堆内存使用
        "heap_max_in_bytes": 4294967296   # 堆内存总量
      }
    }
  }
}
```

**🎯 快速判断集群状态**
- `status: "green"` = 一切正常 ✅
- `status: "yellow"` = 有警告，需要关注 ⚠️  
- `status: "red"` = 有问题，需要立即处理 🚨

---

## 3. 📊 索引级别统计命令


### 3.1 单个索引统计


**🔸 GET /{index}/_stats - 查看特定索引统计**

当你想了解某个具体索引的表现时，这个命令就像是给特定器官做专项检查。

```bash
# 查看用户索引的统计信息
GET /users/_stats

# 核心统计信息
{
  "indices": {
    "users": {
      "primaries": {
        "docs": { "count": 50000 },
        "store": { "size_in_bytes": 26214400 },
        "indexing": {
          "index_total": 5000,
          "index_time_in_millis": 2500,
          "index_current": 0              # 当前正在索引的文档数
        },
        "search": {
          "query_total": 10000,
          "query_time_in_millis": 4500,
          "query_current": 2              # 当前正在执行的查询数
        },
        "get": {
          "total": 1000,
          "time_in_millis": 500,
          "current": 0
        }
      }
    }
  }
}
```

### 3.2 索引性能分析技巧


**📋 性能指标计算**

让我们把这些数字转换成更容易理解的性能指标：

```bash
# 索引性能计算示例
平均索引时间 = index_time_in_millis ÷ index_total
             = 2500ms ÷ 5000次 = 0.5ms/次

平均查询时间 = query_time_in_millis ÷ query_total  
             = 4500ms ÷ 10000次 = 0.45ms/次

索引吞吐量 = index_total ÷ 运行时间
查询吞吐量 = query_total ÷ 运行时间
```

**⚡ 性能评判标准**
- **索引速度**: `<1ms/文档` 优秀，`1-5ms` 良好，`>5ms` 需要优化
- **查询速度**: `<10ms` 优秀，`10-50ms` 良好，`>50ms` 需要优化
- **当前操作数**: 如果`current`值持续很高，说明有堆积

### 3.3 多索引统计对比


**🔸 GET /_stats/indexing,search - 指定统计类型**

当你只关心特定类型的性能数据时，可以指定获取哪些统计信息，这样响应更快，数据更聚焦。

```bash
# 只获取索引和搜索相关统计
GET /_stats/indexing,search

# 多个索引对比
GET /users,orders,products/_stats/indexing,search

# 简化的响应数据
{
  "_all": {
    "primaries": {
      "indexing": { /* 索引统计 */ },
      "search": { /* 搜索统计 */ }
    }
  },
  "indices": {
    "users": { /* 用户索引统计 */ },
    "orders": { /* 订单索引统计 */ },
    "products": { /* 产品索引统计 */ }
  }
}
```

---

## 4. 🖥️ 节点性能统计命令


### 4.1 节点统计概览


**🔸 GET /_nodes/stats - 节点详细统计**

这个命令让你了解集群中每个节点的"身体状况"，就像医生检查每个器官的功能。

```bash
# 获取所有节点统计
GET /_nodes/stats

# 获取特定节点统计  
GET /_nodes/node1,node2/stats

# 只获取JVM和操作系统统计
GET /_nodes/stats/jvm,os

# 关键响应数据
{
  "nodes": {
    "node1": {
      "name": "data-node-1",
      "roles": ["data", "ingest"],
      "jvm": {
        "timestamp": 1642761234567,
        "uptime_in_millis": 86400000,
        "mem": {
          "heap_used_in_bytes": 2147483648,     # 堆内存使用
          "heap_used_percent": 50,              # 堆内存使用率
          "heap_max_in_bytes": 4294967296       # 堆内存总量
        },
        "gc": {
          "collectors": {
            "young": {
              "collection_count": 100,          # 年轻代GC次数
              "collection_time_in_millis": 1000 # 年轻代GC耗时
            }
          }
        }
      },
      "os": {
        "cpu": { "percent": 25 },              # CPU使用率
        "mem": {
          "total_in_bytes": 8589934592,        # 系统总内存
          "free_in_bytes": 2147483648          # 系统可用内存
        }
      }
    }
  }
}
```

### 4.2 节点健康状态判断


**🩺 健康状态评估标准**

```
🟢 健康状态：
• CPU使用率 < 70%
• 堆内存使用率 < 75%  
• GC时间占比 < 5%
• 磁盘使用率 < 80%

🟡 警告状态：
• CPU使用率 70-85%
• 堆内存使用率 75-85%
• GC时间占比 5-10%
• 磁盘使用率 80-90%

🔴 危险状态：
• CPU使用率 > 85%
• 堆内存使用率 > 85%
• GC时间占比 > 10%
• 磁盘使用率 > 90%
```

### 4.3 节点性能问题诊断


**🔍 常见问题诊断**

```bash
# 检查内存使用情况
GET /_nodes/stats/jvm

# 分析结果：
如果 heap_used_percent > 80%：
  ├── 检查查询复杂度
  ├── 调整堆内存大小
  └── 考虑增加节点

# 检查GC性能
GET /_nodes/stats/jvm
  
# 分析GC指标：
GC频率 = collection_count ÷ uptime_in_millis
GC耗时占比 = collection_time_in_millis ÷ uptime_in_millis

如果GC耗时占比 > 5%：
  ├── 调整GC参数
  ├── 增加堆内存
  └── 优化查询和索引
```

---

## 5. 🔄 线程池与资源监控


### 5.1 线程池状态监控


**🔸 GET /_cat/thread_pool - 线程池状态**

线程池就像是Elasticsearch的"工作队伍"，不同类型的任务需要不同的工作组来处理。

```bash
# 查看线程池状态
GET /_cat/thread_pool?v&h=node_name,name,active,queue,rejected

# 响应示例
node_name    name        active queue rejected
data-node-1  search      2      0     0
data-node-1  index       1      0     0  
data-node-1  bulk        0      0     0
data-node-1  get         0      0     0
data-node-1  management  1      0     0
```

**📋 线程池类型说明**

| 线程池类型 | **作用** | **正常状态** | **异常信号** |
|-----------|---------|------------|------------|
| 🔍 **search** | 处理搜索请求 | `queue=0, rejected=0` | `queue>0` 或 `rejected>0` |
| 📝 **index** | 处理单文档索引 | `queue=0, rejected=0` | `queue持续>0` |
| 📦 **bulk** | 处理批量操作 | `active适中` | `queue满载` |
| 🎯 **get** | 处理GET请求 | `响应快速` | `queue堆积` |
| ⚙️ **management** | 集群管理任务 | `偶尔活跃` | `持续繁忙` |

### 5.2 线程池性能分析


**⚠️ 问题诊断指南**

```bash
# 查看详细线程池统计
GET /_nodes/stats/thread_pool

# 关键指标分析：
{
  "thread_pool": {
    "search": {
      "threads": 13,        # 当前线程数
      "queue": 0,           # 队列中等待的任务
      "active": 2,          # 正在执行的任务
      "rejected": 0,        # 被拒绝的任务数
      "largest": 13,        # 历史最大线程数
      "completed": 1000000  # 已完成任务数
    }
  }
}
```

**🚨 问题信号识别**
- **队列堆积**: `queue > 0` 且持续增长 → 处理能力不足
- **任务拒绝**: `rejected > 0` → 系统过载
- **活跃线程满载**: `active = threads` → 需要调优或扩容

---

## 6. 💾 段与内存统计命令


### 6.1 段统计信息


**🔸 GET /_cat/segments - 段统计信息**

Elasticsearch把数据存储在"段"(segments)中，就像是把书分成不同的章节，每个段都是一个独立的存储单元。

```bash
# 查看段信息
GET /_cat/segments?v&h=index,shard,prirep,segment,generation,docs.count,size

# 响应示例
index  shard prirep segment   generation docs.count    size
users  0     p      _0        0          1000         1.2mb
users  0     p      _1        1          2000         2.1mb
users  0     p      _2        2          500          800kb
users  1     p      _0        0          1500         1.8mb
```

**📊 段统计解读**
- **segment数量**: 每个分片的段数量，太多会影响搜索性能
- **docs.count**: 每个段包含的文档数
- **size**: 段的物理大小
- **generation**: 段的生成序号，数字越大越新

### 6.2 字段数据内存使用


**🔸 GET /_cat/fielddata - 字段数据统计**

字段数据是Elasticsearch在内存中缓存的字段信息，主要用于排序、聚合等操作。

```bash
# 查看字段数据使用情况
GET /_cat/fielddata?v&h=node,field,size

# 响应示例  
node        field       size
data-node-1 user_id     10.2mb
data-node-1 timestamp   5.8mb
data-node-1 category    3.1mb
data-node-2 user_id     9.8mb
data-node-2 timestamp   6.2mb
```

**🧠 内存使用优化建议**
```
内存使用分析：
• 字段数据占用过多 → 考虑使用doc_values
• 某个字段占用特别大 → 检查数据类型是否合适
• 内存增长过快 → 设置字段数据缓存限制

优化策略：
✅ 对不需要排序/聚合的字段禁用fielddata
✅ 使用keyword类型替代text类型进行精确匹配
✅ 设置合理的fielddata缓存大小限制
```

### 6.3 段合并监控


**📈 段合并性能影响**

段太多会让搜索变慢，就像在一个杂乱的图书馆找书一样。Elasticsearch会自动合并小段成大段。

```bash
# 查看段合并统计
GET /_stats/merge

# 关键指标
{
  "merge": {
    "current": 1,                    # 当前正在进行的合并
    "current_docs": 5000,            # 正在合并的文档数
    "current_size_in_bytes": 5242880, # 正在合并的数据大小
    "total": 100,                    # 历史合并总数
    "total_time_in_millis": 30000,   # 合并总耗时
    "total_docs": 500000,            # 合并的文档总数
    "total_size_in_bytes": 524288000 # 合并的数据总大小
  }
}
```

---

## 7. 🛠️ 实用监控技巧


### 7.1 性能监控脚本


**⭐ 一键健康检查脚本**

```bash
#!/bin/bash
# ES集群健康检查脚本

echo "=== 集群健康状态 ==="
curl -s "localhost:9200/_cluster/health?pretty" | jq '.status, .number_of_nodes, .active_primary_shards'

echo -e "\n=== 节点CPU和内存 ==="
curl -s "localhost:9200/_cat/nodes?v&h=name,cpu,ram.percent,heap.percent"

echo -e "\n=== 索引大小统计 ==="  
curl -s "localhost:9200/_cat/indices?v&h=index,docs.count,store.size&s=store.size:desc"

echo -e "\n=== 线程池状态 ==="
curl -s "localhost:9200/_cat/thread_pool?v&h=node_name,name,active,queue,rejected" | grep -E "(search|index|bulk)"
```

### 7.2 性能告警阈值设置


**📊 告警阈值配置表**

| 监控项目 | **警告阈值** | **严重阈值** | **检查命令** |
|---------|------------|-------------|------------|
| 🔴 **堆内存使用率** | `75%` | `85%` | `GET /_nodes/stats/jvm` |
| 🟡 **CPU使用率** | `70%` | `85%` | `GET /_nodes/stats/os` |
| 🟢 **磁盘使用率** | `80%` | `90%` | `GET /_nodes/stats/fs` |
| 🔵 **搜索队列长度** | `5` | `20` | `GET /_cat/thread_pool` |
| 🟣 **索引队列长度** | `10` | `50` | `GET /_cat/thread_pool` |

### 7.3 性能问题排查流程


**🔍 问题排查步骤**

```
第一步：检查集群整体状态
├── GET /_cluster/health
├── GET /_cluster/stats  
└── 确认是集群问题还是节点问题

第二步：定位问题节点
├── GET /_cat/nodes?v
├── GET /_nodes/stats/jvm,os
└── 找出资源使用异常的节点

第三步：分析具体问题
├── 内存问题 → 检查heap使用和GC
├── CPU问题 → 检查查询复杂度
├── IO问题 → 检查磁盘使用和段合并
└── 网络问题 → 检查集群通信

第四步：制定解决方案
├── 立即措施：重启、清理、限流
├── 短期优化：调参、索引优化
└── 长期规划：扩容、架构调整
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心命令


```bash
🔸 集群整体监控：
GET /_stats                    # 完整统计信息
GET /_cluster/stats           # 集群统计汇总
GET /_cluster/health          # 集群健康状态

🔸 索引性能监控：  
GET /{index}/_stats           # 特定索引统计
GET /_stats/indexing,search   # 指定统计类型

🔸 节点性能监控：
GET /_nodes/stats             # 节点详细统计
GET /_cat/nodes?v            # 节点概览信息

🔸 资源使用监控：
GET /_cat/thread_pool        # 线程池状态
GET /_cat/segments           # 段统计信息
GET /_cat/fielddata          # 字段数据统计
```

### 8.2 关键性能指标理解


**🎯 必知指标含义**
- **堆内存使用率**: 反映JVM内存压力，超过75%需要关注
- **GC时间占比**: 垃圾回收耗时，超过5%影响性能
- **线程池队列**: 任务堆积情况，>0说明处理能力不足
- **平均查询时间**: 搜索性能指标，>50ms需要优化
- **段数量**: 影响搜索效率，每分片建议<50个段

### 8.3 实战应用价值


**📈 监控的实际作用**
- **预防故障**: 通过趋势分析提前发现问题
- **性能优化**: 基于数据制定优化策略
- **容量规划**: 根据增长趋势规划扩容
- **问题定位**: 快速找到性能瓶颈根源

**🚀 最佳实践建议**
- **定期监控**: 建立日常巡检机制
- **设置告警**: 关键指标超阈值及时通知
- **保存历史**: 建立性能数据历史记录
- **优化迭代**: 基于监控数据持续优化

**核心记忆**：
- Elasticsearch性能监控就像给系统做体检
- 统计命令帮你了解集群、节点、索引的"身体状况"
- 关键是要看懂数据，知道什么是正常，什么需要关注
- 监控不是目的，发现问题并解决问题才是核心价值