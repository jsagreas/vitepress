---
title: 16、索引滚动管理
---
## 📚 目录

1. [索引滚动基础概念](#1-索引滚动基础概念)
2. [滚动操作核心命令](#2-滚动操作核心命令)
3. [别名滚动管理](#3-别名滚动管理)
4. [滚动模板配置](#4-滚动模板配置)
5. [索引分割与收缩](#5-索引分割与收缩)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔄 索引滚动基础概念


### 1.1 什么是索引滚动


**💡 通俗理解**：就像日记本写满了要换新本子一样
```
旧日记本满了 → 拿新日记本 → 继续写日记

logs-2024-01 满了 → 创建 logs-2024-02 → 继续写入日志
```

**核心作用**：
- 🔸 **防止索引过大**：单个索引太大会影响性能
- 🔸 **便于管理**：按时间或大小分割数据
- 🔸 **提高查询效率**：小索引查询更快
- 🔸 **方便删除**：过期数据整个索引删除

### 1.2 滚动触发条件


**自动滚动条件**：
```
大小条件：索引达到指定大小（如5GB）
时间条件：索引存在时间超过期限（如7天）
文档数量：文档数量达到上限（如1000万）
```

**滚动策略示意图**：
```
时间滚动：
logs-2024-01-01 → logs-2024-01-02 → logs-2024-01-03
     ↓                ↓                ↓
   1天后滚动        1天后滚动        1天后滚动

大小滚动：
index-000001 → index-000002 → index-000003
     ↓             ↓             ↓
   5GB后滚动     5GB后滚动     5GB后滚动
```

### 1.3 滚动与别名的关系


**别名的作用**：就像门牌号，房子换了但地址不变
```
应用程序访问：logs-current（别名）
实际指向：logs-2024-01-15（真实索引）

滚动后：
应用程序访问：logs-current（别名不变）
实际指向：logs-2024-01-16（新索引）
```

---

## 2. 🎯 滚动操作核心命令


### 2.1 基础滚动命令


**🔸 自动滚动（推荐方式）**
```bash
# 基于大小滚动
POST /logs-000001/_rollover
{
  "conditions": {
    "max_size": "5gb"
  }
}
```

**命令说明**：
- `logs-000001`：当前索引名称
- `max_size`：触发滚动的最大大小
- **自动命名**：新索引会自动命名为 `logs-000002`

**🔸 指定新索引名称滚动**
```bash
# 手动指定新索引名
PUT /logs-current/_rollover/logs-2024-01-16
{
  "conditions": {
    "max_age": "7d",
    "max_docs": 10000000
  }
}
```

**参数详解**：
- `max_age: "7d"`：索引存在超过7天就滚动
- `max_docs: 10000000`：文档数超过1000万就滚动
- 满足**任一条件**就会触发滚动

### 2.2 滚动条件检查


**🔸 检查是否满足滚动条件**
```bash
# 检查滚动状态（不会真正滚动）
GET /logs-current/_rollover
{
  "conditions": {
    "max_size": "5gb",
    "max_age": "7d"
  }
}
```

**返回结果解读**：
```json
{
  "old_index": "logs-000001",
  "new_index": "logs-000002", 
  "rolled_over": false,  // 是否需要滚动
  "dry_run": true,       // 仅检查，未实际执行
  "conditions": {
    "max_size": "5gb",
    "[max_size] 当前大小": "2.1gb"  // 当前还不满足条件
  }
}
```

### 2.3 多条件滚动配置


**🔸 组合条件滚动**
```bash
POST /logs-write/_rollover
{
  "conditions": {
    "max_age": "30d",      // 30天后滚动
    "max_size": "50gb",    // 50GB后滚动  
    "max_docs": 50000000   // 5000万文档后滚动
  },
  "mappings": {
    "properties": {
      "timestamp": {"type": "date"},
      "message": {"type": "text"}
    }
  }
}
```

**条件优先级**：
- 任何一个条件满足就会滚动
- **时间条件**通常优先级最高
- **大小条件**防止单个索引过大
- **文档数量**控制搜索性能

---

## 3. 🏷️ 别名滚动管理


### 3.1 别名滚动原理


**别名滚动流程图**：
```
步骤1：检查当前别名指向
logs-write → logs-000001

步骤2：创建新索引  
logs-000002（新建）

步骤3：更新别名指向
logs-write → logs-000002（更新指向）

步骤4：应用程序无感知
应用继续写入 logs-write（别名不变）
```

### 3.2 别名滚动命令


**🔸 通过别名执行滚动**
```bash
# 使用别名进行滚动
POST /logs-write/_rollover
{
  "conditions": {
    "max_size": "10gb"
  },
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1
  }
}
```

**别名滚动优势**：
- ✅ **应用无感知**：应用程序继续使用别名
- ✅ **自动切换**：ES自动更新别名指向
- ✅ **配置继承**：新索引继承设置和映射

### 3.3 查看滚动别名状态


**🔸 查看所有别名信息**
```bash
# 查看别名详细信息
GET /_cat/aliases?v&s=alias

# 输出示例：
alias      index        filter routing.index routing.search is_write_index
logs-write logs-000003  -      -             -              true
logs-read  logs-000001  -      -             -              false  
logs-read  logs-000002  -      -             -              false
logs-read  logs-000003  -      -             -              false
```

**字段说明**：
- `is_write_index: true`：当前写入索引
- `logs-read`：读取别名，指向所有历史索引
- `logs-write`：写入别名，只指向当前索引

---

## 4. 📋 滚动模板配置


### 4.1 滚动索引模板


**🔸 创建滚动模板**
```bash
PUT /_template/logs-rollover-template
{
  "index_patterns": ["logs-*"],
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "index.lifecycle.name": "logs-policy",
    "index.lifecycle.rollover_alias": "logs-write"
  },
  "mappings": {
    "properties": {
      "@timestamp": {
        "type": "date",
        "format": "strict_date_optional_time||epoch_millis"
      },
      "level": {"type": "keyword"},
      "message": {"type": "text"},
      "service": {"type": "keyword"}
    }
  },
  "aliases": {
    "logs-write": {
      "is_write_index": true
    },
    "logs-read": {}
  }
}
```

**模板配置要点**：

| 配置项 | 作用说明 | 示例值 |
|-------|----------|---------|
| `index_patterns` | 匹配索引命名规则 | `["logs-*"]` |
| `rollover_alias` | 滚动使用的别名 | `"logs-write"` |
| `is_write_index` | 标记为写入索引 | `true` |
| `lifecycle.name` | 生命周期策略名 | `"logs-policy"` |

### 4.2 初始化滚动索引


**🔸 创建第一个滚动索引**
```bash
# 创建初始索引并设置别名
PUT /logs-000001
{
  "aliases": {
    "logs-write": {
      "is_write_index": true
    },
    "logs-read": {}
  }
}
```

**初始化步骤**：
```
步骤 ①：创建模板（定义规则）
步骤 ②：创建第一个索引（logs-000001）
步骤 ③：设置写入别名（logs-write）
步骤 ④：开始数据写入
步骤 ⑤：满足条件时自动滚动
```

---

## 5. 🔧 索引分割与收缩


### 5.1 索引收缩操作


**💡 什么是索引收缩**：把大索引变成小索引，就像把大房子改成小房子

**🔸 索引收缩命令**
```bash
# 第一步：设置索引为只读
PUT /large-index/_settings
{
  "settings": {
    "index.blocks.write": true
  }
}

# 第二步：执行收缩操作
POST /large-index/_shrink/small-index
{
  "settings": {
    "index.number_of_shards": 1,
    "index.blocks.write": null
  }
}
```

**收缩条件限制**：
- ✅ 目标分片数必须是源分片数的因子
- ✅ 源索引必须是只读状态
- ✅ 源索引必须是绿色健康状态
- ⚠️ 收缩过程中会占用额外磁盘空间

### 5.2 索引分割操作


**💡 什么是索引分割**：把小索引变成大索引，就像把小房子扩建成大房子

**🔸 索引分割命令**
```bash
# 第一步：设置索引为只读
PUT /small-index/_settings
{
  "settings": {
    "index.blocks.write": true
  }
}

# 第二步：执行分割操作
POST /small-index/_split/large-index
{
  "settings": {
    "index.number_of_shards": 6
  }
}
```

**分割条件限制**：
- ✅ 目标分片数必须是源分片数的倍数
- ✅ 源索引必须是只读状态
- ✅ 目标分片数不能超过 1024
- ⚠️ 分割不会改变数据分布，只是逻辑分割

### 5.3 收缩与分割对比


| 操作类型 | **使用场景** | **分片变化** | **性能影响** |
|---------|-------------|-------------|-------------|
| 🔸 **收缩** | `索引数据量减少` | `多分片→少分片` | `提高查询效率` |
| 🔸 **分割** | `索引数据量增加` | `少分片→多分片` | `提高写入性能` |

---

## 6. 🚀 实际应用场景


### 6.1 日志管理场景


**场景描述**：每天产生大量日志，需要按天滚动

```bash
# 日志滚动配置
POST /logs-write/_rollover
{
  "conditions": {
    "max_age": "1d",       // 每天滚动
    "max_size": "10gb"     // 或者10GB时滚动
  }
}
```

**滚动结果**：
```
logs-2024-01-01  ← 1月1日的日志
logs-2024-01-02  ← 1月2日的日志  
logs-2024-01-03  ← 1月3日的日志（当前写入）
```

### 6.2 监控数据场景


**场景描述**：监控指标数据，按大小滚动

```bash
# 监控数据滚动
POST /metrics-write/_rollover
{
  "conditions": {
    "max_size": "5gb",     // 5GB滚动
    "max_docs": 50000000   // 或5000万文档滚动
  }
}
```

### 6.3 滚动自动化管理


**使用ILM策略自动滚动**：
```bash
PUT /_ilm/policy/logs-policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "50gb",
            "max_age": "30d"
          }
        }
      },
      "delete": {
        "min_age": "90d",
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 索引滚动：自动创建新索引，保持旧索引不变
🔸 滚动条件：大小、时间、文档数量任一满足即滚动  
🔸 别名机制：应用程序通过别名访问，滚动对应用透明
🔸 模板配置：提前定义滚动规则和索引设置
🔸 收缩分割：根据实际需要调整索引分片数量
```

### 7.2 关键命令速记


| 操作类型 | **核心命令** | **使用场景** |
|---------|-------------|-------------|
| 🔄 **自动滚动** | `POST /{index}/_rollover` | `日常数据滚动` |
| 🎯 **指定滚动** | `PUT /{index}/_rollover/{new}` | `手动控制滚动` |
| 🔍 **滚动检查** | `GET /{index}/_rollover` | `检查滚动状态` |
| 📋 **别名查看** | `GET /_cat/aliases?v` | `查看别名状态` |
| 🔧 **索引收缩** | `POST /{index}/_shrink/{target}` | `减少分片数量` |
| 📈 **索引分割** | `POST /{index}/_split/{target}` | `增加分片数量` |

### 7.3 实际应用原则


**🔹 滚动策略选择**
```
时间敏感数据：优先使用时间条件（max_age）
大数据量：优先使用大小条件（max_size）  
高频写入：结合文档数量条件（max_docs）
```

**🔹 性能优化建议**
```
✅ 合理设置滚动条件，避免索引过大或过小
✅ 使用别名进行滚动，保证应用程序连续性
✅ 配置合适的分片数量，平衡查询和写入性能
✅ 结合ILM策略实现自动化管理
```

**🔹 常见问题避免**
```
❌ 不要频繁滚动，会产生过多小索引
❌ 不要设置过大的滚动条件，影响查询性能  
❌ 收缩分割前必须设置索引为只读状态
❌ 注意收缩分割的分片数量限制
```

**核心记忆**：
- 滚动管理是数据生命周期的重要环节
- 别名机制让滚动对应用程序透明
- 合理的滚动策略能显著提升集群性能
- 收缩分割是运维阶段的重要调优手段