---
title: 10、文档版本控制
---
## 📚 目录

1. [版本控制基本概念](#1-版本控制基本概念)
2. [内部版本控制机制](#2-内部版本控制机制)
3. [外部版本控制](#3-外部版本控制)
4. [序列号和主分片号控制](#4-序列号和主分片号控制)
5. [版本冲突处理](#5-版本冲突处理)
6. [创建操作控制](#6-创建操作控制)
7. [版本查询操作](#7-版本查询操作)
8. [实战应用场景](#8-实战应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 版本控制基本概念


### 1.1 什么是文档版本控制


**简单理解**：就像Word文档的版本历史一样，Elasticsearch会给每个文档分配一个版本号，每次修改都会增加版本号。

```
文档生命周期示例：
创建文档 → 版本1
第1次修改 → 版本2  
第2次修改 → 版本3
删除文档 → 版本4（标记删除）
```

### 1.2 为什么需要版本控制


**🎯 核心作用**：
- **防止数据覆盖** - 避免多人同时修改造成数据丢失
- **并发控制** - 确保数据一致性
- **冲突检测** - 发现并处理数据冲突
- **操作审计** - 跟踪文档变更历史

### 1.3 版本控制的工作原理


**基本机制**：
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  用户A读取  │    │  用户B读取  │    │   版本冲突   │
│  版本: 1    │    │  版本: 1    │    │   检测机制   │
└─────────────┘    └─────────────┘    └─────────────┘
        │                  │                  │
        ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  用户A修改  │    │  用户B修改  │    │  后修改者   │
│  版本: 2    │    │  版本冲突!  │    │  操作失败   │
└─────────────┘    └─────────────┘    └─────────────┘
```

---

## 2. ⚙️ 内部版本控制机制


### 2.1 内部版本号基础


**内部版本**：Elasticsearch自动维护的版本号，从1开始递增。

### 2.2 使用内部版本进行更新


**🔧 基本语法**：
```http
PUT /{index}/_doc/{id}?version={version}
```

**📝 实际操作示例**：

```bash
# 1. 创建一个文档
PUT /products/_doc/1
{
  "name": "iPhone 15",
  "price": 999,
  "stock": 100
}

# 返回结果包含版本信息
{
  "_index": "products",
  "_id": "1",
  "_version": 1,        # 版本号为1
  "result": "created"
}
```

```bash
# 2. 指定版本号进行更新（成功情况）
PUT /products/_doc/1?version=1
{
  "name": "iPhone 15 Pro",
  "price": 1099,
  "stock": 90
}

# 更新成功，版本号变为2
{
  "_index": "products",
  "_id": "1", 
  "_version": 2,        # 版本号递增
  "result": "updated"
}
```

```bash
# 3. 使用错误版本号更新（失败情况）
PUT /products/_doc/1?version=1
{
  "name": "iPhone 15 Max",
  "price": 1199
}

# 返回版本冲突错误
{
  "error": {
    "type": "version_conflict_engine_exception",
    "reason": "[1]: version conflict, current version [2] is different than the one provided [1]"
  }
}
```

### 2.3 版本控制的核心特点


**✅ 重要特性**：
- **原子性操作** - 版本检查和更新在同一个原子操作中完成
- **自动递增** - 每次成功操作后版本号自动+1
- **严格检查** - 版本不匹配时操作立即失败

---

## 3. 🌐 外部版本控制


### 3.1 外部版本的概念


**什么是外部版本**：使用外部系统的版本号（如数据库的timestamp），而不是ES内部版本号。

### 3.2 外部版本控制命令


**🔧 基本语法**：
```http
PUT /{index}/_doc/{id}?version={external_version}&version_type=external
```

**📝 实际应用示例**：

```bash
# 使用时间戳作为外部版本
PUT /orders/_doc/1001?version=1640995200000&version_type=external
{
  "order_id": "ORD-2022-001",
  "customer": "张三",
  "amount": 299.9,
  "status": "pending"
}

# 成功创建，ES内部版本为1，但记录外部版本
{
  "_index": "orders",
  "_id": "1001",
  "_version": 1640995200000,    # 显示外部版本号
  "result": "created"
}
```

```bash
# 使用更大的外部版本号更新
PUT /orders/_doc/1001?version=1640995800000&version_type=external  
{
  "order_id": "ORD-2022-001",
  "customer": "张三", 
  "amount": 299.9,
  "status": "confirmed"
}

# 更新成功
{
  "_version": 1640995800000,    # 外部版本号更新
  "result": "updated"
}
```

### 3.3 外部版本的规则


**🎯 关键规则**：
- **必须递增** - 新的外部版本必须大于当前版本
- **不能回退** - 不允许使用更小的版本号
- **灵活性** - 可以使用任意数字作为版本（时间戳、序列号等）

| 对比项目 | **内部版本** | **外部版本** |
|---------|-------------|-------------|
| **版本来源** | `ES自动生成` | `外部系统提供` |
| **起始值** | `1` | `任意数值` |
| **递增规则** | `自动+1` | `必须手动确保递增` |
| **适用场景** | `ES内部管理` | `多系统数据同步` |

---

## 4. 🔢 序列号和主分片号控制


### 4.1 序列号机制介绍


**序列号（Sequence Number）**：ES 6.0+引入的更精确的版本控制机制，解决了分布式环境下的一致性问题。

**主分片号（Primary Term）**：标识主分片的"任期"，每次主分片选举后递增。

### 4.2 序列号控制语法


**🔧 基本语法**：
```http
PUT /{index}/_doc/{id}?if_seq_no={seq_no}&if_primary_term={primary_term}
```

**📝 完整操作流程**：

```bash
# 1. 先获取文档的序列号信息
GET /products/_doc/1

# 返回结果包含序列号信息
{
  "_index": "products",
  "_id": "1",
  "_version": 2,
  "_seq_no": 5,           # 序列号
  "_primary_term": 1,     # 主分片号
  "_source": {
    "name": "iPhone 15 Pro",
    "price": 1099
  }
}
```

```bash
# 2. 使用序列号进行精确控制更新
PUT /products/_doc/1?if_seq_no=5&if_primary_term=1
{
  "name": "iPhone 15 Pro Max",
  "price": 1199,
  "stock": 85
}

# 更新成功，序列号自动递增
{
  "_index": "products", 
  "_id": "1",
  "_version": 3,
  "_seq_no": 6,           # 序列号递增
  "_primary_term": 1,
  "result": "updated"
}
```

### 4.3 序列号 vs 版本号对比


```
版本号机制：           序列号机制：
文档级别 ────────────→ 分片级别
简单递增 ────────────→ 全局排序
重建索引会重置 ─────→ 持续递增
分布式不够精确 ─────→ 分布式精确控制
```

| 特性 | **版本号** | **序列号+主分片号** |
|-----|-----------|-------------------|
| **粒度** | `文档级别` | `分片级别` |
| **重建索引** | `重置为1` | `持续递增` |
| **分布式一致性** | `基本保证` | `强一致性保证` |
| **推荐使用** | `简单场景` | `复杂分布式场景` |

---

## 5. ⚡ 版本冲突处理


### 5.1 冲突重试机制


**自动重试语法**：
```http
POST /{index}/_update/{id}?retry_on_conflict={retry_count}
```

**📝 冲突重试示例**：

```bash
# 使用update API进行冲突重试
POST /products/_update/1?retry_on_conflict=3
{
  "script": {
    "source": "ctx._source.stock -= params.quantity",
    "params": {
      "quantity": 5
    }
  }
}

# 如果发生冲突，ES会自动重试最多3次
```

### 5.2 冲突处理策略


**🎯 常见处理方式**：

```bash
# 方式1：忽略冲突，静默失败
PUT /products/_doc/1?version=1&version_type=internal
{
  "name": "新产品名"
}
# 冲突时返回错误，需要应用层处理

# 方式2：使用upsert避免冲突
POST /products/_update/1
{
  "doc": {
    "name": "新产品名",
    "price": 999
  },
  "upsert": {
    "name": "新产品名", 
    "price": 999,
    "stock": 0
  }
}
# 文档存在则更新，不存在则创建
```

### 5.3 冲突场景分析


```
高并发购物车场景：

用户A: 读取商品库存(100) → 准备购买5个
用户B: 读取商品库存(100) → 准备购买3个
        ↓
用户A: 提交订单，库存变为95 (版本2)
用户B: 提交订单，发现版本冲突！
        ↓
系统: 重新读取最新库存(95) → 重新计算 → 提交成功(92)
```

---

## 6. 🆕 创建操作控制


### 6.1 仅创建操作


**防止覆盖已存在文档**的两种方式：

**方式1：使用 `_create` 端点**
```http
POST /{index}/_doc/{id}/_create
```

**方式2：使用 `op_type=create` 参数**
```http
PUT /{index}/_doc/{id}?op_type=create
```

### 6.2 创建控制实战


**📝 实际操作对比**：

```bash
# 1. 普通创建（可能覆盖）
PUT /users/_doc/user001
{
  "username": "张三",
  "email": "zhangsan@example.com",
  "status": "active"
}
# 如果user001已存在，会被覆盖

# 2. 安全创建（不会覆盖）
POST /users/_doc/user001/_create
{
  "username": "李四", 
  "email": "lisi@example.com",
  "status": "active"
}
# 如果user001已存在，返回冲突错误

# 3. 使用op_type参数
PUT /users/_doc/user002?op_type=create
{
  "username": "王五",
  "email": "wangwu@example.com" 
}
# 等同于方式2的效果
```

**🔍 返回结果对比**：

```bash
# 创建成功时：
{
  "_index": "users",
  "_id": "user001", 
  "_version": 1,
  "result": "created"     # 注意是created
}

# 文档已存在时：
{
  "error": {
    "type": "version_conflict_engine_exception",
    "reason": "[user001]: version conflict, document already exists"
  }
}
```

---

## 7. 🔍 版本查询操作


### 7.1 获取版本信息


**查询文档版本的几种方式**：

```bash
# 方式1：普通查询（包含版本信息）
GET /products/_doc/1

# 方式2：仅获取版本信息
GET /products/_doc/1?version=true

# 方式3：获取详细元数据
GET /products/_doc/1?_source=false
```

### 7.2 版本信息详解


**📊 完整的版本相关字段**：

```bash
GET /products/_doc/1

# 返回的版本相关信息
{
  "_index": "products",
  "_id": "1",
  "_version": 3,          # 文档版本号  
  "_seq_no": 8,           # 序列号
  "_primary_term": 1,     # 主分片号
  "found": true,
  "_source": {
    "name": "iPhone 15 Pro Max",
    "price": 1199
  }
}
```

### 7.3 批量版本查询


**批量获取多个文档的版本信息**：

```bash
# 使用mget批量查询
GET /_mget
{
  "docs": [
    {
      "_index": "products",
      "_id": "1"
    },
    {
      "_index": "products", 
      "_id": "2"
    }
  ]
}

# 返回每个文档的版本信息
{
  "docs": [
    {
      "_index": "products",
      "_id": "1", 
      "_version": 3,
      "_seq_no": 8,
      "_primary_term": 1,
      "found": true,
      "_source": {...}
    },
    {
      "_index": "products",
      "_id": "2",
      "_version": 1, 
      "_seq_no": 9,
      "_primary_term": 1,
      "found": true,
      "_source": {...}
    }
  ]
}
```

---

## 8. 🚀 实战应用场景


### 8.1 电商库存管理


**场景描述**：防止超卖，确保库存数据准确性。

```bash
# 1. 查询当前库存
GET /products/_doc/iphone15
{
  "_version": 5,
  "_source": {
    "name": "iPhone 15",
    "stock": 10
  }
}

# 2. 安全减库存（防止超卖）
POST /products/_update/iphone15?retry_on_conflict=3
{
  "script": {
    "source": """
      if (ctx._source.stock >= params.quantity) {
        ctx._source.stock -= params.quantity;
        ctx._source.last_updated = params.timestamp;
      } else {
        ctx.op = 'none';
      }
    """,
    "params": {
      "quantity": 2,
      "timestamp": "2024-12-23T10:30:00Z"
    }
  }
}
```

### 8.2 用户信息同步


**场景描述**：多系统间用户信息同步，避免数据不一致。

```bash
# 使用外部版本同步用户数据
PUT /users/_doc/user123?version=1703334600000&version_type=external
{
  "username": "zhangsan",
  "email": "zhangsan@example.com", 
  "profile": {
    "age": 28,
    "city": "北京"
  },
  "last_updated": 1703334600000
}

# 从其他系统更新数据时，确保时间戳更大
PUT /users/_doc/user123?version=1703334900000&version_type=external
{
  "username": "zhangsan",
  "email": "zhangsan@example.com",
  "profile": {
    "age": 28, 
    "city": "上海"     # 城市信息更新
  },
  "last_updated": 1703334900000
}
```

### 8.3 文档协作编辑


**场景描述**：多人协作编辑文档，防止互相覆盖。

```bash
# 编辑者A获取文档
GET /documents/_doc/doc001
{
  "_version": 3,
  "_seq_no": 15,
  "_primary_term": 1,
  "_source": {
    "title": "项目计划书",
    "content": "原始内容...",
    "last_editor": "admin"
  }
}

# 编辑者A提交修改
PUT /documents/_doc/doc001?if_seq_no=15&if_primary_term=1
{
  "title": "项目计划书v2",
  "content": "修改后的内容...",
  "last_editor": "zhangsan",
  "edit_time": "2024-12-23T10:30:00Z"
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 版本控制本质：防止数据覆盖，确保并发安全
🔸 内部版本：ES自动维护，从1开始递增  
🔸 外部版本：使用外部系统版本号，必须递增
🔸 序列号机制：更精确的分布式版本控制
🔸 冲突处理：重试机制和错误处理策略
🔸 创建控制：防止意外覆盖已存在文档
```

### 9.2 关键命令速查


| 操作类型 | **命令格式** | **适用场景** |
|---------|-------------|-------------|
| **内部版本更新** | `PUT /index/_doc/id?version=N` | `基础版本控制` |
| **外部版本更新** | `PUT /index/_doc/id?version=N&version_type=external` | `多系统同步` |
| **序列号控制** | `PUT /index/_doc/id?if_seq_no=N&if_primary_term=N` | `精确控制` |
| **冲突重试** | `POST /index/_update/id?retry_on_conflict=N` | `高并发场景` |
| **仅创建** | `POST /index/_doc/id/_create` | `防止覆盖` |
| **版本查询** | `GET /index/_doc/id` | `获取版本信息` |

### 9.3 实际应用建议


**🎯 选择合适的版本控制方式**：

- **简单应用** → 使用内部版本控制
- **多系统集成** → 使用外部版本控制  
- **高并发场景** → 结合重试机制
- **精确控制** → 使用序列号机制
- **防止覆盖** → 使用创建操作控制

### 9.4 常见问题与解决


**⚠️ 注意事项**：

- **版本冲突不是错误** - 是数据安全的保护机制
- **重试次数要合理** - 太少可能失败，太多影响性能
- **外部版本必须递增** - 不能使用相同或更小的版本号
- **删除后版本不会重置** - 即使文档被删除，版本号会继续递增

**🔧 最佳实践**：
- 在高并发场景下优先使用update API + retry机制
- 多系统数据同步时使用外部版本控制
- 重要业务场景建议使用序列号机制
- 定期监控版本冲突频率，优化并发策略

**核心记忆**：版本控制是Elasticsearch确保数据安全和一致性的重要机制，选择合适的版本控制策略是构建可靠系统的关键。