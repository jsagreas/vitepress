---
title: 2、度量聚合详解
---
## 📚 目录

1. [度量聚合基础概念](#1-度量聚合基础概念)
2. [基础度量聚合](#2-基础度量聚合)
3. [统计类聚合](#3-统计类聚合)
4. [高级度量聚合](#4-高级度量聚合)
5. [脚本聚合](#5-脚本聚合)
6. [度量聚合组合使用](#6-度量聚合组合使用)
7. [性能优化技巧](#7-性能优化技巧)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 度量聚合基础概念


### 1.1 什么是度量聚合

🔍 **简单理解**：度量聚合就像对数据做"计算题"

```
生活中的类比：
考试成绩统计 → 计算平均分、最高分、最低分
销售数据分析 → 计算总销售额、平均客单价
网站访问统计 → 计算平均访问时长、最大并发数

Elasticsearch度量聚合：
对搜索结果中的数值字段进行数学运算
得到汇总的统计信息
```

**🔸 度量聚合的核心价值**
```
数据洞察：
- 快速了解数据分布情况
- 发现数据中的极值和趋势
- 为业务决策提供数据支撑

性能优势：
- 在搜索引擎层面完成计算
- 避免将大量数据传输到应用层
- 充分利用ES的分布式计算能力
```

### 1.2 度量聚合的工作原理

**⚙️ 聚合计算过程**

```
数据处理流程：
1. 查询阶段 → 筛选出符合条件的文档
2. 聚合阶段 → 对指定字段进行统计计算
3. 返回结果 → 包含聚合结果的响应

分布式计算：
各个分片独立计算 → 协调节点汇总结果 → 返回最终统计值
```

**📊 度量聚合分类概览**

| 聚合类型 | **主要作用** | **典型应用** | **返回值类型** |
|---------|-------------|-------------|---------------|
| 🔸 **基础度量** | `单一数值计算` | `求和、平均值` | `单个数值` |
| 🔸 **统计聚合** | `多指标计算` | `完整统计信息` | `统计对象` |
| 🔸 **分位数聚合** | `分布分析` | `性能监控` | `百分位数组` |
| 🔸 **基数聚合** | `唯一值统计` | `去重计数` | `近似数值` |
| 🔸 **脚本聚合** | `自定义计算` | `复杂业务逻辑` | `自定义结果` |

### 1.3 度量聚合的数据类型要求

**📋 支持的字段类型**

```
数值型字段：
- integer, long, float, double → 最常用的聚合字段
- 支持所有数学运算聚合

日期型字段：
- date → 可以进行时间范围统计
- 支持日期间隔计算

关键词字段：
- keyword → 主要用于基数聚合（去重统计）
- 不支持数学运算聚合

注意事项：
- text字段默认不支持聚合
- 需要启用fielddata或使用keyword子字段
```

---

## 2. 📊 基础度量聚合


### 2.1 Avg 平均值聚合

🎯 **用途**：计算数值字段的平均值

**实际应用场景**
```
电商场景：
- 计算商品的平均价格
- 统计用户平均消费金额
- 分析平均订单配送时间

监控场景：
- 计算系统平均响应时间
- 统计服务器平均CPU使用率
- 分析平均内存占用情况
```

**基础用法示例**
```json
GET /products/_search
{
  "size": 0,
  "aggs": {
    "avg_price": {
      "avg": {
        "field": "price"
      }
    }
  }
}
```

**💡 带查询条件的平均值计算**
```json
GET /orders/_search
{
  "query": {
    "range": {
      "order_date": {
        "gte": "2024-01-01",
        "lte": "2024-12-31"
      }
    }
  },
  "size": 0,
  "aggs": {
    "avg_order_amount": {
      "avg": {
        "field": "total_amount"
      }
    }
  }
}
```

### 2.2 Max/Min 最值聚合

📈 **用途**：查找数值字段的最大值和最小值

**实际业务价值**
```
业务监控：
- 找出最高/最低销售额
- 监控系统峰值性能指标
- 识别异常数据范围

质量控制：
- 检查数据边界值
- 验证数据完整性
- 发现潜在的数据问题
```

**同时计算最大值和最小值**
```json
GET /sales/_search
{
  "size": 0,
  "aggs": {
    "max_revenue": {
      "max": {
        "field": "daily_revenue"
      }
    },
    "min_revenue": {
      "min": {
        "field": "daily_revenue"
      }
    }
  }
}
```

### 2.3 Sum 求和聚合

💰 **用途**：计算数值字段的总和

**典型应用场景**
```
财务统计：
- 计算总销售额
- 统计总支出金额
- 汇总各部门预算

资源统计：
- 计算总存储使用量
- 统计总流量消耗
- 汇总系统资源占用
```

**求和聚合实例**
```json
GET /transactions/_search
{
  "query": {
    "term": {
      "status": "completed"
    }
  },
  "size": 0,
  "aggs": {
    "total_amount": {
      "sum": {
        "field": "amount"
      }
    }
  }
}
```

### 2.4 Value_count 计数聚合

🔢 **用途**：统计包含特定字段值的文档数量

**与文档计数的区别**
```
文档计数：
- 统计匹配查询条件的文档总数
- 使用 _count API 或查询结果中的 hits.total

字段值计数：
- 统计具有非空字段值的文档数
- 排除字段值为null的文档
- 用于数据完整性检查
```

**字段值计数示例**
```json
GET /users/_search
{
  "size": 0,
  "aggs": {
    "users_with_email": {
      "value_count": {
        "field": "email"
      }
    },
    "users_with_phone": {
      "value_count": {
        "field": "phone_number"
      }
    }
  }
}
```

---

## 3. 📈 统计类聚合


### 3.1 Stats 统计聚合

📊 **用途**：一次性获取字段的完整基础统计信息

**包含的统计指标**
```
基础统计五要素：
- count：有效值数量
- min：最小值
- max：最大值  
- avg：平均值
- sum：总和

相当于同时执行：
value_count + min + max + avg + sum 五个聚合
```

**统计聚合实例**
```json
GET /products/_search
{
  "size": 0,
  "aggs": {
    "price_stats": {
      "stats": {
        "field": "price"
      }
    }
  }
}
```

**返回结果示例**
```json
{
  "aggregations": {
    "price_stats": {
      "count": 1000,
      "min": 9.99,
      "max": 999.99,
      "avg": 156.78,
      "sum": 156780.50
    }
  }
}
```

### 3.2 Extended_stats 扩展统计

🔍 **用途**：获取更详细的统计信息，包括方差和标准差

**扩展统计指标**
```
基础统计 + 高级指标：
- sum_of_squares：平方和
- variance：方差  
- std_deviation：标准差
- std_deviation_bounds：标准差边界

业务应用价值：
- 数据分散程度分析
- 异常值检测
- 质量控制标准制定
```

**扩展统计示例**
```json
GET /response_times/_search
{
  "size": 0,
  "aggs": {
    "response_time_stats": {
      "extended_stats": {
        "field": "response_time_ms"
      }
    }
  }
}
```

**🔍 标准差的实际意义**
```
标准差应用场景：

服务质量监控：
- 响应时间标准差小 → 服务稳定
- 响应时间标准差大 → 性能不稳定

销售数据分析：
- 销售额标准差小 → 业绩稳定
- 销售额标准差大 → 波动较大

异常检测：
- 超出2个标准差的数据 → 可能异常
- 可用于自动告警阈值设置
```

---

## 4. 🎨 高级度量聚合


### 4.1 Cardinality 基数聚合

🔢 **用途**：统计字段中唯一值的数量（类似SQL的COUNT DISTINCT）

**基数聚合的实际应用**
```
用户行为分析：
- 统计独立访客数量（UV）
- 计算活跃用户数
- 分析用户留存情况

商品数据分析：
- 统计商品品牌数量
- 计算商品分类数量
- 分析SKU数量分布
```

**基数聚合示例**
```json
GET /website_logs/_search
{
  "query": {
    "range": {
      "timestamp": {
        "gte": "2024-01-01",
        "lte": "2024-01-31"
      }
    }
  },
  "size": 0,
  "aggs": {
    "unique_visitors": {
      "cardinality": {
        "field": "user_id"
      }
    },
    "unique_ips": {
      "cardinality": {
        "field": "ip_address"
      }
    }
  }
}
```

**⚠️ 基数聚合的精度说明**
```
HyperLogLog算法：
- ES使用HyperLogLog算法进行基数估算
- 在大数据量下提供快速的近似结果
- 默认精度阈值：3000（约2%误差）

精度控制：
"cardinality": {
  "field": "user_id",
  "precision_threshold": 10000  // 提高精度阈值
}

注意事项：
- 小数据量（<阈值）：精确计算
- 大数据量（>阈值）：近似计算
- 精度阈值越高，内存消耗越大
```

### 4.2 Percentiles 百分位聚合

📊 **用途**：计算数据分布的百分位数

**百分位数的业务意义**
```
性能监控：
- P50（中位数）：50%请求的响应时间
- P90：90%请求都在此时间内完成
- P99：99%请求的响应时间上限

SLA制定：
- 基于P95或P99设置服务水平协议
- 更合理的性能基准
- 避免被极值影响
```

**百分位聚合示例**
```json
GET /api_logs/_search
{
  "size": 0,
  "aggs": {
    "response_time_percentiles": {
      "percentiles": {
        "field": "response_time",
        "percents": [50, 90, 95, 99]
      }
    }
  }
}
```

**返回结果解读**
```json
{
  "aggregations": {
    "response_time_percentiles": {
      "values": {
        "50.0": 245.3,    // 50%的请求在245ms内完成
        "90.0": 892.1,    // 90%的请求在892ms内完成
        "95.0": 1204.7,   // 95%的请求在1204ms内完成
        "99.0": 2156.4    // 99%的请求在2156ms内完成
      }
    }
  }
}
```

### 4.3 Percentile_ranks 百分位排名

📈 **用途**：查询特定数值在数据分布中的排名位置

**百分位排名的应用**
```
竞品分析：
- 我们的价格在市场中的位置
- 产品性能的相对排名
- 服务质量的行业对比

个人表现评估：
- 学生成绩在班级中的排名
- 员工绩效的相对位置
- 用户活跃度的百分位
```

**百分位排名示例**
```json
GET /student_scores/_search
{
  "size": 0,
  "aggs": {
    "score_ranks": {
      "percentile_ranks": {
        "field": "math_score",
        "values": [80, 90, 95]
      }
    }
  }
}
```

### 4.4 Top_hits 顶部文档

🏆 **用途**：获取聚合分组中的具体文档内容

**Top_hits的独特价值**
```
具体案例获取：
- 每个分类下的热门商品
- 每个地区的优秀销售代表
- 每个时间段的典型事件

与其他聚合配合：
- 先分组聚合，再获取每组的代表文档
- 结合排序获取最优/最劣案例
- 提供聚合结果的具体证据
```

**Top_hits聚合示例**
```json
GET /sales/_search
{
  "size": 0,
  "aggs": {
    "sales_by_region": {
      "terms": {
        "field": "region"
      },
      "aggs": {
        "top_sales": {
          "top_hits": {
            "sort": [
              {
                "amount": {
                  "order": "desc"
                }
              }
            ],
            "size": 3,
            "_source": ["salesperson", "amount", "product"]
          }
        }
      }
    }
  }
}
```

---

## 5. 🔧 脚本聚合


### 5.1 Scripted_metric 脚本聚合

💻 **用途**：实现自定义的复杂聚合逻辑

**脚本聚合的四个阶段**
```
聚合执行阶段：

1. init_script（初始化）
   → 为每个分片初始化聚合状态

2. map_script（映射）  
   → 对每个文档执行操作

3. combine_script（合并）
   → 合并单个分片的结果

4. reduce_script（归约）
   → 合并所有分片的最终结果
```

**实际应用场景**
```
复杂业务指标：
- 计算加权平均值
- 自定义评分算法
- 复合指标计算

数据转换：
- 字段值的复杂运算
- 条件性统计逻辑
- 多字段联合计算
```

**脚本聚合示例：计算加权平均价格**
```json
GET /products/_search
{
  "size": 0,
  "aggs": {
    "weighted_avg_price": {
      "scripted_metric": {
        "init_script": "state.prices = []; state.weights = []",
        "map_script": "state.prices.add(doc['price'].value); state.weights.add(doc['quantity'].value)",
        "combine_script": "double totalPrice = 0; double totalWeight = 0; for (int i = 0; i < state.prices.size(); i++) { totalPrice += state.prices[i] * state.weights[i]; totalWeight += state.weights[i]; } return totalWeight > 0 ? totalPrice / totalWeight : 0",
        "reduce_script": "double totalWeightedPrice = 0; double totalWeight = 0; for (result in states) { if (result instanceof Map) { totalWeightedPrice += result.weightedPrice; totalWeight += result.weight; } else { totalWeightedPrice += result; totalWeight += 1; } } return totalWeight > 0 ? totalWeightedPrice / totalWeight : 0"
      }
    }
  }
}
```

**🔍 脚本性能优化建议**
```
性能优化策略：

1. 使用存储脚本
   → 预编译脚本，提高执行效率
   → 避免重复编译开销

2. 简化脚本逻辑
   → 减少复杂计算
   → 优先使用内置聚合

3. 限制脚本使用范围
   → 在必要时才使用脚本聚合
   → 考虑数据预处理替代方案

脚本安全设置：
script.allowed_types: inline
script.allowed_contexts: aggregation
```

---

## 6. 🔗 度量聚合组合使用


### 6.1 多重度量聚合

📊 **同时计算多个度量指标**

**组合聚合的业务价值**
```
全面数据分析：
- 一次查询获取完整统计画像
- 减少网络请求次数
- 提高数据分析效率

决策支持：
- 多维度评估业务状况
- 对比不同指标的表现
- 发现指标间的关联关系
```

**多重度量聚合示例**
```json
GET /orders/_search
{
  "query": {
    "range": {
      "order_date": {
        "gte": "2024-01-01"
      }
    }
  },
  "size": 0,
  "aggs": {
    "order_analytics": {
      "stats": {
        "field": "total_amount"
      }
    },
    "unique_customers": {
      "cardinality": {
        "field": "customer_id"
      }
    },
    "amount_percentiles": {
      "percentiles": {
        "field": "total_amount",
        "percents": [25, 50, 75, 90]
      }
    },
    "top_orders": {
      "top_hits": {
        "sort": [{"total_amount": {"order": "desc"}}],
        "size": 5,
        "_source": ["customer_name", "total_amount", "order_date"]
      }
    }
  }
}
```

### 6.2 嵌套聚合中的度量

🎯 **在桶聚合基础上计算度量**

**嵌套聚合的分析价值**
```
分组统计分析：
- 每个分组的统计特征
- 不同组别的对比分析
- 发现群体差异和特点

业务场景应用：
- 各地区的销售统计
- 不同时间段的性能指标
- 各产品类别的用户行为
```

**按类别分组的价格统计**
```json
GET /products/_search
{
  "size": 0,
  "aggs": {
    "categories": {
      "terms": {
        "field": "category",
        "size": 10
      },
      "aggs": {
        "price_stats": {
          "stats": {
            "field": "price"
          }
        },
        "price_distribution": {
          "histogram": {
            "field": "price",
            "interval": 100
          }
        }
      }
    }
  }
}
```

### 6.3 条件聚合

🎯 **基于条件过滤的度量计算**

**条件聚合的应用场景**
```
对比分析：
- 正常用户 vs VIP用户的消费行为
- 工作日 vs 周末的系统负载
- 新产品 vs 经典产品的销售表现

精准统计：
- 特定条件下的数据指标
- 排除异常数据的统计
- 细分市场的分析
```

**使用filter聚合进行条件统计**
```json
GET /users/_search
{
  "size": 0,
  "aggs": {
    "vip_users": {
      "filter": {
        "term": {
          "user_type": "vip"
        }
      },
      "aggs": {
        "avg_order_amount": {
          "avg": {
            "field": "order_amount"
          }
        }
      }
    },
    "regular_users": {
      "filter": {
        "term": {
          "user_type": "regular"
        }
      },
      "aggs": {
        "avg_order_amount": {
          "avg": {
            "field": "order_amount"
          }
        }
      }
    }
  }
}
```

---

## 7. ⚡ 性能优化技巧


### 7.1 聚合性能优化策略

🚀 **提升聚合查询性能的方法**

**数据结构优化**
```
字段类型选择：
- 数值聚合优先使用 integer/long
- 避免在 text 字段上聚合
- 合理使用 keyword 字段

索引优化：
- 为聚合字段建立合适的映射
- 启用 doc_values（默认开启）
- 考虑使用 eager_global_ordinals
```

**查询优化技巧**
```json
{
  "query": {
    "bool": {
      "filter": [  // 使用filter而非query
        {
          "range": {
            "timestamp": {
              "gte": "2024-01-01"
            }
          }
        }
      ]
    }
  },
  "size": 0,  // 不返回文档内容
  "aggs": {
    "sales_stats": {
      "stats": {
        "field": "amount"
      }
    }
  }
}
```

### 7.2 聚合缓存机制

💾 **利用ES缓存提升重复查询性能**

**缓存类型和作用**
```
查询缓存：
- 缓存整个查询结果
- 适用于重复的相同查询
- 自动管理缓存生命周期

聚合缓存：
- 缓存聚合计算结果
- 分片级别的缓存机制
- 提高重复聚合的性能
```

**缓存友好的查询设计**
```
缓存优化建议：

1. 使用固定的时间范围
   → 避免使用 "now" 这样的动态值
   → 使用具体的日期时间

2. 合理设置size参数
   → size=0 提高聚合查询性能
   → 只返回必要的聚合结果

3. 避免脚本聚合的过度使用
   → 脚本结果通常无法缓存
   → 优先使用内置聚合函数
```

### 7.3 大数据量聚合优化

📈 **处理大规模数据的聚合策略**

**分段处理策略**
```
时间分段聚合：
- 将大时间范围拆分为小段
- 并行处理多个时间段
- 在应用层合并结果

采样聚合：
- 对大数据集进行采样
- 基于样本数据进行快速估算
- 平衡精度和性能需求
```

**采样聚合示例**
```json
GET /large_dataset/_search
{
  "size": 0,
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 10000
      },
      "aggs": {
        "avg_price": {
          "avg": {
            "field": "price"
          }
        }
      }
    }
  }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 度量聚合本质：对数值字段进行数学运算和统计分析
🔸 基础度量：avg、max、min、sum、value_count - 日常使用最多
🔸 统计聚合：stats、extended_stats - 一次获取完整统计信息
🔸 高级度量：cardinality、percentiles、top_hits - 解决复杂分析需求
🔸 脚本聚合：scripted_metric - 实现自定义复杂逻辑
🔸 组合使用：多重聚合、嵌套聚合、条件聚合 - 提供全面分析视角
```

### 8.2 关键理解要点


**🔹 选择合适的聚合类型**
```
根据需求选择：
- 简单统计 → 使用基础度量聚合
- 完整统计 → 使用 stats 聚合
- 分布分析 → 使用 percentiles 聚合
- 去重统计 → 使用 cardinality 聚合
- 复杂逻辑 → 考虑脚本聚合

性能考虑：
- 优先使用内置聚合
- 避免过度使用脚本聚合
- 合理设计查询条件
```

**🔹 理解聚合的精度和限制**
```
精度认识：
- 基数聚合是近似算法
- 大数据量下可能有误差
- 可通过参数调整精度

限制理解：
- 聚合字段必须支持doc_values
- text字段需要特殊处理
- 深度嵌套影响性能
```

**🔹 聚合与业务结合**
```
数据洞察：
- 不仅仅是计算数字
- 要理解数字背后的业务含义
- 结合业务场景选择合适指标

决策支持：
- 基于数据制定业务策略
- 监控关键业务指标
- 发现业务优化机会
```

### 8.3 实际应用价值


**🎯 业务场景应用**
- **电商分析**：商品价格分布、用户消费行为、销售趋势统计
- **系统监控**：性能指标统计、异常检测、容量规划
- **用户分析**：活跃度统计、行为模式分析、用户画像构建
- **财务分析**：收入统计、成本分析、ROI计算

**🔧 技术实践建议**
- **渐进学习**：从基础聚合开始，逐步掌握高级功能
- **性能意识**：始终关注查询性能，合理设计聚合查询
- **业务思维**：将技术能力与业务需求有机结合
- **实战练习**：多在真实数据上练习，积累实践经验

**📈 发展方向**
- **机器学习集成**：结合ML算法进行更深度的数据分析
- **实时聚合**：掌握实时数据流的聚合处理
- **可视化结合**：将聚合结果与数据可视化工具结合
- **性能调优**：深入理解ES内部机制，进行针对性优化

**核心记忆要点**：
- 度量聚合像计算器，帮你算出数据的各种统计结果
- 基础聚合解决常见需求，高级聚合处理复杂场景
- 性能永远是关键考虑因素，合理设计比复杂功能更重要
- 技术服务业务，理解业务才能用好技术