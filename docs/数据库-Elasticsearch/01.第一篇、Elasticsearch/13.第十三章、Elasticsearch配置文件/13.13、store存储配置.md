---
title: 13、store存储配置
---
## 📚 目录

1. [存储配置概述](#1-存储配置概述)
2. [存储类型配置](#2-存储类型配置)
3. [索引缓冲区配置](#3-索引缓冲区配置)
4. [文件系统相关配置](#4-文件系统相关配置)
5. [分片管理配置](#5-分片管理配置)
6. [存储优化配置](#6-存储优化配置)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💾 存储配置概述


### 1.1 什么是存储配置


**📋 基本概念**
存储配置就是告诉Elasticsearch如何保存和管理数据的设置。想象一下，这就像是给Elasticsearch一本"存储说明书"，告诉它：
- 数据应该以什么格式保存
- 需要多少内存来处理数据
- 什么时候清理不用的文件

**🎯 为什么需要存储配置**
```
日常比喻：
就像整理房间一样，你需要决定：
• 书放在哪个书架（存储类型）
• 书桌要多大才够用（缓冲区大小）
• 多久整理一次房间（清理策略）

Elasticsearch也是如此：
• 数据存在哪种格式的文件里
• 分配多少内存来处理索引
• 什么时候删除不需要的分片
```

### 1.2 存储配置的核心作用


**🔸 性能影响**
- **读取速度**：合适的存储格式让查询更快
- **写入效率**：足够的缓冲区让数据写入更顺畅
- **磁盘使用**：合理的存储策略节省磁盘空间

**🔸 稳定性保障**
- **数据安全**：防止文件冲突和数据丢失
- **资源管理**：避免内存不足或磁盘满
- **自动清理**：及时删除无用的数据文件

---

## 2. 🗂️ 存储类型配置


### 2.1 index.store.type - 存储类型


**💡 参数含义**
这个参数决定Elasticsearch用什么方式来存储索引文件，就像选择用什么格式保存文档一样。

```yaml
# elasticsearch.yml 配置示例
index.store.type: "fs"
```

**📊 可选存储类型**

| 存储类型 | **说明** | **适用场景** | **特点** |
|---------|---------|-------------|---------|
| `fs` | **文件系统存储（默认）** | `生产环境` | `稳定可靠，支持各种文件系统` |
| `niofs` | **NIO文件系统** | `Linux/Unix环境` | `高并发读取性能好` |
| `mmapfs` | **内存映射文件** | `大内存服务器` | `利用系统内存加速访问` |

**🔧 选择建议**
```
选择原则：
✅ 一般情况：使用默认的 fs 即可
✅ Linux服务器且并发高：考虑 niofs
✅ 内存充足且数据量大：可选 mmapfs

⚠️ 注意事项：
• Windows系统建议使用默认 fs
• 内存不足时避免使用 mmapfs
• 生产环境变更前要充分测试
```

### 2.2 index.compound_format - 复合文件格式


**💭 通俗解释**
这个设置决定是否把索引的多个小文件合并成一个大文件，就像把散装的文件打包成压缩包一样。

```yaml
# 启用复合文件格式
index.compound_format: true

# 或者设置阈值（当分片大小超过这个值时不使用复合格式）
index.compound_format: "100mb"
```

**⚖️ 优缺点对比**

```
启用复合格式 (true)：
✅ 减少文件数量，降低文件句柄使用
✅ 提高小分片的查询性能
❌ 合并和拆分需要额外开销

禁用复合格式 (false)：
✅ 大分片查询性能更好
✅ 索引速度稍快
❌ 产生更多小文件
```

---

## 3. 💻 索引缓冲区配置


### 3.1 indices.memory.index_buffer_size - 索引缓冲区大小


**🎯 参数作用**
控制用于索引操作的内存缓冲区大小。这就像给Elasticsearch一个"工作台"，工作台越大，处理索引的效率越高。

```yaml
# 设置为总内存的百分比（推荐）
indices.memory.index_buffer_size: "10%"

# 或设置固定大小
indices.memory.index_buffer_size: "512mb"
```

**📈 大小设置指导**

```
内存配置建议：

小型集群（< 8GB 堆内存）：
• 设置 5-10% 即可
• 例如：indices.memory.index_buffer_size: "5%"

中型集群（8-32GB 堆内存）：
• 设置 10-15%
• 例如：indices.memory.index_buffer_size: "10%"

大型集群（> 32GB 堆内存）：
• 可设置 15-20%
• 例如：indices.memory.index_buffer_size: "15%"

⚠️ 重要提醒：
• 不要设置超过总内存的 20%
• 写入量大的场景可以适当提高
• 搜索为主的场景可以适当降低
```

### 3.2 最小和最大缓冲区限制


**🔸 indices.memory.min_index_buffer_size**
```yaml
# 设置最小缓冲区（防止缓冲区太小）
indices.memory.min_index_buffer_size: "48mb"
```

**🔸 indices.memory.max_index_buffer_size**
```yaml
# 设置最大缓冲区（防止缓冲区过大）
indices.memory.max_index_buffer_size: "1gb"
```

**💡 实际应用场景**
```
配置组合示例：

# 保守配置（适合搜索为主的场景）
indices.memory.index_buffer_size: "5%"
indices.memory.min_index_buffer_size: "48mb"
indices.memory.max_index_buffer_size: "512mb"

# 积极配置（适合大量写入的场景）
indices.memory.index_buffer_size: "15%"
indices.memory.min_index_buffer_size: "96mb"
indices.memory.max_index_buffer_size: "2gb"
```

### 3.3 indices.memory.shard_inactive_time - 分片非活跃时间


**📋 参数说明**
设置分片多长时间没有写入操作后被认为是"非活跃"状态，非活跃的分片会释放索引缓冲区。

```yaml
# 5分钟无写入操作后标记为非活跃
indices.memory.shard_inactive_time: "5m"
```

**🕐 时间设置建议**
```
业务场景指导：

实时写入场景：
• 设置较长时间：10m 或 30m
• 避免频繁释放和重新分配缓冲区

批量导入场景：
• 设置较短时间：1m 或 2m
• 快速释放不用的缓冲区

混合场景：
• 使用默认值：5m
• 平衡性能和内存使用
```

---

## 4. 📁 文件系统相关配置


### 4.1 index.store.fs.fs_lock - 文件系统锁


**🔒 锁机制说明**
文件系统锁是一种保护机制，防止多个Elasticsearch实例同时操作同一个索引目录，就像给重要文件夹加锁一样。

```yaml
# 配置文件系统锁类型
index.store.fs.fs_lock: "native"
```

**🔧 锁类型对比**

| 锁类型 | **说明** | **优点** | **缺点** |
|--------|---------|---------|---------|
| `native` | **原生文件系统锁（默认）** | `最可靠，系统级保护` | `某些文件系统可能不支持` |
| `simple` | **简单锁文件** | `兼容性好` | `保护级别较低` |
| `none` | **不使用锁** | `无额外开销` | `❌ 不安全，可能数据损坏` |

**⚠️ 安全提醒**
```
生产环境必须启用锁：
✅ 推荐使用 native（默认）
✅ 如果 native 有问题，可使用 simple
❌ 绝不要在生产环境使用 none

常见问题：
• NFS存储可能不支持 native 锁
• 此时可以使用 simple 锁
• 容器环境需要确保锁文件可写
```

### 4.2 index.store.preload - 预加载文件


**💾 预加载机制**
设置哪些类型的文件在打开时就加载到内存中，提高访问速度。

```yaml
# 预加载所有文件（谨慎使用）
index.store.preload: ["*"]

# 只预加载特定类型文件
index.store.preload: ["nvd", "dvd"]

# 不预加载任何文件（默认）
index.store.preload: []
```

**📊 文件类型说明**
```
常见的索引文件类型：

基础文件：
• "nvd" - 数值型字段数据
• "dvd" - 文档值数据
• "tim" - 词项索引
• "tip" - 词项位置

配置建议：
内存充足：可预加载常用文件类型
内存紧张：使用默认空配置
SSD存储：预加载收益不大
```

---

## 5. 🗃️ 分片管理配置


### 5.1 indices.store.delete.shard.timeout - 分片删除超时


**⏰ 参数含义**
设置删除分片时的最大等待时间。当分片正在被使用时，系统会等待这个时间让操作完成。

```yaml
# 删除分片时最多等待30秒
indices.store.delete.shard.timeout: "30s"
```

**🔄 删除流程说明**
```
分片删除过程：

1. 接收删除请求
   ↓
2. 检查分片是否正在使用
   ↓ (如果正在使用)
3. 等待操作完成（最多等待timeout时间）
   ↓
4. 强制删除或报错

超时设置建议：
• 频繁删除索引：设置较短时间 10s-30s
• 大分片删除：设置较长时间 60s-120s  
• 生产环境：建议 30s-60s
```

### 5.2 分片状态监控


**📊 监控分片删除**
```bash
# 查看正在删除的分片
GET /_cat/shards?h=index,shard,prirep,state&s=state

# 查看集群中的删除任务
GET /_cat/tasks?actions=*delete*
```

**🚨 常见问题处理**
```
删除超时问题：

问题现象：
• 分片删除失败
• 磁盘空间无法释放
• 错误日志出现超时信息

解决方案：
1. 检查是否有长时间运行的查询
2. 增大超时时间
3. 停止相关的搜索和索引操作
4. 重启节点（最后手段）
```

---

## 6. ⚡ 存储优化配置


### 6.1 存储性能调优组合


**🎯 高性能存储配置**
```yaml
# 针对写入密集场景的优化配置
elasticsearch.yml:
  # 存储相关
  index.store.type: "niofs"  # Linux环境使用
  index.compound_format: false  # 大分片禁用复合格式
  
  # 缓冲区优化
  indices.memory.index_buffer_size: "15%"
  indices.memory.min_index_buffer_size: "96mb"
  indices.memory.max_index_buffer_size: "1gb"
  indices.memory.shard_inactive_time: "10m"
  
  # 删除优化
  indices.store.delete.shard.timeout: "60s"
```

**🔍 搜索优化存储配置**
```yaml
# 针对查询密集场景的优化配置
elasticsearch.yml:
  # 存储相关
  index.store.type: "mmapfs"  # 大内存环境
  index.compound_format: true  # 减少文件数
  
  # 缓冲区优化
  indices.memory.index_buffer_size: "8%"  # 留更多内存给查询
  indices.memory.shard_inactive_time: "5m"
  
  # 预加载优化
  index.store.preload: ["nvd", "dvd"]  # 预加载常用数据
```

### 6.2 不同环境的推荐配置


**🏢 生产环境配置**
```yaml
# 生产环境：稳定性第一
index.store.type: "fs"  # 使用默认，最稳定
index.store.fs.fs_lock: "native"  # 启用文件锁
index.compound_format: "100mb"  # 小分片使用复合格式
indices.memory.index_buffer_size: "10%"
indices.store.delete.shard.timeout: "30s"
```

**🧪 测试环境配置**
```yaml
# 测试环境：可以更激进
index.store.type: "niofs"  # 尝试高性能存储
index.compound_format: false  # 测试性能差异
indices.memory.index_buffer_size: "15%"  # 更大缓冲区
indices.store.delete.shard.timeout: "10s"  # 快速删除
```

### 6.3 监控存储配置效果


**📈 关键监控指标**
```bash
# 查看索引缓冲区使用情况
GET /_cat/nodes?h=name,indexing.index_buffer_size_in_bytes&v

# 查看存储使用情况
GET /_cat/allocation?h=node,disk.used_percent,disk.avail&v

# 查看索引性能
GET /_cat/indices?h=index,indexing.index_total,search.query_total&v
```

**🔧 性能调优建议**
```
调优步骤：

1. 建立基线
   • 记录当前配置的性能指标
   • 包括索引速度、查询延迟、内存使用

2. 逐项调整
   • 一次只改变一个参数
   • 运行一段时间后观察效果

3. 压力测试
   • 使用实际业务数据测试
   • 模拟高峰期负载

4. 监控稳定性
   • 观察内存使用趋势
   • 检查错误日志
   • 确保没有资源泄露
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心配置


```
🔸 存储类型：index.store.type（默认fs即可）
🔸 缓冲区大小：indices.memory.index_buffer_size（写入多设大点）
🔸 文件锁：index.store.fs.fs_lock（生产环境必须启用）
🔸 复合格式：index.compound_format（小分片启用，大分片禁用）
🔸 删除超时：indices.store.delete.shard.timeout（根据分片大小调整）
```

### 7.2 关键理解要点


**🔹 缓冲区配置原则**
```
写入为主的场景：
• 增大 index_buffer_size 到 10-15%
• 设置合适的 min/max 限制
• 延长 shard_inactive_time

查询为主的场景：
• 减小 index_buffer_size 到 5-8%
• 留更多内存给查询缓存
• 可以启用文件预加载
```

**🔹 存储类型选择**
```
选择决策树：

默认选择 → fs（最稳定）
    ↓
Linux + 高并发 → niofs（更好的并发性能）
    ↓
大内存 + 大数据量 → mmapfs（利用内存映射）

⚠️ 注意：生产环境变更需要充分测试
```

**🔹 配置调优思路**
```
性能调优步骤：
1. 了解业务特征（写入多 vs 查询多）
2. 建立监控基线
3. 逐步调整参数
4. 验证性能改善
5. 确保稳定性
```

### 7.3 实际应用价值


**🎯 业务场景应用**
- **日志分析**：大缓冲区 + 批量写入优化
- **电商搜索**：复合格式 + 预加载优化  
- **实时监控**：平衡写入和查询性能
- **数据仓库**：大分片 + 存储压缩优化

**🔧 运维实践**
- **容量规划**：根据数据增长预估缓冲区需求
- **性能监控**：定期检查存储相关指标
- **故障处理**：了解分片删除和锁机制
- **版本升级**：注意存储配置的兼容性变化

**核心记忆**：
- 存储配置影响性能和稳定性
- 缓冲区大小要根据业务特征调整
- 文件锁保护数据安全，生产环境必须启用
- 不同存储类型适合不同的硬件环境
- 监控和测试是调优的重要环节