---
title: 14、cache缓存配置
---
## 📚 目录

1. [缓存配置基础概念](#1-缓存配置基础概念)
2. [全局缓存清理配置](#2-全局缓存清理配置)
3. [字段数据缓存配置](#3-字段数据缓存配置)
4. [查询缓存配置](#4-查询缓存配置)
5. [请求缓存配置](#5-请求缓存配置)
6. [断路器保护配置](#6-断路器保护配置)
7. [缓存性能优化策略](#7-缓存性能优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 缓存配置基础概念


### 1.1 什么是Elasticsearch缓存


**💡 简单理解**：
缓存就像你的大脑记忆，把常用的信息先记住，下次用的时候就不用重新去找了，这样速度会快很多。

```
没有缓存的情况：
用户搜索 → ES从磁盘读取数据 → 计算结果 → 返回
      ↑_____________耗时较长_____________↑

有缓存的情况：
用户搜索 → ES从内存缓存获取 → 直接返回结果
      ↑__________速度很快__________↑
```

### 1.2 ES中的主要缓存类型


**🔸 核心缓存分类**
```
📦 字段数据缓存 (Field Data Cache)
• 作用：存储字段值，用于排序、聚合
• 比喻：像电话簿，把联系人信息提前整理好

📦 查询缓存 (Query Cache) 
• 作用：存储查询结果
• 比喻：像搜索历史，记住之前搜过的内容

📦 请求缓存 (Request Cache)
• 作用：存储整个请求的响应
• 比喻：像浏览器缓存，整个网页都记住了

📦 断路器 (Circuit Breaker)
• 作用：防止内存使用过多导致系统崩溃
• 比喻：像家里的保险丝，防止电路过载
```

### 1.3 缓存配置的重要性


> ⚠️ **为什么要配置缓存**：
> 
> **性能提升**：合理的缓存配置能让查询速度提升10-100倍
> **内存保护**：防止缓存占用过多内存导致系统不稳定
> **成本控制**：提高硬件利用效率，降低服务器成本

---

## 2. 🧹 全局缓存清理配置


### 2.1 缓存清理间隔配置


**🔸 配置参数**：`indices.cache.cleanup_interval`

**💡 通俗解释**：
这个配置就像定时清理垃圾桶的时间间隔。你不能让垃圾堆太久，但也不能每分钟都去清理，要找个合适的平衡点。

```yaml
# elasticsearch.yml 配置示例
indices.cache.cleanup_interval: 1m
```

### 2.2 清理间隔参数说明


| 配置值 | **含义** | **适用场景** | **影响** |
|--------|---------|-------------|----------|
| `30s` | `30秒清理一次` | `高频查询系统` | `内存释放快，但CPU占用高` |
| `1m` | `1分钟清理一次` | `一般业务系统` | `平衡性能和资源消耗` |
| `5m` | `5分钟清理一次` | `低频查询系统` | `减少CPU消耗，但内存占用高` |

### 2.3 最佳实践建议


> 💡 **配置建议**：
> 
> **🔸 小型集群**：设置为 `1m`，保证内存及时释放
> **🔸 大型集群**：设置为 `30s`，应对高并发场景
> **🔸 测试环境**：可以设置为 `10s`，便于观察缓存行为

---

## 3. 📊 字段数据缓存配置


### 3.1 字段数据缓存基本概念


**💡 什么是字段数据缓存**：
当你要对数据进行排序或者统计分析时，ES需要把字段的所有值都加载到内存中。这就像你要统计班级成绩，需要把所有学生的分数都拿出来排序一样。

```
示例场景：
GET /products/_search
{
  "sort": [
    { "price": "desc" }  ← 这里需要用到字段数据缓存
  ],
  "aggs": {
    "avg_price": {
      "avg": { "field": "price" }  ← 这里也需要字段数据缓存
    }
  }
}
```

### 3.2 字段数据缓存大小配置


**🔸 配置参数**：`indices.fielddata.cache.size`

```yaml
# 方式1：固定大小配置
indices.fielddata.cache.size: 2gb

# 方式2：百分比配置  
indices.fielddata.cache.size: 20%
```

### 3.3 配置方式对比


**📋 配置选择指南**

```
🔸 固定大小配置 (如: 2gb)
✅ 优点：可预测的内存使用量
✅ 适用：内存资源充足，需要精确控制
❌ 缺点：不够灵活，升级硬件时需要手动调整

🔸 百分比配置 (如: 20%)  
✅ 优点：自动适应服务器配置
✅ 适用：多环境部署，硬件配置不统一
❌ 缺点：在小内存服务器上可能不够用
```

### 3.4 内存分配建议


| 服务器内存 | **推荐配置** | **实际大小** | **说明** |
|-----------|-------------|-------------|----------|
| `8GB` | `indices.fielddata.cache.size: 1gb` | `1GB` | `小型项目，预留足够堆内存` |
| `16GB` | `indices.fielddata.cache.size: 15%` | `约2.4GB` | `中型项目，平衡配置` |
| `32GB` | `indices.fielddata.cache.size: 20%` | `约6.4GB` | `大型项目，充分利用内存` |

---

## 4. 🔍 查询缓存配置


### 4.1 查询缓存工作原理


**💡 简单理解**：
查询缓存就像你的搜索历史记录。当有人搜索"苹果手机"时，ES会把搜索结果记住。下次再有人搜索同样的内容，就直接返回之前的结果，不用重新计算。

```
查询缓存命中流程：
用户查询 → 检查缓存 → 发现相同查询 → 直接返回结果 ✅

查询缓存未命中流程：  
用户查询 → 检查缓存 → 没有相同查询 → 执行查询 → 缓存结果 → 返回
```

### 4.2 查询缓存大小配置


**🔸 全局配置**：`indices.queries.cache.size`

```yaml
# elasticsearch.yml 全局配置
indices.queries.cache.size: 10%
```

**🔸 索引级配置**：`index.queries.cache.enabled`

```json
PUT /my_index/_settings
{
  "index.queries.cache.enabled": true
}
```

### 4.3 查询缓存适用场景


**✅ 适合缓存的查询**：
- 🔸 **过滤查询**：`term`、`range`、`exists` 等
- 🔸 **重复查询**：相同条件的频繁查询
- 🔸 **复杂过滤**：多条件组合的过滤器

**❌ 不适合缓存的查询**：
- 🔸 **实时数据**：需要最新结果的查询
- 🔸 **一次性查询**：不会重复执行的查询
- 🔸 **随机参数**：每次参数都不同的查询

### 4.4 查询缓存配置示例


```yaml
# 推荐配置组合
indices.queries.cache.size: 10%        # 查询缓存占堆内存10%
indices.queries.cache.count: 10000      # 最多缓存10000个查询
```

---

## 5. 📨 请求缓存配置


### 5.1 请求缓存基本概念


**💡 通俗解释**：
请求缓存会把整个搜索请求的完整结果都保存下来。这就像你把整个购物清单和价格都抄写一份放在手边，下次需要同样信息时直接看抄写的内容。

```
请求缓存示例：
原始请求：
GET /products/_search
{
  "query": { "match": { "category": "phone" } },
  "size": 10
}

缓存内容：包含完整的搜索结果，包括文档、评分、聚合等
```

### 5.2 请求缓存配置参数


**🔸 缓存大小配置**：`indices.requests.cache.size`

```yaml
# elasticsearch.yml 配置
indices.requests.cache.size: 1%
```

**🔸 缓存过期配置**：`indices.requests.cache.expire`

```yaml
# 设置缓存过期时间
indices.requests.cache.expire: 5m
```

### 5.3 索引级请求缓存控制


**🔸 启用索引请求缓存**：

```json
PUT /my_index/_settings
{
  "index.requests.cache.enable": true
}
```

**🔸 查询时控制缓存**：

```json
GET /my_index/_search?request_cache=true
{
  "query": {
    "term": { "status": "published" }
  }
}
```

### 5.4 请求缓存最佳实践


> 💡 **使用建议**：
> 
> **🔸 适用场景**：
> - 报表查询：相同的统计需求
> - 下拉选项：商品分类、地区列表等
> - 热门内容：首页推荐、热门搜索
> 
> **🔸 不适用场景**：
> - 实时搜索：用户输入的搜索
> - 个性化内容：根据用户定制的结果
> - 频繁更新：数据经常变化的索引

---

## 6. 🛡️ 断路器保护配置


### 6.1 断路器基本概念


**💡 什么是断路器**：
断路器就像家里的保险丝或空气开关。当用电量过大时会自动断电保护家里的电器。ES的断路器也是一样，当内存使用过多时会拒绝新的请求，保护整个集群不崩溃。

```
断路器工作流程：
内存使用正常 → 允许新请求 → 正常处理
       ↓
内存接近限制 → 触发断路器 → 拒绝新请求 → 保护系统
```

### 6.2 总断路器配置


**🔸 配置参数**：`indices.breaker.total.limit`

```yaml
# elasticsearch.yml 配置
indices.breaker.total.limit: 70%
```

**📊 内存分配示例**：
```
假设JVM堆内存：8GB
断路器总限制：70% = 5.6GB

内存分配：
├── 字段数据缓存：1.6GB (20%)
├── 查询缓存：0.8GB (10%)  
├── 请求缓存：0.08GB (1%)
├── 其他内存使用：3.12GB (39%)
└── 安全保留：2.4GB (30%)
```

### 6.3 字段数据断路器配置


**🔸 配置参数**：`indices.breaker.fielddata.limit`

```yaml
# 字段数据断路器限制
indices.breaker.fielddata.limit: 40%
```

### 6.4 断路器配置建议


| 断路器类型 | **推荐配置** | **作用说明** | **触发后果** |
|-----------|-------------|-------------|-------------|
| `总断路器` | `70%` | `保护整体内存不溢出` | `拒绝所有新请求` |
| `字段数据断路器` | `40%` | `限制聚合排序内存使用` | `聚合查询失败` |
| `请求断路器` | `60%` | `限制单个请求内存使用` | `单个请求失败` |

### 6.5 断路器故障处理


> ⚠️ **当断路器触发时**：
> 
> **🔸 立即处理**：
> - 检查是否有大量聚合查询
> - 减少并发请求数量
> - 优化查询语句减少内存使用
> 
> **🔸 长期优化**：
> - 增加集群节点分散负载
> - 优化索引mapping减少内存占用
> - 调整断路器限制（谨慎操作）

---

## 7. ⚡ 缓存性能优化策略


### 7.1 缓存配置组合建议


**🔸 小型业务系统（单节点，8GB内存）**：
```yaml
# 保守配置，稳定优先
indices.cache.cleanup_interval: 1m
indices.fielddata.cache.size: 1gb
indices.queries.cache.size: 5%
indices.requests.cache.size: 0.5%
indices.breaker.total.limit: 65%
indices.breaker.fielddata.limit: 35%
```

**🔸 中型业务系统（3节点，16GB内存）**：
```yaml
# 平衡配置，性能和稳定兼顾
indices.cache.cleanup_interval: 1m
indices.fielddata.cache.size: 15%
indices.queries.cache.size: 10%
indices.requests.cache.size: 1%
indices.breaker.total.limit: 70%
indices.breaker.fielddata.limit: 40%
```

**🔸 大型业务系统（5+节点，32GB内存）**：
```yaml
# 性能优化配置
indices.cache.cleanup_interval: 30s
indices.fielddata.cache.size: 20%
indices.queries.cache.size: 15%
indices.requests.cache.size: 2%
indices.breaker.total.limit: 75%
indices.breaker.fielddata.limit: 45%
```

### 7.2 监控缓存效果


**🔸 查看缓存统计信息**：
```bash
# 查看节点级缓存信息
curl -X GET "localhost:9200/_nodes/stats/indices/query_cache,request_cache,fielddata"

# 查看索引级缓存信息  
curl -X GET "localhost:9200/my_index/_stats/query_cache,request_cache,fielddata"
```

### 7.3 缓存优化技巧


**🎯 提高缓存命中率**：

```
🔸 查询优化：
• 使用过滤器代替查询（filter vs query）
• 避免在查询中使用随机参数
• 合并相似的查询条件

🔸 业务优化：
• 预热热门查询缓存
• 合理设计查询接口
• 避免大范围的聚合查询
```

**⚠️ 常见问题和解决**：

| 问题现象 | **可能原因** | **解决方案** |
|---------|-------------|-------------|
| `查询变慢` | `缓存命中率低` | `检查查询是否可缓存，优化查询条件` |
| `内存不足` | `缓存配置过大` | `减少缓存大小或增加服务器内存` |
| `频繁GC` | `缓存清理过频繁` | `增加清理间隔时间` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 缓存作用：提升查询性能，减少磁盘IO和计算开销
🔸 缓存类型：字段数据缓存、查询缓存、请求缓存
🔸 断路器：保护内存不溢出的安全机制
🔸 配置原则：根据硬件配置和业务需求平衡性能与稳定性
🔸 监控重要：定期检查缓存命中率和内存使用情况
```

### 8.2 关键配置参数速查


**🔹 必配参数**：
```yaml
# 基础缓存配置
indices.cache.cleanup_interval: 1m         # 缓存清理间隔
indices.fielddata.cache.size: 20%          # 字段数据缓存大小
indices.queries.cache.size: 10%            # 查询缓存大小
indices.requests.cache.size: 1%            # 请求缓存大小

# 安全保护配置
indices.breaker.total.limit: 70%           # 总断路器限制
indices.breaker.fielddata.limit: 40%       # 字段数据断路器
```

### 8.3 配置调优思路


**🔹 性能优先场景**：
- 增加各类缓存大小配置
- 减少缓存清理频率
- 适当提高断路器限制

**🔹 稳定优先场景**：
- 保守设置缓存大小
- 频繁清理缓存释放内存
- 较低的断路器限制

**🔹 平衡配置原则**：
```
第一步：根据服务器内存确定基础配置
第二步：根据业务特点调整缓存类型重点
第三步：通过监控数据验证配置效果
第四步：逐步优化到最佳配置状态
```

### 8.4 实际应用指导


**💡 新手建议**：
1. **从保守配置开始**：先保证系统稳定运行
2. **逐步调优**：每次只调整一个参数观察效果
3. **记录配置变更**：方便出问题时快速回滚
4. **定期检查**：监控缓存使用情况和系统性能

**🚀 进阶优化**：
- 根据业务高峰期调整缓存策略
- 结合应用层缓存设计整体缓存架构
- 针对不同索引设置个性化缓存配置
- 建立缓存性能监控和告警机制

**核心记忆**：
- 缓存是性能提升的关键，但要防止内存溢出
- 断路器是安全保障，不能为了性能而完全关闭
- 配置要根据实际硬件和业务场景调整，没有万能配置
- 监控和调优是持续过程，需要根据业务发展不断优化