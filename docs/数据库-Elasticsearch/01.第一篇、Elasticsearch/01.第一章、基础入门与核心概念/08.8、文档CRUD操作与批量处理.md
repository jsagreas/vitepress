---
title: 8、文档CRUD操作与批量处理
---
## 📚 目录

1. [文档CRUD基础概念](#1-文档CRUD基础概念)
2. [文档创建操作详解](#2-文档创建操作详解)
3. [文档查询操作详解](#3-文档查询操作详解)
4. [文档更新操作详解](#4-文档更新操作详解)
5. [文档删除操作详解](#5-文档删除操作详解)
6. [文档版本控制与乐观锁](#6-文档版本控制与乐观锁)
7. [批量操作核心技术](#7-批量操作核心技术)
8. [性能优化与最佳实践](#8-性能优化与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📖 文档CRUD基础概念


### 1.1 什么是文档CRUD

**CRUD的含义**：
- **C**reate（创建）：向索引中添加新文档
- **R**ead（读取）：从索引中查询文档
- **U**pdate（更新）：修改索引中现有文档
- **D**elete（删除）：从索引中移除文档

> 💡 **简单理解**：就像操作数据库表一样，Elasticsearch的文档操作也是增删改查四大基本操作

### 1.2 文档的基本结构

```
Elasticsearch文档 = JSON格式的数据记录

示例文档结构：
{
  "_index": "users",           ← 索引名（相当于数据库表名）
  "_type": "_doc",             ← 文档类型（ES7+基本固定为_doc）
  "_id": "1",                  ← 文档唯一标识符
  "_version": 1,               ← 文档版本号
  "_source": {                 ← 文档的实际内容
    "name": "张三",
    "age": 25,
    "email": "zhangsan@example.com"
  }
}
```

### 1.3 RESTful API风格

Elasticsearch使用RESTful API，通过HTTP请求方法区分不同操作：

| HTTP方法 | **操作类型** | **说明** |
|---------|------------|---------|
| `POST` | `创建文档` | `可自动生成ID或指定ID` |
| `PUT` | `创建/覆盖` | `必须指定ID，存在则覆盖` |
| `GET` | `查询文档` | `根据ID获取文档` |
| `DELETE` | `删除文档` | `根据ID删除文档` |

---

## 2. ✏️ 文档创建操作详解


### 2.1 POST方式创建（自动生成ID）


**基本语法**：
```
POST /索引名/_doc
```

**实际示例**：
```bash
# 创建一个用户文档，让ES自动生成ID
POST /users/_doc
{
  "name": "李四",
  "age": 28,
  "department": "技术部",
  "email": "lisi@company.com"
}

# 返回结果
{
  "_index": "users",
  "_type": "_doc",
  "_id": "mQrKH4AB123xyz789",     ← ES自动生成的随机ID
  "_version": 1,
  "_result": "created",           ← 表示创建成功
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  }
}
```

> 💡 **使用场景**：当你不关心文档ID具体是什么时，比如日志记录、评论等

### 2.2 PUT方式创建（指定ID）


**基本语法**：
```
PUT /索引名/_doc/文档ID
```

**实际示例**：
```bash
# 创建指定ID的用户文档
PUT /users/_doc/1001
{
  "name": "王五",
  "age": 30,
  "department": "财务部",
  "email": "wangwu@company.com"
}

# 返回结果
{
  "_index": "users",
  "_type": "_doc",
  "_id": "1001",                  ← 使用我们指定的ID
  "_version": 1,
  "_result": "created"
}
```

> ⚠️ **注意**：如果指定的ID已存在，PUT会完全覆盖原文档内容！

### 2.3 POST指定ID创建


**基本语法**：
```
POST /索引名/_doc/文档ID
```

这种方式和PUT的区别：
- **PUT**：ID存在时直接覆盖
- **POST指定ID**：ID存在时也会覆盖，但语义上更倾向于创建

### 2.4 文档ID生成策略


**自动生成ID的特点**：
- ✅ **全局唯一**：20个字符的Base64编码字符串
- ✅ **时间有序**：包含时间戳信息，按时间递增
- ✅ **分布均匀**：有助于数据在集群中均匀分布

**手动指定ID的考虑**：
```
适合指定ID的场景：
📌 用户ID、商品编号等有业务含义的标识
📌 需要根据ID快速查找的数据
📌 数据同步时保持一致性

不建议指定ID的场景：
❌ 日志、事件等流水数据
❌ ID可能重复冲突的情况
❌ 不需要按ID查询的数据
```

---

## 3. 🔍 文档查询操作详解


### 3.1 基本查询语法


**根据ID查询单个文档**：
```bash
GET /users/_doc/1001

# 返回结果
{
  "_index": "users",
  "_type": "_doc",
  "_id": "1001",
  "_version": 1,
  "_seq_no": 0,
  "_primary_term": 1,
  "found": true,                  ← 表示找到了文档
  "_source": {                    ← 文档的实际内容
    "name": "王五",
    "age": 30,
    "department": "财务部",
    "email": "wangwu@company.com"
  }
}
```

### 3.2 文档存在性检查


**检查文档是否存在**：
```bash
HEAD /users/_doc/1001

# 返回HTTP状态码：
# 200：文档存在
# 404：文档不存在
```

> 💡 **使用场景**：当你只需要知道文档是否存在，不需要获取具体内容时，这比GET更高效

### 3.3 只获取文档源数据


**获取纯净的文档内容**：
```bash
GET /users/_doc/1001/_source

# 直接返回文档内容，没有元数据
{
  "name": "王五",
  "age": 30,
  "department": "财务部",
  "email": "wangwu@company.com"
}
```

### 3.4 部分字段查询


**只获取指定字段**：
```bash
GET /users/_doc/1001?_source=name,email

# 返回结果只包含指定字段
{
  "_index": "users",
  "_type": "_doc",
  "_id": "1001",
  "_version": 1,
  "found": true,
  "_source": {
    "name": "王五",
    "email": "wangwu@company.com"
  }
}
```

### 3.5 处理查询不到的情况


**文档不存在时的响应**：
```bash
GET /users/_doc/9999

# 返回结果
{
  "_index": "users",
  "_type": "_doc",
  "_id": "9999",
  "found": false                  ← 明确表示未找到
}
```

---

## 4. 🔄 文档更新操作详解


### 4.1 部分更新基础


**部分更新语法**：
```bash
POST /索引名/_update/文档ID
{
  "doc": {
    "要更新的字段": "新值"
  }
}
```

**实际示例**：
```bash
# 只更新用户的年龄和邮箱
POST /users/_update/1001
{
  "doc": {
    "age": 31,
    "email": "wangwu_new@company.com"
  }
}

# 返回结果
{
  "_index": "users",
  "_type": "_doc",
  "_id": "1001",
  "_version": 2,                  ← 版本号递增
  "result": "updated"             ← 表示更新成功
}
```

> 💡 **部分更新的优势**：只修改指定字段，其他字段保持不变，比完全覆盖更安全

### 4.2 脚本更新


**使用脚本进行复杂更新**：
```bash
# 年龄增加1岁
POST /users/_update/1001
{
  "script": {
    "source": "ctx._source.age += params.increment",
    "params": {
      "increment": 1
    }
  }
}
```

**添加新字段**：
```bash
# 添加最后登录时间
POST /users/_update/1001
{
  "script": {
    "source": "ctx._source.last_login = params.login_time",
    "params": {
      "login_time": "2025-01-21T10:30:00"
    }
  }
}
```

### 4.3 Upsert操作


**文档不存在时自动创建**：
```bash
POST /users/_update/1002
{
  "doc": {
    "name": "赵六",
    "age": 26
  },
  "upsert": {
    "name": "赵六",
    "age": 26,
    "department": "未分配",
    "create_time": "2025-01-21"
  }
}
```

> 💡 **Upsert含义**：Update + Insert，存在则更新，不存在则创建

### 4.4 条件更新


**基于版本号的条件更新**：
```bash
# 只有版本号为2时才执行更新
POST /users/_update/1001?version=2
{
  "doc": {
    "age": 32
  }
}
```

**基于文档内容的条件更新**：
```bash
POST /users/_update/1001
{
  "script": {
    "source": "if (ctx._source.age < 40) { ctx._source.age += 1 } else { ctx.op = 'noop' }"
  }
}
```

---

## 5. 🗑️ 文档删除操作详解


### 5.1 基本删除操作


**删除单个文档**：
```bash
DELETE /users/_doc/1001

# 返回结果
{
  "_index": "users",
  "_type": "_doc",
  "_id": "1001",
  "_version": 3,                  ← 删除也会增加版本号
  "result": "deleted"             ← 表示删除成功
}
```

### 5.2 删除不存在的文档


```bash
DELETE /users/_doc/9999

# 返回结果
{
  "_index": "users",
  "_type": "_doc",
  "_id": "9999",
  "_version": 1,
  "result": "not_found"           ← 表示文档不存在
}
```

> ⚠️ **注意**：删除不存在的文档不会报错，会返回"not_found"状态

### 5.3 按查询条件删除


**删除符合条件的所有文档**：
```bash
POST /users/_delete_by_query
{
  "query": {
    "range": {
      "age": {
        "lt": 25
      }
    }
  }
}
```

> 🚨 **警告**：批量删除操作不可逆，使用前务必确认查询条件正确！

---

## 6. 🔒 文档版本控制与乐观锁


### 6.1 版本控制机制


**版本号的作用**：
```
每次文档操作都会增加版本号：
创建文档：_version = 1
第1次更新：_version = 2  
第2次更新：_version = 3
删除文档：_version = 4
```

**版本号查看**：
```bash
GET /users/_doc/1001

# 响应中的版本信息
{
  "_version": 2,
  "_seq_no": 5,                   ← 序列号
  "_primary_term": 1              ← 主分片术语
}
```

### 6.2 乐观锁原理


**什么是乐观锁**：
假设并发冲突很少发生，在更新时才检查数据是否被其他操作修改过

**乐观锁流程图**：
```
用户A查询文档 → 获得version=1
用户B查询文档 → 获得version=1
用户A更新文档 → version变为2，成功
用户B更新文档 → 检查version=1≠2，失败！
```

### 6.3 使用版本控制防冲突


**基于version的乐观锁**：
```bash
# 查询获取当前版本
GET /users/_doc/1001
# 假设返回 "_version": 2

# 更新时指定版本号
PUT /users/_doc/1001?version=2
{
  "name": "王五",
  "age": 35,
  "department": "技术部"
}

# 如果版本号不匹配，返回409冲突错误
```

**基于seq_no的乐观锁（推荐）**：
```bash
# 使用序列号进行版本控制
PUT /users/_doc/1001?if_seq_no=5&if_primary_term=1
{
  "name": "王五",
  "age": 35
}
```

### 6.4 处理版本冲突


**冲突处理策略**：
- ✅ **重新获取**：重新查询最新版本，合并修改后再更新
- ✅ **放弃操作**：如果不重要，直接放弃本次修改
- ✅ **强制覆盖**：使用外部版本号强制更新（需谨慎）

---

## 7. 🚀 批量操作核心技术


### 7.1 批量获取(_mget)


**基本语法**：
```bash
GET /_mget
{
  "docs": [
    {
      "_index": "users",
      "_id": "1001"
    },
    {
      "_index": "users", 
      "_id": "1002"
    }
  ]
}
```

**同索引简化写法**：
```bash
GET /users/_mget
{
  "ids": ["1001", "1002", "1003"]
}

# 返回结果
{
  "docs": [
    {
      "_index": "users",
      "_id": "1001",
      "found": true,
      "_source": { "name": "王五", "age": 30 }
    },
    {
      "_index": "users", 
      "_id": "1002",
      "found": false
    }
  ]
}
```

### 7.2 批量操作(_bulk)


**Bulk API的强大之处**：
一次请求可以执行多种操作：创建、更新、删除

**基本格式**：
```
{ "action": { "metadata" } }
{ "source" }
{ "action": { "metadata" } }
{ "source" }
```

**完整示例**：
```bash
POST /_bulk
{"index":{"_index":"users","_id":"2001"}}
{"name":"张三","age":25,"department":"研发部"}
{"create":{"_index":"users","_id":"2002"}}
{"name":"李四","age":28,"department":"测试部"}
{"update":{"_index":"users","_id":"1001"}}
{"doc":{"age":33}}
{"delete":{"_index":"users","_id":"1002"}}
```

### 7.3 Bulk操作类型详解


| 操作类型 | **说明** | **ID存在时行为** |
|---------|---------|-----------------|
| `index` | `创建或替换文档` | `覆盖现有文档` |
| `create` | `仅创建新文档` | `失败返回错误` |
| `update` | `更新现有文档` | `执行更新操作` |
| `delete` | `删除文档` | `删除成功` |

### 7.4 批量操作最佳实践


**性能优化建议**：
```
批量大小建议：
🎯 文档数量：100-1000个/批次
🎯 数据大小：1-15MB/批次
🎯 测试确定：根据实际环境测试最优值

并发控制：
⚡ 并发批次：2-8个并发请求
⚡ 错误处理：设置合理的重试机制
⚡ 监控性能：关注批量操作的延迟和吞吐量
```

### 7.5 错误处理与重试


**Bulk操作的错误处理**：
```bash
# Bulk响应示例
{
  "took": 30,
  "errors": true,                 ← 表示存在错误
  "items": [
    {
      "index": {
        "_index": "users",
        "_id": "2001", 
        "status": 201,            ← 成功创建
        "result": "created"
      }
    },
    {
      "create": {
        "_index": "users",
        "_id": "2002",
        "status": 409,            ← 冲突错误
        "error": {
          "type": "version_conflict_engine_exception",
          "reason": "version conflict"
        }
      }
    }
  ]
}
```

**失败重试策略**：
- ✅ **可重试错误**：网络超时、临时性错误
- ❌ **不可重试错误**：数据格式错误、权限问题
- 🔄 **重试间隔**：指数退避策略（1s, 2s, 4s, 8s...）

---

## 8. ⚡ 性能优化与最佳实践


### 8.1 文档路由策略


**理解文档路由**：
```
文档路由公式：
shard_id = hash(routing_value) % number_of_primary_shards

默认routing_value = 文档ID
可自定义routing参数优化查询性能
```

**自定义路由示例**：
```bash
# 按用户ID路由，相同用户的文档在同一分片
PUT /users/_doc/1001?routing=user_001
{
  "user_id": "user_001",
  "name": "张三",
  "age": 25
}

# 查询时也要指定相同路由
GET /users/_doc/1001?routing=user_001
```

### 8.2 批量导入优化策略


**大批量数据导入优化**：
```bash
# 1. 临时调整索引设置
PUT /users/_settings
{
  "index": {
    "refresh_interval": "30s",      ← 减少刷新频率
    "number_of_replicas": 0         ← 临时移除副本
  }
}

# 2. 执行批量导入
POST /_bulk
{ ... 大量数据 ... }

# 3. 恢复正常设置
PUT /users/_settings
{
  "index": {
    "refresh_interval": "1s",
    "number_of_replicas": 1
  }
}

# 4. 强制刷新
POST /users/_refresh
```

### 8.3 吞吐量优化技巧


**客户端优化**：
```
连接池配置：
📊 连接数：每个ES节点2-4个连接
📊 超时设置：连接超时30s，读超时60s
📊 重试机制：最多重试3次，指数退避

请求优化：
🚀 异步处理：使用异步客户端提高并发
🚀 压缩传输：启用HTTP压缩减少网络开销
🚀 批量合并：将小批量请求合并为大批量
```

### 8.4 监控与调试


**关键性能指标**：
- **索引速度**：docs/second
- **搜索延迟**：平均响应时间
- **错误率**：失败请求比例
- **资源使用**：CPU、内存、磁盘IO

**常用监控命令**：
```bash
# 查看索引统计信息
GET /users/_stats

# 查看节点性能
GET /_nodes/stats

# 查看集群健康状态
GET /_cluster/health
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本操作


```
🔸 文档创建：POST自动ID vs PUT指定ID的选择
🔸 文档查询：GET基本查询、HEAD存在检查、部分字段获取
🔸 文档更新：POST _update部分更新、脚本更新、upsert操作
🔸 文档删除：DELETE单个删除、_delete_by_query批量删除
🔸 批量操作：_mget批量获取、_bulk批量处理
```

### 9.2 关键理解要点


**🔹 版本控制的重要性**
```
版本控制作用：
- 防止并发修改冲突
- 提供乐观锁机制
- 追踪文档变更历史

使用建议：
- 多用户环境必须使用版本控制
- 推荐使用seq_no而非version
- 合理处理版本冲突情况
```

**🔹 批量操作的优势**
```
为什么要用批量操作：
- 减少网络往返次数
- 提高整体吞吐量
- 降低ES集群负载

注意事项：
- 控制批量大小避免内存溢出
- 处理部分失败的情况
- 监控批量操作性能
```

**🔹 性能优化考虑**
```
影响性能的因素：
- 文档大小和结构复杂度
- 批量操作的大小和频率
- 网络延迟和带宽限制
- ES集群的配置和负载

优化策略：
- 合理设计文档结构
- 使用合适的批量大小
- 优化网络配置
- 监控并调整ES参数
```

### 9.3 实际应用指导


**适用场景判断**：
```
单个操作适用：
✅ 实时性要求高的场景
✅ 数据量小且操作简单
✅ 需要立即获取操作结果

批量操作适用：
✅ 数据导入和同步
✅ 批量数据处理
✅ 性能要求高的场景
```

**错误处理策略**：
```
常见错误类型：
🔴 版本冲突：使用乐观锁重试
🟡 文档不存在：检查ID和索引名
🟠 格式错误：验证JSON格式和字段类型
🔵 网络超时：增加超时时间或重试
```

### 9.4 最佳实践清单


```
文档设计：
- ✅ 使用有意义的文档ID
- ✅ 合理设计文档结构
- ✅ 避免过大的文档
- ✅ 考虑查询模式设计字段

操作实践：
- ✅ 生产环境必须使用版本控制
- ✅ 大批量操作优先使用_bulk
- ✅ 设置合理的超时和重试
- ✅ 监控操作性能和错误率

安全考虑：
- ✅ 删除操作前确认查询条件
- ✅ 重要操作前备份数据
- ✅ 使用权限控制限制危险操作
- ✅ 记录重要操作日志
```

**核心记忆要点**：
- CRUD操作是ES最基础的技能，必须熟练掌握
- 版本控制是并发环境下的安全保障
- 批量操作是高性能应用的关键技术
- 性能优化需要结合具体业务场景调整