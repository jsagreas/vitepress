---
title: 3、基本术语与数据模型
---
## 📚 目录

1. [什么是Elasticsearch？从生活场景说起](#1-什么是elasticsearch？从生活场景说起)
2. [核心概念全景图](#2-核心概念全景图)
3. [集群与节点：ES的组织架构](#3-集群与节点：es的组织架构)
4. [索引与文档：数据的存储方式](#4-索引与文档：数据的存储方式)
5. [字段与映射：数据的结构定义](#5-字段与映射：数据的结构定义)
6. [分片与副本：数据的分布策略](#6-分片与副本：数据的分布策略)
7. [路由与分段：数据的定位机制](#7-路由与分段：数据的定位机制)
8. [版本控制：数据的更新追踪](#8-版本控制：数据的更新追踪)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌟 什么是Elasticsearch？从生活场景说起


### 1.1 生活中的搜索场景


想象一下，你在逛一个超级大的图书馆：

```
传统图书馆的困境：
📚 书籍分类：文学类、科技类、历史类...
🔍 查找方式：只能按分类或书名查找
⏰ 查找速度：需要人工翻阅目录册
❌ 局限性：无法按内容、作者风格等多维度搜索

Elasticsearch就像一个"智能图书馆"：
🚀 全文搜索：能搜索书籍内容的任意关键词
⚡ 秒级响应：瞬间找到相关的所有书籍
🎯 多维搜索：同时按作者、年代、主题等搜索
📊 智能排序：按相关性、热度等排序结果
```

### 1.2 ES在现实中的应用


**电商网站搜索**：
- 你搜索"红色 iPhone 128G"
- ES帮你找到所有匹配的商品
- 按价格、销量、好评度排序

**日志监控系统**：
- 系统每秒产生成千上万条日志
- ES帮你实时搜索错误信息
- 快速定位问题根源

### 1.3 ES的本质特点


| 特点 | 传统数据库 | Elasticsearch |
|------|-----------|---------------|
| **搜索方式** | 精确匹配 | 全文搜索 + 模糊匹配 |
| **查询速度** | 简单查询快 | 复杂搜索也很快 ⚡ |
| **数据结构** | 结构化表格 | 灵活的JSON文档 |
| **扩展性** | 垂直扩展 | 水平扩展 🚀 |

> 💡 **新手理解要点**
> 
> 把ES想象成一个"超级智能的搜索助手"，它不仅记住了你存储的每一个字，还能理解这些字的含义和关联关系！

---

## 2. 🗺️ 核心概念全景图


### 2.1 ES架构总览


```
                    🌐 Elasticsearch 集群 (Cluster)
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
    🖥️ 节点1            🖥️ 节点2            🖥️ 节点3
    (Node-1)          (Node-2)          (Node-3)
        │                  │                  │
    ┌───┴───┐          ┌───┴───┐          ┌───┴───┐
    │索引 A │          │索引 B │          │索引 C │
    │(商品) │          │(用户) │          │(订单) │
    └───────┘          └───────┘          └───────┘
        │                  │                  │
    ┌───┴───┐          ┌───┴───┐          ┌───┴───┐
    │文档1-N│          │文档1-N│          │文档1-N│
    │(JSON) │          │(JSON) │          │(JSON) │
    └───────┘          └───────┘          └───────┘
```

### 2.2 概念层次关系


```
集群 (Cluster)
└── 节点 (Node) × N
    └── 索引 (Index) × N
        └── 文档 (Document) × N
            └── 字段 (Field) × N
```

### 2.3 数据模型对比


| 关系型数据库 | Elasticsearch | 生活类比 |
|-------------|---------------|----------|
| **数据库** | 集群 (Cluster) | 整个图书馆系统 📚 |
| **表** | 索引 (Index) | 某个分类区域 (科技书区) |
| **行** | 文档 (Document) | 一本具体的书 📖 |
| **列** | 字段 (Field) | 书的属性 (标题、作者、价格) |

---

## 3. 🏢 集群与节点：ES的组织架构


### 3.1 集群 (Cluster) - ES的"大家庭"


**什么是集群？**
集群就像一个"图书馆联盟"，由多个图书馆（节点）组成，它们共同协作为你提供服务。

```
🏢 集群特点：
┌─────────────────────────────────────┐
│  集群名称: my-elasticsearch-cluster  │
├─────────────────────────────────────┤
│  👥 节点数量: 3个                    │
│  📊 数据分布: 自动负载均衡            │
│  🔄 故障恢复: 自动容错               │
│  🚀 弹性扩展: 随时增减节点            │
└─────────────────────────────────────┘
```

> ⚠️ **重要提醒**
> 
> 集群中的所有节点必须有相同的集群名称，这就像加入同一个微信群需要群号一样！

### 3.2 节点 (Node) - 集群中的"工作者"


**节点的角色分工**：

```
🎯 主节点 (Master Node)
├─ 职责: 管理集群状态、索引创建删除
├─ 类比: 图书馆馆长
└─ 特点: 只有一个，但可以选举

📊 数据节点 (Data Node)  
├─ 职责: 存储数据、执行搜索查询
├─ 类比: 图书管理员
└─ 特点: 可以有多个，承担主要工作

🔍 协调节点 (Coordinating Node)
├─ 职责: 路由请求、汇总结果
├─ 类比: 咨询台工作人员
└─ 特点: 不存储数据，只负责协调

🔧 专用节点 (Dedicated Node)
├─ 职责: 特殊功能(如机器学习)
├─ 类比: 专业技术顾问
└─ 特点: 专门负责特定任务
```

**节点健康状态**：
- `🟢 绿色` - 健康运行
- `🟡 黄色` - 部分功能受限  
- `🔴 红色` - 严重故障

### 3.3 集群的自动管理


```
集群自动化管理流程：

新节点加入:
1. 配置集群名称
2. 自动发现其他节点
3. 主节点分配角色
4. 开始数据同步

节点故障处理:
1. 其他节点检测到故障
2. 重新分配分片
3. 数据自动恢复
4. 集群状态更新
```

---

## 4. 📁 索引与文档：数据的存储方式


### 4.1 索引 (Index) - 数据的"分类仓库"


**索引就像商店的不同区域**：

```
🏪 电商网站的索引划分：

📱 商品索引 (products)
├─ 手机、电脑、家电...
├─ 每个商品都是一个文档
└─ 包含名称、价格、描述等字段

👤 用户索引 (users)  
├─ 用户账号、个人信息...
├─ 每个用户都是一个文档
└─ 包含姓名、邮箱、地址等字段

📦 订单索引 (orders)
├─ 购买记录、物流信息...
├─ 每个订单都是一个文档  
└─ 包含商品、数量、金额等字段
```

**索引命名规范**：
- ✅ `products_2024` - 清晰有意义
- ✅ `user-profiles` - 小写加连字符
- ❌ `Products_Mix` - 避免大写和混合

### 4.2 文档 (Document) - 数据的"基本单元"


**文档是JSON格式的数据记录**：

**一个商品文档示例**：
```json
{
  "_id": "iphone_15_pro_128",
  "_source": {
    "name": "iPhone 15 Pro 128GB",
    "brand": "Apple",
    "price": 7999.00,
    "category": "手机",
    "colors": ["深空黑", "原色钛金属"],
    "in_stock": true,
    "release_date": "2023-09-15",
    "tags": ["5G", "A17芯片", "钛金属"],
    "description": "配备A17 Pro芯片的专业级手机"
  }
}
```

**文档的核心属性**：

| 属性 | 说明 | 类比 |
|------|------|------|
| `_id` | 唯一标识符 | 图书的ISBN号 📖 |
| `_source` | 原始JSON数据 | 图书的完整内容 |
| `_index` | 所属索引 | 图书所在的分类区 |
| `_type` | 文档类型 (已废弃) | ~~子分类~~ |

> 💡 **新手提示**
> 
> 想象文档就是一张"智能名片"，不仅包含基本信息，还能被快速搜索和查找！

### 4.3 文档的生命周期


```
文档操作流程:

创建文档:
POST /products/_doc/1 → 📄 新增商品信息

读取文档:
GET /products/_doc/1 → 🔍 查看商品详情

更新文档:
PUT /products/_doc/1 → ✏️ 修改商品信息

删除文档:
DELETE /products/_doc/1 → 🗑️ 删除商品信息
```

---

## 5. 🏗️ 字段与映射：数据的结构定义


### 5.1 字段 (Field) - 文档的"属性"


**字段就像表格的列**，但更加灵活：

```
📋 商品文档的字段设计：

基础字段:
├─ name (文本) - 商品名称
├─ price (数字) - 价格  
├─ in_stock (布尔) - 是否有库存
└─ category (关键词) - 分类

复杂字段:
├─ colors (数组) - 多个颜色选项
├─ specs (对象) - 规格参数
├─ location (地理位置) - 仓库坐标
└─ create_time (日期) - 创建时间
```

### 5.2 映射 (Mapping) - 字段的"使用说明书"


**映射定义了每个字段的处理方式**：

**基本数据类型**：

| 类型 | 用途 | 示例 | 搜索特点 |
|------|------|------|----------|
| `text` | 全文搜索 | "iPhone 15 Pro" | 分词搜索 🔍 |
| `keyword` | 精确匹配 | "手机" | 完整匹配 |
| `integer` | 整数 | 128 | 范围查询 📊 |
| `float` | 小数 | 7999.99 | 数值计算 |
| `boolean` | 布尔值 | true/false | 是否判断 |
| `date` | 日期 | "2023-09-15" | 时间范围 📅 |

**映射配置示例**：
```json
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text",
        "analyzer": "ik_max_word"
      },
      "category": {
        "type": "keyword"
      },
      "price": {
        "type": "float"
      },
      "tags": {
        "type": "keyword"
      }
    }
  }
}
```

> ⚠️ **注意事项**
> 
> 映射一旦创建就很难修改，就像房子的地基一样，所以前期规划很重要！

### 5.3 动态映射 vs 显式映射


**动态映射 - "自动推测"**：
```
ES自动判断字段类型:
"price": 7999 → 自动识别为 long
"name": "iPhone" → 自动识别为 text + keyword
"available": true → 自动识别为 boolean
```

**显式映射 - "精确控制"**：
```
手动定义字段类型:
✅ 更精确的控制
✅ 更好的性能
✅ 避免类型错误
```

---

## 6. 🧩 分片与副本：数据的分布策略


### 6.1 分片 (Shard) - 数据的"分割存储"


**为什么需要分片？**

想象你有一本超厚的字典：

```
❌ 不分片的问题:
📚 一本字典太厚 → 数据太大，单机存不下
🐌 查找很慢 → 搜索性能受限
💥 容易损坏 → 单点故障风险

✅ 分片的好处:
📖 分成多册 → 数据分布到多个节点
⚡ 并行查找 → 多个分片同时搜索
🛡️ 风险分散 → 部分故障不影响整体
```

### 6.2 分片的工作原理


**主分片 (Primary Shard)**：

```
📊 索引分片示例 (3个主分片):

商品索引 (products)
├─ 分片0: 商品ID 1-1000  → 节点A
├─ 分片1: 商品ID 1001-2000 → 节点B  
└─ 分片2: 商品ID 2001-3000 → 节点C

每个分片独立存储和搜索
搜索时并行查询所有分片
```

**分片数量选择指南**：

| 数据量 | 建议分片数 | 理由 |
|--------|-----------|------|
| < 1GB | 1个 | 小数据无需分片 |
| 1-10GB | 1-3个 | 适度分片 ⚡ |
| 10GB+ | 根据节点数决定 | 充分利用集群 🚀 |

> 💡 **分片数量的经验法则**
> 
> 分片数 ≈ 节点数 × 1-3倍，既能充分利用资源，又不会产生过多开销。

### 6.3 副本 (Replica) - 数据的"备份保险"


**副本分片的作用**：

```
🛡️ 数据安全保障:
主分片 → 副本分片 (完全相同的拷贝)
节点A故障 → 副本分片自动顶替
数据永不丢失 → 业务持续运行

⚡ 性能提升:
读请求 → 可以从主分片或副本分片读取
并发处理 → 多个副本同时服务
负载分散 → 提高查询吞吐量
```

**分片与副本的分布示例**：

```
3节点集群，1个索引，3主分片，1副本:

节点A: [主分片0] [副本分片1] [副本分片2]
节点B: [主分片1] [副本分片2] [副本分片0]  
节点C: [主分片2] [副本分片0] [副本分片1]

✅ 每个主分片都有副本
✅ 主分片和副本不在同一节点
✅ 任意节点故障都不会丢失数据
```

### 6.4 分片策略最佳实践


| 场景 | 主分片数 | 副本数 | 说明 |
|------|---------|-------|------|
| **开发测试** | 1 | 0 | 简单快速 🔧 |
| **小型生产** | 3 | 1 | 平衡性能与安全 ⚖️ |
| **大型生产** | 5-10 | 1-2 | 高性能高可用 🚀 |

---

## 7. 🧭 路由与分段：数据的定位机制


### 7.1 路由 (Routing) - 数据的"导航系统"


**路由决定文档存储在哪个分片**：

```
路由算法:
shard_num = hash(routing_value) % primary_shards_count

默认路由值 = 文档ID
自定义路由值 = 用户指定字段
```

**路由示例**：

```
商品文档路由过程:

文档ID: "iphone_15_pro"
1. 计算哈希: hash("iphone_15_pro") = 12345
2. 取模运算: 12345 % 3 = 0  
3. 存储位置: 分片0

好处:
✅ 相同ID的文档总是存储在相同分片
✅ 查询时能直接定位到具体分片
✅ 避免扫描所有分片，提高效率
```

**自定义路由的应用**：

```
按用户ID路由订单数据:

POST /orders/_doc/order_001?routing=user_123

好处:
📍 同一用户的订单存储在同一分片
🔍 查询用户订单时只需搜索一个分片
⚡ 大幅提升查询性能
```

### 7.2 分段 (Segment) - 分片内部的"文件系统"


**分段是分片内部的最小存储单元**：

```
分片内部结构:
分片 (Shard)
├─ 分段1 (1000个文档)
├─ 分段2 (1500个文档)  
├─ 分段3 (800个文档)
└─ 分段4 (正在写入...)

每个分段都是不可变的
新增文档会创建新分段
定期合并小分段为大分段
```

**分段的生命周期**：

```
文档写入流程:
1. 新文档 → 内存缓冲区
2. 缓冲区满 → 创建新分段
3. 分段刷新 → 可被搜索
4. 后台合并 → 优化存储

分段合并过程:
小分段A + 小分段B → 大分段C
删除旧分段A和B
释放磁盘空间
```

---

## 8. 🔄 版本控制：数据的更新追踪


### 8.1 版本控制机制


**ES使用版本号追踪文档变化**：

```
文档版本变化示例:

创建文档:
PUT /products/_doc/1
{
  "name": "iPhone 15",
  "price": 5999
}
→ _version: 1

更新文档:  
PUT /products/_doc/1
{
  "name": "iPhone 15 Pro",
  "price": 7999
}
→ _version: 2

再次更新:
POST /products/_update/1
{
  "doc": {"price": 7599}
}
→ _version: 3
```

### 8.2 版本冲突处理


**乐观锁机制**：

```
并发更新冲突场景:

用户A读取文档 (version: 1)
用户B读取文档 (version: 1)
用户A更新文档 → version: 2 ✅
用户B尝试更新 → 版本冲突 ❌

解决方案:
1. 重新读取最新版本
2. 应用自己的修改
3. 再次尝试更新
```

**版本控制的实际应用**：

| 更新方式 | 版本处理 | 适用场景 |
|---------|---------|----------|
| **全量更新** | 自动递增 | 简单替换 🔄 |
| **部分更新** | 检查版本 | 字段修改 ✏️ |
| **条件更新** | 指定版本 | 并发控制 🛡️ |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🏢 架构层面:
├─ 集群: ES的"大家庭"，多个节点的联盟
├─ 节点: 集群中的"工作者"，承担不同角色
└─ 分工: 主节点管理，数据节点存储，协调节点路由

📁 数据层面:  
├─ 索引: 数据的"分类仓库"，类似数据库的表
├─ 文档: 数据的"基本单元"，JSON格式记录
└─ 字段: 文档的"属性"，定义数据的结构

🧩 存储层面:
├─ 分片: 数据的"分割存储"，实现水平扩展
├─ 副本: 数据的"备份保险"，保证高可用性
└─ 路由: 数据的"导航系统"，快速定位位置
```

### 9.2 关键理解要点


**🔹 ES vs 传统数据库的核心差异**：
```
设计理念:
传统数据库 → 事务一致性优先
Elasticsearch → 搜索性能优先

数据模型:
传统数据库 → 严格的表结构
Elasticsearch → 灵活的JSON文档

查询方式:
传统数据库 → SQL精确查询  
Elasticsearch → 全文搜索 + 相关性打分
```

**🔹 分布式存储的核心优势**：
```
水平扩展: 通过增加节点扩容 🚀
高可用性: 副本机制防止数据丢失 🛡️
高性能: 并行搜索提升速度 ⚡
容错能力: 节点故障自动恢复 🔄
```

### 9.3 新手学习建议


**📚 学习路径**：
1. **理解核心概念** - 集群、索引、文档的关系
2. **动手实践** - 创建索引，插入文档，搜索数据
3. **掌握映射** - 学会设计合理的字段结构
4. **优化配置** - 合理设置分片和副本数量

**💡 避免的常见误区**：
- ❌ 把ES当作传统数据库使用
- ❌ 不考虑映射直接存储数据
- ❌ 分片数量设置过多或过少
- ❌ 忽视版本控制的重要性

**🎯 实践建议**：
```
从小做起: 先用单节点学习基础概念
逐步扩展: 理解后再尝试集群部署  
多做实验: 通过实际操作加深理解
关注性能: 观察不同配置对性能的影响
```

**核心记忆口诀**：
```
集群管节点，节点存索引
索引含文档，文档有字段
分片来分散，副本保安全
路由定位置，版本控变化
```

> 🎉 **学习成果检验**
> 
> 如果你能用自己的话解释清楚"为什么一个商品文档总是能快速找到存储在哪个分片上"，说明你已经掌握了ES的核心工作原理！