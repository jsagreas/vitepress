---
title: 5、缓存机制与预热策略
---
## 📚 目录

1. [缓存机制基础概念](#1-缓存机制基础概念)
2. [查询缓存详解](#2-查询缓存详解)
3. [字段数据缓存](#3-字段数据缓存)
4. [请求缓存配置](#4-请求缓存配置)
5. [缓存监控与优化](#5-缓存监控与优化)
6. [预热策略设计](#6-预热策略设计)
7. [性能调优实践](#7-性能调优实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 缓存机制基础概念


### 1.1 什么是Elasticsearch缓存


**🔸 缓存的本质**
```
简单理解：缓存就像是一个"记忆本"
• 第一次查询：ES需要到磁盘找数据（慢）
• 后续查询：直接从内存拿结果（快）
• 目标：用内存换时间，提升查询速度
```

> 💡 **生活类比**：
> 缓存就像你桌上的常用文件夹，经常用的文档放桌上，用时直接拿；不常用的放柜子里，需要时才去翻找。

### 1.2 ES缓存体系架构


**🏗️ 缓存层次结构**
```
┌─────────────────────────────────────┐
│           应用层缓存                │ ← 应用程序缓存
├─────────────────────────────────────┤
│           查询缓存层                │ ← Query Cache
├─────────────────────────────────────┤
│         字段数据缓存层              │ ← Field Data Cache
├─────────────────────────────────────┤
│          请求缓存层                 │ ← Request Cache
├─────────────────────────────────────┤
│           分片缓存                  │ ← Shard Level
├─────────────────────────────────────┤
│          底层存储                   │ ← Lucene Segments
└─────────────────────────────────────┘
```

### 1.3 缓存类型概览


| 缓存类型 | **主要作用** | **缓存内容** | **生命周期** | **适用场景** |
|---------|-------------|-------------|-------------|-------------|
| 🔍 **查询缓存** | `加速重复查询` | `查询结果集` | `段级别` | `频繁重复查询` |
| 📊 **字段数据缓存** | `加速聚合排序` | `字段值数据` | `段级别` | `聚合分析场景` |
| 📨 **请求缓存** | `缓存整个响应` | `完整查询结果` | `索引级别` | `size=0的聚合查询` |
| 🔧 **节点级缓存** | `减少网络开销` | `跨分片数据` | `节点级别` | `分布式查询` |

---

## 2. 🔍 查询缓存详解


### 2.1 查询缓存工作原理


**🔸 工作流程**
```
用户查询请求
       ↓
检查查询缓存
       ↓
┌─命中缓存？─┐
│    是      │ → 直接返回缓存结果 ⚡
│           │
│    否      │ → 执行查询 → 存入缓存 → 返回结果
└───────────┘
```

> 🧠 **核心理解**：
> 查询缓存是在Lucene段级别工作的，相同的查询在相同的段上会被缓存。当段发生变化（如新增文档），相关缓存会失效。

### 2.2 查询缓存配置


**⚙️ 基础配置参数**
```yaml
# elasticsearch.yml 配置
indices.queries.cache.size: 10%        # 缓存大小占堆内存比例
indices.queries.cache.count: 1000      # 最大缓存查询数量
```

**🔧 索引级别配置**
```json
PUT /my_index/_settings
{
  "index": {
    "queries": {
      "cache": {
        "enabled": true           // 启用查询缓存
      }
    }
  }
}
```

### 2.3 查询缓存策略


**📋 什么查询会被缓存**
```
✅ 会缓存的查询：
• filter上下文中的查询
• bool查询中的filter子句
• constant_score查询
• 聚合中的filter

❌ 不会缓存的查询：
• query上下文中的查询（涉及评分）
• 脚本查询
• 时间相关的查询（如now）
• 随机查询
```

**💡 缓存命中优化技巧**
```json
// 推荐：使用filter上下文
GET /orders/_search
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "status": "completed" } },
        { "range": { "amount": { "gte": 100 } } }
      ]
    }
  }
}

// 不推荐：使用query上下文（不会缓存）
GET /orders/_search
{
  "query": {
    "bool": {
      "must": [
        { "term": { "status": "completed" } },
        { "range": { "amount": { "gte": 100 } } }
      ]
    }
  }
}
```

---

## 3. 📊 字段数据缓存


### 3.1 字段数据缓存原理


**🔸 核心概念**
```
字段数据缓存的作用：
• 聚合操作：计算sum、avg、max等
• 排序操作：按字段值排序
• 脚本操作：在脚本中访问字段值

存储内容：
• 字段的所有唯一值
• 文档到值的映射关系
• 倒排索引的"正排"版本
```

> 💭 **形象理解**：
> 倒排索引像字典（词→文档），字段数据缓存像花名册（文档→字段值），方便按字段值进行统计和排序。

### 3.2 字段数据缓存配置


**⚙️ 全局配置**
```yaml
# elasticsearch.yml
indices.fielddata.cache.size: 40%      # 字段数据缓存大小
indices.fielddata.cache.expire: -1     # 缓存过期时间（-1表示不过期）
```

**🔧 字段级别控制**
```json
PUT /my_index/_mapping
{
  "properties": {
    "description": {
      "type": "text",
      "fielddata": false        // 禁用大文本字段的fielddata
    },
    "category": {
      "type": "text",
      "fielddata": true,        // 启用fielddata
      "fielddata": {
        "loading": "eager"      // 预加载策略
      }
    }
  }
}
```

### 3.3 内存管理策略


**📈 内存使用监控**
```json
GET /_nodes/stats/indices/fielddata
```

**⚠️ 内存溢出预防**
```yaml
# 设置断路器保护
indices.breaker.fielddata.limit: 40%
indices.breaker.fielddata.overhead: 1.03
```

> ⚠️ **注意事项**：
> 字段数据缓存会消耗大量内存，特别是高基数字段（如用户ID）。建议对不需要聚合的text字段禁用fielddata。

---

## 4. 📨 请求缓存配置


### 4.1 请求缓存工作机制


**🔸 适用场景**
```
请求缓存最适合：
• size=0 的聚合查询
• 仪表板类应用
• 报表生成场景
• 相同查询重复执行

缓存键组成：
• 查询的JSON结构
• 目标分片的状态
• 索引设置版本
```

### 4.2 请求缓存配置


**⚙️ 全局启用**
```yaml
# elasticsearch.yml
indices.requests.cache.size: 1%        # 占堆内存比例
indices.requests.cache.expire: 1h      # 缓存过期时间
```

**🔧 索引级别配置**
```json
PUT /analytics_index/_settings
{
  "index": {
    "requests": {
      "cache": {
        "enable": true
      }
    }
  }
}
```

**💻 查询级别控制**
```json
// 强制使用缓存
GET /sales/_search?request_cache=true
{
  "size": 0,
  "aggs": {
    "monthly_sales": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"
      }
    }
  }
}

// 跳过缓存
GET /sales/_search?request_cache=false
{
  "size": 0,
  "aggs": {
    "realtime_stats": {
      "terms": { "field": "status" }
    }
  }
}
```

---

## 5. 📊 缓存监控与优化


### 5.1 缓存性能监控


**📈 关键监控指标**
```json
// 查看所有缓存统计
GET /_stats/query_cache,fielddata,request_cache

// 响应示例
{
  "indices": {
    "query_cache": {
      "memory_size_in_bytes": 52428800,     // 查询缓存内存占用
      "total_count": 15000,                 // 总查询次数
      "hit_count": 12000,                   // 缓存命中次数
      "miss_count": 3000,                   // 缓存未命中次数
      "cache_size": 500,                    // 缓存条目数
      "cache_count": 500,                   // 缓存总数
      "evictions": 50                       // 缓存驱逐次数
    }
  }
}
```

**🎯 缓存命中率计算**
```
缓存命中率 = hit_count / (hit_count + miss_count) × 100%

理想指标：
✅ 查询缓存命中率：> 70%
✅ 请求缓存命中率：> 80%
✅ 缓存驱逐次数：< 10% of cache_count
```

### 5.2 缓存清理管理


**🧹 手动清理缓存**
```bash
# 清理所有缓存
POST /_cache/clear

# 清理特定类型缓存
POST /_cache/clear?query=true&fielddata=true&request=true

# 清理特定索引缓存
POST /my_index/_cache/clear
```

**⏰ 自动清理策略**
```yaml
# 基于内存使用率的自动清理
indices.fielddata.cache.size: 40%
indices.breaker.fielddata.limit: 45%

# 基于时间的自动过期
indices.requests.cache.expire: 2h
```

---

## 6. 🚀 预热策略设计


### 6.1 什么是缓存预热


**🔸 预热概念**
```
缓存预热 = 提前把热点数据加载到缓存中

目标：
• 避免冷启动时的性能问题
• 减少用户等待时间
• 提升整体响应速度

时机：
• 集群重启后
• 新增节点后
• 业务高峰前
```

> 💡 **生活类比**：
> 就像冬天开车前先热车，让引擎达到最佳工作状态，缓存预热让ES在处理真实请求前就准备好热点数据。

### 6.2 预热策略实施


**📋 预热脚本示例**
```bash
#!/bin/bash
# ES缓存预热脚本

# 1. 预热常用查询
curl -X POST "localhost:9200/orders/_search" -H 'Content-Type: application/json' -d'
{
  "size": 0,
  "query": {
    "bool": {
      "filter": [
        { "range": { "date": { "gte": "now-7d" } } }
      ]
    }
  },
  "aggs": {
    "daily_orders": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "day"
      }
    }
  }
}
'

# 2. 预热字段数据
curl -X POST "localhost:9200/products/_search" -H 'Content-Type: application/json' -d'
{
  "size": 0,
  "aggs": {
    "categories": {
      "terms": { "field": "category.keyword" }
    }
  }
}
'
```

**⚙️ 自动预热配置**
```json
// 使用模板为新索引配置预热
PUT /_index_template/warmup_template
{
  "index_patterns": ["logs-*"],
  "settings": {
    "index": {
      "store.preload": ["*.doc", "*.tim"],     // 预加载段文件
      "queries.cache.enabled": true,
      "requests.cache.enable": true
    }
  }
}
```

### 6.3 预热监控与调整


**📊 预热效果评估**
```bash
# 监控预热进度
GET /_cat/fielddata?v&s=size:desc
GET /_nodes/stats/indices/query_cache

# 检查响应时间改善
before_warmup_time: 2000ms
after_warmup_time: 200ms
improvement: 90%
```

**🎯 预热策略优化**
```
优化原则：
• 只预热真正的热点数据
• 按业务优先级分批预热
• 监控内存使用避免过载
• 定期更新预热脚本

预热时间规划：
□ 核心业务查询：立即预热
□ 常用聚合：5分钟内完成
□ 历史数据查询：低峰时段预热
```

---

## 7. ⚡ 性能调优实践


### 7.1 缓存大小调优


**📊 内存分配建议**
```
总内存分配策略：

堆内存 (50% 系统内存)
├── 查询缓存: 5-10%     ← 高频查询多时可适当增加
├── 字段数据: 30-40%    ← 聚合操作多时需要更多
├── 请求缓存: 1-2%      ← 仪表板应用可适当增加
└── 其他ES组件: 剩余

剩余内存 (50% 系统内存)
└── 操作系统页缓存      ← Lucene段文件缓存
```

**⚙️ 动态调整示例**
```bash
# 运行时调整缓存大小
PUT /_cluster/settings
{
  "transient": {
    "indices.queries.cache.size": "15%",
    "indices.fielddata.cache.size": "35%"
  }
}
```

### 7.2 查询优化策略


**🎯 缓存友好的查询设计**
```json
// ✅ 推荐：使用filter上下文
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "status": "active" } },
        { "range": { "created_at": { "gte": "2023-01-01" } } }
      ]
    }
  }
}

// ✅ 推荐：分离可缓存和不可缓存部分
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "category": "electronics" } }    // 可缓存
      ],
      "must": [
        { "match": { "title": "smartphone" } }       // 评分查询
      ]
    }
  }
}
```

**⚠️ 避免缓存失效的陷阱**
```json
// ❌ 避免：时间相关查询
{
  "query": {
    "range": {
      "created_at": {
        "gte": "now-1d"    // 每次执行now值都不同，无法缓存
      }
    }
  }
}

// ✅ 改进：使用具体时间
{
  "query": {
    "range": {
      "created_at": {
        "gte": "2023-12-01T00:00:00Z"    // 固定值，可以缓存
      }
    }
  }
}
```

### 7.3 分片策略与缓存


**🔧 分片数量对缓存的影响**
```
分片越多 → 缓存分散 → 命中率下降
分片过少 → 单分片压力大 → 热点问题

最佳实践：
• 分片大小：20-50GB
• 缓存本地化：查询尽量命中相同分片
• 路由策略：相关数据分配到同一分片
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 缓存体系：查询缓存、字段数据缓存、请求缓存三大核心
🔸 工作原理：内存换时间，用空间换取查询速度
🔸 配置策略：合理分配内存，避免缓存争用
🔸 监控优化：持续监控命中率和内存使用
🔸 预热机制：主动预热热点数据，避免冷启动
```

### 8.2 关键配置参数


| 参数类型 | **推荐配置** | **适用场景** | **注意事项** |
|---------|-------------|-------------|-------------|
| 🔍 **查询缓存** | `10% 堆内存` | `频繁重复查询` | `只缓存filter上下文` |
| 📊 **字段数据** | `40% 堆内存` | `聚合分析多` | `注意高基数字段` |
| 📨 **请求缓存** | `1-2% 堆内存` | `仪表板应用` | `适合size=0查询` |
| 🛡️ **断路器** | `fielddata 45%` | `防止内存溢出` | `略高于缓存限制` |

### 8.3 性能优化检查清单


**🎯 日常优化要点**
```
□ 缓存命中率 > 70%
□ 内存使用率 < 80%
□ 缓存驱逐次数最小化
□ 查询使用filter上下文
□ 禁用不必要字段的fielddata
□ 定期清理无效缓存
□ 业务高峰前执行预热
□ 监控热点查询模式
```

### 8.4 常见问题与解决方案


**❌ 常见问题**
```
问题1：缓存命中率低
解决：检查查询是否使用filter，避免now等动态值

问题2：内存不足频繁GC
解决：调整缓存大小，启用断路器保护

问题3：冷启动性能差
解决：实施预热策略，预加载热点数据

问题4：聚合查询慢
解决：检查fielddata配置，优化字段映射
```

### 8.5 实际应用指导


**🚀 最佳实践**
```
设计原则：
• 缓存优先：优先设计可缓存的查询
• 监控驱动：基于监控数据调整配置
• 渐进优化：小步快跑，持续改进
• 业务匹配：缓存策略匹配业务模式

运维建议：
• 建立缓存监控告警
• 制定预热SOP流程
• 定期评估缓存效果
• 文档化配置变更
```

> 🔑 **一句话总结**：
> Elasticsearch缓存就像给查询加了"记忆功能"，第一次慢点没关系，后面越用越快，关键是要配置合理、监控到位、预热及时。

**核心记忆口诀**：
- 缓存三兄弟：查询、字段、请求
- 内存要分配，监控要跟上  
- 预热防冷启，优化无止境
- Filter好缓存，Now值要避免