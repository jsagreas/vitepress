---
title: 3、健康检查告警
---
## 📚 目录

1. [健康检查基础概念](#1-健康检查基础概念)
2. [进程状态检查](#2-进程状态检查)
3. [端口连通性检查](#3-端口连通性检查)
4. [数据处理延迟监控](#4-数据处理延迟监控)
5. [错误率监控](#5-错误率监控)
6. [资源使用检查](#6-资源使用检查)
7. [自动化监控脚本](#7-自动化监控脚本)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏥 健康检查基础概念


### 1.1 什么是健康检查


> **💡 简单理解**：健康检查就像定期给Logstash做体检，确保它工作正常

```
生活类比：
体检项目          →    Logstash健康检查
─────────────────────────────────────────
测量血压体温      →    检查进程状态
检查心跳          →    监控端口连通性
验血验尿          →    查看日志和错误
体能测试          →    检查处理性能
```

**核心作用**：
- **预防故障**：在问题变严重之前发现
- **保证稳定**：确保数据处理不中断
- **性能优化**：发现性能瓶颈并改进
- **快速恢复**：故障时能快速定位问题

### 1.2 健康检查的维度


**📊 六大检查维度**：

| 检查维度 | **检查内容** | **重要性** | **检查频率** |
|---------|-------------|-----------|-------------|
| 🔄 **进程状态** | `Logstash进程是否运行` | `极高` | `每分钟` |
| 🌐 **端口连通** | `输入输出端口是否正常` | `高` | `每5分钟` |
| ⏱️ **处理延迟** | `数据处理是否及时` | `高` | `每10分钟` |
| ❌ **错误率** | `处理过程中的错误情况` | `极高` | `实时监控` |
| 💾 **资源使用** | `CPU、内存、磁盘占用` | `中` | `每5分钟` |
| 📈 **吞吐量** | `每秒处理的数据量` | `中` | `每10分钟` |

---

## 2. 🔄 进程状态检查


### 2.1 基本进程检查


**什么是进程检查**：
确认Logstash主进程是否正在运行，就像检查一个人是否还有脉搏。

**Linux系统检查方法**：

```bash
# 方法1：使用ps命令查看进程
ps aux | grep logstash

# 方法2：使用systemctl检查服务状态
systemctl status logstash

# 方法3：使用pgrep精确查找
pgrep -f "logstash"
```

**检查脚本示例**：

```bash
#!/bin/bash
# logstash_process_check.sh

LOGSTASH_PROCESS=$(pgrep -f "logstash")

if [ -z "$LOGSTASH_PROCESS" ]; then
    echo "⚠️ 警告：Logstash进程未运行"
    # 发送告警通知
    echo "Logstash进程停止" | mail -s "Logstash告警" admin@company.com
    exit 1
else
    echo "✅ Logstash进程正常运行，PID: $LOGSTASH_PROCESS"
    exit 0
fi
```

### 2.2 进程资源占用检查


```bash
# 检查Logstash进程的资源使用情况
top -p $(pgrep -f logstash)

# 或者使用ps查看详细信息
ps -p $(pgrep -f logstash) -o pid,ppid,cmd,%mem,%cpu
```

---

## 3. 🌐 端口连通性检查


### 3.1 为什么要检查端口


> **📍 关键理解**：Logstash通过端口接收和发送数据，端口不通就像道路堵塞，数据无法流通

**常见端口配置**：
```
输入端口：
• Beats输入：5044
• Syslog输入：514
• HTTP输入：8080

输出端口：
• Elasticsearch：9200
• Kafka：9092
• Redis：6379
```

### 3.2 端口检查方法


**基本连通性检查**：

```bash
# 检查本地端口是否在监听
netstat -tlnp | grep :5044

# 检查远程端口是否可达
telnet elasticsearch-server 9200

# 使用nc命令测试
nc -zv elasticsearch-server 9200
```

**自动化端口检查脚本**：

```bash
#!/bin/bash
# port_connectivity_check.sh

# 定义要检查的端口
INPUT_PORTS="5044 8080"
OUTPUT_SERVERS="elasticsearch-server:9200 kafka-server:9092"

echo "🔍 开始检查Logstash端口连通性..."

# 检查输入端口
for port in $INPUT_PORTS; do
    if netstat -tlnp | grep ":$port" > /dev/null; then
        echo "✅ 输入端口 $port 正常监听"
    else
        echo "❌ 输入端口 $port 未监听"
    fi
done

# 检查输出连接
for server in $OUTPUT_SERVERS; do
    host=$(echo $server | cut -d':' -f1)
    port=$(echo $server | cut -d':' -f2)
    
    if nc -zv $host $port 2>/dev/null; then
        echo "✅ 输出连接 $server 正常"
    else
        echo "❌ 输出连接 $server 不可达"
    fi
done
```

### 3.3 端口监控告警


```bash
# 端口监控with告警
check_port_and_alert() {
    local port=$1
    local service_name=$2
    
    if ! netstat -tlnp | grep ":$port" > /dev/null; then
        # 发送告警
        curl -X POST "http://alertmanager:9093/api/v1/alerts" \
        -H "Content-Type: application/json" \
        -d '{
            "alerts": [{
                "labels": {
                    "alertname": "LogstashPortDown",
                    "service": "'$service_name'",
                    "port": "'$port'"
                },
                "annotations": {
                    "summary": "Logstash端口'$port'无法连接"
                }
            }]
        }'
    fi
}
```

---

## 4. ⏱️ 数据处理延迟监控


### 4.1 什么是处理延迟


> **💭 生活类比**：处理延迟就像餐厅出菜时间，点餐后等待时间越长，说明厨房越忙或有问题

**延迟的影响**：
- **数据时效性**：日志数据失去实时性
- **存储压力**：积压数据占用更多资源
- **业务影响**：监控告警延迟，影响故障处理

### 4.2 通过API监控延迟


**Logstash监控API**：

```bash
# 获取Logstash统计信息
curl -X GET "localhost:9600/_node/stats"

# 查看pipeline统计
curl -X GET "localhost:9600/_node/stats/pipelines"
```

**关键指标解读**：

```json
{
  "pipelines": {
    "main": {
      "events": {
        "in": 1000,           // 输入事件数
        "filtered": 950,      // 处理完成数
        "out": 900           // 输出事件数
      },
      "plugins": {
        "inputs": [...],
        "filters": [...],
        "outputs": [...]
      }
    }
  }
}
```

### 4.3 延迟监控脚本


```bash
#!/bin/bash
# latency_monitor.sh

# 获取当前统计
STATS=$(curl -s localhost:9600/_node/stats/pipelines)

# 提取关键指标
EVENTS_IN=$(echo $STATS | jq '.pipelines.main.events.in')
EVENTS_OUT=$(echo $STATS | jq '.pipelines.main.events.out')

# 计算积压数量
BACKLOG=$((EVENTS_IN - EVENTS_OUT))

echo "📊 当前处理状态："
echo "   输入事件: $EVENTS_IN"
echo "   输出事件: $EVENTS_OUT"
echo "   积压数量: $BACKLOG"

# 设置告警阈值
if [ $BACKLOG -gt 1000 ]; then
    echo "⚠️ 告警：数据积压超过1000个事件"
    # 发送告警通知
fi
```

---

## 5. ❌ 错误率监控


### 5.1 错误类型与来源


**常见错误类型**：

```
解析错误：
• Grok模式匹配失败
• JSON格式错误
• 时间戳解析失败

连接错误：
• Elasticsearch连接超时
• Kafka生产者错误
• 数据库连接失败

资源错误：
• 内存不足
• 磁盘空间不足
• 文件权限问题
```

### 5.2 日志错误监控


**Logstash日志位置**：
```bash
# 典型日志路径
/var/log/logstash/logstash-plain.log

# 查看最近的错误
tail -f /var/log/logstash/logstash-plain.log | grep ERROR

# 统计错误数量
grep ERROR /var/log/logstash/logstash-plain.log | wc -l
```

**错误监控脚本**：

```bash
#!/bin/bash
# error_rate_monitor.sh

LOG_FILE="/var/log/logstash/logstash-plain.log"
TIME_WINDOW=300  # 5分钟

echo "🔍 检查最近5分钟的错误情况..."

# 获取5分钟内的错误
RECENT_ERRORS=$(find $LOG_FILE -newermt "5 minutes ago" -exec grep -c "ERROR" {} \;)

echo "📈 错误统计："
echo "   时间窗口: 最近${TIME_WINDOW}秒"
echo "   错误数量: $RECENT_ERRORS"

# 设置错误率阈值
if [ $RECENT_ERRORS -gt 10 ]; then
    echo "🚨 高错误率告警：5分钟内发生${RECENT_ERRORS}个错误"
    
    # 显示最近的错误详情
    echo "📋 最近错误详情："
    tail -100 $LOG_FILE | grep ERROR | tail -5
fi
```

### 5.3 Pipeline错误监控


**通过API获取错误信息**：

```bash
# 查看pipeline错误统计
curl -s localhost:9600/_node/stats/pipelines | jq '.pipelines.main.events.failures'

# 查看详细的插件错误
curl -s localhost:9600/_node/stats/pipelines | jq '.pipelines.main.plugins.outputs[0].events.failures'
```

---

## 6. 💾 资源使用检查


### 6.1 内存使用监控


> **🧠 理解要点**：Logstash是Java程序，需要关注JVM内存使用情况

**内存检查命令**：

```bash
# 查看Logstash进程内存使用
ps -p $(pgrep -f logstash) -o pid,ppid,cmd,%mem,rss

# 查看JVM内存详情
curl -s localhost:9600/_node/jvm | jq '.mem'
```

**内存监控脚本**：

```bash
#!/bin/bash
# memory_monitor.sh

# 获取JVM内存信息
JVM_STATS=$(curl -s localhost:9600/_node/jvm)

HEAP_USED=$(echo $JVM_STATS | jq '.mem.heap_used_percent')
HEAP_MAX=$(echo $JVM_STATS | jq '.mem.heap_max_in_bytes')

echo "💾 内存使用情况："
echo "   堆内存使用率: ${HEAP_USED}%"
echo "   堆内存上限: $((HEAP_MAX / 1024 / 1024))MB"

# 内存告警阈值
if [ $(echo "$HEAP_USED > 85" | bc) -eq 1 ]; then
    echo "⚠️ 内存告警：堆内存使用率超过85%"
fi
```

### 6.2 CPU和磁盘监控


```bash
# CPU使用率检查
top -p $(pgrep -f logstash) -n 1

# 磁盘IO检查
iostat -p sda 1 1

# 磁盘空间检查
df -h /var/log/logstash
```

---

## 7. 🤖 自动化监控脚本


### 7.1 综合健康检查脚本


```bash
#!/bin/bash
# logstash_health_check.sh - 综合健康检查

echo "🏥 开始Logstash健康检查 $(date)"
echo "================================================"

# 颜色定义
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 检查结果计数
PASS_COUNT=0
FAIL_COUNT=0

# 1. 进程检查
echo "1️⃣ 检查进程状态..."
if pgrep -f "logstash" > /dev/null; then
    echo -e "${GREEN}✅ Logstash进程正常运行${NC}"
    ((PASS_COUNT++))
else
    echo -e "${RED}❌ Logstash进程未运行${NC}"
    ((FAIL_COUNT++))
fi

# 2. API可用性检查
echo "2️⃣ 检查API可用性..."
if curl -s localhost:9600/_node > /dev/null; then
    echo -e "${GREEN}✅ Logstash API正常${NC}"
    ((PASS_COUNT++))
else
    echo -e "${RED}❌ Logstash API不可用${NC}"
    ((FAIL_COUNT++))
fi

# 3. 内存检查
echo "3️⃣ 检查内存使用..."
HEAP_USED=$(curl -s localhost:9600/_node/jvm | jq -r '.mem.heap_used_percent // 0')
if [ $(echo "$HEAP_USED < 85" | bc) -eq 1 ]; then
    echo -e "${GREEN}✅ 内存使用正常 (${HEAP_USED}%)${NC}"
    ((PASS_COUNT++))
else
    echo -e "${YELLOW}⚠️ 内存使用偏高 (${HEAP_USED}%)${NC}"
    ((FAIL_COUNT++))
fi

# 4. 数据处理检查
echo "4️⃣ 检查数据处理..."
EVENTS_IN=$(curl -s localhost:9600/_node/stats/pipelines | jq -r '.pipelines.main.events.in // 0')
EVENTS_OUT=$(curl -s localhost:9600/_node/stats/pipelines | jq -r '.pipelines.main.events.out // 0')
BACKLOG=$((EVENTS_IN - EVENTS_OUT))

if [ $BACKLOG -lt 1000 ]; then
    echo -e "${GREEN}✅ 数据处理正常 (积压:${BACKLOG})${NC}"
    ((PASS_COUNT++))
else
    echo -e "${YELLOW}⚠️ 数据积压较多 (积压:${BACKLOG})${NC}"
    ((FAIL_COUNT++))
fi

# 结果汇总
echo "================================================"
echo "📊 健康检查结果汇总："
echo -e "   通过: ${GREEN}${PASS_COUNT}项${NC}"
echo -e "   失败: ${RED}${FAIL_COUNT}项${NC}"

# 总体健康状态判断
if [ $FAIL_COUNT -eq 0 ]; then
    echo -e "${GREEN}🎉 Logstash健康状态：良好${NC}"
    exit 0
elif [ $FAIL_COUNT -le 2 ]; then
    echo -e "${YELLOW}⚠️ Logstash健康状态：注意${NC}"
    exit 1
else
    echo -e "${RED}🚨 Logstash健康状态：异常${NC}"
    exit 2
fi
```

### 7.2 定时监控配置


**crontab配置示例**：

```bash
# 编辑定时任务
crontab -e

# 添加监控任务
# 每5分钟执行一次健康检查
*/5 * * * * /opt/scripts/logstash_health_check.sh >> /var/log/logstash_monitor.log 2>&1

# 每小时生成健康报告
0 * * * * /opt/scripts/logstash_health_report.sh
```

### 7.3 告警集成


**与钉钉集成的告警脚本**：

```bash
#!/bin/bash
# dingtalk_alert.sh

WEBHOOK_URL="https://oapi.dingtalk.com/robot/send?access_token=YOUR_TOKEN"
MESSAGE="$1"
LEVEL="$2"  # info, warning, error

# 根据级别设置颜色
case $LEVEL in
    "error")
        COLOR="red"
        EMOJI="🚨"
        ;;
    "warning")
        COLOR="yellow"
        EMOJI="⚠️"
        ;;
    *)
        COLOR="green"
        EMOJI="ℹ️"
        ;;
esac

# 发送告警消息
curl -X POST $WEBHOOK_URL \
    -H 'Content-Type: application/json' \
    -d '{
        "msgtype": "markdown",
        "markdown": {
            "title": "Logstash监控告警",
            "text": "## '$EMOJI' Logstash监控告警\n\n**告警时间:** '$(date)'\n\n**告警内容:** '$MESSAGE'\n\n**服务器:** '$(hostname)'"
        }
    }'
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的监控要点


```
🔸 进程监控：确保Logstash主进程持续运行
🔸 端口检查：验证输入输出端口的连通性
🔸 延迟监控：关注数据处理的实时性
🔸 错误监控：及时发现和处理各类错误
🔸 资源监控：避免内存、CPU、磁盘资源耗尽
🔸 自动化脚本：实现7×24小时无人值守监控
```

### 8.2 监控最佳实践


**📈 监控策略建议**：

| 监控项目 | **检查频率** | **告警阈值** | **处理优先级** |
|---------|-------------|-------------|---------------|
| 🔄 **进程状态** | `1分钟` | `进程停止` | `P0 - 立即处理` |
| 🌐 **端口连通** | `5分钟` | `端口不通` | `P1 - 30分钟内` |
| ⏱️ **处理延迟** | `10分钟` | `积压>1000` | `P2 - 1小时内` |
| ❌ **错误率** | `实时` | `5分钟>10个错误` | `P1 - 30分钟内` |
| 💾 **内存使用** | `5分钟` | `堆内存>85%` | `P2 - 1小时内` |

### 8.3 故障处理流程


```
监控告警触发流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   监控脚本   │───▶│   告警系统   │───▶│   运维人员   │
│  定期检查   │    │  推送通知   │    │  故障处理   │
└─────────────┘    └─────────────┘    └─────────────┘
        │                  │                  │
        ▼                  ▼                  ▼
    健康检查           钉钉/邮件           问题定位
    性能统计           短信/电话           快速修复
    异常捕获           工单系统           服务恢复
```

### 8.4 实际应用价值


**🎯 监控的业务价值**：
- **预防故障**：在服务完全停止前发现问题
- **快速恢复**：缩短故障发现和处理时间
- **性能优化**：基于监控数据调优配置
- **容量规划**：根据资源使用趋势扩容
- **合规要求**：满足服务可用性SLA要求

**🔧 运维实践要点**：
- **分层监控**：系统级 + 应用级 + 业务级
- **阈值调优**：根据实际情况调整告警阈值
- **告警收敛**：避免告警风暴，合理设置告警频率
- **监控覆盖**：确保关键指标无遗漏
- **文档完善**：维护监控和告警处理手册

> **💡 核心记忆**：
> 
> 健康检查六要素：进程、端口、延迟、错误、资源、自动化
> 
> 监控三原则：及时发现、快速定位、迅速恢复
> 
> 告警四层级：P0立即、P1半小时、P2一小时、P3次日处理