---
title: 4、条件逻辑控制
---
## 📚 目录

1. [条件逻辑基础概念](#1-条件逻辑基础概念)
2. [if/else条件语句详解](#2-ifelse条件语句详解)
3. [字段存在性判断](#3-字段存在性判断)
4. [逻辑运算符应用](#4-逻辑运算符应用)
5. [正则匹配条件](#5-正则匹配条件)
6. [范围比较判断](#6-范围比较判断)
7. [嵌套条件处理](#7-嵌套条件处理)
8. [实际应用场景](#8-实际应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 条件逻辑基础概念


### 1.1 什么是条件逻辑控制


**通俗理解**：就像我们生活中的"如果...那么..."逻辑

```
生活中的条件逻辑：
如果下雨了 → 那么带伞
如果是工作日 → 那么早起上班
如果温度超过30度 → 那么开空调

Logstash中的条件逻辑：
如果日志来自nginx → 那么用nginx解析器
如果错误级别是ERROR → 那么发送告警
如果字段不存在 → 那么添加默认值
```

### 1.2 为什么需要条件逻辑


**🔸 解决的核心问题**：
- **数据分类处理**：不同类型的日志用不同方式处理
- **灵活性控制**：根据数据内容决定处理流程
- **错误处理**：当数据有问题时的应对策略
- **性能优化**：避免不必要的处理步骤

**💡 实际应用场景**：
```
场景1：多种日志格式混合
- Apache访问日志 → 用Apache解析器
- Nginx访问日志 → 用Nginx解析器
- 应用程序日志 → 用JSON解析器

场景2：错误级别分类
- INFO级别 → 正常存储
- WARN级别 → 存储并标记
- ERROR级别 → 存储、标记、发送告警

场景3：数据清洗
- 字段为空 → 设置默认值
- 字段格式错误 → 修正或丢弃
- 敏感信息 → 脱敏处理
```

### 1.3 条件逻辑的基本语法结构


**📋 基础语法模板**：
```ruby
filter {
  if [字段名] 条件操作符 值 {
    # 条件为真时执行的操作
  } else {
    # 条件为假时执行的操作
  }
}
```

**🔧 语法要点**：
- 字段名用方括号 `[]` 包围
- 条件操作符有 `==`、`!=`、`>`、`<` 等
- 大括号 `{}` 包围执行的操作
- `else` 部分是可选的

---

## 2. 🔀 if/else条件语句详解


### 2.1 基本if语句


**🔸 单一条件判断**：

```ruby
filter {
  if [log_level] == "ERROR" {
    mutate {
      add_tag => ["error_log"]
    }
  }
}
```

**解释说明**：
- 检查 `log_level` 字段是否等于 "ERROR"
- 如果是，就给这条日志添加一个 "error_log" 标签
- 相当于给错误日志贴个标签，方便后续处理

### 2.2 if/else语句


**🔸 二选一处理**：

```ruby
filter {
  if [response_code] >= 400 {
    mutate {
      add_field => { "status_type" => "error" }
    }
  } else {
    mutate {
      add_field => { "status_type" => "success" }
    }
  }
}
```

**通俗解释**：
- 就像看HTTP状态码决定请求是否成功
- 如果状态码大于等于400，标记为错误
- 否则标记为成功
- 每条日志都会被分类

### 2.3 if/else if/else语句


**🔸 多重条件判断**：

```ruby
filter {
  if [log_level] == "ERROR" {
    mutate {
      add_field => { "priority" => "high" }
    }
  } else if [log_level] == "WARN" {
    mutate {
      add_field => { "priority" => "medium" }
    }
  } else {
    mutate {
      add_field => { "priority" => "low" }
    }
  }
}
```

**实际含义**：
- 根据日志级别设置优先级
- ERROR → 高优先级
- WARN → 中优先级
- 其他 → 低优先级

### 2.4 条件语句的嵌套使用


**🔸 复杂业务逻辑**：

```ruby
filter {
  if [source] == "nginx" {
    if [response_code] >= 500 {
      mutate {
        add_tag => ["nginx_server_error"]
      }
    } else if [response_code] >= 400 {
      mutate {
        add_tag => ["nginx_client_error"]
      }
    }
  }
}
```

**业务逻辑说明**：
- 先判断是否来自nginx
- 如果是nginx日志，再细分错误类型
- 500+错误标记为服务器错误
- 400+错误标记为客户端错误

---

## 3. ✅ 字段存在性判断


### 3.1 检查字段是否存在


**🔸 基本存在性检查**：

```ruby
filter {
  if [user_id] {
    # 字段存在时的处理
    mutate {
      add_field => { "has_user" => "true" }
    }
  }
}
```

**通俗理解**：
- 就像检查"这个人有没有身份证"
- 如果 `user_id` 字段存在（不管是什么值），就执行操作
- 即使值是空字符串，也算"存在"

### 3.2 检查字段是否不存在


**🔸 缺失字段处理**：

```ruby
filter {
  if ![timestamp] {
    # 字段不存在时的处理
    mutate {
      add_field => { "timestamp" => "%{@timestamp}" }
    }
  }
}
```

**实际应用**：
- 感叹号 `!` 表示"不"
- 如果没有时间戳字段，就用系统时间补充
- 这样确保每条日志都有时间信息

### 3.3 检查字段值是否为空


**🔸 空值处理**：

```ruby
filter {
  if [message] == "" {
    # 字段为空字符串
    mutate {
      update => { "message" => "empty_message" }
    }
  }
}
```

### 3.4 组合存在性和值判断


**🔸 完整的字段检查**：

```ruby
filter {
  if [user_id] and [user_id] != "" {
    # 字段存在且不为空
    mutate {
      add_tag => ["valid_user"]
    }
  } else {
    # 字段不存在或为空
    mutate {
      add_tag => ["anonymous_user"]
    }
  }
}
```

**实际场景**：
- 像检查用户是否真的登录了
- 既要有用户ID字段，又要ID不是空的
- 这样才算有效用户

---

## 4. ⚡ 逻辑运算符应用


### 4.1 AND逻辑运算符


**🔸 多个条件同时满足**：

```ruby
filter {
  if [status] == "active" and [age] >= 18 {
    mutate {
      add_tag => ["adult_active_user"]
    }
  }
}
```

**生活比喻**：
- 就像招聘要求"既要有经验，又要年龄合适"
- 只有当状态是活跃**并且**年龄大于等于18时，才执行操作
- 两个条件缺一不可

### 4.2 OR逻辑运算符


**🔸 多个条件满足其一**：

```ruby
filter {
  if [log_level] == "ERROR" or [log_level] == "FATAL" {
    mutate {
      add_field => { "is_critical" => "true" }
    }
  }
}
```

**通俗理解**：
- 就像"要么是错误，要么是致命错误，都算严重问题"
- 只要满足其中一个条件就执行
- 相当于把ERROR和FATAL都归类为严重问题

### 4.3 NOT逻辑运算符


**🔸 条件取反**：

```ruby
filter {
  if ![processed] {
    # 等同于 if not [processed]
    mutate {
      add_field => { "processed" => "false" }
      add_tag => ["unprocessed"]
    }
  }
}
```

### 4.4 复杂逻辑组合


**🔸 括号控制优先级**：

```ruby
filter {
  if ([log_level] == "ERROR" or [log_level] == "WARN") and [source] == "application" {
    mutate {
      add_tag => ["app_issue"]
    }
  }
}
```

**逻辑分析**：
- 先判断是ERROR或WARN（括号内）
- 再判断来源是否为application
- 只有应用程序的错误或警告才标记为应用问题

---

## 5. 🔍 正则匹配条件


### 5.1 基本正则匹配


**🔸 模式匹配操作符 `=~`**：

```ruby
filter {
  if [message] =~ /^ERROR/ {
    mutate {
      add_tag => ["starts_with_error"]
    }
  }
}
```

**正则解释**：
- `=~` 表示"匹配这个模式"
- `/^ERROR/` 是正则表达式，表示以ERROR开头
- `^` 表示行开始，`ERROR` 是字面文本
- 相当于检查消息是否以"ERROR"开头

### 5.2 正则不匹配


**🔸 不匹配操作符 `!~`**：

```ruby
filter {
  if [user_agent] !~ /bot|crawler|spider/i {
    mutate {
      add_tag => ["real_user"]
    }
  }
}
```

**含义说明**：
- `!~` 表示"不匹配这个模式"
- `/bot|crawler|spider/i` 匹配包含bot、crawler或spider的文本
- `|` 表示"或者"，`i` 表示忽略大小写
- 相当于过滤掉爬虫，保留真实用户

### 5.3 常用正则表达式模式


**📋 实用正则模式表**：

| 模式 | 含义 | 示例 |
|------|------|------|
| `^text` | 以text开头 | `^ERROR` 匹配"ERROR: something" |
| `text$` | 以text结尾 | `\.log$` 匹配"app.log" |
| `\d+` | 一个或多个数字 | `\d+` 匹配"123" |
| `\w+` | 一个或多个字母数字 | `\w+` 匹配"user123" |
| `.*` | 任意字符任意次数 | `error.*failed` 匹配"error in process failed" |

### 5.4 实际正则应用场景


**🔸 IP地址匹配**：

```ruby
filter {
  if [client_ip] =~ /^192\.168\./ {
    mutate {
      add_tag => ["internal_network"]
    }
  }
}
```

**🔸 邮箱格式验证**：

```ruby
filter {
  if [email] =~ /@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/ {
    mutate {
      add_tag => ["valid_email"]
    }
  }
}
```

**🔸 文件类型判断**：

```ruby
filter {
  if [filename] =~ /\.(jpg|png|gif)$/i {
    mutate {
      add_field => { "file_type" => "image" }
    }
  }
}
```

---

## 6. 📊 范围比较判断


### 6.1 数值比较操作符


**📋 比较操作符完整列表**：

| 操作符 | 含义 | 示例 | 说明 |
|--------|------|------|------|
| `==` | 等于 | `[age] == 25` | 精确匹配 |
| `!=` | 不等于 | `[status] != "ok"` | 排除特定值 |
| `>` | 大于 | `[price] > 100` | 数值比较 |
| `>=` | 大于等于 | `[score] >= 90` | 包含边界值 |
| `<` | 小于 | `[count] < 10` | 数值比较 |
| `<=` | 小于等于 | `[level] <= 5` | 包含边界值 |

### 6.2 字符串长度判断


**🔸 检查字符串长度**：

```ruby
filter {
  # 字符串长度转换为数字比较
  if [message] and [message] != "" {
    ruby {
      code => "event.set('message_length', event.get('message').length)"
    }
    
    if [message_length] > 1000 {
      mutate {
        add_tag => ["long_message"]
      }
    }
  }
}
```

**实际用途**：
- 识别特别长的日志消息
- 可能是错误堆栈或异常信息
- 需要特殊处理或存储策略

### 6.3 时间范围判断


**🔸 基于时间的条件**：

```ruby
filter {
  # 获取小时数（0-23）
  ruby {
    code => "event.set('hour', Time.parse(event.get('@timestamp').to_s).hour)"
  }
  
  if [hour] >= 9 and [hour] <= 17 {
    mutate {
      add_field => { "business_hours" => "true" }
    }
  } else {
    mutate {
      add_field => { "business_hours" => "false" }
    }
  }
}
```

**业务场景**：
- 区分工作时间和非工作时间的日志
- 非工作时间的错误可能需要特别关注
- 帮助分析系统使用模式

### 6.4 范围区间判断


**🔸 HTTP状态码分类**：

```ruby
filter {
  if [response_code] >= 200 and [response_code] < 300 {
    mutate { add_field => { "status_category" => "success" } }
  } else if [response_code] >= 300 and [response_code] < 400 {
    mutate { add_field => { "status_category" => "redirect" } }
  } else if [response_code] >= 400 and [response_code] < 500 {
    mutate { add_field => { "status_category" => "client_error" } }
  } else if [response_code] >= 500 {
    mutate { add_field => { "status_category" => "server_error" } }
  }
}
```

**分类逻辑**：
- 200-299：成功响应
- 300-399：重定向
- 400-499：客户端错误
- 500+：服务器错误

---

## 7. 🔄 嵌套条件处理


### 7.1 多层嵌套结构


**🔸 复杂业务逻辑示例**：

```ruby
filter {
  if [source] == "web_server" {
    # 第一层：判断来源
    
    if [response_code] {
      # 第二层：检查是否有状态码
      
      if [response_code] >= 500 {
        # 第三层：服务器错误处理
        mutate {
          add_tag => ["web_server_error"]
          add_field => { "alert_level" => "critical" }
        }
        
        if [response_time] > 5000 {
          # 第四层：响应时间检查
          mutate {
            add_tag => ["slow_response"]
          }
        }
      }
    }
  }
}
```

**结构分析**：
```
web_server日志
    ├── 有状态码
    │   ├── 500+错误
    │   │   ├── 标记为服务器错误
    │   │   └── 响应时间>5秒 → 标记慢响应
    │   └── 其他状态码 → 正常处理
    └── 无状态码 → 跳过处理
```

### 7.2 避免过度嵌套


**❌ 不推荐的深层嵌套**：
```ruby
# 这种写法可读性差，难以维护
if [a] {
  if [b] {
    if [c] {
      if [d] {
        # 太深了！
      }
    }
  }
}
```

**✅ 推荐的平铺写法**：
```ruby
# 使用逻辑运算符减少嵌套
if [a] and [b] and [c] and [d] {
  # 清晰易读
}
```

### 7.3 条件组合最佳实践


**🔸 日志路由示例**：

```ruby
filter {
  # 应用程序错误日志
  if [source] == "application" and [log_level] == "ERROR" {
    mutate {
      add_tag => ["app_error"]
    }
    
    # 进一步分类
    if [exception_type] {
      mutate {
        add_field => { "error_category" => "%{exception_type}" }
      }
    }
  }
  
  # 数据库慢查询日志
  if [source] == "database" and [query_time] and [query_time] > 1000 {
    mutate {
      add_tag => ["slow_query"]
      add_field => { "performance_issue" => "true" }
    }
  }
  
  # 安全相关日志
  if [log_type] == "security" or [message] =~ /login|authentication|authorization/i {
    mutate {
      add_tag => ["security_event"]
    }
  }
}
```

---

## 8. 🚀 实际应用场景


### 8.1 多源日志分类处理


**🎯 场景描述**：一个系统收集来自不同服务的日志

```ruby
filter {
  # 根据日志来源进行不同处理
  if [fields][service] == "nginx" {
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
    }
    
    if [response] >= 400 {
      mutate {
        add_tag => ["http_error"]
      }
    }
  } else if [fields][service] == "mysql" {
    grok {
      match => { "message" => "%{MYSQL_ERROR}" }
    }
    
    if [message] =~ /slow query/i {
      mutate {
        add_tag => ["slow_query"]
      }
    }
  } else if [fields][service] == "application" {
    if [message] =~ /^{.*}$/ {
      # JSON格式日志
      json {
        source => "message"
      }
    }
  }
}
```

### 8.2 数据清洗和标准化


**🧹 清洗脏数据**：

```ruby
filter {
  # 处理缺失的用户ID
  if ![user_id] or [user_id] == "" or [user_id] == "null" {
    mutate {
      update => { "user_id" => "anonymous" }
    }
  }
  
  # 标准化日志级别
  if [level] {
    if [level] =~ /^(error|err|e)$/i {
      mutate { update => { "level" => "ERROR" } }
    } else if [level] =~ /^(warn|warning|w)$/i {
      mutate { update => { "level" => "WARN" } }
    } else if [level] =~ /^(info|information|i)$/i {
      mutate { update => { "level" => "INFO" } }
    }
  }
  
  # 处理异常的响应时间
  if [response_time] and [response_time] < 0 {
    mutate {
      remove_field => ["response_time"]
      add_tag => ["invalid_response_time"]
    }
  }
}
```

### 8.3 安全事件检测


**🔒 安全监控规则**：

```ruby
filter {
  # 检测可疑的登录活动
  if [event_type] == "login" {
    if [login_result] == "failed" {
      mutate {
        add_tag => ["failed_login"]
      }
      
      # 检测暴力破解
      if [attempt_count] and [attempt_count] > 5 {
        mutate {
          add_tag => ["brute_force_attempt"]
          add_field => { "security_alert" => "high" }
        }
      }
    }
  }
  
  # 检测异常访问模式
  if [request_path] and [request_path] =~ /\.\./  {
    mutate {
      add_tag => ["path_traversal_attempt"]
      add_field => { "security_alert" => "critical" }
    }
  }
  
  # 检测SQL注入尝试
  if [query_string] and [query_string] =~ /(union|select|insert|delete|drop)/i {
    mutate {
      add_tag => ["sql_injection_attempt"]
      add_field => { "security_alert" => "critical" }
    }
  }
}
```

### 8.4 性能监控和告警


**📈 性能指标监控**：

```ruby
filter {
  # 应用响应时间监控
  if [response_time] and [response_time] > 5000 {
    mutate {
      add_tag => ["slow_response"]
    }
    
    if [response_time] > 10000 {
      mutate {
        add_field => { "alert_level" => "critical" }
        add_tag => ["performance_critical"]
      }
    } else {
      mutate {
        add_field => { "alert_level" => "warning" }
      }
    }
  }
  
  # 内存使用监控
  if [memory_usage_percent] and [memory_usage_percent] > 90 {
    mutate {
      add_tag => ["high_memory_usage"]
      add_field => { "resource_alert" => "memory" }
    }
  }
  
  # 磁盘空间监控
  if [disk_usage_percent] and [disk_usage_percent] > 85 {
    mutate {
      add_tag => ["low_disk_space"]
      add_field => { "resource_alert" => "disk" }
    }
  }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 条件逻辑：根据数据内容决定处理方式的控制结构
🔸 if/else语句：最基础的条件判断，支持多重嵌套
🔸 字段存在性：检查字段是否存在、是否为空的重要技巧
🔸 逻辑运算符：and、or、not的组合使用
🔸 正则匹配：强大的模式匹配能力，用于文本分析
🔸 范围比较：数值大小比较，时间范围判断等
```

### 9.2 关键理解要点


**🔹 条件逻辑的本质作用**：
- **数据分流**：把不同类型的数据送到不同的处理流程
- **质量控制**：检查数据完整性，处理异常情况
- **业务规则**：实现复杂的业务逻辑和分类规则
- **性能优化**：避免不必要的处理，提高效率

**🔹 语法使用技巧**：
```
字段引用：[字段名] 用方括号
字符串比较：用引号包围 "value"
数值比较：直接使用数字 100
正则表达式：用斜杠包围 /pattern/
逻辑组合：用括号控制优先级 (A or B) and C
```

**🔹 实际应用原则**：
- **先检查存在性**：避免空字段导致的错误
- **合理使用嵌套**：过深的嵌套影响可读性
- **善用逻辑运算符**：减少重复的条件判断
- **正则表达式要简洁**：复杂的正则影响性能

### 9.3 常见使用模式


**📊 典型应用模式表**：

| 应用场景 | 常用条件 | 处理方式 |
|----------|----------|----------|
| **日志分类** | `[source] == "nginx"` | 不同解析器 |
| **错误过滤** | `[level] == "ERROR"` | 添加标签、告警 |
| **数据清洗** | `![field]` 或 `[field] == ""` | 设置默认值 |
| **性能监控** | `[response_time] > 5000` | 性能标记 |
| **安全检测** | 正则匹配可疑模式 | 安全告警 |
| **时间分段** | 时间范围判断 | 业务时间标记 |

### 9.4 最佳实践建议


**💡 编写高质量条件逻辑的要点**：

✅ **先验证后使用**：
```ruby
# 好的做法
if [field] and [field] != "" {
  # 使用字段
}

# 避免的做法
if [field] == "some_value" {
  # 如果字段不存在会出错
}
```

✅ **使用有意义的标签**：
```ruby
# 清晰的标签名
add_tag => ["nginx_server_error"]
add_tag => ["slow_database_query"]

# 避免模糊的标签名
add_tag => ["error"]
add_tag => ["slow"]
```

✅ **合理组织条件结构**：
```ruby
# 按业务逻辑分组
if [source] == "application" {
  # 应用程序相关的所有条件判断
}

if [source] == "database" {
  # 数据库相关的所有条件判断
}
```

**核心记忆要点**：
- 条件逻辑是Logstash数据处理的"大脑"
- 合理的条件判断让数据处理更智能、更灵活
- 掌握基本语法，结合实际业务场景练习
- 注重代码可读性和维护性，避免过度复杂的嵌套