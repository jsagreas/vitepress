---
title: 11、JSON过滤器配置
---
## 📚 目录

1. [JSON过滤器基础概念](#1-JSON过滤器基础概念)
2. [核心参数详解](#2-核心参数详解)
3. [基础配置与使用](#3-基础配置与使用)
4. [高级配置技巧](#4-高级配置技巧)
5. [错误处理与调试](#5-错误处理与调试)
6. [实战应用场景](#6-实战应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 JSON过滤器基础概念


### 1.1 什么是JSON过滤器


**🔸 简单理解**
JSON过滤器就像一个**"JSON字符串拆包工具"**，它能把存储在某个字段中的JSON字符串解析成结构化的数据。

```
想象一下：
原始数据：message字段包含 '{"name":"张三","age":25,"city":"北京"}'
经过JSON过滤器处理后：
- name: 张三
- age: 25  
- city: 北京
```

**💡 为什么需要JSON过滤器**
- **日志中的JSON**：很多应用程序会把结构化数据以JSON格式写入日志
- **API响应数据**：接口返回的JSON响应需要解析成字段
- **配置文件内容**：配置信息以JSON格式存储在日志中
- **数据库查询结果**：查询结果以JSON格式记录

### 1.2 工作原理


**🔄 处理流程**
```
输入阶段                     处理阶段                    输出阶段
┌─────────────┐             ┌─────────────┐            ┌─────────────┐
│   原始事件   │  ────────>  │ JSON过滤器  │  ────────> │  解析后事件  │
│ message字段 │             │   解析器    │            │  新增字段   │
└─────────────┘             └─────────────┘            └─────────────┘
```

**🎯 核心作用**
- **解析**：将JSON字符串转换为Logstash事件字段
- **扩展**：为事件增加新的结构化字段
- **转换**：将非结构化文本转为可查询的结构化数据

---

## 2. ⚙️ 核心参数详解


### 2.1 source参数 - JSON源字段


**🔸 参数含义**
`source` 指定包含JSON字符串的字段名称，这是**必填参数**。

```ruby
filter {
  json {
    source => "message"    # 从message字段中读取JSON字符串
  }
}
```

**💭 通俗理解**
就像告诉工具："我的JSON数据放在哪个盒子里"。Logstash会去这个指定的"盒子"(字段)里找JSON字符串进行解析。

**📝 实际示例**
```
原始日志：
{
  "timestamp": "2024-01-01T10:00:00",
  "message": "{\"user\":\"admin\",\"action\":\"login\",\"ip\":\"192.168.1.1\"}"
}

配置：
source => "message"

解析结果：会从message字段中提取JSON并解析
```

### 2.2 target参数 - 解析目标字段


**🔸 参数含义**
`target` 指定解析后的JSON数据存放的目标字段，**可选参数**。

| 配置方式 | 结果说明 | 适用场景 |
|---------|---------|---------|
| **不设置target** | 解析的字段直接添加到事件根级别 | 简单JSON，字段不冲突 |
| **设置target** | 解析的字段放在指定的嵌套对象中 | 复杂JSON，避免字段冲突 |

**🔧 配置对比**

不设置target：
```ruby
filter {
  json {
    source => "message"
    # 不设置target
  }
}
```

设置target：
```ruby
filter {
  json {
    source => "message"
    target => "parsed_data"    # 解析结果放入parsed_data字段
  }
}
```

**📊 效果对比**

```
原始JSON: {"name":"张三","age":25}

不设置target的结果：
{
  "message": "{\"name\":\"张三\",\"age\":25}",
  "name": "张三",        ← 直接添加到根级别
  "age": 25
}

设置target的结果：
{
  "message": "{\"name\":\"张三\",\"age\":25}",
  "parsed_data": {       ← 放在嵌套对象中
    "name": "张三",
    "age": 25
  }
}
```

### 2.3 skip_on_invalid_json参数 - 跳过无效JSON


**🔸 参数含义**
当遇到无效的JSON格式时，是否跳过不处理，**默认值为false**。

```ruby
filter {
  json {
    source => "message"
    skip_on_invalid_json => true    # 遇到无效JSON就跳过
  }
}
```

**⚖️ 行为对比**

| 参数值 | 遇到无效JSON时的行为 | 适用场景 |
|-------|------------------|---------|
| **false**(默认) | 会添加`_jsonparsefailure`标签 | 需要知道哪些数据解析失败 |
| **true** | 静默跳过，不做任何处理 | 数据质量参差不齐，只处理有效JSON |

**🧪 实际测试**

假设有无效JSON数据：`{"name":"张三",age:}`  (缺少age的值)

`skip_on_invalid_json => false` 的结果：
```
{
  "message": "{\"name\":\"张三\",age:}",
  "tags": ["_jsonparsefailure"]    ← 会添加失败标签
}
```

`skip_on_invalid_json => true` 的结果：
```
{
  "message": "{\"name\":\"张三\",age:}"    ← 保持原样，没有任何处理
}
```

### 2.4 tag_on_failure参数 - 失败标签设置


**🔸 参数含义**
自定义解析失败时添加的标签，**默认为["_jsonparsefailure"]**。

```ruby
filter {
  json {
    source => "message"
    tag_on_failure => ["json_error", "parse_failed"]    # 自定义失败标签
  }
}
```

**🏷️ 标签的作用**
标签就像给数据贴上**"分类标签"**，方便后续：
- **筛选处理**：只处理带特定标签的事件
- **错误统计**：统计解析失败的数量
- **调试分析**：快速定位问题数据

**📈 使用建议**

```ruby
# 基础配置 - 使用默认标签
json {
  source => "message"
}

# 进阶配置 - 自定义有意义的标签
json {
  source => "api_response"
  tag_on_failure => ["api_json_error", "需要人工检查"]
}
```

---

## 3. 🛠️ 基础配置与使用


### 3.1 最简单的配置


**🎯 基础语法**
```ruby
filter {
  json {
    source => "message"
  }
}
```

**📝 完整配置示例**
```ruby
input {
  stdin {}
}

filter {
  json {
    source => "message"
  }
}

output {
  stdout {
    codec => rubydebug
  }
}
```

**🧪 测试数据**
输入：`{"timestamp":"2024-01-01","level":"INFO","msg":"用户登录成功"}`

输出结果：
```
{
      "message" => "{\"timestamp\":\"2024-01-01\",\"level\":\"INFO\",\"msg\":\"用户登录成功\"}",
    "timestamp" => "2024-01-01",
        "level" => "INFO",
          "msg" => "用户登录成功",
         "host" => "localhost"
}
```

### 3.2 使用target参数的配置


**🎯 配置目的**
避免字段名冲突，将解析结果放入独立的嵌套对象中。

```ruby
filter {
  json {
    source => "message"
    target => "app_data"
  }
}
```

**📊 对比效果**

原始数据：`{"host":"server1","timestamp":"2024-01-01"}`

由于Logstash事件本身也有`host`和`@timestamp`字段，不使用target可能造成冲突：

```
不使用target（可能冲突）：
{
  "host" => "server1",           ← 可能覆盖Logstash的host字段
  "timestamp" => "2024-01-01",
  "message" => "原始JSON字符串"
}

使用target（避免冲突）：
{
  "host" => "原始Logstash主机名",  ← Logstash原有字段保持不变
  "app_data" => {                ← JSON解析结果放在独立空间
    "host" => "server1",
    "timestamp" => "2024-01-01"
  },
  "message" => "原始JSON字符串"
}
```

### 3.3 完整的实用配置


```ruby
filter {
  json {
    source => "message"
    target => "parsed"
    skip_on_invalid_json => true
    tag_on_failure => ["json_parse_error"]
  }
}
```

**🔍 配置解读**
- `source => "message"`：从message字段读取JSON
- `target => "parsed"`：解析结果放入parsed字段  
- `skip_on_invalid_json => true`：遇到无效JSON跳过处理
- `tag_on_failure => ["json_parse_error"]`：失败时添加自定义标签

---

## 4. 🎯 高级配置技巧


### 4.1 处理嵌套JSON


**📝 场景说明**
实际应用中，JSON可能包含多层嵌套结构。

```ruby
# 处理复杂嵌套JSON
filter {
  json {
    source => "message"
    target => "event_data"
  }
  
  # 如果需要进一步处理嵌套字段
  if [event_data][details] {
    json {
      source => "[event_data][details]"
      target => "[event_data][parsed_details]"
    }
  }
}
```

**🧪 测试数据**
```json
{
  "event": "user_action",
  "details": "{\"action\":\"click\",\"element\":\"button\"}",
  "timestamp": "2024-01-01T10:00:00Z"
}
```

处理结果：
```
{
  "event_data" => {
    "event" => "user_action",
    "details" => "{\"action\":\"click\",\"element\":\"button\"}",
    "parsed_details" => {
      "action" => "click",
      "element" => "button"
    },
    "timestamp" => "2024-01-01T10:00:00Z"
  }
}
```

### 4.2 条件化JSON解析


**🎯 使用场景**
只对特定条件的事件进行JSON解析，提高处理效率。

```ruby
filter {
  # 只有当message字段以{开头时才进行JSON解析
  if [message] =~ /^\s*\{/ {
    json {
      source => "message"
      target => "json_data"
      skip_on_invalid_json => true
    }
  }
}
```

**💡 条件判断说明**
- `[message] =~ /^\s*\{/`：检查message字段是否以`{`开头
- `^\s*\{`：正则表达式，匹配行首可能有空白字符，然后是`{`
- 这样避免对非JSON数据进行不必要的解析尝试

### 4.3 多JSON字段处理


**📝 实际场景**
一个事件中可能有多个字段包含JSON数据。

```ruby
filter {
  # 解析请求数据
  json {
    source => "request_body"
    target => "request"
    tag_on_failure => ["request_json_error"]
  }
  
  # 解析响应数据
  json {
    source => "response_body"  
    target => "response"
    tag_on_failure => ["response_json_error"]
  }
  
  # 解析错误详情
  if [error_details] {
    json {
      source => "error_details"
      target => "error"
      skip_on_invalid_json => true
    }
  }
}
```

---

## 5. 🚨 错误处理与调试


### 5.1 常见错误类型


**❌ 错误1：JSON格式错误**
```
原始数据：{"name":"张三",age:25}  ← 缺少age值的引号
错误原因：JSON语法不正确
解决方案：检查数据源，或使用skip_on_invalid_json => true
```

**❌ 错误2：字段不存在**
```ruby
json {
  source => "nonexistent_field"    ← 字段不存在
}

解决方案：先检查字段是否存在
if [nonexistent_field] {
  json {
    source => "nonexistent_field"
  }
}
```

**❌ 错误3：数据类型错误**
```
原始数据：message字段是数字123，不是字符串
错误原因：JSON过滤器只能处理字符串类型的JSON
解决方案：先转换为字符串或添加类型检查
```

### 5.2 调试技巧


**🔍 调试配置**
```ruby
filter {
  json {
    source => "message"
    target => "parsed"
    tag_on_failure => ["debug_json_error"]
  }
  
  # 调试：输出解析失败的事件
  if "debug_json_error" in [tags] {
    mutate {
      add_field => { "debug_info" => "JSON解析失败：%{message}" }
    }
  }
}
```

**📊 监控解析成功率**
```ruby
filter {
  json {
    source => "message"
    target => "data"
  }
  
  # 添加解析状态标记
  if "data" in [fields] {
    mutate {
      add_field => { "json_parse_status" => "success" }
    }
  } else {
    mutate {
      add_field => { "json_parse_status" => "failed" }
    }
  }
}
```

### 5.3 错误恢复策略


**🔄 策略1：降级处理**
```ruby
filter {
  json {
    source => "message"
    target => "parsed_data"
    skip_on_invalid_json => true
  }
  
  # 如果JSON解析失败，尝试其他解析方式
  if ![parsed_data] {
    grok {
      match => { "message" => "%{GREEDYDATA:raw_content}" }
    }
  }
}
```

**🔄 策略2：部分解析**
```ruby
filter {
  # 尝试解析完整JSON
  json {
    source => "message"
    target => "full_data"
    skip_on_invalid_json => true
  }
  
  # 如果完整解析失败，尝试提取关键字段
  if ![full_data] and [message] =~ /"timestamp"/ {
    grok {
      match => { "message" => '"timestamp"\s*:\s*"(?<extracted_timestamp>[^"]+)"' }
    }
  }
}
```

---

## 6. 🎪 实战应用场景


### 6.1 应用日志解析


**📝 场景描述**
Spring Boot应用输出的JSON格式日志。

**原始日志样例**：
```
{"timestamp":"2024-01-01T10:00:00.123Z","level":"INFO","logger":"com.example.UserService","message":"用户登录","userId":12345,"ip":"192.168.1.100"}
```

**配置方案**：
```ruby
filter {
  json {
    source => "message"
    # 不设置target，字段直接添加到根级别
  }
  
  # 日期处理
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }
  
  # 清理原始message字段（可选）
  mutate {
    remove_field => [ "message" ]
  }
}
```

**处理结果**：
```
{
  "@timestamp" => 2024-01-01T10:00:00.123Z,
      "level" => "INFO",
     "logger" => "com.example.UserService", 
    "message" => "用户登录",
     "userId" => 12345,
         "ip" => "192.168.1.100"
}
```

### 6.2 API网关日志处理


**📝 场景描述**
API网关记录的请求和响应JSON数据。

**原始日志样例**：
```
2024-01-01 10:00:00 INFO Request: {"method":"POST","path":"/api/users","body":"{\"name\":\"张三\",\"email\":\"zhang@example.com\"}"}
```

**配置方案**：
```ruby
filter {
  # 先用grok提取JSON部分
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:log_time} %{WORD:level} Request: %{GREEDYDATA:request_json}" }
  }
  
  # 解析请求JSON
  if [request_json] {
    json {
      source => "request_json"
      target => "request"
      tag_on_failure => ["request_parse_error"]
    }
    
    # 如果请求中还有嵌套的body JSON
    if [request][body] {
      json {
        source => "[request][body]"
        target => "[request][parsed_body]"
        skip_on_invalid_json => true
      }
    }
  }
}
```

**处理结果**：
```
{
  "log_time" => "2024-01-01 10:00:00",
     "level" => "INFO",
   "request" => {
     "method" => "POST",
       "path" => "/api/users", 
       "body" => "{\"name\":\"张三\",\"email\":\"zhang@example.com\"}",
       "parsed_body" => {
         "name" => "张三",
         "email" => "zhang@example.com"
       }
   }
}
```

### 6.3 Docker容器日志


**📝 场景描述**
Docker容器输出的结构化JSON日志。

**原始日志样例**：
```
{"log":"{\"service\":\"user-api\",\"level\":\"error\",\"error\":\"数据库连接失败\",\"details\":{\"host\":\"db.example.com\",\"port\":5432}}\n","stream":"stderr","time":"2024-01-01T10:00:00.123456789Z"}
```

**配置方案**：
```ruby
filter {
  # Docker日志的外层JSON解析
  json {
    source => "message"
    target => "docker"
  }
  
  # 解析应用日志内容
  if [docker][log] {
    json {
      source => "[docker][log]"
      target => "app"
      skip_on_invalid_json => true
    }
  }
  
  # 设置时间戳
  if [docker][time] {
    date {
      match => [ "[docker][time]", "ISO8601" ]
    }
  }
  
  # 清理不需要的字段
  mutate {
    remove_field => [ "[docker][log]", "message" ]
  }
}
```

### 6.4 Nginx访问日志JSON格式


**📝 场景描述**
Nginx配置为输出JSON格式的访问日志。

**Nginx配置**：
```nginx
log_format json_log '{"time":"$time_iso8601","remote_addr":"$remote_addr","method":"$request_method","uri":"$request_uri","status":$status,"bytes":$bytes_sent,"referer":"$http_referer","user_agent":"$http_user_agent","request_time":$request_time}';
```

**Logstash配置**：
```ruby
filter {
  json {
    source => "message"
    # 直接解析到根级别，因为字段名不冲突
  }
  
  # 处理时间字段
  date {
    match => [ "time", "ISO8601" ]
    target => "@timestamp"
  }
  
  # 数据类型转换
  mutate {
    convert => {
      "status" => "integer"
      "bytes" => "integer" 
      "request_time" => "float"
    }
  }
  
  # 添加地理位置信息（如果需要）
  geoip {
    source => "remote_addr"
    target => "geoip"
  }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 JSON过滤器作用：将JSON字符串解析为结构化字段
🔸 source参数：指定包含JSON的源字段（必填）
🔸 target参数：指定解析结果存放位置（可选）
🔸 skip_on_invalid_json：控制无效JSON的处理方式
🔸 tag_on_failure：自定义解析失败时的标签
```

### 7.2 关键理解要点


**🔹 什么时候用target参数**
```
不用target：
✅ JSON字段名不会与事件原有字段冲突
✅ 希望解析的字段直接添加到事件根级别
✅ JSON结构简单，字段较少

使用target：
✅ 避免字段名冲突（如host、timestamp等）
✅ 保持数据结构清晰，便于后续处理
✅ JSON数据复杂，需要独立管理
```

**🔹 错误处理策略选择**
```
skip_on_invalid_json => false（默认）：
✅ 需要知道哪些数据解析失败
✅ 后续要对失败数据进行特殊处理
✅ 数据质量要求高，需要监控解析成功率

skip_on_invalid_json => true：
✅ 数据来源复杂，质量参差不齐
✅ 只处理有效的JSON数据
✅ 性能优先，减少不必要的错误标记
```

**🔹 实际应用建议**
```
基础应用：
json {
  source => "message"
}

生产环境推荐：
json {
  source => "message"
  target => "parsed_data"
  skip_on_invalid_json => true
  tag_on_failure => ["json_parse_error"]
}
```

### 7.3 实际应用价值


**🎯 主要应用场景**
- **应用日志解析**：Spring Boot、Node.js等应用的JSON日志
- **API数据处理**：接口请求响应的JSON数据解析
- **容器日志处理**：Docker、Kubernetes容器的结构化日志
- **监控数据解析**：监控系统产生的JSON格式指标数据

**💡 使用技巧**
- **先检查后解析**：使用条件判断避免不必要的解析
- **分层处理**：复杂JSON分步骤解析，便于调试
- **错误监控**：合理使用标签机制监控数据质量
- **性能优化**：对于高频数据，优先使用`skip_on_invalid_json => true`

**核心记忆**：
- JSON过滤器是数据解包工具，让JSON字符串变成可用字段
- source指定数据来源，target控制数据去向
- 错误处理要根据数据质量和业务需求来配置
- 实际使用中要考虑字段冲突和性能优化