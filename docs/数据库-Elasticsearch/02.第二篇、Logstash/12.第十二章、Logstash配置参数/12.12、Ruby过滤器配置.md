---
title: 12、Ruby过滤器配置
---
## 📚 目录

1. [Ruby过滤器概述](#1-Ruby过滤器概述)
2. [核心参数详解](#2-核心参数详解)
3. [实际应用场景](#3-实际应用场景)
4. [最佳实践指南](#4-最佳实践指南)
5. [故障排查技巧](#5-故障排查技巧)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔧 Ruby过滤器概述


### 1.1 什么是Ruby过滤器


**🔸 基本概念**
```
Ruby过滤器就像是Logstash的"瑞士军刀"
当其他过滤器解决不了问题时，Ruby过滤器几乎能做任何事情
```

Ruby过滤器允许你在Logstash中直接编写Ruby代码来处理日志事件。这是一个非常强大的工具，就像给了你一把万能钥匙，可以打开任何复杂数据处理的大门。

**💡 为什么需要Ruby过滤器**
```
普通过滤器的局限性：
• grok只能做模式匹配，不能做复杂计算
• mutate只能做简单的字段操作
• date只能处理时间格式转换

Ruby过滤器的强大之处：
• 可以编写任意复杂的逻辑
• 可以进行数学计算和统计
• 可以调用外部API或数据库
• 可以实现自定义的数据处理算法
```

### 1.2 Ruby过滤器的工作原理


**🔄 执行流程图示**
```
日志事件 → Ruby过滤器 → 执行Ruby代码 → 修改事件字段 → 输出到下一个插件

详细流程：
输入事件: {"message": "user login", "host": "web01"}
       ↓
    Ruby代码执行
       ↓  
输出事件: {"message": "user login", "host": "web01", "processed": true}
```

Ruby过滤器在每个事件通过时都会执行一次，这就像是一个检查站，每个数据包都要经过这里进行特殊处理。

**⚡ 性能考虑**
```
执行顺序：每个事件都会触发Ruby代码执行
性能影响：Ruby代码越复杂，处理速度越慢
最佳实践：只在必要时使用，避免过于复杂的计算
```

---

## 2. 📝 核心参数详解


### 2.1 code参数 - 内联代码执行


**🔸 参数说明**
```
code参数：直接在配置文件中编写Ruby代码
适用场景：简单的数据处理逻辑
优点：配置集中，易于管理
缺点：复杂代码会让配置文件难以阅读
```

**💻 基础使用示例**

*简单字段添加*
```ruby
filter {
  ruby {
    code => "event.set('processed_time', Time.now.to_i)"
  }
}
```
这段代码的作用就像给每个数据包贴上一个时间戳标签，记录它被处理的时间。

*条件逻辑处理*
```ruby
filter {
  ruby {
    code => '
      if event.get("status_code")
        status = event.get("status_code").to_i
        if status >= 400
          event.set("error_level", "high")
        elsif status >= 300
          event.set("error_level", "medium")
        else
          event.set("error_level", "low")
        end
      end
    '
  }
}
```

**🎯 实际应用场景**

*日志等级自动分类*
```ruby
filter {
  ruby {
    code => '
      message = event.get("message").to_s.downcase
      
      if message.include?("error") || message.include?("exception")
        event.set("log_level", "ERROR")
        event.set("priority", 1)
      elsif message.include?("warn")
        event.set("log_level", "WARN") 
        event.set("priority", 2)
      else
        event.set("log_level", "INFO")
        event.set("priority", 3)
      end
    '
  }
}
```

### 2.2 init参数 - 初始化代码


**🔸 参数说明**
```
init参数：在Logstash启动时执行一次的初始化代码
执行时机：过滤器首次加载时
用途：设置全局变量、加载配置、建立连接等
重要特点：只执行一次，不是每个事件都执行
```

**💡 为什么需要初始化代码**
```
想象一下：
如果你需要一个计数器统计处理了多少条日志
或者需要加载一个映射表来转换数据
这些操作只需要在开始时做一次就够了
```

**实用示例**

*全局计数器设置*
```ruby
filter {
  ruby {
    init => "
      $$counter = 0
      $$start_time = Time.now
    "
    code => "
      $$counter += 1
      event.set('sequence_number', $$counter)
      event.set('uptime_seconds', Time.now - $$start_time)
    "
  }
}
```

*映射表加载*
```ruby
filter {
  ruby {
    init => "
      $$status_mapping = {
        '200' => 'Success',
        '404' => 'Not Found', 
        '500' => 'Server Error'
      }
    "
    code => "
      status_code = event.get('status_code')
      if $$status_mapping[status_code]
        event.set('status_text', $$status_mapping[status_code])
      end
    "
  }
}
```

### 2.3 script参数 - 外部脚本文件


**🔸 参数说明**
```
script参数：指向外部Ruby脚本文件的路径
适用场景：复杂的数据处理逻辑
优点：代码复用，便于维护和测试
文件要求：必须是.rb文件，可以包含完整的Ruby程序
```

**📁 文件组织结构**
```
/etc/logstash/
├── conf.d/
│   └── pipeline.conf
└── scripts/
    ├── data_processor.rb
    ├── geo_lookup.rb
    └── user_analyzer.rb
```

**实际应用示例**

*配置文件中的引用*
```ruby
filter {
  ruby {
    script => "/etc/logstash/scripts/data_processor.rb"
  }
}
```

*data_processor.rb文件内容*
```ruby
# 复杂的数据清洗逻辑
def clean_user_agent(event)
  ua = event.get("user_agent")
  return unless ua
  
  # 移除版本号
  ua = ua.gsub(/\/[\d\.]+/, '')
  # 统一浏览器名称
  ua = ua.gsub(/Chrome.*/, 'Chrome')
  ua = ua.gsub(/Firefox.*/, 'Firefox')
  
  event.set("browser_family", ua)
end

def calculate_session_duration(event)
  start_time = event.get("session_start")
  end_time = event.get("timestamp")
  
  if start_time && end_time
    duration = Time.parse(end_time) - Time.parse(start_time)
    event.set("session_duration", duration.to_i)
  end
end

# 主处理函数
clean_user_agent(event)
calculate_session_duration(event)
```

### 2.4 script_params参数 - 脚本参数传递


**🔸 参数说明**
```
script_params：向外部脚本传递参数的哈希表
用途：让脚本更加灵活，可以根据不同环境使用不同配置
参数格式：键值对形式
在脚本中访问：通过params变量
```

**配置示例**
```ruby
filter {
  ruby {
    script => "/etc/logstash/scripts/flexible_processor.rb"
    script_params => {
      "environment" => "production"
      "max_retries" => 3
      "timeout" => 30
      "debug_mode" => false
    }
  }
}
```

**脚本中使用参数**
```ruby
# flexible_processor.rb
environment = params["environment"] || "development"
max_retries = params["max_retries"] || 1
timeout = params["timeout"] || 10
debug_mode = params["debug_mode"] || true

if debug_mode
  puts "Processing event in #{environment} mode"
  puts "Max retries: #{max_retries}, Timeout: #{timeout}"
end

# 根据环境进行不同处理
if environment == "production"
  # 生产环境的严格处理
  event.set("validation_level", "strict")
else
  # 开发环境的宽松处理  
  event.set("validation_level", "relaxed")
end
```

### 2.5 tag_on_exception参数 - 异常处理


**🔸 参数说明**
```
tag_on_exception：当Ruby代码执行出错时添加的标签
默认值：["_rubyexception"]
作用：帮助识别和调试处理失败的事件
重要性：Ruby代码出错不会中断整个管道，而是给事件打标签
```

**异常处理策略**

*基础异常标签*
```ruby
filter {
  ruby {
    code => "
      # 可能出错的代码
      result = 100 / event.get('denominator').to_i
      event.set('calculation_result', result)
    "
    tag_on_exception => ["_math_error"]
  }
}
```

*详细异常信息捕获*
```ruby
filter {
  ruby {
    code => "
      begin
        # 危险操作
        data = JSON.parse(event.get('json_data'))
        event.set('parsed_data', data)
      rescue JSON::ParserError => e
        event.set('parse_error', e.message)
        event.tag('_json_parse_failed')
      rescue => e
        event.set('general_error', e.message)
        event.tag('_unknown_error')
      end
    "
    tag_on_exception => ["_ruby_processing_failed"]
  }
}
```

**🔍 异常监控和调试**
```
异常事件的典型结构：
{
  "message": "original log message",
  "tags": ["_rubyexception"],
  "@timestamp": "2025-09-21T14:30:00.000Z"
}

如何查找异常事件：
• 在Kibana中搜索：tags:_rubyexception
• 在配置中添加条件输出专门处理异常事件
• 设置告警监控异常事件的数量
```

---

## 3. 🎯 实际应用场景


### 3.1 复杂数据格式解析


**场景描述**：处理非标准格式的日志数据

```ruby
filter {
  ruby {
    code => '
      # 处理自定义格式：user:john|action:login|ip:192.168.1.1
      message = event.get("message")
      if message
        pairs = message.split("|")
        pairs.each do |pair|
          key, value = pair.split(":")
          if key && value
            event.set(key.strip, value.strip)
          end
        end
      end
    '
  }
}
```

### 3.2 动态字段重命名


**场景描述**：根据条件动态调整字段名称

```ruby
filter {
  ruby {
    code => '
      # 根据日志来源重命名字段
      source = event.get("source_system")
      
      if source == "nginx"
        event.rename("field1", "response_time")
        event.rename("field2", "request_path")
      elsif source == "apache"  
        event.rename("field1", "duration")
        event.rename("field2", "uri")
      end
    '
  }
}
```

### 3.3 数据聚合和统计


**场景描述**：实时计算统计信息

```ruby
filter {
  ruby {
    init => "
      $$hourly_stats = {}
      $$mutex = Mutex.new
    "
    code => '
      hour_key = Time.now.strftime("%Y%m%d%H")
      
      $$mutex.synchronize do
        $$hourly_stats[hour_key] ||= { count: 0, errors: 0 }
        $$hourly_stats[hour_key][:count] += 1
        
        if event.get("level") == "ERROR"
          $$hourly_stats[hour_key][:errors] += 1
        end
        
        event.set("hourly_total", $$hourly_stats[hour_key][:count])
        event.set("hourly_errors", $$hourly_stats[hour_key][:errors])
      end
    '
  }
}
```

---

## 4. 📋 最佳实践指南


### 4.1 性能优化策略


**🚀 代码性能优化**

| 优化项目 | **不推荐做法** | **推荐做法** | **提升效果** |
|---------|-------------|------------|-------------|
| **字符串操作** | `多次字符串拼接` | `使用数组join` | `2-3倍性能提升` |
| **正则表达式** | `每次重新编译` | `预编译存储` | `5-10倍性能提升` |
| **循环处理** | `嵌套多层循环` | `单层循环+hash查找` | `10倍以上提升` |
| **变量访问** | `频繁get/set调用` | `缓存到本地变量` | `30%性能提升` |

**实际优化示例**
```ruby
# ❌ 不推荐的写法
filter {
  ruby {
    code => '
      # 每次都重新编译正则表达式
      if event.get("message") =~ /ERROR|WARN|INFO/
        # 多次字符串拼接
        result = ""
        result += event.get("host")
        result += ":"
        result += event.get("service")
        event.set("identifier", result)
      end
    '
  }
}

# ✅ 推荐的写法  
filter {
  ruby {
    init => "
      $$log_level_regex = /ERROR|WARN|INFO/
    "
    code => '
      message = event.get("message")
      if message =~ $$log_level_regex
        # 使用数组拼接
        identifier_parts = [event.get("host"), event.get("service")]
        event.set("identifier", identifier_parts.join(":"))
      end
    '
  }
}
```

### 4.2 代码组织和维护


**📁 模块化设计**
```ruby
# 将功能拆分成独立的方法
filter {
  ruby {
    code => '
      def extract_user_info(event)
        user_agent = event.get("user_agent")
        return unless user_agent
        
        # 提取浏览器信息
        if user_agent.include?("Chrome")
          event.set("browser", "Chrome")
        elsif user_agent.include?("Firefox") 
          event.set("browser", "Firefox")
        end
      end
      
      def calculate_response_category(event)
        response_time = event.get("response_time").to_f
        
        case response_time
        when 0..100
          event.set("performance", "excellent")
        when 100..500
          event.set("performance", "good")  
        when 500..1000
          event.set("performance", "acceptable")
        else
          event.set("performance", "poor")
        end
      end
      
      # 主处理逻辑
      extract_user_info(event)
      calculate_response_category(event)
    '
  }
}
```

### 4.3 错误处理和容错


**🛡️ 防御式编程**
```ruby
filter {
  ruby {
    code => '
      # 总是检查字段是否存在
      response_time = event.get("response_time")
      if response_time && response_time.to_s.match(/^\d+$/)
        # 安全的数值转换
        rt = response_time.to_i
        event.set("response_time_ms", rt)
        
        # 避免除零错误
        if rt > 0
          event.set("requests_per_second", 1000.0 / rt)
        end
      else
        event.set("response_time_valid", false)
      end
    '
  }
}
```

---

## 5. 🔧 故障排查技巧


### 5.1 调试方法


**📊 调试输出技巧**
```ruby
filter {
  ruby {
    code => '
      # 调试输出（生产环境要注释掉）
      puts "Debug: Processing event #{event.get("@timestamp")}"
      puts "Debug: Message content: #{event.get("message")}"
      
      # 处理逻辑
      processed_data = event.get("raw_data").to_s.upcase
      event.set("processed_data", processed_data)
      
      puts "Debug: Result: #{event.get("processed_data")}"
    '
  }
}
```

### 5.2 常见问题解决


**⚠️ 问题诊断表**

| 问题现象 | **可能原因** | **解决方案** |
|---------|------------|-------------|
| **事件丢失** | `Ruby代码抛出未捕获异常` | `添加begin-rescue块` |
| **性能下降** | `复杂计算或外部调用` | `优化算法或异步处理` |
| **内存泄漏** | `全局变量持续增长` | `定期清理或使用LRU缓存` |
| **字段为空** | `get()方法返回nil` | `添加nil检查` |

**实际问题修复示例**
```ruby
# 问题：处理大量事件时内存持续增长
filter {
  ruby {
    init => "
      $$cache = {}
      $$cache_max_size = 1000
    "
    code => '
      key = event.get("cache_key")
      
      # 问题代码：缓存无限增长
      # $$cache[key] = expensive_calculation(key)
      
      # 修复：限制缓存大小
      if $$cache.size >= $$cache_max_size
        # 删除最老的一半条目
        old_keys = $$cache.keys.first($$cache_max_size / 2)
        old_keys.each { |k| $$cache.delete(k) }
      end
      
      $$cache[key] ||= expensive_calculation(key)
      event.set("result", $$cache[key])
    '
  }
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的关键概念


```
🔸 Ruby过滤器本质：Logstash中的"万能工具"，用Ruby代码处理事件
🔸 执行模式：每个事件都会触发代码执行，init代码只执行一次
🔸 核心参数：code(内联代码)、script(外部文件)、init(初始化)
🔸 异常处理：tag_on_exception确保错误不会中断整个处理流程
🔸 性能考虑：复杂逻辑会影响处理速度，需要优化和监控
```

### 6.2 实际使用决策


**🔹 什么时候使用Ruby过滤器**
```
适用场景：
✅ 其他过滤器无法满足需求
✅ 需要复杂的条件逻辑处理
✅ 需要进行数学计算或统计
✅ 需要调用外部服务或API
✅ 需要实现自定义的数据转换

避免使用：
❌ 简单的字段操作（用mutate更好）
❌ 正则表达式匹配（用grok更高效）
❌ 时间格式转换（用date插件）
❌ 对性能要求极高的场景
```

**🔹 参数选择指南**
```
code参数：适合简单逻辑，代码少于20行
script参数：适合复杂逻辑，需要代码复用
init参数：用于设置全局变量、加载配置
script_params：让脚本更灵活，支持多环境
tag_on_exception：必须设置，便于错误监控
```

### 6.3 生产环境注意事项


**🚨 重要提醒**
```
性能监控：
• 监控Ruby过滤器的执行时间
• 设置合理的超时限制
• 避免阻塞操作

错误处理：
• 总是使用begin-rescue包装危险操作
• 设置有意义的异常标签
• 建立异常事件的监控告警

代码维护：
• 复杂逻辑使用外部脚本文件
• 添加详细的代码注释
• 建立代码版本管理
```

**💡 实用技巧汇总**
- **调试技巧**：使用puts输出调试信息，生产环境要移除
- **性能优化**：预编译正则表达式，缓存计算结果，避免重复操作
- **容错设计**：检查字段存在性，处理nil值，捕获异常
- **代码组织**：函数式编程，模块化设计，提高代码复用性

**核心记忆口诀**：
```
Ruby过滤万能强，复杂逻辑它能扛
code简单script复杂，init初始要记好
异常标签别忘记，性能监控很重要
```