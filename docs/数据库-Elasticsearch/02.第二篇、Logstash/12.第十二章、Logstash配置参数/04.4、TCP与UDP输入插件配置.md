---
title: 4、TCP与UDP输入插件配置
---
## 📚 目录

1. [TCP/UDP输入插件概述](#1-TCP-UDP输入插件概述)
2. [核心参数详解](#2-核心参数详解)
3. [TCP模式配置实践](#3-TCP模式配置实践)
4. [UDP模式配置实践](#4-UDP模式配置实践)
5. [SSL加密配置](#5-SSL加密配置)
6. [实际应用场景](#6-实际应用场景)
7. [常见问题与解决方案](#7-常见问题与解决方案)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 TCP/UDP输入插件概述


### 1.1 什么是TCP/UDP输入插件


**🔸 插件的作用**
TCP和UDP输入插件就像是Logstash的"网络耳朵"，专门负责监听网络上传来的数据。

```
简单理解：
应用程序 → 网络传输 → Logstash TCP/UDP插件 → 数据处理

就像邮递员送信：
发件人 → 邮政系统 → 你家门牌号 → 你收信
```

**💡 两种协议的区别**
```
TCP（传输控制协议）：
✅ 可靠传输：保证数据不丢失
✅ 有序传输：数据按顺序到达
✅ 连接建立：需要握手建连
❌ 传输较慢：因为要确保可靠性

UDP（用户数据报协议）：
✅ 传输快速：直接发送数据
✅ 资源消耗少：无需建立连接
❌ 不保证可靠：数据可能丢失
❌ 无序传输：数据可能乱序到达
```

### 1.2 使用场景对比


**🎯 TCP适用场景**
- **日志收集**：需要确保每条日志都收到
- **重要事件**：不能丢失的业务数据
- **系统监控**：准确的性能指标收集

**🎯 UDP适用场景**
- **实时监控**：网络延迟监控、性能指标
- **高频数据**：游戏服务器状态、IoT传感器数据
- **日志流**：允许偶尔丢失但要求高吞吐量

---

## 2. ⚙️ 核心参数详解


### 2.1 端口参数（port）


**🔸 参数含义**
`port`参数指定Logstash监听哪个网络端口，就像你家的门牌号。

```ruby
input {
  tcp {
    port => 5514    # 监听5514端口
  }
}
```

**💡 端口选择建议**
```
常用端口范围：
• 1-1023：     系统保留端口（需要管理员权限）
• 1024-49151： 注册端口（推荐使用）
• 49152-65535：动态端口（临时使用）

推荐配置：
• 开发环境：5000-6000
• 生产环境：5514（Syslog标准）、9200-9300
```

### 2.2 主机参数（host）


**🔸 参数作用**
`host`参数决定Logstash绑定到哪个网络接口上，控制谁能连接到你的服务。

```ruby
input {
  tcp {
    host => "0.0.0.0"  # 允许任何IP连接
    port => 5514
  }
}
```

**🔧 不同配置的含义**
```
host配置选项：

"0.0.0.0" → 监听所有网络接口
┌─ 本地回环：127.0.0.1
├─ 内网IP：  192.168.1.100
└─ 公网IP：  203.0.113.1

"127.0.0.1" → 只允许本机连接
应用场景：测试环境、本地开发

"192.168.1.100" → 只监听指定IP
应用场景：指定网卡、安全限制
```

### 2.3 数据超时参数（data_timeout）


**🔸 超时机制说明**
`data_timeout`控制连接空闲多长时间后自动断开，防止"僵尸连接"占用资源。

```ruby
input {
  tcp {
    port => 5514
    data_timeout => 5    # 5秒无数据就断开连接
  }
}
```

**⏰ 超时设置指导**
```
超时时间建议：

高频数据流：1-5秒
• 实时监控数据
• 游戏服务器日志
• IoT设备数据

普通应用日志：30-60秒
• Web应用日志
• 数据库日志
• 系统服务日志

批量数据传输：300秒（5分钟）
• 数据库导出
• 文件同步
• 离线分析数据
```

### 2.4 工作模式参数（mode）


**🔸 模式含义**
`mode`参数决定Logstash是主动连接别人（client），还是等别人连接自己（server）。

```ruby
# 服务器模式（默认）- 等待连接
input {
  tcp {
    mode => "server"  # Logstash作为服务器
    port => 5514
  }
}

# 客户端模式 - 主动连接
input {
  tcp {
    mode => "client"  # Logstash作为客户端
    host => "192.168.1.100"
    port => 5514
  }
}
```

**🔄 两种模式的应用场景**
```
Server模式（被动接收）：
┌─ 应用服务器 ─┐
├─ 数据库服务器 ├──→ Logstash Server
├─ Web服务器 ──┘
└─ 其他系统 ────┘

Client模式（主动获取）：
┌─ Logstash Client ──→ 远程日志服务器
├─ Logstash Client ──→ 监控系统API
└─ Logstash Client ──→ 第三方数据源
```

### 2.5 SSL参数详解


**🔸 SSL启用参数（ssl_enable）**
```ruby
input {
  tcp {
    port => 5514
    ssl_enable => true           # 启用SSL加密
    ssl_cert => "/path/to/cert.crt"
    ssl_key => "/path/to/key.key"
  }
}
```

**🔸 SSL验证参数（ssl_verify）**
```ruby
input {
  tcp {
    ssl_enable => true
    ssl_verify => true           # 启用客户端证书验证
    ssl_cacert => "/path/to/ca.crt"
  }
}
```

**🔒 SSL配置组合**
```
安全级别配置：

基础加密：
ssl_enable => true

双向认证：
ssl_enable => true
ssl_verify => true
ssl_cacert => "/path/to/ca.crt"

生产环境推荐：
ssl_enable => true
ssl_verify => true
ssl_cert => "/path/to/server.crt"
ssl_key => "/path/to/server.key"
ssl_cacert => "/path/to/ca.crt"
```

### 2.6 编码参数（codec）


**🔸 编码器的作用**
`codec`参数告诉Logstash如何理解接收到的数据格式，就像告诉翻译员用哪种语言来翻译。

```ruby
input {
  tcp {
    port => 5514
    codec => "json"    # 按JSON格式解析数据
  }
}
```

**📄 常用编码格式**
```
编码类型及用途：

json → JSON格式数据
{
  "timestamp": "2024-01-19T10:30:00",
  "level": "INFO",
  "message": "用户登录成功"
}

plain → 普通文本（默认）
2024-01-19 10:30:00 INFO 用户登录成功

lines → 按行分割的文本
第一行日志
第二行日志
第三行日志

multiline → 多行日志（如Java异常堆栈）
2024-01-19 10:30:00 ERROR Java异常
    at com.example.Method1(File.java:10)
    at com.example.Method2(File.java:20)
```

---

## 3. 🖥️ TCP模式配置实践


### 3.1 基础TCP服务器配置


**📋 最简配置示例**
```ruby
input {
  tcp {
    port => 5514
    type => "tcp-logs"
  }
}

filter {
  # 添加时间戳
  mutate {
    add_field => { "received_at" => "%{@timestamp}" }
  }
}

output {
  stdout { 
    codec => rubydebug 
  }
}
```

**🎯 配置说明**
- `port => 5514`：监听5514端口
- `type => "tcp-logs"`：给数据打标签，方便后续处理
- 自动使用默认值：`host => "0.0.0.0"`, `mode => "server"`

### 3.2 生产环境TCP配置


**🏭 完整生产配置**
```ruby
input {
  tcp {
    # 基础连接参数
    host => "0.0.0.0"
    port => 5514
    type => "application-logs"
    
    # 性能优化参数
    data_timeout => 30
    tcp_keep_alive => true
    
    # 数据处理参数
    codec => json {
      charset => "UTF-8"
    }
    
    # 添加元数据
    add_field => {
      "input_type" => "tcp"
      "environment" => "production"
    }
  }
}

filter {
  # 验证必要字段
  if ![timestamp] {
    mutate {
      add_field => { "parse_error" => "missing timestamp" }
    }
  }
  
  # 标准化时间格式
  date {
    match => [ "timestamp", "yyyy-MM-dd HH:mm:ss" ]
    target => "@timestamp"
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "tcp-logs-%{+YYYY.MM.dd}"
  }
}
```

### 3.3 TCP客户端模式配置


**📡 主动连接配置**
```ruby
input {
  tcp {
    mode => "client"
    host => "log-server.company.com"
    port => 5514
    reconnect_interval => 10    # 断线重连间隔
    
    # 客户端特有参数
    connect_timeout => 5
    
    codec => json
    type => "remote-logs"
  }
}
```

**🔄 重连机制说明**
```
断线重连流程：
1. 检测连接断开
2. 等待 reconnect_interval 时间
3. 尝试重新连接
4. 连接失败则重复步骤2-3
5. 连接成功则恢复数据接收

重连间隔建议：
• 本地网络：1-5秒
• 跨机房：  10-30秒
• 公网连接：30-60秒
```

---

## 4. 📡 UDP模式配置实践


### 4.1 基础UDP配置


**⚡ 简单UDP接收**
```ruby
input {
  udp {
    port => 5514
    type => "syslog-udp"
  }
}

filter {
  # UDP数据通常需要解析
  grok {
    match => { 
      "message" => "%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:host} %{GREEDYDATA:log_message}" 
    }
  }
}

output {
  stdout { codec => rubydebug }
}
```

### 4.2 高性能UDP配置


**🚀 优化后的UDP配置**
```ruby
input {
  udp {
    # 基础参数
    host => "0.0.0.0"
    port => 5514
    type => "metrics-udp"
    
    # 性能优化
    receive_buffer_bytes => 1048576    # 1MB接收缓冲区
    workers => 4                       # 4个工作线程
    
    # 数据处理
    codec => json {
      charset => "UTF-8"
    }
  }
}

filter {
  # 添加接收时间戳
  ruby {
    code => "event.set('received_timestamp', Time.now.to_f)"
  }
  
  # 处理可能的数据丢失
  if ![sequence_id] {
    mutate {
      add_field => { "data_integrity" => "unknown" }
    }
  }
}
```

**📊 UDP性能参数说明**
```
性能调优参数：

receive_buffer_bytes → 操作系统接收缓冲区大小
• 默认值：65536 (64KB)
• 高频数据：1048576 (1MB)
• 超高频：  4194304 (4MB)

workers → 并发处理线程数
• CPU核心数：推荐等于CPU核心数
• 高负载：  可设置为CPU核心数 × 2
• 注意：过多线程可能降低性能
```

### 4.3 UDP数据完整性检查


**🔍 数据丢失检测**
```ruby
input {
  udp {
    port => 5514
    codec => json
  }
}

filter {
  # 检查序列号连续性
  if [sequence_id] {
    ruby {
      init => "@last_sequence = 0"
      code => "
        current_seq = event.get('sequence_id').to_i
        if current_seq != @last_sequence + 1
          event.set('missing_packets', current_seq - @last_sequence - 1)
        end
        @last_sequence = current_seq
      "
    }
  }
  
  # 统计丢包情况
  if [missing_packets] and [missing_packets] > 0 {
    mutate {
      add_tag => ["packet_loss"]
      add_field => { "data_quality" => "degraded" }
    }
  }
}
```

---

## 5. 🔐 SSL加密配置


### 5.1 SSL证书准备


**📋 证书文件准备**
```bash
# 生成自签名证书（测试用）
openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt -days 365 -nodes

# 生成CA证书（生产用）
openssl genrsa -out ca.key 4096
openssl req -new -x509 -key ca.key -out ca.crt -days 3650

# 生成服务器证书
openssl genrsa -out server.key 4096
openssl req -new -key server.key -out server.csr
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -out server.crt -days 365
```

### 5.2 SSL服务端配置


**🔒 加密传输配置**
```ruby
input {
  tcp {
    port => 5514
    type => "secure-logs"
    
    # SSL基础配置
    ssl_enable => true
    ssl_cert => "/etc/logstash/ssl/server.crt"
    ssl_key => "/etc/logstash/ssl/server.key"
    
    # 安全增强配置
    ssl_verify => true
    ssl_cacert => "/etc/logstash/ssl/ca.crt"
    
    # SSL协议版本控制
    ssl_supported_protocols => ["TLSv1.2", "TLSv1.3"]
    
    codec => json
  }
}
```

**🛡️ SSL安全等级配置**
```ruby
# 低安全等级（仅加密）
input {
  tcp {
    ssl_enable => true
    ssl_cert => "/path/to/cert.crt"
    ssl_key => "/path/to/key.key"
    ssl_verify => false    # 不验证客户端证书
  }
}

# 高安全等级（双向认证）
input {
  tcp {
    ssl_enable => true
    ssl_cert => "/path/to/server.crt"
    ssl_key => "/path/to/server.key"
    ssl_verify => true     # 验证客户端证书
    ssl_cacert => "/path/to/ca.crt"
    
    # 额外安全措施
    ssl_certificate_authorities => ["/path/to/ca.crt"]
    ssl_cipher_suites => ["TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"]
  }
}
```

---

## 6. 🎯 实际应用场景


### 6.1 Web应用日志收集


**🌐 应用场景配置**
```ruby
input {
  # 接收Web服务器日志
  tcp {
    port => 5514
    type => "webapp-logs"
    codec => json
    
    # 针对Web应用优化
    data_timeout => 60
    tcp_keep_alive => true
  }
}

filter {
  # 解析Web日志特有字段
  if [type] == "webapp-logs" {
    # 提取IP地理位置
    geoip {
      source => "client_ip"
      target => "geoip"
    }
    
    # 识别用户代理
    useragent {
      source => "user_agent"
      target => "ua"
    }
    
    # 响应时间性能分析
    if [response_time] {
      range {
        ranges => [
          "response_fast", 0, 100,
          "response_normal", 100, 500,
          "response_slow", 500, 99999
        ]
        field => "response_time"
      }
    }
  }
}
```

### 6.2 系统监控数据收集


**📊 监控指标接收**
```ruby
input {
  # 接收系统监控指标
  udp {
    port => 8125
    type => "system-metrics"
    codec => json
    
    # 高频数据优化
    receive_buffer_bytes => 2097152  # 2MB缓冲区
    workers => 8
  }
}

filter {
  if [type] == "system-metrics" {
    # 计算资源使用率
    ruby {
      code => "
        if event.get('cpu_total') and event.get('cpu_idle')
          cpu_used = event.get('cpu_total') - event.get('cpu_idle')
          cpu_usage = (cpu_used.to_f / event.get('cpu_total').to_f) * 100
          event.set('cpu_usage_percent', cpu_usage.round(2))
        end
      "
    }
    
    # 内存使用率计算
    if [memory_total] and [memory_free] {
      ruby {
        code => "
          memory_used = event.get('memory_total') - event.get('memory_free')
          memory_usage = (memory_used.to_f / event.get('memory_total').to_f) * 100
          event.set('memory_usage_percent', memory_usage.round(2))
        "
      }
    }
    
    # 添加告警级别
    if [cpu_usage_percent] and [cpu_usage_percent] > 80 {
      mutate { add_tag => ["high_cpu"] }
    }
  }
}
```

### 6.3 安全日志收集


**🔒 安全事件处理**
```ruby
input {
  # 接收安全设备日志
  tcp {
    port => 5515
    type => "security-logs"
    
    # 安全传输
    ssl_enable => true
    ssl_cert => "/etc/ssl/security.crt"
    ssl_key => "/etc/ssl/security.key"
    ssl_verify => true
    ssl_cacert => "/etc/ssl/ca.crt"
    
    codec => plain
  }
}

filter {
  if [type] == "security-logs" {
    # 解析防火墙日志
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:action} %{IP:src_ip}:%{INT:src_port} -> %{IP:dst_ip}:%{INT:dst_port} %{GREEDYDATA:description}"
      }
    }
    
    # 威胁情报匹配
    if [src_ip] {
      # 检查黑名单IP
      ruby {
        init => "@blacklist_ips = ['192.168.1.100', '10.0.0.50']"
        code => "
          if @blacklist_ips.include?(event.get('src_ip'))
            event.set('threat_level', 'high')
            event.tag('blacklisted_ip')
          end
        "
      }
    }
    
    # 异常行为检测
    if [action] == "DENY" {
      mutate { add_tag => ["blocked_connection"] }
    }
  }
}
```

---

## 7. ❓ 常见问题与解决方案


### 7.1 连接问题排查


**🔧 连接失败诊断**
```bash
# 1. 检查端口是否开放
netstat -tlnp | grep 5514

# 2. 测试端口连通性
telnet localhost 5514

# 3. 检查防火墙规则
iptables -L | grep 5514

# 4. 验证Logstash配置
/usr/share/logstash/bin/logstash --config.test_and_exit --path.config=/etc/logstash/conf.d/
```

**📋 常见连接错误及解决**
```
错误：Connection refused
原因：端口未监听或防火墙阻断
解决：
1. 确认Logstash正常启动
2. 检查配置文件语法
3. 验证防火墙规则

错误：Address already in use
原因：端口被其他进程占用
解决：
1. 查找占用进程：lsof -i :5514
2. 停止冲突进程或更换端口

错误：SSL certificate verify failed
原因：SSL证书配置错误
解决：
1. 验证证书文件路径
2. 检查证书有效期
3. 确认证书格式正确
```

### 7.2 性能优化问题


**📈 性能调优指南**
```ruby
# 高并发TCP配置
input {
  tcp {
    port => 5514
    
    # 连接优化
    tcp_keep_alive => true
    data_timeout => 30
    
    # 缓冲区优化
    receive_buffer_bytes => 1048576
    
    # 线程优化
    threads => 4
  }
}

# 高吞吐UDP配置
input {
  udp {
    port => 5514
    
    # 缓冲区最大化
    receive_buffer_bytes => 16777216  # 16MB
    
    # 多工作进程
    workers => 8
    
    # 批处理优化
    codec => json_lines {
      delimiter => "\n"
    }
  }
}
```

**🔍 性能监控配置**
```ruby
filter {
  # 添加性能监控字段
  ruby {
    code => "
      event.set('processing_time', Time.now.to_f)
      event.set('input_plugin', 'tcp')
      event.set('worker_id', Thread.current.object_id)
    "
  }
}

output {
  # 性能指标输出
  if [type] == "performance" {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "logstash-performance-%{+YYYY.MM}"
    }
  }
}
```

### 7.3 数据丢失预防


**🛡️ 数据完整性保障**
```ruby
input {
  tcp {
    port => 5514
    
    # 启用持久队列
    codec => json {
      charset => "UTF-8"
    }
    
    # 添加序列号
    add_field => {
      "input_timestamp" => "%{@timestamp}"
      "input_source" => "tcp-5514"
    }
  }
}

filter {
  # 数据验证
  if ![message] or [message] == "" {
    mutate {
      add_tag => ["empty_message"]
      add_field => { "data_quality" => "poor" }
    }
  }
  
  # 重复检测
  fingerprint {
    source => ["message", "@timestamp"]
    target => "[@metadata][fingerprint]"
    method => "SHA256"
  }
}

output {
  # 确保数据送达
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "secure-logs-%{+YYYY.MM.dd}"
    
    # 重试机制
    retry_on_conflict => 3
    retry_initial_interval => 2
    retry_max_interval => 64
  }
  
  # 备份输出
  file {
    path => "/var/log/logstash/backup-%{+YYYY-MM-dd}.log"
    codec => json_lines
  }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 插件本质：TCP/UDP插件是Logstash的网络数据接收器
🔸 协议差异：TCP可靠但慢，UDP快速但可能丢数据
🔸 核心参数：port（端口）、host（绑定IP）、mode（工作模式）
🔸 超时控制：data_timeout防止连接资源浪费
🔸 安全加密：SSL配置保障数据传输安全
🔸 编码处理：codec参数决定数据解析方式
```

### 8.2 关键配置要点


**🔹 端口和网络配置**
```
端口选择：
• 避免系统保留端口（1-1023）
• 生产环境使用标准端口（如5514）
• 确保防火墙规则正确配置

网络绑定：
• 开发环境：127.0.0.1（本地）
• 生产环境：0.0.0.0（所有接口）
• 安全环境：指定IP地址
```

**🔹 性能优化配置**
```
TCP优化：
• tcp_keep_alive => true（保持连接）
• data_timeout => 30（合理超时）
• threads => CPU核心数（并发处理）

UDP优化：
• receive_buffer_bytes => 1MB+（大缓冲区）
• workers => 4-8（多工作进程）
• 序列号检查（检测丢包）
```

**🔹 安全配置最佳实践**
```
SSL配置层级：
基础：ssl_enable => true
增强：ssl_verify => true
生产：双向认证 + 证书管理

证书管理：
• 使用有效的CA签发证书
• 定期更新证书
• 安全存储私钥文件
```

### 8.3 实际应用指导


**📊 场景选择决策**
```
选择TCP场景：
✅ 重要业务日志（不能丢失）
✅ 系统错误日志（需要完整）
✅ 审计日志（合规要求）
✅ 安全事件日志（零丢失）

选择UDP场景：
✅ 实时监控指标（速度优先）
✅ IoT传感器数据（高频率）
✅ 游戏服务器状态（低延迟）
✅ 网络性能监控（实时性）
```

**🔧 配置模板推荐**
```
开发环境模板：
• 简单配置
• 明文传输
• 调试输出

测试环境模板：
• 完整配置
• SSL加密
• 性能监控

生产环境模板：
• 安全配置
• 性能优化
• 错误处理
• 监控告警
```

### 8.4 故障排查思路


**🔍 系统性排查方法**
```
连接问题排查顺序：
1. 检查Logstash进程状态
2. 验证配置文件语法
3. 测试端口监听状态
4. 检查防火墙规则
5. 验证网络连通性

性能问题排查：
1. 监控CPU和内存使用
2. 检查网络带宽占用
3. 分析日志处理延迟
4. 优化缓冲区设置
5. 调整工作线程数

数据问题排查：
1. 验证数据格式正确性
2. 检查编码器配置
3. 监控数据丢失情况
4. 验证过滤器逻辑
5. 确认输出目标状态
```

**💡 记忆要点**
- TCP/UDP插件是网络数据的"收集器"和"监听器"
- 选择协议要平衡可靠性和性能需求
- 核心参数配置决定了插件的工作方式
- SSL配置保障数据传输安全
- 性能优化需要根据实际场景调整
- 故障排查要遵循系统性的检查流程