---
title: 6、JDBC输入插件配置
---
## 📚 目录

1. [JDBC插件概述](#1-JDBC插件概述)
2. [核心配置参数详解](#2-核心配置参数详解)
3. [数据库连接配置](#3-数据库连接配置)
4. [SQL查询与调度](#4-SQL查询与调度)
5. [增量数据采集](#5-增量数据采集)
6. [实战配置示例](#6-实战配置示例)
7. [常见问题与解决](#7-常见问题与解决)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔌 JDBC插件概述


### 1.1 什么是JDBC输入插件


**🔸 通俗理解**
JDBC插件就像是Logstash的"数据库读取器"，它能够：
- 连接各种数据库（MySQL、PostgreSQL、Oracle等）
- 定期执行SQL查询
- 将查询结果转换成Logstash能处理的数据格式

```
简单类比：
数据库 ──JDBC插件──▶ Logstash ──▶ Elasticsearch
（仓库）   （搬运工）   （处理中心）  （展示柜）
```

**🔸 主要作用**
- **数据同步**：将数据库数据实时同步到ES
- **数据迁移**：批量导入历史数据
- **定时采集**：按计划自动抓取新数据

### 1.2 工作原理图解


```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   MySQL数据库    │    │   Logstash      │    │  Elasticsearch  │
│                │    │                │    │                │
│  ┌───────────┐  │    │  ┌───────────┐  │    │  ┌───────────┐  │
│  │   用户表   │  │───▶│  │JDBC Input │  │───▶│  │   索引     │  │
│  │   订单表   │  │    │  │   插件    │  │    │  │           │  │
│  │   日志表   │  │    │  └───────────┘  │    │  └───────────┘  │
│  └───────────┘  │    │                │    │                │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.3 插件优势


| 特性 | **说明** | **实际价值** |
|------|---------|-------------|
| 🔄 **自动化** | `定时执行SQL查询` | `无需人工干预，7x24小时工作` |
| 📊 **增量同步** | `只抓取新增/修改数据` | `提高效率，减少重复处理` |
| 🔗 **多数据库支持** | `MySQL/PostgreSQL/Oracle等` | `适配各种企业环境` |
| ⚡ **高性能** | `支持并发查询` | `处理大量数据不卡顿` |

---

## 2. 🛠️ 核心配置参数详解


### 2.1 jdbc_driver_library参数


**🔸 参数含义**
这个参数告诉Logstash："数据库驱动文件放在哪里"

**🔸 通俗解释**
就像你要开车需要驾驶证一样，Logstash要连接数据库需要"驱动证"（JDBC驱动）

```ruby
input {
  jdbc {
    # 指定MySQL驱动jar包的路径
    jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
  }
}
```

**💡 实用提示**
- 路径必须是绝对路径，不能用相对路径
- jar包版本要与数据库版本匹配
- 多个jar包用逗号分隔

### 2.2 jdbc_driver_class参数


**🔸 参数含义**
指定使用哪个具体的驱动类来连接数据库

**🔸 通俗解释**
如果说`jdbc_driver_library`是告诉在哪找驾驶证，那`jdbc_driver_class`就是告诉用哪种类型的驾驶证（小车证、货车证等）

```ruby
input {
  jdbc {
    jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
    # MySQL数据库的驱动类名
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
  }
}
```

**📋 常用数据库驱动类**

| 数据库类型 | **驱动类名** |
|-----------|-------------|
| 🔸 **MySQL** | `com.mysql.cj.jdbc.Driver` |
| 🔸 **PostgreSQL** | `org.postgresql.Driver` |
| 🔸 **Oracle** | `oracle.jdbc.OracleDriver` |
| 🔸 **SQL Server** | `com.microsoft.sqlserver.jdbc.SQLServerDriver` |

### 2.3 jdbc_connection_string参数


**🔸 参数含义**
数据库连接地址，告诉Logstash要连接到哪个数据库

**🔸 通俗解释**
就像网址一样，包含了服务器地址、端口号、数据库名等信息

```ruby
input {
  jdbc {
    # MySQL连接字符串格式
    jdbc_connection_string => "jdbc:mysql://localhost:3306/mydb?useUnicode=true&characterEncoding=utf8"
  }
}
```

**🔧 连接字符串解析**
```
jdbc:mysql://localhost:3306/mydb?useUnicode=true&characterEncoding=utf8
  │      │        │       │     │
  │      │        │       │     └─ 参数：编码设置
  │      │        │       └─ 数据库名：mydb
  │      │        └─ 端口号：3306
  │      └─ 服务器地址：localhost
  └─ 协议类型：jdbc:mysql
```

### 2.4 用户认证参数


**🔸 jdbc_user参数**
```ruby
input {
  jdbc {
    # 数据库登录用户名
    jdbc_user => "root"
  }
}
```

**🔸 jdbc_password参数**
```ruby
input {
  jdbc {
    # 数据库登录密码
    jdbc_password => "123456"
  }
}
```

> ⚠️ **安全提醒**  
> 生产环境中密码不要明文写在配置文件里，建议使用环境变量：
> `jdbc_password => "${DB_PASSWORD}"`

---

## 3. 🗄️ 数据库连接配置


### 3.1 完整连接配置示例


```ruby
input {
  jdbc {
    # 第1步：指定驱动文件位置
    jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
    
    # 第2步：指定驱动类
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    
    # 第3步：配置连接字符串
    jdbc_connection_string => "jdbc:mysql://192.168.1.100:3306/ecommerce?useSSL=false&allowPublicKeyRetrieval=true"
    
    # 第4步：配置用户认证
    jdbc_user => "logstash_user"
    jdbc_password => "${MYSQL_PASSWORD}"
    
    # 第5步：配置查询语句
    statement => "SELECT * FROM orders WHERE created_at >= :sql_last_value"
  }
}
```

### 3.2 连接测试方法


**🔸 简单测试配置**
```ruby
input {
  jdbc {
    jdbc_driver_library => "/path/to/mysql-connector-java.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://localhost:3306/test"
    jdbc_user => "root"
    jdbc_password => "password"
    
    # 简单查询测试连接
    statement => "SELECT 1 as test_connection"
    
    # 只执行一次
    schedule => "* * * * *"
  }
}

output {
  stdout { 
    codec => rubydebug 
  }
}
```

### 3.3 连接池优化


```ruby
input {
  jdbc {
    # 基础连接配置...
    
    # 连接池设置
    jdbc_pool_timeout => 5
    jdbc_validate_connection => true
    
    # 连接测试SQL
    jdbc_validation_timeout => 3600
  }
}
```

---

## 4. 📝 SQL查询与调度


### 4.1 statement参数详解


**🔸 参数含义**
`statement`就是告诉Logstash要执行什么SQL查询

**🔸 基本用法**
```ruby
input {
  jdbc {
    # 查询用户表的所有记录
    statement => "SELECT id, name, email, created_at FROM users"
  }
}
```

**🔸 带条件查询**
```ruby
input {
  jdbc {
    # 只查询今天创建的用户
    statement => "SELECT * FROM users WHERE DATE(created_at) = CURDATE()"
  }
}
```

### 4.2 schedule参数详解


**🔸 参数含义**
`schedule`控制多久执行一次查询，使用Cron表达式

**🔸 Cron表达式通俗理解**
```
* * * * *
│ │ │ │ │
│ │ │ │ └─ 星期几 (0-7, 0和7都表示周日)
│ │ │ └─ 月份 (1-12)
│ │ └─ 日期 (1-31)
│ └─ 小时 (0-23)
└─ 分钟 (0-59)
```

**📅 常用调度示例**

| 调度需求 | **Cron表达式** | **说明** |
|---------|--------------|---------|
| 🕐 **每分钟** | `* * * * *` | `测试用，生产环境慎用` |
| 🕕 **每5分钟** | `*/5 * * * *` | `高频数据同步` |
| 🕘 **每小时** | `0 * * * *` | `常规数据采集` |
| 🌅 **每天早上8点** | `0 8 * * *` | `日报数据处理` |
| 📊 **每周一早上9点** | `0 9 * * 1` | `周报数据统计` |

```ruby
input {
  jdbc {
    # 数据库连接配置...
    statement => "SELECT * FROM orders"
    
    # 每30分钟执行一次
    schedule => "*/30 * * * *"
  }
}
```

### 4.3 实际调度场景


**🔸 电商订单数据同步**
```ruby
input {
  jdbc {
    # 每5分钟同步一次新订单
    schedule => "*/5 * * * *"
    statement => "SELECT * FROM orders WHERE updated_at >= :sql_last_value"
  }
}
```

**🔸 用户行为日志采集**
```ruby
input {
  jdbc {
    # 每小时采集一次用户行为
    schedule => "0 * * * *" 
    statement => "SELECT * FROM user_actions WHERE action_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR)"
  }
}
```

---

## 5. 📈 增量数据采集


### 5.1 use_column_value参数


**🔸 参数含义**
开启增量采集模式，避免重复处理相同数据

**🔸 通俗理解**
就像看书做书签一样，Logstash会记住上次读到哪里，下次从那里继续读

```ruby
input {
  jdbc {
    # 开启增量模式
    use_column_value => true
    
    # 指定追踪哪个字段
    tracking_column => "updated_at"
    
    # 字段类型（数字或时间）
    tracking_column_type => "timestamp"
    
    # SQL查询使用占位符
    statement => "SELECT * FROM users WHERE updated_at >= :sql_last_value"
  }
}
```

### 5.2 增量采集原理图解


```
第1次运行：
数据库: [记录1] [记录2] [记录3] [记录4] [记录5]
        ↑                              ↑
      开始                          读取到这里
Logstash记住：最后一条记录的updated_at = 2024-01-15 10:30:00

第2次运行：  
数据库: [记录1] [记录2] [记录3] [记录4] [记录5] [新记录6] [新记录7]
                                        ↑                    ↑
                              从这里开始读            读取到这里
查询条件：WHERE updated_at >= '2024-01-15 10:30:00'
```

### 5.3 追踪字段配置


**🔸 时间戳字段追踪**
```ruby
input {
  jdbc {
    use_column_value => true
    tracking_column => "created_at"
    tracking_column_type => "timestamp"
    
    # 查询语句必须包含 :sql_last_value 占位符
    statement => "SELECT * FROM orders WHERE created_at >= :sql_last_value ORDER BY created_at"
  }
}
```

**🔸 数字ID字段追踪**
```ruby
input {
  jdbc {
    use_column_value => true
    tracking_column => "id" 
    tracking_column_type => "numeric"
    
    statement => "SELECT * FROM products WHERE id > :sql_last_value ORDER BY id"
  }
}
```

### 5.4 追踪状态管理


**🔸 状态文件位置**
```ruby
input {
  jdbc {
    # 自定义状态文件保存位置
    last_run_metadata_path => "/opt/logstash/data/.logstash_jdbc_last_run"
    
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"
  }
}
```

**💡 重要说明**
- 状态文件记录上次读取的位置
- 删除状态文件会重新开始全量采集
- 建议定期备份状态文件

---

## 6. 🛠️ 实战配置示例


### 6.1 电商订单同步配置


```ruby
input {
  jdbc {
    # MySQL驱动配置
    jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://db.company.com:3306/ecommerce?useSSL=false"
    jdbc_user => "logstash"
    jdbc_password => "${MYSQL_PASSWORD}"
    
    # 增量同步配置
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"
    
    # 每5分钟同步一次
    schedule => "*/5 * * * *"
    
    # 查询订单数据
    statement => "
      SELECT 
        order_id,
        user_id,
        product_name,
        quantity,
        price,
        status,
        created_at,
        updated_at
      FROM orders 
      WHERE updated_at >= :sql_last_value 
      ORDER BY updated_at ASC
    "
    
    # 状态文件路径
    last_run_metadata_path => "/var/lib/logstash/jdbc_last_run_orders"
  }
}

filter {
  # 添加数据源标识
  mutate {
    add_field => { "data_source" => "mysql_orders" }
  }
  
  # 转换时间格式
  date {
    match => [ "created_at", "yyyy-MM-dd HH:mm:ss" ]
    target => "@timestamp"
  }
}

output {
  elasticsearch {
    hosts => ["http://es1.company.com:9200"]
    index => "orders-%{+YYYY.MM.dd}"
    document_id => "%{order_id}"
  }
  
  # 开发调试用
  stdout { 
    codec => rubydebug 
  }
}
```

### 6.2 用户数据全量导入


```ruby
input {
  jdbc {
    # PostgreSQL配置
    jdbc_driver_library => "/opt/logstash/drivers/postgresql-42.6.0.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    jdbc_connection_string => "jdbc:postgresql://pg.company.com:5432/userdb"
    jdbc_user => "readonly_user"
    jdbc_password => "${PG_PASSWORD}"
    
    # 一次性全量导入，不使用增量
    use_column_value => false
    
    # 只执行一次
    schedule => "0 2 * * 0"  # 每周日凌晨2点
    
    statement => "
      SELECT 
        user_id,
        username,
        email,
        phone,
        registration_date,
        last_login,
        user_type,
        is_active
      FROM users 
      WHERE is_deleted = false
    "
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "users"
    document_id => "%{user_id}"
  }
}
```

### 6.3 多表关联查询配置


```ruby
input {
  jdbc {
    jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://localhost:3306/crm"
    jdbc_user => "logstash"
    jdbc_password => "${MYSQL_PASSWORD}"
    
    use_column_value => true
    tracking_column => "o.updated_at"
    tracking_column_type => "timestamp"
    
    schedule => "*/10 * * * *"
    
    # 关联查询订单和用户信息
    statement => "
      SELECT 
        o.order_id,
        o.user_id,
        u.username,
        u.email,
        o.product_name,
        o.amount,
        o.status,
        o.created_at,
        o.updated_at
      FROM orders o
      LEFT JOIN users u ON o.user_id = u.user_id
      WHERE o.updated_at >= :sql_last_value
      ORDER BY o.updated_at ASC
    "
  }
}
```

---

## 7. ❓ 常见问题与解决


### 7.1 连接问题排查


**🔸 问题1：找不到驱动类**
```
错误信息：ClassNotFoundException: com.mysql.cj.jdbc.Driver
```

**解决方案：**
1. 检查jar包路径是否正确
2. 确认jar包是否存在
3. 验证jar包版本与数据库匹配

```ruby
# 正确配置示例
jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
```

**🔸 问题2：连接超时**
```
错误信息：Connection timed out
```

**解决方案：**
```ruby
input {
  jdbc {
    # 增加连接超时设置
    jdbc_pool_timeout => 10
    jdbc_validate_connection => true
    
    # 连接字符串添加超时参数
    jdbc_connection_string => "jdbc:mysql://host:3306/db?connectTimeout=60000&socketTimeout=60000"
  }
}
```

### 7.2 性能优化建议


**🔸 查询优化**
```ruby
input {
  jdbc {
    # 限制查询结果数量
    statement => "
      SELECT * FROM large_table 
      WHERE updated_at >= :sql_last_value 
      ORDER BY updated_at ASC 
      LIMIT 10000
    "
    
    # 增加查询间隔
    schedule => "*/15 * * * *"  # 15分钟一次而不是每分钟
  }
}
```

**🔸 内存优化**
```ruby
input {
  jdbc {
    # 控制JDBC连接池
    jdbc_pool_timeout => 5
    
    # 分页查询大表
    jdbc_paging_enabled => true
    jdbc_page_size => 50000
  }
}
```

### 7.3 数据一致性保障


**🔸 幂等性处理**
```ruby
output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "orders"
    
    # 使用业务主键作为文档ID，确保幂等性
    document_id => "%{order_id}"
  }
}
```

**🔸 重复数据处理**
```ruby
filter {
  # 去重处理
  if [duplicate_check] == "true" {
    drop { }
  }
  
  # 添加数据指纹
  fingerprint {
    source => ["order_id", "user_id", "amount"]
    target => "[@metadata][fingerprint]"
  }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的配置参数


```
🔸 连接四要素：
  - jdbc_driver_library：驱动文件路径
  - jdbc_driver_class：驱动类名
  - jdbc_connection_string：连接字符串  
  - jdbc_user/jdbc_password：用户认证

🔸 查询控制：
  - statement：SQL查询语句
  - schedule：执行调度计划

🔸 增量同步：
  - use_column_value：开启增量模式
  - tracking_column：追踪字段名
  - tracking_column_type：字段类型
```

### 8.2 关键理解要点


**🔹 增量同步的核心思想**
- 记住上次读取位置，避免重复处理数据
- 通过时间戳或ID字段实现断点续传
- 状态文件保存进度信息

**🔹 调度策略选择**
- 高频业务：5-15分钟一次
- 常规同步：30分钟-1小时
- 大量数据：按小时或按天

**🔹 性能优化原则**
- 合理设置查询间隔
- 限制单次查询数据量
- 使用索引优化SQL查询

### 8.3 实际应用价值


**📊 业务场景应用**
- **电商订单**：实时同步订单状态变化
- **用户行为**：采集用户操作日志数据  
- **财务数据**：定期同步交易流水记录
- **库存管理**：监控商品库存变化情况

**🔧 运维监控建议**
- 监控Logstash运行状态
- 检查数据同步延迟情况
- 定期备份状态文件
- 设置异常告警机制

**核心记忆口诀**：
- 四要素连接数据库，SQL语句定义查询
- 调度计划控制频率，增量同步避重复
- 状态文件记进度，异常监控保稳定