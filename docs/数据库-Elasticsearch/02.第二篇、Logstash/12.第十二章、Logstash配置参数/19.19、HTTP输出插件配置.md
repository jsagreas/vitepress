---
title: 19、HTTP输出插件配置
---
## 📚 目录

1. [HTTP输出插件基础概念](#1-HTTP输出插件基础概念)
2. [URL参数配置详解](#2-URL参数配置详解)
3. [HTTP方法参数设置](#3-HTTP方法参数设置)
4. [HTTP头部设置](#4-HTTP头部设置)
5. [认证参数配置](#5-认证参数配置)
6. [消息格式与字段映射](#6-消息格式与字段映射)
7. [连接池优化配置](#7-连接池优化配置)
8. [实战配置案例](#8-实战配置案例)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 HTTP输出插件基础概念


### 1.1 什么是HTTP输出插件


**简单理解**：HTTP输出插件就像一个"数据邮递员"，它把Logstash处理好的数据通过HTTP协议发送到指定的网站或API接口。

```
数据流向示意图：
输入数据 → Logstash处理 → HTTP输出插件 → 目标服务器
   ↓           ↓              ↓           ↓
  日志        格式化         HTTP请求     API接收
```

**核心作用**：
- 📤 **数据推送**：将处理后的数据推送到外部系统
- 🔗 **系统集成**：连接不同的系统和服务
- 📊 **实时传输**：实时将数据发送到目标端
- 🔄 **数据分发**：同时向多个目标发送数据

### 1.2 使用场景说明


**典型应用场景**：
```
🎯 监控告警：将异常日志发送到告警系统
🎯 数据同步：将数据推送到其他数据库或系统
🎯 API集成：调用第三方API接口
🎯 Webhook通知：触发其他系统的处理流程
```

**为什么需要HTTP输出**：
- **灵活性**：几乎所有现代系统都支持HTTP协议
- **标准化**：HTTP是通用的网络协议
- **实时性**：可以实时推送数据
- **扩展性**：可以轻松集成各种外部服务

---

## 2. 🎯 URL参数配置详解


### 2.1 url参数基础


**什么是url参数**：
url参数就是告诉Logstash"把数据发送到哪里去"，就像写信要写明收件人地址一样。

```ruby
output {
  http {
    url => "http://example.com/api/logs"
  }
}
```

### 2.2 URL格式详解


**标准URL格式**：
```
协议://域名:端口/路径?查询参数
http://api.example.com:8080/logs/receive?token=abc123
 ↓      ↓              ↓     ↓           ↓
协议   域名           端口   路径      查询参数
```

**各部分说明**：
- **协议**：http 或 https（推荐https保证安全）
- **域名**：目标服务器地址
- **端口**：服务端口（http默认80，https默认443）
- **路径**：API接口路径
- **查询参数**：附加的参数信息

### 2.3 动态URL配置


**使用字段动态构建URL**：
```ruby
output {
  http {
    # 根据日志级别动态选择接口
    url => "http://api.example.com/logs/%{[log_level]}"
    # 实际效果：
    # log_level=error → http://api.example.com/logs/error
    # log_level=info  → http://api.example.com/logs/info
  }
}
```

**多种URL配置示例**：

| 配置类型 | **示例** | **说明** |
|---------|----------|----------|
| **固定URL** | `"http://api.com/logs"` | 所有数据发到同一接口 |
| **动态路径** | `"http://api.com/%{type}"` | 根据type字段动态路径 |
| **带参数** | `"http://api.com/logs?app=%{app}"` | URL包含查询参数 |
| **HTTPS安全** | `"https://secure-api.com/data"` | 使用加密传输 |

---

## 3. 🔧 HTTP方法参数设置


### 3.1 http_method参数概念


**什么是HTTP方法**：
HTTP方法就像不同的"操作指令"，告诉服务器你想做什么操作。

```
生活类比：
POST → "我要新增一条记录"（像往箱子里放东西）
PUT  → "我要更新一条记录"（像替换箱子里的东西）
GET  → "我要查询数据"（像看箱子里有什么）
```

### 3.2 常用HTTP方法


**POST方法（最常用）**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    http_method => "post"  # 新增数据，默认值
  }
}
```

**PUT方法**：
```ruby
output {
  http {
    url => "http://api.example.com/logs/%{id}"
    http_method => "put"   # 更新指定ID的数据
  }
}
```

**方法选择指南**：

| HTTP方法 | **适用场景** | **数据位置** | **幂等性** |
|----------|-------------|-------------|-----------|
| **POST** | `新增日志记录` | `请求体` | `否` |
| **PUT** | `更新现有记录` | `请求体` | `是` |
| **PATCH** | `部分更新记录` | `请求体` | `否` |
| **GET** | `很少用于输出` | `URL参数` | `是` |

> 💡 **新手提示**：99%的情况下使用POST方法就够了，它是最通用的数据发送方式。

---

## 4. 📋 HTTP头部设置


### 4.1 headers参数作用


**什么是HTTP头部**：
HTTP头部就像信封上的"备注信息"，告诉接收方一些额外的重要信息。

```
信件类比：
信封正面 → URL地址（发给谁）
信封内容 → 数据内容（发什么）
信封备注 → HTTP头部（怎么处理）
```

### 4.2 常用头部配置


**基础头部设置**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    headers => {
      "Content-Type" => "application/json"
      "User-Agent" => "Logstash/8.0"
      "Accept" => "application/json"
    }
  }
}
```

**重要头部说明**：

```
Content-Type → 告诉服务器数据是什么格式
├─ application/json    (JSON格式，最常用)
├─ application/xml     (XML格式)
├─ text/plain         (纯文本格式)
└─ application/x-www-form-urlencoded (表单格式)

Authorization → 身份认证信息
├─ Bearer token123    (Token认证)
├─ Basic dXNlcjpwYXNz (基础认证)
└─ Custom auth-key    (自定义认证)
```

### 4.3 动态头部配置


**根据数据内容设置头部**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    headers => {
      "Content-Type" => "application/json"
      "X-Log-Level" => "%{[log_level]}"
      "X-Source-Host" => "%{[host]}"
    }
  }
}
```

**API密钥头部配置**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    headers => {
      "Content-Type" => "application/json"
      "API-Key" => "your-secret-api-key"
      "X-Request-ID" => "%{[@metadata][request_id]}"
    }
  }
}
```

---

## 5. 🔐 认证参数配置


### 5.1 用户名密码认证


**什么是HTTP基础认证**：
就像进入需要账号密码的网站一样，API也可能需要用户名和密码验证身份。

```ruby
output {
  http {
    url => "http://secure-api.example.com/logs"
    user => "your_username"
    password => "your_password"
  }
}
```

**认证流程说明**：
```
客户端请求 → 服务器要求认证 → 提供用户名密码 → 验证通过 → 接收数据
     ↓              ↓                ↓           ↓         ↓
   Logstash      返回401           编码认证信息    验证身份   处理数据
```

### 5.2 认证安全最佳实践


**密码安全配置**：
```ruby
# ❌ 不好的做法：密码明文写在配置文件
output {
  http {
    user => "admin"
    password => "123456"  # 不安全！
  }
}

# ✅ 推荐做法：使用环境变量
output {
  http {
    user => "${HTTP_USERNAME}"
    password => "${HTTP_PASSWORD}"
  }
}
```

**设置环境变量**：
```bash
# Linux/Mac设置
export HTTP_USERNAME="your_username"
export HTTP_PASSWORD="your_secure_password"

# Windows设置
set HTTP_USERNAME=your_username
set HTTP_PASSWORD=your_secure_password
```

### 5.3 Token认证方式


**使用API Token**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    headers => {
      "Authorization" => "Bearer ${API_TOKEN}"
      "Content-Type" => "application/json"
    }
  }
}
```

> ⚠️ **安全提醒**：永远不要把密码和API密钥直接写在配置文件里，要使用环境变量或密钥管理工具。

---

## 6. 📄 消息格式与字段映射


### 6.1 format参数详解


**什么是消息格式**：
format参数决定数据以什么"样子"发送出去，就像选择用JSON格式还是纯文本格式包装你的数据。

```ruby
output {
  http {
    url => "http://api.example.com/logs"
    format => "json"  # 最常用的格式
  }
}
```

**支持的格式类型**：

| 格式 | **说明** | **适用场景** | **示例** |
|------|----------|-------------|----------|
| **json** | `JSON格式` | `API接口最常用` | `{"message":"log text"}` |
| **form** | `表单格式` | `传统Web表单` | `message=log+text&level=info` |
| **message** | `纯文本` | `简单文本接口` | `log text` |

### 6.2 JSON格式详细配置


**默认JSON输出**：
```ruby
# 输入日志：{"message": "Error occurred", "level": "error", "host": "web01"}
output {
  http {
    url => "http://api.example.com/logs"
    format => "json"
  }
}
# 发送数据：{"message":"Error occurred","level":"error","host":"web01"}
```

**自定义JSON格式**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    format => "json"
    mapping => {
      "log_message" => "%{message}"
      "log_level" => "%{level}"
      "timestamp" => "%{@timestamp}"
      "source" => "%{host}"
    }
  }
}
# 发送数据：{"log_message":"Error occurred","log_level":"error",...}
```

### 6.3 mapping参数使用


**什么是字段映射**：
mapping就像"翻译器"，把Logstash内部的字段名翻译成目标系统需要的字段名。

```
原始字段名 → mapping映射 → 目标字段名
  message  →    翻译     →  log_content
   level   →    翻译     →  severity
   host    →    翻译     →  server_name
```

**实用映射配置**：
```ruby
output {
  http {
    url => "http://monitoring.example.com/alerts"
    format => "json"
    mapping => {
      # 基础字段映射
      "content" => "%{message}"
      "severity" => "%{level}"
      "server" => "%{host}"
      
      # 时间格式化
      "event_time" => "%{+YYYY-MM-dd HH:mm:ss}"
      
      # 组合字段
      "full_message" => "[%{level}] %{message} from %{host}"
      
      # 条件字段
      "priority" => "%{[fields][priority]}"
    }
  }
}
```

**映射实际效果**：
```json
// 原始数据
{
  "message": "Database connection failed",
  "level": "error",
  "host": "db-server-01",
  "@timestamp": "2024-01-15T10:30:00Z"
}

// 映射后发送的数据
{
  "content": "Database connection failed",
  "severity": "error", 
  "server": "db-server-01",
  "event_time": "2024-01-15 10:30:00",
  "full_message": "[error] Database connection failed from db-server-01"
}
```

---

## 7. 🔧 连接池优化配置


### 7.1 pool_max参数概念


**什么是连接池**：
连接池就像停车场，提前准备好多个"停车位"（连接），需要时直接使用，用完归还，避免每次都重新"找停车位"（建立连接）。

```
没有连接池的情况：
请求1 → 建立连接 → 发送数据 → 关闭连接
请求2 → 建立连接 → 发送数据 → 关闭连接  (重复建立，效率低)

有连接池的情况：
请求1 → 从池中取连接 → 发送数据 → 归还连接
请求2 → 从池中取连接 → 发送数据 → 归还连接  (复用连接，效率高)
```

### 7.2 连接池大小设置


**基础配置**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    pool_max => 50  # 最多保持50个连接
  }
}
```

**连接池大小选择指南**：

| 数据量级 | **推荐pool_max** | **说明** |
|---------|-----------------|----------|
| **小量** | `5-10` | `每秒几百条日志` |
| **中量** | `20-50` | `每秒几千条日志` |
| **大量** | `50-100` | `每秒上万条日志` |
| **超大量** | `100+` | `每秒数万条日志` |

### 7.3 其他连接优化参数


**完整连接优化配置**：
```ruby
output {
  http {
    url => "http://api.example.com/logs"
    
    # 连接池设置
    pool_max => 50                    # 最大连接数
    pool_max_per_route => 25          # 每个路由最大连接数
    
    # 超时设置
    connect_timeout => 10             # 连接超时(秒)
    socket_timeout => 10              # 读取超时(秒)
    request_timeout => 60             # 请求总超时(秒)
    
    # 重试设置
    retry_non_idempotent => true      # 允许重试
    retries => 3                      # 最大重试次数
  }
}
```

**参数详细说明**：
- **connect_timeout**：建立连接的最长等待时间
- **socket_timeout**：数据传输的最长等待时间  
- **request_timeout**：整个请求的最长时间
- **retries**：失败时重试的次数

---

## 8. 🚀 实战配置案例


### 8.1 监控告警配置


**场景**：将错误日志发送到告警系统
```ruby
output {
  # 只处理错误级别的日志
  if [level] == "error" {
    http {
      url => "https://alerts.company.com/api/incidents"
      http_method => "post"
      
      headers => {
        "Content-Type" => "application/json"
        "Authorization" => "Bearer ${ALERT_API_TOKEN}"
        "X-Alert-Source" => "logstash"
      }
      
      mapping => {
        "title" => "系统错误：%{message}"
        "description" => "%{message}"
        "severity" => "high"
        "source" => "%{host}"
        "timestamp" => "%{@timestamp}"
        "tags" => ["%{service}", "%{environment}"]
      }
      
      # 高可靠性设置
      pool_max => 20
      connect_timeout => 5
      retries => 3
    }
  }
}
```

### 8.2 数据同步配置


**场景**：将处理后的数据同步到外部系统
```ruby
output {
  http {
    url => "http://datawarehouse.company.com/api/logs/%{[fields][table_name]}"
    http_method => "post"
    
    headers => {
      "Content-Type" => "application/json"
      "API-Key" => "${DW_API_KEY}"
      "X-Data-Source" => "application-logs"
    }
    
    format => "json"
    mapping => {
      "id" => "%{[@metadata][doc_id]}"
      "log_content" => "%{message}"
      "log_level" => "%{level}"
      "application" => "%{[fields][app_name]}"
      "server_name" => "%{host}"
      "created_at" => "%{@timestamp}"
      "processed_at" => "%{+YYYY-MM-dd'T'HH:mm:ss.SSSZ}"
    }
    
    # 性能优化
    pool_max => 100
    pool_max_per_route => 50
    socket_timeout => 30
  }
}
```

### 8.3 Webhook通知配置


**场景**：触发其他系统的处理流程
```ruby
output {
  # 当检测到特定模式时发送webhook
  if [message] =~ /CRITICAL|FATAL/ {
    http {
      url => "https://automation.company.com/webhooks/log-critical"
      http_method => "post"
      
      headers => {
        "Content-Type" => "application/json"
        "X-Webhook-Secret" => "${WEBHOOK_SECRET}"
        "User-Agent" => "Logstash-Webhook/1.0"
      }
      
      mapping => {
        "event_type" => "critical_log"
        "message" => "%{message}"
        "host" => "%{host}"
        "service" => "%{[fields][service_name]}"
        "timestamp" => "%{@timestamp}"
        "urgency" => "high"
        "metadata" => {
          "environment" => "%{[fields][env]}"
          "version" => "%{[fields][app_version]}"
        }
      }
      
      # 快速响应设置
      connect_timeout => 3
      socket_timeout => 10
      retries => 2
    }
  }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 HTTP输出插件：Logstash向外部系统发送数据的桥梁
🔸 URL配置：指定数据发送的目标地址，支持动态构建
🔸 HTTP方法：POST用于新增，PUT用于更新，99%用POST
🔸 认证配置：保护API安全，推荐使用环境变量存储密钥
🔸 消息格式：JSON是最常用格式，mapping实现字段重命名
🔸 连接池：提高性能，避免频繁建立连接的开销
```

### 9.2 关键理解要点


**🔹 参数优先级理解**：
```
基础配置 → 必须正确的URL和认证
格式配置 → format和mapping决定数据样式  
性能配置 → 连接池和超时优化传输效率
安全配置 → 头部和认证保护数据安全
```

**🔹 常见配置模式**：
```
简单发送：只需要url + format
安全发送：添加认证头部和HTTPS
批量发送：配置连接池和超时参数
定制发送：使用mapping重新组织数据结构
```

**🔹 性能优化思路**：
```
连接复用：设置合适的pool_max值
超时控制：避免长时间等待影响整体性能
重试机制：处理网络不稳定情况
批量处理：在Filter阶段聚合数据减少请求次数
```

### 9.3 实际应用价值


**🎯 业务场景应用**：
- **监控告警**：实时推送异常信息到告警平台
- **数据集成**：将日志数据同步到数据仓库
- **自动化触发**：通过Webhook启动自动化流程
- **第三方集成**：对接各种外部API和服务

**🔧 配置最佳实践**：
- **安全第一**：使用HTTPS和环境变量保护敏感信息
- **性能优化**：根据数据量合理设置连接池大小
- **错误处理**：配置重试和超时机制提高可靠性
- **监控调试**：添加适当的日志输出便于问题排查

### 9.4 新手学习要点


- [x] 理解HTTP输出插件的基本作用和工作原理
- [x] 掌握URL配置的各种形式和动态构建方法
- [x] 学会设置HTTP头部和认证参数
- [x] 熟练使用format和mapping参数控制数据格式
- [x] 了解连接池优化对性能的重要作用
- [ ] 在实际项目中应用不同的配置模式
- [ ] 学会调试和排查HTTP输出的常见问题

**核心记忆**：
- HTTP输出是数据的"邮递员"，负责把处理好的数据安全快速地送到目的地
- URL告诉去哪里，认证证明是谁，格式决定怎么包装，连接池提高效率
- 安全配置和性能优化同样重要，实际使用中要根据业务需求灵活调整参数