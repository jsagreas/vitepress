---
title: 2、网络数据输入
---
## 📚 目录

1. [网络输入概述](#1-网络输入概述)
2. [Beats插件详解](#2-Beats插件详解)
3. [TCP/UDP网络输入](#3-TCP-UDP网络输入)
4. [HTTP接口输入](#4-HTTP接口输入)
5. [SSL安全传输配置](#5-SSL安全传输配置)
6. [性能优化与最佳实践](#6-性能优化与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌐 网络输入概述


### 1.1 什么是网络数据输入


**通俗理解**：网络数据输入就是让Logstash通过网络接收数据，就像开了一个"数据接收窗口"

```
想象一个场景：
你的公司有很多台服务器 → 每台都在产生日志 → 需要统一收集分析
这时候Logstash就像一个"数据收集站"，通过网络接收各个服务器发来的数据

现实类比：
邮局 ← 各地邮件投递 ← 不同地方的信件
Logstash ← 网络数据传输 ← 不同服务器的日志
```

### 1.2 网络输入的核心优势


**🔸 集中化收集**
- **解决问题**：避免一台台服务器去收集日志
- **实际价值**：一个Logstash可以接收成百上千台机器的数据
- **效率提升**：统一管理，减少运维复杂度

**🔸 实时传输**
- **传统方式**：定时把日志文件拷贝过来（慢且不及时）
- **网络输入**：数据产生后立即发送（实时性强）

**🔸 可靠传输**
- **数据安全**：支持加密传输，防止数据泄露
- **传输保障**：有重试机制，确保数据不丢失

### 1.3 主要网络输入方式


```
Logstash网络输入方式对比：

┌─────────────┬──────────────┬──────────────┬─────────────┐
│   输入方式   │   适用场景   │   传输协议   │   安全性    │
├─────────────┼──────────────┼──────────────┼─────────────┤
│ Beats插件   │ 日志文件收集 │   专用协议   │    很高     │
├─────────────┼──────────────┼──────────────┼─────────────┤
│ TCP输入     │ 应用直接发送 │     TCP      │     中等    │
├─────────────┼──────────────┼──────────────┼─────────────┤
│ UDP输入     │ 高并发场景   │     UDP      │     较低    │
├─────────────┼──────────────┼──────────────┼─────────────┤
│ HTTP输入    │ API接口调用  │     HTTP     │     高      │
└─────────────┴──────────────┴──────────────┴─────────────┘
```

---

## 2. 🔄 Beats插件详解


### 2.1 什么是Beats


**简单理解**：Beats是Elastic公司专门开发的"数据搬运工"

> 💡 **形象比喻**：如果Logstash是工厂的原料接收站，那么Beats就是专门运送原料的卡车，它们配合默契，专业高效

**Beats家族成员**：
- **Filebeat** → 专门收集日志文件（最常用）
- **Metricbeat** → 专门收集系统指标
- **Packetbeat** → 专门监控网络流量
- **Winlogbeat** → 专门收集Windows事件日志

### 2.2 Beats插件基础配置


**🔸 最简单的配置**

```ruby
input {
  beats {
    port => 5044                    # 监听端口
  }
}
```

**配置说明**：
- `port => 5044`：这是Beats的**默认端口**，就像HTTP默认用80端口一样
- Filebeat会主动连接到这个端口，发送数据给Logstash

### 2.3 Beats插件高级配置


```ruby
input {
  beats {
    port => 5044
    host => "0.0.0.0"               # 监听所有网络接口
    client_inactivity_timeout => 60  # 客户端超时时间
    include_codec_tag => false       # 不添加codec标签
    enrich => [source_metadata]      # 添加源数据信息
    ssl => true                      # 启用SSL加密
    ssl_certificate => "/path/to/cert.pem"
    ssl_key => "/path/to/private.key"
  }
}
```

**参数详细解释**：

| 参数 | 作用 | 新手理解 |
|------|------|----------|
| `host` | 指定监听的IP地址 | `0.0.0.0`表示接受任何IP的连接 |
| `client_inactivity_timeout` | 客户端超时时间 | 如果60秒没数据就断开连接 |
| `include_codec_tag` | 是否添加编码标签 | 一般设为false，减少不必要信息 |
| `enrich` | 添加额外信息 | 可以获取发送方的IP、主机名等 |

### 2.4 与Filebeat的完整配合


**Filebeat端配置示例**：
```yaml
# filebeat.yml
filebeat.inputs:
- type: log
  paths:
    - /var/log/*.log

output.logstash:
  hosts: ["192.168.1.100:5044"]    # Logstash的IP和端口
```

**数据流向图**：
```
服务器A (Filebeat) ──┐
                     ├──→ Logstash (5044端口) ──→ 数据处理
服务器B (Filebeat) ──┘
```

---

## 3. 🔌 TCP/UDP网络输入


### 3.1 TCP输入详解


**什么是TCP输入**：
TCP输入就是让Logstash像服务器一样，等待其他程序通过TCP协议发送数据过来

> 📝 **生活类比**：TCP就像打电话，双方要先"握手"建立连接，然后可靠地传输信息，确保对方收到

### 3.2 TCP输入基础配置


```ruby
input {
  tcp {
    port => 9999                    # 监听端口
    codec => json                   # 数据格式
  }
}
```

**实际应用场景**：
```python
# Python应用发送日志到Logstash
import socket
import json

def send_log_to_logstash(message):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('logstash-server', 9999))
    
    log_data = {
        "timestamp": "2024-01-01T10:00:00",
        "level": "INFO", 
        "message": message
    }
    
    sock.send(json.dumps(log_data).encode())
    sock.close()
```

### 3.3 TCP输入高级配置


```ruby
input {
  tcp {
    port => 9999
    host => "0.0.0.0"               # 监听所有接口
    codec => json                   # JSON格式解析
    ssl_enable => true              # 启用SSL
    ssl_cert => "/path/to/cert.pem"
    ssl_key => "/path/to/key.pem"
    tcp_keep_alive => true          # 保持连接
  }
}
```

### 3.4 UDP输入详解


**什么是UDP输入**：
UDP输入是无连接的数据接收方式，速度快但不保证数据一定到达

> 📝 **生活类比**：UDP就像发短信，发出去就不管了，速度快但不确保对方一定收到

```ruby
input {
  udp {
    port => 8888
    codec => json
    buffer_size => 65536            # 缓冲区大小
    queue_size => 2000              # 队列大小
  }
}
```

### 3.5 TCP vs UDP 选择指南


```
使用TCP的场景：
✅ 重要的业务日志（绝对不能丢）
✅ 数据量不是特别大
✅ 对实时性要求不是极致

使用UDP的场景：
✅ 监控指标数据（偶尔丢一两个点可以接受）
✅ 高并发、大数据量场景
✅ 对性能要求极高
```

---

## 4. 🌐 HTTP接口输入


### 4.1 HTTP输入的应用价值


**为什么需要HTTP输入**：
现代应用很多都是微服务架构，通过HTTP API相互调用，HTTP输入让这些应用可以直接发送日志给Logstash

> 💡 **实际场景**：你的Web应用在处理用户请求时，可以直接通过HTTP POST发送操作日志到Logstash

### 4.2 HTTP输入基础配置


```ruby
input {
  http {
    port => 8080                    # HTTP监听端口
    codec => json                   # 解析JSON数据
  }
}
```

**客户端发送示例**：
```bash
# 使用curl发送数据
curl -X POST "http://logstash-server:8080" \
  -H "Content-Type: application/json" \
  -d '{
    "timestamp": "2024-01-01T10:00:00",
    "user_id": "12345",
    "action": "login",
    "ip": "192.168.1.100"
  }'
```

### 4.3 HTTP输入高级配置


```ruby
input {
  http {
    port => 8080
    host => "0.0.0.0"               # 监听所有接口
    codec => json                   # JSON解析
    
    # 安全配置
    ssl => true                     # 启用HTTPS
    ssl_certificate => "/path/to/cert.pem"
    ssl_key => "/path/to/key.pem"
    
    # 认证配置
    user => "admin"                 # 基础认证用户名
    password => "password"          # 基础认证密码
    
    # 性能配置
    threads => 4                    # 处理线程数
    max_pending_requests => 200     # 最大等待请求数
    response_headers => {           # 响应头设置
      "Access-Control-Allow-Origin" => "*"
    }
  }
}
```

### 4.4 HTTP输入实战应用


**Web应用集成示例**：
```javascript
// Node.js应用发送日志
const axios = require('axios');

async function sendLogToLogstash(logData) {
  try {
    await axios.post('http://logstash-server:8080', {
      timestamp: new Date().toISOString(),
      service: 'user-service',
      level: 'INFO',
      message: logData.message,
      user_id: logData.userId,
      request_id: logData.requestId
    }, {
      auth: {
        username: 'admin',
        password: 'password'
      }
    });
  } catch (error) {
    console.error('发送日志失败:', error.message);
  }
}
```

---

## 5. 🔒 SSL安全传输配置


### 5.1 为什么需要SSL


**安全问题**：
网络传输的数据可能被窃听或篡改，特别是包含敏感信息的日志

> ⚠️ **安全警告**：如果日志中包含用户信息、订单数据等敏感内容，不加密传输就像明信片一样，任何人都能看到

### 5.2 SSL证书准备


**生成自签名证书**（仅测试环境使用）：
```bash
# 生成私钥
openssl genrsa -out logstash.key 2048

# 生成证书
openssl req -new -x509 -key logstash.key -out logstash.crt -days 365
```

### 5.3 各种输入的SSL配置


**Beats输入SSL配置**：
```ruby
input {
  beats {
    port => 5044
    ssl => true
    ssl_certificate => "/etc/logstash/ssl/logstash.crt"
    ssl_key => "/etc/logstash/ssl/logstash.key"
    ssl_verify_mode => "force_peer"    # 强制验证客户端证书
  }
}
```

**HTTP输入SSL配置**：
```ruby
input {
  http {
    port => 8443                       # HTTPS端口
    ssl => true
    ssl_certificate => "/etc/logstash/ssl/logstash.crt"
    ssl_key => "/etc/logstash/ssl/logstash.key"
    ssl_verify_mode => "none"          # 不验证客户端证书
  }
}
```

**TCP输入SSL配置**：
```ruby
input {
  tcp {
    port => 9999
    ssl_enable => true
    ssl_cert => "/etc/logstash/ssl/logstash.crt"
    ssl_key => "/etc/logstash/ssl/logstash.key"
    ssl_verify => false                # 不验证客户端
  }
}
```

### 5.4 客户端SSL配置


**Filebeat SSL配置**：
```yaml
output.logstash:
  hosts: ["logstash-server:5044"]
  ssl.certificate_authorities: ["/etc/ssl/certs/logstash.crt"]
  ssl.verification_mode: certificate
```

---

## 6. ⚡ 性能优化与最佳实践


### 6.1 端口监听优化


**多端口策略**：
```ruby
# 不同类型数据使用不同端口
input {
  beats {
    port => 5044    # 日志数据
    type => "logs"
  }
}

input {
  beats {
    port => 5045    # 监控指标
    type => "metrics"
  }
}

input {
  http {
    port => 8080    # API日志
    type => "api_logs"
  }
}
```

**优势说明**：
- **数据分类**：不同类型数据分开处理
- **性能提升**：避免单一端口压力过大
- **故障隔离**：一个端口有问题不影响其他

### 6.2 缓冲区和队列优化


```ruby
input {
  tcp {
    port => 9999
    codec => json
    
    # 缓冲区优化
    buffer_size => 65536          # 64KB缓冲区
    
    # 连接优化
    tcp_keep_alive => true        # 保持TCP连接
    so_keepalive => true          # 系统级保活
  }
}

input {
  udp {
    port => 8888
    codec => json
    
    # UDP特有优化
    buffer_size => 65536          # 接收缓冲区
    queue_size => 2000            # 内部队列大小
    workers => 2                  # 工作线程数
  }
}
```

### 6.3 资源监控与调优


**监控关键指标**：
```ruby
# 在logstash.yml中启用监控
monitoring.enabled: true
monitoring.elasticsearch.hosts: ["http://localhost:9200"]

# API端点监控
http.host: "0.0.0.0"
http.port: 9600
```

**通过API查看性能**：
```bash
# 查看输入插件状态
curl "http://logstash-server:9600/_node/stats/pipelines"

# 查看具体输入统计
curl "http://logstash-server:9600/_node/stats/pipelines/main/plugins/inputs"
```

### 6.4 故障排查技巧


**常见问题诊断**：

| 问题现象 | 可能原因 | 解决方法 |
|----------|----------|----------|
| 连接被拒绝 | 端口未监听或防火墙阻止 | 检查配置和防火墙规则 |
| 数据丢失 | UDP缓冲区溢出 | 增大buffer_size和queue_size |
| SSL握手失败 | 证书问题或配置错误 | 检查证书路径和权限 |
| 性能慢 | 单线程处理或网络延迟 | 增加workers或优化网络 |

**调试模式启用**：
```ruby
input {
  tcp {
    port => 9999
    codec => json
    
    # 启用调试日志
    add_field => { "debug" => "tcp_input" }
  }
}

# 在logstash.yml中设置日志级别
log.level: debug
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 网络输入本质：通过网络协议接收外部数据的方式
🔸 四种主要方式：Beats、TCP、UDP、HTTP各有适用场景
🔸 安全传输：SSL/TLS加密保护敏感数据
🔸 性能优化：合理配置缓冲区、队列、线程数
🔸 监控运维：实时监控连接状态和性能指标
```

### 7.2 实际应用选择指南


**🔹 Beats输入（推荐新手首选）**
```
适用场景：
✅ 收集服务器日志文件
✅ 需要可靠传输的场景
✅ 有现成的Beat工具可用

配置要点：
- 使用默认5044端口
- 启用SSL保证安全
- 配置适当超时时间
```

**🔹 HTTP输入（Web应用友好）**
```
适用场景：
✅ 微服务架构的应用日志
✅ 需要通过API发送数据
✅ 与现有HTTP基础设施集成

配置要点：
- 选择合适端口（避免冲突）
- 配置认证机制
- 设置CORS头（如需要）
```

**🔹 TCP/UDP输入（高性能场景）**
```
TCP适用：重要业务数据，需要可靠传输
UDP适用：监控指标，高并发，可容忍丢失

配置要点：
- TCP注重连接保持和重连机制
- UDP注重缓冲区和队列大小
- 都要考虑SSL加密需求
```

### 7.3 最佳实践总结


**🔸 安全实践**
- 生产环境必须启用SSL
- 使用正规CA签发的证书
- 配置合适的认证机制
- 定期更新证书

**🔸 性能实践**
- 根据数据量选择合适的输入方式
- 合理配置缓冲区大小
- 使用多端口分散压力
- 定期监控性能指标

**🔸 运维实践**
- 详细记录配置变更
- 建立监控告警机制
- 准备故障处理预案
- 定期备份配置文件

### 7.4 新手学习路径


```
学习顺序建议：
第1步：掌握Beats输入 ⭐（最实用）
第2步：了解HTTP输入 ⭐⭐（Web开发需要）
第3步：学习TCP输入 ⭐⭐（自定义应用）
第4步：理解UDP输入 ⭐⭐⭐（高级场景）
第5步：SSL安全配置 ⭐⭐⭐（生产必需）
```

**核心记忆要点**：
- 网络输入让Logstash变身"数据接收站"
- Beats是官方推荐的数据传输方式
- HTTP输入最适合现代Web应用
- SSL加密是生产环境的必备配置
- 性能优化要从缓冲区、队列、线程多方面考虑