---
title: 17ã€ruby-filter.conf Rubyè„šæœ¬è¿‡æ»¤å™¨
---
## ğŸ“š ç›®å½•

1. [Rubyè¿‡æ»¤å™¨åŸºç¡€æ¦‚å¿µ](#1-Rubyè¿‡æ»¤å™¨åŸºç¡€æ¦‚å¿µ)
2. [å†…è”Rubyä»£ç å®ç°](#2-å†…è”Rubyä»£ç å®ç°)
3. [å¤–éƒ¨è„šæœ¬æ–‡ä»¶é…ç½®](#3-å¤–éƒ¨è„šæœ¬æ–‡ä»¶é…ç½®)
4. [è„šæœ¬å‚æ•°ä¼ é€’æœºåˆ¶](#4-è„šæœ¬å‚æ•°ä¼ é€’æœºåˆ¶)
5. [äº‹ä»¶å¯¹è±¡æ“ä½œè¯¦è§£](#5-äº‹ä»¶å¯¹è±¡æ“ä½œè¯¦è§£)
6. [å­—æ®µåŠ¨æ€å¤„ç†æŠ€å·§](#6-å­—æ®µåŠ¨æ€å¤„ç†æŠ€å·§)
7. [æ¡ä»¶é€»è¾‘å®ç°æ–¹æ³•](#7-æ¡ä»¶é€»è¾‘å®ç°æ–¹æ³•)
8. [å¼‚å¸¸å¤„ç†æœºåˆ¶](#8-å¼‚å¸¸å¤„ç†æœºåˆ¶)
9. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#9-æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
10. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#10-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ”§ Rubyè¿‡æ»¤å™¨åŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯Rubyè¿‡æ»¤å™¨


**ç®€å•ç†è§£**ï¼šRubyè¿‡æ»¤å™¨å°±æ˜¯åœ¨Logstashæ•°æ®å¤„ç†æµç¨‹ä¸­ï¼Œè®©ä½ ç”¨Rubyç¼–ç¨‹è¯­è¨€æ¥è‡ªå®šä¹‰æ•°æ®å¤„ç†é€»è¾‘çš„å·¥å…·ã€‚

```
æ•°æ®æµå‘ç¤ºæ„ï¼š
è¾“å…¥æ•°æ® â†’ [å…¶ä»–è¿‡æ»¤å™¨] â†’ Rubyè¿‡æ»¤å™¨ â†’ [å…¶ä»–è¿‡æ»¤å™¨] â†’ è¾“å‡º
                          â†‘
                    åœ¨è¿™é‡Œæ‰§è¡Œä½ çš„Rubyä»£ç 
```

**æ ¸å¿ƒä½œç”¨**ï¼š
- **è‡ªå®šä¹‰é€»è¾‘**ï¼šå½“ç°æœ‰è¿‡æ»¤å™¨æ— æ³•æ»¡è¶³éœ€æ±‚æ—¶ï¼Œç”¨Rubyç¼–å†™å¤„ç†é€»è¾‘
- **å¤æ‚è®¡ç®—**ï¼šè¿›è¡Œæ•°å­¦è¿ç®—ã€å­—ç¬¦ä¸²å¤„ç†ç­‰å¤æ‚æ“ä½œ
- **åŠ¨æ€å¤„ç†**ï¼šæ ¹æ®æ•°æ®å†…å®¹åŠ¨æ€è°ƒæ•´å¤„ç†æ–¹å¼
- **æ•°æ®è½¬æ¢**ï¼šå°†æ•°æ®ä»ä¸€ç§æ ¼å¼è½¬æ¢ä¸ºå¦ä¸€ç§æ ¼å¼

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦Rubyè¿‡æ»¤å™¨


**ä½¿ç”¨åœºæ™¯ä¸¾ä¾‹**ï¼š
```
âŒ æ™®é€šè¿‡æ»¤å™¨åšä¸åˆ°çš„äº‹æƒ…ï¼š
- å¤æ‚çš„æ•°å­¦è®¡ç®—ï¼ˆå¦‚è®¡ç®—ä¸¤ä¸ªæ—¶é—´æˆ³çš„å·®å€¼ï¼‰
- å¤æ‚çš„å­—ç¬¦ä¸²æ“ä½œï¼ˆå¦‚æå–ç‰¹å®šæ ¼å¼çš„æ•°æ®ï¼‰
- åŠ¨æ€å­—æ®µåç”Ÿæˆ
- å¤æ‚çš„æ¡ä»¶åˆ¤æ–­é€»è¾‘

âœ… Rubyè¿‡æ»¤å™¨å¯ä»¥è½»æ¾å®ç°ï¼š
- ä»»ä½•ä½ èƒ½ç”¨Rubyè¯­è¨€å®ç°çš„é€»è¾‘
- ç›´æ¥æ“ä½œLogstashäº‹ä»¶å¯¹è±¡
- çµæ´»çš„æ•°æ®å¤„ç†å’Œè½¬æ¢
```

### 1.3 Rubyè¿‡æ»¤å™¨çš„å·¥ä½œåŸç†


**æ‰§è¡Œæµç¨‹**ï¼š
```
1. Logstashæ¥æ”¶åˆ°äº‹ä»¶æ•°æ®
2. äº‹ä»¶ä¼ é€’ç»™Rubyè¿‡æ»¤å™¨
3. Rubyä»£ç è®¿é—®å¹¶ä¿®æ”¹äº‹ä»¶æ•°æ®
4. å¤„ç†å®Œæˆåï¼Œäº‹ä»¶ç»§ç»­ä¼ é€’ç»™ä¸‹ä¸€ä¸ªè¿‡æ»¤å™¨
5. æœ€ç»ˆè¾“å‡ºåˆ°ç›®æ ‡ç³»ç»Ÿ
```

**äº‹ä»¶å¯¹è±¡ç»“æ„**ï¼š
```
äº‹ä»¶å¯¹è±¡(event)åŒ…å«ï¼š
â”œâ”€â”€ å­—æ®µæ•°æ® (event.get/setæ–¹æ³•è®¿é—®)
â”œâ”€â”€ å…ƒæ•°æ® (@metadataå­—æ®µ)
â”œâ”€â”€ æ—¶é—´æˆ³ (@timestampå­—æ®µ)
â””â”€â”€ æ ‡ç­¾ä¿¡æ¯ (tagså­—æ®µ)
```

---

## 2. ğŸ“ å†…è”Rubyä»£ç å®ç°


### 2.1 åŸºæœ¬è¯­æ³•ç»“æ„


**æœ€ç®€å•çš„Rubyè¿‡æ»¤å™¨é…ç½®**ï¼š
```ruby
filter {
    ruby {
        code => "event.set('new_field', 'hello world')"
    }
}
```

**è¯­æ³•è¯´æ˜**ï¼š
- `code =>` åé¢è·Ÿç€Rubyä»£ç å­—ç¬¦ä¸²
- `event` æ˜¯Logstashä¼ é€’ç»™Rubyä»£ç çš„äº‹ä»¶å¯¹è±¡
- `event.set()` ç”¨æ¥è®¾ç½®å­—æ®µå€¼
- `event.get()` ç”¨æ¥è·å–å­—æ®µå€¼

### 2.2 å¸¸ç”¨çš„å†…è”ä»£ç ç¤ºä¾‹


**ç¤ºä¾‹1ï¼šæ—¶é—´æˆ³å¤„ç†**
```ruby
filter {
    ruby {
        code => '
            # è·å–å½“å‰æ—¶é—´æˆ³å¹¶æ ¼å¼åŒ–
            current_time = Time.now.strftime("%Y-%m-%d %H:%M:%S")
            event.set("processed_time", current_time)
            
            # è®¡ç®—æ—¶é—´å·®ï¼ˆå¦‚æœæœ‰å¼€å§‹æ—¶é—´ï¼‰
            if event.get("start_time")
                start_time = Time.parse(event.get("start_time"))
                duration = Time.now - start_time
                event.set("duration_seconds", duration.to_i)
            end
        '
    }
}
```

**ç¤ºä¾‹2ï¼šå­—ç¬¦ä¸²å¤„ç†**
```ruby
filter {
    ruby {
        code => '
            # è·å–ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²
            user_agent = event.get("user_agent")
            
            if user_agent
                # æå–æµè§ˆå™¨ç±»å‹
                if user_agent.include?("Chrome")
                    event.set("browser", "Chrome")
                elsif user_agent.include?("Firefox")
                    event.set("browser", "Firefox")
                else
                    event.set("browser", "Other")
                end
                
                # åˆ¤æ–­æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
                mobile = user_agent.include?("Mobile") || user_agent.include?("Android")
                event.set("is_mobile", mobile)
            end
        '
    }
}
```

**ç¤ºä¾‹3ï¼šæ•°å€¼è®¡ç®—**
```ruby
filter {
    ruby {
        code => '
            # è®¡ç®—å“åº”æ—¶é—´ç­‰çº§
            response_time = event.get("response_time").to_f
            
            if response_time < 100
                level = "fast"
            elsif response_time < 500
                level = "normal"
            elsif response_time < 1000
                level = "slow"
            else
                level = "very_slow"
            end
            
            event.set("response_level", level)
            
            # è®¡ç®—åˆ†æ•°ï¼ˆæ»¡åˆ†100ï¼‰
            score = [100 - (response_time / 10), 0].max.to_i
            event.set("performance_score", score)
        '
    }
}
```

### 2.3 å†…è”ä»£ç çš„ä¼˜ç¼ºç‚¹


| ç‰¹ç‚¹ | ä¼˜åŠ¿ | åŠ£åŠ¿ |
|------|------|------|
| **å¼€å‘é€Ÿåº¦** | å¿«é€Ÿç¼–å†™ï¼Œç«‹å³æµ‹è¯• | å¤æ‚é€»è¾‘éš¾ä»¥ç»´æŠ¤ |
| **å¯è¯»æ€§** | ç®€å•é€»è¾‘æ¸…æ™°ç›´è§‚ | é•¿ä»£ç éš¾ä»¥é˜…è¯» |
| **ç»´æŠ¤æ€§** | å°ä¿®æ”¹å®¹æ˜“ | å¤§å‹é€»è¾‘ç»´æŠ¤å›°éš¾ |
| **å¤ç”¨æ€§** | æ— æ³•è·¨é…ç½®å¤ç”¨ | éœ€è¦é‡å¤ç¼–å†™ |

---

## 3. ğŸ“ å¤–éƒ¨è„šæœ¬æ–‡ä»¶é…ç½®


### 3.1 ä¸ºä»€ä¹ˆä½¿ç”¨å¤–éƒ¨è„šæœ¬


**ä½¿ç”¨å¤–éƒ¨è„šæœ¬çš„å¥½å¤„**ï¼š
- **ä»£ç å¤ç”¨**ï¼šå¤šä¸ªé…ç½®å¯ä»¥å…±äº«åŒä¸€ä¸ªè„šæœ¬
- **ç»´æŠ¤æ–¹ä¾¿**ï¼šä¿®æ”¹è„šæœ¬ä¸éœ€è¦æ”¹é…ç½®æ–‡ä»¶
- **ç‰ˆæœ¬æ§åˆ¶**ï¼šè„šæœ¬å¯ä»¥ç‹¬ç«‹è¿›è¡Œç‰ˆæœ¬ç®¡ç†
- **å›¢é˜Ÿåä½œ**ï¼šå¤šäººå¯ä»¥åˆ†åˆ«ç»´æŠ¤ä¸åŒçš„è„šæœ¬

### 3.2 å¤–éƒ¨è„šæœ¬é…ç½®æ–¹æ³•


**åŸºæœ¬é…ç½®è¯­æ³•**ï¼š
```ruby
filter {
    ruby {
        path => "/etc/logstash/scripts/my_script.rb"
    }
}
```

**åˆ›å»ºå¤–éƒ¨è„šæœ¬æ–‡ä»¶**ï¼š

æ–‡ä»¶è·¯å¾„ï¼š`/etc/logstash/scripts/log_processor.rb`
```ruby
# æ—¥å¿—å¤„ç†è„šæœ¬
def filter(event)
    # å¤„ç†IPåœ°å€
    ip = event.get("client_ip")
    if ip
        # åˆ¤æ–­æ˜¯å¦ä¸ºå†…ç½‘IP
        if ip.start_with?("192.168.") || ip.start_with?("10.") || ip.start_with?("172.")
            event.set("ip_type", "internal")
        else
            event.set("ip_type", "external")
        end
    end
    
    # å¤„ç†æ—¥å¿—çº§åˆ«
    log_level = event.get("level")
    if log_level
        case log_level.downcase
        when "error", "err"
            event.set("severity", 3)
            event.set("alert_needed", true)
        when "warn", "warning"
            event.set("severity", 2)
            event.set("alert_needed", false)
        when "info", "information"
            event.set("severity", 1)
            event.set("alert_needed", false)
        else
            event.set("severity", 0)
            event.set("alert_needed", false)
        end
    end
    
    return [event]
end
```

**ä½¿ç”¨å¤–éƒ¨è„šæœ¬çš„é…ç½®**ï¼š
```ruby
filter {
    ruby {
        path => "/etc/logstash/scripts/log_processor.rb"
    }
}
```

### 3.3 å¤–éƒ¨è„šæœ¬çš„æ ‡å‡†ç»“æ„


**æ¨èçš„è„šæœ¬ç»“æ„**ï¼š
```ruby
# è„šæœ¬å¤´éƒ¨ï¼šè¯´æ˜å’Œä¾èµ–
# æè¿°ï¼šå¤„ç†Webè®¿é—®æ—¥å¿—
# ä½œè€…ï¼šè¿ç»´å›¢é˜Ÿ
# æ›´æ–°ï¼š2025-01-20

require 'uri'
require 'time'

# ä¸»å¤„ç†å‡½æ•°
def filter(event)
    begin
        # å…·ä½“çš„å¤„ç†é€»è¾‘
        process_url(event)
        process_timestamp(event)
        calculate_metrics(event)
        
        return [event]
    rescue => e
        # é”™è¯¯å¤„ç†
        event.set("ruby_error", e.message)
        return [event]
    end
end

# è¾…åŠ©å‡½æ•°ï¼šå¤„ç†URL
def process_url(event)
    url = event.get("url")
    if url
        uri = URI.parse(url)
        event.set("domain", uri.host)
        event.set("path", uri.path)
        event.set("query", uri.query)
    end
end

# è¾…åŠ©å‡½æ•°ï¼šå¤„ç†æ—¶é—´æˆ³
def process_timestamp(event)
    timestamp = event.get("timestamp")
    if timestamp
        time = Time.parse(timestamp)
        event.set("hour", time.hour)
        event.set("day_of_week", time.strftime("%A"))
    end
end

# è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æŒ‡æ ‡
def calculate_metrics(event)
    response_size = event.get("response_size").to_i
    response_time = event.get("response_time").to_f
    
    # è®¡ç®—ä¼ è¾“é€Ÿç‡ï¼ˆå­—èŠ‚/ç§’ï¼‰
    if response_time > 0
        transfer_rate = response_size / response_time
        event.set("transfer_rate", transfer_rate.round(2))
    end
end
```

---

## 4. ğŸ”§ è„šæœ¬å‚æ•°ä¼ é€’æœºåˆ¶


### 4.1 å‚æ•°ä¼ é€’çš„åŸºæœ¬æ¦‚å¿µ


**ä»€ä¹ˆæ˜¯å‚æ•°ä¼ é€’**ï¼š
å°±æ˜¯åœ¨Logstashé…ç½®ä¸­å‘Rubyè„šæœ¬ä¼ é€’ä¸€äº›é…ç½®å€¼ï¼Œè®©è„šæœ¬æ ¹æ®è¿™äº›å‚æ•°æ¥è°ƒæ•´å¤„ç†è¡Œä¸ºã€‚

**å‚æ•°ä¼ é€’çš„è¯­æ³•**ï¼š
```ruby
filter {
    ruby {
        path => "/path/to/script.rb"
        script_params => {
            "threshold" => 100
            "environment" => "production"
            "debug_mode" => true
        }
    }
}
```

### 4.2 åœ¨è„šæœ¬ä¸­æ¥æ”¶å‚æ•°


**è„šæœ¬ä¸­è·å–å‚æ•°çš„æ–¹æ³•**ï¼š
```ruby
def register(params)
    # registeræ–¹æ³•åœ¨è„šæœ¬åˆå§‹åŒ–æ—¶è¢«è°ƒç”¨
    @threshold = params["threshold"] || 50  # é»˜è®¤å€¼50
    @environment = params["environment"] || "development"
    @debug_mode = params["debug_mode"] || false
    
    # å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œå‚æ•°éªŒè¯
    if @threshold < 0
        raise "é˜ˆå€¼ä¸èƒ½ä¸ºè´Ÿæ•°"
    end
end

def filter(event)
    # åœ¨filteræ–¹æ³•ä¸­ä½¿ç”¨å‚æ•°
    response_time = event.get("response_time").to_i
    
    if response_time > @threshold
        event.set("slow_request", true)
        
        if @debug_mode
            event.set("debug_info", "å“åº”æ—¶é—´#{response_time}msè¶…è¿‡é˜ˆå€¼#{@threshold}ms")
        end
    end
    
    # æ ¹æ®ç¯å¢ƒè®¾ç½®ä¸åŒçš„å¤„ç†é€»è¾‘
    if @environment == "production"
        # ç”Ÿäº§ç¯å¢ƒçš„å¤„ç†é€»è¾‘
        event.remove("sensitive_data")
    end
    
    return [event]
end
```

### 4.3 å®é™…åº”ç”¨ç¤ºä¾‹


**é…ç½®æ–‡ä»¶**ï¼š
```ruby
filter {
    ruby {
        path => "/etc/logstash/scripts/flexible_processor.rb"
        script_params => {
            "max_response_time" => 500
            "enable_geoip" => true
            "anonymize_ip" => true
            "log_level" => "info"
        }
    }
}
```

**å¯¹åº”çš„è„šæœ¬æ–‡ä»¶**ï¼š
```ruby
def register(params)
    @max_response_time = params["max_response_time"].to_i
    @enable_geoip = params["enable_geoip"]
    @anonymize_ip = params["anonymize_ip"]
    @log_level = params["log_level"]
    
    puts "Rubyè„šæœ¬åˆå§‹åŒ–å®Œæˆï¼Œå‚æ•°ï¼š#{params}" if @log_level == "debug"
end

def filter(event)
    # å“åº”æ—¶é—´æ£€æŸ¥
    response_time = event.get("response_time").to_i
    if response_time > @max_response_time
        event.set("response_status", "slow")
        event.tag("slow_response")
    else
        event.set("response_status", "normal")
    end
    
    # IPåœ°å€å¤„ç†
    if @anonymize_ip
        ip = event.get("client_ip")
        if ip
            # å°†IPåœ°å€çš„æœ€åä¸€æ®µæ›¿æ¢ä¸ºxxx
            anonymized_ip = ip.gsub(/\.\d+$/, ".xxx")
            event.set("client_ip_masked", anonymized_ip)
        end
    end
    
    # åœ°ç†ä½ç½®ä¿¡æ¯ï¼ˆæ¨¡æ‹Ÿï¼‰
    if @enable_geoip
        ip = event.get("client_ip")
        if ip && ip.start_with?("192.168.")
            event.set("geoip_country", "Internal")
            event.set("geoip_city", "DataCenter")
        end
    end
    
    return [event]
end
```

---

## 5. ğŸ¯ äº‹ä»¶å¯¹è±¡æ“ä½œè¯¦è§£


### 5.1 äº‹ä»¶å¯¹è±¡çš„åŸºæœ¬æ¦‚å¿µ


**ä»€ä¹ˆæ˜¯äº‹ä»¶å¯¹è±¡**ï¼š
åœ¨Logstashä¸­ï¼Œæ¯ä¸€æ¡æ—¥å¿—æ•°æ®éƒ½è¢«åŒ…è£…æˆä¸€ä¸ª"äº‹ä»¶å¯¹è±¡"ï¼ŒRubyä»£ç é€šè¿‡è¿™ä¸ªå¯¹è±¡æ¥è¯»å–å’Œä¿®æ”¹æ•°æ®ã€‚

**äº‹ä»¶å¯¹è±¡çš„ç»“æ„**ï¼š
```
äº‹ä»¶å¯¹è±¡ç¤ºä¾‹ï¼š
{
    "@timestamp": "2025-01-20T10:30:00.000Z",
    "@version": "1",
    "message": "ç”¨æˆ·ç™»å½•æˆåŠŸ",
    "user_id": "12345",
    "ip_address": "192.168.1.100",
    "tags": ["login", "success"],
    "@metadata": {
        "source": "app.log"
    }
}
```

### 5.2 è¯»å–äº‹ä»¶æ•°æ®çš„æ–¹æ³•


**åŸºæœ¬è¯»å–æ“ä½œ**ï¼š
```ruby
def filter(event)
    # è·å–å­—æ®µå€¼
    user_id = event.get("user_id")
    message = event.get("message")
    timestamp = event.get("@timestamp")
    
    # è·å–åµŒå¥—å­—æ®µ
    source = event.get("[@metadata][source]")
    
    # æ£€æŸ¥å­—æ®µæ˜¯å¦å­˜åœ¨
    if event.get("user_id")
        puts "ç”¨æˆ·IDå­˜åœ¨"
    end
    
    # è·å–æ‰€æœ‰å­—æ®µå
    all_fields = event.to_hash.keys
    puts "æ‰€æœ‰å­—æ®µï¼š#{all_fields}"
    
    return [event]
end
```

**å®‰å…¨çš„è¯»å–æ–¹æ³•**ï¼š
```ruby
def filter(event)
    # ä½¿ç”¨é»˜è®¤å€¼é¿å…nilé”™è¯¯
    user_id = event.get("user_id") || "unknown"
    response_time = event.get("response_time").to_i  # è½¬æ¢ä¸ºæ•´æ•°ï¼Œnilä¼šå˜æˆ0
    
    # ç±»å‹æ£€æŸ¥
    ip = event.get("ip_address")
    if ip && ip.is_a?(String)
        event.set("ip_length", ip.length)
    end
    
    return [event]
end
```

### 5.3 ä¿®æ”¹äº‹ä»¶æ•°æ®çš„æ–¹æ³•


**åŸºæœ¬ä¿®æ”¹æ“ä½œ**ï¼š
```ruby
def filter(event)
    # è®¾ç½®æ–°å­—æ®µ
    event.set("processed", true)
    event.set("processor", "ruby_filter")
    
    # ä¿®æ”¹ç°æœ‰å­—æ®µ
    message = event.get("message")
    if message
        event.set("message", message.upcase)  # è½¬æ¢ä¸ºå¤§å†™
    end
    
    # è®¾ç½®åµŒå¥—å­—æ®µ
    event.set("[user][processed_time]", Time.now.to_s)
    
    # åˆ é™¤å­—æ®µ
    event.remove("sensitive_field")
    
    return [event]
end
```

**æ‰¹é‡æ“ä½œç¤ºä¾‹**ï¼š
```ruby
def filter(event)
    # æ‰¹é‡é‡å‘½åå­—æ®µ
    field_mapping = {
        "old_name1" => "new_name1",
        "old_name2" => "new_name2",
        "old_name3" => "new_name3"
    }
    
    field_mapping.each do |old_name, new_name|
        if event.get(old_name)
            event.set(new_name, event.get(old_name))
            event.remove(old_name)
        end
    end
    
    # æ‰¹é‡æ·»åŠ å‰ç¼€
    ["field1", "field2", "field3"].each do |field_name|
        value = event.get(field_name)
        if value
            event.set("processed_#{field_name}", value)
        end
    end
    
    return [event]
end
```

### 5.4 æ ‡ç­¾æ“ä½œ


**æ ‡ç­¾çš„ä½œç”¨**ï¼š
æ ‡ç­¾å°±åƒç»™æ•°æ®è´´çš„æ ‡ç­¾çº¸ï¼Œç”¨æ¥æ ‡è®°æ•°æ®çš„ç‰¹å¾ï¼Œæ–¹ä¾¿åç»­å¤„ç†å’Œè¿‡æ»¤ã€‚

**æ ‡ç­¾æ“ä½œæ–¹æ³•**ï¼š
```ruby
def filter(event)
    # æ·»åŠ æ ‡ç­¾
    event.tag("processed_by_ruby")
    
    # æ¡ä»¶æ·»åŠ æ ‡ç­¾
    response_time = event.get("response_time").to_i
    if response_time > 1000
        event.tag("slow_response")
    end
    
    # æ£€æŸ¥æ˜¯å¦æœ‰ç‰¹å®šæ ‡ç­¾
    tags = event.get("tags") || []
    if tags.include?("error")
        event.set("needs_attention", true)
    end
    
    # ç§»é™¤æ ‡ç­¾ï¼ˆéœ€è¦æ‰‹åŠ¨æ“ä½œï¼‰
    current_tags = event.get("tags") || []
    new_tags = current_tags.reject { |tag| tag == "unwanted_tag" }
    event.set("tags", new_tags)
    
    return [event]
end
```

---

## 6. ğŸ”„ å­—æ®µåŠ¨æ€å¤„ç†æŠ€å·§


### 6.1 åŠ¨æ€å­—æ®µåç”Ÿæˆ


**ä»€ä¹ˆæ˜¯åŠ¨æ€å­—æ®µ**ï¼š
æ ¹æ®æ•°æ®å†…å®¹æ¥åŠ¨æ€å†³å®šå­—æ®µåç§°ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å›ºå®šçš„å­—æ®µåã€‚

**åŸºæœ¬ç¤ºä¾‹**ï¼š
```ruby
def filter(event)
    # æ ¹æ®ç”¨æˆ·ç±»å‹åˆ›å»ºåŠ¨æ€å­—æ®µ
    user_type = event.get("user_type")
    if user_type
        # åˆ›å»ºç±»ä¼¼ "count_admin"ã€"count_user" çš„å­—æ®µ
        field_name = "count_#{user_type}"
        current_count = event.get(field_name) || 0
        event.set(field_name, current_count + 1)
    end
    
    # æ ¹æ®æ—¶é—´åˆ›å»ºåŠ¨æ€å­—æ®µ
    timestamp = event.get("@timestamp")
    if timestamp
        hour = timestamp.strftime("%H")
        day = timestamp.strftime("%A")
        
        # åˆ›å»ºç±»ä¼¼ "requests_monday_14" çš„å­—æ®µ
        event.set("requests_#{day.downcase}_#{hour}", 1)
    end
    
    return [event]
end
```

**å¤æ‚çš„åŠ¨æ€å¤„ç†**ï¼š
```ruby
def filter(event)
    # å¤„ç†ç›‘æ§æŒ‡æ ‡æ•°æ®
    metrics = event.get("metrics")
    if metrics && metrics.is_a?(Hash)
        metrics.each do |metric_name, value|
            # ä¸ºæ¯ä¸ªæŒ‡æ ‡åˆ›å»ºç»Ÿè®¡å­—æ®µ
            event.set("#{metric_name}_current", value)
            
            # è®¡ç®—æŒ‡æ ‡ç­‰çº§
            level = calculate_level(metric_name, value)
            event.set("#{metric_name}_level", level)
            
            # åˆ¤æ–­æ˜¯å¦éœ€è¦å‘Šè­¦
            if should_alert?(metric_name, value)
                event.set("#{metric_name}_alert", true)
                event.tag("alert_#{metric_name}")
            end
        end
    end
    
    return [event]
end

def calculate_level(metric_name, value)
    # æ ¹æ®ä¸åŒæŒ‡æ ‡è®¡ç®—ç­‰çº§
    case metric_name
    when "cpu_usage"
        value > 80 ? "high" : value > 50 ? "medium" : "low"
    when "memory_usage"
        value > 90 ? "high" : value > 70 ? "medium" : "low"
    when "disk_usage"
        value > 95 ? "high" : value > 80 ? "medium" : "low"
    else
        "unknown"
    end
end

def should_alert?(metric_name, value)
    # æ ¹æ®ä¸åŒæŒ‡æ ‡åˆ¤æ–­æ˜¯å¦å‘Šè­¦
    thresholds = {
        "cpu_usage" => 80,
        "memory_usage" => 90,
        "disk_usage" => 95,
        "error_rate" => 5
    }
    
    threshold = thresholds[metric_name]
    threshold && value > threshold
end
```

### 6.2 å­—æ®µæ‰¹é‡å¤„ç†


**æ‰¹é‡å­—æ®µè½¬æ¢**ï¼š
```ruby
def filter(event)
    # æ‰¹é‡å¤„ç†æ•°å€¼å­—æ®µ
    numeric_fields = ["response_time", "request_size", "response_size"]
    
    numeric_fields.each do |field|
        value = event.get(field)
        if value
            # è½¬æ¢ä¸ºæ•°å€¼
            numeric_value = value.to_f
            event.set(field, numeric_value)
            
            # åˆ›å»ºåˆ†ç±»å­—æ®µ
            category = categorize_numeric_value(field, numeric_value)
            event.set("#{field}_category", category)
        end
    end
    
    # æ‰¹é‡å¤„ç†å­—ç¬¦ä¸²å­—æ®µ
    string_fields = ["user_agent", "referer", "url"]
    
    string_fields.each do |field|
        value = event.get(field)
        if value && value.is_a?(String)
            # æ¸…ç†å­—ç¬¦ä¸²
            cleaned_value = value.strip.gsub(/\s+/, ' ')
            event.set(field, cleaned_value)
            
            # æ·»åŠ é•¿åº¦ä¿¡æ¯
            event.set("#{field}_length", cleaned_value.length)
        end
    end
    
    return [event]
end

def categorize_numeric_value(field, value)
    case field
    when "response_time"
        value < 100 ? "fast" : value < 500 ? "normal" : "slow"
    when "request_size", "response_size"
        value < 1024 ? "small" : value < 10240 ? "medium" : "large"
    else
        "unknown"
    end
end
```

### 6.3 æ¡ä»¶å­—æ®µå¤„ç†


**åŸºäºæ¡ä»¶çš„å­—æ®µå¤„ç†**ï¼š
```ruby
def filter(event)
    # æ ¹æ®æ—¥å¿—çº§åˆ«å¤„ç†ä¸åŒå­—æ®µ
    log_level = event.get("level")
    
    case log_level
    when "ERROR"
        # é”™è¯¯æ—¥å¿—çš„ç‰¹æ®Šå¤„ç†
        event.set("priority", "high")
        event.set("requires_investigation", true)
        
        # æå–é”™è¯¯è¯¦æƒ…
        message = event.get("message")
        if message
            error_type = extract_error_type(message)
            event.set("error_type", error_type)
        end
        
    when "WARN"
        # è­¦å‘Šæ—¥å¿—çš„å¤„ç†
        event.set("priority", "medium")
        event.set("requires_monitoring", true)
        
    when "INFO"
        # ä¿¡æ¯æ—¥å¿—çš„å¤„ç†
        event.set("priority", "low")
        
        # æå–ä¸šåŠ¡ä¿¡æ¯
        extract_business_info(event)
    end
    
    # æ ¹æ®ç”¨æˆ·ç±»å‹å¤„ç†å­—æ®µ
    user_type = event.get("user_type")
    if user_type == "admin"
        # ç®¡ç†å‘˜æ“ä½œéœ€è¦ç‰¹æ®Šè®°å½•
        event.set("audit_required", true)
        event.set("retention_days", 365)
    else
        event.set("retention_days", 30)
    end
    
    return [event]
end

def extract_error_type(message)
    # ä»é”™è¯¯æ¶ˆæ¯ä¸­æå–é”™è¯¯ç±»å‹
    if message.include?("NullPointerException")
        "null_pointer"
    elsif message.include?("SQLException")
        "database_error"
    elsif message.include?("IOException")
        "io_error"
    else
        "unknown_error"
    end
end

def extract_business_info(event)
    message = event.get("message")
    return unless message
    
    # æå–ä¸šåŠ¡ç›¸å…³ä¿¡æ¯
    if message.include?("è®¢å•")
        event.set("business_type", "order")
        order_id = message.match(/è®¢å•å·[:ï¼š]\s*(\w+)/)
        event.set("order_id", order_id[1]) if order_id
    elsif message.include?("æ”¯ä»˜")
        event.set("business_type", "payment")
    elsif message.include?("ç™»å½•")
        event.set("business_type", "auth")
    end
end
```

---

## 7. ğŸ”€ æ¡ä»¶é€»è¾‘å®ç°æ–¹æ³•


### 7.1 åŸºæœ¬æ¡ä»¶åˆ¤æ–­


**ç®€å•çš„if-elseæ¡ä»¶**ï¼š
```ruby
def filter(event)
    # åŸºæœ¬æ¡ä»¶åˆ¤æ–­
    status_code = event.get("status_code").to_i
    
    if status_code >= 200 && status_code < 300
        event.set("status_category", "success")
        event.set("is_error", false)
    elsif status_code >= 400 && status_code < 500
        event.set("status_category", "client_error")
        event.set("is_error", true)
    elsif status_code >= 500
        event.set("status_category", "server_error")
        event.set("is_error", true)
        event.tag("critical_error")
    else
        event.set("status_category", "unknown")
    end
    
    return [event]
end
```

**å¤šæ¡ä»¶ç»„åˆåˆ¤æ–­**ï¼š
```ruby
def filter(event)
    response_time = event.get("response_time").to_i
    status_code = event.get("status_code").to_i
    request_size = event.get("request_size").to_i
    
    # å¤æ‚çš„å¤šæ¡ä»¶åˆ¤æ–­
    if status_code >= 500 && response_time > 5000
        # æœåŠ¡å™¨é”™è¯¯ä¸”å“åº”æ—¶é—´å¾ˆé•¿
        event.set("issue_type", "critical_performance")
        event.set("priority", "urgent")
        event.tag("immediate_attention")
        
    elsif status_code >= 400 && request_size > 1000000
        # å®¢æˆ·ç«¯é”™è¯¯ä¸”è¯·æ±‚å¾ˆå¤§
        event.set("issue_type", "large_request_error")
        event.set("priority", "medium")
        
    elsif response_time > 10000
        # å“åº”æ—¶é—´æé•¿
        event.set("issue_type", "timeout_risk")
        event.set("priority", "high")
        
    else
        event.set("issue_type", "normal")
        event.set("priority", "low")
    end
    
    return [event]
end
```

### 7.2 caseè¯­å¥çš„ä½¿ç”¨


**ä½¿ç”¨caseç®€åŒ–å¤šæ¡ä»¶åˆ¤æ–­**ï¼š
```ruby
def filter(event)
    # ä½¿ç”¨caseè¯­å¥å¤„ç†HTTPæ–¹æ³•
    http_method = event.get("http_method")
    
    risk_level = case http_method
    when "GET", "HEAD", "OPTIONS"
        "low"
    when "POST", "PUT"
        "medium"
    when "DELETE", "PATCH"
        "high"
    else
        "unknown"
    end
    
    event.set("request_risk", risk_level)
    
    # æ ¹æ®é£é™©çº§åˆ«è®¾ç½®å¤„ç†ç­–ç•¥
    case risk_level
    when "high"
        event.set("requires_approval", true)
        event.set("log_retention", "long")
        event.tag("high_risk_operation")
    when "medium"
        event.set("requires_monitoring", true)
        event.set("log_retention", "medium")
    else
        event.set("log_retention", "short")
    end
    
    return [event]
end
```

### 7.3 æ­£åˆ™è¡¨è¾¾å¼æ¡ä»¶åŒ¹é…


**ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ¨¡å¼åŒ¹é…**ï¼š
```ruby
def filter(event)
    url = event.get("url")
    user_agent = event.get("user_agent")
    
    # URLæ¨¡å¼åŒ¹é…
    if url
        case url
        when /^\/api\/v[12]\//
            event.set("api_version", url.match(/\/api\/v([12])\//)[1])
            event.set("request_type", "api")
        when /^\/admin\//
            event.set("request_type", "admin")
            event.set("requires_auth_check", true)
        when /^\/static\//
            event.set("request_type", "static")
            event.set("cacheable", true)
        when /\.(jpg|png|gif|css|js)$/
            event.set("request_type", "asset")
            event.set("cacheable", true)
        else
            event.set("request_type", "page")
        end
    end
    
    # User-Agentæ¨¡å¼åŒ¹é…
    if user_agent
        bot_patterns = [
            /googlebot/i,
            /bingbot/i,
            /spider/i,
            /crawler/i,
            /bot/i
        ]
        
        is_bot = bot_patterns.any? { |pattern| user_agent.match?(pattern) }
        event.set("is_bot", is_bot)
        
        if is_bot
            event.tag("bot_traffic")
            # æå–æœºå™¨äººç±»å‹
            if user_agent.match?(/googlebot/i)
                event.set("bot_type", "googlebot")
            elsif user_agent.match?(/bingbot/i)
                event.set("bot_type", "bingbot")
            else
                event.set("bot_type", "other_bot")
            end
        end
    end
    
    return [event]
end
```

### 7.4 å¤æ‚ä¸šåŠ¡é€»è¾‘æ¡ä»¶


**å¤„ç†å¤æ‚ä¸šåŠ¡è§„åˆ™**ï¼š
```ruby
def filter(event)
    # è·å–å¿…è¦çš„å­—æ®µ
    user_id = event.get("user_id")
    action = event.get("action")
    timestamp = event.get("@timestamp")
    ip_address = event.get("ip_address")
    
    # ä¸šåŠ¡è§„åˆ™1ï¼šæ£€æµ‹å¯ç–‘ç™»å½•
    if action == "login"
        # æ£€æŸ¥ç™»å½•æ—¶é—´
        hour = timestamp.hour
        if hour < 6 || hour > 22
            event.set("suspicious_time", true)
            event.tag("unusual_hour_login")
        end
        
        # æ£€æŸ¥IPåœ°å€å˜åŒ–ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
        if ip_address && !ip_address.start_with?("192.168.")
            event.set("external_login", true)
            event.tag("external_ip_login")
        end
        
        # ç»¼åˆåˆ¤æ–­
        if event.get("suspicious_time") && event.get("external_login")
            event.set("security_alert", "high")
            event.tag("security_review_needed")
        end
    end
    
    # ä¸šåŠ¡è§„åˆ™2ï¼šæ£€æµ‹æ‰¹é‡æ“ä½œ
    if action == "bulk_delete" || action == "bulk_update"
        affected_count = event.get("affected_records").to_i
        
        if affected_count > 1000
            event.set("bulk_operation_risk", "high")
            event.tag("large_bulk_operation")
        elsif affected_count > 100
            event.set("bulk_operation_risk", "medium")
        else
            event.set("bulk_operation_risk", "low")
        end
    end
    
    # ä¸šåŠ¡è§„åˆ™3ï¼šVIPç”¨æˆ·ç‰¹æ®Šå¤„ç†
    user_level = event.get("user_level")
    if user_level == "vip" || user_level == "premium"
        event.set("priority_support", true)
        event.set("escalation_required", action.include?("error"))
    end
    
    return [event]
end
```

---

## 8. âš ï¸ å¼‚å¸¸å¤„ç†æœºåˆ¶


### 8.1 ä¸ºä»€ä¹ˆéœ€è¦å¼‚å¸¸å¤„ç†


**Rubyè„šæœ¬ä¸­å¯èƒ½å‡ºç°çš„é—®é¢˜**ï¼š
- **æ•°æ®ç±»å‹é”™è¯¯**ï¼šæœŸæœ›æ•°å­—ä½†å¾—åˆ°å­—ç¬¦ä¸²
- **å­—æ®µä¸å­˜åœ¨**ï¼šè¯•å›¾è®¿é—®ä¸å­˜åœ¨çš„å­—æ®µ
- **æ ¼å¼è§£æé”™è¯¯**ï¼šè§£ææ—¥æœŸã€URLç­‰æ ¼å¼æ—¶å‡ºé”™
- **ç½‘ç»œè°ƒç”¨å¤±è´¥**ï¼šå¦‚æœè„šæœ¬éœ€è¦è°ƒç”¨å¤–éƒ¨API
- **å†…å­˜ä¸è¶³**ï¼šå¤„ç†å¤§é‡æ•°æ®æ—¶

**ä¸å¤„ç†å¼‚å¸¸çš„åæœ**ï¼š
```
âŒ å¦‚æœä¸å¤„ç†å¼‚å¸¸ï¼š
- Rubyè„šæœ¬å´©æºƒ
- æ•´ä¸ªLogstashç®¡é“åœæ­¢
- æ•°æ®ä¸¢å¤±
- ç³»ç»Ÿä¸ç¨³å®š
```

### 8.2 åŸºæœ¬å¼‚å¸¸å¤„ç†è¯­æ³•


**try-catchåŸºæœ¬ç»“æ„**ï¼š
```ruby
def filter(event)
    begin
        # å¯èƒ½å‡ºé”™çš„ä»£ç 
        response_time = event.get("response_time").to_f
        result = 1000 / response_time  # å¯èƒ½é™¤é›¶é”™è¯¯
        event.set("rate", result)
        
    rescue ZeroDivisionError => e
        # å¤„ç†é™¤é›¶é”™è¯¯
        event.set("rate", 0)
        event.set("error_type", "division_by_zero")
        
    rescue TypeError => e
        # å¤„ç†ç±»å‹é”™è¯¯
        event.set("error_type", "type_error")
        event.set("error_message", e.message)
        
    rescue => e
        # å¤„ç†æ‰€æœ‰å…¶ä»–é”™è¯¯
        event.set("error_type", "unknown_error")
        event.set("error_message", e.message)
        
    ensure
        # æ— è®ºæ˜¯å¦å‡ºé”™éƒ½ä¼šæ‰§è¡Œ
        event.set("processed_by", "ruby_filter")
        event.set("processed_at", Time.now.to_s)
    end
    
    return [event]
end
```

### 8.3 å¸¸è§é”™è¯¯ç±»å‹å¤„ç†


**å¤„ç†å„ç§å¸¸è§é”™è¯¯**ï¼š
```ruby
def filter(event)
    begin
        process_event_safely(event)
    rescue => e
        handle_error(event, e)
    end
    
    return [event]
end

def process_event_safely(event)
    # å®‰å…¨çš„å­—æ®µè®¿é—®
    response_time = safe_get_numeric(event, "response_time")
    if response_time
        event.set("response_category", categorize_response_time(response_time))
    end
    
    # å®‰å…¨çš„æ—¶é—´è§£æ
    timestamp_str = event.get("timestamp")
    if timestamp_str
        parsed_time = safe_parse_time(timestamp_str)
        if parsed_time
            event.set("parsed_timestamp", parsed_time)
            event.set("hour_of_day", parsed_time.hour)
        end
    end
    
    # å®‰å…¨çš„URLè§£æ
    url = event.get("url")
    if url
        url_parts = safe_parse_url(url)
        if url_parts
            event.set("url_domain", url_parts[:domain])
            event.set("url_path", url_parts[:path])
        end
    end
end

def safe_get_numeric(event, field_name)
    # å®‰å…¨è·å–æ•°å€¼å­—æ®µ
    value = event.get(field_name)
    return nil unless value
    
    begin
        case value
        when String
            return value.to_f if value.match?(/^\d+\.?\d*$/)
        when Numeric
            return value.to_f
        end
    rescue
        return nil
    end
    
    nil
end

def safe_parse_time(time_string)
    # å®‰å…¨è§£ææ—¶é—´å­—ç¬¦ä¸²
    return nil unless time_string.is_a?(String)
    
    begin
        # å°è¯•å¤šç§æ—¶é—´æ ¼å¼
        [
            "%Y-%m-%d %H:%M:%S",
            "%Y-%m-%dT%H:%M:%S",
            "%Y-%m-%d %H:%M:%S.%L",
            "%d/%b/%Y:%H:%M:%S"
        ].each do |format|
            begin
                return Time.strptime(time_string, format)
            rescue ArgumentError
                next
            end
        end
        
        # å¦‚æœéƒ½ä¸åŒ¹é…ï¼Œå°è¯•è‡ªåŠ¨è§£æ
        Time.parse(time_string)
    rescue
        nil
    end
end

def safe_parse_url(url_string)
    # å®‰å…¨è§£æURL
    return nil unless url_string.is_a?(String)
    
    begin
        require 'uri'
        uri = URI.parse(url_string)
        {
            domain: uri.host,
            path: uri.path,
            query: uri.query,
            scheme: uri.scheme
        }
    rescue URI::InvalidURIError
        nil
    end
end

def handle_error(event, error)
    # ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
    event.set("ruby_processing_error", true)
    event.set("error_type", error.class.name)
    event.set("error_message", error.message)
    event.tag("ruby_filter_error")
    
    # è®°å½•é”™è¯¯è¯¦æƒ…ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    event.set("error_backtrace", error.backtrace.first(3)) if error.backtrace
end
```

### 8.4 é”™è¯¯æ¢å¤ç­–ç•¥


**ä¸åŒé”™è¯¯çš„æ¢å¤ç­–ç•¥**ï¼š
```ruby
def filter(event)
    begin
        # ä¸»è¦å¤„ç†é€»è¾‘
        main_processing(event)
        
    rescue StandardError => e
        # æ ¹æ®é”™è¯¯ç±»å‹é‡‡ç”¨ä¸åŒæ¢å¤ç­–ç•¥
        recovery_strategy = determine_recovery_strategy(e)
        
        case recovery_strategy
        when :retry
            retry_processing(event, e)
        when :skip
            skip_processing(event, e)
        when :default_values
            apply_default_values(event, e)
        when :partial_processing
            partial_processing(event, e)
        else
            fallback_processing(event, e)
        end
    end
    
    return [event]
end

def determine_recovery_strategy(error)
    case error
    when ZeroDivisionError, ArgumentError
        :default_values
    when TypeError, NoMethodError
        :skip
    when Timeout::Error, Net::TimeoutError
        :retry
    else
        :partial_processing
    end
end

def retry_processing(event, error)
    # å¯¹äºä¸´æ—¶é”™è¯¯ï¼Œå¯ä»¥å°è¯•é‡è¯•
    event.set("processing_retry", true)
    event.set("retry_reason", error.message)
    
    # è¿™é‡Œå¯ä»¥å®ç°ç®€å•çš„é‡è¯•é€»è¾‘
    # å®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„é‡è¯•æœºåˆ¶
end

def skip_processing(event, error)
    # è·³è¿‡å¤„ç†ï¼Œä½†ä¿ç•™åŸå§‹æ•°æ®
    event.set("processing_skipped", true)
    event.set("skip_reason", error.message)
    event.tag("processing_skipped")
end

def apply_default_values(event, error)
    # åº”ç”¨é»˜è®¤å€¼ç»§ç»­å¤„ç†
    event.set("processing_error", error.message)
    event.set("response_time", 0) if error.message.include?("response_time")
    event.set("status_code", 500) if error.message.include?("status_code")
end

def partial_processing(event, error)
    # éƒ¨åˆ†å¤„ç†ï¼Œå¤„ç†èƒ½å¤„ç†çš„éƒ¨åˆ†
    event.set("partial_processing", true)
    event.set("processing_error", error.message)
    
    # ç»§ç»­å¤„ç†ä¸ä¼šå‡ºé”™çš„å­—æ®µ
    safe_fields = ["timestamp", "message", "source"]
    safe_fields.each do |field|
        if event.get(field)
            event.set("#{field}_processed", true)
        end
    end
end

def fallback_processing(event, error)
    # å…œåº•å¤„ç†
    event.set("fallback_processing", true)
    event.set("original_error", error.message)
    event.tag("fallback_applied")
end
```

---

## 9. ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


### 9.1 æ€§èƒ½é—®é¢˜çš„è¯†åˆ«


**å¸¸è§çš„æ€§èƒ½é—®é¢˜**ï¼š
- **å¤„ç†é€Ÿåº¦æ…¢**ï¼šRubyä»£ç æ‰§è¡Œæ—¶é—´è¿‡é•¿
- **å†…å­˜å ç”¨é«˜**ï¼šå­˜å‚¨è¿‡å¤šä¸´æ—¶æ•°æ®
- **CPUä½¿ç”¨ç‡é«˜**ï¼šå¤æ‚è®¡ç®—æˆ–é¢‘ç¹æ“ä½œ
- **é˜»å¡ç®¡é“**ï¼šåŒæ­¥æ“ä½œå¯¼è‡´æ•°æ®å †ç§¯

**æ€§èƒ½ç›‘æ§æ–¹æ³•**ï¼š
```ruby
def filter(event)
    start_time = Time.now
    
    begin
        # ä½ çš„å¤„ç†é€»è¾‘
        process_main_logic(event)
        
    ensure
        # è®°å½•å¤„ç†æ—¶é—´
        processing_time = (Time.now - start_time) * 1000  # æ¯«ç§’
        event.set("ruby_processing_time_ms", processing_time.round(2))
        
        # å¦‚æœå¤„ç†æ—¶é—´è¿‡é•¿ï¼Œæ·»åŠ æ ‡è®°
        if processing_time > 100  # è¶…è¿‡100æ¯«ç§’
            event.tag("slow_ruby_processing")
        end
    end
    
    return [event]
end
```

### 9.2 ä»£ç ä¼˜åŒ–æŠ€å·§


**é¿å…é‡å¤è®¡ç®—**ï¼š
```ruby
# âŒ æ•ˆç‡ä½çš„å†™æ³•
def filter(event)
    if expensive_calculation(event.get("data")) > 100
        event.set("result1", expensive_calculation(event.get("data")))
    end
    
    if expensive_calculation(event.get("data")) < 50
        event.set("result2", "low")
    end
    
    return [event]
end

# âœ… ä¼˜åŒ–åçš„å†™æ³•
def filter(event)
    # åªè®¡ç®—ä¸€æ¬¡ï¼Œå­˜å‚¨ç»“æœ
    calculation_result = expensive_calculation(event.get("data"))
    
    if calculation_result > 100
        event.set("result1", calculation_result)
    end
    
    if calculation_result < 50
        event.set("result2", "low")
    end
    
    return [event]
end
```

**ä¼˜åŒ–å­—ç¬¦ä¸²æ“ä½œ**ï¼š
```ruby
# âŒ æ•ˆç‡ä½çš„å­—ç¬¦ä¸²æ“ä½œ
def filter(event)
    message = event.get("message")
    if message
        # å¤šæ¬¡å­—ç¬¦ä¸²æ“ä½œï¼Œæ¯æ¬¡éƒ½åˆ›å»ºæ–°å¯¹è±¡
        result = message.downcase
        result = result.strip
        result = result.gsub(/\s+/, ' ')
        result = result.gsub(/[^\w\s]/, '')
        event.set("cleaned_message", result)
    end
    
    return [event]
end

# âœ… ä¼˜åŒ–åçš„å­—ç¬¦ä¸²æ“ä½œ
def filter(event)
    message = event.get("message")
    if message
        # é“¾å¼æ“ä½œï¼Œå‡å°‘ä¸­é—´å¯¹è±¡
        cleaned = message.downcase.strip.gsub(/\s+/, ' ').gsub(/[^\w\s]/, '')
        event.set("cleaned_message", cleaned)
    end
    
    return [event]
end
```

**ä¼˜åŒ–å¾ªç¯å’Œæ¡ä»¶åˆ¤æ–­**ï¼š
```ruby
# âŒ æ•ˆç‡ä½çš„å†™æ³•
def filter(event)
    fields_to_check = ["field1", "field2", "field3", "field4", "field5"]
    
    fields_to_check.each do |field|
        value = event.get(field)
        if value && value.is_a?(String) && value.length > 0
            if value.include?("error")
                event.set("has_error", true)
                return [event]  # æ‰¾åˆ°ä¸€ä¸ªå°±è¿”å›
            end
        end
    end
    
    return [event]
end

# âœ… ä¼˜åŒ–åçš„å†™æ³•
def filter(event)
    fields_to_check = ["field1", "field2", "field3", "field4", "field5"]
    
    # ä½¿ç”¨any?æå‰é€€å‡º
    has_error = fields_to_check.any? do |field|
        value = event.get(field)
        value.is_a?(String) && !value.empty? && value.include?("error")
    end
    
    event.set("has_error", has_error)
    return [event]
end
```

### 9.3 å†…å­˜ä¼˜åŒ–


**é¿å…å†…å­˜æ³„æ¼**ï¼š
```ruby
# âŒ å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼çš„å†™æ³•
$$global_cache = {}  # ç±»å˜é‡ï¼Œä¼šæŒç»­å¢é•¿

def filter(event)
    key = event.get("user_id")
    $$global_cache[key] = event.to_hash  # ä¸æ–­ç§¯ç´¯æ•°æ®
    
    return [event]
end

# âœ… å†…å­˜å‹å¥½çš„å†™æ³•
def register(params)
    @cache = {}
    @cache_max_size = params["cache_max_size"] || 1000
    @cache_cleanup_counter = 0
end

def filter(event)
    key = event.get("user_id")
    
    # å®šæœŸæ¸…ç†ç¼“å­˜
    @cache_cleanup_counter += 1
    if @cache_cleanup_counter > 100
        cleanup_cache
        @cache_cleanup_counter = 0
    end
    
    # é™åˆ¶ç¼“å­˜å¤§å°
    if @cache.size < @cache_max_size
        @cache[key] = extract_essential_data(event)
    end
    
    return [event]
end

def cleanup_cache
    # ä¿ç•™æœ€è¿‘ä½¿ç”¨çš„50%æ•°æ®
    keep_size = @cache_max_size / 2
    @cache = @cache.to_a.last(keep_size).to_h
end

def extract_essential_data(event)
    # åªå­˜å‚¨å¿…è¦çš„æ•°æ®ï¼Œä¸æ˜¯å®Œæ•´äº‹ä»¶
    {
        timestamp: event.get("@timestamp"),
        status: event.get("status"),
        user_id: event.get("user_id")
    }
end
```

### 9.4 ç®—æ³•ä¼˜åŒ–


**é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„**ï¼š
```ruby
# âŒ æ•ˆç‡ä½çš„æŸ¥æ‰¾
def register(params)
    @blacklist = ["ip1", "ip2", "ip3", "ip4", "ip5"]  # æ•°ç»„æŸ¥æ‰¾O(n)
end

def filter(event)
    ip = event.get("client_ip")
    if @blacklist.include?(ip)  # çº¿æ€§æŸ¥æ‰¾ï¼Œæ•ˆç‡ä½
        event.tag("blacklisted")
    end
    
    return [event]
end

# âœ… ä¼˜åŒ–åçš„æŸ¥æ‰¾
def register(params)
    blacklist_array = ["ip1", "ip2", "ip3", "ip4", "ip5"]
    @blacklist = Set.new(blacklist_array)  # ä½¿ç”¨Setï¼ŒæŸ¥æ‰¾O(1)
end

def filter(event)
    ip = event.get("client_ip")
    if @blacklist.include?(ip)  # å¸¸æ•°æ—¶é—´æŸ¥æ‰¾
        event.tag("blacklisted")
    end
    
    return [event]
end
```

**æ‰¹é‡å¤„ç†ä¼˜åŒ–**ï¼š
```ruby
# âŒ é€ä¸ªå¤„ç†ï¼Œæ•ˆç‡ä½
def filter(event)
    urls = event.get("urls")  # å‡è®¾æ˜¯URLæ•°ç»„
    if urls && urls.is_a?(Array)
        urls.each do |url|
            domain = extract_domain(url)  # æ¯æ¬¡éƒ½è°ƒç”¨å‡½æ•°
            event.set("domain_#{url}", domain)
        end
    end
    
    return [event]
end

# âœ… æ‰¹é‡å¤„ç†ä¼˜åŒ–
def filter(event)
    urls = event.get("urls")
    if urls && urls.is_a?(Array)
        # æ‰¹é‡å¤„ç†ï¼Œå‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€
        domains = extract_domains_batch(urls)
        domains.each_with_index do |domain, index|
            event.set("domain_#{index}", domain)
        end
    end
    
    return [event]
end

def extract_domains_batch(urls)
    # æ‰¹é‡å¤„ç†ï¼Œå¤ç”¨æ­£åˆ™è¡¨è¾¾å¼ç­‰èµ„æº
    domain_regex = /https?:\/\/([^\/]+)/
    urls.map do |url|
        match = url.match(domain_regex)
        match ? match[1] : "unknown"
    end
end
```

### 9.5 æ€§èƒ½æµ‹è¯•å’Œç›‘æ§


**æ·»åŠ æ€§èƒ½ç›‘æ§ä»£ç **ï¼š
```ruby
def register(params)
    @performance_stats = {
        total_events: 0,
        total_time: 0,
        slow_events: 0,
        error_events: 0
    }
    @stats_report_interval = 1000  # æ¯1000ä¸ªäº‹ä»¶æŠ¥å‘Šä¸€æ¬¡
end

def filter(event)
    start_time = Time.now
    
    begin
        process_event(event)
        
    rescue => e
        @performance_stats[:error_events] += 1
        handle_error(event, e)
        
    ensure
        # æ›´æ–°æ€§èƒ½ç»Ÿè®¡
        processing_time = Time.now - start_time
        @performance_stats[:total_events] += 1
        @performance_stats[:total_time] += processing_time
        
        if processing_time > 0.1  # è¶…è¿‡100æ¯«ç§’
            @performance_stats[:slow_events] += 1
        end
        
        # å®šæœŸæŠ¥å‘Šæ€§èƒ½ç»Ÿè®¡
        if @performance_stats[:total_events] % @stats_report_interval == 0
            report_performance_stats
        end
    end
    
    return [event]
end

def report_performance_stats
    total_events = @performance_stats[:total_events]
    total_time = @performance_stats[:total_time]
    avg_time = total_time / total_events
    slow_percentage = (@performance_stats[:slow_events].to_f / total_events * 100).round(2)
    error_percentage = (@performance_stats[:error_events].to_f / total_events * 100).round(2)
    
    puts "Ruby Filter Performance Stats:"
    puts "  Total Events: #{total_events}"
    puts "  Average Processing Time: #{(avg_time * 1000).round(2)}ms"
    puts "  Slow Events (>100ms): #{slow_percentage}%"
    puts "  Error Events: #{error_percentage}%"
    puts "  Events per Second: #{(total_events / total_time).round(2)}"
end
```

---

## 10. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 10.1 å¿…é¡»æŒæ¡çš„åŸºæœ¬æ¦‚å¿µ


```
ğŸ”¸ Rubyè¿‡æ»¤å™¨æœ¬è´¨ï¼šåœ¨Logstashä¸­ä½¿ç”¨Rubyä»£ç è‡ªå®šä¹‰æ•°æ®å¤„ç†é€»è¾‘
ğŸ”¸ äº‹ä»¶å¯¹è±¡æ“ä½œï¼šé€šè¿‡event.get()å’Œevent.set()è¯»å†™æ•°æ®
ğŸ”¸ å†…è”vså¤–éƒ¨è„šæœ¬ï¼šç®€å•é€»è¾‘ç”¨å†…è”ï¼Œå¤æ‚é€»è¾‘ç”¨å¤–éƒ¨æ–‡ä»¶
ğŸ”¸ å‚æ•°ä¼ é€’ï¼šé€šè¿‡script_paramså‘è„šæœ¬ä¼ é€’é…ç½®å‚æ•°
ğŸ”¸ å¼‚å¸¸å¤„ç†ï¼šå¿…é¡»ä½¿ç”¨begin-rescueç¡®ä¿è„šæœ¬ç¨³å®šæ€§
ğŸ”¸ æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…é‡å¤è®¡ç®—ï¼Œé€‰æ‹©åˆé€‚æ•°æ®ç»“æ„ï¼Œç›‘æ§æ€§èƒ½
```

### 10.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä½•æ—¶ä½¿ç”¨Rubyè¿‡æ»¤å™¨**
```
é€‚ç”¨åœºæ™¯ï¼š
âœ… ç°æœ‰è¿‡æ»¤å™¨æ— æ³•æ»¡è¶³éœ€æ±‚
âœ… éœ€è¦å¤æ‚çš„è®¡ç®—é€»è¾‘
âœ… åŠ¨æ€å­—æ®µåç”Ÿæˆ
âœ… å¤æ‚çš„æ¡ä»¶åˆ¤æ–­

ä¸é€‚ç”¨åœºæ™¯ï¼š
âŒ ç®€å•çš„å­—æ®µé‡å‘½åï¼ˆç”¨mutateï¼‰
âŒ æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ï¼ˆç”¨grokï¼‰
âŒ ç®€å•çš„æ¡ä»¶è¿‡æ»¤ï¼ˆç”¨ifè¯­å¥ï¼‰
```

**ğŸ”¹ ä»£ç ç»„ç»‡æœ€ä½³å®è·µ**
```
å†…è”ä»£ç ï¼š
- é€‚åˆ10è¡Œä»¥å†…çš„ç®€å•é€»è¾‘
- å¿«é€ŸåŸå‹å’Œæµ‹è¯•
- ä¸´æ—¶çš„æ•°æ®å¤„ç†éœ€æ±‚

å¤–éƒ¨è„šæœ¬ï¼š
- è¶…è¿‡10è¡Œçš„å¤æ‚é€»è¾‘
- éœ€è¦å¤ç”¨çš„å¤„ç†é€»è¾‘
- å›¢é˜Ÿå¼€å‘å’Œç»´æŠ¤
- ç‰ˆæœ¬æ§åˆ¶éœ€æ±‚
```

**ğŸ”¹ æ€§èƒ½è€ƒè™‘è¦ç‚¹**
```
å½±å“æ€§èƒ½çš„å› ç´ ï¼š
- Rubyä»£ç æ‰§è¡Œå¤æ‚åº¦
- å­—ç¬¦ä¸²æ“ä½œé¢‘ç‡
- å¾ªç¯å’Œé€’å½’æ·±åº¦
- å†…å­˜ä½¿ç”¨é‡
- å¼‚å¸¸å¤„ç†å¼€é”€

ä¼˜åŒ–ç­–ç•¥ï¼š
- ç¼“å­˜è®¡ç®—ç»“æœ
- é€‰æ‹©é«˜æ•ˆç®—æ³•
- é™åˆ¶å†…å­˜ä½¿ç”¨
- æ‰¹é‡å¤„ç†æ•°æ®
- ç›‘æ§æ€§èƒ½æŒ‡æ ‡
```

### 10.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ“ å¼€å‘æµç¨‹å»ºè®®**
```
1. éœ€æ±‚åˆ†æ
   - ç¡®è®¤ç°æœ‰è¿‡æ»¤å™¨æ— æ³•æ»¡è¶³éœ€æ±‚
   - åˆ†ææ•°æ®å¤„ç†å¤æ‚åº¦
   - è¯„ä¼°æ€§èƒ½è¦æ±‚

2. è®¾è®¡é˜¶æ®µ
   - é€‰æ‹©å†…è”æˆ–å¤–éƒ¨è„šæœ¬
   - è®¾è®¡å‚æ•°ä¼ é€’æ–¹æ¡ˆ
   - è§„åˆ’å¼‚å¸¸å¤„ç†ç­–ç•¥

3. å¼€å‘é˜¶æ®µ
   - ç¼–å†™æ ¸å¿ƒå¤„ç†é€»è¾‘
   - æ·»åŠ å¼‚å¸¸å¤„ç†
   - å®ç°æ€§èƒ½ç›‘æ§

4. æµ‹è¯•é˜¶æ®µ
   - åŠŸèƒ½æµ‹è¯•
   - æ€§èƒ½æµ‹è¯•
   - å¼‚å¸¸æƒ…å†µæµ‹è¯•

5. éƒ¨ç½²è¿ç»´
   - ç›‘æ§æ€§èƒ½æŒ‡æ ‡
   - æ”¶é›†é”™è¯¯æ—¥å¿—
   - æŒç»­ä¼˜åŒ–æ”¹è¿›
```

**âš ï¸ å¸¸è§é™·é˜±é¿å…**
```
ä»£ç é™·é˜±ï¼š
- å¿˜è®°å¼‚å¸¸å¤„ç†å¯¼è‡´ç®¡é“ä¸­æ–­
- å­—æ®µè®¿é—®ä¸æ£€æŸ¥nullå€¼
- æ­£åˆ™è¡¨è¾¾å¼æ€§èƒ½é—®é¢˜
- å†…å­˜æ³„æ¼é—®é¢˜

é…ç½®é™·é˜±ï¼š
- å‚æ•°ä¼ é€’æ ¼å¼é”™è¯¯
- è„šæœ¬æ–‡ä»¶è·¯å¾„é”™è¯¯
- æƒé™é—®é¢˜å¯¼è‡´æ— æ³•è¯»å–è„šæœ¬
- è„šæœ¬æ›´æ–°åéœ€è¦é‡å¯Logstash
```

### 10.4 è¿›é˜¶æŠ€å·§


**ğŸš€ é«˜çº§åº”ç”¨æ¨¡å¼**
```
æ¨¡å¼1ï¼šç®¡é“å¼å¤„ç†
- å°†å¤æ‚é€»è¾‘åˆ†è§£ä¸ºå¤šä¸ªå°å‡½æ•°
- æ¯ä¸ªå‡½æ•°å¤„ç†ä¸€ä¸ªç‰¹å®šä»»åŠ¡
- ä¾¿äºæµ‹è¯•å’Œç»´æŠ¤

æ¨¡å¼2ï¼šç­–ç•¥æ¨¡å¼
- æ ¹æ®æ•°æ®ç±»å‹é€‰æ‹©ä¸åŒå¤„ç†ç­–ç•¥
- æé«˜ä»£ç çš„å¯æ‰©å±•æ€§
- ä¾¿äºæ·»åŠ æ–°çš„å¤„ç†é€»è¾‘

æ¨¡å¼3ï¼šç¼“å­˜æ¨¡å¼
- ç¼“å­˜é¢‘ç¹æŸ¥è¯¢çš„æ•°æ®
- å‡å°‘é‡å¤è®¡ç®—å¼€é”€
- æ³¨æ„å†…å­˜ç®¡ç†

æ¨¡å¼4ï¼šæ‰¹å¤„ç†æ¨¡å¼
- å°†å¤šä¸ªç›¸ä¼¼æ“ä½œæ‰¹é‡æ‰§è¡Œ
- æé«˜å¤„ç†æ•ˆç‡
- é€‚åˆå¤§é‡æ•°æ®å¤„ç†
```

**ğŸ”§ è°ƒè¯•æŠ€å·§**
```
è°ƒè¯•æ–¹æ³•ï¼š
- ä½¿ç”¨putsè¾“å‡ºè°ƒè¯•ä¿¡æ¯
- åœ¨äº‹ä»¶ä¸­æ·»åŠ è°ƒè¯•å­—æ®µ
- è®°å½•å¤„ç†æ—¶é—´å’ŒçŠ¶æ€
- ä½¿ç”¨æ¡ä»¶æ–­ç‚¹ï¼ˆé€šè¿‡ifè¯­å¥ï¼‰

æ—¥å¿—åˆ†æï¼š
- ç›‘æ§é”™è¯¯ç‡å˜åŒ–
- åˆ†ææ€§èƒ½ç“¶é¢ˆ
- è¿½è¸ªæ•°æ®å¤„ç†æµç¨‹
- éªŒè¯å¤„ç†ç»“æœæ­£ç¡®æ€§
```

**æ ¸å¿ƒè®°å¿†**ï¼š
- Rubyè¿‡æ»¤å™¨æ˜¯Logstashçš„å¼ºå¤§æ‰©å±•å·¥å…·
- äº‹ä»¶å¯¹è±¡æ˜¯æ•°æ®å¤„ç†çš„æ ¸å¿ƒæ¥å£
- å¼‚å¸¸å¤„ç†æ˜¯ä¿è¯ç³»ç»Ÿç¨³å®šæ€§çš„å…³é”®
- æ€§èƒ½ä¼˜åŒ–éœ€è¦ä»ç®—æ³•å’Œå®ç°ä¸¤ä¸ªå±‚é¢è€ƒè™‘
- åˆç†çš„ä»£ç ç»„ç»‡èƒ½æé«˜å¼€å‘å’Œç»´æŠ¤æ•ˆç‡