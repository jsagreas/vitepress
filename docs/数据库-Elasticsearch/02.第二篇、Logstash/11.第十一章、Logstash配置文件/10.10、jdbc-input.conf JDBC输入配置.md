---
title: 10、jdbc-input.conf JDBC输入配置
---
## 📚 目录

1. [JDBC输入插件概述](#1-JDBC输入插件概述)
2. [JDBC驱动配置详解](#2-JDBC驱动配置详解)
3. [数据库连接配置](#3-数据库连接配置)
4. [SQL查询语句设计](#4-SQL查询语句设计)
5. [调度执行机制](#5-调度执行机制)
6. [数据追踪策略](#6-数据追踪策略)
7. [完整配置示例](#7-完整配置示例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 JDBC输入插件概述


### 1.1 什么是JDBC输入插件


**简单理解**：JDBC输入插件就像一个"数据搬运工"，专门从各种数据库里把数据搬到Elasticsearch中。

```
想象一个场景：
你有一个MySQL数据库，里面存储着用户订单信息
你希望把这些订单数据同步到Elasticsearch中进行搜索分析
JDBC输入插件就是帮你完成这个搬运工作的工具
```

**核心作用**：
- 🔄 **数据同步**：定期从数据库读取数据
- 🚀 **实时更新**：支持增量数据同步
- 🔍 **灵活查询**：支持复杂SQL查询
- 📅 **定时执行**：按计划自动运行

### 1.2 工作原理图示


```
数据库(MySQL/PostgreSQL/Oracle等)
        ↓ JDBC连接
┌─────────────────────────┐
│    Logstash JDBC插件    │ ← 执行SQL查询
│   ┌─────────────────┐   │
│   │  调度器(定时)    │   │ ← 按计划运行
│   └─────────────────┘   │
│   ┌─────────────────┐   │
│   │  数据追踪器     │   │ ← 记录同步状态
│   └─────────────────┘   │
└─────────────────────────┘
        ↓ 处理后的数据
    Elasticsearch
```

### 1.3 适用场景


**🎯 典型应用场景**：

| 场景类型 | **具体用途** | **示例** |
|---------|------------|---------|
| 🏪 **电商系统** | `订单数据同步` | `MySQL订单表 → ES搜索` |
| 👥 **用户管理** | `用户信息同步` | `用户表 → ES用户画像` |
| 📊 **日志分析** | `业务日志入库` | `应用日志表 → ES分析` |
| 📈 **报表系统** | `数据仓库同步` | `数据仓库 → ES实时查询` |

---

## 2. 🔧 JDBC驱动配置详解


### 2.1 JDBC驱动的作用


**通俗解释**：JDBC驱动就像"翻译官"，让Logstash能够"听懂"不同数据库的"语言"。

```
比喻理解：
如果数据库是不同国家的人，说着不同的语言
MySQL说"MySQL语"，PostgreSQL说"PostgreSQL语"
JDBC驱动就是翻译官，让Logstash能和它们正常交流
```

### 2.2 驱动库配置


**💡 jdbc_driver_library参数**：
- **作用**：指定JDBC驱动文件的位置
- **格式**：jar文件的完整路径
- **重要性**：没有这个文件，就无法连接数据库

```ruby
# 基本配置格式
jdbc_driver_library => "/path/to/driver.jar"

# 常见数据库驱动路径示例
jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
jdbc_driver_library => "/usr/share/java/postgresql-42.6.0.jar"
```

### 2.3 驱动类配置


**🔍 jdbc_driver_class参数**：
- **作用**：告诉Logstash使用哪个具体的驱动类
- **重要性**：相当于告诉系统"用哪个翻译官"

```ruby
# 常见数据库的驱动类
jdbc_driver_class => "com.mysql.cj.jdbc.Driver"         # MySQL 8.x
jdbc_driver_class => "com.mysql.jdbc.Driver"            # MySQL 5.x
jdbc_driver_class => "org.postgresql.Driver"            # PostgreSQL
jdbc_driver_class => "oracle.jdbc.driver.OracleDriver"  # Oracle
```

### 2.4 驱动版本兼容性


**⚠️ 版本选择要点**：

| 数据库类型 | **推荐驱动版本** | **兼容性说明** |
|-----------|-----------------|---------------|
| **MySQL 8.x** | `mysql-connector-java-8.0.x` | `新版本，支持新特性` |
| **MySQL 5.x** | `mysql-connector-java-5.1.x` | `老版本，稳定可靠` |
| **PostgreSQL** | `postgresql-42.x.x` | `向后兼容性好` |
| **Oracle** | `ojdbc8.jar` | `根据Oracle版本选择` |

---

## 3. 🔐 数据库连接配置


### 3.1 连接字符串详解


**🔗 jdbc_connection_string参数**：这是告诉Logstash"数据库住在哪里"的地址。

```ruby
# MySQL连接字符串格式
jdbc_connection_string => "jdbc:mysql://数据库服务器:端口/数据库名"

# 实际示例
jdbc_connection_string => "jdbc:mysql://localhost:3306/ecommerce"
jdbc_connection_string => "jdbc:mysql://192.168.1.100:3306/orders"
```

**连接字符串构成解析**：
```
jdbc:mysql://localhost:3306/ecommerce
 ↑      ↑        ↑       ↑      ↑
协议   数据库类型  服务器地址 端口   数据库名
```

### 3.2 认证信息配置


**🔐 用户名密码配置**：

```ruby
# 基本认证配置
jdbc_user => "your_username"
jdbc_password => "your_password"

# 实际示例
jdbc_user => "logstash_user"
jdbc_password => "safe_password_123"
```

**🛡️ 安全建议**：
- ✅ **专用账户**：为Logstash创建专门的数据库账户
- ✅ **最小权限**：只给读取权限，不给写入权限
- ✅ **密码管理**：使用复杂密码，定期更换

### 3.3 连接池配置


**⚡ 高级连接配置**：

```ruby
# 连接池参数
jdbc_pool_timeout => 5        # 连接超时时间(秒)
jdbc_validate_connection => true  # 验证连接有效性
```

### 3.4 不同数据库连接示例


**📋 各数据库连接配置对比**：

```ruby
# MySQL配置
jdbc_driver_library => "/opt/drivers/mysql-connector-java-8.0.33.jar"
jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
jdbc_connection_string => "jdbc:mysql://localhost:3306/mydb"

# PostgreSQL配置
jdbc_driver_library => "/opt/drivers/postgresql-42.6.0.jar"
jdbc_driver_class => "org.postgresql.Driver"
jdbc_connection_string => "jdbc:postgresql://localhost:5432/mydb"

# SQL Server配置
jdbc_driver_library => "/opt/drivers/mssql-jdbc-9.4.0.jre8.jar"
jdbc_driver_class => "com.microsoft.sqlserver.jdbc.SQLServerDriver"
jdbc_connection_string => "jdbc:sqlserver://localhost:1433;databaseName=mydb"
```

---

## 4. 📝 SQL查询语句设计


### 4.1 基本查询语句


**statement参数**：这是告诉数据库"我要什么数据"的指令。

```ruby
# 简单查询示例
statement => "SELECT * FROM users"

# 带条件的查询
statement => "SELECT id, name, email, created_at FROM users WHERE status = 'active'"
```

### 4.2 增量查询设计


**🔄 什么是增量查询**：
只获取新增或修改的数据，而不是每次都获取全部数据。

```ruby
# 基于时间的增量查询
statement => "
  SELECT id, name, email, updated_at 
  FROM users 
  WHERE updated_at > :sql_last_value
  ORDER BY updated_at ASC
"
```

**增量查询工作原理**：
```
第一次运行：获取所有数据
记录最大时间：2025-09-21 10:00:00

第二次运行：只获取 updated_at > 2025-09-21 10:00:00 的数据
记录最大时间：2025-09-21 11:30:00

第三次运行：只获取 updated_at > 2025-09-21 11:30:00 的数据
...以此类推
```

### 4.3 复杂查询示例


**🔍 多表联查**：

```ruby
statement => "
  SELECT 
    o.id as order_id,
    o.user_id,
    o.total_amount,
    o.created_at,
    u.name as user_name,
    u.email
  FROM orders o
  LEFT JOIN users u ON o.user_id = u.id
  WHERE o.created_at > :sql_last_value
  ORDER BY o.created_at ASC
"
```

### 4.4 SQL语句编写技巧


**💡 最佳实践**：

| 技巧类型 | **说明** | **示例** |
|---------|---------|---------|
| **索引优化** | `WHERE子句使用索引列` | `WHERE created_at > ?` |
| **字段限制** | `只选择需要的字段` | `SELECT id, name` 而不是 `SELECT *` |
| **排序要求** | `增量查询必须排序` | `ORDER BY updated_at ASC` |
| **数据类型** | `注意时间字段格式` | `TIMESTAMP, DATETIME` |

---

## 5. ⏰ 调度执行机制


### 5.1 调度计划配置


**schedule参数**：告诉Logstash"什么时候去取数据"。

```ruby
# 每分钟执行一次
schedule => "* * * * *"

# 每5分钟执行一次
schedule => "*/5 * * * *"

# 每小时执行一次
schedule => "0 * * * *"

# 每天凌晨2点执行
schedule => "0 2 * * *"
```

### 5.2 Cron表达式详解


**📅 Cron格式说明**：
```
* * * * *
│ │ │ │ │
│ │ │ │ └─── 星期 (0-6, 0=周日)
│ │ │ └───── 月份 (1-12)
│ │ └─────── 日期 (1-31)
│ └───────── 小时 (0-23)
└─────────── 分钟 (0-59)
```

**🕐 常用调度示例**：

| 需求场景 | **Cron表达式** | **说明** |
|---------|---------------|---------|
| **实时同步** | `* * * * *` | `每分钟执行` |
| **频繁更新** | `*/5 * * * *` | `每5分钟执行` |
| **定期同步** | `0 */2 * * *` | `每2小时执行` |
| **夜间批处理** | `0 2 * * *` | `每天凌晨2点` |
| **周报处理** | `0 9 * * 1` | `每周一上午9点` |

### 5.3 调度策略选择


**⚖️ 如何选择合适的调度频率**：

```
数据更新频率 → 调度频率建议
实时数据(秒级) → 每分钟
快速变化(分钟级) → 每5-10分钟  
一般业务(小时级) → 每小时
日报数据(天级) → 每天
归档数据(很少变) → 每周或每月
```

---

## 6. 🔍 数据追踪策略


### 6.1 use_column_value详解


**🎯 use_column_value的作用**：
告诉Logstash使用数据库中的某个字段值来追踪数据同步进度。

```ruby
# 启用列值追踪
use_column_value => true
tracking_column => "updated_at"
tracking_column_type => "timestamp"
```

**工作原理图示**：
```
数据库表：users
┌────┬──────┬─────────────────────┐
│ id │ name │     updated_at      │
├────┼──────┼─────────────────────┤
│ 1  │ 张三  │ 2025-09-21 10:00:00 │
│ 2  │ 李四  │ 2025-09-21 10:15:00 │ ← Logstash记录这个值
│ 3  │ 王五  │ 2025-09-21 10:30:00 │
└────┴──────┴─────────────────────┘

下次查询：WHERE updated_at > '2025-09-21 10:30:00'
```

### 6.2 tracking_column配置


**📊 追踪列的选择**：

| 列类型 | **适用场景** | **优缺点** |
|-------|-------------|-----------|
| **id自增列** | `新增数据较多` | `✅简单 ❌无法处理更新` |
| **created_at** | `只关心新增数据` | `✅可靠 ❌不能追踪修改` |
| **updated_at** | `需要追踪更新` | `✅完整 ❌需要维护该字段` |
| **version版本号** | `复杂业务场景` | `✅精确 ❌实现复杂` |

```ruby
# 基于时间戳追踪(推荐)
tracking_column => "updated_at"
tracking_column_type => "timestamp"

# 基于自增ID追踪
tracking_column => "id"
tracking_column_type => "numeric"
```

### 6.3 last_run_metadata_path配置


**💾 元数据存储路径**：
这个文件记录了上次同步到哪里，下次从哪里开始。

```ruby
# 指定元数据文件路径
last_run_metadata_path => "/opt/logstash/metadata/users_last_run"
```

**元数据文件内容示例**：
```
--- 2025-09-21 15:30:00.000000000 +08:00
```

**🔒 重要注意事项**：
- ✅ **路径权限**：确保Logstash有读写权限
- ✅ **备份重要**：定期备份元数据文件
- ✅ **重置机制**：删除文件可重新开始同步

---

## 7. 📋 完整配置示例


### 7.1 MySQL订单数据同步


```ruby
input {
  jdbc {
    # 驱动配置
    jdbc_driver_library => "/opt/logstash/drivers/mysql-connector-java-8.0.33.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    
    # 连接配置
    jdbc_connection_string => "jdbc:mysql://localhost:3306/ecommerce?useUnicode=true&characterEncoding=utf8&useSSL=false"
    jdbc_user => "logstash_user"
    jdbc_password => "secure_password_123"
    
    # 查询配置
    statement => "
      SELECT 
        id,
        user_id,
        order_number,
        total_amount,
        status,
        created_at,
        updated_at
      FROM orders 
      WHERE updated_at > :sql_last_value 
      ORDER BY updated_at ASC
    "
    
    # 调度配置
    schedule => "*/5 * * * *"  # 每5分钟执行一次
    
    # 追踪配置
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"
    last_run_metadata_path => "/opt/logstash/metadata/orders_last_run"
    
    # 其他配置
    jdbc_paging_enabled => true
    jdbc_page_size => 50000
  }
}

filter {
  # 添加索引名称
  mutate {
    add_field => { "[@metadata][index]" => "orders" }
  }
  
  # 格式化金额字段
  if [total_amount] {
    mutate {
      convert => { "total_amount" => "float" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "%{[@metadata][index]}-%{+YYYY.MM.dd}"
    document_id => "%{id}"
  }
  
  # 调试输出(可选)
  stdout { 
    codec => rubydebug 
  }
}
```

### 7.2 PostgreSQL用户数据同步


```ruby
input {
  jdbc {
    # PostgreSQL驱动配置
    jdbc_driver_library => "/opt/logstash/drivers/postgresql-42.6.0.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    
    # 连接配置
    jdbc_connection_string => "jdbc:postgresql://localhost:5432/userdb"
    jdbc_user => "logstash"
    jdbc_password => "logstash_pwd"
    
    # 查询配置
    statement => "
      SELECT 
        u.id,
        u.username,
        u.email,
        u.first_name,
        u.last_name,
        u.status,
        u.created_at,
        u.updated_at,
        p.phone,
        p.address
      FROM users u
      LEFT JOIN profiles p ON u.id = p.user_id
      WHERE u.updated_at > :sql_last_value
      ORDER BY u.updated_at ASC
    "
    
    # 每天凌晨2点执行
    schedule => "0 2 * * *"
    
    # 追踪配置
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"
    last_run_metadata_path => "/opt/logstash/metadata/users_last_run"
  }
}
```

### 7.3 配置优化建议


**🚀 性能优化配置**：

```ruby
# 分页查询配置
jdbc_paging_enabled => true        # 启用分页
jdbc_page_size => 50000            # 每页5万条记录

# 连接池配置
jdbc_pool_timeout => 5             # 连接超时5秒
jdbc_validate_connection => true   # 验证连接

# 字符编码配置
jdbc_connection_string => "jdbc:mysql://localhost:3306/db?useUnicode=true&characterEncoding=utf8"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 JDBC输入插件：数据库到ES的数据搬运工具
🔸 驱动配置：jdbc_driver_library + jdbc_driver_class
🔸 连接配置：连接字符串 + 用户名密码
🔸 SQL查询：statement参数定义数据获取逻辑
🔸 调度机制：schedule参数控制执行时间
🔸 数据追踪：use_column_value + tracking_column
🔸 元数据管理：last_run_metadata_path记录同步状态
```

### 8.2 关键理解要点


**🔹 为什么需要数据追踪**：
```
没有追踪：每次都同步全部数据，效率低下
有了追踪：只同步新增和修改的数据，效率高
追踪原理：记录上次同步的位置，下次从该位置开始
```

**🔹 调度频率如何选择**：
```
业务要求 vs 系统负载的平衡
实时性要求高 → 增加同步频率
数据量大 → 减少同步频率
数据库负载 → 避开业务高峰期
```

**🔹 SQL查询设计要点**：
```
增量查询：WHERE字段 > :sql_last_value
排序要求：ORDER BY 追踪字段 ASC
性能优化：使用索引，限制字段，避免全表扫描
```

### 8.3 实际应用指导


**📊 适用场景判断**：
- ✅ **结构化数据同步**：关系型数据库数据
- ✅ **批量数据处理**：大量历史数据迁移  
- ✅ **定期数据更新**：按计划同步业务数据
- ❌ **实时性要求极高**：毫秒级同步需求
- ❌ **非结构化数据**：日志文件、消息队列

**🔧 配置最佳实践**：
- **安全性**：使用专用账户，最小权限原则
- **性能**：合理设置分页大小，优化SQL查询
- **监控**：记录同步日志，监控执行状态
- **容错**：处理连接异常，数据验证

**核心记忆**：
- JDBC输入是数据库到ES的桥梁
- 追踪机制确保数据不重复不遗漏  
- 调度策略要平衡实时性和性能
- 配置要考虑安全性和可维护性