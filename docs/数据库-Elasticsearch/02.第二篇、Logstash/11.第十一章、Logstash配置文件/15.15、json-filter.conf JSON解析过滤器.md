---
title: 15、json-filter.conf JSON解析过滤器
---
## 📚 目录

1. [JSON过滤器基础概念](#1-JSON过滤器基础概念)
2. [JSON源字段指定](#2-JSON源字段指定)
3. [解析目标字段设置](#3-解析目标字段设置)
4. [嵌套JSON处理](#4-嵌套JSON处理)
5. [无效JSON跳过](#5-无效JSON跳过)
6. [字段展平操作](#6-字段展平操作)
7. [数组元素处理](#7-数组元素处理)
8. [编码格式处理](#8-编码格式处理)
9. [解析错误标签](#9-解析错误标签)
10. [完整配置示例](#10-完整配置示例)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 JSON过滤器基础概念


### 1.1 什么是JSON过滤器


**简单理解**：JSON过滤器就像一个"智能解析器"，专门用来处理JSON格式的数据。

```
原始数据：'{"name":"张三","age":25,"city":"北京"}'
处理后：  name: "张三"
         age: 25  
         city: "北京"
```

**核心作用**：
- 🔧 **解析JSON字符串**：把JSON文本变成可操作的字段
- 📊 **结构化数据**：让杂乱的JSON变得有序
- 🎯 **提取关键信息**：从复杂JSON中取出需要的部分

### 1.2 为什么需要JSON过滤器


**实际场景举例**：
```
应用日志：{"timestamp":"2025-09-21","level":"ERROR","message":"用户登录失败","user_id":12345}
API响应：{"status":"success","data":{"user":"admin","role":"manager"},"code":200}
监控数据：{"cpu":85.5,"memory":67.2,"disk":{"usage":45,"available":55}}
```

**不用JSON过滤器的问题**：
- ❌ 数据全部挤在一个字段里
- ❌ 无法按字段搜索和分析
- ❌ 图表和报表制作困难

**使用JSON过滤器的好处**：
- ✅ 每个字段独立可查询
- ✅ 支持复杂的数据分析
- ✅ 便于制作Dashboard

### 1.3 JSON过滤器工作原理


```
输入数据流程：
原始事件 → JSON过滤器 → 解析后事件

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  原始JSON字符串  │ →  │   JSON过滤器     │ →  │   结构化字段     │
│  message字段    │    │   解析处理      │    │   独立字段      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

---

## 2. 📍 JSON源字段指定


### 2.1 source参数详解


**基本语法**：
```ruby
filter {
  json {
    source => "字段名"
  }
}
```

**source参数的含义**：指定哪个字段包含需要解析的JSON数据。

### 2.2 常见源字段场景


**场景1：默认message字段**
```ruby
filter {
  json {
    source => "message"
  }
}
```

> **💡 实际应用**：大多数日志数据都存储在message字段中

**场景2：自定义字段**
```ruby
filter {
  json {
    source => "json_data"
  }
}
```

**场景3：嵌套字段**
```ruby
filter {
  json {
    source => "[response][body]"
  }
}
```

### 2.3 源字段选择技巧


| 数据来源 | 推荐源字段 | 说明 |
|---------|-----------|------|
| **应用日志** | `message` | 标准日志格式 |
| **API响应** | `response_body` | HTTP响应内容 |
| **配置文件** | `config_content` | 配置信息 |
| **数据库导出** | `json_row` | 数据行内容 |

---

## 3. 🎯 解析目标字段设置


### 3.1 target参数作用


**target参数**：决定解析后的字段放在哪里。

```ruby
# 不指定target - 直接放到根级别
filter {
  json {
    source => "message"
  }
}

# 指定target - 放到指定字段下
filter {
  json {
    source => "message"
    target => "parsed_data"
  }
}
```

### 3.2 不同target设置对比


**不设置target（默认行为）**：
```
输入：message = '{"name":"张三","age":25}'
输出：name = "张三"
     age = 25
     message = '{"name":"张三","age":25}'
```

**设置target字段**：
```
输入：message = '{"name":"张三","age":25}'
输出：parsed_data.name = "张三"
     parsed_data.age = 25
     message = '{"name":"张三","age":25}'
```

### 3.3 target使用建议


```ruby
# ✅ 推荐：避免字段冲突
filter {
  json {
    source => "message"
    target => "app_data"
  }
}

# ⚠️ 注意：可能覆盖现有字段
filter {
  json {
    source => "message"
    # 不设置target，直接解析到根级别
  }
}
```

---

## 4. 🔄 嵌套JSON处理


### 4.1 什么是嵌套JSON


**嵌套JSON示例**：
```json
{
  "user": {
    "profile": {
      "name": "张三",
      "contact": {
        "email": "zhangsan@example.com",
        "phone": "13800138000"
      }
    },
    "settings": {
      "theme": "dark",
      "language": "zh-CN"
    }
  }
}
```

### 4.2 处理嵌套JSON配置


**基础配置**：
```ruby
filter {
  json {
    source => "message"
    target => "user_data"
  }
}
```

**处理结果**：
```
user_data.user.profile.name = "张三"
user_data.user.profile.contact.email = "zhangsan@example.com"
user_data.user.profile.contact.phone = "13800138000"
user_data.user.settings.theme = "dark"
user_data.user.settings.language = "zh-CN"
```

### 4.3 多层嵌套处理策略


**策略1：全部解析**
```ruby
filter {
  json {
    source => "message"
    target => "data"
  }
}
```

**策略2：分步解析**
```ruby
filter {
  # 第一步：解析外层
  json {
    source => "message"
    target => "level1"
  }
  
  # 第二步：解析内层
  json {
    source => "[level1][user][profile]"
    target => "user_profile"
  }
}
```

### 4.4 嵌套数据访问方法


```ruby
# 访问嵌套字段的语法
if [data][user][profile][name] {
  # 处理用户名字段
}

# 检查嵌套字段是否存在
if [data][user][contact] {
  mutate {
    add_field => { "has_contact" => "true" }
  }
}
```

---

## 5. ⚠️ 无效JSON跳过


### 5.1 skip_on_invalid_json参数


**参数作用**：当遇到无效JSON时，决定是报错还是跳过。

```ruby
filter {
  json {
    source => "message"
    skip_on_invalid_json => true
  }
}
```

### 5.2 无效JSON的常见情况


**情况1：格式错误**
```
错误JSON：{"name":"张三","age":25,}  # 多余的逗号
错误JSON：{'name':'张三'}           # 单引号不符合标准
错误JSON：{name:"张三"}            # 缺少引号
```

**情况2：不完整数据**
```
错误JSON：{"name":"张三","age":     # 数据截断
错误JSON：{"name":"张三"           # 缺少结束括号
```

**情况3：非JSON数据**
```
普通文本：This is not JSON
数字：12345
空字符串：""
```

### 5.3 skip_on_invalid_json设置对比


| 设置值 | 遇到无效JSON时的行为 | 适用场景 |
|-------|-------------------|---------|
| `true` | 跳过，继续处理其他数据 | **生产环境**（推荐） |
| `false` | 停止处理，添加错误标签 | **调试阶段** |

**生产环境推荐配置**：
```ruby
filter {
  json {
    source => "message"
    skip_on_invalid_json => true
    tag_on_failure => ["_jsonparsefailure"]
  }
}
```

---

## 6. 📊 字段展平操作


### 6.1 什么是字段展平


**展平前的嵌套结构**：
```json
{
  "user": {
    "name": "张三",
    "age": 25,
    "contact": {
      "email": "zhangsan@example.com"
    }
  }
}
```

**展平后的平铺结构**：
```
user_name = "张三"
user_age = 25
user_contact_email = "zhangsan@example.com"
```

### 6.2 使用Ruby代码实现展平


```ruby
filter {
  json {
    source => "message"
    target => "temp_data"
  }
  
  ruby {
    code => '
      def flatten_hash(hash, prefix = "")
        result = {}
        hash.each do |key, value|
          new_key = prefix.empty? ? key : "#{prefix}_#{key}"
          if value.is_a?(Hash)
            result.merge!(flatten_hash(value, new_key))
          else
            result[new_key] = value
          end
        end
        result
      end
      
      if event.get("temp_data")
        flattened = flatten_hash(event.get("temp_data"))
        flattened.each do |key, value|
          event.set(key, value)
        end
        event.remove("temp_data")
      end
    '
  }
}
```

### 6.3 展平操作的应用场景


**适用场景**：
- ✅ **Elasticsearch映射**：避免复杂的嵌套字段映射
- ✅ **SQL查询**：平铺字段更容易查询
- ✅ **报表制作**：简化字段引用

**不适用场景**：
- ❌ **保持数据结构**：需要维护原始层次关系
- ❌ **动态字段**：字段名经常变化的情况

---

## 7. 📋 数组元素处理


### 7.1 JSON数组的处理方式


**JSON数组示例**：
```json
{
  "users": [
    {"name": "张三", "age": 25},
    {"name": "李四", "age": 30},
    {"name": "王五", "age": 28}
  ],
  "tags": ["user", "admin", "active"]
}
```

### 7.2 基本数组处理


**配置示例**：
```ruby
filter {
  json {
    source => "message"
    target => "data"
  }
}
```

**处理结果**：
```
data.users[0].name = "张三"
data.users[0].age = 25
data.users[1].name = "李四"
data.users[1].age = 30
data.users[2].name = "王五"
data.users[2].age = 28
data.tags[0] = "user"
data.tags[1] = "admin"
data.tags[2] = "active"
```

### 7.3 数组元素分离处理


**使用split插件处理数组**：
```ruby
filter {
  json {
    source => "message"
    target => "data"
  }
  
  # 将数组元素分离为独立事件
  split {
    field => "[data][users]"
  }
}
```

**分离结果**：
```
事件1：data.users.name = "张三", data.users.age = 25
事件2：data.users.name = "李四", data.users.age = 30  
事件3：data.users.name = "王五", data.users.age = 28
```

### 7.4 数组处理实用技巧


**技巧1：数组长度统计**
```ruby
filter {
  json {
    source => "message"
    target => "data"
  }
  
  ruby {
    code => '
      if event.get("[data][users]")
        event.set("user_count", event.get("[data][users]").length)
      end
    '
  }
}
```

**技巧2：数组元素过滤**
```ruby
filter {
  json {
    source => "message"
    target => "data"
  }
  
  ruby {
    code => '
      users = event.get("[data][users]")
      if users
        active_users = users.select { |user| user["age"] > 26 }
        event.set("active_users", active_users)
      end
    '
  }
}
```

---

## 8. 🔤 编码格式处理


### 8.1 字符编码基础概念


**常见编码格式**：
- **UTF-8**：最常用的编码格式，支持中文
- **UTF-16**：Unicode编码格式
- **GBK/GB2312**：中文编码格式
- **ISO-8859-1**：西欧编码格式

### 8.2 charset参数配置


```ruby
filter {
  json {
    source => "message"
    charset => "UTF-8"
  }
}
```

### 8.3 编码问题的表现


**乱码示例**：
```
原始中文：{"name":"张三","city":"北京"}
GBK误读为UTF-8：{"name":"聙閭袚甯淸锛屼腑鏂�","city":"聯鎶悧鑻�"}
```

**解决方案**：
```ruby
filter {
  # 方案1：指定正确编码
  json {
    source => "message"
    charset => "GBK"
  }
  
  # 方案2：编码转换
  mutate {
    convert => { "message" => "string" }
  }
  
  json {
    source => "message"
    charset => "UTF-8"
  }
}
```

### 8.4 编码检测与处理


**自动编码检测**：
```ruby
filter {
  ruby {
    code => '
      require "chardet"
      
      message = event.get("message")
      if message
        detected = CharDet.detect(message)
        event.set("detected_encoding", detected["encoding"])
        
        if detected["encoding"] != "UTF-8"
          # 进行编码转换
          converted = message.encode("UTF-8", detected["encoding"])
          event.set("message", converted)
        end
      end
    '
  }
  
  json {
    source => "message"
  }
}
```

---

## 9. 🏷️ 解析错误标签


### 9.1 tag_on_failure参数


**参数作用**：当JSON解析失败时，给事件添加特定标签。

```ruby
filter {
  json {
    source => "message"
    tag_on_failure => ["_jsonparsefailure"]
  }
}
```

### 9.2 自定义错误标签


**多个错误标签**：
```ruby
filter {
  json {
    source => "message"
    tag_on_failure => ["json_error", "parse_failed", "需要人工检查"]
  }
}
```

**动态错误标签**：
```ruby
filter {
  json {
    source => "message"
    tag_on_failure => ["json_error_%{+YYYY.MM.dd}"]
  }
}
```

### 9.3 错误处理流程


```
JSON解析流程：
输入数据 → JSON解析 → 成功？
                       ↓
                      是 → 继续处理
                       ↓
                      否 → 添加错误标签 → 错误处理分支
```

**错误处理配置**：
```ruby
filter {
  json {
    source => "message"
    tag_on_failure => ["_jsonparsefailure"]
  }
  
  # 处理解析失败的事件
  if "_jsonparsefailure" in [tags] {
    mutate {
      add_field => { 
        "error_type" => "json_parse_error"
        "error_time" => "%{@timestamp}"
        "raw_message" => "%{message}"
      }
    }
    
    # 发送到错误处理管道
    mutate {
      add_tag => ["send_to_error_index"]
    }
  }
}
```

### 9.4 错误监控和报警


**错误统计配置**：
```ruby
filter {
  json {
    source => "message"
    tag_on_failure => ["_jsonparsefailure"]
  }
  
  if "_jsonparsefailure" in [tags] {
    metrics {
      meter => "json_parse_errors"
      add_tag => "metric"
    }
  }
}
```

---

## 10. 🔧 完整配置示例


### 10.1 基础JSON解析配置


```ruby
# 15-json-filter.conf
input {
  beats {
    port => 5044
  }
}

filter {
  # 基础JSON解析
  json {
    source => "message"
    target => "app_data"
    skip_on_invalid_json => true
    tag_on_failure => ["_jsonparsefailure"]
  }
  
  # 添加解析状态标识
  if "_jsonparsefailure" not in [tags] {
    mutate {
      add_tag => ["json_parsed"]
    }
  }
}

output {
  if "json_parsed" in [tags] {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "app-logs-%{+YYYY.MM.dd}"
    }
  } else {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "error-logs-%{+YYYY.MM.dd}"
    }
  }
}
```

### 10.2 高级JSON处理配置


```ruby
filter {
  # 第一步：尝试解析JSON
  json {
    source => "message"
    target => "parsed"
    skip_on_invalid_json => true
    tag_on_failure => ["_jsonparsefailure"]
  }
  
  # 第二步：处理成功解析的数据
  if "_jsonparsefailure" not in [tags] {
    
    # 提取时间戳
    if [parsed][timestamp] {
      date {
        match => [ "[parsed][timestamp]", "yyyy-MM-dd HH:mm:ss" ]
      }
    }
    
    # 处理嵌套的用户信息
    if [parsed][user] {
      json {
        source => "[parsed][user]"
        target => "user_details"
        skip_on_invalid_json => true
      }
    }
    
    # 添加自定义字段
    mutate {
      add_field => { 
        "processed_at" => "%{@timestamp}"
        "data_source" => "json_filter"
      }
    }
  }
  
  # 第三步：处理解析失败的数据
  if "_jsonparsefailure" in [tags] {
    mutate {
      add_field => { 
        "error_reason" => "JSON解析失败"
        "original_message" => "%{message}"
      }
    }
  }
}
```

### 10.3 多源JSON处理配置


```ruby
filter {
  # 处理应用日志
  if [fields][log_type] == "application" {
    json {
      source => "message"
      target => "app"
      skip_on_invalid_json => true
      tag_on_failure => ["_app_json_fail"]
    }
  }
  
  # 处理API响应日志
  if [fields][log_type] == "api_response" {
    json {
      source => "response_body"
      target => "api"
      skip_on_invalid_json => true
      tag_on_failure => ["_api_json_fail"]
    }
  }
  
  # 处理配置文件
  if [fields][log_type] == "config" {
    json {
      source => "config_content"
      target => "config"
      charset => "UTF-8"
      skip_on_invalid_json => true
      tag_on_failure => ["_config_json_fail"]
    }
  }
}
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 JSON过滤器作用：将JSON字符串解析为结构化字段
🔸 source参数：指定包含JSON数据的源字段
🔸 target参数：指定解析后字段的存放位置
🔸 skip_on_invalid_json：控制无效JSON的处理方式
🔸 tag_on_failure：为解析失败的事件添加标签
```

### 11.2 关键配置参数速查


| 参数 | 作用 | 默认值 | 推荐设置 |
|------|------|--------|----------|
| **source** | 源字段名 | `"message"` | 根据实际情况 |
| **target** | 目标字段名 | 无（根级别） | 设置避免冲突 |
| **skip_on_invalid_json** | 跳过无效JSON | `false` | `true`（生产环境） |
| **tag_on_failure** | 错误标签 | `["_jsonparsefailure"]` | 自定义标签 |
| **charset** | 字符编码 | `"UTF-8"` | 根据数据编码 |

### 11.3 最佳实践建议


**🔹 生产环境推荐配置**
```ruby
filter {
  json {
    source => "message"
    target => "data"
    skip_on_invalid_json => true
    tag_on_failure => ["_jsonparsefailure"]
  }
}
```

**🔹 调试阶段推荐配置**
```ruby
filter {
  json {
    source => "message"
    target => "data"
    skip_on_invalid_json => false
    tag_on_failure => ["_jsonparsefailure", "debug"]
  }
}
```

**🔹 性能优化建议**
- ✅ 合理使用target参数避免字段冲突
- ✅ 生产环境启用skip_on_invalid_json
- ✅ 设置有意义的错误标签便于监控
- ✅ 对于大量嵌套数据考虑分步解析

### 11.4 常见问题解决


**问题1：中文乱码**
```ruby
# 解决方案：指定正确编码
json {
  source => "message"
  charset => "UTF-8"
}
```

**问题2：字段冲突**
```ruby
# 解决方案：使用target参数
json {
  source => "message"
  target => "parsed_data"
}
```

**问题3：解析失败频繁**
```ruby
# 解决方案：启用跳过机制并监控
json {
  source => "message"
  skip_on_invalid_json => true
  tag_on_failure => ["需要检查"]
}
```

**核心记忆**：
- JSON过滤器是结构化日志数据的利器
- source指定来源，target指定去处
- 生产环境必须处理无效JSON情况
- 合理的错误标签有助于问题排查和监控