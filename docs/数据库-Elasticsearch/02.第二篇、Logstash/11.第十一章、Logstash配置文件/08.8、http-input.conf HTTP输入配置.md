---
title: 8、http-input.conf HTTP输入配置
---
## 📚 目录

1. [HTTP输入插件基础概念](#1-HTTP输入插件基础概念)
2. [端口和服务配置](#2-端口和服务配置)
3. [安全认证配置](#3-安全认证配置)
4. [性能和并发配置](#4-性能和并发配置)
5. [请求和响应处理](#5-请求和响应处理)
6. [完整配置示例](#6-完整配置示例)
7. [实战应用场景](#7-实战应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 HTTP输入插件基础概念


### 1.1 什么是HTTP输入插件


**简单理解**：HTTP输入插件就像是给Logstash开了一个"网络接收口"，其他系统可以通过HTTP请求把数据发送给Logstash。

```
想象场景：
你的应用程序 → 发送HTTP请求 → Logstash HTTP插件 → 接收数据 → 处理数据

就像邮递员把信件投递到你家的信箱一样简单！
```

**核心作用**：
- 🔸 **接收器**：接收来自各种系统的HTTP数据推送
- 🔸 **解析器**：自动解析JSON、XML等格式的数据
- 🔸 **转换器**：将HTTP请求转换为Logstash事件
- 🔸 **网关**：为不同系统提供统一的数据入口

### 1.2 工作原理图解


```
外部应用/系统
     |
     | HTTP POST/GET请求
     ↓
┌─────────────────────┐
│  Logstash HTTP插件  │ ← 监听指定端口
│                     │
│ ┌─────────────────┐ │
│ │  请求接收处理    │ │ ← 解析HTTP请求
│ └─────────────────┘ │
│ ┌─────────────────┐ │
│ │  数据格式转换    │ │ ← 转换为事件
│ └─────────────────┘ │
│ ┌─────────────────┐ │
│ │  响应返回处理    │ │ ← 返回确认信息
│ └─────────────────┘ │
└─────────────────────┘
     |
     | Logstash事件
     ↓
   Filter处理链
```

### 1.3 适用场景


**最佳应用场景**：
- ✅ **微服务架构**：各个服务推送日志到统一收集点
- ✅ **Webhook接收**：接收第三方系统的Webhook通知
- ✅ **监控数据**：应用主动推送监控指标数据
- ✅ **事件通知**：系统间的事件通知和消息传递

---

## 2. 🔧 端口和服务配置


### 2.1 基础端口绑定


**核心概念**：就像给你的房子分配门牌号一样，HTTP插件需要一个端口号来接收数据。

```ruby
input {
  http {
    port => 8080           # 监听8080端口
    host => "0.0.0.0"      # 绑定所有网络接口
  }
}
```

**参数详解**：
- **port**: 🔸 监听的端口号（必须配置）
- **host**: 🔸 绑定的IP地址
  - `"0.0.0.0"` - 监听所有网络接口（默认）
  - `"127.0.0.1"` - 只监听本地回环接口
  - `"192.168.1.100"` - 只监听指定IP

### 2.2 多端口配置


有时候你需要在不同端口接收不同类型的数据：

```ruby
input {
  # 应用日志端口
  http {
    port => 8080
    host => "0.0.0.0"
    type => "application_logs"
  }
  
  # 监控数据端口  
  http {
    port => 8081
    host => "0.0.0.0"
    type => "metrics"
  }
}
```

> 💡 **实用提示**：不同端口可以用type字段区分数据来源，便于后续处理

---

## 3. 🔒 安全认证配置


### 3.1 SSL/HTTPS加密配置


**为什么需要SSL**：就像给信件加密一样，防止传输过程中数据被窃取。

```ruby
input {
  http {
    port => 8443
    ssl => true                          # 启用SSL
    ssl_certificate => "/path/to/cert.crt"    # SSL证书路径
    ssl_key => "/path/to/private.key"         # 私钥路径
    ssl_verify_mode => "force_peer"           # 验证客户端证书
  }
}
```

**SSL配置选项**：

| 参数 | 说明 | 可选值 |
|------|------|--------|
| **ssl** | `是否启用SSL加密` | `true/false` |
| **ssl_certificate** | `SSL证书文件路径` | `文件路径字符串` |
| **ssl_key** | `SSL私钥文件路径` | `文件路径字符串` |
| **ssl_verify_mode** | `客户端验证模式` | `none/peer/force_peer` |

### 3.2 基础认证配置


**HTTP基础认证**：就像门卫检查身份证一样，验证发送方身份。

```ruby
input {
  http {
    port => 8080
    user => "admin"          # 用户名
    password => "secret123"  # 密码
  }
}
```

**发送数据时的认证**：
```bash
# 使用curl发送带认证的数据
curl -u admin:secret123 \
  -H "Content-Type: application/json" \
  -d '{"message": "test log"}' \
  http://localhost:8080
```

### 3.3 请求头验证


**自定义请求头验证**：可以要求特定的请求头才接受数据。

```ruby
input {
  http {
    port => 8080
    additional_codecs => {
      "application/json" => "json"
    }
    # 可以在filter中验证请求头
  }
}

filter {
  # 验证API Key
  if [headers][x-api-key] != "your-secret-key" {
    drop { }  # 丢弃未授权请求
  }
}
```

---

## 4. ⚡ 性能和并发配置


### 4.1 线程池配置


**threads参数**：控制同时处理多少个HTTP请求，就像银行开几个窗口服务客户。

```ruby
input {
  http {
    port => 8080
    threads => 4             # 4个工作线程
    max_pending_requests => 200   # 最大排队请求数
  }
}
```

**线程数选择指南**：
- 🔸 **CPU密集型**：线程数 = CPU核心数
- 🔸 **IO密集型**：线程数 = CPU核心数 × 2
- 🔸 **高并发场景**：根据实际测试调整

### 4.2 请求队列管理


```ruby
input {
  http {
    port => 8080
    threads => 8
    max_pending_requests => 500    # 最大挂起请求数
    max_content_length => 104857600  # 最大请求体大小(100MB)
  }
}
```

**参数说明**：
- **max_pending_requests**: 🔸 超过此数量的请求会被拒绝
- **max_content_length**: 🔸 防止过大请求消耗服务器资源

> ⚠️ **注意**：线程数过多会增加内存消耗，过少会影响并发性能

---

## 5. 📝 请求和响应处理


### 5.1 响应头配置


**自定义响应头**：告诉发送方请求的处理状态。

```ruby
input {
  http {
    port => 8080
    response_headers => {
      "X-Logstash-Response" => "received"
      "Access-Control-Allow-Origin" => "*"
      "Content-Type" => "application/json"
    }
  }
}
```

**常用响应头**：
- ✅ **Access-Control-Allow-Origin**: 跨域访问控制
- ✅ **Content-Type**: 响应内容类型
- ✅ **X-Custom-Header**: 自定义业务头信息

### 5.2 请求体解析


Logstash会自动根据Content-Type解析请求：

```ruby
# 自动解析JSON数据
POST /
Content-Type: application/json
{
  "timestamp": "2024-09-21T10:30:00Z",
  "level": "ERROR",
  "message": "Database connection failed"
}

# 自动解析表单数据
POST /
Content-Type: application/x-www-form-urlencoded
level=INFO&message=User%20login%20successful
```

### 5.3 请求信息获取


HTTP插件会自动添加请求相关信息：

```ruby
filter {
  mutate {
    add_field => {
      "client_ip" => "%{[headers][x-forwarded-for]}"
      "user_agent" => "%{[headers][user-agent]}"
      "request_method" => "%{[headers][request_method]}"
    }
  }
}
```

---

## 6. 📋 完整配置示例


### 6.1 基础HTTP服务配置


```ruby
input {
  http {
    # 基础服务配置
    port => 8080
    host => "0.0.0.0"
    
    # 性能配置
    threads => 4
    max_pending_requests => 200
    max_content_length => 10485760  # 10MB
    
    # 响应配置
    response_headers => {
      "X-Logstash-Version" => "8.10.0"
      "Content-Type" => "application/json"
    }
    
    # 数据标记
    type => "http_input"
    add_field => {
      "source" => "http_api"
    }
  }
}

filter {
  # 添加接收时间戳
  mutate {
    add_field => {
      "received_at" => "%{[@timestamp]}"
    }
  }
  
  # 解析IP地址
  if [headers][x-forwarded-for] {
    mutate {
      add_field => { "client_ip" => "%{[headers][x-forwarded-for]}" }
    }
  } else {
    mutate {
      add_field => { "client_ip" => "%{[headers][http_host]}" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "logstash-http-%{+YYYY.MM.dd}"
  }
}
```

### 6.2 安全加强版配置


```ruby
input {
  http {
    # HTTPS配置
    port => 8443
    ssl => true
    ssl_certificate => "/etc/logstash/ssl/logstash.crt"
    ssl_key => "/etc/logstash/ssl/logstash.key"
    
    # 基础认证
    user => "logstash_user"
    password => "${LOGSTASH_HTTP_PASSWORD}"  # 从环境变量读取
    
    # 性能配置
    threads => 8
    max_pending_requests => 500
    
    # 响应配置
    response_headers => {
      "X-Frame-Options" => "DENY"
      "X-Content-Type-Options" => "nosniff"
      "Strict-Transport-Security" => "max-age=31536000"
    }
  }
}

filter {
  # API Key验证
  if [headers][x-api-key] != "${API_SECRET_KEY}" {
    mutate {
      add_tag => ["unauthorized"]
    }
    drop { }
  }
  
  # 请求速率检查
  throttle {
    before_count => 100      # 1分钟内最多100个请求
    period => 60
    max_age => 120
    key => "%{[headers][x-forwarded-for]}"
    add_tag => ["rate_limited"]
  }
}
```

---

## 7. 🚀 实战应用场景


### 7.1 微服务日志收集


**场景**：多个微服务需要统一推送日志到Logstash

```ruby
input {
  http {
    port => 8080
    threads => 6
    max_pending_requests => 300
    type => "microservice_logs"
  }
}

filter {
  # 解析微服务信息
  if [headers][x-service-name] {
    mutate {
      add_field => { "service_name" => "%{[headers][x-service-name]}" }
    }
  }
  
  # 添加环境标识
  if [headers][x-environment] {
    mutate {
      add_field => { "environment" => "%{[headers][x-environment]}" }
    }
  }
}
```

**微服务发送示例**：
```javascript
// Node.js微服务发送日志
const axios = require('axios');

const sendLog = async (logData) => {
  try {
    await axios.post('http://logstash:8080', logData, {
      headers: {
        'Content-Type': 'application/json',
        'X-Service-Name': 'user-service',
        'X-Environment': 'production'
      }
    });
  } catch (error) {
    console.error('Failed to send log:', error);
  }
};
```

### 7.2 Webhook事件接收


**场景**：接收GitHub、GitLab等平台的Webhook通知

```ruby
input {
  http {
    port => 9000
    host => "0.0.0.0"
    type => "webhook"
    
    response_headers => {
      "X-Webhook-Response" => "processed"
    }
  }
}

filter {
  # GitHub Webhook处理
  if [headers][x-github-event] {
    mutate {
      add_field => {
        "webhook_source" => "github"
        "event_type" => "%{[headers][x-github-event]}"
      }
    }
  }
  
  # GitLab Webhook处理  
  if [headers][x-gitlab-event] {
    mutate {
      add_field => {
        "webhook_source" => "gitlab"
        "event_type" => "%{[headers][x-gitlab-event]}"
      }
    }
  }
}
```

### 7.3 监控指标收集


**场景**：应用程序主动推送监控指标

```ruby
input {
  http {
    port => 8081
    type => "metrics"
    
    # 专门处理指标数据的优化配置
    threads => 2
    max_content_length => 1048576  # 1MB足够
  }
}

filter {
  # 验证指标格式
  if ![metric_name] or ![metric_value] {
    mutate {
      add_tag => ["invalid_metric"]
    }
    drop { }
  }
  
  # 添加指标元数据
  mutate {
    add_field => {
      "metric_timestamp" => "%{[@timestamp]}"
      "data_type" => "metric"
    }
  }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 HTTP输入插件：为Logstash提供HTTP数据接收能力
🔸 端口绑定：配置监听端口和网络接口
🔸 SSL安全：启用HTTPS加密和证书验证
🔸 认证机制：基础认证和请求头验证
🔸 并发控制：线程池和请求队列管理
🔸 响应配置：自定义HTTP响应头和状态
```

### 8.2 配置要点记忆


**🔹 基础配置三要素**：
- ① **port** - 必须配置端口号
- ② **host** - 绑定网络接口  
- ③ **threads** - 设置并发线程数

**🔹 安全配置三层级**：
- 🔒 **传输加密** - SSL/TLS配置
- 🔑 **身份认证** - 用户名密码
- 🛡️ **访问控制** - 请求头验证

**🔹 性能优化三参数**：
- ⚡ **threads** - 并发处理能力
- 📊 **max_pending_requests** - 队列容量
- 💾 **max_content_length** - 请求大小限制

### 8.3 实际应用指导


**适用场景判断**：
- ✅ **推送模式**：应用主动推送数据到Logstash
- ✅ **实时性要求**：需要准实时的数据传输
- ✅ **标准协议**：利用HTTP的通用性和兼容性
- ❌ **大文件传输**：不适合传输大型日志文件
- ❌ **批量处理**：不如文件输入适合批量数据

**配置建议**：
- 🎯 **开发环境**：简单配置，关注功能验证
- 🔧 **测试环境**：中等配置，验证性能表现  
- 🚀 **生产环境**：完整配置，重视安全和性能

**核心记忆**：
- HTTP输入像网络邮箱，接收各方数据投递
- 端口号是门牌号，认证是门卫检查
- 线程数决定服务窗口，队列管理客流量
- SSL加密保安全，响应头告知状态