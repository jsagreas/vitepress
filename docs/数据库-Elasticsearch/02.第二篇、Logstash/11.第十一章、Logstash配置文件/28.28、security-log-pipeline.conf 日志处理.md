---
title: 28、security-log-pipeline.conf 日志处理
---
## 📚 目录

1. [安全日志处理概述](#1-安全日志处理概述)
2. [安全事件识别与过滤](#2-安全事件识别与过滤)
3. [威胁情报关联](#3-威胁情报关联)
4. [异常行为检测](#4-异常行为检测)
5. [攻击模式匹配](#5-攻击模式匹配)
6. [风险等级评估](#6-风险等级评估)
7. [实时告警触发](#7-实时告警触发)
8. [取证数据保留](#8-取证数据保留)
9. [合规报告生成](#9-合规报告生成)
10. [完整配置示例](#10-完整配置示例)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔒 安全日志处理概述


### 1.1 什么是安全日志处理


**简单理解**：就像给你家安装了一套智能安防系统

```
传统安保：保安看监控，发现问题手工记录
智能安防：摄像头自动识别可疑行为，立即报警

安全日志处理就是：
原始日志 → 智能分析 → 发现威胁 → 立即响应
```

**🎯 核心目标**：
- **发现威胁**：从海量日志中找出安全问题
- **快速响应**：第一时间发现并处理安全事件
- **证据保存**：为后续调查提供完整证据链
- **合规要求**：满足各种安全合规标准

### 1.2 安全日志的来源


```
网络设备日志：
防火墙 → 记录连接和阻断信息
路由器 → 记录网络流量异常
入侵检测 → 记录攻击尝试

系统日志：
Web服务器 → 记录访问和错误
数据库 → 记录查询和权限操作
操作系统 → 记录登录和文件操作

应用日志：
认证系统 → 记录登录失败
业务系统 → 记录敏感操作
API网关 → 记录接口调用
```

### 1.3 处理流程概览


```
数据流向：
原始日志 → 收集 → 解析 → 分析 → 告警 → 存储

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  各种日志源  │──→│   Logstash  │──→│  威胁检测   │
│ 防火墙/服务器│    │   数据处理   │    │   风险评估   │
└─────────────┘    └─────────────┘    └─────────────┘
                          │                    │
                          ↓                    ↓
                   ┌─────────────┐    ┌─────────────┐
                   │  数据存储   │    │  告警通知   │
                   │ 长期保存    │    │  实时响应   │
                   └─────────────┘    └─────────────┘
```

---

## 2. 🔍 安全事件识别与过滤


### 2.1 基础事件识别


**核心思路**：从普通日志中识别出可疑的安全事件

```ruby
# 识别登录失败事件
filter {
  # 检查是否是认证失败日志
  if [message] =~ /Failed|Authentication failed|Invalid/ {
    # 打上安全事件标签
    mutate {
      add_tag => ["security_event", "auth_failure"]
    }
    
    # 提取关键信息
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:result} login for user %{USERNAME:username} from %{IP:source_ip}"
      }
    }
  }
}
```

**💡 通俗解释**：
- 就像门卫看到有人多次尝试错误密码，就知道这可能是坏人
- 我们教Logstash识别"Failed"、"Authentication failed"这些关键词
- 一旦发现，立即打上"安全事件"的标签

### 2.2 多层过滤策略


```ruby
filter {
  # 第一层：基础安全事件过滤
  if [log_type] == "security" or [message] =~ /(?i)(attack|intrusion|malware|virus)/ {
    mutate { add_tag => ["security_candidate"] }
  }
  
  # 第二层：排除误报
  if "security_candidate" in [tags] {
    # 排除正常的系统维护操作
    if [username] == "admin" and [source_ip] == "192.168.1.100" {
      mutate { remove_tag => ["security_candidate"] }
    }
  }
  
  # 第三层：确认安全事件
  if "security_candidate" in [tags] {
    mutate { 
      add_tag => ["confirmed_security_event"]
      add_field => { "security_processed_at" => "%{@timestamp}" }
    }
  }
}
```

**📊 事件分类表格**：

| 事件类型 | 识别关键词 | 风险级别 | 处理方式 |
|---------|-----------|---------|---------|
| 登录失败 | `Failed login`, `Authentication failed` | 🟡 中等 | 计数监控 |
| 暴力破解 | 短时间多次失败 | 🔴 高 | 立即告警 |
| 恶意扫描 | `scan`, `probe`, 大量404 | 🟡 中等 | 记录追踪 |
| 代码注入 | `<script>`, `union select`, `../` | 🔴 高 | 立即阻断 |

---

## 3. 🕵️ 威胁情报关联


### 3.1 什么是威胁情报关联


**生活化比喻**：
```
就像警察有一本"通缉犯名单"：
• 看到可疑人员，先查查是不是通缉犯
• 如果是，立即提高警戒级别
• 如果不是，继续正常观察

威胁情报就是"网络世界的通缉犯名单"：
• 已知的恶意IP地址
• 危险的域名
• 病毒文件的特征码
```

### 3.2 IP威胁情报检查


```ruby
filter {
  # 检查源IP是否在威胁情报库中
  if [source_ip] {
    # 使用translate插件查询威胁情报数据库
    translate {
      source => "source_ip"
      target => "threat_intel"
      dictionary_path => "/etc/logstash/threat_intel/malicious_ips.yml"
      fallback => "clean"
    }
    
    # 如果发现威胁IP
    if [threat_intel] != "clean" {
      mutate {
        add_tag => ["threat_ip"]
        add_field => { 
          "threat_type" => "%{threat_intel}"
          "risk_score" => "95"
        }
      }
    }
  }
}
```

**📝 威胁情报文件示例** (`malicious_ips.yml`):
```yaml
# 恶意IP情报库（示例）
"192.168.100.1": "botnet"
"10.0.0.50": "scanner"
"172.16.1.100": "malware_c2"
```

### 3.3 域名威胁检查


```ruby
filter {
  # 从URL中提取域名
  if [url] {
    grok {
      match => { "url" => "https?://(?<domain>[^/]+)" }
    }
    
    # 检查域名威胁情报
    if [domain] {
      translate {
        source => "domain"
        target => "domain_reputation"
        dictionary_path => "/etc/logstash/threat_intel/malicious_domains.yml"
        fallback => "unknown"
      }
      
      # 发现恶意域名
      if [domain_reputation] =~ /malicious|phishing|malware/ {
        mutate {
          add_tag => ["malicious_domain"]
          add_field => { "threat_category" => "%{domain_reputation}" }
        }
      }
    }
  }
}
```

**🔍 威胁情报来源**：
```
免费情报源：
• AbuseIPDB - IP信誉数据库
• VirusTotal - 文件和URL检测
• 公开的恶意IP列表

商业情报源：
• FireEye ThreatConnect
• IBM X-Force
• Proofpoint ET Intelligence
```

---

## 4. 📊 异常行为检测


### 4.1 基于频率的异常检测


**核心思想**：正常用户不会在短时间内进行大量相同操作

```ruby
filter {
  # 计算用户在5分钟内的登录尝试次数
  if [event_type] == "login_attempt" {
    # 生成时间窗口标识（精确到5分钟）
    ruby {
      code => "
        time_window = (event.get('@timestamp').to_i / 300) * 300
        event.set('time_window', time_window)
        event.set('user_window_key', event.get('username').to_s + '_' + time_window.to_s)
      "
    }
    
    # 使用aggregate插件统计频率
    aggregate {
      task_id => "%{user_window_key}"
      code => "
        map['count'] ||= 0
        map['count'] += 1
        map['username'] = event.get('username')
        map['source_ip'] = event.get('source_ip')
      "
      push_map_as_event_on_timeout => true
      timeout => 300  # 5分钟
    }
  }
  
  # 检测异常高频访问
  if [count] and [count] > 10 {
    mutate {
      add_tag => ["suspicious_frequency", "potential_brute_force"]
      add_field => { 
        "anomaly_type" => "high_frequency_login"
        "risk_score" => "80"
      }
    }
  }
}
```

### 4.2 时间模式异常检测


```ruby
filter {
  # 检测非工作时间的异常活动
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "parsed_time"
    }
    
    # 提取小时信息
    ruby {
      code => "
        hour = event.get('parsed_time').hour
        event.set('hour_of_day', hour)
        
        # 判断是否是工作时间（9:00-18:00）
        if hour < 9 or hour > 18
          event.set('is_off_hours', true)
        else
          event.set('is_off_hours', false)
        end
      "
    }
    
    # 标记非工作时间的敏感操作
    if [is_off_hours] == true and [action] =~ /(?i)(admin|delete|modify)/ {
      mutate {
        add_tag => ["off_hours_activity", "suspicious_timing"]
        add_field => { "anomaly_reason" => "sensitive_operation_off_hours" }
      }
    }
  }
}
```

**📈 异常检测指标**：

```
频率异常：
正常范围：每分钟 < 5次操作
可疑范围：每分钟 5-20次操作  
异常范围：每分钟 > 20次操作

时间异常：
正常时间：工作日 9:00-18:00
可疑时间：工作日 早晚时段
异常时间：深夜、节假日

地理异常：
正常位置：常用办公地点
可疑位置：同城其他区域
异常位置：异国他乡
```

---

## 5. 🎯 攻击模式匹配


### 5.1 Web攻击模式识别


**常见攻击套路**：就像小偷有固定的作案手法

```ruby
filter {
  # SQL注入攻击检测
  if [request_uri] or [post_data] {
    # 检测SQL注入特征
    if [request_uri] =~ /(?i)(union.*select|drop.*table|exec.*xp_|script.*alert)/ {
      mutate {
        add_tag => ["sql_injection", "web_attack"]
        add_field => { 
          "attack_type" => "sql_injection"
          "attack_vector" => "GET_parameter"
        }
      }
    }
    
    # 检测XSS攻击
    if [request_uri] =~ /<script|javascript:|onload=|onerror=/ {
      mutate {
        add_tag => ["xss_attack", "web_attack"]
        add_field => { 
          "attack_type" => "cross_site_scripting"
          "attack_vector" => "reflected_xss"
        }
      }
    }
    
    # 检测目录遍历攻击
    if [request_uri] =~ /\.\.\/|\.\.\\|\/etc\/passwd|\/windows\/system32/ {
      mutate {
        add_tag => ["directory_traversal", "web_attack"]
        add_field => { 
          "attack_type" => "path_traversal"
          "attack_vector" => "file_inclusion"
        }
      }
    }
  }
}
```

### 5.2 网络攻击模式识别


```ruby
filter {
  # 端口扫描检测
  if [destination_port] {
    # 常见扫描端口模式
    if [destination_port] in ["22", "23", "80", "443", "3389", "1433", "3306"] {
      mutate { add_tag => ["common_service_port"] }
    }
    
    # 使用aggregate检测端口扫描（同一IP访问多个端口）
    aggregate {
      task_id => "%{source_ip}_scan_detection"
      code => "
        map['ports'] ||= []
        map['ports'] << event.get('destination_port')
        map['ports'].uniq!
        map['port_count'] = map['ports'].length
        map['source_ip'] = event.get('source_ip')
      "
      push_map_as_event_on_timeout => true
      timeout => 60  # 1分钟窗口
    }
  }
  
  # 判定为端口扫描
  if [port_count] and [port_count] > 5 {
    mutate {
      add_tag => ["port_scan", "network_attack"]
      add_field => { 
        "attack_type" => "port_scanning"
        "scanned_ports" => "%{ports}"
      }
    }
  }
}
```

**🛡️ 攻击模式识别表**：

| 攻击类型 | 特征模式 | 检测方法 | 误报处理 |
|---------|---------|---------|---------|
| SQL注入 | `union select`, `drop table` | 正则匹配 | 白名单过滤 |
| XSS攻击 | `<script>`, `javascript:` | 正则匹配 | 编码检测 |
| 暴力破解 | 高频登录失败 | 频率统计 | 时间窗口 |
| 端口扫描 | 多端口访问 | 聚合分析 | IP白名单 |

---

## 6. ⚡ 风险等级评估


### 6.1 风险评分系统


**评分思路**：像信用评分一样，给每个安全事件打分

```ruby
filter {
  # 初始化风险评分
  mutate { add_field => { "risk_score" => "0" } }
  
  # 基础风险评分
  if "security_event" in [tags] {
    mutate { replace => { "risk_score" => "30" } }
  }
  
  # 威胁情报加分
  if "threat_ip" in [tags] {
    ruby {
      code => "
        current_score = event.get('risk_score').to_i
        event.set('risk_score', current_score + 40)
      "
    }
  }
  
  # 攻击类型加分
  if "sql_injection" in [tags] {
    ruby { code => "event.set('risk_score', event.get('risk_score').to_i + 50)" }
  }
  
  if "xss_attack" in [tags] {
    ruby { code => "event.set('risk_score', event.get('risk_score').to_i + 35)" }
  }
  
  # 异常行为加分
  if "suspicious_frequency" in [tags] {
    ruby { code => "event.set('risk_score', event.get('risk_score').to_i + 25)" }
  }
  
  # 确定风险等级
  ruby {
    code => "
      score = event.get('risk_score').to_i
      if score < 30
        event.set('risk_level', 'low')
        event.set('risk_color', 'green')
      elsif score < 70
        event.set('risk_level', 'medium')
        event.set('risk_color', 'yellow')
      elsif score < 90
        event.set('risk_level', 'high')
        event.set('risk_color', 'orange')
      else
        event.set('risk_level', 'critical')
        event.set('risk_color', 'red')
      end
    "
  }
}
```

### 6.2 上下文风险增强


```ruby
filter {
  # 考虑目标资产的重要性
  if [destination_ip] {
    # 检查是否是核心服务器
    translate {
      source => "destination_ip"
      target => "asset_criticality"
      dictionary_path => "/etc/logstash/asset_inventory.yml"
      fallback => "normal"
    }
    
    # 核心资产风险加权
    if [asset_criticality] == "critical" {
      ruby {
        code => "
          current_score = event.get('risk_score').to_i
          event.set('risk_score', (current_score * 1.5).to_i)
        "
      }
    }
  }
  
  # 考虑用户权限等级
  if [username] {
    translate {
      source => "username"
      target => "user_privilege"
      dictionary_path => "/etc/logstash/user_privileges.yml"
      fallback => "normal"
    }
    
    # 高权限用户异常行为加权
    if [user_privilege] == "admin" and "suspicious" in [tags] {
      ruby {
        code => "
          current_score = event.get('risk_score').to_i
          event.set('risk_score', current_score + 20)
        "
      }
    }
  }
}
```

**📊 风险评分参考表**：

```
基础风险评分：
安全事件基础分：30分
正常业务操作：0分

威胁情报加分：
已知恶意IP：+40分
可疑域名：+30分
恶意文件hash：+50分

攻击类型加分：
SQL注入：+50分
XSS攻击：+35分
暴力破解：+25分
端口扫描：+20分

上下文加权：
核心资产：×1.5倍
管理员账户异常：+20分
非工作时间：+15分
```

---

## 7. 🚨 实时告警触发


### 7.1 分级告警机制


**告警策略**：不同级别的事件，用不同的通知方式

```ruby
filter {
  # 根据风险等级确定告警策略
  if [risk_level] == "critical" {
    mutate {
      add_field => { 
        "alert_required" => "immediate"
        "notification_methods" => "email,sms,phone"
        "escalation_timeout" => "5"  # 5分钟未响应则升级
      }
    }
  } else if [risk_level] == "high" {
    mutate {
      add_field => { 
        "alert_required" => "urgent"
        "notification_methods" => "email,sms"
        "escalation_timeout" => "15"
      }
    }
  } else if [risk_level] == "medium" {
    mutate {
      add_field => { 
        "alert_required" => "normal"
        "notification_methods" => "email"
        "escalation_timeout" => "60"
      }
    }
  }
}
```

### 7.2 告警内容构建


```ruby
filter {
  if [alert_required] {
    # 构建告警标题
    ruby {
      code => "
        severity = event.get('risk_level').upcase
        attack_type = event.get('attack_type') || 'security_event'
        source = event.get('source_ip') || 'unknown'
        
        title = '[#{severity}] #{attack_type.gsub('_', ' ').upcase} detected from #{source}'
        event.set('alert_title', title)
      "
    }
    
    # 构建告警详情
    ruby {
      code => "
        details = []
        details << 'Time: ' + event.get('@timestamp').to_s
        details << 'Source IP: ' + (event.get('source_ip') || 'unknown')
        details << 'Target: ' + (event.get('destination_ip') || 'unknown')
        details << 'Risk Score: ' + event.get('risk_score').to_s
        details << 'Attack Type: ' + (event.get('attack_type') || 'unknown')
        
        if event.get('threat_intel')
          details << 'Threat Intel: ' + event.get('threat_intel')
        end
        
        event.set('alert_details', details.join('\n'))
      "
    }
  }
}
```

### 7.3 告警发送配置


```ruby
output {
  # 关键告警立即发送邮件
  if [alert_required] == "immediate" {
    email {
      to => ["security-team@company.com", "soc-manager@company.com"]
      subject => "[CRITICAL SECURITY ALERT] %{alert_title}"
      body => "
CRITICAL SECURITY EVENT DETECTED

%{alert_details}

Original Message:
%{message}

Please investigate immediately.

Timestamp: %{@timestamp}
Event ID: %{event_id}
      "
      from => "logstash-alerts@company.com"
    }
  }
  
  # 高风险事件发送到安全团队
  if [alert_required] == "urgent" {
    email {
      to => ["security-team@company.com"]
      subject => "[HIGH RISK] %{alert_title}"
      body => "%{alert_details}"
    }
  }
  
  # 所有告警发送到SIEM系统
  if [alert_required] {
    tcp {
      host => "siem.company.local"
      port => 514
      codec => json
    }
  }
}
```

**📱 告警通知渠道**：

```
即时通知渠道：
🔴 Critical: 邮件 + 短信 + 电话
🟠 High: 邮件 + 短信
🟡 Medium: 邮件
🟢 Low: 仅记录日志

通知对象：
• 安全运营团队（SOC）
• 网络管理员
• 应用负责人
• 管理层（Critical事件）
```

---

## 8. 🗄️ 取证数据保留


### 8.1 取证数据分类


**核心思想**：不同类型的安全事件需要保留不同的证据

```ruby
filter {
  if "security_event" in [tags] {
    # 确定需要保留的证据类型
    mutate { add_field => { "evidence_required" => [] } }
    
    # Web攻击需要保留HTTP详情
    if "web_attack" in [tags] {
      mutate { 
        merge => { "evidence_required" => ["http_headers", "request_body", "user_agent"] }
      }
    }
    
    # 登录异常需要保留认证详情
    if "auth_failure" in [tags] {
      mutate { 
        merge => { "evidence_required" => ["auth_method", "session_info", "source_location"] }
      }
    }
    
    # 网络攻击需要保留网络包信息
    if "network_attack" in [tags] {
      mutate { 
        merge => { "evidence_required" => ["packet_size", "tcp_flags", "connection_duration"] }
      }
    }
  }
}
```

### 8.2 证据链完整性


```ruby
filter {
  if "security_event" in [tags] {
    # 生成取证ID
    ruby {
      code => "
        require 'securerandom'
        forensic_id = 'FOR-' + Time.now.strftime('%Y%m%d') + '-' + SecureRandom.hex(4).upcase
        event.set('forensic_id', forensic_id)
      "
    }
    
    # 记录证据链信息
    mutate {
      add_field => {
        "evidence_collected_at" => "%{@timestamp}"
        "evidence_source_system" => "%{host}"
        "evidence_integrity_hash" => ""  # 将在后续步骤中计算
      }
    }
    
    # 计算原始数据的哈希值（确保完整性）
    ruby {
      code => "
        require 'digest'
        original_message = event.get('message').to_s
        hash_value = Digest::SHA256.hexdigest(original_message)
        event.set('evidence_integrity_hash', hash_value)
      "
    }
  }
}
```

### 8.3 长期保存策略


```ruby
output {
  # 高风险事件长期保存（7年）
  if [risk_level] in ["critical", "high"] {
    elasticsearch {
      hosts => ["forensic-storage-cluster:9200"]
      index => "security-forensics-%{+YYYY.MM}"
      template_name => "security-forensics"
      template => "/etc/logstash/templates/forensics-template.json"
      
      # 设置保留策略
      ilm_enabled => true
      ilm_rollover_alias => "security-forensics"
      ilm_pattern => "{now/d}-000001"
      ilm_policy => "forensics-retention-policy"
    }
  }
  
  # 中等风险事件保存1年
  if [risk_level] == "medium" {
    elasticsearch {
      hosts => ["security-logs-cluster:9200"]
      index => "security-events-%{+YYYY.MM}"
      ilm_policy => "security-events-retention"
    }
  }
  
  # 备份到离线存储
  if [risk_level] in ["critical", "high"] {
    file {
      path => "/backup/security-forensics/%{forensic_id}-%{+YYYY-MM-dd}.json"
      codec => json_lines
    }
  }
}
```

**📂 取证数据分类表**：

| 事件类型 | 保留期限 | 存储位置 | 证据内容 |
|---------|---------|---------|---------|
| Critical事件 | 7年 | 专用取证集群 | 完整原始数据 + 分析结果 |
| High事件 | 3年 | 安全日志集群 | 关键字段 + 威胁情报 |
| Medium事件 | 1年 | 普通日志集群 | 基础信息 + 风险评分 |
| Low事件 | 3个月 | 临时存储 | 仅统计信息 |

---

## 9. 📋 合规报告生成


### 9.1 合规框架适配


**常见合规要求**：不同行业有不同的安全合规标准

```ruby
filter {
  if "security_event" in [tags] {
    # 添加合规相关字段
    mutate {
      add_field => {
        "compliance_frameworks" => []
        "compliance_controls" => []
      }
    }
    
    # PCI DSS合规（支付卡行业）
    if [source_ip] =~ /^10\.1\./ or [destination_ip] =~ /^10\.1\./ {
      mutate {
        merge => { "compliance_frameworks" => ["PCI_DSS"] }
        merge => { "compliance_controls" => ["PCI_10.2", "PCI_10.3"] }
      }
    }
    
    # SOX合规（财务系统）
    if [application] == "financial_system" {
      mutate {
        merge => { "compliance_frameworks" => ["SOX"] }
        merge => { "compliance_controls" => ["SOX_IT_CONTROLS"] }
      }
    }
    
    # GDPR合规（个人数据保护）
    if [message] =~ /(?i)(personal|privacy|gdpr)/ {
      mutate {
        merge => { "compliance_frameworks" => ["GDPR"] }
        merge => { "compliance_controls" => ["GDPR_32", "GDPR_33"] }
      }
    }
  }
}
```

### 9.2 报告数据聚合


```ruby
filter {
  # 为合规报告准备聚合数据
  if "security_event" in [tags] {
    # 生成报告周期标识
    ruby {
      code => "
        # 按月分组
        report_month = event.get('@timestamp').strftime('%Y-%m')
        event.set('report_period_month', report_month)
        
        # 按周分组  
        report_week = event.get('@timestamp').strftime('%Y-W%U')
        event.set('report_period_week', report_week)
      "
    }
    
    # 使用aggregate插件收集统计数据
    aggregate {
      task_id => "compliance_stats_%{report_period_month}"
      code => "
        map['total_security_events'] ||= 0
        map['total_security_events'] += 1
        
        # 按风险等级统计
        risk_level = event.get('risk_level') || 'unknown'
        map['by_risk_level'] ||= {}
        map['by_risk_level'][risk_level] ||= 0
        map['by_risk_level'][risk_level] += 1
        
        # 按合规框架统计
        frameworks = event.get('compliance_frameworks') || []
        map['by_compliance'] ||= {}
        frameworks.each do |framework|
          map['by_compliance'][framework] ||= 0
          map['by_compliance'][framework] += 1
        end
        
        map['report_period'] = event.get('report_period_month')
      "
      push_map_as_event_on_timeout => true
      timeout => 86400  # 24小时
      timeout_tags => ["compliance_monthly_stats"]
    }
  }
}
```

### 9.3 自动报告生成


```ruby
output {
  # 生成月度合规报告
  if "compliance_monthly_stats" in [tags] {
    # 发送到报告生成系统
    http {
      url => "http://compliance-reporting.company.local/api/monthly-report"
      http_method => "post"
      content_type => "application/json"
      format => "json"
      headers => {
        "Authorization" => "Bearer ${REPORTING_API_TOKEN}"
      }
    }
    
    # 同时发送邮件给合规团队
    email {
      to => ["compliance@company.com", "risk-management@company.com"]
      subject => "Monthly Security Compliance Report - %{report_period}"
      body => "
Monthly Security Compliance Statistics

Report Period: %{report_period}
Total Security Events: %{total_security_events}

Risk Level Breakdown:
Critical: %{[by_risk_level][critical]}
High: %{[by_risk_level][high]}
Medium: %{[by_risk_level][medium]}
Low: %{[by_risk_level][low]}

Compliance Framework Coverage:
PCI DSS Events: %{[by_compliance][PCI_DSS]}
SOX Events: %{[by_compliance][SOX]}
GDPR Events: %{[by_compliance][GDPR]}

Detailed report available in the compliance dashboard.
      "
    }
  }
}
```

**📊 合规报告内容示例**：

```
月度安全合规报告要素：

统计数据：
• 安全事件总数和趋势
• 风险等级分布
• 响应时间统计
• 误报率分析

合规要求：
• PCI DSS: 日志记录和监控要求
• SOX: IT内控制度执行情况
• GDPR: 数据泄露通知时效
• ISO27001: 安全事件管理流程

改进建议：
• 检测规则优化建议
• 响应流程改进点
• 技术能力提升方向
```

---

## 10. 🔧 完整配置示例


**以下是一个完整的安全日志处理配置文件**：

```ruby
# security-log-pipeline.conf - 安全日志处理完整配置

input {
  # 接收多种安全日志源
  beats {
    port => 5044
    type => "security_logs"
  }
  
  # 防火墙日志
  udp {
    port => 514
    type => "firewall_logs"
  }
  
  # Web访问日志
  file {
    path => "/var/log/nginx/access.log"
    type => "web_access"
    start_position => "end"
  }
}

filter {
  # === 1. 基础数据清理 ===
  if [type] == "security_logs" {
    # 解析时间戳
    date {
      match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss" ]
    }
    
    # 提取基础字段
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:log_level} %{GREEDYDATA:log_message}"
      }
    }
  }
  
  # === 2. 安全事件识别 ===
  # 登录失败检测
  if [log_message] =~ /(?i)(failed|authentication.*failed|invalid.*login)/ {
    mutate {
      add_tag => ["security_event", "auth_failure"]
    }
    
    grok {
      match => { 
        "log_message" => ".*user.?(?<username>\w+).*from.?(?<source_ip>\d+\.\d+\.\d+\.\d+)"
      }
    }
  }
  
  # Web攻击检测
  if [type] == "web_access" {
    grok {
      match => { 
        "message" => "%{COMBINEDAPACHELOG}"
      }
    }
    
    # SQL注入检测
    if [request] =~ /(?i)(union.*select|drop.*table|exec.*xp_)/ {
      mutate {
        add_tag => ["security_event", "sql_injection", "web_attack"]
        add_field => { "attack_type" => "sql_injection" }
      }
    }
    
    # XSS攻击检测
    if [request] =~ /<script|javascript:|onload=/ {
      mutate {
        add_tag => ["security_event", "xss_attack", "web_attack"]
        add_field => { "attack_type" => "cross_site_scripting" }
      }
    }
  }
  
  # === 3. 威胁情报关联 ===
  if [clientip] or [source_ip] {
    # 检查IP威胁情报
    translate {
      source => "[clientip]"
      target => "threat_intel"
      dictionary_path => "/etc/logstash/threat_intel/malicious_ips.yml"
      fallback => "clean"
    }
    
    if [threat_intel] != "clean" {
      mutate {
        add_tag => ["threat_ip"]
        add_field => { "threat_type" => "%{threat_intel}" }
      }
    }
  }
  
  # === 4. 异常行为检测 ===
  if "auth_failure" in [tags] {
    # 统计登录失败频率
    aggregate {
      task_id => "%{source_ip}_login_attempts"
      code => "
        map['attempts'] ||= 0
        map['attempts'] += 1
        map['source_ip'] = event.get('source_ip')
        map['username'] = event.get('username')
      "
      push_map_as_event_on_timeout => true
      timeout => 300  # 5分钟窗口
    }
  }
  
  # 检测暴力破解
  if [attempts] and [attempts] > 5 {
    mutate {
      add_tag => ["brute_force_attack"]
      add_field => { "attack_type" => "brute_force" }
    }
  }
  
  # === 5. 风险评分 ===
  if "security_event" in [tags] {
    mutate { add_field => { "risk_score" => "30" } }
    
    # 威胁IP加分
    if "threat_ip" in [tags] {
      ruby { code => "event.set('risk_score', event.get('risk_score').to_i + 40)" }
    }
    
    # 攻击类型加分
    if "sql_injection" in [tags] {
      ruby { code => "event.set('risk_score', event.get('risk_score').to_i + 50)" }
    }
    
    if "brute_force_attack" in [tags] {
      ruby { code => "event.set('risk_score', event.get('risk_score').to_i + 35)" }
    }
    
    # 确定风险等级
    ruby {
      code => "
        score = event.get('risk_score').to_i
        if score < 40
          event.set('risk_level', 'low')
        elsif score < 70
          event.set('risk_level', 'medium')
        elsif score < 90
          event.set('risk_level', 'high')
        else
          event.set('risk_level', 'critical')
        end
      "
    }
  }
  
  # === 6. 告警准备 ===
  if [risk_level] in ["critical", "high"] {
    mutate {
      add_field => { "alert_required" => "true" }
    }
    
    # 构建告警信息
    ruby {
      code => "
        attack_type = event.get('attack_type') || 'security_event'
        source = event.get('source_ip') || 'unknown'
        severity = event.get('risk_level').upcase
        
        event.set('alert_title', '[#{severity}] #{attack_type} from #{source}')
      "
    }
  }
  
  # === 7. 取证数据准备 ===
  if "security_event" in [tags] {
    ruby {
      code => "
        require 'securerandom'
        forensic_id = 'SEC-' + Time.now.strftime('%Y%m%d') + '-' + SecureRandom.hex(4).upcase
        event.set('forensic_id', forensic_id)
      "
    }
    
    mutate {
      add_field => {
        "evidence_collected_at" => "%{@timestamp}"
        "investigation_status" => "pending"
      }
    }
  }
  
  # === 8. 合规标记 ===
  if "security_event" in [tags] {
    mutate { add_field => { "compliance_frameworks" => [] } }
    
    # 根据不同条件添加合规标记
    if [source_ip] =~ /^10\.1\./ {
      mutate { merge => { "compliance_frameworks" => ["PCI_DSS"] } }
    }
  }
}

output {
  # === 安全事件输出 ===
  if "security_event" in [tags] {
    # 发送到安全信息平台
    elasticsearch {
      hosts => ["security-es-cluster:9200"]
      index => "security-events-%{+YYYY.MM.dd}"
      template_name => "security-events"
    }
    
    # 高风险事件立即告警
    if [risk_level] in ["critical", "high"] {
      email {
        to => ["security-team@company.com"]
        subject => "[SECURITY ALERT] %{alert_title}"
        body => "
Security Event Detected:

Risk Level: %{risk_level}
Attack Type: %{attack_type}
Source IP: %{source_ip}
Target: %{clientip}
Time: %{@timestamp}
Forensic ID: %{forensic_id}

Original Log:
%{message}

Please investigate immediately.
        "
      }
    }
    
    # 发送到SIEM系统
    tcp {
      host => "siem.company.local"
      port => 514
      codec => json
    }
  }
  
  # === 正常日志输出 ===
  if "security_event" not in [tags] {
    elasticsearch {
      hosts => ["general-logs-cluster:9200"]
      index => "general-logs-%{+YYYY.MM.dd}"
    }
  }
  
  # === 调试输出 ===
  if [loglevel] == "debug" {
    stdout { codec => rubydebug }
  }
}
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 安全日志处理目标：快速发现威胁，及时响应，保留证据
🔸 处理流程：收集 → 识别 → 分析 → 评估 → 告警 → 存储
🔸 风险评分：基础分数 + 威胁情报 + 攻击类型 + 上下文
🔸 告警分级：Critical(立即) → High(紧急) → Medium(普通) → Low(记录)
🔸 合规要求：不同行业有不同的日志保留和报告要求
```

### 11.2 关键配置要点


**🔹 事件识别要点**：
```
正确识别：使用精确的正则表达式匹配攻击特征
减少误报：建立白名单机制，排除正常业务操作
完整覆盖：涵盖主要攻击类型和异常行为模式
```

**🔹 性能优化建议**：
```
聚合统计：使用aggregate插件进行时间窗口统计
威胁情报：定期更新恶意IP和域名数据库
索引优化：按时间和风险等级分别建立索引
资源控制：合理设置内存和超时参数
```

**🔹 运维最佳实践**：
```
定期更新：威胁情报库需要定期更新
规则调优：根据误报情况调整检测规则
备份策略：重要安全事件需要多重备份
权限控制：限制配置文件的访问权限
```

### 11.3 实际应用价值


- **威胁发现**：自动识别各种网络安全威胁
- **快速响应**：分钟级别的安全事件通知
- **取证支持**：为安全调查提供完整证据
- **合规满足**：自动生成各种合规报告
- **运营优化**：通过统计分析优化安全策略

**核心记忆口诀**：
- 安全日志要分级，威胁情报来关联
- 异常检测看频率，攻击模式有规律  
- 风险评分综合算，告警分级要及时
- 取证数据长期存，合规报告自动生