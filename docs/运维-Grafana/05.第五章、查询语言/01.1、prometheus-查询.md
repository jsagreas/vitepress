---
title: 1、prometheus-查询
---
## 📚 目录

1. [PromQL基础概念](#1-PromQL基础概念)
2. [指标选择器详解](#2-指标选择器详解)
3. [标签匹配器深入理解](#3-标签匹配器深入理解)
4. [时间范围函数应用](#4-时间范围函数应用)
5. [聚合操作符实战](#5-聚合操作符实战)
6. [数学运算符使用](#6-数学运算符使用)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 PromQL基础概念


### 1.1 什么是PromQL


**🎯 简单理解**
```
PromQL = Prometheus Query Language
就像SQL是查询数据库的语言一样，
PromQL是专门查询监控数据的语言
```

想象一下，你有一个巨大的监控数据仓库，里面存着各种服务器、应用的性能数据。**PromQL就是你和这个仓库对话的工具**，告诉它你想要什么数据，它就给你什么数据。

### 1.2 为什么需要PromQL


**💡 现实场景对比**
```
传统方式：
"我想看CPU使用率" → 需要登录服务器，运行命令，看结果
"我想看昨天的内存使用情况" → 需要翻日志文件

PromQL方式：
"我想看CPU使用率" → cpu_usage
"我想看昨天的内存使用情况" → memory_usage[1d]
```

**🔸 核心优势**
- **统一查询**：所有监控数据用同一种语言查询
- **实时分析**：可以实时计算、聚合、分析数据  
- **灵活过滤**：想看哪台机器、哪个时间段都可以
- **图表展示**：查询结果直接生成图表

### 1.3 PromQL的基本结构


**📋 语法组成**
```
完整的PromQL查询包含：
┌─────────────┐
│   指标名称   │ ← 你要查什么数据
├─────────────┤
│   标签过滤   │ ← 过滤条件
├─────────────┤  
│   时间范围   │ ← 查多长时间的数据
├─────────────┤
│   函数操作   │ ← 对数据做什么处理
└─────────────┘
```

**🌟 基础示例**
```promql
# 最简单的查询 - 查看CPU使用率
cpu_usage

# 带条件的查询 - 查看特定服务器的CPU使用率  
cpu_usage{server="web-01"}

# 带时间范围 - 查看过去5分钟的CPU使用率
cpu_usage{server="web-01"}[5m]

# 带函数计算 - 计算平均CPU使用率
avg(cpu_usage{server="web-01"})
```

---

## 2. 🎯 指标选择器详解


### 2.1 什么是指标选择器


**🔸 通俗解释**
指标选择器就像是**数据的门牌号**，告诉Prometheus你要找哪个指标的数据。

```
现实生活类比：
你去图书馆找书 → 需要书名
你去医院挂号 → 需要科室名
你查监控数据 → 需要指标名

指标选择器 = 监控数据的"身份证"
```

### 2.2 指标选择器的类型


#### 📊 瞬时向量选择器


**定义**：获取某个时间点的数据值

```promql
# 获取当前时刻的CPU使用率
cpu_usage

# 获取当前时刻的内存使用率
memory_usage

# 获取当前时刻HTTP请求数量
http_requests_total
```

**💡 理解要点**
- 瞬时 = 当前这一刻
- 向量 = 一组数据（可能有多台服务器的数据）
- 就像拍照一样，定格某个瞬间的状态

#### 📈 范围向量选择器


**定义**：获取一段时间内的数据序列

```promql
# 获取过去5分钟的CPU数据
cpu_usage[5m]

# 获取过去1小时的内存数据  
memory_usage[1h]

# 获取过去1天的HTTP请求数据
http_requests_total[1d]
```

**🕐 时间单位对照表**
| 单位 | 含义 | 示例 |
|------|------|------|
| `s` | 秒 | `[30s]` = 过去30秒 |
| `m` | 分钟 | `[5m]` = 过去5分钟 |
| `h` | 小时 | `[2h]` = 过去2小时 |
| `d` | 天 | `[1d]` = 过去1天 |
| `w` | 周 | `[1w]` = 过去1周 |
| `y` | 年 | `[1y]` = 过去1年 |

### 2.3 指标选择器实战应用


**🎯 常见使用场景**

```promql
# 场景1：实时监控 - 看当前状态
cpu_usage                    # 当前CPU使用率
memory_usage                 # 当前内存使用率
disk_free                   # 当前磁盘剩余空间

# 场景2：趋势分析 - 看历史变化
cpu_usage[1h]               # 过去1小时CPU变化趋势
http_requests_total[24h]    # 过去24小时请求量变化

# 场景3：问题排查 - 看具体时间段
cpu_usage[5m]               # 过去5分钟是否有异常
error_count[10m]            # 过去10分钟错误数量
```

---

## 3. 🏷️ 标签匹配器深入理解


### 3.1 标签是什么


**🔸 生活化理解**
```
标签就像是给监控数据贴的"便签纸"
每个便签纸上写着这个数据的详细信息

例如：一个CPU使用率数据的标签
┌─────────────────┐
│ server="web-01" │ ← 来自哪台服务器
│ env="production"│ ← 属于什么环境  
│ region="us-east"│ ← 位于哪个地区
│ team="backend"  │ ← 属于哪个团队
└─────────────────┘
```

### 3.2 标签匹配器类型


#### ⚡ 精确匹配


**语法**：`label="value"`

```promql
# 查询web-01服务器的CPU使用率
cpu_usage{server="web-01"}

# 查询生产环境的内存使用率
memory_usage{env="production"}

# 多个条件组合（AND关系）
cpu_usage{server="web-01", env="production"}
```

**💡 理解要点**
- 等号表示"完全相等"
- 区分大小写
- 多个条件之间是"并且"的关系

#### 🚫 不等匹配


**语法**：`label!="value"`

```promql
# 查询除了web-01之外所有服务器的CPU使用率
cpu_usage{server!="web-01"}

# 查询非测试环境的错误数量
error_count{env!="test"}

# 组合使用
cpu_usage{server!="web-01", env!="test"}
```

#### 🔍 正则匹配


**语法**：`label=~"regex"` 和 `label!~"regex"`

```promql
# 查询所有web服务器（web-01, web-02, web-03...）
cpu_usage{server=~"web-.*"}

# 查询生产或预发布环境
memory_usage{env=~"production|staging"}

# 排除所有test开头的服务器
cpu_usage{server!~"test-.*"}
```

**📝 常用正则表达式**
| 表达式 | 含义 | 示例 |
|--------|------|------|
| `.*` | 任意字符 | `web-.*` 匹配 web-01, web-abc |
| `^web` | 以web开头 | `^web` 匹配 web-01, 不匹配 api-web |
| `01$` | 以01结尾 | `01$` 匹配 web-01, 不匹配 web-012 |
| `\|` | 或者关系 | `prod\|test` 匹配 prod 或 test |

### 3.3 标签匹配实战案例


**🎯 实际应用场景**

```promql
# 场景1：按环境查询
cpu_usage{env="production"}              # 只看生产环境
cpu_usage{env=~"production|staging"}     # 看生产+预发布环境

# 场景2：按服务器集群查询  
memory_usage{server=~"web-.*"}           # 所有web服务器
memory_usage{server=~"db-.*"}            # 所有数据库服务器

# 场景3：按地区查询
disk_usage{region="us-east"}             # 美东地区
disk_usage{region=~"us-.*"}              # 所有美国地区

# 场景4：排除特定服务器
cpu_usage{server!~"test-.*"}             # 排除测试服务器
error_count{server!="maintenance"}       # 排除维护中的服务器
```

**⚠️ 新手常见错误**
```promql
❌ 错误写法：
cpu_usage{server=web-01}        # 缺少引号
cpu_usage{server=="web-01"}     # 多了一个等号
cpu_usage{server="Web-01"}      # 大小写错误

✅ 正确写法：
cpu_usage{server="web-01"}      # 标准格式
```

---

## 4. ⏰ 时间范围函数应用


### 4.1 时间范围函数概述


**🔸 为什么需要时间函数**
```
原始数据：一堆散乱的数据点
时间函数：把数据点按时间整理分析

就像整理照片：
- 原始状态：一堆乱七八糟的照片
- 整理后：按时间顺序，还能看出变化趋势
```

### 4.2 常用时间范围函数


#### 📊 rate() - 计算增长率


**作用**：计算计数器指标的每秒增长率

```promql
# 计算HTTP请求的每秒速率
rate(http_requests_total[5m])

# 计算错误的每秒增长率
rate(error_count[10m])
```

**💡 通俗理解**
```
rate函数就像计算"车速"：
- 汽车里程表显示总里程（类似计数器指标）
- rate计算：5分钟跑了多少公里，平均每秒跑多快
- 结果：得到实时的速度信息
```

#### 📈 irate() - 瞬时增长率


**作用**：基于最后两个数据点计算瞬时增长率

```promql
# 计算瞬时HTTP请求速率
irate(http_requests_total[5m])

# 计算瞬时CPU增长率
irate(cpu_usage_total[2m])
```

**🔸 rate vs irate 对比**
| 函数 | 特点 | 适用场景 | 优缺点 |
|------|------|----------|--------|
| `rate()` | 平均增长率 | 长期趋势分析 | 📈 平滑，但反应慢 |
| `irate()` | 瞬时增长率 | 实时监控告警 | ⚡ 敏感，但可能波动大 |

#### 📉 increase() - 计算增长量


**作用**：计算指定时间内的总增长量

```promql
# 计算过去1小时HTTP请求增长量
increase(http_requests_total[1h])

# 计算过去5分钟错误增长量  
increase(error_count[5m])
```

**💡 实际应用**
```
业务场景：
- 今天新增了多少用户？ → increase(user_count[1d])
- 这小时处理了多少订单？ → increase(order_count[1h])
- 过去5分钟有多少报错？ → increase(error_count[5m])
```

### 4.3 时间函数选择指南


**🎯 使用场景决策树**
```
需要看什么？
├── 看总量变化
│   └── 使用 increase()
├── 看平均速率（趋势分析）
│   └── 使用 rate()  
└── 看实时速率（告警监控）
    └── 使用 irate()
```

**📋 实战示例对比**
```promql
# 同样的HTTP请求数据，不同函数的含义：

http_requests_total                    # 累计总请求数
increase(http_requests_total[1h])      # 过去1小时新增请求数
rate(http_requests_total[1h])          # 过去1小时平均每秒请求数
irate(http_requests_total[5m])         # 当前瞬时每秒请求数
```

---

## 5. 🔢 聚合操作符实战


### 5.1 什么是聚合操作


**🔸 生活化理解**
```
聚合操作就像"数据统计员"：
- 原始数据：班级里每个学生的考试成绩
- 聚合操作：计算平均分、最高分、最低分、总分

监控数据也一样：
- 原始数据：每台服务器的CPU使用率
- 聚合操作：计算平均CPU、最高CPU、最低CPU
```

### 5.2 基础聚合操作符


#### 📊 sum() - 求和


**作用**：把所有数值加起来

```promql
# 计算所有服务器总CPU使用量
sum(cpu_usage)

# 计算所有web服务器总内存使用量
sum(memory_usage{server=~"web-.*"})
```

**💡 应用场景**
- **资源总量**：整个集群用了多少CPU/内存
- **业务总量**：今天总共处理了多少订单
- **流量总和**：所有API接口的总请求量

#### 📈 avg() - 求平均值


**作用**：计算所有数值的平均值

```promql
# 计算所有服务器平均CPU使用率
avg(cpu_usage)

# 计算数据库集群平均响应时间
avg(db_response_time{service="database"})
```

**🎯 业务意义**
- **性能基线**：系统平均负载水平
- **容量规划**：需要多少资源
- **异常检测**：某台机器是否偏离平均值

#### 🔺 max() / 🔻 min() - 最大值/最小值


```promql
# 找出CPU使用率最高的服务器数值
max(cpu_usage)

# 找出内存使用率最低的服务器数值  
min(memory_usage)

# 找出响应时间最长的API
max(api_response_time)
```

**⚠️ 重要提醒**
```
max(cpu_usage) 只告诉你最大值是多少
但不告诉你是哪台服务器！

如果想知道是哪台服务器：
max(cpu_usage) by (server)  # 按服务器分组求最大值
```

#### 📋 count() - 计数


**作用**：统计有多少个数据点

```promql
# 统计当前在线的服务器数量
count(up)

# 统计CPU使用率超过80%的服务器数量
count(cpu_usage > 0.8)

# 统计有错误的API接口数量
count(error_rate > 0)
```

### 5.3 分组聚合


#### 🏷️ by() - 按标签分组


**语法**：`聚合函数(指标) by (标签名)`

```promql
# 按环境分组计算平均CPU
avg(cpu_usage) by (env)

# 按服务器分组计算总内存使用
sum(memory_usage) by (server)

# 按地区分组计算最大响应时间
max(api_response_time) by (region)
```

**📊 结果示例**
```
查询：avg(cpu_usage) by (env)
结果：
{env="production"} 0.75    # 生产环境平均CPU 75%
{env="staging"}    0.45    # 预发布环境平均CPU 45%  
{env="test"}       0.20    # 测试环境平均CPU 20%
```

#### 🚫 without() - 排除标签分组


**语法**：`聚合函数(指标) without (标签名)`

```promql
# 计算总CPU使用率，不区分服务器
sum(cpu_usage) without (server)

# 计算平均响应时间，不区分具体API路径
avg(api_response_time) without (path)
```

### 5.4 聚合操作实战案例


**🎯 监控场景应用**

```promql
# 场景1：集群整体健康监控
avg(cpu_usage)                        # 集群平均CPU使用率
sum(memory_usage)                     # 集群总内存使用量
count(up == 0)                        # 离线服务器数量

# 场景2：环境对比分析
avg(cpu_usage) by (env)               # 各环境CPU使用率对比
sum(http_requests_total) by (env)     # 各环境请求量对比

# 场景3：异常检测告警
count(cpu_usage > 0.8)                # CPU使用率超80%的服务器数
max(memory_usage) by (server)         # 每台服务器的最大内存使用率
```

**💡 组合使用技巧**
```promql
# 计算CPU使用率超过80%的服务器占比
count(cpu_usage > 0.8) / count(cpu_usage) * 100

# 找出响应时间最慢的前3个API
topk(3, max(api_response_time) by (endpoint))
```

---

## 6. ➕ 数学运算符使用


### 6.1 数学运算符概述


**🔸 为什么需要数学运算**
```
监控数据经常需要计算：
- CPU使用率 = 已使用CPU / 总CPU * 100
- 错误率 = 错误数量 / 总请求数 * 100  
- 剩余内存 = 总内存 - 已使用内存

PromQL支持这些计算，让你直接得到想要的结果
```

### 6.2 基础数学运算符


#### ➕ 加法运算 (+)


```promql
# 计算总内存使用量（缓存+应用）
memory_cache + memory_app

# 计算总网络流量（入站+出站）
network_in + network_out

# 给CPU使用率加个固定值
cpu_usage + 0.1
```

#### ➖ 减法运算 (-)


```promql
# 计算剩余内存
memory_total - memory_used

# 计算可用磁盘空间
disk_total - disk_used

# 计算成功请求数（总数-错误数）
http_requests_total - http_errors_total
```

#### ✖️ 乘法运算 (*)


```promql
# 将小数转换为百分比
cpu_usage * 100

# 计算每秒字节数转换为MB
network_bytes * 8 / 1024 / 1024

# 计算预估的每日请求量
rate(http_requests_total[1h]) * 24 * 3600
```

#### ➗ 除法运算 (/)


```promql
# 计算错误率（百分比）
http_errors_total / http_requests_total * 100

# 计算内存使用率
memory_used / memory_total * 100

# 计算平均响应时间
response_time_sum / response_time_count
```

### 6.3 比较运算符


**🔍 常用比较运算符**
| 运算符 | 含义 | 示例 | 说明 |
|--------|------|------|------|
| `==` | 等于 | `cpu_usage == 0.5` | CPU使用率等于50% |
| `!=` | 不等于 | `cpu_usage != 0` | CPU使用率不为0 |
| `>` | 大于 | `cpu_usage > 0.8` | CPU使用率大于80% |
| `<` | 小于 | `memory_free < 1000` | 剩余内存小于1GB |
| `>=` | 大于等于 | `disk_usage >= 0.9` | 磁盘使用率大于等于90% |
| `<=` | 小于等于 | `response_time <= 100` | 响应时间小于等于100ms |

### 6.4 实战计算案例


**📊 常见监控计算**

```promql
# 计算资源使用率
cpu_usage_ratio = cpu_used / cpu_total * 100
memory_usage_ratio = memory_used / memory_total * 100
disk_usage_ratio = disk_used / disk_total * 100

# 计算业务指标
error_rate = error_count / total_requests * 100
success_rate = success_count / total_requests * 100
qps = rate(http_requests_total[1m])

# 计算容量预估
daily_requests = rate(http_requests_total[1h]) * 24 * 3600
monthly_storage = rate(data_size[1d]) * 30
```

**🎯 告警条件设置**

```promql
# CPU使用率告警（超过80%）
cpu_usage > 0.8

# 内存不足告警（剩余小于1GB）
memory_total - memory_used < 1024*1024*1024

# 错误率告警（超过5%）
error_count / total_requests * 100 > 5

# 响应时间告警（超过500ms）
avg(response_time) > 500
```

**💡 复杂计算示例**

```promql
# 计算服务器负载综合指数
(cpu_usage * 0.4 + memory_usage * 0.3 + disk_usage * 0.3) * 100

# 计算API性能得分
100 - (response_time / 1000 * 50 + error_rate * 100)

# 计算预计剩余存储时间（天）
(disk_total - disk_used) / rate(disk_used[1d]) / 86400
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 PromQL本质：专门查询监控数据的语言，就像SQL查数据库
🔸 指标选择器：数据的"身份证"，告诉Prometheus你要什么数据
🔸 标签匹配器：数据的"过滤条件"，精确找到你需要的数据
🔸 时间范围函数：处理时间序列数据，计算增长率和趋势
🔸 聚合操作符：对多个数据点进行统计计算
🔸 数学运算符：对数据进行数学计算和比较
```

### 7.2 关键理解要点


**🔹 选择器的使用场景**
```
瞬时选择器 → 看当前状态，实时监控
范围选择器 → 看历史趋势，问题分析

记忆方法：
瞬时 = 拍照（当前状态）
范围 = 录像（一段时间的变化）
```

**🔹 标签匹配的技巧**
```
精确匹配 → 明确知道具体值时使用
正则匹配 → 批量匹配类似的标签
组合使用 → 多个条件同时满足

实用技巧：
先用宽泛条件查看有哪些数据
再用精确条件筛选需要的数据
```

**🔹 时间函数的选择**
```
rate() → 看平均趋势，适合容量规划
irate() → 看实时变化，适合告警监控  
increase() → 看总量变化，适合业务统计

选择原则：
告警用irate，分析用rate，统计用increase
```

### 7.3 实际应用指导


**💻 监控看板常用查询**
```promql
# 系统资源监控
CPU使用率: cpu_usage * 100
内存使用率: memory_used / memory_total * 100
磁盘使用率: disk_used / disk_total * 100

# 应用性能监控
请求速率: rate(http_requests_total[5m])
错误率: rate(http_errors_total[5m]) / rate(http_requests_total[5m]) * 100
响应时间: avg(response_time)

# 业务指标监控
在线用户: count(user_online)
订单量: increase(orders_total[1h])
收入: sum(revenue)
```

**🚨 告警规则示例**
```promql
# 系统告警
CPU过高: avg(cpu_usage) > 0.8
内存不足: (memory_total - memory_used) / memory_total < 0.1
磁盘空间不足: disk_used / disk_total > 0.9

# 应用告警  
请求量异常: rate(http_requests_total[5m]) > 1000
错误率过高: rate(http_errors_total[5m]) / rate(http_requests_total[5m]) > 0.05
响应时间过长: avg(response_time) > 500
```

### 7.4 新手学习路径


**📚 学习步骤建议**
```
第1步：熟悉基础语法
├── 掌握指标选择器的使用
├── 理解标签匹配的概念
└── 练习简单的查询语句

第2步：掌握时间处理
├── 理解瞬时vs范围选择器
├── 掌握rate、irate、increase函数
└── 学会时间范围的指定

第3步：学会数据分析
├── 掌握聚合操作符（sum、avg、max等）
├── 学会分组查询（by、without）
└── 练习复杂的统计计算

第4步：实战应用
├── 设计监控看板查询
├── 编写告警规则
└── 优化查询性能
```

**🎯 练习建议**
- **从简单开始**：先查单个指标，再加条件
- **多做对比**：同一个指标用不同函数处理，看区别
- **结合业务**：根据实际监控需求设计查询
- **关注性能**：避免查询时间范围过大，影响性能

**核心记忆**：
- PromQL是监控数据的查询语言
- 指标+标签+时间+函数=完整查询
- 选择器定位数据，函数处理数据，运算符计算结果
- 实时用irate，趋势用rate，统计用increase
- 分组聚合解决"按什么维度统计"的问题