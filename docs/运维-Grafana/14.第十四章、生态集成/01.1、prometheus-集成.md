---
title: 1、prometheus-集成
---
## 📚 目录

1. [Prometheus + Grafana监控组合](#1-prometheus--grafana监控组合)
2. [架构设计与工作原理](#2-架构设计与工作原理)
3. [Node Exporter指标收集](#3-node-exporter指标收集)
4. [常用监控指标详解](#4-常用监控指标详解)
5. [AlertManager告警集成](#5-alertmanager告警集成)
6. [监控栈配置实战](#6-监控栈配置实战)
7. [最佳实践与优化](#7-最佳实践与优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ Prometheus + Grafana监控组合


### 1.1 什么是监控组合


**💡 核心理解**
> Prometheus + Grafana就像是一个完整的监控"套餐"：
> - **Prometheus**：负责收集和存储监控数据（像数据仓库）
> - **Grafana**：负责展示和分析数据（像数据分析师）
> - 两者配合，实现完整的监控解决方案

**🎯 为什么要组合使用**

```
单独使用的问题：
┌─────────────────┐    ┌─────────────────┐
│   只用Prometheus │    │   只用Grafana   │
├─────────────────┤    ├─────────────────┤
│ ✅ 数据收集强大    │    │ ✅ 图表展示美观    │
│ ❌ 界面简陋难用    │    │ ❌ 需要外部数据源  │
│ ❌ 图表功能有限    │    │ ❌ 本身不收集数据  │
└─────────────────┘    └─────────────────┘

组合使用的优势：
┌─────────────────────────────────────┐
│        Prometheus + Grafana         │
├─────────────────────────────────────┤
│ ✅ 强大的数据收集 + 美观的图表展示      │
│ ✅ 丰富的告警功能 + 灵活的仪表板       │
│ ✅ 完整的监控解决方案                │
└─────────────────────────────────────┘
```

### 1.2 应用场景解析


**🏢 企业级监控**
```
服务器监控：
- CPU、内存、磁盘使用情况
- 网络流量、连接数统计
- 系统负载、进程状态

应用监控：
- Web服务响应时间
- 数据库连接池状态
- 业务指标统计

基础设施监控：
- 网络设备状态
- 存储系统性能
- 容器集群监控
```

**📊 监控数据流转过程**
```
数据来源 → Prometheus → Grafana → 用户
    ↓           ↓          ↓        ↓
  服务器    →   收集存储   →  图表展示  →  决策分析
  应用       →   计算聚合   →  告警通知  →  问题处理
  设备       →   历史数据   →  趋势分析  →  容量规划
```

---

## 2. 🔧 架构设计与工作原理


### 2.1 整体架构设计


**🏗️ 监控架构图**
```
┌─────────────────────────────────────────────────────────┐
│                    监控架构全景                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  被监控目标   │    │  数据采集层   │    │  数据存储层   │  │
│  ├─────────────┤    ├─────────────┤    ├─────────────┤  │
│  │ Web服务器    │───▶│ Node Exporter│───▶│ Prometheus  │  │
│  │ 数据库服务    │───▶│ MySQL Export │───▶│ 时序数据库    │  │
│  │ 应用程序     │───▶│ App Metrics  │───▶│ 数据聚合     │  │
│  └─────────────┘    └─────────────┘    └─────────────┘  │
│          ▲                                    │        │
│          │           ┌─────────────┐         │        │
│          │           │  展示分析层   │         │        │
│          │           ├─────────────┤         ▼        │
│          │           │  Grafana    │◀────────┘        │
│          │           │  仪表板     │                  │
│          │           │  图表可视化   │                  │
│          │           └─────────────┘                  │
│          │                   │                       │
│          │           ┌─────────────┐                  │
│          └───────────│ AlertManager│                  │
│                      ├─────────────┤                  │
│                      │ 告警规则     │                  │
│                      │ 通知发送     │                  │
│                      └─────────────┘                  │
└─────────────────────────────────────────────────────────┘
```

### 2.2 数据流工作原理


**🔄 数据采集流程**
```
步骤1：数据暴露
服务器/应用 → 暴露metrics端点 → HTTP接口(/metrics)

步骤2：数据拉取  
Prometheus → 定时拉取 → 解析指标数据 → 存储到时序数据库

步骤3：数据查询
Grafana → PromQL查询 → 获取指标数据 → 渲染图表

步骤4：告警处理
Prometheus → 规则评估 → 触发告警 → AlertManager → 发送通知
```

**⏰ 时间维度说明**
> **📌 重要概念**：时序数据库
> 
> 普通数据库存储：姓名=张三，年龄=25
> 时序数据库存储：CPU使用率在14:30:00时是75%，在14:30:15时是80%
> 
> 时序数据的特点是每个数据点都有时间戳，可以看到指标随时间的变化趋势

### 2.3 组件角色分工


| 组件 | 主要职责 | 就像现实中的 | 具体功能 |
|------|----------|-------------|----------|
| **Exporter** | `数据采集员` | 调查员 | 从各种系统收集指标数据 |
| **Prometheus** | `数据管理员` | 档案管理员 | 存储、查询、计算监控数据 |
| **Grafana** | `数据分析师` | 图表专家 | 将数据制作成各种图表和仪表板 |
| **AlertManager** | `警报员` | 保安 | 监控异常情况并及时通知相关人员 |

---

## 3. 📊 Node Exporter指标收集


### 3.1 Node Exporter概述


**🔍 什么是Node Exporter**
> Node Exporter就像给服务器安装了一个"体检仪"，它会持续监测服务器的各种"生命体征"：
> - CPU是否过热（CPU使用率）
> - 内存是否不够用（内存使用情况）  
> - 硬盘是否快满了（磁盘空间）
> - 网络是否拥堵（网络流量）

**📋 安装和启动**
```bash
# 下载Node Exporter
wget https://github.com/prometheus/node_exporter/releases/download/v1.6.1/node_exporter-1.6.1.linux-amd64.tar.gz

# 解压并启动
tar xvfz node_exporter-*.tar.gz
cd node_exporter-*
./node_exporter
```

### 3.2 核心指标类别


**💻 CPU相关指标**
```
主要指标说明：
node_cpu_seconds_total：CPU时间统计
├── mode="idle"     → 空闲时间（越高越好）
├── mode="user"     → 用户程序使用时间  
├── mode="system"   → 系统内核使用时间
└── mode="iowait"   → 等待IO操作时间（高了说明磁盘慢）

实际含义：
- idle高：服务器很闲，性能充足
- user高：用户程序在努力工作
- system高：系统内核很忙，可能有问题
- iowait高：磁盘成为瓶颈
```

**🧠 内存相关指标**
```
内存使用情况：
node_memory_MemTotal_bytes     → 总内存大小
node_memory_MemFree_bytes      → 空闲内存
node_memory_MemAvailable_bytes → 可用内存（包括缓存）
node_memory_Buffers_bytes      → 缓冲区内存
node_memory_Cached_bytes       → 缓存内存

理解要点：
总内存 = 已用内存 + 空闲内存 + 缓存内存
实际可用 = 空闲内存 + 可回收的缓存内存
```

**💾 磁盘相关指标**
```
磁盘空间：
node_filesystem_size_bytes     → 文件系统总大小
node_filesystem_free_bytes     → 空闲空间
node_filesystem_avail_bytes    → 可用空间

磁盘IO：
node_disk_read_bytes_total     → 累计读取字节数
node_disk_written_bytes_total  → 累计写入字节数
node_disk_io_time_seconds_total → IO等待时间
```

### 3.3 指标计算技巧


**📈 CPU使用率计算**
```
PromQL查询语句：
100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

解释：
1. node_cpu_seconds_total{mode="idle"} → 获取空闲时间
2. irate(...[5m]) → 计算5分钟内的变化率
3. avg by (instance) → 按服务器实例求平均
4. 100 - (...) * 100 → 用100%减去空闲率得到使用率
```

**💡 记忆技巧**
> **CPU使用率 = 100% - 空闲率**
> 就像一天24小时，如果睡觉8小时，那么工作时间就是16小时
> 工作率 = (24-8)/24 = 67%

---

## 4. 📈 常用监控指标详解


### 4.1 系统性能指标


**⚡ 系统负载指标**
```
系统负载说明：
node_load1    → 1分钟平均负载
node_load5    → 5分钟平均负载  
node_load15   → 15分钟平均负载

负载理解：
┌─────────────────────────────────┐
│         系统负载就像交通流量        │
├─────────────────────────────────┤
│ 负载1.0  → 道路刚好饱和（1核CPU）  │
│ 负载2.0  → 道路拥堵（4核CPU时还好） │
│ 负载0.5  → 道路很通畅            │
└─────────────────────────────────┘

判断标准：
- 负载 < 核心数：正常
- 负载 = 核心数：满载但不拥堵  
- 负载 > 核心数：过载需要关注
```

**🌐 网络流量指标**
```
网络接口流量：
node_network_receive_bytes_total   → 接收字节总数
node_network_transmit_bytes_total  → 发送字节总数

网络错误统计：
node_network_receive_errs_total    → 接收错误数
node_network_transmit_errs_total   → 发送错误数

实时速率计算：
rate(node_network_receive_bytes_total[5m]) → 接收速率（字节/秒）
rate(node_network_transmit_bytes_total[5m]) → 发送速率（字节/秒）
```

### 4.2 应用层监控指标


**🌐 HTTP服务指标**
```
常见Web指标：
http_requests_total               → HTTP请求总数
http_request_duration_seconds     → 请求响应时间
http_requests_in_flight_gauge     → 正在处理的请求数

响应码统计：
http_requests_total{code="200"}   → 成功请求数
http_requests_total{code="404"}   → 404错误数  
http_requests_total{code="500"}   → 服务器错误数

性能计算：
rate(http_requests_total[5m])     → 每秒请求数（QPS）
avg(http_request_duration_seconds) → 平均响应时间
```

**📊 业务指标示例**
```
电商网站监控：
- 用户注册数：user_registrations_total
- 订单创建数：orders_created_total  
- 支付成功率：payments_success_rate
- 商品库存数：product_inventory_gauge

游戏服务器监控：
- 在线用户数：online_users_gauge
- 游戏场次数：game_sessions_total
- 平均延迟：game_latency_seconds
- 掉线率：disconnection_rate
```

### 4.3 指标类型说明


**📋 Prometheus指标类型**

| 类型 | 说明 | 特点 | 应用场景 | 示例 |
|------|------|------|----------|------|
| **Counter** | `计数器` | 只增不减 | 累计统计 | 请求总数、错误总数 |
| **Gauge** | `仪表盘` | 可增可减 | 当前状态 | CPU使用率、内存使用量 |
| **Histogram** | `直方图` | 分布统计 | 性能分析 | 响应时间分布 |
| **Summary** | `摘要` | 分位数统计 | 性能总结 | 99%分位响应时间 |

**💡 类型选择技巧**
> - **计数问题用Counter**：总共处理了多少个请求？
> - **状态问题用Gauge**：当前CPU使用率是多少？
> - **分布问题用Histogram**：响应时间都分布在哪些区间？
> - **分位数问题用Summary**：99%的请求响应时间在多少以下？

---

## 5. 🚨 AlertManager告警集成


### 5.1 告警系统概述


**🔔 告警机制原理**
```
告警流程图：
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│  Prometheus  │    │ AlertManager │    │   通知渠道    │
├──────────────┤    ├──────────────┤    ├──────────────┤
│ 监控指标数据  │───▶│ 告警规则评估  │───▶│ 邮件/短信/钉钉 │
│ 告警规则配置  │    │ 告警分组聚合  │    │ Slack/微信   │
│ 定时触发检查  │    │ 静默期管理   │    │ 电话/Webhook │
└──────────────┘    └──────────────┘    └──────────────┘
```

**⚠️ 告警规则配置**
```yaml
# prometheus.yml告警规则配置
rule_files:
  - "alert_rules.yml"

# alert_rules.yml文件内容
groups:
  - name: server_alerts
    rules:
      # CPU使用率过高告警
      - alert: HighCpuUsage
        expr: 100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "服务器CPU使用率过高"
          description: "服务器 {{ $labels.instance }} CPU使用率已达到 {{ $value }}%"
```

### 5.2 常用告警规则


**🔥 系统资源告警**
```yaml
# CPU使用率告警
- alert: HighCpuUsage
  expr: cpu_usage > 80
  for: 5m
  annotations:
    summary: "CPU使用率超过80%"

# 内存使用率告警  
- alert: HighMemoryUsage
  expr: memory_usage > 90
  for: 3m
  annotations:
    summary: "内存使用率超过90%"

# 磁盘空间告警
- alert: DiskSpaceLow
  expr: disk_free_percent < 10
  for: 1m
  annotations:
    summary: "磁盘剩余空间不足10%"

# 服务器宕机告警
- alert: InstanceDown
  expr: up == 0
  for: 1m
  annotations:
    summary: "服务器无法连接"
```

**📱 应用服务告警**
```yaml
# HTTP错误率过高
- alert: HighErrorRate
  expr: rate(http_requests_total{code=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.1
  for: 2m
  annotations:
    summary: "HTTP 5xx错误率超过10%"

# 响应时间过长
- alert: HighResponseTime
  expr: avg(http_request_duration_seconds) > 2
  for: 3m
  annotations:
    summary: "平均响应时间超过2秒"

# 数据库连接失败
- alert: DatabaseDown
  expr: mysql_up == 0
  for: 30s
  annotations:
    summary: "数据库连接失败"
```

### 5.3 AlertManager配置


**📧 通知渠道配置**
```yaml
# alertmanager.yml配置文件
global:
  smtp_smarthost: 'smtp.qq.com:587'
  smtp_from: 'monitor@example.com'

route:
  group_by: ['alertname']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'default'

receivers:
  - name: 'default'
    email_configs:
      - to: 'admin@example.com'
        subject: '告警通知: {{ .GroupLabels.alertname }}'
        body: |
          告警详情：
          {{ range .Alerts }}
          - 告警名称: {{ .Annotations.summary }}
          - 告警描述: {{ .Annotations.description }}
          - 开始时间: {{ .StartsAt }}
          {{ end }}
```

**📲 多渠道通知配置**
```yaml
receivers:
  # 邮件通知
  - name: 'email-alerts'
    email_configs:
      - to: 'ops@example.com'
        
  # 钉钉通知
  - name: 'dingtalk-alerts'
    webhook_configs:
      - url: 'https://oapi.dingtalk.com/robot/send?access_token=YOUR_TOKEN'
        
  # Slack通知
  - name: 'slack-alerts'
    slack_configs:
      - api_url: 'YOUR_SLACK_WEBHOOK_URL'
        channel: '#alerts'
```

---

## 6. ⚙️ 监控栈配置实战


### 6.1 完整部署配置


**🐳 Docker Compose部署**
```yaml
version: '3.8'
services:
  # Prometheus服务
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - ./alert_rules.yml:/etc/prometheus/alert_rules.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'

  # Grafana服务
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
    volumes:
      - grafana-storage:/var/lib/grafana

  # AlertManager服务
  alertmanager:
    image: prom/alertmanager:latest
    ports:
      - "9093:9093"
    volumes:
      - ./alertmanager.yml:/etc/alertmanager/alertmanager.yml

  # Node Exporter服务
  node-exporter:
    image: prom/node-exporter:latest
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro

volumes:
  grafana-storage:
```

### 6.2 Prometheus配置详解


**📝 prometheus.yml核心配置**
```yaml
global:
  scrape_interval: 15s          # 数据采集间隔
  evaluation_interval: 15s      # 规则评估间隔

# 告警规则文件
rule_files:
  - "alert_rules.yml"

# AlertManager配置
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

# 数据采集目标配置
scrape_configs:
  # Prometheus自监控
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # Node Exporter采集
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']
    scrape_interval: 10s
    metrics_path: /metrics

  # 应用程序采集
  - job_name: 'web-app'
    static_configs:
      - targets: ['app1:8080', 'app2:8080']
    metrics_path: /actuator/prometheus
```

### 6.3 Grafana数据源配置


**🔗 添加Prometheus数据源**
```
配置步骤：
1. 登录Grafana (http://localhost:3000)
2. 进入Configuration → Data Sources
3. 点击"Add data source"
4. 选择Prometheus
5. 配置URL: http://prometheus:9090
6. 点击"Save & Test"

连接参数：
Name: Prometheus
Type: Prometheus  
URL: http://prometheus:9090
Access: Server (default)
```

**📊 导入监控仪表板**
```
推荐仪表板ID：
- Node Exporter仪表板: 1860
- MySQL监控仪表板: 7362
- Redis监控仪表板: 763
- Nginx监控仪表板: 9614

导入步骤：
1. 点击"+" → Import
2. 输入仪表板ID
3. 选择Prometheus数据源
4. 调整配置并保存
```

---

## 7. 🎯 最佳实践与优化


### 7.1 监控策略最佳实践


**📈 监控层次设计**
```
┌─────────────────────────────────────────────┐
│              监控金字塔                      │
├─────────────────────────────────────────────┤
│                                             │
│  ┌─────────────────────────────────────┐    │
│  │          业务监控（顶层）            │    │
│  │  • 用户体验指标                    │    │
│  │  • 业务关键指标                    │    │
│  │  • 收入相关指标                    │    │
│  └─────────────────────────────────────┘    │
│          ┌─────────────────────────────┐    │
│          │        应用监控（中层）      │    │
│          │  • 接口响应时间             │    │
│          │  • 错误率统计               │    │
│          │  • 吞吐量监控               │    │
│          └─────────────────────────────┘    │
│              ┌─────────────────────────┐    │
│              │      基础设施监控（底层） │    │
│              │  • CPU、内存、磁盘      │    │
│              │  • 网络、IO性能        │    │
│              │  • 系统资源状态        │    │
│              └─────────────────────────┘    │
└─────────────────────────────────────────────┘
```

**⚡ 性能优化技巧**

> **📌 数据保留策略**
> ```yaml
> # Prometheus存储配置
> global:
>   external_labels:
>     monitor: 'production'
> 
> # 数据保留期设置
> storage:
>   tsdb:
>     retention.time: 30d    # 保留30天数据
>     retention.size: 10GB   # 最大存储10GB
> ```

**🔧 查询优化建议**
```
PromQL查询优化：

❌ 低效查询：
rate(http_requests_total[1m])  # 查询窗口太小

✅ 优化查询：  
rate(http_requests_total[5m])  # 合适的查询窗口

❌ 资源消耗大：
avg_over_time(cpu_usage[1d])   # 时间窗口太大

✅ 分级聚合：
avg_over_time(cpu_usage[1h])   # 先小窗口聚合，再长期分析
```

### 7.2 告警策略优化


**🎛️ 告警分级策略**
```
告警严重性分级：
┌─────────────────┬─────────────────┬─────────────────┐
│   严重级别       │     触发条件     │     处理方式     │
├─────────────────┼─────────────────┼─────────────────┤
│ 🔴 Critical     │ 服务完全不可用    │ 立即电话通知     │
│ 🟠 Warning      │ 性能显著下降     │ 邮件+短信通知    │
│ 🟡 Info         │ 资源使用偏高     │ 邮件通知        │
│ 🟢 Debug        │ 开发调试信息     │ 仅记录日志      │
└─────────────────┴─────────────────┴─────────────────┘
```

**🔕 告警疲劳预防**
```yaml
# 告警聚合配置
route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: 30s       # 等待30秒聚合同类告警
  group_interval: 5m    # 聚合间隔5分钟
  repeat_interval: 4h   # 重复通知间隔4小时

# 静默期配置
inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'instance']
```

### 7.3 容量规划指导


**📊 资源需求评估**
```
Prometheus资源需求：
CPU需求 = 采集目标数 × 指标数量 × 采集频率
内存需求 = 活跃时间序列数 × 2KB
存储需求 = 指标数 × 采集频率 × 保留时间 × 压缩比

示例计算：
- 监控目标：100台服务器
- 平均指标：1000个/台  
- 采集间隔：15秒
- 保留时间：30天

存储需求 ≈ 100 × 1000 × (86400/15) × 30 × 0.5 = 8.6GB
```

**🔄 扩展性设计**
```
监控系统扩展策略：

水平扩展：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Prometheus1 │    │ Prometheus2 │    │ Prometheus3 │
│  (Web服务)   │    │  (数据库)    │    │  (基础设施)  │
└─────────────┘    └─────────────┘    └─────────────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                  ┌─────────────┐
                  │  Grafana    │
                  │  (联邦查询)  │
                  └─────────────┘

垂直扩展：
- 增加CPU核心数（提升查询性能）
- 增加内存容量（支持更多时间序列）
- 使用SSD存储（提升IO性能）
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Prometheus + Grafana：完整监控解决方案的黄金组合
🔸 Node Exporter：系统指标收集的核心工具
🔸 PromQL语言：查询和计算监控指标的专用语言
🔸 AlertManager：智能告警管理和通知分发系统
🔸 时序数据库：专门存储带时间戳监控数据的数据库
```

### 8.2 关键理解要点


**🔹 监控数据流理解**
```
数据采集 → 数据存储 → 数据查询 → 数据展示 → 告警处理
    ↓         ↓         ↓         ↓         ↓
 Exporter → Prometheus → PromQL → Grafana → AlertManager
```

**🔹 指标类型选择**
```
计数累计用Counter：请求总数、错误总数
当前状态用Gauge：CPU使用率、内存使用量  
分布分析用Histogram：响应时间分布
分位统计用Summary：99%分位响应时间
```

**🔹 告警设计原则**
```
分级告警：不同严重程度不同处理方式
避免疲劳：合理设置阈值和通知频率
快速定位：告警信息要包含足够的上下文
可操作性：告警要给出明确的处理建议
```

### 8.3 实际应用价值


**🎯 业务场景应用**
- **运维监控**：全面监控系统健康状态，及时发现问题
- **性能优化**：通过监控数据分析性能瓶颈和优化方向
- **容量规划**：基于历史趋势预测资源需求和扩容时机
- **故障诊断**：快速定位故障原因和影响范围

**🔧 实施建议**
- **循序渐进**：先搭建基础监控，再逐步完善应用监控
- **重点突出**：优先监控核心业务指标和关键基础设施
- **持续优化**：根据实际使用情况调整监控策略和告警规则
- **文档管理**：建立监控文档和操作手册，便于团队使用

**核心记忆口诀**：
- **Prometheus收集存，Grafana展示美**
- **Exporter把数据采，AlertManager来告警**  
- **指标类型要选对，告警规则设计好**
- **监控不是为监控，业务价值最重要**