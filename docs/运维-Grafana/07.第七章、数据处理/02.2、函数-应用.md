---
title: 2、函数-应用
---
## 📚 目录

1. [函数概述与基础理解](#1-函数概述与基础理解)
2. [数学函数详解与应用](#2-数学函数详解与应用)
3. [聚合函数的实战运用](#3-聚合函数的实战运用)
4. [时间函数处理技巧](#4-时间函数处理技巧)
5. [字符串处理函数应用](#5-字符串处理函数应用)
6. [条件函数与逻辑控制](#6-条件函数与逻辑控制)
7. [自定义计算与组合应用](#7-自定义计算与组合应用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧮 函数概述与基础理解


### 1.1 什么是Grafana函数


**🔸 简单理解**
```
想象函数就像数学课上的计算器：
• 输入：原始监控数据（比如CPU使用率）
• 处理：通过函数进行计算转换
• 输出：我们想要的结果（比如平均值、最大值）

生活类比：
原始数据 → 食材
函数     → 厨师的烹饪技巧  
结果     → 美味的菜肴
```

**💡 函数的核心作用**
- **数据转换**：把复杂的原始数据变成易懂的信息
- **数据聚合**：把大量数据点合并成有意义的结果
- **数据计算**：对监控指标进行数学运算
- **条件筛选**：根据条件过滤和处理数据

### 1.2 函数分类一览


```
Grafana函数家族图谱：

📊 数学函数族
   ├── abs() - 绝对值计算
   ├── round() - 四舍五入
   ├── floor() - 向下取整
   └── ceil() - 向上取整

📈 聚合函数族  
   ├── sum() - 求和
   ├── avg() - 平均值
   ├── max() - 最大值
   └── min() - 最小值

⏰ 时间函数族
   ├── timeShift() - 时间偏移
   ├── movingAverage() - 移动平均
   └── derivative() - 变化率

🔤 字符串函数族
   ├── aliasByNode() - 别名设置
   └── groupByNode() - 分组处理

🎯 条件函数族
   ├── isNonNull() - 非空判断
   └── transformNull() - 空值处理
```

### 1.3 函数使用的基本思路


**🎯 使用步骤**
1. **明确目标**：我想从数据中得到什么？
2. **选择函数**：哪个函数能帮我实现目标？
3. **设置参数**：函数需要什么输入参数？
4. **验证结果**：输出是否符合预期？

**📋 实际应用思考框架**
```
遇到监控需求时的思考路径：

需求：显示服务器CPU平均使用率
↓
分析：需要把多个时间点的CPU数据求平均
↓  
选择：avg()聚合函数
↓
应用：avg(cpu.usage)
↓
验证：查看图表是否显示合理的平均值
```

---

## 2. 🔢 数学函数详解与应用


### 2.1 基础数学运算函数


**🔸 绝对值函数 - abs()**

**作用说明**：把负数变成正数，正数保持不变
```
实际应用场景：
• 温度变化幅度：abs(当前温度 - 目标温度)
• 性能偏差分析：abs(实际响应时间 - 期望响应时间)
• 误差计算：abs(预测值 - 实际值)

使用示例：
abs(cpu.usage - 50)  # 计算CPU使用率偏离50%的程度
```

**🔸 四舍五入函数族**

| 函数 | **作用** | **示例** | **结果** |
|------|----------|----------|----------|
| `round()` | `四舍五入到整数` | `round(85.7)` | `86` |
| `floor()` | `向下取整` | `floor(85.7)` | `85` |
| `ceil()` | `向上取整` | `ceil(85.1)` | `86` |

**实际应用技巧**
```
场景1：磁盘使用率显示
原始数据：85.7234%
使用round()：86% (更清晰易读)

场景2：告警阈值判断  
原始数据：79.9%
使用ceil()：80% (保守估计，避免漏报)

场景3：容量规划
原始数据：需要15.2GB
使用ceil()：16GB (确保容量充足)
```

### 2.2 高级数学计算


**🔸 对数和指数运算**
```
log10() - 常用对数
• 用途：处理数据范围很大的情况
• 示例：网络流量从KB到TB的显示
• 效果：log10(network_bytes) 让图表更均匀

scale() - 数据缩放
• 用途：统一不同指标的显示比例
• 示例：scale(memory_bytes, 0.000001) 把字节转换为MB
• 技巧：1字节 = 0.000001MB
```

**💡 数学函数组合技巧**
```
组合1：百分比计算
(current_value / total_value) * 100

组合2：增长率计算  
((new_value - old_value) / old_value) * 100

组合3：标准化处理
(value - min_value) / (max_value - min_value)
```

---

## 3. 📊 聚合函数的实战运用


### 3.1 核心聚合函数详解


**🔸 求和函数 - sum()**

**基本概念**：把多个数值加起来得到总数
```
生活类比：
就像计算一个月的总花费
第1天：100元 + 第2天：150元 + ... = 月总花费

监控应用：
• 所有服务器的总CPU使用量
• 整个集群的总内存消耗  
• 全部接口的总请求次数
```

**实际应用案例**
```
案例1：集群资源监控
需求：显示5台服务器的总CPU使用量
函数：sum(cpu.usage{server=~"web-[1-5]"})
效果：把5台服务器的CPU使用量加起来

案例2：业务指标统计
需求：计算所有API接口的总调用次数
函数：sum(api_requests_total)
效果：显示系统整体的API调用量
```

**🔸 平均值函数 - avg()**

**基本概念**：把所有数值加起来再除以数量，得到平均水平
```
计算过程演示：
数据：[80%, 85%, 90%, 75%, 70%]
计算：(80 + 85 + 90 + 75 + 70) ÷ 5 = 80%
意义：这组服务器的平均CPU使用率是80%
```

**应用场景对比表**

| 场景类型 | **使用sum()** | **使用avg()** |
|----------|---------------|---------------|
| **容量规划** | `总内存使用量` | `平均内存使用率` |
| **性能分析** | `总请求数` | `平均响应时间` |
| **告警设置** | `总错误数` | `平均错误率` |
| **成本分析** | `总资源消耗` | `平均资源效率` |

### 3.2 极值函数的妙用


**🔸 最大值/最小值函数**
```
max() - 找出最高点
• 应用：找出集群中CPU使用率最高的服务器
• 意义：发现性能瓶颈和热点问题
• 示例：max(cpu.usage) 显示最繁忙的服务器状态

min() - 找出最低点  
• 应用：找出响应时间最快的服务器
• 意义：发现最优性能基准
• 示例：min(response_time) 显示最佳响应时间
```

**🎯 聚合函数选择指南**
```
业务问题 → 函数选择决策树：

问：想知道整体负载情况？
答：用 sum() 计算总负载

问：想知道平均水平？
答：用 avg() 计算平均值

问：想找出问题服务器？  
答：用 max() 找出最高CPU使用率

问：想找出最佳实践？
答：用 min() 找出最低响应时间

问：想了解数据分布？
答：同时使用 max(), min(), avg() 进行对比
```

---

## 4. ⏰ 时间函数处理技巧


### 4.1 时间偏移 - timeShift()


**🔸 基本概念**
```
时间偏移就像"时光机"：
• 把当前的数据和之前某个时间的数据进行对比
• 比如：今天的CPU使用率 vs 昨天同一时间的CPU使用率

语法格式：
timeShift(metric, "时间偏移量")
```

**实际应用场景**
```
场景1：周环比分析
timeShift(cpu.usage, "1w")  # 对比一周前的数据
用途：看看这周和上周同期的差异

场景2：日环比分析  
timeShift(api_requests, "1d")  # 对比一天前的数据
用途：发现每日流量变化趋势

场景3：小时环比分析
timeShift(response_time, "1h")  # 对比一小时前的数据  
用途：快速发现性能变化
```

**⚡ 时间偏移的高级应用**
```
组合应用：计算增长率
当前值：cpu.usage
昨天值：timeShift(cpu.usage, "1d")
增长率：(cpu.usage - timeShift(cpu.usage, "1d")) / timeShift(cpu.usage, "1d") * 100

实际意义：
• 正数：今天比昨天高，可能有性能问题
• 负数：今天比昨天低，性能有改善
• 接近0：变化不大，系统稳定
```

### 4.2 移动平均 - movingAverage()


**🔸 移动平均的概念**
```
移动平均像"平滑滤镜"：
• 原始数据：跳跃很大，看起来很乱
• 移动平均：变得平滑，趋势更清晰

工作原理：
取最近N个数据点的平均值作为当前点的值
```

**应用效果对比**
```
原始CPU数据：[45%, 78%, 52%, 81%, 49%, 76%, 53%]
5点移动平均：计算每5个点的平均值
结果：数据变得平滑，更容易看出趋势

使用方法：
movingAverage(cpu.usage, 5)  # 5个点的移动平均
movingAverage(cpu.usage, 10) # 10个点的移动平均（更平滑）
```

**📈 移动平均窗口大小选择**

| 窗口大小 | **特点** | **适用场景** |
|----------|----------|--------------|
| `3-5个点` | `响应快，保留细节` | `快速变化的指标` |
| `10-15个点` | `平衡平滑度和响应性` | `一般监控指标` |
| `20个点以上` | `非常平滑，滞后明显` | `长期趋势分析` |

### 4.3 变化率计算 - derivative()


**🔸 变化率的作用**
```
变化率告诉我们"变化的快慢"：
• 正值：指标在增长
• 负值：指标在下降  
• 数值大小：变化的快慢程度

实际意义：
CPU使用率从50%到60%，变化率是10%/分钟
网络流量从100MB到120MB，变化率是20MB/分钟
```

**应用实例**
```
示例1：内存泄漏检测
derivative(memory.usage)
• 持续正值：内存在不断增长（可能内存泄漏）
• 在0附近波动：内存使用正常

示例2：流量突增检测
derivative(network.traffic)  
• 突然出现大正值：流量突然增加
• 可能是DDoS攻击或业务高峰
```

---

## 5. 🔤 字符串处理函数应用


### 5.1 别名设置 - aliasByNode()


**🔸 为什么需要别名**
```
问题：默认的指标名称往往很长很复杂
示例：server.datacenter.east.web01.cpu.usage.percent

解决：使用别名让图表更清晰易读
效果：简化为"web01"或"CPU使用率"
```

**基本使用方法**
```
语法：aliasByNode(metric, node_number)

示例数据：server.datacenter.east.web01.cpu.usage
节点编号：   0     1        2    3     4   5

aliasByNode(metric, 3)  # 结果：web01
aliasByNode(metric, 4)  # 结果：cpu  
aliasByNode(metric, 5)  # 结果：usage
```

**🎯 实际应用技巧**
```
场景1：服务器监控面板
原始名称：server.rack1.web01.cpu.usage
使用：aliasByNode(metric, 2)
结果：图例显示"web01"，清晰识别不同服务器

场景2：多环境对比
原始名称：app.production.api.response_time
使用：aliasByNode(metric, 1)  
结果：图例显示"production"，方便环境对比
```

### 5.2 高级别名处理


**🔸 alias() - 自定义别名**
```
完全自定义图表标签：
alias(cpu.usage, "服务器CPU使用率")
alias(memory.usage, "内存使用情况")  
alias(disk.io, "磁盘IO性能")

优势：完全控制显示名称，支持中文
适用：固定的、重要的监控指标
```

**🔸 aliasSub() - 正则替换**
```
使用正则表达式处理复杂的名称：
aliasSub(metric, "\.(\w+)\.cpu\.", "CPU-\1")

示例转换：
server.web01.cpu.usage → CPU-web01
server.db02.cpu.usage → CPU-db02

技巧：适合批量处理相似模式的指标名称
```

---

## 6. 🎯 条件函数与逻辑控制


### 6.1 空值处理函数


**🔸 非空判断 - isNonNull()**

**应用背景**
```
监控数据经常出现空值：
• 服务器宕机：没有数据上报
• 网络问题：数据传输中断
• 服务重启：监控临时中断

问题：空值会影响图表显示和计算
解决：使用isNonNull()过滤掉空值
```

**使用方法**
```
基本语法：isNonNull(metric)

实际效果：
原始数据：[10, null, 15, null, 20, 25]
过滤后：[10, 15, 20, 25]
结果：图表连线更流畅，计算更准确
```

**🔸 空值填充 - transformNull()**

**作用说明**
```
把空值替换成指定的数值：
transformNull(metric, 0)     # 空值替换为0
transformNull(metric, -1)    # 空值替换为-1  
transformNull(metric, 100)   # 空值替换为100
```

**应用策略选择**

| 业务场景 | **填充策略** | **理由** |
|----------|--------------|----------|
| **错误计数** | `填充为0` | `没有数据表示没有错误` |
| **CPU使用率** | `不填充/过滤` | `空值表示服务器离线` |
| **温度监控** | `填充为上一个值` | `温度变化是连续的` |
| **网络流量** | `填充为0` | `没有数据表示没有流量` |

### 6.2 条件逻辑函数


**🔸 keepLastValue() - 保持最后值**
```
作用：当出现空值时，使用最后一个有效值
应用：平滑短暂的数据中断

示例：
原始：[10, 15, null, null, 20]  
结果：[10, 15, 15, 15, 20]
```

**🔸 removeAboveValue()/removeBelowValue() - 数值过滤**
```
去除异常数据点：
removeAboveValue(cpu.usage, 100)  # 去除超过100%的异常值
removeBelowValue(response_time, 0) # 去除负数响应时间

用途：清理数据，避免异常值影响分析
```

---

## 7. 🛠️ 自定义计算与组合应用


### 7.1 函数组合的基本原则


**🔸 组合思路**
```
函数组合像"烹饪步骤"：
1. 原料准备：获取基础监控数据
2. 初步处理：清理、过滤数据
3. 主要加工：核心计算和转换
4. 最终调味：别名、格式化显示

组合顺序很重要：
从内到外，从基础到高级
```

**实际组合示例**
```
复杂组合：计算服务器群组的平均CPU使用率增长
movingAverage(
  derivative(
    avg(cpu.usage{group="web"})
  ), 
  5
)

执行顺序：
1. avg() - 计算web组服务器的平均CPU
2. derivative() - 计算变化率  
3. movingAverage() - 平滑处理
```

### 7.2 常用业务计算模式


**🔸 错误率计算**
```
业务需求：计算API接口的错误率
公式：错误率 = 错误请求数 / 总请求数 * 100

Grafana实现：
(sum(api_errors) / sum(api_requests)) * 100

加上别名：
alias(
  (sum(api_errors) / sum(api_requests)) * 100,
  "API错误率(%)"
)
```

**🔸 资源利用率计算**
```
业务需求：计算磁盘使用率
公式：使用率 = (已用空间 / 总空间) * 100

Grafana实现：
((disk_used / disk_total) * 100)

添加四舍五入：
round(((disk_used / disk_total) * 100))
```

**🔸 性能对比分析**
```
业务需求：对比今天和昨天的性能
思路：当前值与历史值的比较

实现：
当前响应时间：response_time
昨天响应时间：timeShift(response_time, "1d")  
性能变化：response_time - timeShift(response_time, "1d")

完整表达式：
alias(
  response_time - timeShift(response_time, "1d"),
  "响应时间变化(ms)"
)
```

### 7.3 高级计算技巧


**🔸 百分位数计算**
```
需求：计算95%的请求响应时间在多少以内
函数：quantile(0.95, response_time)

意义：
• 95%的用户体验到的响应时间
• 排除5%的极端情况
• 更真实反映用户体验
```

**🔸 同比环比分析**
```
同比（去年同期）：
timeShift(metric, "1y")

环比（上个周期）：  
timeShift(metric, "1w")  # 周环比
timeShift(metric, "1d")  # 日环比

增长率计算：
((current - previous) / previous) * 100
```

**📊 组合应用实战案例**
```
案例：创建完整的服务健康度仪表板

1. CPU健康度
alias(
  avg(cpu.usage{service="api"}),
  "CPU平均使用率"
)

2. 内存健康度  
alias(
  round((avg(memory.used) / avg(memory.total)) * 100),
  "内存使用率(%)"
)

3. 响应时间趋势
alias(
  movingAverage(avg(response_time), 10),
  "响应时间趋势"
)

4. 错误率告警
alias(
  (sum(errors) / sum(requests)) * 100,
  "错误率(%)"
)
```

---

## 8. 📋 核心要点总结


### 8.1 函数使用的关键原则


**🔸 选择函数的决策流程**
```
步骤1：明确监控目标
• 我想要什么信息？
• 这些信息用来做什么决策？

步骤2：分析数据特点
• 数据是什么类型？（数值、字符串、时间序列）
• 数据有什么问题？（空值、异常值、噪声）

步骤3：选择合适函数
• 数据聚合 → sum(), avg(), max(), min()
• 趋势分析 → movingAverage(), derivative()  
• 时间对比 → timeShift()
• 数据清理 → isNonNull(), transformNull()

步骤4：验证和优化
• 结果是否符合预期？
• 是否需要组合多个函数？
```

### 8.2 常用函数速查表


| 函数类别 | **核心函数** | **主要用途** | **使用场景** |
|----------|-------------|-------------|-------------|
| **聚合统计** | `sum(), avg(), max(), min()` | `数据汇总分析` | `性能监控、容量规划` |
| **时间处理** | `timeShift(), movingAverage()` | `趋势分析对比` | `同比环比、趋势预测` |
| **数学计算** | `abs(), round(), scale()` | `数值转换处理` | `数据格式化、单位转换` |
| **条件控制** | `isNonNull(), transformNull()` | `数据质量控制` | `异常处理、数据清洗` |
| **字符处理** | `alias(), aliasByNode()` | `显示优化` | `图表美化、标识清晰` |

### 8.3 实际应用的最佳实践


**🔹 函数组合的三个层次**
```
初级应用：单一函数解决问题
• avg(cpu.usage) - 直接求平均值
• sum(requests) - 直接求总数

中级应用：简单组合增强效果  
• round(avg(cpu.usage)) - 平均值四舍五入
• alias(sum(requests), "总请求数") - 添加清晰标签

高级应用：复杂组合解决业务问题
• 多函数嵌套计算KPI指标
• 时间序列分析和预测
• 跨指标关联分析
```

**🔹 性能监控的函数应用模式**
```
🟢 正常监控：
• avg() - 了解平均水平
• max() - 发现峰值问题  
• timeShift() - 对比历史数据

🟡 异常检测：
• derivative() - 检测快速变化
• removeAboveValue() - 过滤异常值
• isNonNull() - 确保数据完整性

🔴 告警计算：
• 阈值比较：cpu.usage > 80
• 变化率告警：derivative(error_rate) > 10
• 持续时间：movingAverage(cpu.usage, 5) > 90
```

**🎯 记忆技巧和实用建议**
```
记忆口诀：
• 聚合看整体：sum avg max min
• 时间看趋势：shift average derivative  
• 条件控制质量：null值要处理
• 别名提升体验：alias让图表更清晰

实用建议：
• 从简单开始：先用基础函数，再考虑组合
• 验证结果：每添加一个函数都要验证效果
• 保持清晰：复杂组合要添加注释和别名
• 性能考虑：避免不必要的复杂计算
```

### 8.4 学习检查清单


**✅ 基础掌握程度自测**
- [ ] 能解释5种聚合函数的区别和用途
- [ ] 会使用timeShift()进行时间对比
- [ ] 掌握movingAverage()平滑数据
- [ ] 理解空值处理的不同策略
- [ ] 能设置清晰的图表别名

**✅ 进阶应用能力自测**  
- [ ] 能组合3个以上函数解决复杂问题
- [ ] 会计算业务KPI指标（错误率、利用率等）
- [ ] 能进行同比环比分析
- [ ] 掌握数据清洗和异常处理
- [ ] 能创建完整的监控仪表板

**🧠 核心理解检验**
```
思考题：
1. 什么时候用sum()，什么时候用avg()？
2. 如何用函数计算服务可用性？
3. 怎样检测性能突然恶化？
4. 如何优雅处理监控数据中的空值？

答案关键词：
1. 总量用sum，水平用avg
2. (成功请求/总请求)*100  
3. derivative()检测快速变化
4. 根据业务含义选择填充或过滤策略
```

**核心记忆**：
- Grafana函数是数据变美味的调料，选对函数让监控更有价值
- 聚合函数看整体，时间函数看趋势，条件函数保质量  
- 从简单到复杂，从单一到组合，循序渐进掌握函数应用
- 函数不是目的而是工具，关键是解决实际的监控问题