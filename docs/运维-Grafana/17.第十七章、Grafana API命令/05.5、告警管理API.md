---
title: 5、告警管理API
---
## 📚 目录

1. [告警系统基础概念](#1-告警系统基础概念)
2. [告警管理核心API](#2-告警管理核心API)
3. [通知渠道配置详解](#3-通知渠道配置详解)
4. [告警规则管理实战](#4-告警规则管理实战)
5. [告警状态与历史查询](#5-告警状态与历史查询)
6. [高级告警功能](#6-高级告警功能)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🚨 告警系统基础概念


### 1.1 什么是Grafana告警系统


**简单理解**：告警系统就像是你家的烟雾报警器，当监控指标出现异常时，会自动通知你

```
现实生活中的报警：              Grafana告警系统：
烟雾报警器 → 发现火灾 → 响铃      监控指标 → 触发条件 → 发送通知
门铃 → 有人按门 → 通知主人        CPU使用率 → 超过80% → 邮件/短信
```

**核心作用**：
- **主动监控**：不用人工盯着看，系统自动检查
- **及时通知**：问题发生时立即告知相关人员
- **减少损失**：早发现早处理，避免小问题变大问题

### 1.2 告警系统的工作流程


**完整流程图示**：
```
数据源(MySQL/Redis) → Grafana监控 → 告警规则判断 → 触发告警 → 通知渠道 → 相关人员
      ↑                    ↑              ↑           ↑          ↑         ↑
   实时数据              设置阈值        条件满足     发送消息    邮件/短信   运维人员
```

**流程步骤详解**：
1. **数据收集**：Grafana从各种数据源获取监控数据
2. **规则检查**：按设定的告警规则检查数据是否异常
3. **条件判断**：如果数据超过设定阈值，触发告警
4. **消息发送**：通过邮件、短信、微信等方式通知相关人员
5. **状态跟踪**：记录告警状态，直到问题解决

### 1.3 核心API端点概览


| **API端点** | **功能说明** | **使用场景** |
|------------|-------------|-------------|
| `/api/alerts` | **告警管理主入口** | `查看、创建、修改告警规则` |
| `/api/alert-notifications` | **通知渠道管理** | `配置邮件、短信、微信通知` |
| `/api/alerts/test` | **告警测试** | `验证告警规则是否正常工作` |
| `/api/alerts/{id}/pause` | **告警暂停/恢复** | `临时关闭某个告警规则` |

---

## 2. 📡 告警管理核心API


### 2.1 查看所有告警规则


**功能说明**：获取当前系统中所有的告警规则，就像查看手机里所有的闹钟设置

```bash
# 获取所有告警规则
curl -H "Authorization: Bearer YOUR_API_KEY" \
     http://localhost:3000/api/alerts
```

**返回数据解读**：
```json
[
  {
    "id": 1,
    "name": "CPU使用率过高告警",
    "message": "服务器CPU使用率超过80%",
    "state": "ok",           // 当前状态：ok(正常) alerting(告警中) paused(已暂停)
    "frequency": "10s",      // 检查频率：每10秒检查一次
    "executionError": "",    // 执行错误信息
    "evalData": {
      "isNew": false,
      "evalMatches": []      // 匹配的数据点
    }
  }
]
```

**状态含义说明**：
- 🟢 **ok**：一切正常，没有触发告警条件
- 🔴 **alerting**：正在告警中，需要关注
- ⏸️ **paused**：已暂停，不会检查和发送通知
- ❓ **pending**：等待中，可能即将触发告警

### 2.2 创建新的告警规则


**使用场景**：比如你想监控网站响应时间，超过5秒就发送告警

```bash
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "网站响应时间告警",
    "message": "网站响应时间超过5秒，请立即检查",
    "frequency": "30s",
    "conditions": [
      {
        "query": {
          "queryType": "",
          "refId": "A"
        },
        "reducer": {
          "type": "avg",
          "params": []
        },
        "evaluator": {
          "params": [5000],
          "type": "gt"
        }
      }
    ],
    "executionErrorState": "alerting",
    "noDataState": "no_data"
  }' \
  http://localhost:3000/api/alerts
```

**关键参数解释**：
- **name**：告警规则的名称，要起个容易理解的名字
- **message**：告警时显示的消息，要说清楚是什么问题
- **frequency**：多久检查一次，不要太频繁以免影响性能
- **conditions**：触发条件，比如"大于5秒"就是gt(greater than)

### 2.3 修改告警规则


**实际需求**：原来设置CPU超过80%告警，现在想改成70%

```bash
curl -X PUT \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "id": 1,
    "name": "CPU使用率告警(已调整)",
    "message": "CPU使用率超过70%，请注意",
    "conditions": [
      {
        "evaluator": {
          "params": [70],
          "type": "gt"
        }
      }
    ]
  }' \
  http://localhost:3000/api/alerts/1
```

### 2.4 暂停和恢复告警


**使用场景**：系统维护期间，临时关闭告警避免误报

```bash
# 暂停告警
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  http://localhost:3000/api/alerts/1/pause

# 恢复告警  
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  http://localhost:3000/api/alerts/1/unpause
```

---

## 3. 📢 通知渠道配置详解


### 3.1 通知渠道基础概念


**通俗理解**：通知渠道就像是告警系统的"嘴巴"，决定了用什么方式告诉你有问题

**常见通知方式对比**：

| **通知类型** | **适用场景** | **优点** | **缺点** | **紧急程度** |
|-------------|-------------|---------|---------|-------------|
| 📧 **邮件** | `日常监控通知` | 详细信息丰富 | 可能不及时查看 | 🟡 中等 |
| 📱 **短信** | `紧急故障通知` | 立即送达 | 成本较高 | 🔴 高 |
| 💬 **Slack** | `团队协作场景` | 团队共享 | 需要在线 | 🟡 中等 |
| 🔗 **Webhook** | `自动化处理` | 灵活性强 | 需要技术配置 | 🟢 自定义 |

### 3.2 邮件通知配置


**使用场景**：最常用的通知方式，适合日常监控报告

```bash
# 创建邮件通知渠道
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "运维团队邮件通知",
    "type": "email",
    "settings": {
      "addresses": "admin@company.com;ops@company.com",
      "subject": "[告警] {{.CommonLabels.alertname}}",
      "body": "告警详情：\n时间：{{.CommonAnnotations.timestamp}}\n服务：{{.CommonLabels.service}}\n详情：{{.CommonAnnotations.description}}"
    }
  }' \
  http://localhost:3000/api/alert-notifications
```

**配置要点说明**：
- **addresses**：接收邮件的地址，多个用分号分隔
- **subject**：邮件标题，使用模板变量动态生成
- **body**：邮件内容，包含告警的详细信息

### 3.3 Slack通知配置


**使用场景**：团队使用Slack办公，希望告警信息直接发到群里

```bash
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Slack运维通知",
    "type": "slack",
    "settings": {
      "webhook_url": "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK",
      "channel": "#alerts",
      "title": "🚨 系统告警",
      "text": "{{.CommonLabels.alertname}} - {{.CommonAnnotations.description}}",
      "username": "Grafana告警机器人"
    }
  }' \
  http://localhost:3000/api/alert-notifications
```

**Slack配置说明**：
- **webhook_url**：Slack提供的Webhook地址
- **channel**：发送到哪个频道，比如#alerts
- **username**：机器人显示的名称

### 3.4 Webhook通知配置


**使用场景**：需要触发自动化脚本或集成其他系统

```bash
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "自动化处理Webhook",
    "type": "webhook",
    "settings": {
      "url": "http://your-automation-server.com/webhook/alerts",
      "httpMethod": "POST",
      "httpHeaders": {
        "Content-Type": "application/json",
        "Authorization": "Bearer YOUR_WEBHOOK_TOKEN"
      }
    }
  }' \
  http://localhost:3000/api/alert-notifications
```

**Webhook优势**：
- 可以触发自动修复脚本
- 集成到现有的运维系统
- 实现复杂的告警处理逻辑

### 3.5 查看和管理通知渠道


```bash
# 查看所有通知渠道
curl -H "Authorization: Bearer YOUR_API_KEY" \
     http://localhost:3000/api/alert-notifications

# 测试通知渠道是否正常
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  http://localhost:3000/api/alert-notifications/1/test
```

---

## 4. ⚙️ 告警规则管理实战


### 4.1 常见告警规则模板


**系统资源监控告警**：

| **监控指标** | **告警阈值** | **检查频率** | **通知方式** |
|-------------|-------------|-------------|-------------|
| 🖥️ **CPU使用率** | `> 80%` | `30秒` | 邮件+Slack |
| 💾 **内存使用率** | `> 85%` | `1分钟` | 邮件 |
| 💿 **磁盘使用率** | `> 90%` | `5分钟` | 邮件+短信 |
| 🌐 **网络延迟** | `> 500ms` | `10秒` | Slack |

### 4.2 应用服务监控告警


**Web服务监控示例**：
```bash
# 创建API响应时间告警
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "API响应时间过慢",
    "message": "API平均响应时间超过2秒，影响用户体验",
    "frequency": "1m",
    "conditions": [
      {
        "query": {
          "queryType": "prometheus",
          "expr": "avg(http_request_duration_seconds) > 2"
        },
        "reducer": {
          "type": "last"
        },
        "evaluator": {
          "params": [2],
          "type": "gt"
        }
      }
    ],
    "notifications": [1, 2]
  }' \
  http://localhost:3000/api/alerts
```

### 4.3 业务指标监控告警


**电商网站监控示例**：
- **订单量异常**：1小时内订单数少于正常水平的50%
- **支付失败率**：支付失败率超过5%
- **用户登录异常**：登录失败率超过10%

### 4.4 告警规则最佳实践


**命名规范建议**：
```
✅ 好的命名：
- "生产环境-MySQL-连接数过高"
- "用户服务-API响应时间超时"
- "支付系统-错误率异常"

❌ 不好的命名：
- "告警1"
- "测试"
- "alert"
```

**阈值设置原则**：
- 🎯 **基于历史数据**：分析过去3个月的正常范围
- ⚡ **避免误报**：阈值不要设置得太敏感
- 🔄 **定期调整**：根据业务变化调整阈值

---

## 5. 📊 告警状态与历史查询


### 5.1 查询告警状态


**获取当前告警状态**：
```bash
# 查看特定告警的详细状态
curl -H "Authorization: Bearer YOUR_API_KEY" \
     http://localhost:3000/api/alerts/1

# 查看所有正在告警的规则
curl -H "Authorization: Bearer YOUR_API_KEY" \
     "http://localhost:3000/api/alerts?state=alerting"
```

**状态信息解读**：
```json
{
  "id": 1,
  "name": "CPU使用率告警",
  "state": "alerting",
  "stateChanges": 3,           // 状态变化次数
  "stateAge": "5m",           // 当前状态持续时间  
  "evalData": {
    "evalMatches": [
      {
        "value": 85.6,          // 触发告警的具体数值
        "metric": "cpu_usage",
        "tags": {
          "host": "web-server-01"
        }
      }
    ]
  }
}
```

### 5.2 告警历史记录查询


**查看告警历史的作用**：
- 📈 **趋势分析**：了解系统问题的发生频率
- 🔍 **故障排查**：回溯问题发生的时间点
- 📊 **性能评估**：评估告警规则的有效性

```bash
# 查询最近7天的告警历史
curl -H "Authorization: Bearer YOUR_API_KEY" \
     "http://localhost:3000/api/annotations?from=now-7d&to=now&tags=alert"
```

### 5.3 告警统计信息


**获取告警汇总数据**：
```bash
# 获取告警统计
curl -H "Authorization: Bearer YOUR_API_KEY" \
     http://localhost:3000/api/alerts/stats
```

**统计数据示例**：
```
今日告警总数：45次
正在告警：3个
已解决：42个
平均处理时间：15分钟
```

---

## 6. 🔧 高级告警功能


### 6.1 告警静默管理


**什么是告警静默**：临时关闭某些告警，避免在已知问题期间产生噪音

**使用场景**：
- 🛠️ **系统维护**：计划内的维护不需要告警
- 🔄 **部署期间**：应用部署时可能临时异常
- 🎯 **问题处理中**：已知问题正在处理，避免重复告警

```bash
# 创建告警静默规则
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "matchers": [
      {
        "name": "service",
        "value": "web-api",
        "isRegex": false
      }
    ],
    "startsAt": "2024-01-21T10:00:00Z",
    "endsAt": "2024-01-21T12:00:00Z",
    "comment": "API服务维护期间静默告警"
  }' \
  http://localhost:3000/api/alertmanager/grafana/api/v1/silences
```

### 6.2 告警分组设置


**分组的作用**：将相关的告警归类，避免收到太多零散的通知

**分组策略示例**：
```
按服务分组：
- Web服务组：前端、API、负载均衡器
- 数据库组：MySQL、Redis、MongoDB  
- 基础设施组：网络、存储、主机

按严重程度分组：
- 严重告警：影响业务的关键问题
- 警告告警：需要关注但不紧急的问题
- 信息告警：仅供参考的状态信息
```

### 6.3 告警模板配置


**通知消息模板**：让告警信息更清晰易懂

```json
{
  "title": "🚨 {{ .GroupLabels.service }} 服务告警",
  "text": "**告警时间：** {{ .CommonAnnotations.timestamp }}\n**服务名称：** {{ .GroupLabels.service }}\n**告警级别：** {{ .CommonLabels.severity }}\n**问题描述：** {{ .CommonAnnotations.description }}\n**当前数值：** {{ .CommonAnnotations.value }}\n**处理建议：** {{ .CommonAnnotations.runbook_url }}"
}
```

### 6.4 告警频率控制


**防止告警轰炸**：避免短时间内收到大量重复告警

**控制策略**：
- ⏰ **时间间隔**：同一告警最少间隔5分钟发送一次
- 🔢 **次数限制**：1小时内最多发送3次同样的告警
- 📈 **升级机制**：问题持续1小时后发送给更高级别的人员

```bash
# 设置告警频率限制
curl -X PUT \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "groupWait": "30s",      // 等待30秒后发送第一次告警
    "groupInterval": "5m",   // 相同组的告警间隔5分钟
    "repeatInterval": "1h"   // 重复告警间隔1小时
  }' \
  http://localhost:3000/api/alertmanager/config
```

### 6.5 告警依赖关系


**依赖关系的作用**：避免因为一个根本问题导致大量相关告警

**示例场景**：
```
数据库服务器宕机
    ↓
Web应用无法连接数据库 (这个告警应该被抑制)
    ↓  
用户无法登录 (这个告警也应该被抑制)
    ↓
订单服务异常 (这个告警也应该被抑制)

只需要收到"数据库服务器宕机"这一个告警即可
```

### 6.6 批量告警操作


**批量管理的需求**：系统维护时需要临时关闭多个告警

```bash
# 批量暂停多个告警
curl -X POST \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "alertIds": [1, 2, 3, 4, 5],
    "action": "pause",
    "reason": "计划维护期间批量暂停"
  }' \
  http://localhost:3000/api/alerts/batch
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 告警系统本质：主动监控 + 及时通知 + 问题跟踪
🔸 核心API端点：/api/alerts 和 /api/alert-notifications  
🔸 工作流程：数据收集 → 规则检查 → 条件判断 → 消息发送
🔸 通知渠道：邮件、Slack、Webhook等多种方式
🔸 状态管理：ok、alerting、paused三种主要状态
```

### 7.2 关键理解要点


**🔹 告警规则设计原则**
```
合理性：
- 阈值基于历史数据设定
- 避免过于敏感导致误报
- 考虑业务影响程度

可维护性：  
- 使用清晰的命名规范
- 添加详细的描述信息
- 定期检查和调整规则
```

**🔹 通知渠道选择策略**
```
紧急程度分级：
- 🔴 严重：短信 + 电话 + 邮件
- 🟡 警告：邮件 + Slack
- 🟢 信息：邮件

场景化配置：
- 工作时间：Slack + 邮件
- 非工作时间：短信 + 邮件  
- 维护期间：仅记录日志
```

**🔹 告警疲劳预防**
```
静默管理：
- 维护期间临时关闭告警
- 已知问题处理期间静默
- 依赖关系避免告警雪崩

频率控制：
- 设置合理的重复间隔
- 分组减少零散通知
- 升级机制确保关键问题得到关注
```

### 7.3 实际应用场景指导


**✅ 新手推荐配置**
```
第一步：基础系统监控
- CPU、内存、磁盘使用率告警
- 服务进程存活检查
- 网络连通性监控

第二步：应用服务监控  
- API响应时间和错误率
- 数据库连接状态
- 关键业务指标

第三步：用户体验监控
- 页面加载时间
- 用户操作成功率
- 支付交易状态
```

**🔧 运维最佳实践**
```
告警规则管理：
- 定期review告警历史
- 根据误报情况调整阈值
- 删除无用的告警规则

团队协作：
- 明确告警处理责任人
- 建立告警升级机制
- 记录问题处理过程

持续改进：
- 分析告警有效性
- 收集团队反馈
- 优化通知内容和方式
```

### 7.4 常见问题解决方案


**❓ 告警太多怎么办**
```
解决方案：
1. 检查告警阈值是否合理
2. 使用告警分组减少通知数量
3. 设置告警依赖关系
4. 在维护期间使用静默功能
```

**❓ 收不到告警通知**
```
排查步骤：
1. 检查通知渠道配置是否正确
2. 使用测试API验证通知渠道
3. 查看告警规则是否被暂停
4. 确认告警条件是否真的被触发
```

**❓ 告警延迟太大**
```
优化方法：
1. 减少告警检查频率的设置
2. 优化查询语句的性能
3. 检查Grafana服务器的性能
4. 考虑使用推送方式的告警
```

**核心记忆**：
- 告警系统是运维自动化的重要组成部分
- 合理的告警配置能提高运维效率
- 通知渠道要根据场景选择
- 避免告警疲劳，质量比数量重要