---
title: 4ã€åˆ†åŒºç­–ç•¥å’Œè·¯ç”±
---
## ğŸ“š ç›®å½•

1. [åˆ†åŒºç­–ç•¥åŸºç¡€æ¦‚å¿µ](#1-åˆ†åŒºç­–ç•¥åŸºç¡€æ¦‚å¿µ)
2. [é»˜è®¤åˆ†åŒºå™¨è¯¦è§£](#2-é»˜è®¤åˆ†åŒºå™¨è¯¦è§£)
3. [æ ¸å¿ƒåˆ†åŒºç­–ç•¥](#3-æ ¸å¿ƒåˆ†åŒºç­–ç•¥)
4. [è‡ªå®šä¹‰åˆ†åŒºå™¨å®è·µ](#4-è‡ªå®šä¹‰åˆ†åŒºå™¨å®è·µ)
5. [åˆ†åŒºé”®é€‰æ‹©ç­–ç•¥](#5-åˆ†åŒºé”®é€‰æ‹©ç­–ç•¥)
6. [çƒ­ç‚¹åˆ†åŒºå¤„ç†](#6-çƒ­ç‚¹åˆ†åŒºå¤„ç†)
7. [è´Ÿè½½å‡è¡¡ä¼˜åŒ–](#7-è´Ÿè½½å‡è¡¡ä¼˜åŒ–)
8. [æœ€ä½³å®è·µæ€»ç»“](#8-æœ€ä½³å®è·µæ€»ç»“)

---

## 1. ğŸ¯ åˆ†åŒºç­–ç•¥åŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯åˆ†åŒºç­–ç•¥


**é€šä¿—ç†è§£ï¼šåˆ†åŒºç­–ç•¥å°±åƒå¿«é€’åˆ†æ‹£**

æƒ³è±¡ä¸€ä¸‹å¿«é€’å…¬å¸å¤„ç†åŒ…è£¹çš„è¿‡ç¨‹ï¼š
- ğŸ¢ **å¿«é€’å…¬å¸** = Kafkaé›†ç¾¤
- ğŸ“¦ **åŒ…è£¹** = æ¶ˆæ¯ï¼ˆMessageï¼‰  
- ğŸšš **åˆ†æ‹£è½¦é—´** = åˆ†åŒºï¼ˆPartitionï¼‰
- ğŸ“‹ **åˆ†æ‹£è§„åˆ™** = åˆ†åŒºç­–ç•¥

```
å¿«é€’åˆ†æ‹£è¿‡ç¨‹ï¼š                    Kafkaåˆ†åŒºè¿‡ç¨‹ï¼š
åŒ…è£¹åˆ°è¾¾ â†’ æŸ¥çœ‹åœ°å€ â†’ åˆ†é…è½¦é—´     æ¶ˆæ¯åˆ°è¾¾ â†’ è®¡ç®—åˆ†åŒº â†’ å†™å…¥åˆ†åŒº
```

**ğŸ”¸ æ ¸å¿ƒä½œç”¨**
```
åˆ†åŒºç­–ç•¥çš„æœ¬è´¨ç›®çš„ï¼š
âœ… å†³å®šæ¶ˆæ¯å†™å…¥å“ªä¸ªåˆ†åŒº
âœ… å®ç°æ•°æ®åˆ†æ•£å­˜å‚¨
âœ… æé«˜å¹¶è¡Œå¤„ç†èƒ½åŠ›
âœ… ä¿è¯æ¶ˆæ¯æœ‰åºæ€§ï¼ˆåˆ†åŒºå†…ï¼‰
âœ… å®ç°è´Ÿè½½å‡è¡¡
```

### 1.2 åˆ†åŒºè·¯ç”±çš„å·¥ä½œæœºåˆ¶


**æ¶ˆæ¯å‘é€çš„å®Œæ•´æµç¨‹ï¼š**

```
ç”Ÿäº§è€…å‘é€æ¶ˆæ¯æµç¨‹ï¼š
å‘é€æ¶ˆæ¯ â†’ åºåˆ—åŒ– â†’ åˆ†åŒºè®¡ç®— â†’ ç¼“å†²åŒº â†’ ç½‘ç»œå‘é€ â†’ Brokerå­˜å‚¨

é‡ç‚¹å…³æ³¨ï¼šåˆ†åŒºè®¡ç®—ç¯èŠ‚
è¾“å…¥ï¼šæ¶ˆæ¯å†…å®¹ + åˆ†åŒºé”®(å¯é€‰) + Topicåˆ†åŒºæ•°
è¾“å‡ºï¼šå…·ä½“çš„åˆ†åŒºç¼–å·(0, 1, 2, ...)
```

### 1.3 åˆ†åŒºç­–ç•¥çš„é‡è¦æ€§


**ğŸ’¡ ä¸ºä»€ä¹ˆåˆ†åŒºç­–ç•¥è¿™ä¹ˆé‡è¦ï¼Ÿ**

| å½±å“æ–¹é¢ | **è¯´æ˜** | **ä¸¾ä¾‹** |
|---------|---------|----------|
| ğŸš€ **æ€§èƒ½** | `åˆ†åŒºåˆ†æ•£ï¼Œå¹¶å‘å†™å…¥` | `4ä¸ªåˆ†åŒº = 4å€å†™å…¥é€Ÿåº¦` |
| âš–ï¸ **è´Ÿè½½** | `é¿å…çƒ­ç‚¹åˆ†åŒº` | `é˜²æ­¢æŸä¸ªåˆ†åŒºå‹åŠ›è¿‡å¤§` |
| ğŸ“„ **é¡ºåº** | `åˆ†åŒºå†…æ¶ˆæ¯æœ‰åº` | `ç”¨æˆ·æ“ä½œæŒ‰æ—¶é—´é¡ºåº` |
| ğŸ”„ **æ‰©å±•** | `åˆ†åŒºæ•°å†³å®šå¹¶å‘åº¦` | `æ¶ˆè´¹è€…æ•°é‡ â‰¤ åˆ†åŒºæ•°` |

---

## 2. âš™ï¸ é»˜è®¤åˆ†åŒºå™¨è¯¦è§£


### 2.1 DefaultPartitionerå·¥ä½œåŸç†


**é»˜è®¤åˆ†åŒºå™¨æ˜¯Kafkaè‡ªå¸¦çš„åˆ†åŒºç­–ç•¥**ï¼Œå®ƒçš„å·¥ä½œé€»è¾‘å¾ˆç®€å•ï¼š

```
é»˜è®¤åˆ†åŒºå™¨çš„åˆ¤æ–­æµç¨‹ï¼š

æœ‰åˆ†åŒºé”®(key)ï¼Ÿ
â”œâ”€ æ˜¯ â†’ ä½¿ç”¨å“ˆå¸Œåˆ†åŒºç­–ç•¥
â””â”€ å¦ â†’ ä½¿ç”¨ç²˜æ€§åˆ†åŒºç­–ç•¥
```

### 2.2 ä¸¤ç§æƒ…å†µçš„å¤„ç†æ–¹å¼


**ğŸ”¸ æƒ…å†µ1ï¼šæ¶ˆæ¯å¸¦æœ‰Key**
```java
// å¸¦Keyçš„æ¶ˆæ¯
producer.send(new ProducerRecord<>("my-topic", "user123", "ç”¨æˆ·ç™»å½•"));

å¤„ç†é€»è¾‘ï¼š
1. è®¡ç®— hash("user123") 
2. åˆ†åŒºå· = hashå€¼ % åˆ†åŒºæ•°
3. åŒæ ·keyçš„æ¶ˆæ¯æ°¸è¿œå»åŒä¸€ä¸ªåˆ†åŒº
```

**ğŸ”¸ æƒ…å†µ2ï¼šæ¶ˆæ¯æ²¡æœ‰Key**  
```java
// ä¸å¸¦Keyçš„æ¶ˆæ¯
producer.send(new ProducerRecord<>("my-topic", "ç³»ç»Ÿæ—¥å¿—"));

å¤„ç†é€»è¾‘ï¼š
1. ä½¿ç”¨ç²˜æ€§åˆ†åŒºç­–ç•¥
2. éšæœºé€‰æ‹©ä¸€ä¸ªåˆ†åŒº
3. åœ¨è¿™ä¸ªåˆ†åŒºçš„æ‰¹æ¬¡å¡«æ»¡å‰ï¼Œæ‰€æœ‰æ¶ˆæ¯éƒ½å‘å¾€è¿™ä¸ªåˆ†åŒº
```

### 2.3 é»˜è®¤åˆ†åŒºå™¨çš„ä¼˜ç¼ºç‚¹


**âœ… ä¼˜ç‚¹**
- ä½¿ç”¨ç®€å•ï¼Œé›¶é…ç½®
- è‡ªåŠ¨å¤„ç†æœ‰Keyå’Œæ— Keyçš„æƒ…å†µ  
- æ€§èƒ½è‰¯å¥½ï¼Œé€‚åˆå¤§å¤šæ•°åœºæ™¯

**âŒ ç¼ºç‚¹**
- æ— æ³•å¤„ç†å¤æ‚çš„ä¸šåŠ¡åˆ†åŒºéœ€æ±‚
- å“ˆå¸Œåˆ†åŒºå¯èƒ½å¯¼è‡´æ•°æ®å€¾æ–œ
- ä¸èƒ½æ ¹æ®æ¶ˆæ¯å†…å®¹è¿›è¡Œåˆ†åŒº

---

## 3. ğŸ”„ æ ¸å¿ƒåˆ†åŒºç­–ç•¥


### 3.1 è½®è¯¢åˆ†åŒºç­–ç•¥ (Round Robin)


**é€šä¿—ç†è§£ï¼šå°±åƒå‘ç‰Œä¸€æ ·è½®æµåˆ†é…**

```
è½®è¯¢åˆ†åŒºæ¼”ç¤ºï¼š
åˆ†åŒº0  åˆ†åŒº1  åˆ†åŒº2
 â†“     â†“     â†“
æ¶ˆæ¯1  æ¶ˆæ¯2  æ¶ˆæ¯3
æ¶ˆæ¯4  æ¶ˆæ¯5  æ¶ˆæ¯6
æ¶ˆæ¯7  æ¶ˆï¿½8  æ¶ˆæ¯9

ç‰¹ç‚¹ï¼šç»å¯¹å…¬å¹³ï¼Œæ¯ä¸ªåˆ†åŒºæ¶ˆæ¯æ•°é‡ç›¸ç­‰
```

**å®ç°åŸç†ï¼š**
```java
// è½®è¯¢åˆ†åŒºå™¨æ ¸å¿ƒé€»è¾‘
public class RoundRobinPartitioner implements Partitioner {
    private AtomicInteger counter = new AtomicInteger(0);
    
    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        List<PartitionInfo> partitions = cluster.partitionsForTopic(topic);
        int partitionCount = partitions.size();
        
        // è½®è¯¢è®¡ç®—ï¼šæ¯æ¬¡é€’å¢ï¼Œå–æ¨¡è¿ç®—
        return counter.getAndIncrement() % partitionCount;
    }
}
```

**ğŸ“Š é€‚ç”¨åœºæ™¯**
- âœ… **æ¶ˆæ¯æ— éœ€æŒ‰Keyåˆ†ç»„** - æ¯”å¦‚æ—¥å¿—æ”¶é›†
- âœ… **è¿½æ±‚ç»å¯¹è´Ÿè½½å‡è¡¡** - æ¯ä¸ªåˆ†åŒºæ¶ˆæ¯é‡ç›¸ç­‰
- âœ… **æ¶ˆæ¯å¤„ç†æ— çŠ¶æ€** - æ¶ˆè´¹è€…å¯ä»¥å¤„ç†ä»»æ„æ¶ˆæ¯

### 3.2 å“ˆå¸Œåˆ†åŒºç­–ç•¥ (Hash)


**é€šä¿—ç†è§£ï¼šæ ¹æ®Keyçš„"æŒ‡çº¹"å†³å®šåˆ†åŒº**

```
å“ˆå¸Œåˆ†åŒºè¿‡ç¨‹ï¼š
Keyå€¼: "user123" â†’ hashè®¡ç®— â†’ 2847492 â†’ 2847492 % 3 = åˆ†åŒº2
Keyå€¼: "user456" â†’ hashè®¡ç®— â†’ 5639281 â†’ 5639281 % 3 = åˆ†åŒº1

ç›¸åŒKeyæ°¸è¿œè¿›å…¥ç›¸åŒåˆ†åŒºï¼
```

**å…³é”®ç‰¹æ€§ï¼š**
```
ğŸ”¸ ç¡®å®šæ€§ï¼šç›¸åŒè¾“å…¥æ°¸è¿œäº§ç”Ÿç›¸åŒè¾“å‡º
ğŸ”¸ åˆ†æ•£æ€§ï¼šä¸åŒKeyå°½å¯èƒ½åˆ†æ•£åˆ°ä¸åŒåˆ†åŒº
ğŸ”¸ ä¸€è‡´æ€§ï¼šç›¸åŒKeyçš„æ¶ˆæ¯ä¿æŒé¡ºåº
```

**ä»£ç å®ç°æ ¸å¿ƒï¼š**
```java
// å“ˆå¸Œåˆ†åŒºè®¡ç®—
public int partition(String topic, Object key, byte[] keyBytes, ...) {
    if (keyBytes == null) {
        // æ— Keyæ—¶ä½¿ç”¨å…¶ä»–ç­–ç•¥
        return stickyPartitionCache.partition(topic, cluster);
    }
    
    // è®¡ç®—å“ˆå¸Œå€¼
    int hash = Utils.toPositive(Utils.murmur2(keyBytes));
    
    // å–æ¨¡å¾—åˆ°åˆ†åŒºå·
    return hash % cluster.partitionsForTopic(topic).size();
}
```

**ğŸ“ˆ ä¼˜ç¼ºç‚¹åˆ†æ**

| æ–¹é¢ | **ä¼˜ç‚¹** | **ç¼ºç‚¹** |
|------|---------|----------|
| ğŸ¯ **ä¸€è‡´æ€§** | `ç›¸åŒKeyæ¶ˆæ¯æœ‰åº` | `Keyåˆ†å¸ƒä¸å‡å¯èƒ½å€¾æ–œ` |
| ğŸš€ **æ€§èƒ½** | `è®¡ç®—ç®€å•é«˜æ•ˆ` | `çƒ­ç‚¹Keyå¯¼è‡´çƒ­ç‚¹åˆ†åŒº` |
| ğŸ”§ **æ‰©å±•** | `é€»è¾‘ç®€å•æ˜“æ‡‚` | `åˆ†åŒºæ•°å˜åŒ–å½±å“åˆ†å¸ƒ` |

### 3.3 ç²˜æ€§åˆ†åŒºç­–ç•¥ (Sticky)


**é€šä¿—ç†è§£ï¼šå°±åƒ"é’‰å­æˆ·"ï¼Œé€‰å®šä¸€ä¸ªåˆ†åŒºå°±ä¸€ç›´ç”¨**

```
ç²˜æ€§åˆ†åŒºå·¥ä½œæµç¨‹ï¼š

ç¬¬ä¸€æ‰¹æ¶ˆæ¯(æ— Key)ï¼š
é€‰æ‹©åˆ†åŒº1 â†’ æ¶ˆæ¯1ã€æ¶ˆæ¯2ã€æ¶ˆæ¯3... â†’ ç›´åˆ°æ‰¹æ¬¡æ»¡

ç¬¬äºŒæ‰¹æ¶ˆæ¯(æ— Key)ï¼š  
é‡æ–°éšæœºé€‰æ‹©åˆ†åŒº2 â†’ æ¶ˆæ¯20ã€æ¶ˆæ¯21... â†’ ç›´åˆ°æ‰¹æ¬¡æ»¡

ä¼˜åŠ¿ï¼šå‡å°‘ç½‘ç»œå¼€é”€ï¼Œæé«˜ååé‡
```

**æ ¸å¿ƒæœºåˆ¶ï¼š**
```java
// ç²˜æ€§åˆ†åŒºç­–ç•¥ä¼ªä»£ç 
class StickyPartitionCache {
    private volatile Integer stickyPartition = null;
    
    public int partition(String topic, Cluster cluster) {
        // å¦‚æœå½“å‰æ‰¹æ¬¡è¿˜æœ‰ç©ºé—´ï¼Œç»§ç»­ä½¿ç”¨å½“å‰åˆ†åŒº
        if (stickyPartition != null && hasAvailableCapacity(stickyPartition)) {
            return stickyPartition;
        }
        
        // æ‰¹æ¬¡æ»¡äº†æˆ–é¦–æ¬¡åˆ†é…ï¼Œéšæœºé€‰æ‹©æ–°åˆ†åŒº
        stickyPartition = randomPartition(topic, cluster);
        return stickyPartition;
    }
}
```

**âš¡ æ€§èƒ½ä¼˜åŠ¿**
```
ä¼ ç»Ÿè½®è¯¢ vs ç²˜æ€§åˆ†åŒºï¼š

è½®è¯¢åˆ†åŒºï¼šæ¯ä¸ªæ¶ˆæ¯å•ç‹¬å‘é€
æ¶ˆæ¯1â†’åˆ†åŒº0, æ¶ˆæ¯2â†’åˆ†åŒº1, æ¶ˆæ¯3â†’åˆ†åŒº2 (3æ¬¡ç½‘ç»œè¯·æ±‚)

ç²˜æ€§åˆ†åŒºï¼šæ‰¹é‡å‘é€
æ¶ˆæ¯1,2,3â†’åˆ†åŒº0 (1æ¬¡ç½‘ç»œè¯·æ±‚ï¼Œ3å€æ•ˆç‡ï¼)
```

---

## 4. ğŸ› ï¸ è‡ªå®šä¹‰åˆ†åŒºå™¨å®è·µ


### 4.1 ä¸ºä»€ä¹ˆéœ€è¦è‡ªå®šä¹‰åˆ†åŒºå™¨


**ğŸ¤” é»˜è®¤åˆ†åŒºå™¨çš„å±€é™æ€§ï¼š**
- æ— æ³•æ ¹æ®ä¸šåŠ¡é€»è¾‘åˆ†åŒº
- ä¸èƒ½å¤„ç†å¤æ‚çš„è´Ÿè½½å‡è¡¡éœ€æ±‚  
- éš¾ä»¥é¿å…ç‰¹å®šçš„çƒ­ç‚¹é—®é¢˜

### 4.2 ä¸šåŠ¡åœºæ™¯é©±åŠ¨çš„åˆ†åŒºéœ€æ±‚


**ğŸ’¼ å®é™…ä¸šåŠ¡åœºæ™¯ä¸¾ä¾‹ï¼š**

| ä¸šåŠ¡åœºæ™¯ | **åˆ†åŒºéœ€æ±‚** | **ä¼ ç»Ÿæ–¹æ¡ˆé—®é¢˜** |
|---------|-------------|----------------|
| ğŸª **ç”µå•†è®¢å•** | `æŒ‰åœ°åŒºåˆ†åŒºå¤„ç†` | `é»˜è®¤å“ˆå¸Œå¯èƒ½åœ°åŒºä¸å‡` |
| ğŸ‘¥ **ç”¨æˆ·è¡Œä¸º** | `VIPç”¨æˆ·ä¼˜å…ˆåˆ†åŒº` | `æ— æ³•åŒºåˆ†ç”¨æˆ·ç­‰çº§` |
| ğŸ“Š **æ—¥å¿—ç³»ç»Ÿ** | `æŒ‰æ—¥å¿—çº§åˆ«åˆ†åŒº` | `ERRORå’ŒINFOæ··åœ¨ä¸€èµ·` |
| ğŸ® **æ¸¸æˆæ•°æ®** | `æŒ‰æœåŠ¡å™¨åˆ†åŒº` | `è·¨æœæ•°æ®å¤„ç†å›°éš¾` |

### 4.3 è‡ªå®šä¹‰åˆ†åŒºå™¨å¼€å‘å®æˆ˜


**ğŸ—ï¸ å¼€å‘æ­¥éª¤ï¼š**

**Step 1: å®ç°Partitioneræ¥å£**
```java
public class CustomBusinessPartitioner implements Partitioner {
    
    @Override
    public int partition(String topic, Object key, byte[] keyBytes, 
                        Object value, byte[] valueBytes, Cluster cluster) {
        
        // è·å–åˆ†åŒºæ€»æ•°
        int partitionCount = cluster.partitionsForTopic(topic).size();
        
        if (keyBytes == null) {
            // å¤„ç†æ— Keyæƒ…å†µ
            return ThreadLocalRandom.current().nextInt(partitionCount);
        }
        
        String keyStr = new String(keyBytes);
        
        // ä¸šåŠ¡é€»è¾‘ï¼šæ ¹æ®ç”¨æˆ·ç±»å‹åˆ†åŒº
        if (keyStr.startsWith("VIP_")) {
            // VIPç”¨æˆ·ä½¿ç”¨å‰30%åˆ†åŒºï¼ˆå‡è®¾æœ‰æ›´å¥½æ€§èƒ½ï¼‰
            int vipPartitionCount = Math.max(1, partitionCount * 3 / 10);
            return Math.abs(keyStr.hashCode()) % vipPartitionCount;
        } else if (keyStr.startsWith("NORMAL_")) {
            // æ™®é€šç”¨æˆ·ä½¿ç”¨å70%åˆ†åŒº
            int normalPartitionStart = partitionCount * 3 / 10;
            int normalPartitionCount = partitionCount - normalPartitionStart;
            return normalPartitionStart + (Math.abs(keyStr.hashCode()) % normalPartitionCount);
        }
        
        // é»˜è®¤æƒ…å†µä½¿ç”¨å“ˆå¸Œåˆ†åŒº
        return Math.abs(keyStr.hashCode()) % partitionCount;
    }
    
    @Override
    public void configure(Map<String, ?> configs) {
        // ä»é…ç½®ä¸­è¯»å–ä¸šåŠ¡å‚æ•°
    }
    
    @Override  
    public void close() {
        // æ¸…ç†èµ„æº
    }
}
```

**Step 2: é…ç½®ä½¿ç”¨è‡ªå®šä¹‰åˆ†åŒºå™¨**
```java
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

// ğŸ”‘ å…³é”®é…ç½®ï¼šæŒ‡å®šè‡ªå®šä¹‰åˆ†åŒºå™¨
props.put("partitioner.class", "com.example.CustomBusinessPartitioner");

KafkaProducer<String, String> producer = new KafkaProducer<>(props);
```

### 4.4 é«˜çº§è‡ªå®šä¹‰åˆ†åŒºå™¨ç¤ºä¾‹


**ğŸ¯ åœ°ç†ä½ç½®æ„ŸçŸ¥åˆ†åŒºå™¨ï¼š**
```java
public class GeographicPartitioner implements Partitioner {
    private static final Map<String, Integer> REGION_PARTITION_MAP = new HashMap<>();
    
    static {
        // ååŒ—åœ°åŒº â†’ åˆ†åŒº0-2
        REGION_PARTITION_MAP.put("beijing", 0);
        REGION_PARTITION_MAP.put("tianjin", 1);
        REGION_PARTITION_MAP.put("hebei", 2);
        
        // åä¸œåœ°åŒº â†’ åˆ†åŒº3-5  
        REGION_PARTITION_MAP.put("shanghai", 3);
        REGION_PARTITION_MAP.put("jiangsu", 4);
        REGION_PARTITION_MAP.put("zhejiang", 5);
    }
    
    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        
        if (keyBytes != null) {
            String region = extractRegionFromKey(new String(keyBytes));
            Integer partition = REGION_PARTITION_MAP.get(region);
            
            if (partition != null) {
                return partition;
            }
        }
        
        // æœªçŸ¥åœ°åŒºä½¿ç”¨éšæœºåˆ†åŒº
        return ThreadLocalRandom.current().nextInt(cluster.partitionsForTopic(topic).size());
    }
    
    private String extractRegionFromKey(String key) {
        // ä»Keyä¸­æå–åœ°åŒºä¿¡æ¯çš„ä¸šåŠ¡é€»è¾‘
        // ä¾‹å¦‚: "order_beijing_001" â†’ "beijing"
        String[] parts = key.split("_");
        return parts.length > 1 ? parts[1].toLowerCase() : "unknown";
    }
}
```

---

## 5. ğŸ”‘ åˆ†åŒºé”®é€‰æ‹©ç­–ç•¥


### 5.1 åˆ†åŒºé”®çš„æ ¸å¿ƒä½œç”¨


**ğŸ¯ åˆ†åŒºé”®(Partition Key)çš„æœ¬è´¨ï¼š**
```
åˆ†åŒºé”® = å†³å®šæ¶ˆæ¯åˆ†åŒºçš„"èº«ä»½è¯"

ä½œç”¨æœºåˆ¶ï¼š
æ¶ˆæ¯å†…å®¹ + åˆ†åŒºé”® â†’ å“ˆå¸Œè®¡ç®— â†’ åˆ†åŒºç¼–å·
```

**ğŸ’¡ é€‰æ‹©åˆ†åŒºé”®çš„åŸºæœ¬åŸåˆ™ï¼š**

| åŸåˆ™ | **è¯´æ˜** | **ä¸¾ä¾‹** |
|------|---------|----------|
| ğŸ¯ **ä¸šåŠ¡ç›¸å…³æ€§** | `ä¸ä¸šåŠ¡é€»è¾‘ç´§å¯†ç›¸å…³` | `ç”¨æˆ·IDã€è®¢å•IDã€è®¾å¤‡ID` |
| âš–ï¸ **åˆ†å¸ƒå‡åŒ€æ€§** | `é¿å…æ•°æ®å€¾æ–œ` | `é¿å…ç”¨å›ºå®šå€¼åšKey` |  
| ğŸ“„ **é¡ºåºä¸€è‡´æ€§** | `éœ€è¦é¡ºåºçš„æ¶ˆæ¯ç”¨åŒä¸€Key` | `åŒä¸€ç”¨æˆ·çš„æ“ä½œåºåˆ—` |
| ğŸš€ **åŸºæ•°é€‚ä¸­** | `Keyçš„å”¯ä¸€å€¼æ•°é‡åˆç†` | `ä¸è¦å¤ªå°‘ä¹Ÿä¸è¦è¿‡å¤š` |

### 5.2 å¸¸è§åˆ†åŒºé”®é€‰æ‹©ç­–ç•¥


**ğŸ”¸ ç”¨æˆ·ç»´åº¦åˆ†åŒº**
```java
// åœºæ™¯ï¼šç”¨æˆ·è¡Œä¸ºè¿½è¸ªç³»ç»Ÿ
String partitionKey = "user_" + userId;
ProducerRecord<String, String> record = new ProducerRecord<>(
    "user-behavior", 
    partitionKey,  // åŒä¸€ç”¨æˆ·çš„è¡Œä¸ºè¿›å…¥åŒä¸€åˆ†åŒº
    behaviorData
);

ä¼˜åŠ¿ï¼š
âœ… ç”¨æˆ·è¡Œä¸ºæœ‰åº
âœ… ä¾¿äºç”¨æˆ·ç”»åƒåˆ†æ  
âœ… æ”¯æŒç”¨æˆ·ä¼šè¯è·Ÿè¸ª
```

**ğŸ”¸ æ—¶é—´ç»´åº¦åˆ†åŒº**
```java  
// åœºæ™¯ï¼šæ—¥å¿—åˆ†æç³»ç»Ÿ
String partitionKey = "hour_" + (System.currentTimeMillis() / (1000 * 60 * 60));
ProducerRecord<String, String> record = new ProducerRecord<>(
    "application-logs",
    partitionKey,  // æŒ‰å°æ—¶åˆ†åŒº
    logMessage  
);

ä¼˜åŠ¿ï¼š
âœ… ä¾¿äºæŒ‰æ—¶é—´èŒƒå›´æŸ¥è¯¢
âœ… æ”¯æŒæ•°æ®è€åŒ–ç­–ç•¥
âœ… æ–¹ä¾¿æ—¶é—´çª—å£åˆ†æ
```

**ğŸ”¸ ä¸šåŠ¡å®ä½“åˆ†åŒº**
```java
// åœºæ™¯ï¼šç”µå•†è®¢å•ç³»ç»Ÿ
String partitionKey = "order_" + orderId;  
ProducerRecord<String, String> record = new ProducerRecord<>(
    "order-events",
    partitionKey,  // è®¢å•ç›¸å…³äº‹ä»¶èšåˆ
    orderEvent
);

ä¼˜åŠ¿ï¼š  
âœ… è®¢å•äº‹ä»¶æœ‰åºå¤„ç†
âœ… æ”¯æŒè®¢å•çŠ¶æ€æœº
âœ… ä¾¿äºè®¢å•æ•°æ®ä¸€è‡´æ€§
```

### 5.3 åˆ†åŒºé”®è®¾è®¡çš„æœ€ä½³å®è·µ


**ğŸ† é«˜è´¨é‡åˆ†åŒºé”®çš„ç‰¹å¾ï¼š**

```java
// âœ… å¥½çš„åˆ†åŒºé”®è®¾è®¡
class GoodPartitionKeyExample {
    
    // 1. ç»„åˆå¼åˆ†åŒºé”®ï¼šé¿å…çƒ­ç‚¹
    public String createCompositeKey(String userId, String deviceType) {
        return userId + "_" + deviceType + "_" + (System.currentTimeMillis() % 100);
        // ç”¨æˆ·+è®¾å¤‡ç±»å‹+æ—¶é—´ç‰‡æ®µï¼Œä¿è¯åˆ†æ•£æ€§
    }
    
    // 2. å“ˆå¸Œæ•£åˆ—åˆ†åŒºé”®ï¼šå¢åŠ éšæœºæ€§  
    public String createHashedKey(String originalKey) {
        return "hash_" + Math.abs(originalKey.hashCode() % 1000);
        // å°†åŸå§‹Keyå“ˆå¸Œåˆ°1000ä¸ªæ¡¶ä¸­ï¼Œé¿å…å€¾æ–œ
    }
    
    // 3. ä¸šåŠ¡è§„åˆ™åˆ†åŒºé”®ï¼šç¬¦åˆä¸šåŠ¡é€»è¾‘
    public String createBusinessKey(String productCategory, String regionCode) {
        return productCategory + "_region_" + regionCode;
        // æŒ‰å•†å“ç±»åˆ«å’Œåœ°åŒºåˆ†åŒºï¼Œä¾¿äºä¸šåŠ¡åˆ†æ
    }
}
```

**âŒ é¿å…çš„åˆ†åŒºé”®åæ¨¡å¼ï¼š**

```java
// âŒ ç³Ÿç³•çš„åˆ†åŒºé”®è®¾è®¡
class BadPartitionKeyExample {
    
    // åæ¨¡å¼1ï¼šå›ºå®šå€¼åˆ†åŒºé”®
    String badKey1 = "fixed_value";  // æ‰€æœ‰æ¶ˆæ¯è¿›å…¥åŒä¸€åˆ†åŒº
    
    // åæ¨¡å¼2ï¼šæé«˜åŸºæ•°åˆ†åŒºé”®  
    String badKey2 = UUID.randomUUID().toString();  // æ¯ä¸ªæ¶ˆæ¯ä¸åŒåˆ†åŒº
    
    // åæ¨¡å¼3ï¼šä¸šåŠ¡æ— å…³åˆ†åŒºé”®
    String badKey3 = String.valueOf(System.currentTimeMillis());  // ä¸ä¸šåŠ¡æ— å…³
    
    // åæ¨¡å¼4ï¼šå®¹æ˜“äº§ç”Ÿçƒ­ç‚¹çš„åˆ†åŒºé”®
    String badKey4 = "hot_user_" + popularUserId;  // çƒ­é—¨ç”¨æˆ·å¯¼è‡´çƒ­ç‚¹åˆ†åŒº
}
```

---

## 6. ğŸ”¥ çƒ­ç‚¹åˆ†åŒºå¤„ç†


### 6.1 çƒ­ç‚¹åˆ†åŒºç°è±¡è¯†åˆ«


**ğŸš¨ ä»€ä¹ˆæ˜¯çƒ­ç‚¹åˆ†åŒºï¼Ÿ**
```
æ­£å¸¸åˆ†åŒºè´Ÿè½½ï¼š
åˆ†åŒº0: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100MB/s
åˆ†åŒº1: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 95MB/s  
åˆ†åŒº2: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 105MB/s

çƒ­ç‚¹åˆ†åŒºè´Ÿè½½ï¼š
åˆ†åŒº0: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 500MB/s  â† çƒ­ç‚¹åˆ†åŒº
åˆ†åŒº1: â–ˆâ–ˆâ–ˆâ–ˆ 50MB/s
åˆ†åŒº2: â–ˆâ–ˆâ–ˆâ–ˆ 45MB/s
```

**ğŸ“Š çƒ­ç‚¹åˆ†åŒºçš„è¯†åˆ«æŒ‡æ ‡ï¼š**

| æŒ‡æ ‡ç±»å‹ | **ç›‘æ§é¡¹** | **æ­£å¸¸èŒƒå›´** | **çƒ­ç‚¹å‘Šè­¦** |
|---------|-----------|-------------|------------|
| ğŸš€ **æµé‡æŒ‡æ ‡** | `åˆ†åŒºå†™å…¥é€Ÿåº¦` | `ç›¸å¯¹å‡è¡¡` | `è¶…å‡ºå¹³å‡å€¼3å€` |
| ğŸ’¾ **å­˜å‚¨æŒ‡æ ‡** | `åˆ†åŒºæ•°æ®å¤§å°` | `åŸºæœ¬ç›¸å½“` | `æ˜æ˜¾è¶…å‡ºå…¶ä»–åˆ†åŒº` |
| â±ï¸ **å»¶è¿ŸæŒ‡æ ‡** | `æ¶ˆæ¯å¤„ç†å»¶è¿Ÿ` | `æ¯«ç§’çº§` | `ç§’çº§æˆ–æ›´é«˜` |
| ğŸ”„ **æ¶ˆè´¹æŒ‡æ ‡** | `æ¶ˆè´¹è€…Lag` | `æ¥è¿‘0` | `æŒç»­ç§¯å‹` |

### 6.2 çƒ­ç‚¹åˆ†åŒºäº§ç”Ÿçš„åŸå› 


**ğŸ” æ ¹å› åˆ†æï¼š**

```java  
// åŸå› 1ï¼šçƒ­ç‚¹Keyå¯¼è‡´
// æŸä¸ªå¤§Vç”¨æˆ·çš„è¡Œä¸ºæ¶ˆæ¯æš´å¢
String hotKey = "user_big_v_123";  // è¿™ä¸ªç”¨æˆ·äº§ç”Ÿå¤§é‡æ¶ˆæ¯
// è§£å†³ï¼šKeyåŠ éšæœºåç¼€åˆ†æ•£

// åŸå› 2ï¼šä¸šåŠ¡é€»è¾‘å€¾æ–œ
// æŸä¸ªåœ°åŒºæˆ–ç±»åˆ«çš„æ•°æ®ç‰¹åˆ«å¤š
String skewedKey = "region_beijing";  // åŒ—äº¬åœ°åŒºæ¶ˆæ¯ç‰¹åˆ«å¤š  
// è§£å†³ï¼šæŒ‰åœ°åŒº+å…¶ä»–ç»´åº¦ç»„åˆåˆ†åŒº

// åŸå› 3ï¼šæ—¶é—´çª—å£æ•ˆåº”
// æŸä¸ªæ—¶é—´æ®µæ¶ˆæ¯é›†ä¸­çˆ†å‘
String timeKey = "hour_" + peakHour;  // é«˜å³°æ—¶æ®µæ¶ˆæ¯é›†ä¸­
// è§£å†³ï¼šæ—¶é—´çª—å£æ›´ç»†åŒ–æˆ–åŠ éšæœºå› å­
```

### 6.3 çƒ­ç‚¹åˆ†åŒºå¤„ç†ç­–ç•¥


**ğŸ› ï¸ ç­–ç•¥1ï¼šçƒ­ç‚¹Keyåˆ†æ•£**
```java
public class HotKeyScatterPartitioner implements Partitioner {
    private static final Set<String> HOT_KEYS = Set.of("big_v_user", "hot_product");
    private static final int SCATTER_FACTOR = 10;  // åˆ†æ•£å› å­
    
    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        
        if (keyBytes != null) {
            String keyStr = new String(keyBytes);
            
            // æ£€æµ‹æ˜¯å¦ä¸ºçƒ­ç‚¹Key
            if (isHotKey(keyStr)) {
                // çƒ­ç‚¹Keyæ·»åŠ éšæœºåç¼€åˆ†æ•£
                String scatteredKey = keyStr + "_" + 
                    ThreadLocalRandom.current().nextInt(SCATTER_FACTOR);
                return Math.abs(scatteredKey.hashCode()) % 
                    cluster.partitionsForTopic(topic).size();
            }
        }
        
        // éçƒ­ç‚¹Keyæ­£å¸¸å¤„ç†
        return Math.abs(new String(keyBytes).hashCode()) % 
            cluster.partitionsForTopic(topic).size();
    }
    
    private boolean isHotKey(String key) {
        return HOT_KEYS.stream().anyMatch(key::contains);
    }
}
```

**ğŸ› ï¸ ç­–ç•¥2ï¼šåŠ¨æ€è´Ÿè½½å‡è¡¡**
```java  
public class LoadBalancePartitioner implements Partitioner {
    private final Map<Integer, AtomicLong> partitionLoadCounter = new ConcurrentHashMap<>();
    private final int REBALANCE_THRESHOLD = 1000;  // é‡å¹³è¡¡é˜ˆå€¼
    
    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        
        int partitionCount = cluster.partitionsForTopic(topic).size();
        
        // æ‰¾åˆ°å½“å‰è´Ÿè½½æœ€å°çš„åˆ†åŒº
        int selectedPartition = findLeastLoadedPartition(partitionCount);
        
        // æ›´æ–°è´Ÿè½½è®¡æ•°
        partitionLoadCounter.computeIfAbsent(selectedPartition, k -> new AtomicLong(0))
                           .incrementAndGet();
        
        return selectedPartition;
    }
    
    private int findLeastLoadedPartition(int partitionCount) {
        long minLoad = Long.MAX_VALUE;
        int leastLoadedPartition = 0;
        
        for (int i = 0; i < partitionCount; i++) {
            long currentLoad = partitionLoadCounter
                .computeIfAbsent(i, k -> new AtomicLong(0))
                .get();
                
            if (currentLoad < minLoad) {
                minLoad = currentLoad;
                leastLoadedPartition = i;
            }
        }
        
        return leastLoadedPartition;
    }
}
```

**ğŸ› ï¸ ç­–ç•¥3ï¼šé¢„åˆ†åŒºæ‰©å®¹**
```bash
# å¢åŠ Topicåˆ†åŒºæ•°ï¼ˆæ³¨æ„ï¼šåªèƒ½å¢åŠ ï¼Œä¸èƒ½å‡å°‘ï¼‰
kafka-topics.sh --alter \
  --bootstrap-server localhost:9092 \
  --topic hot-topic \
  --partitions 20  # ä»10ä¸ªåˆ†åŒºæ‰©å±•åˆ°20ä¸ª

# ä¼˜åŠ¿ï¼š
âœ… å¢åŠ å¹¶è¡Œåº¦
âœ… åˆ†æ•£çƒ­ç‚¹è´Ÿè½½  
âœ… æé«˜æ•´ä½“ååé‡

# æ³¨æ„äº‹é¡¹ï¼š
âš ï¸ ä¼šå½±å“ç°æœ‰æ¶ˆæ¯çš„åˆ†åŒºåˆ†å¸ƒ
âš ï¸ éœ€è¦é‡å¯æ¶ˆè´¹è€…ä»¥æ„ŸçŸ¥æ–°åˆ†åŒº
âš ï¸ å†å²æ•°æ®ä¸ä¼šè‡ªåŠ¨é‡æ–°åˆ†å¸ƒ
```

---

## 7. âš–ï¸ è´Ÿè½½å‡è¡¡ä¼˜åŒ–


### 7.1 è´Ÿè½½å‡è¡¡çš„æ ¸å¿ƒç›®æ ‡


**ğŸ¯ ä»€ä¹ˆæ˜¯çœŸæ­£çš„è´Ÿè½½å‡è¡¡ï¼Ÿ**

```
ç†æƒ³çš„è´Ÿè½½å‡è¡¡çŠ¶æ€ï¼š

åˆ†åŒºè´Ÿè½½è§†å›¾ï¼š
åˆ†åŒº0: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (100MB/s, 1000msg/s)
åˆ†åŒº1: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (105MB/s, 980msg/s)  
åˆ†åŒº2: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (98MB/s, 1020msg/s)
åˆ†åŒº3: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (102MB/s, 990msg/s)

ç‰¹å¾ï¼šå„åˆ†åŒºçš„æµé‡ã€æ¶ˆæ¯æ•°ã€å¤„ç†å»¶è¿ŸåŸºæœ¬ç›¸å½“
```

**ğŸ“ˆ è´Ÿè½½å‡è¡¡çš„å¤šç»´åº¦è¡¡é‡ï¼š**

| ç»´åº¦ | **è¡¡é‡æŒ‡æ ‡** | **å¹³è¡¡ç›®æ ‡** |
|------|-------------|-------------|
| ğŸ“Š **æµé‡å‡è¡¡** | `æ¯åˆ†åŒºååé‡` | `å·®å¼‚ < 20%` |
| ğŸ”¢ **æ¶ˆæ¯å‡è¡¡** | `æ¯åˆ†åŒºæ¶ˆæ¯æ•°` | `åŸºæœ¬ç›¸ç­‰` |
| â±ï¸ **å»¶è¿Ÿå‡è¡¡** | `å¤„ç†å»¶è¿Ÿ` | `å„åˆ†åŒºå»¶è¿Ÿæ¥è¿‘` |
| ğŸ’¾ **å­˜å‚¨å‡è¡¡** | `åˆ†åŒºå¤§å°` | `å­˜å‚¨ç©ºé—´å‡åŒ€` |

### 7.2 æ™ºèƒ½è´Ÿè½½å‡è¡¡åˆ†åŒºå™¨


**ğŸ§  è‡ªé€‚åº”åˆ†åŒºç­–ç•¥ï¼š**
```java
public class AdaptiveLoadBalancePartitioner implements Partitioner {
    private final Map<Integer, PartitionMetrics> partitionMetrics = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    
    public AdaptiveLoadBalancePartitioner() {
        // å®šæœŸæ”¶é›†åˆ†åŒºæŒ‡æ ‡
        scheduler.scheduleAtFixedRate(this::updatePartitionMetrics, 0, 10, TimeUnit.SECONDS);
    }
    
    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        
        int partitionCount = cluster.partitionsForTopic(topic).size();
        
        if (keyBytes != null) {
            // æœ‰Keyçš„æ¶ˆæ¯ï¼šè€ƒè™‘è´Ÿè½½åçš„å“ˆå¸Œåˆ†åŒº
            return getBalancedHashPartition(new String(keyBytes), partitionCount);
        } else {
            // æ— Keyçš„æ¶ˆæ¯ï¼šé€‰æ‹©è´Ÿè½½æœ€è½»çš„åˆ†åŒº
            return getLeastLoadedPartition(partitionCount);
        }
    }
    
    private int getBalancedHashPartition(String key, int partitionCount) {
        // åŸºç¡€å“ˆå¸Œåˆ†åŒº
        int hashPartition = Math.abs(key.hashCode()) % partitionCount;
        
        // æ£€æŸ¥è¯¥åˆ†åŒºæ˜¯å¦è¿‡è½½
        PartitionMetrics metrics = partitionMetrics.get(hashPartition);
        if (metrics != null && metrics.isOverloaded()) {
            // è¿‡è½½æ—¶é€‰æ‹©ç›¸é‚»çš„è½»è½½åˆ†åŒº
            return findAlternativePartition(hashPartition, partitionCount);
        }
        
        return hashPartition;
    }
    
    private int getLeastLoadedPartition(int partitionCount) {
        int bestPartition = 0;
        double minLoad = Double.MAX_VALUE;
        
        for (int i = 0; i < partitionCount; i++) {
            PartitionMetrics metrics = partitionMetrics.getOrDefault(i, new PartitionMetrics());
            double load = metrics.calculateLoadScore();
            
            if (load < minLoad) {
                minLoad = load;
                bestPartition = i;
            }
        }
        
        return bestPartition;
    }
    
    // åˆ†åŒºæŒ‡æ ‡æ”¶é›†
    private void updatePartitionMetrics() {
        // å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šä»JMXæˆ–ç›‘æ§ç³»ç»Ÿæ”¶é›†æŒ‡æ ‡
        // åŒ…æ‹¬ï¼šæ¶ˆæ¯é€Ÿç‡ã€å­—èŠ‚é€Ÿç‡ã€å»¶è¿Ÿç­‰
    }
    
    static class PartitionMetrics {
        private volatile long messageCount;
        private volatile long byteCount;  
        private volatile double avgLatency;
        private volatile long timestamp;
        
        public double calculateLoadScore() {
            // ç»¼åˆè´Ÿè½½è¯„åˆ†ç®—æ³•
            double messageScore = messageCount / 1000.0;  // æ¶ˆæ¯æ•°æƒé‡
            double byteScore = byteCount / (1024 * 1024.0);  // å­—èŠ‚æ•°æƒé‡  
            double latencyScore = avgLatency / 100.0;  // å»¶è¿Ÿæƒé‡
            
            return messageScore * 0.4 + byteScore * 0.4 + latencyScore * 0.2;
        }
        
        public boolean isOverloaded() {
            return calculateLoadScore() > 10.0;  // è´Ÿè½½é˜ˆå€¼
        }
    }
}
```

### 7.3 åˆ†åŒºé‡å¹³è¡¡ç­–ç•¥


**ğŸ”„ ä»€ä¹ˆæ—¶å€™éœ€è¦é‡å¹³è¡¡ï¼Ÿ**
```
è§¦å‘é‡å¹³è¡¡çš„åœºæ™¯ï¼š
âœ… æ–°å¢åˆ†åŒº
âœ… æ–°å¢æ¶ˆè´¹è€…
âœ… æ¶ˆè´¹è€…ä¸‹çº¿  
âœ… è´Ÿè½½ä¸¥é‡å€¾æ–œ
âœ… æ€§èƒ½æ˜¾è‘—ä¸‹é™
```

**ğŸ› ï¸ å¹³æ»‘é‡å¹³è¡¡å®ç°ï¼š**
```java
public class GradualRebalancePartitioner implements Partitioner {
    private volatile Map<String, Integer> keyToPartitionCache = new ConcurrentHashMap<>();
    private final AtomicInteger rebalanceProgress = new AtomicInteger(0);
    private final int REBALANCE_RATE = 100;  // æ¯100ä¸ªæ¶ˆæ¯è¿ç§»1ä¸ª
    
    @Override  
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        
        if (keyBytes == null) {
            return selectOptimalPartition(cluster.partitionsForTopic(topic).size());
        }
        
        String keyStr = new String(keyBytes);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸è¿›å¼é‡å¹³è¡¡
        if (shouldRebalance(keyStr)) {
            return performGradualRebalance(keyStr, cluster);
        }
        
        // æ­£å¸¸åˆ†åŒºé€»è¾‘
        return keyToPartitionCache.computeIfAbsent(keyStr, 
            k -> Math.abs(k.hashCode()) % cluster.partitionsForTopic(topic).size());
    }
    
    private boolean shouldRebalance(String key) {
        // æŒ‰ä¸€å®šæ¯”ä¾‹è¿›è¡Œæ¸è¿›å¼é‡å¹³è¡¡
        return rebalanceProgress.incrementAndGet() % REBALANCE_RATE == 0;
    }
    
    private int performGradualRebalance(String key, Cluster cluster) {
        // é‡æ–°è®¡ç®—åˆ†åŒºï¼Œä½†åªå¯¹éƒ¨åˆ†Keyç”Ÿæ•ˆ
        int newPartition = calculateOptimalPartition(key, cluster);
        keyToPartitionCache.put(key, newPartition);
        return newPartition;
    }
    
    private int calculateOptimalPartition(String key, Cluster cluster) {
        // åŸºäºå½“å‰è´Ÿè½½æƒ…å†µè®¡ç®—æœ€ä¼˜åˆ†åŒº
        // å®é™…å®ç°ä¼šè€ƒè™‘å„åˆ†åŒºçš„å®æ—¶è´Ÿè½½
        return Math.abs(key.hashCode()) % cluster.partitionsForTopic(topic).size();
    }
}
```

---

## 8. ğŸ“‹ æœ€ä½³å®è·µæ€»ç»“


### 8.1 åˆ†åŒºç­–ç•¥é€‰æ‹©æŒ‡å—


**ğŸ¯ æ ¹æ®ä¸šåŠ¡åœºæ™¯é€‰æ‹©åˆé€‚çš„åˆ†åŒºç­–ç•¥ï¼š**

| ä¸šåŠ¡ç±»å‹ | **æ¨èç­–ç•¥** | **å…³é”®è€ƒè™‘** | **ç¤ºä¾‹é…ç½®** |
|---------|-------------|-------------|------------|
| ğŸ“Š **æ—¥å¿—æ”¶é›†** | `è½®è¯¢/ç²˜æ€§åˆ†åŒº` | `è´Ÿè½½å‡è¡¡ä¼˜å…ˆ` | `æ— Keyæˆ–éšæœºKey` |
| ğŸ‘¤ **ç”¨æˆ·è¡Œä¸º** | `å“ˆå¸Œåˆ†åŒº(ç”¨æˆ·ID)` | `ç”¨æˆ·ä¼šè¯å®Œæ•´æ€§` | `Key=userId` |
| ğŸ›ï¸ **è®¢å•å¤„ç†** | `å“ˆå¸Œåˆ†åŒº(è®¢å•ID)` | `è®¢å•äº‹ä»¶æœ‰åº` | `Key=orderId` |
| ğŸª **å•†å“æ¨è** | `è‡ªå®šä¹‰åˆ†åŒºå™¨` | `æŒ‰ç±»åˆ«/åœ°åŒºåˆ†å‘` | `ä¸šåŠ¡é€»è¾‘åˆ†åŒº` |
| ğŸ’¸ **é‡‘èäº¤æ˜“** | `å“ˆå¸Œåˆ†åŒº(è´¦æˆ·ID)` | `è´¦æˆ·æ“ä½œæœ‰åºæ€§` | `Key=accountId` |

### 8.2 æ€§èƒ½ä¼˜åŒ–æ ¸å¿ƒè¦ç‚¹


**âš¡ å…³é”®æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š**

```java
// 1. æ‰¹é‡å‘é€ä¼˜åŒ–
Properties props = new Properties();
props.put("batch.size", 65536);           // 64KBæ‰¹æ¬¡å¤§å°
props.put("linger.ms", 10);               // ç­‰å¾…10msç§¯ç´¯æ‰¹æ¬¡
props.put("buffer.memory", 67108864);     // 64MBç¼“å†²åŒº

// 2. å‹ç¼©ç®—æ³•é€‰æ‹©
props.put("compression.type", "lz4");     // LZ4å‹ç¼©ï¼Œé€Ÿåº¦å¿«

// 3. åˆ†åŒºå™¨æ€§èƒ½é…ç½®
props.put("partitioner.class", "com.example.OptimizedPartitioner");

// 4. è¿æ¥æ± ä¼˜åŒ–  
props.put("connections.max.idle.ms", 300000);  // è¿æ¥ç©ºé—²æ—¶é—´
```

**ğŸ“Š ç›‘æ§å…³é”®æŒ‡æ ‡ï¼š**
```
ç”Ÿäº§ç«¯ç›‘æ§ï¼š
âœ… åˆ†åŒºæ¶ˆæ¯åˆ†å¸ƒå‡åŒ€åº¦
âœ… ç”Ÿäº§è€…å‘é€å»¶è¿Ÿ (avg, p95, p99)
âœ… æ‰¹æ¬¡å¤§å°å’Œå‘é€é¢‘ç‡
âœ… é”™è¯¯ç‡å’Œé‡è¯•æ¬¡æ•°

æ¶ˆè´¹ç«¯ç›‘æ§ï¼š
âœ… æ¶ˆè´¹è€…Lagåˆ†å¸ƒ
âœ… åˆ†åŒºå¤„ç†é€Ÿåº¦å·®å¼‚  
âœ… é‡å¹³è¡¡é¢‘ç‡
âœ… æ¶ˆè´¹å»¶è¿Ÿ
```

### 8.3 å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ


**ğŸš¨ é—®é¢˜1ï¼šæ•°æ®å€¾æ–œ**
```
ç°è±¡ï¼šæŸäº›åˆ†åŒºæ¶ˆæ¯ç‰¹åˆ«å¤š
åŸå› ï¼šçƒ­ç‚¹Keyæˆ–ä¸šåŠ¡é€»è¾‘å€¾æ–œ
è§£å†³ï¼š
1. çƒ­ç‚¹KeyåŠ éšæœºåç¼€åˆ†æ•£
2. è°ƒæ•´åˆ†åŒºé”®é€‰æ‹©ç­–ç•¥
3. å¢åŠ åˆ†åŒºæ•°é‡
4. ä½¿ç”¨è‡ªå®šä¹‰åˆ†åŒºå™¨
```

**ğŸš¨ é—®é¢˜2ï¼šé¡ºåºæ€§ä¸¢å¤±**
```  
ç°è±¡ï¼šç›¸å…³æ¶ˆæ¯åœ¨ä¸åŒåˆ†åŒºï¼Œå¤„ç†é¡ºåºæ··ä¹±
åŸå› ï¼šåˆ†åŒºé”®é€‰æ‹©ä¸å½“
è§£å†³ï¼š
1. ç¡®ä¿ç›¸å…³æ¶ˆæ¯ä½¿ç”¨ç›¸åŒåˆ†åŒºé”®
2. ä½¿ç”¨ä¸šåŠ¡å®ä½“IDä½œä¸ºKey
3. é¿å…éšæœºåˆ†åŒºé”®
```

**ğŸš¨ é—®é¢˜3ï¼šåˆ†åŒºè¿‡å¤šæˆ–è¿‡å°‘**
```
è¿‡å°‘é—®é¢˜ï¼šå¹¶å‘åº¦å—é™ï¼Œæ€§èƒ½ç“¶é¢ˆ
è¿‡å¤šé—®é¢˜ï¼šç®¡ç†å¼€é”€å¤§ï¼Œæ¶ˆè´¹è€…åˆ©ç”¨ç‡ä½

ç»éªŒå…¬å¼ï¼š
åˆ†åŒºæ•° = max(é¢„æœŸååé‡/å•åˆ†åŒºååé‡, æ¶ˆè´¹è€…æ•°é‡)

å…¸å‹é…ç½®ï¼š
å°å‹åº”ç”¨ï¼š3-6ä¸ªåˆ†åŒº
ä¸­å‹åº”ç”¨ï¼š10-20ä¸ªåˆ†åŒº  
å¤§å‹åº”ç”¨ï¼š50-100ä¸ªåˆ†åŒº
```

### 8.4 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æ£€æŸ¥æ¸…å•


**âœ… ä¸Šçº¿å‰æ£€æŸ¥é¡¹ï¼š**

```markdown
ğŸ”¸ åˆ†åŒºç­–ç•¥éªŒè¯
  - [ ] åˆ†åŒºé”®é€‰æ‹©åˆç†æ€§æµ‹è¯•
  - [ ] è´Ÿè½½åˆ†å¸ƒå‡åŒ€æ€§éªŒè¯
  - [ ] çƒ­ç‚¹åˆ†åŒºæ£€æµ‹å’Œå¤„ç†

ğŸ”¸ æ€§èƒ½åŸºå‡†æµ‹è¯•  
  - [ ] å•åˆ†åŒºååé‡æµ‹è¯•
  - [ ] å¤šåˆ†åŒºå¹¶å‘æµ‹è¯•
  - [ ] å»¶è¿Ÿæ€§èƒ½æµ‹è¯•

ğŸ”¸ ç›‘æ§å’Œå‘Šè­¦é…ç½®
  - [ ] åˆ†åŒºè´Ÿè½½ç›‘æ§
  - [ ] æ¶ˆè´¹è€…Lagå‘Šè­¦  
  - [ ] é”™è¯¯ç‡å’Œé‡è¯•ç›‘æ§

ğŸ”¸ å®¹é”™å’Œæ¢å¤
  - [ ] åˆ†åŒºæ•…éšœè½¬ç§»æµ‹è¯•
  - [ ] æ•°æ®ä¸€è‡´æ€§éªŒè¯
  - [ ] é‡å¹³è¡¡å½±å“è¯„ä¼°
```

### 8.5 æ ¸å¿ƒçŸ¥è¯†è¦ç‚¹å›é¡¾


**ğŸ¯ å¿…é¡»è®°ä½çš„å…³é”®æ¦‚å¿µï¼š**

```
ğŸ”‘ æ ¸å¿ƒåŸç†ï¼š
â€¢ åˆ†åŒºç­–ç•¥å†³å®šæ¶ˆæ¯åˆ†å¸ƒ
â€¢ ç›¸åŒKeyæ°¸è¿œè¿›å…¥ç›¸åŒåˆ†åŒº  
â€¢ åˆ†åŒºå†…æ¶ˆæ¯ä¸¥æ ¼æœ‰åº
â€¢ åˆ†åŒºæ•°å†³å®šæœ€å¤§å¹¶å‘åº¦

ğŸ› ï¸ å®è·µè¦ç‚¹ï¼š
â€¢ æ ¹æ®ä¸šåŠ¡é€‰æ‹©åˆé€‚çš„åˆ†åŒºç­–ç•¥
â€¢ é¿å…çƒ­ç‚¹Keyå’Œæ•°æ®å€¾æ–œ
â€¢ ç›‘æ§åˆ†åŒºè´Ÿè½½å‡è¡¡æƒ…å†µ
â€¢ åˆç†è®¾ç½®åˆ†åŒºæ•°é‡

âš¡ æ€§èƒ½ä¼˜åŒ–ï¼š
â€¢ ä½¿ç”¨æ‰¹é‡å‘é€æé«˜ååé‡
â€¢ é€‰æ‹©åˆé€‚çš„å‹ç¼©ç®—æ³•
â€¢ ç›‘æ§å…³é”®æ€§èƒ½æŒ‡æ ‡
â€¢ å®šæœŸè¯„ä¼°å’Œè°ƒæ•´ç­–ç•¥
```

**ğŸ’¡ è®°å¿†å£è¯€ï¼š**
```
åˆ†åŒºç­–ç•¥è¦é€‰å¥½ï¼Œè´Ÿè½½å‡è¡¡å¾ˆé‡è¦
ç›¸åŒKeyåŒåˆ†åŒºï¼Œæ¶ˆæ¯æœ‰åºä¸ä¼šä¹±  
çƒ­ç‚¹é—®é¢˜è¦é¢„é˜²ï¼Œç›‘æ§æŒ‡æ ‡ä¸èƒ½å¿˜
æ€§èƒ½ä¼˜åŒ–æ­¥æ­¥æ¥ï¼Œç”Ÿäº§ç¯å¢ƒç¨³å¦‚å±±
```

---

## ğŸ“– å»¶ä¼¸é˜…è¯»


- ğŸ“š **Kafkaå®˜æ–¹æ–‡æ¡£**: [Producer Configuration](https://kafka.apache.org/documentation/#producerconfigs)
- ğŸ”§ **åˆ†åŒºå™¨æ¥å£**: `org.apache.kafka.clients.producer.Partitioner`
- ğŸ“Š **ç›‘æ§å·¥å…·**: Kafka Manager, Confluent Control Center
- ğŸ› ï¸ **æ€§èƒ½æµ‹è¯•**: kafka-producer-perf-test.sh

**ğŸ”— ç›¸å…³ç« èŠ‚é“¾æ¥ï¼š**
- [ä¸Šä¸€ç« ï¼šProducer APIè¯¦è§£](#17-producer-api)  
- [ä¸‹ä¸€ç« ï¼šProduceræ€§èƒ½ä¼˜åŒ–](#19-producer-performance)
- [ç›¸å…³ï¼šæ¶ˆè´¹è€…åˆ†åŒºåˆ†é…ç­–ç•¥](#consumer-partition-assignment)