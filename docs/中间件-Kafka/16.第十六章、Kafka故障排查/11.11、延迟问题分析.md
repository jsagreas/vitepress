---
title: 11、延迟问题分析
---
## 📚 目录

1. [延迟问题概述](#1-延迟问题概述)
2. [网络层面延迟问题](#2-网络层面延迟问题)
3. [存储层面延迟问题](#3-存储层面延迟问题)
4. [JVM与内存延迟问题](#4-JVM与内存延迟问题)
5. [并发与线程延迟问题](#5-并发与线程延迟问题)
6. [缓存与序列化延迟问题](#6-缓存与序列化延迟问题)
7. [副本同步延迟问题](#7-副本同步延迟问题)
8. [客户端延迟问题](#8-客户端延迟问题)
9. [外部依赖延迟问题](#9-外部依赖延迟问题)
10. [监控与安全延迟问题](#10-监控与安全延迟问题)
11. [综合诊断与解决策略](#11-综合诊断与解决策略)

---

## 1. 🎯 延迟问题概述


### 1.1 什么是Kafka延迟问题


**🔸 延迟的含义**
```
简单理解：延迟就是"等待时间"
- 生产者发送消息到消息真正被消费的时间差
- 用户感受：点击按钮后要等很久才看到结果
- 技术角度：从请求发出到响应返回的时间间隔
```

**💡 延迟问题的表现**
```
用户体验层面：
• 页面加载慢，用户等待时间长
• 实时数据更新不及时
• 系统响应迟缓，操作卡顿

系统指标层面：
• 消息端到端延迟超过预期
• 生产者发送延迟增高
• 消费者消费延迟增大
• 集群间数据同步延迟
```

### 1.2 延迟问题的分类


**📊 按照发生位置分类**
```
┌─────────────────────────────────────────────────┐
│                Kafka延迟链路                    │
├─────────────────────────────────────────────────┤
│ 客户端 → 网络 → Broker → 存储 → 副本 → 消费者    │
│   ↑        ↑       ↑        ↑       ↑       ↑   │
│  应用     网络   服务端    磁盘    同步    客户端 │
│ 延迟     延迟     延迟     延迟    延迟    延迟   │
└─────────────────────────────────────────────────┘
```

**🎯 按照影响程度分类**
- **🔴 严重延迟**：秒级以上，用户明显感知
- **🟡 中等延迟**：百毫秒级，影响体验
- **🟢 轻微延迟**：毫秒级，基本可接受

### 1.3 延迟问题诊断的基本思路


**🔧 诊断步骤**
```
1. 现象确认 → 延迟确实存在，量化指标
2. 范围定位 → 哪个环节出现问题
3. 原因分析 → 为什么会出现延迟
4. 解决方案 → 如何解决或优化
5. 效果验证 → 解决方案是否有效
```

> **💡 核心理解**
> 延迟问题就像交通堵车，可能是某个路段有问题，也可能是整个路网设计有缺陷。我们需要找到真正的"堵点"在哪里。

---

## 2. 🌐 网络层面延迟问题


### 2.1 网络延迟过高的表现


**📈 典型症状**
```
监控指标异常：
• network.io 指标飙高
• 连接建立时间增长
• 数据包丢失率上升
• ping 延迟明显增加

用户感受：
• 消息发送后很久才收到确认
• 消费者拉取消息耗时长
• 集群节点间同步缓慢
```

### 2.2 网络延迟的常见原因


**🔸 网络基础设施问题**
```
物理层面：
• 网线老化或接触不良
• 交换机端口故障
• 路由器配置错误
• 带宽不足，网络拥塞

逻辑层面：
• 防火墙规则过于复杂
• 负载均衡器配置不当
• DNS解析慢
• 跨地域网络质量差
```

**🔸 Kafka网络配置问题**
```
缓冲区设置：
• socket.receive.buffer.bytes 过小
• socket.send.buffer.bytes 过小
• num.network.threads 不足

连接管理：
• connections.max.idle.ms 设置不当
• max.connections.per.ip 过低
```

### 2.3 网络延迟诊断方法


**⚡ 快速诊断命令**
```bash
# 检查网络延迟
ping broker-host

# 检查端口连通性
telnet broker-host 9092

# 查看网络统计
netstat -i
ss -tuln

# 检查网络吞吐量
iftop -i eth0
```

**📊 详细网络分析**
```bash
# 抓包分析网络延迟
tcpdump -i eth0 host broker-host -w kafka-network.pcap

# 查看TCP连接状态
ss -ant | grep 9092

# 监控网络带宽使用
nload -u M
```

### 2.4 网络延迟解决方案


**🔧 优化网络配置**
```properties
# Broker端网络优化
socket.receive.buffer.bytes=102400
socket.send.buffer.bytes=102400
num.network.threads=8
num.io.threads=16

# 增加网络线程数以处理更多并发连接
# 接收缓冲区：增大可减少网络往返次数
# 发送缓冲区：增大可提高批量发送效率
```

**🎯 基础设施优化**
```
硬件层面：
• 升级网络设备到千兆或万兆
• 检查网线质量，使用CAT6以上标准
• 优化交换机配置，启用流控

软件层面：
• 调整操作系统网络参数
• 优化防火墙规则
• 使用更快的DNS服务器
```

**📋 操作系统网络调优**
```bash
# 增加TCP缓冲区大小
echo 'net.core.rmem_max = 134217728' >> /etc/sysctl.conf
echo 'net.core.wmem_max = 134217728' >> /etc/sysctl.conf

# 优化TCP连接参数
echo 'net.ipv4.tcp_rmem = 4096 87380 134217728' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_wmem = 4096 65536 134217728' >> /etc/sysctl.conf

# 应用配置
sysctl -p
```

---

## 3. 💾 存储层面延迟问题


### 3.1 磁盘响应时间长的原因


**🔸 硬件层面问题**
```
磁盘类型影响：
• 机械硬盘：寻道时间长，随机IO性能差
• 固态硬盘：虽然快，但也有性能上限
• 网络存储：额外的网络延迟

磁盘健康状态：
• 坏道或即将损坏的扇区
• 磁盘碎片化严重
• 磁盘使用率接近100%
```

**🔸 文件系统和配置问题**
```
文件系统选择：
• ext4 vs xfs 性能差异
• 挂载参数不当（如使用了同步写入）
• 没有禁用访问时间更新

Kafka配置问题：
• log.flush.interval.ms 设置过小
• 刷盘策略过于频繁
• segment文件大小不合理
```

### 3.2 磁盘性能诊断


**📊 磁盘IO监控**
```bash
# 实时查看磁盘IO情况
iostat -x 1

# 查看具体进程的磁盘使用
iotop -ao

# 检查磁盘使用率
df -h

# 查看inode使用情况
df -i
```

**🔍 详细磁盘分析**
```bash
# 测试磁盘读写性能
# 顺序写测试
dd if=/dev/zero of=/kafka/testfile bs=1M count=1000 oflag=direct

# 顺序读测试  
dd if=/kafka/testfile of=/dev/null bs=1M iflag=direct

# 随机IO测试（需要安装fio）
fio -name=random-rw -ioengine=posixaio -rw=randrw -bs=4k -size=1G -numjobs=4
```

### 3.3 存储延迟解决方案


**⚡ 硬件优化**
```
存储升级：
• 使用SSD替代机械硬盘
• 配置RAID提高性能和可靠性
• 增加内存作为文件系统缓存

磁盘配置：
• 为Kafka日志和系统分区分离
• 使用独立磁盘存储不同类型数据
• 配置合适的RAID级别
```

**🔧 文件系统优化**
```bash
# 优化挂载参数
mount -o noatime,nodiratime /dev/sdb1 /kafka/logs

# /etc/fstab 中的推荐配置
/dev/sdb1 /kafka/logs ext4 noatime,nodiratime,nobarrier 0 2
```

**📝 Kafka存储配置优化**
```properties
# 减少刷盘频率，提高性能
log.flush.interval.messages=100000
log.flush.interval.ms=30000

# 合理设置segment大小
log.segment.bytes=1073741824

# 优化压缩设置
compression.type=lz4

# 调整批量大小
batch.size=32768
```

> **⚠️ 注意事项**
> 减少刷盘频率会增加数据丢失风险，需要根据业务要求权衡性能和可靠性。

---

## 4. ☕ JVM与内存延迟问题


### 4.1 JVM垃圾回收暂停过长


**🔸 GC暂停的影响**
```
什么是GC暂停：
• Java程序定期清理不用的内存对象
• 清理期间程序会"停下来"等待
• 就像大扫除时要停止正常工作

对Kafka的影响：
• Broker无法处理新请求
• 客户端连接可能超时
• 副本同步出现延迟
• 监控指标出现波动
```

**📊 GC问题的表现**
```
日志中的典型现象：
• Full GC频繁出现
• GC暂停时间超过1秒
• 内存使用率持续高位
• OutOfMemoryError错误

性能指标异常：
• 请求响应时间尖刺
• CPU使用率周期性波动
• 吞吐量周期性下降
```

### 4.2 GC问题诊断方法


**🔍 GC日志分析**
```bash
# 启用详细GC日志
-XX:+PrintGC
-XX:+PrintGCDetails  
-XX:+PrintGCTimeStamps
-Xloggc:/var/log/kafka/gc.log

# 分析GC日志关键信息
grep "Full GC" /var/log/kafka/gc.log
grep "promotion failed" /var/log/kafka/gc.log
```

**📈 内存使用监控**
```bash
# 查看Java进程内存使用
jstat -gc <kafka-pid> 250

# 查看堆内存详情
jmap -heap <kafka-pid>

# 生成堆转储进行分析
jmap -dump:live,format=b,file=kafka-heap.hprof <kafka-pid>
```

### 4.3 JVM优化解决方案


**🎯 堆内存配置优化**
```bash
# 推荐的JVM参数配置
export KAFKA_HEAP_OPTS="-Xms6g -Xmx6g"

# GC算法选择（推荐G1GC）
export KAFKA_JVM_PERFORMANCE_OPTS="-XX:+UseG1GC -XX:MaxGCPauseMillis=200"

# 详细优化参数
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=16m
-XX:G1NewSizePercent=35
-XX:G1MaxNewSizePercent=75
```

**💡 内存分配策略**
```
堆内存大小原则：
• 通常设置为物理内存的50-75%
• 为操作系统和PageCache留足空间
• Xms和Xmx设置相同，避免动态调整

GC算法选择：
• G1GC：适合大堆内存，暂停时间可预测
• CMS：适合延迟敏感应用（较老的JVM）
• ZGC/Shenandoah：超低延迟需求（新版JVM）
```

**📋 监控和调优循环**
```
调优步骤：
1. 基线测试 → 记录当前性能指标
2. 参数调整 → 逐步调整关键参数
3. 压力测试 → 验证调整效果
4. 生产验证 → 小范围部署验证
5. 全面应用 → 推广到整个集群
```

---

## 5. 🔄 并发与线程延迟问题


### 5.1 线程竞争导致延迟


**🔸 什么是线程竞争**
```
简单理解：
• 多个线程同时想使用同一个资源
• 就像多人同时想进同一扇门
• 结果是大家都要排队等待

在Kafka中的表现：
• 生产者线程等待网络线程处理
• 消费者线程等待IO线程读取数据  
• 副本同步线程等待磁盘写入完成
```

**📊 线程竞争的症状**
```
系统层面：
• CPU使用率高但吞吐量不高
• 线程池队列积压严重
• 大量线程处于BLOCKED状态
• 上下文切换频繁

应用层面：
• 请求处理时间不稳定
• 批量操作效率低下
• 偶发性超时错误
```

### 5.2 线程问题诊断


**🔍 线程状态分析**
```bash
# 查看Java线程状态
jstack <kafka-pid> > kafka-threads.dump

# 分析线程转储
grep -A 10 "BLOCKED" kafka-threads.dump
grep -c "waiting for monitor entry" kafka-threads.dump

# 监控线程池状态
jconsole # 图形化工具连接到Kafka进程
```

**📈 性能指标监控**
```bash
# 查看上下文切换
vmstat 1

# 查看线程数量
ps -eLf | grep kafka | wc -l

# 查看负载情况
top -H -p <kafka-pid>
```

### 5.3 线程优化解决方案


**⚡ 线程池配置优化**
```properties
# 网络线程数量调整
num.network.threads=8

# IO线程数量调整  
num.io.threads=16

# 副本同步线程
num.replica.fetchers=4

# 后台线程数量
background.threads=10
```

**🎯 线程数量计算原则**
```
网络线程数量：
• 推荐：CPU核数 × 2
• 处理客户端连接和请求解析
• 过多会增加上下文切换开销

IO线程数量：
• 推荐：磁盘数量 × 2
• 处理磁盘读写操作
• 与存储设备数量相关

副本线程数量：
• 推荐：4-8个
• 根据副本数量和网络条件调整
• 过多可能造成网络拥塞
```

**🔧 避免线程竞争的最佳实践**
```
设计层面：
• 减少共享状态
• 使用无锁数据结构
• 合理分区数据

配置层面：
• 避免线程数量过多
• 合理设置队列大小
• 优化批处理大小
```

---

## 6. 🗄️ 缓存与序列化延迟问题


### 6.1 缓存命中率低


**🔸 缓存的作用**
```
简单理解：
• 缓存就像书桌上的常用文具
• 需要时不用去柜子里翻找
• Kafka也会把常用数据放在内存里

Kafka的缓存类型：
• PageCache：操作系统文件缓存
• JVM堆内缓存：应用程序缓存
• 网络连接缓存：复用TCP连接
```

**📉 缓存命中率低的表现**
```
系统指标：
• 磁盘读取频繁
• 内存使用率偏低
• IO等待时间长
• 网络连接频繁建立

业务影响：
• 消费者读取数据慢
• 历史消息查询慢
• 副本同步效率低
```

### 6.2 缓存优化策略


**💾 操作系统缓存优化**
```bash
# 查看PageCache使用情况
free -h
cat /proc/meminfo | grep -E "Cached|Buffers"

# 优化缓存参数
echo 'vm.dirty_ratio = 15' >> /etc/sysctl.conf
echo 'vm.dirty_background_ratio = 5' >> /etc/sysctl.conf
```

**🔧 Kafka缓存配置**
```properties
# 设置适当的segment保留时间
log.retention.hours=168

# 配置合理的segment大小
log.segment.bytes=1073741824

# 优化索引缓存
log.index.size.max.bytes=10485760
```

### 6.3 数据序列化开销大


**🔸 序列化性能影响**
```
什么是序列化：
• 把Java对象转换成字节数组的过程
• 就像把家具拆解后装箱运输
• 拆装过程需要时间和人力

性能影响：
• CPU使用率增加
• 消息处理延迟增加
• 网络传输开销增大
• 内存使用增加
```

**⚡ 序列化格式对比**

| 序列化格式 | **性能** | **压缩率** | **兼容性** | **推荐场景** |
|-----------|----------|-----------|-----------|-------------|
| `JSON` | `低` | `差` | `优秀` | `开发测试` |
| `Avro` | `高` | `好` | `好` | `生产推荐` |
| `Protobuf` | `高` | `好` | `优秀` | `跨语言` |
| `Kryo` | `极高` | `中` | `Java限定` | `Java环境` |

**🎯 序列化优化建议**
```java
// 推荐使用高效序列化器
Properties props = new Properties();
props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
props.put("value.serializer", "io.confluent.kafka.serializers.KafkaAvroSerializer");

// 启用压缩减少网络传输
props.put("compression.type", "lz4");
```

---

## 7. 🔄 副本同步延迟问题


### 7.1 副本同步等待时间长


**🔸 副本同步的机制**
```
副本同步过程：
1. Leader接收到消息
2. Follower主动拉取Leader的消息  
3. Leader等待足够的Follower确认
4. 返回确认给生产者

同步方式影响：
• 同步副本（ISR）：必须等待确认
• 异步副本：不需要等待确认
• acks参数：决定等待多少个确认
```

**⏱️ 副本延迟的表现**
```
监控指标异常：
• replica.lag.time.max.ms 超标
• under-replicated-partitions 不为0
• isr-shrinks 频繁发生
• leader-election 次数增多

业务影响：
• 写入延迟增加
• 数据一致性风险
• 可用性下降
```

### 7.2 副本同步优化


**🔧 副本配置优化**
```properties
# 副本同步超时设置
replica.lag.time.max.ms=30000

# 副本获取大小
replica.fetch.max.bytes=1048576

# 副本获取等待时间
replica.fetch.wait.max.ms=500

# ISR收缩配置
unclean.leader.election.enable=false
```

**⚡ 网络优化**
```properties
# 副本同步线程数
num.replica.fetchers=4

# 网络接收缓冲区
replica.socket.receive.buffer.bytes=65536

# 减少网络往返
fetch.purgatory.purge.interval.requests=1000
```

**🎯 生产者配置协调**
```properties
# 确认级别设置
acks=1  # 或者 acks=all，根据可靠性需求

# 批量发送优化
batch.size=16384
linger.ms=5

# 重试配置
retries=3
retry.backoff.ms=100
```

---

## 8. 👥 客户端延迟问题


### 8.1 客户端重试导致延迟


**🔸 重试机制的作用**
```
为什么需要重试：
• 网络偶尔不稳定
• Broker临时忙碌
• Leader切换过程中的短暂不可用

重试的副作用：
• 增加整体延迟
• 可能导致消息重复
• 增加系统负载
• 影响消息顺序
```

**📊 重试问题的诊断**
```bash
# 查看生产者重试统计
kafka-run-class.sh kafka.tools.JmxTool \
  --object-name kafka.producer:type=producer-metrics,client-id=* \
  --attributes record-retry-rate

# 查看消费者重试
kafka-run-class.sh kafka.tools.JmxTool \
  --object-name kafka.consumer:type=consumer-fetch-manager-metrics,client-id=*
```

### 8.2 客户端优化策略


**⚡ 生产者优化**
```java
Properties props = new Properties();

// 合理设置重试参数
props.put("retries", 3);
props.put("retry.backoff.ms", 100);

// 优化批量发送
props.put("batch.size", 32768);
props.put("linger.ms", 5);

// 设置合理超时
props.put("request.timeout.ms", 30000);
props.put("delivery.timeout.ms", 120000);
```

**🔍 消费者优化**
```java
Properties props = new Properties();

// 设置合理的拉取大小
props.put("fetch.min.bytes", 1);
props.put("fetch.max.wait.ms", 500);
props.put("max.partition.fetch.bytes", 1048576);

// 优化提交策略
props.put("enable.auto.commit", "false");
// 手动提交，减少不必要的网络往返
```

**🎯 连接池优化**
```java
// 复用连接，减少连接建立开销
props.put("connections.max.idle.ms", 540000);
props.put("reconnect.backoff.ms", 50);
props.put("reconnect.backoff.max.ms", 1000);
```

---

## 9. 🔗 外部依赖延迟问题


### 9.1 负载均衡器延迟


**🔸 负载均衡器的影响**
```
常见延迟来源：
• 健康检查频率过高
• 连接超时设置过长
• 算法选择不当（如轮询vs最少连接）
• SSL终止处理

典型表现：
• 连接建立时间长
• 间歇性连接失败
• 不均匀的负载分布
```

**🔧 负载均衡器优化**
```
配置优化：
• 调整健康检查间隔
• 优化超时设置
• 选择合适的负载均衡算法
• 启用连接复用

架构优化：
• 考虑去除负载均衡器
• 使用客户端直连
• 部署多个负载均衡器实例
```

### 9.2 数据库连接延迟


**🔸 数据库依赖的场景**
```
常见使用场景：
• 存储消费者offset
• 用户认证信息查询
• 业务数据关联查询
• 监控数据存储

延迟产生原因：
• 连接池配置不当
• SQL查询性能差
• 数据库负载过高
• 网络延迟
```

**⚡ 数据库连接优化**
```java
// 连接池配置示例
HikariConfig config = new HikariConfig();
config.setMaximumPoolSize(20);
config.setMinimumIdle(5);
config.setConnectionTimeout(30000);
config.setIdleTimeout(600000);
config.setMaxLifetime(1800000);
```

**🎯 查询优化策略**
```
SQL优化：
• 使用索引加速查询
• 避免复杂的JOIN操作
• 使用批量操作
• 实施查询缓存

架构优化：
• 读写分离
• 使用Redis等缓存
• 异步处理非关键查询
• 数据预聚合
```

---

## 10. 📊 监控与安全延迟问题


### 10.1 监控采集影响性能


**🔸 监控的性能开销**
```
监控数据收集：
• JMX指标采集占用CPU
• 日志写入占用磁盘IO
• 网络指标传输占用带宽
• 频繁的状态检查

过度监控的后果：
• 系统负载增加
• 影响正常业务处理
• 监控数据本身产生噪音
• 存储成本增加
```

**⚖️ 监控策略平衡**
```
核心指标优先：
• 吞吐量、延迟、错误率
• 资源使用率（CPU、内存、磁盘）
• 业务关键指标

采集频率优化：
• 核心指标：秒级采集
• 一般指标：分钟级采集
• 诊断指标：按需采集
```

### 10.2 安全认证开销大


**🔸 安全机制的性能影响**
```
认证开销：
• SASL认证握手过程
• SSL/TLS加密解密
• ACL权限检查
• Token验证

性能影响：
• 连接建立时间增加
• CPU使用率上升
• 网络传输开销增大
• 内存使用增加
```

**🔧 安全性能优化**
```properties
# SSL优化配置
ssl.cipher.suites=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
ssl.enabled.protocols=TLSv1.2
ssl.session.cache.size=1000
ssl.session.timeout.ms=300000

# SASL优化
sasl.login.refresh.buffer.seconds=300
sasl.login.refresh.min.period.seconds=60
```

**🎯 安全与性能平衡**
```
优化策略：
• 使用硬件加速SSL
• 选择高效的加密算法
• 启用连接复用
• 合理设置缓存时间

架构考虑：
• 在负载均衡器层面终止SSL
• 内网传输可考虑降低安全级别
• 使用专门的安全代理
```

---

## 11. 🎯 综合诊断与解决策略


### 11.1 延迟问题诊断流程


**📋 系统化诊断步骤**
```
第一步：问题确认
• 量化延迟指标
• 确定影响范围
• 收集相关日志

第二步：快速定位
• 检查系统资源使用
• 查看错误日志
• 分析监控指标

第三步：深入分析
• 端到端链路追踪
• 压力测试验证
• 配置参数检查

第四步：制定方案
• 列出可能的解决方案
• 评估改动风险
• 制定回滚计划

第五步：实施验证
• 小范围测试
• 逐步推广
• 持续监控效果
```

### 11.2 常用诊断工具和命令


**🔧 系统级诊断工具**
```bash
# 快速系统概览
htop
iostat -x 1
free -h
df -h

# 网络诊断
ss -tuln | grep 9092
ping broker-host
telnet broker-host 9092

# 进程诊断
jstack <kafka-pid>
jstat -gc <kafka-pid>
lsof -p <kafka-pid>
```

**📊 Kafka专用工具**
```bash
# 性能测试
kafka-producer-perf-test.sh --topic test --num-records 100000 --record-size 100 --throughput 10000 --producer-props bootstrap.servers=localhost:9092

# 消费者性能测试
kafka-consumer-perf-test.sh --bootstrap-server localhost:9092 --topic test --messages 100000

# 主题详情查看
kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic test
```

### 11.3 性能优化最佳实践


**⭐ 关键配置参数总结**

| 配置类别 | **关键参数** | **推荐值** | **说明** |
|---------|-------------|-----------|----------|
| **网络** | `num.network.threads` | `CPU核数×2` | `处理网络请求` |
| **IO** | `num.io.threads` | `磁盘数×2` | `处理磁盘操作` |
| **内存** | `heap size` | `物理内存50-75%` | `JVM堆内存` |
| **存储** | `log.segment.bytes` | `1GB` | `日志分段大小` |
| **副本** | `num.replica.fetchers` | `4-8` | `副本同步线程` |

**🎯 优化优先级**
```
高优先级（立即见效）：
1. JVM参数调优
2. 磁盘和文件系统优化
3. 网络配置优化
4. 基础监控配置

中优先级（需要测试）：
1. 客户端参数调优
2. 副本配置优化
3. 压缩算法选择
4. 分区策略调整

低优先级（长期优化）：
1. 硬件升级
2. 架构调整
3. 业务逻辑优化
4. 运维流程改进
```

### 11.4 预防性措施


**🛡️ 监控和告警**
```
核心监控指标：
• End-to-end延迟：消息从生产到消费的时间
• Broker延迟：单个Broker的处理时间
• 网络延迟：网络传输耗时
• 磁盘延迟：磁盘IO响应时间

告警阈值设置：
• P99延迟超过100ms
• GC暂停时间超过1秒
• 磁盘使用率超过80%
• 网络丢包率超过0.1%
```

**📈 容量规划**
```
性能基线：
• 建立正常状态下的性能基线
• 定期进行性能回归测试
• 记录配置变更对性能的影响

扩容策略：
• 水平扩容：增加Broker节点
• 垂直扩容：升级硬件配置
• 分区优化：合理设计分区数量
• 负载均衡：优化数据分布
```

> **💡 核心记忆**
> 延迟问题的解决需要系统化思维：先定位问题出现的环节，再针对性优化。网络、存储、JVM、并发是四个主要关注点。记住"测试-调优-验证"的循环，不要一次改动太多参数。

**🔑 关键要点总结**
- 延迟问题往往是多个因素叠加的结果
- 优化时要有的放矢，避免过度优化
- 监控和测量是优化的基础
- 性能和可靠性需要平衡
- 预防胜于治疗，建立完善的监控体系