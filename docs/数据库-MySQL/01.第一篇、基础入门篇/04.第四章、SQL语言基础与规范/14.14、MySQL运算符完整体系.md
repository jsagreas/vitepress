---
title: 14、MySQL运算符完整体系
---
## 📚 目录

1. [MySQL运算符体系概览](#1-MySQL运算符体系概览)
2. [赋值运算符深度解析](#2-赋值运算符深度解析)
3. [比较运算符详解](#3-比较运算符详解)
4. [逻辑运算符应用](#4-逻辑运算符应用)
5. [算术运算符基础](#5-算术运算符基础)
6. [位运算符操作](#6-位运算符操作)
7. [特殊运算符处理技巧](#7-特殊运算符处理技巧)
8. [运算符优先级与组合](#8-运算符优先级与组合)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🏗️ MySQL运算符体系概览


### 1.1 运算符分类体系


MySQL运算符就像工具箱里的各种工具，每种都有特定的用途。理解这套"工具"的分类和用法，是写好SQL的基础。

**🔑 运算符完整分类体系**

```
MySQL运算符体系架构：
├── 算术运算符
│   ├── + - * / % (加减乘除取余)
│   └── DIV MOD (整除和取模)
├── 比较运算符
│   ├── = != <> < <= > >= (基本比较)
│   ├── <=> (NULL安全等于)
│   ├── BETWEEN...AND (范围比较)
│   ├── IN/NOT IN (集合成员)
│   └── IS NULL/IS NOT NULL (空值检查)
├── 逻辑运算符
│   ├── AND && (逻辑与)
│   ├── OR || (逻辑或)
│   ├── NOT ! (逻辑非)
│   └── XOR (逻辑异或)
├── 位运算符
│   ├── & | ^ (按位与或异或)
│   ├── << >> (左移右移)
│   └── ~ (按位取反)
├── 赋值运算符
│   ├── = (标准赋值)
│   └── := (强制赋值)
└── 模式匹配运算符
    ├── LIKE (通配符匹配)
    └── REGEXP/RLIKE (正则表达式)
```

### 1.2 运算符使用场景


**🎯 不同运算符的典型应用场景**

| 运算符类型 | **主要用途** | **常见场景** | **注意事项** |
|-----------|-------------|-------------|-------------|
| 📊 **算术** | `数值计算` | `价格计算、统计分析` | `除零错误、精度问题` |
| 🔍 **比较** | `条件判断` | `WHERE子句、连接条件` | `NULL值处理` |
| 🧠 **逻辑** | `条件组合` | `复杂查询条件` | `短路求值特性` |
| 🔧 **位操作** | `标志处理` | `权限管理、状态标记` | `数据类型限制` |
| ✏️ **赋值** | `变量设置` | `存储过程、函数` | `作用域问题` |
| 🔎 **模式** | `文本匹配` | `搜索、过滤` | `性能影响` |

---

## 2. ✏️ 赋值运算符深度解析


### 2.1 🔥 赋值运算符 := 和 = 区别


这两个符号看起来很像，但用法完全不同。简单理解：**:= 专门用来赋值，= 主要用来比较**。

**🔸 核心区别说明**

```sql
-- = 运算符：主要用于比较
SELECT * FROM users WHERE age = 25;  -- 比较：查找25岁的用户
SELECT @var = 10;  -- 返回比较结果：1或0

-- := 运算符：专门用于赋值
SET @var := 10;    -- 赋值：将10赋给变量@var
SELECT @var := age FROM users LIMIT 1;  -- 赋值：将查询结果赋给变量
```

**💡 实际应用对比**

```sql
-- ❌ 错误用法：在赋值时使用 =
SELECT @total = price * quantity FROM orders;  -- 这是比较，不是赋值！
-- 结果：@total可能是NULL，因为这是比较操作

-- ✅ 正确用法：使用 := 进行赋值  
SELECT @total := price * quantity FROM orders LIMIT 1;  -- 正确赋值
-- 结果：@total获得计算结果值

-- 实际示例
SET @counter := 0;  -- 初始化计数器
SELECT @counter := @counter + 1 AS row_number, 
       name, age 
FROM users;  -- 为每行添加行号
```

**⚠️ 特殊情况处理**

```sql
-- 在SET语句中，= 和 := 效果相同
SET @var = 10;     -- 可以用 =
SET @var := 10;    -- 也可以用 :=

-- 但在SELECT语句中必须用 :=
SELECT @var := 20;  -- ✅ 正确
SELECT @var = 20;   -- ❌ 这是比较，返回1或0
```

---

## 3. 🔍 比较运算符详解


### 3.1 🔥 NULL安全等于运算符 <=>


普通的等号 = 遇到NULL就"懵了"，而 <=> 是专门处理NULL的"专家"。

**🔸 <=> 运算符的特殊之处**

```sql
-- 普通等号 = 的问题
SELECT NULL = NULL;    -- 结果：NULL（不是TRUE！）
SELECT 5 = NULL;       -- 结果：NULL
SELECT NULL = 5;       -- 结果：NULL

-- NULL安全等于 <=> 的优势
SELECT NULL <=> NULL;  -- 结果：1（TRUE）
SELECT 5 <=> NULL;     -- 结果：0（FALSE）
SELECT 5 <=> 5;        -- 结果：1（TRUE）
```

**💡 实际应用场景**

```sql
-- 查找包含NULL值的记录
-- ❌ 错误方式：使用普通等号
SELECT * FROM users WHERE phone = NULL;  -- 永远查不到结果！

-- ✅ 正确方式1：使用IS NULL
SELECT * FROM users WHERE phone IS NULL;

-- ✅ 正确方式2：使用NULL安全等于
SELECT * FROM users WHERE phone <=> NULL;

-- 🎯 实际应用：比较两个可能为NULL的字段
SELECT * FROM users u1, users u2 
WHERE u1.phone <=> u2.backup_phone;  -- 包括都为NULL的情况
```

### 3.2 🔥 BETWEEN范围运算符


BETWEEN就像说"从这里到那里"，包含边界值的范围查询。

**🔸 BETWEEN运算符特点**

```sql
-- 基本语法：值 BETWEEN 最小值 AND 最大值
-- 等价于：值 >= 最小值 AND 值 <= 最大值

-- 数值范围查询
SELECT * FROM products WHERE price BETWEEN 100 AND 500;
-- 等价于：price >= 100 AND price <= 500

-- 日期范围查询
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';

-- 字符串范围查询（按字典序）
SELECT * FROM users WHERE name BETWEEN 'A' AND 'M';
```

**⚠️ BETWEEN使用注意事项**

```sql
-- 📋 注意事项清单：

-- ✅ 1. 包含边界值
SELECT * FROM users WHERE age BETWEEN 18 AND 65;  -- 包含18和65

-- ✅ 2. 范围顺序必须正确
SELECT * FROM products WHERE price BETWEEN 100 AND 500;  -- ✅ 正确
SELECT * FROM products WHERE price BETWEEN 500 AND 100;  -- ❌ 查不到结果

-- ✅ 3. 时间范围要注意精度
SELECT * FROM orders 
WHERE created_at BETWEEN '2024-01-01 00:00:00' AND '2024-01-01 23:59:59';

-- ✅ 4. 反向查询使用NOT BETWEEN
SELECT * FROM products WHERE price NOT BETWEEN 100 AND 500;
```

### 3.3 🔥 IN/NOT IN集合运算符


IN运算符就像问"这个值在不在这个列表里"，非常直观好用。

**🔸 IN运算符基本用法**

```sql
-- 基本语法：值 IN (值1, 值2, 值3, ...)
-- 等价于：值=值1 OR 值=值2 OR 值=值3

-- 查找指定城市的用户
SELECT * FROM users WHERE city IN ('北京', '上海', '深圳');

-- 查找特定状态的订单
SELECT * FROM orders WHERE status IN (1, 2, 5);  -- 待付款、已付款、已完成

-- 子查询配合使用
SELECT * FROM products 
WHERE category_id IN (
    SELECT id FROM categories WHERE name LIKE '%电子%'
);
```

**⚠️ IN运算符的NULL陷阱**

```sql
-- 🚨 NULL值的特殊处理
SELECT 1 IN (1, 2, 3);     -- 结果：1 (TRUE)
SELECT 4 IN (1, 2, 3);     -- 结果：0 (FALSE)  
SELECT NULL IN (1, 2, 3);  -- 结果：NULL（不是FALSE！）
SELECT 1 IN (1, 2, NULL);  -- 结果：1 (TRUE)
SELECT 4 IN (1, 2, NULL);  -- 结果：NULL（不是FALSE！）

-- 实际影响
SELECT * FROM users WHERE id NOT IN (1, 2, NULL);  
-- ❌ 危险：如果列表中有NULL，可能查不到任何结果！

-- ✅ 安全的处理方式
SELECT * FROM users 
WHERE id NOT IN (SELECT user_id FROM orders WHERE user_id IS NOT NULL);
```

---

## 4. 🔎 模式匹配运算符


### 4.1 🔥 LIKE模式匹配运算符


LIKE就像"模糊搜索"，可以用通配符来匹配文本模式。

**🔸 LIKE通配符说明**

| 通配符 | **含义** | **示例** | **匹配结果** |
|--------|---------|---------|-------------|
| `%` | `匹配0个或多个字符` | `'张%'` | `张三、张三丰、张` |
| `_` | `匹配1个字符` | `'张_'` | `张三、张四（但不匹配张三丰）` |
| `[]` | `匹配括号内任一字符` | `'[ABC]%'` | `A开头、B开头、C开头` |
| `[^]` | `不匹配括号内字符` | `'[^ABC]%'` | `不是A、B、C开头` |

**💡 LIKE实际应用示例**

```sql
-- 姓名模糊查询
SELECT * FROM users WHERE name LIKE '张%';        -- 所有姓张的
SELECT * FROM users WHERE name LIKE '%明%';       -- 名字包含"明"的
SELECT * FROM users WHERE name LIKE '张_';        -- 姓张且名字只有1个字

-- 邮箱格式检查
SELECT * FROM users WHERE email LIKE '%@%.com';   -- 简单邮箱格式

-- 手机号格式检查  
SELECT * FROM users WHERE phone LIKE '1[3-9]_________';  -- 11位手机号

-- 模糊搜索商品
SELECT * FROM products WHERE title LIKE '%iPhone%' OR title LIKE '%苹果%';
```

**🔒 LIKE性能优化技巧**

```sql
-- ⚡ 性能优化建议：

-- ❌ 避免前导通配符（无法使用索引）
SELECT * FROM users WHERE name LIKE '%张';  -- 慢查询

-- ✅ 尽量使用后导通配符（可以使用索引）
SELECT * FROM users WHERE name LIKE '张%';  -- 可以利用索引

-- ✅ 结合其他条件减少扫描范围
SELECT * FROM users 
WHERE city = '北京' AND name LIKE '张%';  -- 先过滤城市再模糊匹配
```

### 4.2 🔥 REGEXP正则表达式运算符


REGEXP是模式匹配的"高级版"，功能更强大但也更复杂。

**🔸 REGEXP基本语法**

```sql
-- 基本语法：字段 REGEXP '正则表达式'
-- 别名：RLIKE 和 REGEXP 完全相同

-- 基本字符匹配
SELECT * FROM users WHERE name REGEXP '^张';     -- 以"张"开头
SELECT * FROM users WHERE name REGEXP '明$';     -- 以"明"结尾
SELECT * FROM users WHERE name REGEXP '张.*明';   -- 包含"张"和"明"

-- 字符类匹配
SELECT * FROM users WHERE phone REGEXP '^1[3-9][0-9]{9}$';  -- 手机号验证
SELECT * FROM products WHERE code REGEXP '^[A-Z]{2}[0-9]{4}$';  -- 产品编码
```

**💡 REGEXP实用模式**

```sql
-- 📧 邮箱格式验证
SELECT email FROM users 
WHERE email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';

-- 📱 身份证号格式检查
SELECT id_card FROM users 
WHERE id_card REGEXP '^[1-9][0-9]{5}(19|20)[0-9]{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])[0-9]{3}[0-9Xx]$';

-- 🔢 IP地址格式验证
SELECT ip_address FROM logs 
WHERE ip_address REGEXP '^([0-9]{1,3}\.){3}[0-9]{1,3}$';

-- 🎯 多关键词搜索
SELECT * FROM articles 
WHERE content REGEXP 'MySQL|数据库|SQL';  -- 包含任一关键词
```

---

## 5. 🔍 空值处理运算符


### 5.1 🔥 IS NULL/IS NOT NULL空值检查


NULL是数据库中的"特殊公民"，需要特殊对待。普通的等号对它无效。

**🔸 NULL值的特殊性质**

```sql
-- NULL的奇特行为：
SELECT NULL = NULL;     -- 结果：NULL（不是TRUE！）
SELECT NULL != NULL;    -- 结果：NULL（不是FALSE！）
SELECT NULL > 5;        -- 结果：NULL
SELECT NULL + 10;       -- 结果：NULL

-- 💡 理解要点：NULL表示"未知"，任何与未知的比较都是未知
```

**✅ 正确的NULL检查方法**

```sql
-- ✅ 正确：使用IS NULL检查空值
SELECT * FROM users WHERE phone IS NULL;        -- 查找未填手机号的用户
SELECT * FROM orders WHERE cancelled_at IS NULL; -- 查找未取消的订单

-- ✅ 正确：使用IS NOT NULL检查非空值
SELECT * FROM users WHERE email IS NOT NULL;    -- 查找有邮箱的用户
SELECT * FROM products WHERE discount IS NOT NULL; -- 查找有折扣的商品

-- ❌ 错误：使用等号检查NULL
SELECT * FROM users WHERE phone = NULL;     -- 永远查不到结果！
SELECT * FROM users WHERE phone != NULL;    -- 也查不到结果！
```

**🔧 NULL值处理技巧**

```sql
-- 使用IFNULL处理NULL值
SELECT name, IFNULL(phone, '未填写') AS phone_display FROM users;

-- 使用COALESCE选择第一个非NULL值
SELECT name, COALESCE(mobile, phone, '无联系方式') AS contact FROM users;

-- 使用CASE语句处理NULL
SELECT name,
       CASE 
           WHEN phone IS NULL THEN '未填写手机号'
           WHEN phone = '' THEN '手机号为空'
           ELSE phone 
       END AS phone_status
FROM users;
```

### 5.2 NULL在不同运算符中的表现


**🔸 NULL值运算规则总结**

| 运算类型 | **含NULL的表达式** | **结果** | **说明** |
|---------|------------------|---------|---------|
| 🧮 **算术运算** | `NULL + 5` | `NULL` | `任何数与NULL运算都是NULL` |
| 🔍 **比较运算** | `NULL = 5` | `NULL` | `NULL不等于任何值，包括自己` |
| 🧠 **逻辑运算** | `NULL AND TRUE` | `NULL` | `三值逻辑：TRUE/FALSE/NULL` |
| 📊 **聚合函数** | `COUNT(NULL)` | `0` | `聚合函数会忽略NULL值` |
| 🔎 **模式匹配** | `NULL LIKE '%'` | `NULL` | `NULL不匹配任何模式` |

---

## 6. 🧠 逻辑运算符应用


### 6.1 基本逻辑运算符


**AND、OR、NOT的组合使用**

```sql
-- 复合条件查询
SELECT * FROM users 
WHERE age >= 18 AND age <= 65        -- 工作年龄段
  AND city IN ('北京', '上海', '深圳')  -- 一线城市
  AND phone IS NOT NULL;              -- 有联系方式

-- 多条件或查询
SELECT * FROM products 
WHERE category = '电子产品' 
   OR (category = '服装' AND price < 200)
   OR status = '促销';

-- 排除条件
SELECT * FROM orders 
WHERE NOT (status = '已取消' OR payment_status = '退款');
```

### 6.2 逻辑运算符优先级


**🔸 运算符优先级规则**

```
优先级从高到低：
1. () 括号
2. NOT, !
3. AND, &&  
4. OR, ||
5. XOR

记忆技巧：括号最高，NOT其次，AND比OR高
```

**💡 优先级实际应用**

```sql
-- ❌ 可能产生歧义
SELECT * FROM users WHERE age > 18 AND city = '北京' OR city = '上海';
-- 实际执行：(age > 18 AND city = '北京') OR city = '上海'
-- 可能不是我们想要的结果

-- ✅ 使用括号明确逻辑
SELECT * FROM users WHERE age > 18 AND (city = '北京' OR city = '上海');
-- 明确：年龄大于18且在北京或上海
```

---

## 7. 🔧 特殊运算符处理技巧


### 7.1 运算符与索引优化


不同运算符对查询性能的影响差别很大，选对运算符可以让查询"飞起来"。

**🔸 运算符性能影响对比**

| 运算符 | **索引利用** | **性能** | **优化建议** |
|--------|-------------|---------|-------------|
| `=` | `🟢最佳` | `🟢极快` | `优先使用精确匹配` |
| `>, <, >=, <=` | `🟢良好` | `🟢快速` | `范围查询性能良好` |
| `BETWEEN` | `🟢良好` | `🟢快速` | `等效于范围查询` |
| `IN` | `🟡中等` | `🟡中等` | `值少时性能好` |
| `LIKE 'prefix%'` | `🟢良好` | `🟢快速` | `前缀匹配可用索引` |
| `LIKE '%suffix'` | `🔴无法使用` | `🔴慢` | `全表扫描，避免使用` |
| `REGEXP` | `🔴无法使用` | `🔴慢` | `复杂匹配才使用` |

### 7.2 运算符类型转换


MySQL会自动进行类型转换，但有时候结果可能出乎意料。

**🔸 自动类型转换规则**

```sql
-- 字符串与数字比较
SELECT '123' = 123;        -- 结果：1（字符串转为数字）
SELECT '123abc' = 123;     -- 结果：1（字符串前缀转为数字）
SELECT 'abc' = 0;          -- 结果：1（非数字字符串转为0）

-- ⚠️ 可能的问题
SELECT * FROM users WHERE user_id = '123abc';  -- 可能匹配到id=123的用户！

-- ✅ 明确的类型处理
SELECT * FROM users WHERE user_id = CAST('123' AS UNSIGNED);
SELECT * FROM users WHERE CAST(user_id AS CHAR) = '123';
```

### 7.3 🔑 特殊运算符处理技巧


**处理特殊字符的转义**

```sql
-- LIKE中的特殊字符需要转义
SELECT * FROM articles WHERE title LIKE '%100\%优惠%';    -- 查找包含"100%优惠"
SELECT * FROM users WHERE name LIKE '张\_三';             -- 查找"张_三"（下划线是字面量）

-- 使用ESCAPE指定转义字符
SELECT * FROM articles WHERE title LIKE '%100$%优惠%' ESCAPE '$';
```

**性能优化的运算符使用**

```sql
-- ✅ 优化技巧1：使用UNION替代OR（某些情况下）
-- ❌ 较慢的OR查询
SELECT * FROM users WHERE name LIKE '张%' OR phone LIKE '138%';

-- ✅ 可能更快的UNION查询（如果有合适索引）
SELECT * FROM users WHERE name LIKE '张%'
UNION
SELECT * FROM users WHERE phone LIKE '138%';

-- ✅ 优化技巧2：利用索引覆盖
SELECT id, name FROM users WHERE name LIKE '张%';  -- 如果有(name, id)索引，性能更好
```

---

## 8. ⚖️ 运算符优先级与组合


### 8.1 完整优先级表


理解运算符优先级就像学数学的"先乘除后加减"，避免逻辑错误。

**🔸 MySQL运算符优先级排序（从高到低）**

```
优先级排序：
1. () 括号
2. ! NOT
3. ^ 异或
4. * / % DIV MOD 乘除模
5. + - 加减
6. << >> 位移
7. & 按位与
8. | 按位或
9. = <=> >= > <= < <> != IS LIKE REGEXP IN 比较运算符
10. BETWEEN CASE WHEN THEN ELSE
11. && AND 逻辑与
12. || OR 逻辑或
13. = := 赋值运算符
```

### 8.2 复杂表达式示例


```sql
-- 📝 复杂查询条件组合
SELECT * FROM orders o
JOIN users u ON o.user_id = u.id
WHERE u.age BETWEEN 25 AND 45           -- 年龄范围
  AND u.city IN ('北京', '上海')          -- 指定城市
  AND o.status NOT IN ('取消', '退款')    -- 排除特定状态
  AND o.total_amount >= 100             -- 金额门槛
  AND (
      o.payment_method = '支付宝' 
      OR (o.payment_method = '信用卡' AND u.credit_level >= 3)
  )                                     -- 支付方式条件
  AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)  -- 最近30天
  AND u.phone IS NOT NULL               -- 有联系方式
  AND u.email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';  -- 有效邮箱
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 赋值运算符：:= 专门赋值，= 主要比较，别搞混
🔸 NULL安全等于：<=> 是处理NULL的专用工具
🔸 范围运算符：BETWEEN包含边界，注意顺序
🔸 集合运算符：IN/NOT IN要小心NULL陷阱
🔸 模式匹配：LIKE用通配符，REGEXP用正则表达式
🔸 空值检查：IS NULL/IS NOT NULL是唯一正确方法
```

### 9.2 关键理解要点


**🔹 NULL的特殊性**
```
核心记忆：NULL不等于任何值，包括它自己
实际含义：NULL表示"未知"，而不是"空"
处理原则：专门的工具处理专门的问题
```

**🔹 运算符选择策略**
```
性能优先：= > BETWEEN > IN > LIKE前缀 > LIKE任意 > REGEXP
功能优先：根据实际需求选择合适的运算符
安全优先：注意NULL值处理和类型转换陷阱
```

**🔹 查询优化思路**
```
索引友好：优先使用能利用索引的运算符
条件排序：把选择性高的条件放前面
括号明确：复杂逻辑用括号明确优先级
```

### 9.3 实际应用指南


**📊 运算符使用建议矩阵**

| 使用场景 | **推荐运算符** | **避免使用** | **性能提示** |
|---------|--------------|-------------|-------------|
| 🎯 **精确查找** | `= != <>` | `LIKE REGEXP` | `最佳索引利用` |
| 📈 **范围查询** | `BETWEEN >= <=` | `OR条件组合` | `索引范围扫描` |
| 📝 **模糊搜索** | `LIKE前缀%` | `LIKE %后缀` | `前缀索引有效` |
| 🔍 **复杂匹配** | `REGEXP` | `多个LIKE OR` | `功能强但较慢` |
| ❓ **空值处理** | `IS NULL/NOT NULL` | `= NULL != NULL` | `NULL专用方法` |

### 9.4 最佳实践总结


```
🔸 编写可读性高的SQL：合理使用括号和缩进
🔸 考虑性能影响：选择索引友好的运算符
🔸 处理边界情况：特别注意NULL值和类型转换
🔸 测试验证逻辑：复杂条件要仔细测试
🔸 文档记录规范：团队开发中统一运算符使用规范
```

**核心记忆口诀**：
- 赋值认准冒号等，比较就用单等号
- NULL值检查IS专用，普通等号永远空
- BETWEEN包含两边界，IN要防NULL陷阱
- LIKE通配符要小心，REGEXP功能更强大
- 优先级记住AND比OR高，括号明确最重要