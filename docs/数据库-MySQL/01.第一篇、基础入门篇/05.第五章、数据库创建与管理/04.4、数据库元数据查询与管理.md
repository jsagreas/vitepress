---
title: 4、数据库元数据查询与管理
---
## 📚 目录

1. [元数据基础概念](#1-元数据基础概念)
2. [INFORMATION_SCHEMA详解](#2-INFORMATION_SCHEMA详解)
3. [表结构与索引信息查询](#3-表结构与索引信息查询)
4. [约束与统计信息管理](#4-约束与统计信息管理)
5. [元数据锁与版本管理](#5-元数据锁与版本管理)
6. [元数据管理实践](#6-元数据管理实践)
7. [自动化运维脚本](#7-自动化运维脚本)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🗄️ 元数据基础概念


### 1.1 什么是数据库元数据


**🔸 元数据的基本含义**
```
简单理解：元数据就是"关于数据的数据"

举个例子：
• 你有一张学生表students
• 表中存储的是学生信息（姓名、年龄、成绩）← 这是数据
• 但是"这张表叫什么名字、有哪些列、每列是什么类型" ← 这就是元数据

元数据包含的信息：
• 表名、列名、数据类型
• 索引信息、约束条件
• 用户权限、存储引擎
• 统计信息、配置参数
```

### 1.2 为什么元数据如此重要


**💡 元数据的作用**
```
开发阶段：
• 查看表结构：了解数据库设计
• 检查索引：优化查询性能
• 验证约束：确保数据完整性

运维阶段：
• 监控表大小：容量规划
• 分析性能：找出瓶颈
• 备份策略：了解重要数据

数据库管理：
• 权限管理：查看用户权限
• 版本管理：跟踪结构变更
• 故障排查：分析异常状况
```

### 1.3 MySQL元数据存储机制


**🏗️ MySQL元数据架构演进**
```
MySQL 5.7及以前：
数据字典存储在MyISAM表中
├── mysql.tables     （表信息）
├── mysql.columns    （列信息）  
├── mysql.indexes    （索引信息）
└── mysql.user       （用户信息）

MySQL 8.0开始：
数据字典存储在InnoDB表中（DDL原子性）
├── mysql.tables               （表信息）
├── mysql.columns              （列信息）
├── mysql.indexes              （索引信息）
├── mysql.foreign_keys         （外键信息）
└── mysql.check_constraints    （检查约束）

对用户的影响：
• 更好的事务性：DDL操作支持回滚
• 更高的并发性：减少元数据锁冲突
• 更强的一致性：避免元数据不一致
```

### 1.4 元数据访问方式对比


**📊 不同访问方式的特点**

| 访问方式 | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|-------------|
| **INFORMATION_SCHEMA** | `标准SQL，跨数据库兼容` | `查询较慢，信息有限` | `应用程序查询` |
| **SHOW命令** | `查询快速，信息全面` | `非标准SQL，格式固定` | `人工查询，脚本` |
| **mysql系统库** | `信息最全，性能最佳` | `版本相关，不推荐直接访问` | `深度定制，高级应用` |
| **PERFORMANCE_SCHEMA** | `性能信息丰富，实时监控` | `专门用于性能，学习成本高` | `性能调优，监控` |

---

## 2. 📊 INFORMATION_SCHEMA详解


### 2.1 INFORMATION_SCHEMA的本质


**🔸 什么是INFORMATION_SCHEMA**
```
本质理解：
INFORMATION_SCHEMA是一个"虚拟数据库"
• 不是真实存储的数据库
• 是MySQL提供的元数据查询接口
• 符合SQL标准，其他数据库也有类似实现

类比理解：
就像Windows的"我的电脑"
• 显示硬盘、文件信息
• 但"我的电脑"本身不是硬盘
• INFORMATION_SCHEMA显示数据库信息，但本身不存储数据
```

### 2.2 常用元数据视图详解


#### 📋 SCHEMATA - 数据库信息


**🔧 基本查询方法**
```sql
-- 查看所有数据库
SELECT 
    SCHEMA_NAME as '数据库名',
    DEFAULT_CHARACTER_SET_NAME as '默认字符集',
    DEFAULT_COLLATION_NAME as '默认排序规则'
FROM INFORMATION_SCHEMA.SCHEMATA
WHERE SCHEMA_NAME NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys');

-- 查看特定数据库信息
SELECT 
    SCHEMA_NAME as '数据库名',
    DEFAULT_CHARACTER_SET_NAME as '字符集',
    DEFAULT_COLLATION_NAME as '排序规则'
FROM INFORMATION_SCHEMA.SCHEMATA 
WHERE SCHEMA_NAME = 'myapp';
```

#### 📋 TABLES - 表信息查询


**🔧 表基础信息查询**
```sql
-- 查看数据库中所有表的基本信息
SELECT 
    TABLE_SCHEMA as '数据库',
    TABLE_NAME as '表名',
    TABLE_TYPE as '表类型',
    ENGINE as '存储引擎',
    VERSION as '版本',
    ROW_FORMAT as '行格式',
    TABLE_ROWS as '预估行数',
    DATA_LENGTH as '数据大小(字节)',
    INDEX_LENGTH as '索引大小(字节)',
    AUTO_INCREMENT as '自增值',
    CREATE_TIME as '创建时间',
    UPDATE_TIME as '更新时间',
    TABLE_COMMENT as '表注释'
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'myapp'
ORDER BY DATA_LENGTH DESC;

-- 查看大表（超过1GB的表）
SELECT 
    TABLE_SCHEMA as '数据库',
    TABLE_NAME as '表名',
    ROUND(DATA_LENGTH/1024/1024/1024, 2) as '数据大小(GB)',
    ROUND(INDEX_LENGTH/1024/1024/1024, 2) as '索引大小(GB)',
    ROUND((DATA_LENGTH + INDEX_LENGTH)/1024/1024/1024, 2) as '总大小(GB)'
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
    AND (DATA_LENGTH + INDEX_LENGTH) > 1024*1024*1024
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;
```

#### 📋 COLUMNS - 列信息查询


**🔧 表结构详细查询**
```sql
-- 查看表的完整结构信息
SELECT 
    COLUMN_NAME as '列名',
    ORDINAL_POSITION as '位置',
    IS_NULLABLE as '允许NULL',
    DATA_TYPE as '数据类型',
    CHARACTER_MAXIMUM_LENGTH as '最大长度',
    NUMERIC_PRECISION as '数值精度',
    NUMERIC_SCALE as '小数位数',
    COLUMN_DEFAULT as '默认值',
    COLUMN_TYPE as '完整类型',
    EXTRA as '额外属性',
    COLUMN_COMMENT as '列注释'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp' 
    AND TABLE_NAME = 'users'
ORDER BY ORDINAL_POSITION;

-- 查找所有包含特定列名的表
SELECT 
    TABLE_SCHEMA as '数据库',
    TABLE_NAME as '表名',
    COLUMN_NAME as '列名',
    DATA_TYPE as '数据类型'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE COLUMN_NAME LIKE '%password%'
    AND TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys');

-- 查找所有自增列
SELECT 
    TABLE_SCHEMA as '数据库',
    TABLE_NAME as '表名',
    COLUMN_NAME as '列名',
    DATA_TYPE as '数据类型',
    AUTO_INCREMENT as '当前自增值'
FROM INFORMATION_SCHEMA.COLUMNS c
JOIN INFORMATION_SCHEMA.TABLES t 
    ON c.TABLE_SCHEMA = t.TABLE_SCHEMA 
    AND c.TABLE_NAME = t.TABLE_NAME
WHERE c.EXTRA = 'auto_increment';
```

#### 📋 STATISTICS - 索引信息查询


**🔧 索引详细信息**
```sql
-- 查看表的所有索引信息
SELECT 
    INDEX_SCHEMA as '数据库',
    TABLE_NAME as '表名',
    INDEX_NAME as '索引名',
    COLUMN_NAME as '列名',
    SEQ_IN_INDEX as '列顺序',
    NON_UNIQUE as '是否非唯一',
    INDEX_TYPE as '索引类型',
    CARDINALITY as '基数',
    NULLABLE as '是否可空',
    INDEX_COMMENT as '索引注释'
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE INDEX_SCHEMA = 'myapp' 
    AND TABLE_NAME = 'users'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;

-- 分析表的索引使用情况
SELECT 
    TABLE_NAME as '表名',
    INDEX_NAME as '索引名',
    GROUP_CONCAT(
        COLUMN_NAME 
        ORDER BY SEQ_IN_INDEX 
        SEPARATOR ', '
    ) as '索引列',
    COUNT(*) as '列数',
    CASE 
        WHEN NON_UNIQUE = 0 THEN '唯一索引'
        ELSE '普通索引'
    END as '索引类型'
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE INDEX_SCHEMA = 'myapp'
GROUP BY TABLE_NAME, INDEX_NAME, NON_UNIQUE
ORDER BY TABLE_NAME, INDEX_NAME;

-- 找出没有索引的表
SELECT 
    t.TABLE_NAME as '表名',
    t.TABLE_ROWS as '行数'
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN INFORMATION_SCHEMA.STATISTICS s 
    ON t.TABLE_SCHEMA = s.INDEX_SCHEMA 
    AND t.TABLE_NAME = s.TABLE_NAME
WHERE t.TABLE_SCHEMA = 'myapp'
    AND t.TABLE_TYPE = 'BASE TABLE'
    AND s.INDEX_NAME IS NULL;
```

### 2.3 Information_Schema常用视图详解


**📋 核心视图功能说明**

| 视图名 | **主要功能** | **常用字段** | **应用场景** |
|--------|-------------|-------------|-------------|
| **SCHEMATA** | `数据库列表信息` | `SCHEMA_NAME, DEFAULT_CHARACTER_SET_NAME` | `数据库清单，字符集检查` |
| **TABLES** | `表的基本信息` | `TABLE_NAME, ENGINE, TABLE_ROWS, DATA_LENGTH` | `表清单，大小统计` |
| **COLUMNS** | `列的详细信息` | `COLUMN_NAME, DATA_TYPE, IS_NULLABLE` | `表结构分析，字段检查` |
| **STATISTICS** | `索引统计信息` | `INDEX_NAME, COLUMN_NAME, CARDINALITY` | `索引分析，性能优化` |
| **KEY_COLUMN_USAGE** | `约束列信息` | `CONSTRAINT_NAME, COLUMN_NAME` | `约束检查，关系分析` |
| **TABLE_CONSTRAINTS** | `表约束信息` | `CONSTRAINT_TYPE, CONSTRAINT_NAME` | `约束管理，完整性检查` |
| **REFERENTIAL_CONSTRAINTS** | `外键约束详情` | `REFERENCED_TABLE_NAME, DELETE_RULE` | `外键关系，级联操作` |
| **TRIGGERS** | `触发器信息` | `TRIGGER_NAME, EVENT_MANIPULATION` | `触发器管理，逻辑检查` |

**🔧 视图组合查询示例**
```sql
-- 获取表的完整信息（表+列+索引）
SELECT 
    t.TABLE_NAME as '表名',
    t.ENGINE as '引擎',
    t.TABLE_ROWS as '行数',
    COUNT(DISTINCT c.COLUMN_NAME) as '列数',
    COUNT(DISTINCT s.INDEX_NAME) as '索引数',
    ROUND((t.DATA_LENGTH + t.INDEX_LENGTH)/1024/1024, 2) as '总大小(MB)',
    t.TABLE_COMMENT as '表注释'
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN INFORMATION_SCHEMA.COLUMNS c 
    ON t.TABLE_SCHEMA = c.TABLE_SCHEMA 
    AND t.TABLE_NAME = c.TABLE_NAME
LEFT JOIN INFORMATION_SCHEMA.STATISTICS s 
    ON t.TABLE_SCHEMA = s.INDEX_SCHEMA 
    AND t.TABLE_NAME = s.TABLE_NAME
WHERE t.TABLE_SCHEMA = 'myapp'
    AND t.TABLE_TYPE = 'BASE TABLE'
GROUP BY t.TABLE_NAME
ORDER BY (t.DATA_LENGTH + t.INDEX_LENGTH) DESC;
```

### 2.4 元数据查询性能优化技巧


**⚡ 查询优化策略**
```sql
-- ❌ 低效查询：扫描所有数据库
SELECT * FROM INFORMATION_SCHEMA.TABLES;

-- ✅ 高效查询：指定数据库范围
SELECT * FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'myapp';

-- ❌ 低效查询：使用LIKE模糊匹配
SELECT * FROM INFORMATION_SCHEMA.COLUMNS 
WHERE COLUMN_NAME LIKE '%name%';

-- ✅ 高效查询：精确匹配+索引字段
SELECT * FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp' 
    AND TABLE_NAME = 'users'
    AND COLUMN_NAME = 'username';
```

**🔧 查询优化技巧**
```sql
-- 技巧1：使用EXISTS代替IN
-- ❌ 较慢
SELECT TABLE_NAME 
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_NAME IN (
    SELECT TABLE_NAME 
    FROM INFORMATION_SCHEMA.STATISTICS 
    WHERE INDEX_NAME = 'PRIMARY'
);

-- ✅ 更快
SELECT t.TABLE_NAME 
FROM INFORMATION_SCHEMA.TABLES t
WHERE EXISTS (
    SELECT 1 
    FROM INFORMATION_SCHEMA.STATISTICS s
    WHERE s.TABLE_SCHEMA = t.TABLE_SCHEMA
        AND s.TABLE_NAME = t.TABLE_NAME
        AND s.INDEX_NAME = 'PRIMARY'
);

-- 技巧2：合理使用LIMIT
SELECT TABLE_NAME, DATA_LENGTH 
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'myapp'
ORDER BY DATA_LENGTH DESC
LIMIT 10;  -- 只查询最大的10个表
```

---

## 3. 🔍 表结构与索引信息查询


### 3.1 表结构信息获取


**📋 获取完整表结构的实用方法**

```sql
-- 方法1：使用DESCRIBE（最常用）
DESCRIBE users;
-- 或者
DESC users;

-- 方法2：使用SHOW COLUMNS（更详细）
SHOW COLUMNS FROM users;

-- 方法3：使用INFORMATION_SCHEMA（最灵活）
SELECT 
    COLUMN_NAME as '字段名',
    COLUMN_TYPE as '类型',
    IS_NULLABLE as '是否为空',
    COLUMN_DEFAULT as '默认值',
    EXTRA as '额外属性',
    COLUMN_COMMENT as '注释'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp' 
    AND TABLE_NAME = 'users'
ORDER BY ORDINAL_POSITION;
```

**🔧 表结构分析实用查询**
```sql
-- 查找所有TEXT/BLOB大字段
SELECT 
    TABLE_SCHEMA as '数据库',
    TABLE_NAME as '表名',
    COLUMN_NAME as '列名',
    DATA_TYPE as '数据类型',
    CHARACTER_MAXIMUM_LENGTH as '最大长度'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE DATA_TYPE IN ('text', 'mediumtext', 'longtext', 'blob', 'mediumblob', 'longblob')
    AND TABLE_SCHEMA = 'myapp'
ORDER BY TABLE_NAME, ORDINAL_POSITION;

-- 查找所有未设置注释的字段
SELECT 
    TABLE_NAME as '表名',
    COLUMN_NAME as '列名',
    DATA_TYPE as '数据类型'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
    AND (COLUMN_COMMENT = '' OR COLUMN_COMMENT IS NULL)
    AND TABLE_NAME NOT LIKE '%_temp%'
ORDER BY TABLE_NAME, ORDINAL_POSITION;

-- 查找所有允许NULL的字段
SELECT 
    TABLE_NAME as '表名',
    COLUMN_NAME as '列名',
    DATA_TYPE as '数据类型',
    COLUMN_DEFAULT as '默认值'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
    AND IS_NULLABLE = 'YES'
    AND COLUMN_KEY != 'PRI'  -- 排除主键
ORDER BY TABLE_NAME, ORDINAL_POSITION;
```

### 3.2 索引信息深度分析


**📊 索引使用情况统计**
```sql
-- 每个表的索引数量统计
SELECT 
    TABLE_NAME as '表名',
    COUNT(DISTINCT INDEX_NAME) as '索引总数',
    SUM(CASE WHEN NON_UNIQUE = 0 THEN 1 ELSE 0 END) as '唯一索引数',
    SUM(CASE WHEN NON_UNIQUE = 1 THEN 1 ELSE 0 END) as '普通索引数',
    SUM(CASE WHEN INDEX_NAME = 'PRIMARY' THEN 1 ELSE 0 END) as '主键索引'
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE INDEX_SCHEMA = 'myapp'
GROUP BY TABLE_NAME
ORDER BY COUNT(DISTINCT INDEX_NAME) DESC;

-- 复合索引详细分析
SELECT 
    TABLE_NAME as '表名',
    INDEX_NAME as '索引名',
    GROUP_CONCAT(
        CONCAT(COLUMN_NAME, '(', SEQ_IN_INDEX, ')')
        ORDER BY SEQ_IN_INDEX
        SEPARATOR ' + '
    ) as '索引列组合',
    COUNT(*) as '列数',
    CASE 
        WHEN NON_UNIQUE = 0 THEN '唯一'
        ELSE '非唯一'
    END as '索引类型'
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE INDEX_SCHEMA = 'myapp'
GROUP BY TABLE_NAME, INDEX_NAME, NON_UNIQUE
HAVING COUNT(*) > 1  -- 只显示复合索引
ORDER BY TABLE_NAME, INDEX_NAME;

-- 查找可能冗余的索引
SELECT 
    s1.TABLE_NAME as '表名',
    s1.INDEX_NAME as '索引1',
    s2.INDEX_NAME as '索引2',
    GROUP_CONCAT(s1.COLUMN_NAME ORDER BY s1.SEQ_IN_INDEX) as '索引1列',
    GROUP_CONCAT(s2.COLUMN_NAME ORDER BY s2.SEQ_IN_INDEX) as '索引2列'
FROM INFORMATION_SCHEMA.STATISTICS s1
JOIN INFORMATION_SCHEMA.STATISTICS s2 
    ON s1.TABLE_SCHEMA = s2.TABLE_SCHEMA
    AND s1.TABLE_NAME = s2.TABLE_NAME
    AND s1.INDEX_NAME < s2.INDEX_NAME
    AND s1.COLUMN_NAME = s2.COLUMN_NAME
    AND s1.SEQ_IN_INDEX = s2.SEQ_IN_INDEX
WHERE s1.INDEX_SCHEMA = 'myapp'
GROUP BY s1.TABLE_NAME, s1.INDEX_NAME, s2.INDEX_NAME;
```

### 3.3 元数据表详细结构


**📊 INFORMATION_SCHEMA核心表结构解析**

```sql
-- TABLES表的关键字段说明
SELECT 
    COLUMN_NAME as '字段名',
    DATA_TYPE as '数据类型',
    IS_NULLABLE as '是否可空',
    COLUMN_COMMENT as '字段说明'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'INFORMATION_SCHEMA' 
    AND TABLE_NAME = 'TABLES'
    AND COLUMN_NAME IN (
        'TABLE_SCHEMA', 'TABLE_NAME', 'TABLE_TYPE', 'ENGINE',
        'VERSION', 'ROW_FORMAT', 'TABLE_ROWS', 'DATA_LENGTH',
        'INDEX_LENGTH', 'AUTO_INCREMENT', 'CREATE_TIME', 'UPDATE_TIME'
    )
ORDER BY ORDINAL_POSITION;

-- COLUMNS表的关键字段说明
SELECT 
    COLUMN_NAME as '字段名',
    DATA_TYPE as '数据类型',
    COLUMN_COMMENT as '字段说明'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'INFORMATION_SCHEMA' 
    AND TABLE_NAME = 'COLUMNS'
    AND COLUMN_NAME IN (
        'TABLE_SCHEMA', 'TABLE_NAME', 'COLUMN_NAME', 'ORDINAL_POSITION',
        'COLUMN_DEFAULT', 'IS_NULLABLE', 'DATA_TYPE', 'CHARACTER_MAXIMUM_LENGTH',
        'NUMERIC_PRECISION', 'NUMERIC_SCALE', 'EXTRA'
    )
ORDER BY ORDINAL_POSITION;
```

**💡 字段含义详解**
```
TABLES表重要字段：
• TABLE_ROWS：预估行数，不是精确值
• DATA_LENGTH：数据文件大小（字节）
• INDEX_LENGTH：索引文件大小（字节）
• AUTO_INCREMENT：下一个自增值
• CREATE_TIME：表创建时间
• UPDATE_TIME：表最后修改时间（DDL操作）

COLUMNS表重要字段：
• ORDINAL_POSITION：列在表中的位置（从1开始）
• CHARACTER_MAXIMUM_LENGTH：字符类型的最大长度
• NUMERIC_PRECISION：数值类型的总位数
• NUMERIC_SCALE：数值类型的小数位数
• EXTRA：额外属性（auto_increment, on update等）
```

---

## 4. 🔗 约束与统计信息管理


### 4.1 约束信息查询


**🔧 主键约束查询**
```sql
-- 查看所有表的主键信息
SELECT 
    kcu.TABLE_SCHEMA as '数据库',
    kcu.TABLE_NAME as '表名',
    kcu.COLUMN_NAME as '主键列',
    kcu.ORDINAL_POSITION as '列位置',
    c.DATA_TYPE as '数据类型'
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
JOIN INFORMATION_SCHEMA.COLUMNS c 
    ON kcu.TABLE_SCHEMA = c.TABLE_SCHEMA
    AND kcu.TABLE_NAME = c.TABLE_NAME
    AND kcu.COLUMN_NAME = c.COLUMN_NAME
WHERE kcu.CONSTRAINT_NAME = 'PRIMARY'
    AND kcu.TABLE_SCHEMA = 'myapp'
ORDER BY kcu.TABLE_NAME, kcu.ORDINAL_POSITION;

-- 查找没有主键的表
SELECT 
    t.TABLE_NAME as '表名',
    t.TABLE_ROWS as '行数',
    ROUND((t.DATA_LENGTH + t.INDEX_LENGTH)/1024/1024, 2) as '大小(MB)'
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu 
    ON t.TABLE_SCHEMA = kcu.TABLE_SCHEMA
    AND t.TABLE_NAME = kcu.TABLE_NAME
    AND kcu.CONSTRAINT_NAME = 'PRIMARY'
WHERE t.TABLE_SCHEMA = 'myapp'
    AND t.TABLE_TYPE = 'BASE TABLE'
    AND kcu.COLUMN_NAME IS NULL
ORDER BY t.TABLE_ROWS DESC;
```

**🔧 外键约束查询**
```sql
-- 查看所有外键约束
SELECT 
    rc.CONSTRAINT_SCHEMA as '数据库',
    rc.TABLE_NAME as '子表',
    kcu.COLUMN_NAME as '外键列',
    rc.REFERENCED_TABLE_NAME as '父表',
    kcu2.COLUMN_NAME as '引用列',
    rc.DELETE_RULE as '删除规则',
    rc.UPDATE_RULE as '更新规则'
FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
    ON rc.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA
    AND rc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu2
    ON rc.UNIQUE_CONSTRAINT_SCHEMA = kcu2.CONSTRAINT_SCHEMA
    AND rc.REFERENCED_TABLE_NAME = kcu2.TABLE_NAME
    AND rc.UNIQUE_CONSTRAINT_NAME = kcu2.CONSTRAINT_NAME
    AND kcu.ORDINAL_POSITION = kcu2.ORDINAL_POSITION
WHERE rc.CONSTRAINT_SCHEMA = 'myapp'
ORDER BY rc.TABLE_NAME, kcu.ORDINAL_POSITION;

-- 分析表之间的依赖关系
WITH RECURSIVE table_dependencies AS (
    -- 找出所有被引用的表（父表）
    SELECT DISTINCT 
        REFERENCED_TABLE_NAME as table_name,
        0 as level
    FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS
    WHERE CONSTRAINT_SCHEMA = 'myapp'
    
    UNION ALL
    
    -- 找出引用其他表的表（子表）
    SELECT DISTINCT 
        rc.TABLE_NAME,
        td.level + 1
    FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
    JOIN table_dependencies td 
        ON rc.REFERENCED_TABLE_NAME = td.table_name
    WHERE rc.CONSTRAINT_SCHEMA = 'myapp'
        AND td.level < 5  -- 防止无限递归
)
SELECT 
    table_name as '表名',
    level as '依赖层级'
FROM table_dependencies
ORDER BY level, table_name;
```

### 4.2 统计信息查询


**📊 数据库统计信息分析**
```sql
-- 数据库整体统计信息
SELECT 
    TABLE_SCHEMA as '数据库',
    COUNT(*) as '表数量',
    SUM(TABLE_ROWS) as '总行数',
    ROUND(SUM(DATA_LENGTH)/1024/1024/1024, 2) as '数据大小(GB)',
    ROUND(SUM(INDEX_LENGTH)/1024/1024/1024, 2) as '索引大小(GB)',
    ROUND(SUM(DATA_LENGTH + INDEX_LENGTH)/1024/1024/1024, 2) as '总大小(GB)'
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
    AND TABLE_TYPE = 'BASE TABLE'
GROUP BY TABLE_SCHEMA
ORDER BY SUM(DATA_LENGTH + INDEX_LENGTH) DESC;

-- 存储引擎使用情况统计
SELECT 
    ENGINE as '存储引擎',
    COUNT(*) as '表数量',
    ROUND(SUM(DATA_LENGTH)/1024/1024, 2) as '数据大小(MB)',
    ROUND(SUM(INDEX_LENGTH)/1024/1024, 2) as '索引大小(MB)',
    ROUND(AVG(TABLE_ROWS), 0) as '平均行数'
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'myapp'
    AND TABLE_TYPE = 'BASE TABLE'
    AND ENGINE IS NOT NULL
GROUP BY ENGINE
ORDER BY COUNT(*) DESC;

-- 字符集和排序规则统计
SELECT 
    CHARACTER_SET_NAME as '字符集',
    COLLATION_NAME as '排序规则',
    COUNT(*) as '列数量'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
    AND CHARACTER_SET_NAME IS NOT NULL
GROUP BY CHARACTER_SET_NAME, COLLATION_NAME
ORDER BY COUNT(*) DESC;
```

### 4.3 数据类型使用情况分析


**📊 数据类型分布统计**
```sql
-- 数据类型使用频率统计
SELECT 
    DATA_TYPE as '数据类型',
    COUNT(*) as '使用次数',
    ROUND(COUNT(*) * 100.0 / (
        SELECT COUNT(*) 
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE TABLE_SCHEMA = 'myapp'
    ), 2) as '使用比例(%)'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
GROUP BY DATA_TYPE
ORDER BY COUNT(*) DESC;

-- 字符串类型长度分布
SELECT 
    CASE 
        WHEN CHARACTER_MAXIMUM_LENGTH <= 50 THEN '短字符串(≤50)'
        WHEN CHARACTER_MAXIMUM_LENGTH <= 255 THEN '中等字符串(51-255)'
        WHEN CHARACTER_MAXIMUM_LENGTH <= 1000 THEN '长字符串(256-1000)'
        ELSE '超长字符串(>1000)'
    END as '长度分类',
    COUNT(*) as '字段数量',
    GROUP_CONCAT(
        CONCAT(TABLE_NAME, '.', COLUMN_NAME)
        SEPARATOR ', '
    ) as '示例字段'
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
    AND DATA_TYPE IN ('varchar', 'char')
    AND CHARACTER_MAXIMUM_LENGTH IS NOT NULL
GROUP BY 
    CASE 
        WHEN CHARACTER_MAXIMUM_LENGTH <= 50 THEN 1
        WHEN CHARACTER_MAXIMUM_LENGTH <= 255 THEN 2
        WHEN CHARACTER_MAXIMUM_LENGTH <= 1000 THEN 3
        ELSE 4
    END
ORDER BY 
    CASE 
        WHEN CHARACTER_MAXIMUM_LENGTH <= 50 THEN 1
        WHEN CHARACTER_MAXIMUM_LENGTH <= 255 THEN 2
        WHEN CHARACTER_MAXIMUM_LENGTH <= 1000 THEN 3
        ELSE 4
    END;
```

### 4.4 索引效率分析


**⚡ 索引基数与选择性分析**
```sql
-- 索引选择性分析（选择性越高，索引效果越好）
SELECT 
    TABLE_NAME as '表名',
    INDEX_NAME as '索引名',
    COLUMN_NAME as '列名',
    CARDINALITY as '基数',
    -- 从TABLES表获取预估行数
    (SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES t 
     WHERE t.TABLE_SCHEMA = s.INDEX_SCHEMA 
     AND t.TABLE_NAME = s.TABLE_NAME) as '总行数',
    CASE 
        WHEN (SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES t 
              WHERE t.TABLE_SCHEMA = s.INDEX_SCHEMA 
              AND t.TABLE_NAME = s.TABLE_NAME) > 0
        THEN ROUND(
            CARDINALITY * 100.0 / 
            (SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES t 
             WHERE t.TABLE_SCHEMA = s.INDEX_SCHEMA 
             AND t.TABLE_NAME = s.TABLE_NAME), 2
        )
        ELSE 0
    END as '选择性(%)',
    CASE 
        WHEN CARDINALITY = 0 THEN '无效索引'
        WHEN CARDINALITY * 100.0 / 
             NULLIF((SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES t 
                     WHERE t.TABLE_SCHEMA = s.INDEX_SCHEMA 
                     AND t.TABLE_NAME = s.TABLE_NAME), 0) > 80 
        THEN '高选择性'
        WHEN CARDINALITY * 100.0 / 
             NULLIF((SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES t 
                     WHERE t.TABLE_SCHEMA = s.INDEX_SCHEMA 
                     AND t.TABLE_NAME = s.TABLE_NAME), 0) > 30 
        THEN '中选择性'
        ELSE '低选择性'
    END as '选择性评估'
FROM INFORMATION_SCHEMA.STATISTICS s
WHERE INDEX_SCHEMA = 'myapp'
    AND SEQ_IN_INDEX = 1  -- 只看复合索引的第一列
ORDER BY TABLE_NAME, CARDINALITY DESC;
```

---

## 5. 🔒 元数据锁与版本管理


### 5.1 元数据锁MDL机制


**🔸 什么是元数据锁（MDL）**
```
简单理解：
元数据锁是MySQL保护表结构不被并发修改的机制

为什么需要MDL：
想象一下，如果没有元数据锁：
• 用户A正在查询表users
• 用户B同时执行ALTER TABLE users修改表结构
• 用户A的查询可能会遇到不一致的表结构
• 结果：数据错乱或程序崩溃

MDL的作用：
• 读操作获取共享MDL锁
• 写操作（DDL）获取排他MDL锁
• 确保表结构的一致性
```

### 5.2 MDL锁的类型与机制


**🔧 MDL锁类型详解**
```sql
-- 查看当前的元数据锁信息
SELECT 
    OBJECT_SCHEMA as '数据库',
    OBJECT_NAME as '对象名',
    OBJECT_TYPE as '对象类型',
    LOCK_TYPE as '锁类型',
    LOCK_DURATION as '锁持续时间',
    LOCK_STATUS as '锁状态'
FROM performance_schema.metadata_locks
WHERE OBJECT_SCHEMA NOT IN ('performance_schema', 'information_schema', 'mysql')
ORDER BY OBJECT_SCHEMA, OBJECT_NAME;

-- 查看MDL锁等待情况
SELECT 
    waiting.PROCESSLIST_ID as '等待进程ID',
    waiting.PROCESSLIST_USER as '等待用户',
    waiting.PROCESSLIST_HOST as '等待主机',
    waiting.PROCESSLIST_DB as '数据库',
    waiting.PROCESSLIST_COMMAND as '命令类型',
    waiting.PROCESSLIST_TIME as '等待时间(秒)',
    waiting.PROCESSLIST_INFO as 'SQL语句',
    blocking.PROCESSLIST_ID as '阻塞进程ID',
    blocking.PROCESSLIST_USER as '阻塞用户'
FROM performance_schema.processlist waiting
JOIN performance_schema.metadata_locks waiting_lock
    ON waiting.PROCESSLIST_ID = waiting_lock.OWNER_THREAD_ID
JOIN performance_schema.metadata_locks blocking_lock
    ON waiting_lock.OBJECT_SCHEMA = blocking_lock.OBJECT_SCHEMA
    AND waiting_lock.OBJECT_NAME = blocking_lock.OBJECT_NAME
JOIN performance_schema.processlist blocking
    ON blocking_lock.OWNER_THREAD_ID = blocking.PROCESSLIST_ID
WHERE waiting_lock.LOCK_STATUS = 'PENDING'
    AND blocking_lock.LOCK_STATUS = 'GRANTED'
    AND waiting.PROCESSLIST_ID != blocking.PROCESSLIST_ID;
```

**📊 MDL锁类型说明**

| 锁类型 | **获取场景** | **兼容性** | **持续时间** |
|--------|-------------|-----------|-------------|
| **MDL_SHARED_READ** | `SELECT查询` | `与读锁兼容` | `语句执行期间` |
| **MDL_SHARED_WRITE** | `INSERT/UPDATE/DELETE` | `与读写锁兼容` | `事务期间` |
| **MDL_EXCLUSIVE** | `ALTER TABLE/DROP TABLE` | `与所有锁互斥` | `DDL操作期间` |
| **MDL_INTENTION_EXCLUSIVE** | `LOCK TABLES` | `部分兼容` | `UNLOCK TABLES前` |

### 5.3 元数据版本管理


**🔄 元数据变更追踪**
```sql
-- 创建元数据变更日志表
CREATE TABLE metadata_change_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    change_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    database_name VARCHAR(64),
    table_name VARCHAR(64),
    change_type ENUM('CREATE', 'ALTER', 'DROP', 'RENAME'),
    old_structure TEXT,
    new_structure TEXT,
    user_name VARCHAR(64),
    host_name VARCHAR(64),
    INDEX idx_change_time (change_time),
    INDEX idx_table (database_name, table_name)
);

-- 创建触发器自动记录表结构变更
DELIMITER $$
CREATE TRIGGER log_table_changes
BEFORE DROP ON *.* 
FOR EACH ROW 
BEGIN
    INSERT INTO mysql.metadata_change_log (
        database_name, 
        table_name, 
        change_type, 
        old_structure,
        user_name,
        host_name
    ) VALUES (
        SCHEMA(), 
        TABLE_NAME(), 
        'DROP',
        (SELECT CONCAT('CREATE TABLE ', TABLE_NAME, ' ...')
         FROM INFORMATION_SCHEMA.TABLES 
         WHERE TABLE_SCHEMA = SCHEMA() 
         AND TABLE_NAME = TABLE_NAME()),
        USER(),
        CONNECTION_ID()
    );
END$$
DELIMITER ;
```

### 5.4 元数据同步机制


**🔄 主从环境元数据同步**
```
元数据同步原理：
主库 → binlog记录DDL操作 → 从库回放DDL → 元数据保持一致

同步检查方法：
```sql
-- 检查主从库表结构一致性
-- 在主库执行
SELECT 
    TABLE_NAME,
    MD5(CONCAT(
        GROUP_CONCAT(
            COLUMN_NAME, ':', 
            COLUMN_TYPE, ':', 
            IS_NULLABLE, ':', 
            IFNULL(COLUMN_DEFAULT, 'NULL')
            ORDER BY ORDINAL_POSITION
        )
    )) as structure_hash
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
GROUP BY TABLE_NAME;

-- 在从库执行相同查询，对比structure_hash值
-- 如果hash值不同，说明表结构不一致
```

**🔧 跨库元数据查询**
```sql
-- 比较不同环境的数据库结构
-- 开发环境 vs 生产环境
SELECT 
    'dev' as environment,
    TABLE_NAME,
    COUNT(*) as column_count,
    GROUP_CONCAT(COLUMN_NAME ORDER BY ORDINAL_POSITION) as columns
FROM dev_db.INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
GROUP BY TABLE_NAME

UNION ALL

SELECT 
    'prod' as environment,
    TABLE_NAME,
    COUNT(*) as column_count,
    GROUP_CONCAT(COLUMN_NAME ORDER BY ORDINAL_POSITION) as columns
FROM prod_db.INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
GROUP BY TABLE_NAME
ORDER BY TABLE_NAME, environment;

-- 使用federated引擎查询远程数据库元数据
CREATE TABLE remote_tables (
    TABLE_SCHEMA VARCHAR(64),
    TABLE_NAME VARCHAR(64),
    ENGINE VARCHAR(64),
    TABLE_ROWS BIGINT,
    DATA_LENGTH BIGINT
) ENGINE=FEDERATED 
CONNECTION='mysql://user:pass@remote_host:3306/information_schema/tables';
```

---

## 6. 🛠️ 元数据管理实践


### 6.1 元数据备份策略


**💾 为什么要备份元数据**
```
元数据的重要性：
• 表结构丢失 = 数据无法访问
• 索引信息丢失 = 性能严重下降
• 约束信息丢失 = 数据完整性失控
• 用户权限丢失 = 系统安全漏洞

备份内容：
• 数据库结构（表、视图、存储过程）
• 索引定义
• 约束定义
• 用户权限
• 触发器和函数
```

**🔧 元数据备份实现**
```bash
#!/bin/bash
# metadata-backup.sh - 元数据备份脚本

# 配置信息
DB_HOST="localhost"
DB_USER="backup_user"
DB_PASS="backup_password"
BACKUP_DIR="/opt/mysql/metadata-backups"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p "$BACKUP_DIR/$DATE"

# 1. 备份所有数据库结构（不包含数据）
echo "备份数据库结构..."
mysqldump \
    --host="$DB_HOST" \
    --user="$DB_USER" \
    --password="$DB_PASS" \
    --no-data \
    --routines \
    --triggers \
    --events \
    --all-databases \
    > "$BACKUP_DIR/$DATE/schema_structure.sql"

# 2. 备份用户权限信息
echo "备份用户权限..."
mysql \
    --host="$DB_HOST" \
    --user="$DB_USER" \
    --password="$DB_PASS" \
    --skip-column-names \
    --batch \
    -e "SELECT CONCAT('SHOW CREATE USER ''', user, '''@''', host, ''';') 
        FROM mysql.user WHERE user NOT IN ('mysql.sys', 'mysql.session')" \
    > "$BACKUP_DIR/$DATE/users_create.sql"

mysql \
    --host="$DB_HOST" \
    --user="$DB_USER" \
    --password="$DB_PASS" \
    --skip-column-names \
    --batch \
    -e "SELECT CONCAT('SHOW GRANTS FOR ''', user, '''@''', host, ''';') 
        FROM mysql.user WHERE user NOT IN ('mysql.sys', 'mysql.session')" \
    > "$BACKUP_DIR/$DATE/users_grants.sql"

# 3. 备份元数据统计信息
echo "备份元数据统计..."
mysql \
    --host="$DB_HOST" \
    --user="$DB_USER" \
    --password="$DB_PASS" \
    -e "
    SELECT 
        TABLE_SCHEMA,
        TABLE_NAME,
        ENGINE,
        TABLE_ROWS,
        DATA_LENGTH,
        INDEX_LENGTH,
        CREATE_TIME,
        UPDATE_TIME
    FROM INFORMATION_SCHEMA.TABLES 
    WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
    " > "$BACKUP_DIR/$DATE/table_statistics.csv"

# 4. 备份索引信息
echo "备份索引信息..."
mysql \
    --host="$DB_HOST" \
    --user="$DB_USER" \
    --password="$DB_PASS" \
    -e "
    SELECT 
        INDEX_SCHEMA,
        TABLE_NAME,
        INDEX_NAME,
        GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as INDEX_COLUMNS,
        NON_UNIQUE,
        INDEX_TYPE
    FROM INFORMATION_SCHEMA.STATISTICS 
    WHERE INDEX_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
    GROUP BY INDEX_SCHEMA, TABLE_NAME, INDEX_NAME
    " > "$BACKUP_DIR/$DATE/index_information.csv"

echo "元数据备份完成：$BACKUP_DIR/$DATE"
```

### 6.2 元数据变更通知


**📢 变更通知机制**
```sql
-- 创建元数据变更通知表
CREATE TABLE metadata_notifications (
    id INT AUTO_INCREMENT PRIMARY KEY,
    notification_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    change_type VARCHAR(20),
    database_name VARCHAR(64),
    table_name VARCHAR(64),
    change_description TEXT,
    affected_applications JSON,
    notification_status ENUM('PENDING', 'SENT', 'FAILED') DEFAULT 'PENDING',
    INDEX idx_status_time (notification_status, notification_time)
);

-- 插入变更通知的存储过程
DELIMITER $$
CREATE PROCEDURE notify_metadata_change(
    IN p_change_type VARCHAR(20),
    IN p_database_name VARCHAR(64),
    IN p_table_name VARCHAR(64),
    IN p_description TEXT
)
BEGIN
    -- 插入通知记录
    INSERT INTO metadata_notifications (
        change_type,
        database_name,
        table_name,
        change_description,
        affected_applications
    ) VALUES (
        p_change_type,
        p_database_name,
        p_table_name,
        p_description,
        JSON_ARRAY('web_app', 'mobile_api', 'data_pipeline')
    );
    
    -- 这里可以集成外部通知系统
    -- 例如发送邮件、短信、钉钉消息等
END$$
DELIMITER ;

-- 使用示例
CALL notify_metadata_change(
    'ALTER_TABLE',
    'myapp',
    'users',
    '添加了新列email，类型VARCHAR(255)'
);
```

### 6.3 元数据版本控制


**📋 数据库版本管理实践**
```sql
-- 创建数据库版本管理表
CREATE TABLE database_versions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    version_number VARCHAR(20) NOT NULL,
    release_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    description TEXT,
    migration_script TEXT,
    rollback_script TEXT,
    applied_by VARCHAR(64),
    applied_at TIMESTAMP NULL,
    status ENUM('PENDING', 'APPLIED', 'FAILED', 'ROLLED_BACK') DEFAULT 'PENDING',
    UNIQUE KEY uk_version (version_number)
);

-- 记录每个版本的具体变更
CREATE TABLE schema_changes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    version_id INT,
    change_order INT,
    change_type ENUM('CREATE_TABLE', 'ALTER_TABLE', 'DROP_TABLE', 'CREATE_INDEX', 'DROP_INDEX'),
    object_name VARCHAR(128),
    sql_statement TEXT,
    FOREIGN KEY (version_id) REFERENCES database_versions(id),
    INDEX idx_version_order (version_id, change_order)
);

-- 版本升级存储过程
DELIMITER $$
CREATE PROCEDURE apply_database_version(IN version_num VARCHAR(20))
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE change_sql TEXT;
    DECLARE change_cursor CURSOR FOR 
        SELECT sql_statement 
        FROM schema_changes sc
        JOIN database_versions dv ON sc.version_id = dv.id
        WHERE dv.version_number = version_num
        ORDER BY sc.change_order;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 开始事务
    START TRANSACTION;
    
    -- 检查版本是否已应用
    IF EXISTS (SELECT 1 FROM database_versions 
               WHERE version_number = version_num AND status = 'APPLIED') THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '版本已经应用';
    END IF;
    
    -- 应用所有变更
    OPEN change_cursor;
    read_loop: LOOP
        FETCH change_cursor INTO change_sql;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        SET @sql = change_sql;
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    CLOSE change_cursor;
    
    -- 更新版本状态
    UPDATE database_versions 
    SET status = 'APPLIED', 
        applied_at = NOW(),
        applied_by = USER()
    WHERE version_number = version_num;
    
    COMMIT;
END$$
DELIMITER ;
```

---

## 7. 🤖 自动化运维脚本开发


### 7.1 数据库健康检查脚本


**🏥 全面的健康检查工具**
```bash
#!/bin/bash
# mysql-health-check.sh - MySQL数据库健康检查

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# 数据库连接信息
DB_HOST=${DB_HOST:-"localhost"}
DB_USER=${DB_USER:-"root"}
DB_PASS=${DB_PASS:-""}
DB_PORT=${DB_PORT:-"3306"}

# 输出函数
print_header() {
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}========================================${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# 数据库连接检查
check_connection() {
    print_header "数据库连接检查"
    
    if mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -e "SELECT 1" &>/dev/null; then
        print_success "数据库连接正常"
        
        # 获取基本信息
        VERSION=$(mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -N -e "SELECT VERSION()")
        UPTIME=$(mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -N -e "SHOW STATUS LIKE 'Uptime'" | awk '{print $2}')
        
        echo "MySQL版本: $VERSION"
        echo "运行时间: $(($UPTIME / 86400))天 $(($UPTIME % 86400 / 3600))小时"
    else
        print_error "数据库连接失败"
        exit 1
    fi
}

# 元数据完整性检查
check_metadata_integrity() {
    print_header "元数据完整性检查"
    
    # 检查孤立的索引
    ORPHAN_INDEXES=$(mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -N -e "
        SELECT COUNT(*)
        FROM INFORMATION_SCHEMA.STATISTICS s
        LEFT JOIN INFORMATION_SCHEMA.TABLES t 
            ON s.TABLE_SCHEMA = t.TABLE_SCHEMA 
            AND s.TABLE_NAME = t.TABLE_NAME
        WHERE t.TABLE_NAME IS NULL
    ")
    
    if [ "$ORPHAN_INDEXES" -gt 0 ]; then
        print_warning "发现 $ORPHAN_INDEXES 个孤立索引"
    else
        print_success "索引元数据完整"
    fi
    
    # 检查表结构一致性
    INCONSISTENT_TABLES=$(mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -N -e "
        SELECT COUNT(*)
        FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
            AND (CREATE_TIME IS NULL OR UPDATE_TIME IS NULL)
    ")
    
    if [ "$INCONSISTENT_TABLES" -gt 0 ]; then
        print_warning "发现 $INCONSISTENT_TABLES 个表的时间戳信息异常"
    else
        print_success "表元数据时间戳正常"
    fi
}

# 表结构规范检查
check_table_standards() {
    print_header "表结构规范检查"
    
    # 检查没有主键的表
    mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            t.TABLE_SCHEMA as '数据库',
            t.TABLE_NAME as '表名',
            t.TABLE_ROWS as '行数'
        FROM INFORMATION_SCHEMA.TABLES t
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu 
            ON t.TABLE_SCHEMA = kcu.TABLE_SCHEMA
            AND t.TABLE_NAME = kcu.TABLE_NAME
            AND kcu.CONSTRAINT_NAME = 'PRIMARY'
        WHERE t.TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
            AND t.TABLE_TYPE = 'BASE TABLE'
            AND kcu.COLUMN_NAME IS NULL
        ORDER BY t.TABLE_ROWS DESC;
    " > /tmp/tables_without_pk.txt
    
    NO_PK_COUNT=$(wc -l < /tmp/tables_without_pk.txt)
    if [ "$NO_PK_COUNT" -gt 1 ]; then  # 减去表头
        print_warning "发现 $((NO_PK_COUNT-1)) 个表没有主键"
        echo "详情请查看: /tmp/tables_without_pk.txt"
    else
        print_success "所有表都有主键"
    fi
    
    # 检查字符集不一致的情况
    CHARSET_ISSUES=$(mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -N -e "
        SELECT COUNT(DISTINCT CHARACTER_SET_NAME)
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE TABLE_SCHEMA = 'myapp'
            AND CHARACTER_SET_NAME IS NOT NULL
    ")
    
    if [ "$CHARSET_ISSUES" -gt 1 ]; then
        print_warning "数据库中存在多种字符集"
    else
        print_success "字符集使用一致"
    fi
}

# 性能相关元数据检查
check_performance_metadata() {
    print_header "性能相关元数据检查"
    
    # 检查大表没有合适索引的情况
    mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            t.TABLE_NAME as '表名',
            t.TABLE_ROWS as '行数',
            ROUND((t.DATA_LENGTH + t.INDEX_LENGTH)/1024/1024, 2) as '大小(MB)',
            COUNT(DISTINCT s.INDEX_NAME) as '索引数量'
        FROM INFORMATION_SCHEMA.TABLES t
        LEFT JOIN INFORMATION_SCHEMA.STATISTICS s 
            ON t.TABLE_SCHEMA = s.INDEX_SCHEMA 
            AND t.TABLE_NAME = s.TABLE_NAME
        WHERE t.TABLE_SCHEMA = 'myapp'
            AND t.TABLE_TYPE = 'BASE TABLE'
            AND t.TABLE_ROWS > 100000  -- 大于10万行
        GROUP BY t.TABLE_NAME
        HAVING COUNT(DISTINCT s.INDEX_NAME) < 3  -- 索引少于3个
        ORDER BY t.TABLE_ROWS DESC;
    "
    
    # 检查可能冗余的索引
    echo "检查可能的冗余索引..."
    mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            s1.TABLE_NAME as '表名',
            s1.INDEX_NAME as '索引1',
            s2.INDEX_NAME as '索引2',
            '可能冗余' as '建议'
        FROM (
            SELECT 
                INDEX_SCHEMA, TABLE_NAME, INDEX_NAME,
                GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns_list
            FROM INFORMATION_SCHEMA.STATISTICS 
            WHERE INDEX_SCHEMA = 'myapp'
            GROUP BY INDEX_SCHEMA, TABLE_NAME, INDEX_NAME
        ) s1
        JOIN (
            SELECT 
                INDEX_SCHEMA, TABLE_NAME, INDEX_NAME,
                GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns_list
            FROM INFORMATION_SCHEMA.STATISTICS 
            WHERE INDEX_SCHEMA = 'myapp'
            GROUP BY INDEX_SCHEMA, TABLE_NAME, INDEX_NAME
        ) s2 ON s1.INDEX_SCHEMA = s2.INDEX_SCHEMA
            AND s1.TABLE_NAME = s2.TABLE_NAME
            AND s1.INDEX_NAME < s2.INDEX_NAME
            AND s1.columns_list = LEFT(s2.columns_list, LENGTH(s1.columns_list))
        ORDER BY s1.TABLE_NAME;
    "
}

# 存储空间分析
analyze_storage_usage() {
    print_header "存储空间分析"
    
    # 数据库大小统计
    mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            TABLE_SCHEMA as '数据库',
            COUNT(*) as '表数量',
            ROUND(SUM(DATA_LENGTH)/1024/1024/1024, 2) as '数据大小(GB)',
            ROUND(SUM(INDEX_LENGTH)/1024/1024/1024, 2) as '索引大小(GB)',
            ROUND(SUM(DATA_LENGTH + INDEX_LENGTH)/1024/1024/1024, 2) as '总大小(GB)'
        FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
        GROUP BY TABLE_SCHEMA
        ORDER BY SUM(DATA_LENGTH + INDEX_LENGTH) DESC;
    "
    
    # 表增长趋势分析（需要历史数据）
    echo "近期表大小变化情况："
    mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            TABLE_NAME as '表名',
            TABLE_ROWS as '当前行数',
            ROUND((DATA_LENGTH + INDEX_LENGTH)/1024/1024, 2) as '当前大小(MB)',
            UPDATE_TIME as '最后更新时间'
        FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA = 'myapp'
            AND TABLE_TYPE = 'BASE TABLE'
            AND UPDATE_TIME > DATE_SUB(NOW(), INTERVAL 7 DAY)
        ORDER BY UPDATE_TIME DESC;
```

### 7.2 元数据自动收集脚本


**📊 元数据定期收集工具**
```bash
#!/bin/bash
# metadata-collector.sh - 元数据收集与分析工具

# 配置信息
DB_HOST="localhost"
DB_USER="metadata_user"
DB_PASS="metadata_password"
REPORT_DIR="/opt/mysql/metadata-reports"
DATE=$(date +%Y%m%d)

# 创建报告目录
mkdir -p "$REPORT_DIR/$DATE"

# 收集表基础信息
collect_table_info() {
    echo "收集表基础信息..."
    
    mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            TABLE_SCHEMA as '数据库',
            TABLE_NAME as '表名',
            ENGINE as '存储引擎',
            TABLE_ROWS as '行数',
            ROUND(DATA_LENGTH/1024/1024, 2) as '数据大小(MB)',
            ROUND(INDEX_LENGTH/1024/1024, 2) as '索引大小(MB)',
            CREATE_TIME as '创建时间',
            UPDATE_TIME as '更新时间',
            TABLE_COMMENT as '表注释'
        FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
            AND TABLE_TYPE = 'BASE TABLE'
        ORDER BY DATA_LENGTH DESC
    " > "$REPORT_DIR/$DATE/table_summary.csv"
}

# 收集索引信息
collect_index_info() {
    echo "收集索引信息..."
    
    mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            INDEX_SCHEMA as '数据库',
            TABLE_NAME as '表名',
            INDEX_NAME as '索引名',
            GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as '索引列',
            NON_UNIQUE as '非唯一',
            INDEX_TYPE as '索引类型',
            COUNT(*) as '列数'
        FROM INFORMATION_SCHEMA.STATISTICS 
        WHERE INDEX_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
        GROUP BY INDEX_SCHEMA, TABLE_NAME, INDEX_NAME
        ORDER BY INDEX_SCHEMA, TABLE_NAME, INDEX_NAME
    " > "$REPORT_DIR/$DATE/index_summary.csv"
}

# 收集约束信息
collect_constraint_info() {
    echo "收集约束信息..."
    
    mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" -e "
        SELECT 
            tc.CONSTRAINT_SCHEMA as '数据库',
            tc.TABLE_NAME as '表名',
            tc.CONSTRAINT_NAME as '约束名',
            tc.CONSTRAINT_TYPE as '约束类型',
            GROUP_CONCAT(kcu.COLUMN_NAME) as '约束列',
            CASE 
                WHEN tc.CONSTRAINT_TYPE = 'FOREIGN KEY' 
                THEN CONCAT(rc.REFERENCED_TABLE_NAME, '(', 
                           (SELECT GROUP_CONCAT(COLUMN_NAME) 
                            FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE 
                            WHERE CONSTRAINT_SCHEMA = rc.UNIQUE_CONSTRAINT_SCHEMA
                              AND CONSTRAINT_NAME = rc.UNIQUE_CONSTRAINT_NAME), ')')
                ELSE NULL
            END as '引用表列'
        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
            ON tc.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA
            AND tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
        LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
            ON tc.CONSTRAINT_SCHEMA = rc.CONSTRAINT_SCHEMA
            AND tc.CONSTRAINT_NAME = rc.CONSTRAINT_NAME
        WHERE tc.CONSTRAINT_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
        GROUP BY tc.CONSTRAINT_SCHEMA, tc.TABLE_NAME, tc.CONSTRAINT_NAME
        ORDER BY tc.CONSTRAINT_SCHEMA, tc.TABLE_NAME, tc.CONSTRAINT_TYPE
    " > "$REPORT_DIR/$DATE/constraint_summary.csv"
}

# 生成分析报告
generate_analysis_report() {
    echo "生成分析报告..."
    
    {
        echo "MySQL元数据分析报告"
        echo "生成时间: $(date)"
        echo "=========================================="
        echo
        
        echo "1. 数据库概览"
        mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" -t -e "
            SELECT 
                '数据库数量' as '项目',
                COUNT(DISTINCT TABLE_SCHEMA) as '数值'
            FROM INFORMATION_SCHEMA.TABLES 
            WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
            UNION ALL
            SELECT 
                '表总数',
                COUNT(*)
            FROM INFORMATION_SCHEMA.TABLES 
            WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
                AND TABLE_TYPE = 'BASE TABLE'
            UNION ALL
            SELECT 
                '索引总数',
                COUNT(DISTINCT CONCAT(INDEX_SCHEMA, '.', TABLE_NAME, '.', INDEX_NAME))
            FROM INFORMATION_SCHEMA.STATISTICS 
            WHERE INDEX_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
        "
        echo
        
        echo "2. 存储引擎分布"
        mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" -t -e "
            SELECT 
                ENGINE as '存储引擎',
                COUNT(*) as '表数量',
                ROUND(SUM(DATA_LENGTH)/1024/1024, 2) as '数据大小(MB)'
            FROM INFORMATION_SCHEMA.TABLES 
            WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
                AND TABLE_TYPE = 'BASE TABLE'
                AND ENGINE IS NOT NULL
            GROUP BY ENGINE
            ORDER BY COUNT(*) DESC
        "
        echo
        
        echo "3. TOP 10 大表"
        mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASS" -t -e "
            SELECT 
                TABLE_SCHEMA as '数据库',
                TABLE_NAME as '表名',
                TABLE_ROWS as '行数',
                ROUND((DATA_LENGTH + INDEX_LENGTH)/1024/1024, 2) as '总大小(MB)'
            FROM INFORMATION_SCHEMA.TABLES 
            WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
                AND TABLE_TYPE = 'BASE TABLE'
            ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC
            LIMIT 10
        "
        
    } > "$REPORT_DIR/$DATE/analysis_report.txt"
    
    echo "分析报告已生成: $REPORT_DIR/$DATE/analysis_report.txt"
}

# 主执行函数
main() {
    echo "MySQL元数据收集工具启动..."
    echo "目标主机: $DB_HOST:3306"
    echo
    
    collect_table_info
    collect_index_info  
    collect_constraint_info
    generate_analysis_report
    
    echo
    echo "元数据收集完成！"
    echo "报告目录: $REPORT_DIR/$DATE"
}

# 检查参数并执行
if [ "$1" = "--help" ]; then
    echo "用法: $0 [选项]"
    echo "环境变量："
    echo "  DB_HOST    - 数据库主机 (默认: localhost)"
    echo "  DB_USER    - 数据库用户 (默认: metadata_user)"  
    echo "  DB_PASS    - 数据库密码"
    echo "  REPORT_DIR - 报告目录 (默认: /opt/mysql/metadata-reports)"
    exit 0
fi

main "$@"
```

### 7.3 元数据管理最佳实践


**⭐ 日常运维检查清单**
```sql
-- 创建日常检查视图
CREATE VIEW daily_metadata_check AS
SELECT 
    'table_without_pk' as check_type,
    COUNT(*) as issue_count,
    CASE WHEN COUNT(*) > 0 THEN 'WARNING' ELSE 'OK' END as status
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu 
    ON t.TABLE_SCHEMA = kcu.TABLE_SCHEMA
    AND t.TABLE_NAME = kcu.TABLE_NAME
    AND kcu.CONSTRAINT_NAME = 'PRIMARY'
WHERE t.TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
    AND t.TABLE_TYPE = 'BASE TABLE'
    AND kcu.COLUMN_NAME IS NULL

UNION ALL

SELECT 
    'large_table_few_indexes',
    COUNT(*) as issue_count,
    CASE WHEN COUNT(*) > 0 THEN 'WARNING' ELSE 'OK' END as status
FROM (
    SELECT t.TABLE_NAME
    FROM INFORMATION_SCHEMA.TABLES t
    LEFT JOIN (
        SELECT 
            INDEX_SCHEMA, 
            TABLE_NAME, 
            COUNT(DISTINCT INDEX_NAME) as index_count
        FROM INFORMATION_SCHEMA.STATISTICS 
        GROUP BY INDEX_SCHEMA, TABLE_NAME
    ) idx ON t.TABLE_SCHEMA = idx.INDEX_SCHEMA 
         AND t.TABLE_NAME = idx.TABLE_NAME
    WHERE t.TABLE_SCHEMA = 'myapp'
        AND t.TABLE_ROWS > 100000
        AND IFNULL(idx.index_count, 0) < 2
) large_tables_issues

UNION ALL

SELECT 
    'charset_inconsistency',
    COUNT(DISTINCT CHARACTER_SET_NAME) - 1 as issue_count,
    CASE WHEN COUNT(DISTINCT CHARACTER_SET_NAME) > 1 THEN 'WARNING' ELSE 'OK' END as status
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'myapp'
    AND CHARACTER_SET_NAME IS NOT NULL;

-- 执行日常检查
SELECT 
    check_type as '检查项目',
    issue_count as '问题数量',
    status as '状态',
    CASE 
        WHEN check_type = 'table_without_pk' THEN '表缺少主键'
        WHEN check_type = 'large_table_few_indexes' THEN '大表索引不足'
        WHEN check_type = 'charset_inconsistency' THEN '字符集不一致'
    END as '问题描述'
FROM daily_metadata_check;
```

### 7.4 自动化运维脚本综合应用


**🔧 完整的元数据管理工具**
```python
#!/usr/bin/env python3
# metadata_manager.py - Python版元数据管理工具

import mysql.connector
import json
import csv
import argparse
from datetime import datetime, timedelta
import logging

class MetadataManager:
    def __init__(self, host, user, password, database=None):
        self.config = {
            'host': host,
            'user': user, 
            'password': password,
            'database': database,
            'autocommit': True
        }
        self.conn = None
        
    def connect(self):
        """连接数据库"""
        try:
            self.conn = mysql.connector.connect(**self.config)
            return True
        except Exception as e:
            logging.error(f"数据库连接失败: {e}")
            return False
            
    def get_table_metadata(self, schema_name):
        """获取表元数据信息"""
        cursor = self.conn.cursor(dictionary=True)
        
        query = """
        SELECT 
            TABLE_NAME,
            ENGINE,
            TABLE_ROWS,
            DATA_LENGTH,
            INDEX_LENGTH,
            AUTO_INCREMENT,
            CREATE_TIME,
            UPDATE_TIME,
            TABLE_COMMENT
        FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA = %s 
            AND TABLE_TYPE = 'BASE TABLE'
        ORDER BY DATA_LENGTH DESC
        """
        
        cursor.execute(query, (schema_name,))
        return cursor.fetchall()
    
    def get_index_metadata(self, schema_name):
        """获取索引元数据信息"""
        cursor = self.conn.cursor(dictionary=True)
        
        query = """
        SELECT 
            TABLE_NAME,
            INDEX_NAME,
            GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as COLUMNS,
            NON_UNIQUE,
            INDEX_TYPE,
            COUNT(*) as COLUMN_COUNT
        FROM INFORMATION_SCHEMA.STATISTICS 
        WHERE INDEX_SCHEMA = %s
        GROUP BY INDEX_SCHEMA, TABLE_NAME, INDEX_NAME
        ORDER BY TABLE_NAME, INDEX_NAME
        """
        
        cursor.execute(query, (schema_name,))
        return cursor.fetchall()
        
    def analyze_table_health(self, schema_name):
        """分析表健康状况"""
        cursor = self.conn.cursor(dictionary=True)
        
        # 检查没有主键的表
        no_pk_query = """
        SELECT t.TABLE_NAME
        FROM INFORMATION_SCHEMA.TABLES t
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu 
            ON t.TABLE_SCHEMA = kcu.TABLE_SCHEMA
            AND t.TABLE_NAME = kcu.TABLE_NAME
            AND kcu.CONSTRAINT_NAME = 'PRIMARY'
        WHERE t.TABLE_SCHEMA = %s
            AND t.TABLE_TYPE = 'BASE TABLE'
            AND kcu.COLUMN_NAME IS NULL
        """
        
        cursor.execute(no_pk_query, (schema_name,))
        no_pk_tables = [row['TABLE_NAME'] for row in cursor.fetchall()]
        
        # 检查大表少索引的情况
        few_index_query = """
        SELECT 
            t.TABLE_NAME,
            t.TABLE_ROWS,
            COUNT(DISTINCT s.INDEX_NAME) as INDEX_COUNT
        FROM INFORMATION_SCHEMA.TABLES t
        LEFT JOIN INFORMATION_SCHEMA.STATISTICS s 
            ON t.TABLE_SCHEMA = s.INDEX_SCHEMA 
            AND t.TABLE_NAME = s.TABLE_NAME
        WHERE t.TABLE_SCHEMA = %s
            AND t.TABLE_TYPE = 'BASE TABLE'
            AND t.TABLE_ROWS > 50000
        GROUP BY t.TABLE_NAME
        HAVING COUNT(DISTINCT s.INDEX_NAME) < 3
        ORDER BY t.TABLE_ROWS DESC
        """
        
        cursor.execute(few_index_query, (schema_name,))
        few_index_tables = cursor.fetchall()
        
        return {
            'tables_without_pk': no_pk_tables,
            'large_tables_few_indexes': few_index_tables
        }
    
    def generate_report(self, schema_name, output_file):
        """生成完整的元数据报告"""
        tables = self.get_table_metadata(schema_name)
        indexes = self.get_index_metadata(schema_name)
        health = self.analyze_table_health(schema_name)
        
        report = {
            'generated_at': datetime.now().isoformat(),
            'schema_name': schema_name,
            'summary': {
                'total_tables': len(tables),
                'total_indexes': len(indexes),
                'total_data_size_mb': sum(t['DATA_LENGTH'] or 0 for t in tables) / 1024 / 1024,
                'total_index_size_mb': sum(t['INDEX_LENGTH'] or 0 for t in tables) / 1024 / 1024
            },
            'tables': tables,
            'indexes': indexes,
            'health_issues': health
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, default=str, ensure_ascii=False)
            
        return report

def main():
    parser = argparse.ArgumentParser(description='MySQL元数据管理工具')
    parser.add_argument('--host', default='localhost', help='数据库主机')
    parser.add_argument('--user', required=True, help='数据库用户')
    parser.add_argument('--password', required=True, help='数据库密码')
    parser.add_argument('--schema', required=True, help='要分析的数据库名')
    parser.add_argument('--output', help='输出文件路径')
    
    args = parser.parse_args()
    
    # 初始化日志
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    
    # 创建管理器实例
    manager = MetadataManager(args.host, args.user, args.password)
    
    if not manager.connect():
        logging.error("无法连接到数据库")
        return 1
        
    # 生成报告
    output_file = args.output or f"metadata_report_{args.schema}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    try:
        report = manager.generate_report(args.schema, output_file)
        
        print(f"元数据报告已生成: {output_file}")
        print(f"数据库: {report['schema_name']}")
        print(f"表数量: {report['summary']['total_tables']}")
        print(f"索引数量: {report['summary']['total_indexes']}")
        print(f"数据大小: {report['summary']['total_data_size_mb']:.2f} MB")
        print(f"索引大小: {report['summary']['total_index_size_mb']:.2f} MB")
        
        # 显示健康问题
        if report['health_issues']['tables_without_pk']:
            print(f"⚠️ 发现 {len(report['health_issues']['tables_without_pk'])} 个表没有主键")
            
        if report['health_issues']['large_tables_few_indexes']:
            print(f"⚠️ 发现 {len(report['health_issues']['large_tables_few_indexes'])} 个大表索引不足")
            
    except Exception as e:
        logging.error(f"生成报告失败: {e}")
        return 1
    finally:
        if manager.conn:
            manager.conn.close()
    
    return 0

if __name__ == '__main__':
    exit(main())
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


**🔸 元数据的本质理解**
```
元数据 = 描述数据结构的数据
• 表结构：列名、数据类型、约束
• 索引信息：索引名、列组合、类型
• 统计信息：行数、大小、更新时间
• 权限信息：用户、角色、权限范围
```

**🔸 INFORMATION_SCHEMA的核心价值**
```
标准化接口：
• 符合SQL标准，跨数据库兼容
• 提供统一的元数据查询方式
• 支持复杂的元数据分析查询

实时性：
• 反映当前数据库状态
• 无需额外维护
• 查询结果始终最新
```

### 8.2 关键理解要点


**🔹 元数据查询的性能考虑**
```
查询优化原则：
• 始终指定具体的数据库名
• 避免全库扫描式查询  
• 使用精确匹配而非模糊查询
• 合理使用LIMIT限制结果集

示例对比：
❌ SELECT * FROM INFORMATION_SCHEMA.TABLES
✅ SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'myapp'
```

**🔹 元数据锁的重要性**
```
MDL锁保护表结构一致性：
• 读操作：共享锁，允许并发读
• DDL操作：排他锁，阻塞所有其他操作
• 长事务：可能导致DDL操作等待

避免MDL锁问题：
• 控制事务时间，及时提交
• DDL操作选择业务低峰期
• 监控锁等待情况
```

**🔹 元数据管理的自动化思维**
```
手工查询 → 脚本化 → 自动化监控
• 定期收集元数据信息
• 自动分析潜在问题
• 及时通知相关人员
• 建立变更审计机制
```

### 8.3 实际应用价值


**🎯 开发阶段的应用**
```
数据库设计验证：
• 检查表是否有主键
• 验证外键约束正确性
• 分析索引设计合理性

代码生成：
• 根据表结构生成实体类
• 自动生成CRUD代码
• 生成API文档
```

**🎯 运维阶段的应用**
```
性能优化：
• 识别缺少索引的大表
• 发现冗余或无效索引
• 分析表增长趋势

容量规划：
• 统计数据库大小增长
• 预测存储需求
• 规划硬件资源

故障排查：
• 检查元数据锁等待
• 分析表结构变更历史
• 验证主从数据一致性
```

**🎯 数据治理的应用**
```
数据标准化：
• 检查命名规范
• 验证数据类型一致性
• 确保注释完整性

合规性检查：
• 识别包含敏感信息的列
• 检查数据保留策略
• 验证访问权限设置
```

### 8.4 学习建议和最佳实践


**📚 学习路径建议**
```
基础阶段：
1. 熟练使用DESCRIBE、SHOW COLUMNS等基础命令
2. 理解INFORMATION_SCHEMA的常用视图
3. 掌握基本的元数据查询方法

进阶阶段：
1. 学习复杂的联合查询分析
2. 理解元数据锁机制
3. 掌握元数据备份和恢复

高级阶段：
1. 开发自动化元数据管理工具
2. 建立元数据变更管理流程
3. 实现元数据驱动的代码生成
```

**🔧 实践建议**
```
日常习惯：
• 建表前先查看现有结构
• 定期检查表大小和增长趋势
• 监控索引使用情况

开发规范：
• 所有表必须有主键
• 重要字段必须有注释
• 索引命名要有规律
• 外键约束要明确定义

运维规范：
• 定期备份元数据
• 记录所有结构变更
• 监控元数据锁等待
• 建立变更审批流程
```

**💡 常见误区避免**
```
❌ 错误认知：
• "元数据查询不影响性能" - 复杂查询也会有开销
• "INFORMATION_SCHEMA总是准确的" - 某些统计信息是估算值
• "元数据不需要备份" - 结构比数据更重要

✅ 正确理解：
• 元数据查询也需要优化
• 统计信息有滞后性和估算性
• 元数据备份是灾难恢复的基础
```

**核心记忆**：
- 元数据是数据库的"说明书"，描述数据结构和组织方式
- INFORMATION_SCHEMA提供标准化的元数据查询接口
- 元数据锁保护结构一致性，但可能影响DDL操作
- 自动化元数据管理是现代数据库运维的必备技能
- 元数据分析是性能优化和问题排查的重要手段