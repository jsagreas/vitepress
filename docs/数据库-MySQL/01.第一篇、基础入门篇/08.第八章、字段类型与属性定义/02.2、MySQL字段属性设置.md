---
title: 2、MySQL字段属性设置
---
## 📚 目录

1. [字段属性基本概念](#1-字段属性基本概念)
2. [空值约束与唯一性](#2-空值约束与唯一性)
3. [主键与外键约束](#3-主键与外键约束)
4. [检查约束与字段级索引](#4-检查约束与字段级索引)
5. [高级字段属性详解](#5-高级字段属性详解)
6. [属性组合配置策略](#6-属性组合配置策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏷️ 字段属性基本概念


### 1.1 什么是字段属性


**💡 通俗理解**：字段属性就像给数据设置的"规则和标签"
```
想象一个员工信息登记表：
📝 姓名：必须填写，不能为空 → NOT NULL属性
🆔 员工号：全公司唯一 → UNIQUE属性  
📞 手机号：11位数字格式 → CHECK约束
💰 工资：只有HR能看到 → 字段级权限控制

每个字段都有自己的"个性"和"规矩"
```

### 1.2 字段属性的作用


**🎯 核心作用**
```
数据完整性：确保数据符合业务规则
约束验证：在数据插入/更新时自动检查
索引优化：为高效查询创建索引
安全控制：控制字段的访问权限
存储优化：影响数据的存储方式和性能
```

### 1.3 属性分类概览


**🔸 字段属性分类图**
```
字段属性
├── 基础约束属性
│   ├── NULL/NOT NULL        ← 空值控制
│   ├── UNIQUE              ← 唯一性约束
│   ├── PRIMARY KEY         ← 主键约束
│   └── FOREIGN KEY         ← 外键约束
├── 验证约束属性  
│   ├── CHECK               ← 检查约束
│   ├── DEFAULT             ← 默认值
│   └── AUTO_INCREMENT      ← 自增属性
├── 索引相关属性
│   ├── INDEX               ← 普通索引
│   ├── FULLTEXT            ← 全文索引
│   └── SPATIAL             ← 空间索引
└── 高级扩展属性
    ├── INVISIBLE           ← 不可见字段
    ├── 字段级权限控制       ← 访问控制
    ├── 字段级加密配置       ← 数据加密
    └── 字段级审计标记       ← 操作审计
```

---

## 2. 🔒 空值约束与唯一性


### 2.1 NULL vs NOT NULL详解


**💡 NULL的含义**：NULL不是空字符串，而是"未知值"
```
NULL 的真实含义：
'' (空字符串) ≠ NULL (未知值)
0 (数字零) ≠ NULL (未知值)  
' ' (空格) ≠ NULL (未知值)

实际例子：
员工表中的"配偶姓名"字段：
- 未婚员工：NULL（没有配偶）
- 已婚但不愿透露：''（空字符串）
- 这两种情况含义完全不同！
```

**🔸 NULL属性使用规则**
```sql
-- 默认情况：字段允许NULL
CREATE TABLE users (
    name VARCHAR(50),           -- 可以为NULL
    email VARCHAR(100)          -- 可以为NULL
);

-- 明确不允许NULL
CREATE TABLE users (
    name VARCHAR(50) NOT NULL,  -- 必须有值
    email VARCHAR(100) NOT NULL -- 必须有值
);
```

**⚠️ NULL的注意事项**
```sql
-- NULL的比较运算特殊性
SELECT * FROM users WHERE email = NULL;     -- ❌ 错误写法
SELECT * FROM users WHERE email IS NULL;    -- ✅ 正确写法

-- NULL参与计算的结果
SELECT salary + bonus FROM employees;       -- 如果bonus是NULL，结果是NULL
SELECT IFNULL(salary, 0) + IFNULL(bonus, 0); -- ✅ 正确处理NULL
```

### 2.2 UNIQUE唯一性约束深入


**🆔 UNIQUE约束的本质**
```
💡 作用：确保字段值在整个表中唯一，不重复

实际应用场景：
✅ 用户邮箱：一个邮箱只能注册一个账号
✅ 身份证号：每个人的身份证号都是唯一的  
✅ 产品编码：每个商品的编码不能重复
✅ 手机号码：一个手机号只能绑定一个用户
```

**🔧 UNIQUE的配置方式**
```sql
-- 方式1：字段级别定义
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE,          -- 单字段唯一
    phone VARCHAR(20) UNIQUE
);

-- 方式2：表级别定义  
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100),
    phone VARCHAR(20),
    UNIQUE KEY uk_email (email),        -- 命名唯一约束
    UNIQUE KEY uk_phone (phone)
);

-- 方式3：复合唯一约束
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    UNIQUE KEY uk_order_product (order_id, product_id)  -- 组合唯一
);
```

**📊 UNIQUE vs PRIMARY KEY对比**

| 特性 | **UNIQUE** | **PRIMARY KEY** | **说明** |
|------|-----------|----------------|----------|
| 🔢 **数量限制** | `多个` | `只能1个` | 一个表可以有多个UNIQUE |
| 🚫 **NULL值** | `允许1个NULL` | `不允许NULL` | UNIQUE可以有一个NULL值 |
| 📇 **聚集索引** | `否` | `是` | PRIMARY KEY创建聚集索引 |
| 🔗 **外键引用** | `可以` | `可以` | 都可以被外键引用 |

---

## 3. 🔑 主键与外键约束


### 3.1 PRIMARY KEY主键深入理解


**💡 主键的本质**：主键是表中每一行的"身份证号"
```
主键的核心特征：
🆔 唯一性：不能有重复值
🚫 非空性：不能为NULL
📇 聚集性：InnoDB中主键决定数据物理存储顺序
🔗 引用性：其他表可以通过外键引用主键
```

**🔧 主键设计策略**

| 主键类型 | **优点** | **缺点** | **适用场景** |
|---------|----------|----------|-------------|
| **自增ID** | `简单高效` | `无业务含义` | 大部分应用表 |
| **业务主键** | `有业务含义` | `可能变更` | 字典表、配置表 |
| **UUID** | `全局唯一` | `性能较差` | 分布式系统 |
| **复合主键** | `业务关联性强` | `复杂度高` | 关联表、明细表 |

**💻 主键配置示例**
```sql
-- 自增主键（推荐方式）
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- 简洁写法
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
);

-- 业务主键
CREATE TABLE products (
    product_code VARCHAR(20) PRIMARY KEY,  -- 商品编码作主键
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2)
);

-- 复合主键
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)     -- 组合主键
);
```

### 3.2 FOREIGN KEY外键约束详解


**🔗 外键的作用**：维护表与表之间的数据关联性
```
💡 生活比喻：
学生表的"班级ID"必须在班级表中存在
就像学生必须属于一个真实存在的班级
不能让学生属于一个不存在的"幻想班级"

外键 = 数据关系的"质检员"
确保关联数据的真实性和有效性
```

**🔧 外键配置与使用**
```sql
-- 创建父表（被引用表）
CREATE TABLE classes (
    class_id INT PRIMARY KEY,
    class_name VARCHAR(50) NOT NULL
);

-- 创建子表（引用表）
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(50) NOT NULL,
    class_id INT,
    FOREIGN KEY (class_id) REFERENCES classes(class_id)
);

-- 带约束动作的外键
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
        ON DELETE CASCADE          -- 删除用户时删除其订单
        ON UPDATE CASCADE          -- 更新用户ID时同步更新
);
```

**⚠️ 外键约束动作说明**

| 约束动作 | **含义** | **使用场景** |
|---------|----------|-------------|
| **CASCADE** | `级联操作` | 主表变化时，从表跟着变化 |
| **SET NULL** | `设为NULL` | 主表删除时，从表字段置空 |
| **RESTRICT** | `拒绝操作` | 有从表数据时，禁止删除主表 |
| **NO ACTION** | `不采取行动` | 默认行为，检查约束但不操作 |

---

## 4. ✅ 检查约束与字段级索引


### 4.1 CHECK检查约束详解


**💡 CHECK约束的作用**：为字段值设置"合法范围"
```
生活例子：
年龄字段：必须在0-150之间
邮箱格式：必须包含@符号
工资等级：只能是1-10级
性别：只能是'男'或'女'

CHECK约束 = 数据的"入门检查员"
```

**🔧 CHECK约束配置**
```sql
-- MySQL 8.0+支持CHECK约束
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 65),           -- 年龄范围
    salary DECIMAL(10,2) CHECK (salary > 0),           -- 工资必须为正
    email VARCHAR(100) CHECK (email LIKE '%@%'),       -- 邮箱格式
    gender ENUM('男', '女') NOT NULL,                  -- 枚举替代CHECK
    level INT CHECK (level BETWEEN 1 AND 10)           -- 等级范围
);

-- 命名CHECK约束（便于管理）
CREATE TABLE products (
    id INT PRIMARY KEY,
    price DECIMAL(10,2),
    stock INT,
    CONSTRAINT chk_price CHECK (price >= 0),           -- 命名约束
    CONSTRAINT chk_stock CHECK (stock >= 0)
);
```

### 4.2 字段级索引配置


**📇 索引的通俗理解**：索引就像书的"目录"
```
没有索引的查询：
翻遍整本书找内容 → 全表扫描（慢）

有索引的查询：
先看目录找到页码，直接翻到对应页 → 索引查询（快）
```

**🔧 字段级索引创建**
```sql
-- 在创建表时定义索引
CREATE TABLE users (
    id INT PRIMARY KEY,                    -- 主键自动创建索引
    email VARCHAR(100) UNIQUE,             -- 唯一约束自动创建索引
    name VARCHAR(50),
    phone VARCHAR(20),
    city VARCHAR(50),
    
    INDEX idx_name (name),                 -- 普通索引
    INDEX idx_phone (phone),               -- 单字段索引
    INDEX idx_city_name (city, name)       -- 复合索引
);

-- 后续添加索引
ALTER TABLE users ADD INDEX idx_email (email);
CREATE INDEX idx_phone ON users(phone);
```

**📊 不同索引类型的应用**

| 索引类型 | **适用数据类型** | **适用场景** | **查询特点** |
|---------|-----------------|-------------|-------------|
| **B+树索引** | `数值、字符、日期` | 范围查询、排序 | 等值+范围查询 |
| **哈希索引** | `等值查询字段` | 精确匹配 | 只支持等值查询 |
| **全文索引** | `TEXT类型` | 文本搜索 | 关键词搜索 |
| **空间索引** | `几何类型` | 地理位置 | 空间范围查询 |

---

## 5. 🚀 高级字段属性详解


### 5.1 INVISIBLE不可见字段


**👻 不可见字段的概念**：数据存在但"隐身"的字段
```
💡 应用场景：
系统内部使用，但不想让应用看到的字段

实际例子：
用户表添加一个"最后登录IP"字段
→ 系统内部统计用，但普通查询不显示
→ 避免影响现有应用代码
```

**🔧 INVISIBLE字段配置**
```sql
-- 创建不可见字段
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    last_login_ip VARCHAR(45) INVISIBLE,    -- 不可见字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP INVISIBLE
);

-- 查询行为对比
SELECT * FROM users;                        -- 不显示INVISIBLE字段
SELECT id, name, email, last_login_ip FROM users;  -- 明确指定才显示

-- 修改字段可见性
ALTER TABLE users MODIFY COLUMN last_login_ip VARCHAR(45) VISIBLE;
```

### 5.2 字段级权限控制


**🔐 字段级权限的意义**：不同用户只能看到被允许的字段
```
💡 实际应用：
员工管理系统中：
- 普通员工：只能看到自己的基本信息
- HR：可以看到所有员工的工资信息  
- 财务：可以看到工资但不能看到绩效评价
- 管理员：可以看到所有字段

实现细粒度的数据访问控制
```

**🔧 权限控制实现方式**
```sql
-- 创建不同权限的用户
CREATE USER 'hr_user'@'%' IDENTIFIED BY 'password';
CREATE USER 'finance_user'@'%' IDENTIFIED BY 'password';
CREATE USER 'normal_user'@'%' IDENTIFIED BY 'password';

-- 授予不同的字段访问权限
-- HR可以看到所有字段
GRANT SELECT ON company.employees TO 'hr_user'@'%';

-- 财务只能看到工资相关字段
GRANT SELECT (id, name, salary, bonus) ON company.employees TO 'finance_user'@'%';

-- 普通用户只能看到基本信息
GRANT SELECT (id, name, department) ON company.employees TO 'normal_user'@'%';
```

### 5.3 字段级加密配置


**🔐 字段加密的必要性**：敏感数据的"保险箱"
```
💡 需要加密的敏感字段：
✅ 身份证号：个人隐私信息
✅ 银行卡号：金融敏感数据
✅ 手机号码：个人联系方式
✅ 密码字段：用户认证信息
```

**🔧 加密实现方式**
```sql
-- 应用层加密（推荐）
INSERT INTO users (name, phone, id_card) VALUES (
    '张三',
    AES_ENCRYPT('13888888888', 'encryption_key'),      -- 手机号加密
    AES_ENCRYPT('110101199001011234', 'encryption_key') -- 身份证加密
);

-- 查询时解密
SELECT 
    name,
    AES_DECRYPT(phone, 'encryption_key') AS phone,
    AES_DECRYPT(id_card, 'encryption_key') AS id_card
FROM users;

-- MySQL 8.0透明数据加密（TDE）
ALTER TABLE sensitive_data ENCRYPTION='Y';              -- 整表加密
```

### 5.4 字段级审计标记


**📋 审计的含义**：记录"谁、什么时候、做了什么"
```
💡 审计的重要性：
合规要求：金融、医疗等行业的法规要求
安全追踪：发现数据泄露或误操作的来源
责任追溯：出现问题时能找到责任人

审计字段设计：
created_by    ← 谁创建的
created_at    ← 什么时候创建
updated_by    ← 谁最后修改的  
updated_at    ← 什么时候修改
```

**🔧 审计字段配置**
```sql
CREATE TABLE sensitive_data (
    id INT PRIMARY KEY,
    data_content TEXT NOT NULL,
    
    -- 审计字段
    created_by VARCHAR(50) NOT NULL,                    -- 创建人
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,     -- 创建时间
    updated_by VARCHAR(50),                             -- 修改人
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 操作类型标记
    operation_type ENUM('INSERT', 'UPDATE', 'DELETE') DEFAULT 'INSERT',
    operation_ip VARCHAR(45),                           -- 操作IP
    operation_reason TEXT                               -- 操作原因
);
```

---

## 6. ⚙️ 属性组合配置策略


### 6.1 字段约束验证时机


**⏰ 约束检查的时间点**
```
💡 MySQL约束检查顺序：

数据插入/更新时的检查流程：
1️⃣ 数据类型检查：值是否符合字段数据类型
2️⃣ NOT NULL检查：必填字段是否有值
3️⃣ CHECK约束检查：值是否满足CHECK条件
4️⃣ UNIQUE约束检查：值是否在表中唯一
5️⃣ 外键约束检查：引用的主表记录是否存在

任何一步失败，整个操作就会被拒绝
```

**🔧 约束验证示例**
```sql
-- 创建带多重约束的表
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    amount DECIMAL(10,2) CHECK (amount > 0),           -- CHECK约束
    status ENUM('pending', 'paid', 'shipped', 'completed'),
    order_no VARCHAR(32) UNIQUE NOT NULL,              -- 唯一+非空
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id)         -- 外键约束
);

-- 插入数据时的约束验证
INSERT INTO orders (user_id, amount, order_no) VALUES 
(1, 99.99, 'ORD2025090100001');  -- ✅ 通过所有约束检查

INSERT INTO orders (user_id, amount, order_no) VALUES 
(999, -10.00, 'ORD2025090100001');  -- ❌ 多重约束失败
-- 外键约束失败：user_id=999不存在
-- CHECK约束失败：amount=-10.00 < 0  
-- UNIQUE约束失败：order_no重复
```

### 6.2 属性组合规则与最佳实践


**🔑 字段属性完整配置清单**

| 属性类型 | **配置语法** | **使用说明** | **注意事项** |
|---------|-------------|-------------|-------------|
| **空值约束** | `NOT NULL` | 字段必须有值 | 主键自动NOT NULL |
| **唯一约束** | `UNIQUE` | 值不能重复 | 允许一个NULL值 |
| **主键约束** | `PRIMARY KEY` | 唯一+非空+聚集 | 一表只能一个 |
| **外键约束** | `FOREIGN KEY` | 引用其他表主键 | 需要索引支持 |
| **检查约束** | `CHECK(条件)` | 值必须满足条件 | MySQL 8.0+支持 |
| **默认值** | `DEFAULT 值` | 未指定时的默认值 | 可以是函数 |
| **自增属性** | `AUTO_INCREMENT` | 自动递增数值 | 只能用于整数主键 |
| **不可见属性** | `INVISIBLE` | 隐藏字段 | MySQL 8.0+支持 |

**🎯 属性组合配置方法**
```sql
-- 完整的字段属性组合示例
CREATE TABLE user_profiles (
    -- 主键：自增+主键+非空
    id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 基本信息：非空+唯一约束
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    
    -- 可选信息：允许空值+默认值
    nickname VARCHAR(50) DEFAULT '新用户',
    avatar_url VARCHAR(255) DEFAULT '/default-avatar.jpg',
    
    -- 数值约束：CHECK约束+默认值
    age INT CHECK (age >= 0 AND age <= 150) DEFAULT 0,
    score INT CHECK (score >= 0 AND score <= 100) DEFAULT 0,
    
    -- 枚举约束：限定取值范围
    gender ENUM('男', '女', '保密') DEFAULT '保密',
    status ENUM('active', 'inactive', 'banned') DEFAULT 'active',
    
    -- 外键关联：引用其他表
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id),
    
    -- 审计字段：时间戳+不可见
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_login_ip VARCHAR(45) INVISIBLE,              -- 不可见字段
    
    -- 字段级索引
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_department (department_id)
);
```

### 6.3 属性冲突处理与继承机制


**⚠️ 常见属性冲突**
```
冲突情况1：PRIMARY KEY + NULL
解决：PRIMARY KEY自动包含NOT NULL，无需指定

冲突情况2：AUTO_INCREMENT + 非整数类型
解决：AUTO_INCREMENT只能用于整数类型字段

冲突情况3：UNIQUE + 多个NULL值
解决：UNIQUE约束允许多个NULL值（MySQL特性）

冲突情况4：外键字段类型不匹配
解决：外键字段必须与引用字段类型完全一致
```

**🔄 属性继承示例**
```sql
-- 通过LIKE继承表结构和属性
CREATE TABLE users_backup LIKE users;              -- 继承所有属性

-- 继承部分属性的新表
CREATE TABLE users_archive AS SELECT 
    id, username, email, created_at 
FROM users WHERE 1=0;                              -- 只继承结构

-- 修改继承后的属性
ALTER TABLE users_archive 
    ADD PRIMARY KEY (id),                          -- 添加主键
    MODIFY username VARCHAR(50) NOT NULL UNIQUE;   -- 修改约束
```

---

## 7. 📊 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 字段属性 = 数据规则的定义，控制数据的完整性和行为
🔸 NULL/NOT NULL = 控制字段是否可以为空值
🔸 UNIQUE = 确保字段值在表中的唯一性  
🔸 PRIMARY KEY = 主键，唯一标识每一行数据
🔸 FOREIGN KEY = 外键，维护表间关联关系
🔸 CHECK约束 = 自定义数据值的合法范围
🔸 字段级索引 = 提升特定字段的查询性能
```

### 7.2 关键理解要点


**🔹 为什么需要字段属性**
```
数据质量保障：
- 防止脏数据进入数据库
- 确保业务规则的执行
- 维护数据的一致性

性能优化：
- 合理的索引提升查询速度
- 适当的约束减少无效操作
- 优化存储空间使用

业务安全：
- 敏感字段加密保护
- 字段级权限控制
- 操作审计追踪
```

**🔹 属性设置最佳实践**
```
设计原则：
1️⃣ 根据业务需求选择合适的约束
2️⃣ 平衡数据完整性和性能影响
3️⃣ 考虑未来扩展和维护需求
4️⃣ 遵循最小权限原则

常见模式：
✅ 主键：AUTO_INCREMENT + PRIMARY KEY
✅ 业务唯一字段：NOT NULL + UNIQUE + INDEX  
✅ 关联字段：FOREIGN KEY + INDEX
✅ 枚举字段：ENUM类型代替CHECK约束
✅ 审计字段：TIMESTAMP + DEFAULT + INVISIBLE
```

**🔹 约束选择策略**
```
严格业务系统：
→ 使用完整的约束体系（主键+外键+CHECK）
→ 确保数据完整性，防止业务逻辑错误

高性能系统：
→ 减少约束检查，在应用层控制
→ 只保留必要的主键和唯一约束

数据仓库系统：
→ 最少约束，重点关注查询性能
→ 主要使用索引优化查询速度
```

### 7.3 实际应用价值


**💼 业务场景应用**
- **电商系统**：商品编码UNIQUE，订单金额CHECK约束，用户外键关联
- **用户管理**：邮箱UNIQUE，密码加密存储，登录IP不可见记录
- **财务系统**：完整审计字段，金额CHECK约束，严格外键关联
- **内容管理**：文章标题全文索引，作者外键，发布状态枚举

**🔧 开发实践**
- **设计阶段**：根据业务规则设置合适的约束
- **开发阶段**：利用约束减少业务逻辑代码
- **测试阶段**：验证约束的有效性和性能影响
- **运维阶段**：监控约束违反情况，优化索引性能

**🎯 性能影响考虑**
```
约束检查成本：
CHECK约束 > 外键约束 > 唯一约束 > 非空约束

索引维护成本：
复合索引 > 单字段索引 > 无索引

设计权衡：
数据完整性 vs 插入性能
查询速度 vs 存储空间
安全级别 vs 访问便利性
```

**核心记忆**：
- 字段属性是数据质量的守护者
- 合理配置属性能提升系统健壮性
- 不同场景需要不同的约束策略
- 安全和性能需要平衡考虑