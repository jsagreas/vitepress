---
title: 1、关系型数据库基础理论
---
## 📚 目录

1. [关系模型理论概述](#1-关系模型理论概述)
2. [关系模型三要素详解](#2-关系模型三要素详解)
3. [实体关系模型基础](#3-实体关系模型基础)
4. [范式理论与数据库设计](#4-范式理论与数据库设计)
5. [ACID特性与数据完整性](#5-acid特性与数据完整性)
6. [关系代数与SQL理论基础](#6-关系代数与sql理论基础)
7. [Codd的12条规则详解](#7-codd的12条规则详解)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 关系模型理论概述


### 1.1 Edgar F. Codd关系模型理论


**🧑‍💼 Edgar F. Codd是谁？**
- **IBM研究员**：1970年提出关系数据库理论
- **图灵奖得主**：因关系模型理论获得1981年图灵奖
- **数据库之父**：现代关系型数据库的理论奠基人

**🔥 关系模型的革命性意义**
```
传统数据存储方式：
文件系统 → 层次数据库 → 网状数据库

问题：
• 数据访问复杂，需要编程
• 数据结构变更困难
• 数据独立性差

Codd的解决方案：
• 用数学中的关系概念描述数据
• 提供简单的查询语言
• 数据与程序分离
```

### 1.2 关系模型的核心思想


**🎯 基本理念**
关系模型把现实世界的数据抽象成**数学关系**，就像一张**二维表格**：

```
学生信息表（关系）
┌────────┬──────┬──────┬────────┐
│ 学号   │ 姓名 │ 年龄 │ 专业   │
├────────┼──────┼──────┼────────┤
│ 001    │ 张三 │  20  │ 计算机 │
│ 002    │ 李四 │  19  │ 数学   │
│ 003    │ 王五 │  21  │ 物理   │
└────────┴──────┴──────┴────────┘

每一行 = 一个元组（tuple）= 一条记录
每一列 = 一个属性（attribute）= 一个字段
整张表 = 一个关系（relation）= 实体集合
```

**💡 通俗理解**
- **关系 = 表格**：存储同一类事物的信息
- **元组 = 行**：表示一个具体的事物
- **属性 = 列**：表示事物的特征

---

## 2. 🔑 关系模型三要素详解


### 2.1 数据结构：关系（Relation）


**🔸 什么是关系？**
关系就是一张**二维表**，但有严格的数学定义：

```
数学定义：设有域D₁, D₂, ..., Dₙ
关系R是这些域的笛卡尔积的子集
R ⊆ D₁ × D₂ × ... × Dₙ

通俗理解：
关系 = 符合特定规则的表格
• 每行代表一个实体实例
• 每列代表一个属性
• 表格内容必须满足完整性约束
```

**🔸 域（Domain）定义**
域就是**属性的取值范围**：

| 属性名 | 域定义 | 举例 |
|--------|--------|------|
| **学号** | `4位数字字符串` | "0001", "0002" |
| **年龄** | `16-100的整数` | 18, 19, 20 |
| **性别** | `{男, 女}` | "男" 或 "女" |
| **成绩** | `0-100的小数` | 85.5, 92.0 |

### 2.2 元组（Tuple）与属性（Attribute）概念


**🔸 元组（Tuple）详解**
```
元组 = 关系中的一行数据

示例元组：
(学号: "001", 姓名: "张三", 年龄: 20, 专业: "计算机")

特点：
✅ 元组中每个分量都来自相应域
✅ 元组的顺序无关紧要
✅ 元组不能重复（通过主键保证）
```

**🔸 属性（Attribute）详解**
```
属性 = 关系中的一列

属性的组成：
• 属性名：如"姓名"、"年龄"
• 域：属性的取值范围
• 值：属性在特定元组中的具体数据

属性分类：
🔑 主属性：构成主键的属性
🔸 非主属性：不构成主键的属性
```

### 2.3 关系运算


**🔸 关系代数基本操作详解**

**选择（Selection）- σ**
```
作用：从关系中选出满足条件的元组（行）

SQL示例：
SELECT * FROM 学生表 WHERE 年龄 > 19;

结果：只返回年龄大于19的学生记录
```

**投影（Projection）- π**
```
作用：从关系中选出指定的属性（列）

SQL示例：
SELECT 姓名, 专业 FROM 学生表;

结果：只返回姓名和专业两列
```

**连接（Join）- ⋈**
```
作用：将两个关系按某个条件组合

学生表          成绩表
┌──────┬──────┐  ┌──────┬──────┐
│ 学号 │ 姓名 │  │ 学号 │ 分数 │
├──────┼──────┤  ├──────┼──────┤
│ 001  │ 张三 │  │ 001  │  85  │
│ 002  │ 李四 │  │ 002  │  92  │
└──────┴──────┘  └──────┴──────┘

连接结果：
┌──────┬──────┬──────┐
│ 学号 │ 姓名 │ 分数 │
├──────┼──────┼──────┤
│ 001  │ 张三 │  85  │
│ 002  │ 李四 │  92  │
└──────┴──────┴──────┘
```

---

## 3. 🏗️ 实体关系模型基础


### 3.1 实体关系模型（E-R模型）


**🔸 E-R模型是什么？**
Entity-Relationship Model，用来描述现实世界的概念模型：

```
现实世界的抽象过程：
现实世界 → 概念模型（E-R图）→ 逻辑模型（关系表）→ 物理模型（数据库文件）

E-R模型的三个基本概念：
🔸 实体（Entity）：现实世界中的事物
🔸 属性（Attribute）：实体的特征
🔸 关系（Relationship）：实体间的联系
```

### 3.2 E-R图基本元素


**🔸 图形表示法**
```
实体关系图示例：

    ┌─────────┐         ┌─────────┐
    │  学生   │         │  课程   │
    │ (实体)  │         │ (实体)  │
    └─────────┘         └─────────┘
         │                   │
         │     ◊选课◊        │
         └─────────────────────┘
              (关系)

属性表示：
学生属性：学号(主键)、姓名、年龄、专业
课程属性：课程号(主键)、课程名、学分
选课属性：成绩（关系的属性）
```

### 3.3 实体间的联系类型


**🔸 一对一（1:1）**
```
例：员工 ←→ 身份证
一个员工对应一个身份证号
一个身份证号对应一个员工
```

**🔸 一对多（1:N）**
```
例：部门 ← 员工
一个部门有多个员工
一个员工属于一个部门
```

**🔸 多对多（M:N）**
```
例：学生 ←→ 课程
一个学生可以选多门课程
一门课程可以被多个学生选择
```

---

## 4. 📐 范式理论与数据库设计


### 4.1 什么是范式？


**🔸 范式的通俗理解**
范式就是设计数据库表的**规范标准**，就像建房子的建筑规范：

```
为什么需要范式？
❌ 没有规范的表设计：
┌──────┬──────┬──────────┬──────────┐
│ 学号 │ 姓名 │ 课程列表 │ 成绩列表 │
├──────┼──────┼──────────┼──────────┤
│ 001  │ 张三 │ 数学,英语│ 85,92    │
└──────┴──────┴──────────┴──────────┘

问题：
• 数据冗余：课程信息重复存储
• 更新异常：修改课程名要改多处
• 插入异常：不能单独添加课程
• 删除异常：删除学生丢失课程信息
```

### 4.2 函数依赖与多值依赖理论


**🔸 函数依赖（Functional Dependency）**
```
定义：如果属性A的值能唯一确定属性B的值
则称B函数依赖于A，记作A → B

通俗理解：
学号 → 姓名  （知道学号就能确定姓名）
学号 → 专业  （知道学号就能确定专业）
(学号,课程号) → 成绩  （知道学号和课程号就能确定成绩）

函数依赖类型：
• 完全函数依赖：B依赖于A的所有属性
• 部分函数依赖：B只依赖于A的部分属性
• 传递函数依赖：A → B, B → C，则A → C
```

**🔸 多值依赖（Multi-Valued Dependency）**
```
定义：属性A的一个值对应属性B的多个值
且B的取值与其他属性无关

例子：教师表
┌──────┬──────┬──────┐
│ 教师 │ 课程 │ 教材 │
├──────┼──────┼──────┤
│ 张老师│ 数学 │ 高数 │
│ 张老师│ 数学 │ 线代 │
│ 张老师│ 英语 │ 新概念│
└──────┴──────┴──────┘

教师 →→ 课程（一个教师教多门课程）
教师 →→ 教材（一个教师用多种教材）
```

### 4.3 范式详解


**🔸 第一范式（1NF）**
```
要求：表中每个字段都是原子性的，不可再分

❌ 违反1NF：
┌──────┬──────────┐
│ 学号 │ 联系方式  │
├──────┼──────────┤
│ 001  │ 电话:123 │
│      │ 邮箱:a@b │
└──────┴──────────┘

✅ 符合1NF：
┌──────┬──────┬──────────┐
│ 学号 │ 电话 │ 邮箱     │
├──────┼──────┼──────────┤
│ 001  │ 123  │ a@b.com  │
└──────┴──────┴──────────┘
```

**🔸 第二范式（2NF）**
```
要求：在1NF基础上，消除部分函数依赖

❌ 违反2NF：
┌──────┬────────┬──────┬──────┐
│ 学号 │ 课程号 │ 姓名 │ 成绩 │
├──────┼────────┼──────┼──────┤
│ 001  │ C001   │ 张三 │  85  │
│ 001  │ C002   │ 张三 │  92  │
└──────┴────────┴──────┴──────┘

问题：姓名只依赖学号，不依赖课程号

✅ 符合2NF：拆分成两个表
学生表：学号 → 姓名
选课表：(学号,课程号) → 成绩
```

**🔸 第三范式（3NF）**
```
要求：在2NF基础上，消除传递函数依赖

❌ 违反3NF：
┌──────┬──────┬──────────┬──────────┐
│ 学号 │ 专业 │ 专业负责人│ 负责人电话│
├──────┼──────┼──────────┼──────────┤
│ 001  │ 计算机│ 李教授   │   12345  │
└──────┴──────┴──────────┴──────────┘

问题：学号 → 专业 → 专业负责人 → 负责人电话
存在传递依赖

✅ 符合3NF：拆分表，消除传递依赖
```

**🔸 BCNF范式**
```
要求：每个决定因素都是候选键

通俗理解：
如果A → B，那么A必须是候选键
即：能决定别人的，自己必须是主键
```

**🔸 第四范式与连接依赖**
```
第四范式（4NF）：
要求：在BCNF基础上，消除多值依赖

第五范式（5NF）：投影-连接范式
要求：消除连接依赖
```

### 4.4 关系模式分解原则


**🔸 分解的目标**
```
1. 无损连接性：分解后能完全恢复原关系
2. 函数依赖保持：重要的函数依赖不能丢失
3. 既要分解彻底，又要保证信息完整
```

**🔸 分解实例**
```
原关系：学生选课(学号, 姓名, 课程号, 课程名, 成绩)

存在的函数依赖：
学号 → 姓名
课程号 → 课程名
(学号, 课程号) → 成绩

3NF分解：
学生表(学号, 姓名)
课程表(课程号, 课程名)  
选课表(学号, 课程号, 成绩)
```

---

## 5. 🛡️ ACID特性与数据完整性


### 5.1 ACID特性概念


**🔸 什么是ACID？**
ACID是数据库事务必须满足的四个特性，保证数据的**可靠性**：

```
A - Atomicity（原子性）
C - Consistency（一致性）  
I - Isolation（隔离性）
D - Durability（持久性）
```

**🔸 原子性（Atomicity）**
```
含义：事务是最小执行单位，不可分割
要么全部成功，要么全部失败

生活例子：银行转账
张三向李四转账100元：
1. 张三账户 -100元
2. 李四账户 +100元

原子性保证：
✅ 两步都成功 → 转账完成
❌ 任一步失败 → 全部撤销，回到转账前状态
```

**🔸 一致性（Consistency）**
```
含义：事务执行前后，数据库保持一致状态
所有完整性约束都得到满足

例子：转账前后总金额不变
转账前：张三(1000) + 李四(500) = 1500
转账后：张三(900) + 李四(600) = 1500
```

**🔸 隔离性（Isolation）**
```
含义：并发执行的事务之间不互相影响
每个事务感觉像在独占数据库

问题：如果两人同时向同一账户转账
事务1：查询余额1000 → 转入100 → 更新为1100
事务2：查询余额1000 → 转入200 → 更新为1200

隔离性保证：事务按某种顺序串行执行
```

**🔸 持久性（Durability）**
```
含义：事务一旦提交，结果永久保存
即使系统故障也不会丢失

技术实现：
• 写日志文件
• 数据备份
• 故障恢复机制
```

### 5.2 数据完整性约束


**🔸 完整性约束的作用**
保证数据库中的数据是**正确、有效、一致**的：

```
完整性约束类型：
🔑 实体完整性：主键约束
🔗 参照完整性：外键约束  
✅ 域完整性：数据类型和取值范围约束
🎯 用户定义完整性：业务规则约束
```

**🔸 实体完整性**
```
规则：主键不能为空，且唯一

例子：学生表的学号
✅ 正确：学号 = "001", "002", "003"
❌ 错误：学号 = null 或 重复值
```

**🔸 参照完整性**
```
规则：外键必须引用存在的主键值，或为空

例子：选课表引用学生表
学生表：学号为主键
选课表：学号为外键

✅ 正确：选课表中的学号在学生表中存在
❌ 错误：选课表中出现不存在的学号
```

**🔸 关系完整性规则体系**
```
关系完整性的三级体系：
1. 域完整性：字段级别的约束
2. 实体完整性：记录级别的约束  
3. 参照完整性：表间关系的约束
```

---

## 6. 🔧 关系代数与SQL理论基础


### 6.1 关系代数基本操作详解


**🔸 关系代数是什么？**
关系代数是操作关系的**数学运算体系**，是SQL语言的理论基础：

```
关系代数 vs SQL：
关系代数：数学表达式，理论基础
SQL：实际查询语言，工程实现

关系：σ_{年龄>20}(学生表) 
SQL：SELECT * FROM 学生表 WHERE 年龄 > 20;
```

**🔸 基本运算符**

| 运算符 | 名称 | SQL对应 | 作用 |
|--------|------|---------|------|
| **σ** | 选择 | `WHERE` | 选择满足条件的行 |
| **π** | 投影 | `SELECT` | 选择指定的列 |
| **×** | 笛卡尔积 | `CROSS JOIN` | 两表组合 |
| **⋈** | 连接 | `JOIN` | 按条件连接表 |
| **∪** | 并 | `UNION` | 合并两个关系 |
| **∩** | 交 | `INTERSECT` | 两表共同部分 |
| **-** | 差 | `EXCEPT` | 从一表中减去另一表 |

**🔸 运算示例**
```
学生表 R：
┌──────┬──────┬──────┐
│ 学号 │ 姓名 │ 年龄 │
├──────┼──────┼──────┤
│ 001  │ 张三 │  20  │
│ 002  │ 李四 │  19  │
│ 003  │ 王五 │  21  │
└──────┴──────┴──────┘

选择运算：σ_{年龄>19}(R)
结果：
┌──────┬──────┬──────┐
│ 001  │ 张三 │  20  │
│ 003  │ 王五 │  21  │
└──────┴──────┴──────┘

投影运算：π_{姓名,年龄}(R)  
结果：
┌──────┬──────┐
│ 张三 │  20  │
│ 李四 │  19  │
│ 王五 │  21  │
└──────┴──────┘
```

### 6.2 关系运算完备性概念


**🔸 什么是运算完备性？**
```
定义：一个查询语言能表达所有可能的查询

关系代数完备性：
能用关系代数表达的查询，SQL都能实现
SQL比关系代数更强大：
• 聚合函数（COUNT, SUM等）
• 排序（ORDER BY）
• 分组（GROUP BY）
```

### 6.3 数据独立性概念


**🔸 数据独立性是什么？**
数据独立性指**数据结构改变不影响应用程序**：

```
三级模式结构：
外模式（视图）← 用户看到的数据
    ↑
概念模式（逻辑结构）← 数据库整体逻辑结构  
    ↑
内模式（物理结构）← 数据存储方式

数据独立性分类：
🔸 逻辑独立性：概念模式改变，外模式不变
🔸 物理独立性：内模式改变，概念模式不变
```

**🔸 视图与基表关系**
```
基表：真实存储数据的表
视图：虚拟表，基于基表的查询结果

例子：
基表：员工表(工号, 姓名, 部门, 工资)
视图：高薪员工视图 = 工资>10000的员工

优点：
• 数据安全：隐藏敏感信息
• 简化查询：复杂查询封装成视图
• 逻辑独立性：基表结构改变，视图可不变
```

---

## 7. 📜 Codd的12条规则详解


### 7.1 规则背景


**🔸 为什么制定12条规则？**
1970年代，很多厂商声称自己的产品是"关系数据库"，但实际上并不完全符合关系模型。Codd在1985年提出12条规则，作为**真正关系数据库的判断标准**。

### 7.2 核心规则解析


**🔸 规则0：基础规则**
```
系统必须能完全通过关系能力来管理数据库
含义：数据库管理完全基于关系模型，不能混合其他模型
```

**🔸 规则1：信息规则**
```
关系数据库中所有信息都用表中的数据值来表示
含义：数据、元数据都存储在表中，不能用其他方式
```

**🔸 规则2：保证访问规则**
```
每个数据都能通过"表名+主键+列名"唯一访问
含义：任何数据都有确定的访问路径
```

**🔸 规则3：系统化的空值处理**
```
支持空值(null)，且与任何值都不相等
含义：空值有特殊含义，表示"未知"或"不适用"
```

**🔸 规则4：基于关系模型的联机目录**
```
数据库结构信息存储在普通表中，用户可查询
含义：系统表也是关系表，可用SQL查询
```

**🔸 规则5：全面的数据子语言规则**
```
必须支持一种全面的数据语言（如SQL）
含义：能通过一种语言完成所有数据操作
```

**🔸 规则6：视图更新规则**
```
理论上可更新的视图，系统应支持更新
含义：视图不只是查询，还要支持插入、更新、删除
```

**🔸 规则7：高级插入、更新、删除**
```
支持集合级别的插入、更新、删除操作
含义：一条SQL语句能操作多行数据
```

**🔸 规则8：物理数据独立性**
```
应用程序不受数据物理存储方式影响
含义：改变存储方式，应用程序不用修改
```

**🔸 规则9：逻辑数据独立性**
```
应用程序不受逻辑结构变化影响
含义：改变表结构，应用可通过视图保持不变
```

**🔸 规则10：完整性独立性**
```
完整性约束用数据库语言定义，独立于应用程序
含义：约束规则存储在数据库中，不是写在程序里
```

**🔸 规则11：分布独立性**
```
数据分布在多台机器上，用户感觉像在一台机器上
含义：支持分布式数据库
```

**🔸 规则12：非破坏性规则**
```
低级接口不能绕过完整性约束
含义：任何访问方式都要遵守数据库规则
```

---

## 8. 📋 核心要点总结


### 8.1 关系模型核心概念


```
🎯 Edgar F. Codd贡献：
• 1970年提出关系模型理论
• 建立了现代数据库的数学基础
• 获得图灵奖，被誉为"数据库之父"

🔑 关系模型三要素：
• 数据结构：关系（二维表）
• 数据操作：关系代数运算
• 完整性约束：实体、参照、域完整性

🔸 基本概念理解：
• 关系 = 表格：存储同类事物信息
• 元组 = 行：一个具体事物实例  
• 属性 = 列：事物的特征
• 域 = 取值范围：属性可能的值
```

### 8.2 数据库设计理论


```
🔸 函数依赖核心：
• A → B：A的值能唯一确定B的值
• 用于分析表结构是否合理
• 指导范式化设计

🔸 范式化设计目标：
• 消除数据冗余
• 避免更新、插入、删除异常
• 提高数据一致性

🔸 范式递进关系：
1NF（原子性）→ 2NF（消除部分依赖）→ 3NF（消除传递依赖）→ BCNF → 4NF → 5NF
```

### 8.3 ACID事务特性


```
🛡️ 事务ACID特性：
• 原子性：要么全成功，要么全失败
• 一致性：保持数据库约束规则
• 隔离性：并发事务互不干扰
• 持久性：提交后永久保存

🔒 完整性约束体系：
• 实体完整性：主键唯一非空
• 参照完整性：外键引用存在的主键
• 域完整性：数据类型和范围约束
• 用户完整性：业务规则约束
```

### 8.4 关系运算理论


```
🔧 关系代数运算：
• 基本运算：选择σ、投影π、连接⋈等
• SQL基础：每个SQL操作都有对应的关系代数表达
• 运算完备性：能表达所有可能的查询

🔸 数据独立性：
• 物理独立性：存储方式改变不影响逻辑结构
• 逻辑独立性：逻辑结构改变不影响应用程序
• 通过三级模式结构实现
```

### 8.5 实际应用价值


```
🎯 理论指导实践：
• 数据库设计：范式理论指导表结构设计
• 查询优化：关系代数指导SQL优化
• 系统评估：Codd规则评判系统是否为真正关系数据库

💡 学习重点：
• 理解概念本质，不死记硬背定义
• 掌握范式化设计方法
• 理解ACID特性在并发控制中的作用
• 学会用关系代数思维分析SQL查询
```

**核心记忆口诀**：
- 关系模型三要素：结构运算加约束
- ACID保事务：原子一致隔离久  
- 范式消除冗余性：一二三级步步清
- Codd规则十二条：真正关系标准高