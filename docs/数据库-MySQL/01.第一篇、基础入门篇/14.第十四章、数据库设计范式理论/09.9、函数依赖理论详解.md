---
title: 9、函数依赖理论详解
---
## 📚 目录

1. [函数依赖基本概念](#1-函数依赖基本概念)
2. [依赖关系类型分析](#2-依赖关系类型分析)
3. [Armstrong公理系统](#3-Armstrong公理系统)
4. [候选键求解算法](#4-候选键求解算法)
5. [模式分解理论](#5-模式分解理论)
6. [闭包计算与最小依赖集](#6-闭包计算与最小依赖集)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔗 函数依赖基本概念


### 1.1 什么是函数依赖


**🔸 函数依赖定义**

函数依赖其实很简单，就是数据之间的一种"决定关系"。

> **通俗理解**：如果知道了A的值，就能确定B的值，那么我们说"B函数依赖于A"，记作 A → B

**📋 生活化例子理解**

```
学生信息表：
学号    姓名    专业     年级
001    张三    计算机    2021
002    李四    数学     2020
003    王五    计算机    2022

函数依赖关系：
学号 → 姓名  (知道学号，就能确定姓名)
学号 → 专业  (知道学号，就能确定专业)
学号 → 年级  (知道学号，就能确定年级)
```

**⚡ 函数依赖的数学定义**

对于关系R的属性集合，如果存在函数依赖 X → Y，表示：
- **X称为决定因素**：能够决定其他属性值的属性集合
- **Y称为依赖因素**：被决定的属性集合
- **约束条件**：对于R中任意两个元组t1和t2，如果t1[X] = t2[X]，则必有t1[Y] = t2[Y]

> **核心理解**：函数依赖是数据库设计中描述数据约束关系的重要工具，它告诉我们哪些数据之间存在逻辑上的决定关系。

### 1.2 函数依赖的实际意义


**🎯 为什么要研究函数依赖？**

函数依赖理论解决数据库设计中的核心问题：
- **数据冗余**：重复存储相同信息
- **更新异常**：修改一处数据需要改多个地方
- **插入异常**：某些数据无法独立插入
- **删除异常**：删除数据会丢失其他有用信息

```
问题表格示例：
学号   姓名   专业     专业负责人   专业电话
001   张三   计算机   王教授      123456
002   李四   数学     李教授      789012
003   王五   计算机   王教授      123456  ← 冗余信息

问题分析：
• 专业信息重复存储（冗余）
• 修改专业负责人需要改多行（更新异常）
• 无法单独录入专业信息（插入异常）
• 删除学生可能丢失专业信息（删除异常）
```

---

## 2. 🔍 依赖关系类型分析


### 2.1 完全函数依赖与部分函数依赖


**✅ 完全函数依赖**

当X的所有子集都不能决定Y时，Y完全函数依赖于X。

```
课程成绩表示例：
(学号, 课程号) → 成绩

分析：
• 只知道学号，不能确定成绩（学生可能选多门课）
• 只知道课程号，不能确定成绩（一门课有多个学生）
• 必须同时知道学号和课程号，才能确定成绩

结论：成绩完全函数依赖于(学号, 课程号)
```

**⚠️ 部分函数依赖**

当X的某个真子集就能决定Y时，Y部分函数依赖于X。

```
学生选课表问题示例：
(学号, 课程号) → 姓名

分析：
• 只知道学号，就能确定姓名
• 不需要知道课程号
• 姓名只依赖于学号这个子集

结论：姓名部分函数依赖于(学号, 课程号)
这种设计有问题！
```

### 2.2 传递函数依赖


**🔗 传递函数依赖的含义**

如果存在 A → B 和 B → C，且B不依赖于C，则C传递函数依赖于A。

```
学生信息传递依赖示例：

学号 → 专业 → 专业负责人

具体数据：
学号001 → 计算机专业 → 王教授
学号002 → 数学专业   → 李教授

分析：
• 学号能决定专业
• 专业能决定专业负责人  
• 因此：学号能传递决定专业负责人
```

**📊 三种依赖类型对比**

| **依赖类型** | **表示方法** | **特点** | **数据库设计影响** |
|-------------|-------------|---------|-------------------|
| **完全函数依赖** | `X →f Y` | `需要X的全部属性` | `符合规范化要求` |
| **部分函数依赖** | `X →p Y` | `只需X的部分属性` | `可能导致冗余` |
| **传递函数依赖** | `X →t Z` | `通过中间属性传递` | `可能导致异常` |

---

## 3. 📐 Armstrong公理系统


### 3.1 Armstrong公理系统基础


**🎯 什么是Armstrong公理？**

Armstrong公理是推导函数依赖的数学规则，就像数学中的公式一样，可以从已知的函数依赖推导出新的函数依赖。

**📋 三条基本公理**

```
A1 - 自反律（Reflexivity）：
如果 Y ⊆ X，则 X → Y

通俗理解：一个属性集合总是能决定它的子集
例子：(学号, 姓名) → 学号  ✓
```

```
A2 - 增广律（Augmentation）：
如果 X → Y，则 XZ → YZ

通俗理解：在两边同时添加相同属性，依赖关系仍然成立
例子：学号 → 姓名，则 (学号, 专业) → (姓名, 专业)  ✓
```

```
A3 - 传递律（Transitivity）：
如果 X → Y 且 Y → Z，则 X → Z

通俗理解：依赖关系可以传递
例子：学号 → 专业，专业 → 负责人，则 学号 → 负责人  ✓
```

### 3.2 函数依赖推理规则


**🔧 扩展推理规则**

基于三条基本公理，可以推导出更实用的规则：

```
合并规则（Union）：
如果 X → Y 且 X → Z，则 X → YZ

分解规则（Decomposition）：
如果 X → YZ，则 X → Y 且 X → Z

伪传递规则（Pseudo-transitivity）：
如果 X → Y 且 WY → Z，则 WX → Z
```

**💡 推理规则应用示例**

```
已知函数依赖集：
F = {A → B, B → C, A → D}

使用推理规则推导：

步骤1：应用合并规则
A → B 且 A → D  →  A → BD

步骤2：应用传递律
A → B 且 B → C  →  A → C

步骤3：再次应用合并规则
A → BD 且 A → C  →  A → BCD

结论：从A可以推导出B、C、D的所有组合
```

---

## 4. 🔑 候选键求解算法


### 4.1 候选键的概念


**🗝️ 什么是候选键？**

候选键就是能够唯一标识表中每一行数据的最小属性集合：
- **唯一性**：没有两行数据在候选键上的值相同
- **最小性**：去掉候选键中任何一个属性，就失去唯一性

**📊 候选键分类方法**

```
属性在函数依赖中的角色分类：

┌─────────────────────────────────────────────────┐
│               属性分类图谱                       │
├─────────────┬─────────────┬─────────────┬───────┤
│   L类属性    │   R类属性    │   N类属性    │ LR类  │
├─────────────┼─────────────┼─────────────┼───────┤
│• 只出现在    │• 只出现在    │• 不在依赖中  │• 两边 │
│  依赖左边    │  依赖右边    │  出现       │  都有 │
│• 必须在候选键│• 不可能在    │• 必须在候选键│• 可能 │
│  中          │  候选键中    │  中         │  在   │
└─────────────┴─────────────┴─────────────┴───────┘
```

### 4.2 候选键求解算法详解


**🛠️ 算法步骤分解**

```
候选键求解流程：

输入：关系模式R(A1,A2,...,An)，函数依赖集F
输出：所有候选键

Step 1: 属性分类
├─ 统计每个属性在F中的出现情况
├─ L类：只在左边  R类：只在右边  
├─ N类：不出现    LR类：两边都有

Step 2: 初始候选键
├─ 必含属性 = L类 ∪ N类
├─ 如果必含属性的闭包 = R，则它就是候选键

Step 3: 扩展搜索  
├─ 如果必含属性闭包 ≠ R
├─ 逐步添加LR类属性进行组合测试
└─ 保证最小性原则
```

**💻 算法实现示例**

```
关系：R(A,B,C,D,E)
函数依赖：F = {A→B, B→C, CD→E, C→D, E→A}

Step 1: 属性分类
A: 出现在 A→B(左), E→A(右)  → LR类
B: 出现在 A→B(右), B→C(左)  → LR类  
C: 出现在 B→C(右), CD→E(左), C→D(左) → LR类
D: 出现在 CD→E(左), C→D(右) → LR类
E: 出现在 CD→E(右), E→A(左) → LR类

Step 2: 没有L类和N类属性，必含属性 = ∅

Step 3: 从单个属性开始测试
测试A的闭包：
A+ = {A,B,C,D,E} = R  ✓

结论：A是候选键
```

### 4.3 候选键求解实战练习


**🎯 复杂示例求解**

```
关系：R(A,B,C,D,E,F)
函数依赖：F = {A→BC, B→CF, CD→E, DE→F, F→A}

属性分类：
A: A→BC(左), F→A(右)     → LR类
B: A→BC(右), B→CF(左)   → LR类
C: A→BC(右), B→CF(右), CD→E(左) → LR类
D: CD→E(左), DE→F(左)   → L类
E: CD→E(右), DE→F(左)   → LR类
F: B→CF(右), DE→F(右), F→A(左) → LR类

候选键求解：
必含属性 = {D}

计算D的闭包：
D+ = {D} (D不能推导出其他属性)

需要扩展，尝试添加其他属性：
(A,D)+：A→BC, B→CF, F→A, CD→E → {A,B,C,D,E,F} ✓
(B,D)+：B→CF, F→A, A→BC, CD→E → {A,B,C,D,E,F} ✓

最终候选键：{AD}, {BD}
```

---

## 4. 🧮 Armstrong公理系统


### 4.1 公理系统的作用


**📐 为什么需要Armstrong公理？**

Armstrong公理系统就像数学中的推理规则，帮我们：
- **发现隐含依赖**：从已知依赖推导出新的依赖关系
- **验证依赖**：检查某个依赖是否成立
- **简化依赖集**：找到最简形式的依赖集合

**🔧 公理系统的完备性**

Armstrong公理系统具有两个重要性质：
- **有效性**：所有用公理推导的依赖都是正确的
- **完备性**：所有正确的依赖都能用公理推导出来

### 4.2 推理规则详细解析


**📚 基本公理详解**

**自反律应用**：
```
示例：学生表(学号, 姓名, 专业)
自反律告诉我们：
(学号, 姓名, 专业) → 学号      ✓ 显然成立
(学号, 姓名, 专业) → (学号, 姓名) ✓ 显然成立

实际意义：任何属性集合都能决定其子集，这是最基本的逻辑
```

**增广律应用**：
```
已知：学号 → 姓名
增广律推导：
(学号, 专业) → (姓名, 专业)

实际意义：在决定关系两边同时添加相同属性，关系仍然成立
```

**传递律应用**：
```
已知：学号 → 专业，专业 → 负责人
传递律推导：学号 → 负责人

实际意义：依赖关系可以链式传递
```

**🔄 复合推理规则**

```
合并规则示例：
已知：A → B, A → C
推导：A → BC

分解规则示例：
已知：A → BC  
推导：A → B, A → C

实际应用：
学号 → (姓名, 专业)
等价于：
学号 → 姓名, 学号 → 专业
```

---

## 5. 🎯 模式分解理论


### 5.1 为什么需要模式分解


**❓ 什么是模式分解？**

模式分解就是把一个大表拆分成多个小表，目标是：
- **消除冗余**：减少重复数据
- **避免异常**：防止更新、插入、删除异常
- **提高效率**：小表操作更快

**📋 分解示例**

```
原始表：学生选课(学号, 姓名, 课程号, 课程名, 成绩, 学分)

问题分析：
• 学号 → 姓名 (学生信息冗余)
• 课程号 → (课程名, 学分) (课程信息冗余)

分解方案：
表1：学生表(学号, 姓名)
表2：课程表(课程号, 课程名, 学分)  
表3：选课表(学号, 课程号, 成绩)
```

### 5.2 无损连接分解


**🔗 什么是无损连接？**

无损连接分解的意思是：把表拆分后，还能通过连接操作完全恢复原来的信息，不会丢失数据，也不会产生虚假数据。

**✅ 无损连接判定方法**

```
无损连接分解的判定条件：

设关系R分解为R1(X)和R2(Y)，当且仅当：
X ∩ Y → X-Y  或  X ∩ Y → Y-X

通俗理解：
公共属性必须能够决定其中一个分解表的其他属性
```

**💡 无损连接实例**

```
关系：学生课程(学号, 姓名, 课程号, 成绩)
函数依赖：{学号→姓名, (学号,课程号)→成绩}

分解方案：
R1：学生(学号, 姓名)
R2：选课(学号, 课程号, 成绩)

验证无损连接：
公共属性：学号
检查：学号 → 姓名  ✓ (学号能决定R1中的其他属性)

结论：这是无损连接分解
```

### 5.3 依赖保持分解


**🛡️ 什么是依赖保持？**

依赖保持分解的意思是：分解后的小表仍然能够检查原来的所有函数依赖约束，不会丢失数据完整性检查能力。

**📊 依赖保持检查方法**

```
依赖保持验证步骤：

原关系R：{A,B,C,D}
函数依赖F：{A→B, B→C, C→D}
分解为：R1{A,B}, R2{B,C}, R3{C,D}

检查每个依赖是否能在某个分解表中检查：
A→B: 在R1{A,B}中可以检查  ✓
B→C: 在R2{B,C}中可以检查  ✓  
C→D: 在R3{C,D}中可以检查  ✓

结论：这是依赖保持分解
```

### 5.4 模式分解正确性验证


**🎯 分解质量评估标准**

一个好的分解必须同时满足：

| **标准** | **含义** | **检验方法** | **重要性** |
|---------|---------|-------------|-----------|
| **无损连接** | `信息不丢失` | `连接后恢复原表` | `⭐⭐⭐⭐⭐` |
| **依赖保持** | `约束不丢失` | `每个依赖可检查` | `⭐⭐⭐⭐` |
| **消除冗余** | `数据不重复` | `符合范式要求` | `⭐⭐⭐` |

**🔍 分解正确性验证实例**

```
原关系：R(A,B,C,D)
函数依赖：F = {A→B, B→C, A→D}

分解方案1：R1(A,B), R2(A,C,D)
验证：
• 无损连接：A是公共属性，A→B ✓
• 依赖保持：A→B在R1检查，B→C需要跨表 ✗

分解方案2：R1(A,B), R2(B,C), R3(A,D)  
验证：
• 无损连接：需要特殊算法验证
• 依赖保持：所有依赖都能在对应表中检查 ✓

结论：方案2更优
```

---

## 6. ⚗️ 闭包计算与最小依赖集


### 6.1 属性闭包计算算法


**🔍 什么是属性闭包？**

属性闭包就是给定属性集合能够确定的所有属性的集合。

> **生活化理解**：知道了一个人的身份证号，你能推断出哪些其他信息？姓名、出生日期、籍贯等，这些就是身份证号的"闭包"。

**⚡ 闭包计算算法**

```java
// 属性闭包计算伪代码
闭包计算算法(属性集X, 函数依赖集F) {
    闭包 = X;  // 初始化为X本身
    
    do {
        旧闭包 = 闭包;
        for (每个函数依赖 α→β in F) {
            if (α ⊆ 闭包) {
                闭包 = 闭包 ∪ β;
            }
        }
    } while (闭包 != 旧闭包);
    
    return 闭包;
}
```

**💻 实际计算示例**

```
关系：R(A,B,C,D,E)
函数依赖：F = {A→B, B→C, CD→E, C→D}
求：{A,C}的闭包

计算过程：
初始：闭包 = {A,C}

第1轮：
• A→B: A∈{A,C} ✓ → 闭包 = {A,B,C}
• B→C: B∈{A,B,C} ✓ → 闭包 = {A,B,C} (C已存在)
• CD→E: {C,D}⊄{A,B,C} ✗
• C→D: C∈{A,B,C} ✓ → 闭包 = {A,B,C,D}

第2轮：
• CD→E: {C,D}⊆{A,B,C,D} ✓ → 闭包 = {A,B,C,D,E}

第3轮：无新增属性，算法结束

结果：{A,C}+ = {A,B,C,D,E}
```

### 6.2 最小函数依赖集


**🎯 什么是最小函数依赖集？**

最小函数依赖集就是去掉冗余后的依赖集合，特点：
- **右边单属性**：每个依赖右边只有一个属性
- **左边最小**：不能再减少左边的属性
- **无冗余依赖**：每个依赖都不能被其他依赖推导出来

**🔧 最小化算法**

```
最小依赖集求解步骤：

Step 1: 分解右部
将 A→BC 分解为 A→B, A→C

Step 2: 去除左部冗余属性
对每个依赖X→A，检查X的真子集能否推导A

Step 3: 去除冗余依赖  
对每个依赖X→A，检查从其余依赖能否推导出X→A
```

**💡 最小化实例**

```
原依赖集：F = {A→BC, B→C, A→B, AB→C}

Step 1: 分解右部
F1 = {A→B, A→C, B→C, AB→C}

Step 2: 去除左部冗余
检查AB→C：
• A的闭包 = {A,B,C} ⊇ {C} ✓
• AB→C 可简化为 A→C (但A→C已存在)

Step 3: 去除冗余依赖
• A→C: 由A→B, B→C传递得到 → 删除A→C
• AB→C: 可由A→B, B→C推导 → 删除AB→C

最小依赖集：{A→B, B→C}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 函数依赖：数据间的决定关系，A→B表示A能决定B
🔸 依赖类型：完全依赖、部分依赖、传递依赖三种形式
🔸 Armstrong公理：推导函数依赖的数学规则系统
🔸 候选键：能唯一标识元组的最小属性集合
🔸 模式分解：无损连接和依赖保持是分解的基本要求
🔸 属性闭包：给定属性能确定的所有属性集合
🔸 最小依赖集：去除冗余后的最简函数依赖集合
```

### 7.2 关键理解要点


**🔹 函数依赖的本质**
```
数据约束的形式化表达：
• 反映现实世界的逻辑关系
• 为数据库规范化提供理论基础
• 指导表结构设计和优化
```

**🔹 候选键求解的核心思路**
```
属性分类 → 确定必含属性 → 闭包计算 → 最小性检查
重点掌握属性分类方法和闭包计算过程
```

**🔹 分解理论的实用价值**
```
设计指导：
• 无损连接保证信息完整性
• 依赖保持保证约束完整性  
• 两者缺一不可
```

### 7.3 理论实践应用指导


**💼 数据库设计应用**

**阶段1：需求分析**
- 识别实体和属性
- 确定属性间的函数依赖关系
- 画出初始的ER图

**阶段2：函数依赖分析**
- 列出所有函数依赖
- 计算候选键
- 检查当前设计的范式级别

**阶段3：规范化分解**
- 根据范式要求进行分解
- 验证分解的无损连接性
- 验证分解的依赖保持性

**🛠️ 实际项目应用步骤**

```
项目实战应用流程：

业务调研 → 依赖分析 → 键值设计 → 分解优化 → 验证测试
    ↓         ↓         ↓         ↓         ↓
收集业务规则  列出依赖关系  确定主键外键  表结构设计  完整性检查
```

### 7.4 学习要点检查清单


**📝 自测检查点**

- [ ] **能准确识别函数依赖关系**
- [ ] **会使用Armstrong公理进行推理**
- [ ] **掌握候选键求解算法**
- [ ] **理解无损连接分解的判定**
- [ ] **掌握依赖保持的验证方法**
- [ ] **会计算属性闭包**
- [ ] **能求解最小函数依赖集**

**🎯 实践应用能力**

- [ ] **能分析现有表结构的问题**
- [ ] **会设计符合范式的表结构**
- [ ] **能验证分解方案的正确性**
- [ ] **掌握理论与实际的对应关系**

### 7.5 常见误区与注意事项


**⚠️ 学习中的常见误区**

```
误区1：混淆函数依赖方向
错误理解：A→B 等同于 B→A
正确理解：依赖有方向性，A决定B不代表B决定A

误区2：候选键理解错误  
错误理解：候选键就是主键
正确理解：候选键可能有多个，主键是选定的一个候选键

误区3：分解盲目进行
错误做法：只关注消除冗余，忽略无损连接
正确做法：必须同时保证无损连接和依赖保持
```

**💡 学习建议**

```
理论联系实际：
• 每学一个概念，都要想实际的数据表例子
• 多做手工计算练习，掌握算法思路
• 理解理论的实用价值，不要死记硬背
```

**核心记忆口诀**：
```
函数依赖描述数据间决定关系
Armstrong公理推导依赖传递规律
候选键求解分类闭包算法
模式分解无损保持双重标准
理论指导实践设计规范数据库
```