---
title: 17、表的存在性检查语法
---
## 📚 目录

1. [存在性检查基础概念](#1-存在性检查基础概念)
2. [IF EXISTS条件语法详解](#2-IF-EXISTS条件语法详解)
3. [IF NOT EXISTS创建语法](#3-IF-NOT-EXISTS创建语法)
4. [表存在性查询方法](#4-表存在性查询方法)
5. [条件DDL语句应用](#5-条件DDL语句应用)
6. [脚本容错性设计](#6-脚本容错性设计)
7. [实际应用场景](#7-实际应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 存在性检查基础概念


### 1.1 什么是表存在性检查


**🔸 基本概念理解**
```
存在性检查就是在执行DDL操作前，先确认表是否存在

为什么需要存在性检查：
• 避免重复创建表导致的错误
• 避免删除不存在的表导致的错误
• 让SQL脚本可以重复执行
• 提高脚本的健壮性和容错能力

简单类比：
就像进房间前先敲门确认是否有人一样
对表进行操作前先确认表是否存在
```

### 1.2 存在性检查的应用场景


**🚀 实际开发中的需求**
```
数据库初始化脚本：
• 项目部署时自动创建所需表结构
• 多次执行不会报错

数据库迁移脚本：
• 版本升级时安全地添加新表
• 避免在已有表的环境中报错

开发调试：
• 开发过程中频繁重建表结构
• 不用手动检查表是否存在

生产环境维护：
• 安全地执行结构变更
• 降低操作风险
```

### 1.3 不使用存在性检查的问题


**❌ 直接执行DDL的问题**
```sql
-- 问题示例：重复创建表
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50)
);
-- 第二次执行会报错：Table 'users' already exists

-- 问题示例：删除不存在的表  
DROP TABLE non_existent_table;
-- 报错：Unknown table 'non_existent_table'
```

**💡 解决思路**
```
传统解决方式：
1. 手动查询表是否存在
2. 根据查询结果决定是否执行DDL
3. 需要写很多判断逻辑

MySQL提供的解决方式：
1. 使用IF EXISTS语法
2. 使用IF NOT EXISTS语法
3. 一条语句解决问题
```

---

## 2. 🔧 IF EXISTS条件语法详解


### 2.1 DROP TABLE IF EXISTS语法


**🔸 基本语法结构**
```sql
DROP TABLE [IF EXISTS] table_name [, table_name] ...

语法说明：
• IF EXISTS：可选关键字，表示条件删除
• table_name：要删除的表名，可以是多个表
• 如果表存在就删除，不存在也不报错
```

**💡 使用示例对比**
```sql
-- 传统方式（不推荐）
DROP TABLE users;  
-- 如果表不存在会报错：Table 'users' doesn't exist

-- 条件删除方式（推荐）
DROP TABLE IF EXISTS users;
-- 表存在就删除，不存在也不报错，静默成功
```

### 2.2 多表条件删除


**🔧 批量删除多个表**
```sql
-- 同时删除多个表（如果存在的话）
DROP TABLE IF EXISTS 
    users,
    user_profiles, 
    user_logs,
    user_sessions;

-- 等价于逐个删除
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS user_profiles;
DROP TABLE IF EXISTS user_logs;
DROP TABLE IF EXISTS user_sessions;
```

### 2.3 IF EXISTS的执行逻辑


**🔍 执行流程解析**
```
IF EXISTS执行流程：
    ↓
1. 检查表是否存在
    ↓
表存在？
├─ 是 → 执行删除操作 → 返回成功
└─ 否 → 跳过删除操作 → 返回成功（不报错）

关键理解：
• IF EXISTS让不存在的表删除变成"成功"而不是"错误"
• 这样可以让脚本具有幂等性（多次执行结果相同）
```

**📝 执行结果示例**
```sql
-- 表存在时的执行结果
mysql> DROP TABLE IF EXISTS users;
Query OK, 0 rows affected (0.01 sec)
-- 显示"0 rows affected"表示表被删除

-- 表不存在时的执行结果  
mysql> DROP TABLE IF EXISTS non_existent_table;
Query OK, 0 rows affected, 1 warning (0.00 sec)
-- 有warning但不是error，脚本继续执行

-- 查看warning内容
mysql> SHOW WARNINGS;
+-------+------+----------------------------------------+
| Level | Code | Message                                |
+-------+------+----------------------------------------+
| Note  | 1051 | Unknown table 'test.non_existent_table'|
+-------+------+----------------------------------------+
```

### 2.4 其他支持IF EXISTS的DDL语句


**🔧 扩展应用**
```sql
-- 删除数据库
DROP DATABASE IF EXISTS test_db;

-- 删除视图
DROP VIEW IF EXISTS user_summary_view;

-- 删除存储过程
DROP PROCEDURE IF EXISTS calculate_user_score;

-- 删除函数
DROP FUNCTION IF EXISTS get_user_level;

-- 删除触发器
DROP TRIGGER IF EXISTS user_update_trigger;

-- 删除索引
DROP INDEX IF EXISTS idx_username ON users;
```

---

## 3. ✨ IF NOT EXISTS创建语法


### 3.1 CREATE TABLE IF NOT EXISTS语法


**🔸 基本语法结构**
```sql
CREATE TABLE [IF NOT EXISTS] table_name (
    column_definition,
    ...
    [table_options]
)

语法说明：
• IF NOT EXISTS：可选关键字，表示条件创建
• 如果表不存在就创建，存在则跳过
• 不会覆盖已存在的表结构
```

**💡 使用示例对比**
```sql
-- 传统方式（不推荐）
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- 如果表已存在会报错：Table 'users' already exists

-- 条件创建方式（推荐）
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- 表不存在就创建，存在则跳过，不报错
```

### 3.2 IF NOT EXISTS的执行逻辑


**🔍 执行流程解析**
```
IF NOT EXISTS执行流程：
    ↓
1. 检查表是否存在
    ↓
表存在？
├─ 是 → 跳过创建操作 → 返回成功（有warning）
└─ 否 → 执行创建操作 → 返回成功

重要理解：
• IF NOT EXISTS不会检查表结构是否一致
• 如果表已存在，即使结构不同也不会报错
• 只是简单跳过，不做任何修改
```

**📝 执行结果示例**
```sql
-- 首次创建表
mysql> CREATE TABLE IF NOT EXISTS users (
    ->     id INT PRIMARY KEY,
    ->     username VARCHAR(50)
    -> );
Query OK, 0 rows affected (0.02 sec)
-- 表被成功创建

-- 再次执行相同语句
mysql> CREATE TABLE IF NOT EXISTS users (
    ->     id INT PRIMARY KEY,
    ->     username VARCHAR(50)  
    -> );
Query OK, 0 rows affected, 1 warning (0.00 sec)
-- 有warning但不报错

-- 查看warning
mysql> SHOW WARNINGS;
+-------+------+---------------------------+
| Level | Code | Message                   |
+-------+------+---------------------------+
| Note  | 1050 | Table 'users' already exists |
+-------+------+---------------------------+
```

### 3.3 结构不一致的处理


**⚠️ 重要注意事项**
```sql
-- 已存在的表结构
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50)
);

-- 尝试用不同结构创建
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),  -- 新增字段
    age INT             -- 新增字段
);

结果：
• 不会报错，但也不会添加新字段
• 表结构保持原样不变
• 如果需要修改结构，要用ALTER TABLE
```

**🔧 正确的表结构更新方式**
```sql
-- 先创建基础表
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY,
    username VARCHAR(50)
);

-- 然后逐步添加字段
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS email VARCHAR(100);

ALTER TABLE users 
ADD COLUMN IF NOT EXISTS age INT;
```

### 3.4 其他支持IF NOT EXISTS的DDL语句


**🔧 扩展应用**
```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS myapp_db 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_username 
ON users(username);

-- 创建唯一索引
CREATE UNIQUE INDEX IF NOT EXISTS uk_email 
ON users(email);

-- 注意：以下DDL不支持IF NOT EXISTS
-- CREATE VIEW IF NOT EXISTS ...        ❌ 不支持
-- CREATE PROCEDURE IF NOT EXISTS ...   ❌ 不支持
-- CREATE FUNCTION IF NOT EXISTS ...    ❌ 不支持
```

---

## 4. 🔍 表存在性查询方法


### 4.1 information_schema查询法


**🔸 使用系统表查询**
```sql
-- 查询特定表是否存在
SELECT COUNT(*) as table_exists
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'myapp_db'   -- 数据库名
  AND TABLE_NAME = 'users';       -- 表名

-- 结果解读：
-- 1：表存在
-- 0：表不存在
```

**📊 实用查询示例**
```sql
-- 1. 检查当前数据库的表
SELECT TABLE_NAME as '表名'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE()
  AND TABLE_NAME = 'users';

-- 2. 检查多个表是否存在
SELECT 
    'users' as table_name,
    COUNT(*) as exists_flag
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'users'

UNION ALL

SELECT 
    'products' as table_name,
    COUNT(*) as exists_flag
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'products';

-- 3. 列出所有表及其基本信息
SELECT 
    TABLE_NAME as '表名',
    ENGINE as '存储引擎',
    TABLE_ROWS as '行数',
    ROUND(DATA_LENGTH/1024/1024, 2) as '数据大小(MB)'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE()
ORDER BY TABLE_NAME;
```

### 4.2 SHOW TABLES查询法


**🔧 使用SHOW语句**
```sql
-- 1. 显示所有表
SHOW TABLES;

-- 2. 模糊匹配表名
SHOW TABLES LIKE 'user%';

-- 3. 使用WHERE子句过滤
SHOW TABLES WHERE Tables_in_myapp_db = 'users';

-- 4. 获取表的详细信息
SHOW TABLE STATUS LIKE 'users';
```

**📋 SHOW TABLES结果处理**
```sql
-- 在存储过程中判断表是否存在
DELIMITER //
CREATE PROCEDURE CheckTableExists(IN db_name VARCHAR(64), IN table_name VARCHAR(64))
BEGIN
    DECLARE table_count INT DEFAULT 0;
    
    SELECT COUNT(*) INTO table_count
    FROM information_schema.TABLES 
    WHERE TABLE_SCHEMA = db_name 
      AND TABLE_NAME = table_name;
    
    IF table_count > 0 THEN
        SELECT CONCAT('表 ', table_name, ' 存在') as result;
    ELSE
        SELECT CONCAT('表 ', table_name, ' 不存在') as result;
    END IF;
END//
DELIMITER ;

-- 调用存储过程
CALL CheckTableExists('myapp_db', 'users');
```

### 4.3 应用程序中的存在性检查


**💻 不同语言的实现方式**

**Java示例**
```java
public class TableExistenceChecker {
    private DataSource dataSource;
    
    // 检查表是否存在
    public boolean tableExists(String tableName) {
        String sql = "SELECT COUNT(*) FROM information_schema.TABLES " +
                    "WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, getDatabaseName(conn));
            stmt.setString(2, tableName);
            
            try (ResultSet rs = stmt.executeQuery()) {
                return rs.next() && rs.getInt(1) > 0;
            }
        } catch (SQLException e) {
            log.error("检查表存在性失败", e);
            return false;
        }
    }
    
    // 安全创建表
    public void createTableSafely(String tableName, String createSql) {
        if (!tableExists(tableName)) {
            executeSQL(createSql);
            log.info("表 {} 创建成功", tableName);
        } else {
            log.info("表 {} 已存在，跳过创建", tableName);
        }
    }
}
```

**Python示例**
```python
import mysql.connector
from mysql.connector import Error

class TableExistenceChecker:
    def __init__(self, connection_config):
        self.config = connection_config
    
    def table_exists(self, table_name):
        """检查表是否存在"""
        try:
            connection = mysql.connector.connect(**self.config)
            cursor = connection.cursor()
            
            query = """
                SELECT COUNT(*) 
                FROM information_schema.TABLES 
                WHERE TABLE_SCHEMA = %s 
                  AND TABLE_NAME = %s
            """
            
            cursor.execute(query, (self.config['database'], table_name))
            result = cursor.fetchone()
            
            return result[0] > 0
            
        except Error as e:
            print(f"检查表存在性错误: {e}")
            return False
        finally:
            if connection.is_connected():
                cursor.close()
                connection.close()
    
    def create_table_safely(self, table_name, create_sql):
        """安全创建表"""
        if not self.table_exists(table_name):
            self.execute_sql(create_sql)
            print(f"表 {table_name} 创建成功")
        else:
            print(f"表 {table_name} 已存在，跳过创建")
```

---

## 3. 🛠️ IF NOT EXISTS创建语法


### 3.1 创建表的条件语法


**🔸 完整语法示例**
```sql
-- 基础表创建
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100),
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 带存储引擎和字符集
CREATE TABLE IF NOT EXISTS products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock INT DEFAULT 0,
    category_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_category (category_id),
    INDEX idx_name (name)
) ENGINE=InnoDB 
  DEFAULT CHARSET=utf8mb4 
  COLLATE=utf8mb4_unicode_ci;
```

### 3.2 创建数据库的条件语法


**🔧 数据库级别的条件创建**
```sql
-- 创建数据库（如果不存在）
CREATE DATABASE IF NOT EXISTS myapp_db
CHARACTER SET utf8mb4
COLLATE utf8mb4_unicode_ci;

-- 使用数据库
USE myapp_db;

-- 创建完整的项目数据库结构
CREATE DATABASE IF NOT EXISTS ecommerce_db
CHARACTER SET utf8mb4
COLLATE utf8mb4_unicode_ci;

USE ecommerce_db;

-- 用户表
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 商品表
CREATE TABLE IF NOT EXISTS products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    stock INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 订单表
CREATE TABLE IF NOT EXISTS orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'delivered') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 3.3 索引的条件创建


**🔧 索引条件创建语法**
```sql
-- MySQL 8.0.13及以后版本支持
CREATE INDEX IF NOT EXISTS idx_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_created_at ON users(created_at);

-- 复合索引
CREATE INDEX IF NOT EXISTS idx_user_created 
ON users(user_id, created_at);

-- 唯一索引
CREATE UNIQUE INDEX IF NOT EXISTS uk_email 
ON users(email);

-- 函数索引（MySQL 8.0支持）
CREATE INDEX IF NOT EXISTS idx_username_lower 
ON users((LOWER(username)));
```

**⚠️ 版本兼容性注意**
```sql
-- MySQL 8.0.13之前版本不支持索引的IF NOT EXISTS
-- 需要先查询再创建

-- 兼容性写法
SELECT COUNT(*) INTO @index_exists
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = DATABASE() 
  AND TABLE_NAME = 'users' 
  AND INDEX_NAME = 'idx_username';

-- 使用动态SQL（在存储过程中）
IF @index_exists = 0 THEN
    SET @sql = 'CREATE INDEX idx_username ON users(username)';
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END IF;
```

---

## 4. 📊 表存在性查询方法


### 4.1 information_schema详细查询


**🔍 系统表详解**
```sql
-- information_schema.TABLES表结构说明
DESC information_schema.TABLES;

-- 常用字段含义：
-- TABLE_SCHEMA：数据库名
-- TABLE_NAME：表名  
-- ENGINE：存储引擎
-- TABLE_ROWS：表行数（估计值）
-- DATA_LENGTH：数据文件大小
-- CREATE_TIME：创建时间
-- UPDATE_TIME：最后更新时间
```

**📋 实用查询模板**
```sql
-- 1. 精确匹配查询
SELECT 
    TABLE_NAME as '表名',
    ENGINE as '存储引擎',
    TABLE_ROWS as '行数',
    ROUND(DATA_LENGTH/1024/1024, 2) as '数据大小(MB)',
    CREATE_TIME as '创建时间'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'myapp_db'
  AND TABLE_NAME = 'users';

-- 2. 模糊匹配查询
SELECT TABLE_NAME as '匹配的表'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE()
  AND TABLE_NAME LIKE 'user%';

-- 3. 批量检查多个表
SELECT 
    table_check.table_name as '表名',
    CASE 
        WHEN t.TABLE_NAME IS NOT NULL THEN '存在'
        ELSE '不存在'
    END as '状态'
FROM (
    SELECT 'users' as table_name
    UNION SELECT 'products'
    UNION SELECT 'orders'
    UNION SELECT 'non_existent_table'
) table_check
LEFT JOIN information_schema.TABLES t 
  ON t.TABLE_SCHEMA = DATABASE() 
  AND t.TABLE_NAME = table_check.table_name;
```

### 4.2 SHOW语句查询法


**🔧 SHOW语句的灵活应用**
```sql
-- 1. 基础表列表
SHOW TABLES;

-- 2. 带状态信息的表列表
SHOW TABLE STATUS;

-- 3. 条件过滤
SHOW TABLES WHERE Tables_in_myapp_db LIKE 'user%';

-- 4. 获取建表语句
SHOW CREATE TABLE users;

-- 5. 在脚本中使用SHOW结果
SELECT 
    TABLE_NAME,
    ENGINE,
    TABLE_ROWS
FROM (SHOW TABLE STATUS) ts
WHERE TABLE_NAME = 'users';
```

### 4.3 编程语言中的查询封装


**🔧 实用工具类设计**
```java
public class MySQLTableManager {
    private JdbcTemplate jdbcTemplate;
    
    // 检查表是否存在
    public boolean tableExists(String tableName) {
        String sql = """
            SELECT COUNT(*) 
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = DATABASE() 
              AND TABLE_NAME = ?
        """;
        
        Integer count = jdbcTemplate.queryForObject(sql, Integer.class, tableName);
        return count != null && count > 0;
    }
    
    // 检查多个表是否存在
    public Map<String, Boolean> tablesExist(List<String> tableNames) {
        String sql = """
            SELECT TABLE_NAME
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = DATABASE() 
              AND TABLE_NAME IN (%s)
        """.formatted(
            tableNames.stream()
                .map(name -> "?")
                .collect(joining(","))
        );
        
        List<String> existingTables = jdbcTemplate.queryForList(sql, String.class, 
            tableNames.toArray());
        
        return tableNames.stream()
            .collect(toMap(
                name -> name,
                existingTables::contains
            ));
    }
    
    // 获取表的创建语句
    public String getCreateTableSQL(String tableName) {
        if (!tableExists(tableName)) {
            throw new IllegalArgumentException("表 " + tableName + " 不存在");
        }
        
        String sql = "SHOW CREATE TABLE " + tableName;
        return jdbcTemplate.queryForMap(sql).get("Create Table").toString();
    }
    
    // 安全删除表
    public void dropTableSafely(String tableName) {
        String sql = "DROP TABLE IF EXISTS " + tableName;
        jdbcTemplate.execute(sql);
        log.info("表 {} 删除完成", tableName);
    }
    
    // 安全创建表  
    public void createTableSafely(String tableName, String createSQL) {
        // 确保SQL中包含IF NOT EXISTS
        if (!createSQL.toUpperCase().contains("IF NOT EXISTS")) {
            createSQL = createSQL.replaceFirst(
                "(?i)CREATE\\s+TABLE\\s+", 
                "CREATE TABLE IF NOT EXISTS "
            );
        }
        
        jdbcTemplate.execute(createSQL);
        log.info("表 {} 创建检查完成", tableName);
    }
}
```

---

## 5. ⚡ 条件DDL语句应用


### 5.1 数据库初始化脚本


**🔧 完整初始化脚本模板**
```sql
-- database_init.sql
-- 电商系统数据库初始化脚本

-- 1. 创建数据库
CREATE DATABASE IF NOT EXISTS ecommerce_db
CHARACTER SET utf8mb4
COLLATE utf8mb4_unicode_ci;

USE ecommerce_db;

-- 2. 删除已存在的表（如果需要重建）
-- 注意：删除顺序很重要，先删除有外键的表
DROP TABLE IF EXISTS order_items;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories;
DROP TABLE IF EXISTS users;

-- 3. 创建基础表

-- 用户表
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '邮箱',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    phone VARCHAR(20) COMMENT '手机号',
    status ENUM('active', 'inactive', 'banned') DEFAULT 'active' COMMENT '用户状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_email (email),
    INDEX idx_phone (phone),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB COMMENT='用户表';

-- 商品分类表
CREATE TABLE IF NOT EXISTS categories (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL COMMENT '分类名称',
    parent_id INT DEFAULT NULL COMMENT '父分类ID',
    sort_order INT DEFAULT 0 COMMENT '排序',
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_parent_id (parent_id),
    INDEX idx_sort_order (sort_order),
    FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE SET NULL
) ENGINE=InnoDB COMMENT='商品分类表';

-- 商品表
CREATE TABLE IF NOT EXISTS products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL COMMENT '商品名称',
    description TEXT COMMENT '商品描述',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    stock INT DEFAULT 0 COMMENT '库存',
    category_id INT COMMENT '分类ID',
    sku VARCHAR(100) UNIQUE COMMENT '商品编码',
    status ENUM('active', 'inactive', 'deleted') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_category_id (category_id),
    INDEX idx_sku (sku),
    INDEX idx_price (price),
    INDEX idx_stock (stock),
    INDEX idx_status (status),
    FULLTEXT idx_name_desc (name, description),
    
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE SET NULL
) ENGINE=InnoDB COMMENT='商品表';

-- 4. 插入初始数据（如果表为空）
INSERT IGNORE INTO categories (name, parent_id, sort_order) VALUES
('电子产品', NULL, 1),
('服装', NULL, 2),
('图书', NULL, 3),
('手机', 1, 1),
('电脑', 1, 2),
('男装', 2, 1),
('女装', 2, 2);

-- 5. 创建初始管理员用户
INSERT IGNORE INTO users (username, email, password_hash, status) VALUES
('admin', 'admin@example.com', SHA2('admin123', 256), 'active');

-- 6. 验证脚本执行结果
SELECT '数据库初始化完成' as message;
SELECT 
    TABLE_NAME as '已创建的表',
    TABLE_ROWS as '记录数'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE()
ORDER BY TABLE_NAME;
```

### 5.2 数据库版本升级脚本


**🔄 版本迁移脚本示例**
```sql
-- migration_v1_to_v2.sql
-- 数据库从版本1.0升级到2.0

USE ecommerce_db;

-- 检查当前版本
CREATE TABLE IF NOT EXISTS db_version (
    version VARCHAR(10) PRIMARY KEY,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 检查是否已经升级过
SELECT @current_version := COUNT(*) 
FROM db_version 
WHERE version = '2.0';

-- 只有未升级的情况下才执行
-- （这里用条件逻辑，实际中可能需要存储过程）

-- 1. 添加新表
CREATE TABLE IF NOT EXISTS user_profiles (
    user_id INT PRIMARY KEY,
    real_name VARCHAR(100),
    avatar_url VARCHAR(255),
    bio TEXT,
    birthday DATE,
    gender ENUM('male', 'female', 'other'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='用户资料表';

-- 2. 为现有表添加新字段
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(255) COMMENT '头像URL';

ALTER TABLE products 
ADD COLUMN IF NOT EXISTS weight DECIMAL(8,3) COMMENT '重量(kg)';

ALTER TABLE products 
ADD COLUMN IF NOT EXISTS dimensions VARCHAR(50) COMMENT '尺寸';

-- 3. 创建新索引
CREATE INDEX IF NOT EXISTS idx_users_avatar ON users(avatar_url);
CREATE INDEX IF NOT EXISTS idx_products_weight ON products(weight);

-- 4. 创建购物车表
CREATE TABLE IF NOT EXISTS shopping_cart (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT DEFAULT 1,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_product (user_id, product_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='购物车表';

-- 5. 记录升级版本
INSERT IGNORE INTO db_version (version) VALUES ('2.0');

-- 6. 升级完成验证
SELECT '数据库升级到v2.0完成' as message;
```

### 5.3 开发环境重置脚本


**🔄 开发环境快速重置**
```sql
-- dev_reset.sql
-- 开发环境数据重置脚本

USE ecommerce_db;

-- 1. 清空所有数据（保留表结构）
SET FOREIGN_KEY_CHECKS = 0;  -- 临时禁用外键检查

TRUNCATE TABLE order_items;
TRUNCATE TABLE orders;
TRUNCATE TABLE shopping_cart;
TRUNCATE TABLE user_profiles;
TRUNCATE TABLE products;
TRUNCATE TABLE categories;
TRUNCATE TABLE users;

SET FOREIGN_KEY_CHECKS = 1;  -- 重新启用外键检查

-- 2. 插入测试数据
INSERT INTO users (username, email, password_hash, status) VALUES
('testuser1', 'test1@example.com', SHA2('password123', 256), 'active'),
('testuser2', 'test2@example.com', SHA2('password123', 256), 'active'),
('admin', 'admin@example.com', SHA2('admin123', 256), 'active');

INSERT INTO categories (name, parent_id, sort_order) VALUES
('电子产品', NULL, 1),
('服装', NULL, 2),
('手机', 1, 1),
('电脑', 1, 2);

INSERT INTO products (name, description, price, stock, category_id, sku) VALUES
('iPhone 15', '苹果最新手机', 6999.00, 100, 3, 'IP15-001'),
('MacBook Pro', '苹果笔记本电脑', 12999.00, 50, 4, 'MBP-001'),
('小米14', '小米旗舰手机', 3999.00, 200, 3, 'MI14-001');

-- 3. 验证重置结果
SELECT 
    TABLE_NAME as '表名',
    TABLE_ROWS as '记录数'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE()
  AND TABLE_TYPE = 'BASE TABLE'
ORDER BY TABLE_NAME;

SELECT '开发环境重置完成，测试数据已插入' as message;
```

---

## 6. 🛡️ 脚本容错性设计


### 6.1 健壮SQL脚本的设计原则


**⭐ 容错性设计要点**
```
1. 幂等性：脚本可以重复执行
2. 原子性：要么全部成功，要么全部失败
3. 可回滚：出错时能够回到初始状态
4. 有日志：记录执行过程和结果
5. 有验证：执行后验证结果是否正确
```

**🔧 完整的容错脚本模板**
```sql
-- robust_migration.sql
-- 健壮的数据库迁移脚本模板

-- ==========================================
-- 脚本基本信息
-- ==========================================
/*
脚本名称：用户系统表结构初始化
版本：v1.0
作者：开发团队
创建时间：2025-09-01
用途：创建用户相关的所有表结构
*/

-- ==========================================
-- 执行前检查
-- ==========================================

-- 检查MySQL版本
SELECT 
    $$version as mysql_version,
    CASE 
        WHEN $$version >= '8.0' THEN '版本支持'
        ELSE '版本过低，请升级到8.0+'
    END as version_check;

-- 检查字符集支持
SELECT 
    CHARACTER_SET_NAME 
FROM information_schema.CHARACTER_SETS 
WHERE CHARACTER_SET_NAME = 'utf8mb4';

-- ==========================================
-- 开始事务
-- ==========================================
START TRANSACTION;

-- 创建执行日志表
CREATE TABLE IF NOT EXISTS migration_log (
    id INT PRIMARY KEY AUTO_INCREMENT,
    script_name VARCHAR(100) NOT NULL,
    operation VARCHAR(500) NOT NULL,
    status ENUM('started', 'success', 'failed') NOT NULL,
    error_message TEXT,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 记录脚本开始执行
INSERT INTO migration_log (script_name, operation, status) 
VALUES ('user_system_init.sql', 'Script execution started', 'started');

-- ==========================================
-- 主要DDL操作
-- ==========================================

-- 用户表
CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    status ENUM('active', 'inactive', 'banned') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (status)
) ENGINE=InnoDB 
  DEFAULT CHARSET=utf8mb4 
  COLLATE=utf8mb4_unicode_ci 
  COMMENT='用户基础信息表';

-- 记录用户表创建
INSERT INTO migration_log (script_name, operation, status) 
VALUES ('user_system_init.sql', 'CREATE TABLE users', 'success');

-- 用户资料表
CREATE TABLE IF NOT EXISTS user_profiles (
    user_id INT PRIMARY KEY,
    real_name VARCHAR(100),
    phone VARCHAR(20),
    address TEXT,
    birthday DATE,
    gender ENUM('male', 'female', 'other'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_phone (phone),
    INDEX idx_real_name (real_name),
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB 
  DEFAULT CHARSET=utf8mb4 
  COLLATE=utf8mb4_unicode_ci 
  COMMENT='用户详细资料表';

-- 记录用户资料表创建
INSERT INTO migration_log (script_name, operation, status) 
VALUES ('user_system_init.sql', 'CREATE TABLE user_profiles', 'success');

-- ==========================================
-- 执行后验证
-- ==========================================

-- 验证表是否创建成功
SELECT 
    'users' as table_name,
    CASE 
        WHEN COUNT(*) > 0 THEN '✓ 创建成功'
        ELSE '✗ 创建失败'
    END as status
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'users'

UNION ALL

SELECT 
    'user_profiles' as table_name,
    CASE 
        WHEN COUNT(*) > 0 THEN '✓ 创建成功'
        ELSE '✗ 创建失败'
    END as status
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'user_profiles';

-- 验证外键关系
SELECT 
    CONSTRAINT_NAME as '约束名',
    TABLE_NAME as '表名',
    REFERENCED_TABLE_NAME as '引用表',
    CONSTRAINT_TYPE as '约束类型'
FROM information_schema.TABLE_CONSTRAINTS 
WHERE TABLE_SCHEMA = DATABASE() 
  AND CONSTRAINT_TYPE = 'FOREIGN KEY';

-- ==========================================
-- 提交事务
-- ==========================================

-- 记录脚本执行完成
INSERT INTO migration_log (script_name, operation, status) 
VALUES ('user_system_init.sql', 'Script execution completed', 'success');

COMMIT;

-- 显示执行结果
SELECT '用户系统表结构初始化完成！' as result;
SELECT 
    operation as '执行操作',
    status as '状态',
    executed_at as '执行时间'
FROM migration_log 
WHERE script_name = 'user_system_init.sql'
ORDER BY executed_at DESC;
```

### 6.2 错误处理和回滚机制


**🛡️ 异常处理模板**
```sql
-- error_handling_template.sql
-- 带错误处理的SQL脚本模板

DELIMITER //

CREATE PROCEDURE SafeMigration()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 发生错误时的处理
        ROLLBACK;
        
        -- 记录错误信息
        INSERT INTO migration_log (script_name, operation, status, error_message) 
        VALUES ('safe_migration', 'ERROR OCCURRED', 'failed', 
               CONCAT('Error at: ', NOW(), ' State: ', $$error_count));
        
        -- 输出错误信息
        SELECT 'Migration failed! Transaction rolled back.' as error_message;
        
        RESIGNAL;  -- 重新抛出异常
    END;
    
    -- 开始事务
    START TRANSACTION;
    
    -- 记录开始
    INSERT INTO migration_log (script_name, operation, status) 
    VALUES ('safe_migration', 'Migration started', 'started');
    
    -- 执行DDL操作
    CREATE TABLE IF NOT EXISTS test_table (
        id INT PRIMARY KEY,
        name VARCHAR(50) NOT NULL
    );
    
    -- 这里可能有其他DDL操作...
    
    -- 验证操作结果
    IF (SELECT COUNT(*) FROM information_schema.TABLES 
        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'test_table') = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Table creation failed';
    END IF;
    
    -- 记录成功
    INSERT INTO migration_log (script_name, operation, status) 
    VALUES ('safe_migration', 'Migration completed', 'success');
    
    -- 提交事务
    COMMIT;
    
    SELECT 'Migration completed successfully!' as success_message;
END//

DELIMITER ;

-- 执行迁移
CALL SafeMigration();

-- 清理存储过程
DROP PROCEDURE SafeMigration;
```

### 6.3 脚本编写基础技巧


**📋 实用脚本技巧集合**

**🔧 条件执行技巧**
```sql
-- 1. 基于表是否存在的条件执行
SET @table_exists = (
    SELECT COUNT(*) 
    FROM information_schema.TABLES 
    WHERE TABLE_SCHEMA = DATABASE() 
      AND TABLE_NAME = 'users'
);

-- 动态SQL执行
SET @sql = CASE 
    WHEN @table_exists = 0 THEN 
        'CREATE TABLE users (id INT PRIMARY KEY, username VARCHAR(50))'
    ELSE 
        'SELECT "Table users already exists" as message'
END;

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- 2. 基于字段是否存在的条件执行
SET @column_exists = (
    SELECT COUNT(*) 
    FROM information_schema.COLUMNS 
    WHERE TABLE_SCHEMA = DATABASE() 
      AND TABLE_NAME = 'users' 
      AND COLUMN_NAME = 'phone'
);

SET @sql = CASE 
    WHEN @column_exists = 0 THEN 
        'ALTER TABLE users ADD COLUMN phone VARCHAR(20)'
    ELSE 
        'SELECT "Column phone already exists" as message'
END;

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
```

**🔧 批量操作技巧**
```sql
-- 批量删除以某前缀开头的表
SELECT 
    CONCAT('DROP TABLE IF EXISTS ', TABLE_NAME, ';') as drop_sql
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE() 
  AND TABLE_NAME LIKE 'temp_%';

-- 批量检查表是否存在
SELECT 
    check_table.table_name as '需要检查的表',
    CASE 
        WHEN actual_table.TABLE_NAME IS NOT NULL THEN '✓ 存在'
        ELSE '✗ 不存在'
    END as '存在状态'
FROM (
    SELECT 'users' as table_name
    UNION SELECT 'products'
    UNION SELECT 'orders'
    UNION SELECT 'categories'
) check_table
LEFT JOIN information_schema.TABLES actual_table
  ON actual_table.TABLE_SCHEMA = DATABASE()
  AND actual_table.TABLE_NAME = check_table.table_name;
```

**🔧 环境检查技巧**
```sql
-- 环境兼容性检查脚本
-- environment_check.sql

-- 1. MySQL版本检查
SELECT 
    $$version as current_version,
    CASE 
        WHEN $$version_comment LIKE '%MySQL%' THEN '✓ MySQL Server'
        WHEN $$version_comment LIKE '%MariaDB%' THEN '! MariaDB Server'
        ELSE '? Unknown Server'
    END as server_type,
    CASE 
        WHEN CAST(SUBSTRING_INDEX($$version, '.', 1) AS UNSIGNED) >= 8 THEN '✓ 版本支持'
        ELSE '✗ 版本过低'
    END as version_support;

-- 2. 权限检查
SELECT 
    GRANTEE as '用户',
    PRIVILEGE_TYPE as '权限'
FROM information_schema.USER_PRIVILEGES 
WHERE GRANTEE = CONCAT("'", USER(), "'")
  AND PRIVILEGE_TYPE IN ('CREATE', 'DROP', 'ALTER', 'INDEX');

-- 3. 存储引擎检查
SELECT 
    ENGINE as '存储引擎',
    SUPPORT as '支持状态',
    COMMENT as '说明'
FROM information_schema.ENGINES 
WHERE ENGINE IN ('InnoDB', 'MyISAM')
ORDER BY ENGINE;

-- 4. 字符集检查
SELECT 
    CHARACTER_SET_NAME as '字符集',
    DEFAULT_COLLATE_NAME as '默认排序规则'
FROM information_schema.CHARACTER_SETS 
WHERE CHARACTER_SET_NAME IN ('utf8mb4', 'utf8');

-- 5. 数据库大小检查
SELECT 
    SCHEMA_NAME as '数据库',
    ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) as '大小(MB)'
FROM information_schema.TABLES 
WHERE SCHEMA_NAME = DATABASE()
GROUP BY SCHEMA_NAME;
```

---

## 7. 🚀 实际应用场景


### 7.1 CI/CD流水线中的应用


**🔄 自动化部署脚本**
```bash
#!/bin/bash
# deploy_database.sh
# CI/CD流水线中的数据库部署脚本

set -e  # 遇到错误立即退出

# 配置变量
DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-3306}"
DB_NAME="${DB_NAME:-myapp_db}"
DB_USER="${DB_USER:-root}"
DB_PASSWORD="${DB_PASSWORD}"

# 颜色输出
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 1. 检查数据库连接
check_connection() {
    log_info "检查数据库连接..."
    
    if ! mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASSWORD" -e "SELECT 1;" &>/dev/null; then
        log_error "无法连接到数据库"
        exit 1
    fi
    
    log_info "数据库连接正常"
}

# 2. 执行SQL脚本
execute_sql_script() {
    local script_file=$1
    local script_name=$(basename "$script_file")
    
    log_info "执行脚本: $script_name"
    
    # 执行SQL脚本
    if mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" < "$script_file"; then
        log_info "脚本 $script_name 执行成功"
        return 0
    else
        log_error "脚本 $script_name 执行失败"
        return 1
    fi
}

# 3. 验证表结构
verify_tables() {
    log_info "验证表结构..."
    
    # 期望的表列表
    expected_tables=("users" "user_profiles" "products" "categories" "orders")
    
    for table in "${expected_tables[@]}"; do
        table_count=$(mysql -h"$DB_HOST" -P"$DB_PORT" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" \
            -e "SELECT COUNT(*) FROM information_schema.TABLES WHERE TABLE_SCHEMA='$DB_NAME' AND TABLE_NAME='$table';" \
            -s -N)
        
        if [ "$table_count" -eq 1 ]; then
            log_info "表 $table ✓"
        else
            log_error "表 $table ✗"
            return 1
        fi
    done
    
    log_info "所有表验证通过"
}

# 4. 主执行流程
main() {
    log_info "开始数据库部署..."
    
    # 检查环境
    check_connection
    
    # 执行初始化脚本
    if execute_sql_script "database_init.sql"; then
        log_info "数据库初始化完成"
    else
        log_error "数据库初始化失败"
        exit 1
    fi
    
    # 验证结果
    if verify_tables; then
        log_info "数据库部署成功！"
    else
        log_error "数据库验证失败！"
        exit 1
    fi
}

# 执行主流程
main "$@"
```

### 7.2 数据库版本管理


**📊 版本控制表设计**
```sql
-- 数据库版本管理系统
CREATE TABLE IF NOT EXISTS schema_migrations (
    version VARCHAR(20) PRIMARY KEY COMMENT '版本号',
    description VARCHAR(255) NOT NULL COMMENT '版本描述',
    sql_script VARCHAR(255) NOT NULL COMMENT 'SQL脚本文件名',
    checksum VARCHAR(64) COMMENT 'SQL脚本校验和',
    applied_by VARCHAR(100) NOT NULL COMMENT '执行人',
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '执行时间',
    execution_time_ms INT COMMENT '执行时间(毫秒)',
    
    INDEX idx_applied_at (applied_at),
    INDEX idx_version (version)
) ENGINE=InnoDB COMMENT='数据库版本迁移记录表';

-- 迁移脚本执行函数
DELIMITER //
CREATE PROCEDURE ExecuteMigration(
    IN migration_version VARCHAR(20),
    IN migration_description VARCHAR(255),
    IN script_name VARCHAR(255)
)
BEGIN
    DECLARE migration_exists INT DEFAULT 0;
    DECLARE start_time BIGINT;
    DECLARE end_time BIGINT;
    DECLARE execution_time INT;
    
    -- 检查版本是否已经执行过
    SELECT COUNT(*) INTO migration_exists 
    FROM schema_migrations 
    WHERE version = migration_version;
    
    IF migration_exists > 0 THEN
        SELECT CONCAT('Migration ', migration_version, ' already applied') as message;
    ELSE
        -- 记录开始时间
        SET start_time = UNIX_TIMESTAMP(NOW(3)) * 1000;
        
        -- 记录迁移开始
        INSERT INTO schema_migrations (
            version, description, sql_script, applied_by, execution_time_ms
        ) VALUES (
            migration_version, migration_description, script_name, USER(), 0
        );
        
        -- 这里执行实际的迁移SQL
        -- （实际使用中需要动态执行SQL脚本）
        
        -- 记录结束时间
        SET end_time = UNIX_TIMESTAMP(NOW(3)) * 1000;
        SET execution_time = end_time - start_time;
        
        -- 更新执行时间
        UPDATE schema_migrations 
        SET execution_time_ms = execution_time 
        WHERE version = migration_version;
        
        SELECT CONCAT('Migration ', migration_version, ' completed in ', execution_time, 'ms') as message;
    END IF;
END//
DELIMITER ;

-- 使用示例
CALL ExecuteMigration('1.0.1', '添加用户表', 'V001__create_users_table.sql');
```

### 7.3 多环境配置管理


**🌍 环境感知的脚本设计**
```sql
-- multi_environment.sql
-- 多环境配置管理脚本

-- 1. 创建环境配置表
CREATE TABLE IF NOT EXISTS environment_config (
    id INT PRIMARY KEY AUTO_INCREMENT,
    env_name ENUM('development', 'testing', 'staging', 'production') NOT NULL,
    config_key VARCHAR(100) NOT NULL,
    config_value TEXT,
    description VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_env_key (env_name, config_key)
) ENGINE=InnoDB COMMENT='环境配置表';

-- 2. 插入不同环境的配置
INSERT IGNORE INTO environment_config (env_name, config_key, config_value, description) VALUES
-- 开发环境配置
('development', 'max_connections', '100', '开发环境最大连接数'),
('development', 'innodb_buffer_pool_size', '128M', '开发环境缓冲池大小'),
('development', 'log_level', 'DEBUG', '开发环境日志级别'),

-- 测试环境配置
('testing', 'max_connections', '200', '测试环境最大连接数'),
('testing', 'innodb_buffer_pool_size', '256M', '测试环境缓冲池大小'),
('testing', 'log_level', 'INFO', '测试环境日志级别'),

-- 生产环境配置
('production', 'max_connections', '1000', '生产环境最大连接数'),
('production', 'innodb_buffer_pool_size', '2G', '生产环境缓冲池大小'),
('production', 'log_level', 'WARN', '生产环境日志级别');

-- 3. 根据环境创建不同的表结构
DELIMITER //
CREATE PROCEDURE CreateTablesByEnvironment(IN env_name VARCHAR(20))
BEGIN
    DECLARE table_suffix VARCHAR(10) DEFAULT '';
    
    -- 根据环境设置表后缀
    CASE env_name
        WHEN 'development' THEN SET table_suffix = '_dev';
        WHEN 'testing' THEN SET table_suffix = '_test';
        WHEN 'staging' THEN SET table_suffix = '_stage';
        ELSE SET table_suffix = '';
    END CASE;
    
    -- 动态创建用户表
    SET @sql = CONCAT('
        CREATE TABLE IF NOT EXISTS users', table_suffix, ' (
            id INT PRIMARY KEY AUTO_INCREMENT,
            username VARCHAR(50) NOT NULL,
            email VARCHAR(100) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            
            UNIQUE KEY uk_username (username),
            UNIQUE KEY uk_email (email)
        ) ENGINE=InnoDB COMMENT="', env_name, '环境用户表"
    ');
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    SELECT CONCAT('Environment: ', env_name, ', Table: users', table_suffix, ' created') as result;
END//
DELIMITER ;

-- 使用示例
CALL CreateTablesByEnvironment('development');
CALL CreateTablesByEnvironment('testing');
CALL CreateTablesByEnvironment('production');
```

### 7.4 脚本模板库


**📚 常用脚本模板**

**🔧 表结构同步脚本**
```sql
-- table_sync_template.sql
-- 表结构同步模板

-- 源环境和目标环境的表结构同步

-- 1. 检查目标表是否存在
CREATE TABLE IF NOT EXISTS table_sync_log (
    id INT PRIMARY KEY AUTO_INCREMENT,
    source_table VARCHAR(100) NOT NULL,
    target_table VARCHAR(100) NOT NULL,
    sync_type ENUM('create', 'alter', 'skip') NOT NULL,
    sql_executed TEXT,
    sync_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 2. 同步用户表结构
-- 获取源表结构
SET @source_ddl = (
    SELECT CREATE_TABLE_SQL FROM (
        SHOW CREATE TABLE source_db.users
    ) AS create_info
);

-- 检查目标表是否存在
SET @target_exists = (
    SELECT COUNT(*) 
    FROM information_schema.TABLES 
    WHERE TABLE_SCHEMA = DATABASE() 
      AND TABLE_NAME = 'users'
);

-- 根据情况执行同步
IF @target_exists = 0 THEN
    -- 表不存在，直接创建
    SET @sync_sql = REPLACE(@source_ddl, 'CREATE TABLE', 'CREATE TABLE IF NOT EXISTS');
    
    PREPARE stmt FROM @sync_sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    INSERT INTO table_sync_log (source_table, target_table, sync_type, sql_executed)
    VALUES ('source_db.users', 'users', 'create', @sync_sql);
ELSE
    -- 表已存在，记录跳过
    INSERT INTO table_sync_log (source_table, target_table, sync_type)
    VALUES ('source_db.users', 'users', 'skip');
END IF;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心语法


**🔸 条件DDL基本语法**
```sql
-- 创建语法
CREATE TABLE IF NOT EXISTS table_name (...);
CREATE DATABASE IF NOT EXISTS db_name;
CREATE INDEX IF NOT EXISTS index_name ON table_name(column);

-- 删除语法  
DROP TABLE IF EXISTS table_name;
DROP DATABASE IF EXISTS db_name;
DROP INDEX IF EXISTS index_name ON table_name;

-- 修改语法（部分支持）
ALTER TABLE table_name ADD COLUMN IF NOT EXISTS column_name data_type;
```

### 8.2 关键理解要点


**🔹 IF EXISTS和IF NOT EXISTS的本质**
```
作用机制：
• 不是真正的条件判断，而是错误抑制
• 让原本会报错的操作变成静默成功
• 提供脚本的幂等性保障

使用场景：
• 数据库初始化脚本
• 自动化部署流水线
• 开发环境重置
• 生产环境安全变更
```

**🔹 存在性检查的三种方式**
```
1. 语法级检查：IF EXISTS / IF NOT EXISTS
   • 优点：简单直接，性能好
   • 缺点：功能有限，不能做复杂判断

2. 查询级检查：information_schema
   • 优点：灵活强大，可获取详细信息
   • 缺点：需要额外查询，稍复杂

3. 程序级检查：应用代码判断
   • 优点：最灵活，可与业务逻辑结合
   • 缺点：增加代码复杂度
```

**🔹 脚本容错性设计思路**
```
设计原则：
• 幂等性：多次执行结果一致
• 原子性：全部成功或全部失败
• 可追溯：记录执行日志和状态
• 可回滚：支持错误恢复机制
• 验证性：执行后验证操作结果
```

### 8.3 实际应用的最佳实践


**⭐ 脚本编写黄金法则**
```sql
-- 1. 总是使用条件语法
CREATE TABLE IF NOT EXISTS users (...);  -- ✓ 推荐
CREATE TABLE users (...);                -- ❌ 不推荐

-- 2. 先删除后创建的安全模式
DROP TABLE IF EXISTS temp_users;
CREATE TABLE temp_users (...);

-- 3. 事务包装重要操作
START TRANSACTION;
-- DDL操作
COMMIT;

-- 4. 添加执行日志
INSERT INTO operation_log (operation, status) 
VALUES ('create_users_table', 'completed');
```

**📊 不同场景的选择策略**

| 使用场景 | **推荐方法** | **原因说明** |
|---------|-------------|-------------|
| **开发环境** | `IF NOT EXISTS` | `允许重复执行，快速开发` |
| **生产环境** | `先查询再操作` | `更可控，有明确反馈` |
| **CI/CD流水线** | `IF NOT EXISTS + 日志` | `自动化友好，可追溯` |
| **数据迁移** | `事务 + 验证` | `安全性优先` |
| **紧急修复** | `手动查询确认` | `避免意外操作` |

### 8.4 版本兼容性注意事项


**⚠️ MySQL版本差异**
```
MySQL 5.7及更早版本：
• 不支持：ALTER TABLE ... IF NOT EXISTS
• 不支持：CREATE INDEX IF NOT EXISTS  
• 支持：CREATE/DROP TABLE IF [NOT] EXISTS

MySQL 8.0及更新版本：
• 完整支持：所有DDL的条件语法
• 新增功能：更多DDL语句支持条件执行
• 增强特性：更好的错误信息和警告

兼容性建议：
• 生产环境建议升级到MySQL 8.0+
• 如必须使用旧版本，采用查询+动态SQL方式
```

### 8.5 常见问题和解决方案


**❓ 常见问题FAQ**

**Q1: IF NOT EXISTS创建的表结构和期望不一致怎么办？**
```sql
-- 问题：表已存在但结构不同
CREATE TABLE IF NOT EXISTS users (
    id INT,
    username VARCHAR(50),
    email VARCHAR(100)  -- 新字段，但表已存在且没有此字段
);

-- 解决方案：分步操作
CREATE TABLE IF NOT EXISTS users (
    id INT,
    username VARCHAR(50)
);

-- 然后检查并添加字段
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS email VARCHAR(100);
```

**Q2: 如何在脚本中获得更详细的执行反馈？**
```sql
-- 解决方案：结合查询和条件DDL
SET @table_exists = (
    SELECT COUNT(*) FROM information_schema.TABLES 
    WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'users'
);

SELECT 
    CASE 
        WHEN @table_exists = 0 THEN '将创建新表'
        ELSE '表已存在，跳过创建'
    END as operation_info;

CREATE TABLE IF NOT EXISTS users (...);

SELECT 
    CASE 
        WHEN @table_exists = 0 THEN '表创建成功'
        ELSE '表已存在'
    END as result_info;
```

**Q3: 如何处理外键依赖的表创建顺序？**
```sql
-- 解决方案：按依赖顺序创建
-- 1. 先创建被引用的表
CREATE TABLE IF NOT EXISTS categories (
    id INT PRIMARY KEY,
    name VARCHAR(100)
);

-- 2. 再创建引用其他表的表
CREATE TABLE IF NOT EXISTS products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(id)
);
```

### 8.6 进阶技巧和最佳实践


**🚀 高级应用技巧**

**动态表名处理**
```sql
-- 根据日期创建分表
DELIMITER //
CREATE PROCEDURE CreateMonthlyTable(IN table_month VARCHAR(6))
BEGIN
    SET @table_name = CONCAT('orders_', table_month);
    SET @sql = CONCAT('
        CREATE TABLE IF NOT EXISTS ', @table_name, ' (
            id INT PRIMARY KEY AUTO_INCREMENT,
            user_id INT NOT NULL,
            order_date DATE NOT NULL,
            amount DECIMAL(10,2) NOT NULL,
            
            INDEX idx_user_id (user_id),
            INDEX idx_order_date (order_date)
        ) ENGINE=InnoDB
    ');
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    SELECT CONCAT('表 ', @table_name, ' 处理完成') as message;
END//
DELIMITER ;

-- 使用示例
CALL CreateMonthlyTable('202501');
CALL CreateMonthlyTable('202502');
```

**批量表管理**
```sql
-- 批量创建相似结构的表
DELIMITER //
CREATE PROCEDURE CreateLogTables()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE table_name VARCHAR(50);
    
    WHILE i <= 12 DO
        SET table_name = CONCAT('user_log_', LPAD(i, 2, '0'));
        
        SET @sql = CONCAT('
            CREATE TABLE IF NOT EXISTS ', table_name, ' (
                id INT PRIMARY KEY AUTO_INCREMENT,
                user_id INT NOT NULL,
                action VARCHAR(100) NOT NULL,
                log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                
                INDEX idx_user_id (user_id),
                INDEX idx_log_time (log_time)
            ) ENGINE=InnoDB
        ');
        
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        SET i = i + 1;
    END WHILE;
    
    SELECT '所有日志表创建完成' as message;
END//
DELIMITER ;

CALL CreateLogTables();
```

### 8.7 学习建议


**📚 掌握路径建议**
```
初级阶段：
1. 熟练掌握基本的IF EXISTS语法
2. 理解存在性检查的基本原理
3. 能编写简单的初始化脚本

中级阶段：
1. 掌握information_schema查询方法
2. 能设计容错性较好的迁移脚本
3. 了解不同MySQL版本的兼容性

高级阶段：
1. 能设计复杂的多环境部署方案
2. 熟练使用动态SQL和存储过程
3. 具备完整的数据库版本管理能力
```

**💡 实践建议**
- **从简单开始**：先掌握基本的IF EXISTS语法，再学习复杂应用
- **多写多练**：编写各种场景的脚本，积累经验
- **重视测试**：所有脚本都要在测试环境充分验证
- **关注兼容性**：了解不同MySQL版本的差异
- **建立规范**：制定团队统一的脚本编写规范

**核心记忆**：
- IF EXISTS让删除操作变安全，IF NOT EXISTS让创建操作可重复
- 存在性检查有三种方式：语法级、查询级、程序级
- 脚本容错设计要考虑幂等性、原子性、可追溯性
- 不同环境和场景选择合适的检查策略
- 版本兼容性很重要，新版本支持更多条件DDL语法