---
title: 11、MySQL行格式详解
---
## 📚 目录

1. [行格式基本概念](#1-行格式基本概念)
2. [行记录结构详解](#2-行记录结构详解)
3. [四种行格式深度对比](#3-四种行格式深度对比)
4. [变长字段与NULL值管理](#4-变长字段与null值管理)
5. [行溢出处理机制](#5-行溢出处理机制)
6. [行格式性能影响分析](#6-行格式性能影响分析)
7. [行格式选择策略](#7-行格式选择策略)
8. [行格式配置与迁移](#8-行格式配置与迁移)
9. [实际应用最佳实践](#9-实际应用最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📖 行格式基本概念


### 1.1 什么是行格式


**🔸 行格式的本质**
```
行格式(ROW_FORMAT)：MySQL存储引擎将数据行存储到磁盘的方式
简单理解：就像整理衣柜的不同方法，有的节省空间，有的方便取用

为什么需要行格式？
├── 不同业务有不同需求
├── 有的要节省空间，有的要查询快
├── 有的要兼容性，有的要新功能
└── MySQL提供多种格式供选择
```

**💡 生活类比**
```
行格式就像不同的文件压缩方式：

📁 ZIP压缩 = COMPRESSED格式（高压缩比，解压慢）
📁 RAR压缩 = DYNAMIC格式（平衡压缩和速度）  
📁 不压缩 = REDUNDANT格式（占用大，访问快）
📁 7Z压缩 = COMPACT格式（适中压缩，兼容好）
```

### 1.2 行格式的发展历程


**🕐 MySQL行格式演进**
```
MySQL发展时间线：

2003年 MySQL 4.0
└── REDUNDANT格式
    └── 最早的InnoDB行格式，兼容性好但占用空间大

2005年 MySQL 5.0  
└── COMPACT格式
    └── 优化空间使用，成为长期默认格式

2010年 MySQL 5.1
└── DYNAMIC格式 
    └── 增强变长字段处理，更好的行溢出管理

2010年 MySQL 5.1
└── COMPRESSED格式
    └── 支持数据压缩，节省存储空间
```

### 1.3 四种行格式概览


| **行格式** | **引入版本** | **特点** | **适用场景** |
|-----------|-------------|---------|-------------|
| **REDUNDANT** | `MySQL 4.0` | `兼容性好，空间利用率低` | `旧系统兼容，小数据量` |
| **COMPACT** | `MySQL 5.0` | `平衡性能和空间，长期默认` | `通用场景，生产环境` |
| **DYNAMIC** | `MySQL 5.1` | `优化大字段处理，现代默认` | `大文本字段多的场景` |
| **COMPRESSED** | `MySQL 5.1` | `数据压缩，I/O密集` | `存储成本敏感场景` |

---

## 2. 🏗️ 行记录结构详解


### 2.1 MySQL行记录的基本结构


**🔸 通用行记录结构**
```
一条MySQL记录在磁盘上的存储结构：

┌─────────────┬─────────────┬─────────────┬─────────────┐
│  变长字段    │   NULL值     │   记录头     │   实际数据   │
│  长度列表    │   位图       │   信息       │   字段值     │
└─────────────┴─────────────┴─────────────┴─────────────┘
     ↑             ↑             ↑             ↑
   记录哪些字段   标记哪个字段   行元数据     真正的数据
   的实际长度     是NULL值      信息         内容
```

### 2.2 变长字段长度列表


**🔸 为什么需要长度列表**
```
问题：VARCHAR、TEXT等变长字段，长度不固定
解决：在行记录开头记录每个变长字段的实际长度

示例表结构：
CREATE TABLE user (
    id INT,              -- 固定长度，不需要记录
    name VARCHAR(50),    -- 变长字段，需要记录长度  
    email VARCHAR(100)   -- 变长字段，需要记录长度
);

插入数据：('1', 'Tom', 'tom@qq.com')
长度列表：[3, 10]  (name长度3，email长度10)
```

**📏 长度存储规则**
```
字段长度 ≤ 255字节：用1个字节存储长度
字段长度 > 255字节：用2个字节存储长度

存储顺序：按表定义的字段顺序倒序存储
示例：字段定义顺序 name, email
     长度列表存储：[email长度, name长度]
```

### 2.3 NULL值位图管理


**🔸 NULL值的存储挑战**
```
问题：NULL值不占用数据空间，但需要标记哪个字段是NULL
解决：用位图(bitmap)标记，1位对应1个字段

示例：
字段：id(NOT NULL), name(可NULL), email(可NULL), age(可NULL)
数据：(1, NULL, 'tom@qq.com', 25)

NULL位图：0 1 0 0 (从右到左对应 id, name, email, age)
└── id不能为NULL，name是NULL，email和age有值
```

**🧮 位图计算规则**
```
可为NULL的字段数量决定位图字节数：
1-8个可NULL字段   → 1个字节
9-16个可NULL字段  → 2个字节  
17-24个可NULL字段 → 3个字节

位的含义：
0 = 字段有值
1 = 字段为NULL
```

### 2.4 记录头信息


**🔸 记录头信息内容**
```
记录头信息(5字节)包含：

字节1-2：下一条记录的偏移量
└── 用于在页内快速定位下一条记录

字节3：记录类型和状态
└── 标记是普通记录、删除记录还是最小记录

字节4-5：所属的堆号
└── 在页内的位置标识

额外信息：
├── 记录是否被删除
├── 记录的类型标识  
└── 记录在页内的位置
```

---

## 3. 🔍 四种行格式深度对比


### 3.1 REDUNDANT格式详解


**🔸 REDUNDANT格式特点**
```
设计理念：保持最大兼容性，存储相对简单
优点：✅ 兼容性最好，稳定可靠
缺点：❌ 空间利用率低，存储开销大

存储结构：
┌─────────────┬─────────────┬─────────────┐
│  字段长度    │   记录头     │   字段数据   │
│  信息列表    │   信息       │             │
└─────────────┴─────────────┴─────────────┘

特殊之处：
- 每个字段都存储长度信息（即使是定长字段）
- 记录头信息较大
- 空间浪费相对明显
```

**适用场景**
```
✅ 从老版本MySQL升级的系统
✅ 需要最大兼容性的环境  
✅ 数据量不大，不在意空间开销
❌ 现代新系统不推荐使用
```

### 3.2 COMPACT格式详解


**🔸 COMPACT格式特点**
```
设计理念：在兼容性和空间效率间找平衡
优点：✅ 空间利用率提升，兼容性好
缺点：❌ 大字段处理不如DYNAMIC

存储优化：
- 只记录变长字段的长度
- 固定长度字段不记录长度信息
- 减少了存储开销

MySQL 5.0-5.7的默认行格式
```

**🔧 COMPACT vs REDUNDANT对比**
```
相同数据的存储对比：

表结构：id INT, name VARCHAR(20), age INT

REDUNDANT格式：
├── 存储字段长度：id长度 + name长度 + age长度
├── 占用空间：约15-20字节额外开销
└── 兼容性：最好

COMPACT格式：  
├── 存储字段长度：仅name长度(变长字段)
├── 占用空间：约8-12字节额外开销
└── 空间节省：约30-40%
```

### 3.3 DYNAMIC格式详解


**🔸 DYNAMIC格式特点**
```
设计理念：优化大字段和变长字段的存储
优点：✅ 大字段处理优秀，空间效率高
特点：✅ 现代MySQL的默认格式(8.0+)

核心改进：
1. 更智能的行溢出处理
2. 变长字段存储优化
3. 更好的空间利用率
```

**🔸 DYNAMIC vs COMPACT核心差异**
```
大字段处理差异：

COMPACT格式：
├── 行内存储：前768字节 + 20字节指针
├── 溢出页存储：剩余数据存储在溢出页
└── 缺点：即使很大的字段，行内也要存768字节

DYNAMIC格式：
├── 行内存储：仅存储20字节指针  
├── 溢出页存储：所有数据都在溢出页
└── 优点：行内空间更紧凑，减少页分裂
```

### 3.4 COMPRESSED格式详解


**🔸 COMPRESSED格式特点**
```
设计理念：通过压缩减少存储空间和I/O
优点：✅ 存储空间最小，I/O减少
缺点：❌ CPU开销大，查询性能可能下降

压缩机制：
1. 使用zlib算法压缩数据页
2. 压缩比通常30-70%
3. 解压缩需要额外CPU计算
```

**💰 COMPRESSED适用场景分析**
```
适合使用：
✅ 存储成本高昂(云存储、SSD)
✅ I/O是瓶颈，CPU资源充足
✅ 历史数据，查询频率低
✅ 数据仓库，分析型业务

不适合使用：
❌ CPU资源紧张
❌ 频繁更新的OLTP系统  
❌ 对查询延迟敏感的应用
❌ 小数据量表(压缩收益小)
```

---

## 4. 📊 变长字段与NULL值管理


### 4.1 变长字段存储机制


**🔸 变长字段存储策略**
```
MySQL变长字段类型：
VARCHAR(n)：可变长字符串
TEXT：大文本字段  
BLOB：二进制大对象
JSON：JSON格式数据

存储原理：
实际数据 + 长度信息 = 完整存储

示例：VARCHAR(100)字段存储'Hello'
┌─────────┬─────────────────┐
│ 长度:5  │ 数据:'Hello'    │
└─────────┴─────────────────┘
实际占用：1字节长度 + 5字节数据 = 6字节
```

### 4.2 长度字段编码规则


**🔸 长度字段的存储方式**
```
VARCHAR长度编码：

字符串长度 ≤ 255字符：
└── 用1个字节存储长度

字符串长度 > 255字符：  
└── 用2个字节存储长度

TEXT类型长度编码：
├── TINYTEXT：1字节长度 (最大255字节)
├── TEXT：2字节长度 (最大65K)  
├── MEDIUMTEXT：3字节长度 (最大16M)
└── LONGTEXT：4字节长度 (最大4G)
```

### 4.3 NULL值位图高效管理


**🔸 NULL位图的空间优化**
```
传统方式：每个字段用特殊值表示NULL
MySQL方式：用位图统一管理所有NULL值

空间对比：
传统方式：每个NULL字段占用完整字段空间
位图方式：8个字段的NULL状态只需1个字节

示例表：10个可NULL字段
传统方式：最多浪费 10 × 平均字段大小
位图方式：只需要 2个字节(10个字段需要2字节位图)
```

**🧮 位图计算实例**
```
表结构：
CREATE TABLE example (
    id INT NOT NULL,        -- 不参与NULL位图
    name VARCHAR(50),       -- 位置0
    email VARCHAR(100),     -- 位置1  
    phone VARCHAR(20),      -- 位置2
    address TEXT            -- 位置3
);

插入数据：(1, 'Tom', NULL, '123456', NULL)

NULL位图计算：
name=有值  → 位0 = 0
email=NULL → 位1 = 1  
phone=有值 → 位2 = 0
address=NULL → 位3 = 1

位图：1010 (二进制) = 0x0A (十六进制)
存储：只需要1个字节
```

---

## 5. 🌊 行溢出处理机制


### 5.1 什么是行溢出


**🔸 行溢出问题的产生**
```
MySQL页大小限制：默认16KB (16384字节)
行记录限制：单行数据不能超过页大小的一半

当出现超大字段时：
├── 大文本字段(TEXT)
├── 大二进制字段(BLOB)
├── 超长VARCHAR字段
└── 大JSON字段

就需要"行溢出"处理机制
```

**📏 行溢出的判断标准**
```
InnoDB行溢出触发条件：

1. 单行数据 > 8KB (页大小的一半)
2. 单个字段 > 768字节 (COMPACT/REDUNDANT)
3. 单个字段 > 40字节 (DYNAMIC/COMPRESSED特殊情况)

实际例子：
页大小：16KB = 16384字节
溢出阈值：8KB = 8192字节
如果一行数据总长度超过8192字节，就会发生行溢出
```

### 5.2 不同格式的溢出处理策略


**🔸 COMPACT/REDUNDANT溢出处理**
```
溢出页处理方式：

原始页内：
┌─────────────────────────────────────┐
│ 大字段前768字节 + 20字节溢出页指针    │
└─────────────────────────────────────┘
                ↓ (指针指向)
溢出页：
┌─────────────────────────────────────┐
│        大字段剩余部分               │
└─────────────────────────────────────┘

特点：行内总是保留768字节数据
```

**🔸 DYNAMIC/COMPRESSED溢出处理**
```
智能溢出处理：

小字段(≤40字节)：完全存储在行内
大字段(>768字节)：完全存储在溢出页，行内只保留20字节指针

原始页内：
┌─────────────────────────────────────┐
│ 小字段完整数据 + 大字段20字节指针     │  
└─────────────────────────────────────┘
                ↓ (指针指向)
溢出页：
┌─────────────────────────────────────┐
│        大字段完整数据               │
└─────────────────────────────────────┘

优势：行内空间更紧凑，减少页分裂
```

### 5.3 行溢出的性能影响


**🔸 性能影响分析**
```
读取性能：
├── 行内数据：1次I/O即可读取
├── 溢出数据：需要额外的I/O读取溢出页
└── DYNAMIC格式：减少不必要的溢出页读取

写入性能：
├── 行溢出时：需要分配额外的溢出页
├── 页分裂：可能导致B+树页分裂
└── 碎片产生：频繁的溢出操作产生空间碎片

查询优化：
SELECT name FROM user;  -- 如果name在行内，查询快
SELECT content FROM article;  -- 如果content溢出，查询慢
```

---

## 6. ⚡ 行格式性能影响分析


### 6.1 存储空间对比


**🔸 相同数据不同格式的空间占用**
```
测试表结构：
CREATE TABLE test (
    id INT,
    name VARCHAR(50),
    content TEXT
);

插入1万条记录，每条content约2KB：

格式对比结果：
REDUNDANT：  约240MB (基准)
COMPACT：    约180MB (节省25%)
DYNAMIC：    约160MB (节省33%)  
COMPRESSED： 约80MB (节省67%)

空间效率排序：
COMPRESSED > DYNAMIC > COMPACT > REDUNDANT
```

### 6.2 查询性能对比


**🔸 不同操作的性能表现**

| **操作类型** | **REDUNDANT** | **COMPACT** | **DYNAMIC** | **COMPRESSED** |
|-------------|---------------|-------------|-------------|---------------|
| **🔍 按主键查询** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **📊 范围查询** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **📝 插入操作** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |
| **🔄 更新操作** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **🗑️ 删除操作** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |

性能说明：
⭐⭐⭐⭐⭐ = 最优  ⭐⭐⭐⭐ = 良好  ⭐⭐⭐ = 一般  ⭐⭐ = 较差
```

### 6.3 资源消耗对比


**🔸 CPU和I/O资源使用**
```
CPU消耗（压缩/解压开销）：
REDUNDANT：  █░░░░ (几乎无额外CPU开销)
COMPACT：    █░░░░ (几乎无额外CPU开销)  
DYNAMIC：    █░░░░ (几乎无额外CPU开销)
COMPRESSED： █████ (大量CPU用于压缩解压)

I/O消耗（磁盘读写量）：
REDUNDANT：  █████ (最多I/O)
COMPACT：    ████░ (减少约25% I/O)
DYNAMIC：    ███░░ (减少约40% I/O)  
COMPRESSED： ██░░░ (减少约60% I/O)

内存使用：
COMPRESSED格式需要额外的解压缩缓冲区
其他格式内存使用基本相同
```

---

## 7. 🎯 行格式选择策略


### 7.1 选择决策矩阵


**🔸 业务场景决策表**

| **业务特征** | **推荐格式** | **核心原因** |
|-------------|-------------|-------------|
| **📱 移动应用后台** | `DYNAMIC` | `数据量适中，查询频繁` |
| **💰 金融交易系统** | `COMPACT` | `稳定可靠，性能均衡` |
| **📊 数据仓库** | `COMPRESSED` | `存储成本敏感，查询较少` |
| **🎮 游戏日志系统** | `DYNAMIC` | `大量TEXT字段，写入频繁` |
| **🏢 传统企业系统** | `COMPACT` | `兼容性好，运维简单` |
| **☁️ 云存储应用** | `COMPRESSED` | `存储按量计费，压缩节省成本` |

### 7.2 字段类型与格式匹配


**🔸 根据字段特点选择格式**
```
表字段分析：

主要是定长字段(INT, DATETIME等)：
└── 选择COMPACT，兼容性好，性能稳定

包含大量VARCHAR字段：
└── 选择DYNAMIC，变长字段处理更优

包含TEXT/BLOB大字段：
└── 选择DYNAMIC，行溢出处理更智能

历史数据表，查询少：
└── 选择COMPRESSED，节省存储成本

高并发OLTP系统：
└── 选择COMPACT或DYNAMIC，避免COMPRESSED的CPU开销
```

### 7.3 选择原则与权衡


**🔸 选择的核心原则**
```
1. 性能优先原则：
   OLTP系统 → 选择COMPACT/DYNAMIC
   OLAP系统 → 可考虑COMPRESSED

2. 存储成本考虑：
   存储昂贵 → 优先COMPRESSED
   存储便宜 → 优先性能格式

3. 维护复杂度：
   团队技术强 → 可选择DYNAMIC
   求稳定 → 选择COMPACT

4. 兼容性要求：
   老系统迁移 → 考虑REDUNDANT
   新系统 → 直接DYNAMIC
```

**⚖️ 权衡分析框架**
```
决策因素优先级：

高优先级：
🔴 业务性能要求 (响应时间、吞吐量)
🔴 数据安全稳定性 (不能出问题)

中优先级：  
🟡 存储成本 (成本压力)
🟡 运维复杂度 (团队能力)

低优先级：
🟢 新技术尝试 (技术追求)
🟢 理论上的优化 (实际收益小)
```

---

## 8. 🔧 行格式配置与迁移


### 8.1 行格式配置方法


**🔸 创建表时指定行格式**
```sql
-- 创建表时指定行格式
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100),
    content TEXT
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC;
```

**🔸 修改现有表的行格式**
```sql
-- 修改表的行格式
ALTER TABLE user ROW_FORMAT=COMPRESSED;

-- 查看表的当前行格式
SHOW TABLE STATUS LIKE 'user'\G

-- 或者查询information_schema
SELECT 
    TABLE_NAME,
    ROW_FORMAT,
    TABLE_ROWS,
    DATA_LENGTH/1024/1024 AS 'Data Size(MB)'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'your_database';
```

### 8.2 全局默认配置


**🔸 设置默认行格式**
```sql
-- 查看当前默认行格式
SHOW VARIABLES LIKE 'innodb_default_row_format';

-- 修改默认行格式(MySQL 5.7.9+)
SET GLOBAL innodb_default_row_format = 'DYNAMIC';

-- 在配置文件中永久设置
[mysqld]
innodb_default_row_format = DYNAMIC
```

### 8.3 行格式迁移步骤


**🔸 安全迁移操作指南**
```
迁移前准备：
1️⃣ 备份数据：完整备份原表数据
2️⃣ 评估影响：分析表大小和业务影响  
3️⃣ 选择时机：在业务低峰期操作
4️⃣ 准备回滚：制定回滚方案

迁移执行：
1️⃣ 停止应用写入(可选)
2️⃣ 执行ALTER TABLE命令
3️⃣ 监控迁移进度
4️⃣ 验证数据完整性

迁移后验证：
1️⃣ 检查行格式是否正确
2️⃣ 验证数据完整性
3️⃣ 测试应用功能
4️⃣ 监控性能变化
```

**💡 迁移注意事项**
```
⚠️ 重要提醒：

ALTER TABLE修改行格式会：
❌ 重建整个表 (耗时长)
❌ 需要足够的磁盘空间 (约2倍表大小)
❌ 可能锁表 (影响业务)
❌ 产生大量redo log

建议：
✅ 在从库先操作，再主从切换
✅ 使用pt-online-schema-change工具
✅ 分批次迁移，降低影响
```

---

## 9. 🎯 实际应用最佳实践


### 9.1 不同业务场景的格式选择


**🔸 电商系统行格式策略**
```
用户表 (读写频繁)：
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20)
) ROW_FORMAT=COMPACT;  -- 稳定可靠

商品表 (大图片字段)：
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(200),
    description TEXT,    -- 可能很长
    images JSON         -- 大字段
) ROW_FORMAT=DYNAMIC;   -- 大字段处理优秀

订单历史表 (查询少，数据量大)：
CREATE TABLE order_history (
    order_id BIGINT PRIMARY KEY,
    order_data JSON,
    user_behavior TEXT
) ROW_FORMAT=COMPRESSED;  -- 节省存储成本
```

### 9.2 行格式监控与优化


**🔸 行格式效果监控**
```sql
-- 监控表的存储效率
SELECT 
    TABLE_NAME,
    ROW_FORMAT,
    TABLE_ROWS,
    ROUND(DATA_LENGTH/1024/1024, 2) AS 'Data_MB',
    ROUND(INDEX_LENGTH/1024/1024, 2) AS 'Index_MB',
    ROUND((DATA_LENGTH + INDEX_LENGTH)/1024/1024, 2) AS 'Total_MB',
    ROUND(DATA_LENGTH/TABLE_ROWS, 0) AS 'Avg_Row_Size'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'your_database'
AND TABLE_ROWS > 0
ORDER BY DATA_LENGTH DESC;
```

**📊 性能优化检查点**
```
空间效率检查：
├── 平均行大小是否合理
├── 索引与数据比例是否正常
└── 压缩效果是否达到预期

查询性能检查：  
├── 慢查询是否增加
├── I/O等待是否正常
└── CPU使用率变化

业务影响检查：
├── 应用响应时间
├── 并发处理能力  
└── 错误率是否正常
```

### 9.3 行格式迁移案例


**🔸 实际迁移案例：COMPACT → DYNAMIC**
```
背景：某社交应用用户动态表，包含大量长文本
问题：COMPACT格式下行溢出频繁，查询性能下降

迁移计划：
阶段1：业务低峰期(凌晨2-4点)
阶段2：先在从库操作验证
阶段3：主从切换完成迁移

执行脚本：
-- 从库执行迁移
ALTER TABLE user_posts ROW_FORMAT=DYNAMIC;

-- 验证结果
SHOW TABLE STATUS LIKE 'user_posts'\G

迁移效果：
存储空间：减少约30%
查询性能：大文本字段查询提升40%
行溢出：减少80%的溢出页访问
```

---

## 10. 📋 核心要点总结


### 10.1 四种格式快速对比


```
🔸 格式特点一句话总结：

REDUNDANT：老古董，兼容好，占地方
COMPACT：老实人，中规中矩，最常用  
DYNAMIC：新主流，大字段好，推荐用
COMPRESSED：压缩王，省空间，CPU累
```

### 10.2 选择决策流程图


```
开始选择行格式
        ↓
    是否有大字段(TEXT/BLOB)？
      ↙              ↘
     有               没有
     ↓                ↓
  存储成本敏感？      追求最大兼容性？
   ↙      ↘          ↙        ↘
  是       否        是         否
  ↓        ↓         ↓          ↓
COMPRESSED DYNAMIC REDUNDANT  COMPACT
```

### 10.3 关键配置命令


```sql
-- 查看支持的行格式
SHOW ENGINES;

-- 查看当前默认行格式  
SHOW VARIABLES LIKE 'innodb_default_row_format';

-- 创建表指定格式
CREATE TABLE t1 (...) ROW_FORMAT=DYNAMIC;

-- 修改表格式
ALTER TABLE t1 ROW_FORMAT=COMPRESSED;

-- 查看表格式
SHOW TABLE STATUS LIKE 't1'\G
```

### 10.4 最佳实践建议


**🎯 生产环境建议**
```
新项目默认选择：DYNAMIC
├── 现代MySQL默认格式
├── 大字段处理优秀
├── 空间效率高
└── 性能表现好

特殊场景调整：
├── 存储成本敏感 → COMPRESSED
├── 老系统兼容 → COMPACT
├── 极简场景 → COMPACT
└── 性能敏感 → 避免COMPRESSED
```

**🧠 记忆口诀**
```
行格式选择三步走：
看业务，看字段，看成本
大字段多选DYNAMIC
存储贵了COMPRESSED  
求稳定就用COMPACT
老系统还有REDUNDANT
```

**⚠️ 注意事项**
```
🔸 修改行格式是重型操作，会重建表
🔸 不同格式间迁移需要充足的磁盘空间
🔸 COMPRESSED格式会增加CPU负载
🔸 行格式选择要结合实际业务测试验证
🔸 监控迁移前后的性能变化
```

---

> 💡 **一句话总结**
> 
> MySQL行格式就是数据行的存储方式，DYNAMIC是现代推荐选择，能智能处理大字段；COMPRESSED适合存储成本敏感场景；COMPACT是经典稳定选择；REDUNDANT只为兼容性保留。选择时主要看有没有大字段和是否在意存储成本。