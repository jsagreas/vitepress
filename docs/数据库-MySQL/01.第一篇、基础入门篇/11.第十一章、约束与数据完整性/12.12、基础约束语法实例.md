---
title: 12、基础约束语法实例
---
## 📚 目录

1. [约束概述与基础概念](#1-约束概述与基础概念)
2. [PRIMARY KEY主键约束](#2-primary-key主键约束)
3. [FOREIGN KEY外键约束](#3-foreign-key外键约束)
4. [UNIQUE唯一约束](#4-unique唯一约束)
5. [NOT NULL非空约束](#5-not-null非空约束)
6. [DEFAULT默认值约束](#6-default默认值约束)
7. [约束组合使用实践](#7-约束组合使用实践)
8. [约束管理与维护](#8-约束管理与维护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 约束概述与基础概念


### 1.1 什么是数据库约束


**简单理解**：约束就是给数据设置的"规则"，确保存储的数据符合业务要求。

```
现实生活中的约束              数据库中的约束
┌─────────────────┐          ┌─────────────────┐
│ 身份证号唯一     │          │ PRIMARY KEY     │
│ 学生必须有学号   │    ≈     │ NOT NULL        │
│ 年龄不能为负数   │          │ CHECK           │
│ 学生属于某班级   │          │ FOREIGN KEY     │
└─────────────────┘          └─────────────────┘
```

**🔧 约束的核心作用**：
- **数据完整性**：确保数据准确、完整、一致
- **业务规则**：强制执行业务逻辑规则
- **数据质量**：防止错误数据进入系统
- **系统稳定**：减少因脏数据导致的程序错误

### 1.2 MySQL约束类型总览


**📊 约束类型全景图**：

| 约束类型 | **作用** | **使用频率** | **重要程度** | **学习优先级** |
|---------|---------|-------------|-------------|---------------|
| **PRIMARY KEY** | `唯一标识记录` | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 🔥 必学 |
| **FOREIGN KEY** | `维护表间关系` | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 🔥 必学 |
| **UNIQUE** | `保证数据唯一` | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🔥 必学 |
| **NOT NULL** | `禁止空值` | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🔥 必学 |
| **DEFAULT** | `设置默认值` | ⭐⭐⭐⭐ | ⭐⭐⭐ | 🔥 必学 |
| **CHECK** | `条件检查` | ⭐⭐ | ⭐⭐⭐ | ⭐ 了解即可 |

### 1.3 约束的工作时机


**⏰ 约束检查时间点**：

```
数据操作流程:
用户提交SQL
    ↓
语法检查
    ↓
权限验证  
    ↓
🔒 约束检查 ← 在这里检查所有约束
    ↓
执行操作
    ↓
提交事务
```

> 💡 **重要理解**
> 
> 约束是在数据写入**之前**检查的，一旦违反约束，整个操作会被拒绝，确保数据库中的数据始终符合规则。

---

## 2. 🔑 PRIMARY KEY主键约束


### 2.1 主键的含义和作用


**什么是主键**：
主键就是一张表中用来**唯一标识每一行记录**的字段或字段组合。

```
就像生活中的例子：
┌─────────────────┐
│ 身份证号 → 人   │  每个人都有唯一的身份证号
│ 学号 → 学生     │  每个学生都有唯一的学号  
│ 商品编码 → 商品 │  每个商品都有唯一的编码
└─────────────────┘
```

**🎯 主键的核心特点**：
- **唯一性**：表中不能有重复的主键值
- **非空性**：主键字段不能为NULL
- **不可变性**：主键值一旦确定，不建议修改
- **唯一索引**：MySQL自动为主键创建唯一索引

### 2.2 PRIMARY KEY基础语法


**🔧 创建表时定义主键**：

```sql
-- 方式1：在字段定义时指定主键 (单字段主键)
CREATE TABLE students (
    id INT PRIMARY KEY,           -- 简单方式
    name VARCHAR(50) NOT NULL,
    age INT
);

-- 方式2：在表定义末尾指定主键 (推荐方式)
CREATE TABLE students (
    id INT,
    name VARCHAR(50) NOT NULL,
    age INT,
    PRIMARY KEY (id)              -- 明确指定主键
);

-- 方式3：复合主键 (多个字段组合)
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 两个字段组合作为主键
);
```

**⚡ 自增主键的使用**：

```sql
-- 自增主键（最常用）
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- 自动递增的主键
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入数据时不需要指定id值
INSERT INTO users (username, email) VALUES 
('zhangsan', 'zhang@example.com'),
('lisi', 'li@example.com');

-- 查看自动分配的id
SELECT * FROM users;
-- 结果：id自动为1, 2, 3...
```

### 2.3 主键约束的实际效果


**🔍 主键约束验证**：

```sql
-- 创建测试表
CREATE TABLE test_pk (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

-- ✅ 正常插入
INSERT INTO test_pk VALUES (1, '张三');
INSERT INTO test_pk VALUES (2, '李四');

-- ❌ 违反唯一性约束
INSERT INTO test_pk VALUES (1, '王五');
-- 错误：Duplicate entry '1' for key 'PRIMARY'

-- ❌ 违反非空约束  
INSERT INTO test_pk VALUES (NULL, '赵六');
-- 错误：Column 'id' cannot be null
```

### 2.4 主键的修改和管理


**🔧 主键的维护操作**：

```sql
-- 为已存在的表添加主键
ALTER TABLE existing_table ADD PRIMARY KEY (id);

-- 删除主键约束
ALTER TABLE students DROP PRIMARY KEY;

-- 修改主键（需要先删除后添加）
ALTER TABLE students DROP PRIMARY KEY;
ALTER TABLE students ADD PRIMARY KEY (new_id);

-- 查看表的主键信息
SHOW CREATE TABLE students;
-- 或者
DESC students;  -- 主键字段会显示PRI
```

---

## 3. 🔗 FOREIGN KEY外键约束


### 3.1 外键的含义和作用


**什么是外键**：
外键是一个表中的字段，它引用另一个表的主键，用来**建立表与表之间的关联关系**。

```
现实中的关联关系：
学生表                        班级表
┌─────────────────┐          ┌─────────────────┐
│ 学号(主键)       │          │ 班级编号(主键)   │
│ 姓名            │          │ 班级名称        │
│ 班级编号(外键)   │ ────────→│ 班主任          │
│ 年龄            │          │ 教室号          │
└─────────────────┘          └─────────────────┘

外键的作用：确保学生的班级编号必须是真实存在的班级
```

**🎯 外键约束的核心价值**：
- **引用完整性**：确保关联数据的存在
- **数据一致性**：防止出现"孤儿记录"
- **业务逻辑**：强制执行表间的业务关系
- **级联操作**：自动维护关联数据的变化

### 3.2 FOREIGN KEY基础语法


**🔧 创建表时定义外键**：

```sql
-- 先创建被引用的表（父表）
CREATE TABLE classes (
    class_id INT PRIMARY KEY,
    class_name VARCHAR(50) NOT NULL,
    teacher VARCHAR(50)
);

-- 再创建引用表（子表）
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    class_id INT,                          -- 外键字段
    FOREIGN KEY (class_id)                 -- 定义外键约束
        REFERENCES classes(class_id)       -- 引用classes表的class_id
);
```

**📝 外键约束的完整语法**：

```sql
-- 完整的外键定义语法
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE,
    
    -- 命名约束（推荐方式）
    CONSTRAINT fk_orders_customer           -- 约束名称
        FOREIGN KEY (customer_id)          -- 本表字段
        REFERENCES customers(customer_id)  -- 引用表和字段
        ON DELETE CASCADE                  -- 删除时级联删除
        ON UPDATE CASCADE                  -- 更新时级联更新
);
```

### 3.3 外键的级联操作


**🔄 级联操作详解**：

| 级联选项 | **含义** | **效果** | **使用场景** |
|---------|---------|---------|-------------|
| **CASCADE** | `级联操作` | 父表删除/更新时，子表记录同步操作 | 强关联关系 |
| **SET NULL** | `设为空值` | 父表删除/更新时，子表外键设为NULL | 弱关联关系 |
| **RESTRICT** | `限制操作` | 有子表记录时，禁止父表删除/更新 | 严格完整性 |
| **NO ACTION** | `无动作` | 同RESTRICT，延迟到事务末尾检查 | 默认行为 |

**💡 级联操作示例**：

```sql
-- 测试级联删除
-- 父表数据
INSERT INTO classes VALUES (1, '一年级1班', '张老师');
INSERT INTO classes VALUES (2, '一年级2班', '李老师');

-- 子表数据
INSERT INTO students VALUES (1, '小明', 1);
INSERT INTO students VALUES (2, '小红', 1);
INSERT INTO students VALUES (3, '小强', 2);

-- 删除班级（CASCADE级联删除）
DELETE FROM classes WHERE class_id = 1;
-- 结果：一年级1班被删除，小明和小红的记录也被自动删除

-- SET NULL示例
ALTER TABLE students 
DROP FOREIGN KEY fk_students_class;

ALTER TABLE students 
ADD CONSTRAINT fk_students_class 
    FOREIGN KEY (class_id) REFERENCES classes(class_id)
    ON DELETE SET NULL;

-- 删除班级时，学生的class_id变为NULL而不是删除记录
```

### 3.4 外键约束的验证


**🔍 外键约束的实际效果**：

```sql
-- ✅ 正常插入（班级存在）
INSERT INTO students VALUES (4, '小李', 2);  -- 成功

-- ❌ 违反外键约束（班级不存在）
INSERT INTO students VALUES (5, '小王', 999);
-- 错误：Cannot add or update a child row: a foreign key constraint fails

-- ✅ 插入NULL值（允许的）
INSERT INTO students VALUES (6, '小赵', NULL);  -- 成功，表示未分班

-- ❌ 删除被引用的父表记录（有子表记录时）
DELETE FROM classes WHERE class_id = 2;
-- 错误（如果是RESTRICT）：Cannot delete or update a parent row
```

---

## 4. ⭐ UNIQUE唯一约束


### 4.1 唯一约束的含义


**什么是唯一约束**：
确保字段中的**所有值都不重复**，但允许有NULL值（NULL不参与唯一性检查）。

```
UNIQUE vs PRIMARY KEY的区别：
┌─────────────────┐          ┌─────────────────┐
│ UNIQUE约束      │          │ PRIMARY KEY     │
│ ├─ 可以为NULL    │          │ ├─ 不能为NULL    │
│ ├─ 表中可以多个  │    VS    │ ├─ 表中只能一个  │
│ ├─ 不自动创建索引│          │ ├─ 自动创建索引  │
│ └─ 用于业务唯一性│          │ └─ 用于记录标识  │
└─────────────────┘          └─────────────────┘
```

### 4.2 UNIQUE约束基础语法


**🔧 单字段唯一约束**：

```sql
-- 方式1：在字段定义时指定
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,      -- 用户名唯一
    email VARCHAR(100) UNIQUE,        -- 邮箱唯一
    phone VARCHAR(20)
);

-- 方式2：在表定义末尾指定
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    UNIQUE (username),                -- 明确指定唯一约束
    UNIQUE (email)
);
```

**🔧 复合字段唯一约束**：

```sql
-- 多个字段组合唯一
CREATE TABLE course_selection (
    id INT PRIMARY KEY,
    student_id INT,
    course_id INT,
    semester VARCHAR(20),
    
    -- 同一学期，同一学生不能选择同一门课程
    UNIQUE (student_id, course_id, semester)
);
```

### 4.3 命名唯一约束


**📝 为约束命名**：

```sql
CREATE TABLE products (
    id INT PRIMARY KEY,
    product_code VARCHAR(50),
    product_name VARCHAR(100),
    
    -- 命名约束便于管理
    CONSTRAINT uk_products_code UNIQUE (product_code),
    CONSTRAINT uk_products_name UNIQUE (product_name)
);
```

> 💡 **命名建议**
> 
> 约束命名规范：`约束类型_表名_字段名`
> - `uk_` = UNIQUE Key
> - `fk_` = FOREIGN Key  
> - `pk_` = PRIMARY Key

### 4.4 唯一约束的验证效果


**🔍 测试唯一约束**：

```sql
-- 正常插入
INSERT INTO users VALUES (1, 'zhangsan', 'zhang@qq.com', '13800138001');
INSERT INTO users VALUES (2, 'lisi', 'li@qq.com', '13800138002');

-- ❌ 违反用户名唯一约束
INSERT INTO users VALUES (3, 'zhangsan', 'zhang2@qq.com', '13800138003');
-- 错误：Duplicate entry 'zhangsan' for key 'username'

-- ❌ 违反邮箱唯一约束
INSERT INTO users VALUES (3, 'wangwu', 'zhang@qq.com', '13800138003');
-- 错误：Duplicate entry 'zhang@qq.com' for key 'email'

-- ✅ NULL值不参与唯一性检查
INSERT INTO users VALUES (3, 'wangwu', NULL, '13800138003');      -- 成功
INSERT INTO users VALUES (4, 'zhaoliu', NULL, '13800138004');     -- 也成功
```

---

## 5. ⛔ NOT NULL非空约束


### 5.1 非空约束的含义


**什么是非空约束**：
确保字段**必须有值**，不能为空（NULL）。

```
现实场景理解：
┌─────────────────────────────────┐
│ 用户注册时：                     │
│ ├─ 用户名：必须填写 (NOT NULL)    │
│ ├─ 邮箱：必须填写 (NOT NULL)      │  
│ ├─ 密码：必须填写 (NOT NULL)      │
│ └─ 头像：可以不填 (允许NULL)      │
└─────────────────────────────────┘
```

### 5.2 NOT NULL基础语法


**🔧 定义非空约束**：

```sql
CREATE TABLE user_profiles (
    id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,        -- 用户名必填
    email VARCHAR(100) NOT NULL,          -- 邮箱必填
    password VARCHAR(255) NOT NULL,       -- 密码必填
    nickname VARCHAR(50),                 -- 昵称可选
    avatar_url VARCHAR(200),              -- 头像可选
    bio TEXT,                             -- 个人简介可选
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP  -- 创建时间必填且有默认值
);
```

### 5.3 非空约束的验证


**🔍 测试非空约束**：

```sql
-- ✅ 提供所有必填字段
INSERT INTO user_profiles (username, email, password) 
VALUES ('testuser', 'test@example.com', 'password123');

-- ❌ 缺少必填字段
INSERT INTO user_profiles (username, email) 
VALUES ('testuser2', 'test2@example.com');
-- 错误：Field 'password' doesn't have a default value

-- ❌ 显式插入NULL到非空字段
INSERT INTO user_profiles (username, email, password) 
VALUES ('testuser3', NULL, 'password123');
-- 错误：Column 'email' cannot be null
```

### 5.4 修改非空约束


**🔧 约束的添加和移除**：

```sql
-- 为已存在的字段添加非空约束
ALTER TABLE user_profiles MODIFY phone VARCHAR(20) NOT NULL;

-- 移除非空约束（改为允许NULL）
ALTER TABLE user_profiles MODIFY bio TEXT NULL;

-- 注意：添加非空约束前，确保现有数据中该字段没有NULL值
-- 否则会失败
```

---

## 6. 🎲 DEFAULT默认值约束


### 6.1 默认值约束的含义


**什么是默认值约束**：
当插入数据时**没有指定字段值**，系统自动使用预设的默认值。

```
默认值的应用场景：
┌─────────────────────────────────┐
│ 用户注册：                       │
│ ├─ 状态 → 默认为"激活"           │
│ ├─ 积分 → 默认为0               │
│ ├─ 注册时间 → 默认为当前时间      │
│ └─ 会员等级 → 默认为"普通"       │
└─────────────────────────────────┘
```

### 6.2 DEFAULT约束基础语法


**🔧 常用默认值类型**：

```sql
CREATE TABLE user_accounts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    
    -- 字符串默认值
    status VARCHAR(20) DEFAULT 'active',          -- 默认状态为激活
    user_type VARCHAR(20) DEFAULT 'regular',     -- 默认为普通用户
    
    -- 数字默认值
    balance DECIMAL(10,2) DEFAULT 0.00,          -- 余额默认为0
    points INT DEFAULT 0,                        -- 积分默认为0
    
    -- 时间默认值
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,              -- 创建时间默认为当前时间
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  -- 自动更新时间
    
    -- 布尔默认值
    is_verified BOOLEAN DEFAULT FALSE,           -- 默认未验证
    is_active BOOLEAN DEFAULT TRUE               -- 默认激活状态
);
```

### 6.3 默认值的实际应用


**💡 实用的默认值设置**：

```sql
-- 订单表的智能默认值
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    
    -- 订单状态默认为待付款
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled') 
        DEFAULT 'pending',
    
    -- 订单金额默认为0
    total_amount DECIMAL(10,2) DEFAULT 0.00,
    
    -- 订单编号自动生成（使用函数）
    order_no VARCHAR(50) DEFAULT (CONCAT('ORD', DATE_FORMAT(NOW(), '%Y%m%d'), LPAD(CONNECTION_ID(), 6, '0'))),
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 6.4 默认值的测试验证


**🔍 默认值效果测试**：

```sql
-- 插入数据时不指定有默认值的字段
INSERT INTO user_accounts (username) VALUES ('newuser');

-- 查看插入结果
SELECT * FROM user_accounts WHERE username = 'newuser';

/*
结果显示：
id: 1
username: newuser
status: active          ← 使用了默认值
user_type: regular      ← 使用了默认值  
balance: 0.00          ← 使用了默认值
points: 0              ← 使用了默认值
created_at: 2025-09-01 10:30:15  ← 使用了默认值
is_verified: 0         ← 使用了默认值
is_active: 1           ← 使用了默认值
*/
```

---

## 7. 🔧 约束组合使用实践


### 7.1 实际业务场景建模


**🏢 电商系统约束设计**：

```sql
-- 用户表：综合约束使用
CREATE TABLE users (
    -- 主键：自增ID
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 唯一约束：用户名和邮箱不能重复
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    
    -- 非空约束：重要信息必须填写
    password_hash VARCHAR(255) NOT NULL,
    
    -- 默认值约束：状态和时间信息
    status ENUM('active', 'inactive', 'banned') DEFAULT 'active',
    user_type ENUM('customer', 'admin', 'vip') DEFAULT 'customer',
    
    -- 时间戳约束
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 可选字段
    phone VARCHAR(20) UNIQUE,             -- 手机号唯一但可选
    avatar_url VARCHAR(500),
    last_login TIMESTAMP NULL
);
```

**🛒 订单系统关联约束**：

```sql
-- 商品表
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    product_code VARCHAR(50) NOT NULL UNIQUE,    -- 商品编码唯一
    product_name VARCHAR(200) NOT NULL,
    price DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    stock_quantity INT NOT NULL DEFAULT 0,
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 订单表
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(50) NOT NULL UNIQUE,        -- 订单号唯一
    
    -- 外键约束：关联用户
    user_id INT NOT NULL,
    CONSTRAINT fk_orders_user 
        FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON DELETE RESTRICT,                       -- 不允许删除有订单的用户
    
    -- 订单信息
    total_amount DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled') DEFAULT 'pending',
    
    -- 时间约束
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMP NULL,
    shipped_at TIMESTAMP NULL
);

-- 订单详情表  
CREATE TABLE order_items (
    item_id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 复合外键：关联订单和商品
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    
    CONSTRAINT fk_orderitems_order 
        FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON DELETE CASCADE,                        -- 订单删除时同步删除订单项
        
    CONSTRAINT fk_orderitems_product 
        FOREIGN KEY (product_id) REFERENCES products(product_id)
        ON DELETE RESTRICT,                       -- 不能删除有订单的商品
    
    -- 复合唯一约束：同一订单中同一商品只能有一条记录
    UNIQUE (order_id, product_id),
    
    -- 订单项信息
    quantity INT NOT NULL DEFAULT 1,
    unit_price DECIMAL(10,2) NOT NULL,
    
    -- 约束检查：数量必须大于0（MySQL 8.0支持）
    CHECK (quantity > 0)
);
```

### 7.2 约束配置的最佳实践


**🎯 约束设计原则**：

```markdown
✅ **DO - 应该这样做**
• 主键：每个表必须有主键
• 外键：重要关联关系使用外键
• 唯一：业务唯一性字段加UNIQUE
• 非空：核心业务字段设NOT NULL
• 默认值：常用字段设合理默认值
• 命名：为约束起有意义的名称

❌ **DON'T - 避免这样做**  
• 过度约束：不必要的字段加约束
• 缺少主键：表没有主键标识
• 外键滥用：所有关联都用外键
• 默认值滥用：复杂逻辑不用默认值
• 约束重复：同一逻辑多个约束
```

### 7.3 约束组合使用模式


**🔧 常用约束组合模式**：

```sql
-- 模式1：用户身份表
CREATE TABLE user_identities (
    id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 身份信息：唯一且非空
    id_card VARCHAR(18) NOT NULL UNIQUE COMMENT '身份证号',
    
    -- 用户关联：外键且非空
    user_id INT NOT NULL,
    CONSTRAINT fk_identity_user FOREIGN KEY (user_id) REFERENCES users(user_id),
    
    -- 状态信息：默认值
    verify_status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
    
    -- 时间信息：自动维护
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    verified_at TIMESTAMP NULL
);

-- 模式2：配置参数表
CREATE TABLE system_configs (
    config_key VARCHAR(100) PRIMARY KEY,     -- 配置键作为主键
    config_value TEXT NOT NULL,              -- 配置值非空
    config_type ENUM('string', 'number', 'boolean', 'json') DEFAULT 'string',
    description VARCHAR(500),
    is_active BOOLEAN DEFAULT TRUE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

---

## 8. 🛠️ 约束管理与维护


### 8.1 查看表的约束信息


**🔍 查看约束的方法**：

```sql
-- 方法1：查看表结构
DESC table_name;
SHOW CREATE TABLE table_name;

-- 方法2：查询信息模式（推荐）
-- 查看所有约束
SELECT 
    CONSTRAINT_NAME as '约束名',
    CONSTRAINT_TYPE as '约束类型',
    TABLE_NAME as '表名',
    COLUMN_NAME as '字段名'
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu 
    ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
WHERE tc.TABLE_SCHEMA = 'your_database_name'
ORDER BY tc.TABLE_NAME, tc.CONSTRAINT_TYPE;

-- 查看外键约束详情
SELECT 
    CONSTRAINT_NAME as '外键名',
    TABLE_NAME as '子表',
    COLUMN_NAME as '外键字段',
    REFERENCED_TABLE_NAME as '父表',
    REFERENCED_COLUMN_NAME as '引用字段'
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE CONSTRAINT_SCHEMA = 'your_database_name'
    AND REFERENCED_TABLE_NAME IS NOT NULL;
```

### 8.2 修改和删除约束


**🔧 约束的动态管理**：

```sql
-- 添加约束到已存在的表
ALTER TABLE users ADD CONSTRAINT uk_users_phone UNIQUE (phone);
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;

-- 删除约束
ALTER TABLE users DROP INDEX uk_users_phone;      -- 删除唯一约束
ALTER TABLE users DROP FOREIGN KEY fk_user_class; -- 删除外键约束

-- 修改字段属性（添加/移除NOT NULL）
ALTER TABLE users MODIFY phone VARCHAR(20) NULL;          -- 允许为空
ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL;   -- 设为非空
```

### 8.3 约束错误处理


**⚠️ 常见约束错误及解决方案**：

| 错误类型 | **错误信息** | **原因** | **解决方案** |
|---------|-------------|---------|-------------|
| **主键重复** | `Duplicate entry for key 'PRIMARY'` | 插入重复主键值 | 检查数据，使用AUTO_INCREMENT |
| **外键失败** | `foreign key constraint fails` | 引用不存在的父表记录 | 先插入父表数据 |
| **非空冲突** | `Column cannot be null` | 向非空字段插入NULL | 提供有效值或修改约束 |
| **唯一冲突** | `Duplicate entry for key 'unique_key'` | 插入重复值 | 检查数据唯一性 |

**🔧 错误处理示例**：

```sql
-- 处理外键约束错误
-- 错误：插入不存在的班级ID
INSERT INTO students (name, class_id) VALUES ('新学生', 999);

-- 解决方案1：先创建班级
INSERT INTO classes VALUES (999, '新班级', '新老师');
INSERT INTO students (name, class_id) VALUES ('新学生', 999);

-- 解决方案2：使用已存在的班级ID
INSERT INTO students (name, class_id) VALUES ('新学生', 1);

-- 解决方案3：允许未分班（设为NULL）
INSERT INTO students (name, class_id) VALUES ('新学生', NULL);
```

### 8.4 约束性能影响


**⚡ 约束对性能的影响**：

```
约束检查开销排序：
CHECK约束     ████████████████████ 高开销
FOREIGN KEY   ████████████████ 中等开销  
UNIQUE        ████████████ 中等开销
NOT NULL      ████ 低开销
PRIMARY KEY   ████ 低开销（有索引支持）
DEFAULT       ██ 极低开销
```

> 💡 **性能优化建议**
> 
> - 在数据量大的表上谨慎使用复杂约束
> - 合理设计索引来支持约束检查
> - 批量插入时考虑临时禁用约束检查
> - 定期分析约束的实际使用价值

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基础语法


```sql
-- 约束定义速查表
CREATE TABLE example_table (
    -- 主键约束
    id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 外键约束  
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(id),
    
    -- 唯一约束
    code VARCHAR(50) UNIQUE,
    
    -- 非空约束
    name VARCHAR(100) NOT NULL,
    
    -- 默认值约束
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 9.2 关键理解要点


**🔹 约束的本质作用**
```
数据完整性保障：
- 主键：确保记录可唯一标识
- 外键：确保关联数据存在  
- 唯一：确保业务唯一性
- 非空：确保关键数据完整
- 默认值：提供合理的初始值
```

**🔹 约束使用原则**
```
设计原则：
- 必要性：只在需要的地方使用约束
- 简单性：优先使用简单直接的约束
- 可维护性：为约束起有意义的名称
- 性能性：考虑约束对性能的影响
```

**🔹 约束组合策略**
```
组合建议：
- 主键 + 非空：核心标识字段
- 唯一 + 非空：重要业务字段
- 外键 + 非空：强制关联关系
- 默认值 + 非空：自动填充字段
```

### 9.3 实际应用价值


**💼 业务应用场景**

```markdown
🎯 **用户系统**
• PRIMARY KEY: 用户ID唯一标识
• UNIQUE: 用户名、邮箱不重复
• NOT NULL: 核心信息必填
• DEFAULT: 状态、时间自动设置
• FOREIGN KEY: 关联角色权限

🛒 **订单系统**  
• PRIMARY KEY: 订单ID唯一
• FOREIGN KEY: 关联用户、商品
• NOT NULL: 订单金额、状态必填
• DEFAULT: 订单状态、创建时间
• UNIQUE: 订单号全局唯一

📊 **内容管理**
• PRIMARY KEY: 文章ID
• FOREIGN KEY: 关联作者、分类
• NOT NULL: 标题、内容必填
• DEFAULT: 发布状态、创建时间
• UNIQUE: 文章URL地址
```

**🔧 运维管理要点**

> 📋 **约束管理检查清单**
> 
> - [x] 每个表都有合适的主键
> - [x] 重要关联关系设置外键
> - [x] 业务唯一性字段加UNIQUE约束
> - [x] 核心字段设置NOT NULL
> - [x] 常用字段设置合理默认值
> - [x] 约束命名规范统一
> - [x] 定期检查约束性能影响

**🚀 进阶学习方向**

```
约束技术演进:
基础约束 → 高级约束 → 触发器 → 存储过程
    ↓           ↓         ↓         ↓
  入门必学   进阶学习   高级应用   专家级
```

**核心记忆**：
- 约束是数据质量的守护神，必须合理使用
- 主键保证记录唯一，外键维护表关联
- 唯一约束防重复，非空约束保完整
- 默认值提效率，组合使用见真章
- 约束语法要熟练，实际应用更重要