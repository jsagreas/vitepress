---
title: 28、表级约束与字段约束管理
---
## 📚 目录

1. [数据库约束概述](#1-数据库约束概述)
2. [表级约束定义](#2-表级约束定义)
3. [主键约束PRIMARY KEY详解](#3-主键约束primary-key详解)
4. [外键约束FOREIGN KEY管理](#4-外键约束foreign-key管理)
5. [唯一约束UNIQUE设计](#5-唯一约束unique设计)
6. [检查约束CHECK应用](#6-检查约束check应用)
7. [非空约束NOT NULL处理](#7-非空约束not-null处理)
8. [默认值约束DEFAULT设置](#8-默认值约束default设置)
9. [约束命名规范与管理](#9-约束命名规范与管理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🛡️ 数据库约束概述


### 1.1 什么是数据库约束


**💡 约束的本质**
数据库约束就像是数据的"规则管家"，它确保存入数据库的数据符合业务规则和逻辑要求。

```
生活中的例子：
身份证号码：
- 必须是18位数字（长度约束）
- 不能重复（唯一约束）
- 不能为空（非空约束）
- 最后一位有特定计算规则（检查约束）

MySQL约束就是给数据库字段设置这样的"规则"
```

### 1.2 约束的重要作用


**🎯 核心作用**
- **数据完整性**：保证数据的准确性和一致性
- **业务规则**：将业务逻辑转化为数据库规则
- **错误预防**：在数据录入时就发现问题
- **系统稳定**：避免无效数据导致程序异常

### 1.3 约束分类概览


```
MySQL约束类型大全：

字段级约束：
├── NOT NULL     → 非空约束
├── DEFAULT      → 默认值约束
└── AUTO_INCREMENT → 自增约束

表级约束：
├── PRIMARY KEY  → 主键约束
├── FOREIGN KEY  → 外键约束
├── UNIQUE       → 唯一约束
└── CHECK        → 检查约束
```

---

## 2. 📋 表级约束定义


### 2.1 表级约束与字段级约束的区别


**🔸 字段级约束**
```sql
-- 在字段定义时直接指定约束
CREATE TABLE users (
    id INT NOT NULL,              -- 字段级非空约束
    email VARCHAR(100) UNIQUE,    -- 字段级唯一约束
    age INT DEFAULT 18            -- 字段级默认值约束
);
```

**🔸 表级约束**
```sql
-- 在字段定义完成后单独定义约束
CREATE TABLE users (
    id INT,
    email VARCHAR(100),
    age INT,
    -- 表级约束定义
    PRIMARY KEY (id),                    -- 主键约束
    UNIQUE KEY uk_email (email),         -- 唯一约束
    CHECK (age >= 0 AND age <= 150)      -- 检查约束
);
```

### 2.2 表级约束的优势


**💪 表级约束的特点**
```
灵活性更强：
- 可以跨多个字段定义约束
- 可以给约束指定名称
- 便于后续管理和维护

复合约束支持：
- 复合主键：PRIMARY KEY (field1, field2)
- 复合唯一键：UNIQUE (field1, field2)
- 复杂检查约束：CHECK (field1 > field2)
```

### 2.3 表级约束语法结构


**📝 基本语法格式**
```sql
CREATE TABLE 表名 (
    字段定义...,
    
    -- 表级约束语法
    [CONSTRAINT 约束名] 约束类型 (字段列表) [约束选项]
);

-- 实际示例
CREATE TABLE orders (
    order_id INT,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10,2),
    
    -- 表级约束定义
    CONSTRAINT pk_order PRIMARY KEY (order_id),
    CONSTRAINT fk_customer FOREIGN KEY (customer_id) REFERENCES customers(id),
    CONSTRAINT uk_order_date UNIQUE (customer_id, order_date),
    CONSTRAINT chk_amount CHECK (total_amount > 0)
);
```

---

## 3. 🔑 主键约束PRIMARY KEY详解


### 3.1 主键约束基本概念


**💡 什么是主键**
主键就像是表中每一行数据的"身份证号码"，用来唯一标识每条记录。

```
生活例子：
学生表中的学生学号：
- 每个学生都有唯一的学号
- 通过学号能准确找到某个学生
- 学号不能重复，也不能为空
- 这就是主键的作用
```

**🔸 主键的特性**
```
唯一性：主键值在表中必须唯一
非空性：主键字段不能为NULL
不可变性：主键值一旦确定，不应该随意修改
最小性：主键应该使用最少的字段
```

### 3.2 单字段主键


**🔸 语法格式**
```sql
-- 方式1：字段级定义
CREATE TABLE users (
    id INT PRIMARY KEY,           -- 直接在字段后指定
    username VARCHAR(50),
    email VARCHAR(100)
);

-- 方式2：表级定义
CREATE TABLE users (
    id INT,
    username VARCHAR(50),
    email VARCHAR(100),
    PRIMARY KEY (id)              -- 表级主键定义
);

-- 方式3：带约束名的表级定义
CREATE TABLE users (
    id INT,
    username VARCHAR(50),
    email VARCHAR(100),
    CONSTRAINT pk_users_id PRIMARY KEY (id)
);
```

### 3.3 复合主键


**🔸 什么是复合主键**
复合主键是由多个字段组合而成的主键，适用于单个字段无法唯一标识记录的情况。

```sql
-- 订单详情表示例
CREATE TABLE order_details (
    order_id INT,                 -- 订单ID
    product_id INT,               -- 商品ID  
    quantity INT,                 -- 数量
    price DECIMAL(10,2),          -- 单价
    
    -- 复合主键：订单ID + 商品ID 组合唯一
    PRIMARY KEY (order_id, product_id)
);

-- 业务含义：同一个订单中，每个商品只能有一条记录
```

**🔸 复合主键的应用场景**
```
学生选课表：
- 学生ID + 课程ID = 主键
- 同一学生不能重复选同一门课

销售记录表：  
- 销售员ID + 日期 = 主键
- 每个销售员每天只有一条汇总记录

日志表：
- 用户ID + 时间戳 = 主键
- 确保记录的唯一性
```

### 3.4 主键选择策略


**🎯 主键选择原则**
```
业务主键 vs 代理主键：

业务主键：使用有业务含义的字段
- 优点：有业务含义，便于理解
- 缺点：可能会变化，影响稳定性
- 示例：身份证号、商品编码

代理主键：使用无业务含义的字段  
- 优点：稳定不变，性能好
- 缺点：需要额外的存储空间
- 示例：自增ID、UUID
```

**💻 实际应用建议**
```sql
-- 推荐方式：代理主键 + 业务唯一键
CREATE TABLE customers (
    id INT AUTO_INCREMENT,              -- 代理主键，系统自动生成
    customer_code VARCHAR(20) NOT NULL, -- 业务编码
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    
    PRIMARY KEY (id),                   -- 代理主键
    UNIQUE KEY uk_customer_code (customer_code)  -- 业务唯一键
);
```

### 3.5 主键约束管理


**🔧 添加和删除主键**
```sql
-- 为已存在的表添加主键
ALTER TABLE users ADD PRIMARY KEY (id);

-- 删除主键约束
ALTER TABLE users DROP PRIMARY KEY;

-- 修改主键（需要先删除再添加）
ALTER TABLE users DROP PRIMARY KEY;
ALTER TABLE users ADD PRIMARY KEY (new_id);
```

**⚠️ 主键约束注意事项**
```
重要提醒：
1. 一个表只能有一个主键
2. 主键字段不能为NULL
3. 删除主键前要确保没有外键引用
4. 主键删除会同时删除对应的索引
5. AUTO_INCREMENT字段通常需要是主键
```

---

## 4. 🔗 外键约束FOREIGN KEY管理


### 4.1 外键约束基本概念


**💡 什么是外键**
外键就像是表与表之间的"关系线"，它确保表之间的数据保持一致性。

```
生活例子：
学生表 和 班级表：
- 学生表中的班级ID必须在班级表中存在
- 不能给学生分配一个不存在的班级
- 删除班级前，必须先处理该班级的所有学生
- 这种关系就是外键约束
```

### 4.2 外键约束语法


**🔸 创建外键约束**
```sql
-- 方式1：创建表时定义外键
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    
    -- 外键约束定义
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 方式2：带约束名的外键定义
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    
    CONSTRAINT fk_orders_customer 
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 方式3：为已存在的表添加外键
ALTER TABLE orders 
ADD CONSTRAINT fk_orders_customer 
FOREIGN KEY (customer_id) REFERENCES customers(id);
```

### 4.3 外键约束选项


**🔧 引用动作设置**
外键约束可以设置当父表数据发生变化时，子表应该如何响应：

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    
    CONSTRAINT fk_orders_customer 
    FOREIGN KEY (customer_id) REFERENCES customers(id)
    ON DELETE CASCADE      -- 删除动作
    ON UPDATE CASCADE      -- 更新动作
);
```

**📊 引用动作类型对比**

| 动作类型 | **ON DELETE** | **ON UPDATE** | **说明** |
|---------|---------------|---------------|----------|
| **CASCADE** | 删除父记录时，删除所有子记录 | 更新父记录时，更新所有子记录 | 级联操作 |
| **SET NULL** | 删除父记录时，子记录外键设为NULL | 更新父记录时，子记录外键设为NULL | 置空操作 |
| **RESTRICT** | 如果有子记录，禁止删除父记录 | 如果有子记录，禁止更新父记录 | 严格限制 |
| **NO ACTION** | 同RESTRICT | 同RESTRICT | 默认行为 |

### 4.4 外键约束实际应用


**🏪 电商系统示例**
```sql
-- 客户表
CREATE TABLE customers (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100)
);

-- 订单表
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'completed'),
    
    -- 外键约束：确保客户存在
    CONSTRAINT fk_orders_customer 
    FOREIGN KEY (customer_id) REFERENCES customers(id)
    ON DELETE RESTRICT     -- 客户有订单时不能删除
    ON UPDATE CASCADE      -- 客户ID更新时，订单中的customer_id同步更新
);

-- 订单详情表
CREATE TABLE order_items (
    order_id INT,
    product_id INT, 
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    
    PRIMARY KEY (order_id, product_id),
    
    -- 外键约束：确保订单存在
    CONSTRAINT fk_items_order
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
    ON DELETE CASCADE,     -- 删除订单时，删除所有订单项
    
    -- 外键约束：确保商品存在
    CONSTRAINT fk_items_product
    FOREIGN KEY (product_id) REFERENCES products(id)
    ON DELETE RESTRICT     -- 商品被订购后不能删除
);
```

### 4.5 外键约束管理


**🔧 外键约束操作**
```sql
-- 查看表的外键约束
SHOW CREATE TABLE orders;

-- 查看外键约束详细信息
SELECT 
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME,
    DELETE_RULE,
    UPDATE_RULE
FROM information_schema.KEY_COLUMN_USAGE
WHERE REFERENCED_TABLE_NAME IS NOT NULL
AND TABLE_SCHEMA = 'your_database';

-- 删除外键约束
ALTER TABLE orders DROP FOREIGN KEY fk_orders_customer;

-- 临时禁用外键检查（数据导入时常用）
SET FOREIGN_KEY_CHECKS = 0;
-- 执行数据操作
SET FOREIGN_KEY_CHECKS = 1;
```

---

## 5. 🔒 唯一约束UNIQUE设计


### 5.1 唯一约束基本概念


**💡 什么是唯一约束**
唯一约束确保指定字段（或字段组合）的值在整个表中不重复，但允许为NULL。

```
简单理解：
邮箱地址：
- 每个用户的邮箱必须不同
- 但可以选择不填写邮箱（NULL）
- 这就是唯一约束的特点：唯一但可空
```

### 5.2 单字段唯一约束


**🔸 创建方式**
```sql
-- 方式1：字段级定义
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,      -- 字段级唯一约束
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20)
);

-- 方式2：表级定义
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    
    UNIQUE KEY uk_username (username),    -- 表级唯一约束
    UNIQUE KEY uk_email (email)
);

-- 方式3：后期添加
ALTER TABLE users ADD UNIQUE KEY uk_phone (phone);
```

### 5.3 复合唯一约束


**🔸 多字段组合唯一**
复合唯一约束要求多个字段的组合值不能重复，但单个字段可以重复。

```sql
-- 课程选择表
CREATE TABLE student_courses (
    id INT AUTO_INCREMENT PRIMARY KEY,
    student_id INT,
    course_id INT,
    semester VARCHAR(20),
    grade DECIMAL(3,1),
    
    -- 复合唯一约束：同一学期，学生不能重复选同一门课
    UNIQUE KEY uk_student_course_semester (student_id, course_id, semester)
);

-- 数据示例
INSERT INTO student_courses VALUES 
(1, 1001, 2001, '2024-spring', 85.5),   -- ✓ 可以插入
(2, 1001, 2002, '2024-spring', 90.0),   -- ✓ 不同课程，可以插入
(3, 1001, 2001, '2024-fall', 88.0),     -- ✓ 不同学期，可以插入
(4, 1001, 2001, '2024-spring', 92.0);   -- ❌ 重复组合，插入失败
```

### 5.4 唯一约束与NULL值


**🔸 NULL值的特殊处理**
```sql
-- 唯一约束对NULL的处理规则
CREATE TABLE test_unique (
    id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE
);

-- NULL值插入测试
INSERT INTO test_unique VALUES (1, 'user1@example.com');  -- ✓ 正常
INSERT INTO test_unique VALUES (2, 'user1@example.com');  -- ❌ 违反唯一约束
INSERT INTO test_unique VALUES (3, NULL);                 -- ✓ NULL可以插入
INSERT INTO test_unique VALUES (4, NULL);                 -- ✓ 多个NULL可以插入

-- 结果：多个NULL值是被允许的
```

**💡 NULL值处理策略**
```
业务场景分析：

允许NULL的情况：
- 手机号码：用户可以选择不填写
- 个人网站：不是所有用户都有
- 微信号：非必填信息

不允许NULL的情况：
- 身份证号：法律要求必须有
- 员工工号：公司管理必需
- 用户邮箱：系统登录必需

解决方案：NOT NULL + UNIQUE组合使用
```

### 5.5 唯一约束管理


**🔧 约束管理操作**
```sql
-- 查看表的唯一约束
SHOW INDEX FROM users WHERE Non_unique = 0;

-- 删除唯一约束
ALTER TABLE users DROP INDEX uk_email;

-- 添加唯一约束
ALTER TABLE users ADD UNIQUE KEY uk_phone (phone);

-- 修改唯一约束（先删除再添加）
ALTER TABLE users DROP INDEX uk_email;
ALTER TABLE users ADD UNIQUE KEY uk_email_new (email);
```

---

## 6. ✅ 检查约束CHECK应用


### 6.1 检查约束基本概念


**💡 什么是检查约束**
检查约束允许你为字段设置自定义的验证规则，确保数据符合特定的业务逻辑。

```
生活例子：
年龄字段的验证：
- 年龄必须大于0
- 年龄不能超过150岁
- 入学年龄必须大于等于6岁
- 这些业务规则就可以用检查约束实现
```

### 6.2 检查约束语法


**🔸 基本语法格式**
```sql
-- 表级检查约束
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    age INT,
    salary DECIMAL(10,2),
    hire_date DATE,
    
    -- 检查约束定义
    CONSTRAINT chk_age CHECK (age >= 18 AND age <= 65),
    CONSTRAINT chk_salary CHECK (salary > 0),
    CONSTRAINT chk_hire_date CHECK (hire_date >= '2000-01-01')
);

-- 字段级检查约束（MySQL 8.0.16+）
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2) CHECK (price > 0),     -- 字段级检查约束
    stock INT CHECK (stock >= 0)
);
```

### 6.3 检查约束实际应用


**🎯 常见业务场景**
```sql
-- 用户注册表
CREATE TABLE user_registration (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    password VARCHAR(255) NOT NULL,
    age INT,
    gender ENUM('M', 'F', 'Other'),
    email VARCHAR(100),
    registration_date DATE,
    
    -- 用户名长度检查
    CONSTRAINT chk_username_length CHECK (CHAR_LENGTH(username) >= 3),
    
    -- 年龄范围检查
    CONSTRAINT chk_age_range CHECK (age >= 13 AND age <= 120),
    
    -- 邮箱格式简单检查
    CONSTRAINT chk_email_format CHECK (email LIKE '%@%'),
    
    -- 注册日期检查
    CONSTRAINT chk_registration_date CHECK (registration_date <= CURDATE())
);
```

**💰 财务相关检查约束**
```sql
-- 订单表
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    total_amount DECIMAL(12,2),
    discount_rate DECIMAL(3,2),
    order_status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled'),
    order_date DATE,
    
    -- 金额检查：订单总额必须大于0
    CONSTRAINT chk_total_amount CHECK (total_amount > 0),
    
    -- 折扣率检查：折扣率在0-1之间
    CONSTRAINT chk_discount_rate CHECK (discount_rate >= 0 AND discount_rate <= 1),
    
    -- 日期检查：订单日期不能是未来
    CONSTRAINT chk_order_date CHECK (order_date <= CURDATE()),
    
    -- 状态逻辑检查
    CONSTRAINT chk_status_logic CHECK (
        (order_status = 'cancelled' AND total_amount = 0) OR 
        (order_status != 'cancelled' AND total_amount > 0)
    )
);
```

### 6.4 复杂检查约束


**🔍 跨字段检查约束**
```sql
-- 员工表：入职和离职日期的逻辑检查
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    hire_date DATE NOT NULL,
    termination_date DATE,
    salary DECIMAL(10,2),
    department_id INT,
    
    -- 离职日期必须晚于入职日期
    CONSTRAINT chk_employment_dates 
    CHECK (termination_date IS NULL OR termination_date > hire_date),
    
    -- 工资范围检查
    CONSTRAINT chk_salary_range 
    CHECK (salary >= 3000 AND salary <= 100000),
    
    -- 入职日期不能是未来
    CONSTRAINT chk_hire_date 
    CHECK (hire_date <= CURDATE())
);
```

**📊 数据一致性检查**
```sql
-- 库存表：出入库数量的逻辑检查
CREATE TABLE inventory_transactions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT,
    transaction_type ENUM('in', 'out'),
    quantity INT,
    transaction_date DATE,
    
    -- 入库数量必须为正，出库数量必须为正
    CONSTRAINT chk_quantity_positive CHECK (quantity > 0),
    
    -- 根据交易类型检查数量逻辑
    CONSTRAINT chk_transaction_logic CHECK (
        (transaction_type = 'in' AND quantity > 0) OR
        (transaction_type = 'out' AND quantity > 0)
    ),
    
    -- 交易日期检查
    CONSTRAINT chk_transaction_date CHECK (
        transaction_date >= '2020-01-01' AND 
        transaction_date <= CURDATE()
    )
);
```

### 6.5 检查约束管理


**🔧 约束操作管理**
```sql
-- 查看表的检查约束
SELECT 
    CONSTRAINT_NAME,
    CHECK_CLAUSE
FROM information_schema.CHECK_CONSTRAINTS
WHERE CONSTRAINT_SCHEMA = 'your_database'
AND TABLE_NAME = 'your_table';

-- 删除检查约束
ALTER TABLE employees DROP CHECK chk_age_range;

-- 添加检查约束
ALTER TABLE employees 
ADD CONSTRAINT chk_salary_positive CHECK (salary > 0);

-- 临时禁用检查约束（MySQL 8.0.19+）
ALTER TABLE employees ALTER CHECK chk_age_range NOT ENFORCED;

-- 重新启用检查约束
ALTER TABLE employees ALTER CHECK chk_age_range ENFORCED;
```

---

## 7. 🚫 非空约束NOT NULL处理


### 7.1 非空约束基本概念


**💡 什么是非空约束**
非空约束确保字段不能存储NULL值，这是最基础也是最重要的数据完整性约束。

```
生活例子：
用户注册时的必填项：
- 用户名：必须填写，不能为空
- 密码：必须设置，不能为空  
- 邮箱：必须提供，用于找回密码
- 年龄：可以不填（NULL）

在数据库中，必填项就用NOT NULL约束
```

### 7.2 非空约束语法


**🔸 创建非空约束**
```sql
-- 创建表时定义非空约束
CREATE TABLE users (
    id INT NOT NULL,                    -- 非空约束
    username VARCHAR(50) NOT NULL,      -- 用户名必填
    password VARCHAR(255) NOT NULL,     -- 密码必填
    email VARCHAR(100) NOT NULL,        -- 邮箱必填
    phone VARCHAR(20),                  -- 手机号可选（允许NULL）
    age INT,                           -- 年龄可选
    
    PRIMARY KEY (id)
);

-- 为已存在的字段添加非空约束
ALTER TABLE users MODIFY username VARCHAR(50) NOT NULL;

-- 删除非空约束（改为允许NULL）
ALTER TABLE users MODIFY phone VARCHAR(20) NULL;
```

### 7.3 非空约束与默认值结合


**🔸 NOT NULL + DEFAULT组合**
```sql
-- 合理的字段设计
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,              -- 标题必填
    content TEXT NOT NULL,                    -- 内容必填
    author_id INT NOT NULL,                   -- 作者必填
    status ENUM('draft', 'published', 'archived') NOT NULL DEFAULT 'draft',  -- 状态有默认值
    view_count INT NOT NULL DEFAULT 0,        -- 浏览数默认为0
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,  -- 创建时间自动设置
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**💡 设计原则**
```
字段设计建议：

核心业务字段：NOT NULL
- 用户ID、订单号、商品名称等
- 这些字段为空会导致业务逻辑错误

可选辅助字段：允许NULL  
- 用户头像、个人简介、备注等
- 这些字段为空不影响核心功能

有默认值的字段：NOT NULL + DEFAULT
- 状态字段、计数字段、时间戳等
- 既保证不为空，又提供合理默认值
```

### 7.4 非空约束实际应用


**🏢 企业级表设计示例**
```sql
-- 员工表
CREATE TABLE employees (
    employee_id INT AUTO_INCREMENT PRIMARY KEY,
    employee_no VARCHAR(20) NOT NULL,          -- 工号必填
    first_name VARCHAR(50) NOT NULL,           -- 名字必填
    last_name VARCHAR(50) NOT NULL,            -- 姓氏必填
    email VARCHAR(100) NOT NULL,               -- 邮箱必填
    phone VARCHAR(20),                         -- 电话可选
    hire_date DATE NOT NULL,                   -- 入职日期必填
    department_id INT NOT NULL,                -- 部门必填
    salary DECIMAL(10,2) NOT NULL,             -- 工资必填
    status ENUM('active', 'inactive', 'terminated') NOT NULL DEFAULT 'active',
    
    -- 确保关键字段组合唯一
    UNIQUE KEY uk_employee_no (employee_no),
    UNIQUE KEY uk_email (email)
);
```

### 7.5 非空约束注意事项


**⚠️ 重要注意点**
```sql
-- 1. 添加非空约束前要检查现有数据
-- 如果表中已有NULL值，添加NOT NULL会失败
SELECT COUNT(*) FROM users WHERE email IS NULL;
-- 如果有NULL值，需要先处理

-- 2. 空字符串不等于NULL
INSERT INTO users (username) VALUES ('');     -- ✓ 空字符串可以插入
INSERT INTO users (username) VALUES (NULL);   -- ❌ NULL不能插入

-- 3. 默认值可以避免NOT NULL的插入问题
CREATE TABLE logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    message TEXT NOT NULL DEFAULT '',          -- 空字符串作为默认值
    level ENUM('info', 'warning', 'error') NOT NULL DEFAULT 'info',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

---

## 8. 🔧 默认值约束DEFAULT设置


### 8.1 默认值约束基本概念


**💡 什么是默认值约束**
默认值约束为字段提供一个预设值，当插入数据时没有明确指定该字段的值时，系统自动使用默认值。

```
生活例子：
APP设置中的默认选项：
- 语言设置：默认为中文
- 主题模式：默认为浅色模式
- 消息提醒：默认开启
- 用户不设置时，系统使用这些默认值
```

### 8.2 静态默认值


**🔸 常量默认值**
```sql
-- 静态默认值示例
CREATE TABLE user_settings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    language VARCHAR(10) DEFAULT 'zh_CN',      -- 默认中文
    theme VARCHAR(20) DEFAULT 'light',         -- 默认浅色主题
    notifications BOOLEAN DEFAULT TRUE,        -- 默认开启通知
    max_login_attempts INT DEFAULT 5,          -- 默认最大登录尝试次数
    account_status ENUM('active', 'inactive', 'suspended') DEFAULT 'active'
);

-- 插入数据时的默认值应用
INSERT INTO user_settings (user_id) VALUES (1001);
-- 结果：language='zh_CN', theme='light', notifications=TRUE 等都使用默认值

INSERT INTO user_settings (user_id, language, theme) VALUES (1002, 'en_US', 'dark');
-- 结果：language='en_US', theme='dark'（明确指定），notifications=TRUE（使用默认值）
```

### 8.3 动态默认值


**🔸 函数默认值**
MySQL支持使用函数作为默认值，特别适用于时间戳字段：

```sql
-- 时间相关的动态默认值
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT,
    author_id INT NOT NULL,
    
    -- 创建时间：插入时自动设置为当前时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 更新时间：插入时设为当前时间，更新时自动更新
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 发布日期：默认为当前日期
    publish_date DATE DEFAULT (CURDATE()),
    
    -- 状态：默认为草稿
    status ENUM('draft', 'published', 'archived') DEFAULT 'draft'
);
```

**🔸 表达式默认值（MySQL 8.0+）**
```sql
-- 使用表达式作为默认值
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(50) DEFAULT (CONCAT('ORD', YEAR(NOW()), LPAD(MONTH(NOW()),2,'0'), LPAD(DAY(NOW()),2,'0'))),
    customer_id INT NOT NULL,
    order_amount DECIMAL(10,2),
    tax_rate DECIMAL(3,2) DEFAULT 0.13,       -- 默认税率13%
    tax_amount DECIMAL(10,2) GENERATED ALWAYS AS (order_amount * tax_rate),  -- 计算字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 8.4 默认值的数据类型


**📊 不同类型的默认值**

| 数据类型 | **默认值示例** | **说明** |
|----------|---------------|----------|
| **INT** | `DEFAULT 0` | 数字默认值 |
| **VARCHAR** | `DEFAULT ''` | 空字符串默认值 |
| **BOOLEAN** | `DEFAULT TRUE` | 布尔默认值 |
| **DATE** | `DEFAULT (CURDATE())` | 当前日期 |
| **TIMESTAMP** | `DEFAULT CURRENT_TIMESTAMP` | 当前时间戳 |
| **ENUM** | `DEFAULT 'active'` | 枚举值之一 |
| **DECIMAL** | `DEFAULT 0.00` | 小数默认值 |

### 8.5 默认值约束管理


**🔧 默认值操作**
```sql
-- 查看表的默认值设置
DESCRIBE users;
-- 或者
SHOW CREATE TABLE users;

-- 修改字段的默认值
ALTER TABLE users ALTER COLUMN status SET DEFAULT 'inactive';

-- 删除字段的默认值
ALTER TABLE users ALTER COLUMN status DROP DEFAULT;

-- 为已存在字段添加默认值
ALTER TABLE users MODIFY COLUMN age INT DEFAULT 18;
```

### 8.6 默认值最佳实践


**🎯 设计建议**
```sql
-- 推荐的默认值设计模式
CREATE TABLE best_practice_table (
    id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 业务字段：重要字段不设默认值，强制用户填写
    name VARCHAR(100) NOT NULL,              -- 无默认值，必须填写
    email VARCHAR(100) NOT NULL,             -- 无默认值，必须填写
    
    -- 状态字段：设置合理的初始状态
    status ENUM('active', 'inactive', 'pending') NOT NULL DEFAULT 'pending',
    
    -- 计数字段：从0开始
    login_count INT NOT NULL DEFAULT 0,
    view_count INT NOT NULL DEFAULT 0,
    
    -- 标识字段：布尔值有明确默认值
    is_verified BOOLEAN NOT NULL DEFAULT FALSE,
    is_admin BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- 时间字段：自动记录操作时间
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 可选字段：允许NULL，不设默认值
    description TEXT,                        -- 描述信息可为空
    avatar_url VARCHAR(255),                 -- 头像URL可为空
    last_login_at TIMESTAMP NULL             -- 最后登录时间可为空
);
```

---

## 9. 📝 约束命名规范与管理


### 9.1 约束命名规范


**💡 为什么要规范命名**
给约束起一个有意义的名字，就像给文件起名字一样，便于后续的查找、修改和维护。

```
无名约束的问题：
MySQL自动生成的约束名：
- PRIMARY: 主键约束名固定
- email: 唯一约束用字段名
- employees_ibfk_1: 外键约束自动编号

问题：难以理解约束的作用和关系
```

### 9.2 约束命名标准


**📋 推荐命名规范**
```sql
-- 约束命名规范
主键约束：pk_表名
外键约束：fk_表名_引用表名
唯一约束：uk_表名_字段名
检查约束：chk_表名_验证内容
索引约束：idx_表名_字段名

-- 实际应用示例
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT,
    customer_id INT NOT NULL,
    product_id INT NOT NULL,
    order_date DATE NOT NULL,
    quantity INT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped') NOT NULL DEFAULT 'pending',
    
    -- 规范的约束命名
    CONSTRAINT pk_orders PRIMARY KEY (order_id),
    CONSTRAINT fk_orders_customers FOREIGN KEY (customer_id) REFERENCES customers(id),
    CONSTRAINT fk_orders_products FOREIGN KEY (product_id) REFERENCES products(id),
    CONSTRAINT uk_orders_customer_date UNIQUE (customer_id, order_date),
    CONSTRAINT chk_orders_quantity CHECK (quantity > 0),
    CONSTRAINT chk_orders_amount CHECK (total_amount > 0)
);
```

### 9.3 约束信息查询


**🔍 系统约束查询**
```sql
-- 查看表的所有约束信息
SELECT 
    CONSTRAINT_NAME as '约束名',
    CONSTRAINT_TYPE as '约束类型',
    TABLE_NAME as '表名',
    COLUMN_NAME as '字段名'
FROM information_schema.TABLE_CONSTRAINTS tc
LEFT JOIN information_schema.KEY_COLUMN_USAGE kcu 
    ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
WHERE tc.TABLE_SCHEMA = 'your_database'
AND tc.TABLE_NAME = 'orders'
ORDER BY tc.CONSTRAINT_TYPE, tc.CONSTRAINT_NAME;

-- 查看外键约束详情
SELECT 
    CONSTRAINT_NAME as '外键名',
    TABLE_NAME as '子表',
    COLUMN_NAME as '外键字段',
    REFERENCED_TABLE_NAME as '父表', 
    REFERENCED_COLUMN_NAME as '主键字段',
    DELETE_RULE as '删除规则',
    UPDATE_RULE as '更新规则'
FROM information_schema.REFERENTIAL_CONSTRAINTS rc
JOIN information_schema.KEY_COLUMN_USAGE kcu 
    ON rc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
WHERE rc.CONSTRAINT_SCHEMA = 'your_database';
```

### 9.4 约束管理操作


**🔧 约束的增删改操作**
```sql
-- 添加约束（推荐带名称）
ALTER TABLE users 
ADD CONSTRAINT uk_users_email UNIQUE (email);

ALTER TABLE orders 
ADD CONSTRAINT fk_orders_customers 
FOREIGN KEY (customer_id) REFERENCES customers(id);

ALTER TABLE products 
ADD CONSTRAINT chk_products_price CHECK (price > 0);

-- 删除约束
ALTER TABLE users DROP INDEX uk_users_email;           -- 删除唯一约束
ALTER TABLE orders DROP FOREIGN KEY fk_orders_customers; -- 删除外键约束
ALTER TABLE products DROP CHECK chk_products_price;     -- 删除检查约束

-- 修改约束（先删除再添加）
ALTER TABLE users DROP INDEX uk_users_email;
ALTER TABLE users ADD CONSTRAINT uk_users_email_new UNIQUE (email);
```

### 9.5 约束管理工具脚本


**🛠️ 实用管理脚本**
```sql
-- 生成删除所有外键约束的SQL
SELECT 
    CONCAT('ALTER TABLE ', TABLE_NAME, ' DROP FOREIGN KEY ', CONSTRAINT_NAME, ';') as drop_fk_sql
FROM information_schema.TABLE_CONSTRAINTS
WHERE CONSTRAINT_TYPE = 'FOREIGN KEY'
AND TABLE_SCHEMA = 'your_database';

-- 生成重建所有外键约束的SQL  
SELECT 
    CONCAT(
        'ALTER TABLE ', kcu.TABLE_NAME, 
        ' ADD CONSTRAINT ', kcu.CONSTRAINT_NAME,
        ' FOREIGN KEY (', kcu.COLUMN_NAME, ')',
        ' REFERENCES ', kcu.REFERENCED_TABLE_NAME, '(', kcu.REFERENCED_COLUMN_NAME, ')',
        ' ON DELETE ', rc.DELETE_RULE,
        ' ON UPDATE ', rc.UPDATE_RULE, ';'
    ) as create_fk_sql
FROM information_schema.KEY_COLUMN_USAGE kcu
JOIN information_schema.REFERENTIAL_CONSTRAINTS rc 
    ON kcu.CONSTRAINT_NAME = rc.CONSTRAINT_NAME
WHERE kcu.TABLE_SCHEMA = 'your_database'
AND kcu.REFERENCED_TABLE_NAME IS NOT NULL;
```

### 9.6 约束管理最佳实践


**📋 管理建议**
```
约束设计原则：

1. 命名规范统一
   - 团队内部统一约束命名规范
   - 便于理解和维护

2. 文档记录完整
   - 记录每个约束的业务含义
   - 说明约束之间的依赖关系

3. 版本控制管理
   - 约束变更要记录在数据库版本脚本中
   - 便于数据库结构的版本管理

4. 性能影响考虑
   - 过多约束会影响插入和更新性能
   - 在数据完整性和性能间找平衡

5. 环境同步
   - 开发、测试、生产环境约束保持一致
   - 避免环境差异导致的问题
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的约束类型


**🔸 约束体系全览**
```
表级约束：
✓ PRIMARY KEY - 主键约束（唯一标识）
✓ FOREIGN KEY - 外键约束（关系完整性）
✓ UNIQUE - 唯一约束（值不重复）
✓ CHECK - 检查约束（业务规则验证）

字段级约束：
✓ NOT NULL - 非空约束（必填验证）
✓ DEFAULT - 默认值约束（自动填充）
✓ AUTO_INCREMENT - 自增约束（自动编号）
```

### 10.2 约束设计原则


**🎯 核心设计思路**
```
数据完整性保障：
- 实体完整性：主键约束保证记录唯一性
- 参照完整性：外键约束保证关系正确性  
- 域完整性：检查约束保证字段值合理性
- 用户定义完整性：结合业务规则设计约束

约束粒度控制：
- 必要约束：核心业务规则必须有约束
- 适度约束：不要过度设计，影响性能
- 灵活约束：考虑业务变化，留有余地
```

### 10.3 实用操作技能


**🛠️ 约束管理命令**
```sql
-- 查看约束
SHOW CREATE TABLE table_name;
DESCRIBE table_name;
SELECT * FROM information_schema.TABLE_CONSTRAINTS;

-- 添加约束
ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition;

-- 删除约束  
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
ALTER TABLE table_name DROP FOREIGN KEY constraint_name;
ALTER TABLE table_name DROP INDEX constraint_name;

-- 修改约束
-- （先删除再添加）
```

### 10.4 性能与安全平衡


**⚖️ 约束的双面性**
```
积极作用：
✓ 保证数据质量和一致性
✓ 预防无效数据导致的业务问题
✓ 提供数据库层面的安全保障
✓ 简化应用程序的验证逻辑

性能影响：
- 插入数据时需要验证约束，增加耗时
- 外键约束会影响删除和更新操作
- 过多约束可能影响批量数据操作
- 需要在数据质量和性能间找平衡
```

### 10.5 故障排除指南


**🔍 常见约束问题**
```
主键冲突：
错误：Duplicate entry 'xxx' for key 'PRIMARY'
解决：检查是否有重复值，使用AUTO_INCREMENT或UUID

外键约束失败：
错误：Cannot add or update a child row: a foreign key constraint fails
解决：检查引用的父表记录是否存在

检查约束失败：
错误：Check constraint 'chk_xxx' is violated
解决：检查插入的数据是否符合约束条件

非空约束失败：
错误：Column 'xxx' cannot be null  
解决：为必填字段提供值或设置默认值
```

**⚠️ 约束管理注意事项**
```
生产环境约束变更：
✓ 在业务低峰期操作
✓ 先在测试环境验证
✓ 备份数据和表结构
✓ 准备回滚方案
✓ 通知相关开发人员

数据迁移时的约束处理：
✓ 临时禁用外键检查：SET FOREIGN_KEY_CHECKS=0
✓ 导入完成后重新启用：SET FOREIGN_KEY_CHECKS=1  
✓ 验证数据完整性
✓ 检查约束是否正常工作
```

**核心记忆**：
- 约束是数据库的"质量管家"，保证数据的正确性和一致性
- 不同约束有不同用途，要根据业务需求合理选择
- 约束命名规范化，便于团队协作和后期维护
- 在数据完整性和系统性能之间要找到合适的平衡点