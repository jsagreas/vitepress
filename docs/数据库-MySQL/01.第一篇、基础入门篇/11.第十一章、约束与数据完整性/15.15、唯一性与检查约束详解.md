---
title: 15、唯一性与检查约束详解
---
##  📚 目录

1. [唯一性约束基础概念](#1-唯一性约束基础概念)
2. [UNIQUE约束实现机制](#2-UNIQUE约束实现机制)
3. [NULL值与唯一性规则](#3-NULL值与唯一性规则)
4. [复合唯一约束详解](#4-复合唯一约束详解)
5. [唯一约束性能优化](#5-唯一约束性能优化)
6. [唯一冲突处理策略](#6-唯一冲突处理策略)
7. [高级唯一约束技巧](#7-高级唯一约束技巧)
8. [核心要点总结](#8-核心要点总结)

---

##  1. 🎯 唯一性约束基础概念


## # 1.1 什么是唯一性约束


**🔸 通俗理解**
唯一性约束就像身份证号码，在整个数据库表中必须是独一无二的：
- **身份证号**：每个人只能有一个，不能重复
- **邮箱地址**：每个用户的邮箱不能相同
- **商品编码**：每个商品的SKU编码必须唯一

> 💡 **核心概念**  
> 唯一性约束确保表中指定列（或列组合）的值在整个表中不重复，但允许NULL值的存在。

## # 1.2 唯一约束 vs 主键约束


**🔸 关键区别对比**

| 特性 | **唯一约束 UNIQUE** | **主键约束 PRIMARY KEY** |
|------|-------------------|------------------------|
| 🔢 **数量限制** | `一个表可以有多个` | `一个表只能有一个` |
| 🚫 **NULL值** | `允许NULL值` | `不允许NULL值` |
| 🏷️ **标识作用** | `业务唯一性保证` | `记录唯一标识符` |
| 🔍 **索引创建** | `自动创建唯一索引` | `自动创建主键索引` |
| 🔗 **外键引用** | `可以被外键引用` | `常被外键引用` |

```sql
-- 示例对比
CREATE TABLE users (
    id INT PRIMARY KEY,        -- 主键：不允许NULL，全表唯一
    email VARCHAR(100) UNIQUE, -- 唯一约束：允许NULL，但不允许重复
    phone VARCHAR(20) UNIQUE   -- 可以有多个唯一约束
);
```

## # 1.3 唯一性约束的作用


**🔸 数据完整性保障**
- **防止重复数据**：避免业务逻辑错误
- **维护数据一致性**：确保关键业务字段的唯一性
- **支持业务规则**：实现业务层面的约束要求

**🔸 实际应用场景**

```sql
-- 用户管理系统
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,    -- 用户名不能重复
    email VARCHAR(100) UNIQUE,      -- 邮箱不能重复  
    phone VARCHAR(20) UNIQUE,       -- 手机号不能重复
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 商品管理系统
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    sku_code VARCHAR(50) UNIQUE,    -- SKU编码唯一
    barcode VARCHAR(100) UNIQUE,    -- 商品条码唯一
    product_name VARCHAR(200),
    price DECIMAL(10,2)
);
```

---

##  2. ⚙️ UNIQUE约束实现机制


## # 2.1 UNIQUE约束的创建方式


**🔸 表创建时定义约束**

```sql
-- 方式1：列级约束定义
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_code VARCHAR(20) UNIQUE,    -- 列级唯一约束
    email VARCHAR(100) UNIQUE,
    name VARCHAR(100)
);

-- 方式2：表级约束定义  
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_code VARCHAR(20),
    email VARCHAR(100),
    name VARCHAR(100),
    UNIQUE (emp_code),              -- 表级唯一约束
    UNIQUE (email)
);

-- 方式3：命名约束定义
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_code VARCHAR(20),
    email VARCHAR(100),
    name VARCHAR(100),
    CONSTRAINT uk_emp_code UNIQUE (emp_code),    -- 自定义约束名
    CONSTRAINT uk_email UNIQUE (email)
);
```

**🔸 表创建后添加约束**

```sql
-- 添加唯一约束
ALTER TABLE employees ADD UNIQUE (emp_code);

-- 添加命名唯一约束
ALTER TABLE employees ADD CONSTRAINT uk_emp_code UNIQUE (emp_code);

-- 删除唯一约束
ALTER TABLE employees DROP INDEX uk_emp_code;
-- 或者
ALTER TABLE employees DROP CONSTRAINT uk_emp_code;
```

## # 2.2 唯一索引与唯一约束关系


**🔸 内在关联机制**

> 💡 **重要理解**  
> 在MySQL中，唯一约束的底层实现就是唯一索引。创建唯一约束时，MySQL会自动创建对应的唯一索引。

```sql
-- 创建唯一约束
ALTER TABLE users ADD UNIQUE (email);

-- 查看索引信息
SHOW INDEX FROM users;
-- 会看到自动创建了名为 'email' 的唯一索引

-- 直接创建唯一索引（效果相同）
CREATE UNIQUE INDEX idx_email ON users (email);
```

**🔸 唯一索引的特点**

```
唯一索引工作原理：
插入新记录时 ──▶ 检查索引 ──▶ 发现重复 ──▶ 拒绝插入
       │               │          │         │
       ▼               ▼          ▼         ▼
   准备数据        索引查找    重复检测   报错返回

性能优势：
- 唯一性检查通过索引快速完成，时间复杂度O(log n)
- 避免了全表扫描验证唯一性
```

## # 2.3 约束命名与管理


**🔸 约束命名策略**

```sql
-- 推荐的约束命名规范
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    order_no VARCHAR(50),
    customer_email VARCHAR(100),
    
    -- 清晰的约束命名
    CONSTRAINT uk_orders_order_no UNIQUE (order_no),
    CONSTRAINT uk_orders_customer_email UNIQUE (customer_email)
);

-- 查看表约束信息
SELECT 
    CONSTRAINT_NAME,
    CONSTRAINT_TYPE,
    COLUMN_NAME
FROM information_schema.KEY_COLUMN_USAGE 
WHERE TABLE_NAME = 'orders' 
  AND TABLE_SCHEMA = 'your_database';
```

---

##  3. 🚫 NULL值与唯一性规则


## # 3.1 唯一约束与NULL值特殊规则


**🔸 NULL值的唯一性处理**

> ⚠️ **重要规则**  
> 在MySQL中，NULL值不违反唯一性约束。多个NULL值可以同时存在于唯一约束列中，因为NULL表示"未知"，两个未知值不能判断是否相等。

```sql
-- 创建测试表
CREATE TABLE test_unique (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20) UNIQUE
);

-- 以下插入都会成功
INSERT INTO test_unique (email, phone) VALUES ('user1@email.com', '13800001111');
INSERT INTO test_unique (email, phone) VALUES ('user2@email.com', NULL);  -- phone为NULL
INSERT INTO test_unique (email, phone) VALUES (NULL, '13800002222');      -- email为NULL  
INSERT INTO test_unique (email, phone) VALUES (NULL, NULL);               -- 都为NULL
INSERT INTO test_unique (email, phone) VALUES (NULL, NULL);               -- 再次插入NULL也成功

-- 查看结果
SELECT * FROM test_unique;
```

**🔸 NULL值规则的实际应用**

```sql
-- 用户表设计：手机号可选，但不能重复
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,  -- 用户名必填且唯一
    email VARCHAR(100) NOT NULL UNIQUE,    -- 邮箱必填且唯一
    phone VARCHAR(20) UNIQUE,              -- 手机号可选但唯一
    wechat_id VARCHAR(50) UNIQUE           -- 微信号可选但唯一
);

-- 这些插入都是合法的
INSERT INTO users (username, email, phone) VALUES ('user1', 'user1@email.com', '13800001111');
INSERT INTO users (username, email, phone) VALUES ('user2', 'user2@email.com', NULL);  -- phone可以为空
INSERT INTO users (username, email, wechat_id) VALUES ('user3', 'user3@email.com', 'wechat123');
```

## # 3.2 处理NULL值的约束设计


**🔸 强制非空唯一约束**

```sql
-- 如果业务要求某字段既不能为空也不能重复
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    sku_code VARCHAR(50) NOT NULL UNIQUE,  -- 不允许NULL且必须唯一
    product_name VARCHAR(200) NOT NULL,
    barcode VARCHAR(100) UNIQUE            -- 允许NULL但不能重复
);
```

**🔸 条件唯一约束模拟**

> 💡 **高级技巧**  
> 如果需要实现"当某字段不为NULL时必须唯一"的复杂约束，可以使用函数索引或触发器。

```sql
-- 函数唯一索引实现（MySQL 8.0+）
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    draft_order_no VARCHAR(50),  -- 草稿订单号，可以为空
    confirmed_order_no VARCHAR(50), -- 确认订单号，不能为空时必须唯一
    status ENUM('draft', 'confirmed', 'shipped')
);

-- 创建条件唯一索引：只对非空值创建唯一约束
CREATE UNIQUE INDEX uk_confirmed_order_no 
ON orders (confirmed_order_no) 
WHERE confirmed_order_no IS NOT NULL;
```

---

##  4. 🔗 复合唯一约束详解


## # 4.1 什么是复合唯一约束


**🔸 概念理解**
复合唯一约束是对多个列的组合进行唯一性限制，就像"姓名+身份证号"的组合必须唯一：

```sql
-- 学生选课表：同一学生不能选同一门课程两次
CREATE TABLE student_courses (
    id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    course_id INT NOT NULL,
    enrollment_date DATE,
    UNIQUE (student_id, course_id)  -- 复合唯一约束
);
```

## # 4.2 复合唯一约束的设计原则


**🔸 实际应用场景**

```sql
-- 用户地址表：同一用户的地址标签不能重复
CREATE TABLE user_addresses (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    address_type ENUM('home', 'work', 'other') NOT NULL,
    address TEXT NOT NULL,
    UNIQUE (user_id, address_type)  -- 同一用户的同种地址类型只能有一个
);

-- 商品库存表：同一商品在同一仓库中只能有一条库存记录
CREATE TABLE inventory (
    id INT PRIMARY KEY AUTO_INCREMENT,
    product_id INT NOT NULL,
    warehouse_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 0,
    UNIQUE (product_id, warehouse_id)
);
```

**🔸 复合约束与单列约束的区别**

```sql
-- 对比示例
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    order_no VARCHAR(50) NOT NULL,
    
    -- 单列唯一约束：订单号全局唯一
    UNIQUE (order_no),
    
    -- 复合唯一约束：同一客户同一天只能有一个订单
    UNIQUE (customer_id, order_date)
);

-- 这些数据插入都是合法的
INSERT INTO orders (customer_id, order_date, order_no) VALUES (1, '2024-01-01', 'ORD001');
INSERT INTO orders (customer_id, order_date, order_no) VALUES (1, '2024-01-02', 'ORD002');  -- 同一客户不同日期
INSERT INTO orders (customer_id, order_date, order_no) VALUES (2, '2024-01-01', 'ORD003');  -- 不同客户同一日期

-- 这个插入会失败：违反复合唯一约束
-- INSERT INTO orders (customer_id, order_date, order_no) VALUES (1, '2024-01-01', 'ORD004');
```

## # 4.3 复合约束的索引策略


**🔸 索引列顺序的重要性**

```sql
-- 复合唯一约束的索引顺序很重要
CREATE TABLE user_permissions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    module_id INT NOT NULL,
    permission_type VARCHAR(20) NOT NULL,
    
    -- 索引顺序：user_id, module_id, permission_type
    UNIQUE (user_id, module_id, permission_type)
);

-- 索引使用效率分析
-- ✅ 高效：能使用索引
SELECT * FROM user_permissions WHERE user_id = 123;
SELECT * FROM user_permissions WHERE user_id = 123 AND module_id = 456;

-- ❌ 低效：不能使用索引  
SELECT * FROM user_permissions WHERE module_id = 456;
SELECT * FROM user_permissions WHERE permission_type = 'read';
```

---

##  5. ⚡ 唯一约束性能优化


## # 5.1 唯一约束性能分析


**🔸 性能影响因素**

| 操作类型 | **性能影响** | **影响程度** | **优化建议** |
|---------|-------------|-------------|-------------|
| 🔍 **SELECT查询** | `正面影响` | `查询加速` | `利用唯一索引快速定位` |
| ➕ **INSERT插入** | `负面影响` | `轻微延迟` | `唯一性检查开销` |
| ✏️ **UPDATE更新** | `负面影响` | `中等延迟` | `可能需要重建索引` |
| 🗑️ **DELETE删除** | `负面影响` | `轻微延迟` | `索引维护开销` |

**🔸 性能测试对比**

```sql
-- 测试表准备
CREATE TABLE test_performance (
    id INT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50),
    name VARCHAR(100),
    INDEX idx_code (code)  -- 普通索引
);

CREATE TABLE test_performance_unique (
    id INT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50) UNIQUE,  -- 唯一索引
    name VARCHAR(100)
);

-- 查询性能对比（唯一索引通常更快）
-- 因为MySQL知道最多只会返回一条记录
EXPLAIN SELECT * FROM test_performance WHERE code = 'ABC123';
EXPLAIN SELECT * FROM test_performance_unique WHERE code = 'ABC123';
```

## # 5.2 唯一约束性能优化策略


**🔸 索引设计优化**

```sql
-- 优化前：效率低的复合唯一约束
CREATE TABLE orders_old (
    id INT PRIMARY KEY,
    customer_name VARCHAR(100),  -- 长字符串
    order_date DATE,
    order_time TIME,
    amount DECIMAL(10,2),
    UNIQUE (customer_name, order_date, order_time)  -- 包含长字符串的复合索引
);

-- 优化后：使用ID替代长字符串
CREATE TABLE orders_new (
    id INT PRIMARY KEY,
    customer_id INT,  -- 使用ID替代长字符串
    order_date DATE,
    order_time TIME,
    amount DECIMAL(10,2),
    UNIQUE (customer_id, order_date, order_time),  -- 更高效的复合索引
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);
```

**🔸 批量操作优化**

```sql
-- 批量插入时的唯一约束优化
-- 使用 INSERT IGNORE 忽略重复数据
INSERT IGNORE INTO products (sku_code, name, price) VALUES
    ('SKU001', 'Product 1', 100.00),
    ('SKU002', 'Product 2', 200.00),
    ('SKU001', 'Duplicate', 150.00);  -- 这条会被忽略

-- 使用 ON DUPLICATE KEY UPDATE 处理冲突
INSERT INTO products (sku_code, name, price) VALUES
    ('SKU001', 'Updated Product 1', 120.00)
ON DUPLICATE KEY UPDATE 
    name = VALUES(name),
    price = VALUES(price),
    updated_at = CURRENT_TIMESTAMP;
```

## # 5.3 监控唯一约束性能


**🔸 性能监控指标**

```sql
-- 监控索引使用情况
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,  -- 索引基数
    SEQ_IN_INDEX  -- 索引中的列序号
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' 
  AND NON_UNIQUE = 0;  -- 只看唯一索引

-- 监控约束违反情况
SHOW ENGINE INNODB STATUS;  -- 查看最近的约束违反错误
```

---

##  6. 🚨 唯一冲突处理策略


## # 6.1 唯一冲突解决方案


**🔸 处理策略对比**

| 处理方式 | **语法** | **冲突时行为** | **适用场景** |
|---------|---------|---------------|-------------|
| 🚫 **报错中止** | `INSERT` | `抛出错误，事务回滚` | `严格的数据一致性要求` |
| 🔄 **忽略重复** | `INSERT IGNORE` | `忽略重复记录` | `数据导入，允许跳过重复` |
| 🔄 **替换记录** | `REPLACE INTO` | `删除旧记录，插入新记录` | `数据同步，覆盖更新` |
| 📝 **更新处理** | `ON DUPLICATE KEY UPDATE` | `更新已存在的记录` | `灵活的冲突处理逻辑` |

## # 6.2 具体处理方法详解


**🔸 INSERT IGNORE：忽略重复**

```sql
-- 示例：导入用户数据，忽略重复邮箱
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE,
    name VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 正常插入
INSERT INTO users (email, name) VALUES ('user1@email.com', 'User One');

-- 使用 INSERT IGNORE 忽略重复
INSERT IGNORE INTO users (email, name) VALUES 
    ('user1@email.com', 'Duplicate User'),  -- 会被忽略
    ('user2@email.com', 'User Two');        -- 会被插入

-- 检查结果（只有第一条和第三条被插入）
SELECT * FROM users;
```

**🔸 REPLACE INTO：替换记录**

```sql
-- REPLACE INTO 会删除冲突记录然后插入新记录
-- 注意：这会改变主键ID！
REPLACE INTO users (email, name) VALUES ('user1@email.com', 'Updated User One');

-- 查看结果：user1@email.com的记录被完全替换，ID可能改变
SELECT * FROM users;
```

**🔸 ON DUPLICATE KEY UPDATE：更新处理**

```sql
-- 最灵活的冲突处理方式
INSERT INTO users (email, name) VALUES ('user1@email.com', 'New Name')
ON DUPLICATE KEY UPDATE 
    name = VALUES(name),                    -- 使用新的name值
    updated_at = CURRENT_TIMESTAMP;         -- 更新时间戳

-- 复杂的更新逻辑
INSERT INTO product_inventory (product_id, warehouse_id, quantity) 
VALUES (101, 1, 50)
ON DUPLICATE KEY UPDATE 
    quantity = quantity + VALUES(quantity), -- 累加库存数量
    last_updated = CURRENT_TIMESTAMP;
```

## # 6.3 应用层冲突处理


**🔸 程序化处理策略**

```sql
-- 方案1：先查询后插入（存在并发问题）
SELECT COUNT(*) FROM users WHERE email = 'user@email.com';
-- 如果不存在才插入（并发时可能仍然冲突）

-- 方案2：直接插入，捕获异常处理
-- Java示例逻辑：
-- try {
--     INSERT INTO users (email, name) VALUES (?, ?);
-- } catch (SQLIntegrityConstraintViolationException e) {
--     // 处理唯一约束冲突
--     UPDATE users SET name = ? WHERE email = ?;
-- }
```

**🔸 业务层面的冲突处理**

```sql
-- 用户注册场景的冲突处理
-- 表设计
CREATE TABLE user_registrations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE,
    username VARCHAR(50) UNIQUE,
    password_hash VARCHAR(255),
    status ENUM('pending', 'active', 'inactive') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 注册时的处理策略
INSERT INTO user_registrations (email, username, password_hash) 
VALUES ('user@email.com', 'username', 'hash')
ON DUPLICATE KEY UPDATE
    password_hash = CASE 
        WHEN status = 'inactive' THEN VALUES(password_hash)  -- 重新激活
        ELSE password_hash  -- 保持原密码
    END,
    status = CASE 
        WHEN status = 'inactive' THEN 'pending'  -- 重新激活账户
        ELSE status  -- 保持原状态
    END;
```

---

##  7. 🎯 高级唯一约束技巧


## # 7.1 函数唯一索引实现


**🔸 基于表达式的唯一约束**

```sql
-- MySQL 8.0+ 支持函数索引
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100),
    name VARCHAR(50)
);

-- 创建基于表达式的唯一索引（不区分大小写的邮箱唯一性）
CREATE UNIQUE INDEX uk_email_lower ON users ((LOWER(email)));

-- 测试效果
INSERT INTO users (email, name) VALUES ('User@Email.com', 'User One');
-- 以下插入会失败，因为 LOWER('user@email.com') 重复
-- INSERT INTO users (email, name) VALUES ('user@email.com', 'User Two');
```

**🔸 条件唯一索引**

```sql
-- 部分唯一约束：只对满足条件的记录建立唯一性
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(50),
    status ENUM('draft', 'confirmed', 'cancelled'),
    customer_id INT
);

-- 只对已确认的订单要求订单号唯一
CREATE UNIQUE INDEX uk_confirmed_order_no 
ON orders (order_no) 
WHERE status = 'confirmed';

-- 测试：草稿订单可以有重复的订单号
INSERT INTO orders (order_no, status, customer_id) VALUES ('ORD001', 'draft', 1);
INSERT INTO orders (order_no, status, customer_id) VALUES ('ORD001', 'draft', 2);  -- 允许

-- 确认的订单不能重复
INSERT INTO orders (order_no, status, customer_id) VALUES ('ORD002', 'confirmed', 1);
-- INSERT INTO orders (order_no, status, customer_id) VALUES ('ORD002', 'confirmed', 2);  -- 失败
```

## # 7.2 部分唯一约束模拟


**🔸 使用触发器实现复杂约束**

```sql
-- 业务需求：每个用户最多只能有一个默认地址
CREATE TABLE user_addresses (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    address TEXT NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    INDEX (user_id)
);

-- 创建触发器确保每个用户只有一个默认地址
DELIMITER //
CREATE TRIGGER ensure_single_default_address
    BEFORE INSERT ON user_addresses
    FOR EACH ROW
BEGIN
    IF NEW.is_default = TRUE THEN
        UPDATE user_addresses 
        SET is_default = FALSE 
        WHERE user_id = NEW.user_id AND is_default = TRUE;
    END IF;
END//

CREATE TRIGGER ensure_single_default_address_update
    BEFORE UPDATE ON user_addresses
    FOR EACH ROW
BEGIN
    IF NEW.is_default = TRUE AND OLD.is_default = FALSE THEN
        UPDATE user_addresses 
        SET is_default = FALSE 
        WHERE user_id = NEW.user_id AND is_default = TRUE AND id != NEW.id;
    END IF;
END//
DELIMITER ;
```

## # 7.3 唯一性约束设计原则


**🔸 设计最佳实践**

> 🔑 **设计原则总结**
> 1. **业务导向**：唯一约束应该反映真实的业务规则
> 2. **性能考虑**：避免在高频更新字段上建立唯一约束
> 3. **扩展性**：考虑未来业务变化，预留设计空间
> 4. **错误处理**：设计完善的冲突处理机制

```sql
-- 良好的约束设计示例
CREATE TABLE e_commerce_orders (
    -- 技术主键：稳定不变
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    -- 业务主键：订单号唯一
    order_no VARCHAR(50) NOT NULL UNIQUE,
    
    -- 业务约束：同一用户同一时间只能有一个待支付订单
    customer_id INT NOT NULL,
    status ENUM('pending_payment', 'paid', 'shipped', 'completed', 'cancelled'),
    
    -- 业务字段
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引策略
    INDEX idx_customer_status (customer_id, status),
    INDEX idx_created_at (created_at)
);

-- 通过唯一索引实现业务约束
CREATE UNIQUE INDEX uk_customer_pending_payment 
ON e_commerce_orders (customer_id) 
WHERE status = 'pending_payment';
```

---

##  8. 📋 核心要点总结


## # 8.1 唯一约束核心概念


**🔸 必须掌握的要点**

> 💡 **核心理解**  
> 唯一约束是数据完整性的重要保障，它通过底层的唯一索引实现，允许NULL值存在，支持复合列约束，是业务规则在数据库层面的体现。

**🔸 关键知识点梳理**

| 核心概念 | **要点说明** | **实际应用** |
|---------|-------------|-------------|
| 🔑 **基本特性** | `允许NULL，不允许重复` | `邮箱、手机号等业务字段` |
| 🔍 **索引关系** | `自动创建唯一索引` | `提升查询性能` |
| 🔗 **复合约束** | `多列组合唯一性` | `用户+课程，商品+仓库` |
| 🚨 **冲突处理** | `多种处理策略` | `数据导入，业务逻辑` |

## # 8.2 实际应用指导


**🔸 约束设计检查清单**
- [ ] **业务合理性**：约束是否符合实际业务规则
- [ ] **性能影响**：是否会显著影响写入性能
- [ ] **NULL值处理**：是否正确处理NULL值情况
- [ ] **冲突策略**：是否有完善的冲突处理机制
- [ ] **扩展性**：是否考虑未来业务变化

**🔸 常见错误避免**

> ⚠️ **典型错误**
> 1. **忽略NULL值规则**：以为NULL也会违反唯一约束
> 2. **复合约束顺序错误**：不了解索引列顺序的重要性
> 3. **缺乏冲突处理**：没有设计重复数据的处理策略
> 4. **过度约束**：在不需要的地方添加唯一约束

## # 8.3 性能优化要点


**🔸 优化策略总结**
- **索引设计**：合理安排复合索引的列顺序
- **数据类型**：使用较短的数据类型建立唯一约束
- **批量操作**：使用适当的冲突处理语法
- **监控维护**：定期检查约束性能影响

## # 8.4 学习进阶方向


**🔸 深入学习建议**

> 🚀 **下一步学习**
> 1. **外键约束**：学习表间关系约束
> 2. **检查约束**：了解值范围约束（MySQL 8.0.16+）
> 3. **触发器应用**：实现复杂的业务约束
> 4. **分区表约束**：大数据场景下的约束设计

**🔸 实践项目建议**
- 设计用户管理系统的约束方案
- 实现电商订单的业务约束
- 优化高并发场景下的唯一约束性能
- 处理数据迁移中的约束冲突

---

**💡 学习要点**：
- 唯一约束是业务规则的数据库实现
- NULL值的特殊处理规则很重要
- 性能与数据完整性需要平衡考虑
- 冲突处理策略要结合具体业务场景