---
title: 2、约束类型与分类体系
---
## 📚 目录

1. [数据完整性理论基础](#1-数据完整性理论基础)
2. [约束体系完整架构](#2-约束体系完整架构)
3. [实体完整性机制](#3-实体完整性机制)
4. [参照完整性机制](#4-参照完整性机制)
5. [域完整性机制](#5-域完整性机制)
6. [用户定义完整性](#6-用户定义完整性)
7. [约束层次结构与优先级](#7-约束层次结构与优先级)
8. [约束分类标准说明](#8-约束分类标准说明)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📖 数据完整性理论基础


### 1.1 什么是数据完整性


**🔸 通俗理解**
数据完整性就像**数据的保护盾**，确保存储在数据库中的数据是正确、一致、有效的。

想象一下现实生活中的例子：
- **身份证号码**：必须唯一，不能重复
- **手机号码**：必须11位数字，不能是字母
- **年龄**：必须是正数，不能是负数
- **员工部门**：必须存在这个部门，不能瞎填

**🔸 完整性的核心作用**
```
数据质量保障体系：

输入数据 ━━━━➤ 约束检查 ━━━━➤ 合格数据存储
    |             |             |
    |             |             |
垃圾数据      过滤机制        高质量数据
错误数据      验证规则        可靠数据
无效数据      约束条件        一致数据
```

### 1.2 为什么需要数据完整性


**🔸 没有约束的混乱情况**

假设一个学生管理系统没有任何约束：
```sql
-- 可能出现的数据混乱
INSERT INTO students VALUES (1, '张三', 20, '计算机系');
INSERT INTO students VALUES (1, '李四', 25, '计算机系');  -- 学号重复！
INSERT INTO students VALUES (2, '王五', -5, '火星系');   -- 年龄负数！
INSERT INTO students VALUES (3, '', 150, '不存在系');    -- 姓名空白！
```

**导致的问题**：
- 🚫 **数据混乱**：相同学号对应不同学生
- 🚫 **逻辑错误**：年龄-5岁、150岁都不合理
- 🚫 **业务错误**：不存在的院系无法管理
- 🚫 **查询困难**：无法准确查找和统计

**🔸 有约束的数据质量**
```sql
-- 添加约束后的表结构
CREATE TABLE students (
    student_id INT PRIMARY KEY,           -- 主键：唯一且非空
    name VARCHAR(50) NOT NULL,            -- 非空：姓名必填
    age INT CHECK (age >= 0 AND age <= 120), -- 检查：年龄合理范围
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id) -- 外键：部门必须存在
);
```

### 1.3 完整性的分类层次


**📊 完整性四大支柱**
```
                     数据完整性
                         |
        ┌────────────────┼────────────────┐
        |                |                |
   实体完整性        参照完整性        域完整性
   (谁是谁)         (关系对不对)       (值合不合理)
        |                |                |
   主键约束          外键约束         类型约束
   唯一约束          级联操作         检查约束
                                    非空约束
                                    默认值约束
                                       |
                                 用户定义完整性
                                 (自定义业务规则)
```

---

## 2. 🏗️ 约束体系完整架构


### 2.1 约束分类的标准维度


**🔸 按作用范围分类**

```
约束作用范围层次图：

┌─────────────────────────────────────────────────────────┐
│                    数据库级约束                          │
│  ┌─────────────────────────────────────────────────┐   │
│  │                表级约束                         │   │
│  │  ┌─────────────────────────────────────────┐   │   │
│  │  │            列级约束                     │   │   │
│  │  │                                         │   │   │
│  │  │  NOT NULL, DEFAULT, CHECK               │   │   │
│  │  └─────────────────────────────────────────┘   │   │
│  │                                                 │   │
│  │  PRIMARY KEY, FOREIGN KEY, UNIQUE               │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
│  自定义函数约束, 触发器约束                               │
└─────────────────────────────────────────────────────────┘
```

**层次说明**：
- **列级约束**：只影响单个字段的约束
- **表级约束**：涉及多个字段或整行的约束  
- **数据库级约束**：跨表的约束关系

**🔸 按约束时机分类**

```
约束检查时机：

数据插入时 ━━━━➤ 立即检查约束 ━━━━➤ 通过/拒绝
    |                 |                |
    |                 |                |
插入新记录         所有相关约束        数据存储
更新现有记录       实时验证          或报错退回

延迟检查约束 ━━━━➤ 事务提交时检查 ━━━━➤ 整体验证
    |                 |                |
    |                 |                |
复杂业务逻辑       批量数据处理        一致性保证
多表关联更新       事务完整性          或整体回滚
```

### 2.2 约束命名与管理体系


**🔧 约束命名规范**
```sql
-- 推荐的约束命名规范
CREATE TABLE orders (
    order_id INT,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10,2),
    status VARCHAR(20),
    
    -- 主键约束命名
    CONSTRAINT PK_orders_order_id PRIMARY KEY (order_id),
    
    -- 外键约束命名  
    CONSTRAINT FK_orders_customer_id FOREIGN KEY (customer_id) 
        REFERENCES customers(customer_id),
    
    -- 检查约束命名
    CONSTRAINT CHK_orders_amount CHECK (total_amount > 0),
    CONSTRAINT CHK_orders_status CHECK (status IN ('pending', 'completed', 'cancelled')),
    
    -- 唯一约束命名
    CONSTRAINT UK_orders_date_customer UNIQUE (customer_id, order_date)
);
```

**命名规范解释**：
- **PK_** = Primary Key 主键
- **FK_** = Foreign Key 外键  
- **CHK_** = Check 检查约束
- **UK_** = Unique Key 唯一约束
- **表名_字段名** = 明确约束所属

---

## 3. 🎯 实体完整性机制


### 3.1 什么是实体完整性


**🔸 通俗解释**
实体完整性就是保证**每一行数据都有唯一身份标识**，就像每个人都有唯一的身份证号码一样。

**🔸 核心概念**
- **实体**：数据库表中的每一行记录
- **标识**：能够唯一区分不同记录的字段组合
- **完整性**：保证标识的唯一性和有效性

### 3.2 主键约束（PRIMARY KEY）详解


**🔥 主键的本质含义**

> 💡 **主键就像身份证**：每个人只有一个身份证，身份证号码不能重复，也不能为空

**主键的四大特性**：
```
1. 唯一性 (UNIQUE)
   ┌─────────────────────────────────────┐
   │ 表中任意两行的主键值都不能相同        │
   │ 例：学生表中不能有两个学号相同的学生   │
   └─────────────────────────────────────┘

2. 非空性 (NOT NULL)  
   ┌─────────────────────────────────────┐
   │ 主键字段的值不能为NULL               │
   │ 例：学生必须有学号，不能是空的        │
   └─────────────────────────────────────┘

3. 不可变性 (IMMUTABLE)
   ┌─────────────────────────────────────┐
   │ 主键值一旦确定，通常不建议修改        │
   │ 例：学生入学后学号一般不会改变        │
   └─────────────────────────────────────┘

4. 唯一标识性 (IDENTIFICATION)
   ┌─────────────────────────────────────┐
   │ 通过主键可以唯一确定一行记录          │
   │ 例：知道学号就能找到对应的学生信息     │
   └─────────────────────────────────────┘
```

**🔧 主键约束实现**
```sql
-- 方法1：创建表时定义主键
CREATE TABLE students (
    student_id INT PRIMARY KEY,  -- 单字段主键
    name VARCHAR(50),
    age INT
);

-- 方法2：组合主键（多个字段共同作为主键）
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 组合主键
);

-- 方法3：后续添加主键
ALTER TABLE students ADD CONSTRAINT PK_students PRIMARY KEY (student_id);
```

### 3.3 唯一性约束（UNIQUE）详解


**🔥 唯一约束的作用**

> 💡 **唯一约束像邮箱地址**：每个邮箱只能属于一个人，但一个人可以有多个邮箱

**UNIQUE vs PRIMARY KEY对比**：
```
┌─────────────────┬─────────────────┬─────────────────┐
│     特性        │   PRIMARY KEY   │     UNIQUE      │
├─────────────────┼─────────────────┼─────────────────┤
│   唯一性        │      ✅必须      │      ✅必须      │
│   非空性        │      ✅必须      │      ❌允许NULL  │
│   数量限制      │    🔸每表1个     │    🔸每表多个    │
│   索引创建      │      ✅自动      │      ✅自动      │
│   业务含义      │   🎯主要标识     │   🎯辅助标识     │
└─────────────────┴─────────────────┴─────────────────┘
```

**实际应用示例**：
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,              -- 主键：用户ID
    username VARCHAR(50) UNIQUE,          -- 唯一：用户名不能重复
    email VARCHAR(100) UNIQUE,            -- 唯一：邮箱不能重复
    phone VARCHAR(20) UNIQUE,             -- 唯一：手机号不能重复
    id_card VARCHAR(18) UNIQUE,           -- 唯一：身份证不能重复
    password_hash VARCHAR(255) NOT NULL
);
```

**🔸 NULL值的特殊处理**
```sql
-- UNIQUE约束中NULL的特殊规则
INSERT INTO users (user_id, username, email) VALUES (1, 'user1', NULL);  -- ✅允许
INSERT INTO users (user_id, username, email) VALUES (2, 'user2', NULL);  -- ✅允许
INSERT INTO users (user_id, username, email) VALUES (3, 'user3', NULL);  -- ✅允许

-- 解释：多个NULL值不被认为是重复，因为NULL表示"未知"
```

---

## 4. 🔗 参照完整性机制


### 4.1 什么是参照完整性


**🔸 生活化理解**
参照完整性就像**户籍管理系统**：
- 每个人必须属于某个真实存在的社区
- 不能填写一个不存在的社区名称
- 如果社区被撤销，居民必须先转移到其他社区

**🔸 数据库中的体现**
```
现实世界关系：              数据库表关系：
┌─────────────┐            ┌─────────────────┐
│    部门表    │            │   departments   │
│ 部门ID 部门名 │     对应    │ dept_id  name   │  
│   1   研发部  │ ═══════════ │    1    研发部   │
│   2   销售部  │            │    2    销售部   │
└─────────────┘            └─────────────────┘
                                    ↑
┌─────────────┐                     │参照关系
│    员工表    │            ┌─────────────────┐
│员工ID 姓名 部门│     对应    │   employees     │
│  101  张三  1  │ ═══════════ │ emp_id name dept│
│  102  李四  2  │            │  101   张三  1  │
│  103  王五  1  │            │  102   李四  2  │
└─────────────┘            └─────────────────┘
```

### 4.2 外键约束（FOREIGN KEY）详解


**🔥 外键约束的核心作用**

**基本原理**：
- **子表**的外键字段值必须在**父表**的主键中存在
- 保证数据引用的有效性
- 防止"悬空引用"（引用不存在的数据）

**🔧 外键约束语法**
```sql
-- 创建父表（被引用表）
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50) NOT NULL,
    location VARCHAR(100)
);

-- 创建子表（引用表）
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50) NOT NULL,
    dept_id INT,
    salary DECIMAL(10,2),
    
    -- 外键约束：员工的部门ID必须在部门表中存在
    CONSTRAINT FK_emp_dept FOREIGN KEY (dept_id) 
        REFERENCES departments(dept_id)
);
```

**🔥 外键约束的保护机制**

**插入保护**：
```sql
-- 先插入部门数据
INSERT INTO departments VALUES (1, '研发部', '北京');
INSERT INTO departments VALUES (2, '销售部', '上海');

-- 正确插入员工（引用存在的部门）
INSERT INTO employees VALUES (101, '张三', 1, 8000);  -- ✅成功

-- 错误插入员工（引用不存在的部门）
INSERT INTO employees VALUES (102, '李四', 99, 6000); -- ❌失败
-- 错误信息：Cannot add foreign key constraint
```

**删除保护**：
```sql
-- 尝试删除被引用的部门
DELETE FROM departments WHERE dept_id = 1;  -- ❌失败
-- 错误信息：Cannot delete referenced row

-- 正确的删除顺序：
-- 1. 先删除或转移员工
UPDATE employees SET dept_id = 2 WHERE dept_id = 1;
-- 2. 再删除部门
DELETE FROM departments WHERE dept_id = 1;  -- ✅成功
```

### 4.3 外键的级联操作


**🔥 级联操作类型**

> 💡 **级联操作**：当父表数据变更时，子表数据自动跟着变更

**四种级联操作模式**：

```sql
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
        ON DELETE CASCADE     -- 删除级联
        ON UPDATE CASCADE     -- 更新级联
);
```

**级联操作详解**：
```
1. CASCADE（级联）
   父表删除 ━━━━➤ 子表相关记录自动删除
   父表更新 ━━━━➤ 子表相关记录自动更新

2. SET NULL（设为空值）
   父表删除 ━━━━➤ 子表外键字段设为NULL
   父表更新 ━━━━➤ 子表外键字段设为NULL

3. RESTRICT（限制）
   父表删除 ━━━━➤ 如果有子表引用，拒绝删除
   父表更新 ━━━━➤ 如果有子表引用，拒绝更新

4. NO ACTION（无动作）
   父表删除 ━━━━➤ 延迟到事务提交时检查
   父表更新 ━━━━➤ 延迟到事务提交时检查
```

**实际场景示例**：
```sql
-- 场景：删除部门时的不同处理方式

-- CASCADE：部门删除，员工也删除（适合临时部门）
DELETE FROM departments WHERE dept_id = 1;
-- 结果：部门1删除，该部门所有员工记录也删除

-- SET NULL：部门删除，员工部门设为空（适合部门重组）
DELETE FROM departments WHERE dept_id = 1;  
-- 结果：部门1删除，员工的dept_id变为NULL

-- RESTRICT：有员工的部门不能删除（适合严格管理）
DELETE FROM departments WHERE dept_id = 1;
-- 结果：删除失败，提示"该部门还有员工"
```

---

## 5. 📏 域完整性机制


### 5.1 什么是域完整性


**🔸 域的概念**
"域"在数据库中指的是**字段的取值范围**，就像：
- 年龄域：0-120之间的整数
- 性别域：'男'或'女'
- 成绩域：0-100之间的数值
- 邮箱域：符合邮箱格式的字符串

**🔸 域完整性的作用**
确保每个字段的值都在合理的范围内，符合业务逻辑要求。

### 5.2 数据类型约束


**🔸 基础数据类型约束**
```sql
CREATE TABLE student_scores (
    student_id INT,           -- 整数域：只能存储整数
    score DECIMAL(5,2),       -- 数值域：最多5位数，2位小数
    grade CHAR(1),            -- 字符域：只能存储1个字符
    remarks TEXT,             -- 文本域：可变长文本
    exam_date DATE,           -- 日期域：只能存储有效日期
    is_passed BOOLEAN         -- 布尔域：TRUE或FALSE
);
```

**类型约束的自动保护**：
```sql
-- 以下插入会被自动拒绝
INSERT INTO student_scores VALUES 
    ('abc', 95.5, 'A', '优秀', '2023-02-30', TRUE);
    --  ↑        ↑                    ↑
    -- 字符不能   小数位数           2月没有30日
    -- 存入INT    超过限制            日期无效
```

### 5.3 非空约束（NOT NULL）


**🔥 非空约束的重要性**

**业务含义**：
```
必填字段示例：

用户注册表：
┌─────────────────┬─────────────────┬─────────────────┐
│     字段        │   是否必填       │     业务原因     │
├─────────────────┼─────────────────┼─────────────────┤
│   用户名        │    ✅必填        │   登录凭证       │
│   密码         │    ✅必填        │   安全验证       │
│   邮箱         │    ✅必填        │   找回密码       │
│   真实姓名      │    ❌可选        │   隐私保护       │
│   电话号码      │    ❌可选        │   用户自愿       │
└─────────────────┴─────────────────┴─────────────────┘
```

**🔧 非空约束实现**
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,       -- 用户名必填
    password_hash VARCHAR(255) NOT NULL, -- 密码必填  
    email VARCHAR(100) NOT NULL,         -- 邮箱必填
    real_name VARCHAR(50),               -- 真实姓名可选
    phone VARCHAR(20)                    -- 电话可选
);

-- 违反非空约束的插入
INSERT INTO users (user_id, username) VALUES (1, 'testuser');
-- 错误：Field 'password_hash' doesn't have a default value
```

### 5.4 默认值约束（DEFAULT）


**🔥 默认值的智能设计**

**设计原则**：
- **合理默认**：选择最常见或最安全的值
- **业务逻辑**：符合实际业务需求
- **用户友好**：减少用户输入负担

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 默认当前时间
    status VARCHAR(20) DEFAULT 'pending',            -- 默认待处理状态
    priority INT DEFAULT 5,                          -- 默认中等优先级
    is_urgent BOOLEAN DEFAULT FALSE,                 -- 默认非紧急
    shipping_fee DECIMAL(8,2) DEFAULT 0.00          -- 默认免运费
);
```

**默认值的实际作用**：
```sql
-- 简化插入操作
INSERT INTO orders (customer_id) VALUES (1001);

-- 等效于完整插入：
INSERT INTO orders (order_id, customer_id, order_date, status, priority, is_urgent, shipping_fee) 
VALUES (AUTO_INCREMENT, 1001, NOW(), 'pending', 5, FALSE, 0.00);
```

### 5.5 检查约束（CHECK）


**🔥 CHECK约束的强大功能**

> 💡 **CHECK约束像入场检票**：只有符合条件的数据才能"入场"存储

**约束表达式类型**：
```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) CHECK (price > 0),                    -- 价格必须大于0
    discount_rate DECIMAL(3,2) CHECK (discount_rate BETWEEN 0 AND 1), -- 折扣率0-1之间
    category VARCHAR(20) CHECK (category IN ('electronics', 'books', 'clothing')), -- 限定分类
    stock_quantity INT CHECK (stock_quantity >= 0),            -- 库存不能为负
    production_date DATE CHECK (production_date <= CURDATE()), -- 生产日期不能未来
    
    -- 多字段联合检查
    CHECK (price > discount_rate * 100)  -- 确保折扣后价格合理
);
```

**复杂业务规则示例**：
```sql
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 65),  -- 工作年龄范围
    salary DECIMAL(10,2),
    position VARCHAR(50),
    hire_date DATE,
    
    -- 复杂业务规则：经理薪资必须大于8000
    CHECK (
        (position != 'manager') OR 
        (position = 'manager' AND salary >= 8000)
    ),
    
    -- 入职日期不能是未来
    CHECK (hire_date <= CURDATE())
);
```

---

## 6. 🎨 用户定义完整性


### 6.1 什么是用户定义完整性


**🔸 超越标准约束的自定义规则**

用户定义完整性是根据**具体业务需求**制定的特殊约束规则，标准约束无法满足时，就需要自定义完整性规则。

**🔸 实现方式层次**
```
用户定义完整性实现层次：

Level 1: 复杂CHECK约束
    |
    ├── 多字段逻辑判断
    ├── 复杂数学计算
    └── 业务规则验证

Level 2: 触发器约束  
    |
    ├── 数据变更时自动执行
    ├── 复杂业务逻辑处理
    └── 跨表数据验证

Level 3: 存储过程约束
    |
    ├── 复杂业务流程控制
    ├── 多步骤数据验证
    └── 事务性业务规则
```

### 6.2 复杂CHECK约束示例


**🔧 业务规则约束**
```sql
-- 图书管理系统的复杂约束
CREATE TABLE books (
    book_id INT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    author VARCHAR(100) NOT NULL,
    isbn VARCHAR(13),
    publish_date DATE,
    page_count INT,
    price DECIMAL(8,2),
    category VARCHAR(50),
    
    -- 复杂业务规则约束
    CHECK (
        -- ISBN格式验证（简化版）
        isbn REGEXP '^[0-9]{10}$' OR isbn REGEXP '^[0-9]{13}$'
    ),
    
    CHECK (
        -- 出版日期合理性：不能太早也不能未来
        publish_date >= '1900-01-01' AND publish_date <= CURDATE()
    ),
    
    CHECK (
        -- 页数与价格的合理关系
        (page_count <= 100 AND price <= 50) OR
        (page_count > 100 AND page_count <= 500 AND price <= 100) OR  
        (page_count > 500 AND price <= 200)
    ),
    
    CHECK (
        -- 不同类别书籍的价格范围
        (category = 'textbook' AND price >= 20) OR
        (category = 'novel' AND price <= 80) OR
        (category = 'reference' AND price <= 300) OR
        (category NOT IN ('textbook', 'novel', 'reference'))
    )
);
```

### 6.3 触发器实现的完整性


**🔥 触发器约束机制**

> 💡 **触发器像自动警卫**：当数据发生变化时，自动检查是否符合业务规则

**触发器应用场景**：
```sql
-- 场景：库存管理的复杂业务规则
-- 规则：商品销售时自动减少库存，库存不足时拒绝销售

DELIMITER //
CREATE TRIGGER check_inventory_before_sale
    BEFORE INSERT ON order_items
    FOR EACH ROW
BEGIN
    DECLARE current_stock INT;
    
    -- 查询当前库存
    SELECT stock_quantity INTO current_stock 
    FROM products 
    WHERE product_id = NEW.product_id;
    
    -- 检查库存是否充足
    IF current_stock < NEW.quantity THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '库存不足，无法完成销售';
    END IF;
    
    -- 减少库存
    UPDATE products 
    SET stock_quantity = stock_quantity - NEW.quantity
    WHERE product_id = NEW.product_id;
END //
DELIMITER ;
```

**跨表数据一致性保证**：
```sql
-- 场景：确保账户余额与交易记录一致
DELIMITER //
CREATE TRIGGER update_account_balance
    AFTER INSERT ON transactions  
    FOR EACH ROW
BEGIN
    -- 根据交易类型更新账户余额
    IF NEW.transaction_type = 'deposit' THEN
        UPDATE accounts 
        SET balance = balance + NEW.amount 
        WHERE account_id = NEW.account_id;
    ELSEIF NEW.transaction_type = 'withdraw' THEN
        UPDATE accounts 
        SET balance = balance - NEW.amount 
        WHERE account_id = NEW.account_id;
        
        -- 检查余额不能为负
        IF (SELECT balance FROM accounts WHERE account_id = NEW.account_id) < 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '账户余额不足';
        END IF;
    END IF;
END //
DELIMITER ;
```

---

## 7. 📊 约束层次结构与优先级


### 7.1 约束层次关系


**🔸 约束检查的层次顺序**

```
数据插入/更新时的约束检查顺序：

Step 1: 数据类型检查
        ↓
   类型是否匹配？ ━━ ❌ ━━➤ 立即拒绝
        ↓ ✅
Step 2: 非空约束检查  
        ↓
   必填字段是否为空？ ━━ ❌ ━━➤ 立即拒绝
        ↓ ✅
Step 3: 默认值处理
        ↓
   空字段填入默认值
        ↓
Step 4: 检查约束验证
        ↓
   CHECK条件是否满足？ ━━ ❌ ━━➤ 立即拒绝
        ↓ ✅
Step 5: 唯一性约束检查
        ↓
   PRIMARY KEY/UNIQUE冲突？ ━━ ❌ ━━➤ 立即拒绝
        ↓ ✅
Step 6: 外键约束检查
        ↓
   参照完整性是否满足？ ━━ ❌ ━━➤ 立即拒绝
        ↓ ✅
Step 7: 数据存储成功
```

### 7.2 约束优先级规则


**🔥 约束冲突时的处理原则**

**优先级从高到低**：
```
1. 数据类型约束 ━━━━━━━━━━━━━━━━━━━━ 最高优先级
   |                                 (系统级约束)
   |
2. NOT NULL约束 ━━━━━━━━━━━━━━━━━━━━ 
   |                                 
   |
3. PRIMARY KEY约束 ━━━━━━━━━━━━━━━━━
   |                                 
   |  
4. UNIQUE约束 ━━━━━━━━━━━━━━━━━━━━━━
   |
   |
5. CHECK约束 ━━━━━━━━━━━━━━━━━━━━━━━
   |
   |
6. FOREIGN KEY约束 ━━━━━━━━━━━━━━━━━ 最低优先级
                                   (可延迟检查)
```

**🔧 优先级示例**
```sql
-- 假设有冲突的约束定义
CREATE TABLE test_table (
    id INT PRIMARY KEY,
    code VARCHAR(10) UNIQUE,
    value INT CHECK (value > 0),
    ref_id INT,
    FOREIGN KEY (ref_id) REFERENCES other_table(id)
);

-- 插入数据：INSERT INTO test_table VALUES (1, 'A001', -5, 999);

检查顺序和结果：
1. 类型检查：✅ 所有类型匹配
2. PRIMARY KEY：✅ id=1首次出现  
3. UNIQUE：✅ code='A001'首次出现
4. CHECK：❌ value=-5不满足>0条件
5. FOREIGN KEY：⏸️ 不会检查（前面已失败）

最终结果：插入失败，错误信息指向CHECK约束违反
```

### 7.3 约束的作用域范围


**🔸 作用域层次结构**

```
约束作用域范围图：

数据库级作用域
├── 字符集约束 (整个数据库的字符编码规则)
├── 存储引擎约束 (影响所有表的存储方式)
└── 全局参数约束 (如最大连接数、超时时间)
    |
    ├── 表级作用域  
    │   ├── PRIMARY KEY约束 (整个表的主键规则)
    │   ├── FOREIGN KEY约束 (表间引用关系)
    │   └── 复合UNIQUE约束 (多字段组合唯一性)
    │       |
    │       ├── 列级作用域
    │       │   ├── NOT NULL约束 (单个字段非空)
    │       │   ├── DEFAULT约束 (单个字段默认值)
    │       │   ├── CHECK约束 (单个字段值检查)
    │       │   └── 数据类型约束 (字段类型限制)
```

**约束范围影响分析**：
```
┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   约束类型      │   影响范围       │   检查时机       │   性能影响       │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ 数据类型约束     │   单个字段       │   立即检查       │   影响最小       │
│ NOT NULL约束    │   单个字段       │   立即检查       │   影响很小       │
│ CHECK约束       │   单行数据       │   立即检查       │   影响较小       │
│ UNIQUE约束      │   整个表        │   立即检查       │   影响中等       │
│ PRIMARY KEY约束 │   整个表        │   立即检查       │   影响中等       │
│ FOREIGN KEY约束 │   跨表关系       │   立即/延迟检查   │   影响较大       │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

---

## 8. 📋 约束分类标准说明


### 8.1 按完整性类型分类


**🔸 四大完整性类型对应关系**

```
完整性分类与约束对应关系：

实体完整性 (Entity Integrity)
├── PRIMARY KEY ━━━━━━━━━━━━━━ 确保实体唯一标识
└── UNIQUE ━━━━━━━━━━━━━━━━━━ 提供辅助唯一标识

参照完整性 (Referential Integrity)  
├── FOREIGN KEY ━━━━━━━━━━━━━ 维护表间引用关系
├── CASCADE操作 ━━━━━━━━━━━━━ 自动维护引用一致性
└── RESTRICT操作 ━━━━━━━━━━━━ 防止破坏引用关系

域完整性 (Domain Integrity)
├── NOT NULL ━━━━━━━━━━━━━━━━ 确保必要数据存在
├── DEFAULT ━━━━━━━━━━━━━━━━━ 提供合理默认值
├── CHECK ━━━━━━━━━━━━━━━━━━━ 验证数据值范围
└── 数据类型 ━━━━━━━━━━━━━━━━ 限制数据格式

用户定义完整性 (User-Defined Integrity)
├── 复杂CHECK约束 ━━━━━━━━━━━ 自定义业务规则
├── 触发器约束 ━━━━━━━━━━━━━━ 动态业务逻辑
└── 存储过程约束 ━━━━━━━━━━━━ 复杂业务流程
```

### 8.2 按约束范围分类


**🔸 约束作用范围分类体系**

```
按作用范围的约束分类：

字段级约束 (Column-Level)
├── 单字段直接约束
│   ├── NOT NULL ━━━━━━━━━━━━ 该字段不能为空
│   ├── DEFAULT ━━━━━━━━━━━━━ 该字段的默认值
│   ├── CHECK ━━━━━━━━━━━━━━━ 该字段值的检查
│   └── 数据类型 ━━━━━━━━━━━━ 该字段的格式限制

表级约束 (Table-Level)  
├── 多字段组合约束
│   ├── PRIMARY KEY ━━━━━━━━ 主键字段组合
│   ├── UNIQUE ━━━━━━━━━━━━━ 唯一性字段组合
│   ├── FOREIGN KEY ━━━━━━━━ 外键引用关系
│   └── 复合CHECK ━━━━━━━━━━ 多字段逻辑检查

数据库级约束 (Database-Level)
├── 跨表约束关系
│   ├── 触发器约束 ━━━━━━━━━━ 跨表数据一致性
│   ├── 视图约束 ━━━━━━━━━━━━ 数据访问控制
│   └── 存储过程约束 ━━━━━━━━ 复杂业务规则
```

### 8.3 按检查时机分类


**🔸 约束检查时机分类**

```
立即检查约束 (Immediate Constraints)
└── 数据修改时立即验证
    ├── NOT NULL ━━━━━━━━━━━━━━ 插入/更新时立即检查
    ├── CHECK ━━━━━━━━━━━━━━━━━ 插入/更新时立即检查  
    ├── UNIQUE ━━━━━━━━━━━━━━━━ 插入/更新时立即检查
    └── PRIMARY KEY ━━━━━━━━━━━ 插入/更新时立即检查

延迟检查约束 (Deferred Constraints)
└── 事务提交时统一验证
    ├── FOREIGN KEY ━━━━━━━━━━━ 可设置延迟检查
    ├── 复杂CHECK ━━━━━━━━━━━━━ 可设置延迟检查
    └── 触发器约束 ━━━━━━━━━━━━ 可控制检查时机
```

**延迟检查的应用场景**：
```sql
-- 场景：相互引用的表更新
-- 问题：员工表和部门表相互引用时的更新顺序问题

-- 设置延迟检查
SET foreign_key_checks = 0;  -- 临时禁用外键检查

-- 批量更新操作
UPDATE employees SET dept_id = 5 WHERE dept_id = 3;
UPDATE departments SET manager_id = 201 WHERE dept_id = 5;
DELETE FROM departments WHERE dept_id = 3;

SET foreign_key_checks = 1;  -- 重新启用外键检查
COMMIT;  -- 事务提交时统一检查所有约束
```

### 8.4 按实现机制分类


**🔸 约束实现机制分类**

```
声明式约束 (Declarative Constraints)
├── 定义时声明，系统自动执行
│   ├── PRIMARY KEY ━━━━━━━━━━━━ SQL标准约束
│   ├── FOREIGN KEY ━━━━━━━━━━━━ SQL标准约束
│   ├── UNIQUE ━━━━━━━━━━━━━━━━━ SQL标准约束
│   ├── NOT NULL ━━━━━━━━━━━━━━━ SQL标准约束
│   ├── CHECK ━━━━━━━━━━━━━━━━━━ SQL标准约束
│   └── DEFAULT ━━━━━━━━━━━━━━━━ SQL标准约束

程序式约束 (Procedural Constraints)  
├── 通过代码逻辑实现
│   ├── 触发器约束 ━━━━━━━━━━━━━━ 事件驱动执行
│   ├── 存储过程约束 ━━━━━━━━━━━━ 程序控制执行
│   ├── 函数约束 ━━━━━━━━━━━━━━━━ 函数调用执行
│   └── 应用层约束 ━━━━━━━━━━━━━━ 应用程序实现
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 数据完整性：保证数据正确、一致、有效的机制体系
🔸 实体完整性：通过主键和唯一约束确保每行记录可唯一标识
🔸 参照完整性：通过外键约束维护表间关系的一致性
🔸 域完整性：通过类型、范围、格式约束确保字段值合理
🔸 用户定义完整性：根据业务需求自定义的特殊约束规则
🔸 约束层次：从字段级到数据库级的多层次约束体系
🔸 约束优先级：不同约束的检查顺序和冲突处理机制
```

### 9.2 关键理解要点


**🔹 约束不是限制，而是保护**
```
正确理解约束的价值：
- 预防胜于治疗：在数据输入时就防止错误
- 系统性保护：从多个维度保证数据质量
- 自动化管理：减少人工检查的工作量
- 业务规则强制：确保数据符合业务逻辑
```

**🔹 约束设计的平衡艺术**
```
约束设计的权衡考虑：

严格性 vs 灵活性：
- 过严：可能影响正常业务操作
- 过松：可能导致数据质量问题
- 平衡：根据业务重要性分级设计

性能 vs 安全性：
- 约束检查需要消耗CPU资源
- 复杂约束可能影响插入更新速度
- 关键业务数据必须保证完整性
- 临时数据可以适当放宽约束
```

**🔹 约束的层次化设计思路**
```
从简单到复杂的设计思路：
Level 1: 基础数据类型和非空约束
Level 2: 业务逻辑的CHECK约束  
Level 3: 表间关系的外键约束
Level 4: 复杂业务规则的触发器约束

从核心到边缘的保护策略：
Core: 主键唯一性 ━━ 保证数据实体的基本标识
Important: 外键完整性 ━━ 保证数据关系的一致性  
Business: CHECK约束 ━━ 保证业务规则的合理性
Extended: 触发器约束 ━━ 保证复杂逻辑的正确性
```

### 9.3 实际应用价值


**🎯 数据质量保障**
- **准确性**：通过约束确保数据符合预期格式和范围
- **一致性**：通过外键维护数据间的逻辑关系
- **完整性**：通过非空约束确保关键信息不缺失
- **有效性**：通过检查约束确保数据符合业务规则

**🔧 系统稳定性提升**
- **错误预防**：在数据层面防止应用程序错误
- **性能优化**：通过索引约束提升查询效率
- **维护简化**：减少数据清理和修复工作
- **业务保护**：防止无效数据影响业务决策

**📊 开发效率提升**
- **规范统一**：团队开发中的数据标准统一
- **调试简化**：约束报错信息帮助快速定位问题
- **文档化**：约束本身就是数据结构的文档说明
- **质量保证**：减少因数据问题导致的系统故障

**核心记忆要点**：
- 数据完整性四大支柱：实体、参照、域、用户定义完整性
- 约束有层次：字段级→表级→数据库级，优先级递减
- 约束是保护：预防数据错误，保障业务逻辑
- 设计需平衡：严格性与灵活性、安全性与性能的权衡