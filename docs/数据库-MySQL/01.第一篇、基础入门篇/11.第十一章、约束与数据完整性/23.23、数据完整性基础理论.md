---
title: 23、数据完整性基础理论
---
## 📚 目录

1. [数据完整性基本概念](#1-数据完整性基本概念)
2. [实体完整性Entity Integrity基础概念](#2-实体完整性entity-integrity基础概念)
3. [域完整性Domain Integrity基础理解](#3-域完整性domain-integrity基础理解)
4. [参照完整性Referential Integrity入门](#4-参照完整性referential-integrity入门)
5. [用户定义完整性基础](#5-用户定义完整性基础)
6. [完整性约束分类层次](#6-完整性约束分类层次)
7. [完整性理论基础知识](#7-完整性理论基础知识)
8. [完整性约束入门理解](#8-完整性约束入门理解)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ 数据完整性基本概念


### 1.1 什么是数据完整性


**💡 核心定义**
数据完整性就是确保数据库中的数据是**正确的、一致的、有效的**。简单说，就是让数据库里的数据"靠谱"。

```
生活化理解：
就像一本通讯录：
- 每个人的手机号码格式要正确 (域完整性)
- 每个人都有唯一的身份证号 (实体完整性)  
- 联系人的公司必须在公司表里存在 (参照完整性)
- 年龄必须是正数且小于150 (用户定义完整性)

数据库的完整性就是确保这些"常识规则"得到遵守
```

### 1.2 为什么需要数据完整性


**🎯 重要作用**
```
数据质量保障：
- 防止垃圾数据进入数据库
- 确保业务逻辑的正确性
- 维护数据的一致性状态

系统稳定性：
- 避免因为脏数据导致程序错误
- 保证应用程序的正常运行
- 减少数据维护的工作量

业务价值保护：
- 确保业务决策基于正确数据
- 避免因数据错误造成的损失
- 提高数据的可信度
```

### 1.3 数据完整性的层次


```
数据完整性保障体系：

应用程序层 → 业务逻辑验证
    ↓
数据库层 → 约束规则检查  ← 我们主要学习的部分
    ↓  
存储层 → 物理数据保护
```

### 1.4 完整性vs其他概念的区别


**📊 概念对比**

| 概念 | **主要目的** | **检查时机** | **举例** |
|------|-------------|-------------|----------|
| **数据完整性** | 保证数据正确有效 | 数据操作时 | 年龄不能为负数 |
| **数据安全性** | 保护数据不被非法访问 | 访问控制时 | 用户权限验证 |
| **数据一致性** | 保证数据状态统一 | 事务处理时 | 转账金额平衡 |
| **数据可靠性** | 保证数据不丢失损坏 | 存储恢复时 | 备份恢复机制 |

---

## 2. 🏷️ 实体完整性Entity Integrity基础概念


### 2.1 什么是实体完整性


**💡 核心定义**
实体完整性是指**每一行数据都能被唯一标识**，确保表中不会有重复的记录。

```
生活化例子：
身份证系统的完整性：
- 每个人都有身份证号码 (不能为空)
- 每个身份证号码都是独一无二的 (不能重复)
- 通过身份证号可以准确找到这个人 (唯一标识)

数据库表的实体完整性就是这个道理
```

### 2.2 主键的作用


**🔑 主键（Primary Key）核心作用**
```
唯一标识：每行数据的"身份证"
- 值不能重复
- 值不能为空（NULL）
- 一个表只能有一个主键

快速查找：
- 数据库会为主键自动创建索引
- 通过主键查找数据最快
- 其他表可以通过主键来引用这行数据
```

**🔸 主键设计原则**
```sql
-- 单字段主键（推荐）
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- 自增ID作主键
    name VARCHAR(50),
    email VARCHAR(100)
);

-- 复合主键（多字段组合）
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 两个字段组合做主键
);

-- 为什么推荐单字段主键？
-- 1. 简单明了，容易理解
-- 2. 占用空间小，索引效率高  
-- 3. 外键引用方便
```

### 2.3 实体完整性约束规则


**✅ 完整性规则**
```
规则1：主键不能为空
- 原因：空值无法唯一标识一行数据
- 实现：PRIMARY KEY约束自动包含NOT NULL

规则2：主键值必须唯一
- 原因：重复值无法区分不同的实体
- 实现：PRIMARY KEY约束自动创建唯一索引

规则3：主键值不应该改变
- 原因：改变主键可能影响其他表的外键引用
- 建议：使用无业务意义的自增ID
```

### 2.4 实体完整性的实现


**🔧 MySQL中的实现方式**
```sql
-- 方式1：创建表时定义主键
CREATE TABLE students (
    student_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT
);

-- 方式2：创建表后添加主键
CREATE TABLE teachers (
    teacher_id INT,
    name VARCHAR(50),
    subject VARCHAR(30)
);
ALTER TABLE teachers ADD PRIMARY KEY (teacher_id);

-- 方式3：使用唯一约束（替代方案）
CREATE TABLE courses (
    course_code VARCHAR(10) UNIQUE NOT NULL,  -- 唯一且非空
    course_name VARCHAR(100),
    credits INT
);
```

### 2.5 实体完整性违反的情况


**❌ 常见违反情况**
```sql
-- 情况1：插入重复的主键值
INSERT INTO students VALUES (1, 'Alice', 20);
INSERT INTO students VALUES (1, 'Bob', 21);   -- 错误：主键重复
-- Error: Duplicate entry '1' for key 'PRIMARY'

-- 情况2：插入空的主键值
INSERT INTO students VALUES (NULL, 'Charlie', 22);  -- 错误：主键为空
-- Error: Column 'student_id' cannot be null

-- 情况3：更新导致主键重复
UPDATE students SET student_id = 1 WHERE name = 'Bob';  -- 错误：会产生重复主键
```

**✅ 正确的操作方式**
```sql
-- 正确插入（自增主键）
INSERT INTO students (name, age) VALUES ('Alice', 20);    -- 让ID自动增长
INSERT INTO students (name, age) VALUES ('Bob', 21);

-- 正确插入（手动指定不重复的主键）
INSERT INTO students VALUES (10, 'Charlie', 22);
INSERT INTO students VALUES (11, 'David', 23);
```

---

## 3. 📏 域完整性Domain Integrity基础理解


### 3.1 什么是域完整性


**💡 核心定义**
域完整性是指**每个字段的值都符合该字段定义的数据类型和取值范围**。简单说，就是确保每个"格子"里放的都是"合适的东西"。

```
生活化理解：
就像表格填写要求：
- "年龄"栏只能填数字，不能填文字
- "性别"栏只能填"男"或"女"  
- "邮箱"栏必须符合邮箱格式
- "电话"栏必须是11位数字

域完整性就是确保每个字段都按"填写要求"来
```

### 3.2 域完整性的组成部分


**🔸 数据类型约束**
```sql
-- 数据类型定义了字段能存储什么样的数据
CREATE TABLE products (
    id INT,                    -- 只能存整数
    name VARCHAR(100),         -- 只能存最长100个字符的字符串
    price DECIMAL(10,2),       -- 只能存最多10位、小数点后2位的数字
    create_date DATE,          -- 只能存日期格式数据
    is_active BOOLEAN          -- 只能存true/false
);
```

**🔸 取值范围约束**
```sql
-- CHECK约束定义字段的有效取值范围
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 65),    -- 年龄必须在18-65之间
    salary DECIMAL(10,2) CHECK (salary > 0),    -- 工资必须大于0
    gender ENUM('Male', 'Female', 'Other'),     -- 性别只能是这三个值
    status SET('Active', 'Inactive', 'Pending') -- 状态可以是这些值的组合
);
```

**🔸 空值约束**
```sql
-- NOT NULL约束确保重要字段不能为空
CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,        -- 姓名不能为空
    email VARCHAR(100) NOT NULL,      -- 邮箱不能为空
    phone VARCHAR(20),                -- 电话可以为空
    address TEXT                      -- 地址可以为空
);
```

### 3.3 MySQL中的域完整性实现


**📋 常用数据类型及其约束**

```sql
-- 数值类型的域约束
TINYINT     -- -128 到 127 (有符号) 或 0 到 255 (无符号)
SMALLINT    -- -32768 到 32767 或 0 到 65535  
INT         -- -2147483648 到 2147483647 或 0 到 4294967295
BIGINT      -- 更大的整数范围

-- 字符类型的域约束
CHAR(10)    -- 固定长度10个字符
VARCHAR(255) -- 可变长度，最多255个字符
TEXT        -- 大文本，最多65535个字符

-- 日期时间类型的域约束
DATE        -- 日期：'1000-01-01' 到 '9999-12-31'
TIME        -- 时间：'-838:59:59' 到 '838:59:59'  
DATETIME    -- 日期时间：'1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'
TIMESTAMP   -- 时间戳：'1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC
```

### 3.4 域完整性约束示例


**✅ 正确的域约束设计**
```sql
-- 电商商品表的域约束设计
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 商品名称：必填，长度限制
    name VARCHAR(200) NOT NULL,
    
    -- 价格：必须大于0，精确到分
    price DECIMAL(10,2) NOT NULL CHECK (price > 0),
    
    -- 库存：不能为负数
    stock INT NOT NULL DEFAULT 0 CHECK (stock >= 0),
    
    -- 商品状态：只能是特定值
    status ENUM('active', 'inactive', 'discontinued') NOT NULL DEFAULT 'active',
    
    -- 创建时间：自动设置当前时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 更新时间：自动更新
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 3.5 域完整性违反的常见情况


**❌ 典型违反示例**
```sql
-- 错误1：数据类型不匹配
INSERT INTO products (name, price, stock) 
VALUES ('iPhone', 'expensive', 100);  -- price字段应该是数字，不是字符串
-- Error: Incorrect decimal value: 'expensive' for column 'price'

-- 错误2：超出字段长度限制  
INSERT INTO products (name, price, stock)
VALUES (REPEAT('very long product name ', 50), 5999.99, 50);  -- name太长
-- Error: Data too long for column 'name'

-- 错误3：违反CHECK约束
INSERT INTO products (name, price, stock)
VALUES ('iPhone', -100, 50);  -- 价格不能为负数
-- Error: Check constraint 'products_chk_1' is violated

-- 错误4：违反NOT NULL约束
INSERT INTO products (price, stock) VALUES (999, 10);  -- name字段缺失
-- Error: Field 'name' doesn't have a default value
```

### 3.6 提高域完整性的技巧


**🔧 实用技巧**
```sql
-- 技巧1：使用合适的数据类型
-- 不要什么都用VARCHAR，选择最合适的类型
age TINYINT UNSIGNED,              -- 年龄用小整数就够了
is_vip BOOLEAN,                    -- 是否VIP用布尔型
country_code CHAR(2),              -- 国家代码固定2位
description TEXT                   -- 长文本用TEXT

-- 技巧2：设置合理的默认值
status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
is_deleted BOOLEAN DEFAULT FALSE

-- 技巧3：使用CHECK约束添加业务规则
email VARCHAR(100) CHECK (email LIKE '%@%.%'),  -- 简单邮箱格式检查
phone VARCHAR(20) CHECK (phone REGEXP '^[0-9+\\-\\s]+$'),  -- 电话号码格式
birth_date DATE CHECK (birth_date <= CURDATE())  -- 出生日期不能是未来
```

---

## 4. 🔗 参照完整性Referential Integrity入门


### 4.1 什么是参照完整性


**💡 核心定义**
参照完整性是指**表与表之间的引用关系必须保持一致**。简单说，就是确保"关联的数据确实存在"。

```
生活化理解：
就像图书馆的借书系统：
- 借书记录中的读者ID，必须在读者表中真实存在
- 借书记录中的图书ID，必须在图书表中真实存在  
- 不能出现"幽灵读者"借书或借"不存在的书"

参照完整性就是维护这种"引用关系"的正确性
```

### 4.2 外键的基本概念


**🔑 外键（Foreign Key）说明**
```sql
-- 外键是实现参照完整性的主要机制
-- 外键字段的值必须在被引用表的主键中存在

示例关系：
学生表 (students)     课程表 (courses)     选课表 (enrollments)
+----------+         +----------+         +-------------+
| id (PK)  |         | id (PK)  |         | student_id  | ← 外键，引用students.id
| name     |         | name     |         | course_id   | ← 外键，引用courses.id  
| age      |         | credits  |         | grade       |
+----------+         +----------+         +-------------+

关系说明：
- student_id必须在students表的id字段中存在
- course_id必须在courses表的id字段中存在
- 这样确保选课记录引用的都是真实的学生和课程
```

### 4.3 外键约束的创建


**🔧 创建外键约束**
```sql
-- 创建主表（被引用表）
CREATE TABLE departments (
    dept_id INT AUTO_INCREMENT PRIMARY KEY,
    dept_name VARCHAR(50) NOT NULL,
    location VARCHAR(100)
);

CREATE TABLE employees (
    emp_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_name VARCHAR(50) NOT NULL,
    dept_id INT,
    salary DECIMAL(10,2),
    
    -- 创建外键约束
    CONSTRAINT fk_emp_dept 
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);

-- 或者在创建表后添加外键
ALTER TABLE employees 
ADD CONSTRAINT fk_emp_dept 
FOREIGN KEY (dept_id) REFERENCES departments(dept_id);
```

### 4.4 外键约束的行为规则


**🔸 引用动作（Referential Actions）**
当主表数据发生变化时，外键表如何响应：

```sql
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    
    FOREIGN KEY (customer_id) REFERENCES customers(id)
    ON DELETE CASCADE        -- 删除客户时，删除其所有订单
    ON UPDATE CASCADE        -- 更新客户ID时，同步更新订单中的客户ID
);
```

**📋 引用动作类型**

| 动作类型 | **含义** | **使用场景** | **效果** |
|---------|---------|-------------|----------|
| **CASCADE** | 级联操作 | 强关联关系 | 主表变化时，从表同步变化 |
| **SET NULL** | 设为空值 | 弱关联关系 | 主表删除时，从表外键设为NULL |
| **SET DEFAULT** | 设为默认值 | 有默认关联 | 主表删除时，从表外键设为默认值 |
| **RESTRICT** | 限制操作 | 保护性要求高 | 有外键引用时，禁止删除主表记录 |
| **NO ACTION** | 无动作 | 延迟检查 | 事务结束时才检查完整性 |

### 4.5 参照完整性违反情况


**❌ 典型违反示例**
```sql
-- 假设departments表中只有dept_id为1和2的部门

-- 错误1：插入不存在的部门ID
INSERT INTO employees (emp_name, dept_id, salary) 
VALUES ('John', 999, 5000);  -- dept_id=999在departments表中不存在
-- Error: Cannot add or update a child row: a foreign key constraint fails

-- 错误2：删除被引用的部门
DELETE FROM departments WHERE dept_id = 1;  -- 如果有员工属于部门1
-- Error: Cannot delete or update a parent row: a foreign key constraint fails

-- 错误3：更新主键导致外键失效
UPDATE departments SET dept_id = 100 WHERE dept_id = 1;  -- 如果没设置CASCADE
-- Error: Cannot delete or update a parent row: a foreign key constraint fails
```

### 4.6 自引用外键


**🔄 自引用关系**
有时候表需要引用自己，比如员工表中的上级关系：

```sql
-- 员工表的自引用外键
CREATE TABLE employees (
    emp_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_name VARCHAR(50) NOT NULL,
    manager_id INT,                    -- 上级经理的ID
    
    -- 自引用外键：manager_id引用本表的emp_id
    FOREIGN KEY (manager_id) REFERENCES employees(emp_id)
    ON DELETE SET NULL                 -- 经理离职时，下属的manager_id设为NULL
);

-- 插入数据示例
INSERT INTO employees (emp_name, manager_id) VALUES ('CEO', NULL);      -- 最高领导
INSERT INTO employees (emp_name, manager_id) VALUES ('CTO', 1);         -- CTO的上级是CEO
INSERT INTO employees (emp_name, manager_id) VALUES ('开发经理', 2);     -- 开发经理的上级是CTO
INSERT INTO employees (emp_name, manager_id) VALUES ('程序员A', 3);      -- 程序员的上级是开发经理
```

---

## 5. 👤 用户定义完整性基础


### 5.1 什么是用户定义完整性


**💡 核心定义**
用户定义完整性是指**根据具体业务需求自定义的数据约束规则**。前面三种完整性是数据库通用的，而用户定义完整性是针对特定业务场景的。

```
简单理解：
前面的完整性像"基本法律"：
- 实体完整性：每个人要有身份证（通用规则）
- 域完整性：年龄要是数字（数据格式规则）  
- 参照完整性：部门ID要真实存在（引用规则）

用户定义完整性像"公司规章制度"：
- 员工年龄必须18-65岁（业务规则）
- 工资不能超过老板工资的50%（业务逻辑）
- 请假天数一年不能超过30天（业务限制）
```

### 5.2 用户定义完整性的实现方式


**🔸 CHECK约束实现**
```sql
-- 业务规则约束示例
CREATE TABLE accounts (
    account_id INT AUTO_INCREMENT PRIMARY KEY,
    account_name VARCHAR(50) NOT NULL,
    balance DECIMAL(15,2) NOT NULL DEFAULT 0,
    account_type ENUM('checking', 'savings', 'credit') NOT NULL,
    
    -- 用户定义的业务规则
    CHECK (balance >= -10000),                    -- 透支不能超过1万
    CHECK (account_type = 'credit' OR balance >= 0), -- 非信用账户余额不能为负
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 创建时间不能是未来时间
    CHECK (created_at <= CURRENT_TIMESTAMP)
);
```

**🔸 触发器实现复杂约束**
```sql
-- 复杂的业务规则用触发器实现
DELIMITER //
CREATE TRIGGER check_salary_limit
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    DECLARE max_salary DECIMAL(10,2);
    
    -- 获取部门最高工资
    SELECT MAX(salary) INTO max_salary 
    FROM employees 
    WHERE dept_id = NEW.dept_id;
    
    -- 新员工工资不能超过部门最高工资的150%
    IF NEW.salary > max_salary * 1.5 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '工资不能超过部门最高工资的150%';
    END IF;
END//
DELIMITER ;
```

### 5.3 常见的用户定义完整性规则


**🎯 业务逻辑约束**
```sql
-- 电商系统的业务约束
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    order_status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled'),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 业务规则约束
    CHECK (total_amount > 0),                           -- 订单金额必须大于0
    CHECK (discount_amount >= 0),                       -- 折扣不能为负数
    CHECK (discount_amount <= total_amount),            -- 折扣不能超过订单金额
    CHECK (order_date <= CURRENT_TIMESTAMP),           -- 订单时间不能是未来
    
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 学生选课系统的业务约束
CREATE TABLE enrollments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    student_id INT NOT NULL,
    course_id INT NOT NULL,
    semester VARCHAR(20) NOT NULL,
    grade DECIMAL(3,1),
    
    -- 业务规则约束
    CHECK (grade IS NULL OR (grade >= 0 AND grade <= 100)), -- 成绩在0-100之间
    CHECK (semester REGEXP '^[0-9]{4}-(春|夏|秋|冬)$'),      -- 学期格式检查
    
    -- 复合约束：同一学期同一学生不能重复选同一门课
    UNIQUE KEY unique_enrollment (student_id, course_id, semester),
    
    FOREIGN KEY (student_id) REFERENCES students(id),
    FOREIGN KEY (course_id) REFERENCES courses(id)
);
```

### 5.4 用户定义完整性的设计原则


**🎯 设计原则**
```
原则1：业务导向
- 约束规则要反映真实的业务需求
- 不要设置过于严格或脱离实际的约束
- 考虑业务流程的特殊情况

原则2：性能平衡
- 复杂约束可能影响插入更新性能
- 在数据质量和性能之间找平衡
- 考虑使用应用层验证分担压力

原则3：维护便利
- 约束规则要容易理解和维护
- 避免过于复杂的逻辑判断
- 为约束添加清晰的命名和注释
```

**💡 实用建议**
```sql
-- 好的约束命名
CONSTRAINT chk_employee_age CHECK (age BETWEEN 18 AND 65),
CONSTRAINT chk_order_amount CHECK (total_amount > 0),
CONSTRAINT uk_employee_email UNIQUE (email),

-- 添加注释说明
ALTER TABLE products ADD CONSTRAINT chk_price 
CHECK (price > 0) 
COMMENT '商品价格必须大于0';
```

---

## 6. 📊 完整性约束分类层次


### 6.1 完整性约束的分类体系


数据库完整性约束按照不同维度可以进行多层次分类，理解这个分类体系有助于系统掌握约束知识。

```
完整性约束分类体系：

按约束范围分类：
┌─ 表级约束 ─┬─ 单表约束（主键、唯一、检查）
│           └─ 多表约束（外键）
└─ 字段级约束 ─── 单字段约束（非空、数据类型）

按约束时机分类：
┌─ 立即检查 ── 操作时立即验证
└─ 延迟检查 ── 事务提交时验证

按约束内容分类：
┌─ 结构约束 ── 数据类型、长度限制
├─ 值约束 ──── CHECK条件、枚举值
├─ 唯一约束 ── 主键、唯一键
└─ 引用约束 ── 外键约束
```

### 6.2 约束的层次结构


**🏗️ 约束层次关系**
```
                    完整性约束
                        |
        ┌───────────────┼───────────────┐
        |               |               |
    实体完整性      域完整性        参照完整性
        |               |               |
    ┌───┴───┐       ┌───┴───┐       ┌───┴───┐
主键约束 唯一约束  类型约束 值约束  外键约束 自引用约束
    |       |       |       |       |       |
 AUTO_   UNIQUE   NOT    CHECK   FOREIGN  SELF
INCREMENT         NULL           KEY      REFERENCE
```

### 6.3 约束级别分类


**📋 按严格程度分类**

| 约束级别 | **严格程度** | **典型约束** | **违反后果** | **适用场景** |
|---------|-------------|-------------|-------------|-------------|
| **强制约束** | 必须遵守 | PRIMARY KEY, FOREIGN KEY | 操作被拒绝 | 核心业务数据 |
| **建议约束** | 应该遵守 | CHECK约束 | 警告或拒绝 | 业务规则验证 |
| **弱约束** | 可以违反 | 应用层验证 | 记录日志 | 辅助性检查 |

### 6.4 约束的组合使用


**🔗 约束组合模式**
```sql
-- 完整的约束组合示例：用户表
CREATE TABLE users (
    -- 实体完整性：主键约束
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    
    -- 域完整性：数据类型 + NOT NULL + CHECK约束
    username VARCHAR(50) NOT NULL UNIQUE 
        CHECK (LENGTH(username) >= 3),     -- 用户名至少3个字符
    
    email VARCHAR(100) NOT NULL UNIQUE 
        CHECK (email LIKE '%@%.%'),        -- 邮箱格式检查
    
    age TINYINT UNSIGNED 
        CHECK (age >= 13 AND age <= 120),  -- 年龄合理范围
    
    -- 用户定义完整性：复杂业务规则
    account_status ENUM('active', 'inactive', 'suspended') DEFAULT 'active',
    registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP NULL,
    
    -- 业务逻辑约束
    CHECK (last_login IS NULL OR last_login >= registration_date),  -- 最后登录不能早于注册
    
    -- 索引优化
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (account_status)
);

-- 用户角色关系表（参照完整性）
CREATE TABLE user_roles (
    user_id INT,
    role_id INT,
    assigned_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (user_id, role_id),  -- 复合主键
    
    -- 参照完整性约束
    FOREIGN KEY (user_id) REFERENCES users(user_id) 
        ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(role_id) 
        ON DELETE CASCADE ON UPDATE CASCADE
);
```

### 6.5 约束优先级和冲突处理


**⚖️ 约束检查顺序**
```
MySQL约束检查优先级：

1. 数据类型约束 (最高优先级)
   ↓
2. NOT NULL约束  
   ↓
3. CHECK约束
   ↓
4. 唯一性约束（UNIQUE、PRIMARY KEY）
   ↓
5. 外键约束 (最低优先级)

示例：
插入数据时，首先检查数据类型是否匹配，
然后检查是否为空，再检查CHECK条件，
最后检查是否违反唯一性和外键约束
```

---

## 7. 🎓 完整性理论基础知识


### 7.1 完整性理论的发展历程


**📚 理论发展脉络**
```
1970年代：关系模型理论奠定基础
- Edgar F. Codd提出关系模型
- 定义了实体完整性和参照完整性的基本概念
- 奠定了现代数据库理论基础

1980年代：约束理论完善发展  
- 扩展了域完整性的定义
- 提出了更丰富的约束类型
- 开始关注约束的性能影响

1990年代至今：实践应用深化
- 各种数据库产品实现约束机制
- 约束与性能平衡的研究
- 分布式环境下的完整性保障
```

### 7.2 完整性的数学基础


**📐 理论模型**
```
关系模型中的完整性定义：

关系R(A1, A2, ..., An)的完整性约束：

实体完整性：
∀ t ∈ R: t[K] ≠ NULL  (主键不能为空)
∀ t1, t2 ∈ R: t1 ≠ t2 → t1[K] ≠ t2[K]  (主键值唯一)

域完整性：  
∀ t ∈ R, ∀ Ai: t[Ai] ∈ Dom(Ai)  (属性值属于定义域)

参照完整性：
∀ t ∈ R: t[FK] = NULL OR ∃ s ∈ S: t[FK] = s[PK]
(外键要么为空，要么在被引用表中存在)

用数学语言描述看起来复杂，但理解起来很简单：
就是用严格的数学表达式描述我们前面讲的约束规则
```

### 7.3 完整性的ACID关系


**🔗 与事务ACID特性的关系**
```
ACID特性与完整性的关系：

Atomicity (原子性)：
- 要么所有约束检查都通过，要么全部失败
- 不会出现部分数据满足约束、部分数据违反约束的情况

Consistency (一致性)：
- 事务执行前后，数据库都必须满足所有完整性约束
- 这是完整性约束存在的根本目的

Isolation (隔离性)：
- 并发事务不能看到违反完整性约束的中间状态
- 约束检查在事务内部进行

Durability (持久性)：
- 一旦事务提交，完整性约束的效果必须持久保存
- 约束信息本身也要持久存储
```

### 7.4 完整性与数据库设计理论


**🏗️ 范式理论中的完整性**
```
第一范式 (1NF)：
- 要求每个属性都是不可分割的原子值
- 对应域完整性的基本要求

第二范式 (2NF)：
- 消除部分函数依赖
- 间接保证了实体完整性

第三范式 (3NF)：
- 消除传递函数依赖  
- 减少数据冗余，间接提高完整性

BCNF范式：
- 更严格的第三范式
- 进一步保证数据的一致性和完整性

范式化的本质就是通过消除冗余来保证数据完整性
```

### 7.5 分布式环境下的完整性


**🌐 分布式完整性挑战**
```
单机数据库 vs 分布式数据库：

单机环境：
- 所有约束在一个数据库内检查
- 事务保证约束的原子性检查
- 实现相对简单

分布式环境：  
- 数据分散在多个节点
- 跨节点的参照完整性检查复杂
- 网络分区时的一致性保证困难

解决方案：
- 最终一致性：允许短暂的不一致
- 分布式事务：2PC、3PC协议
- 约束下沉：在应用层保证完整性
```

---

## 8. 🔧 完整性约束入门理解


### 8.1 约束的生命周期


**🔄 约束从创建到生效的过程**
```
约束生命周期：

设计阶段 → 定义业务规则，确定需要的约束类型
    ↓
创建阶段 → 在CREATE TABLE或ALTER TABLE中定义约束
    ↓  
验证阶段 → 数据库检查现有数据是否符合约束
    ↓
生效阶段 → 约束开始对后续操作生效
    ↓
维护阶段 → 根据业务变化调整约束
    ↓
删除阶段 → 不再需要时删除约束
```

### 8.2 约束的性能影响


**⚡ 性能影响分析**
```sql
-- 约束对性能的影响：

INSERT操作影响：
- 主键约束：需要检查唯一性 (+10-20%耗时)
- 外键约束：需要检查引用表存在性 (+20-50%耗时)  
- CHECK约束：需要执行条件判断 (+5-15%耗时)

UPDATE操作影响：
- 主键更新：需要更新所有外键引用 (影响很大)
- 外键更新：需要检查新值的有效性
- 约束字段更新：需要重新验证约束条件

DELETE操作影响：
- 被外键引用的记录：需要检查CASCADE规则
- 触发器约束：可能需要执行复杂逻辑
```

**🎯 性能优化策略**
```sql
-- 策略1：合理使用索引支持约束
-- 外键字段添加索引，提高引用检查速度
CREATE INDEX idx_emp_dept ON employees(dept_id);

-- 策略2：批量操作时临时禁用约束检查
SET foreign_key_checks = 0;  -- 临时禁用外键检查
-- 执行批量导入操作
LOAD DATA INFILE 'data.csv' INTO TABLE employees;
SET foreign_key_checks = 1;  -- 重新启用外键检查

-- 策略3：使用合适的引用动作
-- CASCADE操作比RESTRICT检查更快
FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE
```

### 8.3 约束的调试和故障排除


**🔍 常见问题诊断**
```sql
-- 查看表的所有约束
SELECT 
    CONSTRAINT_NAME,
    CONSTRAINT_TYPE,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM information_schema.TABLE_CONSTRAINTS tc
LEFT JOIN information_schema.KEY_COLUMN_USAGE kcu
    ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
WHERE tc.TABLE_SCHEMA = 'your_database'
    AND tc.TABLE_NAME = 'your_table';

-- 查看外键约束详情
SELECT 
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME,
    UPDATE_RULE,
    DELETE_RULE
FROM information_schema.REFERENTIAL_CONSTRAINTS rc
JOIN information_schema.KEY_COLUMN_USAGE kcu
    ON rc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
WHERE rc.CONSTRAINT_SCHEMA = 'your_database';
```

**🛠️ 故障排除步骤**
```
步骤1：确定约束类型
- 查看错误信息确定是哪种约束失败
- 使用information_schema查看约束定义

步骤2：分析约束条件  
- 理解约束的具体要求
- 检查数据是否确实违反了约束

步骤3：定位问题数据
- 找出违反约束的具体记录
- 分析为什么会出现这种数据

步骤4：选择解决方案
- 修改数据使其符合约束
- 调整约束条件适应业务需求
- 临时禁用约束完成操作后重新启用
```

### 8.4 约束设计的最佳实践


**🎯 设计最佳实践**
```sql
-- 1. 约束命名规范
-- 使用有意义的约束名称，方便维护
CONSTRAINT pk_user_id PRIMARY KEY (user_id),
CONSTRAINT uk_user_email UNIQUE (email),
CONSTRAINT fk_user_dept FOREIGN KEY (dept_id) REFERENCES departments(id),
CONSTRAINT chk_user_age CHECK (age >= 18),

-- 2. 合理的默认值设计
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
status ENUM('active', 'inactive') DEFAULT 'active',
is_deleted BOOLEAN DEFAULT FALSE,

-- 3. 渐进式约束实施
-- 先在新表上测试约束效果
-- 确认无问题后再应用到生产表
-- 必要时分步骤添加约束
```

### 8.5 约束与业务逻辑的平衡


**⚖️ 平衡原则**
```
数据库约束 vs 应用程序验证：

数据库约束优势：
- 无法绕过，保证最后防线
- 所有应用都能受益
- 数据一致性有保障

应用程序验证优势：
- 灵活性高，容易修改
- 可以提供友好的错误提示
- 性能影响相对较小

最佳实践：
- 核心业务规则用数据库约束
- 用户体验相关用应用验证
- 两者结合使用，形成双重保障
```

**💡 实用建议**
```sql
-- 核心约束放数据库（必须保证）
ALTER TABLE orders ADD CONSTRAINT chk_amount 
CHECK (total_amount > 0);  -- 订单金额必须大于0

-- 用户体验约束放应用层（友好提示）
-- 应用程序中验证：用户名长度、密码复杂度、邮箱格式等
-- 数据库中保留基本的类型和非空约束作为底线
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基础概念


**🔸 四大完整性类型**
```
实体完整性 (Entity Integrity)：
✓ 核心：每行数据能被唯一标识
✓ 实现：主键约束 (PRIMARY KEY)
✓ 规则：主键不能为空、不能重复

域完整性 (Domain Integrity)：  
✓ 核心：每个字段的值都符合定义要求
✓ 实现：数据类型、NOT NULL、CHECK约束
✓ 规则：数据类型正确、值在有效范围内

参照完整性 (Referential Integrity)：
✓ 核心：表间引用关系保持一致
✓ 实现：外键约束 (FOREIGN KEY)  
✓ 规则：外键值必须在被引用表中存在

用户定义完整性：
✓ 核心：满足特定业务规则要求
✓ 实现：CHECK约束、触发器
✓ 规则：根据业务需求自定义
```

### 9.2 约束分类体系掌握


**📊 多维度分类理解**
```
按作用范围：全局约束 vs 局部约束
按检查时机：立即检查 vs 延迟检查  
按严格程度：强制约束 vs 建议约束
按实现层次：数据库约束 vs 应用约束
```

### 9.3 实际应用技能


**🛠️ 核心操作技能**
```sql
-- 约束创建语法
CREATE TABLE table_name (
    column1 datatype CONSTRAINT_TYPE,
    column2 datatype CONSTRAINT_TYPE,
    CONSTRAINT constraint_name CONSTRAINT_TYPE (columns)
);

-- 约束管理语法
ALTER TABLE table_name ADD CONSTRAINT constraint_name ...;
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
ALTER TABLE table_name MODIFY COLUMN column_name ...;

-- 约束查询语法
SHOW CREATE TABLE table_name;
SELECT * FROM information_schema.TABLE_CONSTRAINTS;
```

**📋 设计实践要点**
```
约束设计检查清单：

✅ 每个表都有合适的主键
✅ 重要字段添加NOT NULL约束
✅ 外键关系正确建立
✅ CHECK约束覆盖关键业务规则
✅ 约束命名规范统一
✅ 考虑约束对性能的影响
✅ 建立约束故障排除机制
```

### 9.4 故障处理能力


**🔍 问题诊断流程**
```
1. 识别约束类型
   - 根据错误信息判断是哪种约束失败
   
2. 定位问题数据  
   - 找出具体违反约束的数据记录
   
3. 分析根本原因
   - 是数据问题还是约束设计问题
   
4. 选择解决方案
   - 修正数据、调整约束、或临时禁用
   
5. 验证修复效果
   - 确保问题彻底解决且不影响其他功能
```

### 9.5 进阶学习方向


**🚀 深入学习路径**
```
基础掌握后的进阶方向：

性能优化：
- 约束与索引的关系
- 大数据量下的约束性能调优
- 批量操作中的约束处理策略

高级约束：
- 触发器实现复杂约束
- 存储过程中的完整性检查
- 分区表的约束处理

分布式完整性：
- 跨库外键处理
- 分布式事务中的完整性保证
- 微服务架构下的数据一致性
```

**核心记忆**：
- 数据完整性是数据库的"质量保证体系"
- 四大完整性各有分工，共同保证数据质量
- 约束是实现完整性的主要工具，要合理设计和使用
- 完整性与性能需要平衡，不能一味追求严格约束
- 理解完整性理论有助于设计更好的数据库结构