---
title: 29、数据库约束与完整性总结
---
##  📚 目录

1. [约束与完整性概述](#1-约束与完整性概述)
2. [主键约束PRIMARY KEY详解](#2-主键约束PRIMARY-KEY详解)
3. [外键约束FOREIGN KEY管理](#3-外键约束FOREIGN-KEY管理)
4. [唯一约束UNIQUE设计](#4-唯一约束UNIQUE设计)
5. [非空约束NOT NULL处理](#5-非空约束NOT-NULL处理)
6. [默认值约束DEFAULT设置](#6-默认值约束DEFAULT设置)
7. [检查约束CHECK应用](#7-检查约束CHECK应用)
8. [约束命名规范与管理](#8-约束命名规范与管理)
9. [核心要点总结](#9-核心要点总结)

---

##  1. 🔒 约束与完整性概述


## # 1.1 什么是数据库约束


**🔸 通俗理解**
数据库约束就像生活中的"规则"，比如：
- 身份证号必须唯一（唯一约束）
- 每个人必须有姓名（非空约束）
- 年龄必须是正数（检查约束）
- 学生必须属于某个班级（外键约束）

> 💡 **核心理解**  
> 约束是数据库"自我保护"的机制，防止错误数据进入，确保数据的准确性和一致性。

## # 1.2 完整性的分类


```
数据完整性体系：
┌─────────────────────────────────────┐
│            数据完整性                │
├─────────────┬─────────────┬─────────┤
│  实体完整性  │  域完整性   │ 参照完整性 │
│Entity       │Domain      │Referential│
│Integrity    │Integrity   │Integrity  │
├─────────────┼─────────────┼─────────┤
│主键约束      │非空约束      │外键约束   │
│PRIMARY KEY  │NOT NULL    │FOREIGN   │
│            │CHECK约束    │KEY       │
│            │DEFAULT约束  │          │
└─────────────┴─────────────┴─────────┘
```

**🔸 三大完整性详解**

| 完整性类型 | **保证什么** | **通俗解释** | **实现方式** |
|-----------|-------------|-------------|-------------|
| 🎯 **实体完整性** | `每行数据唯一可识别` | `每个人都有唯一身份证` | `主键约束` |
| 📊 **域完整性** | `列数据符合要求` | `年龄不能是负数` | `类型、CHECK、NOT NULL` |
| 🔗 **参照完整性** | `关联数据保持一致` | `学生必须属于存在的班级` | `外键约束` |

## # 1.3 约束的作用机制


```
约束检查时机：
INSERT ──▶ 新增时检查 ──▶ 违反约束 ──▶ 操作失败
UPDATE ──▶ 修改时检查 ──▶ 通过约束 ──▶ 操作成功  
DELETE ──▶ 删除时检查 ──▶ 外键影响 ──▶ 级联处理
```

---

##  2. 🎯 主键约束PRIMARY KEY详解


## # 2.1 主键约束的核心概念


**🔸 什么是主键**
主键就像每个人的身份证号码，具有以下特点：
- **唯一性**：整个表中不能重复
- **非空性**：不能为空值
- **不变性**：一般不建议修改

> 🧠 **记忆口诀**  
> "主键约束三特点：唯一非空不能变"

## # 2.2 主键约束创建方式


**🔸 创建表时定义主键**

```sql
-- 方式1：列级主键约束
CREATE TABLE users (
    id INT PRIMARY KEY,           -- 单列主键
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100)
);

-- 方式2：表级主键约束  
CREATE TABLE orders (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 复合主键
);

-- 方式3：命名主键约束
CREATE TABLE students (
    student_id INT,
    student_name VARCHAR(50),
    CONSTRAINT pk_students PRIMARY KEY (student_id)
);
```

**🔸 添加主键约束**

```sql
-- 为已存在的表添加主键
ALTER TABLE users ADD PRIMARY KEY (id);

-- 为已存在的表添加命名主键
ALTER TABLE users ADD CONSTRAINT pk_users PRIMARY KEY (id);
```

## # 2.3 主键选择策略


**🔸 主键类型对比**

| 主键类型 | **特点** | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|---------|-------------|
| 🔢 **自增整数** | `AUTO_INCREMENT` | `简单、性能好` | `不适合分布式` | `单机应用` |
| 🎲 **UUID** | `全局唯一标识` | `分布式友好` | `存储空间大、无序` | `分布式系统` |
| 📧 **自然主键** | `业务字段` | `有业务含义` | `可能变更、性能差` | `小表、稳定业务` |
| 🏷️ **组合主键** | `多列组合` | `表达复杂关系` | `维护复杂、性能差` | `关联表` |

```sql
-- 自增主键示例
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50)
);

-- UUID主键示例
CREATE TABLE sessions (
    session_id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
    user_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## # 2.4 主键约束管理


**🔸 查看主键信息**

```sql
-- 查看表的主键约束
SHOW INDEX FROM users WHERE Key_name = 'PRIMARY';

-- 查看约束详细信息
SELECT * FROM information_schema.KEY_COLUMN_USAGE 
WHERE TABLE_NAME = 'users' AND CONSTRAINT_NAME = 'PRIMARY';
```

**🔸 删除和修改主键**

```sql
-- 删除主键约束
ALTER TABLE users DROP PRIMARY KEY;

-- 修改主键（先删除再添加）
ALTER TABLE users DROP PRIMARY KEY;
ALTER TABLE users ADD PRIMARY KEY (new_id);
```

---

##  3. 🔗 外键约束FOREIGN KEY管理


## # 3.1 外键约束核心概念


**🔸 什么是外键**
外键就像"关系纽带"，连接两个表之间的关系：

> 🌰 **生活类比**  
> 就像学生证上的班级编号，必须是学校真实存在的班级。如果班级不存在，就不能发放学生证。

```sql
-- 典型的外键关系
CREATE TABLE classes (
    class_id INT PRIMARY KEY,
    class_name VARCHAR(50)
);

CREATE TABLE students (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(50),
    class_id INT,
    FOREIGN KEY (class_id) REFERENCES classes(class_id)
);
```

## # 3.2 参照完整性机制


**🔸 参照完整性规则**

```
参照完整性保证：
父表(被引用表) ←──── 外键关系 ──── 子表(引用表)
   classes                        students
     │                              │
     └──── class_id必须存在 ────────┘
           才能被students引用
```

**🔸 外键约束的限制**

| 操作 | **对父表的限制** | **对子表的限制** | **解决方案** |
|------|----------------|----------------|-------------|
| 🗑️ **删除** | `被引用的记录不能删除` | `无限制` | `级联删除/设置NULL` |
| ✏️ **修改** | `被引用的字段值不能改` | `外键值必须存在于父表` | `级联更新` |
| ➕ **插入** | `无限制` | `外键值必须存在于父表` | `先插入父表数据` |

## # 3.3 外键约束的级联操作


**🔸 级联选项详解**

```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(50),
    class_id INT,
    FOREIGN KEY (class_id) REFERENCES classes(class_id)
        ON DELETE CASCADE      -- 删除班级时，删除所有该班级学生
        ON UPDATE CASCADE      -- 修改班级ID时，同步修改学生表
);
```

**🔸 级联动作类型**

| 级联动作 | **含义** | **使用场景** | **注意事项** |
|---------|---------|-------------|-------------|
| 🔄 **CASCADE** | `级联操作` | `主从关系紧密` | `可能批量删除数据` |
| 🚫 **RESTRICT** | `禁止操作` | `严格数据保护` | `默认行为` |
| ⚪ **SET NULL** | `设置为NULL` | `弱关联关系` | `外键列必须允许NULL` |
| 📌 **SET DEFAULT** | `设置为默认值` | `有合理默认值` | `MySQL不支持` |
| 🚨 **NO ACTION** | `延迟检查` | `复杂事务操作` | `与RESTRICT类似` |

## # 3.4 外键约束实战应用


**🔸 电商订单系统示例**

```sql
-- 用户表（父表）
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
);

-- 订单表（子表）
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10,2),
    
    -- 外键约束：订单必须属于存在的用户
    CONSTRAINT fk_orders_user 
        FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON DELETE RESTRICT    -- 有订单的用户不能删除
        ON UPDATE CASCADE     -- 用户ID变更时同步更新
);
```

> ⚠️ **实际使用注意**  
> 在高并发系统中，外键约束可能影响性能。很多互联网公司选择在应用层控制数据一致性，而不使用数据库外键。

---

##  4. 🎯 唯一约束UNIQUE设计


## # 4.1 唯一约束基本概念


**🔸 什么是唯一约束**
唯一约束确保列中的值不重复，但允许NULL值：

> 🌰 **生活例子**  
> 就像每个人的手机号必须唯一，但有些人可能没有手机（NULL值），这是允许的。

```sql
-- 唯一约束的基本使用
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,     -- 用户名唯一
    email VARCHAR(100) UNIQUE,       -- 邮箱唯一
    phone VARCHAR(20) UNIQUE         -- 手机号唯一，但可以为NULL
);
```

## # 4.2 唯一约束的创建方式


**🔸 多种创建方法**

```sql
-- 方式1：列级唯一约束
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_code VARCHAR(20) UNIQUE,  -- 商品编码唯一
    product_name VARCHAR(100)
);

-- 方式2：表级唯一约束
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_code VARCHAR(20),
    id_card VARCHAR(18),
    
    UNIQUE (emp_code),                -- 员工编号唯一
    UNIQUE (id_card)                  -- 身份证号唯一
);

-- 方式3：命名唯一约束
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    email VARCHAR(100),
    phone VARCHAR(20),
    
    CONSTRAINT uk_customer_email UNIQUE (email),
    CONSTRAINT uk_customer_phone UNIQUE (phone)
);

-- 方式4：复合唯一约束
CREATE TABLE course_selection (
    selection_id INT PRIMARY KEY,
    student_id INT,
    course_id INT,
    semester VARCHAR(20),
    
    -- 同一学期，学生不能重复选择同一课程
    UNIQUE (student_id, course_id, semester)
);
```

## # 4.3 唯一约束与NULL值


**🔸 NULL值的特殊处理**

```sql
-- 唯一约束允许多个NULL值
CREATE TABLE contacts (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    mobile VARCHAR(20) UNIQUE    -- 可以有多个NULL
);

-- 插入测试数据
INSERT INTO contacts VALUES (1, '张三', '13800138000');
INSERT INTO contacts VALUES (2, '李四', NULL);        -- 允许
INSERT INTO contacts VALUES (3, '王五', NULL);        -- 允许  
INSERT INTO contacts VALUES (4, '赵六', '13800138000'); -- 错误！重复
```

> ⚠️ **重要理解**  
> NULL在数据库中表示"未知"，两个"未知"不能说是相同的，所以唯一约束允许多个NULL值。

## # 4.4 唯一约束管理


**🔸 查看和删除唯一约束**

```sql
-- 查看表的唯一约束
SHOW INDEX FROM users WHERE Non_unique = 0;

-- 删除唯一约束（通过索引名）
ALTER TABLE users DROP INDEX username;

-- 添加唯一约束
ALTER TABLE users ADD UNIQUE (email);
ALTER TABLE users ADD CONSTRAINT uk_users_phone UNIQUE (phone);
```

---

##  5. 🚫 非空约束NOT NULL处理


## # 5.1 非空约束基本概念


**🔸 什么是非空约束**
非空约束就像"必填项"，确保重要信息不能缺失：

> 🌰 **实际例子**  
> 注册用户时，用户名和密码是必填的，但生日可以不填。这就是非空约束的应用。

```sql
CREATE TABLE user_accounts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,      -- 用户名必填
    password VARCHAR(100) NOT NULL,     -- 密码必填
    email VARCHAR(100) NOT NULL,        -- 邮箱必填
    birthday DATE,                      -- 生日可选
    phone VARCHAR(20)                   -- 电话可选
);
```

## # 5.2 非空约束的实际应用


**🔸 业务字段的非空设计**

```sql
-- 订单表的非空约束设计
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,              -- 必须有订单用户
    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    
    -- 可选字段
    delivery_address TEXT,             -- 配送地址（虚拟商品可为空）
    notes TEXT                         -- 订单备注
);
```

**🔸 非空约束的修改**

```sql
-- 添加非空约束
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;

-- 删除非空约束（改为允许NULL）
ALTER TABLE users MODIFY email VARCHAR(100);

-- 批量处理NULL值后添加非空约束
UPDATE users SET email = 'unknown@example.com' WHERE email IS NULL;
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;
```

## # 5.3 非空约束的设计原则


**🔸 哪些字段应该设为NOT NULL**

✅ **推荐设为NOT NULL的字段**：
- 主键字段（自动非空）
- 业务核心字段（用户名、订单金额等）
- 状态字段（用默认值）
- 时间戳字段（用默认值）

❌ **不建议设为NOT NULL的字段**：
- 可选的个人信息（生日、地址等）
- 备注说明类字段
- 扩展属性字段

```sql
-- 设计示例：用户信息表
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,           -- ✅ 核心字段
    email VARCHAR(100) NOT NULL,             -- ✅ 联系方式
    status ENUM('active','inactive') NOT NULL DEFAULT 'active', -- ✅ 状态
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,    -- ✅ 时间
    
    nickname VARCHAR(50),                    -- ❌ 可选昵称
    birthday DATE,                           -- ❌ 可选生日  
    bio TEXT                                 -- ❌ 可选简介
);
```

---

##  6. 📌 默认值约束DEFAULT设置


## # 6.1 默认值约束概念


**🔸 什么是默认值约束**
默认值就像表单的"预填内容"，当用户不输入时自动使用：

> 💡 **实用理解**  
> 就像注册表单中，国家字段默认是"中国"，用户不选择时自动使用这个值。

## # 6.2 默认值的类型


**🔸 常见默认值类型**

```sql
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    
    -- 固定值默认
    status VARCHAR(20) DEFAULT 'draft',
    view_count INT DEFAULT 0,
    
    -- 函数默认值
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 表达式默认值（MySQL 8.0+）
    expire_date DATE DEFAULT (DATE_ADD(CURDATE(), INTERVAL 30 DAY))
);
```

**🔸 默认值设计策略**

| 字段类型 | **推荐默认值** | **设计理由** | **示例** |
|---------|---------------|-------------|---------|
| 🔢 **数值字段** | `0` | `避免NULL计算问题` | `score INT DEFAULT 0` |
| 📅 **时间字段** | `CURRENT_TIMESTAMP` | `记录操作时间` | `created_at TIMESTAMP DEFAULT NOW()` |
| 📊 **状态字段** | `初始状态值` | `明确业务状态` | `status VARCHAR(20) DEFAULT 'active'` |
| 🎯 **布尔字段** | `FALSE/0` | `默认关闭功能` | `is_verified BOOLEAN DEFAULT FALSE` |

## # 6.3 默认值约束管理


**🔸 修改默认值**

```sql
-- 添加默认值
ALTER TABLE users ALTER COLUMN status SET DEFAULT 'active';

-- 删除默认值
ALTER TABLE users ALTER COLUMN status DROP DEFAULT;

-- 查看默认值
DESCRIBE users;
-- 或者
SHOW CREATE TABLE users;
```

---

##  7. ✅ 检查约束CHECK应用


## # 7.1 检查约束基本概念


**🔸 什么是检查约束**
检查约束就像"质量检验员"，确保数据符合业务规则：

> 🌰 **现实例子**  
> 年龄必须在0-150之间，工资必须大于0，性别只能是'男'或'女'。这些业务规则就通过CHECK约束实现。

> 📝 **版本说明**  
> MySQL 8.0.16之前版本支持CHECK语法但不生效，8.0.16+版本才真正支持检查约束。

## # 7.2 检查约束的创建


**🔸 基本语法形式**

```sql
-- MySQL 8.0+ 检查约束示例
CREATE TABLE employees (
    emp_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 65),           -- 年龄范围
    salary DECIMAL(10,2) CHECK (salary > 0),           -- 工资必须为正
    gender ENUM('male', 'female') NOT NULL,            -- 使用ENUM代替CHECK
    email VARCHAR(100) CHECK (email LIKE '%@%.%'),     -- 邮箱格式
    
    -- 命名检查约束
    CONSTRAINT chk_emp_age CHECK (age BETWEEN 18 AND 65),
    CONSTRAINT chk_emp_salary CHECK (salary >= 1000)
);
```

## # 7.3 检查约束实际应用


**🔸 业务规则约束示例**

```sql
-- 商品表的业务约束
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) CHECK (price > 0),                    -- 价格必须为正
    discount_rate DECIMAL(3,2) CHECK (discount_rate BETWEEN 0 AND 1), -- 折扣0-100%
    stock_quantity INT CHECK (stock_quantity >= 0),           -- 库存不能为负
    category VARCHAR(50) CHECK (category IN ('electronics', 'clothing', 'books')),
    
    -- 复合检查约束
    CONSTRAINT chk_price_discount CHECK (price * (1 - discount_rate) > 0)
);
```

**🔸 检查约束的替代方案**

```sql
-- 在MySQL 8.0之前的版本，使用这些方法：

-- 1. 使用ENUM约束选择范围
status ENUM('active', 'inactive', 'suspended') DEFAULT 'active'

-- 2. 使用触发器实现复杂检查
DELIMITER $$
CREATE TRIGGER check_age_before_insert 
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    IF NEW.age < 18 OR NEW.age > 65 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '年龄必须在18-65之间';
    END IF;
END$$
DELIMITER ;

-- 3. 在应用层进行数据验证
```

## # 7.4 检查约束管理


**🔸 约束的查看和管理**

```sql
-- 查看检查约束（MySQL 8.0+）
SELECT * FROM information_schema.CHECK_CONSTRAINTS 
WHERE TABLE_NAME = 'employees';

-- 删除检查约束
ALTER TABLE employees DROP CHECK chk_emp_age;

-- 添加检查约束
ALTER TABLE employees ADD CONSTRAINT chk_emp_age 
CHECK (age BETWEEN 18 AND 65);
```

---

##  8. 🏷️ 约束命名规范与管理


## # 8.1 约束命名规范


**🔸 标准命名规范**

| 约束类型 | **命名前缀** | **命名格式** | **示例** |
|---------|-------------|-------------|---------|
| 🎯 **主键约束** | `pk_` | `pk_表名` | `pk_users` |
| 🔗 **外键约束** | `fk_` | `fk_表名_引用表名` | `fk_orders_users` |
| 🎯 **唯一约束** | `uk_` | `uk_表名_列名` | `uk_users_email` |
| ✅ **检查约束** | `chk_` | `chk_表名_列名` | `chk_employees_age` |

```sql
-- 规范的约束命名示例
CREATE TABLE order_items (
    item_id INT AUTO_INCREMENT,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    
    -- 规范命名的约束
    CONSTRAINT pk_order_items PRIMARY KEY (item_id),
    CONSTRAINT fk_order_items_orders FOREIGN KEY (order_id) REFERENCES orders(order_id),
    CONSTRAINT fk_order_items_products FOREIGN KEY (product_id) REFERENCES products(product_id),
    CONSTRAINT uk_order_items_order_product UNIQUE (order_id, product_id),
    CONSTRAINT chk_order_items_quantity CHECK (quantity > 0),
    CONSTRAINT chk_order_items_price CHECK (unit_price > 0)
);
```

## # 8.2 约束管理最佳实践


**🔸 约束信息查询**

```sql
-- 查看表的所有约束
SELECT 
    CONSTRAINT_NAME,
    CONSTRAINT_TYPE,
    TABLE_NAME,
    COLUMN_NAME
FROM information_schema.KEY_COLUMN_USAGE 
WHERE TABLE_SCHEMA = 'your_database' 
AND TABLE_NAME = 'your_table';

-- 查看外键约束详情
SELECT 
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM information_schema.REFERENTIAL_CONSTRAINTS r
JOIN information_schema.KEY_COLUMN_USAGE k 
ON r.CONSTRAINT_NAME = k.CONSTRAINT_NAME
WHERE r.CONSTRAINT_SCHEMA = 'your_database';
```

**🔸 约束维护策略**

> 🛠️ **维护建议**  
> 1. 开发环境：使用完整约束确保数据质量
> 2. 测试环境：验证约束对性能的影响  
> 3. 生产环境：根据性能需求适当调整

---

##  9. 📊 约束性能影响分析


## # 9.1 不同约束的性能影响


**🔸 约束检查成本对比**

| 约束类型 | **检查时机** | **性能开销** | **影响操作** | **优化建议** |
|---------|-------------|-------------|-------------|-------------|
| 🎯 **主键** | `插入/更新时` | `低` | `INSERT/UPDATE` | `使用自增主键` |
| 🎯 **唯一** | `插入/更新时` | `中` | `INSERT/UPDATE` | `合理使用索引` |
| 🚫 **非空** | `插入/更新时` | `极低` | `INSERT/UPDATE` | `无需优化` |
| 📌 **默认值** | `插入时` | `极低` | `INSERT` | `避免复杂表达式` |
| ✅ **检查** | `插入/更新时` | `高` | `INSERT/UPDATE` | `简化检查逻辑` |
| 🔗 **外键** | `增删改时` | `高` | `INSERT/UPDATE/DELETE` | `考虑应用层控制` |

## # 9.2 高并发场景下的约束策略


**🔸 互联网应用的约束取舍**

```sql
-- 高并发场景的表设计
CREATE TABLE user_logs (
    log_id BIGINT AUTO_INCREMENT PRIMARY KEY,   -- 保留主键
    user_id INT NOT NULL,                       -- 保留非空
    action VARCHAR(50) NOT NULL,                -- 保留非空
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 保留默认值
    
    -- 不使用外键约束，在应用层保证数据一致性
    -- FOREIGN KEY (user_id) REFERENCES users(id)  -- 注释掉
    
    INDEX idx_user_id (user_id),               -- 使用普通索引
    INDEX idx_log_time (log_time)
);
```

> ⚠️ **性能权衡**  
> 大型互联网应用通常会放弃外键约束，改为在应用层控制数据一致性，换取更高的性能和更好的扩展性。

---

##  10. 📋 核心要点总结


## # 10.1 约束体系全览


**🔸 约束功能总结**

```
约束类型功能图：
┌─── 数据质量保障 ───┐
│                   │
│ 主键约束 ──▶ 唯一标识每行数据
│ 外键约束 ──▶ 保证关联数据一致性  
│ 唯一约束 ──▶ 防止业务字段重复
│ 非空约束 ──▶ 确保关键信息完整
│ 默认约束 ──▶ 简化数据输入
│ 检查约束 ──▶ 验证业务规则
│                   │
└─── 构建可靠数据库 ──┘
```

## # 10.2 约束选择指导原则


**🔸 约束使用决策树**

```
字段是否为主键？
    │
    ├─Yes─▶ PRIMARY KEY（自动非空+唯一）
    │
    └─No──▶ 是否允许重复？
              │
              ├─No──▶ UNIQUE约束
              │
              └─Yes─▶ 是否允许为空？
                        │
                        ├─No──▶ NOT NULL约束
                        │
                        └─Yes─▶ 是否需要默认值？
                                  │
                                  ├─Yes─▶ DEFAULT约束  
                                  │
                                  └─No──▶ 是否需要业务规则验证？
                                            │
                                            ├─Yes─▶ CHECK约束
                                            │
                                            └─No──▶ 无额外约束
```

## # 10.3 约束设计最佳实践


**🔸 实际项目约束策略**

| 项目类型 | **约束策略** | **重点关注** | **性能考虑** |
|---------|-------------|-------------|-------------|
| 🏢 **企业内部系统** | `完整约束体系` | `数据准确性` | `中等并发，可接受约束开销` |
| 🌐 **互联网应用** | `核心约束+应用层验证` | `高性能` | `高并发，简化数据库约束` |
| 📊 **数据仓库** | `最小约束` | `数据加载速度` | `批量操作，约束影响大` |
| 🔒 **金融系统** | `严格约束` | `数据一致性` | `安全性优先于性能` |

## # 10.4 约束维护要点


**🔸 掌握程度自测**
- [ ] 能设计合理的主键策略
- [ ] 能正确使用外键约束和级联操作
- [ ] 能区分唯一约束和主键约束的差异
- [ ] 能合理设置默认值和非空约束
- [ ] 能在性能和数据完整性间做出权衡

**🔸 常见错误避免**

> ⚠️ **易错点提醒**  
> 1. 外键字段忘记建索引，导致性能问题
> 2. 过度使用CHECK约束，影响插入性能
> 3. 主键选择不当，影响后续扩展
> 4. 约束命名不规范，维护困难

**🔸 核心记忆要点**
```
🔑 主键唯一非空不能变，外键关联要谨慎
🔑 唯一约束允许NULL，非空约束很简单  
🔑 默认值约束提效率，检查约束控业务
🔑 约束命名要规范，性能影响要评估
```

---

**💡 学习要点**：
- 约束是数据质量的重要保障，理解每种约束的适用场景
- 在高性能和数据完整性之间找到平衡点
- 约束设计要考虑业务需求和系统性能
- 规范的约束命名有助于后期维护和管理