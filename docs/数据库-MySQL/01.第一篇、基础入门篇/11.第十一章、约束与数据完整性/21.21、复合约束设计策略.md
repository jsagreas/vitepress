---
title: 21、复合约束设计策略
---
## 📚 目录

1. [复合约束概述](#1-复合约束概述)
2. [复合主键设计原则](#2-复合主键设计原则)
3. [复合唯一约束实现](#3-复合唯一约束实现)
4. [多字段外键约束](#4-多字段外键约束)
5. [条件约束CHECK实现](#5-条件约束CHECK实现)
6. [复合约束索引策略](#6-复合约束索引策略)
7. [业务规则复合约束](#7-业务规则复合约束)
8. [性能影响与优化](#8-性能影响与优化)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔗 复合约束概述


### 1.1 什么是复合约束


**简单理解**：复合约束就像给一个物品贴多个标签一样，需要同时满足多个条件才能算合格。比如一个学生的成绩单，不仅要求分数合格，还要求科目齐全，这就是复合约束。

```
单一约束示例：
用户表：只要求用户名不能为空

复合约束示例：
用户表：要求（用户名 + 邮箱）的组合必须唯一
订单表：要求（商品ID + 用户ID + 下单日期）的组合确定唯一订单
```

### 1.2 复合约束的核心作用


**🔸 数据完整性保障**
```
单字段约束的局限性：
• 只能保证单个字段符合规则
• 无法保证多个字段间的关系正确

复合约束的优势：
• 保证多个字段组合的唯一性
• 确保复杂业务规则的实现
• 维护数据间的逻辑关系
```

**现实场景对比**：
```
身份证系统：
单一约束：身份证号码不能为空
复合约束：（身份证号 + 姓名 + 出生日期）必须匹配

图书馆系统：
单一约束：图书ISBN不能重复
复合约束：（读者ID + 图书ID + 借阅日期）确定唯一借阅记录
```

### 1.3 复合约束类型体系


```
复合约束分类体系：

基于字段数量：
├── 双字段复合约束：两个字段的组合约束
├── 多字段复合约束：三个及以上字段组合
└── 全表复合约束：涉及表中大部分字段

基于约束类型：
├── 复合主键 (Composite Primary Key)
├── 复合唯一约束 (Composite Unique)  
├── 复合外键 (Composite Foreign Key)
├── 复合检查约束 (Composite Check)
└── 混合复合约束 (Mixed Composite)

基于业务逻辑：
├── 标识复合约束：用于唯一标识记录
├── 关系复合约束：维护表间关系
├── 业务规则约束：实现复杂业务逻辑
└── 数据质量约束：保证数据质量要求
```

---

## 2. 🗝️ 复合主键设计原则


### 2.1 复合主键的核心概念


**什么是复合主键**：由多个字段组合起来作为主键，这些字段的组合值在表中必须唯一且不能为空。

**🔸 复合主键 vs 单一主键**
```
单一主键：
CREATE TABLE users (
    user_id INT PRIMARY KEY,     -- 单一主键
    username VARCHAR(50),
    email VARCHAR(100)
);

复合主键：
CREATE TABLE order_details (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 复合主键
);

区别对比：
┌─────────────┬─────────────┬─────────────────┐
│ 主键类型     │ 优点         │ 缺点            │
├─────────────┼─────────────┼─────────────────┤
│ 单一主键     │ 简单直观     │ 可能需要额外字段 │
│             │ 性能较好     │ 业务含义不明确   │
├─────────────┼─────────────┼─────────────────┤
│ 复合主键     │ 业务含义清晰 │ 索引开销较大    │
│             │ 天然去重     │ 外键关联复杂    │
└─────────────┴─────────────┴─────────────────┘
```

### 2.2 复合主键设计原则


**🔸 原则1：字段选择的稳定性**
```
好的设计：
CREATE TABLE sales_records (
    store_id INT,           -- 商店ID，稳定不变
    product_id INT,         -- 商品ID，稳定不变  
    sale_date DATE,         -- 销售日期，稳定不变
    amount DECIMAL(10,2),
    PRIMARY KEY (store_id, product_id, sale_date)
);

解释：商店、商品、日期的组合确定唯一的销售记录，且这些字段值稳定

不好的设计：
CREATE TABLE user_sessions (
    username VARCHAR(50),    -- 用户名可能会修改
    login_time TIMESTAMP,    -- 登录时间，精度太高
    session_data TEXT,
    PRIMARY KEY (username, login_time)  -- 不稳定的复合主键
);

问题：用户名修改会影响主键，登录时间精度过高容易冲突
```

**🔸 原则2：字段顺序的重要性**
```cpp
// 复合主键的字段顺序会影响索引性能
CREATE TABLE log_entries (
    service_name VARCHAR(50),
    log_time TIMESTAMP,
    log_level VARCHAR(10),
    message TEXT,
    
    -- 字段顺序很重要！
    PRIMARY KEY (service_name, log_time, log_level)
);

查询性能分析：
-- 高效查询（使用主键前缀）
SELECT * FROM log_entries 
WHERE service_name = 'web-api';                    -- 使用第1个字段 ✓

SELECT * FROM log_entries 
WHERE service_name = 'web-api' 
AND log_time > '2025-01-01';                      -- 使用前2个字段 ✓

-- 低效查询（无法使用主键索引）
SELECT * FROM log_entries 
WHERE log_level = 'ERROR';                         -- 只用第3个字段 ✗

字段顺序建议：
1. 查询频率最高的字段放在前面
2. 过滤性最强的字段放在前面
3. 稳定性最高的字段放在前面
```

**🔸 原则3：字段数量的平衡**
```
字段数量建议：

理想数量：2-3个字段
┌─────────────┬─────────────┬─────────────────┐
│ 字段数量     │ 索引性能     │ 适用场景        │
├─────────────┼─────────────┼─────────────────┤
│ 2个字段      │ 最优        │ 大部分业务场景   │
│ 3个字段      │ 良好        │ 复杂业务关系     │
│ 4个字段      │ 一般        │ 特殊需求        │
│ 5个以上      │ 较差        │ 尽量避免        │
└─────────────┴─────────────┴─────────────────┘

实际案例：
-- 合适的复合主键（2个字段）
CREATE TABLE user_roles (
    user_id INT,
    role_id INT,
    assigned_date DATE,
    PRIMARY KEY (user_id, role_id)
);

-- 过于复杂的复合主键（5个字段，不推荐）
CREATE TABLE complex_table (
    field1 INT, field2 INT, field3 VARCHAR(50),
    field4 DATE, field5 VARCHAR(20),
    PRIMARY KEY (field1, field2, field3, field4, field5)  -- 太复杂
);
```

### 2.3 复合主键最佳实践


**🔸 常见业务场景的设计模式**
```sql
-- 模式1：用户关联表（多对多关系）
CREATE TABLE user_groups (
    user_id INT,
    group_id INT,
    join_date DATE,
    role VARCHAR(20),
    PRIMARY KEY (user_id, group_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (group_id) REFERENCES groups(id)
);

-- 模式2：时间序列数据
CREATE TABLE sensor_data (
    sensor_id VARCHAR(20),
    timestamp TIMESTAMP,
    temperature DECIMAL(5,2),
    humidity DECIMAL(5,2),
    PRIMARY KEY (sensor_id, timestamp)
);

-- 模式3：分层数据结构
CREATE TABLE menu_items (
    category_id INT,
    item_order INT,
    item_name VARCHAR(100),
    price DECIMAL(8,2),
    PRIMARY KEY (category_id, item_order)
);
```

**🔸 复合主键的替代方案对比**
```
方案对比分析：

方案1：复合主键
优点：业务含义清晰，天然防重复
缺点：外键关联复杂，索引较大

CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)  -- 复合主键
);

方案2：代理主键 + 复合唯一约束  
优点：外键简单，单一主键性能好
缺点：额外的ID字段，业务含义不直观

CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- 代理主键
    order_id INT,
    product_id INT,
    quantity INT,
    UNIQUE KEY uk_order_product (order_id, product_id)  -- 复合唯一约束
);

选择建议：
• 关系表、日志表：适合复合主键
• 主业务表：建议代理主键
• 外键较多的表：建议代理主键
```

---

## 3. ✨ 复合唯一约束实现


### 3.1 复合唯一约束基本概念


**核心理解**：复合唯一约束确保多个字段的组合值在表中唯一，但与复合主键不同的是，它允许部分字段为NULL。

**🔸 NULL值处理规则**
```sql
-- 复合唯一约束的NULL处理示例
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    phone VARCHAR(20),
    email VARCHAR(100),
    id_card VARCHAR(18),
    
    -- 复合唯一约束：手机号和邮箱的组合必须唯一
    UNIQUE KEY uk_contact (phone, email)
);

NULL值处理规则：
-- 以下插入都是允许的（NULL不参与唯一性检查）
INSERT INTO user_profiles VALUES (1, '13800138000', 'user1@example.com', '123456');
INSERT INTO user_profiles VALUES (2, '13800138000', NULL, '123457');              -- email为NULL
INSERT INTO user_profiles VALUES (3, NULL, 'user1@example.com', '123458');       -- phone为NULL  
INSERT INTO user_profiles VALUES (4, NULL, NULL, '123459');                      -- 都为NULL

-- 以下插入会失败（违反唯一约束）
INSERT INTO user_profiles VALUES (5, '13800138000', 'user1@example.com', '123460'); -- 重复
```

### 3.2 复合唯一约束设计模式


**🔸 模式1：业务数据防重复**
```sql
-- 用户地址表：确保每个用户的同类型地址只有一个默认地址
CREATE TABLE user_addresses (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    address_type ENUM('home', 'work', 'other'),
    address_detail VARCHAR(200),
    is_default BOOLEAN DEFAULT FALSE,
    
    -- 复合唯一约束：同一用户的同一类型地址只能有一个默认
    UNIQUE KEY uk_user_type_default (user_id, address_type, is_default),
    
    FOREIGN KEY (user_id) REFERENCES users(id)
);

业务逻辑说明：
• 用户可以有多个家庭地址，但只能有一个默认家庭地址
• 用户可以有多个工作地址，但只能有一个默认工作地址
• 通过复合唯一约束自动保证业务规则
```

**🔸 模式2：时间窗口唯一性**
```sql
-- 会议室预订表：确保同一时间段内会议室不被重复预订
CREATE TABLE room_bookings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    room_id INT,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    user_id INT,
    meeting_title VARCHAR(200),
    
    -- 确保同一会议室在同一时间不能被重复预订
    UNIQUE KEY uk_room_time (room_id, start_time),
    
    -- 检查约束：结束时间必须大于开始时间
    CONSTRAINT chk_time_valid CHECK (end_time > start_time)
);

复杂时间冲突检查（通过触发器实现）：
DELIMITER //
CREATE TRIGGER check_room_conflict
BEFORE INSERT ON room_bookings
FOR EACH ROW
BEGIN
    DECLARE conflict_count INT DEFAULT 0;
    
    -- 检查时间段是否有冲突
    SELECT COUNT(*) INTO conflict_count
    FROM room_bookings 
    WHERE room_id = NEW.room_id
    AND (
        (NEW.start_time BETWEEN start_time AND end_time) OR
        (NEW.end_time BETWEEN start_time AND end_time) OR  
        (start_time BETWEEN NEW.start_time AND NEW.end_time)
    );
    
    IF conflict_count > 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '会议室在该时间段已被预订';
    END IF;
END//
DELIMITER ;
```

### 3.3 复合唯一约束实现技巧


**🔸 条件唯一性实现**
```sql
-- 需求：用户可以有多个非默认地址，但每种类型只能有一个默认地址
-- 传统方法的问题：无法直接用复合唯一约束实现

-- 解决方案1：使用函数索引（MySQL 8.0+）
CREATE TABLE user_addresses_v2 (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    address_type VARCHAR(20),
    address_detail VARCHAR(200),
    is_default BOOLEAN DEFAULT FALSE,
    
    -- 条件唯一约束：只对默认地址生效
    UNIQUE KEY uk_default_address (
        user_id, 
        address_type, 
        (CASE WHEN is_default = TRUE THEN 1 ELSE NULL END)
    )
);

-- 解决方案2：使用部分索引（通过NULL技巧）
CREATE TABLE user_addresses_v3 (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    address_type VARCHAR(20), 
    address_detail VARCHAR(200),
    is_default BOOLEAN DEFAULT FALSE,
    default_flag INT GENERATED ALWAYS AS (
        CASE WHEN is_default = TRUE 
        THEN 1 
        ELSE NULL END
    ) STORED,
    
    -- 只有默认地址会有非NULL的default_flag
    UNIQUE KEY uk_conditional_default (user_id, address_type, default_flag)
);
```

**🔸 版本兼容的实现方法**
```sql
-- 对于不支持函数索引的MySQL版本，使用触发器实现
CREATE TABLE user_addresses_compatible (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    address_type VARCHAR(20),
    address_detail VARCHAR(200), 
    is_default BOOLEAN DEFAULT FALSE
);

-- 触发器实现条件唯一性
DELIMITER //
CREATE TRIGGER enforce_single_default
BEFORE INSERT ON user_addresses_compatible
FOR EACH ROW  
BEGIN
    DECLARE existing_default INT DEFAULT 0;
    
    IF NEW.is_default = TRUE THEN
        SELECT COUNT(*) INTO existing_default
        FROM user_addresses_compatible
        WHERE user_id = NEW.user_id 
        AND address_type = NEW.address_type
        AND is_default = TRUE;
        
        IF existing_default > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = '该用户的此类型地址已存在默认地址';
        END IF;
    END IF;
END//

CREATE TRIGGER enforce_single_default_update  
BEFORE UPDATE ON user_addresses_compatible
FOR EACH ROW
BEGIN
    DECLARE existing_default INT DEFAULT 0;
    
    IF NEW.is_default = TRUE AND OLD.is_default = FALSE THEN
        SELECT COUNT(*) INTO existing_default
        FROM user_addresses_compatible  
        WHERE user_id = NEW.user_id
        AND address_type = NEW.address_type
        AND is_default = TRUE
        AND id != NEW.id;
        
        IF existing_default > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = '该用户的此类型地址已存在默认地址';
        END IF;
    END IF;
END//
DELIMITER ;
```

---

## 4. 🔗 多字段外键约束


### 4.1 多字段外键的业务场景


**为什么需要多字段外键**：当父表使用复合主键时，子表的外键也必须是多字段的，这样才能准确地建立表间关系。

```sql
-- 典型场景：订单和订单明细的关系
-- 父表：订单表（使用复合主键）
CREATE TABLE orders (
    customer_id INT,
    order_date DATE,
    order_number VARCHAR(20),
    total_amount DECIMAL(10,2),
    
    PRIMARY KEY (customer_id, order_date, order_number)
);

-- 子表：订单明细表
CREATE TABLE order_details (
    detail_id INT AUTO_INCREMENT,
    customer_id INT,          -- 外键字段1
    order_date DATE,          -- 外键字段2  
    order_number VARCHAR(20), -- 外键字段3
    product_id INT,
    quantity INT,
    unit_price DECIMAL(8,2),
    
    PRIMARY KEY (detail_id),
    
    -- 多字段外键约束
    FOREIGN KEY (customer_id, order_date, order_number) 
    REFERENCES orders(customer_id, order_date, order_number)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
```

### 4.2 多字段外键设计技巧


**🔸 外键字段顺序匹配**
```sql
-- 父表字段顺序
PRIMARY KEY (store_id, product_id, sale_date)

-- 子表外键必须保持相同顺序
FOREIGN KEY (store_id, product_id, sale_date)
REFERENCES parent_table(store_id, product_id, sale_date)

-- 错误示例：字段顺序不匹配
FOREIGN KEY (product_id, store_id, sale_date)  -- 顺序错误
REFERENCES parent_table(store_id, product_id, sale_date)
```

**🔸 复杂关联关系实现**
```sql
-- 实际案例：学生选课系统
-- 课程表
CREATE TABLE courses (
    semester VARCHAR(10),     -- 学期
    course_code VARCHAR(10),  -- 课程代码
    class_number INT,         -- 班级号
    course_name VARCHAR(100),
    instructor VARCHAR(50),
    max_students INT,
    
    PRIMARY KEY (semester, course_code, class_number)
);

-- 学生选课表
CREATE TABLE student_enrollments (
    student_id VARCHAR(20),
    semester VARCHAR(10),
    course_code VARCHAR(10), 
    class_number INT,
    enrollment_date DATE,
    grade CHAR(2),
    
    PRIMARY KEY (student_id, semester, course_code, class_number),
    
    -- 多字段外键：确保选择的课程真实存在
    FOREIGN KEY (semester, course_code, class_number)
    REFERENCES courses(semester, course_code, class_number)
    ON DELETE RESTRICT    -- 防止删除已有学生选择的课程
    ON UPDATE CASCADE,    -- 课程信息更新时同步更新
    
    -- 单字段外键：学生必须存在
    FOREIGN KEY (student_id) REFERENCES students(student_id)
);

业务逻辑保证：
• 学生只能选择真实存在的课程（通过多字段外键）
• 学生账号必须有效（通过单字段外键）
• 同一学生不能重复选择同一门课（通过复合主键）
```

### 4.3 多字段外键的级联操作


**🔸 级联操作策略**
```sql
-- 不同级联策略的应用场景
CREATE TABLE inventory_transactions (
    warehouse_id INT,
    product_id INT,
    transaction_date DATE,
    transaction_id INT,
    transaction_type ENUM('in', 'out'),
    quantity INT,
    
    PRIMARY KEY (warehouse_id, product_id, transaction_date, transaction_id),
    
    -- 级联删除：当库存记录删除时，相关事务也删除
    FOREIGN KEY (warehouse_id, product_id) 
    REFERENCES inventory(warehouse_id, product_id)
    ON DELETE CASCADE,
    
    -- 级联更新：当产品信息更新时，事务记录同步更新
    FOREIGN KEY (product_id) 
    REFERENCES products(product_id)
    ON UPDATE CASCADE,
    
    -- 限制删除：当仓库有事务记录时，不允许删除仓库
    FOREIGN KEY (warehouse_id)
    REFERENCES warehouses(warehouse_id) 
    ON DELETE RESTRICT
);

级联操作选择原则：
┌─────────────┬─────────────────┬─────────────────────┐
│ 级联类型     │ 使用场景         │ 业务含义            │
├─────────────┼─────────────────┼─────────────────────┤
│ CASCADE      │ 从属数据         │ 主数据删除，从数据也删除 │
│ RESTRICT     │ 核心业务数据     │ 有关联时禁止删除     │
│ SET NULL     │ 可选关联         │ 删除时设置为空       │
│ NO ACTION    │ 手动处理         │ 不自动处理，需要手动  │
└─────────────┴─────────────────┴─────────────────────┘
```

---

## 5. ✅ 条件约束CHECK实现


### 5.1 CHECK约束基础概念


**什么是CHECK约束**：CHECK约束就像给数据设置一个"入门考试"，只有通过考试（满足条件）的数据才能进入表中。

**🔸 MySQL版本支持情况**
```
MySQL版本对CHECK约束的支持：

MySQL 5.7及之前：
• 语法支持：可以写CHECK约束，但不生效
• 实际效果：CHECK约束被忽略，不进行检查
• 替代方案：使用触发器实现

MySQL 8.0及之后：
• 完全支持：CHECK约束正常工作
• 语法完整：支持复杂的CHECK表达式
• 性能优化：内置实现，性能比触发器好
```

### 5.2 复合CHECK约束设计


**🔸 多字段联合条件检查**
```sql
-- 员工薪资表：确保薪资数据的合理性
CREATE TABLE employee_salaries (
    employee_id INT PRIMARY KEY,
    base_salary DECIMAL(10,2),
    bonus DECIMAL(10,2),
    total_salary DECIMAL(10,2),
    salary_level ENUM('junior', 'senior', 'manager', 'director'),
    department VARCHAR(50),
    
    -- 复合CHECK约束1：总薪资等于基本薪资加奖金
    CONSTRAINT chk_salary_calculation 
    CHECK (total_salary = base_salary + bonus),
    
    -- 复合CHECK约束2：不同级别的薪资范围限制
    CONSTRAINT chk_salary_level_range
    CHECK (
        (salary_level = 'junior' AND base_salary BETWEEN 5000 AND 15000) OR
        (salary_level = 'senior' AND base_salary BETWEEN 15000 AND 30000) OR  
        (salary_level = 'manager' AND base_salary BETWEEN 30000 AND 60000) OR
        (salary_level = 'director' AND base_salary >= 60000)
    ),
    
    -- 复合CHECK约束3：奖金比例限制
    CONSTRAINT chk_bonus_ratio
    CHECK (bonus <= base_salary * 0.5),  -- 奖金不超过基本薪资的50%
    
    -- 复合CHECK约束4：部门薪资上限
    CONSTRAINT chk_department_salary
    CHECK (
        (department = 'IT' AND total_salary <= 80000) OR
        (department = 'Sales' AND total_salary <= 60000) OR
        (department = 'HR' AND total_salary <= 45000) OR
        (department NOT IN ('IT', 'Sales', 'HR'))
    )
);
```

**🔸 基于时间的复合CHECK约束**
```sql
-- 项目管理表：确保项目时间的合理性
CREATE TABLE projects (
    project_id INT AUTO_INCREMENT PRIMARY KEY,
    project_name VARCHAR(100),
    start_date DATE,
    planned_end_date DATE,
    actual_end_date DATE,
    status ENUM('planning', 'active', 'completed', 'cancelled'),
    budget DECIMAL(12,2),
    actual_cost DECIMAL(12,2),
    
    -- 时间逻辑检查
    CONSTRAINT chk_project_dates
    CHECK (planned_end_date >= start_date),
    
    -- 状态与时间的一致性
    CONSTRAINT chk_status_consistency  
    CHECK (
        (status = 'planning' AND actual_end_date IS NULL) OR
        (status = 'active' AND actual_end_date IS NULL) OR
        (status = 'completed' AND actual_end_date IS NOT NULL) OR
        (status = 'cancelled')
    ),
    
    -- 预算与实际成本检查
    CONSTRAINT chk_budget_control
    CHECK (
        (status IN ('planning', 'active') AND actual_cost <= budget * 1.2) OR
        (status IN ('completed', 'cancelled'))
    )
);
```

### 5.3 CHECK约束的高级技巧


**🔸 使用函数和子查询的CHECK约束**
```sql
-- 高级CHECK约束示例
CREATE TABLE student_grades (
    student_id VARCHAR(20),
    course_id VARCHAR(20),
    semester VARCHAR(10),
    grade_score DECIMAL(4,1),
    grade_letter CHAR(2),
    credit_hours INT,
    
    PRIMARY KEY (student_id, course_id, semester),
    
    -- 成绩分数范围检查
    CONSTRAINT chk_score_range
    CHECK (grade_score BETWEEN 0.0 AND 100.0),
    
    -- 分数与字母等级的一致性
    CONSTRAINT chk_grade_consistency
    CHECK (
        (grade_score >= 90 AND grade_letter = 'A') OR
        (grade_score >= 80 AND grade_score < 90 AND grade_letter = 'B') OR
        (grade_score >= 70 AND grade_score < 80 AND grade_letter = 'C') OR
        (grade_score >= 60 AND grade_score < 70 AND grade_letter = 'D') OR
        (grade_score < 60 AND grade_letter = 'F')
    ),
    
    -- 学分小时数检查
    CONSTRAINT chk_credit_hours  
    CHECK (credit_hours BETWEEN 1 AND 6),
    
    -- 使用JSON函数的复杂检查（MySQL 5.7+）
    extra_info JSON,
    CONSTRAINT chk_json_structure
    CHECK (JSON_VALID(extra_info))
);
```

**🔸 触发器实现复杂CHECK约束**
```sql
-- 对于MySQL 8.0之前版本，使用触发器实现复杂约束
CREATE TABLE account_transactions (
    transaction_id INT AUTO_INCREMENT PRIMARY KEY,
    account_id INT,
    transaction_type ENUM('deposit', 'withdraw', 'transfer'),
    amount DECIMAL(10,2),
    balance_after DECIMAL(10,2),
    transaction_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 复杂业务规则检查触发器
DELIMITER //
CREATE TRIGGER check_transaction_rules
BEFORE INSERT ON account_transactions
FOR EACH ROW
BEGIN
    DECLARE current_balance DECIMAL(10,2);
    DECLARE daily_withdraw_total DECIMAL(10,2);
    
    -- 获取当前余额
    SELECT balance INTO current_balance 
    FROM accounts WHERE account_id = NEW.account_id;
    
    -- 业务规则1：取款不能超过余额
    IF NEW.transaction_type = 'withdraw' AND NEW.amount > current_balance THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '余额不足，无法完成取款';
    END IF;
    
    -- 业务规则2：每日取款限额检查
    IF NEW.transaction_type = 'withdraw' THEN
        SELECT COALESCE(SUM(amount), 0) INTO daily_withdraw_total
        FROM account_transactions
        WHERE account_id = NEW.account_id
        AND transaction_type = 'withdraw'
        AND DATE(transaction_time) = CURDATE();
        
        IF daily_withdraw_total + NEW.amount > 10000 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = '超过每日取款限额';
        END IF;
    END IF;
    
    -- 计算交易后余额
    IF NEW.transaction_type = 'deposit' THEN
        SET NEW.balance_after = current_balance + NEW.amount;
    ELSE 
        SET NEW.balance_after = current_balance - NEW.amount;
    END IF;
END//
DELIMITER ;
```

---

## 6. 📊 复合约束索引策略


### 6.1 复合约束索引的自动创建


**MySQL自动索引创建规则**：
```sql
-- MySQL会为以下约束自动创建索引
CREATE TABLE product_inventory (
    warehouse_id INT,
    product_id INT,
    location_code VARCHAR(10),
    quantity INT,
    last_updated TIMESTAMP,
    
    -- 自动创建索引：pk_warehouse_product_location
    PRIMARY KEY (warehouse_id, product_id, location_code),
    
    -- 自动创建索引：uk_product_location_unique  
    UNIQUE KEY uk_product_location (product_id, location_code),
    
    -- 自动创建索引：fk_warehouse_foreign
    FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
    
    INDEX idx_last_updated (last_updated)  -- 手动创建的普通索引
);

查看自动创建的索引：
SHOW INDEX FROM product_inventory;

结果分析：
┌─────────────────────┬──────────────┬─────────────────┐
│ 索引名称             │ 索引类型      │ 包含字段        │
├─────────────────────┼──────────────┼─────────────────┤
│ PRIMARY             │ 主键索引      │ warehouse_id, product_id, location_code │
│ uk_product_location │ 唯一索引      │ product_id, location_code │
│ fk_warehouse_foreign│ 普通索引      │ warehouse_id    │
│ idx_last_updated    │ 普通索引      │ last_updated    │
└─────────────────────┴──────────────┴─────────────────┘
```

### 6.2 复合索引设计原则


**🔸 最左前缀原则应用**
```sql
-- 复合索引的字段顺序规划
CREATE TABLE user_activities (
    user_id INT,
    activity_type VARCHAR(20),
    activity_date DATE,
    activity_time TIME,
    activity_data JSON,
    
    -- 复合索引：注意字段顺序
    INDEX idx_user_activity (user_id, activity_type, activity_date)
);

索引使用效果分析：
-- 高效查询（能使用索引）
SELECT * FROM user_activities WHERE user_id = 123;                           -- 使用前1个字段 ✓
SELECT * FROM user_activities WHERE user_id = 123 AND activity_type = 'login'; -- 使用前2个字段 ✓  
SELECT * FROM user_activities WHERE user_id = 123 AND activity_date = '2025-01-01'; -- 使用前1+3个字段 ✓

-- 低效查询（无法使用索引）
SELECT * FROM user_activities WHERE activity_type = 'login';                  -- 只用第2个字段 ✗
SELECT * FROM user_activities WHERE activity_date = '2025-01-01';            -- 只用第3个字段 ✗

最左前缀原则：
必须从索引的第一个字段开始，连续使用字段才能利用索引
```

**🔸 覆盖索引设计策略**
```sql
-- 覆盖索引：索引包含查询所需的所有字段
CREATE TABLE order_summary (
    order_id INT,
    customer_id INT,
    order_date DATE,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),
    
    PRIMARY KEY (order_id),
    
    -- 覆盖索引：包含常用查询的所有字段
    INDEX idx_customer_date_cover (customer_id, order_date, status, total_amount)
);

覆盖索引的好处：
-- 查询只需访问索引，不需要回表查询数据
SELECT customer_id, order_date, status, total_amount 
FROM order_summary 
WHERE customer_id = 123 AND order_date >= '2025-01-01';

执行计划显示：
Extra: Using index  -- 表示使用了覆盖索引，性能最优
```

### 6.3 复合约束索引优化策略


**🔸 索引合并技巧**
```sql
-- 避免冗余索引
CREATE TABLE user_orders (
    user_id INT,
    order_id INT,
    order_date DATE,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    
    PRIMARY KEY (user_id, order_id),           -- 复合主键，自动创建索引
    
    -- 不要再创建这些冗余索引：
    -- INDEX idx_user (user_id),              -- 冗余！主键索引已覆盖
    -- INDEX idx_user_order (user_id, order_id), -- 冗余！与主键索引重复
    
    -- 应该创建的补充索引：
    INDEX idx_date_status (order_date, status),   -- 按时间状态查询
    INDEX idx_status_amount (status, amount)      -- 按状态金额查询
);

索引设计原则：
• 避免前缀重复：不要创建主键索引的前缀索引
• 补充查询需求：创建不同查询模式需要的索引
• 控制索引数量：过多索引影响写入性能
```

**🔸 部分索引技巧**
```sql
-- 使用函数索引实现部分约束（MySQL 8.0+）
CREATE TABLE product_reviews (
    review_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT,
    user_id INT,
    rating INT,
    review_text TEXT,
    status ENUM('active', 'deleted', 'hidden'),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 复合唯一约束：同一用户对同一产品只能有一个有效评价
    UNIQUE INDEX uk_user_product_active (
        user_id, 
        product_id, 
        (CASE WHEN status = 'active' THEN 1 ELSE NULL END)
    ),
    
    -- 评分范围检查
    CONSTRAINT chk_rating_range
    CHECK (rating BETWEEN 1 AND 5),
    
    -- 有效评价必须有评分
    CONSTRAINT chk_active_rating
    CHECK (status != 'active' OR rating IS NOT NULL)
);

部分索引的优势：
• 只对符合条件的记录创建索引条目
• 减少索引大小和维护开销
• 实现条件唯一性约束
```

---

## 7. 🏢 业务规则复合约束


### 7.1 电商业务复合约束设计


**🔸 商品SKU管理**
```sql
-- 商品SKU表：确保商品规格组合的唯一性
CREATE TABLE product_skus (
    sku_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT,
    color VARCHAR(20),
    size VARCHAR(10), 
    material VARCHAR(30),
    price DECIMAL(8,2),
    stock_quantity INT,
    status ENUM('active', 'inactive', 'discontinued'),
    
    -- 复合唯一约束：同一商品的规格组合必须唯一
    UNIQUE KEY uk_product_specs (product_id, color, size, material),
    
    -- 业务规则约束
    CONSTRAINT chk_price_positive CHECK (price > 0),
    CONSTRAINT chk_stock_non_negative CHECK (stock_quantity >= 0),
    
    -- 状态与库存的一致性约束
    CONSTRAINT chk_status_stock
    CHECK (
        (status = 'active' AND stock_quantity >= 0) OR
        (status = 'inactive' AND stock_quantity >= 0) OR  
        (status = 'discontinued' AND stock_quantity = 0)
    ),
    
    FOREIGN KEY (product_id) REFERENCES products(id)
);

业务场景说明：
• 同一商品不能有相同的颜色、尺寸、材质组合
• 价格必须为正数
• 库存数量不能为负数
• 已停产商品的库存必须为0
```

**🔸 订单状态流转约束**
```sql
-- 订单表：确保订单状态流转的合理性
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    order_status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled'),
    payment_status ENUM('unpaid', 'paid', 'refunded'),
    shipping_status ENUM('not_shipped', 'shipped', 'in_transit', 'delivered'),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    payment_date TIMESTAMP NULL,
    ship_date TIMESTAMP NULL,
    delivery_date TIMESTAMP NULL,
    
    -- 状态一致性约束
    CONSTRAINT chk_order_payment_consistency  
    CHECK (
        (order_status = 'pending' AND payment_status = 'unpaid') OR
        (order_status = 'paid' AND payment_status = 'paid') OR
        (order_status = 'shipped' AND payment_status = 'paid') OR
        (order_status = 'delivered' AND payment_status = 'paid') OR
        (order_status = 'cancelled')
    ),
    
    -- 时间先后顺序约束
    CONSTRAINT chk_date_sequence
    CHECK (
        (payment_date IS NULL OR payment_date >= order_date) AND
        (ship_date IS NULL OR ship_date >= COALESCE(payment_date, order_date)) AND
        (delivery_date IS NULL OR delivery_date >= ship_date)
    ),
    
    -- 状态与时间的匹配约束
    CONSTRAINT chk_status_time_match
    CHECK (
        (order_status = 'pending' AND payment_date IS NULL) OR
        (order_status = 'paid' AND payment_date IS NOT NULL AND ship_date IS NULL) OR
        (order_status = 'shipped' AND ship_date IS NOT NULL AND delivery_date IS NULL) OR
        (order_status = 'delivered' AND delivery_date IS NOT NULL) OR
        (order_status = 'cancelled')
    )
);
```

### 7.2 金融业务复合约束


**🔸 账户余额一致性约束**
```sql
-- 账户余额表：确保余额计算的准确性
CREATE TABLE account_balances (
    account_id VARCHAR(20) PRIMARY KEY,
    available_balance DECIMAL(15,2),     -- 可用余额
    frozen_balance DECIMAL(15,2),        -- 冻结余额
    total_balance DECIMAL(15,2),         -- 总余额
    last_transaction_id VARCHAR(50),
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 余额逻辑一致性约束
    CONSTRAINT chk_balance_consistency
    CHECK (total_balance = available_balance + frozen_balance),
    
    -- 余额非负约束
    CONSTRAINT chk_balance_non_negative
    CHECK (available_balance >= 0 AND frozen_balance >= 0 AND total_balance >= 0),
    
    -- 冻结余额不能超过总余额
    CONSTRAINT chk_frozen_limit
    CHECK (frozen_balance <= total_balance)
);

-- 交易记录表：确保交易的合理性
CREATE TABLE transactions (
    transaction_id VARCHAR(50) PRIMARY KEY,
    from_account VARCHAR(20),
    to_account VARCHAR(20),
    amount DECIMAL(15,2),
    transaction_type ENUM('transfer', 'deposit', 'withdraw', 'freeze', 'unfreeze'),
    transaction_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status ENUM('pending', 'completed', 'failed', 'cancelled'),
    
    -- 金额必须为正数
    CONSTRAINT chk_amount_positive CHECK (amount > 0),
    
    -- 转账类型的账户约束
    CONSTRAINT chk_transfer_accounts
    CHECK (
        (transaction_type = 'transfer' AND from_account != to_account AND 
         from_account IS NOT NULL AND to_account IS NOT NULL) OR
        (transaction_type IN ('deposit', 'withdraw', 'freeze', 'unfreeze'))
    ),
    
    -- 内部转账账户必须不同
    CONSTRAINT chk_different_accounts  
    CHECK (
        transaction_type != 'transfer' OR 
        from_account != to_account
    )
);
```

### 7.3 库存管理复合约束


**🔸 仓库库存约束设计**
```sql
-- 仓库库存表：确保库存数据的准确性
CREATE TABLE warehouse_inventory (
    warehouse_id INT,
    product_id INT,
    location_zone VARCHAR(10),  -- 库区
    location_shelf VARCHAR(10), -- 货架
    quantity_on_hand INT,       -- 现有数量
    quantity_reserved INT,      -- 预留数量  
    quantity_available INT,     -- 可用数量
    min_stock_level INT,        -- 最低库存
    max_stock_level INT,        -- 最高库存
    last_stocktake_date DATE,   -- 最后盘点日期
    
    -- 复合主键：仓库+商品+位置确定唯一库存记录
    PRIMARY KEY (warehouse_id, product_id, location_zone, location_shelf),
    
    -- 库存数量逻辑约束
    CONSTRAINT chk_inventory_logic
    CHECK (
        quantity_available = quantity_on_hand - quantity_reserved AND
        quantity_on_hand >= 0 AND
        quantity_reserved >= 0 AND
        quantity_available >= 0
    ),
    
    -- 库存水位约束
    CONSTRAINT chk_stock_levels
    CHECK (
        min_stock_level >= 0 AND
        max_stock_level > min_stock_level AND
        max_stock_level <= 10000  -- 防止异常大值
    ),
    
    -- 盘点频率约束（90天内必须盘点一次）
    CONSTRAINT chk_stocktake_frequency
    CHECK (last_stocktake_date >= DATE_SUB(CURDATE(), INTERVAL 90 DAY))
);

-- 库存变动记录表
CREATE TABLE inventory_movements (
    movement_id INT AUTO_INCREMENT PRIMARY KEY,
    warehouse_id INT,
    product_id INT, 
    location_zone VARCHAR(10),
    location_shelf VARCHAR(10),
    movement_type ENUM('in', 'out', 'adjust', 'transfer'),
    quantity_change INT,            -- 变动数量（正负表示增减）
    reference_type VARCHAR(20),     -- 关联类型（order、purchase、adjust等）
    reference_id VARCHAR(50),       -- 关联ID
    movement_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 多字段外键：确保库存位置存在
    FOREIGN KEY (warehouse_id, product_id, location_zone, location_shelf)
    REFERENCES warehouse_inventory(warehouse_id, product_id, location_zone, location_shelf),
    
    -- 变动数量约束
    CONSTRAINT chk_quantity_change
    CHECK (
        (movement_type = 'in' AND quantity_change > 0) OR
        (movement_type = 'out' AND quantity_change < 0) OR
        (movement_type IN ('adjust', 'transfer') AND quantity_change != 0)
    ),
    
    -- 关联信息完整性约束
    CONSTRAINT chk_reference_complete
    CHECK (
        reference_type IS NOT NULL AND 
        reference_id IS NOT NULL AND
        reference_id != ''
    )
);
```

---

## 8. 🚀 性能影响与优化


### 8.1 复合约束的性能影响分析


**🔸 写入性能影响**
```
复合约束对INSERT/UPDATE性能的影响：

单个约束检查耗时：
┌─────────────────┬─────────────┬─────────────────┐
│ 约束类型         │ 检查耗时     │ 主要影响因素     │
├─────────────────┼─────────────┼─────────────────┤
│ 复合主键         │ 0.1-0.5ms   │ 索引查找        │
│ 复合唯一约束     │ 0.2-1.0ms   │ 索引扫描        │
│ 多字段外键       │ 0.5-2.0ms   │ 父表索引查找     │
│ 复杂CHECK约束    │ 1.0-5.0ms   │ 表达式计算      │
│ 触发器实现约束   │ 2.0-10ms    │ 存储过程执行     │
└─────────────────┴─────────────┴─────────────────┘

累积效应：
• 单表约束：5个复合约束 ≈ 额外5-15ms开销
• 关联表约束：外键检查可能触发额外IO
• 复杂CHECK约束：表达式计算消耗CPU资源

优化建议：
• 简化CHECK约束表达式
• 合理设计外键索引
• 避免过多的唯一约束
```

**🔸 查询性能影响**
```sql
-- 复合约束对查询性能的正面影响
CREATE TABLE sales_data (
    region_id INT,
    product_id INT,
    sale_date DATE,
    sales_amount DECIMAL(10,2),
    
    -- 复合主键同时作为查询索引
    PRIMARY KEY (region_id, product_id, sale_date)
);

性能提升效果：
-- 高效的范围查询
SELECT SUM(sales_amount) 
FROM sales_data 
WHERE region_id = 1 
AND product_id = 100 
AND sale_date BETWEEN '2025-01-01' AND '2025-01-31';

执行计划：
type: range              -- 范围查询，效率高
key: PRIMARY             -- 使用主键索引
rows: 31                 -- 预估扫描31行，精确
Extra: Using index       -- 覆盖索引，最优性能
```

### 8.2 复合约束性能优化技巧


**🔸 索引字段顺序优化**
```sql
-- 根据查询模式优化字段顺序
CREATE TABLE web_analytics (
    website_id INT,
    page_path VARCHAR(200),
    visitor_id VARCHAR(50),
    visit_date DATE,
    page_views INT,
    
    -- 根据查询频率确定字段顺序
    PRIMARY KEY (website_id, visit_date, page_path, visitor_id)
);

字段顺序选择依据：
1. website_id - 查询必带条件，过滤性强
2. visit_date - 经常按日期范围查询
3. page_path - 按页面统计的需求
4. visitor_id - 个人访问记录查询

查询效率验证：
-- 最常用查询（利用索引前缀）
SELECT page_path, SUM(page_views)
FROM web_analytics 
WHERE website_id = 1 
AND visit_date BETWEEN '2025-01-01' AND '2025-01-07'
GROUP BY page_path;  -- 高效✓

-- 次常用查询（利用索引前缀）
SELECT visitor_id, SUM(page_views)
FROM web_analytics
WHERE website_id = 1 
AND visit_date = '2025-01-01'
AND page_path = '/index.html';  -- 高效✓
```

**🔸 约束检查优化策略**
```sql
-- 优化CHECK约束的执行效率
CREATE TABLE financial_transactions (
    transaction_id VARCHAR(50) PRIMARY KEY,
    account_from VARCHAR(20),
    account_to VARCHAR(20),
    amount DECIMAL(15,2),
    currency_code CHAR(3),
    exchange_rate DECIMAL(10,6),
    amount_local DECIMAL(15,2),
    transaction_type VARCHAR(20),
    transaction_date DATE,
    
    -- 简单高效的CHECK约束
    CONSTRAINT chk_amount_positive CHECK (amount > 0),
    CONSTRAINT chk_exchange_rate CHECK (exchange_rate > 0),
    
    -- 避免复杂的子查询CHECK约束
    -- CONSTRAINT chk_complex_rule CHECK (
    --     amount <= (SELECT daily_limit FROM account_limits 
    --                WHERE account_id = account_from)  -- 避免这种复杂约束
    -- ),
    
    -- 用计算字段替代复杂约束
    CONSTRAINT chk_local_amount 
    CHECK (ABS(amount_local - amount * exchange_rate) < 0.01)
);

-- 复杂业务规则用触发器实现（更高效）
DELIMITER //
CREATE TRIGGER check_transaction_limits
BEFORE INSERT ON financial_transactions
FOR EACH ROW
BEGIN
    DECLARE daily_limit DECIMAL(15,2);
    DECLARE daily_total DECIMAL(15,2);
    
    -- 获取账户限额
    SELECT limit_amount INTO daily_limit
    FROM account_limits 
    WHERE account_id = NEW.account_from 
    AND limit_type = 'daily';
    
    -- 计算当日累计金额
    SELECT COALESCE(SUM(amount), 0) INTO daily_total
    FROM financial_transactions
    WHERE account_from = NEW.account_from
    AND transaction_date = NEW.transaction_date;
    
    -- 检查是否超限
    IF daily_total + NEW.amount > daily_limit THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '超过账户日限额';
    END IF;
END//
DELIMITER ;
```

### 8.3 批量操作的约束优化


**🔸 批量插入的约束策略**
```sql
-- 针对批量操作优化约束检查
-- 临时禁用约束检查（谨慎使用）
SET foreign_key_checks = 0;  -- 禁用外键检查
SET unique_checks = 0;        -- 禁用唯一性检查

-- 批量插入数据
INSERT INTO large_table (col1, col2, col3) VALUES
(value1, value2, value3),
(value4, value5, value6),
...
(valueN, valueN+1, valueN+2);

-- 重新启用约束检查
SET foreign_key_checks = 1;
SET unique_checks = 1;

-- 手动检查数据完整性
CHECK TABLE large_table;

注意事项：
• 只在可控环境下禁用约束
• 批量操作完成后立即重新启用
• 必须手动验证数据完整性
• 不要在生产环境随意使用
```

**🔸 分批处理策略**
```sql
-- 大批量数据的分批约束检查
DELIMITER //
CREATE PROCEDURE batch_insert_with_constraints(
    IN batch_size INT DEFAULT 1000
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_count INT DEFAULT 0;
    DECLARE total_processed INT DEFAULT 0;
    
    -- 声明游标处理待插入数据
    DECLARE cur CURSOR FOR 
        SELECT col1, col2, col3 FROM staging_table;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    START TRANSACTION;
    
    OPEN cur;
    read_loop: LOOP
        -- 处理一批数据
        SET batch_count = 0;
        
        batch_loop: LOOP
            FETCH cur INTO @col1, @col2, @col3;
            IF done THEN LEAVE batch_loop; END IF;
            
            -- 插入单行数据（约束自动检查）
            INSERT INTO target_table (col1, col2, col3) 
            VALUES (@col1, @col2, @col3);
            
            SET batch_count = batch_count + 1;
            SET total_processed = total_processed + 1;
            
            IF batch_count >= batch_size THEN LEAVE batch_loop; END IF;
        END LOOP;
        
        -- 提交当前批次
        COMMIT;
        START TRANSACTION;
        
        IF done THEN LEAVE read_loop; END IF;
    END LOOP;
    
    CLOSE cur;
    COMMIT;
    
    SELECT CONCAT('成功处理 ', total_processed, ' 条记录') AS result;
END//
DELIMITER ;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 复合约束本质：多个字段组合起来共同维护数据完整性
🔸 复合主键原则：字段稳定性、顺序重要性、数量适度性
🔸 复合唯一约束：允许NULL值，实现条件唯一性
🔸 多字段外键：维护复杂表间关系，确保引用完整性
🔸 CHECK约束实现：表达式约束和触发器约束的选择
🔸 索引策略：最左前缀、覆盖索引、避免冗余索引
🔸 性能优化：约束检查开销控制、批量操作优化
```

### 9.2 关键理解要点


**🔹 复合约束的设计思路**
```
设计步骤：
1. 分析业务规则：理解数据间的逻辑关系
2. 识别约束类型：确定需要哪种类型的复合约束
3. 选择字段组合：确定参与约束的字段
4. 优化字段顺序：考虑查询模式和性能
5. 验证约束效果：测试约束是否正确工作

设计原则：
• 业务驱动：约束设计要符合实际业务需求
• 性能平衡：约束完整性与查询性能的平衡
• 简化原则：能用简单约束就不用复杂约束
• 维护友好：约束规则要便于理解和维护
```

**🔹 何时使用复合约束**
```
适用场景：
✅ 业务唯一性：多字段组合确定业务唯一性
✅ 数据关联：复杂的表间关系维护
✅ 业务规则：复杂的业务逻辑约束
✅ 数据质量：多维度的数据质量保证

不适用场景：
❌ 简单业务：单字段约束就能解决的问题
❌ 性能敏感：对写入性能要求极高的场景
❌ 频繁变化：业务规则经常变化的情况
❌ 临时数据：临时表或中间表
```

**🔹 复合约束与性能的平衡**
```
性能影响因素：
• 约束数量：约束越多，检查开销越大
• 约束复杂度：CHECK表达式越复杂，计算开销越大
• 数据量：表数据量大时，唯一性检查耗时增加
• 并发度：高并发时约束检查可能成为瓶颈

优化策略：
• 索引优化：为约束字段创建合适的索引
• 约束简化：使用最简单的约束表达式
• 分层检查：先检查简单约束，再检查复杂约束
• 批量优化：批量操作时合理控制约束检查
```

### 9.3 实际应用指导


**设计决策流程**：
```
复合约束设计决策树：

需要多字段唯一性？
    │
    ├─ 是 → 选择复合主键还是复合唯一约束？
    │       │
    │       ├─ 主业务标识 → 复合主键
    │       └─ 业务规则约束 → 复合唯一约束
    │
    └─ 否 → 需要表间关系约束？
            │
            ├─ 是 → 父表是复合主键？
            │       │
            │       ├─ 是 → 多字段外键
            │       └─ 否 → 单字段外键
            │
            └─ 否 → 需要业务规则约束？
                    │
                    ├─ 是 → MySQL 8.0+？
                    │       │
                    │       ├─ 是 → CHECK约束
                    │       └─ 否 → 触发器约束
                    │
                    └─ 否 → 使用单字段约束
```

**性能调优检查清单**：
```
索引优化：
☑ 复合主键字段顺序是否符合查询模式？
☑ 是否存在冗余的复合索引？
☑ 复合唯一约束是否需要额外覆盖索引？
☑ 外键字段是否有对应的索引？

约束优化：
☑ CHECK约束表达式是否足够简单？
☑ 是否避免了子查询的CHECK约束？
☑ 触发器逻辑是否高效？
☑ 批量操作是否考虑约束开销？

业务逻辑：
☑ 约束规则是否准确反映业务需求？
☑ 约束是否会阻碍正常的业务操作？
☑ 异常情况的处理是否完善？
☑ 约束维护是否便于日常运维？
```

### 9.4 常见问题解答


**Q1：复合主键和复合唯一约束什么时候用哪个？**
```
答：选择依据主要看业务含义

复合主键适用于：
• 多字段组合就是记录的自然标识
• 不需要额外的自增ID
• 外键关联不复杂
• 例如：订单明细表(订单ID+商品ID)

复合唯一约束适用于：  
• 需要额外的代理主键(自增ID)
• 外键关联较多，使用自增ID更简单
• 部分字段可能为NULL
• 例如：用户信息表(用户名+邮箱唯一，但有自增ID)

实际建议：
关系表多用复合主键，主业务表多用代理主键+复合唯一约束
```

**Q2：多字段外键约束性能开销大吗？**
```
答：开销确实存在，但可以优化

性能开销来源：
• 每次INSERT/UPDATE都要检查父表
• 复合外键需要查找复合索引
• 级联操作可能影响多行数据

优化方法：
• 确保父表有对应的复合索引
• 合理选择级联策略(CASCADE vs RESTRICT)
• 批量操作时考虑约束检查开销
• 必要时可暂时禁用外键检查

建议：在数据完整性要求高的核心业务表使用，
临时表或数据仓库表可以考虑省略。
```

**Q3：CHECK约束在MySQL 5.7中不生效怎么办？**
```
答：使用触发器替代实现

MySQL 5.7替代方案：
1. 应用层检查：在程序中实现约束逻辑
2. 触发器约束：用BEFORE INSERT/UPDATE触发器
3. 存储过程：封装带约束检查的写入操作
4. 版本升级：条件允许时升级到MySQL 8.0+

触发器实现模板：
DELIMITER //
CREATE TRIGGER check_business_rule
BEFORE INSERT ON table_name
FOR EACH ROW
BEGIN
    IF (约束条件不满足) THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '错误提示信息';
    END IF;
END//
DELIMITER ;
```

**Q4：复合约束设计时如何平衡完整性和性能？**
```
答：分层设计，渐进优化

完整性优先的场景：
• 金融交易数据
• 核心业务数据  
• 法规要求的数据
• 多系统共享的数据

性能优先的场景：
• 日志记录数据
• 临时计算数据
• 数据仓库ETL过程
• 高并发写入场景

平衡策略：
1. 核心约束：一定要保证，优化索引提高性能
2. 辅助约束：可以适当简化或异步检查
3. 临时约束：批量导入时可暂时禁用
4. 监控调优：持续监控约束检查的性能影响

记住：数据错误的修复成本远高于约束检查的性能开销
```

### 9.5 学习建议和最佳实践


**循序渐进的学习路径**：
```
第1阶段：基础理解
• 理解各种复合约束的含义和作用
• 掌握基本的语法和创建方法
• 了解约束检查的时机和规则

第2阶段：设计实践
• 分析具体业务场景的约束需求
• 设计合理的复合约束组合
• 理解不同约束类型的适用场景

第3阶段：性能优化
• 掌握复合约束的索引策略
• 了解约束检查的性能影响
• 学会批量操作的优化方法

第4阶段：运维管理
• 监控约束相关的性能指标
• 处理约束冲突的常见问题
• 制定约束维护的最佳实践
```

**实践练习建议**：
- **电商场景练习**：设计商品、订单、库存的复合约束
- **金融场景练习**：设计账户、交易、风控的约束规则
- **用户系统练习**：设计用户、权限、会话的约束关系
- **日志系统练习**：设计时间序列数据的约束策略

**核心记忆要点**：
- 复合约束保证多字段组合的数据完整性
- 设计时要平衡业务需求、完整性要求和性能考虑
- 索引策略是复合约束性能的关键因素
- 约束检查的开销要在设计时充分考虑
- 复杂业务规则优先考虑触发器而不是CHECK约束