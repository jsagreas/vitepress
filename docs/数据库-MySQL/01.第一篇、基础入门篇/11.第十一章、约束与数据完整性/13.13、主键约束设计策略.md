---
title: 13、主键约束设计策略
---
## 📚 目录

1. [主键约束基础概念](#1-主键约束基础概念)
2. [主键设计策略分析](#2-主键设计策略分析)
3. [单列主键vs复合主键](#3-单列主键vs复合主键)
4. [主键类型深度对比](#4-主键类型深度对比)
5. [主键性能影响分析](#5-主键性能影响分析)
6. [分布式主键解决方案](#6-分布式主键解决方案)
7. [主键设计最佳实践](#7-主键设计最佳实践)
8. [主键变更与维护策略](#8-主键变更与维护策略)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔑 主键约束基础概念


### 1.1 什么是主键约束


**🔸 主键的本质含义**
```
主键(Primary Key) = 表中每一行的唯一身份证

作用：
├── 唯一标识：确保每行数据都有唯一标识符
├── 快速查找：MySQL自动为主键创建聚簇索引
├── 外键引用：其他表可以通过主键建立关联关系
└── 数据完整性：保证表中不会有重复或空值记录
```

> 💡 **通俗理解**
> 
> 主键就像每个人的身份证号码，必须唯一且不能为空。有了身份证号，就能快速找到对应的人。

### 1.2 主键约束的特性


**🔸 主键的基本规则**
```
唯一性(UNIQUE)：
└── 主键值在表中必须唯一，不允许重复

非空性(NOT NULL)：  
└── 主键字段不允许为NULL值

不可变性：
└── 一旦设定，主键值不应该修改

单一性：
└── 一个表只能有一个主键约束
```

### 1.3 主键聚簇索引特性


**🔸 什么是聚簇索引**
```
聚簇索引原理：

普通表存储：                主键聚簇索引：
数据行无序存放              数据按主键顺序物理存储
┌─────────┐                ┌─────────┐
│ id=5 ...│                │ id=1 ...│
│ id=1 ...│       →        │ id=2 ...│
│ id=3 ...│                │ id=3 ...│
│ id=2 ...│                │ id=5 ...│
└─────────┘                └─────────┘

查找效率：O(log n)         查找效率：O(log n)，但更快
```

**💡 聚簇索引的好处**
- **查询速度快**：主键查询直接定位到数据行
- **范围查询高效**：连续主键的数据物理相邻
- **节省空间**：不需要额外存储指向数据的指针

---

## 2. 🎯 主键设计策略分析


### 2.1 技术主键vs业务主键


**🔸 技术主键特点**
```
定义：由系统自动生成的主键，与业务逻辑无关

典型例子：
├── 自增ID：1, 2, 3, 4, 5...
├── UUID：550e8400-e29b-41d4-a716-446655440000
└── 雪花算法：1234567890123456789

优势：
✅ 稳定性好：不受业务变化影响
✅ 性能高：通常较短，索引效率高
✅ 唯一性强：系统保证全局唯一
✅ 简单易用：无需考虑业务逻辑
```

**🔸 业务主键特点**
```
定义：使用具有业务含义的字段作为主键

典型例子：
├── 用户表：使用手机号或邮箱
├── 商品表：使用商品编码
└── 订单表：使用订单号

优势：
✅ 业务意义明确：主键本身有业务价值
✅ 查询自然：业务查询通常基于这些字段
✅ 避免JOIN：某些查询不需要额外关联

劣势：
❌ 可能变更：业务规则变化可能影响主键
❌ 长度较长：影响索引性能
❌ 分布不均：可能导致热点问题
```

### 2.2 主键选择原则


**🔸 主键设计的黄金法则**
```
1️⃣ 唯一性：永远不重复
2️⃣ 稳定性：一旦分配，不再改变  
3️⃣ 简洁性：尽量短小，提高索引效率
4️⃣ 连续性：便于范围查询和存储优化
5️⃣ 无意义：不包含业务逻辑，避免耦合
```

**🤔 为什么推荐技术主键？**

```
业务主键的真实问题案例：

❌ 用户手机号作主键：
   问题：用户换手机号怎么办？

❌ 商品编码作主键：
   问题：商品编码规则变更怎么办？

❌ 身份证号作主键：
   问题：身份证号录入错误怎么修改？

✅ 自增ID作主键：
   优势：这些问题都不存在！
```

---

## 3. 🔢 单列主键vs复合主键


### 3.1 单列主键设计


**🔸 单列主键的典型场景**
```sql
-- 用户表：单列自增主键
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 商品表：单列主键  
CREATE TABLE products (
    product_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(200) NOT NULL,
    price DECIMAL(10,2) NOT NULL
);
```

**优势分析**：
- ✅ **查询简单**：`WHERE id = 123` 最直接
- ✅ **索引高效**：单列索引性能最好
- ✅ **外键简单**：其他表引用只需一个字段
- ✅ **扩展容易**：添加字段不影响主键

### 3.2 复合主键设计


**🔸 复合主键适用场景**
```sql
-- 订单商品明细表：天然的复合主键
CREATE TABLE order_items (
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (order_id, product_id)
);

-- 用户角色关联表
CREATE TABLE user_roles (
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, role_id)
);
```

**🔸 复合主键字段顺序优化**
```
原则：将查询最频繁的字段放在前面

错误设计：PRIMARY KEY (role_id, user_id)
正确设计：PRIMARY KEY (user_id, role_id)

原因分析：
查询场景：SELECT * FROM user_roles WHERE user_id = 123
├── 正确设计：可以利用主键索引快速查找
└── 错误设计：无法有效利用索引，需要全表扫描

字段顺序影响索引效率：
(user_id, role_id) ← 可以用于 WHERE user_id = ?
(user_id, role_id) ← 可以用于 WHERE user_id = ? AND role_id = ?
(user_id, role_id) ← 不能用于 WHERE role_id = ? (无法使用索引)
```

### 3.3 单列vs复合主键选择


| **对比维度** | **单列主键** | **复合主键** |
|-------------|-------------|-------------|
| **🔍 查询性能** | `优秀` | `良好（需要优化字段顺序）` |
| **💾 存储开销** | `小` | `大（多个字段）` |
| **🔗 外键引用** | `简单` | `复杂（需要多个字段）` |
| **📝 业务理解** | `需要额外字段理解业务` | `主键本身有业务含义` |
| **🔄 维护难度** | `低` | `高（字段变更影响大）` |
| **🎯 适用场景** | `通用表设计` | `多对多关联表` |

---

## 4. 🏷️ 主键类型深度对比


### 4.1 自增主键AUTO_INCREMENT


**🔸 自增主键的工作原理**
```sql
-- 创建自增主键
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL
);

-- 插入数据（无需指定id）
INSERT INTO orders (order_no, user_id, total_amount) 
VALUES ('ORD001', 1001, 299.99);

-- MySQL自动分配id=1
```

**🔸 自增主键的存储特点**
```
数据存储分布：
物理存储顺序 = 主键顺序

┌─────────────────────────────┐
│ id=1 │ id=2 │ id=3 │ id=4 │ ← 连续存储
└─────────────────────────────┘

查询优势：
- 主键查询：直接定位，速度最快
- 范围查询：连续读取，IO效率高
- 插入性能：总是在末尾插入，无页分裂
```

**自增主键优缺点**

✅ **优势**：
- **性能优秀**：整数比较和存储效率最高
- **空间节省**：只需4-8字节
- **插入高效**：顺序插入，不会导致页分裂
- **简单易用**：MySQL自动管理，无需应用处理

❌ **劣势**：
- **信息泄露**：容易被推算出表的记录数量
- **分布式困难**：多个数据库实例会产生冲突
- **迁移复杂**：数据迁移时ID可能冲突
- **并发瓶颈**：高并发插入时可能产生锁等待

### 4.2 UUID主键方案


**🔸 UUID主键的特点**
```sql
-- UUID主键示例
CREATE TABLE products (
    id CHAR(36) PRIMARY KEY,  -- 存储UUID
    name VARCHAR(200) NOT NULL,
    price DECIMAL(10,2) NOT NULL
);

-- 插入UUID数据
INSERT INTO products (id, name, price) 
VALUES (UUID(), 'iPhone 15', 6999.00);

-- 生成的UUID示例：
-- '550e8400-e29b-41d4-a716-446655440000'
```

**🔸 UUID的存储影响**
```
UUID存储开销分析：

自增INT主键：4字节
自增BIGINT主键：8字节  
UUID主键：36字节（字符串形式）

存储空间对比：
1000万条记录的主键空间占用
├── INT主键：40MB
├── BIGINT主键：80MB
└── UUID主键：360MB

影响：
- 主键索引更大，占用更多内存
- 二级索引也需要存储主键值，空间翻倍
- 缓存命中率下降，查询性能受影响
```

**UUID优缺点分析**

✅ **优势**：
- **全局唯一**：跨数据库、跨服务器都不会重复
- **分布式友好**：多个实例可以独立生成
- **信息安全**：无法推算记录数量和规律
- **离线生成**：客户端可以预先生成

❌ **劣势**：
- **性能较差**：36字节长度影响索引效率
- **插入性能差**：随机性导致页分裂频繁
- **存储开销大**：占用空间是自增ID的9倍
- **可读性差**：调试时不如数字ID直观

### 4.3 雪花算法主键生成


**🔸 雪花算法原理**
```
雪花算法ID结构（64位）：

┌─┬─────────────┬─────┬─────┬──────────────┐
│0│  时间戳     │机器ID│进程ID│  序列号      │
└─┴─────────────┴─────┴─────┴──────────────┘
 1     41位      5位   5位      12位

解释：
- 时间戳(41位)：毫秒级时间戳，可用69年
- 机器ID(5位)：最多支持32台机器
- 进程ID(5位)：每台机器最多32个进程
- 序列号(12位)：每毫秒最多4096个ID
```

**雪花算法ID生成示例**
```java
// 简化的雪花算法实现
public class SnowflakeIdGenerator {
    private final long machineId;
    private long sequence = 0L;
    private long lastTimestamp = -1L;
    
    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();
        
        // 同一毫秒内，序列号递增
        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & 4095; // 12位序列号
        } else {
            sequence = 0L;
        }
        
        lastTimestamp = timestamp;
        
        // 组装64位ID
        return ((timestamp - START_TIME) << 22) | 
               (machineId << 17) | 
               (workerId << 12) | 
               sequence;
    }
}

// 生成的ID示例：1234567890123456789
```

**雪花算法优缺点**

✅ **优势**：
- **分布式友好**：多机器部署不会冲突
- **性能良好**：64位整数，查询和存储效率高
- **时间有序**：ID大致按时间顺序生成
- **信息丰富**：ID包含时间和机器信息

❌ **劣势**：
- **时钟依赖**：依赖系统时钟，时钟回拨会出问题
- **机器配置**：需要为每台机器分配唯一ID
- **实现复杂**：需要自己实现或引入第三方库

### 4.4 时间戳主键策略


**🔸 时间戳主键设计**
```sql
-- 基于时间戳的主键
CREATE TABLE logs (
    id BIGINT PRIMARY KEY,  -- 时间戳微秒 + 随机数
    log_level VARCHAR(10) NOT NULL,
    message TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 生成时间戳主键的方法
INSERT INTO logs (id, log_level, message) VALUES 
(UNIX_TIMESTAMP(NOW(6)) * 1000000 + FLOOR(RAND() * 1000), 'INFO', '日志消息');
```

**应用场景**：
- **日志表**：天然按时间排序
- **消息表**：保持时间顺序
- **事件表**：事件发生时间很重要

---

## 5. ⚡ 主键性能影响分析


### 5.1 主键长度对性能的影响


**🔸 为什么主键长度很重要**
```
MySQL存储结构：

二级索引结构：
┌─────────────┐    ┌─────────────┐
│   索引键    │───→│   主键值    │
│ (username)  │    │    (id)     │  
└─────────────┘    └─────────────┘

主键长度影响：
├── 二级索引大小：每个二级索引都要存储主键值
├── 内存使用：索引缓存占用更多内存
├── IO开销：索引读写需要更多磁盘IO
└── 查询性能：索引树更深，查找路径更长
```

**🔸 不同主键长度性能对比**

| **主键类型** | **长度** | **索引大小** | **查询性能** | **插入性能** |
|-------------|---------|-------------|-------------|-------------|
| **INT自增** | `4字节` | `基准100%` | `🟢 最快` | `🟢 最快` |
| **BIGINT自增** | `8字节` | `120%` | `🟢 很快` | `🟢 很快` |
| **UUID字符串** | `36字节` | `400%` | `🟡 较慢` | `🔴 很慢` |
| **UUID二进制** | `16字节` | `200%` | `🟡 中等` | `🟡 中等` |

### 5.2 主键修改的级联影响


**🔸 修改主键的连锁反应**
```
主键修改影响链：

1. 聚簇索引重建
   └── 整个表的物理存储重新组织

2. 二级索引更新  
   └── 所有二级索引都存储主键值，全部要更新

3. 外键关联更新
   └── 其他表的外键引用需要级联更新

4. 应用程序影响
   └── 缓存失效，关联查询失败

时间成本：大表修改主键可能需要数小时
业务影响：可能导致长时间锁表
```

> ⚠️ **重要提醒**
> 
> 这就是为什么强烈建议使用技术主键！一旦主键设计好，就不要轻易修改。

### 5.3 无主键表的隐式主键


**🔸 MySQL对无主键表的处理**
```sql
-- 创建无主键表
CREATE TABLE logs_no_pk (
    message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- MySQL内部处理：
-- 自动创建隐式主键（ROW_ID，6字节，自增）
```

**隐式主键的问题**
```
MySQL内部行为：
├── 自动创建ROW_ID字段（6字节）
├── ROW_ID全局递增，跨表共享
├── 达到最大值后重新开始，可能重复
└── 重复ROW_ID导致主从复制异常

性能影响：
❌ 没有显式主键索引优化
❌ 复制性能差
❌ 可能出现数据不一致
```

> 🚨 **最佳实践**
> 
> 永远不要创建无主键表！即使是日志表，也要加一个自增ID主键。

---

## 6. 🌐 分布式主键解决方案


### 6.1 分布式环境下的主键挑战


**🔸 分布式主键需要解决的问题**
```
多数据库实例场景：

数据库A            数据库B            数据库C
┌─────────┐       ┌─────────┐       ┌─────────┐
│ id=1    │       │ id=1    │       │ id=1    │ ← 冲突！
│ id=2    │       │ id=2    │       │ id=2    │ ← 冲突！
│ id=3    │       │ id=3    │       │ id=3    │ ← 冲突！
└─────────┘       └─────────┘       └─────────┘

问题：自增主键会在不同实例间产生重复
```

### 6.2 分布式主键解决方案对比


**🔸 方案1：自增ID步长分配**
```sql
-- 数据库A配置
SET $$auto_increment_offset = 1;     -- 起始值
SET $$auto_increment_increment = 3;  -- 步长

-- 数据库B配置  
SET $$auto_increment_offset = 2;
SET $$auto_increment_increment = 3;

-- 数据库C配置
SET $$auto_increment_offset = 3;
SET $$auto_increment_increment = 3;

结果：
数据库A生成：1, 4, 7, 10, 13...
数据库B生成：2, 5, 8, 11, 14...  
数据库C生成：3, 6, 9, 12, 15...
```

**🔸 方案2：雪花算法分布式ID**
```
多机器雪花算法部署：

机器A(ID=1):  生成 1xxx...xxx1xxx
机器B(ID=2):  生成 1xxx...xxx2xxx  
机器C(ID=3):  生成 1xxx...xxx3xxx

优势：
✅ 全局唯一
✅ 大致有序
✅ 性能高
✅ 包含时间信息
```

**🔸 方案3：号段分配模式**
```
号段分配原理：

┌─────────────┐
│ 号段分配器   │ ← 统一分配号段给各实例
└─────────────┘
       │
   ┌───┼───┐
   ↓   ↓   ↓
 实例A 实例B 实例C
1-1000 1001-2000 2001-3000

实例用完后向分配器申请新号段
```

### 6.3 分布式主键方案选择


```
🎯 选择决策树：

需要分布式主键？
    ↓
是否要求严格有序？
  ↙          ↘
 是            否
 ↓            ↓
雪花算法      UUID方案
号段模式      
    
是否要求高性能？
  ↙          ↘  
 是            否
 ↓            ↓
雪花算法      UUID足够
```

**📊 方案对比总结**

| **方案** | **全局唯一** | **有序性** | **性能** | **复杂度** | **推荐场景** |
|---------|-------------|-----------|---------|-----------|-------------|
| **自增+步长** | ✅ | ✅ | 🟢 高 | 🟢 简单 | `小规模分布式` |
| **雪花算法** | ✅ | ✅ | 🟢 高 | 🟡 中等 | `中大规模分布式` |
| **UUID** | ✅ | ❌ | 🟡 中等 | 🟢 简单 | `对性能要求不高` |
| **号段分配** | ✅ | ✅ | 🟢 高 | 🔴 复杂 | `超大规模系统` |

---

## 7. 🎯 主键设计最佳实践


### 7.1 主键设计基本原则


**🔸 设计原则详解**

```
1️⃣ 最小化原则
   └── 选择占用空间最小的数据类型
   
   ❌ 错误：BIGINT (8字节) 用于小表
   ✅ 正确：INT (4字节) 够用就行

2️⃣ 稳定性原则  
   └── 主键值一旦分配，永不修改
   
   ❌ 错误：用户名作主键（用户可能改名）
   ✅ 正确：自增ID作主键

3️⃣ 无意义原则
   └── 主键不包含业务逻辑
   
   ❌ 错误：用订单日期+流水号作主键
   ✅ 正确：纯技术ID，业务字段另建索引

4️⃣ 连续性原则
   └── 尽量保持主键连续递增
   
   ✅ 最佳：AUTO_INCREMENT
   🟡 较好：雪花算法（大致有序）
   ❌ 较差：UUID（完全随机）
```

### 7.2 不同场景的主键选择策略


**🔸 场景化主键选择指南**

```
💻 单机应用：
推荐：AUTO_INCREMENT
理由：简单、高效、够用

🌐 分布式应用（中小规模）：
推荐：雪花算法
理由：全局唯一、性能好、有序

🏢 大型企业系统：
推荐：号段分配
理由：可控性强、性能极佳

📱 移动应用后端：
推荐：UUID
理由：客户端可预生成、离线友好

📊 数据分析系统：
推荐：复合主键
理由：天然分区键、查询效率高
```

### 7.3 主键选择性能基准


**🔸 性能测试数据对比**
```
测试环境：1000万条记录插入性能

主键类型        插入时间    索引大小    查询性能
───────────────────────────────────────────
INT自增         100秒      200MB      100%基准
BIGINT自增      105秒      400MB      98%
雪花算法BIGINT   110秒      400MB      95%
UUID(CHAR36)    180秒      1.2GB      60%
UUID(BINARY16)  140秒      800MB      75%

结论：
🏆 自增ID性能最佳
🥈 雪花算法平衡分布式和性能  
🥉 UUID适合特殊场景
```

### 7.4 复合主键优化策略


**🔸 复合主键字段顺序的重要性**
```sql
-- 案例：用户操作日志表
CREATE TABLE user_actions (
    user_id BIGINT NOT NULL,
    action_time BIGINT NOT NULL,  -- 时间戳
    action_type VARCHAR(20) NOT NULL,
    details JSON,
    PRIMARY KEY (user_id, action_time)  -- 字段顺序很关键
);

-- 常见查询模式
SELECT * FROM user_actions 
WHERE user_id = 12345 
  AND action_time BETWEEN 1640995200 AND 1641081600;
```

**字段顺序优化原则**
```
🔸 查询频率优先：
   最常用的查询条件放在最前面

🔸 选择性优先：
   选择性高的字段（唯一值多）放前面
   
🔸 范围查询优化：
   经常做范围查询的字段放后面

实例分析：
PRIMARY KEY (user_id, action_time)
├── user_id在前：支持查某用户的所有操作
├── action_time在后：支持查某用户某时间段操作
└── 如果顺序颠倒，查询效率会大幅下降
```

---

## 8. 🔄 主键变更与维护策略


### 8.1 主键变更的风险评估


**🔸 主键变更的影响范围**
```
影响评估清单：

数据库层面：
├── 聚簇索引重建 → 可能锁表数小时
├── 二级索引更新 → 所有索引都要重建  
├── 外键约束检查 → 关联表数据一致性验证
└── 统计信息更新 → 查询优化器重新分析

应用程序层面：  
├── 代码逻辑修改 → 所有使用主键的代码
├── 缓存失效 → Redis等缓存需要清理
├── 接口变更 → API接口可能需要修改
└── 数据同步 → ETL、数据仓库等下游系统

业务层面：
├── 服务中断 → 变更期间可能无法提供服务
├── 数据一致性风险 → 变更过程中的数据问题
└── 回滚复杂度 → 变更失败的恢复难度
```

### 8.2 安全的主键变更策略


**🔸 渐进式主键迁移方案**
```
步骤1：添加新主键字段
ALTER TABLE users ADD COLUMN new_id BIGINT AUTO_INCREMENT;

步骤2：为现有数据生成新ID
UPDATE users SET new_id = (@row_number:=@row_number+1), @row_number:=0;

步骤3：创建新主键索引
CREATE UNIQUE INDEX idx_new_id ON users(new_id);

步骤4：更新应用程序使用新ID
-- 逐步修改应用代码，支持新旧两套ID

步骤5：删除旧主键约束
ALTER TABLE users DROP PRIMARY KEY;

步骤6：设置新主键
ALTER TABLE users ADD PRIMARY KEY (new_id);

步骤7：删除旧ID字段（可选）
ALTER TABLE users DROP COLUMN old_id;
```

### 8.3 主键设计的前瞻性规划


**🔸 容量规划考虑**
```
数据类型选择考虑：

INT类型主键：
├── 最大值：2,147,483,647（约21亿）
├── 适用：中小型应用，记录数<10亿
└── 优势：性能最佳，空间最小

BIGINT类型主键：
├── 最大值：9,223,372,036,854,775,807（约922万亿）
├── 适用：大型应用，长期增长
└── 劣势：占用空间翻倍

实际选择建议：
🔸 预期5年内记录数<1亿：INT够用
🔸 预期5年内记录数>1亿：BIGINT保险
🔸 高频插入系统：直接用BIGINT
```

---

## 9. 📊 主键性能优化方法


### 9.1 主键设计性能优化


**🔸 插入性能优化**
```
顺序插入 vs 随机插入：

顺序插入（自增ID）：
┌─────┬─────┬─────┬─────┬─────┐
│ id=1│ id=2│ id=3│ id=4│ id=5│ ← 顺序写入
└─────┴─────┴─────┴─────┴─────┘
优势：无页分裂，插入速度快

随机插入（UUID）：
┌─────┬─────┬─────┬─────┬─────┐
│ UUID│ UUID│ UUID│ UUID│ UUID│ ← 随机位置插入
└─────┴─────┴─────┴─────┴─────┘
劣势：频繁页分裂，插入速度慢
```

**🔸 页分裂的影响**
```
什么是页分裂：
当向已满的数据页插入数据时，MySQL需要：
1. 分配新的数据页
2. 移动部分数据到新页
3. 更新索引指针
4. 增加IO操作

影响：
❌ 插入性能下降50-80%
❌ 磁盘碎片增加
❌ 索引效率降低
```

### 9.2 查询性能优化技巧


**🔸 主键查询优化**
```sql
-- 高效的主键查询
SELECT * FROM orders WHERE id = 12345;          -- ✅ 直接主键查询
SELECT * FROM orders WHERE id IN (1,2,3,4,5);   -- ✅ 主键范围查询

-- 避免的查询模式  
SELECT * FROM orders WHERE id LIKE '123%';      -- ❌ 主键模糊查询
SELECT * FROM orders WHERE id + 1 = 12346;     -- ❌ 主键表达式查询
SELECT * FROM orders WHERE CAST(id AS CHAR) = '12345'; -- ❌ 类型转换
```

**🔸 复合主键查询优化**
```sql
-- 高效的复合主键查询
SELECT * FROM order_items 
WHERE order_id = 1001 AND product_id = 2002;   -- ✅ 完整主键查询

SELECT * FROM order_items WHERE order_id = 1001; -- ✅ 前缀查询

-- 低效的查询模式
SELECT * FROM order_items WHERE product_id = 2002; -- ❌ 非前缀查询
```

### 9.3 主键相关索引优化


**🔸 二级索引优化策略**
```sql
-- 用户表设计
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 二级索引设计
    UNIQUE KEY uk_username (username),
    UNIQUE KEY uk_email (email),
    KEY idx_phone (phone),
    KEY idx_created_at (created_at)
);

索引空间分析：
主键索引：只存储 (id → 完整行数据)
二级索引：存储 (索引键 → 主键值)

如果主键太长：
├── 每个二级索引都增大
├── 缓存效率下降
└── 查询性能受影响
```

---

## 10. 📋 核心要点总结


### 10.1 主键设计金科玉律


**🔸 核心原则记忆**
```
🔑 主键设计五要素：
S - Short (短小)：尽量使用较短的数据类型
T - Table (单表)：一个表只能有一个主键
A - Auto (自动)：推荐使用AUTO_INCREMENT
B - Business (业务)：与业务逻辑解耦
L - Long (长期)：设计时考虑长期发展
E - Efficient (高效)：以性能为优先考虑
```

### 10.2 主键选择速查表


| **应用场景** | **推荐主键** | **核心原因** |
|-------------|-------------|-------------|
| **🏢 单机业务系统** | `BIGINT AUTO_INCREMENT` | 简单高效，长期够用 |
| **🌐 分布式系统** | `雪花算法ID` | 全局唯一，性能良好 |
| **📱 移动应用API** | `UUID` | 客户端友好，离线生成 |
| **📊 数据仓库** | `复合主键` | 天然分区，查询高效 |
| **🔄 多对多关联** | `复合主键` | 业务语义清晰 |
| **📝 日志系统** | `时间戳+序列号` | 天然有序，便于分析 |

### 10.3 性能优化检查清单


**🔸 主键性能检查要点**
```
✅ 数据类型检查：
   □ 使用最小够用的整型（INT vs BIGINT）
   □ 避免使用字符串类型做主键
   □ UUID尽量用BINARY(16)而不是CHAR(36)

✅ 设计模式检查：
   □ 优先选择技术主键而不是业务主键
   □ 单列主键优于复合主键（除非业务需要）
   □ 自增主键优于随机主键

✅ 索引影响检查：
   □ 主键长度对所有二级索引的影响
   □ 复合主键字段顺序是否匹配查询模式
   □ 是否有不必要的唯一约束

✅ 分布式考虑：
   □ 是否需要全局唯一ID
   □ 是否需要包含时间信息
   □ 是否需要包含机器标识
```

### 10.4 常见主键设计错误


**🔸 典型错误案例**
```
❌ 错误1：使用业务字段作主键
CREATE TABLE users (
    phone VARCHAR(20) PRIMARY KEY,  -- 手机号作主键
    name VARCHAR(50)
);
问题：用户换手机号无法处理

✅ 正确做法：
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    phone VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(50)
);

❌ 错误2：复合主键字段顺序错误
PRIMARY KEY (action_time, user_id)  -- 时间在前
常见查询：WHERE user_id = ? AND action_time BETWEEN ? AND ?
问题：无法有效利用主键索引

✅ 正确做法：
PRIMARY KEY (user_id, action_time)  -- 用户ID在前

❌ 错误3：主键过长
CREATE TABLE products (
    product_code VARCHAR(100) PRIMARY KEY,  -- 100字节主键
    name VARCHAR(200)
);
问题：所有二级索引都要存储这100字节

✅ 正确做法：
CREATE TABLE products (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    product_code VARCHAR(100) UNIQUE NOT NULL,
    name VARCHAR(200)
);
```

### 10.5 主键设计决策流程


```
主键设计决策流程：

开始设计主键
     ↓
是否分布式系统？
  ↙        ↘
 否          是
 ↓          ↓
单机主键     分布式主键
 ↓          ↓
BIGINT      是否需要有序？
AUTO_       ↙        ↘
INCREMENT   是          否
           ↓          ↓
         雪花算法      UUID
           ↓          
     是否超大规模？
       ↙      ↘
      是        否
      ↓        ↓
    号段分配   雪花算法
```

### 10.6 实际应用建议


**🔸 生产环境最佳实践**
```
🏆 推荐配置（适用于80%的场景）：

CREATE TABLE example_table (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '主键ID',
    business_code VARCHAR(32) UNIQUE NOT NULL COMMENT '业务编码',
    -- 其他业务字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB CHARSET=utf8mb4;

设计说明：
✅ BIGINT：长期够用，性能良好
✅ AUTO_INCREMENT：简单可靠
✅ 业务编码独立：满足业务查询需求
✅ 时间字段：便于数据管理
✅ InnoDB引擎：支持事务和外键
```

> 🎯 **核心记忆**
> 
> **主键设计原则**：能用自增就用自增，需要分布式就用雪花算法，特殊需求再考虑其他方案。主键要短小精悍，与业务逻辑分离，一旦确定就不要修改。

**🧠 记忆口诀**
```
主键设计要谨慎，
自增整数是首选，
分布式用雪花算，
UUID慎用性能差，
复合主键顺序要，
技术业务要分开。
```