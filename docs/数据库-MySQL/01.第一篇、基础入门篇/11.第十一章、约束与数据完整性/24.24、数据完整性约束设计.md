---
title: 24、数据完整性约束设计
---
## 📚 目录

1. [数据完整性基本概念](#1-数据完整性基本概念)
2. [域完整性约束](#2-域完整性约束)
3. [实体完整性保证](#3-实体完整性保证)
4. [参照完整性规则](#4-参照完整性规则)
5. [用户定义完整性](#5-用户定义完整性)
6. [多层级完整性验证体系](#6-多层级完整性验证体系)
7. [业务规则约束化设计](#7-业务规则约束化设计)
8. [数据质量监控体系](#8-数据质量监控体系)
9. [约束实现策略选择](#9-约束实现策略选择)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 数据完整性基本概念


### 1.1 什么是数据完整性


**🔸 简单理解**
数据完整性就是确保数据库中的数据是**正确的、一致的、有效的**。想象一下，如果你的银行账户余额可以是负数，或者学生的年龄可以是300岁，这样的数据显然是有问题的。

**🔸 数据完整性的作用**
```
保证数据质量：
├── 防止无效数据进入数据库
├── 确保数据符合业务规则  
├── 维护数据之间的逻辑关系
└── 提供数据可信度保障
```

### 1.2 数据完整性的四大类型


**📊 完整性分类图**
```
数据完整性
    │
    ├── 域完整性 (字段层面)
    │   └── 数据类型、取值范围、格式等
    │
    ├── 实体完整性 (记录层面)  
    │   └── 主键唯一性，记录可识别
    │
    ├── 参照完整性 (表间关系)
    │   └── 外键关系，表间数据一致
    │
    └── 用户定义完整性 (业务规则)
        └── 业务逻辑，自定义约束
```

### 1.3 为什么需要数据完整性


**🔸 没有约束的后果**
```
❌ 垃圾数据问题：
   用户年龄：-50岁、999岁
   邮箱格式：abc、12345
   订单金额：-100元

❌ 数据不一致：
   订单表有商品ID：100
   商品表没有ID为100的商品
   
❌ 业务逻辑错误：
   库存数量：-50件
   员工入职日期晚于离职日期
```

**✅ 有约束的好处**
- **数据质量**：确保数据有效可用
- **业务正确**：符合真实业务逻辑
- **系统稳定**：避免因脏数据导致的程序错误
- **维护成本**：减少后期数据清理工作

---

## 2. 📏 域完整性约束


### 2.1 域完整性基本概念


**🔸 什么是域完整性**
域完整性是指**单个字段（列）的数据必须符合预定义的规则**。这是最基础的数据约束，确保每个字段的值都是有效的。

**通俗比喻**：
- 就像表单验证一样，年龄必须是正整数，邮箱必须包含@符号
- 每个字段都有自己的"标准"，不符合标准的数据不能存入

### 2.2 域完整性约束类型


**📋 数据类型约束**
```sql
-- 基础数据类型约束
CREATE TABLE users (
    id INT,                    -- 整数类型
    name VARCHAR(50),          -- 字符串长度限制
    age TINYINT,              -- 小整数(0-255)
    salary DECIMAL(10,2),     -- 精确小数
    birthday DATE,            -- 日期类型
    is_active BOOLEAN         -- 布尔类型
);
```

**🔸 取值范围约束**
```sql
-- CHECK约束限制取值范围
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 65),        -- 年龄范围
    salary DECIMAL(10,2) CHECK (salary > 0),        -- 薪资必须为正
    gender ENUM('男', '女', '其他'),                  -- 枚举值
    level TINYINT CHECK (level BETWEEN 1 AND 10)    -- 等级范围
);
```

**🔸 格式约束**
```sql
-- 使用正则表达式约束格式
CREATE TABLE contacts (
    id INT PRIMARY KEY,
    email VARCHAR(100) CHECK (email REGEXP '^[^@]+@[^@]+\.[^@]+$'),
    phone VARCHAR(20) CHECK (phone REGEXP '^1[3-9][0-9]{9}$'),
    id_card VARCHAR(18) CHECK (LENGTH(id_card) = 18)
);
```

### 2.3 NOT NULL约束详解


**🔸 NULL值的问题**
```
NULL的含义：表示"未知"或"不存在"
NULL的特殊性：
├── NULL ≠ 0
├── NULL ≠ 空字符串''  
├── NULL与任何值比较都是NULL
└── COUNT(*)会计算NULL，COUNT(字段)不计算NULL
```

**实际应用示例**
```sql
-- 关键字段必须有值
CREATE TABLE orders (
    id INT PRIMARY KEY,
    customer_id INT NOT NULL,     -- 订单必须有客户
    product_id INT NOT NULL,      -- 订单必须有商品
    quantity INT NOT NULL,        -- 数量不能为空
    order_date DATE NOT NULL,     -- 下单时间必须记录
    remark TEXT                   -- 备注可以为空
);
```

### 2.4 默认值约束


**🔸 DEFAULT约束的作用**
```sql
-- 为字段设置合理默认值
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    status ENUM('draft', 'published') DEFAULT 'draft',    -- 默认草稿状态
    view_count INT DEFAULT 0,                             -- 默认浏览次数为0
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,       -- 默认当前时间
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**💡 默认值设计原则**
- **业务合理**：默认值要符合业务逻辑
- **安全保守**：选择最安全的默认状态
- **便于维护**：减少应用层的判断逻辑

---

## 3. 🆔 实体完整性保证


### 3.1 实体完整性基本概念


**🔸 什么是实体完整性**
实体完整性确保**每一行数据都能被唯一识别**。在数据库中，每条记录都应该有一个"身份证号"，这就是主键的作用。

**现实类比**：
```
现实世界：每个人都有身份证号，全国唯一
数据库：每条记录都有主键，全表唯一

身份证特点：
├── 唯一性：不能重复
├── 非空性：不能没有  
└── 不变性：一旦分配不能随意更改

主键特点：
├── 唯一性：PRIMARY KEY UNIQUE
├── 非空性：PRIMARY KEY NOT NULL
└── 稳定性：一般不建议修改
```

### 3.2 主键设计策略


**🔸 主键类型选择**

| **主键类型** | **优点** | **缺点** | **适用场景** |
|-------------|---------|---------|-------------|
| **自增ID** | 简单高效，性能好 | 无业务含义，分布式难处理 | 单机应用，内部系统 |
| **UUID** | 全局唯一，分布式友好 | 存储空间大，无序插入 | 分布式系统，对外接口 |
| **业务编号** | 有实际意义，便于理解 | 可能变化，管理复杂 | 业务主导的系统 |
| **复合主键** | 表达复杂关系 | 关联查询复杂 | 多对多关系表 |

**🔸 自增主键示例**
```sql
-- 最常用的主键设计
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- 自增主键
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 为什么推荐自增主键？
-- 1. 性能好：整数比较快，自增插入有序
-- 2. 空间小：4字节存储
-- 3. 简单：不需要应用层生成
```

**🔸 UUID主键示例**
```sql
-- 分布式系统推荐
CREATE TABLE orders (
    id CHAR(36) PRIMARY KEY DEFAULT (UUID()),  -- UUID主键
    customer_id INT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- UUID的特点：
-- 优点：全局唯一，分布式友好
-- 缺点：36字节存储，无序插入影响性能
```

### 3.3 唯一性约束


**🔸 UNIQUE约束**
```sql
-- 单字段唯一约束
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,     -- 用户名唯一
    email VARCHAR(100) UNIQUE,       -- 邮箱唯一
    phone VARCHAR(20) UNIQUE         -- 手机号唯一
);

-- 多字段组合唯一
CREATE TABLE course_enrollments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    student_id INT,
    course_id INT,
    UNIQUE KEY uk_student_course (student_id, course_id)  -- 学生不能重复选同一门课
);
```

---

## 4. 🔗 参照完整性规则


### 4.1 参照完整性基本概念


**🔸 什么是参照完整性**
参照完整性确保**表与表之间的关系是正确的**。当一个表引用另一个表的数据时，被引用的数据必须真实存在。

**生活化理解**：
```
现实场景：
订单 → 客户
- 每个订单都必须有对应的客户
- 不能有"幽灵订单"（客户不存在的订单）
- 客户被删除时，要考虑其订单怎么处理

数据库场景：
orders表 → customers表
- orders.customer_id 必须在 customers.id 中存在
- 这就是外键约束的作用
```

### 4.2 外键约束实现


**🔸 基础外键约束**
```sql
-- 创建主表
CREATE TABLE customers (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE
);

-- 创建从表，建立外键关系
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10,2),
    
    -- 建立外键约束
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);
```

### 4.3 参照完整性操作规则


**🔸 删除和更新规则**

| **规则** | **英文** | **含义** | **适用场景** |
|---------|---------|---------|-------------|
| **级联** | CASCADE | 主表删除时，从表相关记录也删除 | 日志记录、详细信息 |
| **设空** | SET NULL | 主表删除时，从表外键设为NULL | 可选关联关系 |
| **限制** | RESTRICT | 主表有关联记录时，禁止删除 | 重要业务数据 |
| **无动作** | NO ACTION | 同RESTRICT，但检查时机不同 | 默认行为 |

**🔸 实际应用示例**
```sql
-- 级联删除：删除客户时，自动删除其订单
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    FOREIGN KEY (customer_id) REFERENCES customers(id) 
        ON DELETE CASCADE ON UPDATE CASCADE
);

-- 设空处理：删除部门时，员工的部门ID设为NULL
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id)
        ON DELETE SET NULL ON UPDATE CASCADE
);

-- 限制删除：有员工的部门不能删除
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INT NOT NULL,
    FOREIGN KEY (department_id) REFERENCES departments(id)
        ON DELETE RESTRICT ON UPDATE CASCADE
);
```

### 4.4 外键约束的注意事项


**⚠️ 外键使用要点**
```
性能影响：
- 每次插入/更新都要检查外键
- 会影响插入性能
- 删除时可能需要级联操作

维护复杂：
- 表结构变更更复杂
- 数据迁移需要考虑外键顺序
- 测试数据准备更麻烦

替代方案：
- 应用层控制：在程序中检查关系
- 逻辑外键：不建物理约束，只在文档中说明
```

---

## 5. 🛡️ 用户定义完整性


### 5.1 业务规则约束化


**🔸 什么是用户定义完整性**
用户定义完整性是根据**具体业务需求**定义的约束规则。这些规则反映了现实业务世界的逻辑关系。

**举例说明**：
```
电商业务规则：
- 商品价格必须大于0
- 订单总金额 = 商品单价 × 数量
- 用户等级影响可购买商品类型
- 库存数量不能为负数

如何转化为数据库约束：
- 价格字段：CHECK (price > 0)
- 订单金额：触发器计算和验证
- 用户权限：通过用户定义函数检查
- 库存控制：触发器或存储过程
```

### 5.2 CHECK约束详解


**🔸 简单CHECK约束**
```sql
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) CHECK (price > 0),           -- 价格必须为正
    discount_rate DECIMAL(3,2) CHECK (discount_rate BETWEEN 0 AND 1), -- 折扣率0-1
    stock_quantity INT CHECK (stock_quantity >= 0),  -- 库存不能为负
    status ENUM('active', 'inactive', 'discontinued') DEFAULT 'active'
);
```

**🔸 复杂CHECK约束**
```sql
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    birth_date DATE NOT NULL,
    hire_date DATE NOT NULL,
    salary DECIMAL(10,2) NOT NULL,
    
    -- 复杂业务规则约束
    CHECK (hire_date >= birth_date + INTERVAL 18 YEAR),  -- 入职时至少18岁
    CHECK (salary BETWEEN 3000 AND 50000),              -- 薪资范围合理
    CHECK (hire_date <= CURDATE())                       -- 入职日期不能是未来
);
```

### 5.3 触发器实现复杂约束


**🔸 触发器约束示例**
```sql
-- 库存扣减触发器
DELIMITER //
CREATE TRIGGER check_stock_before_order
BEFORE INSERT ON order_items
FOR EACH ROW
BEGIN
    DECLARE current_stock INT;
    
    -- 查询当前库存
    SELECT stock_quantity INTO current_stock
    FROM products WHERE id = NEW.product_id;
    
    -- 检查库存是否足够
    IF current_stock < NEW.quantity THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '库存不足，无法下单';
    END IF;
    
    -- 扣减库存
    UPDATE products 
    SET stock_quantity = stock_quantity - NEW.quantity
    WHERE id = NEW.product_id;
END//
DELIMITER ;
```

---

## 6. 🏗️ 多层级完整性验证体系


### 6.1 数据完整性验证层次


**🔸 多层防护体系**
```
数据完整性验证架构：

应用层验证
    ↓
业务逻辑层验证  
    ↓
数据库约束层验证
    ↓  
存储引擎层验证
    ↓
文件系统层验证
```

### 6.2 各层级验证职责


**🔸 应用层验证**
```javascript
// 前端表单验证
function validateUser(user) {
    if (!user.email || !user.email.includes('@')) {
        return {valid: false, message: '邮箱格式不正确'};
    }
    if (user.age < 18 || user.age > 100) {
        return {valid: false, message: '年龄必须在18-100之间'};
    }
    return {valid: true};
}

// 后端API验证
@RestController
public class UserController {
    @PostMapping("/users")
    public ResponseEntity createUser(@Valid @RequestBody User user) {
        // @Valid注解自动验证请求数据
        // 业务层再次验证
        return userService.createUser(user);
    }
}
```

**🔸 数据库层验证**
```sql
-- 数据库层是最后一道防线
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(100) NOT NULL UNIQUE,
    age INT CHECK (age BETWEEN 18 AND 100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 6.3 验证策略设计


**🔸 分层验证原则**
```
快速失败原则：
├── 前端验证：立即反馈，提升用户体验
├── 后端验证：防止绕过前端的恶意请求  
├── 数据库验证：最终数据质量保障
└── 日志记录：记录所有验证失败的情况

职责分离：
├── 应用层：用户体验、复杂业务逻辑
├── 数据库层：基础约束、数据一致性
└── 不重复：避免在多层重复相同验证
```

---

## 7. 📊 业务规则约束化设计


### 7.1 业务规则识别


**🔸 如何找出业务规则**
```
业务规则来源：
1. 业务流程分析
   └── 梳理业务操作的前置条件

2. 异常场景分析  
   └── 考虑什么情况下业务会出错

3. 数据质量要求
   └── 确定数据的有效性标准

4. 法律法规要求
   └── 合规性约束
```

**实际案例：电商订单系统**
```
业务规则收集：
├── 订单金额 = 商品单价 × 数量 - 优惠金额
├── 库存数量必须大于等于订单数量
├── 用户等级决定可享受的最大折扣
├── 订单状态变化有严格的流程
├── 退款金额不能超过订单金额
└── 同一用户同一时间只能有一个待支付订单
```

### 7.2 约束实现策略


**🔸 约束实现方式对比**

| **实现方式** | **性能** | **灵活性** | **维护性** | **适用场景** |
|-------------|---------|-----------|-----------|-------------|
| **数据库约束** | 高 | 低 | 高 | 简单规则 |
| **触发器** | 中 | 中 | 中 | 中等复杂规则 |
| **存储过程** | 中 | 高 | 中 | 复杂业务逻辑 |
| **应用层验证** | 低 | 极高 | 低 | 复杂多变规则 |

**🔸 约束实现示例**
```sql
-- 1. 简单约束：直接用CHECK
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    total_amount DECIMAL(10,2) CHECK (total_amount > 0),
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled')
);

-- 2. 复杂约束：使用触发器
DELIMITER //
CREATE TRIGGER validate_order_status
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
    -- 已完成的订单不能修改状态
    IF OLD.status = 'completed' AND NEW.status != 'completed' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '已完成订单不能修改状态';
    END IF;
    
    -- 订单状态流转规则检查
    IF OLD.status = 'pending' AND NEW.status NOT IN ('paid', 'cancelled') THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '待支付订单只能变为已支付或已取消';
    END IF;
END//
DELIMITER ;
```

### 7.3 业务规则映射模式


**🔸 常见业务规则模式**
```
1. 数值范围约束
   业务：商品价格在1-10000元之间
   约束：CHECK (price BETWEEN 1 AND 10000)

2. 日期逻辑约束  
   业务：活动结束时间必须晚于开始时间
   约束：CHECK (end_date > start_date)

3. 状态转换约束
   业务：订单状态只能按规定流程变化
   约束：触发器检查状态转换规则

4. 数量平衡约束
   业务：出库数量不能超过库存数量
   约束：触发器检查库存余额

5. 唯一性组合约束
   业务：同一用户同一商品只能评价一次
   约束：UNIQUE(user_id, product_id)
```

---

## 8. 📊 数据质量监控体系


### 8.1 数据质量指标体系


**🔸 数据质量维度**
```
数据质量评估框架：

完整性 (Completeness)
├── 必填字段非空率
├── 关键信息缺失率
└── 记录完整性比例

准确性 (Accuracy)  
├── 数据格式正确率
├── 业务规则符合率
└── 与权威数据源一致性

一致性 (Consistency)
├── 跨表数据一致性
├── 冗余字段一致性  
└── 约束违反检测

及时性 (Timeliness)
├── 数据更新及时性
├── 历史数据有效性
└── 实时性要求满足率
```

### 8.2 数据质量监控实现


**🔸 监控SQL脚本**
```sql
-- 1. 完整性监控
-- 检查必填字段空值率
SELECT 
    '用户表邮箱空值率' as metric_name,
    COUNT(*) as total_records,
    SUM(CASE WHEN email IS NULL OR email = '' THEN 1 ELSE 0 END) as null_count,
    ROUND(SUM(CASE WHEN email IS NULL OR email = '' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as null_rate
FROM users;

-- 2. 一致性监控  
-- 检查订单金额与明细金额是否一致
SELECT 
    o.id as order_id,
    o.total_amount as order_total,
    SUM(oi.quantity * oi.unit_price) as detail_total,
    ABS(o.total_amount - SUM(oi.quantity * oi.unit_price)) as difference
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, o.total_amount
HAVING ABS(o.total_amount - SUM(oi.quantity * oi.unit_price)) > 0.01;

-- 3. 参照完整性监控
-- 检查孤儿记录
SELECT COUNT(*) as orphan_orders
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.id  
WHERE c.id IS NULL;
```

### 8.3 自动化数据质量检查


**🔸 定期质量检查存储过程**
```sql
DELIMITER //
CREATE PROCEDURE daily_data_quality_check()
BEGIN
    DECLARE quality_score DECIMAL(5,2) DEFAULT 100.0;
    DECLARE error_count INT DEFAULT 0;
    
    -- 创建质量检查报告表
    CREATE TEMPORARY TABLE IF NOT EXISTS quality_report (
        check_name VARCHAR(100),
        status ENUM('PASS', 'FAIL', 'WARNING'),
        error_count INT,
        error_rate DECIMAL(5,2),
        description TEXT
    );
    
    -- 检查1：邮箱格式正确性
    SELECT COUNT(*) INTO @email_errors
    FROM users 
    WHERE email NOT REGEXP '^[^@]+@[^@]+\.[^@]+$';
    
    INSERT INTO quality_report VALUES 
    ('邮箱格式检查', IF(@email_errors = 0, 'PASS', 'FAIL'), @email_errors, 
     @email_errors * 100.0 / (SELECT COUNT(*) FROM users), '检查邮箱格式合规性');
    
    -- 检查2：订单金额一致性
    -- ... 更多检查项
    
    -- 生成质量报告
    SELECT * FROM quality_report;
END//
DELIMITER ;

-- 设置定时任务
-- 每天凌晨1点执行数据质量检查
CREATE EVENT daily_quality_check
ON SCHEDULE EVERY 1 DAY STARTS '2025-01-01 01:00:00'
DO CALL daily_data_quality_check();
```

---

## 9. 🎯 约束实现策略选择


### 9.1 约束选择决策树


```
需要实现数据约束
        ↓
    约束复杂度如何？
      ↙        ↘
    简单        复杂
     ↓          ↓
  数据库约束    业务逻辑复杂度？
  (CHECK/FK)     ↙        ↘
                简单      复杂
                 ↓        ↓
               触发器    应用层验证
```

### 9.2 约束实现策略对比


**🔸 策略优缺点分析**

| **实现策略** | **优点** | **缺点** | **最佳场景** |
|-------------|---------|---------|-------------|
| **数据库约束** | 性能好，强制执行 | 灵活性差，修改困难 | 基础数据规则 |
| **触发器** | 功能强大，数据库级执行 | 调试困难，维护复杂 | 中等复杂规则 |
| **存储过程** | 逻辑集中，性能较好 | 可移植性差 | 批量数据处理 |
| **应用层验证** | 灵活性极高，易于修改 | 可能被绕过，性能开销 | 复杂业务逻辑 |

### 9.3 实际选择建议


**🔸 推荐策略组合**
```
基础约束 → 数据库约束
├── 数据类型、NOT NULL、UNIQUE
├── 简单的CHECK约束
└── 主要的外键关系

业务规则 → 应用层验证
├── 复杂的业务逻辑
├── 需要调用外部服务的验证
├── 经常变化的规则
└── 涉及多表复杂关系的验证

监控检查 → 定期批量验证
├── 数据质量报告
├── 一致性检查
├── 异常数据清理
└── 约束执行效果评估
```

### 9.4 约束设计最佳实践


**🔸 设计原则**
```
1. 就近原则
   └── 在最接近数据源的地方进行验证

2. 分层原则
   └── 不同层次负责不同类型的验证

3. 性能原则
   └── 高频操作的约束要考虑性能影响

4. 维护原则  
   └── 约束要易于理解和修改

5. 安全原则
   └── 重要约束不能仅依赖应用层
```

**🔸 约束命名规范**
```sql
-- 清晰的约束命名
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    total_amount DECIMAL(10,2),
    order_date DATE NOT NULL,
    
    -- 清晰的约束命名
    CONSTRAINT fk_orders_customer_id 
        FOREIGN KEY (customer_id) REFERENCES customers(id),
    CONSTRAINT chk_orders_total_amount_positive 
        CHECK (total_amount > 0),
    CONSTRAINT chk_orders_date_not_future 
        CHECK (order_date <= CURDATE())
);
```

---

## 10. 📋 核心要点总结


### 10.1 数据完整性四大支柱


```
🔸 域完整性：字段数据的基本有效性
   └── 数据类型、取值范围、格式要求

🔸 实体完整性：记录的唯一可识别性  
   └── 主键约束、唯一性约束

🔸 参照完整性：表间关系的正确性
   └── 外键约束、级联操作规则

🔸 用户定义完整性：业务规则的数据化
   └── CHECK约束、触发器、业务逻辑
```

### 10.2 约束设计关键原则


**🧠 设计思维要点**
```
从业务到技术：
1. 理解业务规则
2. 识别数据关系  
3. 选择约束类型
4. 设计验证策略
5. 实现监控机制

平衡考虑：
├── 数据质量 vs 系统性能
├── 约束严格性 vs 操作灵活性
├── 数据库约束 vs 应用层验证  
└── 当前需求 vs 未来扩展
```

### 10.3 实施roadmap


**🔸 约束实施步骤**
```
阶段1：现状分析
├── 梳理现有数据质量问题
├── 识别关键业务规则
└── 评估约束实施风险

阶段2：基础约束
├── 实施域完整性约束
├── 建立主键和唯一约束
└── 添加基本的CHECK约束

阶段3：关系约束  
├── 设计外键关系
├── 确定级联规则
└── 测试参照完整性

阶段4：业务约束
├── 实现复杂业务规则
├── 建立监控体系
└── 完善异常处理

阶段5：持续优化
├── 监控约束执行效果
├── 优化性能问题
└── 根据业务变化调整约束
```

### 10.4 常见问题解决


**🔸 约束实施常见问题**

| **问题** | **原因** | **解决方案** |
|---------|---------|-------------|
| **约束过于严格** | 业务理解不够深入 | 放宽约束条件，增加例外处理 |
| **性能影响大** | 约束检查开销高 | 优化约束逻辑，考虑异步验证 |
| **约束冲突** | 多个约束相互矛盾 | 重新梳理业务逻辑，调整约束优先级 |
| **历史数据不符合** | 新约束与旧数据冲突 | 数据清理或约束例外处理 |

---

> 💡 **核心记忆要点**
> 
> **数据完整性 = 数据质量保障**
> 
> - **域完整性**：确保字段数据有效（类型、范围、格式）
> - **实体完整性**：确保记录唯一可识别（主键）
> - **参照完整性**：确保表间关系正确（外键）
> - **用户定义完整性**：确保业务规则正确（CHECK、触发器）
> 
> **设计原则**：从简单到复杂，从基础到业务，分层验证，持续监控
> 
> **实施策略**：数据库约束处理基础规则，应用层处理复杂逻辑，监控体系保证长期质量