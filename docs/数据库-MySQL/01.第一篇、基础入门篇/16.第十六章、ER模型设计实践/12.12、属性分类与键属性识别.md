---
title: 12、属性分类与键属性识别
---
## 📚 目录

1. [属性分类基础概念](#1-属性分类基础概念)
2. [简单属性vs复合属性](#2-简单属性vs复合属性)
3. [单值属性vs多值属性](#3-单值属性vs多值属性)
4. [存储属性vs派生属性](#4-存储属性vs派生属性)
5. [键属性识别技巧](#5-键属性识别技巧)
6. [描述性属性识别方法](#6-描述性属性识别方法)
7. [属性设计基础原则](#7-属性设计基础原则)
8. [实际设计案例分析](#8-实际设计案例分析)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 属性分类基础概念


### 1.1 什么是属性


**简单理解**：属性就是用来描述实体特征的"标签"，就像人的身份证上有姓名、年龄、地址等信息一样。

```
现实世界的人：              数据库中的学生实体：
姓名：张三                  姓名：字符串类型
年龄：25岁                  年龄：整数类型  
身高：175cm                身高：浮点数类型
地址：北京市朝阳区           地址：字符串类型
电话：138xxxx1234          电话：字符串类型

每个特征都是一个属性！
```

### 1.2 属性分类方法概览


**属性分类的三个维度**：
```
📊 属性分类体系：

按结构复杂度分类：
├─ 简单属性 (Simple Attribute)
└─ 复合属性 (Composite Attribute)

按取值数量分类：  
├─ 单值属性 (Single-valued Attribute)
└─ 多值属性 (Multi-valued Attribute)

按存储方式分类：
├─ 存储属性 (Stored Attribute)  
└─ 派生属性 (Derived Attribute)

按功能作用分类：
├─ 键属性 (Key Attribute)
└─ 描述性属性 (Descriptive Attribute)
```

### 1.3 属性分类的实际意义


**为什么要进行属性分类**：
- **设计指导**：不同类型属性有不同的设计方法
- **存储优化**：根据属性特点选择合适的存储方式
- **查询效率**：键属性需要建立索引，派生属性不需要存储
- **数据完整性**：不同属性有不同的约束要求

---

## 2. 🔧 简单属性vs复合属性


### 2.1 简单属性详解


**定义**：不能再分解的基本属性，是属性的"原子"单位。

**特点**：
- **不可分割**：在当前应用场景下不需要进一步分解
- **单一含义**：只表达一个概念
- **直接使用**：可以直接用于查询和操作

```
简单属性示例：

学生实体的简单属性：
┌─────────────┬─────────────┬─────────────┐
│ 属性名称     │ 数据类型     │ 典型值      │
├─────────────┼─────────────┼─────────────┤
│ 学号        │ VARCHAR(10) │ 2021001001  │
│ 年龄        │ INT         │ 20          │
│ 性别        │ CHAR(1)     │ M/F         │
│ 出生日期     │ DATE        │ 1998-03-15  │
│ 电话号码     │ VARCHAR(11) │ 13812345678 │
└─────────────┴─────────────┴─────────────┘

这些属性在学生管理系统中通常不需要进一步分解
```

### 2.2 复合属性详解


**定义**：由多个简单属性组成的属性，可以分解为更小的组成部分。

**为什么需要复合属性**：
```
现实需求：地址信息
完整地址："北京市朝阳区建国路88号SOHO现代城A座1201室"

不同使用场景的需求：
• 邮寄场景：需要完整地址字符串
• 统计分析：只需要省份、城市信息
• 地图定位：需要详细的街道、门牌号
• 区域分析：需要区县级别的信息

如果只用简单属性，要么信息不够详细，要么冗余存储
```

**🔸 复合属性设计示例**：
```
地址复合属性分解：

地址 (Address) - 复合属性
├─ 省份 (Province) - 简单属性
├─ 城市 (City) - 简单属性  
├─ 区县 (District) - 简单属性
├─ 街道 (Street) - 简单属性
├─ 门牌号 (Number) - 简单属性
└─ 详细地址 (Detail) - 简单属性

ER图表示：
     Address
    /   |   \
Province City District
   |      |      |
Street Number Detail

实际存储设计：
方案1：分别存储各个组成部分
CREATE TABLE student (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    addr_province VARCHAR(20),  -- 省份
    addr_city VARCHAR(30),      -- 城市
    addr_district VARCHAR(30),  -- 区县
    addr_street VARCHAR(100),   -- 街道
    addr_number VARCHAR(20),    -- 门牌号
    addr_detail VARCHAR(200)    -- 详细地址
);

方案2：同时存储完整地址和组成部分
CREATE TABLE student (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    full_address VARCHAR(500),  -- 完整地址
    province VARCHAR(20),       -- 便于查询统计
    city VARCHAR(30),
    district VARCHAR(30)
);
```

### 2.3 复合属性的嵌套结构


**多层嵌套的复合属性**：
```
员工实体的联系方式属性：

联系方式 (Contact) - 复合属性
├─ 地址 (Address) - 复合属性
│  ├─ 家庭地址 (Home Address) - 复合属性
│  │  ├─ 省份 (Province) - 简单属性
│  │  ├─ 城市 (City) - 简单属性
│  │  └─ 详细地址 (Detail) - 简单属性
│  └─ 办公地址 (Office Address) - 复合属性
│     ├─ 省份 (Province) - 简单属性
│     ├─ 城市 (City) - 简单属性
│     └─ 详细地址 (Detail) - 简单属性
└─ 电话 (Phone) - 复合属性
   ├─ 手机号 (Mobile) - 简单属性
   ├─ 座机号 (Landline) - 简单属性
   └─ 分机号 (Extension) - 简单属性

树状结构表示：
Contact
├── Address
│   ├── HomeAddress
│   │   ├── Province
│   │   ├── City  
│   │   └── Detail
│   └── OfficeAddress
│       ├── Province
│       ├── City
│       └── Detail
└── Phone
    ├── Mobile
    ├── Landline
    └── Extension
```

### 2.4 简单vs复合属性的选择原则


**🔸 选择决策表**：
```
选择简单属性的情况：
✅ 属性在业务中作为整体使用
✅ 不需要基于组成部分进行查询
✅ 组成部分没有独立的业务意义
✅ 系统复杂度要求尽量简单

选择复合属性的情况：  
✅ 需要基于组成部分进行查询和统计
✅ 组成部分有独立的业务价值
✅ 不同场景需要不同粒度的信息
✅ 便于数据校验和格式化
```

**实际判断例子**：
```
姓名属性的设计选择：

场景1：简单的学生管理系统
设计：name VARCHAR(50) - 简单属性
理由：只需要显示完整姓名，不需要分别处理姓和名

场景2：国际化的人力资源系统  
设计：复合属性
├─ 姓 (LastName)
├─ 名 (FirstName)  
├─ 中间名 (MiddleName)
└─ 称谓 (Title)
理由：需要支持不同文化的姓名格式，需要按姓氏排序统计

场景3：中文环境的政务系统
设计：复合属性
├─ 姓氏 (Surname)
└─ 名字 (GivenName)
理由：需要按姓氏进行统计分析，支持同姓查询
```

---

## 3. 📊 单值属性vs多值属性


### 3.1 单值属性详解


**定义**：对于一个实体实例，该属性只能有一个值。

**特点**：
- **唯一性**：每个实体实例对应一个属性值
- **原子性**：符合关系数据库第一范式要求
- **查询简单**：可以直接建立索引和查询

```
单值属性示例：

学生实体的单值属性：
┌─────────────┬─────────────┬─────────────┐
│ 属性名称     │ 值示例      │ 说明        │
├─────────────┼─────────────┼─────────────┤
│ 学号        │ 2021001001  │ 每人唯一    │
│ 身份证号     │ 110101xxxxx │ 每人唯一    │
│ 出生日期     │ 1998-03-15  │ 每人一个    │
│ 当前年级     │ 大三        │ 当前状态    │
│ 当前GPA     │ 3.75        │ 计算结果    │
└─────────────┴─────────────┴─────────────┘

数据库存储：
CREATE TABLE student (
    student_id VARCHAR(10) PRIMARY KEY,  -- 学号
    id_card VARCHAR(18) UNIQUE,          -- 身份证号
    birth_date DATE,                     -- 出生日期
    current_grade VARCHAR(10),           -- 当前年级
    current_gpa DECIMAL(3,2)             -- 当前GPA
);
```

### 3.2 多值属性详解


**定义**：对于一个实体实例，该属性可以有多个值。

**现实场景**：
```
现实中的多值情况：
• 一个人可以有多个电话号码（手机、座机、家庭电话）
• 一个学生可以有多个兴趣爱好（篮球、音乐、读书）
• 一个员工可以掌握多种技能（Java、Python、前端）
• 一个产品可以有多个颜色（红色、蓝色、绿色）

如果强行用单值属性：
hobby1, hobby2, hobby3, ...  -- 数量限制，扩展困难
hobby_list TEXT              -- 查询困难，违反范式
```

**🔸 多值属性的ER图表示**：
```
学生实体的多值属性：

学生 (Student)
├─ 学号 (StudentID) - 单值属性，键属性
├─ 姓名 (Name) - 单值属性
├─ 年龄 (Age) - 单值属性
├─ 电话 (Phone) - 多值属性 {{phone1, phone2, ...}}
└─ 爱好 (Hobby) - 多值属性 {{hobby1, hobby2, ...}}

ER图符号约定：
• 单值属性：直线连接 ─○─ 
• 多值属性：双线连接 ═○═ 或用双椭圆表示

图示：
      Phone
     ╔═══○═══╗
     ║       ║
   Student ═○═ Hobby
     ║       ║  
     ╚═══○═══╝
      Name
```

### 3.3 多值属性的数据库实现


**🔸 实现方案对比**：

**方案一：创建独立的属性表**（推荐）
```sql
-- 学生主表
CREATE TABLE student (
    student_id VARCHAR(10) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT
);

-- 学生电话表（多值属性表）
CREATE TABLE student_phone (
    student_id VARCHAR(10),
    phone VARCHAR(15),
    phone_type VARCHAR(10),  -- 手机、座机、家庭电话
    PRIMARY KEY (student_id, phone),
    FOREIGN KEY (student_id) REFERENCES student(student_id)
);

-- 学生爱好表（多值属性表）
CREATE TABLE student_hobby (
    student_id VARCHAR(10),
    hobby VARCHAR(30),
    skill_level VARCHAR(10),  -- 初级、中级、高级
    PRIMARY KEY (student_id, hobby),
    FOREIGN KEY (student_id) REFERENCES student(student_id)
);

使用示例：
-- 查询学生张三的所有电话
SELECT s.name, sp.phone, sp.phone_type 
FROM student s 
JOIN student_phone sp ON s.student_id = sp.student_id 
WHERE s.name = '张三';

-- 查询爱好篮球的所有学生
SELECT s.name 
FROM student s 
JOIN student_hobby sh ON s.student_id = sh.student_id 
WHERE sh.hobby = '篮球';
```

**方案二：JSON字段存储**（适用于查询需求简单的场景）
```sql
-- 使用JSON字段存储多值属性
CREATE TABLE student (
    student_id VARCHAR(10) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT,
    phones JSON,  -- ["13812345678", "010-12345678"]
    hobbies JSON  -- ["篮球", "音乐", "读书"]
);

-- 插入数据
INSERT INTO student VALUES (
    '2021001001', 
    '张三', 
    20,
    '["13812345678", "010-12345678", "400-123-4567"]',
    '["篮球", "音乐", "编程"]'
);

-- 查询包含特定爱好的学生
SELECT name, hobbies 
FROM student 
WHERE JSON_CONTAINS(hobbies, '"篮球"');
```

### 3.4 多值属性设计注意事项


**🔸 设计原则**：
```
何时使用独立表：
✅ 需要对多值进行复杂查询
✅ 多值有额外的描述属性
✅ 多值的数量变化很大
✅ 需要建立多值的统计分析

何时使用JSON存储：
✅ 多值查询需求简单
✅ 多值数量相对固定且较少
✅ 主要用于显示，很少用于查询条件
✅ 系统支持JSON查询功能

避免的错误设计：
❌ hobby1, hobby2, hobby3（固定字段数）
❌ hobby_list VARCHAR(500)（字符串拼接）
❌ 在主表中重复存储（违反范式）
```

**🔸 多值属性查询优化**：
```sql
-- 为多值属性表建立适当索引
CREATE INDEX idx_student_phone_type ON student_phone(phone_type);
CREATE INDEX idx_student_hobby_name ON student_hobby(hobby);

-- 统计各种爱好的学生数量
SELECT hobby, COUNT(*) as student_count
FROM student_hobby 
GROUP BY hobby 
ORDER BY student_count DESC;

-- 查询既爱好篮球又爱好音乐的学生
SELECT s.name 
FROM student s
WHERE s.student_id IN (
    SELECT student_id FROM student_hobby WHERE hobby = '篮球'
) AND s.student_id IN (
    SELECT student_id FROM student_hobby WHERE hobby = '音乐'  
);
```

---

## 4. 💾 存储属性vs派生属性


### 4.1 存储属性详解


**定义**：直接存储在数据库中的属性，是数据的基本事实。

**特点**：
- **基础数据**：是其他信息的计算基础
- **直接存储**：占用实际的存储空间
- **用户输入**：通常由用户直接录入或系统采集
- **更新频率**：相对稳定，不会自动变化

```
存储属性示例：

员工实体的存储属性：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性名称     │ 数据来源     │ 更新方式     │ 业务含义     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 员工号      │ 系统生成     │ 创建时分配   │ 唯一标识     │
│ 姓名        │ 用户输入     │ 手动修改     │ 基本信息     │
│ 出生日期     │ 用户输入     │ 几乎不变     │ 基础事实     │
│ 入职日期     │ HR录入      │ 几乎不变     │ 工作记录     │
│ 基本工资     │ HR设置      │ 定期调整     │ 薪酬基础     │
│ 部门编号     │ 管理员分配   │ 偶尔调整     │ 组织关系     │
└─────────────┴─────────────┴─────────────┴─────────────┘

数据库设计：
CREATE TABLE employee (
    emp_id VARCHAR(10) PRIMARY KEY,        -- 员工号（存储）
    name VARCHAR(50) NOT NULL,             -- 姓名（存储）
    birth_date DATE NOT NULL,              -- 出生日期（存储）
    hire_date DATE NOT NULL,               -- 入职日期（存储）
    base_salary DECIMAL(10,2),             -- 基本工资（存储）
    department_id VARCHAR(5)               -- 部门编号（存储）
);
```

### 4.2 派生属性详解


**定义**：可以从其他属性计算得出的属性，不需要单独存储。

**为什么需要派生属性**：
```
现实需求：年龄信息
• 存储出生日期：1998-03-15（基础事实）
• 派生当前年龄：25岁（计算得出）

派生属性的优势：
• 避免数据冗余：年龄可以从出生日期计算
• 保证数据一致性：年龄总是与出生日期匹配
• 自动更新：年龄会随时间自动"更新"
• 节省存储空间：不需要额外存储
```

**🔸 派生属性计算示例**：
```sql
-- 派生属性的计算方式

-- 计算员工年龄（从出生日期派生）
SELECT 
    emp_id,
    name,
    birth_date,
    TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) AS age  -- 派生属性
FROM employee;

-- 计算工作年限（从入职日期派生）
SELECT 
    emp_id,
    name,
    hire_date,
    TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) AS work_years  -- 派生属性
FROM employee;

-- 计算订单总金额（从订单明细派生）
SELECT 
    order_id,
    SUM(quantity * unit_price) AS total_amount  -- 派生属性
FROM order_detail 
GROUP BY order_id;
```

### 4.3 派生属性的设计策略


**🔸 是否存储派生属性的决策**：
```
不存储派生属性（推荐）：
✅ 计算简单且快速
✅ 源数据变化频繁
✅ 存储空间珍贵
✅ 数据一致性要求高

存储派生属性（特殊情况）：
✅ 计算复杂且耗时
✅ 源数据很少变化
✅ 查询频率极高
✅ 历史数据分析需要

混合策略（实用方案）：
✅ 实时计算用于当前查询
✅ 定期缓存用于报表分析
✅ 异步更新减少性能影响
```

**🔸 派生属性缓存策略**：
```sql
-- 为复杂派生属性创建物化视图
CREATE VIEW employee_summary AS
SELECT 
    emp_id,
    name,
    TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) AS age,
    TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) AS work_years,
    CASE 
        WHEN TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) >= 10 THEN '资深员工'
        WHEN TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) >= 5 THEN '经验员工'
        ELSE '新员工'
    END AS employee_level
FROM employee;

-- 对于复杂的统计派生属性，可以创建汇总表
CREATE TABLE department_statistics (
    dept_id VARCHAR(5) PRIMARY KEY,
    total_employees INT,           -- 派生：员工总数
    avg_age DECIMAL(4,1),         -- 派生：平均年龄
    avg_work_years DECIMAL(4,1),  -- 派生：平均工作年限
    total_salary DECIMAL(12,2),   -- 派生：工资总额
    last_updated TIMESTAMP        -- 更新时间
);

-- 定期更新汇总表（可以用存储过程或定时任务）
DELIMITER //
CREATE PROCEDURE update_dept_statistics()
BEGIN
    REPLACE INTO department_statistics 
    SELECT 
        d.dept_id,
        COUNT(e.emp_id),
        AVG(TIMESTAMPDIFF(YEAR, e.birth_date, CURDATE())),
        AVG(TIMESTAMPDIFF(YEAR, e.hire_date, CURDATE())),
        SUM(e.base_salary),
        NOW()
    FROM department d
    LEFT JOIN employee e ON d.dept_id = e.department_id
    GROUP BY d.dept_id;
END //
DELIMITER ;
```

### 4.4 常见派生属性类型


**🔸 数值计算型**：
```
订单系统中的派生属性：

存储属性：
• 商品单价 (unit_price)
• 购买数量 (quantity)  
• 优惠券面额 (discount_amount)

派生属性：
• 小计金额 = 单价 × 数量
• 优惠后金额 = 小计金额 - 优惠券面额
• 应付金额 = 优惠后金额 + 运费
• 节省金额 = 原价 - 实付金额

计算示例：
商品A：单价100元，数量3，优惠20元，运费10元
├─ 小计金额 = 100 × 3 = 300元
├─ 优惠后金额 = 300 - 20 = 280元  
├─ 应付金额 = 280 + 10 = 290元
└─ 节省金额 = 300 - 290 = 10元
```

**🔸 统计聚合型**：
```sql
-- 学生成绩统计的派生属性
SELECT 
    student_id,
    COUNT(*) AS total_courses,                    -- 总课程数
    AVG(score) AS average_score,                  -- 平均分
    MAX(score) AS highest_score,                  -- 最高分
    MIN(score) AS lowest_score,                   -- 最低分
    SUM(CASE WHEN score >= 60 THEN 1 ELSE 0 END) AS passed_courses,  -- 及格课程数
    COUNT(*) - SUM(CASE WHEN score >= 60 THEN 1 ELSE 0 END) AS failed_courses  -- 不及格课程数
FROM student_score 
GROUP BY student_id;
```

**🔸 状态判断型**：
```sql
-- 基于多个条件的状态派生
SELECT 
    emp_id,
    name,
    base_salary,
    TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) AS work_years,
    -- 派生员工等级
    CASE 
        WHEN TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) >= 10 
             AND base_salary >= 15000 THEN '高级员工'
        WHEN TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) >= 5 
             AND base_salary >= 10000 THEN '中级员工'
        WHEN TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) >= 2 THEN '初级员工'
        ELSE '实习员工'
    END AS employee_level,
    -- 派生薪资等级
    CASE
        WHEN base_salary >= 20000 THEN 'A'
        WHEN base_salary >= 15000 THEN 'B'  
        WHEN base_salary >= 10000 THEN 'C'
        ELSE 'D'
    END AS salary_grade
FROM employee;
```

---

## 5. 🔑 键属性识别技巧


### 5.1 键属性基本概念


**什么是键属性**：能够唯一标识实体实例的属性，就像每个人的身份证号码一样。

**简单理解**：
```
现实生活中的"键"：
• 身份证号 → 唯一标识一个人
• 车牌号 → 唯一标识一辆车  
• 学号 → 唯一标识一个学生
• 订单号 → 唯一标识一个订单

数据库中的键属性特点：
• 唯一性：不同实体实例的键值不能相同
• 非空性：键属性的值不能为空
• 稳定性：键值一旦确定，尽量不要修改
• 最小性：用最少的属性组合实现唯一标识
```

### 5.2 键属性的类型


**🔸 候选键(Candidate Key)**：
```
定义：能够唯一标识实体的属性或属性组合

学生实体的候选键分析：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性组合     │ 唯一性      │ 稳定性      │ 是否为候选键 │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 学号        │ ✅ 唯一     │ ✅ 稳定     │ ✅ 是       │
│ 身份证号     │ ✅ 唯一     │ ✅ 稳定     │ ✅ 是       │
│ 姓名        │ ❌ 可重复   │ ✅ 稳定     │ ❌ 否       │
│ 姓名+出生日期│ ✅ 基本唯一 │ ✅ 稳定     │ ⚠️ 可能     │
│ 手机号      │ ✅ 唯一     │ ❌ 可能变化 │ ⚠️ 不建议   │
└─────────────┴─────────────┴─────────────┴─────────────┘

结论：学号和身份证号都是候选键
```

**🔸 主键(Primary Key)**：
```
定义：从候选键中选择的主要标识符

主键选择原则：
• 稳定性：值不应该经常变化
• 简洁性：尽量简短，便于引用
• 业务无关性：不依赖具体业务逻辑
• 性能考虑：适合作为索引键

主键选择示例：
候选键1：学号 (student_id) 
候选键2：身份证号 (id_card)

选择学号作为主键的理由：
✅ 长度较短（10位 vs 18位）
✅ 格式统一（学校内部编码规则）
✅ 业务友好（师生都熟悉）
✅ 索引效率高（定长字符串）

CREATE TABLE student (
    student_id VARCHAR(10) PRIMARY KEY,  -- 主键
    id_card VARCHAR(18) UNIQUE,          -- 候选键，唯一约束
    name VARCHAR(50) NOT NULL
);
```

**🔸 外键(Foreign Key)**：
```
定义：引用其他实体主键的属性

外键设计示例：
选课实体需要引用学生和课程：

学生实体：student_id（主键）
课程实体：course_id（主键）
选课实体：
├─ student_id（外键，引用学生）
├─ course_id（外键，引用课程）  
└─ enrollment_date（描述性属性）

CREATE TABLE enrollment (
    student_id VARCHAR(10),
    course_id VARCHAR(8), 
    enrollment_date DATE,
    grade DECIMAL(4,1),
    PRIMARY KEY (student_id, course_id),  -- 复合主键
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (course_id) REFERENCES course(course_id)
);
```

### 5.3 键属性识别实战技巧


**🔸 键属性识别步骤**：
```
步骤1：列出所有可能的候选键
• 分析每个属性是否具有唯一性
• 考虑属性组合的唯一性
• 排除明显不唯一的属性

步骤2：评估候选键的质量
• 稳定性评分：值是否经常变化？
• 简洁性评分：长度是否合适？
• 业务友好性：是否便于使用？
• 技术性能：是否适合做索引？

步骤3：选择主键
• 优先选择人工键（如学号、员工号）
• 次选稳定的自然键（如身份证号）
• 避免选择业务含义强的键（如邮箱）
• 考虑使用自增ID作为代理键

步骤4：处理其他候选键
• 设置唯一约束（UNIQUE）
• 建立唯一索引提高查询性能
• 在应用层进行重复性检查
```

**🔸 实际案例分析**：
```
商品管理系统的键属性识别：

商品实体分析：
┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性名称     │ 唯一性分析   │ 稳定性分析   │ 实用性分析   │ 推荐级别     │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 商品ID      │ ✅ 系统保证  │ ✅ 永不变化  │ ✅ 简短易用  │ 🥇 首选主键  │
│ 商品编码     │ ✅ 业务规则  │ ⚠️ 可能调整  │ ✅ 有业务含义│ 🥈 备选候选键│
│ 商品名称     │ ❌ 可能重复  │ ⚠️ 可能修改  │ ✅ 用户友好  │ ❌ 不适合    │
│ 条形码      │ ✅ 全球唯一  │ ✅ 相对稳定  │ ⚠️ 较长     │ 🥉 可考虑    │
│ SKU编码     │ ✅ 唯一     │ ✅ 稳定     │ ✅ 业务标准  │ 🥈 好选择    │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘

最终设计决策：
CREATE TABLE product (
    product_id INT AUTO_INCREMENT PRIMARY KEY,  -- 主键：简单自增ID
    sku_code VARCHAR(20) UNIQUE,                -- 候选键：SKU编码
    barcode VARCHAR(13) UNIQUE,                 -- 候选键：条形码
    product_name VARCHAR(100) NOT NULL,         -- 描述性属性
    price DECIMAL(10,2),                        -- 描述性属性
    stock_quantity INT DEFAULT 0                -- 描述性属性
);
```

### 5.4 复合键的设计


**什么是复合键**：由多个属性组合而成的键，当单个属性无法保证唯一性时使用。

```
复合键应用场景：

选课记录实体：
• 学生ID：不唯一（一个学生可以选多门课）
• 课程ID：不唯一（一门课可以被多个学生选择）
• 学生ID + 课程ID：唯一（一个学生选择一门课只能有一条记录）

订单明细实体：
• 订单ID：不唯一（一个订单可以有多个商品）
• 商品ID：不唯一（一个商品可以出现在多个订单中）
• 订单ID + 商品ID：唯一（在同一订单中，每个商品只能有一条记录）

复合键设计：
CREATE TABLE order_detail (
    order_id VARCHAR(20),
    product_id INT,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (order_id, product_id),  -- 复合主键
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES product(product_id)
);
```

---

## 6. 📝 描述性属性识别方法


### 6.1 描述性属性基本概念


**定义**：描述实体特征和性质的属性，不用于唯一标识实体。

**类比理解**：
```
身份证信息类比：
键属性 = 身份证号码（唯一标识）
描述性属性 = 其他所有信息（姓名、性别、地址等）

学生管理系统类比：
键属性 = 学号（用来找到这个学生）
描述性属性 = 姓名、年龄、专业、成绩等（描述学生的特征）
```

### 6.2 描述性属性的分类


**🔸 基本信息属性**：
```
个人基本信息：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性类型     │ 属性示例     │ 数据特点     │ 业务用途     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 身份信息     │ 姓名、性别   │ 相对稳定     │ 基本展示     │
│ 联系方式     │ 电话、邮箱   │ 可能变化     │ 沟通联络     │
│ 地址信息     │ 家庭地址     │ 偶尔变化     │ 邮寄服务     │
│ 时间信息     │ 出生日期     │ 永不变化     │ 年龄计算     │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

**🔸 状态属性**：
```
动态状态信息：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 状态类型     │ 属性示例     │ 变化频率     │ 业务含义     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 活跃状态     │ 是否在校     │ 学期变化     │ 权限控制     │
│ 学业状态     │ 当前年级     │ 每年变化     │ 课程安排     │
│ 财务状态     │ 欠费金额     │ 实时变化     │ 缴费提醒     │
│ 健康状态     │ 体检结果     │ 定期更新     │ 健康管理     │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

### 6.3 描述性属性设计原则


**🔸 属性粒度选择**：
```
粗粒度 vs 细粒度的选择：

地址属性设计：
粗粒度设计：
• 地址 VARCHAR(200) -- "北京市朝阳区建国路88号"

细粒度设计：  
• 省份 VARCHAR(20) -- "北京市"
• 城市 VARCHAR(30) -- "朝阳区"
• 街道 VARCHAR(100) -- "建国路88号"

选择依据：
业务需求：是否需要按地区统计分析？
查询模式：是否需要按省市查询？
数据质量：细粒度有助于数据校验
系统复杂度：细粒度增加设计复杂度

实际建议：
• 统计分析需求多 → 选择细粒度
• 主要用于显示 → 选择粗粒度  
• 数据来源规范 → 可以选择细粒度
• 数据来源复杂 → 建议粗粒度
```

**🔸 可空性设计**：
```
属性可空性决策：

必填属性（NOT NULL）：
✅ 业务逻辑必需的属性
✅ 用于计算其他值的属性
✅ 外键属性（通常情况）
✅ 核心业务属性

可选属性（NULLABLE）：
✅ 补充信息类属性
✅ 可能暂时缺失的属性  
✅ 不影响核心业务的属性
✅ 历史数据可能不完整的属性

示例设计：
CREATE TABLE student (
    student_id VARCHAR(10) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,           -- 必填：核心信息
    gender CHAR(1) NOT NULL,             -- 必填：基本信息
    birth_date DATE NOT NULL,            -- 必填：用于年龄计算
    id_card VARCHAR(18) UNIQUE,          -- 可选：可能暂时没有
    phone VARCHAR(11),                   -- 可选：联系方式
    email VARCHAR(100),                  -- 可选：补充联系方式
    address VARCHAR(200),                -- 可选：地址信息
    emergency_contact VARCHAR(50),       -- 可选：紧急联系人
    remarks TEXT                         -- 可选：备注信息
);
```

### 6.4 键属性识别的实战案例


**🔸 电商系统用户表设计**：
```
用户实体属性分析：

候选键识别：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性名称     │ 唯一性      │ 业务含义     │ 推荐级别     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 用户ID      │ ✅ 系统保证  │ 内部标识     │ 🥇 主键首选  │
│ 用户名      │ ✅ 业务唯一  │ 登录标识     │ 🥈 候选键    │
│ 邮箱地址     │ ✅ 业务唯一  │ 找回密码     │ 🥈 候选键    │
│ 手机号      │ ✅ 业务唯一  │ 身份验证     │ 🥈 候选键    │
│ 身份证号     │ ✅ 法定唯一  │ 实名认证     │ 🥉 特殊候选键│
└─────────────┴─────────────┴─────────────┴─────────────┘

最终设计：
CREATE TABLE user (
    user_id BIGINT AUTO_INCREMENT PRIMARY KEY,  -- 主键：系统生成
    username VARCHAR(30) UNIQUE NOT NULL,       -- 候选键：用户名
    email VARCHAR(100) UNIQUE,                  -- 候选键：邮箱
    phone VARCHAR(11) UNIQUE,                   -- 候选键：手机号
    id_card VARCHAR(18) UNIQUE,                 -- 候选键：身份证
    
    -- 描述性属性
    nickname VARCHAR(50),                       -- 昵称
    real_name VARCHAR(50),                      -- 真实姓名
    gender CHAR(1),                            -- 性别
    birth_date DATE,                           -- 出生日期
    avatar_url VARCHAR(200),                   -- 头像URL
    bio TEXT,                                  -- 个人简介
    
    -- 状态属性
    status TINYINT DEFAULT 1,                  -- 账号状态
    is_verified BOOLEAN DEFAULT FALSE,         -- 是否认证
    last_login_time TIMESTAMP,                 -- 最后登录时间
    
    -- 系统属性
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**🔸 订单系统键属性设计**：
```
订单实体的复合场景：

订单主表：
主键：order_id（订单号）
外键：user_id（用户ID）

订单明细表：
复合主键：(order_id, product_id)
外键：order_id → orders.order_id
外键：product_id → product.product_id

设计逻辑：
┌─────────────────────────────────────────┐
│ 订单 (Order)                            │
│ ├─ order_id [PK] - 主键                 │
│ ├─ user_id [FK] - 外键，引用用户         │
│ ├─ order_date - 下单时间                │
│ ├─ total_amount - 订单总金额             │
│ └─ status - 订单状态                    │
└─────────────────────────────────────────┘
                    │
                    │ 一对多关系
                    ▼
┌─────────────────────────────────────────┐
│ 订单明细 (OrderDetail)                  │
│ ├─ order_id [PK,FK] - 复合主键，外键    │
│ ├─ product_id [PK,FK] - 复合主键，外键  │
│ ├─ quantity - 购买数量                  │
│ ├─ unit_price - 单价                   │
│ └─ discount - 折扣                     │
└─────────────────────────────────────────┘

CREATE TABLE orders (
    order_id VARCHAR(20) PRIMARY KEY,
    user_id BIGINT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(12,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    FOREIGN KEY (user_id) REFERENCES user(user_id)
);

CREATE TABLE order_detail (
    order_id VARCHAR(20),
    product_id INT,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    discount DECIMAL(5,2) DEFAULT 0,
    PRIMARY KEY (order_id, product_id),  -- 复合主键
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES product(product_id)
);
```

---

## 7. 🎨 属性设计基础原则


### 7.1 原子性原则


**第一范式要求**：属性必须是原子的，不可再分。

```
原子性判断标准：
• 在当前业务场景下是否需要进一步分解？
• 是否需要基于组成部分进行查询？
• 组成部分是否有独立的业务含义？

正确示例：
❌ 错误设计：full_name VARCHAR(100) -- "张三|男|25"
✅ 正确设计：
   ├─ name VARCHAR(50)      -- "张三"
   ├─ gender CHAR(1)        -- "M"  
   └─ age INT               -- 25

❌ 错误设计：course_info VARCHAR(200) -- "数据库原理|3学分|李教授"
✅ 正确设计：
   ├─ course_name VARCHAR(100)  -- "数据库原理"
   ├─ credits INT               -- 3
   └─ instructor VARCHAR(50)    -- "李教授"
```

### 7.2 最小化原则


**避免冗余属性**：每个属性都应该有独特的业务价值。

```
冗余属性识别：

学生成绩管理中的冗余问题：
❌ 冗余设计：
CREATE TABLE student_score (
    student_id VARCHAR(10),
    student_name VARCHAR(50),  -- 冗余：可以从student表获取
    course_id VARCHAR(8),
    course_name VARCHAR(100),  -- 冗余：可以从course表获取
    score DECIMAL(4,1),
    semester VARCHAR(10)
);

✅ 规范设计：
CREATE TABLE student_score (
    student_id VARCHAR(10),
    course_id VARCHAR(8), 
    score DECIMAL(4,1),
    semester VARCHAR(10),
    PRIMARY KEY (student_id, course_id, semester),
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (course_id) REFERENCES course(course_id)
);

-- 需要姓名和课程名时通过JOIN获取
SELECT s.name, c.course_name, sc.score
FROM student_score sc
JOIN student s ON sc.student_id = s.student_id  
JOIN course c ON sc.course_id = c.course_id;
```

### 7.3 业务相关性原则


**属性必须与实体直接相关**：不应该包含属于其他实体的属性。

```
属性归属判断：

用户订单场景分析：
用户实体应该包含：
✅ 用户基本信息：姓名、性别、出生日期
✅ 联系方式：电话、邮箱、地址
✅ 账号信息：用户名、密码、注册时间
❌ 订单信息：最近订单金额、订单数量（属于订单实体）

订单实体应该包含：
✅ 订单基本信息：订单号、下单时间、总金额
✅ 订单状态：支付状态、发货状态、完成状态
✅ 关联关系：用户ID（外键）
❌ 用户信息：用户姓名、用户电话（属于用户实体）

正确的关联查询：
-- 获取用户的订单信息（通过外键关联）
SELECT u.name, u.phone, o.order_id, o.total_amount
FROM user u
JOIN orders o ON u.user_id = o.user_id
WHERE u.user_id = 12345;
```

### 7.4 数据类型选择原则


**🔸 数据类型与属性匹配**：
```
常见属性的数据类型选择：

文本类属性：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性用途     │ 推荐类型     │ 长度建议     │ 备注说明     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 姓名        │ VARCHAR     │ 50          │ 支持中英文   │
│ 用户名      │ VARCHAR     │ 30          │ 登录标识     │
│ 邮箱        │ VARCHAR     │ 100         │ 标准邮箱格式 │
│ 手机号      │ VARCHAR     │ 11          │ 固定11位     │
│ 身份证号     │ VARCHAR     │ 18          │ 固定18位     │
│ 地址        │ VARCHAR     │ 200-500     │ 详细地址     │
│ 备注        │ TEXT        │ 65535       │ 长文本内容   │
└─────────────┴─────────────┴─────────────┴─────────────┘

数值类属性：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性用途     │ 推荐类型     │ 精度考虑     │ 取值范围     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 年龄        │ TINYINT     │ 整数        │ 0-255       │
│ 身高体重     │ DECIMAL     │ 一位小数     │ 高精度      │
│ 价格金额     │ DECIMAL     │ 两位小数     │ 财务精确     │
│ 百分比      │ DECIMAL     │ 两位小数     │ 0.00-100.00 │
│ 计数统计     │ INT/BIGINT  │ 整数        │ 大数值      │
└─────────────┴─────────────┴─────────────┴─────────────┘

时间类属性：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 属性用途     │ 推荐类型     │ 精度需求     │ 应用场景     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 出生日期     │ DATE        │ 日精度      │ 年龄计算     │
│ 登录时间     │ TIMESTAMP   │ 秒精度      │ 行为分析     │
│ 创建时间     │ TIMESTAMP   │ 秒精度      │ 审计跟踪     │
│ 营业时间     │ TIME        │ 时分精度     │ 时间段      │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

---

## 8. 🏗️ 实际设计案例分析


### 8.1 学生管理系统完整设计


**需求分析**：设计一个大学的学生管理系统，需要管理学生基本信息、选课信息、成绩信息。

**🔸 学生实体设计**：
```sql
-- 学生主表设计
CREATE TABLE student (
    -- 键属性
    student_id VARCHAR(10) PRIMARY KEY,     -- 主键：学号
    id_card VARCHAR(18) UNIQUE,             -- 候选键：身份证号
    
    -- 基本描述性属性
    name VARCHAR(50) NOT NULL,              -- 姓名
    gender CHAR(1) NOT NULL CHECK (gender IN ('M','F')), -- 性别
    birth_date DATE NOT NULL,               -- 出生日期
    
    -- 联系方式（复合属性分解）
    phone VARCHAR(11),                      -- 手机号
    email VARCHAR(100) UNIQUE,              -- 邮箱
    emergency_contact VARCHAR(50),          -- 紧急联系人
    emergency_phone VARCHAR(11),            -- 紧急联系电话
    
    -- 地址信息（复合属性分解）  
    home_province VARCHAR(20),              -- 家庭地址-省份
    home_city VARCHAR(30),                  -- 家庭地址-城市
    home_address VARCHAR(200),              -- 家庭地址-详细
    
    -- 学业信息
    major_id VARCHAR(6),                    -- 专业ID（外键）
    admission_year YEAR,                    -- 入学年份
    current_grade TINYINT,                  -- 当前年级（1-4）
    
    -- 状态属性
    status VARCHAR(10) DEFAULT 'active',    -- 学籍状态
    is_graduated BOOLEAN DEFAULT FALSE,     -- 是否毕业
    
    -- 系统属性
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 外键约束
    FOREIGN KEY (major_id) REFERENCES major(major_id)
);
```

**🔸 多值属性处理**：
```sql
-- 学生特长（多值属性）
CREATE TABLE student_skill (
    student_id VARCHAR(10),
    skill_name VARCHAR(50),
    proficiency_level VARCHAR(10),  -- 初级、中级、高级、专家
    acquired_date DATE,             -- 获得时间
    certificate VARCHAR(100),       -- 相关证书
    PRIMARY KEY (student_id, skill_name),
    FOREIGN KEY (student_id) REFERENCES student(student_id)
);

-- 学生获奖记录（多值属性）
CREATE TABLE student_award (
    award_id INT AUTO_INCREMENT PRIMARY KEY,
    student_id VARCHAR(10),
    award_name VARCHAR(100),        -- 奖项名称
    award_level VARCHAR(20),        -- 奖项级别（校级、市级、省级、国家级）
    award_date DATE,               -- 获奖时间
    awarding_organization VARCHAR(100), -- 颁奖机构
    certificate_number VARCHAR(50), -- 证书编号
    FOREIGN KEY (student_id) REFERENCES student(student_id)
);

使用示例：
-- 查询某学生的所有技能
SELECT skill_name, proficiency_level 
FROM student_skill 
WHERE student_id = '2021001001';

-- 统计各专业学生的获奖情况
SELECT m.major_name, COUNT(sa.award_id) as award_count
FROM major m
JOIN student s ON m.major_id = s.major_id
LEFT JOIN student_award sa ON s.student_id = sa.student_id
GROUP BY m.major_id, m.major_name;
```

### 8.2 电商平台商品管理设计


**🔸 商品实体复杂属性分析**：
```sql
-- 商品主表（核心属性）
CREATE TABLE product (
    -- 键属性
    product_id INT AUTO_INCREMENT PRIMARY KEY,  -- 主键：商品ID
    sku_code VARCHAR(50) UNIQUE NOT NULL,       -- 候选键：SKU编码
    barcode VARCHAR(20) UNIQUE,                 -- 候选键：条形码
    
    -- 基本描述性属性
    product_name VARCHAR(200) NOT NULL,         -- 商品名称
    brand_id INT,                              -- 品牌ID（外键）
    category_id INT,                           -- 分类ID（外键）
    
    -- 商品规格（复合属性考虑）
    weight DECIMAL(8,3),                       -- 重量（kg）
    dimensions VARCHAR(50),                    -- 尺寸（长×宽×高）
    color VARCHAR(30),                         -- 颜色
    size VARCHAR(10),                          -- 尺码
    
    -- 价格信息
    cost_price DECIMAL(10,2),                  -- 成本价
    selling_price DECIMAL(10,2) NOT NULL,     -- 销售价
    market_price DECIMAL(10,2),               -- 市场价
    
    -- 库存信息
    stock_quantity INT DEFAULT 0,             -- 库存数量
    safety_stock INT DEFAULT 0,               -- 安全库存
    
    -- 状态属性
    status VARCHAR(20) DEFAULT 'active',       -- 商品状态
    is_featured BOOLEAN DEFAULT FALSE,         -- 是否推荐
    
    -- 时间属性
    launch_date DATE,                          -- 上架时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 外键约束
    FOREIGN KEY (brand_id) REFERENCES brand(brand_id),
    FOREIGN KEY (category_id) REFERENCES category(category_id)
);
```

**🔸 商品多值属性处理**：
```sql
-- 商品图片（多值属性）
CREATE TABLE product_image (
    image_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT,
    image_url VARCHAR(500) NOT NULL,           -- 图片URL
    image_type VARCHAR(20) DEFAULT 'normal',   -- 图片类型：主图、详情图、规格图
    sort_order INT DEFAULT 0,                  -- 显示顺序
    alt_text VARCHAR(200),                     -- 图片描述
    upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES product(product_id)
);

-- 商品标签（多值属性）
CREATE TABLE product_tag (
    product_id INT,
    tag_name VARCHAR(30),
    tag_type VARCHAR(20) DEFAULT 'feature',    -- 标签类型：特色、促销、分类
    PRIMARY KEY (product_id, tag_name),
    FOREIGN KEY (product_id) REFERENCES product(product_id)
);

-- 商品规格（复杂多值属性）
CREATE TABLE product_spec (
    spec_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT,
    spec_name VARCHAR(50),                     -- 规格名称：颜色、尺寸、内存
    spec_value VARCHAR(100),                   -- 规格值：红色、XL、64GB
    price_adjustment DECIMAL(10,2) DEFAULT 0, -- 价格调整
    stock_adjustment INT DEFAULT 0,           -- 库存调整
    FOREIGN KEY (product_id) REFERENCES product(product_id)
);
```

### 8.3 银行账户系统设计案例


**复杂业务场景的属性分类**：
```sql
-- 银行账户实体设计
CREATE TABLE bank_account (
    -- 键属性设计
    account_id BIGINT AUTO_INCREMENT PRIMARY KEY,  -- 主键：系统账户ID
    account_number VARCHAR(20) UNIQUE NOT NULL,    -- 候选键：银行账号
    card_number VARCHAR(19) UNIQUE,                -- 候选键：银行卡号
    
    -- 账户所有者信息（外键）
    customer_id BIGINT NOT NULL,                   -- 客户ID
    
    -- 账户基本属性
    account_type VARCHAR(20) NOT NULL,             -- 账户类型：储蓄、支票、定期
    currency_code CHAR(3) DEFAULT 'CNY',          -- 货币代码
    
    -- 财务属性（存储属性）
    balance DECIMAL(15,2) DEFAULT 0.00,           -- 当前余额
    frozen_amount DECIMAL(15,2) DEFAULT 0.00,     -- 冻结金额
    credit_limit DECIMAL(15,2) DEFAULT 0.00,      -- 信用额度
    
    -- 状态属性
    status VARCHAR(10) DEFAULT 'active',           -- 账户状态
    is_dormant BOOLEAN DEFAULT FALSE,              -- 是否休眠
    last_transaction_date DATE,                    -- 最后交易日期
    
    -- 开户信息
    open_date DATE NOT NULL,                       -- 开户日期
    branch_code VARCHAR(10),                       -- 开户网点
    
    -- 系统属性
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (customer_id) REFERENCES customer(customer_id)
);

-- 派生属性的计算示例
CREATE VIEW account_summary AS
SELECT 
    account_id,
    account_number,
    balance,
    frozen_amount,
    -- 派生属性：可用余额
    (balance - frozen_amount) AS available_balance,
    
    -- 派生属性：账户年龄（天数）
    DATEDIFF(CURDATE(), open_date) AS account_age_days,
    
    -- 派生属性：是否长期未使用
    CASE 
        WHEN DATEDIFF(CURDATE(), last_transaction_date) > 365 THEN TRUE
        ELSE FALSE 
    END AS is_long_inactive,
    
    -- 派生属性：风险等级
    CASE
        WHEN balance > 1000000 THEN '高'
        WHEN balance > 100000 THEN '中'
        ELSE '低'
    END AS risk_level
FROM bank_account;
```

### 8.4 社交媒体用户系统设计


**🔸 用户实体的复杂属性处理**：
```sql
-- 用户主表
CREATE TABLE user (
    -- 键属性
    user_id BIGINT AUTO_INCREMENT PRIMARY KEY,     -- 主键：用户ID
    username VARCHAR(50) UNIQUE NOT NULL,          -- 候选键：用户名
    email VARCHAR(100) UNIQUE NOT NULL,            -- 候选键：邮箱
    phone VARCHAR(15) UNIQUE,                      -- 候选键：手机号
    
    -- 基本信息
    display_name VARCHAR(100),                     -- 显示名称
    real_name VARCHAR(50),                         -- 真实姓名
    gender VARCHAR(10),                            -- 性别
    birth_date DATE,                               -- 出生日期
    
    -- 个人资料
    avatar_url VARCHAR(500),                       -- 头像URL
    cover_photo_url VARCHAR(500),                  -- 封面图片URL
    bio TEXT,                                      -- 个人简介
    location VARCHAR(100),                         -- 所在地
    website VARCHAR(200),                          -- 个人网站
    
    -- 账户设置
    is_private BOOLEAN DEFAULT FALSE,              -- 是否私密账户
    allow_message BOOLEAN DEFAULT TRUE,            -- 允许私信
    allow_tag BOOLEAN DEFAULT TRUE,                -- 允许标记
    
    -- 状态信息
    is_verified BOOLEAN DEFAULT FALSE,             -- 是否认证
    is_active BOOLEAN DEFAULT TRUE,                -- 是否活跃
    last_seen_at TIMESTAMP,                       -- 最后在线时间
    
    -- 系统信息
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 用户兴趣标签（多值属性）
CREATE TABLE user_interest (
    user_id BIGINT,
    interest VARCHAR(50),
    interest_level TINYINT DEFAULT 5,              -- 兴趣程度1-10
    added_date DATE DEFAULT (CURDATE()),
    PRIMARY KEY (user_id, interest),
    FOREIGN KEY (user_id) REFERENCES user(user_id)
);

-- 用户社交账号（多值属性）
CREATE TABLE user_social_account (
    user_id BIGINT,
    platform VARCHAR(30),                         -- 平台名称：微博、微信、QQ
    platform_user_id VARCHAR(100),               -- 平台用户ID
    platform_username VARCHAR(100),              -- 平台用户名
    is_verified BOOLEAN DEFAULT FALSE,            -- 是否已验证
    linked_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, platform),
    FOREIGN KEY (user_id) REFERENCES user(user_id)
);
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 属性分类体系：简单vs复合、单值vs多值、存储vs派生、键vs描述性
🔸 键属性识别：主键、候选键、外键的识别和选择原则
🔸 复合属性处理：何时分解、如何分解、分解到什么程度
🔸 多值属性实现：独立表法、JSON存储法的选择和应用
🔸 派生属性策略：计算方式、是否存储、缓存策略
🔸 设计基础原则：原子性、最小化、业务相关性、数据类型匹配
```

### 9.2 关键理解要点


**属性分类的实际意义**：
```
为什么要进行属性分类？

设计指导作用：
• 简单属性 → 直接映射为数据库字段
• 复合属性 → 考虑分解为多个字段
• 单值属性 → 普通字段设计
• 多值属性 → 需要额外的关联表
• 存储属性 → 创建实际的数据库字段
• 派生属性 → 通过计算获得，一般不存储

查询优化指导：
• 键属性 → 建立主键索引和唯一索引
• 常用查询属性 → 建立普通索引
• 多值属性 → 为关联表建立索引
• 派生属性 → 考虑创建计算列或视图
```

**键属性识别的核心技巧**：
```
识别步骤：
1. 找出所有可能唯一的属性
2. 评估稳定性和实用性
3. 选择最适合的作为主键
4. 其他候选键设置唯一约束

选择原则：
• 人工键优于自然键（student_id优于id_card）
• 短键优于长键（便于引用和索引）
• 稳定键优于变化键（避免级联更新）
• 无意义键优于有意义键（避免业务逻辑干扰）

常见错误：
❌ 选择可能变化的属性作为主键
❌ 使用过长的复合键
❌ 忽略设置候选键的唯一约束
❌ 在外键引用中使用描述性属性
```

**复合属性设计的平衡点**：
```
分解的好处：
• 便于查询：可以基于组成部分查询
• 数据校验：可以分别验证各个部分
• 灵活性：可以单独修改某个组成部分
• 统计分析：便于按组成部分进行统计

不分解的好处：
• 简单性：设计和使用都更简单
• 完整性：保持信息的完整性
• 性能：避免多表连接的开销
• 兼容性：便于与外部系统交互

决策原则：
业务需求决定设计复杂度
查询模式决定分解程度
数据来源决定设计方案
系统性能决定实现方式
```

### 9.3 实际应用指导


**属性设计检查清单**：
```
设计完成后的自检项目：

✅ 唯一性检查：
• 每个实体都有明确的主键
• 候选键都设置了唯一约束
• 复合键的组合确实唯一

✅ 完整性检查：
• 必需属性设置了NOT NULL约束
• 外键设置了正确的引用关系
• 枚举值设置了CHECK约束

✅ 冗余性检查：
• 没有存储可以计算得出的属性
• 没有跨实体的属性冗余
• 多值属性采用了规范化设计

✅ 可用性检查：
• 数据类型选择合理
• 字段长度设置适当
• 索引设计支持查询需求

✅ 扩展性检查：
• 设计支持业务发展需要
• 新增属性不会破坏现有结构
• 性能瓶颈有优化空间
```

### 9.4 常见设计错误与解决方案


**错误1：属性分类不清**
```
❌ 错误示例：
CREATE TABLE student (
    id INT PRIMARY KEY,
    full_info VARCHAR(500)  -- 将所有信息放在一个字段中
);

✅ 正确做法：
• 分析full_info包含哪些具体信息
• 根据业务需求决定分解粒度
• 每个属性都有明确的业务含义

CREATE TABLE student (
    student_id VARCHAR(10) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    gender CHAR(1),
    birth_date DATE,
    phone VARCHAR(11),
    address VARCHAR(200)
);
```

**错误2：多值属性处理不当**
```
❌ 错误示例：
CREATE TABLE student (
    student_id VARCHAR(10) PRIMARY KEY,
    hobby1 VARCHAR(50),  -- 固定数量的多值属性
    hobby2 VARCHAR(50),
    hobby3 VARCHAR(50)
);

✅ 正确做法：
CREATE TABLE student_hobby (
    student_id VARCHAR(10),
    hobby VARCHAR(50),
    skill_level VARCHAR(10),
    PRIMARY KEY (student_id, hobby),
    FOREIGN KEY (student_id) REFERENCES student(student_id)
);
```

**错误3：派生属性存储不当**
```
❌ 错误示例：
CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    birth_date DATE,
    age INT,  -- 冗余：可以从birth_date计算
    hire_date DATE,
    work_years INT  -- 冗余：可以从hire_date计算
);

✅ 正确做法：
CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    birth_date DATE,
    hire_date DATE
    -- age和work_years通过计算获得
);

-- 需要时通过视图提供派生属性
CREATE VIEW employee_info AS
SELECT 
    emp_id,
    birth_date,
    hire_date,
    TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) AS age,
    TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) AS work_years
FROM employee;
```

### 9.5 设计最佳实践总结


**实践指导原则**：
```
属性设计的黄金法则：

1. 先分类，后设计
   • 明确每个属性的类型和特点
   • 根据分类选择合适的实现方案

2. 键属性优先
   • 首先确定主键和候选键
   • 键属性的设计质量决定整个表的质量

3. 业务驱动设计
   • 属性设计必须服务于业务需求
   • 不要为了技术而技术

4. 性能与规范平衡
   • 在数据规范化和查询性能间找平衡
   • 根据实际使用场景做调整

5. 预留扩展空间
   • 考虑未来可能的业务变化
   • 设计要有一定的前瞻性
```

**学习建议**：
```
掌握顺序：
第1步：理解各种属性分类的含义和特点
第2步：学会识别现实业务中的各种属性类型
第3步：掌握每种属性类型的数据库实现方法
第4步：能够综合运用进行复杂系统设计
第5步：具备性能优化和设计改进能力

练习方法：
• 分析现有系统的数据库设计
• 尝试重新设计熟悉的业务系统
• 对比不同设计方案的优缺点
• 关注业界主流产品的设计模式
```

**核心记忆口诀**：
- 属性分类要清晰，键属性识别是核心
- 简单复合看需求，单值多值巧处理  
- 存储派生要权衡，描述性质要准确
- 业务驱动做设计，性能规范两平衡