---
title: 13、实体完整性约束基础
---
## 📚 目录

1. [实体完整性基本概念](#1-实体完整性基本概念)
2. [键概念体系理解](#2-键概念体系理解)
3. [实体完整性规则详解](#3-实体完整性规则详解)
4. [主键非空唯一性原理](#4-主键非空唯一性原理)
5. [候选键概念与识别](#5-候选键概念与识别)
6. [超键与最小超键理解](#6-超键与最小超键理解)
7. [完整性约束应用实践](#7-完整性约束应用实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛡️ 实体完整性基本概念


### 1.1 什么是实体完整性


**🔸 生活中的类比理解**
想象你在管理一个图书馆，每本书都必须有一个**唯一的编号**来识别它。如果两本书编号相同，或者某本书没有编号，就会造成混乱。**实体完整性**就是确保数据库中每条记录都有这样一个"身份证号"。

**🔸 专业定义**
```
实体完整性（Entity Integrity）：
数据库表中的每一行记录都必须有唯一标识，且这个标识不能为空
目的：确保表中每条记录都可以被准确定位和区分
实现：通过主键约束来保证
```

### 1.2 为什么需要实体完整性


**🔸 数据唯一性问题**
```
没有实体完整性的问题示例：

学生表（错误设计）：
┌────────┬────────┬──────┬─────────┐
│ 学号   │ 姓名   │ 年龄 │ 专业    │
├────────┼────────┼──────┼─────────┤
│ 20001  │ 张三   │  20  │ 计算机  │
│ 20001  │ 李四   │  21  │ 数学    │  ← 学号重复！
│        │ 王五   │  19  │ 物理    │  ← 学号为空！
│ 20003  │ 赵六   │  22  │ 化学    │
└────────┴────────┴──────┴─────────┘

问题分析：
❌ 无法确定20001到底是张三还是李四
❌ 无法引用王五这条记录（没有唯一标识）
❌ 数据查询和更新会产生歧义
```

**🔸 数据引用问题**
```
外键引用的困境：

选课表想引用学生：
┌────────┬────────┬────────┐
│ 课程号 │ 学号   │ 成绩   │
├────────┼────────┼────────┤
│ CS101  │ 20001  │   85   │  ← 这个20001是张三还是李四？
└────────┴────────┴────────┘

没有实体完整性，外键引用就失去了意义！
```

### 1.3 实体完整性的作用


**保证数据的基本质量**：
- **唯一标识**：每条记录都有独一无二的"身份证"
- **完整引用**：其他表可以准确引用这条记录
- **数据一致性**：避免重复和冲突数据
- **操作可靠性**：增删改查操作都有明确目标

---

## 2. 🔑 键概念体系理解


### 2.1 键的概念层次结构


**🔸 键概念家族关系图**
```
键概念体系结构：

                    属性集合
                        |
                   ┌────┴────┐
                   |         |
              能唯一标识    不能唯一标识
                   |         |
                超键集合   普通属性组合
                   |
              ┌────┴────┐
              |         |
          最小超键   非最小超键
              |         |
            候选键    复合超键
              |
          ┌───┴───┐
          |       |
        主键   备选键

关系说明：
主键 ⊆ 候选键 ⊆ 超键 ⊆ 所有属性组合
```

### 2.2 属性与属性组合


**🔸 基础概念**
```
属性（Attribute）：表的列，如姓名、学号、年龄
属性组合：多个属性的集合，如{学号,姓名}、{身份证号}

学生表示例：
属性集合 = {学号, 姓名, 身份证号, 年龄, 专业}

可能的属性组合：
单属性：{学号}、{姓名}、{身份证号}...
双属性：{学号,姓名}、{学号,年龄}...
三属性：{学号,姓名,年龄}...
全属性：{学号,姓名,身份证号,年龄,专业}
```

### 2.3 键的判断标准


**🔸 唯一性判断**
```
唯一性测试方法：

给定属性组合K，检查在表的所有可能数据中：
- 是否存在两条记录在K上的值完全相同？
- 如果不存在 → K具有唯一性
- 如果存在 → K不具有唯一性

示例测试：
学生表数据：
┌────────┬────────┬─────────────┬──────┬─────────┐
│ 学号   │ 姓名   │ 身份证号    │ 年龄 │ 专业    │
├────────┼────────┼─────────────┼──────┼─────────┤
│ 20001  │ 张三   │ 110101...   │  20  │ 计算机  │
│ 20002  │ 李四   │ 110102...   │  20  │ 计算机  │
│ 20003  │ 王五   │ 110103...   │  21  │ 数学    │
└────────┴────────┴─────────────┴──────┴─────────┘

测试结果：
{学号}: ✅ 唯一 (20001, 20002, 20003都不同)
{姓名}: ✅ 唯一 (张三, 李四, 王五都不同) 
{年龄}: ❌ 不唯一 (张三和李四都是20岁)
{专业}: ❌ 不唯一 (张三和李四都是计算机专业)
```

---

## 3. 🔍 实体完整性规则详解


### 3.1 实体完整性的核心规则


**🔥 实体完整性规则（Entity Integrity Rule）**

> 📋 **规则定义**：关系数据库中的每个基本关系（表）都必须有一个主键，且主键的任何属性都不能为空值（NULL）

**🔸 规则的两个核心要求**

**要求1：必须有主键**
```
每个表都必须指定主键：

正确示例：
CREATE TABLE students (
    student_id INT PRIMARY KEY,    -- ✅ 明确指定主键
    name VARCHAR(50),
    age INT
);

错误示例：
CREATE TABLE students (
    student_id INT,                -- ❌ 没有指定主键
    name VARCHAR(50),
    age INT
);
```

**要求2：主键不能为NULL**
```
主键值的约束：

允许的主键值：
✅ student_id = 20001     (有效数值)
✅ student_id = 'S20001'  (有效字符串)  
✅ student_id = 0         (0也是有效值)

禁止的主键值：
❌ student_id = NULL      (空值)
❌ student_id = ''        (空字符串，某些数据库视为NULL)
```

### 3.2 实体完整性的实现机制


**🔧 数据库层面的约束**

**自动检查机制**：
```
数据库管理系统的自动保护：

插入记录时：
INSERT INTO students VALUES (NULL, '张三', 20);
数据库响应：❌ ERROR: Primary key cannot be NULL

插入重复记录时：
INSERT INTO students VALUES (20001, '李四', 21);  -- 假设20001已存在
数据库响应：❌ ERROR: Duplicate entry '20001' for key 'PRIMARY'

更新主键为NULL时：
UPDATE students SET student_id = NULL WHERE name = '张三';
数据库响应：❌ ERROR: Primary key cannot be NULL
```

### 3.3 违反实体完整性的后果


**🚨 数据问题示例**

**后果1：数据无法唯一定位**
```
问题场景：
┌────────┬────────┬──────┐
│ 学号   │ 姓名   │ 年龄 │
├────────┼────────┼──────┤
│ 20001  │ 张三   │  20  │
│ 20001  │ 李四   │  21  │  ← 主键重复
└────────┴────────┴──────┘

查询问题：
SELECT * FROM students WHERE student_id = 20001;
结果：返回两条记录，无法确定具体要哪一条
```

**后果2：外键引用失效**
```
选课表引用问题：
┌────────┬────────┬────────┐
│ 课程号 │ 学号   │ 成绩   │
├────────┼────────┼────────┤
│ CS101  │ 20001  │   85   │  ← 这个学号对应哪个学生？
└────────┴────────┴────────┘

无法确定成绩85分是张三的还是李四的！
```

---

## 4. 🔐 主键非空唯一性原理


### 4.1 主键的本质理解


**🔸 主键就是"身份证号"**

生活中的身份证号特点：
- **全国唯一**：不会有两个人的身份证号相同
- **必须存在**：每个人都必须有身份证号
- **不可更改**：身份证号一般不轻易更改

数据库中的主键特点：
- **表内唯一**：同一个表中主键值不能重复
- **不能为空**：每条记录都必须有主键值
- **相对稳定**：主键值不应该频繁更改

### 4.2 非空性（NOT NULL）详解


**🔸 为什么主键不能为空**

**逻辑原因**：
```
NULL的含义："未知" 或 "不存在"

如果主键为NULL：
- 表示这条记录的标识是"未知的"
- 那如何引用这条记录？
- 如何确保记录的唯一性？

结论：NULL作为主键没有任何意义
```

**🔸 NULL与空字符串的区别**
```sql
-- NULL：表示未知或不存在
INSERT INTO students VALUES (NULL, '张三', 20);     -- ❌ 违反主键约束

-- 空字符串：是一个确定的值
INSERT INTO students VALUES ('', '张三', 20);       -- ⚠️ 取决于数据库设置

-- 数字0：是一个有效的主键值  
INSERT INTO students VALUES (0, '张三', 20);        -- ✅ 有效主键
```

### 4.3 唯一性（UNIQUE）详解


**🔸 唯一性的严格要求**

**数学角度理解**：
```
设表T中有n条记录：r₁, r₂, ..., rₙ
主键属性为K

唯一性要求：
对于任意 i ≠ j，都有 rᵢ.K ≠ rⱼ.K

换句话说：
- 任意两条记录的主键值都不相同
- 主键值在表中是"一对一"的关系
```

**🔸 复合主键的唯一性**
```sql
-- 复合主键示例：选课表
CREATE TABLE enrollments (
    student_id INT,
    course_id INT, 
    semester VARCHAR(20),
    grade INT,
    PRIMARY KEY (student_id, course_id, semester)  -- 三个字段组合为主键
);

唯一性规则：
(student_id, course_id, semester) 的组合必须唯一

允许的情况：
✅ (20001, 'CS101', '2024春') 
✅ (20001, 'CS102', '2024春')  -- 不同课程
✅ (20001, 'CS101', '2024秋')  -- 不同学期
✅ (20002, 'CS101', '2024春')  -- 不同学生

禁止的情况：
❌ (20001, 'CS101', '2024春')  -- 与第一条完全相同
```

---

## 5. 🎯 候选键概念与识别


### 5.1 候选键的定义与理解


**🔸 候选键（Candidate Key）的通俗解释**

**生活类比**：
在班级里识别一个学生，你可以用：
- **学号**：每个学生都有唯一学号
- **身份证号**：每个学生的身份证号也唯一
- **手机号**：假设每个学生手机号也不同

这些都可以**候选**为这个学生的"标识符"，所以叫**候选键**。

**🔸 候选键的正式定义**
```
候选键：能够唯一标识表中每条记录的最小属性组合

关键要求：
1. 唯一性：候选键值在表中必须唯一
2. 最小性：去掉候选键中任何一个属性，就不能保证唯一性
3. 非空性：候选键的所有属性都不能为空
```

### 5.2 候选键识别方法


**🔧 系统化识别步骤**

**步骤1：列出所有可能的属性组合**
```
学生表属性：{学号, 姓名, 身份证号, 手机号, 邮箱}

单属性组合：
{学号}、{姓名}、{身份证号}、{手机号}、{邮箱}

双属性组合：
{学号,姓名}、{学号,身份证号}、{姓名,身份证号}...

三属性组合：
{学号,姓名,身份证号}...
...
```

**步骤2：唯一性测试**
```
测试数据：
┌────────┬────────┬─────────────┬─────────────┬──────────────────┐
│ 学号   │ 姓名   │ 身份证号    │ 手机号      │ 邮箱             │
├────────┼────────┼─────────────┼─────────────┼──────────────────┤
│ 20001  │ 张三   │ 110101...   │ 138xxxx1111 │ zhang@email.com  │
│ 20002  │ 李四   │ 110102...   │ 139xxxx2222 │ li@email.com     │
│ 20003  │ 张三   │ 110103...   │ 137xxxx3333 │ zhang2@email.com │
└────────┴────────┴─────────────┴─────────────┴──────────────────┘

唯一性测试结果：
{学号}: ✅ 唯一 (20001, 20002, 20003 都不同)
{姓名}: ❌ 不唯一 (有两个张三)
{身份证号}: ✅ 唯一 (每个人身份证号不同)
{手机号}: ✅ 唯一 (每个人手机号不同)  
{邮箱}: ✅ 唯一 (每个人邮箱不同)
```

**步骤3：最小性测试**
```
候选键候选者：{学号}、{身份证号}、{手机号}、{邮箱}

最小性测试：
{学号}: ✅ 最小 (单个属性，无法再减少)
{身份证号}: ✅ 最小 (单个属性，无法再减少)
{手机号}: ✅ 最小 (单个属性，无法再减少)
{邮箱}: ✅ 最小 (单个属性，无法再减少)

结论：这4个都是候选键
```

### 5.3 候选键的选择原则


**🎯 主键选择标准**

在多个候选键中选择主键的考虑因素：

```
选择优先级排序：

1️⃣ 稳定性：不易变化的属性优先
   学号 > 手机号 (手机号可能更换)

2️⃣ 简洁性：简单属性优先
   学号 > 身份证号 (学号更短更简洁)

3️⃣ 性能：便于索引和查询的属性优先
   整数 > 字符串 (整数比较和索引更快)

4️⃣ 业务意义：有明确业务含义的属性优先
   学号 > 系统生成ID (学号有业务含义)
```

**实际选择示例**：
```sql
-- 推荐：选择学号作为主键
CREATE TABLE students (
    student_id VARCHAR(10) PRIMARY KEY,  -- 稳定、简洁、有意义
    name VARCHAR(50),
    id_card VARCHAR(18) UNIQUE,          -- 其他候选键设为唯一约束
    phone VARCHAR(15) UNIQUE,
    email VARCHAR(100) UNIQUE
);
```

---

## 6. 🔧 超键与最小超键理解


### 6.1 超键的基本概念


**🔸 超键（Super Key）的通俗理解**

**生活类比**：
如果说候选键是"精简身份证"，那么超键就是"详细身份信息包"。比如：
- **候选键**：只要身份证号就能识别一个人
- **超键**：身份证号+姓名+出生日期+家庭住址...（信息过多但仍能识别）

**🔸 超键的正式定义**
```
超键：能够唯一标识表中每条记录的属性组合

特点：
1. 唯一性：超键值在表中必须唯一
2. 可冗余：超键可以包含多余的属性
3. 包含关系：候选键一定是超键，但超键不一定是候选键
```

### 6.2 超键识别实例


**🔧 实际识别过程**

```
学生表：{学号, 姓名, 身份证号, 年龄, 专业}

超键识别：
{学号} ────────────── ✅ 超键 (也是候选键)
{身份证号} ──────────── ✅ 超键 (也是候选键)  
{学号, 姓名} ─────────── ✅ 超键 (包含候选键{学号})
{学号, 年龄} ─────────── ✅ 超键 (包含候选键{学号})
{身份证号, 专业} ────── ✅ 超键 (包含候选键{身份证号})
{学号, 姓名, 年龄} ──── ✅ 超键 (包含候选键{学号})
{姓名, 年龄} ─────────── ❌ 不是超键 (可能重复)
{年龄, 专业} ─────────── ❌ 不是超键 (可能重复)

规律总结：
- 包含候选键的任何属性组合都是超键
- 不包含任何候选键的组合不是超键
```

### 6.3 最小超键识别方法


**🔸 最小超键就是候选键**

**概念关系**：
```
最小超键 = 候选键

定义：不能再减少属性的超键

判断方法：
给定超键S，如果去掉S中任何一个属性后：
- 仍然是超键 → S不是最小超键
- 不再是超键 → S是最小超键
```

**🔧 最小性测试算法**

```
测试超键{学号, 姓名}是否最小：

步骤1：测试{学号}
- 去掉姓名属性，只剩{学号}
- {学号}能唯一标识吗？ ✅ 能
- 结论：{学号, 姓名}不是最小超键

步骤2：测试{姓名}  
- 去掉学号属性，只剩{姓名}
- {姓名}能唯一标识吗？ ❌ 不能（可能重名）
- 结论：姓名不能单独标识

最终结论：{学号, 姓名}不是最小超键，因为{学号}已经足够
```

**🔧 复合候选键的最小性测试**

```
订单明细表：{订单号, 商品号, 数量, 单价}

假设候选键是{订单号, 商品号}：

最小性测试：
- 去掉订单号，只剩{商品号} → ❌ 不唯一（一个商品可能在多个订单中）
- 去掉商品号，只剩{订单号} → ❌ 不唯一（一个订单可能有多个商品）

结论：{订单号, 商品号}是最小超键（候选键）
```

### 6.4 超键的实际意义


**🎯 为什么要理解超键概念**

**数据库设计指导**：
- **冗余检测**：发现设计中的冗余字段
- **性能优化**：避免在非必要字段上建立复杂索引
- **规范化指导**：为数据库规范化提供理论基础

**示例分析**：
```
如果把{学号, 姓名, 身份证号}设为主键：

问题分析：
❌ 冗余：{学号}已经足够唯一标识
❌ 浪费：占用更多索引空间
❌ 复杂：联合主键查询更复杂
❌ 维护：更新任何一个字段都影响主键

正确做法：选择{学号}作为主键，其他设为唯一约束
```

---

## 7. 💻 完整性约束应用实践


### 7.1 数据库设计实例


**🔧 学生管理系统设计**

**实体分析**：
```
学生实体属性：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│    属性     │   唯一性    │   稳定性    │  主键适合度  │
├─────────────┼─────────────┼─────────────┼─────────────┤
│    学号     │     ✅      │     ✅      │    ⭐⭐⭐    │
│    姓名     │     ❌      │     ❌      │    ⭐       │
│  身份证号   │     ✅      │     ✅      │    ⭐⭐     │
│   手机号    │     ✅      │     ❌      │    ⭐       │
│    邮箱     │     ✅      │     ❌      │    ⭐       │
│    年龄     │     ❌      │     ❌      │    ❌       │
│    专业     │     ❌      │     ❌      │    ❌       │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

**设计结果**：
```sql
CREATE TABLE students (
    student_id VARCHAR(10) PRIMARY KEY,          -- 主键：学号
    name VARCHAR(50) NOT NULL,                   -- 姓名（非候选键，但不能为空）
    id_card VARCHAR(18) UNIQUE NOT NULL,         -- 候选键，设为唯一约束
    phone VARCHAR(15) UNIQUE,                    -- 候选键，允许为空（学生可能没手机）
    email VARCHAR(100) UNIQUE,                   -- 候选键，允许为空
    age INT CHECK (age >= 16 AND age <= 60),     -- 其他约束
    major VARCHAR(50) NOT NULL
);
```

### 7.2 多表关联的完整性约束


**🔗 外键约束设计**

**选课表设计**：
```sql
-- 选课表：体现学生和课程的多对多关系
CREATE TABLE enrollments (
    -- 复合主键：保证一个学生在同一学期不能重复选同一门课
    student_id VARCHAR(10),
    course_id VARCHAR(10), 
    semester VARCHAR(20),
    enrollment_date DATE NOT NULL,
    grade DECIMAL(4,2),
    
    -- 主键约束
    PRIMARY KEY (student_id, course_id, semester),
    
    -- 外键约束：确保引用的学生和课程确实存在
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

**🔸 完整性约束作用链**：
```
完整性约束保护链：

学生表的实体完整性
        ↓
保证每个学生都有唯一学号
        ↓  
选课表的外键约束才有意义
        ↓
保证选课记录引用的是真实存在的学生
        ↓
整个系统的数据一致性得到保障
```

### 7.3 约束违反的处理策略


**🚨 约束冲突处理**

**插入冲突处理**：
```sql
-- 策略1：忽略冲突（MySQL特有）
INSERT IGNORE INTO students VALUES ('20001', '张三', ...);
-- 如果20001已存在，这条语句不会报错，但也不会插入

-- 策略2：更新冲突（MySQL特有）
INSERT INTO students VALUES ('20001', '张三', ...) 
ON DUPLICATE KEY UPDATE name = VALUES(name);
-- 如果20001已存在，就更新现有记录的姓名

-- 策略3：替换记录
REPLACE INTO students VALUES ('20001', '张三', ...);
-- 如果20001已存在，删除旧记录，插入新记录
```

**应用程序层面处理**：
```java
// Java代码示例：优雅处理主键冲突
public boolean addStudent(Student student) {
    try {
        studentDAO.insert(student);
        return true;
    } catch (DuplicateKeyException e) {
        // 主键冲突处理
        logger.warn("学号已存在: " + student.getStudentId());
        return false;
    } catch (DataIntegrityViolationException e) {
        // 其他完整性约束冲突
        logger.error("数据完整性约束违反: " + e.getMessage());
        return false;
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 实体完整性：每条记录必须有唯一非空标识
🔸 主键约束：非空 + 唯一，确保记录可唯一定位
🔸 候选键概念：所有可能作为主键的属性组合
🔸 超键理解：包含候选键的任意属性组合
🔸 最小超键：就是候选键，不能再减少属性
🔸 约束体系：实体完整性是数据质量的基础保障
```

### 8.2 关键理解要点


**🔹 键概念的层次关系**
```
记忆方法：
主键 ∈ 候选键 ∈ 超键 ∈ 所有属性组合

具体理解：
- 主键：从候选键中选出的"老大"
- 候选键：有资格当主键的"候选人"  
- 超键：包含候选人的"团队"
- 普通属性：没有唯一标识能力的"普通成员"
```

**🔹 完整性约束的重要性**
```
数据质量金字塔：

           高级业务逻辑约束
          ┌─────────────────┐
         │   业务规则约束    │
        ┌┴─────────────────┴┐
       │   参照完整性约束    │
      ┌┴─────────────────────┴┐
     │    实体完整性约束      │  ← 最基础的数据质量保证
    ┌┴───────────────────────┴┐
   │      域完整性约束        │
  └─────────────────────────────┘

没有实体完整性，上层约束都失去意义！
```

**🔹 设计实践指导原则**
```
主键设计原则：
1. 唯一性：绝对不能重复
2. 稳定性：一旦分配尽量不改变
3. 简洁性：越简单越好
4. 有意义：最好有业务含义  
5. 高效性：便于索引和查询

候选键管理：
- 主键：选择最优的候选键
- 唯一约束：其他候选键设为UNIQUE
- 业务规则：结合实际业务需求
```

### 8.3 实际应用价值


**🎯 数据库设计价值**
- **数据质量**：确保基础数据的准确性和一致性
- **系统稳定**：避免因数据问题导致的系统错误  
- **性能优化**：合理的主键设计提升查询效率
- **维护简化**：清晰的约束规则降低维护难度

**🔧 开发实践价值**
- **错误预防**：在数据库层面阻止错误数据
- **代码简化**：减少应用层的数据验证逻辑
- **调试支持**：约束违反提供明确的错误信息
- **团队协作**：统一的数据完整性标准

> 💡 **关键理解**：实体完整性不是技术细节，而是数据管理的根本原则

**核心记忆口诀**：
- 实体完整性是基础，主键唯一不为空
- 候选键里选主键，超键包含候选键
- 最小超键即候选，约束保证数据强