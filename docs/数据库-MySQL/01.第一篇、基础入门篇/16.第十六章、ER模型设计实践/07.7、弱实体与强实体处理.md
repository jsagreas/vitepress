---
title: 7、弱实体与强实体处理
---
## 📚 目录

1. [弱实体基本概念](#1-弱实体基本概念)
2. [弱实体识别与设计](#2-弱实体识别与设计)
3. [依赖关系处理策略](#3-依赖关系处理策略)
4. [弱实体转换规则](#4-弱实体转换规则)
5. [完整性约束与级联操作](#5-完整性约束与级联操作)
6. [弱实体性能优化](#6-弱实体性能优化)
7. [实际应用案例](#7-实际应用案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 弱实体基本概念


### 1.1 什么是弱实体


**🔸 强实体vs弱实体的本质区别**

> 💡 **通俗理解**
> 
> 把实体想象成现实中的事物：
> - **强实体**就像一个人，有身份证号可以独立标识
> - **弱实体**就像一个人的手机号记录，必须依靠"这个人"才有意义

**核心定义对比**：

```
强实体 (Strong Entity)
┌─────────────────────────────────┐
│ • 自己有唯一标识符(主键)          │
│ • 可以独立存在                   │
│ • 不依赖其他实体                 │
│ • 例子: 学生、部门、商品          │
└─────────────────────────────────┘

弱实体 (Weak Entity)  
┌─────────────────────────────────┐
│ • 没有完整的唯一标识符            │
│ • 必须依赖强实体才能存在          │
│ • 需要借助强实体的主键来标识      │
│ • 例子: 订单明细、家属信息        │
└─────────────────────────────────┘
```

### 1.2 弱实体的识别标准


**📋 弱实体识别清单**：

- [x] **缺乏独立主键** - 没有能唯一标识自己的属性
- [x] **存在依赖性** - 必须依赖另一个实体才有意义  
- [x] **级联删除** - 被依赖实体删除时，弱实体也应被删除
- [x] **部分键依赖** - 需要组合被依赖实体的主键才能唯一标识

**🔍 实际判断示例**：

```
案例分析: 订单与订单明细

订单 (强实体):
├─ 订单编号: O001 (可以独立标识)
├─ 订单日期: 2025-09-01  
├─ 客户信息: 张三
└─ 订单金额: 500元

订单明细 (弱实体):
├─ 商品编号: P001 (不能独立标识明细)
├─ 商品名称: 手机
├─ 数量: 1
└─ 单价: 500元

为什么订单明细是弱实体？
• 单独的"商品编号P001"无法确定是哪个订单的明细
• 必须结合"订单编号O001"才能唯一标识一条明细记录
• 如果订单被删除，明细记录也失去意义
```

### 1.3 依赖关系的强度分析


**📊 依赖关系强度等级**：

| 依赖强度 | **特征** | **示例** | **处理方式** |
|---------|----------|----------|-------------|
| **🔴 强依赖** | `生命周期完全绑定` | 订单→订单明细 | 级联删除 |
| **🟡 中依赖** | `功能上依赖，可独立存在` | 部门→员工 | 限制删除 |
| **🟢 弱依赖** | `引用关系，可空` | 用户→头像 | 设置NULL |

**🔄 依赖关系演进路径**：

```
依赖关系变化过程:
设计阶段    开发阶段    运行阶段    维护阶段
    ↓          ↓          ↓          ↓
 识别依赖 → 设计约束 → 实施约束 → 调整优化
    ↓          ↓          ↓          ↓
 强度分析 → 级联规则 → 性能监控 → 规则调整
```

---

## 2. 🔍 弱实体识别与设计


### 2.1 弱实体识别的系统方法


**🎯 识别弱实体的思维框架**：

```
识别流程图:
开始分析实体
      ↓
这个实体能独立存在吗？
      ↓ No        ↓ Yes
   弱实体候选     强实体
      ↓
它的存在依赖其他实体吗？
      ↓ Yes       ↓ No
   确认弱实体    重新分析
      ↓
设计依赖关系
```

**🔧 识别弱实体的关键问题**：

> 🤔 **自问自答检查法**
> 
> 1. **独立性检查**：这个实体能脱离其他实体独立存在吗？
> 2. **标识性检查**：这个实体有自己独特的唯一标识吗？
> 3. **业务意义检查**：删除被依赖实体后，这个实体还有意义吗？
> 4. **生命周期检查**：这个实体的创建和销毁是否依赖其他实体？

### 2.2 常见弱实体设计模式


**📋 经典弱实体模式**：

**模式1：明细模式**
```
订单 (1) ----< 订单明细 (N)
         标识依赖

订单表:
order_id (PK) | order_date | customer
O001         | 2025-09-01 | 张三

订单明细表:
order_id (FK) | item_id (PK) | product_name | quantity | price  
O001         | 1            | 手机         | 1        | 500
O001         | 2            | 耳机         | 2        | 50

复合主键: (order_id, item_id)
```

**模式2：从属模式**
```
员工 (1) ----< 家属 (N)
         存在依赖

员工表:
emp_id (PK) | emp_name | department
E001       | 张三     | 技术部

家属表:
emp_id (FK) | relation (PK) | name | age
E001       | 配偶          | 李四 | 30
E001       | 子女          | 张小 | 5

复合主键: (emp_id, relation)
```

**模式3：版本模式**
```
文档 (1) ----< 文档版本 (N)
         历史依赖

文档表:
doc_id (PK) | title      | author
D001       | 需求文档   | 张三

版本表:
doc_id (FK) | version (PK) | content     | created_date
D001       | 1.0          | 初版内容    | 2025-08-01
D001       | 1.1          | 修订内容    | 2025-09-01

复合主键: (doc_id, version)
```

### 2.3 弱实体设计的最佳实践


**✅ 设计检查清单**：

- [x] **标识完整性** - 弱实体的主键能否唯一标识每条记录
- [x] **依赖合理性** - 依赖关系是否符合业务逻辑
- [x] **级联一致性** - 级联操作是否保持数据一致性
- [x] **查询效率** - 常用查询是否需要过多的表连接
- [x] **维护便利性** - 后期维护和扩展是否方便

**⚠️ 常见设计陷阱**：

> 🚫 **避免过度设计**
> 
> ```
> 错误思路: 把所有从属关系都设计成弱实体
> 正确思路: 只有真正需要标识依赖的才设计为弱实体
> 
> 例子: 员工和部门的关系
> 错误: 把员工设计成依赖部门的弱实体
> 正确: 员工是强实体，通过外键引用部门
> ```

---

## 3. 🔗 依赖关系处理策略


### 3.1 标识依赖关系设计


**🔸 标识依赖的本质含义**

标识依赖是指弱实体必须借助强实体的主键来构成自己的完整主键，这种依赖关系体现了两个实体之间不可分割的紧密联系。

**标识依赖关系图示**：

```
标识依赖关系结构:
强实体                    弱实体
┌─────────────┐         ┌─────────────────────┐
│ 学生        │         │ 成绩记录             │
│ ├─ 学号(PK) │---------│ ├─ 学号(FK,PK)      │
│ ├─ 姓名     │   1:N   │ ├─ 课程号(PK)       │
│ ├─ 班级     │  标识   │ ├─ 学期(PK)         │
│ └─ 入学年份  │  依赖   │ ├─ 成绩             │
└─────────────┘         │ └─ 考试日期          │
                        └─────────────────────┘
```

**🔧 标识依赖的设计要点**：

```sql
-- 强实体表结构
CREATE TABLE student (
    student_id VARCHAR(20) PRIMARY KEY,  -- 独立主键
    student_name VARCHAR(50) NOT NULL,
    class_name VARCHAR(30),
    admission_year YEAR
);

-- 弱实体表结构
CREATE TABLE grade_record (
    student_id VARCHAR(20),              -- 来自强实体的外键
    course_id VARCHAR(20),               -- 弱实体的部分键
    semester VARCHAR(10),                -- 弱实体的部分键
    grade DECIMAL(3,1),
    exam_date DATE,
    
    -- 复合主键：外键 + 部分键
    PRIMARY KEY (student_id, course_id, semester),
    
    -- 外键约束：实现标识依赖
    FOREIGN KEY (student_id) REFERENCES student(student_id)
        ON DELETE CASCADE                -- 级联删除
        ON UPDATE CASCADE                -- 级联更新
);
```

### 3.2 存在依赖设计


**🔸 存在依赖的业务含义**

存在依赖是指弱实体的存在完全依赖于强实体，强实体一旦不存在，弱实体也就失去了存在的意义和价值。

**存在依赖关系图示**：

```
存在依赖业务流程:
强实体生命周期              弱实体生命周期
┌─────────────┐             ┌─────────────┐
│ 创建订单    │ ----------> │ 创建订单项   │
│     ↓       │             │     ↓       │
│ 修改订单    │ ----------> │ 修改订单项   │  
│     ↓       │             │     ↓       │
│ 删除订单    │ ----------> │ 删除订单项   │
└─────────────┘             └─────────────┘
     主导                        跟随
```

**💡 存在依赖的设计原则**：

| 设计原则 | **说明** | **实现方式** |
|---------|----------|-------------|
| **同生共死** | `强实体创建时可创建弱实体` | 业务逻辑控制 |
| **级联删除** | `强实体删除时必须删除弱实体` | CASCADE约束 |
| **引用完整性** | `弱实体必须引用存在的强实体` | 外键约束 |
| **一致性维护** | `保持强弱实体间的数据一致性` | 事务控制 |

### 3.3 依赖关系强度分析


**📊 依赖强度评估模型**：

```
依赖强度评估维度:
业务依赖性 ████████████████████████████████ 40%
├─ 业务逻辑上是否必须依赖
├─ 独立存在是否有意义
└─ 生命周期是否一致

技术依赖性 ████████████████████████████████ 35% 
├─ 是否需要借助其他实体主键
├─ 查询是否总是需要关联
└─ 数据完整性约束程度

维护复杂性 ████████████████████████████████ 25%
├─ 级联操作的复杂程度
├─ 查询性能影响
└─ 维护成本高低
```

**🎯 依赖强度分级**：

| 强度等级 | **特征** | **典型例子** | **处理策略** |
|---------|----------|-------------|-------------|
| **🔴 强依赖** | `无强实体就无意义` | 订单→订单明细 | 严格级联控制 |
| **🟡 中依赖** | `业务上依赖，技术上可独立` | 部门→员工 | 限制性删除 |
| **🟢 弱依赖** | `仅引用关系` | 用户→最后登录记录 | 可空外键 |

### 3.4 弱实体主键构成规则


**🔑 主键构成的标准模式**：

```
弱实体主键 = 强实体主键 + 弱实体部分键

标准格式:
┌─────────────────────────────────────┐
│ 复合主键组成                         │
│ ├─ 外键部分 (来自强实体主键)          │
│ │   └─ 确保依赖关系                 │
│ └─ 部分键 (弱实体自有属性)            │
│     └─ 确保在同一强实体内唯一        │
└─────────────────────────────────────┘
```

**💡 主键设计示例**：

```sql
-- 示例1: 房间预订系统
-- 强实体：酒店
CREATE TABLE hotel (
    hotel_id INT PRIMARY KEY,
    hotel_name VARCHAR(100),
    city VARCHAR(50)
);

-- 弱实体：房间
CREATE TABLE room (
    hotel_id INT,                    -- 外键：来自强实体
    room_number VARCHAR(10),         -- 部分键：房间号在酒店内唯一
    room_type VARCHAR(20),
    price DECIMAL(8,2),
    
    PRIMARY KEY (hotel_id, room_number),  -- 复合主键
    FOREIGN KEY (hotel_id) REFERENCES hotel(hotel_id)
        ON DELETE CASCADE
);

-- 为什么这样设计？
-- 房间号"101"在不同酒店可以重复
-- 只有"某个酒店的101房间"才是唯一的
-- 酒店不存在了，房间也就没意义了
```

---

## 4. 🔄 弱实体转换规则


### 4.1 ER图到关系模式的转换


**🔄 弱实体转换的标准流程**：

```
转换步骤:
步骤 1️⃣: 创建强实体对应的关系表
步骤 2️⃣: 创建弱实体对应的关系表  
步骤 3️⃣: 将强实体主键作为弱实体外键
步骤 4️⃣: 组合外键和部分键形成复合主键
步骤 5️⃣: 设置适当的完整性约束
```

**📊 转换规则对比表**：

| 转换元素 | **强实体转换** | **弱实体转换** | **关键差异** |
|---------|---------------|---------------|-------------|
| **主键设计** | `单一主键` | `复合主键` | 弱实体包含外键 |
| **外键约束** | `可选` | `必须` | 弱实体强制依赖 |
| **级联操作** | `不涉及` | `必须设置` | 保证存在依赖 |
| **完整性约束** | `实体内约束` | `跨实体约束` | 更复杂的约束 |

### 4.2 弱实体转换实例详解


**🏗️ 图书管理系统转换示例**：

**原始ER模型**：
```
图书 (强实体)          图书副本 (弱实体)
┌─────────────┐       ┌─────────────────┐
│ 图书编号     │       │ 副本编号         │
│ 书名        │ 1:N   │ 购买日期         │
│ 作者        │----<  │ 存放位置         │
│ 出版社      │       │ 状态            │
│ ISBN       │       │                 │
└─────────────┘       └─────────────────┘
```

**转换后的关系模式**：

```sql
-- 强实体转换
CREATE TABLE book (
    book_id VARCHAR(20) PRIMARY KEY,     -- 独立主键
    title VARCHAR(200) NOT NULL,
    author VARCHAR(100),
    publisher VARCHAR(100),
    isbn VARCHAR(20) UNIQUE
);

-- 弱实体转换
CREATE TABLE book_copy (
    book_id VARCHAR(20),                 -- 外键：来自强实体
    copy_number INT,                     -- 部分键：副本编号
    purchase_date DATE,
    location VARCHAR(50),
    status ENUM('可借', '已借', '维修中', '丢失'),
    
    -- 复合主键：强实体主键 + 弱实体部分键
    PRIMARY KEY (book_id, copy_number),
    
    -- 外键约束：实现存在依赖
    FOREIGN KEY (book_id) REFERENCES book(book_id)
        ON DELETE CASCADE                -- 图书删除时，所有副本一起删除
        ON UPDATE CASCADE
);
```

### 4.3 多层弱实体转换


**🔗 多级依赖关系处理**：

```
多层弱实体结构:
订单 (强实体)
  ↓ 1:N 标识依赖
订单明细 (弱实体)
  ↓ 1:N 标识依赖  
明细备注 (弱实体的弱实体)

依赖链条:
订单 → 订单明细 → 明细备注
删除传播: 删除订单 → 删除所有明细 → 删除所有备注
```

**🔧 多层转换实现**：

```sql
-- 第一层：订单 (强实体)
CREATE TABLE orders (
    order_id VARCHAR(20) PRIMARY KEY,
    order_date DATE,
    customer_name VARCHAR(100)
);

-- 第二层：订单明细 (弱实体)  
CREATE TABLE order_item (
    order_id VARCHAR(20),
    item_seq INT,                        -- 明细序号
    product_name VARCHAR(100),
    quantity INT,
    
    PRIMARY KEY (order_id, item_seq),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON DELETE CASCADE
);

-- 第三层：明细备注 (弱实体的弱实体)
CREATE TABLE item_note (
    order_id VARCHAR(20),
    item_seq INT,  
    note_seq INT,                        -- 备注序号
    note_content TEXT,
    note_date DATETIME,
    
    PRIMARY KEY (order_id, item_seq, note_seq),
    FOREIGN KEY (order_id, item_seq) 
        REFERENCES order_item(order_id, item_seq)
        ON DELETE CASCADE
);
```

### 4.4 转换验证与测试


**🧪 转换正确性验证**：

```sql
-- 测试数据插入验证
-- 步骤1: 插入强实体数据
INSERT INTO orders VALUES ('O001', '2025-09-01', '张三');

-- 步骤2: 插入弱实体数据  
INSERT INTO order_item VALUES ('O001', 1, '手机', 1);
INSERT INTO order_item VALUES ('O001', 2, '耳机', 2);

-- 步骤3: 插入多层弱实体数据
INSERT INTO item_note VALUES ('O001', 1, 1, '需要红色', NOW());

-- 步骤4: 验证级联删除
DELETE FROM orders WHERE order_id = 'O001';
-- 应该自动删除相关的订单明细和备注

-- 步骤5: 验证完整性约束
INSERT INTO order_item VALUES ('O999', 1, '商品', 1);  
-- 应该失败：违反外键约束
```

---

## 5. 🛡️ 完整性约束与级联操作


### 5.1 完整性约束类型


**🔒 弱实体相关的完整性约束**：

```
约束类型体系:
实体完整性
├─ 主键约束 (PRIMARY KEY)
│  └─ 复合主键唯一性
├─ 候选键约束 (UNIQUE)  
│  └─ 替代标识符
└─ 非空约束 (NOT NULL)
   └─ 必需属性

引用完整性
├─ 外键约束 (FOREIGN KEY)
│  ├─ 标识依赖实现
│  ├─ 存在依赖保证
│  └─ 级联操作控制
└─ 检查约束 (CHECK)
   └─ 业务规则约束

领域完整性  
├─ 数据类型约束
├─ 取值范围约束
└─ 格式规则约束
```

### 5.2 级联操作详解


**🔄 级联操作的四种类型**：

| 级联类型 | **触发条件** | **操作行为** | **适用场景** |
|---------|-------------|-------------|-------------|
| **CASCADE** | `删除/更新强实体` | `自动删除/更新弱实体` | 强依赖关系 |
| **SET NULL** | `删除/更新强实体` | `弱实体外键设为NULL` | 可选依赖 |
| **SET DEFAULT** | `删除/更新强实体` | `弱实体外键设为默认值` | 有默认值情况 |
| **RESTRICT** | `删除/更新强实体` | `如有弱实体则拒绝操作` | 保护性删除 |

**⚡ 级联操作示例**：

```sql
-- 不同级联策略的实现
CREATE TABLE order_item (
    -- 强依赖：订单删除时明细必须删除
    order_id VARCHAR(20),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);

CREATE TABLE employee (
    -- 中等依赖：部门删除时员工部门设为空
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES department(dept_id)
        ON DELETE SET NULL
        ON UPDATE CASCADE
);

CREATE TABLE product (
    -- 保护性删除：有商品时不能删除分类
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES category(category_id)
        ON DELETE RESTRICT
        ON UPDATE CASCADE
);
```

### 5.3 复杂完整性约束实现


**🔧 业务规则约束实现**：

```sql
-- 复合业务约束示例：订单系统
CREATE TABLE order_item (
    order_id VARCHAR(20),
    item_seq INT,
    product_id VARCHAR(20),
    quantity INT,
    unit_price DECIMAL(10,2),
    discount_rate DECIMAL(3,2) DEFAULT 0.00,
    
    PRIMARY KEY (order_id, item_seq),
    
    -- 基础外键约束
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON DELETE CASCADE,
    
    -- 业务规则约束
    CONSTRAINT ck_quantity CHECK (quantity > 0),
    CONSTRAINT ck_price CHECK (unit_price >= 0),
    CONSTRAINT ck_discount CHECK (discount_rate >= 0 AND discount_rate <= 1),
    
    -- 复合约束：确保明细序号连续
    CONSTRAINT ck_item_seq CHECK (item_seq > 0)
);

-- 触发器实现复杂业务约束
DELIMITER $$
CREATE TRIGGER tr_order_item_seq 
BEFORE INSERT ON order_item
FOR EACH ROW
BEGIN
    -- 自动分配明细序号
    SELECT COALESCE(MAX(item_seq), 0) + 1 INTO @next_seq
    FROM order_item 
    WHERE order_id = NEW.order_id;
    
    SET NEW.item_seq = @next_seq;
END$$
DELIMITER ;
```

---

## 6. 🚀 弱实体性能优化


### 6.1 查询复杂度控制


**📊 查询复杂度分析**：

弱实体查询往往涉及多表连接，需要特别关注性能优化。

```
查询复杂度等级:
简单查询 ████████████████████████████████ O(1)
├─ 主键直接查询
└─ 单表过滤查询

中等查询 ████████████████████████████████ O(log n)  
├─ 强实体关联查询
└─ 索引覆盖查询

复杂查询 ████████████████████████████████ O(n)
├─ 多层弱实体连接
├─ 全表关联扫描
└─ 子查询嵌套
```

**🔧 查询优化策略**：

```sql
-- 优化前：低效查询
SELECT s.student_name, g.course_id, g.grade
FROM student s, grade_record g  
WHERE s.student_id = g.student_id
  AND s.class_name = '计算机2班';

-- 优化后：使用适当索引和连接方式
SELECT s.student_name, g.course_id, g.grade
FROM student s
INNER JOIN grade_record g ON s.student_id = g.student_id
WHERE s.class_name = '计算机2班';

-- 创建复合索引优化弱实体查询
CREATE INDEX idx_grade_student_course 
ON grade_record(student_id, course_id);

CREATE INDEX idx_student_class 
ON student(class_name);
```

### 6.2 索引设计策略


**📈 弱实体索引设计原则**：

| 索引类型 | **设计目的** | **创建位置** | **注意事项** |
|---------|-------------|-------------|-------------|
| **主键索引** | `保证唯一性` | 复合主键 | 自动创建 |
| **外键索引** | `优化关联查询` | 外键列 | 手动创建 |
| **覆盖索引** | `避免回表查询` | 常用查询列 | 权衡空间 |
| **复合索引** | `优化多条件查询` | 多个查询条件 | 注意列顺序 |

**🎯 索引设计实战**：

```sql
-- 弱实体索引设计案例
CREATE TABLE order_item (
    order_id VARCHAR(20),
    item_seq INT,
    product_id VARCHAR(20),
    product_name VARCHAR(100),
    quantity INT,
    unit_price DECIMAL(10,2),
    
    PRIMARY KEY (order_id, item_seq),
    
    -- 索引1：优化按订单查询明细
    INDEX idx_order_items (order_id),
    
    -- 索引2：优化按商品查询明细
    INDEX idx_product_items (product_id),
    
    -- 索引3：优化统计查询 (覆盖索引)
    INDEX idx_summary (order_id, product_id, quantity, unit_price)
);

-- 查询优化效果验证
EXPLAIN SELECT COUNT(*), SUM(quantity * unit_price)
FROM order_item 
WHERE order_id = 'O001';
-- 使用idx_summary覆盖索引，无需回表
```

### 6.3 分区表优化


**📊 弱实体分区策略**：

```sql
-- 按时间分区的弱实体表
CREATE TABLE order_item (
    order_id VARCHAR(20),
    item_seq INT,
    product_id VARCHAR(20),
    quantity INT,
    order_date DATE,                     -- 用于分区
    
    PRIMARY KEY (order_id, item_seq, order_date),  -- 包含分区键
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
)
PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025), 
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**🎯 分区优化效果**：

```
分区前后性能对比:
数据量: 1000万订单明细记录

查询最近3个月数据:
分区前: ████████████████████████████████ 15秒 (全表扫描)
分区后: ████ 2秒 (只扫描相关分区)

删除历史数据:
分区前: ████████████████████████████████ 2小时 (逐行删除)
分区后: ██ 10秒 (DROP PARTITION)
```

---

## 7. 📋 实际应用案例


### 7.1 电商订单系统案例


**🛒 电商系统弱实体设计**：

```
电商订单系统实体关系:
客户 (强实体)
  ↓ 1:N
订单 (强实体)  
  ↓ 1:N 标识依赖
订单明细 (弱实体)
  ↓ 1:N 标识依赖
明细评价 (弱实体)
```

**🔧 完整实现代码**：

```sql
-- 客户表 (强实体)
CREATE TABLE customer (
    customer_id VARCHAR(20) PRIMARY KEY,
    customer_name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20)
);

-- 订单表 (强实体)
CREATE TABLE orders (
    order_id VARCHAR(20) PRIMARY KEY,
    customer_id VARCHAR(20) NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(12,2),
    status ENUM('待付款','已付款','已发货','已完成','已取消'),
    
    FOREIGN KEY (customer_id) REFERENCES customer(customer_id)
);

-- 订单明细表 (弱实体)
CREATE TABLE order_item (
    order_id VARCHAR(20),
    item_seq INT,                        -- 明细序号 (部分键)
    product_id VARCHAR(20),
    product_name VARCHAR(100),
    quantity INT,
    unit_price DECIMAL(10,2),
    subtotal DECIMAL(12,2),
    
    PRIMARY KEY (order_id, item_seq),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON DELETE CASCADE
        ON UPDATE CASCADE,
        
    -- 业务约束
    CONSTRAINT ck_quantity CHECK (quantity > 0),
    CONSTRAINT ck_price CHECK (unit_price >= 0)
);

-- 明细评价表 (弱实体的弱实体)
CREATE TABLE item_review (
    order_id VARCHAR(20),
    item_seq INT,
    review_id INT AUTO_INCREMENT,        -- 评价ID (部分键)
    rating INT,
    review_content TEXT,
    review_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (order_id, item_seq, review_id),
    FOREIGN KEY (order_id, item_seq) 
        REFERENCES order_item(order_id, item_seq)
        ON DELETE CASCADE,
        
    CONSTRAINT ck_rating CHECK (rating BETWEEN 1 AND 5)
);
```

### 7.2 人事管理系统案例


**👥 人事系统弱实体应用**：

```
人事系统实体结构:
员工 (强实体)
├─ 基本信息
├─ 工作经历 (弱实体)
├─ 教育背景 (弱实体)  
├─ 家庭成员 (弱实体)
└─ 培训记录 (弱实体)

设计要点:
• 每类信息都依赖员工存在
• 员工离职时相关信息一并清理
• 不同类型信息有不同的标识方式
```

**💼 实现设计**：

```sql
-- 员工表 (强实体)
CREATE TABLE employee (
    emp_id VARCHAR(20) PRIMARY KEY,
    emp_name VARCHAR(100) NOT NULL,
    id_card VARCHAR(18) UNIQUE,
    hire_date DATE,
    department VARCHAR(50)
);

-- 工作经历表 (弱实体)
CREATE TABLE work_experience (
    emp_id VARCHAR(20),
    exp_seq INT,                         -- 经历序号
    company_name VARCHAR(100),
    position VARCHAR(50),
    start_date DATE,
    end_date DATE,
    
    PRIMARY KEY (emp_id, exp_seq),
    FOREIGN KEY (emp_id) REFERENCES employee(emp_id)
        ON DELETE CASCADE
);

-- 家庭成员表 (弱实体)
CREATE TABLE family_member (
    emp_id VARCHAR(20),
    member_name VARCHAR(50),             -- 成员姓名 (部分键)
    relationship VARCHAR(20),
    birth_date DATE,
    id_card VARCHAR(18),
    
    PRIMARY KEY (emp_id, member_name),   -- 注意：姓名作为部分键
    FOREIGN KEY (emp_id) REFERENCES employee(emp_id)
        ON DELETE CASCADE
);
```

### 7.3 图书管理系统完整案例


**📚 图书馆系统设计实战**：

<details>
<summary>🔍 点击查看完整系统设计</summary>

```sql
-- 图书基本信息 (强实体)
CREATE TABLE book (
    book_id VARCHAR(20) PRIMARY KEY,
    isbn VARCHAR(20) UNIQUE,
    title VARCHAR(200) NOT NULL,
    author VARCHAR(100),
    publisher VARCHAR(100),
    publish_date DATE,
    category VARCHAR(50)
);

-- 图书副本 (弱实体)
CREATE TABLE book_copy (
    book_id VARCHAR(20),
    copy_number INT,                     -- 副本编号
    barcode VARCHAR(50) UNIQUE,          -- 物理条码
    purchase_date DATE,
    location VARCHAR(50),                -- 存放位置
    status ENUM('可借','已借','维修','丢失') DEFAULT '可借',
    
    PRIMARY KEY (book_id, copy_number),
    FOREIGN KEY (book_id) REFERENCES book(book_id)
        ON DELETE CASCADE
);

-- 借阅记录 (弱实体)
CREATE TABLE borrow_record (
    book_id VARCHAR(20),
    copy_number INT,
    borrow_seq INT,                      -- 借阅序号
    reader_id VARCHAR(20),
    borrow_date DATE,
    due_date DATE,
    return_date DATE,
    fine_amount DECIMAL(8,2) DEFAULT 0,
    
    PRIMARY KEY (book_id, copy_number, borrow_seq),
    FOREIGN KEY (book_id, copy_number) 
        REFERENCES book_copy(book_id, copy_number)
        ON DELETE CASCADE,
    FOREIGN KEY (reader_id) REFERENCES reader(reader_id)
);

-- 常用查询优化
CREATE INDEX idx_copy_status ON book_copy(status);
CREATE INDEX idx_borrow_reader ON borrow_record(reader_id);
CREATE INDEX idx_borrow_date ON borrow_record(borrow_date);
```

</details>

### 7.4 弱实体设计的常见问题


**⚠️ 设计陷阱与解决方案**：

```markdown
❌ **问题1：过度使用弱实体**
错误思路: 把所有从属关系都设计成弱实体
影响: 查询复杂，性能下降，维护困难
解决: 只有真正需要标识依赖的才用弱实体

❌ **问题2：忽略级联操作性能**  
错误思路: 设置级联删除后不考虑性能影响
影响: 删除强实体时可能触发大量级联操作
解决: 评估级联范围，考虑分批删除

❌ **问题3：复合主键过于复杂**
错误思路: 复合主键包含过多列
影响: 索引体积大，查询性能差
解决: 简化主键设计，考虑代理键

✅ **最佳实践总结**
• 审慎识别真正的弱实体
• 设计适当的索引策略
• 考虑查询性能影响
• 建立监控和优化机制
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 弱实体定义：缺乏完整主键，依赖强实体存在的实体类型
🔸 标识依赖：弱实体必须借助强实体主键构成完整主键  
🔸 存在依赖：弱实体的存在完全依赖强实体的存在
🔸 级联操作：强实体变化时对弱实体的自动操作
🔸 复合主键：外键部分 + 部分键构成的完整主键
```

### 8.2 关键理解要点


**🔹 弱实体不是技术缺陷**
```
正确理解：
- 弱实体是业务现实的准确建模
- 体现了现实世界中的依赖关系
- 是ER模型的重要组成部分
- 有助于保持数据的逻辑一致性
```

**🔹 设计时要平衡多个因素**
```
平衡考虑：
- 业务逻辑准确性 vs 查询性能
- 数据一致性 vs 系统复杂度  
- 规范化程度 vs 维护成本
- 理论完整性 vs 实际可行性
```

**🔹 从业务角度理解技术选择**
```
业务驱动设计：
- 强依赖关系 → 使用弱实体设计
- 弱依赖关系 → 使用普通外键引用
- 性能敏感场景 → 考虑反规范化
- 维护便利性 → 适度简化设计
```

### 8.3 实际应用指导


**💡 设计决策流程**

```markdown
🎯 **弱实体设计决策树**
问题1: 这个实体能独立存在吗？
├─ Yes → 强实体设计
└─ No → 继续分析

问题2: 它的主键需要依赖其他实体吗？  
├─ Yes → 考虑弱实体设计
└─ No → 重新分析需求

问题3: 业务上确实存在生命周期依赖吗？
├─ Yes → 采用弱实体设计
└─ No → 使用普通关联关系

🔧 **实施检查清单**
- [ ] 复合主键设计是否合理
- [ ] 外键约束是否正确设置
- [ ] 级联操作是否符合业务需求
- [ ] 查询性能是否可接受
- [ ] 维护操作是否便利

📊 **性能监控要点**
- 监控复合主键查询性能
- 检查级联操作执行时间
- 观察索引使用情况
- 评估存储空间使用
```

**🚀 发展趋势与建议**

> 💡 **现代数据库设计趋势**
> 
> - **微服务架构**：弱实体设计更需要考虑跨服务边界
> - **NoSQL融合**：某些弱实体场景可考虑文档数据库
> - **云原生设计**：弱实体的分布式一致性挑战
> - **性能优化**：弱实体查询的缓存和索引策略

**核心记忆**：
- 弱实体源于现实依赖，设计需要贴合业务
- 标识依赖决定主键，存在依赖决定生命周期
- 级联操作保证一致性，但要考虑性能影响
- 查询优化需要合理索引，复杂查询需要拆分
- 设计要平衡规范性与实用性，避免过度工程化