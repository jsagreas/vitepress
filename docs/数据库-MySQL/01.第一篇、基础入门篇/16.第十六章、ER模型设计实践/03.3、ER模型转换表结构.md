---
title: 3、ER模型转换表结构
---
## 📚 目录

1. [ER模型转换概述](#1-er模型转换概述)
2. [基本转换规则](#2-基本转换规则)
3. [关系转换策略](#3-关系转换策略)
4. [复杂关系处理](#4-复杂关系处理)
5. [数据类型映射](#5-数据类型映射)
6. [转换质量保证](#6-转换质量保证)
7. [实践案例演示](#7-实践案例演示)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 ER模型转换概述


### 1.1 什么是ER模型转换


**简单理解**：ER模型转换就像把建筑设计图纸变成真正的房子，把抽象的数据模型变成具体的数据库表

```
转换过程：
设计阶段                     实现阶段
┌─────────────┐             ┌─────────────┐
│  ER模型图   │    转换      │  数据库表   │
│ (概念设计)  │  ────────>  │ (物理实现)  │
│             │             │             │
│ 实体+关系   │             │ 表+外键     │
└─────────────┘             └─────────────┘
```

### 1.2 转换的核心目标


**转换要达到的目标**：
- 🎯 **完整性**：ER模型中的所有信息都要在表结构中体现
- 🎯 **准确性**：转换后的表结构要准确反映业务关系
- 🎯 **高效性**：表结构要便于查询和维护
- 🎯 **规范性**：符合数据库设计的规范和最佳实践

### 1.3 转换流程概览


**🔥 ER到关系模型转换算法**：
```
第1步：实体转换
每个实体 → 一个数据表
实体属性 → 表字段

第2步：关系转换  
一对一关系 → 外键引用
一对多关系 → 外键引用
多对多关系 → 中间关系表

第3步：约束转换
主键约束 → PRIMARY KEY
外键约束 → FOREIGN KEY
唯一约束 → UNIQUE
检查约束 → CHECK

第4步：优化调整
索引设计 → CREATE INDEX
分区策略 → PARTITION BY
存储引擎选择 → ENGINE=InnoDB
```

---

## 2. 📋 基本转换规则


### 2.1 实体转表规则


**🔑 ER转换基本规则 - 实体转换**

**规则1：每个实体转换为一个表**

```
ER模型中的实体：
┌─────────────────┐
│      学生       │
│ ─────────────── │
│ 学号(主键)      │
│ 姓名            │
│ 年龄            │
│ 专业            │
└─────────────────┘

转换为数据表：
CREATE TABLE 学生 (
    学号 VARCHAR(20) PRIMARY KEY,
    姓名 VARCHAR(50) NOT NULL,
    年龄 INT,
    专业 VARCHAR(100)
);
```

**规则2：弱实体转换处理**

**什么是弱实体**：依赖于其他实体才能存在的实体，就像"房间号"必须依赖于"建筑物"才有意义

```
弱实体示例：
建筑物 ←─────→ 房间
(强实体)      (弱实体)

转换结果：
-- 强实体表
CREATE TABLE 建筑物 (
    建筑ID VARCHAR(20) PRIMARY KEY,
    建筑名称 VARCHAR(100)
);

-- 弱实体表（包含强实体的主键）
CREATE TABLE 房间 (
    建筑ID VARCHAR(20),           -- 来自强实体的外键
    房间号 VARCHAR(10),           -- 本身的标识
    房间面积 DECIMAL(10,2),
    PRIMARY KEY (建筑ID, 房间号),  -- 组合主键
    FOREIGN KEY (建筑ID) REFERENCES 建筑物(建筑ID)
);
```

### 2.2 属性转字段映射


**属性转换的基本原则**：

| ER模型属性类型 | 转换方式 | SQL实现 |
|----------------|----------|---------|
| **简单属性** | 直接转为字段 | `姓名 VARCHAR(50)` |
| **复合属性** | 拆分为多个字段 | `地址 → 省份、城市、详细地址` |
| **多值属性** | 单独创建关系表 | `电话号码 → 独立的电话表` |
| **派生属性** | 通过计算得出 | `年龄 ← 由出生日期计算` |

**复合属性转换示例**：
```sql
-- ER模型中的复合属性：地址(省份，城市，详细地址)
-- 转换为：
CREATE TABLE 客户 (
    客户ID INT PRIMARY KEY,
    姓名 VARCHAR(50),
    -- 复合属性拆分
    地址_省份 VARCHAR(50),
    地址_城市 VARCHAR(50), 
    地址_详细 VARCHAR(200)
);
```

**多值属性转换示例**：
```sql
-- ER模型中的多值属性：电话号码（一个人可能有多个电话）
-- 转换为独立表：
CREATE TABLE 客户 (
    客户ID INT PRIMARY KEY,
    姓名 VARCHAR(50)
);

CREATE TABLE 客户电话 (
    客户ID INT,
    电话号码 VARCHAR(20),
    电话类型 VARCHAR(20), -- 手机、座机、传真等
    PRIMARY KEY (客户ID, 电话号码),
    FOREIGN KEY (客户ID) REFERENCES 客户(客户ID)
);
```

---

## 3. 🔗 关系转换策略


### 3.1 一对一关系转换


**理解一对一关系**：就像"身份证"和"人"的关系，一个人只能有一个身份证，一个身份证只能属于一个人

**转换方式1：合并为一个表（推荐）**
```sql
-- 合并方式
CREATE TABLE 员工 (
    员工ID INT PRIMARY KEY,
    姓名 VARCHAR(50),
    -- 直接包含身份证信息
    身份证号 VARCHAR(18) UNIQUE,
    签发机关 VARCHAR(100),
    有效期 DATE
);
```

**转换方式2：保持两个表**
```sql
-- 分离方式（当信息较多时）
CREATE TABLE 员工 (
    员工ID INT PRIMARY KEY,
    姓名 VARCHAR(50)
);

CREATE TABLE 身份证 (
    身份证号 VARCHAR(18) PRIMARY KEY,
    员工ID INT UNIQUE,                    -- 一对一外键
    签发机关 VARCHAR(100),
    有效期 DATE,
    FOREIGN KEY (员工ID) REFERENCES 员工(员工ID)
);
```

### 3.2 一对多关系转换


**理解一对多关系**：就像"班级"和"学生"的关系，一个班级有多个学生，一个学生只属于一个班级

**🔑 转换规则**：在"多"的一方添加外键

```sql
-- 一对多关系转换
CREATE TABLE 班级 (
    班级ID INT PRIMARY KEY,
    班级名称 VARCHAR(50),
    班主任 VARCHAR(50)
);

CREATE TABLE 学生 (
    学号 VARCHAR(20) PRIMARY KEY,
    姓名 VARCHAR(50),
    班级ID INT,                           -- 外键指向"一"的一方
    FOREIGN KEY (班级ID) REFERENCES 班级(班级ID)
);
```

**关系转换图示**：
```
ER模型：
班级 ──────1:N────── 学生
     包含

转换后的表结构：
班级表                    学生表
┌─────────┐              ┌─────────┐
│ 班级ID  │              │ 学号    │
│ 班级名称│              │ 姓名    │
│ 班主任  │              │ 班级ID  │←── 外键
└─────────┘              └─────────┘
```

### 3.3 多对多关系转换


**理解多对多关系**：就像"学生"和"课程"的关系，一个学生可以选修多门课程，一门课程可以被多个学生选修

**🔑 转换规则**：创建中间关系表，包含两个实体的主键作为外键

```sql
-- 多对多关系转换
CREATE TABLE 学生 (
    学号 VARCHAR(20) PRIMARY KEY,
    姓名 VARCHAR(50)
);

CREATE TABLE 课程 (
    课程ID VARCHAR(20) PRIMARY KEY,
    课程名称 VARCHAR(100),
    学分 INT
);

-- 多对多关系表
CREATE TABLE 选课记录 (
    学号 VARCHAR(20),
    课程ID VARCHAR(20),
    选课时间 DATETIME,
    成绩 DECIMAL(5,2),
    PRIMARY KEY (学号, 课程ID),                           -- 组合主键
    FOREIGN KEY (学号) REFERENCES 学生(学号),
    FOREIGN KEY (课程ID) REFERENCES 课程(课程ID)
);
```

**多对多关系图示**：
```
ER模型：
学生 ──────M:N────── 课程
     选修

转换后的表结构：
学生表              选课记录表              课程表
┌─────────┐        ┌─────────────┐        ┌─────────┐
│ 学号    │        │ 学号(FK)    │        │ 课程ID  │
│ 姓名    │        │ 课程ID(FK)  │        │ 课程名称│
└─────────┘        │ 选课时间     │        │ 学分    │
                   │ 成绩        │        └─────────┘
                   └─────────────┘
```

---

## 4. 🔧 复杂关系处理


### 4.1 继承关系处理


**什么是继承关系**：就像动物分类，"动物"是父类，"猫"、"狗"是子类，子类继承父类的特征

**🔥 复杂关系转换策略 - 继承关系的三种转换方式**：

**方式1：单表策略（Table Per Hierarchy）**
```sql
-- 所有子类合并到一个表
CREATE TABLE 动物 (
    动物ID INT PRIMARY KEY,
    名称 VARCHAR(50),
    类型 VARCHAR(20),        -- 区分是猫还是狗
    -- 猫的特有属性
    毛色 VARCHAR(20),
    是否长毛 BOOLEAN,
    -- 狗的特有属性  
    品种 VARCHAR(50),
    体重 DECIMAL(5,2),
    -- 鸟的特有属性
    翼展 DECIMAL(5,2),
    是否会飞 BOOLEAN
);
```

**方式2：类表策略（Table Per Class）**
```sql
-- 每个子类一个表，包含所有属性
CREATE TABLE 猫 (
    动物ID INT PRIMARY KEY,
    名称 VARCHAR(50),        -- 继承的属性
    毛色 VARCHAR(20),        -- 猫特有的属性
    是否长毛 BOOLEAN
);

CREATE TABLE 狗 (
    动物ID INT PRIMARY KEY,
    名称 VARCHAR(50),        -- 继承的属性
    品种 VARCHAR(50),        -- 狗特有的属性
    体重 DECIMAL(5,2)
);
```

**方式3：连接表策略（Table Per Subclass）**
```sql
-- 父类表
CREATE TABLE 动物 (
    动物ID INT PRIMARY KEY,
    名称 VARCHAR(50)
);

-- 子类表，通过外键关联父类
CREATE TABLE 猫 (
    动物ID INT PRIMARY KEY,
    毛色 VARCHAR(20),
    是否长毛 BOOLEAN,
    FOREIGN KEY (动物ID) REFERENCES 动物(动物ID)
);

CREATE TABLE 狗 (
    动物ID INT PRIMARY KEY,
    品种 VARCHAR(50),
    体重 DECIMAL(5,2),
    FOREIGN KEY (动物ID) REFERENCES 动物(动物ID)
);
```

**三种方式对比**：
| 策略 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **单表策略** | 查询简单，性能好 | 存在很多NULL值，浪费空间 | 子类属性差异不大 |
| **类表策略** | 无NULL值，结构清晰 | 查询复杂，难以统计 | 子类完全独立 |
| **连接表策略** | 符合规范化，扩展性好 | 需要连接查询，性能一般 | 子类有共同操作需求 |

### 4.2 聚合关系转换


**什么是聚合关系**：就像"汽车"和"发动机"的关系，发动机是汽车的一部分，但可以独立存在

```sql
-- 聚合关系转换示例
CREATE TABLE 汽车 (
    汽车ID VARCHAR(20) PRIMARY KEY,
    品牌 VARCHAR(50),
    型号 VARCHAR(50)
);

CREATE TABLE 发动机 (
    发动机ID VARCHAR(20) PRIMARY KEY,
    功率 INT,
    排量 DECIMAL(3,1),
    汽车ID VARCHAR(20),                   -- 外键，可以为NULL
    FOREIGN KEY (汽车ID) REFERENCES 汽车(汽车ID)
);
```

### 4.3 组合关系转换


**什么是组合关系**：就像"房子"和"房间"的关系，房间依赖于房子存在，房子没了房间也就没了

```sql
-- 组合关系转换示例
CREATE TABLE 房子 (
    房子ID VARCHAR(20) PRIMARY KEY,
    地址 VARCHAR(200),
    面积 DECIMAL(10,2)
);

CREATE TABLE 房间 (
    房间ID VARCHAR(20) PRIMARY KEY,
    房子ID VARCHAR(20) NOT NULL,         -- 外键，不能为NULL
    房间名称 VARCHAR(50),
    面积 DECIMAL(8,2),
    FOREIGN KEY (房子ID) REFERENCES 房子(房子ID) 
        ON DELETE CASCADE                 -- 级联删除
);
```

---

## 5. 🔀 数据类型映射


### 5.1 基本数据类型转换


**🔑 数据类型映射规则**：

| ER模型属性类型 | MySQL数据类型 | 说明 | 示例 |
|----------------|---------------|------|------|
| **文本类型** | `VARCHAR(n)` | 可变长度字符串 | `姓名 VARCHAR(50)` |
| **固定文本** | `CHAR(n)` | 固定长度字符串 | `性别 CHAR(1)` |
| **大文本** | `TEXT` | 长文本内容 | `简介 TEXT` |
| **整数** | `INT` | 标准整数 | `年龄 INT` |
| **小整数** | `TINYINT` | 0-255范围 | `等级 TINYINT` |
| **大整数** | `BIGINT` | 大范围整数 | `访问量 BIGINT` |
| **金额** | `DECIMAL(p,s)` | 精确小数 | `价格 DECIMAL(10,2)` |
| **日期** | `DATE` | 年月日 | `出生日期 DATE` |
| **时间** | `TIME` | 时分秒 | `上班时间 TIME` |
| **日期时间** | `DATETIME` | 完整时间戳 | `创建时间 DATETIME` |
| **布尔值** | `BOOLEAN` | 真假值 | `是否激活 BOOLEAN` |

### 5.2 特殊属性转换


**枚举属性转换**：
```sql
-- ER模型：性别(男，女，未知)
-- 转换为：
性别 ENUM('男', '女', '未知') DEFAULT '未知'
```

**图片/文件属性转换**：
```sql
-- ER模型：头像(图片)
-- 转换为：
头像URL VARCHAR(500),              -- 存储文件路径
头像大小 INT,                      -- 文件大小(字节)
头像类型 VARCHAR(20)               -- 文件类型(jpg/png等)
```

**JSON属性转换**：
```sql
-- ER模型：配置信息(复杂结构)
-- 转换为：
配置信息 JSON,                     -- MySQL 5.7+支持JSON类型
-- 或者
配置信息 TEXT                      -- 存储JSON字符串
```

### 5.3 约束条件转换


**ER模型约束 → SQL约束的转换**：

```sql
CREATE TABLE 学生 (
    -- 主键约束
    学号 VARCHAR(20) PRIMARY KEY,
    
    -- 非空约束
    姓名 VARCHAR(50) NOT NULL,
    
    -- 唯一约束  
    身份证号 VARCHAR(18) UNIQUE,
    
    -- 检查约束
    年龄 INT CHECK (年龄 >= 0 AND 年龄 <= 120),
    
    -- 默认值约束
    入学时间 DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    -- 外键约束
    班级ID INT,
    FOREIGN KEY (班级ID) REFERENCES 班级(班级ID)
);
```

---

## 6. ✅ 转换质量保证


### 6.1 转换质量验证方法


**🔥 转换质量验证清单**：

**完整性验证**：
- ✅ 每个ER实体都有对应的表
- ✅ 每个实体属性都有对应的字段
- ✅ 每个关系都有正确的实现方式
- ✅ 所有约束条件都得到正确转换

**准确性验证**：
- ✅ 主键设置正确且有业务意义
- ✅ 外键关系准确反映业务关系
- ✅ 数据类型选择合适且高效
- ✅ 约束条件符合业务规则

### 6.2 转换后检查要点


**数据完整性检查**：
```sql
-- 检查主键设置
SELECT TABLE_NAME, COLUMN_NAME 
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE 
WHERE CONSTRAINT_NAME = 'PRIMARY';

-- 检查外键关系
SELECT TABLE_NAME, COLUMN_NAME, REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE 
WHERE REFERENCED_TABLE_NAME IS NOT NULL;

-- 检查字段约束
SELECT TABLE_NAME, COLUMN_NAME, IS_NULLABLE, COLUMN_DEFAULT
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'your_database';
```

### 6.3 常见转换错误


**❌ 常见转换错误及解决方案**：

| 错误类型 | 错误表现 | 正确做法 |
|----------|----------|----------|
| **多对多转换错误** | 直接在两个表间建外键 | 创建中间关系表 |
| **主键选择错误** | 使用无意义的自增ID | 优先使用有业务意义的自然主键 |
| **数据类型不当** | 金额用FLOAT存储 | 金额必须用DECIMAL |
| **外键约束缺失** | 只有字段没有约束 | 添加FOREIGN KEY约束 |
| **约束过于严格** | 所有字段都NOT NULL | 根据业务需求合理设置 |

---

## 7. 🛠️ 实践案例演示


### 7.1 完整转换案例


**案例：学生选课系统ER模型转换**

**ER模型图**：
```
学生 ──────M:N────── 课程
│    选修(成绩,时间)    │
│                      │
└──────1:N─────────────┘
       所属
       班级
```

**转换步骤**：

**步骤1：实体转表**
```sql
-- 学生实体转换
CREATE TABLE 学生 (
    学号 VARCHAR(20) PRIMARY KEY,
    姓名 VARCHAR(50) NOT NULL,
    性别 ENUM('男', '女') DEFAULT '男',
    出生日期 DATE,
    入学时间 DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 课程实体转换  
CREATE TABLE 课程 (
    课程ID VARCHAR(20) PRIMARY KEY,
    课程名称 VARCHAR(100) NOT NULL,
    学分 TINYINT CHECK (学分 > 0),
    课时 INT DEFAULT 0
);

-- 班级实体转换
CREATE TABLE 班级 (
    班级ID VARCHAR(20) PRIMARY KEY,
    班级名称 VARCHAR(50) NOT NULL,
    班主任 VARCHAR(50),
    所属学院 VARCHAR(100)
);
```

**步骤2：关系转换**
```sql
-- 一对多关系：学生所属班级
ALTER TABLE 学生 ADD COLUMN 班级ID VARCHAR(20);
ALTER TABLE 学生 ADD FOREIGN KEY (班级ID) REFERENCES 班级(班级ID);

-- 多对多关系：学生选修课程
CREATE TABLE 选课记录 (
    学号 VARCHAR(20),
    课程ID VARCHAR(20),
    选课时间 DATETIME DEFAULT CURRENT_TIMESTAMP,
    成绩 DECIMAL(5,2) CHECK (成绩 >= 0 AND 成绩 <= 100),
    状态 ENUM('已选课', '已完成', '已退课') DEFAULT '已选课',
    PRIMARY KEY (学号, 课程ID),
    FOREIGN KEY (学号) REFERENCES 学生(学号) ON DELETE CASCADE,
    FOREIGN KEY (课程ID) REFERENCES 课程(课程ID) ON DELETE RESTRICT
);
```

### 7.2 转换结果验证


**验证转换结果**：
```sql
-- 验证数据插入
INSERT INTO 班级 VALUES ('CS2021', '计算机科学2021级', '张老师', '计算机学院');
INSERT INTO 学生 VALUES ('20210001', '张三', '男', '2003-05-15', NOW(), 'CS2021');
INSERT INTO 课程 VALUES ('CS101', '计算机基础', 3, 48);
INSERT INTO 选课记录 VALUES ('20210001', 'CS101', NOW(), 85.5, '已完成');

-- 验证关联查询
SELECT s.姓名, c.课程名称, sc.成绩
FROM 学生 s
JOIN 选课记录 sc ON s.学号 = sc.学号  
JOIN 课程 c ON sc.课程ID = c.课程ID
WHERE s.学号 = '20210001';
```

### 7.3 自动化转换工具


**🔥 转换规则自动化工具思路**：

```python
class ERToTableConverter:
    """ER模型到关系表的自动转换工具"""
    
    def convert_entity(self, entity):
        """实体转换为表"""
        table_sql = f"CREATE TABLE {entity.name} (\n"
        
        # 转换属性
        for attr in entity.attributes:
            if attr.is_primary_key:
                table_sql += f"    {attr.name} {self.map_datatype(attr)} PRIMARY KEY,\n"
            else:
                table_sql += f"    {attr.name} {self.map_datatype(attr)},\n"
        
        table_sql = table_sql.rstrip(',\n') + "\n);"
        return table_sql
    
    def convert_relationship(self, relationship):
        """关系转换处理"""
        if relationship.cardinality == "1:1":
            return self.handle_one_to_one(relationship)
        elif relationship.cardinality == "1:N":
            return self.handle_one_to_many(relationship)
        elif relationship.cardinality == "M:N":
            return self.handle_many_to_many(relationship)
    
    def map_datatype(self, attribute):
        """数据类型映射"""
        mapping = {
            'string': 'VARCHAR(255)',
            'integer': 'INT',
            'decimal': 'DECIMAL(10,2)',
            'date': 'DATE',
            'datetime': 'DATETIME',
            'boolean': 'BOOLEAN'
        }
        return mapping.get(attribute.datatype, 'VARCHAR(255)')
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的转换规则


```
🔸 实体转换：每个实体对应一个表，实体属性对应表字段
🔸 一对一关系：合并为一个表，或在任意一方添加外键
🔸 一对多关系：在"多"的一方添加外键指向"一"的一方
🔸 多对多关系：创建中间关系表，包含两个实体的主键作为外键
🔸 继承关系：根据场景选择单表、类表或连接表策略
🔸 属性转换：简单属性直接转换，复合属性拆分，多值属性独立表
🔸 约束转换：主键、外键、唯一性、检查约束的正确设置
```

### 8.2 关键理解要点


**🔹 转换的本质思维**
```
理解核心：
ER模型描述"现实世界的概念和关系"
关系表实现"计算机能理解和处理的结构"

转换过程就是把人类思维转换为机器思维
```

**🔹 关系转换的记忆方法**
```
关系转换口诀：
一对一：要么合并，要么加外键
一对多：多方加外键指向一方
多对多：中间建表两外键
```

**🔹 数据类型选择原则**
```
选择原则：
文本类型：根据最大长度选择VARCHAR或TEXT
数字类型：根据取值范围选择INT、BIGINT等
金额类型：必须使用DECIMAL，不能用FLOAT
日期类型：根据精度需求选择DATE或DATETIME
```

### 8.3 实际应用指导


**🔑 模型转换实践指导**：

**转换前的准备工作**：
- ✅ 仔细分析ER模型，确保理解所有实体和关系
- ✅ 确定主键选择策略（自然主键 vs 代理主键）
- ✅ 分析数据量和查询模式，选择合适的转换策略
- ✅ 考虑系统性能需求和存储限制

**转换过程中的注意事项**：
- ⚠️ **命名规范**：表名和字段名要规范，便于维护
- ⚠️ **约束完整**：不要遗漏任何业务约束条件
- ⚠️ **类型精确**：数据类型要精确，避免空间浪费
- ⚠️ **关系正确**：外键关系要准确反映业务逻辑

**转换后的验证工作**：
- 🔍 **插入测试数据**：验证表结构的正确性
- 🔍 **执行常见查询**：确保查询性能可接受
- 🔍 **测试约束条件**：验证所有约束都能正常工作
- 🔍 **检查数据完整性**：确保外键关系正确

### 8.4 质量保证方法


**🔑 转换质量保证最佳实践**：

```
转换质量检查清单：

□ 实体完整性
  ✓ 每个实体都有对应的表
  ✓ 每个属性都有对应的字段
  ✓ 主键设置正确且有意义

□ 参照完整性  
  ✓ 外键关系准确无误
  ✓ 参照动作设置合理(CASCADE/RESTRICT)
  ✓ 关联表能正确JOIN查询

□ 语义完整性
  ✓ 约束条件完整准确
  ✓ 数据类型选择恰当
  ✓ 默认值设置合理

□ 性能考虑
  ✓ 查询路径优化
  ✓ 索引设计合理
  ✓ 数据分布均衡
```

**自动化验证脚本示例**：
```sql
-- 检查所有表是否有主键
SELECT TABLE_NAME
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
  ON t.TABLE_NAME = tc.TABLE_NAME 
  AND tc.CONSTRAINT_TYPE = 'PRIMARY KEY'
WHERE t.TABLE_SCHEMA = DATABASE()
  AND tc.CONSTRAINT_NAME IS NULL;

-- 检查外键关系的一致性
SELECT DISTINCT
    kcu.TABLE_NAME,
    kcu.COLUMN_NAME,
    kcu.REFERENCED_TABLE_NAME,
    kcu.REFERENCED_COLUMN_NAME
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
WHERE kcu.REFERENCED_TABLE_NAME IS NOT NULL
  AND kcu.TABLE_SCHEMA = DATABASE();
```

**核心记忆**：
```
ER转表要细心，规则掌握是关键
实体变表属性变字段，关系处理分情况
一对一二选一，一对多外键加多方
多对多中间表，继承关系三方案
约束类型要对应，验证质量不能忘
```