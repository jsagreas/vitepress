---
title: 2、逻辑模型设计
---
## 📚 目录

1. [逻辑模型设计概述](#1-逻辑模型设计概述)
2. [概念到逻辑映射规则](#2-概念到逻辑映射规则)
3. [关系模式设计核心](#3-关系模式设计核心)
4. [属性与约束设计](#4-属性与约束设计)
5. [逻辑模型优化策略](#5-逻辑模型优化策略)
6. [跨平台设计考虑](#6-跨平台设计考虑)
7. [实践应用指导](#7-实践应用指导)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 逻辑模型设计概述


### 1.1 什么是逻辑模型


**🔸 核心定义**
```
逻辑模型：将概念模型转换为数据库可实现的设计蓝图
位置：概念模型 → 逻辑模型 → 物理模型
作用：连接业务需求和技术实现的桥梁
特点：独立于具体数据库产品，关注数据关系和结构
```

**💡 通俗理解**
如果概念模型是"房屋设计草图"，那么逻辑模型就是"建筑施工图"：
- **概念模型**：这里需要客厅、卧室、厨房（业务需求）
- **逻辑模型**：客厅20平米，卧室15平米，具体房间布局（数据结构）
- **物理模型**：用什么材料，具体施工工艺（技术实现）

### 1.2 逻辑模型的核心任务


**🎯 主要目标**
```
结构化转换：
• 将概念实体转换为关系表
• 将属性转换为表字段
• 将关系转换为外键约束

规范化处理：
• 消除数据冗余
• 确保数据一致性
• 提高数据质量

约束定义：
• 主键约束定义
• 外键关系建立
• 业务规则约束化
```

### 1.3 逻辑模型设计流程


```
概念模型分析
        ↓
实体关系识别 → 属性分析 → 约束确定
        ↓           ↓         ↓
关系表设计 ← 字段定义 ← 约束设计
        ↓
范式化检查
        ↓
逻辑模型优化
        ↓
逻辑模型文档
```

---

## 2. 🔄 概念到逻辑映射规则


### 2.1 实体映射规则 🔥


**🔸 实体转换为关系表**
```
映射原则：一个实体对应一个关系表

概念模型中的实体：
┌─────────────┐
│   学生实体   │
│ - 学号      │
│ - 姓名      │  
│ - 年龄      │
│ - 专业      │
└─────────────┘

逻辑模型中的关系表：
Student(学号, 姓名, 年龄, 专业)
主键：学号
```

**💡 复合实体处理**
```
概念模型：学生选课（多对多关系）

┌─────┐  选课  ┌─────┐
│学生  │ ←──→ │课程  │
└─────┘       └─────┘

逻辑模型转换：
Student(学号, 姓名, 专业)
Course(课程号, 课程名, 学分)
选课(学号, 课程号, 成绩, 选课时间)  ← 关系表
```

### 2.2 属性映射规则 🔥


**🔸 属性转换策略**

| 概念模型属性类型 | **逻辑模型处理** | **示例** |
|-----------------|----------------|---------|
| **简单属性** | `直接映射为字段` | `姓名 → name VARCHAR(50)` |
| **复合属性** | `拆分为多个字段` | `地址 → 省份+城市+详细地址` |
| **多值属性** | `创建独立关系表` | `电话号码 → 单独的电话表` |
| **派生属性** | `计算字段或视图` | `年龄 → 从出生日期计算` |

**🔧 复合属性拆分示例**
```
概念模型：
Employee {
    员工ID,
    姓名,
    地址(省份, 城市, 街道, 门牌号),
    联系方式(手机, 邮箱, QQ)
}

逻辑模型：
Employee(
    emp_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    province VARCHAR(20),
    city VARCHAR(30), 
    street VARCHAR(100),
    house_number VARCHAR(20),
    mobile VARCHAR(15),
    email VARCHAR(100),
    qq VARCHAR(15)
)
```

### 2.3 关系映射规则 🔥


**🔸 一对一关系映射**
```
处理方式1：合并到一个表
Person(身份证号, 姓名, 护照号, 护照有效期)

处理方式2：分别建表，外键关联
Person(身份证号, 姓名)
Passport(护照号, 护照有效期, 身份证号 FK)

选择原则：
• 关系紧密且不可分割 → 合并表
• 关系松散或有特殊需求 → 分别建表
```

**🔸 一对多关系映射**
```
关系：一个部门有多个员工

Department(dept_id, dept_name, manager)
Employee(emp_id, name, salary, dept_id FK)

关键点：
• 外键放在"多"的一方
• 外键指向"一"方的主键
• 保证引用完整性
```

**🔸 多对多关系映射**
```
关系：学生选课

Student(student_id, name, major)
Course(course_id, course_name, credits)
Enrollment(
    student_id FK,     // 指向Student
    course_id FK,      // 指向Course
    grade,
    enroll_date,
    PRIMARY KEY(student_id, course_id)  // 复合主键
)
```

---

## 3. 📊 关系模式设计核心


### 3.1 关系模式设计原则 🔑


**🔸 设计基本原则**
```
完整性原则：
• 确保所有业务实体都有对应表
• 所有重要属性都被包含
• 关系约束完整定义

一致性原则：
• 命名规范统一
• 数据类型选择一致
• 约束定义标准化

可扩展性原则：
• 预留扩展空间
• 避免硬编码限制
• 考虑未来需求变化
```

### 3.2 表结构设计规范


**🔧 表命名规范**
```
表名规范：
• 使用复数形式：users, orders, products
• 下划线分隔：order_details, user_profiles
• 避免保留字：不用user, order等关键字
• 语义明确：表名能清楚表达内容

字段命名规范：
• 小写加下划线：first_name, created_at
• 主键统一：id 或 表名_id
• 外键明确：user_id, order_id
• 布尔字段：is_active, has_permission
```

**📋 标准表结构模板**
```sql
-- 标准用户表设计
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_phone (phone)
);
```

### 3.3 主外键定义策略


**🔸 主键设计原则**
```
主键选择策略：

自然主键：
• 使用业务中真实存在的唯一标识
• 如：身份证号、商品编码
• 优点：业务意义明确
• 缺点：可能变化，性能较差

代理主键：
• 系统生成的无业务意义ID
• 如：自增ID、UUID
• 优点：稳定不变，性能好
• 缺点：无业务含义

推荐方案：
• 大多数情况使用代理主键(自增ID)
• 业务唯一字段设置唯一约束
• 既保证性能又满足业务需求
```

**🔧 外键设计实践**
```sql
-- 外键约束定义
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    order_number VARCHAR(32) NOT NULL UNIQUE,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'delivered') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 外键约束
    FOREIGN KEY (user_id) REFERENCES users(id) 
        ON DELETE RESTRICT      -- 防止误删用户
        ON UPDATE CASCADE,      -- 用户ID更新时同步
        
    INDEX idx_user_id (user_id),
    INDEX idx_order_number (order_number),
    INDEX idx_status (status)
);
```

---

## 4. 🏗️ 属性与约束设计


### 4.1 属性数据类型选择


**🔸 数据类型选择原则**
```
精确性原则：选择最准确表达数据的类型
效率性原则：在满足需求前提下选择最高效的类型
扩展性原则：预留足够空间应对未来增长
标准化原则：同类数据使用相同类型
```

**💡 常用字段类型设计指南**

| 业务场景 | **推荐类型** | **说明** | **示例** |
|---------|------------|---------|---------|
| **用户ID** | `BIGINT AUTO_INCREMENT` | `预留足够空间` | `1, 2, 3...` |
| **金额** | `DECIMAL(10,2)` | `精确计算，避免浮点误差` | `99.99` |
| **姓名** | `VARCHAR(50)` | `可变长度，节省空间` | `张三` |
| **邮箱** | `VARCHAR(100)` | `考虑国际域名长度` | `user@example.com` |
| **手机号** | `VARCHAR(20)` | `支持国际号码格式` | `+86-13812345678` |
| **状态** | `ENUM` | `限定值，性能好` | `'active','inactive'` |
| **创建时间** | `TIMESTAMP` | `自动维护时间` | `2025-01-20 10:30:00` |
| **是否标记** | `BOOLEAN` | `明确布尔语义` | `TRUE/FALSE` |

### 4.2 约束逻辑化设计


**🔸 约束类型分析**
```
实体完整性约束：
• 主键约束：PRIMARY KEY
• 非空约束：NOT NULL
• 唯一约束：UNIQUE

参照完整性约束：
• 外键约束：FOREIGN KEY
• 级联操作：CASCADE, RESTRICT

用户定义约束：
• 检查约束：CHECK
• 默认值：DEFAULT
• 自动更新：ON UPDATE
```

**🔧 复杂约束实现示例**
```sql
-- 业务规则约束化
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    discount_price DECIMAL(10,2),
    stock_quantity INT NOT NULL DEFAULT 0,
    category_id BIGINT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 业务约束
    CHECK (price > 0),                           -- 价格必须大于0
    CHECK (discount_price IS NULL OR discount_price < price), -- 折扣价小于原价
    CHECK (stock_quantity >= 0),                 -- 库存不能为负
    
    -- 外键约束
    FOREIGN KEY (category_id) REFERENCES categories(id),
    
    -- 索引优化
    INDEX idx_category_active (category_id, is_active),
    INDEX idx_price (price)
);
```

### 4.3 业务规则实现


**🔸 业务规则转换策略**
```
触发器实现：
• 复杂业务逻辑检查
• 数据联动更新
• 业务日志记录

存储过程实现：
• 复杂事务处理
• 批量数据操作
• 业务流程控制

应用层实现：
• 复杂计算逻辑
• 外部系统集成
• 实时业务规则
```

**📝 业务规则示例**
```sql
-- 订单状态变更业务规则
DELIMITER //
CREATE TRIGGER order_status_check 
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
    -- 业务规则：已完成订单不能修改
    IF OLD.status = 'completed' AND NEW.status != 'completed' THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '已完成订单不能修改状态';
    END IF;
    
    -- 业务规则：订单金额不能为负
    IF NEW.total_amount < 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '订单金额不能为负数';
    END IF;
    
    -- 自动更新修改时间
    SET NEW.updated_at = CURRENT_TIMESTAMP;
END//
DELIMITER ;
```

---

## 5. 🚀 逻辑模型优化策略


### 5.1 逻辑模型优化技巧 🔑


**🔸 范式化优化**
```
第一范式(1NF)：消除重复组
问题：一个字段存储多个值
解决：拆分为多行或多表

第二范式(2NF)：消除部分函数依赖
问题：非主键字段依赖于主键的一部分
解决：将依赖部分独立成表

第三范式(3NF)：消除传递函数依赖
问题：非主键字段间存在依赖关系
解决：将传递依赖独立成表
```

**📊 范式化示例**
```sql
-- 未范式化设计（存在问题）
CREATE TABLE order_details_bad (
    order_id INT,
    product_id INT,
    product_name VARCHAR(100),    -- 冗余：依赖于product_id
    product_price DECIMAL(10,2),  -- 冗余：依赖于product_id
    quantity INT,
    total_price DECIMAL(10,2),    -- 冗余：可由单价*数量计算
    PRIMARY KEY(order_id, product_id)
);

-- 范式化后设计
CREATE TABLE order_details (
    order_id INT,
    product_id INT,
    quantity INT,
    unit_price DECIMAL(10,2),     -- 下单时价格，避免价格变动影响
    PRIMARY KEY(order_id, product_id),
    FOREIGN KEY (order_id) REFERENCES orders(id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);
```

### 5.2 逻辑模型性能优化 🔥


**⚡ 性能优化策略**
```
索引设计优化：
• 主键自动有聚集索引
• 外键字段创建索引
• 常用查询条件创建复合索引
• 避免过多索引影响写入性能

分区设计考虑：
• 按时间分区：历史数据归档
• 按业务分区：不同类型数据分离
• 提高查询性能和维护效率

反范式化权衡：
• 适度冗余提高查询性能
• 权衡存储空间和查询效率
• 通过视图提供统一访问接口
```

**🔧 性能优化实例**
```sql
-- 订单查询优化设计
CREATE TABLE orders_optimized (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    order_number VARCHAR(32) NOT NULL UNIQUE,
    user_name VARCHAR(50) NOT NULL,        -- 冗余：提高查询性能
    total_amount DECIMAL(10,2) NOT NULL,
    item_count INT NOT NULL,               -- 冗余：避免关联查询
    status ENUM('pending','paid','shipped','delivered') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 复合索引：常用查询组合
    INDEX idx_user_status (user_id, status),
    INDEX idx_status_created (status, created_at),
    INDEX idx_created_amount (created_at, total_amount)
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### 5.3 逻辑建模转换方法 🔑


**🔄 转换方法论**
```
自顶向下方法：
• 从整体业务开始
• 逐步细化到具体表结构
• 适合新系统设计

自底向上方法：
• 从现有数据开始
• 归纳总结形成模型
• 适合遗留系统改造

混合方法：
• 结合两种方法优势
• 业务驱动+数据驱动
• 最常用的实践方法
```

---

## 6. 🌐 跨平台设计考虑


### 6.1 跨平台逻辑模型设计 🔥


**🔸 平台差异性处理**
```
数据类型兼容性：
MySQL      → PostgreSQL    → SQL Server
VARCHAR    → VARCHAR       → NVARCHAR
TIMESTAMP  → TIMESTAMP     → DATETIME2
AUTO_INCREMENT → SERIAL   → IDENTITY

约束支持差异：
• CHECK约束：MySQL 8.0+支持，早期版本不支持
• ENUM类型：MySQL特有，其他数据库需要CHECK约束替代
• 外键约束：MyISAM不支持，InnoDB支持
```

**💡 跨平台设计策略**
```sql
-- 跨平台兼容的表设计
CREATE TABLE users_compatible (
    id BIGINT NOT NULL,                    -- 避免AUTO_INCREMENT
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    status VARCHAR(20) NOT NULL,           -- 用VARCHAR代替ENUM
    created_at TIMESTAMP,
    
    PRIMARY KEY (id),
    UNIQUE KEY uk_username (username),
    UNIQUE KEY uk_email (email)
);

-- 约束通过CHECK实现（标准SQL）
ALTER TABLE users_compatible 
ADD CONSTRAINT chk_status 
CHECK (status IN ('active', 'inactive', 'suspended'));
```

### 6.2 标准SQL遵循


**📜 SQL标准化设计**
```
ANSI SQL标准遵循：
• 使用标准数据类型
• 避免厂商特有功能
• 使用标准约束语法
• 采用标准函数

移植性考虑：
• 避免厂商特有数据类型
• 使用通用的约束机制
• 标准化命名规范
• 文档化平台差异
```

---

## 7. 🛠️ 实践应用指导


### 7.1 逻辑模型设计实战


**🎯 电商系统逻辑模型示例**
```sql
-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    phone VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 商品分类表
CREATE TABLE categories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    parent_id BIGINT,
    level INT NOT NULL DEFAULT 1,
    sort_order INT DEFAULT 0,
    
    FOREIGN KEY (parent_id) REFERENCES categories(id),
    INDEX idx_parent (parent_id)
);

-- 商品表
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INT NOT NULL DEFAULT 0,
    category_id BIGINT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CHECK (price > 0),
    CHECK (stock_quantity >= 0),
    FOREIGN KEY (category_id) REFERENCES categories(id),
    
    INDEX idx_category_active (category_id, is_active),
    INDEX idx_price (price),
    FULLTEXT INDEX ft_name_desc (name, description)
);

-- 订单表
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    order_number VARCHAR(32) NOT NULL UNIQUE,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') 
           DEFAULT 'pending',
    shipping_address TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id),
    INDEX idx_user_status (user_id, status),
    INDEX idx_created (created_at)
);

-- 订单详情表
CREATE TABLE order_items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    
    CHECK (quantity > 0),
    CHECK (unit_price > 0),
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id),
    
    UNIQUE KEY uk_order_product (order_id, product_id),
    INDEX idx_product (product_id)
);
```

### 7.2 逻辑模型文档化


**📋 逻辑模型文档模板**
```
表名：users (用户表)
描述：存储系统用户基本信息

字段说明：
┌──────────────┬─────────────┬─────────┬─────────────┬──────────────┐
│ 字段名        │ 数据类型     │ 是否为空 │ 默认值       │ 说明          │
├──────────────┼─────────────┼─────────┼─────────────┼──────────────┤
│ id           │ BIGINT      │ NOT NULL│ AUTO_INC    │ 用户唯一标识  │
│ username     │ VARCHAR(50) │ NOT NULL│ 无          │ 用户名        │
│ email        │ VARCHAR(100)│ NOT NULL│ 无          │ 邮箱地址      │
│ phone        │ VARCHAR(20) │ NULL    │ NULL        │ 手机号码      │
│ created_at   │ TIMESTAMP   │ NOT NULL│ CURRENT_TS  │ 创建时间      │
└──────────────┴─────────────┴─────────┴─────────────┴──────────────┘

约束说明：
• 主键：id
• 唯一约束：username, email
• 外键：无
• 业务规则：邮箱格式验证由应用层处理

关联关系：
• 一对多：users → orders (一个用户可有多个订单)
```

### 7.3 模型验证与测试


**✅ 逻辑模型验证清单**
- [ ] **完整性检查**：所有业务实体都有对应表
- [ ] **一致性检查**：命名规范统一，类型选择合理
- [ ] **约束检查**：主外键约束正确，业务规则完整
- [ ] **性能检查**：索引设计合理，查询路径优化
- [ ] **扩展性检查**：支持未来需求变化
- [ ] **兼容性检查**：跨数据库平台兼容

**🔧 模型测试方法**
```sql
-- 插入测试数据验证约束
INSERT INTO users (username, email) VALUES ('test', 'test@example.com');
INSERT INTO products (name, price, category_id) VALUES ('测试商品', 99.99, 1);

-- 测试外键约束
INSERT INTO orders (user_id, order_number, total_amount) 
VALUES (999, 'TEST001', 100.00);  -- 应该失败，用户不存在

-- 测试业务约束  
INSERT INTO products (name, price, category_id) 
VALUES ('错误商品', -10.00, 1);    -- 应该失败，价格为负

-- 性能测试
EXPLAIN SELECT * FROM orders o 
JOIN users u ON o.user_id = u.id 
WHERE o.status = 'pending';
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 逻辑模型作用：将概念设计转换为可实现的数据库结构
🔸 映射规则体系：实体→表，属性→字段，关系→外键的转换规则
🔸 关系模式设计：表结构、主外键、约束的设计原则
🔸 优化策略方法：范式化、性能优化、跨平台兼容的平衡
🔸 业务规则实现：将业务逻辑转换为数据库约束和触发器
```

### 8.2 关键理解要点


**🔹 逻辑模型的核心价值**
```
转换价值：
• 将抽象的业务概念转换为具体的数据结构
• 为物理实现提供明确的设计指导
• 实现业务需求和技术实现的对接

优化价值：
• 通过范式化消除数据冗余
• 通过约束保证数据质量
• 通过索引设计提升查询性能
```

**🔹 设计平衡艺术**
```
范式化 vs 性能：
• 高范式化：数据冗余少，更新简单，查询复杂
• 适度冗余：查询性能好，更新复杂，存储增加
• 平衡策略：核心表高范式化，查询表适度冗余

理论 vs 实践：
• 理论指导：遵循设计原则和规范
• 实践调整：根据具体业务场景优化
• 迭代优化：在使用中持续改进
```

### 8.3 实际应用价值


**💡 业务应用场景**
- **新系统设计**：从0到1的数据库设计
- **系统重构**：优化现有数据库结构  
- **数据迁移**：跨平台数据库迁移设计
- **性能优化**：基于逻辑模型的性能调优

**🔧 技术实践技能**
- **工具使用**：掌握建模工具的使用
- **代码生成**：从逻辑模型生成DDL脚本
- **文档管理**：维护完整的设计文档
- **版本控制**：管理模型变更历史

### 8.4 学习进阶路径


```
🔸 基础掌握：
• 理解逻辑模型的作用和位置
• 掌握基本的映射规则
• 能够设计简单的表结构

🔸 熟练应用：
• 熟练进行范式化设计
• 能够优化逻辑模型性能
• 掌握跨平台设计技巧

🔸 专家水平：
• 能够设计复杂业务系统
• 精通性能优化策略
• 具备架构设计能力
```

**🎯 实践建议**
- ① **多练习**：通过实际项目积累经验
- ② **多对比**：研究优秀系统的设计方案
- ③ **多思考**：理解设计决策背后的原因
- ④ **多总结**：形成自己的设计模式库

**核心记忆**：
- 逻辑模型是概念转实现的关键步骤
- 映射规则要灵活运用，不能机械转换
- 设计要平衡理论规范和实际需求
- 优化策略需要在多个维度间找平衡