---
title: 23、数据类型系统详解
---
## 📚 目录

1. [MySQL数据类型概述](#1-mysql数据类型概述)
2. [整数类型详解](#2-整数类型详解)
3. [浮点与定点类型](#3-浮点与定点类型)
4. [字符串类型系统](#4-字符串类型系统)
5. [二进制数据类型](#5-二进制数据类型)
6. [日期时间类型](#6-日期时间类型)
7. [JSON数据类型](#7-json数据类型)
8. [枚举与集合类型](#8-枚举与集合类型)
9. [位类型与布尔类型](#9-位类型与布尔类型)
10. [数据类型选择指南](#10-数据类型选择指南)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🗂️ MySQL数据类型概述


### 1.1 什么是数据类型


**🔸 数据类型的本质**
```
数据类型 = 数据存储格式 + 操作规则

作用：
├── 规定数据如何存储：占用多少字节
├── 规定数据如何表示：整数、小数、文字
├── 规定可以进行什么操作：加减乘除、字符串拼接
└── 规定数据的取值范围：最小值到最大值
```

**💡 为什么需要数据类型**
- **存储效率**：不同类型占用不同空间，合理选择节省存储
- **性能优化**：类型匹配的运算更快
- **数据完整性**：类型约束防止错误数据
- **功能支持**：不同类型支持不同的函数和操作

### 1.2 MySQL数据类型分类图


```
MySQL数据类型家族
    │
    ├── 数值类型
    │   ├── 整数：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT
    │   ├── 浮点：FLOAT、DOUBLE
    │   └── 定点：DECIMAL
    │
    ├── 字符串类型  
    │   ├── 定长：CHAR
    │   ├── 变长：VARCHAR
    │   └── 大文本：TEXT系列
    │
    ├── 二进制类型
    │   ├── 定长：BINARY
    │   ├── 变长：VARBINARY  
    │   └── 大二进制：BLOB系列
    │
    ├── 日期时间类型
    │   ├── DATE、TIME、DATETIME
    │   ├── TIMESTAMP、YEAR
    │   └── 各有不同的精度和范围
    │
    └── 特殊类型
        ├── JSON：存储JSON格式数据
        ├── ENUM：枚举类型
        ├── SET：集合类型
        └── BIT：位类型
```

### 1.3 选择数据类型的基本原则


**🎯 选择原则**
```
1. 够用就行：选择能存储数据的最小类型
   示例：年龄用TINYINT(0-255)而不是INT

2. 预留空间：考虑业务增长，适当预留
   示例：用户ID用INT而不是SMALLINT

3. 性能考虑：整数比字符串运算快
   示例：状态字段用TINYINT而不是VARCHAR

4. 业务匹配：类型要符合业务含义
   示例：金额用DECIMAL而不是FLOAT
```

---

## 2. 🔢 整数类型详解


### 2.1 整数类型家族概览


**🔸 五种整数类型对比**

| **类型** | **字节数** | **有符号范围** | **无符号范围** | **典型用途** |
|----------|-----------|---------------|---------------|-------------|
| **TINYINT** | 1字节 | `-128 ~ 127` | `0 ~ 255` | 年龄、状态码、小计数 |
| **SMALLINT** | 2字节 | `-32,768 ~ 32,767` | `0 ~ 65,535` | 端口号、小型ID |
| **MEDIUMINT** | 3字节 | `-8,388,608 ~ 8,388,607` | `0 ~ 16,777,215` | 中等规模ID |
| **INT** | 4字节 | `-2,147,483,648 ~ 2,147,483,647` | `0 ~ 4,294,967,295` | 主键ID、计数器 |
| **BIGINT** | 8字节 | `-9×10¹⁸ ~ 9×10¹⁸` | `0 ~ 18×10¹⁸` | 大型ID、时间戳 |

### 2.2 有符号vs无符号详解


**🔸 UNSIGNED修饰符的作用**
```
有符号整数（默认）：
┌─────────┬─────────┐
│  负数   │  正数   │
│ -128~-1 │ 0~127   │ ← TINYINT示例
└─────────┴─────────┘

无符号整数（UNSIGNED）：
┌─────────────────┐
│     正数        │
│    0~255        │ ← TINYINT UNSIGNED示例  
└─────────────────┘
```

**💡 使用建议**
```sql
-- ✅ 推荐：ID类字段使用UNSIGNED
CREATE TABLE users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    age TINYINT UNSIGNED,           -- 年龄不可能为负
    score SMALLINT UNSIGNED         -- 分数0-65535
);

-- ❌ 不推荐：可能有负值的字段
balance DECIMAL(10,2)              -- 账户余额可能为负
temperature FLOAT                  -- 温度可能为负
```

### 2.3 整数类型实际应用场景


**🎯 类型选择实战指南**

```sql
-- 用户基础信息表
CREATE TABLE user_info (
    user_id BIGINT UNSIGNED AUTO_INCREMENT,    -- 用户量可能很大
    age TINYINT UNSIGNED,                      -- 年龄0-255足够
    gender TINYINT,                            -- 0/1/2 表示性别
    status TINYINT UNSIGNED,                   -- 状态码0-255
    login_count INT UNSIGNED,                  -- 登录次数
    created_time TIMESTAMP,                    -- 创建时间
    updated_time TIMESTAMP
);

-- 订单信息表  
CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT,   -- 订单号要大范围
    user_id BIGINT UNSIGNED,                   -- 关联用户ID
    product_count SMALLINT UNSIGNED,           -- 商品数量
    total_amount DECIMAL(10,2),                -- 订单金额(可能有折扣为负)
    order_status TINYINT UNSIGNED              -- 订单状态
);
```

**🧠 记忆技巧**
```
TINY（微小）→ 1字节 → 年龄、状态
SMALL（小型）→ 2字节 → 端口、小ID  
MEDIUM（中等）→ 3字节 → 中等ID
INT（整数）→ 4字节 → 常用主键
BIG（大型）→ 8字节 → 大数据量ID
```

---

## 3. 🔢 浮点与定点类型


### 3.1 浮点类型vs定点类型的区别


**🔸 浮点数的特点**
```
FLOAT和DOUBLE：浮点数，近似存储

工作原理：
12.34 存储为 → 科学计数法 → 1.234 × 10¹
精度有限：可能出现精度丢失

示例问题：
0.1 + 0.2 ≠ 0.3 (计算机浮点运算问题)
```

**🔸 定点数的特点**
```
DECIMAL：定点数，精确存储

工作原理：
DECIMAL(10,2) → 总共10位数字，小数点后2位
12.34 存储为 → 1234 (整数存储) + 小数位信息
精度固定：不会有精度丢失
```

### 3.2 数值类型详细对比


| **类型** | **字节数** | **精度** | **适用场景** | **示例** |
|----------|-----------|---------|-------------|----------|
| **FLOAT** | 4字节 | 单精度，7位有效数字 | 科学计算、近似值 | `3.14159` |
| **DOUBLE** | 8字节 | 双精度，15位有效数字 | 高精度科学计算 | `3.141592653589793` |
| **DECIMAL(M,D)** | 变长 | 精确到小数点后D位 | 金融、货币计算 | `DECIMAL(10,2)` |

### 3.3 精度问题实战演示


**🔸 浮点数精度问题**
```sql
-- 演示浮点数精度问题
CREATE TABLE price_test (
    id INT AUTO_INCREMENT PRIMARY KEY,
    price_float FLOAT(7,2),
    price_double DOUBLE(10,2), 
    price_decimal DECIMAL(10,2)
);

-- 插入测试数据
INSERT INTO price_test (price_float, price_double, price_decimal) 
VALUES (99.99, 99.99, 99.99);

-- 查看存储结果
SELECT * FROM price_test;
-- 可能结果：
-- price_float: 99.98999...  (精度丢失!)
-- price_double: 99.99       (精度较好)  
-- price_decimal: 99.99      (精确存储)
```

**💰 金融场景的正确选择**
```sql
-- ❌ 错误：用浮点数存储金额
CREATE TABLE account_wrong (
    balance DOUBLE  -- 可能有精度问题！
);

-- ✅ 正确：用定点数存储金额
CREATE TABLE account_correct (
    balance DECIMAL(15,2)  -- 精确到分，最大999万亿
);
```

> ⚠️ **重要提醒**
> 
> 凡是涉及金钱计算的字段，一律使用`DECIMAL`类型，绝不使用`FLOAT`或`DOUBLE`！

---

## 4. 📝 字符串类型系统


### 4.1 字符串类型对比


**🔸 CHAR vs VARCHAR的根本区别**
```
CHAR（定长字符串）：
├── 存储：固定长度，不足部分用空格填充
├── 优点：存储和查询速度快
├── 缺点：可能浪费空间
└── 适用：长度固定的数据

VARCHAR（变长字符串）：
├── 存储：实际长度+长度前缀  
├── 优点：节省存储空间
├── 缺点：查询略慢
└── 适用：长度变化的数据
```

**💡 存储示例对比**
```sql
-- 假设存储"Hello"这个5字符字符串

CHAR(10)存储：
"Hello     " + 结束符 = 11字节 (浪费5字节空间)

VARCHAR(10)存储：  
长度前缀(1字节) + "Hello" + 结束符 = 7字节 (节省4字节)
```

### 4.2 字符串类型详细规格


| **类型** | **最大长度** | **存储方式** | **适用场景** | **示例** |
|----------|-------------|-------------|-------------|----------|
| **CHAR(M)** | 255字符 | 定长存储 | 身份证号、手机号 | `CHAR(11)` |
| **VARCHAR(M)** | 65,535字符 | 变长存储 | 用户名、标题 | `VARCHAR(100)` |
| **TINYTEXT** | 255字符 | 变长+长度前缀 | 短描述 | 商品简介 |
| **TEXT** | 65,535字符 | 变长+长度前缀 | 文章内容 | 博客文章 |
| **MEDIUMTEXT** | 16MB | 变长+长度前缀 | 长文档 | 技术文档 |
| **LONGTEXT** | 4GB | 变长+长度前缀 | 超大文本 | 小说全文 |

### 4.3 字符串类型选择实战


**🎯 实际应用场景**
```sql
-- 用户信息表的字符串字段设计
CREATE TABLE users (
    -- 固定长度字段用CHAR
    phone CHAR(11),                    -- 手机号固定11位
    id_card CHAR(18),                  -- 身份证号固定18位
    
    -- 变长字段用VARCHAR
    username VARCHAR(50),              -- 用户名最多50字符
    email VARCHAR(100),                -- 邮箱地址
    real_name VARCHAR(20),             -- 真实姓名
    
    -- 长文本用TEXT
    bio TEXT,                          -- 个人简介
    address VARCHAR(200)               -- 地址信息
);
```

**🧠 选择记忆法**
```
定长数据 → CHAR：
手机号、身份证、邮编、车牌号

变长数据 → VARCHAR：  
姓名、邮箱、标题、描述

长文本 → TEXT系列：
文章内容、评论、日志
```

### 4.4 字符集与排序规则


**🔸 字符集的重要性**
```
字符集(Character Set)：规定字符如何编码存储
排序规则(Collation)：规定字符如何比较和排序

常用字符集：
├── utf8：支持大部分Unicode字符（最多3字节/字符）
├── utf8mb4：完整Unicode支持（最多4字节/字符）
└── latin1：西文字符集（1字节/字符）

推荐选择：utf8mb4（支持emoji等4字节字符）
```

```sql
-- 指定字符集和排序规则
CREATE TABLE articles (
    title VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
    content TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci
);
```

---

## 5. 🗃️ 二进制数据类型


### 5.1 二进制类型概述


**🔸 什么是二进制类型**
```
用途：存储图片、文档、音频、视频等二进制数据
特点：按字节存储，不进行字符集转换
与字符串的区别：
├── 字符串：存储文本，有字符集概念
└── 二进制：存储字节，无字符集概念
```

### 5.2 二进制类型详细规格


| **类型** | **最大长度** | **存储特点** | **适用场景** |
|----------|-------------|-------------|-------------|
| **BINARY(M)** | 255字节 | 定长，不足补0 | 固定长度二进制数据 |
| **VARBINARY(M)** | 65,535字节 | 变长 | 变长二进制数据 |
| **TINYBLOB** | 255字节 | 小二进制对象 | 小图标、缩略图 |
| **BLOB** | 65KB | 二进制对象 | 图片、小文件 |
| **MEDIUMBLOB** | 16MB | 中等二进制对象 | 文档、音频 |
| **LONGBLOB** | 4GB | 大二进制对象 | 视频、大文件 |

### 5.3 二进制数据的实际应用


**🎯 实际使用建议**
```sql
-- 用户头像表
CREATE TABLE user_avatars (
    user_id INT UNSIGNED,
    avatar_small BLOB,          -- 缩略图 < 64KB
    avatar_medium MEDIUMBLOB,   -- 中等图片 < 16MB
    upload_time TIMESTAMP
);

-- 文件存储表
CREATE TABLE file_storage (
    file_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    file_name VARCHAR(255),
    file_type VARCHAR(50),      -- 文件MIME类型
    file_data LONGBLOB,         -- 文件二进制数据
    file_size INT UNSIGNED      -- 文件大小(字节)
);
```

> ⚠️ **性能提醒**
> 
> 大型二进制数据建议存储在文件系统中，数据库只存储文件路径，这样性能更好！

---

## 6. 📅 日期时间类型


### 6.1 日期时间类型全家福


**🔸 五种时间类型对比**

| **类型** | **格式** | **范围** | **字节数** | **时区** | **适用场景** |
|----------|---------|---------|-----------|---------|-------------|
| **DATE** | `YYYY-MM-DD` | `1000-9999年` | 3字节 | 无 | 生日、入职日期 |
| **TIME** | `HH:MM:SS` | `-838:59:59 ~ 838:59:59` | 3字节 | 无 | 时间段、持续时间 |
| **DATETIME** | `YYYY-MM-DD HH:MM:SS` | `1000-9999年` | 8字节 | 无 | 具体时刻 |
| **TIMESTAMP** | `YYYY-MM-DD HH:MM:SS` | `1970-2038年` | 4字节 | 有 | 记录操作时间 |
| **YEAR** | `YYYY` | `1901-2155年` | 1字节 | 无 | 年份信息 |

### 6.2 DATETIME vs TIMESTAMP深度对比


**🔸 两者的核心区别**
```
DATETIME：
├── 存储：直接存储年月日时分秒
├── 范围：1000年到9999年
├── 时区：不自动转换，存什么是什么
└── 应用：记录固定时刻，如生日、会议时间

TIMESTAMP：  
├── 存储：存储UTC时间戳(1970年至今的秒数)
├── 范围：1970年到2038年
├── 时区：自动转换到当前时区显示
└── 应用：记录操作时间，如创建时间、更新时间
```

**💡 时区转换示例**
```sql
-- 设置时区
SET time_zone = '+8:00';  -- 设置为北京时间

-- 插入数据
INSERT INTO logs (event_time, event_timestamp) 
VALUES ('2025-01-20 10:30:00', '2025-01-20 10:30:00');

-- 查看结果
SELECT event_time, event_timestamp FROM logs;
-- event_time: 2025-01-20 10:30:00 (不变)
-- event_timestamp: 2025-01-20 10:30:00 (自动转换为当前时区)

-- 切换到UTC时区
SET time_zone = '+0:00';
SELECT event_time, event_timestamp FROM logs;
-- event_time: 2025-01-20 10:30:00 (仍然不变)  
-- event_timestamp: 2025-01-20 02:30:00 (自动转换为UTC)
```

### 6.3 日期时间字段设计实战


**🎯 常见业务场景设计**
```sql
-- 用户表时间字段设计
CREATE TABLE users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    
    -- 固定时刻用DATETIME
    birthday DATE,                     -- 生日(只需要日期)
    registration_time DATETIME,        -- 注册时间(固定时刻)
    
    -- 操作时间用TIMESTAMP
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 年份信息
    birth_year YEAR                    -- 出生年份
);

-- 活动表时间设计
CREATE TABLE events (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    event_name VARCHAR(100),
    start_date DATE,                   -- 活动开始日期
    end_date DATE,                     -- 活动结束日期  
    start_time TIME,                   -- 每日开始时间
    end_time TIME,                     -- 每日结束时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 7. 📄 JSON数据类型


### 7.1 什么是JSON类型


**🔸 JSON类型的作用**
```
JSON = JavaScript Object Notation，一种数据交换格式

MySQL JSON类型：
├── 原生支持：MySQL 5.7+开始支持
├── 自动验证：插入时自动验证JSON格式
├── 索引支持：可以为JSON字段的特定路径建索引
└── 函数支持：丰富的JSON处理函数
```

**💡 JSON vs TEXT的区别**
```
用TEXT存储JSON：
├── 存储：当作普通字符串存储
├── 验证：不验证JSON格式合法性
├── 查询：只能用字符串函数处理
└── 索引：只能对整个字段建索引

用JSON类型存储：
├── 存储：二进制格式，查询更快
├── 验证：自动验证JSON格式
├── 查询：可以用JSON函数提取特定字段
└── 索引：可以为JSON内的特定路径建索引
```

### 7.2 JSON类型实际应用


**🎯 用户配置信息存储**
```sql
-- 用户配置表
CREATE TABLE user_settings (
    user_id INT UNSIGNED PRIMARY KEY,
    settings JSON,               -- 用JSON存储灵活配置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入JSON数据
INSERT INTO user_settings (user_id, settings) VALUES
(1, '{"theme": "dark", "language": "zh-CN", "notifications": {"email": true, "sms": false}}'),
(2, '{"theme": "light", "language": "en-US", "notifications": {"email": false, "sms": true}}');

-- 查询JSON数据
SELECT 
    user_id,
    JSON_EXTRACT(settings, '$.theme') AS theme,
    JSON_EXTRACT(settings, '$.language') AS language,
    JSON_EXTRACT(settings, '$.notifications.email') AS email_notify
FROM user_settings;
```

**🔸 商品属性存储**
```sql
-- 商品表（不同商品有不同属性）
CREATE TABLE products (
    product_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(100),
    category VARCHAR(50),
    attributes JSON,             -- 灵活存储商品属性
    price DECIMAL(10,2)
);

-- 手机商品
INSERT INTO products (product_name, category, attributes, price) VALUES
('iPhone 15', '手机', '{"brand": "Apple", "storage": "128GB", "color": "黑色", "screen_size": "6.1"}', 5999.00);

-- 服装商品  
INSERT INTO products (product_name, category, attributes, price) VALUES
('T恤', '服装', '{"brand": "Nike", "size": "L", "color": "白色", "material": "棉"}', 299.00);

-- 查询特定属性
SELECT product_name, JSON_EXTRACT(attributes, '$.brand') AS brand
FROM products 
WHERE JSON_EXTRACT(attributes, '$.color') = '黑色';
```

---

## 8. 🏷️ 枚举与集合类型


### 8.1 ENUM枚举类型


**🔸 什么是枚举类型**
```
ENUM = 从预定义列表中选择一个值

特点：
├── 单选：只能选择一个预定义值
├── 高效：内部用数字存储，节省空间
├── 约束：自动验证取值合法性
└── 排序：按定义顺序排序，不是字母顺序
```

**💡 ENUM使用示例**
```sql
-- 用户表的性别字段
CREATE TABLE users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    gender ENUM('男', '女', '未知') DEFAULT '未知',  -- 只能选这三个值
    status ENUM('正常', '禁用', '删除') DEFAULT '正常'
);

-- 插入数据
INSERT INTO users (username, gender, status) VALUES
('张三', '男', '正常'),     -- ✅ 正确
('李四', '女', '禁用'),     -- ✅ 正确  
('王五', '其他', '正常');   -- ❌ 错误：'其他'不在枚举中
```

### 8.2 SET集合类型


**🔸 什么是集合类型**
```
SET = 从预定义列表中选择多个值

特点：
├── 多选：可以选择多个预定义值
├── 组合：值之间用逗号分隔
├── 去重：自动去除重复值
└── 限制：最多64个选项
```

**💡 SET使用示例**
```sql
-- 用户兴趣爱好表
CREATE TABLE user_hobbies (
    user_id INT UNSIGNED,
    hobbies SET('运动', '音乐', '电影', '阅读', '旅游', '游戏', '美食') 
);

-- 插入数据
INSERT INTO user_hobbies VALUES
(1, '运动,音乐,阅读'),        -- 多个爱好
(2, '电影'),                 -- 单个爱好
(3, '旅游,美食,游戏');       -- 多个爱好

-- 查询拥有特定爱好的用户
SELECT user_id FROM user_hobbies 
WHERE FIND_IN_SET('音乐', hobbies) > 0;

-- 查询同时拥有多个爱好的用户
SELECT user_id FROM user_hobbies 
WHERE hobbies & '运动,音乐';  -- 位运算检查
```

### 8.3 ENUM vs SET vs 外键表


**🔸 三种方案对比**

| **方案** | **适用场景** | **优点** | **缺点** |
|---------|-------------|---------|---------|
| **ENUM** | 选项少且固定 | 存储高效，约束严格 | 修改选项需要ALTER TABLE |
| **SET** | 多选且选项少 | 支持多选，存储高效 | 修改选项需要ALTER TABLE |
| **外键表** | 选项多且经常变化 | 灵活性高，易维护 | 需要关联查询，性能稍低 |

**🎯 选择建议**
```
用ENUM的场景：
├── 性别：男、女、未知
├── 状态：正常、禁用、删除
└── 等级：青铜、白银、黄金、钻石

用SET的场景：
├── 兴趣爱好：运动、音乐、电影...
├── 权限标识：读、写、删除、管理...
└── 商品特性：防水、防震、便携...

用外键表的场景：
├── 城市列表：选项多且可能增加
├── 商品分类：层级复杂，经常调整
└── 标签系统：用户自定义标签
```

---

## 9. 🔢 位类型与布尔类型


### 9.1 BIT位类型详解


**🔸 什么是BIT类型**
```
BIT(M)：存储M位的二进制数据
范围：M可以是1到64
用途：存储标志位、开关状态、位掩码

存储示例：
BIT(1)：存储1位，值为0或1
BIT(8)：存储8位，值为0到255
```

**💡 BIT类型实际应用**
```sql
-- 用户权限表（用位存储多个权限开关）
CREATE TABLE user_permissions (
    user_id INT UNSIGNED,
    permissions BIT(8)           -- 8位存储8种权限
    -- 位0：读权限  位1：写权限  位2：删除权限
    -- 位3：管理权限 位4：审核权限 等等
);

-- 设置权限（二进制：10110000 = 176）
INSERT INTO user_permissions VALUES (1, 176);

-- 检查特定权限
SELECT user_id FROM user_permissions 
WHERE permissions & 1;          -- 检查是否有读权限(位0)

SELECT user_id FROM user_permissions  
WHERE permissions & 4;          -- 检查是否有删除权限(位2)
```

### 9.2 BOOLEAN布尔类型


**🔸 布尔类型的实现**
```
MySQL布尔类型：
BOOLEAN / BOOL = TINYINT(1)的别名

实际存储：
├── TRUE/1：存储为1
├── FALSE/0：存储为0
└── NULL：存储为NULL
```

**🎯 布尔类型应用**
```sql
-- 用户表的布尔字段
CREATE TABLE users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,        -- 是否激活
    is_premium BOOLEAN DEFAULT FALSE,      -- 是否高级用户
    email_verified BOOLEAN DEFAULT FALSE  -- 邮箱是否验证
);

-- 插入数据（多种写法）
INSERT INTO users (username, is_active, is_premium) VALUES
('张三', TRUE, FALSE),
('李四', 1, 0),                    -- 数字写法
('王五', 'true', 'false');         -- 字符串写法（会自动转换）

-- 查询活跃用户
SELECT * FROM users WHERE is_active = TRUE;
-- 或者
SELECT * FROM users WHERE is_active;        -- 简写形式
```

---

## 10. 🎯 数据类型选择指南


### 10.1 字段设计决策流程


```
开始设计字段
    ↓
数据是什么类型？
    ↓
┌─────┬─────┬─────┬─────┬─────┐
│数字 │文字 │时间 │二进制│特殊│
└─────┴─────┴─────┴─────┴─────┘
  ↓     ↓     ↓     ↓     ↓
整数？  定长？ 需要   图片？  枚举？
浮点？  变长？ 时区？ 文件？  JSON？
精确？  长度？ 范围？ 大小？  位？
```

### 10.2 常见字段类型选择


**🔸 用户相关字段**
```sql
CREATE TABLE users (
    -- ID类：用无符号整数，根据预期用户量选择
    user_id BIGINT UNSIGNED AUTO_INCREMENT,     -- 大型应用
    
    -- 文本类：根据长度选择
    username VARCHAR(50),                       -- 用户名限长
    email VARCHAR(100),                         -- 邮箱地址
    password_hash CHAR(60),                     -- bcrypt哈希固定60字符
    real_name VARCHAR(20),                      -- 真实姓名
    bio TEXT,                                   -- 个人简介
    
    -- 数值类：根据取值范围选择
    age TINYINT UNSIGNED,                       -- 年龄0-255
    gender ENUM('男', '女', '未知'),             -- 性别枚举
    
    -- 状态类：用小整数或枚举
    status TINYINT UNSIGNED DEFAULT 1,          -- 用户状态
    
    -- 时间类：操作时间用TIMESTAMP
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 日期类：生日用DATE
    birthday DATE,
    
    -- 布尔类：开关状态
    is_verified BOOLEAN DEFAULT FALSE,
    is_premium BOOLEAN DEFAULT FALSE
);
```

### 10.3 性能优化的类型选择


**🔸 索引友好的类型选择**
```
主键字段：
✅ 推荐：INT UNSIGNED AUTO_INCREMENT
✅ 大量数据：BIGINT UNSIGNED AUTO_INCREMENT
❌ 避免：VARCHAR作为主键（索引效率低）

外键字段：
✅ 推荐：与主键类型保持一致
❌ 避免：类型不匹配（影响关联查询性能）

查询条件字段：
✅ 推荐：整数类型 > 字符串类型
✅ 定长：CHAR > VARCHAR（查询略快）
❌ 避免：过长的VARCHAR做频繁查询条件
```

### 10.4 存储空间优化


**🔸 空间优化技巧**
```sql
-- 状态字段优化
-- ❌ 浪费空间
status VARCHAR(20)              -- 可能只存储"正常"、"禁用"

-- ✅ 节省空间  
status TINYINT                  -- 0=正常, 1=禁用, 2=删除

-- 日期字段优化
-- ❌ 浪费空间
birth_year VARCHAR(4)           -- 4字节存储年份

-- ✅ 节省空间
birth_year YEAR                 -- 1字节存储年份

-- 布尔字段优化
-- ❌ 浪费空间
is_active VARCHAR(10)           -- 存储"true"/"false"

-- ✅ 节省空间
is_active BOOLEAN               -- 1字节存储
```

**📊 空间节省效果**
```
优化前后对比（100万用户）：

优化前：
├── status VARCHAR(20) = 20MB
├── birth_year VARCHAR(4) = 4MB  
├── is_active VARCHAR(10) = 10MB
└── 总计：34MB

优化后：
├── status TINYINT = 1MB
├── birth_year YEAR = 1MB
├── is_active BOOLEAN = 1MB  
└── 总计：3MB

空间节省：31MB（节省91%！）
```

---

## 11. 📋 核心要点总结


### 11.1 数据类型选择原则速查


```
🔢 数值类型选择：
├── 整数：够用最小原则（TINYINT < SMALLINT < INT < BIGINT）
├── 小数：精确计算用DECIMAL，科学计算用DOUBLE
└── 主键：推荐INT/BIGINT UNSIGNED AUTO_INCREMENT

📝 字符串类型选择：
├── 固定长度：CHAR（手机号、身份证）
├── 变长文本：VARCHAR（用户名、标题）
└── 长文本：TEXT系列（文章、评论）

📅 时间类型选择：
├── 固定时刻：DATETIME（生日、会议时间）
├── 操作时间：TIMESTAMP（创建时间、更新时间）
└── 仅日期：DATE（活动日期）

🎯 特殊类型选择：
├── 固定选项：ENUM（性别、状态）
├── 多选项：SET（兴趣、权限）
├── 灵活数据：JSON（配置、属性）
└── 开关状态：BOOLEAN（是否激活）
```

### 11.2 常见设计误区


**🚫 避免的常见错误**
```
❌ 金额用FLOAT/DOUBLE
   ✅ 金额必须用DECIMAL

❌ 用VARCHAR存储数字
   ✅ 数字用对应的数值类型

❌ 用TEXT存储JSON
   ✅ JSON数据用JSON类型

❌ 所有整数都用INT
   ✅ 根据实际范围选择合适的整数类型

❌ 所有字符串都用VARCHAR(255)
   ✅ 根据实际长度合理设置
```

### 11.3 性能优化要点


**⚡ 性能优化记忆点**
```
存储优化：
├── 选择最小够用的类型
├── 定长优于变长（CHAR vs VARCHAR）
├── 整数优于字符串
└── 避免过度预留空间

查询优化：
├── 主键用整数类型
├── 索引字段避免过长VARCHAR
├── 时间查询用TIMESTAMP
└── 枚举查询用ENUM而不是字符串

维护优化：
├── 合理使用DEFAULT值
├── 必要字段设置NOT NULL
├── 使用AUTO_INCREMENT主键
└── 定期分析表结构优化空间
```

### 11.4 实际应用最佳实践


**🏆 企业级表设计示例**
```sql
-- 综合运用各种数据类型的用户表
CREATE TABLE users (
    -- 主键：大范围无符号整数
    user_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    
    -- 字符串：根据实际需要选择长度
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash CHAR(60) NOT NULL,            -- bcrypt固定长度
    real_name VARCHAR(20),
    phone CHAR(11),                             -- 手机号固定长度
    
    -- 数值：选择合适范围
    age TINYINT UNSIGNED,                       -- 年龄0-255够用
    balance DECIMAL(15,2) DEFAULT 0.00,         -- 余额精确到分
    login_count INT UNSIGNED DEFAULT 0,         -- 登录次数
    
    -- 枚举：固定选项
    gender ENUM('男', '女', '未知') DEFAULT '未知',
    status ENUM('正常', '禁用', '删除') DEFAULT '正常',
    
    -- 布尔：开关状态
    is_verified BOOLEAN DEFAULT FALSE,
    is_premium BOOLEAN DEFAULT FALSE,
    
    -- JSON：灵活配置
    preferences JSON,                           -- 用户偏好设置
    
    -- 时间：区分固定时刻和操作时间
    birthday DATE,                              -- 生日
    last_login_at DATETIME,                     -- 最后登录时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 索引设计
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);
```

**🧠 核心记忆口诀**
```
整数看范围大小选，够用就行别浪费
字符定长用CHAR，变长就用VARCHAR
金钱计算DECIMAL准，浮点科学DOUBLE好
时间操作TIMESTAMP，固定时刻DATETIME妙
JSON灵活ENUM严，布尔开关BIT巧
```

> 💡 **设计总结**
> 
> 数据类型选择的核心是**平衡存储效率、查询性能和业务需求**。选择时要考虑数据的实际特点、预期增长和使用方式，既不能过度节省导致不够用，也不能过度预留造成浪费。