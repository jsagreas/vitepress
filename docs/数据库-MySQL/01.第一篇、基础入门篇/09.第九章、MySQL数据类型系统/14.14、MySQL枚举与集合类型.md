---
title: 14、MySQL枚举与集合类型
---
## 📚 目录

1. [枚举与集合类型概述](#1-枚举与集合类型概述)
2. [ENUM类型详解](#2-enum类型详解)
3. [SET类型详解](#3-set类型详解)
4. [内部存储机制深度分析](#4-内部存储机制深度分析)
5. [查询操作与函数使用](#5-查询操作与函数使用)
6. [索引优化策略](#6-索引优化策略)
7. [维护与最佳实践](#7-维护与最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 枚举与集合类型概述


### 1.1 什么是ENUM和SET类型？


**🔸 ENUM枚举类型**
ENUM类型就像现实中的**单选题**，只能从预定义的选项中选一个：

```
现实例子：
性别选择：男 或 女 （只能选一个）
订单状态：待付款 或 已付款 或 已发货 或 已完成

MySQL中：
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    gender ENUM('男', '女'),           -- 只能选择其中一个
    status ENUM('待付款', '已付款', '已发货', '已完成')
);
```

**🔸 SET集合类型**
SET类型就像现实中的**多选题**，可以从预定义选项中选择多个：

```
现实例子：
兴趣爱好：读书、运动、音乐、旅游 （可以选多个）
权限设置：读取、写入、删除、管理 （可以组合）

MySQL中：
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    hobbies SET('读书', '运动', '音乐', '旅游'),    -- 可以选择多个
    permissions SET('read', 'write', 'delete', 'admin')
);
```

### 1.2 ENUM vs SET 核心区别


| 对比维度 | **ENUM类型** | **SET类型** |
|---------|-------------|------------|
| **选择方式** | `单选：只能选一个值` | `多选：可以选择多个值` |
| **存储方式** | `整数索引（1,2,3...）` | `位掩码（二进制位组合）` |
| **最大限制** | `最多65535个选项` | `最多64个选项` |
| **查询特点** | `等值查询为主` | `包含查询为主` |
| **应用场景** | `状态、级别、分类` | `标签、权限、属性组合` |

### 1.3 为什么使用ENUM和SET？


**✅ 优势**
```
数据规范性：
• 限制输入值，避免脏数据
• 保证数据一致性

存储效率：
• ENUM：用1-2字节存储，而不是完整字符串
• SET：用位掩码压缩存储多个值

查询性能：
• 内部用数字比较，速度快
• 可以建立高效索引
```

**❌ 缺点**
```
灵活性差：
• 增删选项需要修改表结构
• 不适合经常变化的枚举值

移植性差：
• 不是SQL标准，其他数据库可能不支持
• 与应用程序耦合度高
```

---

## 2. 🔢 ENUM类型详解


### 2.1 ENUM基本语法与使用


**🔸 定义ENUM列**
```sql
-- 基本语法
CREATE TABLE 表名 (
    列名 ENUM('值1', '值2', '值3', ...) [NULL | NOT NULL] [DEFAULT 默认值]
);

-- 实际例子
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(20),
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled') 
           NOT NULL DEFAULT 'pending',
    priority ENUM('low', 'normal', 'high') DEFAULT 'normal'
);
```

**🔸 插入数据**
```sql
-- 正确的插入方式
INSERT INTO orders (order_no, status, priority) VALUES 
('ORD001', 'paid', 'high'),
('ORD002', 'pending', 'normal'),
('ORD003', 'shipped', 'low');

-- 也可以用数字索引（不推荐）
INSERT INTO orders (order_no, status) VALUES 
('ORD004', 1);  -- 1表示第一个值'pending'
```

### 2.2 ENUM内部存储机制


**🔥 数字索引存储原理**
ENUM值在内部是按**数字索引**存储的，不是存储字符串：

```
存储映射表：
ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled')

内部索引映射：
索引 0: NULL值或空字符串（错误值）
索引 1: 'pending'    ← 第1个选项
索引 2: 'paid'       ← 第2个选项  
索引 3: 'shipped'    ← 第3个选项
索引 4: 'completed'  ← 第4个选项
索引 5: 'cancelled'  ← 第5个选项

实际存储：
如果status = 'paid'，实际存储的是数字 2
```

**🔸 存储空间分析**
```
ENUM选项数量与存储字节：
• 1-255个值：   使用 1字节 存储
• 256-65535个值：使用 2字节 存储

例子：
ENUM('A', 'B', 'C')           -- 1字节存储
ENUM('status1', 'status2', ... 'status300')  -- 2字节存储

相比VARCHAR的优势：
VARCHAR(20): 每个值最多20字节
ENUM: 只需1-2字节，节省空间
```

### 2.3 枚举排序规则


**🔸 ENUM排序特点**
ENUM的排序是按**内部索引**排序，不是按字母顺序：

```sql
-- 创建测试表
CREATE TABLE priority_test (
    id INT,
    level ENUM('high', 'medium', 'low')
);

INSERT INTO priority_test VALUES 
(1, 'high'),
(2, 'low'), 
(3, 'medium');

-- 排序查询
SELECT * FROM priority_test ORDER BY level;

结果：
┌─────┬────────┐
│ id  │ level  │
├─────┼────────┤
│  1  │ high   │  ← 索引1，排在第一
│  3  │ medium │  ← 索引2，排在第二  
│  2  │ low    │  ← 索引3，排在第三
└─────┴────────┘

注意：不是按字母顺序！如果要按字母排序：
SELECT * FROM priority_test ORDER BY CAST(level AS CHAR);
```

### 2.4 ENUM最大值数量限制


**🔥 65535个选项限制**
```
理论最大值：65535个枚举选项

实际限制因素：
• MySQL行大小限制（65535字节）
• 所有字符串长度总和不能超过行大小
• 实际可用选项数通常远小于65535

计算示例：
如果每个枚举值平均10个字符
65535字节 ÷ 10字符 ≈ 6500个实际可用选项
```

---

## 3. 📊 SET类型详解


### 3.1 SET基本语法与使用


**🔸 定义SET列**
```sql
-- 基本语法
CREATE TABLE 表名 (
    列名 SET('值1', '值2', '值3', ...) [NULL | NOT NULL] [DEFAULT 默认值]
);

-- 实际例子
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    hobbies SET('reading', 'sports', 'music', 'travel', 'cooking'),
    permissions SET('read', 'write', 'delete', 'admin')
);
```

**🔸 插入数据**
```sql
-- 插入单个值
INSERT INTO users (name, hobbies) VALUES 
('张三', 'reading');

-- 插入多个值（用逗号分隔）
INSERT INTO users (name, hobbies, permissions) VALUES 
('李四', 'reading,sports,music', 'read,write'),
('王五', 'travel,cooking', 'read,delete,admin');

-- 查看插入结果
SELECT * FROM users;
┌─────┬──────┬─────────────────┬─────────────┐
│ id  │ name │ hobbies         │ permissions │
├─────┼──────┼─────────────────┼─────────────┤
│  1  │ 张三 │ reading         │ NULL        │
│  2  │ 李四 │ reading,sports,music │ read,write │
│  3  │ 王五 │ travel,cooking  │ read,delete,admin │
└─────┴──────┴─────────────────┴─────────────┘
```

### 3.2 SET位掩码存储原理


**🔥 位掩码存储机制**
SET类型用**二进制位**来表示每个成员的选择状态：

```
SET('reading', 'sports', 'music', 'travel', 'cooking')

位掩码映射：
position: 1      2       3       4        5
value:   reading sports  music   travel   cooking
bit:     2⁰=1    2¹=2    2²=4    2³=8     2⁴=16

存储示例：
'reading,music' 的存储：
reading: 位置1，值=1
music:   位置3，值=4  
存储值 = 1 + 4 = 5

'sports,travel,cooking' 的存储：
sports:  位置2，值=2
travel:  位置4，值=8
cooking: 位置5，值=16
存储值 = 2 + 8 + 16 = 26
```

**🔸 位运算原理图解**
```
SET('A', 'B', 'C', 'D')

内部位表示：
    D  C  B  A
    ↓  ↓  ↓  ↓
   [0][0][0][0]  = 0  (空集)
   [0][0][0][1]  = 1  (选择A)
   [0][0][1][0]  = 2  (选择B)
   [0][0][1][1]  = 3  (选择A,B)
   [0][1][0][0]  = 4  (选择C)
   [1][1][0][1]  = 13 (选择A,C,D)

查询时用位运算：
SELECT * FROM table WHERE column & 1;    -- 查找包含A的记录
SELECT * FROM table WHERE column & 4;    -- 查找包含C的记录
```

### 3.3 SET最大成员数量限制


**🔥 64个成员限制**
```
理论基础：
SET用一个64位整数存储位掩码
每一位代表一个成员的选择状态
因此最多支持64个成员

存储空间：
• 1-8个成员：  1字节
• 9-16个成员： 2字节  
• 17-24个成员：3字节
• 25-32个成员：4字节
• 33-40个成员：5字节
• 41-48个成员：6字节
• 49-56个成员：7字节
• 57-64个成员：8字节

实际建议：
成员数量不宜过多，通常控制在10个以内
成员过多考虑用关联表设计
```

---

## 4. 🔍 内部存储机制深度分析


### 4.1 枚举集合内部机制对比


**🔸 存储方式对比**

```
ENUM存储机制：
┌─────────────┬─────────────┬─────────────┐
│ 定义值      │ 内部索引    │ 存储字节    │
├─────────────┼─────────────┼─────────────┤
│ 'pending'   │      1      │      1      │
│ 'completed' │      2      │      1      │
│ 'cancelled' │      3      │      1      │
└─────────────┴─────────────┴─────────────┘

SET存储机制：
┌─────────────┬─────────────┬─────────────┐
│ 定义值      │ 位掩码值    │ 存储示例    │
├─────────────┼─────────────┼─────────────┤
│ 'read'      │      1      │ 二进制:0001 │
│ 'write'     │      2      │ 二进制:0010 │
│ 'delete'    │      4      │ 二进制:0100 │
│ 'admin'     │      8      │ 二进制:1000 │
└─────────────┴─────────────┴─────────────┘

组合存储：'read,delete' = 1+4 = 5 = 二进制0101
```

### 4.2 内存与磁盘存储分析


**🔸 存储效率对比**

```
场景：存储用户权限
方案1 - VARCHAR方式：
permissions VARCHAR(100)  -- "read,write,delete,admin"

方案2 - SET方式：  
permissions SET('read','write','delete','admin')

存储对比：
┌─────────────────┬─────────────┬─────────────┐
│ 权限组合        │ VARCHAR存储 │ SET存储     │
├─────────────────┼─────────────┼─────────────┤
│ 'read'          │ 4字节       │ 1字节       │
│ 'read,write'    │ 10字节      │ 1字节       │  
│ 'read,write,delete,admin' │ 23字节 │ 1字节 │
└─────────────────┴─────────────┴─────────────┘

空间节省：SET方式可节省70%-90%存储空间
```

### 4.3 枚举值添加删除影响


**🔥 修改ENUM定义的影响**

**添加枚举值**：
```sql
-- 原定义
status ENUM('pending', 'paid', 'shipped')

-- 在末尾添加（推荐）
ALTER TABLE orders MODIFY status 
ENUM('pending', 'paid', 'shipped', 'completed');

影响分析：
✅ 在末尾添加：对现有数据无影响
❌ 在中间插入：会改变后续值的索引，可能导致数据错乱
```

**删除枚举值**：
```sql
-- 删除'shipped'选项
ALTER TABLE orders MODIFY status 
ENUM('pending', 'paid', 'completed');

影响分析：
⚠️ 风险：现有数据中的'shipped'值会变成空字符串
🔧 解决：删除前先迁移数据

-- 安全删除步骤
UPDATE orders SET status = 'completed' WHERE status = 'shipped';
ALTER TABLE orders MODIFY status ENUM('pending', 'paid', 'completed');
```

**重排枚举值**：
```sql
-- 原顺序：ENUM('low', 'medium', 'high')
-- 新顺序：ENUM('high', 'medium', 'low')

⚠️ 严重影响：
• 所有现有数据的含义都会改变
• 'low'(索引1) 变成 'high'(新索引1)
• 数据完全错乱

建议：永远不要重排枚举值顺序
```

---

## 5. 🔍 查询操作与函数使用


### 5.1 ENUM查询操作


**🔸 基本查询**
```sql
-- 等值查询
SELECT * FROM orders WHERE status = 'paid';
SELECT * FROM orders WHERE status = 2;  -- 用索引查询，结果相同

-- 范围查询（按索引顺序）
SELECT * FROM orders WHERE status < 'shipped';  -- 索引小于3的值

-- IN查询
SELECT * FROM orders WHERE status IN ('paid', 'shipped');

-- NULL查询
SELECT * FROM orders WHERE status IS NULL;
```

**🔸 枚举值的比较规则**
```sql
-- ENUM比较是按内部索引进行的
CREATE TABLE test (
    priority ENUM('low', 'medium', 'high')
);

-- 这些比较的实际含义：
'low' < 'medium'     -- 实际是 1 < 2，返回TRUE
'medium' < 'high'    -- 实际是 2 < 3，返回TRUE  
'high' > 'low'       -- 实际是 3 > 1，返回TRUE

注意：这里的比较不是字母顺序！
```

### 5.2 SET查询操作与FIND_IN_SET函数


**🔸 SET基本查询**
```sql
-- 精确匹配查询
SELECT * FROM users WHERE hobbies = 'reading,sports';

-- 包含查询（使用FIND_IN_SET）
SELECT * FROM users WHERE FIND_IN_SET('reading', hobbies);

-- 查找包含多个值的记录
SELECT * FROM users 
WHERE FIND_IN_SET('reading', hobbies) AND FIND_IN_SET('sports', hobbies);
```

**🔸 FIND_IN_SET函数详解**
```sql
-- 语法：FIND_IN_SET(子字符串, 字符串列表)
-- 返回：子字符串在列表中的位置（从1开始），不存在返回0

示例数据：
hobbies = 'reading,sports,music'

查询示例：
SELECT FIND_IN_SET('sports', 'reading,sports,music');   -- 返回2
SELECT FIND_IN_SET('travel', 'reading,sports,music');   -- 返回0
SELECT FIND_IN_SET('reading', hobbies) FROM users;      -- 对每行检查

实际应用：
-- 查找有运动爱好的用户
SELECT * FROM users WHERE FIND_IN_SET('sports', hobbies) > 0;
```

### 5.3 SET位运算查询


**🔸 位运算查询原理**
SET类型支持高效的**位运算查询**：

```sql
-- 权限表示
permissions SET('read', 'write', 'delete', 'admin')

位值映射：
read:   2^0 = 1   (二进制: 0001)
write:  2^1 = 2   (二进制: 0010)  
delete: 2^2 = 4   (二进制: 0100)
admin:  2^3 = 8   (二进制: 1000)

组合权限：
'read,write' = 1+2 = 3     (二进制: 0011)
'write,admin' = 2+8 = 10   (二进制: 1010)
```

**🔸 位运算查询语法**
```sql
-- 查找包含特定权限的用户
SELECT * FROM users WHERE permissions & 1;      -- 包含read权限
SELECT * FROM users WHERE permissions & 2;      -- 包含write权限
SELECT * FROM users WHERE permissions & 4;      -- 包含delete权限

-- 查找包含多个权限的用户
SELECT * FROM users WHERE (permissions & 3) = 3;  -- 同时有read和write
SELECT * FROM users WHERE (permissions & 5) = 5;  -- 同时有read和delete

-- 查找精确权限组合
SELECT * FROM users WHERE permissions = 'read,write';  -- 只有这两个权限
```

### 5.4 集合值组合查询高级技巧


**🔸 复杂查询示例**
```sql
-- 查找至少有2个爱好的用户
SELECT name, hobbies,
       (BIT_COUNT(CAST(hobbies AS UNSIGNED)) >= 2) AS has_multiple_hobbies
FROM users;

-- 查找某些权限组合的用户  
SELECT * FROM users 
WHERE permissions REGEXP 'read' 
  AND permissions REGEXP 'write'
  AND permissions NOT REGEXP 'admin';

-- 统计每种爱好的用户数量
SELECT 
    SUM(FIND_IN_SET('reading', hobbies) > 0) AS reading_count,
    SUM(FIND_IN_SET('sports', hobbies) > 0) AS sports_count,
    SUM(FIND_IN_SET('music', hobbies) > 0) AS music_count
FROM users;
```

---

## 6. 📈 索引优化策略


### 6.1 枚举集合类型索引优化


**🔸 ENUM索引特点**
```sql
-- ENUM可以正常建立索引
CREATE TABLE orders (
    id INT PRIMARY KEY,
    status ENUM('pending', 'paid', 'shipped', 'completed'),
    INDEX idx_status (status)  -- 为ENUM建立索引
);

索引优势：
✅ 基于数字索引，比较速度快
✅ 索引大小小，内存消耗少
✅ 范围查询效率高

查询性能：
-- 这些查询都能有效使用索引
SELECT * FROM orders WHERE status = 'paid';           -- 等值查询
SELECT * FROM orders WHERE status IN ('paid', 'shipped'); -- IN查询
SELECT * FROM orders WHERE status > 'pending';        -- 范围查询
```

**🔸 SET索引特点**
```sql
-- SET也可以建立索引，但效果有限
CREATE TABLE users (
    id INT PRIMARY KEY,
    permissions SET('read', 'write', 'delete', 'admin'),
    INDEX idx_permissions (permissions)
);

索引局限性：
✅ 精确匹配有效：WHERE permissions = 'read,write'
❌ 包含查询无效：WHERE FIND_IN_SET('read', permissions)
❌ 位运算无效：WHERE permissions & 1

解决方案：
• 使用FIND_IN_SET时无法用索引
• 考虑用关联表设计替代SET
• 或添加辅助的布尔字段
```

### 6.2 索引优化实践


**🔸 ENUM索引优化策略**
```sql
-- 1. 合理排序ENUM值（按使用频率）
status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled')
-- 将最常用的状态放在前面，索引效果更好

-- 2. 复合索引设计
CREATE INDEX idx_status_date ON orders(status, created_date);
-- 状态查询 + 时间范围查询的组合优化

-- 3. 覆盖索引
CREATE INDEX idx_cover ON orders(status, order_no, amount);
-- 避免回表查询，提升性能
```

**🔸 SET查询优化方案**
```sql
-- 方案1：使用辅助字段
ALTER TABLE users ADD COLUMN has_admin_permission BOOLEAN;
UPDATE users SET has_admin_permission = FIND_IN_SET('admin', permissions) > 0;

-- 为布尔字段建索引
CREATE INDEX idx_admin ON users(has_admin_permission);

-- 方案2：使用关联表（推荐）
CREATE TABLE user_permissions (
    user_id INT,
    permission ENUM('read', 'write', 'delete', 'admin'),
    PRIMARY KEY(user_id, permission),
    INDEX idx_permission (permission)
);

-- 查询性能更好
SELECT DISTINCT user_id FROM user_permissions WHERE permission = 'admin';
```

---

## 7. 🔧 维护与最佳实践


### 7.1 类型修改影响分析


**🔸 ENUM修改的风险评估**
```sql
-- 风险级别分类

🟢 低风险操作：
• 在末尾添加新值
• 修改DEFAULT值
• 添加NOT NULL约束

🟡 中风险操作：
• 删除未使用的枚举值
• 重命名枚举值（需要先更新数据）

🔴 高风险操作：
• 删除正在使用的枚举值
• 改变枚举值顺序
• 大幅减少枚举选项

-- 安全修改流程示例
-- 1. 分析影响
SELECT status, COUNT(*) FROM orders GROUP BY status;

-- 2. 数据迁移
UPDATE orders SET status = 'completed' WHERE status = 'delivered';

-- 3. 修改结构
ALTER TABLE orders MODIFY status 
ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled');
```

### 7.2 集合类型NULL值处理


**🔥 NULL值处理机制**

**ENUM的NULL处理**：
```sql
CREATE TABLE test_enum (
    id INT,
    status ENUM('A', 'B', 'C') DEFAULT NULL
);

INSERT INTO test_enum VALUES 
(1, 'A'),
(2, NULL),
(3, '');     -- 空字符串会存储为索引0

查询结果：
┌─────┬────────┐
│ id  │ status │
├─────┼────────┤
│  1  │ A      │
│  2  │ NULL   │
│  3  │        │  ← 空字符串显示为空
└─────┴────────┘

注意：NULL和空字符串是不同的！
```

**SET的NULL处理**：
```sql
CREATE TABLE test_set (
    id INT,
    tags SET('tag1', 'tag2', 'tag3') DEFAULT NULL
);

INSERT INTO test_set VALUES 
(1, 'tag1,tag2'),
(2, NULL),
(3, '');     -- 空字符串表示空集合

查询结果：
┌─────┬───────────┐
│ id  │ tags      │
├─────┼───────────┤
│  1  │ tag1,tag2 │
│  2  │ NULL      │
│  3  │           │  ← 空集合
└─────┴───────────┘

NULL vs 空集合：
• NULL：未设置任何标签
• 空集合：设置了标签列表，但是空的
```

### 7.3 枚举集合维护策略


**🔸 设计阶段策略**
```
1. 选择合适的类型：
   • 状态、分类 → ENUM
   • 标签、权限 → SET（成员少时）
   • 复杂关系 → 关联表

2. 预留扩展空间：
   • ENUM：考虑未来可能的状态
   • SET：成员数控制在合理范围

3. 命名规范：
   • 使用有意义的英文名
   • 保持命名一致性
   • 避免特殊字符
```

**🔸 运维阶段策略**
```sql
-- 1. 定期检查枚举值使用情况
SELECT 
    status,
    COUNT(*) as count,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders) as percentage
FROM orders 
GROUP BY status;

-- 2. 监控无效值
SELECT * FROM orders WHERE status = '';  -- 查找空字符串（无效值）

-- 3. 备份重要修改
-- 修改前先备份表结构和数据
CREATE TABLE orders_backup AS SELECT * FROM orders;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔥 ENUM核心特点：
• 单选机制：只能从预定义选项中选一个
• 数字存储：内部用1-2字节的索引存储
• 排序规则：按索引顺序排序，不是字母顺序
• 最大限制：理论上最多65535个选项

🔥 SET核心特点：
• 多选机制：可以从预定义选项中选择多个
• 位掩码存储：用二进制位表示选择状态
• 位运算查询：支持高效的位运算操作
• 最大限制：最多64个成员

🔑 内部机制理解：
• ENUM：值 → 索引 → 存储（线性映射）
• SET：值组合 → 位掩码 → 存储（位运算映射）
```

### 8.2 查询优化要点


```
🔸 ENUM查询优化：
• 索引效果好：等值、范围、IN查询都高效
• 排序性能佳：按索引排序比字符串快
• 建议：常用查询条件建立复合索引

🔸 SET查询优化：
• FIND_IN_SET：包含查询的标准方法
• 位运算：高效但语法复杂
• 索引局限：包含查询无法有效使用索引
• 建议：复杂查询考虑用关联表替代
```

### 8.3 维护最佳实践


```
🔧 设计原则：
• ENUM适用：状态少、变化少、需要排序
• SET适用：标签少、需要组合查询、位运算
• 关联表适用：选项多、经常变化、复杂查询

⚠️ 修改风险控制：
• 只在末尾添加ENUM值
• 删除前先检查数据影响
• 永远不要改变枚举值顺序
• 重要修改前备份数据

🎯 性能优化：
• 合理利用ENUM的索引优势
• SET复杂查询考虑辅助字段
• 监控查询性能，适时重构
```

### 8.4 实际应用指导


```
📊 选型决策流程：
1. 分析业务需求：单选还是多选？
2. 评估选项数量：是否在合理范围？
3. 考虑变化频率：选项是否经常变化？
4. 评估查询复杂度：查询模式是否复杂？

💡 典型应用场景：
• 订单状态 → ENUM（状态固定，需要排序）
• 用户标签 → SET（标签组合，数量适中）
• 商品分类 → 关联表（层级复杂，经常变化）
• 权限系统 → SET+辅助字段（位运算+索引优化）

🔍 问题诊断：
• 查询慢：检查是否正确使用索引
• 数据异常：检查枚举值修改历史
• 存储浪费：评估是否需要类型优化
```

**核心记忆要点**：
- ENUM单选索引存，SET多选位掩码
- 65535限制ENUM值，SET最多64成员  
- 添加删除要谨慎，顺序改变数据乱
- 查询优化看场景，复杂关系用关联