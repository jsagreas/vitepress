---
title: 8、不可见索引技术
---
## 📚 目录

1. [不可见索引概念](#1-不可见索引概念)
2. [INVISIBLE索引属性详解](#2-INVISIBLE索引属性详解)
3. [索引可见性控制机制](#3-索引可见性控制机制)
4. [optimizer_use_invisible_indexes参数](#4-optimizer_use_invisible_indexes参数)
5. [索引测试与验证策略](#5-索引测试与验证策略)
6. [在线索引管理实践](#6-在线索引管理实践)
7. [索引影响评估与切换](#7-索引影响评估与切换)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 不可见索引概念


### 1.1 什么是不可见索引


**📋 核心定义**
```
不可见索引：索引存在于表中，但查询优化器默认不使用它
本质：索引物理存在，逻辑上对优化器"隐身"
作用：允许安全地测试索引删除的影响
引入版本：MySQL 8.0新特性
```

### 1.2 为什么需要不可见索引


**🤔 传统问题场景**
```
传统索引删除流程：
1. 删除索引 → 性能下降 → 紧急恢复
2. 风险极高，一旦删除就无法快速回滚
3. 大表重建索引耗时极长

生产环境困扰：
• 不确定某个索引是否还有用
• 删除后发现有查询变慢，恢复困难
• 无法安全验证索引的实际价值
```

**💡 不可见索引的解决方案**
```
安全的索引管理流程：
索引创建 → 设为不可见 → 测试性能 → 决定是否可见/删除

优势：
✅ 零风险测试：随时可以切换可见性
✅ 快速回滚：毫秒级恢复索引使用
✅ 渐进式验证：逐步评估索引价值
✅ 生产安全：避免误删重要索引
```

### 1.3 不可见索引工作原理


**🔧 工作机制图示**
```
查询执行流程：

SQL查询
    ↓
查询解析器
    ↓
查询优化器 ←------ 检查索引可见性
    ↓
执行计划生成
    ↓
┌─────────────────────┐
│ 可见索引：正常考虑   │ → 可能被选用
│ 不可见索引：忽略    │ → 不会被选用  
│ (除非特殊参数开启)   │
└─────────────────────┘
```

---

## 2. 📝 INVISIBLE索引属性详解


### 2.1 INVISIBLE属性语法


**🔸 创建不可见索引**
```sql
-- 创建表时指定不可见索引
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100),
    name VARCHAR(50),
    -- 创建不可见索引
    INDEX idx_email (email) INVISIBLE,
    INDEX idx_name (name) INVISIBLE
);

-- 单独创建不可见索引
CREATE INDEX idx_user_email ON users(email) INVISIBLE;

-- 创建复合不可见索引
CREATE INDEX idx_user_info ON users(name, email) INVISIBLE;
```

**🔄 修改索引可见性**
```sql
-- 将可见索引改为不可见
ALTER TABLE users ALTER INDEX idx_email INVISIBLE;

-- 将不可见索引改为可见
ALTER TABLE users ALTER INDEX idx_email VISIBLE;

-- 批量修改多个索引
ALTER TABLE users 
    ALTER INDEX idx_email INVISIBLE,
    ALTER INDEX idx_name VISIBLE;
```

### 2.2 查看索引可见性状态


**🔍 检查索引状态的方法**
```sql
-- 方法1：查看表的所有索引
SHOW INDEX FROM users;
-- 注意看 Visible 列：YES=可见，NO=不可见

-- 方法2：通过information_schema查询
SELECT 
    INDEX_NAME,
    COLUMN_NAME,
    IS_VISIBLE
FROM information_schema.STATISTICS 
WHERE TABLE_NAME = 'users' 
    AND TABLE_SCHEMA = DATABASE();

-- 方法3：查看建表语句
SHOW CREATE TABLE users;
```

**📊 索引状态示例输出**
```
+-------+----------+----------+---------+
| Table | Key_name | Column   | Visible |
+-------+----------+----------+---------+
| users | PRIMARY  | id       | YES     |
| users | idx_email| email    | NO      |  ← 不可见索引
| users | idx_name | name     | YES     |  ← 可见索引
+-------+----------+----------+---------+
```

### 2.3 不可见索引的限制条件


**⚠️ 重要限制**
```sql
-- 主键不能设为不可见
CREATE TABLE test (
    id INT PRIMARY KEY INVISIBLE  -- ❌ 错误！主键必须可见
);

-- 唯一索引可以设为不可见
CREATE TABLE test (
    id INT PRIMARY KEY,
    email VARCHAR(100),
    UNIQUE INDEX uk_email (email) INVISIBLE  -- ✅ 正确
);
```

**📋 限制规则总结**
```
✅ 可以设为不可见：
• 普通索引 (INDEX)
• 唯一索引 (UNIQUE INDEX) 
• 复合索引
• 外键相关索引

❌ 不能设为不可见：
• 主键索引 (PRIMARY KEY)
• 自动创建的外键约束索引(在某些情况下)
```

---

## 3. ⚙️ 索引可见性控制机制


### 3.1 可见性继承规则


**🔗 索引可见性继承机制**
```sql
-- 父表索引设置
CREATE TABLE parent_table (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    INDEX idx_parent_name (name) INVISIBLE
);

-- 子表会继承父表的索引定义
CREATE TABLE child_table (
    id INT PRIMARY KEY,
    parent_id INT,
    child_name VARCHAR(50),
    -- 继承时保持相同的可见性设置
    INDEX idx_child_name (child_name) INVISIBLE,
    FOREIGN KEY (parent_id) REFERENCES parent_table(id)
);
```

### 3.2 索引元数据管理


**📊 索引元数据查询**
```sql
-- 查询所有不可见索引
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME
FROM information_schema.STATISTICS 
WHERE IS_VISIBLE = 'NO'
    AND TABLE_SCHEMA = DATABASE()
ORDER BY TABLE_NAME, INDEX_NAME;

-- 统计各表的不可见索引数量
SELECT 
    TABLE_NAME,
    COUNT(*) as invisible_index_count
FROM information_schema.STATISTICS 
WHERE IS_VISIBLE = 'NO' 
    AND TABLE_SCHEMA = DATABASE()
GROUP BY TABLE_NAME;
```

**🗃️ 索引使用统计查询**
```sql
-- 查看索引使用情况
SELECT 
    s.TABLE_NAME,
    s.INDEX_NAME,
    s.IS_VISIBLE,
    COALESCE(t.COUNT_FETCH, 0) as usage_count
FROM information_schema.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage t
    ON s.TABLE_SCHEMA = t.OBJECT_SCHEMA 
    AND s.TABLE_NAME = t.OBJECT_NAME
    AND s.INDEX_NAME = t.INDEX_NAME
WHERE s.TABLE_SCHEMA = DATABASE()
ORDER BY usage_count DESC;
```

---

## 4. 🔧 optimizer_use_invisible_indexes参数


### 4.1 参数作用与控制


**📋 参数定义**
```sql
-- 查看当前设置
SHOW VARIABLES LIKE 'optimizer_use_invisible_indexes';

-- 参数含义：
-- ON：优化器会考虑不可见索引
-- OFF（默认）：优化器忽略不可见索引
```

**🎯 参数使用场景**
```sql
-- 场景1：临时测试不可见索引效果
SET SESSION optimizer_use_invisible_indexes = ON;

-- 执行测试查询，观察是否使用不可见索引
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- 测试完成后恢复默认设置
SET SESSION optimizer_use_invisible_indexes = OFF;
```

### 4.2 全局vs会话级设置


**⚡ 设置级别对比**
```sql
-- 会话级设置（推荐测试时使用）
SET SESSION optimizer_use_invisible_indexes = ON;
-- 只影响当前连接，安全性高

-- 全局级设置（谨慎使用）
SET GLOBAL optimizer_use_invisible_indexes = ON;
-- 影响所有新连接，风险较大

-- 永久配置（修改my.cnf）
[mysqld]
optimizer_use_invisible_indexes = ON
```

**📊 不同设置的影响范围**
```
设置级别        影响范围            生效时间        推荐场景
会话级         当前连接             立即          索引测试
全局级         新建连接             立即          特殊调试  
配置文件       所有连接             重启后        极少使用
```

### 4.3 参数测试实例


**🔬 完整测试流程**
```sql
-- 1. 准备测试数据
CREATE TABLE test_table (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100),
    name VARCHAR(50)
);

-- 插入测试数据
INSERT INTO test_table (email, name) VALUES 
('user1@test.com', 'User1'),
('user2@test.com', 'User2'),
('user3@test.com', 'User3');

-- 2. 创建不可见索引
CREATE INDEX idx_email ON test_table(email) INVISIBLE;

-- 3. 默认情况下测试（不使用不可见索引）
EXPLAIN SELECT * FROM test_table WHERE email = 'user1@test.com';
-- 应该显示全表扫描

-- 4. 开启参数后测试
SET SESSION optimizer_use_invisible_indexes = ON;
EXPLAIN SELECT * FROM test_table WHERE email = 'user1@test.com';
-- 应该显示使用idx_email索引

-- 5. 恢复默认设置
SET SESSION optimizer_use_invisible_indexes = OFF;
```

---

## 5. 🧪 索引测试与验证策略


### 5.1 索引A/B测试方法


**🔀 A/B测试完整流程**
```sql
-- Phase A：记录原始性能
-- 1. 执行基准测试
SELECT SQL_NO_CACHE COUNT(*) 
FROM large_table 
WHERE status = 'active' 
    AND created_date >= '2024-01-01';

-- 2. 记录执行时间和资源消耗
SHOW PROFILES;

-- Phase B：测试新索引效果  
-- 1. 创建不可见索引
CREATE INDEX idx_status_date ON large_table(status, created_date) INVISIBLE;

-- 2. 临时启用不可见索引
SET SESSION optimizer_use_invisible_indexes = ON;

-- 3. 执行相同查询测试
SELECT SQL_NO_CACHE COUNT(*) 
FROM large_table 
WHERE status = 'active' 
    AND created_date >= '2024-01-01';

-- 4. 对比性能差异
SHOW PROFILES;

-- 5. 决策：如果性能提升显著，则设为可见
ALTER TABLE large_table ALTER INDEX idx_status_date VISIBLE;
```

### 5.2 渐进式索引删除策略


**📉 安全删除索引的步骤**
```sql
-- 步骤1：将可见索引改为不可见
ALTER TABLE users ALTER INDEX idx_old_column INVISIBLE;

-- 步骤2：观察期（建议1-7天）
-- 监控慢查询日志，观察是否有性能下降

-- 步骤3：检查慢查询
SELECT 
    query_time,
    sql_text 
FROM mysql.slow_log 
WHERE start_time > DATE_SUB(NOW(), INTERVAL 24 HOUR)
    AND sql_text LIKE '%users%'
ORDER BY query_time DESC;

-- 步骤4：做出决策
-- 如果无性能问题，则真正删除
DROP INDEX idx_old_column ON users;
-- 如果发现问题，快速恢复
-- ALTER TABLE users ALTER INDEX idx_old_column VISIBLE;
```

### 5.3 索引影响评估方法


**📈 性能评估指标**
```sql
-- 评估指标1：查询执行时间对比
-- 创建测试存储过程
DELIMITER //
CREATE PROCEDURE test_index_performance()
BEGIN
    DECLARE before_time TIMESTAMP DEFAULT NOW(6);
    DECLARE after_time TIMESTAMP DEFAULT NOW(6);
    
    -- 测试查询
    SELECT COUNT(*) FROM users WHERE email LIKE 'test%';
    
    SET after_time = NOW(6);
    
    SELECT TIMESTAMPDIFF(MICROSECOND, before_time, after_time) AS execution_microseconds;
END //
DELIMITER ;

-- 评估指标2：检查执行计划差异
EXPLAIN FORMAT=JSON 
SELECT * FROM users WHERE email = 'test@example.com';
```

**📊 索引使用统计分析**
```sql
-- 查询最近的索引使用情况
SELECT 
    OBJECT_NAME as table_name,
    INDEX_NAME,
    COUNT_FETCH as select_operations,
    COUNT_INSERT as insert_operations,
    COUNT_UPDATE as update_operations,
    COUNT_DELETE as delete_operations
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = DATABASE()
    AND COUNT_FETCH > 0
ORDER BY COUNT_FETCH DESC;
```

---

## 6. 🛠️ 在线索引管理实践


### 6.1 在线索引切换策略


**🔄 零停机索引切换**
```sql
-- 策略1：渐进式切换
-- 第1步：创建新索引（不可见）
CREATE INDEX idx_users_new ON users(name, email) INVISIBLE;

-- 第2步：等待索引构建完成（大表需要时间）
-- 可以通过以下命令查看进度：
SHOW PROCESSLIST;

-- 第3步：快速切换（毫秒级操作）
ALTER TABLE users 
    ALTER INDEX idx_users_old INVISIBLE,
    ALTER INDEX idx_users_new VISIBLE;

-- 第4步：观察期后清理旧索引
-- DROP INDEX idx_users_old ON users;
```

**⚡ 索引切换最佳实践**
```sql
-- 实践1：批量操作减少锁时间
ALTER TABLE large_table
    ALTER INDEX idx_old1 INVISIBLE,
    ALTER INDEX idx_old2 INVISIBLE,
    ALTER INDEX idx_new1 VISIBLE,
    ALTER INDEX idx_new2 VISIBLE;

-- 实践2：使用事务确保原子性
START TRANSACTION;
ALTER TABLE users ALTER INDEX idx_email INVISIBLE;
-- 如果发现问题，可以立即回滚
-- ROLLBACK;
COMMIT;
```

### 6.2 索引版本管理


**📝 索引命名规范**
```sql
-- 建议的索引命名约定
CREATE INDEX idx_users_email_v1 ON users(email) INVISIBLE;
CREATE INDEX idx_users_email_v2 ON users(email, status) INVISIBLE;

-- 通过版本号管理索引演进
-- v1: 单列索引
-- v2: 复合索引优化
-- v3: 包含更多覆盖列的索引

-- 切换时保持版本追踪
ALTER TABLE users 
    ALTER INDEX idx_users_email_v1 INVISIBLE,
    ALTER INDEX idx_users_email_v2 VISIBLE;
```

### 6.3 索引监控与告警


**📊 建立索引监控体系**
```sql
-- 创建监控视图
CREATE VIEW v_index_visibility_monitor AS
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    IS_VISIBLE,
    CREATED_TIME,
    LAST_UPDATE_TIME
FROM information_schema.STATISTICS s
LEFT JOIN information_schema.TABLES t 
    ON s.TABLE_SCHEMA = t.TABLE_SCHEMA 
    AND s.TABLE_NAME = t.TABLE_NAME
WHERE s.TABLE_SCHEMA = DATABASE();

-- 定期检查不可见索引状态
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    GROUP_CONCAT(COLUMN_NAME) as columns,
    'INVISIBLE' as status
FROM v_index_visibility_monitor
WHERE IS_VISIBLE = 'NO'
GROUP BY TABLE_NAME, INDEX_NAME;
```

---

## 7. 📊 索引影响评估与切换


### 7.1 性能基准测试


**🎯 建立性能基准**
```sql
-- 测试脚本：索引性能对比
DELIMITER //
CREATE PROCEDURE benchmark_index_impact(
    IN table_name VARCHAR(64),
    IN index_name VARCHAR(64),
    IN test_query TEXT
)
BEGIN
    DECLARE before_time BIGINT;
    DECLARE after_time BIGINT;
    DECLARE with_index_time BIGINT;
    DECLARE without_index_time BIGINT;
    
    -- 测试无索引性能
    SET @sql = CONCAT('ALTER TABLE ', table_name, ' ALTER INDEX ', index_name, ' INVISIBLE');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    
    SET before_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    SET @test_sql = test_query;
    PREPARE test_stmt FROM @test_sql;
    EXECUTE test_stmt;
    SET after_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    SET without_index_time = after_time - before_time;
    
    -- 测试有索引性能
    SET @sql = CONCAT('ALTER TABLE ', table_name, ' ALTER INDEX ', index_name, ' VISIBLE');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    
    SET before_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    EXECUTE test_stmt;
    SET after_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    SET with_index_time = after_time - before_time;
    
    -- 输出结果
    SELECT 
        table_name,
        index_name,
        without_index_time as time_without_index_us,
        with_index_time as time_with_index_us,
        ROUND((without_index_time - with_index_time) / without_index_time * 100, 2) as improvement_percentage;
        
    DEALLOCATE PREPARE stmt;
    DEALLOCATE PREPARE test_stmt;
END //
DELIMITER ;
```

### 7.2 索引ROI分析


**💰 投资回报率计算**
```sql
-- 索引成本效益分析
SELECT 
    t.TABLE_NAME,
    s.INDEX_NAME,
    -- 索引大小成本
    ROUND(
        (s.CARDINALITY * t.AVG_ROW_LENGTH * 
         (SELECT COUNT(*) FROM information_schema.STATISTICS 
          WHERE INDEX_NAME = s.INDEX_NAME AND TABLE_NAME = s.TABLE_NAME)
        ) / 1024 / 1024, 2
    ) as index_size_mb,
    -- 使用频率效益
    COALESCE(u.COUNT_FETCH, 0) as usage_count,
    -- ROI计算
    CASE 
        WHEN COALESCE(u.COUNT_FETCH, 0) = 0 THEN 'LOW_VALUE'
        WHEN COALESCE(u.COUNT_FETCH, 0) > 1000 THEN 'HIGH_VALUE'
        ELSE 'MEDIUM_VALUE'
    END as roi_level
FROM information_schema.STATISTICS s
JOIN information_schema.TABLES t 
    ON s.TABLE_SCHEMA = t.TABLE_SCHEMA AND s.TABLE_NAME = t.TABLE_NAME
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
    ON s.TABLE_SCHEMA = u.OBJECT_SCHEMA 
    AND s.TABLE_NAME = u.OBJECT_NAME
    AND s.INDEX_NAME = u.INDEX_NAME
WHERE s.TABLE_SCHEMA = DATABASE()
    AND s.INDEX_NAME != 'PRIMARY'
GROUP BY s.TABLE_NAME, s.INDEX_NAME;
```

### 7.3 自动化索引管理


**🤖 自动索引优化建议**
```sql
-- 创建自动化索引建议系统
CREATE VIEW v_index_optimization_suggestions AS
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    IS_VISIBLE,
    COALESCE(usage_stats.COUNT_FETCH, 0) as usage_count,
    CASE 
        -- 不可见索引长期未使用建议删除
        WHEN IS_VISIBLE = 'NO' AND COALESCE(usage_stats.COUNT_FETCH, 0) = 0 
        THEN 'CONSIDER_DROP'
        -- 不可见索引有使用建议设为可见
        WHEN IS_VISIBLE = 'NO' AND COALESCE(usage_stats.COUNT_FETCH, 0) > 100
        THEN 'MAKE_VISIBLE'
        -- 可见索引从未使用建议设为不可见
        WHEN IS_VISIBLE = 'YES' AND COALESCE(usage_stats.COUNT_FETCH, 0) = 0
        THEN 'MAKE_INVISIBLE'
        ELSE 'NO_ACTION'
    END as suggestion
FROM information_schema.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage usage_stats
    ON s.TABLE_SCHEMA = usage_stats.OBJECT_SCHEMA
    AND s.TABLE_NAME = usage_stats.OBJECT_NAME  
    AND s.INDEX_NAME = usage_stats.INDEX_NAME
WHERE s.TABLE_SCHEMA = DATABASE()
    AND s.INDEX_NAME != 'PRIMARY'
GROUP BY s.TABLE_NAME, s.INDEX_NAME, s.IS_VISIBLE;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 不可见索引本质：物理存在，逻辑隐藏的索引管理机制
🔸 INVISIBLE属性：控制索引对查询优化器的可见性
🔸 optimizer_use_invisible_indexes：临时启用不可见索引的开关
🔸 安全测试：零风险验证索引价值的最佳实践
🔸 渐进式管理：从创建到删除的完整索引生命周期控制
```

### 8.2 关键理解要点


**🔹 不可见索引的核心价值**
```
安全性：
- 消除删除索引的风险
- 提供快速回滚能力
- 允许渐进式索引优化

可测试性：
- A/B测试索引效果
- 量化索引性能收益
- 验证索引必要性

可维护性：
- 在线索引管理
- 版本化索引演进
- 自动化优化建议
```

**🔹 最佳实践原则**
```
创建原则：
✅ 新索引先设为不可见，测试后再可见
✅ 使用版本号管理索引演进
✅ 建立索引监控和告警机制

测试原则：
✅ 会话级启用optimizer_use_invisible_indexes
✅ 建立性能基准对比
✅ 设置观察期评估影响

删除原则：
✅ 先设为不可见观察一段时间
✅ 确认无性能影响后再删除
✅ 保持索引元数据记录
```

### 8.3 实际应用价值


**🎯 生产环境应用**
- **索引重构**：安全重建和优化现有索引结构
- **性能调优**：验证新索引对查询性能的实际影响
- **容量管理**：识别和清理无用索引，节省存储空间
- **风险控制**：消除索引操作对生产系统的潜在风险

**🔧 运维最佳实践**
- **建立流程**：制定标准的索引管理流程
- **自动化监控**：定期分析索引使用情况和性能指标
- **团队协作**：通过不可见索引支持多人协作的索引优化
- **知识积累**：记录索引优化的历史决策和效果数据

**核心记忆**：
- 不可见索引是MySQL 8.0的安全索引管理利器
- "先隐藏，再测试，后决定"的三步式索引管理法
- optimizer_use_invisible_indexes是临时测试的关键开关
- 渐进式索引管理消除生产风险，提升DBA工作效率