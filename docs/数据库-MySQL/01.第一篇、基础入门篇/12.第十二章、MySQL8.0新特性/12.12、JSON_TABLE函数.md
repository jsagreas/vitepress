---
title: 12、JSON_TABLE函数
---
## 📚 目录

1. [JSON_TABLE函数概述](#1-JSON_TABLE函数概述)
2. [基本语法结构](#2-基本语法结构)
3. [路径表达式详解](#3-路径表达式详解)
4. [COLUMNS子句定义](#4-COLUMNS子句定义)
5. [嵌套JSON处理](#5-嵌套JSON处理)
6. [序号与排序功能](#6-序号与排序功能)
7. [性能优化策略](#7-性能优化策略)
8. [实际应用场景](#8-实际应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 JSON_TABLE函数概述


### 1.1 什么是JSON_TABLE


**简单理解**：JSON_TABLE就像一个"翻译器"，把JSON数据翻译成我们熟悉的表格形式。

```
原本的JSON数据（看起来像一团文字）：
{"name":"张三","age":25,"skills":["Java","Python"]}

通过JSON_TABLE变成表格：
┌──────┬─────┬─────────┐
│ name │ age │ skill   │
├──────┼─────┼─────────┤
│ 张三  │ 25  │ Java    │
│ 张三  │ 25  │ Python  │
└──────┴─────┴─────────┘
```

### 1.2 为什么需要JSON_TABLE


**实际问题**：JSON数据虽然灵活，但查询起来很麻烦

```sql
-- 传统方式查询JSON（复杂难懂）
SELECT JSON_EXTRACT(data, '$.name') as name,
       JSON_EXTRACT(data, '$.age') as age
FROM users;

-- 使用JSON_TABLE（直观简单）
SELECT name, age, skill
FROM users,
JSON_TABLE(data, '$' COLUMNS (
    name VARCHAR(50) PATH '$.name',
    age INT PATH '$.age',
    skill VARCHAR(50) PATH '$.skills[*]'
)) as jt;
```

### 1.3 核心作用


**🔸 数据扁平化**：把嵌套的JSON结构展开成平面表格
**🔸 类型转换**：JSON字符串自动转换为具体的数据类型  
**🔸 数组展开**：JSON数组中的每个元素变成单独的行
**🔸 标准查询**：可以用普通的SQL语句进行查询和分析

---

## 2. 📝 基本语法结构


### 2.1 语法框架


```sql
JSON_TABLE(
    json_data,           -- JSON数据源
    path_expression      -- 根路径表达式
    COLUMNS (            -- 列定义
        column_definition1,
        column_definition2,
        ...
    )
)
```

### 2.2 最简单的例子


```sql
-- 示例数据
SET @json = '{"name":"李四","age":30,"city":"北京"}';

-- 基本用法
SELECT *
FROM JSON_TABLE(@json, '$' COLUMNS (
    name VARCHAR(50) PATH '$.name',
    age INT PATH '$.age',
    city VARCHAR(50) PATH '$.city'
)) AS person;

-- 结果：
-- name  age  city
-- 李四   30   北京
```

### 2.3 语法组成部分


**JSON数据源**：
- 可以是JSON字符串
- 可以是表中的JSON列
- 可以是返回JSON的表达式

**路径表达式**：
- 通常以`$`开头，表示JSON根节点
- 指定从哪个位置开始解析

**COLUMNS子句**：
- 定义输出表格的列结构
- 指定每列的名称、类型和取值路径

---

## 3. 🗺️ 路径表达式详解


### 3.1 路径表达式基础


**`$`符号**：代表JSON数据的根节点，就像文件系统中的根目录`/`

```
JSON数据结构：          路径表达式：
{                      $ （根节点）
  "user": {            $.user （user对象）
    "name": "张三",     $.user.name （name字段）
    "info": {          $.user.info （info对象）
      "age": 25        $.user.info.age （age字段）
    }
  }
}
```

### 3.2 常用路径模式


```sql
-- 示例JSON数据
SET @json = '{
  "user": {
    "name": "王五",
    "age": 28,
    "hobbies": ["读书", "游戏", "运动"],
    "address": {
      "city": "上海",
      "district": "浦东"
    }
  }
}';

-- 不同路径的使用
SELECT *
FROM JSON_TABLE(@json, '$.user' COLUMNS (
    name VARCHAR(50) PATH '$.name',          -- 直接字段
    age INT PATH '$.age',                    -- 数字字段  
    city VARCHAR(50) PATH '$.address.city', -- 嵌套字段
    hobby VARCHAR(50) PATH '$.hobbies[*]'   -- 数组展开
)) AS user_info;
```

### 3.3 数组路径处理


```sql
-- 数组元素访问
$.hobbies[0]    -- 第一个爱好
$.hobbies[1]    -- 第二个爱好  
$.hobbies[*]    -- 所有爱好（每个变成一行）
$.hobbies[last] -- 最后一个爱好
```

**数组展开示例**：
```sql
SET @json = '{"name":"赵六","skills":["HTML","CSS","JavaScript"]}';

SELECT *
FROM JSON_TABLE(@json, '$' COLUMNS (
    name VARCHAR(50) PATH '$.name',
    skill VARCHAR(50) PATH '$.skills[*]'
)) AS skills;

-- 结果：
-- name  skill
-- 赵六   HTML
-- 赵六   CSS  
-- 赵六   JavaScript
```

---

## 4. 🏗️ COLUMNS子句定义


### 4.1 列定义语法


```sql
column_name data_type PATH json_path [options]
```

**参数说明**：
- `column_name`：输出表中的列名
- `data_type`：数据类型（VARCHAR、INT、JSON等）
- `PATH json_path`：JSON中对应数据的路径
- `options`：可选的额外设置

### 4.2 数据类型转换


```sql
-- 各种数据类型示例
SET @json = '{
  "id": 1001,
  "name": "产品A", 
  "price": 99.99,
  "available": true,
  "tags": ["新品", "热销"],
  "created": "2024-01-15"
}';

SELECT *
FROM JSON_TABLE(@json, '$' COLUMNS (
    id INT PATH '$.id',                           -- 整数
    name VARCHAR(100) PATH '$.name',              -- 字符串
    price DECIMAL(10,2) PATH '$.price',           -- 小数
    available BOOLEAN PATH '$.available',         -- 布尔值
    tag VARCHAR(50) PATH '$.tags[*]',            -- 数组元素
    created_date DATE PATH '$.created'            -- 日期
)) AS product;
```

### 4.3 默认值处理


```sql
-- 处理缺失字段
SET @json = '{"name":"测试","age":25}'; -- 注意：没有city字段

SELECT *
FROM JSON_TABLE(@json, '$' COLUMNS (
    name VARCHAR(50) PATH '$.name',
    age INT PATH '$.age',
    city VARCHAR(50) PATH '$.city' DEFAULT '未知'  -- 设置默认值
)) AS info;

-- 结果：
-- name  age  city
-- 测试   25   未知
```

### 4.4 错误处理选项


```sql
-- 错误处理策略
COLUMNS (
    id INT PATH '$.id',
    -- 遇到错误时返回NULL
    invalid_field VARCHAR(50) PATH '$.not_exist' NULL ON ERROR,
    -- 遇到空值时使用默认值
    optional_field VARCHAR(50) PATH '$.optional' DEFAULT 'N/A' ON EMPTY
)
```

---

## 5. 🌳 嵌套JSON处理


### 5.1 多层嵌套解析


```sql
-- 复杂嵌套JSON示例
SET @json = '{
  "order": {
    "id": "ORD001",
    "customer": {
      "name": "客户A",
      "contact": {
        "phone": "13800138000",
        "email": "test@example.com"
      }
    },
    "items": [
      {"name": "商品1", "quantity": 2, "price": 50.00},
      {"name": "商品2", "quantity": 1, "price": 100.00}
    ]
  }
}';

-- 解析嵌套结构
SELECT *
FROM JSON_TABLE(@json, '$.order' COLUMNS (
    order_id VARCHAR(50) PATH '$.id',
    customer_name VARCHAR(100) PATH '$.customer.name',
    phone VARCHAR(20) PATH '$.customer.contact.phone',
    email VARCHAR(100) PATH '$.customer.contact.email'
)) AS order_info;
```

### 5.2 嵌套数组处理


```sql
-- 处理订单商品（嵌套数组）
SELECT *
FROM JSON_TABLE(@json, '$.order.items[*]' COLUMNS (
    item_name VARCHAR(100) PATH '$.name',
    quantity INT PATH '$.quantity', 
    price DECIMAL(10,2) PATH '$.price',
    total_price DECIMAL(10,2) PATH '$.quantity * $.price'  -- 计算字段
)) AS order_items;

-- 结果：
-- item_name  quantity  price   total_price
-- 商品1       2        50.00   100.00
-- 商品2       1        100.00  100.00
```

### 5.3 嵌套路径的逐级访问


```
JSON层级结构：                路径访问方式：
{                            $                   (根)
  "company": {               $.company          (公司对象)
    "name": "科技公司",       $.company.name     (公司名称)
    "departments": [         $.company.departments (部门数组)
      {                      $.company.departments[*] (所有部门)
        "name": "研发部",     $.company.departments[*].name (部门名)
        "employees": [       $.company.departments[*].employees[*] (所有员工)
          {
            "name": "张三"   $.company.departments[*].employees[*].name
          }
        ]
      }
    ]
  }
}
```

---

## 6. 🔢 序号与排序功能


### 6.1 FOR ORDINALITY序号


**作用**：为展开的数据自动添加行号，特别适合数组数据

```sql
-- 示例数据
SET @json = '{
  "student": "小明",
  "subjects": ["数学", "英语", "物理", "化学"]
}';

-- 添加序号
SELECT *
FROM JSON_TABLE(@json, '$' COLUMNS (
    student VARCHAR(50) PATH '$.student',
    subject_no FOR ORDINALITY,                    -- 自动序号
    subject VARCHAR(50) PATH '$.subjects[*]'      -- 科目
)) AS student_subjects;

-- 结果：
-- student  subject_no  subject
-- 小明      1          数学
-- 小明      2          英语
-- 小明      3          物理
-- 小明      4          化学
```

### 6.2 序号的实际应用


```sql
-- 商品排行榜示例
SET @json = '{
  "top_products": [
    {"name": "iPhone15", "sales": 1000},
    {"name": "小米14", "sales": 800}, 
    {"name": "华为P60", "sales": 600}
  ]
}';

SELECT *
FROM JSON_TABLE(@json, '$.top_products[*]' COLUMNS (
    ranking FOR ORDINALITY,                       -- 排名
    product_name VARCHAR(100) PATH '$.name',      -- 产品名
    sales_count INT PATH '$.sales'                -- 销量
)) AS product_ranking;

-- 结果：
-- ranking  product_name  sales_count
-- 1        iPhone15      1000
-- 2        小米14        800
-- 3        华为P60       600
```

### 6.3 序号与筛选结合


```sql
-- 获取前3名的数据
SELECT *
FROM JSON_TABLE(@json, '$.top_products[*]' COLUMNS (
    ranking FOR ORDINALITY,
    product_name VARCHAR(100) PATH '$.name',
    sales_count INT PATH '$.sales'
)) AS jt
WHERE ranking <= 3;  -- 只要前3名
```

---

## 7. ⚡ 性能优化策略


### 7.1 JSON_TABLE优化器


**MySQL优化器会自动**：
- 分析JSON_TABLE的使用模式
- 选择最佳的执行计划
- 利用可用的索引

```sql
-- 优化器友好的写法
SELECT jt.name, jt.age
FROM users u,
JSON_TABLE(u.profile, '$' COLUMNS (
    name VARCHAR(50) PATH '$.name',
    age INT PATH '$.age'
)) AS jt
WHERE jt.age > 25;  -- 条件尽量放在外层
```

### 7.2 索引利用策略


```sql
-- 为JSON列创建函数索引
CREATE INDEX idx_user_age 
ON users ((JSON_EXTRACT(profile, '$.age')));

-- 为常用路径创建生成列
ALTER TABLE users 
ADD COLUMN user_age INT AS (JSON_EXTRACT(profile, '$.age')) STORED;

-- 为生成列创建索引
CREATE INDEX idx_generated_age ON users(user_age);
```

### 7.3 内存管理优化


**最佳实践**：
```sql
-- ✅ 推荐：只选择需要的列
SELECT jt.name, jt.email
FROM users,
JSON_TABLE(profile, '$' COLUMNS (
    name VARCHAR(50) PATH '$.name',
    email VARCHAR(100) PATH '$.email'
)) AS jt;

-- ❌ 避免：选择所有列
SELECT *
FROM users,
JSON_TABLE(profile, '$' COLUMNS (
    name VARCHAR(50) PATH '$.name',
    age INT PATH '$.age',
    city VARCHAR(50) PATH '$.city',
    -- ... 很多不需要的列
)) AS jt;
```

### 7.4 复杂查询优化


```sql
-- 分步处理复杂JSON
-- 第一步：提取基本信息
WITH basic_info AS (
    SELECT u.id,
           jt.name,
           jt.age
    FROM users u,
    JSON_TABLE(u.profile, '$' COLUMNS (
        name VARCHAR(50) PATH '$.name',
        age INT PATH '$.age'
    )) AS jt
    WHERE jt.age BETWEEN 25 AND 35
)

-- 第二步：关联其他数据
SELECT bi.name, bi.age, o.order_count
FROM basic_info bi
LEFT JOIN order_summary o ON bi.id = o.user_id;
```

---

## 8. 🎯 实际应用场景


### 8.1 用户配置文件分析


```sql
-- 用户表结构
CREATE TABLE user_profiles (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    settings JSON  -- 存储用户设置
);

-- 示例数据
INSERT INTO user_profiles VALUES 
(1, 'user1', '{"theme":"dark","language":"zh","notifications":{"email":true,"sms":false}}'),
(2, 'user2', '{"theme":"light","language":"en","notifications":{"email":false,"sms":true}}');

-- 分析用户偏好
SELECT 
    username,
    theme,
    language,
    email_notify,
    sms_notify
FROM user_profiles,
JSON_TABLE(settings, '$' COLUMNS (
    theme VARCHAR(20) PATH '$.theme',
    language VARCHAR(10) PATH '$.language', 
    email_notify BOOLEAN PATH '$.notifications.email',
    sms_notify BOOLEAN PATH '$.notifications.sms'
)) AS prefs;
```

### 8.2 商品属性查询


```sql
-- 商品表
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    attributes JSON  -- 动态属性
);

-- 查询特定属性的商品
SELECT 
    p.name,
    attrs.color,
    attrs.size,
    attrs.material
FROM products p,
JSON_TABLE(p.attributes, '$' COLUMNS (
    color VARCHAR(50) PATH '$.color',
    size VARCHAR(20) PATH '$.size',
    material VARCHAR(50) PATH '$.material'
)) AS attrs
WHERE attrs.color = '红色' 
  AND attrs.size IN ('M', 'L');
```

### 8.3 日志数据分析


```sql
-- 应用日志表
CREATE TABLE app_logs (
    id INT PRIMARY KEY,
    created_at TIMESTAMP,
    log_data JSON
);

-- 错误日志分析
SELECT 
    DATE(created_at) as log_date,
    log_info.level,
    log_info.message,
    COUNT(*) as error_count
FROM app_logs,
JSON_TABLE(log_data, '$' COLUMNS (
    level VARCHAR(20) PATH '$.level',
    message TEXT PATH '$.message',
    error_code INT PATH '$.error_code'
)) AS log_info
WHERE log_info.level = 'ERROR'
GROUP BY DATE(created_at), log_info.level, log_info.message
ORDER BY log_date DESC, error_count DESC;
```

### 8.4 API响应数据处理


```sql
-- API调用结果表
CREATE TABLE api_responses (
    id INT PRIMARY KEY,
    api_name VARCHAR(100),
    response_data JSON,
    created_at TIMESTAMP
);

-- 解析API返回的分页数据
SELECT 
    api_name,
    response_info.total_count,
    response_info.page_size,
    item_info.item_id,
    item_info.item_name
FROM api_responses ar,
JSON_TABLE(ar.response_data, '$' COLUMNS (
    total_count INT PATH '$.pagination.total',
    page_size INT PATH '$.pagination.page_size',
    NESTED PATH '$.data[*]' COLUMNS (
        item_id INT PATH '$.id',
        item_name VARCHAR(100) PATH '$.name'
    )
)) AS response_info;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 JSON_TABLE本质：JSON数据转换为关系表的工具
🔸 路径表达式：用$开头的路径指定JSON数据位置
🔸 COLUMNS定义：指定输出列的名称、类型和数据源路径  
🔸 数组展开：使用[*]将JSON数组元素展开为多行
🔸 嵌套处理：通过多层路径访问深层嵌套数据
🔸 序号功能：FOR ORDINALITY自动添加行号
```

### 9.2 关键理解要点


**🔹 路径表达式的逻辑**
```
把JSON想象成文件夹结构：
$ = 根目录
$.user = user文件夹  
$.user.name = user文件夹下的name文件
$.hobbies[*] = hobbies文件夹下的所有文件
```

**🔹 数组展开的机制**
```
原始：{"skills":["Java","Python","Go"]}
展开后：
Row1: skill = "Java"
Row2: skill = "Python"  
Row3: skill = "Go"
```

**🔹 性能优化要点**
```
索引策略：为常用JSON路径创建函数索引
查询优化：条件过滤尽量放在外层查询
内存管理：只选择需要的列，避免SELECT *
```

### 9.3 实际应用价值


- **数据分析**：将半结构化JSON数据转换为可分析的表格
- **报表统计**：从JSON日志中提取统计指标
- **数据迁移**：将NoSQL数据迁移到关系数据库
- **API集成**：处理外部API返回的JSON响应数据
- **配置管理**：查询和分析用户配置、系统设置等JSON数据

### 9.4 使用建议


**✅ 适合使用的场景**：
- JSON结构相对稳定
- 需要用SQL查询JSON数据
- 数据分析和报表需求
- 半结构化数据标准化

**⚠️ 注意事项**：
- 复杂嵌套会影响性能
- 路径表达式要准确，错误路径返回NULL
- 数据类型转换要合理，避免截断
- 大量数据时考虑分页处理

**核心记忆**：
- JSON_TABLE是数据转换器，JSON变表格
- $路径表达式指位置，[*]数组要展开  
- COLUMNS定义很重要，类型路径要匹配
- 嵌套路径层层访问，FOR ORDINALITY加序号