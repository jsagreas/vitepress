---
title: 5、CTE公用表表达式
---
## 📚 目录

1. [CTE基本概念](#1-CTE基本概念)
2. [WITH子句语法详解](#2-WITH子句语法详解)
3. [非递归CTE应用](#3-非递归CTE应用)
4. [递归CTE实现](#4-递归CTE实现)
5. [CTE作用域与组合使用](#5-CTE作用域与组合使用)
6. [CTE性能特性](#6-CTE性能特性)
7. [CTE高级特性](#7-CTE高级特性)
8. [CTE与其他方案对比](#8-CTE与其他方案对比)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 CTE基本概念


### 1.1 什么是CTE


**CTE（Common Table Expression）公用表表达式**：可以理解为一个**临时的命名查询结果集**，就像给一段复杂的查询起了个名字，然后可以在主查询中反复使用这个名字。

**🔸 通俗理解**
```
想象你在写作文：
- 传统方式：每次需要引用一段长句子时，都要完整重写一遍
- CTE方式：先给这段长句子起个简短的代号，后面直接用代号引用

CTE就是给复杂查询起"代号"的技术！
```

### 1.2 为什么需要CTE


**📋 解决的核心问题**

| 问题场景 | 传统方式 | CTE方式 |
|---------|---------|---------|
| **复杂子查询** | 嵌套层级深，难读懂 | 分步骤，逻辑清晰 |
| **重复查询** | 相同逻辑写多遍 | 定义一次，多处使用 |
| **层次数据** | 难以处理树形结构 | 递归CTE轻松搞定 |

**💡 实际场景举例**
- **部门层级查询**：查找某部门下所有子部门
- **销售数据分析**：先计算月度汇总，再计算年度对比
- **复杂报表**：多个维度的数据需要分步计算

### 1.3 CTE的基本形式


```
数据处理流程图：

原始数据表 → [CTE临时处理] → 最终查询结果
     ↓              ↓              ↓
   员工表         部门汇总        管理层报表
   订单表         月度统计        业绩分析
   产品表         分类整理        库存报告
```

---

## 2. 📝 WITH子句语法详解


### 2.1 基本语法结构


**🔸 标准语法格式**
```sql
WITH cte_name (column_list) AS (
    CTE_query_definition
)
SELECT * FROM cte_name;
```

**📋 语法要素解释**
- `WITH`：关键字，表示定义CTE开始
- `cte_name`：CTE的名称，就像变量名
- `column_list`：可选，指定CTE结果集的列名
- `CTE_query_definition`：CTE的查询定义，就是具体的SQL语句

### 2.2 简单CTE示例


**🎯 基础示例：销售数据汇总**
```sql
-- 定义CTE：计算每个销售员的总业绩
WITH sales_summary AS (
    SELECT 
        salesperson_id,
        salesperson_name,
        SUM(amount) as total_sales,
        COUNT(*) as order_count
    FROM orders 
    WHERE order_date >= '2024-01-01'
    GROUP BY salesperson_id, salesperson_name
)
-- 使用CTE：找出业绩前5名
SELECT 
    salesperson_name,
    total_sales,
    order_count
FROM sales_summary 
ORDER BY total_sales DESC 
LIMIT 5;
```

**💡 这样做的好处**
- **逻辑清晰**：先汇总，再排序，步骤分明
- **易于维护**：修改汇总逻辑只需改一处
- **可读性强**：主查询专注于业务逻辑

### 2.3 带列名定义的CTE


```sql
-- 显式指定CTE的列名
WITH monthly_stats (dept_name, emp_count, avg_salary) AS (
    SELECT 
        department_name,
        COUNT(*) as employee_count,
        AVG(salary) as average_salary
    FROM employees e
    JOIN departments d ON e.dept_id = d.dept_id
    GROUP BY department_name
)
SELECT 
    dept_name,
    emp_count,
    ROUND(avg_salary, 2) as formatted_avg_salary
FROM monthly_stats
WHERE emp_count > 10;
```

---

## 3. 🏢 非递归CTE应用


### 3.1 替代复杂子查询


**🔸 传统子查询方式（难读）**
```sql
-- 复杂嵌套，难以理解
SELECT *
FROM products p
WHERE p.category_id IN (
    SELECT c.category_id 
    FROM categories c
    WHERE c.parent_id IN (
        SELECT pc.category_id
        FROM categories pc
        WHERE pc.category_name = '电子产品'
    )
);
```

**✅ CTE方式（清晰）**
```sql
-- 分步骤，逻辑清晰
WITH electronics_parent AS (
    SELECT category_id 
    FROM categories 
    WHERE category_name = '电子产品'
),
electronics_categories AS (
    SELECT c.category_id
    FROM categories c
    JOIN electronics_parent ep ON c.parent_id = ep.category_id
)
SELECT *
FROM products p
JOIN electronics_categories ec ON p.category_id = ec.category_id;
```

### 3.2 数据预处理场景


**📊 复杂数据分析示例**
```sql
WITH 
-- 第一步：计算每个客户的基础指标
customer_metrics AS (
    SELECT 
        customer_id,
        COUNT(*) as order_count,
        SUM(total_amount) as total_spent,
        AVG(total_amount) as avg_order_value,
        MAX(order_date) as last_order_date
    FROM orders 
    WHERE order_date >= DATE_SUB(NOW(), INTERVAL 1 YEAR)
    GROUP BY customer_id
),
-- 第二步：客户分级
customer_segments AS (
    SELECT 
        customer_id,
        order_count,
        total_spent,
        avg_order_value,
        last_order_date,
        CASE 
            WHEN total_spent > 10000 AND order_count > 20 THEN 'VIP客户'
            WHEN total_spent > 5000 AND order_count > 10 THEN '重要客户'
            WHEN total_spent > 1000 AND order_count > 5 THEN '普通客户'
            ELSE '新客户'
        END as customer_segment
    FROM customer_metrics
)
-- 第三步：生成最终报表
SELECT 
    customer_segment,
    COUNT(*) as customer_count,
    AVG(total_spent) as avg_total_spent,
    AVG(avg_order_value) as avg_order_value
FROM customer_segments
GROUP BY customer_segment
ORDER BY avg_total_spent DESC;
```

### 3.3 窗口函数结合使用


```sql
WITH ranked_sales AS (
    SELECT 
        product_name,
        category_name,
        sales_amount,
        ROW_NUMBER() OVER (PARTITION BY category_name ORDER BY sales_amount DESC) as rank_in_category
    FROM product_sales ps
    JOIN products p ON ps.product_id = p.product_id
    JOIN categories c ON p.category_id = c.category_id
)
SELECT 
    category_name,
    product_name,
    sales_amount,
    rank_in_category
FROM ranked_sales
WHERE rank_in_category <= 3  -- 每个分类前3名
ORDER BY category_name, rank_in_category;
```

---

## 4. 🔄 递归CTE实现


### 4.1 递归CTE概念理解


**🎯 什么是递归CTE**

递归CTE就像**爬楼梯**：
- **起点**：从第1层开始（初始查询）
- **规则**：每次往上爬一层（递归查询）
- **终点**：直到爬不动为止（没有更多数据）

```
递归处理示意图：

初始数据 → 第1次递归 → 第2次递归 → ... → 结束条件
   ↓           ↓           ↓              ↓
  根节点    一级子节点    二级子节点      叶子节点
```

### 4.2 递归CTE语法结构


```sql
WITH RECURSIVE cte_name AS (
    -- 基础部分（初始查询）
    SELECT initial_columns 
    FROM table_name 
    WHERE base_condition
    
    UNION [ALL]
    
    -- 递归部分（递归查询）
    SELECT recursive_columns
    FROM table_name
    JOIN cte_name ON join_condition
    WHERE recursive_condition
)
SELECT * FROM cte_name;
```

### 4.3 层次数据查询实例


**🏢 组织架构查询**
```sql
-- 员工组织架构表
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(100),
    manager_id INT,  -- 上级主管ID
    department VARCHAR(50)
);

-- 递归查询：找出某个经理下的所有下属
WITH RECURSIVE employee_hierarchy AS (
    -- 基础部分：从指定经理开始
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        department,
        0 as level,  -- 层级
        emp_name as path  -- 路径
    FROM employees 
    WHERE emp_id = 1001  -- 指定的经理ID
    
    UNION ALL
    
    -- 递归部分：查找下属
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        e.department,
        eh.level + 1,
        CONCAT(eh.path, ' -> ', e.emp_name)  -- 构建层级路径
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT 
    emp_id,
    emp_name,
    department,
    level,
    path as hierarchy_path
FROM employee_hierarchy
ORDER BY level, emp_name;
```

### 4.4 数字序列生成


```sql
-- 生成1到10的数字序列
WITH RECURSIVE number_series AS (
    SELECT 1 as num  -- 起始值
    
    UNION ALL
    
    SELECT num + 1   -- 递增逻辑
    FROM number_series
    WHERE num < 10   -- 终止条件
)
SELECT num FROM number_series;
```

### 4.5 路径查找示例


```sql
-- 查找从起点到终点的所有路径
WITH RECURSIVE path_finder AS (
    -- 起始节点
    SELECT 
        node_id,
        node_name,
        CAST(node_name AS CHAR(200)) as path,
        0 as path_length
    FROM graph_nodes 
    WHERE node_name = '起点'
    
    UNION ALL
    
    -- 扩展路径
    SELECT 
        gn.node_id,
        gn.node_name,
        CONCAT(pf.path, ' -> ', gn.node_name),
        pf.path_length + 1
    FROM graph_nodes gn
    JOIN graph_edges ge ON gn.node_id = ge.to_node_id
    JOIN path_finder pf ON ge.from_node_id = pf.node_id
    WHERE pf.path_length < 10  -- 防止无限循环
      AND FIND_IN_SET(gn.node_name, REPLACE(pf.path, ' -> ', ',')) = 0  -- 避免环路
)
SELECT path, path_length
FROM path_finder
WHERE node_name = '终点'
ORDER BY path_length;
```

---

## 5. 🔗 CTE作用域与组合使用


### 5.1 CTE作用域管理


**📋 作用域规则**
- **单查询作用域**：CTE只在定义它的查询中有效
- **不能跨语句使用**：不同的SQL语句之间不能共享CTE
- **顺序依赖**：后面的CTE可以引用前面定义的CTE

```sql
-- ✅ 正确：在同一查询中使用
WITH 
base_data AS (SELECT * FROM table1),
processed_data AS (SELECT * FROM base_data WHERE condition)
SELECT * FROM processed_data;

-- ❌ 错误：跨语句使用
WITH base_data AS (SELECT * FROM table1);
SELECT * FROM base_data;  -- 这里会报错
```

### 5.2 多CTE组合使用


**🎯 复杂业务分析示例**
```sql
WITH 
-- CTE1：基础销售数据
sales_base AS (
    SELECT 
        product_id,
        customer_id,
        sale_date,
        quantity,
        unit_price,
        quantity * unit_price as total_amount
    FROM sales 
    WHERE sale_date >= '2024-01-01'
),
-- CTE2：产品销量统计（依赖CTE1）
product_stats AS (
    SELECT 
        product_id,
        SUM(quantity) as total_quantity,
        SUM(total_amount) as total_revenue,
        COUNT(DISTINCT customer_id) as unique_customers
    FROM sales_base
    GROUP BY product_id
),
-- CTE3：客户购买统计（依赖CTE1）
customer_stats AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT product_id) as products_bought,
        SUM(total_amount) as customer_total_spent
    FROM sales_base
    GROUP BY customer_id
),
-- CTE4：综合分析（依赖多个CTE）
final_analysis AS (
    SELECT 
        p.product_name,
        ps.total_quantity,
        ps.total_revenue,
        ps.unique_customers,
        ROUND(ps.total_revenue / ps.total_quantity, 2) as avg_price,
        ROUND(ps.total_revenue / ps.unique_customers, 2) as revenue_per_customer
    FROM product_stats ps
    JOIN products p ON ps.product_id = p.product_id
)
SELECT * FROM final_analysis
ORDER BY total_revenue DESC;
```

### 5.3 CTE依赖关系图


```
CTE依赖关系图示：

    sales_base (原始数据)
         ↓
    ┌────────┬────────┐
    ↓        ↓        ↓
product_stats customer_stats  其他分析
    ↓        ↓        ↓
    └────────┼────────┘
             ↓
      final_analysis (最终结果)
```

---

## 6. ⚡ CTE性能特性


### 6.1 CTE物化策略


**🔸 什么是CTE物化**

物化就是把CTE的查询结果**临时存储**起来，而不是每次都重新计算。

```
非物化CTE：          物化CTE：
查询1 → 重新计算      查询1 → 计算结果存储
查询2 → 重新计算      查询2 → 直接使用存储结果
查询3 → 重新计算      查询3 → 直接使用存储结果
```

**📊 物化判断因素**
- **引用次数**：CTE被引用多次时更可能物化
- **数据量大小**：结果集较小时倾向于物化
- **复杂度**：查询越复杂越可能物化

### 6.2 性能优化建议


**⚡ 性能最佳实践**

| 场景 | 建议 | 原因 |
|------|------|------|
| **大数据量CTE** | 添加适当WHERE条件 | 减少数据传输和处理 |
| **多次引用** | 让MySQL自动物化 | 避免重复计算 |
| **复杂JOIN** | 分解为多个简单CTE | 提高查询优化效果 |

```sql
-- ✅ 推荐：先过滤再处理
WITH filtered_orders AS (
    SELECT * FROM orders 
    WHERE order_date >= DATE_SUB(NOW(), INTERVAL 1 MONTH)  -- 先过滤
      AND status = 'completed'
),
order_summary AS (
    SELECT 
        customer_id,
        SUM(total_amount) as monthly_total
    FROM filtered_orders  -- 处理少量数据
    GROUP BY customer_id
)
SELECT * FROM order_summary;

-- ❌ 不推荐：处理全部数据后再过滤
WITH all_order_summary AS (
    SELECT 
        customer_id,
        order_date,
        status,
        SUM(total_amount) as total
    FROM orders  -- 处理全部历史数据
    GROUP BY customer_id, order_date, status
)
SELECT * FROM all_order_summary 
WHERE order_date >= DATE_SUB(NOW(), INTERVAL 1 MONTH)
  AND status = 'completed';  -- 后过滤效率低
```

### 6.3 CTE内存管理


**🧠 内存使用特点**
- **临时存储**：CTE结果集存储在内存中
- **查询结束释放**：查询完成后自动清理内存
- **内存限制**：受MySQL内存配置限制

**⚠️ 内存使用注意事项**
```sql
-- 注意：大结果集CTE可能消耗大量内存
WITH large_dataset AS (
    SELECT * FROM huge_table  -- 千万级数据
    WHERE complex_condition
)
-- 考虑分页或添加LIMIT
SELECT * FROM large_dataset 
LIMIT 10000;  -- 限制结果集大小
```

---

## 7. 🔧 CTE高级特性


### 7.1 递归深度限制


**⚠️ 为什么需要深度限制**

递归CTE如果没有正确的终止条件，就像**无限循环**，会一直执行下去直到系统资源耗尽。

```sql
-- 设置递归深度限制
SET SESSION cte_max_recursion_depth = 1000;  -- 最多递归1000次

WITH RECURSIVE deep_recursion AS (
    SELECT 1 as level, 'start' as data
    
    UNION ALL
    
    SELECT level + 1, CONCAT(data, '->next')
    FROM deep_recursion
    WHERE level < 999  -- 确保不超过设置的限制
)
SELECT COUNT(*) FROM deep_recursion;
```

### 7.2 CTE循环检测


**🔍 检测和避免循环**
```sql
-- 在路径中记录访问过的节点，避免循环
WITH RECURSIVE hierarchy AS (
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        CAST(emp_id AS CHAR(1000)) as path,  -- 记录路径
        0 as level
    FROM employees 
    WHERE manager_id IS NULL  -- 从顶级开始
    
    UNION ALL
    
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        CONCAT(h.path, ',', e.emp_id),  -- 添加当前节点到路径
        h.level + 1
    FROM employees e
    JOIN hierarchy h ON e.manager_id = h.emp_id
    WHERE FIND_IN_SET(e.emp_id, h.path) = 0  -- 避免循环：检查当前节点是否已在路径中
      AND h.level < 20  -- 额外的深度保护
)
SELECT * FROM hierarchy
ORDER BY level, emp_name;
```

### 7.3 CTE与子查询性能对比


**📊 性能对比测试**
```sql
-- 场景：查找每个部门工资最高的员工

-- 方式1：传统子查询
SELECT e1.*
FROM employees e1
WHERE e1.salary = (
    SELECT MAX(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- 方式2：CTE方式
WITH dept_max_salary AS (
    SELECT 
        department_id,
        MAX(salary) as max_salary
    FROM employees
    GROUP BY department_id
)
SELECT e.*
FROM employees e
JOIN dept_max_salary dms ON e.department_id = dms.department_id 
                        AND e.salary = dms.max_salary;
```

**性能特点对比**

| 特性 | 子查询方式 | CTE方式 |
|------|-----------|---------|
| **可读性** | 嵌套深，难理解 | 逻辑清晰，分步骤 |
| **维护性** | 修改困难 | 易于修改和扩展 |
| **性能** | 可能重复执行子查询 | 可以物化避免重复计算 |
| **调试** | 难以单独测试部分逻辑 | 可以单独测试每个CTE |

---

## 8. 🔄 CTE与其他方案对比


### 8.1 CTE vs 派生表


**📋 概念对比**

**派生表**：在FROM子句中直接写的子查询
**CTE**：用WITH定义的命名查询

```sql
-- 派生表方式
SELECT *
FROM (
    SELECT department_id, AVG(salary) as avg_salary
    FROM employees
    GROUP BY department_id
) as dept_avg
WHERE avg_salary > 50000;

-- CTE方式
WITH dept_avg AS (
    SELECT department_id, AVG(salary) as avg_salary
    FROM employees
    GROUP BY department_id
)
SELECT * FROM dept_avg
WHERE avg_salary > 50000;
```

**对比分析**

| 特性 | 派生表 | CTE |
|------|--------|-----|
| **可读性** | 嵌套在查询中，难读 | 独立定义，清晰 |
| **重用性** | 不能重用 | 可在同一查询中多次使用 |
| **递归** | 不支持 | 支持递归查询 |
| **调试** | 难以单独调试 | 易于逐步调试 |

### 8.2 CTE vs 视图


**🎯 使用场景对比**

| 特性 | CTE | 视图 |
|------|-----|------|
| **生命周期** | 单次查询 | 持久存储 |
| **作用域** | 当前查询 | 全局可用 |
| **参数化** | 不支持 | 不支持 |
| **递归** | 支持 | 不支持递归 |
| **权限管理** | 跟随基表权限 | 独立权限控制 |

```sql
-- CTE：适合一次性复杂查询
WITH monthly_analysis AS (
    SELECT /* 复杂的月度分析逻辑 */
)
SELECT * FROM monthly_analysis;

-- 视图：适合经常使用的查询
CREATE VIEW monthly_sales_view AS 
SELECT /* 经常需要的销售数据 */;
```

### 8.3 CTE vs 临时表


**📊 特性对比**

| 特性 | CTE | 临时表 |
|------|-----|--------|
| **创建方式** | WITH子句 | CREATE TEMPORARY TABLE |
| **存储位置** | 内存 | 磁盘/内存 |
| **索引** | 不支持 | 支持创建索引 |
| **生命周期** | 查询结束 | 会话结束 |
| **多查询使用** | 不能 | 可以 |

```sql
-- CTE方式：适合单次查询
WITH temp_data AS (
    SELECT /* 数据处理 */
)
SELECT * FROM temp_data;

-- 临时表方式：适合多次操作
CREATE TEMPORARY TABLE temp_analysis AS
SELECT /* 数据处理 */;

-- 可以多次查询临时表
SELECT * FROM temp_analysis WHERE condition1;
SELECT * FROM temp_analysis WHERE condition2;
UPDATE temp_analysis SET column = value WHERE condition3;

DROP TEMPORARY TABLE temp_analysis;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 CTE本质：给复杂查询起名字，让SQL更清晰易懂
🔸 WITH语法：WITH cte_name AS (query) SELECT * FROM cte_name
🔸 两种类型：非递归CTE（数据处理）+ 递归CTE（层次查询）
🔸 作用域：只在定义的查询中有效，不能跨语句使用
🔸 性能特点：可能物化提高效率，但要注意内存使用
```

### 9.2 关键理解要点


**🔹 什么时候使用CTE**
```
✅ 适合使用CTE：
• 复杂查询需要分步骤处理
• 同一查询中需要多次引用相同的子查询结果
• 需要处理层次数据（组织架构、分类树等）
• 提高查询的可读性和维护性

❌ 不适合使用CTE：
• 简单的一次性查询
• 需要跨多个查询语句共享数据（用临时表）
• 需要建索引优化性能（用临时表）
• 查询结果需要持久化存储（用视图）
```

**🔹 递归CTE的关键点**
```
递归三要素：
1. 基础部分（起点）：定义递归的起始条件
2. 递归部分（规则）：定义如何从当前层找到下一层
3. 终止条件（终点）：防止无限递归的条件

常见应用：
• 组织架构查询（找下属/上级）
• 分类树遍历（产品分类、菜单结构）
• 路径查找（图论问题）
• 数字序列生成
```

**🔹 性能优化要点**
```
优化策略：
• 尽早过滤数据，减少CTE处理的数据量
• 合理使用索引，CTE会继承基表的索引效果
• 控制递归深度，避免无限循环消耗资源
• 监控内存使用，大结果集CTE注意内存限制

性能监控：
• 使用EXPLAIN分析CTE的执行计划
• 注意CTE是否被物化
• 关注临时表的创建和使用
```

### 9.3 实际应用价值


- **数据分析**：复杂报表查询的分步处理
- **层次数据**：组织架构、分类树、评论回复等
- **数据清洗**：ETL过程中的数据预处理
- **复杂业务**：多步骤业务逻辑的SQL实现

### 9.4 学习建议


**🎯 学习路径**
1. **掌握基础**：先学会简单的非递归CTE
2. **理解递归**：重点理解递归的三要素
3. **实践应用**：在实际项目中多使用CTE改写复杂查询
4. **性能调优**：学会分析和优化CTE性能

**💡 常见错误避免**
- 不要试图在不同查询间共享CTE
- 递归CTE必须设置合理的终止条件
- 大数据量时注意内存使用限制
- 不要滥用CTE，简单查询直接写更清晰

**核心记忆口诀**：
- CTE给查询起名字，复杂逻辑变清晰
- WITH定义AS使用，作用域内才有效  
- 递归三要素记牢，起点规则加终点
- 性能优化要关注，内存深度控制好