---
title: 4、窗口函数完整实现
---
## 📚 目录

1. [窗口函数基础概念](#1-窗口函数基础概念)
2. [WINDOW窗口函数语法](#2-WINDOW窗口函数语法)
3. [排名函数详解](#3-排名函数详解)
4. [偏移函数应用](#4-偏移函数应用)
5. [聚合窗口函数](#5-聚合窗口函数)
6. [窗口框架定义](#6-窗口框架定义)
7. [分区与排序](#7-分区与排序)
8. [取值函数](#8-取值函数)
9. [窗口函数嵌套与命名](#9-窗口函数嵌套与命名)
10. [性能优化策略](#10-性能优化策略)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 窗口函数基础概念


### 1.1 什么是窗口函数

**简单理解**：窗口函数就是在**不改变行数**的前提下，为每一行计算一个基于"窗口"的值。

```
传统聚合函数：
SELECT department, COUNT(*) FROM employees GROUP BY department;
结果：部门被合并，行数减少

窗口函数：
SELECT name, department, COUNT(*) OVER(PARTITION BY department) FROM employees;
结果：保留所有行，每行显示所在部门的总人数
```

**🔸 核心特点**
- **保留原行**：不会减少结果集的行数
- **计算窗口**：在指定的数据窗口内进行计算
- **逐行处理**：为每一行单独计算结果

### 1.2 窗口函数 vs 普通函数

```
普通查询：只能看到当前行数据
窗口函数：既能看到当前行，又能"透视"相关行的数据

比如：计算每个员工的薪水排名
普通方法：需要子查询，复杂且效率低
窗口函数：一句话搞定，清晰高效
```

---

## 2. ⚙️ WINDOW窗口函数语法


### 2.1 基本语法结构

```sql
窗口函数名() OVER (
    [PARTITION BY 列名]     -- 分区：将数据分组
    [ORDER BY 列名]         -- 排序：确定计算顺序
    [窗口框架定义]          -- 框架：指定计算范围
)
```

**💡 语法解释**
- **OVER子句**：这就是"窗口"，告诉函数在什么范围内计算
- **PARTITION BY**：把数据分组，就像GROUP BY，但不合并行
- **ORDER BY**：决定在窗口内的计算顺序
- **窗口框架**：进一步细化计算的行范围

### 2.2 简单示例理解

```sql
-- 示例数据
CREATE TABLE employees (
    name VARCHAR(50),
    department VARCHAR(50),
    salary INT
);

INSERT INTO employees VALUES
('张三', '技术部', 8000),
('李四', '技术部', 9000),
('王五', '销售部', 7000),
('赵六', '销售部', 7500);

-- 基础窗口函数使用
SELECT 
    name,
    department,
    salary,
    -- 计算每个部门的平均薪水
    AVG(salary) OVER(PARTITION BY department) as dept_avg
FROM employees;
```

**结果理解**：
```
张三  技术部  8000  8500  -- 技术部平均薪水
李四  技术部  9000  8500  -- 技术部平均薪水  
王五  销售部  7000  7250  -- 销售部平均薪水
赵六  销售部  7500  7250  -- 销售部平均薪水
```

---

## 3. 🏆 排名函数详解


### 3.1 ROW_NUMBER - 连续排名

**作用**：给每一行分配一个**唯一的连续序号**，即使值相同也不重复。

```sql
SELECT 
    name, salary,
    ROW_NUMBER() OVER(ORDER BY salary DESC) as row_num
FROM employees;

-- 结果：
-- 李四  9000  1
-- 张三  8000  2  
-- 赵六  7500  3
-- 王五  7000  4
```

**🔸 特点**：序号连续且唯一，适合需要唯一标识的场景

### 3.2 RANK - 跳跃排名

**作用**：相同值获得相同排名，但会**跳过**后续排名。

```sql
-- 假设有相同薪水的情况
INSERT INTO employees VALUES ('小明', '技术部', 8000);

SELECT 
    name, salary,
    RANK() OVER(ORDER BY salary DESC) as rank_num
FROM employees;

-- 结果：
-- 李四  9000  1
-- 张三  8000  2  
-- 小明  8000  2  (相同排名)
-- 赵六  7500  4  (跳过了3)
-- 王五  7000  5
```

**🔸 特点**：相同值同排名，跳过中间序号

### 3.3 DENSE_RANK - 密集排名  

**作用**：相同值获得相同排名，但**不跳过**后续排名。

```sql
SELECT 
    name, salary,
    DENSE_RANK() OVER(ORDER BY salary DESC) as dense_rank_num
FROM employees;

-- 结果：
-- 李四  9000  1
-- 张三  8000  2
-- 小明  8000  2  (相同排名)
-- 赵六  7500  3  (不跳过，直接3)
-- 王五  7000  4
```

**🔸 特点**：相同值同排名，序号连续不跳跃

### 3.4 排名函数对比表


| 函数 | **相同值处理** | **序号特点** | **适用场景** |
|------|---------------|-------------|-------------|
| `ROW_NUMBER()` | `每行唯一序号` | `连续递增` | `分页查询、唯一标识` |
| `RANK()` | `相同值同排名` | `会跳跃` | `竞赛排名、考试成绩` |  
| `DENSE_RANK()` | `相同值同排名` | `不跳跃` | `等级划分、分类排序` |

---

## 4. 🔄 偏移函数应用


### 4.1 LAG - 向前偏移

**作用**：获取**当前行之前**第N行的数据，用于同比分析。

```sql
-- 计算每个员工与前一个员工的薪水差异
SELECT 
    name, 
    salary,
    LAG(salary, 1) OVER(ORDER BY salary DESC) as prev_salary,
    salary - LAG(salary, 1) OVER(ORDER BY salary DESC) as salary_diff
FROM employees;

-- 结果：
-- 李四  9000  NULL   NULL   (第一行没有前一行)
-- 张三  8000  9000   -1000  (比前一行少1000)
-- 赵六  7500  8000   -500   (比前一行少500)
-- 王五  7000  7500   -500   (比前一行少500)
```

**💡 参数说明**
- `LAG(列名, 偏移量, 默认值)`
- 偏移量：向前偏移几行，默认1
- 默认值：当没有对应行时的默认值

### 4.2 LEAD - 向后偏移

**作用**：获取**当前行之后**第N行的数据，用于预测分析。

```sql
-- 查看每个员工的下一个薪水等级
SELECT 
    name, 
    salary,
    LEAD(salary, 1, 0) OVER(ORDER BY salary DESC) as next_salary,
    CASE 
        WHEN LEAD(salary, 1) OVER(ORDER BY salary DESC) IS NULL THEN '最低薪水'
        ELSE '还有更低'
    END as status
FROM employees;
```

### 4.3 偏移函数实用场景

```
📊 业务应用场景：
- 同比增长：LAG获取去年同期数据
- 环比分析：LAG获取上月数据  
- 趋势预测：LEAD获取未来数据
- 连续性检查：检查数据是否连续
```

---

## 5. 📊 聚合窗口函数


### 5.1 基础聚合函数

**作用**：在窗口内进行聚合计算，但保留所有原始行。

```sql
SELECT 
    name,
    department, 
    salary,
    -- 部门内聚合计算
    SUM(salary) OVER(PARTITION BY department) as dept_total,
    AVG(salary) OVER(PARTITION BY department) as dept_avg,
    COUNT(*) OVER(PARTITION BY department) as dept_count,
    -- 全局聚合
    SUM(salary) OVER() as company_total
FROM employees;
```

**结果解读**：
```
每一行都显示：
- 个人信息（姓名、部门、薪水）
- 所在部门的汇总信息（总薪水、平均薪水、人数）
- 公司整体信息（总薪水）
```

### 5.2 累积聚合函数

**作用**：计算从第一行到当前行的累积值。

```sql
SELECT 
    name,
    salary,
    -- 累积求和（跑起来的总和）
    SUM(salary) OVER(ORDER BY salary) as cumulative_sum,
    -- 累积平均
    AVG(salary) OVER(ORDER BY salary) as cumulative_avg,
    -- 累积计数
    COUNT(*) OVER(ORDER BY salary) as cumulative_count
FROM employees
ORDER BY salary;

-- 结果：
-- 王五  7000  7000   7000   1  (第1个，累积=自己)
-- 赵六  7500  14500  7250   2  (前2个总和)
-- 张三  8000  22500  7500   3  (前3个总和)
-- 李四  9000  31500  7875   4  (前4个总和)
```

---

## 6. 🖼️ 窗口框架定义


### 6.1 FRAME框架概念

**作用**：更精确地控制窗口函数的**计算范围**，不是对所有行计算，而是对指定的"框架"内的行计算。

```
窗口框架语法：
ROWS BETWEEN 开始位置 AND 结束位置
RANGE BETWEEN 开始位置 AND 结束位置
```

**🔸 位置关键字**
- `UNBOUNDED PRECEDING`：从分区开始
- `n PRECEDING`：当前行之前n行
- `CURRENT ROW`：当前行
- `n FOLLOWING`：当前行之后n行  
- `UNBOUNDED FOLLOWING`：到分区结束

### 6.2 ROWS框架 - 按行数计算

```sql
SELECT 
    name,
    salary,
    -- 当前行和前1行的平均值（移动平均）
    AVG(salary) OVER(
        ORDER BY salary 
        ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
    ) as moving_avg_2,
    
    -- 当前行前后各1行的总和（滑动窗口）
    SUM(salary) OVER(
        ORDER BY salary 
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) as sliding_sum
FROM employees
ORDER BY salary;
```

**框架图解**：
```
数据行：  A  B  C  D  E
         ↑
   当前行：C
   
ROWS 1 PRECEDING AND CURRENT ROW：
计算范围： [B, C]  只看B和C两行

ROWS 1 PRECEDING AND 1 FOLLOWING：  
计算范围： [B, C, D]  看B、C、D三行
```

### 6.3 RANGE框架 - 按值范围计算

```sql
-- 计算薪水相差不超过1000的所有行的平均值
SELECT 
    name,
    salary,
    AVG(salary) OVER(
        ORDER BY salary 
        RANGE BETWEEN 1000 PRECEDING AND 1000 FOLLOWING
    ) as range_avg
FROM employees
ORDER BY salary;
```

**ROWS vs RANGE对比**：
```
ROWS：按物理行数计算，精确控制行数
RANGE：按数值范围计算，逻辑相关的行

示例：
薪水：7000, 7500, 8000, 9000

ROWS 1 PRECEDING：看前1行
RANGE 1000 PRECEDING：看薪水相差1000以内的行
```

---

## 7. 🎯 分区与排序


### 7.1 PARTITION BY - 数据分组

**作用**：将数据按指定列分组，在每个组内单独计算窗口函数。

```sql
-- 每个部门内的薪水排名
SELECT 
    name,
    department,
    salary,
    ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) as dept_rank,
    RANK() OVER(ORDER BY salary DESC) as company_rank
FROM employees;

-- 结果：
-- 李四  技术部  9000  1  1  (技术部第1，公司第1)
-- 张三  技术部  8000  2  2  (技术部第2，公司第2)
-- 赵六  销售部  7500  1  3  (销售部第1，公司第3)
-- 王五  销售部  7000  2  4  (销售部第2，公司第4)
```

**🔸 分区特点**
```
不分区：所有数据作为一个整体计算
分区后：每个分区独立计算，互不影响

类比理解：
不分区 = 全校排名
分区 = 各班级内排名
```

### 7.2 ORDER BY - 排序控制

**作用**：控制窗口内数据的排序方式，直接影响排名和累积计算。

```sql
-- 不同排序方式的对比
SELECT 
    name, salary,
    -- 按薪水降序排名
    ROW_NUMBER() OVER(ORDER BY salary DESC) as rank_desc,
    -- 按薪水升序排名  
    ROW_NUMBER() OVER(ORDER BY salary ASC) as rank_asc,
    -- 按姓名排序的累积薪水
    SUM(salary) OVER(ORDER BY name) as cumul_by_name
FROM employees;
```

### 7.3 多列排序与分区

```sql
-- 复杂分区和排序组合
SELECT 
    name,
    department, 
    salary,
    hire_date,
    -- 按部门分区，按薪水和入职时间排序
    ROW_NUMBER() OVER(
        PARTITION BY department 
        ORDER BY salary DESC, hire_date ASC
    ) as complex_rank
FROM employees;
```

---

## 8. 📋 取值函数


### 8.1 百分比排名函数

**PERCENT_RANK** - 计算百分比排名
```sql
SELECT 
    name,
    salary,
    -- 百分比排名：当前行排名在总行数中的百分比位置
    PERCENT_RANK() OVER(ORDER BY salary DESC) as pct_rank,
    -- 结果范围：0到1之间
    ROUND(PERCENT_RANK() OVER(ORDER BY salary DESC) * 100, 2) as pct_rank_percent
FROM employees;

-- 结果解读：
-- pct_rank = (当前排名 - 1) / (总行数 - 1)
-- 李四：(1-1)/(4-1) = 0      = 0%    (最高)
-- 张三：(2-1)/(4-1) = 0.33   = 33%   
-- 赵六：(3-1)/(4-1) = 0.67   = 67%   
-- 王五：(4-1)/(4-1) = 1      = 100%  (最低)
```

**CUME_DIST** - 累积分布
```sql
SELECT 
    name,
    salary,
    -- 累积分布：小于等于当前值的行数占总行数的比例
    CUME_DIST() OVER(ORDER BY salary) as cumulative_dist,
    ROUND(CUME_DIST() OVER(ORDER BY salary) * 100, 2) as cumul_percent
FROM employees;

-- 结果解读：有多少比例的人薪水不超过当前值
-- 王五：25%的人薪水不超过7000
-- 赵六：50%的人薪水不超过7500
-- 张三：75%的人薪水不超过8000  
-- 李四：100%的人薪水不超过9000
```

### 8.2 分桶函数

**NTILE** - 将数据分成N个桶
```sql
SELECT 
    name,
    salary,
    -- 将员工分成3个薪水等级
    NTILE(3) OVER(ORDER BY salary DESC) as salary_level,
    -- 分成4个等级
    NTILE(4) OVER(ORDER BY salary DESC) as salary_quartile
FROM employees;

-- 结果：
-- 李四  9000  1  1  (高薪组/第1四分位)
-- 张三  8000  1  2  (高薪组/第2四分位)
-- 赵六  7500  2  3  (中薪组/第3四分位)
-- 王五  7000  3  4  (低薪组/第4四分位)
```

**💡 NTILE应用场景**
```
📊 常用分桶：
- NTILE(4)：四分位数分析
- NTILE(10)：十分位数分析  
- NTILE(100)：百分位数分析

🎯 业务应用：
- 客户等级划分
- 员工绩效分组
- 产品销量分级
```

### 8.3 取值函数

**FIRST_VALUE/LAST_VALUE** - 获取窗口内的第一个/最后一个值
```sql
SELECT 
    name,
    department,
    salary,
    -- 获取本部门薪水最高的员工姓名
    FIRST_VALUE(name) OVER(
        PARTITION BY department 
        ORDER BY salary DESC
    ) as dept_top_earner,
    
    -- 获取本部门薪水最低的员工薪水
    LAST_VALUE(salary) OVER(
        PARTITION BY department 
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) as dept_min_salary
FROM employees;
```

**NTH_VALUE** - 获取第N个值
```sql
SELECT 
    name,
    salary,
    -- 获取薪水第2高的员工姓名
    NTH_VALUE(name, 2) OVER(ORDER BY salary DESC) as second_highest,
    -- 获取薪水第3高的薪水数额
    NTH_VALUE(salary, 3) OVER(ORDER BY salary DESC) as third_salary
FROM employees;
```

---

## 9. 🔧 窗口函数嵌套与命名


### 9.1 窗口函数嵌套使用

**基本嵌套**：将窗口函数的结果作为另一个函数的输入
```sql
-- 计算每个部门内薪水排名，然后筛选前2名
SELECT * FROM (
    SELECT 
        name,
        department,
        salary,
        ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) as dept_rank
    FROM employees
) ranked
WHERE dept_rank <= 2;
```

**复杂嵌套**：多层窗口函数组合
```sql
SELECT 
    name,
    department,
    salary,
    dept_rank,
    -- 对部门排名再进行全局排名
    ROW_NUMBER() OVER(ORDER BY dept_rank, salary DESC) as final_rank
FROM (
    SELECT 
        name,
        department,
        salary,
        ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) as dept_rank
    FROM employees
) as ranked_employees;
```

### 9.2 命名窗口规范

**WINDOW子句**：为复杂的窗口定义命名，提高代码可读性和复用性

```sql
SELECT 
    name,
    department,
    salary,
    -- 使用命名窗口
    ROW_NUMBER() OVER dept_window as dept_rank,
    AVG(salary) OVER dept_window as dept_avg,
    SUM(salary) OVER company_window as total_salary
FROM employees
-- 定义命名窗口
WINDOW 
    dept_window AS (PARTITION BY department ORDER BY salary DESC),
    company_window AS (ORDER BY salary DESC);
```

**🔸 命名窗口优势**
```
✅ 代码复用：避免重复写相同的OVER子句
✅ 易于维护：修改窗口定义只需改一处  
✅ 提高可读性：语义化的窗口名称
✅ 性能优化：相同窗口定义可能被优化器优化
```

### 9.3 窗口继承与扩展

```sql
SELECT 
    name,
    department, 
    salary,
    ROW_NUMBER() OVER base_window as rank1,
    DENSE_RANK() OVER (base_window ROWS UNBOUNDED PRECEDING) as rank2
FROM employees
-- 基础窗口定义
WINDOW base_window AS (PARTITION BY department ORDER BY salary DESC);
```

---

## 10. ⚡ 性能优化策略


### 10.1 索引优化

**核心原则**：为`PARTITION BY`和`ORDER BY`的列建立合适的索引

```sql
-- 创建复合索引支持窗口函数
CREATE INDEX idx_dept_salary ON employees(department, salary DESC);

-- 优化后的查询
SELECT 
    name,
    department,
    salary,
    ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) as rank
FROM employees;
```

**🔸 索引策略**
```
📈 索引建议：
- 分区列 + 排序列的复合索引
- 索引列顺序：PARTITION BY列在前，ORDER BY列在后
- 排序方向要匹配：DESC索引对应DESC排序

⚠️ 注意事项：
- 避免在窗口函数列上建索引
- 考虑查询的整体性能，不只是窗口函数
```

### 10.2 查询优化技巧

**减少数据量**：先过滤再计算窗口函数
```sql
-- ❌ 低效：先计算窗口函数再过滤
SELECT * FROM (
    SELECT name, salary,
           ROW_NUMBER() OVER(ORDER BY salary DESC) as rank
    FROM employees
) ranked WHERE rank <= 10;

-- ✅ 高效：先过滤再计算（如果可能）
SELECT name, salary,
       ROW_NUMBER() OVER(ORDER BY salary DESC) as rank
FROM employees 
WHERE salary > 5000  -- 先减少数据量
ORDER BY salary DESC
LIMIT 10;  -- 进一步限制结果
```

**避免重复计算**：使用命名窗口
```sql
-- ✅ 使用命名窗口避免重复定义
SELECT 
    name, salary,
    ROW_NUMBER() OVER win as rank,
    DENSE_RANK() OVER win as dense_rank,
    AVG(salary) OVER win as avg_salary
FROM employees
WINDOW win AS (ORDER BY salary DESC);
```

### 10.3 内存管理

**控制窗口大小**：避免过大的窗口框架
```sql
-- ❌ 可能内存消耗大
SELECT name, salary,
       SUM(salary) OVER(ORDER BY salary ROWS UNBOUNDED PRECEDING) as cumsum
FROM large_employee_table;

-- ✅ 限制窗口大小  
SELECT name, salary,
       SUM(salary) OVER(ORDER BY salary ROWS 100 PRECEDING) as recent_sum
FROM large_employee_table;
```

### 10.4 性能监控

```sql
-- 查看窗口函数的执行计划
EXPLAIN SELECT 
    name,
    ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) 
FROM employees;

-- 关注以下指标：
-- 1. 是否使用了索引
-- 2. 排序操作的代价
-- 3. 内存使用情况
-- 4. 执行时间
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念

```
🔸 窗口函数本质：在不改变行数的前提下，为每行计算基于窗口的值
🔸 基本语法：函数名() OVER(PARTITION BY ... ORDER BY ... 框架定义)
🔸 三大分类：排名函数、聚合函数、取值函数
🔸 关键区别：窗口函数保留所有行，聚合函数会合并行
🔸 性能要点：合理使用索引，避免过大窗口，善用命名窗口
```

### 11.2 排名函数选择指南

| 场景 | **推荐函数** | **原因** |
|------|-------------|----------|
| `需要唯一序号` | `ROW_NUMBER()` | `保证每行都有不同编号` |
| `传统排名（如比赛）` | `RANK()` | `并列名次会跳跃，符合常规认知` |
| `等级划分` | `DENSE_RANK()` | `连续等级，不会出现空档` |
| `百分比分析` | `PERCENT_RANK()` | `直接得到百分比位置` |
| `数据分组` | `NTILE(n)` | `均匀分成n个组` |

### 11.3 常用模式总结

**💡 部门内排名模式**
```sql
ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC)
```

**📊 累积统计模式**  
```sql
SUM(amount) OVER(ORDER BY date ROWS UNBOUNDED PRECEDING)
```

**🔄 同比分析模式**
```sql  
LAG(value, 12) OVER(ORDER BY month)  -- 同比去年
```

**🎯 移动平均模式**
```sql
AVG(value) OVER(ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
```

### 11.4 实际应用价值

- **报表分析**：排名、占比、趋势分析一步到位
- **业务洞察**：部门对比、员工评估、销售分析  
- **数据清洗**：去重、异常检测、数据校验
- **性能提升**：替代复杂子查询，提高查询效率

### 11.5 学习建议

```
🎯 学习路径：
基础语法 → 排名函数 → 聚合窗口 → 框架定义 → 性能优化

💡 练习重点：
- 理解PARTITION BY与GROUP BY的区别
- 掌握三种排名函数的应用场景  
- 熟练使用LAG/LEAD做同比环比分析
- 学会用框架定义控制计算范围

⚠️ 常见误区：
- 忘记ORDER BY导致结果不确定
- 混淆ROWS和RANGE框架
- 在WHERE中直接使用窗口函数
- 忽视索引对性能的影响
```

**🧠 记忆要点**：
- 窗口函数不减行，保留原数据很重要
- OVER子句是关键，分区排序框架全
- 排名函数有三种，场景不同选择不同  
- LAG往前LEAD往后，偏移分析很有用
- 索引优化要记住，分区排序建复合