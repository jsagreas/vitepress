---
title: 14、密码验证组件
---
## 📚 目录

1. [密码验证组件概述](#1-密码验证组件概述)
2. [validate_password组件基础](#2-validate_password组件基础)
3. [密码强度策略配置](#3-密码强度策略配置)
4. [密码复杂度检查机制](#4-密码复杂度检查机制)
5. [密码历史与重用限制](#5-密码历史与重用限制)
6. [密码过期机制](#6-密码过期机制)
7. [双密码认证](#7-双密码认证)
8. [密码字典检查](#8-密码字典检查)
9. [自定义验证规则](#9-自定义验证规则)
10. [密码验证组件配置实践](#10-密码验证组件配置实践)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔐 密码验证组件概述


### 1.1 什么是密码验证组件


**简单理解**：密码验证组件就像是MySQL的"门卫"，专门检查用户设置的密码是否够安全。

```
传统MySQL：                    MySQL 8.0密码验证：
用户设置密码 → 直接保存        用户设置密码 → 安全检查 → 通过后保存
                              ↓
                         不符合规则就拒绝
```

**核心作用**：
- 🛡️ **提升安全性**：强制用户使用复杂密码
- 🔍 **预防弱密码**：自动拒绝简单、常见的密码
- 📋 **统一标准**：为整个数据库系统建立密码规范
- 🔄 **持续保护**：定期要求用户更换密码

### 1.2 为什么需要密码验证


**现实问题**：
```
常见的弱密码：
❌ 123456
❌ password
❌ admin
❌ 用户名相同
❌ 公司名称

安全风险：
- 暴力破解攻击
- 字典攻击
- 社会工程学攻击
```

**MySQL 8.0的解决方案**：
- ✅ **强制复杂密码**：必须包含大小写、数字、特殊字符
- ✅ **长度要求**：设置最小密码长度
- ✅ **历史检查**：防止重复使用旧密码
- ✅ **字典过滤**：拒绝常见弱密码

---

## 2. ⚙️ validate_password组件基础


### 2.1 组件安装与启用


**检查组件状态**：
```sql
-- 查看是否已安装密码验证组件
SHOW PLUGINS;
-- 或者
SELECT PLUGIN_NAME, PLUGIN_STATUS 
FROM INFORMATION_SCHEMA.PLUGINS 
WHERE PLUGIN_NAME = 'validate_password';
```

**安装密码验证组件**：
```sql
-- 安装validate_password组件
INSTALL COMPONENT 'file://component_validate_password';

-- 验证安装结果
SELECT * FROM mysql.component;
```

**卸载组件**（如需要）：
```sql
-- 卸载组件
UNINSTALL COMPONENT 'file://component_validate_password';
```

### 2.2 组件工作原理


**工作流程图**：
```
用户创建/修改密码
        ↓
   密码验证组件检查
        ↓
    ┌─────────────┐
    │ 长度检查    │ → 太短？拒绝
    └─────────────┘
        ↓
    ┌─────────────┐
    │ 复杂度检查  │ → 太简单？拒绝
    └─────────────┘
        ↓
    ┌─────────────┐
    │ 字典检查    │ → 常见密码？拒绝
    └─────────────┘
        ↓
    ┌─────────────┐
    │ 历史检查    │ → 重复使用？拒绝
    └─────────────┘
        ↓
     验证通过 → 密码保存
```

### 2.3 基本配置查看


**查看当前配置**：
```sql
-- 查看所有密码验证相关变量
SHOW VARIABLES LIKE 'validate_password%';

-- 常见输出示例：
-- validate_password.check_user_name: ON
-- validate_password.dictionary_file: (空)
-- validate_password.length: 8
-- validate_password.mixed_case_count: 1
-- validate_password.number_count: 1
-- validate_password.policy: MEDIUM
-- validate_password.special_char_count: 1
```

---

## 3. 🎯 密码强度策略配置


### 3.1 策略等级详解


**三种策略等级**：

| 策略等级 | **设置值** | **检查内容** | **适用场景** |
|---------|----------|-------------|-------------|
| 🟢 **LOW** | `0` | `只检查长度` | `开发测试环境` |
| 🟡 **MEDIUM** | `1` | `长度+数字+大小写+特殊字符` | `一般生产环境` |
| 🔴 **STRONG** | `2` | `MEDIUM+字典检查` | `高安全要求环境` |

**策略配置示例**：
```sql
-- 设置为LOW等级（只检查长度）
SET GLOBAL validate_password.policy = 'LOW';
-- 或者用数字
SET GLOBAL validate_password.policy = 0;

-- 设置为MEDIUM等级（推荐）
SET GLOBAL validate_password.policy = 'MEDIUM';

-- 设置为STRONG等级（最严格）
SET GLOBAL validate_password.policy = 'STRONG';
```

### 3.2 长度要求配置


**基本长度设置**：
```sql
-- 设置密码最小长度为12位
SET GLOBAL validate_password.length = 12;

-- 查看当前长度要求
SELECT $$validate_password.length;
```

**长度计算逻辑**：
```
实际最小长度 = MAX(
    validate_password.length,
    validate_password.number_count + 
    validate_password.mixed_case_count * 2 + 
    validate_password.special_char_count
)
```

### 3.3 字符类型要求


**数字字符要求**：
```sql
-- 至少包含2个数字
SET GLOBAL validate_password.number_count = 2;

-- 示例：密码必须包含至少2个数字(0-9)
-- ✅ MyPass123    (包含1,2,3三个数字)
-- ❌ MyPassword1  (只有1个数字)
```

**大小写字符要求**：
```sql
-- 至少包含2个大写和2个小写字母
SET GLOBAL validate_password.mixed_case_count = 2;

-- 示例说明：
-- ✅ MyPassWORD123!  (M,P,W,O,R,D大写，y,a,s,s小写)
-- ❌ mypassword123!  (没有大写字母)
-- ❌ MYPASSWORD123!  (没有小写字母)
```

**特殊字符要求**：
```sql
-- 至少包含2个特殊字符
SET GLOBAL validate_password.special_char_count = 2;

-- 特殊字符包括：!@#$%^&*()_+-=[]{}|;:,.<>?
-- ✅ MyPass123!@    (包含!和@两个特殊字符)
-- ❌ MyPass123!     (只有1个特殊字符)
```

---

## 4. 🔍 密码复杂度检查机制


### 4.1 用户名检查


**防止密码包含用户名**：
```sql
-- 启用用户名检查（默认开启）
SET GLOBAL validate_password.check_user_name = ON;

-- 关闭用户名检查
SET GLOBAL validate_password.check_user_name = OFF;
```

**检查规则示例**：
```sql
-- 假设用户名为 'john'
CREATE USER 'john'@'%' IDENTIFIED BY 'john123!';     -- ❌ 密码包含用户名
CREATE USER 'john'@'%' IDENTIFIED BY 'secure123!';   -- ✅ 密码不包含用户名
CREATE USER 'john'@'%' IDENTIFIED BY '123john!';     -- ❌ 密码包含用户名
```

### 4.2 密码强度验证函数


**使用VALIDATE_PASSWORD_STRENGTH()函数**：
```sql
-- 测试密码强度（返回0-100的分数）
SELECT VALIDATE_PASSWORD_STRENGTH('123456') AS strength;          -- 返回: 25
SELECT VALIDATE_PASSWORD_STRENGTH('MyPass123!') AS strength;      -- 返回: 75
SELECT VALIDATE_PASSWORD_STRENGTH('VerySecure#Pass2024') AS strength; -- 返回: 100

-- 实际应用示例
SELECT 
    password,
    VALIDATE_PASSWORD_STRENGTH(password) as strength_score,
    CASE 
        WHEN VALIDATE_PASSWORD_STRENGTH(password) >= 75 THEN '强密码'
        WHEN VALIDATE_PASSWORD_STRENGTH(password) >= 50 THEN '中等密码'
        ELSE '弱密码'
    END as strength_level
FROM (
    SELECT 'abc123' as password
    UNION SELECT 'MyPassword123'
    UNION SELECT 'VerySecure#Pass2024!'
) test_passwords;
```

### 4.3 实时密码检查


**创建用户时的检查**：
```sql
-- 这些密码会被拒绝（假设使用MEDIUM策略）
CREATE USER 'test1'@'%' IDENTIFIED BY '123';          -- ❌ 太短
CREATE USER 'test2'@'%' IDENTIFIED BY '12345678';     -- ❌ 只有数字
CREATE USER 'test3'@'%' IDENTIFIED BY 'password';     -- ❌ 只有小写字母
CREATE USER 'test4'@'%' IDENTIFIED BY 'Password';     -- ❌ 缺少数字和特殊字符

-- 这些密码会被接受
CREATE USER 'test5'@'%' IDENTIFIED BY 'MyPass123!';   -- ✅ 符合所有要求
CREATE USER 'test6'@'%' IDENTIFIED BY 'Secure#2024';  -- ✅ 符合所有要求
```

---

## 5. 📝 密码历史与重用限制


### 5.1 密码历史记录


**启用密码历史功能**：
```sql
-- 记录用户最近5次使用的密码
SET GLOBAL password_history = 5;

-- 为特定用户设置密码历史
ALTER USER 'username'@'%' PASSWORD HISTORY 3;

-- 查看当前设置
SELECT $$password_history;
```

**工作原理**：
```
用户密码变更历史：
第1次：MyPass123!     ← 当前密码
第2次：SecurePass456@ ← 1次前
第3次：StrongPwd789#  ← 2次前
第4次：SafeKey012$    ← 3次前
第5次：GuardWord345%  ← 4次前

如果password_history=3，则前3个密码不能重用
用户尝试设置MyPass123! → ❌ 拒绝（在历史记录中）
用户尝试设置NewPassword890* → ✅ 允许（不在历史记录中）
```

### 5.2 密码重用时间限制


**基于时间的重用限制**：
```sql
-- 密码180天内不能重用
SET GLOBAL password_reuse_interval = 180;

-- 为特定用户设置重用间隔
ALTER USER 'username'@'%' PASSWORD REUSE INTERVAL 90 DAY;

-- 组合使用历史次数和时间间隔
ALTER USER 'username'@'%' 
    PASSWORD HISTORY 5 
    PASSWORD REUSE INTERVAL 90 DAY;
```

**实际应用示例**：
```sql
-- 创建用户并设置密码策略
CREATE USER 'secure_user'@'%' 
    IDENTIFIED BY 'InitialPass123!'
    PASSWORD HISTORY 3
    PASSWORD REUSE INTERVAL 90 DAY;

-- 用户后续修改密码的情况：
-- Day 1: 设置 InitialPass123!
-- Day 30: 修改为 NewSecure456@     ✅ 允许
-- Day 60: 修改为 AnotherPass789#   ✅ 允许  
-- Day 90: 修改为 InitialPass123!  ❌ 拒绝（在90天限制内）
-- Day 180: 修改为 InitialPass123! ✅ 允许（超过90天限制）
```

---

## 6. ⏰ 密码过期机制


### 6.1 全局密码过期策略


**设置默认密码过期时间**：
```sql
-- 设置密码90天后过期
SET GLOBAL default_password_lifetime = 90;

-- 设置密码永不过期（不推荐）
SET GLOBAL default_password_lifetime = 0;

-- 查看当前设置
SELECT $$default_password_lifetime;
```

### 6.2 用户级密码过期


**为用户设置特定过期策略**：
```sql
-- 用户密码60天后过期
ALTER USER 'username'@'%' PASSWORD EXPIRE INTERVAL 60 DAY;

-- 用户密码立即过期（强制下次登录时修改）
ALTER USER 'username'@'%' PASSWORD EXPIRE;

-- 用户密码永不过期
ALTER USER 'username'@'%' PASSWORD EXPIRE NEVER;

-- 用户使用全局默认策略
ALTER USER 'username'@'%' PASSWORD EXPIRE DEFAULT;
```

### 6.3 密码过期状态查看


**检查用户密码过期状态**：
```sql
-- 查看所有用户的密码过期信息
SELECT 
    User,
    Host,
    password_expired,
    password_last_changed,
    password_lifetime
FROM mysql.user;

-- 查看即将过期的密码（30天内）
SELECT 
    User,
    Host,
    password_last_changed,
    password_lifetime,
    DATE_ADD(password_last_changed, INTERVAL password_lifetime DAY) as expires_on,
    DATEDIFF(DATE_ADD(password_last_changed, INTERVAL password_lifetime DAY), NOW()) as days_until_expire
FROM mysql.user
WHERE password_lifetime > 0
    AND DATEDIFF(DATE_ADD(password_last_changed, INTERVAL password_lifetime DAY), NOW()) <= 30;
```

---

## 7. 🔐 双密码认证


### 7.1 双密码概念


**什么是双密码认证**：
简单来说，就是给用户设置两个密码，在密码过渡期间，新旧密码都可以使用。

```
传统密码更换：                   双密码认证：
旧密码 → 立即失效                 旧密码 → 临时保留（辅助密码）
新密码 → 立即生效                 新密码 → 主密码
                                过渡期后 → 只保留新密码
```

**使用场景**：
- 🔄 **密码轮换**：应用程序密码平滑过渡
- 🛠️ **维护窗口**：给应用程序时间更新配置
- 🔗 **多连接场景**：不同连接逐步切换新密码

### 7.2 双密码设置


**设置双密码**：
```sql
-- 为用户设置新密码，保留旧密码作为辅助密码
ALTER USER 'app_user'@'%' 
    IDENTIFIED BY 'NewSecurePass123!' 
    RETAIN CURRENT PASSWORD;

-- 查看用户是否有辅助密码
SELECT User, Host, authentication_string, password_expired 
FROM mysql.user 
WHERE User = 'app_user';
```

**双密码登录示例**：
```bash
# 使用主密码登录
mysql -u app_user -p'NewSecurePass123!' -h localhost

# 使用辅助密码登录（旧密码仍然有效）
mysql -u app_user -p'OldPassword456@' -h localhost
```

### 7.3 双密码管理


**丢弃辅助密码**：
```sql
-- 当确认所有应用都已更新密码后，丢弃辅助密码
ALTER USER 'app_user'@'%' DISCARD OLD PASSWORD;
```

**实际应用流程**：
```sql
-- 步骤1：设置双密码
ALTER USER 'web_app'@'%' 
    IDENTIFIED BY 'NewAppPass2024!' 
    RETAIN CURRENT PASSWORD;

-- 步骤2：逐步更新应用程序配置文件
-- 应用服务器A：更新为NewAppPass2024!
-- 应用服务器B：仍使用旧密码（临时）
-- 应用服务器C：仍使用旧密码（临时）

-- 步骤3：确认所有应用都已更新后，丢弃旧密码
ALTER USER 'web_app'@'%' DISCARD OLD PASSWORD;
```

---

## 8. 📚 密码字典检查


### 8.1 字典文件配置


**设置密码字典文件**：
```sql
-- 设置字典文件路径
SET GLOBAL validate_password.dictionary_file = '/path/to/password_dictionary.txt';

-- 查看当前字典文件设置
SELECT $$validate_password.dictionary_file;
```

### 8.2 创建密码字典


**字典文件格式**（password_dictionary.txt）：
```text
password
123456
admin
root
qwerty
letmein
welcome
monkey
dragon
master
```

**字典文件要求**：
- 📝 **纯文本格式**：每行一个密码
- 🔤 **不区分大小写**：Password 和 password 都会被检查
- 📏 **任意长度**：可以包含短密码和长密码
- 🚫 **拒绝包含**：密码中包含字典词汇会被拒绝

### 8.3 字典检查示例


**启用字典检查**（需要STRONG策略）：
```sql
-- 设置为STRONG策略以启用字典检查
SET GLOBAL validate_password.policy = 'STRONG';
SET GLOBAL validate_password.dictionary_file = '/etc/mysql/bad_passwords.txt';

-- 测试字典检查
CREATE USER 'test_user'@'%' IDENTIFIED BY 'password123!';  -- ❌ 包含字典词"password"
CREATE USER 'test_user'@'%' IDENTIFIED BY 'admin2024@';    -- ❌ 包含字典词"admin"
CREATE USER 'test_user'@'%' IDENTIFIED BY 'SecureKey789#'; -- ✅ 不在字典中
```

---

## 9. ⚙️ 自定义验证规则


### 9.1 验证函数定制


**创建自定义密码验证存储过程**：
```sql
DELIMITER //

CREATE PROCEDURE CheckCustomPassword(IN pwd VARCHAR(255), OUT is_valid BOOLEAN, OUT error_msg VARCHAR(500))
BEGIN
    DECLARE msg TEXT DEFAULT '';
    SET is_valid = TRUE;
    
    -- 检查是否包含连续字符
    IF pwd REGEXP '[0-9]{3,}' OR pwd REGEXP '[a-zA-Z]{4,}' THEN
        SET is_valid = FALSE;
        SET msg = CONCAT(msg, '密码不能包含连续的数字或字母; ');
    END IF;
    
    -- 检查是否包含常见模式
    IF pwd REGEXP '(.)\\1{2,}' THEN  -- 检查重复字符
        SET is_valid = FALSE;
        SET msg = CONCAT(msg, '密码不能包含连续重复的字符; ');
    END IF;
    
    -- 检查是否包含键盘序列
    IF pwd REGEXP 'qwerty|asdfgh|zxcvbn|123456|654321' THEN
        SET is_valid = FALSE;
        SET msg = CONCAT(msg, '密码不能包含键盘序列; ');
    END IF;
    
    SET error_msg = TRIM(TRAILING '; ' FROM msg);
END //

DELIMITER ;
```

### 9.2 应用场景配置


**特定业务需求配置**：
```sql
-- 银行系统密码要求
SET GLOBAL validate_password.policy = 'STRONG';
SET GLOBAL validate_password.length = 16;
SET GLOBAL validate_password.mixed_case_count = 2;
SET GLOBAL validate_password.number_count = 3;
SET GLOBAL validate_password.special_char_count = 2;
SET GLOBAL password_history = 12;
SET GLOBAL password_reuse_interval = 365;
SET GLOBAL default_password_lifetime = 90;

-- 一般企业系统配置
SET GLOBAL validate_password.policy = 'MEDIUM';
SET GLOBAL validate_password.length = 12;
SET GLOBAL validate_password.mixed_case_count = 1;
SET GLOBAL validate_password.number_count = 2;
SET GLOBAL validate_password.special_char_count = 1;
SET GLOBAL password_history = 5;
SET GLOBAL password_reuse_interval = 180;
SET GLOBAL default_password_lifetime = 120;
```

---

## 10. 🛠️ 密码验证组件配置实践


### 10.1 完整配置示例


**生产环境推荐配置**：
```sql
-- 1. 安装并配置密码验证组件
INSTALL COMPONENT 'file://component_validate_password';

-- 2. 设置密码策略
SET GLOBAL validate_password.policy = 'MEDIUM';
SET GLOBAL validate_password.length = 12;
SET GLOBAL validate_password.mixed_case_count = 1;
SET GLOBAL validate_password.number_count = 2;
SET GLOBAL validate_password.special_char_count = 1;
SET GLOBAL validate_password.check_user_name = ON;

-- 3. 设置密码历史和过期策略
SET GLOBAL password_history = 5;
SET GLOBAL password_reuse_interval = 180;
SET GLOBAL default_password_lifetime = 90;

-- 4. 配置字典文件（可选）
-- SET GLOBAL validate_password.dictionary_file = '/etc/mysql/password_blacklist.txt';
```

### 10.2 配置验证脚本


**验证配置是否生效**：
```sql
-- 验证脚本
SELECT '=== 密码验证组件状态 ===' as info;
SELECT PLUGIN_NAME, PLUGIN_STATUS 
FROM INFORMATION_SCHEMA.PLUGINS 
WHERE PLUGIN_NAME LIKE '%password%';

SELECT '=== 当前密码策略配置 ===' as info;
SHOW VARIABLES LIKE 'validate_password%';

SELECT '=== 密码历史和过期配置 ===' as info;
SELECT 
    $$password_history as password_history,
    $$password_reuse_interval as reuse_interval_days,
    $$default_password_lifetime as default_expire_days;

-- 测试密码强度
SELECT '=== 密码强度测试 ===' as info;
SELECT 
    '123456' as test_password,
    VALIDATE_PASSWORD_STRENGTH('123456') as strength_score;
    
SELECT 
    'MySecure123!' as test_password,
    VALIDATE_PASSWORD_STRENGTH('MySecure123!') as strength_score;
```

### 10.3 常见问题处理


**配置文件持久化**：
```ini
# my.cnf 配置文件示例
[mysqld]
# 密码验证组件配置
validate-password.policy=MEDIUM
validate-password.length=12
validate-password.mixed-case-count=1
validate-password.number-count=2
validate-password.special-char-count=1
validate-password.check-user-name=ON

# 密码历史和过期配置
password-history=5
password-reuse-interval=180
default-password-lifetime=90
```

**权限问题解决**：
```sql
-- 确保有足够权限配置密码验证
GRANT SYSTEM_VARIABLES_ADMIN ON *.* TO 'admin_user'@'%';
GRANT CONNECTION_ADMIN ON *.* TO 'admin_user'@'%';
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的基本概念


```
🔸 密码验证组件：MySQL 8.0的安全守护神，自动检查密码强度
🔸 三种策略等级：LOW(长度)、MEDIUM(复杂度)、STRONG(+字典)
🔸 密码历史记录：防止重复使用最近的密码
🔸 密码过期机制：强制定期更换密码提升安全性
🔸 双密码认证：新旧密码并存，平滑过渡应用系统
```

### 11.2 关键理解要点


**🔹 密码验证的工作原理**
```
用户设置密码 → 组件检查 → 通过标准才能保存
检查项目：长度、复杂度、字典、历史、用户名包含
任何一项不符合就直接拒绝，保护数据库安全
```

**🔹 配置策略的选择**
```
开发环境：LOW策略，密码要求宽松，便于测试
生产环境：MEDIUM策略，平衡安全性和可用性  
高安全环境：STRONG策略，最严格的密码要求
```

**🔹 双密码的实际价值**
```
解决问题：应用系统密码更新的时间差
避免中断：新旧密码同时有效，无缝切换
生产友好：给运维团队充分的更新时间
```

### 11.3 实际应用指导


**配置建议**：
- 🎯 **企业标准**：MEDIUM策略 + 12位长度 + 5次历史 + 90天过期
- 🔒 **金融系统**：STRONG策略 + 16位长度 + 12次历史 + 60天过期  
- 🧪 **开发测试**：LOW策略 + 8位长度 + 无历史限制 + 不过期

**最佳实践**：
- ✅ 配置写入my.cnf确保重启后生效
- ✅ 定期检查用户密码过期状态
- ✅ 为关键应用用户使用双密码过渡
- ✅ 建立密码字典文件阻止常见弱密码
- ✅ 监控密码验证失败的登录尝试

**常见应用场景**：
- 🏢 **企业用户管理**：统一密码安全标准
- 🔄 **应用系统迁移**：使用双密码平滑过渡
- 🛡️ **安全合规要求**：满足行业安全标准
- 📊 **数据库安全审计**：提供密码安全证据

**核心记忆**：
- MySQL 8.0密码验证组件是数据库安全的重要防线
- 通过策略等级、长度要求、复杂度检查保护密码安全
- 密码历史和过期机制防止长期使用同一密码
- 双密码认证解决生产环境密码更新的平滑过渡问题
- 合理配置密码验证策略平衡安全性和可用性