---
title: 18、数据库表设计规范
---
## 📚 目录

1. [表结构设计基础原则](#1-表结构设计基础原则)
2. [字段类型选择与规范](#2-字段类型选择与规范)
3. [主键外键设计规范](#3-主键外键设计规范)
4. [索引设计标准](#4-索引设计标准)
5. [约束设计规则](#5-约束设计规则)
6. [分区表设计指南](#6-分区表设计指南)
7. [存储引擎选择策略](#7-存储引擎选择策略)
8. [数据建模最佳实践](#8-数据建模最佳实践)
9. [表设计评审与工具](#9-表设计评审与工具)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📋 表结构设计基础原则


### 1.1 什么是好的表设计

**简单理解**：表设计就像设计房子的图纸，设计得好，住起来舒服、维护简单；设计得差，后期问题不断。

```
好的表设计特征：
✅ 结构清晰：一看就知道存什么数据
✅ 查询高效：常用查询速度快
✅ 维护简单：修改数据不复杂
✅ 扩展性好：业务变化时容易调整
```

### 1.2 设计基本原则


#### 🎯 单一职责原则

**含义**：一张表只存储一类数据，不要什么都往里放

```sql
-- ❌ 错误示例：用户表里混杂订单信息
CREATE TABLE user_bad (
    user_id INT,
    username VARCHAR(50),
    email VARCHAR(100),
    last_order_time DATETIME,    -- 订单信息不应该在用户表
    total_orders INT             -- 订单统计不应该在用户表
);

-- ✅ 正确示例：用户表只存用户信息
CREATE TABLE user_good (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

> **💡 生活类比**：就像整理房间，衣服放衣柜，书放书架，不要都堆在一起。

#### 🔄 最小冗余原则

**含义**：相同的数据不要重复存储多份

```sql
-- ❌ 错误示例：订单表存储重复的用户信息
CREATE TABLE order_bad (
    order_id INT,
    user_id INT,
    username VARCHAR(50),        -- 冗余：用户表已有
    user_email VARCHAR(100),     -- 冗余：用户表已有
    product_name VARCHAR(200)
);

-- ✅ 正确示例：只存关联ID
CREATE TABLE order_good (
    order_id INT PRIMARY KEY,
    user_id INT,
    product_id INT,
    order_amount DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 1.3 命名规范标准


#### 📝 表命名规范

```
基本规则：
🔸 使用小写字母和下划线
🔸 表名要有意义，见名知意
🔸 不要使用MySQL保留字

命名模式：
• 业务表：user, product, order
• 关联表：user_role, product_category  
• 日志表：user_login_log, order_audit_log
• 临时表：temp_user_import, backup_order_20241201
```

```sql
-- 推荐的表命名示例
CREATE TABLE user (              -- 用户表
    user_id INT PRIMARY KEY
);

CREATE TABLE user_profile (      -- 用户资料表
    profile_id INT PRIMARY KEY,
    user_id INT
);

CREATE TABLE user_login_log (    -- 用户登录日志表
    log_id INT PRIMARY KEY,
    user_id INT,
    login_time TIMESTAMP
);
```

#### 🏷️ 字段命名规范

```
字段命名原则：
🔸 使用描述性名称
🔸 统一使用下划线分隔
🔸 主键统一为：表名_id
🔸 布尔字段以 is_ 开头
🔸 时间字段以 _at 或 _time 结尾
```

```sql
CREATE TABLE user (
    user_id INT PRIMARY KEY,           -- 主键：表名_id
    username VARCHAR(50),              -- 用户名
    email VARCHAR(100),                -- 邮箱
    is_active BOOLEAN DEFAULT TRUE,    -- 布尔字段：is_开头
    is_verified BOOLEAN DEFAULT FALSE, -- 是否验证
    created_at TIMESTAMP,              -- 创建时间：_at结尾
    updated_at TIMESTAMP,              -- 更新时间
    last_login_time DATETIME           -- 最后登录：_time结尾
);
```

---

## 2. 🔢 字段类型选择与规范


### 2.1 数值类型选择策略


#### 整数类型选择

**核心原则**：根据数据范围选择最小的合适类型

```sql
-- 整数类型对比与使用场景
CREATE TABLE number_examples (
    -- TINYINT：-128到127，常用于状态、等级
    status TINYINT,              -- 订单状态：1-待付款，2-已付款，3-已发货
    user_level TINYINT UNSIGNED, -- 用户等级：0-255
    
    -- SMALLINT：-32768到32767，常用于计数
    view_count SMALLINT UNSIGNED, -- 浏览次数
    
    -- INT：-21亿到21亿，常用于ID、数量
    user_id INT,                  -- 用户ID
    product_count INT UNSIGNED,   -- 商品数量
    
    -- BIGINT：大数值，常用于时间戳、大ID
    timestamp_value BIGINT,       -- 时间戳
    global_id BIGINT              -- 全局唯一ID
);
```

> **📊 类型选择参考**
> ```
> 数据范围           推荐类型        典型应用
> 0-255             TINYINT         状态码、等级
> 0-65535           SMALLINT        计数、排序
> 0-42亿            INT             主键ID、数量
> 超过42亿          BIGINT          时间戳、大ID
> ```

#### 小数类型选择

**重点理解**：`DECIMAL`用于精确计算，`FLOAT`/`DOUBLE`用于科学计算

```sql
CREATE TABLE decimal_examples (
    -- 金额必须用DECIMAL，避免精度丢失
    price DECIMAL(10,2),          -- 价格：最大99999999.99
    discount_rate DECIMAL(5,4),   -- 折扣率：如0.8500
    
    -- 科学计算可用FLOAT/DOUBLE
    latitude DOUBLE,              -- 纬度
    longitude DOUBLE,             -- 经度
    temperature FLOAT             -- 温度
);
```

> **⚠️ 重要提醒**：涉及金钱计算必须使用`DECIMAL`，否则会有精度误差！

### 2.2 字符串类型规范


#### VARCHAR vs CHAR 选择

**简单判断**：长度固定用`CHAR`，长度变化用`VARCHAR`

```sql
CREATE TABLE string_examples (
    -- 固定长度用CHAR
    country_code CHAR(2),         -- 国家代码：CN, US
    gender CHAR(1),               -- 性别：M, F
    
    -- 变长字符用VARCHAR
    username VARCHAR(50),         -- 用户名：1-50字符
    email VARCHAR(100),           -- 邮箱地址
    description VARCHAR(500),     -- 描述信息
    
    -- 长文本用TEXT
    content TEXT,                 -- 文章内容
    remark LONGTEXT               -- 长备注
);
```

#### 字段长度设计原则

```
长度设计指导：
📏 用户名：VARCHAR(50)     - 一般够用
📏 邮箱：VARCHAR(100)      - 标准长度
📏 手机号：VARCHAR(20)     - 包含国际格式
📏 密码哈希：VARCHAR(255)  - 加密后的密码
📏 URL：VARCHAR(500)       - 网址长度
📏 描述：VARCHAR(1000)     - 简短描述
📏 内容：TEXT             - 长文本内容
```

```sql
-- 实际业务表示例
CREATE TABLE user (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,           -- 用户名
    email VARCHAR(100) UNIQUE NOT NULL,      -- 邮箱
    mobile VARCHAR(20),                      -- 手机号
    password_hash VARCHAR(255) NOT NULL,     -- 密码哈希
    avatar_url VARCHAR(500),                 -- 头像URL
    bio VARCHAR(1000),                       -- 个人简介
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2.3 时间日期类型规范


#### 时间类型选择策略

```sql
CREATE TABLE time_examples (
    -- 业务创建时间：使用TIMESTAMP，自动维护
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 业务更新时间：自动更新
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 生日等日期：使用DATE
    birthday DATE,
    
    -- 预约时间等：使用DATETIME
    appointment_time DATETIME,
    
    -- 时长：使用TIME
    duration TIME
);
```

> **📅 时间类型选择指南**
> ```
> TIMESTAMP：记录操作时间（创建、更新）
> DATETIME：记录业务时间（预约、截止）  
> DATE：只需要日期（生日、节假日）
> TIME：只需要时间（营业时间、时长）
> ```

---

## 3. 🔑 主键外键设计规范


### 3.1 主键设计标准


#### 主键选择策略

**核心原则**：主键要唯一、稳定、简单

```sql
-- 推荐：自增整数主键
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,  -- 自增主键，简单高效
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

-- 备选：UUID主键（分布式环境）
CREATE TABLE user_uuid (
    user_id CHAR(36) PRIMARY KEY,           -- UUID主键，全局唯一
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);
```

#### 复合主键使用场景

**使用场景**：多对多关联表、日志表

```sql
-- 用户角色关联表：复合主键
CREATE TABLE user_role (
    user_id INT,
    role_id INT,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, role_id),         -- 复合主键
    FOREIGN KEY (user_id) REFERENCES user(user_id),
    FOREIGN KEY (role_id) REFERENCES role(role_id)
);

-- 用户每日统计：日期+用户ID作为主键
CREATE TABLE user_daily_stats (
    user_id INT,
    stat_date DATE,
    login_count INT DEFAULT 0,
    page_views INT DEFAULT 0,
    PRIMARY KEY (user_id, stat_date)        -- 复合主键
);
```

### 3.2 外键设计规范


#### 外键约束使用原则

**重要理解**：外键能保证数据一致性，但会影响性能

```sql
-- 订单表：标准外键设计
CREATE TABLE order_info (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,                   -- 外键字段
    product_id INT NOT NULL,                -- 外键字段
    order_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 添加外键约束
    FOREIGN KEY (user_id) REFERENCES user(user_id) 
        ON DELETE RESTRICT ON UPDATE CASCADE,
    FOREIGN KEY (product_id) REFERENCES product(product_id) 
        ON DELETE RESTRICT ON UPDATE CASCADE
);
```

#### 外键约束操作策略

```
外键约束选项：
🔸 RESTRICT：不允许删除/更新（默认，最安全）
🔸 CASCADE：级联删除/更新（需谨慎使用）
🔸 SET NULL：设置为NULL（字段允许NULL时）
🔸 NO ACTION：同RESTRICT
```

> **⚠️ 生产环境建议**：
> - 开发环境：使用外键约束，确保数据一致性
> - 生产环境：考虑性能，可能只建立索引不建约束
> - 通过应用层逻辑保证数据一致性

---

## 4. 🚀 索引设计标准


### 4.1 索引基础概念


**简单理解**：索引就像书的目录，帮助快速找到需要的内容

```
索引的作用：
✅ 加速查询：从全表扫描变成快速定位
✅ 加速排序：ORDER BY操作更快
✅ 加速连接：JOIN操作更高效
❌ 减慢写入：INSERT/UPDATE/DELETE变慢
❌ 占用空间：需要额外存储空间
```

### 4.2 索引类型与应用


#### 单列索引设计

```sql
-- 用户表索引示例
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,  -- 主键自动有索引
    username VARCHAR(50) UNIQUE NOT NULL,    -- 唯一索引
    email VARCHAR(100) UNIQUE NOT NULL,      -- 唯一索引
    mobile VARCHAR(20),
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 添加普通索引
    INDEX idx_mobile (mobile),               -- 手机号索引
    INDEX idx_status (status),               -- 状态索引
    INDEX idx_created_at (created_at)        -- 创建时间索引
);
```

#### 复合索引设计原则

**重要概念**：复合索引有"最左前缀"规则

```sql
-- 订单表复合索引示例
CREATE TABLE order_info (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    status TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 复合索引：注意字段顺序
    INDEX idx_user_status_time (user_id, status, created_at)
);

-- 这个复合索引可以支持的查询：
-- ✅ WHERE user_id = 1
-- ✅ WHERE user_id = 1 AND status = 2  
-- ✅ WHERE user_id = 1 AND status = 2 AND created_at > '2024-01-01'
-- ❌ WHERE status = 2  （不能使用索引）
-- ❌ WHERE created_at > '2024-01-01'  （不能使用索引）
```

#### 索引设计最佳实践

```sql
-- 用户查询场景分析
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    status TINYINT DEFAULT 1,
    city_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 根据查询场景设计索引：
    -- 场景1：按用户名查找 → 已有唯一索引
    -- 场景2：按邮箱查找 → 已有唯一索引  
    -- 场景3：按状态和城市查找活跃用户
    INDEX idx_status_city (status, city_id),
    -- 场景4：按创建时间范围查找
    INDEX idx_created_at (created_at)
);
```

### 4.3 索引优化策略


#### 索引选择性分析

**重要概念**：选择性高的字段更适合建索引

```sql
-- 分析字段选择性（不同值的比例）
SELECT 
    COUNT(DISTINCT username) / COUNT(*) as username_selectivity,
    COUNT(DISTINCT email) / COUNT(*) as email_selectivity,
    COUNT(DISTINCT status) / COUNT(*) as status_selectivity,
    COUNT(DISTINCT city_id) / COUNT(*) as city_selectivity
FROM user;

-- 结果示例：
-- username_selectivity: 0.98  （选择性高，适合索引）
-- email_selectivity: 0.98     （选择性高，适合索引）
-- status_selectivity: 0.03    （选择性低，不太适合索引）
-- city_id_selectivity: 0.15   （选择性一般，结合查询场景决定）
```

> **📊 索引选择性指导**：
> - 选择性 > 0.5：非常适合建索引
> - 选择性 0.1-0.5：结合查询频率决定  
> - 选择性 < 0.1：通常不建议建索引

---

## 5. ✅ 约束设计规则


### 5.1 NOT NULL约束策略


**设计原则**：重要字段必须设置NOT NULL

```sql
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    -- 必须字段：NOT NULL
    username VARCHAR(50) NOT NULL,           -- 用户名必须有
    email VARCHAR(100) NOT NULL,             -- 邮箱必须有  
    password_hash VARCHAR(255) NOT NULL,     -- 密码必须有
    status TINYINT NOT NULL DEFAULT 1,       -- 状态必须有，默认1
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- 可选字段：允许NULL
    mobile VARCHAR(20),                      -- 手机号可选
    avatar_url VARCHAR(500),                 -- 头像可选
    bio VARCHAR(1000),                       -- 简介可选
    last_login_at TIMESTAMP                  -- 最后登录时间可选
);
```

### 5.2 默认值设计规范


```sql
CREATE TABLE product (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    
    -- 状态字段：设置合理默认值
    status TINYINT NOT NULL DEFAULT 1,       -- 1-上架，0-下架
    is_featured BOOLEAN DEFAULT FALSE,       -- 是否推荐，默认否
    
    -- 计数字段：默认0
    view_count INT UNSIGNED DEFAULT 0,       -- 浏览次数
    sale_count INT UNSIGNED DEFAULT 0,       -- 销售次数
    
    -- 时间字段：自动时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 5.3 检查约束应用


```sql
-- MySQL 8.0+ 支持检查约束
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    age TINYINT UNSIGNED,
    score DECIMAL(5,2),
    
    -- 年龄检查约束
    CONSTRAINT chk_age CHECK (age >= 0 AND age <= 150),
    
    -- 分数检查约束  
    CONSTRAINT chk_score CHECK (score >= 0 AND score <= 100)
);
```

---

## 6. 📊 分区表设计指南


### 6.1 分区表应用场景


**什么时候需要分区**：数据量大（百万级以上）且有明显的时间或范围特征

```sql
-- 用户行为日志表：按月分区
CREATE TABLE user_behavior_log (
    log_id BIGINT AUTO_INCREMENT,
    user_id INT NOT NULL,
    action_type VARCHAR(50) NOT NULL,
    action_time TIMESTAMP NOT NULL,
    ip_address VARCHAR(45),
    PRIMARY KEY (log_id, action_time)        -- 分区键必须在主键中
)
PARTITION BY RANGE (YEAR(action_time) * 100 + MONTH(action_time)) (
    PARTITION p202401 VALUES LESS THAN (202402),
    PARTITION p202402 VALUES LESS THAN (202403),
    PARTITION p202403 VALUES LESS THAN (202404),
    PARTITION p202404 VALUES LESS THAN (202405),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### 6.2 分区策略选择


```sql
-- HASH分区：用户表按用户ID分区
CREATE TABLE user_large (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
PARTITION BY HASH(user_id) PARTITIONS 4;

-- LIST分区：按地区分区
CREATE TABLE user_by_region (
    user_id INT AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    region_code VARCHAR(10) NOT NULL,
    PRIMARY KEY (user_id, region_code)
)
PARTITION BY LIST COLUMNS(region_code) (
    PARTITION p_north VALUES IN ('BJ','TJ','HEB'),
    PARTITION p_south VALUES IN ('GD','HN','GX'),
    PARTITION p_others VALUES IN ('OTHER')
);
```

---

## 7. 🔧 存储引擎选择策略


### 7.1 InnoDB vs MyISAM选择


**简单判断**：99%的场景选择InnoDB

```sql
-- 推荐：使用InnoDB存储引擎
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- InnoDB优势：
-- ✅ 支持事务：保证数据一致性
-- ✅ 支持外键：保证引用完整性  
-- ✅ 行级锁：并发性能好
-- ✅ 崩溃恢复：数据更安全
-- ✅ 支持热备份：在线备份
```

### 7.2 字符集选择标准


```sql
-- 推荐配置：utf8mb4字符集
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    nickname VARCHAR(100)
) ENGINE=InnoDB 
  DEFAULT CHARSET=utf8mb4           -- 支持完整Unicode，包括emoji
  COLLATE=utf8mb4_unicode_ci        -- 排序规则，支持多语言
  ROW_FORMAT=DYNAMIC;               -- 行格式，支持大字段
```

> **📝 字符集选择指南**：
> - `utf8mb4`：支持完整Unicode，包括emoji（推荐）
> - `utf8`：不完整Unicode，不支持emoji（不推荐）
> - `latin1`：只支持英文（特殊场景）

---

## 8. 🏗️ 数据建模最佳实践


### 8.1 数据库范式应用


#### 第一范式（1NF）：原子性

**含义**：每个字段都不可再分

```sql
-- ❌ 违反1NF：联系方式字段包含多个值
CREATE TABLE user_bad (
    user_id INT PRIMARY KEY,
    name VARCHAR(50),
    contact VARCHAR(200)  -- "手机:13800138000,邮箱:user@example.com"
);

-- ✅ 符合1NF：字段具有原子性
CREATE TABLE user_good (
    user_id INT PRIMARY KEY,
    name VARCHAR(50),
    mobile VARCHAR(20),   -- 手机单独字段
    email VARCHAR(100)    -- 邮箱单独字段
);
```

#### 第二范式（2NF）：完全依赖

**含义**：非主键字段完全依赖于主键

```sql
-- ❌ 违反2NF：商品名称只依赖商品ID，不依赖完整主键
CREATE TABLE order_item_bad (
    order_id INT,
    product_id INT,
    product_name VARCHAR(200),  -- 只依赖product_id
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);

-- ✅ 符合2NF：分别存储
CREATE TABLE order_item_good (
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10,2),
    PRIMARY KEY (order_id, product_id)
);

CREATE TABLE product (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(200)   -- 商品信息独立存储
);
```

### 8.2 反范式化策略


**什么时候反范式化**：为了查询性能，可以适当冗余

```sql
-- 订单表：冗余商品名称，避免频繁JOIN
CREATE TABLE order_item (
    order_id INT,
    product_id INT,
    product_name VARCHAR(200),      -- 冗余字段，提升查询性能
    quantity INT,
    price DECIMAL(10,2),
    PRIMARY KEY (order_id, product_id)
);

-- 用户表：冗余订单统计，避免复杂计算
CREATE TABLE user (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    total_orders INT DEFAULT 0,     -- 冗余统计，定期同步
    total_amount DECIMAL(10,2) DEFAULT 0.00
);
```

---

## 9. 🔍 表设计评审与工具


### 9.1 设计评审检查清单


```
📋 表设计评审清单：

结构设计：
☐ 表名和字段名符合命名规范
☐ 字段类型选择合适且长度适当  
☐ 主键设计合理
☐ 索引设计符合查询场景
☐ 约束设置正确

性能考虑：
☐ 索引不会过多影响写入性能
☐ 字段长度不会浪费存储空间
☐ 分区策略合理（如果需要）

业务逻辑：
☐ 字段设计符合业务需求
☐ 数据类型能满足业务范围
☐ 默认值设置合理
☐ 扩展性考虑充分
```

### 9.2 常用设计工具


```sql
-- 表结构分析SQL
-- 检查表的基本信息
SHOW CREATE TABLE user;

-- 分析表的索引使用情况
SHOW INDEX FROM user;

-- 查看表的统计信息
SELECT 
    table_name,
    table_rows,
    data_length,
    index_length,
    (data_length + index_length) as total_size
FROM information_schema.tables 
WHERE table_schema = 'your_database' 
AND table_name = 'user';
```

### 9.3 设计模板库


#### 用户相关表模板

```sql
-- 用户基础表模板
CREATE TABLE user (
    user_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
    username VARCHAR(50) NOT NULL COMMENT '用户名',
    email VARCHAR(100) UNIQUE NOT NULL COMMENT '邮箱',
    mobile VARCHAR(20) UNIQUE COMMENT '手机号',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态:1-正常,0-禁用',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_mobile (mobile),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';
```

#### 订单相关表模板

```sql
-- 订单表模板
CREATE TABLE order_info (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID',
    order_no VARCHAR(32) UNIQUE NOT NULL COMMENT '订单号',
    user_id INT NOT NULL COMMENT '用户ID',
    total_amount DECIMAL(12,2) NOT NULL COMMENT '订单总金额',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '订单状态:1-待付款,2-已付款,3-已发货,4-已完成,5-已取消',
    payment_type TINYINT COMMENT '支付方式:1-支付宝,2-微信,3-银行卡',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_order_no (order_no),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    INDEX idx_user_status_time (user_id, status, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='订单表';
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的设计原则


```
🔸 单一职责：一表一事，职责清晰
🔸 最小冗余：避免重复存储，适当反范式化
🔸 合适类型：根据数据特点选择最优字段类型
🔸 规范命名：统一命名规则，见名知意
🔸 合理索引：基于查询场景设计索引
🔸 必要约束：保证数据完整性和一致性
```

### 10.2 关键技术要点


**🔹 字段设计核心**
```
数值字段：
• 整数优先用INT，超大数值用BIGINT
• 金钱计算必须用DECIMAL
• 状态字段用TINYINT节省空间

字符字段：
• 用户名、邮箱等用VARCHAR
• 长文本内容用TEXT
• 固定长度用CHAR（如国家代码）

时间字段：
• 创建更新时间用TIMESTAMP
• 业务时间用DATETIME
• 生日等用DATE
```

**🔹 索引设计要点**
```
索引策略：
• 主键自动有索引，不需额外创建
• 经常WHERE查询的字段建索引
• 复合索引遵循最左前缀原则
• 选择性低的字段不适合建索引

性能平衡：
• 读多写少：可以多建索引
• 写多读少：谨慎建索引
• 定期分析索引使用情况
```

### 10.3 实践应用指导


**🎯 设计流程**
```
1. 需求分析：理解业务需求和数据关系
2. 概念设计：设计实体关系图
3. 逻辑设计：应用范式理论设计表结构
4. 物理设计：选择字段类型、索引、约束
5. 性能优化：根据查询场景调优
6. 评审验证：团队评审，工具检测
```

**🔧 维护策略**
```
监控指标：
• 表大小增长趋势
• 索引使用效率
• 查询性能变化
• 锁等待情况

优化时机：
• 数据量快速增长时
• 查询性能下降时
• 业务需求变化时
• 定期性能评估时
```

**核心记忆**：
- 表设计决定系统性能基础
- 字段类型选择要精准合适  
- 索引设计需要平衡查询和写入
- 约束保证数据质量和一致性
- 持续监控和优化是关键