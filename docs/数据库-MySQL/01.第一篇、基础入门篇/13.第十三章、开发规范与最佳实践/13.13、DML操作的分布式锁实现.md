---
title: 13ã€DMLæ“ä½œçš„åˆ†å¸ƒå¼é”å®ç°
---
## ğŸ“š ç›®å½•

1. [åˆ†å¸ƒå¼é”å¿…è¦æ€§åˆ†æ](#1-åˆ†å¸ƒå¼é”å¿…è¦æ€§åˆ†æ)
2. [åŸºäºMySQLçš„åˆ†å¸ƒå¼é”](#2-åŸºäºMySQLçš„åˆ†å¸ƒå¼é”)
3. [é”è¶…æ—¶ä¸ç»­æœŸæœºåˆ¶](#3-é”è¶…æ—¶ä¸ç»­æœŸæœºåˆ¶)
4. [é”ç«äº‰å¤„ç†ç­–ç•¥](#4-é”ç«äº‰å¤„ç†ç­–ç•¥)
5. [é”æœåŠ¡é«˜å¯ç”¨è®¾è®¡](#5-é”æœåŠ¡é«˜å¯ç”¨è®¾è®¡)
6. [é”æ€§èƒ½ç›‘æ§](#6-é”æ€§èƒ½ç›‘æ§)
7. [åˆ†å¸ƒå¼é”æœ€ä½³å®è·µ](#7-åˆ†å¸ƒå¼é”æœ€ä½³å®è·µ)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ¯ åˆ†å¸ƒå¼é”å¿…è¦æ€§åˆ†æ


### 1.1 ä»€ä¹ˆæ˜¯åˆ†å¸ƒå¼é”


> ğŸ’¡ **æ ¸å¿ƒæ¦‚å¿µ**  
> åˆ†å¸ƒå¼é”æ˜¯åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œå¤šä¸ªè¿›ç¨‹æˆ–æœåŠ¡éœ€è¦è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œç¡®ä¿åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªè¿›ç¨‹èƒ½å¤Ÿè®¿é—®è¯¥èµ„æºçš„æœºåˆ¶

**ğŸ”¸ åˆ†å¸ƒå¼é”è§£å†³çš„é—®é¢˜**
```
å•æœºç¯å¢ƒ vs åˆ†å¸ƒå¼ç¯å¢ƒï¼š

å•æœºç¯å¢ƒï¼š
è¿›ç¨‹A â”€â”€â”
        â”œâ”€â”€ å…±äº«å†…å­˜/æ–‡ä»¶ â”€â”€ æœ¬åœ°é”ï¼ˆsynchronzied/mutexï¼‰
è¿›ç¨‹B â”€â”€â”˜

åˆ†å¸ƒå¼ç¯å¢ƒï¼š
æœåŠ¡å™¨A[è¿›ç¨‹1] â”€â”€â”
               â”œâ”€â”€ ç½‘ç»œ â”€â”€ å…±äº«èµ„æº â”€â”€ åˆ†å¸ƒå¼é”
æœåŠ¡å™¨B[è¿›ç¨‹2] â”€â”€â”˜

é—®é¢˜ï¼šä¼ ç»Ÿçš„æœ¬åœ°é”æ— æ³•è·¨è¿›ç¨‹ã€è·¨æœåŠ¡å™¨å·¥ä½œ
è§£å†³ï¼šéœ€è¦ä¸€ä¸ªå¤–éƒ¨çš„åè°ƒæœºåˆ¶æ¥ç®¡ç†é”
```

### 1.2 åˆ†å¸ƒå¼é”çš„å…¸å‹åº”ç”¨åœºæ™¯


**ğŸ”¸ ä¸šåŠ¡åœºæ™¯åˆ†æ**

| åº”ç”¨åœºæ™¯ | **å¹¶å‘é—®é¢˜** | **ä½¿ç”¨åˆ†å¸ƒå¼é”çš„å¿…è¦æ€§** | **ä¸ä½¿ç”¨çš„åæœ** |
|---------|-------------|------------------------|----------------|
| ğŸ›’ **åº“å­˜æ‰£å‡** | `å¤šä¸ªç”¨æˆ·åŒæ—¶è´­ä¹°åŒä¸€å•†å“` | `é˜²æ­¢è¶…å–` | `åº“å­˜è´Ÿæ•°ï¼Œèµ„æŸä¸¥é‡` |
| ğŸ« **ä¼˜æƒ åˆ¸å‘æ”¾** | `é™é‡ä¼˜æƒ åˆ¸è¢«é‡å¤é¢†å–` | `ä¿è¯å‘æ”¾æ•°é‡å‡†ç¡®` | `æˆæœ¬è¶…é¢„ç®—` |
| ğŸ“Š **è®¢å•å·ç”Ÿæˆ** | `å¤šæœåŠ¡ç”Ÿæˆé‡å¤è®¢å•å·` | `ç¡®ä¿å…¨å±€å”¯ä¸€æ€§` | `è®¢å•å†²çªï¼Œç³»ç»Ÿå¼‚å¸¸` |
| ğŸ’° **è´¦æˆ·ä½™é¢æ“ä½œ** | `åŒæ—¶è½¬è´¦å’Œæç°` | `ä¿è¯ä½™é¢è®¡ç®—æ­£ç¡®` | `èµ„é‡‘ä¸ä¸€è‡´` |
| ğŸ® **æ¸¸æˆå‰¯æœ¬åˆ›å»º** | `å¤šäººåŒæ—¶åˆ›å»ºå‰¯æœ¬` | `æ§åˆ¶å‰¯æœ¬æ•°é‡` | `èµ„æºæµªè´¹` |

**ğŸ’» åº“å­˜æ‰£å‡å…¸å‹åœºæ™¯**
```java
// æ²¡æœ‰åˆ†å¸ƒå¼é”çš„å±é™©ä»£ç 
public boolean decreaseStock(Long productId, Integer quantity) {
    // 1. æŸ¥è¯¢å½“å‰åº“å­˜
    Integer currentStock = productMapper.getStock(productId);
    
    // 2. åˆ¤æ–­åº“å­˜æ˜¯å¦å……è¶³ï¼ˆå±é™©ï¼šå¤šä¸ªçº¿ç¨‹éƒ½å¯èƒ½é€šè¿‡è¿™ä¸ªæ£€æŸ¥ï¼‰
    if (currentStock >= quantity) {
        // 3. æ‰£å‡åº“å­˜ï¼ˆå±é™©ï¼šå¯èƒ½å¯¼è‡´è¶…å–ï¼‰
        productMapper.updateStock(productId, currentStock - quantity);
        return true;
    }
    return false;
}

// ä½¿ç”¨åˆ†å¸ƒå¼é”çš„å®‰å…¨ä»£ç 
public boolean decreaseStockSafely(Long productId, Integer quantity) {
    String lockKey = "stock_lock_" + productId;
    
    // è·å–åˆ†å¸ƒå¼é”
    if (distributedLock.tryLock(lockKey, 30, TimeUnit.SECONDS)) {
        try {
            // åœ¨é”ä¿æŠ¤ä¸‹æ‰§è¡Œåº“å­˜æ“ä½œ
            Integer currentStock = productMapper.getStock(productId);
            if (currentStock >= quantity) {
                productMapper.updateStock(productId, currentStock - quantity);
                return true;
            }
            return false;
        } finally {
            // ç¡®ä¿é‡Šæ”¾é”
            distributedLock.unlock(lockKey);
        }
    }
    return false; // è·å–é”å¤±è´¥
}
```

### 1.3 åˆ†å¸ƒå¼é”çš„æ ¸å¿ƒç‰¹å¾


**ğŸ”¸ åˆ†å¸ƒå¼é”å¿…é¡»å…·å¤‡çš„ç‰¹æ€§**
```
ğŸ” äº’æ–¥æ€§ï¼ˆMutual Exclusionï¼‰ï¼š
â€¢ åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªè¿›ç¨‹èƒ½æŒæœ‰é”
â€¢ è¿™æ˜¯é”çš„æœ€åŸºæœ¬ç‰¹æ€§

ğŸ”“ å¯é‡Šæ”¾ï¼ˆReleasableï¼‰ï¼š
â€¢ æŒæœ‰é”çš„è¿›ç¨‹èƒ½å¤Ÿä¸»åŠ¨é‡Šæ”¾é”
â€¢ ç³»ç»Ÿå¼‚å¸¸æ—¶é”èƒ½å¤Ÿè‡ªåŠ¨é‡Šæ”¾

â° é˜²æ­»é”ï¼ˆDeadlock Freeï¼‰ï¼š
â€¢ é”å¿…é¡»æœ‰è¶…æ—¶æœºåˆ¶
â€¢ é¿å…è¿›ç¨‹å¼‚å¸¸å¯¼è‡´é”æ°¸è¿œä¸é‡Šæ”¾

ğŸ¯ å®¹é”™æ€§ï¼ˆFault Tolerantï¼‰ï¼š
â€¢ é”æœåŠ¡æœ¬èº«è¦é«˜å¯ç”¨
â€¢ å•ç‚¹æ•…éšœä¸èƒ½å½±å“æ•´ä¸ªç³»ç»Ÿ

âš¡ é«˜æ€§èƒ½ï¼ˆHigh Performanceï¼‰ï¼š
â€¢ åŠ é”è§£é”æ“ä½œè¦è¶³å¤Ÿå¿«
â€¢ ä¸èƒ½æˆä¸ºç³»ç»Ÿæ€§èƒ½ç“¶é¢ˆ
```

### 1.4 åˆ†å¸ƒå¼é”å®ç°æ–¹æ¡ˆå¯¹æ¯”


**ğŸ”¸ ä¸»æµå®ç°æ–¹æ¡ˆ**

| å®ç°æ–¹æ¡ˆ | **ä¼˜åŠ¿** | **åŠ£åŠ¿** | **é€‚ç”¨åœºæ™¯** |
|---------|---------|---------|-------------|
| ğŸ—„ï¸ **æ•°æ®åº“é”** | `ç®€å•æ˜“å®ç°ï¼Œäº‹åŠ¡æ”¯æŒ` | `æ€§èƒ½ç›¸å¯¹è¾ƒä½ï¼Œå•ç‚¹é£é™©` | `å¯¹æ€§èƒ½è¦æ±‚ä¸é«˜çš„åœºæ™¯` |
| ğŸ”´ **Redisé”** | `æ€§èƒ½é«˜ï¼Œæ”¯æŒè¿‡æœŸæ—¶é—´` | `å¯èƒ½ä¸¢å¤±é”ï¼Œéœ€è¦è€ƒè™‘ä¸»ä»åˆ‡æ¢` | `é«˜å¹¶å‘ï¼Œå¯¹æ€§èƒ½è¦æ±‚é«˜` |
| ğŸ“‹ **Zookeeperé”** | `å¼ºä¸€è‡´æ€§ï¼Œæ”¯æŒç›‘å¬` | `æ€§èƒ½ä¸€èˆ¬ï¼Œè¿ç»´å¤æ‚` | `å¯¹ä¸€è‡´æ€§è¦æ±‚æé«˜` |
| â˜ï¸ **ETCDé”** | `å¼ºä¸€è‡´æ€§ï¼Œäº‘åŸç”Ÿ` | `æ–°æŠ€æœ¯ï¼Œç”Ÿæ€ç›¸å¯¹è¾ƒå°‘` | `K8sç¯å¢ƒï¼Œäº‘åŸç”Ÿåº”ç”¨` |

---

## 2. ğŸ—„ï¸ åŸºäºMySQLçš„åˆ†å¸ƒå¼é”


### 2.1 MySQLåˆ†å¸ƒå¼é”å®ç°åŸç†


> ğŸ’¡ **å®ç°æ€è·¯**  
> åˆ©ç”¨MySQLçš„å”¯ä¸€ç´¢å¼•ç‰¹æ€§ï¼Œé€šè¿‡INSERTæ“ä½œçš„æˆåŠŸä¸å¦æ¥åˆ¤æ–­æ˜¯å¦è·å–åˆ°é”

**ğŸ”¸ æ•°æ®åº“é”è¡¨è®¾è®¡**
```sql
-- åˆ†å¸ƒå¼é”è¡¨ç»“æ„
CREATE TABLE distributed_locks (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    lock_name VARCHAR(255) NOT NULL COMMENT 'é”åç§°',
    lock_value VARCHAR(255) NOT NULL COMMENT 'é”æŒæœ‰è€…æ ‡è¯†',
    expire_time TIMESTAMP NOT NULL COMMENT 'é”è¿‡æœŸæ—¶é—´',
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- æ ¸å¿ƒï¼šé”åç§°å”¯ä¸€ç´¢å¼•ï¼Œä¿è¯åŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªé”
    UNIQUE KEY uk_lock_name (lock_name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='åˆ†å¸ƒå¼é”è¡¨';

-- ç¤ºä¾‹æ•°æ®
INSERT INTO distributed_locks (lock_name, lock_value, expire_time) 
VALUES ('stock_lock_12345', 'server-001-thread-123', '2024-01-01 12:30:00');
```

### 2.2 åŸºç¡€åŠ é”å®ç°


**ğŸ’» Javaå®ç°ç¤ºä¾‹**
```java
@Component
public class MySQLDistributedLock {
    
    @Autowired
    private DistributedLockMapper lockMapper;
    
    /**
     * å°è¯•è·å–é”
     * @param lockName é”åç§°
     * @param lockValue é”æŒæœ‰è€…æ ‡è¯†ï¼ˆé€šå¸¸æ˜¯æœåŠ¡å™¨+çº¿ç¨‹æ ‡è¯†ï¼‰
     * @param expireSeconds é”è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
     * @return æ˜¯å¦æˆåŠŸè·å–é”
     */
    public boolean tryLock(String lockName, String lockValue, int expireSeconds) {
        try {
            // 1. è®¡ç®—è¿‡æœŸæ—¶é—´
            Timestamp expireTime = new Timestamp(
                System.currentTimeMillis() + expireSeconds * 1000
            );
            
            // 2. å°è¯•æ’å…¥é”è®°å½•
            DistributedLockEntity lockEntity = new DistributedLockEntity();
            lockEntity.setLockName(lockName);
            lockEntity.setLockValue(lockValue);
            lockEntity.setExpireTime(expireTime);
            
            int result = lockMapper.insertLock(lockEntity);
            return result > 0;
            
        } catch (DuplicateKeyException e) {
            // å”¯ä¸€ç´¢å¼•å†²çªï¼Œè¯´æ˜é”å·²è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰
            return false;
        }
    }
    
    /**
     * é‡Šæ”¾é”
     * @param lockName é”åç§°
     * @param lockValue é”æŒæœ‰è€…æ ‡è¯†
     * @return æ˜¯å¦æˆåŠŸé‡Šæ”¾
     */
    public boolean unlock(String lockName, String lockValue) {
        // åªèƒ½é‡Šæ”¾è‡ªå·±æŒæœ‰çš„é”
        int result = lockMapper.deleteLock(lockName, lockValue);
        return result > 0;
    }
    
    /**
     * æ¸…ç†è¿‡æœŸé”
     */
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void cleanExpiredLocks() {
        Timestamp currentTime = new Timestamp(System.currentTimeMillis());
        int cleanedCount = lockMapper.deleteExpiredLocks(currentTime);
        if (cleanedCount > 0) {
            log.info("æ¸…ç†è¿‡æœŸé” {} ä¸ª", cleanedCount);
        }
    }
}
```

**ğŸ”¸ å¯¹åº”çš„Mapperå®ç°**
```xml
<!-- DistributedLockMapper.xml -->
<mapper namespace="com.example.mapper.DistributedLockMapper">
    
    <!-- æ’å…¥é”è®°å½• -->
    <insert id="insertLock" parameterType="DistributedLockEntity">
        INSERT INTO distributed_locks (lock_name, lock_value, expire_time)
        VALUES (#{lockName}, #{lockValue}, #{expireTime})
    </insert>
    
    <!-- åˆ é™¤æŒ‡å®šçš„é”ï¼ˆå¿…é¡»åŒ¹é…é”æŒæœ‰è€…ï¼‰ -->
    <delete id="deleteLock">
        DELETE FROM distributed_locks 
        WHERE lock_name = #{lockName} AND lock_value = #{lockValue}
    </delete>
    
    <!-- åˆ é™¤è¿‡æœŸçš„é” -->
    <delete id="deleteExpiredLocks">
        DELETE FROM distributed_locks 
        WHERE expire_time < #{currentTime}
    </delete>
    
    <!-- æŸ¥è¯¢é”ä¿¡æ¯ -->
    <select id="selectLock" resultType="DistributedLockEntity">
        SELECT * FROM distributed_locks 
        WHERE lock_name = #{lockName}
    </select>
    
</mapper>
```

### 2.3 è¿›é˜¶ç‰ˆæœ¬ï¼šæ”¯æŒé‡å…¥é”


**ğŸ”¸ é‡å…¥é”è¡¨è®¾è®¡**
```sql
-- æ”¯æŒé‡å…¥çš„é”è¡¨ï¼ˆå¢åŠ é‡å…¥æ¬¡æ•°å­—æ®µï¼‰
CREATE TABLE reentrant_locks (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    lock_name VARCHAR(255) NOT NULL,
    lock_value VARCHAR(255) NOT NULL,
    reentrant_count INT DEFAULT 1 COMMENT 'é‡å…¥æ¬¡æ•°',
    expire_time TIMESTAMP NOT NULL,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_lock_name (lock_name),
    INDEX idx_expire_time (expire_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**ğŸ’» é‡å…¥é”å®ç°**
```java
public class MySQLReentrantLock {
    
    /**
     * å¯é‡å…¥åŠ é”
     */
    public boolean tryLock(String lockName, String lockValue, int expireSeconds) {
        try {
            // 1. å…ˆå°è¯•æ’å…¥æ–°é”
            return insertNewLock(lockName, lockValue, expireSeconds);
            
        } catch (DuplicateKeyException e) {
            // 2. æ’å…¥å¤±è´¥ï¼Œæ£€æŸ¥æ˜¯å¦ä¸ºåŒä¸€æŒæœ‰è€…çš„é‡å…¥
            return tryReentrantLock(lockName, lockValue, expireSeconds);
        }
    }
    
    private boolean insertNewLock(String lockName, String lockValue, int expireSeconds) {
        Timestamp expireTime = new Timestamp(System.currentTimeMillis() + expireSeconds * 1000);
        
        ReentrantLockEntity lockEntity = new ReentrantLockEntity();
        lockEntity.setLockName(lockName);
        lockEntity.setLockValue(lockValue);
        lockEntity.setReentrantCount(1);
        lockEntity.setExpireTime(expireTime);
        
        return lockMapper.insertReentrantLock(lockEntity) > 0;
    }
    
    private boolean tryReentrantLock(String lockName, String lockValue, int expireSeconds) {
        // æ£€æŸ¥ç°æœ‰é”çš„æŒæœ‰è€…
        ReentrantLockEntity existingLock = lockMapper.selectLock(lockName);
        
        if (existingLock == null) {
            // é”ä¸å­˜åœ¨ï¼Œå¯èƒ½å·²è¿‡æœŸè¢«æ¸…ç†ï¼Œé‡æ–°å°è¯•åŠ é”
            return tryLock(lockName, lockValue, expireSeconds);
        }
        
        // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        if (existingLock.getExpireTime().before(new Timestamp(System.currentTimeMillis()))) {
            // é”å·²è¿‡æœŸï¼Œåˆ é™¤åé‡æ–°åŠ é”
            lockMapper.deleteLock(lockName, existingLock.getLockValue());
            return tryLock(lockName, lockValue, expireSeconds);
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºåŒä¸€æŒæœ‰è€…
        if (lockValue.equals(existingLock.getLockValue())) {
            // é‡å…¥é”ï¼Œå¢åŠ é‡å…¥æ¬¡æ•°
            Timestamp newExpireTime = new Timestamp(System.currentTimeMillis() + expireSeconds * 1000);
            return lockMapper.incrementReentrantCount(lockName, lockValue, newExpireTime) > 0;
        }
        
        // ä¸åŒæŒæœ‰è€…ï¼ŒåŠ é”å¤±è´¥
        return false;
    }
    
    /**
     * å¯é‡å…¥è§£é”
     */
    public boolean unlock(String lockName, String lockValue) {
        ReentrantLockEntity existingLock = lockMapper.selectLock(lockName);
        
        if (existingLock == null || !lockValue.equals(existingLock.getLockValue())) {
            return false; // é”ä¸å­˜åœ¨æˆ–ä¸æ˜¯è‡ªå·±æŒæœ‰çš„
        }
        
        if (existingLock.getReentrantCount() <= 1) {
            // é‡å…¥æ¬¡æ•°ä¸º1ï¼Œå®Œå…¨é‡Šæ”¾é”
            return lockMapper.deleteLock(lockName, lockValue) > 0;
        } else {
            // é‡å…¥æ¬¡æ•°å¤§äº1ï¼Œå‡å°‘é‡å…¥æ¬¡æ•°
            return lockMapper.decrementReentrantCount(lockName, lockValue) > 0;
        }
    }
}
```

### 2.4 MySQLé”çš„ä¼˜ç¼ºç‚¹åˆ†æ


**âœ… ä¼˜åŠ¿**
```
ğŸ”¸ äº‹åŠ¡æ”¯æŒï¼š
â€¢ å¤©ç„¶æ”¯æŒACIDç‰¹æ€§
â€¢ å¯ä»¥ä¸ä¸šåŠ¡æ“ä½œåœ¨åŒä¸€äº‹åŠ¡ä¸­
â€¢ å›æ»šæ—¶é”ä¹Ÿä¼šè‡ªåŠ¨é‡Šæ”¾

ğŸ”¸ å®ç°ç®€å•ï¼š
â€¢ ä¸éœ€è¦é¢å¤–çš„ç»„ä»¶
â€¢ åˆ©ç”¨ç°æœ‰çš„MySQLåŸºç¡€è®¾æ–½
â€¢ å¼€å‘å’Œç»´æŠ¤æˆæœ¬ä½

ğŸ”¸ å¯é æ€§é«˜ï¼š
â€¢ MySQLçš„å¯é æ€§ç»è¿‡å……åˆ†éªŒè¯
â€¢ æ”¯æŒä¸»ä»å¤åˆ¶å’Œé«˜å¯ç”¨æ–¹æ¡ˆ
```

**âŒ åŠ£åŠ¿**
```
ğŸ”¸ æ€§èƒ½é™åˆ¶ï¼š
â€¢ æ•°æ®åº“IOæ“ä½œç›¸å¯¹è¾ƒæ…¢
â€¢ ä¸é€‚åˆé«˜é¢‘æ¬¡çš„åŠ é”è§£é”

ğŸ”¸ å•ç‚¹é£é™©ï¼š
â€¢ ä¾èµ–å•ä¸ªMySQLå®ä¾‹
â€¢ æ•°æ®åº“æ•…éšœä¼šå½±å“é”æœåŠ¡

ğŸ”¸ èµ„æºæ¶ˆè€—ï¼š
â€¢ æ¯ä¸ªé”éƒ½è¦å ç”¨æ•°æ®åº“è¿æ¥
â€¢ å¤§é‡é”æ“ä½œä¼šå¢åŠ æ•°æ®åº“å‹åŠ›
```

---

## 3. â° é”è¶…æ—¶ä¸ç»­æœŸæœºåˆ¶


### 3.1 ä¸ºä»€ä¹ˆéœ€è¦é”è¶…æ—¶


> ğŸ’¡ **è¶…æ—¶æœºåˆ¶çš„é‡è¦æ€§**  
> é˜²æ­¢è¿›ç¨‹å¼‚å¸¸é€€å‡ºå¯¼è‡´é”æ°¸è¿œä¸è¢«é‡Šæ”¾ï¼Œè¿™æ˜¯åˆ†å¸ƒå¼é”è®¾è®¡ä¸­çš„å…³é”®å®‰å…¨æœºåˆ¶

**ğŸ”¸ æ²¡æœ‰è¶…æ—¶æœºåˆ¶çš„é—®é¢˜**
```
é—®é¢˜åœºæ™¯æ¼”ç¤ºï¼š

æ—¶é—´çº¿ï¼š
10:00:00 - è¿›ç¨‹Aè·å–é” "stock_lock_12345"
10:00:05 - è¿›ç¨‹Aå¼€å§‹æ‰§è¡Œä¸šåŠ¡é€»è¾‘
10:00:10 - è¿›ç¨‹Aæ‰€åœ¨æœåŠ¡å™¨çªç„¶å®•æœº ğŸ’¥
10:00:15 - è¿›ç¨‹Bå°è¯•è·å–åŒæ ·çš„é” âŒ å¤±è´¥
10:00:20 - è¿›ç¨‹Cå°è¯•è·å–åŒæ ·çš„é” âŒ å¤±è´¥
...      - é”æ°¸è¿œæ— æ³•è·å–ï¼Œç³»ç»Ÿæ­»é”

åæœï¼š
â€¢ ç›¸å…³ä¸šåŠ¡åŠŸèƒ½å®Œå…¨åœæ­¢å·¥ä½œ
â€¢ éœ€è¦æ‰‹åŠ¨å¹²é¢„æ‰èƒ½æ¢å¤
â€¢ ä¸¥é‡å½±å“ç³»ç»Ÿå¯ç”¨æ€§
```

### 3.2 åŸºç¡€è¶…æ—¶æœºåˆ¶å®ç°


**ğŸ’» å¸¦è¶…æ—¶çš„é”å®ç°**
```java
public class TimeoutDistributedLock {
    
    private static final int DEFAULT_EXPIRE_SECONDS = 30; // é»˜è®¤30ç§’è¶…æ—¶
    
    /**
     * å¸¦è¶…æ—¶çš„åŠ é”æ–¹æ³•
     */
    public boolean tryLock(String lockName, String lockValue) {
        return tryLock(lockName, lockValue, DEFAULT_EXPIRE_SECONDS);
    }
    
    public boolean tryLock(String lockName, String lockValue, int expireSeconds) {
        try {
            // 1. æ¸…ç†è¿‡æœŸé”ï¼ˆå…ˆæ¸…ç†å†åŠ é”ï¼Œæé«˜æˆåŠŸç‡ï¼‰
            cleanExpiredLock(lockName);
            
            // 2. å°è¯•æ’å…¥æ–°é”
            Timestamp expireTime = new Timestamp(
                System.currentTimeMillis() + expireSeconds * 1000
            );
            
            DistributedLockEntity lockEntity = new DistributedLockEntity();
            lockEntity.setLockName(lockName);
            lockEntity.setLockValue(lockValue);
            lockEntity.setExpireTime(expireTime);
            
            return lockMapper.insertLock(lockEntity) > 0;
            
        } catch (DuplicateKeyException e) {
            return false;
        }
    }
    
    /**
     * æ¸…ç†æŒ‡å®šåç§°çš„è¿‡æœŸé”
     */
    private void cleanExpiredLock(String lockName) {
        Timestamp currentTime = new Timestamp(System.currentTimeMillis());
        lockMapper.deleteExpiredLockByName(lockName, currentTime);
    }
    
    /**
     * æ£€æŸ¥é”æ˜¯å¦è¿‡æœŸ
     */
    public boolean isLockExpired(String lockName) {
        DistributedLockEntity lock = lockMapper.selectLock(lockName);
        if (lock == null) {
            return true; // é”ä¸å­˜åœ¨ï¼Œè®¤ä¸ºå·²è¿‡æœŸ
        }
        
        return lock.getExpireTime().before(new Timestamp(System.currentTimeMillis()));
    }
}
```

### 3.3 é”ç»­æœŸæœºåˆ¶è®¾è®¡


> ğŸ’¡ **ç»­æœŸæœºåˆ¶åŸç†**  
> å¯¹äºæ‰§è¡Œæ—¶é—´è¾ƒé•¿çš„ä»»åŠ¡ï¼Œé€šè¿‡å®šæœŸå»¶é•¿é”çš„è¿‡æœŸæ—¶é—´ï¼Œç¡®ä¿ä»»åŠ¡å®Œæˆå‰é”ä¸ä¼šè¿‡æœŸ

**ğŸ”¸ ç»­æœŸæœºåˆ¶æ¶æ„**
```
é”ç»­æœŸå·¥ä½œæµç¨‹ï¼š

ä¸»çº¿ç¨‹                     ç»­æœŸçº¿ç¨‹
   |                         |
   |-- è·å–é” ----------------â”
   |                         |
   |-- å¼€å§‹ä¸šåŠ¡å¤„ç†           |-- å¯åŠ¨ç»­æœŸä»»åŠ¡
   |                         |
   |-- æ‰§è¡Œä¸­...             |-- æ£€æŸ¥é”çŠ¶æ€
   |                         |
   |-- ä»åœ¨æ‰§è¡Œ...           |-- å»¶é•¿è¿‡æœŸæ—¶é—´
   |                         |
   |-- å®Œæˆä¸šåŠ¡å¤„ç†           |-- ç»§ç»­ç»­æœŸ...
   |                         |
   |-- é‡Šæ”¾é” ----------------â”-- åœæ­¢ç»­æœŸä»»åŠ¡
   |                         |
   â†“                         â†“
  ç»“æŸ                      ç»“æŸ
```

**ğŸ’» ç»­æœŸæœºåˆ¶å®ç°**
```java
@Component
public class RenewableDistributedLock {
    
    private final ScheduledExecutorService renewExecutor = 
        Executors.newScheduledThreadPool(5);
    
    // å­˜å‚¨ç»­æœŸä»»åŠ¡çš„å¼•ç”¨ï¼Œç”¨äºå–æ¶ˆ
    private final ConcurrentHashMap<String, ScheduledFuture<?>> renewTasks = 
        new ConcurrentHashMap<>();
    
    /**
     * å¸¦è‡ªåŠ¨ç»­æœŸçš„åŠ é”
     */
    public boolean tryLockWithRenewal(String lockName, String lockValue, 
                                     int initialExpireSeconds) {
        // 1. å…ˆå°è¯•è·å–é”
        if (!tryLock(lockName, lockValue, initialExpireSeconds)) {
            return false;
        }
        
        // 2. å¯åŠ¨ç»­æœŸä»»åŠ¡
        startRenewalTask(lockName, lockValue, initialExpireSeconds);
        return true;
    }
    
    /**
     * å¯åŠ¨ç»­æœŸä»»åŠ¡
     */
    private void startRenewalTask(String lockName, String lockValue, int expireSeconds) {
        // ç»­æœŸé—´éš”ä¸ºè¿‡æœŸæ—¶é—´çš„1/3ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„å®‰å…¨è¾¹é™…
        long renewalInterval = expireSeconds * 1000 / 3;
        
        ScheduledFuture<?> renewalTask = renewExecutor.scheduleAtFixedRate(() -> {
            try {
                renewLock(lockName, lockValue, expireSeconds);
            } catch (Exception e) {
                log.error("é”ç»­æœŸå¤±è´¥: lockName={}, error={}", lockName, e.getMessage());
                // ç»­æœŸå¤±è´¥ä¸æŠ›å¼‚å¸¸ï¼Œé¿å…å½±å“å®šæ—¶ä»»åŠ¡
            }
        }, renewalInterval, renewalInterval, TimeUnit.MILLISECONDS);
        
        // ä¿å­˜ä»»åŠ¡å¼•ç”¨ï¼Œç”¨äºåç»­å–æ¶ˆ
        renewTasks.put(lockName + ":" + lockValue, renewalTask);
    }
    
    /**
     * ç»­æœŸæ“ä½œ
     */
    private void renewLock(String lockName, String lockValue, int expireSeconds) {
        Timestamp newExpireTime = new Timestamp(
            System.currentTimeMillis() + expireSeconds * 1000
        );
        
        int updated = lockMapper.renewLock(lockName, lockValue, newExpireTime);
        if (updated > 0) {
            log.debug("é”ç»­æœŸæˆåŠŸ: lockName={}", lockName);
        } else {
            log.warn("é”ç»­æœŸå¤±è´¥ï¼Œå¯èƒ½é”å·²è¢«é‡Šæ”¾: lockName={}", lockName);
        }
    }
    
    /**
     * é‡Šæ”¾é”å¹¶åœæ­¢ç»­æœŸ
     */
    public boolean unlockWithRenewal(String lockName, String lockValue) {
        try {
            // 1. åœæ­¢ç»­æœŸä»»åŠ¡
            stopRenewalTask(lockName, lockValue);
            
            // 2. é‡Šæ”¾é”
            return unlock(lockName, lockValue);
            
        } catch (Exception e) {
            log.error("é‡Šæ”¾é”æ—¶å‘ç”Ÿå¼‚å¸¸: lockName={}, error={}", lockName, e.getMessage());
            return false;
        }
    }
    
    /**
     * åœæ­¢ç»­æœŸä»»åŠ¡
     */
    private void stopRenewalTask(String lockName, String lockValue) {
        String taskKey = lockName + ":" + lockValue;
        ScheduledFuture<?> renewalTask = renewTasks.remove(taskKey);
        
        if (renewalTask != null && !renewalTask.isCancelled()) {
            renewalTask.cancel(false);
            log.debug("å·²åœæ­¢é”ç»­æœŸä»»åŠ¡: lockName={}", lockName);
        }
    }
}
```

### 3.4 æ™ºèƒ½è¶…æ—¶æ—¶é—´è®¡ç®—


**ğŸ”¸ åŠ¨æ€è¶…æ—¶æ—¶é—´ç­–ç•¥**
```java
@Component
public class SmartTimeoutCalculator {
    
    // è®°å½•ä¸åŒä¸šåŠ¡æ“ä½œçš„å†å²æ‰§è¡Œæ—¶é—´
    private final Map<String, List<Long>> executionHistory = new ConcurrentHashMap<>();
    
    /**
     * åŸºäºå†å²æ•°æ®è®¡ç®—åˆé€‚çš„è¶…æ—¶æ—¶é—´
     */
    public int calculateTimeout(String businessType) {
        List<Long> history = executionHistory.get(businessType);
        
        if (history == null || history.isEmpty()) {
            return 30; // é»˜è®¤30ç§’
        }
        
        // è®¡ç®—å¹³å‡æ‰§è¡Œæ—¶é—´
        long avgTime = history.stream().mapToLong(Long::longValue).sum() / history.size();
        
        // è®¡ç®—95åˆ†ä½æ•°
        List<Long> sortedHistory = new ArrayList<>(history);
        Collections.sort(sortedHistory);
        int p95Index = (int) (sortedHistory.size() * 0.95);
        long p95Time = sortedHistory.get(Math.min(p95Index, sortedHistory.size() - 1));
        
        // è¶…æ—¶æ—¶é—´ = 95åˆ†ä½æ•° + å®‰å…¨è¾¹é™…(50%)
        long timeoutMillis = p95Time + (p95Time / 2);
        int timeoutSeconds = (int) (timeoutMillis / 1000);
        
        // é™åˆ¶åœ¨åˆç†èŒƒå›´å†…
        return Math.max(10, Math.min(timeoutSeconds, 300)); // 10ç§’åˆ°5åˆ†é’Ÿ
    }
    
    /**
     * è®°å½•ä¸šåŠ¡æ‰§è¡Œæ—¶é—´
     */
    public void recordExecutionTime(String businessType, long executionTimeMs) {
        executionHistory.computeIfAbsent(businessType, k -> new ArrayList<>()).add(executionTimeMs);
        
        // é™åˆ¶å†å²è®°å½•æ•°é‡ï¼Œé¿å…å†…å­˜æ³„æ¼
        List<Long> history = executionHistory.get(businessType);
        if (history.size() > 100) {
            history.remove(0); // ç§»é™¤æœ€æ—§çš„è®°å½•
        }
    }
}
```

---

## 4. ğŸ é”ç«äº‰å¤„ç†ç­–ç•¥


### 4.1 é”ç«äº‰åœºæ™¯åˆ†æ


> ğŸ’¡ **ç«äº‰é—®é¢˜**  
> åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼Œå¤šä¸ªè¿›ç¨‹åŒæ—¶ç«äº‰åŒä¸€ä¸ªé”èµ„æºæ—¶ï¼Œéœ€è¦åˆç†çš„ç­–ç•¥æ¥å¤„ç†ç«äº‰ï¼Œé¿å…ç³»ç»Ÿæ€§èƒ½ä¸‹é™

**ğŸ”¸ å…¸å‹ç«äº‰åœºæ™¯**
```
é«˜å¹¶å‘æŠ¢è´­åœºæ™¯ï¼š

æ—¶é—´: 10:00:00 ç§’æ€å¼€å§‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1000ä¸ªç”¨æˆ·åŒæ—¶ç‚¹å‡»è´­ä¹°               â”‚
â”‚     â†“ â†“ â†“ â†“ â†“ â†“ â†“                  â”‚
â”‚ æœåŠ¡å™¨A: 100ä¸ªçº¿ç¨‹                   â”‚
â”‚ æœåŠ¡å™¨B: 100ä¸ªçº¿ç¨‹                   â”‚  
â”‚ æœåŠ¡å™¨C: 100ä¸ªçº¿ç¨‹                   â”‚
â”‚     â†“                               â”‚
â”‚ éƒ½å°è¯•è·å– "stock_lock_12345"       â”‚
â”‚     â†“                               â”‚
â”‚ åªæœ‰1ä¸ªçº¿ç¨‹èƒ½æˆåŠŸï¼Œ999ä¸ªçº¿ç¨‹ç­‰å¾…      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é—®é¢˜ï¼š
â€¢ å¤§é‡çº¿ç¨‹é˜»å¡ç­‰å¾…
â€¢ æ•°æ®åº“è¿æ¥æ± è¢«å æ»¡
â€¢ ç³»ç»Ÿå“åº”å˜æ…¢
â€¢ ç”¨æˆ·ä½“éªŒä¸‹é™
```

### 4.2 éé˜»å¡å¼ç«äº‰ç­–ç•¥


**ğŸ”¸ ç«‹å³å¤±è´¥ç­–ç•¥**
```java
@Service
public class NonBlockingLockService {
    
    /**
     * éé˜»å¡å¼å°è¯•è·å–é”
     * å¤±è´¥ç«‹å³è¿”å›ï¼Œä¸ç­‰å¾…
     */
    public boolean processWithNonBlockingLock(String resourceId) {
        String lockName = "resource_lock_" + resourceId;
        String lockValue = generateLockValue();
        
        // å°è¯•è·å–é”ï¼Œå¤±è´¥ç«‹å³è¿”å›
        if (!distributedLock.tryLock(lockName, lockValue, 30)) {
            log.info("èµ„æºæ­£åœ¨è¢«å¤„ç†ï¼Œè¯·ç¨åé‡è¯•: resourceId={}", resourceId);
            return false; // å¿«é€Ÿå¤±è´¥ï¼Œé¿å…é˜»å¡
        }
        
        try {
            // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
            return processResource(resourceId);
        } finally {
            distributedLock.unlock(lockName, lockValue);
        }
    }
    
    private String generateLockValue() {
        return String.format("%s-%s-%d", 
            getServerId(), 
            Thread.currentThread().getName(), 
            System.currentTimeMillis());
    }
}
```

**ğŸ”¸ é™æ—¶ç­‰å¾…ç­–ç•¥**
```java
public class TimedWaitLockService {
    
    /**
     * å¸¦è¶…æ—¶çš„ç«äº‰é”è·å–
     */
    public boolean processWithTimedWait(String resourceId, int waitTimeoutSeconds) {
        String lockName = "resource_lock_" + resourceId;
        String lockValue = generateLockValue();
        
        long startTime = System.currentTimeMillis();
        long timeout = waitTimeoutSeconds * 1000;
        
        while (System.currentTimeMillis() - startTime < timeout) {
            // å°è¯•è·å–é”
            if (distributedLock.tryLock(lockName, lockValue, 30)) {
                try {
                    return processResource(resourceId);
                } finally {
                    distributedLock.unlock(lockName, lockValue);
                }
            }
            
            // è·å–å¤±è´¥ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
            try {
                Thread.sleep(100 + new Random().nextInt(100)); // éšæœºç­‰å¾…é¿å…æƒŠç¾¤æ•ˆåº”
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        
        log.warn("ç­‰å¾…é”è¶…æ—¶: resourceId={}, waitTime={}s", resourceId, waitTimeoutSeconds);
        return false;
    }
}
```

### 4.3 åˆ†æ®µé”ç­–ç•¥


> ğŸ’¡ **åˆ†æ®µé”æ€æƒ³**  
> å°†å¤§ç²’åº¦çš„é”æ‹†åˆ†æˆå¤šä¸ªå°ç²’åº¦çš„é”ï¼Œå‡å°‘é”ç«äº‰ï¼Œæé«˜å¹¶å‘åº¦

**ğŸ”¸ åº“å­˜åˆ†æ®µé”å®ç°**
```java
@Service
public class SegmentedStockLockService {
    
    private static final int SEGMENT_COUNT = 16; // åˆ†æ®µæ•°é‡
    
    /**
     * åˆ†æ®µåº“å­˜æ‰£å‡
     */
    public boolean decreaseStockWithSegment(Long productId, Integer quantity) {
        // 1. æ ¹æ®äº§å“IDè®¡ç®—åˆ†æ®µ
        int segment = Math.abs(productId.hashCode()) % SEGMENT_COUNT;
        String lockName = String.format("stock_segment_lock_%d_%d", productId, segment);
        String lockValue = generateLockValue();
        
        if (!distributedLock.tryLock(lockName, lockValue, 30)) {
            return false;
        }
        
        try {
            // 2. æ“ä½œå¯¹åº”åˆ†æ®µçš„åº“å­˜
            return decreaseSegmentStock(productId, segment, quantity);
        } finally {
            distributedLock.unlock(lockName, lockValue);
        }
    }
    
    private boolean decreaseSegmentStock(Long productId, int segment, Integer quantity) {
        // æŸ¥è¯¢è¯¥åˆ†æ®µçš„åº“å­˜
        Integer segmentStock = stockMapper.getSegmentStock(productId, segment);
        
        if (segmentStock >= quantity) {
            // æ‰£å‡åˆ†æ®µåº“å­˜
            stockMapper.decreaseSegmentStock(productId, segment, quantity);
            return true;
        }
        
        // å½“å‰åˆ†æ®µåº“å­˜ä¸è¶³ï¼Œå°è¯•ä»å…¶ä»–åˆ†æ®µå€Ÿç”¨
        return borrowFromOtherSegments(productId, segment, quantity);
    }
    
    /**
     * ä»å…¶ä»–åˆ†æ®µå€Ÿç”¨åº“å­˜
     */
    private boolean borrowFromOtherSegments(Long productId, int currentSegment, Integer quantity) {
        for (int i = 0; i < SEGMENT_COUNT; i++) {
            if (i == currentSegment) continue;
            
            String borrowLockName = String.format("stock_segment_lock_%d_%d", productId, i);
            String lockValue = generateLockValue();
            
            if (distributedLock.tryLock(borrowLockName, lockValue, 5)) {
                try {
                    Integer segmentStock = stockMapper.getSegmentStock(productId, i);
                    if (segmentStock >= quantity) {
                        stockMapper.decreaseSegmentStock(productId, i, quantity);
                        return true;
                    }
                } finally {
                    distributedLock.unlock(borrowLockName, lockValue);
                }
            }
        }
        
        return false; // æ‰€æœ‰åˆ†æ®µéƒ½æ²¡æœ‰è¶³å¤Ÿåº“å­˜
    }
}
```

### 4.4 ä¼˜å…ˆçº§é˜Ÿåˆ—ç­–ç•¥


**ğŸ”¸ åŸºäºä¼˜å…ˆçº§çš„é”è·å–**
```java
@Component
public class PriorityLockQueue {
    
    // ä¸åŒä¸šåŠ¡çš„ä¼˜å…ˆçº§é…ç½®
    private final Map<String, Integer> businessPriority = Map.of(
        "VIP_ORDER", 1,      // æœ€é«˜ä¼˜å…ˆçº§
        "NORMAL_ORDER", 5,   // æ™®é€šä¼˜å…ˆçº§
        "BATCH_TASK", 10     // æœ€ä½ä¼˜å…ˆçº§
    );
    
    /**
     * åŸºäºä¼˜å…ˆçº§çš„é”ç«äº‰
     */
    public boolean processWithPriority(String resourceId, String businessType) {
        String lockName = "resource_lock_" + resourceId;
        String lockValue = generateLockValue();
        int priority = businessPriority.getOrDefault(businessType, 5);
        
        // è®°å½•ç«äº‰è€…ä¿¡æ¯åˆ°æ•°æ®åº“
        recordLockCompetitor(lockName, lockValue, priority);
        
        try {
            return waitForLockByPriority(lockName, lockValue, priority);
        } finally {
            // æ¸…ç†ç«äº‰è€…è®°å½•
            removeLockCompetitor(lockName, lockValue);
        }
    }
    
    private boolean waitForLockByPriority(String lockName, String lockValue, int priority) {
        long startTime = System.currentTimeMillis();
        long maxWaitTime = calculateMaxWaitTime(priority); // ä¼˜å…ˆçº§è¶Šé«˜ï¼Œç­‰å¾…æ—¶é—´è¶Šé•¿
        
        while (System.currentTimeMillis() - startTime < maxWaitTime) {
            // æ£€æŸ¥æ˜¯å¦è½®åˆ°è‡ªå·±è·å–é”
            if (isMyTurnToGetLock(lockName, lockValue)) {
                if (distributedLock.tryLock(lockName, lockValue, 30)) {
                    return true;
                }
            }
            
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        
        return false;
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦è½®åˆ°å½“å‰ç«äº‰è€…è·å–é”
     */
    private boolean isMyTurnToGetLock(String lockName, String lockValue) {
        // æŸ¥è¯¢æ‰€æœ‰ç­‰å¾…è¯¥é”çš„ç«äº‰è€…ï¼ŒæŒ‰ä¼˜å…ˆçº§å’Œç­‰å¾…æ—¶é—´æ’åº
        List<LockCompetitor> competitors = lockCompetitorMapper
            .getCompetitorsByLockName(lockName);
        
        if (competitors.isEmpty()) return true;
        
        // æ‰¾åˆ°å½“å‰ç«äº‰è€…çš„æ’å
        for (int i = 0; i < competitors.size(); i++) {
            if (lockValue.equals(competitors.get(i).getLockValue())) {
                return i == 0; // æ’åœ¨ç¬¬ä¸€ä½æ‰èƒ½è·å–é”
            }
        }
        
        return false;
    }
}
```

---

## 5. ğŸ—ï¸ é”æœåŠ¡é«˜å¯ç”¨è®¾è®¡


### 5.1 é«˜å¯ç”¨æ¶æ„è®¾è®¡


> ğŸ’¡ **é«˜å¯ç”¨ç›®æ ‡**  
> ç¡®ä¿åˆ†å¸ƒå¼é”æœåŠ¡æœ¬èº«ä¸æˆä¸ºç³»ç»Ÿçš„å•ç‚¹æ•…éšœï¼Œé€šè¿‡å¤šç§æŠ€æœ¯æ‰‹æ®µæä¾›å¯é çš„é”æœåŠ¡

**ğŸ”¸ é«˜å¯ç”¨æ¶æ„å›¾**
```
é«˜å¯ç”¨åˆ†å¸ƒå¼é”æ¶æ„ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åº”ç”¨æœåŠ¡é›†ç¾¤                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ æœåŠ¡A   â”‚  â”‚ æœåŠ¡B   â”‚  â”‚ æœåŠ¡C   â”‚  â”‚ æœåŠ¡D   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚           â”‚            â”‚            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              è´Ÿè½½å‡è¡¡å™¨/ä»£ç†å±‚                         â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚         â”‚    é”æœåŠ¡è´Ÿè½½å‡è¡¡                â”‚          â”‚
â”‚         â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  é”æœåŠ¡èŠ‚ç‚¹1     â”‚           â”‚  é”æœåŠ¡èŠ‚ç‚¹2    â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚           â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚ é”ç®¡ç†æœåŠ¡   â”‚ â”‚           â”‚ â”‚ é”ç®¡ç†æœåŠ¡   â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚           â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚        â”‚         â”‚           â”‚       â”‚         â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”   â”‚           â”‚ â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚MySQLä¸»åº“  â”‚   â”‚ â†â”€å¤åˆ¶â”€â”€â”€â†’ â”‚ â”‚MySQLä»åº“  â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚           â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 MySQLä¸»ä»åˆ‡æ¢å¤„ç†


**ğŸ”¸ ä¸»ä»åˆ‡æ¢æ„ŸçŸ¥æœºåˆ¶**
```java
@Component
public class HADistributedLock {
    
    @Autowired
    private List<DataSource> dataSourceList; // ä¸»ä»æ•°æ®æºåˆ—è¡¨
    
    private volatile DataSource currentDataSource;
    private volatile boolean isMaster = true;
    
    /**
     * å¸¦ä¸»ä»åˆ‡æ¢æ„ŸçŸ¥çš„åŠ é”æ“ä½œ
     */
    public boolean tryLockWithHA(String lockName, String lockValue, int expireSeconds) {
        int retryCount = 0;
        int maxRetries = dataSourceList.size();
        
        while (retryCount < maxRetries) {
            try {
                return doTryLock(lockName, lockValue, expireSeconds);
                
            } catch (SQLException e) {
                if (isConnectionError(e)) {
                    log.warn("æ•°æ®åº“è¿æ¥å¼‚å¸¸ï¼Œå°è¯•åˆ‡æ¢æ•°æ®æº: retry={}", retryCount);
                    switchToNextDataSource();
                    retryCount++;
                } else {
                    throw new RuntimeException("åŠ é”æ“ä½œå¤±è´¥", e);
                }
            }
        }
        
        throw new RuntimeException("æ‰€æœ‰æ•°æ®æºå‡ä¸å¯ç”¨");
    }
    
    private boolean doTryLock(String lockName, String lockValue, int expireSeconds) throws SQLException {
        try (Connection conn = getCurrentDataSource().getConnection()) {
            // æ£€æŸ¥å½“å‰æ•°æ®æºæ˜¯å¦ä¸ºä¸»åº“
            if (isMaster || isWritable(conn)) {
                return insertLock(conn, lockName, lockValue, expireSeconds);
            } else {
                // ä»åº“ä¸èƒ½æ‰§è¡Œå†™æ“ä½œï¼Œéœ€è¦åˆ‡æ¢åˆ°ä¸»åº“
                switchToMaster();
                return doTryLock(lockName, lockValue, expireSeconds);
            }
        }
    }
    
    /**
     * æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å¯å†™
     */
    private boolean isWritable(Connection conn) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement("SELECT $$read_only")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1) == 0; // read_only = 0 è¡¨ç¤ºå¯å†™
            }
        }
        return false;
    }
    
    /**
     * åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ•°æ®æº
     */
    private void switchToNextDataSource() {
        int currentIndex = dataSourceList.indexOf(currentDataSource);
        int nextIndex = (currentIndex + 1) % dataSourceList.size();
        
        currentDataSource = dataSourceList.get(nextIndex);
        isMaster = (nextIndex == 0); // å‡è®¾ç¬¬ä¸€ä¸ªæ˜¯ä¸»åº“
        
        log.info("å·²åˆ‡æ¢åˆ°æ•°æ®æº: index={}, isMaster={}", nextIndex, isMaster);
    }
    
    /**
     * å¼ºåˆ¶åˆ‡æ¢åˆ°ä¸»åº“
     */
    private void switchToMaster() {
        currentDataSource = dataSourceList.get(0); // ç¬¬ä¸€ä¸ªæ•°æ®æºä¸ºä¸»åº“
        isMaster = true;
        log.info("å·²åˆ‡æ¢åˆ°ä¸»åº“");
    }
}
```

### 5.3 åˆ†å¸ƒå¼é”æœåŠ¡é›†ç¾¤


**ğŸ”¸ é”æœåŠ¡é›†ç¾¤åŒ–éƒ¨ç½²**
```java
@Service
public class ClusteredLockService {
    
    @Value("${lock.cluster.nodes}")
    private List<String> clusterNodes; // é”æœåŠ¡é›†ç¾¤èŠ‚ç‚¹åˆ—è¡¨
    
    private final LoadBalancer loadBalancer = new RoundRobinLoadBalancer();
    private final CircuitBreaker circuitBreaker = new CircuitBreaker();
    
    /**
     * é›†ç¾¤åŒ–é”æ“ä½œ
     */
    public boolean tryLockInCluster(String lockName, String lockValue, int expireSeconds) {
        List<String> availableNodes = getAvailableNodes();
        
        if (availableNodes.isEmpty()) {
            throw new RuntimeException("æ²¡æœ‰å¯ç”¨çš„é”æœåŠ¡èŠ‚ç‚¹");
        }
        
        // ä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©èŠ‚ç‚¹ï¼Œç¡®ä¿åŒä¸€é”åæ€»æ˜¯è·¯ç”±åˆ°åŒä¸€èŠ‚ç‚¹
        String targetNode = selectNodeByHash(lockName, availableNodes);
        
        return tryLockOnNode(targetNode, lockName, lockValue, expireSeconds);
    }
    
    /**
     * åŸºäºä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©èŠ‚ç‚¹
     */
    private String selectNodeByHash(String lockName, List<String> nodes) {
        int hash = Math.abs(lockName.hashCode());
        int index = hash % nodes.size();
        return nodes.get(index);
    }
    
    /**
     * åœ¨æŒ‡å®šèŠ‚ç‚¹ä¸Šæ‰§è¡Œé”æ“ä½œ
     */
    private boolean tryLockOnNode(String node, String lockName, String lockValue, int expireSeconds) {
        if (!circuitBreaker.allowRequest(node)) {
            log.warn("èŠ‚ç‚¹ç†”æ–­ä¸­ï¼Œè·³è¿‡è¯·æ±‚: node={}", node);
            return tryLockOnFailoverNode(lockName, lockValue, expireSeconds, node);
        }
        
        try {
            // è°ƒç”¨è¿œç¨‹é”æœåŠ¡
            boolean result = remoteLockService.tryLock(node, lockName, lockValue, expireSeconds);
            circuitBreaker.recordSuccess(node);
            return result;
            
        } catch (Exception e) {
            circuitBreaker.recordFailure(node);
            log.error("èŠ‚ç‚¹é”æ“ä½œå¤±è´¥: node={}, error={}", node, e.getMessage());
            
            // æ•…éšœè½¬ç§»åˆ°å…¶ä»–èŠ‚ç‚¹
            return tryLockOnFailoverNode(lockName, lockValue, expireSeconds, node);
        }
    }
    
    /**
     * æ•…éšœè½¬ç§»åˆ°å…¶ä»–èŠ‚ç‚¹
     */
    private boolean tryLockOnFailoverNode(String lockName, String lockValue, 
                                         int expireSeconds, String excludeNode) {
        List<String> failoverNodes = getAvailableNodes().stream()
            .filter(node -> !node.equals(excludeNode))
            .collect(Collectors.toList());
        
        for (String node : failoverNodes) {
            try {
                if (circuitBreaker.allowRequest(node)) {
                    return tryLockOnNode(node, lockName, lockValue, expireSeconds);
                }
            } catch (Exception e) {
                log.warn("æ•…éšœè½¬ç§»èŠ‚ç‚¹ä¹Ÿå¤±è´¥: node={}", node);
            }
        }
        
        return false; // æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¸å¯ç”¨
    }
    
    /**
     * è·å–å¯ç”¨èŠ‚ç‚¹åˆ—è¡¨
     */
    private List<String> getAvailableNodes() {
        return clusterNodes.stream()
            .filter(this::isNodeHealthy)
            .collect(Collectors.toList());
    }
    
    /**
     * æ£€æŸ¥èŠ‚ç‚¹å¥åº·çŠ¶æ€
     */
    private boolean isNodeHealthy(String node) {
        try {
            // å‘é€å¥åº·æ£€æŸ¥è¯·æ±‚
            return remoteLockService.healthCheck(node);
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 5.4 é”çŠ¶æ€ä¸€è‡´æ€§ä¿è¯


**ğŸ”¸ åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„ä¸€è‡´æ€§ç­–ç•¥**
```java
@Component
public class ConsistentLockService {
    
    /**
     * å¤šæ•°æ´¾å†™å…¥ç­–ç•¥
     * è¦æ±‚è¶…è¿‡åŠæ•°èŠ‚ç‚¹å†™å…¥æˆåŠŸæ‰è®¤ä¸ºåŠ é”æˆåŠŸ
     */
    public boolean tryLockWithMajority(String lockName, String lockValue, int expireSeconds) {
        List<String> allNodes = clusterNodes;
        int requiredSuccessCount = allNodes.size() / 2 + 1; // å¤šæ•°æ´¾
        
        CountDownLatch latch = new CountDownLatch(requiredSuccessCount);
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger failureCount = new AtomicInteger(0);
        
        // å¹¶å‘å‘æ‰€æœ‰èŠ‚ç‚¹å‘é€åŠ é”è¯·æ±‚
        allNodes.parallelStream().forEach(node -> {
            try {
                if (remoteLockService.tryLock(node, lockName, lockValue, expireSeconds)) {
                    successCount.incrementAndGet();
                    latch.countDown();
                }
            } catch (Exception e) {
                failureCount.incrementAndGet();
                log.error("èŠ‚ç‚¹åŠ é”å¤±è´¥: node={}", node);
            }
        });
        
        try {
            // ç­‰å¾…è¶³å¤Ÿçš„æˆåŠŸå“åº”
            boolean achieved = latch.await(5, TimeUnit.SECONDS);
            
            if (achieved && successCount.get() >= requiredSuccessCount) {
                log.info("å¤šæ•°æ´¾åŠ é”æˆåŠŸ: success={}, required={}", 
                    successCount.get(), requiredSuccessCount);
                return true;
            } else {
                // å¦‚æœæ²¡æœ‰è¾¾åˆ°å¤šæ•°æ´¾ï¼Œéœ€è¦æ¸…ç†å·²ç»æˆåŠŸçš„é”
                cleanupPartialLocks(allNodes, lockName, lockValue);
                return false;
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            cleanupPartialLocks(allNodes, lockName, lockValue);
            return false;
        }
    }
    
    /**
     * æ¸…ç†éƒ¨åˆ†æˆåŠŸçš„é”
     */
    private void cleanupPartialLocks(List<String> nodes, String lockName, String lockValue) {
        nodes.parallelStream().forEach(node -> {
            try {
                remoteLockService.unlock(node, lockName, lockValue);
            } catch (Exception e) {
                log.warn("æ¸…ç†é”å¤±è´¥: node={}, lockName={}", node, lockName);
            }
        });
    }
}
```

---

## 6. ğŸ“ˆ é”æ€§èƒ½ç›‘æ§


### 6.1 å…³é”®ç›‘æ§æŒ‡æ ‡


> ğŸ’¡ **ç›‘æ§é‡è¦æ€§**  
> é€šè¿‡å…¨é¢çš„ç›‘æ§æŒ‡æ ‡ï¼ŒåŠæ—¶å‘ç°é”æœåŠ¡çš„æ€§èƒ½ç“¶é¢ˆå’Œæ½œåœ¨é—®é¢˜ï¼Œä¿è¯ç³»ç»Ÿç¨³å®šæ€§

**ğŸ”¸ æ ¸å¿ƒç›‘æ§æŒ‡æ ‡ä½“ç³»**
```
åˆ†å¸ƒå¼é”ç›‘æ§æŒ‡æ ‡ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    æŒ‡æ ‡ç±»åˆ«      â”‚    å…·ä½“æŒ‡æ ‡      â”‚      ç›‘æ§æ„ä¹‰       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ¯ ä¸šåŠ¡æŒ‡æ ‡      â”‚ é”è·å–æˆåŠŸç‡     â”‚ ä¸šåŠ¡åŠŸèƒ½å¯ç”¨æ€§      â”‚
â”‚                 â”‚ é”è·å–å¹³å‡è€—æ—¶   â”‚ ç”¨æˆ·ä½“éªŒæŒ‡æ ‡        â”‚
â”‚                 â”‚ é”æŒæœ‰æ—¶é—´åˆ†å¸ƒ   â”‚ ä¸šåŠ¡å¤„ç†æ•ˆç‡        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ”§ æŠ€æœ¯æŒ‡æ ‡      â”‚ é”ç«äº‰æ¿€çƒˆç¨‹åº¦   â”‚ ç³»ç»Ÿå¹¶å‘å‹åŠ›        â”‚
â”‚                 â”‚ é”è¶…æ—¶é‡Šæ”¾æ¬¡æ•°   â”‚ ç³»ç»Ÿç¨³å®šæ€§          â”‚
â”‚                 â”‚ é”ç»­æœŸæˆåŠŸç‡     â”‚ ç»­æœŸæœºåˆ¶æœ‰æ•ˆæ€§      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸš¨ å¼‚å¸¸æŒ‡æ ‡      â”‚ æ­»é”æ£€æµ‹æ¬¡æ•°     â”‚ ç³»ç»Ÿå¼‚å¸¸æƒ…å†µ        â”‚
â”‚                 â”‚ é”æœåŠ¡å¼‚å¸¸ç‡     â”‚ åŸºç¡€æœåŠ¡ç¨³å®šæ€§      â”‚
â”‚                 â”‚ è¿æ¥æ± é¥±å’Œåº¦     â”‚ èµ„æºä½¿ç”¨æƒ…å†µ        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 ç›‘æ§æ•°æ®æ”¶é›†å®ç°


**ğŸ’» ç›‘æ§ç»„ä»¶å®ç°**
```java
@Component
public class LockMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Timer.Sample lockAcquisitionTimer;
    
    // ç›‘æ§è®¡æ•°å™¨
    private final Counter lockSuccessCounter;
    private final Counter lockFailureCounter;
    private final Counter lockTimeoutCounter;
    private final Counter lockRenewalFailureCounter;
    
    // ç›‘æ§è®¡æ—¶å™¨
    private final Timer lockAcquisitionTime;
    private final Timer lockHoldingTime;
    
    // ç›‘æ§ä»ªè¡¨ç›˜
    private final Gauge activeLockCount;
    private final Gauge lockCompetitionLevel;
    
    public LockMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // åˆå§‹åŒ–ç›‘æ§æŒ‡æ ‡
        this.lockSuccessCounter = Counter.builder("distributed_lock_success_total")
            .description("åˆ†å¸ƒå¼é”è·å–æˆåŠŸæ¬¡æ•°")
            .register(meterRegistry);
            
        this.lockFailureCounter = Counter.builder("distributed_lock_failure_total")
            .description("åˆ†å¸ƒå¼é”è·å–å¤±è´¥æ¬¡æ•°")
            .register(meterRegistry);
            
        this.lockAcquisitionTime = Timer.builder("distributed_lock_acquisition_duration")
            .description("åˆ†å¸ƒå¼é”è·å–è€—æ—¶")
            .register(meterRegistry);
            
        this.activeLockCount = Gauge.builder("distributed_lock_active_count")
            .description("å½“å‰æ´»è·ƒé”æ•°é‡")
            .register(meterRegistry, this, LockMonitor::getActiveLockCount);
    }
    
    /**
     * è®°å½•é”è·å–å¼€å§‹
     */
    public LockMetricsContext startLockAcquisition(String lockName) {
        return new LockMetricsContext(lockName, System.currentTimeMillis());
    }
    
    /**
     * è®°å½•é”è·å–æˆåŠŸ
     */
    public void recordLockSuccess(LockMetricsContext context) {
        long duration = System.currentTimeMillis() - context.getStartTime();
        
        lockSuccessCounter.increment(
            Tags.of("lock_name", context.getLockName())
        );
        
        lockAcquisitionTime.record(duration, TimeUnit.MILLISECONDS,
            Tags.of("lock_name", context.getLockName(), "result", "success")
        );
        
        log.debug("é”è·å–æˆåŠŸ: lockName={}, duration={}ms", 
            context.getLockName(), duration);
    }
    
    /**
     * è®°å½•é”è·å–å¤±è´¥
     */
    public void recordLockFailure(LockMetricsContext context, String reason) {
        long duration = System.currentTimeMillis() - context.getStartTime();
        
        lockFailureCounter.increment(
            Tags.of("lock_name", context.getLockName(), "reason", reason)
        );
        
        lockAcquisitionTime.record(duration, TimeUnit.MILLISECONDS,
            Tags.of("lock_name", context.getLockName(), "result", "failure")
        );
        
        log.warn("é”è·å–å¤±è´¥: lockName={}, reason={}, duration={}ms", 
            context.getLockName(), reason, duration);
    }
    
    /**
     * è®°å½•é”ç»­æœŸå¤±è´¥
     */
    public void recordLockRenewalFailure(String lockName, String reason) {
        lockRenewalFailureCounter.increment(
            Tags.of("lock_name", lockName, "reason", reason)
        );
        
        log.error("é”ç»­æœŸå¤±è´¥: lockName={}, reason={}", lockName, reason);
    }
    
    /**
     * è·å–å½“å‰æ´»è·ƒé”æ•°é‡
     */
    private double getActiveLockCount() {
        return lockMapper.getActiveLockCount();
    }
    
    /**
     * ç›‘æ§ä¸Šä¸‹æ–‡
     */
    public static class LockMetricsContext {
        private final String lockName;
        private final long startTime;
        
        public LockMetricsContext(String lockName, long startTime) {
            this.lockName = lockName;
            this.startTime = startTime;
        }
        
        // getter methods...
    }
}
```

### 6.3 æ€§èƒ½å‘Šè­¦é…ç½®


**ğŸ”¸ å‘Šè­¦è§„åˆ™é…ç½®**
```yaml
# Prometheus å‘Šè­¦è§„åˆ™é…ç½®
groups:
  - name: distributed_lock_alerts
    rules:
      # é”è·å–æˆåŠŸç‡ä½äº95%
      - alert: LockSuccessRateLow
        expr: |
          (
            rate(distributed_lock_success_total[5m]) / 
            (rate(distributed_lock_success_total[5m]) + rate(distributed_lock_failure_total[5m]))
          ) < 0.95
        for: 2m
        labels:
          severity: warning
          service: distributed-lock
        annotations:
          summary: "åˆ†å¸ƒå¼é”æˆåŠŸç‡è¿‡ä½"
          description: "åˆ†å¸ƒå¼é”æˆåŠŸç‡åœ¨è¿‡å»5åˆ†é’Ÿå†…ä½äº95%"
          
      # é”è·å–å¹³å‡è€—æ—¶è¶…è¿‡1ç§’
      - alert: LockAcquisitionSlow
        expr: |
          rate(distributed_lock_acquisition_duration_sum[5m]) / 
          rate(distributed_lock_acquisition_duration_count[5m]) > 1000
        for: 3m
        labels:
          severity: critical
          service: distributed-lock
        annotations:
          summary: "é”è·å–è€—æ—¶è¿‡é•¿"
          description: "é”è·å–å¹³å‡è€—æ—¶è¶…è¿‡1ç§’ï¼Œå¯èƒ½å­˜åœ¨æ€§èƒ½é—®é¢˜"
          
      # æ´»è·ƒé”æ•°é‡å¼‚å¸¸å¢é•¿
      - alert: ActiveLockCountHigh
        expr: distributed_lock_active_count > 1000
        for: 5m
        labels:
          severity: warning
          service: distributed-lock
        annotations:
          summary: "æ´»è·ƒé”æ•°é‡è¿‡å¤š"
          description: "å½“å‰æ´»è·ƒé”æ•°é‡è¶…è¿‡1000ï¼Œå¯èƒ½å­˜åœ¨é”æ³„æ¼"
          
      # é”ç»­æœŸå¤±è´¥ç‡é«˜
      - alert: LockRenewalFailureHigh
        expr: rate(distributed_lock_renewal_failure_total[5m]) > 10
        for: 2m
        labels:
          severity: critical
          service: distributed-lock
        annotations:
          summary: "é”ç»­æœŸå¤±è´¥ç‡è¿‡é«˜"
          description: "é”ç»­æœŸå¤±è´¥ç‡æ¯åˆ†é’Ÿè¶…è¿‡10æ¬¡"
```

### 6.4 æ€§èƒ½ä¼˜åŒ–ç›‘æ§


**ğŸ”¸ æ€§èƒ½åˆ†æå·¥å…·**
```java
@Component
public class LockPerformanceAnalyzer {
    
    private final Map<String, LockStatistics> lockStats = new ConcurrentHashMap<>();
    
    /**
     * åˆ†æé”æ€§èƒ½ç»Ÿè®¡ä¿¡æ¯
     */
    @Scheduled(fixedRate = 300000) // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void analyzeLockPerformance() {
        List<LockStatistics> topSlowLocks = getTopSlowLocks(10);
        List<LockStatistics> topContentionLocks = getTopContentionLocks(10);
        
        // è¾“å‡ºæ€§èƒ½æŠ¥å‘Š
        generatePerformanceReport(topSlowLocks, topContentionLocks);
        
        // è‡ªåŠ¨ä¼˜åŒ–å»ºè®®
        generateOptimizationSuggestions(topSlowLocks, topContentionLocks);
    }
    
    /**
     * è·å–æœ€æ…¢çš„é”
     */
    private List<LockStatistics> getTopSlowLocks(int limit) {
        return lockStats.values().stream()
            .sorted(Comparator.comparing(LockStatistics::getAvgHoldTime).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }
    
    /**
     * è·å–ç«äº‰æœ€æ¿€çƒˆçš„é”
     */
    private List<LockStatistics> getTopContentionLocks(int limit) {
        return lockStats.values().stream()
            .sorted(Comparator.comparing(LockStatistics::getContentionRatio).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }
    
    /**
     * ç”Ÿæˆä¼˜åŒ–å»ºè®®
     */
    private void generateOptimizationSuggestions(List<LockStatistics> slowLocks, 
                                               List<LockStatistics> contentionLocks) {
        StringBuilder suggestions = new StringBuilder();
        suggestions.append("=== åˆ†å¸ƒå¼é”æ€§èƒ½ä¼˜åŒ–å»ºè®® ===\n");
        
        // é’ˆå¯¹æ…¢é”çš„å»ºè®®
        if (!slowLocks.isEmpty()) {
            suggestions.append("\nã€é•¿æŒæœ‰æ—¶é—´é”ä¼˜åŒ–ã€‘:\n");
            slowLocks.forEach(lock -> {
                suggestions.append(String.format(
                    "- é” '%s': å¹³å‡æŒæœ‰æ—¶é—´%.2fmsï¼Œå»ºè®®:\n" +
                    "  * å‡å°‘é”å†…ä¸šåŠ¡é€»è¾‘å¤æ‚åº¦\n" +
                    "  * è€ƒè™‘å¼‚æ­¥å¤„ç†éƒ¨åˆ†æ“ä½œ\n" +
                    "  * æ£€æŸ¥æ˜¯å¦æœ‰ä¸å¿…è¦çš„IOæ“ä½œ\n",
                    lock.getLockName(), lock.getAvgHoldTime()
                ));
            });
        }
        
        // é’ˆå¯¹é«˜ç«äº‰é”çš„å»ºè®®
        if (!contentionLocks.isEmpty()) {
            suggestions.append("\nã€é«˜ç«äº‰é”ä¼˜åŒ–ã€‘:\n");
            contentionLocks.forEach(lock -> {
                suggestions.append(String.format(
                    "- é” '%s': ç«äº‰æ¯”ç‡%.2fï¼Œå»ºè®®:\n" +
                    "  * è€ƒè™‘ä½¿ç”¨åˆ†æ®µé”å‡å°‘ç«äº‰\n" +
                    "  * ä¼˜åŒ–ä¸šåŠ¡é€»è¾‘å‡å°‘é”ç²’åº¦\n" +
                    "  * ä½¿ç”¨éé˜»å¡ç­–ç•¥å‡å°‘ç­‰å¾…\n" +
                    "  * è¯„ä¼°æ˜¯å¦å¯ä»¥ä½¿ç”¨ä¹è§‚é”æ›¿ä»£\n",
                    lock.getLockName(), lock.getContentionRatio()
                ));
            });
        }
        
        log.info(suggestions.toString());
    }
    
    /**
     * é”ç»Ÿè®¡ä¿¡æ¯
     */
    public static class LockStatistics {
        private String lockName;
        private long totalAcquisitions;
        private long successfulAcquisitions; 
        private double avgHoldTime;
        private double contentionRatio;
        
        // æ„é€ å™¨å’Œgetter/setteræ–¹æ³•
        public LockStatistics(String lockName) {
            this.lockName = lockName;
        }
        
        public double getContentionRatio() {
            return totalAcquisitions > 0 ? 
                (double)(totalAcquisitions - successfulAcquisitions) / totalAcquisitions : 0;
        }
        
        // å…¶ä»–getteræ–¹æ³•...
        public String getLockName() { return lockName; }
        public double getAvgHoldTime() { return avgHoldTime; }
    }
}
```

---

## 7. ğŸ† åˆ†å¸ƒå¼é”æœ€ä½³å®è·µ


### 7.1 é”è®¾è®¡æœ€ä½³å®è·µ


> ğŸ’¡ **è®¾è®¡åŸåˆ™**  
> éµå¾ªæœ€ä½³å®è·µèƒ½å¤Ÿæ˜¾è‘—æé«˜åˆ†å¸ƒå¼é”çš„å¯é æ€§ã€æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§

**ğŸ”¸ é”å‘½åè§„èŒƒ**
```java
public class LockNamingConvention {
    
    /**
     * æ ‡å‡†é”å‘½åæ ¼å¼
     * æ ¼å¼: {ä¸šåŠ¡åŸŸ}_{èµ„æºç±»å‹}_{èµ„æºæ ‡è¯†}_{æ“ä½œç±»å‹}
     */
    public static class LockNames {
        // åº“å­˜ç›¸å…³é”
        public static final String STOCK_DECREASE = "inventory_product_%d_decrease";
        public static final String STOCK_RESERVE = "inventory_product_%d_reserve";
        
        // è®¢å•ç›¸å…³é”  
        public static final String ORDER_CREATE = "order_user_%d_create";
        public static final String ORDER_PAYMENT = "order_order_%s_payment";
        
        // ä¼˜æƒ åˆ¸ç›¸å…³é”
        public static final String COUPON_CLAIM = "promotion_coupon_%d_claim";
        public static final String COUPON_USE = "promotion_coupon_%s_use";
        
        // è´¦æˆ·ç›¸å…³é”
        public static final String ACCOUNT_BALANCE = "finance_account_%d_balance";
        public static final String ACCOUNT_WITHDRAW = "finance_account_%d_withdraw";
    }
    
    /**
     * ç”Ÿæˆæ ‡å‡†é”åç§°
     */
    public static String generateLockName(String domain, String resourceType, 
                                        String resourceId, String operation) {
        return String.format("%s_%s_%s_%s", domain, resourceType, resourceId, operation);
    }
    
    /**
     * è§£æé”åç§°
     */
    public static LockNameInfo parseLockName(String lockName) {
        String[] parts = lockName.split("_");
        if (parts.length >= 4) {
            return new LockNameInfo(parts[0], parts[1], parts[2], parts[3]);
        }
        throw new IllegalArgumentException("é”åç§°æ ¼å¼ä¸æ­£ç¡®: " + lockName);
    }
}
```

**ğŸ”¸ é”ç²’åº¦é€‰æ‹©ç­–ç•¥**
```java
@Service
public class LockGranularityStrategy {
    
    /**
     * æ ¹æ®ä¸šåŠ¡åœºæ™¯é€‰æ‹©åˆé€‚çš„é”ç²’åº¦
     */
    public String selectLockGranularity(BusinessContext context) {
        switch (context.getScenario()) {
            case HIGH_CONCURRENCY_LOW_CONFLICT:
                // é«˜å¹¶å‘ä½å†²çªï¼šé€‰æ‹©ç»†ç²’åº¦é”
                return generateFineLock(context);
                
            case LOW_CONCURRENCY_HIGH_CONFLICT:
                // ä½å¹¶å‘é«˜å†²çªï¼šå¯ä»¥ä½¿ç”¨ç²—ç²’åº¦é”
                return generateCoarseLock(context);
                
            case BATCH_OPERATION:
                // æ‰¹é‡æ“ä½œï¼šä½¿ç”¨èŒƒå›´é”
                return generateRangeLock(context);
                
            default:
                return generateDefaultLock(context);
        }
    }
    
    /**
     * ç»†ç²’åº¦é” - é’ˆå¯¹å…·ä½“èµ„æºå®ä¾‹
     */
    private String generateFineLock(BusinessContext context) {
        // ä¾‹å¦‚ï¼šé’ˆå¯¹å…·ä½“å•†å“çš„åº“å­˜é”
        return String.format("stock_product_%d", context.getResourceId());
    }
    
    /**
     * ç²—ç²’åº¦é” - é’ˆå¯¹èµ„æºç±»åˆ«
     */
    private String generateCoarseLock(BusinessContext context) {
        // ä¾‹å¦‚ï¼šé’ˆå¯¹æ•´ä¸ªå•†å“ç±»åˆ«çš„é”
        return String.format("stock_category_%d", context.getCategoryId());
    }
    
    /**
     * èŒƒå›´é” - é’ˆå¯¹èµ„æºèŒƒå›´
     */
    private String generateRangeLock(BusinessContext context) {
        // ä¾‹å¦‚ï¼šé’ˆå¯¹å•†å“IDèŒƒå›´çš„é”
        return String.format("stock_range_%d_%d", 
            context.getStartId(), context.getEndId());
    }
}
```

### 7.2 å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ


**ğŸ”¸ å®Œæ•´çš„å¼‚å¸¸å¤„ç†æ¡†æ¶**
```java
@Component
public class RobustDistributedLock {
    
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final long RETRY_DELAY_MS = 100;
    
    /**
     * å¥å£®çš„é”æ“ä½œæ¨¡æ¿
     */
    public <T> T executeWithLock(String lockName, int timeoutSeconds, 
                                Supplier<T> businessLogic) {
        String lockValue = generateLockValue();
        LockMetricsContext metricsContext = lockMonitor.startLockAcquisition(lockName);
        
        try {
            // 1. è·å–é”ï¼ˆå¸¦é‡è¯•ï¼‰
            if (!acquireLockWithRetry(lockName, lockValue, timeoutSeconds)) {
                lockMonitor.recordLockFailure(metricsContext, "acquisition_timeout");
                throw new LockAcquisitionException("è·å–é”è¶…æ—¶: " + lockName);
            }
            
            lockMonitor.recordLockSuccess(metricsContext);
            
            try {
                // 2. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
                return businessLogic.get();
                
            } catch (Exception e) {
                // ä¸šåŠ¡å¼‚å¸¸ä¸å½±å“é”çš„é‡Šæ”¾
                log.error("ä¸šåŠ¡é€»è¾‘æ‰§è¡Œå¼‚å¸¸: lockName={}, error={}", lockName, e.getMessage());
                throw e;
            }
            
        } finally {
            // 3. ç¡®ä¿é”è¢«é‡Šæ”¾
            try {
                releaseLockSafely(lockName, lockValue);
            } catch (Exception e) {
                log.error("é‡Šæ”¾é”å¼‚å¸¸: lockName={}, error={}", lockName, e.getMessage());
                // é‡Šæ”¾é”å¤±è´¥ä¹Ÿè¦è®°å½•ï¼Œä½†ä¸æŠ›å¼‚å¸¸å½±å“ä¸šåŠ¡ç»“æœ
            }
        }
    }
    
    /**
     * å¸¦é‡è¯•çš„é”è·å–
     */
    private boolean acquireLockWithRetry(String lockName, String lockValue, int timeoutSeconds) {
        int attempts = 0;
        long startTime = System.currentTimeMillis();
        long timeoutMs = timeoutSeconds * 1000;
        
        while (attempts < MAX_RETRY_ATTEMPTS && 
               (System.currentTimeMillis() - startTime) < timeoutMs) {
            
            try {
                if (distributedLock.tryLock(lockName, lockValue, timeoutSeconds)) {
                    return true;
                }
                
                // è·å–å¤±è´¥ï¼Œç­‰å¾…åé‡è¯•
                attempts++;
                if (attempts < MAX_RETRY_ATTEMPTS) {
                    Thread.sleep(RETRY_DELAY_MS * attempts); // æŒ‡æ•°é€€é¿
                }
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            } catch (Exception e) {
                log.warn("é”è·å–å¼‚å¸¸ï¼Œå°è¯•é‡è¯•: attempt={}, error={}", attempts, e.getMessage());
                attempts++;
            }
        }
        
        return false;
    }
    
    /**
     * å®‰å…¨é‡Šæ”¾é”
     */
    private void releaseLockSafely(String lockName, String lockValue) {
        try {
            // å…ˆæ£€æŸ¥é”æ˜¯å¦è¿˜å­˜åœ¨ä¸”å±äºå½“å‰æŒæœ‰è€…
            if (isLockOwnedByMe(lockName, lockValue)) {
                distributedLock.unlock(lockName, lockValue);
                log.debug("æˆåŠŸé‡Šæ”¾é”: lockName={}", lockName);
            } else {
                log.warn("é”å·²ä¸å±äºå½“å‰æŒæœ‰è€…ï¼Œå¯èƒ½å·²è¿‡æœŸ: lockName={}", lockName);
            }
        } catch (Exception e) {
            log.error("é‡Šæ”¾é”æ—¶å‘ç”Ÿå¼‚å¸¸: lockName={}, error={}", lockName, e.getMessage());
            // å¯ä»¥è€ƒè™‘å°†å¤±è´¥çš„é”æ”¾å…¥æ¸…ç†é˜Ÿåˆ—ï¼Œç¨åé‡è¯•
            scheduleCleanupTask(lockName, lockValue);
        }
    }
    
    /**
     * æ£€æŸ¥é”æ˜¯å¦å±äºå½“å‰æŒæœ‰è€…
     */
    private boolean isLockOwnedByMe(String lockName, String lockValue) {
        try {
            DistributedLockEntity lock = lockMapper.selectLock(lockName);
            return lock != null && lockValue.equals(lock.getLockValue()) && 
                   !isExpired(lock.getExpireTime());
        } catch (Exception e) {
            log.warn("æ£€æŸ¥é”æŒæœ‰è€…æ—¶å‘ç”Ÿå¼‚å¸¸: {}", e.getMessage());
            return false; // å¼‚å¸¸æ—¶ä¿å®ˆå¤„ç†ï¼Œè®¤ä¸ºä¸å±äºè‡ªå·±
        }
    }
}
```

### 7.3 æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ


**ğŸ”¸ è¿æ¥æ± ä¼˜åŒ–é…ç½®**
```java
@Configuration
public class LockDataSourceConfig {
    
    /**
     * ä¸“é—¨ç”¨äºåˆ†å¸ƒå¼é”çš„æ•°æ®æºé…ç½®
     */
    @Bean("lockDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.lock")
    public DataSource lockDataSource() {
        HikariConfig config = new HikariConfig();
        
        // é”æ“ä½œé€šå¸¸å¾ˆå¿«ï¼Œè¿æ¥æ± å¯ä»¥é…ç½®å¾—å°ä¸€äº›
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        
        // é”æ“ä½œå¯¹è¿æ¥è´¨é‡è¦æ±‚é«˜ï¼Œè®¾ç½®è¾ƒçŸ­çš„è¶…æ—¶æ—¶é—´
        config.setConnectionTimeout(5000);      // 5ç§’è¿æ¥è¶…æ—¶
        config.setIdleTimeout(300000);          // 5åˆ†é’Ÿç©ºé—²è¶…æ—¶
        config.setMaxLifetime(1800000);         // 30åˆ†é’Ÿæœ€å¤§ç”Ÿå‘½å‘¨æœŸ
        
        // å¯ç”¨è¿æ¥æµ‹è¯•ï¼Œç¡®ä¿è¿æ¥å¯ç”¨æ€§
        config.setConnectionTestQuery("SELECT 1");
        config.setTestWhileIdle(true);
        config.setTestOnBorrow(true);
        
        // ä¼˜åŒ–MySQLè¿æ¥å‚æ•°
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        config.addDataSourceProperty("useServerPrepStmts", "true");
        config.addDataSourceProperty("rewriteBatchedStatements", "true");
        
        return new HikariDataSource(config);
    }
}
```

**ğŸ”¸ æ‰¹é‡é”æ“ä½œä¼˜åŒ–**
```java
@Service
public class BatchLockOperationService {
    
    /**
     * æ‰¹é‡è·å–é” - å‡å°‘æ•°æ®åº“äº¤äº’æ¬¡æ•°
     */
    public Map<String, Boolean> batchTryLock(List<String> lockNames, 
                                           String lockValue, int expireSeconds) {
        if (lockNames.isEmpty()) {
            return Collections.emptyMap();
        }
        
        // 1. æ‰¹é‡æ’å…¥é”è®°å½•
        List<DistributedLockEntity> lockEntities = lockNames.stream()
            .map(lockName -> createLockEntity(lockName, lockValue, expireSeconds))
            .collect(Collectors.toList());
        
        Map<String, Boolean> results = new HashMap<>();
        
        // 2. ä½¿ç”¨æ‰¹é‡æ’å…¥ï¼Œæé«˜æ€§èƒ½
        try {
            lockMapper.batchInsertLocks(lockEntities);
            // å…¨éƒ¨æ’å…¥æˆåŠŸ
            lockNames.forEach(lockName -> results.put(lockName, true));
            
        } catch (Exception e) {
            // æ‰¹é‡æ’å…¥å¤±è´¥ï¼Œé€ä¸ªå°è¯•ï¼ˆå¯èƒ½éƒ¨åˆ†æˆåŠŸï¼‰
            lockNames.forEach(lockName -> {
                try {
                    boolean success = distributedLock.tryLock(lockName, lockValue, expireSeconds);
                    results.put(lockName, success);
                } catch (Exception ex) {
                    results.put(lockName, false);
                }
            });
        }
        
        return results;
    }
    
    /**
     * æ‰¹é‡é‡Šæ”¾é”
     */
    public void batchUnlock(List<String> lockNames, String lockValue) {
        if (lockNames.isEmpty()) {
            return;
        }
        
        // æ‰¹é‡åˆ é™¤é”è®°å½•
        int deletedCount = lockMapper.batchDeleteLocks(lockNames, lockValue);
        log.info("æ‰¹é‡é‡Šæ”¾é”å®Œæˆ: é¢„æœŸé‡Šæ”¾={}, å®é™…é‡Šæ”¾={}", lockNames.size(), deletedCount);
        
        // å¦‚æœåˆ é™¤æ•°é‡ä¸åŒ¹é…ï¼Œè®°å½•è¯¦ç»†ä¿¡æ¯ç”¨äºæ’æŸ¥
        if (deletedCount != lockNames.size()) {
            List<String> failedLocks = findFailedUnlocks(lockNames, lockValue);
            log.warn("éƒ¨åˆ†é”é‡Šæ”¾å¤±è´¥: failed={}", failedLocks);
        }
    }
    
    private List<String> findFailedUnlocks(List<String> lockNames, String lockValue) {
        return lockNames.stream()
            .filter(lockName -> {
                DistributedLockEntity lock = lockMapper.selectLock(lockName);
                return lock != null && lockValue.equals(lock.getLockValue());
            })
            .collect(Collectors.toList());
    }
}
```

### 7.4 è¿ç»´ç›‘æ§æœ€ä½³å®è·µ


**ğŸ”¸ é”å¥åº·æ£€æŸ¥**
```java
@Component
public class LockHealthChecker {
    
    /**
     * å®šæœŸå¥åº·æ£€æŸ¥
     */
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    public void performHealthCheck() {
        HealthCheckResult result = new HealthCheckResult();
        
        try {
            // 1. æ£€æŸ¥æ•°æ®åº“è¿æ¥
            checkDatabaseConnection(result);
            
            // 2. æ£€æŸ¥é”è¡¨çŠ¶æ€
            checkLockTableStatus(result);
            
            // 3. æ£€æŸ¥è¿‡æœŸé”æ¸…ç†
            checkExpiredLockCleanup(result);
            
            // 4. æ£€æŸ¥é”æ€§èƒ½æŒ‡æ ‡
            checkLockPerformance(result);
            
            // 5. ç”Ÿæˆå¥åº·æŠ¥å‘Š
            generateHealthReport(result);
            
        } catch (Exception e) {
            log.error("å¥åº·æ£€æŸ¥æ‰§è¡Œå¼‚å¸¸", e);
        }
    }
    
    private void checkDatabaseConnection(HealthCheckResult result) {
        try {
            long startTime = System.currentTimeMillis();
            lockMapper.healthCheck(); // æ‰§è¡Œç®€å•æŸ¥è¯¢
            long duration = System.currentTimeMillis() - startTime;
            
            result.setDatabaseConnected(true);
            result.setDatabaseResponseTime(duration);
            
            if (duration > 1000) {
                result.addWarning("æ•°æ®åº“å“åº”æ—¶é—´è¿‡é•¿: " + duration + "ms");
            }
            
        } catch (Exception e) {
            result.setDatabaseConnected(false);
            result.addError("æ•°æ®åº“è¿æ¥å¤±è´¥: " + e.getMessage());
        }
    }
    
    private void checkLockTableStatus(HealthCheckResult result) {
        try {
            // æ£€æŸ¥é”è¡¨å¤§å°
            long totalLocks = lockMapper.getTotalLockCount();
            long activeLocks = lockMapper.getActiveLockCount();
            long expiredLocks = lockMapper.getExpiredLockCount();
            
            result.setTotalLocks(totalLocks);
            result.setActiveLocks(activeLocks);
            result.setExpiredLocks(expiredLocks);
            
            // å¼‚å¸¸æƒ…å†µå‘Šè­¦
            if (expiredLocks > activeLocks * 0.1) {
                result.addWarning("è¿‡æœŸé”æ¯”ä¾‹è¿‡é«˜ï¼Œå¯èƒ½å­˜åœ¨æ¸…ç†é—®é¢˜");
            }
            
            if (totalLocks > 10000) {
                result.addWarning("é”è¡¨è®°å½•æ•°è¿‡å¤šï¼Œå»ºè®®æ¸…ç†å†å²æ•°æ®");
            }
            
        } catch (Exception e) {
            result.addError("é”è¡¨çŠ¶æ€æ£€æŸ¥å¤±è´¥: " + e.getMessage());
        }
    }
    
    /**
     * å¥åº·æ£€æŸ¥ç»“æœ
     */
    public static class HealthCheckResult {
        private boolean databaseConnected;
        private long databaseResponseTime;
        private long totalLocks;
        private long activeLocks;
        private long expiredLocks;
        private List<String> warnings = new ArrayList<>();
        private List<String> errors = new ArrayList<>();
        
        public boolean isHealthy() {
            return databaseConnected && errors.isEmpty();
        }
        
        // getter/setteræ–¹æ³•...
        public void addWarning(String warning) { warnings.add(warning); }
        public void addError(String error) { errors.add(error); }
    }
}
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 åˆ†å¸ƒå¼é”æ ¸å¿ƒç†å¿µ


> ğŸ¯ **è®¾è®¡å“²å­¦**  
> åˆ†å¸ƒå¼é”æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ä¿è¯æ•°æ®ä¸€è‡´æ€§çš„é‡è¦å·¥å…·ï¼Œä½†ä¸æ˜¯ä¸‡èƒ½çš„ï¼Œéœ€è¦ç»“åˆå…·ä½“ä¸šåŠ¡åœºæ™¯åˆç†ä½¿ç”¨

**ğŸ”¸ æ ¸å¿ƒä»·å€¼ä¸é€‚ç”¨æ€§**
```
âœ… é€‚ç”¨åœºæ™¯ï¼š
â€¢ å¤šè¿›ç¨‹è®¿é—®å…±äº«èµ„æºï¼ˆåº“å­˜ã€ä½™é¢ï¼‰
â€¢ é˜²æ­¢é‡å¤æ“ä½œï¼ˆé‡å¤æ”¯ä»˜ã€é‡å¤å‘åˆ¸ï¼‰
â€¢ ä¿è¯æ“ä½œåŸå­æ€§ï¼ˆå¤æ‚ä¸šåŠ¡æµç¨‹ï¼‰
â€¢ é™åˆ¶å¹¶å‘æ•°é‡ï¼ˆèµ„æºæ± ç®¡ç†ï¼‰

âŒ ä¸é€‚ç”¨åœºæ™¯ï¼š  
â€¢ ç®€å•çš„è®¡æ•°æ“ä½œï¼ˆå¯ç”¨åŸå­æ“ä½œï¼‰
â€¢ é«˜é¢‘è¯»å¤šå†™å°‘ï¼ˆå¯ç”¨ä¹è§‚é”ï¼‰
â€¢ å¯¹æ€§èƒ½è¦æ±‚æé«˜ï¼ˆåˆ†å¸ƒå¼é”æœ‰å¼€é”€ï¼‰
â€¢ å¯ä»¥æ¥å—æœ€ç»ˆä¸€è‡´æ€§ï¼ˆå¼‚æ­¥å¤„ç†æ›´å¥½ï¼‰
```

### 8.2 MySQLåˆ†å¸ƒå¼é”å…³é”®è¦ç‚¹


**ğŸ”¸ æŠ€æœ¯å®ç°è¦ç‚¹**
```
ğŸ” é”æœºåˆ¶è®¾è®¡ï¼š
â€¢ åˆ©ç”¨å”¯ä¸€ç´¢å¼•ä¿è¯äº’æ–¥æ€§
â€¢ è®¾ç½®è¿‡æœŸæ—¶é—´é˜²æ­¢æ­»é”
â€¢ ä½¿ç”¨é”æŒæœ‰è€…æ ‡è¯†ç¡®ä¿å®‰å…¨é‡Šæ”¾
â€¢ æ”¯æŒé‡å…¥é”æé«˜æ˜“ç”¨æ€§

â° è¶…æ—¶ä¸ç»­æœŸï¼š
â€¢ åˆç†è®¾ç½®åˆå§‹è¶…æ—¶æ—¶é—´
â€¢ å®ç°è‡ªåŠ¨ç»­æœŸæœºåˆ¶
â€¢ æ™ºèƒ½è®¡ç®—è¶…æ—¶æ—¶é—´
â€¢ å¼‚å¸¸æƒ…å†µçš„å…œåº•æ¸…ç†

ğŸ ç«äº‰å¤„ç†ç­–ç•¥ï¼š
â€¢ éé˜»å¡å¿«é€Ÿå¤±è´¥
â€¢ é™æ—¶ç­‰å¾…é¿å…æ— é™é˜»å¡  
â€¢ åˆ†æ®µé”å‡å°‘ç«äº‰
â€¢ ä¼˜å…ˆçº§é˜Ÿåˆ—å…¬å¹³è°ƒåº¦
```

### 8.3 é«˜å¯ç”¨è®¾è®¡è¦ç‚¹


**ğŸ”¸ å¯é æ€§ä¿éšœ**
```
ğŸ—ï¸ æ¶æ„é«˜å¯ç”¨ï¼š
â€¢ MySQLä¸»ä»åˆ‡æ¢æ„ŸçŸ¥
â€¢ é”æœåŠ¡é›†ç¾¤åŒ–éƒ¨ç½²
â€¢ å¤šæ•°æ´¾å†™å…¥ä¿è¯ä¸€è‡´æ€§
â€¢ æ•…éšœè½¬ç§»å’Œç†”æ–­æœºåˆ¶

ğŸ“Š ç›‘æ§å‘Šè­¦ï¼š
â€¢ å…¨é¢çš„æ€§èƒ½æŒ‡æ ‡ç›‘æ§
â€¢ åŠæ—¶çš„å¼‚å¸¸æƒ…å†µå‘Šè­¦
â€¢ å®šæœŸçš„å¥åº·çŠ¶æ€æ£€æŸ¥
â€¢ è¯¦ç»†çš„æ€§èƒ½åˆ†ææŠ¥å‘Š

ğŸ”§ è¿ç»´æ”¯æŒï¼š
â€¢ æ ‡å‡†åŒ–çš„é”å‘½åè§„èŒƒ
â€¢ å®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶
â€¢ æ‰¹é‡æ“ä½œæ€§èƒ½ä¼˜åŒ–
â€¢ è‡ªåŠ¨åŒ–çš„é—®é¢˜è¯Šæ–­å·¥å…·
```

### 8.4 æ€§èƒ½ä¼˜åŒ–è¦ç‚¹


**ğŸ”¸ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**
```
âš¡ æŠ€æœ¯å±‚é¢ï¼š
â€¢ ä¸“ç”¨è¿æ¥æ± ä¼˜åŒ–é…ç½®
â€¢ æ‰¹é‡æ“ä½œå‡å°‘æ•°æ®åº“äº¤äº’
â€¢ ç´¢å¼•ä¼˜åŒ–æé«˜æŸ¥è¯¢æ€§èƒ½
â€¢ é€‚å½“çš„é”ç²’åº¦é€‰æ‹©

ğŸ“ˆ ä¸šåŠ¡å±‚é¢ï¼š
â€¢ å‡å°‘é”æŒæœ‰æ—¶é—´
â€¢ é¿å…é”å†…å¤æ‚è®¡ç®—
â€¢ å¼‚æ­¥å¤„ç†éå…³é”®æ“ä½œ
â€¢ åˆç†çš„é‡è¯•å’Œé€€é¿ç­–ç•¥

ğŸ¯ æ¶æ„å±‚é¢ï¼š
â€¢ è¯»å†™åˆ†ç¦»å‡è½»ä¸»åº“å‹åŠ›
â€¢ ç¼“å­˜é¢„çƒ­å‡å°‘é”ç«äº‰  
â€¢ æ¶ˆæ¯é˜Ÿåˆ—å‰Šå³°å¡«è°·
â€¢ å¾®æœåŠ¡è§£è€¦é™ä½é”ç²’åº¦
```

### 8.5 æœ€ä½³å®è·µæ€»ç»“


**ğŸ”¸ å¼€å‘å®è·µ**
```
è®¾è®¡åŸåˆ™ï¼š
â€¢ é”ç²’åº¦å°½å¯èƒ½å°
â€¢ é”æŒæœ‰æ—¶é—´å°½å¯èƒ½çŸ­
â€¢ å¼‚å¸¸å¤„ç†å¿…é¡»å®Œå–„
â€¢ ç›‘æ§å‘Šè­¦å¿…é¡»åˆ°ä½

ç¼–ç è§„èŒƒï¼š
â€¢ ç»Ÿä¸€çš„é”å‘½åè§„èŒƒ
â€¢ æ ‡å‡†çš„å¼‚å¸¸å¤„ç†æ¨¡å¼
â€¢ å®Œæ•´çš„èµ„æºé‡Šæ”¾é€»è¾‘
â€¢ è¯¦ç»†çš„æ“ä½œæ—¥å¿—è®°å½•

æµ‹è¯•ç­–ç•¥ï¼š
â€¢ å¹¶å‘åœºæ™¯å‹åŠ›æµ‹è¯•
â€¢ å¼‚å¸¸æƒ…å†µæ•…éšœæµ‹è¯•
â€¢ æ€§èƒ½åŸºå‡†æµ‹è¯•
â€¢ é•¿æœŸç¨³å®šæ€§æµ‹è¯•
```

**ğŸ”¸ è¿ç»´å®è·µ**
```
éƒ¨ç½²ç­–ç•¥ï¼š
â€¢ æ¸è¿›å¼å‘å¸ƒéªŒè¯
â€¢ ç°åº¦åˆ‡é‡æ§åˆ¶é£é™©
â€¢ ç›‘æ§æŒ‡æ ‡å®æ—¶è·Ÿè¸ª
â€¢ å›æ»šé¢„æ¡ˆéšæ—¶å‡†å¤‡

è¿ç»´ç›‘æ§ï¼š
â€¢ æ ¸å¿ƒæŒ‡æ ‡Dashboard
â€¢ å¼‚å¸¸æƒ…å†µåŠæ—¶å‘Šè­¦
â€¢ å®šæœŸæ€§èƒ½åˆ†ææŠ¥å‘Š
â€¢ å®¹é‡è§„åˆ’æå‰é¢„è­¦

æ•…éšœå¤„ç†ï¼š
â€¢ æ ‡å‡†åŒ–æ•…éšœå¤„ç†æµç¨‹
â€¢ è¯¦ç»†çš„æ•…éšœæ’æŸ¥æ‰‹å†Œ
â€¢ å¿«é€Ÿçš„é—®é¢˜å®šä½å·¥å…·
â€¢ å®Œå–„çš„äº‹åå¤ç›˜æœºåˆ¶
```

**æ ¸å¿ƒè®°å¿†è¦ç‚¹**ï¼š
```
åˆ†å¸ƒå¼é”è®¾è®¡ä¸‰è¦ç´ ï¼šäº’æ–¥æ€§ã€å¯é‡Šæ”¾ã€é˜²æ­»é”
MySQLå®ç°é å”¯ä¸€ç´¢å¼•ï¼Œè¿‡æœŸæ—¶é—´é˜²æ­»é”
ç«äº‰å¤„ç†æœ‰ç­–ç•¥ï¼Œåˆ†æ®µä¼˜å…ˆçº§éƒ½è¦è€ƒè™‘  
é«˜å¯ç”¨é é›†ç¾¤ï¼Œç›‘æ§å‘Šè­¦ä¿ç¨³å®š
æ€§èƒ½ä¼˜åŒ–ä»å¤šå±‚æ¬¡ï¼Œè¿æ¥æ± æ‰¹é‡å’Œç²’åº¦
æœ€ä½³å®è·µè¦è§„èŒƒï¼Œæµ‹è¯•è¿ç»´ä¸¤æ‰‹æŠ“
```