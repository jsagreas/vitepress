---
title: 19、索引设计优化规范
---
## 📚 目录

1. [索引基础概念与作用](#1-索引基础概念与作用)
2. [索引创建原则](#2-索引创建原则)
3. [复合索引设计规则](#3-复合索引设计规则)
4. [索引命名与使用规范](#4-索引命名与使用规范)
5. [索引性能优化策略](#5-索引性能优化策略)
6. [索引监控与维护](#6-索引监控与维护)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📖 索引基础概念与作用


### 1.1 什么是索引

**索引就像书籍的目录**，帮助数据库快速定位到所需要的数据行。

```
没有索引的查询：就像在一本书中逐页翻找某个内容
SELECT * FROM users WHERE name = '张三';
↓ 数据库需要扫描整张表的每一行

有索引的查询：就像直接查看目录找到页码
CREATE INDEX idx_name ON users(name);
↓ 数据库直接定位到对应数据
```

**索引的本质**：
- **数据结构**：通常使用B+树结构存储
- **空间换时间**：占用额外存储空间来提升查询速度
- **有序存储**：索引数据按照特定顺序排列

### 1.2 索引的工作原理

```
原始数据表：
┌────┬────────┬─────┐
│ ID │  姓名   │ 年龄 │
├────┼────────┼─────┤
│ 1  │ 张三    │ 25  │
│ 2  │ 李四    │ 30  │
│ 3  │ 王五    │ 28  │
│ 4  │ 赵六    │ 22  │
└────┴────────┴─────┘

姓名索引结构：
┌────────┬──────┐
│  姓名   │ 行号  │
├────────┼──────┤
│ 李四    │  2   │
│ 王五    │  3   │
│ 张三    │  1   │
│ 赵六    │  4   │
└────────┴──────┘
```

**查询过程**：
1. 在索引中快速找到"张三"对应的行号：1
2. 直接访问第1行获取完整数据
3. 避免扫描整张表

---

## 2. 🎯 索引创建原则


### 2.1 核心创建原则


**🔸 WHERE子句频繁查询的列**
```sql
-- ✅ 好的做法：为经常用于查询条件的列创建索引
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_order_status ON orders(status);

-- 支持的查询
SELECT * FROM users WHERE email = 'user@example.com';
SELECT * FROM orders WHERE status = 'completed';
```

**🔸 ORDER BY排序的列**
```sql
-- ✅ 为排序字段创建索引
CREATE INDEX idx_created_time ON articles(created_time);

-- 支持的查询
SELECT * FROM articles ORDER BY created_time DESC;
```

**🔸 JOIN连接条件的列**
```sql
-- ✅ 为连接键创建索引
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_category_id ON products(category_id);

-- 支持的查询
SELECT u.name, o.amount 
FROM users u 
JOIN orders o ON u.id = o.user_id;
```

### 2.2 不适合创建索引的情况


**❌ 避免的场景**
```sql
-- 1. 频繁更新的列
-- 用户活跃时间每次登录都会更新
-- ❌ 不建议：CREATE INDEX idx_last_login ON users(last_login_time);

-- 2. 重复值太多的列（选择性差）
-- 性别字段只有2-3个值
-- ❌ 不建议：CREATE INDEX idx_gender ON users(gender);

-- 3. 小表
-- 表数据少于1000行，全表扫描更快
-- ❌ 不建议：为小型配置表创建索引
```

### 2.3 索引选择性计算


**选择性**：不重复值的数量与表总行数的比值，越接近1越好。

```sql
-- 计算选择性
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) as selectivity
FROM table_name;

-- 示例：计算邮箱字段的选择性
SELECT 
    COUNT(DISTINCT email) / COUNT(*) as email_selectivity
FROM users;
-- 结果：0.98（选择性很好，适合创建索引）

-- 对比：计算性别字段的选择性  
SELECT 
    COUNT(DISTINCT gender) / COUNT(*) as gender_selectivity
FROM users;
-- 结果：0.0002（选择性很差，不适合创建索引）
```

> **💡 选择性标准**：一般认为选择性大于0.1的字段适合创建索引

---

## 3. 🔧 复合索引设计规则


### 3.1 什么是复合索引

**复合索引**：在多个列上创建的单个索引，也叫联合索引。

```sql
-- 创建复合索引
CREATE INDEX idx_user_age_city ON users(age, city, gender);

-- 相当于创建了一个包含三列的索引结构
┌─────┬──────┬──────┬──────┐
│ age │ city │gender│ 行号  │
├─────┼──────┼──────┼──────┤
│ 22  │ 北京  │  M   │  1   │
│ 22  │ 上海  │  F   │  3   │  
│ 25  │ 北京  │  M   │  2   │
└─────┴──────┴──────┴──────┘
```

### 3.2 最左前缀原则


**核心规则**：复合索引只能从最左边的列开始使用。

```sql
-- 索引：idx_age_city_gender (age, city, gender)

-- ✅ 能使用索引的查询
SELECT * FROM users WHERE age = 25;                    -- 使用age
SELECT * FROM users WHERE age = 25 AND city = '北京';   -- 使用age+city  
SELECT * FROM users WHERE age = 25 AND city = '北京' AND gender = 'M'; -- 使用全部

-- ❌ 不能使用索引的查询
SELECT * FROM users WHERE city = '北京';               -- 跳过了age
SELECT * FROM users WHERE gender = 'M';               -- 跳过了age和city
SELECT * FROM users WHERE city = '北京' AND gender = 'M'; -- 跳过了age
```

**理解最左前缀原则**：
```
把复合索引想象成电话簿：
1. 首先按姓氏排序（age）
2. 姓氏相同的按名字排序（city）  
3. 姓名相同的按其他信息排序（gender）

如果你不知道姓氏，就无法快速找到某个人
这就是为什么必须从最左边开始使用
```

### 3.3 复合索引设计策略


**🔸 查询频率优先原则**
```sql
-- 根据查询使用频率排列字段顺序
-- 假设查询场景：
-- 80%：WHERE status = ? AND created_time > ?
-- 15%：WHERE status = ?  
-- 5%：WHERE created_time > ?

-- ✅ 推荐设计
CREATE INDEX idx_status_time ON orders(status, created_time);
```

**🔸 选择性优先原则**
```sql
-- 选择性高的字段放在前面
-- email选择性：0.99
-- age选择性：0.05
-- city选择性：0.02

-- ✅ 推荐设计
CREATE INDEX idx_email_age_city ON users(email, age, city);
```

**🔸 范围查询字段放最后**
```sql
-- ❌ 不好的设计
CREATE INDEX idx_time_status ON orders(created_time, status);
-- WHERE created_time > ? AND status = ?
-- 范围查询后的字段无法有效使用索引

-- ✅ 好的设计  
CREATE INDEX idx_status_time ON orders(status, created_time);
-- WHERE status = ? AND created_time > ?
-- 先精确匹配，再范围查询
```

---

## 4. 📝 索引命名与使用规范


### 4.1 索引命名规范


**🔸 命名规则**
```sql
-- 单列索引：idx_表名_列名
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_status ON orders(status);

-- 复合索引：idx_表名_列名1_列名2
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_products_category_price ON products(category_id, price);

-- 唯一索引：uk_表名_列名
CREATE UNIQUE INDEX uk_users_email ON users(email);

-- 主键：pk_表名（通常自动创建）
-- 外键索引：fk_表名_引用表名
CREATE INDEX fk_orders_users ON orders(user_id);
```

### 4.2 覆盖索引使用标准


**覆盖索引**：索引包含了查询所需的全部列，无需回表查询。

```sql
-- 查询需求
SELECT user_id, status, total_amount 
FROM orders 
WHERE user_id = 123 AND status = 'completed';

-- ✅ 创建覆盖索引
CREATE INDEX idx_orders_cover 
ON orders(user_id, status, total_amount);

-- 解释执行计划会显示"Using index"
EXPLAIN SELECT user_id, status, total_amount 
FROM orders 
WHERE user_id = 123 AND status = 'completed';
```

**覆盖索引的优势**：
```
传统索引查询过程：
1. 在索引中找到匹配行的行号
2. 根据行号回到表中获取完整数据
3. 返回所需字段

覆盖索引查询过程：
1. 在索引中找到匹配行
2. 直接从索引获取所需字段  
3. 无需回表，性能更好
```

### 4.3 索引使用注意事项


**🔸 避免索引失效的情况**
```sql
-- ❌ 在索引列上使用函数
SELECT * FROM users WHERE UPPER(name) = 'ZHANGSAN';

-- ✅ 正确写法
SELECT * FROM users WHERE name = 'zhangsan';

-- ❌ 使用不等于操作符
SELECT * FROM users WHERE status != 'deleted';

-- ✅ 使用IN操作符
SELECT * FROM users WHERE status IN ('active', 'inactive');

-- ❌ LIKE以通配符开头
SELECT * FROM users WHERE name LIKE '%张%';

-- ✅ LIKE以常量开头
SELECT * FROM users WHERE name LIKE '张%';
```

---

## 5. ⚡ 索引性能优化策略


### 5.1 索引大小控制


**🔸 控制索引键长度**
```sql
-- ❌ 索引过长的字段
CREATE INDEX idx_description ON articles(description); -- VARCHAR(5000)

-- ✅ 使用前缀索引
CREATE INDEX idx_description_prefix ON articles(description(50));

-- 测试前缀长度的选择性
SELECT 
    COUNT(DISTINCT LEFT(description, 10)) / COUNT(*) as len_10,
    COUNT(DISTINCT LEFT(description, 20)) / COUNT(*) as len_20,
    COUNT(DISTINCT LEFT(description, 50)) / COUNT(*) as len_50
FROM articles;
```

**🔸 避免过多索引**
```sql
-- ❌ 每个字段都创建索引
CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_email ON users(email);  
CREATE INDEX idx_phone ON users(phone);
CREATE INDEX idx_address ON users(address);

-- ✅ 根据查询需求创建必要索引
CREATE INDEX idx_email ON users(email);     -- 登录查询
CREATE INDEX idx_name_phone ON users(name, phone); -- 搜索查询
```

### 5.2 冗余索引避免


**识别冗余索引**：
```sql
-- 如果已有索引：idx_user_age_city (user_id, age, city)
-- 则以下索引是冗余的：
-- idx_user (user_id) -- 被包含在复合索引中
-- idx_user_age (user_id, age) -- 被包含在复合索引中

-- 查找冗余索引的SQL
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
GROUP BY TABLE_NAME, INDEX_NAME;
```

### 5.3 索引效果预测


**🔸 分析查询执行计划**
```sql
-- 查看索引使用情况
EXPLAIN SELECT * FROM orders 
WHERE user_id = 123 AND status = 'completed';

-- 关键指标解读：
-- type: const > eq_ref > ref > range > index > ALL
-- key: 使用的索引名称
-- rows: 预估扫描行数
-- Extra: Using index（覆盖索引）、Using filesort（需要排序）
```

**🔸 索引成本收益分析**
```sql
-- 计算索引空间占用
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 2) AS 'SIZE_MB'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;

-- 查看索引使用统计
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT,
    COUNT_UPDATE,
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database';
```

---

## 6. 📊 索引监控与维护


### 6.1 在线索引变更


**🔸 安全的索引操作**
```sql
-- MySQL 5.7+支持在线DDL
-- ✅ 在线添加索引
ALTER TABLE orders 
ADD INDEX idx_created_time (created_time),
ALGORITHM=INPLACE, LOCK=NONE;

-- ✅ 在线删除索引
ALTER TABLE orders 
DROP INDEX idx_old_index,
ALGORITHM=INPLACE, LOCK=NONE;
```

**🔸 大表索引变更策略**
```sql
-- 对于大表（千万级以上），建议：
-- 1. 在业务低峰期操作
-- 2. 使用pt-online-schema-change工具
pt-online-schema-change \
  --alter "ADD INDEX idx_status (status)" \
  --host=localhost \
  --user=root \
  --password=password \
  D=database_name,t=table_name \
  --execute
```

### 6.2 索引监控策略


**🔸 监控关键指标**
```sql
-- 1. 索引使用率监控
SELECT 
    s.TABLE_SCHEMA,
    s.TABLE_NAME,
    s.INDEX_NAME,
    s.CARDINALITY,
    t.COUNT_FETCH
FROM information_schema.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage t
  ON s.TABLE_SCHEMA = t.OBJECT_SCHEMA 
  AND s.TABLE_NAME = t.OBJECT_NAME 
  AND s.INDEX_NAME = t.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
  AND t.COUNT_FETCH IS NULL;  -- 未使用的索引

-- 2. 慢查询中的索引分析
SELECT 
    sql_text,
    exec_count,
    avg_timer_wait/1000000000 as avg_time_sec,
    rows_examined_avg,
    rows_sent_avg
FROM performance_schema.events_statements_summary_by_digest
WHERE avg_timer_wait > 1000000000  -- 超过1秒
ORDER BY avg_timer_wait DESC;
```

### 6.3 索引自动化管理


**🔸 定期维护脚本**
```sql
-- 索引碎片检查
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    SUB_PART,
    PACKED,
    NULLABLE,
    INDEX_TYPE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
  AND CARDINALITY IS NOT NULL
ORDER BY TABLE_NAME, INDEX_NAME;

-- 重建索引（针对碎片严重的索引）
ALTER TABLE table_name ENGINE=InnoDB;
```

**🔸 监控告警规则**
```sql
-- 设置监控规则
-- 1. 索引大小超过表大小的50%
-- 2. 有超过3个月未使用的索引
-- 3. 慢查询中出现全表扫描
-- 4. 索引碎片率超过30%
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的索引设计原则


```
🔸 创建原则：WHERE、ORDER BY、JOIN字段优先
🔸 复合索引：遵循最左前缀原则，注意字段顺序
🔸 命名规范：idx_表名_字段名，语义清晰
🔸 覆盖索引：包含查询所需全部字段，避免回表
🔸 选择性：计算字段区分度，选择性高的字段适合索引
```

### 7.2 关键理解要点


**🔹 索引的本质**
```
空间换时间的策略：
- 占用额外存储空间
- 提升查询性能
- 降低写入性能（需要维护索引）
- 需要在查询和写入之间找到平衡
```

**🔹 复合索引的威力**
```
一个好的复合索引胜过多个单列索引：
- 支持多种查询模式
- 可以实现覆盖索引
- 减少索引维护成本
- 符合最左前缀原则
```

**🔹 索引设计的权衡**
```
设计考虑因素：
- 查询频率 vs 写入频率
- 索引维护成本 vs 查询性能提升
- 存储空间 vs 查询速度
- 索引数量 vs 维护复杂度
```

### 7.3 实际应用指导


**🎯 设计流程**
1. **分析查询模式**：统计最频繁的查询类型
2. **评估字段选择性**：计算候选字段的区分度
3. **设计复合索引**：合理安排字段顺序
4. **测试验证效果**：使用EXPLAIN分析执行计划
5. **监控优化调整**：持续观察索引使用情况

**🎯 常见场景的索引策略**
- **用户系统**：邮箱唯一索引 + 姓名搜索索引
- **订单系统**：用户ID+状态复合索引 + 时间范围索引  
- **商品系统**：分类ID+价格复合索引 + 全文搜索索引
- **日志系统**：时间分区索引 + 关键字段组合索引

### 7.4 避免的常见误区


```
❌ 误区1：为每个字段都创建索引
✅ 正确：根据查询需求创建必要索引

❌ 误区2：复合索引字段顺序随意
✅ 正确：遵循最左前缀原则和选择性原则

❌ 误区3：从不删除无用索引
✅ 正确：定期清理未使用的索引

❌ 误区4：忽视索引维护成本
✅ 正确：平衡查询性能和写入性能
```

**核心记忆口诀**：
- 索引设计要慎重，查询模式是关键
- 复合索引遵左序，选择性高排前面  
- 覆盖索引效果好，避免回表性能高
- 定期监控清无用，维护成本要考量