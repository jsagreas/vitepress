---
title: 9ã€MySQLç»„ä»¶äº¤äº’æœºåˆ¶
---
## ğŸ“š ç›®å½•

1. [MySQLç»„ä»¶æ¶æ„æ¦‚è§ˆ](#1-MySQLç»„ä»¶æ¶æ„æ¦‚è§ˆ)
2. [ğŸ”‘ ç»„ä»¶äº¤äº’åŸºæœ¬æ¨¡å¼](#2-ç»„ä»¶äº¤äº’åŸºæœ¬æ¨¡å¼)
3. [ç»„ä»¶é€šä¿¡åè®®æœºåˆ¶](#3-ç»„ä»¶é€šä¿¡åè®®æœºåˆ¶)
4. [ğŸ”‘ æ¥å£è®¾è®¡è§„èŒƒ](#4-æ¥å£è®¾è®¡è§„èŒƒ)
5. [ğŸ”¥ ç»„ä»¶æœåŠ¡æ³¨å†Œå‘ç°](#5-ç»„ä»¶æœåŠ¡æ³¨å†Œå‘ç°)
6. [ğŸ”¥ ç»„ä»¶çŠ¶æ€åŒæ­¥åè®®](#6-ç»„ä»¶çŠ¶æ€åŒæ­¥åè®®)
7. [ğŸ”¥ ç»„ä»¶æ•…éšœéš”ç¦»æœºåˆ¶](#7-ç»„ä»¶æ•…éšœéš”ç¦»æœºåˆ¶)
8. [ğŸ”¥ ç»„ä»¶æ€§èƒ½ç›‘æ§æ¥å£](#8-ç»„ä»¶æ€§èƒ½ç›‘æ§æ¥å£)
9. [ğŸ”¥ ç»„ä»¶é…ç½®çƒ­æ›´æ–°](#9-ç»„ä»¶é…ç½®çƒ­æ›´æ–°)
10. [ğŸ”¥ ç»„ä»¶ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†](#10-ç»„ä»¶ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†)
11. [ğŸ”‘ æ‰©å±•æ€§è®¾è®¡åŸåˆ™](#11-æ‰©å±•æ€§è®¾è®¡åŸåˆ™)
12. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#12-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ—ï¸ MySQLç»„ä»¶æ¶æ„æ¦‚è§ˆ


### 1.1 MySQLæ•´ä½“æ¶æ„åˆ†å±‚


MySQLçš„æ¶æ„å°±åƒä¸€ä¸ªå¤§å‹ä¼ä¸šçš„ç»„ç»‡ç»“æ„ï¼Œå„ä¸ªéƒ¨é—¨ï¼ˆç»„ä»¶ï¼‰å„å¸å…¶èŒåˆç›¸äº’é…åˆã€‚

```
MySQLæ¶æ„åˆ†å±‚å›¾ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           è¿æ¥å±‚ (Connection Layer)    â”‚ â† å®¢æˆ·ç«¯è¿æ¥ç®¡ç†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           æœåŠ¡å±‚ (SQL Layer)          â”‚ â† SQLè§£æã€ä¼˜åŒ–ã€æ‰§è¡Œ
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ è¿æ¥å™¨ â”‚ æŸ¥è¯¢ç¼“å­˜ â”‚ åˆ†æå™¨ â”‚ ä¼˜åŒ–å™¨ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æ‰§è¡Œå™¨ â”‚ æƒé™ç®¡ç† â”‚ æ—¥å¿—æ¨¡å—      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           å¼•æ“å±‚ (Storage Engine)     â”‚ â† æ•°æ®å­˜å‚¨å’Œæ£€ç´¢
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ InnoDB â”‚ MyISAM â”‚ Memory â”‚ ...   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           ç³»ç»Ÿå±‚ (System Layer)       â”‚ â† æ–‡ä»¶ç³»ç»Ÿã€æ“ä½œç³»ç»Ÿ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒç»„ä»¶æ¸…å•


**ğŸ”¸ ä¸»è¦ç»„ä»¶åŠå…¶èŒè´£**

| ç»„ä»¶ç±»åˆ« | **æ ¸å¿ƒç»„ä»¶** | **ä¸»è¦èŒè´£** | **äº¤äº’é¢‘ç‡** |
|---------|-------------|-------------|-------------|
| ğŸ”Œ **è¿æ¥ç®¡ç†** | `è¿æ¥å™¨ã€çº¿ç¨‹æ± ` | `å®¢æˆ·ç«¯è¿æ¥å¤„ç†` | `ğŸ”¥æé«˜` |
| ğŸ§  **SQLå¤„ç†** | `è§£æå™¨ã€ä¼˜åŒ–å™¨ã€æ‰§è¡Œå™¨` | `SQLè¯­å¥å¤„ç†` | `ğŸ”¥æé«˜` |
| ğŸ’¾ **å­˜å‚¨å¼•æ“** | `InnoDBã€MyISAM` | `æ•°æ®å­˜å‚¨æ£€ç´¢` | `ğŸ”¥æé«˜` |
| ğŸ“ **æ—¥å¿—ç³»ç»Ÿ** | `redo logã€binlogã€undo log` | `äº‹åŠ¡æ—¥å¿—è®°å½•` | `ğŸŸ¡é«˜` |
| ğŸ”’ **é”ç®¡ç†** | `è¡¨é”ã€è¡Œé”ã€å…ƒæ•°æ®é”` | `å¹¶å‘æ§åˆ¶` | `ğŸŸ¡é«˜` |
| ğŸ“Š **ç¼“å­˜ç³»ç»Ÿ** | `æŸ¥è¯¢ç¼“å­˜ã€Buffer Pool` | `æ€§èƒ½ä¼˜åŒ–` | `ğŸŸ¡é«˜` |

### 1.3 ç»„ä»¶ä¾èµ–å…³ç³»å›¾


```
ç»„ä»¶ä¾èµ–å…³ç³»ï¼š

        å®¢æˆ·ç«¯è¿æ¥
            â”‚
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   è¿æ¥å™¨     â”‚ â”€â”€â†’ çº¿ç¨‹æ± ç®¡ç†
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   æƒé™éªŒè¯   â”‚ â†â†’ ç”¨æˆ·æƒé™è¡¨
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  æŸ¥è¯¢ç¼“å­˜    â”‚ â†â†’ æŸ¥è¯¢ç»“æœç¼“å­˜
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   SQLè§£æå™¨  â”‚ â†â†’ â”‚   è¯­æ³•åˆ†æ   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   æŸ¥è¯¢ä¼˜åŒ–å™¨ â”‚ â†â†’ â”‚   ç»Ÿè®¡ä¿¡æ¯   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   æ‰§è¡Œå™¨     â”‚ â†â†’ â”‚   å­˜å‚¨å¼•æ“   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ğŸ”‘ ç»„ä»¶äº¤äº’åŸºæœ¬æ¨¡å¼


### 2.1 äº¤äº’æ¨¡å¼åˆ†ç±»


MySQLç»„ä»¶é—´çš„äº¤äº’å°±åƒäººä¸äººä¹‹é—´çš„æ²Ÿé€šæ–¹å¼ï¼Œæœ‰ä¸åŒçš„æ¨¡å¼å’Œè§„åˆ™ã€‚

**ğŸ“‹ ä¸»è¦äº¤äº’æ¨¡å¼**

```
ğŸ”„ åŒæ­¥è°ƒç”¨æ¨¡å¼ï¼š
   è°ƒç”¨æ–¹ â”€â”€è¯·æ±‚â”€â”€â†’ è¢«è°ƒç”¨æ–¹
   è°ƒç”¨æ–¹ â†â”€ç»“æœâ”€â”€â”€ è¢«è°ƒç”¨æ–¹
   ç‰¹ç‚¹ï¼šç­‰å¾…å“åº”ï¼Œé˜»å¡å¼
   åº”ç”¨ï¼šSQLæ‰§è¡Œã€æ•°æ®æ£€ç´¢

ğŸ“¨ å¼‚æ­¥é€šçŸ¥æ¨¡å¼ï¼š
   å‘é€æ–¹ â”€â”€äº‹ä»¶â”€â”€â†’ æ¥æ”¶æ–¹
   å‘é€æ–¹           æ¥æ”¶æ–¹ï¼ˆç‹¬ç«‹å¤„ç†ï¼‰
   ç‰¹ç‚¹ï¼šä¸ç­‰å¾…å“åº”ï¼Œéé˜»å¡
   åº”ç”¨ï¼šæ—¥å¿—å†™å…¥ã€åå°ä»»åŠ¡

ğŸ”” äº‹ä»¶é©±åŠ¨æ¨¡å¼ï¼š
   äº‹ä»¶æº â”€â”€è§¦å‘â”€â”€â†’ äº‹ä»¶æ€»çº¿ â”€â”€åˆ†å‘â”€â”€â†’ å¤šä¸ªç›‘å¬è€…
   ç‰¹ç‚¹ï¼šä¸€å¯¹å¤šï¼Œæ¾è€¦åˆ
   åº”ç”¨ï¼šçŠ¶æ€å˜æ›´ã€ç›‘æ§å‘Šè­¦

ğŸ¤ åä½œå¼æ¨¡å¼ï¼š
   ç»„ä»¶A â†â”€â”€åä½œâ”€â”€â†’ ç»„ä»¶B â†â”€â”€åä½œâ”€â”€â†’ ç»„ä»¶C
   ç‰¹ç‚¹ï¼šå¤šæ–¹é…åˆï¼Œå…±åŒå®Œæˆä»»åŠ¡
   åº”ç”¨ï¼šäº‹åŠ¡å¤„ç†ã€å¤åˆ¶åŒæ­¥
```

### 2.2 è°ƒç”¨å±‚æ¬¡ç»“æ„


**ç»„ä»¶è°ƒç”¨çš„å±‚æ¬¡å…³ç³»**

```
è°ƒç”¨å±‚æ¬¡ï¼ˆä»ä¸Šåˆ°ä¸‹ï¼‰ï¼š

åº”ç”¨å±‚è°ƒç”¨ï¼š
â”œâ”€â”€ å®¢æˆ·ç«¯ â†’ è¿æ¥å™¨
â””â”€â”€ è¿æ¥å™¨ â†’ æƒé™éªŒè¯

æœåŠ¡å±‚è°ƒç”¨ï¼š
â”œâ”€â”€ æƒé™éªŒè¯ â†’ SQLè§£æå™¨
â”œâ”€â”€ SQLè§£æå™¨ â†’ æŸ¥è¯¢ä¼˜åŒ–å™¨
â”œâ”€â”€ æŸ¥è¯¢ä¼˜åŒ–å™¨ â†’ æ‰§è¡Œå™¨
â””â”€â”€ æ‰§è¡Œå™¨ â†’ å­˜å‚¨å¼•æ“æ¥å£

å¼•æ“å±‚è°ƒç”¨ï¼š
â”œâ”€â”€ å­˜å‚¨å¼•æ“æ¥å£ â†’ å…·ä½“å­˜å‚¨å¼•æ“
â”œâ”€â”€ InnoDB â†’ Buffer Pool
â”œâ”€â”€ InnoDB â†’ æ—¥å¿—ç³»ç»Ÿ
â””â”€â”€ InnoDB â†’ é”ç®¡ç†å™¨

ç³»ç»Ÿå±‚è°ƒç”¨ï¼š
â”œâ”€â”€ å­˜å‚¨å¼•æ“ â†’ æ–‡ä»¶ç³»ç»Ÿ
â”œâ”€â”€ æ—¥å¿—ç³»ç»Ÿ â†’ ç£ç›˜IO
â””â”€â”€ ç½‘ç»œå±‚ â†’ æ“ä½œç³»ç»ŸAPI
```

### 2.3 æ¶ˆæ¯ä¼ é€’æœºåˆ¶


**ç»„ä»¶é—´æ•°æ®ä¼ é€’çš„æ–¹å¼**

```cpp
// åŸºæœ¬çš„æ¶ˆæ¯ä¼ é€’ç»“æ„
struct ComponentMessage {
    int sender_id;          // å‘é€æ–¹ç»„ä»¶ID
    int receiver_id;        // æ¥æ”¶æ–¹ç»„ä»¶ID
    int message_type;       // æ¶ˆæ¯ç±»å‹
    void* data;            // æ¶ˆæ¯æ•°æ®
    size_t data_size;      // æ•°æ®å¤§å°
    callback_func callback; // å›è°ƒå‡½æ•°
};

// æ¶ˆæ¯ç±»å‹å®šä¹‰
enum MessageType {
    MSG_SQL_REQUEST = 1,    // SQLè¯·æ±‚
    MSG_DATA_REQUEST = 2,   // æ•°æ®è¯·æ±‚
    MSG_STATUS_UPDATE = 3,  // çŠ¶æ€æ›´æ–°
    MSG_ERROR_NOTIFY = 4,   // é”™è¯¯é€šçŸ¥
    MSG_CONFIG_CHANGE = 5   // é…ç½®å˜æ›´
};
```

---

## 3. ğŸŒ ç»„ä»¶é€šä¿¡åè®®æœºåˆ¶


### 3.1 å†…éƒ¨é€šä¿¡åè®®


MySQLå†…éƒ¨ç»„ä»¶é€šä¿¡å°±åƒä¼ä¸šå†…éƒ¨çš„æ²Ÿé€šæµç¨‹ï¼Œéœ€è¦ç»Ÿä¸€çš„"è¯­è¨€"å’Œè§„èŒƒã€‚

**ğŸ”¸ é€šä¿¡åè®®åˆ†å±‚**

```
MySQLå†…éƒ¨é€šä¿¡åè®®æ ˆï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    åº”ç”¨åè®®å±‚        â”‚ â† SQLåè®®ã€å‘½ä»¤åè®®
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    ä¼šè¯åè®®å±‚        â”‚ â† ä¼šè¯ç®¡ç†ã€çŠ¶æ€ç»´æŠ¤
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    ä¼ è¾“åè®®å±‚        â”‚ â† æ•°æ®ä¼ è¾“ã€æµæ§åˆ¶
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    æ¥å£åè®®å±‚        â”‚ â† APIè°ƒç”¨ã€å‚æ•°ä¼ é€’
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ¥å£æ ‡å‡†å®šä¹‰


**å­˜å‚¨å¼•æ“æ ‡å‡†æ¥å£**

```cpp
// å­˜å‚¨å¼•æ“æ¥å£å®šä¹‰ï¼ˆç®€åŒ–ç‰ˆï¼‰
class StorageEngine {
public:
    // åŸºç¡€æ“ä½œæ¥å£
    virtual int create_table(const char* name, TABLE* table) = 0;
    virtual int open_table(const char* name, int mode) = 0;
    virtual int close_table() = 0;
    
    // æ•°æ®æ“ä½œæ¥å£
    virtual int read_row(uchar* buf) = 0;
    virtual int write_row(uchar* buf) = 0;
    virtual int update_row(const uchar* old_data, uchar* new_data) = 0;
    virtual int delete_row(const uchar* buf) = 0;
    
    // ç´¢å¼•æ“ä½œæ¥å£
    virtual int index_read(uchar* buf, const uchar* key, uint key_len) = 0;
    virtual int index_next(uchar* buf) = 0;
    virtual int index_prev(uchar* buf) = 0;
    
    // äº‹åŠ¡æ¥å£
    virtual int start_transaction() = 0;
    virtual int commit_transaction() = 0;
    virtual int rollback_transaction() = 0;
};
```

### 3.3 äº‹ä»¶é€šçŸ¥ç³»ç»Ÿ


**ğŸ”” äº‹ä»¶é€šçŸ¥æœºåˆ¶**

```
äº‹ä»¶ç±»å‹åˆ†ç±»ï¼š

ç³»ç»Ÿçº§äº‹ä»¶ï¼š
â”œâ”€â”€ æœåŠ¡å¯åŠ¨/åœæ­¢
â”œâ”€â”€ ç»„ä»¶åŠ è½½/å¸è½½
â”œâ”€â”€ é…ç½®æ–‡ä»¶å˜æ›´
â””â”€â”€ ç³»ç»Ÿèµ„æºå‘Šè­¦

ä¼šè¯çº§äº‹ä»¶ï¼š
â”œâ”€â”€ è¿æ¥å»ºç«‹/æ–­å¼€
â”œâ”€â”€ ç”¨æˆ·ç™»å½•/ç™»å‡º
â”œâ”€â”€ æƒé™å˜æ›´
â””â”€â”€ ä¼šè¯è¶…æ—¶

äº‹åŠ¡çº§äº‹ä»¶ï¼š
â”œâ”€â”€ äº‹åŠ¡å¼€å§‹/æäº¤/å›æ»š
â”œâ”€â”€ é”è·å–/é‡Šæ”¾
â”œâ”€â”€ æ­»é”æ£€æµ‹
â””â”€â”€ æ•°æ®å˜æ›´

æŸ¥è¯¢çº§äº‹ä»¶ï¼š
â”œâ”€â”€ SQLè§£æå¼€å§‹/å®Œæˆ
â”œâ”€â”€ æŸ¥è¯¢æ‰§è¡Œå¼€å§‹/å®Œæˆ
â”œâ”€â”€ æ…¢æŸ¥è¯¢æ£€æµ‹
â””â”€â”€ æŸ¥è¯¢ç¼“å­˜å‘½ä¸­/æœªå‘½ä¸­
```

**äº‹ä»¶å¤„ç†æµç¨‹**

```
äº‹ä»¶å¤„ç†æµç¨‹ï¼š

äº‹ä»¶å‘ç”Ÿ â†’ äº‹ä»¶æ”¶é›†å™¨ â†’ äº‹ä»¶é˜Ÿåˆ— â†’ äº‹ä»¶åˆ†å‘å™¨ â†’ äº‹ä»¶å¤„ç†å™¨
    â”‚           â”‚           â”‚           â”‚           â”‚
    â”‚           â”‚           â”‚           â”‚           â””â”€â†’ æ—¥å¿—è®°å½•
    â”‚           â”‚           â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ç›‘æ§æŠ¥å‘Š  
    â”‚           â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ å‘Šè­¦é€šçŸ¥
    â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ æ€§èƒ½ç»Ÿè®¡
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ è°ƒè¯•è·Ÿè¸ª
```

---

## 4. ğŸ”‘ æ¥å£è®¾è®¡è§„èŒƒ


### 4.1 æ¥å£è®¾è®¡åŸåˆ™


è®¾è®¡å¥½çš„ç»„ä»¶æ¥å£å°±åƒåˆ¶å®šå¥½çš„åˆåŒæ¡æ¬¾ï¼Œè¦æ¸…æ™°ã€å®Œæ•´ã€ä¾¿äºæ‰§è¡Œã€‚

**ğŸ’¡ æ¥å£è®¾è®¡æ ¸å¿ƒåŸåˆ™**

```
ğŸ¯ å•ä¸€èŒè´£åŸåˆ™ï¼š
   æ¯ä¸ªæ¥å£åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½
   ä¾‹ï¼šæ•°æ®è¯»å–æ¥å£åªè´Ÿè´£è¯»å–ï¼Œä¸è´Ÿè´£å†™å…¥

ğŸ”’ æ¥å£éš”ç¦»åŸåˆ™ï¼š
   å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£
   ä¾‹ï¼šåªè¯»å®¢æˆ·ç«¯ä¸éœ€è¦å†™å…¥æ¥å£

ğŸ”„ ä¾èµ–å€’ç½®åŸåˆ™ï¼š
   é«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–ä½å±‚æ¨¡å—
   ä¾‹ï¼šSQLå±‚ä¸ç›´æ¥ä¾èµ–å…·ä½“å­˜å‚¨å¼•æ“

ğŸ›¡ï¸ å¼€é—­åŸåˆ™ï¼š
   å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
   ä¾‹ï¼šæ–°å¢å­˜å‚¨å¼•æ“ä¸éœ€è¦ä¿®æ”¹ç°æœ‰ä»£ç 
```

### 4.2 æ¥å£è§„èŒƒæ¨¡æ¿


**æ ‡å‡†æ¥å£å®šä¹‰æ¨¡æ¿**

```cpp
// æ¥å£è§„èŒƒæ¨¡æ¿
class ComponentInterface {
public:
    // 1. åˆå§‹åŒ–å’Œæ¸…ç†
    virtual int initialize(const Config& config) = 0;
    virtual int shutdown() = 0;
    
    // 2. çŠ¶æ€ç®¡ç†
    virtual ComponentState get_state() const = 0;
    virtual bool is_ready() const = 0;
    virtual std::string get_status_info() const = 0;
    
    // 3. æ ¸å¿ƒåŠŸèƒ½æ¥å£
    virtual int process_request(const Request& req, Response& resp) = 0;
    
    // 4. é…ç½®ç®¡ç†
    virtual int update_config(const Config& config) = 0;
    virtual Config get_config() const = 0;
    
    // 5. é”™è¯¯å¤„ç†
    virtual int get_last_error() const = 0;
    virtual std::string get_error_message() const = 0;
    
    // 6. ç›‘æ§æ¥å£
    virtual Statistics get_statistics() const = 0;
    virtual void reset_statistics() = 0;
    
protected:
    virtual ~ComponentInterface() = default;
};
```

### 4.3 å‚æ•°ä¼ é€’è§„èŒƒ


**ğŸ”§ å‚æ•°ä¼ é€’æœ€ä½³å®è·µ**

| å‚æ•°ç±»å‹ | **ä¼ é€’æ–¹å¼** | **ä½¿ç”¨åœºæ™¯** | **æ³¨æ„äº‹é¡¹** |
|---------|-------------|-------------|-------------|
| ğŸ”¢ **åŸºæœ¬ç±»å‹** | `å€¼ä¼ é€’` | `ç®€å•å‚æ•°` | `æ€§èƒ½å¥½ï¼Œå®‰å…¨` |
| ğŸ“¦ **å°å¯¹è±¡** | `constå¼•ç”¨` | `ç»“æ„ä½“ã€å­—ç¬¦ä¸²` | `é¿å…æ‹·è´å¼€é”€` |
| ğŸ—‚ï¸ **å¤§å¯¹è±¡** | `æ™ºèƒ½æŒ‡é’ˆ` | `å¤æ‚æ•°æ®ç»“æ„` | `è‡ªåŠ¨å†…å­˜ç®¡ç†` |
| ğŸ“‹ **æ•°ç»„/ç¼“å†²åŒº** | `æŒ‡é’ˆ+é•¿åº¦` | `æ•°æ®ç¼“å†²åŒº` | `éœ€è¦è¾¹ç•Œæ£€æŸ¥` |

```cpp
// å‚æ•°ä¼ é€’ç¤ºä¾‹
class DataProcessor {
public:
    // âœ… å¥½çš„æ¥å£è®¾è®¡
    int process_data(
        const std::string& table_name,      // constå¼•ç”¨ä¼ é€’å­—ç¬¦ä¸²
        const std::vector<Record>& records, // constå¼•ç”¨ä¼ é€’å®¹å™¨
        ProcessOptions options,             // å€¼ä¼ é€’å°å¯¹è±¡
        std::shared_ptr<Result>& result     // æ™ºèƒ½æŒ‡é’ˆä¼ é€’å¤§å¯¹è±¡
    );
    
    // âŒ ä¸å¥½çš„æ¥å£è®¾è®¡
    int bad_process(char* name, Record* recs, int count, Result** result);
};
```

---

## 5. ğŸ”¥ ç»„ä»¶æœåŠ¡æ³¨å†Œå‘ç°


### 5.1 æœåŠ¡æ³¨å†Œæœºåˆ¶


ç»„ä»¶æœåŠ¡æ³¨å†Œå°±åƒä¼ä¸šå‘˜å·¥å…¥èŒç™»è®°ï¼Œè®©ç³»ç»ŸçŸ¥é“æœ‰å“ªäº›ç»„ä»¶å¯ä»¥æä¾›ä»€ä¹ˆæœåŠ¡ã€‚

**ğŸ”¸ æœåŠ¡æ³¨å†Œä¸­å¿ƒè®¾è®¡**

```cpp
// æœåŠ¡æ³¨å†Œä¸­å¿ƒ
class ServiceRegistry {
private:
    std::unordered_map<std::string, ServiceInfo> services_;
    std::mutex registry_mutex_;
    
public:
    struct ServiceInfo {
        std::string service_name;    // æœåŠ¡åç§°
        std::string component_id;    // ç»„ä»¶æ ‡è¯†
        std::string version;         // ç‰ˆæœ¬ä¿¡æ¯
        std::vector<std::string> interfaces; // æä¾›çš„æ¥å£
        ServiceState state;          // æœåŠ¡çŠ¶æ€
        time_t register_time;        // æ³¨å†Œæ—¶é—´
        time_t last_heartbeat;       // æœ€åå¿ƒè·³
        std::string endpoint;        // æœåŠ¡ç«¯ç‚¹
        std::map<std::string, std::string> metadata; // å…ƒæ•°æ®
    };
    
    // æœåŠ¡æ³¨å†Œ
    bool register_service(const ServiceInfo& info);
    // æœåŠ¡æ³¨é”€
    bool unregister_service(const std::string& service_name);
    // æœåŠ¡å‘ç°
    std::vector<ServiceInfo> discover_services(const std::string& interface_name);
    // å¥åº·æ£€æŸ¥
    void health_check();
};
```

### 5.2 æœåŠ¡å‘ç°æµç¨‹


**æœåŠ¡å‘ç°çš„å®Œæ•´æµç¨‹**

```
æœåŠ¡å‘ç°æµç¨‹ï¼š

æ­¥éª¤ 1ï¸âƒ£ ç»„ä»¶å¯åŠ¨æ³¨å†Œ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç»„ä»¶å¯åŠ¨   â”‚ â”€â”€â†’ è¯»å–é…ç½® â”€â”€â†’ æ„é€ ServiceInfo
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ 2ï¸âƒ£ å‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ³¨å†Œä¸­å¿ƒ    â”‚ â†â”€â”€ register_service() â†â”€â”€ ç»„ä»¶
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ 3ï¸âƒ£ æœåŠ¡å‘ç°è¯·æ±‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å®¢æˆ·ç«¯ç»„ä»¶  â”‚ â”€â”€â†’ discover_services("storage_engine")
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ 4ï¸âƒ£ è¿”å›å¯ç”¨æœåŠ¡åˆ—è¡¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ³¨å†Œä¸­å¿ƒ    â”‚ â”€â”€â†’ [InnoDB, MyISAM, Memory]
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ 5ï¸âƒ£ é€‰æ‹©å’Œè°ƒç”¨æœåŠ¡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å®¢æˆ·ç«¯ç»„ä»¶  â”‚ â”€â”€â†’ è´Ÿè½½å‡è¡¡é€‰æ‹© â”€â”€â†’ è°ƒç”¨å…·ä½“æœåŠ¡
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.3 æœåŠ¡å¥åº·æ£€æŸ¥


**ğŸ” å¥åº·æ£€æŸ¥æœºåˆ¶**

```cpp
class HealthChecker {
private:
    std::chrono::seconds check_interval_;
    std::chrono::seconds timeout_threshold_;
    
public:
    struct HealthStatus {
        bool is_healthy;
        std::string status_message;
        std::map<std::string, double> metrics;
        time_t last_check_time;
    };
    
    // æ‰§è¡Œå¥åº·æ£€æŸ¥
    HealthStatus check_component_health(const std::string& component_id) {
        HealthStatus status;
        
        // 1. å¿ƒè·³æ£€æŸ¥
        if (!check_heartbeat(component_id)) {
            status.is_healthy = false;
            status.status_message = "Heartbeat timeout";
            return status;
        }
        
        // 2. èµ„æºä½¿ç”¨æ£€æŸ¥
        auto metrics = get_component_metrics(component_id);
        if (metrics["cpu_usage"] > 90.0) {
            status.is_healthy = false;
            status.status_message = "High CPU usage";
        }
        
        // 3. åŠŸèƒ½æ€§æ£€æŸ¥
        if (!ping_component(component_id)) {
            status.is_healthy = false;
            status.status_message = "Component not responding";
        }
        
        status.metrics = metrics;
        status.last_check_time = time(nullptr);
        return status;
    }
};
```

**å¥åº·æ£€æŸ¥ç­–ç•¥**

| æ£€æŸ¥ç±»å‹ | **æ£€æŸ¥é¢‘ç‡** | **è¶…æ—¶é˜ˆå€¼** | **å¤±è´¥å¤„ç†** |
|---------|-------------|-------------|-------------|
| ğŸ’“ **å¿ƒè·³æ£€æŸ¥** | `5ç§’` | `15ç§’` | `æ ‡è®°ä¸å¥åº·` |
| ğŸ” **åŠŸèƒ½æ£€æŸ¥** | `30ç§’` | `5ç§’` | `å°è¯•é‡å¯` |
| ğŸ“Š **æ€§èƒ½æ£€æŸ¥** | `60ç§’` | `10ç§’` | `æ€§èƒ½å‘Šè­¦` |
| ğŸ”§ **æ·±åº¦æ£€æŸ¥** | `300ç§’` | `30ç§’` | `è¯¦ç»†è¯Šæ–­` |

---

## 6. ğŸ”¥ ç»„ä»¶çŠ¶æ€åŒæ­¥åè®®


### 6.1 çŠ¶æ€åŒæ­¥éœ€æ±‚


ç»„ä»¶çŠ¶æ€åŒæ­¥å°±åƒä¹é˜Ÿæ¼”å¥æ—¶çš„æŒ‡æŒ¥ï¼Œç¡®ä¿æ‰€æœ‰ç»„ä»¶æ­¥è°ƒä¸€è‡´ã€‚

**ğŸ”¸ éœ€è¦åŒæ­¥çš„çŠ¶æ€ç±»å‹**

```
ç³»ç»Ÿçº§çŠ¶æ€ï¼š
â”œâ”€â”€ æœåŠ¡å¯åŠ¨/åœæ­¢çŠ¶æ€
â”œâ”€â”€ é…ç½®ç‰ˆæœ¬ä¿¡æ¯
â”œâ”€â”€ ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ
â””â”€â”€ å…¨å±€å˜é‡è®¾ç½®

ç»„ä»¶çº§çŠ¶æ€ï¼š
â”œâ”€â”€ ç»„ä»¶è¿è¡ŒçŠ¶æ€
â”œâ”€â”€ ç»„ä»¶é…ç½®å‚æ•°
â”œâ”€â”€ ç»„ä»¶æ€§èƒ½æŒ‡æ ‡
â””â”€â”€ ç»„ä»¶é”™è¯¯ä¿¡æ¯

äº‹åŠ¡çº§çŠ¶æ€ï¼š
â”œâ”€â”€ äº‹åŠ¡IDåˆ†é…
â”œâ”€â”€ é”èµ„æºçŠ¶æ€
â”œâ”€â”€ äº‹åŠ¡æäº¤çŠ¶æ€
â””â”€â”€ å›æ»šç‚¹ä¿¡æ¯

æ•°æ®çº§çŠ¶æ€ï¼š
â”œâ”€â”€ æ•°æ®ç‰ˆæœ¬å·
â”œâ”€â”€ ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯
â”œâ”€â”€ ç¼“å­˜çŠ¶æ€
â””â”€â”€ å¤åˆ¶ä½ç‚¹ä¿¡æ¯
```

### 6.2 çŠ¶æ€åŒæ­¥åè®®è®¾è®¡


**çŠ¶æ€åŒæ­¥æ¶ˆæ¯æ ¼å¼**

```cpp
// çŠ¶æ€åŒæ­¥æ¶ˆæ¯ç»“æ„
struct StateSync Message {
    struct Header {
        uint32_t magic_number;      // åè®®æ ‡è¯†
        uint16_t version;           // åè®®ç‰ˆæœ¬
        uint16_t message_type;      // æ¶ˆæ¯ç±»å‹
        uint32_t sequence_id;       // åºåˆ—å·
        uint32_t timestamp;         // æ—¶é—´æˆ³
        uint32_t data_length;       // æ•°æ®é•¿åº¦
        uint32_t checksum;          // æ ¡éªŒå’Œ
    } header;
    
    struct Body {
        std::string component_id;   // ç»„ä»¶æ ‡è¯†
        std::string state_name;     // çŠ¶æ€åç§°
        StateValue state_value;     // çŠ¶æ€å€¼
        uint64_t version_number;    // ç‰ˆæœ¬å·
        uint32_t flags;            // æ ‡å¿—ä½
        std::string metadata;       // å…ƒæ•°æ®
    } body;
};

// çŠ¶æ€å€¼ç±»å‹
struct StateValue {
    enum Type {
        INTEGER, FLOAT, STRING, BINARY, JSON
    } type;
    
    union {
        int64_t int_value;
        double float_value;
        struct {
            char* data;
            size_t length;
        } binary_value;
    };
};
```

### 6.3 çŠ¶æ€ä¸€è‡´æ€§ä¿è¯


**ğŸ”„ ä¸€è‡´æ€§çº§åˆ«**

```
å¼ºä¸€è‡´æ€§ï¼š
â”œâ”€â”€ æ‰€æœ‰ç»„ä»¶å¿…é¡»åŒæ—¶æ›´æ–°çŠ¶æ€
â”œâ”€â”€ é€‚ç”¨ï¼šå…³é”®é…ç½®ã€äº‹åŠ¡çŠ¶æ€
â”œâ”€â”€ å®ç°ï¼šä¸¤é˜¶æ®µæäº¤åè®®
â””â”€â”€ ç‰¹ç‚¹ï¼šå¯é ä½†æ€§èƒ½å¼€é”€å¤§

æœ€ç»ˆä¸€è‡´æ€§ï¼š
â”œâ”€â”€ å…è®¸çŸ­æœŸçŠ¶æ€ä¸ä¸€è‡´
â”œâ”€â”€ é€‚ç”¨ï¼šç»Ÿè®¡ä¿¡æ¯ã€æ—¥å¿—çŠ¶æ€
â”œâ”€â”€ å®ç°ï¼šå¼‚æ­¥å¤åˆ¶åŒæ­¥
â””â”€â”€ ç‰¹ç‚¹ï¼šæ€§èƒ½å¥½ä½†å¯èƒ½çŸ­æš‚ä¸ä¸€è‡´

å¼±ä¸€è‡´æ€§ï¼š
â”œâ”€â”€ ä¸ä¿è¯çŠ¶æ€å®Œå…¨ä¸€è‡´
â”œâ”€â”€ é€‚ç”¨ï¼šç¼“å­˜çŠ¶æ€ã€ä¸´æ—¶æ•°æ®
â”œâ”€â”€ å®ç°ï¼šå°½åŠ›è€Œä¸ºçš„åŒæ­¥
â””â”€â”€ ç‰¹ç‚¹ï¼šæ€§èƒ½æœ€å¥½ï¼Œä¸€è‡´æ€§æœ€å¼±
```

**ä¸¤é˜¶æ®µæäº¤å®ç°**

```cpp
class TwoPhaseCommit {
public:
    enum Phase {
        PREPARE_PHASE,
        COMMIT_PHASE,
        ABORT_PHASE
    };
    
    // åè°ƒè€…å‘èµ·ä¸¤é˜¶æ®µæäº¤
    bool coordinate_state_update(
        const std::vector<std::string>& participants,
        const StateUpdate& update
    ) {
        // é˜¶æ®µ1ï¼šPrepare
        std::vector<bool> prepare_results;
        for (const auto& participant : participants) {
            bool result = send_prepare(participant, update);
            prepare_results.push_back(result);
            
            if (!result) {
                // æœ‰å‚ä¸è€…æ‹’ç»ï¼Œä¸­æ­¢äº‹åŠ¡
                send_abort_to_all(participants);
                return false;
            }
        }
        
        // é˜¶æ®µ2ï¼šCommit
        for (const auto& participant : participants) {
            send_commit(participant, update);
        }
        
        return true;
    }
    
private:
    bool send_prepare(const std::string& participant, const StateUpdate& update);
    void send_commit(const std::string& participant, const StateUpdate& update);
    void send_abort_to_all(const std::vector<std::string>& participants);
};
```

---

## 7. ğŸ”¥ ç»„ä»¶æ•…éšœéš”ç¦»æœºåˆ¶


### 7.1 æ•…éšœéš”ç¦»åŸåˆ™


æ•…éšœéš”ç¦»å°±åƒå»ºç­‘ç‰©çš„é˜²ç«å¢™ï¼Œé˜²æ­¢ä¸€ä¸ªç»„ä»¶çš„é—®é¢˜æ³¢åŠæ•´ä¸ªç³»ç»Ÿã€‚

**ğŸ›¡ï¸ éš”ç¦»ç­–ç•¥åˆ†ç±»**

```
ç‰©ç†éš”ç¦»ï¼š
â”œâ”€â”€ è¿›ç¨‹éš”ç¦»ï¼šä¸åŒç»„ä»¶è¿è¡Œåœ¨ç‹¬ç«‹è¿›ç¨‹
â”œâ”€â”€ çº¿ç¨‹éš”ç¦»ï¼šä½¿ç”¨çº¿ç¨‹æ± é™åˆ¶èµ„æºä½¿ç”¨
â”œâ”€â”€ å†…å­˜éš”ç¦»ï¼šç‹¬ç«‹å†…å­˜ç©ºé—´ï¼Œé˜²æ­¢å†…å­˜æ³„éœ²
â””â”€â”€ ç½‘ç»œéš”ç¦»ï¼šç‹¬ç«‹ç½‘ç»œè¿æ¥ï¼Œé¿å…è¿æ¥è€—å°½

é€»è¾‘éš”ç¦»ï¼š
â”œâ”€â”€ èµ„æºé™åˆ¶ï¼šCPUã€å†…å­˜ã€IOä½¿ç”¨é™åˆ¶
â”œâ”€â”€ è¶…æ—¶æ§åˆ¶ï¼šæ“ä½œè¶…æ—¶è‡ªåŠ¨ä¸­æ–­
â”œâ”€â”€ é‡è¯•æœºåˆ¶ï¼šå¤±è´¥åæœ‰é™æ¬¡æ•°é‡è¯•
â””â”€â”€ ç†”æ–­å™¨ï¼šè¿ç»­å¤±è´¥åæš‚åœæœåŠ¡

æ•…éšœè½¬ç§»ï¼š
â”œâ”€â”€ ä¸»å¤‡åˆ‡æ¢ï¼šä¸»ç»„ä»¶æ•…éšœæ—¶åˆ‡æ¢åˆ°å¤‡ç”¨
â”œâ”€â”€ è´Ÿè½½å‡è¡¡ï¼šå°†è¯·æ±‚åˆ†å‘åˆ°å¥åº·ç»„ä»¶
â”œâ”€â”€ é™çº§æœåŠ¡ï¼šæä¾›åŸºç¡€åŠŸèƒ½ï¼Œå…³é—­é«˜çº§åŠŸèƒ½
â””â”€â”€ å›æ»šæœºåˆ¶ï¼šé—®é¢˜ç‰ˆæœ¬å›æ»šåˆ°ç¨³å®šç‰ˆæœ¬
```

### 7.2 ç†”æ–­å™¨æœºåˆ¶


**ğŸ”Œ ç†”æ–­å™¨çŠ¶æ€æœº**

```
ç†”æ–­å™¨çŠ¶æ€è½¬æ¢ï¼š

    [å…³é—­çŠ¶æ€] â”€â”€å¤±è´¥ç‡è¶…è¿‡é˜ˆå€¼â”€â”€â†’ [æ‰“å¼€çŠ¶æ€]
         â†‘                            â”‚
         â”‚                            â”‚è¶…æ—¶å
         â”‚                            â†“
    [åŠæ‰“å¼€çŠ¶æ€] â†â”€â”€æµ‹è¯•è¯·æ±‚æˆåŠŸâ”€â”€ [åŠæ‰“å¼€çŠ¶æ€]
         â”‚
         â”‚æµ‹è¯•è¯·æ±‚å¤±è´¥
         â†“
    [æ‰“å¼€çŠ¶æ€]

çŠ¶æ€è¯´æ˜ï¼š
â€¢ å…³é—­çŠ¶æ€ï¼šæ­£å¸¸å¤„ç†è¯·æ±‚ï¼Œç»Ÿè®¡æˆåŠŸ/å¤±è´¥ç‡
â€¢ æ‰“å¼€çŠ¶æ€ï¼šç›´æ¥æ‹’ç»è¯·æ±‚ï¼Œå¿«é€Ÿå¤±è´¥
â€¢ åŠæ‰“å¼€çŠ¶æ€ï¼šå…è®¸å°‘é‡è¯·æ±‚æµ‹è¯•æœåŠ¡æ¢å¤æƒ…å†µ
```

**ç†”æ–­å™¨å®ç°**

```cpp
class CircuitBreaker {
private:
    enum State {
        CLOSED,     // å…³é—­çŠ¶æ€
        OPEN,       // æ‰“å¼€çŠ¶æ€
        HALF_OPEN   // åŠæ‰“å¼€çŠ¶æ€
    };
    
    State current_state_;
    int failure_count_;
    int success_count_;
    int failure_threshold_;
    std::chrono::seconds timeout_;
    std::chrono::steady_clock::time_point last_failure_time_;
    
public:
    template<typename Func>
    auto call(Func&& func) -> decltype(func()) {
        if (current_state_ == OPEN) {
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥è¿›å…¥åŠæ‰“å¼€çŠ¶æ€
            if (should_attempt_reset()) {
                current_state_ = HALF_OPEN;
            } else {
                throw CircuitBreakerOpenException();
            }
        }
        
        try {
            auto result = func();  // æ‰§è¡Œå®é™…æ“ä½œ
            on_success();
            return result;
        } catch (...) {
            on_failure();
            throw;
        }
    }
    
private:
    void on_success() {
        if (current_state_ == HALF_OPEN) {
            current_state_ = CLOSED;
            failure_count_ = 0;
        }
        success_count_++;
    }
    
    void on_failure() {
        failure_count_++;
        last_failure_time_ = std::chrono::steady_clock::now();
        
        if (failure_count_ >= failure_threshold_) {
            current_state_ = OPEN;
        }
    }
    
    bool should_attempt_reset() {
        auto now = std::chrono::steady_clock::now();
        return (now - last_failure_time_) > timeout_;
    }
};
```

### 7.3 èµ„æºéš”ç¦»ç­–ç•¥


**ğŸ’¾ èµ„æºä½¿ç”¨é™åˆ¶**

| èµ„æºç±»å‹ | **é™åˆ¶æ–¹å¼** | **ç›‘æ§æŒ‡æ ‡** | **è¶…é™å¤„ç†** |
|---------|-------------|-------------|-------------|
| ğŸ§  **CPU** | `cgroupé™åˆ¶` | `CPUä½¿ç”¨ç‡` | `é™ä½ä¼˜å…ˆçº§` |
| ğŸ’¾ **å†…å­˜** | `å†…å­˜é…é¢` | `å†…å­˜ä½¿ç”¨é‡` | `æ‹’ç»æ–°è¯·æ±‚` |
| ğŸ’½ **ç£ç›˜IO** | `IOé…é¢` | `IOPSã€å¸¦å®½` | `é™åˆ¶IOé€Ÿåº¦` |
| ğŸŒ **ç½‘ç»œ** | `è¿æ¥æ•°é™åˆ¶` | `è¿æ¥æ•°ã€å¸¦å®½` | `æ‹’ç»æ–°è¿æ¥` |

```cpp
// èµ„æºç›‘æ§å’Œé™åˆ¶
class ResourceManager {
private:
    struct ResourceLimits {
        size_t max_memory_mb;      // æœ€å¤§å†…å­˜ä½¿ç”¨(MB)
        double max_cpu_percent;    // æœ€å¤§CPUä½¿ç”¨ç‡
        int max_connections;       // æœ€å¤§è¿æ¥æ•°
        size_t max_io_bandwidth;   // æœ€å¤§IOå¸¦å®½
    };
    
    ResourceLimits limits_;
    std::atomic<size_t> current_memory_;
    std::atomic<int> current_connections_;
    
public:
    bool check_and_allocate_memory(size_t size) {
        size_t new_usage = current_memory_ + size;
        if (new_usage > limits_.max_memory_mb * 1024 * 1024) {
            log_warning("Memory limit exceeded");
            return false;  // æ‹’ç»åˆ†é…
        }
        
        current_memory_ = new_usage;
        return true;
    }
    
    bool check_and_create_connection() {
        int new_count = current_connections_ + 1;
        if (new_count > limits_.max_connections) {
            log_warning("Connection limit exceeded");
            return false;  // æ‹’ç»è¿æ¥
        }
        
        current_connections_ = new_count;
        return true;
    }
};
```

---

## 8. ğŸ”¥ ç»„ä»¶æ€§èƒ½ç›‘æ§æ¥å£


### 8.1 ç›‘æ§æŒ‡æ ‡ä½“ç³»


æ€§èƒ½ç›‘æ§å°±åƒæ±½è½¦çš„ä»ªè¡¨ç›˜ï¼Œè®©ä½ éšæ—¶äº†è§£ç³»ç»Ÿè¿è¡ŒçŠ¶å†µã€‚

**ğŸ“Š ç›‘æ§æŒ‡æ ‡åˆ†ç±»**

```
ç³»ç»Ÿçº§æŒ‡æ ‡ï¼š
â”œâ”€â”€ CPUä½¿ç”¨ç‡ (%)
â”œâ”€â”€ å†…å­˜ä½¿ç”¨ç‡ (%)
â”œâ”€â”€ ç£ç›˜IO (IOPS, MB/s)
â”œâ”€â”€ ç½‘ç»œIO (packets/s, MB/s)
â””â”€â”€ ç³»ç»Ÿè´Ÿè½½ (Load Average)

ç»„ä»¶çº§æŒ‡æ ‡ï¼š
â”œâ”€â”€ ç»„ä»¶çŠ¶æ€ (è¿è¡Œ/åœæ­¢/å¼‚å¸¸)
â”œâ”€â”€ å¤„ç†è¯·æ±‚æ•° (QPS)
â”œâ”€â”€ å¹³å‡å“åº”æ—¶é—´ (ms)
â”œâ”€â”€ é”™è¯¯ç‡ (%)
â””â”€â”€ èµ„æºä½¿ç”¨æƒ…å†µ

ä¸šåŠ¡çº§æŒ‡æ ‡ï¼š
â”œâ”€â”€ SQLæ‰§è¡Œæ¬¡æ•°
â”œâ”€â”€ äº‹åŠ¡æäº¤/å›æ»šæ•°
â”œâ”€â”€ æ…¢æŸ¥è¯¢æ•°é‡
â”œâ”€â”€ é”ç­‰å¾…æ—¶é—´
â””â”€â”€ ç¼“å­˜å‘½ä¸­ç‡
```

### 8.2 ç›‘æ§æ¥å£è®¾è®¡


**ğŸ” æ ‡å‡†ç›‘æ§æ¥å£**

```cpp
// ç›‘æ§æ•°æ®ç»“æ„
struct MetricValue {
    std::string name;           // æŒ‡æ ‡åç§°
    double value;              // æŒ‡æ ‡å€¼
    std::string unit;          // å•ä½
    time_t timestamp;          // æ—¶é—´æˆ³
    std::map<std::string, std::string> labels; // æ ‡ç­¾
};

// ç›‘æ§æ¥å£
class MonitoringInterface {
public:
    // è·å–æ‰€æœ‰æŒ‡æ ‡
    virtual std::vector<MetricValue> get_all_metrics() = 0;
    
    // è·å–æŒ‡å®šæŒ‡æ ‡
    virtual MetricValue get_metric(const std::string& name) = 0;
    
    // è·å–æŒ‡æ ‡å†å²æ•°æ®
    virtual std::vector<MetricValue> get_metric_history(
        const std::string& name,
        time_t start_time,
        time_t end_time
    ) = 0;
    
    // è®¾ç½®å‘Šè­¦é˜ˆå€¼
    virtual bool set_alert_threshold(
        const std::string& metric_name,
        double threshold,
        ComparisonOperator op
    ) = 0;
    
    // æ³¨å†Œç›‘æ§å›è°ƒ
    virtual bool register_metric_callback(
        const std::string& metric_name,
        std::function<void(const MetricValue&)> callback
    ) = 0;
};
```

### 8.3 æ€§èƒ½æ•°æ®æ”¶é›†


**ğŸ“ˆ æ•°æ®æ”¶é›†ç­–ç•¥**

```cpp
class MetricsCollector {
private:
    std::unordered_map<std::string, MetricValue> metrics_;
    std::mutex metrics_mutex_;
    std::chrono::seconds collection_interval_;
    
public:
    // æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
    void collect_system_metrics() {
        // CPUä½¿ç”¨ç‡
        double cpu_usage = get_cpu_usage();
        update_metric("system.cpu.usage", cpu_usage, "%");
        
        // å†…å­˜ä½¿ç”¨ç‡
        auto memory_info = get_memory_info();
        update_metric("system.memory.usage", 
                     memory_info.used_percent, "%");
        update_metric("system.memory.available", 
                     memory_info.available_mb, "MB");
        
        // ç£ç›˜IO
        auto disk_stats = get_disk_stats();
        update_metric("system.disk.read_iops", disk_stats.read_iops, "ops/s");
        update_metric("system.disk.write_iops", disk_stats.write_iops, "ops/s");
    }
    
    // æ”¶é›†ç»„ä»¶æŒ‡æ ‡
    void collect_component_metrics(const std::string& component_id) {
        auto component = get_component(component_id);
        if (!component) return;
        
        // QPSç»Ÿè®¡
        double qps = component->get_queries_per_second();
        update_metric(component_id + ".qps", qps, "queries/s");
        
        // å“åº”æ—¶é—´
        double avg_response_time = component->get_avg_response_time();
        update_metric(component_id + ".response_time", 
                     avg_response_time, "ms");
        
        // é”™è¯¯ç‡
        double error_rate = component->get_error_rate();
        update_metric(component_id + ".error_rate", error_rate, "%");
    }
    
private:
    void update_metric(const std::string& name, double value, 
                      const std::string& unit) {
        std::lock_guard<std::mutex> lock(metrics_mutex_);
        
        MetricValue& metric = metrics_[name];
        metric.name = name;
        metric.value = value;
        metric.unit = unit;
        metric.timestamp = time(nullptr);
    }
};
```

### 8.4 ç›‘æ§å‘Šè­¦æœºåˆ¶


**ğŸš¨ å‘Šè­¦è§„åˆ™é…ç½®**

```
å‘Šè­¦çº§åˆ«åˆ†ç±»ï¼š

ğŸŸ¢ INFO (ä¿¡æ¯)ï¼š
   â”œâ”€â”€ ç³»ç»Ÿå¯åŠ¨/åœæ­¢
   â”œâ”€â”€ é…ç½®å˜æ›´
   â””â”€â”€ æ­£å¸¸çš„è¿ç»´æ“ä½œ

ğŸŸ¡ WARNING (è­¦å‘Š)ï¼š
   â”œâ”€â”€ CPUä½¿ç”¨ç‡ > 70%
   â”œâ”€â”€ å†…å­˜ä½¿ç”¨ç‡ > 80%
   â”œâ”€â”€ æ…¢æŸ¥è¯¢æ•°é‡å¢åŠ 
   â””â”€â”€ è¿æ¥æ•°æ¥è¿‘é™åˆ¶

ğŸŸ  ERROR (é”™è¯¯)ï¼š
   â”œâ”€â”€ ç»„ä»¶å¯åŠ¨å¤±è´¥
   â”œâ”€â”€ æ•°æ®åº“è¿æ¥å¤±è´¥
   â”œâ”€â”€ ç£ç›˜ç©ºé—´ä¸è¶³
   â””â”€â”€ ä¸»ä»åŒæ­¥å»¶è¿Ÿ

ğŸ”´ CRITICAL (ä¸¥é‡)ï¼š
   â”œâ”€â”€ æœåŠ¡å®Œå…¨ä¸å¯ç”¨
   â”œâ”€â”€ æ•°æ®ä¸¢å¤±é£é™©
   â”œâ”€â”€ å®‰å…¨æ¼æ´
   â””â”€â”€ ç³»ç»Ÿå´©æºƒ
```

**å‘Šè­¦å¤„ç†æµç¨‹**

```cpp
class AlertManager {
public:
    struct AlertRule {
        std::string metric_name;     // ç›‘æ§æŒ‡æ ‡
        ComparisonOperator operator; // æ¯”è¾ƒæ“ä½œç¬¦
        double threshold;           // é˜ˆå€¼
        int duration_seconds;       // æŒç»­æ—¶é—´
        AlertLevel level;          // å‘Šè­¦çº§åˆ«
        std::vector<std::string> recipients; // æ¥æ”¶è€…
    };
    
    void check_alerts() {
        for (const auto& rule : alert_rules_) {
            auto metric = metrics_collector_->get_metric(rule.metric_name);
            
            if (evaluate_condition(metric, rule)) {
                // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨å‘Šè­¦ä¸­
                if (!is_alerting(rule.metric_name)) {
                    trigger_alert(rule, metric);
                }
            } else {
                // æ¡ä»¶ä¸æ»¡è¶³ï¼Œæ¸…é™¤å‘Šè­¦
                clear_alert(rule.metric_name);
            }
        }
    }
    
private:
    void trigger_alert(const AlertRule& rule, const MetricValue& metric) {
        Alert alert;
        alert.rule_name = rule.metric_name;
        alert.level = rule.level;
        alert.message = format_alert_message(rule, metric);
        alert.timestamp = time(nullptr);
        
        // å‘é€å‘Šè­¦é€šçŸ¥
        send_alert_notification(alert, rule.recipients);
        
        // è®°å½•å‘Šè­¦å†å²
        alert_history_.push_back(alert);
    }
};
```

---

## 9. ğŸ”¥ ç»„ä»¶é…ç½®çƒ­æ›´æ–°


### 9.1 çƒ­æ›´æ–°æœºåˆ¶åŸç†


é…ç½®çƒ­æ›´æ–°å°±åƒç»™è¿è¡Œä¸­çš„æ±½è½¦æ¢é›¶ä»¶ï¼Œåœ¨ä¸åœæ­¢æœåŠ¡çš„æƒ…å†µä¸‹æ›´æ–°é…ç½®ã€‚

**ğŸ”„ çƒ­æ›´æ–°æµç¨‹è®¾è®¡**

```
é…ç½®çƒ­æ›´æ–°æµç¨‹ï¼š

æ­¥éª¤ 1ï¸âƒ£ é…ç½®å˜æ›´æ£€æµ‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é…ç½®æ–‡ä»¶ç›‘æ§     â”‚ â”€â”€â†’ æ–‡ä»¶ç³»ç»Ÿäº‹ä»¶
â”‚ ç®¡ç†ç•Œé¢æ›´æ–°     â”‚ â”€â”€â†’ APIæ¥å£è°ƒç”¨  
â”‚ è¿œç¨‹é…ç½®ä¸­å¿ƒ     â”‚ â”€â”€â†’ é…ç½®æ¨é€
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ 2ï¸âƒ£ é…ç½®æ ¡éªŒ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è¯­æ³•æ ¡éªŒ        â”‚ â”€â”€â†’ æ£€æŸ¥é…ç½®æ ¼å¼
â”‚ é€»è¾‘æ ¡éªŒ        â”‚ â”€â”€â†’ æ£€æŸ¥å‚æ•°åˆç†æ€§
â”‚ ä¾èµ–æ ¡éªŒ        â”‚ â”€â”€â†’ æ£€æŸ¥ç»„ä»¶ä¾èµ–
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ 3ï¸âƒ£ é…ç½®åº”ç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¢é‡æ›´æ–°        â”‚ â”€â”€â†’ åªæ›´æ–°å˜åŒ–éƒ¨åˆ†
â”‚ åŸå­æ“ä½œ        â”‚ â”€â”€â†’ è¦ä¹ˆå…¨éƒ¨æˆåŠŸè¦ä¹ˆå›æ»š
â”‚ ç‰ˆæœ¬ç®¡ç†        â”‚ â”€â”€â†’ æ”¯æŒé…ç½®ç‰ˆæœ¬æ§åˆ¶
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ 4ï¸âƒ£ çŠ¶æ€åŒæ­¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é€šçŸ¥ç›¸å…³ç»„ä»¶     â”‚ â”€â”€â†’ é…ç½®å˜æ›´äº‹ä»¶
â”‚ æ›´æ–°é…ç½®ç¼“å­˜     â”‚ â”€â”€â†’ å†…å­˜é…ç½®æ›´æ–°
â”‚ è®°å½•å˜æ›´å†å²     â”‚ â”€â”€â†’ å®¡è®¡æ—¥å¿—
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9.2 é…ç½®ç®¡ç†æ¶æ„


**ğŸ”§ é…ç½®ç®¡ç†å™¨è®¾è®¡**

```cpp
class ConfigurationManager {
public:
    struct ConfigItem {
        std::string key;            // é…ç½®é”®
        std::string value;          // é…ç½®å€¼
        std::string type;          // æ•°æ®ç±»å‹
        bool hot_reloadable;       // æ˜¯å¦æ”¯æŒçƒ­æ›´æ–°
        std::string description;    // é…ç½®è¯´æ˜
        std::vector<std::string> validators; // éªŒè¯è§„åˆ™
    };
    
    struct ConfigSection {
        std::string section_name;
        std::map<std::string, ConfigItem> items;
        bool requires_restart;     // æ˜¯å¦éœ€è¦é‡å¯
    };
    
private:
    std::map<std::string, ConfigSection> config_sections_;
    std::vector<std::function<void(const std::string&, const std::string&)>> 
        change_listeners_;
    std::mutex config_mutex_;
    
public:
    // æ³¨å†Œé…ç½®å˜æ›´ç›‘å¬å™¨
    void register_change_listener(
        std::function<void(const std::string&, const std::string&)> listener
    ) {
        change_listeners_.push_back(listener);
    }
    
    // æ›´æ–°é…ç½®é¡¹
    bool update_config(const std::string& key, const std::string& value) {
        std::lock_guard<std::mutex> lock(config_mutex_);
        
        // 1. æŸ¥æ‰¾é…ç½®é¡¹
        auto item = find_config_item(key);
        if (!item) {
            log_error("Config key not found: " + key);
            return false;
        }
        
        // 2. éªŒè¯é…ç½®å€¼
        if (!validate_config_value(*item, value)) {
            log_error("Invalid config value for " + key + ": " + value);
            return false;
        }
        
        // 3. æ£€æŸ¥æ˜¯å¦æ”¯æŒçƒ­æ›´æ–°
        if (!item->hot_reloadable) {
            log_warning("Config " + key + " requires restart");
            // æ ‡è®°éœ€è¦é‡å¯
            mark_restart_required(key);
        }
        
        // 4. æ›´æ–°é…ç½®
        std::string old_value = item->value;
        item->value = value;
        
        // 5. é€šçŸ¥ç›‘å¬å™¨
        notify_config_change(key, old_value, value);
        
        return true;
    }
    
private:
    void notify_config_change(const std::string& key, 
                             const std::string& old_value,
                             const std::string& new_value) {
        for (auto& listener : change_listeners_) {
            try {
                listener(key, new_value);
            } catch (const std::exception& e) {
                log_error("Config change listener failed: " + 
                         std::string(e.what()));
            }
        }
    }
};
```

### 9.3 é…ç½®çƒ­æ›´æ–°ç­–ç•¥


**ğŸ”¸ ä¸åŒç±»å‹é…ç½®çš„æ›´æ–°ç­–ç•¥**

| é…ç½®ç±»å‹ | **æ›´æ–°æ–¹å¼** | **ç”Ÿæ•ˆæ—¶é—´** | **å½±å“èŒƒå›´** |
|---------|-------------|-------------|-------------|
| ğŸ”¢ **æ€§èƒ½å‚æ•°** | `ç«‹å³ç”Ÿæ•ˆ` | `æ¯«ç§’çº§` | `å½“å‰ç»„ä»¶` |
| ğŸ“ **æ—¥å¿—é…ç½®** | `ç«‹å³ç”Ÿæ•ˆ` | `ç§’çº§` | `æ—¥å¿—ç³»ç»Ÿ` |
| ğŸŒ **ç½‘ç»œé…ç½®** | `é‡æ–°ç»‘å®š` | `åˆ†é’Ÿçº§` | `ç½‘ç»œå±‚` |
| ğŸ’¾ **å­˜å‚¨é…ç½®** | `é€æ­¥è¿ç§»` | `å°æ—¶çº§` | `å­˜å‚¨å¼•æ“` |
| ğŸ”’ **å®‰å…¨é…ç½®** | `éœ€è¦é‡å¯` | `é‡å¯å` | `å…¨ç³»ç»Ÿ` |

**é…ç½®æ›´æ–°å®ä¾‹**

```cpp
// MySQLé…ç½®çƒ­æ›´æ–°ç¤ºä¾‹
class MySQLConfigHandler {
public:
    void handle_config_change(const std::string& key, const std::string& value) {
        if (key == "max_connections") {
            // è¿æ¥æ•°é™åˆ¶å¯ä»¥çƒ­æ›´æ–°
            int new_max_connections = std::stoi(value);
            connection_manager_.set_max_connections(new_max_connections);
            log_info("Updated max_connections to " + value);
            
        } else if (key == "innodb_buffer_pool_size") {
            // Buffer Poolå¤§å°éœ€è¦é‡å¯æ‰èƒ½ç”Ÿæ•ˆ
            log_warning("innodb_buffer_pool_size change requires restart");
            mark_restart_required();
            
        } else if (key == "slow_query_log") {
            // æ…¢æŸ¥è¯¢æ—¥å¿—å¼€å…³å¯ä»¥çƒ­æ›´æ–°
            bool enable_slow_log = (value == "ON" || value == "1");
            query_logger_.set_slow_log_enabled(enable_slow_log);
            log_info("Updated slow_query_log to " + value);
            
        } else if (key == "log_level") {
            // æ—¥å¿—çº§åˆ«å¯ä»¥çƒ­æ›´æ–°
            LogLevel level = parse_log_level(value);
            logger_.set_log_level(level);
            log_info("Updated log_level to " + value);
        }
    }
    
private:
    ConnectionManager& connection_manager_;
    QueryLogger& query_logger_;
    Logger& logger_;
};
```

---

## 10. ğŸ”¥ ç»„ä»¶ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†


### 10.1 ç‰ˆæœ¬ç®¡ç†ç­–ç•¥


ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†å°±åƒè½¯ä»¶çš„"å‘åå…¼å®¹"ï¼Œç¡®ä¿æ–°ç‰ˆæœ¬ä¸ä¼šç ´åç°æœ‰åŠŸèƒ½ã€‚

**ğŸ”¸ ç‰ˆæœ¬å·è§„åˆ™**

```
è¯­ä¹‰åŒ–ç‰ˆæœ¬å· (Semantic Versioning)ï¼š

æ ¼å¼ï¼šä¸»ç‰ˆæœ¬å·.æ¬¡ç‰ˆæœ¬å·.ä¿®è®¢å·
ç¤ºä¾‹ï¼š8.0.33

ä¸»ç‰ˆæœ¬å· (Major)ï¼š
â”œâ”€â”€ ä¸å…¼å®¹çš„APIä¿®æ”¹
â”œâ”€â”€ æ¶æ„é‡å¤§å˜æ›´
â”œâ”€â”€ æ•°æ®æ ¼å¼å˜åŒ–
â””â”€â”€ é…ç½®æ–‡ä»¶æ ¼å¼å˜æ›´

æ¬¡ç‰ˆæœ¬å· (Minor)ï¼š
â”œâ”€â”€ å‘åå…¼å®¹çš„åŠŸèƒ½æ€§æ–°å¢
â”œâ”€â”€ æ–°å¢å¯é€‰é…ç½®é¡¹
â”œâ”€â”€ æ€§èƒ½ä¼˜åŒ–æ”¹è¿›
â””â”€â”€ æ–°å¢å­˜å‚¨å¼•æ“

ä¿®è®¢å· (Patch)ï¼š
â”œâ”€â”€ å‘åå…¼å®¹çš„é—®é¢˜ä¿®æ­£
â”œâ”€â”€ å®‰å…¨æ¼æ´ä¿®å¤
â”œâ”€â”€ Bugä¿®å¤
â””â”€â”€ å°å¹…æ€§èƒ½æå‡
```

### 10.2 å…¼å®¹æ€§æ£€æŸ¥æœºåˆ¶


**ğŸ” å…¼å®¹æ€§æ£€æŸ¥æ¡†æ¶**

```cpp
class CompatibilityChecker {
public:
    struct VersionInfo {
        int major;
        int minor;
        int patch;
        std::string build_info;
        
        std::string to_string() const {
            return std::to_string(major) + "." + 
                   std::to_string(minor) + "." + 
                   std::to_string(patch);
        }
        
        bool operator>=(const VersionInfo& other) const {
            if (major != other.major) return major > other.major;
            if (minor != other.minor) return minor > other.minor;
            return patch >= other.patch;
        }
    };
    
    struct CompatibilityRule {
        std::string component_name;     // ç»„ä»¶åç§°
        VersionInfo min_version;        // æœ€å°ç‰ˆæœ¬è¦æ±‚
        VersionInfo max_version;        // æœ€å¤§ç‰ˆæœ¬è¦æ±‚
        std::vector<VersionInfo> incompatible_versions; // ä¸å…¼å®¹ç‰ˆæœ¬
        std::string reason;            // å…¼å®¹æ€§è¯´æ˜
    };
    
    // æ£€æŸ¥ç»„ä»¶å…¼å®¹æ€§
    bool check_compatibility(const std::string& component_name,
                           const VersionInfo& version) {
        auto rules = get_compatibility_rules(component_name);
        
        for (const auto& rule : rules) {
            // æ£€æŸ¥ç‰ˆæœ¬èŒƒå›´
            if (version < rule.min_version || version > rule.max_version) {
                log_compatibility_error(component_name, version, rule);
                return false;
            }
            
            // æ£€æŸ¥é»‘åå•ç‰ˆæœ¬
            for (const auto& incompatible : rule.incompatible_versions) {
                if (version.major == incompatible.major &&
                    version.minor == incompatible.minor &&
                    version.patch == incompatible.patch) {
                    log_compatibility_error(component_name, version, rule);
                    return false;
                }
            }
        }
        
        return true;
    }
    
private:
    std::map<std::string, std::vector<CompatibilityRule>> compatibility_rules_;
};
```

### 10.3 APIç‰ˆæœ¬ç®¡ç†


**ğŸ”Œ æ¥å£ç‰ˆæœ¬åŒ–ç­–ç•¥**

```cpp
// APIç‰ˆæœ¬åŒ–æ¥å£è®¾è®¡
class VersionedAPI {
public:
    // APIç‰ˆæœ¬æšä¸¾
    enum class APIVersion {
        V1_0 = 100,   // ç‰ˆæœ¬ 1.0
        V1_1 = 101,   // ç‰ˆæœ¬ 1.1  
        V2_0 = 200,   // ç‰ˆæœ¬ 2.0
        CURRENT = V2_0
    };
    
    // ç‰ˆæœ¬åŒ–çš„å­˜å‚¨å¼•æ“æ¥å£
    class StorageEngineAPI {
    public:
        virtual ~StorageEngineAPI() = default;
        virtual APIVersion get_api_version() const = 0;
        
        // V1.0 æ¥å£
        virtual int read_row_v1(uchar* buf) = 0;
        virtual int write_row_v1(const uchar* buf) = 0;
        
        // V1.1 æ¥å£ (å¢åŠ äº†äº‹åŠ¡æ”¯æŒ)
        virtual int read_row_v1_1(uchar* buf, transaction_id_t txn_id) {
            // é»˜è®¤å®ç°ï¼Œå‘åå…¼å®¹
            return read_row_v1(buf);
        }
        
        // V2.0 æ¥å£ (é‡æ–°è®¾è®¡ï¼Œæ”¯æŒå¼‚æ­¥æ“ä½œ)
        virtual std::future<int> read_row_async(uchar* buf, 
                                               const ReadOptions& options) {
            // æä¾›åŒæ­¥åˆ°å¼‚æ­¥çš„é€‚é…
            std::promise<int> promise;
            auto future = promise.get_future();
            
            int result = read_row_v1(buf);
            promise.set_value(result);
            
            return future;
        }
    };
};

// ç‰ˆæœ¬é€‚é…å™¨
class APIAdapter {
public:
    // V1æ¥å£é€‚é…åˆ°V2
    class V1toV2Adapter : public VersionedAPI::StorageEngineAPI {
    private:
        std::unique_ptr<LegacyStorageEngine> legacy_engine_;
        
    public:
        APIVersion get_api_version() const override {
            return APIVersion::V2_0;
        }
        
        std::future<int> read_row_async(uchar* buf, 
                                       const ReadOptions& options) override {
            // å°†å¼‚æ­¥æ¥å£é€‚é…åˆ°åŒæ­¥å®ç°
            return std::async(std::launch::async, [this, buf]() {
                return legacy_engine_->read_row(buf);
            });
        }
    };
};
```

### 10.4 å‡çº§å…¼å®¹æ€§ä¿éšœ


**ğŸ“ˆ ç»„ä»¶å‡çº§ç­–ç•¥**

```
æ¸è¿›å¼å‡çº§æµç¨‹ï¼š

é˜¶æ®µ 1ï¸âƒ£ å…¼å®¹æ€§æ£€æŸ¥
â”œâ”€â”€ æ£€æŸ¥ä¾èµ–ç»„ä»¶ç‰ˆæœ¬
â”œâ”€â”€ éªŒè¯é…ç½®æ–‡ä»¶å…¼å®¹æ€§  
â”œâ”€â”€ æ£€æŸ¥æ•°æ®æ ¼å¼å…¼å®¹æ€§
â””â”€â”€ ç”Ÿæˆå‡çº§å¯è¡Œæ€§æŠ¥å‘Š

é˜¶æ®µ 2ï¸âƒ£ ç°åº¦å‡çº§
â”œâ”€â”€ é€‰æ‹©éƒ¨åˆ†å®ä¾‹å‡çº§
â”œâ”€â”€ ç›‘æ§å‡çº§åæ€§èƒ½æŒ‡æ ‡
â”œâ”€â”€ éªŒè¯åŠŸèƒ½å®Œæ•´æ€§
â””â”€â”€ æ”¶é›†ç”¨æˆ·åé¦ˆ

é˜¶æ®µ 3ï¸âƒ£ å…¨é‡å‡çº§
â”œâ”€â”€ é€æ­¥æ‰©å¤§å‡çº§èŒƒå›´
â”œâ”€â”€ å®æ—¶ç›‘æ§ç³»ç»Ÿç¨³å®šæ€§
â”œâ”€â”€ ä¿æŒå›æ»šèƒ½åŠ›
â””â”€â”€ å®Œæˆå‡çº§éªŒè¯

é˜¶æ®µ 4ï¸âƒ£ æ¸…ç†å·¥ä½œ
â”œâ”€â”€ æ¸…ç†æ—§ç‰ˆæœ¬æ•°æ®
â”œâ”€â”€ æ›´æ–°ç›‘æ§é…ç½®
â”œâ”€â”€ æ›´æ–°æ–‡æ¡£å’Œå·¥å…·
â””â”€â”€ åŸ¹è®­è¿ç»´äººå‘˜
```

**æ•°æ®æ ¼å¼å…¼å®¹æ€§å¤„ç†**

```cpp
class DataFormatMigrator {
public:
    struct MigrationRule {
        VersionInfo from_version;
        VersionInfo to_version;
        std::function<bool(const DataRecord&, DataRecord&)> migrate_func;
        bool reversible;  // æ˜¯å¦å¯é€†
    };
    
    // æ‰§è¡Œæ•°æ®è¿ç§»
    bool migrate_data(const VersionInfo& from_version,
                     const VersionInfo& to_version,
                     DataIterator& data) {
        // æŸ¥æ‰¾è¿ç§»è·¯å¾„
        auto migration_path = find_migration_path(from_version, to_version);
        if (migration_path.empty()) {
            log_error("No migration path found");
            return false;
        }
        
        // æ‰§è¡Œé€æ­¥è¿ç§»
        for (const auto& rule : migration_path) {
            if (!apply_migration_rule(rule, data)) {
                // è¿ç§»å¤±è´¥ï¼Œå°è¯•å›æ»š
                rollback_migration(rule, data);
                return false;
            }
        }
        
        return true;
    }
    
private:
    std::vector<MigrationRule> migration_rules_;
    
    std::vector<MigrationRule> find_migration_path(
        const VersionInfo& from, const VersionInfo& to) {
        // ä½¿ç”¨å›¾ç®—æ³•æ‰¾åˆ°æœ€çŸ­è¿ç§»è·¯å¾„
        // è¿™é‡Œç®€åŒ–å®ç°
        std::vector<MigrationRule> path;
        // ... è·¯å¾„æŸ¥æ‰¾é€»è¾‘
        return path;
    }
};
```

---

## 11. ğŸ”‘ æ‰©å±•æ€§è®¾è®¡åŸåˆ™


### 11.1 å¯æ‰©å±•æ¶æ„è®¾è®¡


å¯æ‰©å±•æ€§è®¾è®¡å°±åƒæ­ç§¯æœ¨ï¼Œè¦è®©ç³»ç»Ÿèƒ½å¤Ÿæ–¹ä¾¿åœ°æ·»åŠ æ–°åŠŸèƒ½è€Œä¸ç ´åç°æœ‰ç»“æ„ã€‚

**ğŸ¯ æ‰©å±•æ€§è®¾è®¡åŸåˆ™**

```
å¼€æ”¾å°é—­åŸåˆ™ (Open-Closed Principle)ï¼š
â”œâ”€â”€ å¯¹æ‰©å±•å¼€æ”¾ï¼šå¯ä»¥å¢åŠ æ–°åŠŸèƒ½
â”œâ”€â”€ å¯¹ä¿®æ”¹å°é—­ï¼šä¸ä¿®æ”¹ç°æœ‰ä»£ç 
â”œâ”€â”€ å®ç°æ–¹å¼ï¼šæ¥å£æŠ½è±¡ã€æ’ä»¶æœºåˆ¶
â””â”€â”€ å¥½å¤„ï¼šé™ä½é£é™©ï¼Œæé«˜ç¨³å®šæ€§

å•ä¸€èŒè´£åŸåˆ™ (Single Responsibility Principle)ï¼š
â”œâ”€â”€ æ¯ä¸ªç»„ä»¶åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½
â”œâ”€â”€ åŠŸèƒ½å˜åŒ–åªå½±å“ç›¸å…³ç»„ä»¶
â”œâ”€â”€ å®ç°æ–¹å¼ï¼šæ¨¡å—åŒ–è®¾è®¡ã€èŒè´£åˆ†ç¦»
â””â”€â”€ å¥½å¤„ï¼šæ˜“äºç†è§£ã€æµ‹è¯•ã€ç»´æŠ¤

ä¾èµ–å€’ç½®åŸåˆ™ (Dependency Inversion Principle)ï¼š
â”œâ”€â”€ é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—
â”œâ”€â”€ éƒ½ä¾èµ–äºæŠ½è±¡æ¥å£
â”œâ”€â”€ å®ç°æ–¹å¼ï¼šæ¥å£ç¼–ç¨‹ã€ä¾èµ–æ³¨å…¥
â””â”€â”€ å¥½å¤„ï¼šæ¾è€¦åˆã€å¯æ›¿æ¢
```

### 11.2 æ’ä»¶åŒ–æ¶æ„


**ğŸ”Œ æ’ä»¶ç³»ç»Ÿè®¾è®¡**

```cpp
// æ’ä»¶æ¥å£å®šä¹‰
class Plugin {
public:
    virtual ~Plugin() = default;
    
    // æ’ä»¶ä¿¡æ¯
    virtual std::string get_name() const = 0;
    virtual std::string get_version() const = 0;
    virtual std::string get_description() const = 0;
    
    // æ’ä»¶ç”Ÿå‘½å‘¨æœŸ
    virtual bool initialize(const PluginConfig& config) = 0;
    virtual bool start() = 0;
    virtual bool stop() = 0;
    virtual bool shutdown() = 0;
    
    // æ’ä»¶åŠŸèƒ½æ¥å£
    virtual bool handle_request(const Request& req, Response& resp) = 0;
    virtual std::vector<std::string> get_supported_operations() const = 0;
};

// æ’ä»¶ç®¡ç†å™¨
class PluginManager {
private:
    std::map<std::string, std::unique_ptr<Plugin>> plugins_;
    std::map<std::string, void*> plugin_handles_; // åŠ¨æ€åº“å¥æŸ„
    
public:
    // åŠ è½½æ’ä»¶
    bool load_plugin(const std::string& plugin_path) {
        // 1. åŠ è½½åŠ¨æ€åº“
        void* handle = dlopen(plugin_path.c_str(), RTLD_LAZY);
        if (!handle) {
            log_error("Failed to load plugin: " + std::string(dlerror()));
            return false;
        }
        
        // 2. è·å–æ’ä»¶å·¥å‚å‡½æ•°
        typedef Plugin* (*create_plugin_t)();
        create_plugin_t create_plugin = (create_plugin_t)dlsym(handle, "create_plugin");
        if (!create_plugin) {
            log_error("Plugin missing create_plugin function");
            dlclose(handle);
            return false;
        }
        
        // 3. åˆ›å»ºæ’ä»¶å®ä¾‹
        std::unique_ptr<Plugin> plugin(create_plugin());
        if (!plugin) {
            log_error("Failed to create plugin instance");
            dlclose(handle);
            return false;
        }
        
        // 4. åˆå§‹åŒ–æ’ä»¶
        PluginConfig config = load_plugin_config(plugin->get_name());
        if (!plugin->initialize(config)) {
            log_error("Failed to initialize plugin: " + plugin->get_name());
            dlclose(handle);
            return false;
        }
        
        // 5. æ³¨å†Œæ’ä»¶
        std::string plugin_name = plugin->get_name();
        plugins_[plugin_name] = std::move(plugin);
        plugin_handles_[plugin_name] = handle;
        
        log_info("Successfully loaded plugin: " + plugin_name);
        return true;
    }
    
    // å¸è½½æ’ä»¶
    bool unload_plugin(const std::string& plugin_name) {
        auto it = plugins_.find(plugin_name);
        if (it == plugins_.end()) {
            return false;
        }
        
        // åœæ­¢å¹¶æ¸…ç†æ’ä»¶
        it->second->stop();
        it->second->shutdown();
        plugins_.erase(it);
        
        // å¸è½½åŠ¨æ€åº“
        auto handle_it = plugin_handles_.find(plugin_name);
        if (handle_it != plugin_handles_.end()) {
            dlclose(handle_it->second);
            plugin_handles_.erase(handle_it);
        }
        
        log_info("Unloaded plugin: " + plugin_name);
        return true;
    }
    
    // è·¯ç”±è¯·æ±‚åˆ°åˆé€‚çš„æ’ä»¶
    bool route_request(const Request& req, Response& resp) {
        for (auto& [name, plugin] : plugins_) {
            auto supported_ops = plugin->get_supported_operations();
            if (std::find(supported_ops.begin(), supported_ops.end(), 
                         req.operation) != supported_ops.end()) {
                return plugin->handle_request(req, resp);
            }
        }
        
        log_warning("No plugin found for operation: " + req.operation);
        return false;
    }
};
```

### 11.3 æ¨¡å—åŒ–è®¾è®¡


**ğŸ§© æ¨¡å—åŒ–åŸåˆ™**

```
é«˜å†…èšä½è€¦åˆï¼š
â”œâ”€â”€ æ¨¡å—å†…éƒ¨åŠŸèƒ½ç´§å¯†ç›¸å…³
â”œâ”€â”€ æ¨¡å—é—´ä¾èµ–å…³ç³»æœ€å°åŒ–
â”œâ”€â”€ é€šè¿‡æ¥å£è¿›è¡Œæ¨¡å—é—´é€šä¿¡
â””â”€â”€ æ”¯æŒæ¨¡å—ç‹¬ç«‹å¼€å‘æµ‹è¯•

åˆ†å±‚æ¶æ„ï¼š
â”œâ”€â”€ è¡¨ç¤ºå±‚ï¼šç”¨æˆ·ç•Œé¢ã€APIæ¥å£
â”œâ”€â”€ ä¸šåŠ¡é€»è¾‘å±‚ï¼šæ ¸å¿ƒä¸šåŠ¡åŠŸèƒ½
â”œâ”€â”€ æ•°æ®è®¿é—®å±‚ï¼šæ•°æ®å­˜å‚¨å’Œè®¿é—®
â””â”€â”€ åŸºç¡€è®¾æ–½å±‚ï¼šæ—¥å¿—ã€ç›‘æ§ã€é…ç½®

æ¨¡å—è¾¹ç•Œæ¸…æ™°ï¼š
â”œâ”€â”€ æ˜ç¡®çš„è¾“å…¥è¾“å‡ºæ¥å£
â”œâ”€â”€ æ ‡å‡†åŒ–çš„é”™è¯¯å¤„ç†
â”œâ”€â”€ ç»Ÿä¸€çš„æ—¥å¿—æ ¼å¼
â””â”€â”€ ä¸€è‡´çš„é…ç½®ç®¡ç†
```

**æ¨¡å—ä¾èµ–ç®¡ç†**

```cpp
// ä¾èµ–æ³¨å…¥å®¹å™¨
class DependencyInjector {
private:
    std::map<std::string, std::function<std::unique_ptr<Component>()>> factories_;
    std::map<std::string, std::unique_ptr<Component>> singletons_;
    std::map<std::string, std::vector<std::string>> dependencies_;
    
public:
    // æ³¨å†Œç»„ä»¶å·¥å‚
    template<typename T>
    void register_component(const std::string& name,
                          const std::vector<std::string>& deps = {}) {
        factories_[name] = []() { return std::make_unique<T>(); };
        dependencies_[name] = deps;
    }
    
    // è·å–ç»„ä»¶å®ä¾‹
    template<typename T>
    std::shared_ptr<T> get_component(const std::string& name) {
        // æ£€æŸ¥ä¾èµ–å…³ç³»
        if (!resolve_dependencies(name)) {
            throw DependencyResolutionException(name);
        }
        
        auto it = singletons_.find(name);
        if (it != singletons_.end()) {
            return std::static_pointer_cast<T>(it->second);
        }
        
        // åˆ›å»ºæ–°å®ä¾‹
        auto factory_it = factories_.find(name);
        if (factory_it == factories_.end()) {
            throw ComponentNotFoundException(name);
        }
        
        auto component = factory_it->second();
        singletons_[name] = std::move(component);
        
        return std::static_pointer_cast<T>(singletons_[name]);
    }
    
private:
    bool resolve_dependencies(const std::string& name) {
        auto deps_it = dependencies_.find(name);
        if (deps_it == dependencies_.end()) {
            return true;  // æ— ä¾èµ–
        }
        
        for (const auto& dep : deps_it->second) {
            if (singletons_.find(dep) == singletons_.end()) {
                // é€’å½’è§£æä¾èµ–
                if (!resolve_dependencies(dep)) {
                    return false;
                }
                // åˆ›å»ºä¾èµ–ç»„ä»¶
                auto factory_it = factories_.find(dep);
                if (factory_it != factories_.end()) {
                    singletons_[dep] = factory_it->second();
                }
            }
        }
        
        return true;
    }
};
```

---

## 12. æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 12.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ç»„ä»¶æ¶æ„ç†è§£ï¼š
â”œâ”€â”€ MySQLé‡‡ç”¨åˆ†å±‚æ¨¡å—åŒ–æ¶æ„
â”œâ”€â”€ ç»„ä»¶é—´é€šè¿‡æ ‡å‡†æ¥å£é€šä¿¡
â”œâ”€â”€ æ”¯æŒæ’ä»¶åŒ–æ‰©å±•æœºåˆ¶
â””â”€â”€ å…·å¤‡å®Œå–„çš„æœåŠ¡ç®¡ç†èƒ½åŠ›

äº¤äº’æœºåˆ¶æŒæ¡ï¼š
â”œâ”€â”€ åŒæ­¥è°ƒç”¨ã€å¼‚æ­¥é€šçŸ¥ã€äº‹ä»¶é©±åŠ¨ç­‰äº¤äº’æ¨¡å¼
â”œâ”€â”€ æ ‡å‡†åŒ–çš„æ¥å£è®¾è®¡å’Œå‚æ•°ä¼ é€’è§„èŒƒ
â”œâ”€â”€ ç»„ä»¶æ³¨å†Œå‘ç°å’ŒçŠ¶æ€åŒæ­¥åè®®
â””â”€â”€ æ•…éšœéš”ç¦»å’Œæ€§èƒ½ç›‘æ§æœºåˆ¶

é…ç½®ç®¡ç†ç†è§£ï¼š
â”œâ”€â”€ é…ç½®çƒ­æ›´æ–°æœºåˆ¶å’Œç­–ç•¥
â”œâ”€â”€ ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†æ–¹æ³•
â”œâ”€â”€ APIç‰ˆæœ¬åŒ–å’Œå‡çº§ç­–ç•¥
â””â”€â”€ æ‰©å±•æ€§è®¾è®¡åŸåˆ™åº”ç”¨
```

### 12.2 å…³é”®ç†è§£è¦ç‚¹


**ç»„ä»¶äº¤äº’çš„æœ¬è´¨**
```
é€šä¿¡åè®®ï¼šç»„ä»¶é—´éœ€è¦ç»Ÿä¸€çš„"è¯­è¨€"
æ¥å£æ ‡å‡†ï¼šå°±åƒåˆåŒæ¡æ¬¾ï¼Œæ˜ç¡®æƒè´£
çŠ¶æ€åŒæ­¥ï¼šç¡®ä¿ç»„ä»¶ä¿¡æ¯ä¸€è‡´æ€§
æ•…éšœéš”ç¦»ï¼šé˜²æ­¢å•ç‚¹æ•…éšœæ‰©æ•£
æ€§èƒ½ç›‘æ§ï¼šå®æ—¶äº†è§£ç³»ç»Ÿå¥åº·çŠ¶å†µ
```

**è®¾è®¡åŸåˆ™çš„é‡è¦æ€§**
```
æ¨¡å—åŒ–è®¾è®¡ï¼š
â”œâ”€â”€ é™ä½ç³»ç»Ÿå¤æ‚åº¦
â”œâ”€â”€ æé«˜ä»£ç å¤ç”¨æ€§
â”œâ”€â”€ ä¾¿äºå›¢é˜Ÿåä½œå¼€å‘
â””â”€â”€ æ”¯æŒç‹¬ç«‹æµ‹è¯•å’Œéƒ¨ç½²

å¯æ‰©å±•æ¶æ„ï¼š
â”œâ”€â”€ é€‚åº”ä¸šåŠ¡å‘å±•éœ€æ±‚
â”œâ”€â”€ æ”¯æŒæ–°æŠ€æœ¯é›†æˆ
â”œâ”€â”€ é™ä½å‡çº§æˆæœ¬
â””â”€â”€ æé«˜ç³»ç»Ÿçµæ´»æ€§
```

**å®é™…åº”ç”¨ä»·å€¼**
```
å¼€å‘å±‚é¢ï¼š
â”œâ”€â”€ æŒ‡å¯¼ç»„ä»¶æ¥å£è®¾è®¡
â”œâ”€â”€ è§„èŒƒæ¨¡å—é—´é€šä¿¡
â”œâ”€â”€ æä¾›æ‰©å±•å¼€å‘æ¡†æ¶
â””â”€â”€ æ”¯æŒæ’ä»¶å¼€å‘

è¿ç»´å±‚é¢ï¼š
â”œâ”€â”€ æ”¯æŒçƒ­é…ç½®æ›´æ–°
â”œâ”€â”€ æä¾›å¥åº·æ£€æŸ¥æœºåˆ¶
â”œâ”€â”€ å®ç°æ•…éšœè‡ªåŠ¨éš”ç¦»
â””â”€â”€ æ”¯æŒå¹³æ»‘å‡çº§

æ¶æ„å±‚é¢ï¼š
â”œâ”€â”€ æ”¯æŒå¾®æœåŠ¡åŒ–æ”¹é€ 
â”œâ”€â”€ æä¾›å®¹å™¨åŒ–éƒ¨ç½²èƒ½åŠ›
â”œâ”€â”€ æ”¯æŒäº‘åŸç”Ÿæ¶æ„
â””â”€â”€ å®ç°é«˜å¯ç”¨éƒ¨ç½²
```

### 12.3 å®è·µæŒ‡å¯¼åŸåˆ™


**è®¾è®¡æ–°ç»„ä»¶æ—¶çš„è€ƒè™‘è¦ç‚¹**
```
æ¥å£è®¾è®¡ï¼š
â”œâ”€â”€ å®šä¹‰æ¸…æ™°çš„èŒè´£è¾¹ç•Œ
â”œâ”€â”€ è®¾è®¡ç®€æ´çš„æ¥å£ç­¾å
â”œâ”€â”€ æä¾›å®Œæ•´çš„é”™è¯¯å¤„ç†
â””â”€â”€ è€ƒè™‘æœªæ¥æ‰©å±•éœ€æ±‚

é›†æˆç°æœ‰ç³»ç»Ÿï¼š
â”œâ”€â”€ éµå¾ªç°æœ‰æ¥å£è§„èŒƒ
â”œâ”€â”€ å®ç°æ ‡å‡†ç›‘æ§æ¥å£
â”œâ”€â”€ æ”¯æŒé…ç½®çƒ­æ›´æ–°
â””â”€â”€ æä¾›ç‰ˆæœ¬å…¼å®¹ä¿éšœ

æ€§èƒ½ä¼˜åŒ–ï¼š
â”œâ”€â”€ å‡å°‘ç»„ä»¶é—´é€šä¿¡å¼€é”€
â”œâ”€â”€ å®ç°é«˜æ•ˆçš„çŠ¶æ€åŒæ­¥
â”œâ”€â”€ ä¼˜åŒ–èµ„æºä½¿ç”¨ç­–ç•¥
â””â”€â”€ æä¾›æ€§èƒ½ç›‘æ§æŒ‡æ ‡
```

**æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
- ç»„ä»¶äº¤äº’æœ‰è§„èŒƒï¼Œæ¥å£æ ‡å‡†æ˜¯å…³é”®
- æ³¨å†Œå‘ç°æœåŠ¡åŒ–ï¼ŒçŠ¶æ€åŒæ­¥ä¿ä¸€è‡´
- æ•…éšœéš”ç¦»é˜²æ‰©æ•£ï¼Œç›‘æ§å‘Šè­¦è¦åŠæ—¶
- é…ç½®çƒ­æ›´æ–°çµæ´»ï¼Œç‰ˆæœ¬å…¼å®¹è¦è€ƒè™‘
- æ‰©å±•è®¾è®¡è¦å‰ç»ï¼Œæ¨¡å—åŒ–æ˜¯åŸºç¡€