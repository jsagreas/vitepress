---
title: 10ã€æŸ¥è¯¢è§£æå™¨Parserè¯¦è§£
---
## ğŸ“š ç›®å½•

1. [SQLè§£æå™¨åŸºç¡€æ¦‚å¿µ](#1-SQLè§£æå™¨åŸºç¡€æ¦‚å¿µ)
2. [è¯æ³•åˆ†æè¯¦è§£](#2-è¯æ³•åˆ†æè¯¦è§£)
3. [è¯­æ³•åˆ†æè¯¦è§£](#3-è¯­æ³•åˆ†æè¯¦è§£)
4. [æŠ½è±¡è¯­æ³•æ ‘AST](#4-æŠ½è±¡è¯­æ³•æ ‘AST)
5. [è§£æå™¨æ ¸å¿ƒç»„ä»¶](#5-è§£æå™¨æ ¸å¿ƒç»„ä»¶)
6. [è§£æè¿‡ç¨‹ä¸çŠ¶æ€æœº](#6-è§£æè¿‡ç¨‹ä¸çŠ¶æ€æœº)
7. [é”™è¯¯å¤„ç†ä¸è¯Šæ–­](#7-é”™è¯¯å¤„ç†ä¸è¯Šæ–­)
8. [è§£æå™¨æ€§èƒ½ä¼˜åŒ–](#8-è§£æå™¨æ€§èƒ½ä¼˜åŒ–)
9. [SQLæ–¹è¨€ä¸æ‰©å±•](#9-SQLæ–¹è¨€ä¸æ‰©å±•)
10. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#10-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ” SQLè§£æå™¨åŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯SQLè§£æå™¨

**SQLè§£æå™¨ï¼ˆParserï¼‰**å°±åƒæ˜¯æ•°æ®åº“çš„"ç¿»è¯‘å®˜"ï¼Œå®ƒçš„å·¥ä½œæ˜¯æŠŠäººç±»èƒ½ç†è§£çš„SQLè¯­å¥è½¬æ¢æˆæ•°æ®åº“èƒ½æ‰§è¡Œçš„å†…éƒ¨ç»“æ„ã€‚

```
ç®€å•ç±»æ¯”ï¼š
SQLè§£æå™¨ = è¯­è¨€ç¿»è¯‘å®˜
â”œâ”€â”€ è¾“å…¥ï¼šäººç±»å†™çš„SQLè¯­å¥ï¼ˆä¸­æ–‡ï¼‰
â”œâ”€â”€ å¤„ç†ï¼šç†è§£è¯­æ³•å’Œå«ä¹‰
â””â”€â”€ è¾“å‡ºï¼šæ•°æ®åº“èƒ½ç†è§£çš„æŒ‡ä»¤ï¼ˆæœºå™¨è¯­è¨€ï¼‰

ä¾‹å¦‚ï¼š
è¾“å…¥ï¼šSELECT name FROM users WHERE age > 18;
è¾“å‡ºï¼šæ•°æ®åº“å†…éƒ¨çš„æ‰§è¡Œè®¡åˆ’ç»“æ„
```

### 1.2 è§£æå™¨åœ¨æ•°æ®åº“ä¸­çš„ä½ç½®

```
SQLæŸ¥è¯¢å¤„ç†æµç¨‹ï¼š

ç”¨æˆ·SQLè¯­å¥
    â†“
ğŸ“ è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰
    â†“
ğŸ“‹ è¯­æ³•åˆ†æï¼ˆSyntax Analysisï¼‰  
    â†“
ğŸŒ² ç”ŸæˆASTæŠ½è±¡è¯­æ³•æ ‘
    â†“
ğŸ” è¯­ä¹‰åˆ†æï¼ˆSemantic Analysisï¼‰
    â†“
âš¡ æŸ¥è¯¢ä¼˜åŒ–å™¨
    â†“
ğŸƒ æ‰§è¡Œå¼•æ“
    â†“
ğŸ“Š è¿”å›ç»“æœ
```

### 1.3 è§£æå™¨çš„æ ¸å¿ƒä»»åŠ¡

**ğŸ”¸ ä¸»è¦å·¥ä½œ**
- **è¯æ³•åˆ†æ**ï¼šæŠŠSQLå­—ç¬¦ä¸²åˆ†è§£æˆä¸€ä¸ªä¸ª"è¯æ±‡"ï¼ˆTokenï¼‰
- **è¯­æ³•åˆ†æ**ï¼šæ£€æŸ¥è¿™äº›è¯æ±‡çš„ç»„åˆæ˜¯å¦ç¬¦åˆSQLè¯­æ³•è§„åˆ™
- **æ„å»ºAST**ï¼šæŠŠæ­£ç¡®çš„SQLè½¬æ¢æˆæŠ½è±¡è¯­æ³•æ ‘
- **é”™è¯¯æ£€æµ‹**ï¼šå‘ç°å¹¶æŠ¥å‘Šè¯­æ³•é”™è¯¯

**ğŸ”¸ è§£æå™¨çš„ä»·å€¼**
```
æ²¡æœ‰è§£æå™¨çš„æƒ…å†µï¼š
æ•°æ®åº“æ— æ³•ç†è§£ "SELECT * FROM users"
å°±åƒå¤–å›½äººå¬ä¸æ‡‚ä¸­æ–‡

æœ‰äº†è§£æå™¨ï¼š
"SELECT * FROM users" â†’ æ•°æ®åº“æ˜ç™½è¦æŸ¥è¯¢usersè¡¨çš„æ‰€æœ‰åˆ—
```

---

## 2. ğŸ“ è¯æ³•åˆ†æè¯¦è§£


### 2.1 è¯æ³•åˆ†æåŸºæœ¬æ¦‚å¿µ

**è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰**å°±åƒæ˜¯æŠŠå¥å­æ‹†åˆ†æˆå•è¯çš„è¿‡ç¨‹ï¼ŒæŠŠè¿ç»­çš„SQLå­—ç¬¦ä¸²åˆ†è§£æˆä¸€ä¸ªä¸ªæœ‰æ„ä¹‰çš„"è¯æ±‡å•å…ƒ"ã€‚

```
SQLè¯­å¥ï¼šSELECT name FROM users WHERE age > 18;

è¯æ³•åˆ†æç»“æœï¼š
Token1: SELECT    (å…³é”®å­—)
Token2: name      (æ ‡è¯†ç¬¦)  
Token3: FROM      (å…³é”®å­—)
Token4: users     (æ ‡è¯†ç¬¦)
Token5: WHERE     (å…³é”®å­—)
Token6: age       (æ ‡è¯†ç¬¦)
Token7: >         (æ“ä½œç¬¦)
Token8: 18        (æ•°å­—å¸¸é‡)
Token9: ;         (åˆ†éš”ç¬¦)
```

### 2.2 LEXè¯æ³•åˆ†æå™¨ç”Ÿæˆ

**LEXå·¥å…·**æ˜¯ç»å…¸çš„è¯æ³•åˆ†æå™¨ç”Ÿæˆå·¥å…·ï¼Œé€šè¿‡æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰è¯æ±‡è§„åˆ™ã€‚

```c
/* SQLè¯æ³•è§„åˆ™ç¤ºä¾‹ */
%%
SELECT      { return SELECT_TOKEN; }
FROM        { return FROM_TOKEN; }
WHERE       { return WHERE_TOKEN; }
INSERT      { return INSERT_TOKEN; }
UPDATE      { return UPDATE_TOKEN; }
DELETE      { return DELETE_TOKEN; }

[a-zA-Z_][a-zA-Z0-9_]*    { return IDENTIFIER; }
[0-9]+                    { return INTEGER; }
[0-9]*\.[0-9]+           { return DECIMAL; }
'[^']*'                  { return STRING; }

"="         { return EQ; }
">"         { return GT; }
"<"         { return LT; }
">="        { return GE; }
"<="        { return LE; }
"!="        { return NE; }

[ \t\n]+    { /* å¿½ç•¥ç©ºç™½å­—ç¬¦ */ }
"--".*      { /* å¿½ç•¥å•è¡Œæ³¨é‡Š */ }
%%
```

### 2.3 Tokenç±»å‹åˆ†ç±»

**ğŸ”¸ SQLä¸­çš„Tokenç±»å‹**

| Tokenç±»å‹ | æè¿° | ç¤ºä¾‹ |
|-----------|------|------|
| **å…³é”®å­—** | SQLä¿ç•™å­— | SELECT, FROM, WHERE, JOIN |
| **æ ‡è¯†ç¬¦** | è¡¨åã€åˆ—åç­‰ | users, user_id, first_name |
| **å­—é¢é‡** | å¸¸é‡å€¼ | 123, 'hello', 3.14 |
| **æ“ä½œç¬¦** | è¿ç®—ç¬¦å· | +, -, *, /, =, >, < |
| **åˆ†éš”ç¬¦** | è¯­æ³•åˆ†éš”ç¬¦ | (, ), ,, ;, . |
| **æ³¨é‡Š** | ä»£ç æ³¨é‡Š | -- comment, /* comment */ |

### 2.4 è¯æ³•åˆ†æå™¨çŠ¶æ€æœº

```
è¯æ³•åˆ†æå™¨çŠ¶æ€è½¬æ¢ï¼š

åˆå§‹çŠ¶æ€ â†’ è¯»å–å­—ç¬¦ â†’ åˆ¤æ–­å­—ç¬¦ç±»å‹
    â†“
å­—æ¯å¼€å¤´ â†’ ç»§ç»­è¯»å–å­—æ¯æ•°å­— â†’ åˆ¤æ–­æ˜¯å…³é”®å­—è¿˜æ˜¯æ ‡è¯†ç¬¦
    â†“
æ•°å­—å¼€å¤´ â†’ ç»§ç»­è¯»å–æ•°å­— â†’ é‡åˆ°å°æ•°ç‚¹ç»§ç»­è¯»å– â†’ æ•°å­—Token
    â†“
å¼•å·å¼€å¤´ â†’ è¯»å–åˆ°ä¸‹ä¸€ä¸ªå¼•å· â†’ å­—ç¬¦ä¸²Token
    â†“
æ“ä½œç¬¦ â†’ æ£€æŸ¥å¤šå­—ç¬¦æ“ä½œç¬¦ â†’ æ“ä½œç¬¦Token

çŠ¶æ€æœºç¤ºä¾‹ï¼ˆè¯†åˆ«æ•°å­—ï¼‰ï¼š
Start â†’ è¯»åˆ°æ•°å­— â†’ Number_State â†’ è¯»åˆ°å°æ•°ç‚¹ â†’ Decimal_State â†’ ç»“æŸ
```

---

## 3. ğŸ“‹ è¯­æ³•åˆ†æè¯¦è§£


### 3.1 è¯­æ³•åˆ†æåŸºæœ¬æ¦‚å¿µ

**è¯­æ³•åˆ†æï¼ˆSyntax Analysisï¼‰**å°±åƒæ£€æŸ¥å¥å­è¯­æ³•æ˜¯å¦æ­£ç¡®ï¼Œå®ƒæ ¹æ®SQLè¯­æ³•è§„åˆ™æ£€æŸ¥Tokenåºåˆ—æ˜¯å¦æ„æˆåˆæ³•çš„SQLè¯­å¥ã€‚

```
è¯æ³•åˆ†æçš„è¾“å‡º â†’ è¯­æ³•åˆ†æçš„è¾“å…¥ï¼š
Tokenåºåˆ—ï¼š[SELECT, name, FROM, users, WHERE, age, >, 18, ;]

è¯­æ³•åˆ†æè¦å›ç­”çš„é—®é¢˜ï¼š
- è¿™äº›Tokençš„é¡ºåºå¯¹å—ï¼Ÿ
- è¯­æ³•ç»“æ„å®Œæ•´å—ï¼Ÿ
- ç¬¦åˆSQLè§„èŒƒå—ï¼Ÿ

æ­£ç¡®çš„è¯­æ³•ç»“æ„ï¼š
SELECT åˆ—å FROM è¡¨å WHERE æ¡ä»¶ ;
```

### 3.2 YACCè¯­æ³•åˆ†æå™¨ç”Ÿæˆ

**YACCï¼ˆYet Another Compiler Compilerï¼‰**æ˜¯ç»å…¸çš„è¯­æ³•åˆ†æå™¨ç”Ÿæˆå·¥å…·ï¼Œä½¿ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•å®šä¹‰SQLè¯­æ³•è§„åˆ™ã€‚

```yacc
/* SQLè¯­æ³•è§„åˆ™ç¤ºä¾‹ */
%%
/* æŸ¥è¯¢è¯­å¥ */
query: select_stmt
     | insert_stmt  
     | update_stmt
     | delete_stmt
     ;

/* SELECTè¯­å¥ */
select_stmt: SELECT select_list FROM table_list where_clause
           | SELECT select_list FROM table_list
           ;

/* é€‰æ‹©åˆ—è¡¨ */
select_list: column_name
           | select_list ',' column_name
           | '*'
           ;

/* è¡¨åˆ—è¡¨ */
table_list: table_name
          | table_list ',' table_name
          ;

/* WHEREå­å¥ */
where_clause: WHERE condition
            ;

/* æ¡ä»¶è¡¨è¾¾å¼ */
condition: column_name '=' value
         | column_name '>' value
         | column_name '<' value
         | condition AND condition
         | condition OR condition
         | '(' condition ')'
         ;

/* åŸºæœ¬å…ƒç´  */
column_name: IDENTIFIER ;
table_name: IDENTIFIER ;
value: INTEGER | STRING | DECIMAL ;
%%
```

### 3.3 è¯­æ³•è§„åˆ™å®šä¹‰

**ğŸ”¸ ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼ˆCFGï¼‰**
SQLè¯­æ³•ä½¿ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•å®šä¹‰ï¼Œæ¯ä¸ªè§„åˆ™æè¿°ä¸€ä¸ªè¯­æ³•ç»“æ„ï¼š

```
BNFï¼ˆå·´ç§‘æ–¯èŒƒå¼ï¼‰è¡¨ç¤ºæ³•ï¼š

<select_statement> ::= SELECT <select_list> FROM <table_list> [<where_clause>]
<select_list> ::= * | <column_list>
<column_list> ::= <column_name> | <column_list>, <column_name>
<where_clause> ::= WHERE <condition>
<condition> ::= <expression> <operator> <expression>
<operator> ::= = | > | < | >= | <= | !=

ç¤ºä¾‹åŒ¹é…è¿‡ç¨‹ï¼š
"SELECT name FROM users" 
åŒ¹é… <select_statement>
â”œâ”€â”€ SELECT åŒ¹é… SELECT
â”œâ”€â”€ name åŒ¹é… <select_list> â†’ <column_list> â†’ <column_name>
â”œâ”€â”€ FROM åŒ¹é… FROM
â””â”€â”€ users åŒ¹é… <table_list> â†’ <table_name>
```

### 3.4 è¯­æ³•åˆ†æç®—æ³•

**ğŸ”¸ è‡ªä¸Šè€Œä¸‹åˆ†æï¼ˆTop-Downï¼‰**
```
ä»è¯­æ³•æ ‘æ ¹éƒ¨å¼€å§‹ï¼Œé€æ­¥åŒ¹é…Tokenï¼š

ç›®æ ‡ï¼šåŒ¹é… SELECT name FROM users

1. åŒ¹é… <select_statement>
2. æœŸæœ› SELECT â†’ Token[0]=SELECT âœ“
3. åŒ¹é… <select_list>  
4. æœŸæœ› <column_name> â†’ Token[1]=name âœ“
5. æœŸæœ› FROM â†’ Token[2]=FROM âœ“
6. åŒ¹é… <table_list>
7. æœŸæœ› <table_name> â†’ Token[3]=users âœ“
8. è§£ææˆåŠŸï¼
```

**ğŸ”¸ è‡ªä¸‹è€Œä¸Šåˆ†æï¼ˆBottom-Upï¼‰**
```
ä»Tokenå¼€å§‹ï¼Œé€æ­¥æ„å»ºè¯­æ³•ç»“æ„ï¼š

Tokenåºåˆ—ï¼š[SELECT, name, FROM, users]

1. name â†’ <column_name>
2. users â†’ <table_name>  
3. <column_name> â†’ <select_list>
4. <table_name> â†’ <table_list>
5. SELECT <select_list> FROM <table_list> â†’ <select_statement>
6. è§£ææˆåŠŸï¼
```

---

## 4. ğŸŒ² æŠ½è±¡è¯­æ³•æ ‘AST


### 4.1 ASTåŸºæœ¬æ¦‚å¿µ

**æŠ½è±¡è¯­æ³•æ ‘ï¼ˆAbstract Syntax Treeï¼‰**æ˜¯SQLè¯­å¥çš„æ ‘å½¢è¡¨ç¤ºï¼Œå»æ‰äº†å…·ä½“çš„è¯­æ³•ç»†èŠ‚ï¼Œåªä¿ç•™è¯­ä¹‰ç»“æ„ã€‚

```
SQLè¯­å¥ï¼šSELECT name, age FROM users WHERE age > 18;

å¯¹åº”çš„ASTç»“æ„ï¼š
        SelectStmt
       /     |     \
  SelectList FromList  WhereClause
     /   \      |         |
   name   age  users   Condition
                        /   |   \
                     age   >    18
```

### 4.2 ASTèŠ‚ç‚¹ç±»å‹

**ğŸ”¸ å¸¸è§ASTèŠ‚ç‚¹ç±»å‹**

```cpp
// ASTèŠ‚ç‚¹åŸºç±»
class ASTNode {
public:
    virtual ~ASTNode() = default;
    virtual void accept(Visitor& visitor) = 0;
};

// SELECTè¯­å¥èŠ‚ç‚¹
class SelectStmt : public ASTNode {
public:
    std::vector<ColumnRef*> selectList;  // é€‰æ‹©åˆ—è¡¨
    std::vector<TableRef*> fromList;     // è¡¨åˆ—è¡¨  
    ExprNode* whereClause;               // WHEREæ¡ä»¶
    std::vector<ColumnRef*> groupByList; // GROUP BYåˆ—è¡¨
    ExprNode* havingClause;              // HAVINGæ¡ä»¶
    std::vector<OrderByItem*> orderByList; // ORDER BYåˆ—è¡¨
};

// åˆ—å¼•ç”¨èŠ‚ç‚¹
class ColumnRef : public ASTNode {
public:
    std::string tableName;   // è¡¨åï¼ˆå¯é€‰ï¼‰
    std::string columnName;  // åˆ—å
};

// è¡¨å¼•ç”¨èŠ‚ç‚¹  
class TableRef : public ASTNode {
public:
    std::string tableName;   // è¡¨å
    std::string alias;       // åˆ«åï¼ˆå¯é€‰ï¼‰
};

// è¡¨è¾¾å¼èŠ‚ç‚¹
class ExprNode : public ASTNode {
    // åŸºç±»ï¼Œå…·ä½“è¡¨è¾¾å¼ç»§æ‰¿æ­¤ç±»
};

// äºŒå…ƒæ“ä½œèŠ‚ç‚¹
class BinaryOpExpr : public ExprNode {
public:
    ExprNode* left;          // å·¦æ“ä½œæ•°
    ExprNode* right;         // å³æ“ä½œæ•°
    std::string operator_;   // æ“ä½œç¬¦
};
```

### 4.3 è¯­æ³•æ ‘éå†ç®—æ³•

**ğŸ”¸ è®¿é—®è€…æ¨¡å¼ï¼ˆVisitor Patternï¼‰**
```cpp
// è®¿é—®è€…æ¥å£
class Visitor {
public:
    virtual void visit(SelectStmt* stmt) = 0;
    virtual void visit(ColumnRef* column) = 0;
    virtual void visit(TableRef* table) = 0;
    virtual void visit(BinaryOpExpr* expr) = 0;
};

// å…·ä½“è®¿é—®è€…ï¼šæ‰“å°SQLç»“æ„
class PrintVisitor : public Visitor {
public:
    void visit(SelectStmt* stmt) override {
        std::cout << "SELECT ";
        for (auto column : stmt->selectList) {
            column->accept(*this);
        }
        std::cout << " FROM ";
        for (auto table : stmt->fromList) {
            table->accept(*this);
        }
        if (stmt->whereClause) {
            std::cout << " WHERE ";
            stmt->whereClause->accept(*this);
        }
    }
    
    void visit(ColumnRef* column) override {
        if (!column->tableName.empty()) {
            std::cout << column->tableName << ".";
        }
        std::cout << column->columnName;
    }
    
    // ... å…¶ä»–visitæ–¹æ³•
};

// ä½¿ç”¨ç¤ºä¾‹
SelectStmt* ast = parseSQL("SELECT name FROM users WHERE age > 18");
PrintVisitor printer;
ast->accept(printer);
```

### 4.4 è¯­æ³•æ ‘ç»“æ„ç†è§£

**ğŸ”¸ AST vs è§£ææ ‘çš„åŒºåˆ«**
```
åŸå§‹SQLï¼šSELECT name FROM users WHERE age > 18;

è§£ææ ‘ï¼ˆåŒ…å«æ‰€æœ‰è¯­æ³•ç»†èŠ‚ï¼‰ï¼š
    select_statement  
    /       |       \
SELECT  select_list  FROM  table_list  WHERE  condition
        |            |            |       |      \
    column_name    IDENTIFIER   age      >      18
        |             |
    IDENTIFIER      users
        |
       name

ASTï¼ˆå»æ‰è¯­æ³•ç»†èŠ‚ï¼Œä¿ç•™è¯­ä¹‰ï¼‰ï¼š
    SelectStmt
   /     |     \
 name   users  BinaryOp
                /  |  \
              age  >   18

ASTæ›´ç®€æ´ï¼Œä¾¿äºåç»­å¤„ç†
```

---

## 5. âš™ï¸ è§£æå™¨æ ¸å¿ƒç»„ä»¶


### 5.1 ç¬¦å·è¡¨ç®¡ç†

**ç¬¦å·è¡¨ï¼ˆSymbol Tableï¼‰**æ˜¯è§£æå™¨ç”¨æ¥ç®¡ç†æ ‡è¯†ç¬¦ä¿¡æ¯çš„æ•°æ®ç»“æ„ï¼Œè®°å½•è¡¨åã€åˆ—åç­‰çš„å®šä¹‰å’Œå±æ€§ã€‚

```cpp
// ç¬¦å·è¡¨é¡¹
struct Symbol {
    std::string name;        // åç§°
    SymbolType type;         // ç±»å‹ï¼ˆè¡¨ã€åˆ—ã€å‡½æ•°ç­‰ï¼‰
    DataType dataType;       // æ•°æ®ç±»å‹ï¼ˆINTã€VARCHARç­‰ï¼‰
    Scope scope;             // ä½œç”¨åŸŸ
    bool isNullable;         // æ˜¯å¦å¯ç©º
    std::string defaultValue; // é»˜è®¤å€¼
};

// ç¬¦å·è¡¨ç®¡ç†å™¨
class SymbolTable {
private:
    std::vector<std::unordered_map<std::string, Symbol>> scopes;
    
public:
    // è¿›å…¥æ–°ä½œç”¨åŸŸ
    void enterScope() {
        scopes.push_back(std::unordered_map<std::string, Symbol>());
    }
    
    // é€€å‡ºå½“å‰ä½œç”¨åŸŸ
    void exitScope() {
        if (!scopes.empty()) {
            scopes.pop_back();
        }
    }
    
    // æ·»åŠ ç¬¦å·
    void addSymbol(const std::string& name, const Symbol& symbol) {
        if (!scopes.empty()) {
            scopes.back()[name] = symbol;
        }
    }
    
    // æŸ¥æ‰¾ç¬¦å·
    Symbol* findSymbol(const std::string& name) {
        // ä»å½“å‰ä½œç”¨åŸŸå‘å¤–æŸ¥æ‰¾
        for (int i = scopes.size() - 1; i >= 0; i--) {
            auto it = scopes[i].find(name);
            if (it != scopes[i].end()) {
                return &it->second;
            }
        }
        return nullptr;
    }
};
```

### 5.2 è§£æå™¨å†…å­˜ç®¡ç†

**ğŸ”¸ ASTèŠ‚ç‚¹å†…å­˜ç®¡ç†**
```cpp
// å†…å­˜æ± ç®¡ç†å™¨
class ASTNodePool {
private:
    std::vector<std::unique_ptr<ASTNode>> nodes;
    
public:
    template<typename T, typename... Args>
    T* create(Args&&... args) {
        auto node = std::make_unique<T>(std::forward<Args>(args)...);
        T* ptr = node.get();
        nodes.push_back(std::move(node));
        return ptr;
    }
    
    // ææ„æ—¶è‡ªåŠ¨æ¸…ç†æ‰€æœ‰èŠ‚ç‚¹
    ~ASTNodePool() {
        nodes.clear();
    }
};

// ä½¿ç”¨ç¤ºä¾‹
class Parser {
private:
    ASTNodePool nodePool;
    
public:
    SelectStmt* parseSelectStatement() {
        auto stmt = nodePool.create<SelectStmt>();
        
        // è§£æSELECTåˆ—è¡¨
        stmt->selectList = parseSelectList();
        
        // è§£æFROMå­å¥
        stmt->fromList = parseFromList();
        
        // è§£æWHEREå­å¥
        if (currentToken.type == WHERE_TOKEN) {
            stmt->whereClause = parseWhereClause();
        }
        
        return stmt;
    }
};
```

### 5.3 è§£æç¼“å­˜ç­–ç•¥

**ğŸ”¸ è§£æç»“æœç¼“å­˜**
```cpp
// è§£æç¼“å­˜ç®¡ç†å™¨
class ParseCache {
private:
    struct CacheEntry {
        std::string sql;
        std::unique_ptr<ASTNode> ast;
        std::chrono::time_point<std::chrono::steady_clock> timestamp;
    };
    
    std::unordered_map<std::string, CacheEntry> cache;
    size_t maxSize;
    std::chrono::seconds maxAge;
    
public:
    ParseCache(size_t maxSize = 1000, std::chrono::seconds maxAge = std::chrono::seconds(300))
        : maxSize(maxSize), maxAge(maxAge) {}
    
    // è·å–ç¼“å­˜çš„AST
    ASTNode* getAST(const std::string& sql) {
        auto it = cache.find(sql);
        if (it != cache.end()) {
            // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            auto now = std::chrono::steady_clock::now();
            if (now - it->second.timestamp < maxAge) {
                return it->second.ast.get();
            } else {
                // è¿‡æœŸï¼Œåˆ é™¤
                cache.erase(it);
            }
        }
        return nullptr;
    }
    
    // ç¼“å­˜AST
    void putAST(const std::string& sql, std::unique_ptr<ASTNode> ast) {
        // ç¼“å­˜å¤§å°æ§åˆ¶
        if (cache.size() >= maxSize) {
            // ç®€å•çš„LRUç­–ç•¥ï¼šåˆ é™¤æœ€è€çš„æ¡ç›®
            auto oldest = cache.begin();
            for (auto it = cache.begin(); it != cache.end(); ++it) {
                if (it->second.timestamp < oldest->second.timestamp) {
                    oldest = it;
                }
            }
            cache.erase(oldest);
        }
        
        CacheEntry entry;
        entry.sql = sql;
        entry.ast = std::move(ast);
        entry.timestamp = std::chrono::steady_clock::now();
        
        cache[sql] = std::move(entry);
    }
};
```

---

## 6. ğŸ”„ è§£æè¿‡ç¨‹ä¸çŠ¶æ€æœº


### 6.1 è§£æå™¨çŠ¶æ€æœº

**è§£æå™¨çŠ¶æ€æœº**æ§åˆ¶æ•´ä¸ªè§£æè¿‡ç¨‹ï¼Œæ ¹æ®å½“å‰çŠ¶æ€å’Œè¾“å…¥Tokenå†³å®šä¸‹ä¸€æ­¥æ“ä½œã€‚

```cpp
// è§£æå™¨çŠ¶æ€æšä¸¾
enum class ParserState {
    START,
    EXPECT_SELECT_LIST,
    EXPECT_FROM,
    EXPECT_TABLE_LIST,
    EXPECT_WHERE,
    EXPECT_CONDITION,
    EXPECT_GROUP_BY,
    EXPECT_ORDER_BY,
    END
};

// è§£æå™¨çŠ¶æ€æœº
class SQLParser {
private:
    ParserState currentState;
    std::vector<Token> tokens;
    size_t tokenIndex;
    
public:
    SelectStmt* parseSelect() {
        currentState = ParserState::START;
        auto stmt = std::make_unique<SelectStmt>();
        
        while (currentState != ParserState::END && tokenIndex < tokens.size()) {
            switch (currentState) {
                case ParserState::START:
                    if (getCurrentToken().type == SELECT_TOKEN) {
                        consumeToken();
                        currentState = ParserState::EXPECT_SELECT_LIST;
                    } else {
                        throwError("Expected SELECT");
                    }
                    break;
                    
                case ParserState::EXPECT_SELECT_LIST:
                    stmt->selectList = parseSelectList();
                    currentState = ParserState::EXPECT_FROM;
                    break;
                    
                case ParserState::EXPECT_FROM:
                    if (getCurrentToken().type == FROM_TOKEN) {
                        consumeToken();
                        currentState = ParserState::EXPECT_TABLE_LIST;
                    } else {
                        throwError("Expected FROM");
                    }
                    break;
                    
                case ParserState::EXPECT_TABLE_LIST:
                    stmt->fromList = parseTableList();
                    // æ£€æŸ¥æ˜¯å¦æœ‰WHEREå­å¥
                    if (getCurrentToken().type == WHERE_TOKEN) {
                        currentState = ParserState::EXPECT_WHERE;
                    } else {
                        currentState = ParserState::END;
                    }
                    break;
                    
                // ... å…¶ä»–çŠ¶æ€å¤„ç†
            }
        }
        
        return stmt.release();
    }
};
```

### 6.2 SQLè§£æåŸºæœ¬è¿‡ç¨‹

```
å®Œæ•´çš„SQLè§£ææµç¨‹ï¼š

1. è¯æ³•åˆ†æé˜¶æ®µï¼š
   è¾“å…¥ï¼šSELECT name FROM users WHERE age > 18;
   è¾“å‡ºï¼š[SELECT, name, FROM, users, WHERE, age, >, 18, ;]

2. è¯­æ³•åˆ†æé˜¶æ®µï¼š
   è¾“å…¥ï¼šTokenåºåˆ—
   å¤„ç†ï¼šçŠ¶æ€æœºé©±åŠ¨çš„è§£æè¿‡ç¨‹
   è¾“å‡ºï¼šASTæŠ½è±¡è¯­æ³•æ ‘

3. è¯­ä¹‰åˆ†æé˜¶æ®µï¼š
   æ£€æŸ¥ï¼šè¡¨æ˜¯å¦å­˜åœ¨ã€åˆ—æ˜¯å¦å­˜åœ¨ã€ç±»å‹æ˜¯å¦åŒ¹é…
   å¤„ç†ï¼šç¬¦å·è¡¨æŸ¥æ‰¾ã€ç±»å‹æ£€æŸ¥
   è¾“å‡ºï¼šç»è¿‡éªŒè¯çš„AST

4. ä¼˜åŒ–å‡†å¤‡ï¼š
   ASTè½¬æ¢ä¸ºå†…éƒ¨è¡¨ç¤ºï¼Œä¸ºæŸ¥è¯¢ä¼˜åŒ–å™¨åšå‡†å¤‡
```

### 6.3 é€’å½’ä¸‹é™è§£æ

**ğŸ”¸ é€’å½’ä¸‹é™è§£æç®—æ³•**
```cpp
class RecursiveDescentParser {
private:
    std::vector<Token> tokens;
    size_t current;
    
    // åŒ¹é…æœŸæœ›çš„Tokenç±»å‹
    bool match(TokenType expected) {
        if (tokens[current].type == expected) {
            current++;
            return true;
        }
        return false;
    }
    
    // æ£€æŸ¥å½“å‰Tokenç±»å‹
    bool check(TokenType type) {
        return tokens[current].type == type;
    }
    
public:
    // è§£æSELECTè¯­å¥
    SelectStmt* parseSelectStatement() {
        auto stmt = new SelectStmt();
        
        // SELECTå…³é”®å­—
        if (!match(SELECT_TOKEN)) {
            throwError("Expected SELECT");
        }
        
        // è§£æé€‰æ‹©åˆ—è¡¨
        stmt->selectList = parseSelectList();
        
        // FROMå…³é”®å­—
        if (!match(FROM_TOKEN)) {
            throwError("Expected FROM");
        }
        
        // è§£æè¡¨åˆ—è¡¨
        stmt->fromList = parseTableList();
        
        // å¯é€‰çš„WHEREå­å¥
        if (check(WHERE_TOKEN)) {
            stmt->whereClause = parseWhereClause();
        }
        
        return stmt;
    }
    
    // è§£æé€‰æ‹©åˆ—è¡¨
    std::vector<ColumnRef*> parseSelectList() {
        std::vector<ColumnRef*> columns;
        
        do {
            if (match(STAR_TOKEN)) {
                // SELECT *
                columns.push_back(new ColumnRef("*"));
            } else if (check(IDENTIFIER)) {
                // æ™®é€šåˆ—å
                std::string columnName = tokens[current].value;
                current++;
                columns.push_back(new ColumnRef(columnName));
            } else {
                throwError("Expected column name");
            }
        } while (match(COMMA_TOKEN));
        
        return columns;
    }
};
```

---

## 7. âŒ é”™è¯¯å¤„ç†ä¸è¯Šæ–­


### 7.1 è¯­æ³•é”™è¯¯æ¢å¤æœºåˆ¶

**é”™è¯¯æ¢å¤**æ˜¯è§£æå™¨åœ¨é‡åˆ°è¯­æ³•é”™è¯¯æ—¶ç»§ç»­è§£æçš„èƒ½åŠ›ï¼Œå¸®åŠ©å‘ç°æ›´å¤šé”™è¯¯ã€‚

```cpp
// é”™è¯¯æ¢å¤ç­–ç•¥
class ErrorRecovery {
public:
    enum class RecoveryStrategy {
        PANIC_MODE,      // ææ…Œæ¨¡å¼ï¼šè·³è¿‡Tokenç›´åˆ°åŒæ­¥ç‚¹
        PHRASE_LEVEL,    // çŸ­è¯­çº§ï¼šå±€éƒ¨ä¿®æ­£é”™è¯¯
        ERROR_PRODUCTION, // é”™è¯¯äº§ç”Ÿå¼ï¼šé¢„å®šä¹‰é”™è¯¯æ¨¡å¼
        GLOBAL_CORRECTION // å…¨å±€ä¿®æ­£ï¼šæœ€å°è·ç¦»ä¿®æ­£
    };
    
    // ææ…Œæ¨¡å¼æ¢å¤
    void panicModeRecovery(std::vector<Token>& tokens, size_t& current) {
        // è·³è¿‡Tokenç›´åˆ°æ‰¾åˆ°åŒæ­¥ç‚¹
        std::set<TokenType> syncTokens = {
            SEMICOLON, SELECT_TOKEN, FROM_TOKEN, WHERE_TOKEN
        };
        
        while (current < tokens.size() && 
               syncTokens.find(tokens[current].type) == syncTokens.end()) {
            current++;
        }
    }
    
    // çŸ­è¯­çº§æ¢å¤
    bool phraseLevelRecovery(std::vector<Token>& tokens, size_t& current, 
                           TokenType expected) {
        // å¸¸è§é”™è¯¯ä¿®æ­£
        if (expected == FROM_TOKEN && tokens[current].type == FORM_TOKEN) {
            // ä¿®æ­£æ‹¼å†™é”™è¯¯ï¼šFORM -> FROM
            tokens[current].type = FROM_TOKEN;
            return true;
        }
        
        if (expected == SEMICOLON && current == tokens.size()) {
            // ç¼ºå°‘åˆ†å·ï¼Œæ’å…¥åˆ†å·
            tokens.push_back(Token{SEMICOLON, ";"});
            return true;
        }
        
        return false;
    }
};
```

### 7.2 è§£æé”™è¯¯è¯Šæ–­æ–¹æ³•

**ğŸ”¸ é”™è¯¯ä¿¡æ¯ç”Ÿæˆ**
```cpp
class ParseError {
public:
    struct ErrorInfo {
        size_t line;
        size_t column;
        std::string message;
        std::string suggestion;
        ErrorType type;
    };
    
    // ç”Ÿæˆè¯¦ç»†é”™è¯¯ä¿¡æ¯
    static ErrorInfo generateError(const std::vector<Token>& tokens, 
                                 size_t errorPosition,
                                 const std::string& expected) {
        ErrorInfo error;
        error.line = tokens[errorPosition].line;
        error.column = tokens[errorPosition].column;
        
        // æ„é€ é”™è¯¯æ¶ˆæ¯
        std::ostringstream oss;
        oss << "Syntax error at line " << error.line 
            << ", column " << error.column << ": ";
        oss << "Expected " << expected 
            << ", but found '" << tokens[errorPosition].value << "'";
        
        error.message = oss.str();
        
        // ç”Ÿæˆä¿®æ­£å»ºè®®
        error.suggestion = generateSuggestion(tokens, errorPosition, expected);
        
        return error;
    }
    
    // ç”Ÿæˆä¿®æ­£å»ºè®®
    static std::string generateSuggestion(const std::vector<Token>& tokens,
                                        size_t errorPosition, 
                                        const std::string& expected) {
        // åŸºäºä¸Šä¸‹æ–‡ç”Ÿæˆå»ºè®®
        if (expected == "FROM" && errorPosition > 0 && 
            tokens[errorPosition - 1].type == SELECT_TOKEN) {
            return "Did you mean to add a column list before FROM?";
        }
        
        if (expected == ";" && errorPosition == tokens.size()) {
            return "Statement appears to be incomplete. Add ';' at the end.";
        }
        
        return "Check the SQL syntax near this location.";
    }
};
```

### 7.3 å¸¸è§è§£æé”™è¯¯ç±»å‹

```cpp
// é”™è¯¯åˆ†ç±»
enum class ParseErrorType {
    SYNTAX_ERROR,        // è¯­æ³•é”™è¯¯
    LEXICAL_ERROR,       // è¯æ³•é”™è¯¯  
    SEMANTIC_ERROR,      // è¯­ä¹‰é”™è¯¯
    MISSING_TOKEN,       // ç¼ºå°‘Token
    UNEXPECTED_TOKEN,    // æ„å¤–Token
    INCOMPLETE_STATEMENT // ä¸å®Œæ•´è¯­å¥
};

// å¸¸è§é”™è¯¯å¤„ç†
class CommonErrors {
public:
    // å¤„ç†ç¼ºå°‘åˆ†å·é”™è¯¯
    static void handleMissingSemicolon(Parser& parser) {
        parser.reportError("Missing semicolon at end of statement");
        parser.insertToken(Token{SEMICOLON, ";"});
    }
    
    // å¤„ç†å…³é”®å­—æ‹¼å†™é”™è¯¯
    static bool handleKeywordSpelling(Token& token) {
        static std::map<std::string, std::string> corrections = {
            {"SELCT", "SELECT"},
            {"FORM", "FROM"},
            {"WEHRE", "WHERE"},
            {"GROPU", "GROUP"},
            {"ORDR", "ORDER"}
        };
        
        auto it = corrections.find(token.value);
        if (it != corrections.end()) {
            token.value = it->second;
            return true;
        }
        return false;
    }
    
    // å¤„ç†æ‹¬å·ä¸åŒ¹é…
    static void checkParenthesesBalance(const std::vector<Token>& tokens) {
        int balance = 0;
        for (const auto& token : tokens) {
            if (token.type == LEFT_PAREN) balance++;
            else if (token.type == RIGHT_PAREN) balance--;
            
            if (balance < 0) {
                throw ParseError("Unmatched closing parenthesis");
            }
        }
        
        if (balance > 0) {
            throw ParseError("Unmatched opening parenthesis");
        }
    }
};
```

---

## 8. âš¡ è§£æå™¨æ€§èƒ½ä¼˜åŒ–


### 8.1 è§£ææ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**ğŸ”¸ Tokené¢„å¤„ç†ä¼˜åŒ–**
```cpp
class TokenPreprocessor {
public:
    // Tokené¢„å¤„ç†ï¼šç§»é™¤ä¸å¿…è¦çš„ç©ºç™½å’Œæ³¨é‡Š
    static std::vector<Token> preprocess(const std::vector<Token>& rawTokens) {
        std::vector<Token> processed;
        processed.reserve(rawTokens.size()); // é¢„åˆ†é…ç©ºé—´
        
        for (const auto& token : rawTokens) {
            switch (token.type) {
                case WHITESPACE:
                case COMMENT:
                    // è·³è¿‡ç©ºç™½å’Œæ³¨é‡Š
                    break;
                default:
                    processed.push_back(token);
                    break;
            }
        }
        
        // é¢„å¤„ç†å…³é”®å­—å¤§å°å†™ç»Ÿä¸€
        for (auto& token : processed) {
            if (isKeyword(token.value)) {
                std::transform(token.value.begin(), token.value.end(),
                             token.value.begin(), ::toupper);
            }
        }
        
        return processed;
    }
    
    // å…³é”®å­—è¯†åˆ«ä¼˜åŒ–ï¼šä½¿ç”¨å“ˆå¸Œè¡¨
    static bool isKeyword(const std::string& word) {
        static std::unordered_set<std::string> keywords = {
            "SELECT", "FROM", "WHERE", "INSERT", "UPDATE", "DELETE",
            "JOIN", "LEFT", "RIGHT", "INNER", "OUTER", "ON", "AS",
            "GROUP", "BY", "ORDER", "HAVING", "UNION", "ALL", "DISTINCT"
        };
        
        std::string upperWord = word;
        std::transform(upperWord.begin(), upperWord.end(), 
                      upperWord.begin(), ::toupper);
        
        return keywords.find(upperWord) != keywords.end();
    }
};
```

### 8.2 å†…å­˜ä½¿ç”¨ä¼˜åŒ–

**ğŸ”¸ å¯¹è±¡æ± æŠ€æœ¯**
```cpp
template<typename T>
class ObjectPool {
private:
    std::vector<std::unique_ptr<T>> pool;
    std::stack<T*> available;
    
public:
    // è·å–å¯¹è±¡
    T* acquire() {
        if (available.empty()) {
            // æ± ä¸­æ²¡æœ‰å¯ç”¨å¯¹è±¡ï¼Œåˆ›å»ºæ–°çš„
            auto obj = std::make_unique<T>();
            T* ptr = obj.get();
            pool.push_back(std::move(obj));
            return ptr;
        } else {
            // ä»æ± ä¸­è·å–
            T* obj = available.top();
            available.pop();
            return obj;
        }
    }
    
    // å½’è¿˜å¯¹è±¡
    void release(T* obj) {
        if (obj) {
            obj->reset(); // é‡ç½®å¯¹è±¡çŠ¶æ€
            available.push(obj);
        }
    }
    
    // é¢„åˆ†é…å¯¹è±¡
    void preallocate(size_t count) {
        for (size_t i = 0; i < count; ++i) {
            auto obj = std::make_unique<T>();
            T* ptr = obj.get();
            pool.push_back(std::move(obj));
            available.push(ptr);
        }
    }
};

// ASTèŠ‚ç‚¹æ± åŒ–
class OptimizedParser {
private:
    ObjectPool<SelectStmt> selectStmtPool;
    ObjectPool<ColumnRef> columnRefPool;
    ObjectPool<TableRef> tableRefPool;
    
public:
    OptimizedParser() {
        // é¢„åˆ†é…å¸¸ç”¨èŠ‚ç‚¹
        selectStmtPool.preallocate(100);
        columnRefPool.preallocate(500);
        tableRefPool.preallocate(200);
    }
    
    SelectStmt* createSelectStmt() {
        return selectStmtPool.acquire();
    }
    
    void releaseSelectStmt(SelectStmt* stmt) {
        selectStmtPool.release(stmt);
    }
};
```

### 8.3 è§£æç®—æ³•ä¼˜åŒ–

**ğŸ”¸ è¡¨é©±åŠ¨è§£æ**
```cpp
// è§£æè¡¨é©±åŠ¨æ–¹æ³•
class TableDrivenParser {
private:
    // è§£æè¡¨ï¼š[å½“å‰çŠ¶æ€][è¾“å…¥ç¬¦å·] = åŠ¨ä½œ
    enum class Action { SHIFT, REDUCE, ACCEPT, ERROR };
    
    struct ActionEntry {
        Action action;
        int nextState;
        int ruleIndex;
    };
    
    // è§£æè¡¨ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    static const ActionEntry parseTable[10][20];
    
    std::stack<int> stateStack;
    std::stack<ASTNode*> nodeStack;
    
public:
    ASTNode* parse(const std::vector<Token>& tokens) {
        stateStack.push(0); // åˆå§‹çŠ¶æ€
        size_t tokenIndex = 0;
        
        while (true) {
            int currentState = stateStack.top();
            TokenType currentToken = tokens[tokenIndex].type;
            
            ActionEntry entry = parseTable[currentState][currentToken];
            
            switch (entry.action) {
                case Action::SHIFT:
                    stateStack.push(entry.nextState);
                    tokenIndex++;
                    break;
                    
                case Action::REDUCE:
                    // æ ¹æ®è§„åˆ™è¿›è¡Œå½’çº¦
                    reduceByRule(entry.ruleIndex);
                    break;
                    
                case Action::ACCEPT:
                    return nodeStack.top();
                    
                case Action::ERROR:
                    handleError(tokens, tokenIndex);
                    break;
            }
        }
    }
    
private:
    void reduceByRule(int ruleIndex) {
        // æ ¹æ®è¯­æ³•è§„åˆ™è¿›è¡Œå½’çº¦
        // ä¾‹å¦‚ï¼šrule 1: select_stmt -> SELECT select_list FROM table_list
        switch (ruleIndex) {
            case 1: {
                // å¼¹å‡º4ä¸ªçŠ¶æ€ï¼ˆSELECT, select_list, FROM, table_listï¼‰
                for (int i = 0; i < 4; i++) stateStack.pop();
                
                // ä»èŠ‚ç‚¹æ ˆè·å–å­èŠ‚ç‚¹
                auto tableList = nodeStack.top(); nodeStack.pop();
                nodeStack.pop(); // FROM
                auto selectList = nodeStack.top(); nodeStack.pop();
                nodeStack.pop(); // SELECT
                
                // åˆ›å»ºæ–°çš„select_stmtèŠ‚ç‚¹
                auto stmt = new SelectStmt();
                stmt->selectList = static_cast<SelectList*>(selectList);
                stmt->fromList = static_cast<TableList*>(tableList);
                
                nodeStack.push(stmt);
                
                // æŸ¥æ‰¾gotoè¡¨ï¼Œç¡®å®šä¸‹ä¸€çŠ¶æ€
                int gotoState = gotoTable[stateStack.top()][SELECT_STMT];
                stateStack.push(gotoState);
                break;
            }
            // å…¶ä»–è§„åˆ™...
        }
    }
};
```

---

## 9. ğŸ”§ SQLæ–¹è¨€ä¸æ‰©å±•


### 9.1 SQLæ–¹è¨€æ”¯æŒ

**ä¸åŒæ•°æ®åº“çš„SQLæ–¹è¨€å·®å¼‚**éœ€è¦è§£æå™¨èƒ½å¤Ÿé€‚é…å¤šç§è¯­æ³•è§„åˆ™ã€‚

```cpp
// SQLæ–¹è¨€æšä¸¾
enum class SQLDialect {
    STANDARD_SQL,    // æ ‡å‡†SQL
    MYSQL,           // MySQLæ–¹è¨€
    POSTGRESQL,      // PostgreSQLæ–¹è¨€
    ORACLE,          // Oracleæ–¹è¨€
    SQL_SERVER       // SQL Serveræ–¹è¨€
};

// æ–¹è¨€ç‰¹å®šçš„è§£æå™¨
class DialectParser {
private:
    SQLDialect dialect;
    
public:
    DialectParser(SQLDialect d) : dialect(d) {}
    
    // æ ¹æ®æ–¹è¨€è§£æLIMITå­å¥
    LimitClause* parseLimitClause() {
        switch (dialect) {
            case SQLDialect::MYSQL:
                return parseMySQLLimit(); // LIMIT offset, count
                
            case SQLDialect::POSTGRESQL:
                return parsePostgreSQLLimit(); // LIMIT count OFFSET offset
                
            case SQLDialect::SQL_SERVER:
                return parseSQLServerLimit(); // TOP(count) æˆ– OFFSET/FETCH
                
            case SQLDialect::ORACLE:
                return parseOracleLimit(); // ROWNUM æˆ– OFFSET/FETCH
                
            default:
                return parseStandardLimit();
        }
    }
    
    // MySQLæ–¹è¨€çš„LIMITè§£æ
    LimitClause* parseMySQLLimit() {
        if (!match(LIMIT_TOKEN)) return nullptr;
        
        auto limit = new LimitClause();
        
        // è§£æç¬¬ä¸€ä¸ªæ•°å­—
        limit->count = parseNumber();
        
        // æ£€æŸ¥æ˜¯å¦æœ‰åç§»é‡
        if (match(COMMA_TOKEN)) {
            // MySQLæ ¼å¼ï¼šLIMIT offset, count
            limit->offset = limit->count;
            limit->count = parseNumber();
        }
        
        return limit;
    }
    
    // PostgreSQLæ–¹è¨€çš„LIMITè§£æ  
    LimitClause* parsePostgreSQLLimit() {
        auto limit = new LimitClause();
        
        if (match(LIMIT_TOKEN)) {
            if (match(ALL_TOKEN)) {
                limit->count = -1; // è¡¨ç¤ºæ— é™åˆ¶
            } else {
                limit->count = parseNumber();
            }
        }
        
        if (match(OFFSET_TOKEN)) {
            limit->offset = parseNumber();
            // PostgreSQLæ”¯æŒ OFFSET n ROWS
            if (match(ROWS_TOKEN) || match(ROW_TOKEN)) {
                // å¯é€‰çš„ROWSå…³é”®å­—
            }
        }
        
        return limit;
    }
};
```

### 9.2 SQLè¯­æ³•æ‰©å±•æœºåˆ¶

**ğŸ”¸ æ‰©å±•è¯­æ³•æ”¯æŒ**
```cpp
// è¯­æ³•æ‰©å±•æ¥å£
class SyntaxExtension {
public:
    virtual ~SyntaxExtension() = default;
    virtual bool canHandle(const std::vector<Token>& tokens, size_t pos) = 0;
    virtual ASTNode* parse(Parser& parser) = 0;
    virtual std::string getName() const = 0;
};

// JSONå‡½æ•°æ‰©å±•ï¼ˆMySQL JSONå‡½æ•°ï¼‰
class JSONFunctionExtension : public SyntaxExtension {
public:
    bool canHandle(const std::vector<Token>& tokens, size_t pos) override {
        if (pos >= tokens.size()) return false;
        
        const std::string& tokenValue = tokens[pos].value;
        return tokenValue == "JSON_EXTRACT" || 
               tokenValue == "JSON_CONTAINS" ||
               tokenValue == "JSON_ARRAY" ||
               tokenValue == "JSON_OBJECT";
    }
    
    ASTNode* parse(Parser& parser) override {
        std::string functionName = parser.getCurrentToken().value;
        parser.consumeToken();
        
        auto func = new FunctionCall();
        func->name = functionName;
        
        // è§£æå‡½æ•°å‚æ•°
        parser.expect(LEFT_PAREN);
        
        if (!parser.check(RIGHT_PAREN)) {
            do {
                func->arguments.push_back(parser.parseExpression());
            } while (parser.match(COMMA_TOKEN));
        }
        
        parser.expect(RIGHT_PAREN);
        
        return func;
    }
    
    std::string getName() const override {
        return "JSON Functions";
    }
};

// æ‰©å±•ç®¡ç†å™¨
class ExtensionManager {
private:
    std::vector<std::unique_ptr<SyntaxExtension>> extensions;
    
public:
    void registerExtension(std::unique_ptr<SyntaxExtension> ext) {
        extensions.push_back(std::move(ext));
    }
    
    ASTNode* tryParseExtension(Parser& parser, const std::vector<Token>& tokens, size_t pos) {
        for (auto& ext : extensions) {
            if (ext->canHandle(tokens, pos)) {
                return ext->parse(parser);
            }
        }
        return nullptr;
    }
};
```

### 9.3 è‡ªå®šä¹‰è¯­æ³•è§„åˆ™

**ğŸ”¸ åŠ¨æ€è¯­æ³•è§„åˆ™æ·»åŠ **
```cpp
// è¯­æ³•è§„åˆ™å®šä¹‰
struct GrammarRule {
    std::string name;                    // è§„åˆ™åç§°
    std::vector<std::string> symbols;    // ç¬¦å·åºåˆ—
    std::function<ASTNode*(const std::vector<ASTNode*>&)> action; // åŠ¨ä½œå‡½æ•°
};

// åŠ¨æ€è¯­æ³•ç®¡ç†å™¨
class DynamicGrammar {
private:
    std::map<std::string, std::vector<GrammarRule>> rules;
    
public:
    // æ·»åŠ è¯­æ³•è§„åˆ™
    void addRule(const std::string& nonTerminal, const GrammarRule& rule) {
        rules[nonTerminal].push_back(rule);
    }
    
    // ç¤ºä¾‹ï¼šæ·»åŠ MERGEè¯­å¥æ”¯æŒ
    void setupMergeStatement() {
        GrammarRule mergeRule;
        mergeRule.name = "merge_stmt";
        mergeRule.symbols = {"MERGE", "INTO", "table_name", "USING", "table_ref", 
                           "ON", "condition", "merge_clauses"};
        
        mergeRule.action = [](const std::vector<ASTNode*>& children) -> ASTNode* {
            auto stmt = new MergeStmt();
            stmt->targetTable = static_cast<TableRef*>(children[2]);
            stmt->sourceTable = static_cast<TableRef*>(children[4]);
            stmt->joinCondition = static_cast<ExprNode*>(children[6]);
            stmt->clauses = static_cast<MergeClauses*>(children[7]);
            return stmt;
        };
        
        addRule("statement", mergeRule);
    }
    
    // æŸ¥æ‰¾åŒ¹é…çš„è§„åˆ™
    const GrammarRule* findRule(const std::string& nonTerminal, 
                               const std::vector<TokenType>& tokenSequence) {
        auto it = rules.find(nonTerminal);
        if (it == rules.end()) return nullptr;
        
        for (const auto& rule : it->second) {
            if (matchesRule(rule, tokenSequence)) {
                return &rule;
            }
        }
        
        return nullptr;
    }
    
private:
    bool matchesRule(const GrammarRule& rule, const std::vector<TokenType>& tokens) {
        // æ£€æŸ¥è§„åˆ™æ˜¯å¦åŒ¹é…å½“å‰Tokenåºåˆ—
        // ç®€åŒ–å®ç°ï¼Œå®é™…ä¼šæ›´å¤æ‚
        return rule.symbols.size() == tokens.size();
    }
};
```

---

## 10. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 10.1 å¿…é¡»æŒæ¡çš„åŸºæœ¬æ¦‚å¿µ

```
ğŸ”¸ SQLè§£æå™¨ä½œç”¨ï¼šæŠŠäººç±»å¯è¯»çš„SQLè½¬æ¢æˆæ•°æ®åº“å†…éƒ¨ç»“æ„
ğŸ”¸ ä¸¤é˜¶æ®µè§£æï¼šè¯æ³•åˆ†æï¼ˆå­—ç¬¦â†’Tokenï¼‰+ è¯­æ³•åˆ†æï¼ˆTokenâ†’ASTï¼‰
ğŸ”¸ ASTæŠ½è±¡è¯­æ³•æ ‘ï¼šå»æ‰è¯­æ³•ç»†èŠ‚ï¼Œä¿ç•™è¯­ä¹‰ç»“æ„çš„æ ‘å½¢è¡¨ç¤º
ğŸ”¸ ç¬¦å·è¡¨ç®¡ç†ï¼šè®°å½•æ ‡è¯†ç¬¦ï¼ˆè¡¨åã€åˆ—åï¼‰çš„å®šä¹‰å’Œå±æ€§ä¿¡æ¯
ğŸ”¸ é”™è¯¯æ¢å¤æœºåˆ¶ï¼šé‡åˆ°é”™è¯¯æ—¶ç»§ç»­è§£æï¼Œå‘ç°æ›´å¤šé—®é¢˜
```

### 10.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ è¯æ³•åˆ†ævsè¯­æ³•åˆ†æçš„åŒºåˆ«**
```
è¯æ³•åˆ†æï¼ˆLexicalï¼‰ï¼š
- è¾“å…¥ï¼šå­—ç¬¦ä¸² "SELECT name FROM users"
- è¾“å‡ºï¼šTokenåºåˆ— [SELECT, name, FROM, users]  
- ä½œç”¨ï¼šè¯†åˆ«å•è¯è¾¹ç•Œï¼Œåˆ†ç±»Tokenç±»å‹

è¯­æ³•åˆ†æï¼ˆSyntaxï¼‰ï¼š
- è¾“å…¥ï¼šTokenåºåˆ—
- è¾“å‡ºï¼šASTè¯­æ³•æ ‘
- ä½œç”¨ï¼šæ£€æŸ¥è¯­æ³•è§„åˆ™ï¼Œæ„å»ºç»“æ„åŒ–è¡¨ç¤º

è®°å¿†æ–¹æ³•ï¼šè¯æ³•=è¯†åˆ«å•è¯ï¼Œè¯­æ³•=æ£€æŸ¥å¥æ³•
```

**ğŸ”¹ ASTä¸ºä»€ä¹ˆé‡è¦**
```
ASTçš„ä»·å€¼ï¼š
- æ ‡å‡†åŒ–è¡¨ç¤ºï¼šä¸åŒSQLè¯­æ³•å¯¹åº”ç›¸åŒASTç»“æ„
- ä¾¿äºå¤„ç†ï¼šæ ‘ç»“æ„ä¾¿äºéå†å’Œè½¬æ¢
- è¯­ä¹‰ä¿ç•™ï¼šå»æ‰è¯­æ³•å™ªéŸ³ï¼Œä¿ç•™æ ¸å¿ƒå«ä¹‰
- ä¼˜åŒ–åŸºç¡€ï¼šä¸ºæŸ¥è¯¢ä¼˜åŒ–æä¾›æ ‡å‡†è¾“å…¥

å®é™…åº”ç”¨ï¼š
- æŸ¥è¯¢ä¼˜åŒ–å™¨åŸºäºASTè¿›è¡Œä¼˜åŒ–
- SQLæ ¼å¼åŒ–å·¥å…·éå†ASTé‡æ–°ç”ŸæˆSQL
- æƒé™æ£€æŸ¥é€šè¿‡ASTåˆ†æè®¿é—®çš„è¡¨å’Œåˆ—
```

**ğŸ”¹ è§£æå™¨æ€§èƒ½ä¼˜åŒ–çš„é‡ç‚¹**
```
æ€§èƒ½ç“¶é¢ˆï¼š
- å†…å­˜åˆ†é…ï¼šé¢‘ç¹åˆ›å»º/é”€æ¯ASTèŠ‚ç‚¹
- å­—ç¬¦ä¸²å¤„ç†ï¼šTokenè¯†åˆ«å’Œæ¯”è¾ƒ
- é€’å½’è°ƒç”¨ï¼šæ·±å±‚åµŒå¥—çš„è¯­æ³•åˆ†æ

ä¼˜åŒ–ç­–ç•¥ï¼š
- å¯¹è±¡æ± ï¼šé‡ç”¨ASTèŠ‚ç‚¹å¯¹è±¡
- è§£æç¼“å­˜ï¼šç¼“å­˜å¸¸ç”¨SQLçš„AST
- è¡¨é©±åŠ¨ï¼šç”¨æŸ¥è¡¨æ›¿ä»£é€’å½’è°ƒç”¨
- é¢„å¤„ç†ï¼šæå‰è¿‡æ»¤æ— ç”¨Token
```

### 10.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ”¸ è§£æå™¨ä½¿ç”¨åœºæ™¯**
```
å¸¸è§åº”ç”¨ï¼š
âœ… æ•°æ®åº“ç³»ç»Ÿï¼šSQLè¯­å¥è§£æå’Œæ‰§è¡Œ
âœ… ORMæ¡†æ¶ï¼šåŠ¨æ€SQLç”Ÿæˆå’Œè§£æ
âœ… SQLå·¥å…·ï¼šæ ¼å¼åŒ–ã€è¯­æ³•æ£€æŸ¥ã€è¿ç§»
âœ… æ•°æ®åˆ†æï¼šSQLæ—¥å¿—è§£æå’Œåˆ†æ
âœ… å®‰å…¨å®¡è®¡ï¼šSQLæ³¨å…¥æ£€æµ‹å’Œé˜²æŠ¤

é€‰æ‹©è€ƒè™‘ï¼š
- æ€§èƒ½è¦æ±‚ï¼šé«˜æ€§èƒ½ç”¨C++ï¼Œä¸€èˆ¬ç”¨Java/Python
- æ–¹è¨€æ”¯æŒï¼šéœ€è¦æ”¯æŒå“ªäº›æ•°æ®åº“æ–¹è¨€
- æ‰©å±•æ€§ï¼šæ˜¯å¦éœ€è¦è‡ªå®šä¹‰è¯­æ³•æ‰©å±•
- é”™è¯¯å¤„ç†ï¼šæ˜¯å¦éœ€è¦è¯¦ç»†çš„é”™è¯¯è¯Šæ–­
```

**ğŸ”¸ è§£æå™¨é”™è¯¯å¤„ç†æœ€ä½³å®è·µ**
```
é”™è¯¯è¯Šæ–­è¦ç‚¹ï¼š
âœ… æä¾›å‡†ç¡®çš„é”™è¯¯ä½ç½®ï¼ˆè¡Œå·ã€åˆ—å·ï¼‰
âœ… ç»™å‡ºå…·ä½“çš„é”™è¯¯åŸå› å’ŒæœŸæœ›å†…å®¹
âœ… æä¾›ä¿®æ­£å»ºè®®ï¼Œå¸®åŠ©ç”¨æˆ·æ”¹æ­£
âœ… æ”¯æŒå¤šé”™è¯¯æŠ¥å‘Šï¼Œä¸è¦é‡åˆ°ç¬¬ä¸€ä¸ªé”™è¯¯å°±åœæ­¢

é”™è¯¯æ¢å¤ç­–ç•¥ï¼š
âœ… ææ…Œæ¨¡å¼ï¼šè·³è¿‡Tokenåˆ°åŒæ­¥ç‚¹
âœ… çŸ­è¯­çº§ä¿®æ­£ï¼šå±€éƒ¨çº æ­£å¸¸è§é”™è¯¯
âœ… é”™è¯¯äº§ç”Ÿå¼ï¼šé¢„å®šä¹‰å¸¸è§é”™è¯¯æ¨¡å¼
âœ… è¯­ä¹‰å¼•å¯¼ï¼šåŸºäºä¸Šä¸‹æ–‡æä¾›æ™ºèƒ½å»ºè®®
```

**ğŸ”¸ æ–°æ‰‹å­¦ä¹ å»ºè®®**
```
å­¦ä¹ è·¯å¾„ï¼š
1. å…ˆç†è§£ç¼–è¯‘åŸç†åŸºç¡€ï¼ˆè¯æ³•ã€è¯­æ³•åˆ†æï¼‰
2. æŒæ¡ASTçš„æ¦‚å¿µå’Œéå†æ–¹æ³•
3. å­¦ä¹ é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
4. äº†è§£æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
5. å®è·µé¡¹ç›®ï¼šå®ç°ç®€å•SQLè§£æå™¨

å®è·µè¦ç‚¹ï¼š
- ä»ç®€å•çš„SELECTè¯­å¥å¼€å§‹
- ä½¿ç”¨ç°æœ‰çš„è§£æå™¨å·¥å…·ï¼ˆANTLRã€yacc/lexï¼‰
- é‡ç‚¹å…³æ³¨ASTè®¾è®¡å’Œé”™è¯¯å¤„ç†
- é€æ­¥æ‰©å±•æ”¯æŒçš„SQLè¯­æ³•
```

**æ ¸å¿ƒè®°å¿†å£è¯€**ï¼š
```
è¯æ³•è¯­æ³•ä¸¤é˜¶æ®µï¼ŒTokenè¯­æ³•æ ‘ç”Ÿæˆ
ç¬¦å·è¡¨é‡Œå­˜å®šä¹‰ï¼Œé”™è¯¯æ¢å¤ä¿ç¨³å®š
ASTç»“æ„æ˜¯å…³é”®ï¼Œéå†æ¨¡å¼è¦ç†Ÿç»ƒ
æ–¹è¨€æ‰©å±•å¢çµæ´»ï¼Œç¼“å­˜ä¼˜åŒ–ææ€§èƒ½
è§£æå™¨æ˜¯æ•°æ®åº“ï¼Œç†è§£SQLç¬¬ä¸€å…³
```