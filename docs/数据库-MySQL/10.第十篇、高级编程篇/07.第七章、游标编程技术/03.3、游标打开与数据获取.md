---
title: 3、游标打开与数据获取
---
## 📚 目录

1. [游标操作基础概念](#1-游标操作基础概念)
2. [OPEN游标操作详解](#2-OPEN游标操作详解)
3. [FETCH数据获取机制](#3-FETCH数据获取机制)
4. [游标记录遍历技术](#4-游标记录遍历技术)
5. [游标状态检查与处理](#5-游标状态检查与处理)
6. [游标位置管理](#6-游标位置管理)
7. [批量FETCH优化技巧](#7-批量FETCH优化技巧)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 游标操作基础概念


### 1.1 什么是游标操作


**游标操作**：就像是操作一个指向数据库记录的"指针"，可以逐行处理查询结果

```
传统查询 vs 游标操作：

传统查询：
SELECT * FROM users WHERE age > 25;
↓
一次性返回所有结果（可能很多行）

游标操作：
声明游标 → 打开游标 → 逐行获取 → 关闭游标
↓
像翻书一样，一页一页地处理数据
```

**为什么需要游标**：
- **内存控制**：处理大量数据时不会占用过多内存
- **逐行处理**：可以对每条记录进行复杂的业务逻辑处理
- **流式处理**：边读边处理，适合数据量大的场景

### 1.2 游标操作的完整流程


```
游标生命周期：
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ DECLARE  │───→│   OPEN   │───→│  FETCH   │───→│  CLOSE   │
│  声明游标  │    │  打开游标  │    │  获取数据  │    │  关闭游标  │
└──────────┘    └──────────┘    └──────────┘    └──────────┘
                                      ↑________________↓
                                         循环获取数据
```

**基本操作序列**：
1. **DECLARE**：定义游标和查询语句
2. **OPEN**：执行查询，准备数据
3. **FETCH**：逐行获取数据（可重复）
4. **CLOSE**：释放游标资源

---

## 2. 🔓 OPEN游标操作详解


### 2.1 OPEN操作的作用


**OPEN操作**：启动游标，执行关联的SELECT查询，将结果集准备好供FETCH使用

```sql
-- 基本的OPEN语法
DECLARE cursor_name CURSOR FOR SELECT_statement;
OPEN cursor_name;
```

**OPEN做了什么**：
- **执行查询**：运行DECLARE时定义的SELECT语句
- **建立结果集**：将查询结果存储在内存中
- **定位指针**：将游标指针定位到第一行之前
- **准备读取**：为后续的FETCH操作做准备

### 2.2 OPEN操作实例


```sql
-- 实际应用示例：处理员工薪资调整
DELIMITER $$
CREATE PROCEDURE adjust_salary()
BEGIN
    -- 声明变量存储获取的数据
    DECLARE emp_id INT;
    DECLARE emp_name VARCHAR(50);
    DECLARE current_salary DECIMAL(10,2);
    DECLARE done INT DEFAULT FALSE;
    
    -- 声明游标：查询所有员工信息
    DECLARE emp_cursor CURSOR FOR 
        SELECT id, name, salary FROM employees WHERE status = 'active';
    
    -- 声明异常处理
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 打开游标（关键操作）
    OPEN emp_cursor;
    
    -- 后续的FETCH操作...
    
END$$
DELIMITER ;
```

### 2.3 OPEN操作注意事项


> 💡 **重要理解**：OPEN是启动游标的"开关"，不OPEN就无法FETCH数据

> ⚠️ **常见错误**：忘记OPEN游标就直接FETCH，会导致错误

```sql
-- 错误示例
DECLARE my_cursor CURSOR FOR SELECT * FROM users;
-- 忘记OPEN操作
FETCH my_cursor INTO @id, @name;  -- 这会报错！

-- 正确示例  
DECLARE my_cursor CURSOR FOR SELECT * FROM users;
OPEN my_cursor;  -- 必须先打开
FETCH my_cursor INTO @id, @name;  -- 现在可以正常获取
```

---

## 3. 📤 FETCH数据获取机制


### 3.1 FETCH操作原理


**FETCH操作**：从游标指向的结果集中获取一行数据，并将游标指针移动到下一行

```
FETCH工作原理：
┌─────────────────┐
│   结果集数据     │
├─────────────────┤
│ Row 1 ←cursor   │  ← FETCH获取这一行，指针下移
│ Row 2           │
│ Row 3           │
│ ...             │
└─────────────────┘

FETCH后：
┌─────────────────┐
│   结果集数据     │
├─────────────────┤
│ Row 1           │
│ Row 2 ←cursor   │  ← 指针移动到下一行
│ Row 3           │
│ ...             │
└─────────────────┘
```

### 3.2 FETCH基本语法


```sql
-- 基本FETCH语法
FETCH cursor_name INTO variable_list;

-- 实际示例
FETCH emp_cursor INTO emp_id, emp_name, current_salary;
```

**FETCH的数据流向**：
- **FROM**：从游标指向的当前行
- **INTO**：存储到指定的变量中
- **类型匹配**：变量类型必须与查询字段类型匹配

### 3.3 FETCH完整应用示例


```sql
-- 完整的员工信息处理示例
DELIMITER $$
CREATE PROCEDURE process_employees()
BEGIN
    -- 声明接收数据的变量
    DECLARE v_emp_id INT;
    DECLARE v_emp_name VARCHAR(50);
    DECLARE v_salary DECIMAL(10,2);
    DECLARE v_done INT DEFAULT FALSE;
    
    -- 声明游标
    DECLARE emp_cursor CURSOR FOR 
        SELECT emp_id, emp_name, salary 
        FROM employees 
        WHERE department = 'Sales';
    
    -- 声明结束处理器
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    -- 打开游标
    OPEN emp_cursor;
    
    -- 开始数据获取循环
    read_loop: LOOP
        -- 获取一行数据
        FETCH emp_cursor INTO v_emp_id, v_emp_name, v_salary;
        
        -- 检查是否到达结尾
        IF v_done THEN
            LEAVE read_loop;
        END IF;
        
        -- 处理当前行数据
        INSERT INTO salary_log(emp_id, emp_name, old_salary, process_date)
        VALUES(v_emp_id, v_emp_name, v_salary, NOW());
        
    END LOOP;
    
    -- 关闭游标
    CLOSE emp_cursor;
END$$
DELIMITER ;
```

---

## 4. 🔄 游标记录遍历技术


### 4.1 游标遍历的基本模式


**游标遍历**：通过循环结构重复执行FETCH操作，直到处理完所有记录

```
遍历模式对比：

WHILE循环模式：               LOOP循环模式：
┌─────────────┐              ┌─────────────┐
│ WHILE条件   │              │ LOOP开始    │
├─────────────┤              ├─────────────┤
│ FETCH数据   │              │ FETCH数据   │
│ 处理数据    │              │ IF结束条件  │
│ 检查状态    │              │ 处理数据    │
└─────────────┘              └─────────────┘
```

### 4.2 WHILE循环遍历方式


```sql
-- WHILE循环遍历示例
DELIMITER $$
CREATE PROCEDURE while_cursor_demo()
BEGIN
    DECLARE v_id INT;
    DECLARE v_name VARCHAR(50);
    DECLARE v_done INT DEFAULT FALSE;
    
    DECLARE user_cursor CURSOR FOR SELECT id, name FROM users;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    OPEN user_cursor;
    
    -- WHILE循环方式
    WHILE NOT v_done DO
        FETCH user_cursor INTO v_id, v_name;
        
        -- 避免处理最后的空记录
        IF NOT v_done THEN
            -- 处理数据
            SELECT CONCAT('Processing: ', v_name) AS message;
        END IF;
    END WHILE;
    
    CLOSE user_cursor;
END$$
DELIMITER ;
```

### 4.3 LOOP循环遍历方式


```sql
-- LOOP循环遍历示例（推荐方式）
DELIMITER $$
CREATE PROCEDURE loop_cursor_demo()
BEGIN
    DECLARE v_id INT;
    DECLARE v_name VARCHAR(50);
    DECLARE v_done INT DEFAULT FALSE;
    
    DECLARE user_cursor CURSOR FOR SELECT id, name FROM users;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    OPEN user_cursor;
    
    -- LOOP循环方式（更清晰）
    cursor_loop: LOOP
        FETCH user_cursor INTO v_id, v_name;
        
        IF v_done THEN
            LEAVE cursor_loop;  -- 退出循环
        END IF;
        
        -- 处理数据（这里不会处理到空记录）
        SELECT CONCAT('Processing: ', v_name) AS message;
        
    END LOOP;
    
    CLOSE user_cursor;
END$$
DELIMITER ;
```

> 💡 **最佳实践**：推荐使用LOOP方式，逻辑更清晰，避免处理空记录

---

## 5. ✅ 游标状态检查与处理


### 5.1 END标识处理机制


**END标识**：当游标读取到结果集末尾时，MySQL会触发NOT FOUND异常

```
游标状态变化：
初始状态：ready → 第一次FETCH：有数据 → 继续FETCH：有数据 → 最后FETCH：触发NOT FOUND
          ↓                    ↓                    ↓                  ↓
        正常读取              正常读取              正常读取           设置结束标志
```

### 5.2 异常处理器配置


```sql
-- 标准的异常处理配置
DECLARE done INT DEFAULT FALSE;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
```

**异常处理器说明**：
- **NOT FOUND**：当FETCH无法获取更多数据时触发
- **CONTINUE**：继续执行后续代码（而不是终止）
- **SET done = TRUE**：设置结束标志变量

### 5.3 多种状态检查方式


```sql
-- 方式1：使用布尔标志（推荐）
DECLARE v_finished INT DEFAULT FALSE;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_finished = TRUE;

-- 方式2：使用ROW_COUNT()检查
DECLARE v_row_count INT;
SELECT FOUND_ROWS() INTO v_row_count;

-- 方式3：使用错误码检查
DECLARE v_error_code INT DEFAULT 0;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_error_code = 1;
```

> ⚠️ **注意事项**：异常处理器必须在游标声明之后、OPEN之前声明

---

## 6. 📍 游标位置管理


### 6.1 游标定位机制


**游标定位**：游标内部维护一个指针，指向当前要读取的记录位置

```
游标指针位置示意：
┌─────────────────┐
│     结果集       │
├─────────────────┤
│ ← start pos     │  初始位置（第一行之前）
│ Row 1           │  第一次FETCH后指向Row 2
│ Row 2           │  第二次FETCH后指向Row 3  
│ Row 3           │  第三次FETCH后指向Row 4
│ ← end pos       │  最后位置（最后一行之后）
└─────────────────┘
```

### 6.2 游标位置特点


**位置移动规则**：
- **单向移动**：MySQL游标只能向前移动，不能后退
- **自动递增**：每次FETCH自动移动到下一行
- **不可重置**：无法重新定位到开头（需要重新OPEN）

```sql
-- 游标位置管理示例
DELIMITER $$
CREATE PROCEDURE cursor_position_demo()
BEGIN
    DECLARE v_id INT;
    DECLARE v_counter INT DEFAULT 0;
    DECLARE v_done INT DEFAULT FALSE;
    
    DECLARE pos_cursor CURSOR FOR SELECT id FROM users LIMIT 5;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    OPEN pos_cursor;
    
    position_loop: LOOP
        FETCH pos_cursor INTO v_id;
        
        IF v_done THEN
            LEAVE position_loop;
        END IF;
        
        SET v_counter = v_counter + 1;
        SELECT v_counter AS position, v_id AS current_id;
        
    END LOOP;
    
    CLOSE pos_cursor;
END$$
DELIMITER ;
```

### 6.3 重新遍历的方法


```sql
-- 需要重新遍历时，必须重新打开游标
DELIMITER $$
CREATE PROCEDURE re_traverse_demo()
BEGIN
    DECLARE v_id INT;
    DECLARE v_done INT DEFAULT FALSE;
    
    DECLARE re_cursor CURSOR FOR SELECT id FROM users;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    -- 第一次遍历
    OPEN re_cursor;
    -- ... FETCH操作 ...
    CLOSE re_cursor;
    
    -- 需要重新遍历时
    SET v_done = FALSE;  -- 重置结束标志
    OPEN re_cursor;      -- 重新打开游标
    -- ... 再次FETCH操作 ...
    CLOSE re_cursor;
    
END$$
DELIMITER ;
```

---

## 7. 🚀 批量FETCH优化技巧


### 7.1 批量获取的概念


**批量FETCH**：虽然MySQL游标不直接支持批量获取，但可以通过技巧实现类似效果

```
单行 vs 批量处理对比：
┌─────────────────┐    ┌─────────────────┐
│   单行处理       │    │   批量处理       │
├─────────────────┤    ├─────────────────┤
│ FETCH一行       │    │ FETCH多行到数组  │
│ 处理一行        │    │ 批量处理多行    │
│ 重复N次         │    │ 减少循环次数    │
└─────────────────┘    └─────────────────┘
```

### 7.2 模拟批量处理


```sql
-- 使用临时表模拟批量处理
DELIMITER $$
CREATE PROCEDURE batch_process_demo()
BEGIN
    DECLARE v_batch_size INT DEFAULT 100;
    DECLARE v_counter INT DEFAULT 0;
    DECLARE v_id INT;
    DECLARE v_name VARCHAR(50);
    DECLARE v_done INT DEFAULT FALSE;
    
    DECLARE batch_cursor CURSOR FOR SELECT id, name FROM users;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    -- 创建临时表存储批次数据
    CREATE TEMPORARY TABLE temp_batch (
        id INT,
        name VARCHAR(50)
    );
    
    OPEN batch_cursor;
    
    batch_loop: LOOP
        -- 清空临时表
        DELETE FROM temp_batch;
        SET v_counter = 0;
        
        -- 收集一批数据
        collect_loop: LOOP
            FETCH batch_cursor INTO v_id, v_name;
            
            IF v_done THEN
                LEAVE collect_loop;
            END IF;
            
            INSERT INTO temp_batch VALUES(v_id, v_name);
            SET v_counter = v_counter + 1;
            
            IF v_counter >= v_batch_size THEN
                LEAVE collect_loop;
            END IF;
            
        END LOOP;
        
        -- 如果没有数据，退出主循环
        IF v_counter = 0 THEN
            LEAVE batch_loop;
        END IF;
        
        -- 批量处理当前批次的数据
        UPDATE users u 
        JOIN temp_batch t ON u.id = t.id 
        SET u.last_processed = NOW();
        
        SELECT CONCAT('Processed batch of ', v_counter, ' records') AS message;
        
    END LOOP;
    
    CLOSE batch_cursor;
    DROP TEMPORARY TABLE temp_batch;
END$$
DELIMITER ;
```

### 7.3 分页式处理优化


```sql
-- 使用LIMIT分页代替游标（适合大数据量）
DELIMITER $$
CREATE PROCEDURE paginate_process()
BEGIN
    DECLARE v_offset INT DEFAULT 0;
    DECLARE v_limit INT DEFAULT 1000;
    DECLARE v_count INT DEFAULT 0;
    
    page_loop: LOOP
        -- 使用分页查询代替游标
        SELECT COUNT(*) INTO v_count 
        FROM (
            SELECT id FROM users 
            WHERE status = 'active' 
            LIMIT v_limit OFFSET v_offset
        ) AS page_data;
        
        -- 如果没有更多数据，退出循环
        IF v_count = 0 THEN
            LEAVE page_loop;
        END IF;
        
        -- 处理当前页面的数据
        UPDATE users 
        SET last_processed = NOW() 
        WHERE id IN (
            SELECT id FROM users 
            WHERE status = 'active' 
            LIMIT v_limit OFFSET v_offset
        );
        
        -- 移动到下一页
        SET v_offset = v_offset + v_limit;
        
    END LOOP;
END$$
DELIMITER ;
```

> 🚀 **性能提示**：对于大数据量处理，分页式处理通常比游标更高效

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的操作序列


```
🔸 标准游标操作流程：
DECLARE → OPEN → FETCH(循环) → CLOSE

🔸 关键操作理解：
- OPEN：启动游标，执行查询，准备数据
- FETCH：获取一行数据，移动指针位置  
- 异常处理：检测数据结束，控制循环退出
- CLOSE：释放游标资源，清理内存
```

### 8.2 核心概念要点


**🔹 游标本质理解**
```
游标 = 数据库结果集的指针 + 逐行访问机制
作用：将大结果集转换为可控的逐行处理模式
优势：内存可控、处理灵活、适合复杂业务逻辑
```

**🔹 OPEN/FETCH协作机制**
```
OPEN职责：
- 执行SELECT查询
- 建立内存结果集
- 初始化游标指针

FETCH职责：  
- 读取当前行数据
- 移动指针到下一行
- 触发结束异常
```

**🔹 遍历控制要点**
```
循环模式选择：推荐LOOP + LEAVE方式
异常处理：必须配置NOT FOUND处理器
状态检查：通过done变量控制循环退出
避免陷阱：防止处理最后的空记录
```

### 8.3 实际应用价值


**🎯 适用场景判断**
- ✅ **大数据量逐行处理**：内存可控的数据处理
- ✅ **复杂业务逻辑**：每行数据需要复杂计算
- ✅ **批量数据迁移**：数据库间的数据同步
- ✅ **报表数据生成**：需要逐行计算的统计报表

**🔧 性能优化建议**
- **小数据量**：直接使用SELECT处理更简单
- **大数据量**：考虑分页查询代替游标
- **批量操作**：使用临时表收集后批量处理
- **内存控制**：合理设置批次大小

### 8.4 常见问题解决


```
❌ 忘记OPEN游标 → 📝 按标准流程：DECLARE → OPEN → FETCH
❌ 处理空记录   → 📝 在FETCH后立即检查done状态
❌ 游标未关闭   → 📝 确保在END前执行CLOSE操作
❌ 异常处理错误 → 📝 异常处理器必须在OPEN之前声明
```

**核心记忆要点**：
- 游标操作如翻书，一页一页往下读
- OPEN启动FETCH获取，CLOSE释放要记住
- 循环遍历配异常，done标志控退出
- 指针单向不回头，重读需要重新开