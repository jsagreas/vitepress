---
title: 2、游标声明与基础语法
---
## 📚 目录

1. [游标基本概念](#1-游标基本概念)
2. [游标声明语法详解](#2-游标声明语法详解)
3. [游标操作流程](#3-游标操作流程)
4. [游标属性与控制](#4-游标属性与控制)
5. [游标实战应用](#5-游标实战应用)
6. [游标性能优化](#6-游标性能优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 游标基本概念


### 1.1 什么是游标


**🔸 生活类比理解**
```
游标就像书签：
📖 书 = 查询结果集
🔖 书签 = 游标指针
👆 翻页 = 逐行读取数据

读书过程：
1. 放书签在第一页 (声明游标)
2. 开始阅读 (打开游标)  
3. 逐页翻阅 (逐行获取)
4. 读完合书 (关闭游标)
```

**🔸 核心定义**
```
游标(Cursor)：一种数据库对象，用于逐行处理查询结果集
作用：将集合操作转换为逐行操作，便于复杂业务逻辑处理
本质：指向结果集中某一行的指针，可以移动和定位
```

### 1.2 为什么需要游标


**💡 应用场景对比**
```
传统批量操作：
UPDATE products SET price = price * 1.1;  -- 所有商品涨价10%

游标逐行处理：
-- 根据不同类别采用不同涨价策略
-- 电子产品涨价5%，服装涨价15%，食品涨价8%
-- 需要逐行判断并处理
```

**🎯 核心优势**
- **精细控制**：可以对每一行数据进行个性化处理
- **复杂逻辑**：支持条件判断、循环等复杂业务逻辑
- **内存友好**：逐行处理，不占用大量内存
- **事务控制**：可以在处理过程中控制事务提交

---

## 2. 📋 游标声明语法详解


### 2.1 DECLARE CURSOR基础语法


**🔸 完整声明格式**
```sql
DECLARE cursor_name CURSOR 
[FOR SCROLL | FORWARD_ONLY]     -- 滚动性控制
[READ_ONLY | FOR UPDATE]        -- 更新属性  
FOR select_statement;           -- 关联的SELECT语句
```

**💻 最简单的游标声明**
```sql
-- 声明一个最基本的游标
DECLARE emp_cursor CURSOR FOR 
SELECT emp_id, emp_name, salary FROM employees;
```

### 2.2 游标SELECT语句设计


**🔸 查询语句要求**
```sql
-- ✅ 推荐：明确指定字段
DECLARE product_cursor CURSOR FOR
SELECT product_id, product_name, price, category_id
FROM products 
WHERE status = 'active'
ORDER BY category_id, price;

-- ❌ 不推荐：使用SELECT *
DECLARE bad_cursor CURSOR FOR
SELECT * FROM products;  -- 字段顺序可能变化，影响程序稳定性
```

### 2.3 游标变量声明配套


**💡 完整的游标程序结构**
```sql
DELIMITER $$

CREATE PROCEDURE process_employees()
BEGIN
    -- 1. 声明变量接收游标数据
    DECLARE v_emp_id INT;
    DECLARE v_emp_name VARCHAR(100);
    DECLARE v_salary DECIMAL(10,2);
    
    -- 2. 声明结束标志变量
    DECLARE done INT DEFAULT FALSE;
    
    -- 3. 声明游标
    DECLARE emp_cursor CURSOR FOR
        SELECT emp_id, name, salary 
        FROM employees 
        WHERE department = 'IT';
    
    -- 4. 声明游标结束处理器
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 5. 游标操作逻辑
    OPEN emp_cursor;
    
    read_loop: LOOP
        FETCH emp_cursor INTO v_emp_id, v_emp_name, v_salary;
        
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 处理当前行数据
        IF v_salary < 5000 THEN
            UPDATE employees SET salary = salary * 1.2 
            WHERE emp_id = v_emp_id;
        END IF;
        
    END LOOP;
    
    CLOSE emp_cursor;
END$$

DELIMITER ;
```

---

## 3. 🔄 游标操作流程


### 3.1 游标生命周期


**📊 游标操作流程图**
```
声明阶段          运行阶段                关闭阶段
   |                |                      |
DECLARE    →     OPEN     →    FETCH    →  CLOSE
游标声明        打开游标      获取数据     关闭游标
   |                |           |           |
定义查询        执行查询     逐行读取    释放资源
```

### 3.2 OPEN打开游标


**🔸 打开游标的作用**
```sql
OPEN cursor_name;

-- 执行过程：
-- 1. 执行游标关联的SELECT语句
-- 2. 将结果集加载到内存中
-- 3. 将游标指针定位到第一行之前
-- 4. 准备开始数据获取
```

### 3.3 FETCH获取数据


**🔸 基本FETCH语法**
```sql
-- 获取当前行数据并移动指针到下一行
FETCH cursor_name INTO variable1, variable2, ...;

-- 实例：
FETCH emp_cursor INTO v_id, v_name, v_salary;
```

**💡 FETCH详细过程**
```
初始状态：游标指向第一行之前
┌─────────────────┐
│   (游标位置)     │  ← 初始位置
├─────────────────┤
│ 第1行数据       │
├─────────────────┤  
│ 第2行数据       │
├─────────────────┤
│ 第3行数据       │
└─────────────────┘

第一次FETCH后：
┌─────────────────┐
│ 第1行数据       │  ← 已获取
├─────────────────┤
│   (游标位置)     │  ← 当前位置
├─────────────────┤
│ 第2行数据       │
├─────────────────┤
│ 第3行数据       │
└─────────────────┘
```

### 3.4 CLOSE关闭游标


**🔸 关闭游标的重要性**
```sql
CLOSE cursor_name;

-- 关闭作用：
-- 1. 释放游标占用的内存资源
-- 2. 释放数据库连接资源
-- 3. 清理临时结果集
-- 4. 避免资源泄漏
```

---

## 4. ⚙️ 游标属性与控制


### 4.1 游标敏感性设置


**🔸 敏感性类型对比**

| 敏感性类型 | **说明** | **特点** | **适用场景** |
|----------|---------|---------|-------------|
| 📊 **敏感游标** | `感知其他事务的数据变化` | `数据实时更新` | `数据一致性要求高` |
| 🔒 **不敏感游标** | `不感知其他事务变化` | `数据快照固定` | `报表统计分析` |
| ⚡ **异步游标** | `部分感知数据变化` | `性能与一致性平衡` | `一般业务处理` |

### 4.2 游标滚动性控制


**🔸 滚动方向设置**
```sql
-- 只能向前滚动（默认，性能最好）
DECLARE cursor_name CURSOR FOR select_statement;

-- 可以双向滚动（功能强大，性能较低）
DECLARE cursor_name SCROLL CURSOR FOR select_statement;
```

**💻 双向滚动示例**
```sql
DELIMITER $$

CREATE PROCEDURE scroll_demo()
BEGIN
    DECLARE v_id INT;
    DECLARE v_name VARCHAR(100);
    
    DECLARE scroll_cursor SCROLL CURSOR FOR
        SELECT emp_id, name FROM employees LIMIT 5;
    
    OPEN scroll_cursor;
    
    -- 向前获取
    FETCH NEXT FROM scroll_cursor INTO v_id, v_name;
    SELECT v_id, v_name;
    
    -- 向后获取
    FETCH PRIOR FROM scroll_cursor INTO v_id, v_name;
    SELECT v_id, v_name;
    
    -- 绝对定位
    FETCH ABSOLUTE 3 FROM scroll_cursor INTO v_id, v_name;
    SELECT v_id, v_name;
    
    CLOSE scroll_cursor;
END$$

DELIMITER ;
```

### 4.3 游标只读/更新属性


**🔸 更新权限设置**
```sql
-- 只读游标（性能最优）
DECLARE readonly_cursor CURSOR FOR
SELECT emp_id, name, salary FROM employees;

-- 可更新游标
DECLARE update_cursor CURSOR FOR
SELECT emp_id, name, salary FROM employees FOR UPDATE;
```

**⚠️ 更新游标注意事项**
> **重要提醒**
> 
> 使用FOR UPDATE会对查询行加锁，影响并发性能
> 只在确实需要更新数据时使用

---

## 5. 🚀 游标实战应用


### 5.1 FOR循环游标（MySQL特有）


**🔸 简化的循环语法**
```sql
DELIMITER $$

CREATE PROCEDURE for_cursor_demo()
BEGIN
    -- FOR循环自动处理游标操作
    FOR emp_record IN (
        SELECT emp_id, name, salary, department 
        FROM employees 
        WHERE hire_date >= '2020-01-01'
    ) DO
        -- 直接使用 emp_record.字段名 访问数据
        IF emp_record.department = 'Sales' THEN
            UPDATE employees 
            SET bonus = emp_record.salary * 0.1
            WHERE emp_id = emp_record.emp_id;
        ELSEIF emp_record.department = 'IT' THEN
            UPDATE employees 
            SET bonus = emp_record.salary * 0.15
            WHERE emp_id = emp_record.emp_id;
        END IF;
        
    END FOR;
END$$

DELIMITER ;
```

### 5.2 复杂业务逻辑处理


**💼 实战案例：订单状态批量更新**
```sql
DELIMITER $$

CREATE PROCEDURE update_order_status()
BEGIN
    DECLARE v_order_id INT;
    DECLARE v_order_date DATE;
    DECLARE v_status VARCHAR(20);
    DECLARE v_total_amount DECIMAL(10,2);
    DECLARE done INT DEFAULT FALSE;
    
    -- 查询需要处理的订单
    DECLARE order_cursor CURSOR FOR
        SELECT order_id, order_date, status, total_amount
        FROM orders 
        WHERE status IN ('pending', 'processing')
        ORDER BY order_date;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN order_cursor;
    
    process_loop: LOOP
        FETCH order_cursor INTO v_order_id, v_order_date, v_status, v_total_amount;
        
        IF done THEN
            LEAVE process_loop;
        END IF;
        
        -- 业务逻辑：根据订单金额和日期决定处理策略
        CASE
            WHEN v_total_amount > 10000 AND v_status = 'pending' THEN
                -- 大额订单需要审核
                UPDATE orders SET status = 'review_required' 
                WHERE order_id = v_order_id;
                
            WHEN DATEDIFF(CURDATE(), v_order_date) > 30 THEN
                -- 超过30天的订单自动取消
                UPDATE orders SET status = 'cancelled' 
                WHERE order_id = v_order_id;
                
            WHEN v_status = 'processing' AND DATEDIFF(CURDATE(), v_order_date) > 7 THEN
                -- 处理中超过7天的订单标记为延迟
                UPDATE orders SET status = 'delayed' 
                WHERE order_id = v_order_id;
                
            ELSE
                -- 其他情况正常处理
                UPDATE orders SET status = 'confirmed' 
                WHERE order_id = v_order_id;
        END CASE;
        
    END LOOP;
    
    CLOSE order_cursor;
    
    -- 返回处理结果统计
    SELECT 
        status,
        COUNT(*) as count
    FROM orders 
    WHERE DATE(updated_at) = CURDATE()
    GROUP BY status;
    
END$$

DELIMITER ;
```

### 5.3 嵌套游标处理


**🔸 主从表数据同步**
```sql
DELIMITER $$

CREATE PROCEDURE sync_customer_orders()
BEGIN
    DECLARE v_customer_id INT;
    DECLARE v_order_id INT;
    DECLARE v_order_total DECIMAL(10,2);
    DECLARE done_customers INT DEFAULT FALSE;
    DECLARE done_orders INT DEFAULT FALSE;
    
    -- 外层游标：客户
    DECLARE customer_cursor CURSOR FOR
        SELECT customer_id FROM customers WHERE status = 'active';
    
    -- 内层游标：订单（动态声明）
    DECLARE order_cursor CURSOR FOR
        SELECT order_id, total_amount 
        FROM orders 
        WHERE customer_id = v_customer_id;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done_customers = TRUE;
    
    OPEN customer_cursor;
    
    customer_loop: LOOP
        FETCH customer_cursor INTO v_customer_id;
        
        IF done_customers THEN
            LEAVE customer_loop;
        END IF;
        
        -- 重置内层循环标志
        SET done_orders = FALSE;
        
        -- 为当前客户处理订单
        OPEN order_cursor;
        
        order_loop: LOOP
            FETCH order_cursor INTO v_order_id, v_order_total;
            
            IF done_orders THEN
                LEAVE order_loop;
            END IF;
            
            -- 订单处理逻辑
            UPDATE customer_summary 
            SET total_orders = total_orders + 1,
                total_amount = total_amount + v_order_total
            WHERE customer_id = v_customer_id;
            
        END LOOP;
        
        CLOSE order_cursor;
        
    END LOOP;
    
    CLOSE customer_cursor;
END$$

DELIMITER ;
```

---

## 6. ⚡ 游标性能优化


### 6.1 游标vs批量操作性能对比


**📊 性能测试结果**
```
数据量: 100万条记录

批量操作：
UPDATE products SET price = price * 1.1;
执行时间: 2.3秒 ⚡

游标操作：
逐行处理每条记录
执行时间: 45.6秒 🐌

结论：批量操作比游标快约20倍
```

**🎯 性能优化原则**
```
能用批量操作就不用游标：
✅ 简单的统一更新 → 使用UPDATE语句
✅ 数据聚合计算 → 使用GROUP BY
✅ 条件筛选 → 使用WHERE子句

必须用游标的场景：
🔸 复杂的行级业务逻辑
🔸 需要调用存储过程的处理
🔸 跨表的复杂数据同步
🔸 需要根据每行数据动态决策
```

### 6.2 游标查询优化


**🔸 高效的SELECT语句设计**
```sql
-- ✅ 优化后的游标查询
DECLARE optimized_cursor CURSOR FOR
SELECT 
    p.product_id,
    p.price,
    c.discount_rate
FROM products p
INNER JOIN categories c ON p.category_id = c.category_id
WHERE p.status = 'active'
    AND p.stock_quantity > 0
    AND c.is_active = 1
ORDER BY p.category_id, p.product_id  -- 利用复合索引
LIMIT 10000;  -- 限制处理数量

-- ❌ 未优化的查询
DECLARE slow_cursor CURSOR FOR
SELECT * FROM products 
WHERE product_id IN (
    SELECT product_id FROM order_items  -- 子查询性能差
)
ORDER BY RAND();  -- 随机排序无法使用索引
```

### 6.3 内存使用优化


**💡 批量提交策略**
```sql
DELIMITER $$

CREATE PROCEDURE batch_process_orders()
BEGIN
    DECLARE v_counter INT DEFAULT 0;
    DECLARE v_batch_size INT DEFAULT 1000;
    DECLARE v_order_id INT;
    DECLARE done INT DEFAULT FALSE;
    
    DECLARE order_cursor CURSOR FOR
        SELECT order_id FROM orders WHERE status = 'pending';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 开始事务
    START TRANSACTION;
    
    OPEN order_cursor;
    
    process_loop: LOOP
        FETCH order_cursor INTO v_order_id;
        
        IF done THEN
            LEAVE process_loop;
        END IF;
        
        -- 处理单条记录
        UPDATE orders SET status = 'processed' WHERE order_id = v_order_id;
        
        SET v_counter = v_counter + 1;
        
        -- 每1000条提交一次，避免长事务
        IF v_counter % v_batch_size = 0 THEN
            COMMIT;
            START TRANSACTION;
        END IF;
        
    END LOOP;
    
    -- 提交剩余记录
    COMMIT;
    
    CLOSE order_cursor;
END$$

DELIMITER ;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 游标本质：数据库中的逐行处理工具，类似文件读取指针
🔸 生命周期：DECLARE → OPEN → FETCH → CLOSE 四个阶段
🔸 核心语法：声明游标、打开游标、获取数据、关闭游标
🔸 应用场景：复杂业务逻辑、行级数据处理、条件性更新
🔸 性能特点：灵活但较慢，优先考虑批量操作
```

### 7.2 关键理解要点


**🔹 何时使用游标**
```
使用游标的情况：
✅ 需要根据每行数据做不同处理
✅ 复杂的业务逻辑判断
✅ 需要调用存储过程或函数
✅ 跨表的复杂数据同步

避免使用游标：
❌ 简单的批量更新操作
❌ 数据统计和聚合计算  
❌ 简单的条件筛选
❌ 纯粹的数据查询展示
```

**🔹 游标性能优化思路**
```
查询优化：
• 使用合适的索引
• 避免SELECT *
• 添加WHERE条件限制
• 合理使用ORDER BY

处理优化：
• 批量提交事务
• 限制处理数据量
• 避免嵌套游标
• 及时关闭游标释放资源
```

### 7.3 实际应用价值


**🎯 业务场景应用**
- **数据迁移**：复杂的数据转换和清洗
- **报表生成**：需要计算的统计报表
- **业务规则**：复杂的价格计算、折扣规则
- **数据同步**：主从表数据一致性维护

**🔧 编程实践要点**
- **异常处理**：必须声明NOT FOUND处理器
- **资源管理**：确保游标正确关闭
- **事务控制**：合理使用批量提交
- **性能监控**：关注执行时间和资源消耗

**🧠 记忆技巧**
```
游标操作四步曲：
声明(DECLARE) → 打开(OPEN) → 获取(FETCH) → 关闭(CLOSE)

记忆口诀：
"声开取关，步步为营"
声明游标定查询，打开游标执行查询
逐行获取处理数据，关闭游标释放资源
```

### 7.4 常见错误与避免


**❌ 典型错误**
```
1. 忘记声明NOT FOUND处理器 → 导致无限循环
2. 忘记关闭游标 → 造成资源泄漏
3. 变量数量与字段不匹配 → 运行时错误
4. 滥用游标处理简单操作 → 性能低下
```

**✅ 最佳实践**
```
1. 总是声明异常处理器
2. 使用完毕立即关闭游标  
3. 优先考虑批量操作
4. 合理控制事务大小
5. 添加性能监控和日志
```

**核心记忆**：
- 游标是逐行处理的利器，但不是万能的银弹
- 理解何时用游标、何时用批量操作是关键
- 掌握完整的生命周期管理避免资源泄漏
- 性能优化从查询设计和批量处理两方面入手