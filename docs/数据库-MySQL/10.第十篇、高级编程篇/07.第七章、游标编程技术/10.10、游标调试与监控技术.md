---
title: 10、游标调试与监控技术
---
## 📚 目录

1. [游标监控基础概念](#1-游标监控基础概念)
2. [性能指标收集技术](#2-性能指标收集技术)
3. [调试信息输出方法](#3-调试信息输出方法)
4. [执行计划分析](#4-执行计划分析)
5. [资源使用跟踪](#5-资源使用跟踪)
6. [问题诊断实践](#6-问题诊断实践)
7. [监控工具应用](#7-监控工具应用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 游标监控基础概念


### 1.1 什么是游标监控

游标监控就像给汽车安装仪表盘，让我们能实时观察游标的运行状态。

```
传统游标使用：               带监控的游标：
写代码 → 运行 → 出错         写代码 → 监控 → 分析 → 优化
   ↓                          ↓
 难以定位问题              快速发现问题根源
```

**🔸 核心监控对象**
```sql
-- 基本监控框架
DELIMITER $$
CREATE PROCEDURE cursor_with_monitoring()
BEGIN
    -- 声明监控变量
    DECLARE start_time TIMESTAMP DEFAULT NOW();
    DECLARE rows_processed INT DEFAULT 0;
    DECLARE memory_used INT DEFAULT 0;
    
    -- 游标声明
    DECLARE done INT DEFAULT FALSE;
    DECLARE user_id INT;
    DECLARE cur CURSOR FOR SELECT id FROM users;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 监控开始
    SELECT CONCAT('游标开始执行：', start_time) AS debug_info;
    
    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO user_id;
        IF done THEN LEAVE read_loop; END IF;
        
        -- 处理逻辑
        SET rows_processed = rows_processed + 1;
        
        -- 每100行输出一次监控信息
        IF rows_processed % 100 = 0 THEN
            SELECT CONCAT('已处理行数：', rows_processed) AS progress;
        END IF;
    END LOOP;
    
    CLOSE cur;
    
    -- 监控结束
    SELECT 
        CONCAT('总处理行数：', rows_processed) AS total_rows,
        CONCAT('执行时间：', TIMESTAMPDIFF(SECOND, start_time, NOW()), '秒') AS duration;
END$$
DELIMITER ;
```

### 1.2 监控的重要性

监控游标就像体检，能提前发现问题避免严重后果。

**💡 监控解决的问题**
```
性能问题：
• 游标执行过慢
• 内存占用过高
• CPU使用率异常

逻辑问题：
• 死循环风险
• 数据处理错误
• 异常处理不当

资源问题：
• 连接泄露
• 锁等待超时
• 临时表空间不足
```

---

## 2. 📈 性能指标收集技术


### 2.1 核心性能指标

性能指标就像汽车的速度表、油表，告诉我们运行状况。

**🔸 关键指标类型**
```sql
-- 创建性能监控表
CREATE TABLE cursor_performance_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    procedure_name VARCHAR(100),
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    rows_processed INT,
    execution_time_seconds INT,
    memory_peak_mb DECIMAL(10,2),
    cpu_usage_percent DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**⚡ 实时性能收集**
```sql
DELIMITER $$
CREATE PROCEDURE collect_cursor_metrics()
BEGIN
    DECLARE proc_start TIMESTAMP DEFAULT NOW();
    DECLARE current_memory DECIMAL(10,2);
    DECLARE processed_count INT DEFAULT 0;
    
    -- 获取当前内存使用
    SELECT 
        ROUND(
            (SELECT VARIABLE_VALUE 
             FROM performance_schema.session_status 
             WHERE VARIABLE_NAME = 'Created_tmp_tables') * 0.1, 2
        ) INTO current_memory;
    
    -- 游标处理逻辑
    DECLARE done INT DEFAULT FALSE;
    DECLARE order_id INT;
    DECLARE cur CURSOR FOR 
        SELECT id FROM orders WHERE status = 'pending' LIMIT 1000;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    process_loop: LOOP
        FETCH cur INTO order_id;
        IF done THEN LEAVE process_loop; END IF;
        
        -- 模拟处理
        UPDATE orders SET status = 'processing' WHERE id = order_id;
        SET processed_count = processed_count + 1;
        
        -- 每50行记录一次性能
        IF processed_count % 50 = 0 THEN
            INSERT INTO cursor_performance_log 
            (procedure_name, start_time, rows_processed, execution_time_seconds)
            VALUES 
            ('collect_cursor_metrics', proc_start, processed_count, 
             TIMESTAMPDIFF(SECOND, proc_start, NOW()));
        END IF;
    END LOOP;
    CLOSE cur;
    
    -- 最终性能记录
    INSERT INTO cursor_performance_log 
    (procedure_name, start_time, end_time, rows_processed, 
     execution_time_seconds, memory_peak_mb)
    VALUES 
    ('collect_cursor_metrics', proc_start, NOW(), processed_count,
     TIMESTAMPDIFF(SECOND, proc_start, NOW()), current_memory);
END$$
DELIMITER ;
```

### 2.2 性能指标分析

收集到数据后要会分析，就像看懂体检报告。

**📊 性能分析视图**
```sql
-- 创建性能分析视图
CREATE VIEW cursor_performance_analysis AS
SELECT 
    procedure_name,
    COUNT(*) as execution_count,
    AVG(execution_time_seconds) as avg_execution_time,
    MAX(execution_time_seconds) as max_execution_time,
    AVG(rows_processed) as avg_rows_per_execution,
    AVG(rows_processed / execution_time_seconds) as avg_rows_per_second,
    MAX(memory_peak_mb) as peak_memory_usage
FROM cursor_performance_log 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
GROUP BY procedure_name;

-- 查看性能趋势
SELECT * FROM cursor_performance_analysis;
```

---

## 3. 🔍 调试信息输出方法


### 3.1 调试信息的重要性

调试信息就像程序的"自言自语"，告诉我们它在想什么、做什么。

**🔸 基础调试框架**
```sql
DELIMITER $$
CREATE PROCEDURE debug_cursor_example()
BEGIN
    DECLARE debug_mode BOOLEAN DEFAULT TRUE;
    DECLARE step_counter INT DEFAULT 0;
    DECLARE current_step VARCHAR(100);
    
    -- 调试信息输出函数
    DECLARE debug_msg VARCHAR(500);
    
    IF debug_mode THEN
        SET debug_msg = CONCAT('[DEBUG] 存储过程开始执行 - ', NOW());
        SELECT debug_msg AS debug_output;
    END IF;
    
    -- 游标相关声明
    DECLARE done INT DEFAULT FALSE;
    DECLARE user_id INT;
    DECLARE user_name VARCHAR(100);
    DECLARE cur CURSOR FOR 
        SELECT id, name FROM users WHERE status = 'active' LIMIT 5;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    SET current_step = '打开游标';
    SET step_counter = step_counter + 1;
    IF debug_mode THEN
        SELECT CONCAT('[DEBUG] 步骤', step_counter, ': ', current_step) AS debug_output;
    END IF;
    
    OPEN cur;
    
    SET current_step = '开始循环处理';
    SET step_counter = step_counter + 1;
    IF debug_mode THEN
        SELECT CONCAT('[DEBUG] 步骤', step_counter, ': ', current_step) AS debug_output;
    END IF;
    
    read_loop: LOOP
        FETCH cur INTO user_id, user_name;
        IF done THEN 
            IF debug_mode THEN
                SELECT '[DEBUG] 游标读取完毕，退出循环' AS debug_output;
            END IF;
            LEAVE read_loop; 
        END IF;
        
        IF debug_mode THEN
            SELECT CONCAT('[DEBUG] 处理用户: ID=', user_id, ', Name=', user_name) AS debug_output;
        END IF;
        
        -- 模拟处理逻辑
        UPDATE users SET last_access = NOW() WHERE id = user_id;
        
        IF debug_mode THEN
            SELECT CONCAT('[DEBUG] 用户', user_id, '更新完成') AS debug_output;
        END IF;
    END LOOP;
    
    SET current_step = '关闭游标';
    SET step_counter = step_counter + 1;
    IF debug_mode THEN
        SELECT CONCAT('[DEBUG] 步骤', step_counter, ': ', current_step) AS debug_output;
    END IF;
    
    CLOSE cur;
    
    IF debug_mode THEN
        SELECT '[DEBUG] 存储过程执行完成' AS debug_output;
    END IF;
END$$
DELIMITER ;
```

### 3.2 条件调试输出

根据需要控制调试信息，避免信息过载。

**⚙️ 智能调试控制**
```sql
DELIMITER $$
CREATE PROCEDURE smart_debug_cursor()
BEGIN
    -- 调试级别：1=错误，2=警告，3=信息，4=详细
    DECLARE debug_level INT DEFAULT 3;
    DECLARE error_count INT DEFAULT 0;
    
    -- 调试输出过程
    DROP PROCEDURE IF EXISTS log_debug;
    CREATE PROCEDURE log_debug(IN level INT, IN message VARCHAR(500))
    BEGIN
        IF level <= debug_level THEN
            SELECT 
                CASE level
                    WHEN 1 THEN '[ERROR]'
                    WHEN 2 THEN '[WARN] '
                    WHEN 3 THEN '[INFO] '
                    WHEN 4 THEN '[DEBUG]'
                END as log_level,
                message as log_message,
                NOW() as log_time;
        END IF;
    END;
    
    CALL log_debug(3, '游标调试开始');
    
    -- 游标处理
    DECLARE done INT DEFAULT FALSE;
    DECLARE order_id INT;
    DECLARE order_status VARCHAR(20);
    DECLARE cur CURSOR FOR 
        SELECT id, status FROM orders WHERE created_at >= CURDATE() LIMIT 10;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    CALL log_debug(4, '游标已声明，准备打开');
    OPEN cur;
    CALL log_debug(3, '游标已打开，开始处理数据');
    
    process_loop: LOOP
        FETCH cur INTO order_id, order_status;
        IF done THEN 
            CALL log_debug(3, '数据处理完成');
            LEAVE process_loop; 
        END IF;
        
        CALL log_debug(4, CONCAT('处理订单: ', order_id, ', 状态: ', order_status));
        
        -- 模拟可能出错的处理
        IF order_status = 'invalid' THEN
            SET error_count = error_count + 1;
            CALL log_debug(1, CONCAT('发现无效订单: ', order_id));
        ELSE
            CALL log_debug(4, CONCAT('订单', order_id, '处理正常'));
        END IF;
    END LOOP;
    
    CLOSE cur;
    CALL log_debug(3, '游标已关闭');
    
    IF error_count > 0 THEN
        CALL log_debug(2, CONCAT('处理完成，发现', error_count, '个错误'));
    ELSE
        CALL log_debug(3, '处理完成，无错误');
    END IF;
    
    DROP PROCEDURE log_debug;
END$$
DELIMITER ;
```

---

## 4. 📋 执行计划分析


### 4.1 执行计划的作用

执行计划就像GPS导航，告诉我们MySQL是怎么执行查询的。

**🔸 游标查询分析**
```sql
-- 分析游标使用的查询
EXPLAIN FORMAT=JSON
SELECT id, name, email 
FROM users 
WHERE status = 'active' 
  AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
ORDER BY created_at DESC;
```

**📊 执行计划解读**
```
关键指标解读：

type字段：
• ALL：全表扫描（最慢）
• index：索引扫描
• range：范围查询（较好）
• ref：索引查找（好）
• eq_ref：唯一索引查找（最好）

rows字段：
• 预估扫描行数
• 数值越小越好

Extra字段：
• Using filesort：需要排序（可能影响性能）
• Using temporary：使用临时表
• Using index：索引覆盖（很好）
```

### 4.2 游标性能优化

基于执行计划优化游标性能。

**⚡ 优化实践**
```sql
-- 优化前的游标（性能较差）
DELIMITER $$
CREATE PROCEDURE slow_cursor()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE user_id INT;
    -- 没有合适索引的查询
    DECLARE cur CURSOR FOR 
        SELECT id FROM users 
        WHERE YEAR(created_at) = 2024  -- 函数使用导致无法使用索引
        ORDER BY name;  -- name字段可能没有索引
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    -- 处理逻辑...
    CLOSE cur;
END$$

-- 优化后的游标（性能更好）
CREATE PROCEDURE optimized_cursor()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE user_id INT;
    -- 使用索引友好的查询
    DECLARE cur CURSOR FOR 
        SELECT id FROM users 
        WHERE created_at >= '2024-01-01'  -- 直接日期比较
          AND created_at < '2025-01-01'
        ORDER BY id;  -- 主键排序最快
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    -- 处理逻辑...
    CLOSE cur;
END$$
DELIMITER ;

-- 为优化创建必要索引
CREATE INDEX idx_users_created_at ON users(created_at);
```

---

## 5. 💾 资源使用跟踪


### 5.1 内存使用监控

监控内存就像关注手机电量，避免资源耗尽。

**🔸 内存监控技术**
```sql
DELIMITER $$
CREATE PROCEDURE monitor_cursor_memory()
BEGIN
    DECLARE start_memory BIGINT;
    DECLARE current_memory BIGINT;
    DECLARE peak_memory BIGINT DEFAULT 0;
    
    -- 获取初始内存状态
    SELECT VARIABLE_VALUE INTO start_memory
    FROM performance_schema.session_status 
    WHERE VARIABLE_NAME = 'Created_tmp_tables';
    
    -- 游标处理
    DECLARE done INT DEFAULT FALSE;
    DECLARE product_id INT;
    DECLARE cur CURSOR FOR 
        SELECT id FROM products WHERE status = 'active';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    memory_loop: LOOP
        FETCH cur INTO product_id;
        IF done THEN LEAVE memory_loop; END IF;
        
        -- 处理逻辑（可能消耗内存）
        SELECT COUNT(*) FROM order_items WHERE product_id = product_id;
        
        -- 检查内存使用
        SELECT VARIABLE_VALUE INTO current_memory
        FROM performance_schema.session_status 
        WHERE VARIABLE_NAME = 'Created_tmp_tables';
        
        IF current_memory > peak_memory THEN
            SET peak_memory = current_memory;
        END IF;
        
        -- 内存预警
        IF current_memory - start_memory > 1000 THEN
            SELECT CONCAT('内存使用预警：已使用', 
                         current_memory - start_memory, '个临时表') AS warning;
        END IF;
    END LOOP;
    CLOSE cur;
    
    -- 内存使用报告
    SELECT 
        start_memory AS initial_memory,
        peak_memory AS peak_memory_usage,
        peak_memory - start_memory AS memory_consumed;
END$$
DELIMITER ;
```

### 5.2 连接和锁监控

监控连接和锁状态，避免资源死锁。

**🔒 连接锁监控**
```sql
-- 创建锁监控表
CREATE TABLE cursor_lock_monitor (
    id INT AUTO_INCREMENT PRIMARY KEY,
    thread_id BIGINT,
    lock_type VARCHAR(50),
    lock_duration DECIMAL(10,3),
    blocked_queries INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DELIMITER $$
CREATE PROCEDURE cursor_with_lock_monitor()
BEGIN
    DECLARE current_thread_id BIGINT;
    DECLARE lock_start_time TIMESTAMP;
    DECLARE lock_count INT DEFAULT 0;
    
    -- 获取当前线程ID
    SELECT CONNECTION_ID() INTO current_thread_id;
    
    -- 游标处理前记录
    SET lock_start_time = NOW();
    
    DECLARE done INT DEFAULT FALSE;
    DECLARE account_id INT;
    DECLARE cur CURSOR FOR 
        SELECT id FROM accounts WHERE balance > 1000 FOR UPDATE;  -- 会产生行锁
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    lock_loop: LOOP
        FETCH cur INTO account_id;
        IF done THEN LEAVE lock_loop; END IF;
        
        -- 更新操作（持有锁）
        UPDATE accounts SET last_check = NOW() WHERE id = account_id;
        SET lock_count = lock_count + 1;
        
        -- 检查是否有等待锁的查询
        INSERT INTO cursor_lock_monitor (thread_id, lock_type, lock_duration, blocked_queries)
        SELECT 
            current_thread_id,
            'ROW_LOCK',
            TIMESTAMPDIFF(MICROSECOND, lock_start_time, NOW()) / 1000000,
            (SELECT COUNT(*) 
             FROM performance_schema.data_locks 
             WHERE LOCK_STATUS = 'WAITING');
    END LOOP;
    CLOSE cur;
    
    SELECT CONCAT('处理完成，共处理', lock_count, '条记录') AS result;
END$$
DELIMITER ;
```

---

## 6. 🔧 问题诊断实践


### 6.1 常见问题诊断

诊断游标问题就像医生看病，要找到症状的根本原因。

**⚠️ 典型问题诊断**
```sql
DELIMITER $$
CREATE PROCEDURE diagnose_cursor_issues()
BEGIN
    DECLARE diagnosis_result TEXT DEFAULT '';
    DECLARE cursor_count INT;
    DECLARE long_running_count INT;
    DECLARE lock_wait_count INT;
    
    -- 检查1：游标数量
    SELECT COUNT(*) INTO cursor_count
    FROM information_schema.PROCESSLIST 
    WHERE INFO LIKE '%CURSOR%' AND STATE != 'Sleep';
    
    IF cursor_count > 10 THEN
        SET diagnosis_result = CONCAT(diagnosis_result, 
            '[警告] 当前有', cursor_count, '个活跃游标，可能存在性能问题\n');
    END IF;
    
    -- 检查2：长时间运行的查询
    SELECT COUNT(*) INTO long_running_count
    FROM information_schema.PROCESSLIST 
    WHERE TIME > 60 AND INFO LIKE '%CURSOR%';
    
    IF long_running_count > 0 THEN
        SET diagnosis_result = CONCAT(diagnosis_result,
            '[警告] 发现', long_running_count, '个长时间运行的游标查询\n');
    END IF;
    
    -- 检查3：锁等待
    SELECT COUNT(*) INTO lock_wait_count
    FROM performance_schema.data_locks 
    WHERE LOCK_STATUS = 'WAITING';
    
    IF lock_wait_count > 0 THEN
        SET diagnosis_result = CONCAT(diagnosis_result,
            '[警告] 发现', lock_wait_count, '个锁等待情况\n');
    END IF;
    
    -- 输出诊断结果
    IF LENGTH(diagnosis_result) = 0 THEN
        SELECT '系统状态正常，未发现游标相关问题' AS diagnosis;
    ELSE
        SELECT diagnosis_result AS diagnosis;
    END IF;
    
    -- 详细问题信息
    SELECT 
        ID as process_id,
        USER as db_user,
        HOST,
        DB as database_name,
        COMMAND,
        TIME as duration_seconds,
        STATE,
        LEFT(INFO, 100) as query_preview
    FROM information_schema.PROCESSLIST 
    WHERE INFO LIKE '%CURSOR%' AND STATE != 'Sleep'
    ORDER BY TIME DESC;
END$$
DELIMITER ;
```

### 6.2 自动问题修复

建立自动修复机制，就像汽车的自动修复系统。

**🔄 自动修复框架**
```sql
DELIMITER $$
CREATE PROCEDURE auto_fix_cursor_issues()
BEGIN
    DECLARE fix_actions TEXT DEFAULT '';
    DECLARE zombie_cursors INT;
    
    -- 检查僵尸游标（运行超过5分钟）
    SELECT COUNT(*) INTO zombie_cursors
    FROM information_schema.PROCESSLIST 
    WHERE TIME > 300 
      AND INFO LIKE '%CURSOR%' 
      AND STATE = 'User lock';
    
    IF zombie_cursors > 0 THEN
        -- 记录问题
        INSERT INTO cursor_performance_log 
        (procedure_name, start_time, rows_processed, execution_time_seconds)
        VALUES ('auto_fix_detected_zombie', NOW(), zombie_cursors, 300);
        
        SET fix_actions = CONCAT(fix_actions, 
            '已记录', zombie_cursors, '个僵尸游标问题\n');
        
        -- 可以添加更多自动修复逻辑
        -- 注意：杀死进程需要谨慎，这里只做记录
    END IF;
    
    SELECT fix_actions AS auto_fix_result;
END$$
DELIMITER ;
```

---

## 7. 🛠️ 监控工具应用


### 7.1 MySQL自带监控工具

MySQL提供了丰富的监控工具，就像医院的各种检查设备。

**📊 Performance Schema监控**
```sql
-- 查看游标相关的性能统计
SELECT 
    EVENT_NAME,
    COUNT_STAR as total_events,
    AVG_TIMER_WAIT/1000000000 as avg_duration_seconds,
    MAX_TIMER_WAIT/1000000000 as max_duration_seconds
FROM performance_schema.events_statements_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%cursor%'
ORDER BY COUNT_STAR DESC;

-- 查看当前游标状态
SELECT 
    THREAD_ID,
    EVENT_NAME,
    SOURCE,
    TIMER_START,
    TIMER_END,
    TIMER_WAIT/1000000000 as duration_seconds
FROM performance_schema.events_statements_current 
WHERE EVENT_NAME LIKE '%cursor%';
```

### 7.2 自定义监控仪表板

创建专门的游标监控仪表板。

**📈 监控仪表板**
```sql
-- 创建游标监控视图
CREATE VIEW cursor_dashboard AS
SELECT 
    '当前活跃游标' as metric,
    COUNT(*) as value,
    '个' as unit
FROM information_schema.PROCESSLIST 
WHERE INFO LIKE '%CURSOR%' AND STATE != 'Sleep'

UNION ALL

SELECT 
    '平均执行时间' as metric,
    ROUND(AVG(execution_time_seconds), 2) as value,
    '秒' as unit
FROM cursor_performance_log 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR)

UNION ALL

SELECT 
    '峰值内存使用' as metric,
    ROUND(MAX(memory_peak_mb), 2) as value,
    'MB' as unit
FROM cursor_performance_log 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR);

-- 查看仪表板
SELECT * FROM cursor_dashboard;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的监控技能


```
🔸 基础监控：学会收集游标执行的基本指标
🔸 性能分析：能够通过执行计划优化游标性能
🔸 调试技巧：掌握调试信息输出和问题定位方法
🔸 资源监控：监控内存、连接、锁等资源使用情况
🔸 问题诊断：能够快速识别和解决常见游标问题
🔸 工具应用：熟练使用MySQL内置监控工具
```

### 8.2 监控最佳实践


**💡 监控策略**
```
开发阶段：
• 启用详细调试信息
• 记录每个步骤的执行情况
• 分析执行计划优化查询

测试阶段：
• 进行性能基准测试
• 模拟高并发场景
• 验证资源使用是否合理

生产阶段：
• 启用关键指标监控
• 设置性能阈值告警
• 定期分析监控数据
```

**⚠️ 监控注意事项**
```
避免过度监控：
• 不要每行都输出调试信息
• 合理设置监控频率
• 避免监控本身影响性能

确保监控准确性：
• 使用合适的监控指标
• 注意监控数据的时效性
• 定期校验监控结果
```

### 8.3 实际应用价值


- **开发效率**：通过监控快速定位代码问题
- **性能优化**：基于监控数据进行针对性优化
- **稳定性保障**：及时发现和处理潜在问题
- **运维支持**：为生产环境提供关键监控信息

**核心记忆**：
- 监控游标如体检，及时发现解决问题
- 性能指标是关键，执行计划要分析
- 调试信息要适度，资源监控不可少
- 工具使用需熟练，问题诊断靠经验