---
title: 4、游标循环处理与控制
---
## 📚 目录

1. [游标循环概述](#1-游标循环概述)
2. [WHILE循环控制游标](#2-WHILE循环控制游标)
3. [LOOP循环游标处理](#3-LOOP循环游标处理)
4. [循环终止条件设计](#4-循环终止条件设计)
5. [游标记录计数技术](#5-游标记录计数技术)
6. [循环异常处理机制](#6-循环异常处理机制)
7. [嵌套循环游标处理](#7-嵌套循环游标处理)
8. [游标循环性能优化](#8-游标循环性能优化)
9. [大数据集游标处理策略](#9-大数据集游标处理策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔄 游标循环概述


### 1.1 什么是游标循环


**游标循环**是指使用循环结构来逐行处理游标返回的数据记录。简单说就是**让程序自动一行一行地读取查询结果**。

```
传统方式处理数据：
SELECT * FROM users;  ← 一次性返回所有数据

游标循环方式：
OPEN cursor → FETCH第1行 → 处理 → FETCH第2行 → 处理 → ... → CLOSE cursor
```

**为什么需要游标循环？**
- **内存控制**：避免大量数据一次性加载到内存
- **逐行处理**：对每条记录进行复杂的业务逻辑处理
- **流式处理**：边读取边处理，提高效率

### 1.2 游标循环的基本结构


```
游标循环的标准流程：
┌─────────────────┐
│  声明游标        │
├─────────────────┤
│  声明变量        │
├─────────────────┤
│  打开游标        │
├─────────────────┤
│ ┌─────────────┐ │
│ │  开始循环    │ │
│ │  FETCH数据   │ │
│ │  判断结束    │ │
│ │  处理数据    │ │
│ └─────────────┘ │
├─────────────────┤
│  关闭游标        │
└─────────────────┘
```

### 1.3 MySQL中的循环类型


| 循环类型 | **语法特点** | **适用场景** | **优缺点** |
|---------|-------------|-------------|-----------|
| **WHILE循环** | `条件在前` | `已知循环条件` | `灵活，但需手动控制` |
| **LOOP循环** | `无限循环+LEAVE` | `需要精确控制退出` | `控制精确，代码稍复杂` |
| **REPEAT循环** | `条件在后` | `至少执行一次` | `适合特定场景` |

---

## 2. ⏰ WHILE循环控制游标


### 2.1 WHILE循环基本语法


**WHILE循环**是最常用的游标循环方式，**先判断条件再执行**。

```sql
-- WHILE循环语法结构
WHILE 条件表达式 DO
    -- 循环体代码
    FETCH cursor_name INTO variable_list;
    -- 业务处理逻辑
END WHILE;
```

### 2.2 完整的WHILE循环游标示例


```sql
DELIMITER //
CREATE PROCEDURE process_users()
BEGIN
    -- ① 声明变量
    DECLARE user_id INT;
    DECLARE user_name VARCHAR(50);
    DECLARE user_email VARCHAR(100);
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE processed_count INT DEFAULT 0;
    
    -- ② 声明游标
    DECLARE user_cursor CURSOR FOR
        SELECT id, name, email FROM users WHERE status = 'active';
    
    -- ③ 声明异常处理器
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- ④ 打开游标
    OPEN user_cursor;
    
    -- ⑤ WHILE循环处理
    user_loop: WHILE NOT done DO
        -- 获取数据
        FETCH user_cursor INTO user_id, user_name, user_email;
        
        -- 检查是否到达末尾
        IF done THEN
            LEAVE user_loop;
        END IF;
        
        -- 业务处理逻辑
        INSERT INTO user_log (user_id, action, created_at) 
        VALUES (user_id, 'processed', NOW());
        
        -- 更新计数器
        SET processed_count = processed_count + 1;
        
        -- 输出处理信息
        SELECT CONCAT('处理用户: ', user_name, ', 邮箱: ', user_email) AS info;
        
    END WHILE;
    
    -- ⑥ 关闭游标
    CLOSE user_cursor;
    
    -- ⑦ 输出处理结果
    SELECT CONCAT('总共处理了 ', processed_count, ' 个用户') AS result;
END //
DELIMITER ;
```

### 2.3 WHILE循环的关键要点


**🔸 循环控制变量**
```sql
-- 常用的控制变量模式
DECLARE done BOOLEAN DEFAULT FALSE;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

-- 检查循环结束条件
WHILE NOT done DO
    FETCH cursor_name INTO variables;
    IF done THEN
        LEAVE loop_label;  -- 退出循环
    END IF;
    -- 处理逻辑
END WHILE;
```

**🔸 防止无限循环**
```sql
-- 添加安全计数器
DECLARE max_records INT DEFAULT 10000;
DECLARE current_count INT DEFAULT 0;

WHILE NOT done AND current_count < max_records DO
    -- 处理逻辑
    SET current_count = current_count + 1;
END WHILE;
```

---

## 3. 🔁 LOOP循环游标处理


### 3.1 LOOP循环基本语法


**LOOP循环**是**无限循环**，需要使用`LEAVE`语句手动退出。

```sql
-- LOOP循环语法结构
loop_label: LOOP
    -- 循环体代码
    FETCH cursor_name INTO variable_list;
    
    -- 退出条件检查
    IF 退出条件 THEN
        LEAVE loop_label;
    END IF;
    
    -- 业务处理逻辑
END LOOP;
```

### 3.2 LOOP循环游标示例


```sql
DELIMITER //
CREATE PROCEDURE batch_update_salary()
BEGIN
    DECLARE emp_id INT;
    DECLARE current_salary DECIMAL(10,2);
    DECLARE dept_name VARCHAR(50);
    DECLARE done BOOLEAN DEFAULT FALSE;
    
    -- 声明游标：查询需要调薪的员工
    DECLARE salary_cursor CURSOR FOR
        SELECT e.id, e.salary, d.name
        FROM employees e 
        JOIN departments d ON e.dept_id = d.id
        WHERE e.salary < 5000;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN salary_cursor;
    
    -- LOOP循环处理
    salary_loop: LOOP
        -- 获取数据
        FETCH salary_cursor INTO emp_id, current_salary, dept_name;
        
        -- 检查是否结束
        IF done THEN
            LEAVE salary_loop;  -- 退出循环
        END IF;
        
        -- 根据部门调整薪资
        CASE 
            WHEN dept_name = 'IT' THEN
                UPDATE employees SET salary = current_salary * 1.15 WHERE id = emp_id;
            WHEN dept_name = 'Sales' THEN
                UPDATE employees SET salary = current_salary * 1.10 WHERE id = emp_id;
            ELSE
                UPDATE employees SET salary = current_salary * 1.05 WHERE id = emp_id;
        END CASE;
        
        -- 记录调薪日志
        INSERT INTO salary_history (emp_id, old_salary, new_salary, change_date)
        VALUES (emp_id, current_salary, current_salary * 1.1, NOW());
        
    END LOOP;
    
    CLOSE salary_cursor;
    SELECT '薪资调整完成' AS message;
END //
DELIMITER ;
```

### 3.3 LOOP vs WHILE的选择


```
WHILE循环适用场景：
✅ 循环条件明确简单
✅ 标准的游标处理流程
✅ 代码可读性要求高

LOOP循环适用场景：
✅ 需要多个退出条件
✅ 复杂的循环控制逻辑
✅ 需要在循环中间退出
```

---

## 4. ⛔ 循环终止条件设计


### 4.1 标准终止条件


**最基本的终止条件**是检测游标是否到达数据末尾。

```sql
-- 标准终止条件设置
DECLARE done BOOLEAN DEFAULT FALSE;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

-- 在循环中检查
IF done THEN
    LEAVE loop_label;
END IF;
```

### 4.2 多重终止条件


```sql
DELIMITER //
CREATE PROCEDURE safe_data_migration()
BEGIN
    DECLARE record_id INT;
    DECLARE record_data TEXT;
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE error_count INT DEFAULT 0;
    DECLARE max_errors INT DEFAULT 5;
    DECLARE processed_count INT DEFAULT 0;
    DECLARE max_records INT DEFAULT 1000;
    
    DECLARE data_cursor CURSOR FOR
        SELECT id, data FROM source_table;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION 
        BEGIN
            SET error_count = error_count + 1;
            ROLLBACK;
        END;
    
    OPEN data_cursor;
    
    migration_loop: WHILE TRUE DO
        FETCH data_cursor INTO record_id, record_data;
        
        -- 🔸 多重终止条件检查
        IF done THEN
            SELECT '数据读取完成' AS exit_reason;
            LEAVE migration_loop;
        END IF;
        
        IF error_count >= max_errors THEN
            SELECT '错误次数超限，停止迁移' AS exit_reason;
            LEAVE migration_loop;
        END IF;
        
        IF processed_count >= max_records THEN
            SELECT '达到最大处理数量限制' AS exit_reason;
            LEAVE migration_loop;
        END IF;
        
        -- 数据迁移处理
        START TRANSACTION;
        INSERT INTO target_table (source_id, migrated_data, created_at)
        VALUES (record_id, record_data, NOW());
        COMMIT;
        
        SET processed_count = processed_count + 1;
        
    END WHILE;
    
    CLOSE data_cursor;
    SELECT processed_count AS total_processed, error_count AS total_errors;
END //
DELIMITER ;
```

### 4.3 超时控制机制


```sql
-- 带超时控制的游标循环
DECLARE start_time TIMESTAMP DEFAULT NOW();
DECLARE timeout_seconds INT DEFAULT 300; -- 5分钟超时

process_loop: WHILE NOT done DO
    -- 检查超时
    IF TIMESTAMPDIFF(SECOND, start_time, NOW()) > timeout_seconds THEN
        SELECT '处理超时，停止执行' AS timeout_message;
        LEAVE process_loop;
    END IF;
    
    -- 正常处理逻辑
    FETCH cursor_name INTO variables;
    -- 业务处理...
    
END WHILE;
```

---

## 5. 📊 游标记录计数技术


### 5.1 基本计数方法


```sql
DELIMITER //
CREATE PROCEDURE count_and_process()
BEGIN
    DECLARE user_id INT;
    DECLARE user_name VARCHAR(100);
    DECLARE done BOOLEAN DEFAULT FALSE;
    
    -- 📊 计数相关变量
    DECLARE total_count INT DEFAULT 0;
    DECLARE success_count INT DEFAULT 0;
    DECLARE error_count INT DEFAULT 0;
    
    DECLARE user_cursor CURSOR FOR
        SELECT id, name FROM users WHERE status = 'pending';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION 
        SET error_count = error_count + 1;
    
    OPEN user_cursor;
    
    processing_loop: WHILE NOT done DO
        FETCH user_cursor INTO user_id, user_name;
        
        IF done THEN
            LEAVE processing_loop;
        END IF;
        
        SET total_count = total_count + 1;
        
        -- 模拟业务处理
        IF user_id % 10 = 0 THEN
            -- 模拟处理失败
            SET error_count = error_count + 1;
        ELSE
            -- 处理成功
            UPDATE users SET status = 'processed' WHERE id = user_id;
            SET success_count = success_count + 1;
        END IF;
        
        -- 💡 每处理100条显示进度
        IF total_count % 100 = 0 THEN
            SELECT CONCAT('已处理: ', total_count, ' 条记录') AS progress;
        END IF;
        
    END WHILE;
    
    CLOSE user_cursor;
    
    -- 📈 输出统计结果
    SELECT 
        total_count AS '总处理数量',
        success_count AS '成功数量', 
        error_count AS '失败数量',
        ROUND(success_count/total_count*100, 2) AS '成功率%';
        
END //
DELIMITER ;
```

### 5.2 分组计数统计


```sql
DELIMITER //
CREATE PROCEDURE category_statistics()
BEGIN
    DECLARE prod_id INT;
    DECLARE category VARCHAR(50);
    DECLARE price DECIMAL(10,2);
    DECLARE done BOOLEAN DEFAULT FALSE;
    
    -- 📊 分类计数器
    DECLARE electronics_count INT DEFAULT 0;
    DECLARE clothing_count INT DEFAULT 0;
    DECLARE books_count INT DEFAULT 0;
    DECLARE other_count INT DEFAULT 0;
    
    -- 📊 价格统计
    DECLARE total_value DECIMAL(15,2) DEFAULT 0;
    DECLARE avg_price DECIMAL(10,2);
    
    DECLARE product_cursor CURSOR FOR
        SELECT id, category, price FROM products;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN product_cursor;
    
    stats_loop: WHILE NOT done DO
        FETCH product_cursor INTO prod_id, category, price;
        
        IF done THEN
            LEAVE stats_loop;
        END IF;
        
        -- 分类计数
        CASE category
            WHEN 'Electronics' THEN SET electronics_count = electronics_count + 1;
            WHEN 'Clothing' THEN SET clothing_count = clothing_count + 1;
            WHEN 'Books' THEN SET books_count = books_count + 1;
            ELSE SET other_count = other_count + 1;
        END CASE;
        
        -- 累计价值
        SET total_value = total_value + price;
        
    END WHILE;
    
    CLOSE product_cursor;
    
    -- 计算平均价格
    SET avg_price = total_value / (electronics_count + clothing_count + books_count + other_count);
    
    -- 📈 输出分类统计
    SELECT 
        'Electronics' AS category, electronics_count AS count
    UNION ALL
    SELECT 'Clothing', clothing_count
    UNION ALL  
    SELECT 'Books', books_count
    UNION ALL
    SELECT 'Other', other_count;
    
    SELECT 
        total_value AS '总价值',
        avg_price AS '平均价格';
        
END //
DELIMITER ;
```

---

## 6. ⚠️ 循环异常处理机制


### 6.1 基础异常处理


```sql
DELIMITER //
CREATE PROCEDURE safe_data_processing()
BEGIN
    DECLARE record_id INT;
    DECLARE record_value VARCHAR(255);
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE error_occurred BOOLEAN DEFAULT FALSE;
    DECLARE error_message TEXT;
    
    DECLARE data_cursor CURSOR FOR
        SELECT id, value FROM data_table;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 🚨 异常处理器
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        BEGIN
            GET DIAGNOSTICS CONDITION 1
                error_message = MESSAGE_TEXT;
            SET error_occurred = TRUE;
            
            -- 记录错误日志
            INSERT INTO error_log (error_message, error_time, record_id)
            VALUES (error_message, NOW(), record_id);
        END;
    
    OPEN data_cursor;
    
    process_loop: WHILE NOT done DO
        SET error_occurred = FALSE;
        
        FETCH data_cursor INTO record_id, record_value;
        
        IF done THEN
            LEAVE process_loop;
        END IF;
        
        -- 🔄 尝试处理数据
        START TRANSACTION;
        
        -- 可能出错的操作
        INSERT INTO processed_data (source_id, processed_value)
        VALUES (record_id, UPPER(record_value));
        
        -- 检查是否有错误
        IF error_occurred THEN
            ROLLBACK;
            SELECT CONCAT('记录 ', record_id, ' 处理失败: ', error_message) AS error_info;
        ELSE
            COMMIT;
        END IF;
        
    END WHILE;
    
    CLOSE data_cursor;
END //
DELIMITER ;
```

### 6.2 分级异常处理


```sql
DELIMITER //
CREATE PROCEDURE robust_data_migration()
BEGIN
    DECLARE source_id INT;
    DECLARE source_data TEXT;
    DECLARE done BOOLEAN DEFAULT FALSE;
    
    -- 📊 错误统计
    DECLARE critical_errors INT DEFAULT 0;
    DECLARE warning_errors INT DEFAULT 0;
    DECLARE total_processed INT DEFAULT 0;
    
    DECLARE migration_cursor CURSOR FOR
        SELECT id, data FROM source_table;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 🚨 SQL异常处理
    DECLARE CONTINUE HANDLER FOR 1062  -- 重复键错误
        BEGIN
            SET warning_errors = warning_errors + 1;
            INSERT INTO migration_warnings (record_id, warning_type, message)
            VALUES (source_id, 'DUPLICATE_KEY', '记录已存在，跳过插入');
        END;
    
    -- 🚨 严重错误处理
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        BEGIN
            SET critical_errors = critical_errors + 1;
            INSERT INTO migration_errors (record_id, error_code, error_message)
            VALUES (source_id, MYSQL_ERRNO(), MYSQL_ERROR());
        END;
    
    OPEN migration_cursor;
    
    migration_loop: WHILE NOT done DO
        FETCH migration_cursor INTO source_id, source_data;
        
        IF done THEN
            LEAVE migration_loop;
        END IF;
        
        SET total_processed = total_processed + 1;
        
        -- 🚨 检查严重错误数量
        IF critical_errors > 10 THEN
            SELECT '严重错误过多，停止迁移' AS stop_reason;
            LEAVE migration_loop;
        END IF;
        
        -- 数据迁移处理
        INSERT INTO target_table (source_ref, migrated_data, created_at)
        VALUES (source_id, source_data, NOW());
        
    END WHILE;
    
    CLOSE migration_cursor;
    
    -- 📊 输出处理报告
    SELECT 
        total_processed AS '总处理量',
        critical_errors AS '严重错误',
        warning_errors AS '警告数量',
        CASE 
            WHEN critical_errors = 0 THEN '迁移成功'
            WHEN critical_errors < 5 THEN '迁移完成(有少量错误)'
            ELSE '迁移失败'
        END AS '迁移状态';
        
END //
DELIMITER ;
```

---

## 7. 🔄 嵌套循环游标处理


### 7.1 双层嵌套游标


**嵌套游标**就是在一个游标循环里面再套一个游标循环，常用于处理**主从关系**的数据。

```sql
DELIMITER //
CREATE PROCEDURE process_orders_and_items()
BEGIN
    -- 外层游标变量：订单
    DECLARE order_id INT;
    DECLARE customer_id INT;
    DECLARE order_date DATE;
    DECLARE outer_done BOOLEAN DEFAULT FALSE;
    
    -- 内层游标变量：订单项
    DECLARE item_id INT;
    DECLARE product_name VARCHAR(100);
    DECLARE quantity INT;
    DECLARE price DECIMAL(10,2);
    DECLARE inner_done BOOLEAN DEFAULT FALSE;
    
    -- 统计变量
    DECLARE order_total DECIMAL(12,2);
    DECLARE item_count INT;
    
    -- 🔸 外层游标：订单
    DECLARE order_cursor CURSOR FOR
        SELECT id, customer_id, order_date 
        FROM orders 
        WHERE status = 'pending';
    
    -- 🔸 内层游标：订单项（注意：需要在循环中重新声明）
    DECLARE item_cursor CURSOR FOR
        SELECT oi.id, p.name, oi.quantity, oi.price
        FROM order_items oi
        JOIN products p ON oi.product_id = p.id
        WHERE oi.order_id = order_id;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND 
        BEGIN
            IF outer_done = FALSE THEN
                SET inner_done = TRUE;  -- 内层结束
            ELSE 
                SET outer_done = TRUE;  -- 外层结束
            END IF;
        END;
    
    OPEN order_cursor;
    
    -- 🔄 外层循环：处理每个订单
    order_loop: WHILE NOT outer_done DO
        FETCH order_cursor INTO order_id, customer_id, order_date;
        
        IF outer_done THEN
            LEAVE order_loop;
        END IF;
        
        -- 重置内层变量
        SET order_total = 0;
        SET item_count = 0;
        SET inner_done = FALSE;
        
        -- 重新打开内层游标
        OPEN item_cursor;
        
        -- 🔄 内层循环：处理订单项
        item_loop: WHILE NOT inner_done DO
            FETCH item_cursor INTO item_id, product_name, quantity, price;
            
            IF inner_done THEN
                LEAVE item_loop;
            END IF;
            
            -- 计算订单统计
            SET order_total = order_total + (quantity * price);
            SET item_count = item_count + 1;
            
            -- 输出订单项信息
            SELECT CONCAT('订单:', order_id, ', 商品:', product_name, 
                         ', 数量:', quantity, ', 小计:', quantity * price) AS item_info;
            
        END WHILE;
        
        CLOSE item_cursor;
        
        -- 更新订单总金额
        UPDATE orders 
        SET total_amount = order_total, item_count = item_count, status = 'calculated'
        WHERE id = order_id;
        
        SELECT CONCAT('订单 ', order_id, ' 处理完成，总金额：', order_total) AS order_summary;
        
    END WHILE;
    
    CLOSE order_cursor;
END //
DELIMITER ;
```

### 7.2 嵌套游标的注意事项


```
⚠️ 嵌套游标的常见问题：

1. 异常处理器冲突：
   - 内外层共用NOT FOUND处理器可能混乱
   - 需要用标志变量区分是哪层结束

2. 游标重复打开：
   - 内层游标需要在每次外层循环中重新打开
   - 忘记关闭内层游标会导致资源泄漏

3. 变量作用域：
   - 内外层变量要明确区分
   - 避免变量名冲突

4. 性能问题：
   - 嵌套查询数据量大时性能差
   - 考虑用JOIN替代嵌套游标
```

### 7.3 改进的嵌套处理方式


```sql
-- 使用独立的异常处理器
DELIMITER //
CREATE PROCEDURE improved_nested_processing()
BEGIN
    DECLARE order_id INT;
    DECLARE outer_done BOOLEAN DEFAULT FALSE;
    
    DECLARE order_cursor CURSOR FOR
        SELECT id FROM orders WHERE status = 'pending';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET outer_done = TRUE;
    
    OPEN order_cursor;
    
    order_loop: WHILE NOT outer_done DO
        FETCH order_cursor INTO order_id;
        
        IF outer_done THEN
            LEAVE order_loop;
        END IF;
        
        -- 🔧 调用单独的存储过程处理订单项
        CALL process_single_order_items(order_id);
        
    END WHILE;
    
    CLOSE order_cursor;
END //

-- 单独处理订单项的存储过程
CREATE PROCEDURE process_single_order_items(IN p_order_id INT)
BEGIN
    DECLARE item_id INT;
    DECLARE item_done BOOLEAN DEFAULT FALSE;
    
    DECLARE item_cursor CURSOR FOR
        SELECT id FROM order_items WHERE order_id = p_order_id;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET item_done = TRUE;
    
    OPEN item_cursor;
    
    item_loop: WHILE NOT item_done DO
        FETCH item_cursor INTO item_id;
        
        IF item_done THEN
            LEAVE item_loop;
        END IF;
        
        -- 处理单个订单项
        -- 业务逻辑...
        
    END WHILE;
    
    CLOSE item_cursor;
END //
DELIMITER ;
```

---

## 8. ⚡ 游标循环性能优化


### 8.1 批量处理优化


**单条处理 vs 批量处理**：每次处理多条记录而不是一条一条处理。

```sql
DELIMITER //
CREATE PROCEDURE batch_optimization_demo()
BEGIN
    DECLARE user_id INT;
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 100;
    DECLARE current_batch INT DEFAULT 0;
    
    -- 📦 批量处理容器
    DECLARE batch_ids TEXT DEFAULT '';
    
    DECLARE user_cursor CURSOR FOR
        SELECT id FROM users WHERE status = 'pending';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN user_cursor;
    
    batch_loop: WHILE NOT done DO
        FETCH user_cursor INTO user_id;
        
        IF done THEN
            -- 处理最后一批
            IF batch_ids != '' THEN
                CALL process_user_batch(batch_ids);
            END IF;
            LEAVE batch_loop;
        END IF;
        
        -- 🔸 累积批次数据
        IF batch_ids = '' THEN
            SET batch_ids = CAST(user_id AS CHAR);
        ELSE
            SET batch_ids = CONCAT(batch_ids, ',', user_id);
        END IF;
        
        SET current_batch = current_batch + 1;
        
        -- 🔸 达到批次大小时处理
        IF current_batch >= batch_size THEN
            CALL process_user_batch(batch_ids);
            SET batch_ids = '';
            SET current_batch = 0;
        END IF;
        
    END WHILE;
    
    CLOSE user_cursor;
END //

-- 批量处理存储过程
CREATE PROCEDURE process_user_batch(IN user_ids TEXT)
BEGIN
    -- 📦 一次性更新多条记录
    SET @sql = CONCAT('UPDATE users SET status = "processed", 
                       updated_at = NOW() WHERE id IN (', user_ids, ')');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    SELECT CONCAT('批量处理了 ', 
                  (LENGTH(user_ids) - LENGTH(REPLACE(user_ids, ',', '')) + 1), 
                  ' 条记录') AS batch_result;
END //
DELIMITER ;
```

### 8.2 索引优化策略


```sql
-- 💡 游标查询优化建议

-- ❌ 未优化的游标查询
DECLARE slow_cursor CURSOR FOR
    SELECT * FROM large_table 
    WHERE YEAR(created_date) = 2024 
    AND status IN ('pending', 'processing')
    ORDER BY created_date;

-- ✅ 优化后的游标查询
DECLARE fast_cursor CURSOR FOR
    SELECT id, name, status, created_date 
    FROM large_table 
    WHERE created_date >= '2024-01-01' 
    AND created_date < '2025-01-01'
    AND status IN ('pending', 'processing')
    ORDER BY id;  -- 使用主键排序更快

-- 📊 创建合适的索引
-- CREATE INDEX idx_table_date_status ON large_table(created_date, status);
```

### 8.3 内存使用优化


```sql
DELIMITER //
CREATE PROCEDURE memory_efficient_processing()
BEGIN
    DECLARE record_id INT;
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE processed_count INT DEFAULT 0;
    
    DECLARE efficient_cursor CURSOR FOR
        SELECT id FROM large_table  -- 🔸 只查询必要字段
        WHERE status = 'pending'
        ORDER BY id
        LIMIT 1000;  -- 🔸 限制处理数量
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN efficient_cursor;
    
    process_loop: WHILE NOT done DO
        FETCH efficient_cursor INTO record_id;
        
        IF done THEN
            LEAVE process_loop;
        END IF;
        
        -- 🔸 按需查询详细数据
        SELECT name, data INTO @name, @data 
        FROM large_table 
        WHERE id = record_id;
        
        -- 处理逻辑
        INSERT INTO processed_table (source_id, name, processed_data)
        VALUES (record_id, @name, UPPER(@data));
        
        SET processed_count = processed_count + 1;
        
        -- 🔸 定期提交释放锁
        IF processed_count % 50 = 0 THEN
            COMMIT;
        END IF;
        
    END WHILE;
    
    CLOSE efficient_cursor;
    COMMIT;  -- 最终提交
END //
DELIMITER ;
```

---

## 9. 📈 大数据集游标处理策略


### 9.1 分页处理策略


**大数据集**不能一次性处理，需要**分页分批**处理。

```sql
DELIMITER //
CREATE PROCEDURE large_dataset_processing()
BEGIN
    DECLARE page_size INT DEFAULT 1000;
    DECLARE current_page INT DEFAULT 0;
    DECLARE total_processed INT DEFAULT 0;
    DECLARE has_more_data BOOLEAN DEFAULT TRUE;
    
    -- 📊 处理统计
    DECLARE start_time TIMESTAMP DEFAULT NOW();
    DECLARE end_time TIMESTAMP;
    
    page_loop: WHILE has_more_data DO
        SET current_page = current_page + 1;
        
        -- 🔸 分页处理：使用LIMIT OFFSET
        CALL process_data_page(current_page, page_size, @page_count);
        
        SET total_processed = total_processed + @page_count;
        
        -- 检查是否还有数据
        IF @page_count < page_size THEN
            SET has_more_data = FALSE;
        END IF;
        
        -- 📊 显示进度
        SELECT CONCAT('第 ', current_page, ' 页处理完成，本页 ', @page_count, ' 条，累计 ', total_processed, ' 条') AS progress;
        
        -- 🔸 防止长时间运行
        IF current_page > 1000 THEN  -- 最多处理100万条记录
            SELECT '达到最大处理页数限制' AS stop_reason;
            LEAVE page_loop;
        END IF;
        
    END WHILE;
    
    SET end_time = NOW();
    
    -- 📈 输出处理报告
    SELECT 
        total_processed AS '总处理数量',
        current_page AS '处理页数',
        TIMESTAMPDIFF(SECOND, start_time, end_time) AS '耗时(秒)',
        ROUND(total_processed / TIMESTAMPDIFF(SECOND, start_time, end_time), 2) AS '处理速度(条/秒)';
        
END //

-- 分页处理子程序
CREATE PROCEDURE process_data_page(
    IN page_num INT, 
    IN page_size INT, 
    OUT processed_count INT
)
BEGIN
    DECLARE record_id INT;
    DECLARE record_data TEXT;
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE offset_value INT;
    
    SET processed_count = 0;
    SET offset_value = (page_num - 1) * page_size;
    
    -- 使用临时游标处理当前页
    BEGIN
        DECLARE page_cursor CURSOR FOR
            SELECT id, data FROM large_table 
            WHERE status = 'pending'
            ORDER BY id
            LIMIT page_size OFFSET offset_value;
        
        DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
        
        OPEN page_cursor;
        
        page_process_loop: WHILE NOT done DO
            FETCH page_cursor INTO record_id, record_data;
            
            IF done THEN
                LEAVE page_process_loop;
            END IF;
            
            -- 业务处理逻辑
            UPDATE large_table 
            SET status = 'processed', processed_data = UPPER(record_data)
            WHERE id = record_id;
            
            SET processed_count = processed_count + 1;
            
        END WHILE;
        
        CLOSE page_cursor;
    END;
    
END //
DELIMITER ;
```

### 9.2 时间窗口处理


```sql
DELIMITER //
CREATE PROCEDURE time_window_processing()
BEGIN
    DECLARE window_start DATE;
    DECLARE window_end DATE;
    DECLARE current_date DATE DEFAULT '2024-01-01';
    DECLARE end_date DATE DEFAULT CURDATE();
    DECLARE daily_count INT;
    
    -- 📅 按天处理数据
    date_loop: WHILE current_date <= end_date DO
        SET window_start = current_date;
        SET window_end = DATE_ADD(current_date, INTERVAL 1 DAY);
        
        -- 处理当天数据
        CALL process_daily_data(window_start, window_end, daily_count);
        
        SELECT CONCAT('处理日期: ', current_date, ', 数量: ', daily_count) AS daily_progress;
        
        -- 移动到下一天
        SET current_date = DATE_ADD(current_date, INTERVAL 1 DAY);
        
    END WHILE;
    
END //

CREATE PROCEDURE process_daily_data(
    IN start_date DATE, 
    IN end_date DATE, 
    OUT record_count INT
)
BEGIN
    DECLARE record_id INT;
    DECLARE done BOOLEAN DEFAULT FALSE;
    
    SET record_count = 0;
    
    BEGIN
        DECLARE daily_cursor CURSOR FOR
            SELECT id FROM transactions 
            WHERE transaction_date >= start_date 
            AND transaction_date < end_date
            AND status = 'pending';
        
        DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
        
        OPEN daily_cursor;
        
        daily_loop: WHILE NOT done DO
            FETCH daily_cursor INTO record_id;
            
            IF done THEN
                LEAVE daily_loop;
            END IF;
            
            -- 处理单条记录
            UPDATE transactions 
            SET status = 'processed', processed_date = NOW()
            WHERE id = record_id;
            
            SET record_count = record_count + 1;
            
        END WHILE;
        
        CLOSE daily_cursor;
    END;
    
END //
DELIMITER ;
```

### 9.3 断点续传机制


```sql
DELIMITER //
CREATE PROCEDURE resumable_processing()
BEGIN
    DECLARE last_processed_id INT DEFAULT 0;
    DECLARE current_id INT;
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE batch_count INT DEFAULT 0;
    
    -- 🔸 获取上次处理的断点
    SELECT COALESCE(MAX(last_id), 0) INTO last_processed_id 
    FROM processing_checkpoint 
    WHERE process_name = 'data_migration';
    
    SELECT CONCAT('从ID: ', last_processed_id, ' 开始继续处理') AS resume_info;
    
    BEGIN
        DECLARE resume_cursor CURSOR FOR
            SELECT id FROM source_table 
            WHERE id > last_processed_id 
            AND status = 'pending'
            ORDER BY id;
        
        DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
        
        OPEN resume_cursor;
        
        resume_loop: WHILE NOT done DO
            FETCH resume_cursor INTO current_id;
            
            IF done THEN
                LEAVE resume_loop;
            END IF;
            
            -- 处理数据
            INSERT INTO target_table (source_id, migrated_at)
            VALUES (current_id, NOW());
            
            SET batch_count = batch_count + 1;
            
            -- 🔸 每1000条保存一次断点
            IF batch_count % 1000 = 0 THEN
                INSERT INTO processing_checkpoint (process_name, last_id, updated_at)
                VALUES ('data_migration', current_id, NOW())
                ON DUPLICATE KEY UPDATE 
                    last_id = current_id, 
                    updated_at = NOW();
                
                COMMIT;  -- 提交断点
                SELECT CONCAT('保存断点: ', current_id) AS checkpoint_saved;
            END IF;
            
        END WHILE;
        
        CLOSE resume_cursor;
    END;
    
    -- 🏁 处理完成，清除断点
    DELETE FROM processing_checkpoint WHERE process_name = 'data_migration';
    
    SELECT CONCAT('处理完成，总计: ', batch_count, ' 条') AS final_result;
    
END //
DELIMITER ;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 游标循环本质：使用循环结构逐行处理游标数据，实现流式处理
🔸 循环类型选择：WHILE适合标准流程，LOOP适合复杂控制
🔸 终止条件设计：NOT FOUND + 多重安全检查机制
🔸 异常处理机制：分级处理，记录日志，保证数据一致性
🔸 性能优化策略：批量处理，合理索引，内存控制
🔸 大数据集处理：分页、时间窗口、断点续传策略
```

### 10.2 关键理解要点


**🔹 为什么使用游标循环？**
```
场景需求：
- 💾 内存限制：避免大量数据一次性加载
- 🔄 逐行处理：每条记录需要复杂业务逻辑
- 📊 流式计算：边读取边处理，实时统计
- 🔧 数据转换：需要对每条记录进行个性化处理

替代方案考虑：
- 简单查询 → 直接用SELECT
- 批量更新 → 用UPDATE...WHERE
- 聚合统计 → 用GROUP BY
- 数据迁移 → 考虑INSERT...SELECT
```

**🔹 循环控制的最佳实践**
```
安全设计原则：
✅ 多重终止条件：防止无限循环
✅ 异常处理机制：保证程序健壮性
✅ 进度监控：长时间运行需要进度反馈
✅ 资源管理：及时关闭游标，释放内存
✅ 事务控制：定期提交，避免长事务锁表

性能优化要点：
⚡ 批量处理：减少单条操作开销
⚡ 索引优化：游标查询要用好索引
⚡ 内存控制：只查询必要字段
⚡ 分页处理：大数据集要分批处理
```

**🔹 嵌套循环的使用场景**
```
适用情况：
✅ 主从关系数据：订单-订单项，部门-员工
✅ 层级关系处理：组织架构，分类树
✅ 关联数据分析：统计分析类需求

注意事项：
⚠️ 性能问题：嵌套查询数据量大时很慢
⚠️ 异常处理：内外层异常处理器要分离
⚠️ 资源管理：内层游标要正确开启关闭
⚠️ 可读性：复杂嵌套建议拆分成多个存储过程
```

### 10.3 实际应用指导


**📊 适用场景判断**
```
✅ 使用游标循环的场景：
- 数据量适中(万-百万级)，需要逐行复杂处理
- 需要基于每行数据做决策的业务逻辑
- 数据迁移、清洗、统计分析任务
- 需要处理进度监控的长时间任务

❌ 不适用游标循环的场景：
- 简单的查询、更新、删除操作
- 数据量极大(千万级以上)的批处理
- 实时性要求极高的在线业务
- 可以用SQL直接解决的问题
```

**🛠️ 开发实践建议**
```
代码组织：
📝 模块化设计：复杂逻辑拆分成多个存储过程
📝 统一命名：游标、变量、标签使用一致的命名规范  
📝 注释完整：关键逻辑要有清楚的注释说明
📝 错误处理：每个游标都要有完整的异常处理

测试验证：
🧪 小数据测试：先用少量数据验证逻辑正确性
🧪 性能测试：评估大数据量下的处理时间
🧪 异常测试：模拟各种异常情况的处理
🧪 并发测试：多个存储过程同时运行的影响

监控运维：
📊 处理进度：长时间运行要有进度反馈
📊 错误日志：记录详细的错误信息便于排查
📊 性能指标：监控处理速度、资源使用情况
📊 断点续传：重要任务要支持中断后继续处理
```

### 10.4 性能优化记忆要点


**⚡ 性能优化口诀**
```
游标循环要优化，批量处理是关键
索引设计要合理，只查必要字段好
大数据集要分页，时间窗口控制巧
异常处理要完善，断点续传不可少
嵌套循环需谨慎，复杂逻辑要拆分
```

**核心记忆**：
- 游标循环是MySQL中处理大量数据的重要技术
- 循环控制要考虑安全性、性能和可维护性
- 不同的循环类型适用于不同的业务场景
- 异常处理和性能优化是游标循环的关键要素
- 合理的设计模式可以让游标循环既高效又稳定