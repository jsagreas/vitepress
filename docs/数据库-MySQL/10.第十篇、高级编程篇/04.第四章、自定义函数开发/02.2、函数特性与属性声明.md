---
title: 2、函数特性与属性声明
---
## 📚 目录

1. [自定义函数基础概念](#1-自定义函数基础概念)
2. [函数特性与属性声明详解](#2-函数特性与属性声明详解)
3. [函数安全性设置](#3-函数安全性设置)
4. [实际开发应用](#4-实际开发应用)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🎯 自定义函数基础概念


### 1.1 什么是MySQL自定义函数


**简单理解**：自定义函数就像是你给MySQL"教会"一个新技能，让它能够执行你设计的特定操作并返回结果。

```sql
-- 比如创建一个计算圆面积的函数
CREATE FUNCTION circle_area(radius DOUBLE) 
RETURNS DOUBLE
READS SQL DATA
DETERMINISTIC
BEGIN
    RETURN 3.14159 * radius * radius;
END;

-- 使用函数
SELECT circle_area(5); -- 返回：78.53975
```

**核心特点**：
- **有输入有输出**：接收参数，必须返回一个值
- **可重复使用**：一次创建，到处调用
- **封装逻辑**：把复杂的计算或判断包装成简单的函数调用

### 1.2 函数 vs 存储过程的区别


```
┌─────────────────┬─────────────────┬─────────────────┐
│     特性        │    自定义函数    │    存储过程     │
├─────────────────┼─────────────────┼─────────────────┤
│ 返回值          │ 必须返回一个值   │ 可以不返回值     │
│ 调用方式        │ SELECT语句中使用 │ CALL语句调用     │
│ 参数类型        │ 只能有IN参数     │ IN/OUT/INOUT参数 │
│ 事务支持        │ 不能控制事务     │ 可以控制事务     │
│ 使用场景        │ 计算和数据处理   │ 复杂业务逻辑     │
└─────────────────┴─────────────────┴─────────────────┘
```

---

## 2. ⚙️ 函数特性与属性声明详解


### 2.1 DETERMINISTIC 确定性声明


**通俗解释**：确定性就像数学公式，同样的输入永远得到同样的输出。

```sql
-- 确定性函数示例：计算税前金额
CREATE FUNCTION calc_tax_amount(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC  -- 相同输入，相同输出
BEGIN
    RETURN amount * 0.13;  -- 税率固定13%
END;
```

**使用场景**：
- ✅ **数学计算**：加减乘除、三角函数等
- ✅ **格式转换**：字符串处理、日期格式化等
- ✅ **业务规则**：固定的计算公式

### 2.2 NOT DETERMINISTIC 非确定性声明


**通俗解释**：非确定性函数就像抽奖，同样的输入可能得到不同的输出。

```sql
-- 非确定性函数示例：获取当前时间戳
CREATE FUNCTION get_current_timestamp()
RETURNS VARCHAR(50)
NOT DETERMINISTIC  -- 每次调用结果不同
BEGIN
    RETURN CONCAT('时间:', NOW());
END;
```

**使用场景**：
- ✅ **时间相关**：获取当前时间、随机数生成
- ✅ **状态相关**：根据当前系统状态返回不同值
- ✅ **外部依赖**：依赖于外部数据的计算

### 2.3 数据访问特性声明


#### 🔸 READS SQL DATA - 数据读取


**含义**：函数会读取数据库中的数据，但不会修改。

```sql
-- 读取用户等级的函数
CREATE FUNCTION get_user_level(user_id INT)
RETURNS VARCHAR(20)
READS SQL DATA  -- 声明会读取数据
DETERMINISTIC
BEGIN
    DECLARE level_name VARCHAR(20);
    
    SELECT level INTO level_name 
    FROM users 
    WHERE id = user_id;
    
    RETURN IFNULL(level_name, '普通用户');
END;
```

#### 🔸 MODIFIES SQL DATA - 数据修改


**含义**：函数会修改数据库中的数据（增删改操作）。

```sql
-- 更新访问次数的函数
CREATE FUNCTION update_visit_count(page_name VARCHAR(100))
RETURNS INT
MODIFIES SQL DATA  -- 声明会修改数据
NOT DETERMINISTIC
BEGIN
    DECLARE new_count INT DEFAULT 0;
    
    -- 更新访问次数
    UPDATE page_stats 
    SET visit_count = visit_count + 1 
    WHERE page = page_name;
    
    -- 获取新的访问次数
    SELECT visit_count INTO new_count 
    FROM page_stats 
    WHERE page = page_name;
    
    RETURN new_count;
END;
```

#### 🔸 NO SQL - 无SQL语句


**含义**：函数内部不包含任何SQL语句，只做纯计算。

```sql
-- 纯计算函数：判断是否为偶数
CREATE FUNCTION is_even(num INT)
RETURNS BOOLEAN
NO SQL  -- 不涉及任何SQL操作
DETERMINISTIC
BEGIN
    RETURN num % 2 = 0;
END;
```

#### 🔸 CONTAINS SQL - 包含SQL但不读写数据


**含义**：包含SQL语句，但不读取或修改数据（如变量赋值）。

```sql
-- 包含SQL但不访问表的函数
CREATE FUNCTION format_message(msg VARCHAR(200))
RETURNS VARCHAR(250)
CONTAINS SQL  -- 包含SQL但不访问数据
DETERMINISTIC
BEGIN
    DECLARE formatted_msg VARCHAR(250);
    SET formatted_msg = CONCAT('[消息] ', msg, ' [时间] ', DATE_FORMAT(NOW(), '%H:%i'));
    RETURN formatted_msg;
END;
```

### 2.4 特性声明对比总结


```
访问类型选择指南：

┌─────────────────┬─────────────────┬─────────────────┐
│   函数行为      │   推荐声明      │     示例场景    │
├─────────────────┼─────────────────┼─────────────────┤
│ 纯数学计算      │ NO SQL         │ 计算器、公式     │
│ 格式化处理      │ CONTAINS SQL   │ 日期格式化       │
│ 查询数据        │ READS SQL DATA │ 获取用户信息     │
│ 更新数据        │ MODIFIES SQL   │ 计数器、日志     │
└─────────────────┴─────────────────┴─────────────────┘

确定性选择指南：
• 固定算法、数学公式 → DETERMINISTIC
• 时间、随机数、外部状态 → NOT DETERMINISTIC
```

---

## 3. 🔒 函数安全性设置


### 3.1 SQL SECURITY 安全上下文


**通俗解释**：就像给函数设置"身份证"，决定函数以谁的权限来执行。

#### 🔸 DEFINER 定义者权限


**含义**：函数以创建者的权限执行，不管谁调用都用创建者的权限。

```sql
-- 使用定义者权限的函数
CREATE DEFINER = 'admin'@'localhost'
FUNCTION get_sensitive_data(user_id INT)
RETURNS VARCHAR(100)
READS SQL DATA
SQL SECURITY DEFINER  -- 使用创建者权限
BEGIN
    -- 即使普通用户调用，也能访问敏感表
    DECLARE result VARCHAR(100);
    SELECT secret_info INTO result 
    FROM sensitive_table 
    WHERE id = user_id;
    RETURN result;
END;
```

**使用场景**：
- ✅ **权限提升**：让普通用户间接访问高权限数据
- ✅ **安全封装**：通过函数控制数据访问逻辑
- ✅ **统一接口**：提供统一的数据访问方式

#### 🔸 INVOKER 调用者权限


**含义**：函数以调用者的权限执行，权限跟着人走。

```sql
-- 使用调用者权限的函数
CREATE FUNCTION get_my_orders(user_id INT)
RETURNS INT
READS SQL DATA
SQL SECURITY INVOKER  -- 使用调用者权限
BEGIN
    DECLARE order_count INT;
    -- 调用者必须有orders表的查询权限
    SELECT COUNT(*) INTO order_count 
    FROM orders 
    WHERE customer_id = user_id;
    RETURN order_count;
END;
```

**使用场景**：
- ✅ **权限控制**：确保用户只能访问有权限的数据
- ✅ **安全审计**：操作记录到真实用户
- ✅ **灵活授权**：不同用户有不同的访问范围

### 3.2 安全性最佳实践


```sql
-- 安全的函数创建示例
CREATE DEFINER = 'app_user'@'%'
FUNCTION calculate_discount(
    customer_level VARCHAR(20),
    order_amount DECIMAL(10,2)
)
RETURNS DECIMAL(5,2)
READS SQL DATA
DETERMINISTIC
SQL SECURITY DEFINER
COMMENT '计算客户折扣，根据等级和订单金额'
BEGIN
    DECLARE discount_rate DECIMAL(5,2) DEFAULT 0.00;
    
    -- 从配置表读取折扣规则
    SELECT rate INTO discount_rate
    FROM discount_rules 
    WHERE level = customer_level 
      AND min_amount <= order_amount
    ORDER BY min_amount DESC 
    LIMIT 1;
    
    RETURN IFNULL(discount_rate, 0.00);
END;
```

**安全建议**：
- 🔸 **最小权限原则**：函数只申请必要的数据访问权限
- 🔸 **输入验证**：对函数参数进行合法性检查
- 🔸 **错误处理**：妥善处理异常情况，避免信息泄露
- 🔸 **权限审计**：定期检查函数的权限设置

---

## 4. 🚀 实际开发应用


### 4.1 常见函数开发模式


#### 🔸 数据验证函数


```sql
-- 手机号验证函数
CREATE FUNCTION is_valid_phone(phone VARCHAR(20))
RETURNS BOOLEAN
NO SQL
DETERMINISTIC
COMMENT '验证手机号格式是否正确'
BEGIN
    RETURN phone REGEXP '^1[3-9][0-9]{9}$';
END;

-- 使用示例
SELECT * FROM users WHERE is_valid_phone(mobile) = FALSE;
```

#### 🔸 业务计算函数


```sql
-- 会员积分计算函数
CREATE FUNCTION calc_points(
    amount DECIMAL(10,2),
    member_level VARCHAR(20)
)
RETURNS INT
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE rate DECIMAL(3,2);
    
    -- 根据会员等级获取积分倍率
    SELECT point_rate INTO rate 
    FROM member_config 
    WHERE level = member_level;
    
    RETURN FLOOR(amount * IFNULL(rate, 1.0));
END;
```

#### 🔸 状态转换函数


```sql
-- 订单状态描述函数
CREATE FUNCTION get_order_status_desc(status_code INT)
RETURNS VARCHAR(50)
NO SQL
DETERMINISTIC
BEGIN
    CASE status_code
        WHEN 1 THEN RETURN '待付款';
        WHEN 2 THEN RETURN '待发货';
        WHEN 3 THEN RETURN '待收货';
        WHEN 4 THEN RETURN '已完成';
        WHEN 5 THEN RETURN '已取消';
        ELSE RETURN '未知状态';
    END CASE;
END;
```

### 4.2 函数使用注意事项


**性能考虑**：
```sql
-- ❌ 避免在函数中使用复杂查询
CREATE FUNCTION bad_example(user_id INT)
RETURNS VARCHAR(1000)
READS SQL DATA
BEGIN
    -- 复杂的多表关联查询会影响性能
    DECLARE result VARCHAR(1000);
    SELECT GROUP_CONCAT(product_name) INTO result
    FROM orders o
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
    WHERE o.user_id = user_id
    GROUP BY o.user_id;
    RETURN result;
END;

-- ✅ 推荐简单的计算和验证
CREATE FUNCTION good_example(price DECIMAL(10,2))
RETURNS DECIMAL(10,2)
NO SQL
DETERMINISTIC
BEGIN
    RETURN ROUND(price * 1.13, 2);  -- 简单的税费计算
END;
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 函数特性：确定性决定了函数的可预测性和缓存策略
🔸 数据访问：正确声明函数的数据访问类型，影响性能和权限
🔸 安全设置：DEFINER vs INVOKER决定了函数的执行权限
🔸 实际应用：根据业务场景选择合适的函数设计模式
```

### 5.2 关键理解要点


**🔹 确定性的选择原则**：
```
选择DETERMINISTIC的情况：
• 纯数学计算：加减乘除、百分比计算
• 字符串处理：格式化、验证、转换
• 固定业务规则：税率计算、等级判断

选择NOT DETERMINISTIC的情况：
• 时间相关：当前时间、时间戳
• 随机值：随机数、UUID生成
• 外部状态：依赖变化的配置或状态
```

**🔹 数据访问声明的重要性**：
```
正确的声明有助于：
• MySQL优化器做出更好的执行计划
• 权限系统正确验证访问权限
• 开发者理解函数的影响范围
• 避免意外的数据修改
```

**🔹 安全性设置的选择**：
```
使用DEFINER的场景：
• 需要权限提升的封装函数
• 统一的数据访问接口
• 复杂的权限控制逻辑

使用INVOKER的场景：
• 需要审计真实用户操作
• 权限跟随调用者的场景
• 灵活的权限控制需求
```

### 5.3 实际应用价值


**业务场景应用**：
- **电商系统**：价格计算、折扣计算、积分计算函数
- **用户系统**：数据验证、等级判断、权限检查函数  
- **报表系统**：数据转换、格式化、统计计算函数
- **审计系统**：日志记录、状态转换、时间戳函数

**开发最佳实践**：
- **简单明确**：函数功能单一，逻辑简单清晰
- **性能优先**：避免复杂查询，优先考虑执行效率
- **安全可靠**：合理设置权限，做好异常处理
- **易于维护**：添加注释，遵循命名规范

**核心记忆口诀**：
- 确定性看输出，相同输入相同果
- 数据访问要声明，权限安全不能忘  
- 简单逻辑写函数，复杂业务用存储
- 性能安全放首位，维护方便是根本