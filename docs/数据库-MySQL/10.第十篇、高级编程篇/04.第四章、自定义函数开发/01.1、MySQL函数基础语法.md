---
title: 1、MySQL函数基础语法
---
## 📚 目录

1. [什么是MySQL自定义函数](#1-什么是mysql自定义函数)
2. [CREATE FUNCTION完整语法](#2-create-function完整语法)
3. [函数参数与返回值](#3-函数参数与返回值)
4. [函数体实现详解](#4-函数体实现详解)
5. [函数调用与管理](#5-函数调用与管理)
6. [函数vs存储过程区别](#6-函数vs存储过程区别)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 什么是MySQL自定义函数


MySQL自定义函数就像是你自己写的一个**小工具**，可以接收一些输入参数，经过处理后返回一个结果。

### 1.1 函数的本质理解


**💭 生活类比**
```
就像计算器上的函数：
输入：两个数字
处理：相加运算  
输出：结果

MySQL函数也一样：
输入：参数值
处理：SQL逻辑
输出：返回值
```

**🔸 核心特点**
- **必须有返回值**：每个函数都要返回一个确定的结果
- **可以有参数**：接收0个或多个输入参数
- **封装复用**：把复杂逻辑包装成简单调用
- **提高效率**：避免重复写相同的SQL代码

### 1.2 函数的实际作用


```sql
-- 不用函数的情况：每次都要写复杂计算
SELECT name, 
       CASE WHEN score >= 90 THEN '优秀'
            WHEN score >= 80 THEN '良好'
            WHEN score >= 60 THEN '及格'
            ELSE '不及格' END as grade
FROM students;

-- 用函数的情况：简单调用
SELECT name, get_grade(score) as grade FROM students;
```

---

## 2. ⚙️ CREATE FUNCTION完整语法


创建MySQL函数需要遵循固定的语法结构，每个部分都有特定的作用。

### 2.1 基础语法结构


```sql
CREATE FUNCTION 函数名(参数列表)
RETURNS 返回类型 [函数特性]
BEGIN
    函数体
    RETURN 返回值;
END
```

### 2.2 完整语法详解


```sql
CREATE FUNCTION function_name(
    parameter1 datatype,
    parameter2 datatype,
    ...
)
RETURNS return_datatype
[DETERMINISTIC | NOT DETERMINISTIC]
[READS SQL DATA | MODIFIES SQL DATA | NO SQL | CONTAINS SQL]
BEGIN
    -- 函数体逻辑
    DECLARE variable_name datatype;
    -- SQL语句
    RETURN return_value;
END
```

**🔸 语法要素说明**

| 要素 | 说明 | 是否必需 |
|------|------|----------|
| `CREATE FUNCTION` | 创建函数的关键字 | ✅ 必需 |
| `函数名` | 自定义的函数名称 | ✅ 必需 |
| `参数列表` | 输入参数，可以为空 | ⚠️ 括号必需 |
| `RETURNS` | 声明返回值类型 | ✅ 必需 |
| `函数特性` | 函数的执行特征 | ❌ 可选 |
| `BEGIN...END` | 函数体包装 | ✅ 必需 |
| `RETURN` | 返回语句 | ✅ 必需 |

### 2.3 实际创建示例


```sql
-- 简单的计算函数
DELIMITER $$
CREATE FUNCTION calculate_tax(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    DECLARE tax_rate DECIMAL(3,2) DEFAULT 0.05;
    RETURN amount * tax_rate;
END$$
DELIMITER ;
```

> **💡 重要提醒**：创建函数时需要临时改变分隔符，因为函数体内部包含分号，会与SQL语句结束符冲突。

---

## 3. 📝 函数参数与返回值


参数和返回值是函数的"输入口"和"输出口"，定义了函数与外界的数据交换方式。

### 3.1 参数定义规则


**参数语法格式：**
```sql
parameter_name datatype [DEFAULT default_value]
```

**📊 参数类型支持**

| 数据类型分类 | 具体类型 | 使用示例 |
|-------------|----------|----------|
| **数值类型** | `INT`, `DECIMAL`, `FLOAT` | `user_id INT` |
| **字符类型** | `VARCHAR`, `CHAR`, `TEXT` | `user_name VARCHAR(50)` |
| **日期类型** | `DATE`, `DATETIME`, `TIMESTAMP` | `create_time DATETIME` |
| **布尔类型** | `BOOLEAN` | `is_active BOOLEAN` |

**参数示例：**
```sql
CREATE FUNCTION process_user(
    user_id INT,                    -- 用户ID
    user_name VARCHAR(100),         -- 用户名
    birth_date DATE DEFAULT NULL,   -- 生日（可选）
    is_vip BOOLEAN DEFAULT FALSE    -- VIP状态（默认false）
)
RETURNS VARCHAR(200)
BEGIN
    -- 函数逻辑
    RETURN CONCAT('处理用户：', user_name);
END
```

### 3.2 返回值类型声明


**RETURNS关键字用法：**
```sql
RETURNS datatype [CHARSET charset_name] [COLLATE collation_name]
```

**🎯 返回值类型选择指南**

```sql
-- 返回数值
RETURNS INT              -- 整数结果
RETURNS DECIMAL(10,2)    -- 金额计算
RETURNS FLOAT            -- 浮点数计算

-- 返回字符串
RETURNS VARCHAR(255)     -- 动态长度字符串
RETURNS CHAR(10)        -- 固定长度字符串
RETURNS TEXT            -- 长文本内容

-- 返回日期时间
RETURNS DATE            -- 日期
RETURNS DATETIME        -- 日期时间
RETURNS TIMESTAMP       -- 时间戳

-- 返回布尔值
RETURNS BOOLEAN         -- 真假判断
```

### 3.3 函数特性声明


**DETERMINISTIC特性：**
```sql
-- 确定性函数：相同输入总是产生相同输出
CREATE FUNCTION add_numbers(a INT, b INT)
RETURNS INT
DETERMINISTIC  -- 明确声明为确定性
BEGIN
    RETURN a + b;
END

-- 非确定性函数：输出可能因环境而异
CREATE FUNCTION get_current_timestamp()
RETURNS DATETIME
NOT DETERMINISTIC  -- 每次调用结果可能不同
BEGIN
    RETURN NOW();
END
```

**数据访问特性：**

| 特性 | 含义 | 使用场景 |
|------|------|----------|
| `NO SQL` | 不包含SQL语句 | 纯计算函数 |
| `CONTAINS SQL` | 包含SQL但不读写数据 | 简单查询 |
| `READS SQL DATA` | 只读取数据 | 查询统计 |
| `MODIFIES SQL DATA` | 修改数据 | 数据更新 |

---

## 4. 🛠️ 函数体实现详解


函数体是函数的"大脑"，包含了所有的处理逻辑和计算步骤。

### 4.1 变量声明与使用


**变量声明语法：**
```sql
DECLARE variable_name datatype [DEFAULT default_value];
```

**实际使用示例：**
```sql
CREATE FUNCTION calculate_discount(price DECIMAL(10,2), level INT)
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    DECLARE discount_rate DECIMAL(3,2);
    DECLARE final_price DECIMAL(10,2);
    
    -- 根据等级设置折扣率
    CASE level
        WHEN 1 THEN SET discount_rate = 0.05;  -- 5%折扣
        WHEN 2 THEN SET discount_rate = 0.10;  -- 10%折扣
        WHEN 3 THEN SET discount_rate = 0.15;  -- 15%折扣
        ELSE SET discount_rate = 0.00;         -- 无折扣
    END CASE;
    
    -- 计算最终价格
    SET final_price = price * (1 - discount_rate);
    
    RETURN final_price;
END
```

### 4.2 条件控制语句


**IF-THEN-ELSE结构：**
```sql
CREATE FUNCTION get_season(month_num INT)
RETURNS VARCHAR(10)
DETERMINISTIC
BEGIN
    DECLARE season VARCHAR(10);
    
    IF month_num IN (3,4,5) THEN
        SET season = '春季';
    ELSEIF month_num IN (6,7,8) THEN
        SET season = '夏季';
    ELSEIF month_num IN (9,10,11) THEN
        SET season = '秋季';
    ELSE
        SET season = '冬季';
    END IF;
    
    RETURN season;
END
```

**CASE语句：**
```sql
CREATE FUNCTION get_week_type(day_name VARCHAR(10))
RETURNS VARCHAR(10)
DETERMINISTIC
BEGIN
    DECLARE week_type VARCHAR(10);
    
    SET week_type = CASE day_name
        WHEN 'Monday' THEN '工作日'
        WHEN 'Tuesday' THEN '工作日'
        WHEN 'Wednesday' THEN '工作日'
        WHEN 'Thursday' THEN '工作日'
        WHEN 'Friday' THEN '工作日'
        ELSE '休息日'
    END;
    
    RETURN week_type;
END
```

### 4.3 循环控制语句


**WHILE循环：**
```sql
CREATE FUNCTION calculate_factorial(n INT)
RETURNS BIGINT
DETERMINISTIC
BEGIN
    DECLARE result BIGINT DEFAULT 1;
    DECLARE counter INT DEFAULT 1;
    
    WHILE counter <= n DO
        SET result = result * counter;
        SET counter = counter + 1;
    END WHILE;
    
    RETURN result;
END
```

### 4.4 SQL查询在函数中的使用


**查询单个值：**
```sql
CREATE FUNCTION get_user_count_by_city(city_name VARCHAR(50))
RETURNS INT
READS SQL DATA
BEGIN
    DECLARE user_count INT DEFAULT 0;
    
    SELECT COUNT(*) INTO user_count 
    FROM users 
    WHERE city = city_name;
    
    RETURN user_count;
END
```

**复杂查询处理：**
```sql
CREATE FUNCTION get_average_score(student_id INT)
RETURNS DECIMAL(5,2)
READS SQL DATA
BEGIN
    DECLARE avg_score DECIMAL(5,2) DEFAULT 0.00;
    
    SELECT AVG(score) INTO avg_score
    FROM exam_scores 
    WHERE student_id = student_id 
    AND exam_date >= DATE_SUB(NOW(), INTERVAL 1 YEAR);
    
    -- 处理NULL值
    IF avg_score IS NULL THEN
        SET avg_score = 0.00;
    END IF;
    
    RETURN avg_score;
END
```

---

## 5. 🔧 函数调用与管理


创建函数后，需要知道如何正确调用和管理这些函数。

### 5.1 函数调用方式


**基本调用语法：**
```sql
SELECT function_name(parameter1, parameter2, ...);
```

**在查询中使用：**
```sql
-- 在SELECT中调用
SELECT name, calculate_tax(salary) as tax_amount
FROM employees;

-- 在WHERE条件中调用
SELECT * FROM products 
WHERE calculate_discount(price, vip_level) < 100;

-- 在INSERT中调用
INSERT INTO orders (customer_id, total_amount, tax) 
VALUES (1001, 500.00, calculate_tax(500.00));
```

**函数嵌套调用：**
```sql
-- 函数可以相互调用
SELECT name, 
       get_grade(get_average_score(student_id)) as final_grade
FROM students;
```

### 5.2 函数重载机制


MySQL **不支持**真正的函数重载，但可以通过不同的函数名实现类似效果：

```sql
-- 不能这样做（会报错）
CREATE FUNCTION calc(a INT) RETURNS INT;
CREATE FUNCTION calc(a INT, b INT) RETURNS INT;  -- 错误！

-- 正确的做法：使用不同函数名
CREATE FUNCTION calc_single(a INT) RETURNS INT;
CREATE FUNCTION calc_double(a INT, b INT) RETURNS INT;
```

### 5.3 函数元数据查看


**查看所有函数：**
```sql
-- 查看当前数据库的所有函数
SHOW FUNCTION STATUS WHERE Db = DATABASE();

-- 查看函数定义
SHOW CREATE FUNCTION function_name;
```

**查询系统表：**
```sql
-- 从information_schema查看函数信息
SELECT 
    ROUTINE_NAME as 函数名,
    ROUTINE_TYPE as 类型,
    DATA_TYPE as 返回类型,
    CREATED as 创建时间
FROM information_schema.ROUTINES 
WHERE ROUTINE_SCHEMA = DATABASE() 
AND ROUTINE_TYPE = 'FUNCTION';
```

### 5.4 函数删除


**删除函数语法：**
```sql
DROP FUNCTION [IF EXISTS] function_name;
```

**安全删除示例：**
```sql
-- 安全删除（如果存在才删除）
DROP FUNCTION IF EXISTS calculate_tax;

-- 直接删除（不存在会报错）
DROP FUNCTION calculate_tax;
```

---

## 6. ⚖️ 函数vs存储过程区别


理解函数和存储过程的区别，有助于选择合适的工具来解决问题。

### 6.1 核心区别对比


| 特征 | **函数(FUNCTION)** | **存储过程(PROCEDURE)** |
|------|-------------------|------------------------|
| **返回值** | 必须有且只能有一个 | 可以没有，可以有多个 |
| **调用方式** | 在SQL语句中直接调用 | 用CALL语句调用 |
| **参数类型** | 只支持IN参数 | 支持IN、OUT、INOUT参数 |
| **事务控制** | 不能控制事务 | 可以控制事务 |
| **SQL语句** | 可以在SELECT中使用 | 不能在SELECT中使用 |

### 6.2 使用场景对比


**📈 选择函数的场景：**
```sql
-- 计算类操作
SELECT name, calculate_tax(salary) FROM employees;

-- 数据转换
SELECT id, format_phone(phone_number) FROM contacts;

-- 条件判断
SELECT * FROM products WHERE is_discount_eligible(price, category);
```

**🔧 选择存储过程的场景：**
```sql
-- 复杂业务流程
CALL process_monthly_report(2024, 3);

-- 批量数据操作
CALL batch_update_user_status();

-- 需要返回多个结果集
CALL get_sales_summary(OUT total_sales, OUT total_orders);
```

### 6.3 语法对比示例


**函数示例：**
```sql
-- 函数：计算圆的面积
CREATE FUNCTION circle_area(radius DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    RETURN 3.14159 * radius * radius;
END;

-- 调用函数
SELECT circle_area(5.0) as area;  -- 结果：78.54
```

**存储过程示例：**
```sql
-- 存储过程：获取用户统计信息
CREATE PROCEDURE get_user_stats(
    IN city_name VARCHAR(50),
    OUT total_users INT,
    OUT active_users INT
)
BEGIN
    SELECT COUNT(*) INTO total_users
    FROM users WHERE city = city_name;
    
    SELECT COUNT(*) INTO active_users  
    FROM users WHERE city = city_name AND status = 'active';
END;

-- 调用存储过程
CALL get_user_stats('北京', @total, @active);
SELECT @total, @active;
```

### 6.4 性能与使用建议


**🎯 函数使用建议：**
- 简单计算和数据转换
- 需要在查询中直接使用的场景
- 逻辑相对简单，单一返回值

**🎯 存储过程使用建议：**
- 复杂的业务逻辑处理
- 需要事务控制的操作
- 需要返回多个结果的场景

> **📌 重要提醒**：函数在执行时会被优化器重复调用，如果函数内部有复杂查询，可能影响性能。存储过程执行一次完成所有操作，性能通常更好。

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 函数定义：CREATE FUNCTION语法，必须有RETURNS和RETURN
🔸 参数机制：支持多个输入参数，但只能返回一个值
🔸 调用方式：可以在SQL语句中直接使用，像内置函数一样
🔸 函数特性：DETERMINISTIC声明和数据访问特性
🔸 函数管理：创建、查看、删除函数的完整流程
```

### 7.2 关键理解要点


**🔹 什么时候用函数**
```
适合场景：
• 计算类操作（税率、折扣、面积等）
• 数据格式化（电话号码、日期格式等）
• 简单的条件判断逻辑
• 需要在查询中重复使用的逻辑

不适合场景：
• 复杂的业务流程处理
• 需要事务控制的操作
• 需要返回多个值或结果集
```

**🔹 函数编写最佳实践**
```
命名规范：
• 使用有意义的函数名
• 遵循统一的命名约定
• 避免与内置函数重名

性能考虑：
• 避免在函数中写复杂查询
• 谨慎使用在大量数据的查询中
• 考虑查询优化器的影响

错误处理：
• 合理处理NULL值
• 设置合适的默认值
• 添加必要的数据验证
```

### 7.3 实际应用价值


**💼 业务应用场景：**
- **电商系统**：价格计算、折扣处理、税费计算
- **用户系统**：密码验证、权限检查、积分计算
- **报表系统**：数据格式化、统计计算、条件判断
- **内容管理**：文本处理、格式转换、内容验证

**🔧 开发效率提升：**
- **代码复用**：避免重复编写相同逻辑
- **维护简便**：统一修改函数即可更新所有调用
- **逻辑封装**：复杂计算封装为简单调用
- **提高可读性**：SQL语句更加简洁明了

**核心记忆口诀：**
- 函数有返回必须有，参数可选括号留
- RETURNS声明要准确，BEGIN END包装体
- 调用就像内置函数，SELECT WHERE都能用
- 简单计算选函数，复杂流程用过程