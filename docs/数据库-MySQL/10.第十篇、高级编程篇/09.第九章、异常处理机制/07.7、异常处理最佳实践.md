---
title: 7、异常处理最佳实践
---
## 📚 目录


1. [异常处理基本原则](#1-异常处理基本原则)
2. [错误信息规范化设计](#2-错误信息规范化设计)
3. [异常处理性能优化](#3-异常处理性能优化)
4. [代码可读性与维护性](#4-代码可读性与维护性)
5. [异常处理测试策略](#5-异常处理测试策略)
6. [文档规范与团队协作](#6-文档规范与团队协作)
7. [异常处理设计模式](#7-异常处理设计模式)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 异常处理基本原则



### 1.1 什么是异常处理原则


**异常处理原则**是指在MySQL存储过程、函数中处理错误和异常情况时应该遵循的基本规范和最佳做法。这些原则帮助我们写出更健壮、可维护的数据库代码。

> 💡 **核心理念**：异常处理不是为了隐藏错误，而是为了优雅地处理错误并提供有意义的反馈

### 1.2 早发现早处理原则


**含义**：在问题发生的最早时机进行检测和处理，避免错误扩散。

```sql
-- ❌ 错误示例：问题扩散后才处理
DELIMITER $$
CREATE PROCEDURE transfer_money_bad(IN from_account INT, IN to_account INT, IN amount DECIMAL(10,2))
BEGIN
    UPDATE accounts SET balance = balance - amount WHERE id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE id = to_account;
    -- 只在最后才检查，可能已经造成数据不一致
    IF ROW_COUNT() = 0 THEN
        ROLLBACK;
    END IF;
END$$

-- ✅ 正确示例：早发现早处理
DELIMITER $$
CREATE PROCEDURE transfer_money_good(IN from_account INT, IN to_account INT, IN amount DECIMAL(10,2))
BEGIN
    DECLARE account_balance DECIMAL(10,2);
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 早期检查：账户是否存在
    SELECT balance INTO account_balance FROM accounts WHERE id = from_account FOR UPDATE;
    IF account_balance IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '转出账户不存在';
    END IF;
    
    -- 早期检查：余额是否充足
    IF account_balance < amount THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '账户余额不足';
    END IF;
    
    -- 执行转账操作
    UPDATE accounts SET balance = balance - amount WHERE id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE id = to_account;
    
    COMMIT;
END$$
```

### 1.3 异常传播原则


**含义**：让异常能够正确地向上层传播，不要吞掉重要的错误信息。

```sql
-- 异常传播层次结构图
┌─────────────────┐
│  应用层调用      │ ← 接收最终的错误信息
├─────────────────┤
│  业务逻辑层      │ ← 添加业务上下文信息
├─────────────────┤
│  数据访问层      │ ← 处理数据库相关错误
├─────────────────┤
│  MySQL存储过程   │ ← 原始错误发生点
└─────────────────┘
```

**RESIGNAL 的正确使用**：
```sql
DELIMITER $$
CREATE PROCEDURE update_user_info(IN user_id INT, IN new_email VARCHAR(255))
BEGIN
    DECLARE duplicate_email_error CONDITION FOR 1062;
    DECLARE EXIT HANDLER FOR duplicate_email_error
    BEGIN
        -- 添加业务上下文，然后重新抛出
        RESIGNAL SET MESSAGE_TEXT = CONCAT('邮箱已被使用：', new_email);
    END;
    
    UPDATE users SET email = new_email WHERE id = user_id;
END$$
```

### 1.4 资源清理原则


**含义**：无论是否发生异常，都要确保资源得到正确释放。

```sql
DELIMITER $$
CREATE PROCEDURE process_batch_data()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE temp_cursor CURSOR FOR SELECT id FROM temp_processing_table;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 异常时清理临时数据
        DROP TEMPORARY TABLE IF EXISTS temp_processing_table;
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 创建临时表处理数据
    CREATE TEMPORARY TABLE temp_processing_table AS 
    SELECT id FROM large_table WHERE status = 'pending' LIMIT 1000;
    
    -- 处理数据逻辑...
    
    -- 正常完成时清理
    DROP TEMPORARY TABLE temp_processing_table;
    COMMIT;
END$$
```

---

## 2. 📝 错误信息规范化设计



### 2.1 错误信息的重要性


**错误信息**是用户和开发人员理解问题、快速定位和解决故障的关键。规范化的错误信息能显著提高系统的可维护性。

> 📝 **设计目标**：错误信息要做到"一看就懂，快速定位，便于解决"

### 2.2 错误信息结构化设计



**标准错误信息格式**：
```
[错误级别] [错误代码] [业务模块] - [具体描述] [上下文信息]
```

```sql
-- 创建错误信息标准化的存储过程
DELIMITER $$
CREATE PROCEDURE raise_business_error(
    IN error_level VARCHAR(10),    -- ERROR, WARN, INFO
    IN error_code VARCHAR(20),     -- 业务错误代码
    IN module_name VARCHAR(50),    -- 业务模块名
    IN error_desc VARCHAR(200),    -- 具体描述
    IN context_info JSON           -- 上下文信息
)
BEGIN
    DECLARE error_message TEXT;
    
    SET error_message = CONCAT(
        '[', error_level, '] ',
        '[', error_code, '] ',
        '[', module_name, '] - ',
        error_desc
    );
    
    IF context_info IS NOT NULL THEN
        SET error_message = CONCAT(error_message, ' 上下文：', JSON_UNQUOTE(context_info));
    END IF;
    
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = error_message;
END$$

-- 使用示例
DELIMITER $$
CREATE PROCEDURE transfer_with_standard_error(IN from_id INT, IN to_id INT, IN amount DECIMAL(10,2))
BEGIN
    DECLARE account_balance DECIMAL(10,2);
    
    SELECT balance INTO account_balance FROM accounts WHERE id = from_id;
    
    IF account_balance < amount THEN
        CALL raise_business_error(
            'ERROR',
            'INSUFFICIENT_BALANCE', 
            'ACCOUNT_TRANSFER',
            '账户余额不足，无法完成转账',
            JSON_OBJECT('account_id', from_id, 'balance', account_balance, 'required', amount)
        );
    END IF;
END$$
```

### 2.3 错误代码体系设计



**分级编码体系**：
```sql
-- 错误代码规范表
CREATE TABLE error_codes (
    code VARCHAR(20) PRIMARY KEY,
    category VARCHAR(50),      -- 错误分类
    severity VARCHAR(10),      -- 严重程度
    description TEXT,          -- 详细描述
    solution TEXT             -- 解决方案提示
);

-- 示例错误代码数据
INSERT INTO error_codes VALUES 
('ACC_001', 'ACCOUNT', 'ERROR', '账户不存在', '请检查账户ID是否正确'),
('ACC_002', 'ACCOUNT', 'ERROR', '账户余额不足', '请确保账户有足够余额'),
('TRX_001', 'TRANSACTION', 'ERROR', '事务冲突', '请稍后重试'),
('VAL_001', 'VALIDATION', 'WARN', '输入参数格式错误', '请检查参数格式');
```

**错误代码使用模式**：
```sql
DELIMITER $$
CREATE FUNCTION get_error_info(error_code VARCHAR(20)) 
RETURNS JSON READS SQL DATA
BEGIN
    DECLARE error_info JSON;
    
    SELECT JSON_OBJECT(
        'code', code,
        'category', category,
        'severity', severity,
        'description', description,
        'solution', solution
    ) INTO error_info 
    FROM error_codes 
    WHERE code = error_code;
    
    RETURN IFNULL(error_info, JSON_OBJECT('code', 'UNKNOWN', 'description', '未知错误'));
END$$
```

### 2.4 多语言错误信息支持



```sql
-- 多语言错误信息表
CREATE TABLE error_messages (
    error_code VARCHAR(20),
    language VARCHAR(10),
    message TEXT,
    PRIMARY KEY (error_code, language)
);

-- 多语言错误信息获取
DELIMITER $$
CREATE FUNCTION get_localized_error(error_code VARCHAR(20), lang VARCHAR(10)) 
RETURNS TEXT READS SQL DATA
BEGIN
    DECLARE error_msg TEXT;
    
    SELECT message INTO error_msg 
    FROM error_messages 
    WHERE error_code = error_code AND language = lang;
    
    -- 如果找不到指定语言，返回默认英文
    IF error_msg IS NULL THEN
        SELECT message INTO error_msg 
        FROM error_messages 
        WHERE error_code = error_code AND language = 'en';
    END IF;
    
    RETURN IFNULL(error_msg, 'Unknown error');
END$$
```

---

## 3. ⚡ 异常处理性能优化



### 3.1 异常处理的性能成本


**性能影响**：异常处理机制本身会消耗系统资源，不当使用会严重影响性能。

> ⚠️ **重要提醒**：异常处理应该处理"异常"情况，不应该用于正常的程序流程控制

### 3.2 避免异常作为流程控制



```sql
-- ❌ 错误示例：用异常控制正常流程
DELIMITER $$
CREATE PROCEDURE find_user_bad(IN user_id INT, OUT user_name VARCHAR(255))
BEGIN
    DECLARE EXIT HANDLER FOR NOT FOUND
    BEGIN
        SET user_name = 'USER_NOT_FOUND';  -- 用异常处理正常情况
    END;
    
    SELECT name INTO user_name FROM users WHERE id = user_id;
END$$

-- ✅ 正确示例：用正常逻辑判断
DELIMITER $$
CREATE PROCEDURE find_user_good(IN user_id INT, OUT user_name VARCHAR(255))
BEGIN
    DECLARE user_count INT;
    
    SELECT COUNT(*), IFNULL(MAX(name), '') 
    INTO user_count, user_name 
    FROM users WHERE id = user_id;
    
    IF user_count = 0 THEN
        SET user_name = 'USER_NOT_FOUND';
    END IF;
END$$
```

### 3.3 异常处理器的性能优化



**性能对比测试**：
```sql
-- 性能测试场景：处理10000条记录
-- 方案1：每次都检查异常（慢）
DELIMITER $$
CREATE PROCEDURE process_records_slow()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 复杂的错误处理逻辑
        INSERT INTO error_log VALUES (NOW(), 'Processing failed');
        ROLLBACK;
    END;
    
    WHILE i <= 10000 DO
        START TRANSACTION;
        -- 每次操作都可能触发异常处理
        INSERT INTO processed_data SELECT * FROM raw_data WHERE id = i;
        COMMIT;
        SET i = i + 1;
    END WHILE;
END$$

-- 方案2：批量处理减少异常检查（快）
DELIMITER $$
CREATE PROCEDURE process_records_fast()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        INSERT INTO error_log VALUES (NOW(), 'Batch processing failed');
        ROLLBACK;
    END;
    
    START TRANSACTION;
    -- 批量操作，减少异常处理开销
    INSERT INTO processed_data 
    SELECT * FROM raw_data WHERE id BETWEEN 1 AND 10000;
    COMMIT;
END$$
```

### 3.4 异常信息缓存优化



```sql
-- 异常信息缓存表
CREATE TABLE error_cache (
    error_key VARCHAR(100) PRIMARY KEY,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_created (created_at)
);

-- 缓存机制的异常处理
DELIMITER $$
CREATE PROCEDURE handle_error_with_cache(IN error_type VARCHAR(50), IN context_data JSON)
BEGIN
    DECLARE cached_message TEXT;
    DECLARE error_key VARCHAR(100);
    
    SET error_key = MD5(CONCAT(error_type, IFNULL(JSON_UNQUOTE(context_data), '')));
    
    -- 先查缓存
    SELECT error_message INTO cached_message 
    FROM error_cache 
    WHERE error_key = error_key 
    AND created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR);
    
    IF cached_message IS NULL THEN
        -- 生成新的错误信息
        SET cached_message = CONCAT('[', error_type, '] ', 'Error occurred at ', NOW());
        
        -- 缓存错误信息
        INSERT INTO error_cache (error_key, error_message) 
        VALUES (error_key, cached_message)
        ON DUPLICATE KEY UPDATE 
        error_message = cached_message, 
        created_at = NOW();
    END IF;
    
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = cached_message;
END$$
```

---

## 4. 📖 代码可读性与维护性



### 4.1 异常处理代码的可读性


**可读性**是指代码能够被其他开发人员（包括未来的自己）轻松理解和维护的程度。

> 🎯 **目标**：让异常处理逻辑一目了然，降低代码维护成本

### 4.2 异常处理的分层设计



```sql
-- 基础异常处理层
DELIMITER $$
CREATE PROCEDURE base_error_handler(
    IN error_code VARCHAR(20),
    IN error_context JSON,
    IN should_rollback BOOLEAN
)
BEGIN
    DECLARE error_detail TEXT;
    
    -- 记录错误日志
    INSERT INTO error_logs (
        error_code, 
        error_context, 
        occurred_at, 
        session_info
    ) VALUES (
        error_code,
        error_context,
        NOW(),
        JSON_OBJECT('connection_id', CONNECTION_ID(), 'user', USER())
    );
    
    -- 获取错误详情
    SELECT description INTO error_detail 
    FROM error_codes 
    WHERE code = error_code;
    
    -- 根据需要回滚事务
    IF should_rollback THEN
        ROLLBACK;
    END IF;
    
    -- 抛出标准化错误
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = IFNULL(error_detail, '系统错误');
END$$

-- 业务逻辑层使用基础异常处理
DELIMITER $$
CREATE PROCEDURE create_order(IN customer_id INT, IN product_id INT, IN quantity INT)
BEGIN
    DECLARE product_stock INT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        CALL base_error_handler('ORD_001', JSON_OBJECT('customer_id', customer_id), TRUE);
    END;
    
    START TRANSACTION;
    
    -- 检查库存
    SELECT stock INTO product_stock FROM products WHERE id = product_id FOR UPDATE;
    
    IF product_stock < quantity THEN
        CALL base_error_handler(
            'ORD_002', 
            JSON_OBJECT('product_id', product_id, 'available', product_stock, 'required', quantity),
            TRUE
        );
    END IF;
    
    -- 创建订单逻辑...
    COMMIT;
END$$
```

### 4.3 异常处理的命名规范



**清晰的命名约定**：
```sql
-- ✅ 好的命名示例
DECLARE insufficient_balance_error CONDITION FOR SQLSTATE '45000';
DECLARE duplicate_email_handler HANDLER FOR 1062;
DECLARE transaction_rollback_handler EXIT HANDLER;

-- ❌ 不好的命名示例  
DECLARE err1 CONDITION FOR SQLSTATE '45000';
DECLARE h1 HANDLER FOR 1062;
DECLARE handler EXIT HANDLER;
```

**异常处理函数命名规范**：
```sql
-- 清晰的函数命名
DELIMITER $$
CREATE PROCEDURE validate_transfer_prerequisites(IN from_account INT, IN to_account INT, IN amount DECIMAL(10,2))
BEGIN
    -- 验证转账前置条件
END$$

CREATE PROCEDURE handle_account_not_found_error(IN account_id INT)
BEGIN
    -- 处理账户不存在错误
END$$

CREATE PROCEDURE cleanup_failed_transaction_resources()
BEGIN
    -- 清理失败事务的资源
END$$
```

### 4.4 注释和文档化



```sql
DELIMITER $$
CREATE PROCEDURE complex_business_process(IN param1 INT, IN param2 VARCHAR(255))
BEGIN
    /**
     * 复杂业务流程处理
     * 
     * 异常处理策略：
     * 1. 数据验证失败 -> 立即返回错误，不影响数据
     * 2. 业务规则冲突 -> 记录日志，回滚事务
     * 3. 系统错误 -> 全面回滚，通知管理员
     * 
     * 错误恢复机制：
     * - 自动重试：网络超时类错误
     * - 人工介入：数据一致性错误  
     * - 降级处理：非关键功能错误
     */
    
    -- 第一阶段：数据验证
    DECLARE validation_failed_handler EXIT HANDLER FOR SQLSTATE '23000'
    BEGIN
        -- 处理数据验证失败
        -- 这类错误通常是用户输入问题，不需要回滚
        RESIGNAL SET MESSAGE_TEXT = '数据验证失败，请检查输入参数';
    END;
    
    -- 第二阶段：业务规则检查  
    DECLARE business_rule_violation EXIT HANDLER FOR SQLSTATE '45000'
    BEGIN
        -- 处理业务规则冲突
        -- 需要记录详细日志用于业务分析
        INSERT INTO business_error_log (error_type, error_detail, occurred_at)
        VALUES ('BUSINESS_RULE_VIOLATION', 'Complex process failed', NOW());
        
        ROLLBACK;
        RESIGNAL;
    END;
    
    -- 第三阶段：系统错误处理
    DECLARE system_error_handler EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 处理系统级错误
        -- 全面回滚并通知运维团队
        ROLLBACK;
        
        INSERT INTO critical_error_log (severity, message, stack_trace, occurred_at)
        VALUES ('CRITICAL', 'System error in complex_business_process', 'MySQL stored procedure', NOW());
        
        RESIGNAL SET MESSAGE_TEXT = '系统错误，请联系技术支持';
    END;
    
    START TRANSACTION;
    
    -- 业务逻辑实现...
    
    COMMIT;
END$$
```

---

## 5. 🧪 异常处理测试策略



### 5.1 异常处理测试的重要性


**测试异常处理**与测试正常功能同样重要，因为异常情况往往是系统最脆弱的地方。

> 🔧 **测试理念**：好的系统不是没有错误，而是能够优雅地处理错误

### 5.2 异常测试分类



**按错误类型分类的测试策略**：
```
数据层错误测试：
├── 约束违反测试
├── 数据类型错误测试  
├── 数据长度超限测试
└── 外键约束测试

业务逻辑错误测试：
├── 业务规则违反测试
├── 状态转换错误测试
├── 权限验证失败测试
└── 并发冲突测试

系统级错误测试：
├── 连接超时测试
├── 内存不足测试
├── 磁盘空间不足测试
└── 网络中断测试
```

### 5.3 异常测试用例设计



```sql
-- 创建测试辅助表
CREATE TABLE test_results (
    test_id VARCHAR(50),
    test_description TEXT,
    expected_error VARCHAR(100),
    actual_error VARCHAR(100),
    test_status ENUM('PASS', 'FAIL'),
    test_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 异常测试框架
DELIMITER $$
CREATE PROCEDURE run_exception_test(
    IN test_id VARCHAR(50),
    IN test_description TEXT,
    IN test_procedure_name VARCHAR(100),
    IN test_params JSON,
    IN expected_error_pattern VARCHAR(100)
)
BEGIN
    DECLARE actual_error TEXT DEFAULT '';
    DECLARE test_status VARCHAR(10) DEFAULT 'FAIL';
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 actual_error = MESSAGE_TEXT;
        
        -- 检查错误是否符合预期
        IF actual_error LIKE CONCAT('%', expected_error_pattern, '%') THEN
            SET test_status = 'PASS';
        END IF;
        
        INSERT INTO test_results (test_id, test_description, expected_error, actual_error, test_status)
        VALUES (test_id, test_description, expected_error_pattern, actual_error, test_status);
    END;
    
    -- 动态执行测试过程（简化示例）
    SET @sql = CONCAT('CALL ', test_procedure_name, '(', JSON_UNQUOTE(test_params), ')');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 如果没有异常，记录为失败
    INSERT INTO test_results (test_id, test_description, expected_error, actual_error, test_status)
    VALUES (test_id, test_description, expected_error_pattern, 'NO_ERROR', 'FAIL');
END$$

-- 具体测试用例
DELIMITER $$
CREATE PROCEDURE test_transfer_insufficient_balance()
BEGIN
    CALL run_exception_test(
        'TEST_001',
        '测试余额不足时的异常处理',
        'transfer_money',
        '"1", "2", "9999999.99"',
        'INSUFFICIENT_BALANCE'
    );
END$$

CREATE PROCEDURE test_transfer_account_not_exists()
BEGIN
    CALL run_exception_test(
        'TEST_002', 
        '测试账户不存在时的异常处理',
        'transfer_money',
        '"999999", "1", "100.00"',
        '账户不存在'
    );
END$$
```

### 5.4 自动化异常测试



```sql
-- 批量执行异常测试
DELIMITER $$
CREATE PROCEDURE run_all_exception_tests()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE test_proc VARCHAR(100);
    DECLARE test_cursor CURSOR FOR 
        SELECT ROUTINE_NAME 
        FROM INFORMATION_SCHEMA.ROUTINES 
        WHERE ROUTINE_SCHEMA = DATABASE() 
        AND ROUTINE_NAME LIKE 'test_%exception%';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 清空之前的测试结果
    DELETE FROM test_results WHERE DATE(test_time) = CURDATE();
    
    OPEN test_cursor;
    test_loop: LOOP
        FETCH test_cursor INTO test_proc;
        IF done THEN
            LEAVE test_loop;
        END IF;
        
        -- 执行测试过程
        SET @sql = CONCAT('CALL ', test_proc, '()');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    CLOSE test_cursor;
    
    -- 输出测试报告
    SELECT 
        test_status,
        COUNT(*) as test_count,
        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM test_results WHERE DATE(test_time) = CURDATE()), 2) as percentage
    FROM test_results 
    WHERE DATE(test_time) = CURDATE()
    GROUP BY test_status;
END$$
```

---

## 6. 📋 文档规范与团队协作



### 6.1 异常处理文档的重要性


**文档化**是确保异常处理逻辑能被团队成员理解和维护的关键。好的文档能大大减少沟通成本和维护难度。

> 📚 **文档原则**：文档应该回答"为什么这样处理"而不仅仅是"怎样处理"

### 6.2 异常处理规范文档模板



```sql
/**
 * ===== 异常处理规范文档 =====
 * 
 * 存储过程名称: transfer_money_with_full_docs
 * 功能描述: 账户间资金转账，包含完整的异常处理逻辑
 * 
 * == 异常处理策略 ==
 * 1. 输入验证异常
 *    - 触发条件: 参数为NULL或负数
 *    - 处理方式: 立即返回，不启动事务
 *    - 错误代码: VAL_001 ~ VAL_099
 * 
 * 2. 业务规则异常  
 *    - 触发条件: 余额不足、账户状态异常
 *    - 处理方式: 记录业务日志，回滚事务
 *    - 错误代码: BIZ_001 ~ BIZ_099
 * 
 * 3. 数据库异常
 *    - 触发条件: 约束违反、连接问题
 *    - 处理方式: 全面回滚，记录系统日志
 *    - 错误代码: SYS_001 ~ SYS_099
 * 
 * == 错误恢复机制 ==
 * - 自动重试: 死锁、超时类错误（最多3次）
 * - 人工介入: 数据一致性问题
 * - 降级服务: 非关键功能错误时继续核心流程
 * 
 * == 监控告警 ==
 * - 错误率阈值: 5%（1小时内）
 * - 关键错误: 立即通知
 * - 趋势分析: 每日错误统计报告
 * 
 * 创建时间: 2024-01-21
 * 最后更新: 2024-01-21  
 * 维护人员: 张三 (zhangsan@company.com)
 */

DELIMITER $$
CREATE PROCEDURE transfer_money_with_full_docs(
    IN from_account_id INT COMMENT '转出账户ID',
    IN to_account_id INT COMMENT '转入账户ID', 
    IN transfer_amount DECIMAL(10,2) COMMENT '转账金额',
    OUT result_code VARCHAR(20) COMMENT '返回码：SUCCESS/ERROR_CODE',
    OUT result_message TEXT COMMENT '返回信息'
)
COMMENT '资金转账存储过程，包含完整异常处理和文档'
BEGIN
    -- 声明变量和异常处理器
    DECLARE from_balance DECIMAL(10,2);
    DECLARE retry_count INT DEFAULT 0;
    DECLARE max_retries INT DEFAULT 3;
    
    -- 输入验证异常处理
    DECLARE input_validation_handler EXIT HANDLER FOR SQLSTATE '45000'
    BEGIN
        SET result_code = 'VAL_001';
        SET result_message = '输入参数验证失败';
        ROLLBACK;
    END;
    
    -- 业务规则异常处理  
    DECLARE business_rule_handler EXIT HANDLER FOR SQLSTATE '45001'
    BEGIN
        SET result_code = 'BIZ_001';  
        GET DIAGNOSTICS CONDITION 1 result_message = MESSAGE_TEXT;
        ROLLBACK;
    END;
    
    -- 数据库系统异常处理
    DECLARE system_error_handler EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SET result_code = 'SYS_001';
        SET result_message = '系统错误，请联系管理员';
        ROLLBACK;
    END;
    
    retry_loop: LOOP
        START TRANSACTION;
        
        -- 业务逻辑实现...
        
        COMMIT;
        SET result_code = 'SUCCESS';
        SET result_message = '转账成功';
        LEAVE retry_loop;
        
    END LOOP retry_loop;
END$$
```

### 6.3 团队协作规范



**异常处理代码审查清单**：
```markdown
# 异常处理代码审查清单



## ✅ 基础检查项


- [ ] 是否使用了标准化的错误代码
- [ ] 是否提供了清晰的错误信息
- [ ] 是否正确处理了事务回滚
- [ ] 是否有适当的日志记录

## ✅ 设计检查项  


- [ ] 异常处理逻辑是否分层合理
- [ ] 是否避免了用异常控制正常流程
- [ ] 是否考虑了性能影响
- [ ] 是否有资源清理机制

## ✅ 文档检查项


- [ ] 是否有完整的异常处理文档
- [ ] 是否说明了各种异常的处理策略
- [ ] 是否有测试用例覆盖
- [ ] 是否有监控和告警机制
```

**团队开发规范**：
```sql
-- 团队统一的异常处理基础库
DELIMITER $$
CREATE PROCEDURE team_standard_error_handler(
    IN error_category VARCHAR(20),  -- VAL/BIZ/SYS
    IN error_code VARCHAR(20),
    IN error_context JSON,
    IN operation_name VARCHAR(100)
)
BEGIN
    DECLARE full_error_code VARCHAR(50);
    DECLARE error_message TEXT;
    
    SET full_error_code = CONCAT(error_category, '_', error_code);
    
    -- 记录到团队统一的错误日志表
    INSERT INTO team_error_logs (
        error_code,
        operation_name,
        error_context,
        user_session,
        server_info,
        occurred_at
    ) VALUES (
        full_error_code,
        operation_name,
        error_context,
        JSON_OBJECT('user', USER(), 'connection_id', CONNECTION_ID()),
        JSON_OBJECT('version', VERSION(), 'hostname', $$hostname),
        NOW()
    );
    
    -- 获取标准化错误信息
    SELECT description INTO error_message 
    FROM team_error_codes 
    WHERE code = full_error_code;
    
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = IFNULL(error_message, '未定义错误');
END$$
```

---

## 7. 🏗️ 异常处理设计模式



### 7.1 什么是异常处理设计模式


**异常处理设计模式**是在长期实践中总结出来的处理异常情况的经典方法和最佳实践，这些模式能帮助我们写出更健壮、更易维护的代码。

> 🎯 **设计模式的价值**：提供经过验证的解决方案，避免重复犯错，提高代码质量

### 7.2 责任链模式(Chain of Responsibility)



**概念**：将异常处理请求沿着处理者链进行传递，直到有处理者处理它为止。

```sql
-- 责任链模式实现：多级异常处理
DELIMITER $$
CREATE PROCEDURE handle_error_chain(
    IN error_code VARCHAR(20),
    IN error_context JSON,
    IN current_level INT DEFAULT 1
)
BEGIN
    DECLARE handled BOOLEAN DEFAULT FALSE;
    
    -- 第一级：业务级异常处理
    IF current_level = 1 AND error_code LIKE 'BIZ_%' THEN
        INSERT INTO business_error_log (error_code, context, handled_at)
        VALUES (error_code, error_context, NOW());
        
        -- 某些业务错误可以自动修复
        IF error_code = 'BIZ_STOCK_INSUFFICIENT' THEN
            CALL auto_restock_product(JSON_UNQUOTE(JSON_EXTRACT(error_context, '$.product_id')));
            SET handled = TRUE;
        END IF;
    END IF;
    
    -- 第二级：系统级异常处理
    IF NOT handled AND current_level <= 2 AND error_code LIKE 'SYS_%' THEN
        INSERT INTO system_error_log (error_code, context, severity, handled_at)
        VALUES (error_code, error_context, 'HIGH', NOW());
        
        -- 系统错误通知运维
        CALL notify_operations_team(error_code, error_context);
        SET handled = TRUE;
    END IF;
    
    -- 第三级：通用异常处理
    IF NOT handled AND current_level <= 3 THEN
        INSERT INTO general_error_log (error_code, context, handled_at)
        VALUES (error_code, error_context, NOW());
        SET handled = TRUE;
    END IF;
    
    -- 如果所有级别都无法处理，递归到下一级
    IF NOT handled AND current_level < 3 THEN
        CALL handle_error_chain(error_code, error_context, current_level + 1);
    END IF;
END$$

-- 使用责任链模式的业务过程
DELIMITER $$
CREATE PROCEDURE create_order_with_chain(IN customer_id INT, IN product_id INT, IN quantity INT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_info JSON;
        SET error_info = JSON_OBJECT(
            'customer_id', customer_id,
            'product_id', product_id, 
            'quantity', quantity,
            'operation', 'create_order'
        );
        
        CALL handle_error_chain('SYS_UNKNOWN', error_info, 1);
        RESIGNAL;
    END;
    
    -- 业务逻辑...
END$$
```

### 7.3 重试模式(Retry Pattern)



**概念**：对于临时性的错误，自动重试操作，提高系统的可靠性。

```sql
-- 重试模式实现
DELIMITER $$
CREATE PROCEDURE execute_with_retry(
    IN operation_name VARCHAR(100),
    IN operation_params JSON,
    IN max_retry_count INT DEFAULT 3,
    IN retry_delay_seconds INT DEFAULT 1
)
BEGIN
    DECLARE current_retry INT DEFAULT 0;
    DECLARE operation_success BOOLEAN DEFAULT FALSE;
    DECLARE last_error TEXT;
    
    retry_loop: WHILE current_retry <= max_retry_count AND NOT operation_success DO
        BEGIN
            DECLARE EXIT HANDLER FOR SQLEXCEPTION
            BEGIN
                GET DIAGNOSTICS CONDITION 1 last_error = MESSAGE_TEXT;
                SET current_retry = current_retry + 1;
                
                -- 记录重试日志
                INSERT INTO retry_log (operation_name, retry_count, error_message, retry_time)
                VALUES (operation_name, current_retry, last_error, NOW());
                
                -- 如果是可重试的错误类型
                IF last_error LIKE '%deadlock%' OR last_error LIKE '%timeout%' THEN
                    -- 延迟后重试
                    DO SLEEP(retry_delay_seconds);
                    ITERATE retry_loop;
                ELSE
                    -- 不可重试的错误直接退出
                    LEAVE retry_loop;
                END IF;
            END;
            
            -- 根据操作名称执行不同的操作
            CASE operation_name
                WHEN 'update_inventory' THEN
                    CALL update_inventory_operation(operation_params);
                WHEN 'process_payment' THEN
                    CALL process_payment_operation(operation_params);
                ELSE
                    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '不支持的操作类型';
            END CASE;
            
            SET operation_success = TRUE;
            
        END;
    END WHILE;
    
    -- 重试失败后的处理
    IF NOT operation_success THEN
        INSERT INTO failed_operations (operation_name, params, final_error, failed_at)
        VALUES (operation_name, operation_params, last_error, NOW());
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = CONCAT('操作失败，已重试', max_retry_count, '次：', last_error);
    END IF;
END$$
```

### 7.4 断路器模式(Circuit Breaker Pattern)



**概念**：当错误率达到阈值时，暂时停止调用可能失败的操作，避免系统资源浪费。

```sql
-- 断路器状态表
CREATE TABLE circuit_breaker_state (
    service_name VARCHAR(100) PRIMARY KEY,
    state ENUM('CLOSED', 'OPEN', 'HALF_OPEN'),
    failure_count INT DEFAULT 0,
    last_failure_time TIMESTAMP NULL,
    next_attempt_time TIMESTAMP NULL,
    failure_threshold INT DEFAULT 5,
    timeout_duration INT DEFAULT 60  -- 秒
);

-- 断路器模式实现
DELIMITER $$
CREATE PROCEDURE call_with_circuit_breaker(
    IN service_name VARCHAR(100),
    IN operation_params JSON,
    OUT result_status VARCHAR(20),
    OUT result_data JSON
)
BEGIN
    DECLARE cb_state VARCHAR(20);
    DECLARE failure_count INT;
    DECLARE failure_threshold INT;
    DECLARE next_attempt_time TIMESTAMP;
    
    -- 获取断路器状态
    SELECT state, failure_count, failure_threshold, next_attempt_time
    INTO cb_state, failure_count, failure_threshold, next_attempt_time
    FROM circuit_breaker_state 
    WHERE service_name = service_name;
    
    -- 如果断路器开启且未到重试时间
    IF cb_state = 'OPEN' AND NOW() < next_attempt_time THEN
        SET result_status = 'CIRCUIT_OPEN';
        SET result_data = JSON_OBJECT('message', '服务暂时不可用，请稍后重试');
        RETURN;
    END IF;
    
    -- 如果断路器开启但已到重试时间，切换到半开状态
    IF cb_state = 'OPEN' AND NOW() >= next_attempt_time THEN
        UPDATE circuit_breaker_state 
        SET state = 'HALF_OPEN' 
        WHERE service_name = service_name;
        SET cb_state = 'HALF_OPEN';
    END IF;
    
    BEGIN
        DECLARE EXIT HANDLER FOR SQLEXCEPTION
        BEGIN
            -- 操作失败，更新断路器状态
            UPDATE circuit_breaker_state SET 
                failure_count = failure_count + 1,
                last_failure_time = NOW(),
                state = CASE 
                    WHEN failure_count + 1 >= failure_threshold THEN 'OPEN'
                    ELSE state 
                END,
                next_attempt_time = CASE
                    WHEN failure_count + 1 >= failure_threshold THEN 
                        DATE_ADD(NOW(), INTERVAL timeout_duration SECOND)
                    ELSE next_attempt_time
                END
            WHERE service_name = service_name;
            
            SET result_status = 'ERROR';
            GET DIAGNOSTICS CONDITION 1 result_data = MESSAGE_TEXT;
            RETURN;
        END;
        
        -- 执行实际操作
        CALL execute_service_operation(service_name, operation_params, result_data);
        
        -- 操作成功，重置断路器
        UPDATE circuit_breaker_state SET 
            state = 'CLOSED',
            failure_count = 0,
            last_failure_time = NULL,
            next_attempt_time = NULL
        WHERE service_name = service_name;
        
        SET result_status = 'SUCCESS';
        
    END;
END$$
```

### 7.5 补偿模式(Compensation Pattern)



**概念**：当操作失败时，通过执行补偿操作来撤销之前的更改，保持数据一致性。

```sql
-- 补偿操作记录表
CREATE TABLE compensation_log (
    operation_id VARCHAR(50) PRIMARY KEY,
    original_operation VARCHAR(100),
    compensation_operation VARCHAR(100), 
    operation_data JSON,
    status ENUM('PENDING', 'COMPLETED', 'FAILED'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP NULL
);

-- 补偿模式实现
DELIMITER $$
CREATE PROCEDURE execute_with_compensation(
    IN operation_id VARCHAR(50),
    IN main_operation VARCHAR(100),
    IN compensation_operation VARCHAR(100),
    IN operation_data JSON
)
BEGIN
    DECLARE compensation_needed BOOLEAN DEFAULT FALSE;
    
    -- 记录补偿日志
    INSERT INTO compensation_log (operation_id, original_operation, compensation_operation, operation_data, status)
    VALUES (operation_id, main_operation, compensation_operation, operation_data, 'PENDING');
    
    BEGIN
        DECLARE EXIT HANDLER FOR SQLEXCEPTION
        BEGIN
            SET compensation_needed = TRUE;
        END;
        
        -- 执行主要操作
        CASE main_operation
            WHEN 'deduct_inventory' THEN
                UPDATE products 
                SET stock = stock - JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.quantity'))
                WHERE id = JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.product_id'));
                
            WHEN 'charge_payment' THEN
                INSERT INTO payment_records (user_id, amount, type)
                VALUES (
                    JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.user_id')),
                    JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.amount')),
                    'CHARGE'
                );
        END CASE;
        
    END;
    
    -- 如果需要补偿
    IF compensation_needed THEN
        CASE compensation_operation
            WHEN 'restore_inventory' THEN
                UPDATE products 
                SET stock = stock + JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.quantity'))
                WHERE id = JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.product_id'));
                
            WHEN 'refund_payment' THEN
                INSERT INTO payment_records (user_id, amount, type)
                VALUES (
                    JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.user_id')),
                    JSON_UNQUOTE(JSON_EXTRACT(operation_data, '$.amount')),
                    'REFUND'
                );
        END CASE;
        
        UPDATE compensation_log 
        SET status = 'COMPLETED', completed_at = NOW()
        WHERE operation_id = operation_id;
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '操作失败，已执行补偿';
    ELSE
        -- 主操作成功，删除补偿记录
        DELETE FROM compensation_log WHERE operation_id = operation_id;
    END IF;
END$$
```

---

## 8. 📋 核心要点总结



### 8.1 必须掌握的核心概念



```
🔸 异常处理原则：早发现早处理、异常传播、资源清理
🔸 错误信息规范：结构化、标准化、多语言支持
🔸 性能优化：避免异常控制流程、批量处理、缓存机制
🔸 代码可读性：分层设计、清晰命名、完整文档
🔸 测试策略：分类测试、自动化测试、异常覆盖
🔸 团队协作：统一规范、代码审查、文档化
🔸 设计模式：责任链、重试、断路器、补偿模式
```

### 8.2 关键理解要点



**🔹 异常处理的本质目的**
```
不是隐藏错误：而是优雅地处理错误
不是忽略问题：而是提供有意义的反馈  
不是万能方案：而是提高系统健壮性
不是性能负担：而是合理的可靠性投资
```

**🔹 异常处理的设计哲学**
```
预防优于治疗：尽早发现和验证问题
局部化影响：避免错误扩散到整个系统
快速失败：明确的错误好过模糊的成功
优雅降级：核心功能优先，非核心功能可妥协
```

**🔹 性能与可靠性的平衡**
```
异常处理开销：合理的可靠性投资
批量vs单条：根据业务特点选择
缓存vs实时：权衡响应速度和准确性
重试vs失败：避免无意义的资源消耗
```

### 8.3 实际应用指导



**✅ 最佳实践清单**
- 制定统一的错误代码体系
- 实现分层的异常处理架构
- 建立完善的日志记录机制
- 设计合理的重试和降级策略
- 创建全面的异常测试用例
- 编写详细的异常处理文档

**❌ 常见反模式**
- 空的异常处理块（吞掉异常）
- 用异常控制正常程序流程  
- 过度细化的异常分类
- 缺乏上下文信息的错误消息
- 没有资源清理的异常处理
- 缺乏测试的异常处理逻辑

### 8.4 发展建议



**🚀 进阶学习方向**
- 分布式系统的异常处理模式
- 微服务架构下的错误传播
- 监控和告警系统集成
- 异常处理的自动化测试
- 机器学习在异常检测中的应用

**🔧 工具和技术栈**
- 日志分析工具（ELK Stack）
- 监控系统（Prometheus, Grafana）
- 自动化测试框架
- 代码质量检查工具
- 文档生成工具

**核心记忆口诀**：
```
异常处理有原则，早发现来早处理
错误信息要规范，结构清晰易理解  
性能优化不能忘，合理设计是关键
测试文档要跟上，团队协作共维护
设计模式助开发，健壮系统人人夸
```