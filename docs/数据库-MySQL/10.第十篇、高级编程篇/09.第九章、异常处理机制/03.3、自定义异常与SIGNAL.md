---
title: 3、自定义异常与SIGNAL
---
## 📚 目录

1. [异常处理基础概念](#1-异常处理基础概念)
2. [SIGNAL语句详解](#2-SIGNAL语句详解)
3. [RESIGNAL重新抛出机制](#3-RESIGNAL重新抛出机制)
4. [自定义SQLSTATE规范](#4-自定义SQLSTATE规范)
5. [异常消息定制](#5-异常消息定制)
6. [业务异常设计](#6-业务异常设计)
7. [异常处理最佳实践](#7-异常处理最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔥 异常处理基础概念


### 1.1 什么是MySQL异常处理

**异常处理**就是当数据库操作出现问题时，我们主动控制错误的处理方式，而不是让系统随意报错。

**核心作用**：
- 🎯 **主动控制错误** - 我们决定什么时候报错
- 📝 **自定义错误信息** - 用更友好的语言告诉用户问题
- 🔄 **统一错误格式** - 让所有错误都按同一个标准
- 🛡️ **保护业务逻辑** - 避免系统崩溃

```
现实类比：
就像银行ATM机，当余额不足时：
❌ 系统默认：ERROR 1001 INSUFFICIENT_FUNDS  
✅ 自定义后：您的账户余额不足，请充值后再试
```

### 1.2 MySQL异常处理的核心组件

```
异常处理体系
├── 🎯 SIGNAL    ← 主动抛出异常
├── 🔄 RESIGNAL  ← 重新抛出异常  
├── 📋 SQLSTATE  ← 异常状态码
├── 💬 MESSAGE   ← 异常描述信息
└── 🔧 CONDITION ← 异常条件定义
```

**通俗理解**：
- **SIGNAL** = 主动喊"出错了！"
- **RESIGNAL** = 接到错误后，再喊一遍给上级
- **SQLSTATE** = 错误的身份证号
- **MESSAGE** = 用人话解释错误

---

## 2. ⚡ SIGNAL语句详解


### 2.1 SIGNAL基本语法

**SIGNAL**就是MySQL中主动抛出异常的命令，相当于程序员主动说"这里有问题！"

```sql
-- 基本语法
SIGNAL SQLSTATE 'value'
    [SET property = value, ...]

-- 最简单的例子
SIGNAL SQLSTATE '45000' 
    SET MESSAGE_TEXT = '用户余额不足';
```

### 2.2 SIGNAL语法详解


**基础抛出异常**：
```sql
DELIMITER //
CREATE PROCEDURE check_balance(IN user_id INT, IN amount DECIMAL(10,2))
BEGIN
    DECLARE current_balance DECIMAL(10,2);
    
    -- 查询当前余额
    SELECT balance INTO current_balance 
    FROM user_account 
    WHERE id = user_id;
    
    -- 检查余额是否足够
    IF current_balance < amount THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = '账户余额不足，无法完成交易';
    END IF;
END //
DELIMITER ;
```

**带详细信息的异常**：
```sql
DELIMITER //
CREATE PROCEDURE validate_age(IN user_age INT)
BEGIN
    IF user_age < 18 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = '用户年龄不符合要求',
                MYSQL_ERRNO = 1001,
                CLASS_ORIGIN = 'BUSINESS_RULE',
                SUBCLASS_ORIGIN = 'AGE_VALIDATION';
    END IF;
END //
DELIMITER ;
```

### 2.3 SIGNAL属性详解

```sql
SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = '错误描述信息',      -- 用户看到的错误消息
        MYSQL_ERRNO = 1001,               -- 自定义错误号
        CONSTRAINT_CATALOG = '',          -- 约束目录
        CONSTRAINT_SCHEMA = '',           -- 约束模式
        CONSTRAINT_NAME = '',             -- 约束名称
        CATALOG_NAME = '',                -- 目录名
        SCHEMA_NAME = '',                 -- 模式名
        TABLE_NAME = 'users',             -- 相关表名
        COLUMN_NAME = 'age',              -- 相关列名
        CURSOR_NAME = '';                 -- 游标名
```

**实际应用示例**：
```sql
DELIMITER //
CREATE PROCEDURE update_product_stock(
    IN product_id INT, 
    IN quantity INT
)
BEGIN
    DECLARE current_stock INT;
    
    SELECT stock INTO current_stock 
    FROM products 
    WHERE id = product_id;
    
    IF current_stock < quantity THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = CONCAT('商品库存不足，当前库存：', current_stock, '，需要：', quantity),
                MYSQL_ERRNO = 2001,
                TABLE_NAME = 'products',
                COLUMN_NAME = 'stock';
    END IF;
    
    -- 更新库存
    UPDATE products 
    SET stock = stock - quantity 
    WHERE id = product_id;
END //
DELIMITER ;
```

---

## 3. 🔄 RESIGNAL重新抛出机制


### 3.1 什么是RESIGNAL

**RESIGNAL**就是接到一个异常后，再把它传递给上级处理，就像层层上报一样。

**使用场景**：
- 📤 **异常转发** - 把底层错误传给上层
- 🔄 **异常包装** - 给原始错误加上更多信息
- 📝 **错误日志** - 记录错误后再抛出

### 3.2 RESIGNAL基本用法


**简单重新抛出**：
```sql
DELIMITER //
CREATE PROCEDURE safe_divide(IN a INT, IN b INT, OUT result DECIMAL(10,2))
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 记录错误日志
        INSERT INTO error_log(error_time, error_msg) 
        VALUES(NOW(), '除法运算发生错误');
        
        -- 重新抛出原始异常
        RESIGNAL;
    END;
    
    -- 执行除法运算
    SET result = a / b;
END //
DELIMITER ;
```

**修改错误信息后重新抛出**：
```sql
DELIMITER //
CREATE PROCEDURE process_order(IN order_id INT)
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLSTATE '23000'  -- 违反约束
    BEGIN
        RESIGNAL SET 
            MESSAGE_TEXT = '订单处理失败：数据完整性约束违反',
            MYSQL_ERRNO = 3001;
    END;
    
    -- 订单处理逻辑
    INSERT INTO order_items(order_id, product_id, quantity) 
    VALUES(order_id, 999, 1);  -- 可能违反外键约束
END //
DELIMITER ;
```

### 3.3 异常链传播示例


**多层异常处理**：
```sql
-- 底层：数据访问层
DELIMITER //
CREATE PROCEDURE dao_update_user(IN user_id INT, IN new_email VARCHAR(100))
BEGIN
    DECLARE user_count INT;
    
    SELECT COUNT(*) INTO user_count FROM users WHERE id = user_id;
    
    IF user_count = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = '用户不存在',
                MYSQL_ERRNO = 4001;
    END IF;
    
    UPDATE users SET email = new_email WHERE id = user_id;
END //

-- 中层：业务逻辑层
CREATE PROCEDURE service_update_user(IN user_id INT, IN new_email VARCHAR(100))
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLSTATE '45000'
    BEGIN
        RESIGNAL SET 
            MESSAGE_TEXT = CONCAT('用户信息更新失败：', MESSAGE_TEXT),
            MYSQL_ERRNO = 5001;
    END;
    
    CALL dao_update_user(user_id, new_email);
END //

-- 上层：控制器层
CREATE PROCEDURE controller_update_user(IN user_id INT, IN new_email VARCHAR(100))
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLSTATE '45000'
    BEGIN
        INSERT INTO operation_log(user_id, operation, error_msg, log_time)
        VALUES(user_id, 'UPDATE_EMAIL', MESSAGE_TEXT, NOW());
        
        RESIGNAL SET MESSAGE_TEXT = '系统繁忙，请稍后重试';
    END;
    
    CALL service_update_user(user_id, new_email);
END //
DELIMITER ;
```

---

## 4. 📋 自定义SQLSTATE规范


### 4.1 SQLSTATE编码规则

**SQLSTATE**是一个5位字符的错误代码，就像异常的身份证号。

**编码格式**：`CCSSS`
- **CC** - 类别码（Class）
- **SSS** - 子类别码（Subclass）

```
标准SQLSTATE示例：
┌─────┬────────────────┬──────────────────┐
│ 代码 │     含义        │       说明        │
├─────┼────────────────┼──────────────────┤
│ 00000│ 成功           │ 操作正常完成      │
│ 01xxx│ 警告           │ 有警告信息        │
│ 02xxx│ 未找到数据      │ 查询无结果        │
│ 23xxx│ 完整性约束违反  │ 违反主键/外键等   │
│ 45xxx│ 用户自定义异常  │ 我们可以自由使用  │
└─────┴────────────────┴──────────────────┘
```

### 4.2 自定义SQLSTATE设计


**业务异常分类设计**：
```sql
-- 用户相关异常：450xx
SIGNAL SQLSTATE '45001' SET MESSAGE_TEXT = '用户名已存在';
SIGNAL SQLSTATE '45002' SET MESSAGE_TEXT = '用户密码格式错误';
SIGNAL SQLSTATE '45003' SET MESSAGE_TEXT = '用户账户已被锁定';

-- 订单相关异常：451xx  
SIGNAL SQLSTATE '45101' SET MESSAGE_TEXT = '订单状态不允许修改';
SIGNAL SQLSTATE '45102' SET MESSAGE_TEXT = '订单金额超出限制';
SIGNAL SQLSTATE '45103' SET MESSAGE_TEXT = '订单商品库存不足';

-- 支付相关异常：452xx
SIGNAL SQLSTATE '45201' SET MESSAGE_TEXT = '支付金额不符';
SIGNAL SQLSTATE '45202' SET MESSAGE_TEXT = '支付渠道不可用';
SIGNAL SQLSTATE '45203' SET MESSAGE_TEXT = '账户余额不足';
```

**异常分类体系**：
```
自定义异常编码体系
├── 450xx - 用户管理异常
│   ├── 45001 - 用户名冲突
│   ├── 45002 - 密码格式错误  
│   └── 45003 - 账户状态异常
├── 451xx - 订单业务异常
│   ├── 45101 - 订单状态错误
│   ├── 45102 - 金额超限
│   └── 45103 - 库存不足
└── 452xx - 支付相关异常
    ├── 45201 - 金额不符
    ├── 45202 - 渠道故障
    └── 45203 - 余额不足
```

---

## 5. 💬 异常消息定制


### 5.1 动态消息生成

**根据具体情况生成个性化的错误消息**，让用户更容易理解问题。

```sql
DELIMITER //
CREATE PROCEDURE transfer_money(
    IN from_user INT, 
    IN to_user INT, 
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE from_balance DECIMAL(10,2);
    DECLARE from_username VARCHAR(50);
    DECLARE to_username VARCHAR(50);
    
    -- 获取转账方信息
    SELECT balance, username INTO from_balance, from_username 
    FROM users WHERE id = from_user;
    
    -- 获取收款方信息
    SELECT username INTO to_username 
    FROM users WHERE id = to_user;
    
    -- 检查余额
    IF from_balance < amount THEN
        SIGNAL SQLSTATE '45203'
            SET MESSAGE_TEXT = CONCAT(
                '转账失败：', from_username, 
                ' 的账户余额(￥', from_balance, 
                ')不足以支付￥', amount, 
                '给', to_username
            );
    END IF;
    
    -- 执行转账...
END //
DELIMITER ;
```

### 5.2 多语言异常消息


**创建异常消息表**：
```sql
CREATE TABLE error_messages (
    error_code VARCHAR(10),
    language VARCHAR(10),
    message_template TEXT,
    PRIMARY KEY(error_code, language)
);

-- 插入多语言消息
INSERT INTO error_messages VALUES
('45203', 'zh', '账户余额不足，当前余额：{balance}，需要：{amount}'),
('45203', 'en', 'Insufficient balance: current {balance}, required {amount}'),
('45001', 'zh', '用户名 {username} 已被使用'),
('45001', 'en', 'Username {username} is already taken');
```

**支持多语言的异常处理**：
```sql
DELIMITER //
CREATE PROCEDURE register_user(
    IN username VARCHAR(50),
    IN language VARCHAR(10) DEFAULT 'zh'
)
BEGIN
    DECLARE user_count INT;
    DECLARE error_msg TEXT;
    
    -- 检查用户名是否存在
    SELECT COUNT(*) INTO user_count 
    FROM users WHERE username = username;
    
    IF user_count > 0 THEN
        -- 获取对应语言的错误消息
        SELECT REPLACE(message_template, '{username}', username) 
        INTO error_msg
        FROM error_messages 
        WHERE error_code = '45001' AND language = language;
        
        SIGNAL SQLSTATE '45001' SET MESSAGE_TEXT = error_msg;
    END IF;
    
    -- 注册用户逻辑...
END //
DELIMITER ;
```

---

## 6. 🏗️ 业务异常设计


### 6.1 异常分层设计

**将异常按业务层次分类**，便于管理和处理。

```
异常处理架构
┌─────────────────────────────────────┐
│              应用层                  │ ← 用户友好的错误消息
├─────────────────────────────────────┤
│              业务层                  │ ← 业务规则异常
├─────────────────────────────────────┤  
│              数据层                  │ ← 数据完整性异常
├─────────────────────────────────────┤
│              系统层                  │ ← 系统资源异常
└─────────────────────────────────────┘
```

**业务异常基础框架**：
```sql
-- 创建异常配置表
CREATE TABLE business_exceptions (
    exception_code VARCHAR(10) PRIMARY KEY,
    exception_name VARCHAR(100),
    category VARCHAR(50),
    severity ENUM('LOW', 'MEDIUM', 'HIGH', 'CRITICAL'),
    default_message TEXT,
    is_retryable BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入异常定义
INSERT INTO business_exceptions VALUES
('45001', 'UserAlreadyExists', 'USER_MANAGEMENT', 'MEDIUM', '用户已存在', FALSE, NOW()),
('45101', 'InsufficientStock', 'INVENTORY', 'HIGH', '库存不足', FALSE, NOW()),
('45201', 'PaymentFailed', 'PAYMENT', 'CRITICAL', '支付失败', TRUE, NOW());
```

### 6.2 统一异常处理器


**创建通用异常处理存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE handle_business_exception(
    IN exception_code VARCHAR(10),
    IN context_data JSON
)
BEGIN
    DECLARE exception_msg TEXT;
    DECLARE severity_level VARCHAR(20);
    DECLARE is_retryable BOOLEAN;
    
    -- 获取异常配置
    SELECT default_message, severity, is_retryable 
    INTO exception_msg, severity_level, is_retryable
    FROM business_exceptions 
    WHERE exception_code = exception_code;
    
    -- 记录异常日志
    INSERT INTO exception_log(
        exception_code, 
        severity, 
        message, 
        context_data, 
        occur_time
    ) VALUES(
        exception_code, 
        severity_level, 
        exception_msg, 
        context_data, 
        NOW()
    );
    
    -- 根据严重级别决定处理方式
    CASE severity_level
        WHEN 'CRITICAL' THEN
            -- 关键异常：发送报警
            CALL send_alert(exception_code, exception_msg);
        WHEN 'HIGH' THEN  
            -- 高级异常：记录详细日志
            CALL log_detailed_error(exception_code, context_data);
        ELSE
            -- 普通异常：标准日志
            NULL;
    END CASE;
    
    -- 抛出异常
    SIGNAL SQLSTATE exception_code SET MESSAGE_TEXT = exception_msg;
END //
DELIMITER ;
```

### 6.3 异常处理实践案例


**电商下单完整异常处理**：
```sql
DELIMITER //
CREATE PROCEDURE place_order(
    IN user_id INT,
    IN product_id INT, 
    IN quantity INT
)
BEGIN
    DECLARE user_balance DECIMAL(10,2);
    DECLARE product_price DECIMAL(10,2);
    DECLARE product_stock INT;
    DECLARE total_amount DECIMAL(10,2);
    
    -- 异常处理器
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 回滚事务
        ROLLBACK;
        -- 重新抛出异常
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 1. 检查用户状态
    IF NOT EXISTS(SELECT 1 FROM users WHERE id = user_id AND status = 'ACTIVE') THEN
        CALL handle_business_exception('45003', JSON_OBJECT('user_id', user_id));
    END IF;
    
    -- 2. 检查商品库存
    SELECT price, stock INTO product_price, product_stock 
    FROM products WHERE id = product_id;
    
    IF product_stock < quantity THEN
        CALL handle_business_exception('45101', 
            JSON_OBJECT('product_id', product_id, 'required', quantity, 'available', product_stock)
        );
    END IF;
    
    -- 3. 检查用户余额
    SELECT balance INTO user_balance FROM users WHERE id = user_id;
    SET total_amount = product_price * quantity;
    
    IF user_balance < total_amount THEN
        CALL handle_business_exception('45203',
            JSON_OBJECT('user_id', user_id, 'balance', user_balance, 'required', total_amount)
        );
    END IF;
    
    -- 4. 执行下单操作
    INSERT INTO orders(user_id, product_id, quantity, total_amount, status) 
    VALUES(user_id, product_id, quantity, total_amount, 'PENDING');
    
    UPDATE products SET stock = stock - quantity WHERE id = product_id;
    UPDATE users SET balance = balance - total_amount WHERE id = user_id;
    
    COMMIT;
END //
DELIMITER ;
```

---

## 7. 🎯 异常处理最佳实践


### 7.1 异常设计原则


**🔸 明确性原则**
```sql
-- ❌ 不明确的错误消息
SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '操作失败';

-- ✅ 明确的错误消息  
SIGNAL SQLSTATE '45203' SET MESSAGE_TEXT = '转账失败：余额不足，当前余额￥1250.00，需要￥2000.00';
```

**🔸 一致性原则**
```sql
-- 统一的异常格式
DELIMITER //
CREATE PROCEDURE throw_business_exception(
    IN error_code VARCHAR(10),
    IN error_message TEXT,
    IN error_context JSON DEFAULT NULL
)
BEGIN
    SIGNAL SQLSTATE error_code 
        SET MESSAGE_TEXT = error_message,
            MYSQL_ERRNO = CAST(error_code AS UNSIGNED);
END //
DELIMITER ;
```

### 7.2 性能优化建议


**🔸 避免过度异常处理**
```sql
-- ❌ 过度检查
DELIMITER //
CREATE PROCEDURE bad_example(IN user_id INT)
BEGIN
    -- 每个小操作都检查
    IF user_id IS NULL THEN SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ID不能为空'; END IF;
    IF user_id <= 0 THEN SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ID必须大于0'; END IF;
    IF user_id > 999999 THEN SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ID超出范围'; END IF;
    -- ... 更多检查
END //

-- ✅ 合理检查
CREATE PROCEDURE good_example(IN user_id INT)
BEGIN
    -- 集中关键检查
    IF user_id IS NULL OR user_id <= 0 OR user_id > 999999 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户ID格式错误';
    END IF;
END //
DELIMITER ;
```

### 7.3 监控与日志


**异常监控表设计**：
```sql
CREATE TABLE exception_monitor (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    exception_code VARCHAR(10),
    occur_count INT DEFAULT 1,
    last_occur_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    hour_slot TINYINT, -- 0-23小时
    date_slot DATE,
    INDEX idx_code_date (exception_code, date_slot),
    INDEX idx_time (last_occur_time)
);

-- 异常统计触发器
DELIMITER //
CREATE TRIGGER exception_stats_trigger
AFTER INSERT ON exception_log
FOR EACH ROW
BEGIN
    INSERT INTO exception_monitor(exception_code, hour_slot, date_slot)
    VALUES(NEW.exception_code, HOUR(NOW()), DATE(NOW()))
    ON DUPLICATE KEY UPDATE 
        occur_count = occur_count + 1,
        last_occur_time = NOW();
END //
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 SIGNAL：主动抛出异常的命令，控制错误发生
🔸 RESIGNAL：重新抛出异常，用于异常链传播
🔸 SQLSTATE：5位异常编码，45xxx为用户自定义
🔸 MESSAGE_TEXT：异常描述信息，要写得用户能理解
🔸 异常处理器：DECLARE HANDLER捕获和处理异常
```

### 8.2 关键理解要点


**🔹 何时使用SIGNAL vs RESIGNAL**
```
SIGNAL使用场景：
- 业务规则验证失败
- 数据完整性检查
- 权限验证不通过

RESIGNAL使用场景：  
- 异常日志记录后重新抛出
- 异常信息包装和转换
- 异常层次传播
```

**🔹 SQLSTATE编码策略**
```
编码规划：
450xx - 用户相关异常
451xx - 订单相关异常  
452xx - 支付相关异常
453xx - 库存相关异常

每类异常留出足够编码空间便于扩展
```

### 8.3 实际应用价值


**📊 业务场景应用**
```
电商系统：
- 下单时库存检查
- 支付时余额验证
- 退款时状态检查

金融系统：
- 转账时风控检查
- 开户时身份验证
- 交易时额度验证

内容管理：
- 发布时权限检查
- 删除时引用检查
- 修改时版本冲突
```

**🔧 开发实践**
- **统一异常格式**：便于前端统一处理
- **分层异常设计**：不同层次不同粒度
- **异常监控统计**：及时发现系统问题
- **多语言支持**：国际化应用必备

**核心记忆**：
- SIGNAL主动抛异常，RESIGNAL层层传
- 45开头自定义，错误信息要说清
- 业务异常分类好，监控日志不能少
- 异常处理要适度，性能体验两不误