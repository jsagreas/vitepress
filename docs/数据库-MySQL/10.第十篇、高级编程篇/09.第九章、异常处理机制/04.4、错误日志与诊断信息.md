---
title: 4、错误日志与诊断信息
---
## 📚 目录

1. [错误日志与诊断信息概述](#1-错误日志与诊断信息概述)
2. [GET DIAGNOSTICS语法详解](#2-get-diagnostics语法详解)
3. [条件信息获取机制](#3-条件信息获取机制)
4. [错误堆栈跟踪技术](#4-错误堆栈跟踪技术)
5. [日志记录策略](#5-日志记录策略)
6. [诊断区域管理](#6-诊断区域管理)
7. [错误上下文信息](#7-错误上下文信息)
8. [调试信息收集](#8-调试信息收集)
9. [诊断信息结构化存储](#9-诊断信息结构化存储)
10. [错误追踪链路](#10-错误追踪链路)
11. [诊断信息可视化](#11-诊断信息可视化)
12. [核心要点总结](#12-核心要点总结)

---

## 1. 🔍 错误日志与诊断信息概述


### 1.1 什么是MySQL诊断信息


**诊断信息**就是MySQL在执行SQL语句时产生的详细错误和状态信息，帮助我们了解程序哪里出了问题。

```
简单理解：
医生看病需要检查报告 → MySQL程序出错需要诊断信息
体检报告告诉你身体状况 → 诊断信息告诉你程序执行状况
```

**核心作用**：
- **🔧 问题定位**：快速找到错误发生的位置
- **📊 状态监控**：了解SQL执行的详细情况  
- **🛠️ 调试支持**：为程序调试提供详细信息
- **📝 日志记录**：记录系统运行状态

### 1.2 诊断信息的分类


```
诊断信息类型：

🔴 错误信息（Error）
├─ 语法错误：SQL写错了
├─ 权限错误：没有操作权限
└─ 数据错误：违反约束条件

🟡 警告信息（Warning）
├─ 数据截断：数据太长被截断
├─ 类型转换：自动类型转换
└─ 性能建议：查询可以优化

🟢 提示信息（Note）
├─ 操作提示：成功执行信息
├─ 统计信息：影响行数等
└─ 状态信息：连接状态等
```

### 1.3 为什么需要诊断信息


**传统错误处理的问题**：
```sql
-- 只能知道出错了，但不知道具体原因
INSERT INTO users (email) VALUES ('invalid-email');
-- ERROR 1062: Duplicate entry
```

**有了诊断信息**：
```sql
-- 可以获取详细的错误原因、位置、上下文
GET DIAGNOSTICS @error_count = NUMBER;
GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO, @msg = MESSAGE_TEXT;
-- 知道：错误码、错误消息、发生位置等详细信息
```

---

## 2. 📋 GET DIAGNOSTICS语法详解


### 2.1 GET DIAGNOSTICS基本概念


**GET DIAGNOSTICS**是MySQL提供的专门语句，用来获取SQL执行后的诊断信息，就像医生查看检查报告一样。

**基本语法结构**：
```sql
-- 获取语句级别信息
GET DIAGNOSTICS @var_name = statement_information_item;

-- 获取条件级别信息  
GET DIAGNOSTICS CONDITION condition_number @var_name = condition_information_item;
```

### 2.2 语句级别诊断信息


语句级别信息告诉我们整个SQL执行的总体情况：

```sql
DELIMITER $$

CREATE PROCEDURE demo_statement_diagnostics()
BEGIN
    DECLARE v_row_count INT;
    DECLARE v_warning_count INT;
    
    -- 执行一个可能产生警告的操作
    INSERT INTO test_table (name) VALUES 
        ('张三'), ('李四'), ('王五');
    
    -- 获取语句级别的诊断信息
    GET DIAGNOSTICS 
        v_row_count = ROW_COUNT,        -- 影响的行数
        v_warning_count = NUMBER;       -- 警告数量
    
    SELECT v_row_count AS '影响行数', v_warning_count AS '警告数量';
END$$

DELIMITER ;
```

**常用的语句级别信息项**：

| 信息项 | 含义 | 说明 |
|--------|------|------|
| `NUMBER` | 诊断区域中的条件数量 | 包括错误、警告、提示 |
| `ROW_COUNT` | 最后一条语句影响的行数 | INSERT/UPDATE/DELETE的行数 |

### 2.3 条件级别诊断信息


条件级别信息提供每个具体错误或警告的详细内容：

```sql
DELIMITER $$

CREATE PROCEDURE demo_condition_diagnostics()
BEGIN
    DECLARE v_errno INT;
    DECLARE v_sqlstate VARCHAR(5);
    DECLARE v_message TEXT;
    DECLARE v_count INT;
    
    -- 执行一个可能出错的操作
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 获取错误总数
        GET DIAGNOSTICS v_count = NUMBER;
        
        -- 获取第一个错误的详细信息
        GET DIAGNOSTICS CONDITION 1
            v_errno = MYSQL_ERRNO,      -- MySQL错误码
            v_sqlstate = RETURNED_SQLSTATE,  -- SQL状态码
            v_message = MESSAGE_TEXT;   -- 错误消息
            
        SELECT v_count AS '错误数量', 
               v_errno AS '错误码', 
               v_sqlstate AS 'SQL状态', 
               v_message AS '错误消息';
    END;
    
    -- 故意触发一个错误
    INSERT INTO users (id, email) VALUES (1, 'test@example.com');
END$$

DELIMITER ;
```

**常用的条件级别信息项**：

| 信息项 | 类型 | 说明 |
|--------|------|------|
| `MYSQL_ERRNO` | INT | MySQL特定的错误码 |
| `RETURNED_SQLSTATE` | VARCHAR(5) | 标准SQL状态码 |
| `MESSAGE_TEXT` | TEXT | 人类可读的错误消息 |
| `SCHEMA_NAME` | VARCHAR(64) | 相关的数据库名 |
| `TABLE_NAME` | VARCHAR(64) | 相关的表名 |
| `COLUMN_NAME` | VARCHAR(64) | 相关的列名 |

---

## 3. 🎯 条件信息获取机制


### 3.1 诊断区域的工作原理


**诊断区域**就像一个临时存储器，保存最近执行的SQL语句产生的所有诊断信息。

```
诊断区域结构：
┌─────────────────────────────────┐
│          诊断区域                │
├─────────────────────────────────┤
│ 语句信息：NUMBER, ROW_COUNT     │
├─────────────────────────────────┤
│ 条件1：错误码、消息、状态        │
├─────────────────────────────────┤  
│ 条件2：警告码、消息、状态        │
├─────────────────────────────────┤
│ 条件3：提示码、消息、状态        │
└─────────────────────────────────┘
```

### 3.2 条件编号与优先级


条件按照严重程度排序，错误优先级最高：

```sql
DELIMITER $$

CREATE PROCEDURE demo_condition_priority()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE v_count INT;
    DECLARE v_level VARCHAR(20);
    DECLARE v_errno INT;
    DECLARE v_message TEXT;
    
    -- 执行一个产生多种条件的操作
    UPDATE users SET age = 'abc' WHERE id > 100;
    
    GET DIAGNOSTICS v_count = NUMBER;
    
    -- 遍历所有条件
    WHILE i <= v_count DO
        GET DIAGNOSTICS CONDITION i
            v_errno = MYSQL_ERRNO,
            v_message = MESSAGE_TEXT;
            
        -- 根据错误码判断级别
        CASE 
            WHEN v_errno = 0 THEN SET v_level = 'Note';
            WHEN v_errno < 2000 THEN SET v_level = 'Warning';
            ELSE SET v_level = 'Error';
        END CASE;
        
        SELECT i AS '条件序号', v_level AS '级别', 
               v_errno AS '错误码', v_message AS '消息';
               
        SET i = i + 1;
    END WHILE;
END$$

DELIMITER ;
```

### 3.3 诊断信息的生命周期


```
诊断信息生命周期：

SQL执行开始 → 清空诊断区域 → 执行SQL → 产生诊断信息 → 下次SQL执行前清空

注意要点：
• 每条新SQL执行时会清空之前的诊断信息
• 诊断信息只在当前会话中有效
• 需要及时获取，否则会被覆盖
```

---

## 4. 🔍 错误堆栈跟踪技术


### 4.1 什么是错误堆栈跟踪


**错误堆栈跟踪**就像追踪错误的"家谱"，告诉我们错误是怎么一层层传递的。

```
错误传递链路：
存储过程A调用存储过程B → 存储过程B调用函数C → 函数C出现错误
                ↓
错误从C传递到B → 错误从B传递到A → 最终用户看到错误
```

### 4.2 实现错误堆栈跟踪


```sql
DELIMITER $$

-- 创建错误日志表
CREATE TABLE IF NOT EXISTS error_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    error_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    procedure_name VARCHAR(100),
    error_code INT,
    error_message TEXT,
    call_stack TEXT
);

-- 底层函数（可能出错）
CREATE FUNCTION divide_numbers(a DECIMAL(10,2), b DECIMAL(10,2))
RETURNS DECIMAL(10,2)
READS SQL DATA
BEGIN
    DECLARE result DECIMAL(10,2);
    DECLARE v_errno INT;
    DECLARE v_message TEXT;
    
    IF b = 0 THEN
        -- 记录错误发生位置
        INSERT INTO error_log (procedure_name, error_code, error_message, call_stack)
        VALUES ('divide_numbers', 1365, '除数不能为零', 'divide_numbers');
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '除数不能为零';
    END IF;
    
    SET result = a / b;
    RETURN result;
END$$

-- 中层过程
CREATE PROCEDURE calculate_average(IN student_id INT)
BEGIN
    DECLARE v_total DECIMAL(10,2);
    DECLARE v_count INT;
    DECLARE v_average DECIMAL(10,2);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO, @msg = MESSAGE_TEXT;
        
        -- 记录错误传递
        INSERT INTO error_log (procedure_name, error_code, error_message, call_stack)
        VALUES ('calculate_average', @errno, @msg, 'main_process -> calculate_average');
        
        RESIGNAL;
    END;
    
    SELECT SUM(score), COUNT(*) INTO v_total, v_count 
    FROM scores WHERE student_id = student_id;
    
    SET v_average = divide_numbers(v_total, v_count);
    
    SELECT v_average AS '平均分';
END$$

-- 顶层主过程
CREATE PROCEDURE main_process(IN student_id INT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO, @msg = MESSAGE_TEXT;
        
        -- 记录最终错误
        INSERT INTO error_log (procedure_name, error_code, error_message, call_stack)
        VALUES ('main_process', @errno, @msg, 'main_process (top level)');
        
        -- 查询完整的错误堆栈
        SELECT * FROM error_log 
        WHERE error_time >= DATE_SUB(NOW(), INTERVAL 1 MINUTE)
        ORDER BY id;
    END;
    
    CALL calculate_average(student_id);
END$$

DELIMITER ;
```

### 4.3 堆栈信息的收集策略


```sql
-- 简化的堆栈跟踪工具
DELIMITER $$

CREATE PROCEDURE log_error_with_stack(
    IN proc_name VARCHAR(100),
    IN error_context TEXT
)
BEGIN
    DECLARE v_errno INT;
    DECLARE v_message TEXT;
    
    GET DIAGNOSTICS CONDITION 1 
        v_errno = MYSQL_ERRNO,
        v_message = MESSAGE_TEXT;
    
    INSERT INTO error_log (
        procedure_name, 
        error_code, 
        error_message, 
        call_stack
    ) VALUES (
        proc_name,
        v_errno,
        v_message,
        CONCAT(error_context, ' -> ', proc_name)
    );
END$$

DELIMITER ;
```

---

## 5. 📝 日志记录策略


### 5.1 错误日志的分级策略


将错误按严重程度分级，便于后续处理和分析：

```sql
-- 创建分级日志表
CREATE TABLE system_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    log_level ENUM('DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'),
    module_name VARCHAR(50),
    function_name VARCHAR(100),
    error_code INT,
    message TEXT,
    user_id INT,
    session_id VARCHAR(64),
    INDEX idx_log_time (log_time),
    INDEX idx_log_level (log_level)
);
```

```sql
DELIMITER $$

-- 通用日志记录过程
CREATE PROCEDURE write_log(
    IN p_level VARCHAR(10),
    IN p_module VARCHAR(50),
    IN p_function VARCHAR(100),
    IN p_message TEXT
)
BEGIN
    DECLARE v_user_id INT DEFAULT 0;
    DECLARE v_session_id VARCHAR(64);
    
    -- 获取当前用户和会话信息
    SET v_session_id = CONNECTION_ID();
    
    INSERT INTO system_logs (
        log_level, module_name, function_name, 
        message, user_id, session_id
    ) VALUES (
        p_level, p_module, p_function,
        p_message, v_user_id, v_session_id
    );
END$$

-- 专门的错误日志记录
CREATE PROCEDURE log_error(
    IN p_module VARCHAR(50),
    IN p_function VARCHAR(100)
)
BEGIN
    DECLARE v_errno INT;
    DECLARE v_message TEXT;
    DECLARE v_sqlstate VARCHAR(5);
    
    GET DIAGNOSTICS CONDITION 1
        v_errno = MYSQL_ERRNO,
        v_message = MESSAGE_TEXT,
        v_sqlstate = RETURNED_SQLSTATE;
    
    CALL write_log(
        'ERROR',
        p_module,
        p_function,
        CONCAT('错误码:', v_errno, ' SQL状态:', v_sqlstate, ' 消息:', v_message)
    );
END$$

DELIMITER ;
```

### 5.2 结构化日志记录


```sql
-- 业务操作示例（带完整日志记录）
DELIMITER $$

CREATE PROCEDURE transfer_money(
    IN from_account INT,
    IN to_account INT, 
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE v_from_balance DECIMAL(10,2);
    DECLARE v_errno INT DEFAULT 0;
    DECLARE v_message TEXT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        CALL log_error('FINANCE', 'transfer_money');
        RESIGNAL;
    END;
    
    -- 记录操作开始
    CALL write_log('INFO', 'FINANCE', 'transfer_money', 
        CONCAT('开始转账操作: 从账户', from_account, '转出', amount, '到账户', to_account));
    
    START TRANSACTION;
    
    -- 检查余额
    SELECT balance INTO v_from_balance 
    FROM accounts WHERE id = from_account FOR UPDATE;
    
    IF v_from_balance < amount THEN
        CALL write_log('WARN', 'FINANCE', 'transfer_money', '余额不足');
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '账户余额不足';
    END IF;
    
    -- 执行转账
    UPDATE accounts SET balance = balance - amount WHERE id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE id = to_account;
    
    COMMIT;
    
    -- 记录成功
    CALL write_log('INFO', 'FINANCE', 'transfer_money', '转账成功完成');
END$$

DELIMITER ;
```

---

## 6. 🗂️ 诊断区域管理


### 6.1 诊断区域的容量管理


诊断区域有容量限制，需要合理管理：

```sql
DELIMITER $$

-- 诊断信息容量检查
CREATE PROCEDURE check_diagnostics_capacity()
BEGIN
    DECLARE v_max_conditions INT DEFAULT 64;  -- MySQL默认最大条件数
    DECLARE v_current_count INT;
    
    GET DIAGNOSTICS v_current_count = NUMBER;
    
    IF v_current_count >= v_max_conditions * 0.8 THEN
        CALL write_log('WARN', 'SYSTEM', 'check_diagnostics_capacity',
            CONCAT('诊断区域使用率过高:', v_current_count, '/', v_max_conditions));
    END IF;
    
    SELECT v_current_count AS '当前条件数', v_max_conditions AS '最大容量',
           ROUND(v_current_count / v_max_conditions * 100, 2) AS '使用率%';
END$$

DELIMITER ;
```

### 6.2 诊断信息的批量处理


```sql
DELIMITER $$

-- 批量获取所有诊断信息
CREATE PROCEDURE export_all_diagnostics()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE i INT DEFAULT 1;
    DECLARE v_count INT;
    DECLARE v_errno INT;
    DECLARE v_sqlstate VARCHAR(5);
    DECLARE v_message TEXT;
    
    -- 创建临时表存储结果
    CREATE TEMPORARY TABLE temp_diagnostics (
        condition_number INT,
        error_code INT,
        sql_state VARCHAR(5),
        message TEXT
    );
    
    GET DIAGNOSTICS v_count = NUMBER;
    
    -- 循环获取每个条件的信息
    WHILE i <= v_count DO
        GET DIAGNOSTICS CONDITION i
            v_errno = MYSQL_ERRNO,
            v_sqlstate = RETURNED_SQLSTATE,
            v_message = MESSAGE_TEXT;
        
        INSERT INTO temp_diagnostics VALUES (i, v_errno, v_sqlstate, v_message);
        SET i = i + 1;
    END WHILE;
    
    -- 返回所有诊断信息
    SELECT * FROM temp_diagnostics ORDER BY condition_number;
    
    DROP TEMPORARY TABLE temp_diagnostics;
END$$

DELIMITER ;
```

---

## 7. 📊 错误上下文信息


### 7.1 上下文信息的重要性


错误上下文就像案发现场的证据，帮助我们了解错误发生时的具体情况。

```sql
DELIMITER $$

-- 创建上下文信息收集器
CREATE PROCEDURE collect_error_context(
    IN operation_name VARCHAR(100),
    IN input_params TEXT
)
BEGIN
    DECLARE v_errno INT;
    DECLARE v_message TEXT;
    DECLARE v_context JSON;
    
    GET DIAGNOSTICS CONDITION 1
        v_errno = MYSQL_ERRNO,
        v_message = MESSAGE_TEXT;
    
    -- 构建上下文JSON
    SET v_context = JSON_OBJECT(
        'timestamp', NOW(),
        'operation', operation_name,
        'input_parameters', input_params,
        'mysql_version', VERSION(),
        'connection_id', CONNECTION_ID(),
        'current_user', USER(),
        'database_name', DATABASE(),
        'error_code', v_errno,
        'error_message', v_message
    );
    
    -- 保存到上下文表
    INSERT INTO error_context_log (operation_name, context_data)
    VALUES (operation_name, v_context);
END$$

DELIMITER ;
```

### 7.2 环境信息收集


```sql
DELIMITER $$

-- 收集详细的环境信息
CREATE PROCEDURE collect_environment_info()
BEGIN
    DECLARE v_context JSON;
    
    SET v_context = JSON_OBJECT(
        'server_info', JSON_OBJECT(
            'version', VERSION(),
            'version_comment', $$version_comment,
            'hostname', $$hostname,
            'port', $$port,
            'datadir', $$datadir,
            'character_set_server', $$character_set_server
        ),
        'session_info', JSON_OBJECT(
            'connection_id', CONNECTION_ID(),
            'user', USER(),
            'current_user', CURRENT_USER(),
            'database', DATABASE(),
            'autocommit', $$autocommit,
            'tx_isolation', $$tx_isolation
        ),
        'performance_info', JSON_OBJECT(
            'max_connections', $$max_connections,
            'thread_cache_size', $$thread_cache_size,
            'query_cache_size', $$query_cache_size,
            'innodb_buffer_pool_size', $$innodb_buffer_pool_size
        )
    );
    
    SELECT JSON_PRETTY(v_context) AS '环境信息';
END$$

DELIMITER ;
```

---

## 8. 🔧 调试信息收集


### 8.1 调试模式的实现


```sql
-- 创建调试配置表
CREATE TABLE debug_config (
    module_name VARCHAR(50) PRIMARY KEY,
    debug_level INT DEFAULT 0,  -- 0:关闭 1:基础 2:详细 3:完整
    is_enabled BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 插入默认配置
INSERT INTO debug_config (module_name, debug_level, is_enabled) VALUES
('USER_AUTH', 2, TRUE),
('DATA_ACCESS', 1, TRUE),
('BUSINESS_LOGIC', 3, FALSE);
```

```sql
DELIMITER $$

-- 调试信息记录器
CREATE PROCEDURE debug_log(
    IN p_module VARCHAR(50),
    IN p_level INT,
    IN p_message TEXT
)
BEGIN
    DECLARE v_debug_level INT DEFAULT 0;
    DECLARE v_enabled BOOLEAN DEFAULT FALSE;
    
    -- 检查调试配置
    SELECT debug_level, is_enabled INTO v_debug_level, v_enabled
    FROM debug_config WHERE module_name = p_module;
    
    -- 只有在启用且级别足够时才记录
    IF v_enabled AND p_level <= v_debug_level THEN
        INSERT INTO system_logs (log_level, module_name, message)
        VALUES ('DEBUG', p_module, p_message);
    END IF;
END$$

-- 带调试的业务过程示例
CREATE PROCEDURE user_login(
    IN p_username VARCHAR(50),
    IN p_password VARCHAR(255)
)
BEGIN
    DECLARE v_user_id INT;
    DECLARE v_stored_password VARCHAR(255);
    DECLARE v_login_attempts INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        CALL debug_log('USER_AUTH', 1, 
            CONCAT('登录失败 - 用户:', p_username, ' 错误:', @error_msg));
        CALL log_error('USER_AUTH', 'user_login');
        RESIGNAL;
    END;
    
    CALL debug_log('USER_AUTH', 2, CONCAT('开始用户登录验证:', p_username));
    
    -- 查找用户
    SELECT id, password, login_attempts INTO v_user_id, v_stored_password, v_login_attempts
    FROM users WHERE username = p_username;
    
    IF v_user_id IS NULL THEN
        CALL debug_log('USER_AUTH', 1, CONCAT('用户不存在:', p_username));
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户名或密码错误';
    END IF;
    
    -- 检查密码
    IF v_stored_password != SHA2(p_password, 256) THEN
        CALL debug_log('USER_AUTH', 1, CONCAT('密码错误:', p_username));
        UPDATE users SET login_attempts = login_attempts + 1 WHERE id = v_user_id;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户名或密码错误';
    END IF;
    
    CALL debug_log('USER_AUTH', 2, CONCAT('登录成功:', p_username));
    
    -- 重置登录尝试次数
    UPDATE users SET login_attempts = 0, last_login = NOW() WHERE id = v_user_id;
    
    SELECT v_user_id AS user_id, '登录成功' AS status;
END$$

DELIMITER ;
```

---

## 9. 💾 诊断信息结构化存储


### 9.1 诊断数据模型设计


```sql
-- 主诊断信息表
CREATE TABLE diagnostics_master (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    session_id VARCHAR(64),
    operation_id VARCHAR(100),
    operation_type ENUM('SELECT', 'INSERT', 'UPDATE', 'DELETE', 'PROCEDURE', 'FUNCTION'),
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    end_time TIMESTAMP NULL,
    execution_time_ms INT,
    row_count INT,
    condition_count INT,
    status ENUM('SUCCESS', 'WARNING', 'ERROR') DEFAULT 'SUCCESS',
    INDEX idx_session (session_id),
    INDEX idx_operation (operation_id),
    INDEX idx_time (start_time)
);

-- 详细条件信息表
CREATE TABLE diagnostics_conditions (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    master_id BIGINT,
    condition_number INT,
    condition_level ENUM('ERROR', 'WARNING', 'NOTE'),
    mysql_errno INT,
    sql_state VARCHAR(5),
    message_text TEXT,
    schema_name VARCHAR(64),
    table_name VARCHAR(64),
    column_name VARCHAR(64),
    FOREIGN KEY (master_id) REFERENCES diagnostics_master(id),
    INDEX idx_master (master_id),
    INDEX idx_errno (mysql_errno)
);
```

### 9.2 自动化诊断信息存储


```sql
DELIMITER $$

-- 诊断信息自动存储器
CREATE PROCEDURE save_diagnostics_info(
    IN p_operation_id VARCHAR(100),
    IN p_operation_type VARCHAR(20),
    IN p_start_time TIMESTAMP
)
BEGIN
    DECLARE v_master_id BIGINT;
    DECLARE v_condition_count INT;
    DECLARE v_row_count INT;
    DECLARE v_execution_time INT;
    DECLARE v_status VARCHAR(10) DEFAULT 'SUCCESS';
    DECLARE i INT DEFAULT 1;
    
    -- 计算执行时间
    SET v_execution_time = TIMESTAMPDIFF(MICROSECOND, p_start_time, NOW()) / 1000;
    
    -- 获取语句级别信息
    GET DIAGNOSTICS 
        v_condition_count = NUMBER,
        v_row_count = ROW_COUNT;
    
    -- 确定状态
    IF v_condition_count > 0 THEN
        DECLARE v_first_errno INT;
        GET DIAGNOSTICS CONDITION 1 v_first_errno = MYSQL_ERRNO;
        
        IF v_first_errno >= 2000 THEN
            SET v_status = 'ERROR';
        ELSE
            SET v_status = 'WARNING';
        END IF;
    END IF;
    
    -- 插入主记录
    INSERT INTO diagnostics_master (
        session_id, operation_id, operation_type,
        start_time, end_time, execution_time_ms,
        row_count, condition_count, status
    ) VALUES (
        CONNECTION_ID(), p_operation_id, p_operation_type,
        p_start_time, NOW(), v_execution_time,
        v_row_count, v_condition_count, v_status
    );
    
    SET v_master_id = LAST_INSERT_ID();
    
    -- 插入条件详情
    WHILE i <= v_condition_count DO
        CALL save_condition_detail(v_master_id, i);
        SET i = i + 1;
    END WHILE;
    
    SELECT v_master_id AS diagnostics_id;
END$$

-- 保存单个条件详情
CREATE PROCEDURE save_condition_detail(
    IN p_master_id BIGINT,
    IN p_condition_number INT
)
BEGIN
    DECLARE v_errno INT;
    DECLARE v_sqlstate VARCHAR(5);
    DECLARE v_message TEXT;
    DECLARE v_schema VARCHAR(64);
    DECLARE v_table VARCHAR(64);
    DECLARE v_column VARCHAR(64);
    DECLARE v_level VARCHAR(10);
    
    GET DIAGNOSTICS CONDITION p_condition_number
        v_errno = MYSQL_ERRNO,
        v_sqlstate = RETURNED_SQLSTATE,
        v_message = MESSAGE_TEXT,
        v_schema = SCHEMA_NAME,
        v_table = TABLE_NAME,
        v_column = COLUMN_NAME;
    
    -- 确定条件级别
    CASE
        WHEN v_errno = 0 THEN SET v_level = 'NOTE';
        WHEN v_errno < 2000 THEN SET v_level = 'WARNING';
        ELSE SET v_level = 'ERROR';
    END CASE;
    
    INSERT INTO diagnostics_conditions (
        master_id, condition_number, condition_level,
        mysql_errno, sql_state, message_text,
        schema_name, table_name, column_name
    ) VALUES (
        p_master_id, p_condition_number, v_level,
        v_errno, v_sqlstate, v_message,
        v_schema, v_table, v_column
    );
END$$

DELIMITER ;
```

---

## 10. 🔗 错误追踪链路


### 10.1 分布式错误追踪


在复杂系统中，一个操作可能涉及多个模块，需要建立完整的追踪链路：

```sql
-- 操作链路跟踪表
CREATE TABLE operation_trace (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    trace_id VARCHAR(64),           -- 全局追踪ID
    span_id VARCHAR(64),            -- 当前操作ID
    parent_span_id VARCHAR(64),     -- 父操作ID
    operation_name VARCHAR(100),
    start_time TIMESTAMP(6),
    end_time TIMESTAMP(6),
    duration_ms DECIMAL(10,3),
    status ENUM('SUCCESS', 'ERROR'),
    error_message TEXT,
    metadata JSON,
    INDEX idx_trace_id (trace_id),
    INDEX idx_span_id (span_id),
    INDEX idx_start_time (start_time)
);
```

```sql
DELIMITER $$

-- 开始操作追踪
CREATE FUNCTION start_trace(
    p_trace_id VARCHAR(64),
    p_parent_span_id VARCHAR(64),
    p_operation_name VARCHAR(100)
) RETURNS VARCHAR(64)
READS SQL DATA
BEGIN
    DECLARE v_span_id VARCHAR(64);
    
    -- 生成span ID
    SET v_span_id = CONCAT(p_trace_id, '-', UNIX_TIMESTAMP(NOW(6)), '-', CONNECTION_ID());
    
    INSERT INTO operation_trace (
        trace_id, span_id, parent_span_id, operation_name, start_time, status
    ) VALUES (
        p_trace_id, v_span_id, p_parent_span_id, p_operation_name, NOW(6), 'SUCCESS'
    );
    
    RETURN v_span_id;
END$$

-- 结束操作追踪
CREATE PROCEDURE end_trace(
    IN p_span_id VARCHAR(64),
    IN p_status VARCHAR(10),
    IN p_error_message TEXT
)
BEGIN
    DECLARE v_start_time TIMESTAMP(6);
    DECLARE v_duration DECIMAL(10,3);
    
    SELECT start_time INTO v_start_time 
    FROM operation_trace WHERE span_id = p_span_id;
    
    SET v_duration = TIMESTAMPDIFF(MICROSECOND, v_start_time, NOW(6)) / 1000;
    
    UPDATE operation_trace SET
        end_time = NOW(6),
        duration_ms = v_duration,
        status = p_status,
        error_message = p_error_message
    WHERE span_id = p_span_id;
END$$

-- 带追踪的业务过程示例
CREATE PROCEDURE process_order_with_trace(
    IN p_trace_id VARCHAR(64),
    IN p_order_id INT
)
BEGIN
    DECLARE v_span_id VARCHAR(64);
    DECLARE v_sub_span_id VARCHAR(64);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @error_msg = MESSAGE_TEXT;
        CALL end_trace(v_span_id, 'ERROR', @error_msg);
        RESIGNAL;
    END;
    
    SET v_span_id = start_trace(p_trace_id, NULL, 'process_order');
    
    -- 验证订单
    SET v_sub_span_id = start_trace(p_trace_id, v_span_id, 'validate_order');
    CALL validate_order(p_order_id);
    CALL end_trace(v_sub_span_id, 'SUCCESS', NULL);
    
    -- 处理支付
    SET v_sub_span_id = start_trace(p_trace_id, v_span_id, 'process_payment');
    CALL process_payment(p_order_id);
    CALL end_trace(v_sub_span_id, 'SUCCESS', NULL);
    
    -- 更新库存
    SET v_sub_span_id = start_trace(p_trace_id, v_span_id, 'update_inventory');
    CALL update_inventory(p_order_id);
    CALL end_trace(v_sub_span_id, 'SUCCESS', NULL);
    
    CALL end_trace(v_span_id, 'SUCCESS', NULL);
END$$

DELIMITER ;
```

### 10.2 错误传播链分析


```sql
-- 查询完整的错误传播链
DELIMITER $$

CREATE PROCEDURE analyze_error_chain(IN p_trace_id VARCHAR(64))
BEGIN
    -- 显示操作调用层次结构
    WITH RECURSIVE trace_hierarchy AS (
        -- 根节点（没有父span的操作）
        SELECT span_id, parent_span_id, operation_name, 
               start_time, end_time, duration_ms, status, error_message,
               0 as level, span_id as root_span
        FROM operation_trace 
        WHERE trace_id = p_trace_id AND parent_span_id IS NULL
        
        UNION ALL
        
        -- 子节点
        SELECT ot.span_id, ot.parent_span_id, ot.operation_name,
               ot.start_time, ot.end_time, ot.duration_ms, ot.status, ot.error_message,
               th.level + 1, th.root_span
        FROM operation_trace ot
        INNER JOIN trace_hierarchy th ON ot.parent_span_id = th.span_id
        WHERE ot.trace_id = p_trace_id
    )
    SELECT 
        CONCAT(REPEAT('  ', level), operation_name) as '操作层次',
        status as '状态',
        duration_ms as '耗时(ms)',
        error_message as '错误信息',
        start_time as '开始时间'
    FROM trace_hierarchy
    ORDER BY start_time;
    
    -- 统计错误分布
    SELECT 
        status as '状态',
        COUNT(*) as '操作数量',
        AVG(duration_ms) as '平均耗时',
        MAX(duration_ms) as '最大耗时'
    FROM operation_trace 
    WHERE trace_id = p_trace_id
    GROUP BY status;
END$$

DELIMITER ;
```

---

## 11. 📈 诊断信息可视化


### 11.1 错误统计报表


```sql
-- 创建错误统计视图
CREATE VIEW error_statistics AS
SELECT 
    DATE(log_time) as error_date,
    module_name,
    log_level,
    COUNT(*) as error_count,
    COUNT(DISTINCT session_id) as affected_sessions
FROM system_logs 
WHERE log_level IN ('ERROR', 'WARN')
GROUP BY DATE(log_time), module_name, log_level;
```

```sql
DELIMITER $$

-- 生成错误趋势报表
CREATE PROCEDURE generate_error_trend_report(
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    -- 每日错误趋势
    SELECT 
        error_date as '日期',
        SUM(CASE WHEN log_level = 'ERROR' THEN error_count ELSE 0 END) as '错误数',
        SUM(CASE WHEN log_level = 'WARN' THEN error_count ELSE 0 END) as '警告数',
        SUM(error_count) as '总数',
        affected_sessions as '影响会话数'
    FROM error_statistics
    WHERE error_date BETWEEN p_start_date AND p_end_date
    GROUP BY error_date
    ORDER BY error_date;
    
    -- 模块错误分布
    SELECT 
        module_name as '模块',
        SUM(error_count) as '错误总数',
        ROUND(SUM(error_count) * 100.0 / (
            SELECT SUM(error_count) FROM error_statistics 
            WHERE error_date BETWEEN p_start_date AND p_end_date
        ), 2) as '占比%'
    FROM error_statistics
    WHERE error_date BETWEEN p_start_date AND p_end_date
    GROUP BY module_name
    ORDER BY SUM(error_count) DESC;
END$$

DELIMITER ;
```

### 11.2 性能诊断仪表板


```sql
DELIMITER $$

-- 系统健康度检查
CREATE PROCEDURE system_health_check()
BEGIN
    DECLARE v_error_rate DECIMAL(5,2);
    DECLARE v_avg_response_time DECIMAL(8,2);
    DECLARE v_slow_queries INT;
    DECLARE v_health_score INT;
    
    -- 计算错误率（最近1小时）
    SELECT 
        ROUND(SUM(CASE WHEN log_level = 'ERROR' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2)
    INTO v_error_rate
    FROM system_logs 
    WHERE log_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR);
    
    -- 平均响应时间
    SELECT ROUND(AVG(execution_time_ms), 2) INTO v_avg_response_time
    FROM diagnostics_master 
    WHERE start_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR);
    
    -- 慢查询数量
    SELECT COUNT(*) INTO v_slow_queries
    FROM diagnostics_master
    WHERE start_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
    AND execution_time_ms > 1000;
    
    -- 计算健康评分
    SET v_health_score = 100;
    IF v_error_rate > 5 THEN SET v_health_score = v_health_score - 30; END IF;
    IF v_avg_response_time > 500 THEN SET v_health_score = v_health_score - 20; END IF;
    IF v_slow_queries > 10 THEN SET v_health_score = v_health_score - 15; END IF;
    
    -- 输出健康报告
    SELECT 
        '系统健康状况' as '指标类型',
        CASE 
            WHEN v_health_score >= 90 THEN '优秀 🟢'
            WHEN v_health_score >= 70 THEN '良好 🟡'
            WHEN v_health_score >= 50 THEN '一般 🟠'
            ELSE '较差 🔴'
        END as '健康等级',
        v_health_score as '健康评分',
        CONCAT(v_error_rate, '%') as '错误率',
        CONCAT(v_avg_response_time, 'ms') as '平均响应时间',
        v_slow_queries as '慢查询数量';
END$$

DELIMITER ;
```

---

## 12. 📋 核心要点总结


### 12.1 必须掌握的核心概念


```
🔸 GET DIAGNOSTICS：MySQL诊断信息获取的专用语句
🔸 诊断区域：临时存储SQL执行产生的错误、警告信息
🔸 条件信息：具体的错误码、状态码、消息等详细信息
🔸 错误堆栈：错误在程序调用链中的传递过程
🔸 结构化存储：将诊断信息系统化保存便于分析
```

### 12.2 关键语法要点


**🔹 基本诊断信息获取**：
```sql
-- 获取错误总数和影响行数
GET DIAGNOSTICS @count = NUMBER, @rows = ROW_COUNT;

-- 获取具体错误信息
GET DIAGNOSTICS CONDITION 1 
    @errno = MYSQL_ERRNO,
    @msg = MESSAGE_TEXT,
    @state = RETURNED_SQLSTATE;
```

**🔹 错误处理结合**：
```sql
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
    GET DIAGNOSTICS CONDITION 1 @error_msg = MESSAGE_TEXT;
    -- 记录错误日志
    INSERT INTO error_log (message) VALUES (@error_msg);
    RESIGNAL;
END;
```

### 12.3 实际应用价值


**💡 问题定位**：
- 快速找到错误根本原因
- 了解错误发生的完整上下文
- 追踪错误在系统中的传播路径

**📊 系统监控**：
- 实时监控系统健康状况
- 分析错误趋势和模式
- 预警潜在系统问题

**🔧 调试优化**：
- 为开发调试提供详细信息
- 识别性能瓶颈和优化点
- 验证修复效果

### 12.4 最佳实践建议


**🎯 使用原则**：
```
及时获取：诊断信息会被新SQL覆盖，要及时获取
分级记录：根据错误严重程度分级处理
结构化存储：便于后续查询和分析
链路跟踪：在复杂操作中建立完整的错误追踪链
```

**⚠️ 注意事项**：
```
性能影响：诊断信息收集有性能开销，要合理使用
存储空间：大量诊断信息需要定期清理
隐私安全：避免在日志中记录敏感信息
兼容性：不同MySQL版本的诊断功能可能有差异
```

**核心记忆**：
- GET DIAGNOSTICS获取诊断信息，及时收集不能拖
- 错误堆栈层层追踪，结构存储便分析
- 系统监控靠数据，可视报表助决策
- 诊断信息是良医，准确定位解难题