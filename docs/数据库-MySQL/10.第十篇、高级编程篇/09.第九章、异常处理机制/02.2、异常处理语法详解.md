---
title: 2、异常处理语法详解
---
## 📚 目录

1. [异常处理基本概念](#1-异常处理基本概念)
2. [DECLARE HANDLER语法详解](#2-DECLARE-HANDLER语法详解)
3. [异常条件匹配机制](#3-异常条件匹配机制)
4. [处理程序类型与行为](#4-处理程序类型与行为)
5. [异常处理作用域规则](#5-异常处理作用域规则)
6. [处理程序优先级机制](#6-处理程序优先级机制)
7. [嵌套异常处理](#7-嵌套异常处理)
8. [实际应用场景](#8-实际应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 异常处理基本概念


### 1.1 什么是异常处理


**定义**：异常处理是MySQL存储过程中用来**捕获和处理运行时错误**的机制，当程序执行过程中遇到错误时，可以自动执行预定义的处理逻辑。

**通俗理解**：就像开车时如果遇到突发状况，你预先制定好的应急方案会自动启动，而不是让车子直接撞车。

```
正常流程：    执行SQL → 成功 → 继续执行
异常处理：    执行SQL → 出错 → 触发异常处理器 → 处理错误 → 决定后续动作
```

### 1.2 为什么需要异常处理


**核心价值**：
- 🛡️ **防止程序崩溃**：遇到错误时不会直接终止整个存储过程
- 🔄 **优雅错误处理**：可以记录错误信息、回滚事务、清理资源
- 📊 **业务逻辑控制**：根据不同错误类型执行不同的处理策略
- 🎯 **用户体验提升**：给用户友好的错误提示而不是技术错误信息

### 1.3 异常处理的工作原理


```
异常处理工作流程：

1. 声明阶段：DECLARE HANDLER 定义异常处理器
2. 监听阶段：程序执行过程中监听各种异常条件
3. 触发阶段：当满足条件的异常发生时，自动触发对应处理器
4. 执行阶段：执行处理器中定义的处理逻辑
5. 决策阶段：根据处理器类型决定是继续执行还是退出
```

---

## 2. 📋 DECLARE HANDLER语法详解


### 2.1 基本语法结构


**完整语法**：
```sql
DECLARE handler_action HANDLER
    FOR condition_value [, condition_value] ...
    statement
```

**语法组成部分**：

| 组成部分 | **作用** | **说明** |
|---------|----------|----------|
| `handler_action` | `处理动作` | `CONTINUE或EXIT，决定处理后的行为` |
| `condition_value` | `异常条件` | `指定要处理的异常类型` |
| `statement` | `处理语句` | `异常发生时执行的具体逻辑` |

### 2.2 处理动作类型


**CONTINUE处理器**：
```sql
-- 处理异常后继续执行后续代码
DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
BEGIN
    SET @error_count = @error_count + 1;
    INSERT INTO error_log VALUES (NOW(), 'SQL异常发生');
END;
```

**EXIT处理器**：
```sql
-- 处理异常后退出当前BEGIN...END块
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
    ROLLBACK;
    SELECT '发生严重错误，事务已回滚' AS error_message;
END;
```

**两者区别**：
- **CONTINUE**：处理完错误后，**继续执行**后面的代码
- **EXIT**：处理完错误后，**立即退出**当前代码块

### 2.3 异常条件类型


**MySQL错误码**：
```sql
-- 处理特定错误码（如主键重复错误）
DECLARE CONTINUE HANDLER FOR 1062
BEGIN
    INSERT INTO duplicate_log VALUES (NOW(), '主键重复');
END;
```

**SQLSTATE值**：
```sql
-- 处理特定SQLSTATE（标准SQL错误状态）
DECLARE CONTINUE HANDLER FOR SQLSTATE '23000'
BEGIN
    SELECT 'SQLSTATE 23000: 完整性约束违反';
END;
```

**预定义条件**：
```sql
-- 处理所有SQL异常
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
    SELECT 'SQL执行异常';
END;

-- 处理SQL警告
DECLARE CONTINUE HANDLER FOR SQLWARNING
BEGIN
    SELECT 'SQL执行警告';
END;

-- 处理NOT FOUND条件
DECLARE CONTINUE HANDLER FOR NOT FOUND
BEGIN
    SET @no_data = TRUE;
END;
```

---

## 3. 🔍 异常条件匹配机制


### 3.1 条件匹配优先级


**匹配规则**：MySQL按照以下优先级顺序匹配异常处理器

```
优先级排序（从高到低）：
1. 具体MySQL错误码 (如1062)
2. 具体SQLSTATE值 (如'23000')  
3. 预定义条件名称 (如SQLEXCEPTION)
4. 通用条件 (如SQLWARNING)
```

**示例说明**：
```sql
DELIMITER $$
CREATE PROCEDURE test_priority()
BEGIN
    -- 优先级1：具体错误码
    DECLARE CONTINUE HANDLER FOR 1062
        SELECT '处理器1：主键重复错误';
    
    -- 优先级2：SQLSTATE
    DECLARE CONTINUE HANDLER FOR SQLSTATE '23000'
        SELECT '处理器2：完整性约束违反';
    
    -- 优先级3：预定义条件
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        SELECT '处理器3：SQL异常';
    
    -- 当发生1062错误时，只会执行处理器1
    INSERT INTO users VALUES (1, 'test'); -- 假设主键重复
END$$
DELIMITER ;
```

### 3.2 多条件处理器


**一个处理器处理多种条件**：
```sql
-- 同时处理多种异常条件
DECLARE CONTINUE HANDLER FOR 1062, 1048, SQLSTATE '23000'
BEGIN
    INSERT INTO error_log VALUES (
        NOW(), 
        CONCAT('数据完整性错误: ', @error_code)
    );
END;
```

### 3.3 条件匹配算法


```
异常匹配流程：

异常发生 → 获取错误码和SQLSTATE → 按优先级查找处理器
    ↓
找到匹配处理器 → 执行处理逻辑 → 根据handler_action决定后续行为
    ↓
未找到处理器 → 向上级作用域查找 → 最终抛出到客户端
```

---

## 4. ⚙️ 处理程序类型与行为


### 4.1 CONTINUE处理器详解


**特点**：处理异常后继续执行当前块的后续语句

```sql
DELIMITER $$
CREATE PROCEDURE demo_continue()
BEGIN
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        INSERT INTO error_log VALUES (NOW(), '主键冲突，已记录');
    END;
    
    INSERT INTO users VALUES (1, 'Alice');  -- 可能重复
    INSERT INTO users VALUES (2, 'Bob');    -- 即使上面出错，这里仍会执行
    INSERT INTO users VALUES (3, 'Carol');  -- 这里也会执行
    
    SELECT '所有操作尝试完成' AS result;
END$$
DELIMITER ;
```

**使用场景**：
- 📝 **错误日志记录**：记录错误但继续执行
- 🔄 **批量处理**：部分数据出错不影响其他数据处理
- ⚠️ **警告处理**：处理非致命性警告

### 4.2 EXIT处理器详解


**特点**：处理异常后立即退出当前BEGIN...END块

```sql
DELIMITER $$
CREATE PROCEDURE demo_exit()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT '发生错误，事务已回滚' AS error_msg;
    END;
    
    START TRANSACTION;
    INSERT INTO accounts VALUES (1, 1000);
    INSERT INTO accounts VALUES (2, -500);  -- 假设这里违反检查约束
    INSERT INTO accounts VALUES (3, 800);   -- 这行不会执行
    COMMIT;                                 -- 这行不会执行
    
    SELECT '事务成功提交' AS success_msg;   -- 这行不会执行
END$$
DELIMITER ;
```

**使用场景**：
- 🚨 **事务回滚**：发生严重错误时回滚事务
- 🛑 **快速失败**：遇到无法恢复的错误时立即停止
- 🔒 **资源清理**：清理资源后退出

### 4.3 处理器行为对比


| 特性 | **CONTINUE** | **EXIT** |
|------|-------------|----------|
| **错误处理后** | `继续执行后续代码` | `退出当前块` |
| **适用场景** | `非致命错误、日志记录` | `严重错误、事务处理` |
| **性能影响** | `较小` | `中等` |
| **代码复杂度** | `简单` | `需要考虑退出逻辑` |

---

## 5. 🎯 异常处理作用域规则


### 5.1 作用域基本概念


**作用域定义**：异常处理器只在声明它的BEGIN...END块及其内部嵌套块中有效。

```
作用域层次结构：

外层块 (Scope 1)
├── DECLARE HANDLER A
└── 内层块 (Scope 2)
    ├── DECLARE HANDLER B  
    └── 最内层块 (Scope 3)
        └── SQL语句执行
```

### 5.2 作用域继承机制


**继承规则**：内层块可以**访问外层块**声明的处理器，但外层块**不能访问内层块**的处理器。

```sql
DELIMITER $$
CREATE PROCEDURE scope_demo()
BEGIN
    -- 外层处理器
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        INSERT INTO outer_errors VALUES (NOW(), 'Outer handler');
    
    BEGIN
        -- 内层处理器
        DECLARE CONTINUE HANDLER FOR 1062
            INSERT INTO inner_errors VALUES (NOW(), 'Inner handler');
        
        -- 这里的SQL错误会优先匹配内层的1062处理器
        -- 如果不是1062错误，会使用外层的SQLEXCEPTION处理器
        INSERT INTO test_table VALUES (1, 'data');
    END;
    
    -- 这里只能使用外层处理器
    INSERT INTO test_table VALUES (2, 'data');
END$$
DELIMITER ;
```

### 5.3 作用域查找算法


```
异常处理器查找顺序：

1. 当前块查找匹配的处理器
   ↓ (未找到)
2. 父块查找匹配的处理器  
   ↓ (未找到)
3. 祖父块查找匹配的处理器
   ↓ (未找到)
4. 最终抛出给客户端
```

**实际示例**：
```sql
DELIMITER $$
CREATE PROCEDURE nested_scope()
BEGIN
    DECLARE v_level VARCHAR(20) DEFAULT 'Level 1';
    DECLARE CONTINUE HANDLER FOR SQLWARNING
        INSERT INTO scope_log VALUES (CONCAT(v_level, ': Warning handled'));
    
    BEGIN
        DECLARE v_level VARCHAR(20) DEFAULT 'Level 2';
        DECLARE CONTINUE HANDLER FOR 1062
            INSERT INTO scope_log VALUES (CONCAT(v_level, ': Duplicate key'));
        
        BEGIN
            DECLARE v_level VARCHAR(20) DEFAULT 'Level 3';
            -- 这里没有声明处理器
            
            -- 1062错误 → Level 2处理器
            -- 其他警告 → Level 1处理器
            INSERT INTO test VALUES (1, 'test');
        END;
    END;
END$$
DELIMITER ;
```

---

## 6. 🏆 处理程序优先级机制


### 6.1 优先级矩阵


**完整优先级排序**：

| 优先级 | **条件类型** | **示例** | **匹配范围** |
|--------|-------------|----------|-------------|
| **1** | `具体错误码` | `1062, 1048` | `精确匹配特定错误` |
| **2** | `具体SQLSTATE` | `'23000', '42000'` | `匹配SQLSTATE类别` |
| **3** | `命名条件` | `自定义条件名` | `用户定义的条件` |
| **4** | `NOT FOUND` | `游标无数据` | `数据未找到情况` |
| **5** | `SQLWARNING` | `SQL警告` | `非错误的警告信息` |
| **6** | `SQLEXCEPTION` | `SQL异常` | `除警告外的所有错误` |

### 6.2 优先级选择算法


**选择过程**：
```sql
-- 展示优先级选择的完整示例
DELIMITER $$
CREATE PROCEDURE priority_demo()
BEGIN
    -- 低优先级：通用异常处理
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        INSERT INTO log VALUES ('SQLEXCEPTION handler');
    
    -- 中优先级：SQLSTATE处理
    DECLARE CONTINUE HANDLER FOR SQLSTATE '23000'
        INSERT INTO log VALUES ('SQLSTATE 23000 handler');
    
    -- 高优先级：具体错误码
    DECLARE CONTINUE HANDLER FOR 1062
        INSERT INTO log VALUES ('Error 1062 handler');
    
    -- 执行可能产生1062错误的SQL
    -- 结果：只会执行"Error 1062 handler"
    INSERT INTO users VALUES (1, 'duplicate');
END$$
DELIMITER ;
```

### 6.3 同级优先级处理


**相同优先级的处理器**：按声明顺序，**后声明的覆盖先声明的**

```sql
DELIMITER $$
CREATE PROCEDURE same_priority()
BEGIN
    -- 第一个1062处理器
    DECLARE CONTINUE HANDLER FOR 1062
        INSERT INTO log VALUES ('First 1062 handler');
    
    -- 第二个1062处理器（会覆盖第一个）
    DECLARE CONTINUE HANDLER FOR 1062
        INSERT INTO log VALUES ('Second 1062 handler');
    
    -- 执行时只会触发第二个处理器
    INSERT INTO test VALUES (1, 'test');
END$$
DELIMITER ;
```

---

## 7. 🔄 嵌套异常处理


### 7.1 嵌套结构原理


**嵌套概念**：在多层BEGIN...END块中分别声明异常处理器，形成层次化的异常处理结构。

```
嵌套异常处理结构：

主程序块
├── 主处理器 (处理严重错误)
└── 子功能块
    ├── 子处理器 (处理具体错误)
    └── 孙子块
        └── 孙子处理器 (处理细分错误)
```

### 7.2 嵌套处理示例


```sql
DELIMITER $$
CREATE PROCEDURE nested_exception_demo()
BEGIN
    DECLARE v_transaction_started BOOLEAN DEFAULT FALSE;
    
    -- 最外层：处理所有未捕获的异常
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        IF v_transaction_started THEN
            ROLLBACK;
        END IF;
        SELECT '最外层处理器：发生严重错误，程序终止' AS error_message;
    END;
    
    START TRANSACTION;
    SET v_transaction_started = TRUE;
    
    -- 用户数据处理块
    BEGIN
        DECLARE CONTINUE HANDLER FOR 1062
        BEGIN
            INSERT INTO user_errors VALUES (NOW(), '用户数据重复，跳过');
        END;
        
        INSERT INTO users VALUES (1, 'Alice', 'alice@email.com');
        
        -- 订单处理子块
        BEGIN
            DECLARE CONTINUE HANDLER FOR 1452
            BEGIN
                INSERT INTO order_errors VALUES (NOW(), '外键约束违反');
            END;
            
            INSERT INTO orders VALUES (1, 1, '商品A', 100);
            INSERT INTO orders VALUES (2, 1, '商品B', 200);
        END;
        
        INSERT INTO users VALUES (2, 'Bob', 'bob@email.com');
    END;
    
    COMMIT;
    SET v_transaction_started = FALSE;
    SELECT '所有操作成功完成' AS success_message;
END$$
DELIMITER ;
```

### 7.3 嵌套异常的传播机制


**传播规则**：
1. **内层优先**：异常首先在最内层查找匹配的处理器
2. **逐层向外**：内层没有匹配的处理器时，向外层查找
3. **类型匹配**：每层都按照优先级规则进行匹配
4. **处理终止**：找到匹配处理器后，不再向外传播

```
异常传播示例：

Level 3: INSERT语句出错(1062) 
    ↓
Level 3: 查找1062处理器 → 未找到
    ↓  
Level 2: 查找1062处理器 → 找到 → 执行处理器 → CONTINUE
    ↓
Level 2: 继续执行后续代码
```

---

## 8. 🚀 实际应用场景


### 8.1 事务处理中的异常处理


**场景**：银行转账操作，确保数据一致性

```sql
DELIMITER $$
CREATE PROCEDURE transfer_money(
    IN from_account INT,
    IN to_account INT, 
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE v_balance DECIMAL(10,2);
    DECLARE v_transfer_completed BOOLEAN DEFAULT FALSE;
    
    -- 处理所有SQL异常，回滚事务
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        GET DIAGNOSTICS CONDITION 1
            @error_code = MYSQL_ERRNO,
            @error_message = MESSAGE_TEXT;
        
        INSERT INTO transfer_errors VALUES (
            NOW(), from_account, to_account, amount,
            CONCAT('错误码: ', @error_code, ', 信息: ', @error_message)
        );
        
        SELECT '转账失败，事务已回滚' AS result;
    END;
    
    START TRANSACTION;
    
    -- 检查余额
    SELECT balance INTO v_balance FROM accounts WHERE id = from_account;
    IF v_balance < amount THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '余额不足';
    END IF;
    
    -- 执行转账
    UPDATE accounts SET balance = balance - amount WHERE id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE id = to_account;
    
    COMMIT;
    SET v_transfer_completed = TRUE;
    
    INSERT INTO transfer_log VALUES (NOW(), from_account, to_account, amount, '成功');
    SELECT '转账成功' AS result;
END$$
DELIMITER ;
```

### 8.2 批量数据处理


**场景**：批量导入用户数据，部分失败不影响整体

```sql
DELIMITER $$
CREATE PROCEDURE batch_import_users()
BEGIN
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE v_name VARCHAR(50);
    DECLARE v_email VARCHAR(100);
    DECLARE v_success_count INT DEFAULT 0;
    DECLARE v_error_count INT DEFAULT 0;
    
    -- 游标声明
    DECLARE user_cursor CURSOR FOR 
        SELECT name, email FROM temp_users;
    
    -- 游标结束处理
    DECLARE CONTINUE HANDLER FOR NOT FOUND 
        SET done = TRUE;
    
    -- 数据重复处理
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_error_count = v_error_count + 1;
        INSERT INTO import_errors VALUES (NOW(), v_name, v_email, '邮箱重复');
    END;
    
    -- 数据格式错误处理
    DECLARE CONTINUE HANDLER FOR 1406
    BEGIN
        SET v_error_count = v_error_count + 1;
        INSERT INTO import_errors VALUES (NOW(), v_name, v_email, '数据过长');
    END;
    
    OPEN user_cursor;
    
    read_loop: LOOP
        FETCH user_cursor INTO v_name, v_email;
        
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 尝试插入用户
        INSERT INTO users (name, email, created_at) 
        VALUES (v_name, v_email, NOW());
        
        SET v_success_count = v_success_count + 1;
    END LOOP;
    
    CLOSE user_cursor;
    
    SELECT 
        v_success_count AS success_count,
        v_error_count AS error_count,
        CONCAT('成功: ', v_success_count, ', 失败: ', v_error_count) AS summary;
END$$
DELIMITER ;
```

### 8.3 系统监控和日志记录


**场景**：数据库操作监控，记录所有异常情况

```sql
DELIMITER $$
CREATE PROCEDURE monitored_operation()
BEGIN
    -- 创建监控表（如果不存在）
    CREATE TABLE IF NOT EXISTS operation_monitor (
        id INT AUTO_INCREMENT PRIMARY KEY,
        timestamp DATETIME,
        operation_type VARCHAR(50),
        status VARCHAR(20),
        error_details TEXT,
        execution_time INT
    );
    
    DECLARE v_start_time TIMESTAMP DEFAULT NOW();
    DECLARE v_operation_id INT;
    
    -- 插入操作开始记录
    INSERT INTO operation_monitor (timestamp, operation_type, status)
    VALUES (v_start_time, 'DATA_SYNC', 'STARTED');
    SET v_operation_id = LAST_INSERT_ID();
    
    -- 处理各种异常情况
    DECLARE CONTINUE HANDLER FOR SQLWARNING
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @warning_message = MESSAGE_TEXT;
        UPDATE operation_monitor 
        SET error_details = CONCAT(IFNULL(error_details, ''), 'WARNING: ', @warning_message, '; ')
        WHERE id = v_operation_id;
    END;
    
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        UPDATE operation_monitor 
        SET error_details = CONCAT(IFNULL(error_details, ''), 'DUPLICATE_KEY: 主键冲突; ')
        WHERE id = v_operation_id;
    END;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 
            @error_code = MYSQL_ERRNO,
            @error_message = MESSAGE_TEXT;
        
        UPDATE operation_monitor 
        SET 
            status = 'FAILED',
            error_details = CONCAT('FATAL ERROR: ', @error_code, ' - ', @error_message),
            execution_time = TIMESTAMPDIFF(MICROSECOND, v_start_time, NOW())
        WHERE id = v_operation_id;
    END;
    
    -- 执行具体业务逻辑
    CALL sync_user_data();
    CALL sync_order_data();
    CALL cleanup_temp_data();
    
    -- 更新操作完成状态
    UPDATE operation_monitor 
    SET 
        status = 'COMPLETED',
        execution_time = TIMESTAMPDIFF(MICROSECOND, v_start_time, NOW())
    WHERE id = v_operation_id;
    
    SELECT '操作监控完成' AS result;
END$$
DELIMITER ;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 异常处理本质：预先定义错误发生时的应对策略
🔸 DECLARE HANDLER：声明异常处理器的标准语法
🔸 处理器类型：CONTINUE继续执行，EXIT退出块
🔸 条件匹配：按错误码→SQLSTATE→预定义条件的优先级匹配
🔸 作用域规则：内层可访问外层，外层不能访问内层
🔸 优先级机制：具体条件优先于通用条件
```

### 9.2 关键理解要点


**🔹 异常处理的设计思路**
```
设计原则：
- 预防胜于治疗：提前考虑可能的异常情况
- 分层处理：不同层次处理不同类型的异常
- 优雅降级：异常发生时确保系统稳定
- 信息记录：记录异常信息便于问题排查
```

**🔹 CONTINUE vs EXIT的选择策略**
```
使用CONTINUE的情况：
- 非致命错误（如数据重复）
- 批量处理场景
- 需要记录错误但继续执行

使用EXIT的情况：
- 严重错误需要停止执行
- 事务完整性要求高
- 无法恢复的错误情况
```

**🔹 作用域和优先级的实际意义**
```
作用域设计：
- 内层处理具体错误
- 外层处理通用错误
- 形成错误处理的层次结构

优先级应用：
- 先处理具体已知错误
- 再处理分类错误
- 最后兜底处理所有异常
```

### 9.3 实际应用指导


**✅ 最佳实践**
- **明确异常类型**：针对不同错误码设计不同处理策略
- **合理嵌套**：按业务逻辑层次设计异常处理结构
- **记录异常信息**：使用GET DIAGNOSTICS获取详细错误信息
- **事务完整性**：在事务中使用EXIT处理器确保一致性
- **性能考虑**：避免过度复杂的异常处理逻辑

**❌ 常见误区**
- 过度使用CONTINUE导致错误被忽略
- 异常处理器中执行复杂逻辑影响性能
- 没有考虑嵌套作用域的影响
- 异常条件匹配过于宽泛
- 缺少异常情况的日志记录

**🎯 应用场景总结**
- **数据迁移**：批量处理时的错误容错
- **事务处理**：确保数据一致性的异常回滚
- **系统集成**：外部系统调用的异常处理
- **定时任务**：自动化任务的错误处理和恢复
- **API接口**：存储过程作为API时的异常响应

**核心记忆要点**：
- 异常处理是程序健壮性的重要保障
- DECLARE HANDLER是MySQL异常处理的核心语法
- 优先级和作用域决定了哪个处理器会被触发
- CONTINUE适合轻微错误，EXIT适合严重错误
- 良好的异常处理设计能显著提升系统稳定性