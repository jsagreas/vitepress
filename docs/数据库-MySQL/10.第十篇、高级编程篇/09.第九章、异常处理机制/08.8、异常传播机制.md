---
title: 8、异常传播机制
---
## 📚 目录

1. [异常传播基础概念](#1-异常传播基础概念)
2. [异常传播路径详解](#2-异常传播路径详解)
3. [调用栈处理机制](#3-调用栈处理机制)
4. [异常冒泡机制](#4-异常冒泡机制)
5. [截获与重新抛出](#5-截获与重新抛出)
6. [异常转换处理](#6-异常转换处理)
7. [传播终止条件](#7-传播终止条件)
8. [异常链分析](#8-异常链分析)
9. [异常传播可视化](#9-异常传播可视化)
10. [传播路径优化策略](#10-传播路径优化策略)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🌊 异常传播基础概念


### 1.1 什么是异常传播


异常传播是指当MySQL存储过程或函数中发生异常时，异常信息如何在调用层次中向上传递的过程。

> 💡 **通俗理解**：就像多米诺骨牌效应，一个地方出错了，错误会一层层往上传，直到有人处理它或者到达最顶层。

**异常传播的本质**：
- **向上传递**：异常从发生点向调用者传播
- **层层传递**：通过调用栈逐级向上
- **可被截获**：在任何层级都可以被处理
- **可被转换**：可以转换成其他类型的异常

### 1.2 传播机制的重要性


```
为什么需要异常传播？

❌ 没有传播机制：
- 错误被掩盖，难以发现问题
- 程序继续执行错误逻辑
- 数据一致性无法保证

✅ 有传播机制：
- 错误能够及时暴露
- 可以在合适的层级处理
- 保证数据库事务完整性
```

---

## 2. 🛣️ 异常传播路径详解


### 2.1 传播路径示例


异常在MySQL中的传播遵循调用栈的逆向路径：

```
传播路径图示：

应用层 (Application)
    ↑ 异常向上传播
存储过程A (CALL proc_a)
    ↑ 异常向上传播  
存储过程B (CALL proc_b)
    ↑ 异常向上传播
存储过程C (CALL proc_c)
    ↑ 异常发生点
SQL语句执行失败
```

### 2.2 实际传播示例


```sql
-- 底层过程：发生异常
DELIMITER $$
CREATE PROCEDURE proc_level3()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        RESIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '第3层异常';
    END;
    
    -- 故意触发异常
    INSERT INTO non_exist_table VALUES(1);
END$$

-- 中间层过程：传播异常
CREATE PROCEDURE proc_level2()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            @error_msg = MESSAGE_TEXT;
        RESIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = CONCAT('第2层捕获: ', @error_msg);
    END;
    
    CALL proc_level3();
END$$

-- 顶层过程：最终处理
CREATE PROCEDURE proc_level1()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            @error_msg = MESSAGE_TEXT;
        SELECT CONCAT('最终处理: ', @error_msg) AS error_info;
    END;
    
    CALL proc_level2();
END$$
DELIMITER ;
```

### 2.3 传播路径特点


**🔸 自下而上**：异常总是从错误发生点向调用者传播
**🔸 可被拦截**：任何层级都可以截获并处理异常
**🔸 信息累积**：可以在传播过程中添加上下文信息
**🔸 类型转换**：可以将一种异常转换为另一种异常

---

## 3. 📚 调用栈处理机制


### 3.1 调用栈的概念


调用栈记录了程序执行时的函数调用顺序，异常传播正是沿着调用栈的反方向进行。

> 💡 **形象比喻**：调用栈就像一摞盘子，最后放上去的最先拿下来。异常处理也是这样，最深层的调用最先被检查。

```
调用栈示意图：

┌─────────────────┐  ← 栈顶 (最后调用)
│   proc_level3   │  ← 异常发生点
├─────────────────┤
│   proc_level2   │  ← 中间调用
├─────────────────┤  
│   proc_level1   │  ← 最初调用
├─────────────────┤
│   应用程序      │  ← 栈底 (最先调用)
└─────────────────┘
```

### 3.2 栈回退处理


```sql
-- 演示调用栈回退
DELIMITER $$
CREATE PROCEDURE demo_stack_unwinding()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE stack_level VARCHAR(50);
    
    -- 模拟调用栈信息
    SET stack_level = 'Level 1 - 主过程';
    
    CALL sub_procedure_level2();
    
    -- 如果到达这里，说明异常被处理了
    SELECT '异常已被处理，程序继续执行' AS status;
    
END$$

CREATE PROCEDURE sub_procedure_level2()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SELECT '在Level 2处理异常' AS handler_location;
        -- 可以选择处理或继续传播
        RESIGNAL; -- 继续向上传播
    END;
    
    CALL sub_procedure_level3();
END$$

CREATE PROCEDURE sub_procedure_level3()
BEGIN
    -- 触发异常
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '模拟业务异常';
END$$
DELIMITER ;
```

---

## 4. 🫧 异常冒泡机制


### 4.1 冒泡机制原理


异常冒泡是指异常像气泡一样从深层向表层"浮起"的过程。

> 💡 **生活比喻**：就像水中的气泡，总是往水面浮，异常也总是往调用链的上层"冒"。

```
冒泡过程图示：

应用层     ← 🫧 异常最终到达这里
    ↑
过程A      ← 🫧 异常继续向上冒泡  
    ↑
过程B      ← 🫧 异常向上冒泡
    ↑
过程C      ← 💥 异常发生点
```

### 4.2 冒泡机制示例


```sql
DELIMITER $$
-- 演示异常冒泡过程
CREATE PROCEDURE bubble_demo_main()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SELECT '主过程捕获异常并处理' AS final_handler;
    END;
    
    SELECT '开始执行主过程' AS step;
    CALL bubble_demo_sub1();
    SELECT '主过程正常结束' AS step;
END$$

CREATE PROCEDURE bubble_demo_sub1()  
BEGIN
    -- 这里没有异常处理器，异常会继续冒泡
    SELECT '子过程1执行中' AS step;
    CALL bubble_demo_sub2();
    SELECT '子过程1正常结束' AS step;
END$$

CREATE PROCEDURE bubble_demo_sub2()
BEGIN
    -- 这里也没有处理器，继续冒泡
    SELECT '子过程2执行中' AS step;
    
    -- 触发异常
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '子过程2中的业务异常';
    
    -- 这行不会执行
    SELECT '这行不会执行' AS step;
END$$
DELIMITER ;
```

### 4.3 冒泡的特征


**🔸 自动传播**：无需编程控制，异常会自动向上传播
**🔸 寻找处理器**：在每一层查找异常处理器
**🔸 终止执行**：遇到异常后，当前层级的后续代码不再执行
**🔸 恢复执行**：如果异常被处理，程序可以在处理点继续执行

---

## 5. 🔄 截获与重新抛出


### 5.1 截获异常


截获是指在某个层级捕获异常并进行处理，阻止异常继续向上传播。

```sql
DELIMITER $$
-- 截获异常示例
CREATE PROCEDURE intercept_exception_demo()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_msg TEXT;
        GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
        
        -- 记录异常信息
        INSERT INTO error_log(error_time, error_message, procedure_name) 
        VALUES(NOW(), error_msg, 'intercept_exception_demo');
        
        -- 异常被截获，不再向上传播
        SELECT '异常已被截获并记录' AS result;
    END;
    
    -- 调用可能出错的过程
    CALL risky_procedure();
    
    -- 如果异常被截获，这里会继续执行
    SELECT '程序继续正常执行' AS status;
END$$
DELIMITER ;
```

### 5.2 重新抛出异常


有时需要在处理异常的同时，将异常继续向上传播。

```sql
DELIMITER $$
-- 重新抛出异常示例
CREATE PROCEDURE rethrow_exception_demo()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_code CHAR(5);
        DECLARE error_msg TEXT;
        
        -- 获取异常信息
        GET DIAGNOSTICS CONDITION 1
            error_code = RETURNED_SQLSTATE,
            error_msg = MESSAGE_TEXT;
        
        -- 记录异常（但不阻止传播）
        INSERT INTO error_log(error_time, error_code, error_message) 
        VALUES(NOW(), error_code, error_msg);
        
        -- 重新抛出异常，让上层继续处理
        RESIGNAL SQLSTATE error_code SET MESSAGE_TEXT = error_msg;
    END;
    
    CALL another_risky_procedure();
END$$
DELIMITER ;
```

### 5.3 选择性处理


```sql
DELIMITER $$
-- 根据异常类型选择处理策略
CREATE PROCEDURE selective_handling()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_code CHAR(5);
        GET DIAGNOSTICS CONDITION 1 error_code = RETURNED_SQLSTATE;
        
        CASE error_code
            WHEN '23000' THEN
                -- 约束违反异常，记录并继续
                INSERT INTO error_log VALUES(NOW(), '约束违反', error_code);
            WHEN '42S02' THEN  
                -- 表不存在异常，重新抛出
                RESIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '关键表缺失';
            ELSE
                -- 其他异常，通用处理
                RESIGNAL;
        END CASE;
    END;
    
    -- 业务逻辑
    CALL business_logic_procedure();
END$$
DELIMITER ;
```

---

## 6. 🔄 异常转换处理


### 6.1 异常转换的概念


异常转换是指将一种类型的异常转换为另一种更有意义的异常，通常是将系统级异常转换为业务级异常。

> 💡 **实际意义**：比如将"表不存在"的技术异常转换为"用户数据初始化失败"的业务异常，让上层更容易理解和处理。

```sql
DELIMITER $$
-- 异常转换示例
CREATE PROCEDURE exception_transformation()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_code CHAR(5);
        DECLARE error_msg TEXT;
        
        GET DIAGNOSTICS CONDITION 1
            error_code = RETURNED_SQLSTATE,
            error_msg = MESSAGE_TEXT;
        
        -- 将系统异常转换为业务异常
        CASE error_code
            WHEN '42S02' THEN
                SIGNAL SQLSTATE '45001' 
                SET MESSAGE_TEXT = '用户配置表未初始化，请联系管理员';
                
            WHEN '23000' THEN
                SIGNAL SQLSTATE '45002'
                SET MESSAGE_TEXT = '数据冲突：该操作违反业务规则';
                
            WHEN '1062' THEN
                SIGNAL SQLSTATE '45003'
                SET MESSAGE_TEXT = '重复操作：该记录已存在';
                
            ELSE
                -- 未知异常，保持原样但添加上下文
                RESIGNAL SQLSTATE '45999'
                SET MESSAGE_TEXT = CONCAT('业务操作失败：', error_msg);
        END CASE;
    END;
    
    -- 执行可能出错的业务操作
    CALL execute_business_operation();
END$$
DELIMITER ;
```

### 6.2 异常包装


```sql
DELIMITER $$
-- 异常包装：添加上下文信息
CREATE PROCEDURE exception_wrapping(IN user_id INT, IN operation_type VARCHAR(50))
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_msg TEXT;
        GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
        
        -- 包装异常，添加业务上下文
        RESIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = CONCAT(
            '用户操作失败 [用户ID:', user_id, 
            ', 操作:', operation_type,
            ', 原因:', error_msg, ']'
        );
    END;
    
    -- 执行用户操作
    CALL perform_user_operation(user_id, operation_type);
END$$
DELIMITER ;
```

---

## 7. ⏹️ 传播终止条件


### 7.1 正常终止条件


异常传播会在以下情况下终止：

**🔸 被处理器捕获**：遇到匹配的异常处理器
**🔸 到达顶层**：传播到最外层调用
**🔸 被转换**：转换为其他类型后重新处理
**🔸 被忽略**：明确选择忽略异常

```sql
DELIMITER $$
-- 演示各种终止条件
CREATE PROCEDURE termination_conditions_demo()
BEGIN
    -- 条件1：被处理器捕获（正常终止）
    DECLARE EXIT HANDLER FOR SQLSTATE '45001'
    BEGIN
        SELECT '异常被成功捕获并处理' AS termination_reason;
    END;
    
    -- 条件2：特定异常被忽略
    DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'
    BEGIN
        SELECT '警告被忽略，继续执行' AS ignore_reason;
    END;
    
    CALL procedure_that_may_throw_exceptions();
    
    -- 如果到达这里，说明异常被正确处理了
    SELECT '程序正常结束' AS final_status;
END$$
DELIMITER ;
```

### 7.2 异常终止的影响


```sql
DELIMITER $$
-- 展示异常终止对事务的影响
CREATE PROCEDURE transaction_with_exception_handling()
BEGIN
    DECLARE `rollback_flag` BOOLEAN DEFAULT FALSE;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SET `rollback_flag` = TRUE;
        ROLLBACK;
        GET DIAGNOSTICS CONDITION 1
            @error_msg = MESSAGE_TEXT;
        SELECT CONCAT('事务回滚：', @error_msg) AS transaction_result;
    END;
    
    START TRANSACTION;
    
    -- 业务操作
    UPDATE account SET balance = balance - 100 WHERE id = 1;
    UPDATE account SET balance = balance + 100 WHERE id = 2;
    
    -- 如果没有异常，提交事务
    IF NOT `rollback_flag` THEN
        COMMIT;
        SELECT '事务成功提交' AS transaction_result;
    END IF;
END$$
DELIMITER ;
```

---

## 8. 🔗 异常链分析


### 8.1 异常链的概念


异常链记录了异常在传播过程中的完整路径和转换历史。

> 💡 **形象理解**：就像快递包裹的物流信息，记录了从发出到收到的每一个环节。

```sql
DELIMITER $$
-- 构建异常链
CREATE PROCEDURE build_exception_chain()
BEGIN
    DECLARE chain_info TEXT DEFAULT '';
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_msg TEXT;
        GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
        
        SET chain_info = CONCAT(chain_info, ' -> 主过程捕获异常');
        
        -- 输出完整的异常链
        SELECT CONCAT('异常链:', chain_info, ' -> ', error_msg) AS exception_chain;
    END;
    
    SET chain_info = '开始执行';
    CALL level1_procedure();
END$$

CREATE PROCEDURE level1_procedure()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_msg TEXT;
        GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
        
        -- 添加链信息并重新抛出
        RESIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = CONCAT('Level1过程 -> ', error_msg);
    END;
    
    CALL level2_procedure();
END$$

CREATE PROCEDURE level2_procedure()  
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_msg TEXT;
        GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
        
        RESIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = CONCAT('Level2过程 -> ', error_msg);
    END;
    
    -- 触发原始异常
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '原始业务异常';
END$$
DELIMITER ;
```

### 8.2 异常链追踪


```sql
-- 创建异常追踪表
CREATE TABLE exception_trace (
    id INT AUTO_INCREMENT PRIMARY KEY,
    trace_id VARCHAR(36),
    level_name VARCHAR(100),
    error_code CHAR(5),
    error_message TEXT,
    occur_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DELIMITER $$
-- 实现异常链追踪
CREATE PROCEDURE traceable_procedure(IN trace_id VARCHAR(36))
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_code CHAR(5);
        DECLARE error_msg TEXT;
        
        GET DIAGNOSTICS CONDITION 1
            error_code = RETURNED_SQLSTATE,
            error_msg = MESSAGE_TEXT;
        
        -- 记录异常追踪信息
        INSERT INTO exception_trace(trace_id, level_name, error_code, error_message)
        VALUES(trace_id, 'traceable_procedure', error_code, error_msg);
        
        RESIGNAL;
    END;
    
    CALL sub_traceable_procedure(trace_id);
END$$
DELIMITER ;
```

---

## 9. 📊 异常传播可视化


### 9.1 传播路径图示


```
异常传播完整流程图：

应用层                     ┌─ 处理异常 ─┐
   ↑                      │           │
   │ 传播异常              │           ↓
存储过程A ←─ 记录日志 ─────┤         返回错误信息
   ↑                      │
   │ 转换异常              │
存储过程B ←─ 添加上下文 ───┤
   ↑                      │  
   │ 包装异常              │
存储过程C ←─ 原始异常 ─────┘
   ↑
   │ 触发异常
SQL执行失败
```

### 9.2 异常处理决策树


```
异常处理决策流程：

异常发生
    │
    ↓
是否有处理器？
    │
    ├─ 是 → 异常类型匹配？
    │         │
    │         ├─ 是 → 执行处理逻辑 → 是否重新抛出？
    │         │                      │
    │         │                      ├─ 是 → 继续传播
    │         │                      └─ 否 → 传播终止
    │         └─ 否 → 继续向上传播
    │
    └─ 否 → 向上传播到调用者
             │
             ↓
         到达顶层？
             │
             ├─ 是 → 程序异常终止
             └─ 否 → 重复决策过程
```

### 9.3 性能影响分析


```sql
-- 测量异常传播的性能影响
DELIMITER $$
CREATE PROCEDURE performance_analysis()
BEGIN
    DECLARE start_time, end_time BIGINT;
    DECLARE normal_time, exception_time BIGINT;
    
    -- 测试正常执行时间
    SET start_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    CALL normal_execution_procedure();
    SET end_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    SET normal_time = end_time - start_time;
    
    -- 测试异常处理时间
    SET start_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    CALL exception_handling_procedure();
    SET end_time = UNIX_TIMESTAMP(NOW(6)) * 1000000 + MICROSECOND(NOW(6));
    SET exception_time = end_time - start_time;
    
    -- 输出性能对比
    SELECT 
        normal_time AS '正常执行时间(微秒)',
        exception_time AS '异常处理时间(微秒)',
        (exception_time - normal_time) AS '额外开销(微秒)',
        ROUND((exception_time - normal_time) / normal_time * 100, 2) AS '性能影响百分比';
END$$
DELIMITER ;
```

---

## 10. ⚡ 传播路径优化策略


### 10.1 减少传播层次


过深的调用栈会影响异常传播的性能和可读性。

```sql
DELIMITER $$
-- 优化前：过深的调用栈
CREATE PROCEDURE deep_call_stack_bad()
BEGIN
    CALL level1();
END$$

CREATE PROCEDURE level1() BEGIN CALL level2(); END$$
CREATE PROCEDURE level2() BEGIN CALL level3(); END$$  
CREATE PROCEDURE level3() BEGIN CALL level4(); END$$
CREATE PROCEDURE level4() 
BEGIN 
    -- 实际业务逻辑
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '业务异常';
END$$

-- 优化后：扁平化调用结构
CREATE PROCEDURE flat_call_stack_good()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_msg TEXT;
        GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
        SELECT CONCAT('统一异常处理:', error_msg) AS result;
    END;
    
    -- 直接调用核心业务逻辑
    CALL core_business_logic();
END$$
DELIMITER ;
```

### 10.2 异常处理最佳实践


```sql
DELIMITER $$
-- 最佳实践：分层异常处理
CREATE PROCEDURE best_practice_exception_handling()
BEGIN
    -- 业务级异常处理
    DECLARE EXIT HANDLER FOR SQLSTATE '45000'
    BEGIN
        CALL handle_business_exception();
    END;
    
    -- 系统级异常处理  
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        CALL handle_system_exception();
        RESIGNAL; -- 系统异常需要向上传播
    END;
    
    -- 警告处理
    DECLARE CONTINUE HANDLER FOR SQLWARNING
    BEGIN
        CALL log_warning();
    END;
    
    -- 执行业务逻辑
    CALL execute_business_process();
END$$

-- 专门的异常处理过程
CREATE PROCEDURE handle_business_exception()
BEGIN
    DECLARE error_msg TEXT;
    GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
    
    -- 记录业务异常
    INSERT INTO business_error_log(error_time, error_message, handled)
    VALUES(NOW(), error_msg, TRUE);
    
    SELECT '业务异常已处理' AS status;
END$$

CREATE PROCEDURE handle_system_exception()
BEGIN
    DECLARE error_code CHAR(5);
    DECLARE error_msg TEXT;
    
    GET DIAGNOSTICS CONDITION 1
        error_code = RETURNED_SQLSTATE,
        error_msg = MESSAGE_TEXT;
    
    -- 记录系统异常
    INSERT INTO system_error_log(error_time, error_code, error_message)
    VALUES(NOW(), error_code, error_msg);
END$$
DELIMITER ;
```

### 10.3 异常信息聚合


```sql
DELIMITER $$
-- 异常信息聚合处理
CREATE PROCEDURE aggregate_exception_info()
BEGIN
    DECLARE exception_count INT DEFAULT 0;
    DECLARE error_summary TEXT DEFAULT '';
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        DECLARE error_msg TEXT;
        GET DIAGNOSTICS CONDITION 1 error_msg = MESSAGE_TEXT;
        
        SET exception_count = exception_count + 1;
        SET error_summary = CONCAT(error_summary, 
            '[异常', exception_count, ': ', error_msg, '] ');
        
        -- 如果异常过多，终止处理
        IF exception_count >= 3 THEN
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = CONCAT('累积异常过多:', error_summary);
        ELSE
            RESIGNAL;
        END IF;
    END;
    
    -- 可能出错的批量操作
    CALL batch_operation_with_errors();
END$$
DELIMITER ;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 异常传播：异常沿调用栈向上传递的过程
🔸 传播路径：从异常发生点到最终处理点的完整路径
🔸 冒泡机制：异常自动向上级调用者传播
🔸 截获处理：在传播过程中捕获并处理异常
🔸 重新抛出：处理异常后继续向上传播
🔸 异常转换：将系统异常转换为业务异常
🔸 传播终止：异常被处理或到达顶层时停止传播
```

### 11.2 关键理解要点


**🔹 传播的本质**
```
异常传播 = 调用栈回退 + 异常处理器查找
- 沿着调用栈的逆向路径传播
- 在每一层查找匹配的异常处理器
- 找到处理器就终止，否则继续向上
```

**🔹 处理策略选择**
```
截获：完全处理异常，阻止向上传播
转换：转换异常类型，提供更好的错误信息  
重抛：记录异常但继续向上传播
忽略：对特定异常类型不做处理
```

**🔹 性能与可维护性平衡**
```
减少调用层次：避免过深的调用栈
分层处理：不同层次处理不同类型的异常
统一格式：标准化异常信息格式
链式追踪：保留完整的异常传播路径
```

### 11.3 实际应用指导


**✅ 最佳实践**
- 在合适的层级处理对应的异常类型
- 业务异常在业务层处理，系统异常在系统层处理
- 重要操作要有完整的异常链追踪
- 异常信息要包含足够的上下文

**❌ 常见误区**
- 捕获所有异常但不做任何处理
- 异常信息过于技术化，缺乏业务含义
- 异常传播路径过长，难以定位问题
- 没有区分可恢复和不可恢复的异常

**核心记忆**：
- 异常传播遵循调用栈的逆向路径
- 每层都可以选择处理、转换或继续传播
- 合理的分层处理是异常管理的关键
- 完整的异常链有助于问题诊断和解决