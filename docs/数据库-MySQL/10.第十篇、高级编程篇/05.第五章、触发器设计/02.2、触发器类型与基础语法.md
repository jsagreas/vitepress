---
title: 2、触发器类型与基础语法
---
## 📚 目录

1. [触发器概念与作用](#1-触发器概念与作用)
2. [触发器类型分类](#2-触发器类型分类)
3. [触发器执行时机](#3-触发器执行时机)
4. [基础语法详解](#4-基础语法详解)
5. [触发器命名规范](#5-触发器命名规范)
6. [FOR EACH ROW机制](#6-for-each-row机制)
7. [激活条件控制](#7-激活条件控制)
8. [实际应用示例](#8-实际应用示例)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 触发器概念与作用


### 1.1 什么是触发器


**💡 触发器定义**
触发器(Trigger)是一种特殊的存储过程，它不需要人工调用，而是在特定的数据库事件发生时**自动执行**。

```
简单理解：触发器就像是数据库的"自动化机器人"
当某个表发生增删改操作时，触发器会自动执行预设的SQL代码
```

**🔧 触发器的核心作用**
- **数据完整性保护** - 自动检查和维护数据的一致性
- **业务逻辑自动化** - 无需应用程序干预，数据库自动处理业务规则
- **日志记录** - 自动记录数据变更历史
- **数据同步** - 在相关表之间自动同步数据

### 1.2 触发器与存储过程的区别


| **特征** | **触发器** | **存储过程** |
|---------|-----------|-------------|
| **调用方式** | `自动触发` | `手动调用` |
| **执行时机** | `数据变更时` | `程序调用时` |
| **返回值** | `无返回值` | `可有返回值` |
| **参数** | `不能传参` | `可传参数` |

### 1.3 生活化理解


```
触发器就像家里的感应灯：
- 平时不工作，没有人为操作
- 当有人经过时（数据变更），自动亮起（执行代码）
- 你不需要手动按开关（调用），它会自动响应

存储过程像电视遥控器：
- 需要你主动按按钮（调用）
- 可以传递不同指令（参数）
- 执行后给你反馈（返回值）
```

---

## 2. 📋 触发器类型分类


### 2.1 按执行时机分类


**⏰ BEFORE触发器**
在数据变更**之前**执行，可以阻止或修改即将发生的操作。

```sql
-- 在插入数据前检查数据有效性
CREATE TRIGGER check_before_insert 
BEFORE INSERT ON users 
FOR EACH ROW
BEGIN
    IF NEW.age < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '年龄不能为负数';
    END IF;
END;
```

**⏰ AFTER触发器**
在数据变更**之后**执行，通常用于日志记录和数据同步。

```sql
-- 在更新后记录操作日志
CREATE TRIGGER log_after_update
AFTER UPDATE ON products 
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (table_name, action, old_value, new_value)
    VALUES ('products', 'UPDATE', OLD.price, NEW.price);
END;
```

### 2.2 按触发事件分类


**📥 INSERT触发器**
当向表中**插入新记录**时触发。

```
使用场景示例：
- 新用户注册时自动创建用户配置
- 订单创建时自动更新库存
- 插入数据时自动设置创建时间
```

**🔄 UPDATE触发器**
当**修改表中记录**时触发。

```
使用场景示例：
- 价格变更时记录历史
- 状态改变时发送通知
- 修改时自动更新最后修改时间
```

**🗑️ DELETE触发器**
当**删除表中记录**时触发。

```
使用场景示例：
- 删除用户时清理相关数据
- 删除订单时恢复库存
- 删除时移动数据到回收站
```

### 2.3 触发器类型组合


```
每个表最多可以有6种触发器：
┌─────────────────────────────────┐
│  BEFORE INSERT  │  AFTER INSERT  │
├─────────────────├────────────────┤
│  BEFORE UPDATE  │  AFTER UPDATE  │
├─────────────────├────────────────┤
│  BEFORE DELETE  │  AFTER DELETE  │
└─────────────────────────────────┘
```

---

## 3. ⚡ 触发器执行时机


### 3.1 执行时机详解


**🔸 BEFORE触发器执行时机**
```
用户执行SQL → BEFORE触发器 → 实际数据变更 → AFTER触发器

特点：
- 可以修改即将插入/更新的数据
- 可以阻止数据变更操作
- 在数据验证阶段执行
```

**🔸 AFTER触发器执行时机**
```
用户执行SQL → BEFORE触发器 → 实际数据变更 → AFTER触发器

特点：
- 数据已经确实变更
- 无法阻止已完成的操作
- 适合做后续处理和日志记录
```

### 3.2 执行时机选择指导


| **需求场景** | **推荐时机** | **原因** |
|-------------|-------------|---------|
| **数据验证** | `BEFORE` | `可以阻止无效数据` |
| **自动计算字段** | `BEFORE` | `在保存前设置值` |
| **日志记录** | `AFTER` | `确保操作成功后记录` |
| **数据同步** | `AFTER` | `确保源数据已变更` |

### 3.3 时机控制示例


```sql
-- BEFORE示例：插入前自动设置创建时间
CREATE TRIGGER set_create_time
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    SET NEW.created_at = NOW();
END;

-- AFTER示例：删除后备份数据
CREATE TRIGGER backup_deleted_user
AFTER DELETE ON users
FOR EACH ROW
BEGIN
    INSERT INTO deleted_users_backup 
    SELECT OLD.*, NOW() as deleted_at;
END;
```

---

## 4. 📝 基础语法详解


### 4.1 CREATE TRIGGER完整语法


```sql
CREATE TRIGGER trigger_name
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON table_name
FOR EACH ROW
BEGIN
    -- 触发器执行的SQL语句
    trigger_body
END;
```

### 4.2 语法组成部分解释


**🔸 trigger_name（触发器名称）**
```
命名要求：
- 在数据库中必须唯一
- 建议使用描述性名称
- 通常包含时机+事件+表名

良好示例：
before_insert_users
after_update_products  
check_before_delete_orders
```

**🔸 触发时机关键字**
```sql
BEFORE  -- 在数据变更前执行
AFTER   -- 在数据变更后执行
```

**🔸 触发事件关键字**
```sql
INSERT  -- 插入操作触发
UPDATE  -- 更新操作触发  
DELETE  -- 删除操作触发
```

**🔸 FOR EACH ROW（行级触发器）**
```
含义：每affected的数据行都会执行一次触发器
这是MySQL唯一支持的触发器级别

示例：
如果一次UPDATE语句影响了10行数据
那么UPDATE触发器会执行10次
```

### 4.3 完整创建示例


```sql
-- 创建用户信息表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    email VARCHAR(100),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- 创建BEFORE INSERT触发器
CREATE TRIGGER users_before_insert
BEFORE INSERT ON users
FOR EACH ROW
BEGIN
    SET NEW.created_at = NOW();
    SET NEW.updated_at = NOW();
END;

-- 创建BEFORE UPDATE触发器
CREATE TRIGGER users_before_update  
BEFORE UPDATE ON users
FOR EACH ROW
BEGIN
    SET NEW.updated_at = NOW();
END;
```

---

## 5. 🏷️ 触发器命名规范


### 5.1 推荐命名模式


**📋 标准命名格式**
```
格式：[表名]_[时机]_[事件]
或：  [时机]_[事件]_[表名]

示例：
users_before_insert    ✅ 推荐
before_insert_users    ✅ 推荐  
user_bi               ❌ 不推荐（不够清晰）
trigger1              ❌ 不推荐（无意义）
```

### 5.2 命名规范示例


| **触发器类型** | **推荐命名** | **说明** |
|---------------|-------------|---------|
| **插入前** | `products_before_insert` | `清晰表达含义` |
| **更新后** | `orders_after_update` | `便于管理维护` |
| **删除前** | `check_before_delete_users` | `包含功能描述` |

### 5.3 命名最佳实践


```sql
-- ✅ 好的命名示例
CREATE TRIGGER products_before_insert      -- 清晰明了
CREATE TRIGGER audit_after_update_orders   -- 包含功能说明  
CREATE TRIGGER validate_before_delete_user -- 说明验证作用

-- ❌ 不好的命名示例  
CREATE TRIGGER tr1                         -- 无意义
CREATE TRIGGER product_trigger             -- 不够具体
CREATE TRIGGER trig_prod_ins              -- 缩写难懂
```

---

## 6. 🔄 FOR EACH ROW机制


### 6.1 行级触发器概念


**💡 FOR EACH ROW含义**
```
行级触发器：对每一行受影响的数据都执行一次触发器

与语句级触发器对比：
- 行级：影响5行数据 = 执行5次触发器
- 语句级：影响5行数据 = 执行1次触发器（MySQL不支持）
```

### 6.2 NEW和OLD关键字


**🔸 NEW关键字**
```sql
-- 在INSERT和UPDATE触发器中使用
-- 代表新插入或更新后的数据

BEFORE INSERT: NEW.column_name  -- 即将插入的值
BEFORE UPDATE: NEW.column_name  -- 即将更新的新值
AFTER INSERT:  NEW.column_name  -- 已插入的值
AFTER UPDATE:  NEW.column_name  -- 已更新的新值
```

**🔸 OLD关键字**
```sql
-- 在UPDATE和DELETE触发器中使用  
-- 代表更新前或删除前的原始数据

BEFORE UPDATE: OLD.column_name  -- 更新前的原值
BEFORE DELETE: OLD.column_name  -- 即将删除的值
AFTER UPDATE:  OLD.column_name  -- 更新前的原值
AFTER DELETE:  OLD.column_name  -- 已删除的值
```

### 6.3 NEW/OLD使用示例


```sql
-- 价格变更记录触发器
CREATE TRIGGER track_price_changes
AFTER UPDATE ON products
FOR EACH ROW  
BEGIN
    -- 只有价格发生变化时才记录
    IF OLD.price != NEW.price THEN
        INSERT INTO price_history (
            product_id, 
            old_price, 
            new_price, 
            changed_at
        ) VALUES (
            NEW.id,
            OLD.price,    -- 原价格
            NEW.price,    -- 新价格  
            NOW()
        );
    END IF;
END;
```

---

## 7. 🎯 激活条件控制


### 7.1 条件判断语法


**🔸 基本条件控制**
```sql
CREATE TRIGGER conditional_trigger
BEFORE UPDATE ON users
FOR EACH ROW
BEGIN
    -- 只有当状态发生变化时才执行
    IF OLD.status != NEW.status THEN
        -- 执行相关逻辑
        INSERT INTO status_log VALUES (NEW.id, OLD.status, NEW.status, NOW());
    END IF;
END;
```

### 7.2 复杂条件示例


```sql
-- 库存预警触发器
CREATE TRIGGER stock_warning
AFTER UPDATE ON products  
FOR EACH ROW
BEGIN
    -- 当库存低于预警线时发送提醒
    IF NEW.stock < 10 AND OLD.stock >= 10 THEN
        INSERT INTO alerts (message, created_at) 
        VALUES (CONCAT('产品 ', NEW.name, ' 库存不足'), NOW());
    END IF;
    
    -- 当库存为0时标记为缺货
    IF NEW.stock = 0 AND OLD.stock > 0 THEN
        UPDATE products SET status = 'out_of_stock' WHERE id = NEW.id;
    END IF;
END;
```

### 7.3 激活条件最佳实践


> **⚠️ 注意事项**
> - 避免在触发器中修改触发表本身，可能造成无限递归
> - 条件判断要考虑NULL值情况
> - 复杂逻辑建议拆分为多个简单触发器

---

## 8. 🚀 实际应用示例


### 8.1 订单系统示例


```sql
-- 订单表
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    total_amount DECIMAL(10,2),
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP
);

-- 订单项表  
CREATE TABLE order_items (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10,2)
);

-- 产品表
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    stock INT,
    price DECIMAL(10,2)
);
```

**📦 订单创建触发器**
```sql
-- 订单创建后自动减库存
CREATE TRIGGER reduce_stock_after_order
AFTER INSERT ON order_items
FOR EACH ROW
BEGIN
    UPDATE products 
    SET stock = stock - NEW.quantity 
    WHERE id = NEW.product_id;
END;
```

**📝 订单状态变更日志**
```sql
-- 记录订单状态变更历史
CREATE TRIGGER log_order_status_change
AFTER UPDATE ON orders
FOR EACH ROW  
BEGIN
    IF OLD.status != NEW.status THEN
        INSERT INTO order_status_log (
            order_id, 
            old_status, 
            new_status, 
            changed_at
        ) VALUES (
            NEW.id, 
            OLD.status, 
            NEW.status, 
            NOW()
        );
    END IF;
END;
```

### 8.2 用户管理示例


```sql
-- 用户注册后自动创建配置
CREATE TRIGGER create_user_profile
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_profiles (user_id, nickname, created_at)
    VALUES (NEW.id, NEW.username, NOW());
END;

-- 用户删除前备份数据
CREATE TRIGGER backup_before_delete_user  
BEFORE DELETE ON users
FOR EACH ROW
BEGIN
    INSERT INTO deleted_users_backup
    SELECT *, NOW() as deleted_at FROM users WHERE id = OLD.id;
END;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 触发器本质：数据库事件驱动的自动化程序
🔸 执行时机：BEFORE（变更前）和AFTER（变更后）
🔸 触发事件：INSERT、UPDATE、DELETE三种操作
🔸 FOR EACH ROW：每行数据都会执行一次触发器  
🔸 NEW/OLD：访问新数据和原数据的关键字
🔸 命名规范：清晰表达触发器的功能和时机
```

### 9.2 关键理解要点


**🔹 触发器的自动特性**
```
理解要点：
- 无需手动调用，数据变更时自动执行
- 应用程序无需关心触发器的存在
- 保证业务逻辑在数据库层面的一致性
```

**🔹 BEFORE vs AFTER的选择**
```
选择原则：
- 数据验证、自动计算 → 选择BEFORE  
- 日志记录、数据同步 → 选择AFTER
- 需要阻止操作 → 只能用BEFORE
```

**🔹 FOR EACH ROW的影响**
```
性能考虑：
- 大批量操作时要注意触发器执行次数
- 触发器逻辑要尽量简单高效
- 避免在触发器中执行复杂查询
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **电商系统**：订单创建自动减库存，状态变更记录日志
- **用户系统**：注册后自动初始化配置，删除前备份数据  
- **审计系统**：数据变更自动记录操作历史
- **数据同步**：主表变更自动更新相关从表

**🔧 开发实践**
- **数据完整性**：在数据库层面保证业务规则
- **自动化处理**：减少应用层的重复代码
- **审计追踪**：自动记录数据变更历史
- **业务解耦**：核心业务逻辑与数据库操作分离

**核心记忆口诀**：
```
触发器像是数据库的守护神，
数据变更时自动运行保平安。
BEFORE验证AFTER记录，
FOR EACH ROW逐行处理不停歇。
NEW是新值OLD是旧，
INSERT UPDATE DELETE三事件。
```