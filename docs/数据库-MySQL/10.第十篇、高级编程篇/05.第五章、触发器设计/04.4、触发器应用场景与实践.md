---
title: 4、触发器应用场景与实践
---
## 📚 目录

1. [触发器基础概念](#1-触发器基础概念)
2. [数据完整性约束](#2-数据完整性约束)
3. [业务规则自动化](#3-业务规则自动化)
4. [数据变更记录](#4-数据变更记录)
5. [统计信息维护](#5-统计信息维护)
6. [缓存更新触发](#6-缓存更新触发)
7. [消息通知机制](#7-消息通知机制)
8. [关联表数据同步](#8-关联表数据同步)
9. [复杂业务规则实现](#9-复杂业务规则实现)
10. [实时数据同步策略](#10-实时数据同步策略)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 触发器基础概念


### 1.1 什么是触发器


触发器就像数据库的"监控员"，当表中的数据发生变化时，它会自动执行预先设定的操作。

**🔍 核心定义**
```
触发器（Trigger）：数据库中自动执行的特殊存储过程
触发时机：当表发生INSERT、UPDATE、DELETE操作时自动运行
执行特点：无需手动调用，事件驱动自动执行
```

**💡 生活中的类比**
```
就像家里的烟雾报警器：
- 检测到烟雾（数据变化） → 自动响起警报（执行触发器）
- 不需要人工检查，24小时自动监控
- 一旦触发条件满足，立即执行预设动作
```

### 1.2 触发器的执行时机


**⏰ 触发时机分类**
```
BEFORE触发器：在数据变更之前执行
- 用途：数据验证、预处理、阻止不合法操作
- 特点：可以修改即将插入/更新的数据

AFTER触发器：在数据变更之后执行  
- 用途：日志记录、统计更新、关联操作
- 特点：数据已经确定变更，无法阻止操作

事件类型：
- INSERT：新增数据时触发
- UPDATE：修改数据时触发
- DELETE：删除数据时触发
```

### 1.3 触发器的工作原理


**🔄 执行流程图**
```
用户操作           触发器检查           实际执行
    ↓                  ↓                  ↓
INSERT INTO        →  BEFORE INSERT   →  数据写入表
UPDATE SET         →  BEFORE UPDATE   →  数据更新
DELETE FROM        →  BEFORE DELETE   →  数据删除
    ↓                  ↓                  ↓
操作完成           ←  AFTER触发器      ←  变更确认
```

**💻 基本语法结构**
```sql
CREATE TRIGGER trigger_name
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON table_name
FOR EACH ROW
BEGIN
    -- 触发器逻辑
END;
```

---

## 2. 🛡️ 数据完整性约束


### 2.1 自动数据验证


触发器可以实现比普通约束更复杂的数据验证规则，确保数据的完整性和准确性。

**📋 用户年龄验证示例**
```sql
-- 用户表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    age INT,
    email VARCHAR(100)
);

-- 年龄验证触发器
CREATE TRIGGER check_user_age
BEFORE INSERT ON users
FOR EACH ROW
BEGIN
    IF NEW.age < 0 OR NEW.age > 150 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '年龄必须在0-150之间';
    END IF;
END;
```

**🔍 工作原理解析**
```
当插入新用户时：
1. 系统准备插入数据
2. BEFORE INSERT触发器激活
3. 检查NEW.age的值（NEW代表即将插入的新数据）
4. 如果年龄不合理，抛出错误，阻止插入
5. 如果验证通过，继续插入操作
```

### 2.2 字段关联验证


**💰 订单金额一致性检查**
```sql
-- 订单表
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    total_amount DECIMAL(10,2),
    discount_amount DECIMAL(10,2),
    final_amount DECIMAL(10,2)
);

-- 金额一致性验证
CREATE TRIGGER validate_order_amounts
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    -- 检查最终金额是否等于总金额减去折扣
    IF NEW.final_amount != (NEW.total_amount - NEW.discount_amount) THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '订单金额计算错误';
    END IF;
    
    -- 检查折扣不能超过总金额
    IF NEW.discount_amount > NEW.total_amount THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '折扣金额不能超过订单总金额';
    END IF;
END;
```

### 2.3 业务状态验证


**📦 库存扣减验证**
```sql
-- 商品库存表
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    stock_quantity INT
);

-- 订单详情表
CREATE TABLE order_items (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    product_id INT,
    quantity INT
);

-- 库存检查触发器
CREATE TRIGGER check_stock_before_order
BEFORE INSERT ON order_items
FOR EACH ROW
BEGIN
    DECLARE current_stock INT;
    
    -- 获取当前库存
    SELECT stock_quantity INTO current_stock 
    FROM products 
    WHERE id = NEW.product_id;
    
    -- 检查库存是否充足
    IF current_stock < NEW.quantity THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = CONCAT('库存不足，当前库存：', current_stock);
    END IF;
END;
```

---

## 3. ⚙️ 业务规则自动化


### 3.1 自动计算和更新


触发器可以自动处理复杂的业务计算，无需在应用层编写重复代码。

**💳 会员积分自动计算**
```sql
-- 会员表
CREATE TABLE members (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    total_points INT DEFAULT 0,
    level ENUM('bronze', 'silver', 'gold', 'platinum') DEFAULT 'bronze'
);

-- 订单表（简化）
CREATE TABLE member_orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    member_id INT,
    order_amount DECIMAL(10,2)
);

-- 积分和等级自动更新触发器
CREATE TRIGGER update_member_points
AFTER INSERT ON member_orders
FOR EACH ROW
BEGIN
    DECLARE new_points INT;
    DECLARE new_level VARCHAR(20);
    
    -- 计算新增积分（每消费1元获得1积分）
    SET new_points = FLOOR(NEW.order_amount);
    
    -- 更新总积分
    UPDATE members 
    SET total_points = total_points + new_points
    WHERE id = NEW.member_id;
    
    -- 获取更新后的总积分
    SELECT total_points INTO new_points 
    FROM members 
    WHERE id = NEW.member_id;
    
    -- 根据积分自动调整会员等级
    IF new_points >= 10000 THEN
        SET new_level = 'platinum';
    ELSEIF new_points >= 5000 THEN
        SET new_level = 'gold';
    ELSEIF new_points >= 1000 THEN
        SET new_level = 'silver';
    ELSE
        SET new_level = 'bronze';
    END IF;
    
    -- 更新会员等级
    UPDATE members 
    SET level = new_level
    WHERE id = NEW.member_id;
END;
```

**🎯 工作流程说明**
```
用户下单 → 订单记录插入 → 触发器自动执行：
1. 根据订单金额计算积分
2. 累加到会员总积分
3. 根据新的总积分重新计算会员等级
4. 自动更新会员等级

好处：
✅ 业务逻辑集中在数据库层
✅ 确保数据一致性
✅ 减少应用层代码复杂度
```

### 3.2 状态自动流转


**📋 工单状态自动管理**
```sql
-- 工单表
CREATE TABLE tickets (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200),
    status ENUM('open', 'processing', 'resolved', 'closed') DEFAULT 'open',
    priority ENUM('low', 'medium', 'high', 'urgent') DEFAULT 'medium',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 工单处理记录表
CREATE TABLE ticket_actions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    ticket_id INT,
    action_type ENUM('assign', 'comment', 'resolve', 'close'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 状态自动流转触发器
CREATE TRIGGER auto_update_ticket_status
AFTER INSERT ON ticket_actions
FOR EACH ROW
BEGIN
    -- 根据操作类型自动更新工单状态
    CASE NEW.action_type
        WHEN 'assign' THEN
            UPDATE tickets SET status = 'processing' WHERE id = NEW.ticket_id;
        WHEN 'resolve' THEN
            UPDATE tickets SET status = 'resolved' WHERE id = NEW.ticket_id;
        WHEN 'close' THEN
            UPDATE tickets SET status = 'closed' WHERE id = NEW.ticket_id;
    END CASE;
END;
```

---

## 4. 📝 数据变更记录


### 4.1 完整审计日志


数据变更记录是触发器最常用的场景之一，可以追踪谁在什么时候修改了什么数据。

**🔍 用户信息变更日志**
```sql
-- 用户审计日志表
CREATE TABLE user_audit_log (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    action_type ENUM('INSERT', 'UPDATE', 'DELETE'),
    old_values JSON,
    new_values JSON,
    changed_by VARCHAR(100),
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户更新审计触发器
CREATE TRIGGER user_update_audit
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_audit_log (
        user_id, 
        action_type, 
        old_values, 
        new_values, 
        changed_by
    ) VALUES (
        NEW.id,
        'UPDATE',
        JSON_OBJECT(
            'username', OLD.username,
            'email', OLD.email,
            'age', OLD.age
        ),
        JSON_OBJECT(
            'username', NEW.username,
            'email', NEW.email,
            'age', NEW.age
        ),
        USER()
    );
END;

-- 用户删除审计触发器
CREATE TRIGGER user_delete_audit
BEFORE DELETE ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_audit_log (
        user_id, 
        action_type, 
        old_values, 
        changed_by
    ) VALUES (
        OLD.id,
        'DELETE',
        JSON_OBJECT(
            'username', OLD.username,
            'email', OLD.email,
            'age', OLD.age
        ),
        USER()
    );
END;
```

**📊 审计日志查询示例**
```sql
-- 查看某用户的所有变更记录
SELECT 
    action_type,
    old_values,
    new_values,
    changed_by,
    changed_at
FROM user_audit_log 
WHERE user_id = 123 
ORDER BY changed_at DESC;

-- 查看最近24小时的所有用户变更
SELECT COUNT(*) as change_count, action_type
FROM user_audit_log 
WHERE changed_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
GROUP BY action_type;
```

### 4.2 敏感字段变更追踪


**💰 价格变更专项记录**
```sql
-- 商品价格变更日志
CREATE TABLE price_change_log (
    id INT PRIMARY KEY AUTO_INCREMENT,
    product_id INT,
    old_price DECIMAL(10,2),
    new_price DECIMAL(10,2),
    change_amount DECIMAL(10,2),
    change_percentage DECIMAL(5,2),
    changed_by VARCHAR(100),
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 价格变更触发器
CREATE TRIGGER track_price_changes
AFTER UPDATE ON products
FOR EACH ROW
BEGIN
    -- 只有价格发生变化时才记录
    IF OLD.price != NEW.price THEN
        INSERT INTO price_change_log (
            product_id,
            old_price,
            new_price,
            change_amount,
            change_percentage,
            changed_by
        ) VALUES (
            NEW.id,
            OLD.price,
            NEW.price,
            NEW.price - OLD.price,
            ROUND((NEW.price - OLD.price) / OLD.price * 100, 2),
            USER()
        );
    END IF;
END;
```

---

## 5. 📊 统计信息维护


### 5.1 实时统计更新


触发器可以实时维护各种统计信息，避免复杂的定时任务和聚合查询。

**📈 实时销售统计**
```sql
-- 商品销售统计表
CREATE TABLE product_stats (
    product_id INT PRIMARY KEY,
    total_sold INT DEFAULT 0,
    total_revenue DECIMAL(12,2) DEFAULT 0,
    last_sold_at TIMESTAMP NULL
);

-- 订单详情表（简化）
CREATE TABLE order_details (
    id INT PRIMARY KEY AUTO_INCREMENT,
    product_id INT,
    quantity INT,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(10,2)
);

-- 销售统计更新触发器
CREATE TRIGGER update_product_stats
AFTER INSERT ON order_details
FOR EACH ROW
BEGIN
    -- 更新或插入产品统计信息
    INSERT INTO product_stats (
        product_id, 
        total_sold, 
        total_revenue, 
        last_sold_at
    ) VALUES (
        NEW.product_id,
        NEW.quantity,
        NEW.total_amount,
        NOW()
    ) ON DUPLICATE KEY UPDATE
        total_sold = total_sold + NEW.quantity,
        total_revenue = total_revenue + NEW.total_amount,
        last_sold_at = NOW();
END;
```

**🎯 统计数据的价值**
```
实时性：每笔订单都会立即更新统计
准确性：避免了手动计算可能出现的错误
高效性：无需定时扫描大量历史数据

应用场景：
- 热销商品排行榜
- 销售业绩实时看板
- 库存预警系统
- 商业智能分析
```

### 5.2 用户行为统计


**👤 用户活跃度统计**
```sql
-- 用户活跃度统计表
CREATE TABLE user_activity_stats (
    user_id INT PRIMARY KEY,
    login_count INT DEFAULT 0,
    last_login_at TIMESTAMP NULL,
    order_count INT DEFAULT 0,
    total_spent DECIMAL(12,2) DEFAULT 0
);

-- 用户登录记录表
CREATE TABLE user_logins (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 登录统计更新触发器
CREATE TRIGGER update_login_stats
AFTER INSERT ON user_logins
FOR EACH ROW
BEGIN
    INSERT INTO user_activity_stats (
        user_id, 
        login_count, 
        last_login_at
    ) VALUES (
        NEW.user_id,
        1,
        NEW.login_time
    ) ON DUPLICATE KEY UPDATE
        login_count = login_count + 1,
        last_login_at = NEW.login_time;
END;
```

---

## 6. 🔄 缓存更新触发


### 6.1 自动缓存失效


当核心数据发生变化时，触发器可以自动触发缓存更新或失效操作。

**💾 商品信息缓存管理**
```sql
-- 缓存失效记录表
CREATE TABLE cache_invalidation (
    id INT PRIMARY KEY AUTO_INCREMENT,
    cache_key VARCHAR(255),
    action ENUM('invalidate', 'refresh') DEFAULT 'invalidate',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 商品信息变更触发缓存失效
CREATE TRIGGER invalidate_product_cache
AFTER UPDATE ON products
FOR EACH ROW
BEGIN
    -- 如果关键信息发生变化，触发缓存失效
    IF OLD.name != NEW.name 
       OR OLD.price != NEW.price 
       OR OLD.description != NEW.description THEN
        
        INSERT INTO cache_invalidation (cache_key, action) VALUES
        (CONCAT('product:', NEW.id), 'invalidate'),
        (CONCAT('product_list:category:', NEW.category_id), 'invalidate');
    END IF;
END;
```

**🔧 应用层缓存处理**
```sql
-- 应用可以定期检查缓存失效记录
SELECT cache_key, action 
FROM cache_invalidation 
WHERE created_at > '2024-01-01 12:00:00'
ORDER BY created_at;

-- 处理完成后清理记录
DELETE FROM cache_invalidation 
WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 HOUR);
```

### 6.2 多级缓存协调


**🏗️ 分层缓存管理**
```sql
-- 缓存层级定义
CREATE TABLE cache_layers (
    layer_name VARCHAR(50) PRIMARY KEY,
    priority INT,
    ttl_seconds INT
);

-- 插入缓存层级配置
INSERT INTO cache_layers VALUES
('redis', 1, 300),      -- Redis缓存，5分钟TTL
('memcached', 2, 600),  -- Memcached缓存，10分钟TTL
('cdn', 3, 3600);       -- CDN缓存，1小时TTL

-- 分层缓存失效触发器
CREATE TRIGGER multi_layer_cache_invalidation
AFTER UPDATE ON products
FOR EACH ROW
BEGIN
    DECLARE layer_name VARCHAR(50);
    DECLARE done INT DEFAULT FALSE;
    DECLARE cache_cursor CURSOR FOR 
        SELECT layer_name FROM cache_layers ORDER BY priority;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- 如果是重要字段变化，失效所有层级的缓存
    IF OLD.price != NEW.price OR OLD.stock_quantity != NEW.stock_quantity THEN
        OPEN cache_cursor;
        cache_loop: LOOP
            FETCH cache_cursor INTO layer_name;
            IF done THEN
                LEAVE cache_loop;
            END IF;
            
            INSERT INTO cache_invalidation (cache_key, action) VALUES
            (CONCAT(layer_name, ':product:', NEW.id), 'invalidate');
        END LOOP;
        CLOSE cache_cursor;
    END IF;
END;
```

---

## 7. 📢 消息通知机制


### 7.1 实时消息推送


触发器可以在数据变化时自动发送通知消息，实现实时的业务提醒。

**🚨 库存预警通知**
```sql
-- 消息队列表
CREATE TABLE message_queue (
    id INT PRIMARY KEY AUTO_INCREMENT,
    message_type VARCHAR(50),
    recipient VARCHAR(100),
    subject VARCHAR(200),
    content TEXT,
    priority ENUM('low', 'medium', 'high', 'urgent') DEFAULT 'medium',
    status ENUM('pending', 'sent', 'failed') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 库存预警触发器
CREATE TRIGGER stock_alert_notification
AFTER UPDATE ON products
FOR EACH ROW
BEGIN
    DECLARE warning_threshold INT DEFAULT 10;
    DECLARE alert_threshold INT DEFAULT 5;
    
    -- 库存降到预警线以下
    IF NEW.stock_quantity <= warning_threshold 
       AND OLD.stock_quantity > warning_threshold THEN
        
        INSERT INTO message_queue (
            message_type,
            recipient,
            subject,
            content,
            priority
        ) VALUES (
            'stock_warning',
            'inventory@company.com',
            CONCAT('库存预警：', NEW.name),
            CONCAT('商品 "', NEW.name, '" 库存不足，当前库存：', NEW.stock_quantity),
            CASE 
                WHEN NEW.stock_quantity <= alert_threshold THEN 'urgent'
                ELSE 'high'
            END
        );
    END IF;
END;
```

### 7.2 业务流程通知


**📋 订单状态变更通知**
```sql
-- 订单状态变更通知触发器
CREATE TRIGGER order_status_notification
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    -- 订单状态发生变化时发送通知
    IF OLD.status != NEW.status THEN
        INSERT INTO message_queue (
            message_type,
            recipient,
            subject,
            content,
            priority
        ) VALUES (
            'order_status_change',
            (SELECT email FROM customers WHERE id = NEW.customer_id),
            CONCAT('订单状态更新：', NEW.order_number),
            CONCAT('您的订单 ', NEW.order_number, ' 状态已更新为：', NEW.status),
            'medium'
        );
        
        -- 特殊状态需要内部通知
        CASE NEW.status
            WHEN 'cancelled' THEN
                INSERT INTO message_queue (
                    message_type, recipient, subject, content, priority
                ) VALUES (
                    'order_cancelled',
                    'sales@company.com',
                    CONCAT('订单取消提醒：', NEW.order_number),
                    CONCAT('订单 ', NEW.order_number, ' 已被取消，请及时处理'),
                    'high'
                );
            WHEN 'shipped' THEN
                INSERT INTO message_queue (
                    message_type, recipient, subject, content, priority
                ) VALUES (
                    'order_shipped',
                    'logistics@company.com',
                    CONCAT('订单已发货：', NEW.order_number),
                    CONCAT('订单 ', NEW.order_number, ' 已发货，请关注物流状态'),
                    'medium'
                );
        END CASE;
    END IF;
END;
```

---

## 8. 🔗 关联表数据同步


### 8.1 主从表数据一致性


当主表数据发生变化时，相关的从表数据也需要同步更新以保持一致性。

**👥 用户信息同步更新**
```sql
-- 用户基本信息表
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    status ENUM('active', 'inactive', 'banned') DEFAULT 'active'
);

-- 用户扩展信息表
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    display_name VARCHAR(100),
    contact_email VARCHAR(100),
    last_login_at TIMESTAMP
);

-- 用户订单汇总表
CREATE TABLE user_order_summary (
    user_id INT PRIMARY KEY,
    total_orders INT DEFAULT 0,
    total_amount DECIMAL(12,2) DEFAULT 0,
    user_status VARCHAR(20)
);

-- 用户信息同步触发器
CREATE TRIGGER sync_user_info
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
    -- 同步用户状态到订单汇总表
    UPDATE user_order_summary 
    SET user_status = NEW.status 
    WHERE user_id = NEW.id;
    
    -- 如果邮箱发生变化，同步到用户资料表
    IF OLD.email != NEW.email THEN
        UPDATE user_profiles 
        SET contact_email = NEW.email 
        WHERE user_id = NEW.id;
    END IF;
    
    -- 如果用户被禁用，记录禁用时间
    IF OLD.status != 'banned' AND NEW.status = 'banned' THEN
        INSERT INTO user_audit_log (
            user_id, action_type, new_values, changed_by
        ) VALUES (
            NEW.id, 'STATUS_CHANGE',
            JSON_OBJECT('status', 'banned', 'banned_at', NOW()),
            USER()
        );
    END IF;
END;
```

### 8.2 关联计算字段维护


**💰 订单金额汇总维护**
```sql
-- 订单表
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    total_amount DECIMAL(10,2),
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled')
);

-- 客户统计表
CREATE TABLE customer_statistics (
    customer_id INT PRIMARY KEY,
    total_orders INT DEFAULT 0,
    total_paid_amount DECIMAL(12,2) DEFAULT 0,
    avg_order_amount DECIMAL(10,2) DEFAULT 0,
    last_order_date DATE
);

-- 订单统计维护触发器
CREATE TRIGGER maintain_customer_stats
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    INSERT INTO customer_statistics (
        customer_id,
        total_orders,
        total_paid_amount,
        avg_order_amount,
        last_order_date
    ) VALUES (
        NEW.customer_id,
        1,
        CASE WHEN NEW.status IN ('paid', 'shipped', 'completed') 
             THEN NEW.total_amount ELSE 0 END,
        NEW.total_amount,
        CURDATE()
    ) ON DUPLICATE KEY UPDATE
        total_orders = total_orders + 1,
        total_paid_amount = total_paid_amount + 
            CASE WHEN NEW.status IN ('paid', 'shipped', 'completed') 
                 THEN NEW.total_amount ELSE 0 END,
        avg_order_amount = total_paid_amount / total_orders,
        last_order_date = CURDATE();
END;

-- 订单状态更新统计维护
CREATE TRIGGER update_customer_stats_on_status_change
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    DECLARE paid_amount_change DECIMAL(10,2) DEFAULT 0;
    
    -- 计算已付金额的变化
    IF OLD.status NOT IN ('paid', 'shipped', 'completed') 
       AND NEW.status IN ('paid', 'shipped', 'completed') THEN
        SET paid_amount_change = NEW.total_amount;
    ELSEIF OLD.status IN ('paid', 'shipped', 'completed') 
           AND NEW.status NOT IN ('paid', 'shipped', 'completed') THEN
        SET paid_amount_change = -OLD.total_amount;
    END IF;
    
    -- 更新客户统计
    IF paid_amount_change != 0 THEN
        UPDATE customer_statistics 
        SET total_paid_amount = total_paid_amount + paid_amount_change,
            avg_order_amount = total_paid_amount / total_orders
        WHERE customer_id = NEW.customer_id;
    END IF;
END;
```

---

## 9. 🎛️ 复杂业务规则实现


### 9.1 多条件业务逻辑


触发器可以实现复杂的多条件业务规则，将业务逻辑集中在数据库层面管理。

**🏆 会员等级升降级规则**
```sql
-- 会员等级规则表
CREATE TABLE membership_rules (
    level_name VARCHAR(20) PRIMARY KEY,
    min_points INT,
    min_orders INT,
    min_amount DECIMAL(10,2),
    validity_months INT
);

-- 插入等级规则
INSERT INTO membership_rules VALUES
('bronze', 0, 0, 0, 12),
('silver', 1000, 5, 5000, 12),
('gold', 5000, 20, 20000, 12),
('platinum', 15000, 50, 50000, 12);

-- 复杂会员等级计算触发器
CREATE TRIGGER complex_membership_upgrade
AFTER UPDATE ON user_activity_stats
FOR EACH ROW
BEGIN
    DECLARE new_level VARCHAR(20);
    DECLARE current_date DATE DEFAULT CURDATE();
    DECLARE member_since DATE;
    
    -- 获取会员注册时间
    SELECT created_at INTO member_since 
    FROM members 
    WHERE id = NEW.user_id;
    
    -- 复杂的等级判定逻辑
    SELECT level_name INTO new_level
    FROM membership_rules
    WHERE NEW.login_count >= min_orders
      AND NEW.total_spent >= min_amount
      AND (
          -- 新会员或老会员续期
          DATEDIFF(current_date, member_since) <= validity_months * 30
          OR NEW.total_spent >= min_amount * 1.5  -- 高消费用户特殊处理
      )
    ORDER BY min_points DESC
    LIMIT 1;
    
    -- 更新会员等级
    IF new_level IS NOT NULL THEN
        UPDATE members 
        SET level = new_level,
            level_updated_at = NOW()
        WHERE id = NEW.user_id
          AND level != new_level;  -- 只有等级发生变化时才更新
        
        -- 等级变化记录
        IF ROW_COUNT() > 0 THEN
            INSERT INTO member_level_history (
                member_id, 
                old_level, 
                new_level, 
                change_reason,
                changed_at
            ) VALUES (
                NEW.user_id,
                (SELECT level FROM members WHERE id = NEW.user_id),
                new_level,
                'automatic_upgrade',
                NOW()
            );
        END IF;
    END IF;
END;
```

### 9.2 条件化数据处理


**📊 动态定价策略**
```sql
-- 定价策略表
CREATE TABLE pricing_strategies (
    id INT PRIMARY KEY AUTO_INCREMENT,
    product_category VARCHAR(50),
    time_period ENUM('morning', 'afternoon', 'evening', 'weekend'),
    discount_percentage DECIMAL(5,2),
    min_quantity INT,
    is_active BOOLEAN DEFAULT TRUE
);

-- 订单动态定价触发器
CREATE TRIGGER apply_dynamic_pricing
BEFORE INSERT ON order_items
FOR EACH ROW
BEGIN
    DECLARE base_price DECIMAL(10,2);
    DECLARE discount_rate DECIMAL(5,2) DEFAULT 0;
    DECLARE current_hour INT;
    DECLARE current_day VARCHAR(10);
    DECLARE time_period VARCHAR(20);
    
    -- 获取基础价格
    SELECT price INTO base_price 
    FROM products 
    WHERE id = NEW.product_id;
    
    -- 确定时间段
    SET current_hour = HOUR(NOW());
    SET current_day = DAYNAME(NOW());
    
    CASE 
        WHEN current_day IN ('Saturday', 'Sunday') THEN 
            SET time_period = 'weekend';
        WHEN current_hour BETWEEN 6 AND 11 THEN 
            SET time_period = 'morning';
        WHEN current_hour BETWEEN 12 AND 17 THEN 
            SET time_period = 'afternoon';
        ELSE 
            SET time_period = 'evening';
    END CASE;
    
    -- 查找适用的定价策略
    SELECT discount_percentage INTO discount_rate
    FROM pricing_strategies ps
    JOIN products p ON p.category = ps.product_category
    WHERE p.id = NEW.product_id
      AND ps.time_period = time_period
      AND NEW.quantity >= ps.min_quantity
      AND ps.is_active = TRUE
    ORDER BY ps.discount_percentage DESC
    LIMIT 1;
    
    -- 应用动态定价
    SET NEW.unit_price = base_price * (1 - discount_rate / 100);
    SET NEW.total_amount = NEW.unit_price * NEW.quantity;
END;
```

---

## 10. ⚡ 实时数据同步策略


### 10.1 跨数据库同步


触发器可以实现不同数据库之间的实时数据同步，保持数据一致性。

**🔄 主从数据库同步**
```sql
-- 数据同步记录表
CREATE TABLE sync_operations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    table_name VARCHAR(100),
    operation_type ENUM('INSERT', 'UPDATE', 'DELETE'),
    record_id INT,
    sync_data JSON,
    sync_status ENUM('pending', 'completed', 'failed') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户数据同步触发器
CREATE TRIGGER sync_user_changes
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
    INSERT INTO sync_operations (
        table_name,
        operation_type,
        record_id,
        sync_data
    ) VALUES (
        'users',
        'UPDATE',
        NEW.id,
        JSON_OBJECT(
            'id', NEW.id,
            'username', NEW.username,
            'email', NEW.email,
            'updated_at', NOW()
        )
    );
END;

-- 用户新增同步触发器
CREATE TRIGGER sync_user_inserts
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    INSERT INTO sync_operations (
        table_name,
        operation_type,
        record_id,
        sync_data
    ) VALUES (
        'users',
        'INSERT',
        NEW.id,
        JSON_OBJECT(
            'id', NEW.id,
            'username', NEW.username,
            'email', NEW.email,
            'created_at', NOW()
        )
    );
END;
```

### 10.2 数据仓库ETL


**📈 实时数据仓库更新**
```sql
-- 数据仓库事实表
CREATE TABLE fact_sales (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_date DATE,
    product_id INT,
    customer_id INT,
    quantity INT,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 实时ETL触发器
CREATE TRIGGER real_time_etl
AFTER INSERT ON order_items
FOR EACH ROW
BEGIN
    DECLARE order_date DATE;
    DECLARE customer_id INT;
    
    -- 获取订单相关信息
    SELECT DATE(created_at), customer_id 
    INTO order_date, customer_id
    FROM orders 
    WHERE id = NEW.order_id;
    
    -- 插入到数据仓库事实表
    INSERT INTO fact_sales (
        order_date,
        product_id,
        customer_id,
        quantity,
        unit_price,
        total_amount
    ) VALUES (
        order_date,
        NEW.product_id,
        customer_id,
        NEW.quantity,
        NEW.unit_price,
        NEW.total_amount
    );
    
    -- 更新产品维度表的统计信息
    UPDATE dim_products 
    SET total_sales_amount = total_sales_amount + NEW.total_amount,
        total_sales_quantity = total_sales_quantity + NEW.quantity,
        last_sale_date = order_date
    WHERE product_id = NEW.product_id;
END;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 触发器本质：数据库的自动化"监控员"，事件驱动执行
🔸 执行时机：BEFORE/AFTER + INSERT/UPDATE/DELETE组合
🔸 核心优势：数据一致性保障、业务逻辑集中化、实时响应
🔸 应用场景：数据验证、审计日志、统计维护、消息通知
🔸 设计原则：简单高效、避免复杂逻辑、注意性能影响
```

### 11.2 关键理解要点


**🔹 触发器的工作机制**
```
理解要点：
- 触发器是被动执行的，由数据变更事件驱动
- NEW代表新数据，OLD代表旧数据
- BEFORE触发器可以修改数据，AFTER触发器只能记录
- 触发器中的错误会阻止原始操作的执行
```

**🔹 业务价值体现**
```
数据完整性：
✅ 自动验证复杂业务规则
✅ 确保关联数据的一致性
✅ 防止无效数据的产生

业务自动化：
✅ 减少手动维护工作
✅ 实时响应数据变化
✅ 统一业务逻辑管理
```

**🔹 使用注意事项**
```
性能考虑：
⚠️ 避免在触发器中执行复杂查询
⚠️ 注意触发器的递归调用
⚠️ 大批量操作时考虑性能影响

设计原则：
✅ 保持触发器逻辑简单
✅ 避免在触发器中调用外部服务
✅ 合理使用BEFORE和AFTER时机
```

### 11.3 实际应用指导


**🎯 场景选择指南**
```
适用场景：
✅ 数据完整性约束
✅ 审计日志记录
✅ 实时统计维护
✅ 关联数据同步
✅ 业务规则自动化

不适用场景：
❌ 复杂的业务逻辑处理
❌ 需要外部API调用
❌ 大量数据的批处理
❌ 频繁变化的业务规则
```

**🛠️ 最佳实践建议**
```
设计建议：
1. 保持触发器逻辑简单明了
2. 避免触发器间的相互调用
3. 合理处理异常情况
4. 定期审查和优化触发器

性能优化：
1. 只在必要时使用触发器
2. 避免在触发器中执行慢查询
3. 考虑使用存储过程替代复杂逻辑
4. 监控触发器的执行性能
```

### 11.4 学习路径建议


```
🎓 学习步骤：
基础语法 → 简单应用 → 复杂业务 → 性能优化
    ↓         ↓         ↓         ↓
  触发器创建   数据验证   业务自动化   监控调优

🔧 实践项目：
1. 用户操作审计系统
2. 商品库存管理系统
3. 订单状态流转系统
4. 实时数据统计面板

📚 扩展学习：
- 存储过程与函数
- 数据库性能优化
- 事务处理机制
- 数据库架构设计
```

**核心记忆口诀**：
```
触发器好比数据库守卫，数据变化自动响应
BEFORE验证AFTER记录，业务规则集中管理
简单高效是关键，复杂逻辑要避免
数据一致性保障，实时处理是优势
```