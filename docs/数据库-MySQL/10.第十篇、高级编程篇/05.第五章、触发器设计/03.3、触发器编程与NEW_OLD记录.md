---
title: 3、触发器编程与NEW_OLD记录
---
## 📚 目录

1. [触发器编程基础](#1-触发器编程基础)
2. [NEW记录详解](#2-NEW记录详解)
3. [OLD记录详解](#3-OLD记录详解)
4. [触发器变量与逻辑](#4-触发器变量与逻辑)
5. [记录字段访问机制](#5-记录字段访问机制)
6. [触发器编程限制](#6-触发器编程限制)
7. [实战应用案例](#7-实战应用案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 触发器编程基础


### 1.1 什么是触发器编程

触发器编程就是在触发器内部编写逻辑代码，让数据库在特定操作时自动执行我们预设的业务逻辑。

**简单理解**：就像给数据库安装一个"自动助手"，当有人增删改数据时，助手会按照我们写好的程序自动处理相关任务。

```sql
-- 基本触发器结构
DELIMITER $$
CREATE TRIGGER trigger_name
    BEFORE/AFTER INSERT/UPDATE/DELETE
    ON table_name
    FOR EACH ROW
BEGIN
    -- 这里就是触发器编程区域
    -- 可以写变量声明、条件判断、SQL语句等
END$$
DELIMITER ;
```

### 1.2 触发器编程的核心组成


**🔸 变量声明区**：定义触发器内部使用的变量
```sql
DECLARE variable_name datatype DEFAULT value;
```

**🔸 逻辑处理区**：编写条件判断和业务逻辑
```sql
IF condition THEN
    -- 处理逻辑
END IF;
```

**🔸 SQL执行区**：在触发器内执行其他SQL语句
```sql
INSERT INTO log_table VALUES (NEW.id, NOW());
```

---

## 2. 📋 NEW记录详解


### 2.1 NEW记录是什么

NEW记录是MySQL触发器中的一个特殊关键字，代表**即将插入或更新后的新数据记录**。

**通俗解释**：NEW就像一个"预览窗口"，让我们看到数据操作完成后的样子。

### 2.2 NEW记录的使用场景


**🔸 INSERT触发器中的NEW**
```sql
-- 示例：用户注册时自动记录日志
CREATE TRIGGER user_insert_log
    AFTER INSERT ON users
    FOR EACH ROW
BEGIN
    INSERT INTO user_logs (user_id, username, action, created_time)
    VALUES (NEW.id, NEW.username, 'REGISTER', NOW());
END$$
```

**🔸 UPDATE触发器中的NEW**
```sql
-- 示例：更新商品价格时记录价格变化
CREATE TRIGGER product_price_update
    AFTER UPDATE ON products
    FOR EACH ROW
BEGIN
    IF NEW.price != OLD.price THEN
        INSERT INTO price_history (product_id, old_price, new_price, change_time)
        VALUES (NEW.id, OLD.price, NEW.price, NOW());
    END IF;
END$$
```

### 2.3 NEW记录访问方式


**访问语法**：`NEW.字段名`

```sql
-- 访问不同类型的字段
NEW.id          -- 访问主键
NEW.username    -- 访问用户名
NEW.email       -- 访问邮箱
NEW.created_at  -- 访问创建时间
```

**🔸 NEW记录的可用性**
```
INSERT触发器：✅ 可用 (代表新插入的记录)
UPDATE触发器：✅ 可用 (代表更新后的记录)  
DELETE触发器：❌ 不可用 (没有新记录)
```

---

## 3. 📄 OLD记录详解


### 3.1 OLD记录是什么

OLD记录代表**操作前的原始数据记录**，让我们能够获取到数据变化前的状态。

**通俗解释**：OLD就像一个"历史快照"，保存着数据修改前的原始样子。

### 3.2 OLD记录的使用场景


**🔸 UPDATE触发器中的OLD**
```sql
-- 示例：监控敏感字段的修改
CREATE TRIGGER user_sensitive_update
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    -- 如果邮箱被修改，记录旧邮箱
    IF NEW.email != OLD.email THEN
        INSERT INTO email_change_log (user_id, old_email, new_email, change_time)
        VALUES (OLD.id, OLD.email, NEW.email, NOW());
    END IF;
END$$
```

**🔸 DELETE触发器中的OLD**
```sql
-- 示例：删除用户时备份用户信息
CREATE TRIGGER user_delete_backup
    BEFORE DELETE ON users
    FOR EACH ROW
BEGIN
    INSERT INTO deleted_users (original_id, username, email, deleted_time)
    VALUES (OLD.id, OLD.username, OLD.email, NOW());
END$$
```

### 3.3 OLD记录的可用性

```
INSERT触发器：❌ 不可用 (没有原始记录)
UPDATE触发器：✅ 可用 (代表更新前的记录)
DELETE触发器：✅ 可用 (代表被删除的记录)
```

---

## 4. 🔄 触发器变量与逻辑


### 4.1 触发器变量声明

在触发器中可以声明变量来存储临时数据和计算结果。

```sql
-- 变量声明语法
DECLARE variable_name datatype [DEFAULT value];

-- 实际示例
CREATE TRIGGER order_status_update
    AFTER UPDATE ON orders
    FOR EACH ROW
BEGIN
    DECLARE status_msg VARCHAR(100);
    DECLARE log_level INT DEFAULT 1;
    
    -- 根据订单状态设置消息
    IF NEW.status = 'completed' THEN
        SET status_msg = '订单已完成';
        SET log_level = 2;
    ELSEIF NEW.status = 'cancelled' THEN
        SET status_msg = '订单已取消';
        SET log_level = 3;
    END IF;
    
    INSERT INTO order_logs (order_id, message, level, log_time)
    VALUES (NEW.id, status_msg, log_level, NOW());
END$$
```

### 4.2 条件判断逻辑


**🔸 基本IF语句**
```sql
IF condition THEN
    -- 处理逻辑
ELSEIF another_condition THEN
    -- 另一种处理
ELSE
    -- 默认处理
END IF;
```

**🔸 实际应用示例**
```sql
CREATE TRIGGER inventory_check
    BEFORE UPDATE ON products
    FOR EACH ROW
BEGIN
    DECLARE alert_msg VARCHAR(200);
    
    -- 库存检查逻辑
    IF NEW.stock < 10 THEN
        SET alert_msg = CONCAT('商品 ', NEW.name, ' 库存不足，仅剩 ', NEW.stock, ' 件');
        INSERT INTO inventory_alerts (product_id, message, alert_time)
        VALUES (NEW.id, alert_msg, NOW());
    END IF;
    
    -- 价格变化检查
    IF NEW.price > OLD.price * 1.2 THEN
        INSERT INTO price_alerts (product_id, old_price, new_price, message)
        VALUES (NEW.id, OLD.price, NEW.price, '价格涨幅超过20%');
    END IF;
END$$
```

### 4.3 触发器变量作用域


**变量作用域规则**：
- 触发器内声明的变量只在当前触发器中有效
- 变量在BEGIN-END块结束后自动销毁
- 不同触发器之间的变量相互独立

```sql
-- 变量作用域示例
CREATE TRIGGER demo_scope
    AFTER INSERT ON test_table
    FOR EACH ROW
BEGIN
    DECLARE local_var INT DEFAULT 0;  -- 局部变量
    SET local_var = NEW.id * 2;
    
    -- local_var只在这个触发器中有效
    INSERT INTO result_table (value) VALUES (local_var);
END$$
-- 触发器结束后，local_var自动销毁
```

---

## 5. 🗂️ 记录字段访问机制


### 5.1 字段访问基础语法


**NEW/OLD记录字段访问**：
```sql
NEW.字段名    -- 访问新记录的字段
OLD.字段名    -- 访问原记录的字段
```

### 5.2 不同数据类型字段的访问


```sql
CREATE TRIGGER field_access_demo
    AFTER UPDATE ON user_profiles
    FOR EACH ROW
BEGIN
    -- 整数类型字段
    INSERT INTO logs (user_id) VALUES (NEW.user_id);
    
    -- 字符串类型字段
    INSERT INTO logs (message) VALUES (CONCAT('用户名从 ', OLD.username, ' 改为 ', NEW.username));
    
    -- 日期类型字段  
    INSERT INTO logs (log_time) VALUES (NEW.updated_at);
    
    -- 浮点数类型字段
    INSERT INTO logs (score_change) VALUES (NEW.score - OLD.score);
    
    -- JSON类型字段（MySQL 5.7+）
    INSERT INTO logs (preferences) VALUES (NEW.preferences);
END$$
```

### 5.3 字段存在性检查


```sql
-- 检查字段是否为NULL
CREATE TRIGGER null_check_demo
    BEFORE INSERT ON users
    FOR EACH ROW
BEGIN
    -- 检查必填字段
    IF NEW.email IS NULL OR NEW.email = '' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '邮箱不能为空';
    END IF;
    
    -- 为空字段设置默认值
    IF NEW.nickname IS NULL THEN
        SET NEW.nickname = CONCAT('用户', NEW.id);
    END IF;
END$$
```

---

## 6. ⚠️ 触发器编程限制


### 6.1 NEW/OLD记录访问限制


**🔸 使用限制表**
| 触发器类型 | NEW记录 | OLD记录 | 说明 |
|------------|---------|---------|------|
| **BEFORE INSERT** | ✅ 可读写 | ❌ 不可用 | 可修改NEW中的值 |
| **AFTER INSERT** | ✅ 只读 | ❌ 不可用 | 不能修改NEW中的值 |
| **BEFORE UPDATE** | ✅ 可读写 | ✅ 只读 | 可修改NEW，不能修改OLD |
| **AFTER UPDATE** | ✅ 只读 | ✅ 只读 | 都不能修改 |
| **BEFORE DELETE** | ❌ 不可用 | ✅ 只读 | 只能读取OLD |
| **AFTER DELETE** | ❌ 不可用 | ✅ 只读 | 只能读取OLD |

**🔸 实际应用示例**
```sql
-- ✅ 正确：BEFORE INSERT中修改NEW
CREATE TRIGGER before_insert_modify
    BEFORE INSERT ON users
    FOR EACH ROW
BEGIN
    SET NEW.created_at = NOW();  -- 可以修改
    SET NEW.status = 'active';   -- 可以修改
END$$

-- ❌ 错误：AFTER INSERT中修改NEW
CREATE TRIGGER after_insert_error
    AFTER INSERT ON users
    FOR EACH ROW
BEGIN
    SET NEW.created_at = NOW();  -- 报错！不能修改
END$$
```

### 6.2 触发器内SQL语句限制


**🔸 禁止的操作**
```sql
-- ❌ 不能在触发器中操作触发器所在的表
CREATE TRIGGER recursive_error
    AFTER INSERT ON users
    FOR EACH ROW
BEGIN
    INSERT INTO users (username) VALUES ('test');  -- 会造成无限递归
END$$

-- ❌ 不能使用某些SQL语句
BEGIN
    COMMIT;    -- 不允许
    ROLLBACK;  -- 不允许
    LOCK TABLES; -- 不允许
END$$
```

**🔸 允许的操作**
```sql
-- ✅ 可以操作其他表
CREATE TRIGGER allowed_operations
    AFTER INSERT ON orders
    FOR EACH ROW
BEGIN
    -- 可以操作其他表
    INSERT INTO order_logs (order_id, action) VALUES (NEW.id, 'CREATED');
    UPDATE user_stats SET order_count = order_count + 1 WHERE user_id = NEW.user_id;
    
    -- 可以调用存储过程
    CALL update_user_level(NEW.user_id);
END$$
```

### 6.3 触发器性能限制


**性能注意事项**：
- 触发器会增加数据操作的延迟
- 复杂逻辑可能导致死锁
- 过多的触发器会影响数据库性能

```sql
-- 🚨 避免复杂计算
CREATE TRIGGER performance_bad
    AFTER UPDATE ON products
    FOR EACH ROW
BEGIN
    -- ❌ 避免复杂查询
    DECLARE total_sales DECIMAL(10,2);
    SELECT SUM(amount) INTO total_sales 
    FROM orders 
    WHERE product_id = NEW.id 
      AND created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR);
END$$

-- ✅ 推荐简单快速的操作
CREATE TRIGGER performance_good
    AFTER UPDATE ON products
    FOR EACH ROW
BEGIN
    -- ✅ 简单的日志记录
    INSERT INTO product_update_log (product_id, updated_at)
    VALUES (NEW.id, NOW());
END$$
```

---

## 7. 🎯 实战应用案例


### 7.1 用户积分系统触发器


```sql
-- 用户下单自动增加积分
CREATE TRIGGER order_points_reward
    AFTER INSERT ON orders
    FOR EACH ROW
BEGIN
    DECLARE points_earned INT DEFAULT 0;
    DECLARE user_level VARCHAR(20);
    
    -- 根据订单金额计算积分
    SET points_earned = FLOOR(NEW.total_amount / 10);
    
    -- 获取用户等级
    SELECT level INTO user_level 
    FROM users 
    WHERE id = NEW.user_id;
    
    -- VIP用户双倍积分
    IF user_level = 'VIP' THEN
        SET points_earned = points_earned * 2;
    END IF;
    
    -- 更新用户积分
    UPDATE users 
    SET points = points + points_earned 
    WHERE id = NEW.user_id;
    
    -- 记录积分变化日志
    INSERT INTO points_log (user_id, order_id, points_change, reason, created_at)
    VALUES (NEW.user_id, NEW.id, points_earned, '订单消费', NOW());
END$$
```

### 7.2 商品库存监控触发器


```sql
-- 库存变化监控和预警
CREATE TRIGGER inventory_monitor
    AFTER UPDATE ON products
    FOR EACH ROW
BEGIN
    DECLARE stock_change INT;
    DECLARE alert_level VARCHAR(20) DEFAULT 'NORMAL';
    
    -- 计算库存变化量
    SET stock_change = NEW.stock - OLD.stock;
    
    -- 只处理库存有变化的情况
    IF stock_change != 0 THEN
        -- 判断预警级别
        IF NEW.stock <= 5 THEN
            SET alert_level = 'CRITICAL';
        ELSEIF NEW.stock <= 20 THEN
            SET alert_level = 'WARNING';
        END IF;
        
        -- 记录库存变化
        INSERT INTO inventory_log (
            product_id, 
            old_stock, 
            new_stock, 
            stock_change, 
            alert_level,
            change_time
        ) VALUES (
            NEW.id, 
            OLD.stock, 
            NEW.stock, 
            stock_change, 
            alert_level,
            NOW()
        );
        
        -- 库存严重不足时发送预警
        IF alert_level = 'CRITICAL' THEN
            INSERT INTO system_alerts (
                alert_type, 
                message, 
                priority, 
                created_at
            ) VALUES (
                'INVENTORY_LOW', 
                CONCAT('商品 ', NEW.name, ' 库存严重不足，仅剩 ', NEW.stock, ' 件'),
                'HIGH',
                NOW()
            );
        END IF;
    END IF;
END$$
```

### 7.3 数据变更审计触发器


```sql
-- 用户敏感信息变更审计
CREATE TRIGGER user_audit_trigger
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    DECLARE change_details JSON DEFAULT JSON_OBJECT();
    DECLARE has_sensitive_change BOOLEAN DEFAULT FALSE;
    
    -- 检查敏感字段变化
    IF NEW.email != OLD.email THEN
        SET change_details = JSON_SET(change_details, '$.email', JSON_OBJECT('old', OLD.email, 'new', NEW.email));
        SET has_sensitive_change = TRUE;
    END IF;
    
    IF NEW.phone != OLD.phone THEN
        SET change_details = JSON_SET(change_details, '$.phone', JSON_OBJECT('old', OLD.phone, 'new', NEW.phone));
        SET has_sensitive_change = TRUE;
    END IF;
    
    IF NEW.id_card != OLD.id_card THEN
        SET change_details = JSON_SET(change_details, '$.id_card', JSON_OBJECT('old', OLD.id_card, 'new', NEW.id_card));
        SET has_sensitive_change = TRUE;
    END IF;
    
    -- 如果有敏感信息变更，记录审计日志
    IF has_sensitive_change THEN
        INSERT INTO user_audit_log (
            user_id, 
            change_type, 
            change_details, 
            change_time,
            ip_address
        ) VALUES (
            NEW.id, 
            'SENSITIVE_INFO_UPDATE', 
            change_details,
            NOW(),
            @user_ip  -- 假设通过会话变量传递IP
        );
    END IF;
END$$
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 NEW记录：代表新数据，在INSERT和UPDATE中可用
🔸 OLD记录：代表原数据，在UPDATE和DELETE中可用  
🔸 BEFORE触发器：可以修改NEW记录的值
🔸 AFTER触发器：只能读取NEW/OLD记录，不能修改
🔸 触发器变量：局部作用域，触发器结束后销毁
```

### 8.2 关键理解要点


**🔹 NEW/OLD记录的本质**
```
NEW记录 = 数据操作后的"预期结果"
OLD记录 = 数据操作前的"历史快照"
两者配合使用可以完整追踪数据变化过程
```

**🔹 触发器编程的核心思路**
```
1. 先判断操作类型 (INSERT/UPDATE/DELETE)
2. 选择合适的NEW/OLD记录访问
3. 编写业务逻辑和条件判断
4. 执行相关的SQL操作
5. 记录日志或发送通知
```

**🔹 使用场景选择**
```
数据验证 → BEFORE触发器 + NEW记录修改
日志记录 → AFTER触发器 + NEW/OLD记录读取
业务联动 → AFTER触发器 + 其他表操作
审计跟踪 → UPDATE触发器 + NEW/OLD对比
```

### 8.3 实际应用价值


- **数据完整性**：自动验证和修正数据
- **业务自动化**：减少应用层的复杂逻辑
- **审计跟踪**：完整记录数据变化历史  
- **实时响应**：数据变化时立即执行相关操作
- **性能优化**：在数据库层面处理简单逻辑

**核心记忆口诀**：
- NEW记录看未来，OLD记录看过去
- BEFORE能改NEW，AFTER只能看
- 变量作用域局部，逻辑清晰最重要
- 简单快速是王道，复杂逻辑要避免

> 💡 **学习建议**
> 
> 触发器编程需要多练习，建议从简单的日志记录开始，逐步掌握复杂的业务逻辑实现。记住触发器是数据库的"自动化助手"，要让它做合适的事情，不要过度使用。