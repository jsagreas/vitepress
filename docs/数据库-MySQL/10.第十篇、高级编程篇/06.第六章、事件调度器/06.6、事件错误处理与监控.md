---
title: 6、事件错误处理与监控
---
## 📚 目录

1. [事件错误处理基础](#1-事件错误处理基础)
2. [错误日志记录机制](#2-错误日志记录机制)
3. [异常情况监控策略](#3-异常情况监控策略)
4. [重试机制设计](#4-重试机制设计)
5. [告警通知机制](#5-告警通知机制)
6. [故障排查方法](#6-故障排查方法)
7. [监控指标收集](#7-监控指标收集)
8. [事件执行历史记录](#8-事件执行历史记录)
9. [失败事件自动恢复](#9-失败事件自动恢复)
10. [事件监控Dashboard](#10-事件监控dashboard)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔧 事件错误处理基础


### 1.1 什么是事件错误处理


**简单理解**：就像定时闹钟可能会出故障一样，MySQL的定时事件也可能执行失败。我们需要建立一套机制来发现问题、记录问题、解决问题。

```
生活类比：
家用洗衣机 → MySQL事件调度器
定时洗衣 → 定时执行任务
洗衣故障 → 事件执行失败
故障提示 → 错误处理机制
```

### 1.2 常见事件错误类型


**🔸 语法错误**
```sql
-- 错误示例：语法错误的事件
CREATE EVENT syntax_error_event
ON SCHEDULE EVERY 1 HOUR
DO
  -- 这里有语法错误，缺少分号
  UPDATE users SET last_login = NOW()
  INSERT INTO logs VALUES('update completed');  -- 语法错误
```

**🔸 权限错误**
```sql
-- 事件创建者权限不足时会失败
CREATE EVENT permission_error_event
ON SCHEDULE EVERY 1 DAY
DO
  DROP DATABASE sensitive_db;  -- 可能没有删除权限
```

**🔸 资源限制错误**
```sql
-- 长时间运行的事件可能超时
CREATE EVENT long_running_event
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
  -- 这个查询可能运行很久
  UPDATE large_table SET status = 'processed' 
  WHERE created_date < DATE_SUB(NOW(), INTERVAL 1 YEAR);
END;
```

### 1.3 事件状态检查


**🔍 查看事件状态**
```sql
-- 检查所有事件的状态
SELECT 
  event_name,
  event_schema,
  status,
  last_executed,
  last_altered,
  event_comment
FROM information_schema.EVENTS;

-- 查看特定事件的详细信息
SHOW EVENTS WHERE Name = 'your_event_name';
```

---

## 2. 📝 错误日志记录机制


### 2.1 MySQL内置错误日志


**简单理解**：MySQL会把事件执行时的错误信息写到日志文件里，就像医生给病人写病历一样。

**🔸 查看错误日志位置**
```sql
-- 查看错误日志文件位置
SHOW VARIABLES LIKE 'log_error';

-- 查看是否启用了事件调度器日志
SHOW VARIABLES LIKE 'event_scheduler';
```

**🔸 典型错误日志内容**
```
2025-09-07T10:30:15.123456Z [ERROR] Event Scheduler: 
[root@localhost][db_name.event_name] 
Table 'db_name.non_existing_table' doesn't exist

2025-09-07T10:30:15.123456Z [ERROR] Event Scheduler: 
Error code: 1146; SQLSTATE: 42S02
```

### 2.2 自定义错误日志表


**为什么需要**：MySQL内置日志信息有限，我们需要更详细的错误记录来帮助分析问题。

```sql
-- 创建事件错误日志表
CREATE TABLE event_error_log (
  id INT AUTO_INCREMENT PRIMARY KEY,
  event_name VARCHAR(100),
  error_time DATETIME,
  error_code INT,
  error_message TEXT,
  sql_statement TEXT,
  server_id INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**🔸 在事件中记录错误**
```sql
DELIMITER //
CREATE EVENT monitored_cleanup_event
ON SCHEDULE EVERY 1 DAY
STARTS '2025-09-08 02:00:00'
DO
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- 记录错误信息
    INSERT INTO event_error_log (
      event_name, 
      error_time, 
      error_message,
      sql_statement
    ) VALUES (
      'monitored_cleanup_event',
      NOW(),
      '数据清理过程中发生错误',
      'DELETE FROM old_data WHERE created_date < DATE_SUB(NOW(), INTERVAL 30 DAY)'
    );
  END;
  
  -- 实际业务逻辑
  DELETE FROM old_data 
  WHERE created_date < DATE_SUB(NOW(), INTERVAL 30 DAY);
  
  -- 记录成功信息
  INSERT INTO event_error_log (
    event_name,
    error_time,
    error_message,
    sql_statement
  ) VALUES (
    'monitored_cleanup_event',
    NOW(),
    '数据清理成功完成',
    CONCAT('清理了 ', ROW_COUNT(), ' 条记录')
  );
END//
DELIMITER ;
```

---

## 3. 🔍 异常情况监控策略


### 3.1 事件执行状态监控


**核心思路**：定期检查事件是否正常执行，就像定时检查家里的电器是否正常工作。

```sql
-- 创建事件心跳表
CREATE TABLE event_heartbeat (
  event_name VARCHAR(100) PRIMARY KEY,
  last_heartbeat DATETIME,
  expected_interval_minutes INT,
  status ENUM('正常', '延迟', '失败') DEFAULT '正常',
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**🔸 心跳监控事件**
```sql
DELIMITER //
CREATE EVENT heartbeat_monitor
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
  -- 更新当前时间
  INSERT INTO event_heartbeat (event_name, last_heartbeat, expected_interval_minutes)
  VALUES ('heartbeat_monitor', NOW(), 5)
  ON DUPLICATE KEY UPDATE 
    last_heartbeat = NOW(),
    status = '正常';
    
  -- 检查其他事件是否超时
  UPDATE event_heartbeat 
  SET status = '延迟'
  WHERE event_name != 'heartbeat_monitor'
    AND last_heartbeat < DATE_SUB(NOW(), INTERVAL expected_interval_minutes*2 MINUTE);
END//
DELIMITER ;
```

### 3.2 系统资源监控


**🔸 监控数据库连接数**
```sql
-- 记录当前连接状态
CREATE TABLE connection_monitor (
  check_time DATETIME,
  total_connections INT,
  active_connections INT,
  max_connections INT,
  connection_usage_percent DECIMAL(5,2)
);

DELIMITER //
CREATE EVENT connection_monitor_event
ON SCHEDULE EVERY 10 MINUTE
DO
BEGIN
  INSERT INTO connection_monitor (
    check_time,
    total_connections,
    max_connections,
    connection_usage_percent
  )
  SELECT 
    NOW(),
    VARIABLE_VALUE as total_connections,
    $$max_connections as max_connections,
    (VARIABLE_VALUE / $$max_connections) * 100 as usage_percent
  FROM information_schema.GLOBAL_STATUS 
  WHERE VARIABLE_NAME = 'Threads_connected';
END//
DELIMITER ;
```

---

## 4. 🔄 重试机制设计


### 4.1 简单重试机制


**核心思想**：如果事件执行失败，自动再试几次，就像网络不好时手机会自动重连一样。

```sql
-- 创建重试配置表
CREATE TABLE event_retry_config (
  event_name VARCHAR(100) PRIMARY KEY,
  max_retry_count INT DEFAULT 3,
  retry_interval_minutes INT DEFAULT 5,
  current_retry_count INT DEFAULT 0,
  last_retry_time DATETIME,
  status ENUM('等待重试', '重试中', '成功', '最终失败') DEFAULT '等待重试'
);
```

**🔸 带重试的事件示例**
```sql
DELIMITER //
CREATE EVENT data_sync_with_retry
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
  DECLARE retry_count INT DEFAULT 0;
  DECLARE max_retries INT DEFAULT 3;
  DECLARE retry_success BOOLEAN DEFAULT FALSE;
  
  -- 重试循环
  retry_loop: LOOP
    BEGIN
      -- 异常处理
      DECLARE EXIT HANDLER FOR SQLEXCEPTION
      BEGIN
        SET retry_count = retry_count + 1;
        
        -- 记录重试信息
        INSERT INTO event_error_log (
          event_name, 
          error_time, 
          error_message
        ) VALUES (
          'data_sync_with_retry',
          NOW(),
          CONCAT('第', retry_count, '次重试失败')
        );
        
        -- 如果达到最大重试次数，退出
        IF retry_count >= max_retries THEN
          LEAVE retry_loop;
        END IF;
      END;
      
      -- 实际业务逻辑
      UPDATE user_stats 
      SET daily_count = (
        SELECT COUNT(*) 
        FROM user_activities 
        WHERE DATE(created_at) = CURDATE()
      );
      
      -- 如果执行到这里说明成功了
      SET retry_success = TRUE;
      LEAVE retry_loop;
    END;
  END LOOP;
  
  -- 记录最终结果
  IF retry_success THEN
    INSERT INTO event_error_log VALUES (
      NULL, 'data_sync_with_retry', NOW(), 0, 
      '数据同步成功', NULL, $$server_id, NOW()
    );
  ELSE
    INSERT INTO event_error_log VALUES (
      NULL, 'data_sync_with_retry', NOW(), -1,
      CONCAT('数据同步最终失败，重试', retry_count, '次'), 
      NULL, $$server_id, NOW()
    );
  END IF;
END//
DELIMITER ;
```

### 4.2 指数退避重试


**什么是指数退避**：每次重试的间隔时间逐渐增长，避免频繁重试给系统造成压力。

```sql
-- 重试间隔：1分钟 → 2分钟 → 4分钟 → 8分钟
DELIMITER //
CREATE EVENT smart_retry_event
ON SCHEDULE EVERY 1 MINUTE
DO
BEGIN
  DECLARE retry_interval INT;
  DECLARE should_execute BOOLEAN DEFAULT FALSE;
  
  -- 获取当前重试状态
  SELECT 
    CASE 
      WHEN current_retry_count = 0 THEN TRUE
      WHEN last_retry_time IS NULL THEN TRUE
      WHEN TIMESTAMPDIFF(MINUTE, last_retry_time, NOW()) >= 
           POWER(2, current_retry_count) THEN TRUE
      ELSE FALSE
    END INTO should_execute
  FROM event_retry_config 
  WHERE event_name = 'smart_retry_event';
  
  -- 只有到了重试时间才执行
  IF should_execute THEN
    -- 执行业务逻辑和重试处理
    CALL execute_with_smart_retry('smart_retry_event');
  END IF;
END//
DELIMITER ;
```

---

## 5. 🚨 告警通知机制


### 5.1 基于数据库的告警系统


**基本思路**：把告警信息存到数据库表中，外部程序定期检查这个表来发送通知。

```sql
-- 创建告警表
CREATE TABLE alert_notifications (
  id INT AUTO_INCREMENT PRIMARY KEY,
  alert_type ENUM('错误', '警告', '信息') DEFAULT '信息',
  event_name VARCHAR(100),
  alert_title VARCHAR(200),
  alert_message TEXT,
  alert_level ENUM('低', '中', '高', '紧急') DEFAULT '中',
  is_sent BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  sent_at TIMESTAMP NULL
);
```

**🔸 事件中触发告警**
```sql
DELIMITER //
CREATE EVENT critical_data_check
ON SCHEDULE EVERY 30 MINUTE
DO
BEGIN
  DECLARE critical_count INT;
  
  -- 检查关键数据
  SELECT COUNT(*) INTO critical_count
  FROM orders 
  WHERE status = 'pending' 
    AND created_at < DATE_SUB(NOW(), INTERVAL 2 HOUR);
  
  -- 如果有积压订单，发送告警
  IF critical_count > 100 THEN
    INSERT INTO alert_notifications (
      alert_type,
      event_name,
      alert_title,
      alert_message,
      alert_level
    ) VALUES (
      '错误',
      'critical_data_check',
      '订单积压告警',
      CONCAT('发现 ', critical_count, ' 个超过2小时未处理的订单'),
      '高'
    );
  END IF;
END//
DELIMITER ;
```

### 5.2 邮件通知存储过程


**为什么用存储过程**：把复杂的告警逻辑封装起来，多个事件可以复用。

```sql
DELIMITER //
CREATE PROCEDURE send_event_alert(
  IN p_event_name VARCHAR(100),
  IN p_alert_message TEXT,
  IN p_alert_level ENUM('低', '中', '高', '紧急')
)
BEGIN
  DECLARE alert_count INT;
  
  -- 检查最近是否已发送过相同告警
  SELECT COUNT(*) INTO alert_count
  FROM alert_notifications
  WHERE event_name = p_event_name
    AND alert_message = p_alert_message
    AND created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR);
  
  -- 避免重复告警
  IF alert_count = 0 THEN
    INSERT INTO alert_notifications (
      alert_type,
      event_name,
      alert_title,
      alert_message,
      alert_level
    ) VALUES (
      '错误',
      p_event_name,
      CONCAT(p_event_name, ' 执行异常'),
      p_alert_message,
      p_alert_level
    );
  END IF;
END//
DELIMITER ;
```

---

## 6. 🔧 故障排查方法


### 6.1 故障排查检查清单


**🔸 基础检查步骤**

| 检查项目 | 检查命令 | 说明 |
|---------|---------|------|
| **事件调度器状态** | `SHOW VARIABLES LIKE 'event_scheduler';` | 确认调度器是否启用 |
| **事件列表** | `SHOW EVENTS;` | 查看所有事件状态 |
| **错误日志** | `SHOW VARIABLES LIKE 'log_error';` | 找到错误日志位置 |
| **系统权限** | `SHOW GRANTS FOR CURRENT_USER();` | 检查当前用户权限 |

### 6.2 常见问题诊断


**🔸 事件不执行的排查**
```sql
-- 1. 检查事件是否启用
SELECT 
  event_name,
  status,
  last_executed,
  next_execution_time
FROM information_schema.EVENTS 
WHERE event_schema = DATABASE();

-- 2. 检查事件调度器全局状态
SHOW PROCESSLIST;  -- 查看是否有 event_scheduler 进程

-- 3. 手动测试事件内容
-- 把事件的 DO 部分单独执行，看是否有错误
```

**🔸 事件执行缓慢排查**
```sql
-- 创建性能监控事件
DELIMITER //
CREATE EVENT performance_monitor
ON SCHEDULE EVERY 1 MINUTE
DO
BEGIN
  DECLARE start_time DATETIME;
  DECLARE end_time DATETIME;
  DECLARE execution_seconds INT;
  
  SET start_time = NOW();
  
  -- 执行业务逻辑
  CALL your_business_procedure();
  
  SET end_time = NOW();
  SET execution_seconds = TIMESTAMPDIFF(SECOND, start_time, end_time);
  
  -- 记录执行时间
  INSERT INTO performance_log (
    event_name, 
    start_time, 
    end_time, 
    execution_seconds
  ) VALUES (
    'performance_monitor',
    start_time,
    end_time,
    execution_seconds
  );
  
  -- 如果执行超过5分钟，记录告警
  IF execution_seconds > 300 THEN
    CALL send_event_alert(
      'performance_monitor',
      CONCAT('事件执行时间过长：', execution_seconds, '秒'),
      '中'
    );
  END IF;
END//
DELIMITER ;
```

---

## 7. 📊 监控指标收集


### 7.1 核心监控指标


**🔸 事件执行统计表**
```sql
CREATE TABLE event_statistics (
  id INT AUTO_INCREMENT PRIMARY KEY,
  event_name VARCHAR(100),
  execution_date DATE,
  total_executions INT DEFAULT 0,
  successful_executions INT DEFAULT 0,
  failed_executions INT DEFAULT 0,
  avg_execution_time_seconds DECIMAL(10,2),
  max_execution_time_seconds INT,
  last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY unique_event_date (event_name, execution_date)
);
```

**🔸 统计收集事件**
```sql
DELIMITER //
CREATE EVENT collect_event_stats
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
  -- 统计今天的事件执行情况
  INSERT INTO event_statistics (
    event_name,
    execution_date,
    total_executions,
    successful_executions,
    failed_executions
  )
  SELECT 
    event_name,
    CURDATE(),
    COUNT(*) as total,
    SUM(CASE WHEN error_code = 0 THEN 1 ELSE 0 END) as success,
    SUM(CASE WHEN error_code != 0 THEN 1 ELSE 0 END) as failed
  FROM event_error_log
  WHERE DATE(error_time) = CURDATE()
  GROUP BY event_name
  ON DUPLICATE KEY UPDATE
    total_executions = VALUES(total_executions),
    successful_executions = VALUES(successful_executions),
    failed_executions = VALUES(failed_executions);
END//
DELIMITER ;
```

### 7.2 系统健康度监控


```sql
-- 系统健康度快照表
CREATE TABLE system_health_snapshot (
  snapshot_time DATETIME PRIMARY KEY,
  active_events_count INT,
  failed_events_last_hour INT,
  avg_event_execution_time DECIMAL(10,2),
  database_connections INT,
  cpu_usage_percent DECIMAL(5,2),
  memory_usage_percent DECIMAL(5,2)
);

DELIMITER //
CREATE EVENT system_health_check
ON SCHEDULE EVERY 15 MINUTE
DO
BEGIN
  INSERT INTO system_health_snapshot (
    snapshot_time,
    active_events_count,
    failed_events_last_hour,
    avg_event_execution_time,
    database_connections
  )
  SELECT 
    NOW(),
    (SELECT COUNT(*) FROM information_schema.EVENTS WHERE status = 'ENABLED'),
    (SELECT COUNT(*) FROM event_error_log 
     WHERE error_time > DATE_SUB(NOW(), INTERVAL 1 HOUR) 
       AND error_code != 0),
    (SELECT AVG(execution_seconds) FROM performance_log 
     WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)),
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Threads_connected');
END//
DELIMITER ;
```

---

## 8. 📋 事件执行历史记录


### 8.1 详细执行日志


**为什么重要**：就像银行要保存所有交易记录一样，我们需要记录每次事件执行的详细信息。

```sql
-- 事件执行历史表
CREATE TABLE event_execution_history (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  event_name VARCHAR(100),
  execution_start DATETIME,
  execution_end DATETIME,
  execution_status ENUM('成功', '失败', '部分成功'),
  rows_affected INT,
  execution_details JSON,
  error_message TEXT,
  server_hostname VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_event_time (event_name, execution_start),
  INDEX idx_status_time (execution_status, execution_start)
);
```

**🔸 执行历史记录事件**
```sql
DELIMITER //
CREATE EVENT log_execution_history
ON SCHEDULE EVERY 1 DAY
STARTS '2025-09-08 01:00:00'
DO
BEGIN
  DECLARE v_start_time DATETIME;
  DECLARE v_end_time DATETIME;
  DECLARE v_rows_affected INT DEFAULT 0;
  DECLARE v_status VARCHAR(20) DEFAULT '成功';
  DECLARE v_error_msg TEXT DEFAULT NULL;
  
  SET v_start_time = NOW();
  
  BEGIN
    -- 异常处理
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
      SET v_status = '失败';
      SET v_error_msg = '数据处理过程中发生错误';
      SET v_end_time = NOW();
      
      -- 记录失败信息
      INSERT INTO event_execution_history (
        event_name, execution_start, execution_end,
        execution_status, error_message, server_hostname
      ) VALUES (
        'log_execution_history', v_start_time, v_end_time,
        v_status, v_error_msg, $$hostname
      );
    END;
    
    -- 实际业务逻辑：清理30天前的临时数据
    DELETE FROM temp_data 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);
    
    SET v_rows_affected = ROW_COUNT();
    SET v_end_time = NOW();
    
    -- 记录成功信息
    INSERT INTO event_execution_history (
      event_name, execution_start, execution_end,
      execution_status, rows_affected, 
      execution_details, server_hostname
    ) VALUES (
      'log_execution_history', v_start_time, v_end_time,
      v_status, v_rows_affected,
      JSON_OBJECT('deleted_rows', v_rows_affected, 'cleanup_type', 'temp_data'),
      $$hostname
    );
  END;
END//
DELIMITER ;
```

### 8.2 历史数据查询


**🔸 常用查询语句**
```sql
-- 查看最近24小时的事件执行情况
SELECT 
  event_name,
  execution_status,
  COUNT(*) as execution_count,
  AVG(TIMESTAMPDIFF(SECOND, execution_start, execution_end)) as avg_duration,
  MAX(TIMESTAMPDIFF(SECOND, execution_start, execution_end)) as max_duration
FROM event_execution_history
WHERE execution_start > DATE_SUB(NOW(), INTERVAL 24 HOUR)
GROUP BY event_name, execution_status
ORDER BY event_name;

-- 查看失败率最高的事件
SELECT 
  event_name,
  COUNT(*) as total_executions,
  SUM(CASE WHEN execution_status = '失败' THEN 1 ELSE 0 END) as failures,
  ROUND(SUM(CASE WHEN execution_status = '失败' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as failure_rate
FROM event_execution_history
WHERE execution_start > DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY event_name
HAVING failure_rate > 10
ORDER BY failure_rate DESC;
```

---

## 9. 🔄 失败事件自动恢复


### 9.1 自动恢复机制设计


**核心理念**：当发现事件失败时，系统能够自动尝试修复或重新执行，减少人工干预。

```sql
-- 自动恢复配置表
CREATE TABLE auto_recovery_config (
  event_name VARCHAR(100) PRIMARY KEY,
  recovery_enabled BOOLEAN DEFAULT TRUE,
  max_recovery_attempts INT DEFAULT 3,
  recovery_interval_minutes INT DEFAULT 30,
  recovery_strategy ENUM('重新执行', '部分重试', '降级处理') DEFAULT '重新执行',
  notification_required BOOLEAN DEFAULT TRUE
);
```

**🔸 自动恢复执行器**
```sql
DELIMITER //
CREATE EVENT auto_recovery_executor
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE v_event_name VARCHAR(100);
  DECLARE v_recovery_strategy VARCHAR(20);
  DECLARE v_max_attempts INT;
  
  -- 声明游标查找需要恢复的事件
  DECLARE recovery_cursor CURSOR FOR
    SELECT DISTINCT 
      h.event_name,
      c.recovery_strategy,
      c.max_recovery_attempts
    FROM event_execution_history h
    JOIN auto_recovery_config c ON h.event_name = c.event_name
    WHERE h.execution_status = '失败'
      AND h.execution_start > DATE_SUB(NOW(), INTERVAL 1 HOUR)
      AND c.recovery_enabled = TRUE
      AND NOT EXISTS (
        -- 确保不是已经在恢复中的事件
        SELECT 1 FROM event_execution_history h2 
        WHERE h2.event_name = h.event_name 
          AND h2.execution_start > h.execution_start
      );
  
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
  
  OPEN recovery_cursor;
  
  recovery_loop: LOOP
    FETCH recovery_cursor INTO v_event_name, v_recovery_strategy, v_max_attempts;
    IF done THEN
      LEAVE recovery_loop;
    END IF;
    
    -- 执行恢复策略
    CASE v_recovery_strategy
      WHEN '重新执行' THEN
        CALL execute_recovery_retry(v_event_name, v_max_attempts);
      WHEN '部分重试' THEN
        CALL execute_partial_recovery(v_event_name);
      WHEN '降级处理' THEN
        CALL execute_degraded_recovery(v_event_name);
    END CASE;
    
  END LOOP;
  
  CLOSE recovery_cursor;
END//
DELIMITER ;
```

### 9.2 智能恢复策略


**🔸 基于错误类型的恢复**
```sql
DELIMITER //
CREATE PROCEDURE smart_recovery_handler(
  IN p_event_name VARCHAR(100),
  IN p_error_message TEXT
)
BEGIN
  DECLARE recovery_action VARCHAR(100);
  
  -- 根据错误类型决定恢复策略
  CASE 
    WHEN p_error_message LIKE '%Lock wait timeout%' THEN
      SET recovery_action = '延迟重试';
      -- 等待锁释放后重试
      INSERT INTO event_retry_config (event_name, retry_interval_minutes)
      VALUES (p_event_name, 10)
      ON DUPLICATE KEY UPDATE retry_interval_minutes = 10;
      
    WHEN p_error_message LIKE '%Deadlock%' THEN
      SET recovery_action = '立即重试';
      -- 死锁通常可以立即重试
      INSERT INTO event_retry_config (event_name, retry_interval_minutes)
      VALUES (p_event_name, 1)
      ON DUPLICATE KEY UPDATE retry_interval_minutes = 1;
      
    WHEN p_error_message LIKE '%Table%doesn%exist%' THEN
      SET recovery_action = '跳过执行';
      -- 表不存在，可能需要人工处理
      CALL send_event_alert(
        p_event_name,
        '事件引用的表不存在，需要人工检查',
        '高'
      );
      
    ELSE
      SET recovery_action = '标准重试';
      INSERT INTO event_retry_config (event_name, retry_interval_minutes)
      VALUES (p_event_name, 5)
      ON DUPLICATE KEY UPDATE retry_interval_minutes = 5;
  END CASE;
  
  -- 记录恢复操作
  INSERT INTO event_error_log (
    event_name, error_time, error_message
  ) VALUES (
    p_event_name, NOW(), 
    CONCAT('自动恢复策略：', recovery_action)
  );
END//
DELIMITER ;
```

---

## 10. 📊 事件监控Dashboard


### 10.1 实时监控视图


**目标**：创建一个数据视图，让管理员可以快速了解系统整体状况。

```sql
-- 创建实时监控视图
CREATE VIEW event_monitor_dashboard AS
SELECT 
  -- 基础信息
  '系统概览' AS section,
  CONCAT('活跃事件: ', 
    (SELECT COUNT(*) FROM information_schema.EVENTS WHERE status = 'ENABLED')
  ) AS metric_name,
  NULL AS metric_value,
  '正常' AS status
  
UNION ALL

SELECT 
  '最近1小时',
  '执行成功',
  COUNT(*),
  CASE WHEN COUNT(*) > 0 THEN '正常' ELSE '异常' END
FROM event_execution_history
WHERE execution_start > DATE_SUB(NOW(), INTERVAL 1 HOUR)
  AND execution_status = '成功'

UNION ALL

SELECT 
  '最近1小时',
  '执行失败', 
  COUNT(*),
  CASE WHEN COUNT(*) = 0 THEN '正常' 
       WHEN COUNT(*) <= 3 THEN '警告'
       ELSE '严重' END
FROM event_execution_history
WHERE execution_start > DATE_SUB(NOW(), INTERVAL 1 HOUR)
  AND execution_status = '失败'

UNION ALL

SELECT
  '系统负载',
  '数据库连接数',
  VARIABLE_VALUE,
  CASE WHEN VARIABLE_VALUE < $$max_connections * 0.8 THEN '正常'
       WHEN VARIABLE_VALUE < $$max_connections * 0.9 THEN '警告'
       ELSE '严重' END
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Threads_connected';
```

### 10.2 性能趋势分析


**🔸 事件性能趋势表**
```sql
CREATE TABLE event_performance_trend (
  trend_date DATE,
  total_events INT,
  avg_execution_time DECIMAL(10,2),
  success_rate DECIMAL(5,2),
  peak_hour INT,
  daily_summary JSON,
  PRIMARY KEY (trend_date)
);

-- 每日性能趋势统计
DELIMITER //
CREATE EVENT daily_performance_summary
ON SCHEDULE EVERY 1 DAY
STARTS '2025-09-08 00:30:00'
DO
BEGIN
  INSERT INTO event_performance_trend (
    trend_date,
    total_events,
    avg_execution_time,
    success_rate,
    peak_hour,
    daily_summary
  )
  SELECT 
    CURDATE() - INTERVAL 1 DAY as yesterday,
    COUNT(*) as total,
    AVG(TIMESTAMPDIFF(SECOND, execution_start, execution_end)) as avg_time,
    ROUND(SUM(CASE WHEN execution_status = '成功' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as success_rate,
    HOUR(execution_start) as peak_hour,
    JSON_OBJECT(
      'busiest_event', (
        SELECT event_name 
        FROM event_execution_history 
        WHERE DATE(execution_start) = CURDATE() - INTERVAL 1 DAY
        GROUP BY event_name 
        ORDER BY COUNT(*) DESC 
        LIMIT 1
      ),
      'longest_execution', MAX(TIMESTAMPDIFF(SECOND, execution_start, execution_end)),
      'total_failures', SUM(CASE WHEN execution_status = '失败' THEN 1 ELSE 0 END)
    )
  FROM event_execution_history
  WHERE DATE(execution_start) = CURDATE() - INTERVAL 1 DAY;
END//
DELIMITER ;
```

**🔸 Dashboard查询示例**
```sql
-- 获取今天的关键指标
SELECT 
  '今日执行总数' as metric,
  COUNT(*) as value,
  '次' as unit
FROM event_execution_history
WHERE DATE(execution_start) = CURDATE()

UNION ALL

SELECT 
  '今日成功率',
  ROUND(SUM(CASE WHEN execution_status = '成功' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 1),
  '%'
FROM event_execution_history
WHERE DATE(execution_start) = CURDATE()

UNION ALL

SELECT 
  '平均执行时间',
  ROUND(AVG(TIMESTAMPDIFF(SECOND, execution_start, execution_end)), 1),
  '秒'
FROM event_execution_history
WHERE DATE(execution_start) = CURDATE()
  AND execution_end IS NOT NULL;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 错误处理：像给定时器装故障检测，发现问题及时记录
🔸 日志记录：详细记录每次执行情况，方便事后分析
🔸 监控策略：定期检查事件健康状态，预防问题发生
🔸 重试机制：失败后自动重试，提高系统可靠性
🔸 告警通知：及时通知管理员，快速响应问题
🔸 故障排查：系统化的问题诊断方法
🔸 历史记录：完整的执行历史，支持数据分析
🔸 自动恢复：智能的故障自愈能力
```

### 11.2 关键理解要点


**🔹 为什么需要错误处理**
```
生产环境复杂性：
- 网络可能中断
- 数据库可能锁冲突  
- 磁盘空间可能不足
- 并发访问可能死锁

没有错误处理的后果：
- 事件悄无声息地失败
- 数据不一致
- 业务逻辑中断
- 问题难以定位
```

**🔹 监控的层次结构**
```
实时监控：秒级检查，发现立即问题
短期监控：分钟级检查，发现趋势问题  
长期监控：小时/天级检查，发现规律问题
```

**🔹 智能化运维思路**
```
被动处理 → 主动监控 → 预测预防 → 自动恢复
```

### 11.3 实际应用价值


**🎯 业务场景应用**
- **电商系统**：订单处理事件的异常监控和自动恢复
- **数据分析**：ETL任务的执行监控和错误处理
- **系统维护**：定期清理任务的执行状态跟踪
- **报表生成**：定时报表的生成监控和失败重试

**🔧 运维实践**
- **预防为主**：通过监控提前发现潜在问题
- **快速响应**：告警机制保证问题及时处理
- **自动化**：减少人工干预，提高系统可靠性
- **数据驱动**：基于历史数据优化事件性能

**💡 最佳实践要点**
```
1. 每个事件都要有错误处理
2. 重要事件必须有监控告警
3. 失败重试要有次数限制
4. 日志记录要详细但不冗余
5. 监控指标要与业务目标对齐
6. 自动恢复要有人工介入点
```

**核心记忆**：
- 事件错误处理是生产环境的必需品，不是可选项
- 好的监控系统能让问题"无处遁形"
- 自动化运维能大大减少人工干预和响应时间
- 详细的历史记录是系统优化的重要数据来源