---
title: 2、定时任务创建与语法
---
## 📚 目录

1. [事件调度器基本概念](#1-事件调度器基本概念)
2. [CREATE EVENT完整语法](#2-CREATE-EVENT完整语法)
3. [时间表达式详解](#3-时间表达式详解)
4. [事件类型与执行模式](#4-事件类型与执行模式)
5. [事件体SQL编写](#5-事件体SQL编写)
6. [事件调度精度控制](#6-事件调度精度控制)
7. [实际应用场景](#7-实际应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 事件调度器基本概念


### 1.1 什么是事件调度器

**事件调度器**就像是MySQL内置的一个"闹钟系统"，可以让数据库在指定的时间自动执行一些任务，比如清理过期数据、生成报表等。

```
简单理解：
普通SQL：你手动执行一次
事件调度器：设定好时间，MySQL自动执行

就像手机闹钟：
- 设定时间：CREATE EVENT
- 闹钟响起：自动执行SQL
- 重复提醒：EVERY设置周期
```

### 1.2 事件调度器的作用

**核心价值**：
- **自动化运维**：无需人工干预的定时任务
- **数据清理**：定期删除过期数据
- **报表生成**：按时生成统计报表
- **数据备份**：定时备份重要数据

### 1.3 启用事件调度器

事件调度器默认是关闭的，需要手动开启：

```sql
-- 查看事件调度器状态
SHOW VARIABLES LIKE 'event_scheduler';

-- 开启事件调度器
SET GLOBAL event_scheduler = ON;

-- 或者在配置文件中设置
-- [mysqld]
-- event_scheduler = ON
```

---

## 2. 📋 CREATE EVENT完整语法


### 2.1 基本语法结构

CREATE EVENT语法看起来复杂，但理解了结构就很简单：

```sql
CREATE EVENT [IF NOT EXISTS] event_name
ON SCHEDULE schedule
[ON COMPLETION [NOT] PRESERVE]
[ENABLE | DISABLE | DISABLE ON SLAVE]
[COMMENT 'comment']
DO
    sql_statement;
```

### 2.2 语法组件详解


**事件命名**：
```sql
-- 事件命名规范
CREATE EVENT cleanup_old_logs        -- 清理旧日志
CREATE EVENT generate_daily_report   -- 生成日报
CREATE EVENT backup_user_data       -- 备份用户数据

-- 支持IF NOT EXISTS
CREATE EVENT IF NOT EXISTS my_event
```

**调度设置**：
```sql
-- schedule有两种模式：
-- 1. AT：一次性执行
-- 2. EVERY：周期性执行
```

**完成后处理**：
```sql
-- ON COMPLETION PRESERVE：事件执行完保留
-- ON COMPLETION NOT PRESERVE：事件执行完删除（默认）
```

**启用状态**：
```sql
-- ENABLE：启用事件（默认）
-- DISABLE：禁用事件
-- DISABLE ON SLAVE：在从服务器上禁用
```

### 2.3 完整示例

```sql
-- 创建一个每天凌晨2点清理日志的事件
CREATE EVENT IF NOT EXISTS daily_log_cleanup
ON SCHEDULE EVERY 1 DAY
STARTS '2025-01-07 02:00:00'
ON COMPLETION PRESERVE
ENABLE
COMMENT '每日凌晨2点清理30天前的日志'
DO
BEGIN
    DELETE FROM error_logs WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);
    DELETE FROM access_logs WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);
END;
```

---

## 3. ⏰ 时间表达式详解


### 3.1 AT 指定时间执行

AT表达式用于一次性任务，就像设定一个具体的闹钟时间：

```sql
-- 在指定日期时间执行一次
CREATE EVENT one_time_task
ON SCHEDULE AT '2025-12-31 23:59:59'
DO
    INSERT INTO year_end_summary SELECT * FROM daily_stats;

-- 相对时间：从现在开始1小时后执行
CREATE EVENT delayed_task
ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
DO
    UPDATE users SET last_check = NOW();
```

**AT时间表达式类型**：
```sql
-- 绝对时间
AT '2025-01-07 15:30:00'
AT '2025-01-07'  -- 默认时间为 00:00:00

-- 相对时间
AT CURRENT_TIMESTAMP + INTERVAL 30 MINUTE
AT NOW() + INTERVAL 2 HOUR
AT CURDATE() + INTERVAL 1 DAY  -- 明天凌晨
```

### 3.2 EVERY 周期执行

EVERY表达式用于重复任务，就像设定重复提醒：

```sql
-- 基本周期表达式
EVERY 1 MINUTE    -- 每分钟
EVERY 1 HOUR      -- 每小时  
EVERY 1 DAY       -- 每天
EVERY 1 WEEK      -- 每周
EVERY 1 MONTH     -- 每月
EVERY 1 YEAR      -- 每年

-- 复杂周期表达式
EVERY 30 SECOND           -- 每30秒
EVERY 15 MINUTE          -- 每15分钟
EVERY 2 HOUR             -- 每2小时
EVERY 3 DAY              -- 每3天
EVERY '1 2:30:45' DAY_SECOND  -- 每1天2小时30分45秒
```

### 3.3 时间间隔单位表

| **间隔单位** | **含义** | **示例** | **说明** |
|------------|---------|---------|---------|
| `SECOND` | 秒 | `EVERY 30 SECOND` | 每30秒执行 |
| `MINUTE` | 分钟 | `EVERY 5 MINUTE` | 每5分钟执行 |
| `HOUR` | 小时 | `EVERY 2 HOUR` | 每2小时执行 |
| `DAY` | 天 | `EVERY 1 DAY` | 每天执行 |
| `WEEK` | 周 | `EVERY 1 WEEK` | 每周执行 |
| `MONTH` | 月 | `EVERY 1 MONTH` | 每月执行 |
| `YEAR` | 年 | `EVERY 1 YEAR` | 每年执行 |

### 3.4 复杂时间表达式

```sql
-- 使用STARTS和ENDS限定执行时间范围
CREATE EVENT weekly_report
ON SCHEDULE EVERY 1 WEEK
STARTS '2025-01-07 09:00:00'
ENDS '2025-12-31 23:59:59'
DO
    CALL generate_weekly_report();

-- 组合时间间隔
CREATE EVENT complex_schedule
ON SCHEDULE EVERY '1 12:30:00' DAY_SECOND  -- 每1天12小时30分钟
STARTS CURDATE() + INTERVAL 1 DAY
DO
    UPDATE cache_table SET refresh_time = NOW();
```

---

## 4. 🔄 事件类型与执行模式


### 4.1 一次性事件 vs 循环事件


**一次性事件**：
```sql
-- 场景：临时数据处理、一次性迁移
CREATE EVENT temp_data_migration
ON SCHEDULE AT '2025-01-07 20:00:00'
ON COMPLETION NOT PRESERVE  -- 执行完自动删除
DO
BEGIN
    INSERT INTO new_table SELECT * FROM old_table;
    DROP TABLE old_table;
END;
```

**循环事件**：
```sql
-- 场景：日常维护、定期清理
CREATE EVENT regular_maintenance  
ON SCHEDULE EVERY 1 DAY
STARTS '2025-01-07 03:00:00'
ON COMPLETION PRESERVE  -- 保留事件定义
DO
BEGIN
    OPTIMIZE TABLE user_logs;
    DELETE FROM temp_data WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 DAY);
END;
```

### 4.2 事件执行状态控制


```sql
-- 创建时设置状态
CREATE EVENT my_event
ON SCHEDULE EVERY 1 HOUR
ENABLE  -- 立即启用
DO SELECT NOW();

-- 动态修改事件状态
ALTER EVENT my_event ENABLE;   -- 启用
ALTER EVENT my_event DISABLE;  -- 禁用

-- 查看事件状态
SELECT EVENT_NAME, STATUS, EVENT_TYPE 
FROM INFORMATION_SCHEMA.EVENTS 
WHERE EVENT_SCHEMA = 'your_database';
```

### 4.3 事件执行时间精度


```
时间精度说明：
- 最小间隔：1秒
- 精度限制：秒级，不支持毫秒
- 执行偏差：可能有1-2秒的延迟

实际执行时间：
设定时间 + 系统处理时间 = 实际执行时间
```

---

## 5. 💻 事件体SQL编写


### 5.1 简单SQL语句

对于简单的SQL，直接写在DO后面：

```sql
-- 单条SQL语句
CREATE EVENT simple_cleanup
ON SCHEDULE EVERY 1 DAY
DO
    DELETE FROM sessions WHERE expires_at < NOW();

-- 单条INSERT语句
CREATE EVENT daily_stats
ON SCHEDULE EVERY 1 DAY
STARTS CURDATE() + INTERVAL 1 DAY
DO
    INSERT INTO daily_summary (date, user_count) 
    SELECT CURDATE(), COUNT(*) FROM users WHERE DATE(created_at) = CURDATE();
```

### 5.2 复合SQL语句块

对于复杂逻辑，使用BEGIN...END语句块：

```sql
CREATE EVENT comprehensive_maintenance
ON SCHEDULE EVERY 1 WEEK
STARTS '2025-01-07 02:00:00'
DO
BEGIN
    -- 声明变量
    DECLARE old_count INT DEFAULT 0;
    
    -- 查询要删除的记录数
    SELECT COUNT(*) INTO old_count 
    FROM user_logs 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);
    
    -- 删除过期日志
    DELETE FROM user_logs 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);
    
    -- 记录清理日志
    INSERT INTO maintenance_log (operation, affected_rows, executed_at)
    VALUES ('log_cleanup', old_count, NOW());
    
    -- 优化表
    OPTIMIZE TABLE user_logs;
END;
```

### 5.3 调用存储过程

最佳实践是将复杂逻辑写成存储过程，事件中调用：

```sql
-- 先创建存储过程
DELIMITER //
CREATE PROCEDURE sp_daily_maintenance()
BEGIN
    -- 复杂的业务逻辑
    CALL clean_expired_data();
    CALL update_statistics();
    CALL generate_reports();
END //
DELIMITER ;

-- 事件中调用存储过程
CREATE EVENT daily_maintenance_event
ON SCHEDULE EVERY 1 DAY
STARTS CURDATE() + INTERVAL 1 DAY + INTERVAL 2 HOUR
DO
    CALL sp_daily_maintenance();
```

---

## 6. 🎛️ 事件调度精度控制


### 6.1 调度精度限制


```
MySQL事件调度器精度：
✅ 最小间隔：1秒
❌ 不支持：毫秒级精度
⚠️ 注意：实际执行可能有1-2秒延迟

时间精度对比：
操作系统cron：分钟级精度
MySQL事件：秒级精度
应用层定时器：毫秒级精度
```

### 6.2 提高调度准确性

```sql
-- 避免在高峰期执行
CREATE EVENT off_peak_maintenance
ON SCHEDULE EVERY 1 DAY
STARTS '2025-01-07 02:00:00'  -- 凌晨2点，业务低峰期
DO
    CALL heavy_maintenance_procedure();

-- 错开执行时间，避免资源冲突
CREATE EVENT report_generation
ON SCHEDULE EVERY 1 DAY  
STARTS '2025-01-07 03:30:00'  -- 与维护任务错开
DO
    CALL generate_daily_reports();
```

### 6.3 调度表达式验证

```sql
-- 验证事件调度设置
SELECT 
    EVENT_NAME,
    EVENT_TYPE,
    EXECUTE_AT,
    INTERVAL_VALUE,
    INTERVAL_FIELD,
    STARTS,
    ENDS,
    STATUS
FROM INFORMATION_SCHEMA.EVENTS
WHERE EVENT_SCHEMA = DATABASE();

-- 查看下次执行时间
SELECT 
    EVENT_NAME,
    NEXT_EXECUTION_TIME,
    TIME_TO_SEC(TIMEDIFF(NEXT_EXECUTION_TIME, NOW())) AS seconds_until_next
FROM INFORMATION_SCHEMA.EVENTS
WHERE STATUS = 'ENABLED';
```

---

## 7. 🚀 实际应用场景


### 7.1 数据清理任务

```sql
-- 清理过期会话
CREATE EVENT cleanup_expired_sessions
ON SCHEDULE EVERY 1 HOUR
DO
    DELETE FROM user_sessions 
    WHERE expires_at < NOW() OR last_activity < DATE_SUB(NOW(), INTERVAL 24 HOUR);

-- 清理临时文件记录
CREATE EVENT cleanup_temp_files
ON SCHEDULE EVERY 6 HOUR
DO
BEGIN
    DELETE FROM temp_uploads WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 DAY);
    DELETE FROM temp_downloads WHERE created_at < DATE_SUB(NOW(), INTERVAL 6 HOUR);
END;
```

### 7.2 报表生成任务

```sql
-- 生成每日销售报表
CREATE EVENT daily_sales_report
ON SCHEDULE EVERY 1 DAY
STARTS CURDATE() + INTERVAL 1 DAY + INTERVAL 1 HOUR  -- 每天凌晨1点
DO
    INSERT INTO daily_sales_summary (report_date, total_sales, order_count)
    SELECT 
        CURDATE() - INTERVAL 1 DAY,
        SUM(amount),
        COUNT(*)
    FROM orders 
    WHERE DATE(created_at) = CURDATE() - INTERVAL 1 DAY;

-- 生成月度统计
CREATE EVENT monthly_statistics
ON SCHEDULE EVERY 1 MONTH
STARTS '2025-02-01 02:00:00'
DO
    CALL generate_monthly_reports(YEAR(DATE_SUB(NOW(), INTERVAL 1 MONTH)), 
                                 MONTH(DATE_SUB(NOW(), INTERVAL 1 MONTH)));
```

### 7.3 系统维护任务

```sql
-- 数据库表优化
CREATE EVENT weekly_table_optimization
ON SCHEDULE EVERY 1 WEEK
STARTS '2025-01-12 03:00:00'  -- 每周日凌晨3点
DO
BEGIN
    OPTIMIZE TABLE user_logs;
    OPTIMIZE TABLE order_history;
    OPTIMIZE TABLE product_views;
    
    INSERT INTO maintenance_log (operation, executed_at)
    VALUES ('table_optimization', NOW());
END;

-- 更新统计信息
CREATE EVENT update_table_stats
ON SCHEDULE EVERY 1 DAY
STARTS CURDATE() + INTERVAL 1 DAY + INTERVAL 4 HOUR
DO
BEGIN
    ANALYZE TABLE users;
    ANALYZE TABLE orders;
    ANALYZE TABLE products;
END;
```

### 7.4 应用场景选择指南


| **场景类型** | **推荐间隔** | **执行时间** | **注意事项** |
|------------|------------|------------|-------------|
| **数据清理** | 每小时/每天 | 业务低峰期 | 注意清理量，避免锁表 |
| **报表生成** | 每天/每周/每月 | 凌晨时段 | 确保数据完整性 |
| **系统维护** | 每周 | 周末凌晨 | 预留足够执行时间 |
| **数据同步** | 每分钟/每小时 | 任意时间 | 考虑网络延迟 |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念

```
🔸 事件调度器：MySQL内置的定时任务系统
🔸 CREATE EVENT：创建定时任务的SQL语句
🔸 时间表达式：AT（一次性）和EVERY（周期性）
🔸 事件体：DO后面要执行的SQL语句
🔸 调度精度：最小1秒间隔，实际可能有延迟
```

### 8.2 关键语法要点

```sql
-- 基本结构
CREATE EVENT event_name
ON SCHEDULE {AT time | EVERY interval}
[STARTS time] [ENDS time]
[ON COMPLETION [NOT] PRESERVE]
DO sql_statement;

-- 时间表达式
AT '2025-01-07 15:30:00'              -- 指定时间执行
EVERY 1 DAY STARTS '2025-01-07 02:00:00'  -- 每天2点执行
EVERY 30 MINUTE                       -- 每30分钟执行
```

### 8.3 最佳实践原则

```
设计原则：
✅ 在业务低峰期执行重型任务
✅ 复杂逻辑写成存储过程，事件中调用
✅ 合理设置ON COMPLETION PRESERVE
✅ 添加详细的COMMENT说明
✅ 定期检查事件执行状态

避免问题：
❌ 避免高频率执行影响性能
❌ 避免长时间运行阻塞其他操作
❌ 避免在事件中执行DDL操作
❌ 避免事件之间的时间冲突
```

### 8.4 实际应用价值

- **自动化运维**：减少人工干预，提高效率
- **数据清理**：定期清理过期数据，节省存储空间
- **报表生成**：自动生成各类统计报表
- **系统维护**：定期优化表、更新统计信息
- **业务流程**：自动处理定时业务逻辑

**核心记忆**：
- 事件调度器是MySQL的定时任务系统
- AT用于一次性任务，EVERY用于重复任务  
- 复杂逻辑建议使用存储过程
- 合理安排执行时间避免性能影响