---
title: 4、存储过程流程控制
---
## 📚 目录

1. [流程控制基础概念](#1-流程控制基础概念)
2. [条件语句IF-THEN-ELSE](#2-条件语句if-then-else)
3. [多分支CASE语句](#3-多分支case语句)
4. [WHILE循环控制](#4-while循环控制)
5. [REPEAT-UNTIL循环](#5-repeat-until循环)
6. [LOOP无条件循环](#6-loop无条件循环)
7. [循环控制LEAVE和ITERATE](#7-循环控制leave和iterate)
8. [复合语句与标签](#8-复合语句与标签)
9. [游标CURSOR操作](#9-游标cursor操作)
10. [核心要点总结](#10-核心要点总结)

---

### 1. 🔄 流程控制基础概念


##### 1.1 什么是流程控制

**简单理解**：流程控制就是让存储过程能够像写程序一样，根据不同情况做出不同的处理。

```
生活场景类比：
如果天气好 → 去公园
否则 → 在家看书

技术实现：
IF weather = 'sunny' THEN
  go_to_park();
ELSE 
  read_at_home();
END IF;
```

##### 1.2 MySQL流程控制语句分类


| 控制类型 | **语句** | **用途** | **使用场景** |
|---------|---------|---------|-------------|
| 🎯 **条件控制** | `IF-THEN-ELSE` | 根据条件执行不同逻辑 | 简单条件判断 |
| 🎛️ **多分支** | `CASE-WHEN` | 多个条件的选择执行 | 复杂条件判断 |
| 🔁 **条件循环** | `WHILE-DO` | 满足条件时重复执行 | 处理数据集合 |
| 🔄 **后判断循环** | `REPEAT-UNTIL` | 先执行后判断条件 | 至少执行一次的循环 |
| ♾️ **无条件循环** | `LOOP` | 手动控制退出的循环 | 复杂循环逻辑 |

##### 1.3 复合语句结构

所有流程控制都需要在复合语句块中使用：

```sql
DELIMITER $$
CREATE PROCEDURE demo_procedure()
BEGIN
  -- 声明变量区域
  DECLARE var_name INT DEFAULT 0;
  
  -- 流程控制语句区域
  IF condition THEN
    -- 执行语句
  END IF;
  
END$$
DELIMITER ;
```

---

### 2. 🎯 条件语句IF-THEN-ELSE


##### 2.1 IF语句基本语法

条件语句让存储过程能够"思考"，根据不同情况执行不同的代码。

```sql
-- 基本语法结构
IF condition THEN
  statements;
[ELSEIF condition THEN
  statements;]
[ELSE
  statements;]
END IF;
```

##### 2.2 简单条件判断示例


```sql
DELIMITER $$
CREATE PROCEDURE check_score(IN student_score INT)
BEGIN
  -- 根据分数给出等级评价
  IF student_score >= 90 THEN
    SELECT '优秀' AS grade;
  ELSEIF student_score >= 80 THEN
    SELECT '良好' AS grade;
  ELSEIF student_score >= 60 THEN
    SELECT '及格' AS grade;
  ELSE
    SELECT '不及格' AS grade;
  END IF;
END$$
DELIMITER ;

-- 调用测试
CALL check_score(85);  -- 输出：良好
```

##### 2.3 实际业务应用场景


**🛒 电商订单处理示例**：
```sql
DELIMITER $$
CREATE PROCEDURE process_order(
  IN order_amount DECIMAL(10,2),
  IN user_level VARCHAR(10)
)
BEGIN
  DECLARE discount_rate DECIMAL(3,2) DEFAULT 0;
  DECLARE final_amount DECIMAL(10,2);
  
  -- 根据用户等级和订单金额计算折扣
  IF user_level = 'VIP' THEN
    IF order_amount >= 1000 THEN
      SET discount_rate = 0.2;  -- VIP用户大额订单8折
    ELSE
      SET discount_rate = 0.1;  -- VIP用户普通折扣9折
    END IF;
  ELSEIF user_level = 'GOLD' THEN
    SET discount_rate = 0.05;   -- 金牌用户95折
  ELSE
    SET discount_rate = 0;      -- 普通用户无折扣
  END IF;
  
  SET final_amount = order_amount * (1 - discount_rate);
  SELECT final_amount AS '最终金额', discount_rate AS '折扣率';
END$$
DELIMITER ;
```

---

### 3. 🎛️ 多分支CASE语句


##### 3.1 CASE语句基础语法

当需要根据一个变量的不同值执行不同逻辑时，CASE比多个IF更清晰。

```sql
-- 方式一：简单CASE语句
CASE case_value
  WHEN when_value1 THEN statements;
  WHEN when_value2 THEN statements;
  [ELSE statements;]
END CASE;

-- 方式二：搜索CASE语句  
CASE
  WHEN condition1 THEN statements;
  WHEN condition2 THEN statements;
  [ELSE statements;]
END CASE;
```

##### 3.2 员工工资调整示例


```sql
DELIMITER $$
CREATE PROCEDURE adjust_salary(
  IN emp_id INT,
  IN department VARCHAR(20)
)
BEGIN
  DECLARE current_salary DECIMAL(10,2);
  DECLARE new_salary DECIMAL(10,2);
  
  -- 获取当前工资
  SELECT salary INTO current_salary 
  FROM employees WHERE id = emp_id;
  
  -- 根据部门调整工资
  CASE department
    WHEN 'IT' THEN 
      SET new_salary = current_salary * 1.15;  -- IT部门涨15%
    WHEN 'Sales' THEN 
      SET new_salary = current_salary * 1.10;  -- 销售部门涨10%
    WHEN 'HR' THEN 
      SET new_salary = current_salary * 1.08;  -- HR部门涨8%
    ELSE 
      SET new_salary = current_salary * 1.05;  -- 其他部门涨5%
  END CASE;
  
  -- 更新工资
  UPDATE employees 
  SET salary = new_salary 
  WHERE id = emp_id;
  
  SELECT CONCAT('工资从 ', current_salary, ' 调整为 ', new_salary) AS result;
END$$
DELIMITER ;
```

##### 3.3 搜索CASE的复杂条件


```sql
DELIMITER $$
CREATE PROCEDURE categorize_customer(IN customer_id INT)
BEGIN
  DECLARE total_orders INT;
  DECLARE total_amount DECIMAL(10,2);
  DECLARE customer_type VARCHAR(20);
  
  -- 统计客户数据
  SELECT COUNT(*), IFNULL(SUM(order_amount), 0)
  INTO total_orders, total_amount
  FROM orders WHERE cust_id = customer_id;
  
  -- 复杂条件分类
  CASE 
    WHEN total_orders >= 50 AND total_amount >= 10000 THEN
      SET customer_type = '钻石客户';
    WHEN total_orders >= 20 OR total_amount >= 5000 THEN
      SET customer_type = '黄金客户';
    WHEN total_orders >= 5 THEN
      SET customer_type = '银牌客户';
    ELSE
      SET customer_type = '普通客户';
  END CASE;
  
  SELECT customer_type AS '客户类型';
END$$
DELIMITER ;
```

---

### 4. 🔁 WHILE循环控制


##### 4.1 WHILE循环基本概念

WHILE循环就像"只要条件满足就一直做某件事"，常用于处理批量数据。

```sql
-- 基本语法
[label:] WHILE condition DO
  statements;
END WHILE [label];
```

##### 4.2 简单计数示例


```sql
DELIMITER $$
CREATE PROCEDURE calculate_sum(IN max_num INT)
BEGIN
  DECLARE counter INT DEFAULT 1;
  DECLARE total_sum INT DEFAULT 0;
  
  -- 计算1到max_num的和
  WHILE counter <= max_num DO
    SET total_sum = total_sum + counter;
    SET counter = counter + 1;
  END WHILE;
  
  SELECT total_sum AS '累计和';
END$$
DELIMITER ;

-- 调用测试
CALL calculate_sum(100);  -- 计算1+2+...+100
```

##### 4.3 批量数据处理示例


```sql
DELIMITER $$
CREATE PROCEDURE batch_update_status()
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE current_id INT;
  DECLARE update_count INT DEFAULT 0;
  
  -- 声明游标处理待更新的订单
  DECLARE order_cursor CURSOR FOR 
    SELECT order_id FROM orders 
    WHERE status = 'pending' AND create_time < DATE_SUB(NOW(), INTERVAL 7 DAY);
  
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  
  OPEN order_cursor;
  
  -- 使用WHILE循环处理每个订单
  update_loop: WHILE done = 0 DO
    FETCH order_cursor INTO current_id;
    
    IF done = 1 THEN
      LEAVE update_loop;
    END IF;
    
    -- 更新订单状态
    UPDATE orders 
    SET status = 'expired' 
    WHERE order_id = current_id;
    
    SET update_count = update_count + 1;
  END WHILE;
  
  CLOSE order_cursor;
  SELECT CONCAT('更新了 ', update_count, ' 个订单') AS result;
END$$
DELIMITER ;
```

---

### 5. 🔄 REPEAT-UNTIL循环


##### 5.1 REPEAT循环特点

REPEAT循环的特点是"先做事，再判断条件"，保证至少执行一次。

```sql
-- 基本语法
[label:] REPEAT
  statements;
UNTIL condition
END REPEAT [label];
```

##### 5.2 数据初始化示例


```sql
DELIMITER $$
CREATE PROCEDURE init_test_data()
BEGIN
  DECLARE counter INT DEFAULT 1;
  
  -- 初始化测试用户数据
  REPEAT
    INSERT INTO test_users(username, email) 
    VALUES(
      CONCAT('user', counter),
      CONCAT('user', counter, '@test.com')
    );
    SET counter = counter + 1;
  UNTIL counter > 10
  END REPEAT;
  
  SELECT '成功创建10个测试用户' AS result;
END$$
DELIMITER ;
```

##### 5.3 数据清理任务


```sql
DELIMITER $$
CREATE PROCEDURE cleanup_old_logs()
BEGIN
  DECLARE deleted_count INT DEFAULT 0;
  DECLARE batch_count INT;
  
  -- 分批删除旧日志，避免长时间锁表
  REPEAT
    DELETE FROM system_logs 
    WHERE create_time < DATE_SUB(NOW(), INTERVAL 30 DAY) 
    LIMIT 1000;
    
    SET batch_count = ROW_COUNT();
    SET deleted_count = deleted_count + batch_count;
    
    -- 每批次之间稍作停顿
    DO SLEEP(0.1);
    
  UNTIL batch_count < 1000
  END REPEAT;
  
  SELECT CONCAT('共删除 ', deleted_count, ' 条旧日志') AS result;
END$$
DELIMITER ;
```

---

### 6. ♾️ LOOP无条件循环


##### 6.1 LOOP循环基础

LOOP是真正的"无限循环"，必须手动用LEAVE语句退出。

```sql
-- 基本语法
[label:] LOOP
  statements;
  -- 必须有退出条件
  IF exit_condition THEN
    LEAVE label;
  END IF;
END LOOP [label];
```

##### 6.2 灵活控制的数据处理


```sql
DELIMITER $$
CREATE PROCEDURE flexible_data_process()
BEGIN
  DECLARE counter INT DEFAULT 1;
  DECLARE max_iterations INT DEFAULT 1000;
  DECLARE error_count INT DEFAULT 0;
  
  process_loop: LOOP
    -- 处理数据的逻辑
    BEGIN
      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION 
        SET error_count = error_count + 1;
      
      -- 模拟数据处理
      INSERT INTO processed_data(data_value) 
      VALUES(RAND() * 100);
    END;
    
    SET counter = counter + 1;
    
    -- 多个退出条件
    IF counter > max_iterations THEN
      SELECT '达到最大迭代次数' AS exit_reason;
      LEAVE process_loop;
    END IF;
    
    IF error_count > 50 THEN
      SELECT '错误次数过多' AS exit_reason;
      LEAVE process_loop;
    END IF;
    
    -- 每100次检查一下系统负载
    IF counter % 100 = 0 THEN
      DO SLEEP(0.01);  -- 短暂休息
    END IF;
    
  END LOOP process_loop;
  
  SELECT counter AS '处理次数', error_count AS '错误次数';
END$$
DELIMITER ;
```

---

### 7. 🚦 循环控制LEAVE和ITERATE


##### 7.1 LEAVE和ITERATE的作用


```
生活场景对比：
LEAVE = 直接离开循环（类似break）
ITERATE = 跳过本次，继续下次（类似continue）

使用场景：
- LEAVE：遇到错误或完成任务时退出
- ITERATE：跳过无效数据，继续处理
```

##### 7.2 LEAVE语句示例


```sql
DELIMITER $$
CREATE PROCEDURE find_target_value(IN target INT)
BEGIN
  DECLARE current_num INT DEFAULT 1;
  DECLARE found BOOLEAN DEFAULT FALSE;
  
  search_loop: WHILE current_num <= 1000 DO
    IF current_num * current_num = target THEN
      SELECT CONCAT('找到平方根：', current_num) AS result;
      SET found = TRUE;
      LEAVE search_loop;  -- 找到目标，退出循环
    END IF;
    
    SET current_num = current_num + 1;
  END WHILE;
  
  IF NOT found THEN
    SELECT '在1000以内未找到完全平方根' AS result;
  END IF;
END$$
DELIMITER ;
```

##### 7.3 ITERATE语句示例


```sql
DELIMITER $$
CREATE PROCEDURE process_valid_numbers()
BEGIN
  DECLARE num INT DEFAULT 1;
  DECLARE valid_sum INT DEFAULT 0;
  DECLARE valid_count INT DEFAULT 0;
  
  number_loop: WHILE num <= 50 DO
    -- 跳过能被3整除的数字
    IF num % 3 = 0 THEN
      SET num = num + 1;
      ITERATE number_loop;  -- 跳过本次循环
    END IF;
    
    -- 跳过个位数是7的数字
    IF num % 10 = 7 THEN
      SET num = num + 1;
      ITERATE number_loop;
    END IF;
    
    -- 处理有效数字
    SET valid_sum = valid_sum + num;
    SET valid_count = valid_count + 1;
    SET num = num + 1;
  END WHILE;
  
  SELECT valid_sum AS '有效数字和', valid_count AS '有效数字个数';
END$$
DELIMITER ;
```

---

### 8. 🏷️ 复合语句与标签


##### 8.1 标签的作用和命名

标签让我们能够准确控制要退出哪个循环，特别是嵌套循环时。

```sql
-- 标签命名规范
outer_loop: WHILE condition1 DO
  inner_loop: WHILE condition2 DO
    IF some_condition THEN
      LEAVE outer_loop;  -- 退出外层循环
    END IF;
    IF other_condition THEN
      LEAVE inner_loop;  -- 退出内层循环
    END IF;
  END WHILE inner_loop;
END WHILE outer_loop;
```

##### 8.2 嵌套循环实际应用


```sql
DELIMITER $$
CREATE PROCEDURE generate_multiplication_table()
BEGIN
  DECLARE i INT DEFAULT 1;
  DECLARE j INT DEFAULT 1;
  DECLARE result_text TEXT DEFAULT '';
  
  outer_loop: WHILE i <= 9 DO
    SET j = 1;
    
    inner_loop: WHILE j <= i DO
      SET result_text = CONCAT(
        result_text, 
        j, '×', i, '=', i*j, '  '
      );
      SET j = j + 1;
    END WHILE inner_loop;
    
    -- 换行
    SET result_text = CONCAT(result_text, '\n');
    SET i = i + 1;
  END WHILE outer_loop;
  
  SELECT result_text AS '九九乘法表';
END$$
DELIMITER ;
```

---

### 9. 👆 游标CURSOR操作


##### 9.1 游标基本概念

游标就像数据库查询结果的"遥控器"，让我们能够逐行处理查询结果。

```
生活场景类比：
游标 = 看书时的书签
- 指向当前读到的位置
- 可以向前翻页（FETCH）
- 读完了会知道（NOT FOUND）
```

##### 9.2 游标基本操作流程


```sql
-- 游标操作的标准流程
DELIMITER $$
CREATE PROCEDURE cursor_demo()
BEGIN
  -- 1. 声明变量
  DECLARE done INT DEFAULT 0;
  DECLARE emp_name VARCHAR(50);
  DECLARE emp_salary DECIMAL(10,2);
  
  -- 2. 声明游标
  DECLARE emp_cursor CURSOR FOR 
    SELECT name, salary FROM employees;
  
  -- 3. 声明异常处理
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  
  -- 4. 打开游标
  OPEN emp_cursor;
  
  -- 5. 循环读取数据
  read_loop: LOOP
    FETCH emp_cursor INTO emp_name, emp_salary;
    
    IF done = 1 THEN
      LEAVE read_loop;
    END IF;
    
    -- 处理每一行数据
    SELECT emp_name, emp_salary;
  END LOOP;
  
  -- 6. 关闭游标
  CLOSE emp_cursor;
END$$
DELIMITER ;
```

##### 9.3 游标实际应用示例


```sql
DELIMITER $$
CREATE PROCEDURE calculate_bonus()
BEGIN
  DECLARE finished INT DEFAULT 0;
  DECLARE emp_id INT;
  DECLARE emp_salary DECIMAL(10,2);
  DECLARE emp_performance DECIMAL(3,2);
  DECLARE bonus_amount DECIMAL(10,2);
  DECLARE total_bonus DECIMAL(10,2) DEFAULT 0;
  
  -- 查询需要计算奖金的员工
  DECLARE bonus_cursor CURSOR FOR
    SELECT employee_id, salary, performance_score
    FROM employees 
    WHERE department = 'Sales' AND performance_score > 0;
  
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET finished = 1;
  
  OPEN bonus_cursor;
  
  bonus_loop: LOOP
    FETCH bonus_cursor INTO emp_id, emp_salary, emp_performance;
    
    IF finished = 1 THEN
      LEAVE bonus_loop;
    END IF;
    
    -- 根据绩效计算奖金
    CASE 
      WHEN emp_performance >= 0.9 THEN
        SET bonus_amount = emp_salary * 0.3;
      WHEN emp_performance >= 0.8 THEN
        SET bonus_amount = emp_salary * 0.2;
      WHEN emp_performance >= 0.7 THEN
        SET bonus_amount = emp_salary * 0.1;
      ELSE
        SET bonus_amount = 0;
    END CASE;
    
    -- 记录奖金信息
    INSERT INTO bonus_records(employee_id, bonus_amount, calc_date)
    VALUES(emp_id, bonus_amount, NOW());
    
    SET total_bonus = total_bonus + bonus_amount;
  END LOOP;
  
  CLOSE bonus_cursor;
  
  SELECT CONCAT('总奖金: ', total_bonus, ' 元') AS result;
END$$
DELIMITER ;
```

---

### 10. 📋 核心要点总结


##### 10.1 必须掌握的基本概念


```
🔸 流程控制：让存储过程具备"思考"和"重复"的能力
🔸 条件语句：根据不同情况执行不同的代码逻辑
🔸 循环语句：重复执行某段代码，处理批量数据
🔸 游标操作：逐行处理查询结果的标准方法
🔸 标签控制：精确控制复杂嵌套结构的执行流程
```

##### 10.2 语句选择指南


| 使用场景 | **推荐语句** | **原因** |
|---------|-------------|---------|
| 🎯 **简单条件判断** | `IF-THEN-ELSE` | 语法简洁，易于理解 |
| 🎛️ **多个固定值选择** | `CASE-WHEN` | 代码清晰，性能更好 |
| 🔁 **已知循环次数** | `WHILE` | 条件明确，控制简单 |
| 🔄 **至少执行一次** | `REPEAT-UNTIL` | 保证执行，后判断条件 |
| ♾️ **复杂循环控制** | `LOOP` | 灵活性最高，可多条件退出 |
| 👆 **逐行处理数据** | `CURSOR` | 标准方法，内存友好 |

##### 10.3 最佳实践要点


**🔹 代码组织**：
```sql
-- 推荐的存储过程结构
DELIMITER $$
CREATE PROCEDURE procedure_name()
BEGIN
  -- 1. 变量声明区
  DECLARE variables;
  
  -- 2. 游标声明区  
  DECLARE cursors;
  
  -- 3. 异常处理区
  DECLARE handlers;
  
  -- 4. 主要逻辑区
  Main logic here;
  
END$$
DELIMITER ;
```

**🔹 性能优化**：
- 避免在循环中执行复杂查询
- 合理使用批量操作减少循环次数
- 游标处理大数据时考虑分页

**🔹 错误处理**：
- 总是为游标设置NOT FOUND处理器
- 复杂循环要设置最大迭代次数防止死循环
- 关键操作要有异常处理机制

##### 10.4 学习进度检查


**🟢 基础掌握**：
- [ ] 能写简单的IF条件判断
- [ ] 理解CASE语句的两种用法
- [ ] 掌握WHILE循环的基本使用

**🟡 进阶理解**：
- [ ] 熟练使用LEAVE和ITERATE控制循环
- [ ] 能够处理嵌套循环和标签
- [ ] 掌握游标的完整操作流程

**🔴 专家级别**：
- [ ] 能设计复杂的业务流程控制
- [ ] 优化循环性能，处理大数据量
- [ ] 结合异常处理构建健壮的存储过程

**核心记忆口诀**：
> 条件分支IF和CASE，循环控制三兄弟
> WHILE判断再执行，REPEAT执行再判断  
> LOOP最灵活需手控，游标逐行好帮手
> 标签嵌套不迷路，异常处理保安全