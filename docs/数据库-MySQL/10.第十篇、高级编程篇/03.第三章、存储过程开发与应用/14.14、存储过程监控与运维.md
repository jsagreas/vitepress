---
title: 14、存储过程监控与运维
---
## 📚 目录

1. [存储过程监控基础](#1-存储过程监控基础)
2. [Performance Schema监控详解](#2-performance-schema监控详解)
3. [执行统计分析](#3-执行统计分析)
4. [资源使用监控](#4-资源使用监控)
5. [告警机制设置](#5-告警机制设置)
6. [问题诊断方法](#6-问题诊断方法)
7. [运维自动化实践](#7-运维自动化实践)
8. [执行计划变更检测](#8-执行计划变更检测)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 存储过程监控基础


### 1.1 为什么要监控存储过程


**💡 核心作用**
存储过程监控就像给数据库装了一个"体检仪"，随时了解存储过程的健康状况。

```
现实类比：
汽车仪表盘 → 监控引擎状态、油耗、温度
存储过程监控 → 监控执行时间、资源消耗、错误率

目的：及时发现问题，避免系统故障
```

**🎯 监控核心指标**

| 指标类别 | **具体指标** | **含义说明** | **正常范围** |
|---------|-------------|-------------|-------------|
| **性能指标** | `执行时间` | 存储过程从开始到结束的耗时 | < 1秒（一般业务）|
| **性能指标** | `调用频率` | 单位时间内被调用的次数 | 根据业务需求 |
| **资源指标** | `CPU使用率` | 存储过程占用的CPU百分比 | < 80% |
| **资源指标** | `内存消耗` | 执行过程中使用的内存量 | < 可用内存50% |
| **错误指标** | `失败率` | 执行失败的百分比 | < 1% |
| **锁定指标** | `等待时间` | 因锁等待而延迟的时间 | < 100ms |

### 1.2 监控架构概览


```
MySQL存储过程监控体系架构：

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用层监控     │    │   数据库监控     │    │   系统层监控     │
│                │    │                │    │                │
│ • 调用日志      │    │ • Performance   │    │ • CPU使用率     │
│ • 响应时间      │◄──►│   Schema       │◄──►│ • 内存使用率     │
│ • 错误统计      │    │ • 慢查询日志    │    │ • 磁盘I/O       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
          │                       │                       │
          └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   告警中心       │
                    │                │
                    │ • 阈值监控      │
                    │ • 邮件通知      │
                    │ • 短信告警      │
                    └─────────────────┘
```

---

## 2. 📊 Performance Schema监控详解


### 2.1 Performance Schema简介


**🔸 什么是Performance Schema**
Performance Schema就像MySQL的"黑匣子"，记录了数据库内部发生的所有重要事件。

> 💡 **通俗理解**  
> 想象Performance Schema是一个超级记录员，把MySQL里每个操作的详细情况都记录下来，包括谁做了什么、用了多长时间、消耗了多少资源。

**🔧 启用Performance Schema**
```sql
-- 检查Performance Schema是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 如果未启用，需要在配置文件中添加
-- [mysqld]
-- performance_schema = ON
```

### 2.2 存储过程相关监控表


**📋 核心监控表说明**

```sql
-- 1. events_statements_summary_by_digest：SQL语句统计汇总
-- 作用：统计每个SQL语句的执行次数、总耗时、平均耗时等

SELECT 
    DIGEST_TEXT,                    -- SQL语句摘要
    COUNT_STAR,                     -- 执行次数
    AVG_TIMER_WAIT/1000000000 AS avg_time_ms,  -- 平均执行时间(毫秒)
    SUM_TIMER_WAIT/1000000000 AS total_time_ms -- 总执行时间(毫秒)
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%CALL%'     -- 过滤存储过程调用
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

**🔍 实际查询示例**
```sql
-- 监控存储过程执行情况
SELECT 
    SUBSTRING(DIGEST_TEXT, 1, 50) AS procedure_call,
    COUNT_STAR AS call_count,
    ROUND(AVG_TIMER_WAIT/1000000000, 2) AS avg_seconds,
    ROUND(MAX_TIMER_WAIT/1000000000, 2) AS max_seconds,
    ROUND(SUM_TIMER_WAIT/1000000000, 2) AS total_seconds
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%CALL%'
    AND COUNT_STAR > 0
ORDER BY total_seconds DESC;
```

### 2.3 实时监控设置


**⚡ 实时事件监控**
```sql
-- 启用存储过程事件收集
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME = 'events_statements_current';

-- 查看当前正在执行的存储过程
SELECT 
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER,
    t.PROCESSLIST_HOST,
    s.SQL_TEXT,
    s.TIMER_WAIT/1000000000 AS seconds_running
FROM performance_schema.threads t
JOIN performance_schema.events_statements_current s 
    ON t.THREAD_ID = s.THREAD_ID
WHERE s.SQL_TEXT LIKE '%CALL%'
    AND s.TIMER_WAIT > 1000000000;  -- 运行超过1秒的
```

---

## 3. 📈 执行统计分析


### 3.1 执行频率统计


**📊 调用频率分析**
调用频率分析帮我们了解哪些存储过程是"热点"，需要重点关注。

```sql
-- 创建存储过程调用统计视图
CREATE VIEW sp_call_stats AS
SELECT 
    REGEXP_SUBSTR(DIGEST_TEXT, 'CALL\\s+([^\\(]+)', 1, 1, '', 1) AS sp_name,
    COUNT_STAR AS total_calls,
    ROUND(COUNT_STAR / (
        SELECT SUM(COUNT_STAR) 
        FROM performance_schema.events_statements_summary_by_digest 
        WHERE DIGEST_TEXT LIKE '%CALL%'
    ) * 100, 2) AS call_percentage,
    ROUND(AVG_TIMER_WAIT/1000000000, 3) AS avg_time_seconds
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%CALL%'
    AND COUNT_STAR > 0
ORDER BY total_calls DESC;

-- 查看调用统计
SELECT * FROM sp_call_stats LIMIT 10;
```

### 3.2 性能趋势分析


**📉 时间段性能对比**
```sql
-- 按小时统计存储过程性能（需要开启事件历史记录）
SELECT 
    HOUR(FROM_UNIXTIME(TIMER_START/1000000000000)) AS hour_of_day,
    COUNT(*) AS call_count,
    ROUND(AVG(TIMER_WAIT)/1000000000, 3) AS avg_seconds,
    ROUND(MAX(TIMER_WAIT)/1000000000, 3) AS max_seconds
FROM performance_schema.events_statements_history_long
WHERE SQL_TEXT LIKE '%CALL%'
    AND TIMER_START > UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 24 HOUR)) * 1000000000000
GROUP BY HOUR(FROM_UNIXTIME(TIMER_START/1000000000000))
ORDER BY hour_of_day;
```

---

## 4. 💾 资源使用监控


### 4.1 内存使用监控


**🧠 内存消耗分析**
监控存储过程的内存使用，防止内存泄漏和过度消耗。

```sql
-- 查看连接的内存使用情况
SELECT 
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER,
    t.PROCESSLIST_DB,
    mu.EVENT_NAME,
    ROUND(mu.CURRENT_NUMBER_OF_BYTES_USED/1024/1024, 2) AS memory_mb
FROM performance_schema.threads t
JOIN performance_schema.memory_summary_by_thread_by_event_name mu 
    ON t.THREAD_ID = mu.THREAD_ID
WHERE mu.CURRENT_NUMBER_OF_BYTES_USED > 0
    AND mu.EVENT_NAME LIKE '%memory%'
ORDER BY mu.CURRENT_NUMBER_OF_BYTES_USED DESC;
```

### 4.2 临时表使用监控


**📋 临时表监控**
存储过程中大量使用临时表会影响性能，需要重点监控。

```sql
-- 监控临时表的使用情况
SELECT 
    DIGEST_TEXT,
    COUNT_STAR AS execution_count,
    SUM_CREATED_TMP_DISK_TABLES AS disk_tmp_tables,
    SUM_CREATED_TMP_TABLES AS total_tmp_tables,
    ROUND(SUM_CREATED_TMP_DISK_TABLES/SUM_CREATED_TMP_TABLES*100, 2) AS disk_tmp_percentage
FROM performance_schema.events_statements_summary_by_digest
WHERE SUM_CREATED_TMP_TABLES > 0
    AND DIGEST_TEXT LIKE '%CALL%'
ORDER BY disk_tmp_percentage DESC;
```

---

## 5. 🚨 告警机制设置


### 5.1 阈值设置策略


**⚙️ 告警阈值配置**

```sql
-- 创建存储过程监控配置表
CREATE TABLE sp_monitor_config (
    id INT AUTO_INCREMENT PRIMARY KEY,
    sp_name VARCHAR(100),
    metric_name VARCHAR(50),
    warning_threshold DECIMAL(10,2),
    critical_threshold DECIMAL(10,2),
    check_interval_minutes INT DEFAULT 5,
    is_enabled TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入监控配置
INSERT INTO sp_monitor_config (sp_name, metric_name, warning_threshold, critical_threshold) VALUES
('user_login', 'avg_execution_time', 0.5, 1.0),        -- 平均执行时间：警告0.5秒，严重1秒
('data_export', 'avg_execution_time', 5.0, 10.0),      -- 数据导出：警告5秒，严重10秒
('%', 'error_rate', 1.0, 5.0),                         -- 错误率：警告1%，严重5%
('%', 'calls_per_minute', 1000, 2000);                 -- 每分钟调用数：警告1000，严重2000
```

### 5.2 自动告警脚本


**🔔 告警检查存储过程**
```sql
DELIMITER //
CREATE PROCEDURE check_sp_performance()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE sp_name VARCHAR(100);
    DECLARE current_avg_time DECIMAL(10,3);
    DECLARE warning_threshold DECIMAL(10,2);
    DECLARE critical_threshold DECIMAL(10,2);
    
    -- 游标：获取需要检查的存储过程
    DECLARE sp_cursor CURSOR FOR
        SELECT 
            c.sp_name,
            c.warning_threshold,
            c.critical_threshold,
            COALESCE(s.avg_time_seconds, 0) as current_avg_time
        FROM sp_monitor_config c
        LEFT JOIN sp_call_stats s ON c.sp_name = s.sp_name OR c.sp_name = '%'
        WHERE c.is_enabled = 1 AND c.metric_name = 'avg_execution_time';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN sp_cursor;
    
    check_loop: LOOP
        FETCH sp_cursor INTO sp_name, warning_threshold, critical_threshold, current_avg_time;
        
        IF done THEN
            LEAVE check_loop;
        END IF;
        
        -- 检查是否超过阈值
        IF current_avg_time >= critical_threshold THEN
            INSERT INTO sp_alerts (sp_name, alert_level, metric_value, threshold_value, message)
            VALUES (sp_name, 'CRITICAL', current_avg_time, critical_threshold, 
                   CONCAT('存储过程执行时间过长: ', current_avg_time, '秒'));
                   
        ELSEIF current_avg_time >= warning_threshold THEN
            INSERT INTO sp_alerts (sp_name, alert_level, metric_value, threshold_value, message)
            VALUES (sp_name, 'WARNING', current_avg_time, warning_threshold,
                   CONCAT('存储过程执行时间较长: ', current_avg_time, '秒'));
        END IF;
        
    END LOOP;
    
    CLOSE sp_cursor;
END //
DELIMITER ;
```

---

## 6. 🔧 问题诊断方法


### 6.1 慢执行诊断


**🐌 慢存储过程分析**
当存储过程执行缓慢时，需要系统化地分析原因。

```sql
-- 诊断慢执行存储过程的工具查询
SELECT 
    '性能概览' as category,
    DIGEST_TEXT as details,
    COUNT_STAR as executions,
    ROUND(AVG_TIMER_WAIT/1000000000, 3) as avg_seconds,
    ROUND(MAX_TIMER_WAIT/1000000000, 3) as max_seconds,
    ROUND(SUM_TIMER_WAIT/1000000000, 2) as total_seconds
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%CALL%'
    AND AVG_TIMER_WAIT > 1000000000  -- 平均执行时间超过1秒
    
UNION ALL

SELECT 
    '锁等待分析' as category,
    CONCAT('锁类型: ', LOCK_TYPE, ', 锁模式: ', LOCK_MODE) as details,
    COUNT(*) as executions,
    ROUND(AVG(LOCK_DURATION)/1000000000, 3) as avg_seconds,
    ROUND(MAX(LOCK_DURATION)/1000000000, 3) as max_seconds,
    ROUND(SUM(LOCK_DURATION)/1000000000, 2) as total_seconds
FROM performance_schema.data_locks
WHERE LOCK_DURATION > 1000000000  -- 锁持续时间超过1秒
GROUP BY LOCK_TYPE, LOCK_MODE

ORDER BY total_seconds DESC;
```

### 6.2 错误模式识别


**❌ 常见错误分析**
```sql
-- 创建错误日志分析视图
CREATE VIEW sp_error_analysis AS
SELECT 
    DATE(FROM_UNIXTIME(TIMER_START/1000000000000)) as error_date,
    HOUR(FROM_UNIXTIME(TIMER_START/1000000000000)) as error_hour,
    REGEXP_SUBSTR(SQL_TEXT, 'CALL\\s+([^\\(]+)', 1, 1, '', 1) as sp_name,
    MESSAGE_TEXT as error_message,
    COUNT(*) as error_count
FROM performance_schema.events_statements_history_long
WHERE MESSAGE_TEXT IS NOT NULL 
    AND MESSAGE_TEXT != ''
    AND SQL_TEXT LIKE '%CALL%'
GROUP BY error_date, error_hour, sp_name, error_message
ORDER BY error_date DESC, error_hour DESC, error_count DESC;
```

---

## 7. 🤖 运维自动化实践


### 7.1 自动化监控脚本


**⚙️ 定时监控任务**
使用MySQL的事件调度器实现自动化监控。

```sql
-- 启用事件调度器
SET GLOBAL event_scheduler = ON;

-- 创建定时监控事件
DELIMITER //
CREATE EVENT sp_performance_monitor
ON SCHEDULE EVERY 5 MINUTE
STARTS CURRENT_TIMESTAMP
DO
BEGIN
    -- 清理旧的统计数据（保留7天）
    DELETE FROM sp_performance_log 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 7 DAY);
    
    -- 记录当前性能指标
    INSERT INTO sp_performance_log (sp_name, avg_execution_time, call_count, error_count, created_at)
    SELECT 
        REGEXP_SUBSTR(DIGEST_TEXT, 'CALL\\s+([^\\(]+)', 1, 1, '', 1) as sp_name,
        ROUND(AVG_TIMER_WAIT/1000000000, 3) as avg_execution_time,
        COUNT_STAR as call_count,
        SUM_ERRORS as error_count,
        NOW() as created_at
    FROM performance_schema.events_statements_summary_by_digest
    WHERE DIGEST_TEXT LIKE '%CALL%'
        AND LAST_SEEN >= DATE_SUB(NOW(), INTERVAL 5 MINUTE);
        
    -- 执行告警检查
    CALL check_sp_performance();
END //
DELIMITER ;
```

### 7.2 性能报告生成


**📊 自动报告生成**
```sql
-- 创建每日性能报告存储过程
DELIMITER //
CREATE PROCEDURE generate_daily_sp_report(IN report_date DATE)
BEGIN
    SELECT 
        '=== MySQL存储过程每日性能报告 ===' as title,
        report_date as report_for_date;
    
    -- Top 10 最常调用的存储过程
    SELECT 
        '最常调用的存储过程 (Top 10)' as section,
        sp_name,
        SUM(call_count) as total_calls,
        ROUND(AVG(avg_execution_time), 3) as avg_time_seconds
    FROM sp_performance_log
    WHERE DATE(created_at) = report_date
    GROUP BY sp_name
    ORDER BY total_calls DESC
    LIMIT 10;
    
    -- 性能最差的存储过程
    SELECT 
        '执行最慢的存储过程 (Top 5)' as section,
        sp_name,
        MAX(avg_execution_time) as slowest_avg_time,
        SUM(call_count) as total_calls
    FROM sp_performance_log
    WHERE DATE(created_at) = report_date
    GROUP BY sp_name
    ORDER BY slowest_avg_time DESC
    LIMIT 5;
    
    -- 错误统计
    SELECT 
        '错误统计' as section,
        sp_name,
        SUM(error_count) as total_errors,
        SUM(call_count) as total_calls,
        ROUND(SUM(error_count)/SUM(call_count)*100, 2) as error_rate_percent
    FROM sp_performance_log
    WHERE DATE(created_at) = report_date
        AND error_count > 0
    GROUP BY sp_name
    ORDER BY error_rate_percent DESC;
END //
DELIMITER ;
```

---

## 8. 🔍 执行计划变更检测


### 8.1 执行计划监控原理


**💡 为什么监控执行计划变更**
执行计划变更就像开车时突然改变路线，可能导致性能急剧下降。

> 🎯 **核心理念**  
> MySQL优化器会根据数据分布、索引状态等因素选择最优执行计划。当这些因素变化时，执行计划可能改变，导致性能波动。

**📊 执行计划变更检测方法**
```sql
-- 创建执行计划历史表
CREATE TABLE sp_execution_plans (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    sp_name VARCHAR(100),
    plan_hash VARCHAR(64),        -- 执行计划的哈希值
    plan_details TEXT,            -- 执行计划详细信息
    execution_count INT,
    avg_execution_time DECIMAL(10,3),
    first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_sp_name (sp_name),
    INDEX idx_plan_hash (plan_hash)
);
```

### 8.2 计划变更检测实现


**🔍 计划捕获和对比**
```sql
DELIMITER //
CREATE PROCEDURE detect_plan_changes()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE current_sp VARCHAR(100);
    DECLARE current_plan_hash VARCHAR(64);
    DECLARE current_plan TEXT;
    DECLARE existing_count INT;
    
    -- 游标：获取当前活跃的存储过程执行信息
    DECLARE plan_cursor CURSOR FOR
        SELECT 
            REGEXP_SUBSTR(DIGEST_TEXT, 'CALL\\s+([^\\(]+)', 1, 1, '', 1) as sp_name,
            DIGEST as plan_hash,
            SUBSTRING(DIGEST_TEXT, 1, 1000) as plan_summary
        FROM performance_schema.events_statements_summary_by_digest
        WHERE DIGEST_TEXT LIKE '%CALL%'
            AND COUNT_STAR > 0
            AND LAST_SEEN >= DATE_SUB(NOW(), INTERVAL 1 HOUR);
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN plan_cursor;
    
    plan_loop: LOOP
        FETCH plan_cursor INTO current_sp, current_plan_hash, current_plan;
        
        IF done THEN
            LEAVE plan_loop;
        END IF;
        
        -- 检查是否是新的执行计划
        SELECT COUNT(*) INTO existing_count
        FROM sp_execution_plans
        WHERE sp_name = current_sp AND plan_hash = current_plan_hash;
        
        IF existing_count = 0 THEN
            -- 新的执行计划，记录并检查是否需要告警
            INSERT INTO sp_execution_plans (sp_name, plan_hash, plan_details, execution_count)
            VALUES (current_sp, current_plan_hash, current_plan, 1);
            
            -- 检查该存储过程是否已有其他执行计划（计划变更告警）
            SELECT COUNT(DISTINCT plan_hash) INTO existing_count
            FROM sp_execution_plans
            WHERE sp_name = current_sp;
            
            IF existing_count > 1 THEN
                INSERT INTO sp_alerts (sp_name, alert_level, message)
                VALUES (current_sp, 'WARNING', 
                       CONCAT('检测到执行计划变更，存储过程: ', current_sp));
            END IF;
        END IF;
        
    END LOOP;
    
    CLOSE plan_cursor;
END //
DELIMITER ;
```

### 8.3 计划性能对比


**📈 性能变化分析**
```sql
-- 对比不同执行计划的性能
SELECT 
    p.sp_name,
    p.plan_hash,
    p.first_seen as plan_introduced,
    s.COUNT_STAR as recent_executions,
    ROUND(s.AVG_TIMER_WAIT/1000000000, 3) as current_avg_time,
    p.avg_execution_time as historical_avg_time,
    ROUND(
        (s.AVG_TIMER_WAIT/1000000000 - p.avg_execution_time) / p.avg_execution_time * 100, 
        2
    ) as performance_change_percent
FROM sp_execution_plans p
JOIN performance_schema.events_statements_summary_by_digest s 
    ON p.plan_hash = s.DIGEST
WHERE s.LAST_SEEN >= DATE_SUB(NOW(), INTERVAL 1 DAY)
    AND p.avg_execution_time > 0
ORDER BY ABS(performance_change_percent) DESC;
```

---

## 9. 📋 核心要点总结


### 9.1 监控体系架构理解


> 💡 **核心概念**  
> 存储过程监控 = 体检中心，通过各种"检查设备"全面了解存储过程的健康状况

**🔸 三层监控架构**
```
应用层监控 ← 用户视角：调用是否成功、响应是否及时
数据库层监控 ← 数据库视角：资源消耗、执行效率
系统层监控 ← 服务器视角：CPU、内存、磁盘使用情况
```

### 9.2 关键监控指标记忆


**🎯 必须监控的核心指标**
- ⏱️ **执行时间**：平均、最大、总计（最直观的性能指标）
- 📊 **调用频率**：单位时间调用次数（识别热点）
- ❌ **错误率**：失败次数/总次数（稳定性指标）
- 💾 **资源消耗**：CPU、内存、临时表使用（资源效率）
- 🔒 **锁等待**：等待时间和频率（并发性能）

### 9.3 实用运维策略


**🚀 自动化运维要点**
```
定时检查 → 异常告警 → 问题诊断 → 性能优化
    ↓         ↓         ↓         ↓
   5分钟     实时通知   分析工具   计划调整
```

**📱 告警设置原则**
- 🟡 **警告级别**：性能下降20-50%，通知相关人员
- 🔴 **严重级别**：性能下降50%以上或大量错误，立即处理
- 📈 **趋势监控**：持续监控性能变化趋势，预防问题

### 9.4 问题诊断思路


**🔍 系统化诊断步骤**
1. **确认现象**：通过监控指标确认问题存在
2. **缩小范围**：确定是哪个存储过程、什么时间段
3. **分析原因**：检查执行计划、资源使用、锁等待
4. **制定方案**：根据原因制定优化措施
5. **验证效果**：实施后持续监控验证

**💼 常见问题及解决思路**
- 🐌 **执行慢**：检查索引、优化SQL、减少数据量
- 🔒 **锁等待**：优化事务大小、调整隔离级别
- 💥 **频繁错误**：检查输入参数、异常处理逻辑
- 📈 **资源消耗高**：优化算法、减少临时表使用

**核心记忆**：
- 监控体系三层架构，指标全面无遗漏
- Performance Schema是核心，自动化运维是方向
- 告警及时问题早发现，诊断系统效率高
- 执行计划要关注，性能变化早预警