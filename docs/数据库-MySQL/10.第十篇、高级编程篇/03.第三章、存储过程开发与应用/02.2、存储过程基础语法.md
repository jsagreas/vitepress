---
title: 2、存储过程基础语法
---
## 📚 目录

1. [存储过程概念与原理](#1-存储过程概念与原理)
2. [CREATE PROCEDURE语法结构](#2-CREATE-PROCEDURE语法结构)
3. [参数类型详解](#3-参数类型详解)
4. [变量声明与赋值](#4-变量声明与赋值)
5. [复合语句块](#5-复合语句块)
6. [存储过程调用与管理](#6-存储过程调用与管理)
7. [存储过程特性声明](#7-存储过程特性声明)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌟 存储过程概念与原理


### 1.1 什么是存储过程


**🔸 基本定义**
存储过程就是一组预先编写好的SQL语句，保存在数据库服务器中，可以重复调用执行。

```
简单理解：
就像把一套复杂的SQL操作打包成一个"函数"
调用时直接执行这个"函数"，不用重复写SQL
```

**💡 工作原理**
```
传统方式：
客户端 → 发送SQL1 → 服务器执行 → 返回结果
客户端 → 发送SQL2 → 服务器执行 → 返回结果
客户端 → 发送SQL3 → 服务器执行 → 返回结果

存储过程方式：
客户端 → 调用存储过程 → 服务器执行SQL1,2,3 → 返回结果
```

### 1.2 存储过程的优势


| **优势** | **说明** | **应用场景** |
|---------|---------|-------------|
| 🚀 **性能更好** | `SQL预编译，执行速度快` | `频繁执行的复杂查询` |
| 🔒 **安全性高** | `避免SQL注入，权限控制精细` | `敏感数据操作` |
| 📦 **代码复用** | `一次编写，多次调用` | `通用业务逻辑` |
| 🌐 **网络开销小** | `减少客户端与服务器通信` | `大量SQL操作` |
| 🧩 **逻辑集中** | `业务逻辑集中在数据库层` | `复杂数据处理` |

**🎯 实际应用举例**
```
电商订单处理：
1. 检查库存是否充足
2. 扣减库存数量
3. 创建订单记录
4. 更新用户积分
5. 记录操作日志

这些操作放在存储过程中，保证原子性和一致性
```

---

## 2. 📝 CREATE PROCEDURE语法结构


### 2.1 基本语法格式


**🔸 完整语法结构**
```sql
CREATE PROCEDURE 存储过程名称(
    参数列表
)
[存储过程特性]
BEGIN
    存储过程体
END
```

### 2.2 简单示例入门


**💻 最简单的存储过程**
```sql
-- 创建一个简单的存储过程
CREATE PROCEDURE hello_world()
BEGIN
    SELECT 'Hello, World!' AS message;
END;

-- 调用存储过程
CALL hello_world();
```

**🔧 带参数的存储过程**
```sql
-- 根据用户ID查询用户信息
CREATE PROCEDURE get_user_info(IN user_id INT)
BEGIN
    SELECT username, email, create_time 
    FROM users 
    WHERE id = user_id;
END;

-- 调用时传入参数
CALL get_user_info(1001);
```

### 2.3 创建存储过程的注意事项


> 💡 **分隔符问题**  
> 创建存储过程时需要改变语句分隔符，因为过程体内包含分号

```sql
-- 修改分隔符为 //
DELIMITER //

CREATE PROCEDURE demo_proc()
BEGIN
    SELECT 'Line 1';
    SELECT 'Line 2';
END //

-- 恢复默认分隔符
DELIMITER ;
```

**⚠️ 常见错误**
- 忘记修改分隔符导致语法错误
- 存储过程名称重复
- 参数定义不正确

---

## 3. 🔧 参数类型详解


### 3.1 三种参数类型


存储过程的参数有三种类型，理解它们的区别很重要：

**🔸 IN参数（输入参数）**
```
作用：从外部传递数据到存储过程内部
特点：只能读取，不能修改
用途：查询条件、计算数据等
```

**🔸 OUT参数（输出参数）**
```
作用：从存储过程内部返回数据到外部
特点：过程内部可以赋值，外部接收结果
用途：返回计算结果、状态信息等
```

**🔸 INOUT参数（输入输出参数）**
```
作用：既可以输入也可以输出
特点：双向传递数据
用途：需要修改传入值的场景
```

### 3.2 参数类型实例演示


**💻 IN参数示例**
```sql
-- 根据年龄范围查询用户数量
DELIMITER //
CREATE PROCEDURE count_users_by_age(
    IN min_age INT,
    IN max_age INT
)
BEGIN
    SELECT COUNT(*) AS user_count
    FROM users 
    WHERE age BETWEEN min_age AND max_age;
END //
DELIMITER ;

-- 调用：查询20-30岁用户数量
CALL count_users_by_age(20, 30);
```

**💻 OUT参数示例**
```sql
-- 计算用户总数和平均年龄
DELIMITER //
CREATE PROCEDURE get_user_statistics(
    OUT total_users INT,
    OUT avg_age DECIMAL(5,2)
)
BEGIN
    SELECT COUNT(*), AVG(age) 
    INTO total_users, avg_age
    FROM users;
END //
DELIMITER ;

-- 调用并接收结果
CALL get_user_statistics(@total, @avg);
SELECT @total AS '总用户数', @avg AS '平均年龄';
```

**💻 INOUT参数示例**
```sql
-- 累加计算器
DELIMITER //
CREATE PROCEDURE add_number(INOUT number INT, IN add_value INT)
BEGIN
    SET number = number + add_value;
END //
DELIMITER ;

-- 使用示例
SET @num = 10;
CALL add_number(@num, 5);  -- @num变成15
SELECT @num;  -- 输出：15
```

### 3.3 参数定义规范


**📋 参数命名规范**
```sql
-- 推荐的参数命名方式
CREATE PROCEDURE update_user_info(
    IN p_user_id INT,          -- p_前缀表示参数
    IN p_username VARCHAR(50),
    IN p_email VARCHAR(100),
    OUT p_result_code INT,     -- 返回操作结果码
    OUT p_message VARCHAR(200) -- 返回消息
)
```

**🎯 参数类型选择指南**
- **查询条件** → 使用 `IN` 参数
- **返回结果** → 使用 `OUT` 参数  
- **需要修改的值** → 使用 `INOUT` 参数
- **状态码、消息** → 使用 `OUT` 参数

---

## 4. 📊 变量声明与赋值


### 4.1 局部变量DECLARE声明


**🔸 DECLARE语法格式**
```sql
DECLARE 变量名 数据类型 [DEFAULT 默认值];
```

**💻 变量声明示例**
```sql
DELIMITER //
CREATE PROCEDURE variable_demo()
BEGIN
    -- 声明各种类型的局部变量
    DECLARE v_user_count INT DEFAULT 0;
    DECLARE v_username VARCHAR(50);
    DECLARE v_create_date DATE DEFAULT CURDATE();
    DECLARE v_is_active BOOLEAN DEFAULT TRUE;
    
    -- 使用变量
    SELECT COUNT(*) INTO v_user_count FROM users;
    SELECT username INTO v_username FROM users WHERE id = 1;
    
    -- 输出变量值
    SELECT v_user_count, v_username, v_create_date, v_is_active;
END //
DELIMITER ;
```

### 4.2 变量赋值SET语句


**🔸 SET赋值方式**
```sql
-- 直接赋值
SET 变量名 = 值;

-- 计算赋值
SET 变量名 = 表达式;
```

**🔸 SELECT INTO赋值方式**
```sql
-- 从查询结果赋值
SELECT 字段名 INTO 变量名 FROM 表名 WHERE 条件;
```

**💻 变量赋值综合示例**
```sql
DELIMITER //
CREATE PROCEDURE user_order_summary(IN user_id INT)
BEGIN
    DECLARE v_order_count INT;
    DECLARE v_total_amount DECIMAL(10,2);
    DECLARE v_avg_amount DECIMAL(10,2);
    DECLARE v_status VARCHAR(20);
    
    -- 使用SELECT INTO赋值
    SELECT COUNT(*), SUM(amount), AVG(amount)
    INTO v_order_count, v_total_amount, v_avg_amount
    FROM orders 
    WHERE customer_id = user_id;
    
    -- 使用SET赋值
    SET v_status = CASE 
        WHEN v_order_count > 10 THEN 'VIP客户'
        WHEN v_order_count > 5 THEN '活跃客户'
        ELSE '普通客户'
    END;
    
    -- 返回结果
    SELECT v_order_count AS '订单数量',
           v_total_amount AS '总金额',
           v_avg_amount AS '平均金额',
           v_status AS '客户等级';
END //
DELIMITER ;
```

### 4.3 变量作用域


**📋 变量类型对比**

| **变量类型** | **声明方式** | **作用域** | **生命周期** |
|-------------|-------------|-----------|-------------|
| **局部变量** | `DECLARE v_name INT` | `存储过程内部` | `过程执行期间` |
| **用户变量** | `SET @var_name = value` | `会话级别` | `连接断开前` |
| **系统变量** | `SET $$var_name = value` | `全局或会话` | `服务器运行期间` |

---

## 5. 🏗️ 复合语句块


### 5.1 BEGIN-END语句块


**🔸 基本概念**
BEGIN-END用于创建复合语句块，可以包含多条SQL语句，类似编程语言中的大括号 `{}`。

```sql
BEGIN
    -- 这里可以写多条SQL语句
    -- 声明变量
    -- 流程控制
    -- 异常处理等
END
```

### 5.2 语句块的嵌套使用


**💻 嵌套语句块示例**
```sql
DELIMITER //
CREATE PROCEDURE nested_blocks_demo(IN dept_id INT)
BEGIN
    DECLARE v_dept_name VARCHAR(50);
    DECLARE v_emp_count INT;
    
    -- 外层语句块
    SELECT dept_name INTO v_dept_name 
    FROM departments 
    WHERE id = dept_id;
    
    -- 嵌套语句块
    BEGIN
        DECLARE v_total_salary DECIMAL(10,2);
        
        SELECT COUNT(*), SUM(salary) 
        INTO v_emp_count, v_total_salary
        FROM employees 
        WHERE department_id = dept_id;
        
        SELECT v_dept_name AS '部门名称',
               v_emp_count AS '员工数量',
               v_total_salary AS '工资总额';
    END;
    
END //
DELIMITER ;
```

### 5.3 语句块的注意事项


> ⚠️ **重要提醒**  
> - DECLARE语句必须在语句块开头
> - 变量声明要在其他语句之前
> - 内层语句块的变量会覆盖外层同名变量

**🎯 最佳实践**
```sql
BEGIN
    -- 1. 首先声明所有变量
    DECLARE v_var1 INT;
    DECLARE v_var2 VARCHAR(50);
    
    -- 2. 然后声明异常处理
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 异常处理逻辑
    END;
    
    -- 3. 最后编写业务逻辑
    -- SQL语句和逻辑控制
END;
```

---

## 6. 📞 存储过程调用与管理


### 6.1 存储过程调用CALL


**🔸 CALL语法格式**
```sql
CALL 存储过程名称(参数列表);
```

**💻 不同参数类型的调用方式**
```sql
-- 1. 无参数存储过程
CALL show_current_time();

-- 2. 只有IN参数
CALL get_user_info(1001);

-- 3. 有OUT参数（需要用变量接收）
CALL get_user_count(@total_users);
SELECT @total_users;

-- 4. 混合参数类型
CALL update_user_status(1001, 'active', @result_code, @message);
SELECT @result_code, @message;
```

### 6.2 存储过程删除DROP


**🔸 删除语法**
```sql
DROP PROCEDURE [IF EXISTS] 存储过程名称;
```

**💻 删除示例**
```sql
-- 删除存储过程（如果不存在会报错）
DROP PROCEDURE get_user_info;

-- 安全删除（如果不存在不会报错）
DROP PROCEDURE IF EXISTS get_user_info;
```

### 6.3 存储过程查看与管理


**📋 查看存储过程信息**
```sql
-- 查看所有存储过程
SHOW PROCEDURE STATUS;

-- 查看特定数据库的存储过程
SHOW PROCEDURE STATUS WHERE db = 'your_database';

-- 查看存储过程定义
SHOW CREATE PROCEDURE procedure_name;

-- 从系统表查看存储过程信息
SELECT 
    routine_name AS '存储过程名',
    routine_type AS '类型',
    created AS '创建时间',
    last_altered AS '最后修改时间'
FROM information_schema.routines 
WHERE routine_schema = 'your_database'
  AND routine_type = 'PROCEDURE';
```

---

## 7. ⚙️ 存储过程特性声明


### 7.1 CHARACTERISTICS存储过程特性


**🔸 特性类型说明**
```sql
CREATE PROCEDURE proc_name()
[LANGUAGE SQL]                    -- 使用SQL语言（默认）
[DETERMINISTIC | NOT DETERMINISTIC]  -- 确定性声明
[SQL SECURITY DEFINER | INVOKER]     -- 权限模式
[COMMENT 'string']                   -- 注释说明
BEGIN
    -- 存储过程体
END
```

### 7.2 DETERMINISTIC确定性声明


**🔸 确定性概念解释**
```
DETERMINISTIC（确定性）：
- 相同输入总是产生相同输出
- 不依赖外部状态变化
- 例如：计算函数、数据转换等

NOT DETERMINISTIC（非确定性）：
- 相同输入可能产生不同输出  
- 依赖时间、随机数、系统状态等
- 例如：获取当前时间、生成随机数等
```

**💻 确定性示例**
```sql
-- 确定性存储过程（计算圆面积）
DELIMITER //
CREATE PROCEDURE calculate_circle_area(
    IN radius DECIMAL(10,2),
    OUT area DECIMAL(10,2)
)
DETERMINISTIC
COMMENT '计算圆形面积'
BEGIN
    SET area = 3.14159 * radius * radius;
END //

-- 非确定性存储过程（记录操作日志）
CREATE PROCEDURE log_user_action(
    IN user_id INT,
    IN action_type VARCHAR(50)
)
NOT DETERMINISTIC
COMMENT '记录用户操作日志'
BEGIN
    INSERT INTO user_logs(user_id, action_type, log_time)
    VALUES(user_id, action_type, NOW());
END //
DELIMITER ;
```

### 7.3 SQL SECURITY权限模式


**🔸 权限模式类型**
```
SQL SECURITY DEFINER：
- 以存储过程定义者的权限执行
- 调用者不需要直接访问表的权限
- 适用于安全性要求高的场景

SQL SECURITY INVOKER：
- 以存储过程调用者的权限执行
- 调用者需要有相应的表访问权限
- 适用于权限控制灵活的场景
```

**💻 权限模式示例**
```sql
-- 使用定义者权限（推荐用于敏感操作）
DELIMITER //
CREATE PROCEDURE admin_get_user_data(IN user_id INT)
SQL SECURITY DEFINER
COMMENT '管理员查看用户数据'
BEGIN
    SELECT * FROM sensitive_user_data WHERE id = user_id;
END //

-- 使用调用者权限
CREATE PROCEDURE user_get_own_data(IN user_id INT)
SQL SECURITY INVOKER  
COMMENT '用户查看自己的数据'
BEGIN
    SELECT * FROM user_profile WHERE id = user_id;
END //
DELIMITER ;
```

### 7.4 完整语法结构示例


**💻 包含所有特性的存储过程**
```sql
DELIMITER //
CREATE PROCEDURE comprehensive_example(
    IN p_user_id INT,
    OUT p_result_code INT,
    OUT p_message VARCHAR(200)
)
LANGUAGE SQL
DETERMINISTIC
SQL SECURITY DEFINER
COMMENT '综合示例存储过程 - 用户信息验证'
BEGIN
    DECLARE v_user_exists INT DEFAULT 0;
    
    -- 检查用户是否存在
    SELECT COUNT(*) INTO v_user_exists 
    FROM users 
    WHERE id = p_user_id AND status = 'active';
    
    IF v_user_exists > 0 THEN
        SET p_result_code = 1;
        SET p_message = '用户验证成功';
    ELSE
        SET p_result_code = 0;
        SET p_message = '用户不存在或已禁用';
    END IF;
    
END //
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 存储过程本质：预编译的SQL语句集合，提高性能和安全性
🔸 CREATE PROCEDURE：创建存储过程的完整语法结构
🔸 参数类型：IN（输入）、OUT（输出）、INOUT（输入输出）三种类型
🔸 变量声明：DECLARE声明局部变量，SET进行赋值操作
🔸 复合语句：BEGIN-END语句块组织多条SQL语句
🔸 存储过程调用：CALL语句调用，DROP语句删除
🔸 特性声明：DETERMINISTIC、SQL SECURITY等特性配置
```

### 8.2 关键理解要点


**🔹 存储过程的核心价值**
```
性能优势：
- SQL预编译，执行效率高
- 减少网络传输开销
- 缓存执行计划

安全优势：
- 避免SQL注入攻击
- 精细化权限控制
- 隐藏业务逻辑实现

维护优势：
- 业务逻辑集中管理
- 代码复用性强
- 统一修改和部署
```

**🔹 参数类型选择策略**
```
选择原则：
IN参数  → 传递查询条件、配置参数
OUT参数 → 返回计算结果、状态信息
INOUT参数 → 需要修改传入值的场景

使用技巧：
- 多个返回值用OUT参数
- 状态码和消息分别用不同OUT参数
- 避免过多INOUT参数，影响可读性
```

**🔹 变量管理最佳实践**
```
命名规范：
- 局部变量：v_变量名
- 参数变量：p_参数名  
- 用户变量：@变量名

声明顺序：
1. 先声明所有变量
2. 再声明异常处理
3. 最后编写业务逻辑

作用域控制：
- 合理使用嵌套语句块
- 避免变量名冲突
- 明确变量生命周期
```

### 8.3 实际应用指导


**🎯 适用场景判断**
```
适合使用存储过程：
✅ 复杂的业务逻辑处理
✅ 频繁执行的数据操作
✅ 需要事务控制的操作
✅ 对性能要求较高的场景
✅ 需要精细权限控制

不适合使用存储过程：
❌ 简单的CRUD操作
❌ 频繁变更的业务逻辑
❌ 需要跨数据库移植
❌ 团队缺乏数据库开发经验
```

**🔧 开发注意事项**
```
语法要点：
- 注意分隔符的设置和恢复
- DECLARE语句必须在语句块开头
- 参数和变量命名要规范
- 合理使用特性声明

调试技巧：
- 使用SELECT语句输出中间结果
- 分步骤验证逻辑正确性
- 利用用户变量传递调试信息
- 编写完整的错误处理逻辑

性能优化：
- 避免在循环中执行复杂查询
- 合理使用索引
- 控制结果集大小
- 考虑并发访问的影响
```

**核心记忆**：
- 存储过程是数据库层面的"函数"，提升性能和安全性
- 三种参数类型各有用途：IN传入、OUT传出、INOUT双向
- 变量声明用DECLARE，赋值用SET，查询赋值用SELECT INTO
- BEGIN-END组织复合语句，CALL调用执行，DROP删除管理
- 特性声明影响执行方式，要根据实际需求合理配置