---
title: 6、存储过程错误处理
---
## 📚 目录

1. [错误处理基础概念](#1-错误处理基础概念)
2. [异常处理机制详解](#2-异常处理机制详解)
3. [SQLSTATE状态码系统](#3-SQLSTATE状态码系统)
4. [错误日志与诊断](#4-错误日志与诊断)
5. [自定义异常管理](#5-自定义异常管理)
6. [高级错误处理技巧](#6-高级错误处理技巧)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🛡️ 错误处理基础概念


### 1.1 为什么需要错误处理


**简单理解**：存储过程就像一个程序，程序运行时可能遇到各种问题，比如数据不存在、权限不够、磁盘满了等。如果不处理这些错误，程序会直接崩溃，用户得不到友好的提示。

```
现实类比：
开车遇到红灯 → 停车等待（正常处理）
开车遇到故障 → 靠边停车、报警（错误处理）

数据库操作：
查询用户信息 → 返回结果（正常流程）
用户不存在 → 友好提示（错误处理）
```

**错误处理的作用**：
- **用户体验**：给出清晰的错误信息，而不是技术术语
- **程序稳定**：避免整个程序因为一个错误而崩溃
- **调试方便**：记录详细错误信息，便于开发者定位问题
- **数据安全**：在错误发生时保护数据完整性

### 1.2 MySQL错误处理机制概览


```
错误处理流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  SQL执行    │───▶│  发生错误   │───▶│  触发处理器 │
└─────────────┘    └─────────────┘    └─────────────┘
                          │                   │
                          ▼                   ▼
                   ┌─────────────┐    ┌─────────────┐
                   │  记录错误   │    │  执行处理   │
                   └─────────────┘    └─────────────┘
```

**处理器类型**：
- **`CONTINUE HANDLER`**：遇到错误后继续执行
- **`EXIT HANDLER`**：遇到错误后退出当前程序块
- **`UNDO HANDLER`**：遇到错误后撤销操作（很少使用）

---

## 2. ⚙️ 异常处理机制详解


### 2.1 CONTINUE HANDLER - 继续处理器


**核心概念**：当遇到指定的错误时，执行处理代码，然后继续执行后续语句。

```sql
DELIMITER //

CREATE PROCEDURE demo_continue_handler()
BEGIN
    -- 声明变量
    DECLARE v_user_id INT DEFAULT 0;
    DECLARE v_error_count INT DEFAULT 0;
    
    -- 声明继续处理器：遇到"记录不存在"错误时继续执行
    DECLARE CONTINUE HANDLER FOR NOT FOUND 
        SET v_error_count = v_error_count + 1;
    
    -- 模拟查询不存在的用户
    SELECT user_id INTO v_user_id FROM users WHERE user_id = 99999;
    
    -- 这里会继续执行（因为用了CONTINUE）
    SELECT CONCAT('错误次数: ', v_error_count, ', 用户ID: ', v_user_id) AS result;
    
END //

DELIMITER ;
```

**执行效果**：
```
调用：CALL demo_continue_handler();
结果：错误次数: 1, 用户ID: 0

解释：查询不存在的用户时触发了NOT FOUND错误，
     处理器执行了error_count+1，然后继续执行后面的SELECT
```

### 2.2 EXIT HANDLER - 退出处理器


**核心概念**：当遇到指定的错误时，执行处理代码，然后立即退出当前程序块。

```sql
DELIMITER //

CREATE PROCEDURE demo_exit_handler(IN p_user_id INT)
BEGIN
    DECLARE v_username VARCHAR(50);
    
    -- 声明退出处理器：遇到任何SQL异常都退出
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 记录错误并返回友好信息
        SELECT 'ERROR: 用户查询失败，请检查用户ID是否正确' AS error_message;
        ROLLBACK;  -- 如果在事务中，回滚操作
    END;
    
    -- 开始事务
    START TRANSACTION;
    
    -- 查询用户（如果用户不存在会触发异常）
    SELECT username INTO v_username FROM users WHERE user_id = p_user_id;
    
    -- 更新最后登录时间
    UPDATE users SET last_login = NOW() WHERE user_id = p_user_id;
    
    COMMIT;
    SELECT CONCAT('用户 ', v_username, ' 登录成功') AS success_message;
    
END //

DELIMITER ;
```

### 2.3 处理器优先级机制


**优先级规则**：从高到低
1. **具体SQLSTATE**（如'23000'）
2. **具体MySQL错误号**（如1062）
3. **命名条件**（如CONDITION定义的条件）
4. **通用条件**（如SQLWARNING、NOT FOUND、SQLEXCEPTION）

```sql
DELIMITER //

CREATE PROCEDURE demo_handler_priority()
BEGIN
    DECLARE v_result VARCHAR(100);
    
    -- 优先级1：具体的SQLSTATE（最高优先级）
    DECLARE CONTINUE HANDLER FOR SQLSTATE '23000'
        SET v_result = '处理器1：违反唯一约束';
    
    -- 优先级2：具体的错误号
    DECLARE CONTINUE HANDLER FOR 1062
        SET v_result = '处理器2：重复键错误';
    
    -- 优先级3：通用异常类别（最低优先级）
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        SET v_result = '处理器3：通用SQL异常';
    
    -- 模拟插入重复数据（会触发SQLSTATE '23000'或错误1062）
    INSERT INTO users (email) VALUES ('duplicate@test.com');
    
    SELECT v_result AS which_handler_triggered;
    
END //

DELIMITER ;
```

---

## 3. 📊 SQLSTATE状态码系统


### 3.1 SQLSTATE分类体系


**SQLSTATE格式**：5位字符，前2位是类别，后3位是具体错误

```
SQLSTATE分类：
┌─────────┬─────────────────┬─────────────────────┐
│  类别   │     含义        │      示例           │
├─────────┼─────────────────┼─────────────────────┤
│  00     │ 成功完成        │ 00000 (成功)        │
│  01     │ 警告            │ 01000 (一般警告)    │
│  02     │ 没有数据        │ 02000 (无数据)      │
│  23     │ 完整性约束违反  │ 23000 (约束冲突)    │
│  42     │ 语法错误        │ 42000 (语法错误)    │
│  HY     │ 一般错误        │ HY000 (一般错误)    │
└─────────┴─────────────────┴─────────────────────┘
```

### 3.2 常用SQLSTATE状态码


```sql
-- 演示不同SQLSTATE的处理
DELIMITER //

CREATE PROCEDURE demo_sqlstate_handling(IN p_operation VARCHAR(20))
BEGIN
    DECLARE v_message VARCHAR(200);
    
    -- 处理约束违反
    DECLARE CONTINUE HANDLER FOR SQLSTATE '23000'
        SET v_message = '数据冲突：违反了唯一性约束或外键约束';
    
    -- 处理数据过长
    DECLARE CONTINUE HANDLER FOR SQLSTATE '22001'
        SET v_message = '数据错误：字符串数据被截断';
    
    -- 处理除零错误
    DECLARE CONTINUE HANDLER FOR SQLSTATE '22012'
        SET v_message = '计算错误：除数不能为零';
    
    -- 处理无数据
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000'
        SET v_message = '查询结果：没有找到匹配的数据';
    
    -- 根据参数模拟不同错误
    CASE p_operation
        WHEN 'duplicate' THEN
            INSERT INTO users (email) VALUES ('test@example.com');
        WHEN 'divide_zero' THEN
            SELECT 10/0 AS result;
        WHEN 'no_data' THEN
            SELECT username INTO @v FROM users WHERE user_id = 999999;
        WHEN 'too_long' THEN
            INSERT INTO users (username) VALUES ('这是一个超级超级长的用户名，肯定会超过字段长度限制');
    END CASE;
    
    SELECT IFNULL(v_message, '操作成功完成') AS operation_result;
    
END //

DELIMITER ;
```

### 3.3 MySQL特有错误号处理


```sql
DELIMITER //

CREATE PROCEDURE demo_mysql_error_numbers()
BEGIN
    DECLARE v_error_msg VARCHAR(200);
    
    -- 1062: 重复键错误
    DECLARE CONTINUE HANDLER FOR 1062
        SET v_error_msg = 'MySQL错误1062：尝试插入重复的主键或唯一键';
    
    -- 1146: 表不存在
    DECLARE CONTINUE HANDLER FOR 1146
        SET v_error_msg = 'MySQL错误1146：指定的表不存在';
    
    -- 1054: 未知列
    DECLARE CONTINUE HANDLER FOR 1054
        SET v_error_msg = 'MySQL错误1054：查询中包含未知的列名';
    
    -- 1452: 外键约束失败
    DECLARE CONTINUE HANDLER FOR 1452
        SET v_error_msg = 'MySQL错误1452：违反了外键约束条件';
    
    -- 模拟错误（这里故意查询不存在的列）
    SELECT non_existent_column FROM users LIMIT 1;
    
    SELECT v_error_msg AS mysql_specific_error;
    
END //

DELIMITER ;
```

---

## 4. 📝 错误日志与诊断


### 4.1 GET DIAGNOSTICS诊断信息


**核心概念**：获取最近执行语句的详细诊断信息，包括错误号、错误消息、影响行数等。

```sql
DELIMITER //

CREATE PROCEDURE demo_get_diagnostics()
BEGIN
    DECLARE v_errno INT;
    DECLARE v_msg TEXT;
    DECLARE v_rowcount INT;
    DECLARE v_state VARCHAR(5);
    
    -- 声明处理器获取诊断信息
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            v_errno = MYSQL_ERRNO,      -- MySQL错误号
            v_msg = MESSAGE_TEXT,       -- 错误消息
            v_state = RETURNED_SQLSTATE; -- SQLSTATE状态码
        
        -- 记录到错误日志表
        INSERT INTO error_log (error_time, error_code, error_message, sqlstate)
        VALUES (NOW(), v_errno, v_msg, v_state);
    END;
    
    -- 模拟错误操作
    INSERT INTO users (user_id, email) VALUES (1, 'duplicate@test.com');
    
    -- 获取语句级别的诊断信息
    GET DIAGNOSTICS v_rowcount = ROW_COUNT;
    
    SELECT 
        v_rowcount AS affected_rows,
        v_errno AS error_number,
        v_msg AS error_message,
        v_state AS sql_state;
        
END //

DELIMITER ;
```

### 4.2 构建错误日志系统


```sql
-- 创建错误日志表
CREATE TABLE IF NOT EXISTS sp_error_log (
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    procedure_name VARCHAR(100),
    error_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    error_code INT,
    error_message TEXT,
    sqlstate VARCHAR(5),
    user_data JSON,
    INDEX idx_procedure_time (procedure_name, error_time)
);

DELIMITER //

-- 通用错误记录过程
CREATE PROCEDURE log_error(
    IN p_procedure_name VARCHAR(100),
    IN p_user_data JSON
)
BEGIN
    DECLARE v_errno INT DEFAULT 0;
    DECLARE v_msg TEXT DEFAULT '';
    DECLARE v_state VARCHAR(5) DEFAULT '';
    
    -- 获取诊断信息
    GET DIAGNOSTICS CONDITION 1
        v_errno = MYSQL_ERRNO,
        v_msg = MESSAGE_TEXT,
        v_state = RETURNED_SQLSTATE;
    
    -- 记录错误日志
    INSERT INTO sp_error_log 
    (procedure_name, error_code, error_message, sqlstate, user_data)
    VALUES 
    (p_procedure_name, v_errno, v_msg, v_state, p_user_data);
    
END //

-- 使用错误日志的示例存储过程
CREATE PROCEDURE demo_with_error_logging(IN p_user_id INT)
BEGIN
    DECLARE v_user_data JSON;
    
    -- 统一异常处理器
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_user_data = JSON_OBJECT('user_id', p_user_id, 'operation', 'user_update');
        CALL log_error('demo_with_error_logging', v_user_data);
        SELECT 'ERROR: 操作失败，错误已记录' AS result;
    END;
    
    -- 业务逻辑
    UPDATE users SET last_login = NOW() WHERE user_id = p_user_id;
    
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户不存在';
    END IF;
    
    SELECT 'SUCCESS: 用户信息更新成功' AS result;
    
END //

DELIMITER ;
```

---

## 5. ⚡ 自定义异常管理


### 5.1 SIGNAL自定义异常


**核心概念**：主动抛出自定义异常，用于业务逻辑验证和错误提示。

```sql
DELIMITER //

CREATE PROCEDURE demo_custom_exceptions(
    IN p_user_id INT,
    IN p_amount DECIMAL(10,2)
)
BEGIN
    DECLARE v_balance DECIMAL(10,2);
    DECLARE v_status VARCHAR(20);
    
    -- 通用异常处理器
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;  -- 重新抛出异常，保持错误信息
    END;
    
    START TRANSACTION;
    
    -- 检查用户是否存在
    SELECT balance, status INTO v_balance, v_status 
    FROM user_accounts WHERE user_id = p_user_id;
    
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '用户账户不存在',
            MYSQL_ERRNO = 9001;
    END IF;
    
    -- 检查账户状态
    IF v_status != 'ACTIVE' THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '账户已被冻结，无法进行交易',
            MYSQL_ERRNO = 9002;
    END IF;
    
    -- 检查余额是否充足
    IF v_balance < p_amount THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = CONCAT('余额不足，当前余额：', v_balance, '，需要：', p_amount),
            MYSQL_ERRNO = 9003;
    END IF;
    
    -- 执行扣款
    UPDATE user_accounts 
    SET balance = balance - p_amount 
    WHERE user_id = p_user_id;
    
    COMMIT;
    SELECT 'SUCCESS: 扣款成功' AS result;
    
END //

DELIMITER ;
```

### 5.2 CONDITION条件定义


**核心概念**：为特定的错误条件定义一个有意义的名称，提高代码可读性。

```sql
DELIMITER //

CREATE PROCEDURE demo_named_conditions(IN p_email VARCHAR(100))
BEGIN
    -- 定义命名条件
    DECLARE duplicate_email CONDITION FOR SQLSTATE '23000';
    DECLARE invalid_email CONDITION FOR 1062;
    DECLARE user_not_found CONDITION FOR SQLSTATE '02000';
    
    DECLARE v_user_id INT;
    
    -- 使用命名条件的处理器
    DECLARE EXIT HANDLER FOR duplicate_email
    BEGIN
        SELECT 'ERROR: 邮箱地址已被其他用户使用' AS error_message;
    END;
    
    DECLARE CONTINUE HANDLER FOR user_not_found
    BEGIN
        SELECT 'WARNING: 未找到匹配的用户记录' AS warning_message;
    END;
    
    -- 邮箱格式验证
    IF p_email NOT REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '邮箱格式不正确';
    END IF;
    
    -- 查询用户
    SELECT user_id INTO v_user_id FROM users WHERE email = p_email;
    
    -- 更新用户信息
    UPDATE users SET last_access = NOW() WHERE user_id = v_user_id;
    
    SELECT CONCAT('用户ID ', v_user_id, ' 访问记录已更新') AS success_message;
    
END //

DELIMITER ;
```

### 5.3 RESIGNAL异常传播


**核心概念**：重新抛出捕获的异常，可以修改异常信息或保持原有信息。

```sql
DELIMITER //

-- 底层数据访问过程
CREATE PROCEDURE validate_user_data(
    IN p_user_id INT,
    IN p_email VARCHAR(100)
)
BEGIN
    DECLARE v_count INT;
    
    -- 检查用户ID是否存在
    SELECT COUNT(*) INTO v_count FROM users WHERE user_id = p_user_id;
    IF v_count = 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'validate_user_data: 用户ID不存在',
            MYSQL_ERRNO = 8001;
    END IF;
    
    -- 检查邮箱是否重复
    SELECT COUNT(*) INTO v_count 
    FROM users 
    WHERE email = p_email AND user_id != p_user_id;
    
    IF v_count > 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'validate_user_data: 邮箱地址已被使用',
            MYSQL_ERRNO = 8002;
    END IF;
    
END //

-- 上层业务逻辑过程
CREATE PROCEDURE update_user_profile(
    IN p_user_id INT,
    IN p_email VARCHAR(100),
    IN p_username VARCHAR(50)
)
BEGIN
    -- 捕获底层异常并重新包装
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            @error_code = MYSQL_ERRNO,
            @error_msg = MESSAGE_TEXT;
        
        -- 根据错误码提供用户友好的信息
        CASE @error_code
            WHEN 8001 THEN
                RESIGNAL SET MESSAGE_TEXT = '更新失败：用户不存在，请检查用户ID';
            WHEN 8002 THEN
                RESIGNAL SET MESSAGE_TEXT = '更新失败：邮箱已被其他用户使用，请更换邮箱';
            ELSE
                RESIGNAL SET MESSAGE_TEXT = CONCAT('更新失败：系统错误 (', @error_msg, ')');
        END CASE;
    END;
    
    -- 调用验证过程
    CALL validate_user_data(p_user_id, p_email);
    
    -- 更新用户信息
    UPDATE users 
    SET email = p_email, username = p_username, updated_at = NOW()
    WHERE user_id = p_user_id;
    
    SELECT 'SUCCESS: 用户信息更新成功' AS result;
    
END //

DELIMITER ;
```

---

## 6. 🔧 高级错误处理技巧


### 6.1 错误堆栈跟踪实现


**核心概念**：记录异常的调用链路，便于调试复杂的存储过程调用关系。

```sql
-- 创建调用堆栈表
CREATE TABLE IF NOT EXISTS call_stack (
    stack_id INT AUTO_INCREMENT PRIMARY KEY,
    session_id VARCHAR(36),
    procedure_name VARCHAR(100),
    call_level INT,
    call_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    parameters JSON,
    status ENUM('ENTER', 'EXIT', 'ERROR') DEFAULT 'ENTER'
);

DELIMITER //

-- 堆栈跟踪辅助过程
CREATE PROCEDURE push_call_stack(
    IN p_procedure_name VARCHAR(100),
    IN p_parameters JSON
)
BEGIN
    DECLARE v_session_id VARCHAR(36);
    DECLARE v_call_level INT DEFAULT 1;
    
    -- 获取或生成会话ID
    SELECT @session_id INTO v_session_id;
    IF v_session_id IS NULL THEN
        SET v_session_id = UUID();
        SET @session_id = v_session_id;
    END IF;
    
    -- 计算调用层级
    SELECT IFNULL(MAX(call_level), 0) + 1 INTO v_call_level
    FROM call_stack 
    WHERE session_id = v_session_id AND status = 'ENTER';
    
    -- 记录进入
    INSERT INTO call_stack (session_id, procedure_name, call_level, parameters, status)
    VALUES (v_session_id, p_procedure_name, v_call_level, p_parameters, 'ENTER');
    
END //

CREATE PROCEDURE pop_call_stack(
    IN p_procedure_name VARCHAR(100),
    IN p_status ENUM('EXIT', 'ERROR')
)
BEGIN
    UPDATE call_stack 
    SET status = p_status
    WHERE session_id = @session_id 
      AND procedure_name = p_procedure_name 
      AND status = 'ENTER'
    ORDER BY call_time DESC 
    LIMIT 1;
END //

-- 带堆栈跟踪的业务过程示例
CREATE PROCEDURE process_order_with_stack(IN p_order_id INT)
BEGIN
    DECLARE v_params JSON;
    
    SET v_params = JSON_OBJECT('order_id', p_order_id);
    CALL push_call_stack('process_order_with_stack', v_params);
    
    -- 统一异常处理器
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        CALL pop_call_stack('process_order_with_stack', 'ERROR');
        
        -- 输出错误堆栈
        SELECT 
            procedure_name,
            call_level,
            parameters,
            call_time,
            status
        FROM call_stack 
        WHERE session_id = @session_id
        ORDER BY call_time;
        
        RESIGNAL;
    END;
    
    -- 调用其他过程
    CALL validate_order_with_stack(p_order_id);
    CALL calculate_order_total_with_stack(p_order_id);
    
    CALL pop_call_stack('process_order_with_stack', 'EXIT');
    SELECT 'ORDER: 订单处理完成' AS result;
    
END //

DELIMITER ;
```

### 6.2 事务错误处理最佳实践


```sql
DELIMITER //

CREATE PROCEDURE safe_transfer_money(
    IN p_from_account INT,
    IN p_to_account INT,
    IN p_amount DECIMAL(10,2)
)
BEGIN
    DECLARE v_rollback_flag BOOLEAN DEFAULT FALSE;
    DECLARE v_savepoint_name VARCHAR(20) DEFAULT 'transfer_sp';
    
    -- 声明异常处理器
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 获取错误信息
        GET DIAGNOSTICS CONDITION 1
            @error_code = MYSQL_ERRNO,
            @error_msg = MESSAGE_TEXT,
            @sql_state = RETURNED_SQLSTATE;
        
        -- 回滚到保存点或完全回滚
        IF v_rollback_flag THEN
            ROLLBACK TO SAVEPOINT transfer_sp;
        ELSE
            ROLLBACK;
        END IF;
        
        -- 记录错误日志
        INSERT INTO transfer_log 
        (from_account, to_account, amount, status, error_message, created_at)
        VALUES 
        (p_from_account, p_to_account, p_amount, 'FAILED', @error_msg, NOW());
        
        -- 返回错误信息
        SELECT 
            'TRANSFER_FAILED' AS status,
            @error_code AS error_code,
            @error_msg AS error_message;
    END;
    
    -- 开始事务
    START TRANSACTION;
    
    -- 创建保存点
    SAVEPOINT transfer_sp;
    SET v_rollback_flag = TRUE;
    
    -- 参数验证
    IF p_amount <= 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '转账金额必须大于0';
    END IF;
    
    IF p_from_account = p_to_account THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '不能向同一账户转账';
    END IF;
    
    -- 扣款操作
    UPDATE accounts 
    SET balance = balance - p_amount 
    WHERE account_id = p_from_account AND balance >= p_amount;
    
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '源账户余额不足或账户不存在';
    END IF;
    
    -- 入账操作
    UPDATE accounts 
    SET balance = balance + p_amount 
    WHERE account_id = p_to_account;
    
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '目标账户不存在';
    END IF;
    
    -- 记录转账日志
    INSERT INTO transfer_log 
    (from_account, to_account, amount, status, created_at)
    VALUES 
    (p_from_account, p_to_account, p_amount, 'SUCCESS', NOW());
    
    -- 提交事务
    COMMIT;
    
    SELECT 
        'TRANSFER_SUCCESS' AS status,
        '转账成功完成' AS message,
        p_amount AS amount;
        
END //

DELIMITER ;
```

### 6.3 嵌套异常处理


```sql
DELIMITER //

CREATE PROCEDURE nested_error_handling_demo(IN p_user_id INT)
BEGIN
    DECLARE v_level1_error BOOLEAN DEFAULT FALSE;
    
    -- 外层异常处理器
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SELECT 'Level 1: 外层捕获到异常' AS handler_level;
        RESIGNAL;  -- 重新抛出给更外层
    END;
    
    -- 内层代码块
    main_block: BEGIN
        DECLARE v_username VARCHAR(50);
        
        -- 内层异常处理器
        DECLARE CONTINUE HANDLER FOR NOT FOUND
        BEGIN
            SET v_level1_error = TRUE;
            SELECT 'Level 2: 内层处理NOT FOUND异常' AS handler_level;
        END;
        
        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        BEGIN
            SELECT 'Level 2: 内层处理SQL异常' AS handler_level;
            -- 不使用RESIGNAL，异常在此处被消化
        END;
        
        -- 模拟查询不存在的用户
        SELECT username INTO v_username FROM users WHERE user_id = p_user_id;
        
        IF v_level1_error THEN
            SELECT 'Level 2: 用户不存在，进行默认处理' AS result;
            LEAVE main_block;  -- 退出内层块
        END IF;
        
        SELECT CONCAT('用户名: ', v_username) AS result;
        
    END main_block;
    
    SELECT 'Level 1: 主程序执行完成' AS completion_status;
    
END //

DELIMITER ;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 错误处理器类型：CONTINUE（继续）、EXIT（退出）、UNDO（撤销）
🔸 SQLSTATE系统：5位状态码，表示不同类别的错误和警告
🔸 处理器优先级：具体SQLSTATE > 具体错误号 > 命名条件 > 通用条件
🔸 诊断信息：GET DIAGNOSTICS获取详细的错误信息
🔸 自定义异常：SIGNAL抛出、RESIGNAL传播、CONDITION命名
```

### 7.2 关键理解要点


**🔹 处理器选择策略**
```
CONTINUE HANDLER：
• 用于：可恢复的错误，如数据不存在
• 场景：批量处理中的个别失败项
• 特点：继续执行后续代码

EXIT HANDLER：
• 用于：严重错误，需要中断执行
• 场景：参数验证失败、权限不足
• 特点：立即退出当前程序块

选择原则：
• 业务可继续 → 使用CONTINUE
• 必须中断 → 使用EXIT
```

**🔹 错误信息设计原则**
```
技术错误 vs 业务错误：
• 技术错误：记录详细信息供开发者调试
• 业务错误：提供友好提示给最终用户

信息层次：
• 系统日志：完整的错误堆栈和技术细节
• 用户提示：简洁清晰的问题说明和解决建议
• 监控告警：关键错误的实时通知
```

**🔹 事务与错误处理的配合**
```
基本原则：
• 异常发生时必须明确事务状态
• 使用ROLLBACK保证数据一致性
• 合理使用SAVEPOINT支持部分回滚

最佳实践：
• START TRANSACTION后立即设置错误处理器
• 在处理器中明确回滚策略
• 记录操作日志便于追踪问题
```

### 7.3 实际应用价值


**💼 企业级应用场景**
- **金融系统**：转账、支付等关键操作的安全处理
- **电商平台**：订单处理、库存管理的异常控制
- **用户系统**：注册、登录、权限验证的错误处理
- **数据迁移**：大批量数据处理的容错机制

**🔧 开发运维实践**
- **调试支持**：详细的错误日志和调用链跟踪
- **监控告警**：关键异常的实时通知和统计
- **用户体验**：友好的错误提示和处理建议
- **系统稳定性**：优雅的错误恢复和服务降级

### 7.4 学习建议


**📚 学习路径**
```
基础阶段：理解错误处理器的基本语法和使用场景
进阶阶段：掌握SQLSTATE系统和自定义异常机制
高级阶段：实现完整的错误日志和监控体系
实战应用：在真实项目中建立错误处理规范
```

**⚡ 实践要点**
- 从简单的CONTINUE/EXIT处理器开始练习
- 逐步学习SIGNAL/RESIGNAL的高级用法
- 建立项目级别的错误处理规范和模板
- 重视错误日志的设计和维护

**核心记忆**：
- 错误处理是存储过程健壮性的基础保障
- 合理的异常处理能显著提升用户体验
- 详细的错误日志是快速定位问题的关键
- 异常处理器的优先级和作用域需要仔细设计