---
title: 9、存储过程性能优化
---
## 📚 目录

1. [存储过程性能优化概述](#1-存储过程性能优化概述)
2. [执行计划分析与优化](#2-执行计划分析与优化)
3. [缓存机制利用](#3-缓存机制利用)
4. [批量操作优化](#4-批量操作优化)
5. [索引使用策略](#5-索引使用策略)
6. [临时表与内存优化](#6-临时表与内存优化)
7. [性能监控与诊断](#7-性能监控与诊断)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 存储过程性能优化概述


### 1.1 什么是存储过程性能优化


**简单理解**：存储过程性能优化就是让存储过程跑得更快、占用资源更少、响应更及时。

```
普通存储过程：
用户请求 → 存储过程执行 → 慢慢处理 → 10秒后返回结果

优化后存储过程：
用户请求 → 存储过程执行 → 快速处理 → 1秒内返回结果
```

### 1.2 为什么需要优化


**核心问题**：
- **响应慢**：用户等待时间过长
- **资源消耗大**：占用大量CPU和内存
- **并发能力差**：多用户同时访问时性能急剧下降
- **数据库压力大**：影响整个数据库系统的稳定性

### 1.3 优化的基本思路


```
优化金字塔：
┌─────────────────────────┐
│     业务逻辑优化         │ ← 最高层：算法和逻辑
├─────────────────────────┤
│     SQL语句优化         │ ← 中间层：查询语句
├─────────────────────────┤
│     缓存和索引优化       │ ← 底层：数据结构
└─────────────────────────┘
```

---

## 2. 📊 执行计划分析与优化


### 2.1 什么是执行计划


**通俗解释**：执行计划就像是MySQL给每个SQL语句制定的"工作方案"，告诉数据库引擎如何最有效地执行这个查询。

```sql
-- 查看存储过程中SQL的执行计划
EXPLAIN SELECT * FROM users WHERE age > 25 AND city = '北京';
```

### 2.2 如何分析执行计划


**关键指标解读**：

| 字段 | **含义** | **好的值** | **需要优化的值** |
|------|---------|-----------|----------------|
| `type` | 访问类型 | `const`, `eq_ref` | `ALL`, `range` |
| `key` | 使用的索引 | 有具体索引名 | `NULL`（没用索引） |
| `rows` | 预计扫描行数 | 越小越好 | 几万、几十万 |
| `Extra` | 额外信息 | `Using index` | `Using filesort` |

### 2.3 执行计划优化实例


**优化前的问题查询**：
```sql
-- 存储过程中的慢查询
SELECT u.name, o.total 
FROM users u, orders o 
WHERE u.id = o.user_id 
  AND u.city = '上海' 
  AND o.create_time > '2024-01-01';
```

**执行计划分析**：
```
+----+-------+-------+------+-------+------+---------+
| id | table | type  | key  | rows  | Extra            |
+----+-------+-------+------+-------+------+---------+
| 1  | users | ALL   | NULL | 50000 | Using where      |
| 1  | orders| ALL   | NULL | 80000 | Using where      |
+----+-------+-------+------+-------+------+---------+
问题：两个表都是全表扫描，效率极低
```

**优化后的查询**：
```sql
-- 使用JOIN语法，添加合适索引
SELECT u.name, o.total 
FROM users u 
INNER JOIN orders o ON u.id = o.user_id 
WHERE u.city = '上海' 
  AND o.create_time > '2024-01-01';

-- 需要的索引
CREATE INDEX idx_users_city ON users(city);
CREATE INDEX idx_orders_time_user ON orders(create_time, user_id);
```

---

## 3. 💾 缓存机制利用


### 3.1 存储过程缓存机制


**MySQL存储过程缓存工作原理**：

```
第一次执行：
解析存储过程 → 编译 → 生成执行计划 → 缓存 → 执行

后续执行：
直接从缓存取执行计划 → 执行（跳过解析和编译）
```

### 3.2 查询结果缓存优化


**MySQL查询缓存机制**：
```sql
-- 检查查询缓存状态
SHOW VARIABLES LIKE 'query_cache%';

-- 查看缓存命中率
SHOW STATUS LIKE 'Qcache%';
```

### 3.3 应用层缓存策略


**在存储过程中使用内存表做缓存**：
```sql
DELIMITER $$
CREATE PROCEDURE GetUserInfo(IN user_id INT)
BEGIN
    -- 检查内存表缓存
    DECLARE cached_count INT DEFAULT 0;
    
    SELECT COUNT(*) INTO cached_count 
    FROM user_cache_memory 
    WHERE id = user_id AND update_time > DATE_SUB(NOW(), INTERVAL 5 MINUTE);
    
    IF cached_count > 0 THEN
        -- 从缓存返回
        SELECT name, email FROM user_cache_memory WHERE id = user_id;
    ELSE
        -- 从主表查询并更新缓存
        SELECT name, email FROM users WHERE id = user_id;
        
        -- 更新缓存（简化逻辑）
        REPLACE INTO user_cache_memory (id, name, email, update_time) 
        SELECT id, name, email, NOW() FROM users WHERE id = user_id;
    END IF;
END$$
DELIMITER ;
```

---

## 4. ⚡ 批量操作优化


### 4.1 批量vs逐行处理对比


**问题场景**：需要处理10000条用户数据

**逐行处理（效率低）**：
```sql
-- 效率低的写法
DELIMITER $$
CREATE PROCEDURE UpdateUsersOneByOne()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE user_id INT;
    DECLARE user_cursor CURSOR FOR SELECT id FROM users WHERE status = 'pending';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN user_cursor;
    
    user_loop: LOOP
        FETCH user_cursor INTO user_id;
        IF done THEN LEAVE user_loop; END IF;
        
        -- 逐行更新，每次都是一个事务
        UPDATE users SET status = 'processed' WHERE id = user_id;
    END LOOP;
    
    CLOSE user_cursor;
END$$
```

**批量处理（效率高）**：
```sql
-- 效率高的写法
DELIMITER $$
CREATE PROCEDURE UpdateUsersBatch()
BEGIN
    -- 一次性批量更新
    UPDATE users 
    SET status = 'processed', 
        update_time = NOW() 
    WHERE status = 'pending';
    
    -- 获取影响行数
    SELECT ROW_COUNT() as affected_rows;
END$$
```

**性能对比**：
```
逐行处理：10000次 × 每次5ms = 50秒
批量处理：1次 × 200ms = 0.2秒
性能提升：250倍！
```

### 4.2 批量插入优化


**优化前（慢）**：
```sql
-- 一条条插入
INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 100, 2);
INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 101, 1);
INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 102, 3);
```

**优化后（快）**：
```sql
-- 批量插入
INSERT INTO order_items (order_id, product_id, quantity) VALUES 
(1, 100, 2), 
(1, 101, 1), 
(1, 102, 3);

-- 或者使用INSERT ... SELECT
INSERT INTO order_items_backup 
SELECT * FROM order_items WHERE order_id = 1;
```

---

## 5. 🔍 索引使用策略


### 5.1 索引基础概念


**什么是索引**：索引就像书的目录，能快速找到数据位置，而不用翻遍整本书。

```
没有索引：
查找用户"张三" → 从第1条开始，逐条对比 → 可能要查10万条

有索引：
查找用户"张三" → 查索引目录 → 直接定位到第8890条
```

### 5.2 存储过程中的索引优化


**复合索引使用技巧**：
```sql
-- 创建复合索引
CREATE INDEX idx_user_city_age ON users(city, age, create_time);

-- 存储过程中高效使用索引
DELIMITER $$
CREATE PROCEDURE GetUsersByCondition(
    IN p_city VARCHAR(50),
    IN p_min_age INT,
    IN p_start_date DATE
)
BEGIN
    -- 利用复合索引，按索引顺序查询
    SELECT id, name, email 
    FROM users 
    WHERE city = p_city           -- 索引第一列
      AND age >= p_min_age        -- 索引第二列
      AND create_time >= p_start_date  -- 索引第三列
    LIMIT 100;
END$$
```

### 5.3 避免索引失效


**常见索引失效情况**：

| **写法** | **是否用索引** | **说明** |
|---------|---------------|---------|
| `WHERE name = '张三'` | ✅ 使用 | 精确匹配 |
| `WHERE name LIKE '张%'` | ✅ 使用 | 前缀匹配 |
| `WHERE name LIKE '%张%'` | ❌ 不使用 | 包含查询 |
| `WHERE age + 1 = 26` | ❌ 不使用 | 字段有计算 |
| `WHERE age = 25` | ✅ 使用 | 直接比较 |

```sql
-- 存储过程中避免索引失效
DELIMITER $$
CREATE PROCEDURE SearchUsers(IN keyword VARCHAR(100))
BEGIN
    -- 错误写法：索引失效
    -- SELECT * FROM users WHERE UPPER(name) = UPPER(keyword);
    
    -- 正确写法：保持索引有效
    SELECT * FROM users WHERE name = keyword;
    
    -- 如果需要不区分大小写，建议创建函数索引或使用COLLATE
END$$
```

---

## 6. 💻 临时表与内存优化


### 6.1 临时表优化策略


**什么时候使用临时表**：
- 需要多次查询中间结果
- 复杂计算需要存储中间数据
- 大表JOIN时先过滤数据

**临时表类型对比**：

| **类型** | **存储位置** | **速度** | **适用场景** |
|---------|-------------|---------|-------------|
| 内存临时表 | 内存 | 最快 | 数据量小(<16MB) |
| 磁盘临时表 | 磁盘 | 较慢 | 数据量大 |
| 手动创建临时表 | 可控制 | 可优化 | 复杂逻辑 |

### 6.2 临时表实际应用


```sql
DELIMITER $$
CREATE PROCEDURE AnalyzeUserOrders(IN p_year INT)
BEGIN
    -- 创建临时表存储中间结果
    CREATE TEMPORARY TABLE temp_user_stats (
        user_id INT,
        order_count INT,
        total_amount DECIMAL(10,2),
        INDEX idx_user(user_id)
    ) ENGINE=MEMORY;
    
    -- 第一步：统计每个用户的订单信息
    INSERT INTO temp_user_stats
    SELECT 
        user_id,
        COUNT(*) as order_count,
        SUM(total_amount) as total_amount
    FROM orders 
    WHERE YEAR(create_time) = p_year
    GROUP BY user_id;
    
    -- 第二步：关联用户信息，获取最终结果
    SELECT 
        u.name,
        u.email,
        t.order_count,
        t.total_amount,
        CASE 
            WHEN t.total_amount > 10000 THEN 'VIP'
            WHEN t.total_amount > 5000 THEN '金牌'
            ELSE '普通'
        END as user_level
    FROM users u
    INNER JOIN temp_user_stats t ON u.id = t.user_id
    ORDER BY t.total_amount DESC;
    
    -- 临时表会自动清理
END$$
```

### 6.3 内存使用控制


**监控内存使用**：
```sql
-- 查看MySQL内存相关参数
SHOW VARIABLES LIKE '%tmp%';
SHOW VARIABLES LIKE '%heap%';

-- 在存储过程中控制内存使用
DELIMITER $$
CREATE PROCEDURE ProcessLargeData()
BEGIN
    DECLARE total_rows INT;
    DECLARE batch_size INT DEFAULT 1000;
    DECLARE current_offset INT DEFAULT 0;
    
    -- 获取总行数
    SELECT COUNT(*) INTO total_rows FROM large_table WHERE status = 'pending';
    
    -- 分批处理，避免内存溢出
    WHILE current_offset < total_rows DO
        UPDATE large_table 
        SET status = 'processed' 
        WHERE status = 'pending' 
        LIMIT batch_size;
        
        SET current_offset = current_offset + batch_size;
        
        -- 强制提交，释放内存
        COMMIT;
    END WHILE;
END$$
```

---

## 7. 📈 性能监控与诊断


### 7.1 性能监控指标


**关键性能指标**：

```sql
-- 查看存储过程执行统计
SELECT 
    OBJECT_SCHEMA as db_name,
    OBJECT_NAME as procedure_name,
    COUNT_STAR as exec_count,
    SUM_TIMER_WAIT/1000000000 as total_time_sec,
    AVG_TIMER_WAIT/1000000000 as avg_time_sec
FROM performance_schema.events_statements_summary_by_digest 
WHERE OBJECT_TYPE = 'PROCEDURE'
ORDER BY AVG_TIMER_WAIT DESC;
```

### 7.2 慢查询日志分析


**开启慢查询日志**：
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录到慢查询日志

-- 查看慢查询统计
SHOW STATUS LIKE 'Slow_queries';
```

### 7.3 实时性能诊断


```sql
-- 查看当前正在执行的存储过程
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE INFO LIKE '%CALL%' OR COMMAND = 'Query';

-- 查看锁等待情况
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的优化原则


```
🔸 批量优于逐行：能批量处理就不要一条条处理
🔸 索引是关键：合理使用索引能提升几十倍性能
🔸 缓存很重要：充分利用MySQL的各种缓存机制
🔸 监控不可少：定期监控性能指标，及时发现问题
🔸 临时表有技巧：选择合适的临时表类型和引擎
```

### 8.2 性能优化检查清单


**优化前检查**：
- [ ] 分析执行计划，找出全表扫描
- [ ] 检查是否缺少必要的索引
- [ ] 确认是否有不必要的逐行处理
- [ ] 查看是否有大量临时表创建

**优化后验证**：
- [ ] 执行时间是否明显改善
- [ ] CPU和内存使用是否下降
- [ ] 并发处理能力是否提升
- [ ] 慢查询日志是否减少

### 8.3 常见性能问题解决方案


**问题1：存储过程执行很慢**
```
排查步骤：
1. 查看执行计划 → 找出慢的SQL
2. 检查索引使用 → 添加缺失索引
3. 优化SQL逻辑 → 避免复杂嵌套查询
```

**问题2：并发时性能急剧下降**
```
解决方案：
1. 减少锁竞争 → 缩短事务时间
2. 读写分离 → 查询走从库
3. 连接池优化 → 控制并发连接数
```

**问题3：内存使用过高**
```
优化方法：
1. 分批处理大数据
2. 及时释放临时表
3. 控制查询结果集大小
```

### 8.4 最佳实践建议


> 💡 **性能优化金律**：
> - 先测量，后优化（不要盲目优化）
> - 抓主要矛盾（优化最慢的部分）
> - 权衡复杂度与性能收益
> - 持续监控和调优

> ⚠️ **常见误区**：
> - 过度索引：索引不是越多越好
> - 忽略业务逻辑：不能为了性能牺牲数据准确性
> - 一次性优化：性能优化是持续过程

**核心记忆口诀**：
- 执行计划看得清，索引使用要合理
- 批量处理效率高，缓存机制要善用
- 临时表选对型，内存控制别超标
- 监控诊断不能停，性能优化无止境