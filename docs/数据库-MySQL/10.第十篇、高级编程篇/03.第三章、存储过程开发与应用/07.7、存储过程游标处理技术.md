---
title: 7、存储过程游标处理技术
---
## 📚 目录

1. [存储过程游标基础概念](#1-存储过程游标基础概念)
2. [游标声明与使用](#2-游标声明与使用)
3. [存储过程中的游标最佳实践](#3-存储过程中的游标最佳实践)
4. [游标异常处理技术](#4-游标异常处理技术)
5. [游标性能优化策略](#5-游标性能优化策略)
6. [游标与事务交互机制](#6-游标与事务交互机制)
7. [游标内存管理实现](#7-游标内存管理实现)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 存储过程游标基础概念


### 1.1 什么是存储过程游标


**简单理解**：游标就像是数据库结果集的"指针"，让你能够逐行处理查询结果。

```
通俗类比：
游标 = 书签 📖
- 标记当前读到哪一行
- 可以向前翻页（下一行）
- 可以重新定位到开始
- 处理完后要关闭书本（释放资源）
```

**🔸 核心概念**
```
游标的本质：
• 结果集的迭代器：逐行访问SELECT查询的结果
• 内存中的临时数据结构：存储查询结果
• 有状态的对象：记住当前处理位置
• 资源管理器：需要显式打开和关闭
```

### 1.2 存储过程游标 vs 独立游标


**📊 对比分析**：

| 特性 | **存储过程游标** | **独立游标** |
|------|-----------------|-------------|
| 🏃‍♂️ **性能** | 更快，减少网络传输 | 较慢，每次都要传输数据 |
| 🔒 **事务控制** | 与存储过程事务集成 | 独立的事务边界 |
| 💾 **内存管理** | 统一管理，更高效 | 分散管理，开销大 |
| 🛠️ **复用性** | 高，封装在存储过程中 | 低，需要重复编写 |
| 🔧 **维护性** | 集中维护，版本统一 | 分散在应用代码中 |

---

## 2. 🔧 游标声明与使用


### 2.1 游标生命周期


**🔄 完整生命周期**：
```
声明(DECLARE) → 打开(OPEN) → 提取(FETCH) → 关闭(CLOSE)
```

### 2.2 基本语法结构


**📝 完整示例**：
```sql
DELIMITER //
CREATE PROCEDURE demo_cursor_basic()
BEGIN
    -- 1. 声明变量
    DECLARE done INT DEFAULT FALSE;
    DECLARE emp_id INT;
    DECLARE emp_name VARCHAR(100);
    DECLARE emp_salary DECIMAL(10,2);
    
    -- 2. 声明游标
    DECLARE emp_cursor CURSOR FOR
        SELECT employee_id, name, salary 
        FROM employees 
        WHERE salary > 5000;
    
    -- 3. 声明异常处理
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 4. 打开游标
    OPEN emp_cursor;
    
    -- 5. 循环处理
    read_loop: LOOP
        FETCH emp_cursor INTO emp_id, emp_name, emp_salary;
        
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 业务逻辑处理
        SELECT CONCAT('员工：', emp_name, '，工资：', emp_salary);
        
    END LOOP;
    
    -- 6. 关闭游标
    CLOSE emp_cursor;
END //
DELIMITER ;
```

### 2.3 游标声明的关键要点


**💡 声明顺序很重要**：
```sql
-- ❌ 错误顺序
DECLARE emp_cursor CURSOR FOR SELECT ...;  -- 游标
DECLARE emp_id INT;                        -- 变量

-- ✅ 正确顺序  
DECLARE emp_id INT;                        -- 1. 先声明变量
DECLARE emp_cursor CURSOR FOR SELECT ...;  -- 2. 再声明游标
DECLARE CONTINUE HANDLER ...;              -- 3. 最后声明异常处理
```

**🔑 为什么要这个顺序？**
- MySQL要求变量必须在游标之前声明
- 异常处理器必须在最后声明
- 违反顺序会导致语法错误

---

## 3. 🚀 存储过程中的游标最佳实践


### 3.1 实用的游标处理模式


**🎯 模式一：批量数据处理**
```sql
DELIMITER //
CREATE PROCEDURE process_large_dataset()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    DECLARE processed_count INT DEFAULT 0;
    
    DECLARE order_id INT;
    DECLARE order_amount DECIMAL(10,2);
    
    -- 声明游标：处理大量订单数据
    DECLARE order_cursor CURSOR FOR
        SELECT id, total_amount 
        FROM orders 
        WHERE status = 'pending'
        ORDER BY created_at;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 开始事务
    START TRANSACTION;
    
    OPEN order_cursor;
    
    process_loop: LOOP
        FETCH order_cursor INTO order_id, order_amount;
        
        IF done THEN
            LEAVE process_loop;
        END IF;
        
        -- 业务逻辑：更新订单状态
        UPDATE orders 
        SET status = 'processed', 
            processed_at = NOW() 
        WHERE id = order_id;
        
        SET processed_count = processed_count + 1;
        
        -- 每处理1000条就提交一次
        IF processed_count MOD batch_size = 0 THEN
            COMMIT;
            START TRANSACTION;
        END IF;
        
    END LOOP;
    
    CLOSE order_cursor;
    COMMIT; -- 提交剩余的数据
    
    SELECT CONCAT('共处理了 ', processed_count, ' 条记录') AS result;
END //
DELIMITER ;
```

**🎯 模式二：数据聚合统计**
```sql
DELIMITER //
CREATE PROCEDURE calculate_monthly_summary()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE dept_id INT;
    DECLARE dept_name VARCHAR(100);
    DECLARE total_salary DECIMAL(15,2) DEFAULT 0;
    
    -- 按部门统计工资
    DECLARE dept_cursor CURSOR FOR
        SELECT department_id, department_name 
        FROM departments 
        WHERE is_active = 1;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 创建临时结果表
    CREATE TEMPORARY TABLE temp_dept_summary (
        dept_id INT,
        dept_name VARCHAR(100),
        total_salary DECIMAL(15,2),
        avg_salary DECIMAL(10,2),
        emp_count INT
    );
    
    OPEN dept_cursor;
    
    dept_loop: LOOP
        FETCH dept_cursor INTO dept_id, dept_name;
        
        IF done THEN
            LEAVE dept_loop;
        END IF;
        
        -- 计算部门统计数据
        SELECT 
            SUM(salary), 
            AVG(salary), 
            COUNT(*)
        INTO 
            @total_sal, 
            @avg_sal, 
            @emp_cnt
        FROM employees 
        WHERE department_id = dept_id;
        
        -- 插入统计结果
        INSERT INTO temp_dept_summary 
        VALUES (dept_id, dept_name, @total_sal, @avg_sal, @emp_cnt);
        
    END LOOP;
    
    CLOSE dept_cursor;
    
    -- 返回统计结果
    SELECT * FROM temp_dept_summary ORDER BY total_salary DESC;
    
    DROP TEMPORARY TABLE temp_dept_summary;
END //
DELIMITER ;
```

### 3.2 游标参数化技术


**💡 让游标更灵活**：
```sql
DELIMITER //
CREATE PROCEDURE flexible_employee_processor(
    IN min_salary DECIMAL(10,2),
    IN dept_filter VARCHAR(100)
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE emp_id INT;
    DECLARE emp_name VARCHAR(100);
    
    -- 动态构建的查询条件
    DECLARE sql_text TEXT DEFAULT '';
    
    SET sql_text = CONCAT(
        'SELECT employee_id, name FROM employees WHERE salary >= ', 
        min_salary
    );
    
    IF dept_filter IS NOT NULL THEN
        SET sql_text = CONCAT(sql_text, ' AND department = "', dept_filter, '"');
    END IF;
    
    -- 注意：MySQL不直接支持动态游标，这里展示概念
    -- 实际应用中需要使用准备语句的替代方案
    
END //
DELIMITER ;
```

---

## 4. ⚠️ 游标异常处理技术


### 4.1 异常处理的重要性


**🚨 常见问题**：
```
没有异常处理的后果：
• 游标没有正确关闭 → 内存泄漏
• 事务没有回滚 → 数据不一致
• 错误信息不明确 → 调试困难
• 程序异常终止 → 用户体验差
```

### 4.2 完善的异常处理示例


**🛡️ 健壮的异常处理**：
```sql
DELIMITER //
CREATE PROCEDURE robust_cursor_processing()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE error_occurred INT DEFAULT FALSE;
    DECLARE error_msg TEXT DEFAULT '';
    
    DECLARE emp_id INT;
    DECLARE emp_salary DECIMAL(10,2);
    
    DECLARE emp_cursor CURSOR FOR
        SELECT employee_id, salary FROM employees;
    
    -- 多种异常处理器
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET error_occurred = TRUE;
        GET DIAGNOSTICS CONDITION 1
            error_msg = MESSAGE_TEXT;
        ROLLBACK;
    END;
    
    DECLARE CONTINUE HANDLER FOR SQLWARNING
    BEGIN
        -- 记录警告信息
        INSERT INTO error_log (level, message, created_at)
        VALUES ('WARNING', 'Cursor processing warning', NOW());
    END;
    
    -- 开始处理
    START TRANSACTION;
    
    OPEN emp_cursor;
    
    IF error_occurred THEN
        SELECT CONCAT('打开游标失败：', error_msg) AS error_result;
        LEAVE robust_cursor_processing;
    END IF;
    
    process_loop: LOOP
        FETCH emp_cursor INTO emp_id, emp_salary;
        
        IF done THEN
            LEAVE process_loop;
        END IF;
        
        IF error_occurred THEN
            CLOSE emp_cursor;
            SELECT CONCAT('处理过程中出错：', error_msg) AS error_result;
            LEAVE robust_cursor_processing;
        END IF;
        
        -- 业务逻辑处理
        UPDATE employees 
        SET processed = 1 
        WHERE employee_id = emp_id;
        
    END LOOP;
    
    CLOSE emp_cursor;
    
    IF error_occurred THEN
        ROLLBACK;
        SELECT '处理失败，已回滚' AS result;
    ELSE
        COMMIT;
        SELECT '处理成功' AS result;
    END IF;
    
END //
DELIMITER ;
```

### 4.3 错误日志记录系统


**📝 建立错误追踪机制**：
```sql
-- 创建错误日志表
CREATE TABLE cursor_error_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    procedure_name VARCHAR(100),
    error_type ENUM('SQLEXCEPTION', 'SQLWARNING', 'NOT_FOUND'),
    error_message TEXT,
    sql_state VARCHAR(5),
    error_code INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DELIMITER //
CREATE PROCEDURE log_cursor_errors()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE current_procedure VARCHAR(100) DEFAULT 'log_cursor_errors';
    
    DECLARE emp_cursor CURSOR FOR SELECT * FROM non_existent_table;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            @error_msg = MESSAGE_TEXT,
            @sql_state = RETURNED_SQLSTATE,
            @error_code = MYSQL_ERRNO;
            
        INSERT INTO cursor_error_log 
        (procedure_name, error_type, error_message, sql_state, error_code)
        VALUES 
        (current_procedure, 'SQLEXCEPTION', @error_msg, @sql_state, @error_code);
    END;
    
    OPEN emp_cursor;
    -- 其他处理逻辑...
    CLOSE emp_cursor;
END //
DELIMITER ;
```

---

## 5. ⚡ 游标性能优化策略


### 5.1 性能对比分析


**📊 游标 vs 集合操作性能**：

| 操作类型 | **游标方式** | **集合操作** | **性能差异** |
|----------|-------------|-------------|-------------|
| 🔄 **简单更新** | 1000条/秒 | 10000条/秒 | 集合操作快10倍 |
| 📊 **复杂计算** | 500条/秒 | 2000条/秒 | 集合操作快4倍 |
| 💾 **内存使用** | 高（逐行处理） | 低（批量处理） | 游标占用更多内存 |
| 🔒 **锁定时间** | 长（逐行锁定） | 短（批量锁定） | 游标锁定时间更长 |

### 5.2 游标优化技巧


**🎯 优化策略一：减少游标使用**
```sql
-- ❌ 低效的游标方式
DELIMITER //
CREATE PROCEDURE update_salaries_cursor()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE emp_id INT;
    DECLARE emp_cursor CURSOR FOR SELECT employee_id FROM employees;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN emp_cursor;
    loop_label: LOOP
        FETCH emp_cursor INTO emp_id;
        IF done THEN LEAVE loop_label; END IF;
        
        UPDATE employees 
        SET salary = salary * 1.1 
        WHERE employee_id = emp_id;
    END LOOP;
    CLOSE emp_cursor;
END //

-- ✅ 高效的集合操作
CREATE PROCEDURE update_salaries_batch()
BEGIN
    -- 一次性更新所有记录
    UPDATE employees SET salary = salary * 1.1;
END //
DELIMITER ;
```

**🎯 优化策略二：游标查询优化**
```sql
DELIMITER //
CREATE PROCEDURE optimized_cursor_processing()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE emp_id INT;
    DECLARE emp_salary DECIMAL(10,2);
    
    -- ✅ 优化的游标查询
    DECLARE emp_cursor CURSOR FOR
        SELECT employee_id, salary 
        FROM employees 
        WHERE department_id = 10  -- 添加WHERE条件减少数据量
        AND salary > 3000         -- 进一步过滤
        ORDER BY employee_id      -- 利用索引排序
        LIMIT 1000;              -- 限制处理数量
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN emp_cursor;
    
    -- 批量处理逻辑
    process_loop: LOOP
        FETCH emp_cursor INTO emp_id, emp_salary;
        IF done THEN LEAVE process_loop; END IF;
        
        -- 高效的业务逻辑
        INSERT INTO salary_audit (emp_id, old_salary, new_salary, audit_date)
        VALUES (emp_id, emp_salary, emp_salary * 1.1, NOW());
        
    END LOOP;
    
    CLOSE emp_cursor;
END //
DELIMITER ;
```

**🎯 优化策略三：索引优化**
```sql
-- 为游标查询创建合适的索引
CREATE INDEX idx_dept_salary ON employees(department_id, salary);
CREATE INDEX idx_status_created ON orders(status, created_at);

-- 查看游标查询的执行计划
EXPLAIN SELECT employee_id, salary 
FROM employees 
WHERE department_id = 10 AND salary > 3000;
```

### 5.3 内存使用优化


**💾 内存管理最佳实践**：
```sql
DELIMITER //
CREATE PROCEDURE memory_efficient_cursor()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 100;  -- 控制批次大小
    DECLARE processed_count INT DEFAULT 0;
    
    DECLARE emp_id INT;
    
    -- 使用LIMIT分批处理大数据集
    DECLARE emp_cursor CURSOR FOR
        SELECT employee_id 
        FROM employees 
        WHERE processed = 0
        ORDER BY employee_id
        LIMIT batch_size;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    batch_loop: WHILE NOT done DO
        OPEN emp_cursor;
        SET done = FALSE;
        
        record_loop: LOOP
            FETCH emp_cursor INTO emp_id;
            IF done THEN LEAVE record_loop; END IF;
            
            -- 处理单条记录
            UPDATE employees SET processed = 1 WHERE employee_id = emp_id;
            SET processed_count = processed_count + 1;
            
        END LOOP;
        
        CLOSE emp_cursor;
        
        -- 检查是否还有未处理的数据
        SELECT COUNT(*) INTO @remaining FROM employees WHERE processed = 0;
        IF @remaining = 0 THEN
            SET done = TRUE;
        END IF;
        
    END WHILE;
    
    SELECT CONCAT('总共处理了 ', processed_count, ' 条记录') AS result;
END //
DELIMITER ;
```

---

## 6. 🔄 游标与事务交互机制


### 6.1 事务控制的重要性


**💡 为什么需要事务控制？**
```
数据一致性保障：
• 避免部分成功、部分失败的情况
• 确保相关数据同时更新或同时回滚
• 维护业务逻辑的完整性
• 提供错误恢复机制
```

### 6.2 游标与事务的最佳实践


**🔒 事务控制示例**：
```sql
DELIMITER //
CREATE PROCEDURE transfer_with_cursor()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_from_account INT;
    DECLARE v_to_account INT;
    DECLARE v_amount DECIMAL(10,2);
    DECLARE v_from_balance DECIMAL(10,2);
    
    -- 处理转账请求的游标
    DECLARE transfer_cursor CURSOR FOR
        SELECT from_account, to_account, amount 
        FROM transfer_requests 
        WHERE status = 'pending';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT '转账处理失败，所有操作已回滚' AS error_message;
    END;
    
    -- 开始事务
    START TRANSACTION;
    
    OPEN transfer_cursor;
    
    transfer_loop: LOOP
        FETCH transfer_cursor INTO v_from_account, v_to_account, v_amount;
        
        IF done THEN
            LEAVE transfer_loop;
        END IF;
        
        -- 检查余额
        SELECT balance INTO v_from_balance 
        FROM accounts 
        WHERE account_id = v_from_account 
        FOR UPDATE;  -- 加行锁
        
        IF v_from_balance < v_amount THEN
            -- 余额不足，更新请求状态
            UPDATE transfer_requests 
            SET status = 'failed', 
                error_msg = '余额不足'
            WHERE from_account = v_from_account 
            AND to_account = v_to_account 
            AND amount = v_amount;
            ITERATE transfer_loop;  -- 跳过当前循环
        END IF;
        
        -- 执行转账
        UPDATE accounts 
        SET balance = balance - v_amount 
        WHERE account_id = v_from_account;
        
        UPDATE accounts 
        SET balance = balance + v_amount 
        WHERE account_id = v_to_account;
        
        -- 更新请求状态
        UPDATE transfer_requests 
        SET status = 'completed',
            completed_at = NOW()
        WHERE from_account = v_from_account 
        AND to_account = v_to_account 
        AND amount = v_amount;
        
    END LOOP;
    
    CLOSE transfer_cursor;
    
    -- 提交事务
    COMMIT;
    SELECT '所有转账请求处理完成' AS success_message;
    
END //
DELIMITER ;
```

### 6.3 分布式事务中的游标


**🌐 复杂事务场景**：
```sql
DELIMITER //
CREATE PROCEDURE distributed_order_processing()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_order_id INT;
    DECLARE v_product_id INT;
    DECLARE v_quantity INT;
    DECLARE v_warehouse_stock INT;
    
    DECLARE order_cursor CURSOR FOR
        SELECT order_id, product_id, quantity 
        FROM order_items 
        WHERE order_status = 'processing';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 设置保存点，支持部分回滚
    SAVEPOINT before_order_processing;
    
    OPEN order_cursor;
    
    order_loop: LOOP
        FETCH order_cursor INTO v_order_id, v_product_id, v_quantity;
        
        IF done THEN
            LEAVE order_loop;
        END IF;
        
        -- 为每个订单项设置保存点
        SET @savepoint_name = CONCAT('order_', v_order_id, '_', v_product_id);
        
        -- 检查库存
        SELECT stock_quantity INTO v_warehouse_stock
        FROM warehouse_inventory 
        WHERE product_id = v_product_id
        FOR UPDATE;
        
        IF v_warehouse_stock < v_quantity THEN
            -- 库存不足，记录并继续处理下一个
            INSERT INTO order_processing_log 
            (order_id, product_id, status, message)
            VALUES 
            (v_order_id, v_product_id, 'failed', '库存不足');
            
            ITERATE order_loop;
        END IF;
        
        -- 扣减库存
        UPDATE warehouse_inventory 
        SET stock_quantity = stock_quantity - v_quantity
        WHERE product_id = v_product_id;
        
        -- 更新订单状态
        UPDATE order_items 
        SET order_status = 'fulfilled',
            fulfilled_at = NOW()
        WHERE order_id = v_order_id 
        AND product_id = v_product_id;
        
        -- 记录成功日志
        INSERT INTO order_processing_log 
        (order_id, product_id, status, message)
        VALUES 
        (v_order_id, v_product_id, 'success', '订单处理成功');
        
    END LOOP;
    
    CLOSE order_cursor;
    
END //
DELIMITER ;
```

---

## 7. 💾 游标内存管理实现


### 7.1 内存使用模式


**🧠 游标内存管理机制**：
```
游标内存分配：
┌─────────────────┐
│   结果集缓存     │ ← 存储查询结果
├─────────────────┤
│   索引指针       │ ← 当前位置指针
├─────────────────┤
│   元数据信息     │ ← 列定义、类型等
├─────────────────┤
│   状态标志       │ ← 打开/关闭状态
└─────────────────┘
```

### 7.2 内存监控与优化


**📊 内存使用监控**：
```sql
-- 查看当前会话的内存使用情况
SHOW STATUS LIKE 'Memory%';

-- 监控游标相关的内存指标
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE
FROM information_schema.SESSION_STATUS 
WHERE VARIABLE_NAME IN (
    'Com_select',
    'Handler_read_next',
    'Handler_read_key',
    'Created_tmp_tables',
    'Created_tmp_disk_tables'
);
```

**🔧 内存优化实现**：
```sql
DELIMITER //
CREATE PROCEDURE memory_optimized_batch_processing()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_count INT DEFAULT 0;
    DECLARE max_batches INT DEFAULT 10;  -- 限制最大批次数
    
    DECLARE emp_id INT;
    DECLARE emp_name VARCHAR(100);
    
    -- 使用LIMIT分页避免一次加载过多数据
    SET @sql = CONCAT(
        'SELECT employee_id, name FROM employees ',
        'WHERE processed = 0 ',
        'ORDER BY employee_id ',
        'LIMIT ', batch_count * 1000, ', 1000'
    );
    
    batch_processing: WHILE batch_count < max_batches DO
        
        -- 动态构建分页查询
        SET @sql = CONCAT(
            'SELECT employee_id, name FROM employees ',
            'WHERE processed = 0 ',
            'ORDER BY employee_id ',
            'LIMIT ', batch_count * 1000, ', 1000'
        );
        
        -- 准备并执行语句
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 检查是否处理完所有数据
        IF ROW_COUNT() = 0 THEN
            LEAVE batch_processing;
        END IF;
        
        SET batch_count = batch_count + 1;
        
        -- 强制释放内存
        DO SLEEP(0.01);  -- 短暂暂停让MySQL回收内存
        
    END WHILE;
    
    SELECT CONCAT('处理了 ', batch_count, ' 个批次') AS result;
END //
DELIMITER ;
```

### 7.3 内存泄漏预防


**🛡️ 防止内存泄漏的最佳实践**：
```sql
DELIMITER //
CREATE PROCEDURE leak_safe_cursor_processing()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE cursor_opened INT DEFAULT FALSE;
    DECLARE emp_id INT;
    
    DECLARE emp_cursor CURSOR FOR
        SELECT employee_id FROM employees LIMIT 1000;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 异常处理：确保游标总是被关闭
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        IF cursor_opened THEN
            CLOSE emp_cursor;
        END IF;
        ROLLBACK;
        SELECT 'Error occurred, cursor closed and transaction rolled back' AS error;
    END;
    
    -- 开始处理
    START TRANSACTION;
    
    OPEN emp_cursor;
    SET cursor_opened = TRUE;
    
    processing_loop: LOOP
        FETCH emp_cursor INTO emp_id;
        
        IF done THEN
            LEAVE processing_loop;
        END IF;
        
        -- 处理逻辑
        UPDATE employees SET last_processed = NOW() WHERE employee_id = emp_id;
        
    END LOOP;
    
    CLOSE emp_cursor;
    SET cursor_opened = FALSE;
    
    COMMIT;
    SELECT 'Processing completed successfully' AS result;
    
END //
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 游标本质：数据库结果集的迭代器，支持逐行处理
🔸 生命周期：声明 → 打开 → 提取 → 关闭四个阶段
🔸 异常处理：必须包含NOT FOUND、SQLEXCEPTION处理
🔸 事务控制：游标操作应该在事务控制下进行
🔸 性能考量：游标通常比集合操作慢，应谨慎使用
🔸 内存管理：及时关闭游标，避免内存泄漏
```

### 8.2 关键理解要点


**🔹 何时使用游标**
```
适合使用游标的场景：
✅ 需要复杂的逐行业务逻辑处理
✅ 数据需要按特定顺序处理
✅ 需要在处理过程中做条件判断
✅ 处理过程中需要调用其他存储过程

避免使用游标的场景：
❌ 简单的批量更新操作
❌ 可以用JOIN解决的数据关联
❌ 简单的聚合计算
❌ 性能要求极高的场景
```

**🔹 性能优化原则**
```
优化策略：
• 尽量用集合操作代替游标
• 为游标查询添加合适的WHERE条件
• 使用索引优化游标查询
• 控制游标处理的数据量
• 及时提交事务释放锁资源
```

**🔹 异常处理的重要性**
```
必须处理的异常：
• NOT FOUND：游标到达结尾
• SQLEXCEPTION：SQL执行错误
• SQLWARNING：SQL执行警告

异常处理要点：
• 确保游标总是被正确关闭
• 事务异常时要回滚
• 记录详细的错误信息
• 提供友好的错误提示
```

### 8.3 最佳实践总结


**🎯 开发建议**
- **先考虑集合操作**：90%的情况下集合操作比游标更高效
- **合理使用事务**：避免长事务，适时提交释放锁
- **完善异常处理**：确保程序健壮性
- **监控性能指标**：定期检查游标操作的性能影响
- **文档化复杂逻辑**：游标逻辑通常比较复杂，需要详细注释

**🔧 运维要点**
- **定期检查慢查询日志**：识别性能问题
- **监控内存使用**：防止内存泄漏
- **备份相关存储过程**：确保代码版本管理
- **测试异常场景**：验证错误处理机制

**🧠 核心记忆**
```
游标四步骤：声明开提关
异常处理不能忘，事务控制要周全
性能优化是关键，集合操作优先选
内存管理要注意，及时关闭防泄漏
```