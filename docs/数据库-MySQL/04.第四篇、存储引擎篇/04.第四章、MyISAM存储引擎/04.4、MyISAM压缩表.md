---
title: 4、MyISAM压缩表
---
## 📚 目录

1. [MyISAM压缩表基础概念](#1-MyISAM压缩表基础概念)
2. [myisampack压缩工具详解](#2-myisampack压缩工具详解)
3. [压缩算法原理与效果评估](#3-压缩算法原理与效果评估)
4. [压缩表的使用限制](#4-压缩表的使用限制)
5. [压缩表查询性能特征](#5-压缩表查询性能特征)
6. [压缩表应用场景](#6-压缩表应用场景)
7. [压缩操作实践指南](#7-压缩操作实践指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🗜️ MyISAM压缩表基础概念


### 1.1 什么是MyISAM压缩表

**MyISAM压缩表**就像把文件放进压缩包一样，把数据库表"压缩"后存储，可以大大节省存储空间。

```
普通表 vs 压缩表：

普通MyISAM表：
├── table.frm  (表结构文件)
├── table.MYD  (数据文件)
└── table.MYI  (索引文件)

压缩表：
├── table.frm  (表结构文件)
├── table.MYD  (压缩数据文件) ← 大小显著减小
└── table.MYI  (索引文件)
```

### 1.2 压缩表的基本特征

**🔸 核心特点**
```
✅ 显著节省存储空间：通常可减少50-80%的磁盘占用
✅ 减少IO操作：文件变小，读取速度可能更快
✅ 适合历史数据：不需要修改的数据最适合压缩
❌ 变为只读：压缩后无法INSERT、UPDATE、DELETE
❌ 不可逆操作：压缩后无法直接恢复为普通表
```

### 1.3 压缩的基本原理

**简单理解**：MySQL分析表中数据的规律，用更短的方式表示相同的信息。

```
压缩原理示例：

原始数据：
用户状态列：'active','active','active','inactive','active'

压缩后：
字典：1='active', 2='inactive'  
数据：1,1,1,2,1

效果：原来7字节的'active'变成1字节的'1'
```

---

## 2. 🛠️ myisampack压缩工具详解


### 2.1 myisampack工具概述

**myisampack**是MySQL提供的专门用于压缩MyISAM表的命令行工具。

**🔸 工具作用**
- **分析数据**：分析表中数据的分布规律
- **生成字典**：为重复数据创建压缩字典
- **创建压缩表**：生成只读的压缩表文件
- **优化存储**：最大化压缩效果

### 2.2 myisampack基本语法

```bash
# 基本压缩命令
myisampack [选项] 表文件名

# 示例：压缩users表
myisampack /var/lib/mysql/mydb/users
```

**🔸 常用参数选项**
```bash
# 查看压缩效果预估（不实际压缩）
myisampack --test /var/lib/mysql/mydb/users

# 显示详细压缩信息
myisampack --verbose /var/lib/mysql/mydb/users

# 强制压缩（覆盖已存在的压缩文件）
myisampack --force /var/lib/mysql/mydb/users

# 设置临时目录
myisampack --tmpdir=/tmp /var/lib/mysql/mydb/users

# 静默模式（不显示处理信息）
myisampack --silent /var/lib/mysql/mydb/users
```

### 2.3 压缩过程详解

```
myisampack压缩步骤：

第1步：数据分析
├── 分析每列的数据分布
├── 统计重复值出现频率
└── 计算最优压缩策略

第2步：创建压缩字典
├── 为频繁出现的值创建短编码
├── 为长字符串创建引用表
└── 优化数值类型的存储

第3步：生成压缩文件
├── 重写.MYD数据文件
├── 更新.MYI索引文件
└── 标记表为只读状态

第4步：压缩完成
├── 显示压缩统计信息
├── 原文件被替换
└── 表可以正常查询（只读）
```

### 2.4 压缩操作实例

**🔸 完整压缩流程**
```bash
# 第1步：检查表状态
mysql -e "SELECT COUNT(*) FROM mydb.users;"
mysql -e "SHOW TABLE STATUS LIKE 'users';" | grep Data_length

# 第2步：停止MySQL服务（确保没有访问）
sudo systemctl stop mysql

# 第3步：预览压缩效果
myisampack --test /var/lib/mysql/mydb/users
# 输出示例：
# Compressing /var/lib/mysql/mydb/users.MYD: (102400 records)
# - Compressing file
# 80.50%

# 第4步：执行实际压缩
myisampack --verbose /var/lib/mysql/mydb/users

# 第5步：重建索引（重要！）
myisamchk --recover --sort-index /var/lib/mysql/mydb/users

# 第6步：启动MySQL服务
sudo systemctl start mysql
```

**🔸 压缩结果解读**
```bash
# myisampack输出示例解读
Compressing /var/lib/mysql/mydb/users.MYD: (102400 records)
- Compressing file
80.50%    # 压缩比：节省了80.5%的空间
3268 -> 638 bytes    # 原大小3268字节，压缩后638字节
```

---

## 3. 🔬 压缩算法原理与效果评估


### 3.1 压缩算法实现原理

**🔸 哈夫曼编码（主要算法）**
```
原理：频繁出现的数据用短编码，罕见数据用长编码

示例数据分析：
字符  出现频率  原编码  压缩编码
'Y'   45%      8位     2位
'N'   35%      8位     3位  
'M'   15%      8位     4位
'X'   5%       8位     5位

效果：平均每字符从8位减少到约2.8位
```

**🔸 重复数据压缩**
```
重复值压缩原理：

原始数据：
['Beijing','Shanghai','Beijing','Beijing','Guangzhou','Shanghai']

压缩后存储：
字典表：1='Beijing', 2='Shanghai', 3='Guangzhou'
压缩数据：[1,2,1,1,3,2]

节省空间：
原来：8+9+8+8+10+9 = 52字节
压缩：字典(30字节)+数据(6字节) = 36字节
压缩比：约30%
```

### 3.2 压缩效果评估

**🔸 影响压缩效果的因素**
```
数据特征对压缩效果的影响：

高压缩比场景（70-90%）：
✅ 大量重复数据：状态字段、分类字段
✅ 长文本字段：描述、内容字段
✅ 稀疏数据：很多NULL值的表

低压缩比场景（10-30%）：
❌ 主键、唯一键：每行都不同的数据
❌ 随机数据：UUID、哈希值等
❌ 已压缩数据：图片、压缩文件等
```

**🔸 压缩效果预测**
```sql
-- 分析表的压缩潜力
SELECT 
    column_name,
    data_type,
    COUNT(DISTINCT column_name) as unique_values,
    COUNT(*) as total_rows,
    COUNT(DISTINCT column_name) / COUNT(*) as uniqueness_ratio
FROM information_schema.columns c
JOIN table_data t ON 1=1
WHERE table_name = 'your_table'
GROUP BY column_name;

-- uniqueness_ratio 越小，压缩效果越好
-- 比如：0.1表示只有10%是唯一值，压缩效果会很好
```

### 3.3 压缩算法选择

**🔸 MySQL自动选择最优算法**
```
myisampack会为每列自动选择最佳压缩方法：

数值类型：
├── 小整数：位压缩
├── 递增序列：差值压缩  
└── 稀疏数据：NULL值优化

字符类型：
├── 重复字符串：字典压缩
├── 固定前缀：前缀压缩
└── 长度优化：变长编码

原理：工具会尝试多种算法，选择压缩比最高的
```

---

## 4. ⛔ 压缩表的使用限制


### 4.1 只读限制详解

**🔸 压缩后的限制**
```
一旦压缩，表就变成只读状态：

禁止的操作：
❌ INSERT：无法添加新数据
❌ UPDATE：无法修改现有数据  
❌ DELETE：无法删除数据
❌ ALTER TABLE：无法修改表结构
❌ TRUNCATE：无法清空表

允许的操作：
✅ SELECT：正常查询数据
✅ 建立索引：可以添加索引
✅ DROP TABLE：可以删除整个表
```

### 4.2 技术限制

**🔸 其他使用限制**
```
存储引擎限制：
- 只能用于MyISAM引擎表
- 不支持InnoDB等其他引擎
- Memory引擎等不适用

功能限制：
- 不支持AUTO_INCREMENT列
- 不支持BLOB/TEXT的索引
- 不支持全文索引（FULLTEXT）

恢复限制：
- 无法直接"解压缩"
- 需要重新创建表导入数据
```

### 4.3 如何恢复可写状态

**🔸 "解压缩"方法**
```sql
-- 方法1：创建新表导入数据
CREATE TABLE users_new LIKE users_compressed;
INSERT INTO users_new SELECT * FROM users_compressed;
DROP TABLE users_compressed;
RENAME TABLE users_new TO users;

-- 方法2：使用mysqldump
mysqldump mydb users_compressed > users.sql
mysql mydb < users.sql
```

---

## 5. 📊 压缩表查询性能特征


### 5.1 查询性能分析

**🔸 性能影响因素**
```
压缩表的查询性能特征：

读取性能：
✅ IO减少：文件更小，磁盘读取更快
✅ 缓存效率：更多数据可以放入内存
❌ CPU增加：需要解压缩处理

综合效果：
- 磁盘IO密集场景：性能通常提升
- CPU密集场景：性能可能下降
- 内存充足场景：性能提升明显
```

### 5.2 查询性能测试

**🔸 性能对比实例**
```sql
-- 压缩前后的性能对比测试

-- 测试1：全表扫描
SELECT COUNT(*) FROM users_normal;     -- 耗时：2.5秒
SELECT COUNT(*) FROM users_compressed; -- 耗时：1.8秒（提升28%）

-- 测试2：索引查询
SELECT * FROM users_normal WHERE id = 1000;     -- 耗时：0.01秒
SELECT * FROM users_compressed WHERE id = 1000; -- 耗时：0.012秒（略慢）

-- 测试3：复杂查询
SELECT status, COUNT(*) FROM users_normal GROUP BY status;     -- 耗时：3.2秒
SELECT status, COUNT(*) FROM users_compressed GROUP BY status; -- 耗时：2.1秒（提升34%）
```

### 5.3 性能优化建议

**🔸 针对压缩表的优化策略**
```
查询优化：
✅ 充分利用索引：减少需要解压的数据量
✅ 避免SELECT *：只查询需要的列
✅ 使用LIMIT：限制返回的行数
✅ 合理使用WHERE条件：在解压前过滤数据

内存配置优化：
- 增大key_buffer_size：提高索引缓存
- 增大read_buffer_size：提高表扫描效率
- 增大sort_buffer_size：提高排序性能
```

---

## 6. 🎯 压缩表应用场景


### 6.1 理想应用场景

**🔸 历史数据存储**
```
场景描述：
- 历史订单数据：查询频率低，但需要保留
- 日志数据：主要用于分析，很少修改
- 归档数据：备份后的旧数据

优势：
✅ 大幅减少存储成本
✅ 提高备份效率
✅ 减少存储设备压力
```

**🔸 数据仓库场景**
```
OLAP分析场景：
- 维度表：相对稳定的参考数据
- 事实表：历史交易数据
- 报表数据：预计算的汇总结果

特点：
- 数据量大
- 查询多，更新少
- 对存储空间敏感
```

### 6.2 不适合的场景

**🔸 避免使用的情况**
```
OLTP交易系统：
❌ 频繁的增删改操作
❌ 实时数据更新需求
❌ 高并发写入场景

主要业务表：
❌ 用户基础信息表
❌ 商品库存表
❌ 订单状态表

原因：这些表需要频繁修改，压缩后无法写入
```

### 6.3 典型应用案例

**🔸 电商系统应用**
```
适合压缩的表：
✅ 历史订单表（3个月前的订单）
✅ 商品评论历史表
✅ 用户行为日志表
✅ 数据分析结果表

不适合压缩的表：
❌ 当前用户表
❌ 实时库存表
❌ 活跃订单表
❌ 会话状态表

实施策略：
1. 按时间分表（如按月）
2. 当月数据用普通表
3. 历史数据定期压缩
```

---

## 7. 🔧 压缩操作实践指南


### 7.1 压缩前的准备工作

**🔸 数据备份**
```bash
# 第1步：备份原表数据
mysqldump -u root -p mydb users > users_backup.sql

# 第2步：备份表结构
mysqldump -u root -p --no-data mydb users > users_structure.sql

# 第3步：记录表统计信息
mysql -e "SHOW TABLE STATUS LIKE 'users';" > table_stats_before.txt
```

**🔸 环境检查**
```bash
# 检查磁盘空间（压缩过程需要额外空间）
df -h /var/lib/mysql

# 检查表是否有活跃连接
mysql -e "SHOW PROCESSLIST;" | grep users

# 停止相关应用（确保没有写操作）
sudo systemctl stop myapp
```

### 7.2 执行压缩操作

**🔸 标准压缩流程**
```bash
# 第1步：停止MySQL服务
sudo systemctl stop mysql

# 第2步：预测压缩效果
myisampack --test /var/lib/mysql/mydb/users
# 查看预期压缩比和节省空间

# 第3步：执行压缩
myisampack --verbose /var/lib/mysql/mydb/users

# 第4步：重建索引（必须操作）
myisamchk --recover --sort-index /var/lib/mysql/mydb/users

# 第5步：检查表完整性
myisamchk --check /var/lib/mysql/mydb/users

# 第6步：启动MySQL服务
sudo systemctl start mysql
```

### 7.3 压缩后验证

**🔸 验证压缩结果**
```sql
-- 检查数据完整性
SELECT COUNT(*) FROM users;  -- 对比压缩前的记录数

-- 检查表状态
SHOW TABLE STATUS LIKE 'users';
-- 重点查看：
-- Data_length：数据文件大小
-- Rows：行数是否正确
-- Comment：是否显示"Compressed"

-- 测试查询功能
SELECT * FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE status = 'active';

-- 验证只读限制
INSERT INTO users (name) VALUES ('test');  -- 应该报错
```

### 7.4 监控压缩表性能

**🔸 性能监控指标**
```sql
-- 查询响应时间监控
SELECT 
    schema_name,
    table_name,
    count_read,
    avg_timer_read/1000000 as avg_read_ms
FROM performance_schema.table_io_waits_summary_by_table
WHERE table_name = 'users';

-- 文件IO统计
SELECT 
    file_name,
    count_read,
    sum_number_of_bytes_read/1024/1024 as read_mb
FROM performance_schema.file_summary_by_instance
WHERE file_name LIKE '%users%';
```

---

## 8. 📚 压缩操作高级技巧


### 8.1 批量压缩脚本

**🔸 自动化压缩脚本**
```bash
#!/bin/bash
# compress_old_tables.sh - 批量压缩历史表

MYSQL_USER="root"
MYSQL_PASS="password"
DATABASE="mydb"
DATA_DIR="/var/lib/mysql"

# 获取3个月前的表列表（按表名规律）
tables=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -D$DATABASE -e "
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema='$DATABASE' 
AND table_name REGEXP '^users_[0-9]{6}$' 
AND table_name < 'users_$(date -d '3 months ago' +%Y%m)'
" -s)

echo "准备压缩的表：$tables"

# 停止MySQL服务
systemctl stop mysql

for table in $tables; do
    echo "压缩表：$table"
    
    # 预测压缩效果
    myisampack --test $DATA_DIR/$DATABASE/$table
    
    # 执行压缩
    myisampack $DATA_DIR/$DATABASE/$table
    
    # 重建索引
    myisamchk --recover --sort-index $DATA_DIR/$DATABASE/$table
    
    echo "表 $table 压缩完成"
done

# 重启MySQL服务
systemctl start mysql
echo "批量压缩完成"
```

### 8.2 压缩效果统计

**🔸 压缩统计查询**
```sql
-- 查看压缩表统计信息
SELECT 
    table_schema,
    table_name,
    ROUND(data_length/1024/1024, 2) as size_mb,
    table_rows,
    table_comment
FROM information_schema.tables
WHERE engine = 'MyISAM' 
AND table_comment LIKE '%Compressed%';

-- 计算压缩节省的空间
SELECT 
    SUM(CASE WHEN table_comment LIKE '%Compressed%' 
        THEN data_length ELSE 0 END) / 1024/1024 as compressed_mb,
    SUM(data_length) / 1024/1024 as total_mb,
    ROUND(
        (1 - SUM(CASE WHEN table_comment LIKE '%Compressed%' 
                 THEN data_length ELSE 0 END) / SUM(data_length)) * 100, 
        2
    ) as space_saved_percent
FROM information_schema.tables
WHERE table_schema = 'mydb';
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念

```
🔸 压缩表本质：用myisampack工具创建的只读MyISAM表
🔸 核心特征：显著节省存储空间，但变为只读状态
🔸 压缩原理：分析数据规律，用短编码替代长数据
🔸 适用场景：历史数据、归档数据、数据仓库等查询多修改少的场景
🔸 操作工具：myisampack压缩，myisamchk修复索引
```

### 9.2 关键理解要点


**🔹 压缩的权衡取舍**
```
获得的好处：
✅ 存储空间大幅节省（通常50-80%）
✅ 减少磁盘IO，可能提升查询速度
✅ 降低存储成本和备份时间

付出的代价：
❌ 表变为只读，无法修改数据
❌ 压缩和恢复过程需要停机
❌ CPU解压开销（通常可以接受）

决策原则：
- 数据修改频率低 → 适合压缩
- 存储成本敏感 → 适合压缩
- 需要频繁写入 → 不适合压缩
```

**🔹 压缩工具的使用要点**
```
myisampack使用核心：
- 压缩前必须备份数据
- 压缩时必须停止MySQL服务
- 压缩后必须重建索引
- 压缩是不可逆操作

记忆顺序：停服务 → 压缩 → 重建索引 → 启动服务
```

**🔹 应用场景的判断标准**
```
适合压缩的特征：
✅ 查询频率 > 修改频率
✅ 数据量大，存储成本高
✅ 有明显的重复数据或模式
✅ 可以接受只读限制

不适合压缩的特征：
❌ 主业务表，需要频繁修改
❌ 实时性要求高的数据
❌ 数据完全随机，无压缩价值
❌ 表结构可能经常变动
```

### 9.3 实际应用指导


**🔸 生产环境使用建议**
```
实施策略：
1. 先在测试环境验证压缩效果
2. 选择业务低峰期执行压缩
3. 制定详细的操作计划和回滚预案
4. 压缩后持续监控查询性能

监控要点：
- 压缩后的查询响应时间
- CPU使用率变化
- 磁盘IO变化
- 用户体验反馈
```

**🔸 故障处理预案**
```
常见问题及解决方案：

压缩失败：
├── 检查磁盘空间是否充足
├── 检查文件权限是否正确
└── 查看错误日志定位问题

查询变慢：
├── 检查索引是否正确重建
├── 调整相关缓冲区大小
└── 考虑是否需要恢复为普通表

数据异常：
├── 立即停止服务避免进一步损坏
├── 使用备份数据恢复
└── 分析压缩过程日志找出原因
```

**核心记忆口诀**：
```
压缩表来节省空间，只读限制要记牢
历史数据最适合，频繁修改不能要
myisampack工具用，备份索引别忘掉
查询变快存储省，权衡利弊要思考
```