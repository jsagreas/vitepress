---
title: 26、InnoDB表统计信息管理
---
## 📚 目录

1. [InnoDB统计信息概述](#1-InnoDB统计信息概述)
2. [统计信息存储机制](#2-统计信息存储机制)
3. [mysql.innodb_table_stats表详解](#3-mysql-innodb-table-stats表详解)
4. [mysql.innodb_index_stats表详解](#4-mysql-innodb-index-stats表详解)
5. [采样页面数量控制](#5-采样页面数量控制)
6. [统计信息刷新触发条件](#6-统计信息刷新触发条件)
7. [统计信息锁定机制](#7-统计信息锁定机制)
8. [手动统计信息更新](#8-手动统计信息更新)
9. [统计信息对查询计划的影响](#9-统计信息对查询计划的影响)
10. [统计信息更新策略优化](#10-统计信息更新策略优化)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 📊 InnoDB统计信息概述


### 1.1 什么是统计信息


**🔸 统计信息的本质**
想象数据库优化器是一个导航系统，要为你规划最优路线。统计信息就像是交通流量数据、道路拥堵情况等信息，帮助导航系统做出最明智的路径选择。

```
统计信息包含的核心数据：
• 表的总行数
• 每个索引的唯一值数量（基数）
• 索引页面的分布情况
• 数据页面的大小和数量
• 空间使用情况
```

**💡 为什么统计信息很重要**
```
查询优化器的决策过程：

有准确统计信息：
查询请求 ──→ 分析统计信息 ──→ 选择最优执行计划 ──→ 快速执行

没有准确统计信息：
查询请求 ──→ 猜测数据分布 ──→ 选择错误执行计划 ──→ 执行缓慢

实际影响：
• 准确统计：查询耗时0.1秒
• 过时统计：查询耗时10秒（100倍差异！）
```

### 1.2 InnoDB统计信息特点


**🔸 InnoDB vs MyISAM统计信息对比**

| 特性 | **InnoDB** | **MyISAM** | **影响** |
|------|------------|------------|----------|
| **存储位置** | `系统表` | `文件头部` | `InnoDB更灵活` |
| **更新方式** | `估算采样` | `精确计算` | `InnoDB更快但不够精确` |
| **持久化** | `可配置` | `总是持久化` | `InnoDB可控制` |
| **更新时机** | `可配置触发条件` | `实时更新` | `InnoDB性能更好` |

> **🔍 深入分析**：InnoDB使用采样估算而不是精确计算，这是性能与准确性的权衡。对于大表来说，扫描全表计算精确统计信息代价太高，采样估算在大多数情况下已经足够准确。

### 1.3 统计信息的生命周期


**🔄 统计信息更新流程**

```
统计信息生命周期：

1. 初始化阶段
   表创建 ──→ 插入初始数据 ──→ 生成基础统计信息

2. 维护阶段  
   数据变化 ──→ 触发条件检查 ──→ 决定是否更新统计信息
        ↓
   更新统计信息 ──→ 优化器使用新统计信息

3. 优化阶段
   手动分析 ──→ 强制更新统计信息 ──→ 改善查询性能

4. 问题诊断阶段
   查询慢 ──→ 检查统计信息准确性 ──→ 手动刷新统计信息
```

---

## 2. 💾 统计信息存储机制


### 2.1 统计信息存储演进


**🔸 MySQL版本演进**

```
MySQL 5.5及以前：
├── 统计信息存储在内存中
├── 服务器重启后丢失
└── 每次重启需要重新统计

MySQL 5.6及以后：
├── 引入持久化统计信息
├── 存储在mysql系统数据库中
├── 新增innodb_stats_persistent参数
└── 可以选择持久化或非持久化
```

**🔧 统计信息持久化配置**

```sql
-- 查看当前持久化设置
SHOW VARIABLES LIKE 'innodb_stats_persistent%';

-- 全局设置（影响新建表）
SET GLOBAL innodb_stats_persistent = ON;
SET GLOBAL innodb_stats_persistent_sample_pages = 20;

-- 表级别设置（创建表时指定）
CREATE TABLE test_table (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    INDEX idx_name (name)
) ENGINE=InnoDB 
STATS_PERSISTENT=1,
STATS_SAMPLE_PAGES=20;

-- 修改已存在表的设置
ALTER TABLE existing_table 
STATS_PERSISTENT=1,
STATS_SAMPLE_PAGES=20;
```

### 2.2 持久化统计信息的优势


**📊 持久化统计信息对比**

```
非持久化模式问题：
服务器重启 ──→ 统计信息丢失 ──→ 重新采样统计
                                  ↓
                            大表统计耗时很长，影响启动速度

持久化模式优势：
服务器重启 ──→ 从系统表加载统计信息 ──→ 快速启动
                        ↓
                  统计信息保持一致性

性能对比测试（1000万行表）：
非持久化重启：需要3-5分钟重新统计
持久化重启：10秒内完成加载
```

---

## 3. 🗂️ mysql.innodb_table_stats表详解


### 3.1 innodb_table_stats表结构


**🔸 表结构分析**

```sql
-- 查看innodb_table_stats表结构
DESC mysql.innodb_table_stats;

/*
字段说明：
+-------------------+---------------------+
| Field             | Type                |
+-------------------+---------------------+
| database_name     | varchar(64)         |  -- 数据库名
| table_name        | varchar(199)        |  -- 表名
| last_update       | timestamp           |  -- 最后更新时间
| n_rows            | bigint(20) unsigned |  -- 估算行数
| clustered_index_size | bigint(20) unsigned | -- 聚簇索引页数
| sum_of_other_index_sizes | bigint(20) unsigned | -- 其他索引总页数
+-------------------+---------------------+
*/
```

**💡 字段含义详解**

```sql
-- 查看具体表的统计信息
SELECT * FROM mysql.innodb_table_stats 
WHERE database_name = 'test' AND table_name = 'users';

-- 输出示例：
/*
database_name: test
table_name: users
last_update: 2025-09-03 10:30:15
n_rows: 1500000                    -- 估算150万行
clustered_index_size: 8500         -- 聚簇索引占用8500页
sum_of_other_index_sizes: 2300     -- 二级索引占用2300页
*/
```

### 3.2 表统计信息计算方法


**🔸 行数估算原理**

```
InnoDB行数估算方法：

1. 随机采样指定数量的叶子页面
2. 计算每个采样页面的平均行数  
3. 用平均行数乘以总页面数得到估算行数

计算公式：
估算行数 = (采样页面总行数 ÷ 采样页面数) × 总页面数

示例计算：
采样20个页面，共包含4000行记录
总共有5000个页面
估算行数 = (4000 ÷ 20) × 5000 = 1,000,000行
```

**📊 页面大小统计**

```sql
-- 计算表的实际磁盘占用
SELECT 
    database_name,
    table_name,
    n_rows,
    clustered_index_size * 16 / 1024 AS 'clustered_size_MB',
    sum_of_other_index_sizes * 16 / 1024 AS 'other_indexes_MB',
    (clustered_index_size + sum_of_other_index_sizes) * 16 / 1024 AS 'total_size_MB'
FROM mysql.innodb_table_stats
WHERE database_name = 'test' 
ORDER BY (clustered_index_size + sum_of_other_index_sizes) DESC;

-- 注：InnoDB默认页面大小为16KB，所以乘以16再除以1024得到MB
```

### 3.3 统计信息准确性验证


**🔧 验证统计信息准确性**

```sql
-- 对比统计信息和实际行数
SELECT 
    'innodb_table_stats' AS source,
    n_rows AS row_count
FROM mysql.innodb_table_stats 
WHERE database_name = 'test' AND table_name = 'users'

UNION ALL

SELECT 
    'actual_count' AS source,
    COUNT(*) AS row_count
FROM test.users;

-- 计算误差率
SELECT 
    s.n_rows AS estimated_rows,
    (SELECT COUNT(*) FROM test.users) AS actual_rows,
    ABS(s.n_rows - (SELECT COUNT(*) FROM test.users)) / (SELECT COUNT(*) FROM test.users) * 100 AS error_percentage
FROM mysql.innodb_table_stats s
WHERE s.database_name = 'test' AND s.table_name = 'users';
```

> **⚠️ 重要提醒**：统计信息是估算值，通常有5-10%的误差是正常的。如果误差超过20%，建议手动更新统计信息。

---

## 4. 📇 mysql.innodb_index_stats表详解


### 4.1 innodb_index_stats表结构


**🔸 索引统计信息表结构**

```sql
-- 查看innodb_index_stats表结构
DESC mysql.innodb_index_stats;

/*
+-------------------+---------------------+
| Field             | Type                |
+-------------------+---------------------+
| database_name     | varchar(64)         |  -- 数据库名
| table_name        | varchar(199)        |  -- 表名  
| index_name        | varchar(64)         |  -- 索引名
| last_update       | timestamp           |  -- 最后更新时间
| stat_name         | varchar(64)         |  -- 统计项名称
| stat_value        | bigint(20) unsigned |  -- 统计值
| sample_size       | bigint(20) unsigned |  -- 采样大小
| stat_description  | varchar(1024)       |  -- 统计描述
+-------------------+---------------------+
*/
```

### 4.2 统计项类型详解


**📊 stat_name字段说明**

```sql
-- 查看某个表的所有索引统计信息
SELECT 
    index_name,
    stat_name,
    stat_value,
    sample_size,
    stat_description
FROM mysql.innodb_index_stats 
WHERE database_name = 'test' AND table_name = 'users'
ORDER BY index_name, stat_name;
```

**🔸 主要统计项含义**

| stat_name | **含义** | **作用** | **示例值** |
|-----------|---------|----------|-----------|
| `n_diff_pfx01` | `第1列的不同值数量` | `选择性计算` | `150000` |
| `n_diff_pfx02` | `前2列的不同值组合数` | `复合索引选择性` | `1500000` |
| `n_leaf_pages` | `叶子页面数量` | `索引大小估算` | `2500` |
| `size` | `索引总页面数` | `存储空间计算` | `3000` |

**💡 索引选择性计算**

```sql
-- 查看索引选择性
SELECT 
    index_name,
    stat_name,
    stat_value,
    CASE 
        WHEN stat_name = 'n_diff_pfx01' THEN
            CONCAT('选择性: ', ROUND(stat_value / (SELECT n_rows FROM mysql.innodb_table_stats 
                WHERE database_name = 'test' AND table_name = 'users') * 100, 2), '%')
        ELSE ''
    END AS selectivity
FROM mysql.innodb_index_stats 
WHERE database_name = 'test' 
    AND table_name = 'users' 
    AND stat_name = 'n_diff_pfx01';
```

### 4.3 复合索引统计信息


**🔸 复合索引的统计模式**

```sql
-- 创建复合索引示例
CREATE INDEX idx_name_age_city ON users(name, age, city);

-- 查看复合索引的统计信息
SELECT 
    stat_name,
    stat_value,
    stat_description
FROM mysql.innodb_index_stats 
WHERE database_name = 'test' 
    AND table_name = 'users' 
    AND index_name = 'idx_name_age_city'
ORDER BY stat_name;

/*
可能的输出：
stat_name        | stat_value | stat_description
n_diff_pfx01     | 80000     | name列的不同值数量
n_diff_pfx02     | 150000    | (name,age)的不同组合数
n_diff_pfx03     | 800000    | (name,age,city)的不同组合数
n_leaf_pages     | 1500      | 叶子页面数
size             | 1800      | 总页面数
*/
```

**🎯 复合索引选择性分析**

```
复合索引选择性解读：

name列选择性 = 80,000 ÷ 1,000,000 = 8%
(name,age)选择性 = 150,000 ÷ 1,000,000 = 15%  
(name,age,city)选择性 = 800,000 ÷ 1,000,000 = 80%

优化器决策：
• 如果查询只用name：选择性8%，可能不走索引
• 如果查询用name+age：选择性15%，可能走索引
• 如果查询用name+age+city：选择性80%，很可能走索引
```

---

## 5. 📄 采样页面数量控制


### 5.1 采样机制原理


**🔸 为什么需要采样**

想象你要统计一个城市的人口分布，最准确的方法是挨家挨户统计，但这太耗时。更实用的方法是随机抽样一些区域，然后推算整体情况。InnoDB的统计信息采样就是这个原理。

```
采样统计 vs 精确统计：

精确统计（全表扫描）：
扫描所有页面 ──→ 计算精确统计 ──→ 耗时很长（大表可能需要小时级）

采样统计：
随机采样页面 ──→ 估算统计信息 ──→ 快速完成（通常秒级）
     ↓
准确度稍低，但对优化器决策影响不大
```

### 5.2 采样参数配置


**🔧 采样相关参数**

```sql
-- 查看采样相关参数
SHOW VARIABLES LIKE '%stats%sample%';

/*
innodb_stats_persistent_sample_pages = 20    -- 持久化统计采样页数
innodb_stats_transient_sample_pages = 8     -- 非持久化统计采样页数
*/

-- 全局设置采样页数
SET GLOBAL innodb_stats_persistent_sample_pages = 50;

-- 单表设置采样页数
ALTER TABLE users STATS_SAMPLE_PAGES = 100;
```

**📊 采样页数影响分析**

| 采样页数 | **统计准确性** | **统计耗时** | **适用场景** |
|---------|---------------|-------------|-------------|
| `8页` | `±15%误差` | `很快` | `小表或测试环境` |
| `20页(默认)` | `±8%误差` | `快` | `一般生产环境` |
| `50页` | `±5%误差` | `较快` | `统计准确性要求高` |
| `100页` | `±3%误差` | `中等` | `大表或关键业务表` |

### 5.3 采样策略优化


**🎯 不同表类型的采样策略**

```sql
-- 根据表大小调整采样策略

-- 小表（<10万行）：使用默认设置
ALTER TABLE small_table STATS_SAMPLE_PAGES = DEFAULT;

-- 中等表（10万-1000万行）：增加采样页数
ALTER TABLE medium_table STATS_SAMPLE_PAGES = 50;

-- 大表（>1000万行）：显著增加采样页数
ALTER TABLE large_table STATS_SAMPLE_PAGES = 200;

-- 核心业务表：最高精度采样
ALTER TABLE critical_table STATS_SAMPLE_PAGES = 500;
```

**🔧 动态采样策略脚本**

```sql
-- 根据表大小自动设置采样页数的存储过程
DELIMITER $$
CREATE PROCEDURE OptimizeSamplingPages()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE db_name, tbl_name VARCHAR(64);
    DECLARE row_count BIGINT;
    DECLARE sample_pages INT;
    
    -- 声明游标
    DECLARE table_cursor CURSOR FOR
        SELECT database_name, table_name, n_rows 
        FROM mysql.innodb_table_stats
        WHERE database_name NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys');
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    read_loop: LOOP
        FETCH table_cursor INTO db_name, tbl_name, row_count;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 根据行数确定采样页数
        CASE 
            WHEN row_count < 100000 THEN SET sample_pages = 20;
            WHEN row_count < 1000000 THEN SET sample_pages = 50;
            WHEN row_count < 10000000 THEN SET sample_pages = 100;
            ELSE SET sample_pages = 200;
        END CASE;
        
        -- 动态构建并执行ALTER语句
        SET @sql = CONCAT('ALTER TABLE ', db_name, '.', tbl_name, 
                         ' STATS_SAMPLE_PAGES = ', sample_pages);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE table_cursor;
END$$
DELIMITER ;
```

---

## 6. ⚡ 统计信息刷新触发条件


### 6.1 自动刷新触发机制


**🔸 触发条件算法**

InnoDB统计信息的自动刷新就像汽车的定期保养，不是每次启动都保养，而是根据行驶里程或时间间隔来决定。

```
统计信息刷新触发算法：

触发条件 = (当前行数变化 > 阈值) OR (索引结构发生重大变化)

具体计算：
变化行数 > 表总行数 × 10% + 2000

示例：
100万行的表：变化行数 > 100万 × 10% + 2000 = 102000行
10万行的表：变化行数 > 10万 × 10% + 2000 = 12000行
1万行的表：变化行数 > 1万 × 10% + 2000 = 3000行
```

**⚙️ 触发条件相关参数**

```sql
-- 查看自动统计相关参数
SHOW VARIABLES LIKE 'innodb_stats_auto%';

/*
innodb_stats_auto_recalc = ON    -- 是否自动重新计算统计信息
*/

-- 控制是否自动更新统计信息
SET GLOBAL innodb_stats_auto_recalc = ON;  -- 开启自动更新
SET GLOBAL innodb_stats_auto_recalc = OFF; -- 关闭自动更新

-- 表级别控制
ALTER TABLE users STATS_AUTO_RECALC = 1;  -- 开启该表的自动更新
ALTER TABLE users STATS_AUTO_RECALC = 0;  -- 关闭该表的自动更新
```

### 6.2 触发场景分析


**📊 不同操作的触发影响**

```sql
-- 测试统计信息触发条件
-- 假设users表有100万行数据

-- 1. 大批量插入
INSERT INTO users SELECT * FROM users LIMIT 150000;  
-- 插入15万行，超过10万+2000的阈值，会触发统计信息更新

-- 2. 大批量删除  
DELETE FROM users WHERE created_at < '2023-01-01';
-- 如果删除超过10.2万行，会触发统计信息更新

-- 3. 大批量更新
UPDATE users SET status = 'active' WHERE status = 'pending';
-- 更新操作通常不触发统计信息更新（除非涉及索引列的大量变化）

-- 4. 索引操作
DROP INDEX idx_email ON users;    -- 立即触发统计信息更新
CREATE INDEX idx_phone ON users(phone);  -- 立即触发统计信息更新
```

### 6.3 触发条件优化策略


**🎯 不同业务场景的策略**

```
业务场景分析：

🔸 OLTP系统（频繁小事务）
建议：开启自动更新 (innodb_stats_auto_recalc = ON)
原因：数据变化相对稳定，自动触发机制工作良好

🔸 OLAP系统（大批量数据处理）  
建议：关闭自动更新，手动控制更新时机
原因：避免在数据加载过程中频繁更新统计信息

🔸 混合场景
建议：核心表关闭自动更新，其他表开启
原因：对关键查询性能有精确控制
```

**⚙️ 精细化控制示例**

```sql
-- 对不同类型的表采用不同策略

-- 核心业务表：关闭自动更新，手动控制
ALTER TABLE orders STATS_AUTO_RECALC = 0;
ALTER TABLE customers STATS_AUTO_RECALC = 0;

-- 日志类表：开启自动更新
ALTER TABLE access_logs STATS_AUTO_RECALC = 1;
ALTER TABLE error_logs STATS_AUTO_RECALC = 1;

-- 配置表：开启自动更新（数据变化少）
ALTER TABLE system_config STATS_AUTO_RECALC = 1;
```

---

## 7. 🔒 统计信息锁定机制


### 7.1 锁定机制的作用


**🔸 为什么需要锁定统计信息**

想象你正在使用导航软件，如果导航系统在你行驶过程中频繁更新路况信息并改变路线，反而会造成混乱。有时候需要"锁定"当前的路线方案。

```
统计信息锁定的应用场景：

问题场景：
数据批量导入 ──→ 触发统计信息更新 ──→ 执行计划突然变化 ──→ 查询性能下降

解决方案：
锁定统计信息 ──→ 执行计划保持稳定 ──→ 批量操作完成后解锁
```

### 7.2 统计信息锁定实现


**🔧 锁定和解锁操作**

```sql
-- 方法1：关闭特定表的自动统计更新
ALTER TABLE users STATS_AUTO_RECALC = 0;

-- 方法2：全局关闭自动统计更新
SET GLOBAL innodb_stats_auto_recalc = OFF;

-- 方法3：删除统计信息记录（强制锁定）
-- ⚠️ 谨慎使用，会导致优化器使用默认估算值
DELETE FROM mysql.innodb_table_stats 
WHERE database_name = 'test' AND table_name = 'users';

DELETE FROM mysql.innodb_index_stats 
WHERE database_name = 'test' AND table_name = 'users';
```

### 7.3 锁定状态监控


**📊 监控统计信息锁定状态**

```sql
-- 查看哪些表关闭了自动统计更新
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    t.CREATE_OPTIONS,
    CASE 
        WHEN t.CREATE_OPTIONS LIKE '%stats_auto_recalc=0%' THEN 'Locked'
        WHEN t.CREATE_OPTIONS LIKE '%stats_auto_recalc=1%' THEN 'Auto Update'
        ELSE 'Default (Auto Update)'
    END AS stats_status
FROM information_schema.TABLES t
WHERE t.ENGINE = 'InnoDB' 
    AND t.TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')
ORDER BY t.TABLE_SCHEMA, t.TABLE_NAME;
```

**🔧 统计信息锁定管理脚本**

```sql
-- 创建统计信息管理存储过程
DELIMITER $$
CREATE PROCEDURE ManageStatsLocking(
    IN action VARCHAR(10),  -- 'LOCK' 或 'UNLOCK'
    IN schema_name VARCHAR(64),
    IN table_pattern VARCHAR(64)
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE tbl_name VARCHAR(64);
    DECLARE recalc_value INT;
    
    -- 根据操作设置recalc值
    IF action = 'LOCK' THEN
        SET recalc_value = 0;
    ELSE
        SET recalc_value = 1;
    END IF;
    
    -- 声明游标
    DECLARE table_cursor CURSOR FOR
        SELECT TABLE_NAME 
        FROM information_schema.TABLES 
        WHERE TABLE_SCHEMA = schema_name 
            AND TABLE_NAME LIKE table_pattern
            AND ENGINE = 'InnoDB';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    read_loop: LOOP
        FETCH table_cursor INTO tbl_name;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 构建并执行ALTER语句
        SET @sql = CONCAT('ALTER TABLE ', schema_name, '.', tbl_name, 
                         ' STATS_AUTO_RECALC = ', recalc_value);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        SELECT CONCAT(action, ' stats for table: ', schema_name, '.', tbl_name) AS result;
        
    END LOOP;
    
    CLOSE table_cursor;
END$$
DELIMITER ;

-- 使用示例
CALL ManageStatsLocking('LOCK', 'test', 'user%');    -- 锁定test库中user开头的表
CALL ManageStatsLocking('UNLOCK', 'test', 'user%');  -- 解锁test库中user开头的表
```

---

## 8. 🔧 手动统计信息更新


### 8.1 手动更新的必要性


**🔸 什么时候需要手动更新**

```
手动更新统计信息的典型场景：

🔸 数据导入后
大批量数据导入完成 ──→ 统计信息严重过时 ──→ 查询计划不准确

🔸 数据分布发生重大变化
数据倾斜发生变化 ──→ 自动更新不及时 ──→ 需要立即更新

🔸 查询性能突然下降
查询变慢 ──→ 怀疑统计信息问题 ──→ 手动刷新验证

🔸 定期维护
定期维护时间 ──→ 主动更新所有统计信息 ──→ 保证系统性能
```

### 8.2 手动更新方法


**🔧 ANALYZE TABLE语句**

```sql
-- 单表统计信息更新
ANALYZE TABLE users;

-- 多表批量更新
ANALYZE TABLE users, orders, products, categories;

-- 更新指定数据库的所有表
-- （需要先生成语句列表）
SELECT CONCAT('ANALYZE TABLE ', TABLE_SCHEMA, '.', TABLE_NAME, ';') AS analyze_sql
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'test' AND ENGINE = 'InnoDB';
```

**📊 查看更新进度和结果**

```sql
-- 执行ANALYZE TABLE并查看结果
ANALYZE TABLE users;

/*
返回结果示例：
+------------+----------+----------+----------+
| Table      | Op       | Msg_type | Msg_text |
+------------+----------+----------+----------+
| test.users | analyze  | status   | OK       |
+------------+----------+----------+----------+
*/

-- 验证统计信息是否已更新
SELECT 
    table_name,
    last_update,
    n_rows
FROM mysql.innodb_table_stats 
WHERE database_name = 'test' AND table_name = 'users';
```

### 8.3 批量更新脚本


**🔧 智能批量更新脚本**

```sql
-- 创建智能统计信息更新存储过程
DELIMITER $$
CREATE PROCEDURE UpdateStatsIntelligent(
    IN target_schema VARCHAR(64),
    IN update_threshold_hours INT DEFAULT 24
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE tbl_name VARCHAR(64);
    DECLARE last_update_time TIMESTAMP;
    DECLARE hours_since_update INT;
    
    DECLARE table_cursor CURSOR FOR
        SELECT 
            s.table_name,
            s.last_update,
            TIMESTAMPDIFF(HOUR, s.last_update, NOW()) AS hours_old
        FROM mysql.innodb_table_stats s
        WHERE s.database_name = target_schema
            AND TIMESTAMPDIFF(HOUR, s.last_update, NOW()) > update_threshold_hours;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    SELECT CONCAT('开始更新超过 ', update_threshold_hours, ' 小时未更新的统计信息...') AS status;
    
    OPEN table_cursor;
    
    read_loop: LOOP
        FETCH table_cursor INTO tbl_name, last_update_time, hours_since_update;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 执行ANALYZE TABLE
        SET @sql = CONCAT('ANALYZE TABLE ', target_schema, '.', tbl_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        SELECT CONCAT('已更新表: ', target_schema, '.', tbl_name, 
                     ' (上次更新: ', hours_since_update, ' 小时前)') AS result;
        
    END LOOP;
    
    CLOSE table_cursor;
    SELECT '统计信息更新完成!' AS status;
END$$
DELIMITER ;

-- 使用示例
CALL UpdateStatsIntelligent('test', 12);  -- 更新test库中12小时未更新的表
```

### 8.4 更新性能优化


**⚡ 提升更新效率的策略**

```sql
-- 1. 在系统负载较低时进行更新
SELECT 
    HOUR(NOW()) AS current_hour,
    CASE 
        WHEN HOUR(NOW()) BETWEEN 2 AND 5 THEN '建议更新时间'
        WHEN HOUR(NOW()) BETWEEN 9 AND 17 THEN '业务繁忙时间，谨慎更新'
        ELSE '可以更新'
    END AS recommendation;

-- 2. 根据表大小调整更新策略
SELECT 
    table_name,
    n_rows,
    CASE 
        WHEN n_rows < 100000 THEN '立即更新'
        WHEN n_rows < 1000000 THEN '业务低峰期更新'
        ELSE '维护窗口期更新'
    END AS update_strategy
FROM mysql.innodb_table_stats 
WHERE database_name = 'test'
ORDER BY n_rows DESC;

-- 3. 并发控制更新
-- 避免同时更新多个大表，控制系统负载
```

---

## 9. 📈 统计信息对查询计划的影响


### 9.1 统计信息如何影响优化器


**🔸 优化器决策过程**

```
查询优化器的决策流程：

SQL查询 ──→ 解析查询条件 ──→ 读取统计信息 ──→ 计算各种执行方案成本
    ↓
选择成本最低的执行计划 ──→ 执行查询

统计信息的作用：
• 表行数 → 估算全表扫描成本
• 索引选择性 → 估算索引扫描成本  
• 数据分布 → 预测WHERE条件过滤效果
```

**💡 具体影响示例**

```sql
-- 创建测试表和数据
CREATE TABLE test_stats (
    id INT PRIMARY KEY,
    status VARCHAR(20),
    created_date DATE,
    INDEX idx_status (status),
    INDEX idx_date (created_date)
);

-- 插入测试数据（90%的记录status='active'）
INSERT INTO test_stats VALUES 
(1, 'active', '2025-01-01'),
-- ... 大量active记录
(900000, 'active', '2025-09-01'),
-- ... 少量inactive记录  
(999999, 'inactive', '2025-09-02');
```

### 9.2 统计信息准确性对执行计划的影响


**📊 统计信息准确性测试**

```sql
-- 场景1：统计信息准确时
ANALYZE TABLE test_stats;  -- 更新统计信息

EXPLAIN SELECT * FROM test_stats WHERE status = 'inactive';
/*
执行计划：使用idx_status索引（因为优化器知道inactive记录很少）
type: ref
rows: 100000（估算值，接近实际）
*/

-- 场景2：统计信息不准确时  
-- 人为制造不准确的统计信息
UPDATE mysql.innodb_index_stats 
SET stat_value = 500000  -- 错误地认为inactive有50万条
WHERE table_name = 'test_stats' 
    AND index_name = 'idx_status' 
    AND stat_name = 'n_diff_pfx01';

FLUSH TABLE test_stats;  -- 让修改生效

EXPLAIN SELECT * FROM test_stats WHERE status = 'inactive';
/*
执行计划：可能选择全表扫描（因为优化器错误认为inactive记录很多）
type: ALL
rows: 1000000（全表扫描）
*/
```

### 9.3 常见的统计信息问题案例


**🔍 案例1：数据倾斜导致的执行计划问题**

```sql
-- 问题表现
SELECT * FROM orders WHERE order_status = 'pending';  -- 很慢
SELECT * FROM orders WHERE order_status = 'completed';  -- 很快

-- 问题分析：查看统计信息
SELECT 
    index_name,
    stat_name,
    stat_value
FROM mysql.innodb_index_stats 
WHERE table_name = 'orders' AND stat_name = 'n_diff_pfx01';

-- 发现统计信息显示order_status有很高的选择性
-- 但实际上pending状态占95%的记录

-- 解决方案：更新统计信息
ANALYZE TABLE orders;

-- 或者增加采样页数提高准确性
ALTER TABLE orders STATS_SAMPLE_PAGES = 100;
ANALYZE TABLE orders;
```

**🔍 案例2：统计信息过时导致的性能问题**

```sql
-- 监控查询计划变化
SELECT 
    query_sample_text,
    avg_rows_examined,
    avg_rows_sent,
    avg_timer_wait/1000000000 as avg_time_seconds
FROM performance_schema.events_statements_summary_by_digest 
WHERE query_sample_text LIKE '%orders%'
ORDER BY avg_timer_wait DESC LIMIT 5;

-- 对比统计信息更新前后的执行计划
EXPLAIN FORMAT=JSON SELECT * FROM orders 
WHERE created_date BETWEEN '2025-01-01' AND '2025-01-31';

-- 保存执行计划后更新统计信息
ANALYZE TABLE orders;

-- 再次查看执行计划，对比差异
EXPLAIN FORMAT=JSON SELECT * FROM orders 
WHERE created_date BETWEEN '2025-01-01' AND '2025-01-31';
```

---

## 10. ⚙️ 统计信息更新策略优化


### 10.1 不同业务场景的更新策略


**🎯 策略分类**

```
业务场景分析与策略制定：

🔸 OLTP系统（在线交易处理）
特点：频繁小事务，数据变化相对均匀
策略：开启自动更新，设置合理的采样页数
配置：innodb_stats_auto_recalc = ON, sample_pages = 20-50

🔸 OLAP系统（在线分析处理）
特点：大批量数据加载，查询复杂
策略：关闭自动更新，在ETL完成后手动更新
配置：innodb_stats_auto_recalc = OFF，手动ANALYZE

🔸 混合负载系统
特点：既有OLTP也有OLAP工作负载
策略：按表分类管理，核心表手动控制
配置：按表设置不同的STATS_AUTO_RECALC值
```

### 10.2 自动化统计信息维护


**🔧 自动维护脚本**

```sql
-- 创建全面的统计信息维护存储过程
DELIMITER $$
CREATE PROCEDURE AutoStatsMaintenanceSystem()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE db_name, tbl_name VARCHAR(64);
    DECLARE row_count BIGINT;
    DECLARE hours_old INT;
    DECLARE maintenance_action VARCHAR(50);
    
    -- 创建临时表存储维护计划
    DROP TEMPORARY TABLE IF EXISTS temp_maintenance_plan;
    CREATE TEMPORARY TABLE temp_maintenance_plan (
        database_name VARCHAR(64),
        table_name VARCHAR(64),
        current_rows BIGINT,
        hours_since_update INT,
        action_needed VARCHAR(50),
        priority INT
    );
    
    -- 分析所有InnoDB表的统计信息状态
    INSERT INTO temp_maintenance_plan
    SELECT 
        s.database_name,
        s.table_name,
        s.n_rows,
        COALESCE(TIMESTAMPDIFF(HOUR, s.last_update, NOW()), 9999) AS hours_old,
        CASE 
            WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) > 168 THEN 'URGENT_UPDATE'  -- 7天
            WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) > 72 THEN 'SCHEDULED_UPDATE'  -- 3天
            WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) > 24 THEN 'ROUTINE_UPDATE'   -- 1天
            ELSE 'NO_ACTION'
        END AS action_needed,
        CASE 
            WHEN s.n_rows > 10000000 THEN 1        -- 大表最高优先级
            WHEN s.n_rows > 1000000 THEN 2         -- 中表中等优先级
            ELSE 3                                  -- 小表低优先级
        END AS priority
    FROM mysql.innodb_table_stats s
    WHERE s.database_name NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')
        AND EXISTS (
            SELECT 1 FROM information_schema.TABLES t 
            WHERE t.TABLE_SCHEMA = s.database_name 
                AND t.TABLE_NAME = s.table_name 
                AND t.ENGINE = 'InnoDB'
        );
    
    -- 显示维护计划
    SELECT 
        '=== 统计信息维护计划 ===' AS title,
        COUNT(*) AS total_tables,
        SUM(CASE WHEN action_needed = 'URGENT_UPDATE' THEN 1 ELSE 0 END) AS urgent_updates,
        SUM(CASE WHEN action_needed = 'SCHEDULED_UPDATE' THEN 1 ELSE 0 END) AS scheduled_updates,
        SUM(CASE WHEN action_needed = 'ROUTINE_UPDATE' THEN 1 ELSE 0 END) AS routine_updates
    FROM temp_maintenance_plan;
    
    -- 执行紧急更新
    BEGIN
        DECLARE update_cursor CURSOR FOR
            SELECT database_name, table_name, action_needed
            FROM temp_maintenance_plan 
            WHERE action_needed = 'URGENT_UPDATE'
            ORDER BY priority, current_rows DESC;
        
        DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
        
        OPEN update_cursor;
        
        update_loop: LOOP
            FETCH update_cursor INTO db_name, tbl_name, maintenance_action;
            IF done THEN
                LEAVE update_loop;
            END IF;
            
            -- 执行统计信息更新
            SET @sql = CONCAT('ANALYZE TABLE ', db_name, '.', tbl_name);
            PREPARE stmt FROM @sql;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;
            
            SELECT CONCAT('已更新: ', db_name, '.', tbl_name, ' (', maintenance_action, ')') AS maintenance_log;
            
        END LOOP;
        
        CLOSE update_cursor;
    END;
    
    DROP TEMPORARY TABLE temp_maintenance_plan;
    SELECT '统计信息自动维护完成!' AS final_status;
END$$
DELIMITER ;
```

### 10.3 性能监控与告警


**📊 统计信息健康度监控**

```sql
-- 创建统计信息健康度检查视图
CREATE VIEW stats_health_monitor AS
SELECT 
    s.database_name,
    s.table_name,
    s.n_rows,
    s.last_update,
    TIMESTAMPDIFF(HOUR, s.last_update, NOW()) AS hours_since_update,
    CASE 
        WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) > 168 THEN 'CRITICAL'
        WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) > 72 THEN 'WARNING'
        WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) > 24 THEN 'INFO'
        ELSE 'OK'
    END AS health_status,
    -- 计算预估的统计信息准确度
    CASE 
        WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) <= 12 THEN '95%+'
        WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) <= 48 THEN '90%+'
        WHEN TIMESTAMPDIFF(HOUR, s.last_update, NOW()) <= 168 THEN '80%+'
        ELSE '<80%'
    END AS estimated_accuracy
FROM mysql.innodb_table_stats s
WHERE s.database_name NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys');

-- 使用监控视图
SELECT * FROM stats_health_monitor 
WHERE health_status IN ('CRITICAL', 'WARNING')
ORDER BY hours_since_update DESC;
```

### 10.4 最佳实践总结


**📋 统计信息管理最佳实践清单**

```
📋 **日常维护检查清单**
- [ ] 定期检查统计信息更新时间（每周）
- [ ] 监控大表的统计信息准确性（每月）  
- [ ] 在大批量数据操作后手动更新统计信息
- [ ] 为不同类型的表设置合适的采样页数
- [ ] 建立统计信息更新的监控告警机制

📋 **性能优化检查清单**
- [ ] 核心业务表采用较高的采样页数（50-200页）
- [ ] 数据倾斜严重的表定期手动更新
- [ ] 建立定期的统计信息维护任务
- [ ] 在系统负载较低时执行统计信息更新
- [ ] 监控执行计划的稳定性

📋 **问题排查检查清单**
- [ ] 查询性能下降时首先检查统计信息
- [ ] 对比统计信息更新前后的执行计划
- [ ] 验证统计信息与实际数据的匹配度
- [ ] 检查是否有统计信息锁定的表
- [ ] 分析自动更新触发条件是否合理
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 统计信息作用：为查询优化器提供数据分布信息，影响执行计划选择
🔸 存储机制：MySQL 5.6+支持持久化，存储在mysql.innodb_table_stats和mysql.innodb_index_stats表中
🔸 采样原理：通过随机采样页面估算统计信息，平衡准确性与性能
🔸 自动触发：当表变化超过10%+2000行时自动更新统计信息
🔸 手动控制：通过ANALYZE TABLE手动更新，通过参数控制自动更新
```

### 11.2 关键理解要点


**🔹 为什么统计信息如此重要**
```
影响链条：
统计信息准确性 ──→ 执行计划选择 ──→ 查询性能

具体体现：
• 准确的行数估算 → 正确选择索引或全表扫描
• 准确的选择性信息 → 正确选择索引使用顺序
• 准确的数据分布 → 正确估算JOIN操作成本

性能差异：
统计信息准确：查询耗时毫秒级
统计信息过时：查询耗时可能增加10-100倍
```

**🔹 采样机制的权衡**
```
准确性 vs 性能权衡：

精确统计（全表扫描）：
优点：100%准确
缺点：大表可能需要数小时

采样统计：
优点：快速完成（秒级）
缺点：有一定误差（通常5-10%）

实践选择：
• 小表：采样页数可以少一些
• 大表：需要足够的采样页数保证准确性
• 关键表：可以设置更多采样页数
```

**🔹 自动更新机制的设计逻辑**
```
触发阈值设计考虑：
• 太频繁更新：影响系统性能
• 更新太少：统计信息过时

MySQL的解决方案：
变化阈值 = 表总行数 × 10% + 2000

这个公式的巧妙之处：
• 小表（<2万行）：主要看绝对变化量（2000行）
• 大表（>2万行）：主要看相对变化比例（10%）
• 保证了小表和大表都有合适的更新频率
```

### 11.3 实际应用指导


**🎯 不同规模系统的管理策略**

```
小型系统（<100万行数据）：
策略：使用默认配置，开启自动更新
配置：innodb_stats_auto_recalc = ON, sample_pages = 20
维护：每月检查一次统计信息健康度

中型系统（100万-1000万行）：
策略：提高采样精度，定期手动维护  
配置：sample_pages = 50-100，部分表手动控制
维护：每周检查，关键表每天检查

大型系统（>1000万行）：
策略：分层管理，核心表精细控制
配置：按表定制化设置，建立自动维护脚本
维护：实时监控，自动化维护流程
```

**🔧 常见问题处理流程**

```
问题：查询突然变慢
步骤1：检查执行计划是否改变
    EXPLAIN SELECT ...
步骤2：检查统计信息更新时间
    SELECT * FROM mysql.innodb_table_stats WHERE ...
步骤3：对比统计信息与实际数据
    SELECT COUNT(*) FROM table_name;
步骤4：手动更新统计信息
    ANALYZE TABLE table_name;
步骤5：验证问题是否解决
    再次执行查询并查看执行计划

问题：统计信息不准确
步骤1：增加采样页数
    ALTER TABLE xxx STATS_SAMPLE_PAGES = 100;
步骤2：强制更新统计信息
    ANALYZE TABLE xxx;
步骤3：验证准确性
    对比统计值与实际值
步骤4：如需要，考虑锁定统计信息
    ALTER TABLE xxx STATS_AUTO_RECALC = 0;
```

**🛠️ 维护脚本模板**

```sql
-- 每日统计信息健康检查脚本
SELECT 
    CONCAT('数据库: ', database_name, ', 表: ', table_name) AS table_info,
    CONCAT('行数: ', FORMAT(n_rows, 0)) AS row_count,
    CONCAT('最后更新: ', last_update) AS last_update,
    CONCAT('小时前: ', TIMESTAMPDIFF(HOUR, last_update, NOW())) AS hours_ago,
    CASE 
        WHEN TIMESTAMPDIFF(HOUR, last_update, NOW()) > 72 THEN '需要更新'
        WHEN TIMESTAMPDIFF(HOUR, last_update, NOW()) > 24 THEN '建议更新' 
        ELSE '状态正常'
    END AS recommendation
FROM mysql.innodb_table_stats 
WHERE database_name = 'your_database'
ORDER BY TIMESTAMPDIFF(HOUR, last_update, NOW()) DESC;
```

### 11.4 进阶优化技巧


**🚀 高级优化策略**

```
🔸 统计信息分层管理
一级表（核心业务）：
• 采样页数200+，手动控制更新
• 每天检查，实时监控执行计划变化

二级表（重要业务）：
• 采样页数50-100，半自动管理
• 每周检查，定期更新

三级表（辅助数据）：
• 采样页数20-50，自动管理
• 每月检查，按需更新

🔸 智能触发机制
• 根据业务高峰期调整更新时机
• 结合查询性能监控，主动发现统计信息问题
• 建立统计信息质量评估体系
```

**🧠 记忆技巧**

```
🎵 **统计信息管理口诀**
"采样估算是基础，准确性和性能要平衡
自动更新有阈值，手动控制更精确
监控检查不能少，问题发现要及时"

🏷️ **核心关键词记忆**
`采样页数` `自动触发` `手动更新` `执行计划` `健康监控`
```

**核心记忆**：
- InnoDB统计信息是查询优化器的"眼睛"，直接影响执行计划选择
- 采样机制平衡了准确性与性能，需要根据业务需求调整采样页数
- 自动更新机制有智能的触发阈值，但关键业务表建议手动控制
- 统计信息维护是数据库性能优化的重要组成部分，需要建立常态化的监控和维护机制
- 问题排查时，统计信息是优先检查的重点项目之一