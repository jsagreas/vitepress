---
title: 25、InnoDB统计信息机制
---
## 📚 目录

1. [统计信息基础概念](#1-统计信息基础概念)
2. [统计信息类型详解](#2-统计信息类型详解)
3. [持久化统计信息机制](#3-持久化统计信息机制)
4. [统计信息更新策略](#4-统计信息更新策略)
5. [采样算法与准确性](#5-采样算法与准确性)
6. [优化器使用统计信息](#6-优化器使用统计信息)
7. [统计信息监控与维护](#7-统计信息监控与维护)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 统计信息基础概念


### 1.1 什么是统计信息


**🔸 通俗理解**
统计信息就像给数据库做"体检报告"，记录每个表的基本情况：
- **有多少数据**：表里有多少行记录
- **数据分布**：每个字段的值是如何分布的
- **索引情况**：索引的选择性怎么样
- **更新频率**：数据变化的频繁程度

**💡 生活中的类比**
```
就像超市管理者需要知道：
• 商品种类和数量 (表行数)
• 热销商品分布 (数据分布)
• 库存变化趋势 (更新频率)

这些信息帮助决定：
• 进货策略 (查询计划)
• 货架布局 (索引策略)
• 促销方案 (优化策略)
```

### 1.2 统计信息的作用机制


**🎯 核心作用：帮助查询优化器选择最佳执行计划**

```
查询优化过程：
SQL查询 → 解析器 → 优化器 → 执行器

优化器决策依据：
├─ 表的行数统计
├─ 索引的选择性
├─ 数据分布直方图
└─ 字段值的范围信息

决策结果：
• 选择哪个索引
• 表连接顺序
• 是否使用临时表
• 排序算法选择
```

### 1.3 没有统计信息的后果


**❌ 问题示例**
```sql
-- 假设有两个表：
-- users表：1000万行
-- orders表：100行

-- 查询语句
SELECT * FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE o.status = 'active';

-- 如果统计信息不准确：
-- 优化器可能认为orders表很大，users表很小
-- 选择错误的连接顺序：users作为驱动表
-- 结果：性能极差，查询超时
```

---

## 2. 📈 统计信息类型详解


### 2.1 基础统计信息类型


**📊 表级统计信息**
```
Table Statistics (表统计信息)：
• n_rows：表的总行数
• clustered_index_size：聚簇索引大小
• sum_of_other_index_sizes：其他索引总大小
• data_free：可用空间大小
• auto_increment：自增值

查看方式：
SELECT table_name, table_rows, data_length, index_length
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

**📊 索引级统计信息**
```
Index Statistics (索引统计信息)：
• cardinality：索引基数（不重复值的数量）
• stat_name：统计项名称
• stat_value：统计值
• stat_description：统计描述

查看方式：
SELECT index_name, cardinality, is_visible
FROM information_schema.statistics
WHERE table_name = 'your_table';
```

**📊 列级统计信息**
```
Column Statistics (列统计信息)：
• n_distinct：不同值的数量
• null_frac：NULL值的比例
• avg_col_len：列的平均长度
• histogram：数据分布直方图

查看方式：
SELECT column_name, cardinality 
FROM information_schema.key_column_usage 
WHERE table_name = 'your_table';
```

### 2.2 直方图Histogram深入解析


**🔸 什么是直方图**
直方图记录数据在不同值区间的分布情况，就像人口年龄分布图：
- **等频直方图**：每个桶包含相同数量的行
- **等宽直方图**：每个桶覆盖相同的值范围

```
年龄分布示例：
桶1：[18-25] 占25%
桶2：[26-35] 占35% 
桶3：[36-45] 占30%
桶4：[46-60] 占10%

对应SQL查询优化：
WHERE age BETWEEN 26 AND 35  ← 优化器知道这会匹配35%的数据
```

**📊 直方图类型对比**

| 直方图类型 | **工作原理** | **适用场景** | **优缺点** |
|------------|-------------|-------------|-----------|
| **等频(EQUI-HEIGHT)** | `每个桶相同行数` | `数据分布不均匀` | `准确性高，存储开销大` |
| **等宽(EQUI-WIDTH)** | `每个桶相同值范围` | `数据分布较均匀` | `存储省，可能不够准确` |

**🔧 直方图操作示例**
```sql
-- 查看表的直方图信息
SELECT schema_name, table_name, column_name, 
       histogram->>'$.buckets' as buckets
FROM information_schema.column_statistics;

-- 手动生成直方图
ANALYZE TABLE your_table UPDATE HISTOGRAM ON column_name WITH 10 BUCKETS;

-- 删除直方图
ANALYZE TABLE your_table DROP HISTOGRAM ON column_name;

-- 查看直方图统计
SELECT table_name, column_name, 
       JSON_EXTRACT(histogram, '$.number-of-buckets-specified') as buckets
FROM information_schema.column_statistics;
```

---

## 3. 💾 持久化统计信息机制


### 3.1 统计信息存储位置


**🗄️ 存储架构**
```
MySQL 5.6之前：
内存中存储 → 重启后丢失 → 需要重新收集

MySQL 5.6之后：
持久化存储 → 系统表保存 → 重启后保持
```

**📍 存储位置详解**
```sql
-- 主要存储表
mysql.innodb_table_stats     -- 表级统计信息
mysql.innodb_index_stats     -- 索引级统计信息  
information_schema.column_statistics  -- 列统计和直方图

-- 查看持久化统计信息
SELECT database_name, table_name, n_rows, clustered_index_size
FROM mysql.innodb_table_stats;

SELECT database_name, table_name, index_name, stat_name, stat_value
FROM mysql.innodb_index_stats;
```

### 3.2 持久化配置参数


**⚙️ 关键配置参数**
```sql
-- 启用持久化统计信息
SET GLOBAL innodb_stats_persistent = ON;

-- 统计信息采样页数
SET GLOBAL innodb_stats_persistent_sample_pages = 20;

-- 自动重新计算统计信息
SET GLOBAL innodb_stats_auto_recalc = ON;

-- 查看当前配置
SHOW VARIABLES LIKE 'innodb_stats%';
```

**🔧 配置说明**
```
innodb_stats_persistent = ON/OFF
• ON：统计信息持久化保存
• OFF：使用瞬时统计信息（重启丢失）

innodb_stats_persistent_sample_pages = 数值
• 控制统计信息采样的页面数
• 数值越大，统计越准确，但收集时间越长
• 默认：20页

innodb_stats_auto_recalc = ON/OFF  
• ON：表数据变化超过10%时自动更新统计信息
• OFF：需要手动触发更新
```

### 3.3 表级统计信息配置


**🔧 单表配置示例**
```sql
-- 创建表时配置统计信息策略
CREATE TABLE user_orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    order_date DATE,
    amount DECIMAL(10,2),
    INDEX idx_user_date (user_id, order_date)
) ENGINE=InnoDB 
  STATS_PERSISTENT=1
  STATS_AUTO_RECALC=1
  STATS_SAMPLE_PAGES=50;

-- 修改现有表的统计信息配置
ALTER TABLE user_orders 
  STATS_PERSISTENT=1,
  STATS_AUTO_RECALC=0,  
  STATS_SAMPLE_PAGES=30;
```

---

## 4. 🔄 统计信息更新策略


### 4.1 自动更新机制详解


**🔸 自动更新触发条件**
```
触发阈值：表行数变化超过10%
计算公式：
当前行数变化 > (统计信息收集时的行数 * 0.1 + 1)

实际示例：
原始行数：10000行
触发阈值：10000 * 0.1 + 1 = 1001行
触发条件：插入/删除超过1001行时自动更新

小表特殊处理：
行数 < 10行：任何变化都触发更新
目的：确保小表统计信息的准确性
```

**⏰ 更新时机策略**
```sql
-- 手动强制更新统计信息
ANALYZE TABLE your_table;

-- 更新指定索引的统计信息
ANALYZE TABLE your_table UPDATE HISTOGRAM ON column_name WITH 20 BUCKETS;

-- 查看最后更新时间
SELECT table_name, update_time 
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

### 4.2 更新策略配置优化


**⚡ 更新策略选择**

| 更新方式 | **触发条件** | **适用场景** | **优缺点** |
|---------|------------|-------------|----------|
| **自动更新** | `数据变化>10%` | `OLTP系统，数据变化频繁` | `及时准确，可能影响性能` |
| **定时更新** | `定时任务触发` | `OLAP系统，批量数据处理` | `可控性强，可能不够及时` |
| **手动更新** | `人工执行命令` | `关键查询前，重要维护` | `最精确，需要人工干预` |

**📅 定时更新实践**
```sql
-- 设置定时更新策略
SET GLOBAL event_scheduler = ON;

-- 创建定时更新事件
CREATE EVENT update_table_stats
ON SCHEDULE EVERY 1 DAY STARTS '2025-01-20 02:00:00'
DO
BEGIN
    ANALYZE TABLE orders, users, products;
    -- 记录更新日志
    INSERT INTO stats_update_log (update_time, tables_updated) 
    VALUES (NOW(), 'orders,users,products');
END;

-- 查看定时事件状态
SHOW EVENTS;
```

### 4.3 批量更新优化策略


**🚀 批量数据处理场景**
```sql
-- 批量导入前关闭自动更新
ALTER TABLE bulk_import_table STATS_AUTO_RECALC=0;

-- 执行批量导入
LOAD DATA INFILE '/data/bulk_data.csv' 
INTO TABLE bulk_import_table;

-- 导入完成后手动更新统计信息
ANALYZE TABLE bulk_import_table;

-- 重新启用自动更新
ALTER TABLE bulk_import_table STATS_AUTO_RECALC=1;
```

---

## 5. 🔍 采样算法与准确性


### 5.1 采样算法工作原理


**🔸 统计信息收集算法**
InnoDB采用随机采样法收集统计信息：
- **随机选择页面**：从表中随机选择N个数据页
- **统计页面信息**：计算每个页面的行数和索引信息
- **估算总体情况**：根据样本推算整表统计信息

```
采样过程图解：

表总共1000页                   随机选择20页
┌───────────────────┐         ┌─────────────┐
│ Page1  Page2 ...  │   →     │ Page15 ...  │
│ Page3  Page4 ...  │  采样    │ Page67 ...  │ 
│ ...    ...   ...  │         │ Page234 ... │
│ Page999 Page1000  │         │ Page890 ... │
└───────────────────┘         └─────────────┘
        ↓                           ↓
    全表数据                    样本统计
   (100万行)                 → 推算全表
                              (估算99.8万行)
```

### 5.2 采样精度控制


**🎛️ 采样参数调优**
```sql
-- 查看采样配置
SHOW VARIABLES LIKE 'innodb_stats_persistent_sample_pages';

-- 调整采样页数（全局）
SET GLOBAL innodb_stats_persistent_sample_pages = 50;

-- 单表采样配置
ALTER TABLE important_table STATS_SAMPLE_PAGES=100;
```

**📊 采样页数对准确性的影响**

| 采样页数 | **准确性** | **收集时间** | **适用场景** |
|---------|-----------|-------------|-------------|
| **10页** | `70-80%` | `很快` | `小表，要求不高` |
| **20页(默认)** | `85-90%` | `适中` | `一般业务表` |
| **50页** | `95-98%` | `较慢` | `重要查询表` |
| **100页+** | `99%+` | `很慢` | `关键业务表` |

### 5.3 统计信息准确性评估


**🔍 准确性检查方法**
```sql
-- 对比统计信息与实际数据
SELECT 
    t.table_name,
    t.table_rows as stat_rows,          -- 统计信息中的行数
    (SELECT COUNT(*) FROM your_table) as actual_rows,  -- 实际行数
    ROUND(t.table_rows / (SELECT COUNT(*) FROM your_table) * 100, 2) as accuracy_percent
FROM information_schema.tables t
WHERE t.table_name = 'your_table';

-- 检查索引基数准确性
SELECT 
    index_name,
    cardinality as stat_cardinality,
    (SELECT COUNT(DISTINCT column_name) FROM your_table) as actual_cardinality
FROM information_schema.statistics 
WHERE table_name = 'your_table';
```

**⚠️ 准确性影响因素**
```
影响准确性的因素：
• 采样页数：页数越多越准确
• 数据分布：均匀分布比倾斜分布准确
• 表大小：大表比小表统计更准确  
• 更新频率：频繁更新的表可能不准确

准确性阈值建议：
• > 95%：统计信息可信
• 80-95%：基本可用，可考虑增加采样
• < 80%：需要手动更新或调整采样策略
```

---

## 6. ⚙️ 优化器使用统计信息


### 6.1 查询计划选择机制


**🧠 优化器决策过程**
```
步骤1：收集可用信息
• 表行数统计
• 索引选择性
• WHERE条件分析
• JOIN表关系

步骤2：计算访问成本
• 全表扫描成本 = 表页数 × 页读取成本
• 索引扫描成本 = 索引页数 × 索引成本 + 回表成本
• JOIN成本 = 驱动表成本 × 被驱动表单次查找成本

步骤3：选择最优计划
• 比较各种执行方案的成本
• 选择总成本最低的执行计划

步骤4：生成执行计划
• 确定索引使用策略
• 确定表连接顺序
• 确定具体执行步骤
```

### 6.2 统计信息对执行计划的影响


**📋 实际案例分析**
```sql
-- 案例表结构
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    status VARCHAR(20),
    create_time DATETIME,
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_create_time (create_time)
);

-- 查询语句
SELECT * FROM orders 
WHERE user_id = 12345 AND status = 'completed';

-- 情况1：统计信息显示user_id选择性高
-- 执行计划：使用idx_user_id索引
EXPLAIN: Using index idx_user_id; rows examined: 10

-- 情况2：统计信息显示status选择性高  
-- 执行计划：使用idx_status索引
EXPLAIN: Using index idx_status; rows examined: 100

-- 情况3：统计信息不准确
-- 执行计划：全表扫描
EXPLAIN: Full table scan; rows examined: 1000000
```

### 6.3 执行计划验证


**🔍 分析执行计划质量**
```sql
-- 查看详细执行计划
EXPLAIN FORMAT=JSON 
SELECT * FROM orders 
WHERE user_id = 12345 AND status = 'completed';

-- 关键指标分析：
-- "rows_examined_per_scan"：扫描行数
-- "rows_produced_per_join"：产出行数  
-- "cost_info"：成本信息
-- "used_key_parts"：使用的索引部分

-- 验证统计信息准确性
SELECT 
    (SELECT COUNT(*) FROM orders WHERE user_id = 12345) as actual_user_rows,
    (SELECT COUNT(*) FROM orders WHERE status = 'completed') as actual_status_rows;
```

---

## 7. 📊 统计信息监控与维护


### 7.1 统计信息监控方法


**🔍 监控关键指标**
```sql
-- 监控统计信息更新频率
SELECT table_name, 
       n_rows,
       last_update,
       TIMESTAMPDIFF(HOUR, last_update, NOW()) as hours_since_update
FROM mysql.innodb_table_stats
WHERE database_name = 'your_database'
ORDER BY hours_since_update DESC;

-- 监控直方图状态  
SELECT schema_name, table_name, column_name,
       JSON_EXTRACT(histogram, '$.last-updated') as last_updated
FROM information_schema.column_statistics;

-- 查看异常统计信息
SELECT table_name, n_rows, clustered_index_size,
       ROUND(clustered_index_size / n_rows, 2) as bytes_per_row
FROM mysql.innodb_table_stats
WHERE n_rows > 0 
HAVING bytes_per_row > 1000 OR bytes_per_row < 10;
```

### 7.2 性能影响评估


**⚡ 统计信息对性能的影响**
```sql
-- 监控因统计信息导致的执行计划变化
SELECT digest_text, count_star, avg_timer_wait,
       sum_rows_examined / count_star as avg_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE digest_text LIKE '%your_critical_query%'
ORDER BY last_seen DESC;

-- 对比更新前后的查询性能
-- 更新前记录
SELECT NOW() as check_time, 'before_update' as phase,
       count_star, avg_timer_wait
FROM performance_schema.events_statements_summary_by_digest  
WHERE digest_text = 'your_query_digest';

-- 更新统计信息
ANALYZE TABLE your_table;

-- 更新后检查
-- (重复上述查询，对比结果)
```

### 7.3 维护最佳实践


**📋 维护检查清单**

- [ ] **定期检查**：每周检查统计信息准确性
- [ ] **性能监控**：监控关键查询的执行计划变化
- [ ] **异常告警**：统计信息准确性低于80%时告警
- [ ] **批量更新**：大量数据变更后及时更新统计信息
- [ ] **版本升级**：MySQL版本升级后重新收集统计信息

**🛠️ 维护脚本示例**
```bash
#!/bin/bash
# 统计信息健康检查脚本

# 检查准确性低于85%的表
mysql -e "
SELECT t.table_name,
       t.table_rows as stat_rows,
       actual.actual_rows,
       ROUND(t.table_rows / actual.actual_rows * 100, 2) as accuracy
FROM information_schema.tables t
JOIN (
    SELECT 'your_table' as table_name, COUNT(*) as actual_rows FROM your_table
    UNION ALL
    SELECT 'another_table' as table_name, COUNT(*) as actual_rows FROM another_table
) actual ON t.table_name = actual.table_name
WHERE t.table_schema = 'your_database'
HAVING accuracy < 85 OR accuracy > 115;
"

# 对准确性差的表更新统计信息
mysql -e "ANALYZE TABLE low_accuracy_table1, low_accuracy_table2;"
```

### 7.4 故障排查指南


**🔧 常见问题与解决方法**

```sql
-- 问题1：查询突然变慢
-- 排查步骤：
-- 1. 检查执行计划是否改变
EXPLAIN FORMAT=JSON your_slow_query;

-- 2. 检查统计信息是否过期
SELECT table_name, last_update, n_rows
FROM mysql.innodb_table_stats
WHERE table_name = 'problematic_table';

-- 3. 手动更新统计信息测试
ANALYZE TABLE problematic_table;

-- 问题2：统计信息更新过于频繁影响性能
-- 解决方案：关闭自动更新，改为定时更新
ALTER TABLE high_traffic_table STATS_AUTO_RECALC=0;

-- 问题3：小表统计信息不准确
-- 解决方案：强制全量采样
ALTER TABLE small_table STATS_SAMPLE_PAGES=0;  -- 0表示全量采样
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 统计信息本质：数据库的"健康档案"，帮助优化器做决策
🔸 统计信息类型：表级、索引级、列级三层统计体系
🔸 持久化机制：MySQL 5.6后统计信息可持久保存，重启不丢失
🔸 直方图技术：记录数据分布，提高优化器决策准确性
🔸 更新策略：自动更新+手动更新，平衡准确性与性能
🔸 采样算法：通过随机采样估算全表统计，可配置采样精度
🔸 监控维护：定期检查准确性，及时更新过期统计信息
```

### 8.2 关键理解要点


**🔹 统计信息的重要性**
```
决策依据：
• 优化器选择执行计划的核心依据
• 直接影响查询性能的关键因素
• 数据库自动优化的基础

准确性影响：
• 准确统计 → 最优执行计划 → 高性能查询
• 不准确统计 → 错误执行计划 → 性能问题
• 完全无统计 → 盲目猜测 → 性能灾难
```

**🔹 持久化的价值**
```
解决的问题：
• 重启丢失：MySQL重启后统计信息保持
• 一致性：所有节点使用相同的统计信息
• 稳定性：避免统计信息波动导致执行计划频繁变化

带来的好处：
• 查询性能更稳定
• 减少统计信息重新收集时间
• 便于问题诊断和性能调优
```

**🔹 采样与准确性的平衡**
```
关键平衡：
准确性 vs 性能开销
• 更多采样 → 更准确 → 更多CPU和IO开销
• 更少采样 → 更快 → 可能不够准确

实际策略：
• 关键表：增加采样页数，保证准确性
• 一般表：使用默认配置，平衡性能
• 临时表：可以关闭统计信息收集
```

### 8.3 实际应用指导


**💡 配置建议**
- ✅ **启用持久化**：生产环境必须开启统计信息持久化
- ✅ **合理采样**：根据表重要性调整采样页数
- ✅ **监控准确性**：定期检查统计信息与实际数据的偏差
- ✅ **及时更新**：大批量数据操作后手动更新统计信息

**🚨 注意事项**
- ⚠️ **更新时机**：避免在业务高峰期更新统计信息
- ⚠️ **资源消耗**：大表统计信息更新会消耗较多CPU和IO
- ⚠️ **执行计划变化**：统计信息更新可能导致执行计划突变
- ⚠️ **锁影响**：统计信息收集期间可能影响并发性能

### 8.4 故障预防策略


**🛡️ 预防措施**
```
定期维护：
① 每周检查统计信息准确性
② 每月全面更新关键表统计信息  
③ 每季度评估采样策略效果

监控告警：
① 查询性能突然下降告警
② 执行计划异常变化告警
③ 统计信息准确性低于阈值告警

应急预案：
① 准备快速回滚统计信息的方法
② 建立手动更新的标准流程
③ 准备性能问题的快速诊断手册
```

**核心记忆**：
- 统计信息是优化器的"眼睛"，没有它就是盲人摸象
- 持久化统计信息解决了重启丢失的痛点问题
- 直方图让优化器更精准地了解数据分布特征
- 采样算法在准确性和性能间找到最佳平衡点
- 定期维护统计信息是保证数据库性能稳定的关键