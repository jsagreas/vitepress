---
title: 6、RBAC访问控制
---
## 📚 目录导航

1. [基于角色访问控制概述](#1-基于角色访问控制概述)
2. [用户角色映射机制](#2-用户角色映射机制)
3. [权限矩阵设计与实现](#3-权限矩阵设计与实现)
4. [最小权限原则应用](#4-最小权限原则应用)
5. [职责分离SOD机制](#5-职责分离sod机制)
6. [高级访问控制模型](#6-高级访问控制模型)
7. [权限管理工具与实践](#7-权限管理工具与实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 基于角色访问控制概述


### 1.1 什么是RBAC


**RBAC（Role-Based Access Control）**是一种将权限分配给角色，再将角色分配给用户的访问控制方法。

**🌰 生活类比**：
想象一家公司的门禁系统：
- 不是给每个员工单独配置门禁权限
- 而是设置"经理"、"员工"、"保安"等角色
- 每个角色有固定的门禁范围
- 员工入职时只需要分配对应角色即可

### 1.2 传统权限管理的问题


```
传统方式：直接给用户分配权限
用户张三 → [查看订单, 修改订单, 删除订单, 查看用户...]
用户李四 → [查看订单, 修改订单, 删除订单, 查看用户...]
用户王五 → [查看订单, 修改订单, 删除订单, 查看用户...]

问题：
❌ 权限分配重复劳动
❌ 权限变更需要逐个修改
❌ 难以统一管理和审计
❌ 容易出现权限不一致
```

### 1.3 RBAC的核心优势


**🔸 简化管理**
- 通过角色间接管理权限，减少管理复杂度
- 新员工入职只需分配角色，无需逐项配置权限

**🔸 权限一致性**
- 同一角色的用户拥有相同权限
- 避免权限分配不一致的问题

**🔸 易于审计**
- 清晰的角色权限关系便于安全审计
- 权限变更有明确的追踪路径

### 1.4 RBAC模型基本结构


```
用户(Users) ←→ 角色(Roles) ←→ 权限(Permissions)
     │              │              │
   张三           销售经理        查看客户信息
   李四           财务专员        修改订单状态
   王五           系统管理员      管理用户账户
```

**核心关系**：
- **用户-角色**：多对多关系（一个用户可以有多个角色）
- **角色-权限**：多对多关系（一个角色可以有多个权限）
- **用户-权限**：通过角色间接获得权限

---

## 2. 👥 用户角色映射机制


### 2.1 用户角色映射的本质


用户角色映射就是建立"用户"和"角色"之间的对应关系，解决"谁具有什么身份"的问题。

**🔸 映射关系类型**
```
一对一映射：一个用户只能有一个角色
张三 → 销售员

一对多映射：一个用户可以有多个角色  
李四 → [销售经理, 产品专员]

多对一映射：多个用户共享同一角色
[王五, 赵六] → 客服代表

多对多映射：最灵活的映射关系
张三 → [销售员, 客服代表]
李四 → [销售经理, 产品专员]
```

### 2.2 MySQL中的用户角色实现


##### 2.2.1 创建角色


```sql
-- 创建业务角色
CREATE ROLE 'sales_manager';      -- 销售经理角色
CREATE ROLE 'finance_staff';      -- 财务人员角色
CREATE ROLE 'customer_service';   -- 客服角色
```

##### 2.2.2 为角色分配权限


```sql
-- 给销售经理角色分配权限
GRANT SELECT, INSERT, UPDATE ON sales.customers TO 'sales_manager';
GRANT SELECT ON sales.orders TO 'sales_manager';

-- 给财务人员分配权限
GRANT SELECT ON finance.accounts TO 'finance_staff';
GRANT UPDATE ON sales.payment_status TO 'finance_staff';
```

##### 2.2.3 将角色分配给用户


```sql
-- 创建用户并分配角色
CREATE USER 'zhang_san'@'%' IDENTIFIED BY 'password123';
GRANT 'sales_manager' TO 'zhang_san'@'%';

-- 一个用户分配多个角色
CREATE USER 'li_si'@'%' IDENTIFIED BY 'password456';
GRANT 'sales_manager', 'customer_service' TO 'li_si'@'%';
```

### 2.3 角色激活与切换


```sql
-- 查看当前角色
SELECT CURRENT_ROLE();

-- 激活指定角色
SET ROLE 'sales_manager';

-- 激活所有角色
SET ROLE ALL;

-- 切换到不同角色
SET ROLE 'customer_service';
```

**💡 实用场景**：
一个用户可能同时是"销售经理"和"客服代表"，但在处理客户投诉时，只需要激活"客服代表"角色的权限。

### 2.4 角色继承机制


```sql
-- 创建角色层次
CREATE ROLE 'employee';           -- 基础员工角色
CREATE ROLE 'supervisor';         -- 主管角色
CREATE ROLE 'manager';            -- 经理角色

-- 建立角色继承关系
GRANT 'employee' TO 'supervisor';      -- 主管继承员工权限
GRANT 'supervisor' TO 'manager';       -- 经理继承主管权限
```

**角色继承图**：
```
manager
  │
  └── supervisor  
        │
        └── employee
```

---

## 3. 📊 权限矩阵设计与实现


### 3.1 权限矩阵的概念


权限矩阵是一个二维表格，清晰展示"谁对什么资源有什么操作权限"。

**🔸 矩阵结构**
```
          │ 查看客户 │ 修改客户 │ 删除客户 │ 查看订单 │ 修改订单
──────────┼─────────┼─────────┼─────────┼─────────┼─────────
销售员     │    ✅   │    ✅   │    ❌   │    ✅   │    ❌
销售经理   │    ✅   │    ✅   │    ✅   │    ✅   │    ✅
财务专员   │    ❌   │    ❌   │    ❌   │    ✅   │    ❌
客服代表   │    ✅   │    ❌   │    ❌   │    ✅   │    ❌
```

### 3.2 权限矩阵构建方法


##### 3.2.1 识别资源和操作


```sql
-- 资源识别（数据库表）
- customers（客户表）
- orders（订单表）  
- products（产品表）
- payments（支付表）

-- 操作识别（数据库操作）
- SELECT（查看）
- INSERT（新增）
- UPDATE（修改）
- DELETE（删除）
```

##### 3.2.2 定义业务角色


```sql
-- 根据业务需求定义角色
CREATE ROLE 'sales_rep';          -- 销售代表
CREATE ROLE 'sales_manager';      -- 销售经理
CREATE ROLE 'finance_clerk';      -- 财务文员
CREATE ROLE 'finance_manager';    -- 财务经理
CREATE ROLE 'customer_support';   -- 客户支持
```

##### 3.2.3 构建权限映射


```sql
-- 销售代表权限
GRANT SELECT, INSERT, UPDATE ON crm.customers TO 'sales_rep';
GRANT SELECT, INSERT ON crm.orders TO 'sales_rep';

-- 销售经理权限（继承销售代表 + 额外权限）
GRANT 'sales_rep' TO 'sales_manager';
GRANT DELETE ON crm.customers TO 'sales_manager';
GRANT UPDATE, DELETE ON crm.orders TO 'sales_manager';

-- 财务权限
GRANT SELECT ON crm.orders TO 'finance_clerk';
GRANT SELECT, UPDATE ON crm.payments TO 'finance_clerk';
```

### 3.3 权限矩阵实现示例


##### 3.3.1 创建权限管理表


```sql
-- 权限定义表
CREATE TABLE permissions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    resource VARCHAR(50) NOT NULL,     -- 资源名称
    action VARCHAR(20) NOT NULL,       -- 操作类型
    description VARCHAR(100)           -- 权限描述
);

-- 角色权限关联表
CREATE TABLE role_permissions (
    role_name VARCHAR(50),
    permission_id INT,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (role_name, permission_id)
);
```

##### 3.3.2 权限矩阵查询


```sql
-- 查看角色权限矩阵
SELECT 
    r.role_name,
    p.resource,
    p.action,
    CASE WHEN rp.permission_id IS NOT NULL THEN '✅' ELSE '❌' END AS has_permission
FROM 
    (SELECT DISTINCT role_name FROM role_permissions) r
CROSS JOIN 
    permissions p
LEFT JOIN 
    role_permissions rp ON r.role_name = rp.role_name AND p.id = rp.permission_id
ORDER BY 
    r.role_name, p.resource, p.action;
```

---

## 4. 🔒 最小权限原则应用


### 4.1 最小权限原则的含义


**最小权限原则**：每个用户和程序只应该拥有完成其任务所必需的最少权限，不多给一分权限。

**🌰 生活类比**：
就像给员工配发钥匙：
- 清洁工只需要办公区域的钥匙
- 不需要给财务室、服务器机房的钥匙
- 即使他"可能"需要进去打扫

### 4.2 权限最小化策略


##### 4.2.1 按需分配权限


```sql
-- ❌ 错误做法：给予过多权限
GRANT ALL PRIVILEGES ON *.* TO 'app_user'@'%';

-- ✅ 正确做法：精确权限分配
GRANT SELECT, INSERT, UPDATE ON shop.orders TO 'order_service'@'%';
GRANT SELECT ON shop.products TO 'order_service'@'%';
```

##### 4.2.2 细粒度权限控制


```sql
-- 列级权限控制
GRANT SELECT (order_id, customer_id, amount) ON orders TO 'report_user';
-- 不授予敏感字段如customer_phone, customer_address

-- 条件权限控制（通过视图实现）
CREATE VIEW customer_basic_info AS 
SELECT customer_id, name, email 
FROM customers 
WHERE status = 'active';

GRANT SELECT ON customer_basic_info TO 'customer_service';
```

### 4.3 权限审计与清理


##### 4.3.1 定期权限审计


```sql
-- 查看用户权限
SELECT 
    grantee,
    table_schema,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE grantee LIKE '%app_user%';

-- 查看角色权限
SHOW GRANTS FOR 'sales_manager';
```

##### 4.3.2 清理无用权限


```sql
-- 回收不需要的权限
REVOKE DELETE ON customers FROM 'sales_rep';

-- 回收角色
REVOKE 'admin_role' FROM 'temp_user'@'%';
```

### 4.4 权限分级管理


```
超级管理员 (Super Admin)
    │
    ├── 系统管理员 (System Admin)
    │     ├── 数据库管理员 (DBA)
    │     └── 应用管理员 (App Admin)
    │
    ├── 业务管理员 (Business Admin)
    │     ├── 销售经理 (Sales Manager)
    │     └── 财务经理 (Finance Manager)
    │
    └── 普通用户 (Regular Users)
          ├── 销售代表 (Sales Rep)
          ├── 财务专员 (Finance Clerk)
          └── 客服代表 (Support Rep)
```

---

## 5. ⚖️ 职责分离SOD机制


### 5.1 职责分离的概念


**SOD（Separation of Duties）**：将关键业务流程分解为多个步骤，由不同的人员执行，防止单一人员拥有过大权限。

**🌰 生活类比**：
银行转账业务：
- 柜员负责录入转账信息
- 主管负责审核批准
- 系统自动执行转账
- 三个环节缺一不可，避免内部欺诈

### 5.2 互斥角色设计


##### 5.2.1 角色冲突检测


```sql
-- 创建角色冲突规则表
CREATE TABLE role_conflicts (
    role1 VARCHAR(50),
    role2 VARCHAR(50),
    conflict_reason VARCHAR(200),
    PRIMARY KEY (role1, role2)
);

-- 定义冲突角色
INSERT INTO role_conflicts VALUES 
('cashier', 'auditor', '出纳和审计员不能是同一人'),
('purchaser', 'approver', '采购员和审批员必须分离'),
('developer', 'tester', '开发和测试应该独立');
```

##### 5.2.2 用户角色冲突检查


```sql
-- 检查用户是否有冲突角色
SELECT 
    u.user,
    r1.role AS role1,
    r2.role AS role2,
    rc.conflict_reason
FROM mysql.role_edges r1
JOIN mysql.role_edges r2 ON r1.to_user = r2.to_user
JOIN role_conflicts rc ON (r1.from_user = rc.role1 AND r2.from_user = rc.role2)
WHERE r1.to_user LIKE '%@%'  -- 只检查用户，不检查角色
AND r1.from_user != r2.from_user;
```

### 5.3 审批流程控制


##### 5.3.1 多级审批机制


```sql
-- 审批流程表
CREATE TABLE approval_workflows (
    id INT PRIMARY KEY AUTO_INCREMENT,
    process_name VARCHAR(100),
    step_order INT,
    required_role VARCHAR(50),
    min_approvers INT DEFAULT 1
);

-- 定义审批流程
INSERT INTO approval_workflows VALUES
(1, '大额支付', 1, 'finance_clerk', 1),    -- 第一步：财务专员提交
(2, '大额支付', 2, 'finance_manager', 1),  -- 第二步：财务经理审核
(3, '大额支付', 3, 'general_manager', 1);  -- 第三步：总经理批准
```

##### 5.3.2 权限时效性控制


```sql
-- 临时权限表
CREATE TABLE temporary_grants (
    user_name VARCHAR(50),
    role_name VARCHAR(50),
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    granted_by VARCHAR(50)
);

-- 自动清理过期权限的事件
DELIMITER ;;
CREATE EVENT cleanup_expired_permissions
ON SCHEDULE EVERY 1 HOUR
DO BEGIN
    -- 回收过期的临时权限
    DECLARE done INT DEFAULT FALSE;
    DECLARE user_var VARCHAR(50);
    DECLARE role_var VARCHAR(50);
    
    DECLARE cur CURSOR FOR 
        SELECT user_name, role_name 
        FROM temporary_grants 
        WHERE expires_at < NOW();
    
    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO user_var, role_var;
        IF done THEN LEAVE read_loop; END IF;
        
        SET @sql = CONCAT('REVOKE ', role_var, ' FROM ', user_var);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    CLOSE cur;
    
    -- 清理记录
    DELETE FROM temporary_grants WHERE expires_at < NOW();
END;;
DELIMITER ;
```

---

## 6. 🔄 高级访问控制模型


### 6.1 ABAC属性访问控制


**ABAC（Attribute-Based Access Control）**：基于属性的访问控制，考虑用户属性、资源属性、环境属性等多维度信息。

##### 6.1.1 ABAC vs RBAC对比


| 特性 | **RBAC** | **ABAC** |
|------|----------|----------|
| **控制粒度** | `基于角色` | `基于多维属性` |
| **灵活性** | `中等` | `极高` |
| **复杂度** | `简单` | `复杂` |
| **适用场景** | `标准化流程` | `动态复杂场景` |

##### 6.1.2 ABAC属性示例


```sql
-- 用户属性表
CREATE TABLE user_attributes (
    user_id INT,
    attribute_name VARCHAR(50),
    attribute_value VARCHAR(100),
    effective_date DATE,
    expiry_date DATE
);

-- 示例数据
INSERT INTO user_attributes VALUES
(1, 'department', 'sales', '2024-01-01', '2024-12-31'),
(1, 'clearance_level', 'level_2', '2024-01-01', '2024-12-31'),
(1, 'work_location', 'beijing', '2024-01-01', '2024-12-31');
```

##### 6.1.3 基于属性的访问策略


```sql
-- 策略规则表
CREATE TABLE access_policies (
    id INT PRIMARY KEY AUTO_INCREMENT,
    policy_name VARCHAR(100),
    resource_pattern VARCHAR(100),
    action_type VARCHAR(50),
    condition_sql TEXT,
    effect ENUM('ALLOW', 'DENY')
);

-- 示例策略
INSERT INTO access_policies VALUES
(1, '部门数据访问', 'customer_data', 'SELECT', 
 'user_department = resource_department', 'ALLOW'),
(2, '工作时间限制', '*', '*',
 'HOUR(NOW()) BETWEEN 9 AND 18', 'ALLOW'),
(3, '地理位置限制', 'sensitive_data', '*',
 'user_location = approved_location', 'ALLOW');
```

### 6.2 混合访问控制模型


##### 6.2.1 RBAC + ABAC混合模型


```
基础权限层（RBAC）：
└── 销售经理角色 → 基础客户数据访问权限

属性增强层（ABAC）：
├── 部门属性 → 只能访问本部门客户
├── 时间属性 → 只能在工作时间访问  
└── 地点属性 → 只能在办公地点访问

最终权限 = RBAC权限 ∩ ABAC条件
```

##### 6.2.2 实现混合模型


```sql
-- 混合权限检查函数
DELIMITER ;;
CREATE FUNCTION check_access(
    p_user_id INT,
    p_resource VARCHAR(100),
    p_action VARCHAR(50)
) RETURNS BOOLEAN
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE v_has_role_permission BOOLEAN DEFAULT FALSE;
    DECLARE v_meets_attributes BOOLEAN DEFAULT FALSE;
    
    -- 检查RBAC权限
    SELECT COUNT(*) > 0 INTO v_has_role_permission
    FROM user_roles ur
    JOIN role_permissions rp ON ur.role_name = rp.role_name
    JOIN permissions p ON rp.permission_id = p.id
    WHERE ur.user_id = p_user_id
    AND p.resource = p_resource
    AND p.action = p_action;
    
    -- 检查ABAC属性条件
    SELECT COUNT(*) > 0 INTO v_meets_attributes
    FROM access_policies ap
    WHERE ap.resource_pattern = p_resource
    AND ap.action_type = p_action
    AND ap.effect = 'ALLOW'
    -- 这里简化，实际需要动态执行condition_sql
    ;
    
    RETURN v_has_role_permission AND v_meets_attributes;
END;;
DELIMITER ;
```

---

## 7. 🛠️ 权限管理工具与实践


### 7.1 权限可视化工具


##### 7.1.1 权限关系图生成


```sql
-- 生成角色继承关系数据
SELECT 
    from_user AS parent_role,
    to_user AS child_role,
    'inherits' AS relationship
FROM mysql.role_edges
WHERE to_user NOT LIKE '%@%'  -- 角色继承关系
UNION ALL
SELECT 
    from_user AS role_name,
    to_user AS user_name,
    'assigned' AS relationship  
FROM mysql.role_edges
WHERE to_user LIKE '%@%';     -- 用户角色分配
```

##### 7.1.2 权限矩阵报表


```sql
-- 用户权限汇总报表
SELECT 
    u.user AS username,
    r.from_user AS role_name,
    tp.table_schema AS database_name,
    tp.table_name,
    GROUP_CONCAT(tp.privilege_type) AS permissions
FROM mysql.user u
LEFT JOIN mysql.role_edges r ON CONCAT(u.user, '@', u.host) = r.to_user
LEFT JOIN information_schema.table_privileges tp ON r.from_user = tp.grantee
WHERE u.user NOT LIKE 'mysql.%'
GROUP BY u.user, r.from_user, tp.table_schema, tp.table_name
ORDER BY u.user, r.from_user;
```

### 7.2 权限分析报表系统


##### 7.2.1 权限使用统计


```sql
-- 权限使用频率统计表
CREATE TABLE permission_usage_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_name VARCHAR(50),
    database_name VARCHAR(50),
    table_name VARCHAR(50),
    operation_type VARCHAR(20),
    access_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    success BOOLEAN
);

-- 权限使用分析
SELECT 
    user_name,
    operation_type,
    COUNT(*) AS usage_count,
    COUNT(CASE WHEN success THEN 1 END) AS success_count,
    ROUND(COUNT(CASE WHEN success THEN 1 END) * 100.0 / COUNT(*), 2) AS success_rate
FROM permission_usage_log
WHERE access_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY user_name, operation_type
ORDER BY usage_count DESC;
```

##### 7.2.2 异常权限检测


```sql
-- 检测过度权限
SELECT 
    grantee,
    table_schema,
    COUNT(DISTINCT privilege_type) AS permission_count,
    GROUP_CONCAT(privilege_type) AS permissions
FROM information_schema.table_privileges
WHERE grantee NOT LIKE 'mysql.%'
GROUP BY grantee, table_schema
HAVING permission_count > 5  -- 超过5种权限可能过度
ORDER BY permission_count DESC;

-- 检测长期未使用的权限
SELECT 
    tp.grantee,
    tp.table_schema,
    tp.table_name,
    tp.privilege_type,
    'Unused for 90+ days' AS risk_level
FROM information_schema.table_privileges tp
LEFT JOIN permission_usage_log pul ON 
    tp.grantee = pul.user_name 
    AND tp.table_schema = pul.database_name
    AND tp.table_name = pul.table_name
WHERE pul.access_time IS NULL 
OR pul.access_time < DATE_SUB(NOW(), INTERVAL 90 DAY);
```

### 7.3 自动化权限管理


##### 7.3.1 权限申请工作流


```sql
-- 权限申请表
CREATE TABLE permission_requests (
    id INT PRIMARY KEY AUTO_INCREMENT,
    requester VARCHAR(50),
    requested_role VARCHAR(50),
    business_justification TEXT,
    approver VARCHAR(50),
    status ENUM('PENDING', 'APPROVED', 'REJECTED'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reviewed_at TIMESTAMP NULL
);

-- 自动权限审批存储过程
DELIMITER ;;
CREATE PROCEDURE auto_approve_routine_requests()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE req_id INT;
    DECLARE req_user VARCHAR(50);
    DECLARE req_role VARCHAR(50);
    
    DECLARE cur CURSOR FOR
        SELECT id, requester, requested_role
        FROM permission_requests
        WHERE status = 'PENDING'
        AND requested_role IN ('basic_user', 'read_only')  -- 低风险角色
        AND created_at < DATE_SUB(NOW(), INTERVAL 24 HOUR);
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    approval_loop: LOOP
        FETCH cur INTO req_id, req_user, req_role;
        IF done THEN LEAVE approval_loop; END IF;
        
        -- 自动批准低风险权限申请
        UPDATE permission_requests 
        SET status = 'APPROVED', 
            approver = 'SYSTEM_AUTO',
            reviewed_at = NOW()
        WHERE id = req_id;
        
        -- 实际分配权限
        SET @sql = CONCAT('GRANT ', req_role, ' TO ', req_user);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    CLOSE cur;
END;;
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的关键概念


**🔸 RBAC核心思想**
```
用户 → 角色 → 权限 的三层架构
简化权限管理，提高安全性和可维护性
```

**🔸 权限矩阵设计**
```
清晰定义：谁对什么资源有什么操作权限
通过表格形式直观展示权限分配情况
```

**🔸 最小权限原则**
```
只给必需的权限，不多给一分
定期审计和清理无用权限
```

**🔸 职责分离机制**
```
关键流程多人参与，避免权限过度集中
通过角色冲突检测防止违规权限组合
```

### 8.2 实施要点


| 阶段 | **核心任务** | **注意事项** |
|------|------------|-------------|
| **🔸 规划设计** | `分析业务流程，设计角色体系` | `考虑未来扩展性` |
| **🔸 权限分配** | `按最小权限原则分配` | `避免权限过度集中` |
| **🔸 日常管理** | `定期审计，及时调整` | `建立权限变更流程` |
| **🔸 监控预警** | `异常检测，安全防护` | `记录权限使用日志` |

### 8.3 常见误区避免


> ⚠️ **权限管理常见错误**
> - 为了方便直接给用户管理员权限
> - 离职人员权限未及时回收  
> - 权限分配缺乏文档记录
> - 没有定期的权限审计流程

> 💡 **最佳实践建议**
> - 建立标准的角色模板
> - 实施权限申请审批流程
> - 定期进行权限清理和审计
> - 建立权限变更的完整日志

### 8.4 学习路径建议


```
基础理解 → 权限设计 → 工具使用 → 安全加固
    │          │          │          │
    ▼          ▼          ▼          ▼
RBAC概念   角色规划   MySQL实现   审计监控
```

**🧠 记忆要点**：
- RBAC就是"角色做中介，用户不直接拿权限"
- 最小权限原则：够用就行，多了有风险
- 职责分离：重要的事情不能一个人说了算
- 定期审计：权限会过期，定时大扫除