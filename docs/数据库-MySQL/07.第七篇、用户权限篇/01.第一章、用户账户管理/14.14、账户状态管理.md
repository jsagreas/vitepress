---
title: 14、账户状态管理
---
## 📚 目录

1. [账户状态基础概念](#1-账户状态基础概念)
2. [账户激活状态管理](#2-账户激活状态管理)
3. [临时禁用机制](#3-临时禁用机制)
4. [状态变更日志与审计](#4-状态变更日志与审计)
5. [批量状态操作](#5-批量状态操作)
6. [状态查询接口](#6-状态查询接口)
7. [自动状态切换](#7-自动状态切换)
8. [状态监控告警](#8-状态监控告警)
9. [账户生命周期管理](#9-账户生命周期管理)
10. [状态安全控制](#10-状态安全控制)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔐 账户状态基础概念


### 1.1 什么是账户状态管理


**简单理解**：账户状态管理就是控制用户账户能否正常使用的开关系统。就像手机卡可以停机、激活一样，MySQL用户账户也有不同的状态。

```
账户状态类比：
手机卡状态    →    MySQL账户状态
正常使用      →    ACTIVE（激活）
欠费停机      →    LOCKED（锁定）
注销状态      →    EXPIRED（过期）
新卡未激活    →    INACTIVE（未激活）
```

### 1.2 核心状态类型


**🔸 主要状态说明**
```sql
-- 查看账户状态的基本信息
SHOW VARIABLES LIKE 'validate_password%';
SELECT user, host, account_locked, password_expired 
FROM mysql.user WHERE user = 'test_user';
```

| 状态类型 | **含义说明** | **使用场景** | **影响范围** |
|---------|------------|-------------|-------------|
| 🟢 **ACTIVE** | `账户正常可用` | `日常使用` | `全部权限生效` |
| 🔴 **LOCKED** | `账户被锁定` | `安全管控` | `禁止登录` |
| 🟡 **EXPIRED** | `密码已过期` | `安全策略` | `强制改密` |
| ⚪ **INACTIVE** | `账户未激活` | `新建账户` | `等待激活` |

### 1.3 状态管理的重要性


**🎯 为什么需要状态管理**
```
安全防护：
• 快速禁用可疑账户
• 防止恶意登录尝试
• 控制账户访问权限

合规要求：
• 满足企业安全政策
• 符合审计要求
• 定期清理无效账户

运维管理：
• 批量管理用户状态
• 自动化账户维护
• 降低管理成本
```

---

## 2. ✅ 账户激活状态管理


### 2.1 激活状态的含义


**激活状态**是指账户可以正常登录和使用数据库的状态。新创建的账户默认是激活的，但可以通过管理命令改变状态。

### 2.2 查看账户激活状态


```sql
-- 查看所有用户的激活状态
SELECT 
    user,
    host,
    account_locked,
    password_expired,
    password_lifetime
FROM mysql.user;

-- 查看特定用户状态
SELECT 
    user,
    host,
    CASE 
        WHEN account_locked = 'Y' THEN '锁定'
        WHEN password_expired = 'Y' THEN '密码过期'
        ELSE '正常'
    END AS 状态
FROM mysql.user 
WHERE user = 'app_user';
```

### 2.3 激活和停用账户


```sql
-- 锁定账户（停用）
ALTER USER 'app_user'@'localhost' ACCOUNT LOCK;

-- 解锁账户（激活）
ALTER USER 'app_user'@'localhost' ACCOUNT UNLOCK;

-- 创建时直接设置状态
CREATE USER 'new_user'@'localhost' 
IDENTIFIED BY 'password123' ACCOUNT LOCK;
```

**🔸 状态变化示意图**
```
创建账户 → [ACTIVE] ←→ [LOCKED] → 删除账户
           激活状态    锁定状态
              ↓          ↑
           可以登录    禁止登录
```

---

## 3. 🚫 临时禁用机制


### 3.1 临时禁用的应用场景


**临时禁用**是指在不删除账户的情况下，暂时阻止用户登录，通常用于紧急安全响应或维护期间。

**🎯 典型使用场景**
```
安全事件：
• 发现异常登录行为
• 怀疑账户被盗用
• 需要立即切断访问

维护窗口：
• 系统升级期间
• 数据迁移过程
• 权限重新分配

合规要求：
• 员工离职处理
• 定期账户审查
• 访问权限清理
```

### 3.2 实现临时禁用


```sql
-- 方法1：直接锁定账户
ALTER USER 'temp_user'@'%' ACCOUNT LOCK;

-- 方法2：设置密码过期（强制用户重新设置密码）
ALTER USER 'temp_user'@'%' PASSWORD EXPIRE;

-- 方法3：组合使用
ALTER USER 'temp_user'@'%' 
ACCOUNT LOCK 
PASSWORD EXPIRE;
```

### 3.3 临时禁用的恢复流程


```sql
-- 恢复步骤
-- 1. 解锁账户
ALTER USER 'temp_user'@'%' ACCOUNT UNLOCK;

-- 2. 重置密码（如果需要）
ALTER USER 'temp_user'@'%' 
IDENTIFIED BY 'new_password123';

-- 3. 验证状态
SELECT user, host, account_locked, password_expired 
FROM mysql.user WHERE user = 'temp_user';
```

**⚠️ 注意事项**
- 临时禁用会立即生效，已连接的会话不受影响
- 解锁后用户可以立即登录
- 建议配合密码重置使用

---

## 4. 📋 状态变更日志与审计


### 4.1 审计跟踪的重要性


**审计跟踪**记录了账户状态的所有变更历史，这对安全合规和问题排查至关重要。

### 4.2 启用审计日志


```sql
-- 查看审计插件状态
SHOW PLUGINS LIKE '%audit%';

-- 设置通用日志（记录所有操作）
SET GLOBAL general_log = ON;
SET GLOBAL log_output = 'TABLE';

-- 查看操作日志
SELECT 
    event_time,
    user_host,
    command_type,
    argument
FROM mysql.general_log 
WHERE argument LIKE '%ALTER USER%'
ORDER BY event_time DESC;
```

### 4.3 自定义状态变更记录


```sql
-- 创建状态变更记录表
CREATE TABLE user_status_audit (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    hostname VARCHAR(50),
    old_status VARCHAR(20),
    new_status VARCHAR(20),
    changed_by VARCHAR(50),
    change_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reason TEXT
);

-- 记录状态变更的存储过程
DELIMITER //
CREATE PROCEDURE record_status_change(
    IN p_username VARCHAR(50),
    IN p_hostname VARCHAR(50),
    IN p_old_status VARCHAR(20),
    IN p_new_status VARCHAR(20),
    IN p_reason TEXT
)
BEGIN
    INSERT INTO user_status_audit 
    (username, hostname, old_status, new_status, changed_by, reason)
    VALUES 
    (p_username, p_hostname, p_old_status, p_new_status, USER(), p_reason);
END //
DELIMITER ;
```

### 4.4 查询审计记录


```sql
-- 查看特定用户的状态变更历史
SELECT 
    username,
    old_status,
    new_status,
    changed_by,
    change_time,
    reason
FROM user_status_audit 
WHERE username = 'app_user'
ORDER BY change_time DESC;

-- 统计状态变更频率
SELECT 
    DATE(change_time) as 变更日期,
    COUNT(*) as 变更次数
FROM user_status_audit 
GROUP BY DATE(change_time)
ORDER BY 变更日期 DESC;
```

---

## 5. 🔄 批量状态操作


### 5.1 批量操作的需求场景


**批量状态操作**适用于需要同时管理多个账户状态的场景，提高管理效率。

### 5.2 批量锁定账户


```sql
-- 批量锁定指定前缀的用户
-- 先查看要操作的用户
SELECT user, host FROM mysql.user WHERE user LIKE 'temp_%';

-- 生成批量锁定语句
SELECT CONCAT('ALTER USER ''', user, '''@''', host, ''' ACCOUNT LOCK;')
FROM mysql.user 
WHERE user LIKE 'temp_%';

-- 批量锁定特定主机的用户
SET @sql = '';
SELECT GROUP_CONCAT(
    CONCAT('ALTER USER ''', user, '''@''', host, ''' ACCOUNT LOCK;')
    SEPARATOR ' '
) INTO @sql
FROM mysql.user 
WHERE host = '192.168.1.%';

-- 执行批量操作（需要谨慎）
-- PREPARE stmt FROM @sql;
-- EXECUTE stmt;
-- DEALLOCATE PREPARE stmt;
```

### 5.3 批量状态查询


```sql
-- 创建状态汇总视图
CREATE VIEW user_status_summary AS
SELECT 
    CASE 
        WHEN account_locked = 'Y' THEN 'LOCKED'
        WHEN password_expired = 'Y' THEN 'EXPIRED'
        ELSE 'ACTIVE'
    END AS status,
    COUNT(*) AS user_count
FROM mysql.user
GROUP BY 
    account_locked, 
    password_expired;

-- 查看状态分布
SELECT * FROM user_status_summary;
```

### 5.4 批量状态恢复


```sql
-- 批量解锁符合条件的用户
DELIMITER //
CREATE PROCEDURE batch_unlock_users(
    IN p_pattern VARCHAR(50)
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_user VARCHAR(50);
    DECLARE v_host VARCHAR(50);
    
    DECLARE user_cursor CURSOR FOR 
        SELECT user, host FROM mysql.user 
        WHERE user LIKE p_pattern AND account_locked = 'Y';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN user_cursor;
    
    read_loop: LOOP
        FETCH user_cursor INTO v_user, v_host;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        SET @sql = CONCAT('ALTER USER ''', v_user, '''@''', v_host, ''' ACCOUNT UNLOCK;');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE user_cursor;
END //
DELIMITER ;

-- 使用批量解锁
CALL batch_unlock_users('temp_%');
```

---

## 6. 🔍 状态查询接口


### 6.1 基础状态查询


**状态查询接口**提供了标准化的方式来检查和监控账户状态。

```sql
-- 创建状态查询函数
DELIMITER //
CREATE FUNCTION get_user_status(
    p_username VARCHAR(50),
    p_hostname VARCHAR(50)
) RETURNS VARCHAR(20)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE v_locked CHAR(1);
    DECLARE v_expired CHAR(1);
    DECLARE v_status VARCHAR(20);
    
    SELECT account_locked, password_expired
    INTO v_locked, v_expired
    FROM mysql.user
    WHERE user = p_username AND host = p_hostname;
    
    IF v_locked = 'Y' THEN
        SET v_status = 'LOCKED';
    ELSEIF v_expired = 'Y' THEN
        SET v_status = 'EXPIRED';
    ELSE
        SET v_status = 'ACTIVE';
    END IF;
    
    RETURN v_status;
END //
DELIMITER ;

-- 使用状态查询函数
SELECT get_user_status('app_user', 'localhost') AS 账户状态;
```

### 6.2 高级状态报告


```sql
-- 创建详细状态报告视图
CREATE VIEW detailed_user_status AS
SELECT 
    user AS 用户名,
    host AS 主机,
    CASE 
        WHEN account_locked = 'Y' THEN '🔴 锁定'
        WHEN password_expired = 'Y' THEN '🟡 密码过期'
        ELSE '🟢 正常'
    END AS 状态,
    password_lifetime AS 密码有效期,
    password_last_changed AS 上次改密时间,
    CASE 
        WHEN ssl_type != '' THEN '🔒 SSL'
        ELSE '🔓 普通'
    END AS 连接类型
FROM mysql.user
ORDER BY 
    CASE 
        WHEN account_locked = 'Y' THEN 1
        WHEN password_expired = 'Y' THEN 2
        ELSE 3
    END, user;

-- 查看详细状态报告
SELECT * FROM detailed_user_status;
```

### 6.3 API接口模拟


```sql
-- 模拟RESTful API的查询存储过程
DELIMITER //
CREATE PROCEDURE api_get_user_status(
    IN p_username VARCHAR(50),
    IN p_hostname VARCHAR(50)
)
BEGIN
    SELECT 
        user as username,
        host as hostname,
        CASE 
            WHEN account_locked = 'Y' THEN 'locked'
            WHEN password_expired = 'Y' THEN 'expired'
            ELSE 'active'
        END as status,
        password_last_changed as last_password_change,
        password_lifetime as password_validity_days,
        NOW() as query_time
    FROM mysql.user
    WHERE user = p_username AND host = p_hostname;
END //
DELIMITER ;

-- 调用API接口
CALL api_get_user_status('app_user', 'localhost');
```

---

## 7. ⏰ 自动状态切换


### 7.1 自动状态切换的概念


**自动状态切换**是指根据预设规则或条件，系统自动改变账户状态，无需人工干预。

### 7.2 基于时间的自动切换


```sql
-- 创建定时任务表
CREATE TABLE scheduled_status_changes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    hostname VARCHAR(50),
    target_status VARCHAR(20),
    scheduled_time DATETIME,
    executed BOOLEAN DEFAULT FALSE,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 添加定时状态变更任务
INSERT INTO scheduled_status_changes 
(username, hostname, target_status, scheduled_time)
VALUES 
('temp_user', 'localhost', 'LOCKED', '2024-12-31 23:59:59');

-- 执行定时状态变更的存储过程
DELIMITER //
CREATE PROCEDURE execute_scheduled_status_changes()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_id INT;
    DECLARE v_username VARCHAR(50);
    DECLARE v_hostname VARCHAR(50);
    DECLARE v_target_status VARCHAR(20);
    
    DECLARE status_cursor CURSOR FOR 
        SELECT id, username, hostname, target_status
        FROM scheduled_status_changes
        WHERE scheduled_time <= NOW() AND executed = FALSE;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN status_cursor;
    
    read_loop: LOOP
        FETCH status_cursor INTO v_id, v_username, v_hostname, v_target_status;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        IF v_target_status = 'LOCKED' THEN
            SET @sql = CONCAT('ALTER USER ''', v_username, '''@''', v_hostname, ''' ACCOUNT LOCK;');
        ELSEIF v_target_status = 'UNLOCKED' THEN
            SET @sql = CONCAT('ALTER USER ''', v_username, '''@''', v_hostname, ''' ACCOUNT UNLOCK;');
        END IF;
        
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        UPDATE scheduled_status_changes 
        SET executed = TRUE 
        WHERE id = v_id;
        
    END LOOP;
    
    CLOSE status_cursor;
END //
DELIMITER ;
```

### 7.3 基于条件的自动切换


```sql
-- 创建登录失败记录表
CREATE TABLE login_failures (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    hostname VARCHAR(50),
    failure_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45)
);

-- 自动锁定多次登录失败的账户
DELIMITER //
CREATE PROCEDURE auto_lock_failed_accounts()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_username VARCHAR(50);
    DECLARE v_hostname VARCHAR(50);
    DECLARE v_failure_count INT;
    
    DECLARE failure_cursor CURSOR FOR 
        SELECT username, hostname, COUNT(*) as failure_count
        FROM login_failures
        WHERE failure_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
        GROUP BY username, hostname
        HAVING failure_count >= 5;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN failure_cursor;
    
    read_loop: LOOP
        FETCH failure_cursor INTO v_username, v_hostname, v_failure_count;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        SET @sql = CONCAT('ALTER USER ''', v_username, '''@''', v_hostname, ''' ACCOUNT LOCK;');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 记录自动锁定原因
        INSERT INTO user_status_audit 
        (username, hostname, old_status, new_status, changed_by, reason)
        VALUES 
        (v_username, v_hostname, 'ACTIVE', 'LOCKED', 'SYSTEM', 
         CONCAT('自动锁定：1小时内登录失败', v_failure_count, '次'));
        
    END LOOP;
    
    CLOSE failure_cursor;
END //
DELIMITER ;
```

---

## 8. 🚨 状态监控告警


### 8.1 监控告警的目标


**状态监控告警**及时发现异常的账户状态变化，确保系统安全。

### 8.2 异常状态检测


```sql
-- 创建状态监控视图
CREATE VIEW status_monitoring AS
SELECT 
    user,
    host,
    account_locked,
    password_expired,
    password_last_changed,
    CASE 
        WHEN account_locked = 'Y' THEN 1
        WHEN password_expired = 'Y' THEN 1
        ELSE 0
    END AS needs_attention,
    CASE 
        WHEN password_last_changed < DATE_SUB(NOW(), INTERVAL 90 DAY) THEN 1
        ELSE 0
    END AS password_aging_warning
FROM mysql.user
WHERE user != 'root';

-- 检查需要关注的账户
SELECT 
    user AS 用户名,
    host AS 主机,
    CASE 
        WHEN account_locked = 'Y' THEN '账户已锁定'
        WHEN password_expired = 'Y' THEN '密码已过期'
        WHEN password_aging_warning = 1 THEN '密码即将过期'
    END AS 警告信息
FROM status_monitoring
WHERE needs_attention = 1 OR password_aging_warning = 1;
```

### 8.3 告警通知机制


```sql
-- 创建告警记录表
CREATE TABLE status_alerts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    alert_type VARCHAR(50),
    username VARCHAR(50),
    hostname VARCHAR(50),
    alert_message TEXT,
    alert_level ENUM('INFO', 'WARNING', 'CRITICAL'),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved BOOLEAN DEFAULT FALSE
);

-- 生成状态告警的存储过程
DELIMITER //
CREATE PROCEDURE generate_status_alerts()
BEGIN
    -- 检查锁定账户告警
    INSERT INTO status_alerts (alert_type, username, hostname, alert_message, alert_level)
    SELECT 
        'ACCOUNT_LOCKED',
        user,
        host,
        CONCAT('账户 ', user, '@', host, ' 处于锁定状态'),
        'WARNING'
    FROM mysql.user
    WHERE account_locked = 'Y'
    AND NOT EXISTS (
        SELECT 1 FROM status_alerts 
        WHERE alert_type = 'ACCOUNT_LOCKED' 
        AND username = mysql.user.user 
        AND hostname = mysql.user.host 
        AND resolved = FALSE
    );
    
    -- 检查密码过期告警
    INSERT INTO status_alerts (alert_type, username, hostname, alert_message, alert_level)
    SELECT 
        'PASSWORD_EXPIRED',
        user,
        host,
        CONCAT('账户 ', user, '@', host, ' 密码已过期'),
        'CRITICAL'
    FROM mysql.user
    WHERE password_expired = 'Y'
    AND NOT EXISTS (
        SELECT 1 FROM status_alerts 
        WHERE alert_type = 'PASSWORD_EXPIRED' 
        AND username = mysql.user.user 
        AND hostname = mysql.user.host 
        AND resolved = FALSE
    );
END //
DELIMITER ;

-- 查看未解决的告警
SELECT 
    alert_type AS 告警类型,
    username AS 用户名,
    hostname AS 主机,
    alert_message AS 告警信息,
    alert_level AS 告警级别,
    created_time AS 创建时间
FROM status_alerts
WHERE resolved = FALSE
ORDER BY 
    CASE alert_level
        WHEN 'CRITICAL' THEN 1
        WHEN 'WARNING' THEN 2
        WHEN 'INFO' THEN 3
    END,
    created_time DESC;
```

---

## 9. 🔄 账户生命周期管理


### 9.1 生命周期管理概念


**账户生命周期管理**是指从账户创建到销毁的整个过程中，对账户状态的系统化管理。

```
账户生命周期流程图：
创建 → 激活 → 使用 → 维护 → 停用 → 删除
 ↓      ↓      ↓      ↓      ↓      ↓
新建   正常   活跃   检查   锁定   销毁
```

### 9.2 生命周期状态定义


```sql
-- 创建账户生命周期状态表
CREATE TABLE account_lifecycle (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    hostname VARCHAR(50),
    lifecycle_stage ENUM('CREATED', 'ACTIVE', 'MAINTENANCE', 'SUSPENDED', 'DEPRECATED', 'DELETED'),
    stage_start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    stage_end_time TIMESTAMP NULL,
    notes TEXT,
    created_by VARCHAR(50),
    INDEX idx_user_host (username, hostname),
    INDEX idx_stage (lifecycle_stage)
);

-- 记录生命周期变更
DELIMITER //
CREATE PROCEDURE update_lifecycle_stage(
    IN p_username VARCHAR(50),
    IN p_hostname VARCHAR(50),
    IN p_new_stage VARCHAR(20),
    IN p_notes TEXT
)
BEGIN
    -- 结束当前阶段
    UPDATE account_lifecycle 
    SET stage_end_time = NOW()
    WHERE username = p_username 
    AND hostname = p_hostname 
    AND stage_end_time IS NULL;
    
    -- 开始新阶段
    INSERT INTO account_lifecycle 
    (username, hostname, lifecycle_stage, notes, created_by)
    VALUES 
    (p_username, p_hostname, p_new_stage, p_notes, USER());
END //
DELIMITER ;
```

### 9.3 自动化生命周期管理


```sql
-- 检查需要进入维护期的账户
SELECT 
    user,
    host,
    password_last_changed,
    DATEDIFF(NOW(), password_last_changed) AS 天数
FROM mysql.user
WHERE password_last_changed < DATE_SUB(NOW(), INTERVAL 180 DAY)
AND account_locked = 'N';

-- 自动处理过期账户
DELIMITER //
CREATE PROCEDURE manage_account_lifecycle()
BEGIN
    -- 将长期未使用的账户标记为维护状态
    INSERT INTO account_lifecycle (username, hostname, lifecycle_stage, notes, created_by)
    SELECT 
        user,
        host,
        'MAINTENANCE',
        '180天未更改密码，进入维护期',
        'SYSTEM'
    FROM mysql.user
    WHERE password_last_changed < DATE_SUB(NOW(), INTERVAL 180 DAY)
    AND account_locked = 'N'
    AND NOT EXISTS (
        SELECT 1 FROM account_lifecycle 
        WHERE username = mysql.user.user 
        AND hostname = mysql.user.host 
        AND lifecycle_stage = 'MAINTENANCE'
        AND stage_end_time IS NULL
    );
    
    -- 自动锁定进入维护期超过30天的账户
    UPDATE mysql.user SET account_locked = 'Y'
    WHERE (user, host) IN (
        SELECT username, hostname 
        FROM account_lifecycle 
        WHERE lifecycle_stage = 'MAINTENANCE'
        AND stage_start_time < DATE_SUB(NOW(), INTERVAL 30 DAY)
        AND stage_end_time IS NULL
    );
END //
DELIMITER ;
```

---

## 10. 🔒 状态安全控制


### 10.1 状态变更授权机制


**状态安全控制**确保只有授权人员才能修改账户状态，防止恶意操作。

### 10.2 权限分级管理


```sql
-- 创建状态管理权限表
CREATE TABLE status_management_permissions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    admin_user VARCHAR(50),
    permission_level ENUM('VIEW', 'MODIFY', 'FULL'),
    target_user_pattern VARCHAR(100),
    granted_by VARCHAR(50),
    granted_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expiry_time TIMESTAMP NULL,
    active BOOLEAN DEFAULT TRUE
);

-- 检查状态变更权限
DELIMITER //
CREATE FUNCTION check_status_permission(
    p_admin_user VARCHAR(50),
    p_target_user VARCHAR(50),
    p_operation VARCHAR(20)
) RETURNS BOOLEAN
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE v_has_permission BOOLEAN DEFAULT FALSE;
    DECLARE v_count INT DEFAULT 0;
    
    SELECT COUNT(*) INTO v_count
    FROM status_management_permissions
    WHERE admin_user = p_admin_user
    AND (target_user_pattern = '%' OR p_target_user LIKE target_user_pattern)
    AND (
        (p_operation = 'VIEW' AND permission_level IN ('VIEW', 'MODIFY', 'FULL'))
        OR (p_operation = 'MODIFY' AND permission_level IN ('MODIFY', 'FULL'))
        OR (p_operation = 'FULL' AND permission_level = 'FULL')
    )
    AND active = TRUE
    AND (expiry_time IS NULL OR expiry_time > NOW());
    
    IF v_count > 0 THEN
        SET v_has_permission = TRUE;
    END IF;
    
    RETURN v_has_permission;
END //
DELIMITER ;
```

### 10.3 安全的状态变更流程


```sql
-- 安全的账户锁定存储过程
DELIMITER //
CREATE PROCEDURE secure_lock_account(
    IN p_target_user VARCHAR(50),
    IN p_target_host VARCHAR(50),
    IN p_reason TEXT
)
BEGIN
    DECLARE v_current_user VARCHAR(50);
    DECLARE v_has_permission BOOLEAN;
    
    SET v_current_user = SUBSTRING_INDEX(USER(), '@', 1);
    SET v_has_permission = check_status_permission(v_current_user, p_target_user, 'MODIFY');
    
    IF NOT v_has_permission THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '权限不足：无法修改该账户状态';
    END IF;
    
    -- 记录操作前状态
    INSERT INTO user_status_audit 
    (username, hostname, old_status, new_status, changed_by, reason)
    SELECT 
        p_target_user,
        p_target_host,
        CASE WHEN account_locked = 'Y' THEN 'LOCKED' ELSE 'ACTIVE' END,
        'LOCKED',
        v_current_user,
        p_reason
    FROM mysql.user
    WHERE user = p_target_user AND host = p_target_host;
    
    -- 执行锁定操作
    SET @sql = CONCAT('ALTER USER ''', p_target_user, '''@''', p_target_host, ''' ACCOUNT LOCK;');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 记录操作日志
    INSERT INTO status_alerts (alert_type, username, hostname, alert_message, alert_level)
    VALUES ('MANUAL_LOCK', p_target_user, p_target_host, 
            CONCAT('账户被 ', v_current_user, ' 手动锁定：', p_reason), 'INFO');
            
END //
DELIMITER ;

-- 使用安全锁定功能
CALL secure_lock_account('test_user', 'localhost', '安全检查需要临时锁定');
```

### 10.4 异常状态检测告警


```sql
-- 检测异常状态变更
CREATE EVENT detect_unusual_status_changes
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
    -- 检测短时间内大量状态变更
    INSERT INTO status_alerts (alert_type, username, hostname, alert_message, alert_level)
    SELECT 
        'BULK_STATUS_CHANGE',
        'SYSTEM',
        'ALL',
        CONCAT('检测到5分钟内有', COUNT(*), '个账户状态发生变更'),
        'WARNING'
    FROM user_status_audit
    WHERE change_time >= DATE_SUB(NOW(), INTERVAL 5 MINUTE)
    HAVING COUNT(*) > 10;
    
    -- 检测非工作时间的状态变更
    INSERT INTO status_alerts (alert_type, username, hostname, alert_message, alert_level)
    SELECT 
        'OFF_HOURS_CHANGE',
        username,
        hostname,
        CONCAT('非工作时间账户状态变更：', old_status, ' → ', new_status),
        'WARNING'
    FROM user_status_audit
    WHERE change_time >= DATE_SUB(NOW(), INTERVAL 5 MINUTE)
    AND (HOUR(change_time) < 8 OR HOUR(change_time) > 18)
    AND changed_by != 'SYSTEM';
END;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 账户状态类型：ACTIVE（正常）、LOCKED（锁定）、EXPIRED（过期）
🔸 状态管理命令：ALTER USER ... ACCOUNT LOCK/UNLOCK
🔸 状态查询方法：mysql.user表中的account_locked和password_expired字段
🔸 批量操作技巧：使用存储过程和游标处理多个账户
🔸 审计跟踪重要性：记录所有状态变更历史
🔸 自动化管理：基于时间和条件的自动状态切换
🔸 安全控制：权限验证和异常检测机制
```

### 11.2 关键理解要点


**🔹 状态管理的核心价值**
```
安全防护：
• 快速响应安全事件
• 防止未授权访问
• 控制账户权限范围

运维效率：
• 批量管理大量账户
• 自动化日常维护
• 减少人工干预错误

合规要求：
• 满足审计需求
• 符合安全策略
• 提供完整操作记录
```

**🔹 实施最佳实践**
```
权限最小化：
• 只授予必要的状态管理权限
• 定期审查权限分配
• 实施权限分离原则

监控告警：
• 设置实时状态监控
• 配置异常行为告警
• 建立响应处理流程

文档记录：
• 详细记录操作原因
• 保留完整审计日志
• 定期备份状态数据
```

### 11.3 实际应用价值


- **安全响应**：快速禁用可疑账户，防止安全事件扩大
- **合规管理**：满足企业安全政策和审计要求
- **运维自动化**：减少手工操作，提高管理效率
- **风险控制**：通过状态管理降低数据库访问风险

**核心记忆**：
- 账户状态管理是数据库安全的重要防线
- 合理的状态管理流程能显著提高安全性
- 自动化和监控是现代状态管理的关键
- 权限控制和审计跟踪缺一不可