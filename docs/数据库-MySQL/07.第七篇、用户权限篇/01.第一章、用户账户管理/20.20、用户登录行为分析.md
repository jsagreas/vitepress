---
title: 20、用户登录行为分析
---
## 📚 目录

1. [登录行为分析概述](#1-登录行为分析概述)
2. [登录模式识别](#2-登录模式识别)
3. [异常登录检测](#3-异常登录检测)
4. [登录时间分析](#4-登录时间分析)
5. [登录地理位置追踪](#5-登录地理位置追踪)
6. [登录设备指纹识别](#6-登录设备指纹识别)
7. [用户行为基线建立](#7-用户行为基线建立)
8. [登录风险评分算法](#8-登录风险评分算法)
9. [登录行为安全分析](#9-登录行为安全分析)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 登录行为分析概述


### 1.1 什么是登录行为分析

**登录行为分析**就是通过记录和分析用户每次登录系统时的各种数据，来发现异常情况、保护账户安全的技术手段。

```
简单理解：
就像门卫记录每个人进出大楼的时间、方式一样
数据库也要记录用户什么时候、从哪里、用什么设备登录
```

**🎯 为什么需要登录行为分析**
- **安全防护**：及时发现账户被盗用或攻击
- **用户体验**：识别正常用户，减少不必要的验证
- **合规要求**：满足数据安全法规的审计需求
- **业务洞察**：了解用户使用习惯，优化产品

### 1.2 登录行为分析的核心维度


```
时间维度：什么时候登录？
地点维度：从哪里登录？
设备维度：用什么设备登录？
行为维度：登录后做什么？
频率维度：多久登录一次？
```

**📊 基础登录记录表结构**
```sql
CREATE TABLE user_login_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    login_time DATETIME NOT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT,
    login_status ENUM('success', 'failed', 'blocked'),
    country VARCHAR(50),
    city VARCHAR(100),
    device_fingerprint VARCHAR(255),
    risk_score DECIMAL(3,2),
    INDEX idx_user_time (user_id, login_time),
    INDEX idx_ip (ip_address),
    INDEX idx_status (login_status)
);
```

---

## 2. 🔄 登录模式识别


### 2.1 什么是登录模式

**登录模式**就是用户登录行为的规律性特征，比如每天上班时间登录、只在工作日登录等。

```
举例说明：
小张的登录模式：
- 时间：每天早上9点左右，晚上6点左右
- 地点：公司IP段和家里IP段
- 设备：固定的办公电脑和个人手机
- 频率：工作日登录，周末很少登录
```

### 2.2 识别用户登录时间模式


**📈 按小时统计登录分布**
```sql
-- 分析用户在一天中各个小时的登录习惯
SELECT 
    user_id,
    HOUR(login_time) as login_hour,
    COUNT(*) as login_count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY user_id) as percentage
FROM user_login_logs 
WHERE login_status = 'success'
    AND login_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY user_id, HOUR(login_time)
ORDER BY user_id, login_hour;
```

**📅 按星期分析登录模式**
```sql
-- 分析用户在一周中各天的登录习惯
SELECT 
    user_id,
    DAYOFWEEK(login_time) as day_of_week,
    CASE DAYOFWEEK(login_time)
        WHEN 1 THEN '周日' WHEN 2 THEN '周一' WHEN 3 THEN '周二'
        WHEN 4 THEN '周三' WHEN 5 THEN '周四' WHEN 6 THEN '周五'
        WHEN 7 THEN '周六'
    END as day_name,
    COUNT(*) as login_count
FROM user_login_logs 
WHERE login_status = 'success'
GROUP BY user_id, DAYOFWEEK(login_time)
ORDER BY user_id, day_of_week;
```

### 2.3 设备使用模式识别


**💻 常用设备识别**
```sql
-- 识别用户的常用设备
SELECT 
    user_id,
    device_fingerprint,
    COUNT(*) as usage_count,
    MIN(login_time) as first_used,
    MAX(login_time) as last_used,
    CASE 
        WHEN COUNT(*) >= 10 THEN '常用设备'
        WHEN COUNT(*) >= 3 THEN '偶尔使用'
        ELSE '新设备'
    END as device_category
FROM user_login_logs
WHERE login_status = 'success'
GROUP BY user_id, device_fingerprint
ORDER BY user_id, usage_count DESC;
```

---

## 3. ⚠️ 异常登录检测


### 3.1 什么是异常登录

**异常登录**是指与用户正常登录模式明显不符的登录行为，可能表示账户被盗用或遭受攻击。

```
常见异常登录情况：
❌ 凌晨3点突然登录（平时只在白天登录）
❌ 从陌生国家登录（平时只在国内登录）
❌ 使用从未见过的设备登录
❌ 短时间内多次登录失败
❌ 登录后立即修改密码或敏感信息
```

### 3.2 基于时间的异常检测


**⏰ 检测非正常时间登录**
```sql
-- 检测在用户不常登录的时间段登录的情况
WITH user_normal_hours AS (
    SELECT 
        user_id,
        HOUR(login_time) as hour,
        COUNT(*) as count
    FROM user_login_logs 
    WHERE login_status = 'success'
        AND login_time >= DATE_SUB(NOW(), INTERVAL 90 DAY)
    GROUP BY user_id, HOUR(login_time)
    HAVING COUNT(*) >= 5  -- 至少出现5次才算正常时间
)
SELECT 
    l.user_id,
    l.login_time,
    l.ip_address,
    HOUR(l.login_time) as login_hour,
    '时间异常' as anomaly_type
FROM user_login_logs l
LEFT JOIN user_normal_hours nh 
    ON l.user_id = nh.user_id 
    AND HOUR(l.login_time) = nh.hour
WHERE l.login_status = 'success'
    AND l.login_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    AND nh.user_id IS NULL;  -- 不在正常时间范围内
```

### 3.3 基于地理位置的异常检测


**🌍 检测异常地理位置登录**
```sql
-- 检测从未出现过的国家/城市登录
WITH user_normal_locations AS (
    SELECT DISTINCT 
        user_id,
        country,
        city
    FROM user_login_logs 
    WHERE login_status = 'success'
        AND login_time >= DATE_SUB(NOW(), INTERVAL 90 DAY)
)
SELECT 
    l.user_id,
    l.login_time,
    l.ip_address,
    l.country,
    l.city,
    '地理位置异常' as anomaly_type
FROM user_login_logs l
LEFT JOIN user_normal_locations nl
    ON l.user_id = nl.user_id 
    AND l.country = nl.country
WHERE l.login_status = 'success'
    AND l.login_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    AND nl.user_id IS NULL;
```

### 3.4 基于设备的异常检测


**📱 检测新设备登录**
```sql
-- 检测使用全新设备的登录
SELECT 
    user_id,
    login_time,
    ip_address,
    device_fingerprint,
    user_agent,
    '新设备登录' as anomaly_type
FROM user_login_logs
WHERE login_status = 'success'
    AND device_fingerprint NOT IN (
        SELECT DISTINCT device_fingerprint 
        FROM user_login_logs 
        WHERE user_id = user_login_logs.user_id
            AND login_time < DATE_SUB(NOW(), INTERVAL 7 DAY)
            AND login_status = 'success'
    )
    AND login_time >= DATE_SUB(NOW(), INTERVAL 7 DAY);
```

---

## 4. ⏰ 登录时间分析


### 4.1 登录时间分析的意义

通过分析用户的登录时间规律，我们能够了解用户的作息习惯，识别异常行为，优化系统资源分配。

```
时间分析的价值：
🔍 发现异常：深夜突然登录可能是账户被盗
📊 资源规划：了解系统访问高峰期
👤 用户画像：判断用户类型（上班族、学生等）
🛡️ 安全防护：基于时间的访问控制
```

### 4.2 登录活跃时段分析


**📈 每小时登录活跃度统计**
```sql
-- 分析系统整体的每小时登录活跃度
SELECT 
    HOUR(login_time) as hour,
    COUNT(*) as total_logins,
    COUNT(DISTINCT user_id) as unique_users,
    AVG(COUNT(*)) OVER () as avg_logins_per_hour,
    CASE 
        WHEN COUNT(*) > AVG(COUNT(*)) OVER () * 1.5 THEN '高峰期'
        WHEN COUNT(*) < AVG(COUNT(*)) OVER () * 0.5 THEN '低峰期'
        ELSE '正常期'
    END as period_type
FROM user_login_logs 
WHERE login_status = 'success'
    AND login_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY HOUR(login_time)
ORDER BY hour;
```

### 4.3 用户登录频率分析


**🔄 用户登录频率分类**
```sql
-- 根据登录频率给用户分类
WITH user_login_stats AS (
    SELECT 
        user_id,
        COUNT(*) as total_logins,
        COUNT(DISTINCT DATE(login_time)) as active_days,
        DATEDIFF(MAX(login_time), MIN(login_time)) + 1 as period_days,
        COUNT(*) / NULLIF(DATEDIFF(MAX(login_time), MIN(login_time)) + 1, 0) as avg_logins_per_day
    FROM user_login_logs 
    WHERE login_status = 'success'
        AND login_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
    GROUP BY user_id
)
SELECT 
    user_id,
    total_logins,
    active_days,
    ROUND(avg_logins_per_day, 2) as avg_daily_logins,
    CASE 
        WHEN avg_logins_per_day >= 3 THEN '重度用户'
        WHEN avg_logins_per_day >= 1 THEN '中度用户'  
        WHEN avg_logins_per_day >= 0.5 THEN '轻度用户'
        ELSE '偶尔用户'
    END as user_type
FROM user_login_stats
ORDER BY avg_logins_per_day DESC;
```

---

## 5. 🌍 登录地理位置追踪


### 5.1 地理位置追踪的重要性

通过记录和分析用户的登录地理位置，可以有效识别账户盗用、实现地域化服务、满足合规要求。

```
地理位置的安全价值：
🚨 异常检测：突然从远距离地点登录
🛡️ 风险控制：限制特定地区的访问
📍 位置验证：结合用户常用地点验证身份
⚖️ 合规审计：记录数据访问的地理信息
```

### 5.2 用户地理位置模式分析


**🗺️ 用户常用登录地点统计**
```sql
-- 分析用户的常用登录地点
SELECT 
    user_id,
    country,
    city,
    COUNT(*) as login_count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY user_id) as percentage,
    MIN(login_time) as first_login,
    MAX(login_time) as last_login,
    CASE 
        WHEN COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY user_id) >= 80 THEN '主要地点'
        WHEN COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY user_id) >= 10 THEN '常用地点'
        ELSE '偶尔地点'
    END as location_type
FROM user_login_logs 
WHERE login_status = 'success'
    AND country IS NOT NULL
    AND login_time >= DATE_SUB(NOW(), INTERVAL 90 DAY)
GROUP BY user_id, country, city
ORDER BY user_id, login_count DESC;
```

### 5.3 跨地域异常登录检测


**🔄 快速地理位置切换检测**
```sql
-- 检测物理上不可能的快速地理位置切换
WITH location_timeline AS (
    SELECT 
        user_id,
        login_time,
        country,
        city,
        LAG(login_time) OVER (PARTITION BY user_id ORDER BY login_time) as prev_login_time,
        LAG(country) OVER (PARTITION BY user_id ORDER BY login_time) as prev_country,
        LAG(city) OVER (PARTITION BY user_id ORDER BY login_time) as prev_city
    FROM user_login_logs 
    WHERE login_status = 'success'
        AND login_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
)
SELECT 
    user_id,
    login_time,
    CONCAT(prev_country, '/', prev_city) as from_location,
    CONCAT(country, '/', city) as to_location,
    TIMESTAMPDIFF(MINUTE, prev_login_time, login_time) as time_diff_minutes,
    '地理位置切换异常' as anomaly_type
FROM location_timeline
WHERE prev_login_time IS NOT NULL
    AND (country != prev_country OR city != prev_city)
    AND TIMESTAMPDIFF(HOUR, prev_login_time, login_time) < 12  -- 12小时内
    AND (
        (country != prev_country AND TIMESTAMPDIFF(HOUR, prev_login_time, login_time) < 4)  -- 跨国4小时内
        OR 
        (city != prev_city AND TIMESTAMPDIFF(HOUR, prev_login_time, login_time) < 1)  -- 跨城市1小时内
    )
ORDER BY user_id, login_time;
```

---

## 6. 📱 登录设备指纹识别


### 6.1 什么是设备指纹

**设备指纹**是通过收集设备的各种特征信息（浏览器版本、操作系统、屏幕分辨率等）生成的唯一标识，用来识别和追踪设备。

```
设备指纹包含的信息：
📱 硬件信息：CPU型号、内存大小、屏幕分辨率
💻 软件信息：操作系统、浏览器版本、插件列表  
🌐 网络信息：IP地址、网络类型、代理设置
⚙️ 其他信息：时区、语言设置、字体列表
```

### 6.2 设备指纹表结构设计


**💾 设备指纹详细记录表**
```sql
CREATE TABLE device_fingerprints (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    fingerprint_hash VARCHAR(64) UNIQUE NOT NULL,
    user_agent TEXT,
    screen_resolution VARCHAR(20),
    timezone VARCHAR(50),
    language VARCHAR(10),
    platform VARCHAR(50),
    plugins_hash VARCHAR(64),
    first_seen DATETIME NOT NULL,
    last_seen DATETIME NOT NULL,
    usage_count INT DEFAULT 1,
    risk_level ENUM('low', 'medium', 'high') DEFAULT 'low',
    INDEX idx_fingerprint (fingerprint_hash),
    INDEX idx_last_seen (last_seen)
);
```

### 6.3 设备使用行为分析


**📊 设备使用频率分析**
```sql
-- 分析用户的设备使用习惯
SELECT 
    user_id,
    device_fingerprint,
    COUNT(*) as usage_count,
    COUNT(DISTINCT DATE(login_time)) as active_days,
    ROUND(COUNT(*) / COUNT(DISTINCT DATE(login_time)), 2) as avg_daily_usage,
    MIN(login_time) as first_login,
    MAX(login_time) as last_login,
    DATEDIFF(NOW(), MAX(login_time)) as days_since_last_use,
    CASE 
        WHEN COUNT(*) >= 50 THEN '主力设备'
        WHEN COUNT(*) >= 10 THEN '常用设备'
        WHEN COUNT(*) >= 3 THEN '偶尔使用'
        ELSE '临时设备'
    END as device_category
FROM user_login_logs
WHERE login_status = 'success'
    AND login_time >= DATE_SUB(NOW(), INTERVAL 90 DAY)
GROUP BY user_id, device_fingerprint
ORDER BY user_id, usage_count DESC;
```

### 6.4 可疑设备识别


**🚨 识别高风险设备**
```sql
-- 识别可能存在风险的设备
WITH device_risk_analysis AS (
    SELECT 
        device_fingerprint,
        COUNT(DISTINCT user_id) as user_count,
        COUNT(DISTINCT ip_address) as ip_count,
        COUNT(DISTINCT country) as country_count,
        COUNT(*) as total_logins,
        SUM(CASE WHEN login_status = 'failed' THEN 1 ELSE 0 END) as failed_attempts
    FROM user_login_logs
    WHERE login_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
    GROUP BY device_fingerprint
)
SELECT 
    device_fingerprint,
    user_count,
    ip_count,
    country_count,
    total_logins,
    failed_attempts,
    ROUND(failed_attempts * 100.0 / total_logins, 2) as failure_rate,
    CASE 
        WHEN user_count > 10 THEN '多用户共享设备'
        WHEN ip_count > 20 THEN '频繁切换IP'
        WHEN country_count > 5 THEN '跨国漫游设备'
        WHEN failed_attempts * 100.0 / total_logins > 30 THEN '高失败率设备'
        ELSE '正常设备'
    END as risk_category
FROM device_risk_analysis
WHERE user_count > 1 OR ip_count > 5 OR failed_attempts > 0
ORDER BY 
    CASE 
        WHEN user_count > 10 THEN 1
        WHEN failed_attempts * 100.0 / total_logins > 30 THEN 2
        WHEN ip_count > 20 THEN 3
        ELSE 4
    END,
    total_logins DESC;
```

---

## 7. 📊 用户行为基线建立


### 7.1 什么是用户行为基线

**用户行为基线**是通过分析用户历史登录数据，建立的反映用户正常行为模式的标准。就像给每个用户画一个"正常行为的轮廓"。

```
行为基线包含：
⏰ 时间基线：用户通常什么时候登录
📍 地点基线：用户通常从哪里登录  
📱 设备基线：用户通常用什么设备登录
🔄 频率基线：用户通常多久登录一次
```

### 7.2 建立时间行为基线


**⏰ 用户时间偏好基线**
```sql
-- 为每个用户建立时间行为基线
CREATE TABLE user_time_baseline AS
SELECT 
    user_id,
    -- 最常登录的小时段
    (SELECT HOUR(login_time) 
     FROM user_login_logs l2 
     WHERE l2.user_id = l1.user_id 
       AND l2.login_status = 'success'
       AND l2.login_time >= DATE_SUB(NOW(), INTERVAL 90 DAY)
     GROUP BY HOUR(login_time) 
     ORDER BY COUNT(*) DESC 
     LIMIT 1) as preferred_hour,
    
    -- 常用登录时间段（占比超过10%的小时）
    GROUP_CONCAT(
        DISTINCT CONCAT(HOUR(login_time), ':', 
        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) 
                                   FROM user_login_logs l3 
                                   WHERE l3.user_id = l1.user_id 
                                     AND l3.login_status = 'success'), 1), '%')
        ORDER BY COUNT(*) DESC
    ) as normal_hours,
    
    -- 活跃天数和总登录次数
    COUNT(DISTINCT DATE(login_time)) as active_days,
    COUNT(*) as total_logins,
    
    -- 建立基线的时间
    NOW() as baseline_created
FROM user_login_logs l1
WHERE login_status = 'success'
    AND login_time >= DATE_SUB(NOW(), INTERVAL 90 DAY)
GROUP BY user_id
HAVING COUNT(*) >= 10;  -- 至少10次登录才建立基线
```

### 7.3 建立地理位置基线


**🌍 用户地理位置基线**
```sql
-- 为用户建立地理位置基线
CREATE TABLE user_location_baseline AS
SELECT 
    user_id,
    -- 主要登录国家
    (SELECT country 
     FROM user_login_logs l2 
     WHERE l2.user_id = l1.user_id 
       AND l2.login_status = 'success'
       AND l2.country IS NOT NULL
     GROUP BY country 
     ORDER BY COUNT(*) DESC 
     LIMIT 1) as primary_country,
     
    -- 主要登录城市
    (SELECT city 
     FROM user_login_logs l2 
     WHERE l2.user_id = l1.user_id 
       AND l2.login_status = 'success'
       AND l2.city IS NOT NULL
     GROUP BY city 
     ORDER BY COUNT(*) DESC 
     LIMIT 1) as primary_city,
     
    -- 常用地点列表（占比超过5%的地点）
    GROUP_CONCAT(
        DISTINCT CONCAT(country, '/', city)
        ORDER BY COUNT(*) DESC
    ) as normal_locations,
    
    -- 地理位置的多样性
    COUNT(DISTINCT country) as country_count,
    COUNT(DISTINCT CONCAT(country, '/', city)) as location_count,
    
    NOW() as baseline_created
FROM user_login_logs l1
WHERE login_status = 'success'
    AND login_time >= DATE_SUB(NOW(), INTERVAL 90 DAY)
    AND country IS NOT NULL
GROUP BY user_id
HAVING COUNT(*) >= 10;
```

### 7.4 基线偏离度计算


**📈 计算当前行为与基线的偏离度**
```sql
-- 计算用户最近登录行为与基线的偏离程度
WITH recent_behavior AS (
    SELECT 
        user_id,
        COUNT(*) as recent_logins,
        COUNT(DISTINCT HOUR(login_time)) as hour_diversity,
        COUNT(DISTINCT country) as country_diversity,
        COUNT(DISTINCT device_fingerprint) as device_diversity
    FROM user_login_logs
    WHERE login_status = 'success'
        AND login_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    GROUP BY user_id
)
SELECT 
    rb.user_id,
    rb.recent_logins,
    
    -- 时间偏离度
    CASE 
        WHEN rb.hour_diversity > 12 THEN '时间模式异常'
        WHEN rb.hour_diversity > 6 THEN '时间模式变化'
        ELSE '时间模式正常'
    END as time_deviation,
    
    -- 地理位置偏离度  
    CASE
        WHEN rb.country_diversity > 3 THEN '地理位置异常'
        WHEN rb.country_diversity > 1 THEN '地理位置变化'
        ELSE '地理位置正常'
    END as location_deviation,
    
    -- 设备偏离度
    CASE
        WHEN rb.device_diversity > 5 THEN '设备使用异常'
        WHEN rb.device_diversity > 2 THEN '设备使用变化'
        ELSE '设备使用正常'  
    END as device_deviation,
    
    -- 综合偏离评分
    (CASE 
        WHEN rb.hour_diversity > 12 THEN 3
        WHEN rb.hour_diversity > 6 THEN 1
        ELSE 0
    END +
    CASE
        WHEN rb.country_diversity > 3 THEN 3
        WHEN rb.country_diversity > 1 THEN 1
        ELSE 0
    END +
    CASE
        WHEN rb.device_diversity > 5 THEN 3
        WHEN rb.device_diversity > 2 THEN 1
        ELSE 0
    END) as total_deviation_score
    
FROM recent_behavior rb
ORDER BY total_deviation_score DESC;
```

---

## 8. 🎯 登录风险评分算法


### 8.1 风险评分的概念

**登录风险评分**是一个数值（通常0-100），表示某次登录的风险程度。分数越高，表示这次登录越可能是异常或恶意的。

```
风险评分的用途：
🚨 自动拦截：高分登录自动阻止
🔐 增强验证：中等分数要求额外验证
📊 安全监控：跟踪整体安全趋势
⚖️ 决策支持：为安全团队提供决策依据
```

### 8.2 风险因子定义


**⚖️ 主要风险因子及权重**
```sql
-- 创建风险因子配置表
CREATE TABLE risk_factors (
    factor_name VARCHAR(50) PRIMARY KEY,
    base_score INT NOT NULL,
    max_score INT NOT NULL,
    weight DECIMAL(3,2) NOT NULL,
    description TEXT,
    status ENUM('active', 'inactive') DEFAULT 'active'
);

-- 插入风险因子配置
INSERT INTO risk_factors VALUES
('new_device', 20, 40, 1.5, '使用新设备登录', 'active'),
('unusual_time', 15, 30, 1.2, '异常时间登录', 'active'),
('new_location', 25, 50, 1.8, '新地理位置登录', 'active'),
('multiple_failures', 30, 60, 2.0, '多次登录失败', 'active'),
('suspicious_ip', 35, 70, 2.2, '可疑IP地址', 'active'),
('rapid_location_change', 40, 80, 2.5, '快速地理位置变化', 'active');
```

### 8.3 实时风险评分计算


**🔢 登录风险评分计算函数**
```sql
DELIMITER //
CREATE FUNCTION calculate_login_risk_score(
    p_user_id INT,
    p_ip_address VARCHAR(45),
    p_country VARCHAR(50),
    p_city VARCHAR(100),
    p_device_fingerprint VARCHAR(255),
    p_login_time DATETIME
) RETURNS DECIMAL(5,2)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE risk_score DECIMAL(5,2) DEFAULT 0;
    DECLARE device_count INT DEFAULT 0;
    DECLARE location_count INT DEFAULT 0;
    DECLARE recent_failures INT DEFAULT 0;
    DECLARE time_score INT DEFAULT 0;
    
    -- 1. 检查设备新旧程度
    SELECT COUNT(*) INTO device_count
    FROM user_login_logs 
    WHERE user_id = p_user_id 
        AND device_fingerprint = p_device_fingerprint
        AND login_status = 'success'
        AND login_time < p_login_time;
    
    IF device_count = 0 THEN
        SET risk_score = risk_score + 40;  -- 全新设备
    ELSEIF device_count < 5 THEN
        SET risk_score = risk_score + 20;  -- 不常用设备
    END IF;
    
    -- 2. 检查地理位置
    SELECT COUNT(*) INTO location_count
    FROM user_login_logs 
    WHERE user_id = p_user_id 
        AND country = p_country 
        AND city = p_city
        AND login_status = 'success'
        AND login_time < p_login_time;
    
    IF location_count = 0 THEN
        SET risk_score = risk_score + 50;  -- 全新地点
    ELSEIF location_count < 3 THEN
        SET risk_score = risk_score + 25;  -- 不常用地点
    END IF;
    
    -- 3. 检查最近登录失败次数
    SELECT COUNT(*) INTO recent_failures
    FROM user_login_logs 
    WHERE user_id = p_user_id 
        AND login_status = 'failed'
        AND login_time >= DATE_SUB(p_login_time, INTERVAL 1 HOUR);
    
    SET risk_score = risk_score + LEAST(recent_failures * 15, 60);
    
    -- 4. 检查登录时间异常
    SELECT 
        CASE 
            WHEN COUNT(*) = 0 THEN 30  -- 从未在此时间登录
            WHEN COUNT(*) < 3 THEN 15  -- 很少在此时间登录
            ELSE 0
        END INTO time_score
    FROM user_login_logs 
    WHERE user_id = p_user_id 
        AND HOUR(login_time) = HOUR(p_login_time)
        AND login_status = 'success'
        AND login_time < p_login_time;
    
    SET risk_score = risk_score + time_score;
    
    -- 确保分数在合理范围内
    RETURN LEAST(risk_score, 100);
END //
DELIMITER ;
```

### 8.4 批量风险评分更新


**🔄 为历史登录记录计算风险分数**
```sql
-- 为最近的登录记录批量计算风险分数
UPDATE user_login_logs 
SET risk_score = calculate_login_risk_score(
    user_id, 
    ip_address, 
    country, 
    city, 
    device_fingerprint, 
    login_time
)
WHERE login_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    AND login_status = 'success'
    AND risk_score IS NULL;
```

### 8.5 风险等级分类


**📊 根据分数划分风险等级**
```sql
-- 查看不同风险等级的登录分布
SELECT 
    CASE 
        WHEN risk_score >= 80 THEN '极高风险'
        WHEN risk_score >= 60 THEN '高风险'
        WHEN risk_score >= 40 THEN '中等风险'
        WHEN risk_score >= 20 THEN '低风险'
        ELSE '正常'
    END as risk_level,
    COUNT(*) as login_count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () as percentage,
    AVG(risk_score) as avg_score
FROM user_login_logs 
WHERE risk_score IS NOT NULL
    AND login_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY 
    CASE 
        WHEN risk_score >= 80 THEN '极高风险'
        WHEN risk_score >= 60 THEN '高风险'
        WHEN risk_score >= 40 THEN '中等风险'
        WHEN risk_score >= 20 THEN '低风险'
        ELSE '正常'
    END
ORDER BY avg_score DESC;
```

---

## 9. 🛡️ 登录行为安全分析


### 9.1 安全分析的目标

通过对登录行为的深入分析，及时发现安全威胁，保护用户账户安全，维护系统整体安全。

```
安全分析的核心目标：
🎯 威胁检测：识别账户劫持、撞库攻击等威胁
🛡️ 风险预防：在攻击成功前阻止恶意行为
📊 态势感知：了解整体安全状况和趋势
🔍 调查支持：为安全事件调查提供数据支持
```

### 9.2 攻击模式识别


**🔍 识别暴力破解攻击**
```sql
-- 检测可能的暴力破解攻击
WITH brute_force_analysis AS (
    SELECT 
        ip_address,
        user_id,
        COUNT(*) as attempt_count,
        SUM(CASE WHEN login_status = 'failed' THEN 1 ELSE 0 END) as failed_count,
        MIN(login_time) as first_attempt,
        MAX(login_time) as last_attempt,
        COUNT(DISTINCT user_id) as target_users
    FROM user_login_logs 
    WHERE login_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
    GROUP BY ip_address, user_id
)
SELECT 
    ip_address,
    target_users,
    SUM(attempt_count) as total_attempts,
    SUM(failed_count) as total_failures,
    ROUND(SUM(failed_count) * 100.0 / SUM(attempt_count), 2) as failure_rate,
    MIN(first_attempt) as attack_start,
    MAX(last_attempt) as attack_end,
    '暴力破解攻击' as attack_type
FROM brute_force_analysis
GROUP BY ip_address
HAVING SUM(failed_count) >= 10  -- 至少10次失败
    AND SUM(failed_count) * 100.0 / SUM(attempt_count) >= 80  -- 失败率超过80%
ORDER BY total_failures DESC;
```

### 9.3 账户接管检测


**🚨 检测可能的账户接管**
```sql
-- 检测账户接管的迹象
WITH account_takeover_signals AS (
    SELECT 
        user_id,
        login_time,
        ip_address,
        country,
        device_fingerprint,
        
        -- 与历史模式的差异
        CASE 
            WHEN country NOT IN (
                SELECT DISTINCT country 
                FROM user_login_logs l2 
                WHERE l2.user_id = l1.user_id 
                    AND l2.login_time < l1.login_time 
                    AND l2.login_time >= DATE_SUB(l1.login_time, INTERVAL 90 DAY)
                    AND l2.login_status = 'success'
            ) THEN 1 ELSE 0
        END as new_country,
        
        CASE 
            WHEN device_fingerprint NOT IN (
                SELECT DISTINCT device_fingerprint 
                FROM user_login_logs l2 
                WHERE l2.user_id = l1.user_id 
                    AND l2.login_time < l1.login_time
                    AND l2.login_time >= DATE_SUB(l1.login_time, INTERVAL 30 DAY)
                    AND l2.login_status = 'success'
            ) THEN 1 ELSE 0
        END as new_device,
        
        -- 检查是否在异常时间
        CASE 
            WHEN HOUR(login_time) NOT IN (
                SELECT DISTINCT HOUR(login_time) 
                FROM user_login_logs l2 
                WHERE l2.user_id = l1.user_id 
                    AND l2.login_time < l1.login_time
                    AND l2.login_time >= DATE_SUB(l1.login_time, INTERVAL 90 DAY)
                    AND l2.login_status = 'success'
                GROUP BY HOUR(login_time)
                HAVING COUNT(*) >= 3
            ) THEN 1 ELSE 0
        END as unusual_time
        
    FROM user_login_logs l1
    WHERE login_status = 'success'
        AND login_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
)
SELECT 
    user_id,
    login_time,
    ip_address,
    country,
    (new_country + new_device + unusual_time) as suspicious_score,
    CASE 
        WHEN (new_country + new_device + unusual_time) >= 3 THEN '高度可疑'
        WHEN (new_country + new_device + unusual_time) = 2 THEN '中度可疑'
        WHEN (new_country + new_device + unusual_time) = 1 THEN '轻度可疑'
        ELSE '正常'
    END as suspicion_level,
    '可能账户接管' as alert_type
FROM account_takeover_signals
WHERE (new_country + new_device + unusual_time) >= 2
ORDER BY suspicious_score DESC, login_time DESC;
```

### 9.4 安全指标监控


**📈 关键安全指标统计**
```sql
-- 生成安全监控仪表板数据
WITH security_metrics AS (
    SELECT 
        DATE(login_time) as login_date,
        COUNT(*) as total_logins,
        SUM(CASE WHEN login_status = 'success' THEN 1 ELSE 0 END) as successful_logins,
        SUM(CASE WHEN login_status = 'failed' THEN 1 ELSE 0 END) as failed_logins,
        SUM(CASE WHEN login_status = 'blocked' THEN 1 ELSE 0 END) as blocked_logins,
        COUNT(DISTINCT user_id) as unique_users,
        COUNT(DISTINCT ip_address) as unique_ips,
        COUNT(DISTINCT device_fingerprint) as unique_devices,
        AVG(COALESCE(risk_score, 0)) as avg_risk_score
    FROM user_login_logs 
    WHERE login_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
    GROUP BY DATE(login_time)
)
SELECT 
    login_date,
    total_logins,
    successful_logins,
    failed_logins,
    blocked_logins,
    ROUND(failed_logins * 100.0 / total_logins, 2) as failure_rate,
    ROUND(blocked_logins * 100.0 / total_logins, 2) as block_rate,
    unique_users,
    unique_ips,
    unique_devices,
    ROUND(avg_risk_score, 2) as avg_risk_score,
    
    -- 安全健康度评分（0-100）
    ROUND(100 - (
        LEAST(failed_logins * 100.0 / total_logins, 50) * 0.4 +  -- 失败率影响40%
        LEAST(blocked_logins * 100.0 / total_logins, 20) * 0.3 +  -- 阻断率影响30%
        LEAST(avg_risk_score, 50) * 0.3                           -- 平均风险分影响30%
    ), 2) as security_health_score
    
FROM security_metrics
ORDER BY login_date DESC;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 登录行为分析：通过分析登录数据发现异常，保护账户安全
🔸 登录模式：用户的正常登录习惯和规律
🔸 异常检测：识别与正常模式不符的可疑登录行为
🔸 设备指纹：设备的唯一标识，用于追踪和识别设备
🔸 行为基线：用户正常行为的标准模式
🔸 风险评分：量化每次登录的风险程度
🔸 安全分析：深入分析发现攻击和威胁
```

### 10.2 关键技术要点


**🔹 数据收集要全面**
```
必收集数据：
- 登录时间、IP地址、设备信息
- 地理位置、登录结果、用户代理
- 设备指纹、会话信息

数据质量要求：
- 准确性：确保数据真实可靠
- 完整性：避免关键字段缺失  
- 时效性：实时或准实时收集
```

**🔹 分析方法要科学**
```
统计分析：
- 建立用户行为模式和基线
- 使用历史数据进行对比分析
- 计算偏离度和异常程度

机器学习：
- 无监督学习发现异常模式
- 有监督学习训练风险模型
- 深度学习提升检测精度
```

**🔹 响应机制要及时**
```
实时监控：
- 登录时实时计算风险分数
- 超过阈值立即触发安全措施
- 自动化响应减少人工干预

分级处理：
- 低风险：正常放行
- 中风险：要求额外验证
- 高风险：阻断并人工审核
```

### 10.3 实际应用指导


**🎯 部署建议**
```
分阶段实施：
① 基础数据收集和存储
② 简单的异常检测规则
③ 复杂的行为分析算法
④ 机器学习和AI增强

性能考虑：
- 使用合适的索引优化查询
- 定期清理历史数据
- 异步处理复杂分析任务
- 缓存常用的分析结果
```

**⚖️ 平衡安全与体验**
```
避免误判：
- 建立充分的历史数据基线
- 设置合理的风险阈值
- 提供用户申诉机制

提升体验：
- 对可信用户降低验证要求
- 提供便捷的身份验证方式
- 及时通知用户安全事件
```

### 10.4 安全防护价值


**💪 防护能力**
- **账户保护**：及时发现账户被盗用
- **攻击检测**：识别暴力破解、撞库等攻击
- **风险控制**：基于风险评分的动态防护
- **合规支持**：满足数据安全法规要求

**📊 业务价值**
- **用户信任**：保护用户隐私和资产安全
- **品牌保护**：避免安全事件损害品牌形象
- **成本节约**：自动化检测减少人工成本
- **业务洞察**：了解用户行为支持产品优化

**核心记忆**：
- 登录行为分析是现代系统安全的重要基础
- 通过模式识别和异常检测保护账户安全
- 平衡安全防护强度与用户体验的便捷性
- 持续优化算法提高检测准确性和效率