---
title: 12、MySQL动态权限管理
---
## 📚 目录

1. [动态权限系统概述](#1-动态权限系统概述)
2. [运行时权限调整](#2-运行时权限调整)
3. [权限热更新机制](#3-权限热更新机制)
4. [动态权限注册与插件](#4-动态权限注册与插件)
5. [临时权限授予](#5-临时权限授予)
6. [动态权限监控](#6-动态权限监控)
7. [权限插件架构设计](#7-权限插件架构设计)
8. [动态权限API接口](#8-动态权限api接口)
9. [安全控制与策略](#9-安全控制与策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔄 动态权限系统概述


### 1.1 什么是动态权限


**简单理解**：动态权限就是可以在MySQL运行过程中随时调整的权限设置，不需要重启数据库。

```
传统权限 vs 动态权限：

传统权限（静态）：
配置文件修改 → 重启MySQL → 权限生效
↓
影响：服务中断，用户体验差

动态权限（动态）：
在线执行命令 → 立即生效 → 无需重启
↓
优势：零中断，实时调整
```

**核心特点**：
- **实时生效**：权限变更立即生效，无需重启
- **热更新**：支持在线修改权限配置
- **插件支持**：可以通过插件扩展新的权限类型
- **监控友好**：权限变更可以被实时监控

### 1.2 动态权限的应用场景


**典型使用场景**：

```
🎯 紧急权限调整
场景：突发安全事件需要立即回收某用户权限
传统方式：修改配置→重启→影响所有用户
动态方式：执行一条命令→立即生效→零影响

🎯 临时权限授予  
场景：开发人员临时需要生产库查询权限
动态方式：授予临时权限→设置过期时间→自动回收

🎯 权限AB测试
场景：测试新权限策略的效果
动态方式：实时切换权限配置→观察效果→快速回滚
```

---

## 2. ⚡ 运行时权限调整


### 2.1 基本权限调整命令


**权限立即生效**：MySQL 8.0支持多种运行时权限调整方式。

```sql
-- 立即授予权限（无需重启）
GRANT SELECT ON database.* TO 'user'@'host';

-- 立即回收权限
REVOKE SELECT ON database.* FROM 'user'@'host';

-- 修改用户密码（立即生效）
ALTER USER 'user'@'host' IDENTIFIED BY 'new_password';

-- 锁定用户账户（立即生效）
ALTER USER 'user'@'host' ACCOUNT LOCK;
```

### 2.2 系统变量动态调整


**运行时修改系统权限相关变量**：

```sql
-- 动态调整最大连接数
SET GLOBAL max_connections = 500;

-- 动态调整查询缓存大小
SET GLOBAL query_cache_size = 64*1024*1024;

-- 动态调整权限检查级别
SET GLOBAL validate_password.policy = 'STRONG';

-- 查看当前动态变量状态
SHOW GLOBAL VARIABLES LIKE 'max_connections';
```

**实际应用示例**：
```sql
-- 紧急情况：限制新连接
SET GLOBAL max_connections = 10;

-- 高峰期：增加连接池
SET GLOBAL max_connections = 1000;

-- 维护期：禁用某些权限检查
SET GLOBAL sql_mode = 'NO_ENGINE_SUBSTITUTION';
```

### 2.3 权限刷新机制


**让权限变更立即生效**：

```sql
-- 强制刷新权限表（立即生效）
FLUSH PRIVILEGES;

-- 重新加载权限相关表
FLUSH TABLES mysql.user, mysql.db, mysql.tables_priv;

-- 检查权限是否生效
SELECT User, Host, Select_priv FROM mysql.user WHERE User='testuser';
```

---

## 3. 🔥 权限热更新机制


### 3.1 热更新的工作原理


**理解热更新**：就像给运行中的汽车换轮胎，不停车就能更换配置。

```
热更新流程：
                                    
用户权限变更请求                     内存权限缓存
       │                              │
       ▼                              ▼
  ┌─────────────┐    更新权限    ┌─────────────┐
  │  权限命令   │ ────────────▶  │ 权限管理器   │
  │ GRANT/REVOKE│                │   (内存)    │
  └─────────────┘                └─────────────┘
       │                              │
       ▼                              ▼
  ┌─────────────┐    同步更新    ┌─────────────┐
  │  权限表     │ ◀────────────  │  活跃连接   │
  │ (mysql库)   │                │  权限检查   │
  └─────────────┘                └─────────────┘
```

### 3.2 热更新配置示例


**配置权限热更新**：

```sql
-- 启用自动权限刷新
SET GLOBAL automatic_sp_privileges = ON;

-- 配置权限缓存时间
SET GLOBAL table_definition_cache = 2000;

-- 查看权限更新状态
SHOW STATUS LIKE 'Com_grant%';
SHOW STATUS LIKE 'Com_revoke%';
```

### 3.3 热更新安全验证


**确保热更新的安全性**：

```sql
-- 1. 更新前备份当前权限
CREATE TABLE user_backup AS SELECT * FROM mysql.user;

-- 2. 执行权限更新
GRANT UPDATE ON sales.* TO 'analyst'@'%';

-- 3. 验证更新结果
SELECT User, Host, Update_priv FROM mysql.user WHERE User='analyst';

-- 4. 测试权限是否生效
-- (用analyst用户连接测试UPDATE操作)

-- 5. 如有问题，快速回滚
-- DELETE FROM mysql.user WHERE User='analyst';
-- INSERT INTO mysql.user SELECT * FROM user_backup WHERE User='analyst';
-- FLUSH PRIVILEGES;
```

---

## 4. 🔌 动态权限注册与插件


### 4.1 动态权限注册机制


**插件式权限扩展**：MySQL支持通过插件注册新的权限类型。

```sql
-- 查看已注册的动态权限
SELECT * FROM INFORMATION_SCHEMA.USER_PRIVILEGES 
WHERE PRIVILEGE_TYPE LIKE 'DYNAMIC_%';

-- 查看插件注册的权限
SHOW PLUGINS;

-- 安装权限管理插件
INSTALL PLUGIN auth_pam SONAME 'auth_pam.so';
```

### 4.2 自定义权限插件开发


**插件架构示例**：

```c
// 简化的权限插件结构
struct permission_plugin {
    char *name;                    // 权限名称
    int (*check_permission)(       // 权限检查函数
        const char *user,
        const char *host,
        const char *resource
    );
    int (*grant_permission)(       // 授权函数
        const char *user,
        const char *resource
    );
};

// 注册自定义权限
static int register_custom_permission() {
    return mysql_register_dynamic_privilege(
        "CUSTOM_READ_ANALYTICS",   // 权限名
        check_analytics_permission  // 检查函数
    );
}
```

### 4.3 权限插件配置


**配置插件权限**：

```sql
-- 授予插件定义的动态权限
GRANT BACKUP_ADMIN ON *.* TO 'backup_user'@'localhost';
GRANT CLONE_ADMIN ON *.* TO 'clone_user'@'localhost';

-- 查看动态权限状态
SELECT 
    GRANTEE,
    PRIVILEGE_TYPE,
    IS_GRANTABLE
FROM INFORMATION_SCHEMA.USER_PRIVILEGES 
WHERE PRIVILEGE_TYPE IN ('BACKUP_ADMIN', 'CLONE_ADMIN');
```

---

## 5. ⏰ 临时权限授予


### 5.1 临时权限的概念


**什么是临时权限**：有时间限制的权限，到期自动回收，就像临时停车证。

### 5.2 实现临时权限的方法


**通过事件调度器实现**：

```sql
-- 1. 启用事件调度器
SET GLOBAL event_scheduler = ON;

-- 2. 授予临时权限
GRANT SELECT ON sensitive_data.* TO 'temp_user'@'%';

-- 3. 创建自动回收事件
DELIMITER $$
CREATE EVENT revoke_temp_permission
ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 2 HOUR
DO BEGIN
    REVOKE SELECT ON sensitive_data.* FROM 'temp_user'@'%';
    
    -- 记录权限回收日志
    INSERT INTO admin_log (action, details, timestamp) 
    VALUES ('REVOKE', 'Temporary SELECT permission revoked for temp_user', NOW());
END$$
DELIMITER ;

-- 4. 查看临时权限状态
SHOW EVENTS WHERE Name='revoke_temp_permission';
```

### 5.3 临时权限管理最佳实践


**安全的临时权限策略**：

```sql
-- 创建临时权限管理表
CREATE TABLE temp_permissions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    hostname VARCHAR(50),
    permission_type VARCHAR(100),
    resource_name VARCHAR(200),
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    status ENUM('ACTIVE', 'EXPIRED', 'REVOKED') DEFAULT 'ACTIVE',
    granted_by VARCHAR(50),
    reason TEXT
);

-- 授予临时权限并记录
INSERT INTO temp_permissions 
(username, hostname, permission_type, resource_name, expires_at, granted_by, reason)
VALUES 
('developer1', '%', 'SELECT', 'production.orders', 
 DATE_ADD(NOW(), INTERVAL 4 HOUR), 'admin', 'Debug production issue #1234');

-- 定期清理过期权限的存储过程
DELIMITER $$
CREATE PROCEDURE CleanupExpiredPermissions()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_username, v_hostname, v_permission, v_resource VARCHAR(200);
    
    -- 游标获取过期权限
    DECLARE expire_cursor CURSOR FOR
        SELECT username, hostname, permission_type, resource_name
        FROM temp_permissions 
        WHERE expires_at < NOW() AND status = 'ACTIVE';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN expire_cursor;
    
    cleanup_loop: LOOP
        FETCH expire_cursor INTO v_username, v_hostname, v_permission, v_resource;
        
        IF done THEN
            LEAVE cleanup_loop;
        END IF;
        
        -- 构建并执行REVOKE语句
        SET @sql = CONCAT('REVOKE ', v_permission, ' ON ', v_resource, 
                         ' FROM ''', v_username, '''@''', v_hostname, '''');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 更新权限状态
        UPDATE temp_permissions 
        SET status = 'EXPIRED' 
        WHERE username = v_username AND hostname = v_hostname 
          AND permission_type = v_permission AND resource_name = v_resource
          AND status = 'ACTIVE';
          
    END LOOP;
    
    CLOSE expire_cursor;
END$$
DELIMITER ;

-- 设置定期执行清理
CREATE EVENT cleanup_expired_permissions
ON SCHEDULE EVERY 1 HOUR
DO CALL CleanupExpiredPermissions();
```

---

## 6. 📊 动态权限监控


### 6.1 权限变更监控


**实时监控权限变化**：

```sql
-- 启用通用查询日志（记录所有权限操作）
SET GLOBAL general_log = ON;
SET GLOBAL general_log_file = '/var/log/mysql/mysql-general.log';

-- 创建权限变更监控表
CREATE TABLE permission_audit (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user VARCHAR(100),
    host VARCHAR(100),
    operation VARCHAR(20),  -- GRANT, REVOKE, ALTER
    privilege_type VARCHAR(50),
    object_name VARCHAR(200),
    grantee VARCHAR(100),
    details JSON,
    source_ip VARCHAR(45)
);

-- 创建权限变更触发器
DELIMITER $$
CREATE TRIGGER log_user_changes
AFTER UPDATE ON mysql.user
FOR EACH ROW
BEGIN
    INSERT INTO permission_audit 
    (user, host, operation, privilege_type, object_name, grantee, details)
    VALUES 
    (USER(), CONNECTION_ID(), 'ALTER', 'USER_PRIVILEGE', 
     CONCAT(NEW.User, '@', NEW.Host), CONCAT(NEW.User, '@', NEW.Host),
     JSON_OBJECT('old_privileges', ROW(OLD.*), 'new_privileges', ROW(NEW.*)));
END$$
DELIMITER ;
```

### 6.2 权限使用情况监控


**监控权限的实际使用**：

```sql
-- 查看活跃用户的权限使用情况
SELECT 
    USER,
    HOST,
    COMMAND,
    STATE,
    INFO,
    TIME
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE COMMAND != 'Sleep'
ORDER BY TIME DESC;

-- 分析权限使用频率
SELECT 
    GRANTEE,
    PRIVILEGE_TYPE,
    COUNT(*) as usage_count
FROM INFORMATION_SCHEMA.USER_PRIVILEGES up
JOIN INFORMATION_SCHEMA.PROCESSLIST pl ON 
    SUBSTRING_INDEX(up.GRANTEE, '@', 1) = CONCAT("'", pl.USER, "'")
GROUP BY GRANTEE, PRIVILEGE_TYPE
ORDER BY usage_count DESC;
```

### 6.3 权限监控告警


**设置权限异常告警**：

```sql
-- 创建权限异常检测存储过程
DELIMITER $$
CREATE PROCEDURE CheckPermissionAnomalies()
BEGIN
    DECLARE anomaly_count INT DEFAULT 0;
    
    -- 检测异常权限授予（如给普通用户授予了SUPER权限）
    SELECT COUNT(*) INTO anomaly_count
    FROM mysql.user 
    WHERE Super_priv = 'Y' 
      AND User NOT IN ('root', 'mysql.sys', 'mysql.session');
    
    IF anomaly_count > 0 THEN
        INSERT INTO security_alerts 
        (alert_type, severity, message, detected_at)
        VALUES 
        ('PRIVILEGE_ANOMALY', 'HIGH', 
         CONCAT('Found ', anomaly_count, ' non-admin users with SUPER privilege'),
         NOW());
    END IF;
    
    -- 检测权限升级（普通用户获得了管理员权限）
    SELECT COUNT(*) INTO anomaly_count
    FROM permission_audit 
    WHERE operation = 'GRANT' 
      AND privilege_type IN ('ALL PRIVILEGES', 'SUPER', 'FILE', 'PROCESS')
      AND timestamp > DATE_SUB(NOW(), INTERVAL 1 HOUR);
      
    IF anomaly_count > 0 THEN
        INSERT INTO security_alerts 
        (alert_type, severity, message, detected_at)
        VALUES 
        ('PRIVILEGE_ESCALATION', 'CRITICAL', 
         CONCAT('Detected ', anomaly_count, ' privilege escalations in last hour'),
         NOW());
    END IF;
END$$
DELIMITER ;

-- 定期执行权限异常检测
CREATE EVENT permission_anomaly_check
ON SCHEDULE EVERY 30 MINUTE
DO CALL CheckPermissionAnomalies();
```

---

## 7. 🏗️ 权限插件架构设计


### 7.1 插件架构概述


**权限插件的设计思路**：把权限管理变成可插拔的模块，就像手机应用一样可以安装卸载。

```
权限插件架构：

┌─────────────────────────────────────┐
│           MySQL核心引擎              │
├─────────────────────────────────────┤
│         权限管理框架                 │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ │
│  │基础权限 │ │动态权限 │ │自定义权限│ │
│  │ 插件   │ │ 插件   │ │  插件   │ │
│  └─────────┘ └─────────┘ └─────────┘ │
├─────────────────────────────────────┤
│         插件注册中心                 │
├─────────────────────────────────────┤
│         权限执行引擎                 │
└─────────────────────────────────────┘
```

### 7.2 插件接口定义


**标准权限插件接口**：

```c
// 权限插件接口结构
typedef struct {
    const char *name;                    // 插件名称
    const char *version;                 // 版本号
    
    // 初始化函数
    int (*init)(void *plugin_info);
    
    // 权限检查函数
    int (*check_privilege)(
        const char *user,               // 用户名
        const char *host,               // 主机
        const char *privilege,          // 权限类型
        const char *object             // 对象名
    );
    
    // 权限授予函数
    int (*grant_privilege)(
        const char *user,
        const char *host,
        const char *privilege,
        const char *object,
        int with_grant_option
    );
    
    // 权限回收函数
    int (*revoke_privilege)(
        const char *user,
        const char *host,
        const char *privilege,
        const char *object
    );
    
    // 清理函数
    int (*deinit)(void);
    
} mysql_privilege_plugin_interface;
```

### 7.3 插件开发示例


**开发一个简单的时间权限插件**：

```c
// 时间权限插件：只允许在特定时间访问
#include <mysql/plugin.h>
#include <time.h>

// 检查时间权限
static int check_time_privilege(
    const char *user,
    const char *host,
    const char *privilege,
    const char *object)
{
    time_t now;
    struct tm *timeinfo;
    
    time(&now);
    timeinfo = localtime(&now);
    
    // 只允许工作时间(9-18点)访问
    if (timeinfo->tm_hour >= 9 && timeinfo->tm_hour < 18) {
        return 0;  // 允许访问
    }
    
    // 记录拒绝访问日志
    sql_print_warning("Time privilege denied for user %s@%s at %d:00", 
                     user, host, timeinfo->tm_hour);
    
    return 1;  // 拒绝访问
}

// 插件描述
static struct st_mysql_privilege time_privilege_plugin = {
    MYSQL_PRIVILEGE_INTERFACE_VERSION,
    check_time_privilege,
    NULL,  // grant函数
    NULL   // revoke函数
};

// 插件声明
mysql_declare_plugin(time_privilege)
{
    MYSQL_PRIVILEGE_PLUGIN,
    &time_privilege_plugin,
    "time_privilege",
    "MySQL Team",
    "Time-based access control",
    PLUGIN_LICENSE_GPL,
    NULL,  // init
    NULL,  // deinit
    0x0100,
    NULL,
    NULL,
    NULL,
    0,
}
mysql_declare_plugin_end;
```

---

## 8. 🔧 动态权限API接口


### 8.1 权限管理API概述


**通过API管理权限**：提供编程接口，让应用程序可以动态管理数据库权限。

### 8.2 基本API接口


**核心权限API函数**：

```sql
-- 权限检查API
SELECT PRIVILEGE_CHECK('SELECT', 'database.table', 'user@host') as has_privilege;

-- 权限授予API  
CALL GRANT_PRIVILEGE('user@host', 'SELECT', 'database.table', FALSE);

-- 权限回收API
CALL REVOKE_PRIVILEGE('user@host', 'SELECT', 'database.table');

-- 批量权限操作API
CALL BATCH_GRANT_PRIVILEGES(
    JSON_ARRAY(
        JSON_OBJECT('user', 'user1@%', 'privilege', 'SELECT', 'object', 'db1.*'),
        JSON_OBJECT('user', 'user2@%', 'privilege', 'INSERT', 'object', 'db2.*')
    )
);
```

### 8.3 高级API接口


**实现高级权限管理API**：

```sql
-- 创建权限管理API存储过程
DELIMITER $$

-- 智能权限授予（自动处理依赖）
CREATE PROCEDURE SMART_GRANT_PRIVILEGE(
    IN p_user VARCHAR(100),
    IN p_privilege VARCHAR(50),
    IN p_object VARCHAR(200),
    IN p_temporary BOOLEAN DEFAULT FALSE,
    IN p_duration_hours INT DEFAULT 24
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 检查用户是否存在
    IF NOT EXISTS (SELECT 1 FROM mysql.user WHERE CONCAT(User,'@',Host) = p_user) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'User does not exist';
    END IF;
    
    -- 执行权限授予
    SET @sql = CONCAT('GRANT ', p_privilege, ' ON ', p_object, ' TO ', p_user);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 如果是临时权限，创建自动回收任务
    IF p_temporary THEN
        SET @event_name = CONCAT('revoke_', REPLACE(p_user, '@', '_at_'), '_', 
                                UNIX_TIMESTAMP(), '_', CONNECTION_ID());
        SET @sql = CONCAT(
            'CREATE EVENT ', @event_name,
            ' ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL ', p_duration_hours, ' HOUR ',
            ' DO BEGIN ',
            '   REVOKE ', p_privilege, ' ON ', p_object, ' FROM ', p_user, '; ',
            '   DROP EVENT ', @event_name, '; ',
            ' END'
        );
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END IF;
    
    -- 记录操作日志
    INSERT INTO permission_audit 
    (operation, privilege_type, object_name, grantee, details) 
    VALUES 
    ('SMART_GRANT', p_privilege, p_object, p_user,
     JSON_OBJECT('temporary', p_temporary, 'duration_hours', p_duration_hours));
    
    COMMIT;
    
    SELECT 'SUCCESS' as result, @event_name as cleanup_event;
END$$

-- 权限影响分析API
CREATE FUNCTION ANALYZE_PRIVILEGE_IMPACT(
    p_user VARCHAR(100),
    p_privilege VARCHAR(50),
    p_object VARCHAR(200),
    p_action ENUM('GRANT', 'REVOKE')
) RETURNS JSON
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE result JSON DEFAULT JSON_OBJECT();
    DECLARE affected_tables INT DEFAULT 0;
    DECLARE current_privileges TEXT DEFAULT '';
    
    -- 分析影响的表数量
    SELECT COUNT(*) INTO affected_tables
    FROM information_schema.tables t
    WHERE CONCAT(t.table_schema, '.', t.table_name) LIKE 
          REPLACE(REPLACE(p_object, '*', '%'), '.*', '.%');
    
    -- 获取用户当前权限
    SELECT GROUP_CONCAT(privilege_type) INTO current_privileges
    FROM information_schema.user_privileges 
    WHERE grantee = CONCAT("'", SUBSTRING_INDEX(p_user, '@', 1), "'@'", 
                          SUBSTRING_INDEX(p_user, '@', -1), "'");
    
    -- 构建分析结果
    SET result = JSON_OBJECT(
        'affected_tables', affected_tables,
        'current_privileges', current_privileges,
        'action', p_action,
        'risk_level', CASE 
            WHEN p_privilege IN ('ALL PRIVILEGES', 'SUPER', 'FILE') THEN 'HIGH'
            WHEN p_privilege IN ('DROP', 'ALTER', 'DELETE') THEN 'MEDIUM'
            ELSE 'LOW'
        END,
        'recommendation', CASE
            WHEN p_action = 'GRANT' AND p_privilege = 'ALL PRIVILEGES' THEN 
                'Consider granting specific privileges instead of ALL'
            WHEN p_action = 'REVOKE' AND affected_tables > 100 THEN
                'This will affect many tables, consider testing first'
            ELSE 'Safe to proceed'
        END
    );
    
    RETURN result;
END$$

DELIMITER ;
```

---

## 9. 🔒 安全控制与策略


### 9.1 动态权限安全原则


**动态权限的安全考虑**：权限变更虽然灵活，但必须有严格的安全控制。

```
安全控制层次：

认证层面：
├── 多因素认证
├── 强密码策略  
└── 会话管理

授权层面：
├── 最小权限原则
├── 职责分离
└── 权限审批流程

审计层面：
├── 完整日志记录
├── 实时监控告警
└── 定期权限审查
```

### 9.2 临时权限安全策略


**临时权限的安全实现**：

```sql
-- 创建安全的临时权限管理框架
CREATE TABLE temp_permission_requests (
    id INT AUTO_INCREMENT PRIMARY KEY,
    requester VARCHAR(100) NOT NULL,
    target_user VARCHAR(100) NOT NULL,
    privilege_type VARCHAR(50) NOT NULL,
    object_name VARCHAR(200) NOT NULL,
    business_justification TEXT NOT NULL,
    requested_duration_hours INT NOT NULL,
    approver VARCHAR(100),
    status ENUM('PENDING', 'APPROVED', 'DENIED', 'EXPIRED') DEFAULT 'PENDING',
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approved_at TIMESTAMP NULL,
    expires_at TIMESTAMP NULL,
    approval_token VARCHAR(64)
);

-- 临时权限申请流程
DELIMITER $$
CREATE PROCEDURE REQUEST_TEMP_PRIVILEGE(
    IN p_target_user VARCHAR(100),
    IN p_privilege VARCHAR(50),
    IN p_object VARCHAR(200),
    IN p_justification TEXT,
    IN p_duration_hours INT
)
BEGIN
    DECLARE v_requester VARCHAR(100);
    DECLARE v_request_id INT;
    DECLARE v_approval_token VARCHAR(64);
    
    -- 获取请求者信息
    SELECT USER() INTO v_requester;
    
    -- 生成审批令牌
    SET v_approval_token = SHA2(CONCAT(
        v_requester, p_target_user, p_privilege, p_object, NOW(), CONNECTION_ID()
    ), 256);
    
    -- 验证请求的合理性
    IF p_duration_hours > 168 THEN  -- 不超过7天
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Duration too long (max 168 hours)';
    END IF;
    
    IF p_privilege IN ('ALL PRIVILEGES', 'SUPER', 'FILE') AND p_duration_hours > 24 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'High privilege duration limited to 24 hours';
    END IF;
    
    -- 插入权限请求
    INSERT INTO temp_permission_requests 
    (requester, target_user, privilege_type, object_name, 
     business_justification, requested_duration_hours, approval_token)
    VALUES 
    (v_requester, p_target_user, p_privilege, p_object, 
     p_justification, p_duration_hours, v_approval_token);
     
    SET v_request_id = LAST_INSERT_ID();
    
    -- 发送审批通知（这里简化为插入通知表）
    INSERT INTO approval_notifications 
    (request_id, approver_role, message, created_at)
    VALUES 
    (v_request_id, 'DBA', 
     CONCAT('Temporary privilege request #', v_request_id, ' requires approval'), 
     NOW());
    
    SELECT v_request_id as request_id, v_approval_token as approval_token;
END$$

-- 权限审批流程
CREATE PROCEDURE APPROVE_TEMP_PRIVILEGE(
    IN p_request_id INT,
    IN p_approval_token VARCHAR(64),
    IN p_approver_action ENUM('APPROVE', 'DENY'),
    IN p_approver_comment TEXT
)
BEGIN
    DECLARE v_target_user, v_privilege, v_object VARCHAR(200);
    DECLARE v_duration_hours INT;
    DECLARE v_status VARCHAR(20);
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 验证审批令牌和请求状态
    SELECT target_user, privilege_type, object_name, requested_duration_hours, status
    INTO v_target_user, v_privilege, v_object, v_duration_hours, v_status
    FROM temp_permission_requests 
    WHERE id = p_request_id AND approval_token = p_approval_token;
    
    IF v_status != 'PENDING' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Request already processed';
    END IF;
    
    -- 更新请求状态
    UPDATE temp_permission_requests 
    SET status = p_approver_action,
        approver = USER(),
        approved_at = NOW(),
        expires_at = CASE 
            WHEN p_approver_action = 'APPROVE' THEN 
                DATE_ADD(NOW(), INTERVAL v_duration_hours HOUR)
            ELSE NULL
        END
    WHERE id = p_request_id;
    
    -- 如果批准，自动授予权限
    IF p_approver_action = 'APPROVE' THEN
        CALL SMART_GRANT_PRIVILEGE(v_target_user, v_privilege, v_object, TRUE, v_duration_hours);
    END IF;
    
    COMMIT;
    
    SELECT 'SUCCESS' as result, p_approver_action as action;
END$$

DELIMITER ;
```

### 9.3 权限热更新安全验证


**确保热更新过程的安全性**：

```sql
-- 权限变更安全检查存储过程
DELIMITER $$
CREATE PROCEDURE SECURE_PRIVILEGE_UPDATE(
    IN p_operation ENUM('GRANT', 'REVOKE'),
    IN p_user VARCHAR(100),
    IN p_privilege VARCHAR(50),
    IN p_object VARCHAR(200),
    IN p_force BOOLEAN DEFAULT FALSE
)
BEGIN
    DECLARE v_risk_level VARCHAR(20);
    DECLARE v_current_connection_count INT;
    DECLARE v_approval_required BOOLEAN DEFAULT FALSE;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        -- 记录安全事件
        INSERT INTO security_events 
        (event_type, severity, details, timestamp)
        VALUES 
        ('PRIVILEGE_UPDATE_FAILED', 'HIGH', 
         JSON_OBJECT('operation', p_operation, 'user', p_user, 'error', 'Exception occurred'),
         NOW());
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 1. 安全风险评估
    SELECT JSON_UNQUOTE(JSON_EXTRACT(
        ANALYZE_PRIVILEGE_IMPACT(p_user, p_privilege, p_object, p_operation),
        '$.risk_level'
    )) INTO v_risk_level;
    
    -- 2. 检查是否需要额外审批
    SET v_approval_required = (
        v_risk_level = 'HIGH' OR 
        p_privilege IN ('ALL PRIVILEGES', 'SUPER', 'FILE', 'PROCESS') OR
        p_object LIKE 'mysql.%'
    );
    
    -- 3. 获取当前活跃连接数
    SELECT COUNT(*) INTO v_current_connection_count
    FROM INFORMATION_SCHEMA.PROCESSLIST 
    WHERE USER = SUBSTRING_INDEX(p_user, '@', 1);
    
    -- 4. 安全检查
    IF v_approval_required AND NOT p_force THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 
            'High-risk privilege operation requires manual approval';
    END IF;
    
    IF v_current_connection_count > 10 AND p_operation = 'REVOKE' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 
            'Cannot revoke privileges: user has too many active connections';
    END IF;
    
    -- 5. 创建回滚点
    INSERT INTO privilege_rollback_log 
    (operation_id, user_privileges_before, timestamp)
    SELECT 
        UUID(),
        JSON_OBJECT(
            'user', p_user,
            'privileges', (
                SELECT JSON_ARRAYAGG(PRIVILEGE_TYPE)
                FROM INFORMATION_SCHEMA.USER_PRIVILEGES 
                WHERE GRANTEE = CONCAT("'", SUBSTRING_INDEX(p_user, '@', 1), "'@'", 
                                     SUBSTRING_INDEX(p_user, '@', -1), "'")
            )
        ),
        NOW();
    
    -- 6. 执行权限操作
    SET @sql = CONCAT(p_operation, ' ', p_privilege, ' ON ', p_object, 
                     CASE p_operation 
                         WHEN 'GRANT' THEN CONCAT(' TO ', p_user)
                         WHEN 'REVOKE' THEN CONCAT(' FROM ', p_user)
                     END);
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 7. 记录安全审计日志
    INSERT INTO security_audit_log 
    (operation, user_account, privilege_type, object_name, risk_level, 
     operator, timestamp, additional_info)
    VALUES 
    (p_operation, p_user, p_privilege, p_object, v_risk_level,
     USER(), NOW(), 
     JSON_OBJECT('active_connections', v_current_connection_count, 'forced', p_force));
    
    COMMIT;
    
    SELECT 'SUCCESS' as result, v_risk_level as risk_level;
END$$

DELIMITER ;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🎯 **动态权限核心特性**
• 实时生效：权限变更立即生效，无需重启
• 热更新：支持在线修改权限配置
• 插件化：通过插件扩展新的权限类型
• 临时性：支持有时间限制的临时权限
• 监控性：权限变更可以被实时监控和审计
```

### 10.2 关键理解要点


**🔹 动态权限的优势**
```
灵活性：
• 紧急情况快速响应
• 支持临时权限需求
• 便于权限策略调整

安全性：
• 实时监控权限变化
• 完整的审计日志
• 支持自动化安全检查

效率：
• 零中断权限调整
• 自动化权限管理
• 减少人工操作错误
```

**🔹 实施的注意事项**
```
安全考虑：
• 高风险操作需要审批
• 完善的日志记录
• 定期权限审查

性能影响：
• 权限检查开销
• 监控系统负载
• 日志存储空间

运维管理：
• 标准化操作流程
• 自动化脚本管理
• 应急处理预案
```

### 10.3 实际应用价值


**🎯 业务场景应用**
- **开发环境**：开发人员临时需要生产环境查询权限
- **运维管理**：紧急情况下快速调整权限策略
- **安全审计**：实时监控权限变化，发现异常行为
- **合规要求**：满足权限管理的合规性要求

**🔧 技术实现要点**
- **权限粒度**：支持表级、列级的精细权限控制
- **时间控制**：通过事件调度器实现临时权限
- **安全审计**：完整的权限变更日志和监控
- **插件扩展**：支持自定义权限类型和检查逻辑

### 10.4 最佳实践建议


```
📋 **权限管理最佳实践**

设计原则：
• 最小权限原则：只授予必要的权限
• 职责分离：不同角色拥有不同权限
• 定期审查：定期检查和清理权限

安全策略：
• 多层验证：重要操作需要多重确认
• 自动监控：设置权限异常告警
• 应急响应：建立权限安全事件处理流程

运维管理：
• 标准化流程：制定权限申请和审批流程
• 自动化工具：使用脚本简化常规操作
• 文档管理：维护完整的权限说明文档
```

**核心记忆**：
- 动态权限让数据库权限管理更加灵活高效
- 安全控制是动态权限系统的关键要素
- 临时权限解决了临时访问需求的安全问题
- 完善的监控和审计是权限安全的重要保障