---
title: 8、MySQL复杂表达式计算
---
## 📚 目录

1. [复杂表达式基础概念](#1-复杂表达式基础概念)
2. [复合表达式构建技巧](#2-复合表达式构建技巧)
3. [嵌套函数调用详解](#3-嵌套函数调用详解)
4. [运算符优先级与计算顺序](#4-运算符优先级与计算顺序)
5. [表达式性能优化策略](#5-表达式性能优化策略)
6. [表达式索引与缓存机制](#6-表达式索引与缓存机制)
7. [复杂表达式拆分优化](#7-复杂表达式拆分优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧮 复杂表达式基础概念


### 1.1 什么是复杂表达式


**🔸 表达式的本质理解**
```
简单表达式：基础运算
price * quantity  -- 单一计算

复杂表达式：多层嵌套计算
CASE 
  WHEN category = 'VIP' THEN 
    ROUND(price * quantity * 0.8 + IF(quantity > 10, 50, 0), 2)
  ELSE 
    ROUND(price * quantity * 0.9, 2)
END

核心特点：
• 多个函数嵌套调用
• 条件判断与计算结合
• 多步骤的数据处理
• 业务逻辑的SQL化表达
```

### 1.2 复杂表达式的应用场景


**💼 实际业务需求**
```
电商订单计算：
基础价格 + 折扣计算 + 税费 + 运费 - 优惠券

用户积分计算：
消费金额 × 积分倍率 + 等级加成 + 活动奖励

报表统计分析：
同比增长率 = (本期数据 - 同期数据) / 同期数据 × 100%

数据质量评估：
完整性得分 = (非空字段数 / 总字段数) × 权重系数
```

### 1.3 复杂表达式的构成要素


**🧩 表达式组成部分**
```
基础元素：
• 字段名：table.column
• 常量值：123, 'hello', TRUE
• 系统函数：NOW(), USER(), VERSION()

运算符：
• 算术运算：+, -, *, /, %, DIV, MOD
• 比较运算：=, <>, <, >, <=, >=, LIKE, IN
• 逻辑运算：AND, OR, NOT, XOR
• 位运算：&, |, ^, ~, <<, >>

控制函数：
• 条件判断：IF(), CASE WHEN
• 空值处理：IFNULL(), NULLIF(), COALESCE()
• 类型转换：CAST(), CONVERT()
```

---

## 2. 🔗 复合表达式构建技巧


### 2.1 逐步构建复杂表达式


**🎯 分层构建方法**
```sql
-- 第1层：基础计算
SELECT 
  order_id,
  price,
  quantity,
  price * quantity AS subtotal
FROM orders;

-- 第2层：添加折扣逻辑
SELECT 
  order_id,
  price * quantity AS subtotal,
  CASE 
    WHEN customer_level = 'VIP' THEN price * quantity * 0.8
    WHEN customer_level = 'GOLD' THEN price * quantity * 0.9
    ELSE price * quantity
  END AS discounted_total
FROM orders;

-- 第3层：添加复杂业务规则
SELECT 
  order_id,
  CASE 
    WHEN customer_level = 'VIP' THEN 
      ROUND(price * quantity * 0.8 + 
        IF(quantity > 10, 50, 0) +  -- 批量奖励
        IF(MONTH(order_date) = MONTH(birthday), 100, 0), 2)  -- 生日奖励
    WHEN customer_level = 'GOLD' THEN 
      ROUND(price * quantity * 0.9 + 
        IF(quantity > 5, 20, 0), 2)
    ELSE 
      ROUND(price * quantity + 
        IF(total_orders > 50, 30, 0), 2)  -- 忠诚客户奖励
  END AS final_amount
FROM orders;
```

### 2.2 条件表达式的高级应用


**⚡ CASE表达式的灵活运用**
```sql
-- 多条件组合判断
SELECT 
  product_id,
  product_name,
  CASE 
    -- 多个条件同时满足
    WHEN category = 'Electronics' AND price > 1000 THEN '高端电子产品'
    WHEN category = 'Electronics' AND price BETWEEN 300 AND 1000 THEN '中端电子产品'
    WHEN category = 'Electronics' THEN '入门电子产品'
    
    -- 时间相关判断
    WHEN category = 'Fashion' AND MONTH(created_date) IN (6,7,8) THEN '夏季服装'
    WHEN category = 'Fashion' AND MONTH(created_date) IN (12,1,2) THEN '冬季服装'
    
    -- 复杂计算判断
    WHEN (price / cost_price) > 2.5 THEN '高利润商品'
    WHEN (price / cost_price) BETWEEN 1.5 AND 2.5 THEN '中等利润商品'
    
    ELSE '其他商品'
  END AS product_classification,
  
  -- 基于分类的价格调整
  CASE 
    WHEN category = 'Electronics' THEN 
      price * (1 + 0.1 * FLOOR(DATEDIFF(NOW(), created_date) / 365))  -- 电子产品按年折旧
    WHEN category = 'Fashion' THEN 
      price * EXP(-0.05 * DATEDIFF(NOW(), created_date) / 30)  -- 服装按月贬值
    ELSE price
  END AS adjusted_price
FROM products;
```

### 2.3 字符串复合表达式


**📝 字符串处理的复杂应用**
```sql
-- 复杂字符串拼接和处理
SELECT 
  user_id,
  -- 生成用户显示名称
  CASE 
    WHEN nickname IS NOT NULL AND CHAR_LENGTH(nickname) > 0 THEN 
      CONCAT(
        UPPER(LEFT(nickname, 1)),  -- 首字母大写
        LOWER(SUBSTRING(nickname, 2))  -- 其余小写
      )
    ELSE 
      CONCAT(
        UPPER(LEFT(first_name, 1)),
        LOWER(SUBSTRING(first_name, 2)),
        ' ',
        UPPER(LEFT(last_name, 1)),
        '.'
      )
  END AS display_name,
  
  -- 生成用户编码
  CONCAT(
    DATE_FORMAT(created_date, '%Y%m'),  -- 年月
    LPAD(user_id, 6, '0'),  -- 用户ID补零到6位
    CASE region
      WHEN 'North' THEN 'N'
      WHEN 'South' THEN 'S'
      WHEN 'East' THEN 'E'
      WHEN 'West' THEN 'W'
      ELSE 'O'
    END,
    IF(is_premium = 1, 'P', 'R')  -- P=付费用户, R=普通用户
  ) AS user_code,
  
  -- 脱敏手机号
  CASE 
    WHEN CHAR_LENGTH(phone) = 11 THEN 
      CONCAT(
        LEFT(phone, 3),
        '****',
        RIGHT(phone, 4)
      )
    ELSE '手机号格式错误'
  END AS masked_phone
FROM users;
```

### 2.4 日期时间复合计算


**📅 复杂日期时间处理**
```sql
-- 复杂的日期时间计算
SELECT 
  employee_id,
  hire_date,
  birth_date,
  
  -- 工作年限计算
  CASE 
    WHEN DATEDIFF(NOW(), hire_date) >= 365 THEN 
      CONCAT(
        FLOOR(DATEDIFF(NOW(), hire_date) / 365), '年',
        FLOOR((DATEDIFF(NOW(), hire_date) % 365) / 30), '个月'
      )
    ELSE 
      CONCAT(FLOOR(DATEDIFF(NOW(), hire_date) / 30), '个月')
  END AS work_experience,
  
  -- 年龄段分类
  CASE 
    WHEN TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) < 25 THEN '青年'
    WHEN TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) BETWEEN 25 AND 35 THEN '壮年'
    WHEN TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) BETWEEN 36 AND 50 THEN '中年'
    ELSE '资深'
  END AS age_group,
  
  -- 下次生日倒计时
  CASE 
    WHEN DAYOFYEAR(DATE_ADD(birth_date, INTERVAL YEAR(NOW()) - YEAR(birth_date) YEAR)) >= DAYOFYEAR(NOW()) THEN
      DATEDIFF(
        DATE_ADD(birth_date, INTERVAL YEAR(NOW()) - YEAR(birth_date) YEAR),
        NOW()
      )
    ELSE 
      DATEDIFF(
        DATE_ADD(birth_date, INTERVAL YEAR(NOW()) - YEAR(birth_date) + 1 YEAR),
        NOW()
      )
  END AS days_to_birthday,
  
  -- 节假日加班费计算
  salary * 
  CASE DAYOFWEEK(NOW())
    WHEN 1 THEN 2.0  -- 周日
    WHEN 7 THEN 2.0  -- 周六
    ELSE 
      CASE 
        WHEN DATE(NOW()) IN ('2025-01-01', '2025-10-01', '2025-05-01') THEN 3.0  -- 法定节假日
        ELSE 1.5  -- 正常加班
      END
  END AS overtime_rate
FROM employees;
```

---

## 3. 🔄 嵌套函数调用详解


### 3.1 函数嵌套的基本原理


**🎯 嵌套执行顺序**
```
函数嵌套的执行原则：从内到外，从右到左

示例分析：
ROUND(ABS(price - AVG(price)), 2)

执行顺序：
1. AVG(price)          -- 计算平均价格
2. price - AVG(price)  -- 计算差值
3. ABS(...)            -- 取绝对值
4. ROUND(..., 2)       -- 保留2位小数

嵌套深度建议：一般不超过4层，避免过度复杂
```

### 3.2 数值函数嵌套应用


**🔢 常见数值函数组合**
```sql
-- 复杂数值处理示例
SELECT 
  product_id,
  original_price,
  
  -- 智能定价策略
  CASE 
    WHEN category = 'luxury' THEN 
      CEIL(                           -- 向上取整
        ROUND(                        -- 四舍五入到2位
          original_price * 
          (1 + RAND() * 0.1)         -- 随机浮动10%
        , 2) / 10                     -- 除以10
      ) * 10                          -- 乘以10，确保尾数为0
    ELSE 
      FLOOR(                          -- 向下取整
        original_price * 
        EXP(                          -- 指数函数
          -0.01 * DATEDIFF(NOW(), created_date) / 30  -- 按月衰减
        ) / 5                         -- 除以5
      ) * 5                           -- 乘以5，价格尾数为0或5
  END AS smart_price,
  
  -- 库存预警计算
  GREATEST(                           -- 取最大值
    LEAST(                            -- 取最小值
      ROUND(
        stock_quantity * 
        POW(                          -- 幂函数
          1.1, 
          MONTH(NOW()) - MONTH(created_date)  -- 按月增长
        ), 0
      ),
      9999                            -- 最大库存限制
    ),
    safety_stock                      -- 安全库存下限
  ) AS recommended_stock
FROM products;
```

### 3.3 字符串函数嵌套技巧


**📝 字符串处理的深度嵌套**
```sql
-- 复杂字符串处理示例
SELECT 
  customer_id,
  email,
  phone,
  
  -- 生成客户唯一标识码
  UPPER(                              -- 转大写
    CONCAT(                           -- 拼接字符串
      LEFT(                           -- 取左边字符
        MD5(                          -- MD5加密
          CONCAT(email, phone, created_date)
        ), 8                          -- 取前8位
      ),
      YEAR(created_date),             -- 注册年份
      LPAD(                           -- 左补零
        customer_id, 4, '0'
      )
    )
  ) AS customer_code,
  
  -- 智能用户名建议
  CASE 
    WHEN LOCATE('@', email) > 0 THEN 
      CONCAT(
        UPPER(                        -- 首字母大写
          LEFT(
            SUBSTRING_INDEX(email, '@', 1),  -- 邮箱@前部分
            1
          )
        ),
        LOWER(                        -- 其余小写
          SUBSTRING(
            SUBSTRING_INDEX(email, '@', 1),
            2,
            CHAR_LENGTH(SUBSTRING_INDEX(email, '@', 1)) - 1
          )
        ),
        YEAR(NOW()) - YEAR(birth_date) -- 添加年龄
      )
    ELSE 
      CONCAT(
        'User',
        LPAD(customer_id, 6, '0')
      )
  END AS suggested_username,
  
  -- 敏感信息脱敏处理
  CASE 
    WHEN CHAR_LENGTH(TRIM(phone)) = 11 THEN 
      CONCAT(
        LEFT(TRIM(phone), 3),         -- 前3位
        REPEAT('*', 4),               -- 中间4个*
        RIGHT(TRIM(phone), 4)         -- 后4位
      )
    WHEN CHAR_LENGTH(TRIM(phone)) > 0 THEN 
      CONCAT(
        LEFT(TRIM(phone), 2),
        REPEAT('*', CHAR_LENGTH(TRIM(phone)) - 4),
        RIGHT(TRIM(phone), 2)
      )
    ELSE '未提供'
  END AS masked_phone
FROM customers;
```

### 3.4 日期时间函数嵌套


**📅 复杂时间计算组合**
```sql
-- 业务时间相关的复杂计算
SELECT 
  order_id,
  order_date,
  delivery_date,
  
  -- 配送效率评级
  CASE 
    WHEN delivery_date IS NULL THEN '未配送'
    WHEN DATEDIFF(delivery_date, order_date) <= 1 THEN '极速'
    WHEN DATEDIFF(delivery_date, order_date) <= 3 THEN '快速'
    WHEN DATEDIFF(delivery_date, order_date) <= 7 THEN '正常'
    ELSE '延迟'
  END AS delivery_rating,
  
  -- 订单时效性分析
  CASE 
    WHEN TIMESTAMPDIFF(HOUR, order_date, NOW()) < 24 THEN 
      CONCAT(TIMESTAMPDIFF(HOUR, order_date, NOW()), '小时前')
    WHEN TIMESTAMPDIFF(DAY, order_date, NOW()) < 30 THEN 
      CONCAT(TIMESTAMPDIFF(DAY, order_date, NOW()), '天前')
    WHEN TIMESTAMPDIFF(MONTH, order_date, NOW()) < 12 THEN 
      CONCAT(TIMESTAMPDIFF(MONTH, order_date, NOW()), '个月前')
    ELSE 
      CONCAT(TIMESTAMPDIFF(YEAR, order_date, NOW()), '年前')
  END AS order_age,
  
  -- 工作日配送时间预估
  CASE DAYOFWEEK(order_date)
    WHEN 1 THEN DATE_ADD(order_date, INTERVAL 2 DAY)  -- 周日+2天
    WHEN 7 THEN DATE_ADD(order_date, INTERVAL 3 DAY)  -- 周六+3天
    ELSE 
      DATE_ADD(
        order_date, 
        INTERVAL (
          CASE 
            WHEN HOUR(order_date) < 12 THEN 1  -- 上午下单次日送达
            ELSE 2                             -- 下午下单后天送达
          END
        ) DAY
      )
  END AS estimated_delivery,
  
  -- 季度业绩周期
  CONCAT(
    YEAR(order_date), 'Q',
    QUARTER(order_date)
  ) AS fiscal_quarter
FROM orders;
```

---

## 4. ⚖️ 运算符优先级与计算顺序


### 4.1 MySQL运算符优先级表


**📊 优先级从高到低排列**

| 优先级 | **运算符** | **说明** | **示例** |
|-------|-----------|---------|---------|
| `1` | `()` | `括号` | `(a + b) * c` |
| `2` | `!` | `逻辑非` | `!flag` |
| `3` | `-`, `+` | `一元正负号` | `-value`, `+value` |
| `4` | `^` | `异或` | `a ^ b` |
| `5` | `*`, `/`, `%`, `DIV`, `MOD` | `乘除取模` | `a * b / c` |
| `6` | `+`, `-` | `加减` | `a + b - c` |
| `7` | `<<`, `>>` | `位移` | `value << 2` |
| `8` | `&` | `位与` | `a & b` |
| `9` | `\|` | `位或` | `a \| b` |
| `10` | `=`, `<>`, `<=`, `<`, `>=`, `>` | `比较运算` | `a = b`, `a > b` |
| `11` | `LIKE`, `IN`, `BETWEEN` | `模式匹配` | `name LIKE 'A%'` |
| `12` | `NOT` | `逻辑非` | `NOT EXISTS` |
| `13` | `AND`, `&&` | `逻辑与` | `a AND b` |
| `14` | `OR`, `\|\|` | `逻辑或` | `a OR b` |

### 4.2 优先级陷阱与解决方案


**⚠️ 常见优先级误区**
```sql
-- 误区1：逻辑运算优先级
-- 错误理解
WHERE status = 'active' OR status = 'pending' AND priority = 'high'
-- 实际执行：status = 'active' OR (status = 'pending' AND priority = 'high')
-- 可能不是想要的结果

-- 正确写法
WHERE (status = 'active' OR status = 'pending') AND priority = 'high'

-- 误区2：算术与比较混合
-- 错误理解
WHERE price + tax > 100 = TRUE
-- 实际执行：price + tax > (100 = TRUE)，语法错误

-- 正确写法
WHERE (price + tax) > 100

-- 误区3：字符串拼接与比较
-- 错误理解
WHERE CONCAT(first_name, last_name) = 'John' + 'Doe'
-- 实际执行：CONCAT(first_name, last_name) = ('John' + 'Doe')

-- 正确写法
WHERE CONCAT(first_name, last_name) = CONCAT('John', 'Doe')
```

### 4.3 复杂表达式的括号使用策略


**🔧 括号的最佳实践**
```sql
-- 复杂表达式的清晰写法
SELECT 
  order_id,
  
  -- 方式1：不用括号（容易出错）
  customer_level = 'VIP' AND total_amount > 1000 OR payment_method = 'credit' AND status = 'paid'
  
  -- 方式2：使用括号明确优先级（推荐）
  (customer_level = 'VIP' AND total_amount > 1000) OR 
  (payment_method = 'credit' AND status = 'paid') AS is_preferred_order,
  
  -- 复杂数学计算的括号使用
  ROUND(
    (
      (price * quantity * discount_rate) +          -- 商品总价
      (shipping_fee * (1 + tax_rate)) +             -- 含税运费
      IF(is_urgent = 1, urgent_fee, 0)              -- 加急费
    ) * 
    (1 - coupon_discount_rate),                     -- 优惠券折扣
    2
  ) AS final_amount
FROM orders;
```

---

## 5. 🚀 表达式性能优化策略


### 5.1 表达式性能影响因素


**⚡ 性能影响分析**
```
影响性能的因素：

计算复杂度：
• 函数嵌套层数：每增加一层嵌套，计算开销增加
• 数据类型转换：CAST/CONVERT操作消耗较大
• 正则表达式：REGEXP操作性能开销最大

数据访问模式：
• 全表扫描：表达式用于WHERE条件时
• 索引失效：复杂表达式可能导致索引不可用
• 重复计算：相同表达式在同一查询中多次计算

函数选择：
• 内置函数 > 自定义函数
• 简单函数 > 复杂函数
• 确定性函数 > 非确定性函数
```

### 5.2 查询执行计划分析


**📊 使用EXPLAIN分析表达式性能**
```sql
-- 性能测试案例
EXPLAIN FORMAT=JSON
SELECT 
  customer_id,
  order_date,
  
  -- 复杂表达式1：会导致全表扫描
  CASE 
    WHEN MONTH(order_date) = MONTH(NOW()) THEN 
      total_amount * 1.1
    ELSE total_amount
  END AS adjusted_amount
  
FROM orders 
WHERE YEAR(order_date) = 2025;  -- 函数用于WHERE，索引失效

-- 优化后的查询
EXPLAIN FORMAT=JSON
SELECT 
  customer_id,
  order_date,
  
  -- 表达式移到SELECT，WHERE使用索引范围
  CASE 
    WHEN MONTH(order_date) = MONTH(NOW()) THEN 
      total_amount * 1.1
    ELSE total_amount
  END AS adjusted_amount
  
FROM orders 
WHERE order_date >= '2025-01-01'   -- 直接范围查询，可使用索引
  AND order_date < '2026-01-01';
```

**🔍 执行计划关键指标**
```json
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "1250.25",      // 查询总成本
      "eval_cost": "100.00",        // 表达式计算成本
      "prefix_cost": "1250.25",
      "data_read_per_join": "10.9KB"
    },
    "table": {
      "table_name": "orders",
      "access_type": "range",         // 访问类型：range(好) vs ALL(差)
      "possible_keys": ["idx_order_date"],
      "key": "idx_order_date",        // 使用的索引
      "rows_examined_per_scan": 1250, // 扫描行数
      "filtered": 100.00              // 过滤百分比
    }
  }
}

性能判断标准：
• access_type = "const" 最优
• access_type = "range" 较好  
• access_type = "ALL" 需要优化
• rows_examined_per_scan 越小越好
• query_cost 是总体性能指标
```

### 5.3 表达式优化技巧


**⚡ 计算前置优化**
```sql
-- 优化前：重复计算
SELECT 
  order_id,
  YEAR(order_date) AS order_year,
  MONTH(order_date) AS order_month,
  DAY(order_date) AS order_day,
  DAYOFWEEK(order_date) AS day_of_week,
  
  -- 相同的日期计算重复多次
  CASE YEAR(order_date)
    WHEN 2025 THEN 'Current Year'
    ELSE 'Previous Year'
  END AS year_category,
  
  CASE MONTH(order_date)
    WHEN 12 THEN 'December'
    WHEN 1 THEN 'January'
    ELSE 'Other Month'
  END AS month_category
FROM orders;

-- 优化后：使用子查询预计算
SELECT 
  order_id,
  order_year,
  order_month,
  order_day,
  day_of_week,
  
  CASE order_year
    WHEN 2025 THEN 'Current Year'
    ELSE 'Previous Year'
  END AS year_category,
  
  CASE order_month
    WHEN 12 THEN 'December'
    WHEN 1 THEN 'January'
    ELSE 'Other Month'
  END AS month_category
FROM (
  SELECT 
    order_id,
    order_date,
    YEAR(order_date) AS order_year,    -- 日期函数只计算一次
    MONTH(order_date) AS order_month,
    DAY(order_date) AS order_day,
    DAYOFWEEK(order_date) AS day_of_week
  FROM orders
) AS order_with_dates;
```

### 5.4 条件表达式优化


**🎯 WHERE条件表达式优化**
```sql
-- 优化前：复杂表达式在WHERE中
SELECT * FROM orders 
WHERE 
  ROUND(price * quantity * (1 - discount_rate), 2) > 1000
  AND DATEDIFF(NOW(), order_date) < 30
  AND UPPER(status) IN ('PAID', 'SHIPPED');

-- 优化后：简化WHERE条件
SELECT * FROM orders 
WHERE 
  price * quantity > 1200  -- 预估值，避免复杂计算
  AND order_date > DATE_SUB(NOW(), INTERVAL 30 DAY)  -- 直接日期比较
  AND status IN ('paid', 'shipped', 'PAID', 'SHIPPED')  -- 包含可能的大小写
HAVING 
  ROUND(price * quantity * (1 - discount_rate), 2) > 1000;  -- 精确计算移到HAVING
```

---

## 6. 🗃️ 表达式索引与缓存机制


### 6.1 表达式索引的应用


**🔍 什么时候需要表达式索引**
```
表达式索引的适用场景：
• 经常在WHERE条件中使用函数表达式
• 需要对计算结果进行排序
• 复杂表达式查询频繁且性能要求高

MySQL表达式索引：
MySQL 8.0开始支持函数索引（表达式索引）
可以为函数或表达式的结果创建索引
```

**🔧 表达式索引创建示例**
```sql
-- 示例表结构
CREATE TABLE customers (
  id INT PRIMARY KEY,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  email VARCHAR(100),
  phone VARCHAR(20),
  birth_date DATE,
  created_date DATETIME,
  total_spent DECIMAL(10,2)
);

-- 创建表达式索引
-- 1. 全名搜索索引
CREATE INDEX idx_full_name ON customers (
  (CONCAT(first_name, ' ', last_name))
);

-- 2. 年龄范围索引
CREATE INDEX idx_age ON customers (
  (TIMESTAMPDIFF(YEAR, birth_date, CURDATE()))
);

-- 3. 邮箱域名索引
CREATE INDEX idx_email_domain ON customers (
  (SUBSTRING_INDEX(email, '@', -1))
);

-- 4. 月消费能力索引
CREATE INDEX idx_monthly_spending ON customers (
  (total_spent / TIMESTAMPDIFF(MONTH, created_date, NOW()))
);

-- 使用表达式索引的查询
-- 查询1：可以使用idx_full_name索引
SELECT * FROM customers 
WHERE CONCAT(first_name, ' ', last_name) = 'John Smith';

-- 查询2：可以使用idx_age索引
SELECT * FROM customers 
WHERE TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) BETWEEN 25 AND 35;

-- 查询3：可以使用idx_email_domain索引
SELECT * FROM customers 
WHERE SUBSTRING_INDEX(email, '@', -1) = 'gmail.com';
```

### 6.2 虚拟列与预计算优化


**💾 使用虚拟列存储计算结果**
```sql
-- 创建带虚拟列的表
CREATE TABLE orders_optimized (
  id INT PRIMARY KEY,
  customer_id INT,
  price DECIMAL(10,2),
  quantity INT,
  discount_rate DECIMAL(3,2),
  tax_rate DECIMAL(3,2),
  order_date DATETIME,
  
  -- 虚拟列：实时计算，不占存储空间
  subtotal DECIMAL(10,2) AS (price * quantity) VIRTUAL,
  discount_amount DECIMAL(10,2) AS (price * quantity * discount_rate) VIRTUAL,
  tax_amount DECIMAL(10,2) AS (price * quantity * tax_rate) VIRTUAL,
  
  -- 存储列：预计算，占用存储空间但查询更快
  final_amount DECIMAL(10,2) AS (
    ROUND(
      price * quantity * (1 - discount_rate) * (1 + tax_rate), 
      2
    )
  ) STORED,
  
  -- 日期相关虚拟列
  order_year INT AS (YEAR(order_date)) VIRTUAL,
  order_month INT AS (MONTH(order_date)) VIRTUAL,
  order_quarter INT AS (QUARTER(order_date)) VIRTUAL,
  
  -- 为虚拟列创建索引
  INDEX idx_final_amount (final_amount),
  INDEX idx_order_year_month (order_year, order_month),
  INDEX idx_subtotal (subtotal)
);

-- 高效查询示例
-- 查询1：直接使用预计算的final_amount
SELECT * FROM orders_optimized 
WHERE final_amount > 1000  -- 使用索引，性能高
ORDER BY final_amount DESC;

-- 查询2：使用虚拟列索引
SELECT * FROM orders_optimized 
WHERE order_year = 2025 AND order_month IN (10, 11, 12);  -- 使用组合索引
```

### 6.3 计算结果缓存机制


**🗂️ 查询缓存策略**
```sql
-- MySQL查询缓存配置（MySQL 5.7及之前）
SET GLOBAL query_cache_type = ON;
SET GLOBAL query_cache_size = 67108864;  -- 64MB

-- 查询缓存状态检查
SHOW STATUS LIKE 'Qcache%';

-- 查询缓存友好的表达式写法
-- 缓存友好：使用常量
SELECT 
  product_id,
  price * 1.1 AS price_with_tax  -- 常量表达式，可缓存
FROM products 
WHERE category = 'Electronics';

-- 缓存不友好：使用非确定性函数
SELECT 
  product_id,
  price * (1 + RAND() * 0.1) AS random_price  -- RAND()每次不同，无法缓存
FROM products;
```

**📊 应用层缓存机制**
```sql
-- 复杂计算结果的物化表策略
-- 1. 创建计算结果缓存表
CREATE TABLE customer_statistics_cache (
  customer_id INT PRIMARY KEY,
  total_orders INT,
  total_spent DECIMAL(12,2),
  avg_order_value DECIMAL(10,2),
  last_order_date DATE,
  customer_lifetime_value DECIMAL(12,2),
  
  -- 复杂计算结果
  customer_score DECIMAL(5,2) AS (
    (total_orders * 0.3 + 
     total_spent / 100 * 0.4 + 
     DATEDIFF(NOW(), last_order_date) / -10 * 0.3)
  ) STORED,
  
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_customer_score (customer_score),
  INDEX idx_updated_at (updated_at)
);

-- 2. 定期更新缓存表的存储过程
DELIMITER //
CREATE PROCEDURE UpdateCustomerStatistics()
BEGIN
  -- 删除过期缓存
  DELETE FROM customer_statistics_cache 
  WHERE updated_at < DATE_SUB(NOW(), INTERVAL 1 DAY);
  
  -- 重新计算客户统计
  INSERT INTO customer_statistics_cache (
    customer_id, total_orders, total_spent, 
    avg_order_value, last_order_date, customer_lifetime_value
  )
  SELECT 
    customer_id,
    COUNT(*) AS total_orders,
    SUM(final_amount) AS total_spent,
    AVG(final_amount) AS avg_order_value,
    MAX(order_date) AS last_order_date,
    
    -- 复杂的客户生命周期价值计算
    SUM(final_amount) * 
    EXP(
      -0.1 * DATEDIFF(NOW(), MAX(order_date)) / 30  -- 时间衰减因子
    ) * 
    (1 + COUNT(*) * 0.05)  -- 订单频次加成
    AS customer_lifetime_value
    
  FROM orders 
  WHERE order_date >= DATE_SUB(NOW(), INTERVAL 2 YEAR)
  GROUP BY customer_id
  ON DUPLICATE KEY UPDATE
    total_orders = VALUES(total_orders),
    total_spent = VALUES(total_spent),
    avg_order_value = VALUES(avg_order_value),
    last_order_date = VALUES(last_order_date),
    customer_lifetime_value = VALUES(customer_lifetime_value);
END //
DELIMITER ;

-- 3. 使用缓存表进行高效查询
SELECT 
  customer_id,
  customer_score,
  CASE 
    WHEN customer_score >= 90 THEN 'VIP'
    WHEN customer_score >= 70 THEN 'Gold'
    WHEN customer_score >= 50 THEN 'Silver'
    ELSE 'Bronze'
  END AS customer_level
FROM customer_statistics_cache
WHERE customer_score > 60
ORDER BY customer_score DESC;
```

### 6.4 表达式重写优化


**🔧 常见优化重写模式**
```sql
-- 优化模式1：提取公共子表达式
-- 优化前
SELECT 
  order_id,
  ROUND(price * quantity * (1 - discount_rate), 2) AS discounted_total,
  ROUND(price * quantity * (1 - discount_rate) * 1.1, 2) AS total_with_tax,
  ROUND(price * quantity * (1 - discount_rate) * 1.1 + shipping_fee, 2) AS grand_total
FROM orders;

-- 优化后：使用子查询提取公共计算
SELECT 
  order_id,
  discounted_total,
  ROUND(discounted_total * 1.1, 2) AS total_with_tax,
  ROUND(discounted_total * 1.1 + shipping_fee, 2) AS grand_total
FROM (
  SELECT 
    order_id,
    shipping_fee,
    ROUND(price * quantity * (1 - discount_rate), 2) AS discounted_total
  FROM orders
) AS order_calculations;

-- 优化模式2：避免重复的类型转换
-- 优化前
SELECT 
  CAST(price AS CHAR) AS price_str,
  CAST(price * 1.1 AS CHAR) AS price_with_tax_str,
  CAST(price * quantity AS CHAR) AS total_str
FROM products;

-- 优化后：减少类型转换次数
SELECT 
  CAST(price AS CHAR) AS price_str,
  CAST(price_with_tax AS CHAR) AS price_with_tax_str,
  CAST(total AS CHAR) AS total_str
FROM (
  SELECT 
    price,
    price * 1.1 AS price_with_tax,
    price * quantity AS total
  FROM products
) AS calculated_values;
```

---

## 7. 🧩 复杂表达式拆分优化


### 7.1 表达式拆分的基本原则


**🎯 拆分优化策略**
```
拆分的核心目标：
• 降低单个表达式的复杂度
• 提高代码可读性和维护性
• 减少重复计算，提升性能
• 便于调试和故障定位

拆分原则：
• 按业务逻辑分层
• 公共计算提取
• 复杂条件简化
• 函数嵌套展开
```

### 7.2 实际拆分案例演示


**📊 电商订单复杂计算拆分**
```sql
-- 原始复杂表达式（不推荐）
SELECT 
  order_id,
  customer_id,
  
  -- 超级复杂的一个表达式
  ROUND(
    CASE 
      WHEN customer_level = 'VIP' THEN 
        (price * quantity * 0.8 + 
         IF(quantity > 10, 50, 0) + 
         IF(MONTH(order_date) = MONTH(birthday), 100, 0)) * 
        (1 + tax_rate) + 
        CASE region 
          WHEN 'urban' THEN 15 
          WHEN 'suburban' THEN 25 
          ELSE 35 
        END
      WHEN customer_level = 'GOLD' THEN 
        (price * quantity * 0.9 + 
         IF(quantity > 5, 20, 0)) * 
        (1 + tax_rate) + 
        CASE region 
          WHEN 'urban' THEN 15 
          WHEN 'suburban' THEN 25 
          ELSE 35 
        END
      ELSE 
        price * quantity * (1 + tax_rate) + 
        CASE region 
          WHEN 'urban' THEN 15 
          WHEN 'suburban' THEN 25 
          ELSE 35 
        END
    END, 2
  ) AS final_total
FROM order_details;

-- 拆分优化后（推荐）
SELECT 
  order_id,
  customer_id,
  base_amount,
  discount_amount,
  bonus_amount,
  tax_amount,
  shipping_fee,
  ROUND(base_amount - discount_amount + bonus_amount + tax_amount + shipping_fee, 2) AS final_total
FROM (
  SELECT 
    order_id,
    customer_id,
    customer_level,
    region,
    -- 第3层：基础金额计算
    price * quantity AS base_amount,
    
    -- 第3层：折扣计算
    CASE customer_level
      WHEN 'VIP' THEN price * quantity * 0.2   -- VIP折扣20%
      WHEN 'GOLD' THEN price * quantity * 0.1  -- GOLD折扣10%
      ELSE 0
    END AS discount_amount,
    
    -- 第3层：奖励计算
    CASE customer_level
      WHEN 'VIP' THEN 
        IF(quantity > 10, 50, 0) + 
        IF(MONTH(order_date) = MONTH(birthday), 100, 0)
      WHEN 'GOLD' THEN 
        IF(quantity > 5, 20, 0)
      ELSE 
        IF(total_orders > 50, 30, 0)
    END AS bonus_amount,
    
    -- 第3层：税费计算
    price * quantity * tax_rate AS tax_amount,
    
    -- 第3层：运费计算
    CASE region 
      WHEN 'urban' THEN 15 
      WHEN 'suburban' THEN 25 
      ELSE 35 
    END AS shipping_fee
    
  FROM (
    SELECT 
      od.*,
      c.customer_level,
      c.birthday,
      c.region,
      c.total_orders,
      0.1 AS tax_rate  -- 税率配置
    FROM order_details od
    JOIN customers c ON od.customer_id = c.id
  ) AS order_with_customer
) AS order_calculations;
```

### 7.3 使用CTE简化复杂表达式


**🔄 公用表表达式（CTE）的应用**
```sql
-- 使用WITH子句逐步构建复杂查询
WITH 
-- 第1步：基础数据准备
base_data AS (
  SELECT 
    o.order_id,
    o.customer_id,
    o.price,
    o.quantity,
    o.order_date,
    c.customer_level,
    c.birthday,
    c.region,
    c.total_orders,
    p.category,
    p.is_seasonal
  FROM orders o
  JOIN customers c ON o.customer_id = c.id
  JOIN products p ON o.product_id = p.id
),

-- 第2步：基础计算
basic_calculations AS (
  SELECT 
    *,
    price * quantity AS subtotal,
    TIMESTAMPDIFF(YEAR, birthday, CURDATE()) AS customer_age,
    DATEDIFF(CURDATE(), order_date) AS days_since_order,
    MONTH(order_date) = MONTH(birthday) AS is_birthday_month
  FROM base_data
),

-- 第3步：折扣和奖励计算
discount_calculations AS (
  SELECT 
    *,
    -- 客户等级折扣
    CASE customer_level
      WHEN 'VIP' THEN subtotal * 0.2
      WHEN 'GOLD' THEN subtotal * 0.1
      ELSE 0
    END AS level_discount,
    
    -- 数量奖励
    CASE 
      WHEN customer_level = 'VIP' AND quantity > 10 THEN 50
      WHEN customer_level = 'GOLD' AND quantity > 5 THEN 20
      WHEN total_orders > 50 THEN 30
      ELSE 0
    END AS quantity_bonus,
    
    -- 生日奖励
    IF(is_birthday_month = 1, 100, 0) AS birthday_bonus,
    
    -- 季节性商品折扣
    IF(is_seasonal = 1 AND MONTH(order_date) IN (6,7,8), subtotal * 0.05, 0) AS seasonal_discount
    
  FROM basic_calculations
),

-- 第4步：最终计算
final_calculations AS (
  SELECT 
    *,
    subtotal - level_discount - seasonal_discount AS discounted_subtotal,
    quantity_bonus + birthday_bonus AS total_bonus,
    
    -- 运费计算
    CASE region 
      WHEN 'urban' THEN 15 
      WHEN 'suburban' THEN 25 
      ELSE 35 
    END AS shipping_fee,
    
    -- 税费计算
    (subtotal - level_discount - seasonal_discount) * 0.1 AS tax_amount
  FROM discount_calculations
)

-- 第5步：最终结果
SELECT 
  order_id,
  customer_id,
  customer_level,
  subtotal,
  level_discount,
  seasonal_discount,
  total_bonus,
  shipping_fee,
  tax_amount,
  
  -- 最终金额计算
  ROUND(
    discounted_subtotal + total_bonus + shipping_fee + tax_amount, 
    2
  ) AS final_amount,
  
  -- 优惠百分比
  ROUND(
    (level_discount + seasonal_discount) / subtotal * 100, 
    1
  ) AS discount_percentage
  
FROM final_calculations
WHERE days_since_order <= 30  -- 只看最近30天的订单
ORDER BY final_amount DESC;
```

### 7.4 存储过程封装复杂表达式


**⚙️ 将复杂逻辑封装为函数**
```sql
-- 创建复杂计算的存储函数
DELIMITER //

-- 客户折扣计算函数
CREATE FUNCTION CalculateCustomerDiscount(
  p_customer_level VARCHAR(20),
  p_subtotal DECIMAL(10,2),
  p_quantity INT,
  p_total_orders INT
) 
RETURNS DECIMAL(10,2)
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE discount_amount DECIMAL(10,2) DEFAULT 0;
  
  -- 等级基础折扣
  CASE p_customer_level
    WHEN 'VIP' THEN SET discount_amount = p_subtotal * 0.2;
    WHEN 'GOLD' THEN SET discount_amount = p_subtotal * 0.1;
    ELSE SET discount_amount = 0;
  END CASE;
  
  -- 数量奖励
  IF p_customer_level = 'VIP' AND p_quantity > 10 THEN
    SET discount_amount = discount_amount + 50;
  ELSEIF p_customer_level = 'GOLD' AND p_quantity > 5 THEN
    SET discount_amount = discount_amount + 20;
  ELSEIF p_total_orders > 50 THEN
    SET discount_amount = discount_amount + 30;
  END IF;
  
  RETURN discount_amount;
END //

-- 运费计算函数
CREATE FUNCTION CalculateShippingFee(
  p_region VARCHAR(50),
  p_weight DECIMAL(5,2),
  p_is_express BOOLEAN
) 
RETURNS DECIMAL(8,2)
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE base_fee DECIMAL(8,2);
  DECLARE weight_fee DECIMAL(8,2);
  DECLARE express_fee DECIMAL(8,2) DEFAULT 0;
  
  -- 区域基础运费
  CASE p_region
    WHEN 'urban' THEN SET base_fee = 15;
    WHEN 'suburban' THEN SET base_fee = 25;
    ELSE SET base_fee = 35;
  END CASE;
  
  -- 重量附加费
  SET weight_fee = GREATEST(0, (p_weight - 1) * 5);  -- 超过1kg每公斤5元
  
  -- 加急费
  IF p_is_express = TRUE THEN
    SET express_fee = base_fee * 0.5;
  END IF;
  
  RETURN base_fee + weight_fee + express_fee;
END //

DELIMITER ;

-- 使用存储函数简化主查询
SELECT 
  order_id,
  customer_id,
  price * quantity AS subtotal,
  
  -- 使用函数替代复杂表达式
  CalculateCustomerDiscount(
    customer_level, 
    price * quantity, 
    quantity, 
    total_orders
  ) AS discount_amount,
  
  CalculateShippingFee(region, weight, is_express) AS shipping_fee,
  
  -- 最终计算变得简洁
  ROUND(
    price * quantity - 
    CalculateCustomerDiscount(customer_level, price * quantity, quantity, total_orders) +
    CalculateShippingFee(region, weight, is_express) +
    price * quantity * 0.1,  -- 税费
    2
  ) AS final_amount
  
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 复杂表达式的本质理解**
```
表达式 = 数据处理的业务逻辑
• 不是简单的数学运算，而是业务规则的实现
• 通过SQL表达复杂的计算需求
• 在数据库层面完成数据处理，减少应用层计算
• 实现数据的实时计算和分析
```

**🔸 表达式构建的核心技巧**
```
逐层构建：
简单计算 → 条件判断 → 复合逻辑 → 最终结果

函数嵌套：
从内到外执行，注意执行顺序和优先级

性能考虑：
计算复杂度 vs 查询性能的平衡
```

### 8.2 关键优化策略


**🔹 性能优化的核心思路**
```
减少重复计算：
• 公共子表达式提取
• 使用子查询或CTE预计算
• 虚拟列存储常用计算结果

索引优化：
• 为常用表达式创建函数索引
• 避免在WHERE条件中使用复杂函数
• 使用范围查询替代函数计算

缓存机制：
• 物化表存储复杂计算结果
• 定期更新缓存数据
• 权衡实时性与性能
```

**🔹 表达式拆分的实践方法**
```
CTE方式：
WITH子句逐步构建，逻辑清晰

存储函数：
封装复杂逻辑，提高复用性

虚拟列：
预计算常用表达式，提升查询速度

分层查询：
子查询分层处理，降低复杂度
```

### 8.3 运算符优先级的实践要点


**🔹 避免优先级陷阱**
```
关键记忆：
• 括号优先级最高，有疑问就加括号
• 算术运算 > 比较运算 > 逻辑运算
• AND优先级 > OR优先级
• 函数调用在其参数计算完成后执行

实践建议：
• 复杂表达式必须使用括号明确优先级
• 不要依赖默认优先级，明确表达意图
• 代码审查时重点检查运算符优先级
```

### 8.4 生产环境应用指导


**📊 表达式设计的最佳实践**
```
设计原则：
• 可读性优先：宁可多写几行，也要清晰明了
• 性能考虑：复杂计算考虑预计算和缓存
• 业务对齐：表达式要准确反映业务规则
• 维护性：表达式要易于理解和修改

测试验证：
• 边界值测试：NULL值、极值、异常数据
• 性能测试：大数据量下的执行时间
• 业务验证：计算结果是否符合业务期望
• 兼容性测试：不同MySQL版本的兼容性
```

**🚀 发展建议**
```
技能提升路径：
1. 熟练掌握基础函数和运算符
2. 理解业务逻辑，能将需求转化为SQL表达式
3. 掌握性能优化技巧
4. 学会使用高级特性（虚拟列、函数索引等）

工具辅助：
• 使用EXPLAIN分析表达式性能
• 开发表达式测试用例
• 建立表达式性能监控
• 制定表达式编写规范
```

**💡 记忆要点**
- **复杂表达式要分层构建**，不要一次性写成巨无霸
- **公共计算要提取**，避免重复计算浪费性能
- **WHERE条件要简化**，复杂表达式移到SELECT或HAVING
- **适当使用索引和缓存**，平衡实时性与性能需求
- **业务逻辑要准确**，表达式必须正确反映业务规则

**核心理念**：
复杂表达式不是为了炫技，而是为了在数据库层面高效地实现业务逻辑。好的表达式应该是**逻辑清晰、性能优良、易于维护**的。记住：**能用简单方法解决的问题，就不要用复杂表达式**。