---
title: 4、常量与系统变量
---
## 📚 目录

1. [常量值的使用](#1-常量值的使用)
2. [系统变量引用机制](#2-系统变量引用机制)
3. [用户变量定义与使用](#3-用户变量定义与使用)
4. [变量作用域详解](#4-变量作用域详解)
5. [变量类型转换规则](#5-变量类型转换规则)
6. [变量生命周期管理](#6-变量生命周期管理)
7. [性能影响与应用技巧](#7-性能影响与应用技巧)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 常量值的使用


### 1.1 什么是常量


在MySQL中，**常量**就是固定不变的值，就像数学中的数字"5"，无论在哪里都代表同样的含义。

**🔸 常量的基本特征**
```
固定性：值在查询执行期间不会改变
直接性：可以直接在SQL语句中使用
多样性：支持数字、字符串、日期等多种类型
```

### 1.2 常量的分类与使用


**🔢 数值常量**
```sql
-- 整数常量
SELECT 100, -50, 0;

-- 小数常量  
SELECT 3.14, -2.5, 0.001;

-- 科学记数法
SELECT 1.2E3, 2.5E-2;  -- 1200, 0.025
```

**📝 字符串常量**
```sql
-- 单引号字符串（推荐）
SELECT 'Hello World', '这是中文字符串';

-- 双引号字符串（特定模式下可用）
SELECT "MySQL Database";

-- 转义字符使用
SELECT 'It\'s a beautiful day', 'Line1\nLine2';
```

**📅 日期时间常量**
```sql
-- 日期常量
SELECT '2025-01-20', DATE('2025-01-20');

-- 时间常量
SELECT '14:30:25', TIME('14:30:25');

-- 日期时间常量
SELECT '2025-01-20 14:30:25', TIMESTAMP('2025-01-20 14:30:25');
```

**💡 NULL常量**
```sql
-- NULL表示"未知"或"空值"
SELECT NULL, 'Hello', NULL + 5;  -- NULL, Hello, NULL

-- NULL的特殊性
SELECT NULL = NULL;  -- NULL（不是TRUE也不是FALSE）
SELECT NULL IS NULL; -- TRUE
```

### 1.3 常量使用场景


**实际应用示例**
```sql
-- 🎯 数据查询中的过滤条件
SELECT * FROM users WHERE age > 18;  -- 18是数值常量

-- 🎯 计算表达式中的参与者
SELECT price * 0.9 AS discounted_price FROM products;  -- 0.9是折扣常量

-- 🎯 默认值设置
SELECT COALESCE(nickname, '匿名用户') AS display_name FROM users;

-- 🎯 状态标识
SELECT 
    name,
    CASE status 
        WHEN 1 THEN '激活'
        WHEN 0 THEN '禁用'
        ELSE '未知'
    END AS status_text
FROM users;
```

---

## 2. ⚙️ 系统变量引用机制


### 2.1 什么是系统变量


**系统变量**就是MySQL内部的"设置选项"，就像手机的各种设置一样，可以调整MySQL的行为方式。

**🔸 系统变量的本质**
```
配置作用：控制MySQL服务器的运行行为
预定义：由MySQL系统预先定义，不能随意创建
可调节：大部分可以动态修改，立即生效
持久性：有些修改重启后失效，有些永久保存
```

### 2.2 系统变量的访问语法


**查看系统变量的方法**

```sql
-- 查看所有系统变量
SHOW VARIABLES;

-- 模糊查询特定变量
SHOW VARIABLES LIKE 'innodb%';
SHOW VARIABLES LIKE '%timeout%';

-- 使用SELECT查看变量
SELECT $$global.max_connections;    -- 全局变量
SELECT $$session.sql_mode;          -- 会话变量
SELECT $$max_connections;           -- 默认查看会话级别
```

### 2.3 常用系统变量类别


**🔸 连接相关变量**

| 变量名 | **作用说明** | **默认值** | **调整建议** |
|--------|-------------|-----------|-------------|
| `max_connections` | `最大连接数` | `151` | `根据并发需求调整：500-2000` |
| `connect_timeout` | `连接超时时间` | `10秒` | `网络慢时适当增加` |
| `wait_timeout` | `非交互连接超时` | `28800秒` | `减少到1800-3600秒` |
| `interactive_timeout` | `交互连接超时` | `28800秒` | `保持默认或适当调整` |

**🔸 性能相关变量**

| 变量名 | **作用说明** | **影响范围** | **调优要点** |
|--------|-------------|-------------|-------------|
| `innodb_buffer_pool_size` | `InnoDB缓冲池大小` | `查询性能` | `设为物理内存的60-80%` |
| `query_cache_size` | `查询缓存大小` | `重复查询性能` | `MySQL 8.0已移除` |
| `sort_buffer_size` | `排序缓冲区大小` | `ORDER BY性能` | `256KB-2MB，不宜过大` |
| `tmp_table_size` | `临时表大小` | `复杂查询性能` | `16MB-256MB` |

### 2.4 系统变量的修改方法


**动态修改（重启后失效）**
```sql
-- 修改全局变量（影响新连接）
SET GLOBAL max_connections = 500;
SET $$global.max_connections = 500;

-- 修改会话变量（只影响当前连接）
SET SESSION sql_mode = 'STRICT_TRANS_TABLES';
SET $$session.sql_mode = 'STRICT_TRANS_TABLES';
```

**永久修改（配置文件）**
```ini
# 在 /etc/my.cnf 中添加
[mysqld]
max_connections = 500
innodb_buffer_pool_size = 2G
sql_mode = STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO
```

---

## 3. 👤 用户变量定义与使用


### 3.1 用户变量概念


**用户变量**是你自己定义的"临时存储盒子"，可以在查询中保存和使用数据。

**🔸 用户变量特点**
```
自定义性：变量名由用户自己决定
临时性：只在当前会话中有效
弱类型：根据赋值自动确定类型
灵活性：可以在查询的任何地方使用
```

### 3.2 用户变量定义语法


**变量定义的两种方式**

```sql
-- 方式1：使用SET语句
SET @变量名 = 值;
SET @user_count = 100;
SET @user_name = '张三';
SET @current_date = NOW();

-- 方式2：在查询中赋值
SELECT @变量名 := 值;
SELECT @max_salary := MAX(salary) FROM employees;
SELECT @row_number := 0;  -- 初始化计数器
```

### 3.3 用户变量的实际应用


**🎯 行号生成（排序编号）**
```sql
-- 为查询结果添加序号
SET @row_number = 0;
SELECT 
    @row_number := @row_number + 1 AS 序号,
    name,
    salary
FROM employees 
ORDER BY salary DESC;
```

**📊 累积计算**
```sql
-- 计算累积销售额
SET @total = 0;
SELECT 
    order_date,
    amount,
    @total := @total + amount AS 累积销售额
FROM orders 
ORDER BY order_date;
```

**🔄 条件计数**
```sql
-- 统计不同条件的记录数
SELECT 
    (@high_salary := SUM(CASE WHEN salary > 10000 THEN 1 ELSE 0 END)) AS 高薪人数,
    (@low_salary := SUM(CASE WHEN salary <= 5000 THEN 1 ELSE 0 END)) AS 低薪人数,
    (@high_salary + @low_salary) AS 总统计人数
FROM employees;
```

### 3.4 🔑 用户变量在查询中的应用技巧


**技巧 ①** 避免重复计算
```sql
-- ❌ 低效写法：重复计算
SELECT 
    name,
    (salary * 12 * 1.1) AS annual_salary,
    (salary * 12 * 1.1) * 0.1 AS bonus
FROM employees;

-- ✅ 高效写法：使用变量缓存
SELECT 
    name,
    (@annual := salary * 12 * 1.1) AS annual_salary,
    @annual * 0.1 AS bonus
FROM employees;
```

**技巧 ②** 实现复杂排名逻辑
```sql
-- 实现相同分数并列排名
SET @rank = 0, @prev_score = NULL;
SELECT 
    name,
    score,
    @rank := CASE 
        WHEN @prev_score = score THEN @rank
        WHEN @prev_score := score THEN @rank := @rank + 1
    END AS ranking
FROM students 
ORDER BY score DESC;
```

---

## 4. 🌐 变量作用域详解


### 4.1 会话变量作用域


**会话变量**只在当前连接中有效，就像你房间里的私人物品，别人看不到也用不了。

**🔸 会话变量的特点**
```
生效范围：仅当前数据库连接
生命周期：从连接建立到连接断开
独立性：不同连接间的变量互不影响
覆盖性：会话变量可以覆盖全局变量的值
```

**会话变量操作示例**
```sql
-- 查看当前会话的特定变量
SELECT $$session.autocommit;
SELECT $$autocommit;  -- 默认查看会话级别

-- 修改会话变量
SET SESSION autocommit = 0;  -- 关闭自动提交
SET $$session.sql_mode = 'STRICT_TRANS_TABLES';

-- 验证修改结果
SHOW SESSION VARIABLES LIKE 'autocommit';
```

### 4.2 全局变量访问


**全局变量**影响所有新建立的连接，就像公司的规章制度，对所有员工都有效。

**🔸 全局变量特点**
```
影响范围：所有新建立的数据库连接
权限要求：需要SUPER权限才能修改
持久性：重启后恢复为配置文件中的值
默认值：为新连接提供初始设置
```

**全局变量操作示例**
```sql
-- 查看全局变量
SELECT $$global.max_connections;
SHOW GLOBAL VARIABLES LIKE 'max_connections';

-- 修改全局变量（需要SUPER权限）
SET GLOBAL max_connections = 1000;
SET $$global.max_connections = 1000;

-- 查看修改是否生效
SELECT $$global.max_connections;
```

### 4.3 变量作用域的实际影响


**作用域优先级规则**
```
变量查找顺序：
1️⃣ 会话变量 (Session Level)
2️⃣ 全局变量 (Global Level)  
3️⃣ 编译默认值 (Compiled Default)

实际效果：
会话变量 > 全局变量 > 默认值
```

**作用域示例对比**
```sql
-- 场景：设置SQL模式
-- 全局设置（影响所有新连接）
SET GLOBAL sql_mode = 'STRICT_TRANS_TABLES';

-- 会话设置（只影响当前连接）
SET SESSION sql_mode = 'TRADITIONAL';

-- 当前连接使用TRADITIONAL模式
-- 新连接使用STRICT_TRANS_TABLES模式
```

---

## 5. 🔄 变量类型转换规则


### 5.1 自动类型转换


MySQL的变量有"智能转换"能力，会根据使用场景自动调整数据类型。

**🔸 转换规则概览**

| 原类型 | **目标类型** | **转换规则** | **示例** |
|--------|-------------|-------------|----------|
| `字符串` | `数值` | `从左开始转换，遇到非数字停止` | `'123abc'→123` |
| `数值` | `字符串` | `直接转换` | `123→'123'` |
| `NULL` | `任意类型` | `保持NULL` | `NULL+5→NULL` |
| `布尔` | `数值` | `TRUE=1, FALSE=0` | `TRUE+5→6` |

### 5.2 类型转换实例


**数值与字符串转换**
```sql
-- 字符串转数值
SET @str_num = '123.45';
SELECT @str_num + 0;        -- 123.45（数值）
SELECT @str_num + 10;       -- 133.45

-- 包含非数字的字符串
SET @mixed = '100abc';
SELECT @mixed + 0;          -- 100（只转换前面的数字部分）

-- 完全非数字的字符串
SET @text = 'abc';
SELECT @text + 0;           -- 0（转换失败返回0）
```

**日期时间转换**
```sql
-- 日期字符串自动识别
SET @date_str = '2025-01-20';
SELECT @date_str + INTERVAL 1 DAY;  -- 2025-01-21

-- 时间戳转换
SET @timestamp = UNIX_TIMESTAMP();
SELECT FROM_UNIXTIME(@timestamp);   -- 转换为可读日期
```

### 5.3 强制类型转换


**显式转换函数**
```sql
-- CAST函数转换
SELECT CAST('123.45' AS DECIMAL(10,2));  -- 精确转换
SELECT CAST('2025-01-20' AS DATE);       -- 日期转换

-- CONVERT函数转换
SELECT CONVERT('123', SIGNED);           -- 转换为有符号整数
SELECT CONVERT('hello', CHAR(10));       -- 字符串长度限制
```

---

## 6. 🔥 变量生命周期管理


### 6.1 用户变量生命周期


**用户变量**的生命周期就是从你定义它开始，到数据库连接断开为止。

**🔸 生命周期阶段**

```
用户变量生命周期：
连接建立 → 变量定义 → 使用阶段 → 连接断开

┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│  连接建立     │───→│  变量活跃     │───→│  变量销毁     │
│ (变量不存在)  │    │ (可读写使用)  │    │ (连接断开)    │
└──────────────┘    └──────────────┘    └──────────────┘
```

**生命周期管理示例**
```sql
-- 会话开始
-- 此时用户变量都不存在

-- 第一次使用：变量自动创建并初始化为NULL
SELECT @counter;  -- NULL

-- 显式初始化变量
SET @counter = 0;
SET @start_time = NOW();

-- 在查询中使用和更新
SELECT @counter := @counter + 1 AS row_num, name FROM users LIMIT 5;

-- 会话结束时，所有用户变量自动销毁
```

### 6.2 系统变量生命周期


**🔸 全局变量生命周期**
```
启动阶段：从配置文件读取初始值
运行阶段：可以动态修改
重启阶段：恢复为配置文件中的值

全局变量持久化：
临时修改：SET GLOBAL var = value;  -- 重启后失效
永久修改：修改my.cnf配置文件      -- 重启后生效
```

**🔸 会话变量生命周期**
```
连接建立：继承全局变量的值作为初始值
会话期间：可以独立修改，不影响其他连接
连接断开：所有会话变量自动清除

会话变量特点：
• 每个连接都有独立的副本
• 修改只影响当前连接
• 连接断开后彻底消失
```

### 6.3 🔥 变量生命周期管理最佳实践


**内存管理策略**
```sql
-- ✅ 及时清理不需要的变量
SET @large_text = NULL;  -- 释放大型字符串变量

-- ✅ 避免创建过多变量
-- 在循环或批量操作中重复使用变量

-- ✅ 合理规划变量命名
SET @temp_count = 0;     -- 临时计数器
SET @user_id = 12345;    -- 业务相关变量
SET @debug_flag = 1;     -- 调试开关
```

**变量使用规范**
```sql
-- 🎯 变量初始化模式
-- 在使用前明确初始化
SET @total_amount = 0;
SET @row_count = 0;
SET @max_date = '1900-01-01';

-- 🎯 变量重置模式  
-- 在新的统计开始前重置变量
SET @running_total = 0;
SELECT 
    date,
    amount,
    (@running_total := @running_total + amount) AS cumulative
FROM sales 
ORDER BY date;
```

---

## 7. ⚡ 性能影响与应用技巧


### 7.1 🔑 系统变量对查询性能影响


系统变量的设置直接影响MySQL的运行效率，就像汽车的发动机调校影响车子的动力表现。

**🔸 关键性能变量影响分析**

| 变量类别 | **核心变量** | **性能影响** | **调优建议** |
|---------|-------------|-------------|-------------|
| 💾 **内存管理** | `innodb_buffer_pool_size` | `缓存命中率直接影响查询速度` | `设为物理内存60-80%` |
| 🔗 **连接管理** | `max_connections` | `连接数过多消耗内存，过少限制并发` | `监控并发数，合理设置` |
| 📝 **日志管理** | `innodb_log_file_size` | `日志文件小会频繁刷盘，影响写性能` | `设为缓冲池的25%` |
| 🔍 **查询优化** | `optimizer_search_depth` | `搜索深度影响复杂查询优化时间` | `保持默认值62` |

**性能调优实战案例**
```sql
-- 🚀 高并发场景优化
SET GLOBAL max_connections = 2000;           -- 支持更多连接
SET GLOBAL innodb_thread_concurrency = 16;   -- 限制并发线程
SET GLOBAL innodb_read_io_threads = 8;       -- 增加读IO线程
SET GLOBAL innodb_write_io_threads = 8;      -- 增加写IO线程

-- 📊 查询缓存优化（MySQL 5.7及以下）
SET GLOBAL query_cache_type = 1;             -- 启用查询缓存
SET GLOBAL query_cache_size = 256M;          -- 设置缓存大小

-- 🔄 事务优化
SET GLOBAL innodb_flush_log_at_trx_commit = 2;  -- 性能与安全平衡
SET GLOBAL sync_binlog = 100;                   -- 减少binlog刷盘频率
```

### 7.2 用户变量性能优化技巧


**避免性能陷阱**
```sql
-- ❌ 性能陷阱：在WHERE子句中使用变量赋值
SELECT * FROM large_table WHERE (@var := column1) > 100;
-- 问题：每行都要计算变量赋值，无法使用索引

-- ✅ 正确做法：先过滤再赋值
SELECT 
    *,
    @var := column1 AS assigned_value
FROM large_table 
WHERE column1 > 100;
```

**批量操作优化**
```sql
-- 🎯 批量更新中的变量使用
SET @batch_size = 1000;
SET @processed = 0;

UPDATE users 
SET last_login = NOW() 
WHERE status = 'active' 
  AND (@processed := @processed + 1) <= @batch_size;

SELECT CONCAT('已处理 ', @processed, ' 条记录') AS 处理结果;
```

### 7.3 变量使用的性能注意事项


**⚠️ 性能影响因素**

```
变量赋值开销：
🟢 简单赋值：@var = 5           -- 开销极小
🟡 计算赋值：@var = col1 + col2  -- 需要计算
🔴 函数赋值：@var = NOW()       -- 函数调用开销

查询优化影响：
🟢 过滤后使用：WHERE ... AND @var := col  -- 不影响索引
🔴 过滤中使用：WHERE @var := col > 100     -- 可能无法使用索引

内存使用：
🟢 数值变量：占用空间小
🟡 字符串变量：按实际长度占用
🔴 大文本变量：可能消耗大量内存
```

**最佳实践建议**
```sql
-- ✅ 推荐：变量用于结果处理
SELECT 
    name,
    salary,
    (@avg_salary := AVG(salary) OVER()) AS avg_salary,
    salary - @avg_salary AS salary_diff
FROM employees;

-- ⚠️ 谨慎：变量用于条件判断
-- 确保不会影响索引使用
SELECT * FROM products 
WHERE price > (@min_price := 100);  -- 可以接受，@min_price是常量
```

---

## 8. 🛠️ 实际应用综合案例


### 8.1 数据分析场景


**📊 销售数据分析报表**
```sql
-- 综合使用各种变量类型
SET @report_date = CURDATE();
SET @total_sales = 0;
SET @order_count = 0;

SELECT 
    @report_date AS 报表日期,
    (@total_sales := SUM(amount)) AS 总销售额,
    (@order_count := COUNT(*)) AS 订单数量,
    ROUND(@total_sales / @order_count, 2) AS 平均订单金额,
    CASE 
        WHEN @total_sales > 100000 THEN '业绩优秀'
        WHEN @total_sales > 50000 THEN '业绩良好'
        ELSE '需要改进'
    END AS 业绩评价
FROM orders 
WHERE DATE(order_date) = @report_date;
```

### 8.2 排名与分组统计


**🏆 学生成绩排名系统**
```sql
-- 使用变量实现复杂排名逻辑
SET @rank = 0;
SET @prev_score = -1;
SET @same_rank_count = 0;

SELECT 
    student_name,
    score,
    @rank := CASE 
        WHEN @prev_score = score THEN @rank
        WHEN @prev_score := score THEN @rank + (@same_rank_count := @same_rank_count + 1)
    END AS ranking,
    CASE 
        WHEN @rank <= 3 THEN '🥇优秀'
        WHEN @rank <= 10 THEN '🥈良好'
        ELSE '🥉及格'
    END AS 等级评定
FROM students 
ORDER BY score DESC, student_name;
```

### 8.3 动态SQL构建


**🔧 动态查询条件**
```sql
-- 根据条件动态构建查询
SET @search_name = '张%';
SET @min_age = 18;
SET @dept_filter = CASE 
    WHEN @include_all_dept = 1 THEN '' 
    ELSE 'AND department = "IT"' 
END;

-- 使用变量构建动态WHERE条件
SELECT * FROM employees 
WHERE name LIKE @search_name 
  AND age >= @min_age
  AND (@include_all_dept = 1 OR department = 'IT');
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 常量：固定不变的值，可直接在SQL中使用
🔸 系统变量：MySQL的配置参数，控制服务器行为
🔸 用户变量：自定义的临时存储，会话级别有效
🔸 作用域：全局变量影响所有连接，会话变量只影响当前连接
🔸 类型转换：MySQL自动处理类型转换，遵循特定规则
🔸 生命周期：变量的创建、使用、销毁过程
```

### 9.2 关键理解要点


**🔹 变量的本质区别**
```
常量 vs 变量：
• 常量：写死的值，查询期间不变
• 变量：可以存储和修改的"容器"

系统变量 vs 用户变量：
• 系统变量：MySQL内置，控制系统行为
• 用户变量：自定义，用于临时计算和存储

全局 vs 会话：
• 全局：影响所有人，需要权限修改
• 会话：只影响自己，随意修改
```

**🔹 性能优化要点**
```
系统变量调优：
• 根据硬件资源合理设置缓冲区大小
• 监控关键性能指标，动态调整参数
• 重要变量修改后要写入配置文件

用户变量使用：
• 避免在WHERE条件中进行变量赋值
• 大量数据处理时注意内存使用
• 及时清理不需要的大型变量
```

**🔹 实际应用技巧**
```
数据分析：用变量实现行号、累积、排名等功能
性能优化：避免重复计算，缓存中间结果
动态查询：根据条件灵活构建查询逻辑
调试辅助：使用变量输出中间计算结果
```

### 9.3 实际应用价值


- **📊 数据分析**：使用变量实现复杂的统计和排名功能
- **⚡ 性能调优**：通过系统变量优化MySQL运行效率  
- **🔧 查询优化**：用变量避免重复计算，提升查询性能
- **🎯 业务逻辑**：在SQL中实现复杂的业务计算逻辑
- **🐛 调试分析**：使用变量输出中间结果，便于问题定位

**核心记忆要点**：
- 常量固定用户灵活系统可调，三类数据各有用途
- 全局影响新连接，会话只管当前，作用域要分清
- 类型转换很智能，性能影响要注意
- 生命周期随连接，合理使用避坑点