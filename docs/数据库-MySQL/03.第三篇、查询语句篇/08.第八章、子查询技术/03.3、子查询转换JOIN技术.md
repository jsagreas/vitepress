---
title: 3、子查询转换JOIN技术
---
## 📚 目录

1. [子查询与JOIN转换概述](#1-子查询与join转换概述)
2. [子查询重写优化原理](#2-子查询重写优化原理)
3. [半连接Semi-join算法详解](#3-半连接semi-join算法详解)
4. [反连接Anti-join实现机制](#4-反连接anti-join实现机制)
5. [子查询执行计划分析](#5-子查询执行计划分析)
6. [优化器子查询处理机制](#6-优化器子查询处理机制)
7. [子查询JOIN转换最佳实践](#7-子查询join转换最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 子查询与JOIN转换概述


### 1.1 什么是子查询转JOIN？


**🔸 基本概念**
子查询转JOIN是数据库优化器的一项重要技术，将**嵌套查询**转换为**连接查询**来提升性能：

```sql
-- 原始子查询（可能性能差）
SELECT * FROM customers c
WHERE c.customer_id IN (
    SELECT o.customer_id 
    FROM orders o 
    WHERE o.order_date > '2024-01-01'
);

-- 转换为JOIN（通常性能更好）
SELECT DISTINCT c.* 
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date > '2024-01-01';
```

### 1.2 为什么要进行转换？


**🔸 性能问题分析**
```
子查询的性能问题：
❌ 嵌套循环执行：外层每行都要执行内层查询
❌ 重复计算：相同条件的子查询可能被多次执行
❌ 索引利用不充分：优化器难以选择最优执行路径

JOIN的性能优势：
✅ 集合操作：一次性处理所有数据
✅ 索引友好：更容易利用索引优化
✅ 优化空间大：优化器有更多选择余地
```

### 1.3 转换适用场景


**🔸 适合转换的子查询类型**
```
✅ EXISTS子查询
SELECT * FROM table1 t1 
WHERE EXISTS (SELECT 1 FROM table2 t2 WHERE t1.id = t2.id);

✅ IN子查询  
SELECT * FROM table1 t1
WHERE t1.id IN (SELECT t2.id FROM table2 t2);

✅ NOT IN子查询（需注意NULL值）
SELECT * FROM table1 t1
WHERE t1.id NOT IN (SELECT t2.id FROM table2 t2 WHERE t2.id IS NOT NULL);

❌ 不适合转换的情况
• 子查询返回聚合结果且需要保持语义
• 相关子查询的逻辑过于复杂
• 转换后会改变结果集的数量
```

---

## 2. ⚡ 子查询重写优化原理


### 2.1 优化器重写机制


**🔸 重写过程详解**
数据库优化器按照以下步骤进行子查询重写：

```
子查询重写流程：
1. 语法分析 → 识别子查询类型
2. 语义分析 → 判断转换可行性  
3. 代价评估 → 比较转换前后成本
4. 执行计划生成 → 选择最优方案

重写规则引擎：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  子查询语句  │ →  │  规则匹配   │ →  │  JOIN语句   │
│             │    │             │    │             │
│ WHERE col   │    │ EXISTS规则  │    │ INNER JOIN  │
│ EXISTS(...)  │    │ IN规则      │    │ LEFT JOIN   │
│ IN(...)     │    │ NOT规则     │    │ ANTI JOIN   │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 2.2 子查询转JOIN条件分析


**🔸 转换条件判断**
```sql
-- 案例1：简单EXISTS转换
-- 原查询
SELECT c.customer_name, c.email
FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.customer_id 
    AND o.status = 'completed'
);

-- 转换条件分析：
✅ 子查询是相关子查询（引用外表）
✅ 子查询只用于存在性判断
✅ 没有聚合函数
✅ 连接条件明确（customer_id）

-- 转换结果
SELECT DISTINCT c.customer_name, c.email
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
WHERE o.status = 'completed';
```

### 2.3 派生表优化技术


**🔸 什么是派生表？**
派生表是子查询在FROM子句中形成的临时表：

```sql
-- 派生表示例
SELECT c.customer_name, summary.total_amount
FROM customers c
JOIN (
    SELECT customer_id, SUM(amount) as total_amount
    FROM orders 
    WHERE order_date >= '2024-01-01'
    GROUP BY customer_id
) summary ON c.customer_id = summary.customer_id;

派生表优化策略：
🔸 合并优化：将派生表合并到外层查询
🔸 物化优化：将派生表结果临时存储
🔸 索引优化：为派生表创建临时索引
```

**🔸 派生表优化实例**
```sql
-- 优化前：派生表嵌套
SELECT * FROM (
    SELECT * FROM (
        SELECT customer_id, order_date, amount
        FROM orders 
        WHERE amount > 1000
    ) t1
    WHERE order_date > '2024-01-01'
) t2
WHERE customer_id IN (1, 2, 3);

-- 优化后：条件下推合并
SELECT customer_id, order_date, amount
FROM orders
WHERE amount > 1000 
  AND order_date > '2024-01-01'
  AND customer_id IN (1, 2, 3);
```

---

## 3. 🔥 半连接Semi-join算法详解


### 3.1 半连接概念理解


**🔸 什么是半连接？**
半连接(Semi-join)是一种特殊的连接操作，只返回**左表中与右表匹配的记录**：

```
半连接 vs 内连接的区别：

内连接(INNER JOIN)：
左表每行 × 右表匹配行 → 可能产生重复

半连接(SEMI JOIN)：
左表每行最多返回一次 → 不会产生重复

图示对比：
左表 A          右表 B
┌────┬────┐     ┌────┬────┐
│ id │name│     │ id │type│
├────┼────┤     ├────┼────┤
│ 1  │张三│     │ 1  │VIP │
│ 2  │李四│     │ 1  │普通│
│ 3  │王五│     │ 3  │VIP │
└────┴────┘     └────┴────┘

INNER JOIN结果：          SEMI JOIN结果：
┌────┬────┬────┐         ┌────┬────┐
│ 1  │张三│VIP │         │ 1  │张三│
│ 1  │张三│普通│  →      │ 3  │王五│
│ 3  │王五│VIP │         └────┴────┘
└────┴────┴────┘
```

### 3.2 半连接实现算法


**🔸 嵌套循环半连接(NL Semi-join)**
```
算法流程：
for 左表的每一行 left_row:
    for 右表的每一行 right_row:
        if left_row.join_key == right_row.join_key:
            输出 left_row
            break  # 找到匹配就停止，不继续找

特点：
✅ 实现简单
❌ 性能较差，复杂度O(M×N)
```

**🔸 哈希半连接(Hash Semi-join)**
```
算法流程：
1. 构建阶段：
   hash_table = {}
   for 右表的每一行 right_row:
       hash_table[right_row.join_key] = true

2. 探测阶段：
   for 左表的每一行 left_row:
       if hash_table.contains(left_row.join_key):
           输出 left_row

特点：
✅ 性能较好，复杂度O(M+N)
✅ 适合右表较小的情况
❌ 需要额外内存空间
```

**🔸 排序合并半连接(Sort-Merge Semi-join)**
```
算法流程：
1. 预处理：左表和右表按连接键排序
2. 合并：
   left_index = 0, right_index = 0
   while left_index < left_size and right_index < right_size:
       if left_key == right_key:
           输出 left_row
           left_index++
           跳过右表中相同key的所有行
       elif left_key < right_key:
           left_index++
       else:
           right_index++

特点：
✅ 适合大数据量
✅ 对内存要求不高
❌ 需要预先排序
```

### 3.3 半连接应用场景


**🔸 EXISTS子查询转换**
```sql
-- 原始EXISTS查询
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.customer_id = c.customer_id
    AND o.order_date > '2024-01-01'
);

-- 优化器内部转换为半连接
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id IN (
    SELECT DISTINCT o.customer_id 
    FROM orders o
    WHERE o.order_date > '2024-01-01'
);

执行计划显示：Hash Semi Join
```

---

## 4. 🚫 反连接Anti-join实现机制


### 4.1 反连接概念理解


**🔸 什么是反连接？**
反连接(Anti-join)返回**左表中与右表不匹配的记录**：

```
反连接应用场景：
• NOT EXISTS子查询
• NOT IN子查询（需特殊处理NULL）
• EXCEPT/MINUS操作

图示说明：
左表 customers        右表 orders
┌────┬────────┐      ┌────┬───────────┐
│ id │  name  │      │cust│order_date │
├────┼────────┤      ├────┼───────────┤
│ 1  │ 张三   │      │ 1  │2024-01-15 │
│ 2  │ 李四   │      │ 3  │2024-02-01 │
│ 3  │ 王五   │      │ 3  │2024-02-10 │
│ 4  │ 赵六   │      └────┴───────────┘
└────┴────────┘

Anti-join结果（没有下单的客户）：
┌────┬────────┐
│ 2  │ 李四   │
│ 4  │ 赵六   │
└────┴────────┘
```

### 4.2 反连接实现算法


**🔸 哈希反连接(Hash Anti-join)**
```
算法流程：
1. 构建阶段：
   hash_set = {}
   for 右表的每一行 right_row:
       if right_row.join_key IS NOT NULL:
           hash_set.add(right_row.join_key)

2. 探测阶段：
   for 左表的每一行 left_row:
       if left_row.join_key IS NOT NULL:
           if NOT hash_set.contains(left_row.join_key):
               输出 left_row

注意：NULL值特殊处理很关键！
```

**🔸 NULL值处理机制**
```sql
-- NOT IN的NULL陷阱
SELECT * FROM table1 
WHERE id NOT IN (SELECT id FROM table2);

-- 如果table2.id中有NULL值，整个查询返回空结果！

-- 正确的处理方式
SELECT * FROM table1 t1
WHERE NOT EXISTS (
    SELECT 1 FROM table2 t2 
    WHERE t2.id = t1.id
);

-- 或者显式排除NULL
SELECT * FROM table1 
WHERE id NOT IN (
    SELECT id FROM table2 WHERE id IS NOT NULL
);
```

### 4.3 反连接性能优化


**🔸 反连接优化策略**
```
性能优化要点：

1. 索引利用：
   -- 右表连接键建索引（构建hash table更快）
   CREATE INDEX idx_orders_customer_id ON orders(customer_id);

2. 统计信息：
   -- 准确的统计信息帮助选择最优算法
   ANALYZE TABLE customers, orders;

3. NULL值优化：
   -- 提前过滤NULL值
   WHERE join_key IS NOT NULL

4. 数据分布：
   -- 如果右表很小，优先选择Hash Anti-join
   -- 如果内存不足，选择Sort-Merge Anti-join
```

---

## 5. 📊 子查询执行计划分析


### 5.1 执行计划解读


**🔸 如何查看执行计划？**
```sql
-- MySQL
EXPLAIN SELECT * FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);

-- PostgreSQL  
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);

-- Oracle
EXPLAIN PLAN FOR
SELECT * FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);

-- SQL Server
SET SHOWPLAN_ALL ON
SELECT * FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);
```

### 5.2 常见执行计划模式


**🔸 子查询未优化的执行计划**
```
执行计划：
┌─────────────────────┐
│    Nested Loop      │  ← 嵌套循环（性能差）
├─────────────────────┤
│ → Table Scan: customers │
│ → SubPlan             │
│   └→ Index Scan: orders │
│      Filter: customer_id = $1 │
└─────────────────────┘

特征：
❌ 出现SubPlan节点
❌ 子查询对外表每行都执行一次
❌ 成本估算：O(M × N)
```

**🔸 优化后的执行计划（Semi-join）**
```
执行计划：
┌─────────────────────┐
│   Hash Semi Join    │  ← 半连接（性能好）
├─────────────────────┤
│ → Hash             │
│   └→ Index Scan: orders │
│ → Table Scan: customers │
└─────────────────────┘

特征：
✅ Semi Join操作
✅ 一次性处理
✅ 成本估算：O(M + N)
```

### 5.3 性能监控指标


**🔸 关键性能指标**
```sql
-- 监控查询执行时间
SELECT 
    query_id,
    avg_timer_wait/1000000000 as avg_time_sec,
    count_star as exec_count,
    sum_timer_wait/1000000000 as total_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE digest_text LIKE '%EXISTS%'
ORDER BY avg_timer_wait DESC;

监控重点：
🔸 执行时间：avg_timer_wait
🔸 执行次数：count_star  
🔸 I/O成本：sum_sort_*、sum_*_io_wait
🔸 内存使用：sum_memory_used
🔸 临时表：sum_created_tmp_tables
```

---

## 6. 🔧 优化器子查询处理机制


### 6.1 优化器架构


**🔸 优化器处理流程**
```
查询优化器处理子查询的完整流程：

输入SQL → 语法解析 → 语义分析 → 查询重写 → 计划生成 → 计划选择 → 执行

详细步骤：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   SQL解析   │ →  │  语义检查   │ →  │  查询重写   │
│ 构建语法树   │    │ 类型检查    │    │ 子查询转换  │
│ 识别子查询   │    │ 权限验证    │    │ 条件下推    │
└─────────────┘    └─────────────┘    └─────────────┘
        ↓                    ↓                    ↓
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   成本评估   │ ←  │  计划枚举   │ ←  │  统计信息   │
│ 选择最优计划 │    │ 生成候选计划│    │ 表大小估算  │
│ 确定算法    │    │ JOIN顺序    │    │ 选择性分析  │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 6.2 优化器决策规则


**🔸 子查询转换决策树**
```
优化器如何决定是否转换子查询：

START
  ↓
子查询类型？
├─ EXISTS/IN → 检查相关性
│             ├─ 相关 → 评估转换成本
│             │       ├─ 成本降低 → 转换为Semi-join
│             │       └─ 成本不变 → 保持子查询
│             └─ 非相关 → 评估物化成本
│                     ├─ 小结果集 → 物化+Hash Join  
│                     └─ 大结果集 → 转换为Semi-join
│
├─ NOT EXISTS/NOT IN → 检查NULL处理
│                    ├─ 有NULL → Anti-join with NULL处理
│                    └─ 无NULL → 标准Anti-join
│
└─ 标量子查询 → 检查相关性
              ├─ 相关 → 保持嵌套循环
              └─ 非相关 → 物化结果
```

### 6.3 优化器配置参数


**🔸 关键配置参数**
```sql
-- MySQL优化器参数
SET optimizer_switch = 'semijoin=on';           -- 启用半连接
SET optimizer_switch = 'materialization=on';   -- 启用物化
SET optimizer_switch = 'loosescan=on';         -- 启用松散扫描
SET optimizer_switch = 'firstmatch=on';        -- 启用首次匹配

-- PostgreSQL优化器参数  
SET enable_hashjoin = on;                      -- 启用Hash Join
SET enable_mergejoin = on;                     -- 启用Sort-Merge Join  
SET enable_nestloop = on;                      -- 启用嵌套循环
SET work_mem = '256MB';                        -- 设置工作内存

-- SQL Server优化器Hint
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.customer_id
)
OPTION (HASH JOIN, OPTIMIZE FOR UNKNOWN);     -- 强制使用Hash Join
```

---

## 7. 🎯 子查询JOIN转换最佳实践


### 7.1 转换策略选择


**🔸 转换决策指南**
```
根据场景选择最佳策略：

🔸 数据量场景：
小表 JOIN 大表：
├─ 优选Hash Semi-join
├─ 小表作为构建端  
└─ 大表作为探测端

大表 JOIN 大表：
├─ 考虑Sort-Merge Join
├─ 利用已有排序
└─ 避免大Hash Table

🔸 选择性场景：
高选择性（结果集小）：
├─ EXISTS → Semi-join
└─ 建议创建索引

低选择性（结果集大）：
├─ 考虑保持子查询
└─ 利用短路求值

🔸 相关性场景：
相关子查询：
├─ 优先转换为JOIN
└─ 避免重复执行

非相关子查询：
├─ 考虑物化策略
└─ 一次计算多次使用
```

### 7.2 性能调优技巧


**🔸 索引优化策略**
```sql
-- 针对Semi-join的索引设计
-- 原查询
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.customer_id 
    AND o.status = 'completed'
);

-- 推荐索引策略
CREATE INDEX idx_orders_customer_status ON orders(customer_id, status);
-- 覆盖索引，包含连接列和过滤列

CREATE INDEX idx_customers_id ON customers(customer_id);
-- 主键索引（通常已存在）

-- 索引选择原理：
✅ 连接列作为索引前导列
✅ 过滤条件列包含在索引中  
✅ 避免索引列数过多
❌ 避免在低选择性列上建索引
```

**🔸 查询重写技巧**
```sql
-- 技巧1：用JOIN替代IN子查询
-- 原查询（可能性能差）
SELECT customer_id, customer_name 
FROM customers
WHERE customer_id IN (
    SELECT customer_id FROM orders 
    WHERE order_date > '2024-01-01'
);

-- 优化后（通常更快）
SELECT DISTINCT c.customer_id, c.customer_name
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date > '2024-01-01';

-- 技巧2：NOT IN改写为LEFT JOIN
-- 原查询（NULL问题）
SELECT * FROM customers
WHERE customer_id NOT IN (
    SELECT customer_id FROM orders 
    WHERE customer_id IS NOT NULL
);

-- 优化后（更安全）
SELECT c.*
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE o.customer_id IS NULL;
```

### 7.3 监控与诊断


**🔸 性能监控检查清单**
```sql
-- 1. 查看执行计划
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
SELECT * FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);

-- 2. 监控关键指标
SELECT 
    schemaname,
    tablename,
    seq_scan,           -- 顺序扫描次数
    seq_tup_read,       -- 顺序读取行数
    idx_scan,           -- 索引扫描次数
    idx_tup_fetch       -- 索引获取行数
FROM pg_stat_user_tables
WHERE tablename IN ('customers', 'orders');

-- 3. 检查锁等待
SELECT 
    locktype,
    database,
    relation::regclass,
    mode,
    granted,
    pid
FROM pg_locks
WHERE NOT granted;

监控重点：
🔸 执行时间趋势
🔸 I/O等待时间
🔸 CPU使用率
🔸 内存消耗
🔸 锁等待情况
```

### 7.4 常见问题及解决方案


**🔸 问题诊断及解决**
```sql
-- 问题1：Semi-join性能不如预期
诊断方法：
EXPLAIN (ANALYZE, BUFFERS) ...

可能原因及解决：
❌ 统计信息过期 → ANALYZE TABLE
❌ 索引缺失 → 创建合适索引
❌ 内存不足 → 调整work_mem
❌ 数据倾斜 → 考虑分区或重写查询

-- 问题2：NOT IN返回意外结果  
原因：NULL值导致的逻辑问题
解决：
1) 显式过滤NULL
WHERE col NOT IN (SELECT col FROM table WHERE col IS NOT NULL)

2) 改写为NOT EXISTS
WHERE NOT EXISTS (SELECT 1 FROM table t2 WHERE t2.col = t1.col)

-- 问题3：转换后结果集数量变化
原因：重复行处理不当
解决：
1) 添加DISTINCT
SELECT DISTINCT ...

2) 使用EXISTS替代IN
WHERE EXISTS (...) 而不是 WHERE col IN (...)
```

---

## 8. 📋 核心要点总结


### 8.1 子查询转JOIN核心概念


```
🎯 转换基本原理：
• 将嵌套查询转换为连接查询
• 从逐行处理改为集合处理
• 提升查询执行效率

🔥 半连接Semi-join：
• 用于EXISTS和IN子查询优化
• 只返回左表匹配的行，无重复
• 算法：Hash、Sort-Merge、Nested Loop

🔥 反连接Anti-join：
• 用于NOT EXISTS和NOT IN优化
• 返回左表不匹配的行
• 需特别注意NULL值处理
```

### 8.2 优化器处理机制


```
🔧 优化器决策流程：
1. 语法语义分析 → 识别子查询类型
2. 可行性检查 → 判断是否可转换
3. 成本评估 → 比较转换前后成本
4. 算法选择 → 选择最优执行算法

🔸 关键决策因素：
• 数据量大小：影响算法选择
• 选择性高低：影响是否转换
• 内存容量：影响Hash vs Sort-Merge
• 索引情况：影响访问路径选择
```

### 8.3 最佳实践指南


```
🔑 转换策略选择：
• EXISTS/IN → Semi-join（推荐）
• NOT EXISTS → Anti-join（安全）
• NOT IN → LEFT JOIN + IS NULL（避免NULL陷阱）

🔑 性能优化要点：
• 创建合适索引：连接列+过滤列
• 更新统计信息：帮助优化器决策
• 调整内存参数：支持Hash操作
• 监控执行计划：验证优化效果

🔑 问题诊断方法：
• 查看执行计划：识别性能瓶颈
• 监控关键指标：执行时间、I/O、CPU
• 检查索引使用：避免全表扫描
• 验证结果正确性：特别注意NULL处理
```

### 8.4 实际应用价值


```
💡 业务场景应用：
• 客户订单查询：找有订单/无订单客户
• 权限检查：用户是否具有某权限
• 数据清洗：找出不一致数据
• 报表查询：统计分析类查询

🎯 性能提升效果：
• 简单场景：2-10倍性能提升
• 复杂场景：10-100倍性能提升
• 大数据量：改善更明显
• 并发查询：系统整体吞吐量提升

⚠️ 注意事项：
• 验证结果正确性：转换可能改变语义
• 监控资源使用：Hash Join消耗内存
• 考虑数据特征：倾斜数据影响算法选择
• 定期维护：统计信息和索引更新
```

**核心记忆口诀**：
- 子查询转JOIN提性能：嵌套改集合效率高
- Semi-join处理EXISTS：左表匹配不重复  
- Anti-join处理NOT：NULL值处理要小心
- 优化器智能选算法：统计索引是关键