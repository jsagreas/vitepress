---
title: 1、子查询分类与特性
---
## 📚 目录

1. [子查询理论基础](#1-子查询理论基础)
2. [子查询技术系统分类](#2-子查询技术系统分类)
3. [标量子查询单值返回](#3-标量子查询单值返回)
4. [列子查询应用详解](#4-列子查询应用详解)
5. [行子查询多字段比较](#5-行子查询多字段比较)
6. [表子查询派生表技术](#6-表子查询派生表技术)
7. [相关子查询与非相关子查询差异](#7-相关子查询与非相关子查询差异)
8. [子查询执行上下文分析](#8-子查询执行上下文分析)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 子查询理论基础


### 1.1 什么是子查询


**🔸 概念解释**
子查询就是**嵌套在其他SQL语句中的查询语句**。可以理解为"查询中的查询"，就像套娃一样，一个查询里面还包含另一个查询。

**简单比喻**：
- 子查询像是**询问助手**：你问主管"谁的工资最高？"，主管先问HR"所有人的工资是多少？"，然后告诉你答案
- 外层查询是**主要问题**，子查询是**辅助问题**

**基本语法结构**：
```sql
-- 子查询的基本形式
SELECT 字段列表
FROM 表名
WHERE 字段 操作符 (SELECT 字段 FROM 表名 WHERE 条件)
                  └─────── 这部分就是子查询 ──────┘
```

### 1.2 嵌套查询发展历程


**🔸 SQL发展中的子查询**

```
SQL发展时间轴：

1970年代 ━━━━━━━━━━━━━━━━━━━━━━━━━━ 关系数据库理论诞生
         |                        (Dr. Edgar Codd)
         |
1980年代 ━━┼━━━━━━━━━━━━━━━━━━━━━━━━ 基础子查询语法
         |                        (WHERE子查询)
         |
1990年代 ━━┼━━━━━━━━━━━━━━━━━━━━━━━━ 高级子查询特性
         |                        (EXISTS、相关子查询)
         |
2000年代 ━━┼━━━━━━━━━━━━━━━━━━━━━━━━ 子查询优化技术
         |                        (查询重写、物化)
现在     ━━┼━━━━━━━━━━━━━━━━━━━━━━━━ CTE和窗口函数
         ↓                        (Common Table Expression)
   继续演进发展
```

**为什么需要子查询**：
- **复杂条件筛选**：基于其他表的计算结果进行过滤
- **动态条件**：查询条件本身需要通过查询获得
- **数据分析**：需要进行多层次的数据处理

### 1.3 子查询在SQL中的位置


**🔸 子查询可以出现的位置**

```sql
-- 1. SELECT子句中（标量子查询）
SELECT name, salary, 
       (SELECT AVG(salary) FROM employees) AS avg_salary
FROM employees;

-- 2. FROM子句中（表子查询）
SELECT *
FROM (SELECT * FROM employees WHERE salary > 5000) AS high_earners;

-- 3. WHERE子句中（最常见）
SELECT name
FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 4. HAVING子句中
SELECT department_id, COUNT(*)
FROM employees
GROUP BY department_id
HAVING COUNT(*) > (SELECT AVG(dept_count) 
                   FROM (SELECT COUNT(*) AS dept_count 
                         FROM employees GROUP BY department_id) AS t);
```

---

## 2. 📊 子查询技术系统分类


### 2.1 分类体系总览


**🔸 子查询分类框架**

```
子查询分类体系树：
                    子查询
                      |
        ┌─────────────┼─────────────┐
        |             |             |
    按返回结果     按执行方式     按嵌套位置
        |             |             |
   ┌────┼────┐   ┌────┼────┐   ┌────┼────┐
   |    |    |   |         |   |    |    |
 标量  列  行表  非相关   相关  SELECT FROM WHERE
 子查询      子查询   子查询    子查询
```

### 2.2 按返回结果分类详解


**🔥 返回结果类型对比表**

```
┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   子查询类型     │   返回结果形式   │   使用场景       │   操作符支持     │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ 标量子查询       │   单行单列       │ 比较运算、计算   │ =, >, <, >=, <= │
│ 列子查询         │   多行单列       │ 成员判断        │ IN, ANY, ALL    │
│ 行子查询         │   单行多列       │ 多字段比较      │ =, IN           │
│ 表子查询         │   多行多列       │ 临时数据源      │ FROM, EXISTS    │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

**🔸 返回结果示意图**

```
标量子查询结果：    列子查询结果：      行子查询结果：
┌─────────┐       ┌─────────┐        ┌───────────────┐
│  5000   │       │  1001   │        │ 'John'  5000  │
└─────────┘       │  1002   │        └───────────────┘
单个值              │  1003   │        一行多列
                  │  1004   │
                  └─────────┘
                  多行单列

表子查询结果：
┌───────────────────────────┐
│ name     salary    dept   │
├───────────────────────────┤
│ 'John'   5000      IT     │
│ 'Mary'   6000      HR     │  
│ 'Bob'    5500      IT     │
└───────────────────────────┘
多行多列
```

### 2.3 按执行方式分类


**🔸 执行方式对比**

**非相关子查询**：
- **执行方式**：子查询先执行，结果传给外层查询
- **执行次数**：只执行一次
- **性能特点**：通常性能较好

**相关子查询**：
- **执行方式**：外层查询每处理一行，子查询执行一次
- **执行次数**：与外层查询行数相同
- **性能特点**：性能相对较差，但功能更强大

```
执行流程对比：

非相关子查询执行：
第1步: 执行子查询 → 得到结果集
第2步: 用结果集执行外层查询 → 最终结果

相关子查询执行：
第1步: 外层查询取第1行 → 执行子查询 → 判断条件
第2步: 外层查询取第2行 → 执行子查询 → 判断条件
第3步: 外层查询取第3行 → 执行子查询 → 判断条件
...继续直到所有行处理完
```

---

## 3. 📈 标量子查询单值返回


### 3.1 标量子查询特性


**🔸 核心特点**
标量子查询返回**单行单列**的结果，就像一个具体的数值或字符串。可以把它理解为"计算器"，给你一个确定的答案。

> 💡 **记住要点**：标量子查询必须确保只返回一个值，否则会报错

**🔸 标量子查询的使用位置**

```sql
-- 在SELECT子句中使用（计算字段）
SELECT 
    name,
    salary,
    (SELECT AVG(salary) FROM employees) AS company_avg,
    salary - (SELECT AVG(salary) FROM employees) AS diff_from_avg
FROM employees;

-- 在WHERE子句中使用（条件过滤）
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 在UPDATE语句中使用
UPDATE employees 
SET salary = salary * 1.1
WHERE department_id = (SELECT id FROM departments WHERE name = 'IT');
```

### 3.2 标量子查询实际应用


**🔥 常见应用场景**

**场景1：工资高于平均值的员工**
```sql
-- 问题：找出工资高于公司平均工资的员工
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 执行过程：
-- 1. 先计算：SELECT AVG(salary) FROM employees → 假设得到5500
-- 2. 再执行：SELECT name, salary FROM employees WHERE salary > 5500
```

**场景2：部门人数最多的部门**
```sql
-- 问题：找出员工人数最多的部门
SELECT department_name
FROM departments d
WHERE (SELECT COUNT(*) FROM employees WHERE department_id = d.id) = 
      (SELECT MAX(emp_count) 
       FROM (SELECT COUNT(*) AS emp_count 
             FROM employees 
             GROUP BY department_id) AS dept_counts);
```

**场景3：计算差值和比例**
```sql
-- 显示每个员工工资与平均工资的差异
SELECT 
    name,
    salary,
    (SELECT AVG(salary) FROM employees) AS avg_salary,
    salary - (SELECT AVG(salary) FROM employees) AS difference,
    ROUND(salary / (SELECT AVG(salary) FROM employees) * 100, 2) AS percentage
FROM employees
ORDER BY salary DESC;
```

### 3.3 标量子查询注意事项


> ⚠️ **重要提醒**：标量子查询如果返回多行会导致错误

**错误示例**：
```sql
-- ❌ 错误：子查询返回多行
SELECT name
FROM employees
WHERE salary = (SELECT salary FROM employees WHERE department_id = 1);
-- 错误信息：Subquery returns more than 1 row

-- ✅ 正确：确保只返回一行
SELECT name  
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees WHERE department_id = 1);
```

**防止空值的处理**：
```sql
-- 使用COALESCE处理可能的NULL值
SELECT 
    name,
    salary,
    COALESCE((SELECT AVG(salary) FROM employees WHERE department_id = 999), 0) AS dept_avg
FROM employees;
```

---

## 4. 📋 列子查询应用详解


### 4.1 列子查询基本概念


**🔸 什么是列子查询**
列子查询返回**多行单列**的结果，就像一个数值列表。主要用于判断某个值是否在这个列表中。

**🔸 列子查询操作符**

```
列子查询专用操作符：
┌─────────────────┬─────────────────────────────────────┐
│   操作符        │             含义说明                │
├─────────────────┼─────────────────────────────────────┤
│ IN              │ 值在子查询结果列表中                │
│ NOT IN          │ 值不在子查询结果列表中              │
│ ANY/SOME        │ 满足与子查询结果中任意一个值的比较   │
│ ALL             │ 满足与子查询结果中所有值的比较       │
└─────────────────┴─────────────────────────────────────┘
```

### 4.2 IN和NOT IN操作符


**🔥 IN操作符使用**

**基本用法**：
```sql
-- 问题：找出在IT、HR、财务部门工作的员工
SELECT name, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments 
                        WHERE name IN ('IT', 'HR', '财务'));

-- 等价于多个OR条件：
-- WHERE department_id = 1 OR department_id = 2 OR department_id = 3
```

**复杂场景应用**：
```sql
-- 找出参与了项目的员工
SELECT DISTINCT e.name, e.salary
FROM employees e
WHERE e.id IN (SELECT DISTINCT employee_id FROM project_assignments);

-- 找出销售额超过平均值的销售员
SELECT name
FROM salespeople  
WHERE id IN (SELECT salesperson_id 
             FROM sales 
             GROUP BY salesperson_id
             HAVING SUM(amount) > (SELECT AVG(total_sales)
                                   FROM (SELECT SUM(amount) AS total_sales
                                         FROM sales 
                                         GROUP BY salesperson_id) AS t));
```

**🔥 NOT IN操作符陷阱**

> ⚠️ **重要警告**：NOT IN遇到NULL值会产生意外结果

**问题演示**：
```sql
-- 假设departments表中id字段有NULL值
SELECT name
FROM employees
WHERE department_id NOT IN (SELECT id FROM departments);

-- 如果子查询结果包含NULL，整个NOT IN表达式返回NULL
-- 导致没有任何记录被返回！

-- ✅ 正确做法：过滤掉NULL值
SELECT name  
FROM employees
WHERE department_id NOT IN (SELECT id FROM departments WHERE id IS NOT NULL);

-- 或者使用EXISTS
SELECT name
FROM employees e
WHERE NOT EXISTS (SELECT 1 FROM departments d WHERE d.id = e.department_id);
```

### 4.3 ANY、SOME、ALL操作符详解


**🔧 ANY/SOME操作符**（ANY和SOME完全等价）

```sql
-- 基本语法：字段 比较操作符 ANY (子查询)

-- 示例：工资比任何一个经理的工资都高的员工
SELECT name, salary
FROM employees
WHERE salary > ANY (SELECT salary FROM employees WHERE position = '经理');

-- 等价理解：salary > MIN(经理工资列表)
-- 如果经理工资是 [8000, 9000, 10000]
-- 那么 salary > ANY 就是 salary > 8000
```

**🔧 ALL操作符**

```sql
-- 基本语法：字段 比较操作符 ALL (子查询)

-- 示例：工资比所有经理的工资都高的员工  
SELECT name, salary
FROM employees
WHERE salary > ALL (SELECT salary FROM employees WHERE position = '经理');

-- 等价理解：salary > MAX(经理工资列表)
-- 如果经理工资是 [8000, 9000, 10000] 
-- 那么 salary > ALL 就是 salary > 10000
```

**🔸 ANY/ALL操作符对比表**

```
┌─────────────────┬─────────────────┬─────────────────┐
│   表达式        │   等价条件       │   通俗理解       │
├─────────────────┼─────────────────┼─────────────────┤
│ > ANY           │ > MIN(list)     │ 比最小值大       │
│ < ANY           │ < MAX(list)     │ 比最大值小       │ 
│ = ANY           │ IN (list)       │ 等于任一值       │
│ > ALL           │ > MAX(list)     │ 比最大值大       │
│ < ALL           │ < MIN(list)     │ 比最小值小       │
│ = ALL           │ 只有一个值时成立 │ 等于所有值       │
└─────────────────┴─────────────────┴─────────────────┘
```

**实际应用示例**：
```sql
-- 找出比所有销售员工资都高的管理人员
SELECT name, salary, position
FROM employees
WHERE position LIKE '%经理%'
  AND salary > ALL (SELECT salary FROM employees WHERE position LIKE '%销售%');

-- 找出工资在任何一个部门平均工资之上的员工
SELECT e.name, e.salary, d.name AS dept_name
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE e.salary > ANY (SELECT AVG(salary) 
                      FROM employees 
                      GROUP BY department_id);
```

---

## 5. 🔄 行子查询多字段比较


### 5.1 行子查询概念


**🔸 什么是行子查询**
行子查询返回**单行多列**的结果，用于同时比较多个字段的组合。就像同时检查多个条件是否匹配。

**基本语法形式**：
```sql
-- 行构造器语法
WHERE (字段1, 字段2, 字段3) = (SELECT 字段1, 字段2, 字段3 FROM 表 WHERE 条件)

-- 或者使用IN
WHERE (字段1, 字段2) IN (SELECT 字段1, 字段2 FROM 表 WHERE 条件)
```

### 5.2 行子查询实际应用


**🔥 场景1：查找特定条件组合**

```sql
-- 问题：找出与张三同部门且同职位的其他员工
SELECT name, department_id, position
FROM employees
WHERE (department_id, position) = 
      (SELECT department_id, position 
       FROM employees 
       WHERE name = '张三')
  AND name != '张三';

-- 传统写法需要多个条件：
SELECT name, department_id, position  
FROM employees
WHERE department_id = (SELECT department_id FROM employees WHERE name = '张三')
  AND position = (SELECT position FROM employees WHERE name = '张三')
  AND name != '张三';
```

**🔥 场景2：多字段最值查询**

```sql
-- 问题：找出每个部门中工资和奖金组合最高的员工
SELECT name, department_id, salary, bonus
FROM employees e1
WHERE (salary, bonus) = (SELECT MAX(salary), MAX(bonus)
                         FROM employees e2  
                         WHERE e2.department_id = e1.department_id);
```

**🔥 场景3：复杂条件匹配**

```sql
-- 问题：找出与某个特定员工具有相同学历和经验年限的员工
SELECT name, education, experience_years
FROM employees
WHERE (education, experience_years) IN 
      (SELECT education, experience_years
       FROM employees  
       WHERE salary > 10000);

-- 查找在特定日期范围内入职且满足条件的员工
SELECT name, hire_date, department_id
FROM employees
WHERE (YEAR(hire_date), department_id) IN 
      (SELECT YEAR(hire_date), department_id
       FROM employees
       WHERE salary > (SELECT AVG(salary) FROM employees)
       GROUP BY YEAR(hire_date), department_id
       HAVING COUNT(*) >= 2);
```

### 5.3 行子查询注意事项


**🔸 字段数量和类型匹配**

```sql
-- ✅ 正确：字段数量和类型匹配
WHERE (name, age) = (SELECT name, age FROM persons WHERE id = 1)

-- ❌ 错误：字段数量不匹配  
WHERE (name, age) = (SELECT name FROM persons WHERE id = 1)

-- ❌ 错误：字段类型不匹配
WHERE (name, salary) = (SELECT salary, name FROM employees WHERE id = 1)
```

**🔸 空值处理**

```sql
-- 行子查询中的NULL值处理
SELECT *
FROM employees
WHERE (department_id, manager_id) = (SELECT 1, NULL);

-- 如果子查询返回 (1, NULL)，比较结果为 NULL，不会匹配任何行
-- 需要特殊处理NULL值的情况
```

---

## 6. 🗂️ 表子查询派生表技术


### 6.1 表子查询基本概念


**🔸 什么是表子查询**
表子查询返回**多行多列**的结果，创建一个**临时的虚拟表**（派生表），可以像普通表一样使用。

**🔸 派生表的特点**
- **临时性**：只在查询执行期间存在
- **别名必需**：必须给派生表指定别名
- **完整功能**：支持JOIN、WHERE、GROUP BY等所有操作

### 6.2 FROM子句中的表子查询


**🔥 基础用法**

```sql
-- 基本语法
SELECT 字段列表
FROM (子查询) AS 别名
WHERE 条件;

-- 示例：查询高工资员工的统计信息
SELECT dept_name, avg_salary, emp_count
FROM (SELECT d.name AS dept_name,
             AVG(e.salary) AS avg_salary,
             COUNT(*) AS emp_count
      FROM employees e
      JOIN departments d ON e.department_id = d.id  
      WHERE e.salary > 5000
      GROUP BY d.id, d.name) AS high_salary_stats
WHERE emp_count > 3;
```

**🔥 复杂分析场景**

```sql
-- 问题：找出每个部门工资排名前3的员工
SELECT department_name, employee_name, salary, rank_num
FROM (SELECT d.name AS department_name,
             e.name AS employee_name,
             e.salary,
             ROW_NUMBER() OVER (PARTITION BY d.id ORDER BY e.salary DESC) AS rank_num
      FROM employees e
      JOIN departments d ON e.department_id = d.id) AS ranked_employees
WHERE rank_num <= 3
ORDER BY department_name, rank_num;

-- 计算移动平均值
SELECT month, sales_amount, avg_3_months
FROM (SELECT month,
             sales_amount,
             AVG(sales_amount) OVER (ORDER BY month 
                                     ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS avg_3_months
      FROM monthly_sales
      WHERE year = 2024) AS sales_with_avg
ORDER BY month;
```

### 6.3 表子查询的高级应用


**🔥 多层嵌套分析**

```sql
-- 三层嵌套：部门→员工统计→最终分析
SELECT final_category, COUNT(*) AS dept_count, AVG(avg_salary) AS overall_avg
FROM (SELECT dept_name,
             avg_salary,
             emp_count,
             CASE 
                 WHEN avg_salary > 8000 THEN '高薪部门'
                 WHEN avg_salary > 5000 THEN '中薪部门'  
                 ELSE '低薪部门'
             END AS final_category
      FROM (SELECT d.name AS dept_name,
                   AVG(e.salary) AS avg_salary,
                   COUNT(*) AS emp_count
            FROM employees e
            JOIN departments d ON e.department_id = d.id
            GROUP BY d.id, d.name
            HAVING COUNT(*) >= 5) AS dept_stats) AS categorized_depts
GROUP BY final_category
ORDER BY overall_avg DESC;
```

**🔥 与普通表的JOIN操作**

```sql
-- 派生表与普通表的连接
SELECT p.project_name, 
       team.avg_salary, 
       team.team_size,
       p.budget / team.team_size AS budget_per_person
FROM projects p
JOIN (SELECT pa.project_id,
             AVG(e.salary) AS avg_salary,
             COUNT(*) AS team_size
      FROM project_assignments pa
      JOIN employees e ON pa.employee_id = e.id
      GROUP BY pa.project_id) AS team ON p.id = team.project_id
WHERE p.status = 'active'
ORDER BY budget_per_person DESC;
```

### 6.4 表子查询性能考虑


> 💡 **性能提示**：表子查询会创建临时结果集，对于大数据量要注意性能

**优化建议**：
```sql
-- ❌ 性能较差：每次都计算完整的派生表
SELECT *
FROM (SELECT * FROM large_table ORDER BY create_time DESC) AS recent_data
WHERE id = 12345;

-- ✅ 性能较好：先过滤再排序
SELECT *  
FROM (SELECT * FROM large_table WHERE id = 12345) AS filtered_data
ORDER BY create_time DESC;

-- 使用索引友好的条件
SELECT *
FROM (SELECT * FROM employees WHERE department_id IN (1,2,3)) AS dept_employees
WHERE salary > 5000;
```

---

## 7. 🔄 相关子查询与非相关子查询差异


### 7.1 执行机制根本差异


**🔸 非相关子查询执行过程**

```
非相关子查询 = 独立执行
┌─────────────────────────────────────────────────────────────┐
│ 执行步骤：                                                   │
│ 1. 执行子查询（1次）        → 得到结果                       │
│ 2. 将结果代入外层查询       → 执行外层查询                   │
│ 3. 返回最终结果                                             │
└─────────────────────────────────────────────────────────────┘

示例：
SELECT name FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);

执行过程：
第1步：SELECT AVG(salary) FROM employees → 假设得到 6000
第2步：SELECT name FROM employees WHERE salary > 6000
```

**🔸 相关子查询执行过程**

```
相关子查询 = 循环执行  
┌─────────────────────────────────────────────────────────────┐
│ 执行步骤：                                                   │
│ 1. 外层查询取第1行数据                                       │
│ 2. 将第1行数据传给子查询执行                                 │
│ 3. 根据子查询结果决定是否保留第1行                           │
│ 4. 外层查询取第2行数据，重复步骤2-3                          │
│ 5. 直到处理完外层查询的所有行                                │
└─────────────────────────────────────────────────────────────┘

示例：  
SELECT name FROM employees e1 
WHERE salary > (SELECT AVG(salary) FROM employees e2 
                WHERE e2.department_id = e1.department_id);
```

### 7.2 相关子查询典型应用


**🔥 场景1：部门内比较**

```sql
-- 找出每个部门中工资高于本部门平均工资的员工
SELECT e1.name, e1.salary, d.name AS dept_name
FROM employees e1
JOIN departments d ON e1.department_id = d.id
WHERE e1.salary > (SELECT AVG(e2.salary) 
                   FROM employees e2 
                   WHERE e2.department_id = e1.department_id);

-- 执行解释：
-- 对于每个员工e1，子查询都会计算该员工所在部门的平均工资
-- 然后比较该员工的工资是否高于部门平均工资
```

**🔥 场景2：EXISTS存在性检查**

```sql
-- 找出有下属的经理
SELECT m.name AS manager_name
FROM employees m  
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.manager_id = m.id);

-- 找出没有员工的部门
SELECT d.name AS empty_dept
FROM departments d
WHERE NOT EXISTS (SELECT 1 FROM employees e WHERE e.department_id = d.id);
```

**🔥 场景3：排名和比较**

```sql
-- 找出在本部门工资排名前3的员工
SELECT name, salary, department_id
FROM employees e1
WHERE (SELECT COUNT(*) 
       FROM employees e2 
       WHERE e2.department_id = e1.department_id 
         AND e2.salary >= e1.salary) <= 3;

-- 找出销售额超过上月同期的销售员
SELECT s1.salesperson_name, s1.sales_amount, s1.sales_month
FROM monthly_sales s1
WHERE s1.sales_amount > (SELECT s2.sales_amount 
                         FROM monthly_sales s2
                         WHERE s2.salesperson_id = s1.salesperson_id
                           AND s2.sales_month = DATE_SUB(s1.sales_month, INTERVAL 1 MONTH));
```

### 7.3 性能特点分析


**🔸 性能对比**

```
┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   子查询类型     │   执行次数       │   性能特点       │   适用场景       │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ 非相关子查询     │   1次           │ 通常较快         │ 全局条件比较     │
│ 相关子查询       │   外层查询行数   │ 通常较慢         │ 逐行条件检查     │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

**优化建议**：

```sql
-- ❌ 性能较差的相关子查询
SELECT name
FROM employees e1
WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.department_id = e1.department_id);

-- ✅ 优化方案：使用窗口函数
SELECT name
FROM (SELECT name, salary,
             AVG(salary) OVER (PARTITION BY department_id) AS dept_avg
      FROM employees) AS t
WHERE salary > dept_avg;

-- ✅ 优化方案：使用JOIN
SELECT e.name
FROM employees e
JOIN (SELECT department_id, AVG(salary) AS avg_salary
      FROM employees
      GROUP BY department_id) AS dept_avg
  ON e.department_id = dept_avg.department_id
WHERE e.salary > dept_avg.avg_salary;
```

---

## 8. 🧠 子查询执行上下文分析


### 8.1 执行上下文概念


**🔸 什么是执行上下文**
执行上下文是指查询执行时的**环境和状态**，包括可访问的表、字段、变量等。可以理解为查询的"作用域"。

**🔸 上下文层次结构**

```
查询上下文层次图：
┌─────────────────────────────────────────────────────────────┐
│                    全局上下文                                │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                 外层查询上下文                         │  │
│  │  ┌─────────────────────────────────────────────────┐  │  │
│  │  │              子查询上下文                        │  │  │
│  │  │  ┌───────────────────────────────────────────┐  │  │  │
│  │  │  │           嵌套子查询上下文                 │  │  │  │
│  │  │  └───────────────────────────────────────────┘  │  │  │
│  │  └─────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 变量和字段的作用域


**🔸 字段引用规则**

```sql
-- 字段引用的优先级和作用域
SELECT e1.name,
       (SELECT COUNT(*) 
        FROM projects p
        WHERE p.manager_id = e1.id  -- e1来自外层查询上下文
          AND p.status = 'active'
          AND p.budget > (SELECT AVG(pr.budget) 
                          FROM projects pr  -- pr是内层子查询的上下文
                          WHERE pr.department_id = e1.department_id)) AS active_projects
FROM employees e1
WHERE e1.position LIKE '%manager%';
```

**🔸 上下文访问规则**

```
上下文访问规则：
┌─────────────────────────────────────────────────────────────┐
│ 1. 内层查询可以访问外层查询的所有字段和表别名                │
│ 2. 外层查询不能访问内层查询的字段和表别名                   │ 
│ 3. 同级子查询之间不能互相访问对方的上下文                   │
│ 4. 字段引用遵循"就近原则"，优先使用当前层的字段             │
└─────────────────────────────────────────────────────────────┘
```

### 8.3 复杂嵌套的上下文管理


**🔧 多层嵌套示例**

```sql
-- 三层嵌套的上下文关系
SELECT d.name AS dept_name,
       (SELECT COUNT(*)
        FROM employees e1
        WHERE e1.department_id = d.id  -- 访问最外层的d表
          AND e1.salary > (SELECT AVG(e2.salary)
                           FROM employees e2  
                           WHERE e2.department_id = d.id  -- 访问最外层的d表
                             AND e2.hire_date > (SELECT MIN(e3.hire_date)
                                                 FROM employees e3
                                                 WHERE e3.department_id = e1.department_id  -- 访问中间层的e1表
                                                   AND e3.position = e1.position))) AS complex_count
FROM departments d;
```

**🔧 上下文冲突处理**

```sql
-- 表别名冲突的处理
SELECT e.name
FROM employees e
WHERE e.salary > (SELECT AVG(e.salary)  -- ❌ 这里的e指的是子查询中的e，不是外层的e
                  FROM employees e);

-- 正确的写法：使用不同的别名
SELECT e1.name  
FROM employees e1
WHERE e1.salary > (SELECT AVG(e2.salary)
                   FROM employees e2);

-- 或者明确指定表名
SELECT employees.name
FROM employees  
WHERE employees.salary > (SELECT AVG(e.salary)
                          FROM employees e);
```

### 8.4 执行计划和优化


**🔸 查询优化器的处理**

```sql
-- 查询优化器可能的重写
-- 原始查询：
SELECT name FROM employees e1
WHERE EXISTS (SELECT 1 FROM departments d WHERE d.id = e1.department_id);

-- 优化器可能重写为：
SELECT e1.name
FROM employees e1
INNER JOIN departments d ON d.id = e1.department_id;
```

**🔸 执行计划分析**

```sql
-- 使用EXPLAIN查看执行计划
EXPLAIN SELECT name
FROM employees e1
WHERE salary > (SELECT AVG(salary) 
                FROM employees e2 
                WHERE e2.department_id = e1.department_id);

-- 关注点：
-- 1. 子查询执行方式：DEPENDENT SUBQUERY（相关）vs SUBQUERY（非相关）
-- 2. 表访问顺序
-- 3. 索引使用情况
-- 4. 预估的行数和成本
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 子查询本质：嵌套在其他SQL语句中的查询，实现复杂的数据筛选和分析
🔸 分类体系：按返回结果（标量/列/行/表）和执行方式（相关/非相关）分类
🔸 标量子查询：返回单值，可用于比较和计算，必须确保只返回一行一列
🔸 列子查询：返回多行单列，配合IN、ANY、ALL等操作符使用
🔸 行子查询：返回单行多列，用于多字段组合比较
🔸 表子查询：返回多行多列，创建派生表用于复杂分析
🔸 执行差异：非相关子查询执行一次，相关子查询循环执行
```

### 9.2 关键技术要点


**🔹 子查询选择策略**
```
场景分析决策树：
需要单个计算结果 → 标量子查询
需要列表匹配判断 → 列子查询 + IN/ANY/ALL
需要多字段联合比较 → 行子查询
需要复杂数据分析 → 表子查询（派生表）
需要逐行条件检查 → 相关子查询 + EXISTS
```

**🔹 性能优化原则**
```
优化策略：
- 优先使用非相关子查询（执行次数少）
- 避免在大表上使用相关子查询
- 合理使用索引支持子查询条件
- 考虑用JOIN替代部分子查询
- 注意NULL值对NOT IN等操作的影响
```

**🔹 常见陷阱和注意事项**
```
技术陷阱：
⚠️ 标量子查询返回多行会报错
⚠️ NOT IN遇到NULL值会返回意外结果  
⚠️ 相关子查询性能可能很差
⚠️ 表别名在嵌套中可能产生冲突
⚠️ 过深的嵌套层次影响可读性
```

### 9.3 实际应用指导


**🎯 业务场景匹配**
- **数据分析**：使用表子查询创建复杂的统计报表
- **条件筛选**：使用列子查询进行列表匹配过滤
- **动态比较**：使用标量子查询进行基于计算的比较
- **存在性检查**：使用EXISTS进行高效的存在性判断
- **排名分析**：使用相关子查询进行组内排名和比较

**🔧 最佳实践建议**
- **可读性优先**：复杂子查询考虑拆分为多个步骤
- **性能考虑**：大数据量场景谨慎使用相关子查询
- **维护性**：为子查询添加注释说明业务逻辑
- **测试验证**：充分测试边界条件和NULL值处理
- **监控优化**：定期检查子查询的执行计划和性能

**核心记忆要点**：
- 子查询分四类：标量返单值，列表配IN用，行比多字段，表做派生源
- 执行有差异：非相关跑一次，相关子查询逐行循环很耗时
- 性能要注意：大表避免相关查询，NULL值影响NOT IN结果
- 上下文规则：内层能访问外层字段，外层不能访问内层变量