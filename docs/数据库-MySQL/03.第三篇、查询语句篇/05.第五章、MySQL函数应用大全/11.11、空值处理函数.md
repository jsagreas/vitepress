---
title: 11、空值处理函数
---
## 📚 目录

1. [空值处理基础概念](#1-空值处理基础概念)
2. [ISNULL空值检测函数](#2-ISNULL空值检测函数)
3. [IFNULL默认值设置函数](#3-IFNULL默认值设置函数)
4. [COALESCE多值合并函数](#4-COALESCE多值合并函数)
5. [NULLIF条件置空函数](#5-NULLIF条件置空函数)
6. [空值处理综合策略](#6-空值处理综合策略)
7. [NULL值逻辑处理详解](#7-NULL值逻辑处理详解)
8. [空值处理最佳实践](#8-空值处理最佳实践)
9. [性能优化考虑](#9-性能优化考虑)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 空值处理基础概念


### 1.1 什么是NULL值


**NULL的本质理解**：
```
NULL ≠ 0        // NULL不是数字0
NULL ≠ ''       // NULL不是空字符串
NULL ≠ FALSE    // NULL不是布尔值false

NULL = "未知"   // NULL表示数据缺失、未知或不适用
```

> 💡 **通俗理解**：NULL就像一个空的盒子，你不知道里面应该放什么，甚至不知道该不该放东西

**NULL在数据库中的实际含义**：
- **数据缺失**：用户没有填写手机号码
- **暂时未知**：订单的实际发货时间
- **不适用**：单身用户的配偶信息
- **计算无意义**：除零运算的结果

### 1.2 NULL值的特殊行为


**NULL值的运算特性**：
```sql
-- 任何值与NULL运算都得到NULL
SELECT 10 + NULL;        -- 结果: NULL
SELECT 'hello' + NULL;   -- 结果: NULL
SELECT NULL = NULL;      -- 结果: NULL (不是TRUE!)
SELECT NULL <> NULL;     -- 结果: NULL (不是FALSE!)
```

> ⚠️ **重要提醒**：NULL = NULL 的结果不是TRUE，而是NULL！这是很多初学者容易犯错的地方

**NULL值的比较逻辑**：
```sql
-- 错误的NULL判断方式
SELECT * FROM users WHERE age = NULL;     -- 永远查不到数据
SELECT * FROM users WHERE age != NULL;    -- 永远查不到数据

-- 正确的NULL判断方式
SELECT * FROM users WHERE age IS NULL;        -- 查找年龄为空的用户
SELECT * FROM users WHERE age IS NOT NULL;    -- 查找年龄不为空的用户
```

### 1.3 为什么需要空值处理函数


**实际业务场景**：

┌─────────────────┬─────────────────┬─────────────────┐
│  **业务场景**   │  **NULL问题**   │  **解决需求**   │
├─────────────────┼─────────────────┼─────────────────┤
│ 用户资料显示     │ 手机号为NULL     │ 显示"未设置"    │
│ 价格计算        │ 折扣为NULL       │ 按原价计算      │
│ 数据统计        │ 部分数据缺失     │ 排除或替换      │
│ 报表生成        │ NULL影响计算     │ 提供默认值      │
└─────────────────┴─────────────────┴─────────────────┘

---

## 2. 🔍 ISNULL空值检测函数


### 2.1 ISNULL函数基本语法


**函数定义**：
```sql
ISNULL(expression)
```

**返回值逻辑**：
- 如果 expression 是 NULL → 返回 1 (TRUE)
- 如果 expression 不是 NULL → 返回 0 (FALSE)

> 💡 **记忆技巧**：ISNULL就像问"这个值是NULL吗？"，是的话返回1，不是返回0

### 2.2 ISNULL函数实际应用


**基础用法示例**：
```sql
-- 检测单个字段是否为空
SELECT 
  name,
  phone,
  ISNULL(phone) AS phone_is_null
FROM users;

结果示例：
┌─────────┬─────────────┬───────────────┐
│  name   │    phone    │ phone_is_null │
├─────────┼─────────────┼───────────────┤
│ 张三     │ 13800138000 │      0        │
│ 李四     │    NULL     │      1        │
│ 王五     │ 13900139000 │      0        │
└─────────┴─────────────┴───────────────┘
```

**条件查询中的应用**：
```sql
-- 查找所有手机号为空的用户
SELECT * FROM users WHERE ISNULL(phone) = 1;

-- 查找所有手机号不为空的用户
SELECT * FROM users WHERE ISNULL(phone) = 0;

-- 等价的更简洁写法
SELECT * FROM users WHERE phone IS NULL;
SELECT * FROM users WHERE phone IS NOT NULL;
```

### 2.3 ISNULL在业务逻辑中的应用


**用户资料完整性检查**：
```sql
SELECT 
  user_id,
  name,
  CASE 
    WHEN ISNULL(phone) = 1 THEN '手机号缺失'
    WHEN ISNULL(email) = 1 THEN '邮箱缺失'  
    WHEN ISNULL(address) = 1 THEN '地址缺失'
    ELSE '资料完整'
  END AS profile_status
FROM users;
```

**数据质量统计**：
```sql
SELECT 
  COUNT(*) AS total_users,
  SUM(ISNULL(phone)) AS missing_phone,
  SUM(ISNULL(email)) AS missing_email,
  -- 计算完整率
  (COUNT(*) - SUM(ISNULL(phone))) / COUNT(*) * 100 AS phone_complete_rate
FROM users;
```

---

## 3. 🔧 IFNULL默认值设置函数


### 3.1 IFNULL函数基本语法


**函数定义**：
```sql
IFNULL(expression, default_value)
```

**执行逻辑**：
```
如果 expression 是 NULL → 返回 default_value
如果 expression 不是 NULL → 返回 expression 本身
```

> 💡 **通俗理解**：IFNULL就像给NULL值准备一个"备胎"，如果原值是NULL，就用备胎替代

### 3.2 IFNULL函数实际应用


**用户信息显示优化**：
```sql
SELECT 
  name,
  IFNULL(phone, '未设置') AS display_phone,
  IFNULL(email, '未设置') AS display_email,
  IFNULL(age, 0) AS display_age
FROM users;

结果示例：
┌─────────┬──────────────┬──────────────┬─────────────┐
│  name   │ display_phone│ display_email│ display_age │
├─────────┼──────────────┼──────────────┼─────────────┤
│ 张三     │ 13800138000  │ zhang@qq.com │     25      │
│ 李四     │   未设置      │   未设置      │      0      │
│ 王五     │ 13900139000  │   未设置      │     30      │
└─────────┴──────────────┴──────────────┴─────────────┘
```

**价格计算中的默认值处理**：
```sql
-- 商品价格计算，折扣为空时按原价
SELECT 
  product_name,
  original_price,
  discount_rate,
  original_price * IFNULL(discount_rate, 1.0) AS final_price
FROM products;

-- 解释：discount_rate为NULL时，用1.0替代，表示无折扣
```

### 3.3 IFNULL在不同数据类型中的应用


**字符串类型处理**：
```sql
-- 拼接用户全名，中间名可能为空
SELECT 
  CONCAT(
    first_name, 
    IFNULL(CONCAT(' ', middle_name), ''), 
    ' ', 
    last_name
  ) AS full_name
FROM users;
```

**数值类型处理**：
```sql
-- 计算订单总额，运费可能为空
SELECT 
  order_id,
  product_amount,
  IFNULL(shipping_fee, 0) AS shipping_fee,
  product_amount + IFNULL(shipping_fee, 0) AS total_amount
FROM orders;
```

**日期类型处理**：
```sql
-- 显示最后登录时间，从未登录显示注册时间
SELECT 
  username,
  register_time,
  IFNULL(last_login_time, register_time) AS display_time
FROM users;
```

---

## 4. 🔄 COALESCE多值合并函数


### 4.1 COALESCE函数基本语法


**函数定义**：
```sql
COALESCE(value1, value2, value3, ..., valueN)
```

**执行逻辑**：
```
从左到右检查每个参数
返回第一个非NULL的值
如果所有值都是NULL，返回NULL
```

> 💡 **通俗理解**：COALESCE就像排队买票，从第一个窗口开始，哪个窗口开着(不是NULL)就在哪买票

### 4.2 COALESCE与IFNULL的区别


**功能对比**：
```sql
-- IFNULL只能处理两个值
SELECT IFNULL(phone, '未设置') FROM users;

-- COALESCE可以处理多个值
SELECT COALESCE(mobile_phone, home_phone, office_phone, '未设置') FROM users;
```

**实际应用场景对比**：

┌─────────────────┬─────────────────────────┬─────────────────────────┐
│  **使用场景**   │     **IFNULL适用**      │    **COALESCE适用**     │
├─────────────────┼─────────────────────────┼─────────────────────────┤
│ 简单默认值      │ ✅ 性能好，语法简单      │ ✅ 功能相同             │
│ 多个备选值      │ ❌ 需要嵌套，复杂        │ ✅ 语法清晰，推荐       │
│ 复杂业务逻辑     │ ❌ 可读性差             │ ✅ 逻辑清晰             │
└─────────────────┴─────────────────────────┴─────────────────────────┘

### 4.3 COALESCE函数实际应用


**联系方式优先级处理**：
```sql
-- 优先显示手机号，其次座机，最后显示"无联系方式"
SELECT 
  name,
  COALESCE(mobile_phone, home_phone, office_phone, '无联系方式') AS contact
FROM users;

结果示例：
┌─────────┬──────────────────┐
│  name   │     contact      │
├─────────┼──────────────────┤
│ 张三     │   13800138000    │  ← 使用mobile_phone
│ 李四     │   021-12345678   │  ← mobile_phone为NULL，使用home_phone
│ 王五     │    无联系方式     │  ← 所有号码都为NULL
└─────────┴──────────────────┘
```

**多渠道价格选择**：
```sql
-- 选择最优价格：促销价 > 会员价 > 原价
SELECT 
  product_name,
  COALESCE(promotion_price, member_price, original_price) AS final_price,
  CASE 
    WHEN promotion_price IS NOT NULL THEN '促销价'
    WHEN member_price IS NOT NULL THEN '会员价'
    ELSE '原价'
  END AS price_type
FROM products;
```

**配置项级联查找**：
```sql
-- 配置优先级：用户配置 > 部门配置 > 系统默认配置
SELECT 
  user_id,
  config_name,
  COALESCE(user_config.value, dept_config.value, system_config.value) AS config_value
FROM users u
LEFT JOIN user_configs user_config ON u.user_id = user_config.user_id
LEFT JOIN dept_configs dept_config ON u.dept_id = dept_config.dept_id  
LEFT JOIN system_configs system_config ON 1=1;
```

### 4.4 COALESCE高级应用技巧


**动态SQL生成**：
```sql
-- 根据不同条件生成查询条件
SELECT * FROM orders 
WHERE status = COALESCE(@input_status, status)  -- 如果没有传入状态，查询所有状态
  AND create_time >= COALESCE(@start_date, '1900-01-01')
  AND create_time <= COALESCE(@end_date, '2099-12-31');
```

**数据迁移中的字段合并**：
```sql
-- 合并旧系统的多个地址字段到新系统的单个地址字段
SELECT 
  user_id,
  COALESCE(
    NULLIF(TRIM(detailed_address), ''),  -- 详细地址不为空时使用
    CONCAT(
      IFNULL(province, ''), 
      IFNULL(city, ''), 
      IFNULL(district, '')
    )  -- 否则拼接省市区
  ) AS address
FROM old_user_table;
```

---

## 5. ⚡ NULLIF条件置空函数


### 5.1 NULLIF函数基本语法


**函数定义**：
```sql
NULLIF(expression1, expression2)
```

**执行逻辑**：
```
如果 expression1 = expression2 → 返回 NULL
如果 expression1 ≠ expression2 → 返回 expression1
```

> 💡 **通俗理解**：NULLIF就像一个"过滤器"，当两个值相等时，把第一个值变成NULL

### 5.2 NULLIF函数典型应用场景


**避免除零错误**：
```sql
-- 计算平均分，避免除零
SELECT 
  student_name,
  total_score,
  subject_count,
  total_score / NULLIF(subject_count, 0) AS average_score
FROM student_scores;

-- 解释：当subject_count为0时，NULLIF返回NULL，避免了除零错误
```

**数据清理中的应用**：
```sql
-- 将空字符串转换为NULL，便于后续处理
SELECT 
  name,
  NULLIF(TRIM(phone), '') AS clean_phone,    -- 空字符串转为NULL
  NULLIF(age, 0) AS clean_age               -- 年龄为0时转为NULL
FROM users;

结果示例：
┌─────────┬──────────────┬───────────┐
│  name   │ clean_phone  │ clean_age │
├─────────┼──────────────┼───────────┤
│ 张三     │ 13800138000  │    25     │
│ 李四     │    NULL      │   NULL    │  ← 原来是空字符串和0
│ 王五     │ 13900139000  │    30     │
└─────────┴──────────────┴───────────┘
```

### 5.3 NULLIF在数据分析中的应用


**统计分析中的特殊值处理**：
```sql
-- 销售分析，排除异常数据
SELECT 
  product_id,
  AVG(NULLIF(price, -1)) AS avg_price,      -- 排除价格为-1的异常数据
  COUNT(NULLIF(quantity, 0)) AS valid_sales -- 只统计数量不为0的有效销售
FROM sales_records
GROUP BY product_id;
```

**数据质量检查**：
```sql
-- 检查必填字段的数据完整性
SELECT 
  'phone' AS field_name,
  COUNT(*) AS total_records,
  COUNT(NULLIF(TRIM(phone), '')) AS valid_records,
  COUNT(*) - COUNT(NULLIF(TRIM(phone), '')) AS invalid_records
FROM users
UNION ALL
SELECT 
  'email' AS field_name,
  COUNT(*) AS total_records,
  COUNT(NULLIF(TRIM(email), '')) AS valid_records,
  COUNT(*) - COUNT(NULLIF(TRIM(email), '')) AS invalid_records
FROM users;
```

---

## 6. 🎯 空值处理综合策略


### 6.1 空值处理函数组合使用


**多层空值处理**：
```sql
-- 复杂的用户信息显示逻辑
SELECT 
  user_id,
  name,
  -- 联系方式：手机 > 邮箱 > 地址 > 默认提示
  COALESCE(
    NULLIF(TRIM(phone), ''),           -- 手机号不为空字符串
    NULLIF(TRIM(email), ''),           -- 邮箱不为空字符串
    NULLIF(TRIM(address), ''),         -- 地址不为空字符串
    '暂无联系方式'                      -- 最终默认值
  ) AS contact_info,
  
  -- 年龄显示：有效年龄 > 默认提示
  CASE 
    WHEN age IS NULL OR age = 0 THEN '年龄未知'
    WHEN age < 0 OR age > 150 THEN '年龄异常' 
    ELSE CONCAT(age, '岁')
  END AS age_display
FROM users;
```

### 6.2 不同数据类型的空值处理策略


**字符串类型空值处理流程**：
```
原始数据 → TRIM去除空格 → NULLIF转换空字符串 → IFNULL设置默认值
    ↓              ↓                ↓               ↓
"  hello  "  →  "hello"      →    "hello"    →   "hello"
"    "      →     ""        →      NULL     →   "默认值"
 NULL       →    NULL       →      NULL     →   "默认值"
```

**数值类型空值处理流程**：
```
原始数据 → NULLIF过滤异常值 → IFNULL设置默认值 → 业务逻辑处理
    ↓              ↓                ↓               ↓
   100     →       100       →      100      →   正常处理
    -1     →       NULL      →       0       →   按默认值处理
   NULL    →       NULL      →       0       →   按默认值处理
```

### 6.3 业务场景的空值处理模式


**电商订单计算**：
```sql
-- 订单金额计算，处理各种NULL值情况
SELECT 
  order_id,
  product_price,
  quantity,
  discount_rate,
  shipping_fee,
  
  -- 商品总额 = 单价 × 数量
  IFNULL(product_price, 0) * IFNULL(quantity, 1) AS product_amount,
  
  -- 折扣后金额
  IFNULL(product_price, 0) * IFNULL(quantity, 1) * IFNULL(discount_rate, 1.0) AS discounted_amount,
  
  -- 最终总额 = 折扣后金额 + 运费
  IFNULL(product_price, 0) * IFNULL(quantity, 1) * IFNULL(discount_rate, 1.0) 
  + IFNULL(shipping_fee, 0) AS total_amount
FROM orders;
```

**用户积分系统**：
```sql
-- 用户积分计算，处理不同积分来源
SELECT 
  user_id,
  username,
  
  -- 各类积分，NULL时按0处理
  IFNULL(login_points, 0) AS login_points,
  IFNULL(purchase_points, 0) AS purchase_points, 
  IFNULL(activity_points, 0) AS activity_points,
  IFNULL(referral_points, 0) AS referral_points,
  
  -- 总积分计算
  COALESCE(login_points, 0) + COALESCE(purchase_points, 0) + 
  COALESCE(activity_points, 0) + COALESCE(referral_points, 0) AS total_points,
  
  -- 积分等级判断
  CASE 
    WHEN COALESCE(login_points, 0) + COALESCE(purchase_points, 0) + 
         COALESCE(activity_points, 0) + COALESCE(referral_points, 0) >= 10000 THEN '钻石会员'
    WHEN COALESCE(login_points, 0) + COALESCE(purchase_points, 0) + 
         COALESCE(activity_points, 0) + COALESCE(referral_points, 0) >= 5000 THEN '金牌会员'
    WHEN COALESCE(login_points, 0) + COALESCE(purchase_points, 0) + 
         COALESCE(activity_points, 0) + COALESCE(referral_points, 0) >= 1000 THEN '银牌会员'
    ELSE '普通会员'
  END AS member_level
FROM user_points;
```

---

## 7. 🧠 NULL值逻辑处理详解


### 7.1 三值逻辑系统


**三值逻辑概念**：
```
传统二值逻辑：TRUE、FALSE
SQL三值逻辑：TRUE、FALSE、UNKNOWN(NULL)
```

**逻辑运算真值表**：

┌─────────┬─────────┬─────────┬─────────┬─────────┐
│  **A**  │  **B**  │ **A AND B** │ **A OR B**  │ **NOT A** │
├─────────┼─────────┼─────────┼─────────┼─────────┤
│  TRUE   │  TRUE   │   TRUE    │   TRUE    │  FALSE  │
│  TRUE   │ FALSE   │  FALSE    │   TRUE    │  FALSE  │
│  TRUE   │  NULL   │   NULL    │   TRUE    │  FALSE  │
│ FALSE   │  TRUE   │  FALSE    │   TRUE    │  TRUE   │
│ FALSE   │ FALSE   │  FALSE    │  FALSE    │  TRUE   │
│ FALSE   │  NULL   │  FALSE    │   NULL    │  TRUE   │
│  NULL   │  TRUE   │   NULL    │   TRUE    │  NULL   │
│  NULL   │ FALSE   │  FALSE    │   NULL    │  NULL   │
│  NULL   │  NULL   │   NULL    │   NULL    │  NULL   │
└─────────┴─────────┴─────────┴─────────┴─────────┘

### 7.2 NULL值在条件判断中的表现


**WHERE子句中的NULL处理**：
```sql
-- 这些条件都不会匹配NULL值
SELECT * FROM users WHERE age = NULL;      -- 结果为空
SELECT * FROM users WHERE age <> NULL;     -- 结果为空
SELECT * FROM users WHERE age > NULL;      -- 结果为空
SELECT * FROM users WHERE NOT (age = 10);  -- 不包含age为NULL的记录

-- 正确的NULL判断方式
SELECT * FROM users WHERE age IS NULL;         -- 查找NULL值
SELECT * FROM users WHERE age IS NOT NULL;     -- 查找非NULL值
```

**复合条件中的NULL影响**：
```sql
-- 示例：查找年龄大于25或者收入高于5000的用户
SELECT * FROM users 
WHERE age > 25 OR income > 5000;

/*
分析不同情况：
1. age=30, income=6000  → TRUE OR TRUE = TRUE    ✅ 包含
2. age=20, income=6000  → FALSE OR TRUE = TRUE   ✅ 包含  
3. age=30, income=3000  → TRUE OR FALSE = TRUE   ✅ 包含
4. age=20, income=3000  → FALSE OR FALSE = FALSE ❌ 不包含
5. age=NULL, income=6000 → NULL OR TRUE = TRUE   ✅ 包含
6. age=30, income=NULL  → TRUE OR NULL = TRUE    ✅ 包含
7. age=NULL, income=NULL → NULL OR NULL = NULL   ❌ 不包含
*/
```

### 7.3 聚合函数中的NULL处理


**聚合函数对NULL的处理规则**：
```sql
-- 创建测试数据
CREATE TABLE test_scores (
  student_id INT,
  score INT
);

INSERT INTO test_scores VALUES 
(1, 85), (2, NULL), (3, 92), (4, NULL), (5, 78);

-- 聚合函数测试
SELECT 
  COUNT(*) AS total_records,           -- 结果: 5 (包含NULL)
  COUNT(score) AS non_null_scores,     -- 结果: 3 (排除NULL)
  AVG(score) AS average_score,         -- 结果: 85 (基于85,92,78计算)
  SUM(score) AS total_score,           -- 结果: 255 (NULL被忽略)
  MAX(score) AS max_score,             -- 结果: 92 (NULL被忽略)
  MIN(score) AS min_score              -- 结果: 78 (NULL被忽略)
FROM test_scores;
```

> ⚠️ **重要提醒**：大部分聚合函数会自动忽略NULL值，只有COUNT(*)会统计包含NULL的记录数

**GROUP BY中的NULL处理**：
```sql
-- NULL值会被作为一个单独的分组
SELECT 
  department,
  COUNT(*) AS employee_count,
  AVG(salary) AS avg_salary
FROM employees 
GROUP BY department;

/*
结果可能包含：
┌─────────────┬───────────────┬────────────┐
│ department  │ employee_count│ avg_salary │
├─────────────┼───────────────┼────────────┤
│ 技术部       │      10       │   8500     │
│ 销售部       │       8       │   7200     │
│ NULL        │       3       │   6800     │  ← 部门为NULL的员工
└─────────────┴───────────────┴────────────┘
*/
```

---

## 8. 🚀 空值处理最佳实践


### 8.1 数据库设计阶段的空值策略


**字段NULL性设计原则**：
```sql
-- 好的设计实践
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL,           -- 必填字段设为NOT NULL
  email VARCHAR(100),                      -- 可选字段允许NULL
  phone VARCHAR(20),                       -- 可选字段允许NULL
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- 使用默认值
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**字段默认值设置策略**：

┌─────────────────┬─────────────────┬─────────────────────┐
│  **数据类型**   │  **推荐默认值**  │     **使用场景**     │
├─────────────────┼─────────────────┼─────────────────────┤
│ 数值类型         │ 0 或 NULL       │ 根据业务逻辑决定     │
│ 字符串类型       │ '' 或 NULL      │ 空字符串vs未知状态   │
│ 日期时间类型     │ CURRENT_TIME    │ 记录创建/更新时间   │
│ 布尔类型        │ FALSE           │ 默认关闭状态        │
│ 枚举类型        │ 第一个值         │ 默认选项            │
└─────────────────┴─────────────────┴─────────────────────┘

### 8.2 应用层空值处理策略


**输入数据预处理**：
```sql
-- 插入数据前的空值预处理
INSERT INTO users (username, email, phone, age) 
VALUES (
  'testuser',
  NULLIF(TRIM(@email), ''),        -- 空字符串转为NULL
  NULLIF(TRIM(@phone), ''),        -- 空字符串转为NULL  
  NULLIF(@age, 0)                  -- 0转为NULL
);
```

**查询结果后处理**：
```sql
-- 为前端提供友好的数据格式
SELECT 
  id,
  username,
  IFNULL(email, '') AS email,              -- NULL转为空字符串
  IFNULL(phone, '') AS phone,              -- NULL转为空字符串
  IFNULL(age, 0) AS age,                   -- NULL转为0
  IFNULL(avatar_url, '/default.jpg') AS avatar_url
FROM users;
```

### 8.3 性能优化的空值处理


**索引设计考虑**：
```sql
-- 为经常查询的NULL值字段创建合适的索引
CREATE INDEX idx_users_phone ON users(phone);  -- 包含NULL值的索引
CREATE INDEX idx_users_active ON users(is_active) WHERE is_active IS NOT NULL;  -- 部分索引排除NULL
```

**查询优化技巧**：
```sql
-- 避免复杂的空值处理影响性能
-- 不推荐：复杂的嵌套函数
SELECT * FROM users 
WHERE COALESCE(NULLIF(TRIM(phone), ''), email, username) LIKE '%search%';

-- 推荐：简化查询逻辑
SELECT * FROM users 
WHERE (phone IS NOT NULL AND phone LIKE '%search%')
   OR (phone IS NULL AND email LIKE '%search%')
   OR (phone IS NULL AND email IS NULL AND username LIKE '%search%');
```

### 8.4 数据迁移中的空值处理


**旧系统数据清理**：
```sql
-- 数据迁移时的空值标准化
UPDATE users SET 
  phone = NULL WHERE phone IN ('', 'NULL', 'null', 'undefined'),
  email = NULL WHERE email IN ('', 'NULL', 'null', 'undefined'),
  age = NULL WHERE age IN (0, -1, 999);

-- 数据一致性检查
SELECT 
  'phone' AS field_name,
  COUNT(CASE WHEN phone = '' THEN 1 END) AS empty_string_count,
  COUNT(CASE WHEN phone IS NULL THEN 1 END) AS null_count,
  COUNT(CASE WHEN phone REGEXP '^[0-9]{11}$' THEN 1 END) AS valid_phone_count
FROM users;
```

---

## 9. ⚡ 性能优化考虑


### 9.1 空值处理函数的性能特点


**函数执行效率对比**：

┌─────────────────┬─────────────────┬─────────────────┐
│   **函数名**    │   **执行效率**   │   **使用建议**   │
├─────────────────┼─────────────────┼─────────────────┤
│ ISNULL()        │    最快         │ 简单判断首选     │
│ IFNULL()        │    较快         │ 两值选择推荐     │
│ COALESCE()      │    较慢         │ 多值选择时使用   │
│ NULLIF()        │    中等         │ 特定场景使用     │
│ CASE WHEN       │    最慢         │ 复杂逻辑使用     │
└─────────────────┴─────────────────┴─────────────────┘

**性能测试示例**：
```sql
-- 测试不同函数的执行效率（基于100万条记录）
-- 方案1：使用IFNULL（推荐）
SELECT COUNT(*) FROM users WHERE IFNULL(age, 0) > 18;
-- 执行时间：约 0.8秒

-- 方案2：使用COALESCE 
SELECT COUNT(*) FROM users WHERE COALESCE(age, 0) > 18;  
-- 执行时间：约 1.2秒

-- 方案3：使用CASE WHEN
SELECT COUNT(*) FROM users 
WHERE CASE WHEN age IS NULL THEN 0 ELSE age END > 18;
-- 执行时间：约 1.8秒

-- 方案4：使用IS NULL判断（最快）
SELECT COUNT(*) FROM users WHERE age IS NOT NULL AND age > 18;
-- 执行时间：约 0.5秒
```

### 9.2 索引与空值的关系


**NULL值对索引的影响**：
```sql
-- NULL值在不同索引类型中的表现
CREATE TABLE test_index (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  age INT,
  status ENUM('active', 'inactive'),
  INDEX idx_name (name),           -- 普通索引包含NULL
  INDEX idx_age (age),             -- 数值索引包含NULL
  UNIQUE INDEX idx_email (email)   -- 唯一索引允许多个NULL
);

-- 查询性能分析
EXPLAIN SELECT * FROM test_index WHERE name IS NULL;     -- 能使用索引
EXPLAIN SELECT * FROM test_index WHERE name IS NOT NULL; -- 能使用索引
EXPLAIN SELECT * FROM test_index WHERE IFNULL(name, '') = ''; -- 不能使用索引！
```

> ⚠️ **性能陷阱**：在索引字段上使用函数（如IFNULL）会导致索引失效！

**索引优化策略**：
```sql
-- 不推荐：函数导致索引失效
SELECT * FROM users WHERE IFNULL(status, 'inactive') = 'active';

-- 推荐：分离NULL判断保持索引有效
SELECT * FROM users WHERE status = 'active' OR (status IS NULL);

-- 或者使用部分索引（MySQL 8.0+）
CREATE INDEX idx_users_active_status ON users(status) WHERE status IS NOT NULL;
```

### 9.3 大数据量下的空值处理优化


**批量数据处理优化**：
```sql
-- 大表空值统计优化
-- 不推荐：全表扫描
SELECT COUNT(CASE WHEN phone IS NULL THEN 1 END) AS null_phone_count FROM big_table;

-- 推荐：使用统计表维护空值统计
CREATE TABLE data_quality_stats (
  table_name VARCHAR(50),
  column_name VARCHAR(50), 
  null_count INT,
  total_count INT,
  last_updated TIMESTAMP,
  PRIMARY KEY (table_name, column_name)
);

-- 定期更新统计信息
INSERT INTO data_quality_stats 
SELECT 'users' AS table_name, 'phone' AS column_name,
       SUM(CASE WHEN phone IS NULL THEN 1 ELSE 0 END) AS null_count,
       COUNT(*) AS total_count,
       NOW() AS last_updated
FROM users
ON DUPLICATE KEY UPDATE 
  null_count = VALUES(null_count),
  total_count = VALUES(total_count),
  last_updated = VALUES(last_updated);
```

**内存使用优化**：
```sql
-- 大结果集的空值处理优化
-- 不推荐：复杂的COALESCE嵌套
SELECT id, COALESCE(
  CONCAT(first_name, ' ', middle_name, ' ', last_name),
  CONCAT(first_name, ' ', last_name),
  first_name,
  '匿名用户'
) AS display_name FROM big_table;

-- 推荐：简化逻辑，提前过滤
SELECT id, 
  CASE 
    WHEN first_name IS NULL THEN '匿名用户'
    WHEN middle_name IS NULL THEN CONCAT(first_name, ' ', last_name)
    ELSE CONCAT(first_name, ' ', middle_name, ' ', last_name)
  END AS display_name 
FROM big_table
WHERE first_name IS NOT NULL OR id IN (SELECT id FROM vip_users);
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 NULL的本质：表示未知、缺失或不适用的数据，不等于0或空字符串
🔸 三值逻辑：SQL中存在TRUE、FALSE、NULL三种逻辑值
🔸 NULL比较：任何值与NULL比较都返回NULL，必须使用IS NULL判断
🔸 聚合函数：大多数聚合函数自动忽略NULL值
🔸 索引影响：NULL值包含在索引中，函数处理会导致索引失效
```

### 10.2 四大空值处理函数对比


┌─────────────┬─────────────────┬─────────────────┬─────────────────┐
│ **函数名**  │  **主要功能**   │  **适用场景**   │  **性能特点**   │
├─────────────┼─────────────────┼─────────────────┼─────────────────┤
│ ISNULL()    │ 检测是否为NULL   │ 条件判断        │ 执行最快        │
│ IFNULL()    │ NULL时返回默认值 │ 简单替换        │ 性能较好        │
│ COALESCE()  │ 返回首个非NULL值 │ 多选项处理      │ 功能最强        │
│ NULLIF()    │ 相等时返回NULL   │ 数据清理        │ 特定用途        │
└─────────────┴─────────────────┴─────────────────┴─────────────────┘

### 10.3 实际应用指导原则


**🔹 选择合适的函数**
```
简单默认值 → IFNULL()
多个备选值 → COALESCE()  
条件判断 → ISNULL() 或 IS NULL
数据清理 → NULLIF()
复杂逻辑 → CASE WHEN
```

**🔹 性能优化建议**
```
索引字段避免使用函数处理
大数据量时使用IS NULL而非函数判断
批量处理时考虑预处理空值
合理设置字段默认值减少NULL处理
```

**🔹 业务设计建议**
```
数据库设计：区分必填和可选字段
应用层处理：输入验证和输出格式化
数据迁移：标准化空值表示方式
监控统计：定期检查数据质量
```

### 10.4 常见陷阱与解决方案


**❌ 常见错误**：
- 使用 = NULL 进行空值判断
- 忽略NULL对聚合函数的影响  
- 在索引字段上使用空值处理函数
- 混淆NULL、空字符串和0的概念

**✅ 正确做法**：
- 使用 IS NULL 进行空值判断
- 理解聚合函数对NULL的处理规则
- 优先使用条件判断而非函数处理
- 明确区分不同类型的"空"值

### 10.5 实战应用价值


- **数据展示**：为前端提供友好的数据格式
- **业务计算**：确保数值计算的准确性
- **数据分析**：正确处理缺失数据对统计的影响
- **系统集成**：统一不同系统间的空值表示
- **性能优化**：避免不必要的函数调用开销

**核心记忆口诀**：
```
NULL不是零来不是空，三值逻辑要记清
IS NULL判断是正道，函数处理需谨慎
IFNULL简单COALESCE强，NULLIF清理有专长
索引字段别用函数，性能优化是关键
```