---
title: 1、字符串函数
---
## 📚 目录

1. [MySQL函数系统概览](#1-MySQL函数系统概览)
2. [字符串连接函数](#2-字符串连接函数)
3. [字符串截取函数](#3-字符串截取函数)
4. [长度计算函数](#4-长度计算函数)
5. [字符串查找与定位](#5-字符串查找与定位)
6. [字符串替换与修改](#6-字符串替换与修改)
7. [大小写转换函数](#7-大小写转换函数)
8. [空格处理函数](#8-空格处理函数)
9. [字符串比较函数](#9-字符串比较函数)
10. [字符串聚合函数](#10-字符串聚合函数)
11. [性能优化与最佳实践](#11-性能优化与最佳实践)
12. [核心要点总结](#12-核心要点总结)

---

## 1. 🗂️ MySQL函数系统概览


### 1.1 函数系统架构


MySQL函数就像工具箱里的各种工具，每个都有特定用途。字符串函数专门处理文本数据。

**🔸 MySQL函数系统架构**

```
MySQL函数体系
├── 字符串函数
│   ├── 连接函数 (CONCAT, CONCAT_WS)
│   ├── 截取函数 (SUBSTRING, LEFT, RIGHT)
│   ├── 长度函数 (LENGTH, CHAR_LENGTH)
│   ├── 查找函数 (LOCATE, POSITION)
│   ├── 替换函数 (REPLACE, INSERT)
│   ├── 大小写函数 (UPPER, LOWER)
│   ├── 空格处理 (TRIM, LTRIM, RTRIM)
│   └── 聚合函数 (GROUP_CONCAT)
├── 数值函数
│   ├── 数学运算 (ABS, ROUND, CEIL)
│   └── 统计函数 (SUM, AVG, COUNT)
├── 日期函数
│   ├── 获取日期 (NOW, CURDATE)
│   └── 格式化 (DATE_FORMAT)
└── 条件函数
    ├── 逻辑判断 (IF, CASE)
    └── 空值处理 (IFNULL, COALESCE)
```

### 1.2 🔸 函数分类体系


| 函数类别 | **主要功能** | **常用函数** | **使用频率** |
|---------|-------------|-------------|-------------|
| 🔗 **连接合并** | `文本拼接组合` | `CONCAT, CONCAT_WS` | `🔥高频` |
| ✂️ **截取提取** | `字符串切分` | `SUBSTRING, LEFT, RIGHT` | `🔥高频` |
| 📏 **长度计算** | `字符串度量` | `LENGTH, CHAR_LENGTH` | `⭐常用` |
| 🔍 **查找定位** | `字符位置查找` | `LOCATE, POSITION` | `⭐常用` |
| 🔄 **替换修改** | `内容替换更新` | `REPLACE, INSERT` | `⭐常用` |
| 📝 **格式转换** | `大小写空格处理` | `UPPER, LOWER, TRIM` | `⭐常用` |
| 📊 **聚合处理** | `多行数据合并` | `GROUP_CONCAT` | `💡实用` |

### 1.3 🔸 函数使用场景概述


**字符串函数的实际应用场景**：
- ✅ **数据清洗**：去除多余空格、统一大小写格式
- ✅ **报表展示**：拼接用户姓名、格式化显示信息
- ✅ **数据查询**：模糊搜索、字符串匹配查找
- ✅ **数据转换**：字段拆分合并、格式标准化
- ✅ **业务逻辑**：字符串处理、内容替换修改

---

## 2. 🔗 字符串连接函数


### 2.1 CONCAT连接函数基础


**CONCAT**函数就像胶水，把多个字符串粘在一起变成一个。

**基本语法**：
```sql
CONCAT(string1, string2, ..., stringN)
```

**基础示例**：
```sql
-- 简单字符串连接
SELECT CONCAT('Hello', ' ', 'World') AS result;
-- 结果: Hello World

-- 连接数据库字段
SELECT 
    CONCAT(first_name, ' ', last_name) AS full_name
FROM users;
-- 结果: 张 三, 李 四

-- 多个字段连接
SELECT 
    CONCAT('用户: ', username, ', 年龄: ', age, '岁') AS user_info
FROM users;
-- 结果: 用户: zhangsan, 年龄: 25岁
```

**⚠️ CONCAT函数注意事项**：
```sql
-- 如果任何一个参数为NULL，整个结果为NULL
SELECT CONCAT('Hello', NULL, 'World') AS result;
-- 结果: NULL

-- 数字会自动转换为字符串
SELECT CONCAT('订单号: ', 12345) AS result;
-- 结果: 订单号: 12345
```

### 2.2 🔥 CONCAT_WS分隔符连接


**CONCAT_WS**比CONCAT更智能，WS表示"With Separator"（带分隔符），它会自动在字符串之间添加分隔符。

**基本语法**：
```sql
CONCAT_WS(separator, string1, string2, ..., stringN)
```

**⭐ CONCAT/CONCAT_WS字符串连接对比**：

| 特性 | **CONCAT** | **CONCAT_WS** |
|------|-----------|---------------|
| **分隔符** | `需手动添加` | `自动添加统一分隔符` |
| **NULL处理** | `遇NULL返回NULL` | `忽略NULL值继续处理` |
| **使用复杂度** | `🟡中等` | `🟢简单` |
| **适用场景** | `简单拼接` | `格式化输出，批量处理` |

**实战示例对比**：
```sql
-- 传统CONCAT方式
SELECT 
    CONCAT(city, '-', district, '-', street) AS address
FROM addresses 
WHERE city IS NOT NULL AND district IS NOT NULL AND street IS NOT NULL;

-- CONCAT_WS方式（推荐）
SELECT 
    CONCAT_WS('-', city, district, street) AS address
FROM addresses;
-- 自动忽略NULL字段，结果更稳定
```

**CONCAT_WS实用场景**：
```sql
-- 1️⃣ 生成完整地址
SELECT 
    CONCAT_WS(' ', province, city, district, street, detail) AS full_address
FROM user_addresses;

-- 2️⃣ 格式化用户信息
SELECT 
    CONCAT_WS(' | ', 
        CONCAT('姓名:', name),
        CONCAT('电话:', phone), 
        CONCAT('邮箱:', email)
    ) AS contact_info
FROM users;

-- 3️⃣ 生成CSV格式数据
SELECT 
    CONCAT_WS(',', id, name, age, city) AS csv_line
FROM users;
```

---

## 3. ✂️ 字符串截取函数


### 3.1 SUBSTRING子串函数


**SUBSTRING**函数用于提取字符串的一部分，就像用剪刀剪纸一样精确。

**基本语法**：
```sql
SUBSTRING(string, start, length)
SUBSTRING(string FROM start FOR length)
```

**基础用法示例**：
```sql
-- 从指定位置开始截取
SELECT SUBSTRING('Hello World', 7, 5) AS result;
-- 结果: World

SELECT SUBSTRING('Hello World', 7) AS result;
-- 结果: World (从位置7到结尾)

-- 使用FROM...FOR语法
SELECT SUBSTRING('Hello World' FROM 1 FOR 5) AS result;  
-- 结果: Hello
```

**实际应用场景**：
```sql
-- 提取身份证号的生日部分
SELECT 
    id_card,
    CONCAT(
        SUBSTRING(id_card, 7, 4), '-',
        SUBSTRING(id_card, 11, 2), '-', 
        SUBSTRING(id_card, 13, 2)
    ) AS birthday
FROM users
WHERE LENGTH(id_card) = 18;

-- 提取手机号前三位（运营商识别）
SELECT 
    phone,
    SUBSTRING(phone, 1, 3) AS carrier_code
FROM users;
```

### 3.2 🔥 LEFT/RIGHT字符串截取


**LEFT/RIGHT**函数专门从字符串的左边或右边开始截取，使用更直观简单。

**⭐ SUBSTRING/LEFT/RIGHT字符串截取对比**：

| 函数 | **截取方向** | **灵活性** | **易用性** | **适用场景** |
|------|-------------|-----------|-----------|-------------|
| **LEFT** | `从左开始` | `🟡有限` | `🟢简单` | `固定长度前缀提取` |
| **RIGHT** | `从右开始` | `🟡有限` | `🟢简单` | `固定长度后缀提取` |
| **SUBSTRING** | `任意位置` | `🟢高` | `🟡中等` | `灵活的中间段提取` |

**LEFT/RIGHT基础语法**：
```sql
LEFT(string, length)   -- 从左边开始取length个字符
RIGHT(string, length)  -- 从右边开始取length个字符
```

**实战示例**：
```sql
-- 1️⃣ 提取姓氏（中文名通常姓氏1-2个字符）
SELECT 
    name,
    LEFT(name, 1) AS surname_1,
    LEFT(name, 2) AS surname_2
FROM users;

-- 2️⃣ 提取文件扩展名
SELECT 
    filename,
    RIGHT(filename, 4) AS extension
FROM files
WHERE filename LIKE '%.%';

-- 3️⃣ 银行卡号脱敏显示
SELECT 
    card_number,
    CONCAT(
        LEFT(card_number, 4), 
        ' **** **** ',
        RIGHT(card_number, 4)
    ) AS masked_card
FROM bank_cards;
-- 结果: 6212 **** **** 1234

-- 4️⃣ 订单号规则提取
SELECT 
    order_no,
    LEFT(order_no, 8) AS date_part,      -- 订单日期部分
    RIGHT(order_no, 6) AS sequence_part  -- 序号部分
FROM orders;
```

**截取函数组合使用**：
```sql
-- 复杂的字符串解析：提取邮箱用户名和域名
SELECT 
    email,
    LEFT(email, LOCATE('@', email) - 1) AS username,
    SUBSTRING(email, LOCATE('@', email) + 1) AS domain
FROM users;
```

---

## 4. 📏 长度计算函数


### 4.1 LENGTH长度函数


**LENGTH**函数计算字符串的字节长度，不同字符编码占用的字节数不同。

**基本语法**：
```sql
LENGTH(string)
```

**基础示例**：
```sql
-- 英文字符长度（UTF8下每个字符1字节）
SELECT LENGTH('Hello') AS byte_length;
-- 结果: 5

-- 中文字符长度（UTF8下每个中文3字节）
SELECT LENGTH('你好') AS byte_length;
-- 结果: 6
```

### 4.2 🔥 CHAR_LENGTH字符长度


**CHAR_LENGTH**函数计算字符串的字符个数，不管字符编码如何，每个字符都算1个。

**⭐ LENGTH/CHAR_LENGTH长度函数差异**：

| 函数 | **计算单位** | **中文字符** | **英文字符** | **使用场景** |
|------|-------------|-------------|-------------|-------------|
| **LENGTH** | `字节数` | `3字节/字符` | `1字节/字符` | `存储空间计算` |
| **CHAR_LENGTH** | `字符数` | `1字符` | `1字符` | `用户体验，字符限制` |

**对比示例**：
```sql
SELECT 
    'Hello你好' AS text,
    LENGTH('Hello你好') AS byte_length,        -- 11 (5+6)
    CHAR_LENGTH('Hello你好') AS char_length;   -- 7 (5+2)

-- 实际应用：检查用户输入长度限制
SELECT 
    username,
    CHAR_LENGTH(username) AS char_count,
    CASE 
        WHEN CHAR_LENGTH(username) > 20 THEN '用户名过长'
        WHEN CHAR_LENGTH(username) < 2 THEN '用户名过短'
        ELSE '长度合适'
    END AS length_check
FROM users;
```

**实用场景**：
```sql
-- 1️⃣ 数据质量检查
SELECT 
    COUNT(*) AS total,
    COUNT(CASE WHEN CHAR_LENGTH(name) = 0 THEN 1 END) AS empty_names,
    COUNT(CASE WHEN CHAR_LENGTH(name) > 50 THEN 1 END) AS long_names
FROM users;

-- 2️⃣ 字符串截断处理
SELECT 
    title,
    CASE 
        WHEN CHAR_LENGTH(title) > 20 THEN 
            CONCAT(LEFT(title, 17), '...')
        ELSE title
    END AS display_title
FROM articles;

-- 3️⃣ 存储空间预估
SELECT 
    content,
    LENGTH(content) AS storage_bytes,
    ROUND(LENGTH(content) / 1024, 2) AS storage_kb
FROM posts;
```

---

## 5. 🔍 字符串查找与定位


### 5.1 🔥 LOCATE/POSITION字符位置


**LOCATE**和**POSITION**函数用于查找子字符串在主字符串中的位置，就像在书中找特定内容一样。

**⭐ LOCATE/POSITION字符查找函数对比**：

| 函数 | **语法风格** | **功能** | **返回值** | **推荐使用** |
|------|-------------|---------|-----------|-------------|
| **LOCATE** | `MySQL风格` | `查找子串位置` | `位置数字(1开始)` | `🟢推荐` |
| **POSITION** | `标准SQL` | `查找子串位置` | `位置数字(1开始)` | `🟡兼容性好` |

**基本语法**：
```sql
LOCATE(substring, string)              -- 查找substring在string中的位置
LOCATE(substring, string, start_pos)   -- 从start_pos开始查找
POSITION(substring IN string)          -- 标准SQL语法
```

**基础示例**：
```sql
-- 查找字符位置
SELECT LOCATE('@', 'user@example.com') AS at_position;
-- 结果: 5

SELECT POSITION('@' IN 'user@example.com') AS at_position;  
-- 结果: 5

-- 从指定位置开始查找
SELECT LOCATE('o', 'Hello World', 5) AS second_o;
-- 结果: 8 (找到第二个'o')

-- 找不到时返回0
SELECT LOCATE('xyz', 'Hello World') AS not_found;
-- 结果: 0
```

**实际应用场景**：
```sql
-- 1️⃣ 邮箱格式验证
SELECT 
    email,
    CASE 
        WHEN LOCATE('@', email) > 1 
         AND LOCATE('.', email, LOCATE('@', email)) > LOCATE('@', email)
        THEN '格式正确'
        ELSE '格式错误'
    END AS email_check
FROM users;

-- 2️⃣ URL域名提取
SELECT 
    url,
    SUBSTRING(
        url, 
        LOCATE('://', url) + 3,
        LOCATE('/', url, LOCATE('://', url) + 3) - LOCATE('://', url) - 3
    ) AS domain
FROM websites;

-- 3️⃣ 文件路径解析
SELECT 
    filepath,
    SUBSTRING(filepath, LOCATE('/', filepath) + 1) AS filename,
    LEFT(filepath, LOCATE('/', filepath) - 1) AS directory
FROM files;

-- 4️⃣ 数据清洗：查找特殊字符
SELECT 
    content,
    LOCATE('&', content) AS has_ampersand,
    LOCATE('<', content) AS has_less_than
FROM user_posts
WHERE LOCATE('&', content) > 0 OR LOCATE('<', content) > 0;
```

### 5.2 字符串搜索高级技巧


```sql
-- 统计字符出现次数
SELECT 
    text,
    (CHAR_LENGTH(text) - CHAR_LENGTH(REPLACE(text, 'a', ''))) AS count_a
FROM test_data;

-- 查找多个关键词
SELECT 
    title,
    CASE 
        WHEN LOCATE('MySQL', title) > 0 THEN 'MySQL相关'
        WHEN LOCATE('Oracle', title) > 0 THEN 'Oracle相关'  
        WHEN LOCATE('PostgreSQL', title) > 0 THEN 'PostgreSQL相关'
        ELSE '其他'
    END AS db_type
FROM articles;
```

---

## 6. 🔄 字符串替换与修改


### 6.1 REPLACE替换函数


**REPLACE**函数用于替换字符串中的指定内容，就像文档的查找替换功能。

**基本语法**：
```sql
REPLACE(string, old_substring, new_substring)
```

**基础示例**：
```sql
-- 简单替换
SELECT REPLACE('Hello World', 'World', 'MySQL') AS result;
-- 结果: Hello MySQL

-- 替换多个相同字符
SELECT REPLACE('aaa-bbb-ccc', '-', '_') AS result;
-- 结果: aaa_bbb_ccc

-- 删除指定字符（替换为空字符串）
SELECT REPLACE('Hello World!', '!', '') AS result;
-- 结果: Hello World
```

**实际应用场景**：
```sql
-- 1️⃣ 数据清洗：统一格式
UPDATE users 
SET phone = REPLACE(REPLACE(REPLACE(phone, ' ', ''), '-', ''), '(', '')
WHERE phone IS NOT NULL;

-- 2️⃣ 敏感词过滤
SELECT 
    content,
    REPLACE(
        REPLACE(
            REPLACE(content, '敏感词1', '***'),
            '敏感词2', '***'
        ),
        '敏感词3', '***'
    ) AS filtered_content
FROM posts;

-- 3️⃣ URL路径标准化
SELECT 
    url,
    REPLACE(url, '//', '/') AS normalized_url
FROM links;

-- 4️⃣ 数据脱敏
SELECT 
    name,
    REPLACE(name, SUBSTRING(name, 2, CHAR_LENGTH(name)-2), 
            REPEAT('*', CHAR_LENGTH(name)-2)) AS masked_name
FROM users;
```

### 6.2 ⭐ REPLACE/INSERT字符串替换


**INSERT**函数可以在指定位置插入或替换字符串。

**基本语法**：
```sql
INSERT(string, position, length, new_string)
```

**REPLACE vs INSERT对比**：

| 函数 | **替换方式** | **精确性** | **适用场景** |
|------|-------------|-----------|-------------|
| **REPLACE** | `内容匹配替换` | `🟡模糊替换` | `批量内容替换` |
| **INSERT** | `位置精确替换` | `🟢精确替换` | `固定位置修改` |

**INSERT示例**：
```sql
-- 在指定位置插入内容
SELECT INSERT('Hello World', 7, 0, 'Beautiful ') AS result;
-- 结果: Hello Beautiful World

-- 替换指定位置的内容
SELECT INSERT('Hello World', 7, 5, 'MySQL') AS result;  
-- 结果: Hello MySQL

-- 实际应用：银行卡号部分替换
SELECT 
    card_number,
    INSERT(card_number, 5, 8, '********') AS masked_card
FROM bank_cards;
```

---

## 7. 📝 大小写转换函数


### 7.1 UPPER/LOWER大小写转换


大小写转换函数用于统一字符格式，就像调整文字的字体样式。

**基本语法**：
```sql
UPPER(string)  -- 转换为大写
LOWER(string)  -- 转换为小写
```

**基础示例**：
```sql
-- 大小写转换
SELECT 
    'Hello World' AS original,
    UPPER('Hello World') AS upper_case,   -- HELLO WORLD
    LOWER('Hello World') AS lower_case;   -- hello world
```

**实际应用场景**：
```sql
-- 1️⃣ 数据标准化
UPDATE products 
SET category = UPPER(category)
WHERE category IS NOT NULL;

-- 2️⃣ 不区分大小写查询
SELECT * FROM users 
WHERE LOWER(email) = LOWER('User@Example.COM');

-- 3️⃣ 用户名格式统一
SELECT 
    username,
    LOWER(username) AS normalized_username
FROM users;

-- 4️⃣ 首字母大写处理
SELECT 
    name,
    CONCAT(
        UPPER(LEFT(name, 1)), 
        LOWER(SUBSTRING(name, 2))
    ) AS capitalized_name
FROM users;
```

---

## 8. 🧹 空格处理函数


### 8.1 ⭐ TRIM/LTRIM/RTRIM空格处理


空格处理函数用于清理字符串两端或指定位置的空格和特殊字符。

**⭐ TRIM/LTRIM/RTRIM空格处理对比**：

| 函数 | **处理位置** | **处理字符** | **使用场景** |
|------|-------------|-------------|-------------|
| **TRIM** | `两端` | `空格和指定字符` | `🟢通用清理` |
| **LTRIM** | `左端` | `空格` | `左侧空格清理` |
| **RTRIM** | `右端` | `空格` | `右侧空格清理` |

**基本语法**：
```sql
TRIM([BOTH | LEADING | TRAILING] [remove_str] FROM string)
LTRIM(string)
RTRIM(string)
```

**基础示例**：
```sql
-- 去除两端空格
SELECT TRIM('  Hello World  ') AS trimmed;
-- 结果: 'Hello World'

-- 去除左侧空格
SELECT LTRIM('  Hello World  ') AS left_trimmed;
-- 结果: 'Hello World  '

-- 去除右侧空格  
SELECT RTRIM('  Hello World  ') AS right_trimmed;
-- 结果: '  Hello World'

-- 去除指定字符
SELECT TRIM('x' FROM 'xxxHello Worldxxx') AS custom_trim;
-- 结果: 'Hello World'
```

**实际应用场景**：
```sql
-- 1️⃣ 数据导入清洗
UPDATE imported_data 
SET 
    name = TRIM(name),
    address = TRIM(address),
    phone = TRIM(phone);

-- 2️⃣ 用户输入验证
SELECT 
    input_data,
    CASE 
        WHEN LENGTH(TRIM(input_data)) = 0 THEN '输入为空'
        WHEN LENGTH(TRIM(input_data)) != LENGTH(input_data) THEN '包含多余空格'
        ELSE '格式正确'
    END AS validation_result
FROM user_inputs;

-- 3️⃣ CSV数据处理
SELECT 
    TRIM(SUBSTRING_INDEX(csv_line, ',', 1)) AS field1,
    TRIM(SUBSTRING_INDEX(SUBSTRING_INDEX(csv_line, ',', 2), ',', -1)) AS field2
FROM csv_data;

-- 4️⃣ 去除特殊字符
SELECT 
    content,
    TRIM(BOTH '\r\n' FROM content) AS cleaned_content
FROM text_data;
```

---

## 9. 📊 字符串比较函数


### 9.1 字符串比较操作


MySQL提供多种字符串比较方式，适应不同的比较需求。

**基本比较操作符**：
```sql
-- 精确匹配
SELECT * FROM users WHERE name = '张三';

-- 不区分大小写比较
SELECT * FROM users WHERE name COLLATE utf8_general_ci = 'ZHANGSAN';

-- 模糊匹配
SELECT * FROM users WHERE name LIKE '张%';
SELECT * FROM users WHERE name LIKE '%san%';

-- 正则表达式匹配
SELECT * FROM users WHERE email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
```

**字符串比较函数**：
```sql
-- STRCMP字符串比较
SELECT STRCMP('abc', 'abd') AS result;  -- -1 (第一个字符串小)
SELECT STRCMP('abc', 'abc') AS result;  -- 0  (相等)
SELECT STRCMP('abd', 'abc') AS result;  -- 1  (第一个字符串大)

-- 实际应用：排序规则
SELECT 
    name,
    CASE STRCMP(name, '李四')
        WHEN -1 THEN '在李四之前'
        WHEN 0 THEN '就是李四'
        WHEN 1 THEN '在李四之后'
    END AS position_relative_to_lisi
FROM users
ORDER BY name;
```

---

## 10. 📈 字符串聚合函数


### 10.1 字符串聚合GROUP_CONCAT


**GROUP_CONCAT**函数可以将多行数据合并成一个字符串，在分组查询中特别有用。

**基本语法**：
```sql
GROUP_CONCAT([DISTINCT] expr [ORDER BY order_expr] [SEPARATOR str_val])
```

**基础示例**：
```sql
-- 基本聚合
SELECT 
    department,
    GROUP_CONCAT(name) AS employees
FROM employees
GROUP BY department;
-- 结果: '张三,李四,王五'

-- 使用分隔符
SELECT 
    department,
    GROUP_CONCAT(name SEPARATOR ' | ') AS employees
FROM employees  
GROUP BY department;
-- 结果: '张三 | 李四 | 王五'

-- 去重和排序
SELECT 
    department,
    GROUP_CONCAT(DISTINCT position ORDER BY position SEPARATOR ', ') AS positions
FROM employees
GROUP BY department;
```

**实际应用场景**：
```sql
-- 1️⃣ 用户标签聚合
SELECT 
    user_id,
    GROUP_CONCAT(tag_name SEPARATOR ', ') AS user_tags
FROM user_tags ut
JOIN tags t ON ut.tag_id = t.id
GROUP BY user_id;

-- 2️⃣ 订单商品列表
SELECT 
    order_id,
    GROUP_CONCAT(
        CONCAT(product_name, '(', quantity, ')')
        ORDER BY product_name 
        SEPARATOR '; '
    ) AS order_items
FROM order_items oi
JOIN products p ON oi.product_id = p.id
GROUP BY order_id;

-- 3️⃣ 权限列表生成
SELECT 
    user_id,
    GROUP_CONCAT(
        DISTINCT permission_name 
        ORDER BY permission_name
        SEPARATOR '|'
    ) AS permissions
FROM user_permissions up
JOIN permissions p ON up.permission_id = p.id
GROUP BY user_id;

-- 4️⃣ 数据导出格式化
SELECT 
    category,
    COUNT(*) AS product_count,
    GROUP_CONCAT(
        CONCAT(product_name, '(¥', price, ')') 
        ORDER BY price DESC
        SEPARATOR '\n'
    ) AS product_list
FROM products
GROUP BY category;
```

**GROUP_CONCAT配置优化**：
```sql
-- 查看当前长度限制
SHOW VARIABLES LIKE 'group_concat_max_len';

-- 临时调整长度限制
SET SESSION group_concat_max_len = 10000;

-- 全局调整（需要重启）
SET GLOBAL group_concat_max_len = 10000;
```

---

## 11. ⚡ 性能优化与最佳实践


### 11.1 🔑 字符串函数性能优化技巧


**性能优化原则**：

```
性能优化金字塔：
├── 索引优化 (最重要)
│   ├── 避免在WHERE子句中使用函数
│   ├── 使用前缀索引处理长字符串
│   └── 考虑函数索引 (MySQL 8.0+)
├── 函数选择优化
│   ├── 选择最高效的函数
│   ├── 避免重复计算
│   └── 合理使用正则表达式
└── 查询结构优化
    ├── 减少字符串函数嵌套
    ├── 批量处理优于单条处理
    └── 合理使用临时表
```

**性能对比测试**：
```sql
-- ❌ 性能差：在WHERE中使用函数
SELECT * FROM users WHERE UPPER(name) = 'ZHANG SAN';

-- ✅ 性能好：标准化数据存储
-- 存储时统一为大写，查询时直接比较
SELECT * FROM users WHERE name = 'ZHANG SAN';

-- ❌ 性能差：复杂字符串处理
SELECT 
    id,
    REPLACE(REPLACE(REPLACE(content, 'a', 'A'), 'b', 'B'), 'c', 'C')
FROM posts;

-- ✅ 性能好：批量处理
UPDATE posts 
SET content = REPLACE(REPLACE(REPLACE(content, 'a', 'A'), 'b', 'B'), 'c', 'C')
WHERE content REGEXP '[abc]';
```

### 11.2 🔑 字符串处理最佳实践


**最佳实践清单**：

✅ **数据存储优化**：
```sql
-- 1️⃣ 存储时标准化数据
CREATE TRIGGER user_insert_trigger 
BEFORE INSERT ON users
FOR EACH ROW
SET NEW.email = LOWER(TRIM(NEW.email)),
    NEW.phone = REPLACE(REPLACE(NEW.phone, '-', ''), ' ', '');

-- 2️⃣ 使用合适的字符集和排序规则
CREATE TABLE users (
    name VARCHAR(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
    email VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci
);
```

✅ **查询优化**：
```sql
-- 3️⃣ 使用UNION而不是OR进行多条件字符串查询
SELECT * FROM products WHERE name LIKE 'iPhone%'
UNION
SELECT * FROM products WHERE name LIKE 'iPad%';

-- 4️⃣ 利用覆盖索引减少回表
CREATE INDEX idx_name_category ON products(name(10), category);
SELECT name, category FROM products WHERE name LIKE 'Apple%';
```

✅ **函数使用优化**：
```sql
-- 5️⃣ 批量字符串操作
UPDATE users 
SET full_name = CONCAT_WS(' ', first_name, last_name)
WHERE full_name IS NULL;

-- 6️⃣ 使用CASE减少多次函数调用
SELECT 
    name,
    CASE 
        WHEN CHAR_LENGTH(name) <= 10 THEN name
        ELSE CONCAT(LEFT(name, 10), '...')
    END AS display_name
FROM users;
```

**字符串函数使用规范**：

| 规范类别 | **建议做法** | **避免做法** |
|---------|-------------|-------------|
| 🔍 **WHERE条件** | `预处理数据，直接比较` | `WHERE UPPER(col) = 'VALUE'` |
| 📊 **SELECT输出** | `适度使用，考虑缓存` | `过度复杂的字符串拼接` |
| 🔄 **UPDATE操作** | `批量更新，使用WHERE限制` | `全表字符串函数更新` |
| 📈 **GROUP BY** | `GROUP_CONCAT限制长度` | `无限制的字符串聚合` |

---

## 12. 📋 核心要点总结


### 12.1 必须掌握的核心概念


```
🔸 字符串连接：CONCAT简单拼接，CONCAT_WS智能分隔符连接
🔸 字符串截取：LEFT/RIGHT简单截取，SUBSTRING灵活定位
🔸 长度计算：LENGTH字节长度，CHAR_LENGTH字符个数
🔸 字符查找：LOCATE/POSITION查找子串位置
🔸 字符替换：REPLACE内容替换，INSERT位置替换
🔸 格式处理：UPPER/LOWER大小写，TRIM空格清理
🔸 字符串聚合：GROUP_CONCAT多行数据合并
```

### 12.2 关键理解要点


**🔹 函数选择的核心原则**
```
简单优先：能用LEFT/RIGHT就不用SUBSTRING
性能考虑：避免在WHERE条件中使用字符串函数
数据标准：存储时标准化，查询时直接匹配
合理组合：多个简单函数组合实现复杂功能
```

**🔹 字符串处理的性能影响**
```
索引失效：WHERE UPPER(name) = 'VALUE' 无法使用索引
计算开销：复杂字符串函数影响查询性能
内存占用：GROUP_CONCAT需要注意长度限制
批量优势：批量字符串处理比单条效率高
```

**🔹 实际应用的关键点**
```
数据清洗：TRIM去空格，REPLACE统一格式
信息展示：CONCAT_WS格式化输出
数据验证：LENGTH/CHAR_LENGTH检查输入长度
模糊查询：LOCATE配合SUBSTRING实现复杂查找
数据脱敏：字符串函数组合实现敏感信息保护
```

### 12.3 实际应用价值


- **📊 数据处理**：清洗导入数据，统一字段格式
- **🔍 查询优化**：灵活的字符串搜索和匹配
- **📱 界面展示**：格式化输出，提升用户体验  
- **🔒 数据安全**：敏感信息脱敏处理
- **📈 报表统计**：字符串聚合，生成汇总报告
- **🔧 系统集成**：数据转换，格式适配

### 12.4 进阶学习方向


```
高级应用：
├── 正则表达式函数 (REGEXP, RLIKE)
├── JSON字符串处理函数  
├── 全文检索 (MATCH AGAINST)
└── 自定义字符串函数

性能优化：
├── 字符串索引策略
├── 字符集和排序规则优化
├── 查询重写技巧
└── 字符串函数的执行计划分析
```

**核心记忆口诀**：
- 连接用CONCAT_WS，截取LEFT/RIGHT/SUBSTRING
- 长度CHAR_LENGTH算字符，LENGTH算字节要记清
- 查找LOCATE定位置，替换REPLACE换内容
- 大小写UPPER/LOWER转，空格TRIM来清理
- 聚合GROUP_CONCAT妙，性能优化是关键