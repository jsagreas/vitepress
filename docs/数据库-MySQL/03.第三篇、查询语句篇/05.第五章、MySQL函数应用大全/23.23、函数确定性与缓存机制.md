---
title: 23、函数确定性与缓存机制
---
## 📚 目录

1. [函数确定性基础概念](#1-函数确定性基础概念)
2. [确定性函数DETERMINISTIC详解](#2-确定性函数DETERMINISTIC详解)
3. [非确定性函数识别与处理](#3-非确定性函数识别与处理)
4. [函数结果缓存策略](#4-函数结果缓存策略)
5. [函数调用优化技术](#5-函数调用优化技术)
6. [表达式求值缓存机制](#6-表达式求值缓存机制)
7. [函数调用成本分析](#7-函数调用成本分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 函数确定性基础概念


### 1.1 什么是函数确定性


> 💡 **核心概念**  
> 函数确定性指的是：给定相同的输入参数，函数是否总是返回相同的结果

**🔸 确定性函数特征**
```
定义特点：
• 相同输入 → 相同输出
• 无副作用（不修改数据库状态）
• 不依赖外部变化因素
• 结果可预测和重现

典型例子：
ABS(-5)        → 总是返回 5
UPPER('hello') → 总是返回 'HELLO'
LENGTH('test') → 总是返回 4
```

**🔸 非确定性函数特征**
```
定义特点：
• 相同输入可能产生不同输出
• 依赖系统状态或时间
• 结果随环境变化
• 无法预测具体结果

典型例子：
NOW()          → 每次调用返回当前时间
RAND()         → 每次返回不同随机数  
CONNECTION_ID()→ 返回当前连接ID
```

### 1.2 函数确定性的重要意义


**🎯 性能优化价值**

```
查询优化器的工作原理：

确定性函数：
┌─────────────────────┐
│ SELECT * FROM users │
│ WHERE age > ABS(-18)│  ← 优化器可以将ABS(-18)预计算为18
└─────────────────────┘
执行时变为：SELECT * FROM users WHERE age > 18

非确定性函数：
┌─────────────────────┐
│ SELECT * FROM users │
│ WHERE created_at >  │  ← NOW()每次执行都要重新计算
│       NOW() - 86400 │
└─────────────────────┘
每行都要重新计算NOW()的值
```

**📊 确定性对索引的影响**

```sql
-- 确定性函数可以用于函数索引
CREATE INDEX idx_upper_name ON users (UPPER(name));

-- 查询时可以有效使用索引
SELECT * FROM users WHERE UPPER(name) = 'JOHN';  -- 能使用索引

-- 非确定性函数不能用于索引
-- 这样的索引创建会失败或无效
CREATE INDEX idx_rand ON users (RAND());  -- 不建议，无实际意义
```

### 1.3 MySQL中的函数分类


**📋 MySQL函数确定性分类表**

| 函数类型 | **确定性** | **典型例子** | **使用场景** |
|---------|-----------|-------------|-------------|
| 🔢 **数学函数** | `确定性` | `ABS, ROUND, CEIL, FLOOR` | `数值计算，可缓存` |
| 🔤 **字符函数** | `确定性` | `UPPER, LOWER, LENGTH, SUBSTRING` | `字符处理，可索引` |
| 📅 **日期函数** | `混合` | `DATE_FORMAT确定性, NOW非确定性` | `需区别对待` |
| 🔀 **系统函数** | `非确定性` | `CONNECTION_ID, RAND, UUID` | `实时性要求高` |
| 🔄 **聚合函数** | `确定性` | `SUM, COUNT, AVG, MAX, MIN` | `结果集计算` |

---

## 2. ✅ 确定性函数DETERMINISTIC详解


### 2.1 DETERMINISTIC关键字的作用


> 📖 **关键理解**  
> DETERMINISTIC是MySQL中用来标识自定义函数确定性的关键字，影响函数的缓存和优化策略

**🔸 DETERMINISTIC声明语法**

```sql
-- 创建确定性函数的标准语法
CREATE FUNCTION function_name(parameters)
RETURNS return_type
DETERMINISTIC           -- 声明为确定性函数
READS SQL DATA         -- 声明函数特性
BEGIN
    -- 函数体
END;
```

**💻 确定性函数实例**

```sql
-- 示例1：计算圆面积的确定性函数
DELIMITER //
CREATE FUNCTION circle_area(radius DECIMAL(10,2))
RETURNS DECIMAL(15,4)
DETERMINISTIC                    -- 相同半径总是返回相同面积
READS SQL DATA
BEGIN
    DECLARE area DECIMAL(15,4);
    SET area = 3.14159 * radius * radius;
    RETURN area;
END//
DELIMITER ;

-- 使用示例
SELECT circle_area(5.0);        -- 总是返回 78.5398
SELECT circle_area(5.0);        -- 结果完全相同，可以缓存
```

**🔧 复杂确定性函数示例**

```sql
-- 示例2：根据用户级别计算折扣的确定性函数
DELIMITER //
CREATE FUNCTION get_discount_rate(user_level INT)
RETURNS DECIMAL(3,2)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE discount DECIMAL(3,2);
    
    -- 根据级别确定折扣率（纯逻辑计算，确定性）
    CASE user_level
        WHEN 1 THEN SET discount = 0.05;  -- 5%折扣
        WHEN 2 THEN SET discount = 0.10;  -- 10%折扣  
        WHEN 3 THEN SET discount = 0.15;  -- 15%折扣
        ELSE SET discount = 0.00;         -- 无折扣
    END CASE;
    
    RETURN discount;
END//
DELIMITER ;

-- 应用场景：电商价格计算
SELECT 
    product_name,
    original_price,
    get_discount_rate(user_level) as discount_rate,
    original_price * (1 - get_discount_rate(user_level)) as final_price
FROM products p
JOIN users u ON p.seller_id = u.user_id;
```

### 2.2 DETERMINISTIC vs NOT DETERMINISTIC


**🔸 声明对比和影响**

```sql
-- 确定性函数声明
CREATE FUNCTION calc_tax(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC           -- 明确声明为确定性
BEGIN
    RETURN amount * 0.08;  -- 固定税率计算
END;

-- 非确定性函数声明  
CREATE FUNCTION get_current_user_id()
RETURNS INT
NOT DETERMINISTIC       -- 明确声明为非确定性
READS SQL DATA
BEGIN
    -- 获取当前会话的用户ID（依赖系统状态）
    RETURN CONNECTION_ID();
END;
```

**⚠️ 错误声明的后果**

```sql
-- 错误示例：将非确定性函数声明为确定性
CREATE FUNCTION bad_random_function()
RETURNS INT
DETERMINISTIC           -- 错误声明！
BEGIN
    RETURN FLOOR(RAND() * 100);  -- 实际上是非确定性的
END;

-- 问题：
-- 1. 优化器可能错误缓存结果
-- 2. 复制环境下可能产生数据不一致
-- 3. 查询结果可能不符合预期
```

### 2.3 确定性函数的优化机制


**🚀 MySQL优化器如何处理确定性函数**

```sql
-- 优化前的查询
EXPLAIN SELECT * FROM orders 
WHERE total_amount > get_discount_rate(3) * 1000;

-- 优化器处理过程
-- 1. 识别get_discount_rate(3)为确定性函数
-- 2. 预计算：get_discount_rate(3) = 0.15
-- 3. 简化条件：total_amount > 0.15 * 1000
-- 4. 最终条件：total_amount > 150

-- 实际执行的等价查询
SELECT * FROM orders WHERE total_amount > 150;
```

**📈 性能对比测试**

```sql
-- 测试环境准备
CREATE TABLE test_orders (
    id INT PRIMARY KEY,
    amount DECIMAL(10,2),
    user_level INT
);

-- 插入测试数据
INSERT INTO test_orders 
SELECT 
    id, 
    RAND() * 1000 as amount,
    FLOOR(RAND() * 4) + 1 as user_level
FROM (SELECT ROW_NUMBER() OVER() as id FROM information_schema.columns LIMIT 100000) t;

-- 性能对比
-- 方案1：使用确定性函数
SELECT COUNT(*) FROM test_orders 
WHERE amount > circle_area(5.0);

-- 方案2：预计算常量
SELECT COUNT(*) FROM test_orders 
WHERE amount > 78.5398;

-- 结果：两种方案性能几乎相同（因为优化器预计算）
```

---

## 3. ❌ 非确定性函数识别与处理


### 3.1 常见非确定性函数识别


> ⚠️ **识别要点**  
> 非确定性函数通常依赖时间、随机数、系统状态或外部环境，需要特别注意其使用场景

**📋 非确定性函数分类表**

| 函数类型 | **函数名** | **非确定性原因** | **使用注意事项** |
|---------|-----------|-----------------|----------------|
| ⏰ **时间函数** | `NOW(), CURDATE(), CURRENT_TIMESTAMP` | `依赖系统时间` | `每次调用结果不同` |
| 🎲 **随机函数** | `RAND(), UUID()` | `随机算法` | `无法预测结果` |
| 🔗 **会话函数** | `CONNECTION_ID(), USER(), DATABASE()` | `依赖会话状态` | `不同连接结果不同` |
| 📊 **系统函数** | `LAST_INSERT_ID(), ROW_COUNT()` | `依赖操作状态` | `依赖前置操作` |

**💻 非确定性函数识别示例**

```sql
-- 时间相关函数（非确定性）
SELECT NOW();                    -- 2024-01-15 10:30:45
-- 1秒后再执行
SELECT NOW();                    -- 2024-01-15 10:30:46（结果不同）

-- 随机函数（非确定性）
SELECT RAND();                   -- 0.6789123
SELECT RAND();                   -- 0.2345678（完全不同）

-- 会话相关函数（非确定性）  
SELECT CONNECTION_ID();          -- 连接1: 返回8
-- 新连接执行
SELECT CONNECTION_ID();          -- 连接2: 返回9（不同连接不同结果）

-- 操作状态相关函数（非确定性）
INSERT INTO users (name) VALUES ('John');
SELECT LAST_INSERT_ID();        -- 返回刚插入记录的ID

INSERT INTO users (name) VALUES ('Mary');  
SELECT LAST_INSERT_ID();        -- 返回不同的ID
```

### 3.2 非确定性函数的使用场景


**🎯 合理使用场景**

```sql
-- 场景1：数据记录时间戳
CREATE TABLE user_logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    action VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP  -- 合理使用
);

-- 每次插入自动记录当前时间
INSERT INTO user_logs (user_id, action) VALUES (1, 'login');

-- 场景2：生成唯一标识符
CREATE TABLE sessions (
    session_id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),  -- 合理使用
    user_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 场景3：随机抽样
SELECT * FROM products 
ORDER BY RAND()          -- 合理使用随机排序
LIMIT 10;               -- 获取10个随机产品
```

**⚠️ 需要注意的使用场景**

```sql
-- 问题场景1：WHERE条件中使用非确定性函数
-- 不推荐：每行都会重新计算NOW()
SELECT * FROM orders 
WHERE created_at > NOW() - INTERVAL 1 DAY;

-- 推荐：预计算时间值
SET @yesterday = NOW() - INTERVAL 1 DAY;
SELECT * FROM orders WHERE created_at > @yesterday;

-- 问题场景2：JOIN条件中使用非确定性函数  
-- 严重问题：每次JOIN都重新计算，结果不可预期
SELECT * FROM users u1
JOIN users u2 ON u1.id = u2.id + FLOOR(RAND() * 10);

-- 问题场景3：GROUP BY中使用非确定性函数
-- 不推荐：分组依据不稳定
SELECT COUNT(*), RAND() as random_group
FROM orders
GROUP BY FLOOR(RAND() * 5);  -- 分组结果无意义
```

### 3.3 非确定性函数的性能影响


**📊 性能影响分析**

```sql
-- 性能测试：比较确定性和非确定性函数的影响

-- 测试表准备
CREATE TABLE perf_test (
    id INT PRIMARY KEY,
    value DECIMAL(10,2)
);

-- 插入测试数据
INSERT INTO perf_test 
SELECT n, n * 1.5 
FROM (SELECT ROW_NUMBER() OVER() as n FROM information_schema.columns LIMIT 100000) t;

-- 测试1：确定性函数在WHERE条件中
SELECT COUNT(*) FROM perf_test WHERE value > ABS(-100);
-- 执行时间：约10ms（ABS(-100)被预计算为100）

-- 测试2：非确定性函数在WHERE条件中  
SELECT COUNT(*) FROM perf_test WHERE id > RAND() * 100000;
-- 执行时间：约500ms（每行都要计算RAND()）

-- 测试3：非确定性函数在SELECT中
SELECT id, value, NOW() as query_time FROM perf_test LIMIT 1000;
-- NOW()会为每行计算一次，但通常在同一查询中值相同
```

**🔧 非确定性函数优化策略**

```sql
-- 策略1：预计算非确定性值
-- 不优化的写法
SELECT * FROM orders 
WHERE created_at BETWEEN NOW() - INTERVAL 7 DAY AND NOW();

-- 优化的写法  
SET @now = NOW();
SET @week_ago = @now - INTERVAL 7 DAY;
SELECT * FROM orders 
WHERE created_at BETWEEN @week_ago AND @now;

-- 策略2：使用子查询隔离非确定性函数
-- 不优化的写法
SELECT *, (SELECT COUNT(*) FROM order_items WHERE order_id = o.id AND RAND() > 0.5) 
FROM orders o;

-- 优化的写法
SELECT o.*, 
       CASE WHEN @random_threshold > 0.5 
            THEN (SELECT COUNT(*) FROM order_items WHERE order_id = o.id)
            ELSE 0 
       END as conditional_count
FROM orders o
CROSS JOIN (SELECT RAND() as random_threshold) r;
```

---

## 4. 💾 函数结果缓存策略


### 4.1 MySQL内置缓存机制


> 💡 **缓存原理**  
> MySQL对确定性函数的结果有多层次的缓存机制，包括表达式缓存、查询缓存等

**🔸 表达式级缓存**

```sql
-- MySQL内部缓存机制示例
SELECT 
    product_name,
    price * get_discount_rate(3) as discounted_price,  -- 函数只计算一次
    price * get_discount_rate(3) * 0.08 as tax         -- 复用前面的计算结果
FROM products;

-- 内部优化过程：
-- 1. 识别get_discount_rate(3)为确定性函数
-- 2. 计算一次：get_discount_rate(3) = 0.15  
-- 3. 替换所有出现：price * 0.15, price * 0.15 * 0.08
-- 4. 避免重复函数调用
```

**📊 缓存效果验证**

```sql
-- 创建带计数器的测试函数
DELIMITER //
CREATE FUNCTION test_deterministic(input_val INT)
RETURNS INT
DETERMINISTIC
READS SQL DATA
BEGIN
    -- 模拟复杂计算
    DECLARE result INT DEFAULT 0;
    DECLARE i INT DEFAULT 0;
    
    WHILE i < input_val DO
        SET result = result + i;
        SET i = i + 1;
    END WHILE;
    
    RETURN result;
END//
DELIMITER ;

-- 测试缓存效果
SELECT 
    product_id,
    test_deterministic(100) as calc1,  -- 只计算一次
    test_deterministic(100) as calc2,  -- 复用缓存结果  
    test_deterministic(100) as calc3   -- 复用缓存结果
FROM products LIMIT 1000;

-- 查看执行计划确认优化效果
EXPLAIN FORMAT=JSON 
SELECT product_id, test_deterministic(100) 
FROM products LIMIT 10;
```

### 4.2 应用层缓存策略


**🔧 自定义缓存实现**

```sql
-- 策略1：使用变量缓存函数结果
-- 场景：在存储过程中多次使用同一函数
DELIMITER //
CREATE PROCEDURE process_orders_with_cache()
BEGIN
    DECLARE cached_discount DECIMAL(3,2);
    DECLARE done INT DEFAULT FALSE;
    DECLARE order_id INT;
    DECLARE order_amount DECIMAL(10,2);
    
    -- 游标声明
    DECLARE order_cursor CURSOR FOR 
        SELECT id, amount FROM orders WHERE status = 'pending';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 预计算并缓存常用值
    SET cached_discount = get_discount_rate(3);  -- 只计算一次
    
    OPEN order_cursor;
    
    process_loop: LOOP
        FETCH order_cursor INTO order_id, order_amount;
        IF done THEN LEAVE process_loop; END IF;
        
        -- 使用缓存值，避免重复计算
        UPDATE orders 
        SET final_amount = order_amount * (1 - cached_discount)
        WHERE id = order_id;
        
    END LOOP;
    
    CLOSE order_cursor;
END//
DELIMITER ;
```

**📋 缓存策略对比表**

| 缓存类型 | **适用场景** | **优势** | **劣势** |
|---------|-------------|---------|---------|
| 🔄 **MySQL内置** | `确定性函数自动缓存` | `透明，无需干预` | `仅限单查询内` |
| 📝 **变量缓存** | `存储过程内重复使用` | `手动控制，灵活` | `需要额外编码` |
| 🗃️ **临时表缓存** | `复杂计算结果集` | `可持久化到会话结束` | `占用内存空间` |
| 💾 **应用程序缓存** | `跨请求复用结果` | `最高性能` | `一致性维护复杂` |

### 4.3 缓存失效机制


**🔄 缓存更新策略**

```sql
-- 策略1：基于时间的缓存失效
CREATE TABLE function_cache (
    cache_key VARCHAR(255) PRIMARY KEY,
    cache_value TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    INDEX idx_expires (expires_at)
);

-- 缓存函数实现
DELIMITER //
CREATE FUNCTION cached_complex_calc(input_param INT)
RETURNS DECIMAL(15,4)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE cached_result DECIMAL(15,4);
    DECLARE cache_key VARCHAR(255);
    DECLARE cache_count INT DEFAULT 0;
    
    -- 生成缓存key
    SET cache_key = CONCAT('complex_calc_', input_param);
    
    -- 检查缓存是否存在且未过期
    SELECT COUNT(*), cache_value INTO cache_count, cached_result
    FROM function_cache 
    WHERE cache_key = cache_key 
      AND expires_at > NOW()
    LIMIT 1;
    
    -- 如果缓存命中，直接返回
    IF cache_count > 0 THEN
        RETURN cached_result;
    END IF;
    
    -- 缓存未命中，执行复杂计算
    SET cached_result = input_param * input_param * 3.14159;  -- 示例计算
    
    -- 存储到缓存（1小时有效期）
    INSERT INTO function_cache (cache_key, cache_value, expires_at)
    VALUES (cache_key, cached_result, NOW() + INTERVAL 1 HOUR)
    ON DUPLICATE KEY UPDATE 
        cache_value = cached_result,
        expires_at = NOW() + INTERVAL 1 HOUR;
    
    RETURN cached_result;
END//
DELIMITER ;
```

---

## 5. ⚡ 函数调用优化技术


### 5.1 函数调用开销分析


> 📊 **性能要点**  
> 函数调用涉及参数传递、栈帧创建、上下文切换等开销，优化调用方式能显著提升性能

**🔸 函数调用成本构成**

```
函数调用的完整开销：

参数处理：
┌─────────────────────┐
│ 1. 参数类型检查      │ ← 数据类型验证
│ 2. 参数值拷贝        │ ← 内存分配和复制
│ 3. 参数栈压入        │ ← 调用栈准备
└─────────────────────┘

函数执行：
┌─────────────────────┐
│ 1. 上下文创建        │ ← 执行环境初始化  
│ 2. 局部变量分配      │ ← 内存空间分配
│ 3. 函数体执行        │ ← 实际计算逻辑
│ 4. 返回值准备        │ ← 结果值处理
└─────────────────────┘

清理工作：
┌─────────────────────┐
│ 1. 局部变量释放      │ ← 内存回收
│ 2. 栈帧弹出          │ ← 调用栈恢复  
│ 3. 返回值传递        │ ← 结果返回
└─────────────────────┘
```

**💻 性能测试代码**

```sql
-- 创建简单函数用于性能测试
DELIMITER //
CREATE FUNCTION simple_add(a INT, b INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN a + b;
END//

CREATE FUNCTION complex_calc(input_val INT)
RETURNS DECIMAL(15,4)
DETERMINISTIC
BEGIN
    DECLARE result DECIMAL(15,4) DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    
    -- 模拟复杂计算
    WHILE i <= input_val DO
        SET result = result + SQRT(i) * 3.14159;
        SET i = i + 1;
    END WHILE;
    
    RETURN result;
END//
DELIMITER ;

-- 性能对比测试
-- 测试1：直接计算 vs 函数调用
SELECT BENCHMARK(1000000, 5 + 10);                    -- 直接计算
SELECT BENCHMARK(1000000, simple_add(5, 10));         -- 函数调用

-- 测试2：函数调用频次影响
SELECT COUNT(*) FROM 
(SELECT simple_add(id, id) FROM test_table LIMIT 10000) t;      -- 10K次调用
SELECT COUNT(*) FROM 
(SELECT simple_add(id, id) FROM test_table LIMIT 100000) t;     -- 100K次调用
```

### 5.2 批量调用优化


**🚀 批量处理策略**

```sql
-- 优化前：逐行调用函数
SELECT 
    order_id,
    amount,
    get_discount_rate(user_level) as discount,           -- 每行调用一次
    amount * (1 - get_discount_rate(user_level)) as final_amount
FROM order_details od
JOIN users u ON od.user_id = u.id;

-- 优化后：预计算常用值
SELECT 
    od.order_id,
    od.amount,
    discounts.rate as discount,
    od.amount * (1 - discounts.rate) as final_amount
FROM order_details od
JOIN users u ON od.user_id = u.id
JOIN (
    -- 预计算所有可能的折扣率
    SELECT 1 as user_level, get_discount_rate(1) as rate
    UNION ALL SELECT 2, get_discount_rate(2)
    UNION ALL SELECT 3, get_discount_rate(3)
    UNION ALL SELECT 4, get_discount_rate(4)
) discounts ON u.user_level = discounts.user_level;
```

**🔧 条件调用优化**

```sql
-- 优化前：无条件调用昂贵函数
SELECT 
    product_id,
    name,
    CASE 
        WHEN category = 'electronics' 
        THEN complex_calc(price)      -- 即使不需要也会计算
        ELSE price 
    END as final_price
FROM products;

-- 优化后：条件判断前置
SELECT 
    product_id,
    name,
    CASE 
        WHEN category = 'electronics' 
        THEN complex_calc(price)      -- 只在需要时计算
        ELSE price 
    END as final_price
FROM products
WHERE category = 'electronics'         -- 先过滤，减少函数调用次数

UNION ALL

SELECT 
    product_id,
    name, 
    price as final_price              -- 无需函数调用
FROM products  
WHERE category != 'electronics';
```

### 5.3 内联优化技术


**🎯 表达式内联替代**

```sql
-- 优化前：频繁调用简单函数
CREATE FUNCTION calc_tax_rate(amount DECIMAL(10,2))
RETURNS DECIMAL(5,4)
DETERMINISTIC
BEGIN
    RETURN CASE 
        WHEN amount <= 1000 THEN 0.05
        WHEN amount <= 5000 THEN 0.08  
        ELSE 0.10
    END;
END;

SELECT *, calc_tax_rate(amount) FROM orders;

-- 优化后：直接使用CASE表达式（避免函数调用开销）
SELECT *,
    CASE 
        WHEN amount <= 1000 THEN 0.05
        WHEN amount <= 5000 THEN 0.08
        ELSE 0.10
    END as tax_rate
FROM orders;
```

**📈 内联优化效果对比**

```sql
-- 性能测试对比
-- 创建测试数据
CREATE TABLE perf_orders AS
SELECT 
    ROW_NUMBER() OVER() as id,
    RAND() * 10000 as amount
FROM information_schema.columns 
LIMIT 100000;

-- 方法1：函数调用
SELECT COUNT(*), AVG(calc_tax_rate(amount)) 
FROM perf_orders;                           -- 执行时间：约800ms

-- 方法2：内联表达式  
SELECT COUNT(*), AVG(
    CASE 
        WHEN amount <= 1000 THEN 0.05
        WHEN amount <= 5000 THEN 0.08
        ELSE 0.10
    END
) FROM perf_orders;                        -- 执行时间：约200ms
```

---

## 6. 🗃️ 表达式求值缓存机制


### 6.1 表达式缓存原理


> 🔍 **工作机制**  
> MySQL查询优化器会识别重复的表达式计算，在查询执行期间缓存中间结果

**🔸 表达式缓存的工作流程**

```
表达式缓存处理过程：

语法解析阶段：
┌─────────────────────┐
│ 1. 识别表达式        │ ← 解析SQL中的计算表达式
│ 2. 表达式标准化      │ ← 转换为内部表示形式
│ 3. 重复检测          │ ← 发现相同的表达式
└─────────────────────┘

优化阶段：
┌─────────────────────┐
│ 1. 常量折叠          │ ← 预计算常量表达式
│ 2. 表达式提取        │ ← 提取公共子表达式  
│ 3. 缓存策略制定      │ ← 决定哪些结果缓存
└─────────────────────┘

执行阶段：
┌─────────────────────┐
│ 1. 首次计算          │ ← 计算表达式并缓存
│ 2. 结果复用          │ ← 后续直接使用缓存
│ 3. 缓存更新          │ ← 根据需要更新缓存
└─────────────────────┘
```

**💻 表达式缓存示例**

```sql
-- 示例查询：多次使用相同表达式
SELECT 
    order_id,
    amount,
    amount * 0.08 as tax,                    -- 表达式1
    amount * 0.08 * 1.5 as penalty,         -- 包含表达式1
    (amount + amount * 0.08) as total       -- 再次使用表达式1
FROM orders
WHERE amount * 0.08 > 10;                   -- WHERE中也使用表达式1

-- MySQL优化器处理：
-- 1. 识别"amount * 0.08"出现多次
-- 2. 计算一次并缓存结果
-- 3. 所有地方都复用缓存值
-- 4. 实际只进行一次乘法计算
```

### 6.2 复杂表达式缓存策略


**🔧 子表达式提取优化**

```sql
-- 复杂表达式示例
SELECT 
    customer_id,
    order_date,
    -- 复杂的价格计算公式
    base_price * (1 + tax_rate) * (1 - discount_rate) * quantity as final_total,
    base_price * (1 + tax_rate) * (1 - discount_rate) * quantity * 0.1 as commission,
    base_price * (1 + tax_rate) * (1 - discount_rate) as unit_price_after_tax_discount
FROM order_items;

-- 优化器内部处理（伪代码表示）：
-- temp_expr1 = base_price * (1 + tax_rate)
-- temp_expr2 = temp_expr1 * (1 - discount_rate)  
-- final_total = temp_expr2 * quantity
-- commission = final_total * 0.1
-- unit_price_after_tax_discount = temp_expr2
```

**📊 缓存效果监控**

```sql
-- 使用EXPLAIN分析表达式优化
EXPLAIN FORMAT=JSON
SELECT 
    product_id,
    price * 1.2 as price_with_markup,
    price * 1.2 * 0.08 as tax_on_markup,
    (price * 1.2) + (price * 1.2 * 0.08) as total
FROM products
LIMIT 1000;

-- 查看执行计划中的表达式处理
-- 关注：
-- 1. "constant_condition_removal"
-- 2. "expression_evaluation" 
-- 3. "common_subexpression_elimination"
```

### 6.3 手动表达式优化


**🎯 使用派生表缓存复杂表达式**

```sql
-- 优化前：重复计算复杂表达式
SELECT 
    order_id,
    customer_id,
    SQRT(quantity * unit_price) + LOG(discount_rate + 1) as complexity_score,
    (SQRT(quantity * unit_price) + LOG(discount_rate + 1)) * 1.5 as weighted_score,
    CASE 
        WHEN SQRT(quantity * unit_price) + LOG(discount_rate + 1) > 10 
        THEN 'high'
        ELSE 'normal' 
    END as score_category
FROM order_details;

-- 优化后：使用派生表预计算
SELECT 
    order_id,
    customer_id, 
    complexity_score,
    complexity_score * 1.5 as weighted_score,
    CASE 
        WHEN complexity_score > 10 THEN 'high'
        ELSE 'normal'
    END as score_category
FROM (
    SELECT 
        order_id,
        customer_id,
        SQRT(quantity * unit_price) + LOG(discount_rate + 1) as complexity_score
    FROM order_details
) pre_calculated;
```

**🔄 使用临时变量缓存（存储过程中）**

```sql
DELIMITER //
CREATE PROCEDURE process_orders_optimized()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_order_id INT;
    DECLARE v_amount DECIMAL(10,2);
    DECLARE v_complex_calc DECIMAL(15,4);  -- 缓存变量
    
    DECLARE order_cursor CURSOR FOR 
        SELECT order_id, amount FROM orders WHERE status = 'pending';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN order_cursor;
    
    process_loop: LOOP
        FETCH order_cursor INTO v_order_id, v_amount;
        IF done THEN LEAVE process_loop; END IF;
        
        -- 计算一次复杂表达式并缓存
        SET v_complex_calc = SQRT(v_amount) * LOG(v_amount + 1) * 3.14159;
        
        -- 多处使用缓存值
        UPDATE orders 
        SET 
            complexity_score = v_complex_calc,
            risk_factor = v_complex_calc * 0.15,
            priority_level = CASE 
                WHEN v_complex_calc > 100 THEN 'high'
                WHEN v_complex_calc > 50 THEN 'medium'
                ELSE 'low'
            END
        WHERE order_id = v_order_id;
        
    END LOOP;
    
    CLOSE order_cursor;
END//
DELIMITER ;
```

---

## 7. 💰 函数调用成本分析


### 7.1 成本模型基础


> 📊 **成本计算**  
> MySQL使用基于成本的优化器(CBO)来评估函数调用的代价，包括CPU成本和IO成本

**🔸 函数调用成本构成**

| 成本类型 | **具体内容** | **影响因素** | **量化方式** |
|---------|-------------|-------------|-------------|
| 🖥️ **CPU成本** | `函数执行计算` | `算法复杂度，循环次数` | `时间复杂度 × CPU单价` |
| 💾 **内存成本** | `参数和局部变量` | `数据类型大小` | `字节数 × 内存单价` |
| 🔄 **调用成本** | `函数调用开销` | `参数个数，嵌套层次` | `固定成本 + 变量成本` |
| 📊 **IO成本** | `函数内数据访问` | `表访问次数` | `页面读取数 × IO单价` |

**💻 成本分析实例**

```sql
-- 创建不同复杂度的函数进行成本分析
-- 简单函数（低成本）
CREATE FUNCTION low_cost_func(a INT) 
RETURNS INT DETERMINISTIC
BEGIN 
    RETURN a * 2; 
END;

-- 中等复杂度函数（中成本）
CREATE FUNCTION medium_cost_func(n INT)
RETURNS DECIMAL(10,2) DETERMINISTIC  
BEGIN
    DECLARE result DECIMAL(10,2) DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    WHILE i <= n DO
        SET result = result + SQRT(i);
        SET i = i + 1;
    END WHILE;
    RETURN result;
END;

-- 高复杂度函数（高成本）
CREATE FUNCTION high_cost_func(table_name VARCHAR(100))
RETURNS INT READS SQL DATA
BEGIN
    DECLARE row_count INT;
    SET @sql = CONCAT('SELECT COUNT(*) FROM ', table_name);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    RETURN row_count;
END;
```

### 7.2 成本分析工具


**🔍 使用EXPLAIN分析函数成本**

```sql
-- 分析函数调用对查询成本的影响
-- 查询1：无函数调用
EXPLAIN FORMAT=JSON
SELECT order_id, amount FROM orders WHERE amount > 100;

-- 查询2：简单函数调用
EXPLAIN FORMAT=JSON  
SELECT order_id, amount, low_cost_func(amount) FROM orders WHERE amount > 100;

-- 查询3：复杂函数调用
EXPLAIN FORMAT=JSON
SELECT order_id, amount, medium_cost_func(amount) FROM orders WHERE amount > 100;

-- 对比分析结果中的cost字段：
-- "query_cost": "120.50"     -- 无函数
-- "query_cost": "145.80"     -- 简单函数 
-- "query_cost": "890.30"     -- 复杂函数
```

**📈 实际性能测试**

```sql
-- 准备测试数据
CREATE TABLE cost_test AS
SELECT ROW_NUMBER() OVER() as id, RAND() * 1000 as value
FROM information_schema.columns LIMIT 50000;

-- 成本对比测试
-- 基准测试：无函数调用
SELECT COUNT(*), AVG(value) FROM cost_test;

-- 测试1：简单函数调用
SELECT COUNT(*), AVG(low_cost_func(value)) FROM cost_test;

-- 测试2：中等复杂度函数调用  
SELECT COUNT(*), AVG(medium_cost_func(CAST(value/100 AS INT))) FROM cost_test;

-- 记录执行时间：
-- 基准：50ms
-- 简单函数：180ms (3.6x)
-- 复杂函数：15000ms (300x)
```

### 7.3 成本优化策略


**🚀 函数调用频次优化**

```sql
-- 优化策略1：减少函数调用频次
-- 低效写法：每行都调用函数
SELECT 
    product_id,
    price,
    medium_cost_func(category_id) as category_score  -- 重复计算
FROM products p1
JOIN products p2 ON p1.category_id = p2.category_id;

-- 高效写法：预计算函数结果
WITH category_scores AS (
    SELECT DISTINCT 
        category_id,
        medium_cost_func(category_id) as category_score  -- 只计算一次
    FROM products
)
SELECT 
    p1.product_id,
    p1.price, 
    cs.category_score
FROM products p1
JOIN products p2 ON p1.category_id = p2.category_id
JOIN category_scores cs ON p1.category_id = cs.category_id;
```

**🎯 条件化函数调用**

```sql
-- 优化策略2：避免不必要的函数调用
-- 低效写法：无条件调用昂贵函数
SELECT 
    order_id,
    status,
    CASE 
        WHEN status = 'completed' 
        THEN medium_cost_func(order_id)  -- 总是计算
        ELSE 0 
    END as completion_score
FROM orders;

-- 高效写法：条件过滤后再调用函数
SELECT 
    order_id,
    status, 
    medium_cost_func(order_id) as completion_score
FROM orders 
WHERE status = 'completed'  -- 先过滤再计算

UNION ALL

SELECT 
    order_id,
    status,
    0 as completion_score
FROM orders
WHERE status != 'completed';
```

**📊 批量处理优化**

```sql
-- 优化策略3：批量处理降低平均成本
-- 创建批量处理函数
DELIMITER //
CREATE PROCEDURE batch_process_orders()
BEGIN
    DECLARE batch_size INT DEFAULT 1000;
    DECLARE offset_val INT DEFAULT 0;
    DECLARE row_count INT;
    
    -- 获取总记录数
    SELECT COUNT(*) INTO row_count FROM orders WHERE status = 'pending';
    
    WHILE offset_val < row_count DO
        -- 批量更新，减少函数调用次数
        UPDATE orders 
        SET processed_score = medium_cost_func(order_id)
        WHERE status = 'pending'
        ORDER BY order_id 
        LIMIT batch_size OFFSET offset_val;
        
        SET offset_val = offset_val + batch_size;
        
        -- 提交批次，释放锁
        COMMIT;
    END WHILE;
END//
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 函数确定性核心理念


> 🎯 **本质理解**  
> 函数确定性是数据库性能优化的基础，直接影响缓存策略、查询优化和执行效率

**🔸 确定性判断要点**
```
确定性函数特征：
✅ 相同输入总是产生相同输出
✅ 不依赖系统状态（时间、会话、随机数）
✅ 不产生副作用（不修改数据）
✅ 结果可预测和缓存

非确定性识别：
❌ 时间函数：NOW(), CURDATE(), CURRENT_TIMESTAMP
❌ 随机函数：RAND(), UUID()  
❌ 会话函数：CONNECTION_ID(), USER()
❌ 状态函数：LAST_INSERT_ID(), ROW_COUNT()
```

### 8.2 DETERMINISTIC关键字使用要点


```
正确声明的重要性：
🔸 影响查询优化器的决策
🔸 决定函数结果是否可以缓存
🔸 影响复制环境的数据一致性
🔸 关系到函数调用的性能表现

常见误区：
⚠️ 将非确定性函数错误标记为DETERMINISTIC
⚠️ 在函数内使用非确定性函数却声明为确定性
⚠️ 忽略READS SQL DATA等补充声明
```

### 8.3 缓存机制优化策略


**📊 多层次缓存体系**
```
MySQL内置缓存：
• 表达式级缓存：同一查询内的重复表达式
• 函数结果缓存：确定性函数的计算结果
• 查询计划缓存：避免重复的执行计划生成

应用层缓存：
• 变量缓存：存储过程内的临时缓存
• 临时表缓存：会话级的结果集缓存
• 程序缓存：跨请求的函数结果缓存

缓存策略选择：
• 计算成本高：优先使用缓存
• 调用频次高：考虑预计算
• 数据变化少：延长缓存有效期
```

### 8.4 性能优化实战技巧


**⚡ 函数调用优化方法**
```
减少调用频次：
🔸 预计算常用值
🔸 使用JOIN替代重复函数调用
🔸 批量处理降低平均成本

优化调用位置：
🔸 避免在WHERE条件中使用非确定性函数
🔸 条件判断前置，减少不必要的计算
🔸 使用派生表隔离复杂计算

表达式优化：
🔸 提取公共子表达式
🔸 使用内联替代简单函数
🔸 利用MySQL的常量折叠机制
```

### 8.5 成本分析与监控


**📈 性能监控指标**
```
关键监控点：
• 函数调用次数和频率
• 单次函数调用平均耗时
• 复杂函数对查询总成本的影响
• 缓存命中率和效果

性能基准：
• 简单确定性函数：< 0.1ms
• 中等复杂度函数：0.1-10ms
• 复杂函数或非确定性函数：> 10ms

优化目标：
• 减少高成本函数的调用频次
• 提高缓存利用率
• 降低查询总体执行时间
```

### 8.6 最佳实践指南


**🛠️ 开发规范**
```
函数设计原则：
✅ 明确标识函数的确定性
✅ 避免在确定性函数中使用非确定性操作
✅ 合理设计函数的复杂度
✅ 考虑函数的可缓存性

使用建议：
✅ 优先使用内置函数而非自定义函数
✅ 简单计算考虑内联而非函数调用
✅ 复杂逻辑优先在应用层实现
✅ 批量操作使用存储过程

监控和维护：
✅ 定期分析慢查询中的函数使用
✅ 监控函数调用的性能指标
✅ 优化高频调用的函数实现
✅ 建立函数性能基准测试
```

### 8.7 实际应用价值


**💼 业务场景应用**
- **电商系统**：价格计算函数的确定性声明和缓存策略
- **金融系统**：风险评估函数的性能优化和批量处理
- **报表系统**：复杂统计函数的结果缓存和增量计算
- **实时系统**：避免非确定性函数导致的性能波动

**🔧 技术架构优化**
- **查询性能**：通过函数确定性提升查询执行效率
- **系统稳定性**：避免非确定性函数导致的不一致问题
- **资源使用**：通过缓存机制减少CPU和内存消耗
- **扩展性**：为大规模数据处理建立高效的函数调用模式

**核心记忆要点**：
```
函数确定性是优化基石，DETERMINISTIC声明要准确
缓存机制分层次，表达式复用最重要  
成本分析看全局，调用频次是关键
非确定性需谨慎，WHERE条件要避免
```