---
title: 8、JSON函数详解
---
## 📚 目录

1. [JSON函数基础概念](#1-JSON函数基础概念)
2. [JSON路径表达式详解](#2-JSON路径表达式详解)
3. [核心JSON函数深度解析](#3-核心JSON函数深度解析)
4. [JSON数据提取与查询](#4-JSON数据提取与查询)
5. [JSON数据修改操作](#5-JSON数据修改操作)
6. [JSON数据创建与构建](#6-JSON数据创建与构建)
7. [JSON数据验证与类型检测](#7-JSON数据验证与类型检测)
8. [JSON聚合函数应用](#8-JSON聚合函数应用)
9. [JSON函数性能优化](#9-JSON函数性能优化)
10. [JSON索引策略与最佳实践](#10-JSON索引策略与最佳实践)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🌟 JSON函数基础概念


### 1.1 什么是JSON函数


**🔸 JSON函数的本质**
```
JSON函数就像是处理JSON数据的"瑞士军刀"
作用：让MySQL能够像操作普通数据一样操作JSON格式的数据
目标：在关系型数据库中享受NoSQL的灵活性
```

**💡 为什么需要JSON函数**
```
传统问题：
- 存储复杂数据结构需要多张表
- 用户配置、商品属性等动态字段难以处理
- 与前端JSON数据交互复杂

JSON函数的解决方案：
- 直接在数据库中存储和操作JSON
- 无需复杂的序列化/反序列化
- 保持数据的完整性和查询效率
```

### 1.2 JSON函数的应用场景


**🎯 典型应用场景**
```
用户配置管理：
{"theme": "dark", "language": "zh-CN", "notifications": {"email": true, "push": false}}

商品属性存储：
{"color": "红色", "size": "M", "features": ["防皱", "透气", "抗菌"]}

日志和事件记录：
{"event": "user_login", "timestamp": "2025-09-02T10:30:00Z", "metadata": {"ip": "192.168.1.100"}}
```

### 1.3 JSON函数分类概览


**📋 函数功能分类**
```
数据提取类：
• JSON_EXTRACT (->) - 提取JSON值
• JSON_UNQUOTE (->>) - 去除JSON字符串引号

数据修改类：
• JSON_SET - 设置JSON值（存在更新，不存在新增）
• JSON_INSERT - 插入新的JSON值（只插新的）
• JSON_REPLACE - 替换已有JSON值（只换旧的）
• JSON_REMOVE - 删除JSON元素
• JSON_MERGE - 合并JSON文档

数据创建类：
• JSON_ARRAY - 创建JSON数组
• JSON_OBJECT - 创建JSON对象

数据检测类：
• JSON_VALID - 验证JSON格式
• JSON_TYPE - 检测JSON数据类型
• JSON_KEYS - 获取JSON对象的键名

聚合统计类：
• JSON_ARRAYAGG - 聚合为JSON数组
• JSON_OBJECTAGG - 聚合为JSON对象
```

---

## 2. 🔍 JSON路径表达式详解


### 2.1 JSON路径表达式基础


**🔸 路径表达式的概念**
```
JSON路径表达式就像"GPS导航"，告诉MySQL在JSON文档中的具体位置
格式：用点号和方括号来表示层级关系
目的：精确定位JSON文档中的任意元素
```

**💡 基础语法规则**
```
根路径：$
对象属性：$.property 或 $."property"
数组元素：$[index]
嵌套访问：$.property.subproperty
数组中的对象：$[index].property

示例JSON：
{"user": {"name": "张三", "hobbies": ["读书", "游泳"]}, "orders": [{"id": 1, "amount": 100}]}

路径示例：
$.user.name → "张三"
$.user.hobbies[0] → "读书"  
$.orders[0].amount → 100
```

### 2.2 路径表达式高级用法


**🔧 通配符和范围操作**
```sql
-- 通配符 * 获取所有同级元素
SELECT JSON_EXTRACT(data, '$.orders[*].amount') FROM products;
-- 结果：[100, 200]

-- 范围操作 [start to end]
SELECT JSON_EXTRACT(data, '$.hobbies[0 to 1]') FROM users;

-- last 关键字获取最后一个元素
SELECT JSON_EXTRACT(data, '$.hobbies[last]') FROM users;
```

**⚠️ 路径表达式注意事项**
```
常见错误：
❌ 忘记根符号$：'user.name'
✅ 正确写法：'$.user.name'

❌ 特殊字符未加引号：$.user-info
✅ 正确写法：$."user-info"

记忆技巧：
• $ 代表JSON文档的根
• 点号访问对象属性，方括号访问数组元素
• 引号处理特殊字符
```

---

## 3. ⚙️ 核心JSON函数深度解析


### 3.1 JSON_EXTRACT - 数据提取核心


**🔸 JSON_EXTRACT基本用法**
```
作用：从JSON文档中提取指定路径的值
语法：JSON_EXTRACT(json_doc, path[, path] ...)
返回：JSON格式的数据（保留引号）
别名：-> 操作符
```

**💻 实际应用示例**
```sql
-- 创建测试表和数据
CREATE TABLE users (
  id INT PRIMARY KEY,
  profile JSON
);

INSERT INTO users VALUES 
(1, '{"name": "张三", "age": 25, "city": "北京", "tags": ["程序员", "摄影"]}');

-- 基础提取
SELECT 
  id,
  JSON_EXTRACT(profile, '$.name') as name,
  profile->'$.age' as age  -- 使用->操作符
FROM users;
-- 结果：id=1, name="张三", age=25

-- 多路径提取
SELECT JSON_EXTRACT(profile, '$.name', '$.city') FROM users WHERE id = 1;
-- 结果：["张三", "北京"]
```

### 3.2 JSON_UNQUOTE - 去除引号神器


**🔸 JSON_UNQUOTE的作用**
```
问题：JSON_EXTRACT返回的字符串带有JSON格式的引号
解决：JSON_UNQUOTE去除外层引号，返回纯字符串
语法：JSON_UNQUOTE(json_val)
别名：->> 操作符（推荐使用）
```

**💻 对比示例**
```sql
-- 带引号 vs 不带引号的区别
SELECT 
  profile->'$.name' as with_quote,      -- "张三" (带引号)
  profile->>'$.name' as without_quote   -- 张三 (不带引号)
FROM users WHERE id = 1;

-- 实际应用：条件查询
SELECT * FROM users WHERE profile->>'$.city' = '北京';  -- 正确
```

### 3.3 JSON_SET/INSERT/REPLACE - 数据修改三剑客


**🔸 三个函数的区别**
```
JSON_SET：万能设置，存在就更新，不存在就新增
JSON_INSERT：只插入新值，存在的路径不会覆盖
JSON_REPLACE：只更新已存在的值，不存在的路径不会新增

记忆技巧：
SET = 设置（不管存在与否）
INSERT = 插入（只插新的）
REPLACE = 替换（只换旧的）
```

**💻 详细应用对比**
```sql
-- 初始数据：{"name": "张三", "age": 25}
SET @json = '{"name": "张三", "age": 25}';

-- JSON_SET：存在就更新，不存在就新增
SELECT JSON_SET(@json, '$.age', 26, '$.city', '北京');
-- 结果：{"name": "张三", "age": 26, "city": "北京"}

-- JSON_INSERT：只插入不存在的字段
SELECT JSON_INSERT(@json, '$.age', 30, '$.city', '上海');
-- 结果：{"name": "张三", "age": 25, "city": "上海"} (age未变)

-- JSON_REPLACE：只替换已存在的字段
SELECT JSON_REPLACE(@json, '$.age', 28, '$.city', '深圳');
-- 结果：{"name": "张三", "age": 28} (city未添加)

-- 实际表更新
UPDATE users SET profile = JSON_SET(profile, '$.age', 26) WHERE id = 1;
```

### 3.4 JSON_REMOVE - 数据删除操作


**💻 删除操作示例**
```sql
-- 删除单个字段
SELECT JSON_REMOVE(profile, '$.age') FROM users WHERE id = 1;

-- 删除数组元素
SET @arr = '{"items": ["a", "b", "c"]}';
SELECT JSON_REMOVE(@arr, '$.items[1]');  -- 删除"b"
-- 结果：{"items": ["a", "c"]}

-- 批量清理
UPDATE users SET profile = JSON_REMOVE(profile, '$.temp_data') 
WHERE profile->'$.temp_data' IS NOT NULL;
```

### 3.5 JSON_KEYS - 获取对象键名


**💻 获取键名示例**
```sql
-- 获取所有键名
SELECT JSON_KEYS(profile) FROM users WHERE id = 1;
-- 结果：["name", "age", "city", "tags"]

-- 获取嵌套对象的键
SET @nested = '{"user": {"info": {"name": "张三", "age": 25}}}';
SELECT JSON_KEYS(@nested, '$.user.info');  -- ["name", "age"]

-- 动态检查字段存在
SELECT * FROM users WHERE JSON_CONTAINS(JSON_KEYS(profile), '"city"');
```

---

## 4. 📊 JSON数据提取与查询


### 4.1 复杂数据提取技巧


**🔍 嵌套JSON数据提取**
```sql
-- 创建复杂订单数据
CREATE TABLE orders (id INT, order_data JSON);
INSERT INTO orders VALUES (1, '{
  "customer": {"name": "张三", "contact": {"phone": "138****1234"}},
  "items": [{"name": "商品A", "price": 100}, {"name": "商品B", "price": 200}],
  "shipping": {"address": "北京市", "method": "快递"}
}');

-- 复杂路径提取
SELECT 
  id,
  order_data->>'$.customer.name' as customer_name,
  order_data->>'$.customer.contact.phone' as phone,
  JSON_EXTRACT(order_data, '$.items[*].name') as item_names
FROM orders;
```

**⚡ 条件查询优化**
```sql
-- JSON字段条件查询
SELECT * FROM orders WHERE order_data->>'$.customer.name' = '张三';

-- 数值范围查询
SELECT * FROM orders WHERE JSON_EXTRACT(order_data, '$.items[0].price') > 150;

-- 数组长度检查
SELECT * FROM orders WHERE JSON_LENGTH(order_data, '$.items') > 1;
```

### 4.2 JSON_TABLE展开数组（MySQL 8.0+）


**📋 数组元素展开**
```sql
-- 将JSON数组展开为关系型数据
SELECT o.id, jt.*
FROM orders o
JOIN JSON_TABLE(
  o.order_data, 
  '$.items[*]' 
  COLUMNS (
    item_name VARCHAR(100) PATH '$.name',
    item_price DECIMAL(10,2) PATH '$.price'
  )
) as jt;

-- 结果：
-- id | item_name | item_price
-- 1  | 商品A     | 100.00
-- 1  | 商品B     | 200.00
```

---

## 5. 🛠️ JSON数据修改操作


### 5.1 批量数据修改策略


**🔄 批量字段更新**
```sql
-- 给所有用户添加默认设置
UPDATE users 
SET profile = JSON_SET(
  profile, 
  '$.settings', JSON_OBJECT('theme', 'light', 'language', 'zh-CN')
);

-- 条件性字段更新
UPDATE users 
SET profile = JSON_SET(
  profile, 
  '$.vip_level', 
  CASE WHEN CAST(profile->>'$.age' AS UNSIGNED) >= 30 THEN 'gold' ELSE 'silver' END
);
```

### 5.2 动态数组操作


**➕ 数组元素管理**
```sql
-- 向数组末尾添加新元素
UPDATE orders 
SET order_data = JSON_ARRAY_APPEND(
  order_data,
  '$.items',
  JSON_OBJECT('name', '商品C', 'price', 300)
);

-- 向指定位置插入元素
UPDATE orders 
SET order_data = JSON_ARRAY_INSERT(
  order_data,
  '$.items[1]',  -- 在索引1位置插入
  JSON_OBJECT('name', '新商品', 'price', 150)
);
```

---

## 6. 🏗️ JSON数据创建与构建


### 6.1 JSON_ARRAY - 创建数组神器


**💻 数组创建示例**
```sql
-- 基础数组创建
SELECT JSON_ARRAY(1, 2, 3, 'hello', true);
-- 结果：[1, 2, 3, "hello", true]

-- 嵌套数组创建
SELECT JSON_ARRAY(
  JSON_OBJECT('name', '张三', 'age', 25),
  JSON_OBJECT('name', '李四', 'age', 30)
);

-- 实际应用：构建商品标签
SELECT product_id, JSON_ARRAY(category, brand, color) as tags FROM products;
```

### 6.2 JSON_OBJECT - 创建对象利器


**💻 对象创建示例**
```sql
-- 基础对象创建
SELECT JSON_OBJECT('name', '张三', 'age', 25, 'city', '北京');
-- 结果：{"name": "张三", "age": 25, "city": "北京"}

-- 嵌套对象创建
SELECT JSON_OBJECT(
  'user', JSON_OBJECT('name', '张三', 'age', 25),
  'settings', JSON_OBJECT('theme', 'dark', 'lang', 'zh')
);

-- 构建API响应格式
SELECT JSON_OBJECT(
  'status', 'success',
  'data', JSON_OBJECT('user_id', u.id, 'name', u.name),
  'timestamp', NOW()
) FROM users u WHERE u.id = 1;
```

### 6.3 JSON_MERGE - 文档合并操作


**💻 合并操作示例**
```sql
-- 对象合并
SET @obj1 = '{"name": "张三", "age": 25}';
SET @obj2 = '{"city": "北京", "active": true}';
SELECT JSON_MERGE_PRESERVE(@obj1, @obj2);
-- 结果：{"name": "张三", "age": 25, "city": "北京", "active": true}

-- 数组合并
SELECT JSON_MERGE_PRESERVE('[1,2,3]', '[4,5,6]');
-- 结果：[1, 2, 3, 4, 5, 6]

-- 配置更新合并
UPDATE users 
SET profile = JSON_MERGE_PRESERVE(
  profile,
  JSON_OBJECT('last_login', NOW(), 'device', 'mobile')
) WHERE id = 1;
```

---

## 7. ✅ JSON数据验证与类型检测


### 7.1 JSON_VALID - 格式验证守护者


**💻 格式验证示例**
```sql
-- 基础格式验证
SELECT 
  JSON_VALID('{"name": "张三"}') as valid1,    -- 1
  JSON_VALID('{"name": 张三}') as valid2,      -- 0 (缺少引号)
  JSON_VALID('[1,2,3]') as valid3,            -- 1
  JSON_VALID('[1,2,3,]') as valid4;           -- 0 (尾部逗号)

-- 数据导入安全验证
CREATE TABLE temp_import (
  raw_data TEXT,
  is_valid BOOLEAN GENERATED ALWAYS AS (JSON_VALID(raw_data))
);

-- 只处理有效数据
INSERT INTO users (profile)
SELECT CAST(raw_data AS JSON) FROM temp_import WHERE is_valid = 1;
```

### 7.2 JSON_TYPE - 类型检测专家


**📊 类型检测示例**
```sql
-- 各种JSON类型检测
SELECT 
  JSON_TYPE('{}') as object_type,         -- OBJECT
  JSON_TYPE('[]') as array_type,          -- ARRAY
  JSON_TYPE('"hello"') as string_type,    -- STRING
  JSON_TYPE('123') as number_type,        -- INTEGER
  JSON_TYPE('true') as boolean_type;      -- BOOLEAN

-- 动态类型处理
SELECT 
  id,
  CASE JSON_TYPE(JSON_EXTRACT(profile, '$.tags'))
    WHEN 'ARRAY' THEN JSON_LENGTH(profile, '$.tags')
    WHEN 'STRING' THEN 1
    ELSE 0
  END as tag_count
FROM users;
```

---

## 8. 📈 JSON聚合函数应用


### 8.1 JSON_ARRAYAGG - 数组聚合


**💻 数组聚合示例**
```sql
-- 创建部门员工数据
CREATE TABLE departments (id INT, name VARCHAR(50));
CREATE TABLE employees (id INT, name VARCHAR(50), dept_id INT, salary DECIMAL(10,2));

INSERT INTO departments VALUES (1, '技术部'), (2, '销售部');
INSERT INTO employees VALUES (1, '张三', 1, 8000), (2, '李四', 1, 9000), (3, '王五', 2, 7000);

-- 按部门聚合员工
SELECT 
  d.name as department,
  JSON_ARRAYAGG(e.name) as employees
FROM departments d
LEFT JOIN employees e ON d.id = e.dept_id
GROUP BY d.id, d.name;
-- 结果：技术部 -> ["张三", "李四"]

-- 聚合复杂对象
SELECT 
  d.name,
  JSON_ARRAYAGG(JSON_OBJECT('name', e.name, 'salary', e.salary)) as details
FROM departments d
JOIN employees e ON d.id = e.dept_id
GROUP BY d.id, d.name;
```

### 8.2 JSON_OBJECTAGG - 对象聚合


**💻 对象聚合示例**
```sql
-- 基础对象聚合
SELECT JSON_OBJECTAGG(e.name, e.salary) as salary_map
FROM employees e WHERE e.dept_id = 1;
-- 结果：{"张三": 8000, "李四": 9000}

-- 部门薪资统计
SELECT 
  d.name as department,
  JSON_OBJECTAGG(e.name, e.salary) as salary_details
FROM departments d
JOIN employees e ON d.id = e.dept_id
GROUP BY d.id, d.name;
```

---

## 9. ⚡ JSON函数性能优化


### 9.1 JSON函数性能特点


**🔍 性能分析基础**
```
性能影响因素：
1. 文档大小：越大的JSON文档处理越慢
2. 嵌套深度：深层嵌套的路径访问成本更高
3. 索引支持：是否有适当的索引支持
4. 函数类型：提取 > 修改 > 聚合

性能对比（相对速度）：
JSON_EXTRACT (->)   : ⭐⭐⭐⭐⭐ 最快
JSON_UNQUOTE (->>)  : ⭐⭐⭐⭐☆ 快
JSON_SET/INSERT     : ⭐⭐⭐☆☆ 中等
JSON_MERGE          : ⭐⭐☆☆☆ 较慢
JSON_ARRAYAGG       : ⭐⭐☆☆☆ 慢
```

### 9.2 索引优化策略


**🎯 生成列索引优化**
```sql
-- 为常用JSON路径创建生成列
CREATE TABLE user_profiles (
  id INT PRIMARY KEY,
  profile JSON,
  -- 生成列
  user_name VARCHAR(100) GENERATED ALWAYS AS (profile->>'$.name') STORED,
  user_age INT GENERATED ALWAYS AS (CAST(profile->>'$.age' AS UNSIGNED)) STORED,
  user_city VARCHAR(50) GENERATED ALWAYS AS (profile->>'$.city') STORED
);

-- 为生成列添加索引
CREATE INDEX idx_user_age ON user_profiles(user_age);
CREATE INDEX idx_user_city ON user_profiles(user_city);

-- 使用索引优化查询（比直接JSON路径查询快很多）
SELECT * FROM user_profiles WHERE user_age > 25 AND user_city = '北京';
```

### 9.3 查询优化技巧


**⚡ 高效查询模式**
```sql
-- 低效写法：多次JSON解析
SELECT profile->>'$.name', profile->>'$.age', profile->>'$.city' 
FROM user_profiles WHERE profile->>'$.age' > '30';

-- 高效写法：使用生成列
SELECT user_name, user_age, user_city 
FROM user_profiles WHERE user_age > 30;

-- 减少JSON解析次数
SELECT 
  JSON_UNQUOTE(JSON_EXTRACT(profile_data, '$.name')) as name,
  JSON_UNQUOTE(JSON_EXTRACT(profile_data, '$.age')) as age
FROM (
  SELECT JSON_EXTRACT(profile, '$.basic') as profile_data FROM user_profiles
) t;
```

---

## 10. 🎯 JSON索引策略与最佳实践


### 10.1 索引策略选择指南


**🔍 索引类型适用场景**
```
生成列索引 - 适用于：
✅ 固定JSON路径的频繁查询
✅ 简单数据类型提取（字符串、数字）
✅ 需要范围查询和排序

多值索引 - 适用于：
✅ JSON数组元素查询  
✅ 标签、分类等多值查询
✅ IN/CONTAINS操作优化

函数索引 - 适用于：
✅ 复杂表达式计算
✅ 数据转换和格式化
```

### 10.2 数据建模最佳实践


**🏗️ JSON结构设计**
```sql
-- 良好的JSON结构设计
CREATE TABLE optimized_users (
  id INT PRIMARY KEY,
  basic_info JSON COMMENT '基础信息',
  contact_info JSON COMMENT '联系信息',
  preferences JSON COMMENT '用户偏好',
  
  -- 关键字段生成列
  user_name VARCHAR(100) GENERATED ALWAYS AS (basic_info->>'$.name') STORED,
  user_age INT GENERATED ALWAYS AS (CAST(basic_info->>'$.age' AS UNSIGNED)) STORED,
  user_email VARCHAR(200) GENERATED ALWAYS AS (contact_info->>'$.email') STORED,
  
  -- 索引策略
  INDEX idx_name (user_name),
  INDEX idx_age (user_age),
  INDEX idx_email (user_email)
);
```

### 10.3 维护和监控


**🔧 数据一致性检查**
```sql
-- JSON数据验证
SELECT id, 'basic_info invalid' as issue
FROM optimized_users WHERE NOT JSON_VALID(basic_info)
UNION ALL
SELECT id, 'contact_info invalid' 
FROM optimized_users WHERE NOT JSON_VALID(contact_info);

-- 数据结构统计
SELECT 
  'basic_info' as field,
  JSON_KEYS(basic_info) as keys,
  COUNT(*) as count
FROM optimized_users
WHERE basic_info IS NOT NULL
GROUP BY JSON_KEYS(basic_info);
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


**🔸 JSON函数分类理解**
```
数据提取类：
• JSON_EXTRACT (->)：提取JSON值，保留格式
• JSON_UNQUOTE (->>)：提取并去引号，返回纯文本

数据修改类：
• JSON_SET：万能设置（存在更新，不存在新增）
• JSON_INSERT：只插入新值（不覆盖已有）
• JSON_REPLACE：只更新已存在的值
• JSON_REMOVE：删除指定路径元素

数据创建类：
• JSON_ARRAY：创建JSON数组
• JSON_OBJECT：创建JSON对象  
• JSON_MERGE：合并JSON文档

数据验证类：
• JSON_VALID：验证JSON格式
• JSON_TYPE：检测数据类型
• JSON_KEYS：获取对象键名
```

### 11.2 关键理解要点


**🔹 JSON路径表达式精通**
```
基础语法：
• $ = 根节点（必须有）
• .property = 对象属性访问
• [index] = 数组索引访问
• [*] = 所有同级元素

实用示例：
• $.user.profile.name - 嵌套对象访问
• $.items[0].price - 数组中对象属性
• $.tags[*] - 获取数组所有元素
```

**🔹 -> vs ->> 操作符区别**
```
-> (JSON_EXTRACT)：
• 返回JSON格式（带引号）：profile->'$.name' → "张三"
• 用于JSON函数链式调用

->> (JSON_UNQUOTE)：
• 返回纯文本（无引号）：profile->>'$.name' → 张三  
• 用于条件查询和显示

选择原则：查询条件用->>，JSON操作用->
```

**🔹 性能优化核心策略**
```
1. 生成列索引：为常用JSON路径创建生成列和索引
2. 多值索引：为JSON数组创建多值索引
3. 查询重写：减少重复JSON解析
4. 数据分离：分离热点和冷门JSON字段
```

### 11.3 实际应用指导


**💼 应用场景最佳实践**
```
用户配置管理：
✅ 使用JSON_OBJECT构建配置
✅ 用JSON_MERGE更新部分配置
✅ 为常用配置项创建生成列索引

商品属性存储：
✅ 分类存储（基础属性 + 扩展属性）
✅ 使用JSON_VALID验证属性格式
✅ 为搜索属性创建多值索引

API数据交换：
✅ JSON_OBJECT构建标准响应格式
✅ JSON_SET动态添加字段
✅ JSON_VALID验证请求数据
```

### 11.4 常见陷阱避免


**⚠️ 必须避免的错误**
```
路径表达式错误：
❌ 'user.name'（缺少$根符号）
✅ '$.user.name'

类型比较错误：
❌ profile->'$.city' = '北京'（JSON格式比较）
✅ profile->>'$.city' = '北京'（字符串比较）

索引优化遗漏：
❌ 直接对JSON路径建索引
✅ 使用生成列建索引

性能陷阱：
❌ 在大表上频繁使用复杂JSON函数
✅ 提前优化热点查询路径
```

**🎯 最佳实践总结**
```
设计原则：
• JSON用于灵活字段，固定字段仍用普通列
• 为常用查询路径创建生成列索引  
• 验证JSON数据格式和结构完整性
• 监控JSON函数查询性能

查询优化：
• 优先使用生成列而不是JSON路径
• 避免在大数据集上使用聚合JSON函数
• 合理设计JSON文档结构和大小

维护策略：
• 定期检查JSON数据有效性
• 监控JSON相关查询性能
• 及时清理无用的JSON字段
```

**🧠 记忆口诀**
```
JSON函数用法口诀：
"提取用箭头，修改分三种，创建靠两将，验证保安全"

性能优化口诀：  
"生成列索引是王道，路径查询要慎用，结构设计要合理，监控维护不能少"
```