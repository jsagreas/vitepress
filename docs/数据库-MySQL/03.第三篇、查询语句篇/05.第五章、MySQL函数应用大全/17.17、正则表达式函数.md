---
title: 17、正则表达式函数
---
## 📚 目录

1. [正则表达式函数概述](#1-正则表达式函数概述)
2. [REGEXP正则匹配基础](#2-REGEXP正则匹配基础)
3. [REGEXP_REPLACE替换函数](#3-REGEXP_REPLACE替换函数)
4. [REGEXP_SUBSTR提取函数](#4-REGEXP_SUBSTR提取函数)
5. [REGEXP_INSTR位置查找](#5-REGEXP_INSTR位置查找)
6. [REGEXP_LIKE条件匹配](#6-REGEXP_LIKE条件匹配)
7. [正则表达式语法详解](#7-正则表达式语法详解)
8. [正则表达式性能优化](#8-正则表达式性能优化)
9. [最佳实践与案例](#9-最佳实践与案例)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📖 正则表达式函数概述


### 1.1 什么是正则表达式


**🔸 正则表达式的本质**
正则表达式（Regular Expression）就像是一个非常聪明的"文本搜索器"。想象你要在一本厚厚的电话簿里找电话号码，普通搜索只能找固定的号码，但正则表达式能找到所有符合"手机号码格式"的内容。

```
传统匹配：只能找完全相同的
LIKE 'iPhone'  -- 只能找到完全是"iPhone"的文本

正则表达式：可以找符合模式的
REGEXP '[0-9]{11}'  -- 能找到所有11位数字（手机号）
REGEXP '[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}'  -- 能找到邮箱格式
```

> **💡 关键理解**：正则表达式是用特殊符号组成的"模式"，用来描述一类字符串的特征，而不是具体的字符串内容。

### 1.2 MySQL中的正则表达式函数家族


**🔸 MySQL 8.0正则函数全览**

| 函数名 | **作用** | **返回值** | **使用场景** |
|--------|---------|-----------|-------------|
| `REGEXP` | `判断是否匹配` | `0或1` | `WHERE条件筛选` |
| `REGEXP_LIKE()` | `增强版匹配判断` | `TRUE/FALSE` | `复杂条件匹配` |
| `REGEXP_REPLACE()` | `查找并替换` | `替换后的字符串` | `数据清洗、格式转换` |
| `REGEXP_SUBSTR()` | `提取匹配内容` | `匹配的子字符串` | `数据提取、解析` |
| `REGEXP_INSTR()` | `查找匹配位置` | `位置索引` | `定位特定内容` |

### 1.3 为什么要使用正则表达式


**🎯 解决的实际问题**

```
🔸 数据验证问题
场景：验证用户输入的手机号、邮箱是否合法
传统方法：写很多IF-ELSE判断，复杂且容易遗漏
正则方法：一个模式搞定所有情况

🔸 数据清洗问题  
场景：从杂乱的文本中提取有用信息
示例：从"联系电话：138-8888-8888"中提取纯数字
传统方法：多次字符串函数嵌套，代码复杂
正则方法：一个表达式直接提取

🔸 数据格式转换
场景：统一数据格式，如日期、电话号码格式
传统方法：复杂的字符串处理逻辑
正则方法：强大的查找替换功能
```

---

## 2. 🔍 REGEXP正则匹配基础


### 2.1 REGEXP基本语法


**🔸 REGEXP操作符用法**

```sql
-- 基本语法
SELECT column FROM table WHERE column REGEXP 'pattern';

-- 简单示例：查找包含数字的用户名
SELECT username FROM users WHERE username REGEXP '[0-9]';

-- 等价写法（MySQL中REGEXP和RLIKE相同）
SELECT username FROM users WHERE username RLIKE '[0-9]';
```

**🔸 REGEXP与LIKE的区别**

```sql
-- LIKE：简单模式匹配
SELECT * FROM products WHERE name LIKE '%phone%';
-- 只能用 % 和 _ 通配符

-- REGEXP：强大的模式匹配  
SELECT * FROM products WHERE name REGEXP 'i?[Pp]hone';
-- 能使用复杂的正则表达式模式
```

### 2.2 常用匹配模式


**🔧 基础匹配模式**

```sql
-- 1. 字符匹配
SELECT name FROM users WHERE name REGEXP '^张';        -- 以"张"开头
SELECT name FROM users WHERE name REGEXP '王$';        -- 以"王"结尾
SELECT name FROM users WHERE name REGEXP '张.*李';     -- 包含"张"和"李"

-- 2. 数字匹配
SELECT phone FROM contacts WHERE phone REGEXP '^1[3-9][0-9]{9}$';  -- 手机号
SELECT id FROM orders WHERE id REGEXP '^[0-9]+$';                  -- 纯数字

-- 3. 字母匹配
SELECT email FROM users WHERE email REGEXP '^[a-zA-Z]';    -- 字母开头
SELECT code FROM products WHERE code REGEXP '[A-Z]{3}[0-9]{3}';  -- 3字母3数字
```

**📊 匹配模式对照表**

| 模式 | **含义** | **示例** | **匹配结果** |
|------|---------|---------|-------------|
| `^` | `行开始` | `^张` | `张三、张丽` |
| `$` | `行结束` | `王$` | `李王、小王` |
| `.` | `任意字符` | `a.c` | `abc、a1c、a@c` |
| `*` | `0次或多次` | `ab*c` | `ac、abc、abbc` |
| `+` | `1次或多次` | `ab+c` | `abc、abbc` |
| `?` | `0次或1次` | `ab?c` | `ac、abc` |
| `[abc]` | `字符集合` | `[abc]123` | `a123、b123、c123` |

### 2.3 实际应用案例


**🎯 用户数据验证**

```sql
-- 查找手机号格式正确的用户
SELECT user_id, name, phone 
FROM users 
WHERE phone REGEXP '^1[3-9][0-9]{9}$';

-- 查找邮箱格式的联系方式
SELECT name, contact 
FROM customers 
WHERE contact REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';

-- 查找包含中文的商品名称
SELECT product_id, name 
FROM products 
WHERE name REGEXP '[\u4e00-\u9fff]';
```

**🔍 数据质量检查**

```sql
-- 检查身份证号格式（18位数字或17位数字+X）
SELECT customer_id, id_card
FROM customers 
WHERE id_card NOT REGEXP '^[0-9]{17}[0-9Xx]$';

-- 查找可能的重复用户名（相似模式）
SELECT username 
FROM users 
WHERE username REGEXP '^(test|demo|admin)[0-9]*$'
ORDER BY username;
```

---

## 3. 🔄 REGEXP_REPLACE替换函数


### 3.1 REGEXP_REPLACE基本用法


**🔸 函数语法结构**

```sql
REGEXP_REPLACE(source_string, pattern, replacement[, position[, occurrence[, match_type]]])
```

**参数说明：**
- `source_string`：要处理的原始字符串
- `pattern`：正则表达式模式
- `replacement`：替换内容
- `position`：开始位置（可选，默认1）
- `occurrence`：替换第几个匹配（可选，默认0表示全部）
- `match_type`：匹配类型（可选，如'i'表示不区分大小写）

### 3.2 数据清洗应用


**🔧 电话号码格式统一**

```sql
-- 将各种格式的电话号码统一为纯数字
SELECT 
    customer_name,
    phone AS original_phone,
    REGEXP_REPLACE(phone, '[^0-9]', '') AS clean_phone
FROM customers;

-- 原始数据                    清洗结果
-- 138-8888-8888       -->    13888888888
-- (021)6666-7777      -->    02166667777
-- +86 135 0000 1111   -->    8613500001111
```

**🔧 HTML标签清理**

```sql
-- 从商品描述中移除HTML标签
UPDATE products 
SET clean_description = REGEXP_REPLACE(description, '<[^>]*>', '', 1, 0, 'g')
WHERE description REGEXP '<[^>]*>';

-- 示例转换
-- 原始：<p>这是一个<strong>优质</strong>产品</p>
-- 结果：这是一个优质产品
```

### 3.3 格式转换应用


**🔧 日期格式标准化**

```sql
-- 将MM/DD/YYYY格式转换为YYYY-MM-DD格式
SELECT 
    event_name,
    event_date,
    REGEXP_REPLACE(
        event_date, 
        '^([0-9]{1,2})/([0-9]{1,2})/([0-9]{4})$', 
        '\\3-\\1-\\2'
    ) AS standard_date
FROM events 
WHERE event_date REGEXP '^[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}$';

-- 转换示例：
-- 12/25/2023  -->  2023-12-25
-- 1/1/2024    -->  2024-1-1
```

**🔧 文本格式美化**

```sql
-- 将驼峰命名转换为下划线命名
SELECT 
    field_name,
    REGEXP_REPLACE(
        REGEXP_REPLACE(field_name, '([a-z])([A-Z])', '\\1_\\2', 1, 0, 'g'),
        '([A-Z])', 
        LOWER('\\1'), 
        1, 0, 'g'
    ) AS snake_case_name
FROM table_fields;

-- 转换示例：
-- UserName     -->  user_name
-- ProductInfo  -->  product_info
-- OrderID      -->  order_id
```

### 3.4 高级替换技巧


**🔧 条件替换**

```sql
-- 敏感信息脱敏：保留前3位和后4位，中间用*替代
SELECT 
    customer_name,
    REGEXP_REPLACE(phone, '^([0-9]{3})[0-9]+([0-9]{4})$', '\\1****\\2') AS masked_phone
FROM customers
WHERE phone REGEXP '^[0-9]{11}$';

-- 结果示例：
-- 13888888888  -->  138****8888
```

**🔧 多模式替换**

```sql
-- 统一处理多种分隔符
SELECT 
    product_tags,
    REGEXP_REPLACE(
        REGEXP_REPLACE(
            REGEXP_REPLACE(product_tags, '[,;|]', '、', 1, 0, 'g'),
            '\\s+', 
            '', 
            1, 0, 'g'
        ),
        '、+',
        '、',
        1, 0, 'g'
    ) AS formatted_tags
FROM products;

-- 转换示例：
-- 原始：电子产品, 手机;苹果|iPhone
-- 结果：电子产品、手机、苹果、iPhone
```

---

## 4. ✂️ REGEXP_SUBSTR提取函数


### 4.1 REGEXP_SUBSTR基本语法


**🔸 函数完整语法**

```sql
REGEXP_SUBSTR(source_string, pattern[, position[, occurrence[, match_type]]])
```

这个函数就像是一个"智能剪刀"，能从一大段文字中精确地"剪出"你需要的部分。

### 4.2 数据提取应用


**🔧 从复合信息中提取关键数据**

```sql
-- 从商品标题中提取品牌信息
SELECT 
    product_title,
    REGEXP_SUBSTR(product_title, '^[A-Za-z]+') AS brand,
    REGEXP_SUBSTR(product_title, '[0-9]+GB') AS memory,
    REGEXP_SUBSTR(product_title, '[0-9]+寸') AS screen_size
FROM products
WHERE product_title REGEXP '^[A-Za-z].*[0-9]+';

-- 示例数据：
-- 标题：Apple iPhone 14 Pro 256GB 6.1寸
-- 品牌：Apple
-- 内存：256GB  
-- 尺寸：6.1寸
```

**🔧 从文本中提取联系信息**

```sql
-- 从客户备注中提取各种联系方式
SELECT 
    customer_id,
    notes,
    REGEXP_SUBSTR(notes, '1[3-9][0-9]{9}') AS mobile_phone,
    REGEXP_SUBSTR(notes, '0[0-9]{2,3}-?[0-9]{7,8}') AS landline,
    REGEXP_SUBSTR(notes, '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}') AS email
FROM customers
WHERE notes IS NOT NULL;
```

### 4.3 位置和次数控制


**🔧 提取指定位置的匹配内容**

```sql
-- 提取第2个出现的数字
SELECT 
    text_content,
    REGEXP_SUBSTR(text_content, '[0-9]+', 1, 1) AS first_number,   -- 第1个数字
    REGEXP_SUBSTR(text_content, '[0-9]+', 1, 2) AS second_number,  -- 第2个数字
    REGEXP_SUBSTR(text_content, '[0-9]+', 1, 3) AS third_number    -- 第3个数字
FROM data_table;

-- 示例：
-- 文本：订单编号123，金额456元，客户ID789
-- 第1个：123
-- 第2个：456  
-- 第3个：789
```

**🔧 从指定位置开始提取**

```sql
-- 从字符串第10个位置开始查找邮箱
SELECT 
    long_text,
    REGEXP_SUBSTR(long_text, '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', 10) AS email_from_pos10
FROM text_data;
```

### 4.4 复杂提取案例


**🔧 日志解析**

```sql
-- 从访问日志中提取关键信息
SELECT 
    log_line,
    REGEXP_SUBSTR(log_line, '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}') AS ip_address,
    REGEXP_SUBSTR(log_line, '\\[[^\\]]+\\]') AS timestamp,
    REGEXP_SUBSTR(log_line, '"[A-Z]+ [^"]*"') AS request,
    REGEXP_SUBSTR(log_line, '[0-9]{3}\\s') AS status_code
FROM access_logs
WHERE log_line REGEXP '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}';

-- 日志示例：
-- 192.168.1.100 - - [25/Dec/2023:10:00:00 +0000] "GET /api/users HTTP/1.1" 200 1234
-- IP：192.168.1.100
-- 时间：[25/Dec/2023:10:00:00 +0000]
-- 请求："GET /api/users HTTP/1.1"
-- 状态：200
```

**🔧 配置文件解析**

```sql
-- 从配置字符串中提取键值对
SELECT 
    config_line,
    REGEXP_SUBSTR(config_line, '^[^=]+') AS config_key,
    REGEXP_SUBSTR(config_line, '=(.*)$', 1, 1, NULL, 1) AS config_value
FROM system_configs
WHERE config_line REGEXP '^[^=]+=.*';

-- 配置示例：
-- database_host=192.168.1.100
-- 键：database_host
-- 值：192.168.1.100
```

---

## 5. 🎯 REGEXP_INSTR位置查找


### 5.1 REGEXP_INSTR功能说明


**🔸 函数作用**
`REGEXP_INSTR`就像是一个"定位器"，能告诉你要找的内容在字符串中的具体位置。这在数据分析和处理中非常有用。

```sql
-- 基本语法
REGEXP_INSTR(source_string, pattern[, position[, occurrence[, return_option[, match_type]]]])
```

**参数详解：**
- `return_option`：返回选项（0返回匹配开始位置，1返回匹配结束位置+1）

### 5.2 基础定位应用


**🔧 查找特定内容位置**

```sql
-- 找到第一个数字出现的位置
SELECT 
    product_name,
    REGEXP_INSTR(product_name, '[0-9]') AS first_digit_position,
    REGEXP_INSTR(product_name, '[0-9]+') AS first_number_start,
    REGEXP_INSTR(product_name, '[0-9]+', 1, 1, 1) AS first_number_end
FROM products;

-- 示例：
-- 产品名：iPhone 14 Pro Max
-- 首个数字位置：8 (字符'1'的位置)
-- 数字开始位置：8
-- 数字结束位置：10 (数字'14'后的位置)
```

**🔧 多次匹配定位**

```sql
-- 找到第2个、第3个邮箱地址的位置
SELECT 
    text_content,
    REGEXP_INSTR(text_content, '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', 1, 1) AS email1_pos,
    REGEXP_INSTR(text_content, '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', 1, 2) AS email2_pos,
    REGEXP_INSTR(text_content, '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', 1, 3) AS email3_pos
FROM contact_info;
```

### 5.3 数据验证应用


**🔧 验证数据格式位置**

```sql
-- 检查身份证号码格式，找出格式错误的位置
SELECT 
    customer_id,
    id_card,
    CASE 
        WHEN LENGTH(id_card) != 18 THEN '长度错误'
        WHEN REGEXP_INSTR(id_card, '[^0-9Xx]') > 0 THEN 
            CONCAT('位置', REGEXP_INSTR(id_card, '[^0-9Xx]'), '字符无效')
        WHEN REGEXP_INSTR(id_card, '[Xx]') NOT IN (0, 18) THEN 
            CONCAT('X只能在末位，当前位置：', REGEXP_INSTR(id_card, '[Xx]'))
        ELSE '格式正确'
    END AS validation_result
FROM customers;
```

### 5.4 文本分析应用


**🔧 关键词密度分析**

```sql
-- 分析产品描述中关键词出现的位置分布
SELECT 
    product_id,
    description,
    (REGEXP_INSTR(description, '优质|高品质|精品', 1, 1) > 0) AS has_quality_word,
    REGEXP_INSTR(description, '优惠|特价|折扣', 1, 1) AS promotion_word_position,
    REGEXP_INSTR(description, '包邮|免运费', 1, 1) AS shipping_word_position
FROM products
WHERE description IS NOT NULL;
```

**🔧 文本结构分析**

```sql
-- 分析文章段落结构
SELECT 
    article_id,
    content,
    REGEXP_INSTR(content, '\n\n') AS first_paragraph_end,
    (LENGTH(content) - LENGTH(REPLACE(content, '\n\n', ''))) / 2 AS paragraph_count,
    CASE 
        WHEN REGEXP_INSTR(content, '第[一二三四五六七八九十]章') > 0 THEN '有章节结构'
        WHEN REGEXP_INSTR(content, '[0-9]+\\.') > 0 THEN '有序号结构'  
        ELSE '普通文本'
    END AS text_structure
FROM articles;
```

---

## 6. ✅ REGEXP_LIKE条件匹配


### 6.1 REGEXP_LIKE增强匹配


**🔸 REGEXP_LIKE vs REGEXP的区别**

`REGEXP_LIKE`是`REGEXP`的增强版本，提供了更多的控制选项和更清晰的语法。

```sql
-- 传统REGEXP写法
SELECT * FROM users WHERE email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$';

-- REGEXP_LIKE写法（更清晰）
SELECT * FROM users 
WHERE REGEXP_LIKE(email, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
```

### 6.2 匹配类型控制


**🔧 大小写控制**

```sql
-- 不区分大小写匹配
SELECT product_name
FROM products 
WHERE REGEXP_LIKE(product_name, 'iphone', 'i');  -- 'i'表示忽略大小写

-- 区分大小写匹配（默认）
SELECT product_name
FROM products 
WHERE REGEXP_LIKE(product_name, 'iPhone', 'c');  -- 'c'表示区分大小写
```

**🔧 多行匹配控制**

```sql
-- 多行模式匹配
SELECT article_id, title, content
FROM articles
WHERE REGEXP_LIKE(content, '^标题：.*$', 'm');  -- 'm'表示多行模式

-- 单行模式（点号匹配换行符）
SELECT log_id, log_content
FROM system_logs
WHERE REGEXP_LIKE(log_content, 'ERROR.*CRITICAL', 's');  -- 's'表示单行模式
```

### 6.3 复杂条件组合


**🔧 多条件验证**

```sql
-- 密码强度验证（至少8位，包含大小写字母和数字）
SELECT 
    user_id,
    username,
    CASE 
        WHEN REGEXP_LIKE(password_hash, '^.{8,}$') 
             AND REGEXP_LIKE(password_hash, '[a-z]')
             AND REGEXP_LIKE(password_hash, '[A-Z]') 
             AND REGEXP_LIKE(password_hash, '[0-9]') THEN '强密码'
        WHEN REGEXP_LIKE(password_hash, '^.{6,}$')
             AND REGEXP_LIKE(password_hash, '[a-zA-Z]')
             AND REGEXP_LIKE(password_hash, '[0-9]') THEN '中等密码'
        ELSE '弱密码'
    END AS password_strength
FROM users;
```

**🔧 数据分类验证**

```sql
-- 根据商品编码规则分类
SELECT 
    product_code,
    product_name,
    CASE 
        WHEN REGEXP_LIKE(product_code, '^ELE[0-9]{6}$', 'i') THEN '电子产品'
        WHEN REGEXP_LIKE(product_code, '^CLO[0-9]{6}$', 'i') THEN '服装产品'
        WHEN REGEXP_LIKE(product_code, '^BOO[0-9]{6}$', 'i') THEN '图书产品'
        WHEN REGEXP_LIKE(product_code, '^[A-Z]{3}[0-9]{6}$') THEN '其他产品'
        ELSE '编码格式错误'
    END AS product_category
FROM products;
```

### 6.4 性能优化应用


**🔧 索引友好的查询**

```sql
-- 结合索引使用正则表达式
-- 假设phone字段有前缀索引
SELECT customer_id, name, phone
FROM customers 
WHERE phone LIKE '138%'  -- 先用索引过滤
  AND REGEXP_LIKE(phone, '^138[0-9]{8}$');  -- 再用正则精确匹配

-- 比直接用正则表达式效率更高
-- SELECT customer_id, name, phone
-- FROM customers 
-- WHERE REGEXP_LIKE(phone, '^138[0-9]{8}$');  -- 全表扫描
```

---

## 7. 📖 正则表达式语法详解


### 7.1 基础元字符


**🔸 位置匹配符**

```sql
-- ^ 开始位置
SELECT name FROM users WHERE name REGEXP '^张';  -- 姓张的人

-- $ 结束位置  
SELECT email FROM users WHERE email REGEXP '\\.com$';  -- .com邮箱

-- \\b 单词边界
SELECT content FROM articles WHERE content REGEXP '\\bmysql\\b';  -- 完整的"mysql"单词
```

**🔸 数量修饰符**

```sql
-- * 零次或多次
SELECT phone FROM contacts WHERE phone REGEXP '^[0-9]*$';  -- 纯数字（可以为空）

-- + 一次或多次
SELECT phone FROM contacts WHERE phone REGEXP '^[0-9]+$';  -- 纯数字（不能为空）

-- ? 零次或一次
SELECT url FROM websites WHERE url REGEXP '^https?://';  -- http或https

-- {n} 精确n次
SELECT code FROM products WHERE code REGEXP '^[A-Z]{3}[0-9]{4}$';  -- 3字母4数字

-- {n,m} n到m次
SELECT password FROM users WHERE password REGEXP '^.{8,16}$';  -- 8-16位字符
```

### 7.2 字符类和分组


**🔸 字符类**

```sql
-- [abc] 字符集合
SELECT grade FROM students WHERE grade REGEXP '^[ABC]$';  -- A、B、C等级

-- [^abc] 否定字符集
SELECT username FROM users WHERE username REGEXP '[^0-9]';  -- 包含非数字字符

-- [a-z] 字符范围
SELECT name FROM products WHERE name REGEXP '^[a-zA-Z ]+$';  -- 只包含字母和空格

-- 预定义字符类
-- [[:digit:]] 等价于 [0-9]
-- [[:alpha:]] 等价于 [a-zA-Z]  
-- [[:alnum:]] 等价于 [a-zA-Z0-9]
-- [[:space:]] 空白字符
```

**🔸 分组和引用**

```sql
-- 分组 ()
SELECT name FROM users 
WHERE name REGEXP '^(张|李|王)[a-zA-Z]*';  -- 张、李、王开头的姓名

-- 反向引用 \\1, \\2
-- 查找重复字符
SELECT text FROM data WHERE text REGEXP '([a-z])\\1';  -- 包含重复字母

-- 在REGEXP_REPLACE中使用分组
SELECT 
    phone,
    REGEXP_REPLACE(phone, '^([0-9]{3})([0-9]{4})([0-9]{4})$', '\\1-\\2-\\3') AS formatted_phone
FROM contacts;
-- 13812345678 变成 138-1234-5678
```

### 7.3 高级语法特性


**🔸 贪婪与非贪婪匹配**

```sql
-- 贪婪匹配（默认）
SELECT REGEXP_SUBSTR('<div>内容1</div><div>内容2</div>', '<div>.*</div>') AS greedy_match;
-- 结果：<div>内容1</div><div>内容2</div> (匹配最长的)

-- 非贪婪匹配  
SELECT REGEXP_SUBSTR('<div>内容1</div><div>内容2</div>', '<div>.*?</div>') AS non_greedy_match;
-- 结果：<div>内容1</div> (匹配最短的)
```

**🔸 环视断言**

```sql
-- 正向前瞻 (?=pattern)
-- 查找后面跟着数字的字母
SELECT text FROM data WHERE text REGEXP '[a-zA-Z](?=[0-9])';

-- 负向前瞻 (?!pattern)  
-- 查找后面不跟数字的字母
SELECT text FROM data WHERE text REGEXP '[a-zA-Z](?![0-9])';
```

### 7.4 实用语法模式


**🔧 常用验证模式**

```sql
-- 邮箱验证（完整版）
WHERE email REGEXP '^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'

-- 中国手机号验证
WHERE phone REGEXP '^1[3-9][0-9]{9}$'

-- 身份证号验证  
WHERE id_card REGEXP '^[1-9][0-9]{5}(19|20)[0-9]{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])[0-9]{3}[0-9Xx]$'

-- IP地址验证
WHERE ip_address REGEXP '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'

-- URL验证
WHERE url REGEXP '^https?://[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}(/.*)?$'
```

---

## 8. ⚡ 正则表达式性能优化


### 8.1 性能问题分析


**🔸 正则表达式的性能成本**

正则表达式虽然功能强大，但也有性能成本。就像用瑞士军刀切菜一样，虽然能切，但不如菜刀效率高。

```
性能开销来源：

🔸 模式编译开销
每次执行正则表达式都需要编译模式
复杂的正则表达式编译时间更长

🔸 回溯开销  
正则引擎匹配时可能需要回溯尝试
嵌套量词和分组会加剧回溯问题

🔸 全表扫描问题
正则表达式通常无法使用索引
大表查询时性能问题明显
```

### 8.2 正则表达式优化技巧


**🔧 简化正则模式**

```sql
-- ❌ 复杂低效的模式
SELECT * FROM users WHERE email REGEXP '^[a-zA-Z0-9._%+-]*[a-zA-Z0-9][a-zA-Z0-9._%+-]*@[a-zA-Z0-9.-]*[a-zA-Z0-9]\\.[a-zA-Z]{2,}$';

-- ✅ 简化高效的模式
SELECT * FROM users WHERE email REGEXP '^[^@\\s]+@[^@\\s]+\\.[a-zA-Z]{2,}$';
```

**🔧 避免灾难性回溯**

```sql
-- ❌ 可能导致灾难性回溯的模式
SELECT * FROM text_data WHERE content REGEXP '(a+)+b';

-- ✅ 优化后的模式
SELECT * FROM text_data WHERE content REGEXP 'a+b';
```

**🔧 使用锚点限制搜索范围**

```sql
-- ❌ 无锚点，需要搜索整个字符串
SELECT * FROM products WHERE code REGEXP '[A-Z]{3}[0-9]{6}';

-- ✅ 有锚点，明确开始和结束
SELECT * FROM products WHERE code REGEXP '^[A-Z]{3}[0-9]{6}$';
```

### 8.3 索引配合优化


**🔧 前缀过滤 + 正则精确匹配**

```sql
-- ✅ 结合索引的高效查询
SELECT customer_id, name, phone
FROM customers 
WHERE phone LIKE '138%'  -- 利用索引快速过滤
  AND REGEXP_LIKE(phone, '^138[0-9]{8}$');  -- 正则精确验证

-- 性能对比测试（100万记录）：
-- 纯正则查询：3.2秒
-- 索引+正则：0.3秒（提升10倍）
```

**🔧 分阶段过滤**

```sql
-- 多阶段过滤策略
SELECT user_id, email 
FROM users 
WHERE email LIKE '%@gmail.com'  -- 第1阶段：索引过滤
  AND LENGTH(email) BETWEEN 10 AND 50  -- 第2阶段：长度过滤
  AND REGEXP_LIKE(email, '^[a-zA-Z0-9._%+-]+@gmail\\.com$');  -- 第3阶段：正则验证
```

### 8.4 缓存和预编译策略


**🔧 避免重复编译**

```sql
-- ❌ 每次查询都编译正则表达式
SELECT * FROM users WHERE name REGEXP @user_pattern;  -- 变量模式

-- ✅ 使用固定模式（MySQL会缓存编译结果）
SELECT * FROM users WHERE name REGEXP '^[张李王][a-zA-Z]*$';  -- 固定模式
```

**📊 性能测试对比**

```
正则表达式性能测试（100万条记录）：

简单LIKE查询：
WHERE name LIKE '张%'
耗时：0.1秒，使用索引

复杂正则查询：
WHERE name REGEXP '^张[a-zA-Z]*$'  
耗时：2.3秒，全表扫描

优化正则查询：
WHERE name LIKE '张%' AND name REGEXP '^张[a-zA-Z]*$'
耗时：0.4秒，索引+正则
```

---

## 9. 🎯 最佳实践与案例


### 9.1 数据清洗最佳实践


**🔧 电商数据清洗完整流程**

```sql
-- 商品标题规范化处理
UPDATE products SET 
    -- 1. 清理HTML标签
    clean_title = REGEXP_REPLACE(title, '<[^>]*>', '', 1, 0, 'g'),
    
    -- 2. 统一空白字符
    clean_title = REGEXP_REPLACE(clean_title, '\\s+', ' ', 1, 0, 'g'),
    
    -- 3. 清理特殊字符
    clean_title = REGEXP_REPLACE(clean_title, '[^a-zA-Z0-9\\u4e00-\\u9fff\\s]', '', 1, 0, 'g'),
    
    -- 4. 提取品牌信息
    brand = REGEXP_SUBSTR(title, '^[A-Za-z]+'),
    
    -- 5. 提取型号信息  
    model = REGEXP_SUBSTR(title, '[A-Za-z0-9]+(?=\\s|$)', 1, 2),
    
    -- 6. 提取价格信息
    price_extracted = REGEXP_SUBSTR(description, '[0-9]+\\.?[0-9]*元')
    
WHERE title IS NOT NULL;
```

**🔧 用户信息标准化**

```sql
-- 用户联系方式标准化
UPDATE customers SET
    -- 手机号格式统一
    phone_clean = CASE 
        WHEN REGEXP_LIKE(phone, '^1[3-9][0-9]{9}$') THEN phone
        WHEN REGEXP_LIKE(phone, '^[+]?86-?1[3-9][0-9]{9}$') THEN 
            REGEXP_REPLACE(phone, '^[+]?86-?', '')
        WHEN REGEXP_LIKE(phone, '^1[3-9][0-9]{4}[^0-9]+[0-9]{4}$') THEN
            REGEXP_REPLACE(phone, '[^0-9]', '')
        ELSE NULL
    END,
    
    -- 邮箱格式验证和清理
    email_clean = CASE
        WHEN REGEXP_LIKE(email, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') 
        THEN LOWER(TRIM(email))
        ELSE NULL
    END
    
WHERE phone IS NOT NULL OR email IS NOT NULL;
```

### 9.2 数据验证最佳实践


**🔧 多层次验证策略**

```sql
-- 创建数据质量检查视图
CREATE VIEW data_quality_check AS
SELECT 
    customer_id,
    name,
    phone,
    email,
    id_card,
    
    -- 手机号验证
    CASE 
        WHEN phone IS NULL THEN '未填写'
        WHEN REGEXP_LIKE(phone, '^1[3-9][0-9]{9}$') THEN '格式正确'
        WHEN REGEXP_LIKE(phone, '^[0-9]+$') AND LENGTH(phone) = 11 THEN '可能正确'
        ELSE '格式错误'
    END AS phone_status,
    
    -- 邮箱验证
    CASE 
        WHEN email IS NULL THEN '未填写'
        WHEN REGEXP_LIKE(email, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') THEN '格式正确'
        WHEN REGEXP_LIKE(email, '@') THEN '格式可疑'
        ELSE '格式错误'
    END AS email_status,
    
    -- 身份证验证
    CASE 
        WHEN id_card IS NULL THEN '未填写'
        WHEN REGEXP_LIKE(id_card, '^[1-9][0-9]{5}(19|20)[0-9]{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])[0-9]{3}[0-9Xx]$') THEN '格式正确'
        WHEN LENGTH(id_card) = 18 THEN '长度正确但格式可疑'
        ELSE '格式错误'
    END AS id_card_status
    
FROM customers;
```

**🔧 实时数据验证触发器**

```sql
-- 创建数据验证触发器
DELIMITER $$
CREATE TRIGGER validate_customer_data
BEFORE INSERT ON customers
FOR each ROW
BEGIN
    -- 验证手机号
    IF NEW.phone IS NOT NULL AND NOT REGEXP_LIKE(NEW.phone, '^1[3-9][0-9]{9}$') THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '手机号格式错误';
    END IF;
    
    -- 验证邮箱
    IF NEW.email IS NOT NULL AND NOT REGEXP_LIKE(NEW.email, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '邮箱格式错误';
    END IF;
    
    -- 自动清理和标准化
    SET NEW.phone = REGEXP_REPLACE(NEW.phone, '[^0-9]', '');
    SET NEW.email = LOWER(TRIM(NEW.email));
END$$
DELIMITER ;
```

### 9.3 性能优化案例


**🔧 大数据量正则查询优化**

```sql
-- 场景：从1000万条日志中查找特定错误模式

-- ❌ 原始低效查询
SELECT * FROM system_logs 
WHERE REGEXP_LIKE(log_content, 'ERROR.*database.*timeout');
-- 执行时间：45秒

-- ✅ 优化后的查询
SELECT * FROM system_logs 
WHERE log_level = 'ERROR'  -- 利用索引
  AND log_content LIKE '%database%'  -- 初步过滤
  AND log_content LIKE '%timeout%'   -- 进一步过滤
  AND REGEXP_LIKE(log_content, 'ERROR.*database.*timeout');  -- 最终验证
-- 执行时间：3秒
```

**🔧 批量数据处理优化**

```sql
-- 批量处理策略：分批次更新，避免长时间锁表
DELIMITER $$
CREATE PROCEDURE clean_phone_numbers()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    DECLARE total_processed INT DEFAULT 0;
    
    WHILE total_processed < (SELECT COUNT(*) FROM customers WHERE phone_clean IS NULL) DO
        UPDATE customers 
        SET phone_clean = REGEXP_REPLACE(phone, '[^0-9]', '')
        WHERE phone_clean IS NULL 
          AND REGEXP_LIKE(phone, '^[0-9\\-\\s\\(\\)\\+]+$')
        LIMIT batch_size;
        
        SET total_processed = total_processed + batch_size;
        
        -- 避免过长事务，适当休眠
        SELECT SLEEP(0.1);
    END WHILE;
END$$
DELIMITER ;
```

### 9.4 错误处理和调试


**🔧 正则表达式调试技巧**

```sql
-- 分步调试复杂正则表达式
SELECT 
    email,
    -- 第1步：检查基本格式
    REGEXP_LIKE(email, '@') AS has_at_sign,
    -- 第2步：检查@符号前部分
    REGEXP_LIKE(email, '^[^@\\s]+@') AS valid_local_part,
    -- 第3步：检查@符号后部分
    REGEXP_LIKE(email, '@[^@\\s]+$') AS valid_domain_part,
    -- 第4步：检查域名格式
    REGEXP_LIKE(email, '@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') AS valid_domain_format,
    -- 最终结果
    REGEXP_LIKE(email, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') AS final_result
FROM test_emails;
```

**🔧 常见错误处理**

```sql
-- 安全的正则表达式执行
SELECT 
    customer_id,
    phone,
    CASE 
        WHEN phone IS NULL THEN NULL
        WHEN phone = '' THEN NULL
        ELSE 
            -- 使用TRY-CATCH处理正则表达式错误
            CASE 
                WHEN REGEXP_LIKE(phone, '^1[3-9][0-9]{9}$') THEN 'VALID'
                ELSE 'INVALID'
            END
    END AS phone_validation
FROM customers;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 正则表达式本质：用模式描述字符串特征的强大工具
🔸 MySQL正则函数：REGEXP、REGEXP_LIKE、REGEXP_REPLACE、REGEXP_SUBSTR、REGEXP_INSTR
🔸 基础语法元素：锚点(^$)、量词(*+?)、字符类([])、分组()
🔸 性能优化原则：简化模式、使用锚点、配合索引、避免回溯
🔸 实际应用场景：数据验证、内容提取、格式转换、数据清洗
```

### 10.2 关键理解要点


**🔹 正则表达式的强大之处**
```
传统字符串函数 vs 正则表达式：

提取手机号：
传统方法：需要多个SUBSTR、LOCATE、IF嵌套
正则方法：一个REGEXP_SUBSTR搞定

验证邮箱格式：
传统方法：复杂的条件判断链
正则方法：一个模式表达式

数据清洗：
传统方法：多次REPLACE嵌套调用
正则方法：一次REGEXP_REPLACE完成
```

**🔹 性能和功能的平衡**
```
使用原则：
🔸 简单匹配优先用LIKE（性能更好）
🔸 复杂模式匹配用正则表达式（功能更强）
🔸 大数据量查询要配合索引使用
🔸 批量处理时要注意分批执行

性能优化记忆：
"索引过滤打头阵，正则验证做精兵"
先用索引快速过滤大部分数据，再用正则精确匹配
```

**🔹 常用模式要熟记**
```
🧠 **实用正则模式库**
手机号：^1[3-9][0-9]{9}$
邮箱：^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$
身份证：^[1-9][0-9]{17}[0-9Xx]$  
IP地址：^([0-9]{1,3}\\.){3}[0-9]{1,3}$
中文字符：[\u4e00-\u9fff]
```

### 10.3 实际应用指导


**🎯 不同场景的最佳选择**

```
数据验证场景：
首选：REGEXP_LIKE（清晰的布尔返回值）
语法：WHERE REGEXP_LIKE(column, pattern, 'i')

数据提取场景：
首选：REGEXP_SUBSTR（直接返回匹配内容）
语法：SELECT REGEXP_SUBSTR(column, pattern, 1, 1)

数据清洗场景：
首选：REGEXP_REPLACE（强大的替换功能）
语法：REGEXP_REPLACE(column, pattern, replacement, 1, 0, 'g')

位置查找场景：
首选：REGEXP_INSTR（返回精确位置）
语法：REGEXP_INSTR(column, pattern, 1, 1, 0)
```

**🛠️ 开发实践建议**

```
📋 **正则表达式开发清单**
- [ ] 先用在线工具测试正则表达式
- [ ] 从简单模式开始，逐步复杂化
- [ ] 注意转义字符的正确使用
- [ ] 考虑性能影响，大数据量时配合索引
- [ ] 添加适当注释说明复杂正则的含义
- [ ] 建立常用正则模式库供复用
```

**🔧 调试和维护技巧**

```
调试步骤：
1. 分解复杂正则为简单部分
2. 逐步测试每个部分
3. 使用SELECT语句验证结果
4. 注意边界情况和特殊字符

维护建议：
• 复杂正则表达式要添加注释
• 建立团队正则模式库
• 定期review性能表现
• 保持模式简洁，避免过度复杂
```

### 10.4 学习进阶路径


**📚 学习路线**

```
初级阶段：基础语法掌握
• 理解锚点、量词、字符类概念
• 掌握REGEXP和LIKE的区别  
• 学会基本的匹配和验证

中级阶段：函数熟练应用
• 掌握所有MySQL正则函数的用法
• 能够进行数据提取和替换操作
• 理解性能优化的基本原则

高级阶段：实践和优化
• 能设计复杂的数据处理流程
• 深入理解正则引擎工作原理
• 具备性能调优和问题诊断能力
```

**🎯 实践项目建议**

```
项目1：用户数据清洗系统
• 电话号码格式统一
• 邮箱地址验证和清理
• 姓名格式规范化

项目2：日志分析系统  
• 访问日志解析和统计
• 错误日志模式识别
• 性能日志数据提取

项目3：内容管理系统
• 富文本内容清洗
• 敏感词过滤和替换
• 格式转换和标准化
```

**核心记忆口诀**：
```
🎵 "正则强大用处多，模式匹配最在行
验证提取和替换，位置查找也能行  
语法虽难要细学，性能优化更要懂
索引配合效率高，数据处理显神通"
```

**🏷️ 关键技能标签**：
`模式匹配` `数据验证` `内容提取` `格式转换` `性能优化`