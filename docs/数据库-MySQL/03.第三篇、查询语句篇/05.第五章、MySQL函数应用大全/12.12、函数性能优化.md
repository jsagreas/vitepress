---
title: 12、函数性能优化
---
## 📚 目录

1. [函数性能基础理解](#1-函数性能基础理解)
2. [函数执行性能分析](#2-函数执行性能分析)
3. [函数索引优化策略](#3-函数索引优化策略)
4. [确定性函数DETERMINISTIC优化](#4-确定性函数DETERMINISTIC优化)
5. [函数内联优化机制](#5-函数内联优化机制)
6. [复杂函数拆分与重构](#6-复杂函数拆分与重构)
7. [函数性能监控与调优](#7-函数性能监控与调优)
8. [函数性能优化最佳实践](#8-函数性能优化最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚀 函数性能基础理解


### 1.1 什么是函数性能问题


**简单理解**：MySQL函数性能问题就像是做菜时调料用法的问题

```
做菜类比：
调料用得巧 → 菜香味美，效率高
调料用不好 → 费时费力，效果差

MySQL函数：
函数用得对 → 查询快速，资源省
函数用不当 → 查询缓慢，资源浪费
```

**🔸 函数性能影响的根本原因**

```
为什么函数会影响性能？

1. 计算开销
   - 每行数据都要执行一次函数
   - 复杂函数计算时间长

2. 索引失效  
   - 函数包装列无法使用索引
   - WHERE func(column) = value ❌
   - WHERE column = value ✅

3. 重复计算
   - 相同参数的函数重复执行
   - 没有缓存结果
```

### 1.2 函数性能问题的常见表现


**⚠️ 典型症状识别**

```sql
-- ❌ 性能杀手：每行都执行函数
SELECT * FROM orders 
WHERE DATE(create_time) = '2024-01-15';

-- ❌ 更严重：嵌套函数调用
SELECT customer_id, 
       UPPER(LEFT(customer_name, 10))
FROM customers 
WHERE LENGTH(TRIM(address)) > 50;
```

**📊 性能影响对比**

| 场景 | **执行方式** | **100万行数据耗时** | **CPU使用率** | **说明** |
|------|------------|------------------|--------------|---------|
| 🟢 **直接条件** | `WHERE create_time >= '2024-01-15'` | `0.5秒` | `低` | `使用索引，最优` |
| 🟡 **简单函数** | `WHERE YEAR(create_time) = 2024` | `8秒` | `中` | `函数计算，索引失效` |
| 🔴 **复杂函数** | `WHERE DATEDIFF(NOW(), create_time) = 30` | `25秒` | `高` | `复杂计算，性能最差` |

### 1.3 函数调用成本分析


**💰 函数执行成本的构成**

```
函数执行成本 = 调用开销 + 计算开销 + 数据传输开销

调用开销：
- 函数查找时间
- 参数传递时间
- 上下文切换时间

计算开销：
- 算法复杂度
- 数据处理量
- 内存分配

数据传输开销：
- 结果集大小
- 网络传输时间
- 数据格式转换
```

---

## 2. 📊 函数执行性能分析


### 2.1 性能分析工具使用


**🔧 查看查询执行计划**

```sql
-- 分析函数对查询计划的影响
EXPLAIN SELECT customer_id, customer_name
FROM customers 
WHERE UPPER(customer_name) LIKE 'JOHN%';

/*
关键指标解读：
- type: ALL (全表扫描，最差)
- rows: 100000 (需要检查的行数)
- Extra: Using where (无法使用索引)
*/
```

**⏱️ 查询性能对比测试**

```sql
-- 开启性能分析
SET profiling = 1;

-- 测试1：使用函数的查询
SELECT COUNT(*) FROM orders 
WHERE DATE(create_time) = '2024-01-15';

-- 测试2：直接条件查询  
SELECT COUNT(*) FROM orders 
WHERE create_time >= '2024-01-15' 
  AND create_time < '2024-01-16';

-- 查看性能差异
SHOW PROFILES;

/*
结果对比：
Query 1 (函数): 2.5秒
Query 2 (直接): 0.1秒
性能差异：25倍
*/
```

### 2.2 函数执行频率分析


**📈 统计函数调用次数**

```
理解函数执行频率的重要性：

假设查询处理100万行数据：
- 每个函数都会被调用100万次
- 哪怕每次多花0.001秒，总计也要多花16分钟
- 这就是为什么函数优化如此重要
```

**💡 函数执行成本计算公式**

```
总执行时间 = 行数 × 单次函数执行时间

实际案例：
行数：1,000,000行
函数：DATE(create_time) 
单次执行：0.0001秒
总计：1,000,000 × 0.0001 = 100秒
```

### 2.3 性能瓶颈识别


**🎯 找出性能瓶颈的方法**

```sql
-- 1. 使用 BENCHMARK 函数测试
SELECT BENCHMARK(1000000, DATE('2024-01-15'));
-- 结果：执行100万次DATE函数的总时间

-- 2. 对比不同函数的性能
SELECT BENCHMARK(1000000, YEAR('2024-01-15'));  -- 快
SELECT BENCHMARK(1000000, DATE_FORMAT('2024-01-15', '%Y')); -- 慢

-- 3. 分析慢查询日志
-- 在my.cnf中开启：
-- slow_query_log = 1
-- long_query_time = 1
-- 然后分析日志中的函数使用情况
```

**⚡ 性能瓶颈的典型特征**

```
高CPU使用率：
- 大量数学计算函数
- 字符串处理函数
- 日期时间函数

高内存使用：
- GROUP_CONCAT处理大量数据
- 复杂的正则表达式
- 大字符串操作

高IO等待：
- 文件操作函数（如果允许）
- 大量数据读取
- 临时表创建
```

---

## 3. 🔍 函数索引优化策略


### 3.1 表达式索引的理解与应用


**💡 什么是表达式索引**

```
传统索引：直接对列建索引
表达式索引：对函数表达式建索引

生活类比：
传统索引 = 按姓氏排序的电话本
表达式索引 = 按姓氏首字母排序的电话本（预处理结果）
```

**🔧 表达式索引的创建与使用**

```sql
-- 创建表达式索引（MySQL 8.0+支持）
CREATE TABLE orders (
    id INT PRIMARY KEY,
    create_time DATETIME,
    amount DECIMAL(10,2)
);

-- 为日期函数创建表达式索引
CREATE INDEX idx_order_date ON orders ((DATE(create_time)));

-- 为计算表达式创建索引
CREATE INDEX idx_order_year ON orders ((YEAR(create_time)));

-- 现在这个查询可以使用索引了！
SELECT * FROM orders 
WHERE DATE(create_time) = '2024-01-15';
```

### 3.2 函数索引优化实战


**📊 优化前后性能对比**

```sql
-- 场景：经常需要按年份查询订单
CREATE TABLE order_analysis (
    id INT AUTO_INCREMENT PRIMARY KEY,
    create_time DATETIME NOT NULL,
    customer_id INT,
    amount DECIMAL(10,2)
);

-- 插入100万条测试数据
INSERT INTO order_analysis (create_time, customer_id, amount)
SELECT 
    DATE_ADD('2020-01-01', INTERVAL RAND()*1460 DAY),
    FLOOR(RAND()*10000),
    RAND()*1000
FROM 
    (SELECT 1 UNION SELECT 2 /* ... 生成足够行数 */) t1,
    (SELECT 1 UNION SELECT 2 /* ... */) t2;

-- ❌ 优化前：无法使用索引
SELECT COUNT(*) FROM order_analysis 
WHERE YEAR(create_time) = 2024;
-- 执行时间：~3秒，全表扫描

-- ✅ 优化方案1：创建表达式索引
CREATE INDEX idx_year ON order_analysis ((YEAR(create_time)));

-- 现在查询变快了！
SELECT COUNT(*) FROM order_analysis 
WHERE YEAR(create_time) = 2024;
-- 执行时间：~0.1秒，使用索引

-- ✅ 优化方案2：改写查询条件（推荐）
SELECT COUNT(*) FROM order_analysis 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';
-- 执行时间：~0.05秒，使用普通索引，更快！
```

### 3.3 索引选择策略


**🎯 何时使用表达式索引**

```
适合使用表达式索引的场景：

✅ 查询频繁且固定：
   - 经常按 YEAR(date) 查询
   - 经常按 UPPER(name) 查询
   
✅ 函数结果相对稳定：
   - DATE(datetime) 
   - MONTH(date)
   
✅ 查询无法改写：
   - 业务逻辑必须使用函数
   - 第三方系统生成的SQL

❌ 不适合的场景：
   - 函数结果变化频繁（如NOW()）
   - 查询不频繁
   - 可以通过改写查询优化
```

**⚖️ 表达式索引的优缺点**

```
优点：
🟢 让函数查询也能使用索引
🟢 大幅提升特定查询性能
🟢 对应用透明，无需改代码

缺点：
🔴 额外的存储空间占用
🔴 插入/更新时需要维护索引
🔴 只在MySQL 8.0+版本支持
🔴 增加数据库维护复杂度
```

---

## 4. 🔥 确定性函数DETERMINISTIC优化


### 4.1 确定性函数的概念


**💡 什么是确定性函数**

```
确定性函数（DETERMINISTIC）：
给定相同输入，总是返回相同输出的函数

生活类比：
确定性函数 = 数学公式（2+3总是等于5）
非确定性函数 = 天气预报（相同条件下结果可能不同）
```

**🔸 确定性函数分类**

```sql
-- ✅ 确定性函数（可以优化缓存）
SELECT 
    ABS(-10),           -- 总是返回10
    SQRT(16),           -- 总是返回4
    UPPER('hello'),     -- 总是返回'HELLO'
    DATE('2024-01-15'); -- 总是返回'2024-01-15'

-- ❌ 非确定性函数（无法缓存）
SELECT 
    NOW(),              -- 每次调用返回不同时间
    RAND(),             -- 每次返回不同随机数
    UUID(),             -- 每次生成不同UUID
    CONNECTION_ID();     -- 返回当前连接ID
```

### 4.2 DETERMINISTIC关键字的使用


**🔧 自定义函数的确定性声明**

```sql
-- 创建确定性函数
DELIMITER //
CREATE FUNCTION calculate_tax(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC  -- 关键字：声明这是确定性函数
READS SQL DATA
BEGIN
    RETURN amount * 0.08;  -- 固定税率8%
END//
DELIMITER ;

-- MySQL可以对此函数进行优化：
-- 1. 结果缓存
-- 2. 表达式预计算  
-- 3. 常量折叠优化
```

**⚡ 确定性函数的性能优化原理**

```
MySQL对确定性函数的优化策略：

1. 常量折叠：
   WHERE calculate_tax(100) > 5
   优化为：WHERE 8.0 > 5  -- 预先计算

2. 结果缓存：
   相同参数的函数调用使用缓存结果

3. 表达式提升：
   将函数调用移到循环外部执行
```

### 4.3 确定性函数优化实战


**📊 性能测试对比**

```sql
-- 测试场景：计算订单税费
CREATE TABLE orders_test (
    id INT PRIMARY KEY,
    amount DECIMAL(10,2),
    region VARCHAR(50)
);

-- 创建非确定性函数（错误示例）
DELIMITER //
CREATE FUNCTION bad_calculate_tax(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
NOT DETERMINISTIC  -- 声明为非确定性
BEGIN
    RETURN amount * 0.08;
END//

-- 创建确定性函数（优化示例）  
CREATE FUNCTION good_calculate_tax(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC      -- 声明为确定性
BEGIN
    RETURN amount * 0.08;
END//
DELIMITER ;

-- 性能测试
-- 测试1：非确定性函数
SELECT COUNT(*) FROM orders_test 
WHERE bad_calculate_tax(amount) > 50;
-- 每行都重新计算，耗时较长

-- 测试2：确定性函数
SELECT COUNT(*) FROM orders_test 
WHERE good_calculate_tax(amount) > 50;
-- MySQL可能缓存结果，性能更好
```

**🎯 确定性函数最佳实践**

```
设计确定性函数的原则：

1. ✅ 纯计算逻辑
   - 只依赖输入参数
   - 不读取变化的系统状态
   - 不产生副作用

2. ✅ 合理使用关键字
   CREATE FUNCTION func_name(...)
   DETERMINISTIC          -- 明确声明
   READS SQL DATA        -- 如果需要读数据
   
3. ❌ 避免以下内容
   - 调用NOW()、RAND()等
   - 读取会变化的表数据
   - 依赖会话变量
```

---

## 5. 🔄 函数内联优化机制


### 5.1 函数内联的基本概念


**💡 什么是函数内联优化**

```
函数内联：把函数调用替换为函数体的直接代码

类比理解：
普通函数调用 = 电话咨询（需要拨号、等待、通话）
内联函数    = 直接查手册（直接获取答案）

性能提升：
- 减少函数调用开销
- 减少栈操作
- 编译器更容易进行其他优化
```

**🔸 内联优化的工作原理**

```sql
-- 原始查询（函数调用）
SELECT customer_id, 
       calculate_discount(amount, vip_level)
FROM orders;

-- 内联优化后（直接计算）
SELECT customer_id,
       CASE 
           WHEN vip_level = 'GOLD' THEN amount * 0.1
           WHEN vip_level = 'SILVER' THEN amount * 0.05
           ELSE amount * 0.02
       END AS discount
FROM orders;
```

### 5.2 促进内联优化的技巧


**🔧 编写内联友好的函数**

```sql
-- ✅ 内联友好：简单逻辑
DELIMITER //
CREATE FUNCTION simple_discount(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    RETURN amount * 0.1;  -- 简单计算
END//

-- ❌ 不适合内联：复杂逻辑
CREATE FUNCTION complex_discount(customer_id INT)
RETURNS DECIMAL(10,2)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE discount DECIMAL(5,2);
    DECLARE total_orders INT;
    
    SELECT COUNT(*) INTO total_orders
    FROM orders 
    WHERE customer_id = customer_id;
    
    IF total_orders > 100 THEN
        SET discount = 0.15;
    ELSEIF total_orders > 50 THEN
        SET discount = 0.10;
    ELSE
        SET discount = 0.05;
    END IF;
    
    RETURN discount;
END//
DELIMITER ;
```

**⚡ 内联优化的最佳实践**

```
促进内联优化的方法：

1. 保持函数简单：
   - 单一职责
   - 逻辑简单
   - 无复杂控制流

2. 使用表达式：
   -- ✅ 简单表达式，易于内联
   SELECT amount * 0.1 AS discount
   
   -- ❌ 函数调用，需要额外开销
   SELECT calculate_discount(amount)

3. 避免递归：
   - 递归函数通常不会被内联
   - 改用循环或迭代方式
```

### 5.3 内联优化效果测试


**📊 内联优化性能对比**

```sql
-- 性能测试：对比函数调用与直接计算

-- 测试数据准备
CREATE TABLE performance_test (
    id INT PRIMARY KEY,
    amount DECIMAL(10,2),
    category VARCHAR(50)
);

-- 插入10万条测试数据
INSERT INTO performance_test (id, amount, category)
SELECT 
    ROW_NUMBER() OVER(),
    RAND() * 1000,
    CASE FLOOR(RAND() * 3)
        WHEN 0 THEN 'A'
        WHEN 1 THEN 'B'
        ELSE 'C'
    END
FROM information_schema.columns t1, information_schema.columns t2
LIMIT 100000;

-- 创建简单函数
DELIMITER //
CREATE FUNCTION calc_fee(amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    RETURN amount * 0.03;
END//
DELIMITER ;

-- 性能对比测试
SET profiling = 1;

-- 测试1：使用函数
SELECT SUM(calc_fee(amount)) FROM performance_test;

-- 测试2：直接计算
SELECT SUM(amount * 0.03) FROM performance_test;

SHOW PROFILES;

/*
典型结果：
Query 1 (函数调用): 0.15秒
Query 2 (直接计算): 0.08秒
性能提升: 约50%
*/
```

---

## 6. 🔧 复杂函数拆分与重构


### 6.1 复杂函数的识别


**⚠️ 什么是需要优化的复杂函数**

```
复杂函数的特征：

1. 🔴 多层嵌套调用
   UPPER(LEFT(TRIM(customer_name), 10))
   
2. 🔴 多个条件判断
   大量的IF、CASE语句
   
3. 🔴 包含子查询
   函数内部查询数据库
   
4. 🔴 计算密集型
   复杂数学运算、字符串操作
```

**📊 复杂函数的性能问题**

```sql
-- ❌ 性能杀手：复杂嵌套函数
SELECT customer_id,
       CONCAT(
           UPPER(LEFT(TRIM(first_name), 1)),
           LOWER(SUBSTRING(TRIM(first_name), 2)),
           ' ',
           UPPER(LEFT(TRIM(last_name), 1)),
           LOWER(SUBSTRING(TRIM(last_name), 2))
       ) AS formatted_name
FROM customers
WHERE LENGTH(TRIM(CONCAT(first_name, ' ', last_name))) > 10;

-- 问题分析：
-- - TRIM函数被调用4次
-- - UPPER、LOWER各被调用2次  
-- - SUBSTRING被调用2次
-- - 总计每行调用10+次函数
```

### 6.2 函数拆分策略


**🔧 拆分复杂函数的方法**

```sql
-- 原始复杂查询（性能差）
SELECT 
    order_id,
    CASE 
        WHEN DATEDIFF(NOW(), create_time) <= 7 THEN 'NEW'
        WHEN DATEDIFF(NOW(), create_time) <= 30 THEN 'RECENT'  
        WHEN DATEDIFF(NOW(), create_time) <= 90 THEN 'OLD'
        ELSE 'ARCHIVED'
    END AS order_age,
    ROUND(amount * 
          CASE region 
              WHEN 'US' THEN 1.08
              WHEN 'EU' THEN 1.20  
              ELSE 1.05
          END, 2) AS total_with_tax
FROM orders
WHERE YEAR(create_time) = 2024;

-- ✅ 优化方案1：使用子查询拆分
SELECT 
    order_id,
    CASE 
        WHEN days_since_created <= 7 THEN 'NEW'
        WHEN days_since_created <= 30 THEN 'RECENT'
        WHEN days_since_created <= 90 THEN 'OLD'
        ELSE 'ARCHIVED'  
    END AS order_age,
    ROUND(amount * tax_rate, 2) AS total_with_tax
FROM (
    SELECT 
        order_id,
        amount,
        DATEDIFF(NOW(), create_time) AS days_since_created,
        CASE region
            WHEN 'US' THEN 1.08
            WHEN 'EU' THEN 1.20
            ELSE 1.05
        END AS tax_rate
    FROM orders  
    WHERE create_time >= '2024-01-01' 
      AND create_time < '2025-01-01'  -- 避免使用YEAR函数
) t;
```

**⚡ 使用计算列优化**

```sql
-- ✅ 优化方案2：添加计算列
ALTER TABLE orders 
ADD COLUMN days_since_created INT AS (DATEDIFF(NOW(), create_time)) VIRTUAL;

-- 为计算列创建索引
CREATE INDEX idx_days_since ON orders (days_since_created);

-- 现在查询变得简单快速
SELECT order_id, 
       CASE 
           WHEN days_since_created <= 7 THEN 'NEW'
           WHEN days_since_created <= 30 THEN 'RECENT'
           ELSE 'OLD'
       END AS order_age
FROM orders  
WHERE days_since_created <= 30;  -- 可以使用索引！
```

### 6.3 函数重构最佳实践


**🎯 重构原则与方法**

```
函数重构的核心原则：

1. 🔸 减少重复计算
   - 将重复的函数调用提取到变量
   - 使用子查询预计算结果

2. 🔸 拆分复杂逻辑  
   - 将复杂函数拆分为多个简单步骤
   - 使用临时表存储中间结果

3. 🔸 消除函数嵌套
   - 减少函数调用层数
   - 用直接计算替代函数调用

4. 🔸 利用索引优化
   - 创建表达式索引
   - 添加计算列并建索引
```

**💡 重构实战案例**

```sql
-- 场景：客户信用评分计算（重构前）
SELECT 
    customer_id,
    ROUND(
        (COALESCE(total_orders, 0) * 0.3 +
         COALESCE(avg_order_value, 0) * 0.2 + 
         GREATEST(0, DATEDIFF('2024-12-31', first_order_date)) / 365 * 0.5) * 100
    ) AS credit_score
FROM (
    SELECT 
        c.customer_id,
        COUNT(o.id) AS total_orders,
        AVG(o.amount) AS avg_order_value,
        MIN(o.create_time) AS first_order_date
    FROM customers c
    LEFT JOIN orders o ON c.id = o.customer_id  
    GROUP BY c.customer_id
) t;

-- ✅ 重构后：拆分为多个步骤
-- 步骤1：创建客户统计视图
CREATE VIEW customer_stats AS
SELECT 
    c.customer_id,
    COUNT(o.id) AS total_orders,
    COALESCE(AVG(o.amount), 0) AS avg_order_value,
    COALESCE(DATEDIFF('2024-12-31', MIN(o.create_time)) / 365, 0) AS customer_years
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
GROUP BY c.customer_id;

-- 步骤2：简化信用评分计算
SELECT 
    customer_id,
    ROUND((total_orders * 0.3 + avg_order_value * 0.2 + customer_years * 0.5) * 100) AS credit_score
FROM customer_stats;

-- 性能提升：查询时间从5秒降至0.8秒
```

---

## 7. 📈 函数性能监控与调优


### 7.1 函数性能监控方法


**🔍 监控函数性能的工具**

```sql
-- 1. 使用 Performance Schema 监控
-- 开启相关监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%function%';

-- 查看函数执行统计
SELECT 
    OBJECT_NAME as function_name,
    COUNT_STAR as call_count,
    SUM_TIMER_WAIT/1000000000000 as total_time_sec,
    AVG_TIMER_WAIT/1000000000000 as avg_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE OBJECT_TYPE = 'FUNCTION'
ORDER BY total_time_sec DESC;
```

**📊 慢查询分析**

```sql
-- 2. 分析慢查询日志中的函数使用
-- 设置慢查询阈值
SET GLOBAL slow_query_log = 1;
SET GLOBAL long_query_time = 1;  -- 1秒以上记录

-- 查看包含函数的慢查询
-- 在日志中查找包含函数调用的查询
-- 分析函数对查询时间的影响
```

### 7.2 函数缓存机制


**💾 理解MySQL的查询缓存**

```
MySQL查询缓存对函数的影响：

✅ 可缓存的情况：
- 查询完全相同（包括函数参数）
- 涉及的表没有发生变化
- 使用确定性函数

❌ 不可缓存的情况：
- 包含非确定性函数（NOW(), RAND()）
- 表数据发生变化
- 查询语句有任何差异
```

**🔧 自定义函数结果缓存**

```sql
-- 创建缓存表来存储复杂计算结果
CREATE TABLE function_cache (
    cache_key VARCHAR(255) PRIMARY KEY,
    result_value TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP
);

-- 创建带缓存的函数
DELIMITER //
CREATE FUNCTION cached_complex_calc(input_val INT)
RETURNS DECIMAL(10,2)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE cache_key VARCHAR(255);
    DECLARE cached_result DECIMAL(10,2);
    DECLARE result DECIMAL(10,2);
    
    SET cache_key = CONCAT('complex_calc_', input_val);
    
    -- 检查缓存
    SELECT result_value INTO cached_result
    FROM function_cache 
    WHERE cache_key = cache_key 
      AND expires_at > NOW()
    LIMIT 1;
    
    IF cached_result IS NOT NULL THEN
        RETURN cached_result;
    END IF;
    
    -- 执行复杂计算
    SET result = input_val * input_val * 1.5 + SQRT(input_val);
    
    -- 存储到缓存
    INSERT INTO function_cache (cache_key, result_value, expires_at)
    VALUES (cache_key, result, DATE_ADD(NOW(), INTERVAL 1 HOUR))
    ON DUPLICATE KEY UPDATE 
        result_value = result,
        expires_at = DATE_ADD(NOW(), INTERVAL 1 HOUR);
        
    RETURN result;
END//
DELIMITER ;
```

### 7.3 函数调优实战


**🎯 函数调优的系统方法**

```
函数调优的完整流程：

1. 📊 性能基线测试
   - 记录当前查询性能
   - 识别性能瓶颈函数

2. 🔍 问题分析  
   - 分析函数执行频率
   - 找出最耗时的函数调用

3. 🛠 优化实施
   - 应用各种优化技术
   - 逐步测试验证效果

4. 📈 效果验证
   - 对比优化前后性能
   - 确保功能正确性
```

**📊 调优案例完整演示**

```sql
-- 调优案例：订单报表性能优化

-- 问题查询（性能差）
SELECT 
    DATE_FORMAT(create_time, '%Y-%m') AS month,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(DATEDIFF(ship_time, create_time)) AS avg_ship_days
FROM orders 
WHERE YEAR(create_time) = 2024
  AND status != 'CANCELLED'
GROUP BY DATE_FORMAT(create_time, '%Y-%m')
ORDER BY month;

-- 📊 性能分析
EXPLAIN SELECT ...;  -- 显示全表扫描，无法使用索引

-- 🛠 优化步骤

-- 步骤1：消除函数，使用范围查询
-- 步骤2：预计算月份字段
-- 步骤3：创建合适的索引

-- ✅ 优化后的查询
-- 首先添加月份计算列
ALTER TABLE orders 
ADD COLUMN order_month VARCHAR(7) AS (DATE_FORMAT(create_time, '%Y-%m'));

-- 创建复合索引
CREATE INDEX idx_month_status ON orders (order_month, status, create_time);

-- 优化后的查询
SELECT 
    order_month AS month,
    COUNT(*) AS order_count,  
    SUM(amount) AS total_amount,
    AVG(DATEDIFF(ship_time, create_time)) AS avg_ship_days
FROM orders
WHERE order_month LIKE '2024-%'
  AND status != 'CANCELLED'  
GROUP BY order_month
ORDER BY month;

-- 📈 性能提升结果
-- 优化前：8.5秒，全表扫描
-- 优化后：0.3秒，使用索引
-- 性能提升：28倍
```

---

## 8. 💎 函数性能优化最佳实践


### 8.1 函数使用的核心原则


**🎯 函数性能优化的黄金法则**

```
1. 🔸 能不用函数就不用
   - 直接条件 > 函数条件
   - 预计算 > 实时计算

2. 🔸 用简单函数不用复杂函数  
   - 内置函数 > 自定义函数
   - 单一函数 > 嵌套函数

3. 🔸 用确定性函数  
   - 声明DETERMINISTIC
   - 避免非确定性函数

4. 🔸 合理使用索引
   - 表达式索引
   - 计算列索引
```

**⚡ 实用优化技巧对照表**

| 场景 | **❌ 慢速写法** | **✅ 优化写法** | **性能提升** |
|------|---------------|---------------|-------------|
| 日期查询 | `WHERE DATE(create_time) = '2024-01-15'` | `WHERE create_time >= '2024-01-15' AND create_time < '2024-01-16'` | `10-50倍` |
| 字符串处理 | `WHERE UPPER(name) = 'JOHN'` | `WHERE name = 'JOHN' OR name = 'john'` | `5-20倍` |
| 数值计算 | `WHERE amount * 1.08 > 100` | `WHERE amount > 100/1.08` | `3-10倍` |
| 年份筛选 | `WHERE YEAR(date) = 2024` | `WHERE date >= '2024-01-01' AND date < '2025-01-01'` | `20-100倍` |

### 8.2 函数选择指南


**🔍 高性能函数选择策略**

```sql
-- 1. 日期时间函数优化选择

-- ❌ 慢：复杂格式化函数
SELECT DATE_FORMAT(create_time, '%Y年%m月%d日') FROM orders;

-- ✅ 快：简单提取函数  
SELECT DATE(create_time) FROM orders;

-- ✅ 更快：直接截取
SELECT LEFT(create_time, 10) FROM orders;

-- 2. 字符串函数优化选择

-- ❌ 慢：多层嵌套
SELECT UPPER(TRIM(SUBSTRING(name, 1, 10))) FROM customers;

-- ✅ 快：分步处理
SELECT UPPER(LEFT(TRIM(name), 10)) FROM customers;

-- ✅ 更快：应用层处理（如果可能）
-- 让应用程序处理字符串格式化

-- 3. 数学函数优化选择

-- ❌ 慢：复杂计算函数
SELECT POWER(amount, 2) + SQRT(amount) FROM orders;

-- ✅ 快：简化计算
SELECT amount * amount + SQRT(amount) FROM orders;
```

### 8.3 性能优化检查清单


**📋 函数性能优化检查表**

```
优化前检查：

□ 1. 函数是否必要？
   - 能否用简单条件替代？
   - 能否在应用层处理？

□ 2. 函数调用频率如何？
   - 是否在WHERE子句中？
   - 是否在大表上执行？

□ 3. 索引情况如何？
   - 函数是否导致索引失效？
   - 是否可以创建表达式索引？

优化后验证：

□ 4. 性能是否有提升？
   - 执行时间对比
   - 资源使用对比

□ 5. 功能是否正确？
   - 结果是否一致
   - 边界情况是否正常

□ 6. 维护性如何？
   - 代码是否清晰
   - 是否增加了复杂度
```

**🚀 高性能查询模式**

```sql
-- 模式1：预计算模式
-- 在数据写入时计算好结果，查询时直接使用
CREATE TABLE order_summary (
    order_id INT PRIMARY KEY,
    order_date DATE,
    order_year INT,    -- 预计算年份
    order_month INT,   -- 预计算月份
    tax_amount DECIMAL(10,2),  -- 预计算税费
    total_amount DECIMAL(10,2) -- 预计算总额
);

-- 模式2：视图优化模式
-- 将复杂计算封装在视图中
CREATE VIEW customer_metrics AS
SELECT 
    customer_id,
    COUNT(*) as order_count,
    SUM(amount) as total_spent,
    AVG(amount) as avg_order_value,
    MAX(create_time) as last_order_date
FROM orders
GROUP BY customer_id;

-- 模式3：分离计算模式  
-- 将复杂函数从WHERE子句移到SELECT子句
-- ❌ 低效
SELECT * FROM orders 
WHERE YEAR(create_time) = 2024 AND calculate_tax(amount) > 50;

-- ✅ 高效
SELECT *, calculate_tax(amount) as tax
FROM orders  
WHERE create_time >= '2024-01-01' AND create_time < '2025-01-01'
HAVING tax > 50;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 函数性能问题：函数调用会带来额外开销，特别是在大数据量时
🔸 索引失效：WHERE子句中的函数会导致索引无法使用
🔸 确定性函数：相同输入总是相同输出，MySQL可以进行缓存优化
🔸 表达式索引：为函数表达式创建索引，让函数查询也能高速执行
🔸 函数内联：简单函数可能被内联优化，减少调用开销
🔸 性能监控：通过各种工具监控函数执行性能，找出瓶颈
```

### 9.2 关键优化策略


**🔹 查询改写策略**
```
函数条件改写：
- DATE(时间) = '日期' → 时间范围查询
- YEAR(时间) = 年份 → 时间范围查询  
- UPPER(字符串) = '大写' → 多条件OR查询
- 数值*系数 > 值 → 数值 > 值/系数

索引利用策略：
- 创建表达式索引
- 添加计算列并建索引
- 改写查询以使用现有索引
```

**🔹 函数设计原则**
```
设计高性能函数：
- 声明为DETERMINISTIC（如果适用）
- 保持逻辑简单，便于内联优化
- 避免在函数中查询数据库
- 使用缓存机制存储计算结果

函数使用原则：
- 能不用就不用函数
- 简单函数优于复杂函数
- 预计算优于实时计算
- 应用层处理优于数据库函数
```

### 9.3 实际应用指导


**💡 性能优化决策树**
```
遇到函数性能问题时的决策流程：

1. 评估必要性
   ├─ 非必要 → 删除函数调用
   └─ 必要 → 继续评估

2. 分析使用位置  
   ├─ WHERE子句 → 考虑改写查询或创建索引
   ├─ SELECT子句 → 考虑预计算或缓存
   └─ GROUP BY/ORDER BY → 考虑添加计算列

3. 选择优化方案
   ├─ 改写查询（优先选择）
   ├─ 创建表达式索引
   ├─ 添加计算列
   └─ 应用层处理
```

**🎯 优化效果预期**
```
典型优化效果：

查询改写优化：
- 性能提升：5-100倍
- 实施难度：低
- 维护成本：低

表达式索引：
- 性能提升：10-50倍  
- 实施难度：中
- 维护成本：中

函数重构：
- 性能提升：2-10倍
- 实施难度：高
- 维护成本：中

预计算方案：
- 性能提升：10-1000倍
- 实施难度：高  
- 维护成本：高
```

### 9.4 常见误区避免


**⚠️ 函数使用常见误区**
```
误区1：过度使用函数
- 认为函数让SQL更简洁
- 实际上严重影响性能

误区2：忽视索引影响
- 不知道函数会导致索引失效
- 没有考虑创建表达式索引

误区3：不区分函数类型
- 将所有函数一视同仁
- 没有利用确定性函数的优化特性

误区4：缺乏性能测试
- 没有对比优化前后的性能
- 没有在真实数据量下测试
```

**核心记忆口诀**：
- 函数虽便利，性能要牢记
- 索引易失效，改写是王道  
- 确定性声明，缓存来帮忙
- 简单胜复杂，预算超实时
- 监控不可少，调优见真章