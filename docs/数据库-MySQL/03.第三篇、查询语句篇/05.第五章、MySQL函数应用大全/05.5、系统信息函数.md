---
title: 5、系统信息函数
---
## 📚 目录

1. [系统信息函数概述](#1-系统信息函数概述)
2. [用户身份相关函数](#2-用户身份相关函数)
3. [数据库连接信息函数](#3-数据库连接信息函数)
4. [版本与环境信息函数](#4-版本与环境信息函数)
5. [操作结果信息函数](#5-操作结果信息函数)
6. [系统状态与性能函数](#6-系统状态与性能函数)
7. [安全注意事项与监控应用](#7-安全注意事项与监控应用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 系统信息函数概述


### 1.1 什么是系统信息函数


**🔸 基本概念**
```
系统信息函数是什么：
• MySQL内置的特殊函数
• 用于获取数据库系统的各种信息
• 不需要访问任何表就能执行
• 返回当前环境的实时状态信息

主要用途：
• 获取当前登录用户信息
• 查看数据库连接状态
• 监控系统性能指标
• 调试和故障排查
• 安全审计和日志记录
```

### 1.2 系统函数的分类


**📋 功能分类一览**
```
用户身份类：
├─ USER() / CURRENT_USER()    当前用户信息
├─ SESSION_USER()             会话用户
└─ SYSTEM_USER()              系统用户

数据库环境类：
├─ DATABASE() / SCHEMA()      当前数据库
├─ VERSION()                  MySQL版本
└─ $$version_comment          版本注释

连接信息类：
├─ CONNECTION_ID()            连接标识
├─ $$hostname                 主机名
└─ $$port                     端口号

操作结果类：
├─ LAST_INSERT_ID()          最后插入ID
├─ ROW_COUNT()               影响行数
└─ FOUND_ROWS()              查找行数
```

### 1.3 系统函数的特点


**⭐ 核心特性**
```
无需参数：
大部分系统函数不需要参数，直接调用即可

实时性：
返回的都是当前时刻的系统状态

会话相关：
很多函数返回的信息与当前会话相关

只读性：
系统函数只能读取信息，不能修改系统状态

高效性：
执行速度很快，对系统性能影响很小
```

**💡 使用场景示例**
```sql
-- 快速查看当前环境信息
SELECT 
    USER() as 当前用户,
    DATABASE() as 当前数据库,
    VERSION() as MySQL版本,
    CONNECTION_ID() as 连接ID;

-- 在应用中记录操作日志
INSERT INTO operation_log (user_name, database_name, operation_time)
VALUES (USER(), DATABASE(), NOW());
```

---

## 2. 👤 用户身份相关函数


### 2.1 USER函数 - 当前登录用户


**🔸 基本用法和含义**
```sql
-- USER() 获取当前登录用户
SELECT USER();
-- 返回结果：'root@localhost'

-- 完整格式：'用户名@主机名'
-- 这是登录时使用的完整用户标识
```

**💡 实际应用场景**
```sql
-- 1. 在审计日志中记录操作用户
CREATE TABLE audit_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(100),
    operation VARCHAR(255),
    operation_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO audit_log (user_name, operation) 
VALUES (USER(), '查询用户列表');

-- 2. 根据用户身份进行权限控制
SELECT * FROM sensitive_data 
WHERE USER() LIKE 'admin@%';

-- 3. 在视图中显示当前用户信息
CREATE VIEW my_orders AS
SELECT order_id, order_date, amount
FROM orders 
WHERE created_by = USER();
```

### 2.2 CURRENT_USER函数 - 有效权限用户


**🔥 CURRENT_USER与USER的重要区别**
```sql
-- CURRENT_USER() 返回当前生效的权限用户
SELECT CURRENT_USER();
-- 返回结果：'app_user@%'

-- 关键区别理解：
-- USER()：显示登录时使用的用户名@主机名
-- CURRENT_USER()：显示MySQL实际使用的权限用户

-- 为什么会不同？
-- 因为MySQL的用户匹配是按照最具体匹配原则
```

**📊 对比示例说明**
```sql
-- 假设有以下用户权限设置：
-- 'john@192.168.1.100' - 特定IP的john用户
-- 'john@%' - 任意主机的john用户

-- 当john从192.168.1.100登录时：
SELECT USER(), CURRENT_USER();
-- 结果：'john@192.168.1.100', 'john@192.168.1.100'

-- 当john从192.168.1.200登录时：
SELECT USER(), CURRENT_USER();
-- 结果：'john@192.168.1.200', 'john@%'

-- 解释：
-- USER()显示实际登录信息
-- CURRENT_USER()显示MySQL找到的匹配权限用户
```

**🔧 实际应用场景**
```sql
-- 1. 权限调试 - 查看实际生效的权限用户
SELECT 
    USER() as 登录用户,
    CURRENT_USER() as 权限用户,
    CASE 
        WHEN USER() = CURRENT_USER() THEN '精确匹配'
        ELSE '通配符匹配'
    END as 匹配类型;

-- 2. 安全审计 - 记录真实权限用户
INSERT INTO security_log (login_user, effective_user, login_time)
VALUES (USER(), CURRENT_USER(), NOW());

-- 3. 权限检查存储过程
DELIMITER //
CREATE PROCEDURE check_user_permissions()
BEGIN
    DECLARE current_effective_user VARCHAR(100);
    SET current_effective_user = CURRENT_USER();
    
    IF current_effective_user NOT LIKE 'admin@%' THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '权限不足，需要管理员权限';
    END IF;
END //
DELIMITER ;
```

### 2.3 其他用户相关函数


**📋 用户函数家族**
```sql
-- SESSION_USER() - 会话用户（通常与USER()相同）
SELECT SESSION_USER();

-- SYSTEM_USER() - 系统用户（MySQL 8.0+）
SELECT SYSTEM_USER();

-- 对比查看所有用户信息
SELECT 
    USER() as 'USER()',
    CURRENT_USER() as 'CURRENT_USER()',
    SESSION_USER() as 'SESSION_USER()';
```

---

## 3. 🗄️ 数据库连接信息函数


### 3.1 DATABASE函数 - 当前数据库


**🔸 基本使用方法**
```sql
-- DATABASE() 获取当前选中的数据库
SELECT DATABASE();
-- 返回：'myapp' (如果当前在myapp数据库中)
-- 返回：NULL (如果没有选择数据库)

-- 检查是否选择了数据库
SELECT CASE 
    WHEN DATABASE() IS NULL THEN '未选择数据库'
    ELSE CONCAT('当前数据库：', DATABASE())
END as 数据库状态;
```

**💡 实际应用场景**
```sql
-- 1. 在存储过程中验证数据库环境
DELIMITER //
CREATE PROCEDURE validate_environment()
BEGIN
    IF DATABASE() != 'production_db' THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '此存储过程只能在生产数据库中执行';
    END IF;
    
    SELECT '环境验证通过' as result;
END //
DELIMITER ;

-- 2. 动态构建跨数据库查询
SET @current_db = DATABASE();
SET @query = CONCAT('SELECT COUNT(*) FROM ', @current_db, '.users');
PREPARE stmt FROM @query;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- 3. 在日志表中记录操作的数据库
INSERT INTO operation_log (database_name, user_name, action, timestamp)
VALUES (DATABASE(), USER(), 'SELECT', NOW());
```

### 3.2 SCHEMA函数 - 当前模式


**🔥 SCHEMA与DATABASE的关系**
```sql
-- SCHEMA() 与 DATABASE() 完全相同
SELECT SCHEMA(), DATABASE();
-- 返回结果完全一致

-- 为什么有两个相同的函数？
-- SCHEMA是SQL标准术语，DATABASE是MySQL传统用法
-- 在MySQL中，schema和database是同一概念
```

**🔧 使用建议**
```sql
-- 推荐使用DATABASE()，更直观
SELECT DATABASE() as current_db;

-- 在需要SQL标准兼容时使用SCHEMA()
SELECT SCHEMA() as current_schema;

-- 在存储过程中的应用
DELIMITER //
CREATE FUNCTION get_current_context()
RETURNS VARCHAR(200)
READS SQL DATA
BEGIN
    RETURN CONCAT('用户:', USER(), ' 数据库:', DATABASE());
END //
DELIMITER ;

SELECT get_current_context();
```

### 3.3 CONNECTION_ID函数 - 连接标识


**🔸 连接ID的作用**
```sql
-- CONNECTION_ID() 获取当前连接的唯一标识
SELECT CONNECTION_ID();
-- 返回：145 (每个连接都有唯一的数字ID)

-- 连接ID的用途：
-- 1. 标识不同的数据库连接
-- 2. 在进程列表中找到对应连接
-- 3. 终止特定连接
-- 4. 监控和调试
```

**📊 连接管理应用**
```sql
-- 1. 查看当前连接在进程列表中的信息
SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE ID = CONNECTION_ID();

-- 2. 记录连接信息用于调试
CREATE TABLE connection_log (
    connection_id BIGINT,
    user_name VARCHAR(100),
    database_name VARCHAR(100),
    connect_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO connection_log (connection_id, user_name, database_name)
VALUES (CONNECTION_ID(), USER(), DATABASE());

-- 3. 在应用中跟踪数据库连接
-- 应用启动时记录连接ID
SELECT CONCAT('应用连接ID: ', CONNECTION_ID()) as connection_info;

-- 4. 监控长时间运行的连接
SELECT 
    ID as 连接ID,
    USER as 用户,
    HOST as 主机,
    DB as 数据库,
    COMMAND as 命令,
    TIME as 运行时间,
    INFO as 查询语句
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE TIME > 60;  -- 运行超过60秒的连接
```

---

## 4. 📋 版本与环境信息函数


### 4.1 VERSION函数 - MySQL版本信息


**🔸 版本信息的重要性**
```sql
-- VERSION() 获取MySQL服务器版本
SELECT VERSION();
-- 返回：'8.0.35-0ubuntu0.22.04.1'

-- 版本信息包含的内容：
-- 主版本.次版本.修订版本-发行版信息
```

**💡 版本信息的实际应用**
```sql
-- 1. 检查MySQL版本兼容性
SELECT 
    VERSION() as mysql_version,
    CASE 
        WHEN VERSION() LIKE '8.0%' THEN 'MySQL 8.0 - 支持最新特性'
        WHEN VERSION() LIKE '5.7%' THEN 'MySQL 5.7 - 需要注意兼容性'
        WHEN VERSION() LIKE '5.6%' THEN 'MySQL 5.6 - 建议升级'
        ELSE '版本较老，强烈建议升级'
    END as version_status;

-- 2. 在应用中进行版本检查
DELIMITER //
CREATE FUNCTION check_mysql_version()
RETURNS VARCHAR(100)
READS SQL DATA
BEGIN
    DECLARE ver VARCHAR(50);
    SET ver = VERSION();
    
    IF ver LIKE '8.0%' THEN
        RETURN '版本检查通过';
    ELSE
        RETURN '版本不兼容，需要MySQL 8.0+';
    END IF;
END //
DELIMITER ;

-- 3. 环境信息收集
SELECT 
    VERSION() as MySQL版本,
    $$version_comment as 版本注释,
    $$version_compile_machine as 编译平台,
    $$version_compile_os as 编译系统;
```

### 4.2 系统变量获取


**🔧 常用系统变量查询**
```sql
-- 获取重要的系统配置信息
SELECT 
    $$hostname as 主机名,
    $$port as 端口号,
    $$datadir as 数据目录,
    $$basedir as 安装目录,
    $$character_set_server as 服务器字符集,
    $$collation_server as 服务器排序规则;

-- 获取性能相关配置
SELECT 
    $$max_connections as 最大连接数,
    $$innodb_buffer_pool_size as InnoDB缓冲池大小,
    $$query_cache_size as 查询缓存大小,
    $$tmp_table_size as 临时表大小;

-- 获取安全相关配置
SELECT 
    $$secure_file_priv as 安全文件路径,
    $$local_infile as 本地文件加载,
    $$sql_mode as SQL模式;
```

---

## 5. 🎯 操作结果信息函数


### 5.1 LAST_INSERT_ID函数 - 自增主键ID


**🔸 基本使用方法**
```sql
-- LAST_INSERT_ID() 获取最后插入记录的自增ID
-- 只有在INSERT包含自增字段时才有意义

-- 创建测试表
CREATE TABLE test_table (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入数据并获取ID
INSERT INTO test_table (name) VALUES ('测试记录');
SELECT LAST_INSERT_ID();  -- 返回：1

INSERT INTO test_table (name) VALUES ('第二条记录');
SELECT LAST_INSERT_ID();  -- 返回：2
```

**⚠️ 重要注意事项**
```sql
-- LAST_INSERT_ID()是连接级别的，不是全局的
-- 每个连接维护自己的LAST_INSERT_ID值

-- 示例：多连接环境下的行为
-- 连接A：
INSERT INTO test_table (name) VALUES ('连接A的记录');
SELECT LAST_INSERT_ID();  -- 返回插入记录的ID

-- 连接B：
INSERT INTO test_table (name) VALUES ('连接B的记录');
SELECT LAST_INSERT_ID();  -- 返回连接B插入记录的ID，与连接A无关

-- 安全性：不会受到其他连接的干扰
```

**💡 实际应用场景**
```sql
-- 1. 插入主表记录后，获取ID用于子表关联
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES (101, NOW(), 1299.99);

SET @order_id = LAST_INSERT_ID();

INSERT INTO order_items (order_id, product_id, quantity, price)
VALUES 
    (@order_id, 1001, 2, 299.99),
    (@order_id, 1002, 1, 699.99);

-- 2. 在存储过程中的应用
DELIMITER //
CREATE PROCEDURE create_user_with_profile(
    IN p_username VARCHAR(50),
    IN p_email VARCHAR(100),
    IN p_full_name VARCHAR(100)
)
BEGIN
    DECLARE user_id INT;
    
    -- 插入用户基本信息
    INSERT INTO users (username, email, created_time)
    VALUES (p_username, p_email, NOW());
    
    -- 获取插入的用户ID
    SET user_id = LAST_INSERT_ID();
    
    -- 插入用户详细信息
    INSERT INTO user_profiles (user_id, full_name, created_time)
    VALUES (user_id, p_full_name, NOW());
    
    SELECT user_id as created_user_id;
END //
DELIMITER ;

-- 3. 批量插入后获取起始ID
INSERT INTO batch_table (name) VALUES 
    ('记录1'), ('记录2'), ('记录3');

-- LAST_INSERT_ID()返回第一条记录的ID
SELECT LAST_INSERT_ID() as first_id;
-- 如果first_id=10，那么三条记录的ID分别是10,11,12
```

### 5.2 ROW_COUNT函数 - 影响行数


**🔥 ROW_COUNT的重要作用**
```sql
-- ROW_COUNT() 返回上一条语句影响的行数
-- 对于INSERT、UPDATE、DELETE特别有用

-- INSERT语句的影响行数
INSERT INTO test_table (name) VALUES ('新记录');
SELECT ROW_COUNT();  -- 返回：1

-- 批量INSERT
INSERT INTO test_table (name) VALUES ('记录1'), ('记录2'), ('记录3');
SELECT ROW_COUNT();  -- 返回：3

-- UPDATE语句的影响行数
UPDATE test_table SET name = '更新后的名称' WHERE id = 1;
SELECT ROW_COUNT();  -- 返回：1（如果更新成功）

-- DELETE语句的影响行数
DELETE FROM test_table WHERE id > 5;
SELECT ROW_COUNT();  -- 返回：删除的记录数
```

**📊 不同语句的ROW_COUNT返回值**
```sql
-- SELECT语句
SELECT * FROM test_table;
SELECT ROW_COUNT();  -- 返回：-1（SELECT不会改变ROW_COUNT）

-- 没有匹配行的UPDATE
UPDATE test_table SET name = '新名称' WHERE id = 99999;
SELECT ROW_COUNT();  -- 返回：0（没有行被更新）

-- 相同值的UPDATE（实际没有变化）
UPDATE test_table SET name = '原有名称' WHERE name = '原有名称';
SELECT ROW_COUNT();  -- 返回：0（值没有实际改变）
```

**🔧 实际应用场景**
```sql
-- 1. 在存储过程中检查操作结果
DELIMITER //
CREATE PROCEDURE update_user_status(
    IN p_user_id INT,
    IN p_status VARCHAR(20)
)
BEGIN
    DECLARE affected_rows INT;
    
    UPDATE users SET status = p_status WHERE id = p_user_id;
    SET affected_rows = ROW_COUNT();
    
    IF affected_rows = 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '用户不存在或状态未改变';
    ELSE
        SELECT CONCAT('成功更新 ', affected_rows, ' 行记录') as result;
    END IF;
END //
DELIMITER ;

-- 2. 批量操作的结果验证
-- 批量更新价格
UPDATE products SET price = price * 1.1 WHERE category = 'electronics';
SELECT CONCAT('共更新了 ', ROW_COUNT(), ' 个商品的价格') as update_result;

-- 3. 在应用程序中验证操作结果
-- Java示例逻辑（SQL部分）
UPDATE user_last_login SET last_login = NOW() WHERE user_id = ?;
-- 然后检查ROW_COUNT()来确认用户是否存在
```

### 5.3 FOUND_ROWS函数 - 查找行数


**🔸 FOUND_ROWS的特殊用途**
```sql
-- FOUND_ROWS() 与 SQL_CALC_FOUND_ROWS 配合使用
-- 获取不考虑LIMIT限制时的总行数

-- 使用SQL_CALC_FOUND_ROWS进行分页查询
SELECT SQL_CALC_FOUND_ROWS * 
FROM test_table 
LIMIT 5 OFFSET 10;

-- 获取总行数（不考虑LIMIT）
SELECT FOUND_ROWS() as total_rows;

-- 实际应用：分页查询
SELECT SQL_CALC_FOUND_ROWS id, name, created_time
FROM users 
WHERE status = 'active'
ORDER BY created_time DESC
LIMIT 20 OFFSET 0;

-- 获取符合条件的总记录数，用于计算总页数
SELECT FOUND_ROWS() as total_records;
```

**⚠️ 性能注意事项**
```sql
-- SQL_CALC_FOUND_ROWS 有性能开销
-- MySQL 8.0.17+ 已弃用，建议使用替代方案

-- 推荐的替代方案：
-- 1. 单独的COUNT查询
SELECT COUNT(*) as total_count FROM users WHERE status = 'active';
SELECT id, name FROM users WHERE status = 'active' LIMIT 20 OFFSET 0;

-- 2. 使用窗口函数（MySQL 8.0+）
SELECT 
    id, name,
    COUNT(*) OVER() as total_count
FROM users 
WHERE status = 'active'
ORDER BY created_time DESC
LIMIT 20;
```

---

## 6. 📊 系统状态与性能函数


### 6.1 系统状态信息查询


**🔧 获取系统运行状态**
```sql
-- 查看数据库运行时间
SHOW STATUS LIKE 'Uptime';
SELECT $$global.uptime;

-- 查看连接统计信息
SHOW STATUS LIKE 'Connections';
SHOW STATUS LIKE 'Max_used_connections';
SHOW STATUS LIKE 'Threads_connected';

-- 查看查询统计
SHOW STATUS LIKE 'Questions';
SHOW STATUS LIKE 'Queries';
SHOW STATUS LIKE 'Slow_queries';

-- 综合状态查询
SELECT 
    $$global.hostname as 主机名,
    $$global.port as 端口,
    $$global.version as 版本,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Uptime') as 运行时间秒,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Threads_connected') as 当前连接数,
    $$global.max_connections as 最大连接数;
```

### 6.2 性能监控相关查询


**📈 性能指标获取**
```sql
-- 创建系统监控视图
CREATE VIEW system_monitor AS
SELECT 
    CONNECTION_ID() as 当前连接ID,
    USER() as 当前用户,
    DATABASE() as 当前数据库,
    VERSION() as MySQL版本,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME='Threads_connected') as 活跃连接数,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME='Questions') as 总查询数,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME='Uptime') as 运行时间,
    NOW() as 查询时间;

-- 使用监控视图
SELECT * FROM system_monitor;

-- 计算查询频率
SELECT 
    ROUND(
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Questions') /
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Uptime'), 
        2
    ) as 平均每秒查询数;
```

**🔍 连接监控函数应用**
```sql
-- 监控当前会话信息
SELECT 
    CONNECTION_ID() as 连接ID,
    USER() as 登录用户,
    CURRENT_USER() as 权限用户,
    DATABASE() as 当前数据库,
    $$session.autocommit as 自动提交状态,
    $$session.transaction_isolation as 事务隔离级别;

-- 创建会话监控存储过程
DELIMITER //
CREATE PROCEDURE session_info()
BEGIN
    SELECT 
        'SESSION INFO' as 类别,
        CONNECTION_ID() as 连接ID,
        USER() as 用户,
        DATABASE() as 数据库,
        VERSION() as 版本;
    
    SELECT 
        'SESSION VARIABLES' as 类别,
        $$session.sql_mode as SQL模式,
        $$session.autocommit as 自动提交,
        $$session.tx_isolation as 事务隔离级别;
        
    SELECT 
        'CONNECTION STATUS' as 类别,
        (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST) as 总连接数,
        (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE DB = DATABASE()) as 当前库连接数;
END //
DELIMITER ;

CALL session_info();
```

---

## 7. 🔐 安全注意事项与监控应用


### 7.1 系统信息函数的安全注意事项


**⚠️ 信息泄露风险**
```sql
-- 敏感信息泄露风险示例
-- 这些信息可能被恶意用户利用

-- 系统路径信息
SELECT $$datadir, $$basedir, $$secure_file_priv;

-- 版本信息可能暴露已知漏洞
SELECT VERSION();

-- 用户和权限信息
SELECT USER(), CURRENT_USER();

-- 系统配置信息
SELECT $$hostname, $$port;
```

**🔒 安全防护措施**
```sql
-- 1. 限制普通用户的系统函数使用权限
-- 创建受限用户
CREATE USER 'limited_user'@'%' IDENTIFIED BY 'password123';
GRANT SELECT ON myapp.* TO 'limited_user'@'%';

-- 2. 在应用中谨慎使用系统函数
-- 避免在用户可见的地方显示系统信息
-- 不要在错误信息中包含系统详情

-- 3. 创建安全的系统信息查询函数
DELIMITER //
CREATE FUNCTION safe_user_info()
RETURNS VARCHAR(100)
READS SQL DATA
DETERMINISTIC
BEGIN
    -- 只返回用户名部分，隐藏主机信息
    RETURN SUBSTRING_INDEX(USER(), '@', 1);
END //
DELIMITER ;

SELECT safe_user_info() as 用户名;
```

**📋 安全审计应用**
```sql
-- 创建安全审计日志表
CREATE TABLE security_audit (
    id INT AUTO_INCREMENT PRIMARY KEY,
    connection_id BIGINT,
    user_name VARCHAR(100),
    database_name VARCHAR(100),
    client_ip VARCHAR(45),
    action_type VARCHAR(50),
    action_detail TEXT,
    action_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_time (user_name, action_time),
    INDEX idx_connection (connection_id)
);

-- 安全审计存储过程
DELIMITER //
CREATE PROCEDURE log_security_event(
    IN action_type VARCHAR(50),
    IN action_detail TEXT
)
BEGIN
    INSERT INTO security_audit (
        connection_id,
        user_name,
        database_name,
        client_ip,
        action_type,
        action_detail
    ) VALUES (
        CONNECTION_ID(),
        USER(),
        DATABASE(),
        SUBSTRING_INDEX(USER(), '@', -1),  -- 提取主机部分作为IP
        action_type,
        action_detail
    );
END //
DELIMITER ;

-- 使用示例
CALL log_security_event('LOGIN', '用户登录系统');
CALL log_security_event('QUERY', '查询敏感数据表');
```

### 7.2 系统函数在监控中的应用


**📊 数据库监控仪表板**
```sql
-- 创建监控数据收集视图
CREATE VIEW db_monitor_dashboard AS
SELECT 
    -- 基础信息
    VERSION() as mysql_version,
    $$hostname as server_hostname,
    $$port as server_port,
    
    -- 连接信息
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME='Threads_connected') as current_connections,
    $$global.max_connections as max_connections,
    ROUND(
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
         WHERE VARIABLE_NAME='Threads_connected') * 100.0 / $$global.max_connections, 
        2
    ) as connection_usage_percent,
    
    -- 性能指标
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME='Questions') as total_queries,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME='Slow_queries') as slow_queries,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME='Uptime') as uptime_seconds,
    
    -- 计算每秒查询数
    ROUND(
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Questions') /
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Uptime'), 
        2
    ) as queries_per_second,
    
    NOW() as monitor_time;

-- 查看监控仪表板
SELECT * FROM db_monitor_dashboard;
```

**🔍 实时监控存储过程**
```sql
DELIMITER //
CREATE PROCEDURE realtime_monitor()
BEGIN
    -- 显示当前系统状态
    SELECT 
        '=== 系统基础信息 ===' as section,
        VERSION() as mysql_version,
        USER() as current_user,
        DATABASE() as current_database,
        CONNECTION_ID() as connection_id,
        NOW() as current_time;
    
    -- 显示连接统计
    SELECT 
        '=== 连接统计 ===' as section,
        (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST) as total_connections,
        (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE COMMAND != 'Sleep') as active_connections,
        (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE TIME > 60) as long_running_queries,
        $$global.max_connections as max_connections_limit;
    
    -- 显示性能统计
    SELECT 
        '=== 性能统计 ===' as section,
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Questions') as total_questions,
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Slow_queries') as slow_queries,
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Uptime') as uptime_seconds,
        ROUND(
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Questions') /
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Uptime'), 
            2
        ) as avg_queries_per_second;
    
    -- 显示当前活跃连接详情
    SELECT 
        '=== 活跃连接详情 ===' as section,
        ID as connection_id,
        USER as user_name,
        HOST as client_host,
        DB as database_name,
        COMMAND as current_command,
        TIME as execution_time,
        LEFT(IFNULL(INFO, ''), 100) as query_preview
    FROM INFORMATION_SCHEMA.PROCESSLIST 
    WHERE COMMAND != 'Sleep' 
    ORDER BY TIME DESC 
    LIMIT 10;
END //
DELIMITER ;

-- 执行实时监控
CALL realtime_monitor();
```

**📈 历史监控数据收集**
```sql
-- 创建监控数据历史表
CREATE TABLE monitor_history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    monitor_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    mysql_version VARCHAR(50),
    current_connections INT,
    max_connections INT,
    connection_usage_percent DECIMAL(5,2),
    total_queries BIGINT,
    slow_queries BIGINT,
    uptime_seconds BIGINT,
    queries_per_second DECIMAL(10,2),
    INDEX idx_monitor_time (monitor_time)
);

-- 监控数据收集存储过程
DELIMITER //
CREATE PROCEDURE collect_monitor_data()
BEGIN
    INSERT INTO monitor_history (
        mysql_version,
        current_connections,
        max_connections,
        connection_usage_percent,
        total_queries,
        slow_queries,
        uptime_seconds,
        queries_per_second
    )
    SELECT 
        mysql_version,
        current_connections,
        max_connections,
        connection_usage_percent,
        total_queries,
        slow_queries,
        uptime_seconds,
        queries_per_second
    FROM db_monitor_dashboard;
END //
DELIMITER ;

-- 设置定时任务收集监控数据（需要配置Event Scheduler）
CREATE EVENT monitor_data_collection
ON SCHEDULE EVERY 5 MINUTE
DO CALL collect_monitor_data();

-- 启用事件调度器
SET GLOBAL event_scheduler = ON;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 系统信息函数的本质理解**
```
系统信息函数的特点：
• 无需参数，直接调用即可获取信息
• 返回当前会话或系统的实时状态
• 执行效率高，对性能影响minimal
• 主要用于监控、审计、调试场景

核心函数分类：
• 身份识别：USER()、CURRENT_USER()
• 环境信息：DATABASE()、VERSION()、CONNECTION_ID()
• 操作结果：LAST_INSERT_ID()、ROW_COUNT()
• 系统状态：各种系统变量和状态值
```

**🔸 关键函数的重要区别**
```
USER() vs CURRENT_USER()：
• USER()：登录时使用的完整用户标识
• CURRENT_USER()：MySQL实际匹配的权限用户
• 区别：在通配符用户匹配时会不同

DATABASE() vs SCHEMA()：
• 两者完全相同，只是命名不同
• SCHEMA是SQL标准术语，DATABASE是MySQL传统用法

LAST_INSERT_ID() 特点：
• 连接级别，不是全局的
• 只在包含自增字段的INSERT后有意义
• 批量插入时返回第一条记录的ID
```

### 8.2 实际应用的关键要点


**🔹 在业务开发中的应用**
```sql
-- 1. 审计日志记录
INSERT INTO audit_log (user_name, database_name, action, timestamp)
VALUES (USER(), DATABASE(), '敏感操作', NOW());

-- 2. 权限控制
IF CURRENT_USER() NOT LIKE 'admin@%' THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '权限不足';
END IF;

-- 3. 主从表关联插入
INSERT INTO master_table (...) VALUES (...);
SET @master_id = LAST_INSERT_ID();
INSERT INTO detail_table (master_id, ...) VALUES (@master_id, ...);

-- 4. 操作结果验证
UPDATE user_table SET status = 'active' WHERE user_id = ?;
IF ROW_COUNT() = 0 THEN
    -- 用户不存在的处理逻辑
END IF;
```

**🔹 监控和运维中的应用**
```sql
-- 系统状态监控
SELECT 
    VERSION() as 版本,
    CONNECTION_ID() as 连接ID,
    (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST) as 总连接数,
    $$global.max_connections as 最大连接数;

-- 性能指标计算
SELECT 
    ROUND(
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Questions') /
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Uptime'), 
        2
    ) as QPS;
```

### 8.3 安全和最佳实践


**🔒 安全注意事项**
```
信息泄露防护：
• 不要在用户界面显示详细的系统信息
• 限制普通用户对系统函数的访问
• 在错误信息中避免暴露系统详情
• 对敏感的系统信息进行访问控制

审计和监控：
• 记录关键操作的用户和时间信息
• 监控异常的连接和查询行为
• 建立完整的操作审计日志
• 定期分析系统访问模式
```

**⭐ 最佳实践建议**
```
开发阶段：
• 使用系统函数进行环境验证
• 在存储过程中加入适当的检查逻辑
• 利用LAST_INSERT_ID()处理主从表关联
• 使用ROW_COUNT()验证操作结果

运维阶段：
• 建立基于系统函数的监控体系
• 使用CONNECTION_ID()跟踪问题连接
• 定期收集系统状态信息
• 建立自动化的健康检查机制

性能优化：
• 避免频繁调用FOUND_ROWS()
• 合理使用系统变量查询
• 在监控中避免过于频繁的系统函数调用
```

### 8.4 学习建议和扩展


**📚 深入学习方向**
```
基础巩固：
• 熟练掌握所有核心系统函数的用法
• 理解函数返回值的含义和适用场景
• 掌握在存储过程中的应用技巧

进阶应用：
• 结合INFORMATION_SCHEMA进行系统监控
• 设计完整的审计日志系统
• 实现自动化的性能监控方案
• 掌握系统函数在集群环境中的应用

实战项目：
• 开发数据库监控仪表板
• 实现用户操作审计系统
• 设计数据库健康检查工具
• 构建自动化运维脚本
```

**🎯 常见问题和解决方案**
```
问题1：USER()和CURRENT_USER()返回不同值
解决：理解MySQL用户匹配机制，检查用户权限配置

问题2：LAST_INSERT_ID()返回意外值
解决：确认是否在正确的连接中调用，是否有自增字段

问题3：ROW_COUNT()返回-1或0
解决：检查上一条语句类型，确认是否有实际的数据变更

问题4：系统函数在复制环境中的行为
解决：了解主从复制中系统函数的处理机制
```

**核心记忆**：
- 系统信息函数提供数据库环境的实时状态信息
- USER()显示登录身份，CURRENT_USER()显示权限身份
- LAST_INSERT_ID()和ROW_COUNT()帮助处理操作结果
- 系统函数在监控、审计、调试中发挥重要作用
- 使用时要注意安全性，避免信息泄露风险