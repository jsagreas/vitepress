---
title: 20、信息函数与诊断
---
## 📚 目录

1. [连接信息函数](#1-连接信息函数)
2. [数据库状态函数](#2-数据库状态函数) 
3. [性能诊断函数](#3-性能诊断函数)
4. [资源使用函数](#4-资源使用函数)
5. [系统监控函数](#5-系统监控函数)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔗 连接信息函数


### 1.1 什么是连接信息函数


**🔸 基本概念**
```
连接信息函数：用于获取当前MySQL连接相关信息的内置函数
作用：帮助开发者了解当前连接状态、用户信息、连接参数等
应用场景：调试、监控、安全审计、连接管理
```

**💡 通俗理解**
想象你打电话给客服，连接信息函数就像是**"通话信息显示"**，它能告诉你：
- 你是谁（用户身份）
- 你从哪里打来的（客户端信息）
- 这通电话的编号（连接ID）
- 通话质量如何（连接状态）

### 1.2 核心连接信息函数


**👤 用户身份相关函数**

| 函数名 | **作用** | **返回示例** | **使用场景** |
|--------|---------|-------------|-------------|
| `USER()` | `当前连接的完整用户信息` | `root@localhost` | `身份验证，日志记录` |
| `CURRENT_USER()` | `实际生效的用户权限` | `admin@'%'` | `权限检查，安全审计` |
| `SESSION_USER()` | `会话用户（同USER）` | `app@192.168.1.100` | `会话管理` |
| `SYSTEM_USER()` | `系统层面的用户` | `mysql.sys@localhost` | `系统级操作识别` |

**📝 实际应用示例**
```sql
-- 查看当前用户信息
SELECT 
    USER() as '连接用户',
    CURRENT_USER() as '生效权限用户',
    SESSION_USER() as '会话用户';

-- 结果示例：
-- 连接用户: app_user@192.168.1.100
-- 生效权限用户: app_user@'192.168.%'  
-- 会话用户: app_user@192.168.1.100
```

> ⚠️ **重要区别**：`USER()`显示连接时的用户名，`CURRENT_USER()`显示实际匹配的权限用户名

**🔌 连接标识相关函数**

| 函数名 | **作用** | **返回类型** | **典型用途** |
|--------|---------|-------------|-------------|
| `CONNECTION_ID()` | `获取当前连接的唯一ID` | `数字` | `连接跟踪，性能分析` |
| `DATABASE()` | `当前使用的数据库名` | `字符串` | `上下文检查` |
| `SCHEMA()` | `当前数据库（同DATABASE）` | `字符串` | `兼容性使用` |

**🛠️ 实践示例**
```sql
-- 连接信息总览
SELECT 
    CONNECTION_ID() as '连接ID',
    DATABASE() as '当前数据库',
    USER() as '用户信息',
    NOW() as '当前时间';

-- 应用场景：在应用日志中记录操作上下文
INSERT INTO operation_log 
VALUES (CONNECTION_ID(), USER(), DATABASE(), 'SELECT', NOW());
```

### 1.3 版本与环境信息


**📋 版本信息函数**
```sql
-- 查看MySQL版本信息
SELECT 
    VERSION() as 'MySQL版本',
    $$version_comment as '版本说明',
    $$version_compile_os as '编译操作系统',
    $$version_compile_machine as '编译架构';

-- 典型输出：
-- MySQL版本: 8.0.32
-- 版本说明: MySQL Community Server - GPL
-- 编译操作系统: Linux
-- 编译架构: x86_64
```

**🌍 字符集与编码信息**
```sql
-- 字符集相关信息
SELECT 
    $$character_set_client as '客户端字符集',
    $$character_set_connection as '连接字符集', 
    $$character_set_results as '结果字符集',
    $$character_set_server as '服务器字符集',
    $$collation_connection as '连接校对规则';
```

### 1.4 连接参数查询


**⚙️ 重要连接参数**
```sql
-- 查看连接相关参数
SELECT 
    $$max_connections as '最大连接数',
    $$max_user_connections as '单用户最大连接',
    $$connect_timeout as '连接超时秒数',
    $$wait_timeout as '等待超时秒数',
    $$interactive_timeout as '交互超时秒数';

-- 网络相关参数
SELECT 
    $$max_allowed_packet as '最大数据包大小',
    $$net_read_timeout as '网络读取超时',
    $$net_write_timeout as '网络写入超时',
    $$net_buffer_length as '网络缓冲区大小';
```

**📊 连接状态检查**
```sql
-- 实用的连接健康检查查询
SELECT 
    'CONNECTION_CHECK' as '检查项目',
    CASE 
        WHEN CONNECTION_ID() IS NOT NULL THEN '连接正常'
        ELSE '连接异常'
    END as '连接状态',
    USER() as '当前用户',
    DATABASE() as '当前数据库',
    $$autocommit as '自动提交状态',
    $$tx_isolation as '事务隔离级别';
```

---

## 2. 📊 数据库状态函数


### 2.1 数据库状态监控基础


**🔸 状态监控的重要性**
```
为什么需要监控数据库状态：
• 性能问题：及时发现性能瓶颈
• 资源使用：监控内存、磁盘、CPU使用情况  
• 连接管理：跟踪连接数量和状态
• 安全审计：监控异常访问和操作
```

**💡 状态信息的层次结构**
```
全局状态：整个MySQL实例的状态信息
会话状态：当前连接会话的状态信息
存储引擎状态：InnoDB、MyISAM等存储引擎状态
复制状态：主从复制相关状态
```

### 2.2 核心状态查询函数


**📈 SHOW STATUS 语句详解**
```sql
-- 查看全局状态变量
SHOW GLOBAL STATUS;

-- 查看会话状态变量  
SHOW SESSION STATUS;

-- 查看特定状态变量
SHOW STATUS LIKE 'Connections';
SHOW STATUS WHERE Variable_name IN ('Threads_connected', 'Threads_running');

-- 使用LIKE模糊匹配
SHOW STATUS LIKE 'Com_%';  -- 查看所有命令统计
SHOW STATUS LIKE 'Innodb_%';  -- 查看InnoDB相关状态
```

**🔍 常用状态变量解析**

| 状态变量 | **含义** | **重要程度** | **关注指标** |
|---------|---------|-------------|-------------|
| `Connections` | `总连接数（累计）` | `⭐⭐⭐⭐⭐` | `连接趋势` |
| `Threads_connected` | `当前连接数` | `⭐⭐⭐⭐⭐` | `实时连接监控` |
| `Threads_running` | `正在执行的线程数` | `⭐⭐⭐⭐☆` | `并发性能` |
| `Queries` | `总查询数（累计）` | `⭐⭐⭐⭐☆` | `负载评估` |
| `Questions` | `客户端发送的语句数` | `⭐⭐⭐☆☆` | `真实负载` |
| `Uptime` | `MySQL运行时间（秒）` | `⭐⭐⭐☆☆` | `稳定性监控` |

### 2.3 连接状态监控


**🔗 连接相关状态监控**
```sql
-- 连接状态总览
SELECT 
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Threads_connected') as '当前连接数',
     
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Threads_running') as '活跃连接数',
     
    (SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
     WHERE VARIABLE_NAME = 'max_connections') as '最大连接数',
     
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Threads_connected') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
         WHERE VARIABLE_NAME = 'max_connections') * 100, 2
    ) as '连接使用率%';
```

**📋 连接详细信息查询**
```sql
-- 查看所有活跃连接
SELECT 
    ID as '连接ID',
    USER as '用户',
    HOST as '来源主机',
    DB as '数据库',
    COMMAND as '当前命令',
    TIME as '执行时间(秒)',
    STATE as '状态',
    LEFT(INFO, 50) as 'SQL片段'
FROM information_schema.PROCESSLIST
WHERE COMMAND != 'Sleep'
ORDER BY TIME DESC;

-- 统计各状态连接数
SELECT 
    COMMAND as '命令类型',
    COUNT(*) as '连接数量',
    AVG(TIME) as '平均执行时间'
FROM information_schema.PROCESSLIST 
GROUP BY COMMAND
ORDER BY COUNT(*) DESC;
```

### 2.4 性能状态指标


**⚡ 查询性能相关状态**
```sql
-- 查询执行统计
SELECT 
    VARIABLE_NAME as '指标名称',
    VARIABLE_VALUE as '数值',
    CASE VARIABLE_NAME
        WHEN 'Com_select' THEN 'SELECT语句执行次数'
        WHEN 'Com_insert' THEN 'INSERT语句执行次数'  
        WHEN 'Com_update' THEN 'UPDATE语句执行次数'
        WHEN 'Com_delete' THEN 'DELETE语句执行次数'
        WHEN 'Slow_queries' THEN '慢查询数量'
        ELSE '其他'
    END as '说明'
FROM performance_schema.global_status 
WHERE VARIABLE_NAME IN (
    'Com_select', 'Com_insert', 'Com_update', 'Com_delete', 'Slow_queries'
);
```

**🎯 关键性能比率计算**
```sql
-- 重要性能比率计算
SELECT 
    'Query_Cache_Hit_Rate' as '指标',
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Qcache_hits') /
        ((SELECT VARIABLE_VALUE FROM performance_schema.global_status 
          WHERE VARIABLE_NAME = 'Qcache_hits') +
         (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
          WHERE VARIABLE_NAME = 'Com_select')) * 100, 2
    ) as '查询缓存命中率%'
    
UNION ALL

SELECT 
    'Buffer_Pool_Hit_Rate' as '指标',
    ROUND(
        (1 - (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
              WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
             (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
              WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')) * 100, 2
    ) as 'InnoDB缓冲池命中率%';
```

---

## 3. 🚀 性能诊断函数


### 3.1 性能诊断概述


**🔸 性能诊断的目标**
```
识别瓶颈：找出系统性能的限制因素
量化影响：测量性能问题的具体影响
优化方向：为性能优化提供数据支撑
预防问题：在问题严重化前发现并解决
```

**🎯 性能诊断的维度**
```
时间维度：查询执行时间、等待时间
资源维度：CPU、内存、磁盘I/O、网络
并发维度：锁竞争、线程竞争
数据维度：扫描行数、返回行数
```

### 3.2 查询性能分析函数


**📊 执行计划分析**
```sql
-- 使用EXPLAIN分析查询性能
EXPLAIN SELECT * FROM users WHERE age > 25 AND city = '北京';

-- 详细的执行计划信息
EXPLAIN FORMAT=JSON 
SELECT u.name, o.total 
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
WHERE u.status = 'active';
```

**⏱️ 查询性能计时函数**
```sql
-- 开启性能分析
SET profiling = 1;

-- 执行要分析的查询
SELECT COUNT(*) FROM large_table WHERE status = 'active';

-- 查看性能分析结果
SHOW PROFILES;

-- 查看具体查询的详细性能信息
SHOW PROFILE FOR QUERY 1;

-- 查看CPU和I/O使用情况
SHOW PROFILE CPU, BLOCK IO FOR QUERY 1;
```

**🔍 慢查询分析**
```sql
-- 查看慢查询相关配置
SELECT 
    $$slow_query_log as '慢查询日志开启状态',
    $$long_query_time as '慢查询阈值(秒)',
    $$slow_query_log_file as '慢查询日志文件',
    $$log_queries_not_using_indexes as '记录未使用索引查询';

-- 查看慢查询统计
SHOW STATUS LIKE 'Slow_queries';
```

### 3.3 锁与并发分析


**🔒 锁状态分析**
```sql
-- 查看当前锁等待情况
SELECT 
    r.trx_id AS '等待事务ID',
    r.trx_mysql_thread_id AS '等待线程ID',
    r.trx_query AS '等待查询',
    b.trx_id AS '阻塞事务ID', 
    b.trx_mysql_thread_id AS '阻塞线程ID',
    b.trx_query AS '阻塞查询'
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id;

-- InnoDB锁状态总览
SELECT 
    (SELECT COUNT(*) FROM information_schema.innodb_trx) as '活跃事务数',
    (SELECT COUNT(*) FROM information_schema.innodb_locks) as '当前锁数量',
    (SELECT COUNT(*) FROM information_schema.innodb_lock_waits) as '等待锁数量';
```

**⚡ 并发性能指标**
```sql
-- 并发相关性能指标
SELECT 
    VARIABLE_NAME as '指标名称',
    VARIABLE_VALUE as '当前值',
    CASE VARIABLE_NAME
        WHEN 'Threads_running' THEN '当前执行线程数'
        WHEN 'Threads_connected' THEN '当前连接数'
        WHEN 'Table_locks_waited' THEN '表锁等待次数'
        WHEN 'Innodb_row_lock_waits' THEN '行锁等待次数'
        WHEN 'Innodb_row_lock_time' THEN '行锁等待总时间(ms)'
    END as '说明'
FROM performance_schema.global_status
WHERE VARIABLE_NAME IN (
    'Threads_running',
    'Threads_connected', 
    'Table_locks_waited',
    'Innodb_row_lock_waits',
    'Innodb_row_lock_time'
);
```

### 3.4 索引使用分析


**📈 索引效率分析**
```sql
-- 分析表的索引使用情况
SELECT 
    TABLE_SCHEMA as '数据库',
    TABLE_NAME as '表名',
    NON_UNIQUE as '是否唯一',
    INDEX_NAME as '索引名',
    COLUMN_NAME as '列名',
    CARDINALITY as '唯一值数量',
    NULLABLE as '是否可空'
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, SEQ_IN_INDEX;

-- 找出可能需要添加索引的查询
SELECT 
    SCHEMA_NAME as '数据库',
    DIGEST_TEXT as 'SQL模式',
    COUNT_STAR as '执行次数',
    AVG_TIMER_WAIT/1000000000 as '平均执行时间(秒)',
    ROWS_EXAMINED_AVG as '平均扫描行数',
    ROWS_SENT_AVG as '平均返回行数'
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL 
AND AVG_TIMER_WAIT > 1000000000  -- 执行时间超过1秒
ORDER BY COUNT_STAR DESC
LIMIT 10;
```

---

## 4. 💾 资源使用函数


### 4.1 内存使用监控


**🧠 内存相关状态变量**
```sql
-- 查看内存使用相关配置和状态
SELECT 
    VARIABLE_NAME as '配置项',
    VARIABLE_VALUE as '值',
    CASE 
        WHEN VARIABLE_VALUE REGEXP '^[0-9]+$' THEN 
            CONCAT(ROUND(VARIABLE_VALUE/1024/1024, 2), ' MB')
        ELSE VARIABLE_VALUE
    END as '易读格式'
FROM performance_schema.global_variables
WHERE VARIABLE_NAME IN (
    'innodb_buffer_pool_size',      -- InnoDB缓冲池大小
    'key_buffer_size',              -- MyISAM键缓冲区大小  
    'query_cache_size',             -- 查询缓存大小
    'sort_buffer_size',             -- 排序缓冲区大小
    'read_buffer_size',             -- 读缓冲区大小
    'max_allowed_packet'            -- 最大数据包大小
);
```

**📊 InnoDB缓冲池详细分析**
```sql
-- InnoDB缓冲池使用情况
SELECT 
    'Buffer_Pool_Size' as '指标',
    ROUND((SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
           WHERE VARIABLE_NAME = 'innodb_buffer_pool_size') / 1024 / 1024, 2) as '缓冲池大小(MB)'
           
UNION ALL

SELECT 
    'Buffer_Pool_Pages_Total',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total')
     
UNION ALL

SELECT 
    'Buffer_Pool_Pages_Free',  
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_free')
     
UNION ALL

SELECT 
    'Buffer_Pool_Hit_Rate%',
    ROUND((1 - 
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
    ) * 100, 2);
```

### 4.2 磁盘I/O监控


**💿 磁盘I/O相关指标**
```sql
-- 磁盘I/O统计信息
SELECT 
    'Physical_Reads' as '指标',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_data_reads') as '物理读取次数'
     
UNION ALL

SELECT 
    'Physical_Writes',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_data_writes') as '物理写入次数'
     
UNION ALL  

SELECT 
    'Data_Read(MB)',
    ROUND((SELECT VARIABLE_VALUE FROM performance_schema.global_status 
           WHERE VARIABLE_NAME = 'Innodb_data_read') / 1024 / 1024, 2)
           
UNION ALL

SELECT 
    'Data_Written(MB)',
    ROUND((SELECT VARIABLE_VALUE FROM performance_schema.global_status 
           WHERE VARIABLE_NAME = 'Innodb_data_written') / 1024 / 1024, 2);
```

**📈 I/O性能比率分析**
```sql
-- I/O效率分析
SELECT 
    '读写比率' as '分析维度',
    CONCAT(
        ROUND((SELECT VARIABLE_VALUE FROM performance_schema.global_status 
               WHERE VARIABLE_NAME = 'Innodb_data_reads') /
              (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
               WHERE VARIABLE_NAME = 'Innodb_data_writes'), 2),
        ':1'
    ) as '读:写'
    
UNION ALL

SELECT 
    '缓存命中率',
    CONCAT(
        ROUND((1 - (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
                    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
                   (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
                    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')) * 100, 2),
        '%'
    );
```

### 4.3 临时表使用监控


**🔄 临时表相关状态**
```sql  
-- 临时表使用情况
SELECT 
    'Created_tmp_tables' as '指标',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Created_tmp_tables') as '创建临时表总数'
     
UNION ALL

SELECT 
    'Created_tmp_disk_tables',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') as '磁盘临时表数'
     
UNION ALL

SELECT 
    'Tmp_table_to_disk_rate%',
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100, 2
    ) as '磁盘临时表比率';

-- 相关配置参数
SELECT 
    VARIABLE_NAME as '参数',
    VARIABLE_VALUE as '值',
    CASE VARIABLE_NAME
        WHEN 'tmp_table_size' THEN '临时表最大内存大小'
        WHEN 'max_heap_table_size' THEN 'MEMORY引擎表最大大小'
    END as '说明'
FROM performance_schema.global_variables
WHERE VARIABLE_NAME IN ('tmp_table_size', 'max_heap_table_size');
```

### 4.4 资源使用优化建议


**💡 资源优化检查清单**
```sql
-- 综合资源使用健康检查
SELECT 
    '连接使用率' as '检查项目',
    CONCAT(
        ROUND(
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Threads_connected') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
             WHERE VARIABLE_NAME = 'max_connections') * 100, 1
        ), '%'
    ) as '当前状态',
    CASE 
        WHEN (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
              WHERE VARIABLE_NAME = 'Threads_connected') /
             (SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
              WHERE VARIABLE_NAME = 'max_connections') > 0.8 
        THEN '⚠️ 警告：连接数过高'
        ELSE '✅ 正常'
    END as '状态评估'
    
UNION ALL

SELECT 
    '缓冲池命中率',
    CONCAT(
        ROUND((1 - 
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
        ) * 100, 2), '%'
    ),
    CASE 
        WHEN (1 - 
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
        ) < 0.95 
        THEN '⚠️ 警告：命中率偏低'
        ELSE '✅ 正常'
    END;
```

---

## 5. 🔍 系统监控函数


### 5.1 系统运行状态监控


**⏰ 系统运行时间和负载**
```sql
-- 系统基本运行状态
SELECT 
    'MySQL_Uptime' as '监控项',
    SEC_TO_TIME((SELECT VARIABLE_VALUE FROM performance_schema.global_status 
                WHERE VARIABLE_NAME = 'Uptime')) as '运行时间',
    'MySQL已连续运行时间' as '说明'
    
UNION ALL

SELECT 
    'Total_Connections',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Connections'),
    '累计连接数'
    
UNION ALL

SELECT 
    'QPS(Queries_Per_Second)',
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Queries') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Uptime'), 2
    ),
    '平均每秒查询数';
```

**📊 实时性能指标监控**
```sql
-- 创建一个监控视图来持续观察性能
CREATE OR REPLACE VIEW mysql_health_monitor AS
SELECT 
    NOW() as '检查时间',
    
    -- 连接监控
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Threads_connected') as '当前连接数',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Threads_running') as '活跃线程数',
     
    -- 性能监控  
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Queries') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Uptime'), 2
    ) as 'QPS',
    
    -- 资源监控
    ROUND((1 - 
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
    ) * 100, 2) as '缓冲池命中率%',
    
    -- 异常监控
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Slow_queries') as '慢查询数',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Aborted_connects') as '连接中断数';

-- 使用监控视图
SELECT * FROM mysql_health_monitor;
```

### 5.2 错误和异常监控


**⚠️ 错误统计监控**
```sql
-- 错误和异常状态监控
SELECT 
    'Connection_Errors' as '错误类型',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Aborted_connects') as '连接中断数',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Aborted_clients') as '客户端中断数'
     
UNION ALL

SELECT 
    'Access_Denied',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Access_denied_errors'), 
    NULL
    
UNION ALL

SELECT 
    'Table_Locks_Waited',
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Table_locks_waited'),
    NULL;
```

**🔐 安全相关监控**
```sql
-- 安全事件监控
SELECT 
    sl.USER as '用户',
    sl.HOST as '来源主机',
    sl.ERROR_NUMBER as '错误代码',
    sl.ERROR_MESSAGE as '错误信息',
    sl.SQL_TEXT as 'SQL语句',
    sl.TIMESTAMP as '发生时间'
FROM performance_schema.events_statements_history sl
WHERE sl.SQL_TEXT IS NOT NULL 
AND (sl.ERROR_NUMBER != 0 OR sl.SQL_TEXT LIKE '%DROP%' OR sl.SQL_TEXT LIKE '%DELETE%')
ORDER BY sl.TIMESTAMP DESC
LIMIT 10;
```

### 5.3 复制状态监控


**🔄 主从复制监控**
```sql
-- 主库状态监控
SHOW MASTER STATUS;

-- 从库状态监控（在从库执行）
SHOW SLAVE STATUS\G

-- 复制延迟监控查询
SELECT 
    CHANNEL_NAME as '复制通道',
    HOST as '主库地址', 
    PORT as '主库端口',
    USER as '复制用户',
    SOURCE_LOG_FILE as '主库日志文件',
    READ_SOURCE_LOG_POS as '读取位置',
    RELAY_LOG_FILE as '中继日志文件',
    SERVICE_STATE as '服务状态'
FROM performance_schema.replication_connection_configuration;
```

### 5.4 自动化监控脚本


**🤖 监控脚本示例**
```sql
-- 创建存储过程进行自动健康检查
DELIMITER $$

CREATE PROCEDURE mysql_health_check()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE warning_count INT DEFAULT 0;
    
    -- 检查连接数
    IF (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
        WHERE VARIABLE_NAME = 'Threads_connected') /
       (SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
        WHERE VARIABLE_NAME = 'max_connections') > 0.8 
    THEN
        SELECT '⚠️ 警告：连接数使用率超过80%' as '健康检查结果';
        SET warning_count = warning_count + 1;
    END IF;
    
    -- 检查缓冲池命中率
    IF (1 - (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')) < 0.95 
    THEN
        SELECT '⚠️ 警告：InnoDB缓冲池命中率低于95%' as '健康检查结果';
        SET warning_count = warning_count + 1;
    END IF;
    
    -- 检查慢查询
    IF (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
        WHERE VARIABLE_NAME = 'Slow_queries') > 0 
    THEN
        SELECT CONCAT('⚠️ 提醒：发现 ', 
                     (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
                      WHERE VARIABLE_NAME = 'Slow_queries'), 
                     ' 个慢查询') as '健康检查结果';
        SET warning_count = warning_count + 1;
    END IF;
    
    -- 如果没有警告
    IF warning_count = 0 THEN
        SELECT '✅ 系统状态正常，所有指标都在健康范围内' as '健康检查结果';
    END IF;
    
END$$

DELIMITER ;

-- 执行健康检查
CALL mysql_health_check();
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 连接信息函数：USER()、CONNECTION_ID()、DATABASE()等
🔸 状态监控：SHOW STATUS用于查看运行状态
🔸 性能诊断：EXPLAIN、SHOW PROFILE分析查询性能
🔸 资源监控：内存、I/O、临时表使用情况
🔸 系统监控：运行时间、QPS、错误统计等综合指标
```

### 6.2 关键理解要点


**🔹 监控的重要性**
```
预防胜于治疗：
• 通过监控及早发现问题
• 避免问题扩大化影响业务
• 为性能优化提供数据支撑

数据驱动决策：
• 用具体数字说话，而不是感觉
• 建立性能基线，识别异常波动
• 量化优化效果，验证改进成果
```

**🔹 监控指标的层次**
```
基础指标（必须监控）：
• 连接数、QPS、响应时间
• 缓冲池命中率、慢查询数量
• 系统运行时间、错误统计

进阶指标（深度分析）：
• 锁等待情况、I/O统计
• 临时表使用率、索引效率
• 复制延迟、事务统计

业务指标（业务相关）：
• 特定表的变更频率
• 关键查询的执行情况
• 用户行为相关的数据库指标
```

**🔹 监控的最佳实践**
```
实时监控 + 历史趋势：
• 实时监控：及时发现当前问题
• 历史趋势：分析长期变化模式
• 对比分析：同比、环比分析

自动化 + 人工分析：
• 自动化：定时收集和基础分析
• 人工分析：深度问题诊断
• 智能告警：减少误报和漏报
```

### 6.3 实际应用价值


**🎯 运维价值**
- **故障预防**：通过监控提前发现潜在问题
- **快速定位**：出现问题时快速找到根本原因
- **容量规划**：基于历史数据规划资源需求
- **性能优化**：识别性能瓶颈，指导优化方向

**🔧 开发价值**
- **SQL调优**：识别慢查询和低效SQL
- **架构优化**：了解系统负载特征
- **功能测试**：验证新功能对性能的影响
- **故障排查**：开发阶段发现性能问题

### 6.4 学习建议


**📚 学习路径**
```
① 掌握基础函数：USER()、CONNECTION_ID()等
② 理解状态变量：SHOW STATUS的各种用法
③ 学会性能分析：EXPLAIN、SHOW PROFILE
④ 建立监控体系：设计适合的监控指标
⑤ 自动化运维：编写监控脚本和存储过程
```

**🛠️ 实践建议**
- **搭建监控环境**：在测试环境练习各种监控查询
- **模拟负载测试**：观察不同负载下的指标变化
- **分析真实案例**：收集和分析生产环境的监控数据
- **建立监控仪表板**：使用Grafana等工具可视化监控数据

**⚠️ 注意事项**
```
监控本身的开销：
• 过度监控可能影响性能
• 选择合适的监控频率
• 避免在高峰期执行重型监控查询

数据的时效性：
• 某些状态变量是累计值，需要计算增量
• 注意区分全局状态和会话状态
• 考虑MySQL重启对累计数据的影响
```

**核心记忆**：
- 信息函数帮我们了解"现在的状态"
- 状态函数帮我们监控"系统的健康"  
- 诊断函数帮我们找到"性能的瓶颈"
- 资源函数帮我们掌握"资源的使用"
- 监控函数帮我们建立"全面的观察"
- 数据驱动的运维才是科学的运维