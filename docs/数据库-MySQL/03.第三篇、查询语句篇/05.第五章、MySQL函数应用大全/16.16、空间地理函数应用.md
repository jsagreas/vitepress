---
title: 16、空间地理函数应用
---
## 📚 目录

1. [MySQL空间数据基础概念](#1-MySQL空间数据基础概念)
2. [几何对象创建与WKT格式](#2-几何对象创建与WKT格式)
3. [核心空间关系函数详解](#3-核心空间关系函数详解)
4. [距离计算与测量函数](#4-距离计算与测量函数)
5. [空间分析与GIS处理](#5-空间分析与GIS处理)
6. [坐标系统与转换函数](#6-坐标系统与转换函数)
7. [空间索引优化策略](#7-空间索引优化策略)
8. [GIS实际应用场景](#8-GIS实际应用场景)
9. [性能调优与最佳实践](#9-性能调优与最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌍 MySQL空间数据基础概念


### 1.1 什么是空间数据


**🔸 空间数据定义**
```
空间数据就是用来描述地理位置和形状的数据
简单理解：地图上的点、线、面都是空间数据

日常例子：
• 你家的地址 → 一个点(Point)
• 一条马路 → 一条线(LineString) 
• 一个公园 → 一个区域(Polygon)
• 整个城市 → 多个区域的集合(MultiPolygon)
```

**💡 为什么需要空间函数？**
```
传统问题：如何判断两个地点的距离？
普通方法：存储经纬度，用复杂公式计算
MySQL空间函数：直接调用ST_Distance()

传统问题：如何判断某个点是否在某个区域内？
普通方法：复杂的数学几何计算
MySQL空间函数：直接调用ST_Contains()
```

### 1.2 MySQL支持的几何数据类型


**📊 几何类型层次结构**
```
Geometry (几何对象基类)
├── Point (点)
├── Curve (曲线)
│   └── LineString (线串)
├── Surface (面)
│   └── Polygon (多边形)
└── GeometryCollection (几何集合)
    ├── MultiPoint (多点)
    ├── MultiLineString (多线串)
    └── MultiPolygon (多多边形)
```

**🔸 常用几何类型详解**

| 类型 | **说明** | **应用场景** | **示例** |
|------|---------|-------------|---------|
| `Point` | **单个坐标点** | `商店位置、用户定位` | `餐厅地址、GPS坐标` |
| `LineString` | **连接的点序列** | `道路、河流、路线` | `地铁线路、配送路径` |
| `Polygon` | **闭合的边界区域** | `行政区域、建筑物` | `小区范围、商圈边界` |
| `MultiPoint` | **多个点的集合** | `连锁店分布` | `星巴克门店位置` |
| `MultiPolygon` | **多个区域的集合** | `复杂行政区域` | `由多个岛屿组成的城市` |

### 1.3 坐标系统基础


**🗺️ 坐标系统概念**
```
坐标系统(SRID)：空间参考标识符
作用：定义坐标的含义和计算方法

常用坐标系：
• SRID 4326：WGS84经纬度坐标系(GPS使用)
• SRID 3857：Web墨卡托投影(网络地图常用)
• SRID 0：平面笛卡尔坐标系(简单计算)
```

**💡 坐标系选择原则**
```
GPS定位应用 → 选择4326(WGS84)
网络地图应用 → 选择3857(Web墨卡托)
简单距离计算 → 选择0(平面坐标)
```

---

## 2. 🏗️ 几何对象创建与WKT格式


### 2.1 WKT格式详解


**🔸 WKT基本概念**
```
WKT(Well-Known Text)：几何对象的文本表示格式
作用：用简单文本描述复杂的几何形状
优势：人类可读，便于调试和数据交换
```

**📋 WKT格式规范**

**点(Point)格式**
```sql
-- 标准点格式
POINT(经度 纬度)

-- 示例：北京天安门坐标
POINT(116.3974 39.9093)

-- 创建Point对象
SELECT ST_GeomFromText('POINT(116.3974 39.9093)', 4326) AS beijing_tiananmen;
```

**线(LineString)格式**
```sql
-- 线串格式：连接多个点
LINESTRING(x1 y1, x2 y2, x3 y3, ...)

-- 示例：北京到上海的直线
LINESTRING(116.3974 39.9093, 121.4737 31.2304)

-- 创建复杂路线
SELECT ST_GeomFromText(
    'LINESTRING(116.3974 39.9093, 118.7969 32.0603, 121.4737 31.2304)', 
    4326
) AS beijing_to_shanghai;
```

**多边形(Polygon)格式**
```sql
-- 多边形格式：外环 + 可选内环
POLYGON((外环坐标), (内环坐标1), (内环坐标2), ...)

-- 示例：正方形区域
POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))

-- 带洞的多边形
POLYGON((0 0, 0 10, 10 10, 10 0, 0 0), (2 2, 2 8, 8 8, 8 2, 2 2))
```

### 2.2 ST_GeomFromText函数详解


**🔥 ST_GeomFromText核心用法**
```sql
-- 基本语法
ST_GeomFromText(wkt_string, srid)

-- 参数说明：
-- wkt_string: WKT格式的几何对象描述
-- srid: 坐标系统标识符（可选，默认0）
```

**💻 实际应用示例**
```sql
-- 创建商店位置数据表
CREATE TABLE stores (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    location GEOMETRY NOT NULL SRID 4326
);

-- 插入商店位置数据
INSERT INTO stores (id, name, location) VALUES
(1, '北京王府井店', ST_GeomFromText('POINT(116.4074 39.9142)', 4326)),
(2, '上海南京路店', ST_GeomFromText('POINT(121.4737 31.2304)', 4326)),
(3, '广州天河店', ST_GeomFromText('POINT(113.3308 23.1291)', 4326));

-- 查看数据
SELECT id, name, ST_AsText(location) AS coordinates 
FROM stores;
```

### 2.3 其他几何对象创建函数


**🔧 常用创建函数对比**

| 函数名 | **用途** | **输入格式** | **使用场景** |
|--------|---------|-------------|-------------|
| `ST_GeomFromText` | **WKT文本转几何对象** | `文本字符串` | `手动输入坐标数据` |
| `ST_Point` | **直接创建点对象** | `数值坐标` | `程序动态创建点` |
| `ST_LineFromText` | **WKT转线对象** | `LINESTRING文本` | `路径规划应用` |
| `ST_PolygonFromText` | **WKT转多边形** | `POLYGON文本` | `区域边界定义` |

**💡 ST_Point函数简化点创建**
```sql
-- 使用ST_Point创建点（更简洁）
INSERT INTO stores (id, name, location) VALUES
(4, '深圳华强北店', ST_Point(114.0853, 22.5431, 4326));

-- 对比ST_GeomFromText方式
INSERT INTO stores (id, name, location) VALUES
(5, '杭州西湖店', ST_GeomFromText('POINT(120.1551 30.2741)', 4326));
```

---

## 3. 🔄 核心空间关系函数详解


### 3.1 包含关系判断


**🔥 ST_Contains包含关系核心应用**
```
ST_Contains(几何对象A, 几何对象B)
返回：1表示A完全包含B，0表示不包含

生活理解：
判断某个点是否在某个区域内
判断某条路是否完全在某个行政区内
判断某个小区域是否被大区域完全包围
```

**💻 实际应用场景**
```sql
-- 创建配送区域表
CREATE TABLE delivery_zones (
    id INT PRIMARY KEY,
    zone_name VARCHAR(50),
    boundary GEOMETRY NOT NULL SRID 4326
);

-- 插入配送区域（以正方形为例）
INSERT INTO delivery_zones VALUES
(1, '朝阳区配送范围', 
   ST_GeomFromText('POLYGON((116.4 39.9, 116.4 40.0, 116.5 40.0, 116.5 39.9, 116.4 39.9))', 4326)
);

-- 查询某个用户地址是否在配送范围内
SELECT 
    zone_name,
    CASE 
        WHEN ST_Contains(boundary, ST_Point(116.45, 39.95, 4326)) 
        THEN '可配送' 
        ELSE '超出范围' 
    END AS delivery_status
FROM delivery_zones;
```

**🎯 ST_Contains性能优化技巧**
```sql
-- 使用空间索引加速查询
-- 先创建空间索引
CREATE SPATIAL INDEX idx_delivery_zones_boundary ON delivery_zones(boundary);

-- 查询在配送范围内的所有订单
SELECT o.order_id, o.address, d.zone_name
FROM orders o
CROSS JOIN delivery_zones d
WHERE ST_Contains(d.boundary, 
    ST_GeomFromText(CONCAT('POINT(', o.longitude, ' ', o.latitude, ')'), 4326)
);
```

### 3.2 相交关系判断


**🔥 ST_Intersects相交判断详解**
```
ST_Intersects(几何对象A, 几何对象B)
返回：1表示A和B有交集，0表示没有交集

应用理解：
判断两条道路是否相交
判断某个区域是否与另一个区域重叠
判断配送路线是否经过某个禁行区域
```

**💻 道路交叉口检测示例**
```sql
-- 创建道路表
CREATE TABLE roads (
    id INT PRIMARY KEY,
    road_name VARCHAR(100),
    path GEOMETRY NOT NULL SRID 4326
);

-- 插入道路数据
INSERT INTO roads VALUES
(1, '长安街', ST_GeomFromText('LINESTRING(116.3 39.91, 116.5 39.91)', 4326)),
(2, '王府井大街', ST_GeomFromText('LINESTRING(116.41 39.90, 116.41 39.92)', 4326));

-- 检查道路是否相交
SELECT 
    r1.road_name AS road1,
    r2.road_name AS road2,
    ST_Intersects(r1.path, r2.path) AS has_intersection,
    ST_AsText(ST_Intersection(r1.path, r2.path)) AS intersection_point
FROM roads r1, roads r2
WHERE r1.id < r2.id;
```

### 3.3 距离关系函数


**📏 ST_Within和ST_DWithin区别**
```sql
-- ST_Within：判断对象A是否完全在对象B内部
-- 类似ST_Contains的反向操作

-- ST_DWithin：判断两个对象之间的距离是否小于指定值
-- 用于"附近查询"场景

-- 查找距离某点1000米内的所有商店
SELECT name, ST_AsText(location)
FROM stores 
WHERE ST_DWithin(
    location, 
    ST_Point(116.4074, 39.9142, 4326), 
    1000  -- 1000米
);
```

**🎯 空间关系函数对比**

| 函数 | **判断条件** | **返回值** | **典型应用** |
|------|-------------|-----------|-------------|
| `ST_Contains(A,B)` | **A完全包含B** | `1/0` | `点是否在区域内` |
| `ST_Within(A,B)` | **A完全在B内部** | `1/0` | `区域是否在大区域内` |
| `ST_Intersects(A,B)` | **A与B有交集** | `1/0` | `路径是否经过区域` |
| `ST_Touches(A,B)` | **A与B相切但不重叠** | `1/0` | `边界相邻判断` |
| `ST_Crosses(A,B)` | **A穿过B** | `1/0` | `线穿过面的判断` |

---

## 4. 📐 距离计算与测量函数


### 4.1 ST_Distance距离计算核心


**🔥 ST_Distance函数详解**
```
ST_Distance(几何对象A, 几何对象B)
功能：计算两个几何对象之间的最短距离
返回：距离数值（单位取决于坐标系）

重要提醒：
• 4326坐标系：返回度数，需要转换为实际距离
• 平面坐标系：直接返回坐标单位距离
```

**🌍 不同坐标系的距离计算**
```sql
-- 错误示例：直接在WGS84坐标系计算距离（返回度数）
SELECT ST_Distance(
    ST_Point(116.3974, 39.9093, 4326), -- 北京
    ST_Point(121.4737, 31.2304, 4326)  -- 上海
) AS distance_in_degrees;  -- 结果约为8.3度，不是实际距离！

-- 正确示例：使用ST_Distance_Sphere计算实际距离
SELECT ST_Distance_Sphere(
    ST_Point(116.3974, 39.9093),  -- 北京
    ST_Point(121.4737, 31.2304)   -- 上海  
) AS distance_in_meters;  -- 结果约为1067816米（约1068公里）
```

### 4.2 球面距离计算函数


**🌐 ST_Distance_Sphere详解**
```
ST_Distance_Sphere(点A, 点B)
功能：计算地球表面两点间的球面距离
返回：米为单位的实际距离
适用：GPS坐标的实际距离计算
```

**💻 实用距离计算示例**
```sql
-- 查找距离用户最近的3家门店
SET @user_location = ST_Point(116.4074, 39.9142);  -- 用户当前位置

SELECT 
    name,
    ROUND(ST_Distance_Sphere(@user_location, location)) AS distance_meters,
    ROUND(ST_Distance_Sphere(@user_location, location)/1000, 2) AS distance_km
FROM stores 
ORDER BY distance_meters
LIMIT 3;
```

**🎯 距离查询性能优化**
```sql
-- 创建距离查询的优化索引
ALTER TABLE stores ADD SPATIAL INDEX(location);

-- 使用MBR(最小边界矩形)预筛选，提高性能
-- 先用范围筛选，再精确计算距离
SELECT name, ST_Distance_Sphere(@user_location, location) as distance
FROM stores
WHERE MBRContains(
    ST_Buffer(ST_GeomFromText(CONCAT('POINT(', 
        ST_X(@user_location), ' ', ST_Y(@user_location), ')')), 0.01),
    location
)
ORDER BY distance;
```

### 4.3 缓冲区创建与应用


**📊 ST_Buffer缓冲区函数**
```
ST_Buffer(几何对象, 距离)
功能：创建几何对象周围指定距离的缓冲区
应用：创建影响范围、安全区域等
```

**💡 缓冲区实际应用**
```sql
-- 创建商圈影响范围分析
SELECT 
    s.name,
    ST_AsText(ST_Buffer(s.location, 0.01)) AS influence_area  -- 约1公里范围
FROM stores s
WHERE s.name = '北京王府井店';

-- 查找在商店1公里范围内的所有用户
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    location GEOMETRY SRID 4326
);

-- 查询在缓冲区内的用户
SELECT u.username
FROM users u, stores s
WHERE s.name = '北京王府井店'
  AND ST_Contains(ST_Buffer(s.location, 0.01), u.location);
```

---

## 5. 🗺️ 空间分析与GIS处理


### 5.1 几何对象属性获取


**📏 基础属性函数**
```sql
-- 几何对象基本信息获取
SELECT 
    name,
    ST_GeometryType(location) AS geom_type,      -- 几何类型
    ST_SRID(location) AS coordinate_system,      -- 坐标系
    ST_IsEmpty(location) AS is_empty,            -- 是否为空
    ST_IsValid(location) AS is_valid             -- 是否有效
FROM stores;
```

**🔍 坐标提取函数**
```sql
-- 从Point对象提取经纬度
SELECT 
    name,
    ST_X(location) AS longitude,    -- 提取经度
    ST_Y(location) AS latitude,     -- 提取纬度
    ST_AsText(location) AS wkt_format
FROM stores;

-- 从复杂几何对象提取边界
SELECT 
    zone_name,
    ST_AsText(ST_Envelope(boundary)) AS bounding_box,  -- 边界矩形
    ST_Area(boundary) AS area_size,                    -- 面积
    ST_Perimeter(boundary) AS perimeter_length         -- 周长
FROM delivery_zones;
```

### 5.2 几何运算函数


**⚙️ 集合运算函数**

| 函数 | **功能** | **应用场景** | **示例** |
|------|---------|-------------|---------|
| `ST_Union` | **合并几何对象** | `合并相邻区域` | `多个配送区域合并` |
| `ST_Intersection` | **计算交集** | `重叠区域分析` | `两个商圈重叠部分` |
| `ST_Difference` | **计算差集** | `去除重叠部分` | `A区域减去B区域` |
| `ST_SymDifference` | **对称差集** | `非重叠部分` | `两区域不重叠的部分` |

**💻 实际几何运算示例**
```sql
-- 计算两个配送区域的重叠部分
SELECT 
    ST_AsText(ST_Intersection(z1.boundary, z2.boundary)) AS overlap_area
FROM delivery_zones z1, delivery_zones z2
WHERE z1.id = 1 AND z2.id = 2;

-- 合并多个小区域为一个大区域
SELECT ST_AsText(
    ST_Union(boundary)
) AS merged_area
FROM delivery_zones
WHERE zone_name LIKE '%朝阳%';
```

### 5.3 空间数据转换函数


**🔄 格式转换函数**
```sql
-- WKT与几何对象互转
SELECT 
    ST_AsText(location) AS wkt_format,           -- 几何→WKT
    ST_GeomFromText(ST_AsText(location)) AS geom -- WKT→几何

-- WKB二进制格式转换
SELECT 
    ST_AsBinary(location) AS wkb_format,         -- 几何→WKB
    ST_GeomFromWKB(ST_AsBinary(location)) AS geom -- WKB→几何

-- GeoJSON格式转换
SELECT 
    ST_AsGeoJSON(location) AS geojson_format     -- 几何→GeoJSON
FROM stores;
```

---

## 6. 🌐 坐标系统与转换函数


### 6.1 坐标系统理解


**🗺️ 常用坐标系统对比**
```
SRID 4326 (WGS84)：
• 全球GPS标准坐标系
• 单位：度(经纬度)
• 适用：GPS定位、全球应用
• 特点：不适合直接距离计算

SRID 3857 (Web Mercator)：
• 网络地图投影坐标系
• 单位：米
• 适用：网络地图、距离计算
• 特点：高纬度地区变形较大

SRID 0 (平面坐标)：
• 简单的笛卡尔坐标系
• 单位：自定义
• 适用：局部区域、简单计算
• 特点：不考虑地球曲率
```

### 6.2 坐标转换函数


**🔄 ST_Transform坐标转换**
```sql
-- 基本转换语法
ST_Transform(几何对象, 目标SRID)

-- 从WGS84转换为Web Mercator进行距离计算
SELECT 
    s1.name,
    s2.name,
    ST_Distance(
        ST_Transform(s1.location, 3857),
        ST_Transform(s2.location, 3857)
    ) AS distance_meters
FROM stores s1, stores s2
WHERE s1.id = 1 AND s2.id = 2;
```

> 💡 **重要提醒**
> 
> MySQL的ST_Transform函数需要安装额外的坐标转换库支持。如果没有安装，建议使用ST_Distance_Sphere函数直接计算WGS84坐标的球面距离。

### 6.3 坐标系选择指导


**🎯 实际应用选择指南**
```
GPS应用开发：
• 数据存储：使用SRID 4326
• 距离计算：使用ST_Distance_Sphere
• 范围查询：结合空间索引

网络地图应用：
• 数据存储：可选择SRID 3857
• 瓦片计算：适合Web Mercator投影
• 显示优化：减少前端转换开销

本地化应用：
• 小范围应用：可使用平面坐标
• 简化计算：SRID 0 + 简单距离公式
• 性能优先：避免复杂投影转换
```

---

## 7. 🚀 空间索引优化策略


### 7.1 空间索引基础


**🔍 空间索引工作原理**
```
空间索引：专门优化几何数据查询的索引结构
原理：使用R-tree算法，将空间划分为层次化的矩形区域
优势：大幅提升空间查询性能，特别是范围查询

没有空间索引：需要扫描全表进行空间计算
有空间索引：先通过索引快速定位候选对象，再精确计算
```

### 7.2 创建和使用空间索引


**🏗️ 空间索引创建语法**
```sql
-- 创建表时定义空间索引
CREATE TABLE locations (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    point GEOMETRY NOT NULL SRID 4326,
    SPATIAL INDEX idx_point (point)
);

-- 在existing表上添加空间索引  
ALTER TABLE stores ADD SPATIAL INDEX idx_location (location);

-- 查看空间索引信息
SHOW INDEX FROM stores WHERE Key_name LIKE 'idx_%';
```

### 7.3 空间索引查询优化


**⚡ 空间查询性能对比**
```sql
-- 未优化查询（全表扫描）
SELECT COUNT(*) 
FROM stores 
WHERE ST_DWithin(location, ST_Point(116.4074, 39.9142, 4326), 1000);

-- 优化查询（使用MBR预筛选）
SELECT s.name, ST_Distance_Sphere(ST_Point(116.4074, 39.9142), s.location) as dist
FROM stores s
WHERE MBRContains(
    -- 创建查询范围的边界矩形
    ST_GeomFromText('POLYGON((116.39 39.90, 116.42 39.90, 116.42 39.92, 116.39 39.92, 116.39 39.90))'),
    s.location
)
AND ST_Distance_Sphere(ST_Point(116.4074, 39.9142), s.location) <= 1000
ORDER BY dist;
```

**📊 MBR函数优化技巧**

| 函数 | **功能** | **性能** | **适用场景** |
|------|---------|---------|-------------|
| `MBRContains` | **矩形包含判断** | `极快` | `范围预筛选` |
| `MBRIntersects` | **矩形相交判断** | `极快` | `相交预筛选` |
| `ST_Contains` | **精确包含判断** | `较慢` | `精确结果确认` |
| `ST_Intersects` | **精确相交判断** | `较慢` | `精确结果确认` |

**最佳实践查询模式**：
```
1. 使用MBR函数快速筛选候选结果
2. 再用精确空间函数确认最终结果
3. 充分利用空间索引的矩形查询优势
```

---

## 8. 🏪 GIS实际应用场景


### 8.1 位置服务应用


**📱 "附近的店"功能实现**
```sql
-- 完整的附近商店查询功能
DELIMITER //
CREATE PROCEDURE FindNearbyStores(
    IN user_lng DECIMAL(10,8),
    IN user_lat DECIMAL(10,8), 
    IN search_radius INT,
    IN max_results INT
)
BEGIN
    SET @user_point = ST_Point(user_lng, user_lat);
    
    SELECT 
        s.id,
        s.name,
        s.category,
        ST_X(s.location) AS longitude,
        ST_Y(s.location) AS latitude,
        ROUND(ST_Distance_Sphere(@user_point, s.location)) AS distance_meters,
        CASE 
            WHEN ST_Distance_Sphere(@user_point, s.location) <= 500 THEN '500米内'
            WHEN ST_Distance_Sphere(@user_point, s.location) <= 1000 THEN '1公里内'  
            ELSE '较远'
        END AS distance_category
    FROM stores s
    WHERE ST_Distance_Sphere(@user_point, s.location) <= search_radius
    ORDER BY distance_meters
    LIMIT max_results;
END //
DELIMITER ;

-- 调用示例：查找用户周围2公里内最近的10家店
CALL FindNearbyStores(116.4074, 39.9142, 2000, 10);
```

### 8.2 配送区域管理


**🚛 配送范围判断系统**
```sql
-- 创建完整配送系统表结构
CREATE TABLE delivery_areas (
    id INT PRIMARY KEY AUTO_INCREMENT,
    area_name VARCHAR(100),
    delivery_fee DECIMAL(5,2),
    boundary GEOMETRY NOT NULL SRID 4326,
    is_active BOOLEAN DEFAULT TRUE,
    SPATIAL INDEX idx_boundary (boundary)
);

-- 插入配送区域数据
INSERT INTO delivery_areas (area_name, delivery_fee, boundary) VALUES
('市中心配送区', 5.00, ST_GeomFromText(
    'POLYGON((116.35 39.88, 116.45 39.88, 116.45 39.98, 116.35 39.98, 116.35 39.88))', 4326)),
('郊区配送区', 8.00, ST_GeomFromText(
    'POLYGON((116.30 39.85, 116.50 39.85, 116.50 40.00, 116.30 40.00, 116.30 39.85))', 4326));

-- 订单配送费用计算函数
DELIMITER //
CREATE FUNCTION CalculateDeliveryFee(order_lng DECIMAL(10,8), order_lat DECIMAL(10,8))
RETURNS DECIMAL(5,2)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE delivery_fee DECIMAL(5,2) DEFAULT 999.99;
    
    SELECT da.delivery_fee INTO delivery_fee
    FROM delivery_areas da
    WHERE da.is_active = TRUE
      AND ST_Contains(da.boundary, ST_Point(order_lng, order_lat, 4326))
    ORDER BY da.delivery_fee ASC
    LIMIT 1;
    
    RETURN IFNULL(delivery_fee, 999.99);
END //
DELIMITER ;

-- 使用示例
SELECT CalculateDeliveryFee(116.4074, 39.9142) AS delivery_cost;
```

### 8.3 地理围栏应用


**🔐 电子围栏监控系统**
```sql
-- 电子围栏表
CREATE TABLE geofences (
    id INT PRIMARY KEY AUTO_INCREMENT,
    fence_name VARCHAR(100),
    fence_type ENUM('ENTRY', 'EXIT', 'BOTH') DEFAULT 'BOTH',
    boundary GEOMETRY NOT NULL SRID 4326,
    alert_enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    SPATIAL INDEX idx_boundary (boundary)
);

-- 位置记录表  
CREATE TABLE location_logs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    location GEOMETRY NOT NULL SRID 4326,
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    SPATIAL INDEX idx_location (location)
);

-- 围栏事件检测
DELIMITER //
CREATE PROCEDURE CheckGeofenceEvents(IN user_id INT, IN lng DECIMAL(10,8), IN lat DECIMAL(10,8))
BEGIN
    DECLARE current_point GEOMETRY;
    SET current_point = ST_Point(lng, lat, 4326);
    
    -- 记录位置
    INSERT INTO location_logs (user_id, location) VALUES (user_id, current_point);
    
    -- 检测围栏事件
    SELECT 
        gf.id,
        gf.fence_name,
        gf.fence_type,
        'ENTERED' AS event_type,
        NOW() AS event_time
    FROM geofences gf
    WHERE gf.alert_enabled = TRUE
      AND ST_Contains(gf.boundary, current_point)
      AND NOT EXISTS (
          -- 检查用户之前是否已经在围栏内
          SELECT 1 FROM location_logs ll
          WHERE ll.user_id = user_id
            AND ll.recorded_at > DATE_SUB(NOW(), INTERVAL 10 MINUTE)  
            AND ST_Contains(gf.boundary, ll.location)
            AND ll.id < LAST_INSERT_ID()
      );
END //
DELIMITER ;
```

---

## 9. ⚡ 性能调优与最佳实践


### 9.1 查询性能优化策略


**📊 性能优化层次结构**
```
Level 1: 索引优化
├── 创建合适的空间索引
├── 使用复合索引（空间+普通列）
└── 定期维护索引统计信息

Level 2: 查询优化  
├── 使用MBR函数预筛选
├── 避免复杂的空间运算
└── 合理使用LIMIT限制结果

Level 3: 数据组织优化
├── 选择合适的坐标系统
├── 预计算常用的空间关系
└── 数据分区和归档策略
```

### 9.2 具体优化技巧


**🎯 查询重写优化**
```sql
-- ❌ 性能差的写法
SELECT * FROM stores 
WHERE ST_Distance_Sphere(location, ST_Point(116.4074, 39.9142)) <= 1000;

-- ✅ 性能好的写法  
SELECT * FROM stores 
WHERE MBRContains(
    -- 先用矩形范围预筛选
    ST_Buffer(ST_Point(116.4074, 39.9142), 0.01), 
    location
)
AND ST_Distance_Sphere(location, ST_Point(116.4074, 39.9142)) <= 1000;

-- ✅ 更优的写法：预计算边界
SET @search_center = ST_Point(116.4074, 39.9142);
SET @search_bound = ST_GeomFromText('POLYGON((116.39 39.90, 116.42 39.90, 116.42 39.93, 116.39 39.93, 116.39 39.90))');

SELECT s.*, ST_Distance_Sphere(@search_center, s.location) as distance
FROM stores s
WHERE MBRContains(@search_bound, s.location)
  AND ST_Distance_Sphere(@search_center, s.location) <= 1000
ORDER BY distance;
```

**🔧 配置优化建议**
```sql
-- MySQL空间相关配置调优
-- my.cnf配置建议

[mysqld]
# 增加排序缓冲区，有助于空间查询排序
sort_buffer_size = 2M

# 增加临时表大小，复杂空间查询可能需要临时表
tmp_table_size = 64M
max_heap_table_size = 64M

# 优化查询缓存
query_cache_size = 32M
query_cache_type = 1
```

### 9.3 数据存储优化


**📦 数据组织最佳实践**
```sql
-- 使用分区表优化大量空间数据
CREATE TABLE location_history (
    id BIGINT PRIMARY KEY,
    user_id INT,
    location GEOMETRY NOT NULL SRID 4326,
    created_date DATE,
    recorded_at TIMESTAMP,
    INDEX idx_user_date (user_id, created_date),
    SPATIAL INDEX idx_location (location)
)
PARTITION BY RANGE (TO_DAYS(created_date)) (
    PARTITION p2024q1 VALUES LESS THAN (TO_DAYS('2024-04-01')),
    PARTITION p2024q2 VALUES LESS THAN (TO_DAYS('2024-07-01')),
    PARTITION p2024q3 VALUES LESS THAN (TO_DAYS('2024-10-01')),
    PARTITION p2024q4 VALUES LESS THAN (TO_DAYS('2025-01-01'))
);

-- 预计算常用空间关系，避免重复计算
CREATE TABLE store_distances (
    store1_id INT,
    store2_id INT,
    distance_meters INT,
    PRIMARY KEY (store1_id, store2_id),
    INDEX idx_distance (distance_meters)
);

-- 预计算数据填充
INSERT INTO store_distances (store1_id, store2_id, distance_meters)
SELECT 
    s1.id,
    s2.id,
    ROUND(ST_Distance_Sphere(s1.location, s2.location))
FROM stores s1, stores s2
WHERE s1.id < s2.id;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 空间数据类型：Point、LineString、Polygon等几何对象
🔸 WKT格式：几何对象的文本表示，便于数据交换
🔸 坐标系统：4326(GPS)、3857(Web墨卡托)、0(平面)
🔸 核心函数：ST_GeomFromText、ST_Distance、ST_Contains、ST_Intersects
🔸 性能优化：空间索引、MBR预筛选、查询重写
```

### 10.2 重要函数功能记忆


**🔹 创建函数**
```
ST_GeomFromText(wkt, srid) → 文本转几何对象
ST_Point(x, y, srid) → 直接创建点对象  
ST_Buffer(geom, distance) → 创建缓冲区
```

**🔹 关系判断函数**
```  
ST_Contains(A, B) → A是否包含B
ST_Within(A, B) → A是否在B内部
ST_Intersects(A, B) → A与B是否相交
ST_Crosses(A, B) → A是否穿过B
```

**🔹 距离计算函数**
```
ST_Distance(A, B) → 两对象间距离（坐标单位）
ST_Distance_Sphere(A, B) → 球面距离（米）
ST_DWithin(A, B, dist) → 距离是否小于指定值
```

### 10.3 实际应用指导原则


**🎯 坐标系选择**
```
GPS定位应用 → SRID 4326 + ST_Distance_Sphere
网络地图应用 → SRID 3857 + ST_Transform  
简单计算应用 → SRID 0 + ST_Distance
本地化应用 → 自定义SRID + 针对性优化
```

**🎯 性能优化策略**
```
数据量 < 10万 → 基础空间索引即可
数据量 > 10万 → MBR预筛选 + 空间索引
数据量 > 100万 → 分区表 + 预计算 + 缓存
实时要求高 → 预计算距离矩阵 + Redis缓存
```

**🎯 功能实现模式**
```
附近搜索：MBR预筛选 + ST_Distance_Sphere排序
区域判断：ST_Contains + 空间索引加速
路径分析：ST_Intersects + LineString对象
围栏监控：ST_Contains + 事件触发逻辑
```

### 10.4 常见问题避免


**⚠️ 性能陷阱**
- ❌ 不要在大表上直接使用ST_Distance排序
- ❌ 不要忽略坐标系，直接计算WGS84距离  
- ❌ 不要忘记创建空间索引
- ✅ 先用MBR筛选，再精确计算
- ✅ 选择合适坐标系，使用对应距离函数
- ✅ 充分利用空间索引加速查询

**🔧 数据质量**
- ❌ 不要混用不同坐标系的数据
- ❌ 不要存储无效的几何对象
- ✅ 统一坐标系，必要时进行转换
- ✅ 使用ST_IsValid验证数据完整性

### 10.5 学习进阶路径


```
🟢 基础阶段：
- 掌握Point、Polygon等基本几何类型
- 熟练使用ST_GeomFromText创建对象
- 理解ST_Contains、ST_Distance等核心函数

🟡 进阶阶段：  
- 掌握不同坐标系的转换和选择
- 熟练使用空间索引优化查询性能
- 能够实现复杂的GIS业务逻辑

🔴 高级阶段：
- 深入理解空间索引原理和优化策略
- 掌握大规模空间数据的分区和缓存
- 能够设计高性能的位置服务系统
```

**💡 核心记忆口诀**：
- 空间数据点线面，WKT格式把形状现
- ST_GeomFromText来创建，坐标系统要指全  
- 包含相交距离算，索引优化性能显
- 实际应用场景多，GPS围栏和配送

**🎯 实践建议**：
从简单的"附近的店"功能开始，逐步深入到复杂的GIS分析，每个函数都要结合实际场景练习，理论与实践并重才能真正掌握MySQL空间函数的精髓。