---
title: 8、复杂窗口查询
---
## 📚 目录

1. [复杂窗口查询概述](#1-复杂窗口查询概述)
2. [多层窗口嵌套技术](#2-多层窗口嵌套技术)
3. [窗口函数组合使用](#3-窗口函数组合使用)
4. [条件窗口查询设计](#4-条件窗口查询设计)
5. [动态窗口框架应用](#5-动态窗口框架应用)
6. [复杂业务场景实现](#6-复杂业务场景实现)
7. [性能优化策略](#7-性能优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 复杂窗口查询概述


### 1.1 什么是复杂窗口查询


**🔸 核心定义**
```
复杂窗口查询：综合运用多种窗口函数和技术的高级查询
目的：解决传统SQL难以处理的复杂分析需求
特点：多层嵌套、函数组合、条件控制、动态框架
应用：商业智能、数据分析、报表统计等场景
```

**💡 通俗理解**
如果说基础窗口函数是"计算器"，那么复杂窗口查询就是"高级分析仪"：
- **基础查询** = 单一计算（如求和、排名）
- **复杂查询** = 综合分析（如趋势分析、异常检测、多维对比）
- **组合使用** = 多种分析方法配合使用

### 1.2 复杂窗口查询的应用价值


**🎯 解决的业务问题**
```
数据分析挑战：
• 多维度同时分析：同时按时间、地区、产品分析
• 层级关系处理：部门、子部门的层级统计
• 趋势变化检测：识别数据异常和趋势拐点
• 复杂排名逻辑：多条件排名和分组排名

传统SQL局限：
• 需要多次查询和临时表
• 逻辑复杂，维护困难
• 性能低下，资源消耗大

窗口查询优势：
• 一次查询完成复杂分析
• 逻辑清晰，易于理解
• 性能优越，资源高效
```

### 1.3 复杂窗口查询的技术特征


**📊 核心技术特征**
```
多层嵌套结构：
窗口函数内嵌套其他窗口函数

函数组合应用：
多个窗口函数配合使用解决问题

条件控制逻辑：
根据条件动态调整窗口行为

动态框架设计：
窗口范围根据数据特征自适应调整
```

---

## 2. 🔀 多层窗口嵌套技术


### 2.1 嵌套结构设计原理


**🔸 嵌套层次分析**
```
第一层：基础数据计算
• 简单聚合和排序
• 数据清洗和标准化

第二层：基于第一层结果的分析
• 同比、环比计算
• 移动平均和趋势分析

第三层：综合分析和决策
• 异常检测和预警
• 复杂业务逻辑判断
```

**💻 嵌套结构示意图**
```
数据流向图：
原始数据 → [窗口函数1] → 中间结果1
               ↓
中间结果1 → [窗口函数2] → 中间结果2  
               ↓
中间结果2 → [窗口函数3] → 最终结果

实际示例：
销售数据 → [SUM() OVER()] → 部门总销售额
              ↓  
部门总销售额 → [RANK() OVER()] → 部门排名
              ↓
部门排名 → [CASE WHEN] → 绩效等级
```

### 2.2 实战案例：员工绩效多层分析


**🎯 业务场景**
分析员工绩效，需要：
1. 计算个人销售额在部门中的排名
2. 判断是否超过部门平均水平
3. 给出综合绩效评级

**📊 示例数据**
```sql
-- 创建示例数据
CREATE TABLE employee_sales (
    employee_id INT,
    employee_name VARCHAR(50),
    department VARCHAR(50),
    month_date DATE,
    sales_amount DECIMAL(10,2)
);

INSERT INTO employee_sales VALUES
(1, '张三', '销售部', '2024-01-01', 50000),
(2, '李四', '销售部', '2024-01-01', 60000),
(3, '王五', '销售部', '2024-01-01', 45000),
(4, '赵六', '市场部', '2024-01-01', 40000),
(5, '钱七', '市场部', '2024-01-01', 35000);
```

**🔧 多层嵌套查询实现**
```sql
WITH performance_analysis AS (
  SELECT 
    employee_id,
    employee_name,
    department,
    sales_amount,
    
    -- 第一层：计算部门内排名
    RANK() OVER (
      PARTITION BY department 
      ORDER BY sales_amount DESC
    ) as dept_rank,
    
    -- 第一层：计算部门平均值
    AVG(sales_amount) OVER (
      PARTITION BY department
    ) as dept_avg,
    
    -- 第一层：计算总体排名
    RANK() OVER (ORDER BY sales_amount DESC) as overall_rank
    
  FROM employee_sales
  WHERE month_date = '2024-01-01'
),
enhanced_analysis AS (
  SELECT 
    *,
    
    -- 第二层：判断是否超过部门平均
    CASE 
      WHEN sales_amount > dept_avg THEN '超过平均'
      ELSE '低于平均'
    END as vs_dept_avg,
    
    -- 第二层：计算超过平均的幅度
    ROUND((sales_amount - dept_avg) / dept_avg * 100, 2) as avg_deviation_pct
    
  FROM performance_analysis
)
SELECT 
  employee_name,
  department,
  sales_amount,
  dept_rank,
  vs_dept_avg,
  avg_deviation_pct,
  
  -- 第三层：综合绩效评级
  CASE 
    WHEN dept_rank = 1 AND avg_deviation_pct > 10 THEN 'A+'
    WHEN dept_rank <= 2 AND avg_deviation_pct > 0 THEN 'A'
    WHEN avg_deviation_pct > -10 THEN 'B'
    ELSE 'C'
  END as performance_grade
  
FROM enhanced_analysis
ORDER BY department, dept_rank;
```

### 2.3 嵌套查询的设计模式


**🔸 常见嵌套模式**

**模式1：层级聚合模式**
```sql
-- 个人 → 部门 → 公司 层级统计
SELECT 
  employee_name,
  department,
  sales_amount,
  
  -- 个人占部门比例
  ROUND(sales_amount / SUM(sales_amount) OVER (PARTITION BY department) * 100, 2) as dept_pct,
  
  -- 部门占公司比例  
  ROUND(SUM(sales_amount) OVER (PARTITION BY department) / 
        SUM(sales_amount) OVER () * 100, 2) as company_pct
        
FROM employee_sales;
```

**模式2：时序分析模式**
```sql
-- 当期 → 累计 → 趋势分析
SELECT 
  month_date,
  sales_amount,
  
  -- 累计销售额
  SUM(sales_amount) OVER (ORDER BY month_date) as cumulative_sales,
  
  -- 基于累计值计算增长率
  ROUND((SUM(sales_amount) OVER (ORDER BY month_date) - 
         LAG(SUM(sales_amount) OVER (ORDER BY month_date)) OVER (ORDER BY month_date))
        / LAG(SUM(sales_amount) OVER (ORDER BY month_date)) OVER (ORDER BY month_date) * 100, 2) as growth_rate
        
FROM monthly_sales;
```

---

## 3. 🔗 窗口函数组合使用


### 3.1 函数组合设计原则


**🔸 组合配合策略**
```
互补原则：
• 排名函数 + 聚合函数：排名基础上计算统计值
• 偏移函数 + 聚合函数：时序数据的对比分析
• 分布函数 + 条件函数：数据分段和分类

协同原则：
• 相同窗口规范：减少重复计算
• 逐步细化：从粗粒度到细粒度分析
• 结果传递：前一函数结果用于后续计算
```

### 3.2 经典组合模式实战


**🎯 模式1：排名+百分比分布**
```sql
-- 销售员业绩分析：排名、百分位、分档
SELECT 
  employee_name,
  sales_amount,
  
  -- 销售排名
  RANK() OVER (ORDER BY sales_amount DESC) as sales_rank,
  
  -- 百分位排名
  PERCENT_RANK() OVER (ORDER BY sales_amount) as percentile_rank,
  
  -- 根据百分位分档
  CASE 
    WHEN PERCENT_RANK() OVER (ORDER BY sales_amount) >= 0.8 THEN '优秀'
    WHEN PERCENT_RANK() OVER (ORDER BY sales_amount) >= 0.6 THEN '良好'  
    WHEN PERCENT_RANK() OVER (ORDER BY sales_amount) >= 0.4 THEN '一般'
    ELSE '需改进'
  END as performance_level,
  
  -- 与平均值比较
  ROUND((sales_amount - AVG(sales_amount) OVER ()) / 
        AVG(sales_amount) OVER () * 100, 2) as vs_avg_pct
        
FROM employee_sales;
```

**🎯 模式2：时序对比+趋势分析**
```sql
-- 月度销售趋势分析
SELECT 
  month_date,
  sales_amount,
  
  -- 环比增长
  LAG(sales_amount, 1) OVER (ORDER BY month_date) as prev_month,
  ROUND((sales_amount - LAG(sales_amount, 1) OVER (ORDER BY month_date)) / 
        LAG(sales_amount, 1) OVER (ORDER BY month_date) * 100, 2) as mom_growth,
  
  -- 同比增长  
  LAG(sales_amount, 12) OVER (ORDER BY month_date) as same_month_last_year,
  ROUND((sales_amount - LAG(sales_amount, 12) OVER (ORDER BY month_date)) / 
        LAG(sales_amount, 12) OVER (ORDER BY month_date) * 100, 2) as yoy_growth,
  
  -- 3个月移动平均
  AVG(sales_amount) OVER (ORDER BY month_date ROWS 2 PRECEDING) as ma_3month,
  
  -- 趋势判断
  CASE 
    WHEN sales_amount > AVG(sales_amount) OVER (ORDER BY month_date ROWS 2 PRECEDING) 
         AND LAG(sales_amount, 1) OVER (ORDER BY month_date) > 
             LAG(sales_amount, 2) OVER (ORDER BY month_date) 
    THEN '上升趋势'
    WHEN sales_amount < AVG(sales_amount) OVER (ORDER BY month_date ROWS 2 PRECEDING)
         AND LAG(sales_amount, 1) OVER (ORDER BY month_date) < 
             LAG(sales_amount, 2) OVER (ORDER BY month_date)
    THEN '下降趋势'  
    ELSE '平稳'
  END as trend_direction
  
FROM monthly_sales
ORDER BY month_date;
```

### 3.3 高级组合技巧


**🔧 组合优化技巧**
```sql
-- 技巧1：窗口规范复用
WITH base_calculations AS (
  SELECT 
    *,
    -- 定义通用窗口规范，避免重复计算
    SUM(sales_amount) OVER (PARTITION BY department) as dept_total,
    AVG(sales_amount) OVER (PARTITION BY department) as dept_avg,
    COUNT(*) OVER (PARTITION BY department) as dept_count
  FROM employee_sales
)
SELECT 
  *,
  -- 基于预计算结果进行分析
  ROUND(sales_amount / dept_total * 100, 2) as dept_contribution_pct,
  CASE WHEN sales_amount > dept_avg THEN '超过平均' ELSE '低于平均' END as vs_avg
FROM base_calculations;

-- 技巧2：多维度组合分析  
SELECT 
  employee_name,
  department,
  sales_amount,
  
  -- 部门内排名
  RANK() OVER (PARTITION BY department ORDER BY sales_amount DESC) as dept_rank,
  
  -- 总体排名
  RANK() OVER (ORDER BY sales_amount DESC) as overall_rank,
  
  -- 基于两个排名的综合评价
  CASE 
    WHEN RANK() OVER (PARTITION BY department ORDER BY sales_amount DESC) = 1
         AND RANK() OVER (ORDER BY sales_amount DESC) <= 5 
    THEN '部门明星+公司精英'
    WHEN RANK() OVER (PARTITION BY department ORDER BY sales_amount DESC) = 1 
    THEN '部门明星'
    WHEN RANK() OVER (ORDER BY sales_amount DESC) <= 10 
    THEN '公司精英'
    ELSE '普通员工'
  END as employee_category
  
FROM employee_sales;
```

---

## 4. ⚙️ 条件窗口查询设计


### 4.1 条件窗口的概念


**🔸 什么是条件窗口查询**
```
条件窗口查询：根据特定条件动态调整窗口行为的查询
应用场景：
• 按条件分组统计
• 条件性排名和过滤  
• 动态窗口范围调整
• 业务逻辑驱动的分析
```

**💡 与传统窗口的区别**
```
传统窗口：固定规则和范围
条件窗口：根据数据内容和业务逻辑灵活调整

例如：
传统：计算所有员工的排名
条件：只对销售额>5万的员工排名，其他显示"未达标"
```

### 4.2 条件窗口实现技术


**🔧 技术方案1：CASE WHEN组合**
```sql
-- 按业绩等级进行条件排名
SELECT 
  employee_name,
  sales_amount,
  
  -- 条件排名：只对高业绩员工排名
  CASE 
    WHEN sales_amount >= 50000 THEN 
      RANK() OVER (ORDER BY sales_amount DESC)
    ELSE NULL
  END as high_performer_rank,
  
  -- 条件分组统计
  CASE 
    WHEN sales_amount >= 50000 THEN 
      COUNT(*) OVER (ORDER BY sales_amount DESC 
                     ROWS UNBOUNDED PRECEDING)
    ELSE 0  
  END as high_performer_count,
  
  -- 业绩等级
  CASE 
    WHEN sales_amount >= 50000 THEN '高业绩'
    WHEN sales_amount >= 30000 THEN '中业绩'  
    ELSE '低业绩'
  END as performance_tier
  
FROM employee_sales
ORDER BY sales_amount DESC;
```

**🔧 技术方案2：FILTER子句（MySQL 8.0+）**
```sql
-- 使用FILTER进行条件聚合
SELECT 
  department,
  month_date,
  
  -- 条件统计：只统计大单销售
  COUNT(*) FILTER (WHERE sales_amount > 50000) 
    OVER (PARTITION BY department) as big_deals_count,
    
  -- 条件求和：只计算大单金额  
  SUM(sales_amount) FILTER (WHERE sales_amount > 50000)
    OVER (PARTITION BY department) as big_deals_amount,
    
  -- 条件平均：大单平均金额
  AVG(sales_amount) FILTER (WHERE sales_amount > 50000)
    OVER (PARTITION BY department) as big_deals_avg
    
FROM employee_sales;
```

### 4.3 复杂条件窗口案例


**🎯 案例：客户分层管理分析**
```sql
-- 根据客户价值进行分层管理
WITH customer_analysis AS (
  SELECT 
    customer_id,
    customer_name,
    total_purchase,
    last_purchase_date,
    
    -- 计算客户价值分层
    NTILE(5) OVER (ORDER BY total_purchase DESC) as value_tier,
    
    -- 最近购买天数
    DATEDIFF(CURRENT_DATE, last_purchase_date) as days_since_last_purchase
    
  FROM customer_summary
)
SELECT 
  customer_name,
  total_purchase,
  value_tier,
  days_since_last_purchase,
  
  -- 条件1：高价值客户的排名
  CASE 
    WHEN value_tier <= 2 THEN 
      RANK() OVER (ORDER BY total_purchase DESC)
    ELSE NULL
  END as vip_ranking,
  
  -- 条件2：流失风险评估
  CASE 
    WHEN value_tier <= 2 AND days_since_last_purchase > 90 THEN '高价值客户流失风险'
    WHEN value_tier <= 3 AND days_since_last_purchase > 180 THEN '中价值客户流失风险'
    WHEN days_since_last_purchase > 365 THEN '低活跃客户'
    ELSE '正常'
  END as risk_status,
  
  -- 条件3：营销策略建议
  CASE 
    WHEN value_tier = 1 AND days_since_last_purchase <= 30 THEN '白金服务'
    WHEN value_tier <= 2 AND days_since_last_purchase > 90 THEN '挽回营销'
    WHEN value_tier >= 4 AND total_purchase < 10000 THEN '促销推广'
    ELSE '常规维护'
  END as marketing_strategy
  
FROM customer_analysis
ORDER BY value_tier, total_purchase DESC;
```

---

## 5. 📊 动态窗口框架应用


### 5.1 动态窗口框架概念


**🔸 什么是动态窗口框架**
```
动态窗口框架：窗口大小和范围根据数据特征自动调整
核心特点：
• 自适应窗口大小
• 基于数据驱动的框架调整  
• 智能边界识别
• 业务逻辑导向的动态调整
```

**💡 应用价值**
- **智能分析**：根据数据特征自动选择最优分析窗口
- **异常检测**：动态调整检测范围以识别异常模式
- **趋势识别**：根据数据变化自动调整趋势分析周期

### 5.2 动态窗口实现技术


**🔧 方案1：基于数据量的动态调整**
```sql
-- 根据数据密度动态调整移动平均窗口
WITH data_density AS (
  SELECT 
    sales_date,
    sales_amount,
    
    -- 计算最近30天的数据点数量
    COUNT(*) OVER (ORDER BY sales_date 
                   RANGE BETWEEN INTERVAL 30 DAY PRECEDING 
                   AND CURRENT ROW) as data_points_30d
  FROM daily_sales
),
dynamic_analysis AS (
  SELECT 
    *,
    
    -- 根据数据密度动态选择窗口大小
    CASE 
      WHEN data_points_30d >= 25 THEN 7   -- 数据充足，用7天窗口
      WHEN data_points_30d >= 15 THEN 5   -- 数据中等，用5天窗口  
      WHEN data_points_30d >= 8 THEN 3    -- 数据稀少，用3天窗口
      ELSE 1                              -- 数据极少，不使用移动平均
    END as optimal_window_size
    
  FROM data_density
)
SELECT 
  sales_date,
  sales_amount,
  data_points_30d,
  optimal_window_size,
  
  -- 使用动态窗口计算移动平均（简化示例）
  CASE 
    WHEN optimal_window_size >= 7 THEN 
      AVG(sales_amount) OVER (ORDER BY sales_date ROWS 6 PRECEDING)
    WHEN optimal_window_size >= 5 THEN
      AVG(sales_amount) OVER (ORDER BY sales_date ROWS 4 PRECEDING)  
    WHEN optimal_window_size >= 3 THEN
      AVG(sales_amount) OVER (ORDER BY sales_date ROWS 2 PRECEDING)
    ELSE sales_amount
  END as dynamic_moving_avg
  
FROM dynamic_analysis;
```

**🔧 方案2：基于业务周期的动态框架**
```sql
-- 根据业务季节性动态调整分析框架
WITH seasonal_analysis AS (
  SELECT 
    sales_date,
    sales_amount,
    
    -- 识别业务季节性
    CASE 
      WHEN MONTH(sales_date) IN (11, 12, 1) THEN '旺季'
      WHEN MONTH(sales_date) IN (6, 7, 8) THEN '淡季'  
      ELSE '平季'
    END as business_season,
    
    -- 计算同期历史平均
    AVG(sales_amount) OVER (
      PARTITION BY MONTH(sales_date), DAY(sales_date)
      ORDER BY YEAR(sales_date)
      ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING
    ) as historical_avg
    
  FROM daily_sales
  WHERE sales_date >= DATE_SUB(CURRENT_DATE, INTERVAL 3 YEAR)
)
SELECT 
  sales_date,
  sales_amount,
  business_season,
  historical_avg,
  
  -- 基于季节性动态调整对比基准
  CASE business_season
    WHEN '旺季' THEN 
      ROUND((sales_amount - historical_avg * 1.2) / (historical_avg * 1.2) * 100, 2)
    WHEN '淡季' THEN
      ROUND((sales_amount - historical_avg * 0.8) / (historical_avg * 0.8) * 100, 2)
    ELSE  
      ROUND((sales_amount - historical_avg) / historical_avg * 100, 2)
  END as seasonal_adjusted_variance
  
FROM seasonal_analysis;
```

### 5.3 智能异常检测框架


**🔧 动态异常检测实现**
```sql
-- 智能异常检测：动态调整检测阈值
WITH statistical_base AS (
  SELECT 
    sales_date,
    sales_amount,
    
    -- 计算移动统计指标
    AVG(sales_amount) OVER (ORDER BY sales_date ROWS 29 PRECEDING) as moving_avg_30d,
    STDDEV(sales_amount) OVER (ORDER BY sales_date ROWS 29 PRECEDING) as moving_stddev_30d,
    
    -- 计算数据波动性
    STDDEV(sales_amount) OVER (ORDER BY sales_date ROWS 29 PRECEDING) / 
    AVG(sales_amount) OVER (ORDER BY sales_date ROWS 29 PRECEDING) as volatility_ratio
    
  FROM daily_sales
),
dynamic_thresholds AS (
  SELECT 
    *,
    
    -- 根据波动性动态调整异常检测阈值
    CASE 
      WHEN volatility_ratio > 0.3 THEN 3.0  -- 高波动环境，放宽阈值
      WHEN volatility_ratio > 0.2 THEN 2.5  -- 中等波动，标准阈值
      ELSE 2.0                               -- 低波动环境，严格阈值
    END as dynamic_threshold
    
  FROM statistical_base
  WHERE moving_stddev_30d IS NOT NULL
)
SELECT 
  sales_date,
  sales_amount,
  moving_avg_30d,
  moving_stddev_30d,
  volatility_ratio,
  dynamic_threshold,
  
  -- 动态异常检测
  CASE 
    WHEN ABS(sales_amount - moving_avg_30d) > dynamic_threshold * moving_stddev_30d 
    THEN '异常数据'
    ELSE '正常数据'  
  END as anomaly_status,
  
  -- 异常程度量化
  ROUND(ABS(sales_amount - moving_avg_30d) / moving_stddev_30d, 2) as anomaly_score
  
FROM dynamic_thresholds
ORDER BY sales_date;
```

---

## 6. 💼 复杂业务场景实现


### 6.1 电商平台用户行为分析


**🎯 业务需求**
分析用户购买行为，实现：
- 用户生命周期价值分析
- 购买频次和金额趋势  
- 流失预警和挽回策略
- 个性化推荐支持

**🔧 综合分析实现**
```sql
WITH user_behavior_base AS (
  SELECT 
    user_id,
    order_date,
    order_amount,
    product_category,
    
    -- 用户累计订单数
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date) as order_sequence,
    
    -- 用户累计消费金额
    SUM(order_amount) OVER (PARTITION BY user_id ORDER BY order_date) as cumulative_spent,
    
    -- 距离上次购买天数
    DATEDIFF(order_date, 
             LAG(order_date) OVER (PARTITION BY user_id ORDER BY order_date)
    ) as days_since_last_order,
    
    -- 用户平均订单金额  
    AVG(order_amount) OVER (PARTITION BY user_id ORDER BY order_date 
                           ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as avg_order_value
  FROM user_orders
  WHERE order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
),
user_lifecycle_analysis AS (
  SELECT 
    *,
    
    -- 用户生命周期阶段
    CASE 
      WHEN order_sequence = 1 THEN '新客户'
      WHEN order_sequence <= 3 THEN '成长期客户'
      WHEN order_sequence <= 10 THEN '成熟期客户'  
      ELSE 'VIP客户'
    END as lifecycle_stage,
    
    -- 购买频次趋势
    CASE 
      WHEN days_since_last_order IS NULL THEN '首单'
      WHEN days_since_last_order <= 30 THEN '高频用户'
      WHEN days_since_last_order <= 90 THEN '中频用户'
      WHEN days_since_last_order <= 180 THEN '低频用户'
      ELSE '沉睡用户'
    END as frequency_segment,
    
    -- 价值增长趋势
    LAG(cumulative_spent) OVER (PARTITION BY user_id ORDER BY order_date) as prev_cumulative_spent
    
  FROM user_behavior_base
)
SELECT 
  user_id,
  order_date,
  order_amount,
  lifecycle_stage,
  frequency_segment,
  cumulative_spent,
  avg_order_value,
  
  -- 价值增长率
  CASE 
    WHEN prev_cumulative_spent IS NOT NULL THEN
      ROUND((cumulative_spent - prev_cumulative_spent) / prev_cumulative_spent * 100, 2)
    ELSE 0
  END as value_growth_rate,
  
  -- 风险评估和营销建议
  CASE 
    WHEN lifecycle_stage = 'VIP客户' AND frequency_segment = '沉睡用户' 
    THEN '高价值流失风险-紧急挽回'
    WHEN lifecycle_stage IN ('成长期客户', '成熟期客户') AND frequency_segment = '沉睡用户'
    THEN '潜力客户流失-营销激活'  
    WHEN lifecycle_stage = '新客户' AND avg_order_value > 500
    THEN '高潜力新客-重点培育'
    WHEN frequency_segment = '高频用户' 
    THEN '活跃客户-交叉销售'
    ELSE '常规维护'
  END as marketing_recommendation
  
FROM user_lifecycle_analysis
ORDER BY user_id, order_date;
```

### 6.2 库存周转率动态监控


**🎯 业务场景**
实现库存智能监控：
- 动态计算周转率和库存天数
- 识别滞销和热销商品
- 预测缺货风险
- 优化补货策略

**🔧 动态库存分析**
```sql
WITH inventory_movement AS (
  SELECT 
    product_id,
    movement_date,
    movement_type,  -- 'IN'(入库) 或 'OUT'(出库)
    quantity,
    
    -- 计算库存余量
    SUM(CASE WHEN movement_type = 'IN' THEN quantity ELSE -quantity END) 
      OVER (PARTITION BY product_id ORDER BY movement_date 
            ROWS UNBOUNDED PRECEDING) as current_stock,
    
    -- 计算最近30天出库总量
    SUM(CASE WHEN movement_type = 'OUT' THEN quantity ELSE 0 END)
      OVER (PARTITION BY product_id ORDER BY movement_date 
            RANGE BETWEEN INTERVAL 30 DAY PRECEDING AND CURRENT ROW) as sales_30d,
    
    -- 计算平均库存（近30天）
    AVG(SUM(CASE WHEN movement_type = 'IN' THEN quantity ELSE -quantity END) 
        OVER (PARTITION BY product_id ORDER BY movement_date 
              ROWS UNBOUNDED PRECEDING))
      OVER (PARTITION BY product_id ORDER BY movement_date 
            RANGE BETWEEN INTERVAL 30 DAY PRECEDING AND CURRENT ROW) as avg_stock_30d
            
  FROM inventory_movements
  WHERE movement_date >= DATE_SUB(CURRENT_DATE, INTERVAL 90 DAY)
),
turnover_analysis AS (
  SELECT 
    product_id,
    movement_date,
    current_stock,
    sales_30d,
    avg_stock_30d,
    
    -- 库存周转率（月度）
    CASE 
      WHEN avg_stock_30d > 0 THEN ROUND(sales_30d / avg_stock_30d, 2)
      ELSE 0  
    END as monthly_turnover_rate,
    
    -- 库存可售天数
    CASE 
      WHEN sales_30d > 0 THEN ROUND(current_stock / (sales_30d / 30.0), 1)
      ELSE 999  -- 无销售时设为很大值
    END as days_of_inventory,
    
    -- 销售趋势（近7天 vs 前7天）
    AVG(CASE WHEN movement_type = 'OUT' THEN quantity ELSE 0 END)
      OVER (PARTITION BY product_id ORDER BY movement_date 
            RANGE BETWEEN INTERVAL 7 DAY PRECEDING AND CURRENT ROW) as avg_daily_sales_7d,
    
    AVG(CASE WHEN movement_type = 'OUT' THEN quantity ELSE 0 END)  
      OVER (PARTITION BY product_id ORDER BY movement_date 
            RANGE BETWEEN INTERVAL 14 DAY PRECEDING AND INTERVAL 7 DAY PRECEDING) as avg_daily_sales_prev_7d
            
  FROM inventory_movement
)
SELECT 
  product_id,
  current_stock,
  monthly_turnover_rate,
  days_of_inventory,
  
  -- 销售趋势判断
  CASE 
    WHEN avg_daily_sales_7d > avg_daily_sales_prev_7d * 1.2 THEN '销售上升'
    WHEN avg_daily_sales_7d < avg_daily_sales_prev_7d * 0.8 THEN '销售下降'  
    ELSE '销售平稳'
  END as sales_trend,
  
  -- 库存状态分类
  CASE 
    WHEN days_of_inventory < 7 THEN '缺货风险'
    WHEN days_of_inventory < 15 THEN '库存偏低'
    WHEN days_of_inventory < 45 THEN '库存正常'
    WHEN days_of_inventory < 90 THEN '库存偏高'  
    ELSE '滞销风险'
  END as inventory_status,
  
  -- 补货建议
  CASE 
    WHEN days_of_inventory < 7 AND avg_daily_sales_7d > 0 
    THEN CONCAT('紧急补货:', ROUND(avg_daily_sales_7d * 30 - current_stock), '件')
    WHEN days_of_inventory < 15 AND monthly_turnover_rate > 2
    THEN CONCAT('建议补货:', ROUND(avg_daily_sales_7d * 30 - current_stock), '件') 
    WHEN days_of_inventory > 90 AND monthly_turnover_rate < 0.5
    THEN '建议促销清库存'
    ELSE '维持现状'  
  END as restock_recommendation
  
FROM turnover_analysis
WHERE movement_date = (SELECT MAX(movement_date) FROM inventory_movements)
ORDER BY monthly_turnover_rate DESC;
```

---

## 7. 🚀 性能优化策略


### 7.1 复杂窗口查询优化原则 🔑


**🔸 核心优化原则**
```
计算复用原则：
• 相同窗口规范的函数放在同一查询中
• 使用CTE缓存中间结果
• 避免重复计算相同的聚合值

索引优化原则：  
• 为PARTITION BY字段建索引
• 为ORDER BY字段建索引
• 考虑复合索引的字段顺序

内存管理原则：
• 控制窗口框架大小
• 合理使用ROWS vs RANGE
• 避免过大的数据集
```

### 7.2 查询优化技术


**🔧 优化技术1：计算结果缓存**
```sql
-- 优化前：重复计算
SELECT 
  employee_id,
  sales_amount,
  RANK() OVER (PARTITION BY department ORDER BY sales_amount DESC) as dept_rank,
  sales_amount / SUM(sales_amount) OVER (PARTITION BY department) as dept_pct,
  AVG(sales_amount) OVER (PARTITION BY department) as dept_avg
FROM employee_sales;

-- 优化后：使用CTE缓存
WITH dept_aggregates AS (
  SELECT 
    department,
    SUM(sales_amount) as dept_total,
    AVG(sales_amount) as dept_avg
  FROM employee_sales
  GROUP BY department
)
SELECT 
  e.employee_id,
  e.sales_amount,
  RANK() OVER (PARTITION BY e.department ORDER BY e.sales_amount DESC) as dept_rank,
  ROUND(e.sales_amount / d.dept_total * 100, 2) as dept_pct,
  d.dept_avg
FROM employee_sales e
JOIN dept_aggregates d ON e.department = d.department;
```

**🔧 优化技术2：分段处理**
```sql
-- 大数据集分段处理示例
WITH monthly_segments AS (
  SELECT 
    *,
    DATE_FORMAT(order_date, '%Y-%m') as month_key
  FROM large_orders_table
  WHERE order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 12 MONTH)
),
monthly_analysis AS (
  SELECT 
    month_key,
    customer_id,
    SUM(order_amount) as monthly_amount,
    COUNT(*) as monthly_orders,
    
    -- 在月度级别计算窗口函数
    RANK() OVER (PARTITION BY month_key ORDER BY SUM(order_amount) DESC) as monthly_rank
  FROM monthly_segments  
  GROUP BY month_key, customer_id
)
-- 最终汇总分析
SELECT 
  customer_id,
  AVG(monthly_amount) as avg_monthly_amount,
  AVG(monthly_rank) as avg_monthly_rank,
  COUNT(*) as active_months
FROM monthly_analysis
GROUP BY customer_id
ORDER BY avg_monthly_amount DESC;
```

### 7.3 监控和调优


**📊 性能监控查询**
```sql
-- 监控窗口查询性能
SELECT 
  sql_text,
  avg_timer_wait/1000000 as avg_duration_ms,
  count_star as execution_count,
  sum_rows_examined as total_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE sql_text LIKE '%OVER%'
ORDER BY avg_timer_wait DESC
LIMIT 10;

-- 检查是否使用了索引
EXPLAIN FORMAT=JSON
SELECT 
  employee_id,
  RANK() OVER (PARTITION BY department ORDER BY sales_amount DESC) as rank
FROM employee_sales;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 多层嵌套：窗口函数的递进式应用，解决复杂分析需求
🔸 函数组合：多个窗口函数协同配合，实现综合分析效果
🔸 条件查询：根据业务条件动态调整窗口行为和计算逻辑  
🔸 动态框架：窗口大小和范围根据数据特征自适应调整
🔸 业务实现：将复杂业务逻辑转化为高效的窗口查询
🔸 性能优化：通过合理设计提升复杂查询的执行效率
```

### 8.2 关键理解要点


**🔹 复杂窗口查询的设计思路**
```
分层设计思想：
• 第一层：基础数据计算和清理
• 第二层：基于基础数据的分析计算  
• 第三层：综合分析和业务判断

组合应用原则：
• 互补性：不同函数解决不同维度问题
• 协同性：函数间结果可以相互传递使用
• 效率性：合理复用避免重复计算
```

**🔹 条件和动态控制的价值**
```
灵活性提升：
• 根据数据特征调整分析策略
• 根据业务场景动态选择计算方式
• 实现智能化的数据分析

实用性增强：  
• 更贴近实际业务需求
• 提供可操作的分析结果
• 支持复杂决策制定
```

### 8.3 实际应用指导


**💡 复杂查询设计步骤**
```
步骤1：需求分析
• 明确业务分析目标
• 识别关键分析维度
• 确定输出结果格式

步骤2：数据梳理
• 理解数据结构和关系
• 识别数据质量问题
• 确定计算基础数据

步骤3：分层设计
• 设计计算层次结构
• 确定各层计算逻辑
• 规划数据传递关系

步骤4：优化调试
• 验证计算结果正确性  
• 监控查询执行性能
• 优化索引和查询结构
```

**🚨 常见问题避免**
```
性能问题：
• 避免不必要的复杂嵌套
• 合理使用索引支持
• 控制数据集大小

逻辑错误：
• 仔细验证窗口范围定义
• 检查NULL值处理逻辑
• 确认分组和排序逻辑

可维护性：
• 使用CTE提高代码可读性
• 添加适当的注释说明
• 模块化设计便于调试
```

### 8.4 进阶学习建议


**🎯 学习重点**
- ✅ **掌握基础**：先熟练掌握单个窗口函数的使用
- ✅ **理解组合**：学会多个函数的配合使用模式  
- ✅ **实践应用**：结合实际业务场景进行练习
- ✅ **性能优化**：学习查询优化和性能调优技术

**🔧 实践建议**
- 💡 **从简到繁**：逐步增加查询复杂度
- 💡 **多做练习**：通过实际案例加深理解
- 💡 **性能监控**：养成监控查询性能的习惯  
- 💡 **代码管理**：建立复杂查询的代码库和模板

**核心记忆**：
- 复杂窗口查询是数据分析的高级工具
- 分层设计和函数组合是核心技术
- 条件控制和动态调整提供更大灵活性
- 性能优化是实用性的重要保障