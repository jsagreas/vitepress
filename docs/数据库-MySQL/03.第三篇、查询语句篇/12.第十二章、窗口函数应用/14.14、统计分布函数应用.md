---
title: 14、统计分布函数应用
---
## 📚 目录

1. [统计分布函数概述](#1-统计分布函数概述)
2. [CUME_DIST累积分布函数](#2-cume_dist累积分布函数)
3. [PERCENT_RANK百分比排名函数](#3-percent_rank百分比排名函数)
4. [分位数计算方法](#4-分位数计算方法)
5. [统计分布分析实践](#5-统计分布分析实践)
6. [数据分布特征识别](#6-数据分布特征识别)
7. [异常值检测应用](#7-异常值检测应用)
8. [统计分布函数应用场景](#8-统计分布函数应用场景)
9. [数据分析统计方法](#9-数据分析统计方法)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📊 统计分布函数概述


### 1.1 什么是统计分布函数


**💡 基本概念理解**
统计分布函数是用来分析数据分布特征的窗口函数，它们能告诉我们每个数据点在整个数据集中所处的相对位置。

```
简单理解：
就像学校考试成绩排名：
- CUME_DIST：告诉你有多少比例的同学成绩不如你
- PERCENT_RANK：告诉你你在所有同学中的百分比位置
- 分位数：把所有同学按成绩分成几等份

这些函数帮助我们理解数据的分布规律
```

### 1.2 统计分布函数的作用


**🎯 核心价值**
- **相对位置**：确定每个值在数据集中的相对排名
- **分布特征**：了解数据的分布形状和特点
- **异常识别**：发现极端值和异常数据点
- **业务决策**：基于统计分布制定业务策略

### 1.3 统计分布函数分类


**📋 主要函数类型**
```sql
-- 累积分布函数
CUME_DIST()     -- 累积分布比例
PERCENT_RANK()  -- 百分比排名

-- 分位数函数  
NTILE(n)        -- 分n个等份
PERCENTILE_CONT() -- 连续百分位数
PERCENTILE_DISC() -- 离散百分位数

-- 排名函数
ROW_NUMBER()    -- 行号排名
RANK()          -- 并列排名
DENSE_RANK()    -- 密集排名
```

---

## 2. 📈 CUME_DIST累积分布函数


### 2.1 CUME_DIST函数原理


**🔸 累积分布概念**
CUME_DIST函数计算小于等于当前行的行数占总行数的比例，返回值在0到1之间。

```
理解方式：
假设班级考试成绩：[60, 70, 80, 80, 90, 95]

成绩80分的CUME_DIST：
- 小于等于80分的人数：4人  
- 总人数：6人
- CUME_DIST = 4/6 = 0.667

含义：67%的同学成绩不超过80分
```

### 2.2 CUME_DIST语法和用法


**📝 基本语法**
```sql
CUME_DIST() OVER (
    [PARTITION BY 分组列]
    ORDER BY 排序列 [ASC|DESC]
)
```

**🔧 实际应用示例**
```sql
-- 创建员工薪资表
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    hire_date DATE
);

-- 插入测试数据
INSERT INTO employees VALUES
(1, '张三', '技术部', 8000, '2022-01-15'),
(2, '李四', '技术部', 12000, '2021-06-10'),
(3, '王五', '技术部', 15000, '2020-03-20'),
(4, '赵六', '销售部', 7000, '2022-05-12'),
(5, '钱七', '销售部', 9000, '2021-08-15'),
(6, '孙八', '销售部', 11000, '2020-12-01'),
(7, '周九', '人事部', 6000, '2022-02-28'),
(8, '吴十', '人事部', 8500, '2021-11-05');

-- 计算每个员工的薪资累积分布
SELECT 
    name,
    department,
    salary,
    CUME_DIST() OVER (ORDER BY salary) as salary_cume_dist,
    ROUND(CUME_DIST() OVER (ORDER BY salary) * 100, 1) as salary_percentile
FROM employees
ORDER BY salary;
```

**📊 查询结果解释**
```
姓名    部门    薪资    累积分布    百分位
周九    人事部  6000    0.125      12.5%
赵六    销售部  7000    0.250      25.0%  
张三    技术部  8000    0.375      37.5%
吴十    人事部  8500    0.500      50.0%
钱七    销售部  9000    0.625      62.5%
孙八    销售部  11000   0.750      75.0%
李四    技术部  12000   0.875      87.5%
王五    技术部  15000   1.000      100.0%

解读：
- 张三薪资8000，37.5%的员工薪资不超过他
- 钱七薪资9000，62.5%的员工薪资不超过他
```

### 2.3 分部门累积分布分析


**🏢 部门内薪资分布**
```sql
-- 各部门内的薪资累积分布
SELECT 
    name,
    department,
    salary,
    CUME_DIST() OVER (
        PARTITION BY department 
        ORDER BY salary
    ) as dept_cume_dist,
    CUME_DIST() OVER (ORDER BY salary) as company_cume_dist
FROM employees
ORDER BY department, salary;
```

**📈 分析结果**
```
部门内分布 vs 全公司分布：

技术部内部：
- 张三：部门内33.3%，全公司37.5%
- 李四：部门内66.7%，全公司87.5% 
- 王五：部门内100%，全公司100%

销售部内部：
- 赵六：部门内33.3%，全公司25.0%
- 钱七：部门内66.7%，全公司62.5%
- 孙八：部门内100%，全公司75.0%

观察：技术部整体薪资水平较高
```

### 2.4 CUME_DIST实际应用


**💼 业务场景应用**
```sql
-- 场景1：找出薪资前25%的高薪员工
SELECT 
    name,
    department, 
    salary,
    ROUND(CUME_DIST() OVER (ORDER BY salary DESC) * 100, 1) as top_percentile
FROM employees
WHERE CUME_DIST() OVER (ORDER BY salary DESC) <= 0.25
ORDER BY salary DESC;

-- 场景2：识别各部门薪资分布情况
SELECT 
    department,
    COUNT(*) as total_employees,
    COUNT(CASE WHEN CUME_DIST() OVER (PARTITION BY department ORDER BY salary) <= 0.5 
          THEN 1 END) as below_median_count,
    AVG(salary) as avg_salary,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary
FROM employees
GROUP BY department
ORDER BY avg_salary DESC;
```

---

## 3. 🏆 PERCENT_RANK百分比排名函数


### 3.1 PERCENT_RANK函数原理


**🔸 百分比排名概念**
PERCENT_RANK计算当前行的排名减1后除以总行数减1的结果，表示有多少比例的值小于当前值。

```
计算公式：
PERCENT_RANK = (当前行排名 - 1) / (总行数 - 1)

与CUME_DIST的区别：
- PERCENT_RANK：严格小于当前值的比例
- CUME_DIST：小于等于当前值的比例

示例数据：[60, 70, 80, 80, 90, 95]
成绩80分：
- PERCENT_RANK = (3-1)/(6-1) = 2/5 = 0.4 (40%的人成绩低于80)
- CUME_DIST = 4/6 = 0.667 (66.7%的人成绩不超过80)
```

### 3.2 PERCENT_RANK语法和实例


**📝 基本语法**
```sql
PERCENT_RANK() OVER (
    [PARTITION BY 分组列]
    ORDER BY 排序列 [ASC|DESC]
)
```

**🔧 实际对比示例**
```sql
-- PERCENT_RANK与CUME_DIST对比分析
SELECT 
    name,
    salary,
    RANK() OVER (ORDER BY salary) as salary_rank,
    PERCENT_RANK() OVER (ORDER BY salary) as percent_rank,
    CUME_DIST() OVER (ORDER BY salary) as cume_dist,
    ROUND(PERCENT_RANK() OVER (ORDER BY salary) * 100, 1) as percent_rank_pct,
    ROUND(CUME_DIST() OVER (ORDER BY salary) * 100, 1) as cume_dist_pct
FROM employees
ORDER BY salary;
```

**📊 结果对比分析**
```
姓名  薪资   排名  PERCENT_RANK  CUME_DIST  PR百分比  CD百分比
周九  6000   1     0.000        0.125      0.0%     12.5%
赵六  7000   2     0.143        0.250      14.3%    25.0%
张三  8000   3     0.286        0.375      28.6%    37.5%
吴十  8500   4     0.429        0.500      42.9%    50.0%
钱七  9000   5     0.571        0.625      57.1%    62.5%
孙八  11000  6     0.714        0.750      71.4%    75.0%
李四  12000  7     0.857        0.875      85.7%    87.5%
王五  15000  8     1.000        1.000      100.0%   100.0%

关键差异：
- 最小值：PERCENT_RANK=0，CUME_DIST>0
- 最大值：两者都等于1
- 中间值：PERCENT_RANK < CUME_DIST
```

### 3.3 处理重复值情况


**🔄 重复值处理示例**
```sql
-- 添加重复薪资数据测试
INSERT INTO employees VALUES
(9, '新员工A', '技术部', 8000, '2023-01-01'),
(10, '新员工B', '技术部', 8000, '2023-01-01');

-- 查看重复值的处理情况
SELECT 
    name,
    salary,
    RANK() OVER (ORDER BY salary) as rank_num,
    DENSE_RANK() OVER (ORDER BY salary) as dense_rank_num,
    PERCENT_RANK() OVER (ORDER BY salary) as percent_rank,
    CUME_DIST() OVER (ORDER BY salary) as cume_dist
FROM employees
WHERE salary BETWEEN 7500 AND 8500
ORDER BY salary, name;
```

**📈 重复值结果分析**
```
姓名     薪资  RANK  DENSE_RANK  PERCENT_RANK  CUME_DIST
张三     8000  3     2           0.222         0.500
新员工A  8000  3     2           0.222         0.500  
新员工B  8000  3     2           0.222         0.500
吴十     8500  6     3           0.556         0.600

重复值特点：
- 相同值的PERCENT_RANK和CUME_DIST相同
- PERCENT_RANK基于RANK计算
- CUME_DIST考虑所有小于等于当前值的行
```

### 3.4 PERCENT_RANK应用场景


**💼 实际业务应用**
```sql
-- 场景1：绩效评估分级
SELECT 
    name,
    department,
    salary,
    PERCENT_RANK() OVER (ORDER BY salary) as performance_rank,
    CASE 
        WHEN PERCENT_RANK() OVER (ORDER BY salary) >= 0.8 THEN 'A级-优秀'
        WHEN PERCENT_RANK() OVER (ORDER BY salary) >= 0.6 THEN 'B级-良好'  
        WHEN PERCENT_RANK() OVER (ORDER BY salary) >= 0.4 THEN 'C级-一般'
        WHEN PERCENT_RANK() OVER (ORDER BY salary) >= 0.2 THEN 'D级-待改进'
        ELSE 'E级-需培训'
    END as performance_grade
FROM employees
ORDER BY salary DESC;

-- 场景2：薪资调整建议
SELECT 
    department,
    name,
    salary,
    PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) as dept_rank,
    CASE 
        WHEN PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) < 0.3 
        THEN '建议涨薪15%'
        WHEN PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) < 0.7 
        THEN '建议涨薪10%'
        ELSE '建议涨薪5%'
    END as salary_advice
FROM employees
ORDER BY department, salary;
```

---

## 4. 📐 分位数计算方法


### 4.1 分位数基本概念


**💡 分位数含义**
分位数是将数据按大小顺序排列后，处于特定位置的数值。常用的分位数包括四分位数、十分位数、百分位数等。

```
分位数类型：
- 四分位数：将数据分成4等份（Q1, Q2, Q3）
- 十分位数：将数据分成10等份（D1, D2, ..., D9）
- 百分位数：将数据分成100等份（P1, P2, ..., P99）

实际意义：
- Q1（第一四分位数）：25%的数据小于此值
- Q2（中位数）：50%的数据小于此值  
- Q3（第三四分位数）：75%的数据小于此值
```

### 4.2 NTILE函数应用


**📊 等份分组函数**
```sql
-- NTILE函数将数据分成n个等份
SELECT 
    name,
    salary,
    NTILE(4) OVER (ORDER BY salary) as quartile,
    NTILE(10) OVER (ORDER BY salary) as decile,
    CASE NTILE(4) OVER (ORDER BY salary)
        WHEN 1 THEN '第一四分位数（0-25%）'
        WHEN 2 THEN '第二四分位数（25-50%）'
        WHEN 3 THEN '第三四分位数（50-75%）'
        WHEN 4 THEN '第四四分位数（75-100%）'
    END as quartile_desc
FROM employees
ORDER BY salary;
```

**🔍 分位数统计分析**
```sql
-- 各分位数的统计信息
WITH quartile_stats AS (
    SELECT 
        name,
        salary,
        NTILE(4) OVER (ORDER BY salary) as quartile
    FROM employees
)
SELECT 
    quartile,
    COUNT(*) as employee_count,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary,
    AVG(salary) as avg_salary,
    ROUND(AVG(salary), 0) as rounded_avg
FROM quartile_stats
GROUP BY quartile
ORDER BY quartile;
```

### 4.3 百分位数计算


**📈 PERCENTILE函数应用**
```sql
-- 计算特定百分位数值
SELECT 
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as Q1_continuous,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary) as median_continuous,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) as Q3_continuous,
    PERCENTILE_DISC(0.25) WITHIN GROUP (ORDER BY salary) as Q1_discrete,
    PERCENTILE_DISC(0.50) WITHIN GROUP (ORDER BY salary) as median_discrete,
    PERCENTILE_DISC(0.75) WITHIN GROUP (ORDER BY salary) as Q3_discrete
FROM employees;

-- 各部门的分位数对比
SELECT 
    department,
    COUNT(*) as emp_count,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as Q1,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary) as median,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) as Q3,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) - 
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as IQR
FROM employees
GROUP BY department
ORDER BY median DESC;
```

### 4.4 分位数实际应用


**💼 业务场景应用**
```sql
-- 场景1：薪资分布箱线图数据
WITH salary_quantiles AS (
    SELECT 
        department,
        PERCENTILE_CONT(0.00) WITHIN GROUP (ORDER BY salary) as min_val,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as q1,
        PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary) as median,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) as q3,
        PERCENTILE_CONT(1.00) WITHIN GROUP (ORDER BY salary) as max_val
    FROM employees
    GROUP BY department
)
SELECT 
    department,
    min_val,
    q1,
    median,
    q3, 
    max_val,
    q3 - q1 as iqr,
    ROUND((q3 - q1) / median * 100, 1) as variation_coefficient
FROM salary_quantiles
ORDER BY median DESC;
```

---

## 5. 📊 统计分布分析实践


### 5.1 完整分布分析框架


**🔧 综合分析查询**
```sql
-- 薪资分布完整分析
WITH salary_analysis AS (
    SELECT 
        name,
        department,
        salary,
        -- 排名相关
        ROW_NUMBER() OVER (ORDER BY salary) as row_num,
        RANK() OVER (ORDER BY salary) as rank_num,
        DENSE_RANK() OVER (ORDER BY salary) as dense_rank,
        
        -- 分布相关
        PERCENT_RANK() OVER (ORDER BY salary) as percent_rank,
        CUME_DIST() OVER (ORDER BY salary) as cume_dist,
        NTILE(4) OVER (ORDER BY salary) as quartile,
        
        -- 部门内分布
        PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) as dept_percent_rank,
        CUME_DIST() OVER (PARTITION BY department ORDER BY salary) as dept_cume_dist
    FROM employees
)
SELECT 
    name,
    department,
    salary,
    quartile,
    ROUND(percent_rank * 100, 1) as company_percentile,
    ROUND(dept_percent_rank * 100, 1) as dept_percentile,
    CASE 
        WHEN quartile = 1 THEN '薪资偏低'
        WHEN quartile = 2 THEN '薪资中等偏低'  
        WHEN quartile = 3 THEN '薪资中等偏高'
        ELSE '薪资较高'
    END as salary_level
FROM salary_analysis
ORDER BY salary;
```

### 5.2 分布形状判断


**📈 数据分布特征识别**
```sql
-- 分布偏度和峰度分析（近似计算）
WITH distribution_stats AS (
    SELECT 
        department,
        AVG(salary) as mean_salary,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) as median_salary,
        STDDEV(salary) as std_salary,
        MIN(salary) as min_salary,
        MAX(salary) as max_salary,
        COUNT(*) as sample_size
    FROM employees
    GROUP BY department
),
skewness_analysis AS (
    SELECT 
        department,
        mean_salary,
        median_salary,
        std_salary,
        -- 偏度近似：(均值-中位数)/标准差
        CASE 
            WHEN std_salary > 0 THEN (mean_salary - median_salary) / std_salary
            ELSE 0 
        END as skewness_approx,
        max_salary - min_salary as range_val,
        sample_size
    FROM distribution_stats
)
SELECT 
    department,
    ROUND(mean_salary, 0) as mean_salary,
    ROUND(median_salary, 0) as median_salary,
    ROUND(std_salary, 0) as std_deviation,
    ROUND(skewness_approx, 3) as skewness,
    CASE 
        WHEN ABS(skewness_approx) < 0.1 THEN '近似正态分布'
        WHEN skewness_approx > 0.1 THEN '右偏分布（少数高值）'
        ELSE '左偏分布（少数低值）'
    END as distribution_type
FROM skewness_analysis
ORDER BY mean_salary DESC;
```

### 5.3 分布比较分析


**⚖️ 多组分布对比**
```sql
-- 不同部门薪资分布对比
SELECT 
    '技术部' as department,
    ROUND(AVG(salary), 0) as avg_salary,
    ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary), 0) as Q1,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary), 0) as median,
    ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary), 0) as Q3,
    ROUND(STDDEV(salary), 0) as std_dev
FROM employees WHERE department = '技术部'

UNION ALL

SELECT 
    '销售部' as department,
    ROUND(AVG(salary), 0) as avg_salary,
    ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary), 0) as Q1,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary), 0) as median,
    ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary), 0) as Q3,
    ROUND(STDDEV(salary), 0) as std_dev
FROM employees WHERE department = '销售部'

UNION ALL

SELECT 
    '人事部' as department,
    ROUND(AVG(salary), 0) as avg_salary,
    ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary), 0) as Q1,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary), 0) as median,
    ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary), 0) as Q3,
    ROUND(STDDEV(salary), 0) as std_dev
FROM employees WHERE department = '人事部'

ORDER BY avg_salary DESC;
```

---

## 6. 🔍 数据分布特征识别


### 6.1 正态分布检验


**📊 分布形状识别方法**
```sql
-- 正态分布特征检验
WITH normality_test AS (
    SELECT 
        department,
        salary,
        AVG(salary) OVER (PARTITION BY department) as dept_mean,
        STDDEV(salary) OVER (PARTITION BY department) as dept_std,
        -- 标准化分数
        (salary - AVG(salary) OVER (PARTITION BY department)) / 
        NULLIF(STDDEV(salary) OVER (PARTITION BY department), 0) as z_score
    FROM employees
),
distribution_check AS (
    SELECT 
        department,
        COUNT(*) as total_count,
        -- 68-95-99.7规则检验（正态分布特征）
        SUM(CASE WHEN ABS(z_score) <= 1 THEN 1 ELSE 0 END) as within_1_std,
        SUM(CASE WHEN ABS(z_score) <= 2 THEN 1 ELSE 0 END) as within_2_std,
        SUM(CASE WHEN ABS(z_score) <= 3 THEN 1 ELSE 0 END) as within_3_std
    FROM normality_test
    GROUP BY department
)
SELECT 
    department,
    total_count,
    ROUND(within_1_std * 100.0 / total_count, 1) as pct_within_1_std,
    ROUND(within_2_std * 100.0 / total_count, 1) as pct_within_2_std,
    ROUND(within_3_std * 100.0 / total_count, 1) as pct_within_3_std,
    CASE 
        WHEN (within_1_std * 100.0 / total_count) BETWEEN 60 AND 75 THEN '接近正态分布'
        WHEN (within_1_std * 100.0 / total_count) > 75 THEN '高度集中分布'
        ELSE '分散分布'
    END as distribution_pattern
FROM distribution_check
ORDER BY total_count DESC;
```

### 6.2 分布不均匀性分析


**⚖️ 分布均匀性检测**
```sql
-- 各分位数区间人数分布
WITH quartile_distribution AS (
    SELECT 
        department,
        NTILE(4) OVER (PARTITION BY department ORDER BY salary) as quartile,
        salary,
        COUNT(*) OVER (PARTITION BY department) as dept_total
    FROM employees
)
SELECT 
    department,
    quartile,
    COUNT(*) as quartile_count,
    MAX(dept_total) as dept_total,
    ROUND(COUNT(*) * 100.0 / MAX(dept_total), 1) as quartile_percentage,
    CASE 
        WHEN COUNT(*) * 100.0 / MAX(dept_total) > 30 THEN '分布不均-偏多'
        WHEN COUNT(*) * 100.0 / MAX(dept_total) < 20 THEN '分布不均-偏少'  
        ELSE '分布相对均匀'
    END as distribution_balance
FROM quartile_distribution
GROUP BY department, quartile
ORDER BY department, quartile;
```

### 6.3 数据分布可视化准备


**📈 分布图表数据准备**
```sql
-- 为直方图准备数据
WITH salary_bins AS (
    SELECT 
        department,
        salary,
        -- 创建薪资区间
        CASE 
            WHEN salary < 7000 THEN '6000-7000'
            WHEN salary < 8000 THEN '7000-8000'
            WHEN salary < 9000 THEN '8000-9000'
            WHEN salary < 10000 THEN '9000-10000'
            WHEN salary < 11000 THEN '10000-11000'
            WHEN salary < 12000 THEN '11000-12000'
            WHEN salary < 13000 THEN '12000-13000'
            ELSE '13000+'
        END as salary_bin
    FROM employees
)
SELECT 
    salary_bin,
    COUNT(*) as frequency,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM employees), 1) as percentage,
    -- 简单的直方图可视化
    REPEAT('■', COUNT(*)) as histogram_bar
FROM salary_bins
GROUP BY salary_bin
ORDER BY 
    CASE salary_bin
        WHEN '6000-7000' THEN 1
        WHEN '7000-8000' THEN 2
        WHEN '8000-9000' THEN 3
        WHEN '9000-10000' THEN 4
        WHEN '10000-11000' THEN 5
        WHEN '11000-12000' THEN 6
        WHEN '12000-13000' THEN 7
        ELSE 8
    END;
```

---

## 7. 🚨 异常值检测应用


### 7.1 基于分位数的异常值检测


**🔍 IQR方法异常值检测**
```sql
-- 使用四分位数间距（IQR）检测异常值
WITH quartile_bounds AS (
    SELECT 
        department,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) as Q3,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) - 
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as IQR
    FROM employees
    GROUP BY department
),
outlier_bounds AS (
    SELECT 
        department,
        Q1,
        Q3,
        IQR,
        Q1 - 1.5 * IQR as lower_bound,
        Q3 + 1.5 * IQR as upper_bound,
        Q1 - 3 * IQR as extreme_lower_bound,
        Q3 + 3 * IQR as extreme_upper_bound
    FROM quartile_bounds
)
SELECT 
    e.name,
    e.department,
    e.salary,
    ob.lower_bound,
    ob.upper_bound,
    CASE 
        WHEN e.salary < ob.extreme_lower_bound OR e.salary > ob.extreme_upper_bound 
        THEN '极端异常值'
        WHEN e.salary < ob.lower_bound OR e.salary > ob.upper_bound 
        THEN '轻微异常值'
        ELSE '正常值'
    END as outlier_type,
    -- 异常程度
    CASE 
        WHEN e.salary < ob.lower_bound 
        THEN ROUND((ob.lower_bound - e.salary) / ob.IQR, 2)
        WHEN e.salary > ob.upper_bound 
        THEN ROUND((e.salary - ob.upper_bound) / ob.IQR, 2)
        ELSE 0
    END as outlier_degree
FROM employees e
JOIN outlier_bounds ob ON e.department = ob.department
WHERE e.salary < ob.lower_bound OR e.salary > ob.upper_bound
ORDER BY e.department, outlier_degree DESC;
```

### 7.2 基于百分位数的异常值检测


**📊 百分位数异常值识别**
```sql
-- 使用百分位数方法检测异常值
WITH percentile_analysis AS (
    SELECT 
        name,
        department,
        salary,
        PERCENT_RANK() OVER (ORDER BY salary) as global_percentile,
        PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) as dept_percentile
    FROM employees
)
SELECT 
    name,
    department,
    salary,
    ROUND(global_percentile * 100, 1) as global_pct,
    ROUND(dept_percentile * 100, 1) as dept_pct,
    CASE 
        WHEN global_percentile <= 0.05 OR global_percentile >= 0.95 
        THEN '全公司异常值'
        WHEN dept_percentile <= 0.1 OR dept_percentile >= 0.9 
        THEN '部门内异常值'
        ELSE '正常范围'
    END as anomaly_type,
    CASE 
        WHEN global_percentile <= 0.01 OR global_percentile >= 0.99 
        THEN '需要特别关注'
        WHEN global_percentile <= 0.05 OR global_percentile >= 0.95 
        THEN '需要关注'
        ELSE '无需特别关注'
    END as attention_level
FROM percentile_analysis
ORDER BY 
    CASE 
        WHEN global_percentile <= 0.05 THEN global_percentile
        WHEN global_percentile >= 0.95 THEN 1 - global_percentile  
        ELSE 1
    END;
```

### 7.3 多维度异常值分析


**🎯 综合异常值评估**
```sql
-- 多维度异常值检测
WITH multi_dimension_analysis AS (
    SELECT 
        name,
        department,
        salary,
        hire_date,
        -- 薪资维度
        PERCENT_RANK() OVER (ORDER BY salary) as salary_percentile,
        -- 工作年限计算
        DATEDIFF(CURDATE(), hire_date) / 365.25 as work_years,
        -- 薪资与工作年限比值
        salary / NULLIF(DATEDIFF(CURDATE(), hire_date) / 365.25, 0) as salary_per_year
    FROM employees
),
anomaly_detection AS (
    SELECT 
        *,
        PERCENT_RANK() OVER (ORDER BY work_years) as experience_percentile,
        PERCENT_RANK() OVER (ORDER BY salary_per_year) as efficiency_percentile
    FROM multi_dimension_analysis
)
SELECT 
    name,
    department,
    salary,
    ROUND(work_years, 1) as work_years,
    ROUND(salary_per_year, 0) as annual_salary_growth,
    ROUND(salary_percentile * 100, 1) as salary_pct,
    ROUND(experience_percentile * 100, 1) as exp_pct,
    ROUND(efficiency_percentile * 100, 1) as efficiency_pct,
    CASE 
        WHEN (salary_percentile >= 0.9 AND experience_percentile <= 0.3) 
        THEN '高薪低资历-需核实'
        WHEN (salary_percentile <= 0.1 AND experience_percentile >= 0.7) 
        THEN '低薪高资历-可能被低估'
        WHEN efficiency_percentile >= 0.95 
        THEN '薪资增长异常快'
        WHEN efficiency_percentile <= 0.05 
        THEN '薪资增长异常慢'
        ELSE '正常范围'
    END as anomaly_analysis
FROM anomaly_detection
WHERE (salary_percentile <= 0.1 OR salary_percentile >= 0.9)
   OR (efficiency_percentile <= 0.1 OR efficiency_percentile >= 0.9)
ORDER BY salary_percentile DESC;
```

---

## 8. 💼 统计分布函数应用场景


### 8.1 人力资源管理应用


**👥 HR分析场景**
```sql
-- 场景1：薪酬公平性分析
WITH pay_equity_analysis AS (
    SELECT 
        department,
        name,
        salary,
        PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) as dept_rank,
        CUME_DIST() OVER (PARTITION BY department ORDER BY salary) as dept_cume_dist,
        AVG(salary) OVER (PARTITION BY department) as dept_avg
    FROM employees
)
SELECT 
    department,
    name,
    salary,
    dept_avg,
    salary - dept_avg as salary_diff,
    ROUND(dept_rank * 100, 1) as dept_percentile,
    CASE 
        WHEN dept_rank >= 0.8 THEN '部门内高薪'
        WHEN dept_rank >= 0.6 THEN '部门内中上薪资'
        WHEN dept_rank >= 0.4 THEN '部门内中等薪资'
        WHEN dept_rank >= 0.2 THEN '部门内中下薪资'  
        ELSE '部门内低薪'
    END as salary_category,
    CASE 
        WHEN ABS(salary - dept_avg) > dept_avg * 0.3 THEN '薪资差异较大'
        ELSE '薪资差异正常'
    END as equity_status
FROM pay_equity_analysis
ORDER BY department, salary DESC;

-- 场景2：绩效评估与薪资匹配分析
SELECT 
    name,
    department,
    salary,
    NTILE(5) OVER (ORDER BY salary) as salary_quintile,
    CASE NTILE(5) OVER (ORDER BY salary)
        WHEN 1 THEN 'E级薪资'
        WHEN 2 THEN 'D级薪资'
        WHEN 3 THEN 'C级薪资'
        WHEN 4 THEN 'B级薪资'
        WHEN 5 THEN 'A级薪资'
    END as salary_grade,
    ROUND(PERCENT_RANK() OVER (ORDER BY salary) * 100, 0) as salary_percentile
FROM employees
ORDER BY salary DESC;
```

### 8.2 销售业绩分析应用


**📈 销售数据分析**
```sql
-- 创建销售业绩表进行演示
CREATE TEMPORARY TABLE sales_performance (
    salesperson VARCHAR(50),
    region VARCHAR(50),
    monthly_sales DECIMAL(12,2),
    quarter VARCHAR(10)
);

INSERT INTO sales_performance VALUES
('张销售', '华东', 150000, '2024Q1'),
('李销售', '华东', 180000, '2024Q1'),
('王销售', '华南', 120000, '2024Q1'),
('赵销售', '华南', 160000, '2024Q1'),
('钱销售', '华北', 200000, '2024Q1'),
('孙销售', '华北', 140000, '2024Q1');

-- 销售业绩分布分析
SELECT 
    salesperson,
    region,
    monthly_sales,
    PERCENT_RANK() OVER (ORDER BY monthly_sales) as overall_rank,
    PERCENT_RANK() OVER (PARTITION BY region ORDER BY monthly_sales) as region_rank,
    CUME_DIST() OVER (ORDER BY monthly_sales) as cumulative_dist,
    NTILE(3) OVER (ORDER BY monthly_sales) as performance_tier,
    CASE NTILE(3) OVER (ORDER BY monthly_sales)
        WHEN 1 THEN '待提升'
        WHEN 2 THEN '良好'
        WHEN 3 THEN '优秀'
    END as performance_level
FROM sales_performance
ORDER BY monthly_sales DESC;
```

### 8.3 财务风险分析应用


**💰 风险评估场景**
```sql
-- 模拟客户信用评分分析
CREATE TEMPORARY TABLE customer_credit (
    customer_id INT,
    customer_name VARCHAR(50),
    credit_score INT,
    loan_amount DECIMAL(12,2),
    industry VARCHAR(50)
);

INSERT INTO customer_credit VALUES
(1, '客户A', 780, 100000, '制造业'),
(2, '客户B', 720, 150000, '服务业'),
(3, '客户C', 650, 80000, '零售业'),
(4, '客户D', 800, 200000, '科技业'),
(5, '客户E', 600, 120000, '建筑业');

-- 信用风险分层分析
SELECT 
    customer_name,
    industry,
    credit_score,
    loan_amount,
    PERCENT_RANK() OVER (ORDER BY credit_score DESC) as credit_percentile,
    NTILE(5) OVER (ORDER BY credit_score DESC) as risk_tier,
    CASE NTILE(5) OVER (ORDER BY credit_score DESC)
        WHEN 1 THEN '极低风险'
        WHEN 2 THEN '低风险' 
        WHEN 3 THEN '中等风险'
        WHEN 4 THEN '较高风险'
        WHEN 5 THEN '高风险'
    END as risk_category,
    CASE 
        WHEN PERCENT_RANK() OVER (ORDER BY credit_score DESC) <= 0.2 THEN '拒绝放贷'
        WHEN PERCENT_RANK() OVER (ORDER BY credit_score DESC) <= 0.4 THEN '谨慎放贷'
        ELSE '可以放贷'
    END as loan_decision
FROM customer_credit
ORDER BY credit_score DESC;
```

### 8.4 学术成绩分析应用


**📚 教育数据分析**
```sql
-- 模拟学生成绩分析
CREATE TEMPORARY TABLE student_scores (
    student_name VARCHAR(50),
    subject VARCHAR(50),
    score INT,
    class VARCHAR(10)
);

INSERT INTO student_scores VALUES
('学生A', '数学', 95, '高三1班'),
('学生B', '数学', 88, '高三1班'),
('学生C', '数学', 76, '高三1班'),
('学生D', '数学', 92, '高三2班'),
('学生E', '数学', 84, '高三2班'),
('学生F', '数学', 79, '高三2班');

-- 成绩分布与排名分析
SELECT 
    student_name,
    class,
    score,
    RANK() OVER (ORDER BY score DESC) as overall_rank,
    RANK() OVER (PARTITION BY class ORDER BY score DESC) as class_rank,
    PERCENT_RANK() OVER (ORDER BY score DESC) as percentile_rank,
    ROUND(PERCENT_RANK() OVER (ORDER BY score DESC) * 100, 1) as percentile,
    CASE 
        WHEN PERCENT_RANK() OVER (ORDER BY score DESC) <= 0.1 THEN 'A+ 优秀'
        WHEN PERCENT_RANK() OVER (ORDER BY score DESC) <= 0.3 THEN 'A 良好'
        WHEN PERCENT_RANK() OVER (ORDER BY score DESC) <= 0.6 THEN 'B 中等'
        WHEN PERCENT_RANK() OVER (ORDER BY score DESC) <= 0.8 THEN 'C 及格'
        ELSE 'D 不及格'
    END as grade_level
FROM student_scores
ORDER BY score DESC;
```

---

## 9. 📈 数据分析统计方法


### 9.1 描述性统计综合分析


**📊 统计指标全面计算**
```sql
-- 综合描述性统计分析
WITH comprehensive_stats AS (
    SELECT 
        department,
        salary,
        COUNT(*) OVER (PARTITION BY department) as dept_count,
        AVG(salary) OVER (PARTITION BY department) as dept_mean,
        STDDEV(salary) OVER (PARTITION BY department) as dept_std,
        MIN(salary) OVER (PARTITION BY department) as dept_min,
        MAX(salary) OVER (PARTITION BY department) as dept_max
    FROM employees
),
percentile_stats AS (
    SELECT 
        department,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as Q1,
        PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary) as Q2_median,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) as Q3,
        PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY salary) as P5,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY salary) as P95
    FROM employees
    GROUP BY department
)
SELECT DISTINCT
    cs.department,
    cs.dept_count as sample_size,
    ROUND(cs.dept_mean, 0) as mean_salary,
    ROUND(ps.Q2_median, 0) as median_salary,
    ROUND(cs.dept_std, 0) as std_deviation,
    cs.dept_min as min_salary,
    cs.dept_max as max_salary,
    ROUND(ps.Q1, 0) as Q1_25th,
    ROUND(ps.Q3, 0) as Q3_75th,
    ROUND(ps.Q3 - ps.Q1, 0) as IQR,
    ROUND(ps.P5, 0) as P5_5th,
    ROUND(ps.P95, 0) as P95_95th,
    -- 变异系数
    ROUND(cs.dept_std / cs.dept_mean * 100, 1) as coefficient_variation,
    -- 偏度近似
    ROUND((cs.dept_mean - ps.Q2_median) / cs.dept_std, 3) as skewness_approx
FROM comprehensive_stats cs
JOIN percentile_stats ps ON cs.department = ps.department
ORDER BY cs.dept_mean DESC;
```

### 9.2 相关性分析方法


**🔗 变量关系分析**
```sql
-- 薪资与工作年限相关性分析
WITH correlation_data AS (
    SELECT 
        name,
        salary,
        DATEDIFF(CURDATE(), hire_date) / 365.25 as work_years,
        RANK() OVER (ORDER BY salary) as salary_rank,
        RANK() OVER (ORDER BY DATEDIFF(CURDATE(), hire_date) / 365.25) as years_rank
    FROM employees
),
rank_correlation AS (
    SELECT 
        COUNT(*) as n,
        SUM(salary_rank * years_rank) as sum_xy,
        SUM(salary_rank) as sum_x,
        SUM(years_rank) as sum_y,
        SUM(salary_rank * salary_rank) as sum_x2,
        SUM(years_rank * years_rank) as sum_y2
    FROM correlation_data
)
SELECT 
    n as sample_size,
    -- Spearman等级相关系数近似计算
    ROUND(
        (n * sum_xy - sum_x * sum_y) / 
        SQRT((n * sum_x2 - sum_x * sum_x) * (n * sum_y2 - sum_y * sum_y)), 
        3
    ) as spearman_correlation,
    CASE 
        WHEN ABS((n * sum_xy - sum_x * sum_y) / 
                SQRT((n * sum_x2 - sum_x * sum_x) * (n * sum_y2 - sum_y * sum_y))) >= 0.7 
        THEN '强相关'
        WHEN ABS((n * sum_xy - sum_x * sum_y) / 
                SQRT((n * sum_x2 - sum_x * sum_x) * (n * sum_y2 - sum_y * sum_y))) >= 0.3 
        THEN '中等相关'
        ELSE '弱相关或无关'
    END as correlation_strength
FROM rank_correlation;
```

### 9.3 趋势分析方法


**📈 时间序列趋势分析**
```sql
-- 按入职时间的薪资趋势分析
WITH hire_trend AS (
    SELECT 
        YEAR(hire_date) as hire_year,
        AVG(salary) as avg_salary,
        COUNT(*) as hire_count,
        STDDEV(salary) as salary_std
    FROM employees
    GROUP BY YEAR(hire_date)
),
trend_analysis AS (
    SELECT 
        hire_year,
        avg_salary,
        hire_count,
        salary_std,
        LAG(avg_salary) OVER (ORDER BY hire_year) as prev_year_salary,
        FIRST_VALUE(avg_salary) OVER (ORDER BY hire_year) as baseline_salary
    FROM hire_trend
)
SELECT 
    hire_year,
    ROUND(avg_salary, 0) as avg_salary,
    hire_count,
    ROUND(salary_std, 0) as salary_std,
    CASE 
        WHEN prev_year_salary IS NULL THEN 0
        ELSE ROUND((avg_salary - prev_year_salary) / prev_year_salary * 100, 1)
    END as year_over_year_growth,
    ROUND((avg_salary - baseline_salary) / baseline_salary * 100, 1) as cumulative_growth
FROM trend_analysis
ORDER BY hire_year;
```

### 9.4 预测分析基础


**🔮 基于历史数据的简单预测**
```sql
-- 基于分位数的薪资预测分析
WITH prediction_base AS (
    SELECT 
        department,
        DATEDIFF(CURDATE(), hire_date) / 365.25 as work_years,
        salary,
        NTILE(5) OVER (PARTITION BY department ORDER BY DATEDIFF(CURDATE(), hire_date) / 365.25) as experience_quintile
    FROM employees
),
experience_salary_model AS (
    SELECT 
        department,
        experience_quintile,
        AVG(work_years) as avg_years,
        AVG(salary) as avg_salary,
        STDDEV(salary) as salary_std,
        COUNT(*) as sample_count
    FROM prediction_base
    GROUP BY department, experience_quintile
)
SELECT 
    department,
    experience_quintile,
    ROUND(avg_years, 1) as avg_experience_years,
    ROUND(avg_salary, 0) as avg_salary,
    ROUND(salary_std, 0) as salary_std,
    sample_count,
    -- 简单线性趋势预测
    CASE 
        WHEN experience_quintile < 5 THEN 
            ROUND(avg_salary + (avg_salary * 0.1 * experience_quintile), 0)
        ELSE avg_salary
    END as predicted_next_tier_salary,
    ROUND(avg_salary - salary_std, 0) as salary_lower_bound,
    ROUND(avg_salary + salary_std, 0) as salary_upper_bound
FROM experience_salary_model
ORDER BY department, experience_quintile;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


**🔸 统计分布函数理解**
```
✓ CUME_DIST - 累积分布比例，小于等于当前值的数据占比
✓ PERCENT_RANK - 百分比排名，严格小于当前值的数据占比
✓ NTILE - 等份分组，将数据分成n个相等部分
✓ 分位数 - Q1(25%)、Q2(50%)、Q3(75%)等关键位置点
✓ 异常值检测 - 基于IQR和百分位数识别极端值
```

**🔸 函数差异理解**
```
CUME_DIST vs PERCENT_RANK：
- CUME_DIST：包含等于当前值的情况，最小值>0
- PERCENT_RANK：不包含等于当前值，最小值=0
- 最大值：两者都等于1

NTILE vs 百分位数：
- NTILE：将数据等分成n份，每份人数相等
- 百分位数：计算特定位置的数值，关注数值而非人数
```

### 10.2 实际应用技能


**💼 业务场景应用**
```sql
-- 核心应用模式
-- 1. 相对位置分析
SELECT 
    value_column,
    PERCENT_RANK() OVER (ORDER BY value_column) as percentile,
    CUME_DIST() OVER (ORDER BY value_column) as cumulative_dist
FROM table_name;

-- 2. 异常值检测
WITH bounds AS (
    SELECT 
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value_column) as Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value_column) as Q3
    FROM table_name
)
SELECT * FROM table_name, bounds
WHERE value_column < Q1 - 1.5*(Q3-Q1) 
   OR value_column > Q3 + 1.5*(Q3-Q1);

-- 3. 分层分析
SELECT 
    group_column,
    NTILE(4) OVER (PARTITION BY group_column ORDER BY value_column) as tier
FROM table_name;
```

### 10.3 性能优化要点


**⚡ 查询优化建议**
```
索引优化：
✓ 在ORDER BY字段上建立索引
✓ 在PARTITION BY字段上建立索引
✓ 考虑复合索引 (partition_col, order_col)

查询优化：
✓ 避免在大结果集上使用窗口函数
✓ 合理使用LIMIT限制结果数量
✓ 将复杂计算拆分成多个CTE
✓ 预先聚合数据减少计算量
```

### 10.4 常见错误避免


**⚠️ 注意事项**
```
数据质量：
❌ 忽略NULL值的影响
❌ 不考虑重复值的处理
❌ 数据分布假设错误

函数使用：
❌ 混淆CUME_DIST和PERCENT_RANK的含义
❌ NTILE分组数大于数据行数
❌ 异常值检测阈值设置不当

业务理解：
❌ 机械套用统计方法，不结合业务场景
❌ 过度依赖单一指标做判断
❌ 忽略数据的业务背景和时效性
```

### 10.5 扩展学习方向


**📚 进阶学习建议**
```
统计学基础：
- 概率分布理论（正态分布、偏态分布等）
- 假设检验方法
- 相关性分析和回归分析

高级SQL技能：
- 自定义聚合函数
- 递归查询应用
- JSON数据统计分析

数据科学应用：
- 机器学习特征工程
- 时间序列分析  
- A/B测试统计方法
```

**核心记忆**：
- 统计分布函数是理解数据相对位置的重要工具
- CUME_DIST关注"不超过"，PERCENT_RANK关注"严格小于"  
- 异常值检测要结合业务场景，不能机械套用统计方法
- 分位数分析是数据分布分析的基础，要熟练掌握各种计算方法
- 统计分析要与业务理解相结合，数据背后的业务逻辑更重要