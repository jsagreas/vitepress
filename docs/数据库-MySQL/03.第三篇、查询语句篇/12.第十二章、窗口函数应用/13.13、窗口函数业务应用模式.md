---
title: 13、窗口函数业务应用模式
---
## 📚 目录

1. [窗口函数业务应用概述](#1-窗口函数业务应用概述)
2. [销售分析排名应用](#2-销售分析排名应用)
3. [时序数据分析模式](#3-时序数据分析模式)
4. [同比环比分析实现](#4-同比环比分析实现)
5. [累积业务指标计算](#5-累积业务指标计算)
6. [移动平均分析方法](#6-移动平均分析方法)
7. [业务趋势分析应用](#7-业务趋势分析应用)
8. [客户行为分析场景](#8-客户行为分析场景)
9. [行业分析场景实现](#9-行业分析场景实现)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 窗口函数业务应用概述


### 1.1 什么是窗口函数的业务价值


**🔸 简单理解**
窗口函数就像一个**智能分析师**，它能在不改变数据行数的情况下，为每一行数据提供**上下文分析信息**。比如：这个销售员在所有销售员中排第几名？这个月的销售额比上个月增长了多少？

**🔸 传统分析vs窗口函数分析**
```
传统GROUP BY分析：
原始数据(1000行) → GROUP BY汇总 → 结果数据(10行)
问题：失去了明细信息

窗口函数分析：  
原始数据(1000行) → 窗口函数计算 → 结果数据(1000行+分析列)
优势：既有明细又有分析结果
```

### 1.2 业务应用分类体系


```
窗口函数业务应用分类：

排名分析类 ─────────┐
                  ├─── ROW_NUMBER(), RANK(), DENSE_RANK()
                  └─── 销售排名、客户排名、产品排名

聚合分析类 ─────────┐  
                  ├─── SUM(), AVG(), COUNT()
                  └─── 累积销售、移动平均、客户指标

偏移分析类 ─────────┐
                  ├─── LAG(), LEAD()  
                  └─── 同比环比、趋势分析、序列对比

分组分析类 ─────────┐
                  ├─── NTILE(), PERCENT_RANK()
                  └─── 客户分层、业绩分组、风险评级
```

---

## 2. 📈 销售分析排名应用


### 2.1 销售业绩排名分析


**🔸 业务需求**
销售经理需要知道：每个销售员在各个地区的排名情况，既要看总体排名，也要看地区内排名。

**🔥 全局排名 vs 分组排名**
```sql
-- 销售业绩综合排名分析
SELECT 
    sales_name,
    region,
    sale_amount,
    -- 全公司排名
    ROW_NUMBER() OVER (ORDER BY sale_amount DESC) AS global_rank,
    -- 地区内排名  
    ROW_NUMBER() OVER (PARTITION BY region ORDER BY sale_amount DESC) AS region_rank,
    -- 业绩占比
    ROUND(sale_amount / SUM(sale_amount) OVER() * 100, 2) AS global_percentage
FROM sales_data
WHERE sale_date >= '2024-01-01'
ORDER BY sale_amount DESC;
```

**📊 分析结果解读**：
```
┌─────────────┬──────────┬─────────────┬─────────────┬─────────────┬─────────────┐
│ sales_name  │  region  │ sale_amount │ global_rank │ region_rank │global_percent│
├─────────────┼──────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 张三        │ 华东      │   50000     │      1      │      1      │    15.5%    │
│ 李四        │ 华北      │   48000     │      2      │      1      │    14.9%    │ 
│ 王五        │ 华东      │   35000     │      3      │      2      │    10.8%    │
└─────────────┴──────────┴─────────────┴─────────────┴─────────────┴─────────────┘

业务洞察：
• 张三全公司排名第1，华东地区也是第1
• 李四虽然全公司第2，但在华北地区贡献占比更高
• 华东地区竞争更激烈
```

### 2.2 产品销售排名分析


**🔥 产品表现分级**
```sql
-- 产品销售表现多维分析
SELECT 
    product_category,
    region,
    SUM(sale_amount) AS total_sales,
    COUNT(*) AS order_count,
    -- 产品全国排名
    RANK() OVER (ORDER BY SUM(sale_amount) DESC) AS product_global_rank,
    -- 产品地区排名
    RANK() OVER (PARTITION BY region ORDER BY SUM(sale_amount) DESC) AS product_region_rank,
    -- 表现等级标记
    CASE 
        WHEN RANK() OVER (PARTITION BY region ORDER BY SUM(sale_amount) DESC) = 1 THEN '明星产品'
        WHEN RANK() OVER (PARTITION BY region ORDER BY SUM(sale_amount) DESC) <= 3 THEN '核心产品'  
        ELSE '普通产品'
    END AS product_level
FROM sales_data
WHERE sale_date >= '2024-01-01'
GROUP BY product_category, region
ORDER BY region, total_sales DESC;
```

---

## 3. ⏰ 时序数据分析模式


### 3.1 时间序列基础分析


**🔸 时序分析的核心思路**
时序分析就是**看数据随时间的变化规律**。窗口函数能帮我们轻松计算各种时间相关的指标。

**🔥 时序指标计算**
```sql
-- 时序分析核心指标
SELECT 
    sale_date,
    SUM(sale_amount) AS daily_total,
    -- 7天移动平均
    AVG(SUM(sale_amount)) OVER (
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS avg_7_days,
    -- 累积销售额
    SUM(SUM(sale_amount)) OVER (
        ORDER BY sale_date 
    ) AS cumulative_sales,
    -- 日环比增长率
    ROUND(
        (SUM(sale_amount) - LAG(SUM(sale_amount)) OVER (ORDER BY sale_date)) / 
        LAG(SUM(sale_amount)) OVER (ORDER BY sale_date) * 100, 2
    ) AS daily_change_rate
FROM sales_data
GROUP BY sale_date
ORDER BY sale_date DESC;
```

### 3.2 周期性规律分析


**🔸 识别业务周期规律**
```sql
-- 周内销售规律分析
SELECT 
    CASE DAYOFWEEK(sale_date)
        WHEN 1 THEN '周日' WHEN 2 THEN '周一' WHEN 3 THEN '周二'
        WHEN 4 THEN '周三' WHEN 5 THEN '周四' WHEN 6 THEN '周五'
        WHEN 7 THEN '周六'
    END AS weekday_name,
    AVG(daily_total) AS avg_daily_sales,
    -- 相对于周平均的表现
    ROUND(AVG(daily_total) / AVG(AVG(daily_total)) OVER() * 100, 2) AS relative_performance,
    -- 表现排名
    RANK() OVER (ORDER BY AVG(daily_total) DESC) AS performance_rank
FROM (
    SELECT sale_date, SUM(sale_amount) AS daily_total
    FROM sales_data GROUP BY sale_date
) daily_summary
GROUP BY DAYOFWEEK(sale_date)
ORDER BY DAYOFWEEK(sale_date);
```

### 3.3 异常值检测


**🔸 基于时序的异常检测**
```sql
-- 销售异常值检测
WITH daily_stats AS (
    SELECT 
        sale_date,
        SUM(sale_amount) AS daily_total,
        AVG(SUM(sale_amount)) OVER (
            ORDER BY sale_date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS moving_avg_30
    FROM sales_data
    GROUP BY sale_date
)
SELECT 
    sale_date,
    daily_total,
    ROUND(moving_avg_30, 2) AS avg_30_days,
    ROUND((daily_total - moving_avg_30) / moving_avg_30 * 100, 2) AS deviation_percent,
    -- 异常标记
    CASE 
        WHEN ABS((daily_total - moving_avg_30) / moving_avg_30) > 0.3 THEN '异常'
        WHEN ABS((daily_total - moving_avg_30) / moving_avg_30) > 0.2 THEN '需关注'
        ELSE '正常'
    END AS status
FROM daily_stats
ORDER BY sale_date DESC;
```

---

## 4. 📊 同比环比分析实现


### 4.1 环比分析模式


**🔸 什么是环比分析**
环比就是和**上一个时期**比较。比如这个月和上个月比，今天和昨天比。它能告诉我们业务的**短期变化趋势**。

**🔥 多维度环比分析**
```sql
-- 月度环比增长分析
SELECT 
    DATE_FORMAT(sale_date, '%Y-%m') AS month_key,
    SUM(sale_amount) AS monthly_sales,
    -- 上月销售额
    LAG(SUM(sale_amount)) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) AS prev_month_sales,
    -- 环比增长率
    ROUND(
        (SUM(sale_amount) - LAG(SUM(sale_amount)) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m'))) / 
        LAG(SUM(sale_amount)) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) * 100, 2
    ) AS mom_growth_rate,
    -- 增长趋势判断
    CASE 
        WHEN (SUM(sale_amount) - LAG(SUM(sale_amount)) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m'))) / 
             LAG(SUM(sale_amount)) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) > 0.1 THEN '快速增长'
        WHEN (SUM(sale_amount) - LAG(SUM(sale_amount)) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m'))) / 
             LAG(SUM(sale_amount)) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) > 0.05 THEN '稳定增长'
        ELSE '增长放缓'
    END AS growth_trend
FROM sales_data
GROUP BY DATE_FORMAT(sale_date, '%Y-%m')
ORDER BY month_key DESC;
```

### 4.2 同比分析模式


**🔸 什么是同比分析**
同比就是和**去年同期**比较。比如今年3月和去年3月比，能看出业务的**年度增长趋势**和季节性规律。

**🔥 年同比分析**
```sql
-- 同比增长分析
SELECT 
    DATE_FORMAT(sale_date, '%Y-%m') AS month_key,
    SUM(sale_amount) AS current_month_sales,
    -- 去年同月销售额
    LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) AS same_month_last_year,
    -- 同比增长率
    ROUND(
        (SUM(sale_amount) - LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m'))) / 
        LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) * 100, 2
    ) AS yoy_growth_rate,
    -- 增长状态评估
    CASE 
        WHEN LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) IS NULL THEN '新业务'
        WHEN (SUM(sale_amount) - LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m'))) / 
             LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) > 0.2 THEN '高速增长'
        WHEN (SUM(sale_amount) - LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m'))) / 
             LAG(SUM(sale_amount), 12) OVER (ORDER BY DATE_FORMAT(sale_date, '%Y-%m')) > 0 THEN '正增长'
        ELSE '负增长'
    END AS growth_status
FROM sales_data
GROUP BY DATE_FORMAT(sale_date, '%Y-%m')
ORDER BY month_key DESC;
```

---

## 5. 📈 累积业务指标计算


### 5.1 累积销售分析


**🔸 累积指标的业务价值**
累积指标能帮我们看到**业务的整体发展轨迹**，比如：年度销售目标完成了多少？客户生命周期价值如何？

**🔥 多维度累积计算**
```sql
-- 累积业务指标分析
SELECT 
    sale_date,
    SUM(sale_amount) AS daily_sales,
    -- 年度累积销售
    SUM(SUM(sale_amount)) OVER (
        PARTITION BY YEAR(sale_date) 
        ORDER BY sale_date
    ) AS ytd_sales,
    -- 月度累积销售
    SUM(SUM(sale_amount)) OVER (
        PARTITION BY DATE_FORMAT(sale_date, '%Y-%m')
        ORDER BY sale_date
    ) AS mtd_sales,
    -- 累积订单数
    SUM(COUNT(*)) OVER (
        PARTITION BY YEAR(sale_date)
        ORDER BY sale_date
    ) AS ytd_orders
FROM sales_data
WHERE YEAR(sale_date) = 2024
GROUP BY sale_date
ORDER BY sale_date DESC;
```

### 5.2 客户累积价值分析


**🔸 客户生命周期价值**
```sql
-- 客户累积价值分析
SELECT 
    customer_id,
    sale_date,
    sale_amount,
    -- 客户累积购买金额
    SUM(sale_amount) OVER (
        PARTITION BY customer_id 
        ORDER BY sale_date
    ) AS customer_lifetime_value,
    -- 客户购买次数
    ROW_NUMBER() OVER (
        PARTITION BY customer_id 
        ORDER BY sale_date
    ) AS purchase_sequence,
    -- 距离上次购买天数
    DATEDIFF(
        sale_date, 
        LAG(sale_date) OVER (PARTITION BY customer_id ORDER BY sale_date)
    ) AS days_since_last_purchase,
    -- 客户价值分层
    NTILE(5) OVER (ORDER BY SUM(sale_amount) OVER (PARTITION BY customer_id)) AS value_segment
FROM sales_data
ORDER BY customer_id, sale_date;
```

---

## 6. 📉 移动平均分析方法


### 6.1 移动平均基础概念


**🔸 什么是移动平均**
移动平均就像给数据**戴上平滑镜**，它能消除短期波动，让我们看清**真正的趋势**。

**🔥 多周期移动平均**
```sql
-- 销售趋势移动平均分析
SELECT 
    sale_date,
    SUM(sale_amount) AS daily_amount,
    -- 7日移动平均(周趋势)  
    ROUND(
        AVG(SUM(sale_amount)) OVER (
            ORDER BY sale_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ), 2
    ) AS ma_7_days,
    -- 30日移动平均(月趋势)
    ROUND(
        AVG(SUM(sale_amount)) OVER (
            ORDER BY sale_date  
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ), 2
    ) AS ma_30_days,
    -- 趋势信号判断
    CASE 
        WHEN SUM(sale_amount) > AVG(SUM(sale_amount)) OVER (
            ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) * 1.1 THEN '强势上涨'
        WHEN SUM(sale_amount) > AVG(SUM(sale_amount)) OVER (
            ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) THEN '温和上涨'
        ELSE '基本平稳'
    END AS trend_signal
FROM sales_data
GROUP BY sale_date
ORDER BY sale_date DESC;
```

### 6.2 移动平均交叉信号


**🔸 利用移动平均交叉判断趋势转折**
```sql
-- 移动平均交叉信号分析
WITH ma_signals AS (
    SELECT 
        sale_date,
        SUM(sale_amount) AS daily_sales,
        -- 短期移动平均(5日)
        AVG(SUM(sale_amount)) OVER (
            ORDER BY sale_date ROWS BETWEEN 4 PRECEDING AND CURRENT ROW  
        ) AS ma_5,
        -- 长期移动平均(20日)
        AVG(SUM(sale_amount)) OVER (
            ORDER BY sale_date ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS ma_20
    FROM sales_data
    GROUP BY sale_date
)
SELECT 
    sale_date,
    daily_sales,
    ROUND(ma_5, 2) AS ma_5_days,
    ROUND(ma_20, 2) AS ma_20_days,
    -- 交叉信号检测
    CASE 
        WHEN ma_5 > ma_20 AND LAG(ma_5) OVER (ORDER BY sale_date) <= LAG(ma_20) OVER (ORDER BY sale_date) 
        THEN '金叉-上升信号'
        WHEN ma_5 < ma_20 AND LAG(ma_5) OVER (ORDER BY sale_date) >= LAG(ma_20) OVER (ORDER BY sale_date)
        THEN '死叉-下降信号'  
        WHEN ma_5 > ma_20 THEN '多头排列'
        ELSE '空头排列'
    END AS signal_type
FROM ma_signals
WHERE ma_20 IS NOT NULL
ORDER BY sale_date DESC;
```

---

## 7. 📊 业务趋势分析应用


### 7.1 业务增长趋势识别


**🔸 趋势分析要回答的问题**
业务是在增长还是下滑？增长速度如何？什么时候可能出现转折点？

**🔥 增长趋势综合分析**
```sql
-- 业务增长趋势分析
WITH monthly_metrics AS (
    SELECT 
        DATE_FORMAT(sale_date, '%Y-%m') AS month_key,
        SUM(sale_amount) AS monthly_sales,
        COUNT(DISTINCT customer_id) AS active_customers,
        COUNT(*) AS total_orders
    FROM sales_data
    GROUP BY DATE_FORMAT(sale_date, '%Y-%m')
)
SELECT 
    month_key,
    monthly_sales,
    active_customers,
    total_orders,
    -- 环比增长率
    ROUND(
        (monthly_sales - LAG(monthly_sales) OVER (ORDER BY month_key)) / 
        LAG(monthly_sales) OVER (ORDER BY month_key) * 100, 2
    ) AS mom_growth_rate,
    -- 客户增长率
    ROUND(
        (active_customers - LAG(active_customers) OVER (ORDER BY month_key)) / 
        LAG(active_customers) OVER (ORDER BY month_key) * 100, 2
    ) AS customer_growth_rate,
    -- 综合发展阶段判断
    CASE 
        WHEN (monthly_sales - LAG(monthly_sales) OVER (ORDER BY month_key)) / 
             LAG(monthly_sales) OVER (ORDER BY month_key) > 0.1 AND
             (active_customers - LAG(active_customers) OVER (ORDER BY month_key)) / 
             LAG(active_customers) OVER (ORDER BY month_key) > 0.05 THEN '高速增长期'
        WHEN (monthly_sales - LAG(monthly_sales) OVER (ORDER BY month_key)) / 
             LAG(monthly_sales) OVER (ORDER BY month_key) > 0.05 THEN '稳定增长期'
        ELSE '平稳发展期'
    END AS business_phase
FROM monthly_metrics
ORDER BY month_key DESC;
```

### 7.2 产品生命周期分析


**🔸 产品发展阶段识别**
```sql
-- 产品生命周期分析
WITH product_trends AS (
    SELECT 
        product_category,
        DATE_FORMAT(sale_date, '%Y-%m') AS month_key,
        SUM(sale_amount) AS monthly_sales,
        COUNT(*) AS monthly_orders
    FROM sales_data
    GROUP BY product_category, DATE_FORMAT(sale_date, '%Y-%m')
)
SELECT 
    product_category,
    month_key,
    monthly_sales,
    -- 3个月环比增长率
    ROUND(
        (monthly_sales - LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key
        )) / LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key  
        ) * 100, 2
    ) AS quarterly_growth_rate,
    -- 市场份额
    ROUND(
        monthly_sales / SUM(monthly_sales) OVER (PARTITION BY month_key) * 100, 2
    ) AS market_share,
    -- 生命周期阶段判断
    CASE 
        WHEN (monthly_sales - LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key
        )) / LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key
        ) > 0.5 THEN '导入期'
        WHEN (monthly_sales - LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key
        )) / LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key
        ) > 0.2 THEN '成长期'  
        WHEN (monthly_sales - LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key
        )) / LAG(monthly_sales, 3) OVER (
            PARTITION BY product_category ORDER BY month_key
        ) BETWEEN -0.1 AND 0.2 THEN '成熟期'
        ELSE '衰退期'
    END AS lifecycle_stage
FROM product_trends
ORDER BY product_category, month_key DESC;
```

---

## 8. 🎯 客户行为分析场景


### 8.1 客户购买行为分析


**🔸 客户行为分析的价值**
通过分析客户的购买模式，我们能发现：哪些客户最有价值？客户的购买周期是什么？如何预防客户流失？

**🔥 客户行为基础分析**
```sql
-- 客户购买行为分析
SELECT 
    customer_id,
    sale_date,
    sale_amount,
    -- 客户购买次数序号
    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY sale_date) AS purchase_order,
    -- 客户累积消费
    SUM(sale_amount) OVER (
        PARTITION BY customer_id 
        ORDER BY sale_date
    ) AS cumulative_spending,
    -- 购买间隔天数
    DATEDIFF(
        sale_date,
        LAG(sale_date) OVER (PARTITION BY customer_id ORDER BY sale_date)
    ) AS days_between_purchases,
    -- 客户活跃度评估
    CASE 
        WHEN DATEDIFF(CURRENT_DATE, sale_date) <= 30 THEN '高活跃'
        WHEN DATEDIFF(CURRENT_DATE, sale_date) <= 90 THEN '中活跃'  
        WHEN DATEDIFF(CURRENT_DATE, sale_date) <= 180 THEN '低活跃'
        ELSE '流失风险'
    END AS activity_level
FROM sales_data
ORDER BY customer_id, sale_date;
```

### 8.2 客户流失风险分析


**🔸 流失预警模型**
```sql
-- 客户流失风险评估
WITH customer_metrics AS (
    SELECT 
        customer_id,
        COUNT(*) as total_orders,
        SUM(sale_amount) as total_spending,
        MAX(sale_date) as last_purchase_date,
        AVG(DATEDIFF(
            sale_date,
            LAG(sale_date) OVER (PARTITION BY customer_id ORDER BY sale_date)
        )) as avg_purchase_interval,
        DATEDIFF(CURRENT_DATE, MAX(sale_date)) as days_since_last_purchase
    FROM sales_data
    GROUP BY customer_id
)
SELECT 
    customer_id,
    total_orders,
    total_spending,
    last_purchase_date,
    days_since_last_purchase,
    ROUND(avg_purchase_interval, 0) as normal_interval,
    -- 流失风险评分
    CASE 
        WHEN days_since_last_purchase > avg_purchase_interval * 2 THEN '极高风险'
        WHEN days_since_last_purchase > avg_purchase_interval * 1.5 THEN '高风险'
        WHEN days_since_last_purchase > avg_purchase_interval THEN '中风险'  
        ELSE '健康'
    END as risk_level,
    -- 客户价值分层
    NTILE(5) OVER (ORDER BY total_spending DESC) as value_tier,
    -- 挽回策略建议
    CASE
        WHEN days_since_last_purchase > avg_purchase_interval * 2 AND total_spending > 10000 
        THEN '立即联系，专属优惠'
        WHEN days_since_last_purchase > avg_purchase_interval * 1.5 
        THEN '主动关怀，了解需求'
        ELSE '定期维护，保持联系'
    END as retention_strategy
FROM customer_metrics
WHERE avg_purchase_interval IS NOT NULL
ORDER BY (days_since_last_purchase / NULLIF(avg_purchase_interval, 0)) DESC;
```

### 8.3 客户购买周期分析


**🔸 购买周期模式识别**
```sql
-- 客户购买周期分析
WITH purchase_patterns AS (
    SELECT 
        customer_id,
        MONTH(sale_date) as purchase_month,
        DAYOFWEEK(sale_date) as purchase_weekday,
        COUNT(*) as purchase_count,
        AVG(sale_amount) as avg_monthly_spending
    FROM sales_data
    GROUP BY customer_id, MONTH(sale_date), DAYOFWEEK(sale_date)
)
SELECT 
    customer_id,
    purchase_month,
    CASE purchase_weekday
        WHEN 1 THEN '周日' WHEN 2 THEN '周一' WHEN 3 THEN '周二'
        WHEN 4 THEN '周三' WHEN 5 THEN '周四' WHEN 6 THEN '周五' 
        WHEN 7 THEN '周六'
    END as preferred_weekday,
    purchase_count,
    ROUND(avg_monthly_spending, 2) as avg_spending,
    -- 客户购买偏好排名
    RANK() OVER (
        PARTITION BY customer_id 
        ORDER BY purchase_count DESC
    ) AS preference_rank,
    -- 季节性购买标记
    CASE 
        WHEN purchase_month IN (3,4,5) THEN '春季偏好'
        WHEN purchase_month IN (6,7,8) THEN '夏季偏好'
        WHEN purchase_month IN (9,10,11) THEN '秋季偏好'
        WHEN purchase_month IN (12,1,2) THEN '冬季偏好'
    END as seasonal_preference
FROM purchase_patterns
WHERE purchase_count >= 2  -- 至少购买2次才有意义
ORDER BY customer_id, preference_rank;
```

---

## 9. 🏢 行业分析场景实现


### 9.1 电商行业分析模式


**🔸 电商核心指标分析**
```sql
-- 电商行业关键指标分析
WITH ecommerce_metrics AS (
    SELECT 
        DATE_FORMAT(sale_date, '%Y-%m') AS month_key,
        COUNT(DISTINCT customer_id) AS monthly_active_users,
        COUNT(*) AS total_orders,
        SUM(sale_amount) AS gmv,
        SUM(CASE WHEN customer_first_order = 1 THEN 1 ELSE 0 END) AS new_customers
    FROM (
        SELECT *,
            CASE WHEN ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY sale_date) = 1 
                 THEN 1 ELSE 0 END AS customer_first_order
        FROM sales_data
    ) marked_data
    GROUP BY DATE_FORMAT(sale_date, '%Y-%m')
)
SELECT 
    month_key,
    monthly_active_users,
    total_orders,
    gmv,
    new_customers,
    -- 客单价
    ROUND(gmv / total_orders, 2) AS avg_order_value,
    -- 用户月均消费
    ROUND(gmv / monthly_active_users, 2) AS arpu,
    -- 新客占比
    ROUND(new_customers / monthly_active_users * 100, 2) AS new_customer_rate,
    -- 复购率（简化计算）
    ROUND((total_orders - new_customers) / (monthly_active_users - new_customers) * 100, 2) AS repurchase_rate,
    -- 环比增长
    ROUND(
        (gmv - LAG(gmv) OVER (ORDER BY month_key)) / 
        LAG(gmv) OVER (ORDER BY month_key) * 100, 2
    ) AS gmv_growth_rate
FROM ecommerce_metrics
ORDER BY month_key DESC;
```

### 9.2 SaaS业务分析模式


**🔸 SaaS业务关键指标**
```sql
-- SaaS业务分析（基于订阅模式）
WITH saas_metrics AS (
    SELECT 
        DATE_FORMAT(subscription_start_date, '%Y-%m') AS month_key,
        customer_id,
        monthly_fee,
        subscription_start_date,
        subscription_end_date,
        -- 客户生命周期月数
        CASE 
            WHEN subscription_end_date IS NULL THEN 
                PERIOD_DIFF(DATE_FORMAT(CURRENT_DATE, '%Y%m'), DATE_FORMAT(subscription_start_date, '%Y%m'))
            ELSE 
                PERIOD_DIFF(DATE_FORMAT(subscription_end_date, '%Y%m'), DATE_FORMAT(subscription_start_date, '%Y%m'))
        END AS customer_lifecycle_months
    FROM subscription_data
),
monthly_analysis AS (
    SELECT 
        month_key,
        COUNT(*) AS new_customers,
        SUM(monthly_fee) AS monthly_recurring_revenue,
        AVG(monthly_fee) AS avg_monthly_fee
    FROM saas_metrics
    GROUP BY month_key
)
SELECT 
    month_key,
    new_customers,
    monthly_recurring_revenue AS mrr,
    ROUND(avg_monthly_fee, 2) AS avg_fee,
    -- 累积月度经常性收入
    SUM(monthly_recurring_revenue) OVER (ORDER BY month_key) AS cumulative_mrr,
    -- MRR增长率
    ROUND(
        (monthly_recurring_revenue - LAG(monthly_recurring_revenue) OVER (ORDER BY month_key)) / 
        LAG(monthly_recurring_revenue) OVER (ORDER BY month_key) * 100, 2
    ) AS mrr_growth_rate,
    -- 新客户贡献度
    ROUND(new_customers * avg_monthly_fee / monthly_recurring_revenue * 100, 2) AS new_customer_contribution
FROM monthly_analysis
ORDER BY month_key DESC;
```

### 9.3 零售行业分析模式


**🔸 零售业务核心分析**
```sql
-- 零售行业销售分析
WITH retail_analysis AS (
    SELECT 
        store_id,
        product_category,
        sale_date,
        SUM(sale_amount) AS daily_sales,
        SUM(quantity) AS daily_quantity,
        COUNT(DISTINCT customer_id) AS daily_customers
    FROM retail_sales_data
    GROUP BY store_id, product_category, sale_date
)
SELECT 
    store_id,
    product_category,
    sale_date,
    daily_sales,
    daily_quantity,
    daily_customers,
    -- 店铺内产品排名
    RANK() OVER (
        PARTITION BY store_id, sale_date 
        ORDER BY daily_sales DESC
    ) AS product_rank_in_store,
    -- 品类全网排名
    RANK() OVER (
        PARTITION BY product_category, sale_date 
        ORDER BY daily_sales DESC
    ) AS store_rank_in_category,
    -- 7日移动平均
    ROUND(
        AVG(daily_sales) OVER (
            PARTITION BY store_id, product_category
            ORDER BY sale_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ), 2
    ) AS sales_trend_7d,
    -- 同店同比增长
    ROUND(
        (daily_sales - LAG(daily_sales, 365) OVER (
            PARTITION BY store_id, product_category ORDER BY sale_date
        )) / LAG(daily_sales, 365) OVER (
            PARTITION BY store_id, product_category ORDER BY sale_date
        ) * 100, 2
    ) AS same_store_yoy_growth
FROM retail_analysis
ORDER BY store_id, product_category, sale_date DESC;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 窗口函数本质：在保留明细数据的同时进行分析计算
🔸 排名分析：ROW_NUMBER(), RANK(), DENSE_RANK()解决业务排序需求
🔸 时序分析：LAG(), LEAD()实现环比同比计算
🔸 累积分析：SUM() OVER()计算累积指标和运行总计
🔸 移动平均：AVG() OVER()消除波动，识别趋势
🔸 客户分析：NTILE(), PERCENT_RANK()实现客户分层
🔸 业务应用：结合具体行业特点设计分析模型
```

### 10.2 关键业务应用模式


**🔹 销售分析核心模式**
```
排名分析模式：
• 全局排名 vs 分组排名
• 静态排名 vs 动态排名变化
• 绝对值排名 vs 相对比例排名

趋势分析模式：  
• 短期趋势（日、周环比）
• 中期趋势（月、季环比）
• 长期趋势（年同比分析）
```

**🔹 客户分析核心模式**
```
价值分析模式：
• RFM模型：最近消费、消费频率、消费金额
• 生命周期价值：累积消费轨迹分析
• 行为预测：基于历史模式预测未来行为

风险分析模式：
• 流失风险：购买间隔异常检测
• 价值流失：高价值客户活跃度下降
• 行为变化：购买模式突然改变
```

### 10.3 实际应用指导原则


**🎯 分析设计原则**
```
业务导向：
✅ 从实际业务问题出发设计分析
✅ 分析结果要能指导具体行动
✅ 指标要能被业务人员理解

技术实现：
✅ 选择合适的窗口函数类型
✅ 合理设置窗口范围和分组
✅ 注意性能优化和索引设计

结果应用：
✅ 建立定期分析报表
✅ 设置异常预警机制  
✅ 形成闭环的决策支持体系
```

**🔹 常见应用场景总结**
- **电商平台**：用户行为分析、商品销售趋势、运营效果评估
- **SaaS业务**：客户留存分析、收入趋势预测、产品使用模式
- **零售连锁**：店铺业绩对比、商品动销分析、区域发展评估
- **金融服务**：风险评估模型、客户价值分析、业务增长监控

**🔹 窗口函数选择指南**
```
业务需求 → 窗口函数选择：

需要排名 → ROW_NUMBER(), RANK(), DENSE_RANK()
需要对比 → LAG(), LEAD() 
需要累积 → SUM() OVER(), COUNT() OVER()
需要平均 → AVG() OVER()
需要分层 → NTILE(), PERCENT_RANK()
需要占比 → 聚合函数 / SUM() OVER()
```

### 10.4 实施建议和注意事项


**💡 最佳实践建议**
- **从简单开始**：先掌握基础窗口函数，再组合使用
- **性能考虑**：大数据量时注意窗口范围，避免全表扫描
- **业务验证**：分析结果要与业务常识对比验证
- **持续优化**：根据使用反馈不断调整分析模型

**⚠️ 常见注意事项**
- **数据质量**：确保基础数据准确完整
- **时区处理**：跨时区业务要注意时间统一
- **空值处理**：妥善处理NULL值对计算的影响
- **边界情况**：注意月初月末、年初年末的特殊情况

**核心记忆要点**：
- 窗口函数让分析和明细并存，是业务分析的强大工具
- 排名、对比、累积、平均是四大核心分析模式  
- 不同行业有不同的关键指标和分析重点
- 技术实现要服务于业务决策，分析结果要可解释可行动