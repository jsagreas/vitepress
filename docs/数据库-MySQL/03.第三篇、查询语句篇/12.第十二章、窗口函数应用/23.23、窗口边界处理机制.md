---
title: 23、窗口边界处理机制
---
## 📚 目录

1. [窗口边界基础概念](#1-窗口边界基础概念)
2. [窗口边界定义精确性](#2-窗口边界定义精确性)
3. [边界溢出处理机制](#3-边界溢出处理机制)
4. [不完整窗口处理策略](#4-不完整窗口处理策略)
5. [边界条件异常分析](#5-边界条件异常分析)
6. [窗口范围验证方法](#6-窗口范围验证方法)
7. [边界性能优化技巧](#7-边界性能优化技巧)
8. [实际应用场景案例](#8-实际应用场景案例)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 窗口边界基础概念


### 1.1 什么是窗口边界


**🔸 窗口边界的本质**
```
窗口边界就像"观察窗口的边框"
作用：定义每一行计算时考虑哪些数据行
范围：从当前行向前向后延伸的数据范围
目标：精确控制窗口函数的计算范围
```

**💡 窗口边界的生活类比**
```
想象你在看电影：
🎬 电影院座位：每个座位就是数据行
👀 你的视野范围：就是窗口边界
🔍 看到的内容：就是参与计算的数据

边界定义：
- 向前看3排：ROWS 3 PRECEDING
- 向后看2排：ROWS 2 FOLLOWING  
- 当前排：CURRENT ROW
- 从开始到现在：UNBOUNDED PRECEDING
```

### 1.2 窗口边界的语法结构


**📋 基本语法框架**
```sql
SELECT 
  column,
  窗口函数() OVER (
    PARTITION BY 分组字段
    ORDER BY 排序字段
    ROWS/RANGE BETWEEN 起始边界 AND 结束边界
  )
FROM table;

边界关键字说明：
ROWS：基于行数的物理边界
RANGE：基于值的逻辑边界
PRECEDING：向前（上方行）
FOLLOWING：向后（下方行）  
CURRENT ROW：当前行
UNBOUNDED：无限制边界
```

### 1.3 边界类型对比


**⚖️ ROWS vs RANGE 的区别**
```
ROWS（行边界）：按照行的物理位置计算
示例数据：
score: 85, 90, 90, 95, 100

ROWS 1 PRECEDING AND CURRENT ROW：
行1(85): [85]           - 只有当前行
行2(90): [85,90]        - 前1行+当前行
行3(90): [90,90]        - 前1行+当前行  
行4(95): [90,95]        - 前1行+当前行

RANGE（值边界）：按照排序字段的值范围计算
RANGE 5 PRECEDING AND CURRENT ROW：
行1(85): [85]           - 值范围 [80,85]
行2(90): [85,90]        - 值范围 [85,90]
行3(90): [85,90,90]     - 值范围 [85,90]，包含相同值
行4(95): [90,90,95]     - 值范围 [90,95]
```

---

## 2. 🎯 窗口边界定义精确性


### 2.1 精确边界定义语法


**🔍 完整边界定义语法**
```sql
-- 基本边界定义格式
ROWS BETWEEN start_boundary AND end_boundary

-- 边界值类型
UNBOUNDED PRECEDING    -- 从分区开始到当前行
n PRECEDING           -- 当前行前n行
CURRENT ROW           -- 当前行
n FOLLOWING           -- 当前行后n行  
UNBOUNDED FOLLOWING   -- 从当前行到分区结束

-- 简化语法（省略BETWEEN）
ROWS n PRECEDING      -- 等价于 ROWS BETWEEN n PRECEDING AND CURRENT ROW
```

**💻 精确边界定义示例**
```sql
-- 创建销售数据表
CREATE TABLE daily_sales (
  sale_date DATE,
  amount DECIMAL(10,2),
  region VARCHAR(20)
);

INSERT INTO daily_sales VALUES
('2025-01-01', 1000, '北京'), ('2025-01-02', 1200, '北京'),
('2025-01-03', 800, '北京'),  ('2025-01-04', 1500, '北京'),
('2025-01-05', 900, '北京');

-- 不同边界定义的效果对比
SELECT 
  sale_date,
  amount,
  -- 前2天+当前天的移动平均
  AVG(amount) OVER (
    ORDER BY sale_date 
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  ) as avg_3days,
  
  -- 前1天+当前天+后1天的移动平均
  AVG(amount) OVER (
    ORDER BY sale_date 
    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
  ) as avg_centered,
  
  -- 从开始到当前的累计平均
  AVG(amount) OVER (
    ORDER BY sale_date 
    ROWS UNBOUNDED PRECEDING
  ) as avg_cumulative
FROM daily_sales
ORDER BY sale_date;
```

### 2.2 边界精确性的重要性


**🔸 边界定义对结果的影响**
```
以移动平均为例：

数据：[100, 200, 300, 400, 500]

ROWS 1 PRECEDING AND CURRENT ROW（2天移动平均）：
第1天：AVG(100) = 100
第2天：AVG(100,200) = 150  
第3天：AVG(200,300) = 250
第4天：AVG(300,400) = 350
第5天：AVG(400,500) = 450

ROWS 2 PRECEDING AND CURRENT ROW（3天移动平均）：
第1天：AVG(100) = 100
第2天：AVG(100,200) = 150
第3天：AVG(100,200,300) = 200
第4天：AVG(200,300,400) = 300
第5天：AVG(300,400,500) = 400

可见边界定义直接影响计算结果！
```

**⚡ 实际业务影响**
```sql
-- 股票价格移动平均线
SELECT 
  trade_date,
  close_price,
  -- 5日均线
  AVG(close_price) OVER (
    ORDER BY trade_date 
    ROWS 4 PRECEDING
  ) as ma5,
  -- 20日均线  
  AVG(close_price) OVER (
    ORDER BY trade_date 
    ROWS 19 PRECEDING
  ) as ma20
FROM stock_prices
WHERE stock_code = '000001'
ORDER BY trade_date;

-- 边界精确性直接影响投资决策！
```

### 2.3 RANGE边界的精确计算


**🔢 RANGE边界值计算**
```sql
-- RANGE边界基于排序字段的值
SELECT 
  sale_date,
  amount,
  -- 金额相差100以内的行参与计算
  COUNT(*) OVER (
    ORDER BY amount 
    RANGE BETWEEN 100 PRECEDING AND 100 FOLLOWING
  ) as similar_amount_count,
  
  -- 时间相差3天以内的行参与计算  
  AVG(amount) OVER (
    ORDER BY sale_date 
    RANGE BETWEEN INTERVAL 3 DAY PRECEDING AND INTERVAL 3 DAY FOLLOWING
  ) as weekly_avg
FROM daily_sales
ORDER BY sale_date;

-- RANGE边界处理相同值
SELECT 
  student_name,
  score,
  -- 相同分数的学生都会包含在窗口中
  COUNT(*) OVER (
    ORDER BY score 
    RANGE CURRENT ROW  -- 等价于相同值的所有行
  ) as same_score_count
FROM exam_results
ORDER BY score;
```

---

## 3. 🚫 边界溢出处理机制


### 3.1 边界溢出的定义


**🔸 什么是边界溢出**
```
边界溢出就像"看电影时座位不够"
情况1：向前看超出了第一排（数据开始）
情况2：向后看超出了最后一排（数据结束）
处理：MySQL自动调整到实际可用范围

不会报错，而是智能调整边界范围
```

**💡 边界溢出的处理逻辑**
```
处理原则：
1. 向前溢出：自动调整到分区的第一行
2. 向后溢出：自动调整到分区的最后一行
3. 不影响计算：使用实际可用的行数计算
4. 保持一致：相同情况下处理方式一致

MySQL的智能处理：
- 要求前5行，但只有3行 → 使用这3行
- 要求后5行，但只剩2行 → 使用这2行
- 窗口函数正常工作，不会报错
```

### 3.2 前向边界溢出处理


**💻 前向溢出实例**
```sql
-- 测试前向边界溢出
SELECT 
  sale_date,
  amount,
  -- 要求前3天数据，但前面行数不足
  COUNT(*) OVER (
    ORDER BY sale_date 
    ROWS 3 PRECEDING
  ) as count_with_overflow,
  
  AVG(amount) OVER (
    ORDER BY sale_date 
    ROWS 3 PRECEDING  
  ) as avg_with_overflow,
  
  -- 实际参与计算的行数
  ROW_NUMBER() OVER (ORDER BY sale_date) as row_num
FROM daily_sales
ORDER BY sale_date
LIMIT 5;

/* 结果分析：
第1行：要求前3行，实际只有1行参与计算
第2行：要求前3行，实际只有2行参与计算  
第3行：要求前3行，实际只有3行参与计算
第4行：要求前3行，实际有4行参与计算
第5行：要求前3行，实际有4行参与计算（前3+当前1）
*/
```

### 3.3 后向边界溢出处理


**💻 后向溢出实例**
```sql
-- 测试后向边界溢出
SELECT 
  sale_date,
  amount,
  -- 要求后2天数据，但后面行数可能不足
  COUNT(*) OVER (
    ORDER BY sale_date 
    ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
  ) as count_future,
  
  AVG(amount) OVER (
    ORDER BY sale_date 
    ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
  ) as avg_future,
  
  -- 显示总行数便于理解
  COUNT(*) OVER () as total_rows,
  ROW_NUMBER() OVER (ORDER BY sale_date) as current_row
FROM daily_sales
ORDER BY sale_date;

/* 边界溢出处理：
倒数第3行：当前+后2行 = 3行参与计算
倒数第2行：当前+后1行 = 2行参与计算（溢出调整）
最后1行：只有当前行 = 1行参与计算（溢出调整）
*/
```

### 3.4 分区边界溢出


**🔄 分区内边界处理**
```sql
-- 按地区分区的边界溢出
SELECT 
  region,
  sale_date,
  amount,
  -- 每个地区内部的3日移动平均
  AVG(amount) OVER (
    PARTITION BY region 
    ORDER BY sale_date 
    ROWS 2 PRECEDING
  ) as regional_3day_avg,
  
  -- 显示分区内的行号
  ROW_NUMBER() OVER (PARTITION BY region ORDER BY sale_date) as regional_row_num
FROM daily_sales
ORDER BY region, sale_date;

/* 分区边界特点：
每个分区（地区）独立处理边界溢出
北京分区的第1行只计算北京的数据，不会跨越到上海分区
边界溢出处理在每个分区内独立进行
*/
```

---

## 4. ⚠️ 不完整窗口处理策略


### 4.1 不完整窗口的识别


**🔸 什么是不完整窗口**
```
不完整窗口就像"拼图缺了几块"
原因：边界要求的行数超过实际可用行数
表现：窗口函数使用的行数少于期望行数
影响：可能导致计算结果不符合预期

常见场景：
• 数据序列的开始几行（前向不足）
• 数据序列的结束几行（后向不足）
• 分区内数据量不足
• 有NULL值或缺失数据
```

### 4.2 不完整窗口的检测


**🔍 检测不完整窗口**
```sql
-- 检测窗口完整性的方法
SELECT 
  sale_date,
  amount,
  -- 期望的窗口大小
  3 as expected_window_size,
  
  -- 实际窗口大小
  COUNT(*) OVER (
    ORDER BY sale_date 
    ROWS 2 PRECEDING
  ) as actual_window_size,
  
  -- 窗口完整性标识
  CASE 
    WHEN COUNT(*) OVER (ORDER BY sale_date ROWS 2 PRECEDING) = 3 
    THEN '完整窗口' 
    ELSE '不完整窗口' 
  END as window_status,
  
  -- 移动平均值
  AVG(amount) OVER (
    ORDER BY sale_date 
    ROWS 2 PRECEDING
  ) as moving_avg
FROM daily_sales
ORDER BY sale_date;
```

### 4.3 不完整窗口的处理策略


**🛠️ 策略1：忽略不完整窗口**
```sql
-- 只显示完整窗口的结果
SELECT 
  sale_date,
  amount,
  moving_avg
FROM (
  SELECT 
    sale_date,
    amount,
    AVG(amount) OVER (ORDER BY sale_date ROWS 2 PRECEDING) as moving_avg,
    COUNT(*) OVER (ORDER BY sale_date ROWS 2 PRECEDING) as window_size
  FROM daily_sales
) t
WHERE window_size = 3  -- 只保留完整的3日移动平均
ORDER BY sale_date;
```

**🛠️ 策略2：使用条件函数处理**
```sql
-- 区分完整和不完整窗口的计算
SELECT 
  sale_date,
  amount,
  CASE 
    WHEN COUNT(*) OVER (ORDER BY sale_date ROWS 2 PRECEDING) = 3 
    THEN AVG(amount) OVER (ORDER BY sale_date ROWS 2 PRECEDING)
    ELSE NULL  -- 不完整窗口返回NULL
  END as reliable_moving_avg,
  
  -- 始终计算，但标记可靠性
  AVG(amount) OVER (ORDER BY sale_date ROWS 2 PRECEDING) as all_moving_avg,
  CONCAT(
    COUNT(*) OVER (ORDER BY sale_date ROWS 2 PRECEDING), 
    '天平均'
  ) as avg_description
FROM daily_sales
ORDER BY sale_date;
```

### 4.4 分区不完整窗口处理


**🔄 分区内窗口完整性**
```sql
-- 各地区销售的7日移动平均
SELECT 
  region,
  sale_date,
  amount,
  -- 分区内的移动平均
  AVG(amount) OVER (
    PARTITION BY region 
    ORDER BY sale_date 
    ROWS 6 PRECEDING
  ) as weekly_avg,
  
  -- 分区内窗口大小检查
  COUNT(*) OVER (
    PARTITION BY region 
    ORDER BY sale_date 
    ROWS 6 PRECEDING
  ) as window_size,
  
  -- 分区内数据量
  COUNT(*) OVER (PARTITION BY region) as total_days_in_region
FROM daily_sales
ORDER BY region, sale_date;

-- 只显示有足够数据的地区
SELECT * FROM (上述查询) t 
WHERE total_days_in_region >= 7;  -- 至少有7天数据的地区
```

---

## 5. 🚨 边界条件异常分析


### 5.1 常见边界异常情况


**⚠️ 异常情况类型**
```
NULL值处理异常：
- 问题：排序字段包含NULL值
- 影响：可能导致边界计算错误
- 解决：使用COALESCE或WHERE过滤

数据类型不匹配：
- 问题：RANGE边界用于不支持的数据类型
- 影响：语法错误或计算异常
- 解决：确保排序字段支持范围计算

分区数据不足：
- 问题：某些分区数据量过少
- 影响：窗口始终不完整
- 解决：合并分区或调整窗口大小
```

**💻 NULL值处理示例**
```sql
-- 包含NULL值的数据
INSERT INTO daily_sales VALUES 
('2025-01-06', NULL, '北京'), 
('2025-01-07', 1100, '北京');

-- 错误的处理方式（可能产生意外结果）
SELECT 
  sale_date,
  amount,
  AVG(amount) OVER (ORDER BY sale_date ROWS 2 PRECEDING) as wrong_avg
FROM daily_sales;

-- 正确的处理方式
SELECT 
  sale_date,
  amount,
  AVG(amount) OVER (
    ORDER BY sale_date 
    ROWS 2 PRECEDING
  ) as avg_including_null,
  
  -- 排除NULL值的移动平均
  AVG(CASE WHEN amount IS NOT NULL THEN amount END) OVER (
    ORDER BY sale_date 
    ROWS 2 PRECEDING
  ) as avg_excluding_null
FROM daily_sales
WHERE amount IS NOT NULL  -- 或者在这里过滤NULL
ORDER BY sale_date;
```

### 5.2 数据类型边界异常


**🔧 RANGE边界类型限制**
```sql
-- 支持RANGE的数据类型
SELECT 
  student_id,
  score,
  -- 数值类型：支持RANGE
  COUNT(*) OVER (
    ORDER BY score 
    RANGE 10 PRECEDING  -- 分数相差10分以内
  ) as similar_scores
FROM exam_results;

-- 日期类型：支持RANGE
SELECT 
  order_date,
  amount,
  SUM(amount) OVER (
    ORDER BY order_date 
    RANGE BETWEEN INTERVAL 7 DAY PRECEDING AND CURRENT ROW
  ) as weekly_total
FROM orders;

-- 字符串类型：不直接支持RANGE（会报错）
-- 解决方案：转换为数值或使用ROWS
SELECT 
  product_name,
  price,
  AVG(price) OVER (
    ORDER BY LENGTH(product_name)  -- 按名称长度排序
    RANGE 2 PRECEDING
  ) as avg_by_name_length
FROM products;
```

### 5.3 边界异常的调试方法


**🔍 边界异常诊断**
```sql
-- 边界异常诊断查询
SELECT 
  sale_date,
  amount,
  -- 窗口边界调试信息
  FIRST_VALUE(sale_date) OVER w as window_start,
  LAST_VALUE(sale_date) OVER w as window_end,
  COUNT(*) OVER w as window_size,
  
  -- 期望的窗口信息
  DATE_SUB(sale_date, INTERVAL 3 DAY) as expected_start,
  sale_date as expected_end,
  4 as expected_size,
  
  -- 异常检测
  CASE 
    WHEN COUNT(*) OVER w < 4 THEN '窗口不完整'
    WHEN FIRST_VALUE(sale_date) OVER w > DATE_SUB(sale_date, INTERVAL 3 DAY) THEN '前向边界溢出'
    ELSE '窗口正常'
  END as boundary_status
FROM daily_sales
WINDOW w AS (
  ORDER BY sale_date 
  RANGE BETWEEN INTERVAL 3 DAY PRECEDING AND CURRENT ROW
)
ORDER BY sale_date;
```

---

## 6. ✔️ 窗口范围验证方法


### 6.1 窗口范围有效性验证


**🔍 验证窗口定义合理性**
```sql
-- 验证窗口定义的有效性
SELECT 
  '边界定义检查' as check_type,
  -- 检查1：窗口大小是否合理
  CASE 
    WHEN (SELECT COUNT(*) FROM daily_sales) < 7 
    THEN '数据量不足，无法计算7日移动平均'
    ELSE '数据量充足'
  END as data_sufficiency,
  
  -- 检查2：分区数据分布
  (SELECT COUNT(DISTINCT region) FROM daily_sales) as partition_count,
  (SELECT MIN(cnt) FROM (
    SELECT COUNT(*) as cnt FROM daily_sales GROUP BY region
  ) t) as min_partition_size;

-- 分区数据充足性检查
SELECT 
  region,
  COUNT(*) as days_count,
  CASE 
    WHEN COUNT(*) >= 7 THEN '可计算7日均线'
    WHEN COUNT(*) >= 3 THEN '可计算3日均线'
    ELSE '数据不足'
  END as analysis_capability
FROM daily_sales
GROUP BY region;
```

### 6.2 动态边界范围调整


**⚡ 自适应边界大小**
```sql
-- 根据数据量动态调整窗口大小
SELECT 
  sale_date,
  amount,
  region,
  -- 自适应窗口大小
  AVG(amount) OVER (
    PARTITION BY region 
    ORDER BY sale_date 
    ROWS BETWEEN 
      CASE 
        WHEN COUNT(*) OVER (PARTITION BY region) >= 7 THEN 6
        WHEN COUNT(*) OVER (PARTITION BY region) >= 3 THEN 2  
        ELSE 0
      END PRECEDING 
      AND CURRENT ROW
  ) as adaptive_avg,
  
  -- 窗口大小说明
  CASE 
    WHEN COUNT(*) OVER (PARTITION BY region) >= 7 THEN '7日均线'
    WHEN COUNT(*) OVER (PARTITION BY region) >= 3 THEN '3日均线'
    ELSE '当日值'
  END as avg_type
FROM daily_sales
ORDER BY region, sale_date;
```

### 6.3 边界合理性验证函数


**🛡️ 自定义验证机制**
```sql
-- 创建边界验证存储函数
DELIMITER //
CREATE FUNCTION validate_window_boundary(
  table_name VARCHAR(64),
  partition_col VARCHAR(64), 
  order_col VARCHAR(64),
  window_size INT
) RETURNS VARCHAR(200)
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE min_partition_size INT DEFAULT 0;
  DECLARE result VARCHAR(200);
  
  -- 动态SQL检查（简化示例）
  IF window_size <= 0 THEN
    SET result = '窗口大小必须大于0';
  ELSE
    SET result = '边界定义有效';
  END IF;
  
  RETURN result;
END //
DELIMITER ;

-- 使用验证函数
SELECT validate_window_boundary('daily_sales', 'region', 'sale_date', 7) as validation;
```

---

## 7. 🚀 边界性能优化技巧


### 7.1 窗口边界性能影响因素


**📊 性能影响分析**
```
影响窗口边界性能的因素：

窗口大小：
• 小窗口（1-10行）：性能最佳 ⭐⭐⭐⭐⭐
• 中等窗口（10-100行）：性能良好 ⭐⭐⭐⭐☆
• 大窗口（100-1000行）：性能一般 ⭐⭐⭐☆☆
• 超大窗口（1000+行）：性能较差 ⭐⭐☆☆☆

边界类型：
• ROWS：物理边界，性能更好
• RANGE：逻辑边界，需要值比较，稍慢

数据量：
• 小数据集（<1万行）：边界影响微小
• 大数据集（>10万行）：边界选择很重要

索引支持：
• 有序索引：大幅提升RANGE性能
• 无索引：RANGE性能下降明显
```

### 7.2 边界优化策略


**⚡ 策略1：选择合适的边界类型**
```sql
-- 性能对比：ROWS vs RANGE
-- 场景：计算最近7天销售平均

-- 方案A：使用ROWS（推荐，性能更好）
SELECT 
  sale_date,
  AVG(amount) OVER (ORDER BY sale_date ROWS 6 PRECEDING) as avg_rows
FROM daily_sales;

-- 方案B：使用RANGE（逻辑更准确，但性能稍差）
SELECT 
  sale_date,
  AVG(amount) OVER (
    ORDER BY sale_date 
    RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW
  ) as avg_range
FROM daily_sales;

-- 选择建议：
-- 如果数据按日期连续无缺失 → 用ROWS
-- 如果数据可能有日期缺失 → 用RANGE
```

**⚡ 策略2：优化大窗口计算**
```sql
-- 大窗口优化：使用累计值减去历史值
SELECT 
  sale_date,
  amount,
  -- 传统方法：直接计算30日移动总和（性能差）
  SUM(amount) OVER (ORDER BY sale_date ROWS 29 PRECEDING) as sum_30days_slow,
  
  -- 优化方法：累计值差值计算（性能好）
  SUM(amount) OVER (ORDER BY sale_date) - 
  COALESCE(
    LAG(SUM(amount) OVER (ORDER BY sale_date), 30) OVER (ORDER BY sale_date),
    0
  ) as sum_30days_fast
FROM daily_sales
ORDER BY sale_date;
```

### 7.3 索引优化边界性能


**🎯 边界计算索引策略**
```sql
-- 为RANGE边界创建合适的索引
CREATE TABLE optimized_sales (
  id INT AUTO_INCREMENT PRIMARY KEY,
  region VARCHAR(20),
  sale_date DATE,
  amount DECIMAL(10,2),
  
  -- 关键索引：支持分区和排序
  INDEX idx_region_date (region, sale_date),
  INDEX idx_date_amount (sale_date, amount)
);

-- 利用索引的高效查询
SELECT 
  region,
  sale_date,
  amount,
  -- 这个查询会利用idx_region_date索引
  AVG(amount) OVER (
    PARTITION BY region 
    ORDER BY sale_date 
    ROWS 6 PRECEDING
  ) as weekly_avg
FROM optimized_sales
WHERE sale_date >= '2025-01-01'
ORDER BY region, sale_date;
```

### 7.4 内存使用优化


**💾 大数据集边界优化**
```sql
-- 大数据集的分批处理策略
-- 避免一次性处理过多数据
SELECT 
  batch_id,
  sale_date,
  amount,
  AVG(amount) OVER (
    PARTITION BY batch_id 
    ORDER BY sale_date 
    ROWS 6 PRECEDING
  ) as batch_avg
FROM (
  SELECT 
    *,
    -- 将数据分批处理
    NTILE(10) OVER (ORDER BY sale_date) as batch_id
  FROM large_sales_table
  WHERE sale_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
) batched_data
ORDER BY batch_id, sale_date;
```

---

## 8. 💼 实际应用场景案例


### 8.1 金融数据分析场景


**📈 股票技术指标计算**
```sql
-- 股票技术分析中的边界处理
CREATE TABLE stock_daily (
  stock_code VARCHAR(10),
  trade_date DATE,
  close_price DECIMAL(8,2),
  volume BIGINT
);

-- 计算移动平均线（处理不完整窗口）
SELECT 
  stock_code,
  trade_date,
  close_price,
  -- 5日均线（标记完整性）
  CASE 
    WHEN COUNT(*) OVER (
      PARTITION BY stock_code 
      ORDER BY trade_date 
      ROWS 4 PRECEDING
    ) = 5 
    THEN AVG(close_price) OVER (
      PARTITION BY stock_code 
      ORDER BY trade_date 
      ROWS 4 PRECEDING
    )
    ELSE NULL 
  END as ma5,
  
  -- 成交量移动平均
  AVG(volume) OVER (
    PARTITION BY stock_code 
    ORDER BY trade_date 
    ROWS 4 PRECEDING
  ) as volume_ma5,
  
  -- 数据完整性标识
  CONCAT(
    COUNT(*) OVER (
      PARTITION BY stock_code 
      ORDER BY trade_date 
      ROWS 4 PRECEDING
    ), 
    '/5天'
  ) as data_completeness
FROM stock_daily
WHERE stock_code = '000001'
ORDER BY trade_date DESC
LIMIT 20;
```

### 8.2 用户行为分析场景


**👤 用户活跃度分析**
```sql
-- 用户登录行为分析
CREATE TABLE user_logins (
  user_id INT,
  login_date DATE,
  session_duration INT  -- 分钟
);

-- 用户活跃度趋势分析（边界处理）
SELECT 
  user_id,
  login_date,
  session_duration,
  -- 最近7天平均会话时长
  AVG(session_duration) OVER (
    PARTITION BY user_id 
    ORDER BY login_date 
    RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW
  ) as avg_7day_session,
  
  -- 最近7天登录频率
  COUNT(*) OVER (
    PARTITION BY user_id 
    ORDER BY login_date 
    RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW  
  ) as login_frequency_7days,
  
  -- 活跃度评级（考虑边界完整性）
  CASE 
    WHEN COUNT(*) OVER (
      PARTITION BY user_id 
      ORDER BY login_date 
      RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW
    ) >= 7 THEN '高活跃'
    WHEN COUNT(*) OVER (
      PARTITION BY user_id 
      ORDER BY login_date 
      RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW
    ) >= 3 THEN '中活跃'
    ELSE '低活跃'
  END as activity_level
FROM user_logins
WHERE user_id = 1001
ORDER BY login_date DESC;
```

### 8.3 销售报表场景


**💰 销售趋势分析**
```sql
-- 销售同比环比分析
SELECT 
  sale_month,
  monthly_sales,
  -- 环比增长（处理边界不足）
  CASE 
    WHEN LAG(monthly_sales) OVER (ORDER BY sale_month) IS NOT NULL
    THEN ROUND(
      (monthly_sales - LAG(monthly_sales) OVER (ORDER BY sale_month)) / 
      LAG(monthly_sales) OVER (ORDER BY sale_month) * 100, 
      2
    )
    ELSE NULL
  END as mom_growth_rate,
  
  -- 3个月移动平均（边界标记）
  AVG(monthly_sales) OVER (
    ORDER BY sale_month 
    ROWS 2 PRECEDING
  ) as ma3_sales,
  
  COUNT(*) OVER (
    ORDER BY sale_month 
    ROWS 2 PRECEDING
  ) as ma3_data_points,
  
  -- 趋势判断（考虑数据完整性）
  CASE 
    WHEN COUNT(*) OVER (ORDER BY sale_month ROWS 2 PRECEDING) = 3 THEN
      CASE 
        WHEN monthly_sales > AVG(monthly_sales) OVER (ORDER BY sale_month ROWS 2 PRECEDING) 
        THEN '上升趋势'
        ELSE '下降趋势'
      END
    ELSE '数据不足'
  END as trend_direction
FROM monthly_sales_summary
ORDER BY sale_month;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


**🔸 窗口边界基础理解**
```
边界定义语法：
• ROWS：基于行数的物理边界（性能更好）
• RANGE：基于值的逻辑边界（逻辑更准确）
• PRECEDING：向前（上方行）
• FOLLOWING：向后（下方行）
• CURRENT ROW：当前行
• UNBOUNDED：无限制边界

边界组合规则：
• BETWEEN start_boundary AND end_boundary
• 简化语法：ROWS n PRECEDING = ROWS BETWEEN n PRECEDING AND CURRENT ROW
```

**🔸 边界处理机制**
```
边界溢出处理：
• MySQL自动调整到实际可用范围
• 不会报错，智能使用可用数据
• 前向溢出：调整到分区第一行
• 后向溢出：调整到分区最后一行

不完整窗口识别：
• 实际窗口大小 < 期望窗口大小
• 通过COUNT(*)检测窗口实际大小
• 可选择忽略或标记不完整窗口
```

### 9.2 关键理解要点


**🔹 ROWS vs RANGE的选择**
```
ROWS边界（推荐日常使用）：
• 按行计数，简单直观
• 性能更好，计算更快
• 适合：时间序列、排序数据

RANGE边界（特殊需求使用）：
• 按值范围，逻辑准确  
• 处理相同值更合理
• 适合：分数排名、金额范围
• 需要索引支持获得好性能

选择原则：
没有特殊需求就用ROWS，有值范围需求才用RANGE
```

**🔹 边界异常的预防**
```
常见异常及预防：
1. NULL值影响：WHERE过滤或COALESCE处理
2. 数据不足：验证分区数据量
3. 类型不匹配：确保RANGE支持的数据类型
4. 性能问题：合理设置窗口大小，添加必要索引

异常处理策略：
• 检测：使用COUNT(*)检查窗口大小
• 标记：标识不完整窗口
• 过滤：只保留完整窗口结果
• 调整：动态调整窗口大小
```

**🔹 性能优化核心**
```
性能优化策略：
1. 窗口大小控制：避免过大窗口（建议<100行）
2. 边界类型选择：ROWS优于RANGE
3. 索引支持：为ORDER BY字段建索引
4. 分区合理：避免过多小分区
5. 数据过滤：在窗口计算前过滤数据

实际优化效果：
• 合适索引：性能提升50-80%
• 窗口大小控制：避免内存溢出
• 分区策略：提升并行处理效率
```

### 9.3 实际应用指导


**💼 应用场景最佳实践**
```
时间序列分析：
✅ 使用ROWS进行移动平均计算
✅ 检测不完整窗口并合理处理
✅ 为日期字段创建索引

排名和分组：
✅ 使用RANGE处理相同值情况
✅ 验证边界定义的合理性
✅ 考虑分区数据分布

性能敏感场景：
✅ 优先选择ROWS边界
✅ 控制窗口大小在合理范围
✅ 添加必要的排序索引
✅ 预处理过滤不必要数据
```

### 9.4 故障排查指南


**🔧 边界相关问题排查**
```
问题1：窗口函数结果异常
排查步骤：
1. 检查边界定义语法是否正确
2. 验证数据是否包含NULL值
3. 确认分区和排序字段
4. 检查窗口大小是否合理

问题2：性能问题
排查步骤：  
1. 检查ORDER BY字段是否有索引
2. 确认窗口大小是否过大
3. 验证是否使用了合适的边界类型
4. 检查数据量和分区策略

问题3：不完整窗口处理
解决方案：
1. 使用COUNT(*)检测窗口大小
2. 添加条件过滤不完整窗口
3. 或者调整边界定义适应数据量
```

**⚠️ 常见错误避免**
```
边界定义错误：
❌ ROWS BETWEEN 3 FOLLOWING AND 1 FOLLOWING（起始>结束）
✅ ROWS BETWEEN 1 FOLLOWING AND 3 FOLLOWING

类型使用错误：
❌ 对字符串字段使用RANGE数值边界
✅ 对数值/日期字段使用RANGE边界

性能陷阱：
❌ 在大表上使用超大窗口无索引
✅ 合理窗口大小+适当索引支持

NULL值陷阱：
❌ 忽略NULL值对边界计算的影响
✅ 预先处理或在计算中考虑NULL值
```

**🧠 记忆要点**
```
边界处理口诀：
"ROWS按行数，RANGE按值算，溢出自调整，完整要检验"

性能优化口诀：
"窗口别太大，索引要跟上，ROWS性能好，RANGE逻辑强"

异常处理口诀：
"NULL值要小心，边界先验证，不完整标记，大窗口分批"
```

**🎯 核心记忆**
- 窗口边界定义决定了计算范围的精确性
- 边界溢出和不完整窗口是正常现象，需要合理处理
- ROWS性能好适合大多数场景，RANGE逻辑准确适合特殊需求
- 性能优化的关键是合理的窗口大小和索引策略
- 边界异常检测和处理是生产环境的必要措施