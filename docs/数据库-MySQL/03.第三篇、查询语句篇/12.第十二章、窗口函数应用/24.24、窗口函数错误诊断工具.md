---
title: 24ã€çª—å£å‡½æ•°é”™è¯¯è¯Šæ–­å·¥å…·
---
## ğŸ“š ç›®å½•

1. [çª—å£å‡½æ•°è°ƒè¯•åŸºç¡€](#1-çª—å£å‡½æ•°è°ƒè¯•åŸºç¡€)
2. [çª—å£èŒƒå›´å¯è§†åŒ–æŠ€æœ¯](#2-çª—å£èŒƒå›´å¯è§†åŒ–æŠ€æœ¯)
3. [çª—å£è®¡ç®—è·Ÿè¸ªæ–¹æ³•](#3-çª—å£è®¡ç®—è·Ÿè¸ªæ–¹æ³•)
4. [çª—å£æ€§èƒ½åˆ†æå·¥å…·](#4-çª—å£æ€§èƒ½åˆ†æå·¥å…·)
5. [çª—å£å‡½æ•°æµ‹è¯•æ¡†æ¶](#5-çª—å£å‡½æ•°æµ‹è¯•æ¡†æ¶)
6. [é—®é¢˜å®šä½å®æˆ˜æ–¹æ³•](#6-é—®é¢˜å®šä½å®æˆ˜æ–¹æ³•)
7. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#7-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ” çª—å£å‡½æ•°è°ƒè¯•åŸºç¡€


### 1.1 ä»€ä¹ˆæ˜¯çª—å£å‡½æ•°è°ƒè¯•


> **ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ**
> 
> çª—å£å‡½æ•°è°ƒè¯•æ˜¯æŒ‡åœ¨SQLæŸ¥è¯¢ä¸­ä½¿ç”¨çª—å£å‡½æ•°æ—¶ï¼Œå¦‚ä½•å¿«é€Ÿå‘ç°å’Œè§£å†³è®¡ç®—é”™è¯¯ã€æ€§èƒ½é—®é¢˜å’Œé€»è¾‘é”™è¯¯çš„ä¸€å¥—æ–¹æ³•å’Œå·¥å…·ã€‚

**ä¸ºä»€ä¹ˆéœ€è¦è°ƒè¯•çª—å£å‡½æ•°ï¼Ÿ**

çª—å£å‡½æ•°è™½ç„¶å¼ºå¤§ï¼Œä½†å®¹æ˜“å‡ºç°ä»¥ä¸‹é—®é¢˜ï¼š
- **è®¡ç®—ç»“æœä¸ç¬¦åˆé¢„æœŸ**ï¼šåˆ†ç»„ã€æ’åºã€èŒƒå›´è®¾ç½®é”™è¯¯
- **æ€§èƒ½é—®é¢˜**ï¼šçª—å£è®¾ç½®ä¸å½“å¯¼è‡´æŸ¥è¯¢ç¼“æ…¢
- **é€»è¾‘é”™è¯¯**ï¼šå¯¹çª—å£æœºåˆ¶ç†è§£åå·®

```
å¸¸è§é—®é¢˜åœºæ™¯ï¼š
ç”¨æˆ·æœŸæœ›ï¼šæŒ‰æœˆç»Ÿè®¡æ¯ä¸ªç”¨æˆ·çš„ç´¯è®¡é‡‘é¢
å®é™…ç»“æœï¼šæ•°æ®é‡å¤æˆ–é—æ¼
é—®é¢˜æ ¹æºï¼šçª—å£å‡½æ•°çš„PARTITION BYå’ŒORDER BYè®¾ç½®é”™è¯¯
```

### 1.2 çª—å£å‡½æ•°é”™è¯¯çš„å…¸å‹è¡¨ç°


**ğŸš¨ æ•°æ®å¼‚å¸¸è¡¨ç°**

| é”™è¯¯ç±»å‹ | **è¡¨ç°ç—‡çŠ¶** | **å¯èƒ½åŸå› ** | **å½±å“ç¨‹åº¦** |
|---------|-------------|-------------|-------------|
| **é‡å¤è®¡ç®—** | `åŒä¸€è¡Œæ•°æ®è¢«å¤šæ¬¡è®¡ç®—` | `çª—å£èŒƒå›´è®¾ç½®è¿‡å¤§` | `ğŸ”´ ä¸¥é‡` |
| **é—æ¼æ•°æ®** | `éƒ¨åˆ†æ•°æ®æœªå‚ä¸è®¡ç®—` | `åˆ†åŒºæ¡ä»¶è¿‡ä¸¥æ ¼` | `ğŸ”´ ä¸¥é‡` |
| **æ’åºé”™è¯¯** | `ç´¯è®¡å€¼é¡ºåºæ··ä¹±` | `ORDER BYè®¾ç½®é”™è¯¯` | `ğŸŸ¡ ä¸­ç­‰` |
| **æ€§èƒ½ç¼“æ…¢** | `æŸ¥è¯¢æ‰§è¡Œæ—¶é—´è¿‡é•¿` | `çª—å£å‡½æ•°ä½¿ç”¨ä¸å½“` | `ğŸŸ¡ ä¸­ç­‰` |

### 1.3 è°ƒè¯•æ€ç»´æ¨¡å¼


**ğŸ§  è°ƒè¯•æ€è·¯æ¡†æ¶**
```
ç¬¬ä¸€æ­¥ï¼šç†è§£é¢„æœŸç»“æœ
â†“
ç¬¬äºŒæ­¥ï¼šåˆ†è§£çª—å£å‡½æ•°ç»„æˆ
â†“  
ç¬¬ä¸‰æ­¥ï¼šé€ä¸ªéªŒè¯å„éƒ¨åˆ†
â†“
ç¬¬å››æ­¥ï¼šæ£€æŸ¥çª—å£èŒƒå›´
â†“
ç¬¬äº”æ­¥ï¼šéªŒè¯è®¡ç®—é€»è¾‘
```

**ğŸ” åˆ†è§£éªŒè¯æ³•**
```sql
-- åŸå§‹å¤æ‚æŸ¥è¯¢
SELECT 
    user_id,
    order_date,
    amount,
    SUM(amount) OVER (
        PARTITION BY user_id 
        ORDER BY order_date 
        RANGE BETWEEN INTERVAL '30' DAY PRECEDING AND CURRENT ROW
    ) as rolling_30day_sum
FROM orders;

-- åˆ†è§£éªŒè¯æ­¥éª¤ï¼š
-- 1. å…ˆçœ‹åŸºç¡€æ•°æ®
SELECT user_id, order_date, amount FROM orders ORDER BY user_id, order_date;

-- 2. éªŒè¯åˆ†åŒºæ•ˆæœ  
SELECT user_id, COUNT(*) FROM orders GROUP BY user_id;

-- 3. éªŒè¯æ’åºæ•ˆæœ
SELECT user_id, order_date, amount FROM orders ORDER BY user_id, order_date;

-- 4. ç®€åŒ–çª—å£å‡½æ•°æµ‹è¯•
SELECT 
    user_id, order_date, amount,
    SUM(amount) OVER (PARTITION BY user_id ORDER BY order_date) as cumsum
FROM orders;
```

---

## 2. ğŸ‘ï¸ çª—å£èŒƒå›´å¯è§†åŒ–æŠ€æœ¯


### 2.1 çª—å£èŒƒå›´å¯è§†åŒ–çš„é‡è¦æ€§


**ä¸ºä»€ä¹ˆè¦å¯è§†åŒ–çª—å£èŒƒå›´ï¼Ÿ**

çª—å£å‡½æ•°çš„æ ¸å¿ƒéš¾ç‚¹åœ¨äºç†è§£"å½“å‰è¡Œçš„çª—å£èŒƒå›´åŒ…å«å“ªäº›æ•°æ®"ã€‚é€šè¿‡å¯è§†åŒ–æŠ€æœ¯ï¼Œæˆ‘ä»¬å¯ä»¥ç›´è§‚çœ‹åˆ°æ¯ä¸€è¡Œè®¡ç®—æ—¶å®é™…åŒ…å«çš„æ•°æ®èŒƒå›´ã€‚

> **ğŸ’¡ ç†è§£è¦ç‚¹**
>
> æƒ³è±¡çª—å£å‡½æ•°å°±åƒä¸€ä¸ª"æ»‘åŠ¨çš„è®¡ç®—çª—å£"ï¼Œè¿™ä¸ªçª—å£åœ¨æ¯ä¸€è¡Œæ•°æ®ä¸Šç§»åŠ¨ï¼ŒåŒ…å«ä¸åŒçš„æ•°æ®è¿›è¡Œè®¡ç®—ã€‚å¯è§†åŒ–å°±æ˜¯è¦çœ‹æ¸…æ¥šè¿™ä¸ªçª—å£åœ¨æ¯ä¸€è¡Œæ—¶åˆ°åº•"æ¡†ä½äº†"å“ªäº›æ•°æ®ã€‚

### 2.2 ROWèŒƒå›´å¯è§†åŒ–


**ğŸ“Š ROWçª—å£ç¤ºä¾‹æ•°æ®**
```sql
-- ç¤ºä¾‹ï¼šå‘˜å·¥å·¥èµ„æ’ååˆ†æ
CREATE TEMP TABLE employee_salary AS
SELECT * FROM VALUES
    ('å¼ ä¸‰', 'IT', 8000, '2023-01-15'),
    ('æå››', 'IT', 9000, '2023-02-01'), 
    ('ç‹äº”', 'IT', 7500, '2023-03-01'),
    ('èµµå…­', 'HR', 6000, '2023-01-10'),
    ('å­™ä¸ƒ', 'HR', 6500, '2023-02-15')
AS t(name, dept, salary, hire_date);
```

**ğŸ” å¯è§†åŒ–ROWçª—å£è®¡ç®—**
```sql
-- å¯è§†åŒ–æŸ¥è¯¢ï¼šæ˜¾ç¤ºæ¯è¡Œçš„çª—å£èŒƒå›´
SELECT 
    name,
    dept,
    salary,
    -- å½“å‰è¡Œåœ¨éƒ¨é—¨å†…çš„è¡Œå·
    ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC) as row_num,
    
    -- æ˜¾ç¤ºçª—å£èŒƒå›´ï¼šå‰1è¡Œåˆ°å1è¡Œ
    LAG(name, 1) OVER (PARTITION BY dept ORDER BY salary DESC) as prev_row,
    name as current_row,
    LEAD(name, 1) OVER (PARTITION BY dept ORDER BY salary DESC) as next_row,
    
    -- åœ¨çª—å£èŒƒå›´å†…çš„å¹³å‡å·¥èµ„
    AVG(salary) OVER (
        PARTITION BY dept 
        ORDER BY salary DESC 
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) as window_avg_salary
FROM employee_salary
ORDER BY dept, salary DESC;
```

**ğŸ“‹ ROWçª—å£å¯è§†åŒ–ç»“æœ**
```
ITéƒ¨é—¨çª—å£èŒƒå›´å¯è§†åŒ–ï¼š
è¡Œå·  å§“å   å·¥èµ„   å‰ä¸€è¡Œ  å½“å‰è¡Œ  åä¸€è¡Œ   çª—å£å¹³å‡
1    æå››   9000   NULL   æå››    å¼ ä¸‰    8500  â† çª—å£:[æå››,å¼ ä¸‰]
2    å¼ ä¸‰   8000   æå››   å¼ ä¸‰    ç‹äº”    8167  â† çª—å£:[æå››,å¼ ä¸‰,ç‹äº”]  
3    ç‹äº”   7500   å¼ ä¸‰   ç‹äº”    NULL    7750  â† çª—å£:[å¼ ä¸‰,ç‹äº”]

HRéƒ¨é—¨çª—å£èŒƒå›´å¯è§†åŒ–ï¼š
è¡Œå·  å§“å   å·¥èµ„   å‰ä¸€è¡Œ  å½“å‰è¡Œ  åä¸€è¡Œ   çª—å£å¹³å‡
1    å­™ä¸ƒ   6500   NULL   å­™ä¸ƒ    èµµå…­    6250  â† çª—å£:[å­™ä¸ƒ,èµµå…­]
2    èµµå…­   6000   å­™ä¸ƒ   èµµå…­    NULL    6250  â† çª—å£:[å­™ä¸ƒ,èµµå…­]
```

### 2.3 RANGEèŒƒå›´å¯è§†åŒ–


**ğŸ“… æ—¶é—´èŒƒå›´çª—å£ç¤ºä¾‹**
```sql
-- ç¤ºä¾‹ï¼šç”¨æˆ·è®¢å•é‡‘é¢æ»šåŠ¨ç»Ÿè®¡
CREATE TEMP TABLE user_orders AS
SELECT * FROM VALUES
    (1, '2023-01-01'::date, 100),
    (1, '2023-01-05'::date, 200),
    (1, '2023-01-15'::date, 150),
    (1, '2023-01-20'::date, 300),
    (1, '2023-02-01'::date, 250)
AS t(user_id, order_date, amount);
```

**ğŸ” RANGEçª—å£å¯è§†åŒ–æŸ¥è¯¢**
```sql
-- å¯è§†åŒ–7å¤©æ»šåŠ¨çª—å£
SELECT 
    order_date,
    amount,
    
    -- æ˜¾ç¤ºçª—å£çš„å¼€å§‹å’Œç»“æŸæ—¥æœŸ
    (order_date - INTERVAL '7 days') as window_start,
    order_date as window_end,
    
    -- æ˜¾ç¤ºçª—å£å†…åŒ…å«çš„è®¢å•
    STRING_AGG(
        order_date::text || ':' || amount::text, 
        ', ' 
        ORDER BY order_date
    ) OVER (
        ORDER BY order_date 
        RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW
    ) as window_orders,
    
    -- 7å¤©å†…è®¢å•æ€»é‡‘é¢
    SUM(amount) OVER (
        ORDER BY order_date 
        RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW
    ) as rolling_7day_sum
    
FROM user_orders
ORDER BY order_date;
```

**ğŸ“Š RANGEçª—å£å¯è§†åŒ–ç»“æœ**
```
è®¢å•æ—¥æœŸ    é‡‘é¢  çª—å£å¼€å§‹   çª—å£ç»“æŸ   çª—å£å†…è®¢å•              7å¤©æ»šåŠ¨å’Œ
2023-01-01  100  2022-12-25 2023-01-01 2023-01-01:100         100
2023-01-05  200  2022-12-29 2023-01-05 2023-01-01:100,        300
                                       2023-01-05:200         
2023-01-15  150  2023-01-08 2023-01-15 2023-01-15:150         150  â† 1-01è¶…å‡º7å¤©
2023-01-20  300  2023-01-13 2023-01-20 2023-01-15:150,        450
                                       2023-01-20:300
2023-02-01  250  2023-01-25 2023-02-01 2023-02-01:250         250  â† å‰é¢è®¢å•éƒ½è¶…å‡º7å¤©
```

### 2.4 çª—å£è¾¹ç•Œå¯è§†åŒ–å·¥å…·å‡½æ•°


**ğŸ› ï¸ è‡ªå®šä¹‰å¯è§†åŒ–å‡½æ•°**
```sql
-- åˆ›å»ºçª—å£èŒƒå›´æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION show_window_range(
    table_name TEXT,
    partition_col TEXT,
    order_col TEXT, 
    window_spec TEXT
) RETURNS TABLE (
    row_position INT,
    current_value TEXT,
    window_start_value TEXT,
    window_end_value TEXT,
    window_size INT
) AS $$
BEGIN
    -- åŠ¨æ€æ„å»ºæŸ¥è¯¢ï¼Œæ˜¾ç¤ºçª—å£èŒƒå›´
    RETURN QUERY EXECUTE format('
        SELECT 
            ROW_NUMBER() OVER (PARTITION BY %I ORDER BY %I) as row_position,
            %I::TEXT as current_value,
            FIRST_VALUE(%I) OVER (
                PARTITION BY %I ORDER BY %I %s
            )::TEXT as window_start_value,
            LAST_VALUE(%I) OVER (
                PARTITION BY %I ORDER BY %I %s
            )::TEXT as window_end_value,
            COUNT(*) OVER (
                PARTITION BY %I ORDER BY %I %s  
            ) as window_size
        FROM %I
        ORDER BY %I, %I
    ', order_col, order_col, order_col, order_col, partition_col, order_col, window_spec,
       order_col, partition_col, order_col, window_spec,
       partition_col, order_col, window_spec, table_name, partition_col, order_col);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM show_window_range(
    'employee_salary', 
    'dept', 
    'salary', 
    'ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING'
);
```

---

## 3. ğŸ“Š çª—å£è®¡ç®—è·Ÿè¸ªæ–¹æ³•


### 3.1 åˆ†æ­¥è®¡ç®—è·Ÿè¸ª


**é€æ­¥åˆ†è§£è®¡ç®—è¿‡ç¨‹**

å½“çª—å£å‡½æ•°ç»“æœä¸ç¬¦åˆé¢„æœŸæ—¶ï¼Œæœ€æœ‰æ•ˆçš„æ–¹æ³•æ˜¯å°†å¤æ‚è®¡ç®—åˆ†è§£ä¸ºå¤šä¸ªç®€å•æ­¥éª¤ï¼Œé€æ­¥éªŒè¯æ¯ä¸€æ­¥çš„æ­£ç¡®æ€§ã€‚

```sql
-- å¤æ‚çª—å£å‡½æ•°ç¤ºä¾‹ï¼šè®¡ç®—ç”¨æˆ·æ¶ˆè´¹è¶‹åŠ¿
-- åŸå§‹æŸ¥è¯¢ï¼ˆå¯èƒ½æœ‰é—®é¢˜ï¼‰
SELECT 
    user_id,
    order_date,
    amount,
    AVG(amount) OVER (
        PARTITION BY user_id 
        ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg_3
FROM user_orders;

-- åˆ†æ­¥è·Ÿè¸ªæ–¹æ³•ï¼š
-- ç¬¬1æ­¥ï¼šæ£€æŸ¥åŸºç¡€æ•°æ®
SELECT user_id, order_date, amount 
FROM user_orders 
ORDER BY user_id, order_date;

-- ç¬¬2æ­¥ï¼šæ·»åŠ è¡Œå·ï¼Œç¡®è®¤æ’åº
SELECT 
    user_id, order_date, amount,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date) as row_num
FROM user_orders 
ORDER BY user_id, order_date;

-- ç¬¬3æ­¥ï¼šæ˜¾ç¤ºçª—å£å†…çš„å…·ä½“æ•°æ®
SELECT 
    user_id, order_date, amount,
    LAG(amount, 2) OVER (PARTITION BY user_id ORDER BY order_date) as amount_2_before,
    LAG(amount, 1) OVER (PARTITION BY user_id ORDER BY order_date) as amount_1_before,
    amount as current_amount,
    -- æ‰‹åŠ¨è®¡ç®—éªŒè¯
    (COALESCE(LAG(amount, 2) OVER (PARTITION BY user_id ORDER BY order_date), 0) + 
     COALESCE(LAG(amount, 1) OVER (PARTITION BY user_id ORDER BY order_date), 0) + 
     amount) / 
    (CASE WHEN LAG(amount, 2) OVER (PARTITION BY user_id ORDER BY order_date) IS NOT NULL THEN 3
          WHEN LAG(amount, 1) OVER (PARTITION BY user_id ORDER BY order_date) IS NOT NULL THEN 2  
          ELSE 1 END) as manual_avg,
    -- çª—å£å‡½æ•°è®¡ç®—
    AVG(amount) OVER (
        PARTITION BY user_id ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as window_avg
FROM user_orders 
ORDER BY user_id, order_date;
```

### 3.2 çª—å£çŠ¶æ€è·Ÿè¸ªè¡¨


**ğŸ“‹ åˆ›å»ºè°ƒè¯•çŠ¶æ€è¡¨**
```sql
-- åˆ›å»ºçª—å£å‡½æ•°è°ƒè¯•çŠ¶æ€è¡¨
CREATE TEMP TABLE window_debug_trace AS
SELECT 
    -- åŸºç¡€ä¿¡æ¯
    user_id,
    order_date, 
    amount,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date) as row_position,
    
    -- çª—å£è¾¹ç•Œè·Ÿè¸ª
    FIRST_VALUE(order_date) OVER (
        PARTITION BY user_id ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as window_start_date,
    
    LAST_VALUE(order_date) OVER (
        PARTITION BY user_id ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as window_end_date,
    
    -- çª—å£å¤§å°è·Ÿè¸ª
    COUNT(*) OVER (
        PARTITION BY user_id ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as window_size,
    
    -- è®¡ç®—è¿‡ç¨‹è·Ÿè¸ª
    STRING_AGG(amount::text, '+') OVER (
        PARTITION BY user_id ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as calculation_formula,
    
    SUM(amount) OVER (
        PARTITION BY user_id ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as window_sum,
    
    AVG(amount) OVER (
        PARTITION BY user_id ORDER BY order_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as window_avg

FROM user_orders;

-- æŸ¥çœ‹è°ƒè¯•ä¿¡æ¯
SELECT * FROM window_debug_trace ORDER BY user_id, order_date;
```

### 3.3 çª—å£å‡½æ•°æ‰§è¡Œè®¡åˆ’åˆ†æ


**ğŸ” æŸ¥çœ‹æ‰§è¡Œè®¡åˆ’**
```sql
-- åˆ†æçª—å£å‡½æ•°çš„æ‰§è¡Œè®¡åˆ’
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT) 
SELECT 
    user_id,
    order_date,
    SUM(amount) OVER (PARTITION BY user_id ORDER BY order_date) as cumsum,
    AVG(amount) OVER (PARTITION BY user_id ORDER BY order_date 
                     ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg
FROM user_orders;

-- é‡ç‚¹å…³æ³¨ï¼š
-- 1. Sortæ“ä½œï¼šæ˜¯å¦æœ‰ä¸å¿…è¦çš„æ’åº
-- 2. WindowAggèŠ‚ç‚¹ï¼šçª—å£å‡½æ•°çš„è®¡ç®—æˆæœ¬
-- 3. Buffersï¼šå†…å­˜ä½¿ç”¨æƒ…å†µ
-- 4. å®é™…æ‰§è¡Œæ—¶é—´vsé¢„æœŸæ—¶é—´
```

**ğŸ“Š æ‰§è¡Œè®¡åˆ’è§£è¯»è¦ç‚¹**
```
WindowAgg (cost=xxx..xxx rows=xxx width=xxx) (actual time=xxx..xxx loops=xxx)
  -> Sort (cost=xxx..xxx rows=xxx width=xxx) (actual time=xxx..xxx loops=xxx)
       Sort Key: user_id, order_date
       Sort Method: quicksort Memory: xxxkB
       -> Seq Scan on user_orders

å…³é”®æŒ‡æ ‡è§£è¯»ï¼š
- Sort Memoryï¼šå¦‚æœä½¿ç”¨äº†ç£ç›˜æ’åºï¼Œæ€§èƒ½ä¼šæ˜¾è‘—ä¸‹é™
- actual timeï¼šå®é™…æ‰§è¡Œæ—¶é—´ï¼Œå…³æ³¨æ˜¯å¦å¼‚å¸¸
- loopsï¼šå¾ªç¯æ¬¡æ•°ï¼Œæ­£å¸¸åº”è¯¥æ˜¯1
- rowsï¼šå¤„ç†çš„è¡Œæ•°ï¼ŒéªŒè¯æ˜¯å¦ç¬¦åˆé¢„æœŸ
```

---

## 4. ğŸ“ˆ çª—å£æ€§èƒ½åˆ†æå·¥å…·


### 4.1 æ€§èƒ½é—®é¢˜è¯Šæ–­


**ğŸš¨ å¸¸è§æ€§èƒ½é—®é¢˜**

| é—®é¢˜ç±»å‹ | **ç—‡çŠ¶** | **æ ¹æœ¬åŸå› ** | **è§£å†³æ–¹æ¡ˆ** |
|---------|---------|-------------|-------------|
| **æ’åºå¼€é”€å¤§** | `æŸ¥è¯¢ç¼“æ…¢ï¼Œå†…å­˜ä¸è¶³` | `ORDER BYå­—æ®µæœªå»ºç´¢å¼•` | `åˆ›å»ºå¤åˆç´¢å¼•` |
| **çª—å£è®¡ç®—é‡å¤** | `CPUä½¿ç”¨ç‡é«˜` | `å¤šä¸ªç›¸ä¼¼çª—å£å‡½æ•°` | `åˆå¹¶è®¡ç®—ï¼Œå¤ç”¨ç»“æœ` |
| **å†…å­˜æº¢å‡º** | `æŸ¥è¯¢å¤±è´¥æˆ–ææ…¢` | `çª—å£èŒƒå›´è¿‡å¤§` | `ä¼˜åŒ–çª—å£èŒƒå›´è®¾ç½®` |
| **å…¨è¡¨æ‰«æ** | `IOç­‰å¾…é«˜` | `åˆ†åŒºå­—æ®µæ— ç´¢å¼•` | `æ·»åŠ åˆ†åŒºå­—æ®µç´¢å¼•` |

### 4.2 æ€§èƒ½ç›‘æ§æŸ¥è¯¢


**ğŸ“Š çª—å£å‡½æ•°æ€§èƒ½ç›‘æ§**
```sql
-- ç›‘æ§çª—å£å‡½æ•°æŸ¥è¯¢æ€§èƒ½
WITH query_stats AS (
    SELECT 
        query,
        calls,
        total_time,
        mean_time,
        min_time,
        max_time,
        rows,
        100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
    FROM pg_stat_statements 
    WHERE query LIKE '%OVER%'  -- åŒ…å«çª—å£å‡½æ•°çš„æŸ¥è¯¢
    ORDER BY total_time DESC
    LIMIT 10
)
SELECT 
    LEFT(query, 100) as query_preview,
    calls as "æ‰§è¡Œæ¬¡æ•°",
    ROUND(total_time::numeric, 2) as "æ€»è€—æ—¶(ms)",
    ROUND(mean_time::numeric, 2) as "å¹³å‡è€—æ—¶(ms)",
    rows as "å¤„ç†è¡Œæ•°",
    ROUND(hit_percent::numeric, 2) as "ç¼“å­˜å‘½ä¸­ç‡(%)"
FROM query_stats;
```

### 4.3 ç´¢å¼•ä¼˜åŒ–å»ºè®®


**ğŸ”§ çª—å£å‡½æ•°ç´¢å¼•ç­–ç•¥**

> **ğŸ’¡ ç´¢å¼•åˆ›å»ºåŸåˆ™**
>
> çª—å£å‡½æ•°çš„æ€§èƒ½ä¸»è¦å–å†³äº`PARTITION BY`å’Œ`ORDER BY`å­—æ®µçš„ç´¢å¼•ã€‚åˆ›å»ºå¤åˆç´¢å¼•æ—¶ï¼Œå­—æ®µé¡ºåºåº”è¯¥æ˜¯ï¼šåˆ†åŒºå­—æ®µåœ¨å‰ï¼Œæ’åºå­—æ®µåœ¨åã€‚

```sql
-- é’ˆå¯¹çª—å£å‡½æ•°ä¼˜åŒ–çš„ç´¢å¼•ç­–ç•¥

-- åœºæ™¯1ï¼šå•ä¸€åˆ†åŒºå•ä¸€æ’åº
-- SELECT SUM(amount) OVER (PARTITION BY user_id ORDER BY order_date)
CREATE INDEX idx_user_orders_window 
ON user_orders (user_id, order_date);

-- åœºæ™¯2ï¼šå¤šå­—æ®µåˆ†åŒº
-- SELECT AVG(amount) OVER (PARTITION BY user_id, product_type ORDER BY order_date)  
CREATE INDEX idx_user_orders_complex_window
ON user_orders (user_id, product_type, order_date);

-- åœºæ™¯3ï¼šåŒ…å«WHEREæ¡ä»¶çš„çª—å£æŸ¥è¯¢
-- WHERE status = 'completed' 
CREATE INDEX idx_user_orders_filtered_window
ON user_orders (status, user_id, order_date)
WHERE status = 'completed';  -- éƒ¨åˆ†ç´¢å¼•

-- åœºæ™¯4ï¼šå¤šä¸ªçª—å£å‡½æ•°å…±ç”¨
-- åŒæ—¶ä½¿ç”¨æŒ‰æ—¥æœŸå’ŒæŒ‰é‡‘é¢çš„çª—å£å‡½æ•°
CREATE INDEX idx_user_orders_multi_window1 ON user_orders (user_id, order_date);
CREATE INDEX idx_user_orders_multi_window2 ON user_orders (user_id, amount DESC);
```

### 4.4 æ€§èƒ½æµ‹è¯•æ¡†æ¶


**âš¡ çª—å£å‡½æ•°æ€§èƒ½æµ‹è¯•**
```sql
-- åˆ›å»ºæ€§èƒ½æµ‹è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION test_window_performance(
    test_table TEXT,
    window_query TEXT,
    iterations INT DEFAULT 10
) RETURNS TABLE (
    iteration INT,
    execution_time_ms NUMERIC,
    rows_processed BIGINT,
    memory_used_mb NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    i INT;
BEGIN
    FOR i IN 1..iterations LOOP
        -- æ¸…ç†ç¼“å­˜ï¼ˆå¯é€‰ï¼‰
        PERFORM pg_stat_reset();
        
        start_time := clock_timestamp();
        
        -- æ‰§è¡Œçª—å£å‡½æ•°æŸ¥è¯¢
        EXECUTE window_query;
        
        end_time := clock_timestamp();
        
        iteration := i;
        execution_time_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
        rows_processed := (SELECT COUNT(*) FROM pg_stat_user_tables WHERE relname = test_table);
        memory_used_mb := (SELECT SUM(heap_blks_read + heap_blks_hit) * 8.0 / 1024 
                          FROM pg_stat_user_tables WHERE relname = test_table);
        
        RETURN NEXT;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM test_window_performance(
    'user_orders',
    'SELECT user_id, SUM(amount) OVER (PARTITION BY user_id ORDER BY order_date) FROM user_orders',
    5
);
```

---

## 5. ğŸ§ª çª—å£å‡½æ•°æµ‹è¯•æ¡†æ¶


### 5.1 å•å…ƒæµ‹è¯•æ¡†æ¶è®¾è®¡


**ğŸ—ï¸ æµ‹è¯•æ¡†æ¶æ¶æ„**
```
æµ‹è¯•æ¡†æ¶ç»“æ„ï¼š
â”œâ”€ æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
â”œâ”€ çª—å£å‡½æ•°éªŒè¯å™¨  
â”œâ”€ æ€§èƒ½åŸºå‡†æµ‹è¯•
â”œâ”€ è¾¹ç•Œæ¡ä»¶æµ‹è¯•
â””â”€ å›å½’æµ‹è¯•å¥—ä»¶
```

**ğŸ› ï¸ åŸºç¡€æµ‹è¯•æ¡†æ¶**
```sql
-- åˆ›å»ºçª—å£å‡½æ•°æµ‹è¯•æ¡†æ¶
CREATE SCHEMA IF NOT EXISTS window_function_tests;

-- æµ‹è¯•ç”¨ä¾‹è¡¨
CREATE TABLE window_function_tests.test_cases (
    test_id SERIAL PRIMARY KEY,
    test_name VARCHAR(100) NOT NULL,
    test_description TEXT,
    input_data JSONB,  -- æµ‹è¯•è¾“å…¥æ•°æ®
    expected_result JSONB,  -- æœŸæœ›ç»“æœ  
    window_function_sql TEXT,  -- çª—å£å‡½æ•°SQL
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æµ‹è¯•ç»“æœè¡¨
CREATE TABLE window_function_tests.test_results (
    result_id SERIAL PRIMARY KEY,
    test_id INT REFERENCES window_function_tests.test_cases(test_id),
    actual_result JSONB,  -- å®é™…ç»“æœ
    execution_time_ms NUMERIC,  -- æ‰§è¡Œæ—¶é—´
    memory_used_kb BIGINT,  -- å†…å­˜ä½¿ç”¨
    test_status VARCHAR(20),  -- PASS/FAIL/ERROR
    error_message TEXT,
    tested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 5.2 è‡ªåŠ¨åŒ–æµ‹è¯•å‡½æ•°


**ğŸ”§ æµ‹è¯•æ‰§è¡Œå™¨**
```sql
-- çª—å£å‡½æ•°è‡ªåŠ¨åŒ–æµ‹è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION run_window_function_test(test_case_id INT)
RETURNS TABLE (
    test_name TEXT,
    status TEXT,
    execution_time_ms NUMERIC,
    error_details TEXT
) AS $$
DECLARE
    test_record RECORD;
    actual_result JSONB;
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    exec_time NUMERIC;
    test_status TEXT := 'PASS';
    error_msg TEXT := '';
BEGIN
    -- è·å–æµ‹è¯•ç”¨ä¾‹
    SELECT * INTO test_record 
    FROM window_function_tests.test_cases 
    WHERE test_id = test_case_id;
    
    IF NOT FOUND THEN
        test_name := 'Unknown';
        status := 'ERROR';
        error_details := 'Test case not found';
        RETURN NEXT;
        RETURN;
    END IF;
    
    BEGIN
        -- è®°å½•å¼€å§‹æ—¶é—´
        start_time := clock_timestamp();
        
        -- æ‰§è¡Œçª—å£å‡½æ•°æŸ¥è¯¢
        EXECUTE test_record.window_function_sql INTO actual_result;
        
        -- è®°å½•ç»“æŸæ—¶é—´
        end_time := clock_timestamp();
        exec_time := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
        
        -- æ¯”è¾ƒç»“æœ
        IF actual_result = test_record.expected_result THEN
            test_status := 'PASS';
        ELSE
            test_status := 'FAIL';
            error_msg := format('Expected: %s, Actual: %s', 
                              test_record.expected_result, actual_result);
        END IF;
        
    EXCEPTION WHEN OTHERS THEN
        test_status := 'ERROR';
        error_msg := SQLERRM;
        exec_time := 0;
    END;
    
    -- è®°å½•æµ‹è¯•ç»“æœ
    INSERT INTO window_function_tests.test_results 
    (test_id, actual_result, execution_time_ms, test_status, error_message)
    VALUES (test_case_id, actual_result, exec_time, test_status, error_msg);
    
    -- è¿”å›ç»“æœ
    test_name := test_record.test_name;
    status := test_status;
    execution_time_ms := exec_time;
    error_details := error_msg;
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 è¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹


**ğŸ¯ å…³é”®è¾¹ç•Œæµ‹è¯•**
```sql
-- æ’å…¥è¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹
INSERT INTO window_function_tests.test_cases 
(test_name, test_description, window_function_sql, expected_result) 
VALUES 

-- æµ‹è¯•1ï¼šç©ºæ•°æ®é›†
('empty_dataset_test', 
 'æµ‹è¯•ç©ºæ•°æ®é›†ä¸Šçš„çª—å£å‡½æ•°',
 'SELECT COUNT(*) OVER () as total FROM (SELECT 1 WHERE FALSE) t',
 '[]'::jsonb),

-- æµ‹è¯•2ï¼šå•è¡Œæ•°æ®
('single_row_test',
 'æµ‹è¯•å•è¡Œæ•°æ®çš„çª—å£å‡½æ•°',
 'SELECT user_id, SUM(amount) OVER (PARTITION BY user_id) as total 
  FROM (VALUES (1, 100)) AS t(user_id, amount)',
 '[{"user_id": 1, "total": 100}]'::jsonb),

-- æµ‹è¯•3ï¼šç›¸åŒå€¼æ’åº
('duplicate_values_test',
 'æµ‹è¯•ç›¸åŒæ’åºå€¼çš„å¤„ç†',
 'SELECT amount, RANK() OVER (ORDER BY amount) as rank 
  FROM (VALUES (100), (100), (200)) AS t(amount)',
 '[{"amount": 100, "rank": 1}, {"amount": 100, "rank": 1}, {"amount": 200, "rank": 3}]'::jsonb),

-- æµ‹è¯•4ï¼šNULLå€¼å¤„ç†
('null_values_test',
 'æµ‹è¯•NULLå€¼åœ¨çª—å£å‡½æ•°ä¸­çš„å¤„ç†',
 'SELECT amount, SUM(amount) OVER (ORDER BY amount NULLS LAST) as cumsum
  FROM (VALUES (100), (NULL), (200)) AS t(amount)',
 '[{"amount": 100, "cumsum": 100}, {"amount": 200, "cumsum": 300}, {"amount": null, "cumsum": 300}]'::jsonb);
```

### 5.4 æ€§èƒ½åŸºå‡†æµ‹è¯•


**âš¡ æ€§èƒ½åŸºå‡†å¯¹æ¯”**
```sql
-- åˆ›å»ºæ€§èƒ½åŸºå‡†æµ‹è¯•
CREATE OR REPLACE FUNCTION benchmark_window_functions()
RETURNS TABLE (
    test_scenario TEXT,
    rows_count BIGINT,
    execution_time_ms NUMERIC,
    memory_usage_mb NUMERIC,
    performance_rating TEXT
) AS $$
BEGIN
    -- æµ‹è¯•åœºæ™¯1ï¼šå°æ•°æ®é›†(1000è¡Œ)
    INSERT INTO temp_orders 
    SELECT generate_series(1, 10) as user_id,
           CURRENT_DATE + (random() * 30)::int as order_date,
           (random() * 1000)::int as amount
    FROM generate_series(1, 100);
    
    test_scenario := 'å°æ•°æ®é›†-1000è¡Œ';
    rows_count := 1000;
    -- æ‰§è¡Œæµ‹è¯•å¹¶è®°å½•ç»“æœ...
    
    RETURN NEXT;
    
    -- æµ‹è¯•åœºæ™¯2ï¼šä¸­ç­‰æ•°æ®é›†(10ä¸‡è¡Œ)  
    -- ç±»ä¼¼å®ç°...
    
    -- æµ‹è¯•åœºæ™¯3ï¼šå¤§æ•°æ®é›†(100ä¸‡è¡Œ)
    -- ç±»ä¼¼å®ç°...
END;
$$ LANGUAGE plpgsql;
```

---

## 6. ğŸ¯ é—®é¢˜å®šä½å®æˆ˜æ–¹æ³•


### 6.1 å¸¸è§é”™è¯¯ç±»å‹ä¸è¯Šæ–­


**âŒ é”™è¯¯ç±»å‹1ï¼šçª—å£èŒƒå›´è®¾ç½®é”™è¯¯**

**é—®é¢˜ç°è±¡**ï¼šç´¯è®¡é‡‘é¢çªç„¶è·³è·ƒæˆ–é‡å¤è®¡ç®—
```sql
-- é”™è¯¯çš„çª—å£è®¾ç½®
SELECT 
    order_date,
    amount,
    SUM(amount) OVER (ORDER BY order_date) as wrong_cumsum  -- ç¼ºå°‘æ˜ç¡®çš„çª—å£èŒƒå›´
FROM orders;

-- é—®é¢˜è¯Šæ–­æ–¹æ³•
SELECT 
    order_date,
    amount,
    -- æ˜¾ç¤ºé»˜è®¤çª—å£èŒƒå›´
    COUNT(*) OVER (ORDER BY order_date) as window_size,
    FIRST_VALUE(order_date) OVER (ORDER BY order_date) as window_start,
    LAST_VALUE(order_date) OVER (ORDER BY order_date) as window_end,
    SUM(amount) OVER (ORDER BY order_date) as cumsum
FROM orders
ORDER BY order_date;
```

**ğŸ”§ æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆ**
```sql
-- æ˜ç¡®æŒ‡å®šçª—å£èŒƒå›´
SELECT 
    order_date,
    amount,
    SUM(amount) OVER (
        ORDER BY order_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- æ˜ç¡®æŒ‡å®šèŒƒå›´
    ) as correct_cumsum
FROM orders;
```

**âŒ é”™è¯¯ç±»å‹2ï¼šåˆ†åŒºè®¾ç½®ä¸å½“**

**é—®é¢˜ç°è±¡**ï¼šè·¨ç”¨æˆ·çš„æ•°æ®è¢«é”™è¯¯èšåˆ
```sql
-- é”™è¯¯ï¼šå¿˜è®°æŒ‰ç”¨æˆ·åˆ†åŒº
SELECT 
    user_id,
    order_date, 
    amount,
    ROW_NUMBER() OVER (ORDER BY order_date) as wrong_rank  -- å…¨å±€æ’åºï¼Œä¸åˆ†ç”¨æˆ·
FROM user_orders;

-- è¯Šæ–­ï¼šæ£€æŸ¥åˆ†åŒºæ•ˆæœ
SELECT 
    user_id,
    COUNT(*) as orders_count,
    MIN(order_date) as first_order,
    MAX(order_date) as last_order
FROM user_orders 
GROUP BY user_id;

-- æ­£ç¡®ï¼šæŒ‰ç”¨æˆ·åˆ†åŒº
SELECT 
    user_id,
    order_date,
    amount, 
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date) as correct_rank
FROM user_orders;
```

### 6.2 è°ƒè¯•å·¥å…·å‡½æ•°é›†åˆ


**ğŸ› ï¸ ç»¼åˆè°ƒè¯•å·¥å…·åŒ…**
```sql
-- å·¥å…·1ï¼šçª—å£å‡½æ•°å¥åº·æ£€æŸ¥
CREATE OR REPLACE FUNCTION check_window_function_health(
    query_text TEXT
) RETURNS TABLE (
    check_item TEXT,
    status TEXT,
    suggestion TEXT
) AS $$
BEGIN
    -- æ£€æŸ¥æ˜¯å¦åŒ…å«PARTITION BY
    IF query_text !~* 'PARTITION\s+BY' THEN
        check_item := 'PARTITION BYæ£€æŸ¥';
        status := 'âš ï¸ è­¦å‘Š';
        suggestion := 'è€ƒè™‘æ˜¯å¦éœ€è¦æŒ‰æŸä¸ªå­—æ®µåˆ†åŒºï¼Œé¿å…å…¨å±€è®¡ç®—';
        RETURN NEXT;
    END IF;
    
    -- æ£€æŸ¥æ˜¯å¦æ˜ç¡®æŒ‡å®šçª—å£èŒƒå›´
    IF query_text ~* 'OVER\s*\([^)]*ORDER\s+BY[^)]*\)' AND 
       query_text !~* 'ROWS\s+BETWEEN|RANGE\s+BETWEEN' THEN
        check_item := 'çª—å£èŒƒå›´æ£€æŸ¥';
        status := 'âš ï¸ è­¦å‘Š'; 
        suggestion := 'å»ºè®®æ˜ç¡®æŒ‡å®šçª—å£èŒƒå›´ï¼Œé¿å…ä½¿ç”¨é»˜è®¤çš„RANGE UNBOUNDED PRECEDING';
        RETURN NEXT;
    END IF;
    
    -- æ£€æŸ¥ORDER BYå­—æ®µæ˜¯å¦æœ‰ç´¢å¼•
    check_item := 'ç´¢å¼•æ£€æŸ¥';
    status := 'ğŸ’¡ å»ºè®®';
    suggestion := 'ç¡®ä¿PARTITION BYå’ŒORDER BYå­—æ®µæœ‰é€‚å½“çš„å¤åˆç´¢å¼•';
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM check_window_function_health(
    'SELECT user_id, SUM(amount) OVER (ORDER BY order_date) FROM orders'
);
```

**ğŸ” å·¥å…·2ï¼šçª—å£æ•°æ®å®Œæ•´æ€§éªŒè¯**
```sql
-- éªŒè¯çª—å£å‡½æ•°è®¡ç®—çš„æ­£ç¡®æ€§
CREATE OR REPLACE FUNCTION validate_window_calculation(
    base_table TEXT,
    partition_col TEXT,
    order_col TEXT,
    calc_col TEXT,
    window_spec TEXT
) RETURNS TABLE (
    partition_value TEXT,
    row_number INT,
    input_value NUMERIC,
    window_result NUMERIC,
    manual_calculation NUMERIC,
    is_correct BOOLEAN
) AS $$
BEGIN
    RETURN QUERY EXECUTE format('
        WITH windowed_data AS (
            SELECT 
                %I::TEXT as partition_value,
                ROW_NUMBER() OVER (PARTITION BY %I ORDER BY %I) as row_number,
                %I as input_value,
                SUM(%I) OVER (PARTITION BY %I ORDER BY %I %s) as window_result
            FROM %I
        ),
        manual_calc AS (
            SELECT 
                wd.partition_value,
                wd.row_number,
                wd.input_value,
                wd.window_result,
                -- æ‰‹åŠ¨è®¡ç®—éªŒè¯ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
                (SELECT SUM(base.%I) 
                 FROM %I base 
                 WHERE base.%I = wd.partition_value
                   AND base.%I <= (SELECT orig.%I FROM %I orig 
                                   WHERE orig.%I = wd.partition_value 
                                   ORDER BY orig.%I LIMIT 1 OFFSET (wd.row_number-1))
                ) as manual_calculation
            FROM windowed_data wd
        )
        SELECT 
            partition_value,
            row_number,
            input_value,
            window_result,
            manual_calculation,
            ABS(window_result - manual_calculation) < 0.01 as is_correct
        FROM manual_calc
        ORDER BY partition_value, row_number
    ', partition_col, partition_col, order_col, calc_col, calc_col, partition_col, 
       order_col, window_spec, base_table, calc_col, base_table, partition_col, 
       order_col, order_col, base_table, partition_col, order_col);
END;
$$ LANGUAGE plpgsql;
```

### 6.3 é”™è¯¯æ¨¡å¼è¯†åˆ«


**ğŸ” å¸¸è§é”™è¯¯æ¨¡å¼åº“**
```sql
-- é”™è¯¯æ¨¡å¼æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION detect_window_function_antipatterns(
    query_text TEXT
) RETURNS TABLE (
    antipattern_type TEXT,
    severity TEXT, 
    description TEXT,
    fix_suggestion TEXT
) AS $$
BEGIN
    -- åæ¨¡å¼1ï¼šåœ¨WHEREå­å¥ä¸­ä½¿ç”¨çª—å£å‡½æ•°
    IF query_text ~* 'WHERE.*OVER\s*\(' THEN
        antipattern_type := 'çª—å£å‡½æ•°ä½ç½®é”™è¯¯';
        severity := 'ğŸ”´ ä¸¥é‡';
        description := 'çª—å£å‡½æ•°ä¸èƒ½ç›´æ¥ç”¨åœ¨WHEREå­å¥ä¸­';
        fix_suggestion := 'ä½¿ç”¨å­æŸ¥è¯¢æˆ–CTEï¼Œåœ¨å¤–å±‚æŸ¥è¯¢ä¸­è¿‡æ»¤çª—å£å‡½æ•°ç»“æœ';
        RETURN NEXT;
    END IF;
    
    -- åæ¨¡å¼2ï¼šè¿‡åº¦ä½¿ç”¨çª—å£å‡½æ•°
    IF (LENGTH(query_text) - LENGTH(REPLACE(UPPER(query_text), 'OVER', ''))) / 4 > 5 THEN
        antipattern_type := 'çª—å£å‡½æ•°è¿‡åº¦ä½¿ç”¨';
        severity := 'ğŸŸ¡ è­¦å‘Š';
        description := 'æŸ¥è¯¢ä¸­åŒ…å«è¿‡å¤šçª—å£å‡½æ•°ï¼Œå¯èƒ½å½±å“æ€§èƒ½';
        fix_suggestion := 'è€ƒè™‘åˆå¹¶ç›¸ä¼¼çš„çª—å£å‡½æ•°ï¼Œæˆ–åˆ†æ­¥è®¡ç®—';
        RETURN NEXT;
    END IF;
    
    -- åæ¨¡å¼3ï¼šæœªæŒ‡å®šçª—å£èŒƒå›´çš„ORDER BY
    IF query_text ~* 'OVER\s*\([^)]*ORDER\s+BY[^)]*\)' AND 
       query_text !~* 'ROWS|RANGE' THEN
        antipattern_type := 'éšå¼çª—å£èŒƒå›´';
        severity := 'ğŸŸ¡ è­¦å‘Š';
        description := 'ä½¿ç”¨äº†ORDER BYä½†æœªæ˜ç¡®æŒ‡å®šçª—å£èŒƒå›´ï¼Œä½¿ç”¨äº†é»˜è®¤çš„RANGE UNBOUNDED PRECEDING';
        fix_suggestion := 'æ˜ç¡®æŒ‡å®šROWS BETWEENæˆ–RANGE BETWEENå­å¥';
        RETURN NEXT;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM detect_window_function_antipatterns('
    SELECT user_id, amount,
           SUM(amount) OVER (ORDER BY order_date),
           AVG(amount) OVER (ORDER BY order_date),
           COUNT(*) OVER (ORDER BY order_date)
    FROM orders 
    WHERE SUM(amount) OVER (PARTITION BY user_id) > 1000
');
```

### 6.4 å®æˆ˜é—®é¢˜å®šä½æµç¨‹


**ğŸ”§ ç³»ç»ŸåŒ–é—®é¢˜å®šä½æ–¹æ³•**

```
é—®é¢˜å®šä½æ£€æŸ¥æ¸…å•ï¼š

ğŸ“‹ ç¬¬ä¸€æ­¥ï¼šåŸºç¡€æ•°æ®æ£€æŸ¥
â–¡ æºæ•°æ®æ˜¯å¦å®Œæ•´ï¼Ÿ
â–¡ æ•°æ®ç±»å‹æ˜¯å¦æ­£ç¡®ï¼Ÿ
â–¡ æ˜¯å¦å­˜åœ¨NULLå€¼ï¼Ÿ
â–¡ æ—¥æœŸæ ¼å¼æ˜¯å¦ç»Ÿä¸€ï¼Ÿ

ğŸ“‹ ç¬¬äºŒæ­¥ï¼šçª—å£è®¾ç½®æ£€æŸ¥  
â–¡ PARTITION BYå­—æ®µæ˜¯å¦æ­£ç¡®ï¼Ÿ
â–¡ ORDER BYå­—æ®µæ˜¯å¦ç¬¦åˆä¸šåŠ¡é€»è¾‘ï¼Ÿ
â–¡ çª—å£èŒƒå›´æ˜¯å¦æ˜ç¡®æŒ‡å®šï¼Ÿ
â–¡ æ˜¯å¦éœ€è¦å¤„ç†é‡å¤å€¼ï¼Ÿ

ğŸ“‹ ç¬¬ä¸‰æ­¥ï¼šè®¡ç®—é€»è¾‘æ£€æŸ¥
â–¡ çª—å£å‡½æ•°é€‰æ‹©æ˜¯å¦åˆé€‚ï¼Ÿ
â–¡ èšåˆå‡½æ•°æ˜¯å¦æ­£ç¡®ï¼Ÿ
â–¡ æ˜¯å¦è€ƒè™‘äº†è¾¹ç•Œæ¡ä»¶ï¼Ÿ
â–¡ è®¡ç®—ç»“æœæ˜¯å¦åœ¨åˆç†èŒƒå›´å†…ï¼Ÿ

ğŸ“‹ ç¬¬å››æ­¥ï¼šæ€§èƒ½æ£€æŸ¥
â–¡ æ˜¯å¦æœ‰é€‚å½“çš„ç´¢å¼•ï¼Ÿ
â–¡ æŸ¥è¯¢æ‰§è¡Œæ—¶é—´æ˜¯å¦åˆç†ï¼Ÿ
â–¡ å†…å­˜ä½¿ç”¨æ˜¯å¦æ­£å¸¸ï¼Ÿ
â–¡ æ˜¯å¦å¯ä»¥ä¼˜åŒ–ï¼Ÿ
```

**ğŸ› ï¸ å®æˆ˜è°ƒè¯•æ¡ˆä¾‹**
```sql
-- æ¡ˆä¾‹ï¼šç”¨æˆ·æœˆåº¦æ¶ˆè´¹è¶‹åŠ¿åˆ†æå‡ºç°å¼‚å¸¸

-- é—®é¢˜SQL
SELECT 
    user_id,
    DATE_TRUNC('month', order_date) as month,
    SUM(amount) as monthly_total,
    LAG(SUM(amount)) OVER (PARTITION BY user_id ORDER BY DATE_TRUNC('month', order_date)) as prev_month,
    SUM(amount) - LAG(SUM(amount)) OVER (PARTITION BY user_id ORDER BY DATE_TRUNC('month', order_date)) as month_change
FROM user_orders
GROUP BY user_id, DATE_TRUNC('month', order_date);

-- è°ƒè¯•æ­¥éª¤1ï¼šæ£€æŸ¥åŸºç¡€èšåˆ
SELECT 
    user_id,
    DATE_TRUNC('month', order_date) as month,
    COUNT(*) as order_count,
    SUM(amount) as monthly_total
FROM user_orders
GROUP BY user_id, DATE_TRUNC('month', order_date)
ORDER BY user_id, month;

-- è°ƒè¯•æ­¥éª¤2ï¼šæ£€æŸ¥çª—å£å‡½æ•°åˆ†åŒº
WITH monthly_data AS (
    SELECT 
        user_id,
        DATE_TRUNC('month', order_date) as month,
        SUM(amount) as monthly_total
    FROM user_orders
    GROUP BY user_id, DATE_TRUNC('month', order_date)
)
SELECT 
    user_id,
    month,
    monthly_total,
    -- æ˜¾ç¤ºå‰åæœˆä»½ï¼ŒéªŒè¯æ’åº
    LAG(month) OVER (PARTITION BY user_id ORDER BY month) as prev_month_date,
    LEAD(month) OVER (PARTITION BY user_id ORDER BY month) as next_month_date,
    -- è®¡ç®—æœˆåº¦å˜åŒ–
    LAG(monthly_total) OVER (PARTITION BY user_id ORDER BY month) as prev_month_total,
    monthly_total - LAG(monthly_total) OVER (PARTITION BY user_id ORDER BY month) as change
FROM monthly_data
ORDER BY user_id, month;
```

---

## 7. ğŸª é«˜çº§è°ƒè¯•æŠ€å·§


### 7.1 çª—å£å‡½æ•°æ€§èƒ½Profile


**ğŸ“Š è¯¦ç»†æ€§èƒ½åˆ†æ**
```sql
-- åˆ›å»ºçª—å£å‡½æ•°æ€§èƒ½å‰–æå™¨
CREATE OR REPLACE FUNCTION profile_window_query(query_text TEXT)
RETURNS TABLE (
    metric_name TEXT,
    value NUMERIC,
    unit TEXT,
    status TEXT
) AS $$
DECLARE 
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    query_plan TEXT;
    total_cost NUMERIC;
BEGIN
    -- æ‰§è¡ŒEXPLAIN ANALYZEè·å–è¯¦ç»†ä¿¡æ¯
    start_time := clock_timestamp();
    
    -- è·å–æ‰§è¡Œè®¡åˆ’
    EXECUTE 'EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) ' || query_text 
    INTO query_plan;
    
    end_time := clock_timestamp();
    
    -- æå–å…³é”®æ€§èƒ½æŒ‡æ ‡
    metric_name := 'æ€»æ‰§è¡Œæ—¶é—´';
    value := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    unit := 'ms';
    status := CASE WHEN value < 100 THEN 'âœ… ä¼˜ç§€'
                   WHEN value < 1000 THEN 'ğŸŸ¡ ä¸€èˆ¬' 
                   ELSE 'ğŸ”´ éœ€ä¼˜åŒ–' END;
    RETURN NEXT;
    
    -- æ›´å¤šæ€§èƒ½æŒ‡æ ‡...
END;
$$ LANGUAGE plpgsql;
```

### 7.2 çª—å£å‡½æ•°ä»£ç ç”Ÿæˆå™¨


**ğŸ¤– æ™ºèƒ½ä»£ç ç”Ÿæˆ**
```sql
-- çª—å£å‡½æ•°ä»£ç ç”ŸæˆåŠ©æ‰‹
CREATE OR REPLACE FUNCTION generate_window_function_template(
    table_name TEXT,
    partition_columns TEXT[],
    order_columns TEXT[],
    calculation_type TEXT,
    target_column TEXT
) RETURNS TEXT AS $$
DECLARE
    partition_clause TEXT := '';
    order_clause TEXT := '';
    window_clause TEXT;
    template TEXT;
BEGIN
    -- æ„å»ºPARTITION BYå­å¥
    IF array_length(partition_columns, 1) > 0 THEN
        partition_clause := 'PARTITION BY ' || array_to_string(partition_columns, ', ');
    END IF;
    
    -- æ„å»ºORDER BYå­å¥  
    IF array_length(order_columns, 1) > 0 THEN
        order_clause := 'ORDER BY ' || array_to_string(order_columns, ', ');
    END IF;
    
    -- ç»„åˆçª—å£å­å¥
    window_clause := TRIM(partition_clause || ' ' || order_clause);
    
    -- ç”Ÿæˆæ¨¡æ¿
    template := format('
-- çª—å£å‡½æ•°æ¨¡æ¿ï¼š%s
SELECT 
    %s,
    %s,
    %s(%s) OVER (%s) as %s_result
FROM %s
ORDER BY %s;

-- è°ƒè¯•ç‰ˆæœ¬ï¼š
SELECT 
    %s,
    %s, 
    %s,
    ROW_NUMBER() OVER (%s) as row_num,
    COUNT(*) OVER (%s) as window_size,
    %s(%s) OVER (%s) as result
FROM %s
ORDER BY %s;
',
    calculation_type,
    array_to_string(partition_columns, ', '),
    array_to_string(order_columns, ', '),
    UPPER(calculation_type), target_column, window_clause, calculation_type, table_name,
    array_to_string(order_columns, ', '),
    
    array_to_string(partition_columns, ', '),
    array_to_string(order_columns, ', '),
    target_column,
    window_clause, window_clause,
    UPPER(calculation_type), target_column, window_clause, table_name,
    array_to_string(order_columns, ', ')
);
    
    RETURN template;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT generate_window_function_template(
    'user_orders',                    -- è¡¨å
    ARRAY['user_id'],                -- åˆ†åŒºå­—æ®µ
    ARRAY['order_date'],             -- æ’åºå­—æ®µ  
    'sum',                           -- è®¡ç®—ç±»å‹
    'amount'                         -- ç›®æ ‡å­—æ®µ
);
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„è°ƒè¯•æŠ€èƒ½


```
ğŸ”¸ çª—å£èŒƒå›´ç†è§£ï¼šæ¸…æ¥šæ¯è¡Œè®¡ç®—æ—¶åŒ…å«å“ªäº›æ•°æ®
ğŸ”¸ åˆ†æ­¥éªŒè¯æ–¹æ³•ï¼šå¤æ‚æŸ¥è¯¢åˆ†è§£ä¸ºç®€å•æ­¥éª¤éªŒè¯
ğŸ”¸ å¯è§†åŒ–æŠ€æœ¯ï¼šç”¨è¾…åŠ©æŸ¥è¯¢æ˜¾ç¤ºçª—å£èŒƒå›´å’Œè®¡ç®—è¿‡ç¨‹
ğŸ”¸ æ€§èƒ½åˆ†æï¼šè¯†åˆ«æ€§èƒ½ç“¶é¢ˆï¼Œä¼˜åŒ–æŸ¥è¯¢æ•ˆç‡
ğŸ”¸ é”™è¯¯è¯†åˆ«ï¼šå¿«é€Ÿè¯†åˆ«å¸¸è§é”™è¯¯æ¨¡å¼å’Œè§£å†³æ–¹æ¡ˆ
```

### 8.2 å…³é”®è°ƒè¯•æ€è·¯


**ğŸ”¹ ç†è§£çª—å£æœºåˆ¶**
```
è°ƒè¯•å‰æï¼š
- çª—å£å‡½æ•°æ˜¯"è¡Œçº§"è®¡ç®—ï¼Œæ¯è¡Œéƒ½æœ‰è‡ªå·±çš„çª—å£
- çª—å£èŒƒå›´ç”±PARTITION BYã€ORDER BYã€çª—å£èŒƒå›´å­å¥å†³å®š
- ç†è§£ROWSå’ŒRANGEçš„åŒºåˆ«æ˜¯è°ƒè¯•çš„åŸºç¡€
```

**ğŸ”¹ åˆ†å±‚è°ƒè¯•ç­–ç•¥**
```
æ•°æ®å±‚ï¼šæ£€æŸ¥æºæ•°æ®è´¨é‡å’Œå®Œæ•´æ€§
é€»è¾‘å±‚ï¼šéªŒè¯åˆ†åŒºã€æ’åºã€çª—å£èŒƒå›´è®¾ç½®
è®¡ç®—å±‚ï¼šç¡®è®¤èšåˆå‡½æ•°å’Œè®¡ç®—é€»è¾‘
æ€§èƒ½å±‚ï¼šåˆ†ææ‰§è¡Œè®¡åˆ’å’Œèµ„æºä½¿ç”¨
```

**ğŸ”¹ å·¥å…·åŒ–è°ƒè¯•**
```
å¯è§†åŒ–å·¥å…·ï¼šæ˜¾ç¤ºçª—å£èŒƒå›´å’Œè®¡ç®—è¿‡ç¨‹
æµ‹è¯•æ¡†æ¶ï¼šè‡ªåŠ¨åŒ–éªŒè¯è®¡ç®—æ­£ç¡®æ€§  
æ€§èƒ½å·¥å…·ï¼šç›‘æ§å’Œåˆ†ææŸ¥è¯¢æ€§èƒ½
æ¨¡å¼æ£€æµ‹ï¼šè‡ªåŠ¨è¯†åˆ«å¸¸è§é”™è¯¯æ¨¡å¼
```

### 8.3 å®æˆ˜è°ƒè¯•checklist


> **ğŸ¯ è°ƒè¯•æ£€æŸ¥æ¸…å•**
>
> å½“çª—å£å‡½æ•°å‡ºç°é—®é¢˜æ—¶ï¼ŒæŒ‰ç…§ä»¥ä¸‹æ¸…å•é€é¡¹æ£€æŸ¥ï¼š

**ğŸ“‹ æ•°æ®æ£€æŸ¥**
- âœ… æºæ•°æ®æ˜¯å¦å®Œæ•´æ— ç¼ºå¤±ï¼Ÿ
- âœ… æ•°æ®ç±»å‹æ˜¯å¦æ­£ç¡®ï¼Ÿ
- âœ… æ˜¯å¦å­˜åœ¨å¼‚å¸¸å€¼æˆ–NULLï¼Ÿ
- âœ… æ—¥æœŸ/æ—¶é—´æ ¼å¼æ˜¯å¦ç»Ÿä¸€ï¼Ÿ

**ğŸ“‹ é€»è¾‘æ£€æŸ¥**
- âœ… PARTITION BYå­—æ®µæ˜¯å¦ç¬¦åˆä¸šåŠ¡éœ€æ±‚ï¼Ÿ
- âœ… ORDER BYå­—æ®µæ˜¯å¦æ­£ç¡®ï¼Ÿ
- âœ… çª—å£èŒƒå›´è®¾ç½®æ˜¯å¦åˆç†ï¼Ÿ
- âœ… èšåˆå‡½æ•°é€‰æ‹©æ˜¯å¦æ­£ç¡®ï¼Ÿ

**ğŸ“‹ æ€§èƒ½æ£€æŸ¥**
- âœ… ç›¸å…³å­—æ®µæ˜¯å¦æœ‰ç´¢å¼•ï¼Ÿ
- âœ… æŸ¥è¯¢æ‰§è¡Œæ—¶é—´æ˜¯å¦åˆç†ï¼Ÿ
- âœ… å†…å­˜ä½¿ç”¨æ˜¯å¦æ­£å¸¸ï¼Ÿ
- âœ… æ˜¯å¦å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Ÿ

### 8.4 æœ€ä½³å®è·µå»ºè®®


**ğŸ† è°ƒè¯•æœ€ä½³å®è·µ**
- **å…ˆç®€å•åå¤æ‚**ï¼šä»ç®€å•çª—å£å‡½æ•°å¼€å§‹éªŒè¯ï¼Œé€æ­¥å¢åŠ å¤æ‚åº¦
- **å°æ•°æ®é›†æµ‹è¯•**ï¼šç”¨å°æ•°æ®é›†éªŒè¯é€»è¾‘ï¼Œç¡®è®¤æ— è¯¯åå†ç”¨å¤§æ•°æ®é›†
- **åˆ†æ­¥éªŒè¯**ï¼šå¤æ‚çª—å£å‡½æ•°åˆ†è§£ä¸ºå¤šä¸ªæ­¥éª¤ï¼Œé€æ­¥éªŒè¯
- **å»ºç«‹åŸºå‡†**ï¼šä¸ºå¸¸ç”¨çª—å£å‡½æ•°å»ºç«‹æ€§èƒ½åŸºå‡†ï¼Œä¾¿äºå¯¹æ¯”
- **æ–‡æ¡£è®°å½•**ï¼šè®°å½•è°ƒè¯•è¿‡ç¨‹å’Œè§£å†³æ–¹æ¡ˆï¼Œç§¯ç´¯ç»éªŒ

**ğŸ’¡ è°ƒè¯•æ•ˆç‡æå‡**
- **å·¥å…·å¤ç”¨**ï¼šå»ºç«‹è°ƒè¯•å‡½æ•°åº“ï¼Œé‡å¤ä½¿ç”¨
- **æ¨¡æ¿åº”ç”¨**ï¼šä½¿ç”¨è°ƒè¯•æ¨¡æ¿å¿«é€Ÿå®šä½é—®é¢˜
- **è‡ªåŠ¨åŒ–æµ‹è¯•**ï¼šå»ºç«‹è‡ªåŠ¨åŒ–æµ‹è¯•ä½“ç³»ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
- **çŸ¥è¯†åˆ†äº«**ï¼šå›¢é˜Ÿåˆ†äº«è°ƒè¯•ç»éªŒå’Œå·¥å…·

**æ ¸å¿ƒè®°å¿†**ï¼š
- çª—å£å‡½æ•°è°ƒè¯•çš„å…³é”®æ˜¯ç†è§£"çª—å£èŒƒå›´"
- åˆ†æ­¥éªŒè¯æ˜¯æœ€æœ‰æ•ˆçš„è°ƒè¯•æ–¹æ³•
- å¯è§†åŒ–æŠ€æœ¯å¸®åŠ©ç†è§£å¤æ‚çš„çª—å£è®¡ç®—
- æ€§èƒ½åˆ†æå’Œé”™è¯¯æ¨¡å¼è¯†åˆ«æ˜¯é«˜çº§è°ƒè¯•æŠ€èƒ½
- å»ºç«‹å·¥å…·åº“å’Œæµ‹è¯•æ¡†æ¶å¯ä»¥å¤§å¹…æå‡è°ƒè¯•æ•ˆç‡