---
title: 2、SQL排名窗口函数详解
---
## 📚 目录

1. [排名窗口函数概述](#1-排名窗口函数概述)
2. [基础排名函数详解](#2-基础排名函数详解)
3. [高级排名函数应用](#3-高级排名函数应用)
4. [排名函数实战应用](#4-排名函数实战应用)
5. [性能优化与选择策略](#5-性能优化与选择策略)
6. [常见问题与最佳实践](#6-常见问题与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 排名窗口函数概述


### 1.1 什么是排名窗口函数


**🔸 核心概念**
```
排名窗口函数：对查询结果集中的每一行计算排名位置
特点：
• 不改变结果集的行数
• 为每行添加排名信息
• 支持分组内排名
• 可以处理相同值的排名规则
```

**💡 排名函数的应用价值**
- **数据分析**：统计排名、百分位数分析
- **业务排序**：销售排行榜、成绩排名
- **数据分层**：将数据分成不同等级或分组
- **TopN查询**：查询前N名的记录

### 1.2 排名函数分类


**📊 排名函数家族**
```
基础排名函数：
├── ROW_NUMBER()：连续排名，不重复
├── RANK()：跳跃排名，相同值并列  
├── DENSE_RANK()：密集排名，相同值并列但不跳跃
└── NTILE()：分桶排名，将数据分成N组

高级排名函数：
├── CUME_DIST()：累积分布比例
└── PERCENT_RANK()：百分比排名
```

### 1.3 窗口函数基本语法


**📝 标准语法结构**
```sql
排名函数() OVER (
    [PARTITION BY column1, column2, ...]  -- 分组
    ORDER BY column3 [ASC|DESC]           -- 排序
)
```

**🔍 语法要素说明**
```
OVER子句：定义窗口范围
├── PARTITION BY：按字段分组（可选）
│   作用：在每个分组内独立排名
│   示例：按部门分组，每个部门内排名
│
└── ORDER BY：排序规则（必需）
    作用：决定排名的顺序
    示例：按薪资降序排列
```

---

## 2. 🔢 基础排名函数详解


### 2.1 ROW_NUMBER()：连续排名


**🎯 ROW_NUMBER特点**
```
连续排名规则：
• 为每一行分配唯一的连续数字
• 相同值也会有不同的排名
• 排名从1开始，连续递增
• 不会出现并列排名
```

**💻 基础使用示例**
```sql
-- 示例数据：员工薪资表
SELECT 
    employee_name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num
FROM employees;

-- 结果示例：
┌──────────────┬────────┬─────────┐
│ employee_name│ salary │ row_num │
├──────────────┼────────┼─────────┤
│ 张三         │ 10000  │    1    │
│ 李四         │ 9000   │    2    │
│ 王五         │ 9000   │    3    │ ← 相同薪资不同排名
│ 赵六         │ 8000   │    4    │
└──────────────┴────────┴─────────┘
```

**🔸 分区内连续排名**
```sql
-- 按部门分组，部门内按薪资排名
SELECT 
    department,
    employee_name,
    salary,
    ROW_NUMBER() OVER (
        PARTITION BY department 
        ORDER BY salary DESC
    ) as dept_rank
FROM employees;

-- 结果：每个部门内独立排名
┌────────────┬──────────────┬────────┬───────────┐
│ department │ employee_name│ salary │ dept_rank │
├────────────┼──────────────┼────────┼───────────┤
│ IT         │ 张三         │ 12000  │     1     │
│ IT         │ 李四         │ 10000  │     2     │
│ HR         │ 王五         │ 8000   │     1     │
│ HR         │ 赵六         │ 7000   │     2     │
└────────────┴──────────────┴────────┴───────────┘
```

### 2.2 RANK()：跳跃排名


**🎯 RANK特点**
```
跳跃排名规则：
• 相同值获得相同排名
• 下一个排名会跳跃相应位置
• 适合处理并列情况
• 排名可能不连续
```

**💻 RANK使用示例**
```sql
SELECT 
    employee_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) as rank_num
FROM employees;

-- 结果对比ROW_NUMBER：
┌──────────────┬────────┬──────────┐
│ employee_name│ salary │ rank_num │
├──────────────┼────────┼──────────┤
│ 张三         │ 10000  │    1     │
│ 李四         │ 9000   │    2     │
│ 王五         │ 9000   │    2     │ ← 并列第2名
│ 赵六         │ 8000   │    4     │ ← 跳跃到第4名
└──────────────┴────────┴──────────┘
```

### 2.3 DENSE_RANK()：密集排名


**🎯 DENSE_RANK特点**
```
密集排名规则：
• 相同值获得相同排名
• 下一个排名不会跳跃
• 排名始终连续
• 最适合真正的"名次"概念
```

**💻 DENSE_RANK使用示例**
```sql
SELECT 
    employee_name,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank_num
FROM employees;

-- 结果：
┌──────────────┬────────┬─────────────────┐
│ employee_name│ salary │ dense_rank_num  │
├──────────────┼────────┼─────────────────┤
│ 张三         │ 10000  │        1        │
│ 李四         │ 9000   │        2        │
│ 王五         │ 9000   │        2        │ ← 并列第2名
│ 赵六         │ 8000   │        3        │ ← 紧接着第3名
└──────────────┴────────┴─────────────────┘
```

### 2.4 三种排名函数对比


**📊 排名结果对比表**

| 姓名 | 薪资 | **ROW_NUMBER** | **RANK** | **DENSE_RANK** |
|------|------|----------------|----------|----------------|
| 张三 | 10000 | `1` | `1` | `1` |
| 李四 | 9000 | `2` | `2` | `2` |
| 王五 | 9000 | `3` | `2` | `2` |
| 赵六 | 8000 | `4` | `4` | `3` |
| 孙七 | 8000 | `5` | `4` | `3` |
| 周八 | 7000 | `6` | `6` | `4` |

**💡 选择建议**
```
使用场景选择：
ROW_NUMBER()：
✅ 需要唯一标识每一行
✅ 分页查询
✅ 去重时保留一条记录

RANK()：
✅ 传统排名场景（如奥运会排名）
✅ 需要体现并列和跳跃

DENSE_RANK()：
✅ 连续等级排名
✅ 成绩等级划分
✅ 业务层级排名
```

### 2.5 NTILE()：分桶函数


**🎯 NTILE分桶机制**
```
分桶规则：
• 将结果集分成N个大致相等的组
• 每组分配一个桶号（1到N）
• 如果不能平均分配，前面的桶可能多一条记录
• 常用于数据分层分析
```

**💻 NTILE使用示例**
```sql
-- 将员工按薪资分成4个等级
SELECT 
    employee_name,
    salary,
    NTILE(4) OVER (ORDER BY salary DESC) as salary_quartile
FROM employees;

-- 结果示例（假设有12个员工）：
┌──────────────┬────────┬──────────────────┐
│ employee_name│ salary │ salary_quartile  │
├──────────────┼────────┼──────────────────┤
│ 员工1        │ 15000  │        1         │ ← 高薪组
│ 员工2        │ 14000  │        1         │
│ 员工3        │ 13000  │        1         │
│ 员工4        │ 12000  │        2         │ ← 中高薪组
│ 员工5        │ 11000  │        2         │
│ 员工6        │ 10000  │        2         │
│ 员工7        │ 9000   │        3         │ ← 中等薪资组
│ 员工8        │ 8000   │        3         │
│ 员工9        │ 7000   │        3         │
│ 员工10       │ 6000   │        4         │ ← 基础薪资组
│ 员工11       │ 5000   │        4         │
│ 员工12       │ 4000   │        4         │
└──────────────┴────────┴──────────────────┘
```

**🎯 NTILE实际应用**
```sql
-- 按销售额将销售员分成3个层级
SELECT 
    salesperson,
    sales_amount,
    NTILE(3) OVER (ORDER BY sales_amount DESC) as performance_tier,
    CASE 
        WHEN NTILE(3) OVER (ORDER BY sales_amount DESC) = 1 
        THEN '顶尖销售'
        WHEN NTILE(3) OVER (ORDER BY sales_amount DESC) = 2 
        THEN '优秀销售'
        ELSE '普通销售'
    END as performance_level
FROM sales_data;
```

---

## 3. 🔥 高级排名函数应用


### 3.1 CUME_DIST()：累积分布


**🎯 CUME_DIST函数原理**
```
累积分布定义：
• 计算某个值在整个数据集中的累积分布比例
• 返回值范围：0 < CUME_DIST ≤ 1
• 公式：(小于等于当前值的行数) / (总行数)
• 用途：了解数据的分布情况
```

**💻 CUME_DIST实际应用**
```sql
-- 计算员工薪资的累积分布
SELECT 
    employee_name,
    salary,
    CUME_DIST() OVER (ORDER BY salary) as salary_percentile,
    CONCAT(ROUND(CUME_DIST() OVER (ORDER BY salary) * 100, 1), '%') as percentile_str
FROM employees
ORDER BY salary;

-- 结果示例：
┌──────────────┬────────┬───────────────────┬───────────────┐
│ employee_name│ salary │ salary_percentile │ percentile_str│
├──────────────┼────────┼───────────────────┼───────────────┤
│ 新员工       │ 4000   │      0.1667       │    16.7%     │
│ 初级员工     │ 5000   │      0.3333       │    33.3%     │
│ 中级员工     │ 7000   │      0.5000       │    50.0%     │
│ 高级员工     │ 9000   │      0.8333       │    83.3%     │
│ 资深员工     │ 12000  │      1.0000       │   100.0%     │
└──────────────┴────────┴───────────────────┴───────────────┘

-- 解读：薪资7000的员工超过了50%的员工
```

**📊 CUME_DIST业务应用场景**
```sql
-- 分析学生成绩分布
SELECT 
    student_name,
    score,
    CUME_DIST() OVER (ORDER BY score DESC) as score_percentile,
    CASE 
        WHEN CUME_DIST() OVER (ORDER BY score DESC) <= 0.1 THEN '优秀(前10%)'
        WHEN CUME_DIST() OVER (ORDER BY score DESC) <= 0.3 THEN '良好(前30%)'
        WHEN CUME_DIST() OVER (ORDER BY score DESC) <= 0.7 THEN '中等(前70%)'
        ELSE '需要努力'
    END as performance_level
FROM student_scores;
```

### 3.2 PERCENT_RANK()：百分比排名


**🎯 PERCENT_RANK函数机制**
```
百分比排名定义：
• 计算某行相对于其他行的相对排名
• 返回值范围：0 ≤ PERCENT_RANK ≤ 1
• 公式：(RANK() - 1) / (总行数 - 1)
• 第一名的PERCENT_RANK始终为0
```

**💻 PERCENT_RANK使用示例**
```sql
-- 计算员工薪资的百分比排名
SELECT 
    employee_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) as rank_position,
    PERCENT_RANK() OVER (ORDER BY salary DESC) as percent_rank,
    CONCAT(ROUND(PERCENT_RANK() OVER (ORDER BY salary DESC) * 100, 1), '%') as rank_percentage
FROM employees
ORDER BY salary DESC;

-- 结果示例：
┌──────────────┬────────┬─────────────┬──────────────┬────────────────┐
│ employee_name│ salary │rank_position│ percent_rank │ rank_percentage│
├──────────────┼────────┼─────────────┼──────────────┼────────────────┤
│ CEO          │ 20000  │      1      │    0.0000    │     0.0%      │
│ 副总         │ 15000  │      2      │    0.2500    │    25.0%      │
│ 经理         │ 12000  │      3      │    0.5000    │    50.0%      │
│ 主管         │ 8000   │      4      │    0.7500    │    75.0%      │
│ 员工         │ 5000   │      5      │    1.0000    │   100.0%      │
└──────────────┴────────┴─────────────┴──────────────┴────────────────┘

-- 解读：副总的排名超过了75%的员工(100% - 25% = 75%)
```

**🎯 CUME_DIST vs PERCENT_RANK对比**

```sql
-- 对比两个函数的差异
SELECT 
    employee_name,
    salary,
    CUME_DIST() OVER (ORDER BY salary) as cume_dist,
    PERCENT_RANK() OVER (ORDER BY salary) as percent_rank,
    CONCAT('累积分布: ', ROUND(CUME_DIST() OVER (ORDER BY salary) * 100, 1), '%') as cume_explanation,
    CONCAT('百分比排名: ', ROUND((1 - PERCENT_RANK() OVER (ORDER BY salary)) * 100, 1), '%') as rank_explanation
FROM employees
ORDER BY salary;
```

**💡 两个函数的实际含义**
```
CUME_DIST()：回答"有多少比例的人薪资不超过我？"
PERCENT_RANK()：回答"我的排名位置占总体的百分之几？"

业务理解：
• CUME_DIST = 0.7：70%的人薪资不超过我
• PERCENT_RANK = 0.3：我的排名在总体的30%位置（即前30%）
```

---

## 4. 🏆 排名函数实战应用


### 4.1 销售排行榜制作


**📊 多维度销售排名**
```sql
-- 销售业绩综合排名分析
WITH sales_analysis AS (
    SELECT 
        salesperson_name,
        region,
        total_sales,
        sales_count,
        -- 全公司排名
        ROW_NUMBER() OVER (ORDER BY total_sales DESC) as company_rank,
        DENSE_RANK() OVER (ORDER BY total_sales DESC) as sales_tier,
        -- 区域内排名
        RANK() OVER (PARTITION BY region ORDER BY total_sales DESC) as region_rank,
        -- 业绩分层
        NTILE(4) OVER (ORDER BY total_sales DESC) as performance_quartile,
        -- 百分位分析
        CUME_DIST() OVER (ORDER BY total_sales) as sales_percentile
    FROM sales_summary
)
SELECT 
    salesperson_name,
    region,
    total_sales,
    company_rank,
    region_rank,
    CASE performance_quartile
        WHEN 1 THEN 'Top Performer'
        WHEN 2 THEN 'High Performer'  
        WHEN 3 THEN 'Average Performer'
        ELSE 'Developing Performer'
    END as performance_level,
    CONCAT(ROUND(sales_percentile * 100, 1), '%') as percentile_position
FROM sales_analysis
ORDER BY total_sales DESC;
```

### 4.2 学生成绩排名系统


**🎓 教育数据排名分析**
```sql
-- 学生成绩多维度排名
SELECT 
    student_id,
    student_name,
    class_name,
    subject,
    score,
    -- 全校排名
    DENSE_RANK() OVER (PARTITION BY subject ORDER BY score DESC) as school_rank,
    -- 班级内排名
    RANK() OVER (PARTITION BY class_name, subject ORDER BY score DESC) as class_rank,
    -- 成绩等级
    NTILE(5) OVER (PARTITION BY subject ORDER BY score DESC) as grade_level,
    -- 百分位位置
    PERCENT_RANK() OVER (PARTITION BY subject ORDER BY score DESC) as percentile_rank,
    -- 成绩等级标签
    CASE 
        WHEN NTILE(5) OVER (PARTITION BY subject ORDER BY score DESC) = 1 THEN 'A级优秀'
        WHEN NTILE(5) OVER (PARTITION BY subject ORDER BY score DESC) = 2 THEN 'B级良好'
        WHEN NTILE(5) OVER (PARTITION BY subject ORDER BY score DESC) = 3 THEN 'C级中等'
        WHEN NTILE(5) OVER (PARTITION BY subject ORDER BY score DESC) = 4 THEN 'D级合格'
        ELSE 'E级待提高'
    END as grade_label
FROM student_scores
ORDER BY subject, score DESC;
```

### 4.3 电商产品排名


**🛒 产品销售数据排名**
```sql
-- 产品销售表现排名
WITH product_metrics AS (
    SELECT 
        product_name,
        category,
        total_revenue,
        units_sold,
        avg_rating,
        review_count,
        -- 收入排名
        DENSE_RANK() OVER (ORDER BY total_revenue DESC) as revenue_rank,
        DENSE_RANK() OVER (PARTITION BY category ORDER BY total_revenue DESC) as category_revenue_rank,
        -- 销量排名  
        DENSE_RANK() OVER (ORDER BY units_sold DESC) as volume_rank,
        -- 评分排名
        DENSE_RANK() OVER (ORDER BY avg_rating DESC, review_count DESC) as rating_rank,
        -- 综合表现分层
        NTILE(3) OVER (ORDER BY (total_revenue * 0.4 + units_sold * 0.3 + avg_rating * review_count * 0.3) DESC) as overall_tier
    FROM product_sales_summary
)
SELECT 
    product_name,
    category,
    total_revenue,
    revenue_rank,
    category_revenue_rank,
    volume_rank,
    rating_rank,
    CASE overall_tier
        WHEN 1 THEN '明星产品'
        WHEN 2 THEN '热门产品'
        ELSE '普通产品'
    END as product_tier
FROM product_metrics
WHERE revenue_rank <= 50  -- 只看收入前50的产品
ORDER BY revenue_rank;
```

### 4.4 网站流量分析排名


**📈 访问数据排名分析**
```sql
-- 网站页面流量排名
SELECT 
    page_url,
    page_title,
    daily_visits,
    bounce_rate,
    avg_session_duration,
    -- 访问量排名
    ROW_NUMBER() OVER (ORDER BY daily_visits DESC) as traffic_rank,
    -- 质量评分排名（综合跳出率和停留时间）
    RANK() OVER (ORDER BY (1-bounce_rate) * avg_session_duration DESC) as quality_rank,
    -- 流量分层
    NTILE(10) OVER (ORDER BY daily_visits DESC) as traffic_decile,
    -- 累积流量占比
    CUME_DIST() OVER (ORDER BY daily_visits) as traffic_cumulative,
    -- 流量等级标签
    CASE 
        WHEN NTILE(10) OVER (ORDER BY daily_visits DESC) <= 2 THEN '高流量页面'
        WHEN NTILE(10) OVER (ORDER BY daily_visits DESC) <= 5 THEN '中等流量页面'
        ELSE '低流量页面'
    END as traffic_category
FROM page_analytics
WHERE date_range = '2024-08-01'
ORDER BY daily_visits DESC;
```

---

## 5. ⚡ 性能优化与选择策略


### 5.1 排名函数性能对比


**📊 性能特征分析**

| 函数 | **计算复杂度** | **内存使用** | **适用数据量** | **性能等级** |
|------|---------------|-------------|---------------|-------------|
| **ROW_NUMBER** | `O(n log n)` | `较低` | `大数据量` | `⭐⭐⭐⭐⭐` |
| **RANK** | `O(n log n)` | `中等` | `大数据量` | `⭐⭐⭐⭐` |
| **DENSE_RANK** | `O(n log n)` | `中等` | `中大数据量` | `⭐⭐⭐⭐` |
| **NTILE** | `O(n log n)` | `较低` | `大数据量` | `⭐⭐⭐⭐⭐` |
| **CUME_DIST** | `O(n log n)` | `中高` | `中等数据量` | `⭐⭐⭐` |
| **PERCENT_RANK** | `O(n log n)` | `中高` | `中等数据量` | `⭐⭐⭐` |

### 5.2 排名查询性能优化策略


**🚀 索引优化建议**
```sql
-- 为排名查询创建合适的索引
-- 1. 基础排名查询索引
CREATE INDEX idx_employee_salary_desc ON employees (salary DESC);

-- 2. 分区排名查询索引
CREATE INDEX idx_employee_dept_salary ON employees (department, salary DESC);

-- 3. 复合条件排名索引
CREATE INDEX idx_employee_complex ON employees (status, department, salary DESC, hire_date);

-- 优化后的查询
SELECT 
    employee_name,
    department,
    salary,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank
FROM employees
WHERE status = 'active'  -- 利用索引过滤
ORDER BY department, salary DESC;
```

**💡 查询优化技巧**
```
性能优化要点：
1️⃣ ORDER BY字段建立合适索引
2️⃣ PARTITION BY字段包含在索引中
3️⃣ 合理使用WHERE条件减少数据量
4️⃣ 避免在窗口函数中使用复杂表达式
5️⃣ 考虑使用物化视图缓存排名结果
```

### 5.3 排名函数选择策略


**🎯 选择决策树**
```
需求分析
    │
    ▼
┌─────────────────┐    YES    ┌─────────────────┐
│需要唯一标识每行? │─────────→│  使用ROW_NUMBER  │
└─────────────────┘           └─────────────────┘
    │ NO
    ▼
┌─────────────────┐    YES    ┌─────────────────┐
│需要处理并列排名? │─────────→│  RANK/DENSE_RANK │
└─────────────────┘           └─────────────────┘
    │ NO
    ▼
┌─────────────────┐    YES    ┌─────────────────┐
│需要数据分层分组? │─────────→│   使用NTILE     │
└─────────────────┘           └─────────────────┘
    │ NO
    ▼
┌─────────────────┐    YES    ┌─────────────────┐
│需要分布分析?    │─────────→│CUME_DIST/PERCENT│
└─────────────────┘           └─────────────────┘
```

**🔑 业务场景选择指南**
```
具体应用场景：

ROW_NUMBER适合：
✅ 分页查询：LIMIT结合使用
✅ 去重保留：每组保留一条记录
✅ 序号生成：为记录生成唯一序号

RANK适合：
✅ 体育比赛：传统排名规则
✅ 考试排名：允许并列和跳跃
✅ 奖项评选：相同分数并列获奖

DENSE_RANK适合：
✅ 等级评定：连续的等级划分
✅ 薪资等级：薪资档次划分
✅ 绩效评估：连续的绩效等级

NTILE适合：
✅ 数据分层：将数据分成几个层次
✅ A/B测试：随机分组
✅ 业务分析：四分位数分析

CUME_DIST适合：
✅ 百分位分析：了解数据分布
✅ 异常检测：识别极值
✅ 统计分析：累积分布函数

PERCENT_RANK适合：
✅ 相对排名：了解相对位置
✅ 绩效评估：相对表现分析
✅ 标准化排名：不同量纲数据对比
```

---

## 6. ⚠️ 常见问题与最佳实践


### 6.1 排序规则与NULL值处理


**🔍 NULL值在排名中的处理**
```sql
-- NULL值排序行为测试
SELECT 
    employee_name,
    salary,
    commission,  -- 包含NULL值
    ROW_NUMBER() OVER (ORDER BY commission DESC) as row_num,
    RANK() OVER (ORDER BY commission DESC) as rank_num,
    DENSE_RANK() OVER (ORDER BY commission DESC) as dense_rank
FROM employees;

-- NULL值处理策略
SELECT 
    employee_name,
    salary,
    COALESCE(commission, 0) as commission_clean,  -- NULL转为0
    DENSE_RANK() OVER (ORDER BY COALESCE(commission, 0) DESC) as rank_with_default
FROM employees;
```

**💡 NULL值排序规则**
```
默认NULL值处理：
• ORDER BY ASC：NULL值排在最后
• ORDER BY DESC：NULL值排在最后  
• MySQL默认：NULLS LAST

显式控制NULL位置：
-- MySQL 8.0+支持
ORDER BY commission DESC NULLS FIRST   -- NULL值在前
ORDER BY commission DESC NULLS LAST    -- NULL值在后
```

### 6.2 排名函数常见错误


**❌ 错误用法示例**
```sql
-- 错误1：在WHERE中直接使用窗口函数
SELECT employee_name, salary
FROM employees
WHERE RANK() OVER (ORDER BY salary DESC) <= 10;  -- ❌ 语法错误

-- 正确写法：使用子查询或CTE
WITH ranked_employees AS (
    SELECT 
        employee_name, 
        salary,
        RANK() OVER (ORDER BY salary DESC) as salary_rank
    FROM employees
)
SELECT employee_name, salary
FROM ranked_employees  
WHERE salary_rank <= 10;  -- ✅ 正确
```

```sql
-- 错误2：混用不同排名函数的逻辑
SELECT 
    product_name,
    sales,
    CASE RANK() OVER (ORDER BY sales DESC)
        WHEN 1 THEN '冠军'
        WHEN 2 THEN '亚军'  
        WHEN 3 THEN '季军'
        ELSE '其他'
    END as award
FROM product_sales;
-- ⚠️ 问题：如果有并列第二，没有第三名

-- 更好的写法：
SELECT 
    product_name,
    sales,
    CASE DENSE_RANK() OVER (ORDER BY sales DESC)
        WHEN 1 THEN '冠军'
        WHEN 2 THEN '亚军'
        WHEN 3 THEN '季军'  
        ELSE '其他'
    END as award
FROM product_sales;
```

### 6.3 性能调优最佳实践


**🚀 高性能排名查询模式**
```sql
-- 最佳实践：结合索引和合理的数据过滤
-- 1. 先过滤再排名（减少排名数据量）
WITH filtered_sales AS (
    SELECT salesperson_name, region, total_sales
    FROM sales_data  
    WHERE sales_date >= '2024-01-01'  -- 先过滤数据
      AND region IN ('华东', '华南')   -- 缩小数据范围
)
SELECT 
    salesperson_name,
    region,
    total_sales,
    DENSE_RANK() OVER (PARTITION BY region ORDER BY total_sales DESC) as region_rank
FROM filtered_sales;

-- 2. 合理使用LIMIT（避免排序所有数据）
SELECT * FROM (
    SELECT 
        product_name,
        sales_amount,
        ROW_NUMBER() OVER (ORDER BY sales_amount DESC) as rn
    FROM product_sales
) ranked
WHERE rn <= 100;  -- 只需要前100名
```

**💡 排名查询优化技巧**
```
优化策略清单：
☑️ 为ORDER BY字段创建索引
☑️ 为PARTITION BY字段创建索引  
☑️ 合理使用WHERE条件预过滤
☑️ 避免在窗口函数中使用复杂计算
☑️ 考虑分页时使用ROW_NUMBER
☑️ 大数据量时考虑分批处理
☑️ 监控查询执行计划
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的排名函数特点


```
🔸 ROW_NUMBER：连续唯一排名，相同值不同序号
🔸 RANK：跳跃排名，相同值相同排名，下个排名跳跃
🔸 DENSE_RANK：密集排名，相同值相同排名，排名连续
🔸 NTILE：分桶函数，将数据分成N个大致相等的组
🔸 CUME_DIST：累积分布，计算小于等于当前值的比例
🔸 PERCENT_RANK：百分比排名，计算相对排名位置
```

### 7.2 关键应用场景理解


**🔹 排名函数的实际价值**
```
业务应用场景：
• 销售排行榜制作
• 学生成绩排名统计  
• 产品销售分析
• 用户行为分层
• 数据分布分析
• TopN查询实现
```

**🔹 选择函数的判断依据**
```
决策因素：
• 是否需要处理并列情况
• 排名是否需要连续
• 是否需要唯一标识
• 是否需要分层分析
• 是否需要分布分析
```

### 7.3 实际应用指导原则


**🎯 性能优化要点**
- **索引策略**：为ORDER BY和PARTITION BY字段建索引
- **数据过滤**：使用WHERE条件减少参与排名的数据量
- **合理选择**：根据业务需求选择合适的排名函数
- **查询优化**：避免不必要的复杂计算和多重排序

**🔧 开发最佳实践**
```
编码规范：
1️⃣ 明确业务需求再选择函数类型
2️⃣ 合理处理NULL值的排序逻辑
3️⃣ 使用CTE提高查询可读性
4️⃣ 注意窗口函数不能直接用于WHERE
5️⃣ 大数据量场景考虑分批处理
```

**核心记忆**：
- 排名窗口函数为每行计算排名位置，不改变行数
- 不同函数处理相同值的方式不同，选择要匹配业务逻辑
- 高级排名函数提供统计分析能力，适合数据分析场景
- 性能优化的关键是合理的索引设计和数据过滤策略