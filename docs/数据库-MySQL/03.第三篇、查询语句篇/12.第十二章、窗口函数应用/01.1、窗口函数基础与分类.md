---
title: 1、窗口函数基础与分类
---
## 📚 目录

1. [窗口函数概念与发展背景](#1-窗口函数概念与发展背景)
2. [OVER子句语法核心](#2-OVER子句语法核心)
3. [窗口函数分类详解](#3-窗口函数分类详解)
4. [窗口函数与传统查询对比](#4-窗口函数与传统查询对比)
5. [窗口函数执行机制](#5-窗口函数执行机制)
6. [实际应用场景分析](#6-实际应用场景分析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌟 窗口函数概念与发展背景


### 1.1 窗口函数概念定义


**💡 什么是窗口函数？**

窗口函数就像给每一行数据安装了一个"智能望远镜"，它不仅能看到当前行的数据，还能看到相关的其他行，然后基于这些信息进行计算。

> **核心特点**：窗口函数在保留原始数据行的同时，为每行添加基于相关行集合的计算结果。

```
窗口函数工作原理：

传统函数：                      窗口函数：
每行独立处理                    每行+相关行一起处理
     ↓                              ↓
只能访问当前行 → 函数 → 结果      当前行+窗口 → 函数 → 结果
                                  ↑
                              相关行集合
```

**🔑 窗口函数核心概念理解**

窗口函数的"窗口"可以理解为一个观察范围：

| **概念** | **含义** | **类比** |
|---------|---------|---------|
| **当前行** | `正在处理的数据行` | `望远镜的焦点` |
| **窗口** | `与当前行相关的行集合` | `望远镜的视野范围` |
| **分区** | `数据的逻辑分组` | `不同的观察区域` |
| **排序** | `窗口内的数据顺序` | `观察的先后顺序` |

### 1.2 OLAP分析需求背景


**🎯 为什么需要窗口函数？**

在传统的数据分析中，我们经常遇到这样的需求：

```
业务分析需求示例：

销售数据表：
日期        销售员    销售额
2024-01-01  张三     1000
2024-01-02  张三     1500  
2024-01-03  张三     800
2024-01-01  李四     1200
2024-01-02  李四     900

分析需求：
• 计算每个销售员的累计销售额
• 计算每天相比前一天的销售增长
• 计算每个销售员在所有销售员中的排名
• 计算移动平均值
```

**❌ 传统方法的局限性**

用传统的GROUP BY方法处理这些需求会遇到问题：

```sql
-- 传统方法的问题
SELECT 销售员, SUM(销售额) FROM sales GROUP BY 销售员;
-- 结果：只能得到汇总数据，丢失了明细信息

-- 需要多次查询和复杂的子查询才能实现复杂分析
```

**✅ 窗口函数的优势**

```sql
-- 窗口函数解决方案
SELECT 
    日期, 
    销售员, 
    销售额,
    SUM(销售额) OVER (PARTITION BY 销售员) AS 总销售额,
    ROW_NUMBER() OVER (ORDER BY 销售额 DESC) AS 排名
FROM sales;
-- 结果：既保留明细数据，又提供分析结果
```

### 1.3 窗口函数发展历史


**📈 发展历程**

```
窗口函数发展时间线：

1999年 ──── SQL:1999标准引入窗口函数概念
2003年 ──── SQL:2003标准进一步完善
2006年 ──── Oracle率先全面支持
2012年 ──── PostgreSQL 9.1支持
2018年 ──── MySQL 8.0开始支持
2019年 ──── 主流数据库基本全面支持
```

**🔸 分析函数理论基础**

窗口函数基于OLAP（联机分析处理）理论：

```
OLAP分析维度：

        时间维度
          ↑
          |
地区维度 ←——————→ 产品维度  
          |
          ↓
        销售指标

窗口函数让我们能在一个查询中：
• 按不同维度分组（PARTITION BY）
• 在组内排序（ORDER BY）  
• 计算各种指标（聚合、排名、比较）
```

---

## 2. 🔧 OVER子句语法核心


### 2.1 OVER子句完整语法


**📝 OVER子句语法结构**

```sql
function_name(arguments) OVER (
    [PARTITION BY partition_expression, ...]
    [ORDER BY sort_expression [ASC|DESC], ...]
    [ROWS|RANGE frame_specification]
)
```

**🔍 语法组件详解**

```
OVER子句组件说明：

┌─────────────────────────────────────────────────────┐
│                    OVER子句                          │
├─────────────────┬─────────────────┬─────────────────┤
│   PARTITION BY  │   ORDER BY      │   窗口框架       │
│   (分区子句)    │   (排序子句)    │  (ROWS/RANGE)   │
├─────────────────┼─────────────────┼─────────────────┤
│• 数据逻辑分组    │• 窗口内排序     │• 窗口范围定义    │
│• 类似GROUP BY   │• 影响排名函数   │• 滑动窗口       │
│• 可选项         │• 可选项         │• 可选项         │
└─────────────────┴─────────────────┴─────────────────┘
```

### 2.2 PARTITION BY分区详解


**📊 分区的作用**

PARTITION BY就像给数据贴标签分组：

```sql
-- 示例数据
CREATE TABLE employee_sales (
    name VARCHAR(50),
    department VARCHAR(50), 
    month INT,
    sales DECIMAL(10,2)
);

-- 按部门分区计算排名
SELECT 
    name,
    department,
    sales,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY sales DESC) AS dept_rank
FROM employee_sales;
```

**🎯 分区效果对比**

```
不使用PARTITION BY：               使用PARTITION BY：
全表统一排名                      各部门内部排名

全公司排名：                       部门内排名：
1. 张三(销售) 5000                销售部：1. 张三 5000
2. 李四(技术) 4800                       2. 王五 3000
3. 王五(销售) 3000                技术部：1. 李四 4800
4. 赵六(技术) 2500                       2. 赵六 2500
```

### 2.3 ORDER BY排序子句


**🔢 排序的重要性**

ORDER BY决定了窗口内数据的处理顺序：

| **函数类型** | **ORDER BY作用** | **示例** |
|-------------|-----------------|---------|
| **排名函数** | `决定排名顺序` | `ROW_NUMBER() OVER (ORDER BY score DESC)` |
| **值访问函数** | `决定前后行关系` | `LAG(sales) OVER (ORDER BY date)` |
| **聚合窗口函数** | `影响累计范围` | `SUM(sales) OVER (ORDER BY date)` |

### 2.4 窗口框架（Frame Specification）


**📐 什么是窗口框架？**

窗口框架定义了具体的计算范围：

```sql
-- 不同的窗口框架示例
SELECT 
    date,
    sales,
    -- 累计从第一行到当前行
    SUM(sales) OVER (ORDER BY date ROWS UNBOUNDED PRECEDING) AS cumulative_sum,
    
    -- 最近3天的移动平均
    AVG(sales) OVER (ORDER BY date ROWS 2 PRECEDING) AS moving_avg_3days,
    
    -- 当前行前后各1行的总和
    SUM(sales) OVER (ORDER BY date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS range_sum
FROM daily_sales;
```

---

## 3. 📋 窗口函数分类详解


### 3.1 排名函数详解


**🏆 三大排名函数对比**

```sql
-- 排名函数示例数据
SELECT 
    student,
    score,
    ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num,
    RANK() OVER (ORDER BY score DESC) AS rank_val,
    DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank_val
FROM student_scores;
```

**📊 排名函数差异对比**

```
学生成绩排名示例：

学生   分数   ROW_NUMBER   RANK   DENSE_RANK
─────────────────────────────────────────────
张三    95        1        1         1
李四    95        2        1         1      ← 并列第1
王五    90        3        3         2      ← 注意差异
赵六    85        4        4         3
孙七    85        5        4         3      ← 并列处理
周八    80        6        6         4

区别说明：
• ROW_NUMBER：连续编号，不考虑重复
• RANK：考虑重复，跳跃编号（1,1,3,4,4,6）
• DENSE_RANK：考虑重复，连续编号（1,1,2,3,3,4）
```

**💡 排名函数使用场景**

| **函数** | **适用场景** | **实例** |
|---------|-------------|---------|
| **ROW_NUMBER** | `需要唯一编号` | `分页查询、去重` |
| **RANK** | `传统排名方式` | `体育比赛排名` |
| **DENSE_RANK** | `紧密排名方式` | `成绩等级划分` |

### 3.2 聚合窗口函数


**📈 聚合窗口函数特点**

聚合窗口函数在窗口范围内进行聚合计算：

```sql
-- 聚合窗口函数示例
SELECT 
    date,
    sales,
    -- 累计销售额
    SUM(sales) OVER (ORDER BY date) AS cumulative_sales,
    
    -- 累计平均销售额  
    AVG(sales) OVER (ORDER BY date) AS cumulative_avg,
    
    -- 累计销售次数
    COUNT(sales) OVER (ORDER BY date) AS cumulative_count
FROM daily_sales
ORDER BY date;
```

**⚡ 与普通聚合函数区别**

```
普通聚合函数 vs 聚合窗口函数：

普通聚合：                    聚合窗口函数：
SELECT SUM(sales)            SELECT sales, 
FROM sales;                         SUM(sales) OVER() 
                             FROM sales;
     ↓                            ↓
返回1行汇总结果                返回每行+汇总结果
```

### 3.3 值访问函数


**🔍 值访问函数功能**

值访问函数可以访问窗口内其他行的值：

```sql
-- 值访问函数示例
SELECT 
    date,
    price,
    -- 前一天价格
    LAG(price, 1) OVER (ORDER BY date) AS prev_price,
    
    -- 后一天价格
    LEAD(price, 1) OVER (ORDER BY date) AS next_price,
    
    -- 第一天价格
    FIRST_VALUE(price) OVER (ORDER BY date) AS first_price,
    
    -- 最后一天价格（需要指定窗口框架）
    LAST_VALUE(price) OVER (
        ORDER BY date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_price
FROM stock_prices
ORDER BY date;
```

**📋 值访问函数详解**

| **函数** | **功能** | **常用参数** | **应用场景** |
|---------|---------|-------------|-------------|
| **LAG** | `访问前面的行` | `LAG(column, offset, default)` | `同比、环比计算` |
| **LEAD** | `访问后面的行` | `LEAD(column, offset, default)` | `预测、趋势分析` |
| **FIRST_VALUE** | `窗口第一个值` | `FIRST_VALUE(column)` | `基准值比较` |
| **LAST_VALUE** | `窗口最后一个值` | `LAST_VALUE(column)` | `最新值获取` |

### 3.4 分析函数


**🎯 高级分析函数**

```sql
-- 分析函数示例
SELECT 
    student,
    score,
    -- 将学生分为4个等级组
    NTILE(4) OVER (ORDER BY score DESC) AS quartile,
    
    -- 计算百分位排名
    PERCENT_RANK() OVER (ORDER BY score) AS percent_rank,
    
    -- 计算累积百分比
    CUME_DIST() OVER (ORDER BY score) AS cumulative_dist
FROM student_scores;
```

**📊 分析函数应用解释**

```
NTILE(4)等级分组示例：

100名学生分为4组：
第1组(Top 25%)：91-100分    quartile = 1
第2组(25-50%)：81-90分     quartile = 2  
第3组(50-75%)：71-80分     quartile = 3
第4组(Bottom 25%)：60-70分  quartile = 4

PERCENT_RANK百分位排名：
• 取值范围：0到1
• 含义：当前行在所有行中的相对位置
• 计算公式：(rank - 1) / (total_rows - 1)
```

---

## 4. ⚖️ 窗口函数与传统查询对比


### 4.1 窗口函数与GROUP BY区别


**🔍 核心区别分析**

```
GROUP BY vs 窗口函数对比：

GROUP BY聚合：                  窗口函数：
    原始数据                      原始数据
       ↓                            ↓
   按组聚合                    保持原始行数
       ↓                            ↓
   返回汇总行                  每行添加计算列

示例对比：
-- GROUP BY方式
SELECT department, AVG(salary)     -- 返回3行
FROM employees 
GROUP BY department;

-- 窗口函数方式  
SELECT name, department, salary,    -- 返回所有原始行
       AVG(salary) OVER (PARTITION BY department)
FROM employees;
```

**📊 详细对比表**

| **方面** | **GROUP BY** | **窗口函数** |
|---------|-------------|-------------|
| **行数变化** | `减少（聚合后）` | `保持不变` |
| **数据粒度** | `组级别汇总` | `行级别详细` |
| **SELECT限制** | `只能选择聚合列和分组列` | `可以选择任意列` |
| **使用场景** | `汇总报表` | `明细分析` |
| **性能特点** | `数据量减少` | `计算开销较大` |

### 4.2 实际应用对比示例


**💼 业务场景对比**

```sql
-- 场景：计算每个员工的工资及其在部门中的排名

-- 传统方法需要多个查询
-- 步骤1：获取员工信息
SELECT name, department, salary FROM employees;

-- 步骤2：获取部门平均工资（需要关联）
SELECT e.name, e.department, e.salary, 
       d.avg_salary
FROM employees e
JOIN (
    SELECT department, AVG(salary) AS avg_salary 
    FROM employees 
    GROUP BY department
) d ON e.department = d.department;

-- 步骤3：计算排名（更复杂的子查询）

-- 窗口函数一次解决
SELECT 
    name, 
    department, 
    salary,
    AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank,
    RANK() OVER (ORDER BY salary DESC) AS company_rank
FROM employees;
```

---

## 5. ⚙️ 窗口函数执行机制


### 5.1 窗口函数执行阶段


**🔄 SQL执行顺序中的窗口函数**

```
SQL语句执行顺序：

1. FROM子句      ← 确定数据源
2. WHERE子句     ← 过滤行数据  
3. GROUP BY子句  ← 分组聚合
4. HAVING子句    ← 过滤分组
5. 窗口函数      ← 🔥 在这个阶段执行
6. SELECT子句    ← 选择列
7. ORDER BY子句  ← 结果排序
8. LIMIT子句     ← 限制行数
```

> **🔑 重要理解**：窗口函数在GROUP BY之后、ORDER BY之前执行，这意味着它能看到聚合后的结果，但不受最终ORDER BY影响。

### 5.2 窗口函数性能特点


**⚡ 性能考虑因素**

```
窗口函数性能影响因素：

数据量大小 → 分区设计 → 排序需求 → 窗口范围
    ↓          ↓         ↓         ↓
  内存消耗   计算分布   排序开销   扫描范围
```

**🛠️ 性能优化建议**

| **优化策略** | **具体做法** | **效果** |
|-------------|-------------|---------|
| **合理分区** | `使用PARTITION BY减少计算范围` | `显著提升性能` |
| **索引支持** | `为ORDER BY列创建索引` | `减少排序时间` |
| **限制窗口范围** | `使用ROWS而非RANGE` | `减少计算复杂度` |
| **避免嵌套** | `减少窗口函数嵌套使用` | `降低CPU消耗` |

---

## 6. 🎯 实际应用场景分析


### 6.1 业务分析场景


**📈 销售数据分析**

```sql
-- 销售数据综合分析
SELECT 
    销售员,
    月份,
    销售额,
    -- 销售员排名
    RANK() OVER (PARTITION BY 月份 ORDER BY 销售额 DESC) AS 月度排名,
    
    -- 累计销售额
    SUM(销售额) OVER (PARTITION BY 销售员 ORDER BY 月份) AS 累计销售额,
    
    -- 环比增长
    LAG(销售额) OVER (PARTITION BY 销售员 ORDER BY 月份) AS 上月销售额,
    
    -- 移动平均
    AVG(销售额) OVER (
        PARTITION BY 销售员 
        ORDER BY 月份 
        ROWS 2 PRECEDING
    ) AS 三月移动平均
FROM 销售数据表;
```

### 6.2 Top-N查询优化


**🔝 传统Top-N vs 窗口函数**

```sql
-- 传统方式：查询每个部门工资前3名
SELECT * FROM (
    SELECT e1.* 
    FROM employees e1
    WHERE (
        SELECT COUNT(*)
        FROM employees e2 
        WHERE e2.department = e1.department 
        AND e2.salary >= e1.salary
    ) <= 3
) ORDER BY department, salary DESC;

-- 窗口函数方式：简洁高效
SELECT *
FROM (
    SELECT name, department, salary,
           ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rn
    FROM employees
) ranked
WHERE rn <= 3;
```

### 6.3 时间序列分析


**⏰ 时间序列数据处理**

```sql
-- 股价趋势分析
SELECT 
    交易日期,
    收盘价,
    -- 5日移动平均
    AVG(收盘价) OVER (
        ORDER BY 交易日期 
        ROWS 4 PRECEDING
    ) AS MA5,
    
    -- 价格变化
    收盘价 - LAG(收盘价) OVER (ORDER BY 交易日期) AS 价格变化,
    
    -- 涨跌幅  
    ROUND(
        (收盘价 - LAG(收盘价) OVER (ORDER BY 交易日期)) 
        / LAG(收盘价) OVER (ORDER BY 交易日期) * 100, 2
    ) AS 涨跌幅
FROM 股价数据表
ORDER BY 交易日期;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 窗口函数定义：在保留原始数据行的同时，基于相关行集合进行计算
🔸 OVER子句：窗口函数的核心语法，定义计算窗口范围
🔸 四大函数类型：排名、聚合、值访问、分析函数各有特点
🔸 与GROUP BY区别：不减少数据行，每行添加计算结果
🔸 执行时机：在GROUP BY之后，ORDER BY之前执行
```

### 7.2 关键理解要点


**🔹 窗口的概念理解**
```
窗口 = 与当前行相关的数据集合
• PARTITION BY 定义窗口边界
• ORDER BY 定义窗口内顺序
• FRAME 定义具体计算范围
```

**🔹 函数选择原则**
```
排名需求 → 选择ROW_NUMBER/RANK/DENSE_RANK
聚合计算 → 选择SUM/AVG/COUNT等聚合窗口函数
行间比较 → 选择LAG/LEAD/FIRST_VALUE等值访问函数
分组分析 → 选择NTILE/PERCENT_RANK等分析函数
```

**🔹 性能优化重点**
```
合理分区 > 索引支持 > 限制窗口范围 > 避免复杂嵌套
```

### 7.3 实际应用价值


**💼 业务分析应用**
- **销售分析**：排名、同比环比、累计统计
- **财务分析**：移动平均、趋势分析、占比计算  
- **用户分析**：用户分群、行为序列、留存分析

**🔧 开发优化应用**
- **Top-N查询**：替代复杂子查询，提升性能
- **分页优化**：ROW_NUMBER实现高效分页
- **报表开发**：一次查询获取多维度分析结果

**📊 数据分析应用**
- **时间序列**：趋势分析、季节性调整
- **统计分析**：百分位数、累积分布
- **对比分析**：同期对比、基准比较

### 7.4 学习进阶建议


**📚 深入学习方向**
- **高级窗口框架**：RANGE vs ROWS的细微差别
- **性能调优**：大数据量下的窗口函数优化
- **复杂场景**：多层窗口函数嵌套使用

**🛠️ 实践练习建议**
- 使用窗口函数重写复杂的GROUP BY查询
- 练习不同业务场景下的窗口函数选择
- 对比窗口函数与传统方法的性能差异

**核心记忆口诀**：
```
窗口函数如望远镜，看己看人做分析
OVER子句定范围，分区排序框架清
排名聚合访问值，分析函数各有功  
保留明细添计算，一次查询全搞定
```