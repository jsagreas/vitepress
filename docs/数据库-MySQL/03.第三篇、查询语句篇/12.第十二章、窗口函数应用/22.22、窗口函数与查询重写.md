---
title: 22、窗口函数与查询重写
---
## 📚 目录

1. [窗口函数查询重写概述](#1-窗口函数查询重写概述)
2. [窗口函数消除技术](#2-窗口函数消除技术)
3. [窗口函数合并优化](#3-窗口函数合并优化)
4. [等价窗口变换规则](#4-等价窗口变换规则)
5. [窗口函数优化规则](#5-窗口函数优化规则)
6. [重写安全性检查](#6-重写安全性检查)
7. [实际应用与性能对比](#7-实际应用与性能对比)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 窗口函数查询重写概述


### 1.1 什么是窗口函数查询重写


**🔸 基本概念**
```
窗口函数查询重写：数据库优化器将复杂的窗口函数查询
转换为更高效的等价查询的过程

目标：在保证结果正确的前提下，提升查询性能
手段：消除、合并、变换窗口函数，减少计算开销
```

**💡 为什么需要查询重写**
想象你要统计班级成绩排名，原本需要多次计算：
```sql
-- 原始查询：多个窗口函数分别计算
SELECT 
    student_name,
    score,
    ROW_NUMBER() OVER (ORDER BY score DESC) as rank_num,
    RANK() OVER (ORDER BY score DESC) as rank_tie,
    AVG(score) OVER () as class_avg
FROM students;
```

优化器可能重写为：
```sql
-- 重写后：减少重复计算
SELECT 
    student_name,
    score,
    -- 通过一次排序完成多个排名计算
    calculated_rank_info.*
FROM students 
CROSS JOIN (SELECT AVG(score) as class_avg FROM students) avg_calc
ORDER BY score DESC;
```

### 1.2 查询重写的触发场景


**🎯 常见触发情况**
```
场景1：多个相似窗口函数
- 相同的PARTITION BY和ORDER BY
- 不同的窗口函数（ROW_NUMBER, RANK, DENSE_RANK）
- 可以合并为一次计算

场景2：可消除的窗口函数
- 简单聚合可以用GROUP BY替代
- 某些排序操作可以外层处理

场景3：窗口范围优化
- 过大的窗口范围可以缩小
- 不必要的ROWS/RANGE子句可以去除
```

### 1.3 重写的基本原理


**🔧 重写策略分类**
```
┌─────────────────────────────────────┐
│            查询重写策略              │
├─────────────────────────────────────┤
│  消除策略  │  转换为GROUP BY等简单操作  │
├─────────────────────────────────────┤
│  合并策略  │  多个窗口函数合并计算     │
├─────────────────────────────────────┤
│  变换策略  │  等价但更高效的表达方式   │
├─────────────────────────────────────┤
│  下推策略  │  将计算推到更底层执行     │
└─────────────────────────────────────┘
```

---

## 2. ❌ 窗口函数消除技术


### 2.1 什么是窗口函数消除


**🔸 消除的含义**
把原本用窗口函数实现的功能，改用更简单的SQL语句来实现，就像把复杂的数学公式简化为基本运算。

```
简单理解：
窗口函数消除 = 把"复杂的窗口计算"变成"简单的普通查询"

就像：原本需要用计算器的复杂计算 → 变成心算就能解决的简单加减
```

### 2.2 可消除的窗口函数类型


#### 📊 全表聚合函数消除


**场景：计算全表统计值**
```sql
-- 原始查询：使用窗口函数
SELECT 
    product_name,
    price,
    AVG(price) OVER () as avg_price,  -- 全表平均价格
    MAX(price) OVER () as max_price   -- 全表最高价格
FROM products;

-- 消除后：使用子查询
SELECT 
    product_name,
    price,
    avg_calc.avg_price,
    max_calc.max_price
FROM products
CROSS JOIN (SELECT AVG(price) as avg_price FROM products) avg_calc
CROSS JOIN (SELECT MAX(price) as max_price FROM products) max_calc;
```

**🔍 为什么这样更好**
- 全表聚合只需要计算一次，不用为每行重复计算
- 数据库可以更好地利用索引和缓存
- 减少了窗口函数的排序开销

#### 🔢 简单排名函数消除


**场景：无分组的简单排序**
```sql
-- 原始查询：ROW_NUMBER排序
SELECT 
    student_name,
    score,
    ROW_NUMBER() OVER (ORDER BY score DESC) as rank_num
FROM students
ORDER BY score DESC;

-- 消除后：直接排序 + 行号生成
SELECT 
    student_name,
    score,
    @row_number := @row_number + 1 as rank_num  -- MySQL语法
FROM students, (SELECT @row_number := 0) r
ORDER BY score DESC;

-- 或者在应用层处理行号
SELECT student_name, score
FROM students
ORDER BY score DESC;
-- 应用程序中添加行号
```

### 2.3 消除的适用条件


**✅ 可以消除的情况**
```
条件检查清单：

□ 没有PARTITION BY子句（全表计算）
□ 聚合函数结果对所有行都相同
□ 不涉及复杂的窗口范围（ROWS/RANGE）
□ 查询逻辑可以用简单JOIN或子查询替代
□ 不依赖窗口函数的特殊语义
```

**❌ 不能消除的情况**
```sql
-- 复杂分组排名：无法简单消除
SELECT 
    department,
    employee_name,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank
FROM employees;

-- 滑动窗口计算：无法简单消除
SELECT 
    date,
    sales,
    AVG(sales) OVER (ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) as moving_avg
FROM daily_sales;
```

### 2.4 消除的性能收益


**📈 性能对比示例**
```
测试场景：100万行数据，计算全表平均值

窗口函数方式：
- 执行时间：1.2秒
- 内存使用：需要排序缓冲区
- I/O开销：可能需要临时文件

消除后方式：
- 执行时间：0.3秒
- 内存使用：只需聚合计算内存
- I/O开销：顺序扫描，无临时文件

性能提升：约4倍速度提升
```

---

## 3. 🔗 窗口函数合并优化


### 3.1 什么是窗口函数合并


**🔸 合并的概念**
当查询中有多个窗口函数使用相同的`PARTITION BY`和`ORDER BY`时，数据库可以把它们"打包"一起计算，就像批量处理一样效率更高。

```
类比理解：
原来：分别去银行办理存款、取款、转账（跑3趟）
合并：一次去银行把3件事都办完（跑1趟）
```

### 3.2 可合并的窗口函数识别


**🔍 合并条件检查**
```sql
-- 可以合并的示例：相同的分区和排序
SELECT 
    employee_id,
    department,
    salary,
    -- 这三个窗口函数可以合并
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as row_num,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank_val,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dense_rank
FROM employees;
```

**合并后的执行计划**
```
执行过程：
1. 按department分区
2. 每个分区内按salary DESC排序
3. 一次遍历同时计算ROW_NUMBER、RANK、DENSE_RANK
4. 返回结果

优势：
- 只需要一次排序操作
- 减少内存使用
- 降低CPU计算量
```

### 3.3 合并规则详解


#### 🎯 完全相同窗口规格


**规则1：PARTITION BY + ORDER BY完全相同**
```sql
-- 可以合并：分区字段、排序字段、排序方向都相同
ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC)
RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC)
DENSE_RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC)

-- 不能合并：排序方向不同
ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC)
LAG(salary) OVER (PARTITION BY dept_id ORDER BY salary ASC)  -- ASC vs DESC
```

#### 🔄 兼容窗口规格


**规则2：窗口规格包含关系**
```sql
-- 可以合并：一个是另一个的子集
SUM(salary) OVER (PARTITION BY department)  -- 整个分区
SUM(salary) OVER (PARTITION BY department ORDER BY hire_date)  -- 累积求和

-- 合并策略：
-- 1. 先按更细粒度的规格（ORDER BY）计算
-- 2. 从细粒度结果推导粗粒度结果
```

#### ⚡ 窗口范围兼容性


**规则3：ROWS/RANGE子句兼容**
```sql
-- 可以合并：窗口范围有包含关系
AVG(score) OVER (ORDER BY date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
MAX(score) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING)

-- 合并策略：
-- 按较大范围计算，然后推导较小范围的结果
```

### 3.4 合并优化实例


**📋 实际案例分析**
```sql
-- 复杂查询：计算销售分析指标
SELECT 
    sale_date,
    product_id,
    sales_amount,
    -- 以下窗口函数可以合并优化
    SUM(sales_amount) OVER (
        PARTITION BY product_id 
        ORDER BY sale_date 
        ROWS UNBOUNDED PRECEDING
    ) as cumulative_sales,
    
    AVG(sales_amount) OVER (
        PARTITION BY product_id 
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as week_avg,
    
    LAG(sales_amount, 1) OVER (
        PARTITION BY product_id 
        ORDER BY sale_date
    ) as prev_day_sales
FROM sales_data;
```

**优化后的执行策略**
```
数据库内部优化过程：

步骤1：识别可合并窗口
- 所有窗口函数都使用相同的PARTITION BY product_id
- 都按sale_date排序
- 可以在一次分区排序中完成

步骤2：制定合并计划
- 按product_id分区，sale_date排序
- 一次遍历计算累积和、移动平均、LAG值

步骤3：执行合并计算
┌─────────────────────────────────────┐
│  分区: product_id = 'A001'          │
│  ┌─────────┬─────────┬─────────────┐ │
│  │ 日期    │ 销量    │ 窗口计算     │ │
│  ├─────────┼─────────┼─────────────┤ │
│  │ 2024-01 │ 100     │ 累积=100    │ │
│  │ 2024-02 │ 150     │ 累积=250    │ │
│  │ 2024-03 │ 120     │ 累积=370    │ │
│  └─────────┴─────────┴─────────────┘ │
└─────────────────────────────────────┘

性能提升：
- 原来：3次分区排序 → 现在：1次分区排序
- 时间复杂度：O(3n log n) → O(n log n)
- 内存使用：减少2/3的排序缓冲区
```

---

## 4. 🔄 等价窗口变换规则


### 4.1 窗口函数等价变换基础


**🔸 等价变换的含义**
把一种窗口函数的写法，改成另一种功能完全相同但性能更好的写法，就像数学中的等式变换。

```
等价变换示例：
数学：2 × 3 = 6  ←→  3 + 3 = 6  (结果相同，计算方式不同)
SQL： ROW_NUMBER() ←→ COUNT(*) (某些情况下等价)
```

### 4.2 常见等价变换规则


#### 🔢 排名函数等价变换


**规则1：ROW_NUMBER → COUNT转换**
```sql
-- 原始写法：使用ROW_NUMBER
SELECT 
    product_name,
    ROW_NUMBER() OVER (ORDER BY price) as price_rank
FROM products;

-- 等价变换：使用COUNT
SELECT 
    p1.product_name,
    COUNT(p2.product_id) as price_rank
FROM products p1
LEFT JOIN products p2 ON p2.price < p1.price 
                      OR (p2.price = p1.price AND p2.product_id <= p1.product_id)
GROUP BY p1.product_id, p1.product_name;
```

**为什么要这样变换？**
- `COUNT` + `JOIN`在某些情况下比窗口函数更快
- 特别是当数据量不大且有合适索引时
- 可以更好地利用索引快速定位

#### 📈 聚合函数等价变换


**规则2：窗口聚合 → 子查询**
```sql
-- 原始：窗口函数计算部门平均工资
SELECT 
    employee_name,
    salary,
    AVG(salary) OVER (PARTITION BY department_id) as dept_avg
FROM employees;

-- 等价变换：子查询
SELECT 
    e.employee_name,
    e.salary,
    d.dept_avg
FROM employees e
JOIN (
    SELECT 
        department_id,
        AVG(salary) as dept_avg
    FROM employees 
    GROUP BY department_id
) d ON e.department_id = d.department_id;
```

**变换的优势**
```
性能对比：

窗口函数方式：
- 需要对整个表进行分区排序
- 内存需求：整表数据的排序空间

子查询方式：
- GROUP BY可以利用索引
- 内存需求：只需要分组后的少量结果
- JOIN操作通常很快

适用条件：
✅ 分组数量相对较少
✅ department_id上有索引
✅ 不需要复杂的窗口范围
```

### 4.3 复杂等价变换


#### 🎯 累积计算的变换


**规则3：累积和的优化**
```sql
-- 原始：窗口函数累积和
SELECT 
    order_date,
    daily_sales,
    SUM(daily_sales) OVER (
        ORDER BY order_date 
        ROWS UNBOUNDED PRECEDING
    ) as cumulative_sales
FROM daily_sales_summary
ORDER BY order_date;

-- 等价变换：自连接实现
SELECT 
    s1.order_date,
    s1.daily_sales,
    SUM(s2.daily_sales) as cumulative_sales
FROM daily_sales_summary s1
JOIN daily_sales_summary s2 ON s2.order_date <= s1.order_date
GROUP BY s1.order_date, s1.daily_sales
ORDER BY s1.order_date;
```

**🤔 何时使用这种变换**
```
适合变换的情况：
- 数据量不大（< 10万行）
- order_date上有索引
- 需要频繁访问历史累积值

不适合变换的情况：
- 数据量很大（JOIN开销大）
- 没有合适的索引支持
- 只是偶尔查询累积值
```

### 4.4 变换安全性验证


**🔐 验证等价性的方法**
```sql
-- 验证方法：对比两种写法的结果
WITH original AS (
    -- 原始窗口函数查询
    SELECT id, ROW_NUMBER() OVER (ORDER BY score) as rn1
    FROM test_table
),
transformed AS (
    -- 变换后的查询
    SELECT id, COUNT(*) as rn2
    FROM test_table t1
    JOIN test_table t2 ON t2.score < t1.score 
                       OR (t2.score = t1.score AND t2.id <= t1.id)
    GROUP BY t1.id
)
-- 检查结果是否一致
SELECT * FROM original o
FULL OUTER JOIN transformed t ON o.id = t.id
WHERE o.rn1 != t.rn2 OR o.rn1 IS NULL OR t.rn2 IS NULL;
-- 如果返回空结果，说明两种方法等价
```

---

## 5. ⚙️ 窗口函数优化规则


### 5.1 窗口规格优化


#### 📏 窗口范围缩减


**优化规则：缩小不必要的窗口范围**
```sql
-- 未优化：过大的窗口范围
SELECT 
    product_id,
    sale_date,
    sales_amount,
    AVG(sales_amount) OVER (
        PARTITION BY product_id 
        ORDER BY sale_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) as product_avg
FROM sales;

-- 优化后：识别出这实际上是简单的分组平均
SELECT 
    product_id,
    sale_date,
    sales_amount,
    AVG(sales_amount) OVER (PARTITION BY product_id) as product_avg
FROM sales;
```

**为什么这样更快？**
```
窗口范围对性能的影响：

UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING：
- 需要排序整个分区
- 内存需求大
- 计算复杂度高

简化为PARTITION BY only：
- 不需要排序
- 只需要分组聚合
- 可以利用哈希聚合算法
```

#### 🎯 排序优化


**优化规则：消除不必要的ORDER BY**
```sql
-- 原始查询：包含不必要的排序
SELECT 
    customer_id,
    COUNT(*) OVER (PARTITION BY region) as region_customers,
    SUM(order_amount) OVER (PARTITION BY region ORDER BY customer_id) as running_sum
FROM orders;

-- 分析：COUNT(*)不需要排序，可以分离优化
SELECT 
    customer_id,
    region_customers,
    running_sum
FROM (
    SELECT 
        customer_id,
        region,
        order_amount,
        COUNT(*) OVER (PARTITION BY region) as region_customers
    FROM orders
) base
-- 只对需要排序的部分使用窗口函数
```

### 5.2 窗口函数下推优化


**🔸 下推的概念**
把窗口函数的计算"推"到更靠近数据源的地方执行，减少需要处理的数据量。

```
优化思路：
在数据流的早期阶段就进行窗口计算
而不是等到最后再计算

数据流示例：
原来：表扫描 → JOIN → WHERE → 窗口函数计算
优化：表扫描 → 窗口函数计算 → JOIN → WHERE
```

**📋 下推实例**
```sql
-- 原始查询：窗口函数在JOIN之后
SELECT 
    e.employee_name,
    d.department_name,
    e.salary,
    RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC) as salary_rank
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE d.location = 'Beijing';

-- 优化：窗口函数下推到JOIN之前
SELECT 
    ranked_emp.employee_name,
    d.department_name,
    ranked_emp.salary,
    ranked_emp.salary_rank
FROM (
    -- 先计算排名，减少JOIN的数据量
    SELECT 
        employee_name,
        department_id,
        salary,
        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank
    FROM employees
) ranked_emp
JOIN departments d ON ranked_emp.department_id = d.department_id
WHERE d.location = 'Beijing';
```

### 5.3 索引优化建议


**🔍 窗口函数的索引策略**
```sql
-- 针对窗口函数创建复合索引
CREATE INDEX idx_emp_dept_salary ON employees(department_id, salary DESC);

-- 索引设计原则：
-- 1. PARTITION BY字段放在前面
-- 2. ORDER BY字段紧随其后
-- 3. 排序方向要匹配

索引效果：
┌─────────────────────────────────────┐
│  无索引：全表扫描 + 内存排序         │
│  执行时间：2.5秒                    │
├─────────────────────────────────────┤
│  有索引：索引扫描 + 顺序读取         │  
│  执行时间：0.3秒                    │
└─────────────────────────────────────┘
性能提升：约8倍
```

---

## 6. 🛡️ 重写安全性检查


### 6.1 为什么需要安全性检查


**🔸 安全性的重要性**
数据库优化器在重写查询时，必须保证改写后的查询结果与原查询**完全一致**。就像翻译一样，意思不能变。

```
风险示例：错误的重写

原始查询意图：计算每个学生在班级中的排名
错误重写：计算每个学生在全校的排名

后果：业务逻辑错误，数据不准确
```

### 6.2 数据完整性检查


#### 🔍 NULL值处理检查


**检查项1：NULL值的影响**
```sql
-- 原始查询
SELECT 
    student_name,
    score,
    AVG(score) OVER () as class_avg
FROM students;

-- 重写候选
SELECT 
    student_name,
    score,
    (SELECT AVG(score) FROM students) as class_avg
FROM students;
```

**安全性验证**
```sql
-- 验证NULL值处理是否一致
CREATE TABLE test_scores (
    student_name VARCHAR(50),
    score INT
);

INSERT INTO test_scores VALUES 
('Alice', 90),
('Bob', NULL),    -- 包含NULL值
('Charlie', 85);

-- 检查两种方法对NULL的处理是否相同
-- 窗口函数：自动忽略NULL值
-- 子查询：也应该忽略NULL值
-- 验证结果必须一致
```

#### 📊 数据类型检查


**检查项2：数据类型兼容性**
```sql
-- 检查数据类型转换的安全性
-- 原始：窗口函数可能涉及隐式类型转换
SELECT 
    order_id,
    CAST(order_amount AS DECIMAL(10,2)),
    AVG(order_amount) OVER () as avg_amount
FROM orders;

-- 重写后必须保持相同的类型转换规则
```

### 6.3 语义等价性检查


#### 🎯 分组语义检查


**检查项3：PARTITION BY语义保持**
```sql
-- 原始：按部门分组的排名
SELECT 
    employee_name,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank
FROM employees;

-- 错误的重写：丢失了分组语义
SELECT 
    employee_name,
    department,
    salary,
    RANK() OVER (ORDER BY salary DESC) as overall_rank  -- 错误！
FROM employees;

-- 正确的重写验证：
-- 必须保证每个部门内部独立排名
```

#### ⚡ 排序语义检查


**检查项4：ORDER BY语义一致性**
```sql
-- 多字段排序的等价性检查
-- 原始：复合排序条件
RANK() OVER (ORDER BY salary DESC, hire_date ASC)

-- 重写时必须保持：
-- 1. 主排序字段：salary DESC
-- 2. 次排序字段：hire_date ASC  
-- 3. NULL值的排序位置
-- 4. 相同值的处理方式
```

### 6.4 性能与正确性平衡


**⚖️ 安全性检查流程**
```
重写安全性检查步骤：

第1步：语法检查
├─ 窗口函数语法是否正确
├─ 重写后的SQL语法是否有效
└─ 数据类型是否兼容

第2步：语义检查  
├─ PARTITION BY分组逻辑是否保持
├─ ORDER BY排序逻辑是否一致
├─ 窗口范围计算是否等价
└─ NULL值处理是否相同

第3步：结果验证
├─ 小数据集验证结果一致性
├─ 边界条件测试
├─ 性能基准测试
└─ 业务逻辑验证

第4步：上线决策
├─ 性能提升是否显著（>20%）
├─ 风险评估是否可接受
├─ 回滚方案是否完备
└─ 监控指标是否到位
```

### 6.5 常见安全性陷阱


**⚠️ 需要特别注意的情况**
```sql
-- 陷阱1：精度丢失
-- 原始：窗口函数可能保持高精度
AVG(price) OVER (PARTITION BY category)

-- 重写：子查询可能精度不同
(SELECT AVG(price) FROM products WHERE category = p.category)

-- 解决：确保精度设置一致
(SELECT AVG(CAST(price AS DECIMAL(12,4))) FROM products WHERE category = p.category)

-- 陷阱2：排序稳定性
-- 原始：相同值的排序是确定的
ROW_NUMBER() OVER (ORDER BY score DESC)

-- 重写：必须保证相同值的处理方式一致
-- 需要添加唯一性字段确保稳定排序
ROW_NUMBER() OVER (ORDER BY score DESC, student_id ASC)
```

---

## 7. 📊 实际应用与性能对比


### 7.1 真实场景案例


**📈 电商平台销售分析系统**
```sql
-- 业务需求：销售报表分析
-- 原始查询：多个窗口函数
SELECT 
    product_category,
    product_name,
    monthly_sales,
    
    -- 类别内排名
    RANK() OVER (
        PARTITION BY product_category 
        ORDER BY monthly_sales DESC
    ) as category_rank,
    
    -- 类别销售占比
    monthly_sales / SUM(monthly_sales) OVER (
        PARTITION BY product_category
    ) * 100 as category_percentage,
    
    -- 全局排名
    RANK() OVER (ORDER BY monthly_sales DESC) as global_rank,
    
    -- 移动平均（3个月）
    AVG(monthly_sales) OVER (
        PARTITION BY product_name 
        ORDER BY month_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg

FROM product_sales 
WHERE month_date >= '2024-01-01';
```

**🔧 优化重写策略**
```sql
-- 优化分析：
-- 1. 类别内的rank和sum可以合并
-- 2. 全局rank可以单独计算
-- 3. 移动平均需要保持独立

-- 重写后的查询：
WITH category_stats AS (
    -- 先计算类别统计
    SELECT 
        product_category,
        product_name,
        monthly_sales,
        RANK() OVER (PARTITION BY product_category ORDER BY monthly_sales DESC) as category_rank,
        SUM(monthly_sales) OVER (PARTITION BY product_category) as category_total
    FROM product_sales 
    WHERE month_date >= '2024-01-01'
),
global_ranks AS (
    -- 单独计算全局排名
    SELECT 
        product_name,
        RANK() OVER (ORDER BY monthly_sales DESC) as global_rank
    FROM product_sales 
    WHERE month_date >= '2024-01-01'
)
-- 最终合并结果
SELECT 
    cs.*,
    cs.monthly_sales / cs.category_total * 100 as category_percentage,
    gr.global_rank,
    -- 移动平均保持原样（无法简化）
    AVG(cs.monthly_sales) OVER (
        PARTITION BY cs.product_name 
        ORDER BY month_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg
FROM category_stats cs
JOIN global_ranks gr ON cs.product_name = gr.product_name;
```

### 7.2 性能测试对比


**📊 实际性能数据**
```
测试环境：
- 数据量：500万行销售记录
- 服务器：16核CPU，64GB内存
- 数据库：PostgreSQL 14

测试结果对比：

┌─────────────────┬──────────┬──────────┬──────────┐
│   优化策略      │  执行时间 │  内存使用 │  CPU使用  │
├─────────────────┼──────────┼──────────┼──────────┤
│  原始查询       │   45秒   │   8GB    │   85%    │
├─────────────────┼──────────┼──────────┼──────────┤
│  函数合并优化   │   28秒   │   5GB    │   70%    │
├─────────────────┼──────────┼──────────┼──────────┤
│  部分消除优化   │   18秒   │   3GB    │   55%    │
├─────────────────┼──────────┼──────────┼──────────┤
│  综合优化       │   12秒   │   2GB    │   40%    │
└─────────────────┴──────────┴──────────┴──────────┘

性能提升：约4倍速度提升，内存使用减少75%
```

### 7.3 优化效果分析


**🎯 不同场景的优化效果**

| 数据规模 | **原始查询时间** | **优化后时间** | **提升倍数** | **最佳策略** |
|---------|-----------------|---------------|-------------|-------------|
| `< 1万行` | `0.1秒` | `0.08秒` | `1.25倍` | `简单合并` |
| `1-10万行` | `2秒` | `0.8秒` | `2.5倍` | `函数消除` |
| `10-100万行` | `15秒` | `4秒` | `3.75倍` | `综合优化` |
| `> 100万行` | `60秒` | `12秒` | `5倍` | `分段处理` |

**💡 优化策略选择指南**
```
小数据量（< 10万行）：
✅ 重点关注查询简化
✅ 消除不必要的窗口函数
❌ 不必过度优化，简单够用

中等数据量（10-100万行）：
✅ 合并相似窗口函数
✅ 优化窗口范围
✅ 创建合适索引

大数据量（> 100万行）：
✅ 分阶段处理数据
✅ 使用物化视图
✅ 考虑数据分区
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 查询重写：在保证结果正确的前提下，将窗口函数查询转换为更高效的形式
🔸 函数消除：将简单的窗口函数替换为普通的GROUP BY或子查询
🔸 函数合并：将多个相似的窗口函数合并为一次计算
🔸 等价变换：使用不同但等价的SQL表达方式
🔸 安全检查：确保重写后的查询结果与原查询完全一致
```

### 8.2 关键理解要点


**🔹 什么时候需要查询重写**
```
触发条件：
- 查询中有多个相似的窗口函数
- 存在可以简化的聚合计算
- 窗口范围设置不合理
- 性能不满足业务要求

判断标准：
- 查询执行时间 > 预期时间
- 内存使用过多导致系统负载高
- 并发查询时出现性能瓶颈
```

**🔹 重写的核心原则**
```
正确性第一：
- 任何优化都不能改变查询结果
- 必须通过充分的测试验证
- 考虑边界条件和异常情况

性能提升显著：
- 优化效果要明显（通常>20%）
- 考虑维护成本和复杂度
- 权衡开发时间和性能收益

可维护性：
- 重写后的SQL要易于理解
- 不能为了性能牺牲可读性
- 必要时添加注释说明优化思路
```

**🔹 常见优化场景识别**
```
场景1：相同窗口规格的多个函数
识别特征：PARTITION BY和ORDER BY完全相同
优化策略：合并为一次计算

场景2：简单的全表聚合
识别特征：没有PARTITION BY，简单聚合函数
优化策略：改为子查询或标量子查询

场景3：不必要的排序
识别特征：聚合函数不需要ORDER BY
优化策略：移除ORDER BY子句

场景4：过大的窗口范围
识别特征：UNBOUNDED范围但实际不需要
优化策略：缩小窗口范围或改为分组聚合
```

### 8.3 实际应用指导


**🎯 在实际工作中的应用**
```
开发阶段：
- 编写SQL时考虑窗口函数的性能影响
- 避免不必要的复杂窗口函数
- 优先使用简单的GROUP BY和JOIN

测试阶段：
- 对窗口函数查询进行性能测试
- 验证大数据量下的表现
- 比较不同写法的性能差异

生产阶段：
- 监控窗口函数查询的执行情况
- 识别性能瓶颈并进行针对性优化
- 建立查询性能基线和告警机制
```

**🔧 优化工具和方法**
```
分析工具：
- EXPLAIN ANALYZE：查看执行计划和实际耗时
- 数据库性能监控：识别慢查询
- 查询重写验证工具：确保结果一致性

优化方法：
- 渐进式优化：逐步应用优化规则
- A/B测试：对比优化前后的性能
- 灰度发布：在生产环境中逐步应用优化
```

**🧠 学习记忆要点**
```
记忆口诀：
- 重写优化要安全，结果正确是关键
- 合并消除看窗口，相同规格可优化  
- 等价变换需谨慎，测试验证不可少
- 性能提升要显著，维护成本要考虑

核心原则：
1. 安全第一：绝不能改变查询结果
2. 性能导向：优化效果要明显可感知  
3. 渐进优化：从简单场景开始，逐步复杂
4. 持续监控：优化后要持续关注性能表现
```

### 8.4 进阶学习方向


**🚀 深入学习建议**
- **查询优化器原理**：了解数据库内部如何进行查询重写
- **执行计划分析**：掌握读懂和分析执行计划的技能
- **性能调优实践**：在实际项目中应用窗口函数优化技术
- **不同数据库差异**：了解各数据库的窗口函数优化特点

**📚 相关知识拓展**
- **索引设计**：针对窗口函数的索引优化策略
- **数据分区**：大表的分区策略与窗口函数结合
- **并行处理**：窗口函数的并行计算优化
- **内存管理**：窗口函数的内存使用优化

**核心价值**：掌握窗口函数查询重写技术，能够显著提升复杂分析查询的性能，是数据库性能优化的重要技能之一。在大数据时代，这项技术对于处理海量数据的分析查询具有重要的实际价值。