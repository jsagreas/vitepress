---
title: 10、滑动窗口与累积窗口
---
## 📚 目录

1. [窗口函数核心概念](#1-窗口函数核心概念)
2. [滑动窗口实现技术](#2-滑动窗口实现技术)
3. [累积窗口计算](#3-累积窗口计算)
4. [实时窗口处理](#4-实时窗口处理)
5. [窗口优化策略](#5-窗口优化策略)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🪟 窗口函数核心概念


### 1.1 什么是窗口函数


**通俗理解**：窗口函数就像是一个**移动的观察窗口**，你可以通过这个窗口观察数据的不同片段，并对每个片段进行计算。

```
想象你站在火车上看窗外风景：
┌─────┬─────┬─────┬─────┬─────┐
│ 1月  │ 2月  │ 3月  │ 4月  │ 5月  │ 销售数据
└─────┴─────┴─────┴─────┴─────┘
  [    窗口1    ]              ← 计算1-3月的平均值
      [    窗口2    ]          ← 计算2-4月的平均值  
          [    窗口3    ]      ← 计算3-5月的平均值

每个窗口都能看到3个月的数据并计算结果
```

### 1.2 窗口函数的基本语法


```sql
窗口函数名() OVER (
    PARTITION BY 分组字段    -- 可选：数据分组
    ORDER BY 排序字段       -- 通常必需：定义窗口顺序
    ROWS/RANGE 窗口范围     -- 可选：定义窗口大小
)
```

**实际示例**：
```sql
SELECT 
    日期,
    销售额,
    -- 计算最近3天的平均销售额
    AVG(销售额) OVER (
        ORDER BY 日期 
        ROWS 2 PRECEDING
    ) AS 三日平均
FROM 销售表;
```

### 1.3 窗口类型对比


| 窗口类型 | **定义方式** | **特点** | **适用场景** |
|---------|-------------|---------|-------------|
| **固定窗口** | `ROWS n PRECEDING` | 窗口大小固定 | 移动平均、趋势分析 |
| **累积窗口** | `ROWS UNBOUNDED PRECEDING` | 从开始累积到当前 | 累计销售、总计统计 |
| **滑动窗口** | `ROWS BETWEEN ... AND ...` | 灵活定义范围 | 复杂分析场景 |
| **时间窗口** | `RANGE INTERVAL ... PRECEDING` | 基于时间范围 | 实时数据分析 |

---

## 2. 🎯 滑动窗口实现技术


### 2.1 固定大小滑动窗口


**核心概念**：窗口大小始终保持不变，像一个固定尺寸的**放大镜**在数据上移动。

**基础语法结构**：
```sql
-- 固定窗口模板
函数名 OVER (
    ORDER BY 排序字段
    ROWS n PRECEDING  -- 向前n行 + 当前行 = n+1个数据点
)
```

**实际应用示例**：
```sql
-- 计算股票的5日移动平均线
SELECT 
    交易日期,
    收盘价,
    AVG(收盘价) OVER (
        ORDER BY 交易日期
        ROWS 4 PRECEDING  -- 前4行 + 当前行 = 5日平均
    ) AS MA5,
    AVG(收盘价) OVER (
        ORDER BY 交易日期  
        ROWS 19 PRECEDING -- 前19行 + 当前行 = 20日平均
    ) AS MA20
FROM 股票价格表
WHERE 股票代码 = '000001'
ORDER BY 交易日期;
```

**窗口移动过程图解**：
```
数据: [10, 15, 12, 18, 20, 16, 22, 14]
3日移动平均计算过程:

第1天: [10]           → 无法计算(数据不足)
第2天: [10,15]        → 无法计算(数据不足) 
第3天: [10,15,12]     → (10+15+12)/3 = 12.3
第4天: [15,12,18]     → (15+12+18)/3 = 15.0
第5天: [12,18,20]     → (12+18+20)/3 = 16.7
第6天: [18,20,16]     → (18+20+16)/3 = 18.0
```

### 2.2 灵活范围滑动窗口


**BETWEEN语法**：可以精确控制窗口的前后边界。

```sql
-- 灵活窗口语法
函数名 OVER (
    ORDER BY 排序字段
    ROWS BETWEEN 起始位置 AND 结束位置
)

-- 位置关键词说明：
-- UNBOUNDED PRECEDING: 从最开始
-- n PRECEDING: 当前行前n行  
-- CURRENT ROW: 当前行
-- n FOLLOWING: 当前行后n行
-- UNBOUNDED FOLLOWING: 到最后
```

**实用场景示例**：
```sql
-- 电商网站：计算用户行为的滑动窗口指标
SELECT 
    user_id,
    access_time,
    page_views,
    -- 前后各2小时的页面浏览总数
    SUM(page_views) OVER (
        PARTITION BY user_id
        ORDER BY access_time
        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING
    ) AS 五点平滑总数,
    
    -- 当前及之后3个时点的最大值
    MAX(page_views) OVER (
        PARTITION BY user_id  
        ORDER BY access_time
        ROWS BETWEEN CURRENT ROW AND 3 FOLLOWING
    ) AS 未来峰值
FROM 用户行为表;
```

### 2.3 时间滑动窗口


**核心优势**：基于实际时间间隔，不受数据密度影响。

```sql
-- 时间窗口语法(MySQL 8.0+, PostgreSQL)
函数名 OVER (
    ORDER BY 时间字段
    RANGE BETWEEN INTERVAL 'n' 时间单位 PRECEDING 
              AND CURRENT ROW
)
```

**实时监控示例**：
```sql
-- 网站性能监控：计算最近1小时的平均响应时间
SELECT 
    请求时间,
    响应时间ms,
    AVG(响应时间ms) OVER (
        ORDER BY 请求时间
        RANGE BETWEEN INTERVAL '1' HOUR PRECEDING 
                  AND CURRENT ROW
    ) AS 一小时平均响应时间,
    
    COUNT(*) OVER (
        ORDER BY 请求时间  
        RANGE BETWEEN INTERVAL '5' MINUTE PRECEDING
                  AND CURRENT ROW
    ) AS 五分钟请求量
FROM 请求日志表
WHERE 请求时间 >= NOW() - INTERVAL '24' HOUR;
```

---

## 3. 📈 累积窗口计算


### 3.1 累积窗口基本概念


**通俗解释**：累积窗口就像银行账户的**余额变化**，每一笔交易都会影响从开户到现在的总余额。

```sql
-- 累积窗口基本语法
函数名 OVER (
    [PARTITION BY 分组字段]
    ORDER BY 排序字段
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
)
-- 简化写法：
函数名 OVER (ORDER BY 排序字段)  -- 默认就是累积窗口
```

### 3.2 常用累积计算


**财务报表累积统计**：
```sql
-- 公司财务月报：累积收入和支出分析
SELECT 
    月份,
    当月收入,
    当月支出,
    -- 累积收入 (年初至今)
    SUM(当月收入) OVER (
        ORDER BY 月份
    ) AS 累积收入,
    
    -- 累积支出
    SUM(当月支出) OVER (
        ORDER BY 月份  
    ) AS 累积支出,
    
    -- 累积净利润
    SUM(当月收入 - 当月支出) OVER (
        ORDER BY 月份
    ) AS 累积净利润,
    
    -- 累积平均月收入
    AVG(当月收入) OVER (
        ORDER BY 月份
    ) AS 累积平均月收入
FROM 财务月报表
WHERE 年份 = 2024;
```

### 3.3 分组累积计算


**多维度累积分析**：
```sql
-- 各部门销售业绩累积分析
SELECT 
    部门,
    销售员,
    月份, 
    当月销售额,
    -- 每个销售员的累积业绩
    SUM(当月销售额) OVER (
        PARTITION BY 部门, 销售员
        ORDER BY 月份
    ) AS 个人累积销售额,
    
    -- 部门整体累积业绩  
    SUM(当月销售额) OVER (
        PARTITION BY 部门
        ORDER BY 月份
    ) AS 部门累积销售额,
    
    -- 个人在部门中的累积占比
    ROUND(
        SUM(当月销售额) OVER (
            PARTITION BY 部门, 销售员 
            ORDER BY 月份
        ) * 100.0 / 
        SUM(当月销售额) OVER (
            PARTITION BY 部门 
            ORDER BY 月份
        ), 2
    ) AS 个人累积占比
FROM 销售业绩表
ORDER BY 部门, 销售员, 月份;
```

---

## 4. ⚡ 实时窗口处理


### 4.1 实时滑动窗口挑战


**核心问题**：传统SQL窗口函数主要用于**历史数据分析**，而实时场景需要：
- **低延迟处理** - 毫秒级响应
- **内存效率** - 不能存储所有历史数据  
- **动态更新** - 数据持续流入和流出

### 4.2 窗口数据更新策略


**策略对比分析**：

| 更新策略 | **实现方式** | **性能** | **内存占用** | **适用场景** |
|---------|-------------|---------|-------------|-------------|
| **全量重算** | 每次都计算整个窗口 | 🔴 慢 | 🔴 高 | 小数据量 |
| **增量更新** | 只计算新增/删除的影响 | 🟢 快 | 🟢 低 | 实时流处理 |
| **预计算缓存** | 提前计算并缓存结果 | 🟢 快 | 🟡 中 | 固定窗口 |
| **近似计算** | 使用统计采样方法 | 🟢 快 | 🟢 低 | 大数据近似分析 |

### 4.3 实时窗口实现方案


**方案1：基于Redis的滑动窗口**
```sql
-- 使用Redis有序集合实现实时滑动窗口
-- 伪代码逻辑：

-- 1. 添加新数据点
ZADD real_time_window 时间戳 数据值

-- 2. 清理过期数据  
ZREMRANGEBYSCORE real_time_window 0 (当前时间-窗口大小)

-- 3. 计算窗口统计
ZCARD real_time_window        -- 窗口内数据点数量
ZRANGE real_time_window 0 -1 -- 获取所有窗口数据进行计算
```

**方案2：应用层滑动窗口**
```python
# Python实现固定大小滑动窗口
class SlidingWindow:
    def __init__(self, window_size):
        self.window_size = window_size
        self.data = []
        self.sum = 0
    
    def add(self, value):
        self.data.append(value)  
        self.sum += value
        
        # 窗口超出大小时，移除最老的数据
        if len(self.data) > self.window_size:
            oldest = self.data.pop(0)
            self.sum -= oldest
    
    def average(self):
        return self.sum / len(self.data) if self.data else 0

# 使用示例
window = SlidingWindow(5)  # 5个数据点的窗口
for value in [10, 15, 12, 18, 20, 16, 22]:
    window.add(value)
    print(f"当前平均值: {window.average():.2f}")
```

---

## 5. 🔧 窗口优化策略


### 5.1 索引优化


**关键索引策略**：
```sql
-- 为窗口函数创建最优索引
-- 原则：PARTITION BY字段 + ORDER BY字段

-- 示例：优化这个查询
SELECT 
    用户ID, 订单日期, 订单金额,
    SUM(订单金额) OVER (
        PARTITION BY 用户ID 
        ORDER BY 订单日期
        ROWS 6 PRECEDING
    ) AS 七日累计消费
FROM 订单表;

-- 创建复合索引
CREATE INDEX idx_orders_window 
ON 订单表(用户ID, 订单日期, 订单金额);
```

### 5.2 🔑 实时窗口计算优化


**优化技巧汇总**：

**① 数据预处理**
```sql
-- 将原始数据预聚合，减少窗口计算量
CREATE VIEW 小时级汇总 AS
SELECT 
    用户ID,
    DATE_FORMAT(订单时间, '%Y-%m-%d %H:00:00') AS 小时,
    SUM(订单金额) AS 小时销售额,
    COUNT(*) AS 小时订单数
FROM 订单表  
GROUP BY 用户ID, DATE_FORMAT(订单时间, '%Y-%m-%d %H:00:00');

-- 基于预聚合数据计算滑动窗口
SELECT 
    用户ID, 小时, 小时销售额,
    AVG(小时销售额) OVER (
        PARTITION BY 用户ID
        ORDER BY 小时
        ROWS 23 PRECEDING  -- 24小时滑动平均
    ) AS 24小时平均销售额
FROM 小时级汇总;
```

**② 分区策略优化**
```sql
-- 按时间分区减少扫描范围
SELECT 
    交易时间, 交易金额,
    SUM(交易金额) OVER (
        ORDER BY 交易时间
        ROWS 99 PRECEDING  -- 最近100笔交易
    ) AS 百笔交易总额
FROM 交易表
WHERE 交易时间 >= CURDATE() - INTERVAL 7 DAY  -- 限制扫描范围
ORDER BY 交易时间;
```

**③ 内存优化**
```sql
-- 避免在窗口函数中使用大字段
SELECT 
    订单ID,
    订单时间,
    -- ❌ 错误：在窗口函数中包含大字段
    -- FIRST_VALUE(订单详情) OVER (...) 
    
    -- ✅ 正确：只在窗口函数中使用必要字段
    FIRST_VALUE(订单ID) OVER (
        PARTITION BY 用户ID
        ORDER BY 订单时间 DESC
    ) AS 最新订单ID
FROM 订单表;
```

---

## 6. 🚀 实际应用场景


### 6.1 🔑 滑动窗口应用场景


**金融风控实时监控**：
```sql
-- 信用卡异常交易检测：滑动窗口分析
WITH 交易分析 AS (
    SELECT 
        卡号,
        交易时间,
        交易金额,
        商户类型,
        -- 最近1小时交易次数
        COUNT(*) OVER (
            PARTITION BY 卡号
            ORDER BY 交易时间
            RANGE BETWEEN INTERVAL '1' HOUR PRECEDING 
                      AND CURRENT ROW
        ) AS 小时交易次数,
        
        -- 最近1小时交易金额  
        SUM(交易金额) OVER (
            PARTITION BY 卡号
            ORDER BY 交易时间
            RANGE BETWEEN INTERVAL '1' HOUR PRECEDING
                      AND CURRENT ROW  
        ) AS 小时交易总额,
        
        -- 最近24小时平均交易金额
        AVG(交易金额) OVER (
            PARTITION BY 卡号
            ORDER BY 交易时间
            RANGE BETWEEN INTERVAL '24' HOUR PRECEDING
                      AND CURRENT ROW
        ) AS 日均交易金额
    FROM 信用卡交易表
    WHERE 交易时间 >= NOW() - INTERVAL '48' HOUR
)
SELECT 
    卡号, 交易时间, 交易金额, 商户类型,
    小时交易次数, 小时交易总额,
    CASE 
        WHEN 小时交易次数 > 10 THEN '高频警告'
        WHEN 小时交易总额 > 50000 THEN '大额警告'  
        WHEN 交易金额 > 5 * 日均交易金额 THEN '异常金额警告'
        ELSE '正常'
    END AS 风险等级
FROM 交易分析
WHERE 交易时间 >= NOW() - INTERVAL '2' HOUR
ORDER BY 风险等级 DESC, 交易时间 DESC;
```

**网站性能监控**：
```sql  
-- Web应用实时性能监控仪表板
SELECT 
    监控时间,
    响应时间ms,
    CPU使用率,
    内存使用率,
    -- 5分钟滑动平均响应时间
    AVG(响应时间ms) OVER (
        ORDER BY 监控时间
        RANGE BETWEEN INTERVAL '5' MINUTE PRECEDING
                  AND CURRENT ROW
    ) AS 五分钟平均响应,
    
    -- 最近10个数据点的最大响应时间  
    MAX(响应时间ms) OVER (
        ORDER BY 监控时间
        ROWS 9 PRECEDING
    ) AS 十点最大响应,
    
    -- 性能趋势：与1小时前比较
    响应时间ms - LAG(响应时间ms, 12) OVER (
        ORDER BY 监控时间
    ) AS 小时响应趋势,
    
    -- 异常检测：当前值与近期平均值比较
    CASE 
        WHEN 响应时间ms > 2 * AVG(响应时间ms) OVER (
            ORDER BY 监控时间
            ROWS 19 PRECEDING  
        ) THEN '性能异常'
        ELSE '正常'
    END AS 性能状态
FROM 系统监控表
WHERE 监控时间 >= NOW() - INTERVAL '4' HOUR
ORDER BY 监控时间 DESC;
```

### 6.2 业务智能分析


**电商用户行为分析**：
```sql
-- 用户购买行为滑动窗口分析
SELECT 
    用户ID,
    购买日期, 
    订单金额,
    商品类别,
    -- 用户购买频率趋势分析
    COUNT(*) OVER (
        PARTITION BY 用户ID
        ORDER BY 购买日期
        RANGE BETWEEN INTERVAL '30' DAY PRECEDING
                  AND CURRENT ROW
    ) AS 月购买次数,
    
    -- 用户消费能力分析
    AVG(订单金额) OVER (
        PARTITION BY 用户ID
        ORDER BY 购买日期  
        ROWS 4 PRECEDING  -- 最近5次购买平均
    ) AS 近期平均消费,
    
    -- 用户价值评分
    SUM(订单金额) OVER (
        PARTITION BY 用户ID
        ORDER BY 购买日期
        RANGE BETWEEN INTERVAL '90' DAY PRECEDING
                  AND CURRENT ROW
    ) AS 季度消费总额,
    
    -- 购买多样性分析
    COUNT(DISTINCT 商品类别) OVER (
        PARTITION BY 用户ID
        ORDER BY 购买日期
        ROWS 9 PRECEDING  -- 最近10次购买
    ) AS 购买类别多样性
FROM 订单表
WHERE 购买日期 >= CURDATE() - INTERVAL '1' YEAR
ORDER BY 用户ID, 购买日期;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 滑动窗口：固定大小的移动计算窗口，如移动平均线
🔸 累积窗口：从起点累积到当前位置的计算，如累计销售额  
🔸 时间窗口：基于时间间隔的窗口，适合实时数据流分析
🔸 窗口更新：实时场景下的增量计算和数据过期处理
```

### 7.2 关键语法掌握


**窗口定义语法**：
```sql
-- 固定行数窗口
ROWS n PRECEDING                    -- 前n行+当前行
ROWS BETWEEN m PRECEDING AND n FOLLOWING  -- 前m行到后n行

-- 时间间隔窗口  
RANGE BETWEEN INTERVAL 'n' HOUR PRECEDING AND CURRENT ROW

-- 累积窗口
ROWS UNBOUNDED PRECEDING           -- 从开始到当前行
```

### 7.3 性能优化要点


**🔹 索引策略**
```
核心原则：为 PARTITION BY + ORDER BY 字段创建复合索引
索引顺序：分区字段在前，排序字段在后
覆盖索引：包含SELECT字段避免回表查询
```

**🔹 查询优化**  
```
数据预处理：通过聚合减少计算量
范围限制：使用WHERE子句限制扫描范围  
分区裁剪：利用分区表减少数据扫描
内存优化：避免大字段参与窗口计算
```

### 7.4 实际应用指导


**选择窗口类型的原则**：
- **移动平均、趋势分析** → 固定大小滑动窗口
- **累计统计、总计计算** → 累积窗口  
- **实时监控、时间序列** → 时间滑动窗口
- **异常检测、性能监控** → 灵活范围窗口

**实时应用场景**：
- **金融风控** - 交易频率和金额异常检测
- **网站监控** - 响应时间和错误率实时分析
- **业务分析** - 用户行为和销售趋势监控
- **物联网** - 传感器数据流处理和告警

**核心记忆要点**：
- 滑动窗口像移动的放大镜，观察数据的局部特征
- 累积窗口像银行余额，不断累加历史数据  
- 实时处理需要考虑内存效率和计算性能
- 合理的索引设计是窗口函数性能的关键
- 不同业务场景选择最适合的窗口类型和计算策略