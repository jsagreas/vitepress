---
title: 17、窗口函数执行顺序
---
## 📚 目录

1. [SQL执行顺序基础](#1-SQL执行顺序基础)
2. [窗口函数在SQL执行中的位置](#2-窗口函数在SQL执行中的位置)
3. [WHERE与HAVING对窗口函数的影响](#3-WHERE与HAVING对窗口函数的影响)
4. [窗口函数计算时机详解](#4-窗口函数计算时机详解)
5. [多窗口函数执行顺序](#5-多窗口函数执行顺序)
6. [执行顺序对性能的影响](#6-执行顺序对性能的影响)
7. [实际应用案例分析](#7-实际应用案例分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 SQL执行顺序基础


### 1.1 标准SQL执行顺序

理解窗口函数的执行时机，首先要掌握SQL语句的执行顺序：

```
SQL执行的逻辑顺序（不是书写顺序）：

1. FROM      ← 确定数据来源
2. WHERE     ← 行级过滤（在分组前）
3. GROUP BY  ← 数据分组
4. HAVING    ← 组级过滤（在分组后）
5. SELECT    ← 选择列和计算（包括窗口函数）
6. ORDER BY  ← 结果排序
7. LIMIT     ← 限制结果行数
```

### 1.2 执行顺序与书写顺序的区别

```sql
-- 书写顺序（人类习惯）
SELECT column1, SUM(column2) 
FROM table1 
WHERE condition1 
GROUP BY column1 
HAVING SUM(column2) > 100 
ORDER BY column1 
LIMIT 10;

-- 但数据库执行时是按逻辑顺序处理的：
-- 1. FROM table1
-- 2. WHERE condition1  
-- 3. GROUP BY column1
-- 4. HAVING SUM(column2) > 100
-- 5. SELECT column1, SUM(column2)
-- 6. ORDER BY column1
-- 7. LIMIT 10
```

### 1.3 为什么执行顺序很重要

```
执行顺序影响：
├── 哪些列可以在哪个阶段使用
├── 聚合函数的计算时机
├── 窗口函数能访问到什么数据
└── 查询性能和结果正确性
```

---

## 2. 🪟 窗口函数在SQL执行中的位置


### 2.1 窗口函数的执行时机

**核心概念**：窗口函数在`SELECT`阶段执行，这个时机很关键。

```
详细执行流程：

1. FROM        ← 获取基础数据
2. WHERE       ← 过滤行（窗口函数还不存在）
3. GROUP BY    ← 分组（如果有）
4. HAVING      ← 组过滤（窗口函数还不存在）
5. SELECT      ← ★ 窗口函数在这里计算
   ├── 先计算非窗口函数列
   ├── 再计算窗口函数
   └── 基于前面步骤的结果集
6. ORDER BY    ← 可以使用窗口函数结果
7. LIMIT       ← 可以基于窗口函数结果限制
```

### 2.2 窗口函数执行机制理解

```sql
-- 示例表数据
CREATE TABLE sales (
    id INT,
    department VARCHAR(10),
    employee VARCHAR(10),
    salary INT
);

INSERT INTO sales VALUES
(1, 'IT', '张三', 8000),
(2, 'IT', '李四', 9000),
(3, 'HR', '王五', 7000),
(4, 'HR', '赵六', 7500);
```

**执行步骤分解**：
```sql
SELECT 
    employee,
    department,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank_num
FROM sales 
WHERE salary > 7000;

-- 执行过程：
-- 步骤1：FROM sales（获取所有数据）
-- 步骤2：WHERE salary > 7000（过滤掉王五，剩余3行）
-- 步骤3：SELECT阶段开始
--        先选择 employee, department, salary
--        再计算窗口函数 ROW_NUMBER() OVER (...)
--        窗口函数基于过滤后的3行数据计算
```

### 2.3 窗口函数访问的数据集

```
窗口函数能看到的数据：
├── 经过FROM获取的基础数据
├── 经过WHERE过滤后的数据
├── 经过GROUP BY分组后的数据（如果有）
├── 经过HAVING过滤后的数据（如果有）
└── 但看不到其他窗口函数的结果
```

**重要理解**：
```sql
-- 错误理解：认为窗口函数能看到原始表的所有数据
-- 正确理解：窗口函数只能看到经过WHERE等过滤后的数据

SELECT 
    employee,
    salary,
    AVG(salary) OVER () as avg_salary
FROM sales 
WHERE department = 'IT';

-- avg_salary只计算IT部门的平均工资，不是全公司平均工资
-- 因为WHERE已经过滤掉了HR部门的数据
```

---

## 3. ⚖️ WHERE与HAVING对窗口函数的影响


### 3.1 WHERE子句对窗口函数的影响

**核心原则**：WHERE在窗口函数执行前过滤数据，会直接影响窗口函数的计算结果。

```sql
-- 场景1：WHERE过滤影响窗口函数计算基础
SELECT 
    employee,
    department,
    salary,
    RANK() OVER (ORDER BY salary DESC) as salary_rank
FROM sales 
WHERE salary >= 8000;  -- 只有张三(8000)和李四(9000)

-- 结果：
-- 李四  IT  9000  1  
-- 张三  IT  8000  2
-- 排名是基于过滤后的数据计算的，不是基于全表
```

```sql
-- 场景2：不同WHERE条件产生不同的窗口计算结果
-- 查询1：
SELECT department, AVG(salary) OVER () as avg_all
FROM sales WHERE salary > 7000;  -- 平均值基于3个人

-- 查询2：  
SELECT department, AVG(salary) OVER () as avg_all
FROM sales WHERE salary > 8000;  -- 平均值基于2个人

-- 两个查询的avg_all值完全不同
```

### 3.2 HAVING子句对窗口函数的影响

```sql
-- HAVING也在窗口函数执行前生效
SELECT 
    department,
    COUNT(*) as dept_count,
    DENSE_RANK() OVER (ORDER BY COUNT(*)) as dept_rank
FROM sales 
GROUP BY department
HAVING COUNT(*) >= 2;  -- 只保留人数>=2的部门

-- 如果某些部门被HAVING过滤掉，窗口函数看不到它们
-- 窗口函数的排名只基于满足HAVING条件的分组
```

### 3.3 窗口函数不能在WHERE/HAVING中使用

```sql
-- ❌ 错误：不能在WHERE中使用窗口函数
SELECT employee, salary
FROM sales 
WHERE ROW_NUMBER() OVER (ORDER BY salary) = 1;  -- 语法错误

-- ❌ 错误：不能在HAVING中使用窗口函数  
SELECT department, COUNT(*)
FROM sales 
GROUP BY department
HAVING ROW_NUMBER() OVER (ORDER BY COUNT(*)) = 1;  -- 语法错误
```

**原因解释**：
```
为什么不能在WHERE/HAVING中使用窗口函数？

执行顺序决定的：
WHERE/HAVING执行时，窗口函数还没有计算
就像你不能在买菜时使用还没做出来的菜的味道来决定买什么菜
```

**正确的替代方案**：
```sql
-- 使用子查询
SELECT * FROM (
    SELECT 
        employee, 
        salary,
        ROW_NUMBER() OVER (ORDER BY salary DESC) as rn
    FROM sales
) t WHERE rn = 1;  -- 获取工资最高的员工
```

---

## 4. ⏰ 窗口函数计算时机详解


### 4.1 窗口函数的计算步骤

```
窗口函数计算的详细过程：

1. 数据准备阶段
   ├── FROM: 获取基础数据
   ├── WHERE: 行级过滤
   ├── GROUP BY: 分组（如果有）
   └── HAVING: 组级过滤（如果有）

2. SELECT阶段窗口函数计算
   ├── 步骤1: 根据PARTITION BY分区
   ├── 步骤2: 在每个分区内根据ORDER BY排序
   ├── 步骤3: 确定窗口框架（ROWS/RANGE）
   └── 步骤4: 计算窗口函数值

3. 后续阶段
   ├── ORDER BY: 可以使用窗口函数结果排序
   └── LIMIT: 可以基于窗口函数结果限制行数
```

### 4.2 窗口函数计算示例

```sql
-- 详细展示窗口函数的计算过程
SELECT 
    employee,
    department,
    salary,
    -- 窗口函数1：部门内排名
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank,
    -- 窗口函数2：累计工资
    SUM(salary) OVER (PARTITION BY department ORDER BY salary DESC) as running_sum
FROM sales 
WHERE salary > 6500  -- 先过滤
ORDER BY department, dept_rank;  -- 最后排序，可以使用窗口函数结果

-- 执行过程：
-- 1. WHERE过滤：保留所有4行数据（都>6500）
-- 2. SELECT阶段：
--    a) 按department分区：IT组(张三,李四), HR组(王五,赵六)
--    b) 各分区内按salary DESC排序
--    c) 计算ROW_NUMBER()和SUM()
-- 3. ORDER BY：按department和计算出的dept_rank排序
```

### 4.3 窗口函数与聚合函数的计算时机对比

```sql
-- 聚合函数在GROUP BY阶段计算
-- 窗口函数在SELECT阶段计算

SELECT 
    department,
    COUNT(*) as total_count,        -- GROUP BY阶段计算
    salary,
    COUNT(*) OVER () as window_count -- SELECT阶段计算，看到的是分组后的数据
FROM sales 
GROUP BY department, salary;

-- 理解：
-- total_count: 每个(department,salary)组合的数量
-- window_count: 总的分组数量（不是原始行数）
```

---

## 5. 🔢 多窗口函数执行顺序


### 5.1 同一SELECT中多个窗口函数的执行

**重要概念**：同一SELECT中的多个窗口函数是**相互独立**计算的，没有依赖关系。

```sql
-- 多个窗口函数同时存在
SELECT 
    employee,
    department,
    salary,
    -- 这些窗口函数都基于相同的数据集独立计算
    ROW_NUMBER() OVER (ORDER BY salary DESC) as overall_rank,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank,
    AVG(salary) OVER (PARTITION BY department) as dept_avg,
    SUM(salary) OVER () as total_salary
FROM sales;

-- 执行特点：
-- 1. 所有窗口函数都基于WHERE等过滤后的相同数据集
-- 2. 窗口函数之间不能相互引用
-- 3. 每个窗口函数都独立进行分区、排序、计算
```

### 5.2 窗口函数不能嵌套使用

```sql
-- ❌ 错误：窗口函数不能嵌套
SELECT 
    employee,
    RANK() OVER (ORDER BY ROW_NUMBER() OVER (ORDER BY salary)) as nested_rank
FROM sales;  -- 语法错误

-- ✅ 正确：使用子查询实现类似效果
SELECT 
    employee,
    RANK() OVER (ORDER BY rn) as final_rank
FROM (
    SELECT 
        employee,
        ROW_NUMBER() OVER (ORDER BY salary) as rn
    FROM sales
) t;
```

### 5.3 多窗口函数的性能考虑

```sql
-- 相同的OVER子句可以复用计算结果
SELECT 
    employee,
    salary,
    -- 相同的OVER子句，数据库可能会优化
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rn,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank_num,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dense_rank_num
FROM sales;

-- 优化提示：
-- 数据库引擎通常会识别相同的OVER子句
-- 只执行一次分区和排序，然后计算多个窗口函数
```

---

## 6. 🚀 执行顺序对性能的影响


### 6.1 WHERE过滤对窗口函数性能的影响

```sql
-- 性能优化：WHERE过滤减少窗口函数处理的数据量
-- 好的做法：先过滤再计算窗口函数
SELECT 
    employee,
    salary,
    RANK() OVER (ORDER BY salary DESC) as salary_rank
FROM sales 
WHERE department = 'IT'    -- 减少数据量
  AND salary > 7000;       -- 进一步过滤

-- 窗口函数只需要处理过滤后的少量数据
-- 性能比处理全表数据后再过滤要好得多
```

### 6.2 索引对窗口函数性能的影响

```sql
-- 创建合适的索引可以提升窗口函数性能
CREATE INDEX idx_dept_salary ON sales(department, salary DESC);

-- 这个索引对以下查询特别有效：
SELECT 
    employee,
    department,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rn
FROM sales;

-- 原因：
-- 1. 数据已经按department分区
-- 2. 每个分区内已经按salary DESC排序
-- 3. 窗口函数可以直接使用排序后的数据
```

### 6.3 避免不必要的窗口函数计算

```sql
-- ❌ 低效：计算了不需要的窗口函数
SELECT 
    employee,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as rn,
    RANK() OVER (ORDER BY salary DESC) as rank_num
FROM sales 
WHERE ROW_NUMBER() OVER (ORDER BY salary DESC) = 1;  -- 错误且低效

-- ✅ 高效：使用子查询，只计算需要的部分
SELECT employee, salary
FROM (
    SELECT 
        employee,
        salary,
        ROW_NUMBER() OVER (ORDER BY salary DESC) as rn
    FROM sales
) t
WHERE rn = 1;  -- 只获取第一名
```

### 6.4 窗口函数与LIMIT的性能关系

```sql
-- 理解：LIMIT在窗口函数计算完成后执行
SELECT 
    employee,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) as salary_rank
FROM sales 
ORDER BY salary DESC
LIMIT 5;  -- 窗口函数仍会为所有行计算，然后才限制输出

-- 性能影响：
-- 即使只需要前5行结果，窗口函数仍会计算全表
-- 如果表很大，这可能影响性能
-- 考虑是否真的需要窗口函数，或者使用其他方法
```

---

## 7. 📊 实际应用案例分析


### 7.1 案例1：部门工资排名分析

```sql
-- 需求：查找每个部门工资前3名的员工
-- 错误的理解和正确的实现

-- ❌ 错误理解：认为可以直接在WHERE中使用窗口函数
SELECT employee, department, salary
FROM sales 
WHERE RANK() OVER (PARTITION BY department ORDER BY salary DESC) <= 3;

-- ✅ 正确实现：使用子查询
SELECT employee, department, salary, dept_rank
FROM (
    SELECT 
        employee,
        department,
        salary,
        RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank
    FROM sales 
    WHERE salary > 0  -- WHERE过滤在窗口函数计算前生效
) ranked_employees
WHERE dept_rank <= 3;  -- 基于窗口函数结果过滤

-- 执行过程分析：
-- 1. 内层查询：WHERE salary > 0 过滤数据
-- 2. 内层查询：计算每个部门内的工资排名
-- 3. 外层查询：基于排名结果选择前3名
```

### 7.2 案例2：累计销售额与比例分析

```sql
-- 需求：计算每月累计销售额和占总额比例
CREATE TABLE monthly_sales (
    month_num INT,
    sales_amount DECIMAL(10,2)
);

INSERT INTO monthly_sales VALUES
(1, 10000), (2, 15000), (3, 12000), (4, 18000);

SELECT 
    month_num,
    sales_amount,
    -- 累计销售额
    SUM(sales_amount) OVER (ORDER BY month_num) as cumulative_sales,
    -- 占总额比例
    ROUND(sales_amount / SUM(sales_amount) OVER () * 100, 2) as percentage
FROM monthly_sales 
WHERE sales_amount > 5000  -- 过滤小额销售
ORDER BY month_num;

-- 执行顺序分析：
-- 1. FROM: 获取数据
-- 2. WHERE: 过滤销售额>5000的记录（本例中全部保留）
-- 3. SELECT: 计算窗口函数
--    - SUM() OVER (ORDER BY month_num): 基于过滤后数据计算累计
--    - SUM() OVER (): 基于过滤后数据计算总额
-- 4. ORDER BY: 按月份排序
```

### 7.3 案例3：动态排名与排名变化

```sql
-- 需求：分析员工工资排名，并标识排名变化
-- 假设有历史工资数据
CREATE TABLE salary_history (
    employee VARCHAR(10),
    period INT,
    salary INT
);

SELECT 
    employee,
    period,
    salary,
    -- 当期排名
    RANK() OVER (PARTITION BY period ORDER BY salary DESC) as current_rank,
    -- 上期排名（使用LAG函数）
    LAG(RANK() OVER (PARTITION BY period ORDER BY salary DESC)) 
        OVER (PARTITION BY employee ORDER BY period) as prev_rank
FROM salary_history 
WHERE period >= 202301  -- 只分析最近的数据
ORDER BY employee, period;

-- 注意事项：
-- 1. WHERE过滤影响所有窗口函数的计算基础
-- 2. 多层窗口函数需要仔细设计分区和排序条件
-- 3. 确保逻辑正确性：排名基于过滤后的数据
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念

```
🔸 SQL执行顺序：FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY→LIMIT
🔸 窗口函数位置：在SELECT阶段执行，基于前面步骤过滤后的数据
🔸 影响因素：WHERE和HAVING会影响窗口函数的计算基础数据
🔸 使用限制：窗口函数不能在WHERE、HAVING中使用
🔸 独立性：同一SELECT中的多个窗口函数相互独立计算
```

### 8.2 关键理解要点


**🔹 执行时机的重要性**
```
记忆要点：
- 窗口函数"看到"的数据是经过WHERE等过滤后的结果
- 不是原始表的全部数据
- 这直接影响窗口函数的计算结果

实际影响：
- 平均值计算基于过滤后的数据
- 排名基于过滤后的数据
- 分区也基于过滤后的数据
```

**🔹 WHERE与窗口函数的关系**
```
核心理解：
WHERE先执行 → 过滤数据 → 窗口函数基于过滤后的数据计算

常见误解：
❌ 认为窗口函数能看到全表数据
✅ 窗口函数只能看到WHERE过滤后的数据

实际应用：
- 需要全表统计时，不要在WHERE中过滤
- 需要部分统计时，合理使用WHERE过滤
```

**🔹 性能优化思路**
```
优化策略：
- 使用WHERE减少窗口函数处理的数据量
- 创建适当的索引支持分区和排序
- 避免计算不必要的窗口函数
- 合理使用子查询分离逻辑

性能陷阱：
- LIMIT不能减少窗口函数的计算量
- 窗口函数不能嵌套使用
- 相同OVER子句可以复用计算
```

### 8.3 实际应用指导


**🔸 设计查询的步骤**
```
1. 确定数据过滤条件（WHERE、HAVING）
2. 理解过滤后的数据集
3. 基于过滤后的数据设计窗口函数
4. 使用子查询处理窗口函数结果
5. 考虑性能优化（索引、数据量）
```

**🔸 常见错误避免**
```
❌ 在WHERE中直接使用窗口函数
✅ 使用子查询：先计算窗口函数，再过滤结果

❌ 期望窗口函数基于全表计算，但用了WHERE过滤
✅ 明确窗口函数的计算基础是过滤后的数据

❌ 窗口函数嵌套使用
✅ 使用多层子查询实现复杂逻辑
```

**🔸 调试和验证方法**
```
验证步骤：
1. 先执行不含窗口函数的查询，确认数据集
2. 再添加窗口函数，验证计算结果
3. 检查窗口函数的分区和排序是否正确
4. 使用EXPLAIN分析执行计划和性能
```

**核心记忆**：
```
执行顺序要记牢，窗口函数在SELECT里
WHERE过滤先生效，影响窗口函数基础数据
不能嵌套不能早用，子查询来帮忙
性能优化靠索引，合理过滤减数据
```