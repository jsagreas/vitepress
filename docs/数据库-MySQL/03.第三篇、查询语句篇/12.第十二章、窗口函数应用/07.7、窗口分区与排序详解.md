---
title: 7、窗口分区与排序详解
---
## 📚 目录

1. [窗口分区与排序概述](#1-窗口分区与排序概述)
2. [PARTITION BY分区详解](#2-PARTITION-BY分区详解)
3. [ORDER BY排序机制](#3-ORDER-BY排序机制)
4. [多字段分区排序](#4-多字段分区排序)
5. [分区边界处理](#5-分区边界处理)
6. [空值排序处理](#6-空值排序处理)
7. [分区数据倾斜问题](#7-分区数据倾斜问题)
8. [性能优化策略](#8-性能优化策略)
9. [实战应用案例](#9-实战应用案例)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 窗口分区与排序概述


### 1.1 什么是窗口分区与排序


**简单理解**：窗口分区就是把数据分成一组一组的，然后在每组内部进行排序和计算。就像把全班学生按班级分组，然后在每个班级内按成绩排名。

```sql
-- 基本语法结构
SELECT 
    字段列表,
    窗口函数() OVER (
        PARTITION BY 分区字段     -- 分组条件
        ORDER BY 排序字段        -- 排序规则
    )
FROM 表名;
```

### 1.2 为什么需要分区与排序


**实际业务场景**：
```
场景1：各部门员工工资排名
├─ 不分区：全公司员工一起排名
└─ 分区：每个部门内部分别排名

场景2：每月销售业绩分析  
├─ 不分区：所有月份数据混在一起
└─ 分区：按月份分组，每月内部排序

场景3：学生成绩统计
├─ 不分区：所有年级学生一起比较
└─ 分区：按年级分组，年级内部排名
```

### 1.3 分区与排序的工作流程


```
窗口函数执行流程：
原始数据 → 按PARTITION BY分组 → 组内按ORDER BY排序 → 应用窗口函数 → 返回结果

具体步骤：
1. 数据读取：从表中获取所有符合条件的数据
2. 分区操作：根据PARTITION BY字段将数据分成不同的组
3. 组内排序：在每个分区内按ORDER BY规则排序
4. 窗口计算：在排序后的数据上应用窗口函数
5. 结果返回：保持原始行数，为每行添加计算结果
```

---

## 2. 📊 PARTITION BY分区详解


### 2.1 分区的基本概念


**分区的本质**：就是按照指定字段的值把数据分成若干个独立的组，每个组内的窗口函数计算是相互独立的。

```sql
-- 示例数据：员工表
CREATE TABLE employees (
    id INT,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    hire_date DATE
);

-- 插入测试数据
INSERT INTO employees VALUES
(1, 'Alice', 'Sales', 5000, '2023-01-15'),
(2, 'Bob', 'Sales', 5500, '2023-02-20'),
(3, 'Carol', 'IT', 6000, '2023-01-10'),
(4, 'David', 'IT', 6500, '2023-03-05'),
(5, 'Eve', 'HR', 4500, '2023-02-15');
```

### 2.2 单字段分区示例


```sql
-- 按部门分区，计算每个部门内的工资排名
SELECT 
    name,
    department,
    salary,
    ROW_NUMBER() OVER (
        PARTITION BY department 
        ORDER BY salary DESC
    ) as dept_rank
FROM employees;

-- 执行结果：
name    | department | salary | dept_rank
--------|------------|--------|----------
Bob     | Sales      | 5500   | 1         -- Sales部门第1名
Alice   | Sales      | 5000   | 2         -- Sales部门第2名  
David   | IT         | 6500   | 1         -- IT部门第1名
Carol   | IT         | 6000   | 2         -- IT部门第2名
Eve     | HR         | 4500   | 1         -- HR部门第1名
```

**分区处理过程图示**：
```
原始数据：
[Alice,Sales,5000] [Bob,Sales,5500] [Carol,IT,6000] [David,IT,6500] [Eve,HR,4500]
                ↓ 按department分区
Sales分区：                IT分区：               HR分区：
[Alice,Sales,5000]        [Carol,IT,6000]       [Eve,HR,4500]
[Bob,Sales,5500]          [David,IT,6500]
                ↓ 各分区内按salary DESC排序
Sales分区：                IT分区：               HR分区：
[Bob,Sales,5500]→1        [David,IT,6500]→1     [Eve,HR,4500]→1
[Alice,Sales,5000]→2      [Carol,IT,6000]→2
```

### 2.3 不使用分区的对比


```sql
-- 不使用PARTITION BY：全局排名
SELECT 
    name,
    department,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as global_rank
FROM employees;

-- 结果：全公司统一排名
name    | department | salary | global_rank
--------|------------|--------|------------
David   | IT         | 6500   | 1           -- 全公司第1
Carol   | IT         | 6000   | 2           -- 全公司第2
Bob     | Sales      | 5500   | 3           -- 全公司第3
Alice   | Sales      | 5000   | 4           -- 全公司第4
Eve     | HR         | 4500   | 5           -- 全公司第5
```

> 💡 **理解要点**：PARTITION BY是可选的。不使用时，整个结果集被视为一个大分区。

### 2.4 窗口分区设计策略


**选择分区字段的原则**：

```
🔸 业务逻辑相关性
├─ 分区字段应该与业务需求直接相关
├─ 例如：按部门统计选择department字段
└─ 例如：按时间周期分析选择date字段

🔸 数据分布合理性  
├─ 避免分区过多（每个分区数据太少）
├─ 避免分区过少（失去分区意义）
└─ 理想情况：每个分区有适量数据用于计算

🔸 查询性能考虑
├─ 分区字段最好有索引支持
├─ 避免使用计算字段作为分区依据
└─ 考虑分区字段的基数（不同值的数量）
```

**分区设计实例**：
```sql
-- ✅ 好的分区设计
SELECT 
    product_name,
    sale_date,
    amount,
    SUM(amount) OVER (
        PARTITION BY YEAR(sale_date), QUARTER(sale_date)  -- 按年-季度分区
        ORDER BY sale_date
    ) as quarterly_cumulative
FROM sales;

-- ❌ 不好的分区设计  
SELECT 
    product_name,
    amount,
    ROW_NUMBER() OVER (
        PARTITION BY amount  -- 按金额分区，可能每个分区只有1行
        ORDER BY sale_date
    ) as rank_num
FROM sales;
```

---

## 3. 📈 ORDER BY排序机制


### 3.1 窗口内排序的作用


**排序的重要性**：ORDER BY决定了窗口函数在每个分区内的计算顺序，直接影响结果的正确性。

```sql
-- 同样的数据，不同的排序会产生不同的结果
SELECT 
    name,
    salary,
    hire_date,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as salary_rank,
    ROW_NUMBER() OVER (ORDER BY hire_date ASC) as seniority_rank
FROM employees;

-- 结果对比：
name  | salary | hire_date  | salary_rank | seniority_rank
------|--------|------------|-------------|---------------
David | 6500   | 2023-03-05 | 1          | 4              -- 工资最高，但入职较晚
Carol | 6000   | 2023-01-10 | 2          | 1              -- 工资第二，入职最早
Bob   | 5500   | 2023-02-20 | 3          | 3              
Alice | 5000   | 2023-01-15 | 4          | 2              
Eve   | 4500   | 2023-02-15 | 5          | 5              
```

### 3.2 排序算法选择


**常用排序方式**：

```sql
-- 1. 单字段升序（默认）
ORDER BY salary

-- 2. 单字段降序  
ORDER BY salary DESC

-- 3. 多字段组合排序
ORDER BY department ASC, salary DESC

-- 4. 表达式排序
ORDER BY YEAR(hire_date), salary DESC

-- 5. CASE WHEN条件排序
ORDER BY CASE 
    WHEN department = 'IT' THEN 1
    WHEN department = 'Sales' THEN 2  
    ELSE 3
END, salary DESC
```

### 3.3 排序的性能影响


**排序操作的成本**：
```
排序成本构成：
├─ 内存排序：数据量小时，在内存中快速排序
├─ 外部排序：数据量大时，需要磁盘临时存储
└─ 索引排序：如果排序字段有索引，可以避免排序操作

性能优化建议：
✓ 在常用的ORDER BY字段上创建索引
✓ 避免在计算字段上排序
✓ 合理使用LIMIT减少排序数据量
```

**排序性能测试示例**：
```sql
-- 🚀 高效：使用索引字段排序
SELECT 
    employee_id,
    salary,
    RANK() OVER (ORDER BY employee_id) as id_rank  -- employee_id有主键索引
FROM employees;

-- 🐌 低效：使用计算字段排序
SELECT 
    employee_id, 
    salary,
    RANK() OVER (ORDER BY salary * 0.1 + bonus) as custom_rank  -- 需要计算后排序
FROM employees;
```

---

## 4. 🔄 多字段分区排序


### 4.1 多字段分区的应用场景


**什么时候使用多字段分区**：
- **层级分组**：先按大分类，再按小分类
- **时间维度**：按年份+月份，或年份+季度分组
- **地理维度**：按省份+城市分组
- **业务维度**：按产品类别+品牌分组

```sql
-- 示例：销售数据按年份和季度分区
SELECT 
    product_name,
    sale_date,
    amount,
    YEAR(sale_date) as sale_year,
    QUARTER(sale_date) as sale_quarter,
    SUM(amount) OVER (
        PARTITION BY YEAR(sale_date), QUARTER(sale_date)
        ORDER BY sale_date
    ) as quarterly_running_total,
    AVG(amount) OVER (
        PARTITION BY YEAR(sale_date), QUARTER(sale_date)
    ) as quarterly_avg
FROM sales
ORDER BY sale_date;
```

### 4.2 多字段分区的执行逻辑


**分区组合的工作原理**：
```
PARTITION BY field1, field2 的分区逻辑：

原始数据：
(A, X, 100), (A, Y, 200), (B, X, 300), (A, X, 150), (B, Y, 250)
                ↓ 按field1, field2组合分区
分区1: field1=A, field2=X    分区2: field1=A, field2=Y    分区3: field1=B, field2=X    分区4: field1=B, field2=Y
(A, X, 100)                  (A, Y, 200)                  (B, X, 300)                  (B, Y, 250)
(A, X, 150)
```

**实际示例**：
```sql
-- 按部门和级别分区，计算组内排名
SELECT 
    name,
    department,
    level,
    salary,
    RANK() OVER (
        PARTITION BY department, level
        ORDER BY salary DESC
    ) as dept_level_rank
FROM employees;

-- 假设数据：
name   | department | level  | salary | dept_level_rank
-------|------------|--------|--------|----------------
Alice  | Sales      | Senior | 7000   | 1              -- Sales-Senior组第1名
Bob    | Sales      | Senior | 6500   | 2              -- Sales-Senior组第2名  
Carol  | Sales      | Junior | 4000   | 1              -- Sales-Junior组第1名
David  | IT         | Senior | 8000   | 1              -- IT-Senior组第1名
Eve    | IT         | Junior | 5000   | 1              -- IT-Junior组第1名
```

### 4.3 多字段排序的优先级


**排序字段的优先级规则**：ORDER BY后面的字段从左到右优先级递减。

```sql
-- 多字段排序示例
SELECT 
    name,
    department,
    salary,
    hire_date,
    ROW_NUMBER() OVER (
        PARTITION BY department
        ORDER BY salary DESC, hire_date ASC  -- 先按工资降序，工资相同时按入职时间升序
    ) as rank_num
FROM employees;

-- 排序逻辑：
-- 1. 首先按salary DESC排序（主排序）
-- 2. 工资相同时，按hire_date ASC排序（次排序）
```

**排序优先级示例**：
```
department=Sales的数据排序过程：

原始数据：
Bob   (5500, 2023-02-20)
Alice (5000, 2023-01-15)  
Tom   (5500, 2023-01-10)  -- 与Bob工资相同

第一步：按salary DESC排序
Bob   (5500, 2023-02-20) ←┐ 工资相同，需要次排序
Tom   (5500, 2023-01-10) ←┘
Alice (5000, 2023-01-15)

第二步：工资相同时按hire_date ASC排序  
Tom   (5500, 2023-01-10) → rank=1  -- 工资高且入职早
Bob   (5500, 2023-02-20) → rank=2  -- 工资高但入职晚
Alice (5000, 2023-01-15) → rank=3  -- 工资较低
```

---

## 5. 🎨 分区边界处理


### 5.1 什么是分区边界


**分区边界的概念**：指的是在窗口函数中，如何定义每个计算窗口的数据范围。特别是在使用滑动窗口时，需要明确指定窗口的开始和结束位置。

```sql
-- 窗口边界语法
SELECT 
    字段,
    窗口函数() OVER (
        PARTITION BY 分区字段
        ORDER BY 排序字段
        ROWS|RANGE BETWEEN 开始边界 AND 结束边界
    )
FROM 表名;
```

### 5.2 边界定义方式


**ROWS vs RANGE的区别**：
```
ROWS：基于物理行数定义边界
├─ ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
└─ 含义：当前行的前2行到当前行（共3行）

RANGE：基于逻辑值范围定义边界  
├─ RANGE BETWEEN 100 PRECEDING AND CURRENT ROW
└─ 含义：排序字段值在[当前值-100, 当前值]范围内的所有行
```

**边界关键字说明**：
```
边界位置关键字：
├─ UNBOUNDED PRECEDING：分区开始位置
├─ n PRECEDING：当前行往前n行（ROWS）或当前值-n（RANGE）
├─ CURRENT ROW：当前行
├─ n FOLLOWING：当前行往后n行（ROWS）或当前值+n（RANGE）  
└─ UNBOUNDED FOLLOWING：分区结束位置
```

### 5.3 ROWS边界实例


```sql
-- 计算每行及其前2行的销售总和（3行滑动窗口）
SELECT 
    sale_date,
    amount,
    SUM(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as rolling_3day_sum
FROM daily_sales
ORDER BY sale_date;

-- 示例数据和结果：
sale_date  | amount | rolling_3day_sum | 窗口包含的行
-----------|--------|------------------|-------------
2023-01-01 | 100    | 100             | [当前行]
2023-01-02 | 150    | 250             | [前1行, 当前行]  
2023-01-03 | 200    | 450             | [前2行, 前1行, 当前行]
2023-01-04 | 120    | 470             | [前2行, 前1行, 当前行]
2023-01-05 | 180    | 500             | [前2行, 前1行, 当前行]
```

### 5.4 RANGE边界实例


```sql
-- 计算工资在当前员工±1000范围内的平均工资
SELECT 
    name,
    salary,
    AVG(salary) OVER (
        ORDER BY salary
        RANGE BETWEEN 1000 PRECEDING AND 1000 FOLLOWING
    ) as salary_range_avg
FROM employees
ORDER BY salary;

-- 示例数据和结果：
name  | salary | salary_range_avg | 包含的工资范围
------|--------|------------------|----------------
Eve   | 4500   | 5000            | [4500-1000, 4500+1000] = [3500, 5500]
Alice | 5000   | 5167            | [4000, 6000] 包含Eve, Alice, Bob
Bob   | 5500   | 5500            | [4500, 6500] 包含Eve, Alice, Bob, Carol
Carol | 6000   | 6000            | [5000, 7000] 包含Alice, Bob, Carol
David | 6500   | 6250            | [5500, 7500] 包含Bob, Carol, David
```

### 5.5 默认边界行为


```sql
-- 不指定边界时的默认行为
SELECT 
    name,
    salary,
    SUM(salary) OVER (ORDER BY salary) as running_sum
FROM employees;

-- 等价于：
SELECT 
    name,
    salary,
    SUM(salary) OVER (
        ORDER BY salary
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as running_sum
FROM employees;

-- 结果：累计求和
name  | salary | running_sum
------|--------|------------
Eve   | 4500   | 4500        -- 只包含当前行
Alice | 5000   | 9500        -- 包含Eve + Alice  
Bob   | 5500   | 15000       -- 包含Eve + Alice + Bob
Carol | 6000   | 21000       -- 包含前面所有行
David | 6500   | 27500       -- 包含前面所有行
```

---

## 6. ❓ 空值排序处理


### 6.1 空值排序的默认行为


**SQL标准中的空值排序**：
- **NULLS FIRST**：空值排在最前面
- **NULLS LAST**：空值排在最后面  
- **数据库默认行为**：MySQL默认空值排在最前面（升序时）

```sql
-- 测试数据包含空值
INSERT INTO employees VALUES
(6, 'Frank', 'Sales', NULL, '2023-04-01'),
(7, 'Grace', 'IT', 7000, NULL);

-- 默认空值排序行为
SELECT 
    name,
    salary,
    hire_date,
    ROW_NUMBER() OVER (ORDER BY salary) as salary_rank,
    ROW_NUMBER() OVER (ORDER BY hire_date) as date_rank
FROM employees;

-- 结果：
name  | salary | hire_date  | salary_rank | date_rank
------|--------|------------|-------------|----------
Frank | NULL   | 2023-04-01 | 1          | 4         -- salary为NULL排第一
Eve   | 4500   | 2023-02-15 | 2          | 3
Alice | 5000   | 2023-01-15 | 3          | 2         
Bob   | 5500   | 2023-02-20 | 4          | 5
Carol | 6000   | 2023-01-10 | 5          | 1
David | 6500   | 2023-03-05 | 6          | 6
Grace | 7000   | NULL       | 7          | 1         -- hire_date为NULL排第一
```

### 6.2 明确指定空值排序位置


```sql
-- MySQL 8.0开始支持NULLS FIRST/LAST语法
SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (
        ORDER BY salary DESC NULLS LAST  -- 空值排在最后
    ) as salary_rank
FROM employees;

-- 对于不支持NULLS FIRST/LAST的版本，使用CASE WHEN
SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (
        ORDER BY 
            CASE WHEN salary IS NULL THEN 1 ELSE 0 END,  -- 空值排序标志
            salary DESC  -- 非空值按降序排列
    ) as salary_rank
FROM employees;
```

### 6.3 空值处理策略


**业务中的空值处理方法**：

```sql
-- 策略1：用默认值替换空值
SELECT 
    name,
    COALESCE(salary, 0) as salary,
    ROW_NUMBER() OVER (
        ORDER BY COALESCE(salary, 0) DESC
    ) as salary_rank
FROM employees;

-- 策略2：过滤空值
SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as salary_rank
FROM employees
WHERE salary IS NOT NULL;

-- 策略3：单独处理空值
SELECT 
    name,
    salary,
    CASE 
        WHEN salary IS NULL THEN '待定'
        ELSE CAST(ROW_NUMBER() OVER (
            ORDER BY salary DESC
        ) AS CHAR)
    END as salary_rank
FROM employees;
```

### 6.4 分区中的空值处理


```sql
-- 空值在分区中的表现
SELECT 
    name,
    department,
    salary,
    ROW_NUMBER() OVER (
        PARTITION BY department
        ORDER BY salary DESC NULLS LAST
    ) as dept_rank
FROM employees;

-- 如果department字段有空值
INSERT INTO employees VALUES (8, 'Henry', NULL, 5200, '2023-05-01');

-- NULL部门会形成独立的分区
-- 结果中会看到department为NULL的记录单独分组
```

---

## 7. ⚖️ 分区数据倾斜问题


### 7.1 什么是分区数据倾斜


**数据倾斜的定义**：某些分区的数据量远大于其他分区，导致计算资源分配不均，影响整体性能。

```
数据倾斜示例：
分区A：10000行数据    ← 数据倾斜，这个分区数据过多
分区B：50行数据
分区C：80行数据  
分区D：30行数据

问题：分区A的处理时间远长于其他分区，成为性能瓶颈
```

### 7.2 识别数据倾斜


**检测分区数据分布**：
```sql
-- 检查各分区的数据量分布
SELECT 
    department,
    COUNT(*) as record_count,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary,
    AVG(salary) as avg_salary
FROM employees
GROUP BY department
ORDER BY record_count DESC;

-- 结果示例：
department | record_count | min_salary | max_salary | avg_salary
-----------|--------------|------------|------------|----------
Sales      | 8500        | 3000       | 12000      | 6200      ← 数据倾斜
IT         | 120         | 5000       | 15000      | 8500
HR         | 45          | 4000       | 9000       | 6000
Finance    | 30          | 4500       | 8500       | 6100
```

### 7.3 数据倾斜的影响


**性能影响分析**：
```
倾斜带来的问题：
├─ 内存使用不均：大分区占用过多内存
├─ 处理时间延长：整体查询时间由最慢分区决定
├─ 并行度降低：无法有效利用多核处理能力  
└─ 临时文件过大：可能需要磁盘排序
```

**倾斜影响示例**：
```sql
-- 受倾斜影响的查询
SELECT 
    department,
    name,
    salary,
    RANK() OVER (
        PARTITION BY department  -- Sales分区数据过多，处理缓慢
        ORDER BY salary DESC
    ) as dept_rank
FROM employees;

-- 查询性能分析：
-- Sales分区：8500行数据，需要排序8500行
-- IT分区：120行数据，很快完成
-- HR分区：45行数据，很快完成  
-- 总耗时 ≈ Sales分区的处理时间
```

### 7.4 数据倾斜的解决方案


**解决策略1：重新设计分区**
```sql
-- 原始分区（倾斜）：按department分区
PARTITION BY department

-- 优化分区：按department和salary范围组合分区
PARTITION BY department, 
    CASE 
        WHEN salary < 5000 THEN 'Low'
        WHEN salary < 8000 THEN 'Mid'
        ELSE 'High'
    END
```

**解决策略2：预处理数据**
```sql
-- 对大分区进行采样处理
WITH sampled_data AS (
    SELECT * FROM employees
    WHERE department != 'Sales'  -- 非倾斜分区全量数据
    
    UNION ALL
    
    SELECT * FROM employees  
    WHERE department = 'Sales'
    AND id % 10 = 0  -- Sales分区采样10%数据
)
SELECT 
    department,
    AVG(salary) OVER (PARTITION BY department) as dept_avg
FROM sampled_data;
```

**解决策略3：分批处理**  
```sql
-- 将大分区拆分成多个小批次处理
SELECT 
    batch_id,
    department,
    name,
    salary,
    ROW_NUMBER() OVER (
        PARTITION BY batch_id, department
        ORDER BY salary DESC
    ) as batch_rank
FROM (
    SELECT 
        *,
        (ROW_NUMBER() OVER (ORDER BY id) - 1) DIV 1000 as batch_id
    FROM employees
    WHERE department = 'Sales'
) batched_data;
```

---

## 8. 🚀 性能优化策略


### 8.1 索引优化策略


**为分区和排序字段创建合适的索引**：
```sql
-- 创建支持分区和排序的复合索引
CREATE INDEX idx_dept_salary ON employees(department, salary DESC);

-- 这个索引支持以下查询模式：
-- PARTITION BY department ORDER BY salary DESC
-- 避免了排序操作，直接按索引顺序读取

-- 查看执行计划验证索引效果
EXPLAIN SELECT 
    name, department, salary,
    ROW_NUMBER() OVER (
        PARTITION BY department 
        ORDER BY salary DESC
    ) as rank_num
FROM employees;
```

**索引设计原则**：
```
索引字段顺序：分区字段 + 排序字段
├─ 第一字段：PARTITION BY中的字段
├─ 第二字段：ORDER BY中的字段
└─ 排序方向：与ORDER BY方向一致

示例：
PARTITION BY dept, level ORDER BY salary DESC, hire_date ASC
推荐索引：(dept, level, salary DESC, hire_date ASC)
```

### 8.2 查询优化技巧


**技巧1：避免不必要的排序**
```sql
-- ❌ 低效：对已排序数据再次排序
SELECT 
    name, salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as rank_num
FROM employees
ORDER BY salary DESC;  -- 重复排序

-- ✅ 高效：利用窗口函数的排序结果
SELECT 
    name, salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as rank_num
FROM employees
ORDER BY rank_num;  -- 按排名排序，避免重复排序
```

**技巧2：合理使用LIMIT**
```sql
-- 只需要前N名时，使用子查询+LIMIT
SELECT * FROM (
    SELECT 
        name, department, salary,
        ROW_NUMBER() OVER (
            PARTITION BY department 
            ORDER BY salary DESC
        ) as dept_rank
    FROM employees
) ranked
WHERE dept_rank <= 3;  -- 每个部门前3名
```

**技巧3：选择合适的窗口函数**
```sql
-- 根据需求选择最合适的窗口函数
ROW_NUMBER()：严格排名，无重复，性能最好
RANK()：有并列排名，跳号，性能较好  
DENSE_RANK()：有并列排名，不跳号，性能一般
NTILE()：分组排名，计算相对复杂
```

### 8.3 内存和临时表优化


**监控内存使用**：
```sql
-- 查看排序内存使用情况
SHOW STATUS LIKE 'Sort%';

-- 关键指标：
-- Sort_merge_passes：外部排序次数（应该为0或很小）
-- Sort_range：范围排序次数  
-- Sort_rows：排序行数
-- Sort_scan：全表扫描排序次数
```

**优化内存配置**：
```sql
-- 调整排序缓冲区大小
SET SESSION sort_buffer_size = 16777216;  -- 16MB

-- 调整临时表大小限制
SET SESSION tmp_table_size = 134217728;   -- 128MB
SET SESSION max_heap_table_size = 134217728;  -- 128MB
```

### 8.4 并行处理优化


**适用并行处理的场景**：
```
并行窗口函数处理条件：
├─ 数据量大（>100万行）
├─ 分区数量适中（不要太多小分区）
├─ 系统资源充足（多核CPU，足够内存）
└─ 查询复杂度高（多个窗口函数）
```

**并行优化示例**：
```sql
-- 启用并行查询（MySQL 8.0+）
SET SESSION parallel_query = ON;

-- 对大表进行分区窗口函数计算
SELECT /*+ PARALLEL(4) */
    department, name, salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank,
    PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as percentile
FROM large_employee_table
WHERE hire_date >= '2020-01-01';
```

---

## 9. 🎯 实战应用案例


### 9.1 销售业绩分析案例


**业务需求**：分析各销售人员在不同产品类别中的业绩排名和占比。

```sql
-- 创建销售数据表
CREATE TABLE sales_records (
    id INT PRIMARY KEY,
    salesperson VARCHAR(50),
    product_category VARCHAR(50),
    sale_amount DECIMAL(10,2),
    sale_date DATE,
    region VARCHAR(50)
);

-- 复杂分区排序查询
SELECT 
    salesperson,
    product_category,
    region,
    sale_amount,
    sale_date,
    -- 各产品类别中的排名
    RANK() OVER (
        PARTITION BY product_category 
        ORDER BY sale_amount DESC
    ) as category_rank,
    -- 区域内各产品类别的排名
    RANK() OVER (
        PARTITION BY region, product_category
        ORDER BY sale_amount DESC  
    ) as region_category_rank,
    -- 产品类别内的销售占比
    sale_amount / SUM(sale_amount) OVER (
        PARTITION BY product_category
    ) * 100 as category_percentage,
    -- 移动平均（最近3次销售）
    AVG(sale_amount) OVER (
        PARTITION BY salesperson, product_category
        ORDER BY sale_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg_3
FROM sales_records
WHERE sale_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
ORDER BY product_category, category_rank;
```

### 9.2 学生成绩分析案例


**业务需求**：分析学生在各科目的成绩排名，以及年级整体表现。

```sql
-- 学生成绩分析
SELECT 
    student_name,
    class_name,
    subject,
    score,
    exam_date,
    -- 科目内排名
    ROW_NUMBER() OVER (
        PARTITION BY subject 
        ORDER BY score DESC
    ) as subject_rank,
    -- 班级科目内排名  
    ROW_NUMBER() OVER (
        PARTITION BY class_name, subject
        ORDER BY score DESC
    ) as class_subject_rank,
    -- 个人历史最好成绩比较
    MAX(score) OVER (
        PARTITION BY student_name, subject
        ORDER BY exam_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
    ) as historical_best,
    -- 成绩百分位
    PERCENT_RANK() OVER (
        PARTITION BY subject
        ORDER BY score
    ) as score_percentile,
    -- 与班级平均分的差距
    score - AVG(score) OVER (
        PARTITION BY class_name, subject
    ) as diff_from_class_avg
FROM student_scores
WHERE exam_date >= DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH)
ORDER BY class_name, student_name, subject;
```

### 9.3 网站流量分析案例


**业务需求**：分析网站各页面的访问量趋势和用户行为模式。

```sql
-- 网站流量分析
WITH daily_stats AS (
    SELECT 
        page_url,
        DATE(visit_time) as visit_date,
        COUNT(*) as daily_visits,
        COUNT(DISTINCT user_id) as unique_visitors,
        AVG(session_duration) as avg_duration
    FROM website_logs
    WHERE visit_time >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)
    GROUP BY page_url, DATE(visit_time)
)
SELECT 
    page_url,
    visit_date,
    daily_visits,
    unique_visitors,
    avg_duration,
    -- 页面访问量排名（按日期）
    RANK() OVER (
        PARTITION BY visit_date
        ORDER BY daily_visits DESC
    ) as daily_page_rank,
    -- 7天移动平均访问量
    AVG(daily_visits) OVER (
        PARTITION BY page_url
        ORDER BY visit_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as visits_7day_ma,
    -- 访问量增长趋势
    daily_visits - LAG(daily_visits, 1) OVER (
        PARTITION BY page_url
        ORDER BY visit_date
    ) as visits_change,
    -- 累计访问量占比
    SUM(daily_visits) OVER (
        PARTITION BY page_url
        ORDER BY visit_date
    ) / SUM(daily_visits) OVER (PARTITION BY page_url) * 100 as cumulative_percentage
FROM daily_stats
ORDER BY visit_date DESC, daily_page_rank;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 分区概念：PARTITION BY将数据分组，每组内独立计算
🔸 排序机制：ORDER BY决定窗口函数的计算顺序
🔸 边界定义：ROWS/RANGE控制窗口的数据范围  
🔸 空值处理：空值排序位置会影响计算结果
🔸 多字段分区：组合字段创建更细粒度的分区
🔸 性能优化：合理的索引和配置是关键
```

### 10.2 关键理解要点


**🔹 分区的本质理解**
```
分区不是物理分割：
- 数据仍在同一个表中
- 分区只是逻辑概念，用于计算分组
- 每个分区内的窗口函数计算相互独立
```

**🔹 排序对结果的影响**
```
排序决定计算逻辑：
- ROW_NUMBER、RANK等严格依赖排序
- 累计函数（SUM、AVG）的计算顺序由排序决定  
- 相同数据不同排序可能产生完全不同的结果
```

**🔹 性能优化的核心思路**
```
优化重点：
- 减少排序操作：通过索引避免排序
- 控制数据量：合理使用WHERE条件和LIMIT
- 避免数据倾斜：均匀的数据分布是关键
- 选择合适的窗口函数：根据需求选择最高效的函数
```

### 10.3 实际应用指导


**🎯 分区设计原则**：
- **业务相关性**：分区字段应与业务逻辑直接相关
- **数据平衡性**：避免某个分区数据过多或过少  
- **查询友好性**：分区字段最好有索引支持
- **扩展兼容性**：考虑未来数据增长对分区的影响

**🔧 性能调优步骤**：
```
性能调优流程：
1. 分析查询计划：使用EXPLAIN查看执行计划
2. 识别瓶颈点：找出排序、临时表等耗时操作
3. 优化索引策略：创建支持分区排序的复合索引
4. 调整系统参数：优化内存配置和并行度
5. 验证优化效果：对比优化前后的性能指标
```

**💡 常见问题避免**：
- **避免过多分区**：分区太多会导致每个分区数据太少
- **避免复杂表达式分区**：影响性能且难以使用索引
- **注意空值处理**：明确空值的排序位置
- **合理使用边界**：不必要的窗口边界会增加计算复杂度

### 10.4 学习进阶建议


**🔸 实践练习方向**：
- **多场景练习**：尝试不同业务场景的分区排序需求
- **性能测试**：在大数据集上测试不同分区策略的性能差异
- **索引实验**：验证不同索引策略对窗口函数性能的影响

**🔸 深入学习内容**：
- **执行计划分析**：深入理解窗口函数的执行过程
- **内存管理机制**：了解窗口函数的内存使用模式
- **并行处理原理**：学习窗口函数的并行化处理方式

**核心记忆口诀**：
```
窗口分区要合理，业务逻辑是第一
排序规则定计算，空值处理别忽视
索引优化是关键，数据倾斜要避免
边界定义看需求，性能调优步步来
```