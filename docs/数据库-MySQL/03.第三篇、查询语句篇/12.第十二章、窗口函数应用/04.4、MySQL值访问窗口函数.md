---
title: 4、MySQL值访问窗口函数
---
## 📚 目录

1. [值访问窗口函数概述](#1-值访问窗口函数概述)
2. [LAG向前取值函数](#2-lag向前取值函数)
3. [LEAD向后取值函数](#3-lead向后取值函数)
4. [FIRST_VALUE窗口首值函数](#4-first_value窗口首值函数)
5. [LAST_VALUE窗口尾值函数](#5-last_value窗口尾值函数)
6. [NTH_VALUE指定位置取值](#6-nth_value指定位置取值)
7. [默认值处理技巧](#7-默认值处理技巧)
8. [偏移量动态计算](#8-偏移量动态计算)
9. [值访问函数应用技巧](#9-值访问函数应用技巧)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 值访问窗口函数概述


### 1.1 什么是值访问窗口函数


**🔸 基本概念**
```
值访问窗口函数 = 在窗口框架内访问其他行数据的函数

核心作用：
├── 获取当前行之前的数据 (LAG)
├── 获取当前行之后的数据 (LEAD)  
├── 获取窗口第一行数据 (FIRST_VALUE)
├── 获取窗口最后一行数据 (LAST_VALUE)
└── 获取窗口指定位置数据 (NTH_VALUE)
```

**💡 与聚合函数的区别**
```
聚合窗口函数：SUM(), COUNT(), AVG()
├── 返回：计算结果(数值)
└── 用途：统计分析

值访问窗口函数：LAG(), LEAD(), FIRST_VALUE()
├── 返回：具体的行数据值
└── 用途：行间比较、数据关联
```

### 1.2 应用场景概览


**🎯 典型应用场景**
```
📈 时间序列分析：
   └── 计算同比、环比增长率

💰 销售数据分析：
   └── 对比前一天/月的销售额

👥 用户行为分析：
   └── 分析用户连续操作间隔

📊 排名变化追踪：
   └── 对比排名的变化情况

🔄 状态变化监控：
   └── 识别状态切换点
```

### 1.3 值访问函数家族


| **函数名** | **作用** | **方向** | **常用场景** |
|-----------|---------|---------|-------------|
| **LAG** | `获取前面行的值` | ⬆️ 向前 | 环比增长、前值比较 |
| **LEAD** | `获取后面行的值` | ⬇️ 向后 | 预测分析、后值比较 |
| **FIRST_VALUE** | `获取窗口首行值` | 🔝 首位 | 基准值比较 |
| **LAST_VALUE** | `获取窗口尾行值` | 🔚 末位 | 最新值获取 |
| **NTH_VALUE** | `获取指定位置值` | 🎯 定位 | 特定排名值获取 |

---

## 2. ⬆️ LAG向前取值函数


### 2.1 LAG函数基本语法


**🔸 完整语法结构**
```sql
LAG(column_expression [, offset [, default_value]]) 
OVER (
    [PARTITION BY partition_columns] 
    ORDER BY sort_columns
)

参数说明：
├── column_expression：要获取的列表达式
├── offset：向前偏移的行数(默认为1)
├── default_value：没有数据时的默认值
└── OVER子句：窗口定义
```

### 2.2 基础使用示例


**📊 准备测试数据**
```sql
-- 创建销售数据表
CREATE TABLE daily_sales (
    sale_date DATE,
    sales_amount DECIMAL(10,2),
    product_id INT
);

-- 插入测试数据
INSERT INTO daily_sales VALUES
('2024-01-01', 1000.00, 1),
('2024-01-02', 1200.00, 1),
('2024-01-03', 800.00, 1),
('2024-01-04', 1500.00, 1),
('2024-01-05', 1800.00, 1);
```

**🔸 基础LAG使用**
```sql
-- 获取前一天的销售额
SELECT 
    sale_date,
    sales_amount AS today_sales,
    LAG(sales_amount) OVER (ORDER BY sale_date) AS yesterday_sales
FROM daily_sales
ORDER BY sale_date;

结果：
sale_date  | today_sales | yesterday_sales
-----------|-------------|---------------
2024-01-01 |     1000.00 |          NULL
2024-01-02 |     1200.00 |       1000.00
2024-01-03 |      800.00 |       1200.00
2024-01-04 |     1500.00 |        800.00
2024-01-05 |     1800.00 |       1500.00
```

### 2.3 LAG进阶应用


**🔸 计算日环比增长率**
```sql
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount) OVER (ORDER BY sale_date) AS prev_sales,
    ROUND(
        (sales_amount - LAG(sales_amount) OVER (ORDER BY sale_date)) 
        / LAG(sales_amount) OVER (ORDER BY sale_date) * 100, 
        2
    ) AS growth_rate_pct
FROM daily_sales
ORDER BY sale_date;

-- 结果展示增长率变化
```

**🔸 指定偏移量**
```sql
-- 获取3天前的销售额
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount, 3) OVER (ORDER BY sale_date) AS sales_3days_ago
FROM daily_sales
ORDER BY sale_date;

-- 前3行的sales_3days_ago都是NULL
```

**🔸 设置默认值**
```sql
-- 为NULL值设置默认值0
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount, 1, 0) OVER (ORDER BY sale_date) AS prev_sales
FROM daily_sales
ORDER BY sale_date;

-- 第一行的prev_sales显示为0而不是NULL
```

### 2.4 多字段LAG应用


**🔸 获取多个字段的前值**
```sql
SELECT 
    sale_date,
    sales_amount,
    product_id,
    -- 获取前一天的销售额和产品ID
    LAG(sales_amount) OVER (ORDER BY sale_date) AS prev_amount,
    LAG(product_id) OVER (ORDER BY sale_date) AS prev_product,
    LAG(sale_date) OVER (ORDER BY sale_date) AS prev_date
FROM daily_sales
ORDER BY sale_date;
```

---

## 3. ⬇️ LEAD向后取值函数


### 3.1 LEAD函数基本语法


**🔸 语法结构**
```sql
LEAD(column_expression [, offset [, default_value]]) 
OVER (
    [PARTITION BY partition_columns] 
    ORDER BY sort_columns
)

LAG vs LEAD方向对比：
当前行数据：     [行1] [行2] [行3] [行4] [行5]
LAG(col,1)：      NULL  行1   行2   行3   行4
LEAD(col,1)：     行2   行3   行4   行5   NULL
```

### 3.2 LEAD基础使用


**🔸 获取下一天销售额**
```sql
SELECT 
    sale_date,
    sales_amount AS today_sales,
    LEAD(sales_amount) OVER (ORDER BY sale_date) AS tomorrow_sales
FROM daily_sales
ORDER BY sale_date;

结果：
sale_date  | today_sales | tomorrow_sales
-----------|-------------|---------------
2024-01-01 |     1000.00 |       1200.00
2024-01-02 |     1200.00 |        800.00
2024-01-03 |      800.00 |       1500.00
2024-01-04 |     1500.00 |       1800.00
2024-01-05 |     1800.00 |          NULL
```

### 3.3 LEAD实际应用场景


**🔸 计算未来趋势分析**
```sql
-- 分析销售趋势：当前、未来1天、未来3天
SELECT 
    sale_date,
    sales_amount AS current_sales,
    LEAD(sales_amount, 1) OVER (ORDER BY sale_date) AS next_day_sales,
    LEAD(sales_amount, 3) OVER (ORDER BY sale_date) AS sales_3days_later,
    -- 计算未来增长预期
    CASE 
        WHEN LEAD(sales_amount) OVER (ORDER BY sale_date) > sales_amount 
        THEN '预期上涨'
        WHEN LEAD(sales_amount) OVER (ORDER BY sale_date) < sales_amount 
        THEN '预期下跌'
        ELSE '预期持平'
    END AS trend_forecast
FROM daily_sales
ORDER BY sale_date;
```

**🔸 识别峰值和谷值**
```sql
-- 识别销售额的峰值点
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount) OVER (ORDER BY sale_date) AS prev_sales,
    LEAD(sales_amount) OVER (ORDER BY sale_date) AS next_sales,
    CASE 
        WHEN sales_amount > COALESCE(LAG(sales_amount) OVER (ORDER BY sale_date), 0)
         AND sales_amount > COALESCE(LEAD(sales_amount) OVER (ORDER BY sale_date), 0)
        THEN '峰值'
        WHEN sales_amount < COALESCE(LAG(sales_amount) OVER (ORDER BY sale_date), 999999)
         AND sales_amount < COALESCE(LEAD(sales_amount) OVER (ORDER BY sale_date), 999999)
        THEN '谷值'
        ELSE '普通'
    END AS sales_point_type
FROM daily_sales
ORDER BY sale_date;
```

---

## 4. 🔝 FIRST_VALUE窗口首值函数


### 4.1 FIRST_VALUE基本概念


**🔸 函数作用**
```
FIRST_VALUE = 获取窗口框架中第一行的指定列值

窗口框架示例：
┌─────────────┬─────────────┬─────────────┐
│    第1行    │    第2行    │    第3行    │ ← 当前窗口框架
│  (首值)     │            │            │
└─────────────┴─────────────┴─────────────┘
     ↑
FIRST_VALUE总是返回这个值
```

### 4.2 语法和基础使用


**🔸 完整语法**
```sql
FIRST_VALUE(column_expression) 
OVER (
    [PARTITION BY partition_columns] 
    ORDER BY sort_columns
    [ROWS/RANGE window_frame]
)
```

**🔸 基础示例**
```sql
-- 获取每组中的第一个销售额
SELECT 
    sale_date,
    sales_amount,
    FIRST_VALUE(sales_amount) OVER (ORDER BY sale_date) AS first_sale_amount
FROM daily_sales
ORDER BY sale_date;

结果：每行的first_sale_amount都是1000.00(第一行的值)
```

### 4.3 FIRST_VALUE实际应用


**🔸 计算与基准值的差异**
```sql
-- 计算每日销售额与首日销售额的差异
SELECT 
    sale_date,
    sales_amount,
    FIRST_VALUE(sales_amount) OVER (ORDER BY sale_date) AS baseline_sales,
    sales_amount - FIRST_VALUE(sales_amount) OVER (ORDER BY sale_date) AS diff_from_baseline,
    ROUND(
        (sales_amount - FIRST_VALUE(sales_amount) OVER (ORDER BY sale_date)) 
        / FIRST_VALUE(sales_amount) OVER (ORDER BY sale_date) * 100, 
        2
    ) AS pct_change_from_baseline
FROM daily_sales
ORDER BY sale_date;
```

**🔸 分组中的FIRST_VALUE**
```sql
-- 准备分组数据
CREATE TABLE product_sales (
    product_id INT,
    sale_date DATE,
    sales_amount DECIMAL(10,2)
);

INSERT INTO product_sales VALUES
(1, '2024-01-01', 1000.00),
(1, '2024-01-02', 1200.00),
(1, '2024-01-03', 800.00),
(2, '2024-01-01', 500.00),
(2, '2024-01-02', 600.00),
(2, '2024-01-03', 700.00);

-- 每个产品组内的首次销售额
SELECT 
    product_id,
    sale_date,
    sales_amount,
    FIRST_VALUE(sales_amount) OVER (
        PARTITION BY product_id 
        ORDER BY sale_date
    ) AS first_sale_by_product
FROM product_sales
ORDER BY product_id, sale_date;
```

---

## 5. 🔚 LAST_VALUE窗口尾值函数


### 5.1 LAST_VALUE的特殊性


**🔸 重要注意事项**
```
⚠️ LAST_VALUE的常见陷阱

默认窗口框架：RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                └── 只包含到当前行，不包含后续行

想要真正的"最后一行值"需要：
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

### 5.2 正确使用LAST_VALUE


**🔸 错误用法示例**
```sql
-- ❌ 错误：得不到真正的最后值
SELECT 
    sale_date,
    sales_amount,
    LAST_VALUE(sales_amount) OVER (ORDER BY sale_date) AS wrong_last_value
FROM daily_sales
ORDER BY sale_date;

-- 结果：wrong_last_value总是等于当前行的sales_amount
```

**🔸 正确用法示例**
```sql
-- ✅ 正确：指定完整窗口框架
SELECT 
    sale_date,
    sales_amount,
    LAST_VALUE(sales_amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS correct_last_value
FROM daily_sales
ORDER BY sale_date;

-- 结果：correct_last_value总是1800.00(最后一行的值)
```

### 5.3 LAST_VALUE实际应用


**🔸 计算与最终值的差异**
```sql
-- 计算每日销售额与最终销售额的差异
SELECT 
    sale_date,
    sales_amount,
    LAST_VALUE(sales_amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS final_sales,
    sales_amount - LAST_VALUE(sales_amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS diff_from_final
FROM daily_sales
ORDER BY sale_date;
```

**🔸 分组中的LAST_VALUE**
```sql
-- 每个产品组内的最后销售额
SELECT 
    product_id,
    sale_date,
    sales_amount,
    LAST_VALUE(sales_amount) OVER (
        PARTITION BY product_id 
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_sale_by_product
FROM product_sales
ORDER BY product_id, sale_date;
```

---

## 6. 🎯 NTH_VALUE指定位置取值


### 6.1 NTH_VALUE基本概念


**🔸 函数作用**
```
NTH_VALUE = 获取窗口中第N行的指定列值

位置编号从1开始：
┌─────┬─────┬─────┬─────┬─────┐
│  1  │  2  │  3  │  4  │  5  │ ← 行号
└─────┴─────┴─────┴─────┴─────┘

NTH_VALUE(col, 3) 获取第3行的值
```

### 6.2 基础语法和使用


**🔸 完整语法**
```sql
NTH_VALUE(column_expression, n) 
OVER (
    [PARTITION BY partition_columns] 
    ORDER BY sort_columns
    [ROWS/RANGE window_frame]
)

参数说明：
├── column_expression：要获取的列
├── n：位置编号(从1开始)
└── 需要明确指定窗口框架
```

**🔸 基础使用示例**
```sql
-- 获取第2位和第3位的销售额
SELECT 
    sale_date,
    sales_amount,
    NTH_VALUE(sales_amount, 2) OVER (
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS second_sales,
    NTH_VALUE(sales_amount, 3) OVER (
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS third_sales
FROM daily_sales
ORDER BY sale_date;
```

### 6.3 NTH_VALUE实际应用


**🔸 获取排名特定位置的值**
```sql
-- 获取销售排名第2和第3的销售额
SELECT 
    sale_date,
    sales_amount,
    -- 按销售额降序排列后取第2名和第3名
    NTH_VALUE(sales_amount, 2) OVER (
        ORDER BY sales_amount DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS second_highest_sales,
    NTH_VALUE(sales_amount, 3) OVER (
        ORDER BY sales_amount DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS third_highest_sales
FROM daily_sales
ORDER BY sale_date;
```

**🔸 动态获取中位数**
```sql
-- 获取中位数位置的值
SELECT 
    sale_date,
    sales_amount,
    NTH_VALUE(sales_amount, 
        CEILING(COUNT(*) OVER () / 2.0)
    ) OVER (
        ORDER BY sales_amount
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS median_sales
FROM daily_sales
ORDER BY sale_date;
```

---

## 7. 🛠️ 默认值处理技巧


### 7.1 默认值的重要性


**🔸 为什么需要默认值**
```
问题场景：
├── LAG/LEAD在边界行返回NULL
├── 业务逻辑需要有意义的默认值
├── 后续计算需要避免NULL值
└── 报表展示需要友好的显示
```

### 7.2 各函数的默认值处理


**🔸 LAG/LEAD默认值**
```sql
-- 设置有意义的默认值
SELECT 
    sale_date,
    sales_amount,
    -- 前一天销售额，没有则为0
    LAG(sales_amount, 1, 0) OVER (ORDER BY sale_date) AS prev_sales,
    -- 后一天销售额，没有则用当前值
    LEAD(sales_amount, 1, sales_amount) OVER (ORDER BY sale_date) AS next_sales,
    -- 计算增长率时处理除零问题
    CASE 
        WHEN LAG(sales_amount, 1, sales_amount) OVER (ORDER BY sale_date) = 0 
        THEN NULL
        ELSE ROUND(
            (sales_amount - LAG(sales_amount, 1, sales_amount) OVER (ORDER BY sale_date)) 
            / LAG(sales_amount, 1, sales_amount) OVER (ORDER BY sale_date) * 100, 
            2
        )
    END AS growth_rate
FROM daily_sales
ORDER BY sale_date;
```

### 7.3 复杂默认值逻辑


**🔸 条件性默认值**
```sql
-- 根据业务逻辑设置不同的默认值
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount, 1, 
        CASE 
            WHEN DAYOFWEEK(sale_date) = 2 THEN 0  -- 周一默认为0
            ELSE 1000  -- 其他情况默认为1000
        END
    ) OVER (ORDER BY sale_date) AS prev_sales_with_logic
FROM daily_sales
ORDER BY sale_date;
```

**🔸 使用COALESCE处理NULL**
```sql
-- 多层默认值处理
SELECT 
    sale_date,
    sales_amount,
    COALESCE(
        LAG(sales_amount) OVER (ORDER BY sale_date),  -- 优先使用前一天
        AVG(sales_amount) OVER (),                    -- 其次使用平均值
        0                                              -- 最后使用0
    ) AS smart_prev_sales
FROM daily_sales
ORDER BY sale_date;
```

---

## 8. 📊 偏移量动态计算


### 8.1 动态偏移量概念


**🔸 什么是动态偏移量**
```
静态偏移量：LAG(col, 2)  -- 固定向前2行
动态偏移量：LAG(col, variable)  -- 偏移量由变量确定

应用场景：
├── 根据业务规则调整偏移量
├── 基于数据特征计算偏移量
├── 实现复杂的时间窗口分析
└── 自适应的数据比较逻辑
```

### 8.2 动态偏移量实现方法


**🔸 基于条件的动态偏移**
```sql
-- 根据星期几调整偏移量
SELECT 
    sale_date,
    sales_amount,
    DAYOFWEEK(sale_date) AS day_of_week,
    -- 工作日比较前一天，周末比较前两天
    LAG(sales_amount, 
        CASE 
            WHEN DAYOFWEEK(sale_date) IN (1, 7) THEN 2  -- 周末
            ELSE 1  -- 工作日
        END
    ) OVER (ORDER BY sale_date) AS dynamic_prev_sales
FROM daily_sales
ORDER BY sale_date;
```

### 8.3 复杂动态偏移场景


**🔸 基于数据分布的动态偏移**
```sql
-- 根据销售额大小调整比较范围
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount, 
        CASE 
            WHEN sales_amount > 1500 THEN 3  -- 高销售额比较3天前
            WHEN sales_amount > 1000 THEN 2  -- 中等销售额比较2天前  
            ELSE 1                           -- 低销售额比较1天前
        END
    ) OVER (ORDER BY sale_date) AS adaptive_prev_sales
FROM daily_sales
ORDER BY sale_date;
```

**🔸 滑动窗口动态偏移**
```sql
-- 实现动态长度的移动平均
SELECT 
    sale_date,
    sales_amount,
    -- 根据ROW_NUMBER动态调整窗口大小
    AVG(sales_amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 
            CASE 
                WHEN ROW_NUMBER() OVER (ORDER BY sale_date) <= 3 
                THEN UNBOUNDED PRECEDING
                ELSE 2 PRECEDING  
            END 
        AND CURRENT ROW
    ) AS dynamic_moving_avg
FROM daily_sales
ORDER BY sale_date;
```

---

## 9. 🎯 值访问函数应用技巧


### 9.1 行间比较计算方法


**🔸 多维度比较分析**
```sql
-- 综合行间比较分析
SELECT 
    sale_date,
    sales_amount,
    -- 环比分析
    LAG(sales_amount) OVER (ORDER BY sale_date) AS prev_day,
    sales_amount - LAG(sales_amount) OVER (ORDER BY sale_date) AS day_change,
    -- 周期比较  
    LAG(sales_amount, 7, 0) OVER (ORDER BY sale_date) AS same_day_last_week,
    sales_amount - LAG(sales_amount, 7, 0) OVER (ORDER BY sale_date) AS week_change,
    -- 趋势预测
    LEAD(sales_amount) OVER (ORDER BY sale_date) AS next_day_forecast,
    -- 基准比较
    FIRST_VALUE(sales_amount) OVER (ORDER BY sale_date) AS baseline,
    sales_amount - FIRST_VALUE(sales_amount) OVER (ORDER BY sale_date) AS total_change
FROM daily_sales
ORDER BY sale_date;
```

### 9.2 复杂业务场景应用


**🔸 客户生命周期分析**
```sql
-- 模拟客户行为数据
CREATE TABLE customer_actions (
    customer_id INT,
    action_date DATE,
    action_type VARCHAR(20),
    action_value DECIMAL(10,2)
);

-- 分析客户行为模式
SELECT 
    customer_id,
    action_date,
    action_type,
    action_value,
    -- 上次行为时间间隔
    DATEDIFF(action_date, 
        LAG(action_date) OVER (
            PARTITION BY customer_id 
            ORDER BY action_date
        )
    ) AS days_since_last_action,
    -- 上次行为类型
    LAG(action_type) OVER (
        PARTITION BY customer_id 
        ORDER BY action_date
    ) AS prev_action_type,
    -- 行为价值变化
    action_value - LAG(action_value, 1, 0) OVER (
        PARTITION BY customer_id 
        ORDER BY action_date
    ) AS value_change,
    -- 客户首次行为基准
    FIRST_VALUE(action_value) OVER (
        PARTITION BY customer_id 
        ORDER BY action_date
    ) AS first_action_value
FROM customer_actions
ORDER BY customer_id, action_date;
```

### 9.3 性能优化技巧


**🔸 减少重复计算**
```sql
-- ❌ 效率低：重复计算相同的窗口函数
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount) OVER (ORDER BY sale_date) AS prev_sales,
    sales_amount - LAG(sales_amount) OVER (ORDER BY sale_date) AS change1,
    (sales_amount - LAG(sales_amount) OVER (ORDER BY sale_date)) / 
     LAG(sales_amount) OVER (ORDER BY sale_date) * 100 AS change_pct
FROM daily_sales;

-- ✅ 效率高：使用子查询缓存结果
SELECT 
    sale_date,
    sales_amount,
    prev_sales,
    sales_amount - prev_sales AS change1,
    ROUND((sales_amount - prev_sales) / prev_sales * 100, 2) AS change_pct
FROM (
    SELECT 
        sale_date,
        sales_amount,
        LAG(sales_amount) OVER (ORDER BY sale_date) AS prev_sales
    FROM daily_sales
) t
ORDER BY sale_date;
```

### 9.4 错误处理和边界情况


**🔸 健壮的错误处理**
```sql
-- 处理各种边界情况
SELECT 
    sale_date,
    sales_amount,
    LAG(sales_amount) OVER (ORDER BY sale_date) AS prev_sales,
    -- 安全的除法计算
    CASE 
        WHEN LAG(sales_amount) OVER (ORDER BY sale_date) IS NULL 
        THEN 'N/A'
        WHEN LAG(sales_amount) OVER (ORDER BY sale_date) = 0 
        THEN 'DIV/0'
        ELSE CONCAT(
            ROUND((sales_amount - LAG(sales_amount) OVER (ORDER BY sale_date)) / 
                  LAG(sales_amount) OVER (ORDER BY sale_date) * 100, 2), 
            '%'
        )
    END AS growth_rate_safe,
    -- 处理异常值
    CASE 
        WHEN ABS(sales_amount - COALESCE(LAG(sales_amount) OVER (ORDER BY sale_date), sales_amount)) 
             > sales_amount * 0.5 
        THEN '异常变化'
        ELSE '正常变化'
    END AS change_status
FROM daily_sales
ORDER BY sale_date;
```

---

## 10. 📋 核心要点总结


### 10.1 值访问函数速查表


| **函数** | **获取位置** | **语法要点** | **注意事项** |
|---------|-------------|-------------|-------------|
| **LAG** | `当前行向前n行` | `LAG(col, n, default)` | 第一行返回NULL或默认值 |
| **LEAD** | `当前行向后n行` | `LEAD(col, n, default)` | 最后一行返回NULL或默认值 |
| **FIRST_VALUE** | `窗口第一行` | `需要ORDER BY` | 受窗口框架影响 |
| **LAST_VALUE** | `窗口最后一行` | `需要完整窗口框架` | **必须指定UNBOUNDED FOLLOWING** |
| **NTH_VALUE** | `窗口第n行` | `NTH_VALUE(col, n)` | n从1开始，需要完整窗口框架 |

### 10.2 应用场景决策树


```
需要访问其他行的数据
        ↓
   是否需要特定位置？
    ↙            ↘
   是              否
   ↓              ↓
指定位置是？    相对当前行位置？
   ↓              ↙        ↘
第一行 → FIRST_VALUE    前面      后面
最后行 → LAST_VALUE      ↓        ↓
第n行 → NTH_VALUE      LAG     LEAD
```

### 10.3 常见错误和解决方案


**🔸 LAST_VALUE常见错误**
```sql
-- ❌ 错误：没有指定完整窗口框架
LAST_VALUE(col) OVER (ORDER BY date)

-- ✅ 正确：指定完整窗口框架
LAST_VALUE(col) OVER (
    ORDER BY date 
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
```

**🔸 默认值处理错误**
```sql
-- ❌ 错误：没有处理NULL值
LAG(amount) OVER (ORDER BY date) / LAG(amount) OVER (ORDER BY date) 

-- ✅ 正确：设置默认值或用COALESCE
COALESCE(LAG(amount, 1, amount) OVER (ORDER BY date), amount)
```

### 10.4 性能优化要点


**✅ 性能最佳实践**
```
1. 避免重复计算相同窗口函数
2. 合理使用PARTITION BY减少计算范围
3. 在子查询中缓存复杂的窗口函数结果
4. 为ORDER BY列创建合适的索引
5. 避免在窗口函数中使用复杂表达式
```

### 10.5 实用记忆技巧


**🧠 记忆口诀**
```
LAG往前看，LEAD往后瞧
FIRST开头值，LAST结尾找
NTH指定位，默认值要好
窗口框架清，性能优化巧
```

**🔑 关键要记住**
- **LAG/LEAD**：处理时间序列分析的首选
- **FIRST_VALUE**：基准值比较的利器  
- **LAST_VALUE**：记住要用完整窗口框架
- **NTH_VALUE**：获取排名特定位置的值
- **默认值**：边界情况的优雅处理
- **动态偏移**：高级分析的核心技巧

---

> 💡 **学习建议**
> 
> 值访问窗口函数是SQL分析的高级技能，建议从简单的LAG/LEAD开始练习，逐步掌握更复杂的应用场景。重点理解窗口框架的概念，这是正确使用LAST_VALUE和NTH_VALUE的关键。在实际项目中，这些函数常用于时间序列分析、趋势预测和行间比较计算。