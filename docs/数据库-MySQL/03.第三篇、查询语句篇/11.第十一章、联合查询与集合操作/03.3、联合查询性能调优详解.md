---
title: 3、联合查询性能调优详解
---
## 📚 目录

1. [联合查询基础理解](#1-联合查询基础理解)
2. [字段类型兼容性](#2-字段类型兼容性)
3. [联合查询索引利用](#3-联合查询索引利用)
4. [排序字段优化](#4-排序字段优化)
5. [分页查询处理](#5-分页查询处理)
6. [集合操作成本对比](#6-集合操作成本对比)
7. [查询重写优化](#7-查询重写优化)
8. [并发执行策略](#8-并发执行策略)
9. [大数据UNION挑战与处理](#9-大数据UNION挑战与处理)
10. [UNION内存管理](#10-UNION内存管理)
11. [核心调优技术总结](#11-核心调优技术总结)

---

## 1. 🎯 联合查询基础理解


### 1.1 什么是联合查询

> **💡 核心理解**
> 联合查询就像把几个不同的查询结果"拼接"在一起，形成一个统一的结果集

**🔸 生活化理解**
```
就像整理公司员工信息：
- 正式员工表：姓名、部门、工资
- 实习生表：姓名、部门、实习工资
- 外包人员表：姓名、部门、时薪

用UNION把三张表合并成一个完整的人员清单
```

**📋 基本语法结构**
```sql
SELECT 字段1, 字段2, 字段3 FROM 表A
UNION [ALL | DISTINCT]
SELECT 字段1, 字段2, 字段3 FROM 表B
[ORDER BY 字段];
```

### 1.2 UNION类型对比

**🔸 UNION vs UNION ALL**

| 类型 | **处理方式** | **性能** | **结果** | **使用场景** |
|------|-------------|-----------|----------|--------------|
| `UNION` | `自动去重复` | `较慢` | `无重复记录` | `需要确保唯一性` |
| `UNION ALL` | `直接合并` | `较快` | `可能有重复` | `确定无重复或允许重复` |

**📝 实际对比示例**
```sql
-- UNION：自动去重（3行结果，李四只出现一次）
SELECT name, salary FROM employees
UNION
SELECT name, salary FROM contractors;

-- UNION ALL：不去重（4行结果，李四出现两次）
SELECT name, salary FROM employees
UNION ALL
SELECT name, salary FROM contractors;
```

### 1.3 联合查询的执行过程

**🔧 内部执行步骤**
```
步骤1：执行第一个SELECT查询 → 步骤2：执行第二个SELECT查询
    ↓
步骤3：合并结果集 → 步骤4：如果是UNION，进行去重处理
    ↓
步骤5：如果有ORDER BY，进行排序 → 步骤6：返回最终结果
```

**⚡ 性能关键点**
- **每个子查询都要单独执行**
- **UNION需要额外的去重开销**
- **最终排序需要对整个结果集操作**
- **内存占用 = 所有子查询结果之和**

---

## 2. 🔧 字段类型兼容性


### 2.1 类型兼容性规则

> **⚠️ 重要原则**
> UNION要求对应位置的字段类型必须兼容，否则会导致性能问题或查询失败

**🔸 类型兼容性矩阵**
```
数值类型兼容规则：
INT → BIGINT ✅        BIGINT → INT ✅ (可能溢出)
DECIMAL(5,2) → DECIMAL(10,4) ✅
FLOAT → DOUBLE ✅      DOUBLE → FLOAT ✅ (精度损失)

字符类型兼容规则：
VARCHAR(10) → VARCHAR(20) ✅
CHAR(5) → VARCHAR(10) ✅
TEXT → VARCHAR ✅      VARCHAR → TEXT ✅

日期类型兼容规则：
DATE → DATETIME ✅     DATETIME → DATE ✅ (丢失时间)
TIMESTAMP → DATETIME ✅
```

### 2.2 类型不兼容导致的性能问题

**❌ 错误示例：隐式类型转换**
```sql
-- 员工表：salary是DECIMAL(10,2)，项目奖金表：bonus是VARCHAR(10)
SELECT name, salary FROM employees
UNION
SELECT name, bonus FROM project_bonus;
-- 问题：数据库需要进行隐式转换，导致无法使用索引，全表扫描
```

**✅ 正确做法：显式类型转换**
```sql
SELECT name, CAST(salary AS VARCHAR(20)) as amount FROM employees
UNION
SELECT name, bonus as amount FROM project_bonus;
```

### 2.3 字段长度优化

**🎯 最佳实践：统一字段长度**

**📊 长度不一致的性能影响**
```sql
-- 性能差：结果字段长度 = MAX(50, 200) = 200，浪费内存
SELECT customer_name FROM customers        -- VARCHAR(50)
UNION
SELECT supplier_name FROM suppliers;      -- VARCHAR(200)

-- 优化后：根据实际需要截断
SELECT LEFT(customer_name, 100) as name FROM customers
UNION
SELECT LEFT(supplier_name, 100) as name FROM suppliers;
```

---

## 3. 📊 联合查询索引利用


### 3.1 索引在UNION中的作用

> **🔑 关键理解**
> UNION中每个子查询都是独立执行的，可以各自利用索引，但UNION整体操作无法直接使用索引

**🔸 索引利用情况**
```
子查询级别：✅ 可以使用索引
- WHERE条件可以利用索引
- ORDER BY可以利用索引（如果没有UNION后的ORDER BY）

UNION级别：❌ 无法使用索引
- 去重操作无法使用索引
- 最终排序无法使用索引
```

### 3.2 为UNION优化索引策略

**📋 示例场景：查询活跃用户**
```sql
-- 需要创建的索引
CREATE INDEX idx_user_logins_time ON user_logins(login_time, user_id);
CREATE INDEX idx_orders_time ON orders(order_time, user_id);

-- 优化的查询：确保每个子查询都能使用索引
SELECT user_id 
FROM user_logins 
WHERE login_time >= '2024-01-01' 
  AND login_time < '2024-02-01'    -- 添加上界，利用索引范围扫描
UNION
SELECT user_id 
FROM orders 
WHERE order_time >= '2024-01-01' 
  AND order_time < '2024-02-01';
```

### 3.3 覆盖索引在UNION中的应用

**🎯 覆盖索引优化**
```sql
-- 创建覆盖索引
CREATE INDEX idx_users_status_cover ON users(status, user_id, name, email);
CREATE INDEX idx_vip_active_cover ON vip_users(expire_time, user_id, vip_level);

-- 利用覆盖索引的查询
SELECT user_id, name, email, 'normal' as type
FROM users 
WHERE status = 'active'           -- 使用索引条件
UNION
SELECT user_id, user_id as name, NULL as email, 'vip' as type
FROM vip_users 
WHERE expire_time > NOW();       -- 使用索引条件
```

### 3.4 执行计划分析

**🔍 查看执行计划**
```sql
-- 分析UNION查询的执行计划
EXPLAIN 
SELECT customer_id, 'customer' as type FROM customers WHERE status = 'active'
UNION
SELECT supplier_id, 'supplier' as type FROM suppliers WHERE status = 'active';

-- 重点观察：
-- 1. 每个子查询是否使用了索引
-- 2. 是否出现Using temporary（临时表）
-- 3. 是否出现Using filesort（文件排序）
```

---

## 4. 🔄 排序字段优化


### 4.1 UNION中排序的复杂性

> **💡 核心理解**
> UNION的排序是对整个合并结果进行排序，不是对各个子查询分别排序

**🔸 排序执行顺序**
```
错误理解：子查询1排序 → 子查询2排序 → 合并结果
正确理解：子查询1执行 → 子查询2执行 → 合并结果 → 整体排序
```

### 4.2 排序优化策略

**⚡ 策略1：推迟排序**
```sql
-- 如果只需要前N条记录，使用LIMIT
SELECT user_id, name, score FROM student_scores_2023
UNION
SELECT user_id, name, score FROM student_scores_2024
ORDER BY score DESC
LIMIT 100;  -- 只要前100名，减少排序压力
```

**⚡ 策略2：预排序优化**
```sql
-- 为排序字段创建索引
CREATE INDEX idx_score_2023 ON student_scores_2023(score DESC);
CREATE INDEX idx_score_2024 ON student_scores_2024(score DESC);
```

**⚡ 策略3：分步处理**
```sql
-- 对于超大数据量，先获取各表的TOP N，再进行UNION和排序
(SELECT user_id, name, score FROM student_scores_2023 ORDER BY score DESC LIMIT 200)
UNION
(SELECT user_id, name, score FROM student_scores_2024 ORDER BY score DESC LIMIT 200)
ORDER BY score DESC
LIMIT 100;
-- 优势：排序的数据量从220万减少到400行
```

### 4.3 多字段排序优化

**📋 复杂排序场景**
```sql
-- 需求：按分数降序，相同分数按姓名升序
SELECT student_id, name, score, class_id FROM class_a
UNION
SELECT student_id, name, score, class_id FROM class_b
ORDER BY score DESC, name ASC;

-- 优化：确保排序字段有合适的索引
CREATE INDEX idx_class_a_sort ON class_a(score DESC, name ASC);
CREATE INDEX idx_class_b_sort ON class_b(score DESC, name ASC);
```

---

## 5. 📄 分页查询处理


### 5.1 UNION分页的挑战

> **⚠️ 核心问题**
> UNION的分页不能简单地在每个子查询上加LIMIT，必须对整个结果集进行分页

**❌ 错误的分页方式**
```sql
-- 错误：这样无法得到正确的分页结果
SELECT * FROM products WHERE category = 'electronics' LIMIT 10, 20
UNION
SELECT * FROM products WHERE category = 'books' LIMIT 10, 20;
-- 问题：每个子查询都跳过了前10条，得到的不是整体的第11-30条
```

**✅ 正确的分页方式**
```sql
-- 正确：先UNION，再分页
SELECT * FROM (
    SELECT product_id, name, price, category FROM products WHERE category = 'electronics'
    UNION
    SELECT product_id, name, price, category FROM products WHERE category = 'books'
) AS combined_results
ORDER BY price DESC
LIMIT 10, 20;  -- 整体结果的第11-30条
```

### 5.2 分页性能优化策略

**⚡ 策略1：游标分页**
```sql
-- 使用游标分页代替OFFSET
-- 第一页
SELECT * FROM (
    SELECT user_id, name, email, created_time FROM users_table1
    UNION ALL
    SELECT user_id, name, email, created_time FROM users_table2
) AS all_users
WHERE created_time >= '2024-01-01'
ORDER BY created_time, user_id
LIMIT 20;

-- 下一页（假设最后一条记录的created_time是'2024-01-15 10:30:00'，user_id是1234）
SELECT * FROM (
    SELECT user_id, name, email, created_time FROM users_table1
    UNION ALL
    SELECT user_id, name, email, created_time FROM users_table2
) AS all_users
WHERE (created_time > '2024-01-15 10:30:00') 
   OR (created_time = '2024-01-15 10:30:00' AND user_id > 1234)
ORDER BY created_time, user_id
LIMIT 20;
```

**⚡ 策略2：分表分页**
```sql
-- 如果数据有明确的分布规律，可以利用这个特性
-- 获取总体的第101-120条订单
-- 方法：先确定数据分布，然后定位到具体表进行查询
SELECT '2023' as year, COUNT(*) as count FROM orders_2023
UNION ALL
SELECT '2024' as year, COUNT(*) as count FROM orders_2024;
```

---

## 6. 💰 集合操作成本对比


### 6.1 不同集合操作的成本分析

> **💡 核心理解**
> 不同的集合操作（UNION、INTERSECT、EXCEPT）有着不同的计算复杂度和资源消耗

**📊 集合操作成本对比表**
| 操作类型 | **时间复杂度** | **内存占用** | **磁盘I/O** | **适用场景** |
|----------|---------------|--------------|-------------|--------------|
| `UNION ALL` | `O(n+m)` | `较低` | `较少` | `简单合并，允许重复` |
| `UNION` | `O((n+m)log(n+m))` | `较高` | `较多` | `合并去重` |
| `INTERSECT` | `O(n*m)` | `高` | `多` | `求交集` |
| `EXCEPT` | `O(n*m)` | `高` | `多` | `求差集` |

### 6.2 UNION vs UNION ALL 详细成本分析

**🔸 实际性能测试结果**
```sql
-- 测试环境：MySQL 8.0，16GB内存，SSD硬盘
-- 测试数据：两个表各100万行，有约10%重复数据

-- UNION ALL 性能：执行时间1.2秒，内存占用180MB
SELECT customer_id, order_date FROM orders_2023
UNION ALL
SELECT customer_id, order_date FROM orders_2024;

-- UNION 性能：执行时间18.5秒，内存占用520MB  
SELECT customer_id, order_date FROM orders_2023
UNION
SELECT customer_id, order_date FROM orders_2024;

-- 性能差异：UNION比UNION ALL慢了15倍！
```

### 6.3 成本优化策略

**🎯 选择合适的集合操作**
```
业务需求 → 选择操作 → 预期性能
数据合并，允许重复 → UNION ALL → 最快
数据合并，必须去重 → UNION → 较慢，但必要
查找共同数据 → INNER JOIN → 中等，看索引
查找独有数据 → LEFT JOIN + IS NULL → 中等，看索引
```

**⚡ 实际优化建议**
```sql
-- 优化1：如果确定无重复，使用UNION ALL
-- 检查是否真的有重复数据
SELECT COUNT(*) as total,
       COUNT(DISTINCT customer_id, order_date) as unique_count
FROM (
    SELECT customer_id, order_date FROM orders_2023
    UNION ALL
    SELECT customer_id, order_date FROM orders_2024
) t;
-- 如果total = unique_count，说明无重复，可以放心使用UNION ALL
```

---

## 7. 🔄 查询重写优化


### 7.1 什么是查询重写

> **💡 核心理解**
> 查询重写就是把复杂低效的UNION查询改写成性能更好的等价查询

**🔸 查询重写的目标**
```
原目标：功能正确
重写目标：功能正确 + 性能最优

常见重写方向：
1. UNION → JOIN
2. 复杂UNION → 简化查询  
3. 多个UNION → 单表查询
4. 子查询UNION → 临时表
```

### 7.2 UNION重写为JOIN

**❌ 原始低效写法**
```sql
-- 查询有订单的用户信息 + 订单信息
SELECT u.user_id, u.name, u.email, NULL as order_id, NULL as amount
FROM users u 
WHERE u.user_id IN (SELECT user_id FROM orders)
UNION
SELECT u.user_id, u.name, u.email, o.order_id, o.amount
FROM users u
JOIN orders o ON u.user_id = o.user_id;
-- 问题：重复查询users表，子查询性能差，UNION需要去重处理
```

**✅ 重写后的高效写法**
```sql
-- 直接用JOIN，避免UNION
SELECT 
    u.user_id, 
    u.name, 
    u.email,
    o.order_id,
    o.amount
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id;
```

### 7.3 多条件UNION重写

**❌ 原始复杂写法**
```sql
-- 查询：热门商品 + 新品 + 促销商品
SELECT product_id, name, price, 'hot' as tag FROM products 
WHERE sales_count > 1000
UNION
SELECT product_id, name, price, 'new' as tag FROM products 
WHERE created_date > DATE_SUB(NOW(), INTERVAL 30 DAY)
UNION  
SELECT product_id, name, price, 'promotion' as tag FROM products
WHERE discount_rate > 0;
-- 问题：三次全表扫描，同一商品可能出现多次，UNION去重消耗大量资源
```

**✅ 重写后的优化写法**
```sql
-- 使用CASE WHEN一次查询完成
SELECT 
    product_id, 
    name, 
    price,
    CASE 
        WHEN sales_count > 1000 THEN 'hot'
        WHEN created_date > DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 'new'
        WHEN discount_rate > 0 THEN 'promotion'
        ELSE 'normal'
    END as tag
FROM products
WHERE sales_count > 1000 
   OR created_date > DATE_SUB(NOW(), INTERVAL 30 DAY)
   OR discount_rate > 0;
-- 优势：只扫描一次表，每个商品只出现一次，可以为WHERE条件创建组合索引
```

### 7.4 查询重写的最佳实践

**🎯 重写原则**
```
1. 减少表扫描次数：多个UNION扫描同一表 → 一次扫描完成
2. 利用索引：确保重写后的查询能够有效利用索引
3. 减少中间结果：避免产生大量临时数据
4. 简化逻辑：复杂的UNION逻辑 → 简单的条件判断
5. 避免重复计算：多次相同的子查询 → 一次计算多次使用
```

---

## 8. ⚡ 并发执行策略


### 8.1 UNION查询的并发特性

> **🔑 核心理解**
> UNION中的多个子查询理论上可以并行执行，但实际情况取决于数据库的优化器和系统资源

**🔸 并发执行可能性分析**
```
理想情况：
子查询1 ══════════> 结果1
子查询2 ══════════> 结果2  → 合并 → 最终结果
子查询3 ══════════> 结果3

实际情况可能受限于：
- 数据库连接数
- 系统CPU核心数  
- 内存可用量
- 磁盘I/O带宽
- 表锁冲突
```

### 8.2 MySQL中的并行执行

**📊 MySQL 8.0并行查询特性**
```sql
-- 检查并行查询配置
SHOW VARIABLES LIKE 'innodb_parallel_read_threads';
SHOW VARIABLES LIKE 'max_connections';

-- 设置并行线程数
SET SESSION innodb_parallel_read_threads = 4;
```

### 8.3 应用层并发策略

**🚀 多线程并发查询**
```python
# Python示例：并发执行UNION的子查询
import asyncio
import aiomysql

async def execute_query(connection, sql):
    """执行单个查询"""
    async with connection.cursor() as cursor:
        await cursor.execute(sql)
        return await cursor.fetchall()

async def parallel_union_query():
    """并行执行UNION的各个子查询"""
    queries = [
        "SELECT user_id, name FROM users_table1 WHERE status = 'active'",
        "SELECT user_id, name FROM users_table2 WHERE status = 'active'"
    ]
    
    # 并发执行查询
    tasks = [execute_query(conn, query) for conn, query in zip(connections, queries)]
    results = await asyncio.gather(*tasks)
    
    # 合并结果（相当于UNION ALL）
    combined_results = []
    for result in results:
        combined_results.extend(result)
    
    return combined_results
```

### 8.4 并发执行的注意事项

**⚠️ 潜在问题**
```
问题1：资源竞争
- 多个查询竞争相同的磁盘I/O
- 内存缓冲区竞争
- CPU资源竞争

解决方案：
- 错峰执行（如果可能）
- 限制并发度
- 监控系统资源使用情况

问题2：锁冲突
- 表级锁冲突
- 行级锁冲突  
- 元数据锁冲突

解决方案：
- 使用READ UNCOMMITTED隔离级别（如果数据一致性要求不高）
- 避免在UNION查询期间进行DDL操作
- 使用UNION ALL避免额外的锁开销
```

---

## 9. 🌊 大数据UNION挑战与处理


### 9.1 大数据UNION面临的挑战

> **💡 核心理解**
> 当UNION涉及千万级、亿级数据时，传统的处理方式会遇到性能瓶颈和资源限制

**🔸 主要挑战分析**
```
数据量挑战：
- 单表千万级记录
- 多表UNION后数据量爆炸式增长
- 内存无法容纳全部结果集

性能挑战：
- 查询执行时间过长（小时级别）
- 排序去重耗时巨大  
- 磁盘I/O成为瓶颈

资源挑战：
- 内存溢出风险
- 临时文件占满磁盘空间
- CPU长时间高负载
```

### 9.2 分块UNION处理策略

**⚡ 策略1：时间分块处理**
```sql
-- 将大时间范围拆分成小块处理
-- 创建结果表
CREATE TABLE user_actions_result (
    user_id BIGINT,
    action_time DATETIME, 
    action_type VARCHAR(20),
    product_id BIGINT,
    INDEX idx_user_time (user_id, action_time)
);

-- 按月循环处理
-- 插入1月数据
INSERT INTO user_actions_result
SELECT user_id, action_time, 'view' as action_type, product_id 
FROM user_views 
WHERE action_time >= '2024-01-01' AND action_time < '2024-02-01'
UNION ALL
SELECT user_id, purchase_time, 'purchase' as action_type, product_id
FROM user_purchases 
WHERE purchase_time >= '2024-01-01' AND purchase_time < '2024-02-01';

-- 重复处理其他月份...
```

**⚡ 策略2：分页批量处理**
```python
# Python实现分页UNION处理
def process_union_by_batch(connection, start_date, end_date):
    """分批处理大数据UNION"""
    tables = ['user_views', 'user_purchases', 'user_favorites']
    action_types = ['view', 'purchase', 'favorite']
    batch_size = 10000
    
    for table, action_type in zip(tables, action_types):
        offset = 0
        while True:
            sql = f"""
                SELECT user_id, action_time, '{action_type}' as action_type, product_id
                FROM {table}
                WHERE action_time BETWEEN %s AND %s
                ORDER BY action_time
                LIMIT %s OFFSET %s
            """
            cursor = connection.cursor()
            cursor.execute(sql, (start_date, end_date, batch_size, offset))
            results = cursor.fetchall()
            
            if not results:
                break
                
            # 插入结果表
            insert_batch_results(results)
            offset += batch_size
```

### 9.3 大数据UNION最佳实践

**🎯 处理策略选择**
```
数据量级别 → 推荐策略

< 1000万行：
✅ 直接UNION，优化索引和查询
✅ 使用UNION ALL避免去重开销
✅ 适当的硬件资源即可

1000万 - 1亿行：
✅ 分块处理（按时间、按ID范围）
✅ 批量插入临时表
✅ 使用分页查询控制内存
✅ 考虑并行处理

> 1亿行：
✅ 分布式计算框架（Spark、Hadoop）
✅ 数据湖解决方案
✅ 预计算和物化视图
✅ 流式处理实时更新
```

---

## 10. 💾 UNION内存管理


### 10.1 UNION内存使用机制

> **🔑 核心理解**
> UNION操作需要在内存中存储中间结果、进行排序去重，内存管理直接影响查询性能

**🔸 UNION内存使用阶段**
```
阶段1：子查询执行 - 每个SELECT结果存储在内存缓冲区
阶段2：结果合并 - UNION ALL直接流式合并，UNION需要临时表存储
阶段3：去重排序（仅UNION） - 创建临时表进行去重
阶段4：最终排序（如果有ORDER BY） - 对整个结果集排序
```

### 10.2 关键内存参数配置

**📊 MySQL内存相关参数**
```sql
-- 查看当前内存配置
SHOW VARIABLES LIKE 'sort_buffer_size';        -- 排序缓冲区
SHOW VARIABLES LIKE 'tmp_table_size';          -- 临时表大小
SHOW VARIABLES LIKE 'max_heap_table_size';     -- 内存表最大大小

-- 针对UNION优化的配置建议
SET SESSION sort_buffer_size = 16777216;       -- 16MB
SET SESSION tmp_table_size = 134217728;        -- 128MB  
SET SESSION max_heap_table_size = 134217728;   -- 128MB
```

### 10.3 内存使用监控

**🔍 监控内存使用情况**
```sql
-- 查看临时表使用统计
SHOW STATUS LIKE 'Created_tmp%';
/*
Created_tmp_disk_tables: 使用磁盘的临时表数量
Created_tmp_files: 创建的临时文件数量  
Created_tmp_tables: 创建的临时表总数
*/

-- 查看排序使用统计
SHOW STATUS LIKE 'Sort%';
/*
Sort_merge_passes: 排序合并次数
Sort_range: 范围排序次数
Sort_rows: 排序的行数
Sort_scan: 扫描排序次数
*/
```

### 10.4 内存优化策略

**⚡ 策略1：减少内存占用**
```sql
-- 优化前：可能导致内存不足
SELECT customer_id, order_date, amount, product_name
FROM orders_2023
UNION  
SELECT customer_id, order_date, amount, product_name
FROM orders_2024
ORDER BY order_date DESC;

-- 优化后：只查询必要字段，使用UNION ALL
SELECT customer_id, order_date, amount  -- 去掉大字段product_name
FROM orders_2023
UNION ALL  -- 如果确定无重复，使用UNION ALL
SELECT customer_id, order_date, amount
FROM orders_2024
ORDER BY order_date DESC;
```

**⚡ 策略2：分区处理**
```sql
-- 利用分区表减少内存压力
CREATE TABLE user_actions_result (
    user_id BIGINT,
    action_time DATETIME,
    action_type VARCHAR(20),
    product_id BIGINT
) PARTITION BY RANGE (YEAR(action_time)*100 + MONTH(action_time)) (
    PARTITION p202401 VALUES LESS THAN (202402),
    PARTITION p202402 VALUES LESS THAN (202403),
    -- ...更多分区
);
```

---

## 11. 📋 核心调优技术总结


### 11.1 必须掌握的核心技术

```
🔸 类型兼容性：确保UNION字段类型匹配，避免隐式转换
🔸 索引优化：每个子查询都要能有效利用索引
🔸 UNION vs UNION ALL：根据业务需求选择，UNION ALL性能更好
🔸 排序优化：推迟排序，利用索引，分步处理大数据
🔸 分页策略：使用游标分页替代深度OFFSET分页
🔸 查询重写：将复杂UNION改写为高效的JOIN或单表查询
🔸 内存管理：合理配置内存参数，监控临时表使用情况
🔸 大数据处理：分块处理，批量操作，考虑分布式方案
```

### 11.2 关键优化原则

**🔹 性能优先级**
```
1. 避免不必要的UNION：能用JOIN就不用UNION
2. 优先使用UNION ALL：除非确实需要去重
3. 子查询索引优化：确保每个子查询都能用上索引
4. 减少数据传输：只查询必要的字段
5. 分批处理大数据：避免内存溢出和长时间锁定
```

**🔹 监控和调优**
```
关键监控指标：
- 查询执行时间
- 临时表使用情况（Created_tmp_disk_tables）
- 内存使用情况（sort_buffer_size使用率）
- 慢查询日志分析
- 索引使用情况（key_len, rows_examined）

调优步骤：
1. 分析执行计划（EXPLAIN）
2. 识别性能瓶颈点
3. 优化索引策略
4. 调整内存配置
5. 考虑查询重写
6. 测试验证效果
```

### 11.3 实际应用指导

**💼 工作中的最佳实践**
```
设计阶段：
✅ 评估是否真的需要UNION
✅ 考虑表结构设计，减少UNION需求
✅ 预估数据量，选择合适的处理策略

开发阶段：
✅ 为每个子查询创建合适的索引
✅ 使用EXPLAIN分析执行计划
✅ 选择合适的UNION类型（ALL vs DISTINCT）
✅ 优化字段选择和类型转换

运维阶段：
✅ 监控UNION查询的性能表现
✅ 定期检查临时表使用情况
✅ 根据数据增长调整优化策略
✅ 考虑硬件升级或架构调整
```

**🎯 故障排查指南**
```
常见问题 → 排查方向 → 解决方案

查询超时 → 检查索引使用 → 优化WHERE条件索引
内存不足 → 查看临时表大小 → 调整内存参数或分批处理
结果不准确 → 检查类型转换 → 显式类型转换
性能突然下降 → 查看数据量变化 → 调整分页策略或索引
```

**🧠 记忆要点**
- **UNION慢在去重排序，UNION ALL快在直接合并**
- **每个子查询独立优化，整体结果统一处理**
- **大数据分而治之，小数据直接处理**
- **内存够用选UNION，内存不足分批处理**
- **监控先于优化，测试验证效果**

**核心记忆口诀**：
- 类型匹配索引全，UNION ALL性能好
- 排序分页要优化，大数据分块跑  
- 内存监控很重要，查询重写效果高
- 并发处理需谨慎，测试验证不能少