---
title: 1、联合查询与集合操作
---
## 📚 目录

1. [联合查询基础概念](#1-联合查询基础概念)
2. [UNION与UNION ALL核心差异](#2-UNION与UNION-ALL核心差异)
3. [联合查询执行机制详解](#3-联合查询执行机制详解)
4. [性能优化策略与最佳实践](#4-性能优化策略与最佳实践)
5. [字段匹配与类型兼容性](#5-字段匹配与类型兼容性)
6. [索引利用与查询计划优化](#6-索引利用与查询计划优化)
7. [大数据量处理技巧](#7-大数据量处理技巧)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 联合查询基础概念


### 1.1 什么是联合查询


**💡 核心理解**
> 联合查询就像把两个不同的商品清单合并成一个完整清单。比如把"线上订单"和"线下订单"合并，得到"全部订单"列表。

```
生活场景类比：
线上订单：手机、电脑、书籍
线下订单：衣服、鞋子、手机
合并后：手机、电脑、书籍、衣服、鞋子（去重）
```

**🔍 集合论基础**
```
数学集合操作在数据库中的体现：

集合A：{1, 2, 3, 4}
集合B：{3, 4, 5, 6}

并集(UNION)：    {1, 2, 3, 4, 5, 6}  ← 去重合并
联合(UNION ALL)：{1, 2, 3, 4, 3, 4, 5, 6}  ← 直接合并
```

### 1.2 SQL集合操作分类


**📊 数据库集合操作全景**

| 操作类型 | **SQL关键字** | **含义** | **是否去重** | **应用场景** |
|----------|---------------|----------|--------------|--------------|
| 🔄 **并集** | `UNION` | 合并结果，去除重复 | ✅ | 需要唯一记录 |
| 📝 **联合** | `UNION ALL` | 直接合并所有结果 | ❌ | 性能优先场景 |
| 🎯 **交集** | `INTERSECT` | 两查询共同结果 | ✅ | 查找重叠数据 |
| ❌ **差集** | `EXCEPT/MINUS` | 第一查询减去第二查询 | ✅ | 找出不同数据 |

### 1.3 联合查询的基本语法


**🔧 标准语法结构**
```sql
-- 基本UNION语法
SELECT column1, column2, ...
FROM table1
WHERE condition1

UNION [ALL]

SELECT column1, column2, ...  
FROM table2
WHERE condition2

[ORDER BY column_name];
```

**📋 语法要求清单**
- ✅ 各查询的**列数必须相同**
- ✅ 对应列的**数据类型必须兼容**
- ✅ 列名以**第一个查询为准**
- ✅ `ORDER BY`只能放在**最后**

---

## 2. ⚖️ UNION与UNION ALL核心差异


### 2.1 去重机制详解


**🔍 UNION去重机制深度解析**

```sql
-- 示例数据准备
CREATE TABLE orders_online (
    id INT,
    product_name VARCHAR(50),
    price DECIMAL(10,2)
);

CREATE TABLE orders_offline (
    id INT, 
    product_name VARCHAR(50),
    price DECIMAL(10,2)
);

INSERT INTO orders_online VALUES 
(1, '苹果手机', 5999.00),
(2, '笔记本电脑', 7999.00),
(3, '蓝牙耳机', 299.00);

INSERT INTO orders_offline VALUES
(3, '蓝牙耳机', 299.00),  -- 重复数据
(4, '运动鞋', 599.00),
(5, '背包', 199.00);
```

**🔄 UNION执行过程可视化**
```
步骤1: 执行第一个查询
┌─────┬──────────┬─────────┐
│ id  │ product  │  price  │
├─────┼──────────┼─────────┤
│  1  │ 苹果手机  │ 5999.00 │
│  2  │ 笔记本    │ 7999.00 │
│  3  │ 蓝牙耳机  │  299.00 │
└─────┴──────────┴─────────┘

步骤2: 执行第二个查询  
┌─────┬──────────┬─────────┐
│ id  │ product  │  price  │
├─────┼──────────┼─────────┤
│  3  │ 蓝牙耳机  │  299.00 │
│  4  │ 运动鞋    │  599.00 │
│  5  │ 背包      │  199.00 │
└─────┴──────────┴─────────┘

步骤3: UNION合并去重
┌─────┬──────────┬─────────┐
│ id  │ product  │  price  │
├─────┼──────────┼─────────┤
│  1  │ 苹果手机  │ 5999.00 │
│  2  │ 笔记本    │ 7999.00 │
│  3  │ 蓝牙耳机  │  299.00 │ ← 只保留一条
│  4  │ 运动鞋    │  599.00 │
│  5  │ 背包      │  199.00 │
└─────┴──────────┴─────────┘
```

### 2.2 性能差异对比分析


**⚡ 执行时间对比**

```sql
-- UNION查询（带去重）
SELECT product_name, price 
FROM orders_online
UNION  
SELECT product_name, price 
FROM orders_offline;

-- UNION ALL查询（无去重）
SELECT product_name, price 
FROM orders_online
UNION ALL
SELECT product_name, price 
FROM orders_offline;
```

**📈 性能差异表现**

| 方面 | **UNION** | **UNION ALL** | **性能差异** |
|------|-----------|---------------|--------------|
| 🕐 **执行时间** | 慢 | 快 | **UNION ALL快30-70%** |
| 💾 **内存使用** | 高 | 低 | **节省内存50%以上** |
| 📊 **临时表** | 需要 | 不需要 | **避免磁盘IO** |
| 🔄 **排序操作** | 必须 | 可选 | **减少排序开销** |

> **💡 性能优势解释**
> UNION ALL就像直接把两个文件内容复制粘贴到一起，而UNION需要先整理、去重、排序，工作量自然大很多。

### 2.3 使用场景选择指南


**🎯 UNION适用场景**
```sql
-- 场景1: 查询用户在不同表中的唯一记录
SELECT user_id, email FROM active_users
UNION
SELECT user_id, email FROM inactive_users;
-- 目标：获得所有用户，不重复

-- 场景2: 合并不同时期的报表数据  
SELECT product_id, SUM(sales) as total_sales 
FROM sales_2023 GROUP BY product_id
UNION
SELECT product_id, SUM(sales) as total_sales 
FROM sales_2024 GROUP BY product_id;
-- 目标：避免重复统计
```

**🚀 UNION ALL适用场景**
```sql  
-- 场景1: 日志数据合并（不关心重复）
SELECT log_time, log_message FROM app_log_2024_01
UNION ALL
SELECT log_time, log_message FROM app_log_2024_02;
-- 目标：快速获取所有日志

-- 场景2: 报表数据汇总（确定无重复）
SELECT 'Q1' as quarter, SUM(revenue) as total FROM q1_sales
UNION ALL  
SELECT 'Q2' as quarter, SUM(revenue) as total FROM q2_sales;
-- 目标：最快速度生成报表
```

---

## 3. 🔧 联合查询执行机制详解


### 3.1 查询执行计划分析


**📊 执行计划对比**

```sql
-- 查看UNION执行计划
EXPLAIN 
SELECT product_name FROM orders_online 
UNION 
SELECT product_name FROM orders_offline;
```

**🔍 执行计划解读**
```
UNION执行计划：
┌─────────────────────────────────────┐
│ 1. Unique (去重操作)                │ ← 额外开销
│    └── Sort (排序操作)               │ ← 额外开销  
│        └── Append                   │
│            ├── Seq Scan orders_online │
│            └── Seq Scan orders_offline│
└─────────────────────────────────────┘

UNION ALL执行计划：
┌─────────────────────────────────────┐
│ Append                              │ ← 直接合并
│  ├── Seq Scan orders_online         │
│  └── Seq Scan orders_offline        │
└─────────────────────────────────────┘
```

### 3.2 临时表使用机制


**💾 临时表创建过程**

> **⚠️ 重要理解**
> UNION操作需要创建临时表来存储中间结果，这是性能开销的主要来源。

```
UNION临时表使用流程：

第1步：执行子查询1 → 结果存入临时表A
第2步：执行子查询2 → 结果存入临时表B  
第3步：合并A和B → 存入临时表C
第4步：对临时表C去重 → 创建临时表D
第5步：返回最终结果

UNION ALL流程：
第1步：执行子查询1 → 直接输出
第2步：执行子查询2 → 直接输出
（无需临时表，节省内存和IO）
```

### 3.3 内存使用控制


**📈 内存使用优化策略**

```sql
-- 大数据量联合查询优化示例
SELECT customer_id, order_date, amount
FROM large_orders_2023  
WHERE amount > 1000
UNION ALL  -- 使用UNION ALL避免排序
SELECT customer_id, order_date, amount  
FROM large_orders_2024
WHERE amount > 1000
LIMIT 10000;  -- 限制结果集大小
```

**🔧 内存控制参数**
```sql
-- MySQL内存参数调优
SET SESSION tmp_table_size = 512MB;        -- 临时表内存限制
SET SESSION max_heap_table_size = 512MB;   -- 内存表大小限制
SET SESSION sort_buffer_size = 64MB;       -- 排序缓冲区大小
```

---

## 4. 🚀 性能优化策略与最佳实践


### 4.1 UNION查询性能优化核心策略


**🔑 优化策略速查表**

| 策略 | **说明** | **性能提升** | **适用场景** |
|------|----------|--------------|--------------|
| 🚀 **优先使用UNION ALL** | 避免去重开销 | 30-70% | 确定无重复或不关心重复 |
| 📊 **减少返回列数** | 只查询必要字段 | 20-40% | 宽表查询 |
| 🎯 **优化WHERE条件** | 减少子查询结果集 | 50-80% | 大表联合 |
| 📝 **使用LIMIT限制** | 控制结果集大小 | 显著提升 | 分页或预览场景 |

**💡 优化前后对比**
```sql
-- ❌ 性能较差的写法
SELECT * FROM orders_2023 
UNION 
SELECT * FROM orders_2024;

-- ✅ 优化后的写法
SELECT order_id, customer_id, amount  -- 只要必要字段
FROM orders_2023 
WHERE create_date >= '2023-12-01'     -- 添加过滤条件
UNION ALL                             -- 改用UNION ALL
SELECT order_id, customer_id, amount
FROM orders_2024
WHERE create_date <= '2024-01-31'
LIMIT 1000;                          -- 限制结果数量
```

### 4.2 联合查询设计最佳实践


**📋 设计原则清单**

```markdown
✅ **查询设计准则**：
- [ ] 优先考虑UNION ALL而非UNION
- [ ] 在子查询中尽早过滤数据
- [ ] 只选择真正需要的列
- [ ] 合理使用LIMIT控制结果集
- [ ] 避免在UNION中使用ORDER BY（除非必要）

✅ **性能监控准则**：
- [ ] 监控临时表使用情况
- [ ] 检查内存使用是否超标
- [ ] 分析执行计划的Sort操作
- [ ] 测量实际执行时间
```

**🎯 分阶段优化策略**
```
阶段1：基础优化（立即见效）
├── 改UNION为UNION ALL
├── 减少SELECT字段
└── 添加WHERE过滤

阶段2：深度优化（中期改善）  
├── 优化子查询索引
├── 调整内存参数
└── 重构复杂联合查询

阶段3：架构优化（长期方案）
├── 考虑数据分区
├── 使用视图简化查询
└── 数据预处理和缓存
```

### 4.3 大结果集处理技巧


**📊 分页查询优化**
```sql
-- 大数据量分页优化
SELECT * FROM (
    SELECT order_id, customer_id, amount,
           ROW_NUMBER() OVER(ORDER BY order_id) as rn
    FROM orders_2023 
    WHERE status = 'completed'
    UNION ALL
    SELECT order_id, customer_id, amount,
           ROW_NUMBER() OVER(ORDER BY order_id) as rn  
    FROM orders_2024
    WHERE status = 'completed'
) t
WHERE t.rn BETWEEN 1001 AND 2000;  -- 第11页，每页1000条
```

**💾 流式处理方案**
```sql
-- 流式导出大数据集
SELECT /*+ USE_CONCAT */ 
    order_id, customer_id, amount
FROM orders_2023
WHERE export_date = CURDATE()
UNION ALL
SELECT order_id, customer_id, amount  
FROM orders_2024
WHERE export_date = CURDATE()
INTO OUTFILE '/tmp/orders_export.csv'
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n';
```

---

## 5. 🎨 字段匹配与类型兼容性


### 5.1 字段匹配规则详解


**📏 匹配规则基本原理**

> **💡 核心理解**
> 联合查询就像拼装两个积木，每一层的积木块数量和形状都必须匹配，才能完美拼接。

```
字段匹配可视化：

查询1: SELECT name, age, city     ← 3个字段
查询2: SELECT name, age, city     ← 3个字段 ✅匹配

查询1: SELECT name, age, city     ← 3个字段  
查询2: SELECT name, age           ← 2个字段 ❌不匹配
```

**🔧 字段对应规则**
```sql
-- ✅ 正确的字段匹配
SELECT customer_name as name, age, city FROM customers
UNION ALL
SELECT supplier_name as name, age, city FROM suppliers;
-- 字段名可以不同，但位置和类型要匹配

-- ❌ 错误的字段匹配  
SELECT customer_name, age FROM customers         -- 2个字段
UNION ALL
SELECT supplier_name, age, city FROM suppliers;  -- 3个字段
-- 报错：字段数量不匹配
```

### 5.2 数据类型兼容性


**📊 类型兼容性矩阵**

| 第一查询类型 | **兼容的第二查询类型** | **结果类型** | **注意事项** |
|--------------|------------------------|--------------|--------------|
| **INT** | SMALLINT, INT, BIGINT | BIGINT | 自动类型提升 |
| **VARCHAR(50)** | VARCHAR(100), CHAR(20) | VARCHAR(100) | 取较大长度 |
| **DECIMAL(10,2)** | DECIMAL(8,2), FLOAT | DECIMAL(10,2) | 精度可能丢失 |
| **DATE** | DATETIME, TIMESTAMP | DATETIME | 自动转换 |

**🔍 类型转换示例**
```sql
-- 数值类型兼容
SELECT product_id, price FROM products        -- price是DECIMAL(10,2)
UNION ALL  
SELECT product_id, discount FROM discounts;   -- discount是FLOAT
-- 结果：price列类型为DECIMAL，discount自动转换

-- 字符串长度处理
SELECT SUBSTR(long_description, 1, 100) as desc FROM table1  -- 截断到100字符
UNION ALL
SELECT short_description as desc FROM table2;                -- 已经是50字符
-- 结果：统一为100字符长度
```

### 5.3 字段类型不匹配的解决方案


**🔧 类型转换技巧**
```sql
-- 场景1：数值与字符串混合
SELECT customer_id, CAST(customer_code AS CHAR) as identifier
FROM customers
UNION ALL  
SELECT customer_id, phone_number as identifier  
FROM customer_phones;

-- 场景2：日期格式统一
SELECT order_id, DATE_FORMAT(create_time, '%Y-%m-%d') as order_date
FROM online_orders  
UNION ALL
SELECT order_id, order_date  
FROM offline_orders;

-- 场景3：NULL值处理
SELECT product_name, COALESCE(discount, 0) as discount_rate
FROM products_with_discount
UNION ALL
SELECT product_name, 0 as discount_rate  
FROM products_no_discount;
```

**⚠️ 常见类型问题**
```sql
-- 问题1：隐式类型转换导致的性能问题
SELECT customer_id FROM customers WHERE customer_id = '123'  -- 字符串
UNION ALL  
SELECT customer_id FROM vip_customers WHERE customer_id = 123;  -- 数字
-- 建议：保持类型一致性

-- 问题2：精度丢失  
SELECT price FROM products                    -- DECIMAL(10,2)
UNION ALL
SELECT CAST(estimated_price AS DECIMAL(10,2)) FROM estimates;  -- FLOAT转换
-- 建议：显式转换控制精度
```

---

## 6. 🔍 索引利用与查询计划优化


### 6.1 UNION索引利用机制


**📊 索引使用分析**

> **🔍 深入理解**
> UNION查询中每个子查询都可以独立使用索引，但合并后的去重操作无法利用索引，这是性能瓶颈的关键。

```sql
-- 创建测试索引
CREATE INDEX idx_orders_date ON orders_2023(order_date);
CREATE INDEX idx_orders_date ON orders_2024(order_date);
CREATE INDEX idx_orders_status ON orders_2023(status);  
CREATE INDEX idx_orders_status ON orders_2024(status);

-- 索引利用查询示例
SELECT order_id, customer_id, amount
FROM orders_2023 
WHERE order_date >= '2023-12-01' AND status = 'completed'  -- 可以使用复合索引
UNION ALL
SELECT order_id, customer_id, amount
FROM orders_2024
WHERE order_date <= '2024-02-01' AND status = 'completed';  -- 可以使用复合索引
```

**🎯 索引优化策略图**
```
子查询1索引使用：
orders_2023
├── 使用idx_orders_date过滤日期
├── 使用idx_orders_status过滤状态  
└── 返回结果集A

子查询2索引使用：
orders_2024  
├── 使用idx_orders_date过滤日期
├── 使用idx_orders_status过滤状态
└── 返回结果集B

UNION合并：
结果集A + 结果集B → 临时表 → 排序去重 → 最终结果
                      ↑
                 无法使用索引（性能瓶颈）
```

### 6.2 执行计划优化分析


**📈 执行计划对比分析**
```sql
-- 分析查询执行计划
EXPLAIN FORMAT=JSON
SELECT customer_id, SUM(amount) as total
FROM orders_2023 
WHERE status = 'completed'
GROUP BY customer_id
UNION  
SELECT customer_id, SUM(amount) as total  
FROM orders_2024
WHERE status = 'completed' 
GROUP BY customer_id;
```

**🔍 执行计划解读要点**
```json
{
  "query_block": {
    "union_result": {
      "using_temporary_table": true,     ← 使用临时表
      "duplicate_removal": true,         ← 执行去重操作
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "cost_info": {
              "query_cost": "1250.00"    ← 子查询1成本
            },
            "grouping_operation": {
              "using_filesort": false,    ← 是否使用文件排序
              "table": {
                "table_name": "orders_2023",
                "access_type": "range",   ← 索引范围扫描
                "key": "idx_status"       ← 使用的索引
              }
            }
          }
        }
      ]
    }
  }
}
```

### 6.3 查询重写优化技巧


**🔧 重写优化示例**
```sql
-- ❌ 性能较差：UNION导致全表扫描后去重
SELECT DISTINCT customer_id FROM orders_2023
UNION
SELECT DISTINCT customer_id FROM orders_2024;

-- ✅ 优化方案1：先去重再联合
SELECT customer_id FROM (
  SELECT DISTINCT customer_id FROM orders_2023
  UNION ALL
  SELECT DISTINCT customer_id FROM orders_2024
) t GROUP BY customer_id;

-- ✅ 优化方案2：使用EXISTS避免联合
SELECT DISTINCT customer_id FROM orders_2023 o1
WHERE EXISTS (SELECT 1 FROM orders_2024 o2 WHERE o2.customer_id = o1.customer_id)
   OR NOT EXISTS (SELECT 1 FROM orders_2024);
```

**📊 复杂查询优化策略**
```sql
-- 场景：统计每个用户在不同表中的订单总数
-- ❌ 低效写法：多次GROUP BY后UNION
SELECT customer_id, 'online' as source, COUNT(*) as order_count
FROM online_orders GROUP BY customer_id
UNION ALL
SELECT customer_id, 'offline' as source, COUNT(*) as order_count  
FROM offline_orders GROUP BY customer_id;

-- ✅ 高效写法：使用JOIN避免UNION
SELECT c.customer_id,
       COALESCE(o.online_count, 0) as online_count,
       COALESCE(f.offline_count, 0) as offline_count
FROM customers c
LEFT JOIN (SELECT customer_id, COUNT(*) as online_count 
          FROM online_orders GROUP BY customer_id) o ON c.customer_id = o.customer_id
LEFT JOIN (SELECT customer_id, COUNT(*) as offline_count  
          FROM offline_orders GROUP BY customer_id) f ON c.customer_id = f.customer_id;
```

---

## 7. 📊 大数据量处理技巧


### 7.1 内存使用控制策略


**💾 内存优化配置**

```sql
-- MySQL内存参数优化
SET SESSION sort_buffer_size = 128MB;           -- 排序缓冲区
SET SESSION tmp_table_size = 256MB;             -- 临时表内存限制  
SET SESSION max_heap_table_size = 256MB;        -- 内存表大小
SET SESSION join_buffer_size = 64MB;            -- 连接缓冲区

-- 查看当前内存使用
SHOW STATUS LIKE 'Created_tmp%';
-- Created_tmp_disk_tables: 创建的磁盘临时表数量
-- Created_tmp_tables: 创建的临时表总数
```

**🔍 内存使用监控**
```sql
-- 监控临时表使用情况
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Created_tmp_disk_tables' 
        THEN '磁盘临时表（性能差）'
        WHEN VARIABLE_NAME = 'Created_tmp_tables'
        THEN '总临时表数'
    END as description
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN ('Created_tmp_disk_tables', 'Created_tmp_tables');
```

### 7.2 分批处理策略


**📦 数据分批处理方案**
```sql
-- 大数据集分批联合查询
DELIMITER $$
CREATE PROCEDURE batch_union_query()
BEGIN
    DECLARE batch_size INT DEFAULT 10000;
    DECLARE offset_val INT DEFAULT 0;
    DECLARE done INT DEFAULT FALSE;
    
    -- 创建结果临时表
    CREATE TEMPORARY TABLE temp_union_result (
        order_id INT,
        customer_id INT, 
        amount DECIMAL(10,2),
        order_date DATE
    );
    
    -- 分批处理循环
    batch_loop: LOOP
        INSERT INTO temp_union_result
        SELECT order_id, customer_id, amount, order_date
        FROM (
            SELECT order_id, customer_id, amount, order_date
            FROM orders_2023 
            WHERE id > offset_val 
            ORDER BY id 
            LIMIT batch_size
            UNION ALL
            SELECT order_id, customer_id, amount, order_date  
            FROM orders_2024
            WHERE id > offset_val
            ORDER BY id
            LIMIT batch_size
        ) t;
        
        -- 检查是否还有数据
        IF ROW_COUNT() = 0 THEN
            LEAVE batch_loop;
        END IF;
        
        SET offset_val = offset_val + batch_size;
    END LOOP;
    
    -- 返回最终结果
    SELECT * FROM temp_union_result ORDER BY order_date;
    DROP TEMPORARY TABLE temp_union_result;
END$$
DELIMITER ;
```

### 7.3 流式处理与导出优化


**🌊 流式数据导出**
```sql  
-- 大数据量导出优化
SELECT /*+ USE_INDEX(orders_2023, idx_date) */
    order_id,
    customer_id, 
    amount,
    DATE_FORMAT(order_date, '%Y-%m-%d') as formatted_date
FROM orders_2023
WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31'
    AND status = 'completed'
UNION ALL
SELECT /*+ USE_INDEX(orders_2024, idx_date) */
    order_id,
    customer_id,
    amount, 
    DATE_FORMAT(order_date, '%Y-%m-%d') as formatted_date
FROM orders_2024  
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31'
    AND status = 'completed'
INTO OUTFILE '/data/exports/orders_union_export.csv'
FIELDS TERMINATED BY ',' 
OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

**📊 分区表联合查询优化**
```sql
-- 分区表优化联合查询
SELECT 
    partition_name,
    order_count,
    total_amount
FROM (
    -- 2023年各分区统计
    SELECT 
        'Q1_2023' as partition_name,
        COUNT(*) as order_count,
        SUM(amount) as total_amount
    FROM orders_2023_q1
    WHERE status = 'completed'
    
    UNION ALL
    
    SELECT 
        'Q2_2023' as partition_name, 
        COUNT(*) as order_count,
        SUM(amount) as total_amount
    FROM orders_2023_q2  
    WHERE status = 'completed'
    
    UNION ALL
    
    -- 2024年各分区统计  
    SELECT
        'Q1_2024' as partition_name,
        COUNT(*) as order_count, 
        SUM(amount) as total_amount
    FROM orders_2024_q1
    WHERE status = 'completed'
) quarterly_stats
ORDER BY partition_name;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```markdown
🔸 **UNION基础**：合并查询结果，自动去重，类似集合并集操作
🔸 **UNION ALL**：直接合并所有结果，不去重，性能优于UNION
🔸 **字段匹配**：列数必须相同，对应位置类型必须兼容
🔸 **执行机制**：UNION需要临时表和排序，UNION ALL直接合并输出
🔸 **性能优化**：优先使用UNION ALL，减少字段，添加过滤条件
```

### 8.2 关键性能优化要点


**🚀 性能提升速查**
```markdown
立即见效的优化：
✅ UNION → UNION ALL（提升30-70%）
✅ SELECT * → SELECT 具体字段（提升20-40%）  
✅ 添加WHERE过滤条件（提升50-80%）
✅ 合理使用LIMIT限制结果

中级优化技巧：
✅ 优化子查询索引利用
✅ 调整内存参数配置
✅ 监控临时表使用情况
✅ 避免不必要的ORDER BY

高级优化策略：
✅ 考虑用JOIN替代UNION
✅ 实施数据分区策略  
✅ 使用分批处理方案
✅ 流式处理大数据集
```

### 8.3 实际应用指导原则


**🎯 使用场景决策树**
```
需要合并查询结果？
├── 是 → 结果中可能有重复数据？
│   ├── 是 → 需要去除重复？
│   │   ├── 是 → 使用 UNION
│   │   └── 否 → 使用 UNION ALL
│   └── 否 → 使用 UNION ALL
└── 否 → 考虑其他方案（JOIN/EXISTS等）

数据量大小考虑：
├── 小数据量（<1万行）→ UNION和UNION ALL差异不大
├── 中等数据量（1万-100万行）→ 优先UNION ALL
└── 大数据量（>100万行）→ 必须UNION ALL + 其他优化
```

**📊 监控和维护建议**
```sql
-- 定期检查UNION查询性能
SELECT 
    DIGEST_TEXT,
    COUNT_STAR as execution_count,
    AVG_TIMER_WAIT/1000000000 as avg_exec_time_sec,
    SUM_CREATED_TMP_TABLES as temp_tables_created,
    SUM_CREATED_TMP_DISK_TABLES as disk_temp_tables
FROM performance_schema.events_statements_summary_by_digest 
WHERE DIGEST_TEXT LIKE '%UNION%'
ORDER BY avg_exec_time_sec DESC
LIMIT 10;
```

### 8.4 常见问题解决方案


**🔧 问题排查清单**
```markdown
性能问题排查：
□ 检查是否可以用UNION ALL替代UNION
□ 确认子查询是否使用了合适的索引
□ 查看是否创建了过多的磁盘临时表  
□ 检查内存参数配置是否合理

结果错误排查：
□ 确认各子查询的字段数量是否一致
□ 检查对应字段的数据类型是否兼容
□ 验证NULL值处理是否正确
□ 确认字符集编码是否一致

语法错误排查：  
□ ORDER BY是否只放在最后
□ 字段别名是否以第一个查询为准
□ 括号使用是否正确
□ 分号位置是否合适
```

**💡 最佳实践总结**
> **核心记忆口诀**：
> - 能用UNION ALL就别用UNION
> - 先过滤再联合，减少中间结果
> - 只查需要的字段，避免SELECT *
> - 大数据分批处理，小数据直接查
> - 监控临时表，优化是王道

**🎯 学习进展检查**
- 🟢 **已掌握**：能解释UNION和UNION ALL的区别
- 🟡 **学习中**：理解执行计划和性能优化原理  
- 🔴 **待深入**：掌握大数据量处理和分区优化技巧
