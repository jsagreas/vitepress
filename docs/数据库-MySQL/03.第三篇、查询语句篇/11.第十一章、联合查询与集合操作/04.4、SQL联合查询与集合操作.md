---
title: 4、SQL联合查询与集合操作
---
## 📚 目录

1. [集合操作基础概念](#1-集合操作基础概念)
2. [EXCEPT差集操作详解](#2-EXCEPT差集操作详解)
3. [INTERSECT交集操作详解](#3-INTERSECT交集操作详解)
4. [集合操作的模拟实现](#4-集合操作的模拟实现)
5. [复杂集合运算组合](#5-复杂集合运算组合)
6. [性能优化与最佳实践](#6-性能优化与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 集合操作基础概念


### 1.1 什么是集合操作


**简单理解**：集合操作就像数学中的集合运算，把两个或多个查询结果当作集合进行运算。

```
想象两个班级的学生名单：
班级A：张三、李四、王五、赵六
班级B：王五、赵六、孙七、周八

集合操作就是对这两个名单进行各种运算：
• 并集（UNION）：所有学生 = 张三、李四、王五、赵六、孙七、周八
• 交集（INTERSECT）：共同学生 = 王五、赵六  
• 差集（EXCEPT）：A班独有 = 张三、李四
```

### 1.2 SQL中的集合操作类型


```
┌─────────────────────────────────────────┐
│             SQL集合操作                  │
├─────────────────┬───────────────────────┤
│   UNION         │   并集（合并去重）       │
├─────────────────┼───────────────────────┤
│   UNION ALL     │   并集（保留重复）       │
├─────────────────┼───────────────────────┤
│   INTERSECT     │   交集（共同部分）       │
├─────────────────┼───────────────────────┤
│   EXCEPT/MINUS  │   差集（A有B没有）       │
└─────────────────┴───────────────────────┘
```

### 1.3 集合操作的基本规则


**🔸 核心规则**
```sql
-- 基本语法结构
SELECT column1, column2 FROM table1
[UNION | INTERSECT | EXCEPT]  
SELECT column1, column2 FROM table2;

-- 必须满足的条件：
• 两个查询的列数必须相同
• 对应列的数据类型必须兼容  
• 列名以第一个查询为准
• 结果会自动去除重复行（除UNION ALL外）
```

**💡 通俗解释**
- 就像两个表格合并，列数和类型要对得上
- 如果第一个查询有3列，第二个也必须有3列
- 如果第一列是数字，第二个查询的第一列也要是数字

---

## 2. 🔄 EXCEPT差集操作详解


### 2.1 EXCEPT的含义


**什么是差集**：A EXCEPT B = A中有但B中没有的数据

```
直观理解：
集合A: {1, 2, 3, 4, 5}
集合B: {3, 4, 5, 6, 7}

A EXCEPT B = {1, 2}  （A有但B没有的）
B EXCEPT A = {6, 7}  （B有但A没有的）

注意：EXCEPT不是对称的！A-B ≠ B-A
```

### 2.2 EXCEPT的标准用法


**🔸 基础示例**
```sql
-- 示例：查找只选了数学课但没选英语课的学生
SELECT student_id, student_name 
FROM math_students
EXCEPT
SELECT student_id, student_name 
FROM english_students;
```

**🔸 实际应用场景**
```sql
-- 场景1：找出有订单但没有付款的客户
SELECT customer_id, customer_name
FROM orders 
EXCEPT
SELECT customer_id, customer_name  
FROM payments;

-- 场景2：找出员工表中有但部门表中没有的部门
SELECT department_id
FROM employees
EXCEPT  
SELECT department_id
FROM departments;
```

### 2.3 EXCEPT的模拟实现方法


#### 方法一：NOT EXISTS子查询


```sql
-- 用NOT EXISTS模拟EXCEPT
SELECT student_id, student_name 
FROM math_students m
WHERE NOT EXISTS (
    SELECT 1 
    FROM english_students e 
    WHERE e.student_id = m.student_id 
    AND e.student_name = m.student_name
);
```

**通俗解释**：
- "找math_students中的学生"
- "但要求这个学生在english_students中找不到"
- NOT EXISTS就是"找不到"的意思

#### 方法二：LEFT JOIN + IS NULL


```sql
-- 用LEFT JOIN模拟EXCEPT  
SELECT m.student_id, m.student_name
FROM math_students m
LEFT JOIN english_students e 
    ON m.student_id = e.student_id 
    AND m.student_name = e.student_name
WHERE e.student_id IS NULL;
```

**通俗解释**：
- LEFT JOIN保留左表所有记录
- 右表没有匹配的记录会显示NULL
- WHERE e.student_id IS NULL就筛选出右表没有的记录

#### 方法三：NOT IN（需要注意NULL值）


```sql
-- 用NOT IN模拟（单列情况）
SELECT student_id 
FROM math_students
WHERE student_id NOT IN (
    SELECT student_id 
    FROM english_students
    WHERE student_id IS NOT NULL  -- 重要！避免NULL陷阱
);
```

**⚠️ 重要提醒**：NOT IN遇到NULL值会返回错误结果，必须过滤NULL！

---

## 3. 🔀 INTERSECT交集操作详解


### 3.1 INTERSECT的含义  


**什么是交集**：A INTERSECT B = A和B共同拥有的数据

```
直观理解：
集合A: {1, 2, 3, 4, 5}
集合B: {3, 4, 5, 6, 7}

A INTERSECT B = {3, 4, 5}  （A和B都有的）

注意：INTERSECT是对称的！A∩B = B∩A
```

### 3.2 INTERSECT的标准用法


**🔸 基础示例**
```sql
-- 示例：查找既选了数学课又选了英语课的学生
SELECT student_id, student_name 
FROM math_students
INTERSECT
SELECT student_id, student_name 
FROM english_students;
```

**🔸 实际应用场景**
```sql
-- 场景1：找出既是VIP客户又有投诉记录的客户
SELECT customer_id, customer_name
FROM vip_customers 
INTERSECT
SELECT customer_id, customer_name  
FROM complaints;

-- 场景2：找出同时在两个项目组的员工
SELECT employee_id, employee_name
FROM project_a_members
INTERSECT  
SELECT employee_id, employee_name
FROM project_b_members;
```

### 3.3 INTERSECT的模拟实现方法


#### 方法一：EXISTS子查询


```sql
-- 用EXISTS模拟INTERSECT
SELECT student_id, student_name 
FROM math_students m
WHERE EXISTS (
    SELECT 1 
    FROM english_students e 
    WHERE e.student_id = m.student_id 
    AND e.student_name = m.student_name
);
```

**通俗解释**：
- "从math_students中找学生"  
- "但要求这个学生在english_students中也能找到"
- EXISTS就是"能找到"的意思

#### 方法二：INNER JOIN


```sql
-- 用INNER JOIN模拟INTERSECT
SELECT DISTINCT m.student_id, m.student_name
FROM math_students m
INNER JOIN english_students e 
    ON m.student_id = e.student_id 
    AND m.student_name = e.student_name;
```

**通俗解释**：
- INNER JOIN只保留两表都有的记录
- DISTINCT去除重复（模拟INTERSECT的去重效果）

#### 方法三：IN子查询（需要处理复合条件）


```sql
-- 用IN模拟（单列情况）
SELECT student_id 
FROM math_students
WHERE student_id IN (
    SELECT student_id 
    FROM english_students
);

-- 多列情况需要用(col1, col2) IN的形式
SELECT student_id, student_name
FROM math_students  
WHERE (student_id, student_name) IN (
    SELECT student_id, student_name
    FROM english_students
);
```

---

## 4. 🛠 集合操作的模拟实现


### 4.1 完整的模拟实现对比表


| **操作** | **标准语法** | **EXISTS模拟** | **JOIN模拟** | **性能特点** |
|---------|-------------|---------------|-------------|-------------|
| `EXCEPT` | `A EXCEPT B` | `NOT EXISTS` | `LEFT JOIN + IS NULL` | `EXISTS通常更快` |
| `INTERSECT` | `A INTERSECT B` | `EXISTS` | `INNER JOIN + DISTINCT` | `JOIN适合大数据` |

### 4.2 各种模拟方法的优缺点


**🔸 EXISTS/NOT EXISTS方法**
```sql
-- 优点：逻辑清晰，性能通常较好
-- 缺点：嵌套查询，复杂度较高

-- INTERSECT模拟
SELECT * FROM table_a a
WHERE EXISTS (
    SELECT 1 FROM table_b b 
    WHERE a.key = b.key
);

-- EXCEPT模拟  
SELECT * FROM table_a a
WHERE NOT EXISTS (
    SELECT 1 FROM table_b b 
    WHERE a.key = b.key
);
```

**🔸 JOIN方法**
```sql
-- 优点：执行计划通常更优，适合大数据量
-- 缺点：需要注意去重问题

-- INTERSECT模拟
SELECT DISTINCT a.*
FROM table_a a
INNER JOIN table_b b ON a.key = b.key;

-- EXCEPT模拟
SELECT a.*
FROM table_a a  
LEFT JOIN table_b b ON a.key = b.key
WHERE b.key IS NULL;
```

### 4.3 实际项目中的选择建议


```
选择标准：

数据量较小（<10万行）：
→ 优先使用EXISTS/NOT EXISTS
→ 代码更清晰易懂

数据量较大（>10万行）：  
→ 优先使用JOIN方式
→ 性能更好，执行计划更优

有索引支持：
→ JOIN方式效率更高
→ 可以充分利用索引

需要多列比较：
→ EXISTS方式更灵活
→ JOIN需要注意NULL值处理
```

---

## 5. 🔧 复杂集合运算组合


### 5.1 多个集合操作的组合


**🔸 三表集合运算示例**
```sql
-- 场景：找出选了数学但没选英语和物理的学生
SELECT student_id, student_name FROM math_students
EXCEPT
(SELECT student_id, student_name FROM english_students
 UNION  
 SELECT student_id, student_name FROM physics_students);
```

**用模拟方法实现**：
```sql
-- 方法1：多重NOT EXISTS
SELECT student_id, student_name 
FROM math_students m
WHERE NOT EXISTS (
    SELECT 1 FROM english_students e 
    WHERE e.student_id = m.student_id
)
AND NOT EXISTS (
    SELECT 1 FROM physics_students p 
    WHERE p.student_id = m.student_id  
);

-- 方法2：LEFT JOIN多表
SELECT m.student_id, m.student_name
FROM math_students m
LEFT JOIN english_students e ON m.student_id = e.student_id
LEFT JOIN physics_students p ON m.student_id = p.student_id  
WHERE e.student_id IS NULL 
AND p.student_id IS NULL;
```

### 5.2 嵌套集合操作


**🔸 复杂业务场景**
```sql
-- 场景：找出（VIP客户 交集 有订单客户）差集 有投诉客户
-- 即：VIP且有订单但没有投诉的客户

-- 标准SQL（如果支持）
(SELECT customer_id FROM vip_customers
 INTERSECT 
 SELECT customer_id FROM order_customers)
EXCEPT
SELECT customer_id FROM complaint_customers;
```

**模拟实现**：
```sql
-- 分步骤实现
WITH vip_with_orders AS (
    -- 第一步：VIP且有订单
    SELECT v.customer_id, v.customer_name
    FROM vip_customers v
    INNER JOIN order_customers o ON v.customer_id = o.customer_id
)
-- 第二步：排除有投诉的
SELECT vwo.customer_id, vwo.customer_name  
FROM vip_with_orders vwo
WHERE NOT EXISTS (
    SELECT 1 FROM complaint_customers c 
    WHERE c.customer_id = vwo.customer_id
);
```

### 5.3 集合操作的执行顺序


```
运算优先级（从高到低）：
1. 括号内的操作
2. INTERSECT  
3. UNION 和 EXCEPT（从左到右）

示例理解：
A UNION B INTERSECT C
等价于：A UNION (B INTERSECT C)
不等价于：(A UNION B) INTERSECT C

建议：复杂操作时用括号明确指定顺序！
```

---

## 6. ⚡ 性能优化与最佳实践


### 6.1 性能优化策略


**🔸 索引优化**
```sql
-- 为集合操作的关键列创建索引
CREATE INDEX idx_student_id ON math_students(student_id);
CREATE INDEX idx_student_id ON english_students(student_id);

-- 复合索引更有效
CREATE INDEX idx_student_info ON math_students(student_id, student_name);
```

**🔸 执行计划分析**
```sql
-- 分析不同实现方式的性能
EXPLAIN (ANALYZE, BUFFERS) 
SELECT student_id FROM math_students
EXCEPT
SELECT student_id FROM english_students;

-- 对比EXISTS方式的性能
EXPLAIN (ANALYZE, BUFFERS)
SELECT student_id FROM math_students m
WHERE NOT EXISTS (
    SELECT 1 FROM english_students e 
    WHERE e.student_id = m.student_id
);
```

### 6.2 大数据量优化技巧


**🔸 分页处理**
```sql
-- 对于大结果集，使用分页避免内存溢出
SELECT student_id, student_name
FROM (
    SELECT student_id, student_name 
    FROM math_students
    WHERE NOT EXISTS (
        SELECT 1 FROM english_students e 
        WHERE e.student_id = math_students.student_id
    )
    ORDER BY student_id
    LIMIT 1000 OFFSET 0
);
```

**🔸 临时表优化**
```sql
-- 对于复杂查询，使用临时表分步处理
CREATE TEMPORARY TABLE temp_math_only AS
SELECT student_id, student_name FROM math_students
WHERE NOT EXISTS (
    SELECT 1 FROM english_students e 
    WHERE e.student_id = math_students.student_id
);

-- 在临时表基础上继续处理
SELECT * FROM temp_math_only 
WHERE student_id > 1000;
```

### 6.3 避免常见性能陷阱


**⚠️ NULL值处理陷阱**
```sql
-- 错误写法：NOT IN遇到NULL会出问题
SELECT student_id FROM math_students
WHERE student_id NOT IN (
    SELECT student_id FROM english_students  -- 如果有NULL值，结果错误
);

-- 正确写法：过滤NULL值
SELECT student_id FROM math_students  
WHERE student_id NOT IN (
    SELECT student_id FROM english_students 
    WHERE student_id IS NOT NULL
);
```

**⚠️ 重复计算子查询**
```sql
-- 低效写法：子查询被重复执行
SELECT * FROM math_students m
WHERE NOT EXISTS (SELECT 1 FROM english_students WHERE student_id = m.student_id)
AND NOT EXISTS (SELECT 1 FROM english_students WHERE student_name = m.student_name);

-- 优化写法：合并条件
SELECT * FROM math_students m  
WHERE NOT EXISTS (
    SELECT 1 FROM english_students e 
    WHERE e.student_id = m.student_id 
    OR e.student_name = m.student_name
);
```

### 6.4 最佳实践建议


```
实践建议：

1. 索引策略：
   • 为连接字段创建索引
   • 考虑使用复合索引
   • 定期分析索引使用情况

2. 查询优化：
   • 小表驱动大表
   • 避免SELECT *，只选需要的列
   • 合理使用LIMIT限制结果集

3. 代码规范：
   • 复杂逻辑用CTE分步实现
   • 添加适当的注释说明
   • 统一命名规范

4. 监控调优：
   • 监控慢查询日志
   • 定期分析执行计划
   • 根据实际数据分布调整策略
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 集合操作本质：把查询结果当作集合进行数学运算
🔸 EXCEPT差集：A中有但B中没有的数据（不对称）
🔸 INTERSECT交集：A和B共同拥有的数据（对称）  
🔸 基本规则：列数相同、类型兼容、自动去重
🔸 模拟方法：EXISTS/NOT EXISTS、JOIN、IN/NOT IN
```

### 7.2 关键理解要点


**🔹 EXCEPT vs INTERSECT的本质区别**
```
EXCEPT（差集）：
• 找出第一个集合独有的元素
• 不对称操作：A-B ≠ B-A
• 类似"排除法"思维

INTERSECT（交集）：  
• 找出两个集合共同的元素
• 对称操作：A∩B = B∩A
• 类似"筛选法"思维
```

**🔹 模拟实现的选择原则**
```
优先考虑因素：
1. 数据量大小（小用EXISTS，大用JOIN）
2. 索引情况（有索引优先JOIN）
3. 查询复杂度（简单用IN，复杂用EXISTS）
4. NULL值处理（EXISTS最安全）
```

**🔹 性能优化的核心思路**
```
基本原则：
• 小表驱动大表
• 充分利用索引
• 避免重复子查询
• 合理处理NULL值
• 适当使用临时表分步处理
```

### 7.3 实际应用指导


**🔸 业务场景映射**
```sql
-- 用户行为分析
/* 活跃用户但未购买 */ → EXCEPT
/* 既浏览又购买的用户 */ → INTERSECT  
/* 新用户排除老客户 */ → EXCEPT

-- 权限管理
/* 有角色但无权限的用户 */ → EXCEPT
/* 同时拥有多个角色的用户 */ → INTERSECT

-- 数据清洗
/* 主表中有但从表中缺失 */ → EXCEPT
/* 两个数据源的共同记录 */ → INTERSECT
```

**🔸 SQL编写技巧**
```sql
-- 1. 明确业务逻辑
-- 先用自然语言描述需求，再转换为SQL

-- 2. 选择合适的实现方式  
-- 考虑数据量、索引、复杂度等因素

-- 3. 注意边界条件
-- 空结果集、NULL值、重复数据

-- 4. 验证结果正确性
-- 用小数据集验证逻辑正确性
```

### 7.4 学习进阶建议


**🔸 知识拓展方向**
```
进阶学习：
1. 窗口函数与集合操作结合
2. 递归查询中的集合应用
3. 分布式数据库中的集合优化
4. 数据仓库ETL中的集合应用
```

**🔸 实践练习建议**
```
练习重点：
1. 手写各种模拟实现方式
2. 对比不同方法的性能差异
3. 处理复杂的多表集合运算
4. 在实际项目中应用优化技巧
```

**核心记忆**：
- 集合操作是数学思维在SQL中的体现
- EXCEPT找差异，INTERSECT找共同
- EXISTS安全，JOIN高效，IN简单但要防NULL
- 索引是性能关键，分步是复杂查询的解决方案
- 理解业务逻辑比记住语法更重要