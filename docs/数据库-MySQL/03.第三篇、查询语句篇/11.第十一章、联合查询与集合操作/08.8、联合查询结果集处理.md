---
title: 8、联合查询结果集处理
---
## 📚 目录

1. [联合查询基础理解](#1-联合查询基础理解)
2. [UNION结果去重机制](#2-UNION结果去重机制)
3. [联合结果集排序](#3-联合结果集排序)
4. [结果集字段映射](#4-结果集字段映射)
5. [NULL值联合处理](#5-NULL值联合处理)
6. [联合结果分页](#6-联合结果分页)
7. [结果集流式处理](#7-结果集流式处理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 联合查询基础理解


### 1.1 什么是联合查询


🌰 **生活类比**：
联合查询就像把不同班级的学生成绩单合并在一起：
- 每个班级都有自己的成绩单（不同的表）
- 合并后变成一个完整的成绩单（结果集）
- 重复的学生记录需要处理（去重问题）

**📋 核心概念**
```
联合查询：将多个SELECT查询的结果合并成一个结果集
目的：把分散在不同表或查询中的相关数据统一展示
关键词：UNION 和 UNION ALL
```

### 1.2 UNION vs UNION ALL 的本质区别


```sql
-- UNION：自动去重（慢但干净）
SELECT name, age FROM students_class1
UNION
SELECT name, age FROM students_class2;

-- UNION ALL：不去重（快但可能重复）
SELECT name, age FROM students_class1  
UNION ALL
SELECT name, age FROM students_class2;
```

🔄 **对比说明**：
```
UNION的处理过程：
查询1结果 → 临时存储 → 查询2结果 → 合并 → 去重 → 最终结果

UNION ALL的处理过程：
查询1结果 → 查询2结果 → 直接合并 → 最终结果
```

**💡 选择建议**：
- **确定没有重复**或**需要保留重复** → 用 `UNION ALL`（性能更好）
- **可能有重复且需要去重** → 用 `UNION`

### 1.3 联合查询的基本规则


⚠️ **必须遵守的规则**：

```sql
-- ❌ 错误：字段数量不匹配
SELECT name, age FROM students
UNION
SELECT name FROM teachers;  -- 字段数不同

-- ✅ 正确：字段数量匹配
SELECT name, age FROM students
UNION  
SELECT name, age FROM teachers;

-- ✅ 正确：使用NULL补齐字段
SELECT name, age, class FROM students
UNION
SELECT name, age, NULL as class FROM teachers;
```

📊 **规则总结**：
| 规则 | 说明 | 示例 |
|-----|------|-----|
| **字段数量** | 各查询字段数必须相同 | `SELECT a,b UNION SELECT c,d` |
| **字段类型** | 对应位置字段类型要兼容 | `INT` 可以和 `BIGINT` 联合 |
| **字段名称** | 以第一个查询的字段名为准 | 结果集用第一个SELECT的列名 |

---

## 2. 🔄 UNION结果去重机制


### 2.1 去重机制的工作原理


🎯 **核心理解**：
UNION去重是**逐行比较整行数据**，不是单个字段去重

```sql
-- 示例数据演示
-- table1: 
-- | name | age | city |
-- | 张三 | 25  | 北京 |
-- | 李四 | 30  | 上海 |

-- table2:
-- | name | age | city |  
-- | 张三 | 25  | 北京 |  -- 完全相同的行
-- | 张三 | 26  | 北京 |  -- name相同但age不同

SELECT name, age, city FROM table1
UNION
SELECT name, age, city FROM table2;

-- 结果：3行数据
-- | 张三 | 25  | 北京 |  -- 重复行被去掉一行
-- | 李四 | 30  | 上海 |
-- | 张三 | 26  | 北京 |  -- 因为age不同，所以保留
```

### 2.2 去重的性能考量


⚡ **性能影响分析**：
```
UNION去重过程：
1. 执行第一个查询 → 结果存入临时表
2. 执行第二个查询 → 逐行检查是否重复
3. 对所有行进行排序或Hash计算去重
4. 返回最终结果

时间复杂度：O(n log n) 或 O(n) + Hash表空间
```

📈 **性能优化建议**：

```sql
-- 🚀 性能较好：确定无重复时用UNION ALL
SELECT * FROM orders WHERE date >= '2024-01-01'
UNION ALL  
SELECT * FROM orders WHERE date >= '2024-06-01' AND status = 'completed';

-- 🐌 性能较差：大结果集使用UNION
SELECT * FROM large_table1 
UNION
SELECT * FROM large_table2;  -- 可能产生大量重复数据需要去重

-- 🚀 优化方案：先过滤再联合
SELECT DISTINCT * FROM (
    SELECT id, name FROM large_table1 WHERE condition1
    UNION ALL
    SELECT id, name FROM large_table2 WHERE condition2
) AS combined;
```

### 2.3 NULL值在去重中的处理


💡 **NULL值比较规则**：
```sql
-- NULL值在UNION去重中的表现
SELECT 'A', NULL
UNION
SELECT 'A', NULL;  -- 结果：1行，两个NULL被认为相同

SELECT 'A', NULL  
UNION
SELECT 'B', NULL;  -- 结果：2行，不同行的NULL

-- 实际示例
CREATE TABLE test_null1 (name VARCHAR(10), value INT);
CREATE TABLE test_null2 (name VARCHAR(10), value INT);

INSERT INTO test_null1 VALUES ('张三', NULL), ('李四', 100);
INSERT INTO test_null2 VALUES ('张三', NULL), ('王五', NULL);

SELECT * FROM test_null1
UNION  
SELECT * FROM test_null2;

-- 结果：
-- | 张三 | NULL |  -- NULL值相同，被去重
-- | 李四 | 100  |
-- | 王五 | NULL |
```

---

## 3. 📈 联合结果集排序


### 3.1 排序的基本原理


🎯 **核心理解**：
对联合查询结果排序时，ORDER BY只能放在**最后一个查询之后**，作用于**整个联合结果**

```sql
-- ✅ 正确的排序写法
SELECT name, salary FROM employees_2023
UNION ALL
SELECT name, salary FROM employees_2024  
ORDER BY salary DESC, name ASC;

-- ❌ 错误的排序写法  
SELECT name, salary FROM employees_2023 ORDER BY salary
UNION ALL  -- 语法错误！
SELECT name, salary FROM employees_2024;
```

### 3.2 排序字段的引用方式


📋 **字段引用规则**：

```sql
-- 方式1：使用第一个查询的字段名
SELECT emp_name as name, emp_salary as salary FROM table1
UNION
SELECT worker_name, worker_pay FROM table2
ORDER BY name, salary;  -- 使用第一个查询的别名

-- 方式2：使用位置编号（推荐用于复杂场景）
SELECT name, salary, department FROM employees_2023
UNION ALL
SELECT name, salary, department FROM employees_2024
ORDER BY 2 DESC, 1 ASC;  -- 按第2列(salary)降序，第1列(name)升序

-- 方式3：复合字段排序
SELECT 
    CONCAT(first_name, ' ', last_name) as full_name,
    salary,
    hire_date
FROM current_employees
UNION ALL
SELECT 
    CONCAT(first_name, ' ', last_name),
    final_salary,
    termination_date  
FROM former_employees
ORDER BY salary DESC, hire_date ASC;
```

### 3.3 分组排序的高级用法


🔧 **场景应用**：
```sql
-- 需求：查看各部门当前员工和离职员工的工资排名
SELECT 
    department,
    name,
    salary,
    'current' as status,
    ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) as rank_in_dept
FROM current_employees
UNION ALL
SELECT 
    department,
    name, 
    final_salary,
    'former' as status,
    ROW_NUMBER() OVER(PARTITION BY department ORDER BY final_salary DESC) as rank_in_dept
FROM former_employees  
ORDER BY department, status, rank_in_dept;
```

🌟 **排序优化技巧**：

```sql
-- 技巧1：利用索引字段排序
SELECT id, name, created_at FROM orders_2023
UNION ALL  
SELECT id, name, created_at FROM orders_2024
ORDER BY created_at DESC;  -- 如果created_at有索引，排序更快

-- 技巧2：限制排序数据量
SELECT * FROM (
    SELECT name, salary FROM dept_a ORDER BY salary DESC LIMIT 100
    UNION ALL
    SELECT name, salary FROM dept_b ORDER BY salary DESC LIMIT 100  
) as top_employees
ORDER BY salary DESC
LIMIT 50;  -- 先各自取前100，再统一排序取前50
```

---

## 4. 🔗 结果集字段映射


### 4.1 字段映射的基本原理


🌰 **类比理解**：
字段映射就像不同格式的表格对齐：
- 表格A有：姓名、年龄、部门
- 表格B有：员工名、岁数、科室
- 合并时需要建立对应关系：姓名↔员工名、年龄↔岁数、部门↔科室

```sql
-- 基础映射示例
SELECT 
    student_name as name,      -- 统一字段名
    student_age as age,        -- 统一字段名  
    'student' as type          -- 添加标识字段
FROM students
UNION ALL
SELECT 
    teacher_name as name,      -- 映射为相同字段名
    teacher_age as age,        -- 映射为相同字段名
    'teacher' as type          -- 添加标识字段
FROM teachers;
```

### 4.2 数据类型兼容性处理


📊 **类型兼容规则**：

| 第一个查询类型 | 第二个查询类型 | 结果类型 | 是否兼容 |
|-------------|-------------|---------|----------|
| `INT` | `BIGINT` | `BIGINT` | ✅ 兼容 |
| `VARCHAR(10)` | `VARCHAR(20)` | `VARCHAR(20)` | ✅ 兼容 |
| `DATE` | `DATETIME` | `DATETIME` | ✅ 兼容 |
| `INT` | `VARCHAR` | `VARCHAR` | ⚠️ 需注意 |
| `DECIMAL(10,2)` | `INT` | `DECIMAL(10,2)` | ✅ 兼容 |

```sql
-- 类型转换示例
SELECT 
    id,
    CAST(price AS DECIMAL(10,2)) as amount,  -- 统一为DECIMAL类型
    DATE(created_at) as date_only            -- 统一为DATE类型
FROM orders_table1
UNION ALL
SELECT 
    id,
    discount_amount as amount,               -- 已经是DECIMAL类型
    order_date as date_only                  -- 已经是DATE类型  
FROM orders_table2;
```

### 4.3 复杂字段映射策略


🔧 **实际应用场景**：

```sql
-- 场景：合并不同系统的用户数据
SELECT 
    user_id as id,
    CONCAT(first_name, ' ', last_name) as full_name,
    email,
    phone_number as contact,
    registration_date as join_date,
    'system_a' as source
FROM system_a_users
UNION ALL
SELECT 
    member_id as id,  
    member_name as full_name,
    email_address as email,
    mobile as contact,
    signup_time as join_date,
    'system_b' as source
FROM system_b_members
UNION ALL
SELECT 
    customer_id as id,
    customer_name as full_name, 
    contact_email as email,
    COALESCE(phone, mobile_phone) as contact,  -- 优先选择phone，没有就用mobile_phone
    created_date as join_date,
    'system_c' as source
FROM system_c_customers;
```

⚡ **字段映射最佳实践**：

```sql
-- 最佳实践：使用CTE提高可读性
WITH normalized_users AS (
    -- 标准化系统A的数据
    SELECT 
        user_id as id,
        UPPER(TRIM(username)) as username,  -- 统一大写并去空格
        COALESCE(email, '') as email,       -- 空值处理
        CASE 
            WHEN status = 1 THEN 'active'
            WHEN status = 0 THEN 'inactive' 
            ELSE 'unknown'
        END as status
    FROM system_a_users
    
    UNION ALL
    
    -- 标准化系统B的数据  
    SELECT 
        member_id as id,
        UPPER(TRIM(login_name)) as username,
        COALESCE(email_addr, '') as email,
        CASE
            WHEN is_active = 'Y' THEN 'active'
            WHEN is_active = 'N' THEN 'inactive'
            ELSE 'unknown' 
        END as status
    FROM system_b_members
)
SELECT * FROM normalized_users 
ORDER BY username;
```

---

## 5. 🔵 NULL值联合处理


### 5.1 NULL值的基本行为


💡 **核心理解**：
NULL值在联合查询中有特殊的行为规则，理解这些规则对正确处理联合结果很重要

```sql
-- NULL值比较示例
SELECT 'A' as col1, NULL as col2
UNION
SELECT 'A' as col1, NULL as col2;  -- 结果：1行（两个NULL被视为相同）

SELECT 'A' as col1, NULL as col2
UNION  
SELECT 'A' as col1, 0 as col2;     -- 结果：2行（NULL和0不同）
```

🔄 **NULL值处理流程**：
```
联合查询中NULL值处理：
1. NULL与NULL比较 → 视为相同（用于去重）
2. NULL与任何非NULL值比较 → 视为不同  
3. 排序时NULL值通常排在最前或最后（数据库相关）
```

### 5.2 NULL值的实际处理策略


📋 **常见处理策略**：

```sql
-- 策略1：NULL值替换为默认值
SELECT 
    name,
    COALESCE(phone, '无联系方式') as contact_info,
    COALESCE(email, '无邮箱') as email_info
FROM customers_table1
UNION ALL
SELECT 
    name,
    COALESCE(mobile, '无联系方式') as contact_info, 
    COALESCE(email_address, '无邮箱') as email_info
FROM customers_table2;

-- 策略2：NULL值标识处理
SELECT 
    product_name,
    price,
    CASE 
        WHEN discount IS NULL THEN '无折扣'
        ELSE CONCAT(discount * 100, '%')
    END as discount_info
FROM products_online
UNION ALL  
SELECT 
    product_name,
    price,
    CASE
        WHEN discount_rate IS NULL THEN '无折扣' 
        ELSE CONCAT(discount_rate, '%')
    END as discount_info
FROM products_offline;
```

### 5.3 NULL值排序处理


🎯 **排序中的NULL值**：

```sql
-- MySQL中NULL值排序（默认NULL在最前）
SELECT name, age FROM students
UNION ALL
SELECT name, age FROM teachers  
ORDER BY age ASC;  -- NULL值出现在最前面

-- 控制NULL值排序位置
SELECT name, age FROM students
UNION ALL
SELECT name, age FROM teachers
ORDER BY 
    CASE WHEN age IS NULL THEN 1 ELSE 0 END,  -- NULL值排在最后
    age ASC;

-- 或者使用NULLS LAST（某些数据库支持）
SELECT name, age FROM students  
UNION ALL
SELECT name, age FROM teachers
ORDER BY age ASC NULLS LAST;  -- PostgreSQL、Oracle支持
```

### 5.4 NULL值聚合处理


⚡ **NULL值在聚合中的行为**：

```sql
-- NULL值在聚合函数中被忽略
WITH combined_data AS (
    SELECT department, salary FROM employees_2023
    UNION ALL
    SELECT department, salary FROM employees_2024  
)
SELECT 
    department,
    COUNT(*) as total_records,           -- 包括NULL的记录数
    COUNT(salary) as non_null_salaries,  -- 不包括NULL的记录数 
    AVG(salary) as avg_salary,           -- NULL值被忽略
    MIN(salary) as min_salary,           -- NULL值被忽略
    MAX(salary) as max_salary            -- NULL值被忽略
FROM combined_data
GROUP BY department;
```

💻 **实际应用示例**：

```sql
-- 场景：合并多个系统的销售数据，处理缺失值
WITH unified_sales AS (
    SELECT 
        salesperson_name as name,
        sale_amount,
        COALESCE(commission_rate, 0.05) as commission,  -- 默认5%提成
        sale_date,
        'system_a' as source
    FROM sales_system_a
    WHERE sale_date >= '2024-01-01'
    
    UNION ALL
    
    SELECT 
        agent_name as name,
        amount as sale_amount, 
        COALESCE(commission_pct / 100, 0.03) as commission,  -- 转换百分比，默认3%
        transaction_date as sale_date,
        'system_b' as source  
    FROM sales_system_b
    WHERE transaction_date >= '2024-01-01'
)
SELECT 
    name,
    SUM(sale_amount) as total_sales,
    AVG(commission) as avg_commission_rate,
    COUNT(*) as transaction_count,
    source
FROM unified_sales 
WHERE sale_amount IS NOT NULL  -- 过滤掉异常的NULL销售额
GROUP BY name, source
ORDER BY total_sales DESC;
```

---

## 6. 📄 联合结果分页


### 6.1 分页的基本实现


🌰 **分页原理类比**：
联合查询分页就像翻看合订本杂志：
- 先把所有期刊按顺序合并
- 再从合并后的内容中截取指定页码的内容
- 需要知道总页数来控制翻页

```sql
-- 基本分页实现
SELECT name, salary, department FROM employees_2023
UNION ALL  
SELECT name, salary, department FROM employees_2024
ORDER BY salary DESC
LIMIT 20 OFFSET 0;    -- 第1页，每页20条

-- 第2页
SELECT name, salary, department FROM employees_2023
UNION ALL
SELECT name, salary, department FROM employees_2024  
ORDER BY salary DESC
LIMIT 20 OFFSET 20;   -- 第2页，跳过前20条
```

### 6.2 高效分页策略


⚡ **性能优化的分页方法**：

```sql
-- 方法1：使用子查询先限制再联合（适合数据量大的情况）
(SELECT name, salary, hire_date FROM employees_2023 
 ORDER BY salary DESC LIMIT 50)  -- 各表先取前50
UNION ALL
(SELECT name, salary, hire_date FROM employees_2024
 ORDER BY salary DESC LIMIT 50)  -- 各表先取前50
ORDER BY salary DESC  
LIMIT 20 OFFSET 0;  -- 从联合结果中取分页数据

-- 方法2：使用窗口函数进行分页标记
WITH ranked_employees AS (
    SELECT 
        name, salary, department,
        ROW_NUMBER() OVER(ORDER BY salary DESC) as row_num
    FROM (
        SELECT name, salary, department FROM employees_2023
        UNION ALL
        SELECT name, salary, department FROM employees_2024
    ) as all_employees
)
SELECT name, salary, department 
FROM ranked_employees
WHERE row_num BETWEEN 21 AND 40;  -- 第2页（21-40行）
```

### 6.3 分页总数计算


📊 **获取总记录数**：

```sql
-- 方法1：单独查询总数（推荐）
-- 查询总数
SELECT COUNT(*) as total_count
FROM (
    SELECT name FROM employees_2023
    UNION  -- 使用UNION去重计算准确总数
    SELECT name FROM employees_2024
) as unique_employees;

-- 查询分页数据
SELECT name, salary, department FROM employees_2023
UNION ALL
SELECT name, salary, department FROM employees_2024
ORDER BY salary DESC
LIMIT 20 OFFSET 0;

-- 方法2：一次查询获取总数和数据（MySQL 8.0+）
WITH all_data AS (
    SELECT name, salary, department FROM employees_2023
    UNION ALL
    SELECT name, salary, department FROM employees_2024
),
paginated AS (
    SELECT 
        *,
        COUNT(*) OVER() as total_count  -- 窗口函数获取总数
    FROM all_data
    ORDER BY salary DESC
    LIMIT 20 OFFSET 0
)
SELECT * FROM paginated;
```

### 6.4 游标分页优化


🚀 **大数据量分页优化**：

```sql
-- 游标分页（适合大数据量场景）
-- 第一页
SELECT name, salary, hire_date FROM employees_2023
UNION ALL
SELECT name, salary, hire_date FROM employees_2024
ORDER BY salary DESC, hire_date DESC
LIMIT 20;

-- 后续页：使用上一页最后一条记录作为游标
SELECT name, salary, hire_date FROM employees_2023  
UNION ALL
SELECT name, salary, hire_date FROM employees_2024
WHERE (salary < 8000) OR (salary = 8000 AND hire_date < '2023-06-15')  -- 游标条件
ORDER BY salary DESC, hire_date DESC
LIMIT 20;
```

💡 **分页最佳实践**：

```sql
-- 实际项目中的分页模板
-- 参数：page_size = 20, page_number = 2
SET @page_size = 20;
SET @page_number = 2; 
SET @offset = (@page_number - 1) * @page_size;

-- 主查询
SELECT 
    employee_id,
    full_name,
    salary,
    department,
    'current' as status
FROM current_employees
WHERE salary IS NOT NULL

UNION ALL

SELECT 
    employee_id,
    full_name, 
    final_salary as salary,
    department,
    'former' as status
FROM former_employees  
WHERE final_salary IS NOT NULL

ORDER BY salary DESC, full_name ASC
LIMIT @page_size OFFSET @offset;
```

---

## 7. 🌊 结果集流式处理


### 7.1 流式处理的概念


🌊 **流式处理类比**：
流式处理就像水流通过管道：
- 不是等所有水装满池子再使用
- 而是边流边处理，实时消费
- 内存占用小，响应及时

```
传统处理：数据库 → 全部加载到内存 → 处理 → 返回结果
流式处理：数据库 → 逐批读取 → 即时处理 → 即时返回
```

### 7.2 流式处理的应用场景


🎯 **适用场景**：

```sql
-- 场景1：大数据量报表生成
-- 传统方式：一次性查询可能内存溢出
SELECT customer_name, order_amount, order_date
FROM orders_2023
UNION ALL
SELECT customer_name, order_amount, order_date  
FROM orders_2024
ORDER BY order_date;  -- 可能有几百万条记录

-- 流式处理：分批处理
-- 批次1：2023年第一季度
SELECT customer_name, order_amount, order_date
FROM orders_2023 
WHERE order_date BETWEEN '2023-01-01' AND '2023-03-31'
UNION ALL
SELECT customer_name, order_amount, order_date
FROM orders_2024
WHERE order_date BETWEEN '2023-01-01' AND '2023-03-31'  
ORDER BY order_date;

-- 批次2：2023年第二季度... 以此类推
```

### 7.3 流式处理实现策略


🔧 **实现方法**：

```sql
-- 方法1：基于时间窗口的流式处理
-- 按月份分批处理数据
DELIMITER $$
CREATE PROCEDURE ProcessUnionDataByMonth(
    IN start_date DATE,
    IN end_date DATE
)  
BEGIN
    DECLARE current_date DATE DEFAULT start_date;
    DECLARE next_month DATE;
    
    WHILE current_date <= end_date DO
        SET next_month = DATE_ADD(current_date, INTERVAL 1 MONTH);
        
        -- 处理当月数据
        SELECT 
            customer_id,
            SUM(amount) as monthly_total,
            COUNT(*) as transaction_count,
            current_date as process_month
        FROM (
            SELECT customer_id, amount FROM transactions_table1 
            WHERE DATE(created_at) >= current_date 
              AND DATE(created_at) < next_month
            UNION ALL
            SELECT customer_id, amount FROM transactions_table2
            WHERE DATE(created_at) >= current_date 
              AND DATE(created_at) < next_month
        ) as monthly_data
        GROUP BY customer_id;
        
        SET current_date = next_month;
    END WHILE;
END$$
DELIMITER ;
```

### 7.4 流式处理优化技巧


⚡ **性能优化要点**：

```sql
-- 技巧1：使用索引优化分批查询
-- 确保分批字段有索引
CREATE INDEX idx_created_date ON transactions_table1(created_at);
CREATE INDEX idx_created_date ON transactions_table2(created_at);

-- 技巧2：控制批次大小
-- 每批处理1万条记录
WITH batch_data AS (
    SELECT *, ROW_NUMBER() OVER(ORDER BY id) as rn
    FROM (
        SELECT id, customer_name, amount FROM sales_2023
        UNION ALL  
        SELECT id, customer_name, amount FROM sales_2024
    ) as all_sales
)
SELECT customer_name, amount
FROM batch_data  
WHERE rn BETWEEN 1 AND 10000  -- 第一批：1-10000
ORDER BY id;

-- 第二批：10001-20000，依此类推
```

🌟 **应用程序中的流式处理**：

```python
# Python示例：流式处理联合查询结果
import mysql.connector
from mysql.connector import cursor

def stream_union_results():
    connection = mysql.connector.connect(
        host='localhost',
        user='username', 
        password='password',
        database='your_db'
    )
    
    # 使用游标进行流式查询
    cursor = connection.cursor(buffered=False)  # 不缓冲，流式读取
    
    query = """
    SELECT customer_name, order_amount, order_date
    FROM orders_2023
    UNION ALL
    SELECT customer_name, order_amount, order_date
    FROM orders_2024  
    ORDER BY order_date
    """
    
    cursor.execute(query)
    
    batch_size = 1000
    batch = []
    
    # 流式处理结果
    for row in cursor:
        batch.append(row)
        
        if len(batch) >= batch_size:
            # 处理一批数据
            process_batch(batch)
            batch = []  # 清空批次
    
    # 处理最后一批
    if batch:
        process_batch(batch)
    
    cursor.close()
    connection.close()

def process_batch(batch):
    # 处理一批数据的逻辑
    for row in batch:
        # 实际业务处理
        print(f"处理订单：{row[0]}, 金额：{row[1]}")
```

### 7.5 流式处理监控


📊 **处理进度监控**：

```sql
-- 创建处理进度跟踪表
CREATE TABLE processing_progress (
    batch_id INT PRIMARY KEY,
    start_date DATE,
    end_date DATE, 
    total_records INT,
    processed_records INT,
    status ENUM('pending', 'processing', 'completed', 'error'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 记录处理进度的存储过程示例
DELIMITER $$
CREATE PROCEDURE ProcessWithProgress(
    IN batch_start DATE,
    IN batch_end DATE,
    IN batch_id INT
)
BEGIN 
    DECLARE total_count INT DEFAULT 0;
    DECLARE processed_count INT DEFAULT 0;
    
    -- 计算总记录数
    SELECT COUNT(*) INTO total_count 
    FROM (
        SELECT id FROM table1 WHERE date_col BETWEEN batch_start AND batch_end
        UNION ALL
        SELECT id FROM table2 WHERE date_col BETWEEN batch_start AND batch_end  
    ) as batch_data;
    
    -- 更新进度
    INSERT INTO processing_progress 
    (batch_id, start_date, end_date, total_records, processed_records, status)
    VALUES (batch_id, batch_start, batch_end, total_count, 0, 'processing');
    
    -- 实际处理逻辑...
    -- 定期更新 processed_records
    
    -- 处理完成
    UPDATE processing_progress 
    SET processed_records = total_records, status = 'completed'
    WHERE batch_id = batch_id;
END$$
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 联合查询本质：将多个SELECT结果合并为一个结果集
🔸 UNION vs UNION ALL：去重 vs 不去重的性能和结果差异
🔸 去重机制：逐行完整比较，不是单字段去重
🔸 字段映射：数量必须相同，类型必须兼容
🔸 排序规则：ORDER BY只能放在最后，作用于整个结果
🔸 NULL值处理：NULL与NULL相等，NULL与非NULL不等
```

### 8.2 关键理解要点


**🔹 性能优化思路**
```
选择合适的联合方式：
• 确定无重复 → UNION ALL（性能更好）
• 可能有重复且需去重 → UNION

分页优化策略：
• 小数据量 → 直接LIMIT OFFSET
• 大数据量 → 子查询限制 + 游标分页
• 超大数据量 → 流式处理分批
```

**🔹 实际应用价值**
```
业务场景应用：
• 多系统数据整合：统一不同系统的用户信息
• 历史数据合并：当前数据与历史数据的统一查询  
• 分库分表查询：将分散的数据重新组合
• 报表数据生成：多表数据的统一展示
```

**🔹 常见问题解决**
```
字段不匹配：
• 使用NULL补齐缺失字段
• 使用CAST转换数据类型
• 使用别名统一字段名

性能问题：
• 避免不必要的UNION（改用UNION ALL）
• 合理使用索引支持ORDER BY
• 大数据量考虑分批处理

NULL值处理：
• 使用COALESCE提供默认值  
• 使用CASE语句进行条件转换
• 注意NULL值在排序中的位置
```

### 8.3 最佳实践建议


**💡 代码编写规范**：
```sql
-- 推荐的代码格式
WITH standardized_data AS (
    -- 数据标准化处理
    SELECT 
        TRIM(name) as name,
        COALESCE(age, 0) as age,
        'table1' as source
    FROM table1
    WHERE condition1
    
    UNION ALL  -- 明确是否需要去重
    
    SELECT 
        TRIM(name) as name,
        COALESCE(age, 0) as age, 
        'table2' as source
    FROM table2
    WHERE condition2
)
SELECT * FROM standardized_data
ORDER BY name, age  -- 明确排序字段
LIMIT 100;  -- 控制结果集大小
```

**⚡ 性能监控要点**：
```
关注指标：
• 查询执行时间
• 内存使用量  
• 临时表大小
• 结果集返回时间

优化检查：
• EXPLAIN查看执行计划
• 是否合理使用了索引
• 是否产生了不必要的排序
• 是否可以减少结果集大小
```

**🔧 调试技巧**：
```sql
-- 分步调试联合查询
-- 1. 先分别执行各个子查询
SELECT COUNT(*) FROM table1 WHERE condition;
SELECT COUNT(*) FROM table2 WHERE condition;

-- 2. 检查联合后的数量变化
SELECT COUNT(*) FROM (
    SELECT id FROM table1 WHERE condition
    UNION ALL
    SELECT id FROM table2 WHERE condition  
) as combined;

-- 3. 检查去重效果
SELECT COUNT(*) FROM (
    SELECT id FROM table1 WHERE condition
    UNION  -- 注意这里用UNION
    SELECT id FROM table2 WHERE condition
) as deduplicated;
```

**核心记忆口诀**：
- 联合查询合多表，字段数量类型齐
- UNION去重UNION ALL不去重，性能差异要牢记  
- 排序只能放最后，字段映射要对齐
- NULL值处理有规则，分页流式解难题