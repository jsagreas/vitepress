---
title: 6、UNION查询索引利用策略
---
## 📚 目录

1. [UNION查询索引基础](#1-union查询索引基础)
2. [UNION子查询索引设计](#2-union子查询索引设计)
3. [联合查询索引选择机制](#3-联合查询索引选择机制)
4. [各分支索引优化策略](#4-各分支索引优化策略)
5. [UNION索引合并技术](#5-union索引合并技术)
6. [索引覆盖联合查询](#6-索引覆盖联合查询)
7. [联合查询索引统计](#7-联合查询索引统计)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ UNION查询索引基础


### 1.1 UNION查询的索引挑战


**🔸 什么是UNION查询的索引问题**
```
通俗理解：UNION就像"合并多个搜索结果"

生活类比：在图书馆找书
❌ 普通方式：先在文学区找，再在历史区找，最后手动合并
✅ UNION方式：同时在两个区域搜索，系统自动合并结果

技术挑战：
• 每个子查询都需要独立的索引优化
• 合并结果时可能产生额外开销
• 索引选择策略影响整体性能
```

**📊 UNION查询执行流程**
```
UNION查询执行过程：

第1步：分别执行各子查询
   ↓
SELECT * FROM orders WHERE status='pending'    ← 子查询1，需要status索引
   ↓
SELECT * FROM orders WHERE amount > 1000       ← 子查询2，需要amount索引
   ↓
第2步：合并结果集
   ↓
第3步：去重操作(UNION) 或 保留重复(UNION ALL)
   ↓
第4步：返回最终结果

关键点：每个子查询的索引效率直接影响整体性能
```

### 1.2 UNION索引问题的根本原因


**⚠️ 常见索引问题**
```
🔸 子查询索引不均衡
问题：有的子查询有合适索引，有的没有
结果：整体查询被最慢的子查询拖累

🔸 索引选择不当
问题：数据库选择了错误的索引
结果：本可以很快的查询变得很慢

🔸 临时表开销
问题：合并大结果集需要创建临时表
结果：内存不足时使用磁盘，性能急剧下降
```

**📈 性能影响示例**
```sql
-- 性能差异巨大的UNION查询
SELECT customer_id, order_date FROM orders WHERE status = 'pending'    -- 10ms (有status索引)
UNION
SELECT customer_id, order_date FROM orders WHERE amount > 10000;       -- 5000ms (没有amount索引)

总执行时间：约5010ms (被最慢子查询拖累)

-- 优化后
SELECT customer_id, order_date FROM orders WHERE status = 'pending'    -- 10ms (有status索引)
UNION
SELECT customer_id, order_date FROM orders WHERE amount > 10000;       -- 15ms (添加amount索引后)

总执行时间：约25ms (性能提升200倍)
```

### 1.3 索引对UNION查询的影响机制


**🔍 索引影响分析**
```
影响因素：

1️⃣ 子查询执行效率
• 有索引：Index Seek，快速定位
• 无索引：Table Scan，全表扫描

2️⃣ 结果集大小
• 索引过滤效果好：小结果集，合并快
• 索引过滤效果差：大结果集，合并慢

3️⃣ 内存使用
• 小结果集：内存中合并
• 大结果集：磁盘临时文件，性能下降

4️⃣ CPU开销
• UNION：需要去重，CPU密集
• UNION ALL：无需去重，CPU友好
```

---

## 2. 🛠️ UNION子查询索引设计


### 2.1 单子查询索引设计原则


**🎯 索引设计核心原则**
```
🔸 选择性原则
• 为过滤条件创建高选择性索引
• 优先考虑WHERE条件中的列
• 避免为低选择性列单独建索引

🔸 覆盖性原则  
• 索引包含查询需要的所有列
• 减少回表操作，提升性能
• 特别适用于SELECT字段较少的情况

🔸 顺序性原则
• 索引列的顺序影响使用效果
• 等值条件放前面，范围条件放后面
• 考虑查询模式的多样性
```

**📋 索引设计实战示例**
```sql
-- 场景：电商系统的订单查询
-- 需求：查询不同状态和金额范围的订单

-- 子查询1：按状态查询
SELECT order_id, customer_id, order_date, amount 
FROM orders 
WHERE status IN ('pending', 'processing');

-- 为子查询1设计索引
CREATE INDEX idx_orders_status_covering 
ON orders(status, order_id, customer_id, order_date, amount);
-- 解释：status作为过滤条件放首位，其他SELECT字段作为覆盖列

-- 子查询2：按金额范围查询  
SELECT order_id, customer_id, order_date, amount
FROM orders
WHERE amount BETWEEN 1000 AND 5000;

-- 为子查询2设计索引
CREATE INDEX idx_orders_amount_covering
ON orders(amount, order_id, customer_id, order_date);
-- 解释：amount用于范围过滤，其他字段避免回表
```

### 2.2 复合索引设计策略


**🔧 多条件索引优化**
```sql
-- 复杂子查询索引设计
-- 子查询：多条件过滤
SELECT order_id, customer_id, total_amount
FROM orders
WHERE status = 'completed' 
  AND order_date >= '2024-01-01'
  AND customer_type = 'VIP';

-- 索引设计分析
-- 方案1：单列索引组合（不推荐）
CREATE INDEX idx_status ON orders(status);
CREATE INDEX idx_date ON orders(order_date);
CREATE INDEX idx_customer_type ON orders(customer_type);
-- 问题：MySQL只能用其中一个索引，其他条件需要额外过滤

-- 方案2：复合索引（推荐）
CREATE INDEX idx_orders_composite
ON orders(status, customer_type, order_date, order_id, customer_id, total_amount);
-- 优势：一个索引满足所有查询需求
```

**📊 复合索引列顺序决策**

| 排序原则 | **说明** | **示例** |
|---------|---------|---------|
| 🎯 **等值优先** | `等值条件放在范围条件前` | `status = 'xx' 在 date > 'xx' 前` |
| 📈 **选择性优先** | `高选择性列放在前面` | `订单号在状态列前` |
| 🔍 **查询频率优先** | `常用查询条件放前面` | `经常按状态查询则status优先` |
| 📦 **覆盖性考虑** | `SELECT列作为后续覆盖列` | `查询字段追加到索引末尾` |

### 2.3 特殊场景索引设计


**🌟 时间分区场景索引**
```sql
-- 场景：按时间分区的历史数据查询
-- 当前订单表
SELECT * FROM orders_current WHERE status = 'active';
UNION ALL
-- 历史订单表  
SELECT * FROM orders_history WHERE create_date > '2024-01-01';

-- 索引设计
-- 当前表索引：主要按状态查询
CREATE INDEX idx_current_status ON orders_current(status, order_id, create_date);

-- 历史表索引：主要按时间查询
CREATE INDEX idx_history_date ON orders_history(create_date, status, order_id);
-- 注意：历史表以时间为主要过滤条件，所以create_date放首位
```

**🎨 不同表结构的索引协调**
```sql
-- 场景：新老系统数据合并查询
-- 新系统表
SELECT customer_id, order_amount, status FROM orders_new 
WHERE status IN ('paid', 'shipped');
UNION ALL
-- 老系统表（字段名不同）
SELECT client_id, amount, order_status FROM orders_old
WHERE order_status IN ('paid', 'shipped');

-- 协调索引设计
-- 新表索引
CREATE INDEX idx_new_status ON orders_new(status, customer_id, order_amount);

-- 老表索引（对应相同的查询模式）
CREATE INDEX idx_old_status ON orders_old(order_status, client_id, amount);
-- 保持索引结构的一致性，便于查询优化器处理
```

---

## 3. ⚙️ 联合查询索引选择机制


### 3.1 数据库索引选择过程


**🔸 索引选择决策流程**
```
查询优化器的索引选择过程：

Step 1: 分析WHERE条件
   ↓
Step 2: 识别可用索引
   ↓  
Step 3: 估算每个索引的成本
   ↓
Step 4: 选择成本最低的索引
   ↓
Step 5: 执行查询计划

关键因素：
• 索引选择性（过滤效果）
• 索引覆盖程度（是否需要回表）  
• 数据分布情况（统计信息）
• 索引维护成本（更新开销）
```

**📊 索引选择成本评估**
```sql
-- 查看MySQL的索引选择过程
EXPLAIN FORMAT=JSON 
SELECT order_id, customer_id FROM orders WHERE status = 'pending'
UNION ALL
SELECT order_id, customer_id FROM orders WHERE amount > 1000;

-- 关键信息解读：
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "234.50"        -- 第一个子查询成本
    },
    "table": {
      "possible_keys": ["idx_status", "idx_status_amount"],  -- 可选索引
      "key": "idx_status",          -- 实际选择的索引
      "key_length": "62",           -- 使用的索引长度
      "rows_examined": 1500,        -- 预估扫描行数
      "filtered": 100.00            -- 过滤百分比
    }
  }
}
```

### 3.2 索引选择优化技巧


**🎯 强制索引提示**
```sql
-- 当优化器选择错误索引时，可以使用索引提示

-- 问题查询：优化器选择了错误的索引
SELECT * FROM orders WHERE status = 'pending' AND amount > 500;

-- 解决方案1：USE INDEX 提示
SELECT * FROM orders USE INDEX(idx_status_amount) 
WHERE status = 'pending' AND amount > 500;

-- 解决方案2：FORCE INDEX 强制使用
SELECT * FROM orders FORCE INDEX(idx_amount_status)
WHERE status = 'pending' AND amount > 500;

-- 在UNION查询中的应用
SELECT * FROM orders USE INDEX(idx_status) WHERE status = 'pending'
UNION ALL  
SELECT * FROM orders USE INDEX(idx_amount) WHERE amount > 1000;
```

**⚡ 统计信息对索引选择的影响**
```sql
-- 更新表统计信息，帮助优化器做出正确选择
-- MySQL
ANALYZE TABLE orders;

-- 查看索引统计信息
SELECT 
    TABLE_NAME,
    INDEX_NAME, 
    COLUMN_NAME,
    CARDINALITY,          -- 索引基数（不同值的数量）
    SUB_PART
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_NAME = 'orders' 
ORDER BY INDEX_NAME, SEQ_IN_INDEX;

-- 基数影响索引选择：
-- 高基数索引 → 选择性好 → 优先被选择
-- 低基数索引 → 选择性差 → 较少被选择
```

### 3.3 多表UNION的索引协调


**🔗 跨表索引一致性**
```sql
-- 场景：不同表的UNION查询需要协调索引设计
-- 当前订单表
CREATE TABLE orders_current (
    order_id INT PRIMARY KEY,
    customer_id INT,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    create_date DATE,
    INDEX idx_status_customer(status, customer_id),
    INDEX idx_amount_date(amount, create_date)
);

-- 历史订单表  
CREATE TABLE orders_history (
    order_id INT PRIMARY KEY,
    customer_id INT,
    status VARCHAR(20),
    amount DECIMAL(10,2), 
    create_date DATE,
    -- 保持相同的索引结构
    INDEX idx_status_customer(status, customer_id),
    INDEX idx_amount_date(amount, create_date)
);

-- UNION查询将获得一致的性能
SELECT customer_id, amount FROM orders_current WHERE status = 'active'
UNION ALL
SELECT customer_id, amount FROM orders_history WHERE status = 'active';
```

---

## 4. 🔧 各分支索引优化策略


### 4.1 分支索引独立优化


**🔸 分支特性分析**
```
UNION各分支的独立优化原则：

🎯 分支1：高频查询分支
特点：查询频繁，对性能要求高
策略：创建专门的覆盖索引，优化到极致

🎯 分支2：低频查询分支  
特点：偶尔查询，但数据量大
策略：创建基础索引，避免全表扫描即可

🎯 分支3：复杂条件分支
特点：多个WHERE条件，逻辑复杂
策略：创建复合索引，优化复合条件过滤
```

**📈 分支性能差异处理**
```sql
-- 示例：电商订单的多分支查询
-- 分支1：最近订单（高频查询，性能要求高）
SELECT order_id, customer_id, amount, order_date 
FROM orders 
WHERE order_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)
  AND status IN ('pending', 'processing')

UNION ALL

-- 分支2：大额订单（低频查询，但重要）  
SELECT order_id, customer_id, amount, order_date
FROM orders
WHERE amount > 10000 
  AND status = 'completed'

UNION ALL

-- 分支3：VIP客户订单（复杂条件）
SELECT order_id, customer_id, amount, order_date
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.customer_level = 'VIP' 
  AND o.status != 'cancelled';
```

**🛠️ 针对性索引设计**
```sql
-- 为上述查询设计专门的索引

-- 分支1索引：时间+状态的覆盖索引
CREATE INDEX idx_recent_orders 
ON orders(order_date, status, order_id, customer_id, amount)
WHERE order_date >= DATE_SUB(NOW(), INTERVAL 30 DAY);
-- 使用部分索引，只索引最近数据，减少索引大小

-- 分支2索引：金额+状态的覆盖索引  
CREATE INDEX idx_high_amount_orders
ON orders(amount, status, order_id, customer_id, order_date)
WHERE amount > 5000;
-- 部分索引，只索引大额订单

-- 分支3索引：客户连接优化
CREATE INDEX idx_customer_status ON orders(customer_id, status);
CREATE INDEX idx_customer_level ON customers(customer_level, id);
-- 优化JOIN操作的索引
```

### 4.2 负载均衡索引策略


**⚖️ 分支负载分析**
```python
# 使用Python分析各分支的负载情况
def analyze_union_branch_load():
    """
    分析UNION各分支的查询负载
    """
    import mysql.connector
    
    # 执行各分支查询，收集性能数据
    branches = {
        'recent_orders': {
            'query': "SELECT COUNT(*) FROM orders WHERE order_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)",
            'frequency': 'high',  # 查询频率
            'avg_rows': 0,        # 平均返回行数
            'avg_time': 0         # 平均执行时间
        },
        'high_amount': {
            'query': "SELECT COUNT(*) FROM orders WHERE amount > 10000",
            'frequency': 'medium',
            'avg_rows': 0,
            'avg_time': 0
        },
        'vip_orders': {
            'query': "SELECT COUNT(*) FROM orders o JOIN customers c ON o.customer_id = c.id WHERE c.customer_level = 'VIP'",
            'frequency': 'low',
            'avg_rows': 0,
            'avg_time': 0
        }
    }
    
    # 收集每个分支的性能数据
    for branch_name, branch_info in branches.items():
        # 执行多次查询，计算平均值
        total_time = 0
        for i in range(10):
            start_time = time.time()
            cursor.execute(branch_info['query'])
            result = cursor.fetchone()
            end_time = time.time()
            
            branch_info['avg_rows'] = result[0]
            total_time += (end_time - start_time)
        
        branch_info['avg_time'] = total_time / 10
        
        # 计算性能权重
        branch_info['weight'] = calculate_performance_weight(
            branch_info['frequency'],
            branch_info['avg_rows'], 
            branch_info['avg_time']
        )
    
    return branches

def calculate_performance_weight(frequency, rows, time):
    """计算分支性能权重，决定索引优化优先级"""
    freq_weight = {'high': 3, 'medium': 2, 'low': 1}[frequency]
    row_weight = min(rows / 1000, 10)  # 行数权重，最高10
    time_weight = min(time * 100, 10)  # 时间权重，最高10
    
    return freq_weight * 0.5 + row_weight * 0.3 + time_weight * 0.2
```

### 4.3 自适应索引优化


**🤖 动态索引调整策略**
```sql
-- 基于查询模式的动态索引创建

-- 1. 监控各分支的查询模式
CREATE TABLE query_performance_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    branch_name VARCHAR(50),
    execution_time DECIMAL(10,4),
    rows_examined INT,
    rows_returned INT,
    index_used VARCHAR(100),
    query_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 2. 创建性能监控存储过程
DELIMITER $$
CREATE PROCEDURE monitor_union_performance()
BEGIN
    DECLARE recent_avg_time DECIMAL(10,4);
    DECLARE high_amount_avg_time DECIMAL(10,4);
    DECLARE vip_avg_time DECIMAL(10,4);
    
    -- 分析最近7天的查询性能
    SELECT AVG(execution_time) INTO recent_avg_time
    FROM query_performance_log 
    WHERE branch_name = 'recent_orders' 
    AND query_timestamp >= DATE_SUB(NOW(), INTERVAL 7 DAY);
    
    -- 如果性能下降，建议创建新索引
    IF recent_avg_time > 100 THEN  -- 100ms阈值
        INSERT INTO index_suggestions (suggestion, priority, reason)
        VALUES (
            'CREATE INDEX idx_recent_optimized ON orders(order_date DESC, status, customer_id)',
            'HIGH',
            CONCAT('Recent orders branch avg time: ', recent_avg_time, 'ms')
        );
    END IF;
    
    -- 类似地分析其他分支...
END$$
DELIMITER ;

-- 3. 定期执行监控
-- 设置定时任务每小时执行一次
```

---

## 5. 🔗 UNION索引合并技术


### 5.1 索引合并的基本概念


**🔸 什么是索引合并**
```
通俗理解：索引合并就像"多个通道同时搜索，最后汇总结果"

生活类比：在商场找商品
❌ 传统方式：只在一个楼层找，找完为止
✅ 索引合并：同时在多个楼层找，把找到的都收集起来

技术实现：
• MySQL可以使用多个单列索引
• 通过交集、并集操作合并索引结果
• 适用于复杂WHERE条件的查询
```

**📊 索引合并类型**

| 合并类型 | **使用场景** | **操作方式** | **性能特点** |
|---------|-------------|-------------|-------------|
| 🔗 **intersection** | `AND条件连接` | `取交集` | `减少结果集，性能好` |
| ⚡ **union** | `OR条件连接` | `取并集` | `增加结果集，需要去重` |
| 🎯 **sort-union** | `范围条件OR` | `排序后合并` | `处理范围查询的OR` |

### 5.2 UNION查询中的索引合并应用


**🔧 单个子查询的索引合并**
```sql
-- 示例：复杂条件的子查询
SELECT order_id, customer_id, amount 
FROM orders 
WHERE (status = 'pending' OR status = 'processing')
  AND (amount > 1000 AND amount < 5000)
  AND customer_id IN (SELECT id FROM vip_customers);

-- 可能的索引合并策略：
-- 索引1: idx_status(status)
-- 索引2: idx_amount(amount) 
-- 索引3: idx_customer(customer_id)

-- MySQL可能的执行计划：
-- 1. 使用status索引找到pending和processing的记录
-- 2. 使用amount索引找到1000-5000范围的记录  
-- 3. 使用customer_id索引找到VIP客户的记录
-- 4. 对三个结果集求交集
```

**📈 索引合并性能分析**
```sql
-- 查看索引合并的执行计划
EXPLAIN FORMAT=JSON
SELECT * FROM orders 
WHERE status IN ('pending', 'processing') OR amount > 5000;

-- 关键信息：
{
  "table": {
    "access_type": "index_merge",           -- 使用索引合并
    "key": "union(idx_status,idx_amount)",  -- 合并的索引
    "key_length": "62,5",                   -- 各索引使用长度
    "rows_examined": 1250,                  -- 扫描行数
    "filtered": 100.00,
    "index_merge": {
      "union": {                            -- union合并类型
        "access_type": "range",
        "index": "idx_status",              -- 第一个索引
        "ranges": ["('pending'),('processing')"]
      },
      {
        "access_type": "range", 
        "index": "idx_amount",              -- 第二个索引
        "ranges": ["(5000,)"]
      }
    }
  }
}
```

### 5.3 跨UNION分支的索引协调


**🌐 全局索引优化策略**
```sql
-- 场景：多个UNION分支需要协调索引使用

-- UNION查询分析
SELECT order_id, status, amount FROM orders WHERE status = 'pending'
UNION ALL
SELECT order_id, status, amount FROM orders WHERE amount > 10000  
UNION ALL
SELECT order_id, status, amount FROM orders WHERE customer_id IN (1,2,3);

-- 传统索引设计（分别优化）：
CREATE INDEX idx_status ON orders(status);
CREATE INDEX idx_amount ON orders(amount);  
CREATE INDEX idx_customer ON orders(customer_id);

-- 问题：三个单独索引，无法互相利用

-- 优化方案：设计可以跨分支使用的复合索引
CREATE INDEX idx_universal_covering 
ON orders(status, amount, customer_id, order_id);
-- 优势：一个索引可以支持多个分支的查询

-- 验证索引使用情况
EXPLAIN 
SELECT order_id, status, amount FROM orders WHERE status = 'pending';
-- 可以使用 idx_universal_covering

EXPLAIN
SELECT order_id, status, amount FROM orders WHERE amount > 10000;
-- 也可以部分使用 idx_universal_covering (虽然效率不是最优)
```

---

## 6. 📦 索引覆盖联合查询


### 6.1 覆盖索引的概念与优势


**🔸 什么是覆盖索引**
```
通俗理解：覆盖索引就像"一站式服务"

生活类比：去银行办事
❌ 非覆盖索引：先到咨询台问号码，再到对应窗口办事（两次访问）
✅ 覆盖索引：咨询台直接能办完所有事情（一次访问）

技术优势：
• 避免回表操作：索引中包含所有需要的数据
• 减少I/O操作：只读取索引，不读取数据页
• 提高缓存命中率：索引更容易缓存在内存中
```

**📊 覆盖索引性能对比**
```sql
-- 非覆盖索引查询
-- 索引：idx_status(status)
SELECT order_id, customer_id, amount, order_date 
FROM orders 
WHERE status = 'pending';

-- 执行过程：
-- 1. 使用status索引找到符合条件的主键
-- 2. 根据主键回表查询order_id, customer_id, amount, order_date  
-- 3. 返回结果
-- I/O操作：索引读取 + 数据页读取

-- 覆盖索引查询  
-- 索引：idx_status_covering(status, order_id, customer_id, amount, order_date)
SELECT order_id, customer_id, amount, order_date
FROM orders
WHERE status = 'pending';

-- 执行过程：
-- 1. 使用覆盖索引直接获取所有需要的数据
-- 2. 返回结果
-- I/O操作：只有索引读取

-- 性能提升：通常2-5倍性能改善
```

### 6.2 UNION查询的覆盖索引设计


**🎯 统一覆盖索引策略**
```sql
-- 场景：电商系统的多条件订单查询
-- 需要返回相同的字段集合

-- UNION查询需求：
SELECT order_id, customer_id, total_amount, order_status, create_date
FROM orders WHERE order_status = 'pending'
UNION ALL
SELECT order_id, customer_id, total_amount, order_status, create_date  
FROM orders WHERE total_amount > 5000
UNION ALL
SELECT order_id, customer_id, total_amount, order_status, create_date
FROM orders WHERE create_date >= '2024-01-01';

-- 覆盖索引设计思路：
-- 分析所有分支的共同需求：
-- SELECT字段：order_id, customer_id, total_amount, order_status, create_date
-- WHERE条件：order_status, total_amount, create_date

-- 设计统一覆盖索引：
CREATE INDEX idx_orders_universal_cover
ON orders(
    order_status,           -- 第1个分支的主要过滤条件
    total_amount,           -- 第2个分支的主要过滤条件  
    create_date,            -- 第3个分支的主要过滤条件
    order_id,               -- SELECT字段，覆盖需要
    customer_id             -- SELECT字段，覆盖需要
);
-- 注意：create_date不放在最前面，因为它是范围查询条件
```

**🔧 分支特定覆盖索引**
```sql
-- 当UNION各分支差异较大时，为每个分支设计专门的覆盖索引

-- 分支1：状态查询（高频，需要极致性能）
SELECT order_id, customer_id, amount FROM orders WHERE status IN ('active', 'pending');
-- 专门的覆盖索引
CREATE INDEX idx_status_cover ON orders(status, order_id, customer_id, amount);

-- 分支2：时间范围查询（中频，结果集较大）
SELECT order_id, customer_id, amount FROM orders WHERE create_date >= '2024-01-01';  
-- 专门的覆盖索引
CREATE INDEX idx_date_cover ON orders(create_date, order_id, customer_id, amount);

-- 分支3：复杂条件查询（低频，但条件复杂）
SELECT order_id, customer_id, amount FROM orders 
WHERE customer_level = 'VIP' AND amount > 1000;
-- 专门的覆盖索引  
CREATE INDEX idx_vip_amount_cover ON orders(customer_level, amount, order_id, customer_id);
```

### 6.3 覆盖索引的维护成本权衡


**⚖️ 成本效益分析**
```
覆盖索引的成本：

🔸 存储成本
• 索引大小：覆盖索引通常比单列索引大3-5倍
• 磁盘空间：需要额外的存储空间
• 内存使用：占用更多缓冲池空间

🔸 维护成本  
• 插入性能：每次INSERT需要维护更多索引项
• 更新性能：UPDATE涉及覆盖字段时需要维护索引
• 删除性能：DELETE需要清理更多索引项

🔸 收益评估
• 查询性能：2-10倍的查询性能提升
• 资源节约：减少磁盘I/O和CPU使用
• 并发能力：减少锁争用，提高并发性能
```

**📊 维护成本监控**
```sql
-- 创建索引维护成本监控
CREATE TABLE index_maintenance_stats (
    table_name VARCHAR(64),
    index_name VARCHAR(64),
    operation_type ENUM('INSERT', 'UPDATE', 'DELETE'),
    avg_time_ms DECIMAL(10,4),
    operations_count BIGINT,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 监控覆盖索引的维护开销
SELECT 
    index_name,
    operation_type,
    avg_time_ms,
    operations_count,
    (avg_time_ms * operations_count) as total_overhead_ms
FROM index_maintenance_stats
WHERE table_name = 'orders'
ORDER BY total_overhead_ms DESC;

-- 基于监控结果决定是否保留覆盖索引
-- 如果维护成本 > 查询收益，考虑简化索引
```

---

## 7. 📈 联合查询索引统计


### 7.1 索引使用统计收集


**📊 关键统计指标**
```
UNION查询索引统计的重要指标：

🔸 索引使用频率
• 各分支使用了哪些索引
• 索引被使用的次数和频率  
• 索引选择的正确性

🔸 查询性能指标
• 各分支的执行时间
• 索引扫描的行数  
• 回表操作的次数

🔸 资源消耗指标
• 内存使用量（临时表、排序缓冲区）
• CPU使用率（合并、去重操作）
• I/O操作次数（索引读取、数据读取）
```

**🛠️ 统计数据收集工具**
```sql
-- MySQL中收集UNION查询的索引统计

-- 1. 开启性能统计  
SET SESSION long_query_time = 0;
SET SESSION log_queries_not_using_indexes = ON;

-- 2. 创建统计表
CREATE TABLE union_query_stats (
    id INT AUTO_INCREMENT PRIMARY KEY,
    query_hash VARCHAR(32),           -- 查询的哈希值
    branch_number INT,                -- UNION分支编号
    table_name VARCHAR(64),           -- 表名
    index_used VARCHAR(64),           -- 使用的索引
    rows_examined INT,                -- 扫描行数
    rows_sent INT,                    -- 返回行数  
    execution_time_ms DECIMAL(10,4),  -- 执行时间
    created_tmp_tables INT,           -- 创建的临时表数
    query_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 3. 自动收集统计信息的存储过程
DELIMITER $$
CREATE PROCEDURE collect_union_stats()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE query_text TEXT;
    DECLARE exec_time DECIMAL(10,4);
    
    -- 从performance_schema获取查询统计
    DECLARE stats_cursor CURSOR FOR
    SELECT sql_text, timer_wait/1000000000 as exec_time_sec
    FROM performance_schema.events_statements_history  
    WHERE sql_text LIKE '%UNION%'
    AND timer_wait > 1000000000;  -- 只收集执行时间>1秒的查询
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN stats_cursor;
    read_loop: LOOP
        FETCH stats_cursor INTO query_text, exec_time;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 解析UNION查询，提取各分支信息
        CALL parse_union_branches(query_text, exec_time);
        
    END LOOP;
    CLOSE stats_cursor;
END$$
DELIMITER ;
```

### 7.2 索引效率分析


**📊 索引效率评估指标**
```sql
-- 计算索引效率的关键指标

-- 1. 索引选择性（Selectivity）
SELECT 
    index_name,
    table_name,
    non_unique,
    cardinality,
    cardinality / table_rows as selectivity_ratio
FROM information_schema.statistics s
JOIN information_schema.tables t ON s.table_name = t.table_name
WHERE s.table_name = 'orders'
ORDER BY selectivity_ratio DESC;

-- 2. 索引使用率
SELECT 
    object_schema,
    object_name,
    index_name,
    count_read,                    -- 索引被读取的次数
    count_insert,                  -- 索引插入次数  
    count_update,                  -- 索引更新次数
    count_delete,                  -- 索引删除次数
    count_read / (count_insert + count_update + count_delete + 1) as read_write_ratio
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database' 
AND object_name = 'orders'
ORDER BY count_read DESC;

-- 3. 每个UNION分支的索引效率
CREATE VIEW union_branch_efficiency AS
SELECT 
    branch_number,
    index_used,
    AVG(rows_examined) as avg_rows_scanned,
    AVG(rows_sent) as avg_rows_returned,
    AVG(rows_sent / rows_examined) as filter_efficiency,
    AVG(execution_time_ms) as avg_exec_time
FROM union_query_stats
GROUP BY branch_number, index_used
ORDER BY filter_efficiency DESC, avg_exec_time ASC;
```

### 7.3 基于统计的索引优化建议


**🎯 自动化优化建议系统**
```python
def generate_index_recommendations(stats_data):
    """
    基于统计数据生成索引优化建议
    """
    recommendations = []
    
    # 分析各分支的性能表现
    for branch_id, branch_stats in stats_data.items():
        
        # 建议1：低效率分支需要新索引
        if branch_stats['filter_efficiency'] < 0.1:  # 过滤效率低于10%
            recommendations.append({
                'type': 'CREATE_INDEX',
                'priority': 'HIGH',
                'branch': branch_id,
                'reason': f'分支{branch_id}过滤效率仅{branch_stats["filter_efficiency"]:.2%}',
                'suggestion': f'CREATE INDEX idx_branch_{branch_id}_optimized ON {branch_stats["table"]}({branch_stats["key_columns"]})'
            })
        
        # 建议2：未使用索引的分支
        if branch_stats['index_used'] == 'NULL':
            recommendations.append({
                'type': 'CREATE_INDEX', 
                'priority': 'CRITICAL',
                'branch': branch_id,
                'reason': f'分支{branch_id}未使用任何索引，进行全表扫描',
                'suggestion': f'CREATE INDEX idx_branch_{branch_id}_basic ON {branch_stats["table"]}({branch_stats["where_columns"]})'
            })
            
        # 建议3：执行时间过长的分支
        if branch_stats['avg_exec_time'] > 1000:  # 执行时间超过1秒
            recommendations.append({
                'type': 'OPTIMIZE_INDEX',
                'priority': 'MEDIUM', 
                'branch': branch_id,
                'reason': f'分支{branch_id}平均执行时间{branch_stats["avg_exec_time"]}ms',
                'suggestion': f'考虑创建覆盖索引或优化现有索引{branch_stats["index_used"]}'
            })
    
    # 建议4：跨分支的统一索引机会
    common_columns = find_common_columns_across_branches(stats_data)
    if len(common_columns) >= 2:
        recommendations.append({
            'type': 'UNIFIED_INDEX',
            'priority': 'MEDIUM',
            'branch': 'ALL',
            'reason': f'多个分支使用相同字段：{common_columns}',
            'suggestion': f'CREATE INDEX idx_unified ON orders({", ".join(common_columns)})'
        })
    
    return sorted(recommendations, key=lambda x: ['CRITICAL', 'HIGH', 'MEDIUM'].index(x['priority']))

def find_common_columns_across_branches(stats_data):
    """找出多个分支共同使用的字段"""
    all_columns = []
    for branch_stats in stats_data.values():
        all_columns.extend(branch_stats.get('where_columns', []))
    
    # 统计字段出现频率
    from collections import Counter
    column_frequency = Counter(all_columns)
    
    # 返回出现在2个以上分支中的字段
    return [col for col, freq in column_frequency.items() if freq >= 2]
```

**📋 索引优化执行计划**
```sql
-- 创建索引优化建议执行表
CREATE TABLE index_optimization_plan (
    id INT AUTO_INCREMENT PRIMARY KEY,
    recommendation_type VARCHAR(50),
    priority ENUM('CRITICAL', 'HIGH', 'MEDIUM', 'LOW'),
    target_table VARCHAR(64),
    suggested_index VARCHAR(200),
    expected_improvement VARCHAR(100),
    estimated_cost VARCHAR(50),
    status ENUM('PENDING', 'APPROVED', 'IMPLEMENTED', 'REJECTED'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    implemented_at TIMESTAMP NULL
);

-- 插入优化建议
INSERT INTO index_optimization_plan 
(recommendation_type, priority, target_table, suggested_index, expected_improvement, estimated_cost)
VALUES
('CREATE_INDEX', 'HIGH', 'orders', 
 'CREATE INDEX idx_status_amount_cover ON orders(status, amount, order_id, customer_id)', 
 '预计查询性能提升300%', '索引大小约50MB'),
('OPTIMIZE_INDEX', 'MEDIUM', 'orders',
 'DROP INDEX idx_old_status; CREATE INDEX idx_new_status ON orders(status, create_date)',
 '预计减少20%的扫描行数', '重建时间约10分钟');

-- 批量执行已批准的索引优化
DELIMITER $$
CREATE PROCEDURE execute_approved_optimizations()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE sql_statement TEXT;
    
    DECLARE optimization_cursor CURSOR FOR
    SELECT suggested_index 
    FROM index_optimization_plan 
    WHERE status = 'APPROVED'
    ORDER BY FIELD(priority, 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW');
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN optimization_cursor;
    optimization_loop: LOOP
        FETCH optimization_cursor INTO sql_statement;
        IF done THEN
            LEAVE optimization_loop;
        END IF;
        
        -- 执行索引创建/修改
        SET @sql = sql_statement;
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 更新执行状态
        UPDATE index_optimization_plan 
        SET status = 'IMPLEMENTED', implemented_at = NOW()
        WHERE suggested_index = sql_statement;
        
    END LOOP;
    CLOSE optimization_cursor;
END$$
DELIMITER ;
```

---

## 8. 🏁 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 UNION索引策略：每个子查询需要独立的索引优化，整体性能取决于最慢的分支
🔸 索引选择机制：数据库优化器会为每个分支选择最优索引，但可能需要人工干预
🔸 索引合并技术：单个查询可以使用多个索引，通过交集或并集操作提升性能
🔸 覆盖索引设计：包含所有需要字段的索引，避免回表操作，显著提升性能
🔸 统计驱动优化：基于真实的查询统计数据，持续优化索引设计
```

### 8.2 实践中的关键决策


**🔹 索引设计策略选择**
```
统一覆盖索引 vs 分支专用索引：
• 字段需求相同 → 统一覆盖索引
• 分支差异较大 → 分支专用索引
• 混合策略 → 核心字段统一，特殊需求专用

索引合并 vs 复合索引：
• 查询条件固定 → 复合索引性能更好
• 查询条件多变 → 索引合并更灵活
• 维护成本考虑 → 索引合并减少索引数量
```

**🔹 性能优化优先级**
```
第1优先级：消除全表扫描
• 为所有UNION分支创建基础索引
• 确保每个WHERE条件都有对应索引

第2优先级：优化高频分支  
• 识别查询频率最高的分支
• 为其创建专门的覆盖索引

第3优先级：平衡各分支性能
• 避免某个分支成为性能瓶颈
• 统一各分支的执行时间

第4优先级：索引维护成本控制
• 定期清理无用索引
• 合并功能重复的索引
```

### 8.3 常见问题与解决方案


**⚠️ 典型问题分析**
```
❌ 问题1：某个UNION分支特别慢
原因：该分支缺少合适的索引或统计信息过期
解决：分析执行计划，创建针对性索引，更新统计信息

❌ 问题2：UNION查询内存使用过多
原因：临时表太大，无法在内存中完成合并操作
解决：优化索引减少中间结果集，调整tmp_table_size参数

❌ 问题3：索引提示不生效
原因：索引提示语法错误或索引不适用于查询条件
解决：检查索引是否存在，验证提示语法，考虑强制索引

❌ 问题4：覆盖索引太大影响更新性能
原因：覆盖索引包含过多字段，维护成本高
解决：评估查询频率vs更新频率，考虑部分覆盖或分时段索引
```

### 8.4 监控与维护策略


**📊 持续监控要点**
```
性能监控：
• 各UNION分支的执行时间趋势
• 索引使用率和效率统计
• 临时表创建频率和大小

资源监控：
• 索引占用的存储空间
• 内存使用情况（特别是tmp_table_size）
• CPU使用率（合并和去重操作）

业务监控：
• 查询模式的变化趋势
• 数据增长对索引性能的影响
• 用户体验指标（响应时间）
```

**🔧 维护最佳实践**
```
定期维护任务：
□ 每周更新表统计信息(ANALYZE TABLE)
□ 每月检查索引使用率，清理无用索引
□ 每季度评估UNION查询性能，优化索引设计
□ 每半年进行全面的查询模式分析

应急处理流程：
1. 发现性能问题 → 立即检查执行计划
2. 定位问题分支 → 分析索引使用情况  
3. 快速修复 → 添加索引提示或创建临时索引
4. 长期优化 → 重新设计索引策略
```

**核心记忆要点**：
```
🧠 UNION索引优化要诀：
"分支独立设计索引，整体协调求平衡
覆盖索引避回表，统计监控促优化
合并技术巧运用，持续维护保性能"
```

### 8.5 未来发展趋势


**🚀 技术发展方向**
- **智能索引推荐**：基于机器学习的自动索引优化
- **动态索引调整**：根据查询模式实时调整索引
- **列式存储优化**：UNION查询在列式数据库中的优化
- **分布式索引**：跨节点UNION查询的索引协调

这些技术发展将进一步简化UNION查询的索引管理，提升自动化优化能力。