---
title: 9、sys库查询诊断视图
---
## 📚 目录

1. [sys库诊断视图概述](#1-sys库诊断视图概述)
2. [statement_analysis核心视图](#2-statement_analysis核心视图)
3. [临时表相关诊断视图](#3-临时表相关诊断视图)
4. [排序性能诊断视图](#4-排序性能诊断视图)
5. [便捷诊断视图综合应用](#5-便捷诊断视图综合应用)
6. [查询问题快速定位实战](#6-查询问题快速定位实战)
7. [sys视图使用最佳实践](#7-sys视图使用最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 sys库诊断视图概述


### 1.1 什么是sys库


**🔸 sys库的本质**
```
sys库（System Schema）：
MySQL提供的系统诊断和监控工具集合
作用：将复杂的performance_schema数据转换为易读的视图

简单理解：
sys库就像是MySQL的"健康体检报告"
把复杂的内部数据整理成人类能看懂的表格
```

**💡 为什么需要sys库**

传统监控的痛点：
```
原始问题                    sys库解决方案
┌─────────────────────┐    ┌─────────────────────┐
│ performance_schema  │    │ sys库便捷视图       │
│ - 表太多（80+个）    │ → │ - 精选常用视图      │
│ - 字段复杂难懂      │    │ - 字段含义清晰      │
│ - 需要复杂JOIN      │    │ - 开箱即用         │
│ - 结果难以理解      │    │ - 结果直观易懂      │
└─────────────────────┘    └─────────────────────┘

举例对比：
performance_schema需要写复杂的JOIN查询
sys库只需要：SELECT * FROM sys.statement_analysis;
```

**🎯 sys库的核心优势**
```
便利性：
✅ 开箱即用，无需复杂配置
✅ 视图命名直观，见名知意
✅ 结果格式化，易于阅读

实用性：
✅ 聚焦常见问题诊断
✅ 提供性能优化建议
✅ 支持实时监控

可读性：
✅ 时间格式友好（如：1.2s而不是微秒）
✅ 大小单位友好（如：10.5MB而不是字节）
✅ 排序合理，重要信息在前
```

### 1.2 sys库的主要视图分类


**📊 sys库视图全景图**

```
sys库视图分类：
┌─ 📊 语句分析类
│  ├─ statement_analysis           # 语句综合分析
│  ├─ statements_with_temp_tables  # 使用临时表的语句
│  ├─ statements_with_sorting      # 涉及排序的语句
│  └─ statements_with_full_table_scans  # 全表扫描语句
│
├─ 🗂️ 表分析类  
│  ├─ schema_table_statistics      # 表统计信息
│  ├─ schema_index_statistics      # 索引统计信息
│  └─ schema_unused_indexes        # 未使用的索引
│
├─ 💾 内存分析类
│  ├─ memory_global_by_current_bytes  # 全局内存使用
│  ├─ memory_by_thread_by_current_bytes  # 线程内存使用
│  └─ memory_by_user_by_current_bytes    # 用户内存使用
│
└─ 🔄 IO分析类
   ├─ io_global_by_file_by_bytes   # 文件IO统计
   ├─ io_by_thread_by_latency      # 线程IO延迟
   └─ schema_table_statistics_with_buffer  # 表IO缓冲统计
```

### 1.3 sys库的启用和配置


**⚙️ 检查和启用sys库**

```sql
-- 🔍 检查sys库是否存在
SHOW DATABASES LIKE 'sys';

-- 🔍 检查performance_schema是否启用（sys库的基础）
SHOW VARIABLES LIKE 'performance_schema';

-- 🔍 查看sys库中的视图
SELECT TABLE_NAME, TABLE_TYPE 
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'sys' 
AND TABLE_TYPE = 'VIEW'
ORDER BY TABLE_NAME;
```

> 💡 **重要说明**：
> - sys库从MySQL 5.7开始默认安装
> - 依赖performance_schema，需要确保其已启用
> - 大部分视图可以直接使用，无需额外配置

---

## 2. 📊 statement_analysis核心视图


### 2.1 statement_analysis视图详解


**🔸 statement_analysis的作用**
```
statement_analysis视图：
SQL语句性能分析的"一站式体检报告"
功能：展示所有执行过的SQL语句的综合性能指标

相当于：
把每条SQL的执行次数、耗时、资源使用等信息
整理成一张清晰的成绩单
```

**📋 视图字段含义解释**

```sql
-- 📊 查看statement_analysis的完整结构
DESCRIBE sys.statement_analysis;

-- 核心字段说明：
SELECT 
    query,              -- SQL语句摘要（隐藏具体值）
    db,                 -- 执行数据库
    exec_count,         -- 执行次数
    total_latency,      -- 总耗时（格式化显示，如：1.2s）
    avg_latency,        -- 平均耗时
    lock_latency,       -- 锁等待时间
    rows_sent,          -- 返回行数
    rows_examined,      -- 检查行数  
    rows_affected,      -- 影响行数
    tmp_tables,         -- 临时表数量
    tmp_disk_tables,    -- 磁盘临时表数量
    rows_sorted,        -- 排序行数
    sort_merge_passes,  -- 排序合并次数
    max_controlled_memory,  -- 最大内存使用
    max_total_memory,   -- 最大总内存
    digest,             -- SQL指纹（用于分组相似SQL）
    first_seen,         -- 首次执行时间
    last_seen           -- 最后执行时间
FROM sys.statement_analysis 
LIMIT 1;
```

### 2.2 使用statement_analysis诊断性能问题


**🔍 找出最耗时的SQL语句**

```sql
-- 🚨 查找TOP 10最耗时的SQL
SELECT 
    LEFT(query, 80) as sql_preview,  -- SQL预览（截取前80字符）
    exec_count as 执行次数,
    total_latency as 总耗时,
    avg_latency as 平均耗时,
    rows_examined as 扫描行数,
    rows_sent as 返回行数,
    ROUND(rows_examined/rows_sent, 2) as 扫描返回比
FROM sys.statement_analysis 
ORDER BY total_latency DESC 
LIMIT 10;

-- 📊 典型输出示例：
/*
sql_preview                          执行次数  总耗时   平均耗时  扫描行数  返回行数  扫描返回比
SELECT * FROM orders WHERE status... 1250      25.8s    20.6ms   125000   1250      100.00
UPDATE products SET stock = stock... 890       15.2s    17.1ms   89000    890       100.00  
*/
```

> ⚠️ **性能问题指标**：
> - **扫描返回比过高**（>100）：可能缺少索引
> - **平均耗时过长**（>100ms）：需要优化查询
> - **执行次数过多**：考虑缓存或业务优化

**🔍 找出最频繁执行的SQL**

```sql
-- 📈 查找执行频率最高的SQL
SELECT 
    LEFT(query, 100) as sql_statement,
    exec_count as 执行次数,
    total_latency as 总耗时,
    avg_latency as 平均耗时,
    CONCAT(ROUND(exec_count * 100.0 / 
        (SELECT SUM(exec_count) FROM sys.statement_analysis), 2), '%') as 执行占比
FROM sys.statement_analysis 
ORDER BY exec_count DESC 
LIMIT 15;
```

**🔍 找出资源消耗最大的SQL**

```sql
-- 💾 查找内存使用最多的SQL
SELECT 
    LEFT(query, 80) as sql_preview,
    exec_count,
    max_controlled_memory as 最大内存使用,
    avg_latency,
    tmp_tables as 临时表数,
    tmp_disk_tables as 磁盘临时表数
FROM sys.statement_analysis 
WHERE max_controlled_memory > 0
ORDER BY max_controlled_memory DESC 
LIMIT 10;

-- 🔄 查找IO密集的SQL  
SELECT 
    LEFT(query, 80) as sql_preview,
    exec_count,
    rows_examined as 检查行数,
    rows_sent as 返回行数,
    avg_latency,
    CASE 
        WHEN rows_sent = 0 THEN 'N/A'
        ELSE CONCAT(ROUND(rows_examined/rows_sent, 1), ':1')
    END as 检查返回比
FROM sys.statement_analysis 
ORDER BY rows_examined DESC 
LIMIT 10;
```

### 2.3 statement_analysis实战案例


**🎯 综合性能分析查询**

```sql
-- 🔬 全面的SQL性能分析报告
WITH performance_summary AS (
    SELECT 
        LEFT(query, 60) as sql_type,
        exec_count,
        total_latency,
        avg_latency,
        rows_examined,
        rows_sent,
        tmp_tables + tmp_disk_tables as total_tmp_tables,
        -- 性能评分计算
        CASE 
            WHEN avg_latency > '1s' THEN '🔴 严重慢查询'
            WHEN avg_latency > '100ms' THEN '🟡 潜在性能问题'
            WHEN rows_examined/GREATEST(rows_sent,1) > 1000 THEN '🟠 扫描效率低'
            ELSE '🟢 性能正常'
        END as performance_level
    FROM sys.statement_analysis 
    WHERE exec_count > 10  -- 只分析执行过10次以上的SQL
)
SELECT 
    sql_type,
    exec_count as 执行次数,
    total_latency as 总耗时,
    avg_latency as 平均耗时,
    total_tmp_tables as 临时表总数,
    performance_level as 性能评级
FROM performance_summary 
ORDER BY 
    CASE performance_level
        WHEN '🔴 严重慢查询' THEN 1
        WHEN '🟡 潜在性能问题' THEN 2  
        WHEN '🟠 扫描效率低' THEN 3
        ELSE 4
    END,
    total_latency DESC;
```

---

## 3. 🗄️ 临时表相关诊断视图


### 3.1 statements_with_temp_tables视图


**🔸 什么是临时表问题**
```
临时表的产生原因：
当MySQL无法在内存中完成操作时，会创建临时表

常见触发场景：
├─ 复杂的GROUP BY操作
├─ ORDER BY与GROUP BY列不同
├─ 大结果集的DISTINCT操作  
├─ 复杂的子查询
└─ UNION操作

性能影响：
内存临时表：性能影响较小
磁盘临时表：性能影响很大（IO密集）
```

**📊 statements_with_temp_tables视图详解**

```sql
-- 🔍 查看临时表使用情况
SELECT 
    LEFT(query, 100) as sql_statement,
    exec_count as 执行次数,
    total_latency as 总耗时,
    avg_latency as 平均耗时,
    tmp_tables as 内存临时表,
    tmp_disk_tables as 磁盘临时表,
    ROUND(tmp_disk_tables * 100.0 / GREATEST(tmp_tables, 1), 1) as 磁盘临时表比例
FROM sys.statements_with_temp_tables 
ORDER BY tmp_disk_tables DESC, total_latency DESC
LIMIT 15;
```

**🎯 临时表问题诊断实例**

```sql
-- 🚨 找出磁盘临时表使用最多的SQL
SELECT 
    LEFT(query, 120) as problematic_sql,
    exec_count,
    avg_latency,
    tmp_disk_tables as 磁盘临时表次数,
    tmp_tables as 内存临时表次数,
    CONCAT(ROUND(tmp_disk_tables * 100.0 / tmp_tables, 1), '%') as 磁盘使用率,
    first_seen as 首次发现,
    last_seen as 最后执行
FROM sys.statements_with_temp_tables 
WHERE tmp_disk_tables > 0  -- 只显示使用了磁盘临时表的SQL
ORDER BY tmp_disk_tables * exec_count DESC  -- 按影响程度排序
LIMIT 10;

-- 💡 优化建议查询
SELECT 
    '临时表优化建议' as 分析项目,
    CASE 
        WHEN COUNT(*) = 0 THEN '✅ 无临时表问题'
        WHEN AVG(tmp_disk_tables * 100.0 / tmp_tables) < 10 THEN '🟡 轻微临时表问题，建议关注'
        WHEN AVG(tmp_disk_tables * 100.0 / tmp_tables) < 30 THEN '🟠 中等临时表问题，需要优化'
        ELSE '🔴 严重临时表问题，急需优化'
    END as 问题等级,
    COUNT(*) as 涉及SQL数量,
    CONCAT(ROUND(AVG(tmp_disk_tables * 100.0 / tmp_tables), 1), '%') as 平均磁盘使用率
FROM sys.statements_with_temp_tables 
WHERE tmp_tables > 0;
```

### 3.2 临时表问题优化策略


**🛠️ 临时表优化方法**

> 📌 **优化策略总结**：
> 1. **增加内存**：调整tmp_table_size和max_heap_table_size
> 2. **索引优化**：为GROUP BY和ORDER BY列创建合适索引
> 3. **查询重写**：避免复杂的子查询和UNION
> 4. **分页处理**：大结果集分批处理

```sql
-- 🔧 检查临时表相关配置
SHOW VARIABLES WHERE Variable_name IN (
    'tmp_table_size',           -- 内存临时表最大大小
    'max_heap_table_size',      -- 内存表最大大小  
    'internal_tmp_disk_storage_engine'  -- 磁盘临时表存储引擎
);

-- 📊 临时表使用统计
SHOW STATUS WHERE Variable_name LIKE '%tmp%';
/*
Created_tmp_disk_tables    -- 创建的磁盘临时表数
Created_tmp_files         -- 创建的临时文件数  
Created_tmp_tables        -- 创建的临时表总数
*/
```

---

## 4. 📈 排序性能诊断视图


### 4.1 statements_with_sorting视图分析


**🔸 排序操作的性能影响**
```
排序操作的成本：
┌─ 内存排序：速度快，但受内存限制
├─ 磁盘排序：速度慢，需要IO操作
└─ 多次合并排序：极度影响性能

排序触发场景：
├─ ORDER BY语句
├─ GROUP BY（某些情况）
├─ DISTINCT操作
├─ 索引合并排序
└─ 窗口函数排序
```

**📊 statements_with_sorting详细分析**

```sql
-- 🔍 排序性能分析
SELECT 
    LEFT(query, 100) as sql_statement,
    exec_count as 执行次数,
    total_latency as 总耗时,
    avg_latency as 平均耗时,
    rows_sorted as 排序行数,
    sort_merge_passes as 合并排序次数,
    avg_sort_merge_passes as 平均合并次数,
    -- 计算排序效率指标
    ROUND(rows_sorted / GREATEST(exec_count, 1), 0) as 单次平均排序行数,
    CASE 
        WHEN sort_merge_passes > 0 THEN '🔴 磁盘排序'
        WHEN rows_sorted / exec_count > 100000 THEN '🟡 大量排序'
        ELSE '🟢 正常排序'
    END as 排序状态
FROM sys.statements_with_sorting 
ORDER BY sort_merge_passes DESC, total_latency DESC
LIMIT 20;
```

**🎯 排序问题深度分析**

```sql
-- 🚨 识别排序性能问题
WITH sorting_analysis AS (
    SELECT 
        LEFT(query, 80) as sql_preview,
        exec_count,
        total_latency,
        rows_sorted,
        sort_merge_passes,
        -- 排序严重程度评分
        CASE 
            WHEN sort_merge_passes > exec_count * 5 THEN 5  -- 严重：多次磁盘排序
            WHEN sort_merge_passes > 0 THEN 4              -- 较严重：有磁盘排序
            WHEN rows_sorted / exec_count > 1000000 THEN 3 -- 中等：大量数据排序
            WHEN rows_sorted / exec_count > 100000 THEN 2  -- 轻微：较多数据排序
            ELSE 1                                         -- 正常
        END as severity_score
    FROM sys.statements_with_sorting
    WHERE exec_count > 0
)
SELECT 
    sql_preview,
    exec_count as 执行次数,
    total_latency as 总耗时,
    ROUND(rows_sorted / exec_count, 0) as 单次排序行数,
    sort_merge_passes as 磁盘排序次数,
    CASE severity_score
        WHEN 5 THEN '🔴 严重排序问题'
        WHEN 4 THEN '🟠 磁盘排序问题'  
        WHEN 3 THEN '🟡 大数据量排序'
        WHEN 2 THEN '🔵 需要关注'
        ELSE '🟢 正常'
    END as 问题等级
FROM sorting_analysis
WHERE severity_score >= 2  -- 只显示有问题的SQL
ORDER BY severity_score DESC, total_latency DESC;
```

### 4.2 排序优化策略


**🛠️ 排序性能优化方法**

```sql
-- 📊 检查排序相关配置
SHOW VARIABLES WHERE Variable_name IN (
    'sort_buffer_size',      -- 排序缓冲区大小
    'max_length_for_sort_data',  -- 排序数据最大长度
    'max_sort_length'        -- 排序字段最大长度
);

-- 💡 排序优化建议分析
SELECT 
    '排序优化分析' as 分析项目,
    COUNT(DISTINCT digest) as 涉及SQL类型数,
    SUM(exec_count) as 总执行次数,
    SUM(sort_merge_passes) as 总磁盘排序次数,
    ROUND(AVG(rows_sorted / GREATEST(exec_count, 1)), 0) as 平均单次排序行数,
    CASE 
        WHEN SUM(sort_merge_passes) = 0 THEN '✅ 排序性能良好'
        WHEN SUM(sort_merge_passes) < SUM(exec_count) * 0.1 THEN '🟡 轻微排序问题'
        WHEN SUM(sort_merge_passes) < SUM(exec_count) * 0.3 THEN '🟠 中等排序问题'  
        ELSE '🔴 严重排序问题'
    END as 整体评估
FROM sys.statements_with_sorting;
```

> 💡 **排序优化建议**：
> - **增加sort_buffer_size**：减少磁盘排序
> - **创建索引**：让ORDER BY使用索引避免排序
> - **限制结果集**：使用LIMIT减少排序数据量
> - **分页查询**：避免一次性排序大量数据

---

## 5. 🔧 便捷诊断视图综合应用


### 5.1 多视图联合分析


**🎯 综合性能诊断查询**

```sql
-- 🔬 全面的SQL性能体检报告
WITH performance_overview AS (
    -- 基础性能数据
    SELECT 
        sa.digest,
        LEFT(sa.query, 60) as sql_preview,
        sa.exec_count,
        sa.total_latency,
        sa.avg_latency,
        sa.rows_examined,
        sa.rows_sent,
        -- 临时表问题
        COALESCE(stt.tmp_disk_tables, 0) as disk_tmp_tables,
        -- 排序问题
        COALESCE(sws.sort_merge_passes, 0) as sort_passes,
        -- 全表扫描问题
        CASE WHEN sfts.query IS NOT NULL THEN 'Y' ELSE 'N' END as has_full_scan
    FROM sys.statement_analysis sa
    LEFT JOIN sys.statements_with_temp_tables stt ON sa.digest = stt.digest
    LEFT JOIN sys.statements_with_sorting sws ON sa.digest = sws.digest  
    LEFT JOIN sys.statements_with_full_table_scans sfts ON sa.digest = sfts.digest
    WHERE sa.exec_count > 5  -- 只分析执行5次以上的SQL
),
problem_scoring AS (
    SELECT *,
        -- 问题评分
        (CASE WHEN avg_latency > '1s' THEN 10 ELSE 0 END) +
        (CASE WHEN rows_examined/GREATEST(rows_sent,1) > 1000 THEN 8 ELSE 0 END) +
        (CASE WHEN disk_tmp_tables > 0 THEN 6 ELSE 0 END) +
        (CASE WHEN sort_passes > exec_count THEN 5 ELSE 0 END) +
        (CASE WHEN has_full_scan = 'Y' THEN 7 ELSE 0 END) as problem_score
    FROM performance_overview
)
SELECT 
    sql_preview,
    exec_count as 执行次数,
    avg_latency as 平均耗时,
    ROUND(rows_examined/GREATEST(rows_sent,1), 1) as 扫描效率,
    disk_tmp_tables as 磁盘临时表,
    sort_passes as 排序次数,
    has_full_scan as 全表扫描,
    CASE 
        WHEN problem_score >= 15 THEN '🔴 严重问题'
        WHEN problem_score >= 10 THEN '🟠 需要优化'  
        WHEN problem_score >= 5 THEN '🟡 建议关注'
        ELSE '🟢 性能正常'
    END as 综合评级
FROM problem_scoring
ORDER BY problem_score DESC, total_latency DESC
LIMIT 25;
```

### 5.2 数据库整体健康检查


**📊 数据库性能总览报告**

```sql
-- 🏥 数据库性能健康体检
SELECT 
    '📊 语句执行统计' as 检查项目,
    CONCAT(
        '总执行: ', FORMAT(SUM(exec_count), 0), ' 次, ',
        '平均耗时: ', 
        SUBSTRING_INDEX(
            SEC_TO_TIME(
                TIME_TO_SEC(AVG(avg_latency)) 
            ), '.', 1
        )
    ) as 统计结果
FROM sys.statement_analysis

UNION ALL

SELECT 
    '🗄️ 临时表使用情况',
    CONCAT(
        '使用临时表的SQL: ', COUNT(*), ' 个, ',
        '磁盘临时表比例: ', 
        ROUND(SUM(tmp_disk_tables) * 100.0 / GREATEST(SUM(tmp_tables), 1), 1), '%'
    )
FROM sys.statements_with_temp_tables
WHERE tmp_tables > 0

UNION ALL

SELECT 
    '📈 排序操作统计',
    CONCAT(
        '涉及排序的SQL: ', COUNT(*), ' 个, ',
        '磁盘排序次数: ', FORMAT(SUM(sort_merge_passes), 0)
    )
FROM sys.statements_with_sorting

UNION ALL

SELECT 
    '🔍 全表扫描情况', 
    CONCAT(
        '全表扫描的SQL: ', COUNT(*), ' 个, ',
        '平均扫描行数: ', FORMAT(AVG(rows_examined), 0)
    )
FROM sys.statements_with_full_table_scans;
```

### 5.3 定时性能监控脚本


**⏰ 自动化监控查询**

```sql
-- 🤖 每日性能监控报告
DELIMITER $$

CREATE PROCEDURE DailyPerformanceReport()
BEGIN
    DECLARE report_date DATE DEFAULT CURDATE();
    
    SELECT CONCAT('=== MySQL性能监控报告 ', report_date, ' ===') as 报告标题;
    
    -- 🔴 严重性能问题
    SELECT 
        '🔴 严重性能问题' as 问题类型,
        LEFT(query, 100) as SQL语句,
        exec_count as 执行次数,
        avg_latency as 平均耗时
    FROM sys.statement_analysis 
    WHERE avg_latency > '5s' OR rows_examined/GREATEST(rows_sent,1) > 10000
    ORDER BY avg_latency DESC 
    LIMIT 5;
    
    -- 🟠 资源消耗问题
    SELECT 
        '🟠 高资源消耗' as 问题类型,
        LEFT(query, 100) as SQL语句,
        tmp_disk_tables as 磁盘临时表,
        sort_merge_passes as 磁盘排序次数
    FROM sys.statements_with_temp_tables stt
    JOIN sys.statements_with_sorting sws ON stt.digest = sws.digest
    WHERE tmp_disk_tables > 10 OR sort_merge_passes > 100
    ORDER BY (tmp_disk_tables + sort_merge_passes) DESC
    LIMIT 5;
    
    -- 📊 整体性能指标
    SELECT 
        '📊 整体性能指标' as 指标类型,
        CONCAT('活跃SQL数量: ', COUNT(DISTINCT digest)) as 统计1,
        CONCAT('平均查询耗时: ', 
            SUBSTRING_INDEX(SEC_TO_TIME(TIME_TO_SEC(AVG(avg_latency))), '.', 1)
        ) as 统计2,
        CONCAT('问题SQL占比: ', 
            ROUND(
                SUM(CASE WHEN avg_latency > '1s' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 
                1
            ), '%'
        ) as 统计3
    FROM sys.statement_analysis;

END$$

DELIMITER ;

-- 执行监控报告
CALL DailyPerformanceReport();
```

---

## 6. 🎯 查询问题快速定位实战


### 6.1 常见性能问题的快速诊断


**🚨 问题定位的系统化方法**

```
问题定位流程：
第1步：整体性能概览 → 发现异常指标
第2步：具体问题分析 → 定位具体SQL
第3步：问题根因分析 → 找出性能瓶颈
第4步：优化方案制定 → 提出解决方案
第5步：效果验证 → 确认优化效果
```

**🔍 Step 1: 整体性能快速扫描**

```sql
-- ⚡ 性能问题快速扫描
CREATE TEMPORARY TABLE performance_scan AS
SELECT 
    'avg_query_time' as metric,
    SEC_TO_TIME(TIME_TO_SEC(AVG(avg_latency))) as value,
    CASE WHEN AVG(TIME_TO_SEC(avg_latency)) > 1 THEN '🔴' ELSE '🟢' END as status
FROM sys.statement_analysis

UNION ALL

SELECT 
    'slow_queries_pct',
    CONCAT(
        ROUND(
            SUM(CASE WHEN avg_latency > '1s' THEN exec_count ELSE 0 END) * 100.0 
            / SUM(exec_count), 2
        ), '%'
    ),
    CASE WHEN SUM(CASE WHEN avg_latency > '1s' THEN exec_count ELSE 0 END) * 100.0 / SUM(exec_count) > 5 
         THEN '🔴' ELSE '🟢' END
FROM sys.statement_analysis

UNION ALL

SELECT 
    'temp_tables_pct',
    CONCAT(
        ROUND(
            COUNT(CASE WHEN tmp_disk_tables > 0 THEN 1 END) * 100.0 / COUNT(*), 2
        ), '%'
    ),
    CASE WHEN COUNT(CASE WHEN tmp_disk_tables > 0 THEN 1 END) * 100.0 / COUNT(*) > 10 
         THEN '🔴' ELSE '🟢' END
FROM sys.statements_with_temp_tables;

SELECT 
    metric as 性能指标,
    value as 当前值,
    status as 状态,
    CASE metric
        WHEN 'avg_query_time' THEN '平均查询时间（建议<1s）'
        WHEN 'slow_queries_pct' THEN '慢查询占比（建议<5%）'
        WHEN 'temp_tables_pct' THEN '磁盘临时表占比（建议<10%）'
    END as 说明
FROM performance_scan;

DROP TEMPORARY TABLE performance_scan;
```

### 6.2 具体问题的深入分析


**🔍 Step 2: 慢查询根因分析**

```sql
-- 🐌 慢查询深度分析
WITH slow_query_analysis AS (
    SELECT 
        digest,
        LEFT(query, 120) as sql_preview,
        exec_count,
        avg_latency,
        rows_examined,
        rows_sent,
        rows_examined/GREATEST(rows_sent, 1) as scan_efficiency,
        -- 判断慢查询类型
        CASE 
            WHEN rows_examined/GREATEST(rows_sent, 1) > 1000 THEN 'index_missing'
            WHEN rows_sent = 0 AND avg_latency > '500ms' THEN 'write_slow'  
            WHEN rows_sent > 10000 THEN 'large_result'
            WHEN query LIKE '%ORDER BY%' AND query NOT LIKE '%LIMIT%' THEN 'sort_heavy'
            ELSE 'other'
        END as slow_type
    FROM sys.statement_analysis 
    WHERE avg_latency > '1s'
)
SELECT 
    sql_preview,
    exec_count as 执行次数,
    avg_latency as 平均耗时,
    ROUND(scan_efficiency, 1) as 扫描效率,
    CASE slow_type
        WHEN 'index_missing' THEN '🔍 可能缺少索引'
        WHEN 'write_slow' THEN '✏️ 写操作慢'
        WHEN 'large_result' THEN '📊 结果集过大'
        WHEN 'sort_heavy' THEN '📈 排序开销大'
        ELSE '❓ 需要进一步分析'
    END as 问题类型,
    CASE slow_type
        WHEN 'index_missing' THEN '建议：分析WHERE条件，创建合适索引'
        WHEN 'write_slow' THEN '建议：检查锁等待，优化事务'
        WHEN 'large_result' THEN '建议：添加LIMIT，使用分页'
        WHEN 'sort_heavy' THEN '建议：创建排序索引，增加sort_buffer_size'
        ELSE '建议：使用EXPLAIN分析执行计划'
    END as 优化建议
FROM slow_query_analysis
ORDER BY TIME_TO_SEC(avg_latency) DESC;
```

### 6.3 问题SQL的优化验证


**📊 Step 3: 优化效果对比分析**

```sql
-- 🔄 优化前后效果对比（需要在优化前后分别执行）
-- 建议：优化前保存基线数据，优化后对比
CREATE TEMPORARY TABLE baseline_performance AS
SELECT 
    digest,
    LEFT(query, 60) as sql_type,
    exec_count as baseline_exec_count,
    avg_latency as baseline_avg_latency,
    rows_examined as baseline_rows_examined,
    NOW() as baseline_time
FROM sys.statement_analysis 
WHERE avg_latency > '500ms';

-- 一段时间后执行对比查询
SELECT 
    bp.sql_type,
    bp.baseline_avg_latency as 优化前耗时,
    sa.avg_latency as 优化后耗时,
    CONCAT(
        ROUND(
            (TIME_TO_SEC(bp.baseline_avg_latency) - TIME_TO_SEC(sa.avg_latency)) 
            * 100.0 / TIME_TO_SEC(bp.baseline_avg_latency), 1
        ), '%'
    ) as 性能提升,
    bp.baseline_rows_examined as 优化前扫描行数,
    sa.rows_examined as 优化后扫描行数,
    CASE 
        WHEN TIME_TO_SEC(sa.avg_latency) < TIME_TO_SEC(bp.baseline_avg_latency) * 0.5 
        THEN '🟢 显著提升'
        WHEN TIME_TO_SEC(sa.avg_latency) < TIME_TO_SEC(bp.baseline_avg_latency) * 0.8 
        THEN '🟡 有所提升'
        ELSE '🔴 需要进一步优化'
    END as 优化效果
FROM baseline_performance bp
LEFT JOIN sys.statement_analysis sa ON bp.digest = sa.digest
WHERE sa.digest IS NOT NULL;

DROP TEMPORARY TABLE baseline_performance;
```

---

## 7. 🛠️ sys视图使用最佳实践


### 7.1 sys视图使用的注意事项


**⚠️ 重要使用原则**

> 📋 **sys视图使用守则**：
> 1. **生产环境谨慎使用**：sys视图查询本身有性能开销
> 2. **合理控制查询频率**：避免频繁查询加重负担
> 3. **使用LIMIT限制结果**：防止返回过多数据
> 4. **非业务高峰查询**：选择合适时间窗口
> 5. **定期清理统计数据**：避免历史数据过多影响性能

**🔒 安全和权限控制**

```sql
-- 🔍 检查当前用户对sys库的权限
SHOW GRANTS FOR CURRENT_USER();

-- 🛡️ 为监控用户创建最小权限
CREATE USER 'monitor'@'localhost' IDENTIFIED BY 'strong_password';
GRANT SELECT ON sys.* TO 'monitor'@'localhost';
GRANT SELECT ON performance_schema.* TO 'monitor'@'localhost';
GRANT SHOW DATABASES ON *.* TO 'monitor'@'localhost';

-- 🔐 撤销不必要的权限
-- REVOKE ALL PRIVILEGES ON *.* FROM 'monitor'@'localhost';
```

### 7.2 性能监控自动化脚本


**🤖 监控脚本模板**

```sql
-- 📊 轻量级定时监控脚本
DELIMITER $$

CREATE PROCEDURE QuickHealthCheck()
BEGIN
    -- 声明变量
    DECLARE done INT DEFAULT FALSE;
    DECLARE alert_count INT DEFAULT 0;
    
    -- 临时表存储问题
    CREATE TEMPORARY TABLE health_issues (
        issue_type VARCHAR(50),
        description TEXT,
        severity ENUM('HIGH', 'MEDIUM', 'LOW')
    );
    
    -- 检查慢查询
    INSERT INTO health_issues
    SELECT 
        'SLOW_QUERY',
        CONCAT('发现慢查询: ', LEFT(query, 50), '... 平均耗时: ', avg_latency),
        'HIGH'
    FROM sys.statement_analysis 
    WHERE avg_latency > '5s' 
    LIMIT 3;
    
    -- 检查磁盘临时表
    INSERT INTO health_issues  
    SELECT 
        'DISK_TMP_TABLE',
        CONCAT('磁盘临时表过多: ', LEFT(query, 50), '... 次数: ', tmp_disk_tables),
        'MEDIUM'
    FROM sys.statements_with_temp_tables
    WHERE tmp_disk_tables > 100
    LIMIT 3;
    
    -- 检查全表扫描
    INSERT INTO health_issues
    SELECT 
        'FULL_TABLE_SCAN',
        CONCAT('全表扫描: ', LEFT(query, 50), '... 扫描: ', rows_examined, ' 行'),
        'MEDIUM' 
    FROM sys.statements_with_full_table_scans
    WHERE rows_examined > 1000000
    LIMIT 3;
    
    -- 输出检查结果
    SELECT 
        issue_type as 问题类型,
        description as 问题描述,
        severity as 严重程度,
        NOW() as 检查时间
    FROM health_issues
    ORDER BY 
        CASE severity 
            WHEN 'HIGH' THEN 1 
            WHEN 'MEDIUM' THEN 2 
            ELSE 3 
        END;
    
    -- 获取问题数量
    SELECT COUNT(*) INTO alert_count FROM health_issues;
    
    -- 输出总结
    SELECT 
        CONCAT('健康检查完成，发现 ', alert_count, ' 个问题') as 检查总结,
        CASE 
            WHEN alert_count = 0 THEN '🟢 系统健康'
            WHEN alert_count <= 3 THEN '🟡 需要关注' 
            ELSE '🔴 需要紧急处理'
        END as 健康状态;
    
    DROP TEMPORARY TABLE health_issues;
END$$

DELIMITER ;

-- 执行健康检查
CALL QuickHealthCheck();
```

### 7.3 监控数据的持久化存储


**💾 监控历史数据保存**

```sql
-- 📈 创建性能监控历史表
CREATE TABLE performance_history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metric_type ENUM('SLOW_QUERY', 'TEMP_TABLE', 'SORTING', 'FULL_SCAN'),
    sql_digest VARCHAR(64),
    sql_preview TEXT,
    exec_count BIGINT,
    avg_latency VARCHAR(20),
    problem_score INT,
    optimization_suggestion TEXT,
    INDEX idx_check_time (check_time),
    INDEX idx_metric_type (metric_type)
);

-- 📊 定期保存监控数据的存储过程
DELIMITER $$

CREATE PROCEDURE SavePerformanceSnapshot()
BEGIN
    -- 保存慢查询数据
    INSERT INTO performance_history 
        (metric_type, sql_digest, sql_preview, exec_count, avg_latency, problem_score, optimization_suggestion)
    SELECT 
        'SLOW_QUERY',
        digest,
        LEFT(query, 200),
        exec_count,
        avg_latency,
        CASE 
            WHEN avg_latency > '10s' THEN 10
            WHEN avg_latency > '5s' THEN 8  
            WHEN avg_latency > '1s' THEN 5
            ELSE 3
        END,
        '建议分析执行计划，优化索引'
    FROM sys.statement_analysis 
    WHERE avg_latency > '1s'
    ORDER BY avg_latency DESC 
    LIMIT 20;
    
    -- 保存临时表问题
    INSERT INTO performance_history 
        (metric_type, sql_digest, sql_preview, exec_count, avg_latency, problem_score, optimization_suggestion)
    SELECT 
        'TEMP_TABLE',
        digest, 
        LEFT(query, 200),
        exec_count,
        avg_latency,
        CASE WHEN tmp_disk_tables > 100 THEN 8 ELSE 5 END,
        '建议优化GROUP BY和ORDER BY，调整临时表大小'
    FROM sys.statements_with_temp_tables
    WHERE tmp_disk_tables > 10
    LIMIT 10;

END$$

DELIMITER ;

-- 🕐 设置定时任务（需要配合cron或事件调度器）
-- 每小时执行一次性能快照保存
CREATE EVENT IF NOT EXISTS performance_snapshot_event
ON SCHEDULE EVERY 1 HOUR
STARTS CURRENT_TIMESTAMP
DO CALL SavePerformanceSnapshot();

-- 开启事件调度器
SET GLOBAL event_scheduler = ON;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 sys库本质：MySQL性能诊断的便捷工具集
🔸 statement_analysis：SQL语句性能分析的核心视图
🔸 临时表诊断：识别内存和磁盘临时表问题
🔸 排序诊断：分析排序操作对性能的影响  
🔸 综合分析：多视图联合使用进行全面诊断
```

### 8.2 关键理解要点


**🔹 sys库的核心价值**
```
理解要点：
- sys库是performance_schema的"翻译器"
- 将复杂的性能数据转换为易懂的格式
- 提供开箱即用的诊断查询
- 减少DBA和开发人员的工作量
```

**🔹 性能问题的识别思路**
```
系统化的问题识别：
第1层：整体指标扫描（平均耗时、慢查询比例）
第2层：具体问题定位（临时表、排序、全表扫描）  
第3层：根因分析（索引缺失、查询设计问题）
第4层：优化验证（对比优化前后效果）
```

**🔹 使用sys库的最佳时机**
```
适合使用的场景：
✅ 系统性能出现问题时的快速诊断
✅ 定期健康检查和性能巡检
✅ 新应用上线前的性能基线建立
✅ 数据库优化效果的验证

不适合的场景：
❌ 业务高峰期的频繁查询
❌ 对实时性要求极高的监控
❌ 权限受限的生产环境
```

### 8.3 实际应用指导


**📈 监控策略建议**
```
日常监控：
- 每天1-2次整体健康检查
- 重点关注TOP 10慢查询
- 监控临时表和排序问题趋势

问题诊断：
- 性能问题时优先查statement_analysis
- 结合多个视图进行综合分析  
- 保存问题SQL的历史数据便于对比

优化验证：
- 优化前保存性能基线
- 优化后定期对比效果
- 建立长期的性能监控数据库
```

**🛠️ 使用技巧总结**
```
查询技巧：
- 善用LIMIT防止结果集过大
- 结合WHERE条件过滤无关数据
- 使用LEFT JOIN进行多视图关联

安全考虑：
- 创建专用监控账号，最小权限原则
- 避免在业务高峰期执行重型诊断查询
- 定期清理performance_schema历史数据

自动化：
- 编写存储过程进行定期检查
- 设置事件调度器自动执行监控
- 建立告警机制及时发现问题
```

### 8.4 学习进阶建议


```
⭐ 入门级：
- 掌握sys.statement_analysis的基本使用
- 理解慢查询的识别和分析方法
- 学会使用基础的诊断视图

⭐⭐ 中级：  
- 掌握多视图联合分析技巧
- 能够编写复杂的性能诊断查询
- 建立系统化的监控体系

⭐⭐⭐ 高级：
- 开发自动化的监控和告警系统
- 深入理解performance_schema原理
- 能够定制化开发监控工具
```

**🧠 记忆技巧**：
```
sys库记忆口诀：
sys库好帮手，性能问题快定位
statement看全局，临时表要注意
排序问题查sorting，全表扫描需优化
多视图联合用，问题根因现端倪
```

**核心记忆**：
- sys库是MySQL性能诊断的瑞士军刀
- statement_analysis是问题诊断的起点
- 临时表和排序是常见的性能瓶颈
- 系统化分析比单一指标更有价值
- 监控自动化是运维效率的关键