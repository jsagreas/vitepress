---
title: 5、执行计划生成算法
---
## 📚 目录

1. [执行计划生成概述](#1-执行计划生成概述)
2. [计划搜索空间分析](#2-计划搜索空间分析)
3. [动态规划算法在查询优化中的应用](#3-动态规划算法在查询优化中的应用)
4. [启发式搜索策略](#4-启发式搜索策略)
5. [计划枚举策略详解](#5-计划枚举策略详解)
6. [剪枝优化技术](#6-剪枝优化技术)
7. [计划质量评估机制](#7-计划质量评估机制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 执行计划生成概述


### 1.1 什么是执行计划生成


**🔸 通俗理解**
执行计划生成就像是为一个复杂的工程项目制定最优施工方案。当你要盖一栋楼时，有很多种施工顺序：可以先盖地基再盖楼层，也可以分区域同时施工。查询优化器的工作就是从所有可能的"施工方案"中找出最高效的那一个。

```
现实类比：
旅行规划问题：
- 要访问北京、上海、广州、深圳4个城市
- 可能的路线：4! = 24种不同的访问顺序
- 需要考虑：时间成本、交通费用、住宿安排
- 目标：找出总成本最低的路线

SQL查询优化：  
- 要连接表A、B、C、D
- 可能的连接顺序：4! = 24种
- 需要考虑：I/O成本、CPU成本、内存使用
- 目标：找出执行时间最短的计划
```

### 1.2 执行计划的组成要素


**🔸 执行计划的核心组件**
一个完整的执行计划包含以下关键信息：

```
执行计划结构：
┌─────────────────────────────────────┐
│ 表访问方式                          │
│ ├─ 全表扫描(Table Scan)              │
│ ├─ 索引扫描(Index Scan)              │
│ └─ 索引查找(Index Seek)              │
├─────────────────────────────────────┤
│ 连接算法                            │
│ ├─ 嵌套循环连接(Nested Loop)         │
│ ├─ 哈希连接(Hash Join)              │
│ └─ 排序合并连接(Sort Merge Join)     │
├─────────────────────────────────────┤
│ 操作顺序                            │
│ ├─ 表连接顺序                       │
│ ├─ 过滤条件应用时机                  │
│ └─ 聚合和排序操作位置                │
└─────────────────────────────────────┘
```

### 1.3 计划生成的挑战


**🔸 组合爆炸问题**
随着查询中表数量的增加，可能的执行计划数量呈指数级增长：

```
计划数量增长：
表数量    可能的连接顺序    实际考虑的计划数
  2           2!              几十个
  3           3!              几百个
  4           4!              几千个
  5           5!              几万个
  10          10!             几千万个

现实情况：企业级查询常常涉及10+个表的连接！
```

**🔸 时间限制约束**
查询优化器必须在有限时间内找到足够好的计划：

```
优化时间权衡：
┌─────────────────────────────────────┐
│ 简单查询：优化时间 < 1毫秒           │
├─────────────────────────────────────┤
│ 复杂查询：优化时间 < 100毫秒         │
├─────────────────────────────────────┤
│ 超复杂查询：优化时间 < 1秒           │
└─────────────────────────────────────┘

如果优化时间比查询执行时间还长，就得不偿失了！
```

---

## 2. 🔍 计划搜索空间分析


### 2.1 搜索空间的构成


**🔸 什么是搜索空间**
搜索空间就是所有可能的执行计划的集合。就像一个巨大的迷宫，每条路径代表一种执行方案，优化器需要找到通向目标的最短路径。

```
搜索空间维度：
┌─────────────────────────────────────┐
│ 连接顺序维度                        │
│ • 表A先连接表B，还是表B先连接表A？    │
├─────────────────────────────────────┤
│ 连接算法维度                        │  
│ • 使用哈希连接还是嵌套循环连接？      │
├─────────────────────────────────────┤
│ 访问路径维度                        │
│ • 走索引还是全表扫描？              │
├─────────────────────────────────────┤
│ 物理操作维度                        │
│ • 何时排序？何时应用过滤条件？       │
└─────────────────────────────────────┘
```

### 2.2 搜索空间的表示方法


**🔸 计划树表示**
每个执行计划可以表示为一棵树，树的节点代表操作，叶子节点代表基本表：

```
三表连接的计划树示例：
计划1：                    计划2：
    Join                      Join
   /    \                    /    \
  A    Join                Join    C  
      /    \              /    \
     B      C            A      B

连接顺序：A->(B->C)       连接顺序：(A->B)->C
```

**🔸 搜索空间枚举策略**
```
枚举方法对比：
┌─────────────────┬─────────────┬─────────────┐
│    枚举方法     │   覆盖度    │   复杂度    │
├─────────────────┼─────────────┼─────────────┤
│ 完全枚举        │    100%     │    O(n!)    │
├─────────────────┼─────────────┼─────────────┤
│ 动态规划        │  近100%     │   O(3^n)    │  
├─────────────────┼─────────────┼─────────────┤
│ 启发式搜索      │   70-90%    │   O(n²)     │
├─────────────────┼─────────────┼─────────────┤
│ 贪心算法        │   50-70%    │   O(n log n)│
└─────────────────┴─────────────┴─────────────┘
```

### 2.3 搜索空间的复杂性分析


**🔸 复杂性来源**
```
复杂性分析：
基础复杂性：
• n个表的连接顺序：(n-1)! 种可能
• 每个连接可选择的算法：通常3-5种
• 每个表的访问路径：平均2-4种

综合复杂性：
总计划数 ≈ (n-1)! × 3^(n-1) × 2^n

实际例子：
5张表查询：4! × 3⁴ × 2⁵ ≈ 62,208种计划
```

---

## 3. 🧠 动态规划算法在查询优化中的应用


### 3.1 动态规划的基本思想


**🔸 核心原理**
动态规划利用"最优子结构"的特性来减少重复计算。在查询优化中，这意味着如果我们知道连接表集合{A,B}的最优计划，那么包含这个子集的更大查询的最优计划可以基于这个结果构建。

```
动态规划思路：
问题：如何最优地连接表{A,B,C,D}？

分解：
1. 先解决规模为1的子问题：最优访问单表A、B、C、D
2. 再解决规模为2的子问题：最优连接{A,B}、{A,C}、{A,D}...
3. 然后解决规模为3的子问题：基于前面结果构建
4. 最后解决规模为4的问题：得到最终答案

关键优势：避免重复计算相同子问题
```

### 3.2 Selinger算法详解


**🔸 算法核心思想**
Selinger算法是数据库查询优化中最著名的动态规划算法，由IBM在System R中首次实现。

```
Selinger算法步骤：
第1步：初始化
• 为每个基表计算最优访问计划
• 存储每个表的最佳访问方法和成本

第2步：迭代构建
for 集合大小 from 2 to n:
    for 每个大小为s的表集合 S:
        for 每种可能的划分 S = S1 ∪ S2:
            计算连接 best(S1) 和 best(S2) 的成本
            if 成本更低:
                更新 best(S)

第3步：输出结果
• 返回连接所有表的最优计划
```

**🔸 算法实现示例**
```sql
-- 假设查询：
SELECT * FROM A, B, C 
WHERE A.id = B.aid AND B.id = C.bid

-- Selinger算法处理过程：
-- 第1轮：单表访问计划
best({A}) = TableScan(A), cost=100
best({B}) = IndexScan(B, B.id), cost=50  
best({C}) = TableScan(C), cost=80

-- 第2轮：两表连接计划
best({A,B}) = Join(best(A), best(B)), cost=200
best({A,C}) = 无连接条件，cost=∞
best({B,C}) = Join(best(B), best(C)), cost=180

-- 第3轮：三表连接计划
best({A,B,C}) = Join(best({A,B}), best(C)), cost=350
            或 = Join(best(A), best({B,C})), cost=320 ← 更优
```

### 3.3 动态规划的优化改进


**🔸 有趣序(Interesting Order)优化**
不仅考虑成本最低的计划，还保留那些在某些排序上有优势的计划：

```
有趣序概念：
基础计划：cost=100, 结果无序
排序计划：cost=120, 结果按id排序

如果后续需要ORDER BY id：
• 基础计划总成本：100 + 30(排序) = 130
• 排序计划总成本：120 + 0(无需排序) = 120

因此两个计划都应该保留！
```

**🔸 剪枝策略**
```
剪枝优化技术：
1. 成本剪枝：
   if 当前部分成本 > 已知最优解:
       舍弃这条搜索路径

2. 笛卡尔积剪枝：
   避免生成没有连接条件的笛卡尔积

3. 时间限制剪枝：
   if 优化时间 > 阈值:
       返回当前最佳解
```

---

## 4. 🎲 启发式搜索策略


### 4.1 启发式搜索的必要性


**🔸 为什么需要启发式方法**
当查询涉及很多表时，即使是动态规划也会变得计算量巨大。启发式搜索通过"聪明的猜测"来快速找到接近最优的解。

```
启发式 vs 精确算法：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│   表数量    │  精确算法   │  启发式算法  │   质量差距   │
├─────────────┼─────────────┼─────────────┼─────────────┤
│    3-5张    │   首选      │    无必要    │      0%     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│    6-8张    │   可行      │    推荐     │    < 5%     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│   9-12张    │   困难      │    必须     │   < 15%     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│   13+张     │   不可行    │    唯一选择  │   < 25%     │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

### 4.2 贪心策略


**🔸 最小成本优先策略**
每一步都选择当前看起来最划算的连接：

```
贪心算法示例：
查询涉及表：A(1000行), B(100行), C(10000行), D(50行)
连接条件：A.id=B.aid, B.id=C.bid, C.id=D.cid

贪心选择过程：
第1步：寻找代价最小的连接
• A-B连接：1000 × 100 = 100,000
• B-C连接：100 × 10000 = 1,000,000  
• C-D连接：10000 × 50 = 500,000
选择：A-B连接（代价最小）

第2步：将AB看作整体，继续选择
• (AB)-C连接：估算代价300,000
• (AB)-D连接：因无直接连接条件，跳过  
• C-D连接：500,000
选择：(AB)-C连接

第3步：最后连接D
• ((AB)C)-D连接
```

### 4.3 遗传算法在查询优化中的应用


**🔸 遗传算法基本思想**
模拟生物进化过程，通过选择、交叉、变异等操作来搜索最优解：

```
遗传算法流程：
第1步：初始化种群
• 随机生成N个执行计划作为初始种群
• 每个计划编码为一个"染色体"

第2步：适应度评估  
• 计算每个计划的执行成本
• 成本越低，适应度越高

第3步：选择操作
• 按适应度选择优秀个体作为父代
• 适应度高的个体有更大概率被选中

第4步：交叉操作
parent1: [A-B-C-D]    parent2: [C-D-A-B]
         ↓ 交叉 ↓
child1:  [A-B-A-B]    child2:  [C-D-C-D]  
         ↓ 修复 ↓  
child1:  [A-B-D-C]    child2:  [C-D-B-A]

第5步：变异操作
• 随机调整计划中的某些决策
• 如改变连接算法、访问路径等

第6步：迭代进化
• 重复2-5步，直到收敛或达到时间限制
```

### 4.4 模拟退火算法


**🔸 模拟退火的核心思想**
模拟金属退火过程，允许在搜索过程中接受一定程度的"坏"解，避免陷入局部最优：

```
模拟退火算法：
当前解：current_plan，当前成本：current_cost
最优解：best_plan，最优成本：best_cost  
温度：temperature（初始值较高，逐渐降低）

while temperature > min_temperature:
    生成邻居解：neighbor_plan
    计算成本差：delta = neighbor_cost - current_cost
    
    if delta < 0:  # 更好的解
        current_plan = neighbor_plan
        if neighbor_cost < best_cost:
            best_plan = neighbor_plan
    else:  # 更差的解
        probability = exp(-delta / temperature)
        if random() < probability:  # 以一定概率接受
            current_plan = neighbor_plan
    
    temperature *= 0.95  # 降温
```

---

## 5. 📋 计划枚举策略详解


### 5.1 系统性枚举方法


**🔸 左深树优先策略**
优先考虑左深树形式的连接计划，这种结构对流水线处理友好：

```
左深树 vs 灌木树：

左深树（推荐）：           灌木树（复杂）：
      Join                    Join
     /    \                  /    \
   Join    D               Join  Join  
  /    \                  /  \  /  \
 Join   C                A   B C   D
/    \
A     B

优势：可以边连接边输出结果，内存需求低
```

### 5.2 枚举顺序优化


**🔸 智能枚举顺序**
不是盲目地枚举所有可能，而是按照一定的智能顺序：

```
枚举优先级：
高优先级：
1. 有索引支持的连接
2. 选择性高的过滤条件
3. 小表驱动大表的连接

中优先级：  
4. 等值连接优于范围连接
5. 内连接优于外连接
6. 简单条件优于复杂表达式

低优先级：
7. 笛卡尔积连接
8. 需要临时表的操作
9. 复杂的子查询
```

**🔸 分阶段枚举策略**
```
三阶段枚举法：
第1阶段：快速枚举（时间限制：10毫秒）
• 只考虑最有希望的连接顺序
• 使用简单的成本估算
• 目标：快速找到可行解

第2阶段：精确优化（时间限制：100毫秒）  
• 对第1阶段的结果进行精确成本计算
• 考虑更多的连接算法选择
• 目标：找到高质量解

第3阶段：细微调整（时间限制：1秒）
• 对最优计划进行细节优化
• 考虑物理操作的最佳时机
• 目标：获得最佳执行效率
```

### 5.3 并行枚举策略


**🔸 多线程枚举**
利用现代多核处理器的优势，并行搜索不同的计划空间：

```
并行搜索策略：
主线程：负责协调和结果汇总
工作线程1：搜索以表A为起始的所有计划
工作线程2：搜索以表B为起始的所有计划  
工作线程3：搜索以表C为起始的所有计划
...

同步机制：
• 共享最优解：当某个线程找到更好解时，通知其他线程
• 剪枝协调：避免重复搜索相同的子问题
• 时间控制：统一的超时机制
```

---

## 6. ✂️ 剪枝优化技术


### 6.1 剪枝的基本原理


**🔸 为什么需要剪枝**
剪枝就像修剪树木一样，去掉那些明显不会结出好果子的枝条，让营养集中到有希望的枝条上。在查询优化中，剪枝可以大幅减少需要评估的计划数量。

```
剪枝效果示例：
原始搜索空间：1,000,000个计划
经过剪枝后：10,000个计划（减少99%）
优化时间：从10秒降低到0.1秒
计划质量：几乎没有损失
```

### 6.2 成本剪枝技术


**🔸 上界剪枝**
如果当前部分计划的成本已经超过已知的完整计划成本，就可以放弃这条搜索路径：

```
上界剪枝示例：
已知最优完整计划成本：1000

搜索过程中：
计划片段1：A-B连接，成本=800
  可以继续：800 < 1000
  
计划片段2：C-D连接，成本=1200  
  可以剪枝：1200 > 1000，后续连接只会更贵

剪枝判断：
if 当前部分成本 + 乐观估计的剩余成本 > 最优解:
    剪枝这条路径
```

### 6.3 逻辑剪枝技术


**🔸 连接条件剪枝**
避免生成没有连接条件的笛卡尔积：

```
连接图分析：
表：A, B, C, D  
连接条件：A.id = B.aid, B.id = C.bid

连接图：
A ——— B ——— C    D（孤立）

剪枝规则：
• 不考虑A直接连接C（无连接条件）
• 不考虑任何表直接连接D  
• 优先考虑有连接条件的表组合
```

**🔸 语义剪枝**
基于查询语义来排除不合理的计划：

```
语义剪枝例子：
查询：SELECT * FROM A, B WHERE A.status = 'active' AND B.type = 'premium'

语义分析：
• A表过滤后预估10%的数据
• B表过滤后预估5%的数据

剪枝决策：
• 先应用过滤条件，再执行连接
• 避免先连接再过滤的低效计划
```

### 6.4 统计剪枝技术


**🔸 基数估算剪枝**
利用统计信息预估中间结果大小，剪枝明显低效的路径：

```
基数估算示例：
表A：100万行
表B：10万行，在连接字段上有索引
连接选择率：预估0.1%

方案1：A驱动B
• 扫描A：100万次磁盘I/O
• 查找B：100万次索引查找
• 预估成本：非常高

方案2：B驱动A  
• 扫描B：10万次磁盘I/O
• 查找A：10万次查找
• 预估成本：相对较低

剪枝决策：直接剪掉方案1
```

---

## 7. 📊 计划质量评估机制


### 7.1 质量评估的维度


**🔸 多维质量标准**
一个好的执行计划不仅要执行速度快，还要在多个维度上表现良好：

```
质量评估维度：
┌─────────────────────────────────────┐
│ 执行时间（主要指标）                │
│ • CPU时间：数据处理和计算时间        │
│ • I/O时间：磁盘读写等待时间          │
│ • 网络时间：分布式环境下的传输时间    │
├─────────────────────────────────────┤
│ 资源消耗                            │  
│ • 内存使用：临时表、排序缓冲区等     │
│ • 磁盘空间：临时文件、中间结果等     │
│ • CPU利用率：处理器负载情况          │
├─────────────────────────────────────┤
│ 稳定性                              │
│ • 对数据分布变化的敏感度            │
│ • 对系统负载变化的适应能力           │
│ • 极端情况下的表现                  │
└─────────────────────────────────────┘
```

### 7.2 成本模型详解


**🔸 成本计算公式**
数据库通过成本模型来量化评估执行计划的优劣：

```
基础成本公式：
总成本 = CPU成本 + I/O成本 + 网络成本

具体计算：
CPU成本 = 处理行数 × CPU处理单行成本
I/O成本 = 读取页数 × 单页读取成本  
网络成本 = 传输数据量 × 网络传输成本

权重调整：
总成本 = w1×CPU成本 + w2×I/O成本 + w3×网络成本
权重w1, w2, w3根据硬件特性和工作负载特点调整
```

**🔸 成本估算的挑战**
```
估算困难：
1. 统计信息过时
   • 表统计信息未及时更新
   • 数据分布发生显著变化

2. 复杂条件估算
   • 多个过滤条件的联合选择率
   • 函数和表达式的选择率

3. 中间结果大小
   • 连接结果大小难以准确预测
   • 聚合操作后的数据量估算

4. 系统状态影响
   • 缓冲池命中率的动态变化  
   • 并发负载对性能的影响
```

### 7.3 计划质量验证


**🔸 基准测试验证**
通过实际执行来验证计划质量的评估是否准确：

```
验证流程：
第1步：生成多个候选计划
第2步：使用成本模型排序
第3步：选择Top 3计划实际执行
第4步：对比预测成本vs实际成本
第5步：调整成本模型参数

验证指标：
• 成本预测准确率：|预测值-实际值|/实际值 < 20%
• 排序准确率：最优计划排序位置 <= 3
• 稳定性：多次执行结果的方差 < 10%
```

**🔸 反馈学习机制**
```
学习改进循环：
执行结果收集 → 成本模型调整 → 预测准确性提升 → 计划质量改善

具体实现：
• 慢查询日志分析
• 执行计划性能统计  
• 成本模型参数自适应调整
• 统计信息自动更新策略
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 执行计划生成基础**
```
核心概念回顾：
• 搜索空间：所有可能执行计划的集合
• 组合爆炸：计划数量随表数量指数级增长
• 优化目标：在有限时间内找到足够好的计划
• 质量权衡：优化时间 vs 计划质量的平衡
```

**🔸 算法策略分类**
```
算法选择指导：
┌─────────────────┬─────────────┬─────────────┐
│    查询复杂度    │   推荐算法   │   适用场景   │
├─────────────────┼─────────────┼─────────────┤
│   简单(2-4表)   │  动态规划    │  精确最优解  │
├─────────────────┼─────────────┼─────────────┤
│   中等(5-8表)   │  改进DP+剪枝 │  高质量解    │
├─────────────────┼─────────────┼─────────────┤
│   复杂(9+表)    │  启发式搜索  │  可行解      │
└─────────────────┴─────────────┴─────────────┘
```

### 8.2 关键优化策略


**🔸 动态规划优化要点**
```
DP算法核心：
✅ 最优子结构：利用已解决的子问题
✅ 重叠子问题：避免重复计算
✅ 有趣序保留：考虑排序等额外价值
✅ 及时剪枝：减少不必要的搜索
```

**🔸 启发式搜索原则**
```
启发式策略：
✅ 贪心选择：优先考虑代价最小的连接
✅ 遗传算法：适用于超大规模查询优化
✅ 模拟退火：避免陷入局部最优解
✅ 时间限制：确保优化过程可控
```

### 8.3 实践应用指导


**🔸 优化器调优建议**
```
调优检查清单：
□ 统计信息是否及时更新
□ 成本模型参数是否合理
□ 剪枝策略是否过于激进
□ 时间限制设置是否适当
□ 并行优化是否充分利用
```

**🔸 性能监控要点**
```
关键监控指标：
• 优化时间分布：90%的查询优化时间 < 50ms
• 计划质量稳定性：同类查询性能方差 < 15%
• 成本预测准确性：预测误差 < 30%
• 资源使用效率：优化器CPU使用率 < 5%
```

### 8.4 发展趋势与展望


**🔸 技术发展方向**
```
未来趋势：
🚀 机器学习驱动的成本估算
🚀 自适应优化器参数调整
🚀 分布式查询优化协同
🚀 实时查询计划调整
🚀 硬件感知的优化策略
```

**🔸 实际应用价值**
- **查询性能提升**：优化算法直接影响查询响应时间
- **系统资源节省**：高质量计划减少CPU、内存、I/O消耗
- **用户体验改善**：快速响应提升应用整体性能
- **运维成本降低**：减少因慢查询导致的系统问题

### 8.5 学习建议


> 🎓 **深入学习路径**

```
学习阶段规划：
第一阶段：理解基本概念和简单算法
第二阶段：掌握动态规划和启发式方法
第三阶段：学习剪枝技术和质量评估
第四阶段：实践复杂查询优化案例
第五阶段：研究前沿优化技术
```

**🔸 实践练习建议**
```
动手实验：
□ 实现简单的动态规划优化算法
□ 分析不同剪枝策略的效果
□ 对比启发式算法与精确算法的结果
□ 研究真实数据库的优化器行为
□ 设计适合特定场景的优化策略
```

**核心记忆口诀**：
> 📝 **动态规划解子问题，启发搜索抓重点**  
> **剪枝优化减空间，质量评估多维看**  
> **时间成本需平衡，实践验证是关键**