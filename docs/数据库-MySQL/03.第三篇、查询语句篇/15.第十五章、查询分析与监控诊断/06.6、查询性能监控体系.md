---
title: 6、查询性能监控体系
---
## 📚 目录

1. [查询性能监控概述](#1-查询性能监控概述)
2. [查询性能指标体系](#2-查询性能指标体系)
3. [慢查询日志分析](#3-慢查询日志分析)
4. [实时性能监控](#4-实时性能监控)
5. [性能趋势分析](#5-性能趋势分析)
6. [告警机制设计](#6-告警机制设计)
7. [监控工具与平台](#7-监控工具与平台)
8. [监控最佳实践](#8-监控最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 查询性能监控概述


### 1.1 性能监控的重要性


**🔸 为什么需要性能监控**
```
性能监控就像汽车的仪表盘
作用：实时了解数据库的健康状态
目标：及时发现问题，预防性能故障
价值：保障业务稳定运行，提升用户体验
```

**💡 性能问题的影响**
```
业务影响：
• 页面加载缓慢，用户体验差
• 系统响应超时，交易失败
• 并发能力下降，业务受限
• 数据库崩溃，服务中断

技术影响：
• CPU、内存、磁盘资源浪费
• 连接池耗尽，新连接被拒绝
• 锁等待增加，并发性能下降
• 主从延迟，数据一致性问题
```

### 1.2 监控体系架构


**🏗️ 完整监控架构**
```
数据采集层：
┌─────────────────────────────────────┐
│  MySQL内置监控  │  系统监控  │  业务监控  │
│  ·Performance   │  ·CPU使用率  │  ·QPS/TPS   │
│  ·Slow Log      │  ·内存使用率  │  ·响应时间   │
│  ·Error Log     │  ·磁盘I/O   │  ·错误率    │
└─────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────┐
│              数据处理层                │
│  ·数据聚合  ·趋势分析  ·异常检测      │
└─────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────┐
│              展示告警层                │
│  ·仪表板展示  ·报表生成  ·实时告警    │
└─────────────────────────────────────┘
```

### 1.3 监控数据来源


**📊 主要数据来源分类**
```
MySQL内置监控源：
• Performance Schema：详细的性能统计信息
• Information Schema：元数据和状态信息
• Slow Query Log：慢查询记录
• General Log：所有SQL执行记录
• Error Log：错误和警告信息
• Binary Log：数据变更记录

系统层监控源：
• 操作系统指标：CPU、内存、磁盘、网络
• 硬件指标：磁盘IOPS、网络带宽
• 进程指标：MySQL进程资源使用情况

应用层监控源：  
• 连接池状态：活跃连接数、等待连接数
• 应用响应时间：从发起请求到返回结果的时间
• 业务指标：订单量、用户访问量等
```

---

## 2. 📈 查询性能指标体系


### 2.1 核心性能指标


**⭐ 最重要的性能指标**
```
响应时间指标：
• 平均响应时间：所有查询的平均执行时间
• P95响应时间：95%查询的响应时间上限
• P99响应时间：99%查询的响应时间上限
• 最大响应时间：单个查询的最长执行时间

吞吐量指标：
• QPS (Queries Per Second)：每秒查询数
• TPS (Transactions Per Second)：每秒事务数  
• 连接数：当前活跃连接数
• 并发度：同时执行的查询数
```

**💻 指标查询示例**
```sql
-- 查看当前连接数和活跃查询
SHOW PROCESSLIST;
SELECT COUNT(*) as total_connections FROM information_schema.processlist;
SELECT COUNT(*) as active_queries FROM information_schema.processlist WHERE command != 'Sleep';

-- 查看QPS和TPS统计
SHOW GLOBAL STATUS LIKE 'Questions';  -- 总查询数
SHOW GLOBAL STATUS LIKE 'Com_commit';  -- 提交事务数
SHOW GLOBAL STATUS LIKE 'Com_rollback';  -- 回滚事务数

-- 查看慢查询统计
SHOW GLOBAL STATUS LIKE 'Slow_queries';
SHOW VARIABLES LIKE 'long_query_time';
```

### 2.2 资源使用指标


**🔧 系统资源监控指标**
```sql
-- InnoDB缓冲池使用情况
SELECT 
  VARIABLE_NAME,
  VARIABLE_VALUE,
  CASE 
    WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_total' THEN 
      ROUND(VARIABLE_VALUE * 16 / 1024, 2)
    WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_data' THEN 
      ROUND(VARIABLE_VALUE * 16 / 1024, 2)
    ELSE VARIABLE_VALUE
  END as value_mb
FROM information_schema.global_status 
WHERE VARIABLE_NAME IN (
  'Innodb_buffer_pool_pages_total',
  'Innodb_buffer_pool_pages_data', 
  'Innodb_buffer_pool_pages_free',
  'Innodb_buffer_pool_read_requests',
  'Innodb_buffer_pool_reads'
);

-- 临时表使用情况
SHOW GLOBAL STATUS LIKE 'Created_tmp%';

-- 锁等待情况
SELECT * FROM information_schema.innodb_locks;
SELECT * FROM information_schema.innodb_lock_waits;
```

### 2.3 业务层面指标


**📊 业务相关性能指标**
```sql
-- 创建性能监控指标表
CREATE TABLE performance_metrics (
  id INT AUTO_INCREMENT PRIMARY KEY,
  metric_time DATETIME,
  metric_name VARCHAR(50),
  metric_value DECIMAL(15,2),
  metric_unit VARCHAR(20),
  INDEX idx_time_name (metric_time, metric_name)
);

-- 记录关键业务指标
INSERT INTO performance_metrics (metric_time, metric_name, metric_value, metric_unit) VALUES
(NOW(), 'avg_response_time', 125.50, 'ms'),
(NOW(), 'qps', 2580.00, 'queries/sec'),
(NOW(), 'active_connections', 45.00, 'count'),
(NOW(), 'buffer_pool_hit_rate', 99.85, 'percent');

-- 指标趋势查询
SELECT 
  DATE_FORMAT(metric_time, '%H:%i') as time_point,
  AVG(CASE WHEN metric_name = 'qps' THEN metric_value END) as qps,
  AVG(CASE WHEN metric_name = 'avg_response_time' THEN metric_value END) as avg_response_ms,
  AVG(CASE WHEN metric_name = 'active_connections' THEN metric_value END) as connections
FROM performance_metrics
WHERE metric_time >= NOW() - INTERVAL 1 HOUR
GROUP BY DATE_FORMAT(metric_time, '%H:%i')
ORDER BY time_point;
```

### 2.4 指标阈值设定


**⚠️ 性能指标告警阈值**
```
响应时间阈值设定：
• 在线交易系统：平均响应时间 < 100ms，P95 < 200ms
• 报表查询系统：平均响应时间 < 1s，P95 < 5s  
• 批处理系统：平均响应时间 < 10s，P95 < 30s

资源使用阈值：
• CPU使用率：持续 > 70%需要关注，> 90%需要告警
• 内存使用率：> 80%需要关注，> 95%需要告警
• 磁盘使用率：> 80%需要关注，> 90%需要告警
• 连接数：> 80%最大连接数需要告警

业务指标阈值：
• QPS异常：比历史同期降低50%或增长200%
• 错误率：> 1%需要关注，> 5%需要紧急处理
• 锁等待：> 10秒需要告警
```

---

## 3. 📝 慢查询日志分析


### 3.1 慢查询日志配置


**🔧 启用慢查询日志**
```sql
-- 查看当前慢查询配置
SHOW VARIABLES LIKE '%slow%';
SHOW VARIABLES LIKE 'long_query_time';

-- 启用慢查询日志
SET GLOBAL slow_query_log = ON;
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录
SET GLOBAL log_queries_not_using_indexes = ON;  -- 记录未使用索引的查询

-- 永久配置（在my.cnf中）
[mysqld]
slow_query_log = ON
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 2
log_queries_not_using_indexes = ON
min_examined_row_limit = 1000  -- 至少扫描1000行才记录
```

### 3.2 慢查询日志格式解析


**📋 慢查询日志内容解析**
```
# 典型慢查询日志格式：
# Time: 2025-09-03T15:30:15.123456Z
# User@Host: app_user[app_user] @ [192.168.1.100]
# Thread_id: 12345  Schema: ecommerce  QC_hit: No
# Query_time: 5.123456  Lock_time: 0.000123  Rows_sent: 1500  Rows_examined: 150000
# Rows_affected: 0  Bytes_sent: 75000
SET timestamp=1693747815;
SELECT o.*, u.username, p.product_name 
FROM orders o 
JOIN users u ON o.user_id = u.id 
JOIN products p ON o.product_id = p.id 
WHERE o.created_at > '2025-09-01' 
ORDER BY o.created_at DESC;

关键字段说明：
• Query_time: 查询总执行时间
• Lock_time: 等待锁的时间
• Rows_sent: 返回的行数  
• Rows_examined: 扫描的行数
• Rows_affected: 影响的行数（INSERT/UPDATE/DELETE）
```

### 3.3 慢查询分析工具


**🛠️ mysqldumpslow工具使用**
```bash
# 分析慢查询日志的基本用法
mysqldumpslow /var/log/mysql/slow.log

# 按查询次数排序，显示前10个最频繁的慢查询
mysqldumpslow -s c -t 10 /var/log/mysql/slow.log

# 按平均执行时间排序，显示最慢的10个查询
mysqldumpslow -s at -t 10 /var/log/mysql/slow.log

# 按总执行时间排序，显示占用时间最多的查询
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# 只显示包含特定关键字的查询
mysqldumpslow -g 'SELECT.*ORDER BY' /var/log/mysql/slow.log

# 输出详细信息
mysqldumpslow -v -t 5 /var/log/mysql/slow.log
```

### 3.4 慢查询统计分析


**📊 慢查询统计查询**
```sql
-- 使用performance_schema分析慢查询
SELECT 
  DIGEST_TEXT as query_pattern,
  COUNT_STAR as exec_count,
  ROUND(AVG_TIMER_WAIT / 1000000000000, 3) as avg_exec_time_sec,
  ROUND(MAX_TIMER_WAIT / 1000000000000, 3) as max_exec_time_sec,
  ROUND(SUM_TIMER_WAIT / 1000000000000, 3) as total_exec_time_sec,
  ROUND(AVG_ROWS_EXAMINED) as avg_rows_examined,
  ROUND(AVG_ROWS_SENT) as avg_rows_sent
FROM performance_schema.events_statements_summary_by_digest
WHERE AVG_TIMER_WAIT > 2000000000000  -- 超过2秒的查询
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;

-- 按数据库分组的慢查询统计
SELECT 
  SCHEMA_NAME,
  COUNT_STAR as slow_query_count,
  ROUND(SUM_TIMER_WAIT / 1000000000000, 2) as total_time_sec,
  ROUND(AVG_TIMER_WAIT / 1000000000000, 3) as avg_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME IS NOT NULL 
  AND AVG_TIMER_WAIT > 1000000000000  -- 超过1秒
GROUP BY SCHEMA_NAME
ORDER BY total_time_sec DESC;
```

---

## 4. ⚡ 实时性能监控


### 4.1 实时监控指标获取


**📊 关键实时指标查询**
```sql
-- 实时连接状态监控
SELECT 
  command,
  state,
  COUNT(*) as connection_count,
  AVG(time) as avg_time_sec
FROM information_schema.processlist 
GROUP BY command, state
ORDER BY connection_count DESC;

-- 实时锁等待监控
SELECT 
  r.trx_id as requesting_trx,
  r.trx_mysql_thread_id as requesting_thread,
  r.trx_query as requesting_query,
  b.trx_id as blocking_trx,
  b.trx_mysql_thread_id as blocking_thread,
  b.trx_query as blocking_query,
  l.lock_table,
  l.lock_mode,
  w.requesting_trx_id,
  w.blocking_trx_id
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id
JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
JOIN information_schema.innodb_locks l ON l.lock_trx_id = w.blocking_trx_id;
```

### 4.2 性能状态变量监控


**🔍 重要状态变量实时监控**
```sql
-- 创建实时监控存储过程
DELIMITER //
CREATE PROCEDURE GetRealTimeMetrics()
BEGIN
  -- QPS计算
  SELECT 
    'QPS' as metric_name,
    VARIABLE_VALUE as current_queries,
    @prev_queries as previous_queries,
    CASE 
      WHEN @prev_queries IS NOT NULL 
      THEN VARIABLE_VALUE - @prev_queries
      ELSE 0 
    END as qps_last_second
  FROM information_schema.global_status 
  WHERE VARIABLE_NAME = 'Questions';
  
  -- 设置上次查询数
  SELECT VARIABLE_VALUE INTO @prev_queries 
  FROM information_schema.global_status 
  WHERE VARIABLE_NAME = 'Questions';
  
  -- 缓冲池命中率
  SELECT 
    'Buffer Pool Hit Rate' as metric_name,
    ROUND(
      (1 - (
        (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
        (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
      )) * 100, 
      2
    ) as hit_rate_percent;
    
  -- 当前活跃事务
  SELECT 
    'Active Transactions' as metric_name,
    COUNT(*) as active_trx_count
  FROM information_schema.innodb_trx;
END //
DELIMITER ;

-- 调用实时监控
CALL GetRealTimeMetrics();
```

### 4.3 实时告警触发


**🚨 实时告警逻辑**
```sql
-- 创建告警检查存储过程
DELIMITER //
CREATE PROCEDURE CheckPerformanceAlerts()
BEGIN
  DECLARE alert_message TEXT DEFAULT '';
  DECLARE active_connections INT;
  DECLARE slow_query_count INT;
  DECLARE lock_wait_count INT;
  
  -- 检查活跃连接数
  SELECT COUNT(*) INTO active_connections 
  FROM information_schema.processlist 
  WHERE command != 'Sleep';
  
  IF active_connections > 100 THEN
    SET alert_message = CONCAT(alert_message, '告警：活跃连接数过高(', active_connections, ');');
  END IF;
  
  -- 检查慢查询数量
  SELECT COUNT(*) INTO slow_query_count
  FROM information_schema.processlist 
  WHERE time > 10 AND command = 'Query';
  
  IF slow_query_count > 5 THEN
    SET alert_message = CONCAT(alert_message, '告警：当前慢查询过多(', slow_query_count, ');');
  END IF;
  
  -- 检查锁等待
  SELECT COUNT(*) INTO lock_wait_count
  FROM information_schema.innodb_lock_waits;
  
  IF lock_wait_count > 0 THEN
    SET alert_message = CONCAT(alert_message, '告警：存在锁等待(', lock_wait_count, ');');
  END IF;
  
  -- 输出告警信息
  IF LENGTH(alert_message) > 0 THEN
    SELECT NOW() as alert_time, alert_message as alerts;
  ELSE
    SELECT NOW() as check_time, '系统状态正常' as status;
  END IF;
END //
DELIMITER ;

-- 定期执行告警检查（配合定时任务）
CALL CheckPerformanceAlerts();
```

---

## 5. 📈 性能趋势分析


### 5.1 历史性能数据收集


**📊 性能数据采集设计**
```sql
-- 创建性能历史数据表
CREATE TABLE performance_history (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  collect_time DATETIME NOT NULL,
  metric_category VARCHAR(50) NOT NULL,  -- 'connection', 'query', 'resource', 'innodb'
  metric_name VARCHAR(100) NOT NULL,
  metric_value DECIMAL(20,4) NOT NULL,
  metric_unit VARCHAR(20),
  server_id VARCHAR(50) DEFAULT 'default',
  
  INDEX idx_time_category (collect_time, metric_category),
  INDEX idx_category_name (metric_category, metric_name),
  INDEX idx_server_time (server_id, collect_time)
);

-- 性能数据采集存储过程
DELIMITER //
CREATE PROCEDURE CollectPerformanceMetrics()
BEGIN
  DECLARE current_time DATETIME DEFAULT NOW();
  
  -- 采集连接相关指标
  INSERT INTO performance_history (collect_time, metric_category, metric_name, metric_value, metric_unit)
  SELECT 
    current_time, 'connection', 'active_connections', 
    COUNT(*), 'count'
  FROM information_schema.processlist WHERE command != 'Sleep';
  
  INSERT INTO performance_history (collect_time, metric_category, metric_name, metric_value, metric_unit)
  SELECT 
    current_time, 'connection', 'total_connections', 
    COUNT(*), 'count'
  FROM information_schema.processlist;
  
  -- 采集查询相关指标
  INSERT INTO performance_history (collect_time, metric_category, metric_name, metric_value, metric_unit)
  SELECT 
    current_time, 'query', 'questions_total', 
    VARIABLE_VALUE, 'count'
  FROM information_schema.global_status WHERE VARIABLE_NAME = 'Questions';
  
  -- 采集InnoDB相关指标
  INSERT INTO performance_history (collect_time, metric_category, metric_name, metric_value, metric_unit)
  SELECT 
    current_time, 'innodb', 'buffer_pool_hit_rate',
    ROUND(
      (1 - (bp_reads.VARIABLE_VALUE / bp_read_requests.VARIABLE_VALUE)) * 100, 
      4
    ), 'percent'
  FROM 
    (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') bp_reads,
    (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') bp_read_requests
  WHERE bp_read_requests.VARIABLE_VALUE > 0;
  
END //
DELIMITER ;
```

### 5.2 趋势分析查询


**📈 性能趋势分析**
```sql
-- 过去24小时的QPS趋势
SELECT 
  DATE_FORMAT(collect_time, '%H:%i') as time_hour,
  AVG(metric_value) as avg_qps,
  MIN(metric_value) as min_qps,
  MAX(metric_value) as max_qps
FROM (
  SELECT 
    collect_time,
    metric_value - LAG(metric_value) OVER (ORDER BY collect_time) as metric_value
  FROM performance_history 
  WHERE metric_name = 'questions_total' 
    AND collect_time >= NOW() - INTERVAL 24 HOUR
) qps_data
WHERE metric_value > 0
GROUP BY DATE_FORMAT(collect_time, '%H:%i')
ORDER BY time_hour;

-- 连接数趋势对比（本周vs上周）
SELECT 
  HOUR(collect_time) as hour_of_day,
  AVG(CASE WHEN collect_time >= NOW() - INTERVAL 7 DAY THEN metric_value END) as this_week_avg,
  AVG(CASE WHEN collect_time BETWEEN NOW() - INTERVAL 14 DAY AND NOW() - INTERVAL 7 DAY 
           THEN metric_value END) as last_week_avg,
  ROUND(
    (AVG(CASE WHEN collect_time >= NOW() - INTERVAL 7 DAY THEN metric_value END) -
     AVG(CASE WHEN collect_time BETWEEN NOW() - INTERVAL 14 DAY AND NOW() - INTERVAL 7 DAY THEN metric_value END)) /
    AVG(CASE WHEN collect_time BETWEEN NOW() - INTERVAL 14 DAY AND NOW() - INTERVAL 7 DAY THEN metric_value END) * 100,
    2
  ) as growth_percent
FROM performance_history
WHERE metric_name = 'active_connections'
  AND collect_time >= NOW() - INTERVAL 14 DAY
GROUP BY HOUR(collect_time)
ORDER BY hour_of_day;
```

### 5.3 异常趋势检测


**🔍 自动异常检测**
```sql
-- 基于历史数据的异常检测
SELECT 
  current_metrics.*,
  historical_stats.*,
  CASE 
    WHEN current_metrics.current_value > historical_stats.avg_value + 2 * historical_stats.std_value 
    THEN '异常偏高'
    WHEN current_metrics.current_value < historical_stats.avg_value - 2 * historical_stats.std_value 
    THEN '异常偏低'
    ELSE '正常'
  END as anomaly_status
FROM (
  -- 当前指标值
  SELECT 
    metric_name,
    metric_value as current_value,
    collect_time as current_time
  FROM performance_history 
  WHERE collect_time >= NOW() - INTERVAL 5 MINUTE
    AND metric_category = 'connection'
) current_metrics
JOIN (
  -- 历史统计值
  SELECT 
    metric_name,
    AVG(metric_value) as avg_value,
    STDDEV(metric_value) as std_value,
    MIN(metric_value) as min_value,
    MAX(metric_value) as max_value
  FROM performance_history 
  WHERE collect_time BETWEEN NOW() - INTERVAL 30 DAY AND NOW() - INTERVAL 1 DAY
    AND metric_category = 'connection'
    AND HOUR(collect_time) = HOUR(NOW())  -- 同一小时的历史数据
  GROUP BY metric_name
) historical_stats ON current_metrics.metric_name = historical_stats.metric_name;
```

---

## 6. 🚨 告警机制设计


### 6.1 多级告警策略


**⚠️ 告警级别定义**
```
告警级别设计：

INFO（信息级别）：
• 触发条件：性能指标轻微异常
• 处理方式：记录日志，无需人工干预
• 示例：QPS比平时高20%

WARNING（警告级别）：
• 触发条件：性能指标明显异常，但系统仍可正常运行
• 处理方式：发送邮件通知，建议关注
• 示例：连接数超过80%最大值

CRITICAL（严重级别）：
• 触发条件：性能指标严重异常，影响系统稳定性
• 处理方式：立即短信+电话通知，需要紧急处理
• 示例：连接数达到95%，大量慢查询

EMERGENCY（紧急级别）：
• 触发条件：系统几乎不可用
• 处理方式：多渠道通知所有相关人员
• 示例：数据库无法连接，服务完全中断
```

### 6.2 告警规则配置


**🔧 告警规则设计**
```sql
-- 创建告警规则配置表
CREATE TABLE alert_rules (
  id INT AUTO_INCREMENT PRIMARY KEY,
  rule_name VARCHAR(100) NOT NULL,
  metric_category VARCHAR(50),
  metric_name VARCHAR(100),
  alert_level ENUM('INFO', 'WARNING', 'CRITICAL', 'EMERGENCY'),
  condition_operator ENUM('>', '<', '>=', '<=', '=', '!='),
  threshold_value DECIMAL(20,4),
  duration_minutes INT DEFAULT 1,  -- 持续时间
  enabled BOOLEAN DEFAULT TRUE,
  notification_channels JSON,  -- 通知渠道配置
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 插入告警规则示例
INSERT INTO alert_rules (rule_name, metric_category, metric_name, alert_level, condition_operator, threshold_value, duration_minutes, notification_channels) VALUES
('连接数告警', 'connection', 'active_connections', 'WARNING', '>', 100, 3, '["email", "sms"]'),
('缓冲池命中率告警', 'innodb', 'buffer_pool_hit_rate', 'CRITICAL', '<', 95.0, 5, '["email", "sms", "phone"]'),
('慢查询告警', 'query', 'slow_query_count', 'WARNING', '>', 10, 2, '["email"]'),
('QPS异常告警', 'query', 'qps', 'INFO', '>', 5000, 1, '["email"]');

-- 告警检查存储过程
DELIMITER //
CREATE PROCEDURE CheckAlertRules()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE rule_id INT;
  DECLARE rule_name VARCHAR(100);
  DECLARE metric_cat VARCHAR(50);
  DECLARE metric_nm VARCHAR(100);
  DECLARE alert_lv VARCHAR(20);
  DECLARE condition_op VARCHAR(5);
  DECLARE threshold_val DECIMAL(20,4);
  DECLARE duration_min INT;
  
  DECLARE rule_cursor CURSOR FOR 
    SELECT id, rule_name, metric_category, metric_name, alert_level, condition_operator, threshold_value, duration_minutes
    FROM alert_rules WHERE enabled = TRUE;
    
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
  
  OPEN rule_cursor;
  
  rule_loop: LOOP
    FETCH rule_cursor INTO rule_id, rule_name, metric_cat, metric_nm, alert_lv, condition_op, threshold_val, duration_min;
    
    IF done THEN
      LEAVE rule_loop;
    END IF;
    
    -- 检查告警条件（简化逻辑）
    SET @sql = CONCAT('SELECT COUNT(*) INTO @violation_count FROM performance_history WHERE metric_category = "', metric_cat, '" AND metric_name = "', metric_nm, '" AND collect_time >= NOW() - INTERVAL ', duration_min, ' MINUTE AND metric_value ', condition_op, ' ', threshold_val);
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 如果违反告警条件，记录告警
    IF @violation_count > 0 THEN
      INSERT INTO alert_history (rule_id, rule_name, alert_level, triggered_at, alert_message)
      VALUES (rule_id, rule_name, alert_lv, NOW(), CONCAT(rule_name, '触发，阈值：', threshold_val));
    END IF;
    
  END LOOP;
  
  CLOSE rule_cursor;
END //
DELIMITER ;
```

### 6.3 告警通知机制


**📢 多渠道通知设计**
```sql
-- 创建告警历史记录表
CREATE TABLE alert_history (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  rule_id INT,
  rule_name VARCHAR(100),
  alert_level ENUM('INFO', 'WARNING', 'CRITICAL', 'EMERGENCY'),
  triggered_at TIMESTAMP,
  resolved_at TIMESTAMP NULL,
  alert_message TEXT,
  notification_sent BOOLEAN DEFAULT FALSE,
  notification_channels JSON,
  status ENUM('ACTIVE', 'RESOLVED', 'SUPPRESSED') DEFAULT 'ACTIVE',
  
  INDEX idx_triggered_at (triggered_at),
  INDEX idx_status (status),
  INDEX idx_alert_level (alert_level)
);

-- 告警抑制机制（防止告警风暴）
DELIMITER //
CREATE FUNCTION ShouldSendAlert(rule_id INT, alert_level VARCHAR(20)) 
RETURNS BOOLEAN
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE recent_count INT DEFAULT 0;
  DECLARE suppression_minutes INT DEFAULT 5;
  
  -- 根据告警级别设置抑制时间
  CASE alert_level
    WHEN 'INFO' THEN SET suppression_minutes = 30;
    WHEN 'WARNING' THEN SET suppression_minutes = 15;
    WHEN 'CRITICAL' THEN SET suppression_minutes = 5;
    WHEN 'EMERGENCY' THEN SET suppression_minutes = 1;
  END CASE;
  
  -- 检查最近是否已发送过相同告警
  SELECT COUNT(*) INTO recent_count
  FROM alert_history 
  WHERE rule_id = rule_id 
    AND triggered_at >= NOW() - INTERVAL suppression_minutes MINUTE
    AND notification_sent = TRUE;
    
  RETURN recent_count = 0;
END //
DELIMITER ;

-- 告警发送逻辑
DELIMITER //
CREATE PROCEDURE ProcessPendingAlerts()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE alert_id BIGINT;
  DECLARE alert_level VARCHAR(20);
  DECLARE alert_message TEXT;
  DECLARE rule_id INT;
  
  DECLARE alert_cursor CURSOR FOR 
    SELECT id, rule_id, alert_level, alert_message
    FROM alert_history 
    WHERE notification_sent = FALSE 
      AND status = 'ACTIVE'
    ORDER BY triggered_at DESC;
    
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
  
  OPEN alert_cursor;
  
  alert_loop: LOOP
    FETCH alert_cursor INTO alert_id, rule_id, alert_level, alert_message;
    
    IF done THEN
      LEAVE alert_loop;
    END IF;
    
    -- 检查是否应该发送告警
    IF ShouldSendAlert(rule_id, alert_level) THEN
      -- 这里集成实际的通知发送逻辑
      -- 例如：调用邮件服务、短信服务等
      
      UPDATE alert_history 
      SET notification_sent = TRUE 
      WHERE id = alert_id;
      
      -- 记录通知发送日志
      INSERT INTO notification_log (alert_id, sent_at, channels, status)
      VALUES (alert_id, NOW(), '["email"]', 'SUCCESS');
    END IF;
    
  END LOOP;
  
  CLOSE alert_cursor;
END //
DELIMITER ;
```

---

## 7. 🛠️ 监控工具与平台


### 7.1 开源监控解决方案


**🔧 主流开源工具对比**
```
Prometheus + Grafana：
• 优势：功能强大，可视化效果好，社区活跃
• 适用：中大型项目，需要定制化监控
• 配置：需要安装mysqld_exporter采集数据
• 学习成本：中等

Zabbix：
• 优势：监控项目完善，告警功能强大
• 适用：传统企业环境，全面监控需求
• 配置：模板丰富，配置相对简单
• 学习成本：较低

Nagios：
• 优势：老牌监控工具，稳定可靠
• 适用：基础设施监控，告警为主
• 配置：配置文件管理，扩展性好
• 学习成本：较高

Telegraf + InfluxDB + Grafana：
• 优势：时序数据库，高性能存储
• 适用：大数据量监控，时序分析
• 配置：链条较长，需要多组件配合
• 学习成本：中等
```

### 7.2 云平台监控服务


**☁️ 云平台监控对比**
```sql
-- 云平台监控特点：

阿里云RDS监控：
• 内置监控：CPU、内存、连接数、IOPS等
• 慢查询分析：自动收集和分析
• 告警功能：多种通知方式
• 成本：随RDS实例，无额外费用

腾讯云CDB监控：
• 性能洞察：实时性能分析
• 智能巡检：自动发现性能问题
• 一键诊断：快速定位性能瓶颈
• 成本：基础监控免费，高级功能收费

AWS RDS Performance Insights：
• 详细性能指标：等待事件分析
• 历史性能对比：性能趋势分析
• SQL级别监控：单个查询分析
• 成本：按使用量计费

自建 vs 云平台选择建议：
• 小型项目：优先选择云平台监控
• 大型项目：自建监控，更灵活
• 混合环境：云平台+自建监控结合
```

### 7.3 监控工具集成


**🔗 监控工具配置示例**
```yaml
# Prometheus配置示例 (prometheus.yml)
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'mysql'
    static_configs:
      - targets: ['localhost:9104']  # mysqld_exporter端口
    scrape_interval: 10s
    metrics_path: /metrics

# mysqld_exporter启动配置
export DATA_SOURCE_NAME="monitor_user:password@(localhost:3306)/"
./mysqld_exporter --web.listen-address=:9104

# Grafana仪表板JSON配置（简化）
{
  "dashboard": {
    "title": "MySQL Performance Dashboard",
    "panels": [
      {
        "title": "QPS",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(mysql_global_status_questions[5m])",
            "legendFormat": "Queries Per Second"
          }
        ]
      },
      {
        "title": "Active Connections",
        "type": "singlestat",
        "targets": [
          {
            "expr": "mysql_global_status_threads_connected",
            "legendFormat": "Active Connections"
          }
        ]
      }
    ]
  }
}
```

---

## 8. 📚 监控最佳实践


### 8.1 监控指标选择原则


**🎯 指标选择最佳实践**
```
指标选择原则：

业务相关性：
✅ 选择与业务直接相关的指标
✅ 关注用户体验相关的响应时间
✅ 监控关键业务流程的成功率

可操作性：
✅ 选择可以通过调优改善的指标
✅ 避免监控无法控制的外部因素
✅ 关注瓶颈识别相关的指标

成本效益：
✅ 避免过度监控，增加系统负担
✅ 重点监控高价值指标
✅ 合理设置监控频率

指标层次设计：
• Level 1：核心业务指标（QPS、响应时间、错误率）
• Level 2：资源使用指标（CPU、内存、连接数）
• Level 3：详细性能指标（缓冲池、锁、慢查询）
• Level 4：诊断调试指标（具体SQL、执行计划）
```

### 8.2 监控数据治理


**📊 数据治理策略**
```sql
-- 监控数据保留策略
CREATE EVENT cleanup_performance_history
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_TIMESTAMP
DO
BEGIN
  -- 删除30天前的详细性能数据
  DELETE FROM performance_history 
  WHERE collect_time < NOW() - INTERVAL 30 DAY;
  
  -- 删除7天前的告警历史（已解决的）
  DELETE FROM alert_history 
  WHERE triggered_at < NOW() - INTERVAL 7 DAY 
    AND status = 'RESOLVED';
  
  -- 删除1天前的通知日志
  DELETE FROM notification_log 
  WHERE sent_at < NOW() - INTERVAL 1 DAY;
END;

-- 数据聚合存储（降低存储成本）
CREATE TABLE performance_history_hourly (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  hour_time DATETIME NOT NULL,
  metric_category VARCHAR(50),
  metric_name VARCHAR(100),
  avg_value DECIMAL(20,4),
  min_value DECIMAL(20,4),
  max_value DECIMAL(20,4),
  sample_count INT,
  
  UNIQUE KEY uk_hour_metric (hour_time, metric_category, metric_name)
);

-- 数据聚合存储过程
DELIMITER //
CREATE PROCEDURE AggregateHourlyMetrics()
BEGIN
  INSERT INTO performance_history_hourly (
    hour_time, metric_category, metric_name, 
    avg_value, min_value, max_value, sample_count
  )
  SELECT 
    DATE_FORMAT(collect_time, '%Y-%m-%d %H:00:00') as hour_time,
    metric_category,
    metric_name,
    AVG(metric_value) as avg_value,
    MIN(metric_value) as min_value,
    MAX(metric_value) as max_value,
    COUNT(*) as sample_count
  FROM performance_history
  WHERE collect_time >= NOW() - INTERVAL 2 HOUR
    AND collect_time < NOW() - INTERVAL 1 HOUR
  GROUP BY 
    DATE_FORMAT(collect_time, '%Y-%m-%d %H:00:00'),
    metric_category,
    metric_name
  ON DUPLICATE KEY UPDATE
    avg_value = VALUES(avg_value),
    min_value = VALUES(min_value),
    max_value = VALUES(max_value),
    sample_count = VALUES(sample_count);
END //
DELIMITER ;
```

### 8.3 监控运维自动化


**🤖 自动化运维实践**
```sql
-- 自动性能调优建议
DELIMITER //
CREATE PROCEDURE GeneratePerformanceRecommendations()
BEGIN
  DECLARE recommendation TEXT DEFAULT '';
  
  -- 检查缓冲池命中率
  SELECT 
    CASE 
      WHEN AVG(metric_value) < 95 THEN 
        CONCAT('建议增加innodb_buffer_pool_size，当前命中率：', ROUND(AVG(metric_value), 2), '%')
      ELSE NULL
    END INTO @buffer_pool_rec
  FROM performance_history 
  WHERE metric_name = 'buffer_pool_hit_rate' 
    AND collect_time >= NOW() - INTERVAL 1 HOUR;
    
  -- 检查连接数使用率
  SELECT 
    CASE 
      WHEN MAX(metric_value) > (
        SELECT VARIABLE_VALUE * 0.8 
        FROM information_schema.global_variables 
        WHERE VARIABLE_NAME = 'max_connections'
      ) THEN 
        CONCAT('建议增加max_connections，当前峰值：', MAX(metric_value))
      ELSE NULL
    END INTO @connection_rec
  FROM performance_history 
  WHERE metric_name = 'active_connections' 
    AND collect_time >= NOW() - INTERVAL 1 HOUR;
    
  -- 输出建议
  SELECT 
    NOW() as analysis_time,
    COALESCE(@buffer_pool_rec, '缓冲池性能正常') as buffer_pool_recommendation,
    COALESCE(@connection_rec, '连接数配置正常') as connection_recommendation;
END //
DELIMITER ;

-- 自动健康检查
DELIMITER //
CREATE PROCEDURE SystemHealthCheck()
BEGIN
  SELECT 
    'MySQL健康检查报告' as report_title,
    NOW() as check_time;
    
  -- 检查复制状态
  SELECT 
    'Replication Status' as check_item,
    CASE 
      WHEN $$read_only = 1 THEN '从库模式'
      ELSE '主库模式'
    END as status;
    
  -- 检查慢查询
  SELECT 
    'Slow Query Check' as check_item,
    VARIABLE_VALUE as slow_query_count,
    CASE 
      WHEN VARIABLE_VALUE > 100 THEN '需要关注'
      ELSE '正常'
    END as status
  FROM information_schema.global_status 
  WHERE VARIABLE_NAME = 'Slow_queries';
  
  -- 检查错误日志
  SELECT 
    'Error Log Check' as check_item,
    COUNT(*) as recent_errors
  FROM mysql.general_log 
  WHERE event_time >= NOW() - INTERVAL 1 HOUR 
    AND command_type = 'Error';
END //
DELIMITER ;

-- 定期执行健康检查（配合cron任务）
-- 0 */6 * * * mysql -e "CALL SystemHealthCheck();" > /var/log/mysql_health_check.log
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


**🔸 性能监控体系理解**
```
监控架构三层：
• 数据采集层：Performance Schema、慢查询日志、状态变量
• 数据处理层：指标计算、趋势分析、异常检测  
• 展示告警层：仪表板、报表、实时告警

核心监控指标：
• 响应时间：平均、P95、P99、最大响应时间
• 吞吐量：QPS、TPS、连接数、并发度
• 资源使用：CPU、内存、磁盘I/O、网络
• 数据库特有：缓冲池命中率、锁等待、慢查询数
```

**🔸 慢查询分析精髓**
```
慢查询日志配置：
• long_query_time：设置慢查询时间阈值
• log_queries_not_using_indexes：记录未使用索引的查询
• min_examined_row_limit：设置最小扫描行数

分析工具使用：
• mysqldumpslow：官方分析工具
• Performance Schema：实时性能统计
• 第三方工具：pt-query-digest、MySQLTuner

关键分析维度：
• 查询频率：哪些查询执行最频繁
• 执行时间：哪些查询最慢
• 扫描行数：哪些查询效率最低
• 锁等待时间：哪些查询产生阻塞
```

### 9.2 关键理解要点


**🔹 实时监控vs历史分析**
```
实时监控特点：
• 目标：及时发现和处理当前问题
• 数据源：当前状态变量、活跃进程列表
• 时效性：秒级到分钟级更新
• 应用：故障处理、性能调优

历史分析特点：
• 目标：发现趋势、预测问题、容量规划
• 数据源：历史性能数据、聚合统计
• 时效性：小时级到天级分析
• 应用：趋势分析、容量规划、问题定位

结合使用：
实时监控发现问题 → 历史分析找出根因 → 优化配置解决问题
```

**🔹 告警机制设计原则**
```
告警级别设计：
• 避免告警疲劳：不要设置过多低级别告警
• 渐进式升级：从信息→警告→严重→紧急
• 业务影响导向：根据对业务的影响程度分级

告警规则设计：
• 基于趋势：相对阈值比绝对阈值更有效
• 持续时间：避免瞬时波动引起的误报
• 抑制机制：防止告警风暴
• 自动恢复：问题解决后自动取消告警

通知策略：
• 分组通知：不同级别通知不同人群
• 时间窗口：非工作时间调整通知策略  
• 升级机制：长时间未处理自动升级
```

### 9.3 实际应用指导


**💼 监控实施最佳实践**
```
监控指标选择：
✅ 从业务角度选择核心指标
✅ 关注用户体验相关指标
✅ 平衡监控成本和收益
✅ 分层监控，重点突出

工具选择策略：
• 小型项目：云平台监控 + 简单自建
• 中型项目：开源方案（Prometheus+Grafana）
• 大型项目：定制化监控平台
• 企业级：商业监控解决方案

数据治理：
✅ 设置合理的数据保留策略
✅ 实施数据聚合降低存储成本
✅ 定期清理历史数据
✅ 备份重要监控配置
```

### 9.4 常见问题与解决方案


**⚠️ 监控实施常见陷阱**
```
过度监控陷阱：
❌ 监控所有可监控的指标
✅ 只监控有价值的指标

告警风暴陷阱：
❌ 阈值设置过低，频繁误报
✅ 合理设置阈值和抑制机制

监控盲区陷阱：
❌ 只监控数据库，忽略应用层
✅ 端到端监控，覆盖全链路

历史数据陷阱：
❌ 无限制保存所有监控数据
✅ 分级保存，定期清理

工具依赖陷阱：
❌ 完全依赖单一监控工具
✅ 多工具结合，相互验证
```

**🔧 监控故障排查指南**
```
监控系统自身故障：
1. 检查监控进程是否运行正常
2. 验证数据采集是否正常
3. 确认存储空间是否充足
4. 检查网络连接是否正常

告警不准确问题：
1. 验证阈值设置是否合理
2. 检查数据采集频率
3. 确认告警规则逻辑
4. 分析历史数据趋势

性能监控影响数据库：
1. 调整监控频率
2. 优化监控查询
3. 使用只读账户
4. 限制并发监控连接
```

**🧠 记忆要点**
```
监控实施口诀：
"指标选择要精准，告警设置要合理，实时历史相结合，工具选择看规模"

故障处理口诀：
"先看监控后操作，数据说话最重要，趋势分析找根因，自动化让运维高效"

性能优化口诀：
"慢查询是突破口，资源监控是基础，趋势分析防未然，告警及时保稳定"
```

**🎯 核心记忆**
- 性能监控是数据库运维的基础，要建立完整的监控体系
- 慢查询分析是性能优化的重要手段，要定期分析和优化
- 实时监控解决当前问题，历史分析预防未来问题
- 告警机制要平衡及时性和准确性，避免告警疲劳
- 监控工具选择要结合项目规模和团队技术栈
- 监控数据要合理治理，平衡存储成本和分析需求