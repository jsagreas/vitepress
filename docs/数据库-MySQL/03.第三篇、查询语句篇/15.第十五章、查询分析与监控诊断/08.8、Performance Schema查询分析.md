---
title: 8、Performance Schema查询分析
---
## 📚 目录

1. [Performance Schema基本概念](#1-Performance-Schema基本概念)
2. [查询执行事件分析](#2-查询执行事件分析)
3. [events_statements核心表详解](#3-events_statements核心表详解)
4. [SQL性能剖析实战](#4-SQL性能剖析实战)
5. [查询分类统计分析](#5-查询分类统计分析)
6. [性能监控最佳实践](#6-性能监控最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 Performance Schema基本概念


### 1.1 什么是Performance Schema


**📋 简单理解**
Performance Schema就像MySQL数据库的"体检报告系统"，实时监控数据库的各种性能指标。

```
生活类比：
医院体检系统 → Performance Schema
各项检查指标 → 性能监控表
体检报告    → 性能分析结果

目的：及时发现问题，优化数据库性能
```

**🔧 技术定义**
```
Performance Schema：
• MySQL内置的性能监控引擎
• 提供运行时性能数据收集
• 以数据库表的形式存储监控信息
• 支持SQL查询方式分析性能数据
```

### 1.2 Performance Schema的核心价值


**💡 解决的关键问题**

```
传统性能分析困难：
❌ 慢查询日志只记录超过阈值的查询
❌ 缺少实时性能数据
❌ 难以分析查询执行的详细过程
❌ 无法统计各类查询的整体表现

Performance Schema优势：
✅ 实时收集所有查询的执行数据
✅ 详细记录查询执行的各个阶段
✅ 提供丰富的统计和分析维度
✅ 支持灵活的SQL查询分析
```

### 1.3 Performance Schema架构概览


**🏗️ 整体架构设计**
```
Performance Schema架构图：

应用程序执行SQL
        ↓
MySQL服务器执行引擎
        ↓
Performance Schema收集器
        ↓
┌─────────────────────────────────┐
│        Performance Schema       │
├─────────────────────────────────┤
│ • events_statements_*   (语句)  │
│ • events_waits_*       (等待)   │
│ • events_stages_*      (阶段)   │
│ • events_transactions_* (事务)  │
│ • setup_*             (配置)   │
└─────────────────────────────────┘
        ↓
SQL查询分析和报告
```

**🎨 核心组件说明**
```
收集器层面：
• 事件收集：自动收集各种性能事件
• 过滤机制：根据配置决定收集哪些事件
• 存储机制：将事件数据存储到对应的表中

数据存储层面：
• 历史表：记录历史事件详情
• 汇总表：提供统计和聚合数据
• 配置表：控制监控行为和参数
```

---

## 2. ⚡ 查询执行事件分析


### 2.1 查询执行事件的生命周期


**🔄 查询执行完整过程**

```
SQL查询执行的完整生命周期：

客户端发送SQL
      ↓
┌─ 开始事件 ─┐ ← event_name = 'statement/sql/select'
│ 解析SQL    │
│ 权限检查   │
│ 查询优化   │ ← 各种stage事件
│ 执行计划   │
│ 数据读取   │ ← 各种wait事件
│ 结果返回   │
└─ 结束事件 ─┘ ← 记录总执行时间、影响行数等

Performance Schema会记录：
• 整个查询的执行统计
• 各个阶段的耗时分析
• 等待事件的详细信息
```

### 2.2 事件分类与层级关系


**📊 Performance Schema事件分类**

```
事件层次结构：
┌─ Transaction Level ─┐
│ ┌─ Statement Level ─┐│
│ │ ┌─ Stage Level ─┐││
│ │ │ ┌Wait Level ┐│││
│ │ │ │等待I/O读写││││ ← 最底层，具体的资源等待
│ │ │ │CPU使用   ││││
│ │ │ └───────────┘│││
│ │ │ 查询优化阶段 │││ ← 查询执行的各个阶段
│ │ │ 数据读取阶段 │││
│ │ └───────────────┘││
│ │ SELECT语句      ││ ← SQL语句级别
│ │ UPDATE语句      ││
│ └───────────────────┘│
│ 事务开始→提交/回滚   │ ← 事务级别
└─────────────────────────┘
```

### 2.3 查询事件收集机制


**⚙️ 事件收集配置**

```sql
-- 查看当前Performance Schema配置状态
SELECT * FROM performance_schema.setup_actors;
SELECT * FROM performance_schema.setup_objects;

-- 检查语句监控是否开启
SELECT * FROM performance_schema.setup_consumers 
WHERE NAME LIKE '%statements%';

-- 开启语句历史收集
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME = 'events_statements_history';

UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME = 'events_statements_history_long';
```

**🎛️ 收集级别控制**
```
收集级别说明：
🔸 Current：当前正在执行的事件
🔸 History：最近执行的事件（按线程）
🔸 History_long：全局历史事件
🔸 Summary：统计汇总数据

内存使用权衡：
• 更多历史数据 = 更详细分析 + 更多内存占用
• 建议根据实际需要开启相应级别
```

---

## 3. 📊 events_statements核心表详解


### 3.1 events_statements_current表


**📋 实时查询监控**

```sql
-- 查看当前正在执行的查询
SELECT 
    THREAD_ID,
    EVENT_ID,
    TRUNCATE(TIMER_WAIT/1000000000000,6) as exec_time_sec,
    SQL_TEXT,
    CURRENT_SCHEMA,
    ROWS_EXAMINED,
    ROWS_SENT
FROM performance_schema.events_statements_current 
WHERE SQL_TEXT IS NOT NULL
ORDER BY TIMER_WAIT DESC;
```

**🔍 核心字段解析**
```
重要字段说明：

时间相关：
• TIMER_WAIT：总执行时间（皮秒）
• LOCK_TIME：锁等待时间
• TIMER_START：开始时间戳

SQL相关：
• SQL_TEXT：完整的SQL文本
• DIGEST：SQL的标准化摘要
• DIGEST_TEXT：标准化后的SQL文本

影响行数：
• ROWS_EXAMINED：扫描的行数
• ROWS_SENT：返回的行数
• ROWS_AFFECTED：影响的行数

资源使用：
• SELECT_SCAN：全表扫描次数
• SELECT_RANGE：范围查询次数
• SORT_ROWS：排序的行数
```

### 3.2 events_statements_history表


**📚 线程级查询历史**

```sql
-- 分析特定线程的查询历史
SELECT 
    EVENT_ID,
    TRUNCATE(TIMER_WAIT/1000000000000,6) as exec_time_sec,
    TRUNCATE(LOCK_TIME/1000000000000,6) as lock_time_sec,
    ROWS_EXAMINED,
    ROWS_SENT,
    LEFT(SQL_TEXT, 100) as sql_preview,
    MESSAGE_TEXT
FROM performance_schema.events_statements_history 
WHERE THREAD_ID = (
    SELECT THREAD_ID FROM performance_schema.threads 
    WHERE PROCESSLIST_ID = CONNECTION_ID()
)
ORDER BY EVENT_ID DESC
LIMIT 10;
```

**🎯 历史分析应用场景**
```
典型使用场景：
• 调试特定连接的查询问题
• 分析某个会话的查询模式
• 追踪问题查询的执行轨迹
• 了解应用程序的查询行为

分析思路：
🔸 按时间顺序查看查询执行
🔸 识别执行时间异常的查询
🔸 分析锁等待和资源使用情况
```

### 3.3 events_statements_history_long表


**🌍 全局查询历史**

```sql
-- 全局最慢的查询分析
SELECT 
    COUNT(*) as query_count,
    TRUNCATE(AVG(TIMER_WAIT/1000000000000),6) as avg_time_sec,
    TRUNCATE(MAX(TIMER_WAIT/1000000000000),6) as max_time_sec,
    TRUNCATE(SUM(TIMER_WAIT/1000000000000),6) as total_time_sec,
    DIGEST_TEXT as normalized_query
FROM performance_schema.events_statements_history_long 
WHERE DIGEST_TEXT IS NOT NULL
GROUP BY DIGEST
ORDER BY total_time_sec DESC
LIMIT 10;
```

**📈 全局分析价值**
```
全局视角优势：
✅ 发现影响整体性能的查询
✅ 识别高频执行的慢查询
✅ 分析不同时间段的查询模式
✅ 统计各类查询的资源消耗

与慢查询日志对比：
传统慢查询日志：只记录超过阈值的查询
history_long表：记录所有查询，支持灵活分析
```

### 3.4 events_statements_summary表


**📊 查询统计汇总**

```sql
-- 按摘要统计查询性能
SELECT 
    COUNT_STAR as exec_count,
    TRUNCATE(AVG_TIMER_WAIT/1000000000000,6) as avg_time_sec,
    TRUNCATE(MAX_TIMER_WAIT/1000000000000,6) as max_time_sec,
    TRUNCATE(SUM_TIMER_WAIT/1000000000000,6) as total_time_sec,
    SUM_ROWS_EXAMINED as total_rows_examined,
    SUM_ROWS_SENT as total_rows_sent,
    LEFT(DIGEST_TEXT, 150) as query_pattern
FROM performance_schema.events_statements_summary_by_digest 
WHERE DIGEST_TEXT IS NOT NULL
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 15;
```

**🎯 汇总表的核心价值**
```
统计维度丰富：
• 执行次数统计
• 平均/最大/总执行时间
• 行数扫描和返回统计
• 错误和警告统计

业务价值：
• 识别需要优化的SQL模式
• 分析查询的执行频率和性能
• 监控SQL性能趋势变化
• 制定数据库优化策略
```

---

## 4. 🔧 SQL性能剖析实战


### 4.1 慢查询识别与分析


**🚨 慢查询发现流程**

```sql
-- 实战案例：电商平台订单查询性能分析
-- 第1步：找出最耗时的查询模式
WITH slow_queries AS (
    SELECT 
        DIGEST,
        DIGEST_TEXT,
        COUNT_STAR as execution_count,
        TRUNCATE(AVG_TIMER_WAIT/1000000000000,6) as avg_exec_time,
        TRUNCATE(MAX_TIMER_WAIT/1000000000000,6) as max_exec_time,
        TRUNCATE(SUM_TIMER_WAIT/1000000000000,6) as total_time,
        SUM_ROWS_EXAMINED as total_examined,
        SUM_ROWS_SENT as total_sent,
        TRUNCATE(SUM_ROWS_EXAMINED/COUNT_STAR,0) as avg_rows_examined
    FROM performance_schema.events_statements_summary_by_digest
    WHERE DIGEST_TEXT IS NOT NULL
      AND DIGEST_TEXT NOT LIKE '%performance_schema%'
      AND COUNT_STAR > 0
)
SELECT 
    execution_count as 执行次数,
    avg_exec_time as 平均耗时秒,
    max_exec_time as 最大耗时秒,
    total_time as 总耗时秒,
    avg_rows_examined as 平均扫描行数,
    CASE 
        WHEN avg_exec_time > 10 THEN '🔴 严重慢查询'
        WHEN avg_exec_time > 1 THEN '🟡 中等慢查询' 
        WHEN avg_rows_examined > 10000 THEN '🟠 扫描行数过多'
        ELSE '🟢 正常查询'
    END as 性能评级,
    LEFT(DIGEST_TEXT, 200) as 查询模式
FROM slow_queries
ORDER BY total_time DESC
LIMIT 20;
```

**🎯 慢查询分析指标**
```
关键性能指标：
📊 平均执行时间：单次查询平均耗时
📊 总执行时间：累计影响时间（优先优化）
📊 执行频率：高频查询需要重点关注
📊 扫描行数：I/O开销的重要指标
📊 返回行数：网络传输开销指标

优化优先级排序：
1️⃣ 总耗时最高的查询（影响最大）
2️⃣ 平均耗时高且执行频繁的查询
3️⃣ 扫描行数过多的查询
4️⃣ 返回数据量过大的查询
```

### 4.2 查询执行阶段分析


**🔍 深入分析查询执行过程**

```sql
-- 分析具体查询的执行阶段
SELECT 
    EVENT_NAME as 执行阶段,
    COUNT_STAR as 发生次数,
    TRUNCATE(AVG_TIMER_WAIT/1000000000000,6) as 平均耗时秒,
    TRUNCATE(MAX_TIMER_WAIT/1000000000000,6) as 最大耗时秒,
    TRUNCATE(SUM_TIMER_WAIT/1000000000000,6) as 总耗时秒
FROM performance_schema.events_stages_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'stage/%'
  AND COUNT_STAR > 0
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 15;

-- 查看某个具体查询的阶段执行情况
SELECT 
    THREAD_ID,
    EVENT_NAME,
    TRUNCATE(TIMER_WAIT/1000000000000,6) as stage_time_sec,
    TRUNCATE(TIMER_START/1000000000000,6) as start_time
FROM performance_schema.events_stages_history_long
WHERE THREAD_ID = (
    SELECT THREAD_ID FROM performance_schema.threads 
    WHERE PROCESSLIST_ID = CONNECTION_ID()
)
ORDER BY EVENT_ID DESC
LIMIT 10;
```

**⚙️ 执行阶段含义解析**
```
重要执行阶段：
🔸 stage/sql/parsing：SQL解析阶段
🔸 stage/sql/checking permissions：权限检查
🔸 stage/sql/optimizing：查询优化（重要）
🔸 stage/sql/preparing：执行准备
🔸 stage/sql/executing：实际执行（重要）
🔸 stage/sql/Sending to client：结果传输

性能瓶颈分析：
• optimizing耗时长：查询复杂度高，需要优化
• executing耗时长：数据处理量大，考虑索引优化
• Sending to client耗时长：返回数据量大
```

### 4.3 查询资源使用分析


**💾 内存和I/O使用分析**

```sql
-- 分析查询的资源消耗情况
SELECT 
    DIGEST_TEXT as 查询模式,
    COUNT_STAR as 执行次数,
    TRUNCATE(AVG_TIMER_WAIT/1000000000000,6) as 平均耗时,
    SUM_CREATED_TMP_TABLES as 临时表总数,
    SUM_CREATED_TMP_DISK_TABLES as 磁盘临时表总数,
    SUM_SELECT_FULL_JOIN as 全表连接次数,
    SUM_SELECT_SCAN as 全表扫描次数,
    SUM_SORT_SCAN + SUM_SORT_RANGE as 排序次数,
    SUM_NO_INDEX_USED as 未使用索引次数,
    SUM_NO_GOOD_INDEX_USED as 未使用好索引次数
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT IS NOT NULL
  AND COUNT_STAR > 10
ORDER BY (SUM_CREATED_TMP_DISK_TABLES + SUM_SELECT_FULL_JOIN + SUM_NO_INDEX_USED) DESC
LIMIT 20;
```

**🚨 资源使用问题识别**
```
关键问题指标：
❌ 磁盘临时表过多：内存不够，溢出到磁盘
❌ 全表连接：JOIN条件没有索引
❌ 全表扫描：WHERE条件没有有效索引
❌ 未使用索引：查询效率低下

优化建议：
✅ 磁盘临时表 → 增加sort_buffer_size或优化查询
✅ 全表连接 → 为JOIN字段创建索引
✅ 全表扫描 → 为WHERE条件创建合适索引
✅ 排序过多 → 考虑索引覆盖排序字段
```

---

## 5. 📈 查询分类统计分析


### 5.1 按查询类型分类统计


**📊 查询类型分布分析**

```sql
-- 分析不同类型查询的执行情况
SELECT 
    CASE 
        WHEN EVENT_NAME = 'statement/sql/select' THEN '🔍 SELECT查询'
        WHEN EVENT_NAME = 'statement/sql/insert' THEN '➕ INSERT操作'
        WHEN EVENT_NAME = 'statement/sql/update' THEN '✏️ UPDATE操作'
        WHEN EVENT_NAME = 'statement/sql/delete' THEN '🗑️ DELETE操作'
        WHEN EVENT_NAME LIKE 'statement/sql/show%' THEN '👁️ SHOW命令'
        WHEN EVENT_NAME LIKE 'statement/com/%' THEN '🔧 预处理语句'
        ELSE '📋 其他操作'
    END as 查询类型,
    COUNT_STAR as 执行次数,
    TRUNCATE(COUNT_STAR * 100.0 / SUM(COUNT_STAR) OVER(), 2) as 占比百分比,
    TRUNCATE(AVG_TIMER_WAIT/1000000000000,6) as 平均耗时秒,
    TRUNCATE(SUM_TIMER_WAIT/1000000000000,6) as 总耗时秒,
    TRUNCATE(SUM_TIMER_WAIT * 100.0 / SUM(SUM_TIMER_WAIT) OVER(), 2) as 耗时占比
FROM performance_schema.events_statements_summary_global_by_event_name
WHERE COUNT_STAR > 0
GROUP BY 
    CASE 
        WHEN EVENT_NAME = 'statement/sql/select' THEN '🔍 SELECT查询'
        WHEN EVENT_NAME = 'statement/sql/insert' THEN '➕ INSERT操作'
        WHEN EVENT_NAME = 'statement/sql/update' THEN '✏️ UPDATE操作'
        WHEN EVENT_NAME = 'statement/sql/delete' THEN '🗑️ DELETE操作'
        WHEN EVENT_NAME LIKE 'statement/sql/show%' THEN '👁️ SHOW命令'
        WHEN EVENT_NAME LIKE 'statement/com/%' THEN '🔧 预处理语句'
        ELSE '📋 其他操作'
    END
ORDER BY 总耗时秒 DESC;
```

### 5.2 按数据库和表分类统计


**🗄️ 数据库访问热点分析**

```sql
-- 按数据库统计查询分布
SELECT 
    COALESCE(OBJECT_SCHEMA, '未指定数据库') as 数据库名,
    COUNT_STAR as 查询次数,
    TRUNCATE(AVG_TIMER_WAIT/1000000000000,6) as 平均耗时秒,
    TRUNCATE(SUM_TIMER_WAIT/1000000000000,6) as 总耗时秒,
    SUM_ROWS_EXAMINED as 总扫描行数,
    SUM_ROWS_SENT as 总返回行数,
    TRUNCATE(SUM_ROWS_EXAMINED/COUNT_STAR,0) as 平均扫描行数
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT IS NOT NULL
GROUP BY OBJECT_SCHEMA
ORDER BY 总耗时秒 DESC;

-- 分析具体表的访问情况
SELECT 
    OBJECT_SCHEMA as 数据库,
    OBJECT_NAME as 表名,
    COUNT_STAR as 访问次数,
    TRUNCATE(SUM_TIMER_WAIT/1000000000000,6) as 总耗时秒,
    SUM_ROWS_EXAMINED as 扫描行数,
    SUM_ROWS_SENT as 返回行数,
    CASE 
        WHEN SUM_ROWS_EXAMINED/COUNT_STAR > 10000 THEN '🔴 扫描过多'
        WHEN SUM_TIMER_WAIT/COUNT_STAR > 1000000000000 THEN '🟡 耗时较长'
        ELSE '🟢 正常'
    END as 状态评估
FROM performance_schema.events_statements_summary_by_digest
WHERE OBJECT_SCHEMA IS NOT NULL
  AND OBJECT_NAME IS NOT NULL
  AND OBJECT_SCHEMA NOT IN ('information_schema', 'performance_schema', 'sys')
GROUP BY OBJECT_SCHEMA, OBJECT_NAME
ORDER BY 总耗时秒 DESC
LIMIT 20;
```

### 5.3 按时间维度分类统计


**⏰ 时间趋势分析**

```sql
-- 创建时间维度分析（需要定期执行并保存结果）
-- 注意：Performance Schema不直接提供时间分组，需要结合定时任务

-- 实时监控当前1小时内的查询统计
SELECT 
    DATE_FORMAT(NOW(), '%Y-%m-%d %H:00:00') as 统计时间,
    COUNT(*) as 查询总数,
    COUNT(DISTINCT DIGEST) as 不同查询模式数,
    TRUNCATE(AVG(TIMER_WAIT/1000000000000),6) as 平均耗时秒,
    TRUNCATE(MAX(TIMER_WAIT/1000000000000),6) as 最大耗时秒,
    SUM(CASE WHEN TIMER_WAIT > 1000000000000 THEN 1 ELSE 0 END) as 慢查询数量,
    TRUNCATE(SUM(CASE WHEN TIMER_WAIT > 1000000000000 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as 慢查询占比
FROM performance_schema.events_statements_history_long
WHERE TIMER_START > (UNIX_TIMESTAMP(NOW() - INTERVAL 1 HOUR) * 1000000000000);
```

**📊 业务高峰期分析**
```
时间维度分析价值：
• 识别业务高峰期的查询模式
• 发现特定时间段的性能问题
• 制定针对性的优化策略
• 合理规划数据库资源

分析建议：
🔸 按小时统计：发现一天内的访问规律
🔸 按工作日统计：区分工作日和周末的差异
🔸 按月份统计：识别业务增长对数据库的影响
```

---

## 6. 🛠️ 性能监控最佳实践


### 6.1 监控配置最佳实践


**⚙️ Performance Schema配置优化**

```sql
-- 推荐的基础监控配置
-- 1. 开启核心语句监控
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME IN (
    'events_statements_current',
    'events_statements_history',
    'events_statements_summary_by_digest'
);

-- 2. 控制历史数据量（根据服务器内存调整）
-- 查看当前配置
SELECT * FROM performance_schema.setup_instruments 
WHERE NAME LIKE '%statement%' AND NAME LIKE '%history%';

-- 3. 定期清理汇总表（重置统计）
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
```

**📋 配置参数说明**
```
配置考量因素：
内存使用：
• history表会占用较多内存
• 根据服务器配置合理设置大小
• 监控内存使用情况

性能影响：
• Performance Schema有轻微性能开销
• 通常小于5%，可以接受
• 根据业务需要选择监控级别

数据保留：
• current：实时数据，内存占用小
• history：线程级历史，适中
• history_long：全局历史，占用较多
• summary：汇总数据，推荐开启
```

### 6.2 定期性能分析流程


**📋 标准化分析流程**

```sql
-- 性能分析标准化查询脚本
-- 第1步：整体性能概况
SELECT 
    '数据库整体性能概况' as 分析项目,
    CONCAT('总查询数: ', FORMAT(SUM(COUNT_STAR), 0)) as 统计结果,
    '' as 详细信息
FROM performance_schema.events_statements_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'statement/sql/%'

UNION ALL

SELECT 
    '平均查询耗时',
    CONCAT(TRUNCATE(AVG(AVG_TIMER_WAIT/1000000000000), 6), ' 秒'),
    '整体查询效率指标'
FROM performance_schema.events_statements_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'statement/sql/%'

UNION ALL

-- 第2步：慢查询统计
SELECT 
    '慢查询模式统计',
    CONCAT('发现 ', COUNT(*), ' 个慢查询模式'),
    '平均耗时超过1秒的查询模式'
FROM performance_schema.events_statements_summary_by_digest
WHERE AVG_TIMER_WAIT > 1000000000000

UNION ALL

-- 第3步：资源使用问题
SELECT 
    '索引使用问题',
    CONCAT('发现 ', COUNT(*), ' 个查询未使用索引'),
    '需要优化索引设计'
FROM performance_schema.events_statements_summary_by_digest
WHERE SUM_NO_INDEX_USED > 0 OR SUM_NO_GOOD_INDEX_USED > 0;
```

### 6.3 性能监控告警机制


**🚨 自动化监控告警**

```sql
-- 性能异常检测查询
-- 可以集成到监控系统中定期执行
WITH performance_metrics AS (
    SELECT 
        'slow_query_ratio' as metric_name,
        SUM(CASE WHEN AVG_TIMER_WAIT > 5000000000000 THEN COUNT_STAR ELSE 0 END) * 100.0 / SUM(COUNT_STAR) as metric_value,
        '慢查询占比' as metric_desc,
        5.0 as warning_threshold,
        10.0 as critical_threshold
    FROM performance_schema.events_statements_summary_by_digest
    WHERE COUNT_STAR > 0
    
    UNION ALL
    
    SELECT 
        'no_index_queries',
        COUNT(*),
        '未使用索引的查询模式数',
        5,
        10
    FROM performance_schema.events_statements_summary_by_digest
    WHERE SUM_NO_INDEX_USED > 0
    
    UNION ALL
    
    SELECT 
        'tmp_disk_tables',
        SUM(SUM_CREATED_TMP_DISK_TABLES),
        '磁盘临时表总数',
        100,
        500
    FROM performance_schema.events_statements_summary_by_digest
)
SELECT 
    metric_name as 监控指标,
    metric_value as 当前值,
    metric_desc as 指标说明,
    CASE 
        WHEN metric_value >= critical_threshold THEN '🔴 严重告警'
        WHEN metric_value >= warning_threshold THEN '🟡 警告'
        ELSE '🟢 正常'
    END as 状态,
    CASE 
        WHEN metric_value >= critical_threshold THEN '立即处理'
        WHEN metric_value >= warning_threshold THEN '需要关注'
        ELSE '正常范围'
    END as 建议措施
FROM performance_metrics
ORDER BY metric_value DESC;
```

**🎯 监控指标建议**
```
核心监控指标：
📊 慢查询比例：超过5%需要关注
📊 平均查询耗时：持续上升需要分析
📊 未使用索引查询：应该接近0
📊 磁盘临时表：过多表明内存不够
📊 全表扫描频率：高频表需要优化索引

告警级别设定：
🟢 正常：指标在正常范围内
🟡 警告：指标超过阈值，需要关注
🔴 严重：指标严重超标，立即处理
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Performance Schema本质：MySQL内置的性能监控系统
🔸 事件分类：Statement、Stage、Wait、Transaction四个层级
🔸 核心表组织：Current（实时）、History（历史）、Summary（汇总）
🔸 查询分析维度：执行时间、资源使用、执行频率、影响行数
🔸 配置管理：通过setup_*表控制监控行为和数据收集
```

### 7.2 关键应用价值


**🎯 解决的核心问题**
```
性能问题定位：
传统方法：凭经验猜测，定位困难
Performance Schema：数据驱动，精确定位

查询优化决策：
传统方法：主观判断，缺少依据
Performance Schema：客观数据，科学决策

资源使用分析：
传统方法：粗粒度监控，细节不足
Performance Schema：细粒度分析，全面覆盖
```

**💡 适用场景判断**
```
✅ 适合使用Performance Schema：
• 数据库性能调优分析
• 慢查询深度诊断
• 应用程序查询行为分析
• 生产环境性能监控

⚠️ 使用注意事项：
• 会有轻微性能开销（通常<5%）
• 需要合理配置内存使用
• 历史数据定期清理
• 结合其他监控工具使用
```

### 7.3 性能分析方法论


**🔍 标准分析流程**
```
第1步：整体性能评估
• 查看总体查询统计
• 识别性能瓶颈类型
• 确定优化优先级

第2步：具体查询分析
• 定位最耗时的查询模式
• 分析查询执行计划
• 检查资源使用情况

第3步：深入执行过程
• 分析查询执行阶段
• 检查等待事件
• 识别具体瓶颈点

第4步：制定优化方案
• 索引优化建议
• 查询重写建议
• 参数调优建议
```

**📊 分析维度记忆**
| 分析维度 | **关注指标** | **优化方向** | **检查重点** |
|---------|------------|-------------|-------------|
| **执行时间** | `平均耗时、总耗时` | `减少查询响应时间` | `慢查询识别和优化` |
| **执行频率** | `执行次数、调用频率` | `优化高频查询` | `热点查询性能提升` |
| **资源使用** | `扫描行数、临时表` | `减少资源消耗` | `索引使用和查询重写` |
| **等待事件** | `锁等待、I/O等待` | `减少等待时间` | `并发控制和存储优化` |

### 7.4 学习建议与实践要点


**🎓 学习路径**
```
入门阶段：
1. 理解Performance Schema基本概念
2. 掌握核心表的用途和字段
3. 练习基本的性能分析查询

进阶阶段：
1. 深入学习事件分析和统计
2. 掌握复杂性能问题诊断
3. 建立标准化监控流程

高级阶段：
1. 集成自动化监控告警
2. 结合其他工具进行综合分析
3. 制定数据库性能优化策略
```

**🧪 实践练习建议**
```
练习1：配置Performance Schema监控环境
练习2：分析生产环境的慢查询问题
练习3：建立性能监控告警机制
练习4：制定标准化的性能分析报告
```

**🎯 关键记忆点**
```
一句话精华：
Performance Schema是MySQL的"性能体检系统"，
让数据库性能问题无处藏身

核心价值：
从"凭经验猜测"到"用数据说话"的性能优化转变

实践原则：
监控配置要合理，分析流程要标准，优化措施要有据
```

**🔑 掌握程度自检**
```
基础要求：★★★★★
□ 能配置Performance Schema基本监控
□ 理解核心表的作用和字段含义
□ 能写出基本的性能分析查询

进阶要求：★★★☆☆
□ 能进行复杂的查询性能诊断
□ 掌握标准化的性能分析流程
□ 能建立监控告警机制

实战要求：★★☆☆☆
□ 能解决实际的数据库性能问题
□ 能制定数据库优化策略
□ 能集成自动化性能监控系统
```

---

> 📚 **拓展学习**
> 
> - **下一步学习**：sys schema的性能分析视图
> - **相关主题**：慢查询日志分析和优化
> - **实践项目**：构建完整的数据库性能监控体系

**💡 记忆口诀**：
Performance Schema像神医，查询问题看得细，
事件统计全记录，性能优化有依据！