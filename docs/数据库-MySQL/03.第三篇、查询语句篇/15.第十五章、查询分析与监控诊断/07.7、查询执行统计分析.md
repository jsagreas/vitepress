---
title: 7、查询执行统计分析
---
## 📚 目录

1. [查询执行统计基础](#1-查询执行统计基础)
2. [查询执行统计收集机制](#2-查询执行统计收集机制)
3. [查询模式识别与分析](#3-查询模式识别与分析)
4. [执行频率分析技术](#4-执行频率分析技术)
5. [资源消耗统计监控](#5-资源消耗统计监控)
6. [优化建议生成系统](#6-优化建议生成系统)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📊 查询执行统计基础


### 1.1 什么是查询执行统计


> **💡 核心概念**
> 
> 查询执行统计是数据库系统收集和记录SQL查询执行过程中各种性能指标和资源使用情况的机制。它就像给每个SQL查询配备了一个"性能记录仪"，记录下执行次数、耗时、资源消耗等关键信息。

**为什么需要查询执行统计？**

想象你在经营一家餐厅，如果不知道哪道菜最受欢迎、哪道菜制作最耗时，就很难做出正确的经营决策。数据库查询也是一样：

```
业务场景对比：
❌ 没有统计：系统变慢了，只能猜测原因，逐个排查
✅ 有了统计：直接看到耗时最长的TOP 10查询，精准定位
```

### 1.2 统计信息的价值体现


**📈 统计数据告诉我们什么**

| 统计指标 | **实际含义** | **业务价值** | **优化方向** |
|---------|-------------|-------------|-------------|
| **执行次数** | `查询被调用的频率` | `识别核心业务功能` | `高频查询优先优化` |
| **平均耗时** | `单次查询响应速度` | `用户体验评估` | `慢查询性能调优` |
| **总耗时** | `查询累计消耗时间` | `系统整体负载` | `资源分配调整` |
| **缓存命中率** | `数据从内存获取比例` | `硬件资源效率` | `索引和缓存优化` |

### 1.3 统计分析的思维框架


**🎯 分析层次结构**
```
基础统计层
├─ 执行次数、时间、成功率
├─ 基本性能指标收集
└─ 问题现象识别

深度分析层  
├─ 查询模式分类识别
├─ 资源消耗分布分析
└─ 性能瓶颈定位

优化决策层
├─ 优化建议自动生成
├─ 优先级评估排序
└─ 改进效果预测
```

---

## 2. 🔍 查询执行统计收集机制


### 2.1 PostgreSQL统计收集核心


**pg_stat_statements扩展**

这是PostgreSQL提供的查询统计"神器"，可以自动收集所有SQL的执行情况。

> **💡 通俗理解**
>
> `pg_stat_statements`就像一个"智能监控摄像头"，默默记录每个查询的"一举一动"——执行了多少次、花了多长时间、用了多少资源。

**🔧 快速启用统计收集**
```sql
-- 1. 启用扩展（需要重启数据库）
-- 在postgresql.conf中添加：
-- shared_preload_libraries = 'pg_stat_statements'

-- 2. 创建扩展
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 3. 验证是否正常工作
SELECT count(*) as total_queries FROM pg_stat_statements;
```

### 2.2 核心统计字段解读


**📊 重要字段含义**
```sql
-- 查看关键统计信息
SELECT 
    query,                      -- 查询文本（参数化）
    calls,                      -- 执行次数
    total_time,                 -- 总耗时（毫秒）
    mean_time,                  -- 平均耗时
    rows,                       -- 处理行数
    shared_blks_hit,           -- 缓存命中数据块
    shared_blks_read           -- 磁盘读取数据块
FROM pg_stat_statements 
ORDER BY total_time DESC 
LIMIT 10;
```

**字段实际意义**
- `calls = 1000`：这个查询被执行了1000次
- `mean_time = 50`：平均每次耗时50毫秒  
- `shared_blks_hit = 5000`：5000个数据块从缓存获取
- `shared_blks_read = 500`：500个数据块需要读磁盘

### 2.3 统计收集策略配置


**⚙️ 关键配置参数**
```sql
-- 查看当前配置
SELECT name, setting, short_desc 
FROM pg_settings 
WHERE name LIKE 'pg_stat_statements%';

/*
重要配置说明：
pg_stat_statements.max = 5000      -- 最多记录5000个不同查询
pg_stat_statements.track = 'all'   -- 跟踪所有查询
pg_stat_statements.save = on       -- 重启后保留数据
*/
```

---

## 3. 🔍 查询模式识别与分析


### 3.1 查询类型自动分类


**查询模式分类的重要性**

不同类型的查询有不同的性能特征和优化策略，自动识别查询模式是精准优化的基础。

```sql
-- 查询类型分类统计
SELECT 
    CASE 
        WHEN UPPER(query) LIKE 'SELECT%' THEN '查询操作'
        WHEN UPPER(query) LIKE 'INSERT%' THEN '插入操作'  
        WHEN UPPER(query) LIKE 'UPDATE%' THEN '更新操作'
        WHEN UPPER(query) LIKE 'DELETE%' THEN '删除操作'
        ELSE '其他操作'
    END as query_type,
    
    COUNT(*) as query_count,
    SUM(calls) as total_executions,
    ROUND(AVG(mean_time), 2) as avg_response_time,
    ROUND(SUM(total_time), 2) as total_time_consumed
    
FROM pg_stat_statements
WHERE calls > 0
GROUP BY query_type
ORDER BY total_time_consumed DESC;
```

### 3.2 复杂度等级识别


**🎯 查询复杂度分级**
```sql
-- 按复杂度分类查询
SELECT 
    CASE 
        WHEN query ~* 'JOIN.*JOIN.*JOIN' THEN '复杂多表关联'
        WHEN query ~* 'JOIN.*JOIN' THEN '多表关联'  
        WHEN query ~* 'WINDOW|OVER\s*\(' THEN '窗口函数查询'
        WHEN query ~* 'WITH.*AS' THEN 'CTE递归查询'
        WHEN query ~* 'UNION|INTERSECT' THEN '集合操作查询'
        ELSE '简单查询'
    END as complexity_level,
    
    COUNT(*) as query_count,
    ROUND(AVG(mean_time), 2) as avg_time,
    ROUND(MAX(mean_time), 2) as max_time
    
FROM pg_stat_statements
GROUP BY complexity_level
ORDER BY avg_time DESC;
```

### 3.3 表访问热点分析


**📊 识别数据库访问热点**
```sql
-- 表访问模式分析
SELECT 
    schemaname || '.' || tablename as table_name,
    seq_scan + idx_scan as total_reads,
    n_tup_ins + n_tup_upd + n_tup_del as total_writes,
    
    CASE 
        WHEN seq_scan > idx_scan * 2 AND n_live_tup > 1000 THEN '🔴 需要索引优化'
        WHEN (seq_scan + idx_scan) > 10000 THEN '🟡 高频访问表'
        ELSE '🟢 正常访问'
    END as access_status,
    
    ROUND(100.0 * seq_scan / NULLIF(seq_scan + idx_scan, 0), 1) as seq_scan_ratio
    
FROM pg_stat_user_tables
WHERE seq_scan + idx_scan > 100
ORDER BY total_reads + total_writes DESC
LIMIT 20;
```

---

## 4. 📊 执行频率分析技术


### 4.1 热点查询识别


**🔥 热点查询评分系统**

通过综合考虑执行频率、总耗时、平均响应时间等指标，自动识别最需要优化的查询。

```sql
-- 热点查询评分分析
WITH query_scores AS (
    SELECT 
        queryid,
        LEFT(query, 100) as query_preview,
        calls,
        total_time,
        mean_time,
        
        -- 频率评分（1-5分）
        CASE 
            WHEN calls >= 10000 THEN 5
            WHEN calls >= 1000 THEN 4
            WHEN calls >= 100 THEN 3
            WHEN calls >= 10 THEN 2
            ELSE 1
        END as frequency_score,
        
        -- 总时间消耗评分（1-5分）
        CASE 
            WHEN total_time >= 60000 THEN 5  -- 1分钟以上
            WHEN total_time >= 10000 THEN 4  -- 10秒以上
            WHEN total_time >= 1000 THEN 3   -- 1秒以上
            ELSE 2
        END as time_score
        
    FROM pg_stat_statements
    WHERE calls > 0
)
SELECT 
    query_preview,
    calls as execution_count,
    ROUND(mean_time, 2) as avg_time_ms,
    ROUND(total_time, 2) as total_time_ms,
    
    -- 综合热度评分
    (frequency_score * 0.4 + time_score * 0.6) as hotness_score,
    
    CASE 
        WHEN (frequency_score >= 4 AND time_score >= 4) THEN '🔴 紧急优化'
        WHEN (frequency_score >= 3 AND time_score >= 3) THEN '🟡 建议优化'  
        ELSE '🟢 持续监控'
    END as optimization_priority
    
FROM query_scores
ORDER BY hotness_score DESC, total_time DESC
LIMIT 15;
```

### 4.2 执行频率趋势监控


**📈 构建简化的趋势监控**
```sql
-- 创建查询历史记录表
CREATE TABLE query_stats_snapshot (
    snapshot_date DATE DEFAULT CURRENT_DATE,
    queryid BIGINT,
    calls BIGINT,
    total_time NUMERIC,
    mean_time NUMERIC
);

-- 定期收集快照的函数
CREATE OR REPLACE FUNCTION take_query_snapshot()
RETURNS void AS $$
BEGIN
    INSERT INTO query_stats_snapshot (queryid, calls, total_time, mean_time)
    SELECT queryid, calls, total_time, mean_time
    FROM pg_stat_statements
    WHERE calls > 10;  -- 只记录执行次数超过10的查询
END;
$$ LANGUAGE plpgsql;

-- 分析频率趋势变化
SELECT 
    q1.queryid,
    q1.calls as current_calls,
    q2.calls as previous_calls,
    q1.calls - q2.calls as call_increase,
    ROUND((q1.calls::NUMERIC - q2.calls) / q2.calls * 100, 1) as growth_rate
FROM pg_stat_statements q1
JOIN query_stats_snapshot q2 ON q1.queryid = q2.queryid
WHERE q2.snapshot_date = CURRENT_DATE - 1  -- 与昨天对比
  AND q1.calls > q2.calls
ORDER BY growth_rate DESC
LIMIT 10;
```

---

## 5. 💾 资源消耗统计监控


### 5.1 CPU和IO资源分析


**🖥️ 资源消耗快速评估**

```sql
-- 资源消耗综合分析
SELECT 
    LEFT(query, 120) as query_preview,
    calls,
    ROUND(mean_time, 2) as avg_time_ms,
    
    -- 计算缓存命中率
    CASE 
        WHEN (shared_blks_hit + shared_blks_read) > 0 THEN
            ROUND(100.0 * shared_blks_hit / (shared_blks_hit + shared_blks_read), 1)
        ELSE 0
    END as cache_hit_percent,
    
    -- IO密集度评估
    CASE 
        WHEN (shared_blks_read / GREATEST(calls, 1)) > 100 THEN '🔴 IO密集'
        WHEN (shared_blks_read / GREATEST(calls, 1)) > 10 THEN '🟡 中等IO'
        ELSE '🟢 轻量IO'
    END as io_intensity,
    
    -- 内存使用评估
    CASE 
        WHEN temp_blks_read + temp_blks_written > 0 THEN '⚠️ 使用临时文件'
        ELSE '✅ 内存充足'
    END as memory_status
    
FROM pg_stat_statements
WHERE calls > 100
ORDER BY mean_time DESC
LIMIT 20;
```

### 5.2 存储IO性能监控


**💿 存储性能简化分析**
```sql
-- 按查询类型分析IO消耗
SELECT 
    CASE 
        WHEN UPPER(query) LIKE 'SELECT%' THEN 'SELECT查询'
        WHEN UPPER(query) LIKE 'INSERT%' THEN 'INSERT操作'
        WHEN UPPER(query) LIKE 'UPDATE%' THEN 'UPDATE操作' 
        ELSE '其他操作'
    END as operation_type,
    
    COUNT(*) as query_count,
    SUM(shared_blks_read) as total_disk_reads,
    ROUND(AVG(shared_blks_read / GREATEST(calls, 1)), 1) as avg_reads_per_call,
    
    CASE 
        WHEN AVG(shared_blks_read / GREATEST(calls, 1)) > 50 THEN '需要优化'
        ELSE '性能良好'
    END as performance_status
    
FROM pg_stat_statements
WHERE calls > 0
GROUP BY operation_type
ORDER BY total_disk_reads DESC;
```

---

## 6. 🎯 优化建议生成系统


### 6.1 智能优化建议


**🤖 自动化问题识别与建议**

基于收集的统计数据，自动识别常见性能问题并提供针对性的优化建议。

```sql
-- 智能优化建议生成器
WITH problem_identification AS (
    SELECT 
        queryid,
        LEFT(query, 150) as query_text,
        calls,
        mean_time,
        total_time,
        
        -- 缓存命中率计算
        CASE 
            WHEN (shared_blks_hit + shared_blks_read) > 0 THEN
                shared_blks_hit::NUMERIC / (shared_blks_hit + shared_blks_read) * 100
            ELSE 100
        END as cache_hit_ratio,
        
        temp_blks_read + temp_blks_written as temp_usage,
        
        -- 问题识别标记
        CASE 
            WHEN mean_time > 1000 AND calls > 50 THEN 'slow_query'
            WHEN calls > 5000 AND mean_time > 100 THEN 'high_frequency_slow'
            WHEN (shared_blks_hit + shared_blks_read) > 0 AND 
                 shared_blks_hit::NUMERIC / (shared_blks_hit + shared_blks_read) < 0.8 THEN 'poor_cache'
            WHEN temp_blks_read + temp_blks_written > calls * 2 THEN 'memory_issue'
            ELSE 'normal'
        END as issue_type
        
    FROM pg_stat_statements
    WHERE calls > 10
)
SELECT 
    query_text,
    calls as executions,
    ROUND(mean_time, 1) as avg_time_ms,
    
    CASE issue_type
        WHEN 'slow_query' THEN '🔴 慢查询问题'
        WHEN 'high_frequency_slow' THEN '🟠 高频慢查询'  
        WHEN 'poor_cache' THEN '🟡 缓存命中率低'
        WHEN 'memory_issue' THEN '⚠️ 内存不足'
        ELSE '✅ 性能正常'
    END as issue_description,
    
    CASE issue_type
        WHEN 'slow_query' THEN '检查索引覆盖情况，考虑查询重写'
        WHEN 'high_frequency_slow' THEN '优先创建索引，考虑结果缓存'  
        WHEN 'poor_cache' THEN '增加shared_buffers或优化查询'
        WHEN 'memory_issue' THEN '增大work_mem参数或优化排序'
        ELSE '保持现状，持续监控'
    END as optimization_advice,
    
    CASE issue_type
        WHEN 'slow_query' THEN '🔴 高'
        WHEN 'high_frequency_slow' THEN '🔴 高'  
        WHEN 'poor_cache' THEN '🟡 中'
        WHEN 'memory_issue' THEN '🟡 中'
        ELSE '🟢 低'
    END as priority_level
    
FROM problem_identification
WHERE issue_type != 'normal'
ORDER BY 
    CASE issue_type
        WHEN 'high_frequency_slow' THEN 1
        WHEN 'slow_query' THEN 2
        WHEN 'poor_cache' THEN 3
        ELSE 4
    END,
    total_time DESC
LIMIT 15;
```

### 6.2 索引优化建议


**📊 索引需求分析**
```sql
-- 索引优化建议生成
SELECT 
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    
    -- 计算顺序扫描比例
    ROUND(100.0 * seq_scan / NULLIF(seq_scan + idx_scan, 0), 1) as seq_scan_ratio,
    
    CASE 
        WHEN seq_scan > idx_scan AND seq_tup_read > 100000 THEN 
            '🔴 建议创建索引 - 大量顺序扫描'
        WHEN seq_scan > 1000 AND n_live_tup > 10000 THEN 
            '🟡 考虑索引优化 - 频繁扫描大表'
        ELSE '✅ 索引使用良好'
    END as index_recommendation,
    
    n_live_tup as table_rows
    
FROM pg_stat_user_tables
WHERE seq_scan + idx_scan > 100
ORDER BY seq_tup_read DESC
LIMIT 20;
```

### 6.3 配置参数优化建议


**⚙️ 数据库参数调优建议**
```sql
-- 基于统计数据的参数优化建议
WITH config_analysis AS (
    SELECT 
        -- 统计临时文件使用情况
        COUNT(*) FILTER (WHERE temp_blks_read + temp_blks_written > 0) as queries_using_temp,
        COUNT(*) as total_queries,
        
        -- 统计缓存命中情况
        AVG(
            CASE 
                WHEN (shared_blks_hit + shared_blks_read) > 0 THEN
                    shared_blks_hit::NUMERIC / (shared_blks_hit + shared_blks_read) * 100
                ELSE 100
            END
        ) as avg_cache_hit_ratio,
        
        -- 统计平均执行时间
        AVG(mean_time) as overall_avg_time
        
    FROM pg_stat_statements
    WHERE calls > 0
)
SELECT 
    '参数优化建议' as category,
    
    CASE 
        WHEN queries_using_temp::NUMERIC / total_queries > 0.1 THEN
            '建议增加 work_mem: 超过10%的查询使用临时文件'
        ELSE 'work_mem 配置适当'
    END as work_mem_advice,
    
    CASE 
        WHEN avg_cache_hit_ratio < 90 THEN
            '建议增加 shared_buffers: 缓存命中率低于90%'
        ELSE 'shared_buffers 配置适当'
    END as shared_buffers_advice,
    
    CASE 
        WHEN overall_avg_time > 100 THEN
            '建议检查 effective_cache_size: 整体查询较慢'
        ELSE 'effective_cache_size 配置适当'
    END as cache_size_advice
    
FROM config_analysis;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 查询执行统计：数据库自动收集的查询性能记录
🔸 pg_stat_statements：PostgreSQL的统计收集核心工具
🔸 热点查询识别：通过频率和耗时综合评估查询重要性
🔸 资源消耗监控：CPU、内存、IO等系统资源使用分析
🔸 优化建议生成：基于统计数据自动识别问题和建议解决方案
```

### 7.2 关键分析方法


**🔹 统计分析思维**
```
数据收集：启用pg_stat_statements持续收集查询统计
模式识别：按类型、复杂度、频率等维度分类分析
问题定位：通过多维度指标交叉分析找出性能瓶颈
优化决策：基于统计数据制定有针对性的优化策略
```

**🔹 优化优先级评估**
```
高优先级：高频慢查询，严重影响用户体验
中优先级：资源消耗大的查询，影响系统稳定性
低优先级：偶发性能问题，定期监控即可
```

**🔹 持续监控策略**
```
日常监控：定期查看TOP慢查询和高频查询
趋势分析：对比历史数据发现性能变化趋势
主动预警：设置阈值自动识别异常查询
优化验证：改进后对比统计数据验证效果
```

### 7.3 实战应用价值


- **性能问题快速定位**：通过统计数据直接找到问题查询
- **优化效果量化评估**：用数据证明优化改进的效果
- **系统容量规划**：基于资源消耗趋势制定扩容计划
- **数据库健康度评估**：全面了解系统运行状态
- **开发质量提升**：帮助开发者编写高效的SQL查询

### 7.4 最佳实践建议


**🏆 统计分析最佳实践**
- **定期审查**：每周查看统计数据，及时发现问题
- **阈值设置**：为关键指标设置合理的告警阈值
- **历史对比**：建立历史基线，通过对比发现异常
- **分类管理**：按查询类型和重要性分类管理和优化
- **文档记录**：记录优化过程和效果，积累经验

**💡 避免常见误区**
- **不要只看单一指标**：综合分析多个维度才能准确判断
- **不要忽视低频查询**：有些查询虽然频率低但单次耗时很长
- **不要过度优化**：优化要有明确目标，避免过度工程化
- **不要忘记重置统计**：定期重置统计数据保持分析的时效性

**核心记忆**：
- 查询执行统计是数据库性能优化的基础工具
- pg_stat_statements提供了丰富的查询执行数据
- 通过模式识别和资源分析可以精准定位性能问题
- 自动化的优化建议生成可以提高问题解决效率
- 持续监控和分析是保持数据库高性能的关键