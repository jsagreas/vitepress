---
title: 1、聚合函数与统计概述
---
## 📚 目录

1. [聚合函数基础概念](#1-聚合函数基础概念)
2. [基础聚合函数详解](#2-基础聚合函数详解)
3. [GROUP_CONCAT字符串聚合](#3-GROUP_CONCAT字符串聚合)
4. [聚合函数与NULL值处理](#4-聚合函数与NULL值处理)
5. [条件聚合表达式](#5-条件聚合表达式)
6. [聚合函数嵌套应用](#6-聚合函数嵌套应用)
7. [COUNT优化机制深度解析](#7-COUNT优化机制深度解析)
8. [聚合函数索引利用策略](#8-聚合函数索引利用策略)
9. [聚合查询性能优化](#9-聚合查询性能优化)
10. [实际应用场景与案例](#10-实际应用场景与案例)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 聚合函数基础概念


### 1.1 什么是聚合函数


**聚合函数**就像是数据的"计算器"，它能把多行数据"压缩"成一个结果。

```
通俗理解：
想象你有一堆苹果，聚合函数就是帮你：
• COUNT：数一数有多少个苹果
• SUM：算一算苹果的总重量  
• AVG：算一算平均重量
• MAX/MIN：找出最重/最轻的苹果
```

**🔸 聚合操作理论基础**
```sql
-- 原始数据（多行）
学生成绩表：
张三  85
李四  92  
王五  78
赵六  96

-- 聚合结果（单行）
AVG(成绩) = 87.75  -- 把4行数据变成1个平均值
```

### 1.2 聚合函数的数学原理


**🔸 聚合函数数学原理**

聚合函数本质上是**集合运算**：

```
数学表示：
f(S) = result
其中：S是数据集合，f是聚合函数，result是单一结果

常见聚合运算：
• COUNT(S) = |S|           (集合元素个数)
• SUM(S) = Σx_i           (所有元素求和)  
• AVG(S) = Σx_i / |S|     (算术平均数)
• MAX(S) = max{x_i}       (最大值)
• MIN(S) = min{x_i}       (最小值)
```

### 1.3 数据分析中聚合的作用


**🔸 数据分析中聚合的作用**

聚合函数是数据分析的基石：

```
业务价值：
📊 统计分析：销售总额、平均单价、最高订单
📈 趋势分析：月度增长、季度对比
📋 报表生成：各部门业绩汇总
🎯 决策支持：基于统计数据做决策

实际例子：
• 电商：计算每月销售额、平均客单价
• 教育：统计班级平均分、及格率
• 金融：计算平均利率、最大交易额
```

---

## 2. ⭐ 基础聚合函数详解


### 2.1 COUNT计数函数深度解析


**COUNT函数**就是数据的"计数器"，告诉你有多少条记录。

**🔸 COUNT的三种形式**

```sql
-- 示例表：employees
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    bonus DECIMAL(10,2)
);

INSERT INTO employees VALUES 
(1, '张三', '技术部', 8000.00, 1000.00),
(2, '李四', '销售部', 6000.00, NULL),
(3, '王五', '技术部', 9000.00, 1500.00),
(4, '赵六', '销售部', 5500.00, NULL),
(5, '钱七', '技术部', 7500.00, 800.00);
```

**COUNT(*)：统计总行数**
```sql
SELECT COUNT(*) as 总员工数 FROM employees;
-- 结果：5 (包括所有行，不管字段是否为NULL)
```

**COUNT(字段名)：统计非NULL值的行数**
```sql
SELECT COUNT(bonus) as 有奖金员工数 FROM employees;
-- 结果：3 (只统计bonus不为NULL的行)

SELECT COUNT(salary) as 有薪水员工数 FROM employees;  
-- 结果：5 (salary字段没有NULL值)
```

**COUNT(DISTINCT 字段名)：统计不重复值的个数**
```sql
SELECT COUNT(DISTINCT department) as 部门数量 FROM employees;
-- 结果：2 (技术部、销售部，去重后只有2个)
```

**💡 COUNT使用技巧**

```sql
-- 技巧1：统计满足条件的记录数
SELECT 
    COUNT(*) as 总数,
    COUNT(CASE WHEN salary > 7000 THEN 1 END) as 高薪员工数,
    COUNT(CASE WHEN bonus IS NOT NULL THEN 1 END) as 有奖金员工数
FROM employees;

-- 技巧2：计算比例
SELECT 
    COUNT(*) as 总员工数,
    COUNT(bonus) as 有奖金员工数,
    ROUND(COUNT(bonus) * 100.0 / COUNT(*), 2) as 奖金覆盖率
FROM employees;
```

### 2.2 SUM求和函数详解


**SUM函数**就像计算器的"加法"，把所有数值相加。

```sql
-- 基础求和
SELECT 
    SUM(salary) as 薪水总额,
    SUM(bonus) as 奖金总额
FROM employees;
-- 结果：薪水总额=36000.00, 奖金总额=3300.00 (NULL值被忽略)

-- 条件求和
SELECT 
    SUM(CASE WHEN department = '技术部' THEN salary ELSE 0 END) as 技术部薪水总额,
    SUM(CASE WHEN department = '销售部' THEN salary ELSE 0 END) as 销售部薪水总额
FROM employees;

-- 求和 + 分组
SELECT 
    department as 部门,
    SUM(salary) as 部门薪水总额,
    SUM(IFNULL(bonus, 0)) as 部门奖金总额
FROM employees 
GROUP BY department;
```

**⚠️ SUM使用注意事项**
```sql
-- 注意1：NULL值处理
SELECT SUM(bonus) FROM employees;  -- 结果：3300 (自动忽略NULL)
SELECT SUM(IFNULL(bonus, 0)) FROM employees;  -- 结果：3300 (手动处理NULL)

-- 注意2：数据类型溢出
-- 如果求和结果超过数据类型范围，会发生溢出
-- 建议使用DECIMAL或BIGINT类型
```

### 2.3 AVG平均值函数详解  


**AVG函数**就是求"平均数"，把总和除以个数。

```sql
-- 基础平均值
SELECT 
    AVG(salary) as 平均薪水,
    AVG(bonus) as 平均奖金    -- 只计算非NULL值的平均
FROM employees;
-- 结果：平均薪水=7200.00, 平均奖金=1100.00

-- 包含NULL的平均值计算
SELECT 
    AVG(IFNULL(bonus, 0)) as 平均奖金含零值  -- 把NULL当0处理
FROM employees;
-- 结果：660.00 (总和3300÷5人=660)

-- 分组平均值
SELECT 
    department as 部门,
    AVG(salary) as 部门平均薪水,
    COUNT(*) as 部门人数
FROM employees 
GROUP BY department;
```

**💡 AVG实用技巧**
```sql
-- 技巧1：计算加权平均
SELECT 
    SUM(salary * 工作年限) / SUM(工作年限) as 按工龄加权平均薪水
FROM employees_with_years;

-- 技巧2：移动平均
SELECT 
    date,
    sales,
    AVG(sales) OVER (ORDER BY date ROWS 6 PRECEDING) as 7天移动平均
FROM daily_sales;
```

### 2.4 MAX/MIN极值函数详解


**MAX/MIN函数**就是找"最大值"和"最小值"。

```sql
-- 基础极值查询
SELECT 
    MAX(salary) as 最高薪水,
    MIN(salary) as 最低薪水,
    MAX(bonus) as 最高奖金,    -- 自动忽略NULL值
    MIN(bonus) as 最低奖金
FROM employees;

-- 字符串类型的MAX/MIN (按字典序)
SELECT 
    MAX(name) as 姓名最大值,    -- 按字典序最大
    MIN(name) as 姓名最小值     -- 按字典序最小
FROM employees;

-- 日期类型的MAX/MIN
SELECT 
    MAX(hire_date) as 最新入职日期,
    MIN(hire_date) as 最早入职日期
FROM employees;
```

**🎯 MAX/MIN实用场景**
```sql
-- 场景1：找出最值对应的完整记录
SELECT * FROM employees 
WHERE salary = (SELECT MAX(salary) FROM employees);

-- 场景2：计算极值差
SELECT 
    MAX(salary) - MIN(salary) as 薪水差距,
    MAX(salary) / MIN(salary) as 薪水倍数
FROM employees;

-- 场景3：分组极值
SELECT 
    department,
    MAX(salary) as 部门最高薪水,
    MIN(salary) as 部门最低薪水
FROM employees 
GROUP BY department;
```

---

## 3. 🔤 GROUP_CONCAT字符串聚合


### 3.1 GROUP_CONCAT基本用法


**GROUP_CONCAT**就像是把多个字符串"串起来"的函数。

```sql
-- 基础字符串聚合
SELECT 
    department,
    GROUP_CONCAT(name) as 员工姓名列表
FROM employees 
GROUP BY department;

-- 结果：
-- 技术部    张三,王五,钱七
-- 销售部    李四,赵六
```

### 3.2 GROUP_CONCAT高级用法


```sql
-- 自定义分隔符
SELECT 
    department,
    GROUP_CONCAT(name SEPARATOR ' | ') as 员工列表
FROM employees 
GROUP BY department;
-- 结果：技术部    张三 | 王五 | 钱七

-- 字符串排序
SELECT 
    department,
    GROUP_CONCAT(name ORDER BY salary DESC SEPARATOR ', ') as 按薪水排序员工列表
FROM employees 
GROUP BY department;

-- 去重聚合
SELECT 
    GROUP_CONCAT(DISTINCT department) as 所有部门
FROM employees;
-- 结果：技术部,销售部

-- 限制长度
SELECT 
    department,
    GROUP_CONCAT(name SEPARATOR ',' LIMIT 2) as 前两名员工    -- MySQL特定语法
FROM employees 
GROUP BY department;
```

### 3.3 GROUP_CONCAT实际应用


```sql
-- 应用1：构造SQL语句
SELECT 
    CONCAT('UPDATE employees SET bonus = bonus * 1.1 WHERE id IN (', 
           GROUP_CONCAT(id), 
           ');') as 批量更新SQL
FROM employees 
WHERE department = '技术部';

-- 应用2：生成报表格式
SELECT 
    department,
    COUNT(*) as 人数,
    GROUP_CONCAT(CONCAT(name, '(', salary, ')') ORDER BY salary DESC) as 详细信息
FROM employees 
GROUP BY department;

-- 应用3：标签聚合
SELECT 
    user_id,
    GROUP_CONCAT(DISTINCT tag_name SEPARATOR ', ') as 用户标签
FROM user_tags 
GROUP BY user_id;
```

---

## 4. ⭐ 聚合函数与NULL值处理规则


### 4.1 NULL值处理基本规则


**核心原则**：大多数聚合函数都会**自动忽略NULL值**。

```sql
-- 测试数据
CREATE TABLE test_null (
    id INT,
    value1 INT,
    value2 INT
);

INSERT INTO test_null VALUES
(1, 10, NULL),
(2, 20, 30),
(3, NULL, 40),
(4, 30, NULL),
(5, NULL, NULL);

-- NULL值处理测试
SELECT 
    COUNT(*) as 总行数,                    -- 5
    COUNT(value1) as value1非空行数,        -- 3
    COUNT(value2) as value2非空行数,        -- 2
    SUM(value1) as value1总和,             -- 60 (10+20+30)
    SUM(value2) as value2总和,             -- 70 (30+40)
    AVG(value1) as value1平均,             -- 20 (60÷3)
    AVG(value2) as value2平均              -- 35 (70÷2)
FROM test_null;
```

### 4.2 NULL值处理策略


**策略1：让NULL参与计算**
```sql
-- 把NULL当作0处理
SELECT 
    SUM(IFNULL(value1, 0)) as value1总和含零,        -- 60
    AVG(IFNULL(value1, 0)) as value1平均含零         -- 12 (60÷5)
FROM test_null;

-- 使用COALESCE处理多个字段
SELECT 
    SUM(COALESCE(value1, value2, 0)) as 优先总和
FROM test_null;
```

**策略2：排除NULL值**
```sql
-- 明确排除NULL
SELECT 
    AVG(value1) as 平均值
FROM test_null 
WHERE value1 IS NOT NULL;

-- 条件聚合排除NULL
SELECT 
    COUNT(CASE WHEN value1 IS NOT NULL AND value1 > 15 THEN 1 END) as 大于15的非空值个数
FROM test_null;
```

**策略3：NULL值统计**
```sql
-- 统计NULL值情况
SELECT 
    COUNT(*) as 总行数,
    COUNT(value1) as 非空行数,
    COUNT(*) - COUNT(value1) as 空值行数,
    ROUND(COUNT(value1) * 100.0 / COUNT(*), 2) as 数据完整率
FROM test_null;
```

---

## 5. 🎯 条件聚合表达式


### 5.1 CASE WHEN条件聚合


**条件聚合**就是"有选择性地"进行统计，就像给聚合函数加上"过滤器"。

```sql
-- 基础条件聚合
SELECT 
    COUNT(CASE WHEN salary > 7000 THEN 1 END) as 高薪员工数,
    COUNT(CASE WHEN salary <= 7000 THEN 1 END) as 普通员工数,
    SUM(CASE WHEN department = '技术部' THEN salary ELSE 0 END) as 技术部薪水总额,
    AVG(CASE WHEN bonus IS NOT NULL THEN bonus END) as 有奖金员工平均奖金
FROM employees;
```

### 5.2 复杂条件聚合


```sql
-- 多条件组合聚合
SELECT 
    department,
    COUNT(*) as 总人数,
    COUNT(CASE WHEN salary > 7000 AND bonus IS NOT NULL THEN 1 END) as 高薪有奖金人数,
    SUM(CASE 
        WHEN salary > 8000 THEN salary * 1.2  -- 高薪员工按1.2倍计算
        WHEN salary > 6000 THEN salary * 1.1  -- 中薪员工按1.1倍计算
        ELSE salary 
    END) as 调薪后总薪水
FROM employees 
GROUP BY department;

-- 时间范围条件聚合
SELECT 
    YEAR(order_date) as 年份,
    COUNT(CASE WHEN MONTH(order_date) BETWEEN 1 AND 3 THEN 1 END) as Q1订单数,
    COUNT(CASE WHEN MONTH(order_date) BETWEEN 4 AND 6 THEN 1 END) as Q2订单数,
    COUNT(CASE WHEN MONTH(order_date) BETWEEN 7 AND 9 THEN 1 END) as Q3订单数,
    COUNT(CASE WHEN MONTH(order_date) BETWEEN 10 AND 12 THEN 1 END) as Q4订单数
FROM orders 
GROUP BY YEAR(order_date);
```

### 5.3 条件聚合实用技巧


```sql
-- 技巧1：计算比例和百分比
SELECT 
    department,
    COUNT(*) as 总人数,
    COUNT(CASE WHEN bonus IS NOT NULL THEN 1 END) as 有奖金人数,
    ROUND(
        COUNT(CASE WHEN bonus IS NOT NULL THEN 1 END) * 100.0 / COUNT(*), 
        2
    ) as 奖金覆盖率
FROM employees 
GROUP BY department;

-- 技巧2：动态分组聚合
SELECT 
    CASE 
        WHEN salary < 6000 THEN '低薪组'
        WHEN salary < 8000 THEN '中薪组'
        ELSE '高薪组'
    END as 薪水组别,
    COUNT(*) as 人数,
    AVG(salary) as 平均薪水,
    MAX(salary) as 最高薪水,
    MIN(salary) as 最低薪水
FROM employees 
GROUP BY 
    CASE 
        WHEN salary < 6000 THEN '低薪组'
        WHEN salary < 8000 THEN '中薪组'
        ELSE '高薪组'
    END;
```

---

## 6. 🔄 聚合函数嵌套应用


### 6.1 嵌套聚合基本概念


**聚合函数嵌套**就是把一个聚合函数的结果，再作为另一个聚合函数的输入。

```
通俗理解：
就像俄罗斯套娃，一层套一层
内层聚合：先算出每组的结果
外层聚合：再对这些结果进行聚合
```

### 6.2 子查询中的聚合嵌套


```sql
-- 例子1：找出薪水高于平均薪水的员工
SELECT name, salary,
       (SELECT AVG(salary) FROM employees) as 平均薪水
FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 例子2：找出每个部门薪水最高的员工
SELECT e1.name, e1.department, e1.salary
FROM employees e1
WHERE e1.salary = (
    SELECT MAX(e2.salary) 
    FROM employees e2 
    WHERE e2.department = e1.department
);

-- 例子3：计算高于部门平均薪水的员工比例
SELECT 
    department,
    COUNT(*) as 总人数,
    COUNT(CASE WHEN salary > dept_avg THEN 1 END) as 高于平均人数,
    ROUND(COUNT(CASE WHEN salary > dept_avg THEN 1 END) * 100.0 / COUNT(*), 2) as 比例
FROM (
    SELECT 
        name, 
        department, 
        salary,
        AVG(salary) OVER (PARTITION BY department) as dept_avg
    FROM employees
) t
GROUP BY department;
```

### 6.3 窗口函数与聚合嵌套


```sql
-- 综合应用：计算累计值和移动平均
SELECT 
    date,
    sales,
    SUM(sales) OVER (ORDER BY date) as 累计销售额,
    AVG(sales) OVER (ORDER BY date ROWS 6 PRECEDING) as 7天移动平均,
    sales / AVG(sales) OVER (ORDER BY date ROWS 6 PRECEDING) as 相对平均比
FROM daily_sales
ORDER BY date;

-- 排名与聚合结合
SELECT 
    department,
    name,
    salary,
    AVG(salary) OVER (PARTITION BY department) as 部门平均薪水,
    salary - AVG(salary) OVER (PARTITION BY department) as 与部门平均差额,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as 部门内排名
FROM employees;
```

---

## 7. 🔥 COUNT优化机制深度解析


### 7.1 COUNT(*)优化机制


**COUNT(\*)是最常用但也最容易被误解的聚合函数**。

```
🎯 核心理解：
COUNT(*) 统计的是"行数"，不是"数据个数"
即使整行都是NULL，COUNT(*)仍然算1行
```

**🔸 不同COUNT形式的性能对比**

```sql
-- 性能测试表
CREATE TABLE test_count (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    email VARCHAR(100),
    age INT,
    INDEX idx_name (name),
    INDEX idx_email (email)
);

-- 插入100万条测试数据
INSERT INTO test_count (name, email, age) 
SELECT 
    CONCAT('user_', id), 
    CONCAT('user_', id, '@example.com'),
    FLOOR(RAND() * 60) + 18
FROM (
    SELECT row_number() OVER() as id
    FROM information_schema.columns a, information_schema.columns b
    LIMIT 1000000
) t;
```

**性能对比测试**
```sql
-- 1. COUNT(*) - 最优性能 ⭐⭐⭐⭐⭐
SELECT COUNT(*) FROM test_count;
-- 优势：数据库引擎优化最好，不需要检查具体列值

-- 2. COUNT(1) - 性能接近COUNT(*)  ⭐⭐⭐⭐
SELECT COUNT(1) FROM test_count;  
-- 原理：1是常量，不需要检查列值，性能接近COUNT(*)

-- 3. COUNT(主键) - 性能较好 ⭐⭐⭐
SELECT COUNT(id) FROM test_count;
-- 原理：主键不为NULL，但需要访问主键列

-- 4. COUNT(普通列) - 性能一般 ⭐⭐
SELECT COUNT(name) FROM test_count;
-- 原理：需要检查每行该列是否为NULL

-- 5. COUNT(DISTINCT 列) - 性能最差 ⭐
SELECT COUNT(DISTINCT name) FROM test_count;
-- 原理：需要去重计算，最耗资源
```

### 7.2 COUNT优化策略


**策略1：利用索引优化COUNT**
```sql
-- 创建合适的索引
CREATE INDEX idx_status ON orders (status);

-- 优化前（全表扫描）
SELECT COUNT(*) FROM orders WHERE status = 'completed';

-- 优化后（索引扫描）
-- 确保status字段有索引，查询会使用索引统计
EXPLAIN SELECT COUNT(*) FROM orders WHERE status = 'completed';
```

**策略2：近似COUNT替代精确COUNT**
```sql
-- 对于大表，使用近似值
SELECT table_rows as 近似行数
FROM information_schema.tables 
WHERE table_schema = 'database_name' 
  AND table_name = 'table_name';

-- 使用采样估算
SELECT COUNT(*) * 100 as 估算总数
FROM table_name 
WHERE RAND() < 0.01;  -- 1%采样
```

**策略3：分段COUNT**
```sql
-- 对于大表分段统计
SELECT 
    SUM(CASE WHEN id BETWEEN 1 AND 100000 THEN 1 ELSE 0 END) as 段1,
    SUM(CASE WHEN id BETWEEN 100001 AND 200000 THEN 1 ELSE 0 END) as 段2,
    SUM(CASE WHEN id BETWEEN 200001 AND 300000 THEN 1 ELSE 0 END) as 段3
FROM large_table;
```

### 7.3 COUNT的常见误区


```sql
-- ❌ 误区1：认为COUNT(1)比COUNT(*)快
-- 实际：两者性能基本相同
SELECT COUNT(1) FROM table_name;  -- 不一定比COUNT(*)快
SELECT COUNT(*) FROM table_name;  -- 推荐使用

-- ❌ 误区2：在有WHERE条件时使用COUNT(*)
-- 问题：可能无法利用索引
SELECT COUNT(*) FROM orders WHERE create_date = '2023-01-01';
-- ✅ 优化：确保有合适索引
CREATE INDEX idx_create_date ON orders (create_date);

-- ❌ 误区3：频繁COUNT大表
-- 问题：每次都是全表扫描
-- ✅ 解决：维护计数器表
CREATE TABLE table_counters (
    table_name VARCHAR(50) PRIMARY KEY,
    row_count BIGINT,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 8. 🔥 聚合函数索引利用策略


### 8.1 索引对聚合查询的影响


**索引就像书的目录，能大大提高聚合查询的效率**。

```
📚 类比理解：
没有索引的聚合查询 = 逐页翻书统计
有索引的聚合查询 = 看目录快速定位
```

### 8.2 GROUP BY查询的索引优化


```sql
-- 示例表结构
CREATE TABLE sales (
    id INT PRIMARY KEY,
    product_id INT,
    category_id INT,
    sales_date DATE,
    amount DECIMAL(10,2),
    quantity INT,
    
    -- 关键：为GROUP BY字段创建索引
    INDEX idx_category (category_id),
    INDEX idx_date (sales_date),
    INDEX idx_product_category (product_id, category_id),
    INDEX idx_date_category (sales_date, category_id)
);
```

**索引优化实例**
```sql
-- 1. 单字段GROUP BY优化
-- ✅ 优化版本
SELECT category_id, SUM(amount), COUNT(*)
FROM sales 
GROUP BY category_id;
-- 使用idx_category索引，避免排序操作

-- 2. 多字段GROUP BY优化
-- ✅ 优化版本  
SELECT sales_date, category_id, SUM(amount)
FROM sales 
GROUP BY sales_date, category_id;
-- 使用idx_date_category复合索引

-- ❌ 未优化版本
SELECT category_id, sales_date, SUM(amount)
FROM sales 
GROUP BY category_id, sales_date;
-- GROUP BY顺序与索引不匹配，可能无法充分利用索引
```

### 8.3 WHERE + GROUP BY的索引策略


```sql
-- 复合索引设计原则：WHERE字段在前，GROUP BY字段在后
CREATE INDEX idx_optimal ON sales (category_id, sales_date, product_id);

-- ✅ 最优查询
SELECT product_id, SUM(amount), AVG(quantity)
FROM sales 
WHERE category_id = 10 
  AND sales_date >= '2023-01-01'
GROUP BY product_id;
-- 完美匹配索引：category_id(WHERE) -> sales_date(WHERE) -> product_id(GROUP BY)

-- 索引使用分析
EXPLAIN SELECT product_id, SUM(amount), AVG(quantity)
FROM sales 
WHERE category_id = 10 AND sales_date >= '2023-01-01'
GROUP BY product_id;
```

### 8.4 聚合函数特定索引优化


**MAX/MIN函数优化**
```sql
-- MAX/MIN可以直接利用索引
CREATE INDEX idx_amount ON sales (amount);

-- ✅ 高效查询
SELECT MAX(amount) FROM sales;  -- 直接从索引末尾获取
SELECT MIN(amount) FROM sales;  -- 直接从索引开头获取

-- 分组MAX/MIN优化
CREATE INDEX idx_category_amount ON sales (category_id, amount);

SELECT category_id, MAX(amount), MIN(amount)
FROM sales 
GROUP BY category_id;
-- 每个category_id组的最大最小值可以从索引直接获取
```

**COUNT DISTINCT优化**
```sql
-- COUNT DISTINCT优化
CREATE INDEX idx_category_product ON sales (category_id, product_id);

-- ✅ 优化查询
SELECT category_id, COUNT(DISTINCT product_id)
FROM sales 
GROUP BY category_id;
-- 利用复合索引避免额外排序
```

---

## 9. 🔑 聚合查询性能优化


### 9.1 聚合函数性能优化核心策略


**🎯 性能优化金字塔**

```
           🏆 业务层优化
          ↗               ↖
    🔧 查询优化           📊 数据模型优化  
        ↗     ↖           ↗         ↖
  🗃️ 索引优化   ⚡缓存优化   🏗️ 表结构   📈 分区优化
```

### 9.2 查询层面优化


**优化1：减少聚合数据量**
```sql
-- ❌ 低效：全表聚合后过滤
SELECT department, AVG(salary)
FROM employees 
GROUP BY department
HAVING AVG(salary) > 7000;

-- ✅ 高效：先过滤再聚合
SELECT department, AVG(salary)
FROM employees 
WHERE salary > 5000  -- 先减少数据量
GROUP BY department
HAVING AVG(salary) > 7000;
```

**优化2：避免重复聚合计算**
```sql
-- ❌ 低效：多次重复聚合
SELECT 
    (SELECT COUNT(*) FROM orders WHERE status = 'completed') as 完成订单数,
    (SELECT COUNT(*) FROM orders WHERE status = 'pending') as 待处理订单数,
    (SELECT COUNT(*) FROM orders WHERE status = 'cancelled') as 取消订单数;

-- ✅ 高效：一次查询完成所有聚合
SELECT 
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as 完成订单数,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as 待处理订单数,
    COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as 取消订单数
FROM orders;
```

**优化3：合理使用LIMIT**
```sql
-- 对于只需要前几名的聚合，使用LIMIT
SELECT department, SUM(sales) as 部门销售额
FROM sales_data
GROUP BY department
ORDER BY SUM(sales) DESC
LIMIT 5;  -- 只取前5名，减少排序开销
```

### 9.3 数据模型优化


**策略1：预聚合表设计**
```sql
-- 原始明细表
CREATE TABLE order_details (
    order_id INT,
    product_id INT,
    quantity INT,
    amount DECIMAL(10,2),
    order_date DATE
);

-- 创建日汇总表
CREATE TABLE daily_sales_summary (
    sales_date DATE PRIMARY KEY,
    total_orders INT,
    total_amount DECIMAL(15,2),
    total_quantity BIGINT,
    avg_order_value DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_date (sales_date)
);

-- 定时更新汇总表
INSERT INTO daily_sales_summary (sales_date, total_orders, total_amount, total_quantity, avg_order_value)
SELECT 
    DATE(order_date) as sales_date,
    COUNT(DISTINCT order_id) as total_orders,
    SUM(amount) as total_amount,
    SUM(quantity) as total_quantity,
    AVG(amount) as avg_order_value
FROM order_details 
WHERE DATE(order_date) = CURDATE()
GROUP BY DATE(order_date)
ON DUPLICATE KEY UPDATE
    total_orders = VALUES(total_orders),
    total_amount = VALUES(total_amount),
    total_quantity = VALUES(total_quantity),
    avg_order_value = VALUES(avg_order_value);
```

**策略2：分区表优化**
```sql
-- 按时间分区的大表
CREATE TABLE sales_by_month (
    id BIGINT AUTO_INCREMENT,
    sales_date DATE,
    amount DECIMAL(10,2),
    category_id INT,
    PRIMARY KEY (id, sales_date),
    INDEX idx_category (category_id)
)
PARTITION BY RANGE (YEAR(sales_date) * 100 + MONTH(sales_date)) (
    PARTITION p202301 VALUES LESS THAN (202302),
    PARTITION p202302 VALUES LESS THAN (202303),
    PARTITION p202303 VALUES LESS THAN (202304),
    -- ... 更多分区
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 分区优化聚合查询
SELECT MONTH(sales_date) as 月份, SUM(amount) as 月销售额
FROM sales_by_month 
WHERE sales_date BETWEEN '2023-01-01' AND '2023-03-31'
GROUP BY MONTH(sales_date);
-- 只扫描相关分区，大大提高效率
```

### 9.4 聚合查询设计最佳实践


**🔑 最佳实践清单**

```markdown
✅ **索引设计**
- [ ] 为GROUP BY字段创建索引
- [ ] WHERE条件字段放在复合索引前面  
- [ ] 避免在函数上聚合（如SUM(YEAR(date))）

✅ **查询优化** 
- [ ] 先WHERE过滤再GROUP BY聚合
- [ ] 避免SELECT *，只选择需要的字段
- [ ] 合理使用HAVING vs WHERE

✅ **数据模型**
- [ ] 考虑创建汇总表存储预聚合结果
- [ ] 大表考虑分区设计
- [ ] 合理设计数据类型（避免过大类型）

✅ **性能监控**
- [ ] 使用EXPLAIN分析执行计划
- [ ] 监控慢查询日志
- [ ] 定期检查索引使用情况
```

**实际案例：电商订单聚合优化**
```sql
-- ❌ 优化前（性能差）
SELECT 
    u.username,
    COUNT(o.id) as 订单数,
    SUM(o.amount) as 总金额,
    AVG(o.amount) as 平均订单金额
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.created_at >= '2023-01-01'
GROUP BY u.id, u.username
HAVING COUNT(o.id) > 10
ORDER BY SUM(o.amount) DESC;

-- ✅ 优化后（高性能）
-- 1. 添加必要索引
CREATE INDEX idx_orders_user_created ON orders (user_id, created_at);
CREATE INDEX idx_orders_amount ON orders (amount);

-- 2. 优化查询逻辑
SELECT 
    u.username,
    o.订单数,
    o.总金额,
    o.平均订单金额
FROM users u
INNER JOIN (
    SELECT 
        user_id,
        COUNT(*) as 订单数,
        SUM(amount) as 总金额,
        AVG(amount) as 平均订单金额
    FROM orders 
    WHERE created_at >= '2023-01-01'
    GROUP BY user_id
    HAVING COUNT(*) > 10
) o ON u.id = o.user_id
ORDER BY o.总金额 DESC;
```

---

## 10. 🚀 实际应用场景与案例


### 10.1 电商数据分析场景


**场景1：销售报表分析**
```sql
-- 综合销售分析报表
SELECT 
    -- 时间维度
    DATE_FORMAT(order_date, '%Y-%m') as 月份,
    
    -- 基础指标
    COUNT(DISTINCT order_id) as 订单数,
    COUNT(DISTINCT customer_id) as 客户数,
    SUM(amount) as 销售总额,
    
    -- 平均指标
    AVG(amount) as 平均订单金额,
    SUM(amount) / COUNT(DISTINCT customer_id) as 客户平均消费,
    
    -- 比率指标
    COUNT(CASE WHEN amount > 500 THEN 1 END) * 100.0 / COUNT(*) as 大单占比,
    
    -- 累计指标
    SUM(SUM(amount)) OVER (ORDER BY DATE_FORMAT(order_date, '%Y-%m')) as 累计销售额
    
FROM orders 
WHERE order_date >= '2023-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m')
ORDER BY 月份;
```

**场景2：商品销售排名**
```sql
-- 商品销售TOP分析
SELECT 
    p.product_name as 商品名称,
    p.category_name as 类别,
    
    -- 销售数量指标
    SUM(od.quantity) as 销售数量,
    COUNT(DISTINCT od.order_id) as 订单次数,
    
    -- 销售金额指标  
    SUM(od.quantity * od.price) as 销售金额,
    AVG(od.quantity * od.price) as 平均订单金额,
    
    -- 排名指标
    RANK() OVER (ORDER BY SUM(od.quantity * od.price) DESC) as 销售金额排名,
    RANK() OVER (ORDER BY SUM(od.quantity) DESC) as 销售数量排名,
    
    -- 占比指标
    SUM(od.quantity * od.price) * 100.0 / (
        SELECT SUM(quantity * price) FROM order_details 
        WHERE order_date >= '2023-01-01'
    ) as 销售额占比

FROM products p
INNER JOIN order_details od ON p.id = od.product_id
WHERE od.order_date >= '2023-01-01'
GROUP BY p.id, p.product_name, p.category_name
HAVING SUM(od.quantity * od.price) > 10000  -- 只看销售额超过1万的商品
ORDER BY 销售金额 DESC
LIMIT 20;
```

### 10.2 用户行为分析场景


**场景3：用户留存分析**
```sql
-- 用户留存率分析
WITH user_first_visit AS (
    SELECT 
        user_id,
        MIN(DATE(visit_time)) as 首次访问日期
    FROM user_visits 
    GROUP BY user_id
),
retention_analysis AS (
    SELECT 
        ufv.首次访问日期,
        COUNT(DISTINCT ufv.user_id) as 新用户数,
        
        -- 各时期留存用户数
        COUNT(DISTINCT CASE 
            WHEN uv.visit_time >= ufv.首次访问日期 + INTERVAL 1 DAY 
             AND uv.visit_time < ufv.首次访问日期 + INTERVAL 2 DAY 
            THEN ufv.user_id 
        END) as 次日留存用户数,
        
        COUNT(DISTINCT CASE 
            WHEN uv.visit_time >= ufv.首次访问日期 + INTERVAL 7 DAY 
             AND uv.visit_time < ufv.首次访问日期 + INTERVAL 8 DAY 
            THEN ufv.user_id 
        END) as 7日留存用户数,
        
        COUNT(DISTINCT CASE 
            WHEN uv.visit_time >= ufv.首次访问日期 + INTERVAL 30 DAY 
             AND uv.visit_time < ufv.首次访问日期 + INTERVAL 31 DAY 
            THEN ufv.user_id 
        END) as 30日留存用户数
        
    FROM user_first_visit ufv
    LEFT JOIN user_visits uv ON ufv.user_id = uv.user_id
    WHERE ufv.首次访问日期 >= '2023-01-01'
    GROUP BY ufv.首次访问日期
)
SELECT 
    首次访问日期,
    新用户数,
    次日留存用户数,
    7日留存用户数,
    30日留存用户数,
    
    -- 留存率计算
    ROUND(次日留存用户数 * 100.0 / 新用户数, 2) as 次日留存率,
    ROUND(7日留存用户数 * 100.0 / 新用户数, 2) as 7日留存率,
    ROUND(30日留存用户数 * 100.0 / 新用户数, 2) as 30日留存率
    
FROM retention_analysis
WHERE 新用户数 > 0
ORDER BY 首次访问日期;
```

### 10.3 财务数据分析场景


**场景4：财务收支分析**
```sql
-- 月度财务收支分析
SELECT 
    DATE_FORMAT(transaction_date, '%Y-%m') as 月份,
    
    -- 收入分析
    SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) as 总收入,
    COUNT(CASE WHEN type = 'income' THEN 1 END) as 收入笔数,
    AVG(CASE WHEN type = 'income' THEN amount END) as 平均收入,
    
    -- 支出分析
    SUM(CASE WHEN type = 'expense' THEN amount ELSE 0 END) as 总支出,
    COUNT(CASE WHEN type = 'expense' THEN 1 END) as 支出笔数,
    AVG(CASE WHEN type = 'expense' THEN amount END) as 平均支出,
    
    -- 净收入
    SUM(CASE WHEN type = 'income' THEN amount ELSE -amount END) as 净收入,
    
    -- 同比分析
    SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) 
    - LAG(SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END), 12) 
      OVER (ORDER BY DATE_FORMAT(transaction_date, '%Y-%m')) as 收入同比增长,
    
    -- 资金流动性指标
    SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) 
    / SUM(CASE WHEN type = 'expense' THEN amount ELSE 0 END) as 收支比率

FROM financial_transactions 
WHERE transaction_date >= '2022-01-01'
GROUP BY DATE_FORMAT(transaction_date, '%Y-%m')
ORDER BY 月份;
```

### 10.4 运营数据监控场景


**场景5：网站访问统计**
```sql
-- 网站访问综合统计
SELECT 
    DATE(visit_time) as 日期,
    
    -- 访问量统计
    COUNT(*) as 总PV,
    COUNT(DISTINCT user_id) as 独立访客UV,
    COUNT(DISTINCT session_id) as 会话数,
    
    -- 平均指标
    AVG(page_views) as 平均页面浏览数,
    AVG(stay_duration) as 平均停留时长,
    
    -- 来源分析
    COUNT(CASE WHEN referrer_type = 'search' THEN 1 END) as 搜索流量,
    COUNT(CASE WHEN referrer_type = 'direct' THEN 1 END) as 直接流量,
    COUNT(CASE WHEN referrer_type = 'social' THEN 1 END) as 社交流量,
    
    -- 设备分析
    COUNT(CASE WHEN device_type = 'mobile' THEN 1 END) * 100.0 / COUNT(*) as 移动端占比,
    COUNT(CASE WHEN device_type = 'desktop' THEN 1 END) * 100.0 / COUNT(*) as PC端占比,
    
    -- 转化分析
    COUNT(CASE WHEN has_conversion = 1 THEN 1 END) * 100.0 / COUNT(DISTINCT session_id) as 转化率,
    
    -- 跳出率
    COUNT(CASE WHEN page_views = 1 THEN 1 END) * 100.0 / COUNT(DISTINCT session_id) as 跳出率

FROM website_visits 
WHERE visit_time >= CURDATE() - INTERVAL 30 DAY
GROUP BY DATE(visit_time)
ORDER BY 日期 DESC;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🎯 **聚合函数本质**
✓ 多行数据压缩成单个结果的运算
✓ 自动忽略NULL值（COUNT(*)除外）
✓ 配合GROUP BY实现分组统计

🔢 **基础聚合函数**
✓ COUNT：统计行数/非空值个数
✓ SUM：数值求和运算  
✓ AVG：算术平均值计算
✓ MAX/MIN：最大/最小值查找

🎪 **高级应用技巧**
✓ 条件聚合：CASE WHEN配合聚合函数
✓ 字符串聚合：GROUP_CONCAT拼接字符串
✓ 聚合嵌套：子查询中的复杂聚合运算
```

### 11.2 性能优化关键点


```
🔥 **COUNT优化**
✓ COUNT(*) > COUNT(1) > COUNT(主键) > COUNT(普通列)
✓ 利用索引统计，避免全表扫描
✓ 大表使用近似统计或预聚合

🚀 **索引策略**
✓ GROUP BY字段必须有索引
✓ WHERE + GROUP BY：WHERE字段在索引前面
✓ 复合索引顺序：WHERE字段 → GROUP BY字段

⚡ **查询优化**
✓ 先过滤(WHERE)再聚合(GROUP BY)
✓ 避免重复聚合计算
✓ 合理使用HAVING vs WHERE
```

### 11.3 实际应用指导


**🎯 应用场景判断**
```
数据统计报表 → 基础聚合函数 + GROUP BY
用户行为分析 → 条件聚合 + 窗口函数  
实时监控大屏 → 预聚合表 + 缓存策略
财务数据分析 → 复杂聚合嵌套 + 同比环比
```

**🔧 设计最佳实践**
```
✅ 业务设计
- [ ] 根据查询频率设计预聚合表
- [ ] 实时性要求高的用缓存
- [ ] 历史数据分析用离线计算

✅ 技术实现  
- [ ] 为聚合字段创建合适索引
- [ ] 大表考虑分区存储
- [ ] 监控慢查询并持续优化

✅ 数据质量
- [ ] 处理NULL值的业务逻辑
- [ ] 数据类型选择避免溢出
- [ ] 建立数据校验机制
```

### 11.4 学习检查清单


**🎓 基础掌握度检查**
```
- [ ] 能解释COUNT(*)和COUNT(字段)的区别？
- [ ] 会使用CASE WHEN进行条件聚合？
- [ ] 理解GROUP BY的分组原理？
- [ ] 知道聚合函数如何处理NULL值？
```

**🏆 进阶应用检查**
```  
- [ ] 能设计复杂的业务统计查询？
- [ ] 会分析聚合查询的执行计划？
- [ ] 能识别并优化慢聚合查询？
- [ ] 掌握预聚合表的设计思路？
```

**💡 核心记忆口诀**
```
聚合函数五兄弟：COUNT SUM AVG MAX MIN
NULL值自动被忽略，COUNT星号要记清  
条件聚合CASE WHEN，GROUP BY分组要建索引
先过滤来后聚合，性能优化是王道
```

**🔗 扩展学习方向**
- **窗口函数**：OVER子句的高级分析功能
- **数据仓库**：OLAP环境中的聚合优化  
- **实时计算**：流处理中的增量聚合
- **大数据**：Hadoop/Spark中的分布式聚合

---

**🎯 学习目标达成**
通过本章学习，你应该能够：
- ✅ 熟练使用所有基础聚合函数
- ✅ 设计复杂的条件聚合查询  
- ✅ 优化聚合查询性能
- ✅ 解决实际业务中的统计分析需求
