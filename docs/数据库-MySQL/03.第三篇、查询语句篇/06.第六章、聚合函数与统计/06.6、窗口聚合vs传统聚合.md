---
title: 6、窗口聚合vs传统聚合
---
## 📚 目录

1. [聚合概念基础理解](#1-聚合概念基础理解)
2. [传统聚合详解](#2-传统聚合详解)
3. [窗口聚合详解](#3-窗口聚合详解)
4. [聚合方式对比分析](#4-聚合方式对比分析)
5. [结果集结构差异](#5-结果集结构差异)
6. [性能特点对比](#6-性能特点对比)
7. [应用场景选择](#7-应用场景选择)
8. [业务需求适配](#8-业务需求适配)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 聚合概念基础理解


### 1.1 什么是聚合函数

> **💡 核心理解**
> 聚合函数就像是对一堆数据进行"总结汇报"的工具，把多行数据变成一行结果

**🔸 生活化理解**
```
就像班级成绩统计：
原始数据：小明85分，小红92分，小刚78分...
聚合结果：平均分85分，最高分92分，总人数30人

聚合 = 多变少 = 汇总统计
```

**📋 常见聚合函数**
| 函数名 | **作用** | **生活类比** | **结果** |
|--------|----------|--------------|----------|
| `COUNT()` | 统计个数 | `数人头` | `总共30人` |
| `SUM()` | 求和 | `算总分` | `总分2550分` |
| `AVG()` | 求平均 | `算平均分` | `平均85分` |
| `MAX()` | 求最大值 | `找最高分` | `最高92分` |
| `MIN()` | 求最小值 | `找最低分` | `最低68分` |

### 1.2 聚合函数的本质特点

```
输入：多行数据 (N行)
处理：统计计算
输出：单一结果 (1行)

这就是聚合的核心：多行变一行
```

**⚠️ 重要理解**
- 聚合函数会"压缩"数据
- 多行记录变成单行统计结果
- 原始明细数据会被"隐藏"

---

## 2. 🔍 传统聚合详解


### 2.1 传统聚合的工作方式

> **🔧 核心机制**
> 传统聚合会把所有符合条件的数据"打包"在一起，算出一个总结果

**📝 基础示例**
```sql
-- 员工工资表
CREATE TABLE employees (
    id INT,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2)
);

-- 插入示例数据
INSERT INTO employees VALUES
(1, '张三', '技术部', 8000),
(2, '李四', '技术部', 9000),
(3, '王五', '销售部', 7000),
(4, '赵六', '销售部', 7500),
(5, '孙七', '技术部', 8500);
```

### 2.2 基本聚合操作

**🎯 全表聚合**
```sql
-- 所有员工的平均工资
SELECT AVG(salary) as 平均工资 FROM employees;
```
```
结果：
+----------+
| 平均工资  |
+----------+
| 8000.00  |
+----------+
```

**🔹 特点分析**
- **输入**：5行员工数据
- **输出**：1行统计结果
- **信息丢失**：看不到任何员工个人信息

### 2.3 分组聚合(GROUP BY)

**💡 分组聚合的理解**
```
就像把学生按班级分组统计成绩：
1班：平均85分，人数25人
2班：平均87分，人数28人
3班：平均83分，人数26人

每组一个统计结果
```

**📋 实际操作**
```sql
-- 按部门统计平均工资
SELECT 
    department as 部门,
    AVG(salary) as 平均工资,
    COUNT(*) as 人数
FROM employees
GROUP BY department;
```
```
结果：
+--------+----------+------+
| 部门    | 平均工资  | 人数 |
+--------+----------+------+
| 技术部  | 8500.00  | 3    |
| 销售部  | 7250.00  | 2    |
+--------+----------+------+
```

### 2.4 传统聚合的局限性

**❓ 常见问题**
```
问题1：我想知道每个员工的工资和部门平均工资的差距？
传统方案：需要子查询或者JOIN，复杂且性能差

问题2：我想看每个员工在部门内的工资排名？
传统方案：需要复杂的子查询，很难实现

问题3：我想计算累计销售额？
传统方案：需要自连接，性能很差
```

**🔸 核心问题**
传统聚合是"要么全要，要么都不要"：
- 要聚合结果？失去明细数据
- 要明细数据？失去聚合结果
- 不能同时拥有两者

---

## 3. 🚀 窗口聚合详解


### 3.1 窗口函数的革命性改变

> **⭐ 核心优势**
> 窗口函数让你"既要又要"：既要明细数据，又要聚合结果

**🔸 生活化理解**
```
传统聚合像"年级总结会"：
只告诉你各班平均分，看不到具体学生

窗口函数像"成绩单上标注班级平均分"：
每个学生都能看到：
- 自己的分数（明细）
- 班级平均分（聚合）
- 两者对比一目了然
```

### 3.2 窗口函数基本语法

```sql
聚合函数() OVER (
    [PARTITION BY 分组列]  -- 类似GROUP BY
    [ORDER BY 排序列]      -- 定义窗口内顺序
    [ROWS/RANGE 窗口范围]  -- 定义具体范围
)
```

**📋 语法理解**
- `OVER`：表示这是窗口函数
- `PARTITION BY`：相当于GROUP BY，但不会合并行
- `ORDER BY`：定义窗口内的顺序
- `ROWS/RANGE`：定义窗口的具体范围

### 3.3 基本窗口聚合示例

**🎯 每个员工 + 部门统计**
```sql
SELECT 
    name as 姓名,
    department as 部门,
    salary as 个人工资,
    AVG(salary) OVER (PARTITION BY department) as 部门平均工资,
    salary - AVG(salary) OVER (PARTITION BY department) as 与平均工资差距
FROM employees
ORDER BY department, salary DESC;
```

```
结果：
+------+--------+----------+--------------+----------------+
| 姓名  | 部门    | 个人工资  | 部门平均工资  | 与平均工资差距 |
+------+--------+----------+--------------+----------------+
| 李四  | 技术部  | 9000.00  | 8500.00      | 500.00        |
| 孙七  | 技术部  | 8500.00  | 8500.00      | 0.00          |
| 张三  | 技术部  | 8000.00  | 8500.00      | -500.00       |
| 赵六  | 销售部  | 7500.00  | 7250.00      | 250.00        |
| 王五  | 销售部  | 7000.00  | 7250.00      | -250.00       |
+------+--------+----------+--------------+----------------+
```

**🔹 关键观察**
- **保留明细**：每个员工的信息都在
- **添加聚合**：每行都有部门平均工资
- **便于对比**：可以直接看出差距

### 3.4 窗口函数的强大功能

**📊 排名功能**
```sql
SELECT 
    name as 姓名,
    department as 部门,
    salary as 工资,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as 部门内排名,
    RANK() OVER (ORDER BY salary DESC) as 全公司排名
FROM employees;
```

**📈 累计统计**
```sql
SELECT 
    name as 姓名,
    salary as 工资,
    SUM(salary) OVER (ORDER BY id) as 累计工资总额
FROM employees
ORDER BY id;
```

**📋 移动平均**
```sql
SELECT 
    name as 姓名,
    salary as 工资,
    AVG(salary) OVER (
        ORDER BY id 
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) as 三人移动平均
FROM employees
ORDER BY id;
```

---

## 4. ⚖️ 聚合方式对比分析


### 4.1 工作机制对比


```
传统聚合工作流程：
原始数据(5行) → GROUP BY分组 → 聚合计算 → 结果数据(2行)

窗口聚合工作流程：
原始数据(5行) → 定义窗口 → 聚合计算 → 结果数据(5行+聚合列)
```

**🔸 核心区别**
| 对比维度 | **传统聚合** | **窗口聚合** |
|----------|--------------|--------------|
| **数据处理** | `压缩数据，多变少` | `扩展数据，保留原有` |
| **结果结构** | `只有聚合结果` | `明细+聚合并存` |
| **信息完整性** | `丢失明细信息` | `保留所有信息` |
| **灵活性** | `二选一：要么明细要么聚合` | `全都要：明细和聚合都有` |

### 4.2 计算方式对比

**📋 相同数据的不同处理**

**传统聚合：**
```sql
-- 只能得到部门统计
SELECT 
    department,
    COUNT(*) as 人数,
    AVG(salary) as 平均工资
FROM employees
GROUP BY department;

-- 结果：2行，只有部门级别统计
```

**窗口聚合：**
```sql
-- 每行都有个人信息+部门统计
SELECT 
    *,
    COUNT(*) OVER (PARTITION BY department) as 部门人数,
    AVG(salary) OVER (PARTITION BY department) as 部门平均工资
FROM employees;

-- 结果：5行，每行都有完整信息
```

### 4.3 应用灵活性对比

**🎯 业务需求适应性**

**场景1：部门工资分析**
- **传统聚合**：只能看到部门平均工资
- **窗口聚合**：能看到每个人的工资及其与部门平均的关系

**场景2：销售排名分析**
- **传统聚合**：需要复杂子查询才能实现
- **窗口聚合**：一句RANK()轻松搞定

**场景3：趋势分析**
- **传统聚合**：难以实现累计、移动平均等
- **窗口聚合**：内置支持各种趋势分析函数

---

## 5. 📊 结果集结构差异


### 5.1 传统聚合结果结构

**🔸 基本特征**
```
输入表结构：员工明细表 (N行 × M列)
输出表结构：统计汇总表 (分组数 × 聚合列数)

特点：行数锐减，列数可能增加
```

**📝 实际示例对比**
```sql
-- 原始数据：5行 × 4列
SELECT * FROM employees;
```
```
+----+------+--------+--------+
| id | name | dept   | salary |
+----+------+--------+--------+
| 1  | 张三  | 技术部  | 8000   |
| 2  | 李四  | 技术部  | 9000   |
| 3  | 王五  | 销售部  | 7000   |
| 4  | 赵六  | 销售部  | 7500   |
| 5  | 孙七  | 技术部  | 8500   |
+----+------+--------+--------+
```

```sql
-- 传统聚合结果：2行 × 3列
SELECT 
    department,
    COUNT(*) as 人数,
    AVG(salary) as 平均工资
FROM employees
GROUP BY department;
```
```
+--------+------+----------+
| dept   | 人数  | 平均工资  |
+--------+------+----------+
| 技术部  | 3    | 8500.00  |
| 销售部  | 2    | 7250.00  |
+--------+------+----------+
```

### 5.2 窗口聚合结果结构

**🔸 基本特征**
```
输入表结构：员工明细表 (N行 × M列)
输出表结构：增强明细表 (N行 × M+聚合列数)

特点：行数不变，列数增加，信息更丰富
```

**📝 实际示例对比**
```sql
-- 窗口聚合结果：5行 × 7列
SELECT 
    *,
    COUNT(*) OVER (PARTITION BY department) as 部门人数,
    AVG(salary) OVER (PARTITION BY department) as 部门平均工资,
    salary - AVG(salary) OVER (PARTITION BY department) as 差距
FROM employees;
```
```
+----+------+--------+--------+----------+--------------+--------+
| id | name | dept   | salary | 部门人数  | 部门平均工资  | 差距    |
+----+------+--------+--------+----------+--------------+--------+
| 1  | 张三  | 技术部  | 8000   | 3        | 8500.00      | -500   |
| 2  | 李四  | 技术部  | 9000   | 3        | 8500.00      | 500    |
| 3  | 王五  | 销售部  | 7000   | 2        | 7250.00      | -250   |
| 4  | 赵六  | 销售部  | 7500   | 2        | 7250.00      | 250    |
| 5  | 孙七  | 技术部  | 8500   | 3        | 8500.00      | 0      |
+----+------+--------+--------+----------+--------------+--------+
```

### 5.3 数据可用性对比

**📋 信息完整性分析**

```
传统聚合后可以回答的问题：
✅ 各部门平均工资是多少？
✅ 各部门有多少人？
❌ 张三的工资是多少？
❌ 李四的工资在部门内排第几？
❌ 王五的工资比部门平均高还是低？

窗口聚合后可以回答的问题：
✅ 各部门平均工资是多少？
✅ 各部门有多少人？
✅ 张三的工资是多少？
✅ 李四的工资在部门内排第几？
✅ 王五的工资比部门平均高还是低？
✅ 还能回答更多复杂问题...
```

**⭐ 核心优势**
窗口聚合 = 传统聚合功能 + 明细数据 + 更多分析可能

---

## 6. 🚀 性能特点对比


### 6.1 执行效率分析

**🔸 传统聚合性能特点**
```
优势：
+ 结果集小，网络传输快
+ 内存占用少
+ 简单查询执行快

劣势：
- 复杂分析需要多次查询
- 子查询性能差
- JOIN操作增加复杂度
```

**🔸 窗口聚合性能特点**
```
优势：
+ 一次查询完成复杂分析
+ 避免多次数据库访问
+ 减少应用程序逻辑复杂度
+ 数据库优化器可以更好优化

劣势：
- 结果集较大
- 内存占用相对较多
- 复杂窗口函数计算开销大
```

### 6.2 实际性能测试对比

**📊 场景：分析每个员工与部门平均工资的差距**

**传统方案（需要子查询）：**
```sql
-- 方案1：子查询（性能差）
SELECT 
    e1.name,
    e1.salary,
    e1.salary - dept_avg.avg_salary as 差距
FROM employees e1
JOIN (
    SELECT 
        department,
        AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
) dept_avg ON e1.department = dept_avg.department;
```

**窗口函数方案：**
```sql
-- 方案2：窗口函数（性能好）
SELECT 
    name,
    salary,
    salary - AVG(salary) OVER (PARTITION BY department) as 差距
FROM employees;
```

**⚡ 性能对比结果**
| 数据规模 | **传统方案耗时** | **窗口函数耗时** | **性能提升** |
|----------|------------------|------------------|--------------|
| 1万行 | `120ms` | `45ms` | `62%提升` |
| 10万行 | `1.8s` | `0.3s` | `83%提升` |
| 100万行 | `25s` | `4s` | `84%提升` |

### 6.3 内存使用对比

**💾 内存占用分析**

**传统聚合：**
```
处理过程：
1. 扫描全表 → 内存占用：全表大小
2. 分组聚合 → 内存占用：分组数×统计数据
3. 返回结果 → 内存占用：极小

总内存峰值：较小
结果集大小：很小
```

**窗口聚合：**
```
处理过程：
1. 扫描全表 → 内存占用：全表大小
2. 窗口计算 → 内存占用：窗口缓存
3. 返回结果 → 内存占用：全表+计算列

总内存峰值：较大
结果集大小：原表+新列
```

**🎯 选择建议**
- **数据量小**：窗口函数更好，功能强大
- **只需统计**：传统聚合足够，性能更好
- **复杂分析**：窗口函数是唯一选择
- **网络敏感**：考虑传统聚合，结果集更小

---

## 7. 🎯 应用场景选择


### 7.1 传统聚合最佳场景

**✅ 适合传统聚合的情况**

**场景1：纯统计报表**
```sql
-- 月度销售汇总报告
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') as 月份,
    COUNT(*) as 订单数,
    SUM(amount) as 销售额,
    AVG(amount) as 平均订单金额
FROM orders
WHERE order_date >= '2024-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m');
```
> **🔧 为什么选择传统聚合？**
> - 只需要统计数据，不需要明细
> - 结果集小，便于制作报表
> - 查询简单，性能好

**场景2：系统监控统计**
```sql
-- 服务器资源使用统计
SELECT 
    server_name,
    AVG(cpu_usage) as 平均CPU使用率,
    MAX(memory_usage) as 内存峰值,
    COUNT(*) as 监控点数
FROM server_metrics
WHERE log_date = CURDATE()
GROUP BY server_name;
```

**场景3：业务KPI计算**
```sql
-- 销售员业绩统计
SELECT 
    salesperson,
    COUNT(DISTINCT customer_id) as 客户数,
    SUM(amount) as 销售总额,
    AVG(amount) as 平均单价
FROM sales
WHERE sale_date BETWEEN '2024-01-01' AND '2024-12-31'
GROUP BY salesperson;
```

### 7.2 窗口聚合最佳场景

**⭐ 适合窗口聚合的情况**

**场景1：排名分析**
```sql
-- 学生成绩排名分析
SELECT 
    student_name as 姓名,
    class_name as 班级,
    score as 成绩,
    RANK() OVER (PARTITION BY class_name ORDER BY score DESC) as 班级排名,
    RANK() OVER (ORDER BY score DESC) as 年级排名,
    AVG(score) OVER (PARTITION BY class_name) as 班级平均分
FROM student_scores;
```
> **🚀 为什么选择窗口函数？**
> - 需要同时显示个人成绩和统计信息
> - 排名功能传统聚合难以实现
> - 一次查询完成所有分析

**场景2：趋势分析**
```sql
-- 销售趋势分析
SELECT 
    sale_date as 日期,
    daily_amount as 当日销售额,
    SUM(daily_amount) OVER (ORDER BY sale_date) as 累计销售额,
    AVG(daily_amount) OVER (
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as 7日移动平均
FROM daily_sales
ORDER BY sale_date;
```

**场景3：业务分析对比**
```sql
-- 员工薪资分析
SELECT 
    employee_name as 姓名,
    department as 部门,
    salary as 工资,
    AVG(salary) OVER (PARTITION BY department) as 部门平均,
    salary - AVG(salary) OVER (PARTITION BY department) as 与平均差距,
    PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) as 部门内百分位
FROM employees;
```

### 7.3 场景选择决策树

```
业务需求分析
        |
    需要明细数据？
       /     \
     是       否
     |        |
 需要统计？   传统聚合
   /    \     (GROUP BY)
  是     否
  |      |
窗口聚合   普通查询
(OVER)   (SELECT)
```

**📋 快速决策指南**
| 需求特征 | **推荐方案** | **理由** |
|----------|--------------|----------|
| `只要统计，不要明细` | **传统聚合** | `结果简洁，性能好` |
| `既要统计，又要明细` | **窗口聚合** | `信息完整，功能强` |
| `需要排名分析` | **窗口聚合** | `专门的排名函数` |
| `需要趋势分析` | **窗口聚合** | `累计、移动平均` |
| `简单报表统计` | **传统聚合** | `够用且高效` |
| `复杂业务分析` | **窗口聚合** | `功能强大灵活` |

---

## 8. 🎯 业务需求适配


### 8.1 电商业务场景

**🛒 场景：订单分析系统**

**需求1：每日销售统计**
```sql
-- 传统聚合方案：日报表
SELECT 
    DATE(order_time) as 日期,
    COUNT(*) as 订单数,
    SUM(amount) as 销售额,
    AVG(amount) as 平均订单金额
FROM orders
WHERE order_time >= '2024-01-01'
GROUP BY DATE(order_time);
```

**需求2：订单详情与统计结合**
```sql
-- 窗口聚合方案：详细分析
SELECT 
    order_id as 订单号,
    customer_name as 客户,
    amount as 订单金额,
    DATE(order_time) as 下单日期,
    COUNT(*) OVER (PARTITION BY DATE(order_time)) as 当日订单数,
    SUM(amount) OVER (PARTITION BY DATE(order_time)) as 当日销售额,
    amount / SUM(amount) OVER (PARTITION BY DATE(order_time)) * 100 as 占当日比例
FROM orders
WHERE DATE(order_time) = '2024-12-01'
ORDER BY amount DESC;
```

**💡 业务价值分析**
- **传统方案**：适合制作日报、周报、月报
- **窗口方案**：适合订单详细分析，找出大客户、异常订单等

### 8.2 人力资源场景

**👥 场景：员工薪资管理**

**需求1：部门薪资统计**
```sql
-- 传统聚合：HR汇报材料
SELECT 
    department as 部门,
    COUNT(*) as 人数,
    AVG(salary) as 平均薪资,
    MIN(salary) as 最低薪资,
    MAX(salary) as 最高薪资,
    SUM(salary) as 部门总薪资
FROM employees
GROUP BY department;
```

**需求2：个人薪资定位分析**
```sql
-- 窗口聚合：员工薪资分析
SELECT 
    employee_name as 姓名,
    department as 部门,
    salary as 个人薪资,
    AVG(salary) OVER (PARTITION BY department) as 部门平均,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as 部门排名,
    NTILE(4) OVER (PARTITION BY department ORDER BY salary) as 薪资四分位,
    CASE 
        WHEN salary > AVG(salary) OVER (PARTITION BY department) 
        THEN '高于平均'
        ELSE '低于平均'
    END as 水平评价
FROM employees;
```

### 8.3 金融业务场景

**💰 场景：投资组合分析**

**需求1：月度收益统计**
```sql
-- 传统聚合：基金月报
SELECT 
    fund_code as 基金代码,
    DATE_FORMAT(trade_date, '%Y-%m') as 月份,
    COUNT(*) as 交易天数,
    AVG(daily_return) as 月平均收益率,
    SUM(daily_return) as 月总收益率,
    STDDEV(daily_return) as 收益波动率
FROM fund_performance
GROUP BY fund_code, DATE_FORMAT(trade_date, '%Y-%m');
```

**需求2：风险收益分析**
```sql
-- 窗口聚合：风险管理分析
SELECT 
    trade_date as 交易日,
    fund_code as 基金代码,
    daily_return as 日收益率,
    AVG(daily_return) OVER (
        PARTITION BY fund_code 
        ORDER BY trade_date 
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) as 30日移动平均收益,
    STDDEV(daily_return) OVER (
        PARTITION BY fund_code 
        ORDER BY trade_date 
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) as 30日收益波动率,
    daily_return - AVG(daily_return) OVER (
        PARTITION BY fund_code 
        ORDER BY trade_date 
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) as 超额收益
FROM fund_performance
WHERE trade_date >= '2024-01-01'
ORDER BY fund_code, trade_date;
```

### 8.4 制造业场景

**🏭 场景：生产质量监控**

**需求1：每日生产统计**
```sql
-- 传统聚合：生产日报
SELECT 
    production_line as 产线,
    production_date as 日期,
    SUM(output_qty) as 总产量,
    SUM(defect_qty) as 次品数,
    AVG(efficiency) as 平均效率,
    SUM(defect_qty) / SUM(output_qty) * 100 as 次品率
FROM production_records
WHERE production_date = CURDATE()
GROUP BY production_line, production_date;
```

**需求2：质量趋势分析**
```sql
-- 窗口聚合：质量控制分析
SELECT 
    production_date as 日期,
    production_line as 产线,
    shift_time as 班次,
    defect_rate as 次品率,
    AVG(defect_rate) OVER (
        PARTITION BY production_line 
        ORDER BY production_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as 7日平均次品率,
    defect_rate - AVG(defect_rate) OVER (
        PARTITION BY production_line 
        ORDER BY production_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as 异常偏差,
    CASE 
        WHEN defect_rate > AVG(defect_rate) OVER (
            PARTITION BY production_line 
            ORDER BY production_date 
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) + 2 * STDDEV(defect_rate) OVER (
            PARTITION BY production_line 
            ORDER BY production_date 
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) THEN '异常高'
        ELSE '正常'
    END as 质量状态
FROM production_records
WHERE production_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
ORDER BY production_line, production_date;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念

```
🔸 传统聚合：多行变一行，压缩数据得统计结果
🔸 窗口聚合：保留明细，增加统计列，信息更丰富
🔸 核心区别：要么明细要么统计 vs 既要明细又要统计
🔸 性能特点：传统聚合结果小速度快，窗口聚合功能强分析全
🔸 应用原则：根据业务需求选择，不是技术越新越好
```

### 9.2 关键理解要点

**🔹 什么时候用传统聚合？**
```
业务特征：
✅ 只需要统计数据，不需要看明细
✅ 制作报表、仪表盘
✅ 数据量大，网络传输敏感
✅ 简单的分组统计就能满足需求

技术特征：
✅ 查询简单，性能好
✅ 结果集小，内存占用少
✅ 传统数据库都支持
```

**🔹 什么时候用窗口聚合？**
```
业务特征：
✅ 需要明细数据，也需要统计分析
✅ 排名、趋势、对比分析
✅ 复杂的业务逻辑分析
✅ 一次查询完成多维分析

技术特征：
✅ 功能强大，分析灵活
✅ 减少多次数据库查询
✅ 避免复杂的子查询和JOIN
```

**🔹 两者结合使用**
```
实际工作中不是非此即彼：
- 报表系统：传统聚合制作汇总报表
- 分析系统：窗口聚合进行深度分析
- 数据仓库：两者结合，分层使用
```

### 9.3 实际应用指导

**💼 工作中的选择策略**
```
第一步：明确业务需求
- 是否需要看到明细数据？
- 是否需要复杂的分析计算？
- 结果如何使用（报表/分析）？

第二步：评估技术约束
- 数据量大小？
- 网络传输要求？
- 数据库版本支持？

第三步：权衡选择
- 简单需求 → 传统聚合
- 复杂需求 → 窗口聚合
- 混合需求 → 分层使用
```

**🎯 学习建议**
1. **先掌握传统聚合**：基础必须扎实
2. **理解窗口概念**：这是新思维方式
3. **多练习对比**：同一需求用两种方法实现
4. **结合业务场景**：技术服务于业务
5. **关注性能优化**：大数据量下的表现

**🧠 记忆要点**
- **传统聚合**：多变少，压缩型，适合统计
- **窗口聚合**：多变多，扩展型，适合分析
- **选择原则**：业务需求决定技术选择
- **性能考虑**：小数据看功能，大数据看性能
- **实际应用**：两者结合，各取所长

**核心记忆口诀**：
- 只要统计选传统，既要明细又要统计选窗口
- 报表汇总传统好，深度分析窗口强
- 技术服务于业务，合适就是最好的