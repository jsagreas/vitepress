---
title: 5、条件聚合技巧
---
## 📚 目录

1. [条件聚合基础概念](#1-条件聚合基础概念)
2. [CASE WHEN聚合详解](#2-case-when聚合详解)
3. [IF条件聚合技术](#3-if条件聚合技术)
4. [分组条件聚合实战](#4-分组条件聚合实战)
5. [多条件统计策略](#5-多条件统计策略)
6. [聚合过滤技术应用](#6-聚合过滤技术应用)
7. [聚合表达式优化](#7-聚合表达式优化)
8. [聚合函数嵌套规则](#8-聚合函数嵌套规则)
9. [子查询聚合策略](#9-子查询聚合策略)
10. [条件聚合设计模式](#10-条件聚合设计模式)
11. [复杂统计聚合实现](#11-复杂统计聚合实现)
12. [性能优化技巧](#12-性能优化技巧)
13. [核心要点总结](#13-核心要点总结)

---

## 1. 📖 条件聚合基础概念


### 1.1 什么是条件聚合


**通俗理解**：条件聚合就像是"有选择性地统计数据"，不是对所有数据进行统计，而是只统计符合特定条件的数据。

```
生活类比：
统计班级成绩时
- 普通聚合：统计所有学生的平均分
- 条件聚合：只统计数学成绩>90分的学生人数
              只统计文科生的平均分
              按性别分别统计各科平均分
```

**🔸 核心概念**
```sql
-- 基本思路：在聚合函数中加入条件判断
SELECT 
    聚合函数(CASE WHEN 条件 THEN 值 END) AS 条件统计结果
FROM 表名;
```

### 1.2 条件聚合的作用


**📊 主要用途**
- **数据透视**：将行数据转换为列数据进行统计
- **分类统计**：按不同条件对数据进行分类汇总
- **复合分析**：在一次查询中完成多种统计需求
- **报表生成**：生成复杂的业务报表

**💡 实际应用场景**
```
电商场景：
• 统计不同状态订单的数量和金额
• 按月份统计销售情况
• 分析不同地区的销售表现

企业管理：
• 员工绩效分析
• 部门预算统计
• 项目进度追踪
```

---

## 2. 🔧 CASE WHEN聚合详解


### 2.1 CASE WHEN语法基础


**🔸 标准语法格式**
```sql
CASE 
    WHEN 条件1 THEN 结果1
    WHEN 条件2 THEN 结果2
    ELSE 默认结果
END
```

### 2.2 基础条件聚合示例


**📝 测试数据准备**
```sql
CREATE TABLE orders (
    id INT PRIMARY KEY,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    region VARCHAR(50)
);

INSERT INTO orders VALUES
(1, 'pending', 500.00, 'North'),
(2, 'completed', 750.00, 'South'),
(3, 'cancelled', 200.00, 'North'),
(4, 'completed', 1000.00, 'East');
```

**🎯 按状态统计订单**
```sql
SELECT 
    COUNT(CASE WHEN status = 'pending' THEN 1 END) AS 待处理订单数,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 已完成订单数,
    COUNT(CASE WHEN status = 'cancelled' THEN 1 END) AS 已取消订单数,
    COUNT(*) AS 总订单数
FROM orders;
```

**💰 按状态统计金额**
```sql
SELECT 
    SUM(CASE WHEN status = 'completed' THEN amount END) AS 已完成订单总额,
    SUM(CASE WHEN status = 'pending' THEN amount END) AS 待处理订单总额,
    AVG(CASE WHEN status = 'completed' THEN amount END) AS 已完成订单平均额
FROM orders;
```

**🔍 理解要点**
```
关键理解：
1. CASE WHEN返回NULL时，COUNT不会计数
2. CASE WHEN返回任何非NULL值时，COUNT都会计数
3. 通常使用THEN 1，简单明了
4. SUM配合CASE WHEN可以进行条件求和
```

### 2.3 多维度条件聚合


**📊 区间统计**
```sql
-- 按金额区间统计订单分布
SELECT 
    COUNT(CASE WHEN amount < 300 THEN 1 END) AS 小额订单,
    COUNT(CASE WHEN amount BETWEEN 300 AND 700 THEN 1 END) AS 中额订单,
    COUNT(CASE WHEN amount > 700 THEN 1 END) AS 大额订单
FROM orders;
```

---

## 3. ⚡ IF条件聚合技术


### 3.1 IF函数基础语法


**🔸 IF函数格式**
```sql
IF(条件表达式, 真值, 假值)

-- 等价的CASE WHEN写法
CASE WHEN 条件表达式 THEN 真值 ELSE 假值 END
```

**💡 IF vs CASE WHEN对比**

| 方面 | IF函数 | CASE WHEN |
|------|--------|-----------|
| **语法复杂度** | 简单，适合二元条件 | 复杂，适合多条件判断 |
| **可读性** | 条件简单时更清晰 | 复杂逻辑时更清晰 |
| **标准化** | MySQL特有 | SQL标准，通用性好 |

### 3.2 IF条件聚合应用


**🎯 简单二元统计**
```sql
SELECT 
    COUNT(IF(status = 'completed', 1, NULL)) AS 已完成订单,
    COUNT(IF(status != 'completed', 1, NULL)) AS 未完成订单,
    SUM(IF(status = 'completed', amount, 0)) AS 已完成金额
FROM orders;
```

**📊 IF与聚合函数结合**
```sql
SELECT 
    region,
    COUNT(*) AS 总订单数,
    COUNT(IF(status = 'completed', 1, NULL)) AS 完成订单数,
    ROUND(AVG(IF(status = 'completed', amount, NULL)), 2) AS 完成订单平均金额
FROM orders
GROUP BY region;
```

**🔍 选择建议**
```
使用IF的场景：
✅ 简单的二元判断
✅ 条件表达式较短
✅ 只有MySQL环境

使用CASE WHEN的场景：
✅ 多条件复杂判断  
✅ 需要跨数据库兼容性
✅ 条件逻辑较复杂
```

---

## 4. 📊 分组条件聚合实战


### 4.1 单字段分组条件聚合


**🎯 基础分组聚合**
```sql
SELECT 
    region AS 地区,
    COUNT(*) AS 总订单数,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 已完成,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) AS 处理中,
    ROUND(COUNT(CASE WHEN status = 'completed' THEN 1 END) * 100.0 / COUNT(*), 2) AS 完成率
FROM orders
GROUP BY region;
```

### 4.2 多字段分组条件聚合


**📅 按地区和时间双重分组**
```sql
SELECT 
    region AS 地区,
    DATE_FORMAT(order_date, '%Y-%m') AS 月份,
    COUNT(*) AS 订单总数,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 完成数,
    SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) AS 完成金额
FROM orders
GROUP BY region, DATE_FORMAT(order_date, '%Y-%m');
```

### 4.3 分组过滤结合条件聚合


**📊 使用HAVING进行聚合过滤**
```sql
SELECT 
    region,
    COUNT(*) AS 有效订单数,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 已完成数,
    ROUND(COUNT(CASE WHEN status = 'completed' THEN 1 END) * 100.0 / COUNT(*), 2) AS 完成率
FROM orders
WHERE status != 'cancelled'  -- 过滤掉取消订单
GROUP BY region
HAVING COUNT(*) > 1  -- 只显示订单数>1的地区
ORDER BY 完成率 DESC;
```

---

## 5. 🎯 多条件统计策略


### 5.1 复合条件统计


**📊 多维度交叉统计**
```sql
SELECT 
    region AS 地区,
    -- 按金额和状态交叉统计
    COUNT(CASE WHEN status = 'completed' AND amount > 500 THEN 1 END) AS 完成高价订单,
    COUNT(CASE WHEN status = 'pending' AND amount > 500 THEN 1 END) AS 待处理高价订单,
    -- 计算高价订单完成率
    ROUND(
        COUNT(CASE WHEN status = 'completed' AND amount > 500 THEN 1 END) * 100.0 / 
        NULLIF(COUNT(CASE WHEN amount > 500 THEN 1 END), 0), 2
    ) AS 高价订单完成率
FROM orders
GROUP BY region;
```

### 5.2 嵌套条件统计


**🔥 复杂业务逻辑统计**
```sql
SELECT 
    region AS 地区,
    -- 高价值订单（单笔>500且已完成）
    COUNT(CASE WHEN status = 'completed' AND amount > 500 THEN 1 END) AS 高价值完成订单,
    -- VIP客户订单（完成订单>800或特定地区>500）
    COUNT(CASE 
        WHEN (status = 'completed' AND amount > 800) 
             OR (region = 'North' AND amount > 500 AND status = 'completed')
        THEN 1 
    END) AS VIP客户订单,
    -- 计算加权订单价值
    SUM(CASE 
        WHEN status = 'completed' AND amount > 800 THEN amount * 1.2
        WHEN status = 'completed' AND amount > 500 THEN amount * 1.1  
        WHEN status = 'completed' THEN amount
        ELSE 0
    END) AS 加权订单价值
FROM orders
GROUP BY region;
```

---

## 6. 🔍 聚合过滤技术应用


### 6.1 HAVING子句条件过滤


**🎯 聚合后过滤**
```sql
-- 筛选完成率>50%且订单总金额>1000的地区
SELECT 
    region AS 地区,
    COUNT(*) AS 订单总数,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 完成订单数,
    SUM(amount) AS 订单总金额,
    ROUND(COUNT(CASE WHEN status = 'completed' THEN 1 END) * 100.0 / COUNT(*), 2) AS 完成率
FROM orders
GROUP BY region
HAVING 
    COUNT(CASE WHEN status = 'completed' THEN 1 END) * 100.0 / COUNT(*) > 50
    AND SUM(amount) > 1000;
```

### 6.2 WHERE与HAVING结合使用


**🔥 多层过滤策略**
```sql
SELECT 
    region AS 地区,
    COUNT(*) AS 有效订单数,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 完成订单数,
    SUM(amount) AS 总金额,
    ROUND(COUNT(CASE WHEN status = 'completed' THEN 1 END) * 100.0 / COUNT(*), 2) AS 完成率
FROM orders
WHERE order_date >= '2024-01-01'  -- 先过滤：只要2024年的订单
  AND status != 'cancelled'       -- 先过滤：排除取消订单
GROUP BY region
HAVING COUNT(*) >= 2               -- 后过滤：有效订单数>=2
   AND SUM(amount) >= 800;        -- 后过滤：总金额>=800
```

---

## 7. 🚀 聚合表达式优化


### 7.1 表达式重写优化


**🔸 避免重复计算**

**❌ 低效写法：重复计算相同表达式**
```sql
-- 问题：多次计算相同的条件
SELECT 
    region,
    COUNT(CASE WHEN amount > 500 AND status = 'completed' THEN 1 END) AS 高价值完成,
    SUM(CASE WHEN amount > 500 AND status = 'completed' THEN amount END) AS 高价值金额,
    AVG(CASE WHEN amount > 500 AND status = 'completed' THEN amount END) AS 高价值均价
FROM orders GROUP BY region;
```

**✅ 高效写法：使用子查询预过滤**
```sql
-- 优化：先过滤再聚合
SELECT 
    region,
    COUNT(*) AS 高价值完成订单,
    SUM(amount) AS 高价值完成金额,
    ROUND(AVG(amount), 2) AS 高价值完成均价
FROM orders
WHERE amount > 500 AND status = 'completed'  -- 预过滤
GROUP BY region;
```

### 7.2 索引优化聚合查询


**📊 创建合适的索引**
```sql
-- 为聚合查询创建复合索引
CREATE INDEX idx_region_status_amount ON orders(region, status, amount);
CREATE INDEX idx_status_amount ON orders(status, amount);
```

### 7.3 聚合函数选择优化


**💡 性能优化建议**

| 函数类型 | 性能 | 使用场景 |
|----------|------|----------|
| `COUNT(*)` | 最快 | 计算总行数 |
| `COUNT(字段)` | 较快 | 计算非NULL行数 |
| `COUNT(CASE WHEN...)` | 中等 | 条件计数 |
| `SUM(CASE WHEN...)` | 中等 | 条件求和 |

**🎯 优化策略**
```sql
-- ✅ 推荐：在WHERE中过滤
SELECT region, COUNT(*) as 完成订单数
FROM orders
WHERE status = 'completed'  -- 过滤比聚合内判断更快
GROUP BY region;

-- ❌ 不推荐：在聚合函数内部过滤
SELECT region, COUNT(CASE WHEN status = 'completed' THEN 1 END)
FROM orders GROUP BY region;
```

---

## 8. 🔧 聚合函数嵌套规则


### 8.1 MySQL聚合函数嵌套限制


**🚫 不允许的嵌套**
```sql
-- ❌ 错误：聚合函数不能直接嵌套
SELECT COUNT(SUM(amount)) FROM orders GROUP BY region;
-- Error: Invalid use of group function

-- ❌ 错误：聚合函数不能在WHERE子句中使用
SELECT * FROM orders WHERE COUNT(*) > 5;
-- Error: Invalid use of group function
```

**✅ 正确的替代方案**
```sql
-- 方案1：使用子查询
SELECT COUNT(*) as 地区数量
FROM (
    SELECT region, SUM(amount) as region_total
    FROM orders GROUP BY region
) as region_summary;

-- 方案2：使用窗口函数
SELECT region, SUM(amount) as region_total,
       COUNT(*) OVER() as 总地区数
FROM orders GROUP BY region;
```

### 8.2 聚合结果的二次聚合


**🔥 分步聚合策略**
```sql
-- 使用CTE实现多层聚合
WITH region_summary AS (
    SELECT 
        region,
        COUNT(*) as order_count,
        SUM(amount) as total_amount,
        AVG(amount) as avg_amount
    FROM orders GROUP BY region
)
SELECT 
    COUNT(*) as 地区总数,
    SUM(order_count) as 订单总数,
    SUM(total_amount) as 金额总计,
    ROUND(AVG(avg_amount), 2) as 各地区平均金额的平均值
FROM region_summary;
```

---

## 9. 🎯 子查询聚合策略


### 9.1 标量子查询在聚合中的应用


**📊 使用标量子查询进行比较**
```sql
-- 查找高于平均订单金额的订单统计
SELECT 
    region,
    COUNT(*) as 订单数,
    COUNT(CASE WHEN amount > (SELECT AVG(amount) FROM orders) THEN 1 END) as 高于平均金额订单数,
    ROUND((SELECT AVG(amount) FROM orders), 2) as 全局平均金额
FROM orders
GROUP BY region;
```

### 9.2 子查询聚合性能优化


**⚡ 使用变量优化重复子查询**
```sql
-- 优化方案：使用变量避免重复计算
SET @avg_amount = (SELECT AVG(amount) FROM orders);

SELECT 
    region,
    COUNT(CASE WHEN amount > @avg_amount THEN 1 END) as 高于平均订单数,
    @avg_amount as 平均金额
FROM orders
GROUP BY region;
```

---

## 10. 🏗️ 条件聚合设计模式


### 10.1 透视表模式


**📊 行转列经典模式**
```sql
-- 将订单状态从行转为列
SELECT 
    region as 地区,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as 待处理,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as 已完成,
    COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as 已取消,
    SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) as 已完成金额,
    COUNT(*) as 总订单数
FROM orders
GROUP BY region;
```

### 10.2 分桶统计模式


**📦 数值分桶统计**
```sql
-- 按金额范围分桶统计
SELECT 
    region as 地区,
    COUNT(CASE WHEN amount < 400 THEN 1 END) as 低价订单,
    COUNT(CASE WHEN amount BETWEEN 400 AND 800 THEN 1 END) as 中价订单,
    COUNT(CASE WHEN amount > 800 THEN 1 END) as 高价订单,
    ROUND(AVG(CASE WHEN amount < 400 THEN amount END), 2) as 低价订单均额
FROM orders
GROUP BY region;
```

---

## 11. 🎯 复杂统计聚合实现


### 11.1 业务指标聚合


**📊 综合业务分析**
```sql
-- 多维度业务指标统计
SELECT 
    region AS 地区,
    COUNT(*) AS 总订单数,
    
    -- 状态分析
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 完成订单数,
    ROUND(COUNT(CASE WHEN status = 'completed' THEN 1 END) * 100.0 / COUNT(*), 2) AS 完成率,
    
    -- 金额分析
    SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) AS 完成订单金额,
    ROUND(AVG(CASE WHEN status = 'completed' THEN amount END), 2) AS 完成订单均价,
    
    -- 客户价值分析
    COUNT(CASE WHEN amount > 600 THEN 1 END) AS 高价值订单数,
    ROUND(COUNT(CASE WHEN amount > 600 THEN 1 END) * 100.0 / COUNT(*), 2) AS 高价值订单占比
FROM orders
GROUP BY region
HAVING COUNT(*) > 1  -- 过滤订单数过少的地区
ORDER BY 完成订单金额 DESC;
```

### 11.2 同比环比分析


**📅 时间对比统计**
```sql
-- 月度同比分析（需要多年数据）
SELECT 
    region,
    DATE_FORMAT(order_date, '%m') AS 月份,
    
    -- 当年统计
    COUNT(CASE WHEN YEAR(order_date) = 2024 THEN 1 END) AS 当年订单数,
    SUM(CASE WHEN YEAR(order_date) = 2024 THEN amount ELSE 0 END) AS 当年订单金额,
    
    -- 去年统计  
    COUNT(CASE WHEN YEAR(order_date) = 2023 THEN 1 END) AS 去年同期订单数,
    SUM(CASE WHEN YEAR(order_date) = 2023 THEN amount ELSE 0 END) AS 去年同期订单金额,
    
    -- 同比增长率
    ROUND(
        (COUNT(CASE WHEN YEAR(order_date) = 2024 THEN 1 END) - 
         COUNT(CASE WHEN YEAR(order_date) = 2023 THEN 1 END)) * 100.0 / 
        NULLIF(COUNT(CASE WHEN YEAR(order_date) = 2023 THEN 1 END), 0), 2
    ) AS 订单数同比增长率
FROM orders
GROUP BY region, DATE_FORMAT(order_date, '%m');
```

---

## 12. 📈 性能优化技巧


### 12.1 查询优化策略


**⚡ 核心优化原则**

```
优化优先级：
1. WHERE过滤 > 聚合函数内过滤
2. 预计算 > 重复计算
3. 索引优化 > 暴力扫描
4. 适当的数据类型 > 过大的数据类型
```

**🎯 实际优化示例**
```sql
-- ✅ 优化后：先过滤再聚合
SELECT 
    region,
    COUNT(*) AS 高价值订单数,
    AVG(amount) AS 平均金额
FROM orders
WHERE amount > 500 AND status = 'completed'
GROUP BY region;

-- ❌ 优化前：在聚合中过滤  
SELECT 
    region,
    COUNT(CASE WHEN amount > 500 AND status = 'completed' THEN 1 END),
    AVG(CASE WHEN amount > 500 AND status = 'completed' THEN amount END)
FROM orders GROUP BY region;
```

### 12.2 索引设计建议


**📊 聚合查询索引原则**
```sql
-- 复合索引顺序：过滤字段 -> 分组字段 -> 聚合字段
CREATE INDEX idx_orders_optimized ON orders(status, region, amount);

-- 覆盖索引：包含查询所需的所有字段
CREATE INDEX idx_orders_covering ON orders(region, status, amount, order_date);
```

---

## 13. 📋 核心要点总结


### 13.1 必须掌握的核心概念


```
🔸 条件聚合本质：在聚合函数中加入条件判断逻辑
🔸 CASE WHEN：标准SQL语法，适合复杂多条件判断
🔸 IF函数：MySQL特有，适合简单二元条件判断
🔸 聚合过滤：WHERE过滤行，HAVING过滤组
🔸 性能优化：WHERE过滤优于聚合函数内条件判断
```

### 13.2 关键理解要点


**🔹 CASE WHEN核心机制**
```
工作原理：
• CASE WHEN返回NULL时，COUNT不计数
• CASE WHEN返回非NULL值时，COUNT计数  
• SUM会忽略NULL值，只计算非NULL值
• AVG同样忽略NULL值计算平均数
```

**🔹 条件聚合vs普通聚合**
```
普通聚合：SELECT COUNT(*), SUM(amount) FROM orders
条件聚合：SELECT COUNT(CASE WHEN status='completed' THEN 1 END) FROM orders

优势：一次查询完成多种统计需求
缺点：复杂查询可能影响性能
```

**🔹 性能优化策略**
```
优化方向：
• 减少重复计算：提取公共条件
• 合理使用索引：复合索引覆盖查询条件
• 先过滤后聚合：WHERE比CASE WHEN效率高
• 避免聚合函数嵌套：使用子查询或CTE
```

### 13.3 实际应用价值


**🎯 业务场景应用**
- **电商分析**：不同状态订单的统计分析
- **用户行为**：按用户类型分析活跃度和消费
- **销售报表**：按时间、地区、产品多维度统计
- **绩效考核**：员工、部门、项目的量化指标分析

**💡 最佳实践建议**
```
设计原则：
1. 条件清晰：CASE WHEN条件要明确无歧义
2. 性能优先：能用WHERE过滤就不用CASE WHEN
3. 可读性：复杂逻辑拆分成多个步骤
4. 复用性：公共逻辑提取为子查询或视图

避免误区：
❌ 不要过度使用条件聚合，简单需求用WHERE
❌ 不要在大表上进行复杂的条件聚合而不加索引
❌ 不要忽略NULL值处理，使用COALESCE或IFNULL
❌ 不要在聚合函数中嵌套聚合函数
```

**📊 技能进阶路径**
```
初级：掌握基本的CASE WHEN和IF条件聚合
中级：理解分组聚合、多条件统计和性能优化
高级：设计复杂的统计模式和聚合框架
专家：结合窗口函数、CTE等高级特性解决复杂业务需求
```

**核心记忆口诀**：
- 条件聚合选择统计，CASE WHEN灵活IF简洁
- 先过滤后聚合效率高，索引设计很重要
- NULL值影响聚合结果，COALESCE来处理
- 聚合嵌套不可行，子查询CTE是方向