---
title: 3、高级查询模式
---
## 📚 目录

1. [高级查询模式概述](#1-高级查询模式概述)
2. [递归查询与CTE](#2-递归查询与CTE)
3. [层次数据查询模式](#3-层次数据查询模式)
4. [图遍历查询技术](#4-图遍历查询技术)
5. [时序数据查询模式](#5-时序数据查询模式)
6. [窗口函数应用模式](#6-窗口函数应用模式)
7. [复杂查询设计策略](#7-复杂查询设计策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 高级查询模式概述


### 1.1 什么是高级查询模式


**🔸 高级查询的本质**
```
简单查询：查询单表或简单关联，直接获取结果
高级查询：涉及复杂逻辑、多层关系、特殊算法的查询模式

就像烹饪一样：
简单查询 = 煮面条    (直接、快速、简单)
高级查询 = 做满汉全席 (复杂、精细、技巧丰富)
```

**🌟 高级查询解决的实际问题**：
- **组织架构查询** - 查找某经理下的所有下属（不限层级）
- **产品分类遍历** - 遍历商品分类树的所有子分类
- **社交网络分析** - 查找用户的朋友圈关系链
- **时间序列分析** - 分析股价走势、用户行为趋势
- **数据统计排序** - 计算销售排名、用户活跃度排行

### 1.2 高级查询技术分类


**📊 技术分类体系**：

```
高级查询技术树
├── 递归查询技术
│   ├── 🔥 公用表表达式(CTE)
│   ├── 🔥 WITH RECURSIVE语法
│   └── 层次遍历算法
├── 窗口函数技术  
│   ├── 排序函数 (ROW_NUMBER, RANK)
│   ├── 聚合函数 (SUM, AVG OVER)
│   └── 分析函数 (LAG, LEAD)
├── 图遍历技术
│   ├── 深度优先搜索(DFS)
│   ├── 广度优先搜索(BFS)  
│   └── 最短路径算法
└── 时序分析技术
    ├── 滑动窗口计算
    ├── 趋势分析
    └── 时间序列聚合
```

### 1.3 MySQL版本支持情况


**📋 功能支持对比**：

| 功能特性 | **MySQL 5.7** | **MySQL 8.0** | **说明** |
|---------|---------------|---------------|----------|
| **窗口函数** | `❌` | `✅` | 8.0新增核心功能 |
| **CTE公用表表达式** | `❌` | `✅` | 8.0新增递归查询能力 |
| **JSON函数** | `基础` | `完整` | 8.0大幅增强JSON处理 |
| **分析函数** | `❌` | `✅` | 8.0新增数据分析能力 |

> ⚠️ **版本要求**
> 
> 本章的高级查询技术主要基于MySQL 8.0，如果你使用的是MySQL 5.7或更早版本，部分功能无法使用。

---

## 2. 🔄 递归查询与CTE


### 2.1 CTE公用表表达式基础


**🔸 CTE是什么**
```
CTE (Common Table Expression) = 公用表表达式
简单理解：就是在SQL查询中定义一个"临时的命名查询结果"

就像编程中的变量：
int result = calculate();  // 把计算结果存到变量里
use(result);              // 后面可以重复使用

WITH temp_result AS (     -- 把查询结果存到CTE里  
    SELECT ...            -- 定义查询逻辑
)
SELECT * FROM temp_result; -- 后面可以重复使用
```

**💡 CTE的基本语法**：

```sql
-- 基础CTE语法
WITH cte_name AS (
    SELECT column1, column2 
    FROM table_name 
    WHERE condition
)
SELECT * FROM cte_name;

-- 多个CTE定义
WITH 
    cte1 AS (SELECT ...),
    cte2 AS (SELECT ...),
    cte3 AS (SELECT ...)
SELECT * FROM cte1 
JOIN cte2 ON ...
JOIN cte3 ON ...;
```

**🎯 CTE的实际用途**：

<details>
<summary>🔍 点击查看CTE应用示例</summary>

```sql
-- 例子：查询销售额前10的销售员及其详细信息
WITH top_sellers AS (
    -- 先计算每个销售员的总销售额
    SELECT 
        seller_id,
        SUM(amount) as total_sales
    FROM orders
    WHERE order_date >= '2024-01-01'
    GROUP BY seller_id
    ORDER BY total_sales DESC
    LIMIT 10
)
-- 再关联销售员详细信息
SELECT 
    s.name,
    s.department,
    t.total_sales
FROM top_sellers t
JOIN sellers s ON t.seller_id = s.id;
```

</details>

### 2.2 WITH RECURSIVE递归查询


**🔥 递归查询的威力**

递归查询专门用来处理**层次结构数据**，比如：
- 公司的组织架构（经理-下属关系）
- 商品分类树（主分类-子分类）  
- 论坛评论（主贴-回复-回复的回复）
- 地区层级（国家-省份-城市-区县）

**🏗️ 递归查询语法结构**：

```sql
WITH RECURSIVE recursive_cte AS (
    -- 第1部分：初始查询（锚点查询）
    SELECT initial_columns
    FROM table_name
    WHERE initial_condition
    
    UNION ALL
    
    -- 第2部分：递归查询  
    SELECT recursive_columns
    FROM table_name t
    JOIN recursive_cte r ON t.parent_id = r.id
)
SELECT * FROM recursive_cte;
```

**💭 递归查询的工作原理**：

```
递归查询执行过程:
步骤1: 执行锚点查询，得到初始结果集
步骤2: 将初始结果作为输入，执行递归部分
步骤3: 将新结果加入总结果集
步骤4: 如果有新结果，继续步骤2；否则结束

就像爬楼梯：
锚点查询 = 找到第1层楼
递归查询 = 从当前层找到上一层或下一层
继续递归 = 重复爬楼过程，直到楼顶或楼底
```

### 2.3 组织架构递归查询实例


**🏢 员工层级关系表设计**：

```sql
-- 员工表结构
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    position VARCHAR(50),
    manager_id INT,  -- 指向上级管理者的ID
    salary DECIMAL(10,2)
);

-- 示例数据
INSERT INTO employees VALUES
(1, '张总', 'CEO', NULL, 50000),
(2, '李经理', '技术总监', 1, 30000),
(3, '王经理', '销售总监', 1, 28000), 
(4, '赵工', '高级开发', 2, 15000),
(5, '钱工', '开发工程师', 2, 12000),
(6, '孙工', '销售代表', 3, 8000);
```

**📊 组织架构图**：

```
组织结构:
    张总(CEO)
    ├── 李经理(技术总监)
    │   ├── 赵工(高级开发)
    │   └── 钱工(开发工程师)  
    └── 王经理(销售总监)
        └── 孙工(销售代表)
```

**🔥 递归查询所有下属**：

```sql
-- 查询张总(ID=1)的所有下属（不限层级）
WITH RECURSIVE subordinates AS (
    -- 锚点：找到直接下属
    SELECT id, name, position, manager_id, 1 as level
    FROM employees
    WHERE manager_id = 1
    
    UNION ALL
    
    -- 递归：找下属的下属
    SELECT e.id, e.name, e.position, e.manager_id, s.level + 1
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT 
    CONCAT(REPEAT('  ', level-1), name) as org_chart,
    position,
    level
FROM subordinates
ORDER BY level, id;
```

**📋 查询结果展示**：

```
org_chart          position      level
李经理             技术总监        1
王经理             销售总监        1  
  赵工             高级开发        2
  钱工             开发工程师      2
  孙工             销售代表        2
```

### 2.4 CTE递归应用的高级技巧


**🔄 向上递归查询**：

```sql
-- 查询某员工的所有上级（汇报链）
WITH RECURSIVE managers AS (
    -- 锚点：从指定员工开始
    SELECT id, name, position, manager_id, 0 as level
    FROM employees
    WHERE id = 5  -- 钱工
    
    UNION ALL
    
    -- 递归：查找上级管理者
    SELECT e.id, e.name, e.position, e.manager_id, m.level + 1
    FROM employees e
    JOIN managers m ON e.id = m.manager_id
)
SELECT 
    name,
    position,
    level,
    CASE level
        WHEN 0 THEN '👤 本人'
        WHEN 1 THEN '👨‍💼 直接上级'  
        WHEN 2 THEN '👔 上级的上级'
        ELSE '🏢 高层领导'
    END as relationship
FROM managers
ORDER BY level;
```

**🎯 计算组织层级深度**：

```sql
-- 计算每个部门的层级深度
WITH RECURSIVE org_depth AS (
    -- 锚点：顶层管理者
    SELECT id, name, manager_id, 1 as depth
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归：计算子级深度
    SELECT e.id, e.name, e.manager_id, o.depth + 1
    FROM employees e
    JOIN org_depth o ON e.manager_id = o.id
)
SELECT 
    MAX(depth) as max_org_depth,
    COUNT(DISTINCT depth) as total_levels
FROM org_depth;
```

---

## 3. 🌳 层次数据查询模式


### 3.1 层次数据的常见存储模式


**🗂️ 三种主要存储模式**：

```
1. 邻接列表模式 (Adjacency List)
┌────────────────┐
│ id │ name │ pid │  pid = parent_id
├────┼──────┼─────┤
│ 1  │ 根   │NULL │
│ 2  │ A    │ 1   │
│ 3  │ B    │ 1   │  
│ 4  │ A1   │ 2   │
└────┴──────┴─────┘

2. 路径枚举模式 (Path Enumeration)  
┌─────────────────────┐
│ id │ name │ path   │
├────┼──────┼────────┤
│ 1  │ 根   │ /1/    │
│ 2  │ A    │ /1/2/  │
│ 3  │ B    │ /1/3/  │
│ 4  │ A1   │ /1/2/4/│
└────┴──────┴────────┘

3. 嵌套集合模式 (Nested Set)
┌──────────────────────────┐
│ id │ name │ lft │ rgt │
├────┼──────┼─────┼─────┤
│ 1  │ 根   │ 1   │ 8   │
│ 2  │ A    │ 2   │ 5   │
│ 3  │ B    │ 6   │ 7   │
│ 4  │ A1   │ 3   │ 4   │
└────┴──────┴─────┴─────┘
```

### 3.2 商品分类递归查询实例


**🛍️ 电商商品分类表**：

```sql
-- 商品分类表
CREATE TABLE categories (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    parent_id INT,
    level INT,
    sort_order INT
);

-- 示例数据：电商分类体系
INSERT INTO categories VALUES
(1, '所有商品', NULL, 1, 1),
(2, '电子产品', 1, 2, 1),
(3, '服装鞋帽', 1, 2, 2),
(4, '手机数码', 2, 3, 1),
(5, '电脑办公', 2, 3, 2),
(6, '男装', 3, 3, 1),
(7, '女装', 3, 3, 2),
(8, '智能手机', 4, 4, 1),
(9, '平板电脑', 4, 4, 2);
```

**🌳 分类树结构可视化**：

```
所有商品(1)
├── 电子产品(2)
│   ├── 手机数码(4)
│   │   ├── 智能手机(8)
│   │   └── 平板电脑(9)
│   └── 电脑办公(5)
└── 服装鞋帽(3)
    ├── 男装(6)
    └── 女装(7)
```

**🔥 查询指定分类的所有子分类**：

```sql
-- 查询"电子产品"分类下的所有子分类
WITH RECURSIVE category_tree AS (
    -- 锚点：找到起始分类
    SELECT id, name, parent_id, level, name as path
    FROM categories
    WHERE id = 2  -- 电子产品分类ID
    
    UNION ALL
    
    -- 递归：查找所有子分类
    SELECT 
        c.id, 
        c.name, 
        c.parent_id, 
        c.level,
        CONCAT(ct.path, ' → ', c.name) as path
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT 
    CONCAT(REPEAT('├── ', level-2), name) as category_tree,
    path,
    level
FROM category_tree
ORDER BY level, id;
```

**📊 递归查询结果**：

```
category_tree              path                           level
电子产品                   电子产品                        2
├── 手机数码               电子产品 → 手机数码              3
├── 电脑办公               电子产品 → 电脑办公              3  
├──── 智能手机             电子产品 → 手机数码 → 智能手机    4
├──── 平板电脑             电子产品 → 手机数码 → 平板电脑    4
```

### 3.3 层次数据统计查询


**📈 统计每个分类下的商品数量**：

```sql
-- 假设有商品表
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    category_id INT,
    price DECIMAL(10,2)
);

-- 递归统计分类商品数（包含子分类）
WITH RECURSIVE category_stats AS (
    -- 锚点：叶子分类的直接商品数
    SELECT 
        c.id,
        c.name,
        c.parent_id,
        c.level,
        COALESCE(p.product_count, 0) as direct_count
    FROM categories c
    LEFT JOIN (
        SELECT category_id, COUNT(*) as product_count
        FROM products
        GROUP BY category_id
    ) p ON c.id = p.category_id
    WHERE NOT EXISTS (
        SELECT 1 FROM categories child WHERE child.parent_id = c.id
    )
    
    UNION ALL
    
    -- 递归：向上累计商品数量
    SELECT 
        parent.id,
        parent.name,
        parent.parent_id,
        parent.level,
        cs.direct_count
    FROM categories parent
    JOIN category_stats cs ON parent.id = cs.parent_id
)
SELECT 
    name,
    level,
    SUM(direct_count) as total_products
FROM category_stats
GROUP BY id, name, level
ORDER BY level, id;
```

---

## 4. 🔗 图遍历查询技术


### 4.1 社交网络图遍历


**👥 社交关系图查询**

社交网络中的"朋友关系"实际上就是一个**图结构**，我们需要用SQL来实现图的遍历算法。

**🔧 社交关系表设计**：

```sql
-- 用户表
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);

-- 关注关系表（有向图）
CREATE TABLE follows (
    follower_id INT,    -- 关注者
    followed_id INT,    -- 被关注者
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (follower_id, followed_id)
);
```

**🌐 社交网络图示例**：

```
社交关系图:
     (1)张三
    ↙     ↘
  (2)李四 → (3)王五
    ↓       ↙
  (4)赵六 ←

关系说明:
- 张三关注李四和王五
- 李四关注王五和赵六  
- 王五关注赵六
- 赵六没有关注任何人
```

**🔥 查找共同关注（二度人脉）**：

```sql
-- 查找张三的朋友的朋友（2度关系内的用户）
WITH RECURSIVE friend_network AS (
    -- 锚点：张三直接关注的人（1度关系）
    SELECT 
        f.followed_id as user_id,
        u.username,
        1 as degree,
        CAST(u.username AS CHAR(200)) as path
    FROM follows f
    JOIN users u ON f.followed_id = u.id
    WHERE f.follower_id = 1  -- 张三的ID
    
    UNION ALL
    
    -- 递归：朋友的朋友（2度关系）  
    SELECT 
        f.followed_id as user_id,
        u.username,
        fn.degree + 1,
        CONCAT(fn.path, ' → ', u.username) as path
    FROM follows f
    JOIN users u ON f.followed_id = u.id
    JOIN friend_network fn ON f.follower_id = fn.user_id
    WHERE fn.degree < 2  -- 限制搜索深度
      AND f.followed_id != 1  -- 排除自己
)
SELECT DISTINCT
    username,
    degree,
    path
FROM friend_network
ORDER BY degree, username;
```

### 4.2 图算法SQL实现


**🎯 最短路径查询**：

```sql
-- 查找两个用户间的最短关注路径
WITH RECURSIVE shortest_path AS (
    -- 锚点：起始用户
    SELECT 
        followed_id as current_user,
        1 as path_length,
        CAST(CONCAT(follower_id, '→', followed_id) AS CHAR(500)) as path
    FROM follows
    WHERE follower_id = 1  -- 起始用户：张三
    
    UNION ALL
    
    -- 递归：寻找路径
    SELECT 
        f.followed_id,
        sp.path_length + 1,
        CONCAT(sp.path, '→', f.followed_id)
    FROM follows f
    JOIN shortest_path sp ON f.follower_id = sp.current_user
    WHERE sp.path_length < 5  -- 限制最大搜索深度
      AND sp.current_user != 4  -- 还没到达目标用户：赵六
)
SELECT 
    path,
    path_length
FROM shortest_path
WHERE current_user = 4  -- 目标用户：赵六
ORDER BY path_length
LIMIT 1;  -- 只要最短路径
```

**🔍 查找影响力用户（中心度计算）**：

```sql
-- 计算用户的影响力（能影响到多少人）
WITH RECURSIVE influence_network AS (
    -- 锚点：直接关注者
    SELECT 
        u.id as influencer,
        u.username as influencer_name,
        f.followed_id as influenced_user,
        1 as influence_degree
    FROM users u
    JOIN follows f ON u.id = f.follower_id
    
    UNION ALL
    
    -- 递归：间接影响
    SELECT 
        i.influencer,
        i.influencer_name,
        f.followed_id,
        i.influence_degree + 1
    FROM influence_network i
    JOIN follows f ON i.influenced_user = f.follower_id
    WHERE i.influence_degree < 3  -- 限制影响层级
)
SELECT 
    influencer_name,
    COUNT(DISTINCT influenced_user) as total_influence,
    MAX(influence_degree) as max_degree
FROM influence_network
GROUP BY influencer, influencer_name
ORDER BY total_influence DESC;
```

---

## 5. ⏰ 时序数据查询模式


### 5.1 时序数据查询基础


**📈 时序数据的特点**
```
时序数据特征:
• 时间维度：每条记录都有时间戳
• 趋势性：数据随时间变化有规律
• 聚合性：通常需要按时间段聚合
• 连续性：时间点之间存在关联关系

典型应用场景:
股票价格 📊 → 分析价格走势、计算技术指标
用户行为 👤 → 分析活跃度趋势、留存率
系统监控 🖥️ → CPU使用率、内存变化趋势
销售数据 💰 → 月度季度销售对比分析
```

**🔧 时序数据表设计**：

```sql
-- 股票价格表（时序数据示例）
CREATE TABLE stock_prices (
    id INT AUTO_INCREMENT PRIMARY KEY,
    symbol VARCHAR(10),      -- 股票代码
    trade_date DATE,         -- 交易日期
    open_price DECIMAL(10,2), -- 开盘价
    close_price DECIMAL(10,2), -- 收盘价
    high_price DECIMAL(10,2),  -- 最高价
    low_price DECIMAL(10,2),   -- 最低价
    volume BIGINT,            -- 交易量
    INDEX idx_symbol_date (symbol, trade_date)
);
```

### 5.2 时序数据聚合查询模式


**📊 滑动窗口计算**：

```sql
-- 计算股票的5日移动平均价格
SELECT 
    symbol,
    trade_date,
    close_price,
    -- 滑动窗口：当前行及前4行的平均值
    AVG(close_price) OVER (
        PARTITION BY symbol 
        ORDER BY trade_date 
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) as ma5,
    -- 滑动窗口：当前行及前19行的平均值
    AVG(close_price) OVER (
        PARTITION BY symbol 
        ORDER BY trade_date 
        ROWS BETWEEN 19 PRECEDING AND CURRENT ROW  
    ) as ma20
FROM stock_prices
WHERE symbol = 'AAPL'
ORDER BY trade_date;
```

**📈 趋势分析查询**：

```sql
-- 分析股票价格趋势和波动率
SELECT 
    symbol,
    trade_date,
    close_price,
    -- 价格变化
    close_price - LAG(close_price) OVER (
        PARTITION BY symbol ORDER BY trade_date
    ) as daily_change,
    -- 价格变化百分比
    ROUND(
        (close_price - LAG(close_price) OVER (
            PARTITION BY symbol ORDER BY trade_date
        )) / LAG(close_price) OVER (
            PARTITION BY symbol ORDER BY trade_date
        ) * 100, 2
    ) as change_percent,
    -- 历史最高价
    MAX(close_price) OVER (
        PARTITION BY symbol 
        ORDER BY trade_date 
        ROWS UNBOUNDED PRECEDING
    ) as historical_high
FROM stock_prices
WHERE symbol = 'AAPL'
  AND trade_date >= '2024-01-01'
ORDER BY trade_date;
```

### 5.3 时间序列gap填充


**⏰ 处理时间序列中的缺失数据**：

```sql
-- 使用递归CTE生成连续日期，填补缺失的交易日
WITH RECURSIVE date_series AS (
    -- 锚点：起始日期
    SELECT DATE('2024-01-01') as trade_date
    
    UNION ALL
    
    -- 递归：生成后续日期
    SELECT DATE_ADD(trade_date, INTERVAL 1 DAY)
    FROM date_series
    WHERE trade_date < '2024-12-31'
),
complete_data AS (
    SELECT 
        ds.trade_date,
        sp.symbol,
        sp.close_price,
        -- 使用前一个有效价格填充缺失值
        COALESCE(
            sp.close_price,
            LAG(sp.close_price) IGNORE NULLS OVER (
                PARTITION BY sp.symbol 
                ORDER BY ds.trade_date
            )
        ) as filled_price
    FROM date_series ds
    CROSS JOIN (SELECT DISTINCT symbol FROM stock_prices) symbols
    LEFT JOIN stock_prices sp ON ds.trade_date = sp.trade_date 
                               AND symbols.symbol = sp.symbol
    WHERE symbols.symbol = 'AAPL'
)
SELECT 
    trade_date,
    close_price as original_price,
    filled_price,
    CASE 
        WHEN close_price IS NULL THEN '🔸 填充值'
        ELSE '📊 实际值'
    END as data_type
FROM complete_data
ORDER BY trade_date;
```

---

## 6. 📊 窗口函数应用模式


### 6.1 窗口函数基本概念


**🔸 窗口函数是什么**
```
窗口函数 = 在每一行上定义一个"窗口"，在这个窗口内进行计算

与聚合函数的区别：
聚合函数：多行 → 一行 (GROUP BY)
窗口函数：多行 → 多行 (每行都有结果)

生活比喻：
聚合函数像"班级总成绩" - 整个班只有一个总分
窗口函数像"每个人在班级中的排名" - 每个人都有自己的排名
```

**⚡ 窗口函数语法结构**：

```sql
-- 窗口函数基本语法
SELECT 
    column1,
    column2,
    窗口函数() OVER (
        PARTITION BY partition_column  -- 分区（可选）
        ORDER BY order_column         -- 排序（可选）
        ROWS/RANGE 窗口范围           -- 窗口范围（可选）
    ) as result
FROM table_name;
```

### 6.2 排名函数应用模式


**🏆 三种排名函数对比**：

```sql
-- 销售员业绩排名示例
SELECT 
    name,
    sales_amount,
    -- ROW_NUMBER: 连续排名，无并列
    ROW_NUMBER() OVER (ORDER BY sales_amount DESC) as row_num,
    -- RANK: 跳跃排名，有并列时下一名会跳过
    RANK() OVER (ORDER BY sales_amount DESC) as rank_num,
    -- DENSE_RANK: 密集排名，有并列时下一名不跳过
    DENSE_RANK() OVER (ORDER BY sales_amount DESC) as dense_rank
FROM sales_data;
```

**📊 排名结果对比**：

| name | sales_amount | row_num | rank_num | dense_rank |
|------|-------------|---------|----------|------------|
| 张三 | 10000 | `1` | `1` | `1` |
| 李四 | 9000  | `2` | `2` | `2` |
| 王五 | 9000  | `3` | `2` | `2` |
| 赵六 | 8000  | `4` | `4` | `3` |

**🎯 分组排名应用**：

```sql
-- 每个部门的销售Top3
WITH department_ranking AS (
    SELECT 
        department,
        name,
        sales_amount,
        ROW_NUMBER() OVER (
            PARTITION BY department 
            ORDER BY sales_amount DESC
        ) as dept_rank
    FROM sales_data
)
SELECT 
    department,
    name,
    sales_amount,
    CASE dept_rank
        WHEN 1 THEN '🥇 冠军'
        WHEN 2 THEN '🥈 亚军'  
        WHEN 3 THEN '🥉 季军'
        ELSE CONCAT('第', dept_rank, '名')
    END as ranking
FROM department_ranking
WHERE dept_rank <= 3
ORDER BY department, dept_rank;
```

### 6.3 聚合窗口函数模式


**📈 累计计算模式**：

```sql
-- 计算销售的累计金额和移动平均
SELECT 
    order_date,
    daily_sales,
    -- 累计销售额
    SUM(daily_sales) OVER (
        ORDER BY order_date
        ROWS UNBOUNDED PRECEDING
    ) as cumulative_sales,
    -- 7天移动平均
    AVG(daily_sales) OVER (
        ORDER BY order_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as weekly_avg,
    -- 与前一天对比
    daily_sales - LAG(daily_sales) OVER (
        ORDER BY order_date
    ) as daily_change,
    -- 月度排名
    RANK() OVER (
        PARTITION BY DATE_FORMAT(order_date, '%Y-%m')
        ORDER BY daily_sales DESC
    ) as monthly_rank
FROM daily_sales_summary
ORDER BY order_date;
```

### 6.4 分析函数高级应用


**🔍 数据分布分析**：

```sql
-- 用户行为分析：分组、分位数、占比计算
SELECT 
    user_id,
    login_count,
    -- 用户活跃度分组
    NTILE(4) OVER (ORDER BY login_count) as activity_quartile,
    -- 百分位排名
    PERCENT_RANK() OVER (ORDER BY login_count) as percentile,
    -- 累计分布
    CUME_DIST() OVER (ORDER BY login_count) as cumulative_dist,
    -- 占总体比例
    login_count / SUM(login_count) OVER () * 100 as percentage,
    -- 分组标签
    CASE NTILE(4) OVER (ORDER BY login_count)
        WHEN 4 THEN '🔥 高活跃用户'
        WHEN 3 THEN '✅ 中活跃用户'
        WHEN 2 THEN '⚠️ 低活跃用户'  
        WHEN 1 THEN '😴 沉睡用户'
    END as user_segment
FROM user_activity
ORDER BY login_count DESC;
```

---

## 7. 🎨 复杂查询设计策略


### 7.1 多层嵌套查询设计策略


**🏗️ 嵌套查询的层次控制**

复杂查询就像搭积木，需要**分层设计、逐步构建**：

```
查询层次设计原则:
┌─────────────────────────────┐
│ 第1层：基础数据提取         │ ← 最底层，提取原始数据
├─────────────────────────────┤
│ 第2层：数据清洗和转换       │ ← 中间层，处理数据格式
├─────────────────────────────┤  
│ 第3层：业务逻辑计算         │ ← 业务层，实现业务规则
├─────────────────────────────┤
│ 第4层：结果汇总和格式化     │ ← 表现层，最终结果展示
└─────────────────────────────┘
```

**🔧 层次化查询示例**：

```sql
-- 复杂销售分析：4层嵌套查询
WITH 
-- 第1层：基础数据提取
raw_sales AS (
    SELECT 
        o.order_date,
        o.customer_id,
        oi.product_id,
        oi.quantity,
        oi.unit_price,
        p.category_id
    FROM orders o
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
    WHERE o.order_date >= '2024-01-01'
),
-- 第2层：数据清洗和转换
cleaned_sales AS (
    SELECT 
        order_date,
        customer_id,
        category_id,
        quantity * unit_price as item_revenue,
        DATE_FORMAT(order_date, '%Y-%m') as month_key
    FROM raw_sales
    WHERE quantity > 0 AND unit_price > 0
),
-- 第3层：业务逻辑计算
monthly_stats AS (
    SELECT 
        month_key,
        category_id,
        COUNT(DISTINCT customer_id) as customer_count,
        SUM(item_revenue) as total_revenue,
        AVG(item_revenue) as avg_order_value
    FROM cleaned_sales
    GROUP BY month_key, category_id
),
-- 第4层：结果汇总和格式化
final_report AS (
    SELECT 
        month_key,
        c.name as category_name,
        customer_count,
        total_revenue,
        avg_order_value,
        RANK() OVER (
            PARTITION BY month_key 
            ORDER BY total_revenue DESC
        ) as revenue_rank
    FROM monthly_stats ms
    JOIN categories c ON ms.category_id = c.id
)
SELECT 
    month_key as 月份,
    category_name as 商品分类,
    customer_count as 客户数量,
    CONCAT('¥', FORMAT(total_revenue, 2)) as 总收入,
    CONCAT('¥', FORMAT(avg_order_value, 2)) as 平均订单价值,
    CASE revenue_rank
        WHEN 1 THEN '🥇 第一名'
        WHEN 2 THEN '🥈 第二名'
        WHEN 3 THEN '🥉 第三名'
        ELSE CONCAT('第', revenue_rank, '名')
    END as 收入排名
FROM final_report
ORDER BY month_key, revenue_rank;
```

### 7.2 嵌套查询可读性优化


**📝 提升查询可读性的技巧**：

> 💡 **可读性优化原则**
> 
> 1. **命名要清晰** - CTE名称要能表达含义
> 2. **注释要充分** - 复杂逻辑要有注释说明
> 3. **格式要整齐** - 缩进对齐，层次分明
> 4. **逻辑要分层** - 每个CTE只做一件事

**🔧 优化前后对比**：

<details>
<summary>🔍 点击查看优化示例</summary>

```sql
-- ❌ 优化前：可读性差
SELECT c.name, SUM(oi.quantity * oi.unit_price) FROM customers c JOIN orders o ON c.id = o.customer_id JOIN order_items oi ON o.id = oi.order_id WHERE o.order_date >= '2024-01-01' GROUP BY c.id, c.name HAVING SUM(oi.quantity * oi.unit_price) > 10000 ORDER BY SUM(oi.quantity * oi.unit_price) DESC;

-- ✅ 优化后：可读性好
WITH 
-- 第1步：提取今年的订单数据
current_year_orders AS (
    SELECT 
        customer_id,
        order_id,
        order_date
    FROM orders
    WHERE order_date >= '2024-01-01'
),
-- 第2步：计算每个客户的消费总额
customer_spending AS (
    SELECT 
        c.id as customer_id,
        c.name as customer_name,
        SUM(oi.quantity * oi.unit_price) as total_spending
    FROM customers c
    JOIN current_year_orders cyo ON c.id = cyo.customer_id
    JOIN order_items oi ON cyo.order_id = oi.order_id
    GROUP BY c.id, c.name
),
-- 第3步：筛选高价值客户
high_value_customers AS (
    SELECT *
    FROM customer_spending
    WHERE total_spending > 10000
)
-- 第4步：生成最终报告
SELECT 
    customer_name as 客户姓名,
    CONCAT('¥', FORMAT(total_spending, 2)) as 消费总额,
    CASE 
        WHEN total_spending > 50000 THEN '💎 钻石客户'
        WHEN total_spending > 30000 THEN '🥇 金牌客户'
        WHEN total_spending > 20000 THEN '🥈 银牌客户'
        ELSE '🥉 铜牌客户'
    END as 客户等级
FROM high_value_customers
ORDER BY total_spending DESC;
```

</details>

### 7.3 高级查询架构设计


**🎯 查询架构设计模式**：

```
复杂查询架构设计：

数据输入层 (Raw Data)
    ↓
数据清洗层 (Data Cleaning)
    ├─ 去除无效数据
    ├─ 数据类型转换  
    └─ 异常值处理
    ↓
业务计算层 (Business Logic)
    ├─ 业务规则应用
    ├─ 指标计算
    └─ 关联关系处理
    ↓
数据聚合层 (Aggregation)
    ├─ 分组统计
    ├─ 汇总计算
    └─ 排序排名
    ↓  
结果展示层 (Presentation)
    ├─ 格式化输出
    ├─ 标签分类
    └─ 用户友好展示
```

**🔧 模块化查询设计**：

```sql
-- 设计模式：用CTE实现查询模块化
WITH
-- 模块1：数据提取模块
data_extraction AS (
    SELECT ... FROM ... WHERE ...
),
-- 模块2：数据清洗模块  
data_cleaning AS (
    SELECT 
        *,
        CASE WHEN condition THEN clean_value ELSE original_value END
    FROM data_extraction
),
-- 模块3：业务计算模块
business_calculation AS (
    SELECT 
        *,
        complex_business_logic(...) as calculated_field
    FROM data_cleaning
),
-- 模块4：最终结果模块
final_result AS (
    SELECT 
        formatted_columns,
        aggregated_metrics
    FROM business_calculation
    GROUP BY ...
)
SELECT * FROM final_result;
```

### 7.4 查询性能优化策略


**⚡ 复杂查询优化技巧**：

| 优化技术 | **作用原理** | **适用场景** | **注意事项** |
|---------|-------------|-------------|-------------|
| **🔍 索引优化** | 减少扫描行数 | 大数据量查询 | 注意索引维护成本 |
| **📊 分区表** | 并行处理、剪枝 | 时序数据查询 | 分区键选择要合理 |
| **💾 物化视图** | 预计算结果 | 重复复杂查询 | 数据实时性要求低 |
| **🔄 查询重写** | 优化执行计划 | 多表复杂JOIN | 需要深入理解执行计划 |

**🎯 查询优化检查清单**：

```markdown
🔍 **查询优化检查清单**
- [ ] 是否使用了合适的索引
- [ ] WHERE条件是否能有效过滤数据
- [ ] JOIN顺序是否合理  
- [ ] 是否存在不必要的子查询
- [ ] 窗口函数的PARTITION是否合适
- [ ] 是否可以用EXISTS替代IN
- [ ] 临时表大小是否可控
- [ ] 是否考虑了查询缓存
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 CTE递归查询：处理层次结构数据的核心技术
🔸 窗口函数：在每行上进行分析计算的强大工具
🔸 图遍历：用SQL实现社交网络、关系链分析
🔸 时序查询：处理时间相关数据的专业模式
🔸 查询设计：分层设计、模块化、可读性优化
```

### 8.2 关键理解要点


**🔹 递归查询的核心思想**
```
理解要点：
- 递归 = 锚点查询 + 递归部分 + 终止条件
- 适用于层次数据、图遍历、路径查找
- MySQL 8.0才支持，需要注意版本兼容性
- 要设置合理的递归深度限制
```

**🔹 窗口函数vs聚合函数**
```
关键区别：
- 聚合函数改变结果行数（多行→一行）
- 窗口函数保持结果行数（多行→多行）
- 窗口函数能在每行上进行复杂分析
- 适合排名、趋势、对比分析
```

**🔹 复杂查询的设计思维**
```
设计原则：
- 分而治之：复杂问题分解为简单步骤
- 分层设计：每层解决特定类型的问题
- 模块化：用CTE实现查询的模块化
- 可读性优先：代码要让人容易理解
```

### 8.3 实际应用价值


**💼 业务场景应用**
- **电商分析**：商品销售排名、用户购买路径分析
- **社交平台**：用户关系链、影响力分析、推荐算法
- **企业管理**：组织架构查询、员工汇报关系、权限继承
- **金融分析**：股价趋势、技术指标计算、风险评估
- **运营分析**：用户行为漏斗、留存率分析、A/B测试

**🛠️ 技术应用指导**

> 📚 **学习建议**
> 
> 1. **循序渐进**：先掌握基础语法，再学复杂应用
> 2. **实践为主**：多写实际业务场景的查询
> 3. **性能意识**：复杂查询要考虑性能影响
> 4. **版本兼容**：注意MySQL版本功能差异

**🚀 进阶方向**
- **查询优化器**：学习执行计划分析
- **存储过程**：将复杂查询封装为存储过程
- **数据仓库**：学习OLAP分析查询模式
- **大数据技术**：Spark SQL、Presto等分布式查询引擎

**核心记忆**：
- 递归查询处理层次数据，CTE是核心工具
- 窗口函数让每行都能进行复杂分析计算
- 复杂查询要分层设计，注重可读性维护性
- 查询优化和性能考虑同样重要
- MySQL 8.0带来了强大的高级查询能力