---
title: 7、查询性能分析方法
---
## 📚 目录

1. [查询性能分析概述](#1-查询性能分析概述)
2. [Performance Schema性能分析](#2-Performance-Schema性能分析)
3. [sys库查询性能视图](#3-sys库查询性能视图)
4. [SHOW PROFILES性能剖析](#4-SHOW-PROFILES性能剖析)
5. [执行计划深度分析](#5-执行计划深度分析)
6. [资源消耗监控详解](#6-资源消耗监控详解)
7. [等待事件分析](#7-等待事件分析)
8. [性能问题诊断技巧](#8-性能问题诊断技巧)
9. [查询性能分析系统方法](#9-查询性能分析系统方法)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 查询性能分析概述


### 1.1 什么是查询性能分析


**简单理解**：就像医生给病人体检一样，查询性能分析是给你的SQL"体检"，找出哪里有问题，为什么跑得慢。

```
SQL性能体检报告：
┌─────────────────────────────────────┐
│ 患者：SELECT * FROM users WHERE...  │
│ 症状：查询耗时5秒，用户等不及        │
│ 病因：全表扫描，没有使用索引        │  
│ 处方：在age字段上建立索引           │
│ 预后：查询时间预计降低到50ms        │
└─────────────────────────────────────┘
```

### 1.2 性能分析的核心目标


**🎯 主要目标**：
- **定位瓶颈**：找出查询慢在哪个环节
- **量化问题**：用数据说话，不靠猜测
- **优化指导**：给出具体的优化建议
- **预防问题**：建立监控体系，提前发现问题

### 1.3 性能分析的整体思路


```
性能分析三步法：

第一步：发现问题
├─ 监控告警：慢查询日志、监控系统
├─ 用户反馈：页面加载慢、操作超时
└─ 主动检查：定期性能体检

第二步：定位问题  
├─ 执行计划分析：查看SQL执行路径
├─ 资源使用分析：CPU、内存、IO消耗
└─ 等待事件分析：查看等待在哪些资源上

第三步：解决问题
├─ 索引优化：创建、修改、删除索引
├─ SQL改写：优化查询逻辑
├─ 参数调优：调整MySQL配置参数
└─ 架构优化：读写分离、分库分表等
```

---

## 2. 📊 Performance Schema性能分析


### 2.1 Performance Schema是什么


**通俗解释**：Performance Schema就像MySQL的"黑匣子"，记录了MySQL运行过程中的所有性能数据，包括每个SQL执行了多长时间、等待了什么资源、消耗了多少内存等等。

```
Performance Schema的作用：
┌─────────────────────────────────────┐
│ MySQL内部活动监控器                  │
│                                    │
│ 记录内容：                          │
│ ├─ SQL执行统计                      │  
│ ├─ 等待事件统计                     │
│ ├─ 内存使用统计                     │
│ ├─ IO操作统计                      │
│ ├─ 锁等待统计                      │
│ └─ 连接线程统计                     │
└─────────────────────────────────────┘
```

### 2.2 开启Performance Schema


**检查和开启Performance Schema**：
```sql
-- 1. 检查是否已开启
SHOW VARIABLES LIKE 'performance_schema';

-- 2. 如果未开启，需要在配置文件中设置（需要重启）
[mysqld]
performance_schema = ON

-- 3. 查看当前启用的监控项
SELECT * FROM performance_schema.setup_instruments 
WHERE enabled = 'YES' LIMIT 10;
```

### 2.3 Performance Schema核心表分析


**🔥 语句统计表（statements_summary_by_digest）**

这个表记录了每种SQL模式的汇总统计信息：

```sql
-- 查看最耗时的SQL
SELECT 
    SCHEMA_NAME as db_name,
    DIGEST_TEXT as sql_pattern,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000000 as avg_time_sec,
    MAX_TIMER_WAIT/1000000000 as max_time_sec,
    SUM_TIMER_WAIT/1000000000 as total_time_sec
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY SUM_TIMER_WAIT DESC 
LIMIT 10;
```

**结果解读**：
```
db_name | sql_pattern                    | exec_count | avg_time_sec | total_time_sec
--------|--------------------------------|------------|--------------|---------------
mydb    | SELECT * FROM users WHERE id=? | 5000       | 0.050        | 250.5
mydb    | UPDATE users SET status=? ...   | 1200       | 0.120        | 144.8
mydb    | SELECT COUNT(*) FROM orders...  | 800        | 0.180        | 144.2

分析结论：
✓ 第一个SQL虽然单次快(50ms)，但执行次数多，总耗时最大
✓ 第三个SQL单次最慢(180ms)，需要重点优化
```

**🔥 等待事件统计表（events_waits_summary_global_by_event_name）**

```sql
-- 查看主要等待事件
SELECT 
    EVENT_NAME,
    COUNT_STAR as wait_count,
    SUM_TIMER_WAIT/1000000000 as total_wait_sec,
    AVG_TIMER_WAIT/1000000000 as avg_wait_sec
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE SUM_TIMER_WAIT > 0 
ORDER BY SUM_TIMER_WAIT DESC 
LIMIT 10;
```

**等待事件含义解释**：
```
wait/io/file/innodb/innodb_data_file
├─ 含义：等待读写InnoDB数据文件
├─ 常见原因：IO性能不足，缓存命中率低
└─ 优化方向：增加内存，使用SSD，优化查询减少IO

wait/synch/mutex/innodb/buf_pool_mutex  
├─ 含义：等待Buffer Pool的互斥锁
├─ 常见原因：高并发下Buffer Pool竞争激烈
└─ 优化方向：增大Buffer Pool，减少不必要的全表扫描

wait/lock/table/sql/handler
├─ 含义：等待表级锁
├─ 常见原因：长事务、表级锁冲突
└─ 优化方向：优化事务，使用行级锁存储引擎
```

### 2.4 Performance Schema实战案例


**案例：分析一个慢查询的完整过程**

```sql
-- 1. 先执行一个可能慢的查询
SELECT u.*, d.dept_name, COUNT(o.id) as order_count
FROM users u
JOIN departments d ON u.dept_id = d.id  
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, d.dept_name
ORDER BY order_count DESC;

-- 2. 查看这个查询的详细统计
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000000 as avg_sec,
    SUM_LOCK_TIME/1000000000 as lock_time_sec,
    SUM_ROWS_EXAMINED,
    SUM_ROWS_SENT,
    SUM_CREATED_TMP_TABLES,
    SUM_CREATED_TMP_DISK_TABLES
FROM performance_schema.events_statements_summary_by_digest 
WHERE DIGEST_TEXT LIKE '%users%departments%orders%'
ORDER BY LAST_SEEN DESC LIMIT 1;
```

**分析结果指标含义**：
- **avg_sec**：平均执行时间，超过1秒需要关注
- **lock_time_sec**：锁等待时间，时间长说明有锁竞争
- **SUM_ROWS_EXAMINED**：扫描行数，与返回行数比值过大说明效率低
- **SUM_CREATED_TMP_TABLES**：临时表数量，非零需要优化GROUP BY/ORDER BY

---

## 3. 🔧 sys库查询性能视图


### 3.1 sys库是什么


**通俗理解**：sys库就是MySQL提供的"性能分析助手"，它把Performance Schema里复杂难懂的原始数据，包装成容易理解的视图，让你能快速发现问题。

```
原始Performance Schema：          sys库封装后：
复杂的表名和字段名                  通俗易懂的视图名
需要复杂JOIN查询                   简单的SELECT查询  
数据单位是纳秒                     转换成秒、毫秒等
需要自己计算比例                   直接显示百分比
```

### 3.2 sys库核心性能视图


**🔥 最有用的性能分析视图**：

**1. statement_analysis：SQL语句分析**
```sql
-- 查看最耗时的SQL语句
SELECT * FROM sys.statement_analysis 
ORDER BY total_latency DESC LIMIT 10;

-- 结果示例：
query                              | exec_count | total_latency | avg_latency 
-----------------------------------|------------|---------------|-------------
SELECT * FROM users WHERE age > ? | 5000       | 4.5 min       | 54.2 ms
UPDATE users SET status = ? ...    | 1200       | 2.8 min       | 139.5 ms
```

**字段含义解释**：
- **query**：SQL语句模式（参数用?代替）
- **exec_count**：执行次数
- **total_latency**：总耗时（所有执行累加）
- **avg_latency**：平均耗时（单次执行平均时间）
- **lock_latency**：锁等待总时间
- **rows_examined_avg**：平均扫描行数

**2. schema_table_statistics：表访问统计**
```sql
-- 查看表的访问热度
SELECT * FROM sys.schema_table_statistics 
WHERE table_schema = 'mydb'
ORDER BY total_latency DESC LIMIT 10;

-- 结果解读：
table_schema | table_name | total_latency | rows_fetched | rows_inserted
-------------|------------|---------------|--------------|---------------
mydb         | users      | 3.2 min       | 1500000      | 5000
mydb         | orders     | 2.1 min       | 800000       | 12000

-- 分析结论：
-- users表查询频繁，是性能优化重点
-- orders表写入较多，关注写入性能
```

**3. schema_index_statistics：索引使用统计**
```sql
-- 查看索引使用情况
SELECT * FROM sys.schema_index_statistics 
WHERE table_schema = 'mydb'
ORDER BY select_latency DESC LIMIT 10;

-- 分析索引效果：
table_name | index_name | rows_selected | select_latency
-----------|------------|---------------|----------------
users      | idx_age    | 150000        | 45.2 sec
users      | idx_email  | 8000          | 2.1 sec
orders     | PRIMARY    | 200000        | 32.8 sec

-- 结论：
-- idx_age索引使用频繁但耗时长，可能需要优化
-- idx_email索引效率高，使用合理
```

### 3.3 sys库等待事件分析


**4. wait_classes_global_by_latency：等待事件分类**
```sql
-- 查看主要等待事件类型
SELECT * FROM sys.wait_classes_global_by_latency;

-- 结果分析：
event_class        | total_latency | avg_latency  | 占比
-------------------|---------------|--------------|------
wait/io/file       | 45.2 min      | 12.5 ms      | 60%
wait/synch/mutex   | 18.7 min      | 0.8 ms       | 25%  
wait/lock/table    | 8.9 min       | 156.2 ms     | 12%
wait/io/socket     | 2.1 min       | 1.2 ms       | 3%

分析结论：
🔥 文件IO是主要瓶颈(60%)，考虑增加内存或使用SSD
⚠️ 表锁等待占12%，单次等待时间长，需要优化事务
```

**5. io_global_by_file_by_latency：文件IO分析**
```sql
-- 查看文件IO热点
SELECT * FROM sys.io_global_by_file_by_latency 
WHERE file LIKE '%.ibd' LIMIT 10;

-- 结果解读：
file                    | total_latency | count_read | read_latency
------------------------|---------------|------------|-------------
/data/mydb/users.ibd    | 25.6 min      | 580000     | 22.1 min
/data/mydb/orders.ibd   | 12.3 min      | 320000     | 10.8 min

分析：
- users表文件是IO热点，读取频繁
- 考虑增加Buffer Pool大小，提升缓存命中率
```

---

## 4. 📈 SHOW PROFILES性能剖析


### 4.1 SHOW PROFILES基本使用


**什么是PROFILES**：它能详细记录SQL执行过程中每个阶段的耗时，让你清楚地知道时间都花在哪里了。

```sql
-- 1. 开启profiling（默认关闭）
SET profiling = 1;

-- 2. 执行你要分析的SQL
SELECT u.name, COUNT(o.id) as order_count
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 3. 查看所有profiles
SHOW PROFILES;

-- 结果示例：
Query_ID | Duration   | Query
---------|------------|----------------------------------------
1        | 0.125000   | SELECT u.name, COUNT(o.id)...
2        | 0.000234   | SHOW VARIABLES LIKE 'profiling'
```

### 4.2 详细性能剖析


**查看具体SQL的详细耗时分解**：
```sql
-- 查看Query_ID为1的详细信息
SHOW PROFILE FOR QUERY 1;

-- 结果分析：
Status                    | Duration
--------------------------|----------
starting                  | 0.000234
checking permissions      | 0.000012  
Opening tables           | 0.000156
init                     | 0.000034
System lock              | 0.000018
optimizing               | 0.000045    ← 优化器耗时
statistics               | 0.000089    ← 统计信息收集
preparing                | 0.000234    ← 预处理
executing                | 0.000023    ← 执行开始
Sending data             | 0.124200    ← 🔥 主要耗时：数据处理和发送
end                      | 0.000012
query end               | 0.000008
closing tables          | 0.000011
freeing items           | 0.000034
cleaning up             | 0.000018
```

**🔥 重点关注的阶段**：
- **Sending data**：通常是最耗时的阶段，包括数据读取、处理、发送
- **statistics**：统计信息收集时间长，可能统计信息过期
- **optimizing**：优化器耗时长，可能查询过于复杂
- **System lock**：系统锁等待，可能有锁竞争

### 4.3 更详细的性能分析


**查看CPU和IO详细信息**：
```sql
-- 查看CPU和IO详情
SHOW PROFILE CPU, BLOCK IO FOR QUERY 1;

-- 结果分析：
Status          | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out
----------------|----------|----------|------------|--------------|---------------
Sending data    | 0.124200 | 0.095000 | 0.028000   | 2048         | 0
closing tables  | 0.000011 | 0.000008 | 0.000002   | 0            | 0

分析结论：
- CPU使用：用户态95ms，系统态28ms，CPU密集型操作
- IO操作：读取了2048个块，约16MB数据（假设每块8KB）
- 优化方向：考虑添加索引减少数据扫描量
```

**查看内存使用情况**：
```sql
-- 查看内存分配详情（MySQL 8.0+）
SHOW PROFILE MEMORY FOR QUERY 1;

-- 内存使用分析可以发现：
-- - 临时表内存分配
-- - 排序缓冲区使用  
-- - 连接缓冲区分配
```

---

## 5. 🎯 执行计划深度分析


### 5.1 EXPLAIN输出深度解读


**type字段性能排序**（从好到坏）：
```
性能等级：
🟢 system/const    ← 最优：常量级别，如主键=常量
🟢 eq_ref         ← 优秀：唯一索引查找，如主键JOIN  
🟡 ref            ← 良好：非唯一索引查找
🟡 range          ← 一般：索引范围扫描，如age > 18
🟠 index          ← 较差：索引全扫描
🔴 ALL            ← 最差：全表扫描

实际案例：
type=const: SELECT * FROM users WHERE id = 123;  (主键查找)
type=ref:   SELECT * FROM users WHERE status = 'active';  (普通索引)
type=range: SELECT * FROM users WHERE age BETWEEN 18 AND 65;
type=ALL:   SELECT * FROM users WHERE UPPER(name) = 'ALICE';  (函数导致全表扫描)
```

### 5.2 Extra字段重点分析


**🔥 需要重点关注的Extra信息**：

```sql
-- Using filesort：需要额外排序
SELECT * FROM users ORDER BY name;  -- 如果name没有索引
Extra: Using filesort

优化方案：
✓ 在name字段上创建索引
✓ 或者调整ORDER BY字段为已有索引字段
```

```sql  
-- Using temporary：使用临时表
SELECT dept_id, COUNT(*) FROM users GROUP BY dept_id, status;
Extra: Using temporary

原因分析：
- GROUP BY的字段组合没有对应的联合索引
- MySQL需要创建临时表来完成分组

优化方案：  
✓ 创建联合索引：(dept_id, status)
✓ 或者拆分查询，避免复杂分组
```

```sql
-- Using where：WHERE条件在存储引擎层无法完全处理
SELECT * FROM users WHERE age > 18 AND UPPER(name) = 'ALICE';
Extra: Using where

原因分析：
- age > 18 可以在索引层过滤
- UPPER(name) = 'ALICE' 需要在MySQL层额外过滤

优化方案：
✓ 避免在WHERE中使用函数
✓ 或者创建函数索引（MySQL 8.0+）
```

### 5.3 rows字段准确性分析


**rows字段的含义**：MySQL优化器估算需要检查的行数，不一定等于实际扫描行数。

```sql
-- 对比估算值与实际值
EXPLAIN SELECT * FROM users WHERE age > 18;
-- rows: 5000 (优化器估算)

EXPLAIN ANALYZE SELECT * FROM users WHERE age > 18;  -- MySQL 8.0+
-- actual rows=4850 (实际扫描行数)

估算准确性分析：
估算5000行，实际4850行 → 估算相对准确
估算1000行，实际50000行 → 估算严重偏差，需要更新统计信息
```

---

## 6. 🖥️ 资源消耗监控详解


### 6.1 CPU使用分析


**CPU消耗的主要来源**：
- **查询解析和优化**：复杂SQL的解析和计划生成
- **数据处理**：JOIN、GROUP BY、ORDER BY等操作
- **函数计算**：字符串函数、数学函数、日期函数
- **数据转换**：字符集转换、类型转换

**监控CPU使用**：
```sql
-- 查看高CPU消耗的SQL
SELECT 
    DIGEST_TEXT,
    COUNT_STAR as exec_count,
    SUM_TIMER_WAIT/1000000000 as total_time,
    (SUM_TIMER_WAIT/COUNT_STAR)/1000000000 as avg_time,
    ROUND(SUM_TIMER_WAIT*100/
          (SELECT SUM(SUM_TIMER_WAIT) 
           FROM performance_schema.events_statements_summary_by_digest), 2) as cpu_pct
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
```

**CPU优化策略**：
```
高CPU消耗优化：
├─ 函数优化：避免在WHERE中使用复杂函数
├─ 查询简化：拆分复杂的多表JOIN
├─ 索引优化：减少不必要的数据扫描
└─ 硬件升级：增加CPU核心数，提升主频
```

### 6.2 内存消耗分析


**内存使用的主要区域**：
```
MySQL内存使用分布：
┌─────────────────────────────────────┐
│ InnoDB Buffer Pool (70%)            │ ← 数据页缓存
├─────────────────────────────────────┤
│ 查询缓存 (10%)                      │ ← 查询结果缓存  
├─────────────────────────────────────┤
│ 临时表空间 (8%)                     │ ← GROUP BY、ORDER BY使用
├─────────────────────────────────────┤
│ 连接缓冲区 (5%)                     │ ← 每个连接分配的内存
├─────────────────────────────────────┤
│ 排序缓冲区 (4%)                     │ ← ORDER BY使用
├─────────────────────────────────────┤  
│ 其他 (3%)                          │ ← 索引缓存等
└─────────────────────────────────────┘
```

**内存使用监控**：
```sql
-- 查看内存分配情况（MySQL 8.0+）
SELECT 
    EVENT_NAME,
    CURRENT_COUNT_USED as current_alloc,
    HIGH_COUNT_USED as peak_alloc,
    SUM_NUMBER_OF_BYTES_ALLOC/1024/1024 as total_mb_allocated
FROM performance_schema.memory_summary_global_by_event_name 
WHERE CURRENT_COUNT_USED > 0 
ORDER BY SUM_NUMBER_OF_BYTES_ALLOC DESC LIMIT 10;
```

### 6.3 IO模式分析


**IO操作类型分析**：
```
IO操作分类：
├─ 顺序读取：全表扫描、索引扫描
├─ 随机读取：根据主键或唯一索引查找
├─ 顺序写入：批量INSERT、日志写入
└─ 随机写入：随机UPDATE、DELETE操作

性能特点：
顺序IO > 随机IO (速度差可达10-100倍)
内存IO > SSD IO > 机械盘IO
```

**IO热点分析**：
```sql
-- 查看IO最频繁的文件
SELECT 
    file,
    count_read,
    count_write, 
    sum_timer_read/1000000000 as read_latency_sec,
    sum_timer_write/1000000000 as write_latency_sec
FROM performance_schema.file_summary_by_instance 
WHERE file LIKE '%.ibd'
ORDER BY sum_timer_read + sum_timer_write DESC LIMIT 10;

-- 分析结果可以发现：
-- 哪些表的IO最频繁
-- 读写比例是否合理  
-- 是否存在IO热点集中的问题
```

---

## 7. ⏰ 等待事件分析


### 7.1 等待事件的分类


**什么是等待事件**：MySQL执行过程中，线程不能立即获得所需资源时的等待情况。

```
等待事件层次结构：
wait/io/          ← IO相关等待
├─ file/          ← 文件IO等待
│  ├─ innodb/     ← InnoDB文件操作
│  └─ myisam/     ← MyISAM文件操作
├─ socket/        ← 网络Socket等待
└─ table/         ← 表级锁等待

wait/synch/       ← 同步等待
├─ mutex/         ← 互斥锁等待
├─ rwlock/        ← 读写锁等待  
└─ cond/          ← 条件变量等待

wait/lock/        ← 显式锁等待
├─ table/         ← 表锁等待
└─ metadata/      ← 元数据锁等待
```

### 7.2 常见等待事件详解


**🔥 IO等待事件分析**：
```sql
-- 查看IO等待详情
SELECT 
    EVENT_NAME,
    COUNT_STAR as wait_count,
    SUM_TIMER_WAIT/1000000000 as total_wait_sec,
    AVG_TIMER_WAIT/1000000000 as avg_wait_sec,
    MAX_TIMER_WAIT/1000000000 as max_wait_sec
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE 'wait/io/file%'
ORDER BY SUM_TIMER_WAIT DESC LIMIT 5;
```

**等待事件含义解释**：
```
wait/io/file/innodb/innodb_data_file：
├─ 含义：等待读写InnoDB数据文件
├─ 常见原因：缓存命中率低，需要频繁读盘
└─ 优化方向：增大innodb_buffer_pool_size

wait/io/file/innodb/innodb_log_file：
├─ 含义：等待写入事务日志文件
├─ 常见原因：大事务，频繁写操作
└─ 优化方向：优化事务大小，使用SSD存储日志

wait/io/file/sql/binlog：
├─ 含义：等待写入二进制日志
├─ 常见原因：binlog刷盘策略过于保守
└─ 优化方向：调整sync_binlog参数，使用异步复制
```

### 7.3 锁等待事件分析


**锁等待的监控**：
```sql
-- 查看锁等待情况
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,  
    LOCK_TYPE,
    LOCK_STATUS,
    THREAD_ID,
    SQL_TEXT
FROM performance_schema.data_locks dl
JOIN performance_schema.threads t ON dl.THREAD_ID = t.THREAD_ID  
WHERE LOCK_STATUS = 'WAITING';

-- 分析锁等待的原因：
-- 哪个表被锁住了
-- 什么类型的锁（表锁、行锁）
-- 哪个SQL语句在等待
```

**死锁检测与分析**：
```sql
-- 查看最近的死锁信息
SHOW ENGINE INNODB STATUS;

-- 在输出中查找LATEST DETECTED DEADLOCK部分：
TRANSACTION 421394612, ACTIVE 0 sec starting index read
TRANSACTION 421394613, ACTIVE 0 sec starting index read  

WE ROLL BACK TRANSACTION (2)
-- MySQL自动回滚了事务2来解决死锁
```

---

## 8. 🔧 性能问题诊断技巧


### 8.1 性能瓶颈定位方法


**🎯 系统化诊断流程**：

```
性能问题诊断检查单：

□ 第一步：确认问题范围
  ├─ 是单个SQL慢，还是整体系统慢？
  ├─ 是偶发性慢，还是持续性慢？
  └─ 慢的程度如何？（几百ms还是几秒？）

□ 第二步：收集基础信息
  ├─ 查看SHOW PROCESSLIST当前运行情况
  ├─ 检查SHOW ENGINE INNODB STATUS
  └─ 收集系统资源使用情况（CPU、内存、IO）

□ 第三步：分析具体SQL
  ├─ 使用EXPLAIN分析执行计划
  ├─ 使用SHOW PROFILE分析执行耗时
  └─ 检查相关表的索引和统计信息

□ 第四步：定位瓶颈类型
  ├─ IO瓶颈：大量磁盘读写
  ├─ CPU瓶颈：复杂计算、函数调用
  ├─ 锁瓶颈：等待锁资源
  └─ 网络瓶颈：大结果集传输
```

### 8.2 常见性能问题模式


**🔍 问题模式识别**：

**模式1：索引缺失导致全表扫描**
```sql
-- 问题SQL
SELECT * FROM orders WHERE order_date = '2025-09-01';

-- 执行计划特征：
-- type: ALL  
-- rows: 500000 (全表行数)
-- Extra: Using where

-- 解决方案：
CREATE INDEX idx_order_date ON orders(order_date);

-- 优化后执行计划：
-- type: ref
-- rows: 150 (大幅减少)
-- Extra: Using index condition
```

**模式2：不当的JOIN顺序**
```sql
-- 问题SQL：大表驱动小表
SELECT u.name, d.dept_name  
FROM users u                    -- 100万行
JOIN departments d ON u.dept_id = d.id;  -- 10行

-- 问题执行计划：
-- users表先执行，departments表被驱动
-- 扫描100万行，每行都要查找departments

-- 优化方案：
-- 使用STRAIGHT_JOIN强制JOIN顺序
SELECT u.name, d.dept_name
FROM departments d               -- 小表驱动  
STRAIGHT_JOIN users u ON d.id = u.dept_id;
```

**模式3：不必要的排序操作**
```sql
-- 问题SQL
SELECT * FROM users 
WHERE status = 'active'
ORDER BY created_time DESC
LIMIT 10;

-- 如果索引是(status, id)，缺少created_time
-- Extra: Using filesort

-- 优化方案：
-- 创建包含排序字段的索引
CREATE INDEX idx_status_created ON users(status, created_time);
```

### 8.3 Performance Schema诊断技巧


**🔥 快速定位慢查询**：
```sql
-- 一键查看当前最慢的查询
SELECT 
    digest_text as sql_pattern,
    count_star as exec_count,
    avg_timer_wait/1000000000 as avg_time_sec,
    sum_timer_wait/1000000000 as total_time_sec,
    sum_rows_examined/count_star as avg_rows_examined,
    sum_rows_sent/count_star as avg_rows_returned,
    ROUND(sum_rows_examined/sum_rows_sent, 2) as examine_return_ratio
FROM performance_schema.events_statements_summary_by_digest 
WHERE schema_name IS NOT NULL
  AND digest_text NOT LIKE '%performance_schema%'
ORDER BY avg_timer_wait DESC LIMIT 10;
```

**结果分析示例**：
```
sql_pattern                  | avg_time_sec | avg_rows_examined | examine_return_ratio
----------------------------|--------------|-------------------|---------------------
SELECT * FROM users WHERE..| 2.45         | 50000             | 100.0
UPDATE users SET status...  | 1.23         | 1                 | 0.0  
SELECT COUNT(*) FROM...     | 0.85         | 100000            | 0.001

分析结论：
🚨 第一个SQL：examine_return_ratio=100说明扫描效率极低
⚠️ 第三个SQL：扫描10万行只返回1个结果，需要优化
✅ 第二个SQL：UPDATE精确命中，效率良好
```

---

## 9. 📋 查询性能分析系统方法


### 9.1 建立性能分析流程


**🔧 标准化分析流程**：
```
第一阶段：问题发现（主动监控）
├─ 慢查询日志监控：long_query_time阈值设置
├─ 实时性能监控：QPS、TPS、响应时间
├─ 资源使用监控：CPU、内存、IO、网络
└─ 用户体验监控：页面加载时间、错误率

第二阶段：问题定位（深入分析）  
├─ EXPLAIN分析：执行计划评估
├─ SHOW PROFILE分析：详细耗时分解
├─ Performance Schema分析：资源等待详情
└─ sys库分析：汇总统计信息

第三阶段：问题解决（优化实施）
├─ 索引优化：创建、删除、修改索引
├─ SQL重写：查询逻辑优化  
├─ 参数调优：MySQL配置优化
└─ 架构调整：分库分表、读写分离

第四阶段：效果验证（持续监控）
├─ A/B测试：对比优化前后效果
├─ 压力测试：验证高并发下的表现
├─ 长期监控：建立性能基线和告警
└─ 文档记录：记录优化过程和效果
```

### 9.2 性能分析工具箱


**🛠️ 必备工具清单**：

**1. 内置分析工具**
```sql
-- 基础分析工具
EXPLAIN / EXPLAIN ANALYZE    -- 执行计划分析
SHOW PROFILE                 -- 详细耗时分析  
SHOW PROCESSLIST            -- 当前活动线程
SHOW ENGINE INNODB STATUS   -- InnoDB引擎状态

-- 统计信息工具
SHOW TABLE STATUS           -- 表统计信息
SHOW INDEX FROM table_name  -- 索引统计信息
ANALYZE TABLE table_name    -- 更新统计信息
```

**2. Performance Schema核心查询**
```sql
-- 最耗时SQL TOP 10
SELECT query, exec_count, avg_latency, total_latency 
FROM sys.statement_analysis 
ORDER BY total_latency DESC LIMIT 10;

-- 未使用的索引
SELECT * FROM sys.schema_unused_indexes;

-- 冗余索引  
SELECT * FROM sys.schema_redundant_indexes;

-- IO等待热点
SELECT * FROM sys.io_global_by_file_by_latency LIMIT 10;
```

**3. 第三方工具推荐**
```bash
# pt-query-digest：慢查询日志分析
pt-query-digest /var/log/mysql/slow.log

# mysqldumpslow：MySQL自带的慢查询分析
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# pt-online-schema-change：在线DDL工具
pt-online-schema-change --alter "ADD INDEX idx_age(age)" D=mydb,t=users

# mysqltuner：MySQL配置优化建议
wget mysqltuner.pl
perl mysqltuner.pl
```

### 9.3 性能基线建立


**建立性能基线的重要性**：知道正常情况下的性能表现，才能识别异常。

```
性能基线指标：
┌─────────────────────────────────────┐
│ 查询性能基线：                       │
│ ├─ 平均查询耗时：50ms              │
│ ├─ 95%查询耗时：200ms              │  
│ ├─ 99%查询耗时：500ms              │
│ └─ 慢查询比例：< 1%                │
├─────────────────────────────────────┤
│ 系统资源基线：                       │
│ ├─ CPU使用率：< 70%                │
│ ├─ 内存使用率：< 80%               │
│ ├─ IO等待时间：< 10%               │
│ └─ 网络带宽：< 50%                 │
├─────────────────────────────────────┤
│ 数据库指标基线：                     │
│ ├─ QPS：1000 queries/sec          │
│ ├─ TPS：200 transactions/sec      │
│ ├─ 连接数：< 100                   │
│ └─ 缓存命中率：> 95%               │
└─────────────────────────────────────┘
```

**基线数据收集方法**：
```sql
-- 定期收集性能数据
CREATE TABLE performance_baseline (
    collect_time DATETIME,
    avg_query_time DECIMAL(10,6),
    slow_query_count INT,
    qps DECIMAL(10,2),
    buffer_pool_hit_rate DECIMAL(5,2),
    cpu_usage DECIMAL(5,2),
    io_wait_pct DECIMAL(5,2)
);

-- 每小时收集一次数据
INSERT INTO performance_baseline 
SELECT 
    NOW() as collect_time,
    (SELECT AVG(avg_timer_wait)/1000000000 
     FROM performance_schema.events_statements_summary_by_digest) as avg_query_time,
    (SELECT COUNT(*) FROM mysql.slow_log 
     WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)) as slow_query_count,
    -- ... 其他指标
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 性能分析工具：Performance Schema、sys库、SHOW PROFILES三大法宝
🔸 执行计划分析：type、rows、Extra是关键，能看出99%的问题
🔸 等待事件分析：知道SQL等待在哪里，才能对症下药
🔸 资源消耗监控：CPU、内存、IO三大资源的监控和分析
🔸 诊断技巧：从问题现象到根本原因的分析方法
🔸 系统方法：建立完整的性能分析和优化流程
```

### 10.2 关键理解要点


**🔹 性能分析的本质**
```
理解要点：
- 性能分析就是找瓶颈：木桶最短的那块板
- 数据说话：用监控数据，不要凭感觉
- 系统思维：不能头痛医头，要看整体
```

**🔹 工具使用的层次**
```
工具使用递进：
新手阶段 → EXPLAIN看执行计划，发现明显问题
进阶阶段 → SHOW PROFILE分析详细耗时，精确定位
高级阶段 → Performance Schema全面监控，系统分析
专家阶段 → 结合源码理解，自建监控体系
```

**🔹 优化的优先级**
```
优化ROI排序：
高回报 → 索引优化：立竿见影，成本低
中回报 → SQL改写：需要开发配合，风险中等  
低回报 → 参数调优：效果有限，需要重启
高风险 → 架构调整：效果显著，但复杂度高
```

### 10.3 实际应用价值


**🎯 日常运维实践**：
- **监控体系建设**：基于Performance Schema建立完整监控
- **慢查询治理**：定期分析慢查询日志，持续优化
- **容量规划**：基于性能趋势预测资源需求
- **故障快速定位**：在性能问题发生时快速找到根因

**🔍 开发阶段应用**：
- **SQL Review**：开发阶段就用EXPLAIN检查SQL性能
- **压测验证**：上线前进行性能测试和分析
- **性能回归**：版本发布后对比性能基线
- **代码优化**：基于分析结果指导代码优化

**🏗️ 架构设计指导**：
- **数据库选型**：基于性能特点选择存储引擎
- **分片策略**：基于访问模式设计分库分表
- **缓存设计**：结合查询特点设计缓存策略
- **读写分离**：基于读写比例和延迟要求设计架构

### 10.4 学习进阶路径


**🔸 实践建议**：
- **搭建测试环境**：用测试数据反复练习分析技巧
- **模拟性能问题**：人为制造问题，练习诊断流程
- **建立知识库**：记录常见问题和解决方案
- **参与社区**：关注MySQL官方博客和技术社区

**🔸 深入学习方向**：
- **MySQL源码**：理解优化器和存储引擎实现原理
- **操作系统原理**：理解IO、内存、CPU调度机制
- **硬件知识**：了解不同存储介质的性能特点
- **监控系统**：学习Prometheus、Grafana等监控工具

**核心记忆要点**：
```
性能分析有方法，工具使用要得当
Profile看耗时，Schema查等待
执行计划是基础，资源监控不能少
系统分析找瓶颈，对症下药效果好
建立基线做对比，持续优化是王道
```

> 💡 **最重要的提醒**：性能分析不是一次性工作，而是一个持续的过程。建立完善的监控体系，定期进行性能review，才能保证数据库系统的长期稳定高效运行。