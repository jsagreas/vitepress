---
title: 4、执行计划控制技术
---
## 📚 目录

1. [执行计划控制基础概念](#1-执行计划控制基础概念)
2. [执行计划稳定性问题](#2-执行计划稳定性问题)
3. [优化器提示控制技术](#3-优化器提示控制技术)
4. [执行计划绑定技术](#4-执行计划绑定技术)
5. [统计信息控制策略](#5-统计信息控制策略)
6. [优化器Trace跟踪分析](#6-优化器trace跟踪分析)
7. [计划缓存管理机制](#7-计划缓存管理机制)
8. [查询稳定性保障方法](#8-查询稳定性保障方法)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 执行计划控制基础概念


### 1.1 什么是执行计划控制


**🔸 执行计划控制的本质**
```
简单理解：让MySQL按照我们希望的方式执行SQL查询

为什么需要控制：
├── MySQL优化器有时选择不是最优的执行计划
├── 业务场景变化，原来的执行计划不再适用
├── 数据分布变化，统计信息过时导致计划错误
└── 需要在特定场景下强制使用特定执行方式
```

**🔸 执行计划控制的目标**
- **稳定性**：确保关键查询的执行计划不会随意变化
- **可预测性**：知道查询会如何执行，性能表现如何
- **可控性**：在必要时能够干预优化器的选择

### 1.2 执行计划产生过程


**🔸 MySQL查询执行流程**
```
SQL查询
   ↓
解析器(Parser)     ← 检查语法，生成解析树
   ↓
优化器(Optimizer)  ← 生成多种执行计划，选择最优
   ↓
执行器(Executor)   ← 按照计划执行查询
   ↓
返回结果
```

**🔸 优化器工作原理**
```
优化器的任务：
1. 分析所有可能的执行路径
2. 估算每种路径的成本
3. 选择成本最低的执行计划

成本估算依据：
├── 表的行数统计
├── 索引的选择性统计  
├── 数据分布统计
└── 系统配置参数
```

---

## 2. ⚠️ 执行计划稳定性问题


### 2.1 执行计划不稳定的原因


**🔸 常见导致计划变化的因素**
```
1. 统计信息变化
   ├── 数据量增长改变了表统计信息
   ├── 数据分布变化影响索引选择性
   └── ANALYZE TABLE更新统计信息

2. MySQL版本升级
   ├── 优化器算法改进
   ├── 成本模型调整
   └── 新功能影响计划选择

3. 配置参数变化
   ├── innodb_buffer_pool_size调整
   ├── join_buffer_size修改
   └── optimizer_switch设置改变

4. 硬件环境变化
   ├── CPU性能变化
   ├── 内存大小调整
   └── 存储设备性能差异
```

### 2.2 计划不稳定带来的问题


**🔸 实际业务影响**
```
性能波动：
├── 原本1秒的查询突然变成10秒
├── 高峰期执行计划突然改变
└── 影响用户体验和系统稳定性

运维困难：
├── 性能问题难以预测和重现
├── 优化效果不稳定
└── 监控告警频繁触发

业务风险：
├── 关键业务查询性能下降
├── 可能导致系统雪崩
└── 影响企业服务质量
```

### 2.3 计划不稳定案例分析


**🔸 典型案例：索引选择变化**
```sql
-- 查询语句
SELECT * FROM orders 
WHERE status = 'PENDING' 
  AND create_time > '2024-01-01';

-- 原执行计划：使用status索引
-- 新执行计划：使用create_time索引  
-- 结果：性能从1秒变成20秒
```

**问题分析**：
- 数据增长后，`status='PENDING'` 的数据变多
- 优化器重新评估认为 `create_time` 索引更优
- 实际执行时发现选择错误，但已经固化

---

## 3. 🎛️ 优化器提示控制技术


### 3.1 MySQL Hint基本语法


**🔸 Hint语法格式**
```sql
-- 基本格式
SELECT /*+ HINT_NAME(参数) */ column_list FROM table_name;

-- 多个提示
SELECT /*+ USE_INDEX(table_name idx_name) 
           FORCE_INDEX(table_name idx_name2) */ 
FROM table_name;
```

### 3.2 索引控制Hint


**🔸 索引选择提示**
```sql
-- 强制使用指定索引
SELECT /*+ USE_INDEX(orders idx_status) */ *
FROM orders 
WHERE status = 'PENDING';

-- 忽略指定索引
SELECT /*+ IGNORE_INDEX(orders idx_create_time) */ *
FROM orders 
WHERE status = 'PENDING' AND create_time > '2024-01-01';

-- 强制使用索引（比USE_INDEX更强制）
SELECT /*+ FORCE_INDEX(orders idx_status) */ *
FROM orders 
WHERE status = 'PENDING';
```

**提示类型对比**：

| **Hint类型** | **强制程度** | **使用场景** |
|-------------|-------------|-------------|
| **USE_INDEX** | 建议使用 | 优化器参考，可能忽略 |
| **FORCE_INDEX** | 强制使用 | 必须使用指定索引 |
| **IGNORE_INDEX** | 忽略索引 | 排除错误的索引选择 |

### 3.3 连接算法控制Hint


**🔸 JOIN算法提示**
```sql
-- 强制使用Hash Join
SELECT /*+ HASH_JOIN(o, c) */ 
o.order_id, c.customer_name
FROM orders o 
JOIN customers c ON o.customer_id = c.customer_id;

-- 强制使用Nested Loop Join  
SELECT /*+ NO_HASH_JOIN(o, c) */ 
o.order_id, c.customer_name
FROM orders o 
JOIN customers c ON o.customer_id = c.customer_id;

-- 控制JOIN顺序
SELECT /*+ STRAIGHT_JOIN */ 
o.order_id, c.customer_name
FROM orders o 
JOIN customers c ON o.customer_id = c.customer_id;
```

### 3.4 优化器开关控制


**🔸 optimizer_switch参数**
```sql
-- 查看当前优化器开关设置
SHOW VARIABLES LIKE 'optimizer_switch';

-- 临时修改优化器行为
SET SESSION optimizer_switch = 'index_merge=off';

-- 在查询中临时设置
SELECT /*+ SET_VAR(optimizer_switch = 'mrr=off') */ *
FROM large_table 
WHERE range_column BETWEEN 1000 AND 2000;
```

**常用开关选项**：
```
index_merge：是否使用索引合并
mrr：是否使用多范围读优化  
batched_key_access：批量键访问优化
block_nested_loop：块嵌套循环连接
```

---

## 4. 🔗 执行计划绑定技术


### 4.1 执行计划绑定概念


**🔸 什么是Plan Binding**
```
定义：将特定的SQL查询与固定的执行计划绑定
目的：确保关键查询始终使用稳定的执行计划
实现：通过存储执行计划，强制优化器使用

绑定流程：
SQL查询 → 检查是否有绑定计划 → 使用绑定计划 / 生成新计划
```

### 4.2 MySQL中的计划固定方法


**🔸 使用Hint固定计划**
```sql
-- 方法1：创建视图固定执行计划
CREATE VIEW stable_orders AS
SELECT /*+ USE_INDEX(orders idx_status_time) */ 
  order_id, customer_id, status, create_time
FROM orders 
WHERE status = 'PENDING' 
  AND create_time > DATE_SUB(NOW(), INTERVAL 1 DAY);

-- 应用使用视图而不是直接查询表
SELECT * FROM stable_orders;
```

**🔸 使用存储过程固定计划**
```sql
-- 方法2：存储过程封装查询
DELIMITER //
CREATE PROCEDURE GetPendingOrders()
BEGIN
  SELECT /*+ USE_INDEX(orders idx_status_time) */ 
    order_id, customer_id, status, create_time
  FROM orders 
  WHERE status = 'PENDING' 
    AND create_time > DATE_SUB(NOW(), INTERVAL 1 DAY);
END//
DELIMITER ;

-- 调用存储过程
CALL GetPendingOrders();
```

### 4.3 第三方计划绑定工具


**🔸 ProxySQL计划控制**
```sql
-- 在ProxySQL中配置查询规则
INSERT INTO mysql_query_rules (
  match_pattern, 
  replace_pattern, 
  active
) VALUES (
  '^SELECT \* FROM orders WHERE status.*',
  'SELECT /*+ USE_INDEX(orders idx_status) */ * FROM orders WHERE status\1',
  1
);

-- 重新加载规则
LOAD MYSQL QUERY RULES TO RUNTIME;
```

---

## 5. 📊 统计信息控制策略


### 5.1 统计信息对执行计划的影响


**🔸 统计信息的作用**
```
优化器决策依据：
├── 表行数：决定是否使用索引
├── 索引唯一值数量：影响索引选择性评估
├── 数据分布：影响范围查询的成本估算
└── NULL值比例：影响查询成本计算

统计信息 → 成本估算 → 执行计划选择
```

### 5.2 手动控制统计信息


**🔸 更新统计信息**
```sql
-- 更新表统计信息
ANALYZE TABLE orders;

-- 查看统计信息
SELECT 
  table_name,
  table_rows,
  avg_row_length,
  data_length
FROM information_schema.tables 
WHERE table_name = 'orders';

-- 查看索引统计信息
SHOW INDEX FROM orders;
```

**🔸 统计信息采样控制**
```sql
-- 设置统计信息采样页数
SET GLOBAL innodb_stats_sample_pages = 20;

-- 控制统计信息持久化
SET GLOBAL innodb_stats_persistent = ON;

-- 设置统计信息自动更新阈值
SET GLOBAL innodb_stats_auto_recalc = ON;
```

### 5.3 锁定统计信息策略


**🔸 防止统计信息变化**
```sql
-- 关闭自动统计信息更新
ALTER TABLE orders STATS_AUTO_RECALC=0;

-- 手动设置表行数统计
-- 注意：这是估算值，用于优化器成本计算
SET SESSION information_schema_stats_expiry = 0;

-- 定期手动更新（在业务低峰期）
-- 建议在凌晨执行
ANALYZE TABLE orders;
```

---

## 6. 🔍 优化器Trace跟踪分析


### 6.1 什么是优化器Trace


**🔸 Trace功能说明**
```
定义：MySQL提供的优化器决策过程跟踪工具
作用：详细记录优化器如何选择执行计划
用途：深入分析为什么优化器做出某个决策
```

### 6.2 启用Trace跟踪


**🔸 开启Trace功能**
```sql
-- 开启优化器跟踪
SET optimizer_trace = "enabled=on";

-- 设置跟踪内存大小（默认16KB）
SET optimizer_trace_max_mem_size = 1048576; -- 1MB

-- 执行需要分析的查询
SELECT * FROM orders 
WHERE status = 'PENDING' 
  AND create_time > '2024-01-01';

-- 查看跟踪结果
SELECT trace FROM information_schema.optimizer_trace;

-- 关闭跟踪
SET optimizer_trace = "enabled=off";
```

### 6.3 Trace结果分析


**🔸 Trace输出结构**
```json
{
  "steps": [
    {
      "join_preparation": {
        "select_id": 1,
        "steps": [
          {
            "expanded_query": "SELECT * FROM orders WHERE..."
          }
        ]
      }
    },
    {
      "join_optimization": {
        "select_id": 1,
        "steps": [
          {
            "table_dependencies": [
              {
                "table": "orders",
                "row_may_be_null": false
              }
            ]
          },
          {
            "rows_estimation": [
              {
                "table": "orders",
                "range_analysis": {
                  "table_scan": {
                    "rows": 100000,
                    "cost": 20500
                  },
                  "potential_range_indexes": [
                    {
                      "index": "idx_status",
                      "usable": true,
                      "ranges": ["PENDING"],
                      "rows": 15000,
                      "cost": 18000
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    }
  ]
}
```

**🔍 关键信息解读**
- **table_scan.cost**：全表扫描成本
- **potential_range_indexes**：可能使用的索引
- **rows**：预估扫描行数
- **cost**：估算执行成本

---

## 7. 🗄️ 计划缓存管理机制


### 7.1 MySQL查询缓存机制


**🔸 计划缓存的概念**
```
什么是计划缓存：
MySQL会缓存解析后的SQL语句和执行计划
目的：避免重复解析和优化相同的查询
位置：存储在query_cache中（MySQL 5.7及以前）

注意：MySQL 8.0已移除查询缓存功能
```

### 7.2 预处理语句缓存


**🔸 Prepared Statement计划缓存**
```sql
-- 预处理语句会缓存执行计划
PREPARE stmt FROM 'SELECT * FROM orders WHERE status = ?';

-- 第一次执行：生成并缓存执行计划
SET @status = 'PENDING';
EXECUTE stmt USING @status;

-- 后续执行：直接使用缓存的执行计划
SET @status = 'COMPLETED';  
EXECUTE stmt USING @status;  -- 可能使用不适合的计划

-- 释放预处理语句
DEALLOCATE PREPARE stmt;
```

### 7.3 计划缓存管理策略


**🔸 缓存失效策略**
```sql
-- 查看预处理语句缓存状态
SHOW STATUS LIKE 'Com_stmt%';

-- 手动清理缓存（重启连接）
-- 或者定期重建预处理语句

-- 监控缓存命中率
SHOW STATUS LIKE 'Qcache%';
```

---

## 8. 🛡️ 查询稳定性保障方法


### 8.1 综合稳定性策略


**🔸 多层次保障体系**
```
策略层次：
┌─────────────────┐
│  应用层控制      │ ← 使用Hint、视图等
├─────────────────┤
│  中间件控制      │ ← ProxySQL规则
├─────────────────┤  
│  数据库层控制    │ ← 统计信息、参数
├─────────────────┤
│  监控层保障      │ ← 性能监控告警
└─────────────────┘
```

### 8.2 关键查询保护策略


**🔸 核心业务查询固定**
```sql
-- 方案1：使用强制Hint
SELECT /*+ FORCE_INDEX(orders idx_status_time) */ 
  COUNT(*) 
FROM orders 
WHERE status = 'PENDING' 
  AND create_time > DATE_SUB(NOW(), INTERVAL 1 HOUR);

-- 方案2：创建专用索引
CREATE INDEX idx_critical_query 
ON orders(status, create_time, order_id);

-- 方案3：分离关键查询到专用只读库
-- 在只读库上固定统计信息和配置
```

### 8.3 执行计划监控与告警


**🔸 计划变化监控脚本**
```sql
-- 创建执行计划监控表
CREATE TABLE query_plan_monitor (
  query_hash VARCHAR(64),
  query_text TEXT,
  execution_plan TEXT,
  execution_time DECIMAL(10,3),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_hash_time(query_hash, created_at)
);

-- 记录关键查询的执行计划
-- 通过定时任务检查计划是否发生变化
```

### 8.4 应急处理预案


**🔸 执行计划异常应急处理**
```
发现执行计划变差：

步骤1：立即使用Hint强制原计划
├── 在应用中添加USE_INDEX提示
└── 或通过ProxySQL重写查询

步骤2：分析变化原因
├── 检查统计信息是否变化
├── 检查MySQL配置是否调整
└── 分析数据分布是否改变

步骤3：制定长期解决方案
├── 固定统计信息
├── 优化索引设计
└── 调整优化器参数

步骤4：验证和监控
├── 在测试环境验证方案
├── 生产环境逐步实施
└── 持续监控性能表现
```

---

## 9. 📊 成本模型调整技术


### 9.1 MySQL成本模型基础


**🔸 成本模型组成**
```
MySQL优化器成本计算：

总成本 = IO成本 + CPU成本

IO成本：
├── 读取数据页的成本
├── 索引页访问成本  
└── 临时表IO成本

CPU成本：
├── 行比较成本
├── 条件评估成本
└── 结果处理成本
```

### 9.2 成本常数调整


**🔸 查看和调整成本常数**
```sql
-- 查看当前成本常数
SELECT * FROM mysql.server_cost;
SELECT * FROM mysql.engine_cost;

-- 调整行评估成本
UPDATE mysql.server_cost 
SET cost_value = 0.1 
WHERE cost_name = 'row_evaluate_cost';

-- 调整键比较成本
UPDATE mysql.server_cost
SET cost_value = 0.05  
WHERE cost_name = 'key_compare_cost';

-- 使配置生效
FLUSH OPTIMIZER_COSTS;
```

### 9.3 针对性成本调整策略


**🔸 根据硬件特性调整**
```sql
-- SSD存储环境：降低IO成本权重
UPDATE mysql.engine_cost 
SET cost_value = 0.5 
WHERE engine_name = 'InnoDB' 
  AND device_type = 0 
  AND cost_name = 'io_block_read_cost';

-- 高性能CPU：降低CPU成本权重  
UPDATE mysql.server_cost
SET cost_value = 0.05
WHERE cost_name = 'row_evaluate_cost';
```

---

## 10. 📋 核心要点总结


### 10.1 执行计划控制方法总览


| **控制方法** | **适用场景** | **实施难度** | **稳定性** |
|-------------|-------------|-------------|-----------|
| **🎯 Hint提示** | 临时修复 | ⭐ 简单 | ⭐⭐ 中等 |
| **📋 视图封装** | 长期稳定 | ⭐⭐ 中等 | ⭐⭐⭐ 高 |
| **🔧 统计信息固定** | 防止变化 | ⭐⭐⭐ 复杂 | ⭐⭐⭐⭐ 很高 |
| **🌐 中间件控制** | 全局管理 | ⭐⭐⭐⭐ 复杂 | ⭐⭐⭐⭐⭐ 极高 |

### 10.2 实施建议优先级


**🔸 执行计划控制实施路径**
```
阶段1：识别关键查询
├── 找出核心业务查询
├── 分析执行计划稳定性
└── 评估性能影响程度

阶段2：应急保护
├── 对不稳定查询添加Hint
├── 创建关键查询的视图
└── 设置性能监控告警

阶段3：系统性优化  
├── 固定核心查询的统计信息
├── 调整优化器参数
└── 建立执行计划变化监控

阶段4：高级控制
├── 部署ProxySQL等中间件
├── 实施自动化监控和修复
└── 建立完整的计划管理体系
```

### 10.3 最佳实践建议


**🔸 日常运维建议**
```
✅ 做什么：
├── 定期监控关键查询的执行计划
├── 在业务低峰期更新统计信息
├── 为核心查询编写稳定性测试
├── 建立执行计划变化的告警机制
└── 做好执行计划变化的应急预案

❌ 避免什么：
├── 过度使用Hint（影响代码可读性）
├── 忽略统计信息的定期维护
├── 在生产环境随意调整成本参数
├── 没有监控就盲目固定执行计划
└── 一刀切的固定所有查询的执行计划
```

**🔸 核心要点记忆**
```
🧠 执行计划控制核心理念：
"稳定胜过最优" - 可预测的稳定性能比偶尔的最优性能更重要

控制方法选择：
简单查询 → Hint提示
复杂查询 → 视图封装  
关键查询 → 统计信息固定
全局管理 → 中间件控制

监控原则：
预防为主，监控在先，发现问题立即处理
```

> 💡 **总结一句话**
> 
> 执行计划控制就是让MySQL"听话"，确保重要的查询始终按照我们期望的方式执行，通过Hint、统计信息控制、监控告警等手段，保证核心业务查询的稳定性能，避免因优化器"聪明反被聪明误"导致的性能问题。

---

> ⚠️ **重要提醒**
> 
> 执行计划控制是一把双刃剑：过度控制可能限制优化器的正常优化能力，因此应该重点保护核心查询，一般查询让优化器自由发挥。记住：**稳定性和灵活性需要平衡**。