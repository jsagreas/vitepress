---
title: 3、逻辑运算符组合
---
## 📚 目录

1. [逻辑运算符基础概念](#1-逻辑运算符基础概念)
2. [AND逻辑与操作详解](#2-AND逻辑与操作详解)
3. [OR逻辑或操作详解](#3-OR逻辑或操作详解)
4. [NOT逻辑非操作详解](#4-NOT逻辑非操作详解)
5. [运算符优先级规则](#5-运算符优先级规则)
6. [短路求值机制](#6-短路求值机制)
7. [复合条件优化策略](#7-复合条件优化策略)
8. [条件合并优化技巧](#8-条件合并优化技巧)
9. [DNF/CNF范式转换](#9-DNF/CNF范式转换)
10. [多层条件嵌套处理](#10-多层条件嵌套处理)
11. [逻辑表达式化简](#11-逻辑表达式化简)
12. [性能优化最佳实践](#12-性能优化最佳实践)
13. [核心要点总结](#13-核心要点总结)

---

## 1. 🔍 逻辑运算符基础概念


### 1.1 什么是逻辑运算符


**通俗理解**：
逻辑运算符就像生活中的"并且"、"或者"、"不是"这样的连接词，用来组合多个判断条件。

```
生活中的例子：
• "我要买苹果 并且 价格便宜" → AND
• "今天去公园 或者 去电影院" → OR  
• "不是 下雨天才出门" → NOT
```

**数据库中的作用**：
- 将简单的条件组合成复杂的查询条件
- 实现更精确的数据筛选
- 提高查询的灵活性和实用性

### 1.2 MySQL支持的逻辑运算符


```sql
-- 三个基本逻辑运算符
AND  -- 逻辑与，所有条件都必须为真
OR   -- 逻辑或，至少一个条件为真
NOT  -- 逻辑非，对条件结果取反

-- 等价写法（可选）
&&   -- 等同于 AND
||   -- 等同于 OR  
!    -- 等同于 NOT
```

### 1.3 逻辑运算真值表


```
AND运算真值表：
条件A | 条件B | A AND B
-----|-------|--------
 真   |  真   |   真
 真   |  假   |   假  
 假   |  真   |   假
 假   |  假   |   假

OR运算真值表：
条件A | 条件B | A OR B
-----|-------|-------
 真   |  真   |   真
 真   |  假   |   真
 假   |  真   |   真
 假   |  假   |   假

NOT运算真值表：
条件A | NOT A
-----|------
 真   |  假
 假   |  真
```

---

## 2. ⚙️ AND逻辑与操作详解


### 2.1 AND操作的核心概念


**简单理解**：
AND就像考试要求，必须**所有科目都及格**才能通过。在数据库中，AND要求**所有条件都满足**才会返回结果。

**语法格式**：
```sql
SELECT * FROM 表名 
WHERE 条件1 AND 条件2 AND 条件3;
```

### 2.2 AND操作实践示例


```sql
-- 示例表：员工信息表
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    salary DECIMAL(10,2),
    department VARCHAR(30),
    city VARCHAR(30)
);

-- 基础AND查询：查找年龄大于25且薪水大于5000的员工
SELECT * FROM employees 
WHERE age > 25 AND salary > 5000;
```

**执行逻辑**：
```
步骤1：检查 age > 25
步骤2：检查 salary > 5000  
步骤3：两个条件都为真时，才返回该行数据
```

### 2.3 多条件AND组合


```sql
-- 复杂AND查询：多个条件组合
SELECT name, age, salary, department 
FROM employees 
WHERE age BETWEEN 25 AND 45           -- 年龄在25-45之间
  AND salary >= 8000                  -- 薪水不低于8000
  AND department = 'IT'               -- 部门是IT
  AND city IN ('北京', '上海');        -- 城市是北京或上海
```

**查询逻辑图解**：
```
原始数据 → [年龄过滤] → [薪水过滤] → [部门过滤] → [城市过滤] → 最终结果
  1000行      600行       300行       150行        50行       50行

每个AND条件都会进一步缩小结果集
```

### 2.4 AND操作注意事项


💡 **重要提示**：
```sql
-- 错误理解：以为这样能查到两个部门的人
SELECT * FROM employees 
WHERE department = 'IT' AND department = 'HR';
-- 结果：没有任何数据（一个人不能同时属于两个部门）

-- 正确写法：使用OR
SELECT * FROM employees 
WHERE department = 'IT' OR department = 'HR';
```

⚠️ **性能提示**：
- AND条件越多，筛选越严格，返回数据越少
- 将最容易过滤掉数据的条件放在前面
- 确保经常使用的AND条件字段建有索引

---

## 3. 🔄 OR逻辑或操作详解


### 3.1 OR操作的核心概念


**简单理解**：
OR就像多个选择，只要**满足其中任意一个条件**就可以。比如"会开车或会骑车"，只要会其中一样就符合要求。

**语法格式**：
```sql
SELECT * FROM 表名 
WHERE 条件1 OR 条件2 OR 条件3;
```

### 3.2 OR操作实践示例


```sql
-- 基础OR查询：查找薪水很高或年龄很小的员工
SELECT name, age, salary FROM employees 
WHERE salary > 15000 OR age < 25;
```

**执行逻辑**：
```
步骤1：检查 salary > 15000
步骤2：检查 age < 25
步骤3：任意一个条件为真时，就返回该行数据
```

### 3.3 OR与IN的等价关系


```sql
-- 这两种写法是等价的

-- 方式1：使用OR
SELECT * FROM employees 
WHERE department = 'IT' 
   OR department = 'HR' 
   OR department = 'Finance';

-- 方式2：使用IN（推荐）
SELECT * FROM employees 
WHERE department IN ('IT', 'HR', 'Finance');
```

**为什么推荐IN**？
- 代码更简洁易读
- 性能通常更好
- 不容易出错

### 3.4 复杂OR条件组合


```sql
-- 复杂OR查询：找出特殊情况的员工
SELECT name, age, salary, department 
FROM employees 
WHERE salary > 20000                    -- 高薪员工
   OR (age < 30 AND department = 'IT')  -- 年轻的IT员工
   OR (age > 50 AND salary < 5000);     -- 年长但低薪的员工
```

**查询逻辑图解**：
```
条件1: salary > 20000        → 找到 50人
条件2: age < 30 AND dept=IT   → 找到 30人  
条件3: age > 50 AND salary<5K → 找到 20人

最终结果 = 去重后的总人数（可能小于100人，因为有重叠）
```

---

## 4. 🚫 NOT逻辑非操作详解


### 4.1 NOT操作的核心概念


**简单理解**：
NOT就是"不是"、"相反"的意思。比如"不是周末"、"不等于某个值"。

**语法格式**：
```sql
SELECT * FROM 表名 
WHERE NOT 条件;

-- 或者
SELECT * FROM 表名 
WHERE !(条件);
```

### 4.2 NOT操作实践示例


```sql
-- 基础NOT查询：查找不在IT部门的员工
SELECT name, department FROM employees 
WHERE NOT department = 'IT';

-- 等价写法（更常用）
SELECT name, department FROM employees 
WHERE department != 'IT';
-- 或者
SELECT name, department FROM employees 
WHERE department <> 'IT';
```

### 4.3 NOT与其他运算符结合


```sql
-- NOT IN：不在指定列表中
SELECT * FROM employees 
WHERE department NOT IN ('IT', 'HR');

-- NOT LIKE：不匹配指定模式
SELECT * FROM employees 
WHERE name NOT LIKE '张%';

-- NOT BETWEEN：不在指定范围内
SELECT * FROM employees 
WHERE age NOT BETWEEN 25 AND 35;

-- NOT EXISTS：不存在关联数据
SELECT * FROM employees e
WHERE NOT EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.employee_id = e.id
);
```

### 4.4 NOT操作的性能考虑


⚠️ **性能警告**：
```sql
-- 性能较差：NOT条件难以使用索引
SELECT * FROM employees 
WHERE NOT department = 'IT';

-- 性能更好：正向条件更容易优化
SELECT * FROM employees 
WHERE department IN ('HR', 'Finance', 'Marketing');
```

**优化建议**：
- 尽量用正向条件代替NOT条件
- 如果必须用NOT，确保相关字段有索引
- 复杂的NOT条件考虑拆分查询

---

## 5. 📊 运算符优先级规则


### 5.1 MySQL运算符优先级表


```
优先级（从高到低）：
1. ()          -- 括号，最高优先级
2. NOT, !      -- 逻辑非
3. AND, &&     -- 逻辑与  
4. OR, ||      -- 逻辑或，最低优先级
```

### 5.2 优先级实际应用


```sql
-- 没有括号的查询：容易产生歧义
SELECT * FROM employees 
WHERE age > 30 OR department = 'IT' AND salary > 8000;

-- 实际执行顺序（因为AND优先级高于OR）：
SELECT * FROM employees 
WHERE age > 30 OR (department = 'IT' AND salary > 8000);
```

**执行逻辑**：
```
步骤1：先处理 AND → (department = 'IT' AND salary > 8000)
步骤2：再处理 OR → age > 30 OR (上一步结果)

结果：年龄大于30的所有员工 + IT部门薪水大于8000的员工
```

### 5.3 使用括号明确优先级


```sql
-- 明确意图1：年龄大于30或者IT部门的，且薪水大于8000
SELECT * FROM employees 
WHERE (age > 30 OR department = 'IT') AND salary > 8000;

-- 明确意图2：年龄大于30，或者（IT部门且薪水大于8000）
SELECT * FROM employees 
WHERE age > 30 OR (department = 'IT' AND salary > 8000);
```

**对比结果**：
```
原数据：1000名员工

查询1结果：
(age > 30 OR dept = 'IT') → 600人
再筛选 salary > 8000 → 150人

查询2结果：  
age > 30 → 400人
(dept = 'IT' AND salary > 8000) → 50人
总计 → 450人（去重后）

完全不同的结果！
```

### 5.4 复杂优先级示例


```sql
-- 复杂条件组合
SELECT * FROM employees 
WHERE NOT age < 25 
  AND (department = 'IT' OR department = 'HR')
  AND salary > 5000 
  OR city = '北京';
```

**执行顺序解析**：
```
步骤1：NOT age < 25                    （NOT优先级高）
步骤2：(department = 'IT' OR department = 'HR')  （括号内OR）
步骤3：步骤1 AND 步骤2 AND salary > 5000       （AND运算）
步骤4：步骤3 OR city = '北京'                  （最后OR运算）
```

💡 **最佳实践**：
- **总是使用括号**明确优先级，提高代码可读性
- **复杂条件分行写**，每个逻辑块占一行
- **添加注释**说明复杂逻辑的业务含义

---

## 6. ⚡ 短路求值机制


### 6.1 什么是短路求值


**通俗解释**：
短路求值就像考试时的"一票否决"。比如AND条件中，第一个条件就是假，后面的条件就不用检查了，直接判定整个结果为假。

**MySQL短路规则**：
```
AND短路：第一个false条件出现时，停止检查后续条件
OR短路：第一个true条件出现时，停止检查后续条件
```

### 6.2 短路求值示例


```sql
-- AND短路示例
SELECT * FROM employees 
WHERE 1 = 2                    -- 永远为false
  AND expensive_function() = 1; -- 这个函数不会被执行

-- OR短路示例  
SELECT * FROM employees 
WHERE 1 = 1                    -- 永远为true
  OR expensive_function() = 1;  -- 这个函数不会被执行
```

### 6.3 短路求值的性能优化


```sql
-- 优化前：低效的条件排列
SELECT * FROM employees 
WHERE complex_calculation(salary) > 100  -- 复杂计算，耗时
  AND age > 25;                          -- 简单比较，快速

-- 优化后：合理的条件排列
SELECT * FROM employees 
WHERE age > 25                           -- 先检查快速条件
  AND complex_calculation(salary) > 100; -- 再检查复杂条件
```

**性能对比**：
```
场景：10000条记录，其中只有1000条满足 age > 25

优化前：
10000次复杂计算 + 1000次年龄比较 = 很慢

优化后：
10000次年龄比较 + 1000次复杂计算 = 快很多
```

### 6.4 短路求值注意事项


⚠️ **重要警告**：
```sql
-- 危险写法：依赖短路求值避免错误
SELECT * FROM employees 
WHERE department IS NOT NULL 
  AND LENGTH(department) > 2;

-- 如果department为NULL，LENGTH(NULL)会返回NULL
-- 但由于短路求值，LENGTH不会被执行，避免了问题
```

💡 **安全写法**：
```sql
-- 推荐：明确处理NULL值
SELECT * FROM employees 
WHERE department IS NOT NULL 
  AND LENGTH(COALESCE(department, '')) > 2;
```

---

## 7. 🚀 复合条件优化策略


### 7.1 条件重排优化


**基本原则**：将**选择性高**的条件放在前面。

```sql
-- 假设数据分布：
-- age > 30: 过滤掉90%的数据
-- department = 'IT': 过滤掉80%的数据  
-- salary > 10000: 过滤掉70%的数据

-- 优化后的条件排列
SELECT * FROM employees 
WHERE age > 30                -- 最高选择性，先过滤
  AND department = 'IT'       -- 其次选择性
  AND salary > 10000;         -- 最低选择性，最后检查
```

### 7.2 索引友好的条件设计


```sql
-- 假设有复合索引：(department, age, salary)

-- 索引友好的写法：遵循索引列顺序
SELECT * FROM employees 
WHERE department = 'IT'       -- 索引第一列
  AND age BETWEEN 25 AND 35   -- 索引第二列
  AND salary > 8000;          -- 索引第三列

-- 索引不友好的写法：打乱索引列顺序
SELECT * FROM employees 
WHERE salary > 8000           -- 索引第三列
  AND department = 'IT'       -- 索引第一列
  AND age BETWEEN 25 AND 35;  -- 索引第二列
```

### 7.3 避免函数在WHERE条件中


```sql
-- 低效写法：在WHERE中使用函数
SELECT * FROM employees 
WHERE YEAR(hire_date) = 2023
  AND MONTH(hire_date) BETWEEN 6 AND 12;

-- 高效写法：使用范围条件
SELECT * FROM employees 
WHERE hire_date >= '2023-06-01'
  AND hire_date <= '2023-12-31';
```

**性能对比**：
```
低效写法：
- 每行都要计算YEAR()和MONTH()函数
- 无法使用hire_date上的索引

高效写法：  
- 直接范围比较，可以充分利用索引
- 性能提升可达10-100倍
```

### 7.4 合理使用EXISTS vs IN


```sql
-- 场景：查找有订单的员工

-- 使用EXISTS（推荐用于大数据集）
SELECT e.* FROM employees e
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.employee_id = e.id
);

-- 使用IN（适用于小数据集）
SELECT e.* FROM employees e
WHERE e.id IN (
    SELECT DISTINCT employee_id FROM orders
);
```

**选择建议**：
```
EXISTS使用场景：
- 关联表数据量大
- 只需要判断存在性
- 子查询返回大量重复值

IN使用场景：
- 关联表数据量小  
- 子查询返回去重后数据较少
- 逻辑更简单直观
```

---

## 8. 🔥 条件合并优化技巧


### 8.1 相同字段条件合并


```sql
-- 优化前：重复的字段条件
SELECT * FROM employees 
WHERE (age >= 25 AND age <= 35)
  OR (age >= 40 AND age <= 50)
  OR (age >= 55 AND age <= 65);

-- 优化后：使用IN或复杂范围
SELECT * FROM employees 
WHERE age BETWEEN 25 AND 35
  OR age BETWEEN 40 AND 50  
  OR age BETWEEN 55 AND 65;

-- 进一步优化：如果是连续值，考虑合并范围
SELECT * FROM employees 
WHERE age IN (25,26,27,28,29,30,31,32,33,34,35,
              40,41,42,43,44,45,46,47,48,49,50,
              55,56,57,58,59,60,61,62,63,64,65);
```

### 8.2 逻辑等价条件转换


```sql
-- 德摩根定律应用

-- 原条件：NOT (A AND B) 
SELECT * FROM employees 
WHERE NOT (department = 'IT' AND salary > 10000);

-- 等价转换：(NOT A) OR (NOT B)
SELECT * FROM employees 
WHERE department != 'IT' OR salary <= 10000;

-- 原条件：NOT (A OR B)
SELECT * FROM employees 
WHERE NOT (age < 25 OR age > 60);

-- 等价转换：(NOT A) AND (NOT B)  
SELECT * FROM employees 
WHERE age >= 25 AND age <= 60;
-- 进一步简化
SELECT * FROM employees 
WHERE age BETWEEN 25 AND 60;
```

### 8.3 条件吸收和简化


```sql
-- 吸收律应用：A OR (A AND B) = A
-- 优化前
SELECT * FROM employees 
WHERE department = 'IT' 
  OR (department = 'IT' AND salary > 10000);

-- 优化后：第二个条件被吸收
SELECT * FROM employees 
WHERE department = 'IT';

-- 分配律应用：A AND (B OR C) = (A AND B) OR (A AND C)
-- 如果A条件选择性很高，可以考虑这种转换
```

### 8.4 范围条件优化


```sql
-- 重叠范围合并
-- 优化前
SELECT * FROM employees 
WHERE (salary >= 5000 AND salary <= 8000)
  OR (salary >= 7000 AND salary <= 12000);

-- 优化后：合并重叠范围
SELECT * FROM employees 
WHERE salary >= 5000 AND salary <= 12000;

-- 相邻范围合并  
-- 优化前
SELECT * FROM employees 
WHERE age = 25 OR age = 26 OR age = 27;

-- 优化后
SELECT * FROM employees 
WHERE age BETWEEN 25 AND 27;
```

---

## 9. 🔥 DNF/CNF范式转换


### 9.1 什么是DNF和CNF


**通俗解释**：
- **DNF（析取范式）**：就像"或者的组合"，几个AND条件用OR连接
- **CNF（合取范式）**：就像"并且的组合"，几个OR条件用AND连接

```
DNF形式：(A AND B) OR (C AND D) OR (E AND F)
CNF形式：(A OR B) AND (C OR D) AND (E OR F)
```

### 9.2 DNF范式应用场景


```sql
-- 典型的DNF应用：多种员工类型查询
SELECT * FROM employees 
WHERE (department = 'IT' AND salary > 10000)      -- 高薪IT员工
  OR (department = 'Sales' AND age < 30)          -- 年轻销售员工  
  OR (department = 'HR' AND city = '北京');       -- 北京HR员工
```

**DNF的优势**：
- 逻辑清晰，每个OR分支代表一种情况
- 容易理解业务含义
- 便于添加新的业务规则

### 9.3 CNF范式应用场景


```sql
-- 典型的CNF应用：多重筛选条件
SELECT * FROM employees 
WHERE (department = 'IT' OR department = 'R&D')   -- 技术相关部门
  AND (age >= 25 OR experience > 3)               -- 有经验要求
  AND (salary >= 8000 OR bonus > 2000);          -- 薪酬要求
```

**CNF的优势**：
- 每个AND条件都是必须满足的
- 容易进行索引优化
- 筛选效果更强

### 9.4 范式转换实例


```sql
-- 原始复杂条件
SELECT * FROM employees 
WHERE (dept = 'IT' AND (age > 30 OR salary > 15000))
  OR (dept = 'HR' AND age < 25);

-- 转换为DNF形式
SELECT * FROM employees 
WHERE (dept = 'IT' AND age > 30)
  OR (dept = 'IT' AND salary > 15000)  
  OR (dept = 'HR' AND age < 25);

-- 如果需要，还可以进一步优化为union查询
SELECT * FROM employees WHERE dept = 'IT' AND age > 30
UNION
SELECT * FROM employees WHERE dept = 'IT' AND salary > 15000
UNION  
SELECT * FROM employees WHERE dept = 'HR' AND age < 25;
```

### 9.5 范式选择建议


```
选择DNF的情况：
✅ 业务规则是"满足任意一种情况"
✅ 不同分支的筛选条件差异很大
✅ 便于添加新的业务分支

选择CNF的情况：
✅ 业务规则是"必须同时满足多个条件"
✅ 每个条件都有很好的选择性
✅ 更容易利用索引优化
```

---

## 10. 🔸 多层条件嵌套处理


### 10.1 嵌套条件的可读性问题


```sql
-- 难以阅读的嵌套条件
SELECT * FROM employees 
WHERE (
    (department = 'IT' AND (salary > 10000 OR (age < 30 AND experience > 2))) 
    OR 
    (department = 'Sales' AND (age > 25 AND (city = '北京' OR city = '上海')))
) AND hire_date > '2020-01-01';
```

### 10.2 嵌套条件格式化


```sql
-- 格式化后的嵌套条件（提高可读性）
SELECT * FROM employees 
WHERE (
    -- IT部门的条件
    (department = 'IT' 
     AND (salary > 10000 
          OR (age < 30 AND experience > 2)
         )
    ) 
    OR 
    -- 销售部门的条件
    (department = 'Sales' 
     AND age > 25 
     AND (city = '北京' OR city = '上海')
    )
) 
AND hire_date > '2020-01-01';
```

### 10.3 使用CTE简化嵌套


```sql
-- 使用CTE（公用表表达式）分解复杂逻辑
WITH qualified_it_employees AS (
    SELECT * FROM employees 
    WHERE department = 'IT'
      AND (salary > 10000 OR (age < 30 AND experience > 2))
),
qualified_sales_employees AS (
    SELECT * FROM employees 
    WHERE department = 'Sales'
      AND age > 25 
      AND city IN ('北京', '上海')
)
SELECT * FROM (
    SELECT * FROM qualified_it_employees
    UNION ALL
    SELECT * FROM qualified_sales_employees  
) combined_results
WHERE hire_date > '2020-01-01';
```

### 10.4 嵌套条件性能优化


```sql
-- 性能优化：将高选择性条件外提
-- 优化前：嵌套中的高选择性条件
SELECT * FROM employees 
WHERE (
    (department = 'IT' AND salary > 50000)     -- 高选择性
    OR 
    (department = 'Sales' AND salary > 50000) -- 高选择性
) AND age > 25;

-- 优化后：提取公共高选择性条件
SELECT * FROM employees 
WHERE salary > 50000                    -- 先过滤高薪员工  
  AND age > 25                         -- 再过滤年龄
  AND department IN ('IT', 'Sales');    -- 最后过滤部门
```

---

## 11. 🔸 逻辑表达式化简


### 11.1 常用化简规则


```sql
-- 规则1：双重否定消除
-- 优化前：NOT NOT A = A
SELECT * FROM employees 
WHERE NOT (NOT department = 'IT');

-- 优化后
SELECT * FROM employees 
WHERE department = 'IT';

-- 规则2：德摩根定律
-- NOT (A AND B) = (NOT A) OR (NOT B)
-- NOT (A OR B) = (NOT A) AND (NOT B)
```

### 11.2 冗余条件消除


```sql
-- 消除恒真/恒假条件
-- 优化前
SELECT * FROM employees 
WHERE age > 20 
  AND 1 = 1                    -- 恒真条件，可以删除
  AND department = 'IT'
  AND 1 = 0;                   -- 恒假条件，整个查询返回空

-- 优化后
-- 由于存在恒假条件，可以直接写成
SELECT * FROM employees WHERE FALSE;
-- 或者干脆不执行查询
```

### 11.3 条件合并化简


```sql
-- 同一字段的条件合并
-- 优化前
SELECT * FROM employees 
WHERE age > 25 
  AND age < 65
  AND age != 30;

-- 化简分析
-- age > 25 AND age < 65 可以写成 age BETWEEN 26 AND 64
-- 但还要排除30，所以最终是：
SELECT * FROM employees 
WHERE (age BETWEEN 26 AND 29) OR (age BETWEEN 31 AND 64);
```

### 11.4 分配律应用


```sql
-- 分配律：A AND (B OR C) = (A AND B) OR (A AND C)
-- 优化前
SELECT * FROM employees 
WHERE department = 'IT' 
  AND (salary > 10000 OR bonus > 5000);

-- 应用分配律后
SELECT * FROM employees 
WHERE (department = 'IT' AND salary > 10000)
  OR (department = 'IT' AND bonus > 5000);

-- 这种转换在某些情况下可以更好地利用复合索引
```

---

## 12. 🔑 性能优化最佳实践


### 12.1 索引优化策略


```sql
-- 为逻辑运算符创建合适的索引

-- 针对AND条件：创建复合索引
CREATE INDEX idx_dept_age_salary 
ON employees (department, age, salary);

-- 针对OR条件：可能需要多个单列索引
CREATE INDEX idx_department ON employees (department);
CREATE INDEX idx_age ON employees (age);  
CREATE INDEX idx_salary ON employees (salary);

-- 使用索引的查询
SELECT * FROM employees 
WHERE department = 'IT'     -- 使用复合索引第一列
  AND age BETWEEN 25 AND 35 -- 使用复合索引第二列
  AND salary > 8000;        -- 使用复合索引第三列
```

### 12.2 查询执行计划分析


```sql
-- 使用EXPLAIN分析查询性能
EXPLAIN SELECT * FROM employees 
WHERE (department = 'IT' AND salary > 10000)
  OR (department = 'Sales' AND age < 30);

-- 关注以下指标：
-- type: 访问类型（ref > range > index > ALL）
-- key: 使用的索引
-- rows: 扫描的行数
-- Extra: 额外信息（Using where, Using index等）
```

### 12.3 大数据量优化技巧


```sql
-- 1. 使用LIMIT限制结果集
SELECT * FROM employees 
WHERE department = 'IT' 
  AND salary > 10000
LIMIT 100;

-- 2. 分页查询优化
SELECT * FROM employees 
WHERE department = 'IT' 
  AND salary > 10000
  AND id > 1000  -- 使用主键分页，比OFFSET效率高
ORDER BY id 
LIMIT 20;

-- 3. 使用覆盖索引避免回表
SELECT id, name, department FROM employees 
WHERE department = 'IT' 
  AND salary > 10000;
-- 如果索引包含了查询的所有列，就不需要回表查询
```

### 12.4 条件下推优化


```sql
-- 在子查询中尽早应用过滤条件
-- 优化前：在外层过滤
SELECT * FROM (
    SELECT * FROM employees 
    WHERE department IN ('IT', 'Sales')
) t
WHERE t.salary > 10000;

-- 优化后：条件下推到内层
SELECT * FROM (
    SELECT * FROM employees 
    WHERE department IN ('IT', 'Sales')
      AND salary > 10000          -- 提前过滤
) t;

-- 最优：直接在主查询中过滤
SELECT * FROM employees 
WHERE department IN ('IT', 'Sales')
  AND salary > 10000;
```

---

## 13. 📋 核心要点总结


### 13.1 逻辑运算符基础要点


```markdown
🔸 **三大逻辑运算符**
• AND：所有条件都必须为真（交集）
• OR：至少一个条件为真（并集）  
• NOT：对条件结果取反（补集）

🔸 **优先级记忆**
• 括号 > NOT > AND > OR
• 永远使用括号明确优先级

🔸 **短路求值机制**
• AND：遇到false立即停止
• OR：遇到true立即停止
• 利用短路优化性能
```

### 13.2 性能优化要点


```markdown
🔑 **条件排序原则**
• 高选择性条件放在前面
• 简单条件优于复杂条件
• 索引友好条件优先

🔑 **索引设计建议**
• AND条件：设计复合索引
• OR条件：考虑多个单列索引
• 避免在索引列上使用函数

🔑 **复杂查询优化**
• 使用CTE分解复杂逻辑
• 考虑UNION代替复杂OR
• 善用EXISTS和IN的选择
```

### 13.3 代码质量要点


```markdown
💡 **可读性提升**
• 复杂条件分行书写
• 添加注释说明业务逻辑
• 使用有意义的别名

💡 **维护性改进**
• 避免深层嵌套
• 提取公共条件
• 使用视图封装复杂逻辑

💡 **错误预防**
• 明确处理NULL值
• 测试边界条件
• 验证逻辑等价性
```

### 13.4 实际应用建议


**🎯 日常开发建议**：
1. **简单优于复杂**：能用简单条件就不用复杂嵌套
2. **性能优于优雅**：在大数据量场景下，性能比代码优雅更重要
3. **测试驱动**：复杂逻辑条件要有充分的测试用例
4. **文档化**：为复杂的业务逻辑添加详细注释

**⚠️ 常见陷阱**：
- 忽略NULL值处理导致的逻辑错误
- 优先级理解错误导致的查询结果偏差
- 过度优化导致的代码可读性下降
- 忽略数据分布导致的性能问题

**🚀 进阶方向**：
- 学习查询执行计划分析
- 掌握更多SQL优化技巧
- 了解数据库内部实现原理
- 关注不同数据库的差异特性

---

**核心记忆口诀**：
- 逻辑运算三兄弟：AND要全真，OR有真即可，NOT来取反
- 优先级要记牢：括号NOT在前头，AND比OR先执行
- 性能优化三要素：条件排序、索引设计、短路利用
- 代码质量三原则：清晰易读、逻辑正确、性能优良