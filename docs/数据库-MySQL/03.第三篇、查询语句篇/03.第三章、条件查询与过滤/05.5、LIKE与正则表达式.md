---
title: 5、LIKE与正则表达式
---
## 📚 目录

1. [LIKE模式匹配基础](#1-LIKE模式匹配基础)
2. [通配符详解与使用规则](#2-通配符详解与使用规则)
3. [转义字符处理](#3-转义字符处理)
4. [正则表达式REGEXP](#4-正则表达式REGEXP)
5. [性能优化策略](#5-性能优化策略)
6. [全文索引FULLTEXT替代方案](#6-全文索引FULLTEXT替代方案)
7. [实战应用与最佳实践](#7-实战应用与最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 LIKE模式匹配基础


### 1.1 什么是LIKE模式匹配


**🔸 核心定义**
```sql
-- LIKE是SQL中用于模糊查询的关键字
-- 它允许我们查找符合特定模式的字符串
SELECT * FROM users WHERE name LIKE '张%';
```

**💡 生活类比**
LIKE就像在电话簿里找人：
- 你记得姓氏是"张"，但不记得全名
- 用LIKE '张%' 就能找到所有姓张的人
- 比逐个查看每个名字要快得多

### 1.2 LIKE的基本语法结构


**📋 标准语法**
```sql
SELECT 列名 FROM 表名 WHERE 列名 LIKE '模式字符串';

-- 基本示例
SELECT * FROM products WHERE product_name LIKE 'iPhone%';
SELECT * FROM users WHERE email LIKE '%@gmail.com';
```

**🎯 核心特点**
- **模糊匹配**：不需要完全相同，只需符合模式
- **大小写敏感**：默认情况下区分大小写（取决于字符集）
- **字符串操作**：只能用于字符串类型的列
- **通配符支持**：使用特殊字符表示未知部分

---

## 2. 🔍 通配符详解与使用规则


### 2.1 百分号(%)通配符 - 多字符匹配


**🔸 %通配符原理**
```
%代表任意数量的字符（包括0个字符）
就像一个"万能替身"，可以代替任何长度的字符串
```

**📊 %通配符使用模式**

| 模式 | 含义 | 示例 | 匹配结果 |
|------|------|------|----------|
| `'A%'` | 以A开头 | `'Apple'`, `'Android'` | ✅ 匹配 |
| `'%ing'` | 以ing结尾 | `'Running'`, `'Coding'` | ✅ 匹配 |
| `'%SQL%'` | 包含SQL | `'MySQL'`, `'PostgreSQL'` | ✅ 匹配 |
| `'%'` | 匹配所有 | 任何字符串 | ✅ 全部匹配 |

**💻 实际应用示例**
```sql
-- 查找所有以"张"开头的姓名
SELECT * FROM employees WHERE name LIKE '张%';
-- 结果：张三、张小明、张大伟等

-- 查找所有QQ邮箱用户
SELECT * FROM users WHERE email LIKE '%@qq.com';
-- 结果：abc@qq.com、123456@qq.com等

-- 查找包含"管理"关键字的职位
SELECT * FROM jobs WHERE title LIKE '%管理%';
-- 结果：项目管理、人事管理、管理员等
```

### 2.2 下划线(_)通配符 - 单字符匹配


**🔸 _通配符原理**
```
_代表恰好一个字符
就像填空题中的一个空格，必须且只能填一个字符
```

**📊 _通配符使用模式**

| 模式 | 含义 | 示例查询 | 匹配结果 |
|------|------|----------|----------|
| `'_技术'` | X技术 | 查找职位名称 | `'C技术'` ✅ `'Java技术'` ❌ |
| `'1_3'` | 1X3格式 | 查找编号 | `'123'`, `'1A3'` ✅ |
| `'__数据库'` | XX数据库 | 查找课程 | `'大数据库'` ❌ `'关数据库'` ✅ |

**💻 实际应用示例**
```sql
-- 查找电话号码格式为138XXXXXXXX的用户
SELECT * FROM users WHERE phone LIKE '138________';
-- 注意：8个下划线代表后8位数字

-- 查找姓名为两个字的员工
SELECT * FROM employees WHERE name LIKE '__';
-- 结果：王五、李四等（恰好2个字符）

-- 查找产品编号格式为P-XXX的产品
SELECT * FROM products WHERE code LIKE 'P-___';
-- 结果：P-001、P-ABC等
```

### 2.3 通配符组合使用技巧


**🎯 灵活组合模式**
```sql
-- 复合模式：查找以"数据"开头，以"系统"结尾的产品
SELECT * FROM products 
WHERE name LIKE '数据%系统';

-- 精确控制：查找姓张且名字是两个字的员工
SELECT * FROM employees 
WHERE name LIKE '张__';

-- 多条件组合：查找手机号137或138开头的用户
SELECT * FROM users 
WHERE phone LIKE '137%' OR phone LIKE '138%';
```

**⚠️ 常见误区澄清**
```sql
-- ❌ 错误理解：以为%只能匹配多个字符
-- ✅ 正确理解：%可以匹配0个或多个字符
SELECT * FROM test WHERE name LIKE 'A%';  -- 'A' 也会被匹配

-- ❌ 错误理解：认为_可以匹配0个字符  
-- ✅ 正确理解：_必须匹配恰好1个字符
SELECT * FROM test WHERE name LIKE 'A_';  -- 'A' 不会被匹配，'AB' 会被匹配
```

---

## 3. 🔧 转义字符处理


### 3.1 为什么需要转义字符


**💡 问题背景**
当数据中包含通配符字符(%, _)时，如何精确查找？

```sql
-- 假设有产品名称：iPhone_12, Android%Pro
-- 如果想查找真正包含下划线_的产品
SELECT * FROM products WHERE name LIKE '%_%';  -- ❌ 这样会匹配所有产品

-- 需要转义才能精确查找
SELECT * FROM products WHERE name LIKE '%\_%';  -- ✅ 这样才能找到包含_的产品
```

### 3.2 ESCAPE关键字使用详解


**🔸 ESCAPE语法结构**
```sql
-- 基本语法
SELECT * FROM 表名 WHERE 列名 LIKE '模式' ESCAPE '转义字符';

-- 常用转义字符选择
ESCAPE '\'  -- 反斜杠（最常用）
ESCAPE '/'  -- 正斜杠
ESCAPE '#'  -- 井号
ESCAPE '!'  -- 感叹号
```

**📊 转义字符对比表**

| 转义字符 | 优点 | 缺点 | 推荐程度 |
|----------|------|------|----------|
| `\` | 最直观，类似编程语言 | 某些系统需要双反斜杠 | ⭐⭐⭐⭐⭐ |
| `/` | 简单明了 | 与URL路径可能冲突 | ⭐⭐⭐⭐ |
| `#` | 不常用，冲突少 | 不够直观 | ⭐⭐⭐ |
| `!` | 醒目 | 可能与逻辑运算符混淆 | ⭐⭐ |

### 3.3 实际转义应用示例


**💻 转义实战案例**
```sql
-- 案例1：查找包含百分号的数据
-- 数据示例：iPhone销量上涨30%
SELECT * FROM reports 
WHERE content LIKE '%\%%' ESCAPE '\';

-- 案例2：查找包含下划线的文件名
-- 数据示例：user_data.txt, system_log.txt
SELECT * FROM files 
WHERE filename LIKE '%\_%' ESCAPE '\';

-- 案例3：查找同时包含%和_的数据
SELECT * FROM products 
WHERE description LIKE '%\_%\%%' ESCAPE '\';
```

**🔍 转义字符选择建议**
```sql
-- 推荐方案1：使用反斜杠（最常用）
WHERE column LIKE '%\_%' ESCAPE '\';

-- 推荐方案2：使用感叹号（避免反斜杠问题）
WHERE column LIKE '%!_%' ESCAPE '!';

-- 不推荐：使用数据中可能出现的字符作为转义字符
-- WHERE column LIKE '%@_%' ESCAPE '@';  -- 如果数据中有@就会出问题
```

### 3.4 特殊字符处理完整指南


**📋 常见特殊字符转义表**
```sql
-- 查找包含各种特殊字符的数据
SELECT * FROM data WHERE 
    content LIKE '%\%%' ESCAPE '\'     -- 百分号%
    OR content LIKE '%\_%' ESCAPE '\'  -- 下划线_
    OR content LIKE '%\\%' ESCAPE '\'  -- 反斜杠\（需要双转义）
    OR content LIKE '%''%'             -- 单引号'（用两个单引号表示）
    OR content LIKE '%"%';             -- 双引号"（直接使用）
```

---

## 4. 🎨 正则表达式REGEXP


### 4.1 正则表达式基础概念


**🔸 什么是正则表达式**
```
正则表达式（Regular Expression）是一种强大的文本模式匹配工具
比LIKE更灵活，能处理复杂的匹配需求
```

**🌟 生活类比**
- LIKE像简单的查找功能：只能找"包含某个词"的文章
- 正则表达式像高级搜索：可以找"以数字开头，包含邮件格式，长度在10-20字符"的复杂模式

**📊 LIKE vs REGEXP 对比**

| 特性 | LIKE | REGEXP | 适用场景 |
|------|------|---------|----------|
| **复杂度** | 简单 | 复杂 | LIKE：基础查找<br>REGEXP：复杂模式 |
| **灵活性** | 有限 | 强大 | LIKE：固定模式<br>REGEXP：动态模式 |
| **性能** | 较快 | 较慢 | LIKE：大量数据<br>REGEXP：精确匹配 |
| **学习成本** | 低 | 高 | LIKE：新手友好<br>REGEXP：需要学习 |

### 4.2 REGEXP基本语法规则


**🔸 基础语法结构**
```sql
-- 基本格式
SELECT * FROM 表名 WHERE 列名 REGEXP '正则表达式模式';

-- 简单示例
SELECT * FROM users WHERE email REGEXP '^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}$';
```

**📚 核心正则符号详解**

| 符号 | 含义 | 示例 | 匹配结果 |
|------|------|------|----------|
| `^` | 字符串开始 | `'^A'` | 以A开头 |
| `$` | 字符串结束 | `'Z$'` | 以Z结尾 |
| `.` | 任意单个字符 | `'a.c'` | abc, a1c, a@c |
| `*` | 前一个字符0次或多次 | `'ab*'` | a, ab, abb, abbb |
| `+` | 前一个字符1次或多次 | `'ab+'` | ab, abb, abbb |
| `?` | 前一个字符0次或1次 | `'ab?'` | a, ab |
| `[...]` | 字符集合 | `'[abc]'` | a或b或c |
| `[^...]` | 非字符集合 | `'[^abc]'` | 除a,b,c外的字符 |

### 4.3 常用正则表达式模式


**💻 实用正则表达式示例**

```sql
-- 1. 验证邮箱格式
SELECT * FROM users 
WHERE email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';

-- 2. 查找手机号码（11位数字，1开头）
SELECT * FROM contacts 
WHERE phone REGEXP '^1[0-9]{10}$';

-- 3. 查找身份证号码（18位，前17位数字，最后一位数字或X）
SELECT * FROM persons 
WHERE id_card REGEXP '^[0-9]{17}[0-9Xx]$';

-- 4. 查找包含数字的产品编号
SELECT * FROM products 
WHERE code REGEXP '[0-9]+';

-- 5. 查找以字母开头，后跟数字的用户名
SELECT * FROM accounts 
WHERE username REGEXP '^[a-zA-Z][a-zA-Z0-9]*$';
```

**🎯 正则表达式分组详解**
```sql
-- 使用括号()进行分组
-- 查找格式为"字母-数字-字母"的编码
SELECT * FROM items 
WHERE code REGEXP '^([a-zA-Z])-([0-9]+)-([a-zA-Z])$';

-- 使用|表示"或"关系
-- 查找.com或.cn结尾的邮箱
SELECT * FROM users 
WHERE email REGEXP '\.(com|cn)$';

-- 使用量词{}指定重复次数
-- 查找恰好6位数字的验证码
SELECT * FROM verification_codes 
WHERE code REGEXP '^[0-9]{6}$';
```

### 4.4 正则表达式实战应用


**🛠️ 数据清洗应用**
```sql
-- 查找格式不规范的数据
-- 找出不符合邮箱格式的数据
SELECT * FROM users 
WHERE email NOT REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';

-- 查找包含特殊字符的用户名
SELECT * FROM accounts 
WHERE username REGEXP '[^a-zA-Z0-9_]';

-- 查找数据中的异常模式
-- 比如查找可能是测试数据的记录
SELECT * FROM orders 
WHERE customer_name REGEXP '^(test|测试|demo)';
```

---

## 5. ⚡ 性能优化策略


### 5.1 模糊查询性能问题分析


**💡 性能问题根源**
```
LIKE和REGEXP查询慢的原因：
1. 无法使用索引（特别是以%开头的模式）
2. 需要扫描表中每一行数据
3. 字符串比较操作消耗CPU资源
4. 正则表达式引擎计算复杂
```

**📊 不同LIKE模式的性能对比**

| LIKE模式 | 索引利用 | 性能等级 | 说明 |
|----------|----------|----------|------|
| `'ABC%'` | ✅ 可以利用 | 🟢 快速 | 前缀匹配，索引友好 |
| `'%ABC'` | ❌ 无法利用 | 🔴 慢速 | 后缀匹配，全表扫描 |
| `'%ABC%'` | ❌ 无法利用 | 🔴 慢速 | 包含匹配，全表扫描 |
| `'A_C'` | 🟡 部分利用 | 🟡 中等 | 固定长度，部分优化 |

### 5.2 前缀索引优化策略


**🔸 前缀索引的作用原理**
```sql
-- 创建前缀索引，只对字符串前几位建索引
-- 适用于长字符串字段，节省空间提高效率
CREATE INDEX idx_name_prefix ON users (name(10));

-- 查询时利用前缀索引
SELECT * FROM users WHERE name LIKE '张三%';  -- 可以利用前缀索引
```

**💻 前缀索引实践指南**
```sql
-- 1. 分析字段的前缀选择性
SELECT 
    COUNT(DISTINCT LEFT(column_name, 5)) / COUNT(*) AS selectivity_5,
    COUNT(DISTINCT LEFT(column_name, 10)) / COUNT(*) AS selectivity_10,
    COUNT(DISTINCT LEFT(column_name, 15)) / COUNT(*) AS selectivity_15
FROM table_name;

-- 2. 根据选择性创建最优前缀索引
-- 选择selectivity接近1.0且长度最短的前缀长度
CREATE INDEX idx_email_prefix ON users (email(15));

-- 3. 验证索引效果
EXPLAIN SELECT * FROM users WHERE email LIKE 'admin@company%';
```

### 5.3 查询改写优化技巧


**🛠️ 查询优化方案**

**方案1：使用UNION替代OR**
```sql
-- ❌ 低效写法：多个LIKE条件用OR
SELECT * FROM products 
WHERE name LIKE 'iPhone%' 
   OR name LIKE 'Samsung%' 
   OR name LIKE 'Huawei%';

-- ✅ 高效写法：使用UNION
SELECT * FROM products WHERE name LIKE 'iPhone%'
UNION
SELECT * FROM products WHERE name LIKE 'Samsung%'
UNION  
SELECT * FROM products WHERE name LIKE 'Huawei%';
```

**方案2：范围查询替代模糊查询**
```sql
-- ❌ 低效：使用LIKE进行前缀查找
SELECT * FROM users WHERE name LIKE '张%';

-- ✅ 高效：使用范围查询（当可能时）
SELECT * FROM users 
WHERE name >= '张' AND name < '张' + CHAR(1);
```

**方案3：函数索引优化**
```sql
-- 对于固定模式的查询，可以创建函数索引
-- 比如经常查询邮箱的域名部分
CREATE INDEX idx_email_domain ON users ((SUBSTRING_INDEX(email, '@', -1)));

-- 查询时使用相同的函数
SELECT * FROM users 
WHERE SUBSTRING_INDEX(email, '@', -1) = 'gmail.com';
```

### 5.4 索引设计最佳实践


**🔑 索引设计策略**

```sql
-- 1. 复合索引优化LIKE查询
-- 如果经常按状态过滤后再进行名称模糊查询
CREATE INDEX idx_status_name ON orders (status, customer_name);

-- 查询时先用精确条件过滤，再模糊匹配
SELECT * FROM orders 
WHERE status = 'active' AND customer_name LIKE '张%';

-- 2. 覆盖索引减少回表
-- 如果只需要返回特定字段，可以创建覆盖索引
CREATE INDEX idx_name_email ON users (name, email);

-- 查询时只返回索引包含的字段
SELECT name, email FROM users WHERE name LIKE '李%';

-- 3. 分区表优化
-- 对于大表，可以按时间或其他维度分区
CREATE TABLE orders_2024 (
    id INT,
    customer_name VARCHAR(100),
    order_date DATE,
    ...
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2024 VALUES LESS THAN (2025),
    ...
);
```

---

## 6. 🔍 全文索引FULLTEXT替代方案


### 6.1 全文索引基础概念


**🔸 什么是全文索引**
```
全文索引（FULLTEXT Index）是专门为文本搜索设计的索引类型
比LIKE更高效，比正则表达式更适合自然语言搜索
```

**🌟 全文索引 vs 普通模糊查询**

┌─ 💡 性能对比 ──────────────┐
│ 普通LIKE：逐行扫描匹配     │
│ 全文索引：预建搜索词典     │
│ 性能提升：10-100倍不等     │
└────────────────────────────┘

**📊 适用场景对比**

| 查询类型 | LIKE | REGEXP | FULLTEXT | 推荐方案 |
|----------|------|---------|----------|----------|
| **简单前缀** | ⭐⭐⭐ | ⭐⭐ | ⭐ | LIKE + 索引 |
| **精确模式** | ⭐⭐ | ⭐⭐⭐ | ⭐ | REGEXP |
| **关键词搜索** | ⭐ | ⭐ | ⭐⭐⭐ | FULLTEXT |
| **自然语言** | ❌ | ❌ | ⭐⭐⭐ | FULLTEXT |

### 6.2 全文索引创建与使用


**💻 全文索引实战操作**
```sql
-- 1. 创建全文索引
-- 注意：只能在MyISAM、InnoDB引擎上使用
CREATE FULLTEXT INDEX ft_content ON articles (title, content);

-- 或者在创建表时定义
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT(title, content)
) ENGINE=InnoDB;

-- 2. 基本全文搜索
-- 自然语言模式（默认）
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST ('MySQL数据库');

-- 3. 布尔模式搜索
-- 支持AND、OR、NOT等逻辑操作
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST ('+MySQL +优化 -错误' IN BOOLEAN MODE);
```

**🎯 全文搜索模式详解**

```sql
-- 自然语言模式（NATURAL LANGUAGE MODE）
-- 根据相关性排序，返回最匹配的结果
SELECT *, MATCH(content) AGAINST ('数据库优化') AS relevance
FROM articles 
WHERE MATCH(content) AGAINST ('数据库优化')
ORDER BY relevance DESC;

-- 布尔模式（BOOLEAN MODE）
-- 支持精确的搜索语法
SELECT * FROM articles 
WHERE MATCH(content) AGAINST (
    '+数据库 +优化'          -- 必须包含"数据库"和"优化"
    ' -错误'                -- 不能包含"错误"  
    ' +"SQL语句"'           -- 必须包含完整短语"SQL语句"
    IN BOOLEAN MODE
);

-- 查询扩展模式（WITH QUERY EXPANSION）
-- 先进行普通搜索，然后扩展搜索相关词汇
SELECT * FROM articles 
WHERE MATCH(content) AGAINST ('MySQL' WITH QUERY EXPANSION);
```

### 6.3 全文索引优化配置


**⚙️ 关键参数配置**
```sql
-- 查看当前全文搜索相关配置
SHOW VARIABLES LIKE 'ft_%';

-- 重要参数说明：
-- ft_min_word_len: 最小词汇长度（默认4，中文建议设为1或2）
-- ft_max_word_len: 最大词汇长度  
-- ft_stopword_file: 停用词文件路径

-- 设置最小词长（需要重启MySQL）
SET GLOBAL ft_min_word_len = 2;

-- 重建全文索引使配置生效
ALTER TABLE articles DROP INDEX ft_content;
ALTER TABLE articles ADD FULLTEXT(title, content);
```

**🔍 中文全文搜索优化**
```sql
-- 对于中文搜索，建议使用ngram解析器
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT(title, content) WITH PARSER ngram
) ENGINE=InnoDB;

-- 设置ngram词汇长度
SET GLOBAL ngram_token_size = 2;  -- 2字词汇分割
```

### 6.4 全文索引实际应用场景


**🛠️ 实战应用案例**

**案例1：文章搜索系统**
```sql
-- 创建文章表与全文索引
CREATE TABLE blog_articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    tags VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FULLTEXT(title, content, tags)
) ENGINE=InnoDB;

-- 智能搜索查询
SELECT 
    id, title, 
    MATCH(title, content, tags) AGAINST ('Python机器学习') AS score
FROM blog_articles 
WHERE MATCH(title, content, tags) AGAINST ('Python机器学习')
ORDER BY score DESC, created_at DESC
LIMIT 10;
```

**案例2：电商商品搜索**
```sql
-- 商品搜索优化
SELECT 
    product_id, 
    product_name, 
    brand,
    MATCH(product_name, description, brand) AGAINST ('+手机 +华为' IN BOOLEAN MODE) AS relevance
FROM products 
WHERE MATCH(product_name, description, brand) AGAINST ('+手机 +华为' IN BOOLEAN MODE)
    AND status = 'active'
    AND stock > 0
ORDER BY relevance DESC, sales_count DESC;
```

**案例3：日志分析系统**
```sql
-- 日志搜索与分析
SELECT 
    log_time,
    log_level,
    message,
    MATCH(message) AGAINST ('error exception' WITH QUERY EXPANSION) AS score
FROM system_logs 
WHERE MATCH(message) AGAINST ('error exception' WITH QUERY EXPANSION)
    AND log_time >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY log_time DESC;
```

---

## 7. 🚀 实战应用与最佳实践


### 7.1 业务场景应用指南


**📊 查询方式选择决策树**

```
查询需求分析
       ↓
是否需要前缀匹配？
    ↓ 是          ↓ 否
  LIKE 'XX%'   是否复杂模式？
  + 前缀索引      ↓ 是        ↓ 否
              REGEXP     是否文本搜索？
                           ↓ 是      ↓ 否
                       FULLTEXT   LIKE '%XX%'
```

**🎯 实际业务案例分析**

**业务1：用户搜索功能**
```sql
-- 用户输入搜索关键词的处理策略
DELIMITER $$
CREATE PROCEDURE SearchUsers(IN search_term VARCHAR(255))
BEGIN
    -- 策略1：如果是精确匹配（短关键词）
    IF LENGTH(search_term) <= 3 THEN
        SELECT * FROM users 
        WHERE name LIKE CONCAT(search_term, '%')
           OR email LIKE CONCAT('%', search_term, '%');
    
    -- 策略2：如果是复杂搜索（长关键词）    
    ELSE
        SELECT *, MATCH(name, email, profile) AGAINST (search_term) AS score
        FROM users 
        WHERE MATCH(name, email, profile) AGAINST (search_term)
        ORDER BY score DESC;
    END IF;
END$$
DELIMITER ;
```

**业务2：商品分类筛选**
```sql
-- 多维度商品筛选优化
SELECT p.*, c.category_name
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE 
    -- 利用索引的精确条件先过滤
    p.status = 'active' 
    AND p.price BETWEEN 100 AND 1000
    AND c.parent_id = 1
    -- 再进行模糊匹配
    AND (
        p.name LIKE '%手机%' 
        OR p.description LIKE '%智能%'
        OR MATCH(p.name, p.description) AGAINST ('手机 智能' IN BOOLEAN MODE)
    )
ORDER BY p.sales_count DESC, p.created_at DESC;
```

### 7.2 性能监控与调优


**📈 查询性能监控**
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录

-- 分析具体查询的执行计划
EXPLAIN SELECT * FROM products WHERE name LIKE '%iPhone%';

-- 查看索引使用情况
SHOW INDEX FROM products;

-- 分析表的统计信息
ANALYZE TABLE products;
```

**🔧 查询优化检查清单**

┌─ ✅ 优化检查清单 ─────────┐
│ □ 是否可以避免%开头模式    │
│ □ 是否创建了合适的索引    │  
│ □ 是否使用了覆盖索引      │
│ □ 是否考虑了全文索引      │
│ □ 是否限制了返回记录数    │
│ □ 是否避免了SELECT *     │
└───────────────────────────┘

### 7.3 安全性考虑


**🔒 SQL注入防护**
```sql
-- ❌ 危险写法：直接拼接SQL
-- SET @sql = CONCAT("SELECT * FROM users WHERE name LIKE '%", input, "%'");

-- ✅ 安全写法：使用预处理语句
PREPARE stmt FROM 'SELECT * FROM users WHERE name LIKE ?';
SET @search_param = CONCAT('%', ?, '%');
EXECUTE stmt USING @search_param;
DEALLOCATE PREPARE stmt;
```

**🛡️ 应用层安全实践**
```java
// Java示例：使用PreparedStatement
public List<User> searchUsers(String keyword) {
    String sql = "SELECT * FROM users WHERE name LIKE ? OR email LIKE ?";
    
    try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
        String likePattern = "%" + keyword + "%";
        pstmt.setString(1, likePattern);
        pstmt.setString(2, likePattern);
        
        ResultSet rs = pstmt.executeQuery();
        // 处理结果...
    }
}
```

### 7.4 大数据量处理策略


**📊 分批处理优化**
```sql
-- 对大表进行分批模糊查询
-- 避免一次性查询太多数据导致超时
SELECT * FROM large_table 
WHERE name LIKE '张%'
    AND id > 1000000  -- 使用主键分页
ORDER BY id 
LIMIT 1000;

-- 使用游标处理大结果集
DELIMITER $$
CREATE PROCEDURE ProcessLargeResult()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_name VARCHAR(100);
    
    DECLARE cur CURSOR FOR 
        SELECT name FROM users WHERE name LIKE '李%';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO v_name;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 处理每行数据
        -- INSERT INTO processed_users VALUES(v_name);
        
    END LOOP;
    
    CLOSE cur;
END$$
DELIMITER ;
```

**🔍 读写分离优化**
```sql
-- 在读写分离架构中，模糊查询通常路由到只读库
-- 主库：处理写操作和实时性要求高的查询
-- 从库：处理复杂的模糊查询和分析查询

-- 应用层路由示例（伪代码）
if (query.contains("LIKE") || query.contains("REGEXP")) {
    // 路由到只读从库
    executeOnSlaveDB(query);
} else {
    // 路由到主库
    executeOnMasterDB(query);
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 LIKE模式匹配核心**
```
%通配符：匹配任意数量字符（包括0个）
_通配符：匹配恰好一个字符  
转义字符：处理数据中包含通配符的情况
前缀索引：优化以固定开头的模糊查询
```

**🔸 正则表达式REGEXP要点**
```  
更强大的模式匹配工具，适用于复杂查询需求
基本符号：^ $ . * + ? [] [^] () |
常用场景：数据验证、格式检查、数据清洗
性能考虑：比LIKE更耗资源，适合精确匹配需求
```

**🔸 全文索引FULLTEXT特点**
```
专为文本搜索设计，比LIKE效率高
三种模式：自然语言、布尔、查询扩展
适用场景：文章搜索、商品搜索、日志分析
配置要点：词长设置、停用词、中文支持
```

### 8.2 关键理解要点


**🔹 性能优化核心思路**
```
索引友好查询：
✅ 'ABC%'  - 可以利用前缀索引
❌ '%ABC%' - 无法利用索引，需全表扫描

查询改写策略：
- 先用精确条件过滤，再模糊匹配
- 使用UNION替代复杂OR条件  
- 考虑全文索引替代LIKE查询
```

**🔹 实际应用选择原则**
```
简单前缀匹配 → LIKE + 前缀索引
复杂模式匹配 → 正则表达式REGEXP  
自然语言搜索 → 全文索引FULLTEXT
大量数据查询 → 分批处理 + 读写分离
```

### 8.3 实践应用价值


**🎯 业务场景应用**
- **用户搜索**：姓名、邮箱模糊查询优化
- **商品检索**：商品名称、描述关键词搜索
- **内容搜索**：文章、评论全文检索功能
- **数据清洗**：格式验证、异常数据识别
- **日志分析**：错误日志模式匹配和过滤

**🔧 开发实践技巧**
- **安全防护**：使用预处理语句防止SQL注入
- **性能监控**：开启慢查询日志，分析执行计划
- **索引设计**：合理创建前缀索引和全文索引
- **查询优化**：避免%开头模式，合理使用覆盖索引

**💡 核心记忆要诀**
```
LIKE通配符：%多个字符，_单个字符
正则表达式：复杂模式，功能强大  
全文索引：文本搜索，性能最优
性能优化：索引先行，模式后置
安全第一：预处理语句，防注入攻击
```

**⚠️ 常见陷阱避免**
- 不要在大表上无索引地使用`%ABC%`模式
- 不要忽略转义字符处理特殊数据
- 不要在高并发场景滥用正则表达式
- 不要忘记为全文索引设置合适的最小词长
- 不要在没有LIMIT的情况下查询大表

**🚀 进阶学习方向**
- 深入学习MySQL查询优化器原理
- 掌握Elasticsearch等专业搜索引擎
- 了解分布式搜索架构设计
- 学习更多正则表达式高级特性
- 研究不同存储引擎的全文索引实现