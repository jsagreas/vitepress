---
title: 19、WHERE子句与HAVING子句
---
## 📚 目录


1. [WHERE与HAVING基本概念对比](#1-where与having基本概念对比)
2. [执行时机差异深度分析](#2-执行时机差异深度分析)
3. [性能影响对比分析](#3-性能影响对比分析)
4. [使用场景区别详解](#4-使用场景区别详解)
5. [错误使用案例剖析](#5-错误使用案例剖析)
6. [最佳实践选择指南](#6-最佳实践选择指南)
7. [混合使用策略技巧](#7-混合使用策略技巧)
8. [核心要点总结](#8-核心要点总结)

---

# 1. 🔍 WHERE与HAVING基本概念对比



## 1.1 概念本质理解



**WHERE子句**：就像是**门卫**，在数据进入查询处理之前就把不符合条件的记录挡在外面。

```
🏢 公司招聘比喻：
WHERE = 简历筛选阶段
• 直接看个人基本信息
• 学历不符合直接淘汰
• 工作经验不够直接pass
```

**HAVING子句**：就像是**质检员**，等数据分组统计完毕后，再检查统计结果是否符合要求。

```
🏭 生产线比喻：
HAVING = 成品质检阶段  
• 等产品生产完成后检查
• 看整批产品的合格率
• 批次总数量是否达标
```

## 1.2 核心区别速览



| 🆚 对比项 | **WHERE子句** | **HAVING子句** | 💡 记忆要点 |
|----------|---------------|----------------|-------------|
| **作用时机** | 📥 分组**之前**过滤 | 📤 分组**之后**过滤 | WHERE先筛，HAVING后检 |
| **处理对象** | 🔸 单个**行记录** | 📊 **分组结果** | WHERE看行，HAVING看组 |
| **可用函数** | ❌ 不能用聚合函数 | ✅ 专门用聚合函数 | WHERE普通，HAVING聚合 |
| **性能特点** | ⚡ **高效**（早期过滤） | 🐌 **较慢**（处理后过滤） | WHERE快，HAVING慢 |
| **数据范围** | 🎯 **原始数据**筛选 | 📈 **统计结果**筛选 | WHERE原始，HAVING统计 |

---

# 2. ⏰ 执行时机差异深度分析



## 2.1 SQL查询执行顺序详解



```
🔄 SQL语句完整执行流程：

第1步：FROM     ← 确定数据来源表
  ↓
第2步：WHERE    ← 🎯 行级过滤（单条记录判断）
  ↓
第3步：GROUP BY ← 数据分组聚合
  ↓
第4步：HAVING   ← 🎯 组级过滤（分组结果判断）
  ↓
第5步：SELECT   ← 选择要显示的列
  ↓  
第6步：ORDER BY ← 结果排序
  ↓
第7步：LIMIT    ← 限制结果数量
```

## 2.2 执行时机实例演示



🎭 **场景模拟**：统计各部门平均工资超过8000的部门信息

```sql
-- 示例数据表：员工表
CREATE TABLE employees (
    id INT,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2)
);

-- 查询语句
SELECT department, AVG(salary) as avg_salary
FROM employees 
WHERE salary > 5000        -- ⚡ 执行时机：第2步
GROUP BY department
HAVING AVG(salary) > 8000; -- ⚡ 执行时机：第4步
```

**详细执行过程分析：**

```
📊 数据处理流程可视化：

原始数据(1000条) 
        ↓
    WHERE过滤 ← 先过滤掉工资<=5000的员工
        ↓
   筛选后数据(600条)
        ↓
    GROUP BY分组 ← 按部门分组计算平均工资
        ↓
   分组统计结果(8个部门)
   ┌─────────┬──────────┐
   │ 部门    │ 平均工资  │
   ├─────────┼──────────┤
   │ 技术部  │ 9500     │
   │ 销售部  │ 7800     │  
   │ 财务部  │ 8200     │
   │ ...     │ ...      │
   └─────────┴──────────┘
        ↓
    HAVING过滤 ← 再过滤掉平均工资<=8000的部门
        ↓
   最终结果(5个部门)
```

## 2.3 时机差异的实际影响



**🔰 入门理解**：WHERE是"预筛选"，HAVING是"后检验"

```
🏪 超市购物比喻：
WHERE = 进店时的体温检查
• 体温正常才能进店购物
• 在购物行为发生之前

HAVING = 收银台的购物金额检查  
• 满100元才能享受折扣
• 在购物完成、计算总额之后
```

**🔸 进阶理解**：执行时机决定了性能和功能差异

- **WHERE早期过滤**：减少后续处理的数据量，提升整体性能
- **HAVING后期过滤**：处理聚合计算结果，实现复杂统计需求

---

# 3. 📊 性能影响对比分析



## 3.1 性能差异根本原因



**WHERE性能优势分析：**

```
⚡ WHERE高性能原理：

数据流向：
原始数据(100万条) → WHERE过滤 → 剩余数据(10万条) → 后续处理

性能收益：
• 🔥 减少GROUP BY处理的数据量(90%减少)
• 🔥 减少内存占用(大幅节省)
• 🔥 减少CPU计算量(10倍提升)
• 🔥 可以利用索引优化(关键优势)
```

**HAVING性能特点分析：**

```
🐌 HAVING性能特点：

数据流向：
原始数据(100万条) → GROUP BY处理 → 分组结果 → HAVING过滤

性能特点：
• 📈 必须处理所有原始数据
• 📈 完成分组聚合计算后才能过滤
• 📈 无法利用普通字段索引
• 📈 内存和CPU消耗相对较大
```

## 3.2 性能测试对比实例



🔬 **性能测试场景**：100万员工数据，查询平均工资超过8000的部门

**方案1：WHERE优化（推荐）**
```sql
-- ✅ 高性能方案
SELECT department, AVG(salary) 
FROM employees 
WHERE salary > 3000          -- 先过滤掉低工资员工
GROUP BY department 
HAVING AVG(salary) > 8000;

-- 执行统计：
-- 原始数据：1,000,000 条
-- WHERE过滤后：300,000 条 (减少70%)
-- 执行时间：1.2秒
```

**方案2：无WHERE优化（不推荐）**
```sql
-- ❌ 低性能方案
SELECT department, AVG(salary)
FROM employees 
GROUP BY department 
HAVING AVG(salary) > 8000;

-- 执行统计：
-- 处理数据：1,000,000 条 (全表扫描)
-- 执行时间：4.8秒 (慢4倍)
```

## 3.3 索引利用效果对比



| 📊 对比维度 | **WHERE子句** | **HAVING子句** |
|-------------|---------------|----------------|
| **索引利用** | ✅ 可以充分利用列索引 | ❌ 无法利用普通索引 |
| **查询计划** | 🎯 索引扫描 → 快速定位 | 📊 全表扫描 → 逐行处理 |
| **内存占用** | 💚 较少（早期过滤） | 💛 较多（全量处理） |
| **适用数据量** | 🚀 大数据量友好 | ⚠️ 小数据量尚可 |

**💡 性能优化提示：**
```
🎯 性能最佳实践：
1. 尽量在WHERE子句中过滤数据
2. 将可以提前过滤的条件写在WHERE中
3. HAVING只用于聚合结果的条件判断
4. 为WHERE条件字段建立合适的索引
```

---

# 4. 🎯 使用场景区别详解



## 4.1 WHERE适用场景详解



**🔰 WHERE专属场景**：需要对**单条记录**进行判断筛选

**场景1：基础数据筛选**
```sql
-- ✅ 经典WHERE使用：筛选特定条件的员工
SELECT * FROM employees 
WHERE age > 25 AND department = '技术部';
-- 含义：找出技术部年龄超过25岁的员工
```

**场景2：日期范围筛选**
```sql
-- ✅ 时间段数据查询
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' 
  AND order_date < '2024-02-01';
-- 含义：查询2024年1月份的所有订单
```

**场景3：字符串模糊查询**
```sql
-- ✅ 模糊匹配查询
SELECT * FROM products 
WHERE product_name LIKE '%手机%' 
  AND price BETWEEN 1000 AND 5000;
-- 含义：查找价格在1000-5000元的手机产品
```

## 4.2 HAVING专属场景详解



**🔸 HAVING专属场景**：需要对**分组统计结果**进行判断筛选

**场景1：统计数据过滤**
```sql
-- ✅ 经典HAVING使用：筛选满足统计条件的分组
SELECT department, COUNT(*) as emp_count
FROM employees 
GROUP BY department 
HAVING COUNT(*) >= 10;
-- 含义：找出员工数量不少于10人的部门
```

**场景2：聚合计算结果筛选**
```sql
-- ✅ 聚合函数结果判断
SELECT customer_id, SUM(order_amount) as total_amount
FROM orders 
WHERE order_date >= '2024-01-01'
GROUP BY customer_id 
HAVING SUM(order_amount) > 50000;
-- 含义：找出2024年消费总额超过5万元的客户
```

**场景3：复杂统计条件**
```sql
-- ✅ 多重聚合条件判断
SELECT product_category, 
       COUNT(*) as product_count,
       AVG(price) as avg_price
FROM products 
GROUP BY product_category 
HAVING COUNT(*) > 5 
   AND AVG(price) > 1000;
-- 含义：找出产品数量超过5个且平均价格超过1000元的品类
```

## 4.3 场景选择决策树



```
❓ 如何选择WHERE还是HAVING？

问题：我要过滤的是什么？
    ├─ 单条记录的字段值？
    │   └─ ✅ 使用WHERE
    │       例：年龄>25, 部门='销售部'
    │
    └─ 分组后的统计结果？
        └─ ✅ 使用HAVING  
            例：COUNT(*)>10, AVG(salary)>8000

问题：我的条件中是否包含聚合函数？
    ├─ 没有聚合函数 → ✅ 使用WHERE
    └─ 有聚合函数 → ✅ 使用HAVING
```

---

# 5. ❌ 错误使用案例剖析



## 5.1 常见错误类型1：WHERE中使用聚合函数



**❌ 错误写法：**
```sql
-- 这样写会报错！
SELECT department, AVG(salary) 
FROM employees 
WHERE AVG(salary) > 8000    -- ❌ WHERE不能使用聚合函数
GROUP BY department;

-- 错误信息：Invalid use of group function
```

**🔍 错误原因分析：**
```
❌ 为什么不能这样写？

执行顺序问题：
WHERE执行时机 → 分组之前
AVG()计算时机 → 分组之后

时间矛盾：
WHERE执行时，AVG(salary)还没有计算出来！
就像还没考试就想知道平均分一样不合理。
```

**✅ 正确写法：**
```sql
-- 正确的写法
SELECT department, AVG(salary) 
FROM employees 
GROUP BY department
HAVING AVG(salary) > 8000;   -- ✅ 在HAVING中使用聚合函数
```

## 5.2 常见错误类型2：HAVING中过滤非聚合条件



**❌ 低效写法：**
```sql
-- 可以运行但性能很差
SELECT department, COUNT(*) 
FROM employees 
GROUP BY department 
HAVING department != '实习部';  -- ❌ 应该放在WHERE中
```

**🔍 性能问题分析：**
```
📊 性能损失分析：

低效流程：
所有部门数据 → 分组计算 → 过滤掉"实习部" 
• 浪费CPU计算实习部的COUNT()
• 浪费内存存储实习部的分组数据

高效流程：  
过滤掉实习部 → 剩余部门数据 → 分组计算
• 减少分组计算的数据量
• 节省内存和CPU资源
```

**✅ 正确优化写法：**
```sql
-- 性能优化版本
SELECT department, COUNT(*) 
FROM employees 
WHERE department != '实习部'   -- ✅ 提前过滤，提升性能
GROUP BY department;
```

## 5.3 常见错误类型3：混淆使用场景



**❌ 场景理解错误：**
```sql
-- 需求：查询每个部门平均工资，但只看工资大于5000的员工
-- 错误理解：认为需要在HAVING中限制工资

-- 错误写法1：
SELECT department, AVG(salary)
FROM employees 
GROUP BY department 
HAVING salary > 5000;        -- ❌ HAVING中不能直接使用非聚合字段

-- 错误写法2：
SELECT department, AVG(salary)
FROM employees 
GROUP BY department 
HAVING AVG(salary) > 5000;   -- ❌ 逻辑错误：限制的是平均工资而非个人工资
```

**✅ 正确理解与写法：**
```sql
-- 正确写法：先过滤个人工资，再计算部门平均工资
SELECT department, AVG(salary) as avg_salary
FROM employees 
WHERE salary > 5000          -- ✅ 先筛选工资>5000的员工
GROUP BY department;         -- 然后计算这些员工的部门平均工资
```

## 5.4 错误使用的性能损失量化



| 🔍 错误类型 | **性能损失** | **资源浪费** | **修复难度** |
|-------------|-------------|-------------|-------------|
| WHERE中用聚合函数 | ❌ 无法执行 | 💀 SQL报错 | 🟢 简单 |
| HAVING过滤非聚合 | 📈 性能下降50-80% | 💰 CPU+内存浪费 | 🟡 中等 |
| 场景混淆使用 | 📊 逻辑错误 | 🤔 结果不正确 | 🔴 复杂 |

---

# 6. 💡 最佳实践选择指南



## 6.1 选择决策流程图



```
🎯 WHERE vs HAVING 选择决策流程：

开始：我需要添加查询条件
  ↓
问题1：这个条件是否包含聚合函数？
  ├─ 是 → 问题2：是否需要分组？
  │      ├─ 是 → ✅ 使用HAVING
  │      └─ 否 → ❌ 重新思考需求
  │
  └─ 否 → 问题3：是否可以提前过滤数据？
         ├─ 是 → ✅ 使用WHERE（推荐）
         └─ 否 → 🤔 考虑是否真的需要HAVING
```

## 6.2 最佳实践原则



**🥇 黄金原则1：能用WHERE就不用HAVING**

```sql
-- ✅ 推荐做法：优先使用WHERE
SELECT department, COUNT(*) 
FROM employees 
WHERE salary > 5000          -- 优先：能提前过滤的条件放WHERE
  AND department != '实习部' 
GROUP BY department 
HAVING COUNT(*) >= 10;       -- 必要：聚合结果判断用HAVING
```

**🥈 黄金原则2：WHERE和HAVING各司其职**

| 📝 使用原则 | **WHERE负责** | **HAVING负责** |
|-------------|--------------|---------------|
| **数据范围** | 🎯 原始数据行级过滤 | 📊 分组结果组级过滤 |
| **函数类型** | 🔧 普通函数、运算符 | 📈 聚合函数结果 |
| **性能责任** | ⚡ 提升查询性能 | ✅ 实现业务逻辑 |
| **执行目标** | 🚀 减少处理数据量 | 🎯 精确筛选结果 |

**🥉 黄金原则3：组合使用发挥最大效能**

```sql
-- 🏆 完美组合示例：电商订单分析
SELECT 
    customer_city,                    -- 城市
    COUNT(*) as order_count,          -- 订单数量
    SUM(order_amount) as total_amount -- 订单总额
FROM orders 
WHERE order_date >= '2024-01-01'     -- WHERE：时间范围预筛选
  AND order_status = 'completed'     -- WHERE：订单状态预筛选
  AND order_amount > 100             -- WHERE：订单金额预筛选
GROUP BY customer_city 
HAVING COUNT(*) >= 50                -- HAVING：订单数量统计筛选
   AND SUM(order_amount) > 100000;   -- HAVING：总金额统计筛选
```

## 6.3 特殊场景最佳实践



**场景1：数据质量检查**
```sql
-- ✅ 最佳实践：检查数据异常
SELECT department, 
       COUNT(*) as emp_count,
       AVG(salary) as avg_salary
FROM employees 
WHERE salary > 0                     -- WHERE：过滤异常数据
  AND hire_date IS NOT NULL 
GROUP BY department 
HAVING COUNT(*) > 1                  -- HAVING：过滤样本过小的部门
   AND AVG(salary) > 3000           -- HAVING：过滤平均工资异常的部门
   AND AVG(salary) < 50000;
```

**场景2：分层统计分析**
```sql
-- ✅ 最佳实践：多维度分析
SELECT 
    product_category,
    price_level,
    COUNT(*) as product_count,
    AVG(sales_volume) as avg_sales
FROM products 
WHERE is_active = 1                  -- WHERE：只看在售商品
  AND launch_date >= '2023-01-01'    -- WHERE：只看近期产品
GROUP BY product_category, 
         CASE 
           WHEN price < 100 THEN '低价'
           WHEN price < 1000 THEN '中价' 
           ELSE '高价' 
         END
HAVING COUNT(*) >= 5                 -- HAVING：样本数量充足
   AND AVG(sales_volume) > 100;      -- HAVING：销量表现良好
```

---

# 7. 🤝 混合使用策略技巧



## 7.1 分层过滤策略



**🔰 基础混合使用模式**

```sql
-- 🎯 三层过滤模式：
SELECT column_list
FROM table_name 
WHERE row_condition              -- 第1层：行级预过滤
GROUP BY group_columns 
HAVING aggregate_condition       -- 第2层：组级后过滤
ORDER BY sort_columns 
LIMIT result_count;              -- 第3层：结果数量限制
```

**🔸 高级混合使用实例**

```sql
-- 📊 复杂业务场景：电商平台销售分析
SELECT 
    seller_region,                           -- 商家地区
    product_category,                        -- 商品类别  
    COUNT(DISTINCT seller_id) as seller_count, -- 商家数量
    COUNT(*) as product_count,               -- 商品数量
    AVG(price) as avg_price,                 -- 平均价格
    SUM(monthly_sales) as total_sales        -- 总销量
FROM products p
JOIN sellers s ON p.seller_id = s.id
WHERE s.status = 'active'                    -- WHERE：只看活跃商家
  AND p.is_available = 1                     -- WHERE：只看可售商品  
  AND p.price > 10                           -- WHERE：过滤低价商品
  AND p.created_date >= '2024-01-01'         -- WHERE：只看今年新品
GROUP BY seller_region, product_category
HAVING COUNT(DISTINCT seller_id) >= 3        -- HAVING：商家数量充足
   AND COUNT(*) >= 20                        -- HAVING：商品数量充足
   AND AVG(price) > 50                       -- HAVING：平均价格合理
   AND SUM(monthly_sales) > 1000             -- HAVING：总销量达标
ORDER BY total_sales DESC
LIMIT 20;
```

## 7.2 性能优化混合策略



**⚡ 性能优化组合技巧**

```sql
-- 🚀 高性能查询模式
SELECT 
    department,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary
FROM employees 
WHERE salary BETWEEN 5000 AND 50000         -- 优化1：范围预筛选
  AND hire_date >= DATE_SUB(NOW(), INTERVAL 5 YEAR) -- 优化2：时间范围
  AND status = 'active'                      -- 优化3：状态筛选
  AND department IN ('技术部','产品部','运营部') -- 优化4：部门白名单
GROUP BY department 
HAVING COUNT(*) >= 10                        -- 业务需求：部门规模
   AND AVG(salary) > 8000;                   -- 业务需求：薪资水平

-- 性能提升效果：
-- 原始数据：100万行 → WHERE过滤后：5万行 (减少95%)
-- 查询时间：从15秒 → 2秒 (提升7.5倍)
```

## 7.3 复杂业务逻辑实现



**🎭 场景1：多维度数据质量检查**

```sql
-- 🔍 数据质量检查综合查询
SELECT 
    data_source,
    data_type,
    DATE(created_at) as check_date,
    COUNT(*) as total_records,           -- 总记录数
    COUNT(CASE WHEN quality_score > 80 THEN 1 END) as high_quality, -- 高质量记录
    AVG(quality_score) as avg_quality,   -- 平均质量分
    MIN(quality_score) as min_quality,   -- 最低质量分
    MAX(quality_score) as max_quality    -- 最高质量分
FROM data_quality_log 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)  -- 近30天数据
  AND status != 'deleted'                             -- 排除已删除
  AND quality_score IS NOT NULL                       -- 有质量分的记录
GROUP BY data_source, data_type, DATE(created_at)
HAVING COUNT(*) >= 100                                -- 样本量充足
   AND AVG(quality_score) >= 60                       -- 平均质量合格
   AND COUNT(CASE WHEN quality_score > 80 THEN 1 END) / COUNT(*) >= 0.3; -- 高质量占比30%+
```

**🎭 场景2：用户行为分析**

```sql
-- 👤 用户行为深度分析
SELECT 
    user_level,                          -- 用户等级
    register_channel,                    -- 注册渠道
    COUNT(DISTINCT user_id) as user_count, -- 用户数量
    AVG(login_days) as avg_login_days,     -- 平均登录天数
    AVG(order_count) as avg_order_count,   -- 平均订单数
    SUM(total_amount) as revenue           -- 总营收
FROM user_behavior_summary 
WHERE register_date >= '2024-01-01'       -- 今年注册用户
  AND user_status = 'active'              -- 活跃用户
  AND total_amount > 0                    -- 有消费记录
GROUP BY user_level, register_channel
HAVING COUNT(DISTINCT user_id) >= 50      -- 用户群体足够大
   AND AVG(login_days) >= 10              -- 活跃度达标
   AND SUM(total_amount) >= 10000         -- 营收贡献显著
ORDER BY revenue DESC;
```

## 7.4 混合使用避坑指南



**⚠️ 混合使用常见陷阱**

| 🚨 陷阱类型 | **错误示例** | **正确做法** | **避坑技巧** |
|-------------|-------------|-------------|-------------|
| **逻辑重复** | WHERE和HAVING写相同条件 | 将非聚合条件放WHERE | 📝 检查条件重复 |
| **性能浪费** | HAVING中过滤基础字段 | 基础过滤优先放WHERE | ⚡ 提前过滤原则 |
| **条件冲突** | WHERE过滤与HAVING矛盾 | 理清过滤逻辑先后 | 🎯 明确业务逻辑 |
| **函数误用** | WHERE中使用聚合函数 | 聚合函数只在HAVING | 📚 记住执行顺序 |

**💡 混合使用检查清单**
```
✅ 混合使用自检清单：

□ WHERE条件是否都是行级过滤？
□ HAVING条件是否都包含聚合函数？  
□ 能提前过滤的条件是否都在WHERE中？
□ 是否避免了WHERE和HAVING的条件重复？
□ GROUP BY字段是否合理？
□ 查询逻辑是否符合业务需求？
□ 性能是否已经优化到最佳？
```

---

# 8. 📋 核心要点总结



## 8.1 必须掌握的核心概念



```
🎯 WHERE vs HAVING 核心差异：

执行时机：
• WHERE → 分组之前过滤（行级筛选）
• HAVING → 分组之后过滤（组级筛选）

功能定位：
• WHERE → 数据预处理，性能优化
• HAVING → 结果后处理，业务逻辑

使用场景：
• WHERE → 基础字段条件判断
• HAVING → 聚合函数结果判断
```

## 8.2 关键理解要点



**🔹 为什么要区分WHERE和HAVING？**
```
设计理由：
• 满足不同阶段的过滤需求
• 提供性能优化的可能性  
• 实现复杂统计分析功能
• 保持SQL逻辑的清晰性

实际价值：
• WHERE提升查询性能（核心优势）
• HAVING实现统计筛选（独特功能）
• 组合使用解决复杂业务需求
```

**🔹 如何记忆使用规则？**
```
🧠 记忆口诀：
WHERE筛行HAVING筛组，
聚合函数HAVING独有，
性能优先WHERE过滤，
先筛后算效率优。

🎯 判断方法：
看条件 → 有聚合函数？
   ├─ 有 → HAVING
   └─ 无 → WHERE (优先选择)
```

## 8.3 实际应用价值



**💼 业务场景应用**
- **数据分析**：WHERE预筛选+HAVING统计筛选实现多层分析
- **报表查询**：组合使用提升报表生成效率
- **数据质检**：分层过滤确保数据质量和统计准确性
- **性能优化**：合理使用WHERE大幅提升查询性能

**🔧 开发实践**
- **SQL调优**：识别HAVING误用，移至WHERE提升性能
- **逻辑设计**：合理分层过滤条件，保持代码清晰
- **错误排查**：理解执行顺序，快速定位SQL错误
- **代码审查**：检查WHERE/HAVING使用是否符合最佳实践

## 8.4 学习检验标准



**✅ 掌握程度自检**
```
🔰 基础掌握：
□ 能说出WHERE和HAVING的执行时机差异
□ 知道哪些条件应该放在WHERE，哪些放在HAVING
□ 理解为什么WHERE不能使用聚合函数

🔸 进阶掌握：  
□ 能优化包含WHERE/HAVING的慢查询
□ 会设计复杂的分层过滤逻辑
□ 理解性能差异的根本原因

🔹 精通掌握：
□ 能在复杂业务场景中灵活运用组合策略
□ 会根据数据特点选择最优的过滤方案
□ 能指导他人避免常见使用错误
```

**核心记忆**：
- WHERE和HAVING不是可替换的关系，而是分工明确的合作关系
- WHERE负责提升性能，HAVING负责实现逻辑
- 性能优化的关键是让WHERE承担更多过滤责任
- 组合使用才能发挥SQL查询的最大威力