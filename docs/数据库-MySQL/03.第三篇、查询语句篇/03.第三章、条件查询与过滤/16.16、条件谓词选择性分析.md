---
title: 16、条件谓词选择性分析
---
## 📚 目录

1. [谓词选择性基础概念](#1-谓词选择性基础概念)
2. [选择性计算方法与原理](#2-选择性计算方法与原理)
3. [条件过滤率评估技术](#3-条件过滤率评估技术)
4. [索引选择性影响分析](#4-索引选择性影响分析)
5. [统计信息与准确性保障](#5-统计信息与准确性保障)
6. [选择性驱动的查询优化](#6-选择性驱动的查询优化)
7. [实战应用与性能调优](#7-实战应用与性能调优)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 谓词选择性基础概念


### 1.1 什么是谓词选择性


**🔸 谓词选择性定义**
```
谓词选择性(Predicate Selectivity)：指查询条件能够过滤掉多少数据的度量指标

简单理解：
• 选择性 = 满足条件的记录数 / 总记录数
• 取值范围：0到1之间
• 数值越小，过滤效果越好

举例说明：
表中有10000条记录
WHERE age > 60 返回500条记录
选择性 = 500/10000 = 0.05 = 5%
```

**💡 为什么要关心选择性？**
```
数据库优化器的核心工作：
1. 估算每个查询条件的选择性
2. 根据选择性选择最优执行计划
3. 决定是否使用索引

实际影响：
• 高选择性(接近1)：条件过滤效果差，可能全表扫描
• 低选择性(接近0)：条件过滤效果好，优先考虑索引
```

### 1.2 选择性的实际意义


**📊 选择性与查询性能的关系**
```
选择性范围对应的查询特征：

选择性 < 0.01 (1%)    🟢 优秀
├─ 索引扫描效率极高
├─ I/O开销很小
└─ 查询响应快速

选择性 0.01-0.1 (1%-10%)  🟡 良好  
├─ 索引扫描仍然有效
├─ 需要关注索引质量
└─ 可能需要复合索引

选择性 0.1-0.3 (10%-30%)   🟠 一般
├─ 索引效果开始下降
├─ 考虑其他优化手段
└─ 可能出现索引与全表扫描的临界点

选择性 > 0.3 (30%)         🔴 较差
├─ 全表扫描可能更优
├─ 索引扫描I/O开销大
└─ 需要重新设计查询或索引
```

### 1.3 谓词类型与选择性特征


**🔍 不同谓词类型的选择性规律**
```
等值谓词 (=)：
SELECT * FROM users WHERE id = 123;
• 主键/唯一键：选择性通常很低(理想情况1/N)
• 普通列：取决于数据分布的均匀程度
• 适合使用B-tree索引

范围谓词 (>, <, BETWEEN)：
SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';
• 选择性取决于范围大小和数据分布
• 时间范围查询选择性相对可控
• B-tree索引效果良好

模糊匹配谓词 (LIKE)：
SELECT * FROM products WHERE name LIKE 'iPhone%';
• 前缀匹配：选择性相对较好，可用索引
• 包含匹配：选择性通常较差，索引失效
• 通配符位置影响索引使用

逻辑谓词 (AND, OR, NOT)：
SELECT * FROM users WHERE age > 25 AND city = 'Beijing';
• AND操作：选择性 = 各条件选择性的乘积
• OR操作：选择性 = 1 - (1-选择性1) × (1-选择性2)
• NOT操作：选择性 = 1 - 原条件选择性
```

---

## 2. 🧮 选择性计算方法与原理


### 2.1 基础选择性计算公式


**📐 核心计算公式详解**
```
基本选择性公式：
Selectivity = |符合条件的行数| / |表总行数|

记号说明：
• S(P) = 谓词P的选择性
• |R| = 关系R的总行数  
• |σ_P(R)| = 满足谓词P的行数
• 公式：S(P) = |σ_P(R)| / |R|

实例计算：
表employees（100,000行）
WHERE salary > 80000 返回15,000行
S(salary > 80000) = 15,000 / 100,000 = 0.15
```

**💰 不同数据类型的选择性估算**
```
数值类型选择性估算：
对于连续值域[min, max]中的范围查询
WHERE column BETWEEN v1 AND v2
选择性估算 ≈ (v2 - v1) / (max - min)

示例：
salary字段范围[30000, 200000]  
WHERE salary BETWEEN 60000 AND 80000
选择性 ≈ (80000-60000)/(200000-30000) = 20000/170000 ≈ 0.118

字符串类型选择性估算：
WHERE name = 'John'
如果name有1000个不同值，假设均匀分布
选择性 ≈ 1/1000 = 0.001

日期类型选择性估算：
WHERE order_date >= '2024-01-01'  
如果数据跨度2年(730天)，查询最近365天
选择性 ≈ 365/730 = 0.5
```

### 2.2 复合条件选择性计算


**🔗 AND条件选择性计算**
```
独立条件假设：
S(P1 AND P2) = S(P1) × S(P2)

实例计算：
WHERE age > 30 AND city = 'Shanghai'
假设：S(age > 30) = 0.4, S(city = 'Shanghai') = 0.1  
S(age > 30 AND city = 'Shanghai') = 0.4 × 0.1 = 0.04

注意：独立性假设不总是成立！
年龄和收入可能相关，城市和收入也可能相关
实际选择性可能与计算值有偏差
```

**🔄 OR条件选择性计算**
```
OR条件计算公式：
S(P1 OR P2) = S(P1) + S(P2) - S(P1 AND P2)

简化计算（假设条件独立）：
S(P1 OR P2) = S(P1) + S(P2) - S(P1) × S(P2)
             = 1 - (1 - S(P1)) × (1 - S(P2))

实例计算：
WHERE salary > 100000 OR age < 25
假设：S(salary > 100000) = 0.1, S(age < 25) = 0.2
S(OR条件) = 0.1 + 0.2 - 0.1 × 0.2 = 0.3 - 0.02 = 0.28
```

**❌ NOT条件选择性计算**
```
NOT条件计算：
S(NOT P) = 1 - S(P)

实例：
WHERE NOT (status = 'inactive')  
如果S(status = 'inactive') = 0.05
则S(NOT (status = 'inactive')) = 1 - 0.05 = 0.95

应用场景：
• 排除少量异常数据
• 选择大部分正常记录
• 通常导致高选择性，需谨慎使用索引
```

### 2.3 直方图辅助的精确计算


**📊 直方图统计信息**
```
什么是直方图：
• 将列的值域划分为若干个桶(bucket)
• 每个桶记录值的范围和频次
• 提供比简单统计更精确的分布信息

直方图类型：
等宽直方图：每个桶的值域范围相等
等高直方图：每个桶包含相近数量的记录
混合直方图：结合等宽和等高的优点

选择性计算改进：
不再假设均匀分布，而是基于实际的数据分布
能处理数据偏斜(data skew)的情况
```

**🎯 基于直方图的精确估算示例**
```sql
-- 示例表：订单表，包含订单金额
-- 假设order_amount的直方图如下：
-- 桶1: [0-100]     频次: 40000 (40%)
-- 桶2: [100-500]   频次: 30000 (30%)  
-- 桶3: [500-1000]  频次: 20000 (20%)
-- 桶4: [1000-5000] 频次: 10000 (10%)

-- 查询条件：WHERE order_amount > 300
-- 计算过程：
-- 桶1: 完全不符合条件，贡献0
-- 桶2: 部分符合，估算 (500-300)/(500-100) × 30000 = 15000
-- 桶3: 完全符合，贡献 20000  
-- 桶4: 完全符合，贡献 10000
-- 总计符合条件：15000 + 20000 + 10000 = 45000
-- 选择性：45000 / 100000 = 0.45
```

---

## 3. 📈 条件过滤率评估技术


### 3.1 过滤率评估的核心意义


**🎯 过滤率与执行计划的关系**
```
过滤率(Filter Ratio)：描述查询条件筛选数据的能力

与选择性的关系：
过滤率 = 1 - 选择性
• 过滤率越高，剩余数据越少  
• 过滤率越低，剩余数据越多

执行计划影响：
高过滤率(> 90%)  → 优先使用索引扫描
中过滤率(50%-90%) → 权衡索引与全表扫描  
低过滤率(< 50%)   → 可能选择全表扫描

┌─ 过滤率评估决策树 ─────────────────┐
│                                   │
│ 过滤率 > 95%  → 必须使用索引       │  
│ 过滤率 80-95% → 倾向使用索引       │
│ 过滤率 50-80% → 综合评估代价       │
│ 过滤率 < 50%  → 倾向全表扫描       │
│                                   │
└───────────────────────────────────┘
```

### 3.2 多条件过滤率综合评估


**⚖️ 条件执行顺序优化**
```
条件执行顺序原则：
1. 按过滤率从高到低排序
2. 优先执行计算成本低的条件
3. 考虑条件之间的相关性

示例查询分析：
SELECT * FROM employees 
WHERE department = 'Engineering'    -- 过滤率85%，成本低
  AND salary > 120000              -- 过滤率70%，成本低  
  AND UPPER(name) LIKE '%JOHN%'    -- 过滤率40%，成本高

优化后的执行顺序：
1. department = 'Engineering'     (高过滤率+低成本)
2. salary > 120000               (中过滤率+低成本)  
3. UPPER(name) LIKE '%JOHN%'     (低过滤率+高成本)

执行流程图：
1000000行 
    ↓ department过滤(85%)
150000行
    ↓ salary过滤(70%) 
45000行
    ↓ name模糊匹配(40%)
18000行 → 最终结果
```

**🔄 动态过滤率调整**
```
静态估算的局限性：
• 基于历史统计信息
• 无法反映实时数据变化
• 可能存在估算偏差

动态调整机制：
运行时监控：记录实际过滤效果
自适应调整：根据实际情况修正估算
反馈优化：将运行结果反馈给优化器

实现示例：
-- 执行前估算：department = 'Sales' 过滤率预期80%
-- 执行后统计：实际过滤率只有60%
-- 系统学习：更新该条件的过滤率估算参数
-- 下次查询：使用修正后的60%进行计划选择
```

### 3.3 过滤率评估的实用技术


**📊 采样估算技术**
```sql
-- 大表过滤率快速估算
-- 采样1%的数据进行过滤率评估
WITH sample_data AS (
    SELECT * 
    FROM large_table 
    TABLESAMPLE SYSTEM (1)  -- 采样1%
)
SELECT 
    COUNT(*) as total_sample,
    COUNT(CASE WHEN your_condition THEN 1 END) as filtered_count,
    COUNT(CASE WHEN your_condition THEN 1 END) * 1.0 / COUNT(*) as estimated_filter_rate
FROM sample_data;

-- 多条件组合过滤率评估
WITH condition_analysis AS (
    SELECT 
        COUNT(*) as total_rows,
        COUNT(CASE WHEN cond1 THEN 1 END) as cond1_match,
        COUNT(CASE WHEN cond2 THEN 1 END) as cond2_match,  
        COUNT(CASE WHEN cond1 AND cond2 THEN 1 END) as both_match
    FROM sample_table
)
SELECT 
    cond1_match * 1.0 / total_rows as cond1_selectivity,
    cond2_match * 1.0 / total_rows as cond2_selectivity,
    both_match * 1.0 / total_rows as combined_selectivity,
    -- 独立性检验
    ABS((both_match * 1.0 / total_rows) - 
        (cond1_match * 1.0 / total_rows) * (cond2_match * 1.0 / total_rows)) as independence_deviation
FROM condition_analysis;
```

---

## 4. 📇 索引选择性影响分析


### 4.1 索引选择性基础概念


**🔑 索引选择性定义**
```
索引选择性 = 唯一值个数 / 总记录数

理解要点：
• 选择性越高，索引效果越好
• 主键索引选择性 = 1（理想状态）
• 性别字段选择性 ≈ 0.5（较差）
• 身份证号选择性 ≈ 1（很好）

计算示例：
员工表100,000条记录
部门字段有10个不同值：索引选择性 = 10/100,000 = 0.0001  
员工ID有100,000个不同值：索引选择性 = 100,000/100,000 = 1
姓名字段有85,000个不同值：索引选择性 = 85,000/100,000 = 0.85
```

**📊 选择性与索引效果对照表**

| 选择性范围 | 索引效果 | 典型字段示例 | 使用建议 |
|-----------|---------|-------------|---------|
| `> 0.8` | 🟢 **优秀** | `主键、身份证号、邮箱` | `强烈推荐建索引` |
| `0.3-0.8` | 🟡 **良好** | `姓名、电话号码、订单号` | `适合建索引` |
| `0.1-0.3` | 🟠 **一般** | `城市、职位级别` | `考虑复合索引` |
| `< 0.1` | 🔴 **较差** | `性别、状态标志` | `不建议单独建索引` |

### 4.2 低选择性字段的索引策略


**🛠️ 低选择性字段优化技巧**
```sql
-- 问题：status字段只有3个值(active/inactive/pending)，选择性很低
-- 直接索引效果差
CREATE INDEX idx_status ON users(status);  -- 不推荐

-- 解决方案1：复合索引
CREATE INDEX idx_status_created ON users(status, created_date);
-- 查询时能利用复合索引的联合选择性

-- 解决方案2：功能索引（部分索引）
CREATE INDEX idx_active_users ON users(id) 
WHERE status = 'active';  -- 只索引活跃用户

-- 解决方案3：位图索引（某些数据库支持）
-- Oracle等数据库中，低选择性字段适合位图索引
-- 能够高效处理多个低选择性条件的组合查询
```

**🎯 复合索引选择性计算**
```
复合索引选择性计算：
单个字段的选择性相乘（假设字段独立）

示例分析：
字段A选择性：0.1（10个不同值）
字段B选择性：0.05（20个不同值）  
复合索引(A,B)选择性 ≈ 0.1 × 0.05 = 0.005

实际查询效果：
WHERE A = 'value1' AND B = 'value2'
预期过滤到总数据的0.5%
符合高效索引使用的标准

字段顺序重要性：
索引(A,B) vs 索引(B,A)在某些查询下效果不同
WHERE A = ? AND B = ?  -- 两个索引都有效
WHERE A = ?            -- 只有(A,B)索引有效  
WHERE B = ?            -- 只有(B,A)索引有效
```

### 4.3 索引选择性与查询性能的关系


**⚡ 性能影响分析**
```
索引扫描代价模型：
代价 = 索引页读取 + 数据页读取 + CPU处理

索引页读取：
• 高选择性：读取少量索引页
• 低选择性：可能读取大量索引页

数据页读取：  
• 选择性影响回表次数
• 随机I/O vs 顺序I/O的性能差异

实际性能测试示例：
表大小：100万记录
测试条件：WHERE category = 'Electronics'

选择性0.001 (1000条记录):
• 索引扫描：5ms
• 数据页读取：50ms  
• 总耗时：55ms

选择性0.1 (10万条记录):  
• 索引扫描：200ms
• 数据页读取：8000ms
• 总耗时：8200ms (全表扫描可能更快)
```

---

## 5. 📊 统计信息与准确性保障


### 5.1 统计信息的核心组成


**📈 数据库统计信息详解**
```
基础统计信息：
• 表行数 (Table Cardinality)
• 列的唯一值个数 (Column Distinct Values)  
• 列的最大值和最小值 (Min/Max Values)
• 空值比例 (NULL Percentage)
• 数据分布直方图 (Histograms)

获取统计信息示例：
-- MySQL统计信息查询
SELECT 
    table_name,
    table_rows,
    avg_row_length,
    data_length
FROM information_schema.tables 
WHERE table_schema = 'your_database';

-- 列级别统计信息
SHOW INDEX FROM your_table;
SELECT 
    column_name,
    cardinality,
    sub_part,
    nullable
FROM information_schema.statistics 
WHERE table_name = 'your_table';
```

**🔍 统计信息收集策略**
```
自动收集 vs 手动收集：

自动收集：
• 优点：及时更新，无需人工干预
• 缺点：可能选择不合适的时机，影响性能  
• 适用：OLTP系统，数据变化频繁

手动收集：
• 优点：可控制收集时机和精度
• 缺点：需要定期维护，可能遗漏更新
• 适用：OLAP系统，数据变化相对稳定

混合策略：
• 核心表：手动精确收集
• 普通表：自动基础收集
• 定期检查：统计信息的准确性
```

### 5.2 统计信息准确性的影响因素


**⚠️ 统计信息过期问题**
```
统计信息失效的常见情况：

数据大量变化：
• 批量插入/删除操作
• 数据分布发生显著变化
• 时间相关数据的自然增长

系统配置问题：
• 统计信息更新阈值设置不当
• 采样比例过小
• 更新频率不足

影响表现：
查询计划不稳定：同样查询时快时慢
索引使用不当：该用索引时没用，不该用时强制使用  
内存分配错误：Sort/Hash操作内存估算错误

检测方法：
-- 检查统计信息最后更新时间
SELECT 
    table_name,
    update_time,
    DATEDIFF(NOW(), update_time) as days_old
FROM information_schema.tables
WHERE days_old > 7;  -- 超过7天未更新
```

**🎯 提高统计信息准确性的实践**
```sql
-- 1. 手动更新关键表统计信息
ANALYZE TABLE critical_orders;
ANALYZE TABLE user_profiles;

-- 2. 调整采样参数
-- MySQL: 增加采样页数
SET GLOBAL innodb_stats_sample_pages = 64;  -- 默认8

-- 3. 强制收集精确统计信息  
-- PostgreSQL示例
ANALYZE VERBOSE table_name;

-- 4. 监控统计信息质量
CREATE VIEW stats_quality_check AS
SELECT 
    table_name,
    table_rows as estimated_rows,
    (SELECT COUNT(*) FROM table_name) as actual_rows,
    ABS(table_rows - (SELECT COUNT(*) FROM table_name)) / 
    GREATEST((SELECT COUNT(*) FROM table_name), 1) as error_rate
FROM information_schema.tables
WHERE table_schema = DATABASE();

-- 5. 设置自动更新阈值
-- 当表变化超过10%时自动更新统计信息
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_persistent_sample_pages = 20;
```

### 5.3 统计信息在选择性计算中的应用


**🧮 基于统计信息的选择性估算**
```
实际选择性计算流程：

步骤1：获取基础统计
• 表总行数：N
• 列唯一值个数：NDV (Number of Distinct Values)
• 最小值/最大值：用于范围查询估算

步骤2：根据查询类型估算
等值查询：Selectivity = 1/NDV  
范围查询：Selectivity = (high-low)/(max-min)
LIKE查询：基于字符串统计信息估算

步骤3：应用数据分布修正
• 如果有直方图，使用更精确的分布信息
• 如果数据有偏斜，应用偏斜修正因子
• 考虑NULL值的影响

实例计算：
用户表1,000,000行
age列：min=18, max=65, NDV=47, NULL=0.02%

查询：WHERE age BETWEEN 25 AND 35
基础估算：(35-25)/(65-18) = 10/47 ≈ 0.213
考虑NULL：0.213 × (1-0.0002) ≈ 0.213
最终选择性：21.3%
```

---

## 6. ⚙️ 选择性驱动的查询优化


### 6.1 执行计划选择策略


**🎯 基于选择性的优化决策**
```
查询优化器的核心逻辑：

┌─ 查询优化决策树 ────────────────┐
│                               │
│ 1. 收集所有条件的选择性        │
│    ├─ 等值条件选择性          │
│    ├─ 范围条件选择性          │  
│    └─ 复合条件选择性          │
│                               │
│ 2. 评估可用索引的匹配程度      │
│    ├─ 索引覆盖度              │
│    ├─ 索引选择性              │
│    └─ 索引维护代价            │
│                               │
│ 3. 计算各种执行路径代价        │
│    ├─ 索引扫描 + 回表代价     │
│    ├─ 全表扫描代价            │
│    └─ 多索引合并代价          │
│                               │  
│ 4. 选择代价最低的执行计划      │
│                               │
└───────────────────────────────┘
```

**🔄 多表连接中的选择性应用**
```sql
-- 示例：三表连接查询优化
SELECT o.order_id, c.customer_name, p.product_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id  
JOIN products p ON o.product_id = p.product_id
WHERE o.order_date >= '2024-01-01'
  AND c.city = 'Beijing'
  AND p.category = 'Electronics';

-- 选择性分析：
-- o.order_date >= '2024-01-01': 选择性 0.25 (3个月数据)
-- c.city = 'Beijing': 选择性 0.15 (大城市用户多)  
-- p.category = 'Electronics': 选择性 0.3 (热门品类)

-- 优化器决策过程：
-- 1. 确定驱动表：选择过滤后数据量最小的表
--    orders过滤后：1000万 × 0.25 = 250万
--    customers过滤后：500万 × 0.15 = 75万  (选为驱动表)
--    products过滤后：100万 × 0.3 = 30万

-- 2. 确定连接顺序：
--    customers (75万) → products (结果约22.5万) → orders (最终结果)

-- 3. 选择连接算法：
--    Hash Join vs Nested Loop根据数据量决定
```

### 6.2 索引提示与强制优化


**💡 选择性指导的索引设计**
```sql
-- 根据选择性分析结果设计索引

-- 场景1：高选择性单列索引
-- user_email选择性: 0.95
CREATE INDEX idx_user_email ON users(email);  -- 高效

-- 场景2：低选择性需要复合索引  
-- status选择性: 0.1, created_date选择性: 0.4
-- 复合选择性: 0.1 × 0.4 = 0.04 (可接受)
CREATE INDEX idx_status_date ON orders(status, created_date);

-- 场景3：查询模式导向的索引设计
-- 90%的查询都包含这个条件组合
CREATE INDEX idx_frequent_query ON transactions(
    account_id,        -- 高选择性，放在前面
    transaction_date,  -- 范围查询，中间位置  
    amount            -- 包含列，减少回表
);

-- 场景4：部分索引优化
-- 只对active状态建索引，提高选择性
CREATE INDEX idx_active_users ON users(last_login_date) 
WHERE status = 'active';
```

**🛠️ 动态执行计划调优**
```sql
-- 使用Hint强制优化器选择
-- 当统计信息不准确时的临时解决方案

-- MySQL示例：
SELECT /*+ USE_INDEX(orders idx_order_date) */ 
    order_id, total_amount
FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
  AND total_amount > 1000;

-- 分析实际执行情况
EXPLAIN FORMAT=JSON
SELECT * FROM orders 
WHERE order_date >= '2024-01-01';

-- 对比不同执行计划的性能
-- 方案A：使用索引扫描
-- 方案B：全表扫描  
-- 通过实际测试验证选择性估算的准确性
```

### 6.3 查询重写与优化技巧


**✏️ 基于选择性的查询重写**
```sql
-- 原始查询：选择性不佳
SELECT * FROM products 
WHERE category IN ('A', 'B', 'C', 'D', 'E')  -- 包含很多值
  AND price > 100;

-- 重写1：如果category='A'的选择性特别高
SELECT * FROM products 
WHERE category = 'A' AND price > 100
UNION ALL
SELECT * FROM products 
WHERE category IN ('B', 'C', 'D', 'E') AND price > 100;

-- 重写2：利用EXISTS提高选择性
-- 原查询：
SELECT c.* FROM customers c
WHERE c.city = 'Beijing'  -- 选择性0.15
  AND EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.customer_id 
      AND o.order_date > '2024-01-01'  -- 选择性0.25
  );

-- 优化：先过滤高选择性条件
WITH recent_customers AS (
  SELECT DISTINCT customer_id 
  FROM orders 
  WHERE order_date > '2024-01-01'  -- 先执行高选择性条件
)
SELECT c.* 
FROM customers c
JOIN recent_customers rc ON c.customer_id = rc.customer_id
WHERE c.city = 'Beijing';
```

---

## 7. 🚀 实战应用与性能调优


### 7.1 选择性监控与诊断


**📊 建立选择性监控体系**
```sql
-- 1. 创建选择性监控视图
CREATE VIEW selectivity_monitor AS
SELECT 
    t.table_schema,
    t.table_name,
    c.column_name,
    t.table_rows,
    s.cardinality,
    CASE 
        WHEN t.table_rows > 0 
        THEN s.cardinality / t.table_rows 
        ELSE 0 
    END as selectivity,
    CASE 
        WHEN s.cardinality / t.table_rows > 0.8 THEN 'Excellent'
        WHEN s.cardinality / t.table_rows > 0.3 THEN 'Good' 
        WHEN s.cardinality / t.table_rows > 0.1 THEN 'Fair'
        ELSE 'Poor'
    END as index_quality
FROM information_schema.tables t
JOIN information_schema.statistics s ON t.table_name = s.table_name
JOIN information_schema.columns c ON s.column_name = c.column_name
WHERE t.table_schema = DATABASE();

-- 2. 查询选择性问题诊断
SELECT 
    table_name,
    column_name,
    selectivity,
    index_quality
FROM selectivity_monitor 
WHERE index_quality IN ('Poor', 'Fair')
ORDER BY selectivity ASC;
```

**🔍 实际查询选择性验证**
```sql
-- 创建选择性验证存储过程
DELIMITER //
CREATE PROCEDURE validate_selectivity(
    IN p_table VARCHAR(64),
    IN p_condition TEXT
)
BEGIN
    SET @sql = CONCAT(
        'SELECT COUNT(*) as total_rows FROM ', p_table
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    SET @sql = CONCAT(
        'SELECT COUNT(*) as filtered_rows FROM ', p_table, 
        ' WHERE ', p_condition
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt; 
    DEALLOCATE PREPARE stmt;
    
    -- 输出实际选择性
    SELECT 
        @filtered_rows as filtered_rows,
        @total_rows as total_rows,
        @filtered_rows / @total_rows as actual_selectivity;
END //
DELIMITER ;

-- 使用示例
CALL validate_selectivity('orders', 'order_date >= "2024-01-01"');
```

### 7.2 性能调优实战案例


**🎯 案例1：电商订单查询优化**
```sql
-- 问题查询：响应时间5秒
SELECT order_id, customer_name, product_name, order_amount
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN order_items oi ON o.order_id = oi.order_id  
JOIN products p ON oi.product_id = p.product_id
WHERE o.order_date BETWEEN '2024-01-01' AND '2024-01-31'
  AND o.status = 'completed'
  AND c.city = 'Shanghai'
  AND p.category = 'Electronics';

-- 选择性分析结果：
-- order_date范围: 选择性0.083 (1个月/12个月)
-- status='completed': 选择性0.7 (大部分订单都完成)
-- city='Shanghai': 选择性0.08 (大城市)  
-- category='Electronics': 选择性0.25 (热门品类)

-- 复合选择性计算：
-- 0.083 × 0.7 × 0.08 × 0.25 = 0.000116 (约0.01%)

-- 优化方案：
-- 1. 创建复合索引
CREATE INDEX idx_orders_opt ON orders(order_date, status, customer_id);
CREATE INDEX idx_customers_city ON customers(city, customer_id);  
CREATE INDEX idx_products_cat ON products(category, product_id);

-- 2. 重写查询，改变连接顺序
WITH filtered_orders AS (
    SELECT order_id, customer_id
    FROM orders 
    WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
      AND status = 'completed'
),
shanghai_customers AS (
    SELECT customer_id, customer_name
    FROM customers 
    WHERE city = 'Shanghai'
),
electronics_products AS (
    SELECT product_id, product_name
    FROM products
    WHERE category = 'Electronics'
)
SELECT o.order_id, c.customer_name, p.product_name, o.order_amount
FROM filtered_orders fo
JOIN shanghai_customers c ON fo.customer_id = c.customer_id
JOIN order_items oi ON fo.order_id = oi.order_id
JOIN electronics_products p ON oi.product_id = p.product_id
JOIN orders o ON fo.order_id = o.order_id;

-- 优化后响应时间：0.8秒
```

**⚡ 案例2：用户画像查询优化**
```sql
-- 问题：用户标签查询性能差
SELECT user_id, username, email
FROM users u
WHERE EXISTS (
    SELECT 1 FROM user_tags ut 
    WHERE ut.user_id = u.user_id 
      AND ut.tag_name IN ('high_value', 'active_buyer', 'premium')
)
AND u.registration_date >= '2023-01-01'
AND u.status = 'active';

-- 选择性分析：
-- tag_name条件：每个标签选择性约0.05，组合选择性约0.14
-- registration_date: 选择性0.5 (1年数据)
-- status='active': 选择性0.85

-- 问题识别：EXISTS子查询执行效率低

-- 优化方案1：改用IN子查询
SELECT user_id, username, email  
FROM users u
WHERE u.user_id IN (
    SELECT DISTINCT ut.user_id
    FROM user_tags ut
    WHERE ut.tag_name IN ('high_value', 'active_buyer', 'premium')
)
AND u.registration_date >= '2023-01-01'
AND u.status = 'active';

-- 优化方案2：使用JOIN
SELECT DISTINCT u.user_id, u.username, u.email
FROM users u
JOIN user_tags ut ON u.user_id = ut.user_id
WHERE ut.tag_name IN ('high_value', 'active_buyer', 'premium')
  AND u.registration_date >= '2023-01-01'
  AND u.status = 'active';

-- 创建支持索引
CREATE INDEX idx_users_composite ON users(status, registration_date, user_id);
CREATE INDEX idx_tags_name_user ON user_tags(tag_name, user_id);
```

### 7.3 持续优化与维护


**🔧 自动化选择性监控**
```sql
-- 创建选择性质量监控表
CREATE TABLE selectivity_quality_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    column_name VARCHAR(64), 
    query_pattern TEXT,
    estimated_selectivity DECIMAL(10,6),
    actual_selectivity DECIMAL(10,6),
    deviation_percent DECIMAL(5,2),
    execution_time_ms INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_table_column (table_name, column_name),
    INDEX idx_created_at (created_at)
);

-- 定期执行的监控脚本
CREATE EVENT selectivity_quality_check
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_TIMESTAMP
DO
BEGIN
    -- 检查统计信息是否过期
    INSERT INTO selectivity_quality_log (
        table_name, column_name, query_pattern, 
        estimated_selectivity, actual_selectivity, deviation_percent
    )
    SELECT 
        'orders' as table_name,
        'status' as column_name, 
        'status = "completed"' as query_pattern,
        0.7 as estimated_selectivity,  -- 预期选择性
        (SELECT COUNT(*) FROM orders WHERE status = 'completed') / 
        (SELECT COUNT(*) FROM orders) as actual_selectivity,
        ABS(0.7 - (SELECT COUNT(*) FROM orders WHERE status = 'completed') / 
        (SELECT COUNT(*) FROM orders)) / 0.7 * 100 as deviation_percent;
        
    -- 如果偏差超过20%，自动更新统计信息
    IF (SELECT deviation_percent FROM selectivity_quality_log 
        ORDER BY id DESC LIMIT 1) > 20 THEN
        ANALYZE TABLE orders;
    END IF;
END;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🎯 谓词选择性基础**
```
🔸 选择性定义：满足条件记录数 / 总记录数，取值0-1
🔸 过滤率关系：过滤率 = 1 - 选择性，值越大过滤效果越好
🔸 性能影响：低选择性(< 0.1)适合索引，高选择性(> 0.3)考虑全表扫描
🔸 计算方法：等值查询1/NDV，范围查询按值域比例，复合条件需考虑独立性
🔸 实际应用：指导索引设计、执行计划选择、查询重写优化
```

### 8.2 关键理解要点


**💡 选择性与性能的关系**
```
为什么选择性如此重要：
• 决定索引是否有效：低选择性让索引扫描高效
• 影响执行计划：优化器基于选择性估算代价
• 指导索引设计：高选择性字段适合建单列索引
• 优化多表连接：选择过滤效果好的表作为驱动表

选择性估算的挑战：
• 数据分布不均匀：热点数据影响估算准确性
• 条件相关性：多条件间可能存在关联，不完全独立
• 统计信息滞后：数据变化后统计信息未及时更新
• 复杂谓词难估：函数、表达式的选择性难以准确计算
```

**🔍 优化决策的核心逻辑**
```
数据库优化器的思考过程：
1. 收集条件选择性 → 估算过滤后的数据量
2. 评估索引匹配度 → 判断索引是否能有效使用  
3. 计算执行代价 → 对比不同方案的I/O和CPU成本
4. 选择最优计划 → 选择总代价最低的执行路径

人工优化的介入点：
• 统计信息不准时：手动更新或使用Hint
• 特殊查询模式：设计专门的复合索引
• 性能瓶颈出现：重写查询或调整执行顺序
```

### 8.3 实战应用指南


**🛠️ 日常优化工作流程**
```
1. 性能问题识别
   • 慢查询日志分析
   • 执行计划异常检查
   • 索引使用效率评估

2. 选择性分析  
   • 查询条件的选择性计算
   • 多条件组合效果评估
   • 与索引匹配度分析

3. 优化方案设计
   • 索引创建/删除/修改
   • 查询语句重写
   • 执行计划调整

4. 效果验证
   • A/B测试对比
   • 性能指标监控  
   • 长期稳定性观察

5. 持续维护
   • 统计信息定期更新
   • 选择性质量监控
   • 索引使用情况跟踪
```

**⚡ 常见优化技巧总结**
```
高选择性条件优化：
• 优先创建单列索引
• 考虑唯一性约束
• 作为复合索引的前导列

低选择性条件优化：  
• 避免单独建索引
• 考虑复合索引提高组合选择性
• 使用部分索引或过滤索引

复合条件优化：
• 按选择性高低排序执行
• 利用索引覆盖减少回表
• 考虑条件间的相关性

特殊场景处理：
• 范围查询的边界值优化
• NULL值处理策略  
• 函数条件的索引设计
```

### 8.4 进阶学习方向


**📚 深入研究领域**
```
理论基础深化：
• 查询优化理论
• 统计学在数据库中的应用
• 机器学习辅助的选择性估算

技术实践扩展：
• 不同数据库的优化器特性
• 分布式环境下的选择性分析  
• 实时数据变化的自适应优化

工具和方法：
• 性能分析工具的深度使用
• 自动化监控系统建设
• 查询优化的最佳实践总结
```

**核心记忆要点**：
- **选择性指引方向**：低选择性用索引，高选择性需谨慎
- **统计信息是基础**：准确的统计信息是正确优化的前提  
- **组合效应要考虑**：多条件的选择性不是简单相乘
- **持续监控很关键**：数据变化要及时反映到优化策略上
- **实际测试验证**：理论计算需要实际性能测试验证