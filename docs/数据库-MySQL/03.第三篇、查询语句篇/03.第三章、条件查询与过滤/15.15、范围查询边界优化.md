---
title: 15、范围查询边界优化
---
## 📚 目录

1. [范围查询基础概念](#1-范围查询基础概念)
2. [开区间与闭区间处理](#2-开区间与闭区间处理)
3. [边界值索引影响](#3-边界值索引影响)
4. [范围条件合并优化](#4-范围条件合并优化)
5. [多维范围查询](#5-多维范围查询)
6. [时间范围查询特殊处理](#6-时间范围查询特殊处理)
7. [范围查询性能优化策略](#7-范围查询性能优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 范围查询基础概念


### 1.1 什么是范围查询


**🔍 基本定义**
```sql
-- 范围查询就是查找某个字段值在指定范围内的数据
SELECT * FROM products WHERE price BETWEEN 100 AND 500;
SELECT * FROM orders WHERE order_date >= '2024-01-01' AND order_date < '2024-12-31';
```

**💡 通俗理解**
范围查询就像在商店里找商品：
- "我要100到500元之间的商品" → 这就是价格范围查询
- "我要今年的所有订单" → 这就是时间范围查询

### 1.2 范围查询的常见形式


**📋 基本语法对比**
```sql
-- 1. BETWEEN语法（闭区间）
SELECT * FROM table_name WHERE column BETWEEN value1 AND value2;

-- 2. 比较运算符组合
SELECT * FROM table_name WHERE column >= value1 AND column <= value2;

-- 3. 单边界查询
SELECT * FROM table_name WHERE column > value1;
SELECT * FROM table_name WHERE column < value2;
```

**🔸 重要理解**
- `BETWEEN` 包含边界值（闭区间）
- `>= AND <=` 也是闭区间
- `> AND <` 是开区间

### 1.3 范围查询的性能特点


**⚡ 性能影响因素**
```
索引使用情况：
├─ 有索引：扫描索引范围，性能较好
├─ 无索引：全表扫描，性能较差
└─ 复合索引：需考虑索引列顺序

数据分布影响：
├─ 数据均匀分布：性能稳定
├─ 数据倾斜：可能导致性能波动
└─ 边界值集中：需要特殊处理
```

**🎯 学习目标检查单**
- [ ] 理解范围查询的基本概念和语法
- [ ] 掌握开区间和闭区间的区别
- [ ] 了解范围查询对性能的影响

---

## 2. 🔄 开区间与闭区间处理


### 2.1 区间类型详解


**📊 区间类型对比**

| 区间类型 | **数学表示** | **SQL语法** | **包含边界** | **适用场景** |
|---------|------------|-------------|------------|-------------|
| 🟢 **闭区间** | `[a,b]` | `BETWEEN a AND b` | `包含a和b` | `价格范围、ID范围` |
| 🔴 **开区间** | `(a,b)` | `> a AND < b` | `不包含a和b` | `严格范围查询` |
| 🟡 **左闭右开** | `[a,b)` | `>= a AND < b` | `包含a，不包含b` | `时间范围常用` |
| 🟡 **左开右闭** | `(a,b]` | `> a AND <= b` | `不包含a，包含b` | `特殊业务需求` |

### 2.2 实际应用示例


**💰 价格范围查询**
```sql
-- 闭区间：包含100和500
SELECT product_name, price FROM products 
WHERE price BETWEEN 100 AND 500;
-- 等价于：WHERE price >= 100 AND price <= 500

-- 开区间：不包含100和500
SELECT product_name, price FROM products 
WHERE price > 100 AND price < 500;
```

**📅 时间范围查询**
```sql
-- 左闭右开：包含当天开始，不包含次日开始（常用）
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' AND order_date < '2024-01-02';

-- 闭区间：可能包含次日00:00:00的数据
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-01 23:59:59';
```

### 2.3 边界值的特殊处理


**⚠️ 常见边界问题**

**问题1：浮点数精度**
```sql
-- ❌ 可能遗漏边界数据
SELECT * FROM products WHERE price BETWEEN 99.99 AND 100.01;

-- ✅ 考虑精度的范围查询
SELECT * FROM products 
WHERE price >= 99.99 - 0.001 AND price <= 100.01 + 0.001;
```

**问题2：NULL值处理**
```sql
-- 范围查询会自动排除NULL值
SELECT COUNT(*) FROM products WHERE price BETWEEN 100 AND 500;
-- NULL价格的商品不会被计算在内

-- 如需包含NULL值，需要特殊处理
SELECT * FROM products 
WHERE (price BETWEEN 100 AND 500) OR price IS NULL;
```

**💡 最佳实践**
```sql
-- 整数范围：通常使用闭区间
WHERE age BETWEEN 18 AND 65

-- 时间范围：推荐使用左闭右开
WHERE created_at >= '2024-01-01' AND created_at < '2024-02-01'

-- 浮点数范围：考虑精度问题
WHERE price >= 99.99 AND price <= 100.01
```

---

## 3. 🔍 边界值索引影响


### 3.1 索引对范围查询的影响机制


**🏗️ 索引结构与范围查询**
```
B+树索引结构示意：
        [50]
       /    \
   [20,30]  [70,80]
   /  |  \   /  |  \
[10][25][35][60][75][90]

范围查询 WHERE id BETWEEN 25 AND 75:
1. 定位起始边界：找到25
2. 顺序扫描：25→30→35→50→60→70→75
3. 定位结束边界：找到75停止
```

**📈 边界值对性能的影响**
```sql
-- 示例表结构
CREATE TABLE sales_data (
    id INT PRIMARY KEY,
    sale_date DATE,
    amount DECIMAL(10,2),
    INDEX idx_sale_date (sale_date),
    INDEX idx_amount (amount)
);
```

### 3.2 边界值选择性分析


**🎯 选择性的重要性**
```sql
-- 高选择性查询（好）：边界值差异大，结果集小
SELECT * FROM sales_data 
WHERE amount BETWEEN 10000 AND 10100;  -- 可能只返回少量记录

-- 低选择性查询（差）：边界值差异大，结果集大
SELECT * FROM sales_data 
WHERE amount BETWEEN 0 AND 50000;      -- 可能返回大量记录
```

**📊 选择性评估方法**
```sql
-- 1. 计算范围内记录数量
SELECT COUNT(*) FROM sales_data 
WHERE amount BETWEEN @start_value AND @end_value;

-- 2. 计算选择性比例
SELECT 
    (SELECT COUNT(*) FROM sales_data 
     WHERE amount BETWEEN @start_value AND @end_value) * 100.0 / 
    (SELECT COUNT(*) FROM sales_data) AS selectivity_percentage;

-- 3. 分析数据分布
SELECT 
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    AVG(amount) AS avg_amount,
    COUNT(DISTINCT amount) AS distinct_values
FROM sales_data;
```

### 3.3 边界值优化策略


**🚀 优化技巧**

**技巧1：避免函数包装边界值**
```sql
-- ❌ 低效：对索引列使用函数
SELECT * FROM sales_data 
WHERE YEAR(sale_date) = 2024;

-- ✅ 高效：使用范围查询
SELECT * FROM sales_data 
WHERE sale_date >= '2024-01-01' AND sale_date < '2025-01-01';
```

**技巧2：边界值数据类型匹配**
```sql
-- ❌ 类型不匹配可能影响索引使用
SELECT * FROM sales_data WHERE id BETWEEN '100' AND '200';

-- ✅ 类型匹配
SELECT * FROM sales_data WHERE id BETWEEN 100 AND 200;
```

**技巧3：考虑索引覆盖**
```sql
-- 创建覆盖索引
CREATE INDEX idx_amount_date ON sales_data(amount, sale_date);

-- 利用覆盖索引避免回表
SELECT amount, sale_date FROM sales_data 
WHERE amount BETWEEN 1000 AND 5000;
```

---

## 4. 🔄 范围条件合并优化


### 4.1 什么是范围条件合并


**📝 基本概念**
范围条件合并就是把多个相关的范围查询合并成一个更高效的查询，就像把几个小问题合并成一个大问题来解决。

**🔄 合并前后对比**
```sql
-- 合并前：多个独立的范围查询
SELECT * FROM products WHERE price >= 100 AND price <= 200
UNION
SELECT * FROM products WHERE price >= 300 AND price <= 400
UNION  
SELECT * FROM products WHERE price >= 500 AND price <= 600;

-- 合并后：使用IN或OR条件
SELECT * FROM products 
WHERE (price BETWEEN 100 AND 200)
   OR (price BETWEEN 300 AND 400)
   OR (price BETWEEN 500 AND 600);
```

### 4.2 连续范围的合并优化


**🔗 连续范围识别与合并**
```sql
-- 原始查询：多个相邻或重叠的范围
WHERE (age >= 18 AND age <= 25) OR (age >= 24 AND age <= 35) OR (age >= 33 AND age <= 45)

-- 分析重叠：
-- 范围1: [18-25]
-- 范围2: [24-35] （与范围1重叠）
-- 范围3: [33-45] （与范围2重叠）

-- 合并结果：
WHERE age >= 18 AND age <= 45
```

**💻 合并算法示例**
```sql
-- 实际业务示例：促销价格区间合并
WITH price_ranges AS (
    SELECT 100 as min_price, 200 as max_price
    UNION SELECT 180, 250  -- 与第一个重叠
    UNION SELECT 300, 400  -- 独立区间
    UNION SELECT 380, 450  -- 与第三个重叠
),
merged_ranges AS (
    -- 简化版合并逻辑（实际需要更复杂的算法）
    SELECT MIN(min_price) as merged_min, MAX(max_price) as merged_max
    FROM price_ranges
)
SELECT * FROM products p
CROSS JOIN merged_ranges m
WHERE p.price BETWEEN m.merged_min AND m.merged_max;
```

### 4.3 范围条件与等值条件的结合


**🎯 混合条件优化**
```sql
-- 原始查询：范围条件 + 多个等值条件
SELECT * FROM orders 
WHERE (status = 'pending' OR status = 'processing' OR status = 'shipped')
  AND order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND amount BETWEEN 100 AND 1000;

-- 优化方案1：使用IN替代多个OR
SELECT * FROM orders 
WHERE status IN ('pending', 'processing', 'shipped')
  AND order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND amount BETWEEN 100 AND 1000;

-- 优化方案2：考虑复合索引
CREATE INDEX idx_status_date_amount ON orders(status, order_date, amount);
```

### 4.4 子查询范围条件合并


**🔍 子查询优化示例**
```sql
-- 低效：多个子查询
SELECT * FROM products 
WHERE id IN (
    SELECT product_id FROM sales WHERE sale_date BETWEEN '2024-01-01' AND '2024-03-31'
    UNION
    SELECT product_id FROM sales WHERE sale_date BETWEEN '2024-07-01' AND '2024-09-30'
);

-- 高效：合并范围条件
SELECT DISTINCT p.* FROM products p
JOIN sales s ON p.id = s.product_id
WHERE (s.sale_date BETWEEN '2024-01-01' AND '2024-03-31')
   OR (s.sale_date BETWEEN '2024-07-01' AND '2024-09-30');
```

**📊 性能对比**
```sql
-- 测试范围条件合并效果
EXPLAIN SELECT * FROM orders 
WHERE (amount BETWEEN 100 AND 500) OR (amount BETWEEN 800 AND 1200);

-- 对比单个大范围查询
EXPLAIN SELECT * FROM orders 
WHERE amount BETWEEN 100 AND 1200 AND amount NOT BETWEEN 501 AND 799;
```

---

## 5. 📐 多维范围查询


### 5.1 什么是多维范围查询


**🌍 基本概念**
多维范围查询就是同时对多个字段进行范围限制，就像在地图上用一个矩形框选中某个区域一样。

**📊 常见应用场景**
```sql
-- 地理位置查询（二维）
SELECT * FROM restaurants 
WHERE latitude BETWEEN 39.9 AND 40.1    -- 纬度范围
  AND longitude BETWEEN 116.3 AND 116.5; -- 经度范围

-- 商品筛选查询（三维）
SELECT * FROM products 
WHERE price BETWEEN 100 AND 500         -- 价格维度
  AND weight BETWEEN 0.5 AND 2.0        -- 重量维度  
  AND rating BETWEEN 4.0 AND 5.0;       -- 评分维度
```

### 5.2 多维范围查询的索引策略


**🏗️ 索引选择策略**

**策略1：复合索引**
```sql
-- 创建多列复合索引
CREATE INDEX idx_location ON restaurants(latitude, longitude);
CREATE INDEX idx_product_filter ON products(price, weight, rating);

-- 索引使用效果
EXPLAIN SELECT * FROM products 
WHERE price BETWEEN 100 AND 500 
  AND weight BETWEEN 1.0 AND 2.0 
  AND rating >= 4.0;
```

**策略2：单列索引组合**
```sql
-- 为每个范围字段创建单独索引
CREATE INDEX idx_price ON products(price);
CREATE INDEX idx_weight ON products(weight); 
CREATE INDEX idx_rating ON products(rating);

-- 数据库会选择最优索引或索引交集
```

**📋 索引策略选择指南**

| 查询特点 | **推荐策略** | **原因说明** |
|---------|------------|-------------|
| **所有维度都常用** | `复合索引` | `避免索引交集开销` |
| **维度使用频率不同** | `单列索引` | `灵活性更好` |
| **查询结果集很小** | `复合索引` | `减少回表次数` |
| **经常只查询部分维度** | `单列索引` | `避免索引浪费` |

### 5.3 多维范围查询优化技巧


**⚡ 优化技巧详解**

**技巧1：维度优先级排序**
```sql
-- 根据选择性排序查询条件
-- 选择性高（结果少）的条件放在前面
SELECT * FROM products 
WHERE rating BETWEEN 4.8 AND 5.0        -- 高选择性，先筛选
  AND price BETWEEN 100 AND 500         -- 中等选择性
  AND weight BETWEEN 0.1 AND 10.0;      -- 低选择性，后筛选
```

**技巧2：分步查询**
```sql
-- 对于超多维度查询，考虑分步执行
-- 第一步：找出评分最高的商品
WITH high_rating_products AS (
    SELECT id FROM products WHERE rating >= 4.5
)
-- 第二步：在高评分商品中筛选价格和重量
SELECT p.* FROM products p
JOIN high_rating_products h ON p.id = h.id
WHERE p.price BETWEEN 100 AND 500
  AND p.weight BETWEEN 1.0 AND 2.0;
```

**技巧3：空间索引应用**
```sql
-- 对于地理坐标等空间数据，使用专门的空间索引
CREATE SPATIAL INDEX idx_location ON restaurants(location);

-- 使用空间函数进行范围查询
SELECT * FROM restaurants 
WHERE ST_Within(location, 
    ST_GeomFromText('POLYGON((116.3 39.9, 116.5 39.9, 116.5 40.1, 116.3 40.1, 116.3 39.9))'));
```

### 5.4 多维范围查询的性能分析


**📊 性能评估方法**
```sql
-- 1. 分析每个维度的选择性
SELECT 
    COUNT(*) as total_records,
    COUNT(*) FILTER (WHERE price BETWEEN 100 AND 500) as price_matches,
    COUNT(*) FILTER (WHERE weight BETWEEN 1.0 AND 2.0) as weight_matches,
    COUNT(*) FILTER (WHERE rating >= 4.0) as rating_matches
FROM products;

-- 2. 分析组合条件的选择性
SELECT COUNT(*) as combined_matches
FROM products 
WHERE price BETWEEN 100 AND 500 
  AND weight BETWEEN 1.0 AND 2.0 
  AND rating >= 4.0;

-- 3. 查看执行计划
EXPLAIN ANALYZE SELECT * FROM products 
WHERE price BETWEEN 100 AND 500 
  AND weight BETWEEN 1.0 AND 2.0 
  AND rating >= 4.0;
```

---

## 6. ⏰ 时间范围查询特殊处理


### 6.1 时间范围查询的复杂性


**🕐 时间数据的特殊性**
时间范围查询比普通范围查询更复杂，因为时间有很多特殊要求：
- **时区问题**：同一时刻在不同时区显示不同
- **精度问题**：年月日、时分秒、毫秒等不同精度
- **业务语义**：今天、本周、本月等业务含义

**📅 时间类型对比**
```sql
-- 不同时间类型的存储方式
CREATE TABLE events (
    id INT PRIMARY KEY,
    event_date DATE,              -- 只存储日期：2024-01-01
    event_datetime DATETIME,      -- 日期+时间：2024-01-01 14:30:00  
    event_timestamp TIMESTAMP,    -- 带时区的时间戳
    created_at BIGINT            -- Unix时间戳：1704110400
);
```

### 6.2 日期范围查询最佳实践


**📝 标准日期范围查询**
```sql
-- ✅ 推荐：左闭右开区间
-- 查询2024年1月1日的所有数据
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' 
  AND order_date < '2024-01-02';

-- ✅ 推荐：查询整个月的数据
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' 
  AND order_date < '2024-02-01';

-- ❌ 不推荐：使用DATE函数（无法使用索引）
SELECT * FROM orders 
WHERE DATE(order_datetime) = '2024-01-01';

-- ✅ 推荐：改写为范围查询
SELECT * FROM orders 
WHERE order_datetime >= '2024-01-01 00:00:00' 
  AND order_datetime < '2024-01-02 00:00:00';
```

**⚠️ 常见时间查询陷阱**
```sql
-- 陷阱1：BETWEEN包含边界，可能包含意外数据
-- 这个查询可能包含2024-01-02 00:00:00的数据
SELECT * FROM orders 
WHERE order_datetime BETWEEN '2024-01-01' AND '2024-01-01';

-- 陷阱2：时区转换影响查询结果
-- 存储的是UTC时间，查询时需要考虑时区
SELECT * FROM orders 
WHERE CONVERT_TZ(order_datetime, '+00:00', '+08:00') >= '2024-01-01';
```

### 6.3 时间维度的索引优化


**🏗️ 时间索引策略**
```sql
-- 1. 基本时间索引
CREATE INDEX idx_order_date ON orders(order_date);

-- 2. 复合索引（时间+其他字段）
CREATE INDEX idx_date_status ON orders(order_date, status);

-- 3. 按时间分区（大表推荐）
CREATE TABLE orders (
    id INT PRIMARY KEY,
    order_date DATE,
    status VARCHAR(20),
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);
```

### 6.4 复杂时间范围查询


**🎯 业务时间范围查询**
```sql
-- 查询最近7天的数据
SELECT * FROM orders 
WHERE order_date >= CURDATE() - INTERVAL 7 DAY;

-- 查询本月的数据
SELECT * FROM orders 
WHERE order_date >= DATE_FORMAT(CURDATE(), '%Y-%m-01')
  AND order_date < DATE_ADD(DATE_FORMAT(CURDATE(), '%Y-%m-01'), INTERVAL 1 MONTH);

-- 查询工作日的数据（周一到周五）
SELECT * FROM orders 
WHERE WEEKDAY(order_date) BETWEEN 0 AND 4  -- 0=周一，4=周五
  AND order_date >= '2024-01-01';
```

**📊 时间窗口查询**
```sql
-- 滑动窗口查询：每个订单及其前后3天的相关数据
SELECT 
    o1.id,
    o1.order_date,
    COUNT(o2.id) as related_orders
FROM orders o1
LEFT JOIN orders o2 ON o2.order_date BETWEEN 
    o1.order_date - INTERVAL 3 DAY AND 
    o1.order_date + INTERVAL 3 DAY
WHERE o1.order_date >= '2024-01-01'
GROUP BY o1.id, o1.order_date;
```

### 6.5 时间范围查询性能优化


**⚡ 优化策略**
```sql
-- 1. 使用预计算字段
ALTER TABLE orders ADD COLUMN order_year INT AS (YEAR(order_date));
ALTER TABLE orders ADD COLUMN order_month INT AS (MONTH(order_date));
CREATE INDEX idx_year_month ON orders(order_year, order_month);

-- 利用预计算字段查询
SELECT * FROM orders 
WHERE order_year = 2024 AND order_month = 1;

-- 2. 时间范围缓存
CREATE TABLE date_ranges (
    range_name VARCHAR(20),
    start_date DATE,
    end_date DATE
);

INSERT INTO date_ranges VALUES 
('current_month', '2024-01-01', '2024-01-31'),
('last_month', '2023-12-01', '2023-12-31');

-- 使用预定义范围
SELECT o.* FROM orders o
JOIN date_ranges dr ON dr.range_name = 'current_month'
WHERE o.order_date BETWEEN dr.start_date AND dr.end_date;
```

---

## 7. 🚀 范围查询性能优化策略


### 7.1 索引选择与优化


**🎯 索引设计原则**
```sql
-- 1. 范围查询字段应该在复合索引的最后
-- ❌ 错误：范围字段在前面，后续字段无法使用索引
CREATE INDEX idx_bad ON orders(amount, status, order_date);
SELECT * FROM orders 
WHERE amount BETWEEN 100 AND 500 AND status = 'paid';

-- ✅ 正确：等值查询在前，范围查询在后
CREATE INDEX idx_good ON orders(status, order_date, amount);
SELECT * FROM orders 
WHERE status = 'paid' AND order_date >= '2024-01-01';
```

**📋 索引优化检查清单**
- [ ] 范围查询字段是否有单独索引？
- [ ] 复合索引的字段顺序是否合理？
- [ ] 是否考虑了覆盖索引避免回表？
- [ ] 索引的选择性是否足够高？

### 7.2 查询改写技巧


**🔄 改写优化示例**
```sql
-- 1. 避免在范围查询中使用函数
-- ❌ 低效：使用函数包装字段
SELECT * FROM orders 
WHERE YEAR(order_date) = 2024 AND MONTH(order_date) BETWEEN 1 AND 3;

-- ✅ 高效：改写为范围查询
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' AND order_date < '2024-04-01';

-- 2. 大范围查询分页优化
-- ❌ 低效：OFFSET太大时性能差
SELECT * FROM products 
WHERE price BETWEEN 100 AND 1000 
ORDER BY id LIMIT 1000 OFFSET 50000;

-- ✅ 高效：使用游标分页
SELECT * FROM products 
WHERE price BETWEEN 100 AND 1000 AND id > 50000 
ORDER BY id LIMIT 1000;
```

### 7.3 数据分区策略


**📂 按范围分区**
```sql
-- 按时间范围分区
CREATE TABLE sales_data (
    id INT,
    sale_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);

-- 分区裁剪效果：只扫描相关分区
SELECT * FROM sales_data 
WHERE sale_date BETWEEN '2024-01-01' AND '2024-03-31';
-- 只会扫描p2024分区
```

**📊 分区效果分析**
```sql
-- 查看分区使用情况
EXPLAIN PARTITIONS SELECT * FROM sales_data 
WHERE sale_date BETWEEN '2024-01-01' AND '2024-03-31';

-- 分区统计信息
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    DATA_LENGTH/1024/1024 AS DATA_MB
FROM information_schema.PARTITIONS 
WHERE TABLE_NAME = 'sales_data';
```

### 7.4 缓存与预计算优化


**💾 查询结果缓存**
```sql
-- 1. 应用层缓存常用范围查询
-- 缓存键："price_range_100_500"
-- 缓存值：查询结果集

-- 2. 物化视图缓存
CREATE VIEW monthly_sales AS
SELECT 
    DATE_FORMAT(sale_date, '%Y-%m') as month,
    SUM(amount) as total_amount,
    COUNT(*) as total_orders
FROM sales_data 
GROUP BY DATE_FORMAT(sale_date, '%Y-%m');

-- 查询月度数据时直接使用视图
SELECT * FROM monthly_sales 
WHERE month BETWEEN '2024-01' AND '2024-12';
```

**⚡ 预聚合优化**
```sql
-- 创建聚合表
CREATE TABLE price_range_stats (
    price_min INT,
    price_max INT,
    product_count INT,
    avg_rating DECIMAL(3,2),
    total_sales INT,
    PRIMARY KEY (price_min, price_max)
);

-- 定期更新聚合数据
INSERT INTO price_range_stats
SELECT 
    FLOOR(price/100)*100 as price_min,
    FLOOR(price/100)*100 + 99 as price_max,
    COUNT(*) as product_count,
    AVG(rating) as avg_rating,
    SUM(sales_count) as total_sales
FROM products 
GROUP BY FLOOR(price/100);

-- 使用聚合表快速查询
SELECT * FROM price_range_stats 
WHERE price_min >= 100 AND price_max <= 500;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 范围查询基础**
- 范围查询是查找字段值在指定区间内的数据
- `BETWEEN`是闭区间，`> AND <`是开区间
- 时间范围查询推荐使用左闭右开区间

**🔸 边界值处理**
- 开区间不包含边界值，闭区间包含边界值
- 浮点数要考虑精度问题
- NULL值会被范围查询自动排除

**🔸 索引影响**
- 范围查询字段应该在复合索引的最后位置
- 边界值的选择性直接影响查询性能
- 覆盖索引可以避免回表操作

### 8.2 关键优化策略


**🎯 查询优化要点**
```
索引设计：等值在前，范围在后
查询改写：避免函数包装，使用范围替代
条件合并：合并重叠范围，优化OR条件
分区策略：大表按范围分区提高效率
```

**⚡ 性能提升技巧**
- 分析数据分布，选择合适的边界值
- 使用分页避免大结果集
- 预计算常用范围查询结果
- 监控执行计划，及时调整索引

### 8.3 实际应用指导


**📊 应用场景总结**

| 场景类型 | **推荐做法** | **注意事项** |
|---------|------------|-------------|
| **价格范围** | `BETWEEN价格区间` | `考虑促销价格边界` |
| **时间范围** | `左闭右开区间` | `注意时区和精度` |
| **地理范围** | `多维范围+空间索引` | `使用空间函数优化` |
| **评分范围** | `>=最小值方式` | `小数精度处理` |

**🎯 学习成果检验**
- [ ] 能区分开区间和闭区间的使用场景
- [ ] 掌握时间范围查询的最佳实践
- [ ] 理解边界值对索引选择性的影响
- [ ] 会优化多维范围查询性能
- [ ] 能设计合理的索引支持范围查询

### 8.4 进阶学习建议


**📚 深入学习方向**
- **空间数据库**：学习PostGIS等空间扩展
- **时序数据库**：研究InfluxDB等时间序列数据库
- **分布式查询**：了解分片环境下的范围查询
- **查询优化器**：深入理解数据库的查询优化原理

**🔧 实践建议**
- 在实际项目中监控范围查询的性能
- 尝试不同的索引策略并对比效果
- 学会使用EXPLAIN分析查询执行计划
- 关注数据增长对范围查询性能的影响

**核心记忆口诀**：
- 范围查询要建索引，边界处理需精细
- 开闭区间要分清，时间查询左闭右开好
- 多维范围巧组合，条件合并性能高
- 分区缓存来助力，监控优化不可少