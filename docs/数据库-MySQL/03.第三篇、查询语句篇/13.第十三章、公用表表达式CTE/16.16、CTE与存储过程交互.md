---
title: 16、CTE与存储过程交互
---
## 📚 目录


1. [CTE与存储过程基础](#1-cte与存储过程基础)
2. [CTE在存储过程中的应用](#2-cte在存储过程中的应用)
3. [临时结果集传递机制](#3-临时结果集传递机制)
4. [存储过程CTE优化技巧](#4-存储过程cte优化技巧)
5. [动态CTE构建](#5-动态cte构建)
6. [存储过程递归CTE](#6-存储过程递归cte)
7. [实战应用案例](#7-实战应用案例)
8. [性能优化与最佳实践](#8-性能优化与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

# 🎯 **学习目标**


- [ ] 理解CTE在存储过程中的作用机制
- [ ] 掌握临时结果集在存储过程间的传递方法
- [ ] 学会在存储过程中优化CTE性能
- [ ] 掌握动态构建CTE的技巧
- [ ] 学会实现存储过程中的递归CTE应用

---

## 1. 🏗️ CTE与存储过程基础



### 1.1 什么是CTE与存储过程的结合



**简单理解**：CTE在存储过程中就像是"临时助手"，帮助分解复杂逻辑

```
生活类比：
做一道复杂菜的过程：
1. 准备工作台（存储过程环境）
2. 先处理配菜（CTE临时结果）
3. 分步骤烹饪（利用CTE结果）
4. 最终成菜（返回最终结果）

存储过程中的CTE：
1. 创建存储过程环境
2. 定义CTE临时结果集
3. 在后续逻辑中引用CTE
4. 返回处理后的结果
```

**🔸 核心概念**
```
CTE在存储过程中的价值：
- 简化复杂查询逻辑
- 提高代码可读性和维护性
- 实现分步数据处理
- 支持递归操作
- 临时结果集的高效管理
```

### 1.2 CTE与存储过程的协作模式



**💡 协作模式图示**
```
存储过程执行流程：

BEGIN
  ┌─────────────────┐
  │  定义CTE_1       │ → 处理基础数据
  ├─────────────────┤
  │  定义CTE_2       │ → 基于CTE_1进一步处理
  ├─────────────────┤
  │  定义CTE_3       │ → 最终数据准备
  ├─────────────────┤
  │  主查询逻辑      │ → 使用所有CTE生成结果
  └─────────────────┘
END

优势：
- 逻辑清晰：每个CTE职责单一
- 易于调试：可以单独验证每个CTE
- 代码复用：CTE可被多次引用
```

### 1.3 作用域和生命周期



**🔄 CTE在存储过程中的生命周期**
```
CTE生命周期管理：

1. 定义阶段
WITH cte_name AS (SELECT ...)  -- CTE定义，但未执行

2. 引用阶段  
SELECT * FROM cte_name;        -- 首次引用，开始执行

3. 重用阶段
SELECT COUNT(*) FROM cte_name; -- 再次引用，可能复用结果

4. 销毁阶段
存储过程结束时自动销毁所有CTE

关键理解：
- CTE只在定义它的查询语句中有效
- 不同的WITH语句之间CTE不能共享
- 存储过程中每个独立的SQL语句都可以有自己的CTE
```

---

## 2. 🔧 CTE在存储过程中的应用



### 2.1 基础应用模式



**📝 简单CTE应用示例**

```sql
DELIMITER //
CREATE PROCEDURE GetDepartmentStats(IN dept_id INT)
BEGIN
    -- CTE计算部门基础数据
    WITH dept_employees AS (
        SELECT 
            employee_id, 
            name, 
            salary, 
            hire_date
        FROM employees 
        WHERE department_id = dept_id
    ),
    -- CTE计算汇总统计
    dept_summary AS (
        SELECT 
            COUNT(*) as emp_count,
            AVG(salary) as avg_salary,
            MAX(salary) as max_salary,
            MIN(hire_date) as earliest_hire
        FROM dept_employees
    )
    -- 返回详细结果
    SELECT 
        ds.emp_count as '员工总数',
        ROUND(ds.avg_salary, 2) as '平均薪资',
        ds.max_salary as '最高薪资',
        ds.earliest_hire as '最早入职时间',
        de.name as '员工姓名',
        de.salary as '个人薪资'
    FROM dept_summary ds
    CROSS JOIN dept_employees de
    ORDER BY de.salary DESC;

END //
DELIMITER ;

-- 调用示例
CALL GetDepartmentStats(10);
```

**🔍 应用模式解析**
```
代码结构分析：

1. 第一个CTE (dept_employees)：
   - 作用：筛选特定部门的员工
   - 好处：避免在后续查询中重复写WHERE条件

2. 第二个CTE (dept_summary)：
   - 作用：基于第一个CTE计算汇总数据
   - 好处：统计信息和明细信息分离

3. 主查询：
   - 作用：将汇总和明细结合输出
   - 好处：一次查询返回多维度信息

优势对比：
不用CTE：需要多次查询或复杂子查询
使用CTE：逻辑清晰，一次完成，性能更好
```

### 2.2 多步骤数据处理



**🔄 分步骤处理复杂业务逻辑**

```sql
DELIMITER //
CREATE PROCEDURE ProcessMonthlyReport(IN report_month VARCHAR(7))
BEGIN
    -- 步骤1：过滤当月数据
    WITH monthly_orders AS (
        SELECT 
            order_id, customer_id, product_id, 
            amount, order_date
        FROM orders 
        WHERE DATE_FORMAT(order_date, '%Y-%m') = report_month
          AND status = 'completed'
    ),
    -- 步骤2：关联客户和产品信息
    enriched_orders AS (
        SELECT 
            mo.*, 
            c.customer_name, 
            c.region,
            p.product_name, 
            p.category
        FROM monthly_orders mo
        JOIN customers c ON mo.customer_id = c.id
        JOIN products p ON mo.product_id = p.id
    ),
    -- 步骤3：计算汇总指标
    summary_stats AS (
        SELECT 
            region,
            category,
            COUNT(*) as order_count,
            SUM(amount) as total_amount,
            AVG(amount) as avg_amount
        FROM enriched_orders
        GROUP BY region, category
    )
    -- 输出最终报表
    SELECT 
        region as '地区',
        category as '产品类别', 
        order_count as '订单数量',
        ROUND(total_amount, 2) as '总金额',
        ROUND(avg_amount, 2) as '平均金额'
    FROM summary_stats
    ORDER BY total_amount DESC;

END //
DELIMITER ;
```

**💡 分步处理的好处**
```
传统方式 vs CTE方式：

传统方式（复杂子查询）：
- 嵌套层次深，难以理解
- 重复计算多，性能较差
- 调试困难，错误定位难

CTE方式（分步处理）：
- 逻辑层次清晰，易于理解
- 可以独立验证每个步骤
- 性能优化，MySQL可以更好地优化执行计划
- 代码维护性强
```

### 2.3 条件逻辑处理



**🎯 基于条件的CTE选择**

```sql
DELIMITER //
CREATE PROCEDURE GetCustomerAnalysis(
    IN analysis_type VARCHAR(20),
    IN customer_id INT
)
BEGIN
    DECLARE sql_text TEXT;
    
    -- 根据分析类型选择不同的CTE逻辑
    IF analysis_type = 'orders' THEN
        WITH customer_orders AS (
            SELECT 
                order_id, 
                order_date, 
                amount,
                status
            FROM orders 
            WHERE customer_id = customer_id
              AND order_date >= DATE_SUB(NOW(), INTERVAL 6 MONTH)
        )
        SELECT 
            COUNT(*) as '最近6个月订单数',
            SUM(amount) as '总消费金额',
            AVG(amount) as '平均订单金额'
        FROM customer_orders;
        
    ELSEIF analysis_type = 'products' THEN
        WITH customer_products AS (
            SELECT DISTINCT
                p.product_id,
                p.product_name,
                p.category,
                COUNT(*) as purchase_count
            FROM orders o
            JOIN products p ON o.product_id = p.id
            WHERE o.customer_id = customer_id
            GROUP BY p.product_id, p.product_name, p.category
        )
        SELECT 
            product_name as '购买产品',
            category as '产品类别',
            purchase_count as '购买次数'
        FROM customer_products
        ORDER BY purchase_count DESC
        LIMIT 10;
        
    ELSE
        SELECT '无效的分析类型' as error_message;
    END IF;

END //
DELIMITER ;
```

---

## 3. 📊 临时结果集传递机制



### 3.1 CTE作为中间结果传递



**🔗 结果传递模式**

```
传统方式的问题：
存储过程内部需要多次使用相同的复杂查询结果
每次都重新执行查询 → 性能浪费

CTE解决方案：
一次计算，多次引用 → 性能优化
```

**💡 实际应用示例**
```sql
DELIMITER //
CREATE PROCEDURE ProcessOrderData(IN start_date DATE, IN end_date DATE)
BEGIN
    -- CTE定义：计算时间段内的基础订单数据
    WITH base_orders AS (
        SELECT 
            o.order_id,
            o.customer_id, 
            o.product_id,
            o.amount,
            o.order_date,
            c.region,
            p.category
        FROM orders o
        JOIN customers c ON o.customer_id = c.id
        JOIN products p ON o.product_id = p.id
        WHERE o.order_date BETWEEN start_date AND end_date
          AND o.status = 'completed'
    ),
    -- 基于base_orders计算地区统计
    region_stats AS (
        SELECT 
            region,
            COUNT(*) as order_count,
            SUM(amount) as total_amount
        FROM base_orders
        GROUP BY region
    ),
    -- 基于base_orders计算类别统计
    category_stats AS (
        SELECT 
            category,
            COUNT(*) as order_count,
            SUM(amount) as total_amount  
        FROM base_orders
        GROUP BY category
    )
    -- 主查询：组合所有统计结果
    SELECT 
        '地区统计' as report_type,
        region as dimension,
        order_count,
        total_amount
    FROM region_stats
    
    UNION ALL
    
    SELECT 
        '类别统计' as report_type,
        category as dimension, 
        order_count,
        total_amount
    FROM category_stats
    
    ORDER BY report_type, total_amount DESC;

END //
DELIMITER ;
```

### 3.2 CTE结果在存储过程中的复用



**🔄 复用机制详解**

```sql
-- 复用示例：客户价值分析
DELIMITER //
CREATE PROCEDURE AnalyzeCustomerValue(IN target_customer_id INT)
BEGIN
    -- 定义客户购买历史CTE
    WITH customer_history AS (
        SELECT 
            order_id,
            product_id,
            amount,
            order_date,
            YEAR(order_date) as order_year,
            QUARTER(order_date) as order_quarter
        FROM orders 
        WHERE customer_id = target_customer_id
          AND status = 'completed'
          AND order_date >= DATE_SUB(NOW(), INTERVAL 2 YEAR)
    )
    -- 查询1：年度消费趋势
    SELECT 
        '年度趋势' as analysis_type,
        order_year as period_value,
        COUNT(*) as order_count,
        SUM(amount) as total_spent,
        AVG(amount) as avg_order_value
    FROM customer_history
    GROUP BY order_year
    
    UNION ALL
    
    -- 查询2：季度消费模式  
    SELECT 
        '季度模式' as analysis_type,
        CONCAT(order_year, '-Q', order_quarter) as period_value,
        COUNT(*) as order_count,
        SUM(amount) as total_spent,
        AVG(amount) as avg_order_value
    FROM customer_history
    GROUP BY order_year, order_quarter
    
    ORDER BY analysis_type, period_value;

END //
DELIMITER ;
```

**🔍 复用的优势**
```
性能优势：
- 避免重复计算相同的基础数据
- MySQL优化器可以更好地优化执行计划
- 减少磁盘IO和CPU使用

代码优势：
- 逻辑清晰，一个CTE专注一件事
- 易于调试，可以单独验证CTE结果
- 便于维护，修改基础逻辑只需改CTE定义
```

### 3.3 参数化CTE应用



**⚙️ 动态参数传入CTE**

```sql
DELIMITER //
CREATE PROCEDURE FlexibleSalesReport(
    IN report_type VARCHAR(20),
    IN time_range_days INT,
    IN min_amount DECIMAL(10,2)
)
BEGIN
    -- 参数化的时间范围CTE
    WITH filtered_sales AS (
        SELECT 
            s.sale_id,
            s.customer_id,
            s.product_id, 
            s.amount,
            s.sale_date,
            c.customer_name,
            p.product_name
        FROM sales s
        JOIN customers c ON s.customer_id = c.id
        JOIN products p ON s.product_id = p.id
        WHERE s.sale_date >= DATE_SUB(NOW(), INTERVAL time_range_days DAY)
          AND s.amount >= min_amount
    )
    -- 根据报表类型返回不同结果
    SELECT 
        CASE report_type
            WHEN 'customer' THEN customer_name
            WHEN 'product' THEN product_name
            ELSE 'unknown'
        END as name,
        COUNT(*) as sale_count,
        SUM(amount) as total_amount,
        AVG(amount) as avg_amount
    FROM filtered_sales
    GROUP BY 
        CASE report_type
            WHEN 'customer' THEN customer_id
            WHEN 'product' THEN product_id  
            ELSE 1
        END,
        CASE report_type
            WHEN 'customer' THEN customer_name
            WHEN 'product' THEN product_name
            ELSE 'all'
        END
    ORDER BY total_amount DESC
    LIMIT 20;

END //
DELIMITER ;

-- 调用示例
CALL FlexibleSalesReport('customer', 30, 100.00);  -- 最近30天，金额>100的客户报表
CALL FlexibleSalesReport('product', 7, 50.00);     -- 最近7天，金额>50的产品报表
```

---

## 4. 🛠️ 存储过程CTE优化技巧



### 4.1 CTE执行计划优化



**📊 优化执行计划的技巧**

```sql
-- 优化技巧1：合理使用索引提示
DELIMITER //
CREATE PROCEDURE OptimizedEmployeeReport(IN dept_id INT)
BEGIN
    WITH indexed_employees AS (
        SELECT /*+ USE_INDEX(employees, idx_dept_salary) */
            employee_id,
            name, 
            salary,
            hire_date
        FROM employees 
        WHERE department_id = dept_id
          AND status = 'active'
    )
    SELECT 
        name,
        salary,
        DATEDIFF(NOW(), hire_date) as days_employed
    FROM indexed_employees
    WHERE salary > (SELECT AVG(salary) FROM indexed_employees)
    ORDER BY salary DESC;

END //
DELIMITER ;
```

**🎯 CTE与子查询的选择**
```sql
-- 对比：子查询 vs CTE

-- 方式1：使用子查询（可能重复计算）
DELIMITER //
CREATE PROCEDURE SubqueryMethod(IN region_name VARCHAR(50))
BEGIN
    SELECT 
        c.customer_name,
        c.total_orders,
        c.total_amount
    FROM (
        SELECT 
            customer_id,
            customer_name,
            COUNT(*) as total_orders,
            SUM(amount) as total_amount
        FROM orders o 
        JOIN customers c ON o.customer_id = c.id
        WHERE c.region = region_name
        GROUP BY customer_id, customer_name
    ) c
    WHERE c.total_amount > (
        SELECT AVG(total_amount) FROM (
            SELECT SUM(amount) as total_amount
            FROM orders o2 
            JOIN customers c2 ON o2.customer_id = c2.id
            WHERE c2.region = region_name  -- 重复的过滤逻辑
            GROUP BY customer_id
        ) avg_calc
    );
END //

-- 方式2：使用CTE（避免重复计算）
CREATE PROCEDURE CTEMethod(IN region_name VARCHAR(50))
BEGIN
    WITH customer_totals AS (
        SELECT 
            customer_id,
            customer_name,
            COUNT(*) as total_orders,
            SUM(amount) as total_amount
        FROM orders o 
        JOIN customers c ON o.customer_id = c.id
        WHERE c.region = region_name  -- 只写一次过滤条件
        GROUP BY customer_id, customer_name
    ),
    avg_amount AS (
        SELECT AVG(total_amount) as region_avg
        FROM customer_totals  -- 复用CTE，避免重复计算
    )
    SELECT 
        ct.customer_name,
        ct.total_orders,
        ct.total_amount,
        ROUND(ct.total_amount - aa.region_avg, 2) as amount_vs_avg
    FROM customer_totals ct
    CROSS JOIN avg_amount aa
    WHERE ct.total_amount > aa.region_avg
    ORDER BY ct.total_amount DESC;

END //
DELIMITER ;
```

### 4.2 内存使用优化



**💾 CTE内存管理策略**

```sql
-- 内存优化技巧：控制CTE结果集大小
DELIMITER //
CREATE PROCEDURE MemoryOptimizedAnalysis(IN analysis_date DATE)
BEGIN
    -- 优化前：可能产生大量临时数据
    -- WITH large_dataset AS (
    --     SELECT * FROM huge_table WHERE date_col >= analysis_date
    -- )
    
    -- 优化后：只选择必要字段，添加合理限制
    WITH optimized_dataset AS (
        SELECT 
            id,
            customer_id,
            amount,
            category  -- 只选择后续需要的字段
        FROM sales_data 
        WHERE sale_date = analysis_date
          AND amount > 0  -- 添加有意义的过滤条件
          AND status != 'cancelled'
        LIMIT 50000  -- 控制结果集大小
    ),
    category_summary AS (
        SELECT 
            category,
            COUNT(*) as count,
            SUM(amount) as total
        FROM optimized_dataset
        GROUP BY category
    )
    SELECT 
        category,
        count,
        total,
        ROUND(total/count, 2) as avg_amount
    FROM category_summary
    ORDER BY total DESC;

END //
DELIMITER ;
```

**⚡ 性能对比**
```
优化前的问题：
- 选择所有字段：SELECT * 
- 无限制结果集：可能百万行数据
- 内存占用：可能数GB临时数据

优化后的改进：
- 只选必要字段：减少50-80%内存占用
- 添加LIMIT：控制临时数据量
- 早期过滤：在CTE阶段就过滤数据
```

---

## 5. ⚡ 动态CTE构建



### 5.1 什么是动态CTE



**🔧 动态CTE的概念**

```
静态CTE：CTE定义在代码中写死，不能改变
动态CTE：根据参数或条件动态生成CTE定义

适用场景：
- 查询字段需要根据参数动态变化
- 过滤条件需要根据业务逻辑动态生成
- 报表格式需要根据用户需求定制
```

### 5.2 动态SQL构建CTE



**🏗️ 动态构建示例**

```sql
DELIMITER //
CREATE PROCEDURE DynamicReportBuilder(
    IN table_name VARCHAR(64),
    IN group_by_column VARCHAR(64), 
    IN filter_condition TEXT,
    IN time_range_days INT
)
BEGIN
    DECLARE sql_statement TEXT;
    
    -- 构建动态CTE SQL
    SET sql_statement = CONCAT(
        'WITH filtered_data AS (',
        '    SELECT ', group_by_column, ', amount, record_date ',
        '    FROM ', table_name, ' ',
        '    WHERE record_date >= DATE_SUB(NOW(), INTERVAL ', time_range_days, ' DAY)'
    );
    
    -- 添加自定义过滤条件
    IF filter_condition IS NOT NULL AND filter_condition != '' THEN
        SET sql_statement = CONCAT(
            sql_statement,
            ' AND ', filter_condition
        );
    END IF;
    
    -- 完成CTE定义和主查询
    SET sql_statement = CONCAT(
        sql_statement,
        '), ',
        'summary_data AS (',
        '    SELECT ', group_by_column, ', ',
        '           COUNT(*) as record_count, ',
        '           SUM(amount) as total_amount, ',
        '           AVG(amount) as avg_amount ',
        '    FROM filtered_data ',
        '    GROUP BY ', group_by_column,
        ') ',
        'SELECT * FROM summary_data ORDER BY total_amount DESC'
    );
    
    -- 准备并执行动态SQL
    SET @sql = sql_statement;
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

END //
DELIMITER ;

-- 使用示例
CALL DynamicReportBuilder('sales', 'region', 'amount > 1000', 30);
-- 生成SQL：
-- WITH filtered_data AS (
--     SELECT region, amount, record_date 
--     FROM sales 
--     WHERE record_date >= DATE_SUB(NOW(), INTERVAL 30 DAY) 
--       AND amount > 1000
-- ), summary_data AS (...)
```

### 5.3 条件化CTE构建



**🎛️ 基于业务条件动态选择CTE逻辑**

```sql
DELIMITER //
CREATE PROCEDURE ConditionalCTEProcessor(
    IN include_international BOOLEAN,
    IN include_vip_customers BOOLEAN,
    IN analysis_period VARCHAR(20)
)
BEGIN
    DECLARE date_filter_condition TEXT;
    DECLARE customer_filter_condition TEXT;
    
    -- 根据时间周期设置过滤条件
    CASE analysis_period
        WHEN 'week' THEN 
            SET date_filter_condition = 'order_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)';
        WHEN 'month' THEN 
            SET date_filter_condition = 'order_date >= DATE_SUB(NOW(), INTERVAL 1 MONTH)';
        WHEN 'quarter' THEN 
            SET date_filter_condition = 'order_date >= DATE_SUB(NOW(), INTERVAL 3 MONTH)';
        ELSE 
            SET date_filter_condition = 'order_date >= DATE_SUB(NOW(), INTERVAL 1 YEAR)';
    END CASE;
    
    -- 根据客户类型设置过滤条件
    SET customer_filter_condition = 'c.status = "active"';
    
    IF include_international THEN
        SET customer_filter_condition = CONCAT(
            customer_filter_condition, 
            ' AND c.country != "CN"'
        );
    END IF;
    
    IF include_vip_customers THEN
        SET customer_filter_condition = CONCAT(
            customer_filter_condition,
            ' AND c.customer_level = "VIP"'
        );
    END IF;
    
    -- 构建并执行查询
    SET @sql = CONCAT(
        'WITH targeted_orders AS (',
        '    SELECT o.order_id, o.customer_id, o.amount, c.customer_name, c.country ',
        '    FROM orders o JOIN customers c ON o.customer_id = c.id ',
        '    WHERE ', date_filter_condition, ' AND ', customer_filter_condition,
        ') ',
        'SELECT ',
        '    COUNT(*) as order_count, ',
        '    SUM(amount) as total_revenue, ',
        '    AVG(amount) as avg_order_value, ',
        '    COUNT(DISTINCT customer_id) as unique_customers ',
        'FROM targeted_orders'
    );
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

END //
DELIMITER ;
```

---

## 6. 🔄 存储过程递归CTE



### 6.1 递归CTE基础



**🌀 递归CTE的工作原理**

```
递归CTE = 初始查询 + 递归查询 + 终止条件

工作流程：
1. 执行初始查询（anchor）获得初始结果集
2. 执行递归查询（recursive）基于上次结果产生新结果
3. 重复步骤2直到没有新数据产生
4. 合并所有结果返回

就像爬楼梯：
- 初始：站在第1层
- 递归：每次爬到上一层+1
- 终止：到达顶层，无法继续爬
```

### 6.2 组织架构递归查询



**🏢 实战案例：查询组织层级**

```sql
DELIMITER //
CREATE PROCEDURE GetOrganizationHierarchy(IN root_dept_id INT)
BEGIN
    -- 递归CTE：从根部门开始，逐层查找下级部门
    WITH RECURSIVE department_tree AS (
        -- 初始查询：查找根部门
        SELECT 
            dept_id,
            dept_name,
            parent_dept_id,
            0 as level,  -- 根部门层级为0
            CAST(dept_name AS CHAR(500)) as path  -- 部门路径
        FROM departments 
        WHERE dept_id = root_dept_id
        
        UNION ALL
        
        -- 递归查询：查找每个部门的下级部门
        SELECT 
            d.dept_id,
            d.dept_name,
            d.parent_dept_id,
            dt.level + 1,  -- 层级递增
            CONCAT(dt.path, ' → ', d.dept_name) as path  -- 路径拼接
        FROM departments d
        INNER JOIN department_tree dt ON d.parent_dept_id = dt.dept_id
        WHERE dt.level < 10  -- 防止无限递归
    )
    -- 输出完整的组织架构
    SELECT 
        dept_id as '部门ID',
        CONCAT(REPEAT('  ', level), dept_name) as '部门名称',  -- 缩进显示层级
        level as '层级',
        path as '完整路径'
    FROM department_tree
    ORDER BY path;

END //
DELIMITER ;

-- 使用示例
CALL GetOrganizationHierarchy(1);  -- 从ID为1的根部门开始查询
```

**🔍 递归逻辑解析**
```
执行过程示例：

初始数据：
dept_id | dept_name | parent_dept_id
1       | 总公司     | NULL
2       | 技术部     | 1
3       | 市场部     | 1  
4       | 开发组     | 2
5       | 测试组     | 2

递归执行过程：
第1轮（初始）：找到dept_id=1的总公司
第2轮（递归）：找到parent_dept_id=1的技术部、市场部
第3轮（递归）：找到parent_dept_id=2的开发组、测试组  
第4轮（递归）：没有新数据，递归结束

最终结果：
总公司 (level=0)
  技术部 (level=1)
    开发组 (level=2)
    测试组 (level=2)
  市场部 (level=1)
```

### 6.3 商品类别递归查询



**🛍️ 商品分类层级处理**

```sql
DELIMITER //
CREATE PROCEDURE GetCategoryHierarchy(
    IN root_category_id INT,
    IN include_sales_data BOOLEAN
)
BEGIN
    -- 递归查询商品类别层级
    WITH RECURSIVE category_tree AS (
        -- 根类别
        SELECT 
            category_id,
            category_name,
            parent_category_id,
            0 as depth,
            CAST(category_name AS CHAR(200)) as full_path
        FROM product_categories 
        WHERE category_id = root_category_id
        
        UNION ALL
        
        -- 子类别
        SELECT 
            pc.category_id,
            pc.category_name, 
            pc.parent_category_id,
            ct.depth + 1,
            CONCAT(ct.full_path, ' / ', pc.category_name)
        FROM product_categories pc
        INNER JOIN category_tree ct ON pc.parent_category_id = ct.category_id
        WHERE ct.depth < 8  -- 限制递归深度
    )
    -- 根据参数决定是否包含销售数据
    SELECT 
        ct.category_id,
        CONCAT(REPEAT('├─ ', ct.depth), ct.category_name) as category_display,
        ct.depth,
        ct.full_path,
        CASE include_sales_data
            WHEN TRUE THEN (
                SELECT COUNT(*) FROM products p 
                WHERE p.category_id = ct.category_id
            )
            ELSE NULL
        END as product_count,
        CASE include_sales_data  
            WHEN TRUE THEN (
                SELECT COALESCE(SUM(oi.amount), 0)
                FROM order_items oi 
                JOIN products p ON oi.product_id = p.id
                WHERE p.category_id = ct.category_id
                  AND oi.order_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
            )
            ELSE NULL  
        END as monthly_sales
    FROM category_tree ct
    ORDER BY ct.full_path;

END //
DELIMITER ;

-- 调用示例
CALL GetCategoryHierarchy(1, TRUE);   -- 包含销售数据
CALL GetCategoryHierarchy(1, FALSE);  -- 不包含销售数据
```

### 6.4 递归CTE的安全控制



**🛡️ 防止无限递归**

```sql
-- 安全的递归CTE示例
DELIMITER //
CREATE PROCEDURE SafeRecursiveQuery(IN start_node_id INT)
BEGIN
    DECLARE max_depth INT DEFAULT 20;  -- 最大递归深度
    
    WITH RECURSIVE safe_tree AS (
        -- 初始查询
        SELECT 
            node_id,
            parent_id,
            node_name,
            0 as level,
            1 as iteration_count  -- 跟踪递归次数
        FROM tree_nodes 
        WHERE node_id = start_node_id
        
        UNION ALL
        
        -- 递归查询（添加安全检查）
        SELECT 
            tn.node_id,
            tn.parent_id,
            tn.node_name,
            st.level + 1,
            st.iteration_count + 1
        FROM tree_nodes tn
        INNER JOIN safe_tree st ON tn.parent_id = st.node_id
        WHERE st.level < max_depth  -- 深度限制
          AND st.iteration_count < 1000  -- 迭代次数限制
          AND tn.node_id NOT IN (  -- 避免循环引用
              SELECT parent_id FROM safe_tree WHERE parent_id IS NOT NULL
          )
    )
    SELECT 
        node_id,
        CONCAT(REPEAT('  ', level), node_name) as display_name,
        level,
        iteration_count
    FROM safe_tree
    ORDER BY level, node_id;

END //
DELIMITER ;
```

---

## 7. 🎯 实战应用案例



### 7.1 案例1：销售漏斗分析



**📈 复杂业务分析流程**

```sql
DELIMITER //
CREATE PROCEDURE SalesFunnelAnalysis(
    IN analysis_start_date DATE,
    IN analysis_end_date DATE,
    IN product_category VARCHAR(50)
)
BEGIN
    -- 多步骤漏斗分析
    WITH funnel_data AS (
        -- 第1步：潜在客户（浏览过商品）
        SELECT DISTINCT 
            customer_id,
            'viewed' as stage,
            1 as stage_order
        FROM product_views pv
        JOIN products p ON pv.product_id = p.id
        WHERE pv.view_date BETWEEN analysis_start_date AND analysis_end_date
          AND (product_category IS NULL OR p.category = product_category)
        
        UNION ALL
        
        -- 第2步：加入购物车
        SELECT DISTINCT
            customer_id,
            'added_to_cart' as stage,
            2 as stage_order
        FROM cart_items ci
        JOIN products p ON ci.product_id = p.id
        WHERE ci.added_date BETWEEN analysis_start_date AND analysis_end_date
          AND (product_category IS NULL OR p.category = product_category)
        
        UNION ALL
        
        -- 第3步：下单
        SELECT DISTINCT
            o.customer_id,
            'ordered' as stage, 
            3 as stage_order
        FROM orders o
        JOIN order_items oi ON o.order_id = oi.order_id
        JOIN products p ON oi.product_id = p.id
        WHERE o.order_date BETWEEN analysis_start_date AND analysis_end_date
          AND (product_category IS NULL OR p.category = product_category)
        
        UNION ALL
        
        -- 第4步：支付完成
        SELECT DISTINCT
            o.customer_id,
            'paid' as stage,
            4 as stage_order
        FROM orders o
        JOIN order_items oi ON o.order_id = oi.order_id
        JOIN products p ON oi.product_id = p.id
        WHERE o.order_date BETWEEN analysis_start_date AND analysis_end_date
          AND o.payment_status = 'paid'
          AND (product_category IS NULL OR p.category = product_category)
    ),
    -- 计算每个阶段的用户数
    stage_counts AS (
        SELECT 
            stage,
            stage_order,
            COUNT(DISTINCT customer_id) as customer_count
        FROM funnel_data
        GROUP BY stage, stage_order
    ),
    -- 计算转化率
    conversion_rates AS (
        SELECT 
            sc1.stage,
            sc1.customer_count,
            ROUND(
                sc1.customer_count * 100.0 / 
                FIRST_VALUE(sc1.customer_count) OVER (ORDER BY sc1.stage_order), 
                2
            ) as conversion_rate
        FROM stage_counts sc1
        ORDER BY sc1.stage_order
    )
    -- 输出漏斗分析结果
    SELECT 
        stage as '阶段',
        customer_count as '客户数量',
        CONCAT(conversion_rate, '%') as '转化率'
    FROM conversion_rates
    ORDER BY stage_order;

END //
DELIMITER ;

-- 使用示例
CALL SalesFunnelAnalysis('2023-01-01', '2023-01-31', '电子产品');
```

### 7.2 案例2：客户生命周期价值计算



**💰 客户价值分析**

```sql
DELIMITER //  
CREATE PROCEDURE CustomerLifetimeValue(IN target_customer_id INT)
BEGIN
    -- 复杂的客户价值计算
    WITH customer_orders AS (
        -- 客户所有订单基础数据
        SELECT 
            order_id,
            order_date,
            amount,
            status,
            YEAR(order_date) as order_year,
            QUARTER(order_date) as order_quarter
        FROM orders 
        WHERE customer_id = target_customer_id
          AND status IN ('completed', 'shipped')
    ),
    yearly_summary AS (
        -- 按年度汇总
        SELECT 
            order_year,
            COUNT(*) as yearly_orders,
            SUM(amount) as yearly_revenue,
            AVG(amount) as yearly_avg_order
        FROM customer_orders
        GROUP BY order_year
    ),
    purchase_frequency AS (
        -- 计算购买频次
        SELECT 
            order_year,
            yearly_orders,
            CASE 
                WHEN yearly_orders >= 12 THEN '高频客户'
                WHEN yearly_orders >= 6 THEN '中频客户'  
                WHEN yearly_orders >= 2 THEN '低频客户'
                ELSE '一次性客户'
            END as frequency_segment
        FROM yearly_summary
    ),
    customer_segments AS (
        -- 客户分层
        SELECT 
            ys.order_year,
            ys.yearly_revenue,
            pf.frequency_segment,
            CASE 
                WHEN ys.yearly_revenue >= 10000 THEN '高价值'
                WHEN ys.yearly_revenue >= 5000 THEN '中价值'
                WHEN ys.yearly_revenue >= 1000 THEN '低价值' 
                ELSE '潜在价值'
            END as value_segment
        FROM yearly_summary ys
        JOIN purchase_frequency pf ON ys.order_year = pf.order_year
    )
    -- 输出客户价值分析报告
    SELECT 
        order_year as '年份',
        yearly_revenue as '年度消费',
        frequency_segment as '购买频次分层',
        value_segment as '价值分层',
        ROUND(yearly_revenue / yearly_orders, 2) as '平均订单价值'
    FROM customer_segments cs
    JOIN yearly_summary ys ON cs.order_year = ys.order_year
    ORDER BY order_year DESC;

END //
DELIMITER ;
```

---

## 8. 🚀 性能优化与最佳实践



### 8.1 CTE性能优化技巧



**⚡ 优化策略总结**

| 优化方面 | **策略** | **适用场景** | **预期效果** |
|---------|---------|-------------|-------------|
| `索引优化` | `为CTE中的WHERE条件添加索引` | `大表过滤` | `查询时间减少60-90%` |
| `字段选择` | `只选择必要字段，避免SELECT *` | `所有场景` | `内存占用减少30-70%` |
| `早期过滤` | `在CTE中尽早过滤数据` | `大数据集` | `临时数据减少50-80%` |
| `结果集控制` | `使用LIMIT控制CTE结果大小` | `探索性查询` | `响应时间更稳定` |

**🔧 具体优化示例**
```sql
-- 优化前：性能较差的CTE
WITH expensive_cte AS (
    SELECT *  -- 选择所有字段（浪费）
    FROM large_table lt
    JOIN another_large_table alt ON lt.id = alt.ref_id  -- 大表连接
    -- 没有WHERE过滤条件
)
SELECT COUNT(*) FROM expensive_cte WHERE created_date >= '2023-01-01';

-- 优化后：性能优化的CTE  
WITH optimized_cte AS (
    SELECT 
        lt.id, lt.created_date, alt.amount  -- 只选择必要字段
    FROM large_table lt
    JOIN another_large_table alt ON lt.id = alt.ref_id
    WHERE lt.created_date >= '2023-01-01'  -- 早期过滤
      AND lt.status = 'active'
      AND alt.amount > 0
)
SELECT COUNT(*) FROM optimized_cte;
```

### 8.2 CTE与临时表的选择



**🤔 何时用CTE，何时用临时表**

```sql
-- 场景对比分析
DELIMITER //
CREATE PROCEDURE CompareCteTempTable()
BEGIN
    -- 方案1：使用CTE（适合一次性使用）
    WITH monthly_sales AS (
        SELECT 
            product_id,
            SUM(amount) as monthly_total
        FROM sales 
        WHERE sale_date >= DATE_SUB(NOW(), INTERVAL 1 MONTH)
        GROUP BY product_id
    )
    SELECT p.product_name, ms.monthly_total
    FROM monthly_sales ms
    JOIN products p ON ms.product_id = p.id
    ORDER BY ms.monthly_total DESC
    LIMIT 10;
    
    -- 方案2：使用临时表（适合多次使用）
    CREATE TEMPORARY TABLE temp_monthly_sales AS
    SELECT 
        product_id,
        SUM(amount) as monthly_total
    FROM sales 
    WHERE sale_date >= DATE_SUB(NOW(), INTERVAL 1 MONTH)
    GROUP BY product_id;
    
    -- 为临时表添加索引提高后续查询性能
    ALTER TABLE temp_monthly_sales ADD INDEX idx_product_id(product_id);
    
    -- 多次使用临时表
    SELECT '前10名产品' as report_type, COUNT(*) as count FROM temp_monthly_sales WHERE monthly_total > 1000;
    SELECT '销售总额' as metric, SUM(monthly_total) as value FROM temp_monthly_sales;
    SELECT '平均销售额' as metric, AVG(monthly_total) as value FROM temp_monthly_sales;
    
    -- 清理临时表
    DROP TEMPORARY TABLE temp_monthly_sales;

END //
DELIMITER ;
```

**📊 选择指导原则**
```
使用CTE的场景：
✅ 结果只用一次
✅ 逻辑相对简单
✅ 希望代码集中在一个语句中
✅ 不需要添加索引

使用临时表的场景：
✅ 结果需要多次使用
✅ 需要为结果添加索引
✅ 结果数据量很大
✅ 需要在不同的存储过程间共享数据
```

### 8.3 错误处理与调试



**🐛 CTE调试技巧**

```sql
DELIMITER //
CREATE PROCEDURE DebugableCTEProcess(IN debug_mode BOOLEAN)
BEGIN
    DECLARE exit handler for sqlexception
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 可调试的CTE设计
    WITH sales_data AS (
        SELECT 
            sale_id,
            customer_id,
            product_id,
            amount,
            sale_date
        FROM sales 
        WHERE sale_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    )
    -- 根据debug_mode决定输出内容
    SELECT 
        CASE debug_mode
            WHEN TRUE THEN 'DEBUG: 原始数据行数'
            ELSE '销售汇总'
        END as report_type,
        CASE debug_mode
            WHEN TRUE THEN COUNT(*)
            ELSE SUM(amount)
        END as result_value
    FROM sales_data;
    
    -- 如果是调试模式，输出详细信息
    IF debug_mode THEN
        WITH debug_info AS (
            SELECT 
                'CTE行数' as metric,
                COUNT(*) as value
            FROM sales_data
            
            UNION ALL
            
            SELECT 
                '平均金额' as metric,
                ROUND(AVG(amount), 2) as value  
            FROM sales_data
        )
        SELECT * FROM debug_info;
    END IF;
    
    COMMIT;

END //
DELIMITER ;

-- 调试使用
CALL DebugableCTEProcess(TRUE);   -- 调试模式
CALL DebugableCTEProcess(FALSE);  -- 正常模式
```

---

## 9. 📋 核心要点总结



### 9.1 必须掌握的基本概念



```
🔸 CTE在存储过程中的作用：分解复杂逻辑，提高代码可读性
🔸 临时结果集传递：CTE可以在同一查询中多次引用，实现数据复用
🔸 动态CTE构建：使用动态SQL根据参数生成不同的CTE逻辑
🔸 递归CTE应用：处理层级数据，如组织架构、商品分类等
🔸 性能优化：通过合理设计CTE减少重复计算和内存占用
```

### 9.2 关键理解要点



**🔹 CTE vs 子查询 vs 临时表**
```
选择原则：

CTE：适合逻辑分解，一次使用
- 代码清晰，易于理解
- 性能优化，MySQL可以更好地优化
- 作用域限制在单个语句内

子查询：适合简单条件过滤  
- 适合简单的EXISTS、IN操作
- 不适合复杂的多步骤处理

临时表：适合数据复用，复杂处理
- 可以添加索引提高性能
- 可以在多个查询间共享
- 需要手动管理生命周期
```

**🔹 存储过程中CTE的优势**
```
代码组织优势：
- 将复杂查询分解为多个逻辑清晰的步骤
- 每个CTE职责单一，便于理解和维护
- 可以逐步验证每个CTE的正确性

性能优势：
- 避免重复计算相同的中间结果
- MySQL优化器可以更好地优化整个查询
- 减少临时表的创建和销毁开销

维护优势：
- 修改业务逻辑时只需调整对应的CTE
- 添加新的处理步骤很容易
- 代码复用性强
```

**🔹 递归CTE的关键点**
```
设计要点：
1. 明确初始条件（anchor query）
2. 定义递归条件（recursive query）  
3. 设置终止条件（避免无限递归）
4. 控制递归深度（防止栈溢出）

安全措施：
- 设置最大递归深度限制
- 添加循环检测机制
- 监控递归执行时间
- 准备异常处理机制
```

### 9.3 实际应用指导



**🎯 适用场景判断**
```
推荐使用CTE的场景：
✅ 复杂的多步骤数据处理
✅ 需要多次引用相同中间结果
✅ 层级数据的递归查询
✅ 报表和分析类查询
✅ 代码可读性要求高的场景

不推荐使用的场景：
❌ 简单的单表查询
❌ 高频的OLTP操作
❌ 对性能要求极致的场景
❌ 需要跨存储过程共享数据
```

**🔧 最佳实践指南**
```
设计原则：
1. 每个CTE职责单一，逻辑清晰
2. 合理控制CTE的复杂度和嵌套层次
3. 优先在CTE中进行数据过滤
4. 避免在CTE中进行不必要的计算

命名规范：
- 使用有意义的CTE名称（如filtered_orders，而非temp1）
- 统一命名风格（如统一使用下划线分隔）
- 避免使用MySQL保留字作为CTE名称

性能考虑：
- 为CTE中使用的字段添加适当索引
- 控制CTE结果集的大小
- 监控CTE查询的执行计划
- 必要时考虑将CTE改为临时表
```

### 9.4 记忆要点



**🧠 核心记忆**
- **CTE作用**：在存储过程中分解复杂逻辑，提高代码可读性
- **生命周期**：作用域限制在定义它的SQL语句内
- **性能特点**：避免重复计算，但不能跨语句复用
- **递归应用**：处理层级数据的利器，需要注意安全控制
- **优化重点**：早期过滤、字段选择、索引支持

**🎯 实战口诀**
```
CTE使用三原则：
1. 逻辑清晰职责单一（每个CTE做一件事）
2. 早期过滤减少数据（WHERE条件前置）
3. 合理命名便于维护（见名知意）

存储过程CTE四步走：
1. 分析需求拆分步骤（确定需要几个CTE）
2. 设计CTE定义逻辑（每步做什么）
3. 编写主查询组合（如何使用CTE结果）
4. 测试优化性能表现（检查执行计划）
```

**核心原则**：CTE是存储过程中组织复杂查询逻辑的强大工具，正确使用可以显著提高代码质量和执行效率。关键在于合理分解业务逻辑，充分利用CTE的临时结果集特性，同时注意性能优化和安全控制。