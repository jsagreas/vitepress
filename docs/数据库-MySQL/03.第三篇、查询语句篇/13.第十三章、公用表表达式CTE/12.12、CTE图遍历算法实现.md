---
title: 12、CTE图遍历算法实现
---
## 📚 目录

1. [图遍历算法概述](#1-图遍历算法概述)
2. [图结构数据表示](#2-图结构数据表示)
3. [深度优先遍历DFS](#3-深度优先遍历dfs)
4. [广度优先遍历BFS](#4-广度优先遍历bfs)
5. [路径查找算法](#5-路径查找算法)
6. [环检测算法](#6-环检测算法)
7. [最短路径算法](#7-最短路径算法)
8. [连通性分析](#8-连通性分析)
9. [性能优化技巧](#9-性能优化技巧)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌐 图遍历算法概述


### 1.1 什么是图遍历


**💡 基本概念**
```
图遍历：按照某种策略访问图中所有节点的过程

形象理解：
就像在一个城市里旅游，要访问所有景点
- 有些景点之间有直达路线（边）
- 有些需要绕行才能到达
- 遍历就是找到一条路线，确保每个景点都去过

图的基本要素：
┌─────┐     边(Edge)     ┌─────┐
│ 节点A │ ──────────────→ │ 节点B │
│(Node)│                 │(Node)│
└─────┘                 └─────┘

实际应用举例：
🔸 社交网络：人是节点，关注关系是边
🔸 网页链接：网页是节点，超链接是边
🔸 交通网络：城市是节点，道路是边
🔸 组织架构：员工是节点，汇报关系是边
```

### 1.2 为什么要用CTE实现图算法


**🤔 传统方法的问题**
```
存储过程方式：
❌ 代码复杂，难以维护
❌ 调试困难
❌ 移植性差

应用程序方式：
❌ 需要多次数据库往返
❌ 网络开销大
❌ 数据一致性难保证

CTE递归方式：
✅ SQL标准语法，移植性好
✅ 单次查询完成复杂遍历
✅ 代码清晰，易于理解
✅ 数据库引擎优化支持
```

### 1.3 CTE图遍历基本模式


**🔄 递归CTE基本结构**
```sql
WITH RECURSIVE graph_traversal AS (
    -- 基础查询（起始节点）
    SELECT node_id, path, level
    FROM start_condition
    
    UNION ALL
    
    -- 递归查询（扩展到相邻节点）
    SELECT next_node, updated_path, level + 1
    FROM graph_traversal gt
    JOIN graph_edges ge ON gt.node_id = ge.from_node
    WHERE termination_condition
)
SELECT * FROM graph_traversal;
```

**📋 模式要素解析**
```
基础查询：定义遍历的起始点
递归查询：定义如何从当前节点扩展到下一个节点
终止条件：防止无限递归（如检测环、限制深度）
路径记录：跟踪从起点到当前节点的完整路径
深度计算：记录当前节点距离起点的层数
```

---

## 2. 🗂️ 图结构数据表示


### 2.1 图数据的表存储方式


**📊 邻接表表示法（推荐）**
```sql
-- 图的边表（最常用的表示方法）
CREATE TABLE graph_edges (
    id          INT PRIMARY KEY AUTO_INCREMENT,
    from_node   VARCHAR(50) NOT NULL,
    to_node     VARCHAR(50) NOT NULL,
    weight      DECIMAL(10,2) DEFAULT 1,
    edge_type   VARCHAR(20) DEFAULT 'normal',
    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_from_node (from_node),
    INDEX idx_to_node (to_node),
    INDEX idx_from_to (from_node, to_node)
);
```

**💡 为什么选择邻接表**
```
优势对比：

邻接表（推荐）：
✅ 存储空间效率高
✅ 适合稀疏图（边数相对较少）
✅ 添加删除边操作简单
✅ 符合关系数据库设计习惯

邻接矩阵：
❌ 空间复杂度O(n²)，浪费存储
❌ 不适合动态图结构
✅ 判断两点间是否有边的速度快O(1)

实际选择：
99%的实际业务场景都适合用邻接表
只有在密集图且频繁查询边存在性时才考虑邻接矩阵
```

### 2.2 示例数据准备


**🌳 员工组织架构示例**
```sql
-- 创建示例数据：公司组织架构图
INSERT INTO graph_edges (from_node, to_node, weight, edge_type) VALUES
('CEO', '技术VP', 1, 'reports_to'),
('CEO', '销售VP', 1, 'reports_to'),
('CEO', '财务VP', 1, 'reports_to'),
('技术VP', '研发总监', 1, 'reports_to'),
('技术VP', '架构师', 1, 'reports_to'),
('研发总监', '前端组长', 1, 'reports_to'),
('研发总监', '后端组长', 1, 'reports_to'),
('前端组长', '前端工程师A', 1, 'reports_to'),
('前端组长', '前端工程师B', 1, 'reports_to'),
('后端组长', '后端工程师A', 1, 'reports_to'),
('后端组长', '后端工程师B', 1, 'reports_to'),
('销售VP', '销售经理', 1, 'reports_to'),
('销售经理', '销售代表A', 1, 'reports_to'),
('销售经理', '销售代表B', 1, 'reports_to');
```

**🗺️ 图结构可视化**
```
组织架构图：
                    CEO
                   /  |  \
                  /   |   \
              技术VP  销售VP  财务VP
              /   \      |
             /     \     |
        研发总监   架构师  销售经理
        /    \            /    \
       /      \          /      \
   前端组长   后端组长   销售代表A  销售代表B
   /    \     /    \
  前端A  前端B  后端A  后端B
```

**📊 其他图类型示例**
```sql
-- 城市交通网络
INSERT INTO graph_edges (from_node, to_node, weight, edge_type) VALUES
('北京', '上海', 1318, 'flight'),
('北京', '广州', 2129, 'flight'),
('上海', '深圳', 1447, 'flight'),
('广州', '深圳', 120, 'highway'),
('北京', '天津', 137, 'highway');

-- 网页链接关系
INSERT INTO graph_edges (from_node, to_node, weight, edge_type) VALUES
('homepage', 'products', 1, 'link'),
('homepage', 'about', 1, 'link'),
('products', 'product_detail', 1, 'link'),
('product_detail', 'cart', 1, 'link'),
('cart', 'checkout', 1, 'link');
```

---

## 3. 🏊‍♂️ 深度优先遍历DFS


### 3.1 DFS基本原理


**💭 什么是深度优先遍历**
```
深度优先（DFS）：一条路走到黑，走不通了再回头

形象比喻：
就像探索迷宫，选择一个方向一直走下去
走到死路时，回到最近的分岔口，选择另一条路
直到所有路径都探索完毕

遍历特点：
🔸 优先向深度发展：先访问子节点，再访问兄弟节点
🔸 使用栈结构：后进先出，自然回溯
🔸 空间效率：只需要记录当前路径
🔸 适合场景：路径查找、环检测
```

### 3.2 DFS递归CTE实现


**🔧 基础DFS实现**
```sql
-- 从指定节点开始的深度优先遍历
WITH RECURSIVE dfs_traversal AS (
    -- 基础查询：选择起始节点
    SELECT 
        from_node as current_node,
        to_node,
        from_node as root_node,
        CAST(from_node AS CHAR(1000)) as path,
        0 as level,
        CAST(from_node AS CHAR(1000)) as visited_nodes
    FROM graph_edges 
    WHERE from_node = 'CEO'  -- 从CEO开始遍历
    
    UNION ALL
    
    -- 递归查询：扩展到下一层节点
    SELECT 
        ge.from_node as current_node,
        ge.to_node,
        dt.root_node,
        CONCAT(dt.path, ' → ', ge.to_node) as path,
        dt.level + 1 as level,
        CONCAT(dt.visited_nodes, ',', ge.to_node) as visited_nodes
    FROM dfs_traversal dt
    JOIN graph_edges ge ON dt.to_node = ge.from_node
    WHERE dt.level < 10  -- 防止无限递归
      AND FIND_IN_SET(ge.to_node, dt.visited_nodes) = 0  -- 避免环路
)
SELECT 
    current_node,
    to_node,
    level,
    path as traversal_path
FROM dfs_traversal
ORDER BY level, current_node;
```

**📋 DFS结果示例**
```
current_node     to_node         level  traversal_path
CEO             技术VP           0      CEO
技术VP          研发总监         1      CEO → 技术VP
研发总监        前端组长         2      CEO → 技术VP → 研发总监  
前端组长        前端工程师A       3      CEO → 技术VP → 研发总监 → 前端组长
前端工程师A     (NULL)          4      CEO → 技术VP → 研发总监 → 前端组长 → 前端工程师A
前端组长        前端工程师B       3      CEO → 技术VP → 研发总监 → 前端组长
前端工程师B     (NULL)          4      CEO → 技术VP → 研发总监 → 前端组长 → 前端工程师B
...
```

### 3.3 DFS路径记录技术


**🗺️ 路径字符串构建**
```sql
-- 改进的路径记录方法
WITH RECURSIVE dfs_with_path AS (
    -- 起始节点
    SELECT 
        from_node,
        to_node,
        1 as level,
        JSON_ARRAY(from_node, to_node) as path_json,
        CONCAT(from_node, ' → ', to_node) as path_string,
        CONCAT(',', from_node, ',', to_node, ',') as visited_set
    FROM graph_edges 
    WHERE from_node = 'CEO'
    
    UNION ALL
    
    -- 递归扩展
    SELECT 
        ge.from_node,
        ge.to_node,
        dp.level + 1,
        JSON_ARRAY_APPEND(dp.path_json, '$', ge.to_node) as path_json,
        CONCAT(dp.path_string, ' → ', ge.to_node) as path_string,
        CONCAT(dp.visited_set, ge.to_node, ',') as visited_set
    FROM dfs_with_path dp
    JOIN graph_edges ge ON dp.to_node = ge.from_node
    WHERE dp.level < 8
      AND INSTR(dp.visited_set, CONCAT(',', ge.to_node, ',')) = 0
)
SELECT 
    from_node,
    to_node,
    level,
    path_string,
    JSON_EXTRACT(path_json, '$') as path_array
FROM dfs_with_path
ORDER BY level, path_string;
```

### 3.4 DFS深度层次计算


**📏 计算节点深度**
```sql
-- 计算每个节点在组织架构中的层级深度
WITH RECURSIVE node_depth AS (
    -- 根节点深度为0
    SELECT 
        node_name,
        0 as depth,
        node_name as path_from_root
    FROM (
        SELECT DISTINCT from_node as node_name FROM graph_edges
        WHERE from_node NOT IN (SELECT DISTINCT to_node FROM graph_edges)
    ) root_nodes
    
    UNION ALL
    
    -- 子节点深度 = 父节点深度 + 1
    SELECT 
        ge.to_node as node_name,
        nd.depth + 1 as depth,
        CONCAT(nd.path_from_root, ' → ', ge.to_node) as path_from_root
    FROM node_depth nd
    JOIN graph_edges ge ON nd.node_name = ge.from_node
    WHERE nd.depth < 10
)
SELECT 
    node_name,
    MAX(depth) as max_depth,
    GROUP_CONCAT(path_from_root ORDER BY depth SEPARATOR '; ') as all_paths
FROM node_depth
GROUP BY node_name
ORDER BY max_depth, node_name;
```

**📊 深度统计分析**
```sql
-- 组织架构深度分析
WITH RECURSIVE org_depth AS (
    SELECT from_node, 0 as depth FROM graph_edges WHERE from_node = 'CEO'
    UNION ALL
    SELECT ge.to_node, od.depth + 1
    FROM org_depth od
    JOIN graph_edges ge ON od.from_node = ge.from_node
    WHERE od.depth < 10
)
SELECT 
    depth as 组织层级,
    COUNT(*) as 人员数量,
    GROUP_CONCAT(from_node ORDER BY from_node) as 该层级人员
FROM org_depth
GROUP BY depth
ORDER BY depth;
```

---

## 4. 🌊 广度优先遍历BFS


### 4.1 BFS基本原理


**💭 什么是广度优先遍历**
```
广度优先（BFS）：一层一层地扩展，像水波纹一样

形象比喻：
就像石头投入池塘，波纹一圈圈向外扩散
先访问距离起点1步的所有节点
再访问距离起点2步的所有节点
依次类推...

遍历特点：
🔸 优先扩展广度：先访问同层节点，再深入下一层
🔸 使用队列结构：先进先出，层级有序
🔸 最短路径：第一次到达目标节点的路径最短
🔸 适合场景：最短路径、层级分析
```

### 4.2 BFS递归CTE实现


**🔧 基础BFS实现**
```sql
-- 广度优先遍历实现
WITH RECURSIVE bfs_traversal AS (
    -- 基础查询：第0层（起始节点）
    SELECT 
        'CEO' as current_node,
        0 as level,
        'CEO' as path,
        'CEO' as visited_nodes
    
    UNION ALL
    
    -- 递归查询：逐层扩展
    SELECT 
        ge.to_node as current_node,
        bt.level + 1 as level,
        CONCAT(bt.path, ' → ', ge.to_node) as path,
        CONCAT(bt.visited_nodes, ',', ge.to_node) as visited_nodes
    FROM bfs_traversal bt
    JOIN graph_edges ge ON bt.current_node = ge.from_node
    WHERE bt.level < 5
      AND FIND_IN_SET(ge.to_node, bt.visited_nodes) = 0
),
-- 按层级分组，确保BFS顺序
bfs_ordered AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY level ORDER BY current_node) as order_in_level
    FROM bfs_traversal
)
SELECT 
    level as 层级,
    current_node as 当前节点,
    path as 访问路径,
    order_in_level as 层内序号
FROM bfs_ordered
ORDER BY level, order_in_level;
```

**📊 BFS结果对比**
```
BFS遍历结果（按层级顺序）：
层级0: CEO
层级1: 技术VP, 销售VP, 财务VP  
层级2: 研发总监, 架构师, 销售经理
层级3: 前端组长, 后端组长, 销售代表A, 销售代表B
层级4: 前端工程师A, 前端工程师B, 后端工程师A, 后端工程师B

DFS vs BFS 访问顺序对比：
DFS顺序: CEO → 技术VP → 研发总监 → 前端组长 → 前端A → 前端B → 后端组长...
BFS顺序: CEO → 技术VP → 销售VP → 财务VP → 研发总监 → 架构师 → 销售经理...

关键区别：
DFS：深入到底再回头
BFS：铺开一层再深入
```

### 4.3 BFS层级遍历优化


**⚡ 性能优化版BFS**
```sql
-- 优化的分层BFS实现
WITH RECURSIVE level_by_level AS (
    -- 第0层：根节点
    SELECT 
        from_node as node,
        0 as level,
        from_node as path,
        1 as path_length
    FROM graph_edges 
    WHERE from_node = 'CEO'
    GROUP BY from_node
    
    UNION ALL
    
    -- 逐层扩展
    SELECT 
        ge.to_node as node,
        lbl.level + 1 as level,
        CONCAT(lbl.path, '→', ge.to_node) as path,
        lbl.path_length + 1 as path_length
    FROM level_by_level lbl
    JOIN graph_edges ge ON lbl.node = ge.from_node
    WHERE lbl.level < 6
),
-- 去重处理：每个节点只保留最短路径
shortest_paths AS (
    SELECT 
        node,
        MIN(level) as min_level,
        MIN(path_length) as min_path_length
    FROM level_by_level
    GROUP BY node
)
SELECT 
    lbl.node as 节点名称,
    lbl.level as 层级,
    lbl.path as 最短路径,
    lbl.path_length as 路径长度
FROM level_by_level lbl
JOIN shortest_paths sp ON lbl.node = sp.node 
                      AND lbl.level = sp.min_level 
                      AND lbl.path_length = sp.min_path_length
ORDER BY lbl.level, lbl.node;
```

---

## 5. 🎯 路径查找算法


### 5.1 两点间路径查找


**🛤️ 单条路径查找**
```sql
-- 查找从起点到终点的路径
WITH RECURSIVE path_finder AS (
    -- 起始节点
    SELECT 
        from_node as current_node,
        to_node as next_node,
        CAST(CONCAT(from_node, ' → ', to_node) AS CHAR(2000)) as path,
        1 as path_length,
        CAST(CONCAT(',', from_node, ',', to_node, ',') AS CHAR(2000)) as visited
    FROM graph_edges 
    WHERE from_node = 'CEO'
    
    UNION ALL
    
    -- 递归扩展路径
    SELECT 
        ge.from_node as current_node,
        ge.to_node as next_node,
        CAST(CONCAT(pf.path, ' → ', ge.to_node) AS CHAR(2000)) as path,
        pf.path_length + 1 as path_length,
        CAST(CONCAT(pf.visited, ge.to_node, ',') AS CHAR(2000)) as visited
    FROM path_finder pf
    JOIN graph_edges ge ON pf.next_node = ge.from_node
    WHERE pf.path_length < 8
      AND INSTR(pf.visited, CONCAT(',', ge.to_node, ',')) = 0
      AND ge.to_node = '前端工程师A'  -- 目标节点
)
SELECT 
    path as 完整路径,
    path_length as 路径长度
FROM path_finder 
WHERE next_node = '前端工程师A'  -- 找到目标
ORDER BY path_length
LIMIT 1;  -- 取最短路径
```

### 5.2 多路径查找算法


**🔀 查找所有可能路径**
```sql
-- 查找两点间的所有路径
WITH RECURSIVE all_paths AS (
    -- 起始路径
    SELECT 
        from_node as start_node,
        to_node as end_node,
        CONCAT(from_node, ' → ', to_node) as path,
        1 as hops,
        CONCAT(',', from_node, ',', to_node, ',') as visited
    FROM graph_edges 
    WHERE from_node = '技术VP'
    
    UNION ALL
    
    -- 路径扩展
    SELECT 
        ap.start_node,
        ge.to_node as end_node,
        CONCAT(ap.path, ' → ', ge.to_node) as path,
        ap.hops + 1 as hops,
        CONCAT(ap.visited, ge.to_node, ',') as visited
    FROM all_paths ap
    JOIN graph_edges ge ON ap.end_node = ge.from_node
    WHERE ap.hops < 6
      AND INSTR(ap.visited, CONCAT(',', ge.to_node, ',')) = 0
)
-- 筛选到达特定目标的所有路径
SELECT 
    path as 路径,
    hops as 跳数,
    CASE 
        WHEN hops <= 2 THEN '短路径'
        WHEN hops <= 4 THEN '中等路径' 
        ELSE '长路径'
    END as 路径类型
FROM all_paths 
WHERE end_node IN ('前端工程师A', '后端工程师B')
ORDER BY end_node, hops;
```

### 5.3 路径过滤与优化


**🎯 智能路径筛选**
```sql
-- 查找最优路径（考虑权重）
WITH RECURSIVE weighted_paths AS (
    -- 起始边
    SELECT 
        from_node,
        to_node,
        weight as total_weight,
        CONCAT(from_node, ' → ', to_node) as path,
        1 as edge_count,
        CONCAT(',', from_node, ',', to_node, ',') as visited
    FROM graph_edges 
    WHERE from_node = '北京'
    
    UNION ALL
    
    -- 路径扩展（累积权重）
    SELECT 
        ge.from_node,
        ge.to_node,
        wp.total_weight + ge.weight as total_weight,
        CONCAT(wp.path, ' → ', ge.to_node) as path,
        wp.edge_count + 1 as edge_count,
        CONCAT(wp.visited, ge.to_node, ',') as visited
    FROM weighted_paths wp
    JOIN graph_edges ge ON wp.to_node = ge.from_node
    WHERE wp.edge_count < 5
      AND INSTR(wp.visited, CONCAT(',', ge.to_node, ',')) = 0
),
-- 为每个目标城市找最短路径
best_paths AS (
    SELECT 
        to_node as destination,
        MIN(total_weight) as min_weight,
        MIN(edge_count) as min_hops
    FROM weighted_paths
    WHERE to_node = '深圳'  -- 目标城市
    GROUP BY to_node
)
SELECT 
    wp.path as 最优路径,
    wp.total_weight as 总距离,
    wp.edge_count as 中转次数,
    bp.min_weight as 最短距离,
    bp.min_hops as 最少中转
FROM weighted_paths wp
JOIN best_paths bp ON wp.to_node = bp.destination
WHERE wp.total_weight = bp.min_weight
   OR wp.edge_count = bp.min_hops
ORDER BY wp.total_weight;
```

---

## 6. ⭕ 环检测算法


### 6.1 环检测的重要性


**💭 为什么要检测环**
```
环的含义：从某个节点出发，能够回到自己的路径

现实例子：
🔸 组织架构：A管理B，B管理C，C管理A → 管理混乱
🔸 依赖关系：模块A依赖B，B依赖C，C依赖A → 循环依赖
🔸 交通网络：道路形成环路 → 可能有最优绕行路径

检测必要性：
⚠️ 防止无限递归：遍历算法陷入死循环
⚠️ 逻辑错误发现：业务数据的逻辑矛盾
⚠️ 系统稳定性：避免因环导致的系统问题
```

### 6.2 基础环检测算法


**🔍 简单环检测**
```sql
-- 检测图中是否存在环
WITH RECURSIVE cycle_detector AS (
    -- 从每个节点开始检测
    SELECT 
        from_node as start_node,
        from_node as current_node,
        to_node as next_node,
        CONCAT(from_node, ',', to_node) as path,
        1 as path_length
    FROM graph_edges
    
    UNION ALL
    
    -- 路径扩展
    SELECT 
        cd.start_node,
        ge.from_node as current_node,
        ge.to_node as next_node,
        CONCAT(cd.path, ',', ge.to_node) as path,
        cd.path_length + 1 as path_length
    FROM cycle_detector cd
    JOIN graph_edges ge ON cd.next_node = ge.from_node
    WHERE cd.path_length < 10
      AND FIND_IN_SET(ge.to_node, cd.path) = 0  -- 没有重复访问
),
-- 检测环的存在
cycles_found AS (
    SELECT 
        cd.start_node,
        cd.path,
        cd.next_node,
        cd.path_length
    FROM cycle_detector cd
    JOIN graph_edges ge ON cd.next_node = ge.from_node
    WHERE ge.to_node = cd.start_node  -- 回到起始节点，形成环
)
SELECT 
    start_node as 环起点,
    CONCAT(path, ',', start_node) as 完整环路径,
    path_length + 1 as 环长度
FROM cycles_found
ORDER BY 环长度;
```

### 6.3 高级环检测与分析


**🔬 详细环分析**
```sql
-- 复杂环检测，支持多种环类型分析
WITH RECURSIVE comprehensive_cycle_detection AS (
    -- 初始化：从每个节点开始
    SELECT 
        from_node as origin,
        from_node as current_node,
        to_node,
        JSON_ARRAY(from_node, to_node) as path_nodes,
        CONCAT(from_node, ' → ', to_node) as path_display,
        1 as depth,
        false as cycle_detected
    FROM graph_edges
    
    UNION ALL
    
    -- 递归扩展
    SELECT 
        ccd.origin,
        ge.from_node as current_node,
        ge.to_node,
        JSON_ARRAY_APPEND(ccd.path_nodes, '$', ge.to_node) as path_nodes,
        CONCAT(ccd.path_display, ' → ', ge.to_node) as path_display,
        ccd.depth + 1 as depth,
        CASE 
            WHEN ge.to_node = ccd.origin THEN true  -- 检测到环
            ELSE false 
        END as cycle_detected
    FROM comprehensive_cycle_detection ccd
    JOIN graph_edges ge ON ccd.to_node = ge.from_node
    WHERE ccd.depth < 8
      AND ccd.cycle_detected = false
      AND JSON_SEARCH(ccd.path_nodes, 'one', ge.to_node) IS NULL  -- 避免重复访问
),
-- 提取检测到的环
detected_cycles AS (
    SELECT DISTINCT
        origin as 环起点,
        path_display as 环路径,
        depth as 环长度,
        JSON_LENGTH(path_nodes) as 节点数量
    FROM comprehensive_cycle_detection
    WHERE cycle_detected = true
)
SELECT 
    环起点,
    环路径,
    环长度,
    节点数量,
    CASE 
        WHEN 环长度 = 2 THEN '双向边'
        WHEN 环长度 = 3 THEN '三角环'
        WHEN 环长度 <= 5 THEN '短环'
        ELSE '长环'
    END as 环类型
FROM detected_cycles
ORDER BY 环长度, 环起点;
```

---

## 7. 🚀 最短路径算法


### 7.1 最短路径问题概述


**🎯 最短路径的含义**
```
最短路径：两点间代价最小的路径

代价的不同含义：
🔸 物理距离：实际的公里数
🔸 时间成本：通行所需时间
🔸 经济成本：过路费、油费等
🔸 跳数：经过的节点数量
🔸 权重总和：边权重的累加

算法应用：
📍 导航系统：GPS最短路径规划
📍 网络路由：数据包传输路径
📍 物流配送：最优配送路线
📍 社交网络：最短社交距离
```

### 7.2 CTE实现最短路径（类Dijkstra）


**🔧 单源最短路径算法**
```sql
-- CTE实现的简化Dijkstra算法
WITH RECURSIVE shortest_paths AS (
    -- 初始化：起始节点距离为0
    SELECT 
        from_node as node,
        0 as distance,
        weight as edge_weight,
        from_node as path,
        CAST(from_node AS CHAR(1000)) as visited_nodes,
        0 as predecessor_count
    FROM graph_edges 
    WHERE from_node = '北京'
    GROUP BY from_node
    
    UNION ALL
    
    -- 路径扩展：寻找更短路径
    SELECT 
        ge.to_node as node,
        sp.distance + ge.weight as distance,
        ge.weight as edge_weight,
        CONCAT(sp.path, ' → ', ge.to_node) as path,
        CONCAT(sp.visited_nodes, ',', ge.to_node) as visited_nodes,
        sp.predecessor_count + 1 as predecessor_count
    FROM shortest_paths sp
    JOIN graph_edges ge ON sp.node = ge.from_node
    WHERE sp.predecessor_count < 5  -- 限制路径长度
      AND FIND_IN_SET(ge.to_node, sp.visited_nodes) = 0
),
-- 每个节点保留最短距离
min_distances AS (
    SELECT 
        node,
        MIN(distance) as min_distance
    FROM shortest_paths
    GROUP BY node
)
SELECT 
    sp.node as 目标城市,
    sp.distance as 最短距离,
    sp.path as 最短路径,
    sp.predecessor_count as 经过节点数,
    ROUND(sp.distance / sp.predecessor_count, 2) as 平均距离
FROM shortest_paths sp
JOIN min_distances md ON sp.node = md.node 
                      AND sp.distance = md.min_distance
WHERE sp.node != '北京'  -- 排除起点自己
ORDER BY sp.distance;
```

### 7.3 多终点最短路径


**🎯 一对多最短路径**
```sql
-- 从一个起点到多个终点的最短路径
WITH RECURSIVE multi_target_shortest AS (
    -- 起始节点
    SELECT 
        '北京' as start_city,
        from_node as current_city,
        to_node as target_city,
        weight as total_distance,
        CONCAT(from_node, ' → ', to_node) as route,
        1 as stops,
        CONCAT(',', from_node, ',', to_node, ',') as visited
    FROM graph_edges 
    WHERE from_node = '北京'
    
    UNION ALL
    
    -- 路径扩展
    SELECT 
        mts.start_city,
        ge.from_node as current_city,
        ge.to_node as target_city,
        mts.total_distance + ge.weight as total_distance,
        CONCAT(mts.route, ' → ', ge.to_node) as route,
        mts.stops + 1 as stops,
        CONCAT(mts.visited, ge.to_node, ',') as visited
    FROM multi_target_shortest mts
    JOIN graph_edges ge ON mts.target_city = ge.from_node
    WHERE mts.stops < 4
      AND INSTR(mts.visited, CONCAT(',', ge.to_node, ',')) = 0
),
-- 汇总各目标城市的最短路径
target_summary AS (
    SELECT 
        target_city,
        MIN(total_distance) as shortest_distance,
        MIN(stops) as min_stops
    FROM multi_target_shortest
    WHERE target_city IN ('上海', '广州', '深圳', '杭州')
    GROUP BY target_city
)
SELECT 
    mts.target_city as 目标城市,
    mts.route as 最短路线,
    mts.total_distance as 距离,
    mts.stops as 中转次数,
    ROUND(mts.total_distance / mts.stops, 2) as 平均段距离
FROM multi_target_shortest mts
JOIN target_summary ts ON mts.target_city = ts.target_city
                      AND mts.total_distance = ts.shortest_distance
ORDER BY mts.total_distance;
```

### 7.4 带约束的路径查找


**🔒 条件约束路径**
```sql
-- 带业务约束的路径查找
WITH RECURSIVE constrained_paths AS (
    -- 初始路径
    SELECT 
        ge.from_node as current_node,
        ge.to_node,
        ge.weight,
        ge.edge_type,
        CAST(CONCAT(ge.from_node, ' → ', ge.to_node) AS CHAR(1000)) as path,
        ge.weight as total_cost,
        1 as hop_count,
        CAST(CONCAT(',', ge.from_node, ',', ge.to_node, ',') AS CHAR(1000)) as visited
    FROM graph_edges ge
    WHERE ge.from_node = '北京'
      AND ge.edge_type IN ('highway', 'flight')  -- 只走高速或飞机
    
    UNION ALL
    
    -- 路径扩展（保持约束）
    SELECT 
        ge.from_node as current_node,
        ge.to_node,
        ge.weight,
        ge.edge_type,
        CAST(CONCAT(cp.path, ' → ', ge.to_node) AS CHAR(1000)) as path,
        cp.total_cost + ge.weight as total_cost,
        cp.hop_count + 1 as hop_count,
        CAST(CONCAT(cp.visited, ge.to_node, ',') AS CHAR(1000)) as visited
    FROM constrained_paths cp
    JOIN graph_edges ge ON cp.to_node = ge.from_node
    WHERE cp.hop_count < 4
      AND INSTR(cp.visited, CONCAT(',', ge.to_node, ',')) = 0
      AND ge.edge_type IN ('highway', 'flight')  -- 保持交通方式约束
      AND cp.total_cost + ge.weight <= 3000      -- 成本约束
)
SELECT 
    to_node as 目的地,
    path as 路线,
    total_cost as 总成本,
    hop_count as 中转次数,
    ROUND(total_cost / hop_count, 2) as 平均每段成本
FROM constrained_paths
WHERE to_node IN ('上海', '广州', '深圳')
ORDER BY total_cost, hop_count;
```

---

## 8. 🔗 连通性分析


### 8.1 强连通分量分析


**💡 什么是连通性**
```
连通性：判断图中节点间是否可以互相到达

连通类型：
🔸 弱连通：忽略边的方向，节点间可达
🔸 强连通：考虑边的方向，节点间双向可达
🔸 连通分量：最大的连通子图

应用场景：
📍 网络拓扑：判断网络是否连通
📍 社交分析：发现社交圈子
📍 依赖分析：检测模块间的依赖关系
📍 流量分析：分析网站页面间的跳转关系
```

### 8.2 连通分量识别


**🔍 查找连通分量**
```sql
-- 使用CTE查找连通分量
WITH RECURSIVE connected_components AS (
    -- 为每个节点分配初始组件ID（使用节点名作为组件标识）
    SELECT DISTINCT
        from_node as node,
        from_node as component_id,
        0 as iteration
    FROM graph_edges
    
    UNION ALL
    
    -- 传播组件ID到相邻节点
    SELECT DISTINCT
        ge.to_node as node,
        CASE 
            WHEN ge.to_node < cc.component_id THEN ge.to_node
            ELSE cc.component_id 
        END as component_id,
        cc.iteration + 1 as iteration
    FROM connected_components cc
    JOIN graph_edges ge ON cc.node = ge.from_node
    WHERE cc.iteration < 10
),
-- 每个节点保留最小的组件ID
final_components AS (
    SELECT 
        node,
        MIN(component_id) as final_component_id
    FROM connected_components
    GROUP BY node
)
SELECT 
    final_component_id as 连通分量ID,
    COUNT(*) as 节点数量,
    GROUP_CONCAT(node ORDER BY node) as 分量内节点
FROM final_components
GROUP BY final_component_id
ORDER BY 节点数量 DESC;
```

### 8.3 可达性矩阵构建


**📊 构建可达性关系**
```sql
-- 构建节点间的可达性矩阵
WITH RECURSIVE reachability AS (
    -- 直接可达关系（1步可达）
    SELECT DISTINCT
        from_node as source,
        to_node as target,
        1 as distance,
        CONCAT(from_node, '→', to_node) as path
    FROM graph_edges
    
    UNION ALL
    
    -- 间接可达关系（多步可达）
    SELECT DISTINCT
        r.source,
        ge.to_node as target,
        r.distance + 1 as distance,
        CONCAT(r.path, '→', ge.to_node) as path
    FROM reachability r
    JOIN graph_edges ge ON r.target = ge.from_node
    WHERE r.distance < 6
      AND r.source != ge.to_node  -- 避免自环
),
-- 每对节点保留最短距离
min_reachability AS (
    SELECT 
        source,
        target,
        MIN(distance) as min_distance
    FROM reachability
    GROUP BY source, target
)
SELECT 
    source as 起始节点,
    target as 目标节点,
    min_distance as 最短距离,
    CASE 
        WHEN min_distance = 1 THEN '直接可达'
        WHEN min_distance <= 3 THEN '近距离可达'
        WHEN min_distance <= 5 THEN '远距离可达'
        ELSE '很远距离'
    END as 可达性级别
FROM min_reachability
WHERE source != target  -- 排除自己到自己
ORDER BY source, min_distance;
```

---

## 9. ⚡ 性能优化技巧


### 9.1 图查询性能瓶颈


**🚫 常见性能问题**
```
问题1：递归深度过大
现象：查询执行时间过长，甚至超时
原因：没有合适的终止条件，递归层数太多

问题2：重复计算
现象：相同的路径被重复计算多次
原因：没有有效的去重机制

问题3：内存消耗过大
现象：查询占用大量内存，影响系统性能
原因：路径字符串过长，中间结果集过大

问题4：索引使用不当
现象：JOIN操作慢，全表扫描
原因：没有在合适的字段上建立索引
```

### 9.2 索引优化策略


**🚀 关键索引设计**
```sql
-- 图查询专用索引
CREATE TABLE graph_edges_optimized (
    id          INT PRIMARY KEY AUTO_INCREMENT,
    from_node   VARCHAR(50) NOT NULL,
    to_node     VARCHAR(50) NOT NULL,
    weight      DECIMAL(10,2) DEFAULT 1,
    edge_type   VARCHAR(20) DEFAULT 'normal',
    
    -- 核心索引：支持图遍历查询
    INDEX idx_from_node (from_node),           -- DFS/BFS起始查找
    INDEX idx_to_node (to_node),               -- 反向查找
    INDEX idx_from_to (from_node, to_node),    -- 边存在性快速检查
    INDEX idx_type_from (edge_type, from_node), -- 按类型过滤
    INDEX idx_weight (weight)                   -- 权重排序
);

-- 索引使用说明
/*
idx_from_node: 
  用途：从节点查找所有出边 SELECT * FROM edges WHERE from_node = 'A'
  
idx_to_node:
  用途：查找所有入边 SELECT * FROM edges WHERE to_node = 'B'
  
idx_from_to:
  用途：快速检查两点间是否有边 SELECT * FROM edges WHERE from_node='A' AND to_node='B'
  
idx_type_from:
  用途：按类型过滤的遍历 SELECT * FROM edges WHERE edge_type='highway' AND from_node='A'
*/
```

### 9.3 递归深度控制


**🔧 智能终止条件**
```sql
-- 多重终止条件的递归控制
WITH RECURSIVE optimized_traversal AS (
    -- 起始查询
    SELECT 
        from_node as current_node,
        to_node as target_node,
        weight as cumulative_weight,
        CONCAT(from_node, '→', to_node) as path,
        1 as depth,
        CONCAT(',', from_node, ',', to_node, ',') as visited,
        from_node as start_node
    FROM graph_edges 
    WHERE from_node = '北京'
    
    UNION ALL
    
    -- 带优化终止条件的递归
    SELECT 
        ge.from_node as current_node,
        ge.to_node as target_node,
        ot.cumulative_weight + ge.weight as cumulative_weight,
        CONCAT(ot.path, '→', ge.to_node) as path,
        ot.depth + 1 as depth,
        CONCAT(ot.visited, ge.to_node, ',') as visited,
        ot.start_node
    FROM optimized_traversal ot
    JOIN graph_edges ge ON ot.target_node = ge.from_node
    WHERE ot.depth < 5                                              -- 深度限制
      AND INSTR(ot.visited, CONCAT(',', ge.to_node, ',')) = 0       -- 环检测  
      AND ot.cumulative_weight + ge.weight < 5000                   -- 成本上限
      AND LENGTH(ot.path) < 500                                     -- 路径字符串长度限制
      AND ot.target_node NOT IN ('深圳', '上海')                    -- 排除特定节点
)
SELECT 
    target_node as 目标节点,
    cumulative_weight as 总距离,
    path as 路径,
    depth as 深度
FROM optimized_traversal
WHERE target_node != start_node
ORDER BY cumulative_weight
LIMIT 20;  -- 只返回前20个最优结果
```

### 9.4 分批处理大图


**📦 大规模图的分块处理**
```sql
-- 分批处理策略：按节点分组处理
-- 第一步：识别图中的主要节点
CREATE TEMPORARY TABLE major_nodes AS
SELECT DISTINCT from_node as node
FROM graph_edges
WHERE from_node IN (
    SELECT from_node 
    FROM graph_edges 
    GROUP BY from_node 
    HAVING COUNT(*) >= 3  -- 度数大于等于3的重要节点
);

-- 第二步：分批遍历主要节点
WITH RECURSIVE batch_traversal AS (
    -- 只从主要节点开始遍历
    SELECT 
        ge.from_node,
        ge.to_node,
        ge.weight,
        CONCAT(ge.from_node, '→', ge.to_node) as path,
        1 as level,
        CONCAT(',', ge.from_node, ',', ge.to_node, ',') as visited
    FROM graph_edges ge
    JOIN major_nodes mn ON ge.from_node = mn.node
    
    UNION ALL
    
    -- 限制递归深度，减少计算量
    SELECT 
        ge.from_node,
        ge.to_node,
        ge.weight,
        CONCAT(bt.path, '→', ge.to_node) as path,
        bt.level + 1 as level,
        CONCAT(bt.visited, ge.to_node, ',') as visited
    FROM batch_traversal bt
    JOIN graph_edges ge ON bt.to_node = ge.from_node
    WHERE bt.level < 3  -- 严格控制深度
      AND INSTR(bt.visited, CONCAT(',', ge.to_node, ',')) = 0
)
SELECT 
    from_node as 起始节点,
    COUNT(*) as 可达节点数,
    MAX(level) as 最大深度,
    AVG(weight) as 平均权重
FROM batch_traversal
GROUP BY from_node
ORDER BY 可达节点数 DESC;
```

### 9.5 内存使用优化


**💾 减少内存占用**
```sql
-- 路径压缩技术
WITH RECURSIVE memory_optimized AS (
    -- 使用ID代替字符串路径
    SELECT 
        from_node,
        to_node,
        weight,
        ROW_NUMBER() OVER (ORDER BY from_node, to_node) as path_id,
        1 as level
    FROM graph_edges 
    WHERE from_node = '北京'
    
    UNION ALL
    
    -- 递归时只记录关键信息
    SELECT 
        ge.from_node,
        ge.to_node,
        mo.weight + ge.weight as weight,
        mo.path_id * 1000 + ROW_NUMBER() OVER (ORDER BY ge.to_node) as path_id,
        mo.level + 1 as level
    FROM memory_optimized mo
    JOIN graph_edges ge ON mo.to_node = ge.from_node
    WHERE mo.level < 4
),
-- 最后阶段重建路径
path_reconstruction AS (
    SELECT 
        path_id,
        from_node,
        to_node,
        weight,
        level,
        -- 只在需要时构建完整路径字符串
        CASE WHEN level <= 3 THEN 
            CONCAT(from_node, '→', to_node)
        END as simplified_path
    FROM memory_optimized
)
SELECT * FROM path_reconstruction
WHERE to_node IN ('上海', '深圳')  -- 只关注目标节点
ORDER BY weight
LIMIT 10;
```

---

## 10. 🎯 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 图遍历本质：系统性地访问图中所有节点的算法
🔸 DFS特点：深度优先，适合路径查找和环检测
🔸 BFS特点：广度优先，适合最短路径和层级分析
🔸 路径算法：在图中寻找两点间的最优路径
🔸 连通性：分析图中节点间的可达关系
🔸 环检测：发现图中的循环路径，防止无限递归
```

### 10.2 关键技术要点


**🔹 CTE递归图算法的核心模式**
```
基本模式：
1️⃣ 基础查询：定义遍历起点
2️⃣ 递归查询：定义扩展规则
3️⃣ 终止条件：防止无限递归
4️⃣ 路径记录：跟踪访问路径
5️⃣ 去重机制：避免重复访问

模板记忆：
起点定义 + 扩展规则 + 终止条件 = 完整遍历算法
```

**🔹 DFS vs BFS的选择策略**
```
选择DFS的场景：
✅ 需要找到任意一条路径（不要求最短）
✅ 检测图中是否存在环
✅ 拓扑排序和依赖分析
✅ 内存受限的情况（DFS空间复杂度低）

选择BFS的场景：
✅ 需要找最短路径（跳数最少）
✅ 层级分析和距离计算
✅ 需要按层次处理节点
✅ 查找距离起点指定步数内的所有节点

实际应用决策：
🎯 路径查找 → DFS更快找到任意路径
🎯 最短路径 → BFS保证最优解
🎯 层次分析 → BFS提供清晰层级
🎯 环检测 → DFS更直接有效
```

**🔹 路径记录的技术要领**
```
路径存储方式：
方式1：字符串拼接 'A→B→C'
  优点：直观易读，调试方便
  缺点：字符串操作慢，占用内存大

方式2：JSON数组 ['A','B','C']  
  优点：结构化存储，支持复杂操作
  缺点：JSON解析有开销

方式3：ID序列 '1,2,3'
  优点：存储效率高，处理速度快
  缺点：需要额外的ID映射表

选择建议：
🔸 小规模图：字符串拼接，简单直观
🔸 中等规模：JSON数组，功能丰富
🔸 大规模图：ID序列，性能优先
```

### 10.3 性能优化关键


**⚡ CTE图算法性能优化要点**
```
索引策略：
🔸 from_node索引：支持出边查找
🔸 to_node索引：支持入边查找  
🔸 复合索引：from_node + edge_type组合
🔸 权重索引：支持基于权重的排序

递归控制：
🔸 深度限制：防止过深递归（通常<10层）
🔸 成本上限：控制路径总权重
🔸 节点限制：避免访问不必要的节点
🔸 早期终止：找到目标后立即停止

内存优化：
🔸 路径压缩：避免过长的路径字符串
🔸 分批处理：大图分解为小的子图
🔸 结果限制：LIMIT控制返回结果数量
🔸 临时表：复杂查询使用临时表缓存中间结果
```

### 10.4 实际应用指导


**🗺️ 图算法应用场景**
```
业务场景对应算法选择：

组织架构分析：
📌 上下级关系查询 → DFS遍历
📌 同级人员查询 → BFS层级遍历  
📌 汇报链路查询 → 路径查找
📌 管理跨度分析 → 连通性分析

网站页面分析：
📌 页面跳转路径 → 路径查找算法
📌 用户浏览深度 → DFS深度计算
📌 页面关联度 → 连通性分析
📌 导航环路检测 → 环检测算法

物流配送优化：
📌 最短配送路线 → 最短路径算法
📌 配送网络连通性 → 连通分量分析
📌 配送中心覆盖范围 → BFS层级查询
📌 路线环路检测 → 环检测算法
```

**🔧 SQL实现技巧总结**
```
编写技巧：
1️⃣ 先写简单版本，验证逻辑正确性
2️⃣ 添加终止条件，确保查询能够结束
3️⃣ 增加去重机制，避免重复计算
4️⃣ 优化索引设计，提升JOIN性能
5️⃣ 控制结果集大小，避免内存溢出

调试方法：
🔍 分步验证：先测试基础查询，再测试递归
🔍 限制深度：用小的深度限制测试算法逻辑
🔍 打印中间结果：观察递归的每一步执行情况
🔍 性能监控：使用EXPLAIN分析查询执行计划
```

**💡 常见错误与避免**
```
❌ 错误1：忘记添加深度限制
后果：无限递归导致查询超时
解决：WHERE depth < 合理深度值

❌ 错误2：环检测逻辑错误
后果：陷入循环，或者丢失某些路径
解决：正确使用FIND_IN_SET或JSON_SEARCH避免重复访问

❌ 错误3：路径字符串过长
后果：达到字符串长度限制，数据截断
解决：使用CHAR(足够长度)或考虑路径压缩

❌ 错误4：JOIN条件不当
后果：笛卡尔积导致结果集爆炸
解决：确保JOIN条件准确，添加必要的WHERE过滤
```

**核心记忆口诀**：
> CTE递归遍历图，深度广度两策略  
> DFS深入找路径，BFS层级最优先  
> 路径记录要清晰，环检测防死循环  
> 索引优化是关键，终止条件保性能  
> 图算法SQL化，复杂查询变简单