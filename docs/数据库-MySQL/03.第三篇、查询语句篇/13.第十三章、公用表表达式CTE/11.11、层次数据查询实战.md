---
title: 11、层次数据查询实战
---
## 📚 目录

1. [层次数据基础概念](#1-层次数据基础概念)
2. [树型数据存储模型](#2-树型数据存储模型)
3. [组织架构查询实现](#3-组织架构查询实现)
4. [菜单树结构遍历](#4-菜单树结构遍历)
5. [分类层级查询技术](#5-分类层级查询技术)
6. [路径字符串构建](#6-路径字符串构建)
7. [深度优先vs广度优先遍历](#7-深度优先vs广度优先遍历)
8. [树结构查询优化策略](#8-树结构查询优化策略)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌳 层次数据基础概念


### 1.1 什么是层次数据


**🔸 基本定义**
```
层次数据：具有上下级关系的树状结构数据
特点：每个节点有唯一父节点，可以有多个子节点
常见形式：组织架构、文件目录、商品分类、菜单导航
```

**💡 生活化理解**
层次数据就像**"家族族谱"**：
- 每个人都有父母（除了祖先）
- 每个人可能有多个孩子
- 可以追溯到任意祖先
- 可以查看所有后代

```
现实中的组织架构：
       总经理
      /      \
   技术总监    市场总监
   /    \      /    \
 开发部 测试部 销售部 运营部
 /  \
前端 后端
```

### 1.2 层次数据查询的核心需求


**🎯 常见查询场景**
```
向上查询：
• 查询某员工的所有上级领导
• 获取文件所在的完整路径
• 查找商品分类的层级归属

向下查询：
• 查询部门下的所有员工
• 获取目录下的所有子文件
• 查找分类下的所有商品

层级计算：
• 计算组织架构的层级深度
• 统计每层的节点数量
• 查找同级别的兄弟节点
```

### 1.3 传统查询方法的局限性


**❌ 递归查询困难**
```sql
-- 传统SQL查询员工的所有上级，需要多次查询
SELECT * FROM employees WHERE id = 1001;           -- 查询自己
SELECT * FROM employees WHERE id = (上级ID);        -- 查询上级
SELECT * FROM employees WHERE id = (上级的上级ID);   -- 继续向上
... 直到找到最高层

问题：
• 需要多次数据库访问
• 不知道要查询多少层
• 代码复杂，性能低下
```

**✅ CTE递归查询的优势**
```sql
-- 使用CTE一次性查询所有上级
WITH RECURSIVE manager_chain AS (
    -- 基础条件：查询目标员工
    SELECT id, name, manager_id, 0 as level
    FROM employees WHERE id = 1001
    
    UNION ALL
    
    -- 递归条件：向上查找上级
    SELECT e.id, e.name, e.manager_id, mc.level + 1
    FROM employees e
    JOIN manager_chain mc ON e.id = mc.manager_id
)
SELECT * FROM manager_chain ORDER BY level;

优势：
✓ 一次SQL完成递归查询
✓ 性能更好，减少数据库访问
✓ 代码简洁，逻辑清晰
```

---

## 2. 🗂️ 树型数据存储模型


### 2.1 邻接表模型（最常用）


**🔸 邻接表结构设计**
```sql
-- 组织架构表设计
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_id INT,                    -- 指向父部门
    level_depth INT DEFAULT 0,       -- 层级深度（可选）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_parent_id (parent_id)   -- 重要：父子查询索引
);

-- 示例数据
INSERT INTO departments VALUES 
(1, '总公司', NULL, 0),
(2, '技术部', 1, 1),
(3, '销售部', 1, 1), 
(4, '开发组', 2, 2),
(5, '测试组', 2, 2),
(6, '前端组', 4, 3);
```

**📊 邻接表数据关系图**
```
数据库存储：                    实际层级关系：
┌────┬──────┬─────────┐          总公司(1)
│ id │ name │parent_id│         /        \
├────┼──────┼─────────┤      技术部(2)   销售部(3)
│ 1  │总公司 │  NULL   │       /    \
│ 2  │技术部 │   1     │   开发组(4) 测试组(5)
│ 3  │销售部 │   1     │      │
│ 4  │开发组 │   2     │   前端组(6)
│ 5  │测试组 │   2     │
│ 6  │前端组 │   4     │
└────┴──────┴─────────┘
```

### 2.2 嵌套集合模型


**🔸 嵌套集合的思想**
```
核心理念：每个节点用左右边界值表示其在树中的位置
优势：范围查询非常高效
劣势：插入和更新复杂

嵌套集合示例：
       总公司(1,12)
      /            \
   技术部(2,9)     销售部(10,11)  
   /      \
开发组(3,6) 测试组(7,8)
  |
前端组(4,5)

CREATE TABLE nested_set_tree (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    lft INT NOT NULL,     -- 左边界
    rgt INT NOT NULL,     -- 右边界
    level_depth INT,
    
    INDEX idx_lft_rgt (lft, rgt)
);
```

### 2.3 存储模型对比分析


| 存储模型 | **查询子树** | **查询路径** | **插入节点** | **删除节点** | **适用场景** |
|---------|-------------|-------------|-------------|-------------|-------------|
| 📁 **邻接表** | `递归查询` | `递归查询` | `简单` | `简单` | `频繁增删改` |
| 🎯 **嵌套集合** | `范围查询，极快` | `复杂` | `复杂` | `复杂` | `读多写少` |
| 🛤️ **路径枚举** | `LIKE查询` | `直接获取` | `简单` | `简单` | `路径查询频繁` |

**🔑 选择建议**
```
选择邻接表的情况：
✅ 树结构经常变化
✅ 需要频繁插入和删除节点
✅ 查询模式多样化
✅ 开发和维护成本要求较低

选择嵌套集合的情况：
✅ 读取频率远大于修改频率
✅ 经常需要查询整个子树
✅ 性能要求极高
✅ 愿意承担维护复杂性
```

---

## 3. 🏢 组织架构查询实现


### 3.1 员工层级管理场景


**📋 员工表结构设计**
```sql
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50) NOT NULL,
    manager_id INT,                   -- 上级经理ID
    department_id INT,
    position VARCHAR(50),
    hire_date DATE,
    salary DECIMAL(10,2),
    
    INDEX idx_manager (manager_id),
    INDEX idx_dept (department_id)
);

-- 示例数据
INSERT INTO employees VALUES
(1, '张总', NULL, 1, '总经理', '2020-01-01', 50000),
(2, '李总监', 1, 2, '技术总监', '2020-02-01', 30000),
(3, '王总监', 1, 3, '销售总监', '2020-02-01', 28000),
(4, '赵经理', 2, 2, '开发经理', '2020-03-01', 20000),
(5, '钱工程师', 4, 2, '高级工程师', '2020-04-01', 15000),
(6, '孙工程师', 4, 2, '工程师', '2020-05-01', 12000);
```

### 3.2 向上查询：查找所有上级


**🔍 查询员工的管理链**
```sql
-- 查询某员工的所有上级领导
WITH RECURSIVE management_chain AS (
    -- 基础情况：目标员工
    SELECT 
        emp_id, 
        emp_name, 
        manager_id, 
        0 as level,
        emp_name as path
    FROM employees 
    WHERE emp_id = 5  -- 查询钱工程师的管理链
    
    UNION ALL
    
    -- 递归情况：向上查找上级
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        mc.level + 1,
        CONCAT(e.emp_name, ' → ', mc.path) as path
    FROM employees e
    JOIN management_chain mc ON e.emp_id = mc.manager_id
)
SELECT 
    level,
    emp_name,
    position,
    path as management_path
FROM management_chain mc
JOIN employees e ON mc.emp_id = e.emp_id
ORDER BY level DESC;

-- 查询结果：
-- level | emp_name | position    | management_path
-- ------|----------|-------------|----------------
-- 0     | 钱工程师  | 高级工程师   | 钱工程师
-- 1     | 赵经理    | 开发经理    | 赵经理 → 钱工程师  
-- 2     | 李总监    | 技术总监    | 李总监 → 赵经理 → 钱工程师
-- 3     | 张总      | 总经理      | 张总 → 李总监 → 赵经理 → 钱工程师
```

### 3.3 向下查询：查找所有下级


**🔍 查询部门所有下属**
```sql
-- 查询某经理的所有下属（直接和间接）
WITH RECURSIVE subordinate_tree AS (
    -- 基础情况：目标经理
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        0 as level,
        CAST(emp_name AS VARCHAR(1000)) as hierarchy_path
    FROM employees 
    WHERE emp_id = 2  -- 李总监
    
    UNION ALL
    
    -- 递归情况：查找所有下级
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        st.level + 1,
        CONCAT(st.hierarchy_path, ' → ', e.emp_name)
    FROM employees e
    JOIN subordinate_tree st ON e.manager_id = st.emp_id
)
SELECT 
    REPEAT('  ', level) as indent,  -- 用空格表示层级
    emp_name,
    level,
    hierarchy_path
FROM subordinate_tree
ORDER BY level, emp_name;

-- 查询结果展示：
-- indent | emp_name | level | hierarchy_path
-- -------|----------|-------|---------------
--        | 李总监    | 0     | 李总监
--   ··   | 赵经理    | 1     | 李总监 → 赵经理
-- ····   | 钱工程师  | 2     | 李总监 → 赵经理 → 钱工程师
-- ····   | 孙工程师  | 2     | 李总监 → 赵经理 → 孙工程师
```

### 3.4 层级深度计算


**📊 计算组织架构统计信息**
```sql
-- 分析组织架构的层级分布
WITH RECURSIVE org_levels AS (
    -- 根节点（总经理）
    SELECT emp_id, emp_name, manager_id, 0 as level
    FROM employees WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归查找每一层
    SELECT e.emp_id, e.emp_name, e.manager_id, ol.level + 1
    FROM employees e
    JOIN org_levels ol ON e.manager_id = ol.emp_id
),
level_stats AS (
    SELECT 
        level,
        COUNT(*) as employee_count,
        GROUP_CONCAT(emp_name) as employees_at_level
    FROM org_levels
    GROUP BY level
)
SELECT 
    level,
    employee_count,
    CASE 
        WHEN level = 0 THEN '高管层'
        WHEN level = 1 THEN '总监层'  
        WHEN level = 2 THEN '经理层'
        ELSE '员工层'
    END as level_name,
    employees_at_level
FROM level_stats
ORDER BY level;
```

---

## 4. 📋 菜单树结构遍历


### 4.1 前端菜单系统设计


**🔸 菜单表结构**
```sql
CREATE TABLE menu_items (
    menu_id INT PRIMARY KEY,
    menu_name VARCHAR(50) NOT NULL,
    parent_id INT,
    menu_url VARCHAR(200),
    menu_icon VARCHAR(50),
    sort_order INT DEFAULT 0,         -- 同级菜单排序
    is_visible BOOLEAN DEFAULT TRUE,  -- 是否显示
    menu_level INT DEFAULT 0,         -- 菜单层级
    
    INDEX idx_parent_sort (parent_id, sort_order)
);

-- 示例菜单数据
INSERT INTO menu_items VALUES
(1, '系统管理', NULL, NULL, 'settings', 1, TRUE, 0),
(2, '用户管理', 1, '/users', 'user', 1, TRUE, 1),
(3, '角色管理', 1, '/roles', 'role', 2, TRUE, 1),
(4, '用户列表', 2, '/users/list', 'list', 1, TRUE, 2),
(5, '添加用户', 2, '/users/add', 'plus', 2, TRUE, 2),
(6, '业务管理', NULL, NULL, 'business', 2, TRUE, 0),
(7, '订单管理', 6, '/orders', 'order', 1, TRUE, 1);
```

### 4.2 菜单树完整遍历


**🔄 生成完整菜单树**
```sql
-- 生成完整的菜单树结构（用于前端显示）
WITH RECURSIVE menu_tree AS (
    -- 根节点：顶级菜单
    SELECT 
        menu_id,
        menu_name,
        parent_id,
        menu_url,
        menu_icon,
        sort_order,
        0 as level,
        CAST(menu_name AS VARCHAR(1000)) as full_path,
        CAST(LPAD(sort_order, 3, '0') AS VARCHAR(1000)) as sort_path
    FROM menu_items 
    WHERE parent_id IS NULL AND is_visible = TRUE
    
    UNION ALL
    
    -- 递归：子菜单
    SELECT 
        m.menu_id,
        m.menu_name,
        m.parent_id,
        m.menu_url,
        m.menu_icon,
        m.sort_order,
        mt.level + 1,
        CONCAT(mt.full_path, ' → ', m.menu_name),
        CONCAT(mt.sort_path, '-', LPAD(m.sort_order, 3, '0'))
    FROM menu_items m
    JOIN menu_tree mt ON m.parent_id = mt.menu_id
    WHERE m.is_visible = TRUE
)
SELECT 
    menu_id,
    REPEAT('├─', level) || menu_name as display_name,  -- 树状显示
    menu_url,
    level,
    full_path,
    CASE 
        WHEN menu_url IS NOT NULL THEN '页面菜单'
        ELSE '目录菜单' 
    END as menu_type
FROM menu_tree
ORDER BY sort_path;  -- 按排序路径排序
```

### 4.3 菜单权限控制


**🔐 基于角色的菜单过滤**
```sql
-- 查询用户可访问的菜单（结合权限控制）
WITH RECURSIVE accessible_menu AS (
    -- 查询用户角色对应的菜单权限
    SELECT DISTINCT 
        m.menu_id,
        m.menu_name,
        m.parent_id,
        m.menu_url,
        0 as level
    FROM menu_items m
    JOIN role_menu_permissions rmp ON m.menu_id = rmp.menu_id
    JOIN user_roles ur ON rmp.role_id = ur.role_id
    WHERE ur.user_id = 1001 AND m.parent_id IS NULL  -- 用户ID = 1001
    
    UNION ALL
    
    -- 递归查找子菜单（只显示有权限的）
    SELECT 
        m.menu_id,
        m.menu_name,
        m.parent_id,
        m.menu_url,
        am.level + 1
    FROM menu_items m
    JOIN accessible_menu am ON m.parent_id = am.menu_id
    JOIN role_menu_permissions rmp ON m.menu_id = rmp.menu_id
    JOIN user_roles ur ON rmp.role_id = ur.role_id
    WHERE ur.user_id = 1001
)
SELECT 
    menu_id,
    REPEAT('  ', level) || menu_name as menu_display,
    menu_url,
    level
FROM accessible_menu
ORDER BY parent_id, menu_id;
```

### 4.4 动态菜单生成


**🔧 前端JSON格式输出**
```sql
-- 生成前端需要的JSON格式菜单数据
WITH RECURSIVE menu_hierarchy AS (
    SELECT 
        menu_id,
        menu_name,
        parent_id,
        menu_url,
        menu_icon,
        0 as level,
        JSON_OBJECT(
            'id', menu_id,
            'name', menu_name,
            'url', menu_url,
            'icon', menu_icon,
            'children', JSON_ARRAY()
        ) as menu_json
    FROM menu_items 
    WHERE parent_id IS NULL
    
    UNION ALL
    
    SELECT 
        m.menu_id,
        m.menu_name,
        m.parent_id,
        m.menu_url,
        m.menu_icon,
        mh.level + 1,
        JSON_OBJECT(
            'id', m.menu_id,
            'name', m.menu_name, 
            'url', m.menu_url,
            'icon', m.menu_icon,
            'children', JSON_ARRAY()
        )
    FROM menu_items m
    JOIN menu_hierarchy mh ON m.parent_id = mh.menu_id
)
SELECT menu_json FROM menu_hierarchy;
```

---

## 5. 🏷️ 分类层级查询技术


### 5.1 商品分类系统


**🔸 商品分类表设计**
```sql
CREATE TABLE product_categories (
    category_id INT PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL,
    parent_id INT,
    category_code VARCHAR(20) UNIQUE,  -- 分类编码
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    sort_order INT DEFAULT 0,
    
    INDEX idx_parent (parent_id),
    INDEX idx_code (category_code)
);

-- 分类数据示例
INSERT INTO product_categories VALUES
(1, '电子产品', NULL, 'ELEC', '所有电子产品', TRUE, 1),
(2, '手机通讯', 1, 'PHONE', '手机及配件', TRUE, 1),
(3, '电脑办公', 1, 'COMPUTER', '电脑及办公设备', TRUE, 2),
(4, '智能手机', 2, 'SMARTPHONE', '各品牌智能手机', TRUE, 1),
(5, '手机配件', 2, 'PHONE_ACC', '数据线、充电器等', TRUE, 2),
(6, '笔记本电脑', 3, 'LAPTOP', '便携式电脑', TRUE, 1),
(7, '台式机', 3, 'DESKTOP', '台式电脑', TRUE, 2);
```

### 5.2 分类树查询实现


**🔍 查询分类及其所有子分类**
```sql
-- 查询某分类下的所有商品分类（含子分类）
WITH RECURSIVE category_tree AS (
    -- 起始分类
    SELECT 
        category_id,
        category_name,
        parent_id,
        category_code,
        0 as depth,
        category_name as full_path,
        category_code as code_path
    FROM product_categories 
    WHERE category_id = 1  -- 电子产品
    
    UNION ALL
    
    -- 递归查找子分类
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_id,
        c.category_code,
        ct.depth + 1,
        CONCAT(ct.full_path, ' / ', c.category_name),
        CONCAT(ct.code_path, '.', c.category_code)
    FROM product_categories c
    JOIN category_tree ct ON c.parent_id = ct.category_id
    WHERE c.is_active = TRUE
)
SELECT 
    category_id,
    REPEAT('├─', depth) || category_name as tree_display,
    depth,
    full_path,
    code_path,
    -- 统计每个分类下的商品数量
    (SELECT COUNT(*) FROM products p WHERE p.category_id = ct.category_id) as product_count
FROM category_tree ct
ORDER BY code_path;
```

### 5.3 父子关系查询


**🔍 查找父分类链**
```sql
-- 查询商品所属的完整分类路径（面包屑导航）
WITH RECURSIVE parent_chain AS (
    -- 商品的直接分类
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_id,
        0 as level
    FROM products p
    JOIN product_categories c ON p.category_id = c.category_id
    WHERE p.product_id = 12345  -- 特定商品
    
    UNION ALL
    
    -- 向上查找父分类
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_id,
        pc.level + 1
    FROM product_categories c
    JOIN parent_chain pc ON c.category_id = pc.parent_id
)
SELECT 
    category_name,
    level,
    STRING_AGG(category_name, ' > ' ORDER BY level DESC) as breadcrumb
FROM parent_chain
GROUP BY category_name, level
ORDER BY level DESC;

-- 结果示例：电子产品 > 手机通讯 > 智能手机
```

### 5.4 同级分类查询


**🔍 查找兄弟分类**
```sql
-- 查询同级别的分类（用于相关推荐）
SELECT 
    current.category_name as current_category,
    sibling.category_name as sibling_category,
    sibling.category_id
FROM product_categories current
JOIN product_categories sibling ON current.parent_id = sibling.parent_id
WHERE current.category_id = 4  -- 智能手机
  AND sibling.category_id != 4  -- 排除自己
  AND sibling.is_active = TRUE
ORDER BY sibling.sort_order;

-- 结果：手机配件（智能手机的兄弟分类）
```

---

## 6. 🔥 路径字符串构建


### 6.1 路径构建的核心技术


**🔸 路径构建策略**
```
路径表示方法：
• 分隔符路径：/电子产品/手机通讯/智能手机
• 编码路径：ELEC.PHONE.SMARTPHONE  
• 层级路径：L1-电子产品/L2-手机通讯/L3-智能手机
• ID路径：1/2/4 (用ID表示路径)

选择标准：
• 可读性：分隔符路径最直观
• 唯一性：编码路径避免重名问题
• 查询效率：ID路径查询最快
• 国际化：编码路径便于多语言
```

### 6.2 动态路径构建技术


**🔧 路径字符串生成实现**
```sql
-- 构建从根到叶子的完整路径
WITH RECURSIVE path_builder AS (
    -- 叶子节点开始
    SELECT 
        category_id,
        category_name,
        parent_id,
        category_name as path_name,
        category_code as path_code,
        CAST(category_id AS VARCHAR(500)) as id_path,
        0 as reverse_level
    FROM product_categories 
    WHERE category_id NOT IN (
        SELECT DISTINCT parent_id FROM product_categories WHERE parent_id IS NOT NULL
    )  -- 只选择叶子节点
    
    UNION ALL
    
    -- 向上构建路径
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_id,
        CONCAT(c.category_name, ' → ', pb.path_name),
        CONCAT(c.category_code, '.', pb.path_code),
        CONCAT(CAST(c.category_id AS VARCHAR(10)), '/', pb.id_path),
        pb.reverse_level + 1
    FROM product_categories c
    JOIN path_builder pb ON c.category_id = pb.parent_id
)
-- 选择完整路径（到达根节点的路径）
SELECT 
    category_id as leaf_category_id,
    path_name as full_category_path,
    path_code as full_category_code,
    id_path as full_id_path,
    reverse_level as path_depth
FROM path_builder 
WHERE parent_id IS NULL  -- 到达根节点
ORDER BY path_name;
```

### 6.3 路径查询优化


**⚡ 路径缓存策略**
```sql
-- 创建路径缓存表（提高查询效率）
CREATE TABLE category_paths (
    category_id INT PRIMARY KEY,
    ancestor_id INT,
    path_length INT,
    full_path VARCHAR(500),
    path_codes VARCHAR(200),
    
    INDEX idx_ancestor (ancestor_id),
    INDEX idx_path_length (path_length),
    FOREIGN KEY (category_id) REFERENCES product_categories(category_id)
);

-- 使用触发器维护路径缓存
DELIMITER $$
CREATE TRIGGER update_category_paths 
AFTER INSERT ON product_categories
FOR EACH ROW
BEGIN
    -- 重新计算相关路径
    CALL rebuild_category_paths(NEW.category_id);
END$$
DELIMITER ;
```

### 6.4 路径搜索与匹配


**🔍 基于路径的模糊查询**
```sql
-- 根据路径关键词查找分类
SELECT 
    category_id,
    category_name,
    full_path,
    MATCH(full_path) AGAINST('手机 智能' IN BOOLEAN MODE) as relevance_score
FROM category_paths cp
JOIN product_categories pc ON cp.category_id = pc.category_id
WHERE full_path LIKE '%手机%'
   OR full_path LIKE '%智能%'
ORDER BY relevance_score DESC, path_length ASC;

-- 路径前缀匹配（查找某路径下的所有子分类）
SELECT *
FROM category_paths
WHERE full_path LIKE '/电子产品/手机通讯/%'
ORDER BY path_length, full_path;
```

---

## 7. 🚀 深度优先vs广度优先遍历


### 7.1 两种遍历策略对比


**📊 遍历方式差异**
```
树结构示例：
       A
     /   \
    B     C
   / \   / \
  D   E F   G

深度优先遍历 (DFS)：
访问顺序：A → B → D → E → C → F → G
特点：一条路走到底，再回头探索

广度优先遍历 (BFS)：  
访问顺序：A → B → C → D → E → F → G
特点：一层一层地遍历，先广后深
```

### 7.2 深度优先遍历实现


**🔍 深度优先的CTE实现**
```sql
-- 深度优先遍历组织架构
WITH RECURSIVE dfs_traversal AS (
    -- 根节点
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        0 as level,
        CAST(emp_id AS VARCHAR(1000)) as traversal_path,
        ROW_NUMBER() OVER (ORDER BY emp_id) as visit_order
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 深度优先：优先访问第一个子节点的所有后代
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        dt.level + 1,
        CONCAT(dt.traversal_path, '->', CAST(e.emp_id AS VARCHAR(10))),
        -- DFS特点：子节点紧跟父节点编号
        dt.visit_order * 100 + ROW_NUMBER() OVER (ORDER BY e.emp_id)
    FROM employees e
    JOIN dfs_traversal dt ON e.manager_id = dt.emp_id
)
SELECT 
    visit_order,
    REPEAT('  ', level) || emp_name as tree_display,
    level,
    traversal_path
FROM dfs_traversal
ORDER BY visit_order;  -- 深度优先的访问顺序
```

### 7.3 广度优先遍历实现


**🔍 广度优先的CTE实现**
```sql
-- 广度优先遍历（按层级顺序）
WITH RECURSIVE bfs_traversal AS (
    -- 第0层：根节点
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        0 as level,
        ROW_NUMBER() OVER (ORDER BY emp_id) as position_in_level
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 广度优先：逐层遍历
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        bt.level + 1,
        ROW_NUMBER() OVER (PARTITION BY bt.level + 1 ORDER BY e.emp_id)
    FROM employees e
    JOIN bfs_traversal bt ON e.manager_id = bt.emp_id
)
SELECT 
    level,
    position_in_level,
    REPEAT('Level' || level || ': ') || emp_name as level_display,
    emp_name
FROM bfs_traversal
ORDER BY level, position_in_level;  -- 先按层级，再按层内位置
```

### 7.4 遍历策略选择指南


**🎯 应用场景匹配**
```
选择深度优先的场景：
✅ 文件系统遍历：需要完整路径信息
✅ 权限检查：需要追踪完整的权限继承链
✅ 数据导出：按树状结构组织输出
✅ 缓存预热：按访问路径预加载数据

选择广度优先的场景：
✅ 层级统计：分析每层的数据分布
✅ 权限分发：按层级分配权限
✅ UI展示：折叠菜单逐层显示
✅ 性能优化：控制每次查询的深度
```

**📊 性能对比分析**
```java
// 性能特征对比
public class TraversalPerformance {
    
    /*
    深度优先特点：
    • 内存使用：栈深度 = 树的最大深度
    • 查询效率：单次查询获得完整路径
    • 适用数据：窄而深的树结构
    • 缓存友好：局部性好
    
    广度优先特点：
    • 内存使用：队列大小 = 某层的最大节点数
    • 查询效率：需要多次查询或大内存
    • 适用数据：宽而浅的树结构  
    • 并行友好：同层节点可以并行处理
    */
    
    public String recommendTraversal(int maxDepth, int maxWidth, String useCase) {
        if (maxDepth > 10 && maxWidth < 100) {
            return "深度优先 - 深树结构";
        } else if (maxDepth < 5 && maxWidth > 100) {
            return "广度优先 - 宽树结构";
        } else if ("PATH_ANALYSIS".equals(useCase)) {
            return "深度优先 - 路径分析场景";
        } else if ("LEVEL_STATISTICS".equals(useCase)) {
            return "广度优先 - 层级统计场景";
        } else {
            return "根据具体查询需求决定";
        }
    }
}
```

---

## 8. 🎯 子树查询技术


### 8.1 子树范围查询


**🔸 查询指定节点的完整子树**
```sql
-- 查询部门的完整组织结构
WITH RECURSIVE department_tree AS (
    -- 部门根节点
    SELECT 
        emp_id,
        emp_name,
        manager_id,
        department_id,
        0 as level,
        emp_name as hierarchy
    FROM employees 
    WHERE emp_id = 2  -- 技术总监李总监
    
    UNION ALL
    
    -- 递归查找所有下属
    SELECT 
        e.emp_id,
        e.emp_name,
        e.manager_id,
        e.department_id,
        dt.level + 1,
        CONCAT(dt.hierarchy, ' → ', e.emp_name)
    FROM employees e
    JOIN department_tree dt ON e.manager_id = dt.emp_id
)
SELECT 
    level,
    REPEAT('  ', level) as indent,
    emp_name,
    hierarchy,
    -- 子树统计
    (SELECT COUNT(*) - 1 FROM department_tree dt2 
     WHERE dt2.hierarchy LIKE CONCAT(dt.hierarchy, '%')) as subordinate_count
FROM department_tree dt
ORDER BY hierarchy;
```

### 8.2 层级限制查询


**🔍 控制查询深度**
```sql
-- 只查询指定层数的子树（避免查询过深）
WITH RECURSIVE limited_depth_tree AS (
    SELECT 
        category_id, 
        category_name, 
        parent_id,
        0 as depth
    FROM product_categories 
    WHERE category_id = 1
    
    UNION ALL
    
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_id,
        ldt.depth + 1
    FROM product_categories c
    JOIN limited_depth_tree ldt ON c.parent_id = ldt.category_id
    WHERE ldt.depth < 2  -- 限制最大深度为2层
)
SELECT * FROM limited_depth_tree
ORDER BY depth, category_name;
```

### 8.3 条件过滤的子树查询


**🔍 带业务条件的层级查询**
```sql
-- 查询有活跃商品的分类树
WITH RECURSIVE active_category_tree AS (
    -- 从有商品的叶子分类开始
    SELECT DISTINCT
        c.category_id,
        c.category_name,
        c.parent_id,
        0 as level
    FROM product_categories c
    JOIN products p ON c.category_id = p.category_id
    WHERE p.status = 'active'  -- 只考虑活跃商品
    
    UNION ALL
    
    -- 向上查找父分类
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_id,
        act.level + 1
    FROM product_categories c
    JOIN active_category_tree act ON c.category_id = act.parent_id
),
-- 计算每个分类的活跃商品数
category_product_count AS (
    SELECT 
        act.category_id,
        act.category_name,
        act.level,
        COUNT(DISTINCT p.product_id) as active_product_count
    FROM active_category_tree act
    LEFT JOIN products p ON act.category_id = p.category_id AND p.status = 'active'
    GROUP BY act.category_id, act.category_name, act.level
)
SELECT 
    category_name,
    level,
    active_product_count,
    CASE 
        WHEN active_product_count > 0 THEN '✅ 有商品'
        ELSE '📁 仅分类' 
    END as category_status
FROM category_product_count
ORDER BY level DESC, category_name;
```

### 8.4 多起点路径构建


**🔍 批量路径生成**
```sql
-- 一次性查询多个分类的路径
WITH category_paths AS (
    -- 需要查询路径的分类ID列表
    SELECT UNNEST(ARRAY[4, 6, 7]) as target_category_id
),
RECURSIVE path_construction AS (
    -- 目标分类作为起点
    SELECT 
        cp.target_category_id,
        c.category_id,
        c.category_name,
        c.parent_id,
        c.category_name as path,
        0 as path_length
    FROM category_paths cp
    JOIN product_categories c ON cp.target_category_id = c.category_id
    
    UNION ALL
    
    -- 向上构建路径
    SELECT 
        pc.target_category_id,
        c.category_id,
        c.category_name,
        c.parent_id,
        CONCAT(c.category_name, ' / ', pc.path),
        pc.path_length + 1
    FROM product_categories c
    JOIN path_construction pc ON c.category_id = pc.parent_id
)
SELECT 
    target_category_id,
    path as full_category_path,
    path_length
FROM path_construction
WHERE parent_id IS NULL  -- 到达根节点的完整路径
ORDER BY target_category_id;
```

---

## 9. 🔧 树结构查询优化策略


### 9.1 性能优化核心原则


**⚡ 查询性能优化要点**
```
索引策略：
• 父节点索引：INDEX(parent_id) - 向下查询必需
• 复合索引：INDEX(parent_id, sort_order) - 排序查询
• 覆盖索引：INDEX(parent_id, id, name) - 减少回表

查询限制：
• 深度限制：避免无限递归和性能问题
• 节点数量限制：避免查询结果集过大
• 超时控制：设置查询超时时间
```

### 9.2 常见性能问题及解决


**💡 问题1：递归查询性能慢**
```sql
-- 问题：查询大型组织架构时性能差
-- 原因：没有合适的索引，递归层数过多

-- 解决方案1：添加专门的索引
CREATE INDEX idx_emp_manager_dept ON employees(manager_id, department_id, emp_id);

-- 解决方案2：限制递归深度
WITH RECURSIVE org_tree AS (
    SELECT emp_id, emp_name, manager_id, 0 as level
    FROM employees WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.emp_id, e.emp_name, e.manager_id, ot.level + 1
    FROM employees e
    JOIN org_tree ot ON e.manager_id = ot.emp_id
    WHERE ot.level < 5  -- 限制最大5层
)
SELECT * FROM org_tree;
```

**💡 问题2：路径构建内存消耗大**
```sql
-- 问题：路径字符串过长，消耗内存
-- 解决方案：使用路径ID代替路径名称

WITH RECURSIVE id_path_tree AS (
    SELECT 
        category_id,
        parent_id,
        CAST(category_id AS VARCHAR(100)) as id_path,
        0 as level
    FROM product_categories WHERE parent_id IS NULL
    
    UNION ALL
    
    SELECT 
        c.category_id,
        c.parent_id,
        CONCAT(ipt.id_path, '/', c.category_id),  -- ID路径更短
        ipt.level + 1
    FROM product_categories c
    JOIN id_path_tree ipt ON c.parent_id = ipt.category_id
    WHERE ipt.level < 10
)
SELECT 
    category_id,
    id_path,
    level
FROM id_path_tree;
```

### 9.3 查询优化技巧


**🛠️ 高级优化技术**
```sql
-- 技巧1：使用EXISTS避免重复计算
SELECT c1.category_name
FROM product_categories c1
WHERE EXISTS (
    WITH RECURSIVE sub_categories AS (
        SELECT category_id FROM product_categories WHERE category_id = c1.category_id
        UNION ALL
        SELECT c.category_id 
        FROM product_categories c
        JOIN sub_categories sc ON c.parent_id = sc.category_id
    )
    SELECT 1 FROM products p 
    JOIN sub_categories sc ON p.category_id = sc.category_id
    WHERE p.status = 'active'
);

-- 技巧2：分页递归查询
WITH RECURSIVE paged_tree AS (
    SELECT emp_id, emp_name, manager_id, 0 as level, ROW_NUMBER() OVER (ORDER BY emp_id) as rn
    FROM employees WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.emp_id, e.emp_name, e.manager_id, pt.level + 1, 
           ROW_NUMBER() OVER (PARTITION BY pt.level + 1 ORDER BY e.emp_id)
    FROM employees e
    JOIN paged_tree pt ON e.manager_id = pt.emp_id
    WHERE pt.level < 3  -- 控制层数
)
SELECT * FROM paged_tree 
WHERE rn BETWEEN 1 AND 20;  -- 分页处理
```

### 9.4 层次数据查询设计模式


**📋 设计模式总结**
```
1. 路径枚举模式：
   优点：查询路径极快
   缺点：存储冗余，维护复杂
   适用：路径查询频繁的场景

2. 嵌套集合模式：
   优点：子树查询高效
   缺点：插入删除复杂
   适用：读多写少的场景

3. 邻接表+缓存模式：
   优点：平衡了灵活性和性能
   缺点：需要额外的缓存维护
   适用：大多数业务场景

4. 混合存储模式：
   优点：结合多种模式优点
   缺点：系统复杂度高
   适用：复杂的层级查询需求
```

**🔧 实际设计建议**
```java
// 层次数据查询设计决策树
public class HierarchicalQueryDesigner {
    
    public String recommendDesign(QueryCharacteristics query) {
        
        // 查询频率分析
        if (query.getReadWriteRatio() > 100) {
            return "嵌套集合模型 - 读多写少";
        }
        
        // 查询类型分析
        if (query.isPathQueryFrequent()) {
            return "路径枚举模型 - 路径查询频繁";
        }
        
        // 数据量分析
        if (query.getNodeCount() > 100000) {
            return "分表+缓存模式 - 大数据量";
        }
        
        // 默认推荐
        return "邻接表+CTE - 通用场景";
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 层次数据：树状结构的数据，具有父子关系
🔸 CTE递归：SQL标准的递归查询语法，处理层次数据的利器
🔸 存储模型：邻接表（最常用）、嵌套集合、路径枚举三种主要方式
🔸 遍历策略：深度优先适合路径分析，广度优先适合层级统计
🔸 路径构建：动态生成节点到根的完整路径字符串
🔸 查询优化：索引设计、深度限制、分页处理是关键
```

### 10.2 关键理解要点


**🔹 为什么CTE递归这么重要**
```
传统方案问题：
• 需要多次查询数据库
• 应用层递归逻辑复杂
• 性能差，网络开销大

CTE递归优势：
• 一次SQL完成递归遍历
• 数据库引擎优化，性能更好
• 逻辑清晰，代码简洁
• 支持复杂的层级操作
```

**🔹 路径字符串的实际价值**
```
业务应用：
• 面包屑导航：展示用户当前位置
• 权限继承：基于路径的权限控制
• 数据分析：按路径统计和分组
• 搜索优化：基于路径的相关性排序

技术实现：
• 字符串连接：最直观的路径表示
• ID路径：高效的数值路径
• 编码路径：便于系统集成
• JSON路径：适合前端处理
```

**🔹 性能优化的关键思路**
```
优化层次：
① 数据模型：选择合适的存储结构
② 索引设计：为层级查询建立专门索引
③ 查询优化：使用CTE递归，限制查询范围
④ 应用缓存：缓存热点路径和子树数据

监控要点：
• 递归查询的层数和节点数
• 路径字符串的长度和内存占用
• 索引的使用情况
• 查询响应时间和并发性能
```

### 10.3 实际应用价值


**🎯 业务价值**
- **组织管理**：灵活的组织架构查询和统计
- **内容管理**：层级分类的内容组织和检索  
- **权限系统**：基于层级的权限继承和控制
- **导航系统**：动态菜单生成和路径导航

**🔧 技术价值**
- **数据建模**：为层次关系数据设计合适的存储结构
- **查询优化**：使用CTE递归高效处理树状数据
- **系统设计**：支持可扩展的层级数据架构
- **性能调优**：优化层级查询的性能瓶颈

### 10.4 学习路径建议


**📚 学习顺序**
```
① 理解层次数据的基本概念和应用场景
② 掌握CTE递归查询的语法和原理
③ 学习不同存储模型的优缺点
④ 实践各种层级查询的实现方法
⑤ 深入路径构建和遍历策略
⑥ 关注性能优化和最佳实践
```

**🛠️ 实践建议**
- **动手搭建**：创建组织架构或商品分类的完整示例
- **场景练习**：实现不同类型的层级查询需求
- **性能测试**：测试不同数据量下的查询性能
- **架构设计**：为实际业务设计层次数据解决方案

**核心记忆**：
- CTE递归是处理层次数据的标准SQL技术
- 邻接表模型简单实用，适合大多数场景
- 路径构建是层次查询的核心技能
- 深度优先适合路径分析，广度优先适合层级统计
- 性能优化重点是索引设计和查询范围控制