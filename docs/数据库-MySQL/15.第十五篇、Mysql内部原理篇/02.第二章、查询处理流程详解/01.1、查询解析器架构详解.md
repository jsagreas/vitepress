---
title: 1、查询解析器架构详解
---
## 📚 目录

1. [查询解析器概述](#1-查询解析器概述)
2. [词法分析器Lexer详解](#2-词法分析器lexer详解)
3. [语法分析器Parser原理](#3-语法分析器parser原理)
4. [语义分析器Semantic机制](#4-语义分析器semantic机制)
5. [AST抽象语法树构建](#5-ast抽象语法树构建)
6. [查询解析缓存机制](#6-查询解析缓存机制)
7. [预编译语句处理](#7-预编译语句处理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 查询解析器概述


### 1.1 什么是查询解析器


**简单理解**：查询解析器就像是MySQL的"翻译官"，它把我们写的SQL语句翻译成MySQL内部能理解的指令。

```
用户输入：SELECT * FROM users WHERE age > 18;
                    ↓ 查询解析器处理
MySQL理解：查找users表中age字段大于18的所有记录
```

**核心作用**：
- **🔸 语言翻译**：将SQL文本转换为内部执行计划
- **🔸 语法检查**：确保SQL语句符合标准语法
- **🔸 权限验证**：检查用户是否有操作权限
- **🔸 优化准备**：为查询优化器提供标准化的查询树

### 1.2 解析器架构总览


```
SQL查询解析流程：

原始SQL文本
    ↓
┌─────────────────┐
│  词法分析器      │ ← 分解成单词(Token)
│   (Lexer)      │
└─────────────────┘
    ↓
┌─────────────────┐
│  语法分析器      │ ← 检查语法，构建语法树
│   (Parser)     │
└─────────────────┘
    ↓
┌─────────────────┐
│  语义分析器      │ ← 检查语义，验证权限
│  (Semantic)    │
└─────────────────┘
    ↓
┌─────────────────┐
│  AST语法树      │ ← 标准化的查询表示
│               │
└─────────────────┘
    ↓
查询优化器...
```

### 1.3 解析器在MySQL中的位置


**MySQL架构层次**：
```
应用层
    ↓
┌─────────────────┐
│   连接层         │ ← 连接管理、认证
├─────────────────┤
│   SQL层         │ ← 查询解析器在这里
│  (解析器)       │
├─────────────────┤
│   存储引擎层     │ ← InnoDB、MyISAM等
└─────────────────┘
```

---

## 2. 📝 词法分析器Lexer详解


### 2.1 词法分析的基本概念


**什么是词法分析**：就像阅读文章时，我们先要识别出每个单词一样，词法分析器把SQL语句分解成一个个"单词"（叫做Token）。

```sql
-- 原始SQL
SELECT name FROM users WHERE id = 123;

-- 词法分析后的Token序列
[SELECT] [name] [FROM] [users] [WHERE] [id] [=] [123] [;]
  关键字   标识符  关键字  标识符   关键字  标识符 操作符 数字  分隔符
```

### 2.2 关键字识别机制


**关键字识别**：词法分析器需要区分哪些是SQL关键字，哪些是用户自定义的名称。

```sql
-- 示例：关键字 vs 标识符
SELECT select_column FROM table_name;
  ↑        ↑           ↑       ↑
关键字   标识符      关键字   标识符
```

**关键字处理规则**：
- **🔸 大小写不敏感**：`SELECT` 和 `select` 是同一个关键字
- **🔸 保留字检查**：确保用户不能用关键字做表名、列名
- **🔸 上下文相关**：有些词在不同上下文中含义不同

### 2.3 标识符规范化


**标识符规范化**：把用户写的表名、列名等统一成标准格式。

```sql
-- 用户可能这样写
SELECT `User_Name`, "Age" FROM Users;

-- 规范化后
SELECT user_name, age FROM users;
```

**规范化规则**：
- **🔸 反引号处理**：去除反引号，保留原始大小写
- **🔸 双引号处理**：根据SQL模式决定是字符串还是标识符
- **🔸 大小写转换**：根据配置决定是否转换大小写

### 2.4 多字节字符处理


**字符集处理**：MySQL支持多种字符集，词法分析器需要正确处理各种字符。

```sql
-- 不同字符集的例子
SELECT 姓名 FROM 用户表 WHERE 年龄 > 18;  -- UTF8中文
SELECT nom FROM utilisateurs WHERE âge > 18;  -- 法语重音字符
```

**处理机制**：
- **🔸 字符集识别**：根据连接字符集解析字符
- **🔸 字符边界识别**：正确识别多字节字符的边界
- **🔸 字符集转换**：必要时转换为内部字符集

### 2.5 注释处理机制


**注释识别**：词法分析器需要识别并跳过各种注释。

```sql
-- SQL中的注释类型
SELECT name  -- 单行注释
FROM users   /* 多行注释开始
             这是注释内容
             多行注释结束 */
WHERE id > 0; # MySQL特有的注释
```

**注释处理**：
- **🔸 跳过注释**：注释不影响SQL执行
- **🔸 保留位置信息**：用于错误报告和调试
- **🔸 嵌套注释处理**：某些数据库支持嵌套注释

---

## 3. 🏗️ 语法分析器Parser原理


### 3.1 语法分析的作用


**语法分析做什么**：检查Token序列是否符合SQL语法规则，就像检查句子是否符合语法一样。

```sql
-- 正确的语法
SELECT name FROM users WHERE age > 18;

-- 错误的语法
SELECT FROM users name WHERE > 18 age;  -- 词序错误
```

### 3.2 语法分析器实现方式


**解析器类型**：MySQL使用**递归下降解析器**，这是一种自顶向下的解析方法。

```
语法规则示例（简化版）：

SELECT语句 ::= SELECT 列列表 FROM 表名 [WHERE 条件]
列列表 ::= 列名 | 列名, 列列表
条件 ::= 列名 操作符 值
```

**递归下降解析**：
```
解析SELECT语句的过程：
1. 看到SELECT关键字 → 进入SELECT语句解析
2. 调用解析列列表的函数
3. 看到FROM关键字 → 调用解析表名的函数
4. 看到WHERE关键字 → 调用解析条件的函数
5. 每个函数递归调用其他函数，直到完成整个解析
```

### 3.3 语法错误恢复


**错误恢复机制**：当遇到语法错误时，解析器尝试恢复并继续解析，提供更好的错误信息。

```sql
-- 错误示例
SELECT name, FROM users WHERE age > ;

-- 解析器会报告：
-- 1. 第1个错误：FROM前多了逗号
-- 2. 第2个错误：WHERE条件不完整
```

**恢复策略**：
- **🔸 跳过错误Token**：跳过无法识别的符号
- **🔸 插入缺失Token**：自动补充可能缺失的符号
- **🔸 同步点恢复**：在分号等位置重新开始解析

### 3.4 解析器状态机


**状态机概念**：解析器在不同状态间转换，每个状态对应解析过程的不同阶段。

```
状态转换示例：

初始状态 → 看到SELECT → SELECT状态
SELECT状态 → 看到列名 → 列解析状态  
列解析状态 → 看到FROM → FROM状态
FROM状态 → 看到表名 → 表解析状态
...
```

---

## 4. 🔐 语义分析器Semantic机制


### 4.1 语义分析的职责


**语义分析做什么**：检查SQL语句在逻辑上是否正确，就像检查句子的意思是否合理。

```sql
-- 语法正确但语义错误的例子
SELECT age FROM users WHERE name > 100;  -- 用名字和数字比较，语义错误
SELECT * FROM non_existing_table;       -- 表不存在，语义错误
```

### 4.2 元数据解析


**元数据检查**：验证SQL中提到的表、列、函数等是否存在。

```sql
-- 元数据验证过程
SELECT u.name, p.title 
FROM users u 
JOIN posts p ON u.id = p.user_id;

-- 检查项目：
-- 1. users表是否存在？
-- 2. users表有name、id列吗？
-- 3. posts表是否存在？
-- 4. posts表有title、user_id列吗？
-- 5. 用户是否有这些表的查询权限？
```

**元数据缓存**：
- **🔸 表结构缓存**：避免重复查询数据字典
- **🔸 权限信息缓存**：提高权限检查效率
- **🔸 失效机制**：DDL操作时更新缓存

### 4.3 权限检查机制


**权限验证流程**：

```
权限检查步骤：

1. 用户身份验证
   ├─ 检查用户是否有效
   └─ 验证密码/认证信息

2. 全局权限检查  
   ├─ SELECT_PRIV
   ├─ INSERT_PRIV
   └─ UPDATE_PRIV等

3. 数据库级权限
   └─ 特定数据库的操作权限

4. 表级权限
   └─ 特定表的操作权限

5. 列级权限
   └─ 特定列的访问权限
```

**权限检查示例**：
```sql
-- 用户执行这个查询
SELECT salary FROM employees WHERE department = 'HR';

-- 权限检查：
-- 1. 用户是否有employees表的SELECT权限？
-- 2. 用户是否有salary列的SELECT权限？
-- 3. 用户是否有department列的SELECT权限？
```

### 4.4 类型检查与转换


**数据类型验证**：确保操作符和函数的使用符合类型要求。

```sql
-- 类型检查示例
SELECT * FROM users 
WHERE age > '18'        -- 字符串'18'会自动转换为数字18
  AND name LIKE 123;    -- 错误：LIKE操作符不能用于数字

-- 隐式类型转换
WHERE date_column > '2023-01-01'  -- 字符串转换为日期
WHERE int_column = '123'          -- 字符串转换为整数
```

---

## 5. 🌳 AST抽象语法树构建


### 5.1 什么是AST


**AST概念**：抽象语法树是SQL语句的树形表示，就像句子的语法分析树一样。

```sql
-- SQL语句
SELECT name FROM users WHERE age > 18;

-- 对应的AST结构（简化表示）
SELECT
├─ SELECT_LIST
│  └─ COLUMN: name
├─ FROM_CLAUSE  
│  └─ TABLE: users
└─ WHERE_CLAUSE
   └─ COMPARISON
      ├─ LEFT: age
      ├─ OPERATOR: >
      └─ RIGHT: 18
```

### 5.2 AST节点类型


**常见节点类型**：

| 节点类型 | **作用** | **示例** |
|---------|---------|---------|
| `SELECT_NODE` | `表示SELECT语句` | `SELECT * FROM table` |
| `TABLE_NODE` | `表示表引用` | `FROM users` |
| `COLUMN_NODE` | `表示列引用` | `SELECT name` |
| `CONDITION_NODE` | `表示条件表达式` | `WHERE age > 18` |
| `FUNCTION_NODE` | `表示函数调用` | `COUNT(*)` |
| `JOIN_NODE` | `表示表连接` | `INNER JOIN` |

### 5.3 AST构建过程


**构建步骤**：

```
AST构建流程：

词法分析 → Token流
     ↓
语法分析 → 解析规则匹配
     ↓  
节点创建 → 根据语法规则创建AST节点
     ↓
树构建 → 将节点组织成树结构
     ↓
语义分析 → 在AST上进行语义检查
     ↓
完整AST → 用于查询优化
```

### 5.4 AST的优化价值


**为什么需要AST**：

- **🔸 统一表示**：不同的SQL写法可以产生相同的AST
- **🔸 优化基础**：查询优化器基于AST进行优化
- **🔸 执行计划生成**：AST转换为执行计划
- **🔸 语义分析**：在树结构上更容易进行语义检查

```sql
-- 这两个查询产生相同的AST
SELECT * FROM users WHERE age > 18 AND name = 'John';
SELECT * FROM users WHERE name = 'John' AND age > 18;
```

---

## 6. 💾 查询解析缓存机制


### 6.1 解析缓存的必要性


**为什么需要缓存**：解析过程相对耗时，缓存可以避免重复解析相同的SQL。

```sql
-- 这个查询可能被执行很多次
SELECT * FROM users WHERE id = ?;

-- 第一次：完整解析过程
-- 后续：从缓存中获取解析结果
```

### 6.2 缓存机制实现


**缓存策略**：

```
查询缓存结构：

SQL文本 (作为Key)
    ↓
┌─────────────────┐
│  解析缓存项      │
│  ├─ AST树       │
│  ├─ 权限信息     │
│  ├─ 元数据信息   │
│  └─ 解析时间戳   │
└─────────────────┘
```

**缓存查找流程**：
```
1. 计算SQL文本的哈希值
2. 在缓存中查找对应的解析结果
3. 如果找到且有效，直接使用
4. 如果没找到，执行完整解析并缓存结果
```

### 6.3 缓存失效机制


**什么时候缓存失效**：

- **🔸 DDL操作**：表结构改变时
- **🔸 权限变更**：用户权限改变时  
- **🔸 时间过期**：超过缓存有效期
- **🔸 内存压力**：缓存空间不足时

```sql
-- 这些操作会使相关缓存失效
ALTER TABLE users ADD COLUMN email VARCHAR(100);  -- 表结构变更
GRANT SELECT ON users TO 'user1'@'%';            -- 权限变更
```

---

## 7. 🔄 预编译语句处理


### 7.1 什么是预编译语句


**预编译概念**：预编译语句是提前解析好的SQL模板，只需要传入参数就可以执行。

```sql
-- 普通SQL（每次都要解析）
SELECT * FROM users WHERE id = 123;
SELECT * FROM users WHERE id = 456;

-- 预编译SQL（解析一次，多次使用）
PREPARE stmt FROM 'SELECT * FROM users WHERE id = ?';
EXECUTE stmt USING @user_id;
```

### 7.2 预编译处理流程


**处理步骤**：

```
预编译流程：

SQL模板解析
    ↓
┌─────────────────┐
│  解析阶段        │ ← 一次性完成
│  ├─ 词法分析     │
│  ├─ 语法分析     │  
│  └─ 语义分析     │
└─────────────────┘
    ↓
┌─────────────────┐
│  参数化AST      │ ← 带有参数占位符
└─────────────────┘
    ↓
┌─────────────────┐
│  执行阶段        │ ← 多次执行
│  ├─ 参数绑定     │
│  ├─ 查询优化     │
│  └─ 查询执行     │
└─────────────────┘
```

### 7.3 参数绑定机制


**参数绑定过程**：

```java
// 预编译语句的使用示例
PreparedStatement pstmt = connection.prepareStatement(
    "SELECT * FROM users WHERE age > ? AND name = ?"
);

// 参数绑定
pstmt.setInt(1, 18);        // 第一个?绑定为18
pstmt.setString(2, "John"); // 第二个?绑定为"John"

// 执行查询
ResultSet rs = pstmt.executeQuery();
```

**绑定类型检查**：
- **🔸 类型匹配**：确保参数类型与占位符兼容
- **🔸 自动转换**：支持合理的类型转换
- **🔸 错误检查**：不兼容的类型会报错

### 7.4 预编译的优势


**性能优势**：

| 方面 | **普通SQL** | **预编译SQL** |
|------|-----------|-------------|
| `解析次数` | `每次执行都解析` | `解析一次，多次使用` |
| `优化次数` | `每次都优化` | `优化一次，重复使用` |
| `内存使用` | `每次分配新内存` | `重用解析结果内存` |
| `安全性` | `容易SQL注入` | `有效防止SQL注入` |

**安全优势**：
```sql
-- SQL注入风险示例
String sql = "SELECT * FROM users WHERE name = '" + userName + "'";
-- 如果userName = "'; DROP TABLE users; --"，就很危险

-- 预编译语句安全
PreparedStatement pstmt = conn.prepareStatement(
    "SELECT * FROM users WHERE name = ?"
);
pstmt.setString(1, userName); // 参数会被正确转义
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 查询解析器：MySQL的"翻译官"，将SQL转换为内部执行计划
🔸 三大组件：词法分析器(分词) → 语法分析器(语法检查) → 语义分析器(语义检查)
🔸 AST语法树：SQL的标准化树形表示，是优化和执行的基础
🔸 解析缓存：避免重复解析，提高性能
🔸 预编译语句：一次解析多次使用，安全且高效
```

### 8.2 关键理解要点


**🔹 解析器的核心价值**：
```
用户友好性：
- 支持灵活的SQL写法
- 提供友好的错误提示
- 处理各种字符集和注释

性能优化：
- 缓存解析结果避免重复工作
- 预编译语句提高执行效率
- 为查询优化器提供标准化输入

安全保障：
- 权限检查确保数据安全
- 语法验证防止错误操作
- 参数绑定防止SQL注入
```

**🔹 解析过程的层次递进**：
```
词法层面：识别单词和符号
语法层面：检查语法规则
语义层面：验证逻辑正确性
结构层面：构建标准化表示
```

### 8.3 实际应用价值


- **开发者角度**：理解SQL解析有助于写出更高效的查询
- **DBA角度**：了解解析过程有助于性能调优和问题排查  
- **架构师角度**：解析器设计影响数据库的易用性和性能

**核心记忆**：
- 解析器是SQL执行的第一道关卡
- 三个分析器各司其职，层层把关
- AST是标准化的桥梁，连接解析和优化
- 缓存和预编译是性能优化的重要手段
- 理解解析过程有助于写出更好的SQL