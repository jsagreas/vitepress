---
title: 4、查询计划执行过程
---
## 📚 目录

1. [查询执行概述](#1-查询执行概述)
2. [执行计划树遍历](#2-执行计划树遍历)
3. [算子执行顺序与调度](#3-算子执行顺序与调度)
4. [中间结果处理机制](#4-中间结果处理机制)
5. [资源分配与管理](#5-资源分配与管理)
6. [执行状态跟踪](#6-执行状态跟踪)
7. [异常处理机制](#7-异常处理机制)
8. [执行统计与监控](#8-执行统计与监控)
9. [执行优化与自适应](#9-执行优化与自适应)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🚀 查询执行概述


### 1.1 什么是查询计划执行


**查询计划执行**就是MySQL拿到优化器生成的执行计划后，按照计划一步步执行SQL语句的过程。

```
简单理解：
执行计划 = 做菜的菜谱
执行过程 = 按照菜谱一步步做菜

SQL: SELECT * FROM users WHERE age > 25 ORDER BY name
执行计划：1.扫描索引 2.过滤数据 3.排序结果
执行过程：按计划1→2→3的顺序实际操作
```

### 1.2 执行阶段划分


MySQL查询执行分为以下几个核心阶段：

```
执行阶段流程：
┌─────────────┐
│  1.初始化   │ ← 准备执行环境，分配资源
├─────────────┤
│  2.树遍历   │ ← 遍历执行计划树结构
├─────────────┤  
│  3.算子执行 │ ← 执行具体的操作算子
├─────────────┤
│  4.结果处理 │ ← 处理中间和最终结果
├─────────────┤
│  5.资源回收 │ ← 清理资源，记录统计
└─────────────┘
```

**各阶段作用说明**：
- **初始化阶段**：分配内存、建立连接、准备缓冲区
- **树遍历阶段**：从根节点开始遍历执行计划树
- **算子执行阶段**：执行扫描、过滤、连接、排序等操作
- **结果处理阶段**：组装最终结果，返回给客户端
- **资源回收阶段**：释放内存、关闭文件、更新统计信息

---

## 2. 🌳 执行计划树遍历


### 2.1 执行计划树结构


执行计划以**树形结构**组织，每个节点代表一个操作算子。

```
执行计划树示例：
         [ProjectionOp]     ← 根节点：投影操作
              |
         [SortOp]          ← 排序操作
              |
         [FilterOp]        ← 过滤操作
              |
         [TableScanOp]     ← 叶节点：表扫描

对应SQL: SELECT id,name FROM users WHERE age > 25 ORDER BY name
```

### 2.2 树遍历策略


**火山模型（Volcano Model）**：MySQL主要采用的执行模型

```
火山模型特点：
1. 按需拉取：上层算子向下层算子请求数据
2. 逐行处理：每次处理一行数据
3. 流水线：数据在算子间流水线传递

执行流程：
客户端请求 → 投影算子.next() → 排序算子.next() → 过滤算子.next() → 扫描算子.next()
                    ↓                ↓                ↓                ↓
                返回结果 ←────── 返回排序行 ←────── 返回过滤行 ←────── 返回原始行
```

### 2.3 算子接口设计


每个算子都实现统一的接口：

```sql
-- 算子接口（伪代码）
interface Operator {
    void open();     -- 初始化算子
    Row next();      -- 获取下一行数据
    void close();    -- 清理算子资源
}

-- 执行示例
TableScanOp.open()    -- 打开表文件
while (row = TableScanOp.next()) {
    if (FilterOp.evaluate(row)) {
        SortOp.add(row);
    }
}
SortOp.sort()
ProjectionOp.output(SortOp.next())
```

---

## 3. ⚙️ 算子执行顺序与调度


### 3.1 执行顺序规则


算子执行遵循**后序遍历**原则：先执行子节点，再执行父节点。

```
执行顺序示例：
         [3.投影]
              |
         [2.排序]
              |
         [1.过滤]
              |
         [0.扫描]

执行顺序：0 → 1 → 2 → 3
实际含义：先扫描 → 再过滤 → 再排序 → 最后投影
```

### 2.2 调度策略


**单线程调度**：
- 简单直接，按顺序执行算子
- 适合小数据量查询

**并行调度**：
- 多个算子并行执行
- 适合复杂查询和大数据量

```
并行执行示例：
       [合并排序]
        /        \
   [排序线程1]  [排序线程2]
     |            |
  [数据分片1]   [数据分片2]
```

### 3.3 算子类型与执行特点


| 算子类型 | **执行特点** | **资源需求** | **示例操作** |
|---------|-------------|------------|-------------|
| 🔍 **扫描算子** | `顺序读取数据` | `IO密集` | `全表扫描、索引扫描` |
| 🎯 **过滤算子** | `逐行判断条件` | `CPU密集` | `WHERE条件过滤` |
| 🔗 **连接算子** | `关联多表数据` | `内存+CPU密集` | `INNER JOIN、LEFT JOIN` |
| 📊 **聚合算子** | `分组计算统计` | `内存密集` | `GROUP BY、COUNT、SUM` |
| 📋 **排序算子** | `数据排序输出` | `内存+IO密集` | `ORDER BY排序` |

---

## 4. 📦 中间结果处理机制


### 4.1 中间结果的产生


在多算子执行过程中，会产生大量**中间结果**：

```
中间结果示例：
原始数据: [1000万行用户数据]
    ↓ 过滤算子
中间结果1: [100万行符合条件的数据]  ← 中间结果
    ↓ 连接算子  
中间结果2: [150万行连接后的数据]   ← 中间结果
    ↓ 排序算子
最终结果: [150万行排序后的数据]
```

### 4.2 中间结果存储策略


**内存存储**：
```sql
-- 小数据量直接存储在内存中
sort_buffer_size = 2MB  -- 排序缓冲区
join_buffer_size = 256KB -- 连接缓冲区
```

**磁盘存储**：
```sql
-- 数据量超过内存限制时写入临时文件
tmp_table_size = 16MB    -- 临时表大小限制
max_heap_table_size = 16MB -- 内存表大小限制
```

### 4.3 中间结果传递方式


**流水线传递**：
- 数据逐行在算子间传递
- 内存占用小，适合大数据量

**批量传递**：
- 数据分批在算子间传递  
- 减少函数调用开销

```
传递方式对比：
流水线: [扫描] → 行1 → [过滤] → 行1 → [排序]
        [扫描] → 行2 → [过滤] → 行2 → [排序]

批量: [扫描] → [1000行] → [过滤] → [800行] → [排序]
```

---

## 5. 💾 资源分配与管理


### 5.1 内存资源分配


MySQL为查询执行分配不同类型的内存：

```
内存分配结构：
┌─────────────────┐
│   查询内存总池   │ ← query_cache_size
├─────────────────┤
│   排序缓冲区     │ ← sort_buffer_size  
├─────────────────┤
│   连接缓冲区     │ ← join_buffer_size
├─────────────────┤
│   临时表空间     │ ← tmp_table_size
├─────────────────┤
│   读缓冲区       │ ← read_buffer_size
└─────────────────┘
```

**关键参数配置**：
```sql
-- 查看当前内存配置
SHOW VARIABLES LIKE '%buffer%';
SHOW VARIABLES LIKE '%cache%';

-- 常用内存参数
sort_buffer_size = 2M        -- 排序缓冲区
join_buffer_size = 256K      -- 连接缓冲区  
read_buffer_size = 128K      -- 顺序读缓冲区
read_rnd_buffer_size = 256K  -- 随机读缓冲区
```

### 5.2 文件句柄管理


```sql
-- 文件句柄相关参数
open_files_limit = 65535     -- 系统级文件句柄限制
table_open_cache = 2000      -- 表缓存数量
table_definition_cache = 1400 -- 表定义缓存
```

### 5.3 资源使用监控


```sql
-- 监控资源使用情况
SHOW STATUS LIKE 'Created_tmp%';      -- 临时表创建统计
SHOW STATUS LIKE 'Sort%';             -- 排序操作统计  
SHOW STATUS LIKE 'Select%';           -- 查询类型统计

-- 查看当前连接的资源使用
SHOW PROCESSLIST;
SELECT * FROM information_schema.PROCESSLIST;
```

---

## 6. 📊 执行状态跟踪


### 6.1 执行状态类型


MySQL跟踪查询执行的各种状态：

```
执行状态转换：
[等待] → [解析] → [优化] → [执行] → [发送数据] → [清理]
  ↓        ↓       ↓       ↓         ↓          ↓
 Idle   Parsing  Opt   Executing  Sending    Cleanup
```

### 6.2 状态查看方法


```sql
-- 查看当前查询状态
SHOW PROCESSLIST;

-- 详细状态信息
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    LEFT(INFO, 50) as QUERY_TEXT
FROM information_schema.PROCESSLIST 
WHERE STATE != 'Sleep';
```

### 6.3 执行进度报告


对于长时间运行的查询，MySQL提供进度报告：

```sql
-- 启用进度报告（MySQL 8.0+）
SET SESSION show_query_digest = ON;

-- 查看执行进度
SELECT 
    THREAD_ID,
    EVENT_NAME,
    CURRENT_SCHEMA,
    SQL_TEXT,
    ROWS_EXAMINED,
    ROWS_SENT,
    TIMER_WAIT/1000000000 as DURATION_SEC
FROM performance_schema.events_statements_current;
```

---

## 7. ⚠️ 异常处理机制


### 7.1 常见执行异常


**资源不足异常**：
```sql
-- 内存不足
ERROR 1041 (HY000): Out of memory

-- 磁盘空间不足  
ERROR 1021 (HY000): Disk full

-- 临时表过大
ERROR 1114 (HY000): The table is full
```

**超时异常**：
```sql
-- 查询超时
wait_timeout = 28800          -- 连接空闲超时
interactive_timeout = 28800    -- 交互式连接超时
net_read_timeout = 30         -- 网络读超时
```

### 7.2 异常恢复策略


**自动重试机制**：
- 对于临时性错误（如锁等待）自动重试
- 重试次数和间隔可配置

**资源释放**：
- 异常发生时立即释放已分配的资源
- 防止资源泄漏

```sql
-- 异常处理示例（伪代码）
BEGIN EXECUTION
    TRY {
        allocate_resources()
        execute_operators()
        return_results()
    }
    CATCH (OutOfMemoryError) {
        release_resources()
        use_disk_based_algorithm()
        retry_execution()
    }
    FINALLY {
        cleanup_temp_files()
        update_statistics()
    }
END EXECUTION
```

### 7.3 中断恢复机制


**优雅中断**：
- 接收到KILL信号时，完成当前操作后停止
- 保证数据一致性

**检查点机制**：
- 对于长时间运行的查询，定期保存执行状态
- 支持从检查点恢复执行

---

## 8. 📈 执行统计与监控


### 8.1 执行统计信息收集


MySQL收集详细的执行统计信息：

```sql
-- 查看查询执行统计
SHOW STATUS LIKE 'Com_select';
SHOW STATUS LIKE 'Handler_%';
SHOW STATUS LIKE 'Created_tmp_%';

-- 重要统计指标
Handler_read_first    -- 读取索引第一个条目的次数
Handler_read_next     -- 读取下一个索引条目的次数
Handler_read_rnd      -- 随机读取行的次数
Created_tmp_tables    -- 创建临时表的次数
Created_tmp_disk_tables -- 创建磁盘临时表的次数
```

### 8.2 性能监控工具


**Performance Schema**：
```sql
-- 启用性能监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'statement/%';

-- 查看慢查询
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000000 as AVG_TIME_SEC,
    ROWS_EXAMINED_MAX,
    ROWS_SENT_MAX
FROM performance_schema.events_statements_summary_by_digest
ORDER BY AVG_TIMER_WAIT DESC LIMIT 10;
```

**执行计划分析**：
```sql
-- 分析具体查询的执行统计
EXPLAIN FORMAT=JSON 
SELECT * FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.age > 25;
```

### 8.3 资源使用监控


```sql
-- 监控内存使用
SELECT 
    EVENT_NAME,
    CURRENT_COUNT_USED,
    HIGH_COUNT_USED,
    CURRENT_SIZE_ALLOCATED,
    HIGH_SIZE_ALLOCATED
FROM performance_schema.memory_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'memory/sql/%'
ORDER BY CURRENT_SIZE_ALLOCATED DESC;

-- 监控文件IO
SELECT 
    FILE_NAME,
    EVENT_NAME,
    COUNT_READ,
    COUNT_WRITE,
    SUM_NUMBER_OF_BYTES_READ,
    SUM_NUMBER_OF_BYTES_WRITE
FROM performance_schema.file_summary_by_instance
ORDER BY SUM_NUMBER_OF_BYTES_READ DESC;
```

---

## 9. 🔧 执行优化与自适应


### 9.1 执行计划缓存


**计划缓存机制**：
```sql
-- 查询缓存配置
query_cache_type = ON         -- 启用查询缓存
query_cache_size = 64M        -- 缓存大小
query_cache_limit = 2M        -- 单个查询结果限制

-- 预编译语句缓存
PREPARE stmt FROM 'SELECT * FROM users WHERE id = ?';
SET @id = 123;
EXECUTE stmt USING @id;
```

### 9.2 自适应执行


**动态算法选择**：
- 根据数据分布自动选择最优算法
- 例如：小表用嵌套循环连接，大表用哈希连接

```sql
-- 自适应连接算法示例
IF (table1.rows < 1000 AND table2.rows < 1000) {
    USE nested_loop_join();
} ELSE IF (memory_available > join_data_size) {
    USE hash_join();
} ELSE {
    USE sort_merge_join();
}
```

### 9.3 运行时计划调整


**执行计划版本管理**：
- 保存多个版本的执行计划
- 根据实际执行效果选择最优版本

**执行上下文管理**：
- 维护查询执行的上下文信息
- 支持计划的动态调整

```sql
-- 执行上下文信息
Context {
    query_id: 12345,
    session_id: 67890,
    start_time: '2025-09-09 10:00:00',
    allocated_memory: 50MB,
    temp_files: ['/tmp/mysql_sort_123', '/tmp/mysql_join_456'],
    current_operator: 'SortOperator',
    rows_processed: 500000,
    estimated_remaining_time: 30s
}
```

### 9.4 执行优化反馈


**统计信息更新**：
- 执行后更新表和索引的统计信息
- 为下次查询优化提供更准确的数据

**执行计划评估**：
- 比较预估代价与实际执行代价
- 调整代价模型参数

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 查询执行本质：按照执行计划树逐步操作数据的过程
🔸 火山模型：算子间按需拉取数据的执行模式  
🔸 算子类型：扫描、过滤、连接、聚合、排序等基本操作
🔸 资源管理：内存、文件句柄、临时空间的分配与回收
🔸 状态跟踪：监控执行进度，收集统计信息
🔸 异常处理：资源清理、错误恢复、优雅中断
```

### 10.2 关键理解要点


**🔹 执行效率的影响因素**：
```
算子选择：不同算子的效率差异很大
资源分配：内存不足会导致磁盘IO增加  
数据分布：倾斜数据影响算法效果
并发控制：锁竞争影响执行性能
```

**🔹 监控与优化重点**：
```
关注指标：
- 临时表创建数量（Created_tmp_tables）
- 排序操作统计（Sort_merge_passes）  
- 文件读写次数（Handler_read_*）
- 内存使用情况（memory_summary）

优化方向：
- 减少临时表使用
- 合理配置缓冲区大小
- 避免全表扫描
- 优化连接算法选择
```

### 10.3 实际应用价值


**性能问题诊断**：
- 通过执行统计定位性能瓶颈
- 分析资源使用情况找出问题原因

**查询优化指导**：
- 理解执行过程有助于编写高效SQL
- 合理设置相关参数提升性能

**系统调优依据**：
- 基于执行统计调整系统参数
- 根据资源使用情况规划硬件配置

### 10.4 学习要点记忆


**执行流程记忆**：
```
计划树遍历 → 算子调度 → 资源分配 → 状态跟踪 → 结果返回
```

**核心算子记忆**：
```
扫描取数据，过滤筛条件
连接关联表，聚合做统计  
排序保顺序，投影选字段
```

**监控重点记忆**：
```
临时表多了查内存，排序慢了看缓冲
读写频繁查索引，CPU高了看算法
```