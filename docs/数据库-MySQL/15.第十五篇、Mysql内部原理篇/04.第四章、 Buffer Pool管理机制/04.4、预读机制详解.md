---
title: 4、预读机制详解
---
## 📚 目录

1. [预读机制基础概念](#1-预读机制基础概念)
2. [线性预读机制](#2-线性预读机制)
3. [随机预读机制](#3-随机预读机制)
4. [预读参数配置与调优](#4-预读参数配置与调优)
5. [预读性能监控与评估](#5-预读性能监控与评估)
6. [智能预读算法](#6-智能预读算法)
7. [预读机制优化策略](#7-预读机制优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 预读机制基础概念


### 1.1 什么是预读机制


**预读（Read-Ahead）**：MySQL在读取数据页时，预测用户可能需要的后续页面，提前将这些页面加载到Buffer Pool中的智能缓存策略。

```
传统读取模式：
用户请求页面1 → 从磁盘读取页面1 → 返回数据
用户请求页面2 → 从磁盘读取页面2 → 返回数据  ❌ 每次都要等待磁盘IO

预读模式：
用户请求页面1 → 从磁盘读取页面1 + 预读页面2,3,4 → 返回数据
用户请求页面2 → 直接从Buffer Pool获取 ✅ 无需磁盘IO等待
```

### 1.2 预读机制的核心价值


**💡 解决的核心问题**：
- **减少磁盘IO次数**：批量读取代替单次读取
- **提升查询响应速度**：数据已在内存中等待
- **优化顺序访问模式**：特别适合范围查询和表扫描

```
实际效果对比：

没有预读：
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
│
├─ 读取索引页1 (50ms磁盘IO)
├─ 读取数据页1 (50ms磁盘IO)  
├─ 读取数据页2 (50ms磁盘IO)
└─ 总耗时：150ms

启用预读：
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
│
├─ 读取索引页1 + 预读相邻页 (60ms磁盘IO)
├─ 从缓存读取数据页1 (0.1ms内存访问)
├─ 从缓存读取数据页2 (0.1ms内存访问)
└─ 总耗时：60.2ms ⚡ 性能提升60%+
```

### 1.3 预读的工作原理


**🔄 预读决策流程**：
```
用户访问页面 
     ↓
分析访问模式
     ↓
触发预读条件？ ──No──→ 结束
     ↓ Yes
确定预读范围
     ↓
异步加载页面到Buffer Pool
     ↓
更新预读统计信息
```

**📊 预读类型分类**：
- **线性预读**：检测顺序访问模式，预读后续连续页面
- **随机预读**：检测同一区域内的随机访问，预读整个区域

---

## 2. ⬆️ 线性预读机制


### 2.1 线性预读的触发条件


**线性预读（Linear Read-Ahead）**：当MySQL检测到对某个表空间的**顺序访问模式**时，自动预读后续的连续页面。

```
线性预读触发示例：

数据页编号：  [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
访问顺序：     ✓   ✓   ✓   ？   ？   ？
                ↑   ↑   ↑
            按顺序访问了3个连续页面

当连续访问达到阈值时 → 触发线性预读 → 预读页面4,5,6...
```

**🎯 关键参数：`innodb_read_ahead_threshold`**
```sql
-- 查看当前线性预读阈值
SHOW VARIABLES LIKE 'innodb_read_ahead_threshold';
-- 默认值：56 (表示在一个区域内顺序读取56个页面后触发预读)

-- 调整预读阈值
SET GLOBAL innodb_read_ahead_threshold = 32;  -- 降低阈值，更激进的预读
SET GLOBAL innodb_read_ahead_threshold = 0;   -- 禁用线性预读
```

### 2.2 线性预读的工作机制


**📈 触发逻辑详解**：
```
InnoDB区域结构：
┌────────────────────────────────────────┐
│  Extent (区域) = 64个连续页面 (1MB)      │
│  [1][2][3]...[62][63][64]              │
└────────────────────────────────────────┘

线性预读检测：
1. 监控每个区域内的页面访问情况
2. 统计**顺序访问**的连续页面数量
3. 当连续访问数量 ≥ 阈值时，触发预读
4. 预读该区域剩余的所有页面
```

**⚡ 异步预读实现**：
```
主查询线程：
├─ 继续处理当前查询请求
└─ 不等待预读完成

预读后台线程：
├─ 异步读取预测需要的页面
├─ 将页面加载到Buffer Pool
└─ 更新页面访问统计信息

优势：不阻塞主查询，提前准备数据
```

### 2.3 线性预读的适用场景


**✅ 最佳适用场景**：
```sql
-- 1. 大表范围扫描
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
ORDER BY order_date;

-- 2. 索引范围查询
SELECT * FROM products 
WHERE price BETWEEN 100 AND 500
ORDER BY price;

-- 3. 全表扫描
SELECT COUNT(*) FROM large_table;
```

**❌ 不适用场景**：
```sql
-- 1. 随机主键查询
SELECT * FROM users WHERE id = 12345;  -- 跳跃式访问

-- 2. 基于HASH的查询
SELECT * FROM cache_table WHERE hash_key = 'abc123';

-- 3. 小结果集查询  
SELECT * FROM config WHERE type = 'system' LIMIT 1;
```

---

## 3. 🎲 随机预读机制


### 3.1 随机预读的核心思想


**随机预读（Random Read-Ahead）**：当在同一个区域(Extent)内检测到足够多的随机页面访问时，预读该区域的所有剩余页面。

```
随机预读触发示例：

区域内64个页面：[1][2][3]...[62][63][64]
已访问页面：     [✓]   [✓]     [✓]    [✓]  [✓]
访问模式：       随机分布，但集中在同一区域

当随机访问的页面数 ≥ 阈值 → 触发随机预读 → 读取整个区域
```

**🔧 控制参数：`innodb_random_read_ahead`**
```sql
-- 查看随机预读状态
SHOW VARIABLES LIKE 'innodb_random_read_ahead';
-- 默认：OFF (MySQL 5.5+ 默认关闭)

-- 启用随机预读
SET GLOBAL innodb_random_read_ahead = ON;

-- 禁用随机预读  
SET GLOBAL innodb_random_read_ahead = OFF;
```

### 3.2 随机预读的判断逻辑


**📊 触发条件分析**：
```
随机预读触发算法：

1. 监控区域内访问模式
   ├─ 统计已访问的不同页面数量
   ├─ 记录最近的访问时间窗口
   └─ 计算访问密度

2. 判断是否触发预读
   ├─ 区域内访问页面数 ≥ 13个页面
   ├─ 访问时间窗口内的密度够高
   └─ 满足条件 → 预读整个区域(64页)

3. 预读执行
   ├─ 异步读取区域内未缓存的页面
   └─ 将页面标记为"预读页面"
```

**⚠️ 随机预读的风险**：
```
内存污染风险：
├─ 可能读取大量不需要的页面
├─ 占用Buffer Pool空间
├─ 挤出真正有用的热点数据
└─ 导致缓存命中率下降

因此MySQL 5.5+默认关闭随机预读！
```

### 3.3 随机预读的使用建议


**✅ 建议启用的场景**：
```sql
-- 1. 数据仓库环境：大量分析查询
SELECT department, AVG(salary) 
FROM employees 
GROUP BY department;

-- 2. 报表系统：频繁的聚合操作
SELECT DATE(order_date), COUNT(*), SUM(amount)
FROM orders 
WHERE order_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DATE(order_date);

-- 3. 数据挖掘：需要访问大量不规则数据
```

**❌ 不建议启用的场景**：
```sql
-- 1. OLTP高并发环境
-- 2. Buffer Pool内存有限的服务器  
-- 3. 主要是点查询的应用
-- 4. 对延迟敏感的实时系统
```

---

## 4. ⚙️ 预读参数配置与调优


### 4.1 核心参数详解


**📋 预读相关参数总览**：

| 参数名称 | 默认值 | 作用说明 | 调优建议 |
|---------|--------|----------|----------|
| `innodb_read_ahead_threshold` | `56` | 线性预读触发阈值 | **OLAP**: 32-48<br>**OLTP**: 56-64 |
| `innodb_random_read_ahead` | `OFF` | 随机预读开关 | **分析型**: ON<br>**事务型**: OFF |
| `innodb_buffer_pool_size` | `128MB` | Buffer Pool总大小 | 影响预读效果的内存基础 |

### 4.2 预读阈值设置策略


**🎯 线性预读阈值调优**：
```sql
-- 根据工作负载特征调整

-- 数据仓库/分析场景：更激进的预读
SET GLOBAL innodb_read_ahead_threshold = 32;
-- 理由：大量顺序扫描，提前预读能显著提升性能

-- 混合负载场景：适中预读
SET GLOBAL innodb_read_ahead_threshold = 48;  
-- 理由：平衡预读收益和内存开销

-- 纯OLTP场景：保守预读
SET GLOBAL innodb_read_ahead_threshold = 56;  -- 或者更高
-- 理由：避免不必要的预读影响热点数据
```

**📊 阈值效果对比**：
```
阈值设置对比测试：

测试场景：SELECT * FROM orders WHERE date BETWEEN '2024-01-01' AND '2024-01-31'

阈值=16：
├─ 预读触发频率：★★★★★ (很频繁)
├─ 缓存命中率：85%
├─ 查询响应时间：120ms
└─ 内存使用：较高

阈值=32：  
├─ 预读触发频率：★★★★☆ (较频繁)
├─ 缓存命中率：92%
├─ 查询响应时间：95ms ⭐ 最佳
└─ 内存使用：适中

阈值=56 (默认)：
├─ 预读触发频率：★★★☆☆ (适中)
├─ 缓存命中率：88%  
├─ 查询响应时间：130ms
└─ 内存使用：较低
```

### 4.3 动态调优方法


**🔧 基于监控数据的动态调整**：
```sql
-- 1. 监控预读命中率
SELECT 
  VARIABLE_VALUE as read_ahead_pages
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead';

-- 2. 监控预读废料率  
SELECT 
  VARIABLE_VALUE as evicted_without_access
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead_evicted';

-- 3. 计算预读效率
-- 预读效率 = (预读页面 - 未使用被淘汰页面) / 预读页面 × 100%
```

**📈 调优决策矩阵**：
```
预读效率分析：

效率 > 80%：  
├─ 预读策略：✅ 效果很好
├─ 调整建议：可适当降低阈值，增加预读
└─ 监控重点：内存使用情况

效率 60%-80%：
├─ 预读策略：⚠️  效果一般
├─ 调整建议：保持当前设置，观察业务变化
└─ 监控重点：查询模式变化

效率 < 60%：
├─ 预读策略：❌ 效果不佳  
├─ 调整建议：提高阈值或关闭随机预读
└─ 监控重点：是否有内存浪费
```

---

## 5. 📊 预读性能监控与评估


### 5.1 关键监控指标


**📈 预读性能统计视图**：
```sql
-- 查看Buffer Pool预读统计
SELECT 
  '预读总页数' as metric,
  VARIABLE_VALUE as value 
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead'

UNION ALL

SELECT 
  '线性预读页数',
  VARIABLE_VALUE
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead_rnd'

UNION ALL

SELECT 
  '预读淘汰页数',  
  VARIABLE_VALUE
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead_evicted';
```

### 5.2 预读命中率计算


**🎯 核心计算公式**：
```sql
-- 预读命中率计算脚本
SET @read_ahead_total = (
  SELECT VARIABLE_VALUE 
  FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
  WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead'
);

SET @read_ahead_evicted = (
  SELECT VARIABLE_VALUE
  FROM INFORMATION_SCHEMA.GLOBAL_STATUS  
  WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead_evicted'
);

SELECT 
  CONCAT(
    ROUND((@read_ahead_total - @read_ahead_evicted) / @read_ahead_total * 100, 2),
    '%'
  ) as '预读命中率',
  @read_ahead_total as '总预读页数',
  @read_ahead_evicted as '未使用淘汰页数';
```

**💡 命中率评估标准**：
```
预读命中率评估：

90%+ ：🟢 优秀
├─ 预读策略非常有效
├─ 大多数预读页面都被使用
└─ 可考虑适当增加预读

70%-90%：🟡 良好  
├─ 预读策略基本有效
├─ 存在一定的优化空间
└─ 保持现状或微调

50%-70%：🟠 一般
├─ 预读效果不明显
├─ 可能存在预读策略不匹配
└─ 需要分析访问模式

<50%：🔴 较差
├─ 预读大量无效页面
├─ 浪费内存和IO资源  
└─ 建议调整或关闭预读
```

### 5.3 预读废料处理


**🗑️ 预读废料产生原因**：
```
预读页面变成"废料"的典型场景：

1. 查询中断：
   ├─ 用户取消长时间运行的查询
   ├─ 应用程序超时断开连接
   └─ 预读的页面没机会被访问

2. 访问模式改变：
   ├─ 从顺序访问切换到随机访问
   ├─ 查询条件发生变化
   └─ 预测不准确

3. 内存压力：
   ├─ Buffer Pool空间不足
   ├─ 新的热点数据需要空间
   └─ 预读页面被提前淘汰
```

**♻️ 废料处理机制**：
```
InnoDB废料处理策略：

LRU链表管理：
├─ 预读页面初始放在LRU链表中间位置
├─ 如果很快被访问 → 移动到热点区域
├─ 如果长时间未被访问 → 优先淘汰
└─ 避免预读页面污染热点数据

自适应调整：
├─ 监控预读废料率
├─ 动态调整预读激进程度  
├─ 学习访问模式特征
└─ 优化预读决策算法
```

---

## 6. 🧠 智能预读算法


### 6.1 预读模式识别


**🔍 访问模式分析引擎**：
```
MySQL智能预读的模式识别：

顺序模式检测：
├─ 连续页面访问检测
├─ 访问方向识别 (正向/反向)
├─ 访问速度预测
└─ 剩余数据量估算

区域热点检测：
├─ 同一区域内访问密度
├─ 访问时间窗口分析  
├─ 重复访问模式识别
└─ 区域价值评估

查询类型识别：
├─ 范围扫描 → 激进线性预读
├─ 点查询 → 保守预读
├─ 聚合查询 → 区域预读
└─ 连接查询 → 多表协调预读
```

### 6.2 预读深度调整


**📏 动态预读深度算法**：
```
预读深度计算逻辑：

基础预读深度 = min(区域剩余页数, 配置的最大预读页数)

调整因素：
├─ 历史命中率：命中率高 → 增加深度
├─ 内存压力：空闲内存多 → 增加深度  
├─ IO负载：磁盘闲置 → 增加深度
├─ 查询特征：大范围扫描 → 增加深度
└─ 并发情况：高并发 → 减少深度

最终预读深度 = 基础深度 × 调整系数
```

**⚡ 自适应预读参数**：
```sql
-- MySQL 8.0+ 的自适应预读特性

-- 查看自适应预读状态
SELECT 
  $$innodb_adaptive_hash_index as '自适应哈希索引',
  $$innodb_read_ahead_threshold as '当前预读阈值';

-- 自适应调整会考虑：
-- 1. 当前Buffer Pool使用率
-- 2. 最近的查询访问模式  
-- 3. 系统IO负载情况
-- 4. 内存分配压力
```

### 6.3 预读决策模型


**🎯 机器学习辅助的预读决策**：
```
现代预读决策框架：

特征提取：
├─ 页面访问序列特征
├─ 时间窗口内的访问密度
├─ 查询执行计划特征  
├─ 表和索引的统计信息
└─ 历史预读效果反馈

决策模型：
├─ 是否触发预读？(分类问题)
├─ 预读多少页面？(回归问题)  
├─ 预读哪些页面？(推荐问题)
└─ 何时停止预读？(强化学习)

效果反馈：
├─ 预读页面的实际使用情况
├─ 对查询性能的实际提升
├─ 对内存使用的影响
└─ 反馈到决策模型进行学习
```

---

## 7. 🚀 预读机制优化策略


### 7.1 基于工作负载的优化


**📊 不同场景的优化策略**：

```sql
-- OLTP优化配置：点查询为主
SET GLOBAL innodb_read_ahead_threshold = 64;    -- 保守预读
SET GLOBAL innodb_random_read_ahead = OFF;      -- 关闭随机预读
SET GLOBAL innodb_buffer_pool_instances = 8;    -- 减少锁竞争

-- OLAP优化配置：分析查询为主  
SET GLOBAL innodb_read_ahead_threshold = 16;    -- 激进预读
SET GLOBAL innodb_random_read_ahead = ON;       -- 启用随机预读
SET GLOBAL innodb_buffer_pool_size = '75%';     -- 增大Buffer Pool

-- 混合负载优化配置
SET GLOBAL innodb_read_ahead_threshold = 32;    -- 平衡设置
SET GLOBAL innodb_random_read_ahead = OFF;      -- 谨慎使用
-- 根据时间段动态调整参数
```

### 7.2 预读资源管理


**💾 内存资源优化**：
```
Buffer Pool分区管理：

热点数据区：
├─ 50%的空间给频繁访问的页面
├─ 优先级最高，不易被淘汰
└─ 包括索引页面和热点数据页

预读缓冲区：  
├─ 30%的空间给预读页面
├─ 中等优先级，根据使用情况调整
└─ 未使用的预读页面优先淘汰

冷数据区：
├─ 20%的空间给偶尔访问的页面  
├─ 最低优先级，容易被淘汰
└─ 为新数据让出空间
```

**🔄 IO资源协调**：
```
预读IO调度策略：

IO优先级管理：
├─ 用户查询IO：最高优先级
├─ 预读IO：中等优先级，后台执行
├─ 刷脏页IO：根据检查点压力调整
└─ 避免预读IO影响关键业务

IO带宽控制：
├─ 预读占用IO带宽不超过30%
├─ 高峰期自动降低预读强度
├─ 监控磁盘队列深度
└─ 动态调整预读并发度
```

### 7.3 预读质量评估


**📈 预读效果评估体系**：
```sql
-- 创建预读效果监控视图
CREATE VIEW prefetch_performance AS
SELECT 
  -- 预读基础指标
  ROUND(bp_read_ahead / (bp_read_requests + bp_read_ahead) * 100, 2) as '预读比例%',
  ROUND((bp_read_ahead - bp_read_ahead_evicted) / bp_read_ahead * 100, 2) as '预读命中率%',
  
  -- 性能影响指标
  ROUND(bp_hit_rate, 2) as 'Buffer Pool命中率%',
  ROUND(avg_read_time, 2) as '平均读取时间ms'
  
FROM (
  SELECT 
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead') as bp_read_ahead,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead_evicted') as bp_read_ahead_evicted,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') as bp_read_requests,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') as bp_reads,
    -- 计算命中率和读取时间
    (1 - (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') / 
         (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')) * 100 as bp_hit_rate,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_data_read_time') / 
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_data_reads') as avg_read_time
) t;
```

**🎯 优化决策矩阵**：
```
预读优化决策表：

┌─────────────┬─────────────┬─────────────┬─────────────┐
│   预读命中率  │  系统负载   │  内存使用   │   优化建议   │
├─────────────┼─────────────┼─────────────┼─────────────┤
│    >90%     │     低      │     充足    │ 增加预读深度  │
│    >90%     │     高      │     紧张    │ 保持现状     │
│   70%-90%   │     低      │     充足    │ 微调阈值     │
│   70%-90%   │     高      │     紧张    │ 减少预读     │
│    <70%     │     任意    │     任意    │ 禁用或重构   │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 预读本质：提前加载可能需要的数据页，减少磁盘IO等待
🔸 预读类型：线性预读(顺序访问)和随机预读(区域访问)
🔸 核心参数：innodb_read_ahead_threshold 控制触发阈值
🔸 效果评估：通过预读命中率判断策略是否有效
🔸 资源管理：平衡预读收益与内存/IO开销
```

### 8.2 关键理解要点


**🔹 预读的价值与风险**
```
价值：
├─ 显著减少磁盘IO次数
├─ 提升范围查询和扫描性能
├─ 改善用户查询响应体验
└─ 充分利用磁盘的顺序读性能

风险：
├─ 预读错误的页面浪费内存
├─ 挤出真正需要的热点数据  
├─ 增加不必要的磁盘IO负载
└─ 在高并发下加重系统压力
```

**🔹 参数调优的核心思路**
```
调优原则：
├─ 根据工作负载特征选择策略
├─ 监控预读效果持续优化
├─ 平衡性能提升与资源消耗
└─ 避免过度优化影响稳定性

OLTP场景：保守预读，避免内存污染
OLAP场景：激进预读，最大化IO效率
混合场景：动态调整，根据时段优化
```

**🔹 预读机制的发展趋势**
```
传统预读：基于简单的访问模式检测
智能预读：结合机器学习的自适应算法
未来趋势：
├─ 更精准的访问模式预测
├─ 更细粒度的资源控制
├─ 与SSD特性更好的结合
└─ 云环境下的分布式预读
```

### 8.3 实际应用指导


**💡 最佳实践建议**：
```sql
-- 1. 定期监控预读效果
-- 建议每周检查一次预读统计

-- 2. 根据业务特点调整参数  
-- 数据仓库：innodb_read_ahead_threshold = 16-32
-- 在线交易：innodb_read_ahead_threshold = 56-64

-- 3. 配合其他优化策略
-- 合理设计索引减少扫描范围
-- 优化查询语句减少不必要的访问
-- 配置足够的Buffer Pool大小

-- 4. 注意监控关键指标
-- Buffer Pool命中率不应因预读而显著下降  
-- 预读命中率应该保持在70%以上
-- 系统整体响应时间应该有改善
```

**🚀 性能优化检查清单**：
- ✅ 是否根据工作负载特征配置了合适的预读参数？
- ✅ 是否定期监控预读命中率和废料率？
- ✅ 是否在业务高峰期观察了预读对系统的影响？
- ✅ 是否结合了应用层的优化策略？
- ✅ 是否考虑了硬件特性(SSD vs HDD)的影响？

**核心记忆**：
- 预读机制通过预测访问模式提前加载数据，是Buffer Pool的重要优化特性
- 线性预读适合顺序访问，随机预读适合区域访问，需要根据场景选择
- 参数调优的关键是平衡预读收益与资源开销，持续监控效果是必要的
- 预读不是万能的，需要与索引设计、查询优化等策略配合使用