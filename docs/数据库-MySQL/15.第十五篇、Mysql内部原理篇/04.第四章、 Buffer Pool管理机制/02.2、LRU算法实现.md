---
title: 2、LRU算法实现
---
## 📚 目录

1. [LRU算法基础概念](#1-LRU算法基础概念)
2. [MySQL改进LRU算法](#2-MySQL改进LRU算法)
3. [冷热数据分离机制](#3-冷热数据分离机制)
4. [预读页处理策略](#4-预读页处理策略)
5. [全表扫描优化](#5-全表扫描优化)
6. [LRU链表维护机制](#6-LRU链表维护机制)
7. [并发LRU维护](#7-并发LRU维护)
8. [性能监控与调优](#8-性能监控与调优)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 LRU算法基础概念


### 1.1 什么是LRU算法


**LRU（Least Recently Used）**：最近最少使用算法，是一种缓存淘汰策略。

```
基本思想：
如果数据最近被访问过，那么将来被访问的几率也更高
反之，最久没有被访问的数据，将来被访问几率最低

生活类比：
┌─ 书桌整理类比 ─────────────┐
│ • 经常用的书放在手边        │
│ • 很久不用的书放到书架最高层 │
│ • 桌面空间不够时，先收拾最久 │
│   没用的书                │
└────────────────────────────┘
```

### 1.2 传统LRU的工作原理


**基本操作流程**：
```
数据访问时：
1. 如果数据在缓存中 → 移动到链表头部
2. 如果数据不在缓存中：
   - 缓存未满 → 直接插入到头部
   - 缓存已满 → 删除尾部节点，插入新数据到头部

链表状态变化：
访问前：A ←→ B ←→ C ←→ D (D是最久未使用)
访问C后：C ←→ A ←→ B ←→ D
插入E：E ←→ C ←→ A ←→ B (D被淘汰)
```

### 1.3 传统LRU的局限性


**🔴 主要问题**：
```
问题1：预读失效
• 预读的页面可能不会被真正使用
• 但会占据热点数据的位置

问题2：全表扫描污染
• 大表扫描会把所有热点数据挤出缓存
• 扫描完成后，这些数据又不再需要

问题3：访问模式单一
• 不能区分偶然访问和真正的热点数据
• 一次访问就移到最前面，可能过于激进
```

---

## 2. ⚡ MySQL改进LRU算法


### 2.1 MySQL LRU的核心改进


**🔸 主要改进点**：
- **分区域管理**：将LRU链表分为新子链表和老子链表
- **访问频率考虑**：不是一次访问就提升，需要多次访问
- **时间窗口控制**：在特定时间内的访问才算有效

```
改进LRU结构图：
┌─────────────────────────────────────────┐
│               Buffer Pool                │
├─────────────────┬───────────────────────┤
│   新子链表(5/8)   │    老子链表(3/8)      │
│                │                      │
│  [最新访问的页]   │   [准备淘汰的页]      │
│     ↓          │         ↓            │
│  页A → 页B → ... │   页X → 页Y → 页Z     │
│                │                      │
│  热点数据区域    │    冷数据区域         │
└─────────────────┴───────────────────────┘
```

### 2.2 分区域的设计思想


**🎯 设计理念**：
```
新子链表（Hot区域）：
• 存放真正的热点数据
• 占总容量的5/8（约62.5%）
• 访问频繁，不轻易淘汰

老子链表（Cold区域）：
• 存放新读入或冷数据
• 占总容量的3/8（约37.5%）
• 包含预读页、扫描页等

好处分析：
✅ 保护热点数据不被挤出
✅ 新数据需要"证明"自己才能进入热区
✅ 预读失效和扫描污染得到控制
```

---

## 3. 🔥 冷热数据分离机制


### 3.3 冷热分离的实现细节


**页面状态转换**：
```
页面生命周期：
1. 新页面读入 → 插入到老子链表头部
2. 在老子链表中被访问 → 检查时间间隔
3. 满足条件 → 移动到新子链表头部
4. 不满足条件 → 在老子链表中位置前移

状态转换图：
磁盘页面 → 老子链表头 → 老子链表中 → 新子链表头
    ↓         ↓           ↓          ↓
  加载页面   等待验证    时间验证    成为热点
```

### 3.4 热点页面识别算法


**🔸 识别条件**：
```sql
-- 页面从老子链表移到新子链表的条件
IF (当前时间 - 页面首次进入老子链表时间) > innodb_old_blocks_time
AND 页面在老子链表中被访问
THEN 移动到新子链表头部
```

**参数说明**：
- `innodb_old_blocks_time`：默认1000ms
- 这个时间窗口防止"一次性访问"污染热点区域

### 3.5 冷热分离的配置参数


| 参数名称 | 默认值 | 说明 | 调优建议 |
|---------|--------|------|----------|
| `innodb_old_blocks_pct` | **37** | 老子链表占比% | 根据访问模式调整 |
| `innodb_old_blocks_time` | **1000** | 时间窗口(ms) | OLTP设置小一些 |

**🔧 调优示例**：
```sql
-- OLTP场景：快速响应，降低时间窗口
SET GLOBAL innodb_old_blocks_time = 100;

-- OLAP场景：避免扫描污染，增加时间窗口
SET GLOBAL innodb_old_blocks_time = 5000;

-- 查看当前设置
SHOW VARIABLES LIKE 'innodb_old_blocks%';
```

---

## 4. 📖 预读页处理策略


### 4.1 什么是预读机制


**预读（Read-Ahead）**：数据库预测性地读取可能需要的页面到内存中。

```
预读类型：
┌─ 线性预读 ─────────────────┐
│ 连续访问多个页面时，预测后  │
│ 续页面也会被访问，提前读取  │
│ 例：访问页1,2,3 → 预读4,5,6 │
└────────────────────────────┘

┌─ 随机预读 ─────────────────┐
│ 一个区段内多个页面被访问，  │
│ 预读该区段的其他页面        │
│ 例：区段内13个页被访问      │
│ → 预读剩余3个页            │
└────────────────────────────┘
```

### 4.2 预读页的LRU处理


**🔸 预读页面的特殊处理**：
```
处理流程：
1. 预读页面直接放入老子链表头部
2. 如果真的被访问 → 按正常流程可能提升到新子链表
3. 如果一直不被访问 → 在老子链表中逐渐后移，最终被淘汰

好处分析：
✅ 预读成功 → 提高访问性能
✅ 预读失败 → 不会污染热点数据
✅ 自动调节 → 根据实际访问模式优化
```

### 4.3 预读参数配置


```sql
-- 控制线性预读
SET GLOBAL innodb_read_ahead_threshold = 56;  -- 默认56个页

-- 控制随机预读（通常禁用）
SET GLOBAL innodb_random_read_ahead = OFF;

-- 查看预读效果
SHOW ENGINE INNODB STATUS\G
-- 查看 "Pages read ahead" 和 "Evicted without access"
```

---

## 5. 🗂️ 全表扫描优化


### 5.1 全表扫描的挑战


**🔴 问题描述**：
```
传统LRU的问题：
假设Buffer Pool大小为100页，热点数据50页

全表扫描1000页的表：
第1页扫描 → 老热点数据开始被挤出
第100页扫描 → 所有热点数据被挤出
扫描结束 → 缓存中全是无用的扫描页面

结果：
❌ 热点数据全部丢失
❌ 扫描页面占据内存但不再使用
❌ 后续查询性能急剧下降
```

### 5.2 MySQL的扫描优化策略


**🔸 优化机制**：
```
策略1：扫描页面进入老子链表
• 大表扫描的页面只进入老子链表
• 不会直接影响新子链表的热点数据
• 扫描结束后，这些页面会被正常淘汰

策略2：扫描检测
• 数据库能识别大表扫描操作
• 自动调整页面插入策略
• 避免扫描污染问题

策略3：访问模式学习
• 记录表的访问模式
• 区分随机访问和顺序扫描
• 针对不同模式采用不同策略
```

### 5.3 扫描优化的实际效果


**前后对比**：
```
优化前：全表扫描影响
热点数据命中率：95% → 10%
扫描后查询响应时间：10ms → 100ms

优化后：改进LRU保护
热点数据命中率：95% → 90%
扫描后查询响应时间：10ms → 15ms

性能提升：
✅ 热点数据得到保护
✅ 扫描性能略有下降，但影响可控
✅ 整体系统性能更稳定
```

---

## 6. 🔗 LRU链表维护机制


### 6.1 链表结构设计


**🔸 双向链表实现**：
```c
// 简化的页面结构
struct buf_page_t {
    void* frame;              // 指向实际数据页
    buf_page_t* next;         // 下一个页面
    buf_page_t* prev;         // 前一个页面
    time_t access_time;       // 最后访问时间
    time_t first_access_time; // 首次访问时间
    bool in_old_blocks;       // 是否在老子链表中
};

// LRU链表头尾指针
struct lru_list_t {
    buf_page_t* lru_head;     // 最新访问的页面
    buf_page_t* lru_tail;     // 最久未访问的页面
    buf_page_t* old_head;     // 老子链表开始位置
    int total_pages;          // 总页面数
    int old_pages;            // 老子链表页面数
};
```

### 6.2 链表操作的核心算法


**🔸 页面访问操作**：
```
访问页面的处理流程：

IF 页面在新子链表中：
    IF 不在链表头部：
        移动到链表最前面
    ENDIF
    
ELSE IF 页面在老子链表中：
    IF (当前时间 - 首次进入老子链表时间) > 阈值：
        移动到新子链表头部
        调整老子链表和新子链表边界
    ELSE：
        在老子链表内前移
    ENDIF
ENDIF
```

### 6.3 淘汰页面的选择


**🔸 页面淘汰策略**：
```
淘汰优先级：
1. 优先从老子链表尾部淘汰
2. 检查页面是否为脏页
3. 脏页需要先写回磁盘
4. 清理页面直接释放

淘汰流程图：
需要空间 → 检查老子链表尾部 → 是否脏页？
    ↓            ↓                ↓
释放页面 ←─ 直接释放 ←─ 否      是
    ↓                           ↓
调整链表结构                写回磁盘 → 释放页面
```

---

## 7. 🚀 并发LRU维护


### 7.1 并发访问的挑战


**🔴 并发问题**：
```
问题1：多线程同时访问LRU链表
• 链表结构可能被破坏
• 页面可能丢失或重复
• 计数器不准确

问题2：性能瓶颈
• 频繁的链表操作需要加锁
• 锁竞争导致性能下降
• 热点页面访问变慢

问题3：死锁风险
• 多个锁的获取顺序不当
• 可能导致系统死锁
```

### 7.2 MySQL的并发解决方案


**🔸 分区锁设计**：
```
解决策略：
1. 多个LRU链表
   • 将Buffer Pool分成多个区域
   • 每个区域有独立的LRU链表
   • 减少锁竞争

2. 读写分离锁
   • 读操作使用共享锁
   • 写操作使用排他锁
   • 提高并发读取性能

3. 延迟更新
   • 不是每次访问都立即调整链表
   • 批量处理链表调整操作
   • 减少锁持有时间
```

### 7.3 性能优化技术


**🔸 具体优化措施**：
```sql
-- 查看Buffer Pool实例数量
SHOW VARIABLES LIKE 'innodb_buffer_pool_instances';

-- 通常设置为CPU核心数，最大64
SET GLOBAL innodb_buffer_pool_instances = 8;

-- 每个实例至少1GB
-- 总的Buffer Pool大小 = 实例数 × 实例大小
```

**性能监控**：
```sql
-- 查看LRU相关统计
SELECT * FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;

-- 关键指标：
-- FREE_BUFFERS: 空闲页面数
-- LRU_IO_TOTAL: LRU导致的IO总数
-- LRU_IO_CURRENT: 当前LRU的IO数
```

---

## 8. 📊 性能监控与调优


### 8.1 关键性能指标


**🔸 监控指标体系**：

| 指标类型 | 指标名称 | 理想值 | 说明 |
|---------|----------|--------|------|
| **命中率** | `Buffer Pool命中率` | **>99%** | 越高越好 |
| **IO指标** | `逻辑读/物理读比` | **>100:1** | 缓存效果 |
| **页面状态** | `脏页比例` | **<75%** | 写入压力 |
| **LRU效率** | `页面老化速度` | **稳定** | 淘汰是否合理 |

### 8.2 性能诊断SQL


```sql
-- 1. Buffer Pool整体状态
SELECT 
    POOL_ID,
    POOL_SIZE * 16 / 1024 as 'Pool Size(MB)',
    FREE_BUFFERS * 16 / 1024 as 'Free(MB)',
    (POOL_SIZE - FREE_BUFFERS) * 16 / 1024 as 'Used(MB)',
    ROUND(((POOL_SIZE - FREE_BUFFERS) / POOL_SIZE) * 100, 2) as 'Used%'
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;

-- 2. LRU算法效果
SELECT 
    'LRU_IO' as Metric,
    LRU_IO_TOTAL as Total,
    LRU_IO_CURRENT as Current
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS
UNION ALL
SELECT 
    'Hit_Rate',
    ROUND((1 - (READS / READ_REQUESTS)) * 100, 2),
    NULL
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS
WHERE READ_REQUESTS > 0;

-- 3. 页面年龄分布
SELECT 
    OLD_DATABASE_PAGES,
    YOUNG_DATABASE_PAGES,
    ROUND(OLD_DATABASE_PAGES / (OLD_DATABASE_PAGES + YOUNG_DATABASE_PAGES) * 100, 2) as 'Old%'
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;
```

### 8.3 调优实战案例


**🎯 案例：OLTP系统优化**
```
问题现象：
• Buffer Pool命中率只有85%
• 响应时间波动大
• 存在大量短连接查询

诊断分析：
1. 老子链表比例过大(默认37%)
2. 时间窗口设置过长(1000ms)
3. 短连接导致频繁的冷数据访问

优化方案：
-- 降低老子链表比例
SET GLOBAL innodb_old_blocks_pct = 25;

-- 缩短时间窗口
SET GLOBAL innodb_old_blocks_time = 100;

-- 增加Buffer Pool大小
SET GLOBAL innodb_buffer_pool_size = 8G;

优化结果：
✅ 命中率提升到98%
✅ 响应时间稳定在5ms以内
✅ 系统整体吞吐量提升30%
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 改进LRU算法：MySQL将LRU链表分为新老两个区域
🔸 冷热数据分离：通过时间窗口机制识别真正的热点数据
🔸 预读页处理：预读页面放入老子链表，避免污染热点区域
🔸 全表扫描优化：扫描页面不会挤出热点数据
🔸 并发维护机制：通过分区锁和延迟更新提高并发性能
```

### 9.2 关键理解要点


**🔹 为什么要改进传统LRU**
```
传统LRU问题：
• 预读失效会占据热点位置
• 全表扫描会污染整个缓存
• 一次访问就提升可能过于激进

MySQL改进效果：
• 保护真正的热点数据
• 新数据需要"证明"价值才能进入热区
• 更好地适应数据库的访问模式
```

**🔹 如何理解冷热分离**
```
设计思想：
• 新子链表(5/8)：存放证明了价值的热点数据
• 老子链表(3/8)：存放新数据和冷数据
• 时间窗口：防止一次性访问污染热区

实际效果：
• 热点数据更稳定地保持在内存中
• 预读和扫描的负面影响大大降低
• 整体缓存命中率显著提升
```

### 9.3 实际应用价值


**🎯 DBA日常工作**
- **性能调优**：根据访问模式调整LRU参数
- **问题诊断**：通过LRU指标定位性能瓶颈
- **容量规划**：评估Buffer Pool大小需求

**🎯 开发最佳实践**
- **避免大表扫描**：理解LRU机制，优化查询
- **合理使用索引**：减少不必要的页面访问
- **监控缓存效果**：关注命中率和页面老化

**核心记忆口诀**：
```
🧠 LRU改进巧分离，新老链表有玄机
   热点数据需证明，时间窗口把关严
   预读扫描不污染，并发维护性能佳
```