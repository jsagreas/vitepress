---
title: 6ã€æ‰§è¡Œå™¨æºç è§£è¯»
---
## ğŸ“š ç›®å½•


1. [æ‰§è¡Œå™¨æ¶æ„è®¾è®¡](#1-æ‰§è¡Œå™¨æ¶æ„è®¾è®¡)
2. [Iteratorè¿­ä»£å™¨æ¨¡å¼](#2-Iteratorè¿­ä»£å™¨æ¨¡å¼)
3. [æ‰§è¡Œè®¡åˆ’æ ‘éå†](#3-æ‰§è¡Œè®¡åˆ’æ ‘éå†)
4. [ç«å±±æ¨¡å‹å®ç°](#4-ç«å±±æ¨¡å‹å®ç°)
5. [å‘é‡åŒ–æ‰§è¡Œä¼˜åŒ–](#5-å‘é‡åŒ–æ‰§è¡Œä¼˜åŒ–)
6. [å†…å­˜ç®¡ç†æœºåˆ¶](#6-å†…å­˜ç®¡ç†æœºåˆ¶)
7. [æ‰§è¡Œå™¨çŠ¶æ€ç®¡ç†](#7-æ‰§è¡Œå™¨çŠ¶æ€ç®¡ç†)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

# 1. ğŸ—ï¸ æ‰§è¡Œå™¨æ¶æ„è®¾è®¡



## 1.1 æ‰§è¡Œå™¨çš„ä½œç”¨



**ğŸ”¸ æ‰§è¡Œå™¨æ˜¯ä»€ä¹ˆ**
æ‰§è¡Œå™¨ï¼ˆExecutorï¼‰æ˜¯MySQLçš„"æ‰§è¡Œå¼•æ“"ï¼Œå°±åƒæ±½è½¦çš„å‘åŠ¨æœºä¸€æ ·ã€‚å½“ä¼˜åŒ–å™¨åˆ¶å®šå¥½æ‰§è¡Œè®¡åˆ’åï¼Œæ‰§è¡Œå™¨è´Ÿè´£çœŸæ­£åœ°æ‰§è¡ŒSQLè¯­å¥ï¼Œè·å–æ•°æ®å¹¶è¿”å›ç»“æœã€‚

```
SQLæŸ¥è¯¢æ‰§è¡Œæµç¨‹ï¼š
è§£æå™¨ â†’ ä¼˜åŒ–å™¨ â†’ æ‰§è¡Œå™¨ â†’ å­˜å‚¨å¼•æ“
  â†“        â†“        â†“        â†“
è¯­æ³•åˆ†æ  æ‰§è¡Œè®¡åˆ’  çœŸæ­£æ‰§è¡Œ  æ•°æ®è¯»å†™
```

**ğŸ”¸ ä¸ºä»€ä¹ˆéœ€è¦æ‰§è¡Œå™¨**
- **è®¡åˆ’è½¬æ¢**ï¼šæŠŠæŠ½è±¡çš„æ‰§è¡Œè®¡åˆ’å˜æˆå…·ä½“çš„æ“ä½œæ­¥éª¤
- **æ•°æ®å¤„ç†**ï¼šåè°ƒå„ä¸ªå­˜å‚¨å¼•æ“ï¼Œå¤„ç†è¡¨è¿æ¥ã€æ’åºç­‰æ“ä½œ
- **ç»“æœç»„è£…**ï¼šæŠŠä»ä¸åŒè¡¨è·å–çš„æ•°æ®ç»„åˆæˆæœ€ç»ˆç»“æœ

## 1.2 æ‰§è¡Œå™¨æ ¸å¿ƒæ¶æ„



**ğŸ”¸ æ•´ä½“æ¶æ„å›¾**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ‰§è¡Œå™¨å±‚                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æ‰§è¡Œè®¡åˆ’æ ‘     â”‚    Iteratorè¿­ä»£å™¨      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚Sort   â”‚     â”‚    â”‚TableScan    â”‚   â”‚
â”‚   â”‚   â†“   â”‚     â”‚    â”‚IndexScan    â”‚   â”‚
â”‚   â”‚ Join  â”‚     â”‚    â”‚NestedLoop   â”‚   â”‚
â”‚   â”‚   â†“   â”‚     â”‚    â”‚HashJoin     â”‚   â”‚
â”‚   â”‚ Scan  â”‚     â”‚    â”‚Aggregate    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           å†…å­˜æ±  & èµ„æºç®¡ç†              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            å­˜å‚¨å¼•æ“æ¥å£                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ”¸ æ ¸å¿ƒç»„ä»¶è¯´æ˜**
- **æ‰§è¡Œè®¡åˆ’æ ‘**ï¼šæŠŠSQLè½¬æ¢æˆæ ‘å½¢çš„æ“ä½œæ­¥éª¤
- **Iteratorè¿­ä»£å™¨**ï¼šæ¯ä¸ªæ“ä½œæ­¥éª¤çš„å…·ä½“å®ç°
- **å†…å­˜æ± **ï¼šç®¡ç†æ‰§è¡Œè¿‡ç¨‹ä¸­çš„å†…å­˜åˆ†é…
- **èµ„æºè°ƒåº¦å™¨**ï¼šæ§åˆ¶CPUã€å†…å­˜ç­‰èµ„æºä½¿ç”¨

## 1.3 æ‰§è¡Œå™¨è®¾è®¡åŸåˆ™



**ğŸ”¸ æ¨¡å—åŒ–è®¾è®¡**
```cpp
// æ‰§è¡Œå™¨åŸºç±»
class Executor {
public:
    virtual bool Init() = 0;        // åˆå§‹åŒ–
    virtual bool Next() = 0;        // è·å–ä¸‹ä¸€è¡Œ
    virtual void Close() = 0;       // æ¸…ç†èµ„æº
};

// å…·ä½“å®ç°ç±»
class TableScanExecutor : public Executor {
    // è¡¨æ‰«æå…·ä½“å®ç°
};
```

> ğŸ’¡ **è®¾è®¡æ€æƒ³**  
> æ¯ä¸ªæ“ä½œéƒ½æ˜¯ç‹¬ç«‹çš„æ¨¡å—ï¼Œå¯ä»¥åƒæ­ç§¯æœ¨ä¸€æ ·ç»„åˆæˆå¤æ‚çš„æŸ¥è¯¢æ‰§è¡Œæµç¨‹

---

# 2. ğŸ”„ Iteratorè¿­ä»£å™¨æ¨¡å¼



## 2.1 è¿­ä»£å™¨æ¨¡å¼çš„æ ¸å¿ƒæ¦‚å¿µ



**ğŸ”¸ ä»€ä¹ˆæ˜¯è¿­ä»£å™¨æ¨¡å¼**
è¿­ä»£å™¨æ¨¡å¼å°±åƒ"æµæ°´çº¿å·¥äºº"ï¼Œæ¯ä¸ªå·¥äººè´Ÿè´£ä¸€ä¸ªå…·ä½“ä»»åŠ¡ï¼Œæ•°æ®ä¸€è¡Œä¸€è¡Œåœ°åœ¨å·¥äººä¹‹é—´ä¼ é€’å¤„ç†ã€‚

```
æ•°æ®æµåŠ¨ç¤ºä¾‹ï¼š
åŸå§‹æ•°æ® â†’ [è¿‡æ»¤å™¨] â†’ [æ’åºå™¨] â†’ [èšåˆå™¨] â†’ æœ€ç»ˆç»“æœ
    â†“         â†“         â†“         â†“
  1000è¡Œ     800è¡Œ     800è¡Œ     10è¡Œ
```

**ğŸ”¸ è¿­ä»£å™¨çš„ç»Ÿä¸€æ¥å£**
```cpp
class Iterator {
public:
    // åˆå§‹åŒ–è¿­ä»£å™¨
    virtual bool Init() = 0;
    
    // è·å–ä¸‹ä¸€è¡Œæ•°æ®ï¼Œè¿”å›falseè¡¨ç¤ºæ²¡æœ‰æ›´å¤šæ•°æ®
    virtual bool Read() = 0;
    
    // è·å–å½“å‰è¡Œçš„æ•°æ®
    virtual Row* GetCurrentRow() = 0;
    
    // æ¸…ç†èµ„æº
    virtual void Close() = 0;
};
```

## 2.2 å¸¸è§è¿­ä»£å™¨ç±»å‹



**ğŸ”¸ è¡¨æ‰«æè¿­ä»£å™¨ï¼ˆTableScanIteratorï¼‰**
```cpp
class TableScanIterator : public Iterator {
private:
    Table* table_;           // è¦æ‰«æçš„è¡¨
    RowIterator* row_iter_;  // è¡Œéå†å™¨
    
public:
    bool Read() override {
        // ä»å­˜å‚¨å¼•æ“è¯»å–ä¸‹ä¸€è¡Œ
        return table_->ReadNextRow(&current_row_);
    }
};
```

**ğŸ”¸ ç´¢å¼•æ‰«æè¿­ä»£å™¨ï¼ˆIndexScanIteratorï¼‰**
```cpp
class IndexScanIterator : public Iterator {
private:
    Index* index_;           // è¦ä½¿ç”¨çš„ç´¢å¼•
    Key start_key_;          // æ‰«æèµ·å§‹é”®å€¼
    Key end_key_;            // æ‰«æç»“æŸé”®å€¼
    
public:
    bool Read() override {
        // é€šè¿‡ç´¢å¼•æŸ¥æ‰¾ä¸‹ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„è¡Œ
        return index_->SeekNext(&current_row_);
    }
};
```

## 2.3 è¿­ä»£å™¨ç»„åˆç¤ºä¾‹



**ğŸ”¸ å¤æ‚æŸ¥è¯¢çš„è¿­ä»£å™¨ç»„åˆ**
```sql
SELECT name, COUNT(*) 
FROM users 
WHERE age > 18 
GROUP BY department
```

```
è¿­ä»£å™¨ç»„åˆï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AggregateIter   â”‚ â† æŒ‰departmentåˆ†ç»„ç»Ÿè®¡
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FilterIter      â”‚ â† è¿‡æ»¤age > 18
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚ TableScanIter   â”‚ â† æ‰«æusersè¡¨
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> ğŸ¯ **æ‰§è¡Œè¿‡ç¨‹**  
> 1. TableScanIterè¯»å–usersè¡¨çš„æ¯ä¸€è¡Œ
> 2. FilterIterè¿‡æ»¤æ‰age <= 18çš„è¡Œ
> 3. AggregateIteræŒ‰departmentåˆ†ç»„å¹¶è®¡æ•°

---

# 3. ğŸŒ³ æ‰§è¡Œè®¡åˆ’æ ‘éå†



## 3.1 æ‰§è¡Œè®¡åˆ’æ ‘çš„ç»“æ„



**ğŸ”¸ ä»€ä¹ˆæ˜¯æ‰§è¡Œè®¡åˆ’æ ‘**
æ‰§è¡Œè®¡åˆ’æ ‘å°±åƒä¸€ä¸ª"ä»»åŠ¡åˆ†è§£å›¾"ï¼ŒæŠŠå¤æ‚çš„SQLæŸ¥è¯¢åˆ†è§£æˆä¸€ä¸ªä¸ªå°ä»»åŠ¡ï¼Œç„¶åæŒ‰æ ‘å½¢ç»“æ„ç»„ç»‡èµ·æ¥ã€‚

```
ç¤ºä¾‹SQLï¼š
SELECT u.name, d.dept_name 
FROM users u JOIN departments d ON u.dept_id = d.id 
WHERE u.age > 25

æ‰§è¡Œè®¡åˆ’æ ‘ï¼š
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Join   â”‚ â† è¿æ¥æ“ä½œ
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         /       \
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚Filter â”‚   â”‚TableScan â”‚ â† å·¦å­æ ‘ï¼šè¿‡æ»¤users
    â”‚age>25 â”‚   â”‚departmentsâ”‚ â† å³å­æ ‘ï¼šæ‰«ædepartments
    â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚TableScan â”‚ â† æ‰«æusersè¡¨
   â”‚  users   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 3.2 æ ‘éå†ç®—æ³•



**ğŸ”¸ ç«å±±æ¨¡å‹éå†ï¼ˆæŒ‰éœ€æ‰§è¡Œï¼‰**
```cpp
class ExecutionTree {
public:
    bool Execute() {
        // ä»æ ¹èŠ‚ç‚¹å¼€å§‹æ‰§è¡Œ
        while (root_iterator_->Read()) {
            // å¤„ç†å½“å‰è¡Œæ•°æ®
            ProcessCurrentRow();
        }
        return true;
    }
    
private:
    Iterator* root_iterator_;  // æ ¹èŠ‚ç‚¹è¿­ä»£å™¨
};
```

**ğŸ”¸ éå†æ‰§è¡Œæµç¨‹**
```
æ‰§è¡Œé¡ºåºï¼ˆä»æ ¹å‘å¶å­æŒ‰éœ€æ‹‰å–ï¼‰ï¼š
1. JoinèŠ‚ç‚¹è°ƒç”¨Read()
2. Joinéœ€è¦æ•°æ®ï¼Œå‘å·¦å­æ ‘Filterè¯·æ±‚
3. Filteréœ€è¦æ•°æ®ï¼Œå‘TableScan(users)è¯·æ±‚
4. TableScanè¿”å›ä¸€è¡Œæ•°æ®ç»™Filter
5. Filteræ£€æŸ¥æ¡ä»¶ï¼Œç¬¦åˆåˆ™è¿”å›ç»™Join
6. Joinæ‹¿åˆ°å·¦ä¾§æ•°æ®ï¼Œå‘å³å­æ ‘è¯·æ±‚æ•°æ®
7. é‡å¤æ­¤è¿‡ç¨‹ç›´åˆ°æ‰€æœ‰æ•°æ®å¤„ç†å®Œæˆ
```

## 3.3 ä¸´æ—¶è¡¨åˆ›å»ºé”€æ¯



**ğŸ”¸ ä»€ä¹ˆæ—¶å€™éœ€è¦ä¸´æ—¶è¡¨**
```sql
-- éœ€è¦ä¸´æ—¶è¡¨çš„æƒ…å†µï¼š
SELECT dept_id, COUNT(*) 
FROM users 
GROUP BY dept_id 
HAVING COUNT(*) > 10
ORDER BY COUNT(*) DESC
```

**ğŸ”¸ ä¸´æ—¶è¡¨ç®¡ç†æœºåˆ¶**
```cpp
class TempTableManager {
public:
    // åˆ›å»ºä¸´æ—¶è¡¨
    TempTable* CreateTempTable(const TableSchema& schema) {
        auto temp_table = new TempTable(schema);
        temp_tables_.push_back(temp_table);
        return temp_table;
    }
    
    // æŸ¥è¯¢ç»“æŸæ—¶è‡ªåŠ¨æ¸…ç†æ‰€æœ‰ä¸´æ—¶è¡¨
    ~TempTableManager() {
        for (auto table : temp_tables_) {
            delete table;  // é‡Šæ”¾å†…å­˜å’Œç£ç›˜ç©ºé—´
        }
    }
    
private:
    std::vector<TempTable*> temp_tables_;
};
```

> âš ï¸ **ä¸´æ—¶è¡¨æ³¨æ„äº‹é¡¹**  
> ä¸´æ—¶è¡¨ä¼šå ç”¨å¤§é‡å†…å­˜ï¼ŒMySQLä¼šæ ¹æ®æ•°æ®é‡è‡ªåŠ¨é€‰æ‹©å†…å­˜ä¸´æ—¶è¡¨æˆ–ç£ç›˜ä¸´æ—¶è¡¨

---

# 4. ğŸŒ‹ ç«å±±æ¨¡å‹å®ç°



## 4.1 ç«å±±æ¨¡å‹çš„åŸºæœ¬æ¦‚å¿µ



**ğŸ”¸ ç«å±±æ¨¡å‹æ˜¯ä»€ä¹ˆ**
ç«å±±æ¨¡å‹åƒ"æŒ‰éœ€ç”Ÿäº§"çš„å·¥å‚ï¼Œä¸Šæ¸¸éœ€è¦æ•°æ®æ—¶æ‰ä»ä¸‹æ¸¸æ‹‰å–ï¼Œé¿å…ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰æ•°æ®åˆ°å†…å­˜ã€‚

```
ä¼ ç»Ÿæ¨¡å‹ vs ç«å±±æ¨¡å‹ï¼š

ä¼ ç»Ÿæ¨¡å‹ï¼ˆæ¨æ¨¡å¼ï¼‰ï¼š
TableScan â†’ [æ‰€æœ‰æ•°æ®] â†’ Filter â†’ [è¿‡æ»¤åæ•°æ®] â†’ Join

ç«å±±æ¨¡å‹ï¼ˆæ‹‰æ¨¡å¼ï¼‰ï¼š
Join.Next() â†’ Filter.Next() â†’ TableScan.Next() â†’ [ä¸€è¡Œæ•°æ®]
```

**ğŸ”¸ ç«å±±æ¨¡å‹çš„ä¼˜åŠ¿**
- **å†…å­˜å‹å¥½**ï¼šä¸€æ¬¡åªå¤„ç†ä¸€è¡Œï¼Œå†…å­˜å ç”¨ä½
- **æµå¼å¤„ç†**ï¼šå¯ä»¥ç«‹å³è¿”å›ç¬¬ä¸€æ¡ç»“æœ
- **ä¸­æ–­å‹å¥½**ï¼šå¯ä»¥éšæ—¶åœæ­¢ï¼Œä¸æµªè´¹èµ„æº

## 4.2 ç«å±±æ¨¡å‹å®ç°åŸç†



**ğŸ”¸ æ ¸å¿ƒæ¥å£è®¾è®¡**
```cpp
class VolcanoIterator {
public:
    // æ‰“å¼€è¿­ä»£å™¨ï¼Œè¿›è¡Œåˆå§‹åŒ–
    virtual Status Open() = 0;
    
    // è·å–ä¸‹ä¸€è¡Œï¼Œè¿”å›nullptrè¡¨ç¤ºç»“æŸ
    virtual Row* Next() = 0;
    
    // å…³é—­è¿­ä»£å™¨ï¼Œæ¸…ç†èµ„æº
    virtual void Close() = 0;
    
protected:
    std::vector<VolcanoIterator*> children_;  // å­è¿­ä»£å™¨
};
```

**ğŸ”¸ å…·ä½“å®ç°ç¤ºä¾‹**
```cpp
class HashJoinIterator : public VolcanoIterator {
private:
    VolcanoIterator* left_child_;   // å·¦è¡¨è¿­ä»£å™¨
    VolcanoIterator* right_child_;  // å³è¡¨è¿­ä»£å™¨
    HashMap hash_table_;            // è¿æ¥ç”¨çš„å“ˆå¸Œè¡¨
    
public:
    Status Open() override {
        // 1. æ‰“å¼€å­è¿­ä»£å™¨
        left_child_->Open();
        right_child_->Open();
        
        // 2. æ„å»ºå“ˆå¸Œè¡¨ï¼ˆä½¿ç”¨å³è¡¨ï¼‰
        Row* row;
        while ((row = right_child_->Next()) != nullptr) {
            hash_table_.Insert(row->GetJoinKey(), row);
        }
        return Status::OK;
    }
    
    Row* Next() override {
        Row* left_row;
        while ((left_row = left_child_->Next()) != nullptr) {
            // åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾åŒ¹é…çš„è¡Œ
            auto matches = hash_table_.Find(left_row->GetJoinKey());
            if (!matches.empty()) {
                return JoinRows(left_row, matches[0]);
            }
        }
        return nullptr;  // æ²¡æœ‰æ›´å¤šæ•°æ®
    }
};
```

## 4.3 ç®—å­fusionä¼˜åŒ–



**ğŸ”¸ ä»€ä¹ˆæ˜¯ç®—å­fusion**
ç®—å­fusionå°±æ˜¯æŠŠå¤šä¸ªç®€å•æ“ä½œ"åˆå¹¶"æˆä¸€ä¸ªå¤åˆæ“ä½œï¼Œå‡å°‘æ•°æ®åœ¨ä¸åŒæ“ä½œé—´çš„ä¼ é€’å¼€é”€ã€‚

```
ä¼˜åŒ–å‰ï¼š
TableScan â†’ Filter â†’ Project â†’ Sort

ä¼˜åŒ–åï¼š
TableScanWithFilterAndProject â†’ Sort
```

**ğŸ”¸ fusionå®ç°ç¤ºä¾‹**
```cpp
class FusedScanFilterIterator : public VolcanoIterator {
private:
    TableScanIterator* scan_iter_;
    FilterCondition filter_;
    ProjectionList projection_;
    
public:
    Row* Next() override {
        Row* row;
        while ((row = scan_iter_->Next()) != nullptr) {
            // åœ¨åŒä¸€ä¸ªå¾ªç¯ä¸­å®Œæˆæ‰«æã€è¿‡æ»¤ã€æŠ•å½±
            if (filter_.Evaluate(row)) {
                return projection_.Apply(row);  // åˆå¹¶æ“ä½œ
            }
        }
        return nullptr;
    }
};
```

> ğŸ’¡ **fusionçš„å¥½å¤„**  
> å‡å°‘ä¸´æ—¶å¯¹è±¡åˆ›å»ºï¼Œæå‡CPUç¼“å­˜å‘½ä¸­ç‡ï¼Œæ•´ä½“æ€§èƒ½æå‡20-30%

---

# 5. âš¡ å‘é‡åŒ–æ‰§è¡Œä¼˜åŒ–



## 5.1 å‘é‡åŒ–æ‰§è¡Œçš„æ¦‚å¿µ



**ğŸ”¸ å‘é‡åŒ–æ˜¯ä»€ä¹ˆ**
å‘é‡åŒ–æ‰§è¡Œå°±æ˜¯"æ‰¹é‡å¤„ç†"ï¼Œä¸€æ¬¡å¤„ç†å¤šè¡Œæ•°æ®è€Œä¸æ˜¯ä¸€è¡Œä¸€è¡Œå¤„ç†ï¼Œå°±åƒå·¥å‚æµæ°´çº¿æ‰¹é‡ç”Ÿäº§æ›´é«˜æ•ˆã€‚

```
ä¼ ç»Ÿæ‰§è¡Œï¼ˆä¸€è¡Œä¸€è¡Œï¼‰ï¼š
for (æ¯ä¸€è¡Œ) {
    if (age > 18) result.add(row);
}

å‘é‡åŒ–æ‰§è¡Œï¼ˆæ‰¹é‡å¤„ç†ï¼‰ï¼š
for (æ¯1000è¡Œä¸ºä¸€æ‰¹) {
    æ‰¹é‡æ£€æŸ¥age > 18çš„æ¡ä»¶;
    æ‰¹é‡æ·»åŠ ç¬¦åˆæ¡ä»¶çš„è¡Œ;
}
```

**ğŸ”¸ å‘é‡åŒ–çš„ä¼˜åŠ¿**
- **CPUæ•ˆç‡**ï¼šå‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€
- **å†…å­˜å±€éƒ¨æ€§**ï¼šæ‰¹é‡æ“ä½œæå‡ç¼“å­˜å‘½ä¸­
- **SIMDä¼˜åŒ–**ï¼šåˆ©ç”¨CPUçš„å¹¶è¡ŒæŒ‡ä»¤

## 5.2 å‘é‡åŒ–å®ç°æœºåˆ¶



**ğŸ”¸ å‘é‡åŒ–è¿­ä»£å™¨è®¾è®¡**
```cpp
class VectorizedIterator {
public:
    // æ‰¹é‡è·å–æ•°æ®ï¼Œè¿”å›å®é™…è·å–çš„è¡Œæ•°
    virtual size_t NextBatch(RowBatch* batch, size_t max_rows) = 0;
    
protected:
    static const size_t DEFAULT_BATCH_SIZE = 1024;
};

// è¡Œæ‰¹æ¬¡æ•°æ®ç»“æ„
struct RowBatch {
    std::vector<Row*> rows;      // è¡Œæ•°æ®
    std::vector<bool> validity;  // æœ‰æ•ˆæ€§æ ‡è®°
    size_t count;                // å®é™…è¡Œæ•°
};
```

**ğŸ”¸ å‘é‡åŒ–è¿‡æ»¤å™¨å®ç°**
```cpp
class VectorizedFilterIterator : public VectorizedIterator {
private:
    VectorizedIterator* child_;
    FilterExpression filter_;
    
public:
    size_t NextBatch(RowBatch* batch, size_t max_rows) override {
        // 1. ä»å­è¿­ä»£å™¨è·å–ä¸€æ‰¹æ•°æ®
        size_t input_count = child_->NextBatch(batch, max_rows);
        
        // 2. æ‰¹é‡è¯„ä¼°è¿‡æ»¤æ¡ä»¶
        std::vector<bool> filter_results(input_count);
        filter_.EvaluateBatch(batch->rows, filter_results);
        
        // 3. æ‰¹é‡å¤åˆ¶ç¬¦åˆæ¡ä»¶çš„è¡Œ
        size_t output_count = 0;
        for (size_t i = 0; i < input_count; i++) {
            if (filter_results[i]) {
                batch->rows[output_count++] = batch->rows[i];
            }
        }
        
        batch->count = output_count;
        return output_count;
    }
};
```

## 5.3 SIMDæŒ‡ä»¤ä¼˜åŒ–



**ğŸ”¸ SIMDæ˜¯ä»€ä¹ˆ**
SIMDï¼ˆSingle Instruction, Multiple Dataï¼‰å°±æ˜¯"ä¸€æ¡æŒ‡ä»¤å¤„ç†å¤šä¸ªæ•°æ®"ï¼ŒåƒåŒæ—¶æ“ä½œå¤šä¸ªè®¡ç®—å™¨ã€‚

```cpp
// ä¼ ç»Ÿæ–¹å¼ï¼šé€ä¸ªæ¯”è¾ƒ
bool traditional_filter(int* ages, bool* results, size_t count) {
    for (size_t i = 0; i < count; i++) {
        results[i] = (ages[i] > 18);  // ä¸€æ¬¡æ¯”è¾ƒä¸€ä¸ª
    }
}

// SIMDæ–¹å¼ï¼šæ‰¹é‡æ¯”è¾ƒ
bool simd_filter(int* ages, bool* results, size_t count) {
    __m256i threshold = _mm256_set1_epi32(18);  // è®¾ç½®æ¯”è¾ƒå€¼
    
    for (size_t i = 0; i < count; i += 8) {     // ä¸€æ¬¡å¤„ç†8ä¸ª
        __m256i values = _mm256_load_si256((__m256i*)(ages + i));
        __m256i mask = _mm256_cmpgt_epi32(values, threshold);
        _mm256_store_si256((__m256i*)(results + i), mask);
    }
}
```

> âš¡ **æ€§èƒ½æå‡**  
> SIMDä¼˜åŒ–å¯ä»¥è®©æ•°å€¼æ¯”è¾ƒæ“ä½œé€Ÿåº¦æå‡4-8å€

---

# 6. ğŸ’¾ å†…å­˜ç®¡ç†æœºåˆ¶



## 6.1 å†…å­˜æ± åˆ†é…å™¨



**ğŸ”¸ ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜æ± **
æ‰§è¡Œå™¨éœ€è¦é¢‘ç¹åˆ›å»ºå’Œé”€æ¯ä¸´æ—¶å¯¹è±¡ï¼Œä¼ ç»Ÿçš„malloc/freeæ•ˆç‡å¤ªä½ï¼Œå†…å­˜æ± å°±åƒ"å¯¹è±¡å›æ”¶ç«™"ï¼Œé‡å¤åˆ©ç”¨å†…å­˜å—ã€‚

```
ä¼ ç»Ÿå†…å­˜åˆ†é…ï¼š
new Row() â†’ malloc() â†’ ç³»ç»Ÿè°ƒç”¨ â†’ è¿”å›å†…å­˜åœ°å€
delete Row() â†’ free() â†’ ç³»ç»Ÿè°ƒç”¨ â†’ å›æ”¶å†…å­˜

å†…å­˜æ± åˆ†é…ï¼š
new Row() â†’ ä»æ± ä¸­å–ä¸€å— â†’ ç›´æ¥è¿”å›
delete Row() â†’ æ”¾å›æ± ä¸­ â†’ æ— ç³»ç»Ÿè°ƒç”¨
```

**ğŸ”¸ å†…å­˜æ± å®ç°**
```cpp
class MemoryPool {
private:
    struct Block {
        char* data;
        size_t size;
        Block* next;
    };
    
    Block* free_blocks_;     // ç©ºé—²å—é“¾è¡¨
    Block* used_blocks_;     // å·²ç”¨å—é“¾è¡¨
    size_t block_size_;      // å—å¤§å°
    
public:
    void* Allocate(size_t size) {
        if (size > block_size_) {
            // å¤§å¯¹è±¡ç›´æ¥åˆ†é…
            return malloc(size);
        }
        
        if (free_blocks_ == nullptr) {
            // æ²¡æœ‰ç©ºé—²å—ï¼Œåˆ†é…æ–°çš„
            AllocateNewChunk();
        }
        
        // ä»ç©ºé—²é“¾è¡¨å–ä¸€å—
        Block* block = free_blocks_;
        free_blocks_ = free_blocks_->next;
        block->next = used_blocks_;
        used_blocks_ = block;
        
        return block->data;
    }
    
    void Reset() {
        // æŸ¥è¯¢ç»“æŸæ—¶ï¼ŒæŠŠæ‰€æœ‰å·²ç”¨å—æ”¾å›ç©ºé—²é“¾è¡¨
        while (used_blocks_) {
            Block* block = used_blocks_;
            used_blocks_ = used_blocks_->next;
            block->next = free_blocks_;
            free_blocks_ = block;
        }
    }
};
```

## 6.2 èµ„æºè°ƒåº¦ä¸åˆ†é…å™¨



**ğŸ”¸ èµ„æºè°ƒåº¦å™¨çš„ä½œç”¨**
èµ„æºè°ƒåº¦å™¨å°±åƒ"å·¥å‚ç®¡ç†å‘˜"ï¼Œåˆç†åˆ†é…CPUã€å†…å­˜ç­‰èµ„æºï¼Œé˜²æ­¢æŸä¸ªæŸ¥è¯¢å ç”¨è¿‡å¤šèµ„æºå½±å“å…¶ä»–æŸ¥è¯¢ã€‚

```cpp
class ResourceScheduler {
private:
    size_t max_memory_;          // æœ€å¤§å†…å­˜é™åˆ¶
    size_t used_memory_;         // å·²ä½¿ç”¨å†…å­˜
    int max_threads_;            // æœ€å¤§çº¿ç¨‹æ•°
    int active_threads_;         // æ´»è·ƒçº¿ç¨‹æ•°
    
public:
    bool RequestMemory(size_t size) {
        if (used_memory_ + size > max_memory_) {
            return false;  // å†…å­˜ä¸è¶³
        }
        used_memory_ += size;
        return true;
    }
    
    void ReleaseMemory(size_t size) {
        used_memory_ -= size;
    }
    
    bool RequestThread() {
        if (active_threads_ >= max_threads_) {
            return false;  // çº¿ç¨‹ä¸è¶³
        }
        active_threads_++;
        return true;
    }
};
```

## 6.3 æ‰§è¡Œå™¨æ€§èƒ½è®¡æ•°å™¨



**ğŸ”¸ æ€§èƒ½ç›‘æ§çš„é‡è¦æ€§**
æ€§èƒ½è®¡æ•°å™¨å°±åƒ"æ±½è½¦ä»ªè¡¨ç›˜"ï¼Œå®æ—¶ç›‘æ§æ‰§è¡Œå™¨çš„è¿è¡ŒçŠ¶æ€ï¼Œå¸®åŠ©å‘ç°æ€§èƒ½ç“¶é¢ˆã€‚

```cpp
class ExecutorMetrics {
private:
    std::atomic<uint64_t> rows_processed_;    // å·²å¤„ç†è¡Œæ•°
    std::atomic<uint64_t> memory_allocated_;  // å·²åˆ†é…å†…å­˜
    std::atomic<uint64_t> cpu_time_ms_;       // CPUæ—¶é—´
    
public:
    void RecordRowsProcessed(uint64_t count) {
        rows_processed_ += count;
    }
    
    void RecordMemoryUsage(size_t bytes) {
        memory_allocated_ += bytes;
    }
    
    // è·å–æ€§èƒ½æŠ¥å‘Š
    std::string GetReport() {
        return StringFormat(
            "Rows: %lu, Memory: %lu MB, CPU: %lu ms",
            rows_processed_.load(),
            memory_allocated_.load() / (1024 * 1024),
            cpu_time_ms_.load()
        );
    }
};
```

---

# 7. ğŸ›ï¸ æ‰§è¡Œå™¨çŠ¶æ€ç®¡ç†



## 7.1 æ‰§è¡Œå™¨çŠ¶æ€æœºç®¡ç†



**ğŸ”¸ çŠ¶æ€æœºçš„ä½œç”¨**
æ‰§è¡Œå™¨çŠ¶æ€æœºå°±åƒ"å·¥ä½œæµç¨‹å›¾"ï¼Œç®¡ç†æŸ¥è¯¢æ‰§è¡Œçš„å„ä¸ªé˜¶æ®µï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µæŒ‰æ­£ç¡®é¡ºåºæ‰§è¡Œã€‚

```
æ‰§è¡Œå™¨çŠ¶æ€è½¬æ¢å›¾ï¼š
[CREATED] â”€â”€åˆå§‹åŒ–â”€â”€â–¶ [INITIALIZED] â”€â”€å¼€å§‹æ‰§è¡Œâ”€â”€â–¶ [RUNNING]
    â†‘                      â†“                         â†“
    â”‚                   [ERROR] â—€â”€â”€å‘ç”Ÿé”™è¯¯â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚                      â†“                         â†“
    â””â”€â”€â”€â”€â”€é‡ç½®â”€â”€â”€â”€â”€â”€â”€â”€â”€[FINISHED] â—€â”€â”€æ‰§è¡Œå®Œæˆâ”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ”¸ çŠ¶æ€æœºå®ç°**
```cpp
enum ExecutorState {
    CREATED,      // åˆšåˆ›å»º
    INITIALIZED,  // å·²åˆå§‹åŒ–
    RUNNING,      // æ­£åœ¨æ‰§è¡Œ
    FINISHED,     // æ‰§è¡Œå®Œæˆ
    ERROR         // å‘ç”Ÿé”™è¯¯
};

class StateMachine {
private:
    ExecutorState current_state_;
    std::string error_message_;
    
public:
    bool TransitionTo(ExecutorState new_state) {
        // æ£€æŸ¥çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
        if (!IsValidTransition(current_state_, new_state)) {
            return false;
        }
        
        current_state_ = new_state;
        return true;
    }
    
    bool IsValidTransition(ExecutorState from, ExecutorState to) {
        // å®šä¹‰åˆæ³•çš„çŠ¶æ€è½¬æ¢
        static const std::map<ExecutorState, std::vector<ExecutorState>> 
        valid_transitions = {
            {CREATED,     {INITIALIZED, ERROR}},
            {INITIALIZED, {RUNNING, ERROR}},
            {RUNNING,     {FINISHED, ERROR}},
            {FINISHED,    {CREATED}},  // å¯ä»¥é‡ç½®
            {ERROR,       {CREATED}}   // å¯ä»¥é‡ç½®
        };
        
        auto it = valid_transitions.find(from);
        if (it == valid_transitions.end()) return false;
        
        return std::find(it->second.begin(), it->second.end(), to) 
               != it->second.end();
    }
};
```

## 7.2 å¼‚å¸¸å›æ»šæœºåˆ¶



**ğŸ”¸ ä¸ºä»€ä¹ˆéœ€è¦å¼‚å¸¸å›æ»š**
å½“æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯æ—¶ï¼Œéœ€è¦æ¸…ç†å·²åˆ†é…çš„èµ„æºï¼Œå°±åƒ"æ’¤é”€æ“ä½œ"ä¸€æ ·æ¢å¤åˆ°å®‰å…¨çŠ¶æ€ã€‚

```cpp
class ExecutorTransaction {
private:
    std::vector<std::function<void()>> rollback_actions_;  // å›æ»šæ“ä½œåˆ—è¡¨
    
public:
    // æ³¨å†Œéœ€è¦å›æ»šçš„æ“ä½œ
    void RegisterRollbackAction(std::function<void()> action) {
        rollback_actions_.push_back(action);
    }
    
    // å‘ç”Ÿå¼‚å¸¸æ—¶æ‰§è¡Œå›æ»š
    void Rollback() {
        // æŒ‰ç›¸åé¡ºåºæ‰§è¡Œå›æ»šæ“ä½œ
        for (auto it = rollback_actions_.rbegin(); 
             it != rollback_actions_.rend(); ++it) {
            try {
                (*it)();  // æ‰§è¡Œå›æ»šæ“ä½œ
            } catch (...) {
                // å›æ»šæ“ä½œä¸èƒ½å¤±è´¥ï¼Œè®°å½•æ—¥å¿—ä½†ç»§ç»­
                LOG(ERROR) << "Rollback action failed";
            }
        }
        rollback_actions_.clear();
    }
};

// ä½¿ç”¨ç¤ºä¾‹
void ExecuteQuery() {
    ExecutorTransaction transaction;
    
    try {
        // åˆ†é…ä¸´æ—¶è¡¨
        auto temp_table = CreateTempTable();
        transaction.RegisterRollbackAction([temp_table]() {
            delete temp_table;  // å›æ»šæ—¶åˆ é™¤ä¸´æ—¶è¡¨
        });
        
        // åˆ†é…å†…å­˜
        auto buffer = AllocateBuffer(1024);
        transaction.RegisterRollbackAction([buffer]() {
            FreeBuffer(buffer);  // å›æ»šæ—¶é‡Šæ”¾å†…å­˜
        });
        
        // æ‰§è¡ŒæŸ¥è¯¢é€»è¾‘...
        
    } catch (const std::exception& e) {
        transaction.Rollback();  // å¼‚å¸¸æ—¶è‡ªåŠ¨å›æ»š
        throw;
    }
}
```

## 7.3 æ‰§è¡Œå™¨ä¸­æ–­å¤„ç†æœºåˆ¶



**ğŸ”¸ ä¸­æ–­å¤„ç†çš„é‡è¦æ€§**
å½“ç”¨æˆ·å–æ¶ˆæŸ¥è¯¢æˆ–ç³»ç»Ÿéœ€è¦ä¼˜é›…å…³é—­æ—¶ï¼Œæ‰§è¡Œå™¨éœ€è¦èƒ½å¤Ÿå®‰å…¨åœ°åœæ­¢æ‰§è¡Œã€‚

```cpp
class InterruptManager {
private:
    std::atomic<bool> interrupt_requested_;
    std::condition_variable interrupt_cv_;
    std::mutex interrupt_mutex_;
    
public:
    // è¯·æ±‚ä¸­æ–­
    void RequestInterrupt() {
        interrupt_requested_ = true;
        interrupt_cv_.notify_all();
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸­æ–­
    bool ShouldInterrupt() {
        return interrupt_requested_.load();
    }
    
    // åœ¨å…³é”®ç‚¹æ£€æŸ¥ä¸­æ–­
    void CheckInterrupt() {
        if (ShouldInterrupt()) {
            throw InterruptedException("Query was cancelled");
        }
    }
};

// åœ¨æ‰§è¡Œå™¨ä¸­ä½¿ç”¨
class TableScanIterator {
public:
    Row* Next() override {
        // æ¯éš”ä¸€å®šè¡Œæ•°æ£€æŸ¥ä¸­æ–­
        if (++row_count_ % 1000 == 0) {
            interrupt_manager_->CheckInterrupt();
        }
        
        return ReadNextRowFromStorage();
    }
};
```

---

# 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“



## 8.1 æ‰§è¡Œå™¨æ¶æ„æ ¸å¿ƒç†è§£



**ğŸ”¸ æ‰§è¡Œå™¨çš„æœ¬è´¨**
```
æ‰§è¡Œå™¨ = è®¡åˆ’è§£é‡Šå™¨ + æ•°æ®æµç®¡ç†å™¨ + èµ„æºåè°ƒå™¨

æ ¸å¿ƒèŒè´£ï¼š
- æŠŠæŠ½è±¡çš„æ‰§è¡Œè®¡åˆ’å˜æˆå…·ä½“çš„æ•°æ®æ“ä½œ
- ç®¡ç†æ•°æ®åœ¨å„ä¸ªæ“ä½œç®—å­é—´çš„æµåŠ¨
- åè°ƒCPUã€å†…å­˜ç­‰èµ„æºçš„ä½¿ç”¨
```

**ğŸ”¸ å…³é”®è®¾è®¡æ¨¡å¼**
- **è¿­ä»£å™¨æ¨¡å¼**ï¼šç»Ÿä¸€çš„æ•°æ®è¯»å–æ¥å£
- **çŠ¶æ€æœºæ¨¡å¼**ï¼šç®¡ç†æ‰§è¡Œç”Ÿå‘½å‘¨æœŸ
- **å¯¹è±¡æ± æ¨¡å¼**ï¼šé«˜æ•ˆçš„å†…å­˜ç®¡ç†
- **è´£ä»»é“¾æ¨¡å¼**ï¼šæ¨¡å—åŒ–çš„æ“ä½œç»„åˆ

## 8.2 æ€§èƒ½ä¼˜åŒ–è¦ç‚¹



| ä¼˜åŒ–æŠ€æœ¯ | **æ ¸å¿ƒæ€æƒ³** | **æ€§èƒ½æå‡** | **é€‚ç”¨åœºæ™¯** |
|---------|------------|-------------|-------------|
| ğŸ”¸ **ç«å±±æ¨¡å‹** | `æŒ‰éœ€æ‹‰å–æ•°æ®` | `é™ä½å†…å­˜å ç”¨` | `å†…å­˜å—é™ç¯å¢ƒ` |
| ğŸ”¸ **å‘é‡åŒ–æ‰§è¡Œ** | `æ‰¹é‡å¤„ç†æ•°æ®` | `æå‡CPUæ•ˆç‡` | `è®¡ç®—å¯†é›†å‹æŸ¥è¯¢` |
| ğŸ”¸ **ç®—å­fusion** | `åˆå¹¶ç›¸é‚»æ“ä½œ` | `å‡å°‘æ•°æ®æ‹·è´` | `ç®€å•è¿‡æ»¤æŠ•å½±` |
| ğŸ”¸ **SIMDä¼˜åŒ–** | `å¹¶è¡ŒæŒ‡ä»¤è®¡ç®—` | `4-8å€æ€§èƒ½æå‡` | `æ•°å€¼æ¯”è¾ƒè¿ç®—` |
| ğŸ”¸ **å†…å­˜æ± ** | `é‡ç”¨å†…å­˜å—` | `å‡å°‘åˆ†é…å¼€é”€` | `é¢‘ç¹å¯¹è±¡åˆ›å»º` |

## 8.3 å®é™…åº”ç”¨ä»·å€¼



**ğŸ”¸ å¯¹å¼€å‘è€…çš„æ„ä¹‰**
- **æ€§èƒ½è°ƒä¼˜**ï¼šç†è§£æ‰§è¡Œå™¨åŸç†æœ‰åŠ©äºç¼–å†™é«˜æ•ˆSQL
- **é—®é¢˜è¯Šæ–­**ï¼šèƒ½å¤Ÿåˆ†ææ‰§è¡Œè®¡åˆ’æ‰¾å‡ºæ€§èƒ½ç“¶é¢ˆ
- **æ¶æ„è®¾è®¡**ï¼šä¸ºè‡ªç ”æ•°æ®åº“æä¾›è®¾è®¡å‚è€ƒ

**ğŸ”¸ å…³é”®ç›‘æ§æŒ‡æ ‡**
```
æ‰§è¡Œå™¨æ€§èƒ½ç›‘æ§ï¼š
- è¡Œå¤„ç†é€Ÿåº¦ï¼šrows/second
- å†…å­˜ä½¿ç”¨é‡ï¼šMB
- CPUä½¿ç”¨ç‡ï¼š%
- ä¸´æ—¶è¡¨å¤§å°ï¼šMB
- ç®—å­æ‰§è¡Œæ—¶é—´ï¼šms
```

## 8.4 å­¦ä¹ è¦ç‚¹



**ğŸ”¸ å¿…é¡»æŒæ¡çš„æ¦‚å¿µ**
- æ‰§è¡Œå™¨åœ¨MySQLæ¶æ„ä¸­çš„ä½ç½®å’Œä½œç”¨
- Iteratorè¿­ä»£å™¨æ¨¡å¼çš„è®¾è®¡æ€æƒ³
- ç«å±±æ¨¡å‹vså‘é‡åŒ–æ‰§è¡Œçš„åŒºåˆ«
- å†…å­˜æ± å’Œèµ„æºç®¡ç†çš„é‡è¦æ€§

**ğŸ”¸ æ·±å…¥ç†è§£æ–¹å‘**
- é˜…è¯»MySQLæºç ä¸­çš„æ‰§è¡Œå™¨å®ç°
- ç ”ç©¶å…¶ä»–æ•°æ®åº“çš„æ‰§è¡Œå¼•æ“è®¾è®¡
- å®è·µç¼–å†™ç®€å•çš„æ‰§è¡Œå™¨æ¨¡å—

> ğŸ¯ **æ ¸å¿ƒè®°å¿†**  
> æ‰§è¡Œå™¨æ˜¯SQLæ‰§è¡Œçš„"å‘åŠ¨æœº"ï¼Œé€šè¿‡è¿­ä»£å™¨æ¨¡å¼å®ç°æ¨¡å—åŒ–è®¾è®¡ï¼Œé€šè¿‡ç«å±±æ¨¡å‹å®ç°å†…å­˜é«˜æ•ˆï¼Œé€šè¿‡å‘é‡åŒ–å®ç°CPUé«˜æ•ˆï¼Œé€šè¿‡çŠ¶æ€æœºå®ç°å¯é æ‰§è¡Œ

**ğŸ§  è®°å¿†å£è¯€**ï¼š
```
æ‰§è¡Œå™¨æ¶æ„è®¾è®¡ç²¾ï¼Œè¿­ä»£å™¨æ¨¡å¼è´¯å§‹ç»ˆ
ç«å±±æ¨¡å‹çœå†…å­˜ï¼Œå‘é‡æ‰¹å¤„ç†æ›´é«˜æ•ˆ  
çŠ¶æ€ç®¡ç†ä¿å¯é ï¼Œèµ„æºè°ƒåº¦é˜²å†²çª
èåˆä¼˜åŒ–ææ€§èƒ½ï¼Œæºç è§£è¯»ä¿ƒæ·±å…¥
```