---
title: 7、索引记录格式
---
## 📚 目录

1. [索引记录格式概述](#1-索引记录格式概述)
2. [记录头信息详解](#2-记录头信息详解)
3. [变长字段长度处理](#3-变长字段长度处理)
4. [NULL值位图机制](#4-null值位图机制)
5. [记录数据区结构](#5-记录数据区结构)
6. [主键值存储方式](#6-主键值存储方式)
7. [记录删除标记](#7-记录删除标记)
8. [记录格式版本](#8-记录格式版本)
9. [记录索引映射](#9-记录索引映射)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📋 索引记录格式概述


### 1.1 什么是索引记录格式


**🔸 基本概念**
```
索引记录格式：B+树索引中存储数据的具体格式
作用：决定数据在磁盘页面中如何组织和存储
目标：在有限空间内高效存储更多数据，快速定位记录
```

**💡 为什么要了解记录格式**
- **性能优化**：理解存储方式才能做出正确的设计决策
- **故障诊断**：当出现数据问题时能够深入分析
- **容量规划**：准确估算表和索引的存储空间需求

### 1.2 记录格式的整体结构


```
索引记录完整结构：
┌──────────────┬──────────────┬──────────────┬──────────────┐
│   变长字段   │   NULL值     │   记录头     │   记录数据   │
│   长度列表   │   位图       │   信息       │   区域       │
├──────────────┼──────────────┼──────────────┼──────────────┤
│  可变长度    │   固定长度   │   固定长度   │   可变长度   │
│              │   (可选)     │   5字节      │              │
└──────────────┴──────────────┴──────────────┴──────────────┘

从左到右的存储顺序，每部分都有特定作用
```

---

## 2. 🔧 记录头信息详解


### 2.1 记录头信息的作用


**🔸 核心功能**
```
记录头信息：每条记录的元数据信息
固定长度：5个字节，包含多个控制字段
位置：紧邻记录数据区之前
```

### 2.2 记录头信息的详细结构


```
记录头信息 (5字节) 详细结构：
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│ 保留 │ 保留 │deleted│min_rec│n_owned│heap_no│record_type│next_record│
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│ 1bit│ 1bit│ 1bit│ 1bit│ 4bit│ 13bit│ 3bit │ 16bit │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
```

**📊 各字段详细说明**

| 字段名 | 位数 | 作用说明 | 示例值 |
|--------|------|----------|---------|
| **deleted_flag** | `1bit` | **删除标记**：1表示已删除 | `0`(未删除) |
| **min_rec_flag** | `1bit` | **最小记录标记**：每层最小记录 | `0`(普通记录) |
| **n_owned** | `4bit` | **拥有记录数**：slot管理的记录数 | `0-8` |
| **heap_no** | `13bit` | **堆编号**：页面内记录编号 | `0-8191` |
| **record_type** | `3bit` | **记录类型**：0普通/1节点指针/2最小/3最大 | `0`(普通) |
| **next_record** | `16bit` | **下一记录偏移**：指向下条记录 | `32`(偏移量) |

### 2.3 实际记录头信息示例


```
示例：用户表记录的头信息
用户ID: 1001, 姓名: "张三", 年龄: 25

记录头信息解析：
deleted_flag = 0     (记录未删除)
min_rec_flag = 0     (不是最小记录)  
n_owned = 1          (slot拥有1条记录)
heap_no = 5          (页面内第5条记录)
record_type = 0      (普通数据记录)
next_record = 28     (下一条记录距离当前28字节)
```

---

## 3. 📏 变长字段长度处理


### 3.1 为什么需要变长字段长度列表


**🔸 问题背景**
```
定长字段：INT(4字节)、DATE(3字节) - 容易处理
变长字段：VARCHAR、TEXT、BLOB - 长度不固定

挑战：如何知道每个变长字段的实际长度？
解决：在记录开头存储变长字段长度信息
```

### 3.2 变长字段长度存储规则


**💡 存储方式**
```
基本规则：
- 按照字段定义的相反顺序存储长度
- 每个长度占用1-2个字节
- 只有真正的变长字段才会记录长度

示例表结构：
CREATE TABLE user (
    id INT,           -- 定长，不记录
    name VARCHAR(50), -- 变长，需要记录长度
    email VARCHAR(100), -- 变长，需要记录长度  
    age INT           -- 定长，不记录
);
```

**📊 长度编码规则**

| 字段实际长度 | 编码方式 | 字节数 | 示例 |
|-------------|----------|--------|------|
| **0-127字节** | `直接存储` | `1字节` | `0x05`(5字节) |
| **128-16383字节** | `高位+长度` | `2字节` | `0x8020`(32字节) |
| **更长字段** | `溢出页处理` | `特殊处理` | `页指针` |

### 3.3 变长字段长度列表示例


```
示例记录：
id = 1001 (4字节，定长)
name = "张三丰" (9字节，变长) 
email = "zhangsanfeng@example.com" (24字节，变长)
age = 45 (4字节，定长)

变长字段长度列表：
┌────────┬────────┐
│  0x18  │  0x09  │  ← 按相反顺序：email(24), name(9)
├────────┼────────┤
│ email  │  name  │  ← 对应字段
│ 24字节 │ 9字节  │
└────────┴────────┘

存储顺序：[0x18][0x09][NULL位图][记录头][1001][张三丰][zhangsanfeng@example.com][45]
```

---

## 4. 🗺️ NULL值位图机制


### 4.1 NULL值位图的作用


**🔸 设计目的**
```
问题：如何高效地标识哪些字段是NULL？
传统方案：每个字段用特殊值表示NULL - 浪费空间
位图方案：用1个bit表示1个字段是否为NULL - 节省空间
```

### 4.2 NULL值位图的结构


**💡 位图组织方式**
```
位图特点：
- 只对允许NULL的字段分配bit位
- 每个字段按照定义顺序对应一个bit
- 1表示NULL，0表示非NULL
- 位图长度 = ceiling(允许NULL字段数 / 8)

示例表结构：
CREATE TABLE user (
    id INT NOT NULL,        -- 不允许NULL，不占用bit
    name VARCHAR(50),       -- 允许NULL，占用bit 0
    email VARCHAR(100),     -- 允许NULL，占用bit 1  
    phone VARCHAR(20),      -- 允许NULL，占用bit 2
    age INT NOT NULL        -- 不允许NULL，不占用bit
);

NULL位图：只需要1个字节 (3个字段 < 8)
```

### 4.3 NULL值位图实际示例


```
示例记录组合：

记录1：id=1001, name="张三", email=NULL, phone="13800138000", age=25
NULL位图：0x02 (二进制: 00000010)
解释：bit1=1表示email为NULL，其他为0表示非NULL

记录2：id=1002, name=NULL, email=NULL, phone=NULL, age=30  
NULL位图：0x07 (二进制: 00000111)
解释：bit0、bit1、bit2都为1，表示name、email、phone都为NULL

位图读取顺序：
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│ bit7│ bit6│ bit5│ bit4│ bit3│ bit2│ bit1│ bit0│
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│  -  │  -  │  -  │  -  │  -  │phone│email│name │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
```

---

## 5. 💾 记录数据区结构


### 5.1 记录数据区的组织方式


**🔸 数据存储原则**
```
存储顺序：严格按照CREATE TABLE中字段定义顺序
数据紧凑：字段间无间隙，紧密排列
类型对齐：某些数据类型有对齐要求
```

### 5.2 不同数据类型的存储方式


**📊 常见数据类型存储格式**

| 数据类型 | 存储长度 | 存储方式 | 示例 |
|----------|----------|----------|------|
| **TINYINT** | `1字节` | `直接存储` | `0x19`(25) |
| **INT** | `4字节` | `小端序存储` | `0xE9030000`(1001) |
| **BIGINT** | `8字节` | `小端序存储` | `0xE903000000000000` |
| **CHAR(n)** | `n字节` | `定长填充` | `"ABC"`→`"ABC "` |
| **VARCHAR(n)** | `实际长度` | `变长存储` | `"Hello"`→`5字节` |
| **DATE** | `3字节` | `压缩格式` | `2024-01-15` |
| **DATETIME** | `8字节` | `压缩格式` | `2024-01-15 10:30:00` |

### 5.3 记录数据区实际布局


```
示例表和数据：
CREATE TABLE user (
    id INT,                    -- 4字节
    name VARCHAR(20),          -- 变长
    age TINYINT,              -- 1字节  
    created_date DATE         -- 3字节
);

INSERT INTO user VALUES (1001, 'Alice', 25, '2024-01-15');

记录数据区布局：
┌────────────┬─────────────┬─────────┬──────────────┐
│     id     │    name     │   age   │ created_date │
├────────────┼─────────────┼─────────┼──────────────┤
│ 0xE9030000 │  Alice\0    │  0x19   │   0x...      │
│  (1001)    │  (5字节)    │  (25)   │  (压缩日期)  │
└────────────┴─────────────┴─────────┴──────────────┘

总的记录布局：
[变长长度:0x05][NULL位图:0x00][记录头:5字节][1001][Alice][25][2024-01-15]
```

---

## 6. 🔑 主键值存储方式


### 6.1 聚簇索引中的主键存储


**🔸 聚簇索引特点**
```
聚簇索引：主键索引，叶子节点存储完整行数据
存储方式：主键值 + 完整记录数据
查找过程：通过主键直接定位到完整数据
```

### 6.2 二级索引中的主键存储


**💡 二级索引的设计**
```
二级索引：非主键字段上的索引
存储内容：索引字段值 + 主键值
回表查询：通过主键值到聚簇索引查询完整数据

为什么存储主键值而不是行指针？
- 主键值稳定不变，行位置可能因为页分裂而改变
- 避免维护复杂的指针更新机制
```

### 6.3 主键存储示例


```
示例表结构：
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100),
    INDEX idx_email (email)
);

聚簇索引 (PRIMARY KEY)：
┌─────────┬──────────────────────────────────┐
│ 主键值  │          完整记录数据            │
├─────────┼──────────────────────────────────┤
│  1001   │ [1001][Alice][alice@example.com] │
│  1002   │ [1002][Bob][bob@example.com]     │
│  1003   │ [1003][Carol][carol@example.com] │
└─────────┴──────────────────────────────────┘

二级索引 (idx_email)：
┌────────────────────┬─────────┐
│      索引字段值    │ 主键值  │
├────────────────────┼─────────┤
│ alice@example.com  │  1001   │
│ bob@example.com    │  1002   │
│ carol@example.com  │  1003   │
└────────────────────┴─────────┘

查询过程：
SELECT * FROM user WHERE email = 'alice@example.com';
1. 在idx_email中找到主键值1001
2. 用主键值1001到聚簇索引查询完整记录
```

---

## 7. 🗑️ 记录删除标记


### 7.1 逻辑删除机制


**🔸 为什么使用逻辑删除**
```
物理删除问题：
- 立即移动其他记录，成本高
- 可能导致页面频繁重组
- 影响并发性能

逻辑删除优势：
- 只修改删除标记，操作简单
- 延迟回收空间，减少碎片
- 支持事务回滚
```

### 7.2 删除标记的实现


**💡 删除标记处理**
```
删除标记位置：记录头信息中的deleted_flag位
标记含义：1表示已删除，0表示正常记录
可见性：被标记删除的记录对新事务不可见

删除流程：
1. 设置deleted_flag = 1
2. 维护删除记录链表
3. 后台清理进程回收空间
```

### 7.3 删除记录的链表管理


```
删除记录链表结构：
页面内被删除的记录通过next_record字段连接成链表

示例：删除用户ID为1002的记录
删除前：
[记录1001] → [记录1002] → [记录1003] → [记录1004]

删除后：
正常链表：[记录1001] → [记录1003] → [记录1004]  
删除链表：[记录1002] → [其他删除记录]

记录1002的变化：
deleted_flag: 0 → 1
next_record: 指向记录1003 → 指向下一个删除记录

页面头部维护：
- 正常记录链表头指针
- 删除记录链表头指针  
- 可重用空间大小统计
```

---

## 8. 📝 记录格式版本


### 8.1 MySQL记录格式演进


**🔸 格式版本历史**
```
Redundant：早期格式，信息冗余较多
Compact：MySQL 5.0引入，空间优化
Dynamic：MySQL 5.7默认，处理大字段更好  
Compressed：压缩格式，节省存储空间
```

### 8.2 不同格式的特点对比


**📊 格式版本对比**

| 格式类型 | 引入版本 | 主要特点 | 适用场景 |
|----------|----------|----------|----------|
| **Redundant** | `MySQL 4.0` | `信息冗余，兼容性好` | `老版本兼容` |
| **Compact** | `MySQL 5.0` | `紧凑存储，减少空间` | `一般业务场景` |
| **Dynamic** | `MySQL 5.7` | `大字段优化，行溢出处理` | `有大字段的表` |
| **Compressed** | `MySQL 5.7` | `数据压缩，减少IO` | `归档数据，读多写少` |

### 8.3 Compact格式详细特性


```
Compact格式的优化：
1. 变长字段长度列表 - 节省空间
2. NULL值位图 - 高效NULL处理  
3. 紧凑的记录头 - 减少元数据开销
4. 行溢出页处理 - 支持大字段

设置表的记录格式：
CREATE TABLE user (
    id INT,
    content TEXT
) ENGINE=InnoDB ROW_FORMAT=COMPACT;

或者修改现有表：
ALTER TABLE user ROW_FORMAT=DYNAMIC;
```

---

## 9. 🗺️ 记录索引映射


### 9.1 页面内记录定位机制


**🔸 记录定位挑战**
```
问题：如何在页面内快速定位指定记录？
方案1：顺序扫描 - 效率低
方案2：页面目录槽 - 二分查找，效率高
```

### 9.2 页面目录槽机制


**💡 槽的工作原理**
```
槽(Slot)机制：
- 将页面内记录分组，每组4-8条记录
- 每组选择一个代表记录创建槽
- 槽中存储代表记录的偏移量
- 查找时先定位槽，再在组内查找

槽的分布：
页面尾部存储槽目录，从后向前增长
每个槽占用2字节，存储记录偏移量
```

### 9.3 记录查找过程


```
示例：在页面内查找ID=1003的记录

页面内记录分组：
组1：[1001, 1002, 1003, 1004]  ← slot1指向记录1004
组2：[1005, 1006, 1007]        ← slot2指向记录1007  
组3：[1008, 1009]              ← slot3指向记录1009

查找过程：
1. 二分查找槽目录：1003 < 1004，定位到slot1
2. 从组1的起始记录1001开始顺序查找
3. 1001 → 1002 → 1003 找到目标记录

槽目录结构：
┌────────────────────────────────────────┐
│ [slot3:记录1009偏移] [slot2:记录1007偏移] │  
│ [slot1:记录1004偏移] [slot0:最小记录偏移] │
└────────────────────────────────────────┘

时间复杂度：
槽查找：O(log n)，n为槽数量
组内查找：O(4-8)，常数时间
总复杂度：O(log n)
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 记录格式结构：变长长度列表 + NULL位图 + 记录头 + 数据区
🔸 记录头信息：5字节元数据，包含删除标记、类型、偏移等关键信息  
🔸 变长字段处理：长度列表按相反顺序存储，支持1-2字节编码
🔸 NULL值位图：用bit位高效标识NULL字段，节省存储空间
🔸 主键存储方式：聚簇索引存完整数据，二级索引存主键值
🔸 删除标记机制：逻辑删除，维护删除链表，后台回收空间
🔸 记录定位：页面目录槽 + 二分查找，O(log n)复杂度
```

### 10.2 关键理解要点


**🔹 为什么这样设计记录格式**
```
空间效率：
- 变长字段只存储实际长度
- NULL位图比特殊值更节省空间
- 紧凑存储减少页面数量

查找效率：
- 记录头包含偏移信息，快速跳转
- 槽机制支持二分查找
- 链表结构便于顺序访问

维护成本：
- 逻辑删除避免频繁移动
- 格式版本支持优化升级
- 统一格式便于工具处理
```

**🔹 实际应用价值**
```
性能优化：
- 了解存储格式，选择合适的数据类型
- 避免过多NULL字段影响存储效率
- 合理设计表结构减少存储开销

故障诊断：
- 通过记录格式分析数据损坏问题
- 理解删除机制排查空间回收问题
- 掌握索引结构定位性能瓶颈

容量规划：
- 准确计算表和索引的存储需求
- 评估不同数据类型的空间开销
- 预测数据增长对存储的影响
```

### 10.3 记忆要点


**🧠 核心记忆**
```
记录格式四部分：长度、位图、头部、数据
记录头五字节：删除、类型、编号、偏移
NULL用位图：一个bit一个字段，节省空间
主键很重要：聚簇存全部，二级存主键
删除用标记：逻辑删除，链表管理
查找用槽机制：二分定位，常数组内
```

**💡 实践建议**
- 设计表时考虑字段顺序和NULL约束
- 选择合适的行格式应对不同业务场景
- 监控删除记录的空间回收情况
- 理解索引存储原理指导SQL优化