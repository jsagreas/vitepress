---
title: 3、索引扫描算法
---
## 📚 目录

1. [索引扫描基础概念](#1-索引扫描基础概念)
2. [全索引扫描详解](#2-全索引扫描详解)
3. [范围扫描算法](#3-范围扫描算法)
4. [索引覆盖扫描](#4-索引覆盖扫描)
5. [松散索引扫描](#5-松散索引扫描)
6. [扫描方向控制](#6-扫描方向控制)
7. [多范围扫描MRR](#7-多范围扫描mrr)
8. [扫描性能优化](#8-扫描性能优化)
9. [扫描算法选择策略](#9-扫描算法选择策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引扫描基础概念


### 1.1 什么是索引扫描


**简单理解**：索引扫描就是MySQL读取索引数据的方式，就像你在字典里查单词一样。

```
生活类比：
📖 字典查词 vs MySQL索引扫描
- 顺序翻页 = 全索引扫描
- 找特定范围 = 范围扫描  
- 只看目录 = 索引覆盖扫描
- 跳着找 = 松散索引扫描
```

**核心作用**：
- 🔸 **找数据**：定位需要的记录在哪里
- 🔸 **优化性能**：避免扫描整个表
- 🔸 **节省IO**：只读必要的数据页
- 🔸 **减少内存**：降低缓存使用

### 1.2 扫描算法的重要性


**为什么要学习扫描算法？**

```
实际场景：
用户查询：SELECT * FROM users WHERE age BETWEEN 20 AND 30;

不同扫描方式的效果：
❌ 全表扫描：检查100万条记录 → 耗时10秒
✅ 范围扫描：检查1万条记录 → 耗时0.1秒
性能差距：100倍！
```

**扫描算法分类图**：
```
索引扫描算法
├── 按扫描范围
│   ├── 全索引扫描 (Index Scan)
│   ├── 范围扫描 (Range Scan)  
│   └── 唯一扫描 (Unique Scan)
├── 按数据获取
│   ├── 索引覆盖扫描 (Covering Index)
│   └── 回表扫描 (Lookup)
└── 按扫描方式
    ├── 紧密扫描 (Tight Scan)
    └── 松散扫描 (Loose Scan)
```

---

## 2. 📖 全索引扫描详解


### 2.1 全索引扫描概念


**什么是全索引扫描？**
全索引扫描就是从头到尾读取整个索引，像看书一样一页一页翻。

```
全索引扫描示意图：
索引页: [1][2][3][4][5][6][7][8]
扫描:   ←  ←  ←  ←  ←  ←  ←  ←
       从左到右，全部读取
```

### 2.2 触发场景


**什么时候会用全索引扫描？**

```sql
-- 场景1：无WHERE条件的ORDER BY
SELECT * FROM users ORDER BY create_time;

-- 场景2：索引字段统计
SELECT COUNT(*) FROM users;

-- 场景3：范围太大时
SELECT * FROM users WHERE age > 10; -- 大部分用户年龄>10
```

> **💡 核心理解**
> 
> 全索引扫描虽然要读整个索引，但仍比全表扫描快，因为：
> - 索引页更紧凑，IO更少
> - 索引已经排序，无需额外排序
> - 可能无需回表查询

### 2.3 性能特点


```
全索引扫描的特点：
✅ 优势：
   • 保证有序结果
   • 避免临时表排序
   • 索引页连续读取，IO效率高

❌ 劣势：  
   • 读取数据量大
   • 内存消耗较多
   • 不适合大表
```

---

## 3. 🎯 范围扫描算法


### 3.1 范围扫描原理


**范围扫描**就是只读取索引中某个范围的数据，就像在字典中只看某几页。

```
范围扫描示意图：
索引值: [10][15][20][25][30][35][40][45]
查询:   WHERE age BETWEEN 20 AND 35
扫描:        ↓   ↓   ↓   ↓
           只读这4个值的页面
```

### 3.2 范围扫描类型


**常见范围查询语法：**

```sql
-- 1. BETWEEN范围查询
SELECT * FROM users WHERE age BETWEEN 20 AND 30;

-- 2. 比较操作符
SELECT * FROM users WHERE age >= 20 AND age <= 30;

-- 3. IN查询（多个值）
SELECT * FROM users WHERE age IN (20, 25, 30);

-- 4. 模糊查询
SELECT * FROM users WHERE name LIKE 'zhang%';
```

### 3.3 范围扫描算法实现


**MySQL内部如何实现范围扫描？**

```
算法步骤：
1. 解析WHERE条件 → 确定扫描范围
2. 定位起始位置 → 找到第一个满足条件的记录  
3. 顺序扫描 → 从起始位置开始读取
4. 边界检查 → 超出范围时停止
5. 返回结果 → 整理数据返回应用
```

**关键优化点：**
- 🔸 **精确定位**：快速找到起始和结束位置
- 🔸 **顺序读取**：利用索引有序特性
- 🔸 **提前终止**：到达边界立即停止

---

## 4. 🛡️ 索引覆盖扫描


### 4.1 索引覆盖概念


**什么是索引覆盖？**
索引覆盖就是查询的所有字段都在索引里，不用去原表查数据。

```
生活类比：
📚 书的目录 vs 索引覆盖
目录包含：章节名 + 页码
如果你只想知道有哪些章节，看目录就够了
不用翻到具体页面去看内容
```

### 4.2 覆盖索引的好处


```
覆盖索引的优势：
✅ 无需回表：不用访问原始数据页
✅ IO减少：只读索引页，IO量更小  
✅ 内存高效：索引页在内存中命中率更高
✅ 速度更快：减少了回表的开销
```

### 4.3 覆盖索引示例


```sql
-- 创建复合索引
CREATE INDEX idx_user_info ON users(age, name, email);

-- 覆盖索引查询（推荐）
SELECT name, email FROM users WHERE age = 25;
-- ✅ 所有字段都在索引中，无需回表

-- 非覆盖查询
SELECT name, email, phone FROM users WHERE age = 25;  
-- ❌ phone不在索引中，需要回表查询
```

**EXPLAIN查看覆盖索引：**
```sql
EXPLAIN SELECT name, email FROM users WHERE age = 25;

-- 结果中看到：
-- Extra: Using index  ← 表示使用了覆盖索引
```

> **⚠️ 注意事项**
> 
> 覆盖索引并不总是最好的选择：
> - 索引过宽会增加维护成本
> - 需要平衡查询性能和存储空间

---

## 5. 🦘 松散索引扫描


### 5.1 松散扫描概念


**什么是松散索引扫描？**
松散扫描就是跳过一些不需要的索引项，只读取有用的部分。

```
松散扫描示意图：
索引项: [A1][A2][A3][B1][B2][B3][C1][C2][C3]
查询:   SELECT DISTINCT category FROM products;
扫描:    ↓           ↓           ↓
       只读每组第一个，跳过重复项
```

### 5.2 松散扫描应用场景


**典型使用场景：**

```sql
-- 1. GROUP BY查询
SELECT category, COUNT(*) FROM products 
GROUP BY category;

-- 2. DISTINCT查询  
SELECT DISTINCT department FROM employees;

-- 3. MIN/MAX聚合
SELECT category, MIN(price) FROM products 
GROUP BY category;
```

### 5.3 松散扫描的优势


```
松散扫描 vs 紧密扫描：

紧密扫描：
[A1][A1][A1][B1][B1][B1][C1][C1][C1]
 ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
读取所有9个项，然后去重

松散扫描：  
[A1][A1][A1][B1][B1][B1][C1][C1][C1]
 ↓           ↓           ↓
只读3个项，直接跳到下一组

性能提升：3倍效率！
```

---

## 6. 🧭 扫描方向控制


### 6.1 扫描方向概念


**什么是扫描方向？**
B+树索引是有序的，可以正向扫描（升序）或反向扫描（降序）。

```
索引扫描方向图：
正向扫描: [10] → [20] → [30] → [40] → [50]
反向扫描: [50] ← [40] ← [30] ← [20] ← [10]
```

### 6.2 扫描方向控制场景


```sql
-- 正向扫描（升序）
SELECT * FROM users ORDER BY age ASC LIMIT 10;
-- 从最小值开始扫描

-- 反向扫描（降序）  
SELECT * FROM users ORDER BY age DESC LIMIT 10;
-- 从最大值开始扫描

-- 范围查询的方向优化
SELECT * FROM users WHERE age > 30 ORDER BY age DESC;
-- 从索引右侧开始反向扫描
```

### 6.3 方向控制的性能影响


```
场景分析：查询最新的10条记录

表结构：
users (id, name, create_time)
索引：idx_create_time(create_time)

查询语句：
SELECT * FROM users ORDER BY create_time DESC LIMIT 10;

扫描方式：
✅ 反向扫描：直接从最大值开始，读10条就停止
❌ 正向扫描：从头扫描到尾，再取最后10条

性能差距：数千倍！
```

---

## 7. 🚀 多范围扫描MRR


### 7.1 MRR概念解释


**MRR (Multi-Range Read)** 是MySQL的一个优化技术，专门优化范围扫描的IO效率。

```
传统扫描 vs MRR扫描：

传统方式：
读索引 → 回表 → 读索引 → 回表 → ...
IO模式：随机IO，效率低

MRR方式：  
读索引 → 读索引 → 读索引 → 批量回表
IO模式：顺序IO，效率高
```

### 7.2 MRR工作原理


**MRR的聪明之处：**

```
MRR算法步骤：
1. 扫描索引，收集主键值
2. 对主键值排序  
3. 按主键顺序批量回表
4. 返回排序后的结果

好处：
• 将随机IO转换为顺序IO
• 减少磁盘寻道时间
• 提高缓存命中率
```

### 7.3 MRR配置和使用


```sql
-- 查看MRR状态
SHOW VARIABLES LIKE 'optimizer_switch';
-- 找到 mrr=on 表示开启

-- 手动开启MRR
SET optimizer_switch='mrr=on,mrr_cost_based=off';

-- 查询中使用MRR hint
SELECT /*+ MRR(users) */ * FROM users 
WHERE age BETWEEN 20 AND 30;
```

**EXPLAIN中的MRR标识：**
```
Extra: Using MRR  ← 表示使用了MRR优化
```

---

## 8. ⚡ 扫描性能优化


### 8.1 扫描预读优化


**什么是预读？**
预读就是MySQL预先读取可能需要的数据页，减少后续的IO等待。

```
预读机制：
当前读取页: [Page 5]
预读页面: [Page 6][Page 7][Page 8]

原理：
• 顺序扫描时很可能读取相邻页面
• 提前读取可以减少IO等待时间
• 利用IO批量读取的效率优势
```

### 8.2 扫描缓存优化


**缓存在扫描中的作用：**

```
缓存层次结构：
┌─────────────────┐
│  Buffer Pool    │ ← 最快，内存访问
├─────────────────┤  
│  OS Page Cache  │ ← 较快，系统缓存
├─────────────────┤
│  Disk Storage   │ ← 最慢，磁盘IO
└─────────────────┘

优化策略：
✅ 提高Buffer Pool命中率
✅ 合理利用OS缓存
✅ 减少不必要的磁盘IO
```

### 8.3 扫描内存管理


```sql
-- 关键内存参数
SET innodb_buffer_pool_size = '8G';     -- 缓冲池大小
SET read_ahead_threshold = 56;           -- 预读阈值  
SET innodb_read_io_threads = 4;         -- 读IO线程数
```

**内存使用监控：**
```sql
-- 查看缓冲池状态
SHOW ENGINE INNODB STATUS;

-- 关键指标：
-- Buffer pool hit rate: 99.5%  ← 命中率要>95%
-- Pages read ahead: 1000       ← 预读页面数
-- Read requests: 50000         ← 读请求总数
```

### 8.4 并行扫描优化


**并行扫描的思路：**

```
单线程扫描：
Thread 1: [====扫描全部索引====] 耗时10秒

并行扫描：
Thread 1: [===扫描前1/4===]
Thread 2: [===扫描第2/4===]   } 并行执行，耗时3秒  
Thread 3: [===扫描第3/4===]
Thread 4: [===扫描后1/4===]
```

> **⚠️ 注意事项**
> 
> 并行扫描适用场景有限：
> - 主要用于大表的聚合查询
> - 需要足够的CPU和IO资源
> - 小表反而可能因为协调开销变慢

---

## 9. 🎯 扫描算法选择策略


### 9.1 MySQL如何选择扫描算法


**优化器的决策过程：**

```
MySQL优化器选择流程：
1. 分析WHERE条件 → 确定可用索引
2. 估算扫描成本 → 计算不同算法的代价
3. 选择最优方案 → 选择成本最低的算法
4. 执行查询 → 按选定算法执行
```

### 9.2 算法选择规则


| 查询类型 | **优先算法** | **选择原因** | **示例场景** |
|---------|------------|-------------|-------------|
| 🔍 **精确查询** | `唯一扫描` | 只返回一条记录 | `WHERE id = 123` |
| 📏 **小范围** | `范围扫描` | 扫描数据量小 | `WHERE age BETWEEN 25 AND 30` |
| 📊 **聚合查询** | `松散扫描` | 跳过重复值 | `SELECT COUNT(*) GROUP BY category` |
| 🛡️ **覆盖查询** | `索引覆盖` | 无需回表 | `SELECT name FROM users WHERE age > 20` |
| 📖 **大范围** | `全索引扫描` | 范围太大时退化 | `WHERE age > 10` (90%的数据) |

### 9.3 自适应扫描策略


**MySQL 8.0的智能优化：**

```
自适应扫描特性：
• 运行时统计：收集实际扫描的统计信息
• 动态调整：根据统计信息调整扫描策略  
• 历史学习：记住之前查询的最优方案
• 自动切换：性能不佳时自动尝试其他算法
```

### 9.4 强制指定扫描算法


```sql
-- 强制使用特定索引
SELECT * FROM users FORCE INDEX(idx_age) WHERE age > 20;

-- 忽略特定索引
SELECT * FROM users IGNORE INDEX(idx_age) WHERE age > 20;

-- 使用优化器提示
SELECT /*+ INDEX(users idx_age) */ * FROM users WHERE age > 20;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 扫描算法本质：MySQL读取索引数据的不同方式
🔸 性能影响：选择合适的扫描算法可以提升性能数十倍
🔸 算法类型：全索引、范围、覆盖、松散扫描各有适用场景
🔸 优化策略：通过MRR、预读、缓存等技术提升扫描效率
🔸 选择原则：MySQL优化器会自动选择最优扫描算法
```

### 10.2 关键理解要点


**🔹 算法选择的核心逻辑**
```
选择标准：
• 扫描数据量：越少越好
• IO次数：顺序IO优于随机IO  
• 内存使用：缓存命中率要高
• CPU开销：简单算法优于复杂算法
```

**🔹 性能优化的关键思路**
```
优化方向：
• 减少扫描范围：精确的WHERE条件
• 利用索引覆盖：避免回表查询
• 合理使用预读：提高IO效率
• 优化内存配置：提高缓存命中率
```

### 10.3 实际应用指导


**❓ 常见疑问解答：**

**Q：什么时候会使用全索引扫描？**
**A：** 当查询范围很大或者需要有序结果时，比如 `ORDER BY` 且没有 `LIMIT`

**Q：如何判断是否使用了覆盖索引？**  
**A：** 在 `EXPLAIN` 结果中看到 `Extra: Using index` 就表示使用了覆盖索引

**Q：MRR什么时候生效？**
**A：** 主要在范围扫描且需要回表的场景，MySQL会自动判断是否使用

### 10.4 性能监控要点


```sql
-- 监控扫描性能的关键指标
SHOW STATUS LIKE 'Handler_%';

-- 重要指标含义：
-- Handler_read_first: 索引第一条记录读取次数
-- Handler_read_next:  索引顺序读取次数  
-- Handler_read_key:   索引键值读取次数
-- Handler_read_rnd:   随机读取次数（越少越好）
```

**🎯 性能优化检查清单：**
- ✅ 查询是否使用了合适的索引
- ✅ 是否可以利用覆盖索引
- ✅ 扫描范围是否足够小
- ✅ 是否出现了不必要的回表
- ✅ 缓存命中率是否足够高

**核心记忆要点**：
- 索引扫描如同查字典，方法不同效率差异巨大
- 覆盖索引是性能优化的利器，避免回表是关键
- MySQL优化器很聪明，但有时需要人工干预
- 监控扫描性能，数据说话才能找到真正的瓶颈