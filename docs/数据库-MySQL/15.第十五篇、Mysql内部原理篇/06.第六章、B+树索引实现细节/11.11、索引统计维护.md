---
title: 11、索引统计维护
---
## 📚 目录

1. [索引统计信息概述](#1-索引统计信息概述)
2. [统计信息收集机制](#2-统计信息收集机制)
3. [基数估算算法详解](#3-基数估算算法详解)
4. [直方图统计原理](#4-直方图统计原理)
5. [统计信息更新策略](#5-统计信息更新策略)
6. [采样统计方法](#6-采样统计方法)
7. [统计精度控制](#7-统计精度控制)
8. [自动统计任务管理](#8-自动统计任务管理)
9. [实时统计更新](#9-实时统计更新)
10. [统计信息存储结构](#10-统计信息存储结构)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 索引统计信息概述


### 1.1 什么是索引统计信息


**简单理解**：索引统计信息就像是MySQL为每个索引建立的"档案"，记录了这个索引的各种特征数据。

```
想象一下图书馆的卡片目录：
📚 图书总数：10000本
📖 不同作者数：2000位  
📈 最受欢迎的10个分类
📊 每个分类的书籍分布情况

索引统计信息类似：
🔢 索引中的记录总数
🔍 不同值的个数（基数）
📊 数据分布直方图
⏱️ 统计信息最后更新时间
```

**核心作用**：
- **查询优化**：帮助MySQL选择最合适的执行计划
- **索引选择**：决定使用哪个索引效率最高
- **成本估算**：预估查询操作需要的资源消耗

### 1.2 统计信息的重要性


**为什么需要统计信息？**

```
场景对比：

没有统计信息的情况：
用户表：100万条记录
查询：SELECT * FROM users WHERE age = 25

MySQL盲选：
- 可能选择全表扫描（很慢）
- 可能选择错误的索引

有统计信息的情况：
MySQL知道：
- age字段有50个不同值
- age=25大约有2万条记录
- age_index选择性较好

结果：准确选择age索引，快速定位数据
```

### 1.3 统计信息的类型


**🔸 表级统计信息**
```sql
-- 查看表的基本统计信息
SELECT 
    table_name,
    table_rows,        -- 表中记录总数（估算值）
    avg_row_length,    -- 平均行长度
    data_length        -- 数据占用空间
FROM information_schema.tables 
WHERE table_name = 'users';
```

**🔸 索引级统计信息**
```sql
-- 查看索引统计信息
SELECT 
    index_name,
    cardinality,       -- 索引基数（不同值个数）
    sub_part,          -- 前缀索引长度
    nullable           -- 是否允许NULL值
FROM information_schema.statistics 
WHERE table_name = 'users';
```

---

## 2. 📊 统计信息收集机制


### 2.1 统计信息收集的时机


**🔸 自动收集时机**
```
触发条件：

1️⃣ 表结构变化
   - 新建表时
   - 添加或删除索引时
   - 修改表结构时

2️⃣ 数据变化达到阈值
   - 插入记录数 > 表大小的10%
   - 更新记录数 > 表大小的10%
   - 删除记录数 > 表大小的10%

3️⃣ 定期自动更新
   - 系统后台任务定期检查
   - 长时间未更新的统计信息
```

### 2.2 收集过程详解


**🔧 统计信息收集流程**

```
收集过程：
    开始
     ↓
确定采样策略 ← 根据表大小和配置
     ↓
读取样本数据 ← 使用随机采样或固定间隔
     ↓
计算基数估算 ← 应用HyperLogLog等算法  
     ↓
生成直方图 ← 分析数据分布特征
     ↓
更新系统表 ← 存储到mysql.innodb_index_stats
     ↓
    完成
```

### 2.3 收集策略配置


**🛠️ 关键参数设置**
```sql
-- 配置统计信息持久化
SET GLOBAL innodb_stats_persistent = ON;

-- 配置采样页面数量
SET GLOBAL innodb_stats_persistent_sample_pages = 20;

-- 配置自动重新计算
SET GLOBAL innodb_stats_auto_recalc = ON;

-- 查看当前配置
SHOW GLOBAL VARIABLES LIKE 'innodb_stats%';
```

**参数含义解释**：
- `innodb_stats_persistent`：是否持久化统计信息到磁盘
- `innodb_stats_persistent_sample_pages`：采样多少个数据页
- `innodb_stats_auto_recalc`：是否自动重新计算统计信息

---

## 3. 🧮 基数估算算法详解


### 3.1 什么是基数（Cardinality）


**通俗解释**：基数就是索引列中有多少个**不同的值**。

```
举例说明：

用户表中的性别字段：
记录：[男, 女, 男, 男, 女, 女, 男]
基数 = 2 （只有"男"和"女"两个不同值）

用户表中的用户ID字段：
记录：[1001, 1002, 1003, 1004, 1005]
基数 = 5 （每个ID都不同）

基数的意义：
- 基数越高，索引选择性越好
- 基数越低，索引效果越差
```

### 3.2 基数估算的挑战


**为什么需要估算？**
```
直接统计的问题：
✅ 准确性：能得到精确的基数
❌ 性能：需要扫描全部数据，太慢
❌ 资源：占用大量CPU和IO资源

估算的优势：
✅ 速度：只需要采样少量数据
✅ 资源：消耗较少的系统资源
❌ 精度：可能存在一定误差
```

### 3.3 HyperLogLog算法原理


**🔸 算法基本思想**

HyperLogLog是一种**概率性基数估算算法**，核心思想是利用哈希函数的随机性。

```
简化理解：

1️⃣ 哈希映射
   每个值 → 哈希函数 → 二进制串
   "张三" → hash() → "01101100..."
   "李四" → hash() → "10010011..."

2️⃣ 观察特征
   看二进制串开头连续0的个数
   "001101..." → 连续2个0
   "000101..." → 连续3个0

3️⃣ 统计推算
   连续k个0出现的概率 ≈ 1/(2^k)
   观察到最大连续0个数，推算总体数量
```

**🔧 实际实现示例**
```sql
-- MySQL中查看基数估算
SELECT 
    index_name,
    cardinality,
    ROUND(cardinality/table_rows*100, 2) as selectivity_percent
FROM information_schema.statistics s
JOIN information_schema.tables t ON s.table_name = t.table_name
WHERE s.table_name = 'users';
```

### 3.4 基数估算的准确性


**🔸 影响准确性的因素**

```
采样大小：
- 样本越大 → 估算越准确
- 样本越小 → 速度越快

数据分布：
- 均匀分布 → 估算较准确  
- 倾斜分布 → 估算可能偏差较大

算法选择：
- HyperLogLog → 适合高基数估算
- Linear Counting → 适合低基数估算
```

---

## 4. 📈 直方图统计原理


### 4.1 什么是直方图统计


**简单理解**：直方图就像是把数据按值的范围分成若干个"桶"，记录每个桶里有多少数据。

```
年龄分布直方图示例：

年龄范围    人数     可视化
18-25      1200    ████████████
26-35      2500    █████████████████████████  
36-45      1800    ██████████████████
46-55      900     █████████
56-65      400     ████

通过直方图可以知道：
- 26-35岁的用户最多
- 数据分布不均匀
- 查询不同年龄段的选择性
```

### 4.2 MySQL 8.0的直方图功能


**🔸 直方图类型**

MySQL 8.0引入了两种直方图：

```sql
-- 1. 等频直方图（Equi-Height）
-- 每个桶包含相同数量的记录
ANALYZE TABLE users UPDATE HISTOGRAM ON age WITH 10 BUCKETS;

-- 2. 单值直方图（Singleton）  
-- 每个不同值占一个桶
ANALYZE TABLE users UPDATE HISTOGRAM ON status WITH 5 BUCKETS;
```

### 4.3 直方图的使用场景


**🎯 什么时候使用直方图？**

```
适用场景：
✅ 数据分布不均匀
✅ 复杂的范围查询
✅ 多列条件查询
✅ 优化器估算不准确

示例查询：
-- 范围查询优化
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31'
AND order_amount > 1000;

-- 有了直方图，MySQL能更准确估算：
-- - 该日期范围内有多少订单
-- - 金额大于1000的比例
-- - 最优的执行计划
```

**🔧 直方图管理操作**
```sql
-- 创建直方图
ANALYZE TABLE products UPDATE HISTOGRAM ON price WITH 50 BUCKETS;

-- 查看直方图信息
SELECT * FROM information_schema.COLUMN_STATISTICS 
WHERE table_name = 'products';

-- 删除直方图
ANALYZE TABLE products DROP HISTOGRAM ON price;
```

---

## 5. 🔄 统计信息更新策略


### 5.1 更新触发条件


**🔸 自动更新条件**

```
触发阈值（默认设置）：

表变化阈值 = 10% × 表行数 + 1000
示例：
- 100万行表：变化超过10万行触发更新
- 1000行表：变化超过200行触发更新

具体触发情况：
✅ INSERT操作累计达到阈值
✅ UPDATE操作累计达到阈值  
✅ DELETE操作累计达到阈值
✅ 表结构ALTER操作
✅ 手动执行ANALYZE TABLE
```

### 5.2 更新策略配置


**🛠️ 更新频率控制**

```sql
-- 查看当前更新策略
SHOW GLOBAL VARIABLES LIKE '%stats%';

-- 关键配置参数：
-- innodb_stats_auto_recalc：是否自动更新
-- innodb_stats_transient_sample_pages：临时统计采样页数
-- innodb_stats_include_delete_marked：是否包含删除标记的记录
```

### 5.3 更新性能优化


**🚀 优化更新过程**

```
更新策略选择：

高频写入表：
- 适当降低更新频率
- 使用较小的采样大小
- 考虑在低峰期批量更新

查询密集表：
- 保持统计信息的及时性
- 使用较大的采样大小
- 启用直方图统计

配置示例：
-- 对于高频写入表
ALTER TABLE high_write_table 
STATS_AUTO_RECALC=0,           -- 关闭自动更新
STATS_SAMPLE_PAGES=5;          -- 减少采样页数

-- 手动定期更新
-- 设置定时任务，在业务低峰期执行
ANALYZE TABLE high_write_table;
```

---

## 6. 🎲 采样统计方法


### 6.1 采样的必要性


**为什么要采样？**

```
全量统计 vs 采样统计：

全量统计：
优点：结果100%准确
缺点：耗时长、资源消耗大、影响业务

采样统计：
优点：速度快、资源消耗少
缺点：存在一定误差

实际场景：
1000万行的订单表
- 全量统计：需要10分钟，IO密集
- 采样统计：需要10秒，准确率95%+
→ 显然采样更适合生产环境
```

### 6.2 采样策略详解


**🔸 随机采样策略**

```
采样方法：

1️⃣ 均匀随机采样
   - 从整个数据集中随机选择页面
   - 适合数据分布相对均匀的情况

2️⃣ 系统采样  
   - 按固定间隔选择数据页
   - 如：每隔100页选择1页

3️⃣ 分层采样
   - 根据数据特征分层采样
   - 保证各层都有代表性样本
```

**🔧 采样参数配置**
```sql
-- 设置持久化统计采样页数
SET GLOBAL innodb_stats_persistent_sample_pages = 20;

-- 设置临时统计采样页数  
SET GLOBAL innodb_stats_transient_sample_pages = 8;

-- 针对特定表设置
ALTER TABLE large_table STATS_SAMPLE_PAGES = 50;
```

### 6.3 采样质量控制


**🎯 提高采样准确性**

```
采样大小选择原则：

表大小          建议采样页数
< 1万行         全量统计
1万-10万行      10-20页
10万-100万行    20-50页  
100万-1000万行  50-100页
> 1000万行      100-200页

质量评估：
-- 比较采样结果与实际值
SELECT 
    index_name,
    cardinality as estimated,
    (SELECT COUNT(DISTINCT column_name) FROM table_name) as actual,
    ABS(cardinality - (SELECT COUNT(DISTINCT column_name) FROM table_name)) / 
    (SELECT COUNT(DISTINCT column_name) FROM table_name) * 100 as error_rate
FROM information_schema.statistics 
WHERE table_name = 'your_table';
```

---

## 7. 🎯 统计精度控制


### 7.1 精度与性能的权衡


**🔸 精度控制的核心考量**

```
精度要求评估：

高精度要求场景：
✅ 关键业务查询优化
✅ 复杂报表查询
✅ 数据仓库应用
→ 使用更大采样量，接受更长统计时间

一般精度要求：
✅ 日常OLTP查询
✅ 简单条件查询  
✅ 高频访问表
→ 使用适中采样量，平衡精度和性能
```

### 7.2 精度配置策略


**🛠️ 分级精度控制**

```sql
-- 核心业务表：高精度配置
ALTER TABLE core_business_table 
STATS_SAMPLE_PAGES = 100,
STATS_AUTO_RECALC = 1;

-- 日志表：低精度配置  
ALTER TABLE log_table
STATS_SAMPLE_PAGES = 10,
STATS_AUTO_RECALC = 0;

-- 临时表：最低精度
ALTER TABLE temp_table
STATS_SAMPLE_PAGES = 5;
```

### 7.3 精度监控与调整


**📊 统计精度监控**

```sql
-- 创建监控视图
CREATE VIEW stats_accuracy AS
SELECT 
    table_name,
    index_name,
    cardinality,
    CASE 
        WHEN cardinality = 0 THEN 'Empty'
        WHEN cardinality < 10 THEN 'Very Low'
        WHEN cardinality < 100 THEN 'Low'  
        WHEN cardinality < 1000 THEN 'Medium'
        ELSE 'High'
    END as selectivity_level,
    last_update
FROM information_schema.statistics
WHERE table_schema = DATABASE();

-- 定期检查统计信息质量
SELECT * FROM stats_accuracy 
WHERE last_update < DATE_SUB(NOW(), INTERVAL 7 DAY);
```

---

## 8. ⚡ 自动统计任务管理


### 8.1 自动统计任务机制


**🔸 后台统计任务工作原理**

```
自动统计任务流程：

    系统启动后台线程
           ↓
    定期扫描所有表的变化情况
           ↓
    检查是否达到更新阈值
           ↓
    YES → 加入统计任务队列
           ↓
    按优先级执行统计更新
           ↓
    更新完成，记录日志
```

### 8.2 任务调度策略


**⏰ 调度时间控制**

```sql
-- 查看统计相关的后台任务状态
SELECT 
    thread_id,
    name,
    type,
    processlist_state,
    processlist_info
FROM performance_schema.threads 
WHERE name LIKE '%stats%';

-- 业务低峰期批量更新统计
-- 可通过脚本在凌晨执行
SET SESSION sql_log_bin = 0;  -- 不记录binlog
ANALYZE TABLE table1, table2, table3;
```

### 8.3 任务优先级管理


**🎯 统计任务优先级规则**

```
优先级排序（高到低）：

1️⃣ 手动触发的ANALYZE TABLE
2️⃣ 新建表/索引的初始统计
3️⃣ 核心业务表的自动更新
4️⃣ 一般业务表的自动更新
5️⃣ 日志表等低优先级表

资源控制：
-- 限制同时进行的统计任务数量
-- 避免统计任务影响正常业务
-- 在系统负载高时暂停统计任务
```

---

## 9. 🚀 实时统计更新


### 9.1 实时更新的挑战


**🔸 为什么需要实时更新？**

```
传统定期更新的问题：

数据快速变化的表：
- 上午统计：10万条记录
- 下午查询：已经50万条记录
- 优化器：还在用上午的统计信息
- 结果：执行计划不优，性能差

实时更新的价值：
✅ 统计信息始终反映当前状态
✅ 查询优化器做出更准确判断
✅ 应对突发数据增长
```

### 9.2 实时更新实现方式


**🔧 增量更新策略**

```
实现方式：

1️⃣ 触发器方式
   - 在数据变更时触发统计更新
   - 适合小表或低频更新场景

2️⃣ 事务提交时更新
   - 在事务提交时检查统计阈值
   - 达到阈值立即触发更新

3️⃣ 后台线程轮询
   - 后台线程定期检查变化量
   - 发现达到阈值立即执行更新

配置示例：
-- 启用自动实时统计
SET GLOBAL innodb_stats_auto_recalc = ON;

-- 设置较小的阈值，更频繁更新
-- （需要在表创建时指定）
CREATE TABLE real_time_table (
    id INT PRIMARY KEY,
    data VARCHAR(100)
) ENGINE=InnoDB 
STATS_AUTO_RECALC=1,
STATS_SAMPLE_PAGES=10;
```

### 9.3 实时更新的成本控制


**💰 控制更新成本**

```
成本控制策略：

时间窗口控制：
- 同一表最小更新间隔：5分钟
- 避免过于频繁的统计更新

变化阈值动态调整：
- 大表：变化20%才更新
- 小表：变化10%就更新  
- 关键表：变化5%就更新

资源限制：
- 限制同时更新的表数量
- 业务高峰期暂停实时更新
- 统计更新优先级低于业务查询
```

---

## 10. 💾 统计信息存储结构


### 10.1 统计信息存储位置


**🗄️ MySQL统计信息存储系统**

```
MySQL 5.6+统计信息存储：

系统数据库：mysql
关键表：
├── innodb_table_stats     ← 表级统计信息
├── innodb_index_stats     ← 索引级统计信息  
└── column_statistics      ← 列统计信息（8.0+）

存储内容：
表统计：表名、行数、聚簇索引大小等
索引统计：索引名、基数、采样页数等
列统计：直方图数据、数据分布等
```

### 10.2 统计信息表结构


**🔸 innodb_table_stats表结构**
```sql
-- 查看表统计信息存储结构
DESC mysql.innodb_table_stats;

-- 查看具体统计数据
SELECT 
    database_name,
    table_name,
    n_rows,            -- 表行数估算
    clustered_index_size, -- 聚簇索引大小（页数）
    sum_of_other_index_sizes -- 其他索引大小总和
FROM mysql.innodb_table_stats 
WHERE database_name = 'your_database';
```

**🔸 innodb_index_stats表结构**
```sql
-- 索引统计信息详细内容
SELECT 
    database_name,
    table_name,
    index_name,
    stat_name,         -- 统计项名称
    stat_value,        -- 统计值
    sample_size        -- 采样大小
FROM mysql.innodb_index_stats 
WHERE database_name = 'your_database'
AND table_name = 'your_table';

-- 常见统计项：
-- n_diff_pfx01: 第一列的基数
-- n_diff_pfx02: 前两列的基数  
-- n_leaf_pages: 叶子页面数
-- size: 索引总页面数
```

### 10.3 统计信息的持久化


**💽 持久化配置与管理**

```sql
-- 启用统计信息持久化
SET GLOBAL innodb_stats_persistent = ON;

-- 查看持久化状态
SHOW GLOBAL VARIABLES LIKE 'innodb_stats_persistent%';

-- 表级别控制持久化
ALTER TABLE your_table STATS_PERSISTENT = 1;

-- 备份统计信息
mysqldump --no-data --routines --triggers \
  mysql innodb_table_stats innodb_index_stats > stats_backup.sql

-- 恢复统计信息  
mysql < stats_backup.sql
```

**🔧 统计信息维护**
```sql
-- 清理过期统计信息
DELETE FROM mysql.innodb_table_stats 
WHERE database_name = 'dropped_database';

-- 重建统计信息
DROP TABLE temp_rebuild;
CREATE TABLE temp_rebuild LIKE original_table;
INSERT INTO temp_rebuild SELECT * FROM original_table;
RENAME TABLE original_table TO old_table, temp_rebuild TO original_table;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🎯 统计信息的本质：
索引统计信息是MySQL用来指导查询优化的"数据档案"，包含基数、分布、大小等关键信息

🔢 基数估算算法：
通过HyperLogLog等概率算法，用少量采样数据估算索引中不同值的个数

📊 直方图统计：
MySQL 8.0引入的数据分布统计，帮助优化器更准确估算查询成本

⚡ 自动更新机制：
当表数据变化达到一定阈值时，自动触发统计信息更新

💾 持久化存储：
统计信息存储在mysql系统库中，支持持久化和手工管理
```

### 11.2 关键配置参数


| 参数名称 | **作用说明** | **建议值** | **适用场景** |
|---------|-------------|-----------|-------------|
| `innodb_stats_persistent` | **持久化统计信息** | `ON` | `生产环境必开` |
| `innodb_stats_auto_recalc` | **自动重新计算** | `ON` | `数据变化频繁` |
| `innodb_stats_persistent_sample_pages` | **持久化采样页数** | `20-100` | `根据表大小调整` |
| `STATS_SAMPLE_PAGES` | **表级采样页数** | `10-200` | `重要表用大值` |

### 11.3 实际应用指导


**🎯 不同场景的最佳实践**

```
📈 高频写入表（如日志表）：
- 关闭自动统计：STATS_AUTO_RECALC=0
- 减少采样页数：STATS_SAMPLE_PAGES=5
- 定期手工更新：设置离线任务

🔍 查询密集表（如用户表）：  
- 启用自动统计：STATS_AUTO_RECALC=1
- 增加采样页数：STATS_SAMPLE_PAGES=50
- 启用直方图：适合复杂查询

📊 数据仓库表：
- 高精度配置：STATS_SAMPLE_PAGES=100+  
- 启用列直方图：优化范围查询
- 定期重建统计：保证数据准确性
```

### 11.4 性能监控要点


**📊 关键监控指标**

```sql
-- 1. 统计信息更新频率监控
SELECT 
    table_name,
    last_update,
    TIMESTAMPDIFF(DAY, last_update, NOW()) as days_old
FROM mysql.innodb_table_stats 
WHERE days_old > 7;  -- 超过7天未更新的表

-- 2. 基数准确性监控  
SELECT 
    index_name,
    cardinality,
    CASE 
        WHEN cardinality = 0 THEN 'CRITICAL'
        WHEN cardinality < 10 THEN 'LOW'
        ELSE 'NORMAL'
    END as selectivity_status
FROM information_schema.statistics
WHERE cardinality = 0;  -- 基数为0需要重点关注

-- 3. 采样质量评估
SHOW TABLE STATUS LIKE 'your_table';  -- 对比Rows和实际行数
```

### 11.5 故障排查指南


**🔧 常见问题及解决方案**

```
问题1：查询突然变慢
排查：检查统计信息是否过期
解决：手工执行 ANALYZE TABLE

问题2：优化器选择错误索引
排查：检查索引基数是否准确
解决：增加采样页数，重新统计

问题3：统计信息更新太频繁  
排查：检查auto_recalc和阈值设置
解决：调整更新策略，适当降低频率

问题4：新表统计信息不准确
排查：检查采样页数配置
解决：手工ANALYZE或调整SAMPLE_PAGES
```

**核心要点记忆**：
- 统计信息是优化器的"眼睛"，准确性直接影响查询性能
- 采样算法平衡了精度和效率，是生产环境的最佳选择
- 自动更新机制适合大多数场景，特殊场景需要定制化配置  
- 监控和维护统计信息是DBA的重要日常工作