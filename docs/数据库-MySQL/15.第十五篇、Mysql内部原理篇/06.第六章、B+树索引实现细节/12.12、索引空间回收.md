---
title: 12、索引空间回收
---
## 📚 目录

1. [索引空间回收概述](#1-索引空间回收概述)
2. [页面空间回收机制](#2-页面空间回收机制)
3. [碎片空间整理详解](#3-碎片空间整理详解)
4. [删除记录回收过程](#4-删除记录回收过程)
5. [页面合并回收策略](#5-页面合并回收策略)
6. [空间回收算法实现](#6-空间回收算法实现)
7. [回收性能影响分析](#7-回收性能影响分析)
8. [空间使用监控方法](#8-空间使用监控方法)
9. [在线空间回收技术](#9-在线空间回收技术)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 索引空间回收概述


### 1.1 什么是索引空间回收


**📋 核心概念**
```
索引空间回收：当B+树索引中的数据被删除或页面变得稀疏时，
MySQL会自动回收这些不再使用的空间，以提高存储效率。

简单理解：就像整理房间，把空出来的地方重新利用起来
```

**🎯 为什么需要空间回收**
```
数据删除后的问题：
┌─────────────────────────────────┐
│ 原始页面: [记录1][记录2][记录3]    │
├─────────────────────────────────┤  
│ 删除后:  [记录1][空洞][记录3]     │ ← 产生碎片空间
├─────────────────────────────────┤
│ 回收后:  [记录1][记录3][可用空间] │ ← 空间得到重复利用
└─────────────────────────────────┘

不回收的后果：
• 磁盘空间浪费严重
• 查询性能逐渐下降  
• 缓存效率降低
```

### 1.2 空间回收的核心作用


**✅ 主要功能**
- **提高空间利用率**：避免磁盘空间浪费
- **维持查询性能**：保持索引结构紧凑
- **减少IO开销**：减少无用页面的读取
- **保持缓存效率**：提高内存使用效率

**🔄 回收触发时机**
```
自动触发场景：
1. 记录删除操作后
2. 页面填充率低于阈值时
3. 页面合并条件满足时
4. 系统空闲时的后台整理

手动触发场景：  
1. OPTIMIZE TABLE 命令
2. ALTER TABLE 重建
3. 定期维护脚本
```

---

## 2. 📄 页面空间回收机制


### 2.1 页面空间结构


**🏗️ InnoDB页面布局**
```
InnoDB数据页结构：
┌─────────────────────────────────────┐
│ 页头(Page Header)                   │ ← 38字节，存储页面元信息
├─────────────────────────────────────┤
│ 记录目录(Page Directory)            │ ← 记录槽信息
├─────────────────────────────────────┤  
│ 用户记录区(User Records)            │ ← 实际数据存储区域
├─────────────────────────────────────┤
│ 自由空间(Free Space)               │ ← 可用于新记录的空间
├─────────────────────────────────────┤
│ 页尾(Page Trailer)                 │ ← 8字节，校验信息
└─────────────────────────────────────┘

空间分配单位：每页16KB
```

### 2.2 页面空间回收过程


**🔄 回收工作流程**
```
第1步：标记删除记录
删除记录时不立即释放空间，而是标记为"已删除"

第2步：加入自由链表  
被删除的记录空间加入页面的自由空间链表

第3步：空间重复利用
新插入的记录优先使用自由链表中的空间

第4步：碎片整理
当碎片过多时，进行页面内部整理
```

**💡 具体示例说明**
```sql
-- 假设有一个索引页面包含以下记录
-- 页面填充情况：[记录A][记录B][记录C][记录D][自由空间]

-- 删除记录B后的状态
DELETE FROM table WHERE id = 'B';
-- 页面状态：[记录A][已删除B][记录C][记录D][自由空间]
-- 记录B的空间被标记为可回收，加入自由链表

-- 插入新记录时的空间复用
INSERT INTO table VALUES ('E', ...);  
-- 如果记录E大小适合原记录B的空间：
-- 页面状态：[记录A][记录E][记录C][记录D][自由空间]
```

### 2.3 页面填充率监控


**📊 填充率计算**
```
页面填充率 = (已使用空间 / 总页面空间) × 100%

健康状态判断：
🟢 填充率 > 80%：健康状态，空间利用良好
🟡 填充率 50%-80%：正常状态，可能需要关注  
🟠 填充率 20%-50%：警告状态，考虑整理
🔴 填充率 < 20%：危险状态，严重空间浪费

监控SQL示例：
SELECT 
  table_name,
  ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_mb,
  ROUND(data_free / 1024 / 1024, 2) AS free_mb,
  ROUND((data_free / (data_length + index_length)) * 100, 2) AS free_percent
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

---

## 3. 🧩 碎片空间整理详解


### 3.1 什么是索引碎片


**🔸 碎片产生原因**
```
内部碎片：页面内部的空闲空间不连续
┌─────────────────────────────────┐
│[记录1][空洞][记录2][空洞][记录3]│ ← 页面内多个小空洞
└─────────────────────────────────┘

外部碎片：页面之间的逻辑顺序与物理顺序不符
逻辑顺序：页面A → 页面B → 页面C
物理位置：页面A(磁盘块100) → 页面B(磁盘块50) → 页面C(磁盘块200)

产生场景：
• 随机删除操作
• 大量UPDATE操作导致记录迁移
• 批量DELETE后的稀疏页面
• 页面分裂后的不连续存储
```

### 3.2 碎片整理策略


**🛠️ 内部碎片整理**
```
页面内整理过程：

整理前：
┌─────────────────────────────────┐
│[记录1][空洞A][记录2][空洞B][记录3]│
└─────────────────────────────────┘

整理中：移动记录，消除空洞
┌─────────────────────────────────┐  
│[记录1][记录2][记录3][合并空间]   │
└─────────────────────────────────┘

整理后：连续的可用空间
优点：提高空间利用率，减少碎片
代价：需要移动记录，消耗CPU和IO
```

**🔄 外部碎片整理**
```
页面重排过程：

原始状态：物理页面分布混乱
物理磁盘：[页面C][其他数据][页面A][空页面][页面B]
逻辑顺序：页面A → 页面B → 页面C

整理后：物理页面按逻辑顺序排列  
物理磁盘：[页面A][页面B][页面C][其他数据][可用空间]
逻辑顺序：页面A → 页面B → 页面C

性能提升：
• 减少磁盘寻道时间
• 提高预读命中率
• 改善缓存局部性
```

### 3.3 碎片整理触发条件


**⚡ 自动触发机制**
```
InnoDB自动整理条件：
1. 页面填充率 < 页面大小的1/16 (约6.25%)
2. 删除记录数量 > 页面记录总数的1/2
3. 空闲空间碎片数 > 5个
4. 页面分裂/合并操作时

触发阈值可调整参数：
innodb_fill_factor = 100  -- 页面填充百分比
innodb_change_buffering = all  -- 变更缓冲设置
```

---

## 4. 🗑️ 删除记录回收过程


### 4.1 删除操作的内部机制


**📝 记录删除流程**
```
步骤1：标记删除
DELETE语句执行时，记录不会立即物理删除
而是在记录头部设置"已删除"标志位

步骤2：维护删除链表
被删除的记录通过指针链接成删除记录链表
页面头部维护指向第一个删除记录的指针

步骤3：空间复用
新插入记录时，优先使用删除记录的空间
如果空间大小合适，直接复用；否则拆分使用

删除记录链表结构：
页面头 → 删除记录1 → 删除记录2 → 删除记录3 → NULL
```

**💻 删除过程示例**
```sql
-- 原始表状态
CREATE TABLE test_delete (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  data TEXT
);

INSERT INTO test_delete VALUES 
(1, 'Alice', 'Data1'),
(2, 'Bob', 'Data2'), 
(3, 'Charlie', 'Data3'),
(4, 'David', 'Data4');

-- 删除中间记录
DELETE FROM test_delete WHERE id = 2;
-- 记录2被标记删除，空间加入删除链表

DELETE FROM test_delete WHERE id = 4;  
-- 记录4也被标记删除，链接到删除链表

-- 此时页面状态：
-- [记录1(活跃)][记录2(已删除)]→[记录3(活跃)][记录4(已删除)]→NULL
```

### 4.2 空间复用机制


**🔄 复用策略详解**
```
复用算法：First Fit（首次适应算法）

插入新记录时的空间分配优先级：
1. 查找删除记录链表中第一个足够大的空间
2. 如果找到合适空间，直接使用
3. 如果空间过大，拆分使用，剩余部分继续留在链表
4. 如果删除链表中没有合适空间，使用页面末尾的自由空间

空间复用示例：
原删除记录：[40字节空间]
新插入记录：[30字节需求]
复用结果：使用30字节，剩余10字节继续可用
```

**⚠️ 复用限制条件**
```
无法复用的情况：
1. 新记录大小 > 任何删除记录空间
2. 记录格式不兼容（VARCHAR长度变化等）
3. 页面锁定状态（正在进行其他操作）
4. 事务隔离级别限制

处理方案：
• 使用页面末尾自由空间
• 触发页面分裂创建新页面
• 进行碎片整理后重试
```

---

## 5. 🔗 页面合并回收策略


### 5.1 页面合并的概念


**📋 合并触发条件**
```
页面合并场景：
当相邻的两个页面填充率都很低时，InnoDB会将它们合并成一个页面

合并条件判断：
1. 相邻页面填充率之和 < 单页面容量的50%
2. 两个页面的记录总数 < 单页面最大记录数的60%
3. 合并不会破坏B+树的平衡性

合并示例：
页面A：[记录1][记录2][大量空间]     填充率25%
页面B：[记录3][记录4][大量空间]     填充率20% 
合并后：[记录1][记录2][记录3][记录4][剩余空间]  填充率45%
```

### 5.2 合并操作过程


**🔄 页面合并流程**
```
合并前的B+树结构：
        父节点
       /      \
   页面A      页面B
   (25%)      (20%)

第1步：检查合并条件
- 页面A和B是相邻兄弟节点
- 两页面填充率总和 < 50%
- 合并后不超过页面容量

第2步：移动记录
- 将页面B的所有记录移动到页面A
- 更新记录的页内偏移量
- 维护记录之间的链接关系

第3步：更新父节点
- 删除指向页面B的索引项
- 更新页面A的键值范围
- 调整父节点的分割键

第4步：释放页面B
- 标记页面B为可回收
- 加入空闲页面链表
- 更新表空间统计信息

合并后的B+树结构：
        父节点
           |
        页面A  
        (45%)
```

### 5.3 合并性能考量


**📊 性能影响分析**
```
合并操作代价：
🔸 CPU开销：移动记录数据，更新指针
🔸 IO开销：读取两个页面，写入合并结果
🔸 锁定开销：需要锁定涉及的页面和父节点
🔸 事务开销：生成redo/undo日志

性能优化策略：
✅ 批量合并：一次性处理多个相邻页面
✅ 后台执行：在系统空闲时进行合并
✅ 延迟合并：避免频繁的合并/分裂操作
✅ 智能阈值：根据业务特点调整合并条件

合并效果评估：
• 空间节约：减少页面数量，提高填充率
• 查询性能：减少页面遍历，提高缓存命中
• 维护成本：减少索引维护开销
```

---

## 6. ⚙️ 空间回收算法实现


### 6.1 回收算法分类


**🔧 核心算法类型**
```
1. 立即回收算法（Immediate Reclaim）
特点：删除操作后立即回收空间
优点：空间利用率高，碎片少
缺点：删除性能受影响

2. 延迟回收算法（Deferred Reclaim）  
特点：将回收操作推迟到合适时机
优点：删除性能好，批量处理效率高
缺点：可能产生临时空间浪费

3. 混合回收算法（Hybrid Reclaim）
特点：结合上述两种算法的优点
优点：在性能和空间利用之间平衡
缺点：实现复杂度较高
```

### 6.2 InnoDB回收算法实现


**🏗️ 算法实现细节**
```
InnoDB使用的混合回收策略：

删除记录时：
1. 标记记录为删除状态 (立即操作)
2. 加入页面删除记录链表 (立即操作)
3. 检查页面填充率 (延迟操作)
4. 必要时触发页面合并 (延迟操作)

关键数据结构：
┌─────────────────────────────────────┐
│ 页面头(Page Header)                 │
├─────────────────────────────────────┤
│ • n_deleted: 删除记录数量           │
│ • garbage: 删除记录占用的字节数     │
│ • first_deleted_rec: 第一个删除记录 │
│ • free_space: 可用空间大小          │
└─────────────────────────────────────┘

删除记录链表：
first_deleted_rec → 删除记录1 → 删除记录2 → ... → NULL
```

### 6.3 回收算法优化


**⚡ 性能优化技巧**
```sql
-- 1. 批量删除优化
-- ❌ 低效的逐条删除
DELETE FROM large_table WHERE condition1;
DELETE FROM large_table WHERE condition2;
DELETE FROM large_table WHERE condition3;

-- ✅ 高效的批量删除  
DELETE FROM large_table 
WHERE condition1 OR condition2 OR condition3;

-- 2. 分批删除大表数据
-- 避免长时间锁定和日志激增
DELIMITER //
CREATE PROCEDURE batch_delete()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    
    REPEAT
        DELETE FROM large_table 
        WHERE condition 
        LIMIT batch_size;
        
        SELECT ROW_COUNT() INTO @deleted_rows;
        
        -- 让其他事务有机会执行
        DO SLEEP(0.1);
        
    UNTIL @deleted_rows < batch_size END REPEAT;
END //
DELIMITER ;
```

**🎯 回收策略选择**
```
根据业务场景选择合适的回收策略：

OLTP系统（交易处理）：
• 优先考虑响应时间
• 使用延迟回收算法
• 在低峰期进行空间整理

OLAP系统（分析处理）：
• 优先考虑空间利用率
• 使用立即回收算法
• 定期进行全表重建

混合负载系统：
• 使用自适应回收策略
• 根据负载动态调整回收时机
• 设置合理的回收阈值
```

---

## 7. 📈 回收性能影响分析


### 7.1 性能影响维度


**📊 主要影响因素**
```
1. CPU影响
空间回收操作需要：
• 扫描删除记录链表
• 移动和重组记录数据
• 更新页面目录和索引结构
• 维护B+树平衡性

CPU占用特征：
🔸 删除操作：CPU使用量增加10-30%
🔸 页面合并：CPU使用量增加20-50%
🔸 碎片整理：CPU使用量增加30-80%

2. IO影响  
回收过程的IO开销：
• 读取需要整理的页面
• 写入整理后的页面数据
• 更新相关的元数据页面
• 生成redo/undo日志

IO特征：
🔸 随机IO：页面合并时的非顺序访问
🔸 写入放大：一次删除可能导致多页面更新
🔸 日志IO：大量的事务日志写入
```

### 7.2 性能影响测试


**🧪 实际测试案例**
```sql
-- 创建测试表
CREATE TABLE space_test (
  id INT AUTO_INCREMENT PRIMARY KEY,
  data VARCHAR(1000),
  INDEX idx_data(data)
) ENGINE=InnoDB;

-- 插入测试数据
INSERT INTO space_test (data) 
SELECT CONCAT('test_data_', n) 
FROM (
  SELECT a.N + b.N * 10 + c.N * 100 + d.N * 1000 AS n
  FROM (SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) a
  CROSS JOIN (SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) b  
  CROSS JOIN (SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) c
  CROSS JOIN (SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) d
) numbers LIMIT 100000;

-- 性能测试：删除50%的数据
SET @start_time = NOW(6);
DELETE FROM space_test WHERE id % 2 = 0;
SET @delete_time = TIMESTAMPDIFF(MICROSECOND, @start_time, NOW(6)) / 1000;

-- 检查空间使用情况
SELECT 
  ROUND(data_length/1024/1024, 2) AS data_mb,
  ROUND(index_length/1024/1024, 2) AS index_mb,
  ROUND(data_free/1024/1024, 2) AS free_mb,
  CONCAT(ROUND(data_free/(data_length+index_length)*100, 2), '%') AS free_percent
FROM information_schema.tables 
WHERE table_name = 'space_test';
```

### 7.3 性能优化建议


**🚀 优化最佳实践**
```
1. 删除操作优化
• 使用批量删除代替单条删除
• 在业务低峰期执行大批量删除
• 避免删除操作与查询操作冲突

2. 回收时机控制
-- 调整InnoDB参数优化回收策略
SET GLOBAL innodb_purge_threads = 4;        -- 增加清理线程数
SET GLOBAL innodb_purge_batch_size = 300;   -- 提高批处理大小  
SET GLOBAL innodb_max_purge_lag = 1000000;  -- 控制清理延迟

3. 监控和维护
-- 定期检查表空间使用情况
SELECT 
  table_name,
  engine,
  ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_mb,
  ROUND(data_free / 1024 / 1024, 2) AS free_mb,
  ROUND(data_free / (data_length + index_length) * 100, 2) AS free_percent
FROM information_schema.tables 
WHERE table_schema = DATABASE() 
  AND data_free > 0
ORDER BY free_percent DESC;

-- 当空闲空间过多时执行优化
OPTIMIZE TABLE space_test;
```

---

## 8. 📊 空间使用监控方法


### 8.1 监控指标体系


**📈 关键监控指标**
```
1. 表级别指标
• data_length: 数据大小
• index_length: 索引大小  
• data_free: 空闲空间大小
• avg_row_length: 平均行长度
• table_rows: 估计行数

2. 页面级别指标
• page_fill_factor: 页面填充率
• page_fragmentation: 页面碎片率
• deleted_records_ratio: 删除记录比率
• free_space_ratio: 空闲空间比率

3. 系统级别指标
• innodb_buffer_pool_pages_free: 缓冲池空闲页数
• innodb_buffer_pool_pages_dirty: 缓冲池脏页数
• innodb_purge_lag: 清理操作滞后量
• innodb_history_list_length: 历史列表长度
```

### 8.2 监控SQL脚本


**💻 实用监控脚本**
```sql
-- 1. 表空间使用情况监控
CREATE VIEW table_space_usage AS
SELECT 
  table_schema,
  table_name,
  engine,
  table_rows,
  ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_size_mb,
  ROUND(data_length / 1024 / 1024, 2) AS data_size_mb,
  ROUND(index_length / 1024 / 1024, 2) AS index_size_mb,
  ROUND(data_free / 1024 / 1024, 2) AS free_size_mb,
  CASE 
    WHEN (data_length + index_length) = 0 THEN 0
    ELSE ROUND(data_free / (data_length + index_length) * 100, 2)
  END AS free_percent,
  CASE
    WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 25 THEN '🔴 严重碎片'
    WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 15 THEN '🟡 需要关注'  
    WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 5 THEN '🟢 正常范围'
    ELSE '✅ 健康状态'
  END AS status
FROM information_schema.tables
WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
  AND engine = 'InnoDB'
ORDER BY free_percent DESC;

-- 2. InnoDB状态监控
SELECT 
  'Buffer Pool Pages' AS metric_type,
  'Total' AS metric_name,
  variable_value AS metric_value
FROM performance_schema.global_status 
WHERE variable_name = 'Innodb_buffer_pool_pages_total'

UNION ALL

SELECT 
  'Buffer Pool Pages' AS metric_type,
  'Free' AS metric_name, 
  variable_value AS metric_value
FROM performance_schema.global_status
WHERE variable_name = 'Innodb_buffer_pool_pages_free'

UNION ALL

SELECT
  'Purge Info' AS metric_type,
  'Purge Lag' AS metric_name,
  variable_value AS metric_value  
FROM performance_schema.global_status
WHERE variable_name = 'Innodb_purge_trx_id_age';
```

### 8.3 自动化监控方案


**🤖 监控自动化实现**
```sql
-- 创建监控存储过程
DELIMITER //
CREATE PROCEDURE monitor_space_usage()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_table_schema VARCHAR(64);
    DECLARE v_table_name VARCHAR(64); 
    DECLARE v_free_percent DECIMAL(5,2);
    DECLARE v_total_size_mb DECIMAL(10,2);
    
    -- 游标定义
    DECLARE space_cursor CURSOR FOR
        SELECT table_schema, table_name, 
               ROUND(data_free / (data_length + index_length) * 100, 2) AS free_percent,
               ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_size_mb
        FROM information_schema.tables  
        WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
          AND engine = 'InnoDB'
          AND (data_length + index_length) > 0;
          
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 创建监控结果表
    CREATE TEMPORARY TABLE IF NOT EXISTS temp_monitor_results (
        check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        table_schema VARCHAR(64),
        table_name VARCHAR(64),
        free_percent DECIMAL(5,2),
        total_size_mb DECIMAL(10,2),
        action_needed VARCHAR(100)
    );
    
    -- 遍历所有表
    OPEN space_cursor;
    read_loop: LOOP
        FETCH space_cursor INTO v_table_schema, v_table_name, v_free_percent, v_total_size_mb;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 判断是否需要采取行动
        SET @action_needed = CASE
            WHEN v_free_percent > 30 AND v_total_size_mb > 100 THEN 'OPTIMIZE TABLE建议'
            WHEN v_free_percent > 20 AND v_total_size_mb > 1000 THEN 'OPTIMIZE TABLE建议'  
            WHEN v_free_percent > 50 THEN 'ALTER TABLE重建建议'
            ELSE '正常'
        END;
        
        -- 记录监控结果
        INSERT INTO temp_monitor_results 
        VALUES (NOW(), v_table_schema, v_table_name, v_free_percent, v_total_size_mb, @action_needed);
        
    END LOOP;
    CLOSE space_cursor;
    
    -- 返回需要关注的表
    SELECT * FROM temp_monitor_results 
    WHERE action_needed != '正常'
    ORDER BY free_percent DESC;
    
END //
DELIMITER ;

-- 设置定期执行
-- 可以通过系统cron或MySQL Event实现
CREATE EVENT IF NOT EXISTS daily_space_monitor
ON SCHEDULE EVERY 1 DAY
STARTS TIMESTAMP(CURRENT_DATE) + INTERVAL 1 DAY + INTERVAL 2 HOUR
DO CALL monitor_space_usage();
```

---

## 9. 🔄 在线空间回收技术


### 9.1 在线回收的挑战


**⚠️ 在线环境限制**
```
在线系统的约束条件：
1. 不能长时间锁定表
2. 不能显著影响业务查询性能  
3. 需要保证数据一致性
4. 要控制系统资源消耗

传统OPTIMIZE TABLE的问题：
• 需要重建整个表
• 过程中表被锁定
• 消耗大量临时空间
• 可能需要数小时完成

在线回收的解决思路：
✅ 分批次处理
✅ 增量式回收
✅ 非阻塞操作
✅ 资源使用限制
```

### 9.2 在线回收实现方案


**🛠️ 技术实现方案**
```sql
-- 方案1: Online DDL (MySQL 5.6+)
-- 使用ALGORITHM=INPLACE进行在线重建
ALTER TABLE large_table 
ENGINE=InnoDB,
ALGORITHM=INPLACE,
LOCK=NONE;

-- 方案2: 分批处理大表
-- 创建新表结构
CREATE TABLE large_table_new LIKE large_table;

-- 分批迁移数据
SET @batch_size = 10000;
SET @min_id = (SELECT MIN(id) FROM large_table);
SET @max_id = (SELECT MAX(id) FROM large_table);

-- 循环处理每个批次
WHILE @min_id <= @max_id DO
    INSERT INTO large_table_new 
    SELECT * FROM large_table 
    WHERE id >= @min_id AND id < @min_id + @batch_size;
    
    SET @min_id = @min_id + @batch_size;
    
    -- 避免长时间占用资源
    DO SLEEP(0.1);
END WHILE;

-- 方案3: 使用pt-online-schema-change工具
-- 这是Percona提供的在线表结构变更工具
pt-online-schema-change \
  --alter "ENGINE=InnoDB" \
  --execute \
  --chunk-size=1000 \
  --max-load="Threads_running=25" \
  --critical-load="Threads_running=50" \
  D=database_name,t=table_name
```

### 9.3 在线回收最佳实践


**✅ 实施建议**
```
1. 回收时机选择
• 业务低峰期执行
• 避开备份和维护时间
• 监控系统负载情况

2. 资源控制策略  
-- 限制并发线程数
SET GLOBAL innodb_thread_concurrency = 8;

-- 控制IO压力
SET GLOBAL innodb_io_capacity = 200;
SET GLOBAL innodb_io_capacity_max = 2000;

-- 调整缓冲池刷新策略
SET GLOBAL innodb_max_dirty_pages_pct = 75;
SET GLOBAL innodb_max_dirty_pages_pct_lwm = 50;

3. 监控和回滚计划
• 实时监控性能指标
• 准备回滚方案
• 设置自动中止条件

监控脚本示例：
#!/bin/bash
# 监控在线回收过程
while true; do
    # 检查系统负载
    load_avg=$(uptime | awk '{print $12}' | sed 's/,//')
    if (( $(echo "$load_avg > 10" | bc -l) )); then
        echo "系统负载过高，暂停回收操作"
        # 发送告警或暂停操作
    fi
    
    # 检查慢查询数量
    slow_queries=$(mysql -e "SHOW GLOBAL STATUS LIKE 'Slow_queries';" | awk 'NR==2{print $2}')
    echo "当前慢查询数量: $slow_queries"
    
    sleep 60
done
```

**🎯 回收效果评估**
```sql
-- 回收前后对比分析
-- 执行前记录基准数据
CREATE TABLE space_reclaim_baseline AS
SELECT 
  table_schema,
  table_name,
  NOW() as measure_time,
  'BEFORE' as measure_phase,
  table_rows,
  ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_size_mb,
  ROUND(data_free / 1024 / 1024, 2) AS free_size_mb,
  ROUND(data_free / (data_length + index_length) * 100, 2) AS free_percent
FROM information_schema.tables
WHERE table_name = 'target_table';

-- 执行回收操作后记录结果数据
INSERT INTO space_reclaim_baseline
SELECT 
  table_schema,
  table_name, 
  NOW() as measure_time,
  'AFTER' as measure_phase,
  table_rows,
  ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_size_mb,
  ROUND(data_free / 1024 / 1024, 2) AS free_size_mb,
  ROUND(data_free / (data_length + index_length) * 100, 2) AS free_percent
FROM information_schema.tables  
WHERE table_name = 'target_table';

-- 对比分析结果
SELECT 
  b.measure_phase,
  b.total_size_mb,
  b.free_size_mb,
  b.free_percent,
  CASE WHEN b.measure_phase = 'AFTER' THEN
    CONCAT('节约空间: ', 
           ROUND((SELECT total_size_mb FROM space_reclaim_baseline WHERE measure_phase = 'BEFORE') - b.total_size_mb, 2),
           'MB (',
           ROUND(((SELECT total_size_mb FROM space_reclaim_baseline WHERE measure_phase = 'BEFORE') - b.total_size_mb) / 
                 (SELECT total_size_mb FROM space_reclaim_baseline WHERE measure_phase = 'BEFORE') * 100, 2),
           '%)')
  END as space_saved
FROM space_reclaim_baseline b
ORDER BY b.measure_time;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 索引空间回收：MySQL自动回收B+树索引中不再使用的空间
🔸 页面空间回收：通过删除记录链表和自由空间管理实现空间复用
🔸 碎片空间整理：消除页面内部和页面间的空间碎片  
🔸 页面合并回收：将填充率低的相邻页面合并以节约空间
🔸 在线空间回收：在不影响业务的情况下进行空间整理
```

### 10.2 关键理解要点


**🔹 空间回收的本质**
```
空间回收 = 提高存储效率 + 维持查询性能

回收机制：
删除标记 → 空间复用 → 碎片整理 → 页面合并
   ↓         ↓         ↓         ↓
立即生效   延迟生效   批量处理   条件触发
```

**🔹 性能与空间的平衡**
```
立即回收 vs 延迟回收
• 立即回收：空间利用率高，但影响删除性能
• 延迟回收：删除性能好，但可能浪费空间
• 最佳实践：根据业务特点选择合适的回收策略
```

**🔹 监控的重要性**  
```
监控指标优先级：
1. 空闲空间比例 (最重要)
2. 页面填充率
3. 删除记录比例
4. 系统性能影响

告警阈值建议：
• 空闲空间 > 25%：需要关注
• 空闲空间 > 50%：建议优化
• 填充率 < 50%：考虑重建
```

### 10.3 实际应用价值


**💼 业务场景应用**
- **数据清理项目**：定期删除历史数据后的空间回收
- **系统优化**：通过空间整理提升查询性能
- **成本控制**：减少存储空间消耗，降低硬件成本
- **容量规划**：准确评估实际空间需求

**🛠️ 运维实践要点**
- **定期监控**：建立空间使用监控体系
- **合理调参**：根据业务特点优化回收参数
- **择时执行**：在合适时机执行空间整理操作
- **效果评估**：量化空间回收的实际效果

### 10.4 常见问题和解决方案


**❓ 常见问题**
```
Q1: 删除大量数据后表文件大小没有减少？
A1: InnoDB使用标记删除，需要执行OPTIMIZE TABLE或重建表

Q2: OPTIMIZE TABLE执行时间很长怎么办？
A2: 使用在线DDL或分批处理，避免长时间锁定

Q3: 如何判断是否需要进行空间回收？
A3: 监控空闲空间比例，超过20%建议考虑回收

Q4: 空间回收会影响主从复制吗？
A4: 会产生binlog，建议在从库维护窗口执行
```

**🎯 最佳实践总结**
```
1. 预防为主：合理设计删除策略，减少碎片产生
2. 定期监控：建立完善的空间使用监控机制  
3. 择时回收：在业务低峰期执行空间回收操作
4. 渐进优化：采用分批处理，避免对业务的影响
5. 效果评估：量化回收效果，持续优化回收策略
```

**核心记忆要点**：
- 空间回收是维护MySQL性能的重要手段
- 删除操作不会立即释放物理空间，需要回收机制
- 监控空间使用情况，及时发现和处理空间碎片
- 选择合适的回收时机和方法，平衡性能与空间效率