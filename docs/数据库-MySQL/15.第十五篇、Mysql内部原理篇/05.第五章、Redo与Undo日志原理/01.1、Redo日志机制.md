---
title: 1、Redo日志机制
---
## 📚 目录

1. [Redo日志基础概念](#1-Redo日志基础概念)
2. [Redo日志工作原理](#2-Redo日志工作原理)
3. [Redo日志结构详解](#3-Redo日志结构详解)
4. [Undo日志基础概念](#4-Undo日志基础概念)
5. [Undo日志工作原理](#5-Undo日志工作原理)
6. [日志刷盘机制](#6-日志刷盘机制)
7. [崩溃恢复机制](#7-崩溃恢复机制)
8. [性能优化策略](#8-性能优化策略)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📝 Redo日志基础概念


### 1.1 什么是Redo日志


**💡 生活类比**
```
Redo日志就像是建筑工地的施工记录本：
- 每做一步工作都详细记录下来
- 如果工地突然停电，根据记录本可以知道做到哪一步
- 重新开工时，可以从记录继续往下做
```

**🔍 核心定义**
```
Redo日志（重做日志）：
• 作用：记录数据页的物理修改操作
• 目的：保证事务的持久性（Durability）
• 时机：在数据页修改之前先写入日志
• 恢复：系统崩溃后重新执行已提交事务的修改
```

### 1.2 为什么需要Redo日志


**🤔 问题场景**
```
没有Redo日志的情况：
用户A：转账100元给用户B
步骤1：A账户 -100 ✓（已写入磁盘）
步骤2：B账户 +100 ❌（还在内存中，突然断电）
结果：A的钱扣了，B没收到 → 数据不一致！
```

**✅ 有了Redo日志**
```
写入顺序：
1. Redo日志：记录"A账户-100，B账户+100" → 写入磁盘
2. 提交事务：告诉用户"转账成功"
3. 数据页：慢慢将内存中的修改写入磁盘

断电恢复时：
根据Redo日志重新执行 → A-100，B+100 → 数据一致
```

### 1.3 Redo日志的核心特点


**🎯 关键特性**
- **`Write-Ahead Logging(WAL)`**：日志先于数据写入
- **`物理记录`**：记录数据页的具体修改内容
- **`顺序写入`**：日志按时间顺序追加写入
- **`幂等性`**：重复执行同一条日志不会出错

---

## 2. ⚙️ Redo日志工作原理


### 2.1 事务执行流程


**📋 完整流程图示**
```
事务开始
    ↓
修改内存中的数据页 ──同时写入──→ Redo日志缓冲区
    ↓                              ↓
更多修改操作... ────────────→ 更多日志记录...
    ↓                              ↓
事务提交 ←────────────────── Redo日志刷盘
    ↓                              
返回"提交成功"                      
    ↓                              
后台慢慢刷新 ──→ 数据页写入磁盘      
```

### 2.2 WAL机制详解


**🔄 写入顺序保证**
```
正确顺序（WAL原则）：
1. 生成Redo日志记录
2. 将日志写入磁盘
3. 事务提交
4. 后续将脏页写入磁盘

❌ 错误顺序：
如果先写数据页，后写日志 → 
断电时可能数据已写入但日志丢失 → 无法回滚
```

### 2.3 LSN机制原理


**📊 日志序列号（LSN）**
```
LSN作用：
• 全局唯一：每条日志记录都有唯一LSN
• 递增序列：LSN按时间顺序递增
• 位置标识：标识日志在文件中的位置
• 同步标记：用于主从复制的位置同步

LSN示例：
事务A：LSN 1000 - 修改用户表
事务B：LSN 1001 - 修改订单表  
事务A：LSN 1002 - 修改账户表
```

### 2.4 检查点机制


**🔍 CheckPoint原理**
```
检查点作用：
• 定期将内存中的脏页刷新到磁盘
• 标记哪些Redo日志已经不需要了
• 缩短系统崩溃后的恢复时间

工作过程：
1. 找出所有脏页（内存中被修改的页）
2. 将脏页批量写入磁盘
3. 记录检查点LSN
4. 之前的Redo日志可以清理
```

---

## 3. 🏗️ Redo日志结构详解


### 3.1 日志记录格式


**📋 Redo日志记录结构**
```
┌─────────────────────────────────────┐
│           日志记录头部               │
├─────────────────────────────────────┤
│ 记录类型 | 空间ID | 页号 | 偏移量   │
├─────────────────────────────────────┤
│           具体的修改内容             │
│      (旧值 → 新值)                  │
├─────────────────────────────────────┤
│           校验信息                   │
└─────────────────────────────────────┘
```

### 3.2 物理逻辑日志


**💡 什么是物理逻辑日志**
```
物理部分：
• 明确指出修改的页面和位置
• 页号：第几个数据页
• 偏移量：页内第几个字节

逻辑部分：
• 记录具体的修改操作
• 比如："将第5行的age字段从25改为26"

优势：
• 比纯物理日志更紧凑
• 比纯逻辑日志更快速恢复
```

### 3.3 日志记录类型


**📝 常见日志类型**

| 类型 | **说明** | **示例** |
|------|----------|----------|
| `MLOG_1BYTE` | 修改1字节 | 状态标志修改 |
| `MLOG_2BYTES` | 修改2字节 | 整数字段修改 |
| `MLOG_4BYTES` | 修改4字节 | 主键值修改 |
| `MLOG_8BYTES` | 修改8字节 | 时间戳修改 |
| `MLOG_REC_INSERT` | 插入记录 | 新增一行数据 |
| `MLOG_REC_DELETE` | 删除记录 | 删除一行数据 |
| `MLOG_REC_UPDATE` | 更新记录 | 修改某行数据 |

---

## 4. 🔄 Undo日志基础概念


### 4.1 什么是Undo日志


**💡 生活类比**
```
Undo日志就像是文档的"撤销"功能：
- 每次修改都记录"修改前的内容"
- 如果后悔了，可以按撤销恢复原状
- 支持多级撤销，一步步往回退
```

**🔍 核心定义**
```
Undo日志（回滚日志）：
• 作用：记录事务修改前的原始数据
• 目的：支持事务回滚和MVCC
• 时机：在修改数据之前记录原值
• 回滚：失败事务根据Undo日志恢复原状
```

### 4.2 Undo日志的作用


**🎯 两大核心作用**

```
1. 事务回滚：
   事务执行一半出错 → 根据Undo日志撤销所有修改
   
2. MVCC实现：
   提供数据的历史版本 → 支持多版本并发控制
```

**📊 实际场景示例**
```
场景：用户A转账给用户B
原始状态：A=1000，B=500

事务开始：
Step1：记录Undo(A=1000) → 修改A=900
Step2：记录Undo(B=500) → 修改B=600
Step3：检查A余额，发现不足 → 事务回滚

回滚过程：
根据Undo日志：B恢复为500，A恢复为1000
最终状态：A=1000，B=500（回到原始状态）
```

---

## 5. 🔧 Undo日志工作原理


### 5.1 Undo日志记录格式


**📋 Undo记录结构**
```
┌─────────────────────────────────────┐
│              记录头                  │
├─────────────────────────────────────┤
│ 事务ID | 回滚指针 | 记录类型        │
├─────────────────────────────────────┤
│           主键信息                   │
├─────────────────────────────────────┤
│           修改前的值                 │
│         (old values)                │
└─────────────────────────────────────┘
```

### 5.2 版本链机制


**🔗 多版本链表**
```
同一行数据的版本链：

最新版本 ──回滚指针──→ 版本2 ──回滚指针──→ 版本1
   ↓                     ↓               ↓
name='李四'           name='张三'      name='王五'
age=26               age=25           age=24
trx_id=100          trx_id=99        trx_id=98

不同事务看到不同版本：
• 事务100：看到最新版本（李四，26）
• 事务99：看到版本2（张三，25）
• 事务98：看到版本1（王五，24）
```

### 5.3 Undo页面管理


**💾 Undo段结构**
```
Undo表空间
    ↓
Undo段（每个事务一个）
    ↓
Undo页面链表
    ↓
┌─────────┐    ┌─────────┐    ┌─────────┐
│ Undo页1 │───→│ Undo页2 │───→│ Undo页3 │
└─────────┘    └─────────┘    └─────────┘

特点：
• 链表结构：支持动态扩展
• 事务隔离：每个事务独立的Undo段
• 空间复用：事务提交后可以复用空间
```

---

## 6. 💾 日志刷盘机制


### 6.1 缓冲区管理


**🔄 日志缓冲区结构**
```
内存中的日志系统：

应用程序 ──写入──→ Redo Log Buffer ──刷盘──→ Redo Log Files
                        ↓
                   定期/触发刷盘
                        ↓
                    磁盘文件系统
```

### 6.2 刷盘时机


**⏰ 何时将日志写入磁盘**

| 触发条件 | **说明** | **频率** |
|----------|----------|----------|
| `事务提交` | 保证持久性，必须刷盘 | 每次提交 |
| `缓冲区满` | 日志缓冲区空间不足 | 动态触发 |
| `定时刷新` | 定期刷新，避免丢失 | 每秒一次 |
| `检查点` | 配合脏页刷新 | 定期触发 |

### 6.3 刷盘策略配置


**⚙️ innodb_flush_log_at_trx_commit参数**

```
参数值：0
行为：事务提交时不立即刷盘，每秒刷一次
优势：性能最好
风险：可能丢失1秒内的事务 ⚠️

参数值：1（默认）
行为：每次事务提交都刷盘
优势：最安全，不丢数据 ✅
劣势：性能稍差

参数值：2  
行为：提交时写入OS缓存，每秒刷盘
优势：性能和安全的平衡
风险：MySQL崩溃不丢数据，OS崩溃可能丢失
```

---

## 7. 🛠️ 崩溃恢复机制


### 7.1 恢复流程概览


**🔄 系统重启后的恢复过程**
```
系统启动
    ↓
读取最后一个检查点
    ↓
从检查点开始扫描Redo日志
    ↓
┌─────────────────┐
│   重做阶段      │ ← 应用所有Redo日志
│  (Redo Phase)   │   恢复已提交事务的修改
└─────────────────┘
    ↓
┌─────────────────┐
│   回滚阶段      │ ← 回滚所有未提交事务
│ (Rollback Phase)│   根据Undo日志撤销修改
└─────────────────┘
    ↓
系统正常运行
```

### 7.2 重做阶段详解


**⚡ Redo阶段工作原理**
```
目标：恢复所有已提交事务的修改

步骤：
1. 从检查点LSN开始读取日志
2. 解析每条Redo记录
3. 重新执行页面修改操作
4. 不管事务是否提交，先全部重做

示例：
日志1：事务A修改页面P1
日志2：事务B修改页面P2  
日志3：事务A提交
日志4：事务B修改页面P3（未提交）

重做阶段：执行日志1、2、4的修改
```

### 7.3 回滚阶段详解


**🔙 Rollback阶段工作原理**
```
目标：撤销所有未提交事务的修改

步骤：
1. 找出所有未提交的事务
2. 根据Undo日志链表回滚修改
3. 从最新修改开始，逐步往前撤销

示例（接上面）：
事务B未提交，需要回滚：
- 撤销日志4的修改
- 撤销日志2的修改
- 事务B完全消失

最终结果：只有事务A的修改被保留
```

---

## 8. 🚀 性能优化策略


### 8.1 日志写入优化


**📈 提升日志性能的方法**

```
🔧 组提交（Group Commit）：
原理：多个事务的日志一起写入磁盘
好处：减少磁盘IO次数，提升吞吐量

示例：
事务A、B、C同时提交
传统方式：3次磁盘写入
组提交：1次磁盘写入（合并写入）

🔧 并行日志写入：
原理：多个线程同时处理日志
适用：高并发场景
```

### 8.2 缓冲区调优


**💾 关键参数优化**

| 参数 | **作用** | **建议值** |
|------|----------|------------|
| `innodb_log_buffer_size` | 日志缓冲区大小 | 64MB-256MB |
| `innodb_log_file_size` | 单个日志文件大小 | 1GB-4GB |
| `innodb_log_files_in_group` | 日志文件个数 | 2-4个 |

### 8.3 压缩技术


**🗜️ 日志压缩机制**
```
压缩原理：
• 重复模式识别：相同的修改模式只记录一次
• 增量记录：只记录变化的部分
• 批量操作合并：连续的修改操作合并记录

压缩效果：
• 减少日志文件大小 50%-70%
• 减少网络传输量（主从复制）
• 提升IO性能
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Redo日志：保证事务持久性，记录数据修改操作
🔸 Undo日志：支持事务回滚和MVCC，记录修改前原值
🔸 WAL机制：日志先于数据写入，保证数据一致性
🔸 LSN机制：全局唯一的日志序列号，用于位置标识
🔸 检查点：定期刷新脏页，缩短恢复时间
🔸 崩溃恢复：先重做后回滚，保证数据完整性
```

### 9.2 关键理解要点


**🔹 为什么需要两种日志**
```
Redo日志：向前恢复
• 记录"做了什么"
• 用于重新执行已提交事务
• 保证不丢失数据

Undo日志：向后恢复  
• 记录"之前是什么"
• 用于撤销未提交事务
• 保证不出现脏数据

两者配合：既不丢失，也不出错
```

**🔹 性能与安全的平衡**
```
安全优先：
innodb_flush_log_at_trx_commit = 1
每次提交都刷盘，最安全但性能稍差

性能优先：
innodb_flush_log_at_trx_commit = 0  
定时刷盘，性能好但可能丢失数据

折中方案：
innodb_flush_log_at_trx_commit = 2
写入OS缓存，平衡性能和安全
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **金融系统**：严格的事务保证，设置最安全的刷盘策略
- **日志系统**：允许少量丢失，可以选择性能优先配置  
- **电商系统**：核心交易表安全优先，日志表性能优先

**🔧 运维实践**
- **监控指标**：关注日志文件大小、刷盘频率、恢复时间
- **容量规划**：根据业务量估算日志空间需求
- **故障处理**：理解恢复流程，快速定位问题

**核心记忆口诀**：
- Redo向前走，Undo往后退
- WAL原则先写日志，LSN标记全局序号  
- 检查点定期清理，崩溃恢复先做后撤
- 安全性能要平衡，参数调优看场景