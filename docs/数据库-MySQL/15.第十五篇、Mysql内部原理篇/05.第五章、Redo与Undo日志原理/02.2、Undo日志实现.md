---
title: 2、Undo日志实现
---
## 📚 目录

1. [Undo日志基本概念](#1-undo日志基本概念)
2. [撤销日志结构详解](#2-撤销日志结构详解)
3. [事务回滚机制](#3-事务回滚机制)
4. [MVCC版本链原理](#4-mvcc版本链原理)
5. [Undo段管理](#5-undo段管理)
6. [版本可见性算法](#6-版本可见性算法)
7. [Undo日志优化机制](#7-undo日志优化机制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📝 Undo日志基本概念


### 1.1 什么是Undo日志


**💡 简单理解**
```
想象你在写作业时用铅笔：
• 写错了可以用橡皮擦掉
• Undo日志就像是"数据库的橡皮擦"
• 记录每次修改前的原始数据
• 需要时可以"擦掉"错误的修改
```

**🔸 核心定义**
```
Undo日志：记录事务对数据修改前的原始值
作用：支持事务回滚和MVCC多版本并发控制
存储：独立的Undo表空间中
生命周期：从事务开始到版本不再需要
```

### 1.2 Undo日志的两大作用


**🔄 事务回滚**
```
场景：银行转账操作失败需要撤销
原理：通过Undo日志恢复到修改前的状态

示例：
修改前：账户A余额 = 1000元
修改后：账户A余额 = 500元  
回滚时：通过Undo日志恢复到1000元
```

**👀 MVCC快照读**
```
场景：多个事务同时读写同一数据
原理：通过版本链提供一致性快照

示例：
事务1正在修改数据
事务2读取时看到修改前的版本
互不干扰，提高并发性能
```

### 1.3 Undo日志 vs Redo日志对比


| 特性 | **Undo日志** | **Redo日志** |
|------|-------------|-------------|
| **记录内容** | `修改前的旧值` | `修改后的新值` |
| **主要作用** | `事务回滚 + MVCC` | `崩溃恢复 + 持久化` |
| **何时写入** | `修改数据前` | `提交事务时` |
| **清理时机** | `版本不再需要` | `checkpoint后` |

---

## 2. 🏗️ 撤销日志结构详解


### 2.1 Undo日志记录结构


**📋 基本记录格式**
```
┌─────────────┬──────────────┬─────────────┬──────────────┐
│ Undo Header │ 事务信息     │ 操作类型    │ 原始数据     │
├─────────────┼──────────────┼─────────────┼──────────────┤
│ 8字节       │ 事务ID等     │ INSERT/UPDATE│ 修改前的值   │
└─────────────┴──────────────┴─────────────┴──────────────┘
```

**🔸 关键字段说明**
```
事务ID（Transaction ID）：
• 标识产生此Undo记录的事务
• 用于版本可见性判断
• 在整个MySQL实例中唯一

回滚指针（Roll Pointer）：
• 指向上一个Undo记录的位置
• 形成版本链的关键
• 8字节存储空间

原始数据：
• 记录修改前的完整行数据
• 支持完全回滚操作
• 大小根据行数据动态变化
```

### 2.2 Undo页面结构


**📄 页面布局**
```
┌─────────────────────────────────────┐
│         页面头部 (38字节)            │  ← 页面基本信息
├─────────────────────────────────────┤
│       Undo段头部 (可变长度)          │  ← 段管理信息
├─────────────────────────────────────┤
│                                     │
│         Undo记录区域                │  ← 实际的Undo记录
│        (从页面尾部向前增长)           │
│                                     │
├─────────────────────────────────────┤
│         页面尾部 (8字节)             │  ← 校验信息
└─────────────────────────────────────┘
```

**💾 页面头部关键信息**
```cpp
// 简化的页面头部结构
struct UndoPageHeader {
    uint32_t page_no;         // 页面编号
    uint32_t prev_page;       // 上一个页面
    uint32_t next_page;       // 下一个页面
    uint16_t free_space;      // 剩余空间
    uint16_t record_count;    // 记录数量
};
```

### 2.3 版本链维护机制


**🔗 版本链形成过程**
```
初始状态：
行记录: [ID=1, Name="张三", Age=25, TRX_ID=100, ROLL_PTR=NULL]

第一次修改（事务101）：
1. 生成Undo记录：[TRX_ID=100, Name="张三", Age=25]
2. 更新行记录：[ID=1, Name="李四", Age=25, TRX_ID=101, ROLL_PTR=undo_ptr1]

第二次修改（事务102）：
1. 生成Undo记录：[TRX_ID=101, Name="李四", Age=25, ROLL_PTR=undo_ptr1]
2. 更新行记录：[ID=1, Name="王五", Age=26, TRX_ID=102, ROLL_PTR=undo_ptr2]

版本链：
当前记录 → Undo记录2 → Undo记录1 → 历史版本
```

---

## 3. 🔄 事务回滚机制


### 3.1 回滚操作原理


**🎯 回滚的本质**
```
回滚就是"倒带"操作：
• 从最新的Undo记录开始
• 按照版本链逆向应用操作
• 恢复到事务开始前的状态
```

**📖 回滚算法步骤**
```
1. 获取事务的Undo记录链表头
2. 遍历该事务的所有Undo记录
3. 对每个记录执行反向操作：
   - INSERT记录 → 执行DELETE
   - UPDATE记录 → 恢复旧值
   - DELETE记录 → 重新插入
4. 释放事务的Undo段资源
```

### 3.2 不同操作的回滚策略


**📝 INSERT操作回滚**
```sql
-- 原始操作
INSERT INTO users VALUES (1, '张三', 25);

-- 回滚操作
DELETE FROM users WHERE id = 1;

Undo记录内容：
• 操作类型：INSERT
• 主键值：id=1
• 回滚时直接删除该记录
```

**✏️ UPDATE操作回滚**
```sql
-- 原始操作
UPDATE users SET name='李四', age=26 WHERE id=1;

-- 回滚操作
UPDATE users SET name='张三', age=25 WHERE id=1;

Undo记录内容：
• 操作类型：UPDATE
• 主键值：id=1
• 原始值：name='张三', age=25
```

**🗑️ DELETE操作回滚**
```sql
-- 原始操作
DELETE FROM users WHERE id=1;

-- 回滚操作
INSERT INTO users VALUES (1, '张三', 25);

Undo记录内容：
• 操作类型：DELETE
• 完整的行数据
• 包括所有列的原始值
```

### 3.3 回滚性能优化


**⚡ 快速回滚技巧**
```
批量操作优化：
• 将相同表的操作归组
• 减少页面切换开销
• 批量应用Undo记录

内存优化：
• 缓存热点Undo页面
• 减少磁盘I/O操作
• 预读相关页面
```

---

## 4. 👁️ MVCC版本链原理


### 4.1 MVCC基本概念


**💭 生活类比**
```
图书馆的书籍管理：
• 一本书可能有多个版本（第1版、第2版...）
• 读者可以选择读任意版本
• 新版本不影响正在阅读旧版本的读者
• MVCC就是数据库中的"版本管理系统"
```

**🔸 核心机制**
```
多版本并发控制（MVCC）：
• 每行数据维护多个版本
• 不同事务看到不同版本
• 读写操作互不阻塞
• 通过版本链实现一致性读
```

### 4.2 版本链的构建过程


**🔗 版本链示例**
```
假设对用户表进行多次修改：

时间线：T1 → T2 → T3

T1时刻（事务100）：
行数据：[id=1, name="张三", age=25, trx_id=100, roll_ptr=NULL]

T2时刻（事务101修改）：
新Undo：[trx_id=100, name="张三", age=25]
行数据：[id=1, name="李四", age=25, trx_id=101, roll_ptr=&undo1]

T3时刻（事务102修改）：
新Undo：[trx_id=101, name="李四", age=25, roll_ptr=&undo1]
行数据：[id=1, name="王五", age=26, trx_id=102, roll_ptr=&undo2]

版本链：
当前版本 → Undo2 → Undo1 → 原始版本
```

### 4.3 快照读实现机制


**📸 快照读原理**
```
快照读（Snapshot Read）：
• 读取事务开始时的数据快照
• 不会被其他事务的修改影响
• 通过Read View机制实现
• 保证读取的一致性
```

**🔍 Read View工作过程**
```
1. 事务开始时创建Read View
2. 记录当前活跃事务列表
3. 读取数据时检查版本可见性
4. 沿着版本链找到合适版本

Read View结构：
• m_ids：活跃事务ID列表
• min_trx_id：最小活跃事务ID
• max_trx_id：下一个事务ID
• creator_trx_id：创建者事务ID
```

---

## 5. 🗂️ Undo段管理


### 5.1 Undo段基本概念


**📁 段的概念**
```
数据库中的"段"类似文件系统中的"文件夹"：
• 管理相关页面的集合
• Undo段专门管理Undo页面
• 提供统一的分配和回收机制
```

**🏗️ Undo段结构**
```
┌─────────────────────────────────────┐
│            段头页面                  │  ← 段的元数据信息
├─────────────────────────────────────┤
│                                     │
│            数据页面1                │  ← Undo记录存储
│                                     │
├─────────────────────────────────────┤
│            数据页面2                │
├─────────────────────────────────────┤
│              ...                    │
└─────────────────────────────────────┘
```

### 5.2 Undo段分配策略


**📊 分配算法**
```
普通事务分配：
• 轮询方式分配可用段
• 避免热点段过度使用
• 支持段的动态扩展

大事务优化：
• 专门分配独立段
• 避免影响小事务性能
• 支持并行回滚操作
```

**⚙️ 段分配代码示例**
```cpp
// 简化的段分配逻辑
UndoSegment* allocate_undo_segment(Transaction* trx) {
    if (trx->is_large_transaction()) {
        // 大事务分配专用段
        return allocate_dedicated_segment();
    } else {
        // 普通事务使用共享段
        return get_shared_segment(trx->get_id() % segment_count);
    }
}
```

### 5.3 段空间管理


**💾 空间回收机制**
```
段空间状态：
• Active：正在使用的段
• Cached：可复用的空段
• Free：完全释放的段

回收时机：
• 事务提交后立即回收
• 版本不再需要时回收
• 系统空间不足时强制回收
```

**🔄 段重用策略**
```
重用优先级：
1. 优先使用Cached状态的段
2. 其次分配新的Free段
3. 最后扩展表空间

好处：
• 减少段创建开销
• 提高空间利用率
• 降低碎片产生
```

---

## 6. 🔍 版本可见性算法


### 6.1 可见性判断原理


**🧠 核心思想**
```
版本可见性就是回答："这个版本的数据我能看到吗？"

判断依据：
• 版本的事务ID
• 当前事务的Read View
• 版本的提交状态
```

**📋 可见性判断流程**
```
检查步骤：
1. 版本是否由当前事务创建？ → 可见
2. 版本事务是否已提交？ → 不可见（如果未提交）
3. 版本事务是否在Read View创建前提交？ → 可见
4. 版本事务是否在活跃事务列表中？ → 不可见
5. 沿版本链继续查找
```

### 6.2 Read View机制详解


**📖 Read View创建时机**
```
READ COMMITTED（读已提交）：
• 每次SELECT都创建新的Read View
• 能读到其他事务已提交的修改
• 存在不可重复读问题

REPEATABLE READ（可重复读）：
• 事务第一次读取时创建Read View
• 整个事务期间使用同一个Read View
• 避免不可重复读和幻读
```

**🔍 可见性算法实现**
```cpp
// 简化的可见性判断算法
bool is_version_visible(trx_id_t version_trx_id, ReadView* view) {
    // 1. 自己创建的版本总是可见
    if (version_trx_id == view->creator_trx_id) {
        return true;
    }
    
    // 2. 版本太新，不可见
    if (version_trx_id >= view->max_trx_id) {
        return false;
    }
    
    // 3. 版本很老，可见
    if (version_trx_id < view->min_trx_id) {
        return true;
    }
    
    // 4. 检查是否在活跃事务列表中
    return !view->is_active(version_trx_id);
}
```

### 6.3 版本链遍历过程


**🔗 查找可见版本**
```
查找算法：
1. 从当前记录开始
2. 检查版本可见性
3. 如果不可见，沿roll_ptr找上一版本
4. 重复步骤2-3，直到找到可见版本
5. 如果到链表末尾仍无可见版本，返回NULL

示例：
当前版本（事务102，不可见）
    ↓ roll_ptr
Undo版本1（事务101，不可见）
    ↓ roll_ptr  
Undo版本2（事务100，可见）← 返回此版本
```

---

## 7. ⚡ Undo日志优化机制


### 7.1 Undo日志压缩


**🗜️ 压缩原理**
```
为什么需要压缩？
• Undo日志占用大量存储空间
• 长时间运行的事务产生海量日志
• 压缩可以显著节省空间

压缩时机：
• 页面利用率低于阈值时
• 系统空间不足时
• 定期后台压缩任务
```

**📊 压缩策略**
```
相同记录合并：
• 多次UPDATE同一行的Undo记录
• 可以合并为一个记录
• 保留最早的原始值即可

无用记录清理：
• 已经没有事务需要的版本
• 可以直接删除释放空间
• 通过最老活跃事务判断
```

### 7.2 历史版本清理


**🧹 清理触发条件**
```
版本清理的时机：
• 所有事务都不再需要某个版本
• 系统中最老的活跃事务已经超过该版本
• 定期的purge线程清理任务

清理策略：
• 从版本链尾部开始清理
• 保留仍有事务需要的版本
• 释放页面空间供新分配使用
```

**⚙️ Purge线程工作机制**
```
Purge线程职责：
1. 扫描需要清理的Undo记录
2. 判断版本是否可以安全删除
3. 物理删除无用的Undo记录
4. 回收释放的页面空间
5. 更新版本链指针

工作流程：
定期唤醒 → 扫描Undo → 判断可见性 → 删除记录 → 回收空间
```

### 7.3 长事务监控


**⚠️ 长事务的危害**
```
长事务问题：
• 阻止Undo日志清理
• 导致版本链过长
• 影响查询性能
• 占用大量存储空间

监控指标：
• 事务持续时间
• 产生的Undo日志大小
• 影响的版本链长度
```

**📊 监控和告警**
```sql
-- 查找长时间运行的事务
SELECT 
    trx_id,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_seconds,
    trx_rows_modified
FROM information_schema.innodb_trx 
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300;

-- 查看Undo表空间使用情况
SELECT 
    tablespace_name,
    file_size / 1024 / 1024 as size_mb,
    allocated_size / 1024 / 1024 as allocated_mb
FROM information_schema.files 
WHERE tablespace_name LIKE '%undo%';
```

### 7.4 Undo表空间管理


**🗄️ 表空间结构**
```
Undo表空间组织：
┌─────────────────┐
│   表空间头部    │  ← 表空间元数据
├─────────────────┤
│                 │
│     段目录      │  ← 段分配信息
│                 │
├─────────────────┤
│                 │
│   Undo段1       │  ← 实际存储区域
│                 │
├─────────────────┤
│   Undo段2       │
├─────────────────┤
│      ...        │
└─────────────────┘
```

**⚙️ 自动扩展机制**
```
扩展触发条件：
• 表空间使用率超过阈值（如90%）
• 无法分配新的Undo段
• 系统检测到空间不足

扩展策略：
• 自动增加数据文件大小
• 创建新的数据文件
• 动态调整扩展增量
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Undo日志本质：记录修改前原始值的"撤销日志"
🔸 双重作用：支持事务回滚 + 实现MVCC多版本控制
🔸 版本链机制：通过roll_ptr形成历史版本链表
🔸 可见性算法：基于Read View判断版本是否可见
🔸 段管理：Undo段统一管理相关页面和空间分配
```

### 8.2 关键理解要点


**🔹 Undo日志与事务回滚**
```
回滚的本质：
• 不是"撤销"操作，而是"反向"操作
• INSERT的反向是DELETE
• UPDATE的反向是恢复旧值
• DELETE的反向是重新插入
```

**🔹 MVCC的核心价值**
```
并发控制的革命：
• 读写操作不相互阻塞
• 每个事务看到一致的数据快照
• 大幅提升系统并发性能
• 解决了传统锁机制的性能瓶颈
```

**🔹 版本可见性的判断逻辑**
```
简化的判断规则：
• 自己创建的版本 → 可见
• 未提交的版本 → 不可见
• 太新的版本 → 不可见
• 活跃事务的版本 → 不可见
• 其他情况 → 可见
```

### 8.3 实际应用价值


**🎯 性能优化场景**
- **高并发读写**：MVCC避免读写锁竞争
- **长时间查询**：快照读保证数据一致性
- **数据分析**：不影响在线事务处理
- **备份操作**：一致性快照备份

**🔧 故障处理场景**
- **事务回滚**：系统故障后自动恢复
- **应用错误**：手动回滚错误操作
- **数据修复**：基于历史版本恢复数据

**📊 监控运维重点**
```
关键监控指标：
• Undo表空间使用率
• 长事务持续时间
• 版本链平均长度
• Purge线程清理效率

优化建议：
• 避免长时间运行的事务
• 合理设置事务隔离级别
• 监控Undo表空间增长
• 定期分析系统性能
```

### 8.4 学习路径建议


```
📚 基础学习路径：
事务基础概念 → MVCC原理 → Undo日志结构 → 版本可见性算法

🔧 实践操作：
搭建测试环境 → 观察Undo日志变化 → 分析版本链结构 → 监控性能指标

🚀 进阶学习：
源码分析 → 性能调优 → 故障排查 → 容量规划
```

**核心记忆口诀**：
- Undo日志双重要，回滚MVCC都需要
- 版本链条串历史，可见算法定规矩  
- 段管空间统一控，清理压缩性能好
- 长事务害要监控，表空间管理不可少