---
title: 8、Mini_transaction机制
---
## 📚 目录

1. [Mini-transaction基本概念](#1-Mini-transaction基本概念)
2. [mtr生命周期管理](#2-mtr生命周期管理)
3. [日志记录原子性保障](#3-日志记录原子性保障)
4. [页面修改保护机制](#4-页面修改保护机制)
5. [mtr提交流程详解](#5-mtr提交流程详解)
6. [锁资源管理策略](#6-锁资源管理策略)
7. [内存页面同步机制](#7-内存页面同步机制)
8. [mtr高级特性](#8-mtr高级特性)
9. [性能优化与监控](#9-性能优化与监控)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 Mini-transaction基本概念


### 1.1 什么是Mini-transaction


**🔸 核心定义**
```
Mini-transaction（简称mtr）：MySQL InnoDB中的原子操作单元
作用：确保对数据页的修改操作具有原子性
目标：将相关的页面修改操作打包成一个不可分割的整体
```

**💡 通俗理解**
想象你在银行转账，需要同时修改两个账户余额：
- 传统方式：先改A账户-100，再改B账户+100（中间可能出错）
- mtr方式：把两个操作打包，要么都成功，要么都失败

```
现实场景对比：
普通操作：    修改页面1 → 修改页面2 → 修改页面3
            ↓可能失败   ↓可能失败   ↓可能失败

mtr操作：     [修改页面1 + 修改页面2 + 修改页面3]
            ↓要么全成功，要么全失败（原子性）
```

### 1.2 为什么需要mtr


**🔸 解决的核心问题**
```
问题1：页面修改的一致性
- B+树分裂时需要修改多个页面
- 如果只修改了一半就崩溃，数据结构被破坏

问题2：日志记录的完整性  
- 相关的修改操作需要一起记录到redo日志
- 保证恢复时能正确重做所有相关操作

问题3：并发访问的安全性
- 多个线程同时修改相关页面
- 需要保护修改过程不被其他线程干扰
```

**💭 生活例子**
就像装修房子：
- 不能只刷一半墙就停工（数据不一致）
- 不能让别人进来干扰施工（并发保护）
- 要么装修完成，要么恢复原样（原子性）

### 1.3 mtr的基本特征


**✅ 原子性保障**
```
要么成功：所有页面修改都生效
要么失败：所有修改都回滚到修改前状态
中间状态：对外部不可见
```

**🔒 并发控制**
```
页面锁定：修改期间锁定相关页面
资源保护：防止其他事务干扰
隔离保证：修改过程与其他操作隔离
```

**📝 日志一致性**
```
完整记录：所有修改操作都记录到redo日志
顺序保证：日志记录顺序与操作顺序一致
原子提交：日志要么全部写入，要么全部不写入
```

---

## 2. 🔄 mtr生命周期管理


### 2.1 mtr创建阶段


**🔸 初始化过程**
```cpp
// mtr创建的基本流程
class mtr_t {
private:
    mtr_buf_t m_memo;        // 记录访问的页面
    mtr_buf_t m_log;         // 存储redo日志
    mtr_state_t m_state;     // mtr当前状态
    
public:
    void start() {
        m_state = MTR_STATE_ACTIVE;
        m_memo.clear();
        m_log.clear();
    }
};
```

**💡 创建时机**
- 执行任何可能修改页面的操作前
- 包括索引查找、插入、删除、更新操作
- B+树结构调整（分裂、合并）操作

**🎯 初始状态设置**
```
状态标记：MTR_STATE_ACTIVE（活跃状态）
内存清理：清空日志缓冲区和页面记录
锁资源：初始化锁管理结构
```

### 2.2 mtr执行阶段


**🔸 页面访问管理**
```cpp
// 页面访问的典型流程
buf_block_t* mtr_get_page(page_id_t page_id, mtr_t* mtr) {
    // 1. 从缓冲池获取页面
    buf_block_t* block = buf_page_get(page_id);
    
    // 2. 加锁保护页面
    mtr_memo_push(mtr, block, MTR_MEMO_PAGE_X_FIX);
    
    // 3. 标记页面为脏页
    buf_page_set_dirty(block);
    
    return block;
}
```

**🔒 锁定机制**
```
页面级锁：防止其他线程修改同一页面
读写锁：区分读取和修改操作
锁升级：根据需要升级锁级别
```

**📝 修改记录**
```
实时记录：每次页面修改都生成redo日志
缓存存储：暂存在mtr的日志缓冲区
延迟写入：等待mtr提交时统一写入
```

### 2.3 mtr结束阶段


**🔸 正常提交流程**
```
第一步：检查mtr状态和完整性
第二步：将日志写入全局redo日志缓冲区
第三步：释放所有持有的页面锁
第四步：标记mtr为提交状态
```

**⚠️ 异常回滚处理**
```
检测异常：发现操作失败或系统错误
恢复状态：将修改的页面恢复到原始状态
释放资源：释放所有锁定的资源
清理痕迹：清除相关的日志记录
```

---

## 3. 📝 日志记录原子性保障


### 3.1 redo日志生成机制


**🔸 日志记录时机**
```
修改前记录：在实际修改页面之前先生成日志
实时生成：每个修改操作都立即生成对应日志
缓存存储：日志先存储在mtr的本地缓冲区
```

**💡 日志记录内容**
```
页面标识：被修改页面的ID和类型
修改位置：页面内具体修改的偏移量
原始值：修改前的数据内容（用于回滚）
新值：修改后的数据内容（用于重做）
操作类型：插入、删除、更新等操作标识
```

**🔧 日志格式示例**
```
日志类型：MLOG_REC_INSERT
页面ID：space_id=1, page_no=100
偏移量：offset=256
数据长度：len=64
记录内容：[实际插入的记录数据]
```

### 3.2 日志原子性实现


**🔸 本地缓存机制**
```cpp
// mtr内部日志缓存
class mtr_buf_t {
    byte* m_data;        // 日志数据缓冲区
    ulint m_size;        // 当前日志大小
    ulint m_used;        // 已使用空间
    
public:
    void push(const byte* data, ulint len) {
        // 追加日志到本地缓冲区
        memcpy(m_data + m_used, data, len);
        m_used += len;
    }
};
```

**⚡ 原子提交保证**
```
关键原理：
1. 所有日志先在mtr内部缓存
2. 提交时一次性写入全局日志缓冲区  
3. 全局日志缓冲区原子地刷入磁盘
4. 确保要么全部写入，要么全部不写入
```

**🎯 日志一致性检查**
```
LSN编号：每条日志都有唯一的日志序列号
校验和：确保日志内容完整性
顺序检查：确保日志顺序正确
完整性验证：确保相关日志全部存在
```

### 3.3 与全局日志系统的交互


**🔸 日志提交流程**
```
步骤1：mtr准备提交时，获取全局日志互斥锁
步骤2：分配连续的LSN序列号段
步骤3：将mtr的所有日志复制到全局缓冲区
步骤4：更新全局日志写入位置
步骤5：释放全局日志互斥锁
```

**🔄 批量优化机制**
```
日志合并：多个小的mtr日志可以批量提交
写入优化：减少磁盘写入次数
缓冲区管理：合理利用内存缓冲区空间
```

---

## 4. 🛡️ 页面修改保护机制


### 4.1 页面锁定策略


**🔸 锁定类型分类**
```
MTR_MEMO_PAGE_S_FIX：共享锁（读取）
MTR_MEMO_PAGE_X_FIX：排他锁（修改）
MTR_MEMO_PAGE_SX_FIX：共享排他锁（特殊场景）
```

**🔒 锁定时机控制**
```
获取时机：访问页面时立即获取锁
持有期间：整个mtr生命周期
释放时机：mtr提交或回滚时释放
```

**💡 通俗理解**
就像借书：
- 共享锁：多人可以同时看同一本书（只读）
- 排他锁：只有一人可以修改这本书（读写）
- 锁定期间：从借书到还书的整个过程

### 4.2 页面状态管理


**🔸 脏页标记机制**
```cpp
// 页面修改时的状态更新
void mtr_memo_page_dirty(mtr_t* mtr, buf_block_t* block) {
    // 1. 标记页面为脏页
    buf_page_set_dirty(block);
    
    // 2. 记录最新修改的LSN
    block->newest_modification = log_get_lsn();
    
    // 3. 添加到mtr的修改列表
    mtr_memo_push(mtr, block, MTR_MEMO_PAGE_X_FIX);
}
```

**📊 页面版本控制**
```
修改前LSN：记录页面修改前的日志序列号
修改后LSN：记录页面修改后的日志序列号
版本一致性：确保页面版本与日志版本匹配
```

**🎯 状态检查机制**
```
修改检测：检查页面是否被其他事务修改
冲突检测：检测是否存在锁冲突
一致性验证：验证页面状态的合法性
```

### 4.3 并发访问控制


**🔸 读写隔离机制**
```
读操作：可以并发执行，不相互影响
写操作：必须串行化，防止数据竞争
读写冲突：写操作会阻塞读操作
写写冲突：后续写操作必须等待前面的完成
```

**⚡ 死锁预防策略**
```
锁顺序：按固定顺序获取多个页面锁
超时机制：避免长时间等待锁
死锁检测：检测并打破死锁环路
资源释放：及时释放不再需要的锁
```

**🔧 锁升级机制**
```cpp
// 锁升级的典型场景
if (current_lock == MTR_MEMO_PAGE_S_FIX && need_modify) {
    // 从共享锁升级到排他锁
    upgrade_to_x_lock(block);
    mtr_memo_update(mtr, block, MTR_MEMO_PAGE_X_FIX);
}
```

---

## 5. ✅ mtr提交流程详解


### 5.1 提交前准备阶段


**🔸 状态检查验证**
```cpp
bool mtr_can_commit(mtr_t* mtr) {
    // 1. 检查mtr状态是否正常
    if (mtr->m_state != MTR_STATE_ACTIVE) {
        return false;
    }
    
    // 2. 检查日志完整性
    if (!validate_log_integrity(mtr)) {
        return false;
    }
    
    // 3. 检查页面锁状态
    return validate_page_locks(mtr);
}
```

**📝 日志整理工作**
```
日志排序：按页面ID和偏移量排序日志记录
重复检查：检查是否有重复的日志记录
完整性验证：确保所有修改都有对应日志
压缩优化：合并可以合并的日志记录
```

**🎯 资源统计信息**
```
页面数量：统计涉及的页面总数
日志大小：计算生成的日志总大小
锁资源：统计持有的锁资源数量
```

### 5.2 日志提交阶段


**🔸 获取全局锁**
```cpp
void mtr_commit_to_log(mtr_t* mtr) {
    // 1. 获取全局日志系统锁
    log_buffer_reserve(mtr->log_size);
    
    // 2. 分配LSN序列号
    lsn_t start_lsn = log_get_lsn();
    
    // 3. 复制日志到全局缓冲区
    log_buffer_write(mtr->m_log.data, mtr->m_log.size);
    
    // 4. 更新LSN指针
    log_set_lsn(start_lsn + mtr->m_log.size);
}
```

**⚡ 批量写入优化**
```
缓冲区管理：合理利用全局日志缓冲区
写入策略：批量写入减少系统调用
刷盘控制：根据事务需求决定是否立即刷盘
```

**🔄 原子性保证**
```
关键步骤：
1. 日志要么全部写入，要么全部不写入
2. 写入过程中持有全局锁，确保原子性
3. 写入完成后才更新LSN指针
4. 其他事务只能看到完整的日志记录
```

### 5.3 资源释放阶段


**🔸 页面锁释放**
```cpp
void mtr_release_page_locks(mtr_t* mtr) {
    mtr_memo_slot_t* slot;
    
    // 遍历所有持有的页面锁
    for (slot = mtr_memo_get_first(mtr); slot != NULL; 
         slot = mtr_memo_get_next(slot)) {
        
        if (slot->type & MTR_MEMO_PAGE_X_FIX) {
            // 释放排他锁
            buf_page_release_latch(slot->object);
        }
    }
}
```

**🧹 内存清理工作**
```
缓冲区清理：清空mtr的日志缓冲区
状态重置：将mtr状态设置为未活跃
内存释放：释放分配的临时内存
```

**📊 统计信息更新**
```
性能统计：更新mtr执行时间统计
资源统计：更新页面访问统计
错误统计：更新失败次数统计
```

---

## 6. 🔐 锁资源管理策略


### 6.1 锁的层次结构


**🔸 锁粒度分类**
```
页面级锁：保护整个数据页
记录级锁：保护页面内的具体记录
间隙锁：保护记录之间的空隙
表级锁：保护整个表（特殊情况）
```

**🎯 锁的兼容性矩阵**
```
      | S锁  | X锁  | SX锁
------|------|------|------
S锁   | ✅   | ❌   | ✅
X锁   | ❌   | ❌   | ❌ 
SX锁  | ✅   | ❌   | ❌

S：共享锁    X：排他锁    SX：共享排他锁
```

**💡 生活场景类比**
```
共享锁(S)：图书馆看书，多人可以同时看
排他锁(X)：私人书房写作，只能一人使用
共享排他锁(SX)：编辑文档，可以看但不能同时编辑
```

### 6.2 锁获取策略


**🔸 锁获取顺序**
```cpp
// 避免死锁的锁获取顺序
void mtr_get_multiple_pages(page_id_t* pages, int count, mtr_t* mtr) {
    // 1. 按页面ID排序
    sort_pages_by_id(pages, count);
    
    // 2. 按顺序获取锁
    for (int i = 0; i < count; i++) {
        buf_block_t* block = buf_page_get_gen(pages[i], RW_X_LATCH, mtr);
    }
}
```

**⏱️ 锁等待与超时**
```
等待策略：如果锁不可用，进入等待队列
超时设置：避免无限期等待
公平调度：按先后顺序分配锁资源
优先级：重要事务可以有更高优先级
```

**🔄 锁升级机制**
```
升级条件：从读操作变为写操作时
升级过程：先释放低级别锁，再获取高级别锁
原子升级：确保升级过程的原子性
失败处理：升级失败时的回退策略
```

### 6.3 死锁检测与处理


**🔸 死锁检测算法**
```
等待图构建：构建事务间的等待关系图
环路检测：检测等待图中是否存在环路
victim选择：选择合适的事务作为死锁受害者
回滚处理：回滚受害者事务以打破死锁
```

**⚠️ 死锁预防策略**
```
锁顺序：强制按固定顺序获取锁
超时机制：设置合理的锁等待超时时间
资源预分配：事务开始时预先获取所需锁
小事务优先：优先执行小的快速事务
```

**🔧 死锁恢复机制**
```cpp
void handle_deadlock(mtr_t* mtr) {
    // 1. 检测到死锁
    if (deadlock_detected(mtr)) {
        // 2. 选择当前mtr作为受害者
        mtr_rollback(mtr);
        
        // 3. 重新开始操作
        mtr_restart(mtr);
    }
}
```

---

## 7. 💾 内存页面同步机制


### 7.1 缓冲池交互


**🔸 页面获取流程**
```
第一步：从缓冲池查找页面
第二步：如果页面不在内存，从磁盘加载
第三步：获取页面锁，防止并发修改
第四步：将页面信息记录到mtr中
第五步：返回页面指针供修改使用
```

**💡 缓存策略优化**
```cpp
buf_block_t* mtr_get_page_optimized(page_id_t page_id, mtr_t* mtr) {
    // 1. 检查mtr内部是否已缓存
    buf_block_t* block = mtr_find_cached_page(mtr, page_id);
    if (block != NULL) {
        return block;  // 直接返回缓存页面
    }
    
    // 2. 从全局缓冲池获取
    block = buf_page_get(page_id, RW_X_LATCH, mtr);
    
    // 3. 缓存到mtr内部
    mtr_cache_page(mtr, block);
    
    return block;
}
```

**🎯 页面状态同步**
```
读取同步：确保读取到最新的页面内容
修改同步：修改立即反映到内存页面
状态同步：页面状态（脏页、LSN等）及时更新
```

### 7.2 脏页管理机制


**🔸 脏页标记策略**
```
修改即标记：页面被修改时立即标记为脏页
LSN记录：记录页面最新修改的LSN
刷盘时机：根据策略决定何时刷入磁盘
```

**📊 脏页刷新策略**
```
检查点刷新：定期检查点时刷新脏页
缓冲池满：缓冲池空间不足时刷新
事务提交：重要事务提交时强制刷新
系统关闭：系统正常关闭时刷新所有脏页
```

**⚡ 批量刷新优化**
```cpp
void flush_dirty_pages_batch(mtr_t* mtr) {
    buf_block_t* dirty_pages[MAX_BATCH_SIZE];
    int count = 0;
    
    // 1. 收集mtr中的所有脏页
    collect_dirty_pages(mtr, dirty_pages, &count);
    
    // 2. 按磁盘位置排序（减少磁盘寻道）
    sort_pages_by_disk_location(dirty_pages, count);
    
    // 3. 批量写入磁盘
    batch_write_to_disk(dirty_pages, count);
}
```

### 7.3 内存一致性保证


**🔸 读写一致性**
```
读操作：总是读取最新版本的页面
写操作：写入操作对后续读操作立即可见
隔离性：未提交的修改对其他事务不可见
```

**🔄 版本控制机制**
```
页面版本：每个页面都有版本号（LSN）
版本检查：操作前检查页面版本是否匹配
版本更新：修改后更新页面版本
冲突检测：检测版本冲突并处理
```

**🛡️ 并发保护策略**
```
锁保护：通过锁机制保护并发访问
原子操作：关键操作使用原子指令
内存屏障：确保内存操作顺序正确
```

---

## 8. 🚀 mtr高级特性


### 8.1 mtr嵌套机制


**🔸 嵌套场景说明**
```
外层mtr：主要的业务操作（如插入记录）
内层mtr：子操作（如B+树页面分裂）
嵌套需求：复杂操作需要多层次的原子性保证
```

**💡 嵌套实现原理**
```cpp
class nested_mtr_context {
    mtr_t* parent_mtr;       // 父级mtr
    mtr_t child_mtr;         // 子级mtr
    mtr_savepoint_t savepoint; // 保存点
    
public:
    void start_nested(mtr_t* parent) {
        parent_mtr = parent;
        savepoint = mtr_set_savepoint(parent);
        child_mtr.start();
    }
    
    void commit_nested() {
        // 子mtr的日志合并到父mtr
        mtr_merge_logs(&child_mtr, parent_mtr);
        child_mtr.commit();
    }
};
```

**🎯 嵌套优势**
```
灵活性：可以对子操作进行独立的回滚
性能：避免重复的锁获取和释放
原子性：保持整体操作的原子性
可维护性：代码结构更清晰
```

### 8.2 mtr日志合并


**🔸 合并时机与策略**
```
相同页面：对同一页面的多次修改可以合并
顺序操作：连续的插入操作可以批量处理
空间优化：减少日志存储空间
性能提升：减少日志写入次数
```

**⚡ 合并算法实现**
```cpp
void mtr_merge_logs(mtr_t* source, mtr_t* target) {
    log_record_t* record = source->first_log_record;
    
    while (record != NULL) {
        // 检查是否可以与目标mtr的日志合并
        if (can_merge_with_existing(target, record)) {
            merge_log_records(target, record);
        } else {
            append_log_record(target, record);
        }
        record = record->next;
    }
}
```

**📊 合并效果统计**
```
空间节省：平均节省20-30%的日志空间
性能提升：减少15-25%的日志写入时间
复杂度：略微增加日志处理复杂度
```

### 8.3 mtr异常回滚


**🔸 回滚触发条件**
```
操作失败：页面修改操作失败
约束冲突：违反数据完整性约束
资源不足：内存或磁盘空间不足
系统错误：硬件故障或软件bug
```

**🔄 回滚实现机制**
```cpp
void mtr_rollback(mtr_t* mtr) {
    // 1. 停止新的修改操作
    mtr->m_state = MTR_STATE_ROLLBACK;
    
    // 2. 恢复修改的页面
    restore_modified_pages(mtr);
    
    // 3. 释放所有锁资源
    release_all_locks(mtr);
    
    // 4. 清理日志记录
    clear_log_records(mtr);
    
    // 5. 标记mtr为已回滚
    mtr->m_state = MTR_STATE_ROLLED_BACK;
}
```

**💡 回滚策略优化**
```
快速回滚：优先恢复关键页面
批量处理：批量恢复多个页面
内存优化：及时释放不再需要的内存
错误记录：记录回滚原因用于调试
```

---

## 9. 📈 性能优化与监控


### 9.1 mtr性能优化策略


**🔸 锁优化技术**
```
锁粒度：使用最小必要的锁粒度
锁持有时间：尽可能缩短锁持有时间
锁顺序：避免死锁的锁获取顺序
锁升级：适时进行锁升级
```

**⚡ 内存优化方案**
```cpp
// 内存池优化示例
class mtr_memory_pool {
    static thread_local char buffer[MTR_BUF_SIZE];
    static thread_local size_t offset;
    
public:
    static void* allocate(size_t size) {
        if (offset + size <= MTR_BUF_SIZE) {
            void* ptr = buffer + offset;
            offset += size;
            return ptr;
        }
        return malloc(size);  // 备用分配器
    }
    
    static void reset() {
        offset = 0;  // 重置内存池
    }
};
```

**📊 批量处理优化**
```
日志批量：批量写入多个mtr的日志
页面批量：批量获取多个页面
锁批量：批量获取多个锁资源
刷盘批量：批量刷新脏页到磁盘
```

### 9.2 mtr状态监控


**🔸 关键监控指标**
```
性能指标：
- mtr平均执行时间
- mtr提交成功率
- 锁等待时间统计
- 日志生成速率

资源指标：
- 活跃mtr数量
- 内存使用量
- 锁资源占用
- 页面修改频率
```

**📊 监控数据收集**
```cpp
struct mtr_stats {
    atomic<uint64_t> total_mtr_count;
    atomic<uint64_t> total_commit_time_us;
    atomic<uint64_t> total_rollback_count;
    atomic<uint64_t> total_log_bytes;
    
    void record_commit(uint64_t duration_us, size_t log_size) {
        total_mtr_count.fetch_add(1);
        total_commit_time_us.fetch_add(duration_us);
        total_log_bytes.fetch_add(log_size);
    }
};
```

**🎯 性能分析工具**
```
实时监控：实时显示mtr执行状态
历史分析：分析历史性能趋势
瓶颈识别：识别性能瓶颈点
优化建议：提供性能优化建议
```

### 9.3 mtr调试工具


**🔸 调试信息输出**
```cpp
#ifdef DEBUG_MTR
void mtr_debug_print(mtr_t* mtr) {
    printf("MTR Debug Info:\n");
    printf("  State: %s\n", mtr_state_name(mtr->m_state));
    printf("  Log Size: %zu bytes\n", mtr->m_log.size);
    printf("  Pages Modified: %d\n", mtr_count_modified_pages(mtr));
    printf("  Locks Held: %d\n", mtr_count_locks(mtr));
}
#endif
```

**🔍 故障诊断功能**
```
死锁检测：检测和报告死锁情况
性能分析：分析慢查询的mtr执行情况
内存泄漏：检测mtr相关的内存泄漏
日志分析：分析异常的日志模式
```

**🛠️ 调试辅助工具**
```
断点设置：在关键点设置调试断点
状态dump：导出mtr的完整状态信息
执行跟踪：跟踪mtr的完整执行路径
性能profile：分析mtr的性能热点
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


**🔸 mtr本质理解**
```
核心作用：保证页面修改操作的原子性
工作原理：通过锁+日志实现原子性和一致性
使用场景：所有可能修改数据页的操作
```

**🔸 关键机制掌握**
```
生命周期：创建→执行→提交/回滚
日志机制：本地缓存→原子提交→持久化
锁机制：页面锁定→并发控制→资源释放
```

### 10.2 实际应用要点


**💡 使用最佳实践**
```
及时提交：避免长时间持有mtr
合理粒度：选择合适的操作粒度
错误处理：正确处理异常和回滚
资源管理：及时释放不再需要的资源
```

**⚠️ 常见问题避免**
```
死锁问题：按固定顺序获取锁
性能问题：避免在mtr中执行耗时操作
内存泄漏：确保异常情况下也能正确释放资源
数据一致性：确保相关修改在同一个mtr中
```

### 10.3 核心价值体现


**🎯 技术价值**
- **原子性保证**：确保复杂操作的原子性
- **并发控制**：提供高效的并发访问控制
- **故障恢复**：支持系统故障后的数据恢复
- **性能优化**：通过批量处理提升性能

**📈 业务价值**
- **数据安全**：防止数据不一致和损坏
- **系统稳定**：提供可靠的事务处理能力
- **性能提升**：优化数据库操作效率
- **运维便利**：简化数据库故障处理流程

**核心记忆口诀**：
- mtr保原子，页面锁为先
- 日志缓存妙，提交一瞬间  
- 并发控制好，死锁要避免
- 异常能回滚，数据永安全