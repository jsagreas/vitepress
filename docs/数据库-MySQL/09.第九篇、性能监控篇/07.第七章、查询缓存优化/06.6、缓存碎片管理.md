---
title: 6、缓存碎片管理
---
## 📚 目录

1. [查询缓存基础概念](#1-查询缓存基础概念)
2. [缓存碎片产生原理](#2-缓存碎片产生原理)
3. [缓存碎片监控与诊断](#3-缓存碎片监控与诊断)
4. [FLUSH QUERY CACHE碎片整理](#4-flush-query-cache碎片整理)
5. [内存分配算法优化](#5-内存分配算法优化)
6. [缓存区块管理策略](#6-缓存区块管理策略)
7. [实战优化方案](#7-实战优化方案)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 查询缓存基础概念


### 1.1 查询缓存的本质


**什么是查询缓存**：MySQL把执行过的SELECT语句和结果存储在内存中，下次遇到完全相同的查询时直接返回缓存结果，跳过解析、优化、执行等步骤。

```
查询缓存工作流程：
客户端发送查询 → 检查缓存是否存在 → 存在则直接返回 → 不存在则正常执行并缓存结果

简单理解：就像浏览器缓存网页一样，访问过的查询结果暂存起来，下次直接用
```

### 1.2 缓存存储结构


**缓存的物理组织**：
```
┌─────────────────────────────────┐
│        查询缓存内存区           │
├─────────────────────────────────┤
│  空闲块1  │ 查询结果A │ 空闲块2 │
├─────────────────────────────────┤
│ 查询结果B │  空闲块3  │查询结果C│
├─────────────────────────────────┤
│  空闲块4  │ 查询结果D │ 空闲块5 │
└─────────────────────────────────┘

查询结果包含：SQL语句文本 + 查询结果数据
空闲块：可以分配给新查询的内存区域
```

> 💡 **理解要点**  
> 查询缓存不是表级缓存，而是完整SQL语句级缓存。哪怕多加一个空格，都被认为是不同的查询

---

## 2. 🧩 缓存碎片产生原理


### 2.1 碎片产生的根本原因


**内存分配释放不匹配**：当缓存中的查询结果被删除时，会留下大小不等的空闲内存块，这些不连续的小块就是碎片。

```
碎片产生过程示例：

初始状态（8KB缓存区）：
┌────────────────────────────────┐
│          空闲空间 8KB          │
└────────────────────────────────┘

缓存3个查询后：
┌─────────┬─────────┬─────────┬────┐
│ 查询A   │ 查询B   │ 查询C   │空闲│
│ 2KB     │ 3KB     │ 2KB     │1KB │
└─────────┴─────────┴─────────┴────┘

删除查询B后：
┌─────────┬─────────┬─────────┬────┐
│ 查询A   │ 空闲    │ 查询C   │空闲│
│ 2KB     │ 3KB     │ 2KB     │1KB │
└─────────┴─────────┴─────────┴────┘

现在有两个碎片：3KB和1KB的空闲块
```

### 2.2 触发碎片产生的场景


**🔸 表数据更新**
```sql
-- 当表发生任何变化时，相关查询缓存都会失效
UPDATE users SET status = 1 WHERE id = 100;
-- 此时所有涉及users表的查询缓存都被清除，产生碎片
```

**🔸 缓存大小限制**
```sql
-- 当新查询结果需要空间时，会按LRU算法删除旧缓存
SELECT * FROM products WHERE price > 1000;
-- 如果缓存已满，会删除最久未使用的查询缓存
```

**🔸 查询模式变化**
```sql
-- 不同大小的查询结果交替缓存和删除
SELECT id, name FROM users LIMIT 10;        -- 小结果集
SELECT * FROM orders WHERE date > '2024-01-01'; -- 大结果集
```

> ⚠️ **重要提醒**  
> 频繁的表更新操作会导致大量缓存失效，产生严重的碎片问题

### 2.3 碎片对性能的影响


**内存浪费**：
- 碎片无法被有效利用，降低缓存命中率
- 小碎片无法容纳新的查询结果

**分配效率下降**：
- MySQL需要遍历空闲块列表寻找合适大小的空间
- 频繁的内存分配和释放操作增加CPU开销

---

## 3. 📊 缓存碎片监控与诊断


### 3.1 关键监控指标


**查看缓存状态**：
```sql
-- 查看查询缓存相关状态变量
SHOW STATUS LIKE 'Qcache%';
```

**核心指标解读**：
```sql
-- 主要关注这几个指标
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| Qcache_free_blocks     | 158      | -- 空闲块数量（碎片指标）
| Qcache_free_memory     | 1048576  | -- 空闲内存总量
| Qcache_hits            | 12458    | -- 缓存命中次数
| Qcache_inserts         | 3421     | -- 缓存插入次数
| Qcache_queries_in_cache| 876      | -- 当前缓存的查询数
| Qcache_total_blocks    | 2134     | -- 总块数
+-------------------------+----------+
```

### 3.2 碎片率计算方法


**碎片率评估公式**：
```
碎片率 = (Qcache_free_blocks - 1) / Qcache_total_blocks * 100%

正常情况：碎片率 < 10%
需要整理：碎片率 > 20%
严重碎片：碎片率 > 40%
```

**实际计算示例**：
```sql
-- 假设监控数据
-- Qcache_free_blocks = 158
-- Qcache_total_blocks = 2134

-- 碎片率 = (158-1) / 2134 * 100% = 7.36%
-- 这个碎片率属于正常范围
```

### 3.3 内存使用效率分析


**平均块大小检查**：
```sql
-- 计算平均每个查询占用的内存
SELECT 
    ROUND(($$query_cache_size - (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_free_memory')) / 
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_queries_in_cache'), 2) 
    AS avg_cache_size_per_query;
```

> 🔍 **监控技巧**  
> 建议每天检查一次碎片率，在业务低峰期进行碎片整理

---

## 4. 🔧 FLUSH QUERY CACHE碎片整理


### 4.1 FLUSH QUERY CACHE命令详解


**命令作用**：整理查询缓存的内存碎片，不会清除缓存内容，只是重新组织内存布局。

```sql
-- 执行碎片整理
FLUSH QUERY CACHE;
```

**整理前后对比**：
```
整理前（碎片化状态）：
┌─────┬───┬─────┬──┬─────┬───┐
│查询A│空│查询B│空│查询C│空│
└─────┴───┴─────┴──┴─────┴───┘

整理后（连续状态）：
┌─────┬─────┬─────┬─────────┐
│查询A│查询B│查询C│  空闲   │
└─────┴─────┴─────┴─────────┘
```

### 4.2 执行时机和策略


**最佳执行时机**：
```sql
-- 检查是否需要整理（碎片率>20%时执行）
SELECT 
    CASE 
        WHEN (
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_free_blocks') - 1
        ) / (
            SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_total_blocks'
        ) * 100 > 20 
        THEN 'NEED_FLUSH' 
        ELSE 'NO_NEED' 
    END AS fragment_status;
```

**自动化整理脚本**：
```sql
-- 创建存储过程自动检查和整理
DELIMITER $$
CREATE PROCEDURE check_and_flush_cache()
BEGIN
    DECLARE fragment_rate DECIMAL(5,2);
    
    -- 计算碎片率
    SELECT (
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_free_blocks') - 1
    ) / (
        SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_total_blocks'
    ) * 100 INTO fragment_rate;
    
    -- 碎片率超过20%时执行整理
    IF fragment_rate > 20 THEN
        FLUSH QUERY CACHE;
    END IF;
END$$
DELIMITER ;
```

### 4.3 注意事项


> ⚠️ **重要警告**  
> FLUSH QUERY CACHE会短暂锁定查询缓存，建议在业务低峰期执行

**执行频率建议**：
- 正常业务：每周1-2次
- 高更新频率：每天1次  
- 轻度使用：每月1次

---

## 5. 🧮 内存分配算法优化


### 5.1 MySQL缓存分配策略


**分配算法原理**：MySQL使用**首次适应算法**（First Fit）分配缓存空间，从空闲块列表头部开始查找第一个足够大的块。

```
分配过程示例：
需要分配2KB空间，空闲块情况：
┌─────┬─────┬─────┬─────┐
│1KB  │3KB  │1.5KB│4KB  │
└─────┴─────┴─────┴─────┘

选择第一个满足条件的3KB块：
┌─────┬──┬──┬─────┬─────┐
│1KB  │2KB|1KB│1.5KB│4KB  │
└─────┴──┴──┴─────┴─────┘
      (分配)(剩余)
```

### 5.2 分配算法的局限性


**内部碎片问题**：
```
假设要缓存1KB查询，但最小空闲块是3KB：
┌─────────────┐    ┌──┬─────┐
│    3KB      │ -> │1KB│2KB  │
│   空闲块    │    │使用│浪费│
└─────────────┘    └──┴─────┘
```

**外部碎片问题**：
```
多个小空闲块无法合并使用：
┌──┬────┬──┬────┬──┐
│1KB│查询│1KB│查询│1KB│
└──┴────┴──┴────┴──┘

需要2KB空间时，虽然总空闲空间=3KB，但无法分配
```

### 5.3 优化参数配置


**query_cache_min_res_unit调优**：
```sql
-- 查看当前设置
SHOW VARIABLES LIKE 'query_cache_min_res_unit';

-- 根据查询结果大小调整
-- 如果查询结果普遍较小（<1KB）
SET GLOBAL query_cache_min_res_unit = 1024;  -- 1KB

-- 如果查询结果普遍较大（>4KB）  
SET GLOBAL query_cache_min_res_unit = 8192;  -- 8KB
```

> 💡 **调优技巧**  
> `query_cache_min_res_unit`应该设置为常见查询结果的平均大小，减少内存浪费

---

## 6. 🗂️ 缓存区块管理策略


### 6.1 区块分配原理


**缓存区块构成**：每个缓存项占用多个最小分配单元（query_cache_min_res_unit）。

```
区块分配示例（最小单元4KB）：
┌────────────────────────────────┐
│        12KB查询结果            │
├────────┬────────┬────────┬────┤
│ 4KB    │ 4KB    │ 4KB    │剩余│
│ 块1    │ 块2    │ 块3    │0KB │
└────────┴────────┴────────┴────┘

占用3个区块，无内部碎片
```

### 6.2 不同大小查询的处理


**小查询处理**：
```sql
-- 1KB查询结果，最小单元4KB
SELECT id, name FROM users WHERE id = 1;
-- 实际占用4KB，浪费3KB空间（75%浪费）
```

**大查询处理**：
```sql  
-- 10KB查询结果，最小单元4KB
SELECT * FROM orders WHERE date > '2024-01-01';
-- 占用3个区块=12KB，浪费2KB空间（17%浪费）
```

### 6.3 缓存淘汰策略


**LRU淘汰机制**：
```
缓存满时的处理流程：
1. 新查询需要缓存空间
2. 按LRU顺序查找最久未使用的缓存项
3. 删除足够的旧缓存项腾出空间
4. 在空闲空间中分配新查询结果

淘汰顺序：最久未访问 -> 最近访问
```

**监控淘汰情况**：
```sql
-- 查看缓存淘汰统计
SELECT 
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_lowmem_prunes') AS cache_evictions,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_inserts') AS cache_inserts;
```

---

## 7. ⚡ 实战优化方案


### 7.1 综合优化配置


**推荐配置方案**：
```sql
-- 基于业务特点的优化配置
-- 对于一般OLTP应用
SET GLOBAL query_cache_size = 67108864;        -- 64MB
SET GLOBAL query_cache_min_res_unit = 2048;    -- 2KB  
SET GLOBAL query_cache_limit = 1048576;        -- 1MB
SET GLOBAL query_cache_type = ON;

-- 对于大结果集应用
SET GLOBAL query_cache_size = 134217728;       -- 128MB
SET GLOBAL query_cache_min_res_unit = 8192;    -- 8KB
SET GLOBAL query_cache_limit = 4194304;        -- 4MB
```

### 7.2 监控和维护脚本


**日常监控脚本**：
```sql
-- 创建缓存健康检查视图
CREATE VIEW cache_health_check AS
SELECT 
    ROUND($$query_cache_size / 1024 / 1024, 2) AS cache_size_mb,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_queries_in_cache') AS cached_queries,
    ROUND((SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_free_memory') / 1024 / 1024, 2) AS free_memory_mb,
    ROUND(((SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_free_blocks') - 1) / 
          (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_total_blocks') * 100, 2) AS fragment_rate_percent,
    CASE 
        WHEN ((SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_free_blocks') - 1) / 
             (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME='Qcache_total_blocks') * 100 > 20 
        THEN 'NEED_FLUSH' 
        ELSE 'GOOD' 
    END AS cache_status;
```

### 7.3 自动化维护策略


**定期维护任务**：
```sql
-- 创建事件调度器任务
CREATE EVENT cache_maintenance
ON SCHEDULE EVERY 1 DAY 
STARTS '2024-01-01 02:00:00'
DO
BEGIN
    -- 检查碎片率并执行维护
    CALL check_and_flush_cache();
    
    -- 记录维护日志
    INSERT INTO cache_maintenance_log 
    VALUES (NOW(), 'Daily cache maintenance completed');
END;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 缓存碎片：查询删除后留下的不连续空闲内存块
🔸 碎片产生：表更新、缓存淘汰、查询模式变化导致
🔸 碎片监控：通过Qcache_free_blocks等指标评估
🔸 碎片整理：FLUSH QUERY CACHE重新组织内存布局
🔸 分配策略：首次适应算法分配缓存空间
🔸 区块管理：最小分配单元决定内存使用效率
```

### 8.2 关键理解要点


**🔹 碎片影响性能的根本原因**
```
内存浪费：小碎片无法有效利用
分配效率：查找合适空间需要遍历空闲列表
缓存命中率：可用空间减少影响新查询缓存
```

**🔹 优化的平衡点**
```
缓存大小 vs 内存占用：够用即可，不宜过大
最小单元 vs 碎片率：根据查询结果大小调整
整理频率 vs 性能影响：在业务低峰期进行
```

### 8.3 实际应用指导


**监控建议**：
- 📊 每天检查碎片率，超过20%时整理
- 📊 关注缓存命中率和淘汰次数
- 📊 定期分析查询结果大小分布

**优化策略**：
- ⚡ 根据业务特点调整`query_cache_min_res_unit`
- ⚡ 在业务低峰期执行`FLUSH QUERY CACHE`
- ⚡ 考虑对高频更新表禁用查询缓存

> 💡 **最佳实践**  
> 查询缓存适合读多写少的场景，频繁更新的表建议禁用缓存，改用应用层缓存

**核心记忆**：
- 缓存碎片源于删除操作，监控碎片率是关键
- FLUSH QUERY CACHE整理碎片不丢数据  
- 最小分配单元要匹配查询结果大小
- 业务低峰期维护，高更新表禁用缓存