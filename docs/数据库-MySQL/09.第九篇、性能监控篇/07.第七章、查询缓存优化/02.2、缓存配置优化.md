---
title: 2、缓存配置优化
---
## 📚 目录

1. [查询缓存基础概念](#1-查询缓存基础概念)
2. [核心配置参数详解](#2-核心配置参数详解)
3. [缓存控制SQL语法](#3-缓存控制SQL语法)
4. [内存分配策略](#4-内存分配策略)
5. [性能优化实践](#5-性能优化实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 查询缓存基础概念


### 1.1 什么是查询缓存


**查询缓存**就像是MySQL的"记忆功能"，把之前查询过的结果暂时保存起来，下次遇到完全相同的查询时直接返回结果，不用重新执行。

```
缓存工作流程：
客户端查询 → 检查缓存 → 有缓存直接返回
                   ↓
              无缓存执行查询 → 保存结果到缓存
```

**💡 核心理解：**
- **完全匹配**：查询语句必须一模一样（包括空格、大小写）
- **自动失效**：表数据变化时相关缓存自动清空
- **内存存储**：缓存保存在MySQL服务器内存中

### 1.2 查询缓存的优缺点


**✅ 优势：**
- 大幅提升重复查询性能
- 减少CPU和磁盘IO消耗
- 对应用程序透明

**❌ 劣势：**
- 写入频繁的表缓存命中率低
- 内存消耗较大
- MySQL 8.0已移除此功能

---

## 2. ⚙️ 核心配置参数详解


### 2.1 query_cache_type 缓存类型设置


**作用：** 控制查询缓存的工作模式

```sql
-- 查看当前设置
SHOW VARIABLES LIKE 'query_cache_type';

-- 配置文件设置
[mysqld]
query_cache_type = 1
```

**参数值说明：**

| 值 | 模式 | 说明 | 使用场景 |
|---|------|------|----------|
| `0` | **OFF** | 完全关闭缓存 | 写入频繁的OLTP系统 |
| `1` | **ON** | 默认启用缓存 | 读多写少的应用 |
| `2` | **DEMAND** | 按需缓存 | 精确控制哪些查询缓存 |

### 2.2 query_cache_size 缓存大小配置


**作用：** 设置查询缓存使用的内存大小

```sql
-- 查看缓存大小设置
SHOW VARIABLES LIKE 'query_cache_size';

-- 动态调整（重启后失效）
SET GLOBAL query_cache_size = 67108864; -- 64MB

-- 配置文件永久设置
[mysqld]
query_cache_size = 64M
```

**📊 内存大小建议：**
```
小型应用：16-32MB
中型应用：64-128MB  
大型应用：256-512MB
超大应用：1GB+（谨慎使用）
```

### 2.3 query_cache_limit 单查询限制


**作用：** 限制单个查询结果集的最大缓存大小

```sql
-- 查看限制设置
SHOW VARIABLES LIKE 'query_cache_limit';

-- 配置示例
[mysqld]
query_cache_limit = 2M  -- 超过2MB的结果不缓存
```

**💡 设置策略：**
- **默认值：** 1MB
- **建议值：** 根据常见查询结果大小设定
- **注意：** 过大会占用过多内存，过小会错过大结果集缓存

### 2.4 have_query_cache 功能检查


**作用：** 检查MySQL是否支持查询缓存功能

```sql
-- 检查是否支持查询缓存
SHOW VARIABLES LIKE 'have_query_cache';

-- 返回结果说明：
-- YES: 支持查询缓存
-- NO:  不支持查询缓存
```

---

## 3. 🎯 缓存控制SQL语法


### 3.1 SQL_CACHE 强制缓存


当`query_cache_type=2`（DEMAND模式）时，只有明确指定的查询才会被缓存。

```sql
-- 强制缓存指定查询
SELECT SQL_CACHE user_id, username 
FROM users 
WHERE status = 'active';

-- 复杂查询的缓存控制
SELECT SQL_CACHE 
    o.order_id,
    u.username,
    p.product_name
FROM orders o
JOIN users u ON o.user_id = u.user_id
JOIN products p ON o.product_id = p.product_id
WHERE o.order_date >= '2024-01-01';
```

### 3.2 SQL_NO_CACHE 跳过缓存


即使开启了查询缓存，也可以让特定查询跳过缓存。

```sql
-- 跳过缓存，强制执行实时查询
SELECT SQL_NO_CACHE COUNT(*) 
FROM orders 
WHERE DATE(created_at) = CURDATE();

-- 实时数据查询示例
SELECT SQL_NO_CACHE 
    product_id,
    current_stock,
    last_updated
FROM inventory 
WHERE product_id IN (1001, 1002, 1003);
```

**🔍 使用场景：**
- **实时数据：** 库存、余额等需要最新数据的查询
- **一次性查询：** 报表、数据导出等不会重复的查询
- **调试测试：** 需要确保获取最新结果时

---

## 4. 💾 缓存内存分配策略


### 4.1 缓存内存结构


```
查询缓存内存布局：
┌─────────────────────────────────┐
│         缓存管理区域            │ ← 存储缓存元数据
├─────────────────────────────────┤
│                                 │
│         查询结果存储区          │ ← 实际缓存数据
│                                 │
├─────────────────────────────────┤
│         碎片整理区域            │ ← 内存碎片管理
└─────────────────────────────────┘
```

### 4.2 内存分配参数


```sql
-- 查看缓存内存使用情况
SHOW STATUS LIKE 'Qcache_%';

-- 关键指标说明：
-- Qcache_free_memory    : 空闲内存大小
-- Qcache_queries_in_cache : 缓存中的查询数量
-- Qcache_total_blocks   : 总内存块数
-- Qcache_free_blocks    : 空闲内存块数
```

### 4.3 缓存内存监控


```sql
-- 查看缓存命中率统计
SELECT 
    ROUND(
        (Qcache_hits / (Qcache_hits + Qcache_inserts)) * 100, 2
    ) AS cache_hit_ratio,
    Qcache_hits AS cache_hits,
    Qcache_inserts AS cache_inserts
FROM 
    (SELECT 
         VARIABLE_VALUE AS Qcache_hits
     FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Qcache_hits') AS hits
CROSS JOIN 
    (SELECT 
         VARIABLE_VALUE AS Qcache_inserts
     FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Qcache_inserts') AS inserts;
```

---

## 5. 🚀 性能优化实践


### 5.1 配置优化建议


**📋 推荐配置组合：**

```ini
# 配置文件 my.cnf 推荐设置

[mysqld]
# 基础配置
query_cache_type = 1              # 启用查询缓存
query_cache_size = 128M           # 根据内存情况调整
query_cache_limit = 4M            # 单查询结果限制

# 优化配置
query_cache_min_res_unit = 2K     # 最小分配单元
```

### 5.2 缓存效果评估


```sql
-- 缓存性能评估查询
SELECT 
    '缓存命中率' AS metric,
    CONCAT(
        ROUND(
            Qcache_hits / (Qcache_hits + Qcache_inserts) * 100, 2
        ), '%'
    ) AS value
FROM 
    (SELECT 
         SUM(CASE WHEN VARIABLE_NAME = 'Qcache_hits' 
             THEN VARIABLE_VALUE ELSE 0 END) AS Qcache_hits,
         SUM(CASE WHEN VARIABLE_NAME = 'Qcache_inserts' 
             THEN VARIABLE_VALUE ELSE 0 END) AS Qcache_inserts
     FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME IN ('Qcache_hits', 'Qcache_inserts')) AS stats;
```

### 5.3 缓存清理操作


```sql
-- 手动清空查询缓存
FLUSH QUERY CACHE;

-- 重置查询缓存（清空并重新分配内存）
RESET QUERY CACHE;

-- 查看清理效果
SHOW STATUS LIKE 'Qcache_queries_in_cache';
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的配置要点


```
🔸 query_cache_type：控制缓存工作模式（0/1/2）
🔸 query_cache_size：设置缓存内存大小（建议64-256MB）
🔸 query_cache_limit：限制单查询缓存大小（建议2-4MB）
🔸 have_query_cache：检查系统是否支持缓存功能
🔸 SQL_CACHE/SQL_NO_CACHE：精确控制查询缓存行为
```

### 6.2 关键理解要点


**🔹 缓存生效条件：**
```
必要条件：
• 查询语句完全相同（包括空格、注释）
• 相关表数据没有变化
• 缓存空间足够
• 结果集大小未超过限制
```

**🔹 缓存失效机制：**
```
自动失效情况：
• 相关表发生INSERT/UPDATE/DELETE操作
• 使用了不确定函数（NOW()、RAND()等）
• 查询涉及系统表或临时表
• 查询结果超过大小限制
```

### 6.3 实际应用指导


**🎯 适用场景：**
- **读多写少的应用：** 新闻网站、产品目录
- **相对静态的数据：** 配置信息、字典数据
- **重复查询频繁：** 首页数据、热门内容

**⚠️ 不适用场景：**
- **写入频繁的表：** 订单、日志、实时数据
- **个性化查询：** 用户相关的动态内容
- **大结果集查询：** 数据导出、复杂报表

**核心记忆要点：**
- 查询缓存是把双刃剑，适合读多写少场景
- 配置要根据应用特点和硬件资源合理设置
- MySQL 8.0已移除查询缓存，建议使用应用层缓存
- 监控缓存命中率是评估效果的关键指标