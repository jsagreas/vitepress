---
title: 4、内存监控工具与指标
---
## 📚 目录

1. [Performance Schema内存监控](#1-performance-schema内存监控)
2. [INFORMATION_SCHEMA内存表](#2-information_schema内存表)
3. [内存使用统计查询](#3-内存使用统计查询)
4. [内存泄漏检测](#4-内存泄漏检测)
5. [内存监控脚本](#5-内存监控脚本)
6. [内存告警阈值](#6-内存告警阈值)
7. [内存趋势分析](#7-内存趋势分析)
8. [系统级内存监控](#8-系统级内存监控)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 Performance Schema内存监控


Performance Schema是MySQL内置的性能监控工具，提供了详细的内存使用信息，让我们能够精确了解MySQL各个组件的内存消耗情况。

### 1.1 Performance Schema基础概念


**什么是Performance Schema？**
```
Performance Schema = MySQL的"内存体检仪"
作用：实时监控MySQL内部各种资源使用情况
特点：低开销、高精度、实时更新
位置：sys数据库中的各种视图表
```

**内存监控的核心表：**
```sql
-- 查看所有内存相关的监控表
SHOW TABLES FROM performance_schema 
LIKE '%memory%';

-- 主要的内存监控表
memory_summary_global_by_event_name    -- 全局内存统计
memory_summary_by_thread_by_event_name -- 线程级内存统计
memory_summary_by_account_by_event_name -- 账户级内存统计
memory_summary_by_host_by_event_name   -- 主机级内存统计
```

### 1.2 启用Performance Schema内存监控


**检查监控状态：**
```sql
-- 查看内存监控是否开启
SELECT * FROM performance_schema.setup_instruments 
WHERE NAME LIKE 'memory/%' AND ENABLED = 'YES'
LIMIT 10;

-- 查看内存监控配置
SELECT * FROM performance_schema.setup_consumers 
WHERE NAME LIKE '%memory%';
```

**启用内存监控：**
```sql
-- 启用所有内存监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'memory/%';

-- 启用内存统计收集
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'memory%';
```

### 1.3 全局内存使用查询


**查看总体内存使用：**
```sql
-- 查看内存使用排行榜（按当前使用量）
SELECT 
    event_name,
    ROUND(current_alloc/1024/1024, 2) AS current_mb,
    ROUND(high_alloc/1024/1024, 2) AS high_mb,
    current_count_used,
    high_count_used
FROM performance_schema.memory_summary_global_by_event_name
WHERE current_alloc > 0
ORDER BY current_alloc DESC
LIMIT 20;
```

**内存使用关键指标解释：**
```
current_alloc: 当前分配的内存大小（字节）
high_alloc: 历史最高分配内存大小
current_count_used: 当前使用的内存块数量  
high_count_used: 历史最高内存块数量
```

---

## 2. 📊 INFORMATION_SCHEMA内存表


INFORMATION_SCHEMA是MySQL的信息模式，包含了大量关于数据库对象和系统状态的元数据，也提供了一些内存相关的统计信息。

### 2.1 INFORMATION_SCHEMA内存相关表


**主要的内存统计表：**
```sql
-- 查看所有INFORMATION_SCHEMA表
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'INFORMATION_SCHEMA' 
AND table_name LIKE '%MEMORY%' 
OR table_name LIKE '%BUFFER%';

-- 查看引擎状态（包含内存信息）
SELECT * FROM INFORMATION_SCHEMA.ENGINES;
```

### 2.2 通过状态变量监控内存


**关键的内存状态变量：**
```sql
-- 查看缓冲池相关状态
SHOW STATUS LIKE 'Innodb_buffer_pool%';

-- 查看查询缓存状态
SHOW STATUS LIKE 'Qcache%';

-- 查看临时表内存使用
SHOW STATUS LIKE '%tmp%';

-- 查看排序操作内存使用
SHOW STATUS LIKE '%sort%';
```

**具体的内存监控查询：**
```sql
-- InnoDB缓冲池详细状态
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME LIKE '%size%' THEN 
            CONCAT(ROUND(VARIABLE_VALUE/1024/1024, 2), ' MB')
        ELSE VARIABLE_VALUE
    END AS formatted_value
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN (
    'Innodb_buffer_pool_pages_total',
    'Innodb_buffer_pool_pages_free', 
    'Innodb_buffer_pool_pages_data',
    'Innodb_buffer_pool_pages_dirty',
    'Innodb_buffer_pool_bytes_data',
    'Innodb_buffer_pool_bytes_dirty'
);
```

---

## 3. 📈 内存使用统计查询


掌握内存统计查询能帮助我们快速定位内存使用的热点和异常，这些查询是日常运维的重要工具。

### 3.1 按功能模块统计内存


**InnoDB存储引擎内存统计：**
```sql
-- InnoDB各组件内存使用
SELECT 
    SUBSTRING_INDEX(event_name, '/', -1) as component,
    ROUND(SUM(current_alloc)/1024/1024, 2) AS current_mb,
    ROUND(SUM(high_alloc)/1024/1024, 2) AS peak_mb,
    SUM(current_count_used) as current_blocks
FROM performance_schema.memory_summary_global_by_event_name
WHERE event_name LIKE 'memory/innodb/%'
    AND current_alloc > 0
GROUP BY component
ORDER BY current_mb DESC;
```

**服务器层面内存统计：**
```sql
-- 服务器各模块内存使用
SELECT 
    CASE 
        WHEN event_name LIKE 'memory/sql/%' THEN 'SQL Layer'
        WHEN event_name LIKE 'memory/innodb/%' THEN 'InnoDB'
        WHEN event_name LIKE 'memory/performance_schema/%' THEN 'Performance Schema'
        WHEN event_name LIKE 'memory/mysys/%' THEN 'MySQL System'
        ELSE 'Other'
    END as module,
    ROUND(SUM(current_alloc)/1024/1024, 2) AS current_mb,
    COUNT(*) as item_count
FROM performance_schema.memory_summary_global_by_event_name
WHERE current_alloc > 0
GROUP BY module
ORDER BY current_mb DESC;
```

### 3.2 连接和线程内存分析


**单个连接的内存使用：**
```sql
-- 查看各个连接的内存使用情况
SELECT 
    t.thread_id,
    t.processlist_user,
    t.processlist_host,
    t.processlist_command,
    ROUND(SUM(mt.current_alloc)/1024/1024, 2) AS memory_mb
FROM performance_schema.threads t
JOIN performance_schema.memory_summary_by_thread_by_event_name mt 
    ON t.thread_id = mt.thread_id
WHERE mt.current_alloc > 0
    AND t.processlist_id IS NOT NULL
GROUP BY t.thread_id, t.processlist_user, t.processlist_host
ORDER BY memory_mb DESC
LIMIT 20;
```

**内存使用最多的SQL类型：**
```sql
-- 按事件类型统计内存使用
SELECT 
    SUBSTRING_INDEX(event_name, '/', -1) as memory_type,
    COUNT(*) as thread_count,
    ROUND(SUM(current_alloc)/1024/1024, 2) AS total_mb,
    ROUND(AVG(current_alloc)/1024/1024, 2) AS avg_mb_per_thread
FROM performance_schema.memory_summary_by_thread_by_event_name
WHERE current_alloc > 0
GROUP BY memory_type
HAVING total_mb > 1
ORDER BY total_mb DESC;
```

---

## 4. 🚨 内存泄漏检测


内存泄漏是MySQL性能问题的常见原因，通过系统性的监控方法，我们可以及早发现并解决内存泄漏问题。

### 4.1 内存泄漏的识别方法


**什么是内存泄漏？**
```
内存泄漏 = 程序申请的内存没有正确释放
表现：MySQL内存使用量持续增长，不会下降
危害：最终导致系统内存耗尽，MySQL崩溃
```

**内存泄漏检测查询：**
```sql
-- 创建基准时间点的内存快照（执行一次作为基准）
CREATE TABLE IF NOT EXISTS memory_baseline AS
SELECT 
    event_name,
    current_alloc as baseline_alloc,
    current_count_used as baseline_count,
    NOW() as snapshot_time
FROM performance_schema.memory_summary_global_by_event_name
WHERE current_alloc > 0;

-- 对比当前内存使用与基准的差异（定期执行）
SELECT 
    p.event_name,
    ROUND((p.current_alloc - IFNULL(b.baseline_alloc, 0))/1024/1024, 2) AS growth_mb,
    p.current_count_used - IFNULL(b.baseline_count, 0) AS growth_blocks,
    ROUND((p.current_alloc - IFNULL(b.baseline_alloc, 0)) / IFNULL(b.baseline_alloc, 1) * 100, 2) AS growth_percent
FROM performance_schema.memory_summary_global_by_event_name p
LEFT JOIN memory_baseline b ON p.event_name = b.event_name
WHERE p.current_alloc > 0
    AND (p.current_alloc - IFNULL(b.baseline_alloc, 0)) > 1024*1024  -- 增长超过1MB
ORDER BY growth_mb DESC
LIMIT 20;
```

### 4.2 长期内存趋势监控


**内存使用趋势表设计：**
```sql
-- 创建内存监控历史表
CREATE TABLE memory_monitor_history (
    monitor_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    event_name VARCHAR(512),
    current_alloc BIGINT,
    high_alloc BIGINT,
    current_count_used BIGINT,
    INDEX idx_time_event (monitor_time, event_name)
);

-- 定期收集内存数据的存储过程
DELIMITER //
CREATE PROCEDURE collect_memory_stats()
BEGIN
    INSERT INTO memory_monitor_history (event_name, current_alloc, high_alloc, current_count_used)
    SELECT event_name, current_alloc, high_alloc, current_count_used
    FROM performance_schema.memory_summary_global_by_event_name
    WHERE current_alloc > 1024*1024;  -- 只记录超过1MB的项目
END //
DELIMITER ;
```

---

## 5. 📜 内存监控脚本


编写自动化监控脚本能够帮助我们及时发现和处理内存异常，这是生产环境中必不可少的运维工具。

### 5.1 Shell脚本监控示例


**基础内存监控脚本：**
```bash
#!/bin/bash
# MySQL内存监控脚本

MYSQL_USER="monitor_user"
MYSQL_PASS="monitor_pass"
MYSQL_HOST="localhost"
THRESHOLD_MB=1000  # 告警阈值：1000MB

# 获取总内存使用
total_memory=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -se "
SELECT ROUND(SUM(current_alloc)/1024/1024, 2) 
FROM performance_schema.memory_summary_global_by_event_name
WHERE current_alloc > 0;")

echo "MySQL总内存使用: ${total_memory}MB"

# 检查是否超过阈值
if (( $(echo "$total_memory > $THRESHOLD_MB" | bc -l) )); then
    echo "警告：MySQL内存使用超过阈值！"
    
    # 获取内存使用TOP10
    mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -se "
    SELECT 
        SUBSTRING_INDEX(event_name, '/', -1) as component,
        ROUND(current_alloc/1024/1024, 2) AS memory_mb
    FROM performance_schema.memory_summary_global_by_event_name
    WHERE current_alloc > 0
    ORDER BY current_alloc DESC
    LIMIT 10;" | while read component memory; do
        echo "  $component: ${memory}MB"
    done
fi
```

### 5.2 Python监控脚本示例


**功能完整的Python监控脚本：**
```python
#!/usr/bin/env python3
import mysql.connector
import time
import json
from datetime import datetime

class MySQLMemoryMonitor:
    def __init__(self, host, user, password, database='performance_schema'):
        self.connection = mysql.connector.connect(
            host=host, user=user, password=password, database=database
        )
        
    def get_memory_summary(self):
        """获取内存使用汇总"""
        cursor = self.connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT 
                event_name,
                ROUND(current_alloc/1024/1024, 2) AS current_mb,
                ROUND(high_alloc/1024/1024, 2) AS high_mb,
                current_count_used
            FROM memory_summary_global_by_event_name
            WHERE current_alloc > 1048576  -- 大于1MB
            ORDER BY current_alloc DESC
            LIMIT 20
        """)
        return cursor.fetchall()
    
    def check_memory_growth(self, baseline_file='memory_baseline.json'):
        """检查内存增长"""
        current_data = self.get_memory_summary()
        
        try:
            with open(baseline_file, 'r') as f:
                baseline = json.load(f)
        except FileNotFoundError:
            # 首次运行，创建基准
            with open(baseline_file, 'w') as f:
                json.dump({item['event_name']: item['current_mb'] 
                          for item in current_data}, f)
            print("基准数据已创建")
            return
        
        # 检查增长
        alerts = []
        for item in current_data:
            event_name = item['event_name']
            current_mb = item['current_mb']
            baseline_mb = baseline.get(event_name, 0)
            
            if current_mb > baseline_mb * 1.5:  # 增长超过50%
                growth = current_mb - baseline_mb
                alerts.append(f"{event_name}: +{growth:.2f}MB ({current_mb:.2f}MB)")
        
        if alerts:
            print(f"内存异常增长检测到 ({datetime.now()}):")
            for alert in alerts:
                print(f"  {alert}")
    
    def monitor_loop(self, interval=300):  # 5分钟检查一次
        """持续监控循环"""
        while True:
            self.check_memory_growth()
            time.sleep(interval)

# 使用示例
if __name__ == "__main__":
    monitor = MySQLMemoryMonitor('localhost', 'monitor_user', 'password')
    monitor.monitor_loop()
```

---

## 6. 🔔 内存告警阈值


合理设置内存告警阈值能够帮助我们在问题发生前及时处理，避免因内存问题导致的服务中断。

### 6.1 阈值设置策略


**内存告警的层级设计：**
```
📊 告警级别设计：
🟢 正常状态：<70% 系统内存
🟡 注意状态：70-85% 系统内存  
🟠 警告状态：85-95% 系统内存
🔴 严重状态：>95% 系统内存
```

**动态阈值设置查询：**
```sql
-- 基于历史数据设置动态阈值
SELECT 
    event_name,
    ROUND(AVG(current_alloc)/1024/1024, 2) AS avg_mb,
    ROUND(MAX(current_alloc)/1024/1024, 2) AS max_mb,
    ROUND(STDDEV(current_alloc)/1024/1024, 2) AS stddev_mb,
    -- 动态阈值 = 平均值 + 2倍标准差
    ROUND((AVG(current_alloc) + 2*STDDEV(current_alloc))/1024/1024, 2) AS alert_threshold_mb
FROM memory_monitor_history
WHERE monitor_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    AND current_alloc > 0
GROUP BY event_name
HAVING COUNT(*) > 10  -- 至少有10个数据点
ORDER BY avg_mb DESC;
```

### 6.2 告警触发机制


**创建告警触发器：**
```sql
-- 创建告警配置表
CREATE TABLE memory_alert_config (
    event_pattern VARCHAR(255) PRIMARY KEY,
    warning_threshold_mb INT,
    critical_threshold_mb INT,
    alert_enabled BOOLEAN DEFAULT TRUE
);

-- 插入默认配置
INSERT INTO memory_alert_config VALUES
('memory/innodb/buf_pool%', 1000, 2000, TRUE),
('memory/sql/%', 500, 1000, TRUE),
('memory/performance_schema/%', 200, 500, TRUE);

-- 告警检查查询
SELECT 
    p.event_name,
    ROUND(p.current_alloc/1024/1024, 2) AS current_mb,
    c.warning_threshold_mb,
    c.critical_threshold_mb,
    CASE 
        WHEN p.current_alloc/1024/1024 >= c.critical_threshold_mb THEN 'CRITICAL'
        WHEN p.current_alloc/1024/1024 >= c.warning_threshold_mb THEN 'WARNING'
        ELSE 'OK'
    END AS alert_level
FROM performance_schema.memory_summary_global_by_event_name p
JOIN memory_alert_config c ON p.event_name LIKE c.event_pattern
WHERE c.alert_enabled = TRUE
    AND p.current_alloc/1024/1024 >= c.warning_threshold_mb
ORDER BY alert_level DESC, current_mb DESC;
```

---

## 7. 📊 内存趋势分析


内存趋势分析帮助我们理解MySQL内存使用的规律，预测未来的内存需求，提前进行容量规划。

### 7.1 时间序列分析


**内存使用趋势查询：**
```sql
-- 按小时统计内存使用趋势
SELECT 
    DATE_FORMAT(monitor_time, '%Y-%m-%d %H:00:00') AS hour_period,
    ROUND(AVG(current_alloc)/1024/1024, 2) AS avg_memory_mb,
    ROUND(MAX(current_alloc)/1024/1024, 2) AS peak_memory_mb,
    COUNT(DISTINCT event_name) AS active_components
FROM memory_monitor_history
WHERE monitor_time >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
    AND current_alloc > 0
GROUP BY hour_period
ORDER BY hour_period;

-- 内存增长率分析
SELECT 
    event_name,
    first_day.avg_mb AS first_day_avg,
    last_day.avg_mb AS last_day_avg,
    ROUND((last_day.avg_mb - first_day.avg_mb) / first_day.avg_mb * 100, 2) AS growth_percent,
    ROUND(last_day.avg_mb - first_day.avg_mb, 2) AS growth_mb
FROM (
    SELECT event_name, AVG(current_alloc)/1024/1024 AS avg_mb
    FROM memory_monitor_history
    WHERE DATE(monitor_time) = DATE_SUB(CURDATE(), INTERVAL 6 DAY)
    GROUP BY event_name
) first_day
JOIN (
    SELECT event_name, AVG(current_alloc)/1024/1024 AS avg_mb
    FROM memory_monitor_history  
    WHERE DATE(monitor_time) = CURDATE()
    GROUP BY event_name
) last_day ON first_day.event_name = last_day.event_name
WHERE first_day.avg_mb > 10  -- 只分析大于10MB的组件
ORDER BY growth_percent DESC;
```

### 7.2 容量规划预测


**内存容量预测查询：**
```sql
-- 基于线性回归预测未来7天内存需求
SELECT 
    event_name,
    ROUND(current_avg_mb, 2) AS current_avg_mb,
    ROUND(predicted_mb, 2) AS predicted_7days_mb,
    ROUND(growth_rate_mb_per_day, 2) AS daily_growth_mb
FROM (
    SELECT 
        event_name,
        AVG(current_alloc)/1024/1024 AS current_avg_mb,
        -- 简单线性预测：当前平均值 + 7天 * 日增长率
        AVG(current_alloc)/1024/1024 + 7 * 
        (MAX(current_alloc) - MIN(current_alloc))/1024/1024/
        DATEDIFF(MAX(monitor_time), MIN(monitor_time)) AS predicted_mb,
        (MAX(current_alloc) - MIN(current_alloc))/1024/1024/
        DATEDIFF(MAX(monitor_time), MIN(monitor_time)) AS growth_rate_mb_per_day
    FROM memory_monitor_history
    WHERE monitor_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
        AND current_alloc > 10*1024*1024  -- 大于10MB
    GROUP BY event_name
    HAVING COUNT(*) > 5  -- 至少5个数据点
) prediction
WHERE growth_rate_mb_per_day > 0  -- 只显示增长的组件
ORDER BY predicted_mb DESC;
```

---

## 8. 🖥️ 系统级内存监控


除了MySQL内部的内存监控，我们还需要从操作系统层面监控MySQL进程的内存使用情况，这样能获得更全面的视角。

### 8.1 操作系统内存监控


**Linux系统内存监控命令：**
```bash
# 查看MySQL进程的内存使用
ps aux | grep mysql | grep -v grep

# 详细的内存使用情况
cat /proc/$(pgrep mysqld)/status | grep -E "VmSize|VmRSS|VmHWM"

# 实时监控MySQL内存使用
top -p $(pgrep mysqld) -d 5

# 使用pmap查看内存映射
pmap -x $(pgrep mysqld) | tail -1
```

### 8.2 系统内存监控SQL查询


**通过SQL查询系统资源：**
```sql
-- 创建系统监控函数（需要特殊权限）
SELECT 
    $$hostname AS server_name,
    $$version AS mysql_version,
    $$innodb_buffer_pool_size/1024/1024 AS buffer_pool_mb,
    $$max_connections AS max_connections,
    $$thread_cache_size AS thread_cache_size;

-- 查看当前连接数和内存相关状态
SELECT 
    'Current Connections' AS metric,
    VARIABLE_VALUE AS value
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Threads_connected'

UNION ALL

SELECT 
    'Buffer Pool Pages',
    VARIABLE_VALUE
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'

UNION ALL

SELECT 
    'Buffer Pool Utilization %',
    ROUND(
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') * 100.0 /
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2
    );
```

### 8.3 综合监控视图


**创建综合内存监控视图：**
```sql
-- 创建内存监控综合视图
CREATE VIEW v_memory_overview AS
SELECT 
    'MySQL Total Memory' AS category,
    CONCAT(ROUND(SUM(current_alloc)/1024/1024, 2), ' MB') AS value,
    'Current allocation from Performance Schema' AS description
FROM performance_schema.memory_summary_global_by_event_name
WHERE current_alloc > 0

UNION ALL

SELECT 
    'InnoDB Buffer Pool Size',
    CONCAT(ROUND($$innodb_buffer_pool_size/1024/1024, 2), ' MB'),
    'Configured buffer pool size'

UNION ALL

SELECT 
    'Buffer Pool Utilization',
    CONCAT(
        ROUND(
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') * 100.0 /
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2
        ), ' %'
    ),
    'Percentage of buffer pool in use'

UNION ALL

SELECT 
    'Active Connections',
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Threads_connected'),
    'Current number of active connections';

-- 使用视图
SELECT * FROM v_memory_overview;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Performance Schema：MySQL内置的性能监控工具，提供详细内存统计
🔸 内存监控层次：全局→线程→账户→主机的多层次监控体系
🔸 内存泄漏检测：通过基准对比和趋势分析及早发现内存异常
🔸 告警阈值：基于历史数据和业务需求设置合理的告警机制
🔸 系统级监控：结合操作系统工具获得全面的内存使用视角
```

### 9.2 关键理解要点


**🔹 内存监控的价值**
```
性能优化：识别内存瓶颈，优化配置参数
故障预防：提前发现内存泄漏和异常增长
容量规划：基于趋势分析预测未来资源需求
问题诊断：快速定位内存相关的性能问题
```

**🔹 监控工具的选择**
```
Performance Schema：
• 优势：详细、实时、低开销
• 适用：日常监控、问题诊断
• 限制：需要MySQL 5.7+

INFORMATION_SCHEMA：
• 优势：兼容性好、简单易用
• 适用：基础监控、快速检查
• 限制：信息相对有限

系统工具：
• 优势：全面、独立于MySQL
• 适用：系统级分析、跨服务监控
• 限制：需要系统权限
```

### 9.3 实际应用价值


**🎯 监控最佳实践**
```
定期收集：建立定时任务收集内存统计数据
分层告警：设置不同级别的告警阈值
趋势分析：定期分析内存使用趋势，进行容量规划
文档记录：记录告警处理过程，建立知识库
```

**🔧 运维建议**
```
监控频率：
• 实时监控：关键指标每分钟检查
• 趋势分析：每小时收集历史数据
• 容量规划：每周分析内存增长趋势

告警策略：
• 即时告警：内存使用超过95%
• 预警通知：内存使用超过80%
• 趋势告警：内存增长率异常

处理流程：
• 发现异常→分析原因→采取措施→监控效果→总结经验
```

**核心记忆**：
- Performance Schema是MySQL内存监控的核心工具
- 内存监控要从多个维度进行：时间、模块、连接
- 建立基准数据是发现内存异常的关键
- 系统级监控和MySQL内部监控要结合使用
- 监控的最终目的是预防问题和优化性能