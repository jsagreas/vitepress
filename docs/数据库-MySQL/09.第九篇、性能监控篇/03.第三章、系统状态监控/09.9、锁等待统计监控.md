---
title: 9、锁等待统计监控
---
## 📚 目录

1. [锁等待监控概述](#1-锁等待监控概述)
2. [表锁等待统计](#2-表锁等待统计)
3. [行锁等待统计](#3-行锁等待统计)
4. [元数据锁等待监控](#4-元数据锁等待监控)
5. [锁等待超时统计](#5-锁等待超时统计)
6. [死锁次数统计](#6-死锁次数统计)
7. [锁等待时间分析](#7-锁等待时间分析)
8. [锁冲突模式分析](#8-锁冲突模式分析)
9. [锁性能监控实践](#9-锁性能监控实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔒 锁等待监控概述


### 1.1 什么是锁等待监控


**通俗解释**：就像停车场管理一样，当很多车同时要停到同一个车位时，就需要排队等待。MySQL中的锁等待监控就是用来观察数据库中有多少"车"在排队，等了多长时间，以及是否发生了"交通堵塞"。

**锁等待的本质**：
```
正常情况：
事务A → 获取锁 → 执行操作 → 释放锁 → 事务B继续

锁等待情况：
事务A → 获取锁 → 执行中...
事务B → 尝试获取同一锁 → 等待... ⏰
事务C → 尝试获取同一锁 → 等待... ⏰
```

### 1.2 为什么要监控锁等待


**监控的价值**：
- **性能诊断**：发现系统性能瓶颈的根源
- **问题预警**：在严重问题发生前提前发现
- **容量规划**：了解系统并发处理能力
- **优化指导**：为数据库优化提供数据支撑

> 💡 **实际意义**：锁等待监控就像是给数据库装了一个"健康监测器"，能及时发现哪里"堵车"了。

### 1.3 锁等待监控架构


```
锁等待监控体系：
┌─────────────────────────────────────┐
│            应用层监控                │
├─────────────────────────────────────┤
│ 表锁等待  │ 行锁等待  │ 元数据锁等待 │
├─────────────────────────────────────┤
│ 超时统计  │ 死锁统计  │ 时间分析    │
├─────────────────────────────────────┤
│            MySQL状态表               │
│ information_schema.innodb_locks     │
│ performance_schema.events_waits     │
└─────────────────────────────────────┘
```

---

## 2. 📋 表锁等待统计


### 2.1 表锁基本概念


**什么是表锁**：表锁就是给整张表加锁，就像把整个停车场都封起来，只允许一个人使用。

**表锁的特点**：
- **范围大**：锁定整张表的所有数据
- **并发低**：同时只能有少数操作进行
- **冲突多**：容易产生等待现象

### 2.2 表锁等待监控方法


**核心监控SQL**：
```sql
-- 查看当前表锁等待情况
SELECT 
    table_schema AS '数据库',
    table_name AS '表名',
    COUNT(*) AS '等待数量',
    AVG(timer_wait/1000000000) AS '平均等待时间(秒)'
FROM performance_schema.table_io_waits_summary_by_table
WHERE count_star > 0
GROUP BY table_schema, table_name
ORDER BY COUNT(*) DESC;
```

**表锁状态监控**：
```sql
-- 查看表锁状态
SHOW STATUS LIKE 'Table_locks%';
```

**结果解读**：
| 状态变量 | 含义 | 正常范围 |
|---------|------|----------|
| `Table_locks_immediate` | 立即获得表锁的次数 | 越高越好 |
| `Table_locks_waited` | 需要等待表锁的次数 | 越低越好 |

### 2.3 表锁等待分析


**计算表锁等待比例**：
```sql
-- 表锁等待比例分析
SELECT 
    CONCAT(
        ROUND(
            (Table_locks_waited / (Table_locks_immediate + Table_locks_waited)) * 100, 2
        ), '%'
    ) AS '表锁等待比例'
FROM (
    SELECT 
        VARIABLE_VALUE AS Table_locks_waited
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Table_locks_waited'
) waited,
(
    SELECT 
        VARIABLE_VALUE AS Table_locks_immediate
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Table_locks_immediate'
) immediate;
```

> ⚠️ **警告阈值**：表锁等待比例超过1%就需要关注，超过5%属于严重问题。

---

## 3. 🎯 行锁等待统计


### 3.1 行锁基本概念


**什么是行锁**：行锁是只锁定数据表中的特定行，就像停车场中只占用需要的车位，其他车位仍然可以使用。

**行锁优势**：
- **并发高**：不同行的操作可以同时进行
- **冲突少**：只有操作相同行时才会冲突
- **性能好**：是InnoDB引擎的默认锁机制

### 3.2 行锁等待监控


**当前行锁等待查询**：
```sql
-- 查看当前行锁等待情况
SELECT 
    r.trx_id AS '等待事务ID',
    r.trx_mysql_thread_id AS '线程ID',
    TIMESTAMPDIFF(SECOND, r.trx_started, NOW()) AS '等待时间(秒)',
    r.trx_query AS '等待的SQL',
    b.trx_id AS '阻塞事务ID',
    b.trx_mysql_thread_id AS '阻塞线程ID',
    b.trx_query AS '阻塞的SQL'
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx r ON w.requesting_trx_id = r.trx_id
INNER JOIN information_schema.innodb_trx b ON w.blocking_trx_id = b.trx_id;
```

**行锁统计信息**：
```sql
-- 行锁统计分析
SHOW STATUS LIKE 'Innodb_row_lock%';
```

### 3.3 行锁性能指标


**关键指标解读**：
| 指标名称 | 含义 | 健康标准 |
|---------|------|----------|
| `Innodb_row_lock_current_waits` | 当前等待行锁的操作数 | < 10 |
| `Innodb_row_lock_time` | 行锁等待总时间(毫秒) | 增长缓慢 |
| `Innodb_row_lock_time_avg` | 平均行锁等待时间(毫秒) | < 100ms |
| `Innodb_row_lock_waits` | 行锁等待总次数 | 增长缓慢 |

**行锁性能计算**：
```sql
-- 计算行锁平均等待时间
SELECT 
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_row_lock_time') / 
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_row_lock_waits'), 2
    ) AS '平均行锁等待时间(毫秒)';
```

---

## 4. 🗃️ 元数据锁等待监控


### 4.1 元数据锁概念


**什么是元数据锁(MDL)**：元数据锁是保护数据库表结构的锁，就像给建筑图纸加锁，防止在施工期间有人修改设计图。

**MDL的作用**：
- **结构保护**：防止表结构在使用时被修改
- **一致性保证**：确保查询期间表结构不变
- **版本控制**：管理表结构的版本一致性

### 4.2 元数据锁等待监控


**MDL等待查询**：
```sql
-- 查看元数据锁等待
SELECT 
    OBJECT_SCHEMA AS '数据库',
    OBJECT_NAME AS '表名',
    LOCK_TYPE AS '锁类型',
    LOCK_DURATION AS '锁持续时间',
    LOCK_STATUS AS '锁状态',
    THREAD_ID AS '线程ID',
    PROCESSLIST_ID AS '进程ID'
FROM performance_schema.metadata_locks
WHERE LOCK_STATUS = 'PENDING'
ORDER BY OBJECT_SCHEMA, OBJECT_NAME;
```

**长时间MDL等待**：
```sql
-- 查找长时间元数据锁等待
SELECT 
    ml.OBJECT_SCHEMA AS '数据库',
    ml.OBJECT_NAME AS '表名',
    ml.LOCK_TYPE AS '锁类型',
    p.TIME AS '等待时间(秒)',
    p.INFO AS 'SQL语句'
FROM performance_schema.metadata_locks ml
JOIN information_schema.processlist p ON ml.THREAD_ID = p.ID
WHERE ml.LOCK_STATUS = 'PENDING'
AND p.TIME > 30
ORDER BY p.TIME DESC;
```

### 4.3 常见MDL锁等待场景


**典型场景分析**：
```
场景1：DDL操作等待
会话1: SELECT * FROM users;  (长时间运行)
会话2: ALTER TABLE users ADD COLUMN age INT;  ← 等待中

场景2：备份操作冲突  
会话1: mysqldump --single-transaction db  (备份中)
会话2: DROP TABLE temp_table;  ← 等待中

场景3：批量更新阻塞
会话1: UPDATE users SET status=1;  (大批量更新)
会话2: DESCRIBE users;  ← 等待中
```

---

## 5. ⏰ 锁等待超时统计


### 5.1 锁等待超时机制


**超时机制原理**：当一个事务等待锁的时间超过系统设定的阈值时，MySQL会自动终止等待，避免无限期等待造成系统hang死。

**关键参数**：
```sql
-- 查看锁等待超时设置
SHOW VARIABLES LIKE '%timeout%';
```

| 参数名称 | 默认值 | 含义 |
|---------|--------|------|
| `innodb_lock_wait_timeout` | 50秒 | InnoDB行锁等待超时时间 |
| `lock_wait_timeout` | 31536000秒 | 元数据锁等待超时时间 |

### 5.2 超时统计监控


**锁超时统计查询**：
```sql
-- 查看锁等待超时统计
SELECT 
    VARIABLE_NAME AS '指标名称',
    VARIABLE_VALUE AS '累计次数'
FROM performance_schema.global_status
WHERE VARIABLE_NAME IN (
    'Innodb_row_lock_time_max',
    'Innodb_row_lock_waits'
)
UNION ALL
SELECT 
    'Lock_timeout_count' AS '指标名称',
    COUNT(*) AS '累计次数'
FROM performance_schema.events_errors_summary_global_by_error
WHERE ERROR_NAME = 'ER_LOCK_WAIT_TIMEOUT';
```

**实时超时监控**：
```sql
-- 监控即将超时的锁等待
SELECT 
    r.trx_id AS '事务ID',
    r.trx_mysql_thread_id AS '线程ID',
    TIMESTAMPDIFF(SECOND, r.trx_started, NOW()) AS '已等待时间(秒)',
    ($$innodb_lock_wait_timeout - TIMESTAMPDIFF(SECOND, r.trx_started, NOW())) AS '剩余时间(秒)',
    SUBSTRING(r.trx_query, 1, 100) AS 'SQL语句'
FROM information_schema.innodb_trx r
WHERE r.trx_state = 'LOCK WAIT'
AND TIMESTAMPDIFF(SECOND, r.trx_started, NOW()) > ($$innodb_lock_wait_timeout * 0.8)
ORDER BY TIMESTAMPDIFF(SECOND, r.trx_started, NOW()) DESC;
```

### 5.3 超时参数优化


**参数调整建议**：

> 📊 **优化策略**：
> - **OLTP系统**：`innodb_lock_wait_timeout = 5-10秒`（快速失败）
> - **OLAP系统**：`innodb_lock_wait_timeout = 60-120秒`（允许长时间等待）
> - **批处理系统**：`innodb_lock_wait_timeout = 300秒以上`（大事务需要）

```sql
-- 动态调整锁等待超时时间
SET GLOBAL innodb_lock_wait_timeout = 10;
```

---

## 6. ⚡ 死锁次数统计


### 6.1 死锁基本概念


**什么是死锁**：死锁就像两个人面对面走在窄路上，都不肯让路，结果谁也走不了。在数据库中，就是两个事务互相等待对方释放锁，形成循环等待。

**死锁场景示例**：
```
时间线：
T1: 事务A锁定行1
T2: 事务B锁定行2  
T3: 事务A尝试锁定行2 (等待事务B)
T4: 事务B尝试锁定行1 (等待事务A)
结果: 死锁！💀
```

### 6.2 死锁统计监控


**死锁次数查询**：
```sql
-- 查看死锁统计信息
SHOW STATUS LIKE 'Innodb_deadlocks';
```

**死锁详细信息**：
```sql
-- 查看最近的死锁信息
SHOW ENGINE INNODB STATUS\G
```

**死锁趋势分析**：
```sql
-- 死锁趋势监控(需要定期记录)
SELECT 
    NOW() AS '统计时间',
    VARIABLE_VALUE AS '累计死锁次数'
FROM performance_schema.global_status
WHERE VARIABLE_NAME = 'Innodb_deadlocks';
```

### 6.3 死锁分析工具


**死锁日志分析**：
```sql
-- 开启死锁日志记录
SET GLOBAL innodb_print_all_deadlocks = ON;
```

> 🔧 **实践建议**：开启死锁日志可以在错误日志中记录所有死锁信息，便于事后分析死锁原因。

**死锁预防策略**：
```
1. 统一加锁顺序：所有事务按相同顺序访问资源
2. 缩短事务时间：减少锁持有时间
3. 降低隔离级别：在业务允许的情况下使用较低隔离级别
4. 使用索引：减少锁定的行数
```

---

## 7. 📊 锁等待时间分析


### 7.1 等待时间指标体系


**时间维度分析**：
- **当前等待时间**：正在等待的事务已经等了多久
- **历史平均时间**：过去一段时间的平均等待时长
- **最大等待时间**：系统记录的最长等待时间
- **等待时间分布**：不同时间段的等待次数分布

### 7.2 等待时间统计查询


**综合等待时间分析**：
```sql
-- 锁等待时间综合分析
SELECT 
    '当前等待数' AS '指标类型',
    COUNT(*) AS '数值',
    '个' AS '单位'
FROM information_schema.innodb_trx 
WHERE trx_state = 'LOCK WAIT'

UNION ALL

SELECT 
    '平均等待时间' AS '指标类型',
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_row_lock_time') / 
        NULLIF((SELECT VARIABLE_VALUE FROM performance_schema.global_status 
                WHERE VARIABLE_NAME = 'Innodb_row_lock_waits'), 0), 2
    ) AS '数值',
    '毫秒' AS '单位'

UNION ALL

SELECT 
    '最大等待时间' AS '指标类型',
    VARIABLE_VALUE AS '数值',
    '毫秒' AS '单位'
FROM performance_schema.global_status
WHERE VARIABLE_NAME = 'Innodb_row_lock_time_max';
```

**等待时间分布统计**：
```sql
-- 等待时间分布分析
SELECT 
    CASE 
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 1 THEN '< 1秒'
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 5 THEN '1-5秒'
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 10 THEN '5-10秒'
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 30 THEN '10-30秒'
        ELSE '> 30秒'
    END AS '等待时间区间',
    COUNT(*) AS '事务数量'
FROM information_schema.innodb_trx
WHERE trx_state = 'LOCK WAIT'
GROUP BY 
    CASE 
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 1 THEN '< 1秒'
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 5 THEN '1-5秒'
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 10 THEN '5-10秒'
        WHEN TIMESTAMPDIFF(SECOND, trx_started, NOW()) < 30 THEN '10-30秒'
        ELSE '> 30秒'
    END
ORDER BY MIN(TIMESTAMPDIFF(SECOND, trx_started, NOW()));
```

### 7.3 等待时间趋势分析


**时间趋势监控脚本**：
```bash
#!/bin/bash
# 锁等待时间趋势监控脚本

while true; do
    mysql -e "
    SELECT 
        NOW() AS '时间',
        VARIABLE_VALUE AS '总等待时间ms',
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
         WHERE VARIABLE_NAME = 'Innodb_row_lock_waits') AS '总等待次数'
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Innodb_row_lock_time';
    " >> lock_wait_trend.log
    
    sleep 60  # 每分钟记录一次
done
```

---

## 8. 🔀 锁冲突模式分析


### 8.1 锁冲突模式概念


**什么是锁冲突模式**：就是分析哪些类型的操作容易发生锁冲突，就像分析交通事故多发的路段和时间段。

**常见冲突模式**：
```
读写冲突：SELECT vs UPDATE
写写冲突：UPDATE vs UPDATE  
DDL冲突：SELECT vs ALTER TABLE
批量冲突：大批量操作 vs 日常操作
```

### 8.2 锁冲突模式监控


**锁类型冲突分析**：
```sql
-- 分析当前锁冲突模式
SELECT 
    l.lock_type AS '锁类型',
    l.lock_mode AS '锁模式', 
    COUNT(*) AS '等待数量',
    GROUP_CONCAT(DISTINCT l.lock_table) AS '涉及表'
FROM information_schema.innodb_locks l
JOIN information_schema.innodb_lock_waits w ON l.lock_id = w.requesting_lock_id
GROUP BY l.lock_type, l.lock_mode
ORDER BY COUNT(*) DESC;
```

**SQL模式冲突分析**：
```sql
-- 分析SQL操作冲突模式
SELECT 
    CASE 
        WHEN r.trx_query LIKE 'SELECT%' THEN 'SELECT'
        WHEN r.trx_query LIKE 'UPDATE%' THEN 'UPDATE'  
        WHEN r.trx_query LIKE 'INSERT%' THEN 'INSERT'
        WHEN r.trx_query LIKE 'DELETE%' THEN 'DELETE'
        WHEN r.trx_query LIKE 'ALTER%' THEN 'ALTER'
        ELSE 'OTHER'
    END AS '等待操作类型',
    CASE 
        WHEN b.trx_query LIKE 'SELECT%' THEN 'SELECT'
        WHEN b.trx_query LIKE 'UPDATE%' THEN 'UPDATE'
        WHEN b.trx_query LIKE 'INSERT%' THEN 'INSERT' 
        WHEN b.trx_query LIKE 'DELETE%' THEN 'DELETE'
        WHEN b.trx_query LIKE 'ALTER%' THEN 'ALTER'
        ELSE 'OTHER'
    END AS '阻塞操作类型',
    COUNT(*) AS '冲突次数'
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx r ON w.requesting_trx_id = r.trx_id
JOIN information_schema.innodb_trx b ON w.blocking_trx_id = b.trx_id
GROUP BY 
    CASE 
        WHEN r.trx_query LIKE 'SELECT%' THEN 'SELECT'
        WHEN r.trx_query LIKE 'UPDATE%' THEN 'UPDATE'
        WHEN r.trx_query LIKE 'INSERT%' THEN 'INSERT'
        WHEN r.trx_query LIKE 'DELETE%' THEN 'DELETE'
        WHEN r.trx_query LIKE 'ALTER%' THEN 'ALTER'
        ELSE 'OTHER'
    END,
    CASE 
        WHEN b.trx_query LIKE 'SELECT%' THEN 'SELECT'
        WHEN b.trx_query LIKE 'UPDATE%' THEN 'UPDATE'
        WHEN b.trx_query LIKE 'INSERT%' THEN 'INSERT'
        WHEN b.trx_query LIKE 'DELETE%' THEN 'DELETE' 
        WHEN b.trx_query LIKE 'ALTER%' THEN 'ALTER'
        ELSE 'OTHER'
    END
ORDER BY COUNT(*) DESC;
```

### 8.3 高频冲突表分析


**热点表冲突统计**：
```sql
-- 查找锁冲突热点表
SELECT 
    lock_table AS '表名',
    COUNT(*) AS '冲突次数',
    GROUP_CONCAT(DISTINCT lock_mode) AS '锁模式',
    AVG(TIMESTAMPDIFF(SECOND, 
        (SELECT trx_started FROM information_schema.innodb_trx 
         WHERE trx_id = requesting_trx_id), NOW())) AS '平均等待时间(秒)'
FROM information_schema.innodb_locks l
JOIN information_schema.innodb_lock_waits w ON l.lock_id = w.requesting_lock_id  
GROUP BY lock_table
HAVING COUNT(*) > 1
ORDER BY COUNT(*) DESC
LIMIT 10;
```

---

## 9. 📈 锁性能监控实践


### 9.1 监控指标体系


**核心监控指标**：

```
一级指标（必须监控）：
├── 当前锁等待数量
├── 平均锁等待时间  
├── 死锁次数/小时
└── 锁等待超时次数

二级指标（重要监控）：
├── 表锁等待比例
├── 行锁等待比例
├── MDL锁等待时间
└── 热点表锁冲突

三级指标（辅助监控）：
├── 锁等待时间分布
├── 锁冲突模式分析
├── 锁等待SQL TOP10
└── 锁性能趋势分析
```

### 9.2 监控告警设置


**告警阈值配置**：

| 监控项目 | 警告阈值 | 严重阈值 | 检查频率 |
|---------|----------|----------|----------|
| 当前锁等待数 | > 10 | > 50 | 1分钟 |
| 平均等待时间 | > 100ms | > 1000ms | 5分钟 |
| 死锁次数 | > 1次/小时 | > 5次/小时 | 10分钟 |
| 表锁等待比例 | > 1% | > 5% | 5分钟 |

**监控脚本示例**：
```bash
#!/bin/bash
# 锁等待监控告警脚本

# 检查当前锁等待数量
current_waits=$(mysql -e "
SELECT COUNT(*) 
FROM information_schema.innodb_trx 
WHERE trx_state = 'LOCK WAIT';" -N)

if [ "$current_waits" -gt 50 ]; then
    echo "严重告警：当前锁等待数量 $current_waits" 
    # 发送告警通知
elif [ "$current_waits" -gt 10 ]; then
    echo "警告：当前锁等待数量 $current_waits"
fi

# 检查平均等待时间
avg_wait_time=$(mysql -e "
SELECT ROUND(
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_row_lock_time') / 
    NULLIF((SELECT VARIABLE_VALUE FROM performance_schema.global_status 
            WHERE VARIABLE_NAME = 'Innodb_row_lock_waits'), 0), 2);" -N)

if [ $(echo "$avg_wait_time > 1000" | bc) -eq 1 ]; then
    echo "严重告警：平均锁等待时间 ${avg_wait_time}ms"
elif [ $(echo "$avg_wait_time > 100" | bc) -eq 1 ]; then
    echo "警告：平均锁等待时间 ${avg_wait_time}ms"
fi
```

### 9.3 性能优化建议


**基于监控结果的优化策略**：

> 🚀 **优化路径**：
> 1. **SQL优化**：优化高频锁等待的SQL语句
> 2. **索引优化**：为经常锁冲突的字段添加索引  
> 3. **业务优化**：调整业务逻辑，减少锁冲突
> 4. **参数调优**：调整锁相关的MySQL参数
> 5. **架构优化**：读写分离、分库分表等

**常见优化措施**：
```sql
-- 1. 优化长事务
SELECT 
    trx_id,
    trx_mysql_thread_id,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS '事务持续时间(秒)',
    trx_query
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 30
ORDER BY TIMESTAMPDIFF(SECOND, trx_started, NOW()) DESC;

-- 2. 分析缺失索引
SELECT 
    object_schema AS '数据库',
    object_name AS '表名', 
    COUNT(*) AS '全表扫描次数'
FROM performance_schema.table_io_waits_summary_by_table
WHERE count_read > 1000
ORDER BY COUNT(*) DESC;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的监控技能


> 💡 **核心理念**：锁等待监控就是给数据库装上"体检设备"，及时发现"健康问题"。

**基础监控清单**：
- ✅ **表锁监控**：关注 `Table_locks_waited` 指标
- ✅ **行锁监控**：关注 `Innodb_row_lock_*` 指标系列  
- ✅ **死锁监控**：关注 `Innodb_deadlocks` 计数
- ✅ **MDL锁监控**：关注 `metadata_locks` 表状态
- ✅ **超时监控**：关注锁等待超时事件

### 10.2 关键SQL工具箱


**日常巡检SQL**：
```sql
-- 锁等待健康检查
SELECT 
    '表锁等待次数' AS '检查项',
    VARIABLE_VALUE AS '当前值'
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Table_locks_waited'
UNION ALL
SELECT 
    '行锁当前等待数',
    VARIABLE_VALUE 
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Innodb_row_lock_current_waits'
UNION ALL  
SELECT 
    '累计死锁次数',
    VARIABLE_VALUE
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Innodb_deadlocks';
```

### 10.3 监控最佳实践


**监控策略建议**：

```
监控频率安排：
┌──────────────┬──────────┬──────────┐
│   监控项目   │ 检查频率 │ 保留时间 │
├──────────────┼──────────┼──────────┤
│ 当前锁等待   │  1分钟   │  24小时  │
│ 锁等待统计   │  5分钟   │  7天     │  
│ 死锁分析     │  10分钟  │  30天    │
│ 性能趋势     │  1小时   │  90天    │
└──────────────┴──────────┴──────────┘
```

**告警处理流程**：
```
锁等待告警处理流程：
告警触发 → 查看当前等待 → 分析阻塞源 → 评估影响 → 采取措施

处理措施选择：
- 轻微锁等待：观察等待，准备优化
- 中等锁等待：分析SQL，优化查询  
- 严重锁等待：Kill阻塞进程，紧急处理
```

### 10.4 实际应用价值


**业务价值体现**：
- **提前预警**：在用户感受到卡顿前发现问题
- **精准定位**：快速找到性能瓶颈的根本原因  
- **容量规划**：基于锁冲突数据规划系统容量
- **优化指导**：为SQL优化和架构调整提供数据支撑

> 🎯 **记忆要点**：
> - 锁等待监控是数据库性能监控的重要组成部分
> - 重点关注等待数量、等待时间、死锁次数三大核心指标
> - 通过监控数据指导SQL优化和系统调优
> - 建立完善的告警机制，做到问题早发现、早处理

**实践建议**：
1. **从简单开始**：先监控基础指标，再逐步深入分析
2. **结合业务**：监控策略要结合具体业务场景制定
3. **持续优化**：根据监控结果不断优化SQL和系统配置
4. **文档记录**：记录典型问题和处理方案，建立知识库