---
title: 8、响应时间监控
---
## 📚 目录

1. [响应时间基础概念](#1-响应时间基础概念)
2. [平均响应时间监控](#2-平均响应时间监控)
3. [P95_P99响应时间分析](#3-P95_P99响应时间分析)
4. [响应时间分布统计](#4-响应时间分布统计)
5. [慢查询响应时间监控](#5-慢查询响应时间监控)
6. [连接建立时间监控](#6-连接建立时间监控)
7. [事务响应时间分析](#7-事务响应时间分析)
8. [响应时间告警机制](#8-响应时间告警机制)
9. [响应时间优化策略](#9-响应时间优化策略)
10. [响应时间SLA监控](#10-响应时间SLA监控)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 响应时间基础概念


### 1.1 什么是响应时间

**响应时间**就是从客户端发出请求到收到完整结果的总时间。简单理解就是"问MySQL一个问题，它多久能给你答案"。

```
客户端请求 → MySQL处理 → 返回结果
    ↑                           ↓
    └──────── 响应时间 ──────────┘
```

### 1.2 响应时间的组成部分

```
总响应时间 = 网络传输时间 + MySQL处理时间 + 队列等待时间

详细分解：
┌─网络延迟─┐┌─连接建立─┐┌─SQL解析─┐┌─执行时间─┐┌─结果传输─┐
│   5ms   ││   2ms   ││   1ms   ││  50ms   ││   3ms   │
└─────────┘└─────────┘└─────────┘└─────────┘└─────────┘
                     总响应时间：61ms
```

### 1.3 响应时间的重要性

- ✅ **用户体验指标**：直接影响用户感受
- ✅ **系统健康度**：反映数据库整体性能
- ✅ **容量规划**：帮助预测系统负载能力
- ✅ **故障诊断**：快速定位性能问题

---

## 2. ⏱️ 平均响应时间监控


### 2.1 平均响应时间的含义

平均响应时间是一段时间内所有查询响应时间的平均值，它能反映系统的**整体性能水平**。

> 💡 **通俗理解**：如果把响应时间比作考试成绩，平均响应时间就是班级平均分

### 2.2 查看平均响应时间

```sql
-- 查看当前会话的平均查询时间
SHOW SESSION STATUS LIKE 'Questions';
SHOW SESSION STATUS LIKE 'Uptime';

-- 计算平均响应时间（秒）
SELECT 
    VARIABLE_VALUE as total_queries,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Uptime') as uptime_seconds
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Questions';
```

### 2.3 使用Performance Schema监控

```sql
-- 启用语句统计
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME = 'events_statements_summary_by_digest';

-- 查看平均执行时间（微秒）
SELECT 
    DIGEST_TEXT,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000 as avg_ms,
    MAX_TIMER_WAIT/1000000 as max_ms
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;
```

### 2.4 平均响应时间的局限性

```
场景对比：
┌─────────────┬──────────┬──────────┬─────────────┐
│   查询次数   │  响应时间  │  平均值   │    问题     │
├─────────────┼──────────┼──────────┼─────────────┤
│ 100次正常   │   10ms   │  20ms    │ 看起来正常   │
│ 1次超慢     │ 1000ms   │  20ms    │ 隐藏了问题   │
└─────────────┴──────────┴──────────┴─────────────┘
```

> ⚠️ **注意**：平均值会被极值"拉偏"，一个超慢查询可能掩盖整体问题

---

## 3. 📊 P95_P99响应时间分析


### 3.1 什么是P95、P99响应时间

- **P95响应时间**：95%的请求都在这个时间内完成
- **P99响应时间**：99%的请求都在这个时间内完成

> 💡 **生活化理解**：如果把响应时间比作排队时间，P95就是"95%的人都能在这个时间内排到"

### 3.2 为什么P95、P99更重要

```
100个请求的响应时间分布：
┌─────────┬──────────┬─────────────┐
│  95个   │   5个    │    含义     │
├─────────┼──────────┼─────────────┤
│  <50ms  │ >200ms   │ P95 = 50ms  │
│  <100ms │ >500ms   │ P99 = 100ms │
└─────────┴──────────┴─────────────┘

平均值：约60ms（看起来不错）
但5%用户体验很差！
```

### 3.3 使用sys schema查看百分位数

```sql
-- 查看语句的百分位响应时间
SELECT 
    query,
    exec_count,
    avg_latency,
    p95_latency,
    p99_latency
FROM sys.x$statements_with_runtimes_in_95th_percentile
ORDER BY p99_latency DESC
LIMIT 10;
```

### 3.4 手动计算百分位数

```sql
-- 创建临时表存储响应时间
CREATE TEMPORARY TABLE response_times AS
SELECT 
    TIMER_WAIT/1000000 as response_ms
FROM performance_schema.events_statements_history_long
WHERE EVENT_NAME = 'statement/sql/select'
ORDER BY response_ms;

-- 计算P95、P99
SET @total = (SELECT COUNT(*) FROM response_times);
SET @p95_pos = FLOOR(@total * 0.95);
SET @p99_pos = FLOOR(@total * 0.99);

SELECT 
    (SELECT response_ms FROM response_times LIMIT @p95_pos,1) as P95_ms,
    (SELECT response_ms FROM response_times LIMIT @p99_pos,1) as P99_ms;
```

---

## 4. 📈 响应时间分布统计


### 4.1 响应时间分布的重要性

了解响应时间的分布情况，能帮我们发现系统的**性能特征**和**潜在问题**。

```
健康的分布：          不健康的分布：
    ╭─╮                  ╭─╮
   ╱   ╲                ╱   ╲      ╭─╮
  ╱     ╲              ╱     ╲    ╱   ╲
 ╱       ╲            ╱       ╲  ╱     ╲
╱         ╲__________╱         ╲╱       ╲
0-10ms 11-50ms 51ms+   0-10ms 11-50ms 51ms+

大部分请求快速响应     有明显的双峰分布
```

### 4.2 创建响应时间分布统计

```sql
-- 创建响应时间统计表
CREATE TABLE response_time_stats (
    time_bucket VARCHAR(20),
    request_count INT,
    percentage DECIMAL(5,2),
    record_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 统计当前响应时间分布
INSERT INTO response_time_stats (time_bucket, request_count, percentage)
SELECT 
    CASE 
        WHEN TIMER_WAIT/1000000 <= 10 THEN '0-10ms'
        WHEN TIMER_WAIT/1000000 <= 50 THEN '11-50ms'
        WHEN TIMER_WAIT/1000000 <= 100 THEN '51-100ms'
        WHEN TIMER_WAIT/1000000 <= 500 THEN '101-500ms'
        ELSE '500ms+'
    END as time_bucket,
    COUNT(*) as request_count,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM performance_schema.events_statements_history) as percentage
FROM performance_schema.events_statements_history
WHERE EVENT_NAME LIKE 'statement/sql/%'
GROUP BY time_bucket
ORDER BY 
    CASE time_bucket
        WHEN '0-10ms' THEN 1
        WHEN '11-50ms' THEN 2
        WHEN '51-100ms' THEN 3
        WHEN '101-500ms' THEN 4
        ELSE 5
    END;
```

### 4.3 可视化响应时间分布

```sql
-- 简单的ASCII图表展示
SELECT 
    time_bucket,
    request_count,
    CONCAT(REPEAT('█', FLOOR(percentage/2)), ' ', percentage, '%') as distribution_chart
FROM response_time_stats
WHERE record_time >= NOW() - INTERVAL 1 HOUR
ORDER BY record_time DESC, 
    CASE time_bucket
        WHEN '0-10ms' THEN 1
        WHEN '11-50ms' THEN 2
        WHEN '51-100ms' THEN 3
        WHEN '101-500ms' THEN 4
        ELSE 5
    END;
```

---

## 5. 🐌 慢查询响应时间监控


### 5.1 慢查询响应时间概念

慢查询是指执行时间超过设定阈值的SQL语句，它们往往是性能问题的**主要源头**。

> 💡 **形象比喻**：如果数据库是一条高速公路，慢查询就像是路上的"大货车"，虽然数量不多，但严重影响整体通行效率

### 5.2 配置慢查询日志

```sql
-- 查看当前慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;  -- 2秒以上算慢查询
SET GLOBAL log_queries_not_using_indexes = 'ON';  -- 记录未使用索引的查询
```

### 5.3 分析慢查询响应时间

```sql
-- 使用performance_schema分析慢查询
SELECT 
    DIGEST_TEXT as query_pattern,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000 as avg_ms,
    MAX_TIMER_WAIT/1000000 as max_ms,
    SUM_TIMER_WAIT/1000000 as total_ms,
    ROUND(SUM_TIMER_WAIT/SUM(SUM_TIMER_WAIT) OVER() * 100, 2) as time_percentage
FROM performance_schema.events_statements_summary_by_digest 
WHERE AVG_TIMER_WAIT/1000000 > 1000  -- 平均执行时间超过1秒
ORDER BY SUM_TIMER_WAIT DESC 
LIMIT 10;
```

### 5.4 慢查询优化监控脚本

```sql
-- 创建慢查询监控视图
CREATE VIEW slow_query_monitor AS
SELECT 
    LEFT(DIGEST_TEXT, 100) as query_sample,
    COUNT_STAR as execution_count,
    ROUND(AVG_TIMER_WAIT/1000000, 2) as avg_response_ms,
    ROUND(MAX_TIMER_WAIT/1000000, 2) as max_response_ms,
    ROUND(SUM_TIMER_WAIT/1000000, 2) as total_time_ms,
    FIRST_SEEN,
    LAST_SEEN
FROM performance_schema.events_statements_summary_by_digest 
WHERE AVG_TIMER_WAIT/1000000 > 500  -- 500ms以上
ORDER BY total_time_ms DESC;

-- 查看当前慢查询Top 10
SELECT * FROM slow_query_monitor LIMIT 10;
```

---

## 6. 🔌 连接建立时间监控


### 6.1 连接建立时间的重要性

连接建立时间虽然看起来很小，但在高并发场景下会**累积成显著开销**。

> 💡 **生活化理解**：就像排队买票，虽然每个人验证身份只需要几秒钟，但人多了排队时间就会很长

### 6.2 监控连接相关指标

```sql
-- 查看连接相关状态
SHOW STATUS LIKE 'Connections';          -- 总连接数
SHOW STATUS LIKE 'Threads_connected';    -- 当前连接数
SHOW STATUS LIKE 'Threads_running';      -- 活跃连接数
SHOW STATUS LIKE 'Connection_errors%';   -- 连接错误统计

-- 查看连接耗时统计
SELECT 
    EVENT_NAME,
    COUNT_STAR as connection_count,
    ROUND(AVG_TIMER_WAIT/1000000, 2) as avg_connect_ms,
    ROUND(MAX_TIMER_WAIT/1000000, 2) as max_connect_ms
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%connect%'
ORDER BY AVG_TIMER_WAIT DESC;
```

### 6.3 连接池效率分析

```sql
-- 创建连接监控表
CREATE TABLE connection_monitor (
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_connections INT,
    active_connections INT,
    idle_connections INT,
    connection_utilization DECIMAL(5,2)
);

-- 记录连接使用情况
INSERT INTO connection_monitor (total_connections, active_connections, idle_connections, connection_utilization)
SELECT 
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_connected') as total_connections,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_running') as active_connections,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_connected') - 
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_running') as idle_connections,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_running') * 100.0 /
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_connected') as connection_utilization;
```

---

## 7. 🔄 事务响应时间分析


### 7.1 事务响应时间概念

事务响应时间包括**事务开始到提交的总时间**，它比单个查询的响应时间更能反映业务操作的整体性能。

```
事务响应时间组成：
BEGIN → SQL1 → SQL2 → SQL3 → COMMIT
  ↓      ↓      ↓      ↓       ↓
 1ms   50ms   30ms   20ms    2ms
└─────────── 总时间：103ms ──────────┘
```

### 7.2 监控事务响应时间

```sql
-- 查看事务相关统计
SELECT 
    EVENT_NAME,
    COUNT_STAR as transaction_count,
    ROUND(AVG_TIMER_WAIT/1000000, 2) as avg_transaction_ms,
    ROUND(MAX_TIMER_WAIT/1000000, 2) as max_transaction_ms,
    ROUND(SUM_TIMER_WAIT/1000000, 2) as total_transaction_ms
FROM performance_schema.events_transactions_summary_global_by_event_name
WHERE COUNT_STAR > 0
ORDER BY avg_transaction_ms DESC;
```

### 7.3 事务等待分析

```sql
-- 分析事务等待事件
SELECT 
    EVENT_NAME,
    COUNT_STAR as wait_count,
    ROUND(AVG_TIMER_WAIT/1000000, 2) as avg_wait_ms,
    ROUND(SUM_TIMER_WAIT/1000000, 2) as total_wait_ms
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%transaction%' 
   OR EVENT_NAME LIKE '%lock%'
ORDER BY total_wait_ms DESC
LIMIT 10;
```

---

## 8. 🚨 响应时间告警机制


### 8.1 设置响应时间阈值

根据业务需求设定不同级别的响应时间告警阈值：

```
告警级别设定：
┌─────────────┬─────────────┬─────────────────┐
│   告警级别   │   响应时间   │      说明       │
├─────────────┼─────────────┼─────────────────┤
│ 🟢 正常     │    <100ms   │ 用户体验良好     │
│ 🟡 警告     │  100-500ms  │ 需要关注        │
│ 🟠 严重     │  500ms-2s   │ 影响用户体验     │
│ 🔴 紧急     │    >2s      │ 严重性能问题     │
└─────────────┴─────────────┴─────────────────┘
```

### 8.2 创建响应时间告警存储过程

```sql
DELIMITER //
CREATE PROCEDURE CheckResponseTimeAlerts()
BEGIN
    DECLARE avg_response_time DECIMAL(10,2);
    DECLARE p95_response_time DECIMAL(10,2);
    
    -- 计算平均响应时间
    SELECT AVG(TIMER_WAIT)/1000000 INTO avg_response_time
    FROM performance_schema.events_statements_history_long
    WHERE EVENT_NAME LIKE 'statement/sql/%'
    AND TIMER_START > UNIX_TIMESTAMP(NOW() - INTERVAL 5 MINUTE) * 1000000000;
    
    -- 检查是否需要告警
    IF avg_response_time > 2000 THEN
        INSERT INTO performance_alerts (alert_level, alert_message, metric_value)
        VALUES ('CRITICAL', 'Average response time exceeds 2 seconds', avg_response_time);
    ELSEIF avg_response_time > 500 THEN
        INSERT INTO performance_alerts (alert_level, alert_message, metric_value)
        VALUES ('WARNING', 'Average response time exceeds 500ms', avg_response_time);
    END IF;
END //
DELIMITER ;
```

### 8.3 告警历史记录表

```sql
-- 创建告警记录表
CREATE TABLE performance_alerts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    alert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    alert_level ENUM('INFO', 'WARNING', 'CRITICAL'),
    alert_message TEXT,
    metric_value DECIMAL(10,2),
    resolved BOOLEAN DEFAULT FALSE,
    INDEX idx_alert_time (alert_time),
    INDEX idx_alert_level (alert_level)
);
```

---

## 9. ⚡ 响应时间优化策略


### 9.1 识别性能瓶颈

通过监控数据找出影响响应时间的主要因素：

```sql
-- 找出最耗时的查询模式
SELECT 
    DIGEST_TEXT,
    COUNT_STAR as exec_count,
    ROUND(AVG_TIMER_WAIT/1000000, 2) as avg_ms,
    ROUND(SUM_TIMER_WAIT/1000000, 2) as total_ms,
    ROUND(SUM_TIMER_WAIT/SUM(SUM_TIMER_WAIT) OVER() * 100, 2) as time_percentage
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY SUM_TIMER_WAIT DESC 
LIMIT 20;
```

### 9.2 优化策略分类

```
响应时间优化策略：

🔸 索引优化
  - 添加缺失索引
  - 优化复合索引顺序
  - 删除无用索引

🔸 查询优化  
  - 重写SQL语句
  - 避免全表扫描
  - 优化JOIN操作

🔸 数据库配置
  - 调整缓冲池大小
  - 优化连接池设置
  - 配置查询缓存

🔸 硬件优化
  - 增加内存
  - 使用SSD存储
  - 网络带宽优化
```

### 9.3 优化效果监控

```sql
-- 创建优化前后对比视图
CREATE VIEW optimization_comparison AS
SELECT 
    'Before Optimization' as period,
    AVG(avg_response_time) as avg_response,
    MAX(max_response_time) as max_response
FROM response_time_history 
WHERE record_time BETWEEN '2024-01-01' AND '2024-01-15'
UNION ALL
SELECT 
    'After Optimization' as period,
    AVG(avg_response_time) as avg_response,
    MAX(max_response_time) as max_response
FROM response_time_history 
WHERE record_time BETWEEN '2024-01-16' AND '2024-01-30';
```

---

## 10. 📋 响应时间SLA监控


### 10.1 什么是响应时间SLA

**SLA**（Service Level Agreement）是服务等级协议，用来约定系统必须达到的性能标准。

> 💡 **通俗理解**：SLA就像是给客户的"性能承诺书"，比如承诺"99%的查询在100ms内完成"

### 10.2 设定SLA指标

```sql
-- 创建SLA配置表
CREATE TABLE response_time_sla (
    service_name VARCHAR(100),
    sla_level VARCHAR(20),        -- P95, P99, Average
    target_ms INT,                -- 目标响应时间(毫秒)
    success_rate_target DECIMAL(5,2), -- 成功率目标(%)
    measurement_window INT,       -- 测量窗口(分钟)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入SLA配置
INSERT INTO response_time_sla VALUES
('User Query', 'P95', 100, 95.0, 5),
('User Query', 'P99', 500, 99.0, 5),
('Report Query', 'Average', 2000, 90.0, 15);
```

### 10.3 SLA达成率监控

```sql
-- 创建SLA监控存储过程
DELIMITER //
CREATE PROCEDURE MonitorSLA()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE sla_name VARCHAR(100);
    DECLARE sla_level VARCHAR(20);
    DECLARE target_ms INT;
    DECLARE success_target DECIMAL(5,2);
    DECLARE window_minutes INT;
    
    DECLARE sla_cursor CURSOR FOR 
        SELECT service_name, sla_level, target_ms, success_rate_target, measurement_window 
        FROM response_time_sla;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN sla_cursor;
    
    read_loop: LOOP
        FETCH sla_cursor INTO sla_name, sla_level, target_ms, success_target, window_minutes;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 计算实际达成率并记录
        CALL CalculateSLACompliance(sla_name, sla_level, target_ms, success_target, window_minutes);
        
    END LOOP;
    
    CLOSE sla_cursor;
END //
DELIMITER ;
```

### 10.4 SLA报告生成

```sql
-- 生成SLA达成情况报告
SELECT 
    s.service_name,
    s.sla_level,
    s.target_ms,
    s.success_rate_target,
    h.actual_success_rate,
    h.avg_response_time,
    CASE 
        WHEN h.actual_success_rate >= s.success_rate_target THEN '✅ 达标'
        ELSE '❌ 未达标'
    END as sla_status,
    h.check_time
FROM response_time_sla s
LEFT JOIN sla_compliance_history h ON s.service_name = h.service_name 
    AND s.sla_level = h.sla_level
WHERE h.check_time >= NOW() - INTERVAL 24 HOUR
ORDER BY h.check_time DESC, s.service_name;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念

```
🔸 响应时间定义：从请求发出到收到完整结果的总时间
🔸 平均响应时间：反映整体性能水平，但容易被极值影响
🔸 P95/P99响应时间：更准确反映用户体验的性能指标
🔸 响应时间分布：了解系统性能特征和异常模式
🔸 SLA监控：确保系统满足业务性能要求
```

### 11.2 关键监控指标

```
基础指标：
- 平均响应时间：整体性能水平
- 最大响应时间：最差用户体验
- 响应时间标准差：性能稳定性

高级指标：
- P95/P99响应时间：真实用户体验
- 慢查询占比：性能问题比例
- 连接建立时间：基础设施效率
- 事务响应时间：业务操作性能
```

### 11.3 实际应用价值

- **性能诊断**：快速定位响应时间瓶颈
- **容量规划**：预测系统负载承受能力
- **用户体验**：确保良好的应用响应速度
- **SLA管理**：满足业务服务等级要求
- **优化验证**：评估性能优化效果

### 11.4 最佳实践建议

```
监控策略：
✅ 同时监控平均值和百分位数
✅ 设置分级告警阈值
✅ 记录优化前后对比数据
✅ 建立响应时间趋势分析

优化原则：
✅ 先解决影响最大的慢查询
✅ 关注P95/P99而不只是平均值
✅ 建立持续监控机制
✅ 定期评估SLA达成情况
```

**核心记忆**：
- 响应时间是用户体验的直接体现
- P95/P99比平均值更重要
- 持续监控比临时检查更有价值
- 优化要有数据支撑和效果验证