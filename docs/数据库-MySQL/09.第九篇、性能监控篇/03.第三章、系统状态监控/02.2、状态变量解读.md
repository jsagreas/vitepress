---
title: 2、状态变量解读
---
## 📚 目录

1. [状态变量概述](#1-状态变量概述)
2. [连接状态变量解析](#2-连接状态变量解析)
3. [查询状态变量解析](#3-查询状态变量解析)
4. [缓存状态变量解析](#4-缓存状态变量解析)
5. [锁状态变量解析](#5-锁状态变量解析)
6. [IO状态变量解析](#6-IO状态变量解析)
7. [复制状态变量解析](#7-复制状态变量解析)
8. [线程状态变量解析](#8-线程状态变量解析)
9. [状态变量关联分析](#9-状态变量关联分析)
10. [状态异常模式识别](#10-状态异常模式识别)
11. [状态优化建议生成](#11-状态优化建议生成)
12. [系统变量监控分析](#12-系统变量监控分析)
13. [核心要点总结](#13-核心要点总结)

---

## 1. 📊 状态变量概述


### 1.1 什么是状态变量

**状态变量**是MySQL服务器运行时产生的统计信息，记录了数据库各种操作的次数和状态。简单说就是MySQL的"体检报告"，告诉我们数据库运行得怎么样。

```sql
-- 查看所有状态变量
SHOW STATUS;

-- 查看特定状态变量
SHOW STATUS LIKE 'Connections';
```

### 1.2 状态变量 vs 系统变量


```
状态变量 (Status Variables)：
┌─────────────────┐
│   运行时统计     │ ← 连接数、查询数、缓存命中等
├─────────────────┤
│   只读信息      │ ← 只能查看，不能修改
├─────────────────┤
│   实时变化      │ ← 随着操作实时更新
└─────────────────┘

系统变量 (System Variables)：
┌─────────────────┐
│   配置参数      │ ← 缓存大小、连接数限制等
├─────────────────┤
│   可以修改      │ ← 可以动态调整
├─────────────────┤
│   影响行为      │ ← 控制MySQL如何工作
└─────────────────┘
```

### 1.3 状态变量的作用

- **🔍 性能诊断**：发现性能瓶颈在哪里
- **📈 趋势分析**：了解数据库使用模式
- **⚠️ 问题预警**：提前发现潜在问题
- **🎯 优化指导**：为调优提供数据依据

---

## 2. 🔗 连接状态变量解析


### 2.1 连接相关核心变量

连接状态变量告诉我们有多少客户端连接到MySQL，连接质量如何。

```sql
-- 查看连接相关状态
SHOW STATUS LIKE '%connect%';
SHOW STATUS LIKE '%thread%';
```

**🔸 主要连接变量**

| 变量名 | **含义** | **正常范围** | **异常信号** |
|--------|---------|-------------|-------------|
| `Connections` | `累计连接总数` | `持续增长` | `增长过快表示连接频繁` |
| `Threads_connected` | `当前活跃连接数` | `< max_connections的80%` | `接近上限需要关注` |
| `Threads_running` | `正在执行的线程数` | `< CPU核心数×2` | `过高表示并发压力大` |
| `Aborted_connects` | `失败的连接尝试` | `很少或为0` | `频繁失败需要检查` |

### 2.2 连接状态分析示例


```sql
-- 查看当前连接状态
SELECT 
    VARIABLE_NAME as '状态项',
    VARIABLE_VALUE as '当前值'
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN (
    'Connections',
    'Threads_connected', 
    'Threads_running',
    'Aborted_connects'
);
```

**连接状态健康评估**：
```
健康状态：
Threads_connected: 45 (< 100的80% = 80) ✅
Threads_running: 8 (< 16核×2 = 32) ✅
Aborted_connects: 2 (很少) ✅

问题状态：
Threads_connected: 95 (接近上限100) ⚠️
Threads_running: 35 (超过CPU处理能力) ❌
Aborted_connects: 156 (频繁失败) ❌
```

### 2.3 连接池效率分析


```sql
-- 计算连接复用率
SELECT 
    ROUND(
        (Connections - Aborted_connects) / Connections * 100, 2
    ) AS '连接成功率%'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Connections' THEN VARIABLE_VALUE END) AS Connections,
        MAX(CASE WHEN VARIABLE_NAME='Aborted_connects' THEN VARIABLE_VALUE END) AS Aborted_connects
    FROM information_schema.GLOBAL_STATUS
) t;
```

---

## 3. 🔍 查询状态变量解析


### 3.1 查询执行统计

查询状态变量反映了数据库处理SQL语句的情况，是性能分析的核心指标。

```sql
-- 查看查询相关状态
SHOW STATUS LIKE '%query%';
SHOW STATUS LIKE '%select%';
SHOW STATUS LIKE '%insert%';
```

**🔸 核心查询变量**

| 变量名 | **含义** | **分析要点** |
|--------|---------|-------------|
| `Questions` | `总查询数（包括存储过程内部）` | `整体负载指标` |
| `Queries` | `总SQL语句数` | `实际SQL执行量` |
| `Com_select` | `SELECT语句执行次数` | `读操作频率` |
| `Com_insert` | `INSERT语句执行次数` | `写操作频率` |
| `Com_update` | `UPDATE语句执行次数` | `更新操作频率` |
| `Com_delete` | `DELETE语句执行次数` | `删除操作频率` |

### 3.2 查询类型分布分析


```sql
-- 分析查询类型分布
SELECT 
    'SELECT' as '操作类型',
    VARIABLE_VALUE as '执行次数',
    ROUND(VARIABLE_VALUE / total.total_queries * 100, 2) as '占比%'
FROM information_schema.GLOBAL_STATUS,
     (SELECT SUM(VARIABLE_VALUE) as total_queries 
      FROM information_schema.GLOBAL_STATUS 
      WHERE VARIABLE_NAME IN ('Com_select','Com_insert','Com_update','Com_delete')) total
WHERE VARIABLE_NAME = 'Com_select'

UNION ALL

SELECT 'INSERT', VARIABLE_VALUE, 
       ROUND(VARIABLE_VALUE / total.total_queries * 100, 2)
FROM information_schema.GLOBAL_STATUS,
     (SELECT SUM(VARIABLE_VALUE) as total_queries 
      FROM information_schema.GLOBAL_STATUS 
      WHERE VARIABLE_NAME IN ('Com_select','Com_insert','Com_update','Com_delete')) total
WHERE VARIABLE_NAME = 'Com_insert';
```

### 3.3 查询性能指标


```
查询性能评估框架：

读写比例分析：
SELECT操作: 85% ← 读多写少，适合读优化
INSERT操作: 10% 
UPDATE操作: 4%
DELETE操作: 1%

QPS (每秒查询数)：
正常范围: 100-1000 QPS
高负载: > 1000 QPS  
需要优化: > 5000 QPS
```

---

## 4. 💾 缓存状态变量解析


### 4.1 查询缓存状态

查询缓存能够保存SELECT语句的结果，相同查询可以直接返回缓存结果，大大提升性能。

```sql
-- 查看查询缓存状态
SHOW STATUS LIKE '%qcache%';
```

**🔸 查询缓存关键变量**

| 变量名 | **含义** | **理想状态** |
|--------|---------|-------------|
| `Qcache_hits` | `缓存命中次数` | `越高越好` |
| `Qcache_inserts` | `缓存插入次数` | `适中` |
| `Qcache_not_cached` | `未缓存查询数` | `合理范围内` |
| `Qcache_free_memory` | `缓存空闲内存` | `> 总缓存的20%` |

### 4.2 缓存命中率计算


```sql
-- 计算查询缓存命中率
SELECT 
    ROUND(
        Qcache_hits / (Qcache_hits + Com_select) * 100, 2
    ) AS '查询缓存命中率%'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Qcache_hits' THEN VARIABLE_VALUE END) AS Qcache_hits,
        MAX(CASE WHEN VARIABLE_NAME='Com_select' THEN VARIABLE_VALUE END) AS Com_select
    FROM information_schema.GLOBAL_STATUS
) t;
```

**缓存效果评估**：
```
优秀: > 80% 命中率
良好: 60-80% 命中率  
一般: 40-60% 命中率
较差: < 40% 命中率
```

### 4.3 InnoDB缓冲池状态


```sql
-- InnoDB缓冲池状态
SHOW STATUS LIKE '%innodb_buffer_pool%';
```

**🔸 缓冲池核心指标**

| 变量名 | **含义** | **优化目标** |
|--------|---------|-------------|
| `Innodb_buffer_pool_read_requests` | `逻辑读请求` | `记录总读取量` |
| `Innodb_buffer_pool_reads` | `物理读次数` | `越少越好` |
| `Innodb_buffer_pool_pages_dirty` | `脏页数量` | `合理范围内` |

```sql
-- 计算缓冲池命中率
SELECT 
    ROUND(
        (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100, 2
    ) AS 'InnoDB缓冲池命中率%'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Innodb_buffer_pool_reads' THEN VARIABLE_VALUE END) AS Innodb_buffer_pool_reads,
        MAX(CASE WHEN VARIABLE_NAME='Innodb_buffer_pool_read_requests' THEN VARIABLE_VALUE END) AS Innodb_buffer_pool_read_requests
    FROM information_schema.GLOBAL_STATUS
) t;
```

---

## 5. 🔒 锁状态变量解析


### 5.1 锁等待状态

锁状态变量反映了数据库中的并发控制情况，锁等待过多会严重影响性能。

```sql
-- 查看锁相关状态
SHOW STATUS LIKE '%lock%';
SHOW STATUS LIKE '%wait%';
```

**🔸 重要锁状态变量**

| 变量名 | **含义** | **关注点** |
|--------|---------|-----------|
| `Table_locks_immediate` | `立即获得的表锁数` | `越高说明锁竞争少` |
| `Table_locks_waited` | `需要等待的表锁数` | `越少越好` |
| `Innodb_row_lock_waits` | `行锁等待次数` | `监控并发冲突` |
| `Innodb_row_lock_time` | `行锁等待总时间(毫秒)` | `等待时间越短越好` |

### 5.2 锁竞争分析


```sql
-- 计算表锁竞争率
SELECT 
    ROUND(
        Table_locks_waited / (Table_locks_immediate + Table_locks_waited) * 100, 2
    ) AS '表锁竞争率%'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Table_locks_immediate' THEN VARIABLE_VALUE END) AS Table_locks_immediate,
        MAX(CASE WHEN VARIABLE_NAME='Table_locks_waited' THEN VARIABLE_VALUE END) AS Table_locks_waited
    FROM information_schema.GLOBAL_STATUS
) t;
```

**锁状态健康标准**：
```
表锁竞争率:
优秀: < 1%
良好: 1-5%  
需要关注: 5-10%
严重问题: > 10%

行锁平均等待时间:
优秀: < 10ms
可接受: 10-50ms
需要优化: > 50ms
```

### 5.3 死锁监控


```sql
-- 查看死锁状态
SHOW STATUS LIKE '%deadlock%';

-- 死锁数量
SELECT VARIABLE_VALUE as '死锁次数' 
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_deadlocks';
```

---

## 6. 💽 IO状态变量解析


### 6.1 磁盘IO统计

IO状态变量反映了数据库的磁盘读写活动，是性能瓶颈分析的重要指标。

```sql
-- 查看IO相关状态
SHOW STATUS LIKE '%read%';
SHOW STATUS LIKE '%write%';
```

**🔸 核心IO变量**

| 变量名 | **含义** | **性能含义** |
|--------|---------|-------------|
| `Innodb_data_reads` | `InnoDB数据读取次数` | `磁盘读活动量` |
| `Innodb_data_writes` | `InnoDB数据写入次数` | `磁盘写活动量` |
| `Innodb_data_read` | `InnoDB读取的字节数` | `实际读取数据量` |
| `Innodb_data_written` | `InnoDB写入的字节数` | `实际写入数据量` |

### 6.2 IO性能分析


```sql
-- 计算平均IO大小
SELECT 
    ROUND(Innodb_data_read / Innodb_data_reads / 1024, 2) AS '平均读取KB',
    ROUND(Innodb_data_written / Innodb_data_writes / 1024, 2) AS '平均写入KB'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Innodb_data_read' THEN VARIABLE_VALUE END) AS Innodb_data_read,
        MAX(CASE WHEN VARIABLE_NAME='Innodb_data_reads' THEN VARIABLE_VALUE END) AS Innodb_data_reads,
        MAX(CASE WHEN VARIABLE_NAME='Innodb_data_written' THEN VARIABLE_VALUE END) AS Innodb_data_written,
        MAX(CASE WHEN VARIABLE_NAME='Innodb_data_writes' THEN VARIABLE_VALUE END) AS Innodb_data_writes
    FROM information_schema.GLOBAL_STATUS
) t;
```

### 6.3 日志文件IO


```sql
-- 日志相关IO状态
SHOW STATUS LIKE '%log%';
```

**日志IO关键指标**：
```
Innodb_log_writes: 日志写入次数
Innodb_log_write_requests: 日志写入请求数  
Innodb_os_log_written: 实际写入日志字节数

日志写入效率 = Innodb_log_writes / Innodb_log_write_requests
理想比值: 接近1表示批量写入效率高
```

---

## 7. 🔄 复制状态变量解析


### 7.1 主从复制监控

复制状态变量用于监控MySQL主从复制的健康状况和性能表现。

```sql
-- 查看复制相关状态
SHOW STATUS LIKE '%replica%';
SHOW STATUS LIKE '%slave%';  -- 旧版本用slave
```

**🔸 复制核心变量**

| 变量名 | **含义** | **监控重点** |
|--------|---------|-------------|
| `Slave_running` | `从服务器是否运行` | `应该为ON` |
| `Slave_lag_seconds` | `复制延迟秒数` | `越小越好` |
| `Slave_received_heartbeats` | `收到的心跳数` | `确保连接正常` |

### 7.2 复制延迟分析


```sql
-- 检查复制延迟 (在从服务器执行)
SHOW SLAVE STATUS\G

-- 或查看状态变量
SELECT 
    VARIABLE_NAME as '状态项',
    VARIABLE_VALUE as '值'
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME LIKE '%slave%' OR VARIABLE_NAME LIKE '%replica%';
```

**复制健康标准**：
```
复制延迟:
优秀: < 1秒
良好: 1-5秒
需要关注: 5-30秒  
严重问题: > 30秒

复制状态:
Slave_IO_Running: Yes ✅
Slave_SQL_Running: Yes ✅
Last_Error: (空) ✅
```

---

## 8. 🧵 线程状态变量解析


### 8.1 线程池监控

线程状态变量帮助我们了解MySQL的线程使用情况和并发处理能力。

```sql
-- 查看线程相关状态  
SHOW STATUS LIKE '%thread%';
SHOW PROCESSLIST;  -- 查看当前线程活动
```

**🔸 线程状态核心变量**

| 变量名 | **含义** | **正常范围** |
|--------|---------|-------------|
| `Threads_cached` | `线程缓存中的线程数` | `> 0表示有复用` |
| `Threads_created` | `创建的线程总数` | `增长缓慢为好` |
| `Threads_connected` | `当前连接的线程数` | `< max_connections` |
| `Threads_running` | `非睡眠状态的线程数` | `< CPU核心数×2` |

### 8.2 线程效率分析


```sql
-- 计算线程缓存命中率
SELECT 
    ROUND(
        (Connections - Threads_created) / Connections * 100, 2
    ) AS '线程缓存命中率%'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Connections' THEN VARIABLE_VALUE END) AS Connections,
        MAX(CASE WHEN VARIABLE_NAME='Threads_created' THEN VARIABLE_VALUE END) AS Threads_created
    FROM information_schema.GLOBAL_STATUS
) t;
```

**线程状态分析图示**：
```
线程生命周期:
创建 → 执行 → 缓存 → 复用
  ↓      ↓      ↓      ↓
新连接  处理请求 空闲等待 重新分配

理想状态:
- 高缓存命中率 (> 90%)
- 低创建频率
- 合理的运行线程数
```

---

## 9. 🔗 状态变量关联分析


### 9.1 性能瓶颈识别矩阵

通过多个状态变量的组合分析，可以准确定位性能瓶颈所在。

**CPU瓶颈识别**：
```sql
-- CPU压力分析
SELECT 
    '线程运行数' as '指标',
    Threads_running as '当前值',
    CASE 
        WHEN Threads_running > $$global.innodb_thread_concurrency THEN '超负荷'
        WHEN Threads_running > $$global.innodb_thread_concurrency * 0.8 THEN '高负荷'  
        ELSE '正常'
    END as '状态评估'
FROM (
    SELECT VARIABLE_VALUE as Threads_running
    FROM information_schema.GLOBAL_STATUS 
    WHERE VARIABLE_NAME = 'Threads_running'
) t;
```

### 9.2 内存瓶颈识别


```sql
-- 内存使用效率分析
SELECT 
    '缓冲池命中率' as '指标类型',
    CONCAT(
        ROUND((1 - reads/read_requests) * 100, 2), '%'
    ) as '命中率',
    CASE 
        WHEN (1 - reads/read_requests) > 0.95 THEN '优秀'
        WHEN (1 - reads/read_requests) > 0.90 THEN '良好'
        WHEN (1 - reads/read_requests) > 0.80 THEN '需要优化'
        ELSE '严重不足'
    END as '评估结果'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Innodb_buffer_pool_reads' THEN VARIABLE_VALUE END) as reads,
        MAX(CASE WHEN VARIABLE_NAME='Innodb_buffer_pool_read_requests' THEN VARIABLE_VALUE END) as read_requests
    FROM information_schema.GLOBAL_STATUS
) t;
```

### 9.3 IO瓶颈识别


```
IO瓶颈判断矩阵:

高磁盘读取 + 低缓存命中率 = 内存不足
高磁盘写入 + 高脏页比例 = 写入压力大  
高锁等待 + 高并发线程 = 锁竞争激烈
高连接失败 + 高连接数 = 连接资源耗尽
```

---

## 10. 🚨 状态异常模式识别


### 10.1 常见异常模式


**🔸 连接风暴模式**
```sql
-- 识别连接异常
SELECT 
    'Aborted_connects' as '异常类型',
    VARIABLE_VALUE as '当前值',
    CASE 
        WHEN VARIABLE_VALUE > 100 THEN '连接频繁失败'
        WHEN VARIABLE_VALUE > 50 THEN '连接偶有失败'
        ELSE '连接状态正常'
    END as '状态诊断'
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Aborted_connects';
```

**🔸 锁竞争模式**
```sql
-- 识别锁竞争异常
SELECT 
    '锁等待时间' as '监控项',
    ROUND(lock_time/lock_waits, 2) as '平均等待毫秒',
    CASE 
        WHEN lock_time/lock_waits > 100 THEN '严重锁竞争'
        WHEN lock_time/lock_waits > 50 THEN '中等锁竞争'  
        WHEN lock_time/lock_waits > 10 THEN '轻微锁竞争'
        ELSE '锁状态良好'
    END as '竞争程度'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Innodb_row_lock_time' THEN VARIABLE_VALUE END) as lock_time,
        MAX(CASE WHEN VARIABLE_NAME='Innodb_row_lock_waits' THEN VARIABLE_VALUE END) as lock_waits
    FROM information_schema.GLOBAL_STATUS
) t
WHERE lock_waits > 0;
```

### 10.2 异常模式告警阈值


| 异常类型 | **监控指标** | **告警阈值** | **紧急阈值** |
|---------|-------------|-------------|-------------|
| **连接异常** | `Aborted_connects增长率` | `> 10/分钟` | `> 50/分钟` |
| **锁竞争** | `平均锁等待时间` | `> 50ms` | `> 200ms` |
| **缓存失效** | `缓冲池命中率` | `< 90%` | `< 80%` |
| **IO压力** | `磁盘读写比例` | `读写比 < 3:1` | `读写比 < 1:1` |

---

## 11. 🎯 状态优化建议生成


### 11.1 自动化诊断脚本


```sql
-- 综合性能诊断
SELECT 
    '性能诊断报告' as '=====报告类型=====',
    NOW() as '生成时间';

-- 连接状态评估
SELECT 
    '连接评估' as '评估项目',
    CONCAT('当前连接: ', current_conn, ' | 运行线程: ', running_threads) as '状态详情',
    CASE 
        WHEN current_conn/max_conn > 0.8 THEN '连接数过高，建议优化连接池'
        WHEN running_threads > 50 THEN '运行线程过多，检查慢查询'
        ELSE '连接状态正常'
    END as '优化建议'
FROM (
    SELECT 
        MAX(CASE WHEN VARIABLE_NAME='Threads_connected' THEN VARIABLE_VALUE END) as current_conn,
        MAX(CASE WHEN VARIABLE_NAME='Threads_running' THEN VARIABLE_VALUE END) as running_threads,
        $$global.max_connections as max_conn
    FROM information_schema.GLOBAL_STATUS
) t;
```

### 11.2 针对性优化建议


**🔸 连接优化建议**
```
连接数过高：
1. 优化应用连接池配置
2. 减少连接超时时间
3. 增加max_connections参数

连接失败过多：
1. 检查网络连接稳定性
2. 验证用户权限配置  
3. 调整connect_timeout参数
```

**🔸 查询优化建议**
```
查询性能差：
1. 分析慢查询日志
2. 检查索引使用情况
3. 优化SQL语句结构

缓存命中率低：
1. 增加innodb_buffer_pool_size
2. 启用查询缓存 (MySQL 5.7及以下)
3. 优化查询语句减少全表扫描
```

**🔸 锁优化建议**
```
锁等待过多：
1. 优化事务大小，减少事务时间
2. 调整隔离级别
3. 添加合适的索引减少锁范围
4. 考虑分库分表降低锁竞争
```

---

## 12. ⚙️ 系统变量监控分析


### 12.1 关键系统变量监控


```sql
-- 查看重要系统变量
SHOW VARIABLES LIKE 'max_connections';
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
SHOW VARIABLES LIKE 'query_cache_size';
```

**🔸 核心系统变量**

| 变量名 | **作用** | **监控要点** |
|--------|---------|-------------|
| `max_connections` | `最大连接数限制` | `与Threads_connected对比` |
| `innodb_buffer_pool_size` | `InnoDB缓冲池大小` | `影响缓存命中率` |
| `query_cache_size` | `查询缓存大小` | `影响查询缓存效果` |
| `innodb_thread_concurrency` | `InnoDB并发线程数` | `与Threads_running对比` |

### 12.2 变量配置合理性检查


```sql
-- 检查缓冲池配置是否合理
SELECT 
    '缓冲池配置检查' as '检查项',
    CONCAT(
        ROUND($$global.innodb_buffer_pool_size/1024/1024/1024, 1), 'GB'
    ) as '当前配置',
    CASE 
        WHEN $$global.innodb_buffer_pool_size < 1073741824 THEN '偏小，建议增加'
        WHEN $$global.innodb_buffer_pool_size > 8589934592 THEN '较大，检查是否必要'
        ELSE '配置合理'
    END as '配置建议';
```

### 12.3 动态调整监控


```sql
-- 动态修改系统变量 (部分变量支持)
SET GLOBAL max_connections = 200;
SET GLOBAL innodb_thread_concurrency = 16;

-- 检查修改后效果
SHOW STATUS LIKE 'Threads_connected';
SHOW STATUS LIKE 'Threads_running';
```

**变量调整注意事项**：
```
可动态调整变量:
✅ max_connections - 最大连接数
✅ query_cache_size - 查询缓存大小
✅ innodb_thread_concurrency - 并发线程数

需要重启生效:
❌ innodb_buffer_pool_size - 缓冲池大小
❌ innodb_log_file_size - 日志文件大小
```

---

## 13. 📋 核心要点总结


### 13.1 状态变量监控要点


**🔸 必须监控的核心指标**
```
连接状态：Threads_connected, Threads_running, Aborted_connects
查询状态：Questions, Com_select, Com_insert, Com_update  
缓存状态：Qcache_hits, Innodb_buffer_pool_read_requests
锁状态：Table_locks_waited, Innodb_row_lock_waits
IO状态：Innodb_data_reads, Innodb_data_writes
```

### 13.2 性能诊断思路


**🔹 分层诊断方法**
```
第一层 - 连接层：
检查连接数是否正常，有无连接风暴

第二层 - 查询层：  
分析查询类型分布，识别慢查询

第三层 - 存储层：
检查缓存命中率，分析IO压力

第四层 - 锁层：
监控锁等待情况，识别并发冲突
```

### 13.3 监控最佳实践


**🔹 监控频率建议**
- **实时监控**：连接数、运行线程数
- **每分钟**：查询QPS、缓存命中率  
- **每5分钟**：锁等待状态、IO统计
- **每小时**：历史趋势分析

**🔹 告警设置原则**
```
告警级别设计：
信息级：超过正常范围20%
警告级：超过正常范围50%  
紧急级：超过正常范围100%或影响业务

告警指标优先级：
P0: 连接数、死锁、复制中断
P1: 缓存命中率、锁等待时间
P2: IO压力、线程数
```

### 13.4 优化建议总结


**核心记忆要点**：
- 状态变量是MySQL的"体检报告"，反映运行健康状况
- 通过多变量组合分析可以准确定位性能瓶颈
- 连接、查询、缓存、锁、IO是五大核心监控维度  
- 建立阈值告警机制，实现主动运维
- 状态变量分析要结合系统变量配置进行优化

**监控口诀**：
```
连接查询缓存锁，IO复制要记牢
状态变量组合看，瓶颈诊断不会跑
阈值告警提前设，主动运维效果好
优化建议要针对，系统配置要协调
```