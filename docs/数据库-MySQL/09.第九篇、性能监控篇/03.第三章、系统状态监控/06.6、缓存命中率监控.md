---
title: 6、缓存命中率监控
---
## 📚 目录

1. [缓存命中率基础概念](#1-缓存命中率基础概念)
2. [Query Cache查询缓存监控](#2-query-cache查询缓存监控)
3. [InnoDB Buffer Pool缓冲池监控](#3-innodb-buffer-pool缓冲池监控)
4. [Key Cache索引缓存监控](#4-key-cache索引缓存监控)
5. [表缓存命中率监控](#5-表缓存命中率监控)
6. [连接缓存命中率监控](#6-连接缓存命中率监控)
7. [缓存效率综合分析](#7-缓存效率综合分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 缓存命中率基础概念


### 1.1 什么是缓存命中率


缓存命中率就是**数据从缓存中直接获取的比例**。想象一下你的书桌，常用的书放在桌上就是"缓存"，每次需要时直接拿取就是"命中"，如果桌上没有就要去书柜找，这就是"未命中"。

**🔸 核心概念**
```
命中率 = 从缓存获取的次数 / 总请求次数 × 100%

例如：100次查询中，80次从缓存获取 → 命中率80%
```

### 1.2 为什么缓存命中率很重要


**🔸 性能影响对比**
- **缓存命中**：数据在内存中，毫秒级响应
- **缓存未命中**：需要从磁盘读取，响应时间可能慢100-1000倍

**🔸 实际业务影响**
```
命中率90%：平均响应时间较快
命中率50%：系统性能明显下降  
命中率10%：用户体验很差，系统负载高
```

### 1.3 MySQL中的主要缓存类型


```
MySQL缓存体系结构：

应用层请求
    ↓
Query Cache (查询缓存) ← 缓存完整查询结果
    ↓
InnoDB Buffer Pool ← 缓存数据页和索引页  
    ↓
Key Cache (MyISAM) ← 缓存索引数据
    ↓
Table Cache ← 缓存表结构信息
    ↓
磁盘存储
```

---

## 2. 🔍 Query Cache查询缓存监控


### 2.1 Query Cache工作原理


Query Cache会把**完整的SELECT查询结果**存储在内存中。当下次有完全相同的查询时，直接返回缓存的结果，不需要重新执行。

**🔸 缓存匹配条件（必须完全一致）**
```sql
-- 这两个查询会被认为是不同的（大小写不同）
SELECT * FROM users WHERE id = 1;
select * from users where id = 1;

-- 这两个查询也是不同的（空格不同）  
SELECT * FROM users WHERE id=1;
SELECT * FROM users WHERE id = 1;
```

### 2.2 Query Cache关键监控指标


**🔸 查看Query Cache状态**
```sql
-- 查看查询缓存相关变量
SHOW VARIABLES LIKE 'query_cache%';

-- 查看查询缓存统计信息
SHOW STATUS LIKE 'Qcache%';
```

**🔸 核心指标含义**
```sql
-- 缓存大小配置
query_cache_size = 16M        -- 查询缓存总大小
query_cache_limit = 1M        -- 单个查询结果最大缓存大小

-- 运行状态统计  
Qcache_hits = 1000           -- 缓存命中次数
Qcache_inserts = 200         -- 缓存插入次数  
Qcache_not_cached = 50       -- 未缓存查询次数
Qcache_queries_in_cache = 150 -- 当前缓存中的查询数
```

### 2.3 Query Cache命中率计算


```sql
-- 计算查询缓存命中率
SELECT 
  ROUND(
    Qcache_hits / (Qcache_hits + Qcache_inserts + Qcache_not_cached) * 100, 2
  ) AS query_cache_hit_rate;
```

**🔸 命中率评估标准**
- **80%以上**：缓存效果很好
- **50%-80%**：缓存效果一般，可以优化
- **50%以下**：缓存效果差，需要检查配置

> ⚠️ **重要提醒**  
> MySQL 8.0版本已经移除了Query Cache功能，因为在高并发场景下反而可能降低性能。

---

## 3. 🏊 InnoDB Buffer Pool缓冲池监控


### 3.1 Buffer Pool工作原理


InnoDB Buffer Pool是MySQL最重要的缓存，它把**数据页**和**索引页**存储在内存中。这就像是把常用的文件放在桌面上，需要时直接打开，不用去硬盘里翻找。

**🔸 Buffer Pool结构**
```
Buffer Pool (内存缓冲池)
├── 数据页缓存 (Data Pages)
├── 索引页缓存 (Index Pages)  
├── 插入缓冲 (Insert Buffer)
└── 锁信息 (Lock Info)
```

### 3.2 Buffer Pool关键监控指标


**🔸 查看Buffer Pool状态**
```sql
-- 查看缓冲池大小配置
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

-- 查看缓冲池统计信息
SHOW STATUS LIKE 'Innodb_buffer_pool%';
```

**🔸 核心指标详解**
```sql
Innodb_buffer_pool_reads = 1000      -- 从磁盘读取页的次数
Innodb_buffer_pool_read_requests = 10000  -- 总的页读取请求次数
Innodb_buffer_pool_pages_total = 8192     -- 缓冲池总页数
Innodb_buffer_pool_pages_free = 1024      -- 空闲页数
Innodb_buffer_pool_pages_data = 7000      -- 包含数据的页数
```

### 3.3 Buffer Pool命中率计算


```sql
-- 计算InnoDB缓冲池命中率
SELECT 
  ROUND(
    (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100, 2
  ) AS buffer_pool_hit_rate;
```

**🔸 命中率评估标准**
- **99%以上**：缓存效果优秀
- **95%-99%**：缓存效果良好
- **90%-95%**：缓存效果一般，建议增加缓冲池大小
- **90%以下**：缓存效果差，严重影响性能

### 3.4 Buffer Pool使用率监控


```sql
-- 检查缓冲池使用情况
SELECT 
  ROUND(
    (Innodb_buffer_pool_pages_data / Innodb_buffer_pool_pages_total) * 100, 2
  ) AS buffer_pool_usage_rate;
```

---

## 4. 🔑 Key Cache索引缓存监控


### 4.1 Key Cache工作原理


Key Cache专门为**MyISAM存储引擎**缓存索引数据。虽然现在InnoDB更常用，但在一些特定场景下仍会使用MyISAM，所以了解Key Cache也很重要。

### 4.2 Key Cache监控指标


**🔸 查看Key Cache配置和状态**
```sql
-- 查看索引缓存大小
SHOW VARIABLES LIKE 'key_buffer_size';

-- 查看索引缓存统计
SHOW STATUS LIKE 'Key_%';
```

**🔸 关键指标含义**
```sql
Key_reads = 500              -- 从磁盘读取索引的次数
Key_read_requests = 5000     -- 索引读取请求总次数
Key_writes = 100             -- 向磁盘写入索引的次数  
Key_write_requests = 1000    -- 索引写入请求总次数
```

### 4.3 Key Cache命中率计算


```sql
-- 计算索引缓存读命中率
SELECT 
  ROUND(
    (1 - Key_reads / Key_read_requests) * 100, 2
  ) AS key_cache_read_hit_rate;

-- 计算索引缓存写命中率  
SELECT 
  ROUND(
    (1 - Key_writes / Key_write_requests) * 100, 2
  ) AS key_cache_write_hit_rate;
```

---

## 5. 📋 表缓存命中率监控


### 5.1 表缓存工作原理


MySQL会把**表的结构信息**缓存在内存中，包括表定义、列信息、索引结构等。这样每次查询时不需要重新从磁盘读取表结构。

### 5.2 表缓存监控指标


**🔸 查看表缓存配置**
```sql
-- 查看表缓存相关配置
SHOW VARIABLES LIKE 'table_open_cache';
SHOW VARIABLES LIKE 'table_definition_cache';
```

**🔸 查看表缓存统计**
```sql
-- 查看表缓存使用情况
SHOW STATUS LIKE 'Open%tables%';
SHOW STATUS LIKE 'Opened_tables';
```

### 5.3 表缓存效率分析


```sql
-- 检查表缓存是否足够
SELECT 
  Open_tables,                    -- 当前打开的表数量
  Opened_tables,                  -- 累计打开过的表数量
  ROUND(
    (Open_tables / table_open_cache) * 100, 2
  ) AS table_cache_usage_rate
FROM 
  (SELECT $$table_open_cache AS table_open_cache) tc,
  (SELECT 
     VARIABLE_VALUE AS Open_tables 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Open_tables') ot,
  (SELECT 
     VARIABLE_VALUE AS Opened_tables 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Opened_tables') opt;
```

> 💡 **优化建议**  
> 如果Opened_tables增长很快，说明表缓存不够用，需要增加table_open_cache的值。

---

## 6. 🔌 连接缓存命中率监控


### 6.1 连接缓存工作原理


MySQL使用**连接池**来管理客户端连接。当客户端断开连接时，服务器不会立即销毁连接，而是放入缓存池中，供下次使用。

### 6.2 连接相关监控指标


**🔸 查看连接配置**
```sql
-- 查看连接相关配置
SHOW VARIABLES LIKE 'max_connections';
SHOW VARIABLES LIKE 'thread_cache_size';
```

**🔸 查看连接统计信息**
```sql
-- 查看连接统计
SHOW STATUS LIKE 'Connections';
SHOW STATUS LIKE 'Threads_%';
```

### 6.3 连接缓存效率分析


```sql
-- 分析线程缓存效率
SELECT 
  Threads_created,
  Connections,
  ROUND(
    (Threads_created / Connections) * 100, 2
  ) AS thread_cache_miss_rate
FROM 
  (SELECT VARIABLE_VALUE AS Threads_created 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Threads_created') tc,
  (SELECT VARIABLE_VALUE AS Connections 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Connections') c;
```

**🔸 评估标准**
- **线程缓存命中率 > 90%**：连接缓存效果良好
- **线程缓存命中率 < 90%**：建议增加thread_cache_size

---

## 7. 📊 缓存效率综合分析


### 7.1 创建缓存监控视图


```sql
-- 创建综合缓存监控视图
CREATE VIEW cache_monitor AS
SELECT 
  'Query Cache' AS cache_type,
  ROUND(
    Qcache_hits / (Qcache_hits + Qcache_inserts + Qcache_not_cached) * 100, 2
  ) AS hit_rate,
  'percentage' AS unit,
  CASE 
    WHEN ROUND(Qcache_hits / (Qcache_hits + Qcache_inserts + Qcache_not_cached) * 100, 2) >= 80 
    THEN 'Good'
    WHEN ROUND(Qcache_hits / (Qcache_hits + Qcache_inserts + Qcache_not_cached) * 100, 2) >= 50 
    THEN 'Fair'
    ELSE 'Poor'
  END AS status
FROM 
  (SELECT VARIABLE_VALUE AS Qcache_hits FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Qcache_hits') qh,
  (SELECT VARIABLE_VALUE AS Qcache_inserts FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Qcache_inserts') qi,
  (SELECT VARIABLE_VALUE AS Qcache_not_cached FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Qcache_not_cached') qnc

UNION ALL

SELECT 
  'InnoDB Buffer Pool' AS cache_type,
  ROUND(
    (1 - bp_reads / bp_read_requests) * 100, 2
  ) AS hit_rate,
  'percentage' AS unit,
  CASE 
    WHEN ROUND((1 - bp_reads / bp_read_requests) * 100, 2) >= 99 THEN 'Excellent'
    WHEN ROUND((1 - bp_reads / bp_read_requests) * 100, 2) >= 95 THEN 'Good'
    WHEN ROUND((1 - bp_reads / bp_read_requests) * 100, 2) >= 90 THEN 'Fair'
    ELSE 'Poor'
  END AS status
FROM 
  (SELECT VARIABLE_VALUE AS bp_reads FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') br,
  (SELECT VARIABLE_VALUE AS bp_read_requests FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') brr;
```

### 7.2 缓存监控告警脚本


```sql
-- 检查需要告警的缓存指标
SELECT 
  cache_type,
  hit_rate,
  status,
  CASE 
    WHEN status IN ('Poor', 'Fair') THEN 'Need Attention'
    ELSE 'OK'
  END AS alert_level,
  CASE 
    WHEN cache_type = 'InnoDB Buffer Pool' AND hit_rate < 95 
    THEN 'Consider increasing innodb_buffer_pool_size'
    WHEN cache_type = 'Query Cache' AND hit_rate < 50 
    THEN 'Check query cache configuration or disable it'
    ELSE 'No immediate action required'
  END AS recommendation
FROM cache_monitor
WHERE status IN ('Poor', 'Fair');
```

### 7.3 缓存优化建议矩阵


| 缓存类型 | **命中率范围** | **状态评级** | **优化建议** |
|---------|--------------|-------------|-------------|
| 🔸 **InnoDB Buffer Pool** | `>99%` | `优秀` | `保持当前配置` |
| 🔸 **InnoDB Buffer Pool** | `95%-99%` | `良好` | `可适当增加缓冲池大小` |
| 🔸 **InnoDB Buffer Pool** | `<95%` | `需要优化` | `增加innodb_buffer_pool_size` |
| 🔸 **Query Cache** | `>80%` | `良好` | `保持当前配置` |
| 🔸 **Query Cache** | `<50%` | `效果差` | `考虑禁用或重新设计查询` |

---

## 8. 📋 核心要点总结


### 8.1 缓存监控核心要点


```
🔸 InnoDB Buffer Pool：最重要的缓存，命中率应该>95%
🔸 Query Cache：MySQL 8.0已移除，早期版本需要谨慎使用
🔸 Key Cache：主要用于MyISAM，现在使用较少
🔸 表缓存：影响表打开速度，关注Opened_tables增长速度
🔸 连接缓存：影响连接建立性能，关注线程创建频率
```

### 8.2 监控最佳实践


**🔸 日常监控重点**
1. **InnoDB Buffer Pool命中率** - 每日检查
2. **Buffer Pool使用率** - 避免内存浪费
3. **表缓存效率** - 防止频繁的表结构读取
4. **连接复用效率** - 减少连接创建开销

**🔸 告警阈值建议**
```
Buffer Pool命中率 < 95%：警告级别
Buffer Pool命中率 < 90%：严重级别
表缓存未命中率过高：关注级别
连接缓存效率 < 90%：优化建议级别
```

### 8.3 性能优化记忆要点


> 🧠 **记忆口诀**  
> "缓存命中是关键，Buffer Pool最重要，表缓存防重开，连接池要够用"

**🔸 优化思路总结**
- **增加缓存大小**：解决命中率低的问题
- **调整缓存策略**：根据业务特点配置
- **监控缓存效率**：持续观察和调整
- **避免缓存污染**：防止无效数据占用缓存

**核心理解**：缓存就是用内存换时间，命中率越高性能越好，但也要平衡内存使用效率。