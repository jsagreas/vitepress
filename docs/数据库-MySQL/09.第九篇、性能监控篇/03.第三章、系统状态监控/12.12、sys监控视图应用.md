---
title: 12、sys监控视图应用
---
## 📚 目录

1. [sys监控视图系统概述](#1-sys监控视图系统概述)
2. [sys schema核心视图详解](#2-sys-schema核心视图详解)
3. [性能视图查询应用](#3-性能视图查询应用)
4. [监控数据快速分析](#4-监控数据快速分析)
5. [系统状态概览实战](#5-系统状态概览实战)
6. [性能问题快速诊断](#6-性能问题快速诊断)
7. [sys视图最佳实践](#7-sys视图最佳实践)
8. [监控视图定制化开发](#8-监控视图定制化开发)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 sys监控视图系统概述


### 1.1 什么是sys监控视图系统


**简单理解**：sys监控视图就像是MySQL的"体检报告生成器"，它把复杂的性能数据变成了普通人也能看懂的报告。

```
传统方式查看MySQL性能：
需要查询复杂的 performance_schema 表
需要写复杂的SQL语句
需要深入理解底层指标含义

sys监控视图方式：
直接查询简单易懂的视图
获得整理好的性能报告
快速定位问题所在
```

**🔸 核心特点**
- **简化复杂性**：把复杂的性能指标包装成简单视图
- **开箱即用**：MySQL 5.7+ 默认提供，无需安装
- **人性化展示**：数据格式化，便于阅读理解
- **覆盖全面**：涵盖性能、IO、锁、连接等各个方面

### 1.2 sys schema的工作原理


**底层架构图**：
```
应用程序
    ↓
sys 视图 (友好的查询界面)
    ↓
performance_schema (原始性能数据)
    ↓
information_schema (元数据信息)
    ↓
MySQL 服务器内部统计
```

**🔸 数据流转过程**
1. MySQL内部收集各种性能统计数据
2. 存储到performance_schema和information_schema
3. sys schema对这些数据进行聚合和格式化
4. 提供易于理解的视图供用户查询

### 1.3 为什么需要sys监控视图


**传统监控的痛点**：
```sql
-- 传统方式：查看慢查询需要复杂SQL
SELECT 
  digest_text,
  count_star,
  avg_timer_wait/1000000000 as avg_time_ms
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait > 1000000000
ORDER BY avg_timer_wait DESC;
```

**sys视图的简化**：
```sql
-- sys方式：一行SQL搞定
SELECT * FROM sys.statements_with_runtimes_in_95th_percentile;
```

---

## 2. 📊 sys schema核心视图详解


### 2.1 视图分类概览


**sys schema视图分为四大类**：

| 视图类别 | **主要功能** | **典型应用** | **查询频率** |
|---------|------------|-------------|-------------|
| 🔍 **语句分析视图** | `分析SQL执行性能` | `慢查询优化` | `高频使用` |
| 📊 **IO分析视图** | `监控磁盘IO状况` | `存储性能调优` | `中频使用` |
| 🔐 **锁分析视图** | `查看锁等待情况` | `并发问题诊断` | `问题排查` |
| 🌐 **连接分析视图** | `监控连接状态` | `连接池优化` | `日常监控` |

### 2.2 语句分析核心视图


**慢查询相关视图**：

```sql
-- 1. 查看最慢的语句
SELECT * FROM sys.statements_with_runtimes_in_95th_percentile LIMIT 5;

-- 2. 查看错误最多的语句  
SELECT * FROM sys.statements_with_errors_or_warnings LIMIT 5;

-- 3. 查看全表扫描的语句
SELECT * FROM sys.statements_with_full_table_scans LIMIT 5;
```

**🔸 语句分析视图详解**

| 视图名称 | **监控内容** | **关键字段** | **使用场景** |
|---------|------------|-------------|-------------|
| `statements_with_runtimes_in_95th_percentile` | `95%分位数慢查询` | `query, avg_latency` | `性能调优` |
| `statements_with_full_table_scans` | `全表扫描语句` | `query, no_index_used` | `索引优化` |
| `statements_with_temp_tables` | `使用临时表语句` | `query, memory_tmp_tables` | `内存优化` |

### 2.3 IO分析核心视图


**IO性能监控**：

```sql
-- 1. 查看IO最繁忙的文件
SELECT * FROM sys.io_global_by_file_by_bytes LIMIT 10;

-- 2. 查看IO最慢的语句
SELECT * FROM sys.io_global_by_wait_by_latency LIMIT 10;

-- 3. 查看等待时间最长的IO操作
SELECT * FROM sys.io_by_thread_by_latency LIMIT 10;
```

**🔸 IO监控指标解读**

```
IO延迟分析：
┌─────────────────┐
│   磁盘读写请求   │
├─────────────────┤  
│   等待队列时间   │ ← 系统负载指标
├─────────────────┤
│   实际IO时间    │ ← 硬件性能指标  
├─────────────────┤
│   数据传输时间   │ ← 网络/总线性能
└─────────────────┘
```

### 2.4 锁分析核心视图


**锁等待监控**：

```sql
-- 1. 查看当前锁等待情况
SELECT * FROM sys.innodb_lock_waits;

-- 2. 查看锁等待历史统计
SELECT * FROM sys.schema_table_lock_waits;

-- 3. 查看表级锁统计
SELECT * FROM sys.schema_table_statistics;
```

**🔸 锁等待分析流程**

```
锁冲突分析链：
持锁事务 → 等待事务 → 影响范围 → 解决方案
    ↓         ↓         ↓         ↓
  事务ID   被锁资源   等待时间   优化建议
```

---

## 3. ⚡ 性能视图查询应用


### 3.1 性能热点快速定位


**🔥 最常用的性能诊断查询**

```sql
-- 性能问题TOP榜单
SELECT 
  query,
  exec_count,
  avg_latency,
  total_latency
FROM sys.statements_with_runtimes_in_95th_percentile 
ORDER BY avg_latency DESC 
LIMIT 10;
```

**输出示例解读**：
```
+------------------+------------+-------------+---------------+
| query            | exec_count | avg_latency | total_latency |
+------------------+------------+-------------+---------------+
| SELECT * FROM... |       1250 | 2.5s        | 52m 5s        |
| UPDATE users...  |        890 | 1.8s        | 26m 42s       |
+------------------+------------+-------------+---------------+

解读说明：
- exec_count: 执行次数（高频执行需要重点关注）
- avg_latency: 平均耗时（单次性能指标）  
- total_latency: 总耗时（整体影响程度）
```

### 3.2 资源消耗分析


**内存使用分析**：

```sql
-- 1. 查看内存使用TOP用户
SELECT * FROM sys.user_summary_by_statement_type 
ORDER BY total_latency DESC LIMIT 5;

-- 2. 查看临时表使用情况
SELECT 
  query,
  memory_tmp_tables,
  disk_tmp_tables,
  avg_latency
FROM sys.statements_with_temp_tables 
WHERE disk_tmp_tables > 0;
```

**🔸 内存监控关键指标**

| 指标类型 | **监控视图** | **关注阈值** | **优化方向** |
|---------|------------|-------------|-------------|
| 🧠 **连接内存** | `memory_by_thread_by_current_bytes` | `>50MB/连接` | `调整连接参数` |
| 📊 **临时表内存** | `statements_with_temp_tables` | `disk_tmp_tables>0` | `优化查询逻辑` |
| 🔄 **排序内存** | `memory_global_by_current_bytes` | `sort_buffer异常` | `调整排序参数` |

### 3.3 并发性能分析


**连接并发监控**：

```sql
-- 当前活跃连接分析
SELECT 
  user,
  host,
  current_connections,
  total_connections
FROM sys.user_summary 
ORDER BY current_connections DESC;

-- 等待事件分析
SELECT 
  event_name,
  count_star,
  sum_timer_wait/1000000000 as total_wait_time_seconds
FROM sys.wait_events_global_by_avg_latency 
ORDER BY total_wait_time_seconds DESC 
LIMIT 10;
```

---

## 4. 📈 监控数据快速分析


### 4.1 一键式性能体检


**🏥 MySQL健康检查脚本**

```sql
-- 系统整体健康度检查
SELECT 
  'Slow Queries' as metric,
  COUNT(*) as value,
  'Check if > 100' as recommendation
FROM sys.statements_with_runtimes_in_95th_percentile
UNION ALL
SELECT 
  'Full Table Scans',
  COUNT(*),
  'Should minimize'
FROM sys.statements_with_full_table_scans
UNION ALL
SELECT 
  'Temp Tables on Disk',
  COUNT(*),
  'Should be 0'
FROM sys.statements_with_temp_tables 
WHERE disk_tmp_tables > 0;
```

**快速诊断报告格式**：
```
MySQL性能检查报告
═══════════════════════════════════
📊 慢查询统计: 23条 (建议<10条)
🔍 全表扫描: 8条 (建议优化)  
💾 磁盘临时表: 3条 (需要关注)
🔐 锁等待: 0条 (状态良好)
📡 连接数: 45/200 (使用率正常)
```

### 4.2 性能趋势分析


**历史性能对比**：

```sql
-- 查看性能变化趋势（需要历史数据）
SELECT 
  DATE(from_unixtime(first_seen)) as date,
  COUNT(*) as slow_query_count,
  AVG(avg_latency) as avg_response_time
FROM sys.statements_with_runtimes_in_95th_percentile
GROUP BY DATE(from_unixtime(first_seen))
ORDER BY date DESC 
LIMIT 7;
```

### 4.3 异常模式识别


**🚨 异常检测规则**

```sql
-- 检测异常的性能模式
SELECT 
  'High CPU Usage' as alert_type,
  user,
  total_latency,
  'Check query optimization' as action
FROM sys.user_summary_by_statement_type 
WHERE total_latency > '10:00:00'  -- 超过10分钟总耗时
UNION ALL
SELECT 
  'Excessive Full Scans',
  digest_text,
  count_star,
  'Add proper indexes'
FROM sys.statements_with_full_table_scans 
WHERE count_star > 100;  -- 执行超过100次的全表扫描
```

---

## 5. 🎛️ 系统状态概览实战


### 5.1 实时系统状态监控


**系统状态仪表盘查询**：

```sql
-- 核心性能指标仪表盘
SELECT 
  'QPS' as metric,
  ROUND(COUNT(*)/60, 2) as value,  -- 每秒查询数
  'queries/second' as unit
FROM performance_schema.events_statements_history
WHERE timer_start > (SELECT MAX(timer_start) - 60000000000000 FROM performance_schema.events_statements_history)
UNION ALL
SELECT 
  'Avg Response Time',
  ROUND(AVG(timer_wait)/1000000, 2),
  'milliseconds'
FROM performance_schema.events_statements_history
WHERE timer_start > (SELECT MAX(timer_start) - 60000000000000 FROM performance_schema.events_statements_history);
```

**🔸 关键性能指标说明**

```
性能指标金字塔：
         QPS (吞吐量)
        /              \
   响应时间           并发连接数
   /      \           /        \
CPU使用率  内存使用率  锁等待    IO等待
```

### 5.2 资源使用状况监控


**系统资源使用分析**：

```sql
-- 资源消耗TOP分析
SELECT 
  user,
  current_connections,
  current_memory,
  total_memory_allocated
FROM sys.user_summary 
WHERE current_connections > 0
ORDER BY current_memory DESC;

-- 数据库空间使用分析
SELECT 
  table_schema,
  ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS total_mb,
  ROUND(SUM(data_length) / 1024 / 1024, 2) AS data_mb,
  ROUND(SUM(index_length) / 1024 / 1024, 2) AS index_mb
FROM information_schema.tables 
GROUP BY table_schema 
ORDER BY total_mb DESC;
```

### 5.3 连接状态监控


**连接池健康检查**：

```sql
-- 连接状态统计
SELECT 
  processlist_state,
  COUNT(*) as connection_count,
  ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage
FROM sys.processlist 
GROUP BY processlist_state
ORDER BY connection_count DESC;
```

**连接状态解读**：
```
连接状态分布图：
Sleep (空闲): ████████████░ 75%
Query (执行): ███░░░░░░░░░░ 18%  
Locked (锁等待): █░░░░░░░░░░░░ 5%
Other (其他): █░░░░░░░░░░░░ 2%

状态说明：
- Sleep: 连接空闲，等待新请求
- Query: 正在执行SQL语句  
- Locked: 等待锁释放
- Other: 其他状态（Connect、Init等）
```

---

## 6. 🔧 性能问题快速诊断


### 6.1 慢查询问题诊断


**慢查询快速定位流程**：

```sql
-- Step 1: 找出最慢的查询
SELECT 
  LEFT(digest_text, 100) as query_sample,
  count_star as exec_count,
  ROUND(avg_timer_wait/1000000000, 2) as avg_seconds,
  ROUND(max_timer_wait/1000000000, 2) as max_seconds
FROM sys.statements_with_runtimes_in_95th_percentile 
ORDER BY avg_timer_wait DESC 
LIMIT 5;

-- Step 2: 分析查询的执行计划
EXPLAIN FORMAT=JSON 
SELECT /* 这里放上面找到的慢查询 */;

-- Step 3: 检查相关表的索引情况
SELECT 
  table_name,
  index_name,
  column_name,
  cardinality
FROM information_schema.statistics 
WHERE table_schema = 'your_database'
  AND table_name = 'problem_table'
ORDER BY table_name, index_name, seq_in_index;
```

### 6.2 锁等待问题诊断


**锁等待问题排查**：

```sql
-- 当前锁等待详情
SELECT 
  waiting_trx_id,
  waiting_pid,
  waiting_query,
  blocking_trx_id,
  blocking_pid,
  sql_kill_blocking_query
FROM sys.innodb_lock_waits;
```

**🔸 锁等待解决流程图**

```
锁等待问题解决流程：
发现锁等待 → 定位阻塞事务 → 分析锁类型 → 制定解决方案
     ↓             ↓            ↓            ↓
  监控告警      找到罪魁祸首    理解冲突原因    执行解决操作

解决方案选择：
- 短期: KILL 阻塞连接
- 中期: 优化事务逻辑  
- 长期: 设计模式改进
```

### 6.3 IO性能问题诊断


**IO瓶颈快速诊断**：

```sql
-- IO热点文件分析
SELECT 
  file,
  total_read + total_written as total_io,
  ROUND((total_read + total_written) / 1024 / 1024, 2) as total_io_mb,
  read_latency,
  write_latency
FROM sys.io_global_by_file_by_bytes 
WHERE file NOT LIKE '%/tmp/%'  -- 排除临时文件
ORDER BY total_io DESC 
LIMIT 10;

-- IO等待最严重的语句
SELECT 
  digest_text,
  count_star,
  avg_timer_wait/1000000000 as avg_wait_seconds,
  sum_timer_wait/1000000000 as total_wait_seconds
FROM sys.io_global_by_wait_by_latency 
ORDER BY sum_timer_wait DESC 
LIMIT 5;
```

---

## 7. 💡 sys视图最佳实践


### 7.1 日常监控最佳实践


**🎯 监控频率建议**

| 监控类型 | **检查频率** | **关键视图** | **阈值设定** |
|---------|------------|-------------|-------------|
| 🔄 **实时监控** | `每分钟` | `processlist, innodb_lock_waits` | `连接数>80%, 锁等待>10s` |
| 📊 **性能监控** | `每5分钟` | `statements_with_runtimes_in_95th_percentile` | `95%查询>1s` |
| 💾 **资源监控** | `每15分钟` | `memory_global_total, io_global_by_file_by_bytes` | `内存>90%, IO延迟>100ms` |
| 📈 **趋势分析** | `每小时` | `user_summary, schema_table_statistics` | `环比增长>50%` |

### 7.2 告警规则设计


**智能告警查询模板**：

```sql
-- 慢查询告警
SELECT 
  'SLOW_QUERY_ALERT' as alert_type,
  COUNT(*) as slow_query_count,
  MAX(avg_latency) as max_avg_latency,
  NOW() as alert_time
FROM sys.statements_with_runtimes_in_95th_percentile 
HAVING slow_query_count > 50 OR max_avg_latency > '5.00 s';

-- 连接数告警  
SELECT 
  'CONNECTION_ALERT' as alert_type,
  SUM(current_connections) as total_connections,
  $$max_connections as max_allowed,
  ROUND(SUM(current_connections) * 100.0 / $$max_connections, 2) as usage_percent
FROM sys.user_summary 
HAVING usage_percent > 80;
```

### 7.3 性能基线建立


**建立性能基线的步骤**：

```sql
-- 1. 收集正常情况下的性能指标
CREATE TABLE performance_baseline AS
SELECT 
  DATE(NOW()) as baseline_date,
  COUNT(*) as normal_slow_query_count,
  AVG(avg_latency) as normal_avg_latency,
  MAX(current_connections) as normal_max_connections
FROM sys.statements_with_runtimes_in_95th_percentile;

-- 2. 与基线对比分析
SELECT 
  current_metrics.*,
  baseline.normal_slow_query_count,
  (current_metrics.current_slow_count - baseline.normal_slow_query_count) as deviation
FROM (
  SELECT COUNT(*) as current_slow_count 
  FROM sys.statements_with_runtimes_in_95th_percentile
) current_metrics
CROSS JOIN performance_baseline baseline;
```

---

## 8. 🔧 监控视图定制化开发


### 8.1 自定义监控视图


**创建业务特定的监控视图**：

```sql
-- 创建业务慢查询监控视图
CREATE VIEW business_slow_queries AS
SELECT 
  digest_text,
  count_star as execution_count,
  ROUND(avg_timer_wait/1000000000, 2) as avg_response_time_seconds,
  ROUND(sum_timer_wait/1000000000, 2) as total_time_seconds,
  CASE 
    WHEN avg_timer_wait/1000000000 > 10 THEN 'CRITICAL'
    WHEN avg_timer_wait/1000000000 > 5 THEN 'WARNING'  
    WHEN avg_timer_wait/1000000000 > 1 THEN 'ATTENTION'
    ELSE 'NORMAL'
  END as severity_level
FROM performance_schema.events_statements_summary_by_digest
WHERE digest_text LIKE '%your_business_table%'
  AND avg_timer_wait > 1000000000  -- 大于1秒
ORDER BY avg_timer_wait DESC;
```

### 8.2 监控数据聚合


**创建汇总统计视图**：

```sql
-- 每小时性能汇总视图
CREATE VIEW hourly_performance_summary AS
SELECT 
  DATE_FORMAT(FROM_UNIXTIME(first_seen), '%Y-%m-%d %H:00:00') as hour_time,
  COUNT(DISTINCT digest) as unique_query_count,
  SUM(count_star) as total_executions,
  ROUND(AVG(avg_timer_wait)/1000000000, 2) as avg_response_time,
  ROUND(MAX(max_timer_wait)/1000000000, 2) as max_response_time
FROM performance_schema.events_statements_summary_by_digest
WHERE first_seen >= UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 24 HOUR))
GROUP BY DATE_FORMAT(FROM_UNIXTIME(first_seen), '%Y-%m-%d %H:00:00')
ORDER BY hour_time DESC;
```

### 8.3 自动化监控脚本


**监控自动化的存储过程**：

```sql
DELIMITER $$
CREATE PROCEDURE AutoPerformanceCheck()
BEGIN
    DECLARE slow_count INT DEFAULT 0;
    DECLARE lock_count INT DEFAULT 0;
    DECLARE connection_usage DECIMAL(5,2) DEFAULT 0;
    
    -- 检查慢查询数量
    SELECT COUNT(*) INTO slow_count 
    FROM sys.statements_with_runtimes_in_95th_percentile;
    
    -- 检查锁等待情况
    SELECT COUNT(*) INTO lock_count 
    FROM sys.innodb_lock_waits;
    
    -- 检查连接使用率
    SELECT ROUND(SUM(current_connections) * 100.0 / $$max_connections, 2) 
    INTO connection_usage
    FROM sys.user_summary;
    
    -- 输出检查结果
    SELECT 
        slow_count as slow_queries,
        lock_count as lock_waits,
        connection_usage as connection_usage_percent,
        CASE 
            WHEN slow_count > 100 OR lock_count > 5 OR connection_usage > 80 
            THEN 'ALERT' 
            ELSE 'OK' 
        END as system_status;
        
END$$
DELIMITER ;

-- 使用方法
CALL AutoPerformanceCheck();
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 sys监控视图：MySQL性能监控的简化接口，开箱即用
🔸 核心视图分类：语句分析、IO分析、锁分析、连接分析四大类
🔸 性能诊断流程：发现问题→定位根因→制定方案→验证效果
🔸 监控最佳实践：建立基线→设置阈值→定期检查→持续优化
🔸 自定义扩展：根据业务需求创建专用监控视图
```

### 9.2 关键应用技巧


**🔹 日常监控重点**
```
每日必查视图：
- statements_with_runtimes_in_95th_percentile (慢查询)
- innodb_lock_waits (锁等待)  
- user_summary (连接状态)
- io_global_by_file_by_bytes (IO状况)
```

**🔹 问题排查思路**
```
性能问题排查顺序：
1. 查看整体负载 (user_summary)
2. 定位慢查询 (statements_with_runtimes_in_95th_percentile)
3. 分析锁等待 (innodb_lock_waits)
4. 检查IO瓶颈 (io_global_by_wait_by_latency)
5. 制定优化方案
```

**🔹 优化建议原则**
```
优化优先级：
🔥 紧急: 解决锁等待和连接耗尽
⚡ 重要: 优化Top 10慢查询
📊 改进: 减少全表扫描和临时表
🔧 预防: 建立监控基线和告警
```

### 9.3 实际应用价值


- **运维效率提升**：从复杂SQL到一键查询，大幅提升问题定位速度
- **性能优化指导**：通过数据驱动的方式识别真正的性能瓶颈
- **预防性维护**：建立监控基线，提前发现潜在问题
- **业务价值体现**：保障数据库稳定性，提升用户体验

**核心记忆**：
- sys视图让复杂的性能监控变得简单易用
- 掌握核心视图就掌握了MySQL性能监控的核心技能  
- 建立监控体系比解决单个问题更重要
- 数据驱动的优化决策比经验判断更可靠