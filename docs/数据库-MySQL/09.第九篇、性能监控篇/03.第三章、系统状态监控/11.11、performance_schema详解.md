---
title: 11、performance_schema详解
---
## 📚 目录

1. [Performance Schema架构原理](#1-Performance-Schema架构原理)
2. [事件收集机制详解](#2-事件收集机制详解)
3. [Instruments事件源配置](#3-Instruments事件源配置)
4. [Consumers数据消费者](#4-Consumers数据消费者)
5. [等待事件监控分析](#5-等待事件监控分析)
6. [语句性能统计应用](#6-语句性能统计应用)
7. [内存使用监控跟踪](#7-内存使用监控跟踪)
8. [PS性能库核心功能](#8-PS性能库核心功能)
9. [事件数据采集策略](#9-事件数据采集策略)
10. [PS监控最佳实践](#10-PS监控最佳实践)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🏗️ Performance Schema架构原理


### 1.1 什么是Performance Schema


**🔸 核心定义**：Performance Schema（简称PS）是MySQL自带的性能监控引擎，专门用来收集和分析数据库运行时的性能数据。

```
传统监控方式：         Performance Schema：
手动查看慢日志   →     自动收集所有事件
估算性能问题     →     精确测量性能指标
事后分析        →     实时监控分析
```

**💡 PS解决的核心问题**：
- **性能瓶颈定位**：准确找出哪里慢、为什么慢
- **资源使用分析**：内存、锁、IO等资源消耗情况  
- **实时性能监控**：不依赖日志文件的实时数据采集

### 1.2 PS架构组成


**🏗️ 三层架构设计**：

```
┌─────────────────────────────────────┐
│          应用层查询                  │ ← SQL查询PS表
├─────────────────────────────────────┤
│        Consumers (消费者)           │ ← 决定数据存储到哪里
├─────────────────────────────────────┤ 
│        Storage Engine               │ ← 存储引擎（内存表）
├─────────────────────────────────────┤
│        Instruments (事件源)         │ ← 决定收集哪些事件
├─────────────────────────────────────┤
│          MySQL Server               │ ← 产生各种事件
└─────────────────────────────────────┘
```

**🔸 核心组件说明**：
- **Instruments**：事件源，定义要监控的事件类型
- **Consumers**：消费者，决定收集的数据存储到哪个表
- **Storage**：存储层，使用内存表存储性能数据

### 1.3 PS与其他监控工具对比


| 监控方式 | **数据精度** | **实时性** | **系统开销** | **使用难度** |
|---------|------------|----------|------------|------------|
| 📊 **Performance Schema** | `极高` | `实时` | `低` | `中等` |
| 📝 **慢查询日志** | `中等` | `滞后` | `极低` | `简单` |
| 🔍 **SHOW STATUS** | `低` | `实时` | `极低` | `简单` |
| 📈 **第三方工具** | `高` | `准实时` | `中等` | `复杂` |

---

## 2. ⚙️ 事件收集机制详解


### 2.1 事件收集的基本概念


**事件（Event）**：MySQL运行过程中发生的任何可以被测量的操作，比如执行一条SQL、获取一个锁、读写文件等。

**🔸 事件的生命周期**：

```
事件开始 → 事件执行 → 事件结束 → 数据记录

具体示例：
SELECT查询开始 → 解析SQL → 执行查询 → 返回结果 → 记录耗时
```

### 2.2 事件收集机制原理


**🔄 收集流程**：

```
MySQL Server产生事件
         ↓
检查对应Instrument是否开启
         ↓
如果开启，创建事件记录
         ↓
检查对应Consumer是否开启
         ↓  
如果开启，存储到相应表中
         ↓
应用查询PS表获取数据
```

**💡 开关控制机制**：
```sql
-- 查看instruments开关状态
SELECT NAME, ENABLED 
FROM performance_schema.setup_instruments 
WHERE NAME LIKE 'statement%' LIMIT 5;

-- 查看consumers开关状态  
SELECT NAME, ENABLED 
FROM performance_schema.setup_consumers;
```

### 2.3 事件数据的层次结构


**📊 事件层次关系**：

```
Thread (线程)
   └── Statement (语句)
       └── Stage (阶段)
           └── Wait (等待)

示例：
连接线程
   └── SELECT * FROM users
       ├── query end (查询结束阶段)
       ├── Sorting result (排序阶段)  
       └── Waiting for table lock (等待表锁)
```

---

## 3. 🔧 Instruments事件源配置


### 3.1 Instruments的作用和分类


**Instruments**：相当于数据收集的"开关"，决定MySQL要监控哪些类型的事件。

**🔸 主要分类**：

| 事件类型 | **说明** | **典型应用** |
|---------|---------|------------|
| 📝 **statement** | `SQL语句执行` | `慢查询分析、SQL优化` |
| ⏳ **wait** | `各种等待事件` | `锁等待、IO等待分析` |
| 🔄 **stage** | `SQL执行阶段` | `查询执行过程分析` |
| 💾 **memory** | `内存分配使用` | `内存泄漏、使用优化` |
| 🔒 **lock** | `锁相关操作` | `死锁分析、锁竞争` |

### 3.2 常用Instruments配置


**📋 查看和配置示例**：

```sql
-- 查看语句相关的instruments
SELECT NAME, ENABLED, TIMED 
FROM performance_schema.setup_instruments 
WHERE NAME LIKE 'statement/%';

-- 开启SQL语句监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES' 
WHERE NAME = 'statement/sql/select';

-- 开启等待事件监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'wait/io/%';
```

### 3.3 Instruments配置策略


**🎯 配置原则**：

> 💡 **重要提示**：不要一次性开启所有instruments，会显著影响性能

**🔸 推荐配置组合**：
```sql
-- 基础监控（性能影响最小）
statement/sql/*        -- SQL语句监控
wait/io/file/*         -- 文件IO监控  
wait/io/table/*        -- 表IO监控

-- 进阶监控（适度影响）
stage/sql/*            -- SQL执行阶段
memory/*               -- 内存使用监控

-- 深度监控（较大影响，排查问题时使用）
wait/lock/*            -- 锁等待监控
wait/synch/*           -- 同步等待监控
```

---

## 4. 📥 Consumers数据消费者


### 4.1 Consumers的作用机制


**Consumers**：决定收集到的事件数据要存储到哪些表中，相当于数据的"流向控制器"。

**🔄 数据流向示意**：

```
事件产生 → Instrument过滤 → Consumer分发 → 存储表

示例：
SQL执行事件 → statement/sql/select开启 → events_statements_current开启 → 存储到当前语句表
```

### 4.2 Consumer层次结构


**📊 Consumer层次关系**：

```
global_instrumentation (全局开关)
├── thread_instrumentation (线程开关)
├── events_waits_current (当前等待事件)
│   └── events_waits_history (等待事件历史)
│       └── events_waits_history_long (等待事件长历史)
├── events_statements_current (当前语句事件)
│   └── events_statements_history (语句事件历史)
│       └── events_statements_history_long (语句事件长历史)
└── events_stages_current (当前阶段事件)
    └── events_stages_history (阶段事件历史)
        └── events_stages_history_long (阶段事件长历史)
```

### 4.3 Consumer配置实例


**🔧 实用配置示例**：

```sql
-- 查看consumer状态
SELECT NAME, ENABLED 
FROM performance_schema.setup_consumers;

-- 开启基础监控
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME IN (
    'global_instrumentation',
    'thread_instrumentation', 
    'events_statements_current'
);

-- 开启语句历史记录（用于分析最近执行的SQL）
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME = 'events_statements_history';
```

---

## 5. ⏱️ 等待事件监控分析


### 5.1 等待事件的概念


**等待事件**：MySQL在执行过程中，线程暂停执行并等待某种资源或条件满足的事件。

**🔸 常见等待类型**：

```
🔒 锁等待：等待获取表锁、行锁
💾 IO等待：等待磁盘读写完成  
🌐 网络等待：等待网络数据传输
🔄 同步等待：等待线程间同步
```

### 5.2 等待事件分析实战


**📊 等待事件查询示例**：

```sql
-- 查看当前正在等待的事件
SELECT THREAD_ID, EVENT_NAME, TIMER_WAIT/1000000 AS WAIT_TIME_MS
FROM performance_schema.events_waits_current 
WHERE STATE = 'ACTIVE';

-- 分析最耗时的等待事件类型
SELECT EVENT_NAME, 
       COUNT(*) AS COUNT,
       SUM(TIMER_WAIT)/1000000 AS TOTAL_WAIT_MS,
       AVG(TIMER_WAIT)/1000000 AS AVG_WAIT_MS
FROM performance_schema.events_waits_history_long 
GROUP BY EVENT_NAME 
ORDER BY TOTAL_WAIT_MS DESC LIMIT 10;
```

### 5.3 等待事件优化指导


**🎯 常见等待事件及优化方向**：

| 等待事件 | **可能原因** | **优化方向** |
|---------|------------|------------|
| 🔒 **wait/lock/table** | `表锁竞争` | `优化事务大小、避免长事务` |
| 💾 **wait/io/file** | `磁盘IO瓶颈` | `优化索引、增加内存` |
| 🌐 **wait/io/socket** | `网络延迟` | `优化网络配置、减少数据传输` |
| 🔄 **wait/synch/mutex** | `内部锁竞争` | `优化并发参数、分库分表` |

---

## 6. 📈 语句性能统计应用


### 6.1 语句性能监控概述


**语句性能监控**：跟踪和分析每条SQL语句的执行情况，包括执行时间、扫描行数、返回行数等关键指标。

### 6.2 核心性能统计表


**🔸 主要统计表说明**：

```
events_statements_current     ← 当前正在执行的语句
events_statements_history     ← 每个线程最近执行的语句
events_statements_summary_*   ← 按不同维度汇总的语句统计
```

### 6.3 实用查询分析


**📊 找出最慢的SQL语句**：

```sql
-- Top 10 最慢的SQL
SELECT DIGEST_TEXT,
       COUNT_STAR AS exec_count,
       AVG_TIMER_WAIT/1000000 AS avg_ms, 
       MAX_TIMER_WAIT/1000000 AS max_ms,
       SUM_ROWS_EXAMINED AS total_rows_examined
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC LIMIT 10;

-- 找出全表扫描的SQL
SELECT DIGEST_TEXT,
       COUNT_STAR,
       SUM_NO_INDEX_USED,
       SUM_NO_GOOD_INDEX_USED
FROM performance_schema.events_statements_summary_by_digest 
WHERE SUM_NO_INDEX_USED > 0 OR SUM_NO_GOOD_INDEX_USED > 0
ORDER BY COUNT_STAR DESC;
```

### 6.4 SQL性能优化指导


**🎯 关键性能指标分析**：

| 指标名称 | **含义** | **优化建议** |
|---------|---------|------------|
| 📊 **AVG_TIMER_WAIT** | `平均执行时间` | `超过100ms需要重点关注` |
| 🔍 **SUM_ROWS_EXAMINED** | `扫描行数` | `与返回行数比例过大需优化索引` |
| 📝 **SUM_NO_INDEX_USED** | `未使用索引次数` | `需要添加合适索引` |
| 🔄 **COUNT_STAR** | `执行次数` | `高频执行的慢SQL优先优化` |

---

## 7. 💾 内存使用监控跟踪


### 7.1 内存监控的重要性


**内存监控目标**：了解MySQL各组件的内存使用情况，及时发现内存泄漏或使用异常。

**🔸 监控维度**：

```
🏠 全局内存：MySQL整体内存使用
👤 用户内存：每个连接的内存使用  
🎯 事件内存：每个操作的内存分配
📊 主机内存：操作系统级别内存状态
```

### 7.2 内存监控核心表


**📋 主要内存统计表**：

```sql
-- 查看全局内存使用情况
SELECT EVENT_NAME, 
       CURRENT_NUMBER_OF_BYTES_USED/1024/1024 AS current_mb,
       HIGH_NUMBER_OF_BYTES_USED/1024/1024 AS high_mb
FROM performance_schema.memory_summary_global_by_event_name 
ORDER BY CURRENT_NUMBER_OF_BYTES_USED DESC LIMIT 10;

-- 查看每个线程的内存使用
SELECT THREAD_ID,
       SUM(CURRENT_NUMBER_OF_BYTES_USED)/1024/1024 AS memory_mb
FROM performance_schema.memory_summary_by_thread_by_event_name 
GROUP BY THREAD_ID 
ORDER BY memory_mb DESC LIMIT 10;
```

### 7.3 内存使用优化建议


**🎯 内存优化策略**：

> ⚠️ **注意**：内存监控会带来一定性能开销，生产环境建议按需开启

**🔸 常见内存问题及解决**：
- **连接内存过高**：检查`sort_buffer_size`、`read_buffer_size`等参数
- **临时表内存多**：优化SQL避免大量临时表创建
- **缓存内存异常**：检查`query_cache`、`table_cache`配置

---

## 8. 🎯 PS性能库核心功能


### 8.1 性能问题诊断


**🔍 典型诊断场景**：

```sql
-- 1. 找出当前阻塞的会话
SELECT r.trx_id waiting_trx_id,
       r.trx_mysql_thread_id waiting_thread,
       r.trx_query waiting_query,
       b.trx_id blocking_trx_id,
       b.trx_mysql_thread_id blocking_thread,
       b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;

-- 2. 分析表访问热度
SELECT OBJECT_SCHEMA, OBJECT_NAME,
       COUNT_READ, COUNT_WRITE,
       SUM_TIMER_READ/1000000 AS read_ms,
       SUM_TIMER_WRITE/1000000 AS write_ms
FROM performance_schema.table_io_waits_summary_by_table 
ORDER BY (COUNT_READ + COUNT_WRITE) DESC LIMIT 10;
```

### 8.2 实时性能监控


**📊 监控仪表板查询**：

```sql
-- MySQL整体性能概览
SELECT 
  (SELECT COUNT(*) FROM performance_schema.threads WHERE TYPE='FOREGROUND') AS active_connections,
  (SELECT COUNT(*) FROM performance_schema.events_statements_current) AS running_queries,
  (SELECT SUM(CURRENT_NUMBER_OF_BYTES_USED)/1024/1024 FROM performance_schema.memory_summary_global_by_event_name) AS memory_mb;
```

---

## 9. 📋 事件数据采集策略


### 9.1 采集策略设计原则


**🎯 平衡原则**：在性能开销和监控精度之间找到最佳平衡点。

**🔸 分级监控策略**：

```
📊 级别1 - 基础监控（常开）：
  - 语句执行统计
  - 基础等待事件
  - 性能开销：< 5%

📈 级别2 - 详细监控（按需）：
  - 详细等待分析  
  - 内存使用跟踪
  - 性能开销：5-15%

🔍 级别3 - 深度监控（排障）：
  - 所有事件监控
  - 详细历史记录
  - 性能开销：15-30%
```

### 9.2 动态配置管理


**🔧 配置管理最佳实践**：

```sql
-- 创建监控配置管理存储过程
DELIMITER $$
CREATE PROCEDURE EnableBasicMonitoring()
BEGIN
    -- 开启基础语句监控
    UPDATE performance_schema.setup_instruments 
    SET ENABLED = 'YES' WHERE NAME LIKE 'statement/sql/%';
    
    -- 开启基础consumer
    UPDATE performance_schema.setup_consumers 
    SET ENABLED = 'YES' WHERE NAME IN (
        'global_instrumentation',
        'thread_instrumentation',
        'events_statements_current'
    );
END$$
DELIMITER ;
```

---

## 10. 🏆 PS监控最佳实践


### 10.1 生产环境建议


**🎯 生产环境最佳配置**：

> 💡 **核心原则**：监控要有用，但不能影响业务性能

**🔸 推荐配置**：
```sql
-- 生产环境标准配置
SET GLOBAL performance_schema = ON;

-- 开启核心监控
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' WHERE NAME IN (
    'global_instrumentation',
    'thread_instrumentation', 
    'events_statements_current',
    'events_statements_summary_by_digest'
);

-- 只开启关键instruments
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' WHERE NAME IN (
    'statement/sql/select',
    'statement/sql/insert', 
    'statement/sql/update',
    'statement/sql/delete'
);
```

### 10.2 监控告警设置


**📊 关键监控指标**：

| 监控项 | **告警阈值** | **处理建议** |
|--------|------------|------------|
| 🐌 **慢查询比例** | `> 10%` | `优化SQL和索引` |
| 🔒 **锁等待时间** | `> 5秒` | `检查事务和锁竞争` |
| 💾 **内存使用率** | `> 80%` | `调整内存参数配置` |
| 📈 **连接数** | `> 最大连接数80%` | `检查连接池配置` |

### 10.3 定期维护任务


**🔄 维护任务清单**：

```sql
-- 1. 定期清理历史数据（每天执行）
CALL mysql.rds_truncate_slow_log();

-- 2. 重置统计数据（每周执行）
CALL sys.ps_truncate_all_tables(FALSE);

-- 3. 检查配置状态（每月执行）
SELECT * FROM sys.ps_check_lost_instrumentation;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 PS三层架构：Instruments → Consumer → Storage
🔸 事件收集机制：MySQL事件 → 过滤 → 存储 → 查询分析
🔸 配置控制：通过开关控制监控范围和性能开销
🔸 实时监控：不依赖日志文件的实时性能数据采集
🔸 性能平衡：在监控精度和系统开销间找平衡
```

### 11.2 关键理解要点


**🔹 Performance Schema的价值**：
```
传统方式的问题：
- 只能事后分析日志
- 缺乏实时性能数据
- 难以精确定位瓶颈

PS的优势：
- 实时收集性能数据
- 精确测量各种事件
- 多维度性能分析
```

**🔹 配置策略要点**：
```
不要贪多：
- 不是开启越多越好
- 每个开关都有性能代价
- 按需开启，动态调整

分层监控：
- 基础监控常开
- 详细监控按需
- 深度监控排障时使用
```

### 11.3 实际应用价值


**🎯 典型应用场景**：
- **性能调优**：找出最慢的SQL和资源瓶颈
- **故障排查**：分析锁等待、连接问题
- **容量规划**：了解资源使用趋势
- **实时监控**：构建性能监控仪表板

**🔧 运维实践要点**：
- **渐进式开启**：先开基础监控，再根据需要扩展
- **定期维护**：清理历史数据，重置统计信息  
- **告警设置**：设置关键指标阈值和自动告警
- **文档记录**：记录配置变更和优化效果

**核心记忆**：
- Performance Schema是MySQL自带的实时性能监控利器
- 三层架构控制数据收集和存储流向
- 配置要按需开启，平衡监控效果和性能开销
- 重点关注SQL性能、等待事件、资源使用三大维度