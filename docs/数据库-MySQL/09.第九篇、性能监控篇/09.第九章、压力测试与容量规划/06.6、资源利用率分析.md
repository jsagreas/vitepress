---
title: 6、资源利用率分析
---
## 📚 目录

1. [资源利用率分析概述](#1-资源利用率分析概述)
2. [CPU利用率分析](#2-CPU利用率分析)
3. [内存使用率监控](#3-内存使用率监控)
4. [磁盘空间利用率](#4-磁盘空间利用率)
5. [网络带宽使用](#5-网络带宽使用)
6. [数据库连接利用率](#6-数据库连接利用率)
7. [利用率优化策略](#7-利用率优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 资源利用率分析概述


**🎯 什么是资源利用率分析**

资源利用率分析就是检查MySQL服务器的各种硬件资源使用情况，看看哪些资源快用完了，哪些还有富余。就像体检一样，要看看服务器的"身体状况"。

**🔸 为什么需要监控资源利用率**
- **预防故障**：在资源耗尽前发现问题
- **性能优化**：找出性能瓶颈所在
- **容量规划**：为扩容提供数据支撑
- **成本控制**：避免资源浪费

**📋 主要监控指标**

| 资源类型 | **监控重点** | **正常范围** | **告警阈值** |
|---------|------------|-------------|-------------|
| 🔸 **CPU** | `处理器使用率` | `< 70%` | `> 80%` |
| 🔸 **内存** | `内存占用率` | `< 80%` | `> 90%` |
| 🔸 **磁盘** | `空间使用率` | `< 80%` | `> 90%` |
| 🔸 **网络** | `带宽使用率` | `< 70%` | `> 80%` |
| 🔸 **连接** | `连接数使用率` | `< 80%` | `> 90%` |

**🚀 监控的基本思路**

```
实时监控 → 数据收集 → 趋势分析 → 预警告警 → 优化调整
    ↓          ↓         ↓         ↓         ↓
  当前状态   历史数据   未来预测   主动通知   解决问题
```

---

## 2. 🔧 CPU利用率分析


**💡 CPU利用率是什么意思**

CPU利用率就是处理器的繁忙程度，类似于一个工人的工作饱和度。如果CPU利用率太高，说明MySQL处理请求时"累坏了"，响应就会变慢。

### 2.1 CPU利用率监控方法


**🔸 系统级监控**

```bash
# 查看CPU整体使用情况
top -p $(pgrep mysqld)

# 查看CPU各核心使用情况  
htop

# 持续监控CPU使用率
vmstat 1 10
```

**🔸 MySQL专用监控**

```sql
-- 查看MySQL进程状态
SHOW PROCESSLIST;

-- 查看当前CPU密集型查询
SELECT * FROM performance_schema.threads 
WHERE NAME = 'thread/sql/one_connection' 
ORDER BY THREAD_OS_ID;
```

### 2.2 CPU利用率分析要点


**🔸 正常CPU使用模式**

```
理想状态：
- 平均CPU使用率: 40-60%
- 峰值CPU使用率: 不超过80%
- CPU等待时间: 低于20%

异常征象：
- 持续高CPU使用率 (>90%)
- CPU等待时间过高 (>50%)
- 单核CPU被完全占用
```

**🔸 CPU高使用率的常见原因**

| 原因类型 | **具体表现** | **解决方向** |
|---------|------------|-------------|
| 🔸 **慢查询** | `复杂SQL消耗大量CPU` | `优化SQL语句` |
| 🔸 **缺少索引** | `全表扫描占用CPU` | `添加合适索引` |
| 🔸 **并发过高** | `大量请求同时处理` | `控制并发数` |
| 🔸 **排序操作** | `ORDER BY消耗CPU` | `优化排序逻辑` |

### 2.3 CPU性能优化策略


**⚡ 查询优化**

```sql
-- 找出CPU密集型查询
SELECT sql_text, exec_count, avg_timer_wait/1000000 as avg_ms
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY sum_timer_wait DESC LIMIT 10;

-- 优化示例：避免复杂计算
-- ❌ 低效写法
SELECT * FROM orders WHERE YEAR(order_date) = 2024;

-- ✅ 高效写法  
SELECT * FROM orders WHERE order_date >= '2024-01-01' 
AND order_date < '2025-01-01';
```

**🔧 配置优化**

```ini
# MySQL配置优化
[mysqld]
# 减少CPU上下文切换
thread_cache_size = 16
# 控制并发查询数
max_connections = 200
# 优化查询缓存
query_cache_type = 1
query_cache_size = 128M
```

---

## 3. 💾 内存使用率监控


**🎯 内存使用率监控的重要性**

内存就像MySQL的工作台，工作台越大，能同时处理的事情越多。如果内存不够用，MySQL就要频繁去磁盘读取数据，速度会大大下降。

### 3.1 内存使用情况查看


**🔸 系统内存监控**

```bash
# 查看系统内存使用情况
free -h

# 查看MySQL进程内存使用
ps aux | grep mysqld

# 实时监控内存变化
watch -n 1 'free -h'
```

**🔸 MySQL内部内存监控**

```sql
-- 查看MySQL内存使用统计
SELECT 
  event_name,
  current_alloc/1024/1024 as current_mb,
  high_alloc/1024/1024 as high_mb
FROM performance_schema.memory_summary_global_by_event_name
WHERE current_alloc > 0
ORDER BY current_alloc DESC LIMIT 10;

-- 查看缓冲池使用情况
SHOW ENGINE INNODB STATUS\G
```

### 3.2 关键内存组件分析


**📊 MySQL内存结构图**

```
MySQL内存分布：
┌─────────────────────────────────┐
│          MySQL总内存             │
├─────────────────────────────────┤
│    InnoDB缓冲池 (最大块)         │ ← 缓存数据页和索引
├─────────────────────────────────┤
│    查询缓存                     │ ← 缓存SELECT结果
├─────────────────────────────────┤
│    连接线程内存                  │ ← 每个连接分配
├─────────────────────────────────┤
│    排序缓冲区                   │ ← ORDER BY使用
├─────────────────────────────────┤
│    临时表空间                   │ ← 复杂查询使用
└─────────────────────────────────┘
```

**🔸 内存使用率计算**

```sql
-- 计算缓冲池命中率
SELECT 
  ROUND(
    (1 - (Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests)) * 100, 2
  ) AS buffer_pool_hit_rate
FROM 
  (SELECT variable_value AS Innodb_buffer_pool_reads 
   FROM performance_schema.global_status 
   WHERE variable_name = 'Innodb_buffer_pool_reads') AS reads,
  (SELECT variable_value AS Innodb_buffer_pool_read_requests 
   FROM performance_schema.global_status 
   WHERE variable_name = 'Innodb_buffer_pool_read_requests') AS requests;
```

### 3.3 内存优化配置


**⚡ 缓冲池优化**

```ini
# InnoDB缓冲池配置
[mysqld]
# 设置为系统内存的70-80%
innodb_buffer_pool_size = 8G
# 多实例提升并发
innodb_buffer_pool_instances = 8
# 预热缓冲池
innodb_buffer_pool_dump_at_shutdown = 1
innodb_buffer_pool_load_at_startup = 1
```

**🔧 连接内存控制**

```ini
# 单连接内存限制
max_connections = 200
# 排序缓冲区大小
sort_buffer_size = 2M
# 读缓冲区大小  
read_buffer_size = 128K
# 连接缓冲区大小
join_buffer_size = 2M
```

---

## 4. 💿 磁盘空间利用率


**💡 为什么要监控磁盘空间**

磁盘空间就像仓库，如果仓库满了，MySQL就没地方存储新数据了。而且磁盘快满时，性能也会下降，因为系统需要更多时间来寻找可用空间。

### 4.1 磁盘空间监控


**🔸 系统磁盘监控**

```bash
# 查看磁盘使用情况
df -h

# 查看MySQL数据目录大小
du -sh /var/lib/mysql/

# 查看各个数据库大小
du -sh /var/lib/mysql/*/
```

**🔸 MySQL磁盘使用查询**

```sql
-- 查看数据库大小
SELECT 
  table_schema AS database_name,
  ROUND(SUM(data_length + index_length) / 1024 / 1024 / 1024, 2) AS size_gb
FROM information_schema.tables 
GROUP BY table_schema
ORDER BY size_gb DESC;

-- 查看表大小排行
SELECT 
  table_name,
  ROUND(((data_length + index_length) / 1024 / 1024), 2) AS size_mb
FROM information_schema.tables 
WHERE table_schema = 'your_database'
ORDER BY size_mb DESC LIMIT 10;
```

### 4.2 磁盘I/O性能监控


**📊 I/O性能指标**

```bash
# 监控磁盘I/O性能
iostat -x 1 10

# 查看MySQL I/O状态
SHOW ENGINE INNODB STATUS\G
```

**🔸 关键I/O指标解读**

| 指标名称 | **含义说明** | **正常范围** | **优化目标** |
|---------|------------|-------------|-------------|
| 🔸 **IOPS** | `每秒IO操作次数` | `< 80%最大值` | `减少随机IO` |
| 🔸 **延迟** | `IO响应时间` | `< 10ms` | `使用SSD硬盘` |
| 🔸 **吞吐量** | `每秒传输数据量` | `< 80%最大值` | `优化批量操作` |
| 🔸 **队列深度** | `等待IO的请求数` | `< 32` | `调整并发参数` |

### 4.3 磁盘空间优化策略


**🧹 数据清理策略**

```sql
-- 清理过期日志
-- 1. 清理binlog日志
PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 7 DAY);

-- 2. 清理慢查询日志（需要重启）
-- SET GLOBAL slow_query_log = 'OFF';

-- 3. 分析表碎片
SELECT 
  table_name,
  ROUND(((data_length + index_length) / 1024 / 1024), 2) AS size_mb,
  ROUND((data_free / 1024 / 1024), 2) AS free_mb
FROM information_schema.tables 
WHERE data_free > 0 AND table_schema = 'your_database';
```

**⚡ 存储优化配置**

```ini
# 磁盘优化配置
[mysqld]
# 数据文件独立存储
innodb_file_per_table = 1
# 日志文件大小
innodb_log_file_size = 1G
# 日志缓冲区
innodb_log_buffer_size = 16M
# 刷新策略（性能vs安全平衡）
innodb_flush_log_at_trx_commit = 2
```

---

## 5. 🌐 网络带宽使用


**🔗 网络带宽监控的意义**

网络就像MySQL与外界沟通的管道，如果管道太窄或者堵塞，数据传输就会变慢，用户体验就会下降。

### 5.1 网络使用情况监控


**🔸 系统网络监控**

```bash
# 查看网络接口使用情况
iftop -i eth0

# 监控网络连接状态
netstat -an | grep 3306

# 查看MySQL网络连接
ss -tulpn | grep 3306
```

**🔸 MySQL网络统计**

```sql
-- 查看网络流量统计
SHOW STATUS LIKE 'Bytes_%';

-- 查看连接相关统计
SHOW STATUS LIKE '%connect%';

-- 查看网络错误统计
SHOW STATUS LIKE '%error%';
```

### 5.2 网络性能分析


**📊 网络性能计算**

```sql
-- 计算平均数据传输量
SELECT 
  variable_name,
  variable_value,
  ROUND(variable_value / 1024 / 1024, 2) AS value_mb
FROM performance_schema.global_status 
WHERE variable_name IN ('Bytes_sent', 'Bytes_received');
```

**🔸 网络瓶颈识别**

```
网络瓶颈检查清单：
┌─────────────────────────────────┐
│ 1. 带宽使用率是否超过80%         │
│ 2. 网络延迟是否过高             │  
│ 3. 丢包率是否异常               │
│ 4. 连接数是否过多               │
│ 5. 大查询是否占用过多带宽        │
└─────────────────────────────────┘
```

### 5.3 网络优化措施


**⚡ 查询优化减少网络传输**

```sql
-- ❌ 避免查询过多字段
SELECT * FROM large_table WHERE id = 1;

-- ✅ 只查询需要的字段
SELECT id, name, email FROM large_table WHERE id = 1;

-- ✅ 使用LIMIT限制结果集
SELECT * FROM logs ORDER BY created_at DESC LIMIT 100;
```

**🔧 网络配置优化**

```ini
# 网络相关配置
[mysqld]
# 网络缓冲区大小
net_buffer_length = 32K
# 最大数据包大小
max_allowed_packet = 256M
# 网络读写超时
net_read_timeout = 30
net_write_timeout = 60
```

---

## 6. 🔗 数据库连接利用率


**💡 数据库连接是什么**

数据库连接就像餐厅的座位，每个连接就是一个座位。如果座位不够，新客户就要排队等待；如果座位太多，就会浪费资源。合理控制连接数很重要。

### 6.1 连接使用情况监控


**🔸 连接统计查询**

```sql
-- 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 查看最大连接数配置
SHOW VARIABLES LIKE 'max_connections';

-- 查看连接使用率
SELECT 
  (SELECT variable_value FROM performance_schema.global_status WHERE variable_name = 'Threads_connected') AS current_connections,
  (SELECT variable_value FROM performance_schema.global_variables WHERE variable_name = 'max_connections') AS max_connections,
  ROUND((SELECT variable_value FROM performance_schema.global_status WHERE variable_name = 'Threads_connected') / (SELECT variable_value FROM performance_schema.global_variables WHERE variable_name = 'max_connections') * 100, 2) AS connection_usage_percent;
```

**🔸 连接状态分析**

```sql
-- 查看所有连接详情
SELECT 
  id, user, host, db, command, time, state, info
FROM information_schema.processlist
ORDER BY time DESC;

-- 统计不同状态的连接数
SELECT state, COUNT(*) as count
FROM information_schema.processlist 
GROUP BY state
ORDER BY count DESC;
```

### 6.2 连接池性能分析


**📊 连接效率指标**

| 指标名称 | **计算方式** | **正常范围** | **异常表现** |
|---------|------------|-------------|-------------|
| 🔸 **连接使用率** | `当前连接数/最大连接数` | `< 80%` | `> 90%频繁拒绝` |
| 🔸 **连接平均持续时间** | `总连接时间/连接数` | `< 30秒` | `> 300秒长连接过多` |
| 🔸 **连接拒绝率** | `拒绝连接数/总请求数` | `< 1%` | `> 5%容量不足` |
| 🔸 **空闲连接比例** | `Sleep状态连接/总连接` | `< 30%` | `> 50%资源浪费` |

### 6.3 连接优化策略


**⚡ 连接池配置优化**

```ini
# 连接相关配置
[mysqld]
# 最大连接数
max_connections = 500
# 连接超时时间
wait_timeout = 300
# 交互式连接超时
interactive_timeout = 300
# 连接线程缓存
thread_cache_size = 32
```

**🔧 应用层连接管理**

```java
// 应用层连接池配置示例
@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setMaximumPoolSize(20);      // 最大连接数
        config.setMinimumIdle(5);           // 最小空闲连接
        config.setConnectionTimeout(30000); // 连接超时30秒
        config.setIdleTimeout(300000);      // 空闲超时5分钟
        return new HikariDataSource(config);
    }
}
```

---

## 7. ⚡ 利用率优化策略


**🎯 综合优化思路**

优化不是单打独斗，而是要统筹考虑各种资源的平衡使用，就像调节交响乐团，各个声部要协调配合。

### 7.1 监控告警体系


**🔸 告警阈值设置**

```sql
-- 创建监控视图
CREATE VIEW system_health AS
SELECT 
  'CPU' as resource_type,
  CASE WHEN cpu_usage > 80 THEN 'CRITICAL'
       WHEN cpu_usage > 70 THEN 'WARNING' 
       ELSE 'OK' END as status,
  CONCAT(cpu_usage, '%') as current_value
FROM 
  (SELECT 75 as cpu_usage) as cpu_data  -- 示例数据

UNION ALL

SELECT 
  'Memory' as resource_type,
  CASE WHEN memory_usage > 90 THEN 'CRITICAL'
       WHEN memory_usage > 80 THEN 'WARNING'
       ELSE 'OK' END as status,
  CONCAT(memory_usage, '%') as current_value
FROM 
  (SELECT 85 as memory_usage) as memory_data;
```

**📊 监控dashboard配置**

```
监控面板布局：
┌─────────────────┬─────────────────┐
│   CPU使用率     │   内存使用率     │
│     75%        │     85%        │
├─────────────────┼─────────────────┤
│   磁盘使用率    │   网络带宽      │
│     65%        │     45%        │
├─────────────────┼─────────────────┤
│   连接数       │   慢查询数      │
│   150/500      │      15        │
└─────────────────┴─────────────────┘
```

### 7.2 性能调优优先级


**🔸 优化优先级排序**

```
性能优化的先后顺序：

1️⃣ SQL查询优化 (影响最大)
   ├── 添加合适索引
   ├── 重写慢查询  
   └── 优化表结构

2️⃣ 配置参数调优 (成本最低)
   ├── 内存分配优化
   ├── 缓存策略调整
   └── 并发参数调节

3️⃣ 硬件资源升级 (成本最高)
   ├── 增加内存容量
   ├── 升级CPU性能
   └── 使用SSD硬盘
```

### 7.3 容量规划建议


**📈 容量增长预测**

```sql
-- 数据增长趋势分析
SELECT 
  DATE(created_at) as date,
  COUNT(*) as daily_records,
  AVG(COUNT(*)) OVER (ORDER BY DATE(created_at) ROWS 7 PRECEDING) as weekly_avg
FROM your_main_table 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DATE(created_at)
ORDER BY date;
```

**🔧 扩容决策矩阵**

| 资源类型 | **当前使用率** | **增长趋势** | **扩容建议** | **扩容时机** |
|---------|--------------|-------------|-------------|-------------|
| 🔸 **CPU** | `> 80%` | `持续上升` | `增加CPU核数` | `立即执行` |
| 🔸 **内存** | `> 85%` | `缓慢增长` | `增加内存容量` | `1个月内` |
| 🔸 **磁盘** | `> 85%` | `快速增长` | `扩展存储空间` | `立即执行` |
| 🔸 **网络** | `> 75%` | `稳定` | `升级网络带宽` | `3个月内` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的监控指标


**🔸 关键性能指标(KPI)**
```
CPU利用率：处理器繁忙程度，正常< 70%
内存使用率：内存占用情况，正常< 80%  
磁盘使用率：存储空间占用，正常< 80%
网络带宽：数据传输能力，正常< 70%
连接使用率：数据库连接占用，正常< 80%
```

### 8.2 优化策略优先级


**🔹 快速见效的优化措施**
1. **SQL查询优化**：添加索引，重写慢查询
2. **配置参数调整**：内存分配，缓存设置
3. **连接池优化**：合理设置连接数和超时时间

**🔹 长期规划的优化方向**
1. **硬件升级**：CPU、内存、磁盘性能提升
2. **架构优化**：读写分离、分库分表
3. **缓存体系**：Redis缓存、应用层缓存

### 8.3 监控最佳实践


**✅ 监控要点**
- 建立完整的监控指标体系
- 设置合理的告警阈值
- 定期分析历史趋势数据
- 制定应急响应预案

**⚠️ 常见误区**
- 只关注CPU忽略其他资源
- 告警阈值设置过高或过低
- 缺乏历史数据对比分析
- 优化措施缺乏优先级

### 8.4 实战应用建议


**🎯 日常运维checklist**
- [ ] 每日检查资源使用率趋势
- [ ] 每周分析性能瓶颈原因  
- [ ] 每月评估容量规划需求
- [ ] 每季度优化配置参数

**🚀 性能优化roadmap**
```
短期目标(1个月)：
- 解决明显的性能瓶颈
- 优化慢查询语句
- 调整关键配置参数

中期目标(3个月)：
- 建立完善监控体系
- 实施预防性优化措施
- 制定容量扩展计划

长期目标(1年)：
- 实现自动化运维
- 建立性能基准线
- 持续优化架构设计
```

**核心记忆要点**：
- 资源监控如体检，预防胜于治疗
- 优化有先后，SQL优化效果最明显
- 告警要及时，趋势要分析
- 容量要规划，扩容要提前