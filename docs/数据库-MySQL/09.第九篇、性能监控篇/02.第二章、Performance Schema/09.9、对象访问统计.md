---
title: 9、对象访问统计
---
## 📚 目录

1. [对象访问统计概述](#1-对象访问统计概述)
2. [表访问统计分析](#2-表访问统计分析)
3. [索引使用统计](#3-索引使用统计)
4. [文件IO统计](#4-文件IO统计)
5. [表锁统计分析](#5-表锁统计分析)
6. [对象等待统计](#6-对象等待统计)
7. [访问模式分析](#7-访问模式分析)
8. [热点对象识别](#8-热点对象识别)
9. [对象性能优化](#9-对象性能优化)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 对象访问统计概述


### 1.1 什么是对象访问统计

**简单理解**：就像统计商店里哪些商品最受欢迎一样，Performance Schema帮我们统计数据库中哪些表、索引被访问得最频繁。

```
现实类比：
商店统计 → 哪个商品卖得好，哪个货架人流量大
数据库统计 → 哪张表查询多，哪个索引使用频繁

目的都是：找出热点，优化资源配置
```

**核心作用**：
- **找热点**：识别访问频繁的数据库对象
- **查瓶颈**：发现性能问题的根源
- **做优化**：为性能调优提供数据支撑

### 1.2 统计对象的分类


```
数据库对象访问统计分类：

📊 表级别统计
├── 表访问次数（SELECT/INSERT/UPDATE/DELETE）
├── 表锁等待时间
└── 表扫描类型（全表扫描 vs 索引扫描）

📊 索引级别统计  
├── 索引使用频率
├── 索引扫描行数
└── 索引查找效率

📊 文件级别统计
├── 数据文件读写次数
├── 日志文件写入量
└── 临时文件使用情况

📊 锁级别统计
├── 锁等待时间
├── 锁争用次数
└── 死锁发生频率
```

---

## 2. 📋 表访问统计分析


### 2.1 基础表访问统计

**核心表**：`table_io_waits_summary_by_table` - 记录每张表的访问情况

```sql
-- 查看访问最频繁的表
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ,          -- 读操作次数
    COUNT_WRITE,         -- 写操作次数  
    COUNT_READ + COUNT_WRITE AS total_ops,
    SUM_TIMER_READ/1000000000 AS read_time_sec,
    SUM_TIMER_WRITE/1000000000 AS write_time_sec
FROM performance_schema.table_io_waits_summary_by_table 
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY total_ops DESC 
LIMIT 10;
```

### 2.2 表操作类型分析


```sql
-- 分析表的具体操作类型
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_FETCH,         -- SELECT操作
    COUNT_INSERT,        -- INSERT操作
    COUNT_UPDATE,        -- UPDATE操作
    COUNT_DELETE,        -- DELETE操作
    CASE 
        WHEN COUNT_FETCH > (COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE) * 10 
        THEN '读密集型'
        WHEN COUNT_INSERT > COUNT_FETCH 
        THEN '写密集型'
        ELSE '读写混合型'
    END AS table_type
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY (COUNT_FETCH + COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE) DESC;
```

> 💡 **理解要点**  
> 通过操作类型分析，可以了解表的使用模式，为后续优化策略提供依据

### 2.3 表访问热度分析


```
表访问热度评估模型：

🔥 热点表（需重点关注）
├── 访问频率 > 平均值的10倍
├── 读写时间占总时间的30%以上
└── 并发访问冲突频繁

🌡️ 温点表（适度关注）
├── 访问频率在平均值2-10倍之间
├── 读写时间占总时间的10-30%
└── 偶有并发冲突

❄️ 冷点表（低优先级）
├── 访问频率低于平均值
├── 读写时间占比很小
└── 几乎无并发冲突
```

---

## 3. 🔍 索引使用统计


### 3.1 索引使用频率统计

**核心表**：`table_io_waits_summary_by_index_usage` - 统计索引的使用情况

```sql
-- 查看索引使用效率
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_READ,
    COUNT_WRITE,
    SUM_TIMER_READ/1000000000 AS read_time_sec,
    ROUND(COUNT_READ/NULLIF(SUM_TIMER_READ/1000000000, 0), 2) AS reads_per_sec
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
  AND INDEX_NAME IS NOT NULL
ORDER BY COUNT_READ DESC
LIMIT 15;
```

### 3.2 未使用索引识别


```sql
-- 找出从未被使用的索引（可能的冗余索引）
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    '从未使用' AS status
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
  AND COUNT_READ = 0 
  AND COUNT_WRITE = 0
  AND INDEX_NAME != 'PRIMARY'
ORDER BY OBJECT_SCHEMA, OBJECT_NAME;
```

### 3.3 索引效率分析


```
索引效率评估标准：

⚡ 高效索引
├── 使用频率高（COUNT_READ > 1000/小时）
├── 平均响应时间短（< 1ms）
└── 选择性好（能过滤大量数据）

⚠️ 低效索引  
├── 使用频率低但响应时间长
├── 扫描行数多但返回行数少
└── 可能需要重新设计

🗑️ 冗余索引
├── 从未被使用（COUNT_READ = 0）
├── 与其他索引功能重叠
└── 只增加写入成本，无查询收益
```

---

## 4. 💾 文件IO统计


### 4.1 文件IO概述

**作用说明**：数据库所有操作最终都会转化为文件读写，监控文件IO可以发现存储层面的性能瓶颈。

```
文件IO统计维度：

📁 数据文件（.ibd/.MYD）
├── 读取次数和字节数
├── 写入次数和字节数  
└── 平均IO耗时

📁 日志文件（redo log/binlog）
├── 写入频率
├── 刷盘策略效果
└── 日志轮转影响

📁 临时文件
├── 排序操作产生的临时文件
├── 连接查询的中间结果
└── GROUP BY的临时表
```

### 4.2 文件IO统计查询


```sql
-- 查看文件IO统计
SELECT 
    FILE_NAME,
    EVENT_NAME,
    COUNT_READ,
    COUNT_WRITE,
    SUM_NUMBER_OF_BYTES_READ/1024/1024 AS read_mb,
    SUM_NUMBER_OF_BYTES_WRITE/1024/1024 AS write_mb,
    SUM_TIMER_READ/1000000000 AS read_time_sec,
    SUM_TIMER_WRITE/1000000000 AS write_time_sec
FROM performance_schema.file_summary_by_instance 
WHERE FILE_NAME LIKE '%.ibd'
ORDER BY (SUM_NUMBER_OF_BYTES_READ + SUM_NUMBER_OF_BYTES_WRITE) DESC
LIMIT 10;
```

### 4.3 IO性能瓶颈识别


```sql
-- 识别IO密集的文件
SELECT 
    SUBSTRING_INDEX(FILE_NAME, '/', -1) AS filename,
    COUNT_READ + COUNT_WRITE AS total_ops,
    (SUM_TIMER_READ + SUM_TIMER_WRITE)/1000000000 AS total_time_sec,
    ROUND((SUM_TIMER_READ + SUM_TIMER_WRITE)/(COUNT_READ + COUNT_WRITE)/1000000, 2) AS avg_time_ms,
    CASE 
        WHEN avg_time_ms > 10 THEN 'IO瓶颈'
        WHEN avg_time_ms > 5 THEN 'IO压力较大' 
        ELSE 'IO正常'
    END AS io_status
FROM performance_schema.file_summary_by_instance 
WHERE FILE_NAME LIKE '%.ibd'
  AND COUNT_READ + COUNT_WRITE > 0
ORDER BY avg_time_ms DESC;
```

---

## 5. 🔒 表锁统计分析


### 5.1 表锁统计概念

**简单理解**：就像停车场的车位，当多个查询同时访问一张表时，需要获取锁来协调访问顺序。

```
表锁类型：

🔓 读锁（共享锁）
├── 多个SELECT可以同时进行
├── 阻止写操作
└── 兼容性较好

🔒 写锁（排他锁）  
├── 只允许一个写操作
├── 阻止所有其他读写操作
└── 独占性访问

⏱️ 元数据锁（MDL）
├── 保护表结构不被修改
├── DDL操作会获取排他MDL锁
└── 长时间持有会阻塞所有操作
```

### 5.2 表锁等待统计


```sql
-- 查看表锁等待情况
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ_WITH_SHARED_LOCKS,      -- 共享锁读次数
    COUNT_READ_HIGH_PRIORITY,          -- 高优先级读次数
    COUNT_READ_NO_INSERT,              -- 禁止插入的读次数
    COUNT_WRITE_ALLOW_WRITE,           -- 允许写的写次数
    COUNT_WRITE_CONCURRENT_INSERT,     -- 并发插入次数
    COUNT_WRITE_LOW_PRIORITY           -- 低优先级写次数
FROM performance_schema.table_lock_waits_summary_by_table
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY (COUNT_READ_WITH_SHARED_LOCKS + COUNT_WRITE_ALLOW_WRITE) DESC
LIMIT 10;
```

### 5.3 锁冲突分析


```sql
-- 分析锁等待时间
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ + COUNT_WRITE AS total_locks,
    SUM_TIMER_READ_WITH_SHARED_LOCKS/1000000000 AS shared_lock_time_sec,
    SUM_TIMER_WRITE_ALLOW_WRITE/1000000000 AS write_lock_time_sec,
    ROUND((SUM_TIMER_READ_WITH_SHARED_LOCKS + SUM_TIMER_WRITE_ALLOW_WRITE) / 
          (COUNT_READ + COUNT_WRITE) / 1000000, 2) AS avg_lock_time_ms
FROM performance_schema.table_lock_waits_summary_by_table
WHERE COUNT_READ + COUNT_WRITE > 0
ORDER BY avg_lock_time_ms DESC
LIMIT 10;
```

---

## 6. ⏳ 对象等待统计


### 6.1 等待事件概述

**作用说明**：记录各种等待事件，帮助识别系统瓶颈点。

```
常见等待事件分类：

🔄 IO等待
├── wait/io/file/* - 文件读写等待
├── wait/io/table/* - 表IO等待
└── wait/io/socket/* - 网络通信等待

🔐 锁等待
├── wait/lock/table/* - 表锁等待
├── wait/lock/metadata/* - 元数据锁等待
└── wait/synch/mutex/* - 内部互斥锁等待

⚙️ 内部等待
├── wait/synch/cond/* - 条件变量等待
├── wait/synch/rwlock/* - 读写锁等待
└── stage/* - SQL执行阶段等待
```

### 6.2 等待事件统计查询


```sql
-- 查看最耗时的等待事件
SELECT 
    EVENT_NAME,
    COUNT_STAR,
    SUM_TIMER_WAIT/1000000000 AS total_wait_sec,
    AVG_TIMER_WAIT/1000000 AS avg_wait_ms,
    MAX_TIMER_WAIT/1000000 AS max_wait_ms
FROM performance_schema.events_waits_summary_global_by_event_name
WHERE SUM_TIMER_WAIT > 0
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 15;
```

### 6.3 对象级别等待分析


```sql
-- 按对象分析等待情况
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    OBJECT_TYPE,
    COUNT_STAR AS wait_count,
    SUM_TIMER_WAIT/1000000000 AS total_wait_sec,
    AVG_TIMER_WAIT/1000000 AS avg_wait_ms
FROM performance_schema.objects_summary_global_by_type
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
  AND SUM_TIMER_WAIT > 0
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

---

## 7. 📊 访问模式分析


### 7.1 访问模式分类


```
数据库访问模式类型：

📈 OLTP模式（在线事务处理）
特征：
├── 频繁的小事务
├── 主要是点查询和简单更新
├── 高并发、低延迟要求
└── 索引使用率高

📊 OLAP模式（在线分析处理）  
特征：
├── 复杂的聚合查询
├── 大量数据扫描
├── 较少的并发用户
└── 临时表使用较多

🔄 混合模式
特征：
├── 同时存在OLTP和OLAP负载
├── 读写比例相对均衡
├── 需要综合优化策略
└── 可能需要读写分离
```

### 7.2 访问模式识别查询


```sql
-- 识别表的访问模式
WITH table_stats AS (
    SELECT 
        OBJECT_SCHEMA,
        OBJECT_NAME,
        COUNT_FETCH,
        COUNT_INSERT,
        COUNT_UPDATE, 
        COUNT_DELETE,
        COUNT_FETCH + COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE AS total_ops
    FROM performance_schema.table_io_waits_summary_by_table
    WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
)
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    total_ops,
    ROUND(COUNT_FETCH / total_ops * 100, 1) AS read_pct,
    ROUND((COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE) / total_ops * 100, 1) AS write_pct,
    CASE 
        WHEN COUNT_FETCH / total_ops > 0.9 THEN 'OLAP分析型'
        WHEN COUNT_FETCH / total_ops > 0.7 THEN '读密集型'
        WHEN COUNT_FETCH / total_ops < 0.3 THEN '写密集型'
        ELSE 'OLTP事务型'
    END AS access_pattern
FROM table_stats
WHERE total_ops > 100
ORDER BY total_ops DESC;
```

---

## 8. 🔥 热点对象识别


### 8.1 热点识别策略

**识别原理**：通过多维度指标综合评估，找出系统中的性能热点。

```
热点对象识别维度：

📊 访问频率维度
├── 总操作次数排名
├── 读操作频率排名  
└── 写操作频率排名

⏱️ 响应时间维度
├── 平均响应时间排名
├── 总等待时间排名
└── 最大响应时间排名

🔄 资源消耗维度
├── IO消耗排名
├── CPU消耗排名
└── 内存使用排名
```

### 8.2 综合热点分析


```sql
-- 综合热点对象分析
WITH object_metrics AS (
    SELECT 
        t.OBJECT_SCHEMA,
        t.OBJECT_NAME,
        t.COUNT_READ + t.COUNT_WRITE AS total_access,
        (t.SUM_TIMER_READ + t.SUM_TIMER_WRITE)/1000000000 AS total_time_sec,
        f.SUM_NUMBER_OF_BYTES_READ + f.SUM_NUMBER_OF_BYTES_WRITE AS total_bytes,
        RANK() OVER (ORDER BY t.COUNT_READ + t.COUNT_WRITE DESC) as access_rank,
        RANK() OVER (ORDER BY t.SUM_TIMER_READ + t.SUM_TIMER_WRITE DESC) as time_rank,
        RANK() OVER (ORDER BY f.SUM_NUMBER_OF_BYTES_READ + f.SUM_NUMBER_OF_BYTES_WRITE DESC) as io_rank
    FROM performance_schema.table_io_waits_summary_by_table t
    LEFT JOIN performance_schema.file_summary_by_instance f 
        ON f.FILE_NAME LIKE CONCAT('%/', t.OBJECT_SCHEMA, '/', t.OBJECT_NAME, '.ibd')
    WHERE t.OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
)
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    total_access,
    ROUND(total_time_sec, 2) AS total_time_sec,
    ROUND(total_bytes/1024/1024, 2) AS total_mb,
    (access_rank + time_rank + io_rank) / 3 AS hotspot_score,
    CASE 
        WHEN (access_rank + time_rank + io_rank) / 3 <= 5 THEN '🔥 极热点'
        WHEN (access_rank + time_rank + io_rank) / 3 <= 15 THEN '🌡️ 热点'
        ELSE '❄️ 普通'
    END AS hotspot_level
FROM object_metrics
ORDER BY hotspot_score ASC
LIMIT 20;
```

### 8.3 热点对象监控


```sql
-- 实时热点监控（需要定期执行）
CREATE OR REPLACE VIEW v_hotspot_monitor AS
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ + COUNT_WRITE AS current_ops,
    (SUM_TIMER_READ + SUM_TIMER_WRITE)/1000000000 AS current_time_sec,
    ROUND((SUM_TIMER_READ + SUM_TIMER_WRITE)/(COUNT_READ + COUNT_WRITE)/1000000, 2) AS avg_time_ms,
    NOW() AS monitor_time
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
  AND COUNT_READ + COUNT_WRITE > 0
ORDER BY current_ops DESC;
```

---

## 9. ⚡ 对象性能优化


### 9.1 优化策略框架


```
性能优化决策树：

🔍 问题识别
├── 访问频率是否过高？
├── 响应时间是否过长？
├── 资源消耗是否过大？
└── 并发冲突是否频繁？

📊 原因分析
├── 缺少合适的索引？
├── 查询语句不够优化？
├── 表结构设计不合理？
└── 硬件资源成为瓶颈？

⚡ 优化方案
├── 索引优化（添加/删除/重建）
├── 查询优化（改写SQL/分解复杂查询）
├── 架构优化（分库分表/读写分离）
└── 硬件优化（升级存储/增加内存）
```

### 9.2 具体优化建议


**索引优化建议**：
```sql
-- 识别需要添加索引的表
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    '建议添加索引' AS optimization,
    '全表扫描过多' AS reason
FROM performance_schema.table_io_waits_summary_by_table t
WHERE NOT EXISTS (
    SELECT 1 FROM performance_schema.table_io_waits_summary_by_index_usage i
    WHERE i.OBJECT_SCHEMA = t.OBJECT_SCHEMA 
      AND i.OBJECT_NAME = t.OBJECT_NAME
      AND i.COUNT_READ > t.COUNT_READ * 0.5
)
AND t.COUNT_READ > 1000;
```

**表结构优化建议**：
```sql
-- 识别可能需要分区的大表
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ + COUNT_WRITE AS total_ops,
    '考虑分区' AS optimization,
    '访问量大且集中' AS reason
FROM performance_schema.table_io_waits_summary_by_table
WHERE (COUNT_READ + COUNT_WRITE) > 10000
  AND OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY total_ops DESC;
```

### 9.3 优化效果监控


```sql
-- 优化前后对比监控
SELECT 
    'optimization_compare' AS monitor_type,
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ + COUNT_WRITE AS current_ops,
    (SUM_TIMER_READ + SUM_TIMER_WRITE)/1000000000 AS current_time,
    LAG(COUNT_READ + COUNT_WRITE) OVER (PARTITION BY OBJECT_SCHEMA, OBJECT_NAME ORDER BY NOW()) AS previous_ops,
    LAG((SUM_TIMER_READ + SUM_TIMER_WRITE)/1000000000) OVER (PARTITION BY OBJECT_SCHEMA, OBJECT_NAME ORDER BY NOW()) AS previous_time
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA = 'your_database';
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 对象访问统计：通过Performance Schema监控数据库对象的使用情况
🔸 表访问分析：识别读写密集型表，了解访问模式
🔸 索引使用监控：发现未使用的索引和索引使用效率
🔸 文件IO统计：监控存储层面的性能瓶颈
🔸 锁等待分析：识别并发访问冲突和锁争用问题
🔸 热点对象识别：通过多维度指标找出性能热点
🔸 性能优化：基于统计数据制定针对性优化策略
```

### 10.2 关键理解要点


**🔹 统计数据的实际意义**
```
访问频率高 → 需要重点优化，影响面大
响应时间长 → 存在性能瓶颈，用户体验差  
资源消耗大 → 成本高，可能影响其他操作
并发冲突多 → 系统吞吐量受限，扩展性差
```

**🔹 优化的优先级原则**
```
1. 先解决影响面最大的问题（高频访问对象）
2. 再解决用户体验最差的问题（高延迟操作）
3. 最后解决资源消耗问题（降低成本）
4. 持续监控优化效果，避免过度优化
```

**🔹 监控的持续性要求**
```
性能监控不是一次性工作：
- 定期收集统计数据
- 建立监控告警机制  
- 跟踪优化效果
- 根据业务变化调整策略
```

### 10.3 实际应用价值


**📊 业务场景应用**
- **电商系统**：监控商品表、订单表的访问热度
- **社交平台**：分析用户表、消息表的读写模式
- **金融系统**：跟踪交易表、账户表的并发情况
- **内容平台**：优化文章表、评论表的查询性能

**🔧 运维实践**
- **容量规划**：基于访问统计预测资源需求
- **架构设计**：根据访问模式设计分库分表策略
- **故障排查**：通过统计数据快速定位性能问题
- **成本优化**：识别资源浪费，优化硬件配置

> 💡 **核心记忆**  
> Performance Schema的对象访问统计就像给数据库装了一个"黑匣子"，记录每个对象的使用情况。通过分析这些数据，我们可以找到性能瓶颈，制定优化策略，让数据库运行得更快更稳定。关键是要持续监控，根据实际情况调整优化方向。