---
title: 4、监控优化建议
---
## 📚 目录

1. [Performance Schema性能影响评估](#1-performance-schema性能影响评估)
2. [监控粒度选择策略](#2-监控粒度选择策略)
3. [数据保留策略管理](#3-数据保留策略管理)
4. [查询优化建议](#4-查询优化建议)
5. [资源使用优化](#5-资源使用优化)
6. [监控策略调整](#6-监控策略调整)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📊 Performance Schema性能影响评估


### 1.1 Performance Schema基本概念


**🔸 什么是Performance Schema**
```
Performance Schema(PS)：MySQL内置的性能监控存储引擎
作用：实时收集MySQL服务器运行时的性能数据
位置：information_schema库的补充，专注性能监控
特点：基于内存，数据不持久化，重启后清空
```

**💡 为什么需要性能监控**
```
传统问题：
• 慢查询日志：只记录超过阈值的查询
• 通用查询日志：记录所有查询，开销巨大
• 系统监控：只能看到外部表现，无法深入内部

PS解决方案：
• 细粒度监控：从连接到SQL执行的全链路
• 实时数据：当前正在发生的性能事件
• 低开销：相比传统日志方式更高效
• 结构化：通过表结构提供查询接口
```

### 1.2 性能影响程度分析


**⚡ 开销等级评估**
```
🟢 低开销（推荐启用）：
• 连接监控：connections, users
• 基础统计：statement_summary
• 等待事件：waits_summary_global

🟡 中等开销（按需启用）：
• 详细语句：statement_history
• 锁等待：table_lock_waits
• 文件IO：file_summary

🔴 高开销（谨慎使用）：
• 所有语句历史：events_statements_history_long
• 所有等待事件：events_waits_history_long
• 内存使用详情：memory_summary_by_thread_by_event_name
```

**📈 性能影响测试方法**
```sql
-- 查看PS开销占比
SELECT 
    event_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec,
    avg_timer_wait/1000000 as avg_time_ms
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE event_name LIKE 'wait/synch/mutex/sql/LOCK_plugin%'
ORDER BY sum_timer_wait DESC;

-- 监控PS自身的内存使用
SELECT 
    event_name,
    current_alloc,
    high_alloc
FROM performance_schema.memory_summary_global_by_event_name 
WHERE event_name LIKE 'memory/performance_schema%'
ORDER BY current_alloc DESC;
```

### 1.3 影响因素识别


**🔍 主要影响因素**
```
并发连接数：连接越多，监控开销越大
查询频率：高QPS环境下监控压力更大
监控项目：启用的consumer和instrument越多开销越大
数据保留：history表的行数设置影响内存使用
硬件配置：CPU和内存资源充足程度
```

**⚖️ 开销与收益平衡**
```
高收益场景：
✅ 生产环境性能调优期间
✅ 排查性能问题时
✅ 容量规划和基线建立
✅ 新应用上线前的性能测试

低收益场景：
❌ 稳定运行的生产环境
❌ 资源紧张的小型系统
❌ 对性能极度敏感的应用
❌ 监控数据很少查看的情况
```

---

## 2. 🎯 监控粒度选择策略


### 2.1 监控粒度分类


**📊 粒度层次结构**
```
全局级别 (Global)
    ↓
主机级别 (Host) 
    ↓
用户级别 (User)
    ↓ 
线程级别 (Thread)
    ↓
语句级别 (Statement)
    ↓
事件级别 (Event)
```

**🔸 各级别特点对比**

| 粒度级别 | **数据量** | **性能开销** | **分析价值** | **适用场景** |
|----------|------------|-------------|-------------|-------------|
| 🌍 **全局** | 最少 | 最低 | 宏观趋势 | 整体监控 |
| 🏠 **主机** | 少 | 低 | 客户端分析 | 多租户环境 |
| 👤 **用户** | 中 | 中 | 用户行为 | 权限审计 |
| 🧵 **线程** | 多 | 高 | 连接分析 | 并发诊断 |
| 📝 **语句** | 很多 | 很高 | SQL优化 | 慢查询分析 |
| ⚡ **事件** | 最多 | 最高 | 深度调试 | 问题排查 |

### 2.2 粒度选择原则


**🎯 场景化选择策略**
```
🔧 日常监控（推荐配置）：
• 全局统计：了解整体性能趋势
• 用户级别：监控不同用户的资源使用
• 语句摘要：识别热点SQL和性能问题

配置示例：
UPDATE performance_schema.setup_consumers 
SET enabled='YES' 
WHERE name IN (
    'global_instrumentation',
    'statements_digest'
);
```

**🚨 问题排查（临时启用）**
```
深度诊断配置：
• 线程级别：分析具体连接的行为
• 详细事件：追踪锁等待和IO问题
• 历史记录：保留问题发生时的上下文

临时启用命令：
UPDATE performance_schema.setup_consumers 
SET enabled='YES' 
WHERE name LIKE '%history%';
```

### 2.3 动态调整策略


**⚙️ 自适应监控方案**
```sql
-- 基础监控配置（生产环境默认）
DELIMITER //
CREATE PROCEDURE SetBasicMonitoring()
BEGIN
    -- 关闭高开销监控
    UPDATE performance_schema.setup_consumers 
    SET enabled='NO' 
    WHERE name IN (
        'events_statements_history_long',
        'events_waits_history_long'
    );
    
    -- 启用核心监控
    UPDATE performance_schema.setup_consumers 
    SET enabled='YES' 
    WHERE name IN (
        'statements_digest',
        'events_statements_summary_by_digest'
    );
END //
DELIMITER ;

-- 问题排查配置（临时使用）
DELIMITER //
CREATE PROCEDURE SetDebugMonitoring()
BEGIN
    -- 启用详细监控
    UPDATE performance_schema.setup_consumers 
    SET enabled='YES' 
    WHERE name LIKE '%history%';
    
    -- 记录开始时间
    SET @debug_start = NOW();
END //
DELIMITER ;
```

**📅 时间窗口策略**
```
工作时间：高粒度监控，及时发现问题
非工作时间：低粒度监控，减少资源消耗
维护窗口：全面监控，收集完整性能数据
应急响应：最高粒度，快速定位问题
```

---

## 3. 💾 数据保留策略管理


### 3.1 数据保留机制理解


**🔄 PS数据特点**
```
内存存储：所有PS数据都存储在内存中
非持久化：MySQL重启后数据全部丢失
大小限制：每个表都有最大行数限制
循环覆盖：达到上限后，新数据覆盖旧数据
动态配置：可以在运行时调整表大小
```

**📊 主要表类型与保留策略**
```
汇总表 (Summary Tables)：
• 持续累积统计数据
• 不受行数限制影响
• 手动TRUNCATE清理

历史表 (History Tables)：
• events_statements_history: 每线程保留最近N条
• events_waits_history: 每线程保留最近N条
• events_*_history_long: 全局保留最近N条

当前表 (Current Tables)：
• events_statements_current: 当前正在执行的语句
• events_waits_current: 当前正在等待的事件
```

### 3.2 关键参数配置


**⚙️ 核心保留参数**
```sql
-- 查看当前配置
SELECT * FROM performance_schema.setup_instruments 
WHERE name LIKE '%history%';

-- 重要参数说明
SHOW VARIABLES LIKE 'performance_schema%';
```

**🔧 参数调优建议**

| 参数名称 | **默认值** | **推荐值** | **说明** |
|----------|------------|------------|----------|
| `performance_schema_events_statements_history_size` | 10 | 20-50 | 每线程语句历史条数 |
| `performance_schema_events_statements_history_long_size` | 10000 | 1000-5000 | 全局语句历史条数 |
| `performance_schema_events_waits_history_size` | 10 | 20 | 每线程等待事件条数 |
| `performance_schema_max_thread_instances` | -1 | 1000 | 最大监控线程数 |

**💡 配置调整实例**
```ini
# my.cnf 配置示例
[mysqld]
# 基础配置（生产环境）
performance_schema_events_statements_history_size = 20
performance_schema_events_statements_history_long_size = 2000
performance_schema_events_waits_history_size = 10

# 调试配置（问题排查时）
# performance_schema_events_statements_history_size = 100
# performance_schema_events_statements_history_long_size = 10000
```

### 3.3 存储空间管理


**📈 内存使用估算**
```sql
-- 查看PS内存使用情况
SELECT 
    SUBSTRING_INDEX(event_name, '/', -1) AS table_name,
    current_alloc / 1024 / 1024 AS current_mb,
    high_alloc / 1024 / 1024 AS high_mb
FROM performance_schema.memory_summary_global_by_event_name 
WHERE event_name LIKE 'memory/performance_schema%'
    AND current_alloc > 0
ORDER BY current_alloc DESC;

-- 估算配置变更对内存的影响
SELECT 
    $$performance_schema_events_statements_history_size * 
    $$max_connections * 500 / 1024 / 1024 AS estimated_mb;
```

**🗂️ 数据清理策略**
```sql
-- 手动清理统计数据
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
TRUNCATE TABLE performance_schema.events_waits_summary_global_by_event_name;

-- 重置特定用户的统计
DELETE FROM performance_schema.events_statements_summary_by_user_by_event_name 
WHERE user = 'specific_user';

-- 创建定期清理任务
DELIMITER //
CREATE EVENT ps_cleanup
ON SCHEDULE EVERY 1 WEEK
DO
BEGIN
    TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
END //
DELIMITER ;
```

---

## 4. 🔍 查询优化建议


### 4.1 高效查询模式


**⚡ PS查询最佳实践**
```
索引利用：PS表大多没有索引，避免全表扫描
条件过滤：尽早过滤，减少数据处理量
聚合优化：合理使用GROUP BY和ORDER BY
结果限制：使用LIMIT控制返回行数
时间窗口：基于时间戳进行范围查询
```

**🎯 推荐查询模板**
```sql
-- 模板1：TOP N 查询
SELECT 
    digest_text,
    count_star,
    avg_timer_wait/1000000 as avg_ms,
    sum_timer_wait/1000000000 as total_sec
FROM performance_schema.events_statements_summary_by_digest 
WHERE count_star > 10  -- 先过滤低频查询
ORDER BY sum_timer_wait DESC 
LIMIT 10;  -- 控制结果集大小

-- 模板2：时间范围查询
SELECT 
    sql_text,
    timer_wait/1000000 as duration_ms
FROM performance_schema.events_statements_history_long 
WHERE timer_start >= (
    SELECT variable_value - 3600000000000  -- 1小时前
    FROM performance_schema.global_status 
    WHERE variable_name = 'Uptime_since_flush_status'
)
AND timer_wait > 1000000000  -- 只看慢查询
ORDER BY timer_wait DESC;
```

### 4.2 常用查询优化


**🚀 性能分析查询集合**
```sql
-- 1. 最耗时的SQL语句
SELECT 
    SUBSTRING(digest_text, 1, 100) as sql_preview,
    count_star as exec_count,
    ROUND(avg_timer_wait/1000000000, 3) as avg_sec,
    ROUND(sum_timer_wait/1000000000, 3) as total_sec
FROM performance_schema.events_statements_summary_by_digest 
WHERE digest_text NOT LIKE '%performance_schema%'
ORDER BY sum_timer_wait DESC 
LIMIT 5;

-- 2. 锁等待分析
SELECT 
    object_schema,
    object_name,
    lock_type,
    COUNT(*) as wait_count,
    ROUND(SUM(timer_wait)/1000000000, 3) as total_wait_sec
FROM performance_schema.events_waits_history_long 
WHERE event_name LIKE 'wait/lock%'
GROUP BY object_schema, object_name, lock_type
ORDER BY total_wait_sec DESC;

-- 3. IO热点分析
SELECT 
    file_name,
    event_name,
    count_star as io_count,
    ROUND(sum_timer_wait/1000000000, 3) as total_io_sec
FROM performance_schema.file_summary_by_instance 
WHERE count_star > 0
ORDER BY sum_timer_wait DESC 
LIMIT 10;
```

### 4.3 查询性能优化技巧


**💡 优化技术要点**
```
🔸 避免SELECT *：只选择需要的列
🔸 使用EXISTS：代替IN子查询
🔸 合理JOIN：避免大表的笛卡尔积
🔸 预聚合：在应用层进行数据缓存
🔸 分批处理：大量数据分多次查询
```

**🛠️ 查询优化实例**
```sql
-- 优化前：全表扫描
SELECT * FROM performance_schema.events_statements_history_long 
WHERE sql_text LIKE '%SELECT%';

-- 优化后：条件前置
SELECT 
    sql_text,
    timer_wait/1000000 as duration_ms
FROM performance_schema.events_statements_history_long 
WHERE timer_wait > 5000000000  -- 先过滤慢查询
    AND sql_text LIKE '%SELECT%'
ORDER BY timer_wait DESC 
LIMIT 20;

-- 创建汇总视图减少重复计算
CREATE VIEW slow_query_summary AS
SELECT 
    digest,
    digest_text,
    count_star,
    ROUND(avg_timer_wait/1000000, 2) as avg_ms,
    ROUND(sum_timer_wait/1000000000, 2) as total_sec
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait > 1000000000;  -- 只看平均1秒以上的
```

---

## 5. ⚙️ 资源使用优化


### 5.1 CPU使用优化


**🔧 CPU开销控制策略**
```
监控粒度控制：减少不必要的instrument
采样频率调整：降低高频事件的监控频率  
查询优化：避免复杂的PS查询在业务高峰期执行
批量操作：合并多个小查询为一个大查询
缓存结果：将常用查询结果缓存到业务表
```

**⚡ CPU优化配置**
```sql
-- 关闭高开销的instrument
UPDATE performance_schema.setup_instruments 
SET enabled='NO' 
WHERE name LIKE 'wait/synch/mutex%'
    OR name LIKE 'wait/synch/rwlock%';

-- 只监控关键事件
UPDATE performance_schema.setup_instruments 
SET enabled='YES' 
WHERE name IN (
    'statement/sql/select',
    'statement/sql/update', 
    'statement/sql/insert',
    'statement/sql/delete'
);

-- 查看当前启用的instrument数量
SELECT 
    SUBSTRING_INDEX(name, '/', 2) as category,
    COUNT(*) as total_count,
    SUM(enabled='YES') as enabled_count
FROM performance_schema.setup_instruments 
GROUP BY category
ORDER BY enabled_count DESC;
```

### 5.2 内存使用优化


**💾 内存优化策略**
```
🔸 表大小调整：根据实际需求设置history表大小
🔸 consumer控制：只启用必要的数据收集器
🔸 定期清理：清理累积的汇总数据
🔸 连接限制：控制最大连接数减少监控开销
🔸 监控周期：非关键时段降低监控强度
```

**📊 内存使用监控**
```sql
-- 监控PS内存使用趋势
SELECT 
    event_name,
    current_alloc / 1024 / 1024 AS current_mb,
    high_alloc / 1024 / 1024 AS peak_mb,
    ROUND(current_alloc / high_alloc * 100, 2) AS usage_percent
FROM performance_schema.memory_summary_global_by_event_name 
WHERE event_name LIKE 'memory/performance_schema%'
    AND high_alloc > 0
ORDER BY current_alloc DESC;

-- 内存告警查询
SELECT 
    'PS Memory Alert' as alert_type,
    CONCAT(ROUND(SUM(current_alloc)/1024/1024/1024, 2), 'GB') as current_usage
FROM performance_schema.memory_summary_global_by_event_name 
WHERE event_name LIKE 'memory/performance_schema%'
HAVING SUM(current_alloc) > 1024*1024*1024;  -- 超过1GB告警
```

### 5.3 IO影响优化


**💿 IO优化要点**
```
🔸 减少磁盘写入：PS数据在内存中，但统计查询可能影响IO
🔸 查询时机：避免在高IO负载时执行复杂PS查询
🔸 结果导出：大量数据导出选择低峰期
🔸 日志关联：将PS数据与慢查询日志结合分析
```

**🔍 IO监控查询**
```sql
-- 分析PS查询对系统IO的影响
SELECT 
    event_name,
    count_star as io_operations,
    ROUND(sum_timer_wait/1000000000, 3) as total_io_sec,
    ROUND(avg_timer_wait/1000000, 3) as avg_io_ms
FROM performance_schema.file_summary_by_event_name 
WHERE event_name LIKE 'wait/io%'
    AND count_star > 0
ORDER BY sum_timer_wait DESC;
```

---

## 6. 📈 监控策略调整


### 6.1 环境适应性调整


**🏢 生产环境策略**
```
保守配置：优先保证业务性能，适度监控
关键指标：只监控最核心的性能指标
报警阈值：设置合理的性能下降阈值
应急预案：性能问题时快速启用详细监控
定期评估：每月评估监控效果和开销
```

**🧪 测试环境策略**
```
全面监控：启用大部分监控功能收集基线数据
压力测试：在负载测试期间收集详细性能数据
对比分析：不同配置下的性能表现对比
调优验证：代码优化后的性能改进验证
```

### 6.2 动态调整机制


**⚙️ 自动化调整方案**
```sql
-- 创建监控强度调整存储过程
DELIMITER //
CREATE PROCEDURE AdjustMonitoringLevel(IN level_name VARCHAR(20))
BEGIN
    CASE level_name
        WHEN 'minimal' THEN
            -- 最小监控：只保留基础统计
            UPDATE performance_schema.setup_consumers 
            SET enabled='NO' WHERE name LIKE '%history%';
            UPDATE performance_schema.setup_consumers 
            SET enabled='YES' WHERE name = 'statements_digest';
            
        WHEN 'normal' THEN  
            -- 正常监控：适合日常使用
            UPDATE performance_schema.setup_consumers 
            SET enabled='YES' WHERE name IN (
                'statements_digest',
                'events_statements_history'
            );
            UPDATE performance_schema.setup_consumers 
            SET enabled='NO' WHERE name LIKE '%history_long%';
            
        WHEN 'debug' THEN
            -- 调试监控：问题排查时使用
            UPDATE performance_schema.setup_consumers 
            SET enabled='YES' WHERE name LIKE '%history%';
            
    END CASE;
    
    -- 记录调整日志
    INSERT INTO monitoring_log (timestamp, level_name, description) 
    VALUES (NOW(), level_name, CONCAT('Monitoring level changed to: ', level_name));
END //
DELIMITER ;

-- 使用示例
CALL AdjustMonitoringLevel('normal');
```

### 6.3 监控效果评估


**📊 效果评估指标**
```sql
-- 1. 监控开销评估
SELECT 
    'PS Overhead' as metric,
    ROUND(
        (SELECT SUM(current_alloc) FROM performance_schema.memory_summary_global_by_event_name 
         WHERE event_name LIKE 'memory/performance_schema%') / 
        (SELECT variable_value FROM performance_schema.global_status 
         WHERE variable_name = 'innodb_buffer_pool_bytes_data') * 100, 2
    ) as overhead_percent;

-- 2. 发现问题效率
SELECT 
    COUNT(*) as slow_queries_detected,
    COUNT(DISTINCT digest) as unique_slow_patterns
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait > 5000000000;  -- 5秒以上的查询

-- 3. 监控覆盖度
SELECT 
    (SELECT COUNT(*) FROM performance_schema.setup_consumers WHERE enabled='YES') /
    (SELECT COUNT(*) FROM performance_schema.setup_consumers) * 100 as coverage_percent;
```

**🎯 调整决策矩阵**

| 性能开销 | **发现问题数** | **建议调整** |
|----------|---------------|-------------|
| 🟢 <2% | 多个关键问题 | 维持当前配置 |
| 🟡 2-5% | 少量问题 | 适度降低粒度 |
| 🔴 >5% | 很少问题 | 大幅减少监控项 |
| 🔴 >5% | 多个问题 | 优化查询方式 |

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 PS性能影响：监控本身会消耗系统资源，需要平衡监控价值与性能开销
🔸 粒度选择：根据实际需求选择合适的监控粒度，避免过度监控
🔸 数据保留：合理配置历史数据保留量，防止内存过度占用
🔸 查询优化：PS查询需要优化，避免对生产系统造成额外负担
🔸 动态调整：监控策略需要根据环境和需求动态调整
```

### 7.2 关键实践要点


**🔹 配置原则**
```
生产环境：保守配置，重点监控核心指标
测试环境：全面监控，收集完整性能数据
问题排查：临时启用详细监控，事后恢复
容量规划：定期收集基线数据用于容量规划
```

**🔹 优化技巧**
```
开销控制：关闭不必要的instrument和consumer
内存管理：合理设置history表大小，定期清理汇总数据
查询优化：使用条件过滤，避免全表扫描，限制结果集大小
时机选择：在业务低峰期执行复杂的PS分析查询
```

**🔹 监控策略**
```
分层监控：全局 → 用户 → 线程 → 语句的层次化监控
周期调整：根据业务周期调整监控强度
告警设置：设置合理的性能告警阈值
效果评估：定期评估监控效果和资源消耗
```

### 7.3 实际应用价值


**💼 业务价值体现**
- **性能优化**：快速识别性能瓶颈，指导SQL优化
- **容量规划**：基于历史数据进行资源容量规划
- **故障排查**：问题发生时快速定位根本原因
- **运维决策**：数据驱动的数据库运维决策

**🔧 运维实践**
- **监控自动化**：建立自动化的监控策略调整机制
- **报告生成**：定期生成性能分析报告
- **基线建立**：建立系统性能基线用于对比分析
- **知识积累**：将监控发现的问题和解决方案文档化

**🧠 核心记忆**：
- Performance Schema是把双刃剑，用好了是利器，用不好会拖累性能
- 监控粒度要适中，全局统计 + 关键详情是最佳实践
- 数据保留要合理，内存有限制，历史无限长
- 查询要优化，条件过滤是关键，LIMIT控制结果集
- 策略要灵活，根据环境和需求动态调整监控强度