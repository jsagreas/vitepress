---
title: 5、监控表与视图详解
---
## 📚 目录

1. [Performance Schema概述](#1-performance-schema概述)
2. [sys_schema系统视图](#2-sys_schema系统视图)
3. [核心监控表结构](#3-核心监控表结构)
4. [历史数据表使用](#4-历史数据表使用)
5. [摘要统计表应用](#5-摘要统计表应用)
6. [监控视图查询技巧](#6-监控视图查询技巧)
7. [性能优化实践](#7-性能优化实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 Performance Schema概述


### 1.1 什么是Performance Schema

Performance Schema是MySQL内置的性能监控引擎，就像给数据库装了一个"体检仪"，能实时监控数据库的各种运行状态。

**🔸 核心作用**
```
简单理解：
- 就像汽车仪表盘，显示发动机转速、油耗、温度等
- MySQL的Performance Schema显示查询执行时间、锁等待、IO操作等
- 帮助我们发现数据库哪里慢、哪里有问题
```

**💡 基本工作原理**
```
数据收集流程：
用户查询 → MySQL引擎执行 → Performance Schema记录 → 形成监控数据

监控维度：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   语句监控   │    │   锁监控     │    │   IO监控    │
│ SQL执行时间  │    │ 锁等待时间   │    │ 文件读写    │
│ 扫描行数     │    │ 死锁检测     │    │ 网络传输    │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 1.2 开启和配置

**启用Performance Schema**：
```sql
-- 检查是否开启
SHOW VARIABLES LIKE 'performance_schema';

-- 配置文件开启（需重启）
[mysqld]
performance_schema = ON
performance_schema_max_table_instances = 12500
```

**🔸 重要理解**
- Performance Schema默认开启，但很多具体监控项需要手动开启
- 监控会消耗一定性能，生产环境要合理配置
- 数据都存在内存中，重启后清空

---

## 2. 🎯 sys_schema系统视图


### 2.1 sys_schema是什么

sys_schema是MySQL 5.7+提供的系统视图集合，把Performance Schema的复杂数据包装成容易理解的视图，就像把复杂的医学报告翻译成普通人能看懂的健康报告。

**📋 主要视图分类**
```
视图类型分布：
┌──────────────────┐
│   语句分析视图    │ ← 哪些SQL最慢、最消耗资源
├──────────────────┤
│   IO分析视图     │ ← 哪些表、文件IO最多
├──────────────────┤
│   内存使用视图    │ ← 内存分配情况
├──────────────────┤
│   用户统计视图    │ ← 每个用户的资源使用
└──────────────────┘
```

### 2.2 常用核心视图


**🔸 语句分析相关视图**
```sql
-- 查看最耗时的SQL语句
SELECT * FROM sys.statement_analysis 
ORDER BY total_latency DESC LIMIT 5;

-- 查看扫描行数最多的语句
SELECT * FROM sys.statements_with_full_table_scans 
ORDER BY no_index_used_count DESC LIMIT 5;
```

**🔸 IO分析相关视图**
```sql
-- 查看IO最频繁的表
SELECT * FROM sys.io_global_by_file_by_bytes 
ORDER BY total DESC LIMIT 10;

-- 查看等待最多的事件
SELECT * FROM sys.io_global_by_wait_by_bytes 
ORDER BY total_latency DESC LIMIT 10;
```

**📊 实际应用示例**
```sql
-- 找出最需要优化的慢查询
SELECT 
    query,
    exec_count,
    avg_latency,
    total_latency,
    max_latency
FROM sys.statement_analysis 
WHERE avg_latency > '100ms'
ORDER BY total_latency DESC;
```

### 2.3 视图使用最佳实践


**🎯 监控重点**
```
日常检查清单：
✅ statement_analysis - 找慢SQL
✅ schema_table_statistics - 找热点表  
✅ innodb_lock_waits - 找锁冲突
✅ user_summary - 找资源消耗大户
```

---

## 3. 🗂️ 核心监控表结构


### 3.1 表分类体系

Performance Schema包含上百张表，按功能可以分为几大类：

```
表结构体系：
                Performance Schema
                        │
        ┌───────────────┼───────────────┐
        │               │               │
    实例级表         会话级表        对象级表
  (全局统计)      (连接统计)      (表/索引统计)
        │               │               │
    ┌───┴───┐       ┌───┴───┐       ┌───┴───┐
   当前表  历史表   当前表  历史表   当前表  历史表
```

### 3.2 实例级统计表


**🔸 全局等待事件统计**
```sql
-- events_waits_summary_global_by_event_name
-- 记录全局各种等待事件的统计信息

SELECT 
    EVENT_NAME,
    COUNT_STAR as '总次数',
    SUM_TIMER_WAIT/1000000000 as '总等待时间(秒)',
    AVG_TIMER_WAIT/1000000000 as '平均等待时间(秒)'
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE COUNT_STAR > 0 
ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
```

**🔸 语句统计汇总表**
```sql
-- events_statements_summary_global_by_event_name
-- 各类SQL语句的全局执行统计

SELECT 
    EVENT_NAME,
    COUNT_STAR as '执行次数',
    SUM_TIMER_WAIT/1000000000 as '总耗时(秒)',
    AVG_TIMER_WAIT/1000000000 as '平均耗时(秒)',
    SUM_ROWS_EXAMINED as '总扫描行数'
FROM performance_schema.events_statements_summary_global_by_event_name 
WHERE COUNT_STAR > 0;
```

### 3.3 会话级统计表


**🔸 按用户统计**
```sql
-- events_statements_summary_by_user_by_event_name
-- 每个用户的语句执行统计

SELECT 
    USER,
    EVENT_NAME,
    COUNT_STAR as '执行次数',
    SUM_TIMER_WAIT/1000000000 as '总耗时(秒)'
FROM performance_schema.events_statements_summary_by_user_by_event_name 
WHERE USER IS NOT NULL 
  AND COUNT_STAR > 0
ORDER BY SUM_TIMER_WAIT DESC;
```

**🔸 当前连接统计**
```sql
-- events_statements_summary_by_thread_by_event_name  
-- 按线程(连接)统计语句执行情况

SELECT 
    t.THREAD_ID,
    t.PROCESSLIST_USER,
    s.EVENT_NAME,
    s.COUNT_STAR,
    s.SUM_TIMER_WAIT/1000000000 as '总耗时(秒)'
FROM performance_schema.events_statements_summary_by_thread_by_event_name s
JOIN performance_schema.threads t ON s.THREAD_ID = t.THREAD_ID
WHERE s.COUNT_STAR > 0;
```

### 3.4 对象级统计表


**🔸 表IO统计**
```sql
-- table_io_waits_summary_by_table
-- 每张表的IO等待统计

SELECT 
    OBJECT_SCHEMA as '数据库',
    OBJECT_NAME as '表名',
    COUNT_STAR as 'IO总次数',
    SUM_TIMER_WAIT/1000000000 as '总等待时间(秒)',
    COUNT_READ as '读操作次数',
    COUNT_WRITE as '写操作次数'
FROM performance_schema.table_io_waits_summary_by_table 
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema')
ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
```

**🔸 索引使用统计**
```sql
-- table_io_waits_summary_by_index_usage
-- 索引使用情况统计

SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_STAR as '使用次数',
    SUM_TIMER_WAIT/1000000000 as '总等待时间(秒)'
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema')
  AND INDEX_NAME IS NOT NULL
ORDER BY COUNT_STAR DESC;
```

---

## 4. 📈 历史数据表使用


### 4.1 历史表的作用

历史表保存了过往的详细监控数据，就像医院保存病历一样，可以分析历史趋势和问题复盘。

**🔸 历史表命名规律**
```
命名规则：
当前表: events_statements_current (只保存当前正在执行的)
历史表: events_statements_history (保存最近N条)
汇总表: events_statements_history_long (保存更多历史记录)

示例对比：
events_waits_current        ← 当前等待事件  
events_waits_history        ← 最近等待历史(每线程10条)
events_waits_history_long   ← 长期等待历史(全局10000条)
```

### 4.2 语句历史分析


**🔸 查看最近的慢查询**
```sql
-- 从历史表中找出执行时间超过1秒的语句
SELECT 
    THREAD_ID,
    EVENT_ID,
    SQL_TEXT,
    TIMER_WAIT/1000000000 as '执行时间(秒)',
    ROWS_EXAMINED as '扫描行数',
    ROWS_SENT as '返回行数'
FROM performance_schema.events_statements_history_long
WHERE TIMER_WAIT > 1000000000000  -- 1秒 = 1000000000000纳秒
  AND SQL_TEXT IS NOT NULL
ORDER BY TIMER_WAIT DESC LIMIT 10;
```

**🔸 分析SQL执行模式**
```sql
-- 查看某段时间内的SQL执行分布
SELECT 
    DATE_FORMAT(FROM_UNIXTIME(TIMER_START/1000000000000), '%Y-%m-%d %H:%i') as '时间段',
    COUNT(*) as 'SQL执行次数',
    AVG(TIMER_WAIT/1000000000) as '平均执行时间(秒)',
    MAX(TIMER_WAIT/1000000000) as '最大执行时间(秒)'
FROM performance_schema.events_statements_history_long
WHERE TIMER_START > UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 1 HOUR)) * 1000000000000
GROUP BY DATE_FORMAT(FROM_UNIXTIME(TIMER_START/1000000000000), '%Y-%m-%d %H:%i')
ORDER BY 时间段;
```

### 4.3 等待事件历史分析


**🔸 锁等待历史追踪**
```sql
-- 查找历史上的锁等待问题
SELECT 
    THREAD_ID,
    EVENT_NAME,
    TIMER_WAIT/1000000000 as '等待时间(秒)',
    OBJECT_SCHEMA,
    OBJECT_NAME,
    SOURCE
FROM performance_schema.events_waits_history_long
WHERE EVENT_NAME LIKE '%lock%'
  AND TIMER_WAIT > 100000000000  -- 超过0.1秒的锁等待
ORDER BY TIMER_WAIT DESC;
```

### 4.4 历史数据清理策略


**⚠️ 重要理解**
```
历史表特点：
✅ 数据存储在内存中，重启后丢失
✅ 有大小限制，满了会覆盖旧数据
✅ 可以手动清理来重新开始监控

清理方法：
-- 清理语句历史
TRUNCATE TABLE performance_schema.events_statements_history_long;

-- 清理等待事件历史  
TRUNCATE TABLE performance_schema.events_waits_history_long;
```

---

## 5. 📊 摘要统计表应用


### 5.1 摘要表的层次结构

摘要表把详细的监控数据按不同维度进行汇总，提供不同粒度的统计信息。

```
摘要表层次：
                  全局摘要 (Global)
                      │
              ┌───────┼───────┐
              │       │       │
          按用户汇总  按主机汇总  按账户汇总
            (User)   (Host)   (Account)
              │       │       │
              └───────┼───────┘
                      │
                  按线程汇总
                  (Thread)
```

### 5.2 语句摘要统计


**🔸 按SQL摘要统计(最重要)**
```sql
-- events_statements_summary_by_digest
-- 按SQL语句模式汇总，找出最频繁和最耗时的SQL模式

SELECT 
    SCHEMA_NAME as '数据库',
    LEFT(DIGEST_TEXT, 100) as 'SQL模式',
    COUNT_STAR as '执行次数',
    SUM_TIMER_WAIT/1000000000 as '总耗时(秒)',
    AVG_TIMER_WAIT/1000000000 as '平均耗时(秒)',
    SUM_ROWS_EXAMINED as '总扫描行数',
    SUM_ROWS_SENT as '总返回行数'
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL
  AND COUNT_STAR > 10
ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
```

**💡 DIGEST_TEXT的理解**
```
DIGEST_TEXT是什么：
原SQL: SELECT * FROM users WHERE id = 123
模式:   SELECT * FROM users WHERE id = ?

作用：
- 把相似的SQL归为一类进行统计
- 不管参数值如何变化，模式相同就归为一组
- 便于找出执行频繁的SQL模式
```

**🔸 按用户汇总的语句统计**
```sql
-- 看每个用户的SQL执行情况
SELECT 
    USER,
    COUNT_STAR as '总执行次数',
    SUM_TIMER_WAIT/1000000000 as '总耗时(秒)',
    AVG_TIMER_WAIT/1000000000 as '平均耗时(秒)',
    SUM_ROWS_EXAMINED as '总扫描行数'
FROM performance_schema.events_statements_summary_by_user_by_event_name 
WHERE EVENT_NAME = 'statement/sql/select'
  AND USER IS NOT NULL
ORDER BY SUM_TIMER_WAIT DESC;
```

### 5.3 等待事件摘要统计


**🔸 按事件类型汇总**
```sql
-- 看哪些等待事件最影响性能
SELECT 
    EVENT_NAME as '等待事件',
    COUNT_STAR as '发生次数', 
    SUM_TIMER_WAIT/1000000000 as '总等待时间(秒)',
    AVG_TIMER_WAIT/1000000000 as '平均等待时间(秒)'
FROM performance_schema.events_waits_summary_global_by_event_name
WHERE COUNT_STAR > 0
  AND EVENT_NAME NOT LIKE '%idle%'  -- 排除空闲等待
ORDER BY SUM_TIMER_WAIT DESC LIMIT 15;
```

**🔸 文件IO摘要统计**
```sql
-- 哪些文件IO最频繁
SELECT 
    FILE_NAME,
    EVENT_NAME,
    COUNT_STAR as 'IO次数',
    SUM_TIMER_WAIT/1000000000 as '总等待时间(秒)',
    SUM_NUMBER_OF_BYTES as '总字节数'
FROM performance_schema.file_summary_by_instance 
WHERE COUNT_STAR > 0
ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
```

### 5.4 表和索引摘要统计


**🔸 表访问热点分析**
```sql
-- 找出访问最频繁的表
SELECT 
    OBJECT_SCHEMA as '数据库',
    OBJECT_NAME as '表名',
    COUNT_STAR as '访问次数',
    SUM_TIMER_WAIT/1000000000 as '总等待时间(秒)',
    COUNT_READ as '读次数',
    COUNT_WRITE as '写次数',
    COUNT_FETCH as '获取次数',
    COUNT_INSERT as '插入次数',
    COUNT_UPDATE as '更新次数',
    COUNT_DELETE as '删除次数'
FROM performance_schema.table_io_waits_summary_by_table 
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema', 'sys')
ORDER BY COUNT_STAR DESC LIMIT 10;
```

---

## 6. 🔍 监控视图查询技巧


### 6.1 高效查询策略


**🎯 查询优化原则**
```
Performance Schema查询优化：
1. 尽量使用sys视图而不是原始表
2. 添加WHERE条件过滤无用数据  
3. 合理使用LIMIT限制结果集
4. 避免在生产高峰期大量查询
```

**🔸 使用索引进行过滤**
```sql
-- 好的做法：使用索引字段过滤
SELECT * FROM performance_schema.events_statements_current 
WHERE THREAD_ID = 123;

-- 不好的做法：全表扫描
SELECT * FROM performance_schema.events_statements_current 
WHERE SQL_TEXT LIKE '%SELECT%';
```

### 6.2 实用查询模板


**🔸 实时监控模板**
```sql
-- 监控当前正在执行的长时间SQL
SELECT 
    p.ID,
    p.USER,
    p.HOST,
    p.DB,
    p.TIME as '执行时间(秒)',
    LEFT(p.INFO, 100) as 'SQL语句'
FROM information_schema.PROCESSLIST p
WHERE p.COMMAND = 'Query'
  AND p.TIME > 10  -- 执行超过10秒
  AND p.INFO IS NOT NULL
ORDER BY p.TIME DESC;
```

**🔸 性能趋势分析模板**
```sql
-- 分析最近1小时的性能趋势
SELECT 
    DATE_FORMAT(FROM_UNIXTIME(TIMER_START/1000000000000), '%H:%i') as '时间',
    COUNT(*) as 'SQL执行数量',
    AVG(TIMER_WAIT/1000000000) as '平均执行时间',
    SUM(ROWS_EXAMINED) as '总扫描行数'
FROM performance_schema.events_statements_history_long
WHERE TIMER_START > UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 1 HOUR)) * 1000000000000
GROUP BY DATE_FORMAT(FROM_UNIXTIME(TIMER_START/1000000000000), '%H:%i')
ORDER BY 时间;
```

### 6.3 关联查询技巧


**🔸 多表关联分析**
```sql
-- 关联线程信息和语句执行情况
SELECT 
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER,
    t.PROCESSLIST_HOST,
    s.SQL_TEXT,
    s.TIMER_WAIT/1000000000 as '执行时间(秒)',
    s.ROWS_EXAMINED
FROM performance_schema.events_statements_current s
JOIN performance_schema.threads t ON s.THREAD_ID = t.THREAD_ID
WHERE s.SQL_TEXT IS NOT NULL
  AND t.PROCESSLIST_ID IS NOT NULL
ORDER BY s.TIMER_WAIT DESC;
```

**🔸 锁等待分析**
```sql
-- 分析当前的锁等待情况
SELECT 
    waiting.THREAD_ID as '等待线程',
    waiting_thread.PROCESSLIST_USER as '等待用户',
    waiting.OBJECT_SCHEMA as '数据库',
    waiting.OBJECT_NAME as '表名',
    waiting.LOCK_TYPE as '锁类型',
    blocking.THREAD_ID as '阻塞线程',
    blocking_thread.PROCESSLIST_USER as '阻塞用户'
FROM performance_schema.data_locks waiting
JOIN performance_schema.data_lock_waits w ON waiting.ENGINE_TRANSACTION_ID = w.REQUESTING_ENGINE_TRANSACTION_ID
JOIN performance_schema.data_locks blocking ON w.BLOCKING_ENGINE_TRANSACTION_ID = blocking.ENGINE_TRANSACTION_ID
JOIN performance_schema.threads waiting_thread ON waiting.THREAD_ID = waiting_thread.THREAD_ID
JOIN performance_schema.threads blocking_thread ON blocking.THREAD_ID = blocking_thread.THREAD_ID;
```

---

## 7. ⚡ 性能优化实践


### 7.1 监控表索引优化


**🔸 关键索引字段**
```
Performance Schema中的重要索引字段：
- THREAD_ID: 用于按线程过滤
- EVENT_ID: 用于按事件过滤  
- OBJECT_SCHEMA, OBJECT_NAME: 用于按对象过滤
- TIMER_START, TIMER_END: 用于按时间过滤
```

**🔸 优化查询示例**
```sql
-- 优化前：全表扫描
SELECT * FROM performance_schema.events_statements_history_long 
WHERE SQL_TEXT LIKE '%users%';

-- 优化后：使用索引字段
SELECT * FROM performance_schema.events_statements_history_long 
WHERE THREAD_ID IN (
    SELECT THREAD_ID FROM performance_schema.threads 
    WHERE PROCESSLIST_USER = 'app_user'
)
AND TIMER_WAIT > 1000000000000;
```

### 7.2 表结构演进管理


**⚠️ 版本差异处理**
```sql
-- 检查表是否存在(适配不同MySQL版本)
SELECT COUNT(*) as table_exists
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'performance_schema' 
  AND TABLE_NAME = 'events_statements_summary_by_digest';

-- 动态SQL适配不同版本
SET @sql = IF(
    (SELECT COUNT(*) FROM information_schema.TABLES 
     WHERE TABLE_SCHEMA = 'performance_schema' 
       AND TABLE_NAME = 'events_statements_summary_by_digest') > 0,
    'SELECT DIGEST_TEXT FROM performance_schema.events_statements_summary_by_digest LIMIT 1',
    'SELECT "Table not available" as message'
);
PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
```

### 7.3 视图性能优化技巧


**🔸 避免性能陷阱**
```sql
-- 错误做法：可能导致性能问题
SELECT * FROM sys.statement_analysis;  -- 全表扫描

-- 正确做法：添加限制条件
SELECT * FROM sys.statement_analysis 
WHERE total_latency > '1s'
ORDER BY total_latency DESC 
LIMIT 20;
```

**🔸 批量分析策略**
```sql
-- 分时段分析，避免一次性查询过多数据
SELECT 
    HOUR(FROM_UNIXTIME(TIMER_START/1000000000000)) as '小时',
    COUNT(*) as '语句数量',
    AVG(TIMER_WAIT/1000000000) as '平均耗时'
FROM performance_schema.events_statements_history_long
WHERE TIMER_START > UNIX_TIMESTAMP(CURDATE()) * 1000000000000
GROUP BY HOUR(FROM_UNIXTIME(TIMER_START/1000000000000))
ORDER BY 小时;
```

### 7.4 生产环境最佳实践


**📋 监控检查清单**
```
日常监控要点：
✅ 每日检查TOP 10慢查询
✅ 监控锁等待超过1秒的情况  
✅ 检查表扫描行数异常的SQL
✅ 监控连接数和活跃线程数
✅ 检查IO等待时间异常的文件

告警阈值设置：
- 单个SQL执行时间 > 5秒
- 锁等待时间 > 10秒  
- 扫描行数 > 100万行
- 连接数 > 最大连接数的80%
```

**🔧 自动化监控脚本**
```sql
-- 创建监控视图
CREATE VIEW daily_slow_queries AS
SELECT 
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 200) as sql_pattern,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000000 as avg_time_sec,
    SUM_TIMER_WAIT/1000000000 as total_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE AVG_TIMER_WAIT > 1000000000000  -- 平均超过1秒
  AND COUNT_STAR > 10  -- 执行超过10次
ORDER BY total_time_sec DESC;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Performance Schema：MySQL内置的性能监控系统
🔸 sys_schema：封装好的易用监控视图集合
🔸 监控表分类：实例级、会话级、对象级统计
🔸 历史数据：current(当前)、history(短期)、history_long(长期)
🔸 摘要统计：按不同维度汇总的性能数据
```

### 8.2 关键理解要点


**🔹 什么时候用哪个表**
```
实时问题诊断：
→ 用current表查看当前状态
→ 用sys视图快速定位问题

历史趋势分析：  
→ 用history表分析最近趋势
→ 用摘要表看整体统计

性能优化：
→ 用digest表找频繁SQL模式
→ 用IO表找热点表和文件
```

**🔹 监控的核心思路**
```
性能监控三部曲：
1. 发现问题：通过摘要表找异常指标
2. 定位问题：通过历史表找具体SQL和时间点  
3. 解决问题：优化SQL、添加索引、调整配置
```

### 8.3 实际应用价值


**🎯 日常运维应用**
- **问题诊断**：快速找到导致性能问题的SQL
- **容量规划**：分析资源使用趋势，预测容量需求
- **性能优化**：基于监控数据进行针对性优化
- **故障复盘**：通过历史数据分析故障原因

**🔧 优化实践指导**
- **SQL优化**：基于执行统计优化慢查询
- **索引优化**：根据扫描行数添加合适索引
- **架构优化**：基于热点表分析进行分库分表
- **参数调优**：根据等待事件调整MySQL参数

**💡 核心记忆要点**
```
Performance Schema = MySQL的体检报告
sys_schema = 把复杂报告翻译成人话
监控表 = 分门别类记录各种性能数据
摘要表 = 把详细数据汇总成统计结果

记住口诀：
- 有问题找sys视图
- 要详情查原始表  
- 看趋势用摘要表
- 追历史查history表
```