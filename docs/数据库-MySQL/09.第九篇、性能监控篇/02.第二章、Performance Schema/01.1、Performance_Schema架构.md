---
title: 1、Performance_Schema架构
---
## 📚 目录

1. [Performance Schema基础概念](#1-Performance-Schema基础概念)
2. [PS内存引擎架构](#2-PS内存引擎架构)
3. [事件采集框架详解](#3-事件采集框架详解)
4. [Instruments监控点系统](#4-Instruments监控点系统)
5. [Consumers消费者机制](#5-Consumers消费者机制)
6. [Setup表配置体系](#6-Setup表配置体系)
7. [性能开销控制策略](#7-性能开销控制策略)
8. [PS与传统监控对比](#8-PS与传统监控对比)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 Performance Schema基础概念


### 1.1 什么是Performance Schema


**🔸 简单理解**
Performance Schema（简称PS）就像MySQL的"体检报告生成器"，它能实时监控MySQL内部发生的各种活动，告诉你哪些操作慢、哪些资源紧张、哪里可能有问题。

```
生活类比：
医院体检 → Performance Schema监控
体检指标 → 性能指标
体检报告 → 监控数据
医生建议 → 优化建议
```

**🔸 核心作用**
```
传统监控方式：
外部工具 → 猜测MySQL内部状况
症状诊断 → 问题已经发生

Performance Schema：
内部监控 → 直接观察MySQL运行状态  
预防诊断 → 提前发现潜在问题
实时数据 → 立即反馈性能变化
```

### 1.2 PS在MySQL监控中的地位


**🏆 监控工具对比**
```
监控层次：
┌─────────────────────┐
│ 应用层监控工具        │ ← 外部工具(Prometheus等)
├─────────────────────┤
│ MySQL自带监控        │ ← SHOW STATUS, INFORMATION_SCHEMA
├─────────────────────┤
│ Performance Schema  │ ← 内核级监控(最详细)
├─────────────────────┤
│ MySQL内核           │ ← 实际执行层
└─────────────────────┘
```

**💡 独特优势**
- **内核级监控**：直接在MySQL内核层收集数据，最准确
- **实时性强**：事件发生即记录，无延迟
- **覆盖全面**：从SQL执行到锁等待，从内存使用到文件IO全覆盖
- **开销可控**：可以精确控制监控开销

---

## 2. 🏗️ PS内存引擎架构


### 2.1 整体架构设计


**🔸 核心组件构成**
```
Performance Schema架构图：
┌─────────────────────────────────────┐
│              应用查询               │
│        SELECT * FROM events_xxx     │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│           消费者层(Consumers)        │
│   events_statements_current         │
│   events_waits_history             │  
│   events_stages_summary            │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│          事件收集层                  │
│   SQL解析 → 锁等待 → IO操作         │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│       监控点层(Instruments)         │
│   wait/io/file → wait/synch/mutex   │
│   statement/sql → stage/sql         │
└─────────────────────────────────────┘
```

### 2.2 内存分配机制


**💾 内存管理特点**
```sql
-- 查看PS内存使用情况
SELECT * FROM performance_schema.memory_summary_global_by_event_name
WHERE event_name LIKE 'memory/performance_schema/%'
ORDER BY current_bytes DESC;
```

**🔸 内存特点**
- **预分配模式**：启动时分配固定大小内存池
- **环形缓冲区**：历史数据采用环形覆盖，避免内存爆炸
- **可配置大小**：可通过参数控制各类事件的存储数量

```
内存分配示例：
performance_schema_events_statements_history_size = 10
含义：每个线程最多保存10条SQL历史记录

performance_schema_events_waits_history_long_size = 10000  
含义：全局最多保存10000条等待事件历史
```

---

## 3. ⚡ 事件采集框架详解


### 3.1 事件驱动监控原理


**🔸 监控原理**
Performance Schema基于"事件驱动"的思想：MySQL内核每执行一个操作，就产生一个对应的监控事件。

```
事件生命周期：
操作开始 → 创建事件 → 记录开始时间
操作执行 → 更新事件状态
操作结束 → 记录结束时间 → 计算耗时 → 存储到相应表中
```

**💡 生活类比**
```
就像快递追踪：
下单 → 事件开始(创建包裹追踪)
揽件 → 事件更新(状态变更)  
运输 → 事件更新(位置变更)
送达 → 事件结束(记录总耗时)
```

### 3.2 事件分类体系


**📊 五大事件类型**

| 事件类型 | **作用** | **典型场景** | **相关表** |
|---------|---------|------------|-----------|
| 🔍 **wait事件** | `等待操作监控` | `锁等待、IO等待` | `events_waits_*` |
| 📝 **statement事件** | `SQL语句监控` | `查询分析、慢SQL` | `events_statements_*` |
| 🔄 **stage事件** | `SQL执行阶段` | `优化器分析、排序` | `events_stages_*` |
| 🔗 **transaction事件** | `事务监控` | `事务耗时、死锁` | `events_transactions_*` |
| 💾 **memory事件** | `内存使用监控` | `内存泄漏、OOM` | `memory_summary_*` |

**🔸 事件层次关系**
```
事件包含关系：
Transaction(事务)
├── Statement(SQL语句) 
│   ├── Stage(执行阶段)
│   │   └── Wait(等待事件)
│   │   └── Wait(等待事件)
│   └── Stage(执行阶段)
└── Statement(SQL语句)
```

---

## 4. 🎛️ Instruments监控点系统


### 4.1 监控点概念


**🔸 什么是Instruments**
Instruments就是MySQL内核中的"探测器"，在关键位置放置监控点，当代码执行到这些位置时自动收集性能数据。

**💡 形象理解**
```
高速公路监控：
收费站 → wait/io/file (文件IO监控点)
测速点 → wait/synch/mutex (锁监控点)  
摄像头 → statement/sql (SQL监控点)
```

### 4.2 监控点分类


**📋 主要监控点类别**
```sql
-- 查看所有可用的监控点
SELECT name, enabled, timed 
FROM performance_schema.setup_instruments 
WHERE name LIKE 'wait/io%' 
LIMIT 5;
```

**🔸 常用监控点类型**
```
wait/io/file/* → 文件IO操作
  wait/io/file/sql/binlog → 二进制日志写入
  wait/io/file/sql/slow_log → 慢查询日志写入

wait/synch/* → 同步等待操作  
  wait/synch/mutex → 互斥锁等待
  wait/synch/rwlock → 读写锁等待

statement/sql/* → SQL语句执行
  statement/sql/select → SELECT语句
  statement/sql/insert → INSERT语句

stage/sql/* → SQL执行阶段
  stage/sql/Sending data → 数据发送阶段
  stage/sql/Sorting result → 结果排序阶段
```

### 4.3 监控点配置


**⚙️ 启用/禁用监控点**
```sql
-- 启用所有文件IO监控
UPDATE performance_schema.setup_instruments 
SET enabled = 'YES', timed = 'YES' 
WHERE name LIKE 'wait/io/file%';

-- 禁用特定监控点(减少开销)
UPDATE performance_schema.setup_instruments 
SET enabled = 'NO' 
WHERE name = 'wait/synch/mutex/innodb/log_sys_mutex';
```

---

## 5. 📊 Consumers消费者机制


### 5.1 消费者概念


**🔸 什么是Consumers**
消费者决定监控数据存储到哪些表中。可以理解为"数据的去向控制器"。

```
数据流向：
监控点产生数据 → 消费者决定存储位置 → 用户查询对应表
```

### 5.2 消费者层次结构


**📊 消费者层次关系**
```sql
-- 查看所有消费者配置
SELECT * FROM performance_schema.setup_consumers;
```

**🔸 层次结构**
```
消费者层次：
global_instrumentation (全局开关)
├── thread_instrumentation (线程级别)
│   ├── events_waits_current (当前等待事件)
│   ├── events_waits_history (线程等待历史)
│   └── events_waits_history_long (全局等待历史)
├── events_statements_current (当前SQL)
├── events_stages_current (当前执行阶段)  
└── statements_digest (SQL摘要统计)
```

### 5.3 消费者配置策略


**⚙️ 实用配置建议**
```sql
-- 基础监控配置(低开销)
UPDATE performance_schema.setup_consumers 
SET enabled = 'YES' 
WHERE name IN (
    'global_instrumentation',
    'thread_instrumentation', 
    'events_statements_current',
    'statements_digest'
);

-- 详细监控配置(高开销，排查问题时使用)
UPDATE performance_schema.setup_consumers 
SET enabled = 'YES' 
WHERE name LIKE 'events_%_history%';
```

---

## 6. 🔧 Setup表配置体系


### 6.1 配置表概览


**📋 主要配置表**
```
setup_actors → 控制哪些用户的活动被监控
setup_consumers → 控制数据存储到哪些表  
setup_instruments → 控制哪些监控点被启用
setup_objects → 控制哪些数据库对象被监控
setup_threads → 控制哪些线程被监控
```

### 6.2 实用配置示例


**🎯 针对性监控配置**
```sql
-- 只监控特定数据库
INSERT INTO performance_schema.setup_objects 
VALUES ('TABLE', 'your_database', '%', 'YES', 'YES');

-- 排除系统用户监控
UPDATE performance_schema.setup_actors 
SET enabled = 'NO' 
WHERE user IN ('root', 'mysql.sys');

-- 只监控慢查询相关
UPDATE performance_schema.setup_instruments 
SET enabled = 'YES' 
WHERE name LIKE '%slow%' OR name LIKE '%long%';
```

---

## 7. ⚡ 性能开销控制策略


### 7.1 开销评估


**📊 监控开销量化**
```sql
-- 查看PS自身性能开销
SELECT event_name, count_star, sum_timer_wait/1000000000 as total_time_sec
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE event_name LIKE 'wait/synch/mutex/performance_schema%'
ORDER BY sum_timer_wait DESC;
```

**🔸 开销控制原则**
- **生产环境**：只启用必要监控，关注核心指标
- **开发环境**：可以启用详细监控，便于问题定位
- **问题排查**：临时启用高开销监控，完成后立即关闭

### 7.2 分级监控策略


**🟢 基础监控 (开销 < 5%)**
```sql
-- 只启用核心消费者
SET @minimal_consumers = 'global_instrumentation,thread_instrumentation,events_statements_current,statements_digest';

-- 只启用关键监控点
UPDATE performance_schema.setup_instruments 
SET enabled = 'YES' 
WHERE name IN (
    'statement/sql/select',
    'statement/sql/insert', 
    'statement/sql/update',
    'statement/sql/delete'
);
```

**🟡 标准监控 (开销 5-10%)**
```sql
-- 增加等待事件监控
UPDATE performance_schema.setup_instruments 
SET enabled = 'YES' 
WHERE name LIKE 'wait/io/file%' 
   OR name LIKE 'wait/synch/mutex%';
```

**🔴 详细监控 (开销 > 10%)**
```sql
-- 启用历史记录(仅问题排查时使用)
UPDATE performance_schema.setup_consumers 
SET enabled = 'YES' 
WHERE name LIKE '%history%';
```

---

## 8. 📈 PS与传统监控对比


### 8.1 监控方法对比


| 监控方法 | **数据来源** | **实时性** | **详细程度** | **性能开销** | **使用难度** |
|---------|------------|-----------|------------|------------|------------|
| 🔧 **SHOW STATUS** | `状态变量` | `快照式` | `汇总数据` | `极低` | `简单` |
| 📊 **慢查询日志** | `日志文件` | `延迟` | `单条SQL` | `低` | `中等` |
| 🎯 **Performance Schema** | `内核事件` | `实时` | `极详细` | `可控` | `复杂` |
| 🌐 **外部工具** | `多种来源` | `采样` | `综合分析` | `低` | `简单` |

### 8.2 使用场景选择


**🎯 最佳实践**
```
日常监控：
SHOW STATUS + 外部工具 → 宏观把控
慢查询日志 → 发现问题SQL

问题定位：
Performance Schema → 深入分析
精确定位性能瓶颈

故障排查：
Performance Schema详细模式 → 事件级别追踪
找出具体原因
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Performance Schema：MySQL内核级性能监控引擎
🔸 Instruments：内核中的性能监控点，产生原始数据
🔸 Consumers：决定监控数据的存储位置和方式  
🔸 Setup表：控制监控行为的配置表集合
🔸 事件驱动：基于MySQL内核事件的实时监控机制
```

### 9.2 关键理解要点


**🔹 PS的核心价值**
```
实时性：事件发生即记录，无延迟
准确性：内核级数据收集，最可靠
全面性：覆盖SQL执行的各个环节  
可控性：精确控制监控范围和开销
```

**🔹 配置策略**
```
生产环境：启用基础监控，关注核心指标
开发测试：启用详细监控，便于问题发现
故障排查：临时启用高开销监控，快速定位
日常维护：定期分析监控数据，预防问题
```

**🔹 性能开销平衡**
```
监控价值 vs 性能开销
详细程度 vs 存储空间  
实时性 vs 系统负载
问题定位 vs 正常运行
```

### 9.3 实际应用指导


**🎯 典型使用流程**
1. **基础配置**：启用核心消费者和关键监控点
2. **日常监控**：关注statements_digest表，发现慢SQL
3. **问题排查**：启用详细监控，分析具体事件
4. **优化验证**：对比优化前后的性能数据
5. **配置调整**：根据实际需求调整监控范围

**💡 最佳实践建议**
- **渐进式启用**：从基础监控开始，逐步增加详细程度
- **定期清理**：利用环形缓冲区特性，避免数据堆积
- **文档化配置**：记录配置变更，便于问题排查
- **监控监控器**：关注PS自身的性能开销

**核心记忆**：
- Performance Schema是MySQL的"实时体检系统"
- Instruments产生数据，Consumers决定去向，Setup控制行为
- 平衡监控价值与性能开销是使用PS的关键
- 从基础监控开始，按需启用详细功能