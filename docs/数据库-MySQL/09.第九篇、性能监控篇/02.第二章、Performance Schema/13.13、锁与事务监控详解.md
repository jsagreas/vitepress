---
title: 13、锁与事务监控详解
---
## 📚 目录

1. [Performance Schema锁监控概述](#1-performance-schema锁监控概述)
2. [锁等待监控实现](#2-锁等待监控实现)
3. [死锁监控检测](#3-死锁监控检测)
4. [事务监控统计](#4-事务监控统计)
5. [MVCC监控分析](#5-mvcc监控分析)
6. [线程状态监控](#6-线程状态监控)
7. [并发性能分析](#7-并发性能分析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔒 Performance Schema锁监控概述


### 1.1 什么是Performance Schema锁监控


**简单理解**：就像银行排队系统一样，Performance Schema锁监控帮我们看清楚"谁在等什么锁，等了多久，为什么等"。

```
银行排队类比：
客户A正在办理业务（持有锁）
客户B在排队等待（锁等待）
客户C也在排队（锁等待链）

Performance Schema做的事：
记录谁在等、等什么、等多久
分析哪里容易堵塞
帮助优化排队效率
```

**核心作用**：
- **锁等待追踪**：实时监控哪些线程在等锁
- **死锁检测**：发现并分析死锁情况
- **事务分析**：监控事务执行状况
- **性能瓶颈定位**：找出并发问题根源

### 1.2 主要监控表介绍


**核心监控表说明**：

```sql
-- 锁相关的主要表
metadata_locks          -- 元数据锁信息
data_locks             -- 数据锁信息  
data_lock_waits        -- 锁等待关系
events_transactions_*  -- 事务事件信息
events_statements_*    -- SQL语句执行信息
```

**表的作用**：
- `metadata_locks`：监控表级别的锁（如DDL锁）
- `data_locks`：监控行级别的锁（如记录锁、间隙锁）
- `data_lock_waits`：监控锁等待关系链
- `events_transactions_*`：事务的完整生命周期
- `events_statements_*`：具体SQL的执行情况

---

## 2. ⏳ 锁等待监控实现


### 2.1 基础锁等待监控


**什么是锁等待**：当一个事务想要获取某个资源的锁，但该锁被其他事务持有时，就会发生锁等待。

```sql
-- 查看当前所有锁等待情况
SELECT 
    r.trx_id AS blocking_trx,           -- 阻塞事务ID
    r.trx_mysql_thread_id AS blocking_thread,  -- 阻塞线程ID
    CONCAT(r.trx_id, ' blocks ', b.trx_id) AS wait_relationship,
    r.trx_query AS blocking_query,      -- 阻塞的SQL
    b.trx_query AS blocked_query,       -- 被阻塞的SQL
    b.trx_wait_started AS wait_start_time,  -- 等待开始时间
    TIMESTAMPDIFF(SECOND, b.trx_wait_started, NOW()) AS wait_seconds
FROM 
    information_schema.innodb_lock_waits w
    INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.blocking_trx_id  
    INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.requesting_trx_id
ORDER BY wait_seconds DESC;
```

**查询结果解读**：
- `blocking_trx`：谁在阻塞别人
- `blocked_query`：被阻塞的具体SQL
- `wait_seconds`：已经等待的时间（秒）

### 2.2 Performance Schema锁等待监控


**使用新版本的Performance Schema表**：

```sql
-- 查看数据锁等待详情
SELECT 
    waiting.THREAD_ID AS waiting_thread,
    waiting.OBJECT_NAME AS table_name,
    waiting.LOCK_TYPE,
    waiting.LOCK_MODE AS waiting_lock_mode,
    blocking.THREAD_ID AS blocking_thread,
    blocking.LOCK_MODE AS blocking_lock_mode,
    waiting.LOCK_DATA AS lock_data
FROM 
    performance_schema.data_lock_waits dlw
    JOIN performance_schema.data_locks waiting 
        ON dlw.REQUESTING_ENGINE_TRANSACTION_ID = waiting.ENGINE_TRANSACTION_ID
    JOIN performance_schema.data_locks blocking 
        ON dlw.BLOCKING_ENGINE_TRANSACTION_ID = blocking.ENGINE_TRANSACTION_ID;
```

**重要字段说明**：
- `LOCK_TYPE`：锁类型（如RECORD、TABLE）
- `LOCK_MODE`：锁模式（如X、S、IX、IS）
- `LOCK_DATA`：锁定的具体数据

### 2.3 锁等待超时监控


**监控锁等待超时情况**：

```sql
-- 创建监控锁等待超时的视图
CREATE VIEW lock_wait_timeout_monitor AS
SELECT 
    THREAD_ID,
    OBJECT_NAME AS table_name,
    LOCK_TYPE,
    LOCK_MODE,
    LOCK_STATUS,
    LOCK_DATA,
    TIMER_START,
    TIMER_END,
    TIMER_WAIT/1000000000 AS wait_time_seconds
FROM performance_schema.events_waits_history
WHERE EVENT_NAME LIKE 'wait/lock/%'
    AND TIMER_WAIT/1000000000 > 5  -- 等待超过5秒的锁
ORDER BY TIMER_WAIT DESC;
```

---

## 3. 💀 死锁监控检测


### 3.1 什么是死锁


**通俗解释**：死锁就像两个人过独木桥，都不让对方先过，结果谁也过不去。

```
死锁示例场景：
事务A：锁定了记录1，想要锁定记录2
事务B：锁定了记录2，想要锁定记录1
结果：两个事务互相等待，形成死锁

A持有1 → 想要2 ← B持有2
    ↑              ↓
    想要1 ← A   B想要1
```

### 3.2 死锁检测查询


**查看最近的死锁信息**：

```sql
-- 查看InnoDB死锁信息
SHOW ENGINE INNODB STATUS;

-- 从Performance Schema查看死锁相关事件
SELECT 
    THREAD_ID,
    EVENT_NAME,
    SOURCE,
    TIMER_START,
    TIMER_END,
    TIMER_WAIT/1000000000 AS duration_seconds,
    NESTING_EVENT_ID,
    OBJECT_NAME,
    MESSAGE_TEXT
FROM performance_schema.events_errors_history
WHERE ERROR_NUMBER = 1213  -- 死锁错误号
ORDER BY TIMER_START DESC
LIMIT 10;
```

### 3.3 死锁监控存储过程


**创建死锁监控工具**：

```sql
DELIMITER //
CREATE PROCEDURE monitor_deadlocks()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE deadlock_count INT;
    
    -- 检查是否有死锁发生
    SELECT COUNT(*) INTO deadlock_count
    FROM performance_schema.events_errors_history 
    WHERE ERROR_NUMBER = 1213 
        AND TIMER_START > UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 1 HOUR)) * 1000000000;
    
    IF deadlock_count > 0 THEN
        -- 输出死锁详情
        SELECT 
            '死锁检测到' AS alert_type,
            THREAD_ID,
            FROM_UNIXTIME(TIMER_START/1000000000) AS deadlock_time,
            MESSAGE_TEXT AS error_message
        FROM performance_schema.events_errors_history 
        WHERE ERROR_NUMBER = 1213 
        ORDER BY TIMER_START DESC
        LIMIT 5;
    ELSE 
        SELECT '最近1小时无死锁' AS status;
    END IF;
END //
DELIMITER ;
```

---

## 4. 📊 事务监控统计


### 4.1 事务基础监控


**事务监控的重要性**：了解事务的运行状况，包括事务持续时间、锁持有情况、回滚率等。

```sql
-- 监控当前活跃事务
SELECT 
    trx_id AS transaction_id,
    trx_state AS state,
    trx_started AS start_time,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_seconds,
    trx_requested_lock_id AS requested_lock,
    trx_wait_started AS wait_start,
    trx_weight AS transaction_weight,
    trx_mysql_thread_id AS thread_id,
    trx_query AS current_query
FROM information_schema.innodb_trx
WHERE trx_state != 'COMMITTED'
ORDER BY trx_started;
```

**字段含义**：
- `trx_state`：事务状态（RUNNING、LOCK WAIT等）
- `duration_seconds`：事务已运行时间
- `trx_weight`：事务权重（持有锁和修改记录的数量）

### 4.2 事务性能统计


**Performance Schema事务监控**：

```sql
-- 事务性能统计
SELECT 
    THREAD_ID,
    EVENT_NAME,
    STATE,
    GTI_ID,
    XID_FORMAT_ID,
    TIMER_START,
    TIMER_END,
    TIMER_WAIT/1000000000 AS duration_seconds,
    ACCESS_MODE,
    ISOLATION_LEVEL,
    AUTOCOMMIT,
    NESTING_EVENT_ID
FROM performance_schema.events_transactions_current
WHERE STATE != 'COMMITTED'
ORDER BY TIMER_START;
```

### 4.3 事务回滚监控


**监控事务回滚情况**：

```sql
-- 创建事务回滚监控视图
CREATE VIEW transaction_rollback_monitor AS
SELECT 
    DATE(FROM_UNIXTIME(TIMER_START/1000000000)) AS rollback_date,
    COUNT(*) AS rollback_count,
    AVG(TIMER_WAIT/1000000000) AS avg_duration_seconds,
    MAX(TIMER_WAIT/1000000000) AS max_duration_seconds
FROM performance_schema.events_transactions_history
WHERE EVENT_NAME = 'transaction' 
    AND STATE = 'ROLLED BACK'
GROUP BY DATE(FROM_UNIXTIME(TIMER_START/1000000000))
ORDER BY rollback_date DESC;
```

---

## 5. 🔄 MVCC监控分析


### 5.1 什么是MVCC


**MVCC简单理解**：Multi-Version Concurrency Control（多版本并发控制），就像图书馆里同一本书有多个版本，不同的人可以同时读不同版本。

```
MVCC工作原理：
┌─────────────────┐
│   当前版本      │ ← 新事务读取
├─────────────────┤
│   历史版本1     │ ← 长事务可能读取
├─────────────────┤  
│   历史版本2     │ ← 更老的事务读取
└─────────────────┘

优势：读不阻塞写，写不阻塞读
```

### 5.2 MVCC版本监控


**监控MVCC版本情况**：

```sql
-- 查看InnoDB MVCC状态
SELECT 
    variable_name,
    variable_value
FROM performance_schema.global_status 
WHERE variable_name IN (
    'Innodb_rows_read',
    'Innodb_rows_inserted', 
    'Innodb_rows_updated',
    'Innodb_rows_deleted',
    'Innodb_num_open_files'
);

-- 监控长事务（可能影响MVCC性能）
SELECT 
    trx_id,
    trx_started,
    TIMESTAMPDIFF(MINUTE, trx_started, NOW()) AS duration_minutes,
    trx_isolation_level,
    trx_mysql_thread_id
FROM information_schema.innodb_trx 
WHERE TIMESTAMPDIFF(MINUTE, trx_started, NOW()) > 60  -- 超过1小时的长事务
ORDER BY trx_started;
```

### 5.3 Undo日志监控


**监控Undo日志增长**：

```sql
-- Undo日志相关监控
SELECT 
    variable_name,
    variable_value,
    CASE 
        WHEN variable_name = 'Innodb_undo_tablespaces_total' 
        THEN '总Undo表空间数'
        WHEN variable_name = 'Innodb_undo_tablespaces_active'
        THEN '活跃Undo表空间数'
        WHEN variable_name = 'Innodb_undo_tablespaces_explicit'
        THEN '显式Undo表空间数'
    END AS description
FROM performance_schema.global_status 
WHERE variable_name LIKE 'Innodb_undo%';
```

---

## 6. 🧵 线程状态监控


### 6.1 线程基础监控


**线程监控的重要性**：了解数据库连接线程的状态，发现异常线程和资源占用问题。

```sql
-- 监控所有活跃线程
SELECT 
    t.THREAD_ID,
    t.NAME AS thread_name,
    t.TYPE AS thread_type,
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER,
    t.PROCESSLIST_HOST,
    t.PROCESSLIST_DB,
    t.PROCESSLIST_COMMAND,
    t.PROCESSLIST_STATE,
    t.PROCESSLIST_TIME,
    t.CONNECTION_TYPE
FROM performance_schema.threads t
WHERE t.TYPE = 'FOREGROUND'  -- 前台线程（用户连接）
    AND t.PROCESSLIST_COMMAND != 'Sleep'
ORDER BY t.PROCESSLIST_TIME DESC;
```

**重要字段说明**：
- `PROCESSLIST_COMMAND`：线程正在执行的命令类型
- `PROCESSLIST_STATE`：线程当前状态
- `PROCESSLIST_TIME`：当前状态持续时间
- `CONNECTION_TYPE`：连接类型（TCP/IP、Socket等）

### 6.2 线程资源使用监控


**监控线程资源消耗**：

```sql
-- 线程资源使用统计
SELECT 
    t.THREAD_ID,
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER,
    t.PROCESSLIST_HOST,
    a.VARIABLE_NAME,
    a.VARIABLE_VALUE
FROM performance_schema.threads t
JOIN performance_schema.status_by_thread a 
    ON t.THREAD_ID = a.THREAD_ID
WHERE a.VARIABLE_NAME IN (
    'Bytes_sent',
    'Bytes_received', 
    'Com_select',
    'Com_insert',
    'Com_update',
    'Com_delete'
)
    AND t.TYPE = 'FOREGROUND'
    AND a.VARIABLE_VALUE > 0
ORDER BY t.THREAD_ID, a.VARIABLE_NAME;
```

### 6.3 后台线程监控


**监控MySQL后台线程**：

```sql
-- 后台线程状态监控
SELECT 
    NAME AS thread_name,
    TYPE AS thread_type,
    INSTRUMENTED,
    HISTORY,
    CONNECTION_TYPE,
    THREAD_OS_ID
FROM performance_schema.threads
WHERE TYPE = 'BACKGROUND'  -- 后台线程
ORDER BY NAME;
```

**常见后台线程**：
- `thread/sql/main`：主线程
- `thread/innodb/io_*`：InnoDB IO线程
- `thread/innodb/srv_*`：InnoDB服务线程
- `thread/innodb/buf_*`：InnoDB缓冲池线程

---

## 7. 📈 并发性能分析


### 7.1 并发度监控


**监控数据库并发情况**：

```sql
-- 实时并发度监控
SELECT 
    '当前连接数' AS metric_name,
    COUNT(*) AS metric_value
FROM performance_schema.threads 
WHERE TYPE = 'FOREGROUND'

UNION ALL

SELECT 
    '活跃查询数' AS metric_name,
    COUNT(*) AS metric_value  
FROM performance_schema.threads
WHERE TYPE = 'FOREGROUND' 
    AND PROCESSLIST_COMMAND NOT IN ('Sleep', 'Daemon')

UNION ALL

SELECT 
    '锁等待数' AS metric_name,
    COUNT(*) AS metric_value
FROM information_schema.innodb_trx
WHERE trx_state = 'LOCK WAIT';
```

### 7.2 锁冲突分析


**分析锁冲突热点**：

```sql
-- 锁冲突热点分析
SELECT 
    OBJECT_SCHEMA AS database_name,
    OBJECT_NAME AS table_name, 
    LOCK_TYPE,
    LOCK_MODE,
    COUNT(*) AS lock_count,
    COUNT(DISTINCT ENGINE_TRANSACTION_ID) AS transaction_count
FROM performance_schema.data_locks
GROUP BY OBJECT_SCHEMA, OBJECT_NAME, LOCK_TYPE, LOCK_MODE
HAVING lock_count > 1  -- 多个锁的情况
ORDER BY lock_count DESC;
```

### 7.3 并发性能评估


**创建并发性能评估报告**：

```sql
-- 并发性能综合评估
SELECT 
    'Lock Contention Rate' AS metric,
    CONCAT(
        ROUND(
            (SELECT COUNT(*) FROM information_schema.innodb_trx WHERE trx_state = 'LOCK WAIT') * 100.0 /
            NULLIF((SELECT COUNT(*) FROM performance_schema.threads WHERE TYPE = 'FOREGROUND'), 0),
            2
        ), 
        '%'
    ) AS value,
    '锁争用率：锁等待事务/总前台线程' AS description

UNION ALL

SELECT 
    'Average Transaction Duration' AS metric,
    CONCAT(
        ROUND(AVG(TIMESTAMPDIFF(SECOND, trx_started, NOW())), 2),
        ' seconds'
    ) AS value,
    '平均事务持续时间' AS description
FROM information_schema.innodb_trx
WHERE trx_state = 'RUNNING'

UNION ALL

SELECT 
    'Long Transaction Count' AS metric,
    COUNT(*) AS value,
    '长事务数量（>60秒）' AS description  
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 60;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Performance Schema锁监控：实时监控锁状态的工具
🔸 锁等待：事务等待获取锁的状态，需要重点关注
🔸 死锁：两个或多个事务互相等待对方释放锁
🔸 MVCC：多版本并发控制，实现读写不阻塞
🔸 事务监控：跟踪事务生命周期和性能指标
🔸 线程监控：监控数据库连接和后台线程状态
```

### 8.2 关键监控指标


**🔹 锁相关指标**：
```
锁等待数量：正在等待锁的事务数
锁等待时间：平均锁等待持续时间  
死锁频率：单位时间内死锁发生次数
锁争用率：锁等待事务占总事务的比例
```

**🔹 事务相关指标**：
```
活跃事务数：当前运行中的事务数量
长事务数量：运行时间超过阈值的事务
事务回滚率：回滚事务占总事务的比例
平均事务持续时间：事务从开始到结束的平均时间
```

**🔹 并发相关指标**：
```
并发连接数：同时连接的客户端数量
活跃查询数：正在执行的SQL数量
线程状态分布：各种状态线程的数量分布
资源争用情况：CPU、内存、IO的竞争状态
```

### 8.3 实际应用指导


**🎯 监控策略**：
- **实时监控**：关注锁等待、死锁、长事务
- **定期分析**：统计锁冲突热点、并发性能趋势
- **告警设置**：锁等待超时、死锁频繁、长事务过多
- **优化建议**：基于监控数据优化SQL和事务设计

**🔧 问题定位流程**：
```
1. 发现性能问题
2. 检查锁等待情况
3. 分析事务状态
4. 查看线程分布
5. 定位问题SQL
6. 制定优化方案
```

**核心记忆要点**：
- Performance Schema是MySQL自带的性能监控利器
- 锁等待和死锁是并发问题的主要表现
- 事务监控帮助发现长事务和回滚问题  
- 线程监控反映数据库的整体健康状态
- 定期监控分析，防患于未然比事后处理更重要