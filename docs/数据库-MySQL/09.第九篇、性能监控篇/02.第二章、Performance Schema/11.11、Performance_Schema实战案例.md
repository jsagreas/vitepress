---
title: 11、Performance_Schema实战案例
---
## 📚 目录

1. [Performance Schema简介](#1-performance-schema简介)
2. [慢查询分析案例](#2-慢查询分析案例)
3. [锁等待分析案例](#3-锁等待分析案例)
4. [内存使用分析案例](#4-内存使用分析案例)
5. [IO瓶颈分析案例](#5-io瓶颈分析案例)
6. [连接问题分析案例](#6-连接问题分析案例)
7. [复制监控案例](#7-复制监控案例)
8. [故障诊断案例](#8-故障诊断案例)
9. [性能调优案例](#9-性能调优案例)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 Performance Schema简介


### 1.1 什么是Performance Schema


**Performance Schema**是MySQL内置的性能监控工具，就像医院里的各种检查设备，能够实时监控数据库的"健康状况"。

> 💡 **通俗理解**  
> 把Performance Schema想象成汽车的仪表盘，能显示速度、油耗、引擎状态等信息，帮助我们了解MySQL运行情况

**核心特点**：
```
实时监控：像监控摄像头，实时记录数据库活动
低开销：监控本身不会明显影响性能
丰富信息：包含SQL执行、锁等待、内存使用等
```

### 1.2 Performance Schema的工作原理


```
数据流向：
应用程序 ──SQL请求──> MySQL服务器
                        │
                        ├─> 执行SQL
                        │
                        └─> Performance Schema收集数据
                            │
                            └─> 存储到内存表中供查询
```

**监控的主要内容**：
- 🕐 **SQL执行时间**：哪些查询最慢
- 🔒 **锁等待情况**：哪里发生了阻塞
- 💾 **内存使用**：内存分配和释放
- 💿 **磁盘IO**：读写操作的性能
- 🔗 **连接状态**：客户端连接情况

---

## 2. 🐌 慢查询分析案例


### 2.1 案例背景


某电商网站发现页面加载变慢，需要找出最耗时的SQL查询。

### 2.2 问题分析步骤


**步骤1：启用相关监控**
```sql
-- 确保events_statements_*表启用
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'events_statements_%';
```

**步骤2：查看最慢的SQL**
```sql
-- 查询平均执行时间最长的SQL
SELECT 
    SCHEMA_NAME as 数据库,
    DIGEST_TEXT as SQL语句,
    COUNT_STAR as 执行次数,
    ROUND(AVG_TIMER_WAIT/1000000000000, 2) as 平均耗时_秒,
    ROUND(MAX_TIMER_WAIT/1000000000000, 2) as 最长耗时_秒
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;
```

### 2.3 案例结果分析


**查询结果示例**：
```
数据库    | SQL语句                        | 执行次数 | 平均耗时_秒 | 最长耗时_秒
---------|--------------------------------|----------|-------------|-------------
shop     | SELECT * FROM orders WHERE ... | 1250     | 3.45        | 8.92
shop     | SELECT COUNT(*) FROM products  | 890      | 2.18        | 5.67
```

**问题诊断**：
- `orders`表的查询平均耗时3.45秒，明显过慢
- 可能原因：缺少索引、数据量过大、查询条件不当

**优化建议**：
```sql
-- 添加合适的索引
ALTER TABLE orders ADD INDEX idx_status_date (order_status, create_date);

-- 优化查询语句，避免SELECT *
SELECT order_id, user_id, total_amount 
FROM orders 
WHERE order_status = 'pending';
```

---

## 3. 🔒 锁等待分析案例


### 3.1 案例背景


系统在高并发时出现大量事务等待，用户反馈操作卡顿。

### 3.2 锁等待诊断


**查看当前锁等待情况**：
```sql
-- 查看正在等待的事务
SELECT 
    r.trx_id as 等待事务ID,
    r.trx_mysql_thread_id as 等待线程ID,
    r.trx_query as 等待的SQL,
    b.trx_id as 阻塞事务ID,
    b.trx_mysql_thread_id as 阻塞线程ID,
    b.trx_query as 阻塞的SQL
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id
JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id;
```

**查看锁等待历史数据**：
```sql
-- 分析锁等待的统计信息
SELECT 
    OBJECT_SCHEMA as 数据库,
    OBJECT_NAME as 表名,
    LOCK_TYPE as 锁类型,
    COUNT_STAR as 等待次数,
    ROUND(SUM_TIMER_WAIT/1000000000000, 2) as 总等待时间_秒,
    ROUND(AVG_TIMER_WAIT/1000000000000, 2) as 平均等待时间_秒
FROM performance_schema.events_waits_summary_by_instance
WHERE EVENT_NAME LIKE 'wait/lock%'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

### 3.3 锁等待解决方案


**常见锁等待场景及解决方案**：

```
场景1：大事务阻塞
问题：长时间不提交的事务占用锁
解决：缩短事务执行时间，及时提交

场景2：死锁频繁
问题：多个事务互相等待对方释放锁
解决：统一锁获取顺序，避免长事务

场景3：热点数据竞争
问题：多个事务同时修改相同数据
解决：业务层面排队，或使用乐观锁
```

**实用的锁等待处理脚本**：
```sql
-- 杀掉长时间运行的事务
SELECT CONCAT('KILL ', trx_mysql_thread_id, ';') as 杀死命令
FROM information_schema.innodb_trx 
WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) > 300;  -- 超过5分钟
```

---

## 4. 💾 内存使用分析案例


### 4.1 案例背景


服务器内存使用率持续上升，需要分析MySQL内存分配情况。

### 4.2 内存使用监控


**查看整体内存使用情况**：
```sql
-- 查看MySQL总内存使用
SELECT 
    EVENT_NAME as 内存类型,
    ROUND(SUM_NUMBER_OF_BYTES_ALLOC/1024/1024, 2) as 已分配_MB,
    ROUND(SUM_NUMBER_OF_BYTES_FREE/1024/1024, 2) as 已释放_MB,
    ROUND((SUM_NUMBER_OF_BYTES_ALLOC - SUM_NUMBER_OF_BYTES_FREE)/1024/1024, 2) as 当前使用_MB
FROM performance_schema.memory_summary_global_by_event_name
WHERE SUM_NUMBER_OF_BYTES_ALLOC > 0
ORDER BY (SUM_NUMBER_OF_BYTES_ALLOC - SUM_NUMBER_OF_BYTES_FREE) DESC
LIMIT 10;
```

**查看连接级别内存使用**：
```sql
-- 查看各连接的内存使用情况
SELECT 
    t.THREAD_ID as 线程ID,
    t.PROCESSLIST_USER as 用户,
    t.PROCESSLIST_HOST as 来源主机,
    ROUND(SUM(m.CURRENT_NUMBER_OF_BYTES_USED)/1024/1024, 2) as 当前内存_MB
FROM performance_schema.threads t
JOIN performance_schema.memory_summary_by_thread_by_event_name m 
    ON t.THREAD_ID = m.THREAD_ID
WHERE m.CURRENT_NUMBER_OF_BYTES_USED > 0
GROUP BY t.THREAD_ID
ORDER BY SUM(m.CURRENT_NUMBER_OF_BYTES_USED) DESC
LIMIT 10;
```

### 4.3 内存优化建议


**内存使用分析结果示例**：
```
内存类型                        | 当前使用_MB | 占比
-------------------------------|-------------|-----
memory/innodb/buf_buf_pool     | 2048.00     | 45%
memory/sql/TABLE_SHARE         | 512.30      | 11%
memory/sql/thd::main_mem_root  | 256.80      | 6%
```

**优化策略**：
```sql
-- 调整缓冲池大小（需要重启）
SET GLOBAL innodb_buffer_pool_size = 1073741824;  -- 1GB

-- 限制每个连接的内存使用
SET GLOBAL max_heap_table_size = 67108864;        -- 64MB

-- 清理不必要的表缓存
FLUSH TABLES;
```

---

## 5. 💿 IO瓶颈分析案例


### 5.1 案例背景


数据库响应缓慢，怀疑是磁盘IO成为瓶颈。

### 5.2 IO性能监控


**查看文件IO统计**：
```sql
-- 查看最耗时的文件IO操作
SELECT 
    OBJECT_SCHEMA as 数据库,
    OBJECT_NAME as 表名,
    COUNT_STAR as IO次数,
    ROUND(SUM_TIMER_WAIT/1000000000000, 2) as 总耗时_秒,
    ROUND(AVG_TIMER_WAIT/1000000000000, 6) as 平均耗时_秒,
    ROUND(SUM_NUMBER_OF_BYTES/1024/1024, 2) as 总数据量_MB
FROM performance_schema.file_summary_by_instance
WHERE OBJECT_SCHEMA IS NOT NULL
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

**查看表级别IO统计**：
```sql
-- 分析表的读写情况
SELECT 
    OBJECT_SCHEMA as 数据库,
    OBJECT_NAME as 表名,
    COUNT_READ as 读取次数,
    COUNT_WRITE as 写入次数,
    COUNT_FETCH as 获取次数,
    COUNT_INSERT as 插入次数,
    COUNT_UPDATE as 更新次数,
    COUNT_DELETE as 删除次数
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA NOT IN ('performance_schema', 'mysql', 'sys')
ORDER BY (COUNT_READ + COUNT_WRITE) DESC
LIMIT 10;
```

### 5.3 IO优化策略


**IO瓶颈的常见原因和解决方案**：

```
🔍 磁盘读取过多
原因：缺少索引，导致全表扫描
解决：添加适当索引，优化查询

📝 写入操作频繁  
原因：事务提交太频繁
解决：批量操作，调整事务大小

🗂️ 临时表使用
原因：复杂查询产生临时表
解决：优化SQL，增加内存临时表大小
```

**实用的IO优化配置**：
```sql
-- 增加InnoDB缓冲池，减少磁盘读取
SET GLOBAL innodb_buffer_pool_size = 2147483648;  -- 2GB

-- 调整日志缓冲区大小
SET GLOBAL innodb_log_buffer_size = 16777216;     -- 16MB

-- 优化刷新策略
SET GLOBAL innodb_flush_log_at_trx_commit = 2;
```

---

## 6. 🔗 连接问题分析案例


### 6.1 案例背景


应用程序偶尔出现"连接数过多"错误，需要分析连接使用情况。

### 6.2 连接状态监控


**查看当前连接情况**：
```sql
-- 查看活跃连接统计
SELECT 
    PROCESSLIST_USER as 用户,
    PROCESSLIST_HOST as 来源,
    PROCESSLIST_DB as 数据库,
    PROCESSLIST_COMMAND as 命令,
    PROCESSLIST_STATE as 状态,
    COUNT(*) as 连接数
FROM performance_schema.threads
WHERE TYPE = 'FOREGROUND'
GROUP BY PROCESSLIST_USER, PROCESSLIST_HOST, PROCESSLIST_COMMAND
ORDER BY COUNT(*) DESC;
```

**查看连接历史统计**：
```sql
-- 分析连接的创建和断开
SELECT 
    EVENT_NAME as 事件类型,
    COUNT_STAR as 发生次数,
    ROUND(SUM_TIMER_WAIT/1000000000000, 2) as 总耗时_秒,
    ROUND(AVG_TIMER_WAIT/1000000000000, 6) as 平均耗时_秒
FROM performance_schema.events_waits_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'wait/io/socket%'
ORDER BY COUNT_STAR DESC;
```

### 6.3 连接问题解决方案


**连接数过多的排查步骤**：

```
步骤1：检查最大连接数设置
SHOW VARIABLES LIKE 'max_connections';

步骤2：查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

步骤3：找出占用连接最多的用户/IP
步骤4：检查应用程序连接池配置
步骤5：优化长连接使用
```

**连接优化配置**：
```sql
-- 增加最大连接数（谨慎调整）
SET GLOBAL max_connections = 500;

-- 设置连接超时时间
SET GLOBAL wait_timeout = 600;          -- 10分钟
SET GLOBAL interactive_timeout = 600;   -- 10分钟

-- 快速回收无用连接
SET GLOBAL connect_timeout = 10;        -- 连接超时10秒
```

---

## 7. 🔄 复制监控案例


### 7.1 案例背景


主从复制环境中，从库延迟严重，需要监控复制状态。

### 7.2 复制状态监控


**查看复制延迟情况**：
```sql
-- 检查复制延迟（在从库执行）
SELECT 
    CHANNEL_NAME as 复制通道,
    SERVICE_STATE as 服务状态,
    LAST_ERROR_MESSAGE as 最后错误,
    LAST_ERROR_TIMESTAMP as 错误时间,
    RECEIVED_TRANSACTION_SET as 已接收事务
FROM performance_schema.replication_connection_status;
```

**监控复制IO和SQL线程**：
```sql
-- 查看复制线程状态
SELECT 
    THREAD_NAME as 线程名称,
    THREAD_TYPE as 线程类型,
    PROCESSLIST_STATE as 当前状态,
    PROCESSLIST_INFO as 执行信息
FROM performance_schema.threads
WHERE THREAD_NAME LIKE 'thread/sql/slave%';
```

### 7.3 复制优化建议


**复制延迟的常见原因**：

```
🐌 网络延迟
解决：优化网络，使用更快的网络连接

💾 磁盘IO瓶颈
解决：使用SSD，优化磁盘配置

🔄 单线程复制
解决：启用并行复制（MySQL 5.6+）

📊 大事务阻塞
解决：拆分大事务，避免长时间事务
```

**并行复制配置示例**：
```sql
-- 启用并行复制（在从库配置）
SET GLOBAL slave_parallel_type = 'LOGICAL_CLOCK';
SET GLOBAL slave_parallel_workers = 4;
SET GLOBAL slave_preserve_commit_order = ON;

-- 重启复制使配置生效
STOP SLAVE;
START SLAVE;
```

---

## 8. 🚨 故障诊断案例


### 8.1 案例背景


数据库突然出现大量连接超时，需要快速定位问题。

### 8.2 故障排查流程


**快速诊断脚本**：
```sql
-- 一键检查系统健康状况
SELECT '=== 当前连接情况 ===' as 检查项目;
SELECT 
    PROCESSLIST_COMMAND as 命令类型,
    COUNT(*) as 数量
FROM performance_schema.threads
WHERE TYPE = 'FOREGROUND'
GROUP BY PROCESSLIST_COMMAND;

SELECT '=== 锁等待情况 ===' as 检查项目;
SELECT COUNT(*) as 等待锁的事务数
FROM information_schema.innodb_trx 
WHERE trx_state = 'LOCK WAIT';

SELECT '=== 最耗时SQL ===' as 检查项目;
SELECT 
    LEFT(DIGEST_TEXT, 50) as SQL片段,
    COUNT_STAR as 执行次数,
    ROUND(AVG_TIMER_WAIT/1000000000000, 2) as 平均耗时_秒
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 5;
```

### 8.3 故障处理预案


**应急处理步骤**：

```
🚨 第一步：确认故障范围
- 检查数据库是否可连接
- 确认影响的应用程序

🔍 第二步：快速定位问题
- 查看错误日志
- 检查系统资源使用
- 运行诊断脚本

⚡ 第三步：临时缓解措施
- 杀掉异常连接
- 释放锁等待
- 重启相关服务

🛠️ 第四步：根本原因分析
- 分析Performance Schema数据
- 回顾最近的变更
- 制定长期解决方案
```

---

## 9. ⚡ 性能调优案例


### 9.1 综合性能分析


**系统整体性能评估**：
```sql
-- 性能综合评分脚本
SELECT 
    '查询性能' as 指标,
    CASE 
        WHEN avg_time <= 0.1 THEN '优秀'
        WHEN avg_time <= 0.5 THEN '良好'  
        WHEN avg_time <= 1.0 THEN '一般'
        ELSE '需要优化'
    END as 评级,
    CONCAT(ROUND(avg_time, 3), '秒') as 平均响应时间
FROM (
    SELECT AVG(AVG_TIMER_WAIT/1000000000000) as avg_time
    FROM performance_schema.events_statements_summary_by_digest
    WHERE DIGEST_TEXT IS NOT NULL
) t

UNION ALL

SELECT 
    '锁竞争' as 指标,
    CASE 
        WHEN lock_ratio <= 0.01 THEN '优秀'
        WHEN lock_ratio <= 0.05 THEN '良好'
        WHEN lock_ratio <= 0.1 THEN '一般'
        ELSE '需要优化'
    END as 评级,
    CONCAT(ROUND(lock_ratio * 100, 2), '%') as 锁等待比例
FROM (
    SELECT 
        IFNULL(SUM(COUNT_STAR_WAIT) / SUM(COUNT_STAR), 0) as lock_ratio
    FROM performance_schema.events_waits_summary_global_by_event_name
    WHERE EVENT_NAME LIKE 'wait/synch%'
) t;
```

### 9.2 调优建议生成器


**基于监控数据的自动建议**：
```sql
-- 自动生成优化建议
SELECT 
    '索引优化' as 优化类型,
    CONCAT('表 ', table_schema, '.', table_name, ' 可能需要添加索引') as 建议,
    CONCAT('全表扫描次数: ', rows_examined, ', 返回行数: ', rows_sent) as 依据
FROM (
    SELECT 
        table_schema,
        table_name,
        SUM(rows_examined) as rows_examined,
        SUM(rows_sent) as rows_sent
    FROM performance_schema.events_statements_history_long h
    JOIN performance_schema.events_statements_current c USING(thread_id)
    WHERE table_schema NOT IN ('mysql', 'performance_schema', 'sys')
      AND rows_examined > rows_sent * 10  -- 扫描行数是返回行数的10倍以上
    GROUP BY table_schema, table_name
    HAVING rows_examined > 10000
) t
LIMIT 5;
```

### 9.3 性能监控仪表板


**创建监控视图**：
```sql
-- 创建性能监控视图
CREATE OR REPLACE VIEW performance_dashboard AS
SELECT 
    '当前QPS' as 指标,
    ROUND(COUNT(*)/60, 2) as 数值,
    '次/秒' as 单位
FROM performance_schema.events_statements_history
WHERE timer_start > (SELECT MAX(timer_start) - 60000000000000 FROM performance_schema.events_statements_history)

UNION ALL

SELECT 
    '平均响应时间' as 指标,
    ROUND(AVG(timer_wait/1000000000000), 3) as 数值,
    '秒' as 单位
FROM performance_schema.events_statements_history
WHERE timer_start > (SELECT MAX(timer_start) - 60000000000000 FROM performance_schema.events_statements_history)

UNION ALL

SELECT 
    '活跃连接数' as 指标,
    COUNT(*) as 数值,
    '个' as 单位
FROM performance_schema.threads
WHERE type = 'FOREGROUND' AND processlist_command != 'Sleep';

-- 使用监控视图
SELECT * FROM performance_dashboard;
```

---

## 10. 📋 核心要点总结


### 10.1 Performance Schema使用要点


**🔸 启用监控的原则**
```
按需启用：只启用需要的监控项，避免性能开销
分时段监控：在业务低峰期进行详细监控
保留历史：定期备份重要的性能数据
```

**🔸 常用的监控表**
```sql
-- SQL性能监控
events_statements_summary_by_digest          -- SQL摘要统计
events_statements_history_long               -- SQL执行历史

-- 锁等待监控  
events_waits_summary_by_instance            -- 等待事件统计
innodb_trx                                  -- 当前事务信息

-- 内存监控
memory_summary_global_by_event_name         -- 全局内存统计
memory_summary_by_thread_by_event_name      -- 线程内存统计

-- IO监控
file_summary_by_instance                    -- 文件IO统计
table_io_waits_summary_by_table            -- 表IO统计
```

### 10.2 性能分析的最佳实践


**🎯 分析步骤**
```
1. 确定问题范围：是整体慢还是特定查询慢
2. 收集基础数据：CPU、内存、磁盘、网络使用率
3. 分析Performance Schema：找到具体的性能瓶颈
4. 制定优化方案：索引、配置、架构等多个层面
5. 验证优化效果：对比优化前后的性能指标
```

**⚠️ 注意事项**
```
避免过度监控：过多的监控会影响性能
及时清理数据：定期清理历史监控数据
结合业务场景：性能优化要考虑业务特点
持续监控：建立长期的性能监控机制
```

### 10.3 实用的性能优化清单


**📋 日常检查项目**
- [ ] 慢查询日志分析
- [ ] 索引使用情况检查  
- [ ] 锁等待时间监控
- [ ] 内存使用率跟踪
- [ ] 连接数变化趋势
- [ ] 复制延迟监控（主从环境）

**🔧 常用优化手段**
```
SQL层面：添加索引、优化查询、避免全表扫描
配置层面：调整缓冲区、连接数、超时时间
架构层面：读写分离、分库分表、缓存策略
硬件层面：升级CPU、内存、使用SSD
```

**🧠 核心记忆要点**
- Performance Schema是MySQL的"体检报告"
- 慢查询分析看`events_statements_summary_by_digest`
- 锁等待问题查`innodb_trx`和等待事件表
- 内存分析用`memory_summary_*`系列表
- IO瓶颈看`file_summary_by_instance`
- 连接问题检查`threads`表和连接配置
- 故障诊断要快速定位，分步骤处理
- 性能优化是个持续过程，需要定期监控

> 💡 **实践建议**  
> Performance Schema虽然功能强大，但要记住"工具是死的，人是活的"。关键是要结合具体的业务场景，选择合适的监控指标，制定有针对性的优化策略。不要为了优化而优化，而要为了解决实际问题而优化。