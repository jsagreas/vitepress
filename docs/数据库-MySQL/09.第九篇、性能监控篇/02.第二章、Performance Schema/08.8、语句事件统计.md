---
title: 8、语句事件统计
---
## 📚 目录

1. [语句事件统计概述](#1-语句事件统计概述)
2. [核心统计表详解](#2-核心统计表详解)
3. [语句执行分析](#3-语句执行分析)
4. [性能问题诊断](#4-性能问题诊断)
5. [优化实践指南](#5-优化实践指南)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📊 语句事件统计概述


### 1.1 什么是语句事件统计


**简单理解**：就像给每条SQL语句做体检，记录它们的"健康状况"

```
语句事件统计 = SQL语句的执行档案
包含内容：
• 执行了多少次
• 每次花了多长时间  
• 消耗了多少资源
• 有没有出错
• 哪些语句最慢
```

**核心作用**：
- 🔍 **发现慢查询**：找出拖慢系统的SQL语句
- 📈 **统计执行频率**：看哪些语句用得最多
- 💾 **分析资源消耗**：了解SQL对系统的影响
- 🐛 **定位问题语句**：快速找到有问题的SQL

### 1.2 为什么需要语句统计


**实际问题场景**：
```
开发反馈：网站很慢，不知道哪里有问题
DBA困惑：系统负载高，但不知道哪些SQL在捣乱
运维头疼：用户投诉响应慢，需要快速定位原因
```

**语句统计的价值**：
```
问题定位：
传统方式 → 盲目猜测，大海捞针
统计方式 → 数据说话，精准定位

性能优化：
传统方式 → 凭经验优化，效果未知  
统计方式 → 基于数据，针对性优化

容量规划：
传统方式 → 拍脑袋决定硬件配置
统计方式 → 根据真实负载规划资源
```

---

## 2. 🗃️ 核心统计表详解


### 2.1 events_statements_current表


**作用**：记录当前正在执行的SQL语句

```sql
-- 查看当前执行的语句
SELECT 
    thread_id,
    event_name,
    sql_text,
    timer_start,
    timer_end,
    timer_wait/1000000000000 as exec_time_sec
FROM performance_schema.events_statements_current
WHERE sql_text IS NOT NULL;
```

**重要字段说明**：
```
thread_id        → 线程ID（哪个连接在执行）
sql_text         → 具体的SQL语句内容
timer_wait       → 执行耗时（纳秒）
rows_examined    → 扫描的行数
rows_sent        → 返回的行数
errors           → 错误次数
warnings         → 警告次数
```

### 2.2 events_statements_history表


**作用**：记录每个连接最近执行的SQL语句历史

```sql
-- 查看某个连接的SQL执行历史
SELECT 
    sql_text,
    timer_wait/1000000000000 as exec_time_sec,
    rows_examined,
    rows_sent,
    created_tmp_tables,
    created_tmp_disk_tables
FROM performance_schema.events_statements_history 
WHERE thread_id = 123  -- 指定线程ID
ORDER BY event_id DESC 
LIMIT 10;
```

**适用场景**：
- 追踪特定用户的SQL执行情况
- 分析问题发生前后的SQL执行轨迹
- 调试应用程序的数据库访问模式

### 2.3 events_statements_summary_by_digest表


**作用**：按SQL模式汇总统计（最重要的表）

```sql
-- 查找最耗时的SQL模式
SELECT 
    schema_name,
    LEFT(digest_text, 100) as sql_pattern,
    count_star as exec_count,
    avg_timer_wait/1000000000000 as avg_time_sec,
    max_timer_wait/1000000000000 as max_time_sec,
    sum_timer_wait/1000000000000 as total_time_sec
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY sum_timer_wait DESC 
LIMIT 10;
```

**核心指标解释**：
```
count_star       → 执行次数
avg_timer_wait   → 平均执行时间
max_timer_wait   → 最大执行时间  
sum_timer_wait   → 总执行时间
sum_rows_examined → 总扫描行数
sum_created_tmp_disk_tables → 创建磁盘临时表次数
```

### 2.4 语句统计的分类维度


**按不同维度分类的统计表**：
```
按用户统计：
events_statements_summary_by_account_by_event_name
→ 看每个用户执行了哪些类型的语句

按主机统计：  
events_statements_summary_by_host_by_event_name
→ 看每个主机的SQL执行情况

按程序统计：
events_statements_summary_by_program
→ 看每个应用程序的SQL使用情况
```

---

## 3. 🔍 语句执行分析


### 3.1 执行时间分析


**找出最慢的SQL模式**：
```sql
-- 按平均执行时间排序
SELECT 
    schema_name,
    LEFT(digest_text, 120) as sql_pattern,
    count_star as times,
    ROUND(avg_timer_wait/1000000000000, 3) as avg_sec,
    ROUND(max_timer_wait/1000000000000, 3) as max_sec,
    ROUND(sum_timer_wait/1000000000000, 3) as total_sec
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait > 1000000000000  -- 大于1秒的
ORDER BY avg_timer_wait DESC 
LIMIT 20;
```

**执行频率分析**：
```sql
-- 找出执行最频繁的SQL
SELECT 
    schema_name,
    LEFT(digest_text, 100) as sql_pattern,
    count_star as exec_times,
    ROUND(sum_timer_wait/1000000000000, 2) as total_sec,
    ROUND(avg_timer_wait/1000000000000, 4) as avg_sec
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY count_star DESC 
LIMIT 15;
```

### 3.2 资源消耗分析


**磁盘临时表分析**：
```sql
-- 找出创建磁盘临时表最多的SQL
SELECT 
    LEFT(digest_text, 100) as sql_pattern,
    count_star,
    sum_created_tmp_disk_tables,
    ROUND(sum_created_tmp_disk_tables/count_star, 2) as avg_tmp_tables
FROM performance_schema.events_statements_summary_by_digest 
WHERE sum_created_tmp_disk_tables > 0
ORDER BY sum_created_tmp_disk_tables DESC 
LIMIT 10;
```

**扫描行数分析**：
```sql
-- 分析扫描效率
SELECT 
    LEFT(digest_text, 100) as sql_pattern,
    count_star,
    sum_rows_examined,
    sum_rows_sent,
    ROUND(sum_rows_examined/sum_rows_sent, 2) as scan_efficiency
FROM performance_schema.events_statements_summary_by_digest 
WHERE sum_rows_sent > 0
ORDER BY sum_rows_examined DESC 
LIMIT 10;
```

### 3.3 错误和警告统计


**错误语句统计**：
```sql
-- 查找出错的SQL
SELECT 
    LEFT(digest_text, 100) as sql_pattern,
    count_star,
    sum_errors,
    sum_warnings,
    ROUND(sum_errors/count_star*100, 2) as error_rate
FROM performance_schema.events_statements_summary_by_digest 
WHERE sum_errors > 0
ORDER BY sum_errors DESC;
```

---

## 4. 🚨 性能问题诊断


### 4.1 慢查询识别


**识别慢查询的标准**：
```
时间维度：
• 平均执行时间 > 1秒
• 最大执行时间 > 10秒
• 总执行时间占比高

资源维度：
• 扫描行数/返回行数比例 > 1000
• 创建磁盘临时表
• 使用文件排序频繁
```

**慢查询诊断SQL**：
```sql
-- 综合慢查询诊断
SELECT 
    schema_name,
    LEFT(digest_text, 150) as sql_pattern,
    count_star as exec_count,
    ROUND(avg_timer_wait/1000000000000, 3) as avg_time,
    ROUND(max_timer_wait/1000000000000, 3) as max_time,
    sum_rows_examined,
    sum_rows_sent,
    sum_created_tmp_disk_tables,
    sum_sort_rows,
    -- 性能评分
    CASE 
        WHEN avg_timer_wait > 10000000000000 THEN '严重慢查询'
        WHEN avg_timer_wait > 1000000000000 THEN '中等慢查询'
        WHEN sum_rows_examined/NULLIF(sum_rows_sent,0) > 1000 THEN '扫描效率低'
        WHEN sum_created_tmp_disk_tables > 0 THEN '磁盘临时表'
        ELSE '正常'
    END as performance_level
FROM performance_schema.events_statements_summary_by_digest 
WHERE count_star > 10  -- 执行次数大于10
ORDER BY avg_timer_wait DESC;
```

### 4.2 资源消耗热点


**CPU消耗分析**：
```sql
-- 找出CPU消耗最大的SQL
SELECT 
    LEFT(digest_text, 100) as sql_pattern,
    count_star,
    ROUND(sum_timer_wait/1000000000000, 2) as total_cpu_sec,
    ROUND(avg_timer_wait/1000000000000, 4) as avg_cpu_sec,
    -- CPU占比（需要结合总CPU时间计算）
    ROUND(sum_timer_wait/(SELECT SUM(sum_timer_wait) 
                         FROM performance_schema.events_statements_summary_by_digest)*100, 2) as cpu_percent
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY sum_timer_wait DESC 
LIMIT 10;
```

### 4.3 用户行为分析


**按用户分析SQL使用**：
```sql
-- 用户SQL执行统计
SELECT 
    user,
    host,
    event_name,
    count_star,
    ROUND(sum_timer_wait/1000000000000, 2) as total_time_sec
FROM performance_schema.events_statements_summary_by_account_by_event_name 
WHERE user IS NOT NULL 
  AND user != 'root'
ORDER BY sum_timer_wait DESC;
```

---

## 5. 🛠️ 优化实践指南


### 5.1 基于统计数据的优化策略


**优化优先级矩阵**：
```
高优先级：
1. 执行频繁 + 单次耗时长 → 立即优化
2. 执行频繁 + 资源消耗大 → 优先优化

中优先级：  
3. 执行不频繁 + 单次耗时很长 → 考虑优化
4. 扫描效率低 + 有一定频率 → 添加索引

低优先级：
5. 偶尔执行 + 耗时一般 → 暂时忽略
```

**优化决策SQL**：
```sql
-- 优化优先级评估
SELECT 
    LEFT(digest_text, 120) as sql_pattern,
    count_star as frequency,
    ROUND(avg_timer_wait/1000000000000, 3) as avg_time,
    ROUND(sum_timer_wait/1000000000000, 2) as total_impact,
    sum_rows_examined,
    sum_rows_sent,
    -- 优化建议
    CASE 
        WHEN count_star > 1000 AND avg_timer_wait > 1000000000000 THEN '紧急优化'
        WHEN count_star > 100 AND avg_timer_wait > 5000000000000 THEN '高优先级'
        WHEN sum_rows_examined/NULLIF(sum_rows_sent,0) > 100 THEN '需要索引'
        WHEN sum_created_tmp_disk_tables > count_star * 0.1 THEN '优化临时表'
        ELSE '正常'
    END as optimization_advice
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY (count_star * avg_timer_wait) DESC;
```

### 5.2 监控脚本示例


**日常监控脚本**：
```sql
-- 创建性能监控视图
CREATE OR REPLACE VIEW v_slow_statements AS
SELECT 
    schema_name,
    LEFT(digest_text, 200) as sql_text,
    count_star as exec_count,
    ROUND(avg_timer_wait/1000000000000, 3) as avg_seconds,
    ROUND(max_timer_wait/1000000000000, 3) as max_seconds,
    ROUND(sum_timer_wait/1000000000000, 2) as total_seconds,
    sum_rows_examined as total_rows_scanned,
    sum_rows_sent as total_rows_returned,
    sum_created_tmp_disk_tables as disk_tmp_tables,
    first_seen,
    last_seen
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait > 1000000000000  -- 大于1秒
   OR sum_created_tmp_disk_tables > 0  -- 或创建了磁盘临时表
ORDER BY sum_timer_wait DESC;
```

### 5.3 清理和重置统计


**重置统计数据**：
```sql
-- 清理语句统计（谨慎使用）
CALL sys.ps_truncate_all_tables(FALSE);

-- 或者只清理语句相关统计
TRUNCATE performance_schema.events_statements_summary_by_digest;
TRUNCATE performance_schema.events_statements_summary_by_account_by_event_name;
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 语句统计本质：记录每条SQL的执行情况，提供优化依据
🔸 核心统计表：current（当前）、history（历史）、summary（汇总）  
🔸 关键指标：执行次数、执行时间、扫描行数、资源消耗
🔸 优化目标：找出慢查询、高频查询、资源消耗大的查询
🔸 实践价值：数据驱动的性能优化，而非盲目猜测
```

### 6.2 关键理解要点


**🔹 统计表的选择原则**
```
实时监控 → 使用 current 表
问题追踪 → 使用 history 表  
性能分析 → 使用 summary_by_digest 表
用户分析 → 使用 by_account 相关表
```

**🔹 性能问题识别技巧**
```
看执行时间：平均时间长 = 需要优化
看执行频率：高频执行 = 影响大
看扫描效率：扫描多返回少 = 缺索引
看临时表：磁盘临时表 = 内存不够或需优化
```

**🔹 优化策略选择**
```
高频+慢查询 → 立即优化SQL和索引
低频+极慢 → 检查是否必要，考虑异步处理
扫描效率低 → 添加合适索引
临时表多 → 增加内存或优化查询
```

### 6.3 实际应用价值


- **故障排查**：快速定位性能问题的根源SQL
- **容量规划**：基于真实负载数据规划硬件资源  
- **代码审查**：发现开发中的SQL性能问题
- **监控告警**：建立基于统计数据的性能监控体系
- **优化验证**：优化前后的效果对比分析

**核心记忆**：
- 语句统计是MySQL性能优化的数据基础
- 重点关注高频查询和慢查询的组合影响
- 统计数据要结合业务场景进行分析
- 定期清理统计数据，保持监控的时效性