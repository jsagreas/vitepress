---
title: 5、执行计划优化策略
---
## 📚 目录

1. [执行计划优化基础概念](#1-执行计划优化基础概念)
2. [驱动表选择策略](#2-驱动表选择策略)
3. [连接顺序优化技术](#3-连接顺序优化技术)
4. [索引选择优化方法](#4-索引选择优化方法)
5. [条件下推优化策略](#5-条件下推优化策略)
6. [子查询优化技术](#6-子查询优化技术)
7. [临时表避免策略](#7-临时表避免策略)
8. [排序优化策略](#8-排序优化策略)
9. [分组优化技术](#9-分组优化技术)
10. [联合查询优化](#10-联合查询优化)
11. [执行计划固定与优化器提示](#11-执行计划固定与优化器提示)
12. [核心要点总结](#12-核心要点总结)

---

## 1. 🎯 执行计划优化基础概念


### 1.1 什么是执行计划优化


**🔸 执行计划优化的本质**
```
执行计划优化就像"制定最佳路线图"
目标：让数据库以最高效的方式执行SQL查询
方法：选择最优的表访问顺序、连接方式、索引使用
结果：减少IO操作、降低CPU消耗、提升查询速度
```

**💡 执行计划优化的核心思想**
```
优化器的工作原理：
1. 分析SQL语句的结构和条件
2. 评估可用的索引和访问路径
3. 计算不同执行方案的成本
4. 选择预估成本最低的执行计划

优化的本质：
- 减少数据扫描量：优先使用索引而非全表扫描
- 优化连接顺序：小表驱动大表，减少连接次数
- 避免临时操作：减少临时表、文件排序等开销
- 提前过滤数据：尽早应用WHERE条件
```

### 1.2 执行计划优化的关键指标


**📊 性能评估指标**
```
执行成本指标：
• 扫描行数（rows）：越少越好
• 过滤百分比（filtered）：越高越好
• 访问类型（type）：const > eq_ref > ref > range > index > ALL
• 额外信息（Extra）：Using index最佳，Using filesort需优化

时间指标：
• 执行时间：总耗时
• 锁等待时间：锁竞争导致的等待
• IO等待时间：磁盘读写等待

资源消耗：
• 内存使用量：临时表、排序缓冲区
• CPU使用率：复杂计算的处理
• 网络传输量：结果集大小
```

### 1.3 优化策略分类


**🔧 优化策略层次**
```
物理优化（数据库层面）：
• 索引设计：创建合适的索引
• 表结构优化：字段类型、分区等
• 存储引擎选择：InnoDB vs MyISAM

逻辑优化（SQL层面）：
• 查询重写：子查询转连接
• 条件优化：条件下推、谓词转换
• 连接优化：连接顺序、连接算法

算法优化（执行层面）：
• 连接算法：Nested Loop、Hash Join
• 排序算法：内存排序、外部排序
• 聚合算法：基于索引、基于临时表
```

---

## 2. 🚗 驱动表选择策略


### 2.1 驱动表选择原理


**🔸 什么是驱动表**
```
驱动表就像"导航的起点"
定义：在多表连接中，第一个被访问的表
作用：决定整个连接过程的效率
原则：用小表驱动大表，减少连接次数

连接过程模拟：
A表(1000行) JOIN B表(10000行)
- A驱动B：1000次查找B表索引
- B驱动A：10000次查找A表索引
显然A驱动B更高效！
```

**💻 驱动表选择示例**
```sql
-- 创建测试表
CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50), dept_id INT);
CREATE TABLE departments (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE orders (id INT PRIMARY KEY, user_id INT, amount DECIMAL(10,2));

-- 插入数据：users(1000行)，departments(10行)，orders(10000行)

-- 案例1：小表驱动大表（推荐）
EXPLAIN 
SELECT u.name, d.name as dept_name
FROM departments d  -- 小表(10行)作为驱动表
JOIN users u ON d.id = u.dept_id  -- 大表(1000行)
WHERE d.name = '技术部';

-- 案例2：大表驱动小表（不推荐）
EXPLAIN 
SELECT u.name, d.name as dept_name  
FROM users u  -- 大表(1000行)作为驱动表
JOIN departments d ON u.dept_id = d.id  -- 小表(10行)
WHERE d.name = '技术部';
```

### 2.2 MySQL驱动表选择机制


**🧠 优化器的驱动表选择逻辑**
```sql
-- MySQL自动选择驱动表的因素
SELECT u.name, o.amount
FROM users u 
JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 1;

-- 分析执行计划
EXPLAIN FORMAT=JSON
SELECT u.name, o.amount
FROM users u 
JOIN orders o ON u.id = o.user_id  
WHERE u.dept_id = 1;

/*
MySQL考虑的因素：
1. WHERE条件的选择性：u.dept_id = 1 过滤了多少数据
2. 可用索引：是否有u.dept_id和o.user_id的索引
3. 表的统计信息：每个表的估算行数
4. 连接条件：等值连接的效率
*/
```

### 2.3 强制指定驱动表


**🎯 使用STRAIGHT_JOIN强制驱动顺序**
```sql
-- 强制指定连接顺序
SELECT STRAIGHT_JOIN u.name, d.name
FROM departments d  -- 强制d作为驱动表
JOIN users u ON d.id = u.dept_id
WHERE d.name = '技术部';

-- 对比自然连接顺序
SELECT u.name, d.name
FROM departments d 
JOIN users u ON d.id = u.dept_id
WHERE d.name = '技术部';

-- 使用优化器提示（MySQL 8.0+）
SELECT /*+ JOIN_ORDER(d, u) */ u.name, d.name
FROM departments d
JOIN users u ON d.id = u.dept_id  
WHERE d.name = '技术部';
```

### 2.4 驱动表选择最佳实践


**📋 驱动表选择指导原则**
```
选择驱动表的黄金法则：

1. 结果集大小原则：
   ✅ 小结果集驱动大结果集
   ❌ 大结果集驱动小结果集

2. 索引覆盖原则：
   ✅ 有索引的表驱动无索引的表
   ✅ 覆盖索引优于普通索引

3. 过滤条件原则：
   ✅ 有WHERE条件的表作为驱动表
   ✅ 选择性高的条件优先

4. 连接类型原则：
   ✅ 等值连接优于范围连接
   ✅ 内连接优于外连接

实际案例分析：
表A(100万行) JOIN 表B(1000行) WHERE A.status = 'active'
- 如果A.status = 'active'过滤后只剩1万行 → A驱动B
- 如果A.status = 'active'过滤后还有50万行 → B驱动A
```

---

## 3. 🔗 连接顺序优化技术


### 3.1 连接顺序的影响


**🔸 连接顺序对性能的影响**
```
多表连接的执行顺序直接影响性能
原理：每一步连接的中间结果影响下一步的效率
目标：让每步连接的结果集尽可能小

三表连接示例：
A(1000行) JOIN B(5000行) JOIN C(10000行)

顺序1：A → B → C
第一步：A JOIN B = 中间结果1(可能很大)
第二步：中间结果1 JOIN C = 最终结果

顺序2：B → C → A  
第一步：B JOIN C = 中间结果2(可能更大)
第二步：中间结果2 JOIN A = 最终结果

最优顺序需要综合考虑过滤条件和索引
```

**💻 连接顺序分析示例**
```sql
-- 三表连接查询
SELECT u.name, d.name as dept, o.amount
FROM users u
JOIN departments d ON u.dept_id = d.id  
JOIN orders o ON u.id = o.user_id
WHERE d.name = '销售部' 
  AND o.amount > 1000
  AND u.status = 'active';

-- 分析不同连接顺序的效果
-- 方案1：departments → users → orders
EXPLAIN 
SELECT u.name, d.name as dept, o.amount
FROM departments d
JOIN users u ON d.id = u.dept_id
JOIN orders o ON u.id = o.user_id  
WHERE d.name = '销售部' 
  AND o.amount > 1000
  AND u.status = 'active';

-- 方案2：users → departments → orders  
EXPLAIN
SELECT u.name, d.name as dept, o.amount
FROM users u
JOIN departments d ON u.dept_id = d.id
JOIN orders o ON u.id = o.user_id
WHERE d.name = '销售部'
  AND o.amount > 1000 
  AND u.status = 'active';
```

### 3.2 MySQL连接算法


**⚙️ 连接算法类型**
```sql
-- Nested Loop Join（嵌套循环连接）
-- 适用：小表驱动大表，被驱动表有索引
SELECT u.name, o.amount
FROM users u  -- 驱动表
JOIN orders o ON u.id = o.user_id  -- 被驱动表(有索引)
WHERE u.dept_id = 1;

-- Block Nested Loop Join（块嵌套循环）
-- 适用：被驱动表无合适索引时
SELECT u.name, o.amount  
FROM users u
JOIN orders o ON u.dept_id = o.department_id  -- 无索引连接
WHERE u.status = 'active';

-- Hash Join（MySQL 8.0.18+）
-- 适用：等值连接，内存充足
SELECT /*+ HASH_JOIN(u, o) */ u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id;
```

### 3.3 连接顺序优化策略


**🎯 优化连接顺序的方法**
```sql
-- 策略1：WHERE条件过滤优先
SELECT u.name, d.name, o.amount
FROM departments d  -- 先过滤部门
JOIN users u ON d.id = u.dept_id
JOIN orders o ON u.id = o.user_id
WHERE d.name IN ('技术部', '销售部')  -- 高选择性条件
  AND o.created_at >= '2025-01-01';

-- 策略2：索引覆盖优先
SELECT u.id, u.name, o.amount
FROM users u  -- 有复合索引(dept_id, status)
JOIN orders o ON u.id = o.user_id  -- 有索引user_id
WHERE u.dept_id = 1 AND u.status = 'active';

-- 策略3：使用子查询预过滤
SELECT u.name, d.name, o.amount
FROM (
  SELECT id, name FROM users 
  WHERE dept_id = 1 AND status = 'active'
) u
JOIN departments d ON u.dept_id = d.id
JOIN orders o ON u.id = o.user_id
WHERE o.amount > 1000;
```

---

## 4. 📇 索引选择优化方法


### 4.1 索引选择原理


**🔸 索引选择的重要性**
```
索引选择就像"选择最佳工具"
目标：为每个查询条件选择最合适的索引
原则：选择性高、覆盖度好、维护成本低的索引
影响：直接决定查询是否需要回表、扫描行数多少

MySQL索引选择过程：
1. 分析WHERE条件和JOIN条件
2. 找出可用的索引
3. 估算每个索引的选择性
4. 计算使用不同索引的成本
5. 选择成本最低的索引
```

**💻 索引选择示例**
```sql
-- 创建多个索引的表
CREATE TABLE products (
  id INT PRIMARY KEY,
  category_id INT,
  brand_id INT, 
  price DECIMAL(10,2),
  status VARCHAR(20),
  created_at TIMESTAMP,
  
  INDEX idx_category (category_id),
  INDEX idx_brand (brand_id),
  INDEX idx_price (price),
  INDEX idx_status (status),
  INDEX idx_created (created_at),
  INDEX idx_category_brand (category_id, brand_id),
  INDEX idx_category_price (category_id, price)
);

-- 分析索引选择
EXPLAIN 
SELECT * FROM products 
WHERE category_id = 5 AND brand_id = 10;
-- 可能使用：idx_category, idx_brand, idx_category_brand

EXPLAIN
SELECT * FROM products
WHERE category_id = 5 AND price BETWEEN 100 AND 500;
-- 最优：idx_category_price
```

### 4.2 强制索引使用


**🎯 索引提示语法**
```sql
-- USE INDEX：建议使用指定索引
SELECT * FROM products 
USE INDEX (idx_category_brand)
WHERE category_id = 5 AND brand_id = 10;

-- FORCE INDEX：强制使用指定索引
SELECT * FROM products
FORCE INDEX (idx_category)  
WHERE category_id = 5 AND price > 100;

-- IGNORE INDEX：忽略指定索引
SELECT * FROM products
IGNORE INDEX (idx_category)
WHERE category_id = 5;

-- 多个索引提示
SELECT * FROM products
USE INDEX FOR JOIN (idx_category_brand)
USE INDEX FOR ORDER BY (idx_created)
WHERE category_id = 5 
ORDER BY created_at;
```

### 4.3 索引选择优化技巧


**⚡ 索引优化策略**
```sql
-- 技巧1：复合索引的最左前缀
-- 索引：(category_id, brand_id, price)
SELECT * FROM products WHERE category_id = 5;  -- 使用索引
SELECT * FROM products WHERE category_id = 5 AND brand_id = 10;  -- 使用索引
SELECT * FROM products WHERE brand_id = 10;  -- 不能使用索引

-- 技巧2：覆盖索引避免回表
CREATE INDEX idx_covering ON products (category_id, brand_id, price, status);
SELECT category_id, brand_id, price, status 
FROM products 
WHERE category_id = 5;  -- 覆盖索引，无需回表

-- 技巧3：函数和表达式处理
-- 错误：在列上使用函数
SELECT * FROM products WHERE YEAR(created_at) = 2025;

-- 正确：在值上使用函数
SELECT * FROM products 
WHERE created_at >= '2025-01-01' 
  AND created_at < '2026-01-01';

-- 技巧4：NULL值处理
SELECT * FROM products WHERE status IS NOT NULL;  -- 可能不使用索引
SELECT * FROM products WHERE status != '';  -- 可能使用索引
```

---

## 5. ⬇️ 条件下推优化策略


### 5.1 条件下推的概念


**🔸 什么是条件下推**
```
条件下推就像"提前过安检"
概念：将WHERE条件尽早应用到数据访问过程中
目标：减少需要处理的数据量
原理：在数据源头就过滤掉不符合条件的数据

下推的好处：
• 减少IO操作：读取更少的数据页
• 降低内存消耗：减少中间结果集
• 提升网络效率：传输更少的数据
• 加快连接速度：连接更小的数据集
```

**💻 条件下推示例**
```sql
-- 子查询条件下推
-- 优化前：条件在外层查询
SELECT u.name, u.email
FROM (
  SELECT id, name, email, dept_id, status 
  FROM users
) u
WHERE u.dept_id = 5 AND u.status = 'active';

-- 优化后：条件下推到子查询
SELECT u.name, u.email  
FROM (
  SELECT id, name, email
  FROM users
  WHERE dept_id = 5 AND status = 'active'  -- 条件下推
) u;

-- 连接条件下推
-- 优化前：连接后过滤
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 5 AND o.status = 'completed';

-- 优化后：连接前过滤
SELECT u.name, o.amount
FROM (SELECT id, name FROM users WHERE dept_id = 5) u
JOIN (SELECT user_id, amount FROM orders WHERE status = 'completed') o 
ON u.id = o.user_id;
```

### 5.2 视图和派生表的条件下推


**📊 视图条件下推优化**
```sql
-- 创建视图
CREATE VIEW active_users AS
SELECT id, name, email, dept_id
FROM users 
WHERE status = 'active';

-- 查询视图时的条件下推
SELECT name, email
FROM active_users  
WHERE dept_id = 5;  -- 条件会下推到基表

-- 验证下推效果
EXPLAIN 
SELECT name, email FROM active_users WHERE dept_id = 5;
-- 实际执行：SELECT name, email FROM users WHERE status = 'active' AND dept_id = 5

-- 复杂视图的条件下推
CREATE VIEW user_order_summary AS
SELECT u.id, u.name, COUNT(o.id) as order_count, SUM(o.amount) as total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 查询时的条件处理
SELECT name, order_count 
FROM user_order_summary
WHERE order_count > 10;  -- 此条件无法下推，需要在GROUP BY后执行
```

### 5.3 分区表条件下推


**🗂️ 分区裁剪优化**
```sql
-- 按日期分区的表
CREATE TABLE sales_log (
  id INT AUTO_INCREMENT,
  sale_date DATE,
  amount DECIMAL(10,2),
  region VARCHAR(50),
  PRIMARY KEY (id, sale_date)
) PARTITION BY RANGE (YEAR(sale_date)) (
  PARTITION p2023 VALUES LESS THAN (2024),
  PARTITION p2024 VALUES LESS THAN (2025), 
  PARTITION p2025 VALUES LESS THAN (2026)
);

-- 条件下推实现分区裁剪
EXPLAIN PARTITIONS
SELECT region, SUM(amount)
FROM sales_log
WHERE sale_date >= '2025-01-01' 
  AND sale_date < '2025-12-31'  -- 条件下推，只扫描p2025分区
GROUP BY region;

-- 避免分区裁剪失效
-- 错误：使用函数导致无法分区裁剪
SELECT * FROM sales_log WHERE YEAR(sale_date) = 2025;

-- 正确：保持分区键的原始形式
SELECT * FROM sales_log 
WHERE sale_date >= '2025-01-01' AND sale_date < '2026-01-01';
```

---

## 6. 🔄 子查询优化技术


### 6.1 子查询类型与优化策略


**🔸 子查询分类及优化方向**
```
子查询类型：
1. 标量子查询：返回单个值
2. 行子查询：返回单行多列
3. 表子查询：返回多行多列
4. EXISTS子查询：返回布尔值

优化策略：
• 子查询转连接：提升执行效率
• 半连接优化：EXISTS/IN子查询
• 物化优化：缓存子查询结果
• 条件下推：减少子查询数据量
```

**💻 子查询转连接优化**
```sql
-- 标量子查询优化
-- 优化前：标量子查询
SELECT u.name, 
       (SELECT d.name FROM departments d WHERE d.id = u.dept_id) as dept_name
FROM users u
WHERE u.status = 'active';

-- 优化后：LEFT JOIN
SELECT u.name, d.name as dept_name
FROM users u
LEFT JOIN departments d ON u.dept_id = d.id
WHERE u.status = 'active';

-- IN子查询优化  
-- 优化前：IN子查询
SELECT name FROM users 
WHERE dept_id IN (
  SELECT id FROM departments WHERE region = '华北'
);

-- 优化后：EXISTS（性能更好）
SELECT u.name FROM users u
WHERE EXISTS (
  SELECT 1 FROM departments d 
  WHERE d.id = u.dept_id AND d.region = '华北'
);

-- 更优：直接连接
SELECT DISTINCT u.name 
FROM users u
JOIN departments d ON u.dept_id = d.id
WHERE d.region = '华北';
```

### 6.2 EXISTS vs IN 优化选择


**⚖️ EXISTS vs IN 性能对比**
```sql
-- 场景：大表查小表
-- users(100万行) vs departments(50行)

-- 方案1：EXISTS（推荐）
SELECT u.name FROM users u
WHERE EXISTS (
  SELECT 1 FROM departments d 
  WHERE d.id = u.dept_id AND d.region = '华北'
);

-- 方案2：IN
SELECT u.name FROM users u  
WHERE u.dept_id IN (
  SELECT id FROM departments WHERE region = '华北'
);

-- 场景：小表查大表
-- departments(50行) vs users(100万行)

-- 方案1：IN（推荐）
SELECT d.name FROM departments d
WHERE d.id IN (
  SELECT DISTINCT dept_id FROM users WHERE status = 'active'
);

-- 方案2：EXISTS
SELECT d.name FROM departments d
WHERE EXISTS (
  SELECT 1 FROM users u 
  WHERE u.dept_id = d.id AND u.status = 'active'
);

/*
选择原则：
• 外表小，内表大 → 用IN
• 外表大，内表小 → 用EXISTS  
• 内表有重复值 → 用EXISTS
• 需要去重 → 用EXISTS
*/
```

### 6.3 子查询物化优化


**📦 子查询物化技术**
```sql
-- 复杂子查询的物化优化
-- MySQL会自动将子查询结果物化为临时表

EXPLAIN FORMAT=JSON
SELECT u.name, u.email
FROM users u
WHERE u.dept_id IN (
  SELECT d.id 
  FROM departments d
  JOIN regions r ON d.region_id = r.id
  WHERE r.name = '华北区'
    AND d.budget > 1000000
);

-- 手动物化优化（适用于复杂场景）
-- 步骤1：先执行子查询并物化
CREATE TEMPORARY TABLE temp_dept_ids AS
SELECT DISTINCT d.id
FROM departments d  
JOIN regions r ON d.region_id = r.id
WHERE r.name = '华北区' AND d.budget > 1000000;

-- 步骤2：使用物化结果
SELECT u.name, u.email
FROM users u
JOIN temp_dept_ids t ON u.dept_id = t.id;

-- 清理临时表
DROP TEMPORARY TABLE temp_dept_ids;
```

---

## 7. 🚫 临时表避免策略


### 7.1 临时表产生的原因


**🔸 什么情况下会产生临时表**
```
临时表产生的场景：
1. DISTINCT操作：去重处理
2. GROUP BY操作：分组聚合
3. ORDER BY操作：排序处理
4. UNION操作：结果集合并
5. 复杂子查询：中间结果存储
6. 大表连接：连接算法需要

临时表的性能影响：
• 额外的内存/磁盘消耗
• 数据复制的IO开销
• 索引重建的CPU开销
• 可能导致磁盘临时表（performance_schema监控）
```

**💻 临时表检测方法**
```sql
-- 检测临时表使用情况
SHOW STATUS LIKE 'Created_tmp%';
-- Created_tmp_tables: 内存临时表数量
-- Created_tmp_disk_tables: 磁盘临时表数量

-- 查看单个查询的临时表使用
EXPLAIN 
SELECT DISTINCT dept_id FROM users WHERE status = 'active';
-- Extra列显示：Using temporary

-- 监控临时表使用（MySQL 8.0+）
SELECT EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT/1000000000 as duration_ms
FROM performance_schema.events_statements_summary_by_event_name 
WHERE EVENT_NAME LIKE '%tmp%';
```

### 7.2 DISTINCT优化避免临时表


**🎯 DISTINCT优化策略**
```sql
-- 问题查询：DISTINCT产生临时表
EXPLAIN 
SELECT DISTINCT u.dept_id, d.name
FROM users u
JOIN departments d ON u.dept_id = d.id
WHERE u.status = 'active';

-- 优化方案1：使用GROUP BY代替DISTINCT
SELECT u.dept_id, d.name
FROM users u  
JOIN departments d ON u.dept_id = d.id
WHERE u.status = 'active'
GROUP BY u.dept_id, d.name;

-- 优化方案2：使用EXISTS避免连接
SELECT d.id, d.name
FROM departments d
WHERE EXISTS (
  SELECT 1 FROM users u 
  WHERE u.dept_id = d.id AND u.status = 'active'
);

-- 优化方案3：利用索引自然去重
-- 如果dept_id有唯一性约束，可以直接查询departments表
SELECT id, name FROM departments 
WHERE id IN (SELECT DISTINCT dept_id FROM users WHERE status = 'active');
```

### 7.3 ORDER BY优化避免临时表


**📊 排序优化策略**
```sql
-- 问题：ORDER BY产生文件排序
EXPLAIN 
SELECT u.name, u.email, u.created_at
FROM users u
WHERE u.dept_id = 5
ORDER BY u.created_at DESC, u.name;

-- 优化方案1：创建复合索引
CREATE INDEX idx_dept_created_name ON users (dept_id, created_at DESC, name);

-- 优化后的查询
SELECT u.name, u.email, u.created_at
FROM users u  
WHERE u.dept_id = 5
ORDER BY u.created_at DESC, u.name;
-- Extra: Using index condition (避免了Using filesort)

-- 优化方案2：利用主键排序
SELECT u.name, u.email
FROM users u
WHERE u.dept_id = 5
ORDER BY u.id DESC  -- 利用主键自然排序
LIMIT 10;

-- 优化方案3：分页优化
-- 避免大偏移量的排序
SELECT u.name, u.email
FROM users u
WHERE u.dept_id = 5 AND u.id > 1000  -- 使用上次查询的最大ID
ORDER BY u.id
LIMIT 20;
```

### 7.4 GROUP BY优化避免临时表


**📈 GROUP BY优化技术**
```sql
-- 问题：GROUP BY产生临时表
EXPLAIN
SELECT dept_id, COUNT(*) as user_count
FROM users 
WHERE status = 'active'
GROUP BY dept_id;

-- 优化方案1：创建覆盖索引
CREATE INDEX idx_status_dept ON users (status, dept_id);

-- 优化方案2：使用松散索引扫描
-- 需要索引：(dept_id, status)
CREATE INDEX idx_dept_status ON users (dept_id, status);

SELECT dept_id, COUNT(*)
FROM users
WHERE status = 'active'  
GROUP BY dept_id;
-- Extra: Using index for group-by (松散索引扫描)

-- 优化方案3：预聚合思路
-- 对于频繁查询的聚合，可以考虑维护汇总表
CREATE TABLE dept_user_stats (
  dept_id INT PRIMARY KEY,
  active_count INT,
  total_count INT,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

---

## 8. 📊 排序优化策略


### 8.1 排序算法与性能影响


**🔸 MySQL排序算法类型**
```
排序算法类型：
1. 索引排序：利用索引的自然顺序（最快）
2. 内存排序：在sort_buffer_size内完成（较快）
3. 外部排序：需要临时文件辅助（较慢）

排序优化目标：
• 优先使用索引排序
• 避免外部排序（Using filesort）
• 减少排序的数据量
• 合理设置排序缓冲区大小
```

**💻 排序性能分析**
```sql
-- 检查排序相关参数
SHOW VARIABLES LIKE '%sort%';
-- sort_buffer_size: 排序缓冲区大小
-- max_sort_length: 排序字段最大长度

-- 监控排序性能
SHOW STATUS LIKE 'Sort%';
-- Sort_merge_passes: 外部排序次数
-- Sort_range: 范围排序次数  
-- Sort_rows: 排序行数
-- Sort_scan: 全表扫描排序次数

-- 分析具体查询的排序方式
EXPLAIN 
SELECT name, email FROM users 
WHERE dept_id = 5 
ORDER BY created_at DESC
LIMIT 20;
```

### 8.2 索引排序优化


**🎯 利用索引避免排序**
```sql
-- 场景1：单字段排序优化
-- 原查询：产生文件排序
SELECT name, email FROM users 
WHERE dept_id = 5
ORDER BY created_at DESC;

-- 创建复合索引
CREATE INDEX idx_dept_created ON users (dept_id, created_at DESC);

-- 优化后：使用索引排序
EXPLAIN 
SELECT name, email FROM users
WHERE dept_id = 5  
ORDER BY created_at DESC;
-- Extra: Using index condition (无Using filesort)

-- 场景2：多字段排序优化
SELECT name, email FROM users
WHERE status = 'active'
ORDER BY dept_id, created_at DESC;

-- 创建匹配的复合索引
CREATE INDEX idx_status_dept_created ON users (status, dept_id, created_at DESC);

-- 场景3：覆盖索引排序
CREATE INDEX idx_covering_sort ON users (dept_id, created_at DESC, name, email);
SELECT name, email FROM users
WHERE dept_id = 5
ORDER BY created_at DESC;
-- Extra: Using index (完全覆盖，无需回表)
```

### 8.3 排序字段优化技巧


**⚡ 排序优化策略**
```sql
-- 技巧1：减少排序字段长度
-- 避免对长文本字段排序
SELECT id, name FROM users 
ORDER BY LEFT(description, 50);  -- 只对前50个字符排序

-- 技巧2：使用数值代替字符串排序
-- 优化前：字符串排序
SELECT * FROM products ORDER BY status;  -- 'active', 'inactive', 'pending'

-- 优化后：状态码排序
ALTER TABLE products ADD status_code TINYINT;
UPDATE products SET status_code = CASE status 
  WHEN 'active' THEN 1
  WHEN 'pending' THEN 2  
  WHEN 'inactive' THEN 3
END;
CREATE INDEX idx_status_code ON products (status_code);
SELECT * FROM products ORDER BY status_code;

-- 技巧3：LIMIT优化排序
-- 对于只需要少量结果的查询，LIMIT可以显著提升性能
SELECT name, email FROM users
WHERE dept_id = 5
ORDER BY created_at DESC
LIMIT 10;  -- MySQL可以使用top-N排序算法

-- 技巧4：避免ORDER BY RAND()
-- 错误：随机排序性能极差
SELECT * FROM products ORDER BY RAND() LIMIT 10;

-- 正确：使用随机ID范围
SELECT * FROM products 
WHERE id >= (SELECT FLOOR(RAND() * (SELECT MAX(id) FROM products)))
LIMIT 10;
```

---

## 9. 📋 分组优化技术


### 9.1 GROUP BY执行机制


**🔸 GROUP BY处理过程**
```
GROUP BY执行步骤：
1. 扫描数据：根据WHERE条件过滤数据
2. 分组排序：按GROUP BY字段排序（可能产生临时表）
3. 聚合计算：执行COUNT、SUM等聚合函数
4. 结果输出：返回分组后的结果

优化目标：
• 利用索引避免临时表和排序
• 减少参与分组的数据量
• 选择合适的聚合算法
• 避免不必要的GROUP BY操作
```

**💻 GROUP BY性能分析**
```sql
-- 分析GROUP BY执行计划
EXPLAIN 
SELECT dept_id, COUNT(*) as user_count, AVG(salary) as avg_salary
FROM users 
WHERE status = 'active'
GROUP BY dept_id;

-- 关注Extra列的信息：
-- Using index for group-by: 松散索引扫描（最优）
-- Using temporary: 使用临时表（需优化）
-- Using filesort: 使用文件排序（需优化）

-- 监控分组操作性能
SELECT SQL_TEXT, EXEC_COUNT, AVG_TIMER_WAIT/1000000 as avg_ms
FROM performance_schema.events_statements_summary_by_digest
WHERE SQL_TEXT LIKE '%GROUP BY%'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 10;
```

### 9.2 松散索引扫描优化


**🚀 松散索引扫描技术**
```sql
-- 松散索引扫描的条件
-- 1. GROUP BY字段必须是索引的前缀部分
-- 2. 聚合函数只能是MIN()、MAX()或没有聚合函数
-- 3. 查询必须是等值条件或范围条件

-- 创建合适的索引
CREATE INDEX idx_dept_status ON users (dept_id, status, created_at);

-- 能使用松散索引扫描的查询
EXPLAIN
SELECT dept_id, MIN(created_at), MAX(created_at)
FROM users
GROUP BY dept_id;
-- Extra: Using index for group-by (松散索引扫描)

-- 不能使用松散索引扫描的查询  
EXPLAIN
SELECT dept_id, COUNT(*), AVG(salary)
FROM users
GROUP BY dept_id;
-- 因为使用了COUNT(*)和AVG()，无法使用松散索引扫描

-- 优化：分别处理
SELECT dept_id, COUNT(*)
FROM users
GROUP BY dept_id;

SELECT dept_id, AVG(salary)  
FROM users
WHERE salary IS NOT NULL
GROUP BY dept_id;
```

### 9.3 分组查询优化策略


**📊 GROUP BY优化技巧**
```sql
-- 技巧1：WHERE条件优化减少分组数据量
-- 原查询：先分组再过滤
SELECT dept_id, COUNT(*) as cnt
FROM users  
GROUP BY dept_id
HAVING COUNT(*) > 10;

-- 优化：先过滤再分组（如果可能）
SELECT dept_id, COUNT(*) as cnt
FROM users
WHERE status = 'active'  -- 先过滤
GROUP BY dept_id
HAVING COUNT(*) > 10;

-- 技巧2：避免不必要的GROUP BY
-- 如果只是为了去重，考虑使用DISTINCT
SELECT DISTINCT dept_id FROM users WHERE status = 'active';
-- 而不是：SELECT dept_id FROM users WHERE status = 'active' GROUP BY dept_id;

-- 技巧3：分组字段索引优化
CREATE INDEX idx_multi_group ON sales (region, product_type, sale_date);

SELECT region, product_type, SUM(amount)
FROM sales  
WHERE sale_date >= '2025-01-01'
GROUP BY region, product_type;  -- 利用索引避免排序

-- 技巧4：聚合函数优化
-- 避免在聚合函数中使用复杂表达式
-- 优化前
SELECT dept_id, SUM(salary * 1.1 + bonus) 
FROM users GROUP BY dept_id;

-- 优化后：预计算
SELECT dept_id, SUM(total_compensation)
FROM (
  SELECT dept_id, salary * 1.1 + bonus as total_compensation
  FROM users
) t
GROUP BY dept_id;
```

---

## 10. 🔗 联合查询优化


### 10.1 UNION vs UNION ALL


**🔸 UNION操作的性能影响**
```
UNION与UNION ALL的区别：
• UNION：自动去重，需要额外的排序和去重操作
• UNION ALL：不去重，直接合并结果集

性能对比：
• UNION ALL：性能最佳，无额外开销
• UNION：需要临时表和排序，性能较差

选择原则：
如果确定结果集无重复，或业务允许重复，优先使用UNION ALL
```

**💻 UNION优化示例**
```sql
-- 场景：查询活跃用户和VIP用户
-- 优化前：使用UNION（会去重）
EXPLAIN
SELECT id, name, 'active' as type FROM users WHERE status = 'active'
UNION  
SELECT id, name, 'vip' as type FROM users WHERE vip_level > 0;

-- 优化后：使用UNION ALL（如果确定无重复）
EXPLAIN  
SELECT id, name, 'active' as type FROM users WHERE status = 'active'
UNION ALL
SELECT id, name, 'vip' as type FROM users WHERE vip_level > 0 AND status != 'active';

-- 进一步优化：合并为单个查询
SELECT id, name,
  CASE 
    WHEN vip_level > 0 THEN 'vip'
    WHEN status = 'active' THEN 'active'
  END as type
FROM users  
WHERE status = 'active' OR vip_level > 0;
```

### 10.2 子查询UNION优化


**🔄 复杂UNION查询优化**
```sql
-- 复杂的UNION查询优化
-- 原查询：多个子查询的UNION
SELECT 'Q1' as quarter, SUM(amount) as total
FROM orders 
WHERE created_at BETWEEN '2025-01-01' AND '2025-03-31'
UNION ALL
SELECT 'Q2' as quarter, SUM(amount) as total  
FROM orders
WHERE created_at BETWEEN '2025-04-01' AND '2025-06-30'
UNION ALL
SELECT 'Q3' as quarter, SUM(amount) as total
FROM orders  
WHERE created_at BETWEEN '2025-07-01' AND '2025-09-30'
UNION ALL
SELECT 'Q4' as quarter, SUM(amount) as total
FROM orders
WHERE created_at BETWEEN '2025-10-01' AND '2025-12-31';

-- 优化方案：单表GROUP BY
SELECT 
  CASE 
    WHEN MONTH(created_at) <= 3 THEN 'Q1'
    WHEN MONTH(created_at) <= 6 THEN 'Q2' 
    WHEN MONTH(created_at) <= 9 THEN 'Q3'
    ELSE 'Q4'
  END as quarter,
  SUM(amount) as total
FROM orders
WHERE YEAR(created_at) = 2025
GROUP BY 
  CASE 
    WHEN MONTH(created_at) <= 3 THEN 'Q1'
    WHEN MONTH(created_at) <= 6 THEN 'Q2'
    WHEN MONTH(created_at) <= 9 THEN 'Q3' 
    ELSE 'Q4'
  END;
```

---

## 11. 🔒 执行计划固定与优化器提示


### 11.1 执行计划稳定性问题


**🔸 执行计划不稳定的原因**
```
导致执行计划变化的因素：
• 数据量变化：统计信息更新导致成本估算变化
• 索引变化：新增或删除索引
• 参数变化：数据库参数调整
• 版本升级：优化器算法改进
• 并发环境：资源竞争影响执行计划选择

执行计划不稳定的影响：
• 性能波动：同样的SQL执行时间差异很大
• 故障难排查：性能问题不可重现
• 系统不稳定：负载突然增加
```

**💻 执行计划稳定性监控**
```sql
-- 监控执行计划变化（MySQL 8.0+）
SELECT 
  DIGEST_TEXT,
  COUNT_STAR as execution_count,
  COUNT(DISTINCT PLAN_ID) as plan_variations,
  AVG_TIMER_WAIT/1000000 as avg_duration_ms
FROM performance_schema.events_statements_summary_by_digest
WHERE COUNT(DISTINCT PLAN_ID) > 1  -- 执行计划有变化
ORDER BY plan_variations DESC, execution_count DESC;

-- 查看具体SQL的执行计划历史
SELECT EVENT_ID, SQL_TEXT, PLAN_ID, EXECUTION_COUNT
FROM performance_schema.events_statements_history
WHERE DIGEST_TEXT LIKE '%users%'
ORDER BY EVENT_ID;
```

### 11.2 优化器提示使用


**🎯 MySQL优化器提示语法**
```sql
-- 连接顺序提示
SELECT /*+ JOIN_ORDER(u, d, o) */ 
  u.name, d.name, o.amount
FROM users u
JOIN departments d ON u.dept_id = d.id
JOIN orders o ON u.id = o.user_id;

-- 连接算法提示
SELECT /*+ HASH_JOIN(u, o) */
  u.name, o.amount  
FROM users u
JOIN orders o ON u.id = o.user_id;

SELECT /*+ BNL(u, o) */  -- Block Nested Loop
  u.name, o.amount
FROM users u  
JOIN orders o ON u.dept_id = o.department_id;

-- 索引提示
SELECT /*+ INDEX(u idx_dept_status) */
  name, email
FROM users u
WHERE dept_id = 5 AND status = 'active';

-- 禁用索引提示
SELECT /*+ NO_INDEX(u idx_name) */
  id, name  
FROM users u
WHERE name LIKE 'Zhang%';

-- 子查询物化提示
SELECT /*+ SUBQUERY(MATERIALIZATION) */
  name FROM users
WHERE dept_id IN (
  SELECT id FROM departments WHERE region = '华北'
);
```

### 11.3 执行计划固定技术


**🔒 固定执行计划的方法**
```sql
-- 方法1：使用优化器提示固定计划
-- 将稳定的执行计划用提示固定下来
SELECT /*+ 
  JOIN_ORDER(d, u, o) 
  INDEX(u idx_dept_status)
  INDEX(o idx_user_created)
*/
  u.name, o.amount
FROM departments d
JOIN users u ON d.id = u.dept_id  
JOIN orders o ON u.id = o.user_id
WHERE d.region = '华北' 
  AND u.status = 'active'
  AND o.created_at >= '2025-01-01';

-- 方法2：SQL重写固定执行路径
-- 通过改写SQL结构来固定执行计划
-- 原SQL（计划不稳定）
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 5
GROUP BY u.id, u.name;

-- 重写后（计划稳定）
SELECT u.name, COALESCE(oc.order_count, 0) as order_count
FROM users u
LEFT JOIN (
  SELECT user_id, COUNT(*) as order_count
  FROM orders
  GROUP BY user_id
) oc ON u.id = oc.user_id
WHERE u.dept_id = 5;

-- 方法3：创建专用索引固定计划
CREATE INDEX idx_stable_plan ON users (dept_id, status, created_at, id);
-- 这个索引确保查询总是使用相同的访问路径
```

### 11.4 SQL Plan Management


**📋 执行计划管理策略**
```sql
-- 策略1：定期收集统计信息
-- 保持统计信息的准确性，减少计划波动
ANALYZE TABLE users;
ANALYZE TABLE orders; 
ANALYZE TABLE departments;

-- 策略2：监控慢查询的执行计划变化
-- 设置慢查询日志，记录执行计划
SET GLOBAL slow_query_log = 1;
SET GLOBAL log_queries_not_using_indexes = 1;

-- 策略3：建立执行计划基线
-- 对重要SQL建立性能基线，定期检查
CREATE TABLE sql_baseline (
  sql_id VARCHAR(64) PRIMARY KEY,
  sql_text TEXT,
  optimal_plan TEXT,
  baseline_duration_ms INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 策略4：自动化执行计划检查
-- 创建定期检查脚本，发现计划异常时告警
DELIMITER //
CREATE PROCEDURE check_plan_stability()
BEGIN
  -- 检查执行时间超过基线2倍的SQL
  SELECT digest_text, avg_timer_wait/1000000 as current_ms
  FROM performance_schema.events_statements_summary_by_digest psd
  JOIN sql_baseline sb ON psd.digest_text = sb.sql_text
  WHERE psd.avg_timer_wait/1000000 > sb.baseline_duration_ms * 2;
END //
DELIMITER ;
```

---

## 12. 📋 核心要点总结


### 12.1 必须掌握的核心概念


**🔸 执行计划优化的核心原理**
```
优化策略分层：
• 物理层优化：索引设计、表结构优化
• 逻辑层优化：SQL重写、条件优化
• 算法层优化：连接算法、排序算法

性能优化目标：
• 减少数据扫描量：利用索引、条件下推
• 优化连接效率：驱动表选择、连接顺序
• 避免临时操作：临时表、文件排序
• 提升资源利用：内存、CPU、IO
```

**🔸 关键优化技术**
```
驱动表选择：
• 小表驱动大表原则
• 过滤条件优先原则
• 索引覆盖优先原则

连接优化：
• 连接顺序影响性能
• 选择合适的连接算法
• 利用索引优化连接

条件下推：
• 尽早过滤数据
• 减少中间结果集
• 提升整体性能
```

### 12.2 关键理解要点


**🔹 驱动表选择的核心逻辑**
```
选择原则优先级：
1. 结果集大小：小结果集驱动大结果集
2. 索引覆盖：有索引的表优先
3. 过滤效果：WHERE条件选择性高的表优先
4. 连接类型：等值连接优于范围连接

实际判断方法：
• 分析WHERE条件的过滤效果
• 评估可用索引的覆盖情况
• 估算各表的实际数据量
• 选择成本最低的驱动顺序
```

**🔹 索引优化的关键策略**
```
索引选择原则：
• 覆盖索引 > 普通索引 > 无索引
• 复合索引遵循最左前缀原则
• 避免在索引列上使用函数
• 合理使用索引提示

索引设计要点：
• WHERE条件的字段建索引
• ORDER BY字段考虑索引
• GROUP BY字段需要索引
• 连接字段必须有索引
```

**🔹 临时表避免的核心技巧**
```
避免临时表的方法：
• DISTINCT → GROUP BY或EXISTS
• ORDER BY → 利用索引自然排序
• GROUP BY → 松散索引扫描
• UNION → UNION ALL或单表查询

检测临时表的方法：
• EXPLAIN看Extra列的Using temporary
• 监控Created_tmp_tables状态变量
• 使用performance_schema分析
```

### 12.3 实际应用指导


**💼 优化实践路径**
```
第一步：性能问题识别
✅ 使用EXPLAIN分析执行计划
✅ 关注type、rows、Extra列
✅ 监控慢查询日志

第二步：针对性优化
✅ 创建合适的索引
✅ 调整连接顺序
✅ 重写复杂子查询
✅ 避免不必要的临时表

第三步：效果验证
✅ 对比优化前后的执行计划
✅ 测试实际执行时间
✅ 监控系统资源使用

第四步：持续监控
✅ 建立性能基线
✅ 定期检查执行计划稳定性
✅ 及时处理性能回退
```

### 12.4 常见问题解决


**🔧 典型优化场景**
```
场景1：多表连接查询慢
解决思路：
1. 检查连接字段是否有索引
2. 分析驱动表选择是否合理
3. 考虑是否需要调整连接顺序
4. 评估WHERE条件的过滤效果

场景2：ORDER BY查询慢
解决思路：
1. 为排序字段创建索引
2. 考虑复合索引的字段顺序
3. 避免对函数结果排序
4. 使用LIMIT减少排序数据量

场景3：GROUP BY查询慢
解决思路：
1. 为分组字段创建索引
2. 尝试使用松散索引扫描
3. 在GROUP BY前过滤数据
4. 考虑预聚合的设计思路
```

**⚠️ 常见优化陷阱**
```
陷阱1：过度使用索引提示
问题：硬编码的提示可能在数据变化后失效
建议：优先使用SQL重写，提示作为最后手段

陷阱2：忽略数据分布变化
问题：历史最优的执行计划可能不再适用
建议：定期更新统计信息，监控执行计划变化

陷阱3：单纯追求执行计划"好看"
问题：EXPLAIN显示的成本不等于实际执行时间
建议：以实际执行时间为准，执行计划仅作参考

陷阱4：过度复杂的SQL重写
问题：为了优化而让SQL变得难以维护
建议：在性能和可维护性之间找平衡
```

**🧠 记忆要点**
```
执行计划优化口诀：
"小表驱动大表好，索引覆盖扫描少，条件下推过滤早，临时排序要避免"

性能调优口诀：
"先看计划找问题，再建索引解瓶颈，重写查询优结构，监控跟踪保稳定"

优化验证口诀：
"理论分析要实践，执行时间是标准，系统资源要关注，长期监控防回退"
```

**🎯 核心记忆**
- 执行计划优化的目标是减少资源消耗和提升查询效率
- 驱动表选择和连接顺序直接影响多表查询性能
- 索引是优化的基础，但要避免过度索引和错误使用
- 临时表和文件排序是性能杀手，要通过索引和SQL重写避免
- 优化器提示是强制手段，应谨慎使用并做好监控
- 持续监控和基线管理是保持性能稳定的关键