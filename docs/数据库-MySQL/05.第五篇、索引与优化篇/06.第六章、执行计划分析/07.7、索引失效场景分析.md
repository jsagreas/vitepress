---
title: 7、索引失效场景分析
---
## 📚 目录

1. [索引失效基础概念](#1-索引失效基础概念)
2. [函数运算导致的索引失效](#2-函数运算导致的索引失效)
3. [类型转换与隐式转换](#3-类型转换与隐式转换)
4. [查询条件导致的索引失效](#4-查询条件导致的索引失效)
5. [复合索引失效场景](#5-复合索引失效场景)
6. [索引失效检测与修复](#6-索引失效检测与修复)
7. [索引使用最佳实践](#7-索引使用最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 索引失效基础概念


### 1.1 什么是索引失效


**🎯 简单理解**
索引失效就像图书馆的目录册突然变成了废纸，明明有索引但数据库偏偏不用，只能一本本书翻找。

```
生活类比：
有目录的图书馆 → 正常使用索引，快速定位
目录损坏的图书馆 → 索引失效，全书架翻找

性能差异：
索引查找：毫秒级响应
全表扫描：秒级甚至分钟级响应
```

**📋 技术定义**
```sql
索引失效（Index Invalidation）：
• 数据库优化器无法使用已建立的索引
• 被迫进行全表扫描或次优查询方式
• 导致查询性能急剧下降
• 常见于WHERE条件编写不当
```

### 1.2 索引失效的性能影响量化


**📊 性能影响对比**

```
实际性能测试数据：
┌──────────────┬──────────┬──────────┬──────────┐
│   表记录数   │ 索引查询 │ 全表扫描 │ 性能倍数 │
├──────────────┼──────────┼──────────┼──────────┤
│    1万条     │   2ms    │   50ms   │   25倍   │
│   10万条     │   3ms    │  500ms   │  167倍   │
│  100万条     │   5ms    │   5秒    │ 1000倍   │
│ 1000万条     │   8ms    │  50秒    │ 6250倍   │
└──────────────┴──────────┴──────────┴──────────┘

关键结论：数据量越大，索引失效的性能损失越严重
```

**💰 业务影响评估**
```
用户体验影响：
• 页面响应 < 100ms：用户感觉瞬间响应
• 页面响应 100ms-1s：用户能接受
• 页面响应 > 1s：用户开始感到延迟
• 页面响应 > 5s：用户可能放弃操作

业务损失：
• 电商网站：延迟1秒 → 转化率下降7%
• 搜索引擎：延迟500ms → 搜索量下降20%
• 移动应用：响应超3秒 → 用户流失率增加50%
```

### 1.3 索引失效的根本原因


**🔍 深层机制分析**
```
索引工作原理：
数据表 ←→ 索引结构（B+树）
 ↓           ↓
原始数据    排序后的键值 + 指针

索引失效原因：
• 查询条件无法利用索引的有序性
• 优化器判断全表扫描成本更低
• 索引统计信息不准确
• 查询条件破坏了索引结构
```

---

## 2. ⚙️ 函数运算导致的索引失效


### 2.1 函数运算失效原理


**❌ 为什么函数会导致索引失效？**

```
索引存储的是原始字段值：
用户表 user_id 字段索引：
1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ...（有序存储）

函数运算的问题：
WHERE ABS(user_id) = 5
数据库需要计算：ABS(1), ABS(2), ABS(3)...
无法直接利用索引的有序性
```

**🧪 实际测试对比**
```sql
-- 创建测试表
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    amount DECIMAL(10,2),
    create_time DATETIME,
    INDEX idx_user_id (user_id),
    INDEX idx_create_time (create_time)
);

-- ❌ 索引失效：在索引字段上使用函数
EXPLAIN SELECT * FROM orders 
WHERE YEAR(create_time) = 2024;

-- 执行计划结果：
-- type: ALL (全表扫描)
-- rows: 1000000 (扫描全部记录)
-- Extra: Using where

-- ✅ 索引有效：直接使用索引字段
EXPLAIN SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';

-- 执行计划结果：
-- type: range (范围扫描)
-- rows: 365000 (只扫描相关记录)
-- Extra: Using index condition
```

### 2.2 常见函数失效场景及解决方案


**📅 日期函数失效场景**

```sql
-- ❌ 常见错误写法
SELECT * FROM orders WHERE DATE(create_time) = '2024-01-15';
SELECT * FROM orders WHERE YEAR(create_time) = 2024;
SELECT * FROM orders WHERE MONTH(create_time) = 3;

-- ✅ 正确的索引友好写法
SELECT * FROM orders 
WHERE create_time >= '2024-01-15 00:00:00' 
  AND create_time < '2024-01-16 00:00:00';

SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';

SELECT * FROM orders 
WHERE create_time >= '2024-03-01' 
  AND create_time < '2024-04-01';
```

**🔢 数值函数失效场景**
```sql
-- ❌ 常见错误写法
SELECT * FROM products WHERE ABS(stock_count) > 100;
SELECT * FROM orders WHERE ROUND(amount, 0) = 1000;
SELECT * FROM users WHERE MOD(user_id, 10) = 5;

-- ✅ 正确的写法思路
-- 对于 ABS(stock_count) > 100
SELECT * FROM products 
WHERE stock_count > 100 OR stock_count < -100;

-- 对于 ROUND(amount, 0) = 1000
SELECT * FROM orders 
WHERE amount >= 999.5 AND amount < 1000.5;

-- 对于 MOD(user_id, 10) = 5
-- 可以考虑添加计算列或者接受全表扫描
```

**📝 字符串函数失效场景**
```sql
-- ❌ 常见错误写法
SELECT * FROM users WHERE UPPER(username) = 'JOHN';
SELECT * FROM products WHERE LENGTH(product_name) > 10;
SELECT * FROM orders WHERE SUBSTRING(order_no, 1, 3) = 'ORD';

-- ✅ 正确的索引友好写法
-- 对于大小写不敏感查询
SELECT * FROM users WHERE username = 'john';  -- 使用不区分大小写的排序规则

-- 对于长度查询，可以添加长度字段
ALTER TABLE products ADD COLUMN name_length INT;
UPDATE products SET name_length = LENGTH(product_name);
CREATE INDEX idx_name_length ON products(name_length);

-- 对于前缀查询
SELECT * FROM orders WHERE order_no LIKE 'ORD%';  -- 可以使用索引
```

### 2.3 表达式索引的替代方案


**🎯 MySQL函数索引（8.0+）**
```sql
-- MySQL 8.0+ 支持函数索引
CREATE INDEX idx_year_create_time ON orders ((YEAR(create_time)));

-- 现在这个查询可以使用索引了
SELECT * FROM orders WHERE YEAR(create_time) = 2024;
```

**🔧 计算列方案**
```sql
-- 添加计算列
ALTER TABLE orders 
ADD COLUMN create_year INT GENERATED ALWAYS AS (YEAR(create_time));

-- 为计算列创建索引
CREATE INDEX idx_create_year ON orders(create_year);

-- 查询时使用计算列
SELECT * FROM orders WHERE create_year = 2024;
```

**💡 应用层预处理方案**
```python
# Python应用层处理日期范围
def get_orders_by_year(year):
    start_date = f"{year}-01-01 00:00:00"
    end_date = f"{year + 1}-01-01 00:00:00"
    
    sql = """
    SELECT * FROM orders 
    WHERE create_time >= %s AND create_time < %s
    """
    return execute_query(sql, (start_date, end_date))
```

---

## 3. 🔄 类型转换与隐式转换


### 3.1 类型转换导致索引失效的机制


**🔍 隐式转换的陷阱**

```
MySQL类型转换规则：
┌────────────────┬──────────────────┬──────────────┐
│   比较类型     │    转换方向      │  索引使用    │
├────────────────┼──────────────────┼──────────────┤
│ 字符串 vs 数字 │ 字符串→数字      │ 索引失效     │
│ 日期 vs 字符串 │ 字符串→日期      │ 索引可用     │
│ 整数 vs 浮点   │ 整数→浮点        │ 索引可用     │
└────────────────┴──────────────────┴──────────────┘

危险场景：数字与字符串比较
```

**🧪 隐式转换实例分析**
```sql
-- 创建测试表
CREATE TABLE user_accounts (
    id INT PRIMARY KEY,
    phone VARCHAR(20),
    email VARCHAR(100),
    status TINYINT,
    INDEX idx_phone (phone),
    INDEX idx_status (status)
);

-- ❌ 隐式转换导致索引失效
EXPLAIN SELECT * FROM user_accounts WHERE phone = 13800138000;
-- 执行计划：type = ALL (全表扫描)
-- 原因：phone是VARCHAR，13800138000是数字，发生隐式转换

-- ✅ 类型匹配，索引有效
EXPLAIN SELECT * FROM user_accounts WHERE phone = '13800138000';
-- 执行计划：type = ref (索引查找)

-- ❌ 数字字段与字符串比较
EXPLAIN SELECT * FROM user_accounts WHERE status = '1';
-- 执行计划：type = ref (索引仍然有效)
-- 原因：MySQL会将字符串'1'转换为数字1
```

### 3.2 字符集转换问题


**🌐 字符集不匹配导致的性能问题**

```sql
-- 不同字符集的表连接
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50) CHARACTER SET utf8mb4,
    INDEX idx_username (username)
) CHARACTER SET utf8mb4;

CREATE TABLE logs (
    id INT PRIMARY KEY,
    username VARCHAR(50) CHARACTER SET latin1,
    action VARCHAR(100),
    INDEX idx_username (username)
) CHARACTER SET latin1;

-- ❌ 字符集不匹配，可能导致索引失效
SELECT u.*, l.action 
FROM users u
JOIN logs l ON u.username = l.username
WHERE u.username = 'john';

-- ✅ 解决方案：统一字符集
ALTER TABLE logs CONVERT TO CHARACTER SET utf8mb4;
```

### 3.3 类型转换最佳实践


**🎯 预防类型转换问题**
```sql
-- 1. 严格的字段定义
CREATE TABLE orders (
    order_id VARCHAR(20) NOT NULL,      -- 订单号用字符串
    user_id INT NOT NULL,               -- 用户ID用整数
    amount DECIMAL(10,2) NOT NULL,      -- 金额用精确数值
    status TINYINT NOT NULL,            -- 状态用小整数
    create_time DATETIME NOT NULL       -- 时间用日期类型
);

-- 2. 查询时严格匹配类型
-- 查询字符串字段用字符串
SELECT * FROM orders WHERE order_id = 'ORD20240101001';

-- 查询数字字段用数字  
SELECT * FROM orders WHERE user_id = 12345;

-- 查询状态用数字
SELECT * FROM orders WHERE status = 1;
```

**🔧 类型检查工具**
```sql
-- 检查表结构和字段类型
SELECT 
    COLUMN_NAME,
    DATA_TYPE,
    CHARACTER_SET_NAME,
    COLLATION_NAME
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_NAME = 'orders';

-- 检查慢查询中的类型转换问题
SELECT 
    sql_text,
    execution_count,
    avg_timer_wait
FROM performance_schema.events_statements_summary_by_digest
WHERE sql_text LIKE '%WHERE%'
  AND avg_timer_wait > 1000000000;  -- 超过1秒的查询
```

---

## 4. 🚫 查询条件导致的索引失效


### 4.1 前导模糊查询失效


**🔍 LIKE查询的索引使用规则**

```sql
-- 测试表
CREATE TABLE products (
    id INT PRIMARY KEY,
    product_name VARCHAR(200),
    category VARCHAR(50),
    INDEX idx_name (product_name),
    INDEX idx_category (category)
);

-- ✅ 可以使用索引的LIKE查询
EXPLAIN SELECT * FROM products WHERE product_name LIKE 'iPhone%';
-- 结果：type = range，可以使用索引

-- ❌ 无法使用索引的LIKE查询
EXPLAIN SELECT * FROM products WHERE product_name LIKE '%手机%';
-- 结果：type = ALL，全表扫描

EXPLAIN SELECT * FROM products WHERE product_name LIKE '%iPhone';
-- 结果：type = ALL，全表扫描
```

**📊 LIKE查询性能对比**
```
LIKE查询类型性能测试（100万条记录）：
┌─────────────────┬──────────┬──────────┬──────────┐
│   查询类型      │ 执行时间 │ 扫描行数 │ 索引使用 │
├─────────────────┼──────────┼──────────┼──────────┤
│ name LIKE 'A%'  │   5ms    │   1000   │   是     │
│ name LIKE '%A%' │  800ms   │ 1000000  │   否     │
│ name LIKE '%A'  │  850ms   │ 1000000  │   否     │
└─────────────────┴──────────┴──────────┴──────────┘
```

**🎯 前导模糊查询解决方案**
```sql
-- 方案1：全文索引（适合文本搜索）
ALTER TABLE products ADD FULLTEXT(product_name);
SELECT * FROM products WHERE MATCH(product_name) AGAINST('手机' IN NATURAL LANGUAGE MODE);

-- 方案2：分词表（适合关键词搜索）
CREATE TABLE product_keywords (
    product_id INT,
    keyword VARCHAR(50),
    INDEX idx_keyword (keyword)
);

-- 查询时联合关键词表
SELECT DISTINCT p.* 
FROM products p
JOIN product_keywords pk ON p.id = pk.product_id
WHERE pk.keyword = '手机';

-- 方案3：ES等搜索引擎（适合复杂搜索）
-- 将数据同步到Elasticsearch，使用专业搜索功能
```

### 4.2 负向条件查询失效


**🚫 NOT、!=、<> 条件的索引问题**

```sql
-- ❌ 负向条件通常无法有效使用索引
EXPLAIN SELECT * FROM orders WHERE status != 1;
EXPLAIN SELECT * FROM orders WHERE status <> 1;
EXPLAIN SELECT * FROM orders WHERE status NOT IN (1, 2, 3);
EXPLAIN SELECT * FROM users WHERE username NOT LIKE 'admin%';

-- 执行计划通常显示：type = ALL 或 type = index（不理想）
```

**💡 负向条件优化策略**
```sql
-- 策略1：转换为正向条件
-- 如果status只有几个值：0,1,2,3,4
-- ❌ WHERE status != 1
-- ✅ WHERE status IN (0, 2, 3, 4)

-- 策略2：使用EXISTS替代NOT IN
-- ❌ WHERE user_id NOT IN (SELECT user_id FROM banned_users)
-- ✅ WHERE NOT EXISTS (SELECT 1 FROM banned_users b WHERE b.user_id = users.id)

-- 策略3：添加状态标记字段
ALTER TABLE orders ADD COLUMN is_active TINYINT DEFAULT 1;
UPDATE orders SET is_active = 0 WHERE status = 1;
CREATE INDEX idx_is_active ON orders(is_active);

-- 现在可以高效查询
SELECT * FROM orders WHERE is_active = 1;
```

### 4.3 OR条件的索引选择问题


**🔀 OR条件的复杂性**

```sql
-- OR条件的索引使用情况
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100),
    phone VARCHAR(20),
    username VARCHAR(50),
    INDEX idx_email (email),
    INDEX idx_phone (phone),
    INDEX idx_username (username)
);

-- ✅ OR条件可以使用索引（index_merge）
EXPLAIN SELECT * FROM users 
WHERE email = 'john@example.com' 
   OR phone = '13800138000';
-- 可能使用：type = index_merge

-- ❌ OR条件无法有效使用索引
EXPLAIN SELECT * FROM users 
WHERE email = 'john@example.com' 
   OR age > 25;  -- age字段没有索引
-- 结果：type = ALL

-- ❌ 复杂OR条件
EXPLAIN SELECT * FROM users 
WHERE (email LIKE '%john%' OR phone LIKE '%138%');
-- 结果：type = ALL
```

**🎯 OR条件优化方案**
```sql
-- 方案1：使用UNION替代OR
-- ❌ 原始OR查询
SELECT * FROM users 
WHERE email = 'john@example.com' 
   OR phone = '13800138000';

-- ✅ UNION优化（当OR条件较少时）
SELECT * FROM users WHERE email = 'john@example.com'
UNION
SELECT * FROM users WHERE phone = '13800138000';

-- 方案2：创建联合索引
CREATE INDEX idx_email_phone ON users(email, phone);

-- 方案3：分别查询后合并（应用层处理）
-- 适合复杂的OR条件
```

### 4.4 NULL值查询的索引问题


**🕳️ NULL值索引特殊性**

```sql
-- NULL值索引查询测试
CREATE TABLE user_profiles (
    id INT PRIMARY KEY,
    nickname VARCHAR(50),
    avatar_url VARCHAR(200),
    bio TEXT,
    INDEX idx_nickname (nickname),
    INDEX idx_avatar (avatar_url)
);

-- ✅ IS NULL 可以使用索引
EXPLAIN SELECT * FROM user_profiles WHERE nickname IS NULL;
-- 结果：可能使用索引（取决于NULL值比例）

-- ✅ IS NOT NULL 可以使用索引  
EXPLAIN SELECT * FROM user_profiles WHERE nickname IS NOT NULL;

-- ❌ NULL值比较无法使用索引
EXPLAIN SELECT * FROM user_profiles WHERE nickname = NULL;
-- 错误写法，应该用 IS NULL

-- ❌ 包含NULL的函数运算
EXPLAIN SELECT * FROM user_profiles WHERE IFNULL(nickname, '') = '';
```

**🔧 NULL值优化策略**
```sql
-- 策略1：避免NULL值设计
CREATE TABLE user_profiles (
    id INT PRIMARY KEY,
    nickname VARCHAR(50) NOT NULL DEFAULT '',  -- 用空字符串替代NULL
    avatar_url VARCHAR(200) NOT NULL DEFAULT '',
    status TINYINT NOT NULL DEFAULT 0          -- 用0替代NULL
);

-- 策略2：为NULL值创建特殊索引
CREATE INDEX idx_nickname_not_null ON user_profiles(nickname) 
WHERE nickname IS NOT NULL;  -- PostgreSQL支持部分索引

-- 策略3：使用联合索引处理NULL
CREATE INDEX idx_nickname_status ON user_profiles(nickname, status);
```

---

## 5. 🔗 复合索引失效场景


### 5.1 最左前缀原则详解


**📏 最左前缀原则机制**

```
复合索引结构理解：
索引 KEY idx_user_time_status (user_id, create_time, status)

索引内部结构（简化示意）：
user_id | create_time  | status | 行指针
--------|-------------|--------|-------
   1    | 2024-01-01  |   1    |  →行1
   1    | 2024-01-02  |   2    |  →行2  
   1    | 2024-01-03  |   1    |  →行3
   2    | 2024-01-01  |   1    |  →行4
   2    | 2024-01-02  |   2    |  →行5

查找原理：按user_id排序，相同user_id内按create_time排序...
```

**🧪 最左前缀使用测试**
```sql
-- 创建复合索引
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    create_time DATETIME,
    status TINYINT,
    amount DECIMAL(10,2),
    INDEX idx_user_time_status (user_id, create_time, status)
);

-- ✅ 可以使用索引的查询（遵循最左前缀）
EXPLAIN SELECT * FROM orders WHERE user_id = 123;
-- 使用索引：✅

EXPLAIN SELECT * FROM orders WHERE user_id = 123 AND create_time > '2024-01-01';  
-- 使用索引：✅

EXPLAIN SELECT * FROM orders WHERE user_id = 123 AND create_time > '2024-01-01' AND status = 1;
-- 使用索引：✅（完全匹配）

EXPLAIN SELECT * FROM orders WHERE user_id = 123 AND status = 1;
-- 使用索引：✅（跳过中间字段，部分使用）

-- ❌ 无法使用索引的查询（违反最左前缀）
EXPLAIN SELECT * FROM orders WHERE create_time > '2024-01-01';
-- 不使用索引：❌（缺少最左字段user_id）

EXPLAIN SELECT * FROM orders WHERE status = 1;
-- 不使用索引：❌（缺少最左字段user_id）

EXPLAIN SELECT * FROM orders WHERE create_time > '2024-01-01' AND status = 1;
-- 不使用索引：❌（缺少最左字段user_id）
```

### 5.2 复合索引字段顺序优化


**📊 字段顺序选择原则**

```
复合索引字段排序优先级：
1. 等值查询字段 > 范围查询字段
2. 选择性高的字段 > 选择性低的字段  
3. 查询频率高的字段 > 查询频率低的字段

实例分析：
订单表常见查询：
- WHERE user_id = ? AND status = ?           (90%的查询)
- WHERE user_id = ? AND create_time > ?      (60%的查询)  
- WHERE user_id = ?                          (30%的查询)
- WHERE status = ?                           (10%的查询)

字段选择性分析：
- user_id: 10万个不同值（选择性高）
- status: 5个不同值（选择性低）
- create_time: 连续值（范围查询）

推荐索引顺序：(user_id, status, create_time)
```

**🎯 索引设计实例**
```sql
-- 业务场景分析
-- 1. 用户查看自己的订单：WHERE user_id = ? ORDER BY create_time DESC
-- 2. 查看特定状态订单：WHERE user_id = ? AND status = ?
-- 3. 时间范围查询：WHERE user_id = ? AND create_time BETWEEN ? AND ?
-- 4. 复合条件查询：WHERE user_id = ? AND status = ? AND create_time > ?

-- 最优索引设计
CREATE INDEX idx_user_status_time ON orders (user_id, status, create_time);

-- 验证索引效果
EXPLAIN SELECT * FROM orders 
WHERE user_id = 12345 
  AND status IN (1, 2) 
  AND create_time >= '2024-01-01'
ORDER BY create_time DESC;
```

### 5.3 复合索引部分使用场景


**🔄 索引使用效率分析**

```sql
-- 复合索引：KEY idx_abc (a, b, c)
-- 不同查询条件的索引使用情况

-- 查询条件组合测试
CREATE TABLE test_table (
    id INT PRIMARY KEY,
    field_a INT,
    field_b INT, 
    field_c INT,
    field_d INT,
    INDEX idx_abc (field_a, field_b, field_c)
);

-- 索引使用情况分析
┌────────────────────────────┬──────────┬──────────────┐
│         查询条件           │ 索引使用 │   使用程度   │
├────────────────────────────┼──────────┼──────────────┤
│ WHERE a = 1                │    ✅    │   部分使用   │
│ WHERE a = 1 AND b = 2      │    ✅    │   部分使用   │  
│ WHERE a = 1 AND b = 2 AND c = 3 │ ✅ │   完全使用   │
│ WHERE a = 1 AND c = 3      │    ✅    │   部分使用   │
│ WHERE b = 2                │    ❌    │   无法使用   │
│ WHERE b = 2 AND c = 3      │    ❌    │   无法使用   │
│ WHERE c = 3                │    ❌    │   无法使用   │
└────────────────────────────┴──────────┴──────────────┘
```

**📈 索引使用率优化**
```sql
-- 场景：经常需要按不同字段组合查询
-- 需要创建多个索引来覆盖不同查询模式

-- 分析查询模式
-- 70% 查询：WHERE user_id = ? AND status = ?
-- 20% 查询：WHERE user_id = ? AND create_time > ?  
-- 10% 查询：WHERE status = ? AND create_time > ?

-- 索引策略
CREATE INDEX idx_user_status ON orders (user_id, status);        -- 覆盖70%查询
CREATE INDEX idx_user_time ON orders (user_id, create_time);     -- 覆盖20%查询  
CREATE INDEX idx_status_time ON orders (status, create_time);    -- 覆盖10%查询

-- 或者使用覆盖索引
CREATE INDEX idx_user_status_time_amount ON orders (user_id, status, create_time, amount);
```

---

## 6. 🔧 索引失效检测与修复


### 6.1 索引失效自动检测工具


**🔍 MySQL性能监控查询**

```sql
-- 1. 检查慢查询中的全表扫描
SELECT 
    query,
    exec_count,
    avg_timer_wait/1000000000 as avg_time_seconds,
    rows_examined_avg,
    rows_sent_avg,
    last_seen
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait > 1000000000  -- 超过1秒的查询
  AND rows_examined_avg > 10000    -- 扫描行数过多
ORDER BY avg_timer_wait DESC;

-- 2. 检查未使用的索引
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    s.INDEX_NAME,
    s.COLUMN_NAME
FROM information_schema.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p 
    ON s.TABLE_SCHEMA = p.OBJECT_SCHEMA 
   AND s.TABLE_NAME = p.OBJECT_NAME 
   AND s.INDEX_NAME = p.INDEX_NAME
WHERE s.TABLE_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema')
  AND p.INDEX_NAME IS NULL
  AND s.INDEX_NAME != 'PRIMARY';

-- 3. 分析表扫描频率
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ,
    COUNT_WRITE,
    COUNT_READ + COUNT_WRITE as total_operations,
    ROUND(COUNT_READ / (COUNT_READ + COUNT_WRITE) * 100, 2) as read_percentage
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema')
ORDER BY total_operations DESC;
```

**🛠️ 自定义索引分析脚本**
```python
# Python索引分析工具示例
import mysql.connector
import pandas as pd

class IndexAnalyzer:
    def __init__(self, connection_config):
        self.conn = mysql.connector.connect(**connection_config)
        
    def analyze_slow_queries(self):
        """分析慢查询中的索引使用情况"""
        query = """
        SELECT 
            digest_text,
            count_star as execution_count,
            avg_timer_wait/1000000000 as avg_seconds,
            sum_rows_examined/count_star as avg_rows_examined,
            sum_rows_sent/count_star as avg_rows_sent
        FROM performance_schema.events_statements_summary_by_digest 
        WHERE avg_timer_wait > 100000000  -- 超过0.1秒
        ORDER BY avg_timer_wait DESC
        LIMIT 20
        """
        return pd.read_sql(query, self.conn)
    
    def check_unused_indexes(self):
        """检查未使用的索引"""
        query = """
        SELECT 
            s.TABLE_SCHEMA,
            s.TABLE_NAME,
            s.INDEX_NAME,
            GROUP_CONCAT(s.COLUMN_NAME ORDER BY s.SEQ_IN_INDEX) as columns
        FROM information_schema.STATISTICS s
        LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p 
            ON s.TABLE_SCHEMA = p.OBJECT_SCHEMA 
           AND s.TABLE_NAME = p.OBJECT_NAME 
           AND s.INDEX_NAME = p.INDEX_NAME
        WHERE s.TABLE_SCHEMA = 'your_database'
          AND p.INDEX_NAME IS NULL
          AND s.INDEX_NAME != 'PRIMARY'
        GROUP BY s.TABLE_SCHEMA, s.TABLE_NAME, s.INDEX_NAME
        """
        return pd.read_sql(query, self.conn)
        
    def analyze_query_pattern(self, table_name):
        """分析表的查询模式"""
        # 这里可以集成慢查询日志分析
        pass

# 使用示例
analyzer = IndexAnalyzer({
    'host': 'localhost',
    'user': 'root', 
    'password': 'password',
    'database': 'your_db'
})

slow_queries = analyzer.analyze_slow_queries()
unused_indexes = analyzer.check_unused_indexes()
```

### 6.2 失效场景预防策略


**🛡️ 开发阶段预防**
```sql
-- 1. SQL编写规范检查清单
-- ✅ 检查项目
-- WHERE条件是否使用了函数？
-- 字段类型是否匹配？
-- 是否遵循最左前缀原则？
-- LIKE是否使用了前导通配符？
-- 是否使用了负向条件？

-- 2. 代码审查模板
/*
SQL审查清单：
□ 所有WHERE条件字段都有合适索引
□ 没有在索引字段上使用函数
□ 参数类型与字段类型匹配
□ 复合索引使用遵循最左前缀
□ 避免SELECT *，明确指定字段
□ JOIN条件字段都有索引
□ ORDER BY字段有索引支持
*/

-- 3. 性能测试验证
-- 在开发环境进行性能测试
EXPLAIN SELECT * FROM orders WHERE user_id = 12345;
EXPLAIN SELECT * FROM orders WHERE YEAR(create_time) = 2024;  -- 检查是否误用函数
```

**🔒 生产环境监控**
```sql
-- 1. 设置慢查询监控
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 0.1;  -- 记录超过0.1秒的查询
SET GLOBAL log_queries_not_using_indexes = 'ON';  -- 记录未使用索引的查询

-- 2. 创建监控视图
CREATE VIEW v_performance_summary AS
SELECT 
    OBJECT_SCHEMA as database_name,
    OBJECT_NAME as table_name,
    COUNT_READ,
    COUNT_WRITE,
    SUM_TIMER_READ/1000000000 as total_read_time_seconds,
    SUM_TIMER_WRITE/1000000000 as total_write_time_seconds
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema');

-- 3. 定期检查脚本
-- 每日运行的索引健康检查
DELIMITER //
CREATE PROCEDURE CheckIndexHealth()
BEGIN
    -- 检查慢查询
    SELECT 'Slow Queries Analysis' as report_type;
    SELECT 
        digest_text,
        count_star,
        avg_timer_wait/1000000000 as avg_seconds
    FROM performance_schema.events_statements_summary_by_digest 
    WHERE avg_timer_wait > 1000000000
    ORDER BY avg_timer_wait DESC
    LIMIT 10;
    
    -- 检查全表扫描
    SELECT 'Full Table Scan Analysis' as report_type;
    SELECT 
        digest_text,
        sum_rows_examined,
        sum_rows_sent,
        sum_rows_examined/sum_rows_sent as scan_ratio
    FROM performance_schema.events_statements_summary_by_digest 
    WHERE sum_rows_examined > 100000
    ORDER BY sum_rows_examined DESC
    LIMIT 10;
END //
DELIMITER ;
```

### 6.3 失效索引修复建议


**🔧 系统化修复流程**

```
索引失效修复流程：
1. 问题识别 → 2. 原因分析 → 3. 解决方案 → 4. 效果验证

┌─ 第1步：问题识别 ──────────────────┐
│ • 慢查询日志分析                   │
│ • 执行计划检查                     │  
│ • 性能监控告警                     │
└────────────────────────────────────┘
           ⬇
┌─ 第2步：原因分析 ──────────────────┐
│ • 确定索引失效类型                 │
│ • 分析查询模式                     │
│ • 评估数据分布                     │  
└────────────────────────────────────┘
           ⬇
┌─ 第3步：解决方案 ──────────────────┐
│ • 修改查询语句                     │
│ • 调整索引结构                     │
│ • 优化数据类型                     │
└────────────────────────────────────┘
           ⬇
┌─ 第4步：效果验证 ──────────────────┐
│ • 执行计划对比                     │
│ • 性能测试验证                     │
│ • 生产环境监控                     │
└────────────────────────────────────┘
```

**📋 常见问题修复手册**
```sql
-- 问题1：函数导致的索引失效
-- 现象：WHERE DATE(create_time) = '2024-01-01'
-- 原因：在索引字段上使用函数
-- 解决：WHERE create_time >= '2024-01-01' AND create_time < '2024-01-02'

-- 问题2：类型转换导致的索引失效  
-- 现象：WHERE phone = 13800138000 (phone是VARCHAR)
-- 原因：数字与字符串比较引起隐式转换
-- 解决：WHERE phone = '13800138000'

-- 问题3：前导模糊查询
-- 现象：WHERE product_name LIKE '%手机%'
-- 原因：前导通配符无法使用索引
-- 解决：使用全文索引或ES搜索引擎

-- 问题4：复合索引使用不当
-- 现象：INDEX(a,b,c) 但查询 WHERE b = ? AND c = ?
-- 原因：违反最左前缀原则
-- 解决：添加索引 INDEX(b,c) 或调整查询条件

-- 问题5：负向条件查询
-- 现象：WHERE status != 1
-- 原因：负向条件难以有效使用索引
-- 解决：WHERE status IN (0,2,3,4) 或添加标记字段
```

---

## 7. 🎯 索引使用最佳实践


### 7.1 索引设计最佳实践


**🏗️ 索引设计原则**

```sql
-- 1. 单列索引 vs 复合索引选择原则
-- 分析实际查询模式，而不是凭感觉设计

-- 查询分析示例
-- 假设orders表的查询统计：
-- 60% WHERE user_id = ?
-- 30% WHERE user_id = ? AND status = ?  
-- 8%  WHERE user_id = ? AND create_time > ?
-- 2%  WHERE status = ?

-- 推荐索引策略：
CREATE INDEX idx_user_id ON orders(user_id);                    -- 覆盖90%以上查询
CREATE INDEX idx_user_status ON orders(user_id, status);        -- 专门优化30%查询
CREATE INDEX idx_user_time ON orders(user_id, create_time);     -- 专门优化8%查询

-- 2. 索引字段选择性分析
SELECT 
    COLUMN_NAME,
    COUNT(DISTINCT COLUMN_NAME) / COUNT(*) as selectivity,
    COUNT(DISTINCT COLUMN_NAME) as unique_values,
    COUNT(*) as total_rows
FROM orders, INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_NAME = 'orders'
GROUP BY COLUMN_NAME
ORDER BY selectivity DESC;

-- 选择性高的字段（接近1.0）适合做索引
-- 选择性低的字段（接近0.0）不适合单独做索引
```

**📊 索引维护策略**
```sql
-- 定期分析表和索引统计信息
ANALYZE TABLE orders;

-- 检查索引碎片情况
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    SUB_PART,
    PACKED,
    NULLABLE,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, SEQ_IN_INDEX;

-- 重建碎片化严重的索引
ALTER TABLE orders DROP INDEX idx_user_time;
ALTER TABLE orders ADD INDEX idx_user_time (user_id, create_time);
```

### 7.2 查询优化最佳实践


**✅ 索引友好的SQL编写规范**

```sql
-- 1. 避免在WHERE条件中使用函数
-- ❌ 错误写法
SELECT * FROM orders WHERE YEAR(create_time) = 2024;
SELECT * FROM users WHERE UPPER(username) = 'JOHN';

-- ✅ 正确写法  
SELECT * FROM orders WHERE create_time >= '2024-01-01' AND create_time < '2025-01-01';
SELECT * FROM users WHERE username = 'john';  -- 使用正确的大小写

-- 2. 确保数据类型匹配
-- ❌ 错误写法
SELECT * FROM users WHERE user_id = '12345';  -- user_id是INT类型
SELECT * FROM orders WHERE amount = 100;      -- amount是DECIMAL类型

-- ✅ 正确写法
SELECT * FROM users WHERE user_id = 12345;
SELECT * FROM orders WHERE amount = 100.00;

-- 3. 合理使用LIKE查询
-- ❌ 无法使用索引
SELECT * FROM products WHERE name LIKE '%手机%';

-- ✅ 可以使用索引
SELECT * FROM products WHERE name LIKE '苹果%';

-- ✅ 使用全文索引
SELECT * FROM products WHERE MATCH(name, description) AGAINST('手机' IN NATURAL LANGUAGE MODE);

-- 4. 优化OR条件
-- ❌ 可能无法有效使用索引
SELECT * FROM users WHERE email = 'john@qq.com' OR phone = '13800138000' OR username = 'john';

-- ✅ 使用UNION替代（当OR条件不多时）
SELECT * FROM users WHERE email = 'john@qq.com'
UNION  
SELECT * FROM users WHERE phone = '13800138000'
UNION
SELECT * FROM users WHERE username = 'john';
```

**🔍 执行计划分析技巧**
```sql
-- 详细分析执行计划
EXPLAIN FORMAT=JSON SELECT * FROM orders 
WHERE user_id = 12345 AND status = 1 
ORDER BY create_time DESC;

-- 关键指标解读：
-- type: 访问类型
--   const: 主键或唯一索引等值查询（最快）
--   eq_ref: 唯一索引查找（很快）  
--   ref: 非唯一索引等值查询（快）
--   range: 索引范围查询（较快）
--   index: 索引全扫描（慢）
--   ALL: 全表扫描（最慢）

-- key: 实际使用的索引
-- rows: 预估扫描行数（越少越好）
-- Extra: 额外信息
--   Using index: 覆盖索引（很好）
--   Using where: 服务器层过滤（一般）
--   Using temporary: 使用临时表（需要优化）
--   Using filesort: 文件排序（需要优化）
```

### 7.3 性能监控与调优


**📈 建立性能基线**
```sql
-- 1. 记录关键查询的性能基线
CREATE TABLE query_performance_baseline (
    query_id VARCHAR(100),
    query_text TEXT,
    avg_execution_time_ms DECIMAL(10,3),
    avg_rows_examined INT,
    create_date DATE,
    PRIMARY KEY (query_id, create_date)
);

-- 2. 定期收集性能数据
INSERT INTO query_performance_baseline
SELECT 
    MD5(digest_text) as query_id,
    LEFT(digest_text, 500) as query_text,
    avg_timer_wait/1000000 as avg_execution_time_ms,
    sum_rows_examined/count_star as avg_rows_examined,
    CURRENT_DATE as create_date
FROM performance_schema.events_statements_summary_by_digest 
WHERE digest_text NOT LIKE '%performance_schema%'
  AND count_star > 100;  -- 只记录执行次数较多的查询

-- 3. 性能趋势分析
SELECT 
    query_id,
    create_date,
    avg_execution_time_ms,
    LAG(avg_execution_time_ms) OVER (PARTITION BY query_id ORDER BY create_date) as prev_time,
    ROUND((avg_execution_time_ms - LAG(avg_execution_time_ms) OVER (PARTITION BY query_id ORDER BY create_date)) / LAG(avg_execution_time_ms) OVER (PARTITION BY query_id ORDER BY create_date) * 100, 2) as performance_change_percent
FROM query_performance_baseline
WHERE create_date >= DATE_SUB(CURRENT_DATE, INTERVAL 7 DAY)
ORDER BY performance_change_percent DESC;
```

**🚨 自动化告警系统**
```python
# Python性能监控脚本示例
import mysql.connector
import smtplib
from email.mime.text import MIMEText

class PerformanceMonitor:
    def __init__(self, db_config, alert_config):
        self.db_config = db_config
        self.alert_config = alert_config
        
    def check_slow_queries(self):
        """检查慢查询"""
        conn = mysql.connector.connect(**self.db_config)
        cursor = conn.cursor()
        
        # 查询最近1小时的慢查询
        query = """
        SELECT 
            digest_text,
            count_star,
            avg_timer_wait/1000000000 as avg_seconds,
            sum_rows_examined/count_star as avg_rows_examined
        FROM performance_schema.events_statements_summary_by_digest 
        WHERE last_seen >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
          AND avg_timer_wait > 5000000000  -- 超过5秒
        ORDER BY avg_timer_wait DESC
        """
        
        cursor.execute(query)
        slow_queries = cursor.fetchall()
        
        if slow_queries:
            self.send_alert("慢查询告警", slow_queries)
            
        cursor.close()
        conn.close()
        
    def check_index_usage(self):
        """检查索引使用情况"""
        # 检查是否有大量全表扫描
        # 检查是否有索引未被使用
        # 发送相应告警
        pass
        
    def send_alert(self, subject, data):
        """发送告警邮件"""
        msg = MIMEText(str(data))
        msg['Subject'] = subject
        msg['From'] = self.alert_config['from']
        msg['To'] = self.alert_config['to']
        
        smtp = smtplib.SMTP(self.alert_config['smtp_server'])
        smtp.send_message(msg)
        smtp.quit()

# 使用示例
monitor = PerformanceMonitor(
    db_config={'host': 'localhost', 'user': 'root', 'password': 'pass', 'database': 'mydb'},
    alert_config={'smtp_server': 'smtp.qq.com', 'from': 'alert@company.com', 'to': 'dba@company.com'}
)

monitor.check_slow_queries()
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 索引失效本质：有索引但无法使用，导致性能急剧下降
🔸 失效主要原因：函数运算、类型转换、查询条件不当、复合索引使用错误
🔸 性能影响：从毫秒级查询降级到秒级查询，影响用户体验和系统负载
🔸 检测方法：执行计划分析、慢查询日志、性能监控工具
🔸 修复策略：查询重写、索引调整、数据类型优化、监控预防
```

### 8.2 索引失效场景速查表


| **失效类型** | **典型场景** | **解决方案** | **优先级** |
|-------------|-------------|-------------|-----------|
| **函数运算** | `WHERE YEAR(date) = 2024` | `WHERE date >= '2024-01-01' AND date < '2025-01-01'` | `🔴 高` |
| **类型转换** | `WHERE phone = 13800138000` | `WHERE phone = '13800138000'` | `🔴 高` |
| **前导模糊** | `WHERE name LIKE '%abc%'` | `使用全文索引或搜索引擎` | `🟡 中` |
| **负向条件** | `WHERE status != 1` | `WHERE status IN (0,2,3,4)` | `🟡 中` |
| **OR条件** | `WHERE a = 1 OR b = 2` | `使用UNION或联合索引` | `🟡 中` |
| **最左前缀** | `索引(a,b,c) 查询WHERE b = 1` | `调整查询条件或添加索引` | `🔴 高` |

### 8.3 关键诊断流程


**🔍 问题诊断三步法**
```
第1步：确认症状
□ 查询响应时间异常慢
□ 数据库CPU使用率高  
□ 慢查询日志中出现该SQL
□ 用户反馈页面响应慢

第2步：分析执行计划
□ EXPLAIN查看访问类型
□ 检查是否使用了索引
□ 分析扫描行数是否合理
□ 查看Extra信息中的提示

第3步：定位根本原因  
□ 检查WHERE条件是否使用函数
□ 验证字段类型是否匹配
□ 确认复合索引使用是否正确
□ 分析查询模式是否合理
```

### 8.4 预防策略与最佳实践


**🛡️ 开发阶段预防**
```
代码规范：
• WHERE条件避免使用函数
• 确保参数类型与字段类型匹配
• 复合索引查询遵循最左前缀原则
• 避免前导通配符的LIKE查询
• 慎用负向条件查询

设计规范：
• 基于实际查询模式设计索引
• 选择性高的字段优先考虑索引
• 避免过多冗余索引
• 定期分析和清理无用索引
```

**📊 运维阶段监控**
```
监控指标：
• 慢查询数量和趋势
• 全表扫描的查询比例  
• 索引使用率统计
• 查询响应时间分布

告警策略：
• 慢查询超过阈值告警
• 全表扫描比例过高告警
• 索引使用率下降告警
• 数据库性能指标异常告警
```

### 8.5 学习建议与实践要点


**🎓 学习路径**
```
基础阶段：
1. 理解索引工作原理
2. 掌握EXPLAIN执行计划分析
3. 熟悉常见索引失效场景

进阶阶段：
1. 学会性能监控和分析  
2. 掌握复合索引设计原则
3. 了解不同存储引擎的索引特点

高级阶段：
1. 建立自动化监控体系
2. 设计索引策略和规范
3. 处理复杂的性能优化问题
```

**🧪 动手实践建议**
```
练习项目：
1. 搭建测试环境，模拟各种索引失效场景
2. 使用慢查询日志分析工具
3. 编写索引使用监控脚本
4. 对线上项目进行索引优化

实战技能：
1. 快速定位性能问题的能力
2. 设计合理索引策略的能力  
3. 建立性能监控体系的能力
4. 预防索引失效问题的能力
```

**🎯 关键记忆点**
```
一句话精华：
索引失效就像有路不走偏要翻山，明明有捷径却选择了最累的方式

核心原则：
• 函数是索引的天敌
• 类型匹配是基本要求
• 最左前缀是复合索引的铁律
• 监控预防胜过事后补救

实用技巧：
• 先看执行计划再下结论  
• 性能问题要量化分析
• 索引不是越多越好
• 业务场景决定索引策略
```

**🔑 掌握程度自检**
```
基础要求：★★★★★  
□ 能识别常见的索引失效场景
□ 会分析EXPLAIN执行计划
□ 理解最左前缀原则
□ 知道如何避免函数导致的失效

进阶要求：★★★☆☆
□ 能设计合理的复合索引
□ 会使用性能监控工具
□ 能量化分析性能影响
□ 掌握索引失效的修复方法

实战要求：★★☆☆☆  
□ 能建立性能监控体系
□ 会制定索引使用规范
□ 能处理复杂的性能优化问题
□ 具备预防性能问题的能力
```

---

> 📚 **拓展学习**
> 
> - **相关主题**：查询优化器原理、存储引擎索引实现
> - **高级话题**：分区表索引、覆盖索引设计、索引统计信息
> - **实践项目**：搭建数据库性能监控平台

**💡 记忆口诀**：
索引失效五大敌：函数转换模糊负向前缀不合理，执行计划来诊断，监控预防最重要！