---
title: 2、MySQL访问类型与性能分析
---
## 📚 目录

1. [访问类型基础概念](#1-访问类型基础概念)
2. [访问类型详细分析](#2-访问类型详细分析)
3. [访问类型性能排序](#3-访问类型性能排序)
4. [访问类型选择决策逻辑](#4-访问类型选择决策逻辑)
5. [访问类型优化策略](#5-访问类型优化策略)
6. [混合访问类型分析](#6-混合访问类型分析)
7. [监控与性能评估](#7-监控与性能评估)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 访问类型基础概念


### 1.1 什么是访问类型（Access Type）


**🔸 访问类型的本质含义**
```
访问类型就是MySQL告诉你：
"我准备用什么方式来查找你要的数据"

就像在图书馆找书：
• system：图书馆就一本书，直接拿
• const：知道确切位置，直接去取
• eq_ref：按图索骥，精确定位  
• ref：按分类查找，可能有多本
• range：在某个范围内翻找
• ALL：把所有书都翻一遍

性能差异：
从快到慢依次递减，ALL是最慢的
```

### 1.2 访问类型在执行计划中的位置


**📋 EXPLAIN输出中的type列**
```sql
-- 查看执行计划的访问类型
EXPLAIN SELECT * FROM employees WHERE emp_id = 1001;

-- 执行计划输出
+----+-------+-------+-------+------+-------+--------+
| id | type  | table | key   | rows | Extra |        |
+----+-------+-------+-------+------+-------+--------+
|  1 | const | emp   | PRIMARY| 1   |       |        |
+----+-------+-------+-------+------+-------+--------+

关键信息：
• type列显示访问类型
• key列显示使用的索引  
• rows列显示预估扫描行数
• Extra列显示额外信息
```

---

## 2. 📊 访问类型详细分析


### 2.1 最优访问类型


**⚡ system - 系统表单行访问**
```sql
-- system访问类型（很少见）
-- 通常出现在系统表或只有一行数据的表
SELECT * FROM (SELECT 1 as id, 'test' as name) as single_row_table;

特点：
• 表中只有0行或1行数据
• 是const类型的特殊情况
• 性能最优，几乎瞬间完成
• 实际生产中很少遇到
```

**⚡ const - 常数级查询**
```sql
-- const访问类型示例
-- 通过主键或唯一索引精确匹配单行
EXPLAIN SELECT * FROM employees WHERE emp_id = 1001;
EXPLAIN SELECT * FROM employees WHERE email = 'john@company.com';

-- 创建测试数据
CREATE TABLE test_const (
    id INT PRIMARY KEY,
    unique_code VARCHAR(20) UNIQUE,
    name VARCHAR(50)
);

INSERT INTO test_const VALUES (1, 'UC001', 'Alice');

-- const访问示例
EXPLAIN SELECT * FROM test_const WHERE id = 1;
EXPLAIN SELECT * FROM test_const WHERE unique_code = 'UC001';

特点：
• 通过主键或唯一索引精确定位
• 最多返回1行数据
• MySQL优化器会将条件当作常数处理
• 性能极优，仅次于system
```

### 2.2 高效访问类型


**🔗 eq_ref - 唯一索引连接**
```sql
-- eq_ref访问类型
-- 多表连接时，连接条件使用主键或唯一索引

-- 创建测试表
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    INDEX idx_dept(dept_id)
);

-- eq_ref示例
EXPLAIN SELECT e.emp_name, d.dept_name 
FROM employees e 
JOIN departments d ON e.dept_id = d.dept_id;

特点：
• 仅在多表JOIN中出现
• 对于前表的每一行，后表通过主键或唯一索引精确匹配一行
• 性能很高，每次连接最多读取一行
```

**📍 ref - 非唯一索引查找**
```sql
-- ref访问类型
-- 通过普通索引查找，可能返回多行

-- 添加普通索引
ALTER TABLE employees ADD INDEX idx_dept_name(dept_id, emp_name);

-- ref示例
EXPLAIN SELECT * FROM employees WHERE dept_id = 10;
EXPLAIN SELECT * FROM employees WHERE dept_id = 10 AND emp_name LIKE 'John%';

特点：
• 使用普通索引（非唯一）进行等值查找
• 可能返回多行匹配的结果
• 比const慢，但仍然很高效
• 最常见的高效访问类型
```

### 2.3 特殊访问类型


**📝 fulltext - 全文索引查询**
```sql
-- fulltext访问类型
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT KEY idx_content(title, content)
);

-- fulltext示例
EXPLAIN SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL优化' IN BOOLEAN MODE);

特点：
• 使用FULLTEXT索引进行全文搜索
• 专门用于文本搜索查询
• 性能取决于文本内容和搜索词
```

**🔍 ref_or_null - 包含NULL值查找**
```sql
-- ref_or_null访问类型
-- 查找索引值为特定值或NULL的记录

EXPLAIN SELECT * FROM employees 
WHERE dept_id = 10 OR dept_id IS NULL;

特点：
• 在ref基础上增加NULL值查找
• 比单纯ref稍慢，但仍然高效
• 用于处理可能包含NULL值的索引列
```

### 2.4 索引合并类型


**🔀 index_merge - 索引合并**
```sql
-- 创建多个单列索引
CREATE TABLE products (
    id INT PRIMARY KEY,
    category_id INT,
    price DECIMAL(10,2),
    status TINYINT,
    INDEX idx_category(category_id),
    INDEX idx_price(price),
    INDEX idx_status(status)
);

-- index_merge示例  
EXPLAIN SELECT * FROM products 
WHERE category_id = 1 OR price > 1000;

EXPLAIN SELECT * FROM products 
WHERE category_id = 1 AND status = 1;

特点：
• MySQL使用多个索引，然后合并结果
• 通常比单一索引慢，但比全表扫描快
• 出现在OR条件或多个AND条件中
• 建议创建复合索引替代
```

### 2.5 子查询访问类型


**🔍 unique_subquery - 唯一子查询**
```sql
-- unique_subquery示例
EXPLAIN SELECT * FROM departments 
WHERE dept_id IN (
    SELECT DISTINCT dept_id FROM employees WHERE salary > 5000
);

特点：
• 用于处理IN子查询，子查询返回唯一值
• 比普通子查询效率更高
• 会被优化器改写为更高效的形式
```

**📋 index_subquery - 索引子查询**
```sql
-- index_subquery示例
EXPLAIN SELECT * FROM departments 
WHERE dept_id IN (
    SELECT dept_id FROM employees WHERE hire_date > '2020-01-01'
);

特点：
• 用于处理IN子查询，使用索引优化
• 性能中等，优于全表扫描
• 现代MySQL版本中较少出现
```

### 2.6 低效访问类型


**📊 range - 范围扫描**
```sql
-- range访问类型
EXPLAIN SELECT * FROM employees WHERE emp_id BETWEEN 1000 AND 2000;
EXPLAIN SELECT * FROM employees WHERE hire_date > '2020-01-01';
EXPLAIN SELECT * FROM employees WHERE dept_id IN (1, 2, 3);
EXPLAIN SELECT * FROM employees WHERE emp_name LIKE 'John%';

特点：
• 使用索引进行范围扫描
• 包括：>、<、>=、<=、BETWEEN、IN、LIKE前缀匹配
• 性能中等，比全表扫描好很多
• 扫描的行数取决于范围大小
```

**🔍 index - 索引全扫描**
```sql
-- index访问类型
-- 扫描整个索引，但不访问数据行

EXPLAIN SELECT emp_id FROM employees ORDER BY emp_id;
EXPLAIN SELECT COUNT(*) FROM employees;

特点：
• 只扫描索引树，不访问表数据
• 比ALL快，因为索引通常比表小
• 常见于COUNT(*)或只需要索引列的查询
• 仍然需要读取整个索引
```

**⚠️ ALL - 全表扫描**
```sql
-- ALL访问类型（最慢）
EXPLAIN SELECT * FROM employees WHERE UPPER(emp_name) = 'JOHN';
EXPLAIN SELECT * FROM employees WHERE salary * 1.1 > 5000;
EXPLAIN SELECT * FROM employees WHERE emp_name LIKE '%john%';

特点：
• 扫描整个表的所有行
• 性能最差，尤其是大表
• 通常是索引缺失或查询条件无法使用索引
• 需要优先优化的访问类型
```

---

## 3. ⚡ 访问类型性能排序


### 3.1 性能排序表


**📊 访问类型性能对比**

| 访问类型 | **性能等级** | **扫描行数** | **使用场景** | **优化建议** |
|---------|-------------|-------------|-------------|-------------|
| `system` | `🟢 最优` | `0-1行` | `单行表` | `无需优化` |
| `const` | `🟢 极优` | `1行` | `主键/唯一索引等值` | `保持现状` |
| `eq_ref` | `🟢 很好` | `1行/连接` | `JOIN主键/唯一索引` | `保持现状` |
| `ref` | `🟡 良好` | `少量行` | `普通索引等值` | `考虑唯一索引` |
| `fulltext` | `🟡 中等` | `匹配行` | `全文搜索` | `优化搜索词` |
| `ref_or_null` | `🟡 中等` | `少量行+NULL` | `索引+NULL查询` | `避免NULL值` |
| `index_merge` | `🟡 中等` | `多索引合并` | `多条件查询` | `建复合索引` |
| `unique_subquery` | `🟡 中等` | `子查询结果` | `IN子查询` | `改写为JOIN` |
| `index_subquery` | `🟡 中等` | `子查询结果` | `IN子查询` | `改写为JOIN` |
| `range` | `🟠 一般` | `范围内行数` | `范围查询` | `缩小范围` |
| `index` | `🔴 较差` | `索引全部` | `索引覆盖` | `添加WHERE条件` |
| `ALL` | `🔴 最差` | `表全部行` | `全表扫描` | `添加索引` |

### 3.2 性能基准测试


**🧪 实际性能测试**
```sql
-- 创建测试表（100万行数据）
CREATE TABLE perf_test (
    id INT PRIMARY KEY,
    category INT,
    value INT,
    name VARCHAR(50),
    created_date DATE,
    INDEX idx_category(category),
    INDEX idx_value(value),
    INDEX idx_name(name),
    INDEX idx_date(created_date)
);

-- 填充测试数据
INSERT INTO perf_test 
SELECT 
    n,
    n % 100,
    ROUND(RAND() * 10000),
    CONCAT('name_', n),
    DATE_ADD('2020-01-01', INTERVAL n % 1460 DAY)
FROM (
    -- 生成100万行数据的子查询
    SELECT (@row_number:=@row_number + 1) as n
    FROM information_schema.columns c1, information_schema.columns c2,
         (SELECT @row_number:=0) r
    LIMIT 1000000
) numbers;

-- 性能测试对比
-- const访问（最快）
SELECT SQL_NO_CACHE * FROM perf_test WHERE id = 500000;

-- ref访问
SELECT SQL_NO_CACHE * FROM perf_test WHERE category = 50;

-- range访问  
SELECT SQL_NO_CACHE * FROM perf_test WHERE id BETWEEN 400000 AND 500000;

-- index访问
SELECT SQL_NO_CACHE COUNT(*) FROM perf_test;

-- ALL访问（最慢）
SELECT SQL_NO_CACHE * FROM perf_test WHERE name LIKE '%500%';
```

---

## 4. 🧠 访问类型选择决策逻辑


### 4.1 MySQL优化器决策流程


**🔍 优化器如何选择访问类型**
```
MySQL优化器决策流程：

1. 解析查询条件
   ↓
2. 检查可用索引
   ↓
3. 估算各种访问方式的成本
   ↓
4. 选择成本最低的访问类型
   ↓
5. 生成执行计划

成本估算因素：
• 索引选择性（唯一性）
• 数据分布情况
• 表大小和索引大小
• I/O成本和CPU成本
```

### 4.2 决策规则详解


**📋 访问类型选择规则**
```sql
-- 规则1：主键或唯一索引等值查询 → const
SELECT * FROM table WHERE primary_key = value;
SELECT * FROM table WHERE unique_index = value;

-- 规则2：JOIN中使用主键或唯一索引 → eq_ref  
SELECT * FROM t1 JOIN t2 ON t1.id = t2.primary_key;

-- 规则3：普通索引等值查询 → ref
SELECT * FROM table WHERE normal_index = value;

-- 规则4：索引范围查询 → range
SELECT * FROM table WHERE indexed_col > value;
SELECT * FROM table WHERE indexed_col BETWEEN v1 AND v2;

-- 规则5：无合适索引 → ALL
SELECT * FROM table WHERE non_indexed_col = value;
```

### 4.3 成本模型分析


**💰 查看优化器成本计算**
```sql
-- 查看优化器成本信息（MySQL 5.7+）
EXPLAIN FORMAT=JSON 
SELECT * FROM perf_test WHERE category = 50;

-- 分析输出中的成本信息
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "20108.60",    -- 总查询成本
      "eval_cost": "4021.60",      -- 计算成本
      "data_read_per_join": "1M"   -- 读取数据量
    },
    "table": {
      "table_name": "perf_test",
      "access_type": "ref",         -- 访问类型
      "possible_keys": ["idx_category"],
      "key": "idx_category",
      "cost_info": {
        "read_cost": "16087.00",    -- I/O成本
        "eval_cost": "4021.60",     -- CPU成本
        "prefix_cost": "20108.60",  -- 前缀成本
        "data_read_per_join": "1M"
      }
    }
  }
}
```

---

## 5. 🛠️ 访问类型优化策略


### 5.1 从ALL到range的优化


**⚠️ 全表扫描优化**
```sql
-- 问题查询：全表扫描
EXPLAIN SELECT * FROM perf_test WHERE name LIKE '%test%';
-- type: ALL, rows: 1000000

-- 优化方案1：前缀索引
CREATE INDEX idx_name_prefix ON perf_test(name(10));
EXPLAIN SELECT * FROM perf_test WHERE name LIKE 'test%';
-- type: range, rows: 估计少很多

-- 优化方案2：全文索引（适合文本搜索）
ALTER TABLE perf_test ADD FULLTEXT(name);
EXPLAIN SELECT * FROM perf_test 
WHERE MATCH(name) AGAINST('test' IN BOOLEAN MODE);
-- type: fulltext

-- 优化方案3：添加辅助列
ALTER TABLE perf_test ADD COLUMN name_hash INT;
UPDATE perf_test SET name_hash = CRC32(name);
ALTER TABLE perf_test ADD INDEX idx_hash(name_hash);

EXPLAIN SELECT * FROM perf_test 
WHERE name_hash = CRC32('specific_name') AND name = 'specific_name';
-- type: ref
```

### 5.2 从range到ref的优化


**📊 范围查询优化**
```sql
-- 问题查询：范围扫描行数过多
EXPLAIN SELECT * FROM perf_test WHERE category BETWEEN 10 AND 90;
-- type: range, rows: 800000 (太多了)

-- 优化方案1：缩小查询范围
EXPLAIN SELECT * FROM perf_test WHERE category = 50;
-- type: ref, rows: 10000 (好很多)

-- 优化方案2：添加复合索引
CREATE INDEX idx_category_date ON perf_test(category, created_date);
EXPLAIN SELECT * FROM perf_test 
WHERE category BETWEEN 10 AND 20 AND created_date = '2023-01-01';
-- type: range, 但扫描行数大幅减少

-- 优化方案3：分区表
-- 如果经常按时间范围查询，考虑按日期分区
```

### 5.3 从ref到const的优化


**🎯 精确查询优化**
```sql
-- 当前情况：普通索引查询
EXPLAIN SELECT * FROM perf_test WHERE category = 1;
-- type: ref, rows: 10000

-- 优化方案：如果category值唯一，改为唯一索引
ALTER TABLE perf_test DROP INDEX idx_category;
ALTER TABLE perf_test ADD UNIQUE KEY uk_category(category);
EXPLAIN SELECT * FROM perf_test WHERE category = 1;
-- type: const, rows: 1
```

### 5.4 index_merge优化


**🔀 索引合并优化**
```sql
-- 问题查询：索引合并
EXPLAIN SELECT * FROM perf_test 
WHERE category = 50 OR value > 9000;
-- type: index_merge

-- 优化方案1：改写为UNION
(SELECT * FROM perf_test WHERE category = 50)
UNION
(SELECT * FROM perf_test WHERE value > 9000);

-- 优化方案2：根据实际情况选择单一条件
-- 如果category=50的结果集已经足够
SELECT * FROM perf_test WHERE category = 50;

-- 优化方案3：创建覆盖索引（如果只需要特定列）
CREATE INDEX idx_cover ON perf_test(category, value, id);
```

---

## 6. 🔄 混合访问类型分析


### 6.1 多表JOIN的访问类型组合


**🔗 JOIN查询访问类型分析**
```sql
-- 创建关联测试表
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    status TINYINT,
    INDEX idx_customer(customer_id),
    INDEX idx_date(order_date)
);

CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    customer_name VARCHAR(100),
    city VARCHAR(50),
    INDEX idx_city(city)
);

-- 分析复合JOIN查询
EXPLAIN SELECT 
    c.customer_name,
    o.order_date,
    o.status
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE c.city = 'Beijing'
  AND o.order_date > '2023-01-01';

-- 访问类型组合分析：
-- customers表：ref (city索引)
-- orders表：ref 或 eq_ref (取决于连接条件)
```

### 6.2 子查询中的访问类型


**📋 子查询访问类型优化**
```sql
-- 问题：子查询导致的低效访问
EXPLAIN SELECT * FROM customers 
WHERE customer_id IN (
    SELECT customer_id FROM orders WHERE status = 1
);

-- 可能的访问类型：
-- 主查询：ALL 或 range
-- 子查询：ref 或 index_subquery

-- 优化：改写为JOIN
EXPLAIN SELECT DISTINCT c.* 
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.status = 1;

-- 优化后访问类型：
-- customers：eq_ref 或 ref
-- orders：ref
```

### 6.3 访问类型降级分析


**⚠️ 访问类型为什么会降级**
```sql
-- 原本应该是const，但降级为ref
-- 原因：数据类型不匹配
EXPLAIN SELECT * FROM perf_test WHERE id = '123456';  -- 字符串
-- 应该改为
EXPLAIN SELECT * FROM perf_test WHERE id = 123456;    -- 数字

-- 原本应该是ref，但降级为ALL  
-- 原因：函数包装索引列
EXPLAIN SELECT * FROM perf_test WHERE UPPER(name) = 'TEST';
-- 应该改为
EXPLAIN SELECT * FROM perf_test WHERE name = 'test';

-- 原本应该是range，但变成ALL
-- 原因：OR条件中包含非索引列
EXPLAIN SELECT * FROM perf_test WHERE category = 1 OR name = 'test';
-- 应该改为UNION或创建复合索引
```

---

## 7. 📈 监控与性能评估


### 7.1 访问类型监控指标


**📊 关键监控指标**
```sql
-- 查看慢查询中的访问类型分布
SELECT 
    SUBSTRING_INDEX(SUBSTRING_INDEX(sql_text, 'type: ', -1), ',', 1) as access_type,
    COUNT(*) as count,
    AVG(query_time) as avg_time,
    MAX(query_time) as max_time
FROM mysql.slow_log
WHERE sql_text LIKE '%EXPLAIN%'
GROUP BY access_type
ORDER BY avg_time DESC;

-- 监控全表扫描的频率
SELECT 
    table_schema,
    table_name,
    select_full_join,
    select_scan
FROM information_schema.table_statistics
WHERE select_scan > 1000  -- 全表扫描次数大于1000
ORDER BY select_scan DESC;
```

### 7.2 性能预测模型


**🔮 访问类型性能预测**
```sql
-- 基于统计信息预测查询性能
SELECT 
    table_name,
    table_rows,
    CASE 
        WHEN cardinality = table_rows THEN 'const候选'
        WHEN cardinality > table_rows * 0.8 THEN 'ref高效'
        WHEN cardinality > table_rows * 0.1 THEN 'ref一般'
        ELSE 'range或ALL'
    END as predicted_access_type,
    ROUND(table_rows / GREATEST(cardinality, 1), 2) as estimated_rows
FROM information_schema.statistics s
JOIN information_schema.tables t ON s.table_name = t.table_name
WHERE s.table_schema = 'your_database'
  AND t.table_rows > 1000
ORDER BY estimated_rows DESC;
```

### 7.3 自动化优化建议


**🤖 智能优化推荐系统**
```sql
-- 创建访问类型优化建议视图
CREATE VIEW v_access_type_recommendations AS
SELECT 
    table_schema,
    table_name,
    column_name,
    CASE 
        WHEN nullable = 'YES' AND cardinality < 10 
        THEN '建议：考虑添加NOT NULL约束'
        WHEN cardinality = 1 
        THEN '建议：该列值单一，考虑删除索引'
        WHEN cardinality < table_rows * 0.01 
        THEN '建议：低选择性索引，考虑复合索引'
        WHEN cardinality = table_rows 
        THEN '建议：高选择性，适合唯一索引'
        ELSE '当前索引配置合理'
    END as recommendation,
    cardinality,
    table_rows,
    ROUND(cardinality * 100.0 / table_rows, 2) as selectivity_percent
FROM information_schema.statistics s
JOIN information_schema.tables t USING(table_schema, table_name)
JOIN information_schema.columns c USING(table_schema, table_name, column_name)
WHERE s.table_schema NOT IN ('information_schema', 'mysql', 'performance_schema')
  AND t.table_rows > 100;

-- 查看优化建议
SELECT * FROM v_access_type_recommendations
WHERE recommendation != '当前索引配置合理'
ORDER BY table_name, selectivity_percent;
```

### 7.4 告警体系设计


**🚨 访问类型告警规则**
```sql
-- 识别需要告警的查询模式
-- 1. 大表全表扫描告警
SELECT 
    'TABLE_SCAN_ALERT' as alert_type,
    CONCAT(table_schema, '.', table_name) as object_name,
    table_rows as severity_indicator,
    '大表全表扫描风险' as alert_message
FROM information_schema.tables
WHERE table_rows > 100000
  AND table_name IN (
      SELECT table_name FROM information_schema.table_statistics
      WHERE select_scan > select_full_join
  );

-- 2. 索引使用率过低告警  
SELECT 
    'INDEX_UNUSED_ALERT' as alert_type,
    CONCAT(table_schema, '.', table_name, '.', index_name) as object_name,
    0 as severity_indicator,
    '索引从未被使用' as alert_message
FROM information_schema.statistics
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema')
  AND index_name NOT IN (
      SELECT DISTINCT index_name 
      FROM performance_schema.table_io_waits_summary_by_index_usage
      WHERE count_star > 0
  );
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 访问类型的本质理解**
```
访问类型 = MySQL查找数据的方法
性能排序：system > const > eq_ref > ref > range > index > ALL
优化目标：让查询尽可能使用高效的访问类型
核心原则：索引是访问类型优化的基础
```

**🔸 各访问类型的适用场景**
```
const：主键或唯一索引等值查询，性能最优
ref：普通索引等值查询，最常见的高效类型  
range：索引范围查询，性能中等但可接受
ALL：全表扫描，需要重点优化
```

### 8.2 实际优化策略


**🔹 优化优先级**
```
第一优先级：消除ALL（全表扫描）
• 添加合适的索引
• 重写查询条件
• 避免函数包装索引列

第二优先级：优化range查询
• 缩小查询范围
• 创建复合索引
• 考虑数据分区

第三优先级：提升ref到const
• 使用唯一索引
• 优化查询条件的精确性
```

**🔹 索引设计原则**
```
单列索引：
• 高选择性列适合单独建索引
• 经常用于等值查询的列

复合索引：
• 多个查询条件组合使用
• 遵循最左前缀原则
• WHERE + ORDER BY场景

唯一索引：
• 数据天然唯一的列
• 可以将ref提升为const
```

### 8.3 监控和维护要点


**🎯 关键监控指标**
```
查询性能：
• 慢查询中ALL类型的比例
• 平均查询扫描行数
• 索引使用率统计

系统资源：
• CPU使用率（全表扫描消耗大）
• I/O压力（低效查询影响）
• 缓存命中率
```

**🛠️ 维护最佳实践**
```
定期检查：
• 执行计划分析
• 慢查询日志审计
• 索引使用情况统计

持续优化：
• 根据业务变化调整索引
• 清理无用索引
• 监控新的性能问题
```

**💡 实际应用建议**
- **理解业务**：了解查询模式，设计合适的索引策略
- **监控为先**：建立完善的性能监控体系
- **渐进优化**：从最严重的问题开始，逐步优化
- **测试验证**：优化前后对比，确保效果
- **文档记录**：记录优化过程和效果，便于后续维护

**核心记忆**：
- 访问类型体现查询效率，ALL最慢const最快
- 索引是优化访问类型的核心工具
- 监控执行计划，及时发现性能问题
- 业务理解+技术优化=最佳性能表现