---
title: 6、查询优化器原理
---
## 📚 目录

1. [查询优化器概述](#1-查询优化器概述)
2. [基于成本的优化器](#2-基于成本的优化器)
3. [查询重写规则引擎](#3-查询重写规则引擎)
4. [优化算法核心原理](#4-优化算法核心原理)
5. [执行计划生成机制](#5-执行计划生成机制)
6. [优化器架构设计](#6-优化器架构设计)
7. [性能监控与调优](#7-性能监控与调优)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧠 查询优化器概述


### 1.1 什么是查询优化器


**🔸 通俗理解**
查询优化器就像一个超级聪明的GPS导航系统，当你告诉它"我要从A到B"时，它会：
- 分析所有可能的路线
- 计算每条路线的成本（时间、油费、拥堵等）
- 选择最优路线给你

对于SQL查询，优化器做的是同样的事情：
- 分析所有可能的执行方式
- 计算每种方式的成本（CPU、IO、内存等）
- 选择成本最低的执行计划

### 1.2 优化器的核心职责


```
SQL语句 ──▶ 语法分析 ──▶ 语义分析 ──▶ 查询优化 ──▶ 执行计划
   │          │          │          │          │
   │          ▼          ▼          ▼          ▼
用户意图    语法树    逻辑计划    物理计划    可执行代码
```

**🔸 优化器要解决的核心问题**

> 💡 **核心理解**  
> 同一个SQL查询可能有成千上万种执行方式，优化器的任务就是在有限时间内找到成本最低的那一种。

| 优化问题 | **具体表现** | **示例场景** | **优化目标** |
|---------|-------------|-------------|-------------|
| 🛣️ **访问路径选择** | `全表扫描 vs 索引扫描` | `WHERE id = 1` | `最小化IO操作` |
| 🔗 **连接顺序优化** | `表A先连表B还是表B先连表A` | `多表JOIN查询` | `最小化中间结果集` |
| 📊 **连接算法选择** | `嵌套循环 vs 哈希连接` | `大表连接小表` | `最小化CPU和内存消耗` |
| 🔄 **查询重写** | `子查询转换为连接` | `EXISTS子查询` | `避免重复计算` |

### 1.3 优化器版本演进


**🔸 MySQL优化器发展历程**

```
MySQL优化器发展时间线：
MySQL 5.1 ──▶ MySQL 5.5 ──▶ MySQL 5.7 ──▶ MySQL 8.0
    │           │           │           │
    ▼           ▼           ▼           ▼
基础RBO     引入CBO    增强统计   机器学习优化
规则导向    成本导向    直方图     自适应优化
```

---

## 2. 💰 基于成本的优化器


### 2.1 成本模型基础


**🔸 什么是基于成本的优化(CBO)**
基于成本的优化就像购物时比价，不同的执行方案就像不同的商品，我们要找到"性价比"最高的那个：

> 💡 **形象比喻**  
> 你要买一台电脑，有三种选择：
> - 方案A：性能高，价格贵
> - 方案B：性能中等，价格适中  
> - 方案C：性能低，价格便宜
> 
> 优化器就是帮你算出哪个方案的"性价比"最高。

**🔸 成本计算公式**
```
总成本 = CPU成本 + IO成本 + 网络成本 + 内存成本

具体计算：
CPU成本 = 处理行数 × CPU_COST_PER_ROW
IO成本 = 读取页数 × IO_COST_PER_PAGE  
内存成本 = 使用内存 × MEMORY_COST_PER_BYTE
```

### 2.2 统计信息使用


**🔸 统计信息的作用**
统计信息就像地图上的交通信息，告诉优化器"这条路堵不堵"：

```sql
-- 查看表的统计信息
SHOW TABLE STATUS LIKE 'users';

-- 查看索引统计信息
SHOW INDEX FROM users;

-- 查看列的统计信息（MySQL 8.0+）
SELECT * FROM information_schema.COLUMN_STATISTICS 
WHERE SCHEMA_NAME = 'test' AND TABLE_NAME = 'users';
```

**🔸 关键统计信息类型**

| 统计信息 | **作用** | **影响决策** | **更新方式** |
|---------|---------|-------------|-------------|
| 📊 **表行数** | `估算扫描成本` | `全表扫描vs索引选择` | `自动采样` |
| 📈 **索引基数** | `估算过滤效果` | `索引选择优先级` | `定期重建` |
| 📉 **数据分布** | `估算范围查询结果` | `连接顺序选择` | `直方图统计` |
| 🔍 **空值比例** | `估算IS NULL查询` | `索引使用策略` | `实时计算` |

### 2.3 查询复杂度评估模型


**🔸 复杂度评估维度**

```
查询复杂度 = f(表数量, 连接条件, WHERE条件, GROUP BY, ORDER BY)

评估公式：
基础复杂度 = 表数量的阶乘 (N!)
连接复杂度 = 连接方式数量的指数级
过滤复杂度 = WHERE条件的组合数
排序复杂度 = 排序字段和数据量
```

**🔸 复杂度示例分析**

```sql
-- 简单查询 (复杂度: 低)
SELECT * FROM users WHERE id = 1;

-- 中等复杂查询 (复杂度: 中)  
SELECT u.name, o.amount 
FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.age > 18;

-- 高复杂查询 (复杂度: 高)
SELECT u.name, COUNT(o.id), AVG(p.price)
FROM users u 
JOIN orders o ON u.id = o.user_id
JOIN products p ON o.product_id = p.id
WHERE u.create_time > '2023-01-01'
GROUP BY u.id 
HAVING COUNT(o.id) > 5
ORDER BY AVG(p.price) DESC;
```

---

## 3. 🔄 查询重写规则引擎


### 3.1 查询转换规则


**🔸 常见查询重写规则**

查询重写就像数学中的等式变换，把复杂的表达式转换为更简单高效的形式：

> 💡 **数学类比**  
> 就像 2×4 可以重写为 8，(a+b)×c 可以重写为 a×c + b×c 一样，SQL查询也可以进行等价变换。

**🔸 核心重写规则类型**

```sql
-- 1. 子查询转换为连接
-- 原始查询：
SELECT * FROM users 
WHERE id IN (SELECT user_id FROM orders WHERE amount > 100);

-- 重写后：  
SELECT DISTINCT u.* FROM users u 
INNER JOIN orders o ON u.id = o.user_id 
WHERE o.amount > 100;
```

```sql
-- 2. EXISTS转换为连接
-- 原始查询：
SELECT * FROM users u 
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);

-- 重写后：
SELECT DISTINCT u.* FROM users u 
INNER JOIN orders o ON u.id = o.user_id;
```

```sql
-- 3. 常量折叠
-- 原始查询：
SELECT * FROM users WHERE age > 10 + 8;

-- 重写后：
SELECT * FROM users WHERE age > 18;
```

### 3.2 代数优化与启发式优化


**🔸 代数优化原理**

代数优化基于关系代数的等价变换规则，确保变换前后查询结果完全一致：

```
关系代数优化规则：
1. 选择下推：σ(R ⋈ S) = σ(R) ⋈ σ(S)
2. 投影下推：π(R ⋈ S) = π(π(R) ⋈ π(S))  
3. 连接交换律：R ⋈ S = S ⋈ R
4. 连接结合律：(R ⋈ S) ⋈ T = R ⋈ (S ⋈ T)
```

**🔸 启发式优化策略**

| 启发式规则 | **优化原理** | **适用场景** | **效果** |
|-----------|-------------|-------------|---------|
| 🔽 **选择下推** | `尽早过滤数据` | `多表连接前过滤` | `减少连接数据量` |
| 📊 **投影下推** | `只读取需要的列` | `大表查询` | `减少IO和内存` |
| 🔀 **连接重排序** | `小表驱动大表` | `多表连接` | `减少中间结果` |
| 🧮 **常量计算** | `预计算常量表达式` | `复杂计算` | `避免重复计算` |

### 3.3 优化器多阶段处理


**🔸 多阶段优化流程**

```
                    优化器多阶段处理架构
┌─────────────────────────────────────────────────────────┐
│                    第1阶段：语法优化                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ 常量折叠    │  │ 表达式简化  │  │ 死代码消除  │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
├─────────────────────────────────────────────────────────┤
│                    第2阶段：逻辑优化                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ 子查询重写  │  │ 谓词下推    │  │ 连接消除    │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
├─────────────────────────────────────────────────────────┤
│                    第3阶段：物理优化                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ 访问路径    │  │ 连接算法    │  │ 连接顺序    │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 🤖 优化算法核心原理


### 4.1 动态规划算法应用


**🔸 动态规划在优化器中的应用**

动态规划就像解决"最短路径"问题，把大问题分解为小问题，避免重复计算：

> 💡 **经典比喻**  
> 就像计算斐波那契数列，如果每次都从头算会很慢，但如果记住中间结果，就能快速得出答案。优化器也是这样处理复杂查询的。

```
动态规划优化连接顺序：

3表连接 A,B,C 的所有可能：
├─ (A⋈B)⋈C  成本:C1
├─ (A⋈C)⋈B  成本:C2  
├─ (B⋈A)⋈C  成本:C3
├─ (B⋈C)⋈A  成本:C4
├─ (C⋈A)⋈B  成本:C5
└─ (C⋈B)⋈A  成本:C6

动态规划避免重复计算：
保存 A⋈B, A⋈C, B⋈C 的中间结果
后续计算直接使用，不重复计算
```

### 4.2 贪心算法连接顺序


**🔸 贪心算法优化策略**

贪心算法就像"每一步都选当前最好的"，虽然不一定全局最优，但速度快：

```sql
-- 贪心算法示例：
-- 有3个表 users(1000行), orders(10000行), products(100行)
-- 连接条件都是等值连接

-- 贪心选择：总是选择结果集最小的连接
-- 第1步：products ⋈ orders (因为products最小)  
-- 第2步：结果 ⋈ users
```

**🔸 算法对比**

| 算法类型 | **优化质量** | **计算时间** | **适用场景** |
|---------|-------------|-------------|-------------|
| 🎯 **动态规划** | `最优解` | `指数级增长` | `≤10个表` |
| 🏃 **贪心算法** | `近似解` | `线性时间` | `>10个表` |
| 🔍 **启发式** | `较好解` | `多项式时间` | `复杂查询` |

### 4.3 优化器决策算法深度分析


**🔸 访问路径选择算法**

```
访问路径选择决策树：
查询条件
    ├─ 主键等值查询 ──▶ 主键索引 (成本最低)
    ├─ 唯一键等值查询 ──▶ 唯一索引
    ├─ 普通等值查询 ──▶ 比较索引扫描 vs 全表扫描
    ├─ 范围查询 ──▶ 评估选择性选择索引
    └─ 无合适索引 ──▶ 全表扫描
```

**🔸 连接算法选择决策**

```sql
-- 连接算法选择逻辑
IF (内表有索引 AND 外表较小) THEN
    使用嵌套循环连接 (Nested Loop Join)
ELSIF (两表都较大 AND 内存充足) THEN  
    使用哈希连接 (Hash Join)
ELSIF (两表都有序 OR 可排序) THEN
    使用排序合并连接 (Sort-Merge Join)  
ELSE
    使用块嵌套循环连接 (Block Nested Loop)
END IF
```

---

## 5. 📋 执行计划生成机制


### 5.1 查询执行计划生成


**🔸 执行计划是什么**
执行计划就像施工图纸，详细描述了如何"建造"查询结果：

```sql
-- 查看执行计划的方法
EXPLAIN SELECT u.name, COUNT(o.id) 
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
WHERE u.age > 25 
GROUP BY u.id;
```

**🔸 执行计划关键信息解读**

| 字段 | **含义** | **重要指标** | **优化方向** |
|------|---------|-------------|-------------|
| 🔍 **type** | `访问类型` | `const > ref > range > index > ALL` | `避免ALL扫描` |
| 🔑 **key** | `使用的索引` | `有索引 > 无索引` | `合理创建索引` |
| 📊 **rows** | `预计扫描行数` | `越少越好` | `优化WHERE条件` |
| 📋 **Extra** | `额外信息` | `Using index > Using filesort` | `避免临时表和排序` |

### 5.2 查询计划缓存策略


**🔸 计划缓存机制**

```
查询计划缓存流程：
SQL解析 ──▶ 计划缓存查找 ──命中？──Yes──▶ 直接使用缓存计划
   │           │              │
   │           │              └─No─▶ 生成新计划 ──▶ 存入缓存
   │           │                      │
   │           └────── 缓存管理 ◀──────┘
   │                    │
   │                    ▼
   └────── LRU淘汰 ◀─── 缓存空间管理
```

**🔸 缓存策略设计考虑**

> ⚠️ **注意事项**  
> 计划缓存虽然能提高性能，但也要考虑缓存失效的情况：统计信息更新、表结构变更、参数值变化都可能导致原计划不再最优。

```sql
-- MySQL查询缓存相关变量（MySQL 8.0已移除）
-- 这里仅作原理说明
SHOW VARIABLES LIKE 'query_cache%';

-- 查看预处理语句缓存
SHOW GLOBAL STATUS LIKE 'Com_stmt%';
```

### 5.3 优化器扩展性架构


**🔸 插件化架构设计**

```
           优化器扩展性架构
┌─────────────────────────────────────┐
│            优化器核心               │
│  ┌─────────────┐ ┌─────────────┐    │
│  │  规则引擎   │ │  成本模型   │    │
│  └─────────────┘ └─────────────┘    │
├─────────────────────────────────────┤
│              插件接口               │
│  ┌─────────────┐ ┌─────────────┐    │
│  │ 自定义规则  │ │ 自定义成本  │    │
│  │   插件      │ │   模型     │    │
│  └─────────────┘ └─────────────┘    │
├─────────────────────────────────────┤
│            扩展机制                 │
│  ┌─────────────┐ ┌─────────────┐    │
│  │ 存储引擎    │ │ 用户定义    │    │
│  │  优化器     │ │   函数     │    │
│  └─────────────┘ └─────────────┘    │
└─────────────────────────────────────┘
```

---

## 6. 🏗️ 优化器架构设计


### 6.1 优化器插件架构


**🔸 插件架构的优势**

> 💡 **设计理念**  
> 就像手机的APP生态，核心系统提供基础功能，第三方可以开发插件扩展特定功能。MySQL优化器也采用了类似的插件化设计。

```
插件架构层次：
┌─ 应用层 ─┐
│ 业务查询  │ ← 用户SQL查询
├─ 接口层 ─┤  
│ 优化器API │ ← 标准优化接口
├─ 插件层 ─┤
│ 规则插件  │ ← 可扩展优化规则
│ 成本插件  │ ← 可扩展成本模型
├─ 核心层 ─┤
│ 优化框架  │ ← 核心优化逻辑
└─ 引擎层 ─┘
│ 存储引擎  │ ← InnoDB、MyISAM等
```

### 6.2 优化器学习机制设计


**🔸 自适应优化机制**

现代优化器开始引入机器学习技术，让优化器能够"学习"和"进化"：

```
学习机制工作流程：
历史查询 ──▶ 执行统计 ──▶ 模式识别 ──▶ 策略调整
    │          │          │          │
    ▼          ▼          ▼          ▼
查询模式    性能数据    学习算法    优化策略
收集        采集        训练        更新
```

**🔸 学习机制应用场景**

| 学习场景 | **学习内容** | **调整策略** | **效果** |
|---------|-------------|-------------|---------|
| 📊 **数据分布学习** | `热点数据模式` | `调整索引使用策略` | `提高缓存命中率` |
| ⏱️ **执行时间学习** | `实际vs预估时间` | `调整成本模型参数` | `提高预估准确性` |
| 🔄 **查询模式学习** | `常见查询类型` | `预编译执行计划` | `减少优化时间` |

### 6.3 优化器扩展机制


**🔸 扩展点设计**

```sql
-- 自定义优化提示（MySQL 8.0+）
SELECT /*+ USE_INDEX(users, idx_age) */ name 
FROM users 
WHERE age > 25;

-- 自定义成本常数
SET optimizer_search_depth = 10;
SET optimizer_prune_level = 1;

-- 查看优化器开关
SELECT $$optimizer_switch;
```

---

## 7. 📊 性能监控与调优


### 7.1 优化器性能监控


**🔸 监控关键指标**

```sql
-- 优化器性能监控查询
-- 1. 查看优化器统计信息
SHOW STATUS LIKE 'Select%';
SHOW STATUS LIKE 'Sort%';
SHOW STATUS LIKE 'Handler%';

-- 2. 查看慢查询统计
SHOW VARIABLES LIKE 'slow_query%';
SHOW STATUS LIKE 'Slow_queries';

-- 3. 查看执行计划缓存命中率
SHOW STATUS LIKE 'Qcache%';
```

**🔸 性能监控维度**

| 监控维度 | **关键指标** | **正常范围** | **异常表现** |
|---------|-------------|-------------|-------------|
| ⚡ **优化耗时** | `优化器处理时间` | `< 10ms` | `频繁超时` |
| 🎯 **计划准确性** | `实际vs预估行数` | `误差 < 50%` | `预估严重偏差` |
| 💾 **缓存命中率** | `计划缓存命中率` | `> 80%` | `缓存频繁失效` |
| 🔄 **重优化频率** | `计划重新生成` | `< 5%` | `频繁重新优化` |

### 7.2 优化器调优策略


**🔸 常见调优参数**

```sql
-- 优化器相关参数调优
SET optimizer_search_depth = 62;        -- 搜索深度
SET optimizer_prune_level = 1;          -- 剪枝级别  
SET optimizer_use_condition_selectivity = 1; -- 条件选择性
SET optimizer_switch = 'mrr=on,mrr_cost_based=on'; -- 优化开关
```

**🔸 调优最佳实践**

> 🚀 **调优建议**  
> 优化器调优要遵循"先监控，再分析，后调整"的原则，不要盲目修改参数。

```
调优步骤：
1. 收集性能基线数据
2. 识别性能瓶颈点  
3. 分析根本原因
4. 制定调优方案
5. 逐步应用调整
6. 验证调优效果
```

---

## 8. 📋 核心要点总结


### 8.1 优化器工作原理总结


**🔑 核心理解要点**

> 💡 **本质理解**  
> 查询优化器是数据库的"大脑"，它的智能程度直接决定了数据库的性能表现。理解优化器原理是数据库调优的基础。

**🔸 优化器核心能力**
- **成本评估**：能准确评估不同执行方案的成本
- **规则应用**：灵活应用各种优化规则
- **算法选择**：根据数据特征选择最适合的算法
- **自适应学习**：从历史执行中学习优化经验

### 8.2 关键技术要点


| 技术领域 | **核心技术** | **应用场景** | **优化效果** |
|---------|-------------|-------------|-------------|
| 🧮 **成本模型** | `统计信息驱动的成本计算` | `执行路径选择` | `提高选择准确性` |
| 🔄 **查询重写** | `等价变换规则` | `复杂查询简化` | `减少执行成本` |
| 🤖 **智能算法** | `动态规划、贪心算法` | `多表连接优化` | `找到最优连接顺序` |
| 📊 **缓存机制** | `执行计划缓存` | `重复查询加速` | `减少优化开销` |

### 8.3 实践应用指导


**🔸 掌握程度自测**
- [x] 理解优化器的基本工作原理
- [x] 能看懂执行计划的关键信息
- [x] 了解查询重写的常见规则  
- [x] 掌握优化器监控方法
- [ ] 能够进行高级优化器调优
- [ ] 理解机器学习在优化器中的应用

**🔸 学习建议**

> 🚀 **进阶方向**  
> 1. 深入学习执行计划分析技巧
> 2. 掌握索引设计和优化策略  
> 3. 研究存储引擎与优化器的交互
> 4. 关注新版本优化器特性

**🔸 核心记忆要点**
```
优化器如GPS导航，分析路径选最优
成本模型做评估，统计信息是基础
查询重写用规则，等价变换降成本  
算法选择有策略，动态规划找最优
缓存机制提效率，监控调优保性能
```

---

**💡 学习收获**：
- 查询优化器是数据库性能的核心决定因素
- 理解优化原理有助于编写高效SQL和进行性能调优
- 现代优化器正在向智能化、自适应方向发展
- 优化器的配置和监控是DBA的核心技能之一