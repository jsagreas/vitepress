---
title: 4、索引与查询匹配详解
---
## 📚 目录

1. [索引匹配基础概念](#1-索引匹配基础概念)
2. [最左前缀原则深度解析](#2-最左前缀原则深度解析)
3. [复合索引使用策略](#3-复合索引使用策略)
4. [范围查询与索引优化](#4-范围查询与索引优化)
5. [排序分组索引策略](#5-排序分组索引策略)
6. [高级索引优化技术](#6-高级索引优化技术)
7. [索引匹配失败场景分析](#7-索引匹配失败场景分析)
8. [多索引组合使用策略](#8-多索引组合使用策略)
9. [索引匹配优化实战](#9-索引匹配优化实战)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引匹配基础概念


### 1.1 什么是索引匹配


**🔸 索引匹配的本质**
```
索引匹配 = 查询条件能否有效利用已建立的索引

就像查字典：
┌─────────────────┐
│   字典索引      │ ← 按拼音排序的目录
│   a、b、c...    │
└─────────────────┘
        ↓
┌─────────────────┐
│   具体内容      │ ← 根据索引快速定位
│   apple、book   │
└─────────────────┘

MySQL索引工作原理类似：
查询条件 → 索引匹配 → 快速定位数据
```

**💡 为什么索引匹配很重要**
- **性能差异巨大**：有索引匹配时间复杂度O(log n)，无匹配是O(n)
- **资源消耗**：好的匹配减少磁盘IO和CPU使用
- **用户体验**：直接影响查询响应时间

### 1.2 索引匹配的基本类型


**🔸 匹配方式分类**
```
精确匹配 (=)：
SELECT * FROM users WHERE id = 100;
└── 最高效的匹配方式

范围匹配 (>, <, BETWEEN)：
SELECT * FROM users WHERE age > 18;
└── 部分索引扫描

模糊匹配 (LIKE)：
SELECT * FROM users WHERE name LIKE 'John%';
└── 前缀匹配可用索引

排序匹配 (ORDER BY)：
SELECT * FROM users ORDER BY create_time;
└── 利用索引避免排序
```

### 1.3 索引匹配评估指标


**🔸 匹配度评估标准**
```
匹配度评估维度：
┌─ 选择性 (Selectivity)
│  └── 索引能过滤掉多少数据
├─ 覆盖性 (Coverage) 
│  └── 索引是否包含查询所需字段
├─ 顺序性 (Order)
│  └── 索引顺序是否符合查询需求
└─ 完整性 (Completeness)
   └── 查询条件是否完全利用索引
```

---

## 2. 📏 最左前缀原则深度解析


### 2.1 最左前缀原则的本质


**🔸 什么是最左前缀原则**
```
复合索引：INDEX(a, b, c)

想象成这样的排序结构：
a=1, b=1, c=1
a=1, b=1, c=2  
a=1, b=2, c=1
a=1, b=3, c=1
a=2, b=1, c=1
a=2, b=2, c=2

规则：必须从最左边的列开始匹配
```

**💡 为什么必须最左匹配**
```
索引的物理结构决定：

正确的匹配路径：
a → a,b → a,b,c
└── 沿着索引树的结构查找

错误的匹配尝试：
直接查找 b 或 c
└── 无法利用索引的有序性
```

### 2.2 最左前缀匹配示例


**🔸 创建测试表和索引**
```sql
-- 创建用户表
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    city VARCHAR(50),
    salary DECIMAL(10,2),
    INDEX idx_name_age_city (name, age, city)
);
```

**🔸 匹配情况分析**

| **查询SQL** | **索引使用情况** | **匹配程度** |
|------------|----------------|-------------|
| `WHERE name = 'John'` | ✅ 使用索引 | **完美匹配** |
| `WHERE name = 'John' AND age = 25` | ✅ 使用索引 | **完美匹配** |
| `WHERE name = 'John' AND age = 25 AND city = 'NYC'` | ✅ 使用索引 | **完美匹配** |
| `WHERE age = 25` | ❌ 不使用索引 | **无法匹配** |
| `WHERE city = 'NYC'` | ❌ 不使用索引 | **无法匹配** |
| `WHERE name = 'John' AND city = 'NYC'` | ⚠️ 部分使用 | **部分匹配** |

### 2.3 最左前缀的特殊情况


**🔸 范围查询对后续字段的影响**
```sql
-- 索引：INDEX(name, age, city)

-- 情况1：范围查询终止后续匹配
SELECT * FROM users 
WHERE name = 'John' AND age > 20 AND city = 'NYC';

索引使用情况：
├── name = 'John'  ✅ 精确匹配
├── age > 20       ✅ 范围匹配  
└── city = 'NYC'   ❌ 无法使用索引（因为age是范围查询）

-- 情况2：优化后的查询
SELECT * FROM users 
WHERE name = 'John' AND city = 'NYC' AND age > 20;

结果相同，但索引使用情况不变
```

**🔸 前缀模糊查询**
```sql
-- 可以使用索引的LIKE
SELECT * FROM users WHERE name LIKE 'John%';
└── 前缀匹配，可以使用索引

-- 无法使用索引的LIKE  
SELECT * FROM users WHERE name LIKE '%John';
SELECT * FROM users WHERE name LIKE '%John%';
└── 通配符在前面，无法使用索引
```

---

## 3. 🔧 复合索引使用策略


### 3.1 复合索引设计原则


**🔸 字段顺序优化策略**
```
设计原则优先级：
1. 等值查询字段在前
2. 范围查询字段在后  
3. 高选择性字段在前
4. 常用查询字段在前

示例场景分析：
查询模式：
├── WHERE status = 1 AND create_time > '2024-01-01'  (频繁)
├── WHERE status = 1 AND age BETWEEN 20 AND 30      (一般)
└── WHERE status = 1                                (偶尔)

推荐索引：INDEX(status, create_time, age)
理由：status等值查询最频繁，create_time范围查询较多
```

### 3.2 多场景复合索引设计


**🔸 电商订单表索引设计案例**
```sql
-- 订单表结构
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id INT,
    status TINYINT,     -- 订单状态 
    create_time DATETIME,
    amount DECIMAL(10,2),
    city_id INT
);

-- 常见查询模式分析
查询场景1：用户查看自己的订单
SELECT * FROM orders WHERE user_id = 123 ORDER BY create_time DESC;

查询场景2：管理员查看某状态订单  
SELECT * FROM orders WHERE status = 1 AND create_time > '2024-01-01';

查询场景3：用户查看特定状态订单
SELECT * FROM orders WHERE user_id = 123 AND status = 1;

-- 索引设计方案
INDEX idx_user_status_time (user_id, status, create_time)
INDEX idx_status_time (status, create_time)  
INDEX idx_create_time (create_time)  -- 用于日期范围查询
```

### 3.3 索引字段顺序对比


**🔸 不同顺序的性能对比**
```sql
-- 测试数据：100万订单记录
-- 查询：WHERE user_id = 123 AND status = 1

方案A：INDEX(user_id, status)
├── 先过滤user_id = 123    (1000条记录)
└── 再过滤status = 1       (200条记录)

方案B：INDEX(status, user_id)  
├── 先过滤status = 1       (50000条记录)
└── 再过滤user_id = 123    (200条记录)

性能对比：
方案A：需要检查1000条记录 ✅ 更优
方案B：需要检查50000条记录 ❌ 较差

选择原则：选择性高的字段放在前面
```

---

## 4. 🎛️ 范围查询与索引优化


### 4.1 范围查询的索引匹配规律


**🔸 单字段范围查询**
```sql
-- 索引：INDEX(age)
SELECT * FROM users WHERE age BETWEEN 20 AND 30;

索引扫描过程：
┌────────────────┐
│   B+树索引     │
│   age: 18      │
│   age: 19      │ 
│ ◄─age: 20──────┼── 开始扫描点
│   age: 21      │
│   age: 25      │
│   age: 29      │
│ ◄─age: 30──────┼── 结束扫描点
│   age: 31      │
│   age: 35      │
└────────────────┘

扫描方式：顺序扫描20-30区间的所有记录
```

### 4.2 多字段范围查询优化


**🔸 复合索引中的范围查询**
```sql
-- 索引：INDEX(status, create_time, user_id)

-- 优化前查询
SELECT * FROM orders 
WHERE status = 1 
  AND create_time BETWEEN '2024-01-01' AND '2024-01-31'
  AND user_id = 123;

索引使用分析：
├── status = 1           ✅ 精确匹配
├── create_time范围      ✅ 范围匹配
└── user_id = 123        ❌ 无法使用索引(范围查询后)

-- 优化方案：调整字段顺序
INDEX(status, user_id, create_time)

优化后索引使用：
├── status = 1           ✅ 精确匹配  
├── user_id = 123        ✅ 精确匹配
└── create_time范围      ✅ 范围匹配
```

### 4.3 范围查询性能优化技巧


**🔸 分页查询优化**
```sql
-- 传统分页(性能差)
SELECT * FROM orders 
WHERE status = 1 
ORDER BY create_time DESC 
LIMIT 10000, 10;

问题：需要扫描前10000条记录才能获取结果

-- 优化后分页(使用索引)  
SELECT * FROM orders 
WHERE status = 1 
  AND create_time < '2024-01-15 10:30:00'  -- 上次查询的最后时间
ORDER BY create_time DESC 
LIMIT 10;

优势：直接定位到需要的数据位置
```

**🔸 范围查询的索引合并**
```sql
-- 多个范围条件
SELECT * FROM users 
WHERE age BETWEEN 20 AND 30 
  AND salary BETWEEN 5000 AND 10000;

如果有索引：INDEX(age), INDEX(salary)
MySQL可能使用索引合并：
1. 通过age索引找到符合年龄的记录ID
2. 通过salary索引找到符合薪资的记录ID  
3. 求交集得到最终结果

注意：索引合并通常不如单个复合索引高效
```

---

## 5. 📊 排序分组索引策略


### 5.1 ORDER BY的索引利用


**🔸 排序索引匹配规则**
```sql
-- 表结构和索引
CREATE TABLE products (
    id INT,
    category_id INT,
    price DECIMAL(10,2),
    create_time DATETIME,
    INDEX idx_category_price (category_id, price)
);

-- 可以利用索引的排序查询
SELECT * FROM products 
WHERE category_id = 1 
ORDER BY price;  ✅ 利用索引排序

SELECT * FROM products 
WHERE category_id = 1 
ORDER BY price DESC;  ✅ 利用索引排序(反向)

-- 无法利用索引的排序查询
SELECT * FROM products 
ORDER BY price;  ❌ 缺少WHERE条件匹配索引前缀

SELECT * FROM products 
WHERE category_id = 1 
ORDER BY create_time;  ❌ 排序字段不在索引中
```

### 5.2 GROUP BY的索引优化


**🔸 分组操作的索引匹配**
```sql
-- 索引：INDEX(category_id, brand_id, price)

-- 高效的分组查询
SELECT category_id, COUNT(*) 
FROM products 
GROUP BY category_id;  ✅ 使用索引避免排序

SELECT category_id, brand_id, AVG(price)
FROM products  
GROUP BY category_id, brand_id;  ✅ 完美匹配索引顺序

-- 低效的分组查询
SELECT brand_id, COUNT(*)
FROM products
GROUP BY brand_id;  ❌ 跳过了索引的第一列

-- 分组顺序必须匹配索引顺序
SELECT category_id, brand_id, COUNT(*)
FROM products
GROUP BY brand_id, category_id;  ❌ 顺序不匹配
```

### 5.3 排序分组组合优化


**🔸 复杂查询的索引设计**
```sql
-- 业务需求：商品分类统计，按销量排序
SELECT category_id, SUM(sales_count) as total_sales
FROM products 
WHERE status = 1
GROUP BY category_id 
ORDER BY total_sales DESC;

-- 索引设计分析
需求分析：
├── WHERE条件：status = 1
├── GROUP BY：category_id  
└── ORDER BY：聚合结果(无法使用索引)

推荐索引：INDEX(status, category_id)
理由：
1. 先过滤status条件
2. category_id分组时数据已按此字段有序
3. 减少排序开销
```

**🔸 覆盖索引在排序中的应用**
```sql
-- 查询：获取每个分类的商品数量
SELECT category_id, COUNT(*) 
FROM products 
WHERE status = 1
GROUP BY category_id;

-- 覆盖索引设计
INDEX(status, category_id)

优势：
1. 通过索引就能获取所有需要的数据
2. 避免回表操作
3. 分组操作直接在索引上完成
```

---

## 6. 🚀 高级索引优化技术


### 6.1 索引下推(ICP)机制详解


**🔸 什么是索引下推**
```
传统查询过程：
存储引擎 ────── 返回所有可能记录 ──────→ MySQL服务器
                                        ↓
                                   过滤WHERE条件
                                        ↓
                                    返回最终结果

ICP优化后：
存储引擎 ──── 在存储引擎层过滤 ────→ 只返回符合条件的记录 ──→ MySQL服务器
           (减少数据传输量)
```

**🔸 ICP实际应用示例**
```sql
-- 索引：INDEX(name, age)  
SELECT * FROM users 
WHERE name LIKE 'John%' AND age > 30;

-- 不使用ICP：
1. 通过name索引找到所有'John%'的记录
2. 将所有记录传递给MySQL服务器
3. 服务器过滤age > 30的条件

-- 使用ICP：
1. 通过name索引找到'John%'的记录
2. 在存储引擎层直接过滤age > 30
3. 只返回同时满足两个条件的记录

-- 检查ICP是否启用
SHOW VARIABLES LIKE 'optimizer_switch';
-- 查看执行计划中的'Using index condition'
```

### 6.2 多范围读取(MRR)优化


**🔸 MRR工作原理**
```
传统随机读取：
索引查找 → 随机读取行1 → 随机读取行2 → 随机读取行3
              ↓              ↓              ↓
           磁盘I/O        磁盘I/O        磁盘I/O

MRR优化读取：
索引查找 → 收集所有行的位置 → 排序 → 顺序批量读取
                                      ↓
                                  减少磁盘I/O
```

**🔸 MRR适用场景**
```sql
-- 范围查询场景
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';

-- MRR优化过程
1. 通过日期索引找到所有符合条件的主键ID
2. 将主键ID按物理存储位置排序  
3. 批量按顺序读取数据页
4. 减少随机I/O，提升性能

-- 启用MRR
SET SESSION optimizer_switch='mrr=on,mrr_cost_based=off';
```

### 6.3 批量键访问(BKA)算法


**🔸 BKA关联查询优化**
```sql
-- 关联查询示例
SELECT u.name, o.order_no 
FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.city = 'Beijing';

-- 传统嵌套循环：
for each user in users where city='Beijing':
    for each order in orders where user_id = user.id:
        return (user.name, order.order_no)

-- BKA优化：  
1. 先批量获取所有Beijing的用户ID
2. 将用户ID批量传递给orders表查询
3. 利用MRR优化orders表的批量查询
4. 减少循环次数和随机I/O
```

### 6.4 松散索引扫描(Loose Index Scan)


**🔸 松散索引扫描的应用**
```sql
-- 索引：INDEX(category_id, create_time)
-- 查询：每个分类的最早创建时间
SELECT category_id, MIN(create_time)
FROM products 
GROUP BY category_id;

-- 松散索引扫描过程：
索引结构：
category_id=1, create_time='2024-01-01'  ← 读取
category_id=1, create_time='2024-01-05'  ← 跳过
category_id=1, create_time='2024-01-10'  ← 跳过
category_id=2, create_time='2024-01-02'  ← 读取  
category_id=2, create_time='2024-01-08'  ← 跳过
category_id=3, create_time='2024-01-03'  ← 读取

优势：只读取每个分组的第一条记录，大幅减少扫描数据量
```

### 6.5 索引跳跃扫描(Skip Scan)


**🔸 跳跃扫描的工作机制**
```sql
-- 复合索引：INDEX(gender, age)  
-- 查询条件：只有age条件
SELECT * FROM users WHERE age = 25;

-- 传统方式：无法使用索引(违反最左前缀)

-- Skip Scan优化：
1. MySQL自动推断gender的所有可能值(如'M','F')
2. 将查询改写为：
   (gender='M' AND age=25) OR (gender='F' AND age=25)
3. 分别利用索引查找两个条件
4. 合并结果

-- 适用条件：
- 前导列的基数较小(不同值较少)
- 后续列的选择性较高
```

---

## 7. ⚠️ 索引匹配失败场景分析


### 7.1 常见索引失效情况


**🔸 函数运算导致失效**
```sql
-- 索引：INDEX(create_time)

-- 错误写法：索引失效
SELECT * FROM orders 
WHERE YEAR(create_time) = 2024;

SELECT * FROM orders 
WHERE DATE_FORMAT(create_time, '%Y-%m') = '2024-01';

-- 正确写法：使用索引
SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';

SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2024-02-01';

原因分析：
函数运算需要对每行数据进行计算，破坏了索引的有序性
```

### 7.2 数据类型转换失效


**🔸 隐式类型转换问题**
```sql
-- 表结构
CREATE TABLE users (
    id INT,
    phone VARCHAR(11),  -- 字符串类型
    INDEX idx_phone (phone)
);

-- 错误查询：索引失效
SELECT * FROM users WHERE phone = 13800138000;  -- 数字类型

-- 正确查询：使用索引  
SELECT * FROM users WHERE phone = '13800138000'; -- 字符串类型

-- 检查类型转换
EXPLAIN SELECT * FROM users WHERE phone = 13800138000;
-- 如果Extra中显示"Using where"而非"Using index"说明索引失效
```

### 7.3 复杂表达式匹配失败


**🔸 表达式索引匹配规则**
```sql
-- 索引：INDEX(price)

-- 无法使用索引的查询
SELECT * FROM products WHERE price + 100 > 1000;
SELECT * FROM products WHERE price * 1.1 > 1000;
SELECT * FROM products WHERE -price < -500;

-- 可以使用索引的等价查询
SELECT * FROM products WHERE price > 900;        -- price + 100 > 1000
SELECT * FROM products WHERE price > 909.09;     -- price * 1.1 > 1000  
SELECT * FROM products WHERE price > 500;        -- -price < -500

转换原则：将表达式变换为 column op constant 的形式
```

### 7.4 OR条件索引匹配


**🔸 OR条件的索引使用规则**
```sql
-- 索引：INDEX(name), INDEX(age)

-- 可以使用索引合并
SELECT * FROM users 
WHERE name = 'John' OR age = 25;
-- 分别使用两个索引，然后合并结果

-- 无法有效使用索引  
SELECT * FROM users 
WHERE name = 'John' OR phone = '138001380001';
-- 如果phone没有索引，整个查询退化为全表扫描

-- 推荐优化方案：使用UNION
SELECT * FROM users WHERE name = 'John'
UNION
SELECT * FROM users WHERE phone = '138001380001';
```

---

## 8. 🔄 多索引组合使用策略


### 8.1 索引合并技术详解


**🔸 索引合并的三种类型**
```sql
-- 1. 交集合并(intersection)
SELECT * FROM users 
WHERE name = 'John' AND age = 25;
-- 如果name和age都有单独索引，可能合并使用

-- 2. 并集合并(union) 
SELECT * FROM users 
WHERE name = 'John' OR age = 25;
-- 分别查询两个索引，合并结果

-- 3. 排序合并(sort-union)
SELECT * FROM users 
WHERE name > 'John' OR age > 25;  
-- 对范围查询结果排序后合并
```

### 8.2 索引选择优先级算法


**🔸 MySQL如何选择最优索引**
```
索引选择决策过程：

1. 计算每个索引的选择性
   ┌─ 唯一索引      (选择性 = 1)        ← 最高优先级
   ├─ 高选择性索引  (选择性 > 0.1)     ← 高优先级  
   ├─ 中等选择性    (0.01 < 选择性 ≤ 0.1) ← 中优先级
   └─ 低选择性索引  (选择性 ≤ 0.01)    ← 低优先级

2. 考虑查询覆盖度
   ├─ 覆盖索引：包含所有查询字段       ← 优先选择
   └─ 非覆盖索引：需要回表查询        ← 次优选择

3. 评估扫描成本  
   ├─ 索引扫描行数
   ├─ 回表访问成本  
   └─ 排序成本
```

### 8.3 复杂查询的索引策略


**🔸 多条件查询索引设计**
```sql
-- 电商搜索场景
SELECT product_id, name, price 
FROM products 
WHERE category_id = 1 
  AND brand_id IN (10, 20, 30)
  AND price BETWEEN 100 AND 500
  AND status = 1
ORDER BY sales_count DESC
LIMIT 20;

-- 索引设计方案对比
方案1：INDEX(category_id, brand_id, price, status, sales_count)
├── 优点：完美匹配查询顺序
└── 缺点：索引过长，维护成本高

方案2：INDEX(category_id, status, price, sales_count) + INDEX(brand_id)  
├── 优点：平衡性能和维护成本
└── 缺点：可能需要索引合并

方案3：INDEX(category_id, status, sales_count) -- 针对排序优化
├── 优点：避免文件排序
└── 缺点：其他条件过滤效果一般

推荐选择：根据查询频率和数据分布选择方案2
```

### 8.4 索引匹配度评估方法


**🔸 实际匹配度测量**
```sql
-- 使用EXPLAIN ANALYZE查看实际执行
EXPLAIN ANALYZE 
SELECT * FROM users 
WHERE name = 'John' AND age > 25;

-- 关键指标解读
关注指标：
├── rows_examined_per_scan：平均扫描行数
├── rows_produced_per_join：产生的结果行数  
├── cost_info：查询成本评估
└── filtered：WHERE条件过滤百分比

-- 索引效率计算公式
索引效率 = (总行数 - 扫描行数) / 总行数 × 100%

示例：
总行数：1,000,000
扫描行数：100
索引效率：(1,000,000 - 100) / 1,000,000 × 100% = 99.99%
```

---

## 9. 🛠️ 索引匹配优化实战


### 9.1 查询性能诊断流程


**🔸 系统化诊断步骤**
```
性能问题诊断流程：

第1步：识别慢查询
├── 开启慢查询日志
├── 使用pt-query-digest分析  
└── 识别TOP 10慢查询

第2步：分析执行计划
├── 使用EXPLAIN检查索引使用
├── 关注type、key、rows、Extra字段
└── 识别全表扫描和低效操作

第3步：索引匹配度分析  
├── 检查WHERE条件与索引的匹配度
├── 分析最左前缀原则的应用
└── 评估复合索引的有效性

第4步：制定优化方案
├── 创建缺失的索引
├── 优化现有索引结构
└── 调整查询语句
```

### 9.2 实际案例优化演示


**🔸 案例：用户订单查询优化**
```sql
-- 原始慢查询
SELECT u.username, o.order_no, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id  
WHERE u.city = 'Shanghai'
  AND o.status = 1
  AND o.create_time >= '2024-01-01'
ORDER BY o.create_time DESC
LIMIT 10;

-- 第1步：分析执行计划
EXPLAIN SELECT ...;

-- 执行计划显示：
+----+-------+------+------+-------+------+
| id | table | type | key  | rows  | Extra|
+----+-------+------+------+-------+------+  
| 1  | u     | ALL  | NULL | 50000 |Using where|
| 1  | o     | ALL  | NULL |100000 |Using where|
+----+-------+------+------+-------+------+

问题分析：两个表都是全表扫描

-- 第2步：创建必要索引
CREATE INDEX idx_users_city ON users(city);
CREATE INDEX idx_orders_user_status_time ON orders(user_id, status, create_time);

-- 第3步：验证优化效果
EXPLAIN SELECT ...;

-- 优化后执行计划：
+----+-------+------+-------------------------+------+---------+
| id | table | type | key                     | rows | Extra   |
+----+-------+------+-------------------------+------+---------+
| 1  | u     | ref  | idx_users_city          | 500  |Using where|
| 1  | o     | ref  | idx_orders_user_status_time| 10   |Using index|
+----+-------+------+-------------------------+------+---------+

性能提升：扫描行数从150000减少到510，提升99.6%
```

### 9.3 索引维护最佳实践


**🔸 索引监控和维护**
```sql
-- 1. 监控索引使用情况
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT,
    COUNT_UPDATE,
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_FETCH DESC;

-- 2. 识别未使用的索引
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME, 
    INDEX_NAME
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
  AND INDEX_NAME IS NOT NULL
  AND COUNT_FETCH = 0
  AND COUNT_INSERT = 0
  AND COUNT_UPDATE = 0  
  AND COUNT_DELETE = 0;

-- 3. 检查索引碎片
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    NON_UNIQUE,
    INDEX_NAME,
    CARDINALITY,
    INDEX_LENGTH
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY INDEX_LENGTH DESC;
```

---

## 10. 📋 核心要点总结


### 10.1 索引匹配决策树


```
查询条件分析
       ↓
   是否符合最左前缀？
     ↙        ↘
    是          否
    ↓          ↓
 检查字段顺序   考虑其他索引
    ↓          或全表扫描
 范围查询位置？
   ↙    ↘
 合理    不合理
 ↓      ↓  
使用索引  调整索引结构
```

### 10.2 索引匹配核心原则


**🔸 必须掌握的核心规则**
```
1. 最左前缀原则
   └── 复合索引必须从最左字段开始匹配

2. 范围查询终止原则  
   └── 范围查询字段后的字段无法使用索引

3. 函数破坏原则
   └── 字段参与运算或函数调用会导致索引失效

4. 类型匹配原则
   └── 查询条件的数据类型必须与索引字段类型一致

5. 选择性优先原则
   └── 选择性高的字段应该放在复合索引的前面
```

### 10.3 优化策略速查表


| **场景** | **优化策略** | **索引设计** |
|----------|-------------|-------------|
| **等值多条件查询** | 创建复合索引 | `INDEX(col1, col2, col3)` |
| **范围查询+排序** | 范围字段放最后 | `INDEX(等值字段, 范围字段)` |  
| **分组统计** | 按分组字段创建 | `INDEX(group_col, agg_col)` |
| **模糊查询** | 前缀匹配或全文索引 | `INDEX(col)` 或 `FULLTEXT(col)` |
| **关联查询** | 关联字段建索引 | `INDEX(foreign_key)` |
| **覆盖查询** | 包含所有查询字段 | `INDEX(col1, col2, select_col)` |

### 10.4 性能监控关键指标


**🔸 索引效果评估标准**
```
查询性能指标：
├── 执行时间 < 100ms      (优秀)
├── 扫描行数/返回行数 < 10 (高效)  
├── 索引选择性 > 0.1       (有效)
└── 回表率 < 20%           (良好)

索引维护指标：
├── 索引大小/数据大小 < 30% (合理)
├── 写入性能下降 < 20%      (可接受)
├── 未使用索引数量 = 0      (最佳)
└── 重复索引数量 = 0        (最佳)
```

### 10.5 实战优化建议


**🔸 日常优化工作流程**
```
日常维护清单：

□ 每周检查慢查询日志
□ 每月分析索引使用情况  
□ 每季度评估索引性能
□ 及时删除未使用索引
□ 监控索引碎片率
□ 关注写入性能影响
□ 定期更新表统计信息
```

**🔸 应急优化步骤**
```
紧急性能问题处理：

1. 立即分析：EXPLAIN分析慢查询
2. 快速定位：识别缺失或失效的索引  
3. 紧急创建：添加必要的索引(注意锁表)
4. 临时优化：调整查询语句结构
5. 持续监控：观察优化效果
6. 后续完善：制定长期优化方案
```

---

> 💡 **核心记忆要点**
> 
> 索引匹配的本质是让查询条件能够有效利用索引的有序性。掌握最左前缀原则、理解范围查询的影响、避免函数和类型转换、合理设计复合索引，是索引优化的关键。好的索引匹配能将查询性能提升几百倍，而错误的索引使用甚至不如全表扫描。

**🎯 实践建议**：先理解索引的数据结构和查询执行原理，再通过EXPLAIN分析具体的匹配情况，最后结合业务场景设计最优的索引策略。索引优化是一个持续迭代的过程，需要根据实际的查询模式和数据分布不断调整。