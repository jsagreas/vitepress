---
title: 14、索引分区策略
---
## 📚 目录

1. [分区表索引概述](#1-分区表索引概述)
2. [分区表索引创建](#2-分区表索引创建)
3. [全局索引vs局部索引](#3-全局索引vs局部索引)
4. [分区剪枝与索引](#4-分区剪枝与索引)
5. [跨分区查询优化](#5-跨分区查询优化)
6. [分区键与索引键关系](#6-分区键与索引键关系)
7. [分区索引维护策略](#7-分区索引维护策略)
8. [分区表索引设计模式](#8-分区表索引设计模式)
9. [分区索引性能影响分析](#9-分区索引性能影响分析)
10. [分区间索引一致性管理](#10-分区间索引一致性管理)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🗂️ 分区表索引概述


### 1.1 什么是分区表索引


**💡 基本概念解释**
分区表索引是在分区表上创建的索引结构。与普通表不同，分区表的索引可以有不同的组织方式和策略。

```
简单理解：
普通表索引：就像一本书的目录
- 整个书有一个统一的目录
- 查找时直接通过目录定位

分区表索引：就像多本书的索引系统  
- 可以每本书各有目录（局部索引）
- 也可以有一个总目录（全局索引）
- 查找策略更加灵活
```

### 1.2 分区索引的重要性


**🎯 为什么分区索引很关键**
- **性能影响**：分区索引直接影响查询性能
- **维护成本**：索引策略影响维护复杂度  
- **存储效率**：不同策略的存储空间差异很大
- **查询模式**：需要匹配业务的查询模式

### 1.3 分区索引的挑战


**⚠️ 主要挑战**
```
设计挑战：
- 如何平衡查询性能和维护成本
- 如何处理跨分区查询
- 如何保证索引一致性

技术挑战：
- 分区键和索引键的关系处理
- 分区剪枝的有效利用
- 索引统计信息的准确性

业务挑战：
- 适应不断变化的查询模式
- 处理数据分布不均的情况
- 平衡写入性能和查询性能
```

---

## 2. 🔧 分区表索引创建


### 2.1 分区表索引创建基础


**📋 基本创建语法**
MySQL中分区表的索引创建有特殊规则，所有唯一索引（包括主键）都必须包含分区键。

```sql
-- 创建分区表
CREATE TABLE orders_partitioned (
    id BIGINT AUTO_INCREMENT,
    user_id INT NOT NULL,
    order_date DATE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 主键必须包含分区键
    PRIMARY KEY (id, order_date),
    
    -- 其他索引可以不包含分区键
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_amount (amount)
) 
PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);
```

### 2.2 分区表索引类型


**🔸 支持的索引类型**
```sql
-- 1. 普通索引（每个分区独立）
ALTER TABLE orders_partitioned ADD INDEX idx_user_status (user_id, status);

-- 2. 唯一索引（必须包含分区键）
ALTER TABLE orders_partitioned ADD UNIQUE KEY uk_id_date (id, order_date);

-- 3. 复合索引
ALTER TABLE orders_partitioned ADD INDEX idx_composite (user_id, order_date, status);

-- 4. 前缀索引（注意分区特性）
ALTER TABLE orders_partitioned ADD INDEX idx_created_prefix (created_at(10));
```

### 2.3 分区索引创建限制


**❌ 重要限制条件**
```sql
-- 错误示例：唯一索引不包含分区键
-- ALTER TABLE orders_partitioned ADD UNIQUE KEY uk_id_only (id);
-- ERROR: A UNIQUE INDEX must include all columns in the table's partitioning function

-- 正确示例：唯一索引包含分区键
ALTER TABLE orders_partitioned ADD UNIQUE KEY uk_user_date (user_id, order_date);

-- 查看分区表索引信息
SELECT 
    TABLE_NAME,
    PARTITION_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    SEQ_IN_INDEX
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_NAME = 'orders_partitioned'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;
```

### 2.4 分区索引维护操作


**🔧 常用维护操作**
```sql
-- 添加分区索引
ALTER TABLE orders_partitioned ADD INDEX idx_new_column (amount, status);

-- 删除分区索引
ALTER TABLE orders_partitioned DROP INDEX idx_user_id;

-- 重建分区索引（通过重建分区）
ALTER TABLE orders_partitioned REBUILD PARTITION p2024;

-- 查看分区索引统计信息
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    AVG_ROW_LENGTH,
    DATA_LENGTH,
    INDEX_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS 
WHERE TABLE_NAME = 'orders_partitioned';
```

---

## 3. 🌐 全局索引vs局部索引


### 3.1 索引范围概念解释


**💡 全局索引vs局部索引的本质区别**

```
局部索引（Local Index）- MySQL默认方式：
每个分区有自己独立的索引

分区A: 索引A  ┐
分区B: 索引B  ├─ 各自独立，互不影响
分区C: 索引C  ┘

全局索引（Global Index）- MySQL不直接支持：
所有分区共享一个统一的索引

分区A ┐
分区B ├─ 共享一个全局索引结构
分区C ┘
```

### 3.2 MySQL的局部索引实现


**🔸 局部索引特点和实现**
MySQL只支持局部索引，每个分区维护自己的索引副本。

```sql
-- 创建分区表后，每个分区都有完整的索引副本
CREATE TABLE user_logs (
    id BIGINT AUTO_INCREMENT,
    user_id INT NOT NULL,
    log_date DATE NOT NULL,
    action VARCHAR(50),
    ip_address VARCHAR(45),
    
    PRIMARY KEY (id, log_date),
    INDEX idx_user_id (user_id),
    INDEX idx_action (action)
) 
PARTITION BY RANGE (YEAR(log_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 查看各分区的索引情况
SELECT 
    PARTITION_NAME,
    INDEX_NAME,
    CARDINALITY,
    SUB_PART
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_NAME = 'user_logs'
ORDER BY PARTITION_NAME, INDEX_NAME;
```

### 3.3 局部索引的优缺点


**⚖️ 局部索引优缺点分析**

| 特性 | **优点** | **缺点** |
|------|---------|----------|
| **查询性能** | 单分区查询很快 | 跨分区查询需要合并结果 |
| **维护成本** | 分区独立维护，影响范围小 | 需要维护多个索引副本 |
| **存储空间** | 每个分区可以独立优化 | 总体存储空间较大 |
| **并发性能** | 分区间操作互不影响 | 跨分区操作复杂 |

### 3.4 模拟全局索引效果


**🔄 通过设计模拟全局索引**
虽然MySQL不支持真正的全局索引，但可以通过设计模拟类似效果。

```sql
-- 方案1：创建汇总表作为"全局索引"
CREATE TABLE user_id_global_index (
    user_id INT PRIMARY KEY,
    partition_name VARCHAR(20),
    min_date DATE,
    max_date DATE,
    record_count INT,
    INDEX idx_partition (partition_name)
);

-- 维护全局索引表
INSERT INTO user_id_global_index 
SELECT 
    user_id,
    'p2024' as partition_name,
    MIN(log_date) as min_date,
    MAX(log_date) as max_date,
    COUNT(*) as record_count
FROM user_logs PARTITION(p2024)
GROUP BY user_id;
```

### 3.5 索引策略选择建议


**🎯 选择策略指导**
```
选择局部索引的场景：
✅ 查询主要集中在单个分区
✅ 分区键经常出现在WHERE子句中
✅ 数据按时间等自然边界分区
✅ 希望分区间完全独立维护

需要"全局索引"效果的场景：
⚠️ 经常需要跨分区查询
⚠️ 查询条件不包含分区键
⚠️ 需要全表唯一性约束（除了包含分区键的情况）
⚠️ 需要全局排序或聚合

替代方案：
🔄 考虑重新设计分区策略
🔄 使用应用层聚合
🔄 采用分布式数据库系统
🔄 使用搜索引擎（如Elasticsearch）
```

---

## 4. ✂️ 分区剪枝与索引


### 4.1 分区剪枝机制


**💡 什么是分区剪枝**
分区剪枝（Partition Pruning）是MySQL优化器自动排除不相关分区的机制，只查询包含目标数据的分区。

```
分区剪枝工作原理：

没有分区剪枝：
查询 WHERE log_date = '2024-05-15'
扫描：分区A + 分区B + 分区C (全部扫描)

有分区剪枝：  
查询 WHERE log_date = '2024-05-15'
扫描：仅分区B (只扫描相关分区)

结果：查询效率提升2-10倍！
```

### 4.2 分区剪枝与索引的配合


**🎯 索引如何配合分区剪枝**
```sql
-- 创建按日期分区的表
CREATE TABLE sales_data (
    id BIGINT AUTO_INCREMENT,
    sale_date DATE NOT NULL,
    product_id INT NOT NULL,
    customer_id INT NOT NULL,
    amount DECIMAL(10,2),
    
    PRIMARY KEY (id, sale_date),
    INDEX idx_product (product_id),
    INDEX idx_customer (customer_id),
    INDEX idx_product_date (product_id, sale_date)
) 
PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),  
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 优秀的分区剪枝 + 索引使用
EXPLAIN PARTITIONS
SELECT * FROM sales_data 
WHERE sale_date = '2024-06-15' 
  AND product_id = 1001;
-- 结果：只扫描p2024分区，使用idx_product_date索引
```

### 4.3 影响分区剪枝的因素


**🔍 分区剪枝效果的关键因素**
```sql
-- 因素1：WHERE条件是否包含分区键
-- 好的例子：能进行分区剪枝
SELECT * FROM sales_data WHERE sale_date = '2024-01-15';

-- 不好的例子：无法分区剪枝  
SELECT * FROM sales_data WHERE product_id = 1001;

-- 因素2：分区键的表达式形式
-- 好的例子：简单的比较条件
SELECT * FROM sales_data WHERE sale_date BETWEEN '2024-01-01' AND '2024-01-31';

-- 不好的例子：复杂的函数表达式
SELECT * FROM sales_data WHERE MONTH(sale_date) = 1;

-- 因素3：分区函数的复杂度
-- 简单的RANGE分区容易剪枝
PARTITION BY RANGE (YEAR(sale_date))

-- 复杂的HASH分区难以剪枝
PARTITION BY HASH (product_id) PARTITIONS 4;
```

### 4.4 分区剪枝验证方法


**🔬 如何验证分区剪枝效果**
```sql
-- 方法1：使用EXPLAIN PARTITIONS
EXPLAIN PARTITIONS
SELECT * FROM sales_data 
WHERE sale_date = '2024-06-15';

-- 输出示例：
-- partitions: p2024  (只扫描一个分区)

-- 方法2：查看实际扫描的分区数
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    DATA_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS 
WHERE TABLE_NAME = 'sales_data';

-- 方法3：使用性能监控查看
SELECT 
    OBJECT_NAME,
    OBJECT_TYPE,
    INDEX_NAME,
    COUNT_READ,
    COUNT_FETCH
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_NAME = 'sales_data';
```

### 4.5 优化分区剪枝的策略


**⚡ 提升分区剪枝效果的方法**
```sql
-- 策略1：合理设计复合索引，包含分区键
CREATE INDEX idx_optimized ON sales_data (sale_date, product_id, customer_id);

-- 策略2：查询重写，显式包含分区键条件
-- 原查询
SELECT * FROM sales_data WHERE product_id = 1001;

-- 优化后查询（如果已知时间范围）
SELECT * FROM sales_data 
WHERE product_id = 1001 
  AND sale_date >= '2024-01-01' 
  AND sale_date < '2025-01-01';

-- 策略3：使用分区键作为索引的第一列
CREATE INDEX idx_date_product ON sales_data (sale_date, product_id);
CREATE INDEX idx_date_customer ON sales_data (sale_date, customer_id);
```

---

## 5. 🔄 跨分区查询优化


### 5.1 跨分区查询的挑战


**⚠️ 跨分区查询面临的问题**
当查询需要访问多个分区时，会面临性能和复杂性的挑战。

```
跨分区查询场景：

单分区查询（理想情况）：
SELECT * FROM orders WHERE order_date = '2024-06-15'
→ 只扫描一个分区，性能最佳

跨分区查询（复杂情况）：
SELECT * FROM orders WHERE user_id = 1001
→ 可能需要扫描所有分区，性能较差

全表扫描（最差情况）：  
SELECT COUNT(*) FROM orders
→ 必须扫描所有分区，性能最差
```

### 5.2 跨分区查询优化策略


**🎯 优化跨分区查询的方法**
```sql
-- 策略1：添加分区键到查询条件
-- 原查询：跨分区扫描
SELECT * FROM orders_partitioned WHERE user_id = 1001;

-- 优化查询：限制分区范围
SELECT * FROM orders_partitioned 
WHERE user_id = 1001 
  AND order_date >= '2024-01-01'
  AND order_date < '2025-01-01';

-- 策略2：使用UNION分别查询各分区
SELECT * FROM orders_partitioned PARTITION(p2024) WHERE user_id = 1001
UNION ALL
SELECT * FROM orders_partitioned PARTITION(p2023) WHERE user_id = 1001;

-- 策略3：创建包含分区键的复合索引
CREATE INDEX idx_user_date_status ON orders_partitioned (user_id, order_date, status);
```

### 5.3 跨分区聚合查询优化


**📊 聚合查询的特殊处理**
```sql
-- 跨分区聚合查询示例
-- COUNT查询优化
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') as month,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders_partitioned 
WHERE order_date >= '2024-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m');

-- 分区级别的聚合优化
SELECT 
    'p2024' as partition_name,
    COUNT(*) as count,
    AVG(amount) as avg_amount,
    SUM(amount) as total_amount
FROM orders_partitioned PARTITION(p2024)
UNION ALL
SELECT 
    'p2023' as partition_name,
    COUNT(*) as count, 
    AVG(amount) as avg_amount,
    SUM(amount) as total_amount
FROM orders_partitioned PARTITION(p2023);
```

### 5.4 跨分区JOIN优化


**🔗 分区表JOIN的优化技巧**
```sql
-- 创建另一个分区表进行JOIN测试
CREATE TABLE users_partitioned (
    user_id INT NOT NULL,
    name VARCHAR(100),
    register_date DATE NOT NULL,
    status TINYINT DEFAULT 1,
    
    PRIMARY KEY (user_id, register_date),
    INDEX idx_name (name)
)
PARTITION BY RANGE (YEAR(register_date)) (
    PARTITION pu2022 VALUES LESS THAN (2023),
    PARTITION pu2023 VALUES LESS THAN (2024),
    PARTITION pu2024 VALUES LESS THAN (2025)
);

-- 跨分区JOIN优化
-- 方法1：在JOIN条件中包含分区键
SELECT o.*, u.name
FROM orders_partitioned o
JOIN users_partitioned u ON o.user_id = u.user_id 
WHERE o.order_date = '2024-06-15'
  AND u.register_date >= '2024-01-01';

-- 方法2：分区对应JOIN
SELECT o.*, u.name
FROM orders_partitioned PARTITION(p2024) o
JOIN users_partitioned PARTITION(pu2024) u ON o.user_id = u.user_id;
```

### 5.5 应用层优化策略


**💻 应用程序层面的优化**
```python
def get_user_orders_optimized(user_id, start_date=None, end_date=None):
    """优化的跨分区查询"""
    
    # 根据日期范围确定需要查询的分区
    partitions_to_query = determine_partitions(start_date, end_date)
    
    results = []
    for partition in partitions_to_query:
        query = f"""
        SELECT * FROM orders_partitioned PARTITION({partition})
        WHERE user_id = %s
        """
        
        if start_date and end_date:
            query += " AND order_date BETWEEN %s AND %s"
            cursor.execute(query, (user_id, start_date, end_date))
        else:
            cursor.execute(query, (user_id,))
            
        results.extend(cursor.fetchall())
    
    return results
```

---

## 6. 🔑 分区键与索引键关系


### 6.1 分区键与索引键的关系类型


**💡 两种键的关系模式**
分区键和索引键的关系直接影响查询性能和索引设计策略。

```
关系类型分析：

类型1：分区键 = 索引键
分区键：order_date
索引键：order_date
特点：完美匹配，性能最佳

类型2：分区键 ⊆ 索引键  
分区键：order_date
索引键：(order_date, user_id)
特点：包含关系，性能良好

类型3：分区键 ∩ 索引键 ≠ ∅
分区键：order_date  
索引键：(user_id, order_date)
特点：部分重叠，需要优化

类型4：分区键 ∩ 索引键 = ∅
分区键：order_date
索引键：user_id
特点：完全独立，性能最差
```

### 6.2 最佳关系设计模式


**🎯 推荐的设计模式**
```sql
-- 模式1：分区键作为索引前导列（推荐）
CREATE TABLE orders_pattern1 (
    id BIGINT AUTO_INCREMENT,
    order_date DATE NOT NULL,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    amount DECIMAL(10,2),
    
    PRIMARY KEY (id, order_date),
    -- 分区键作为索引第一列
    INDEX idx_date_user (order_date, user_id),
    INDEX idx_date_product (order_date, product_id),
    INDEX idx_date_amount (order_date, amount)
) 
PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 模式2：复合分区键的索引设计
CREATE TABLE user_activities (
    id BIGINT AUTO_INCREMENT,
    user_id INT NOT NULL,
    activity_date DATE NOT NULL,
    activity_type VARCHAR(50),
    duration INT,
    
    PRIMARY KEY (id, user_id, activity_date),
    -- 包含所有分区键的索引
    INDEX idx_user_date_type (user_id, activity_date, activity_type),
    INDEX idx_user_date_duration (user_id, activity_date, duration)
)
PARTITION BY HASH (user_id) PARTITIONS 8;
```

### 6.3 不同关系的性能对比


**📊 性能对比测试**
```sql
-- 测试不同索引设计的性能
-- 设计A：分区键为索引第一列
CREATE INDEX idx_a ON orders_pattern1 (order_date, user_id);

-- 设计B：分区键为索引第二列
CREATE INDEX idx_b ON orders_pattern1 (user_id, order_date);

-- 设计C：不包含分区键
CREATE INDEX idx_c ON orders_pattern1 (user_id);

-- 性能测试查询
-- 查询1：包含分区键条件
EXPLAIN SELECT * FROM orders_pattern1 
WHERE order_date = '2024-06-15' AND user_id = 1001;
-- 设计A最优：分区剪枝 + 索引高效

-- 查询2：只有非分区键条件
EXPLAIN SELECT * FROM orders_pattern1 WHERE user_id = 1001;
-- 设计B次优：无分区剪枝，但索引覆盖好
-- 设计C最差：无分区剪枝，索引效果一般
```

### 6.4 分区键选择对索引的影响


**🔍 分区键选择的考虑因素**
```sql
-- 场景1：时间序列数据（推荐按时间分区）
CREATE TABLE time_series_data (
    id BIGINT AUTO_INCREMENT,
    timestamp DATETIME NOT NULL,
    sensor_id INT NOT NULL,
    value DOUBLE,
    
    PRIMARY KEY (id, timestamp),
    -- 时间相关的索引设计
    INDEX idx_time_sensor (timestamp, sensor_id),
    INDEX idx_sensor_time (sensor_id, timestamp)  -- 支持传感器查询
)
PARTITION BY RANGE (YEAR(timestamp)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 场景2：用户数据（可考虑按用户ID哈希分区）
CREATE TABLE user_data (
    id BIGINT AUTO_INCREMENT,
    user_id INT NOT NULL,
    created_at DATETIME NOT NULL,
    data_type VARCHAR(50),
    content TEXT,
    
    PRIMARY KEY (id, user_id),
    -- 用户相关的索引设计
    INDEX idx_user_created (user_id, created_at),
    INDEX idx_user_type (user_id, data_type)
)
PARTITION BY HASH (user_id) PARTITIONS 16;
```

### 6.5 复合分区键的索引策略


**🔧 复合分区键的处理**
```sql
-- 复合分区键示例
CREATE TABLE complex_partition (
    id BIGINT AUTO_INCREMENT,
    region_id INT NOT NULL,
    created_date DATE NOT NULL,
    user_id INT NOT NULL,
    amount DECIMAL(10,2),
    
    -- 复合分区键：region_id + year(created_date)
    PRIMARY KEY (id, region_id, created_date),
    
    -- 索引设计需要考虑复合分区键
    INDEX idx_region_date_user (region_id, created_date, user_id),
    INDEX idx_region_date_amount (region_id, created_date, amount),
    
    -- 也可以有部分匹配的索引
    INDEX idx_user_region (user_id, region_id),
    INDEX idx_amount_date (amount, created_date)
)
PARTITION BY RANGE COLUMNS (region_id, created_date) (
    PARTITION p_r1_2024 VALUES LESS THAN (1, '2025-01-01'),
    PARTITION p_r2_2024 VALUES LESS THAN (2, '2025-01-01'),
    PARTITION p_r3_2024 VALUES LESS THAN (3, '2025-01-01')
);
```

---

## 7. 🔧 分区索引维护策略


### 7.1 分区索引维护的复杂性


**💡 为什么分区索引维护复杂**
分区表的索引维护比普通表更复杂，因为需要考虑多个分区间的协调和一致性。

```
维护复杂性来源：

数据层面：
- 每个分区都有独立的索引副本
- 分区间数据分布可能不均匀  
- 新增分区时需要创建对应索引

操作层面：
- 索引重建影响多个分区
- 统计信息需要分别维护
- DDL操作可能涉及全表锁

性能层面：
- 维护时间随分区数量增加
- 资源消耗分散在多个分区
- 并发维护的协调问题
```

### 7.2 分区索引日常维护


**🔄 定期维护操作**
```sql
-- 1. 分区索引统计信息更新
-- 更新单个分区的统计信息
ANALYZE TABLE orders_partitioned PARTITION (p2024);

-- 更新所有分区的统计信息
ANALYZE TABLE orders_partitioned;

-- 2. 分区索引重建
-- 重建单个分区的索引
ALTER TABLE orders_partitioned REBUILD PARTITION p2024;

-- 重建多个分区
ALTER TABLE orders_partitioned REBUILD PARTITION p2023, p2024;

-- 3. 检查分区索引状态
SELECT 
    PARTITION_NAME,
    INDEX_NAME,
    CARDINALITY,
    NULLABLE,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_NAME = 'orders_partitioned'
  AND INDEX_NAME != 'PRIMARY'
ORDER BY PARTITION_NAME, INDEX_NAME;
```

### 7.3 分区生命周期管理


**📅 分区生命周期中的索引处理**
```sql
-- 1. 添加新分区时的索引处理
-- 新分区会自动继承表的索引定义
ALTER TABLE orders_partitioned 
ADD PARTITION (PARTITION p2025 VALUES LESS THAN (2026));

-- 验证新分区的索引
SELECT PARTITION_NAME, INDEX_NAME 
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_NAME = 'orders_partitioned' 
  AND PARTITION_NAME = 'p2025';

-- 2. 删除分区时的索引清理
-- 删除分区时，对应的索引数据也会被删除
ALTER TABLE orders_partitioned DROP PARTITION p2022;

-- 3. 分区合并时的索引处理
-- 重新组织分区，索引会重新构建
ALTER TABLE orders_partitioned REORGANIZE PARTITION p2023, p2024 INTO (
    PARTITION p2023_2024 VALUES LESS THAN (2025)
);
```

### 7.4 索引碎片管理


**🧹 分区索引碎片处理**
```sql
-- 检查分区索引碎片情况
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    DATA_LENGTH,
    INDEX_LENGTH,
    DATA_FREE,
    (DATA_FREE / (DATA_LENGTH + INDEX_LENGTH)) * 100 as fragmentation_pct
FROM INFORMATION_SCHEMA.PARTITIONS 
WHERE TABLE_NAME = 'orders_partitioned'
  AND PARTITION_NAME IS NOT NULL
ORDER BY fragmentation_pct DESC;

-- 针对碎片严重的分区进行优化
ALTER TABLE orders_partitioned OPTIMIZE PARTITION p2024;

-- 或者重建特定分区
ALTER TABLE orders_partitioned REBUILD PARTITION p2024;
```

### 7.5 自动化维护脚本


**🤖 分区索引自动维护**
```sql
-- 创建维护存储过程
DELIMITER //
CREATE PROCEDURE maintain_partition_indexes(
    IN table_name VARCHAR(64),
    IN fragmentation_threshold DECIMAL(5,2) DEFAULT 20.0
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE partition_name VARCHAR(64);
    DECLARE frag_pct DECIMAL(5,2);
    
    -- 游标：查找碎片超过阈值的分区
    DECLARE partition_cursor CURSOR FOR
        SELECT 
            PARTITION_NAME,
            (DATA_FREE / (DATA_LENGTH + INDEX_LENGTH)) * 100 as fragmentation
        FROM INFORMATION_SCHEMA.PARTITIONS 
        WHERE TABLE_NAME = table_name
          AND PARTITION_NAME IS NOT NULL
          AND (DATA_FREE / (DATA_LENGTH + INDEX_LENGTH)) * 100 > fragmentation_threshold;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN partition_cursor;
    
    maintenance_loop: LOOP
        FETCH partition_cursor INTO partition_name, frag_pct;
        
        IF done THEN
            LEAVE maintenance_loop;
        END IF;
        
        -- 执行优化
        SET @sql = CONCAT('ALTER TABLE ', table_name, 
                         ' OPTIMIZE PARTITION ', partition_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE partition_cursor;
    
    -- 更新统计信息
    SET @sql = CONCAT('ANALYZE TABLE ', table_name);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
END //
DELIMITER ;

-- 调用维护过程
CALL maintain_partition_indexes('orders_partitioned', 15.0);
```

### 7.6 维护最佳实践


**📋 维护策略最佳实践**
```sql
-- 1. 分批维护策略：避免同时维护所有分区
-- 创建维护计划表
CREATE TABLE partition_maintenance_schedule (
    table_name VARCHAR(64),
    partition_name VARCHAR(64),
    maintenance_type VARCHAR(32),
    scheduled_time DATETIME,
    status VARCHAR(16) DEFAULT 'PENDING',
    execution_time DATETIME NULL,
    duration_seconds INT NULL,
    
    PRIMARY KEY (table_name, partition_name, maintenance_type),
    INDEX idx_scheduled_time (scheduled_time),
    INDEX idx_status (status)
);

-- 2. 维护监控：记录维护历史
CREATE TABLE partition_maintenance_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    partition_name VARCHAR(64),
    operation_type VARCHAR(32),
    start_time DATETIME,
    end_time DATETIME,
    rows_affected BIGINT,
    index_size_before BIGINT,
    index_size_after BIGINT,
    status VARCHAR(16),
    error_message TEXT NULL,
    
    INDEX idx_table_time (table_name, start_time)
);
```

---

## 8. 🎨 分区表索引设计模式


### 8.1 时间序列数据索引模式


**⏰ 时间驱动的索引设计模式**
这是最常见的分区索引设计模式，适用于日志、监控、交易等时间序列数据。

```sql
-- 时间序列索引设计模式
CREATE TABLE metrics_data (
    id BIGINT AUTO_INCREMENT,
    metric_time DATETIME NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value DOUBLE NOT NULL,
    host_id INT NOT NULL,
    tags JSON,
    
    -- 主键包含分区键
    PRIMARY KEY (id, metric_time),
    
    -- 模式1：时间优先索引（适合时间范围查询）
    INDEX idx_time_name_host (metric_time, metric_name, host_id),
    INDEX idx_time_host_name (metric_time, host_id, metric_name),
    
    -- 模式2：业务优先索引（适合业务查询）
    INDEX idx_name_time_host (metric_name, metric_time, host_id),
    INDEX idx_host_time_name (host_id, metric_time, metric_name),
    
    -- 模式3：覆盖索引（减少回表）
    INDEX idx_time_name_value (metric_time, metric_name, metric_value)
) 
PARTITION BY RANGE (UNIX_TIMESTAMP(metric_time)) (
    PARTITION p202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01')),
    PARTITION p202403 VALUES LESS THAN (UNIX_TIMESTAMP('2024-04-01'))
);

-- 典型查询模式及其优化
-- 查询1：时间范围 + 指标名称
SELECT metric_value, host_id 
FROM metrics_data 
WHERE metric_time BETWEEN '2024-01-15 00:00:00' AND '2024-01-15 23:59:59'
  AND metric_name = 'cpu_usage';
-- 使用索引：idx_time_name_host，分区剪枝到p202401
```

### 8.2 用户分片索引模式


**👤 用户维度的索引设计模式**
适用于社交网络、电商平台等以用户为核心的业务系统。

```sql
-- 用户分片索引设计模式
CREATE TABLE user_posts (
    post_id BIGINT AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    post_time DATETIME NOT NULL,
    like_count INT DEFAULT 0,
    comment_count INT DEFAULT 0,
    status TINYINT DEFAULT 1,
    
    -- 主键包含分区键
    PRIMARY KEY (post_id, user_id),
    
    -- 模式1：用户维度索引
    INDEX idx_user_time_status (user_id, post_time, status),
    INDEX idx_user_status_time (user_id, status, post_time),
    
    -- 模式2：热度排序索引  
    INDEX idx_user_likes_time (user_id, like_count, post_time),
    INDEX idx_user_comments_time (user_id, comment_count, post_time)
)
PARTITION BY HASH (user_id) PARTITIONS 32;

-- 查询优化示例
-- 查询用户时间线
SELECT post_id, content, post_time, like_count
FROM user_posts 
WHERE user_id = 12345 
  AND status = 1
ORDER BY post_time DESC 
LIMIT 20;
-- 优势：单分区查询，使用idx_user_status_time
```

### 8.3 地理分区索引模式


**🗺️ 地理位置的索引设计模式**
适用于LBS服务、物流系统、区域性业务等场景。

```sql
-- 地理分区索引设计模式
CREATE TABLE location_events (
    event_id BIGINT AUTO_INCREMENT,
    region_id INT NOT NULL,
    latitude DECIMAL(10,8) NOT NULL,
    longitude DECIMAL(11,8) NOT NULL,
    event_time DATETIME NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    user_id BIGINT,
    
    PRIMARY KEY (event_id, region_id),
    
    -- 模式1：地理位置索引
    INDEX idx_region_lat_lng (region_id, latitude, longitude),
    INDEX idx_region_time_type (region_id, event_time, event_type),
    
    -- 模式2：用户地理轨迹索引
    INDEX idx_region_user_time (region_id, user_id, event_time),
    
    -- 模式3：事件类型索引
    INDEX idx_region_type_time (region_id, event_type, event_time)
)
PARTITION BY LIST (region_id) (
    PARTITION p_north VALUES IN (1, 2, 3),
    PARTITION p_south VALUES IN (4, 5, 6),
    PARTITION p_east VALUES IN (7, 8, 9),
    PARTITION p_west VALUES IN (10, 11, 12)
);
```

### 8.4 混合分区索引模式


**🔀 复合条件的索引设计模式**
适用于复杂业务场景，需要同时考虑多个分区维度。

```sql
-- 混合分区索引设计模式
CREATE TABLE order_details (
    order_id BIGINT AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    order_date DATE NOT NULL,
    store_id INT NOT NULL,
    product_category VARCHAR(50) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status TINYINT DEFAULT 1,
    
    -- 复合主键
    PRIMARY KEY (order_id, order_date, user_id),
    
    -- 模式1：时间 + 用户维度
    INDEX idx_date_user_status (order_date, user_id, status),
    INDEX idx_user_date_amount (user_id, order_date, amount),
    
    -- 模式2：业务维度索引
    INDEX idx_date_store_category (order_date, store_id, product_category),
    INDEX idx_date_category_amount (order_date, product_category, amount),
    
    -- 模式3：分析型索引
    INDEX idx_date_status_amount (order_date, status, amount),
    INDEX idx_store_date_amount (store_id, order_date, amount)
)
PARTITION BY RANGE COLUMNS (order_date, user_id) (
    PARTITION p_202401_1 VALUES LESS THAN ('2024-02-01', 100000),
    PARTITION p_202401_2 VALUES LESS THAN ('2024-02-01', MAXVALUE),
    PARTITION p_202402_1 VALUES LESS THAN ('2024-03-01', 100000),
    PARTITION p_202402_2 VALUES LESS THAN ('2024-03-01', MAXVALUE)
);
```

### 8.5 索引模式选择指南


**📊 不同模式的适用场景**

| 索引模式 | **适用场景** | **查询特点** | **分区策略** | **维护复杂度** |
|----------|-------------|-------------|-------------|---------------|
| **时间序列模式** | 监控、日志、IoT数据 | 按时间范围查询为主 | 按时间RANGE分区 | 低 |
| **用户分片模式** | 社交、电商、SaaS | 按用户维度查询为主 | 按用户ID HASH分区 | 中 |
| **地理分区模式** | LBS、物流、O2O | 按地域查询为主 | 按地区LIST/RANGE分区 | 中 |
| **混合模式** | 复杂业务系统 | 多维度复合查询 | 复合分区策略 | 高 |

**🎯 模式选择决策树**
```
查询模式分析：
├─ 时间范围查询占80%以上？
│  └─ 是 → 选择时间序列模式
│
├─ 用户相关查询占80%以上？  
│  └─ 是 → 选择用户分片模式
│
├─ 地理位置查询重要？
│  └─ 是 → 选择地理分区模式
│
└─ 查询模式复杂多样？
   └─ 是 → 选择混合模式
```

---

## 9. 📈 分区索引性能影响分析


### 9.1 分区数量对索引性能的影响


**📊 分区数量与性能关系**
分区数量直接影响索引的查询性能和维护成本。

```sql
-- 测试不同分区数量的性能影响
-- 场景1：4个分区
CREATE TABLE perf_test_4p (
    id BIGINT AUTO_INCREMENT,
    user_id INT NOT NULL,
    created_at DATETIME NOT NULL,
    data VARCHAR(1000),
    
    PRIMARY KEY (id, created_at),
    INDEX idx_user_created (user_id, created_at)
) 
PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 场景2：32个分区  
CREATE TABLE perf_test_32p (
    id BIGINT AUTO_INCREMENT,
    user_id INT NOT NULL,
    created_at DATETIME NOT NULL,
    data VARCHAR(1000),
    
    PRIMARY KEY (id, created_at),
    INDEX idx_user_created (user_id, created_at)
)
PARTITION BY HASH (user_id) PARTITIONS 32;

-- 性能测试查询
-- 单分区查询
SELECT COUNT(*) FROM perf_test_4p 
WHERE created_at >= '2024-01-01';  -- 只扫描p2024

-- 跨分区查询  
SELECT COUNT(*) FROM perf_test_32p 
WHERE user_id = 12345;  -- 只扫描1个分区（HASH确定）

-- 全表扫描
SELECT COUNT(*) FROM perf_test_4p;   -- 扫描4个分区
SELECT COUNT(*) FROM perf_test_32p;  -- 扫描32个分区
```

### 9.2 索引选择性在分区中的表现


**🔍 分区内索引选择性分析**
```sql
-- 分析各分区的索引选择性
SELECT 
    PARTITION_NAME,
    INDEX_NAME,
    CARDINALITY,
    TABLE_ROWS,
    ROUND(CARDINALITY / TABLE_ROWS, 4) as selectivity
FROM INFORMATION_SCHEMA.STATISTICS s
JOIN INFORMATION_SCHEMA.PARTITIONS p ON 
    s.TABLE_NAME = p.TABLE_NAME AND 
    s.TABLE_SCHEMA = p.TABLE_SCHEMA
WHERE s.TABLE_NAME = 'orders_partitioned'
  AND s.INDEX_NAME != 'PRIMARY'
  AND p.PARTITION_NAME IS NOT NULL
ORDER BY PARTITION_NAME, selectivity DESC;

-- 不同分区可能有不同的索引效果
-- 示例结果分析：
-- p2024分区：user_id索引选择性 0.85（高效）
-- p2023分区：user_id索引选择性 0.23（效果一般）
-- p2022分区：user_id索引选择性 0.05（效果差）

-- 针对性优化：为不同分区创建不同的索引策略
-- ALTER TABLE orders_partitioned DROP INDEX idx_user_id;
-- 在高选择性分区保留索引，低选择性分区考虑其他策略
```

### 9.3 查询类型对性能的影响


**⚡ 不同查询模式的性能表现**
```sql
-- 性能测试：不同查询类型
-- 1. 点查询（最优）
EXPLAIN SELECT * FROM orders_partitioned 
WHERE order_date = '2024-06-15' AND user_id = 1001;
-- 结果：单分区 + 索引查找，性能最佳

-- 2. 范围查询（良好）
EXPLAIN SELECT * FROM orders_partitioned 
WHERE order_date BETWEEN '2024-06-01' AND '2024-06-30' 
  AND user_id = 1001;
-- 结果：单分区 + 索引范围扫描，性能良好

-- 3. 跨分区点查询（一般）
EXPLAIN SELECT * FROM orders_partitioned WHERE user_id = 1001;
-- 结果：多分区扫描 + 索引查找，性能一般

-- 4. 跨分区聚合（较差）
EXPLAIN SELECT COUNT(*), AVG(amount) 
FROM orders_partitioned 
WHERE status = 1;
-- 结果：全分区扫描 + 聚合，性能较差

-- 5. 无索引全表扫描（最差）
EXPLAIN SELECT * FROM orders_partitioned WHERE amount > 10000;
-- 结果：全分区全表扫描，性能最差
```

### 9.4 数据分布对索引性能的影响


**📊 数据倾斜对索引的影响**
```sql
-- 检查分区数据分布情况
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    AVG_ROW_LENGTH,
    DATA_LENGTH,
    INDEX_LENGTH,
    ROUND(TABLE_ROWS / SUM(TABLE_ROWS) OVER() * 100, 2) as data_percentage
FROM INFORMATION_SCHEMA.PARTITIONS 
WHERE TABLE_NAME = 'orders_partitioned'
  AND PARTITION_NAME IS NOT NULL
ORDER BY TABLE_ROWS DESC;

-- 示例结果分析：
-- p2024: 800,000行 (80%) - 数据集中，索引压力大
-- p2023: 150,000行 (15%) - 数据适中，索引正常  
-- p2022: 50,000行  (5%)  - 数据较少，索引效果好

-- 数据倾斜的优化策略
-- 1. 重新设计分区策略
-- 2. 为数据量大的分区创建更多索引
-- 3. 考虑分区再分割
ALTER TABLE orders_partitioned REORGANIZE PARTITION p2024 INTO (
    PARTITION p2024q1 VALUES LESS THAN ('2024-04-01'),
    PARTITION p2024q2 VALUES LESS THAN ('2024-07-01'), 
    PARTITION p2024q3 VALUES LESS THAN ('2024-10-01'),
    PARTITION p2024q4 VALUES LESS THAN ('2025-01-01')
);
```

### 9.5 并发访问对分区索引的影响


**🚀 并发场景下的性能分析**
```sql
-- 模拟并发访问测试
-- 场景1：同分区并发访问（锁竞争）
-- 多个连接同时查询p2024分区
SELECT * FROM orders_partitioned PARTITION(p2024) 
WHERE user_id = 1001 FOR UPDATE;

-- 场景2：不同分区并发访问（无锁竞争）
-- 连接1查询p2024，连接2查询p2023
SELECT * FROM orders_partitioned PARTITION(p2024) WHERE user_id = 1001;
SELECT * FROM orders_partitioned PARTITION(p2023) WHERE user_id = 2002;

-- 监控锁等待情况
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;

-- 分区并发访问的优势：
-- ✅ 不同分区间的操作可以并行进行
-- ✅ 锁的粒度更细，减少锁等待
-- ✅ 索引维护可以分区进行，减少阻塞时间
```

### 9.6 性能优化建议


**🎯 基于分析的优化建议**
```sql
-- 优化策略1：索引右对齐设计
-- 不推荐：分区键不在索引最前面
CREATE INDEX idx_user_date_bad ON orders_partitioned (user_id, order_date);

-- 推荐：分区键在索引最前面  
CREATE INDEX idx_date_user_good ON orders_partitioned (order_date, user_id);

-- 优化策略2：覆盖索引减少回表
CREATE INDEX idx_cover_common_query ON orders_partitioned 
(order_date, user_id, status, amount);

-- 优化策略3：部分索引减少维护成本
-- 只为活跃数据创建索引
CREATE INDEX idx_active_orders ON orders_partitioned (order_date, user_id)
WHERE status IN (1, 2);  -- MySQL 8.0.13+支持

-- 优化策略4：压缩索引节省空间
-- ALTER TABLE orders_partitioned ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
```

---

## 10. 🔄 分区间索引一致性管理


### 10.1 索引一致性的重要性


**💡 为什么需要索引一致性管理**
在分区表中，每个分区都有独立的索引副本，必须确保所有分区的索引结构和状态保持一致。

```
一致性问题的表现：

结构一致性问题：
- 某些分区缺少必要索引
- 不同分区的索引定义不同
- 索引命名不规范

数据一致性问题：
- 索引统计信息过期
- 索引损坏或不完整
- 索引碎片程度差异很大

性能一致性问题：
- 不同分区的查询性能差异巨大
- 执行计划在分区间不稳定
- 索引选择策略不一致
```

### 10.2 索引结构一致性检查


**🔍 检查分区间索引结构一致性**
```sql
-- 检查所有分区是否有相同的索引
WITH partition_indexes AS (
    SELECT 
        PARTITION_NAME,
        INDEX_NAME,
        GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as index_columns,
        COUNT(*) as column_count
    FROM INFORMATION_SCHEMA.STATISTICS 
    WHERE TABLE_NAME = 'orders_partitioned'
      AND PARTITION_NAME IS NOT NULL
    GROUP BY PARTITION_NAME, INDEX_NAME
),
index_consistency AS (
    SELECT 
        INDEX_NAME,
        COUNT(DISTINCT index_columns) as structure_variations,
        COUNT(DISTINCT PARTITION_NAME) as partition_count,
        GROUP_CONCAT(DISTINCT index_columns) as all_structures
    FROM partition_indexes
    GROUP BY INDEX_NAME
)
SELECT 
    INDEX_NAME,
    structure_variations,
    partition_count,
    CASE 
        WHEN structure_variations = 1 THEN '一致'
        ELSE '不一致' 
    END as consistency_status,
    all_structures
FROM index_consistency
WHERE structure_variations > 1;  -- 只显示不一致的索引

-- 检查缺失的索引
SELECT 
    p1.PARTITION_NAME as missing_in_partition,
    p2.INDEX_NAME as missing_index
FROM (
    SELECT DISTINCT PARTITION_NAME 
    FROM INFORMATION_SCHEMA.PARTITIONS 
    WHERE TABLE_NAME = 'orders_partitioned' 
      AND PARTITION_NAME IS NOT NULL
) p1
CROSS JOIN (
    SELECT DISTINCT INDEX_NAME 
    FROM INFORMATION_SCHEMA.STATISTICS 
    WHERE TABLE_NAME = 'orders_partitioned' 
      AND INDEX_NAME != 'PRIMARY'
) p2
LEFT JOIN INFORMATION_SCHEMA.STATISTICS s ON 
    s.TABLE_NAME = 'orders_partitioned' 
    AND s.PARTITION_NAME = p1.PARTITION_NAME 
    AND s.INDEX_NAME = p2.INDEX_NAME
WHERE s.INDEX_NAME IS NULL;
```

### 10.3 索引统计信息一致性


**📊 统计信息一致性管理**
```sql
-- 检查各分区的索引统计信息
SELECT 
    s.PARTITION_NAME,
    s.INDEX_NAME,
    s.CARDINALITY,
    p.TABLE_ROWS,
    CASE 
        WHEN p.TABLE_ROWS > 0 THEN ROUND(s.CARDINALITY / p.TABLE_ROWS, 4)
        ELSE 0 
    END as selectivity,
    p.UPDATE_TIME
FROM INFORMATION_SCHEMA.STATISTICS s
JOIN INFORMATION_SCHEMA.PARTITIONS p ON 
    s.TABLE_NAME = p.TABLE_NAME 
    AND s.PARTITION_NAME = p.PARTITION_NAME
WHERE s.TABLE_NAME = 'orders_partitioned'
  AND s.INDEX_NAME != 'PRIMARY'
  AND s.PARTITION_NAME IS NOT NULL
ORDER BY s.INDEX_NAME, s.PARTITION_NAME;

-- 查找统计信息严重过期的分区
SELECT 
    PARTITION_NAME,
    INDEX_NAME,
    CARDINALITY,
    TABLE_ROWS,
    UPDATE_TIME,
    DATEDIFF(NOW(), UPDATE_TIME) as days_since_update
FROM INFORMATION_SCHEMA.STATISTICS s
JOIN INFORMATION_SCHEMA.PARTITIONS p USING (TABLE_NAME, PARTITION_NAME)
WHERE s.TABLE_NAME = 'orders_partitioned'
  AND DATEDIFF(NOW(), UPDATE_TIME) > 7  -- 超过7天未更新
ORDER BY days_since_update DESC;
```

### 10.4 自动化一致性维护


**🤖 自动化索引一致性管理**
```sql
-- 创建索引一致性维护存储过程
DELIMITER //
CREATE PROCEDURE maintain_index_consistency(
    IN target_table VARCHAR(64)
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE partition_name VARCHAR(64);
    DECLARE days_old INT;
    
    DECLARE stats_cursor CURSOR FOR
        SELECT DISTINCT p.PARTITION_NAME, DATEDIFF(NOW(), p.UPDATE_TIME) as age
        FROM INFORMATION_SCHEMA.PARTITIONS p
        WHERE p.TABLE_NAME = target_table
          AND p.PARTITION_NAME IS NOT NULL
          AND DATEDIFF(NOW(), p.UPDATE_TIME) > 7;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN stats_cursor;
    
    update_loop: LOOP
        FETCH stats_cursor INTO partition_name, days_old;
        
        IF done THEN
            LEAVE update_loop;
        END IF;
        
        -- 更新统计信息
        SET @sql = CONCAT('ANALYZE TABLE ', target_table, ' PARTITION(', partition_name, ')');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE stats_cursor;
END //
DELIMITER ;

-- 调用一致性维护过程
CALL maintain_index_consistency('orders_partitioned');
```

### 10.5 一致性监控告警


**⚠️ 一致性问题监控**
```sql
-- 创建一致性监控视图
CREATE VIEW partition_index_health AS
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    COUNT(DISTINCT PARTITION_NAME) as partition_count,
    AVG(CARDINALITY) as avg_cardinality,
    STDDEV(CARDINALITY) as cardinality_stddev,
    MIN(UPDATE_TIME) as oldest_update,
    MAX(UPDATE_TIME) as newest_update,
    DATEDIFF(MAX(UPDATE_TIME), MIN(UPDATE_TIME)) as update_time_diff,
    CASE 
        WHEN COUNT(DISTINCT PARTITION_NAME) < (
            SELECT COUNT(*) FROM INFORMATION_SCHEMA.PARTITIONS 
            WHERE TABLE_NAME = s.TABLE_NAME AND PARTITION_NAME IS NOT NULL
        ) THEN 'MISSING_PARTITIONS'
        WHEN DATEDIFF(NOW(), MIN(UPDATE_TIME)) > 14 THEN 'STALE_STATS'
        WHEN STDDEV(CARDINALITY) / AVG(CARDINALITY) > 0.5 THEN 'HIGH_VARIANCE'
        ELSE 'HEALTHY'
    END as health_status
FROM INFORMATION_SCHEMA.STATISTICS s
WHERE PARTITION_NAME IS NOT NULL
  AND INDEX_NAME != 'PRIMARY'
GROUP BY TABLE_NAME, INDEX_NAME;

-- 查询需要关注的索引
SELECT * FROM partition_index_health 
WHERE health_status != 'HEALTHY'
ORDER BY health_status DESC;
```

### 10.6 一致性恢复策略


**🔄 索引一致性恢复方法**
```sql
-- 恢复缺失的索引
-- 1. 识别缺失索引的分区
SELECT DISTINCT PARTITION_NAME
FROM INFORMATION_SCHEMA.PARTITIONS 
WHERE TABLE_NAME = 'orders_partitioned' 
  AND PARTITION_NAME NOT IN (
    SELECT DISTINCT PARTITION_NAME 
    FROM INFORMATION_SCHEMA.STATISTICS 
    WHERE TABLE_NAME = 'orders_partitioned' 
      AND INDEX_NAME = 'idx_user_id'
  );

-- 2. 重建整个表的索引（确保一致性）
ALTER TABLE orders_partitioned DROP INDEX idx_user_id;
ALTER TABLE orders_partitioned ADD INDEX idx_user_id (user_id);

-- 3. 针对特定分区的索引修复
ALTER TABLE orders_partitioned REBUILD PARTITION p2024;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


**🔸 分区索引基本原理**
```
✓ 分区表索引 - 每个分区独立维护索引副本
✓ 局部索引 - MySQL只支持局部索引，无真正全局索引
✓ 分区剪枝 - 优化器自动排除无关分区，提升性能
✓ 索引一致性 - 所有分区的索引结构必须保持一致
✓ 维护策略 - 分区索引需要专门的维护方法
```

### 11.2 关键设计原则


**🎯 分区索引设计的核心原则**
```
原则1：分区键优先
- 唯一索引必须包含分区键
- 复合索引推荐分区键作为前导列
- 查询条件尽量包含分区键

原则2：业务导向设计
- 时间序列数据按时间分区
- 用户数据按用户ID分区  
- 地理数据按地区分区

原则3：平衡性能与维护
- 分区数量不宜过多（建议8-32个）
- 索引数量要适中
- 考虑维护成本

原则4：监控与优化
- 定期检查索引一致性
- 监控分区数据分布
- 及时更新统计信息
```

### 11.3 性能优化要点


**⚡ 关键性能优化策略**
```sql
-- 索引设计优化
-- ✅ 推荐：分区键在索引前面
CREATE INDEX idx_good ON table_name (partition_key, business_key);

-- ❌ 不推荐：分区键在后面
CREATE INDEX idx_bad ON table_name (business_key, partition_key);

-- 查询优化
-- ✅ 推荐：包含分区键条件
SELECT * FROM table_name WHERE partition_key = 'value' AND business_key = 'value';

-- ❌ 不推荐：不包含分区键
SELECT * FROM table_name WHERE business_key = 'value';

-- 维护优化
-- ✅ 推荐：分批维护
ANALYZE TABLE table_name PARTITION (p1);
ANALYZE TABLE table_name PARTITION (p2);

-- ❌ 不推荐：同时维护所有分区（可能造成长时间锁定）
ANALYZE TABLE table_name;
```

### 11.4 常见问题与解决方案


**🔍 典型问题处理指南**
```
问题1：跨分区查询性能差
解决方案：
- 重新设计分区策略
- 添加分区键到查询条件
- 使用应用层分别查询合并结果
- 考虑使用搜索引擎

问题2：分区间索引不一致  
解决方案：
- 建立定期一致性检查机制
- 使用自动化脚本维护
- 重建问题分区的索引
- 统一索引管理流程

问题3：某些分区性能特别差
解决方案：
- 检查数据分布是否倾斜
- 分析索引选择性差异
- 考虑分区再划分
- 针对性优化索引结构

问题4：索引维护时间过长
解决方案：
- 分批进行索引维护
- 选择业务低峰期操作
- 使用在线DDL特性
- 考虑分区数量优化
```

### 11.5 实际应用建议


**📊 生产环境最佳实践**
```
设计阶段：
✓ 根据主要查询模式设计分区策略
✓ 选择合适的分区键和索引键关系
✓ 预估数据增长和分区数量
✓ 考虑未来的扩展需求

实施阶段：
✓ 先在测试环境充分验证
✓ 制定详细的迁移计划
✓ 准备回滚方案
✓ 监控迁移过程

运维阶段：
✓ 建立分区索引监控体系
✓ 定期检查一致性
✓ 制定维护计划和流程
✓ 持续优化分区策略

扩展阶段：
✓ 根据业务增长调整分区
✓ 优化索引结构
✓ 考虑新技术方案
✓ 评估架构演进需求
```

### 11.6 技术演进趋势


**🚀 分区索引技术发展方向**
```
当前限制：
- MySQL不支持真正的全局索引
- 跨分区查询性能有限
- 维护复杂度随分区数增加

技术趋势：
- 分布式数据库的全局索引支持
- 智能分区策略自动调整
- 基于机器学习的索引优化
- 云原生的分区管理服务

选择建议：
- 大数据场景考虑分布式数据库
- 复杂查询考虑搜索引擎
- 简单场景MySQL分区已足够
- 关注新技术发展趋势
```

**核心记忆**：
- 分区表索引是局部索引，每个分区独立维护
- 分区键与索引键的关系直接影响查询性能
- 分区剪枝是性能优化的关键，要充分利用
- 跨分区查询需要特殊优化策略
- 索引一致性管理是分区表运维的重要环节