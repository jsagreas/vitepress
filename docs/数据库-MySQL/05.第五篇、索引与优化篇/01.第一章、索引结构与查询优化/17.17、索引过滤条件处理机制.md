---
title: 17、索引过滤条件处理机制
---
## 📚 目录

1. [索引过滤条件基础概念](#1-索引过滤条件基础概念)
2. [条件下推优化机制](#2-条件下推优化机制)
3. [范围条件边界处理](#3-范围条件边界处理)
4. [多条件组合过滤策略](#4-多条件组合过滤策略)
5. [条件选择性评估](#5-条件选择性评估)
6. [过滤条件重排序优化](#6-过滤条件重排序优化)
7. [短路评估机制](#7-短路评估机制)
8. [条件评估成本模型](#8-条件评估成本模型)
9. [实际应用与优化策略](#9-实际应用与优化策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引过滤条件基础概念


### 1.1 什么是索引过滤条件

**索引过滤条件**就是在使用索引查询时，数据库如何智能地处理各种查询条件，让查询更快更高效。

```sql
-- 简单示例
SELECT * FROM users 
WHERE age > 25 AND city = '北京' AND status = 'active';

-- MySQL需要决定：
-- 1. 先用哪个条件过滤？
-- 2. 哪些条件可以在索引层面处理？
-- 3. 哪些条件需要回表后处理？
```

**🔸 过滤条件的处理层次**
```
查询条件处理的三个层次：

索引层过滤：
├── 直接使用索引结构过滤
├── 效率最高，IO最少
└── 示例：WHERE id = 100

索引回表前过滤：  
├── 利用索引中的附加列过滤
├── 减少回表次数
└── 示例：覆盖索引中的非主键列条件

表层过滤：
├── 回表后在原始数据上过滤
├── 效率最低，IO最多
└── 示例：索引中没有的列的条件
```

### 1.2 过滤条件的分类

**🔸 按处理位置分类**
```
Index Condition（索引条件）：
- 能够使用索引直接定位的条件
- 示例：WHERE id = 100, WHERE name = 'Zhang'

Filter Condition（过滤条件）：
- 需要在索引或表数据上额外过滤的条件  
- 示例：WHERE age > 30, WHERE UPPER(name) = 'ZHANG'

Join Condition（连接条件）：
- 表连接时使用的条件
- 示例：WHERE t1.id = t2.user_id
```

**🔸 按条件复杂度分类**
```
简单条件：
├── 等值条件：column = value
├── 范围条件：column > value, column BETWEEN v1 AND v2
└── NULL条件：column IS NULL

复合条件：
├── AND组合：condition1 AND condition2
├── OR组合：condition1 OR condition2  
└── IN条件：column IN (v1, v2, v3)

复杂条件：
├── 函数条件：UPPER(column) = 'VALUE'
├── 计算条件：column1 + column2 > 100
└── 子查询条件：column IN (SELECT ...)
```

---

## 2. ⚡ 条件下推优化机制


### 2.1 条件下推基本概念

**条件下推（Predicate Pushdown）** 是数据库优化器将过滤条件尽可能早地应用，减少需要处理的数据量。

```
传统处理流程：
读取所有数据 → 应用所有条件 → 返回结果

条件下推后：
应用可下推条件 → 读取筛选后数据 → 应用剩余条件 → 返回结果

好处：减少IO、减少内存使用、提高查询速度
```

### 2.2 条件下推的层次结构

```
条件下推的执行层次：

存储引擎层下推（ICP - Index Condition Pushdown）
├── 在存储引擎内部就应用条件
├── 减少存储引擎与MySQL服务层的数据传输
└── 示例：复合索引的非前缀列条件

索引层下推
├── 在索引扫描时应用条件
├── 减少需要访问的索引页
└── 示例：范围扫描的边界条件

表扫描层下推
├── 在全表扫描时应用条件
├── 减少返回给上层的行数
└── 示例：没有合适索引时的条件应用
```

### 2.3 Index Condition Pushdown (ICP) 详解

**🔸 ICP的工作原理**
```sql
-- 假设有复合索引：KEY idx_age_city (age, city)
SELECT * FROM users 
WHERE age > 25 AND city = '北京' AND status = 'active';

-- 没有ICP的执行：
-- 1. 使用索引找到age > 25的记录
-- 2. 对每条记录回表获取完整行数据
-- 3. 在MySQL服务层检查city = '北京' AND status = 'active'

-- 有ICP的执行：
-- 1. 使用索引找到age > 25的记录  
-- 2. 在存储引擎层就检查city = '北京'（因为city在索引中）
-- 3. 只对满足前两个条件的记录回表
-- 4. 在MySQL服务层只需检查status = 'active'
```

**🔸 ICP的适用条件**
```
ICP可以下推的条件：
✅ 涉及索引中包含的列
✅ 不是索引的前导列但在复合索引中
✅ 简单的比较操作（=, >, <, BETWEEN等）
✅ 不涉及子查询的条件

ICP不能下推的条件：
❌ 涉及索引中没有的列
❌ 存储过程和函数调用
❌ 触发器相关的条件
❌ 复杂的表达式计算
```

### 2.4 条件下推的实际示例

```sql
-- 创建测试表和索引
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    product_id INT, 
    order_date DATE,
    amount DECIMAL(10,2),
    status VARCHAR(20),
    KEY idx_user_product (user_id, product_id),
    KEY idx_date_status (order_date, status)
);

-- 查询1：ICP优化示例
EXPLAIN SELECT * FROM orders 
WHERE user_id > 1000 AND product_id = 100;

-- 执行计划显示：
-- Extra: Using index condition
-- 说明：product_id = 100条件被下推到存储引擎层
```

---

## 3. 🎛️ 范围条件边界处理


### 3.1 范围条件的边界确定

**范围条件**需要确定扫描的起始点和结束点，这个过程叫**边界处理**。

```sql
-- 范围查询示例
SELECT * FROM products WHERE price BETWEEN 100 AND 500;

-- MySQL需要确定：
-- 起始边界：第一个price >= 100的记录位置
-- 结束边界：最后一个price <= 500的记录位置
-- 扫描方式：从起始边界顺序扫描到结束边界
```

### 3.2 边界处理的优化策略

**🔸 精确边界定位**
```sql
-- 场景：复合索引 KEY idx_price_category (price, category)
SELECT * FROM products 
WHERE price >= 100 AND price <= 500 AND category = 'electronics';

-- 边界处理策略：
-- 1. 使用价格范围确定扫描边界
-- 2. 在范围内使用category条件进一步过滤
-- 3. 避免扫描不必要的索引页
```

**🔸 范围条件的截断优化**
```
范围截断原理：
当遇到范围条件时，后续的索引列不能再用于范围确定

示例：KEY idx_abc (a, b, c)
WHERE a = 1 AND b > 10 AND c = 5

索引使用情况：
├── a = 1：精确匹配，可以使用
├── b > 10：范围条件，可以使用
└── c = 5：无法用于索引范围，只能作为过滤条件

优化策略：调整索引列顺序，将范围条件放在最后
```

### 3.3 多重范围条件处理

```sql
-- 多重范围条件示例
SELECT * FROM sales 
WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31'
  AND amount >= 1000 
  AND quantity BETWEEN 10 AND 100;

-- 处理策略：
-- 1. 选择选择性最高的范围条件作为主扫描范围
-- 2. 其他范围条件作为过滤条件
-- 3. 评估不同组合的扫描成本
```

**🔸 范围条件成本评估**
```
范围扫描成本 = 扫描的索引页数 + 回表的数据页数

成本评估因素：
├── 范围大小：范围越大，扫描成本越高
├── 数据分布：数据分布均匀时成本预估更准确
├── 索引选择性：选择性高的索引成本更低
└── 缓存命中率：热点数据的访问成本更低

成本比较：
假设索引 KEY idx_date (sale_date), KEY idx_amount (amount)
- sale_date范围包含1000万条记录
- amount范围包含100万条记录  
- 优化器会选择amount索引，然后过滤sale_date条件
```

---

## 4. 🔗 多条件组合过滤策略


### 4.1 AND条件组合优化

**AND条件**可以同时生效，优化器会选择最优的处理顺序。

```sql
-- AND条件组合示例
SELECT * FROM customers 
WHERE age > 30 AND city = '上海' AND vip_level = 'gold' AND status = 'active';

-- 可能的索引：
-- KEY idx_age (age)
-- KEY idx_city (city)  
-- KEY idx_vip (vip_level)
-- KEY idx_status (status)
```

**🔸 AND条件的处理策略**
```
策略1：单索引+过滤
├── 选择选择性最高的索引
├── 使用该索引获取候选记录
└── 用其他条件过滤结果

策略2：索引合并（Index Merge）
├── 同时使用多个单列索引
├── 对结果进行交集运算
└── 适用于各条件选择性都很高的情况

策略3：复合索引匹配
├── 使用包含多列的复合索引
├── 最高效的方式
└── 需要预先建立合适的复合索引

成本比较：
复合索引 < 单索引+过滤 < 索引合并 < 全表扫描
```

**🔸 复合索引的列顺序优化**
```sql
-- 对于查询：WHERE a = ? AND b > ? AND c = ?
-- 最优索引顺序：KEY idx_optimal (a, c, b)

-- 原因：
-- 1. 等值条件（a=?, c=?）放在前面，精确定位
-- 2. 范围条件（b>?）放在最后，避免截断后续列
-- 3. 这样索引利用率最高
```

### 4.2 OR条件组合处理

**OR条件**需要获取多个条件的并集，处理更复杂。

```sql
-- OR条件示例
SELECT * FROM products 
WHERE category = 'electronics' OR price < 100;

-- 处理策略：
-- 1. 如果有合适的复合索引，使用范围扫描
-- 2. 否则使用索引合并（Index Merge Union）
-- 3. 最坏情况下进行全表扫描
```

**🔸 OR条件优化策略**
```
优化策略1：条件重写
将OR条件重写为UNION查询
SELECT * FROM products WHERE category = 'electronics'
UNION
SELECT * FROM products WHERE price < 100;

优化策略2：索引覆盖
使用包含所有相关列的索引避免回表
KEY idx_category_price_id (category, price, id)

优化策略3：条件合并
将多个OR条件合并为IN条件（适用于等值条件）
WHERE id = 1 OR id = 2 OR id = 3
=> WHERE id IN (1, 2, 3)
```

### 4.3 混合条件处理

```sql
-- 复杂的混合条件
SELECT * FROM orders 
WHERE (user_id = 1001 OR user_id = 1002) 
  AND order_date >= '2023-01-01' 
  AND status IN ('paid', 'shipped');

-- 处理步骤：
-- 1. 识别条件类型和优先级
-- 2. 将复杂条件转换为索引友好的形式
-- 3. 选择最优的索引访问路径
-- 4. 确定条件应用顺序
```

---

## 5. 📊 条件选择性评估


### 5.1 选择性的基本概念

**选择性（Selectivity）** 是指条件能够过滤掉多少数据的度量。

```
选择性计算公式：
选择性 = 满足条件的记录数 / 总记录数

选择性范围：0 到 1
- 选择性越接近0，过滤效果越好
- 选择性越接近1，过滤效果越差

示例：
总记录数：1,000,000
WHERE status = 'active'满足条件的记录：800,000
选择性 = 800,000 / 1,000,000 = 0.8（选择性较差）

WHERE id = 12345满足条件的记录：1  
选择性 = 1 / 1,000,000 = 0.000001（选择性极佳）
```

### 5.2 选择性评估方法

**🔸 统计信息收集**
```sql
-- MySQL收集的统计信息
SELECT 
    table_name,
    column_name, 
    cardinality,  -- 不重复值的数量
    nullable
FROM information_schema.statistics 
WHERE table_schema = 'test_db';

-- 估算选择性
-- 选择性 ≈ 1 / cardinality（对于等值查询）
```

**🔸 直方图统计（MySQL 8.0+）**
```sql
-- 创建直方图统计信息
ANALYZE TABLE customers UPDATE HISTOGRAM ON age, city;

-- 查看直方图信息
SELECT 
    schema_name,
    table_name, 
    column_name,
    histogram
FROM information_schema.column_statistics;

-- 直方图提供更准确的数据分布信息
-- 帮助优化器做出更好的选择性评估
```

### 5.3 条件选择性的应用

**🔸 索引选择优化**
```sql
-- 假设有两个单列索引
-- KEY idx_age (age) - 选择性 0.1
-- KEY idx_city (city) - 选择性 0.01

SELECT * FROM users WHERE age = 25 AND city = '北京';

-- 优化器选择：
-- 1. 评估每个条件的选择性
-- 2. 选择选择性更好的索引（idx_city）
-- 3. 使用city索引，然后过滤age条件
```

**🔸 复合索引列顺序优化**
```sql
-- 对于查询条件的选择性：
-- gender: 0.5 (男/女两个值)
-- age_group: 0.1 (10个年龄段)  
-- city: 0.01 (100个城市)

-- 最优索引顺序：KEY idx_optimal (city, age_group, gender)
-- 原因：按选择性从高到低排列，最大化索引效率
```

### 5.4 动态选择性评估

```sql
-- 参数化查询的选择性评估
PREPARE stmt FROM 'SELECT * FROM orders WHERE user_id = ? AND order_date > ?';

-- 挑战：
-- 不同参数值的选择性差异很大
-- user_id = 1（老用户，订单很多）vs user_id = 999999（新用户，订单很少）
-- order_date > '2023-01-01'（大范围）vs order_date > '2023-12-31'（小范围）

-- MySQL的处理：
-- 1. 使用历史统计信息估算
-- 2. 对于常见参数值，可能缓存执行计划
-- 3. 必要时重新评估和优化
```

---

## 6. 🔄 过滤条件重排序优化


### 6.1 条件重排序的原理

**条件重排序**是指优化器调整多个过滤条件的评估顺序，以提高查询效率。

```
重排序的目标：
1. 将成本低、选择性高的条件放在前面
2. 将成本高、选择性低的条件放在后面  
3. 最大化短路评估的效果

示例：
原始条件：expensive_function(col1) = 1 AND col2 = 'value' 
重排序后：col2 = 'value' AND expensive_function(col1) = 1

好处：如果col2条件不满足，就不会执行昂贵的函数调用
```

### 6.2 条件成本评估

**🔸 条件评估成本的分类**
```
成本分类（从低到高）：

常量比较：
├── column = constant
├── column > constant  
└── 成本：极低，直接内存比较

简单函数：
├── UPPER(column), LENGTH(column)
├── 内置数学函数
└── 成本：低，简单计算

复杂函数：
├── 正则表达式：column REGEXP pattern
├── 字符串匹配：column LIKE '%pattern%'
└── 成本：中等，需要复杂计算

子查询：
├── column IN (SELECT ...)
├── EXISTS (SELECT ...)
└── 成本：高，需要执行额外查询

自定义函数：
├── 用户自定义函数
├── 存储过程调用
└── 成本：最高，不可预测
```

### 6.3 重排序算法

**🔸 基于成本的重排序**
```sql
-- 原始查询
SELECT * FROM products 
WHERE UPPER(name) LIKE '%PHONE%'  -- 高成本
  AND price > 100                 -- 低成本，高选择性
  AND category_id = 1             -- 低成本，中选择性
  AND custom_score(id) > 0.8;     -- 极高成本

-- 优化器重排序后的逻辑执行顺序：
-- 1. price > 100 (低成本，高选择性)
-- 2. category_id = 1 (低成本，中选择性)  
-- 3. UPPER(name) LIKE '%PHONE%' (高成本)
-- 4. custom_score(id) > 0.8 (极高成本)
```

**🔸 重排序策略**
```
策略1：贪心算法
按照 (选择性/成本) 比值排序，比值高的先执行

策略2：动态规划  
考虑条件间的相关性，找到全局最优顺序

策略3：启发式规则
├── 等值条件 > 范围条件 > 模糊匹配
├── 索引列条件 > 非索引列条件
└── 简单表达式 > 复杂函数调用

策略4：历史统计优化
根据历史执行情况调整条件顺序
```

### 6.4 重排序的限制

```sql
-- 不能重排序的情况

-- 1. 有依赖关系的条件
SELECT * FROM users 
WHERE email IS NOT NULL AND LENGTH(email) > 10;
-- LENGTH(email) 依赖于 email IS NOT NULL，不能调换顺序

-- 2. 短路逻辑要求
SELECT * FROM products 
WHERE price > 0 AND (total_sales / price) > 100;
-- price > 0 必须先执行，避免除零错误

-- 3. 用户明确指定的顺序（使用括号）
SELECT * FROM orders 
WHERE (status = 'pending' OR status = 'processing') 
  AND order_date > '2023-01-01';
-- 括号内的条件不能与外部条件重排序
```

---

## 7. ⚡ 短路评估机制


### 7.1 短路评估基本原理

**短路评估（Short-Circuit Evaluation）** 是指在逻辑运算中，如果前面的条件已经能确定结果，就不再评估后续条件。

```
AND短路评估：
A AND B AND C
如果A为false，直接返回false，不评估B和C

OR短路评估：  
A OR B OR C
如果A为true，直接返回true，不评估B和C

性能优势：
- 减少不必要的计算
- 降低函数调用成本
- 提高查询响应速度
```

### 7.2 短路评估的应用场景

**🔸 避免昂贵操作**
```sql
-- 场景1：避免不必要的函数调用
SELECT * FROM documents 
WHERE file_size > 0 AND complex_text_analysis(content) = 'positive';

-- 短路评估效果：
-- 如果file_size <= 0，就不会调用complex_text_analysis函数
-- 节省大量计算资源

-- 场景2：避免除零错误
SELECT * FROM sales 
WHERE quantity > 0 AND revenue / quantity > 100;

-- 短路评估保证：
-- quantity > 0 为false时，不会执行除法运算
-- 避免运行时错误
```

**🔸 索引优化中的短路评估**
```sql
-- 复合索引：KEY idx_status_date (status, order_date)
SELECT * FROM orders 
WHERE status = 'shipped' AND order_date > '2023-01-01' AND amount > 1000;

-- 执行过程：
-- 1. 使用索引快速定位status = 'shipped'的记录
-- 2. 在这些记录中继续筛选order_date > '2023-01-01' 
-- 3. 对通过前两步的记录，检查amount > 1000
-- 短路评估避免了对不满足status条件的记录进行后续检查
```

### 7.3 短路评估的优化策略

**🔸 条件顺序优化**
```sql
-- 优化前：低效的条件顺序
SELECT * FROM users 
WHERE expensive_score_function(id) > 0.8 
  AND age > 18 
  AND status = 'active';

-- 优化后：高效的条件顺序
SELECT * FROM users 
WHERE status = 'active'                    -- 快速过滤
  AND age > 18                            -- 进一步过滤  
  AND expensive_score_function(id) > 0.8; -- 最后执行昂贵操作

-- 效果：大大减少expensive_score_function的调用次数
```

**🔸 条件合并优化**
```sql
-- 合并相似条件提高短路效率
-- 优化前：
WHERE (col1 = 1 OR col1 = 2) AND expensive_function(col2) = 'result'

-- 优化后：  
WHERE col1 IN (1, 2) AND expensive_function(col2) = 'result'

-- IN条件的短路评估更高效
```

### 7.4 短路评估与索引的结合

```sql
-- 场景：利用索引顺序优化短路评估
CREATE INDEX idx_price_category ON products(price, category);

SELECT * FROM products 
WHERE price BETWEEN 100 AND 1000 
  AND category = 'electronics'
  AND complex_quality_check(description) = 'high';

-- 执行优化：
-- 1. 使用索引快速定位价格范围内的产品
-- 2. 利用索引中的category列进一步过滤
-- 3. 只对通过前两步的产品执行complex_quality_check
-- 短路评估大大减少了昂贵函数的调用次数
```

---

## 8. 💰 条件评估成本模型


### 8.1 成本模型基本概念

**成本模型**是数据库优化器用来评估不同查询执行策略的成本，选择最优方案的数学模型。

```
成本模型包含的因素：

IO成本：
├── 磁盘页面读取成本
├── 随机IO vs 顺序IO
└── 缓存命中率的影响

CPU成本：
├── 条件评估的计算成本
├── 数据比较和转换成本
└── 函数调用的处理成本

内存成本：
├── 排序缓冲区使用成本
├── 临时表创建成本
└── 连接缓冲区使用成本
```

### 8.2 条件评估成本计算

**🔸 基本成本公式**
```
单条件评估成本 = 基础成本 + 复杂度成本

基础成本：
├── 简单比较：0.1 cost unit
├── 函数调用：1.0 cost unit
└── 子查询：10.0+ cost unit

复杂度成本：
├── 数据类型转换：+0.1 cost unit
├── 字符串操作：+0.2 cost unit
└── 正则表达式：+1.0 cost unit

总查询成本 = Σ(条件成本 × 评估次数)
```

**🔸 实际成本评估示例**
```sql
-- 查询示例
SELECT * FROM orders 
WHERE user_id = 1001                    -- 成本：0.1
  AND order_date > '2023-01-01'         -- 成本：0.1  
  AND UPPER(product_name) = 'IPHONE'    -- 成本：0.3 (0.1 + 0.2)
  AND total_amount > 1000               -- 成本：0.1
  AND is_valid_order(id) = 1;           -- 成本：5.0 (自定义函数)

-- 假设需要评估1000条记录：
-- 总成本 = (0.1 + 0.1 + 0.3 + 0.1 + 5.0) × 1000 = 5600 cost units

-- 如果通过短路评估，只需要评估100条记录的is_valid_order：
-- 优化后成本 = (0.1 + 0.1 + 0.3 + 0.1) × 1000 + 5.0 × 100 = 1100 cost units
```

### 8.3 成本模型的校准

**🔸 统计信息校准**
```sql
-- MySQL收集统计信息来校准成本模型
ANALYZE TABLE orders;

-- 查看成本相关的系统变量
SHOW VARIABLES LIKE '%cost%';

-- 主要成本参数：
-- optimizer_disk_cost = 1.0  (读取一个页面的成本)
-- optimizer_cpu_cost = 0.2   (处理一行数据的成本)
```

**🔸 成本模型调优**
```sql
-- 调整成本参数（谨慎操作）
SET SESSION optimizer_disk_cost = 1.5;  -- 增加磁盘访问成本权重
SET SESSION optimizer_cpu_cost = 0.1;   -- 降低CPU处理成本权重

-- 这会影响优化器对索引 vs 全表扫描的选择
```

### 8.4 多维条件成本模型

**🔸 条件相关性成本**
```sql
-- 相关条件的成本不是简单相加
SELECT * FROM users 
WHERE city = '北京' AND province = '北京市';

-- 这两个条件高度相关：
-- city = '北京' 的选择性：0.05
-- province = '北京市' 的选择性：0.05
-- 但两个条件组合的选择性不是 0.05 × 0.05 = 0.0025
-- 实际可能是 0.05 (因为高度相关)

-- 成本模型需要考虑条件间的相关性
```

**🔸 缓存效应成本模型**
```
热点数据访问成本模型：

首次访问：完整的磁盘IO成本
缓存命中：极低的内存访问成本  

动态成本调整：
├── 监控缓存命中率
├── 根据数据热度调整成本估算
└── 为热点查询提供更准确的成本预估

应用场景：
经常查询的用户信息、商品信息等
缓存命中时的查询成本大大降低
```

---

## 9. 🛠️ 实际应用与优化策略


### 9.1 索引过滤条件优化实战

**🔸 场景1：电商订单查询优化**
```sql
-- 业务场景：查询用户的近期有效订单
SELECT order_id, product_name, amount 
FROM orders 
WHERE user_id = 12345 
  AND order_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
  AND status IN ('paid', 'shipped', 'delivered')
  AND amount > 100;

-- 当前索引：KEY idx_user_id (user_id)
-- 问题：只能使用user_id索引，其他条件需要全部扫描该用户的所有订单

-- 优化方案1：创建复合索引
CREATE INDEX idx_user_date_status ON orders(user_id, order_date, status);

-- 优化效果：
-- ✅ user_id精确定位
-- ✅ order_date范围扫描
-- ✅ status条件可以下推到存储引擎层
-- ❌ amount条件仍需回表后过滤

-- 优化方案2：覆盖索引（如果查询列不多）
CREATE INDEX idx_user_date_status_amount ON orders(
    user_id, order_date, status, amount, order_id, product_name
);
-- ✅ 避免回表，查询性能最佳
-- ❌ 索引维护成本较高
```

**🔸 场景2：复杂搜索条件优化**
```sql
-- 业务场景：商品搜索
SELECT * FROM products 
WHERE category_id = 10 
  AND price BETWEEN 100 AND 1000
  AND brand_id IN (1, 5, 10, 15)
  AND rating >= 4.0
  AND stock_quantity > 0
  AND MATCH(title, description) AGAINST('smartphone' IN NATURAL LANGUAGE MODE);

-- 分析各条件的选择性：
-- category_id = 10: 选择性 0.1 (10个分类)
-- price范围: 选择性 0.3  
-- brand_id: 选择性 0.2 (4个品牌 / 20个总品牌)
-- rating >= 4.0: 选择性 0.4
-- stock_quantity > 0: 选择性 0.8
-- 全文搜索: 选择性 0.05

-- 优化策略：
-- 1. 先使用全文搜索索引（选择性最高）
-- 2. 创建复合索引处理其他高选择性条件
CREATE INDEX idx_category_brand_price ON products(category_id, brand_id, price);
-- 3. rating和stock_quantity作为过滤条件
```

### 9.2 条件重写优化技巧

**🔸 OR条件重写**
```sql
-- 低效的OR查询
SELECT * FROM orders 
WHERE (status = 'pending' AND user_id = 1001)
   OR (status = 'shipped' AND user_id = 1001);

-- 重写为更高效的形式
SELECT * FROM orders 
WHERE user_id = 1001 AND status IN ('pending', 'shipped');

-- 进一步优化：如果有复合索引
-- KEY idx_user_status (user_id, status) 
-- 这个查询可以完全使用索引
```

**🔸 复杂条件简化**
```sql
-- 复杂的日期条件
SELECT * FROM events 
WHERE YEAR(event_date) = 2023 AND MONTH(event_date) = 12;

-- 重写为索引友好的形式
SELECT * FROM events 
WHERE event_date >= '2023-12-01' 
  AND event_date < '2024-01-01';

-- 好处：可以使用event_date列上的索引进行范围扫描
```

### 9.3 参数化查询优化

```sql
-- 准备语句的条件处理
PREPARE stmt FROM 'SELECT * FROM products WHERE category_id = ? AND price > ?';

-- 挑战：不同参数值导致不同的最优执行计划
-- category_id = 1（热门分类，大量商品）
-- category_id = 100（小众分类，少量商品）

-- 优化策略：
-- 1. 使用直方图统计提高估算准确性
ANALYZE TABLE products UPDATE HISTOGRAM ON category_id, price;

-- 2. 监控执行计划的稳定性
SELECT sql_text, exec_count, avg_cost 
FROM performance_schema.events_statements_summary_by_digest
WHERE sql_text LIKE '%products%';

-- 3. 必要时使用查询提示
SELECT /*+ USE_INDEX(products idx_category_price) */ * 
FROM products WHERE category_id = ? AND price > ?;
```

### 9.4 性能监控与调优

**🔸 监控查询执行情况**
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 1;
SET GLOBAL long_query_time = 1;

-- 分析慢查询
-- 关注Using where过多的查询，可能存在条件处理优化空间

-- 使用EXPLAIN分析执行计划
EXPLAIN FORMAT=JSON SELECT * FROM orders 
WHERE user_id = 1001 AND order_date > '2023-01-01';

-- 关注：
-- rows_examined_per_scan: 扫描的行数
-- filtered: 过滤后剩余的行数百分比  
-- index_condition: 是否使用了索引条件下推
```

**🔸 性能测试验证**
```sql
-- 创建性能测试脚本
DELIMITER $$
CREATE PROCEDURE test_query_performance()
BEGIN
    DECLARE i INT DEFAULT 0;
    DECLARE start_time TIMESTAMP;
    DECLARE end_time TIMESTAMP;
    
    SET start_time = NOW(6);
    
    WHILE i < 1000 DO
        -- 执行测试查询
        SELECT COUNT(*) FROM orders 
        WHERE user_id = FLOOR(1 + RAND() * 10000)
          AND order_date > DATE_SUB(NOW(), INTERVAL 30 DAY);
        SET i = i + 1;
    END WHILE;
    
    SET end_time = NOW(6);
    SELECT TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000 AS avg_ms;
END$$
DELIMITER ;

-- 对比优化前后的性能差异
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念

```
🔸 索引过滤条件：查询条件在索引层面的智能处理机制
🔸 条件下推(ICP)：将过滤条件下推到存储引擎层，减少数据传输
🔸 条件选择性：衡量过滤条件筛选效果的重要指标
🔸 短路评估：避免不必要计算的逻辑优化机制
🔸 成本模型：优化器选择最优执行策略的数学基础
```

### 10.2 关键理解要点


**🔹 条件下推的价值**
```
理解要点：
- 条件下推不是万能的，需要满足特定条件
- ICP主要优化复合索引的非前缀列条件
- 能显著减少存储引擎与服务层的数据传输
- 通过EXPLAIN可以看到"Using index condition"标识

实际效果：
- 减少回表次数，降低IO开销
- 提高CPU缓存命中率
- 在大数据量查询中效果尤其明显
```

**🔹 多条件组合的优化策略**
```
AND条件：所有条件都要满足
- 优先使用选择性最高的条件
- 复合索引比多个单列索引效率高
- 注意索引列顺序对性能的影响

OR条件：满足任一条件即可
- 考虑重写为UNION查询
- 索引合并的成本可能很高
- 有时全表扫描反而更效率

混合条件：需要综合考虑
- 将复杂条件转换为索引友好形式
- 利用条件重排序和短路评估
- 监控执行计划的稳定性
```

**🔹 成本模型的实际应用**
```
成本因素：
- IO成本通常是性能瓶颈
- CPU成本在复杂计算时不可忽视
- 缓存状态影响实际成本

调优策略：
- 关注条件评估的成本差异
- 将高成本条件放在短路评估的后面
- 使用统计信息帮助优化器做出更好决策
```

### 10.3 实际应用指导


**🔸 索引设计建议**
```
复合索引设计原则：
✅ 等值条件列放在前面
✅ 范围条件列放在后面  
✅ 选择性高的列优先
✅ 考虑查询的多样性

索引维护：
- 定期更新统计信息
- 监控索引使用情况
- 清理无效索引
- 考虑索引的维护成本
```

**🔸 查询优化实践**
```
条件优化检查清单：
☑️ 避免在WHERE子句中使用函数
☑️ 将OR条件重写为UNION或IN  
☑️ 使用合适的数据类型避免隐式转换
☑️ 利用复合索引减少回表
☑️ 监控慢查询日志识别优化机会

性能验证：
- 使用EXPLAIN分析执行计划
- 通过实际测试验证优化效果
- 监控生产环境的性能指标
- 建立性能基准和回归测试
```

**🔸 故障排查指南**
```
常见性能问题：
❌ 查询条件无法使用索引
❌ 复合索引的列顺序不合理
❌ 条件选择性评估不准确
❌ 统计信息过期导致执行计划异常

排查步骤：
1. 分析EXPLAIN输出，关注rows和filtered
2. 检查索引使用情况和条件下推
3. 验证统计信息的准确性
4. 测试不同的索引和查询策略
5. 监控系统资源使用情况
```

**核心记忆口诀**：
```
条件过滤有学问，下推短路是关键
选择性高效果好，成本模型做指导
索引设计要合理，统计信息常更新
监控分析不可少，优化验证要做到
```