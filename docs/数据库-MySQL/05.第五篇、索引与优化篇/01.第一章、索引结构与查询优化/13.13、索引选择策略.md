---
title: 13、索引选择策略
---
## 📚 目录

1. [索引选择机制概述](#1-索引选择机制概述)
2. [优化器索引选择原理](#2-优化器索引选择原理)
3. [多索引竞争分析](#3-多索引竞争分析)
4. [强制索引HINT应用](#4-强制索引HINT应用)
5. [索引合并策略](#5-索引合并策略)
6. [全表扫描判断机制](#6-全表扫描判断机制)
7. [索引扫描成本计算](#7-索引扫描成本计算)
8. [查询计划稳定性保障](#8-查询计划稳定性保障)
9. [索引选择监控与优化](#9-索引选择监控与优化)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引选择机制概述


### 1.1 什么是索引选择


**🔸 简单理解**
索引选择就像在图书馆里找书，当有多个索引可用时，MySQL需要**智能决策**选择哪个索引最高效。就像你可以按书名找、按作者找、按分类找，系统要选择最快的方式。

**🔸 索引选择的核心问题**
```
一个查询语句面临的选择：

方案1: 使用索引A → 预估扫描1000行 → 预估成本50
方案2: 使用索引B → 预估扫描500行  → 预估成本30  ✅最优
方案3: 全表扫描   → 预估扫描10000行 → 预估成本200
方案4: 索引合并   → 预估扫描800行  → 预估成本60

MySQL优化器的任务：从这些方案中选择成本最低的
```

### 1.2 索引选择决策流程


**🔥 索引选择决策树**
```
查询开始
    |
解析WHERE条件
    |
收集可用索引
    |
┌───────────┬────────────┬───────────┐
|           |            |           |
单列索引     复合索引      索引合并     全表扫描
|           |            |           |
|           |            |           |
计算成本     计算成本      计算成本     计算成本
|           |            |           |
└───────────┴────────────┴───────────┘
                |
            选择最低成本方案
                |
            生成执行计划
                |
            执行查询
```

### 1.3 索引选择的影响因素


**📊 核心影响因素**
```
数据分布因素 ────────┐
                  ├── 表的行数、索引选择性
                  └── 数据倾斜程度

查询特征因素 ────────┐
                  ├── WHERE条件复杂度
                  └── 需要返回的列

系统状态因素 ────────┐
                  ├── 内存状况、I/O负载
                  └── 并发查询数量

统计信息因素 ────────┐
                  ├── 索引统计信息准确性
                  └── 表统计信息更新频率
```

---

## 2. 🧠 优化器索引选择原理


### 2.1 优化器工作机制


**🔸 优化器的核心任务**
MySQL优化器就像一个**智能导航系统**，它要在众多路径中找到到达目的地的最短路径。

**🔸 选择步骤详解**
1. **收集候选索引**：找出所有可能用到的索引
2. **计算访问成本**：估算每种方案的代价
3. **比较选择最优**：选择成本最低的方案
4. **生成执行计划**：确定具体的执行步骤

### 2.2 成本计算模型


**🔥 成本计算公式**
```sql
-- 查看优化器成本计算
EXPLAIN FORMAT=JSON
SELECT * FROM users 
WHERE age > 25 AND city = 'Beijing';

-- 成本计算要素：
-- I/O成本 = 需要读取的页面数 × 页面读取成本
-- CPU成本 = 需要检查的行数 × 行处理成本
-- 总成本 = I/O成本 + CPU成本
```

**📊 成本要素分析**
```
I/O成本计算：
• 索引页面读取：1.0
• 数据页面读取：1.0  
• 随机I/O代价高于顺序I/O

CPU成本计算：
• 行比较操作：0.2
• 键比较操作：0.1
• 内存操作代价低于磁盘I/O

网络成本（结果传输）：
• 返回行数 × 0.1
• 大结果集传输成本不可忽视
```

### 2.3 统计信息的作用


**🔸 统计信息重要性**
统计信息就像**地图的准确度**，如果地图错误，导航系统就会做出错误选择。

**🔥 关键统计信息**
```sql
-- 查看表统计信息
SHOW TABLE STATUS LIKE 'users';

-- 查看索引统计信息  
SHOW INDEX FROM users;

-- 手动更新统计信息
ANALYZE TABLE users;
```

**📋 统计信息内容**
```
表级统计信息：
┌─────────────────┬─────────────────┬─────────────────┐
│    统计项       │      含义        │    影响决策      │
├─────────────────┼─────────────────┼─────────────────┤
│   总行数        │   表的记录数      │   全表扫描成本    │
│   平均行长      │   每行字节数      │   I/O成本计算    │
│   数据文件大小   │   物理存储大小    │   读取页面数     │
└─────────────────┴─────────────────┴─────────────────┘

索引级统计信息：
┌─────────────────┬─────────────────┬─────────────────┐
│    统计项       │      含义        │    影响决策      │
├─────────────────┼─────────────────┼─────────────────┤
│   基数          │   不重复值数量    │   选择性计算     │
│   索引深度      │   B+树层级数     │   随机I/O次数    │
│   叶子页面数    │   叶子节点数量    │   范围扫描成本   │
└─────────────────┴─────────────────┴─────────────────┘
```

---

## 3. ⚔️ 多索引竞争分析


### 3.1 多索引竞争场景


**🔸 什么是多索引竞争**
当一个查询有多个索引可用时，就像多条路线通往同一个目的地，优化器需要选择最优路线。

**🔸 常见竞争场景**
```sql
-- 表结构示例
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    
    INDEX idx_user_id (user_id),
    INDEX idx_order_date (order_date), 
    INDEX idx_status (status),
    INDEX idx_user_status (user_id, status),
    INDEX idx_date_status (order_date, status)
);
```

**🔥 多索引竞争示例**
```sql
-- 查询：特定用户的特定状态订单
SELECT * FROM orders 
WHERE user_id = 12345 AND status = 'completed';

-- 可用索引选择：
-- 1. idx_user_id: 通过user_id过滤，再检查status
-- 2. idx_status: 通过status过滤，再检查user_id  
-- 3. idx_user_status: 直接命中两个条件 ✅ 通常最优
-- 4. 索引合并: 合并idx_user_id和idx_status结果
```

### 3.2 索引竞争成本比较


**🔥 索引竞争成本分析**
```sql
-- 分析不同索引的选择成本
EXPLAIN FORMAT=JSON
SELECT * FROM orders 
WHERE user_id = 12345 AND status = 'completed';

-- 强制使用不同索引对比成本
SELECT * FROM orders USE INDEX(idx_user_id)
WHERE user_id = 12345 AND status = 'completed';

SELECT * FROM orders USE INDEX(idx_status) 
WHERE user_id = 12345 AND status = 'completed';

SELECT * FROM orders USE INDEX(idx_user_status)
WHERE user_id = 12345 AND status = 'completed';
```

**📊 成本对比分析**
```
假设数据分布：
• 总订单数：100万
• user_id=12345的订单：1000条  
• status='completed'的订单：60万条
• 同时满足两个条件：800条

索引选择成本分析：
┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│    索引名       │   过滤后行数     │    额外过滤     │    总成本       │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│  idx_user_id    │     1000        │   检查800行     │      高         │
│  idx_status     │     60万        │   检查800行     │     很高        │
│  idx_user_status│     800         │      0         │      低 ✅      │
│  全表扫描       │     100万       │   检查100万行   │     最高        │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

### 3.3 查询模式识别


**🔸 不同查询模式的索引选择**
```sql
-- 等值查询模式
SELECT * FROM orders WHERE user_id = 12345;
-- 最佳：单列精确索引

-- 范围查询模式  
SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';
-- 最佳：范围列为前缀的索引

-- 多条件AND查询
SELECT * FROM orders WHERE user_id = 12345 AND status = 'pending';
-- 最佳：多列复合索引

-- 多条件OR查询
SELECT * FROM orders WHERE user_id = 12345 OR status = 'pending';
-- 考虑：索引合并或全表扫描

-- 排序查询
SELECT * FROM orders WHERE user_id = 12345 ORDER BY order_date;
-- 最佳：(user_id, order_date)复合索引
```

---

## 4. 💡 强制索引HINT应用


### 4.1 HINT语法和应用场景


**🔸 什么时候需要强制索引**
虽然优化器很智能，但有时会因为统计信息不准确或特殊场景而选择错误。这时需要人工**强制指定**索引。

**🔥 常用HINT语法**
```sql
-- USE INDEX: 建议使用指定索引
SELECT * FROM orders USE INDEX(idx_user_id) 
WHERE user_id = 12345;

-- FORCE INDEX: 强制使用指定索引
SELECT * FROM orders FORCE INDEX(idx_order_date)
WHERE order_date > '2024-01-01';

-- IGNORE INDEX: 忽略指定索引
SELECT * FROM orders IGNORE INDEX(idx_status)
WHERE status = 'completed';

-- 多个HINT组合
SELECT * FROM orders 
USE INDEX(idx_user_id, idx_order_date) 
IGNORE INDEX(idx_status)
WHERE user_id = 12345 AND order_date > '2024-01-01';
```

### 4.2 HINT应用实践


**🔸 典型应用场景**
```sql
-- 场景1：统计信息过期导致错误选择
-- 优化器选择了全表扫描，但实际索引更优
SELECT COUNT(*) FROM orders 
FORCE INDEX(idx_order_date)
WHERE order_date = '2024-01-15';

-- 场景2：小表JOIN大表，强制使用小表驱动
SELECT * FROM users u 
FORCE INDEX(PRIMARY)
JOIN orders o USE INDEX(idx_user_id) ON u.id = o.user_id
WHERE u.register_date > '2024-01-01';

-- 场景3：避免索引合并的低效
SELECT * FROM orders 
USE INDEX(idx_user_status)
WHERE user_id IN (1,2,3) AND status = 'pending';
```

### 4.3 HINT使用注意事项


**⚠️ 使用HINT的风险**
```
风险评估：

数据变化风险 ────────┐
                  ├── 数据分布改变可能让强制索引变劣
                  └── 需要定期重新评估HINT有效性

维护成本风险 ────────┐
                  ├── 增加SQL维护复杂度
                  └── 索引结构改变需要修改HINT

性能测试建议：
✅ HINT前后性能对比测试
✅ 不同数据量下的效果验证  
✅ 定期回归测试HINT合理性
```

---

## 5. 🔗 索引合并策略


### 5.1 索引合并基本概念


**🔸 什么是索引合并**
索引合并就像**多条线索的汇总**，当单个索引都不够好时，MySQL会考虑将多个索引的结果合并。

**🔸 索引合并类型**
```
交集合并(intersect) ─────┐
                      ├── AND条件，取交集
                      └── WHERE a=1 AND b=2

并集合并(union) ─────────┐  
                      ├── OR条件，取并集
                      └── WHERE a=1 OR b=2

排序合并(sort-union) ────┐
                      ├── 复杂OR条件
                      └── WHERE a>1 OR b<10
```

### 5.2 索引合并实现机制


**🔥 交集合并示例**
```sql
-- 表结构
CREATE TABLE products (
    id INT PRIMARY KEY,
    category_id INT,
    brand_id INT,
    price DECIMAL(10,2),
    
    INDEX idx_category (category_id),
    INDEX idx_brand (brand_id),
    INDEX idx_price (price)
);

-- 交集合并查询
SELECT * FROM products 
WHERE category_id = 5 AND brand_id = 10;

-- 执行过程：
-- 1. 通过idx_category找到category_id=5的行ID集合
-- 2. 通过idx_brand找到brand_id=10的行ID集合  
-- 3. 计算两个集合的交集
-- 4. 根据交集中的行ID回表获取完整数据
```

**📊 索引合并成本分析**
```
合并成本 = 索引1扫描成本 + 索引2扫描成本 + 合并计算成本 + 回表成本

场景分析：
条件A过滤结果：10000行
条件B过滤结果：8000行  
AND条件交集：1000行

成本比较：
• 单用索引A：扫描10000行 + 过滤8000行 = 高成本
• 单用索引B：扫描8000行 + 过滤2000行 = 中成本  
• 索引合并：扫描18000行 + 合并计算 + 回表1000行 = 需要评估
• 复合索引：直接命中1000行 = 最低成本 ✅
```

### 5.3 索引合并优化策略


**🔸 何时有效使用索引合并**
```sql
-- 有效场景：选择性都很好的独立条件
SELECT * FROM orders 
WHERE user_id = 12345 AND order_date = '2024-01-15';
-- 如果没有复合索引(user_id, order_date)，合并可能有效

-- 无效场景：选择性差的条件
SELECT * FROM orders 
WHERE status = 'active' AND created_date > '2024-01-01';  
-- status选择性差，合并效果不好
```

**💡 优化建议**
```
索引合并 vs 复合索引：

优先考虑复合索引：
✅ 性能更稳定可预测
✅ 减少回表操作
✅ 避免合并计算开销

索引合并适用场景：
✅ 临时查询需求
✅ 无法创建所有复合索引
✅ 多个独立高选择性条件
```

---

## 6. 🔍 全表扫描判断机制


### 6.1 全表扫描触发条件


**🔸 什么时候会全表扫描**
全表扫描就像逐页翻书找内容，虽然看起来笨拙，但在某些情况下确实是最合理的选择。

**🔸 触发全表扫描的常见原因**
```sql
-- 1. 查询大部分数据（超过30%）
SELECT * FROM users WHERE age > 18;  -- 如果大部分用户都大于18岁

-- 2. 索引选择性太差
SELECT * FROM orders WHERE status = 'active';  -- 如果90%订单都是active

-- 3. 复杂表达式无法使用索引
SELECT * FROM users WHERE YEAR(create_date) = 2024;

-- 4. 类型转换导致索引失效  
SELECT * FROM users WHERE user_id = '12345';  -- user_id是INT类型

-- 5. 统计信息过期
-- 优化器基于错误信息认为全表扫描更优
```

### 6.2 全表扫描判断算法


**🔥 全表扫描成本计算**
```
全表扫描成本计算公式：

总成本 = (数据页面数 × 页面读取成本) + (总行数 × 行检查成本)

示例计算：
表大小：100万行
数据页面：10000页  
页面读取成本：1.0
行检查成本：0.2

全表扫描成本 = 10000 × 1.0 + 1000000 × 0.2 = 210000

索引扫描成本（假设返回10%数据）：
索引扫描 = 1000 + 100000 × 0.2 + 100000 × 1.0 = 121000 ✅

结论：当需要返回的数据超过某个阈值时，全表扫描反而更优
```

### 6.3 全表扫描优化策略


**🔸 避免不必要的全表扫描**
```sql
-- 优化前：全表扫描
SELECT * FROM users WHERE YEAR(create_date) = 2024;

-- 优化后：使用索引
SELECT * FROM users 
WHERE create_date >= '2024-01-01' 
AND create_date < '2025-01-01';

-- 优化前：隐式类型转换
SELECT * FROM users WHERE user_id = '12345';

-- 优化后：显式类型匹配
SELECT * FROM users WHERE user_id = 12345;
```

**💡 合理利用全表扫描**
```sql
-- 场景1：小表查询
SELECT * FROM config_table WHERE status = 'Y';  -- 配置表只有几百行

-- 场景2：大范围数据分析
SELECT COUNT(*), AVG(amount) FROM orders 
WHERE order_date >= '2024-01-01';  -- 分析型查询，需要大部分数据

-- 场景3：无索引的临时查询
SELECT * FROM temp_data WHERE process_flag IS NULL;  -- 临时表，创建索引成本高
```

---

## 7. 💰 索引扫描成本计算


### 7.1 成本模型组成


**🔸 成本计算的核心要素**
MySQL的成本计算就像**出租车计费**，包含起步价、里程费、时间费等多个维度。

**📊 成本计算要素**
```
I/O成本 ─────────────────┐
                       ├── 磁盘页面读取
                       └── 随机I/O vs 顺序I/O

CPU成本 ─────────────────┐
                       ├── 行数据处理  
                       └── 条件匹配计算

内存成本 ────────────────┐
                       ├── 缓冲池命中率
                       └── 排序内存使用

网络成本 ────────────────┐
                       ├── 结果集传输
                       └── 网络带宽影响
```

### 7.2 详细成本计算方法


**🔥 索引扫描成本计算**
```sql
-- 查看详细的成本计算
EXPLAIN FORMAT=JSON
SELECT * FROM orders 
WHERE user_id = 12345 AND status = 'completed';
```

**📋 成本计算实例**
```
假设场景：
• 表orders有100万行
• user_id索引高度为3层
• 预估匹配1000行
• 每页16KB，每行100字节

索引扫描成本计算：
1. 索引遍历成本：3（索引深度）× 1.0 = 3.0
2. 索引范围扫描：预估扫描索引页数 × 1.0  
3. 回表成本：1000（匹配行数）× 1.0 = 1000.0
4. CPU处理成本：1000 × 0.2 = 200.0
5. 总成本：约1203.0

全表扫描成本：
1. 数据页读取：10000（总页数）× 1.0 = 10000.0  
2. CPU处理：1000000（总行数）× 0.2 = 200000.0
3. 总成本：约210000.0

结论：索引扫描成本远低于全表扫描
```

### 7.3 影响成本计算的因素


**🔸 缓冲池命中率影响**
```sql
-- 查看缓冲池状态
SHOW ENGINE INNODB STATUS\G

-- 缓冲池命中率计算
SELECT 
  (1 - (Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests)) * 100 
  AS buffer_pool_hit_rate
FROM 
  (SELECT VARIABLE_VALUE AS Innodb_buffer_pool_reads 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') a,
  (SELECT VARIABLE_VALUE AS Innodb_buffer_pool_read_requests 
   FROM performance_schema.global_status 
   WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') b;
```

**💡 成本优化策略**
```
提高缓冲池命中率：
✅ 适当增大innodb_buffer_pool_size
✅ 优化查询减少随机I/O
✅ 合理设计索引减少回表

降低CPU成本：
✅ 提高索引选择性
✅ 减少不必要的函数计算  
✅ 优化WHERE条件顺序

减少网络传输：
✅ 只查询必要的列
✅ 适当使用LIMIT限制结果
✅ 考虑结果集压缩
```

---

## 8. 🔒 查询计划稳定性保障


### 8.1 查询计划不稳定的原因


**🔸 什么是查询计划不稳定**
查询计划不稳定就像**导航路线突然改变**，同样的查询在不同时间可能选择不同的执行计划，导致性能波动。

**🔸 计划不稳定的常见原因**
```
统计信息变化 ─────────┐
                   ├── 数据分布改变
                   └── AUTO_UPDATE_STATISTICS

参数设置变化 ─────────┐
                   ├── 优化器参数调整
                   └── 系统配置修改

数据量波动 ──────────┐
                   ├── 业务高峰期数据激增
                   └── 历史数据清理

并发负载影响 ────────┐
                   ├── 系统负载高时优化器倾向简单计划
                   └── 内存不足影响成本计算
```

### 8.2 计划稳定性监控


**🔥 查询计划变化监控**
```sql
-- 开启查询日志分析
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 0.1;

-- 使用Performance Schema监控
SELECT 
    sql_text,
    count_star as execution_count,
    avg_timer_wait/1000000000 as avg_exec_time_sec,
    sum_rows_examined/count_star as avg_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE sql_text LIKE '%orders%'
ORDER BY count_star DESC
LIMIT 10;

-- 查询计划hash值监控（MySQL 8.0+）
SELECT 
    query_sample_text,
    plan_hash,
    count_star,
    avg_timer_wait
FROM performance_schema.events_statements_summary_by_digest
WHERE query_sample_text LIKE '%specific_query%'
ORDER BY last_seen DESC;
```

### 8.3 稳定性保障措施


**🔸 查询计划固定策略**
```sql
-- 方法1：使用HINT固定索引选择
SELECT /*+ USE_INDEX(orders, idx_user_status) */ 
* FROM orders 
WHERE user_id = 12345 AND status = 'completed';

-- 方法2：定期更新统计信息
-- 创建定时任务
EVENT scheduler: 
CREATE EVENT update_table_stats
ON SCHEDULE EVERY 1 DAY
DO ANALYZE TABLE orders, users, products;

-- 方法3：使用SQL Plan Baselines（MySQL 8.0+）
-- 固定特定查询的执行计划
```

**💡 最佳实践建议**
```
预防措施：
✅ 建立统计信息更新策略
✅ 监控关键查询性能变化
✅ 设置查询性能基线和告警

应急措施：
✅ 准备强制索引的备用SQL
✅ 建立查询性能回退机制
✅ 快速统计信息重建流程

长期措施：  
✅ 优化索引设计减少计划选择
✅ 简化复杂查询减少不稳定性
✅ 定期评估和调整优化器参数
```

---

## 9. 📊 索引选择监控与优化


### 9.1 索引使用统计监控


**🔸 监控索引使用情况**
监控索引使用就像**健康体检**，定期检查能及时发现问题。

**🔥 索引使用统计查询**
```sql
-- 查看索引使用统计
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    SEQ_IN_INDEX,
    COLUMN_NAME,
    CARDINALITY
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;

-- 查看从未使用的索引（MySQL 8.0+）
SELECT 
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE count_star = 0
AND object_schema = 'your_database'
AND index_name IS NOT NULL;

-- 查看索引使用频率
SELECT 
    object_schema,
    object_name,
    index_name,
    count_star as usage_count,
    sum_timer_wait/1000000000 as total_time_sec
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY count_star DESC;
```

### 9.2 索引选择问题诊断


**🔥 常见索引选择问题诊断**
```sql
-- 1. 检查是否存在重复索引
SELECT 
    a.TABLE_SCHEMA,
    a.TABLE_NAME,
    a.INDEX_NAME as index1,
    b.INDEX_NAME as index2,
    a.COLUMN_NAME
FROM information_schema.STATISTICS a
JOIN information_schema.STATISTICS b 
ON a.TABLE_SCHEMA = b.TABLE_SCHEMA 
AND a.TABLE_NAME = b.TABLE_NAME
AND a.COLUMN_NAME = b.COLUMN_NAME
AND a.INDEX_NAME < b.INDEX_NAME
WHERE a.TABLE_SCHEMA = 'your_database';

-- 2. 检查低选择性索引
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME, 
    INDEX_NAME,
    COLUMN_NAME,
    CARDINALITY,
    (SELECT TABLE_ROWS FROM information_schema.TABLES t 
     WHERE t.TABLE_SCHEMA = s.TABLE_SCHEMA 
     AND t.TABLE_NAME = s.TABLE_NAME) as table_rows,
    ROUND(CARDINALITY / (SELECT TABLE_ROWS FROM information_schema.TABLES t 
                        WHERE t.TABLE_SCHEMA = s.TABLE_SCHEMA 
                        AND t.TABLE_NAME = s.TABLE_NAME) * 100, 2) as selectivity_percent
FROM information_schema.STATISTICS s
WHERE TABLE_SCHEMA = 'your_database'
AND SEQ_IN_INDEX = 1  -- 只看复合索引的第一列
HAVING selectivity_percent < 10
ORDER BY selectivity_percent;
```

### 9.3 索引选择优化建议


**📋 优化决策矩阵**
```
┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   问题类型      │      症状        │      原因        │    解决方案      │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ 索引选择错误     │ 查询时间波动大   │ 统计信息不准     │ 定期ANALYZE     │
│ 多索引冲突      │ 计划不稳定       │ 索引设计重叠     │ 合并或删除索引   │
│ 索引未被使用     │ 存在冗余索引     │ 索引设计不合理   │ 删除无用索引     │
│ 全表扫描频繁     │ 查询性能差       │ 缺少合适索引     │ 创建针对性索引   │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

**🔥 索引选择失误案例分析**
```sql
-- 案例1：复合索引列顺序错误
-- 错误索引：INDEX idx_bad (status, user_id)  
-- 查询模式：WHERE user_id = ? AND status = ?
-- 问题：user_id选择性高但不是前缀列

-- 正确索引：INDEX idx_good (user_id, status)
CREATE INDEX idx_user_status ON orders (user_id, status);
DROP INDEX idx_bad ON orders;

-- 案例2：过度索引导致维护成本高
-- 问题：为每个查询都创建专门索引
-- 解决：设计覆盖多个查询的复合索引

-- 案例3：统计信息过期导致错误选择  
-- 现象：优化器选择全表扫描而不是索引
-- 解决：定期更新统计信息
ANALYZE TABLE orders;
```

### 9.4 监控告警体系


**🔔 索引选择监控告警**
```sql
-- 创建监控视图
CREATE VIEW index_performance_monitor AS
SELECT 
    CONCAT(object_schema, '.', object_name) as table_name,
    index_name,
    count_star as usage_count,
    sum_timer_wait/1000000000 as total_time_sec,
    avg_timer_wait/1000000000 as avg_time_sec,
    CASE 
        WHEN count_star = 0 THEN 'UNUSED'
        WHEN avg_timer_wait/1000000000 > 1.0 THEN 'SLOW'  
        WHEN count_star < 100 THEN 'LOW_USAGE'
        ELSE 'NORMAL'
    END as status
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema NOT IN ('mysql', 'information_schema', 'performance_schema')
AND index_name IS NOT NULL;

-- 告警查询
SELECT * FROM index_performance_monitor 
WHERE status IN ('UNUSED', 'SLOW') 
ORDER BY status, avg_time_sec DESC;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 索引选择机制：优化器基于成本模型选择最优索引
🔸 多索引竞争：同一查询多个索引可用时的选择策略  
🔸 成本计算模型：I/O成本+CPU成本+网络成本的综合评估
🔸 强制索引HINT：在优化器选择不当时的人工干预方法
🔸 索引合并策略：多个单列索引结果的合并使用
🔸 全表扫描判断：在某些条件下全表扫描反而更优
🔸 统计信息作用：准确统计信息是正确选择的基础
🔸 计划稳定性：避免查询计划频繁变化影响性能
```

### 10.2 关键决策要素


**🔹 索引选择影响因素**
```
数据特征因素：
• 表大小和行数分布
• 索引选择性和基数  
• 数据倾斜程度
• 缓冲池命中率

查询特征因素：
• WHERE条件复杂度
• 返回数据比例
• ORDER BY和GROUP BY需求
• JOIN操作类型

系统环境因素：
• 并发查询负载
• 内存可用情况
• I/O系统性能
• 网络带宽限制
```

**🔹 优化决策流程**
```
1. 分析查询模式识别索引需求
2. 评估现有索引的选择性和使用率
3. 计算不同方案的预估成本
4. 考虑系统整体负载影响
5. 选择最优索引策略
6. 监控执行效果并调优
```

### 10.3 实际应用指导


**🎯 索引选择最佳实践**
```
设计阶段：
✅ 根据查询模式设计复合索引
✅ 避免创建过多重复索引
✅ 考虑索引维护成本

运行阶段：
✅ 定期更新表统计信息  
✅ 监控索引使用情况
✅ 及时处理性能异常

优化阶段：
✅ 分析慢查询日志
✅ 使用EXPLAIN分析执行计划
✅ 必要时使用HINT强制索引
```

**🔹 常见问题解决方案**
- **索引选择错误**：检查统计信息，考虑使用HINT
- **计划不稳定**：定期ANALYZE，监控计划变化
- **全表扫描过多**：分析查询条件，创建合适索引
- **索引冲突**：重新设计索引结构，删除冗余索引

### 10.4 监控和维护策略


**📊 关键监控指标**
```
性能监控：
• 平均查询响应时间
• 索引使用率统计
• 全表扫描频率
• 查询计划变化次数

资源监控：
• 缓冲池命中率
• I/O读写延迟
• CPU使用率
• 内存使用情况
```

**🔧 维护操作建议**
```
日常维护：
✅ 监控慢查询日志
✅ 检查索引使用统计
✅ 关注系统性能指标

定期维护：
✅ 更新表统计信息（周/月）
✅ 分析索引使用效果
✅ 清理无用索引

应急处理：
✅ 准备性能回退方案
✅ 建立快速诊断流程  
✅ 制定索引紧急调整策略
```

**核心记忆要点**：
- 索引选择基于成本模型，统计信息准确性至关重要
- 复合索引通常优于索引合并，设计时要考虑查询模式
- 适当使用HINT处理优化器选择不当，但要定期评估有效性
- 建立完善的监控体系，及时发现和解决索引选择问题