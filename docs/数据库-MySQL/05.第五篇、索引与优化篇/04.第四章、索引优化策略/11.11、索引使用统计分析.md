---
title: 11、索引使用统计分析
---
## 📚 目录

1. [索引统计分析概述](#1-索引统计分析概述)
2. [Performance Schema监控体系](#2-Performance-Schema监控体系)
3. [索引使用频率统计](#3-索引使用频率统计)
4. [未使用索引识别技术](#4-未使用索引识别技术)
5. [索引效率评估方法](#5-索引效率评估方法)
6. [索引价值分析模型](#6-索引价值分析模型)
7. [索引使用模式分析](#7-索引使用模式分析)
8. [索引优化建议生成](#8-索引优化建议生成)
9. [索引统计自动化平台](#9-索引统计自动化平台)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📊 索引统计分析概述


### 1.1 什么是索引使用统计分析


**🔸 基本定义**
索引使用统计分析就像给数据库的"每条道路"安装流量监控器，记录哪些索引被使用了多少次，哪些索引从来没被用过，哪些索引效率高，哪些索引浪费资源。

```
索引统计的核心价值：
数据库查询 → 索引使用记录 → 统计分析 → 优化决策

监控体系架构：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   实际查询      │───▶│   使用统计      │───▶│   优化建议      │
│ (SQL语句)      │    │  (访问次数)     │    │  (增删改索引)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

**🎯 统计分析的目标**
- **发现问题**：找出未使用的冗余索引
- **评估价值**：计算每个索引的实际贡献
- **预测趋势**：分析索引使用的变化趋势
- **指导优化**：提供具体的索引优化建议

### 1.2 为什么需要索引统计分析


**💡 索引管理的现实问题**

```
常见索引问题场景：

🔸 索引冗余问题：
开发过程中：添加了大量索引"以防万一"
实际运行时：很多索引从未被使用
结果：浪费存储空间，拖慢写入性能

🔸 索引效果不明：
问题：不知道哪个索引真正有用
现象：查询性能时好时坏
原因：缺乏量化的效果评估

🔸 优化盲目性：
现状：凭感觉或经验调整索引
风险：可能删除了重要索引，影响性能
需求：基于数据的科学决策
```

### 1.3 索引统计的数据来源


**📋 MySQL索引统计信息来源**

```
MySQL索引统计信息架构：
┌─────────────────────────────────────────┐
│              MySQL引擎                  │
├─────────────────────────────────────────┤
│  查询执行器 → 索引访问 → 统计记录        │
├─────────────────────────────────────────┤
│              统计数据存储                │
│  ┌─────────────┐ ┌─────────────┐      │
│  │Performance  │ │INFORMATION  │      │
│  │   Schema    │ │   SCHEMA    │      │
│  └─────────────┘ └─────────────┘      │
└─────────────────────────────────────────┘

主要数据来源：
• Performance Schema：运行时性能统计
• INFORMATION_SCHEMA：元数据和结构信息
• 查询日志：慢查询和通用查询日志
• 状态变量：全局索引使用统计
```

---

## 2. 🔍 Performance Schema监控体系


### 2.1 Performance Schema基础


**🔸 什么是Performance Schema**
Performance Schema是MySQL的内置性能监控系统，就像数据库的"黑匣子"，记录所有查询操作的详细信息。

```sql
-- 检查Performance Schema是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 查看Performance Schema占用的内存
SELECT 
    ENGINE, 
    COUNT(*) as table_count,
    SUM(DATA_LENGTH + INDEX_LENGTH) as total_size
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'performance_schema'
GROUP BY ENGINE;
```

### 2.2 核心监控表详解


**📋 关键Performance Schema表**

```sql
-- 1. events_statements_summary_by_digest
-- 记录SQL语句的执行统计信息
SELECT 
    DIGEST_TEXT,                    -- SQL语句模板
    COUNT_STAR,                     -- 执行次数
    AVG_TIMER_WAIT/1000000000 as avg_time_sec,  -- 平均执行时间(秒)
    SUM_ROWS_EXAMINED,              -- 总扫描行数
    SUM_ROWS_SENT                   -- 总返回行数
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT IS NOT NULL
ORDER BY COUNT_STAR DESC
LIMIT 10;

-- 2. table_io_waits_summary_by_index_usage  
-- 记录索引的IO访问统计
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_READ,                     -- 读取次数
    COUNT_WRITE,                    -- 写入次数
    COUNT_FETCH,                    -- 获取次数
    COUNT_INSERT,                   -- 插入次数
    COUNT_UPDATE,                   -- 更新次数
    COUNT_DELETE                    -- 删除次数
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database_name'
ORDER BY COUNT_READ + COUNT_WRITE DESC;
```

**🔧 监控配置启用**

```sql
-- 启用必要的Performance Schema监控
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%statement%';

UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME = 'table_io';

-- 重置统计数据（清零计数器）
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
TRUNCATE TABLE performance_schema.table_io_waits_summary_by_index_usage;
```

### 2.3 索引访问统计视图


**📊 创建便于分析的统计视图**

```sql
-- 创建索引使用统计汇总视图
CREATE VIEW index_usage_stats AS
SELECT 
    t.OBJECT_SCHEMA as database_name,
    t.OBJECT_NAME as table_name,
    t.INDEX_NAME,
    s.INDEX_TYPE,
    s.CARDINALITY,
    t.COUNT_READ,
    t.COUNT_WRITE,
    (t.COUNT_READ + t.COUNT_WRITE) as total_access,
    ROUND(s.STAT_VALUE / s.CARDINALITY * 100, 2) as selectivity_percent
FROM performance_schema.table_io_waits_summary_by_index_usage t
JOIN information_schema.STATISTICS s 
    ON t.OBJECT_SCHEMA = s.TABLE_SCHEMA 
    AND t.OBJECT_NAME = s.TABLE_NAME 
    AND t.INDEX_NAME = s.INDEX_NAME
WHERE t.OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema');

-- 使用统计视图
SELECT * FROM index_usage_stats 
WHERE database_name = 'your_db'
ORDER BY total_access DESC;
```

---

## 3. 📈 索引使用频率统计


### 3.1 基础使用频率查询


**🔸 获取索引访问频率**
索引使用频率就像道路的车流量统计，告诉我们哪些索引是"交通要道"，哪些是"废弃小路"。

```sql
-- 查询索引使用频率排行榜
SELECT 
    CONCAT(OBJECT_SCHEMA, '.', OBJECT_NAME) as table_full_name,
    INDEX_NAME,
    COUNT_READ as read_count,
    COUNT_WRITE as write_count,
    (COUNT_READ + COUNT_WRITE) as total_usage,
    ROUND((COUNT_READ + COUNT_WRITE) / 
          (SELECT SUM(COUNT_READ + COUNT_WRITE) 
           FROM performance_schema.table_io_waits_summary_by_index_usage) * 100, 2
    ) as usage_percentage
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
  AND (COUNT_READ + COUNT_WRITE) > 0
ORDER BY total_usage DESC
LIMIT 20;
```

### 3.2 索引使用热度分析


**🌡️ 索引热度评估算法**

```sql
-- 计算索引热度得分
WITH index_heat AS (
    SELECT 
        OBJECT_SCHEMA,
        OBJECT_NAME,
        INDEX_NAME,
        COUNT_READ,
        COUNT_WRITE,
        -- 读写权重不同：读操作权重1，写操作权重2（写更昂贵）
        (COUNT_READ * 1 + COUNT_WRITE * 2) as weighted_usage,
        -- 获取表的总大小
        (SELECT (DATA_LENGTH + INDEX_LENGTH) 
         FROM information_schema.TABLES t2 
         WHERE t2.TABLE_SCHEMA = tio.OBJECT_SCHEMA 
           AND t2.TABLE_NAME = tio.OBJECT_NAME) as table_size
    FROM performance_schema.table_io_waits_summary_by_index_usage tio
    WHERE OBJECT_SCHEMA = 'your_database'
)
SELECT 
    CONCAT(OBJECT_SCHEMA, '.', OBJECT_NAME, '.', INDEX_NAME) as index_full_name,
    weighted_usage,
    table_size,
    -- 热度算法：使用频次 / log(表大小) 
    ROUND(weighted_usage / LOG10(GREATEST(table_size/1024, 1)), 2) as heat_score,
    CASE 
        WHEN weighted_usage = 0 THEN '❄️ 冷索引'
        WHEN weighted_usage < 100 THEN '🧊 凉索引' 
        WHEN weighted_usage < 1000 THEN '🔥 温索引'
        WHEN weighted_usage < 10000 THEN '🌋 热索引'
        ELSE '☀️ 超热索引'
    END as heat_level
FROM index_heat
ORDER BY heat_score DESC;
```

### 3.3 时间维度的使用统计


**⏰ 索引使用趋势分析**

```sql
-- 创建索引使用历史记录表
CREATE TABLE index_usage_history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    database_name VARCHAR(64),
    table_name VARCHAR(64),
    index_name VARCHAR(64),
    read_count BIGINT,
    write_count BIGINT,
    total_usage BIGINT,
    record_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_time (record_time),
    INDEX idx_table_index (table_name, index_name)
);

-- 定期收集索引使用统计（建议每小时运行）
INSERT INTO index_usage_history 
    (database_name, table_name, index_name, read_count, write_count, total_usage)
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_READ,
    COUNT_WRITE,
    (COUNT_READ + COUNT_WRITE)
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
  AND (COUNT_READ + COUNT_WRITE) > 0;
```

**📊 趋势分析查询**

```sql
-- 分析索引使用趋势（最近7天）
SELECT 
    CONCAT(table_name, '.', index_name) as index_name,
    DATE(record_time) as date,
    MAX(total_usage) - MIN(total_usage) as daily_usage,
    AVG(total_usage) as avg_usage
FROM index_usage_history
WHERE record_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY table_name, index_name, DATE(record_time)
ORDER BY index_name, date;

-- 计算索引使用增长率
WITH daily_stats AS (
    SELECT 
        CONCAT(table_name, '.', index_name) as index_name,
        DATE(record_time) as date,
        MAX(total_usage) as max_usage
    FROM index_usage_history
    WHERE record_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
    GROUP BY table_name, index_name, DATE(record_time)
)
SELECT 
    index_name,
    LAG(max_usage) OVER (PARTITION BY index_name ORDER BY date) as prev_usage,
    max_usage as current_usage,
    ROUND((max_usage - LAG(max_usage) OVER (PARTITION BY index_name ORDER BY date)) 
          / LAG(max_usage) OVER (PARTITION BY index_name ORDER BY date) * 100, 2
    ) as growth_rate_percent
FROM daily_stats
WHERE LAG(max_usage) OVER (PARTITION BY index_name ORDER BY date) IS NOT NULL
ORDER BY growth_rate_percent DESC;
```

---

## 4. ❌ 未使用索引识别技术


### 4.1 识别完全未使用的索引


**🔍 零使用索引检测**

```sql
-- 查找从未被使用的索引
SELECT 
    s.TABLE_SCHEMA,
    s.TABLE_NAME,
    s.INDEX_NAME,
    s.INDEX_TYPE,
    s.CARDINALITY,
    ROUND((s.STAT_VALUE * s.AVG_ROW_LENGTH) / 1024, 2) as index_size_kb
FROM information_schema.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
    ON s.TABLE_SCHEMA = u.OBJECT_SCHEMA 
    AND s.TABLE_NAME = u.OBJECT_NAME 
    AND s.INDEX_NAME = u.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
  AND s.INDEX_NAME != 'PRIMARY'  -- 排除主键
  AND (u.COUNT_READ IS NULL OR u.COUNT_READ = 0)
  AND (u.COUNT_WRITE IS NULL OR u.COUNT_WRITE = 0)
GROUP BY s.TABLE_SCHEMA, s.TABLE_NAME, s.INDEX_NAME
ORDER BY index_size_kb DESC;
```

### 4.2 低效索引识别


**⚖️ 索引效率评估**

```sql
-- 识别低效率索引（使用频次低但占用资源多）
WITH index_efficiency AS (
    SELECT 
        CONCAT(u.OBJECT_SCHEMA, '.', u.OBJECT_NAME, '.', u.INDEX_NAME) as full_index_name,
        u.COUNT_READ + u.COUNT_WRITE as total_usage,
        s.CARDINALITY,
        -- 估算索引大小（简化计算）
        COUNT(s.COLUMN_NAME) * 8 as estimated_size_bytes,
        -- 效率得分：使用次数 / 索引大小
        ROUND((u.COUNT_READ + u.COUNT_WRITE) / GREATEST(COUNT(s.COLUMN_NAME) * 8, 1), 4) as efficiency_score
    FROM performance_schema.table_io_waits_summary_by_index_usage u
    JOIN information_schema.STATISTICS s 
        ON u.OBJECT_SCHEMA = s.TABLE_SCHEMA 
        AND u.OBJECT_NAME = s.TABLE_NAME 
        AND u.INDEX_NAME = s.INDEX_NAME
    WHERE u.OBJECT_SCHEMA = 'your_database'
      AND u.INDEX_NAME != 'PRIMARY'
    GROUP BY u.OBJECT_SCHEMA, u.OBJECT_NAME, u.INDEX_NAME
)
SELECT 
    full_index_name,
    total_usage,
    estimated_size_bytes,
    efficiency_score,
    CASE 
        WHEN efficiency_score = 0 THEN '🚫 未使用'
        WHEN efficiency_score < 0.1 THEN '⚠️ 低效'
        WHEN efficiency_score < 1 THEN '📊 一般'
        WHEN efficiency_score < 10 THEN '✅ 良好'
        ELSE '⭐ 优秀'
    END as efficiency_level
FROM index_efficiency
ORDER BY efficiency_score ASC;
```

### 4.3 重复索引检测


**🔄 冗余索引识别**

```sql
-- 检测重复和冗余的索引
WITH index_columns AS (
    SELECT 
        TABLE_SCHEMA,
        TABLE_NAME,
        INDEX_NAME,
        GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as column_list,
        COUNT(*) as column_count
    FROM information_schema.STATISTICS
    WHERE TABLE_SCHEMA = 'your_database'
    GROUP BY TABLE_SCHEMA, TABLE_NAME, INDEX_NAME
)
SELECT 
    ic1.TABLE_NAME,
    ic1.INDEX_NAME as index1,
    ic2.INDEX_NAME as index2,
    ic1.column_list,
    '可能冗余' as suggestion
FROM index_columns ic1
JOIN index_columns ic2 
    ON ic1.TABLE_SCHEMA = ic2.TABLE_SCHEMA
    AND ic1.TABLE_NAME = ic2.TABLE_NAME
    AND ic1.INDEX_NAME < ic2.INDEX_NAME  -- 避免重复比较
    AND ic1.column_list = ic2.column_list  -- 列完全相同
ORDER BY ic1.TABLE_NAME, ic1.INDEX_NAME;
```

---

## 5. 📏 索引效率评估方法


### 5.1 索引选择性分析


**🔸 什么是索引选择性**
索引选择性衡量索引能多大程度上缩小搜索范围。选择性高的索引能快速定位少量记录，选择性低的索引需要扫描大量数据。

```
选择性计算公式：
选择性 = 不重复值的数量 / 表的总行数

选择性示例：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│    字段     │  不重复值   │   总行数    │   选择性    │
├─────────────┼─────────────┼─────────────┼─────────────┤
│   user_id   │   100万     │   100万     │    1.0      │ ← 最佳
│   email     │   98万      │   100万     │    0.98     │ ← 很好
│   age       │    80       │   100万     │   0.00008   │ ← 较差
│   gender    │     2       │   100万     │   0.000002  │ ← 很差
└─────────────┴─────────────┴─────────────┴─────────────┘
```

**📊 计算索引选择性**

```sql
-- 计算表中各列的选择性
SELECT 
    TABLE_NAME,
    COLUMN_NAME,
    COUNT(DISTINCT column_value) as distinct_values,
    COUNT(*) as total_rows,
    ROUND(COUNT(DISTINCT column_value) / COUNT(*), 4) as selectivity,
    CASE 
        WHEN COUNT(DISTINCT column_value) / COUNT(*) > 0.8 THEN '⭐ 优秀'
        WHEN COUNT(DISTINCT column_value) / COUNT(*) > 0.5 THEN '✅ 良好'
        WHEN COUNT(DISTINCT column_value) / COUNT(*) > 0.1 THEN '📊 一般'
        ELSE '⚠️ 较差'
    END as selectivity_level
FROM (
    -- 这里需要动态生成查询，实际使用时替换为具体表名和列名
    SELECT 'users' as TABLE_NAME, 'email' as COLUMN_NAME, email as column_value FROM users
    UNION ALL
    SELECT 'users', 'age', age FROM users
    UNION ALL  
    SELECT 'users', 'gender', gender FROM users
) t
GROUP BY TABLE_NAME, COLUMN_NAME
ORDER BY selectivity DESC;
```

### 5.2 索引覆盖度分析


**📋 查询覆盖情况评估**

```sql
-- 分析索引对查询的覆盖程度
WITH query_index_usage AS (
    SELECT 
        DIGEST_TEXT,
        COUNT_STAR as execution_count,
        AVG_TIMER_WAIT/1000000000 as avg_execution_time,
        AVG_ROWS_EXAMINED as avg_rows_scanned,
        AVG_ROWS_SENT as avg_rows_returned,
        -- 计算扫描效率：返回行数 / 扫描行数
        ROUND(AVG_ROWS_SENT / GREATEST(AVG_ROWS_EXAMINED, 1), 4) as scan_efficiency
    FROM performance_schema.events_statements_summary_by_digest
    WHERE DIGEST_TEXT IS NOT NULL
      AND SCHEMA_NAME = 'your_database'
)
SELECT 
    SUBSTRING(DIGEST_TEXT, 1, 100) as query_template,
    execution_count,
    ROUND(avg_execution_time, 3) as avg_time_sec,
    ROUND(avg_rows_scanned, 0) as avg_scan_rows,
    ROUND(scan_efficiency, 4) as efficiency,
    CASE 
        WHEN scan_efficiency > 0.8 THEN '⭐ 优秀覆盖'
        WHEN scan_efficiency > 0.5 THEN '✅ 良好覆盖'
        WHEN scan_efficiency > 0.1 THEN '📊 一般覆盖'
        ELSE '⚠️ 低效扫描'
    END as coverage_level
FROM query_index_usage
WHERE avg_rows_scanned > 10  -- 过滤掉小表查询
ORDER BY scan_efficiency ASC, execution_count DESC
LIMIT 20;
```

### 5.3 索引维护成本分析


**💰 索引ROI计算方法**

```sql
-- 计算索引的投资回报率(ROI)
WITH index_costs AS (
    SELECT 
        CONCAT(OBJECT_SCHEMA, '.', OBJECT_NAME) as table_name,
        INDEX_NAME,
        COUNT_READ + COUNT_WRITE as total_usage,
        -- 估算索引维护成本（写操作次数 * 维护开销系数）
        COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE as maintenance_cost,
        -- 估算索引存储成本（索引大小）
        (SELECT ROUND(INDEX_LENGTH/1024, 2)
         FROM information_schema.TABLES t
         WHERE t.TABLE_SCHEMA = tio.OBJECT_SCHEMA 
           AND t.TABLE_NAME = tio.OBJECT_NAME) as storage_cost_kb
    FROM performance_schema.table_io_waits_summary_by_index_usage tio
    WHERE OBJECT_SCHEMA = 'your_database'
      AND INDEX_NAME != 'PRIMARY'
)
SELECT 
    table_name,
    INDEX_NAME,
    total_usage as benefit,
    maintenance_cost + storage_cost_kb/10 as total_cost,
    ROUND(total_usage / GREATEST(maintenance_cost + storage_cost_kb/10, 1), 2) as roi_score,
    CASE 
        WHEN total_usage / GREATEST(maintenance_cost + storage_cost_kb/10, 1) > 10 THEN '💰 高价值'
        WHEN total_usage / GREATEST(maintenance_cost + storage_cost_kb/10, 1) > 5 THEN '💵 中价值'
        WHEN total_usage / GREATEST(maintenance_cost + storage_cost_kb/10, 1) > 1 THEN '💴 低价值'
        ELSE '🚫 负价值'
    END as value_level
FROM index_costs
ORDER BY roi_score DESC;
```

---

## 6. 🎯 索引价值分析模型


### 6.1 综合价值评估模型


**🔸 索引价值的多维度分析**
索引的价值不仅看使用频次，还要综合考虑性能提升、维护成本、存储开销等多个因素。

```
索引价值评估模型：
┌─────────────────────────────────────────┐
│               索引价值                  │
├─────────────────────────────────────────┤
│  使用频次  ×  性能提升  -  维护成本      │
│     ↓           ↓          ↓           │
│  访问次数   查询加速度   存储+写入开销    │
└─────────────────────────────────────────┘

价值计算要素：
• 正向价值：查询加速、减少IO、提升并发
• 负向成本：存储空间、写入延迟、维护开销
• 综合评估：价值-成本=净收益
```

### 6.2 索引优先级排序算法


**🏆 优化优先级计算**

```sql
-- 索引优化优先级综合评估
WITH index_priority AS (
    SELECT 
        u.OBJECT_SCHEMA,
        u.OBJECT_NAME,
        u.INDEX_NAME,
        -- 基础指标
        u.COUNT_READ + u.COUNT_WRITE as usage_count,
        s.CARDINALITY,
        -- 计算优先级得分
        CASE 
            WHEN u.COUNT_READ + u.COUNT_WRITE = 0 THEN 100  -- 未使用索引最高优先级删除
            WHEN u.COUNT_READ + u.COUNT_WRITE < 10 THEN 80   -- 低使用频次
            WHEN s.CARDINALITY / (SELECT TABLE_ROWS FROM information_schema.TABLES t 
                                 WHERE t.TABLE_SCHEMA = u.OBJECT_SCHEMA 
                                   AND t.TABLE_NAME = u.OBJECT_NAME) < 0.1 THEN 60  -- 低选择性
            ELSE 20  -- 正常索引
        END as optimization_priority
    FROM performance_schema.table_io_waits_summary_by_index_usage u
    JOIN information_schema.STATISTICS s
        ON u.OBJECT_SCHEMA = s.TABLE_SCHEMA 
        AND u.OBJECT_NAME = s.TABLE_NAME 
        AND u.INDEX_NAME = s.INDEX_NAME
    WHERE u.OBJECT_SCHEMA = 'your_database'
      AND u.INDEX_NAME != 'PRIMARY'
    GROUP BY u.OBJECT_SCHEMA, u.OBJECT_NAME, u.INDEX_NAME
)
SELECT 
    CONCAT(OBJECT_SCHEMA, '.', OBJECT_NAME, '.', INDEX_NAME) as index_full_name,
    usage_count,
    optimization_priority,
    CASE 
        WHEN optimization_priority >= 80 THEN '🔴 立即处理'
        WHEN optimization_priority >= 60 THEN '🟡 计划处理'
        WHEN optimization_priority >= 40 THEN '🟢 监控观察'
        ELSE '⚪ 正常维护'
    END as priority_level,
    CASE 
        WHEN optimization_priority >= 80 AND usage_count = 0 THEN 'DROP INDEX'
        WHEN optimization_priority >= 60 THEN '分析查询模式，考虑重构'
        ELSE '继续监控使用情况'
    END as suggested_action
FROM index_priority
ORDER BY optimization_priority DESC, usage_count ASC;
```

### 6.3 索引价值预测模型


**📈 使用趋势预测**

```sql
-- 基于历史数据预测索引未来价值
WITH index_trends AS (
    SELECT 
        table_name,
        index_name,
        -- 计算最近30天的使用趋势
        AVG(CASE WHEN record_time >= DATE_SUB(NOW(), INTERVAL 7 DAY) 
                 THEN total_usage END) as recent_avg,
        AVG(CASE WHEN record_time < DATE_SUB(NOW(), INTERVAL 7 DAY) 
                   AND record_time >= DATE_SUB(NOW(), INTERVAL 14 DAY)
                 THEN total_usage END) as previous_avg
    FROM index_usage_history
    WHERE record_time >= DATE_SUB(NOW(), INTERVAL 14 DAY)
    GROUP BY table_name, index_name
    HAVING recent_avg IS NOT NULL AND previous_avg IS NOT NULL
)
SELECT 
    CONCAT(table_name, '.', index_name) as index_name,
    ROUND(previous_avg, 0) as prev_week_avg,
    ROUND(recent_avg, 0) as recent_week_avg,
    ROUND((recent_avg - previous_avg) / previous_avg * 100, 2) as trend_percent,
    CASE 
        WHEN (recent_avg - previous_avg) / previous_avg > 0.5 THEN '📈 上升趋势'
        WHEN (recent_avg - previous_avg) / previous_avg > 0.1 THEN '📊 稳定增长'
        WHEN (recent_avg - previous_avg) / previous_avg > -0.1 THEN '➡️ 稳定'
        WHEN (recent_avg - previous_avg) / previous_avg > -0.5 THEN '📉 下降趋势'
        ELSE '⬇️ 快速下降'
    END as trend_direction,
    CASE 
        WHEN (recent_avg - previous_avg) / previous_avg < -0.5 THEN '考虑删除索引'
        WHEN (recent_avg - previous_avg) / previous_avg > 0.5 THEN '考虑优化索引'
        ELSE '继续观察'
    END as recommendation
FROM index_trends
ORDER BY trend_percent ASC;
```

---

## 7. 🔍 索引使用模式分析


### 7.1 查询模式与索引匹配度


**🎯 索引使用模式识别**

```sql
-- 分析查询中的WHERE条件模式
SELECT 
    SUBSTRING(DIGEST_TEXT, 1, 200) as query_pattern,
    COUNT_STAR as frequency,
    ROUND(AVG_TIMER_WAIT/1000000000, 3) as avg_time,
    ROUND(AVG_ROWS_EXAMINED/AVG_ROWS_SENT, 2) as scan_ratio,
    CASE 
        WHEN AVG_ROWS_EXAMINED/AVG_ROWS_SENT < 2 THEN '🎯 精确查询'
        WHEN AVG_ROWS_EXAMINED/AVG_ROWS_SENT < 10 THEN '📊 良好查询'
        WHEN AVG_ROWS_EXAMINED/AVG_ROWS_SENT < 100 THEN '⚠️ 扫描较多'
        ELSE '🚨 全表扫描'
    END as query_efficiency
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'your_database'
  AND DIGEST_TEXT LIKE '%WHERE%'
  AND COUNT_STAR > 10
ORDER BY frequency DESC, avg_time DESC
LIMIT 20;
```

### 7.2 时间模式分析


**⏰ 索引使用的时间规律**

```sql
-- 分析索引使用的时间规律（需要历史数据）
SELECT 
    HOUR(record_time) as hour_of_day,
    AVG(total_usage) as avg_usage,
    MIN(total_usage) as min_usage,
    MAX(total_usage) as max_usage,
    STDDEV(total_usage) as usage_variance
FROM index_usage_history
WHERE record_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
  AND table_name = 'important_table'
  AND index_name = 'idx_important'
GROUP BY HOUR(record_time)
ORDER BY hour_of_day;

-- 识别使用高峰时段
SELECT 
    CASE 
        WHEN HOUR(record_time) BETWEEN 9 AND 11 THEN '上午高峰'
        WHEN HOUR(record_time) BETWEEN 14 AND 16 THEN '下午高峰'  
        WHEN HOUR(record_time) BETWEEN 20 AND 22 THEN '晚上高峰'
        ELSE '非高峰期'
    END as time_period,
    COUNT(*) as record_count,
    AVG(total_usage) as avg_usage
FROM index_usage_history  
WHERE record_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY time_period
ORDER BY avg_usage DESC;
```

---

## 8. 💡 索引优化建议生成


### 8.1 自动化建议生成


**🤖 基于统计的优化建议**

```sql
-- 综合分析生成优化建议
WITH optimization_analysis AS (
    SELECT 
        u.OBJECT_NAME as table_name,
        u.INDEX_NAME,
        u.COUNT_READ + u.COUNT_WRITE as usage_count,
        s.CARDINALITY,
        (SELECT TABLE_ROWS FROM information_schema.TABLES t 
         WHERE t.TABLE_SCHEMA = u.OBJECT_SCHEMA AND t.TABLE_NAME = u.OBJECT_NAME) as table_rows,
        -- 计算选择性
        s.CARDINALITY / (SELECT TABLE_ROWS FROM information_schema.TABLES t 
                        WHERE t.TABLE_SCHEMA = u.OBJECT_SCHEMA AND t.TABLE_NAME = u.OBJECT_NAME) as selectivity
    FROM performance_schema.table_io_waits_summary_by_index_usage u
    JOIN information_schema.STATISTICS s 
        ON u.OBJECT_SCHEMA = s.TABLE_SCHEMA 
        AND u.OBJECT_NAME = s.TABLE_NAME 
        AND u.INDEX_NAME = s.INDEX_NAME
    WHERE u.OBJECT_SCHEMA = 'your_database'
      AND u.INDEX_NAME != 'PRIMARY'
    GROUP BY u.OBJECT_SCHEMA, u.OBJECT_NAME, u.INDEX_NAME
)
SELECT 
    table_name,
    INDEX_NAME,
    usage_count,
    ROUND(selectivity, 4) as selectivity,
    CASE 
        WHEN usage_count = 0 THEN 
            CONCAT('🗑️ 建议删除：DROP INDEX ', INDEX_NAME, ' ON ', table_name)
        WHEN usage_count < 10 AND selectivity < 0.1 THEN 
            CONCAT('⚠️ 考虑删除：索引使用率低且选择性差')
        WHEN usage_count > 1000 AND selectivity > 0.8 THEN 
            CONCAT('⭐ 保持现状：高效索引，使用频繁')
        WHEN selectivity < 0.01 THEN
            CONCAT('🔧 考虑重构：选择性过低，可能需要复合索引')
        ELSE '📊 继续监控使用情况'
    END as optimization_suggestion
FROM optimization_analysis
ORDER BY 
    CASE 
        WHEN usage_count = 0 THEN 1
        WHEN usage_count < 10 AND selectivity < 0.1 THEN 2
        ELSE 3
    END,
    usage_count ASC;
```

### 8.2 索引优化报告生成


**📋 自动化报告模板**

```sql
-- 生成索引优化分析报告
SELECT 
    '=== 索引使用分析报告 ===' as report_section
UNION ALL
SELECT CONCAT('生成时间: ', NOW())
UNION ALL  
SELECT CONCAT('分析数据库: ', 'your_database_name')
UNION ALL
SELECT '---'
UNION ALL
SELECT '📊 总体统计:'
UNION ALL
SELECT CONCAT('总索引数: ', 
    (SELECT COUNT(DISTINCT INDEX_NAME) 
     FROM information_schema.STATISTICS 
     WHERE TABLE_SCHEMA = 'your_database'))
UNION ALL
SELECT CONCAT('未使用索引数: ',
    (SELECT COUNT(*) FROM (
        SELECT s.INDEX_NAME
        FROM information_schema.STATISTICS s
        LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
            ON s.TABLE_SCHEMA = u.OBJECT_SCHEMA 
            AND s.TABLE_NAME = u.OBJECT_NAME 
            AND s.INDEX_NAME = u.INDEX_NAME
        WHERE s.TABLE_SCHEMA = 'your_database'
          AND s.INDEX_NAME != 'PRIMARY'
          AND (u.COUNT_READ IS NULL OR u.COUNT_READ = 0)
        GROUP BY s.TABLE_SCHEMA, s.TABLE_NAME, s.INDEX_NAME
    ) unused))
UNION ALL
SELECT '---'
UNION ALL  
SELECT '🔴 需要立即处理的索引:';

-- 添加具体的问题索引列表（简化查询）
```

---

## 9. 🤖 索引统计自动化平台


### 9.1 自动化监控脚本


**⚙️ 定时统计收集**

```bash
#!/bin/bash
# 索引统计自动收集脚本

DB_HOST="localhost"
DB_USER="monitor_user" 
DB_PASS="monitor_pass"
DB_NAME="your_database"

# 收集当前索引使用统计
mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME << EOF
INSERT INTO index_usage_history 
    (database_name, table_name, index_name, read_count, write_count, total_usage)
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_READ,
    COUNT_WRITE,
    (COUNT_READ + COUNT_WRITE)
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = '$DB_NAME'
  AND (COUNT_READ + COUNT_WRITE) > 0;
EOF

echo "索引统计收集完成: $(date)"
```

### 9.2 告警和通知机制


**🚨 异常索引告警**

```sql
-- 创建索引异常告警视图
CREATE VIEW index_alerts AS
SELECT 
    'UNUSED_INDEX' as alert_type,
    CONCAT(TABLE_SCHEMA, '.', TABLE_NAME, '.', INDEX_NAME) as object_name,
    '索引从未被使用，考虑删除' as alert_message,
    'HIGH' as severity
FROM information_schema.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
    ON s.TABLE_SCHEMA = u.OBJECT_SCHEMA 
    AND s.TABLE_NAME = u.OBJECT_NAME 
    AND s.INDEX_NAME = u.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
  AND s.INDEX_NAME != 'PRIMARY'
  AND (u.COUNT_READ IS NULL OR u.COUNT_READ = 0)
  
UNION ALL

SELECT 
    'LOW_SELECTIVITY' as alert_type,
    CONCAT(TABLE_SCHEMA, '.', TABLE_NAME, '.', INDEX_NAME) as object_name,
    CONCAT('索引选择性过低: ', ROUND(CARDINALITY/TABLE_ROWS*100, 1), '%') as alert_message,
    'MEDIUM' as severity
FROM information_schema.STATISTICS s
JOIN information_schema.TABLES t 
    ON s.TABLE_SCHEMA = t.TABLE_SCHEMA AND s.TABLE_NAME = t.TABLE_NAME
WHERE s.TABLE_SCHEMA = 'your_database' 
  AND s.INDEX_NAME != 'PRIMARY'
  AND s.CARDINALITY / GREATEST(t.TABLE_ROWS, 1) < 0.1;

-- 查看当前告警
SELECT * FROM index_alerts ORDER BY severity, alert_type;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 索引使用统计：通过Performance Schema监控索引的实际使用情况
🔸 使用频率分析：统计每个索引被访问的次数，识别热点和冷门索引  
🔸 效率评估：计算索引的选择性、覆盖度、ROI等效率指标
🔸 价值分析：综合考虑使用频次、性能提升、维护成本的索引价值模型
🔸 优化建议：基于统计数据自动生成具体的索引优化建议
🔸 趋势预测：分析索引使用的时间规律和变化趋势
```

### 10.2 关键理解要点


**🔹 索引统计的实际意义**
```
核心价值：
• 数据驱动决策：用实际数据而非猜测来优化索引
• 资源优化：识别并删除无用索引，节省存储和维护成本
• 性能提升：发现低效查询，指导索引创建和调整
• 预防问题：提前发现潜在的性能瓶颈

实施原则：
• 持续监控：索引使用情况会随业务发展变化
• 综合分析：不能只看单一指标，要综合评估
• 谨慎删除：删除索引前要充分测试影响
```

**🔹 Performance Schema的核心价值**
```
为什么重要：
• 提供客观的性能数据，不依赖主观判断
• 实时监控，能够发现瞬时的性能问题
• 细粒度统计，能够精确定位问题索引
• 历史趋势，帮助预测未来的性能变化

使用注意：
• 启用监控会有轻微的性能开销
• 需要定期清理历史数据避免占用过多空间
• 统计数据重启后会清零，需要持久化保存
```

**🔹 索引优化的科学方法**
```
传统方法问题：
• 凭经验猜测：容易误删重要索引或保留无用索引
• 一次性分析：忽略了业务变化对索引需求的影响
• 单一维度：只考虑使用频次，忽略效率和成本

科学方法优势：
• 基于数据：用真实的使用统计指导决策
• 持续监控：跟踪索引使用的变化趋势
• 多维评估：综合考虑频次、效率、成本、选择性
• 自动化：减少人工分析的工作量和主观性
```

### 10.3 实际应用指导


**🎯 索引统计分析实施路径**

```
第一阶段：基础监控（1-2周）
• 启用Performance Schema相关监控
• 收集索引使用的基础统计数据
• 识别完全未使用的索引

第二阶段：深度分析（2-4周）
• 分析索引使用模式和效率
• 计算索引的ROI和价值得分  
• 识别重复和冗余索引

第三阶段：持续优化（长期）
• 建立自动化监控和告警机制
• 根据业务变化调整索引策略
• 定期生成优化建议和执行方案
```

**🛠️ 新手实践建议**
- **从安全开始**：先只做统计分析，不要急于删除索引
- **小范围试点**：在测试环境或非关键表上先试验
- **备份保险**：删除任何索引前都要记录创建语句
- **逐步推进**：每次只处理几个索引，观察效果后再继续

**💡 高级应用技巧**
```
进阶优化策略：
• 结合慢查询日志分析索引缺失问题
• 使用覆盖索引减少回表操作
• 根据查询模式设计复合索引顺序
• 实现索引使用的机器学习预测

监控自动化：
• 设置索引使用率告警阈值
• 自动识别和标记问题索引
• 生成定期的索引健康报告
• 集成到DevOps流程中
```

### 10.4 核心记忆要点


**核心记忆**：
- Performance Schema是索引监控的数据来源，需要正确配置启用
- 索引价值评估要综合使用频次、效率、成本多个维度
- 未使用索引是优化的第一目标，但删除前要谨慎测试
- 索引使用有时间规律，要基于足够长的历史数据分析
- 自动化监控和告警能持续发现索引优化机会
- 索引优化是持续过程，随着业务发展需要动态调整