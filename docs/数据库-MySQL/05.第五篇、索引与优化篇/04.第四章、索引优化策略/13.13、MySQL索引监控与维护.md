---
title: 13、MySQL索引监控与维护
---
## 📚 目录

1. [索引监控与维护概述](#1-索引监控与维护概述)
2. [索引碎片监控](#2-索引碎片监控)
3. [索引重建维护](#3-索引重建维护)
4. [OPTIMIZE TABLE操作详解](#4-OPTIMIZE-TABLE操作详解)
5. [索引统计信息更新](#5-索引统计信息更新)
6. [索引健康检查体系](#6-索引健康检查体系)
7. [预防性索引维护](#7-预防性索引维护)
8. [维护窗口规划策略](#8-维护窗口规划策略)
9. [自动化维护脚本](#9-自动化维护脚本)
10. [维护效果评估](#10-维护效果评估)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔧 索引监控与维护概述


### 1.1 什么是索引维护


> 💡 **一句话理解**：索引维护就像给汽车做保养，定期检查、清理和调整，确保数据库查询始终保持最佳性能。

**🔸 索引维护的本质**
```
索引就像图书馆的书目卡片：
📚 新书入库 → 需要添加新的卡片
📖 书籍移位 → 需要更新卡片位置
🗑️ 旧书下架 → 需要删除相应卡片
🔄 定期整理 → 保持卡片系统井然有序

数据库索引维护同理：
• 数据插入 → 索引页分裂，产生碎片
• 数据删除 → 索引页空洞，浪费空间
• 数据更新 → 索引结构调整，性能下降
• 定期维护 → 重组结构，恢复性能
```

### 1.2 为什么需要索引维护


**⚡ 性能下降的根本原因**
```
索引碎片产生过程：
┌─ 初始状态 ─────────────────────┐
│ 索引页：[1][2][3][4][5]        │
│ 状态：连续存储，性能最佳        │
└───────────────────────────────┘
         ↓ 频繁插入删除
┌─ 碎片状态 ─────────────────────┐  
│ 索引页：[1][ ][3][ ][5][6][7]  │
│ 状态：不连续存储，性能下降      │
└───────────────────────────────┘
         ↓ 索引维护
┌─ 维护后 ───────────────────────┐
│ 索引页：[1][3][5][6][7]        │
│ 状态：重新整理，性能恢复        │
└───────────────────────────────┘
```

**📊 维护带来的收益**
```
性能提升：
• 查询速度：碎片整理后查询提速20-50%
• IO减少：连续页面减少磁盘IO次数
• 缓存效率：更好的空间局部性

资源节省：
• 存储空间：回收删除后的空洞空间
• 内存使用：减少缓冲池的无效页面
• CPU开销：减少查询时的页面扫描
```

### 1.3 索引维护的时机


**⏰ 维护触发条件**
```
主动维护时机：
• 定期维护：每周/月固定时间维护
• 碎片率过高：超过30%需要维护
• 性能下降：查询时间明显增加
• 重大数据变更后：批量删除或更新后

被动维护信号：
• 查询性能监控告警
• 存储空间增长异常
• 用户投诉响应慢
• 数据库负载过高
```

---

## 2. 🔍 索引碎片监控


### 2.1 碎片的概念和类型


> **🤔 新手困惑**：什么是索引碎片？
> **💡 生活类比**：想象你的书架，刚开始书按顺序摆放整齐，但经常取书放书后，书的顺序就乱了，找书变慢了。索引碎片就是这个道理。

**🔸 索引碎片类型**
```
内部碎片（页内碎片）：
┌─ 正常页面 ─────────────┐
│ [数据][数据][数据][数据] │ ← 页面填满，利用率高
└───────────────────────┘

┌─ 碎片页面 ─────────────┐  
│ [数据][ 空 ][数据][ 空 ] │ ← 删除数据后留下空洞
└───────────────────────┘

外部碎片（页间碎片）：
正常：页面1 → 页面2 → 页面3 （连续存储）
碎片：页面1 → 页面5 → 页面2 （不连续存储）
```

### 2.2 碎片监控方法


**📊 MySQL碎片检查方法**

```sql
-- 基础碎片检查查询
SELECT 
    table_schema AS '数据库',
    table_name AS '表名',
    index_name AS '索引名',
    ROUND(stat_value * 100 / cardinality, 2) AS '碎片率(%)',
    cardinality AS '索引行数',
    CASE 
        WHEN ROUND(stat_value * 100 / cardinality, 2) > 50 THEN '🔴 严重碎片'
        WHEN ROUND(stat_value * 100 / cardinality, 2) > 30 THEN '🟡 中度碎片'
        WHEN ROUND(stat_value * 100 / cardinality, 2) > 10 THEN '🟠 轻微碎片'
        ELSE '🟢 健康状态'
    END AS '碎片等级'
FROM information_schema.statistics s
WHERE stat_name = 'n_leaf_pages_defrag' 
  AND cardinality > 0
ORDER BY ROUND(stat_value * 100 / cardinality, 2) DESC;
```

**🔧 详细表碎片分析**
```sql
-- 表级别碎片统计
SELECT 
    table_name AS '表名',
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS '总大小(MB)',
    ROUND(data_free / 1024 / 1024, 2) AS '碎片空间(MB)',
    ROUND(data_free / (data_length + index_length) * 100, 2) AS '碎片率(%)',
    table_rows AS '记录数',
    CASE 
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 25 THEN '需要立即维护'
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 15 THEN '建议维护'
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 5 THEN '监控状态'
        ELSE '健康状态'
    END AS '维护建议'
FROM information_schema.tables 
WHERE table_schema = 'your_database'
  AND table_type = 'BASE TABLE'
  AND (data_length + index_length) > 0
ORDER BY ROUND(data_free / (data_length + index_length) * 100, 2) DESC;
```

### 2.3 碎片监控自动化


**⚡ 自动化监控脚本**

```sql
-- 创建索引健康监控表
CREATE TABLE index_health_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    index_name VARCHAR(64),
    fragmentation_percent DECIMAL(5,2),
    total_size_mb DECIMAL(10,2),
    free_space_mb DECIMAL(10,2),
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    health_status ENUM('健康', '监控', '警告', '严重')
);

-- 监控数据收集存储过程
DELIMITER $$
CREATE PROCEDURE CollectIndexHealth()
READS SQL DATA
BEGIN
    INSERT INTO index_health_log (table_name, fragmentation_percent, total_size_mb, free_space_mb, health_status)
    SELECT 
        table_name,
        ROUND(data_free / (data_length + index_length) * 100, 2),
        ROUND((data_length + index_length) / 1024 / 1024, 2),
        ROUND(data_free / 1024 / 1024, 2),
        CASE 
            WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 25 THEN '严重'
            WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 15 THEN '警告'
            WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 5 THEN '监控'
            ELSE '健康'
        END
    FROM information_schema.tables 
    WHERE table_schema = DATABASE()
      AND table_type = 'BASE TABLE'
      AND (data_length + index_length) > 0;
END$$
DELIMITER ;
```

---

## 3. 🔨 索引重建维护


### 3.1 索引重建的原理


> **💡 理解要点**：索引重建就像重新整理书架，把书按正确顺序重新摆放，删除损坏的书，让整个书架重新变得井井有条。

**🔸 重建操作类型**

| 维护操作 | **作用原理** | **适用场景** | **资源消耗** |
|---------|-------------|-------------|-------------|
| `ANALYZE TABLE` | 更新索引统计信息 | 查询计划不准确 | 🟢 很低 |
| `OPTIMIZE TABLE` | 重建表和索引 | 碎片率>30% | 🟡 中等 |
| `ALTER TABLE ... ENGINE=InnoDB` | 完全重建表 | 严重碎片>50% | 🔴 很高 |
| `REPAIR TABLE` | 修复损坏的表 | 表文件损坏 | 🟠 中高 |

### 3.2 重建操作实施


**🔧 渐进式重建策略**

```sql
-- 轻量级维护：更新统计信息
ANALYZE TABLE users, orders, products;

-- 中等维护：优化表结构
OPTIMIZE TABLE users;

-- 重度维护：完全重建
ALTER TABLE large_table ENGINE=InnoDB;
```

**⏰ 分批重建策略**
```sql
-- 分批维护大表的存储过程
DELIMITER $$
CREATE PROCEDURE BatchOptimizeTables()
MODIFIES SQL DATA
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE tbl_name VARCHAR(64);
    
    -- 获取需要维护的表
    DECLARE table_cursor CURSOR FOR
        SELECT table_name
        FROM information_schema.tables t
        WHERE table_schema = DATABASE()
          AND table_type = 'BASE TABLE'
          AND (
              SELECT ROUND(data_free / (data_length + index_length) * 100, 2)
              FROM information_schema.tables t2 
              WHERE t2.table_name = t.table_name
          ) > 15
        ORDER BY (data_length + index_length) ASC;  -- 从小表开始
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    optimize_loop: LOOP
        FETCH table_cursor INTO tbl_name;
        
        IF done THEN
            LEAVE optimize_loop;
        END IF;
        
        -- 执行优化
        SET @sql = CONCAT('OPTIMIZE TABLE ', tbl_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 记录维护日志
        INSERT INTO maintenance_log (operation, table_name, execution_time)
        VALUES ('OPTIMIZE', tbl_name, NOW());
        
        -- 暂停5秒，避免持续高负载
        DO SLEEP(5);
        
    END LOOP;
    
    CLOSE table_cursor;
END$$
DELIMITER ;
```

### 3.3 重建影响评估


**📊 维护操作影响分析**

```sql
-- 维护操作影响评估
SELECT 
    table_name AS '表名',
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS '大小(MB)',
    table_rows AS '记录数',
    -- 估算维护时间（基于经验值）
    CASE 
        WHEN (data_length + index_length) / 1024 / 1024 < 100 THEN '< 5分钟'
        WHEN (data_length + index_length) / 1024 / 1024 < 1000 THEN '5-30分钟'
        WHEN (data_length + index_length) / 1024 / 1024 < 10000 THEN '30分钟-2小时'
        ELSE '> 2小时'
    END AS '预估维护时间',
    -- 维护优先级
    CASE 
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 30 THEN '高优先级'
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 15 THEN '中优先级'
        ELSE '低优先级'
    END AS '维护优先级'
FROM information_schema.tables 
WHERE table_schema = DATABASE()
  AND table_type = 'BASE TABLE'
ORDER BY ROUND(data_free / (data_length + index_length) * 100, 2) DESC;
```

---

## 4. ⚙️ OPTIMIZE TABLE操作详解


### 4.1 OPTIMIZE TABLE工作原理


**🔄 优化操作流程**
```
OPTIMIZE TABLE执行过程：
步骤1：表锁定    → 阻止写操作，允许读操作
    ↓
步骤2：创建临时表 → 按主键顺序重建表结构
    ↓  
步骤3：数据复制  → 将数据按顺序复制到新表
    ↓
步骤4：索引重建  → 重新创建所有索引
    ↓
步骤5：原表替换  → 用新表替换原表
    ↓
步骤6：释放锁定  → 恢复正常读写操作
```

### 4.2 OPTIMIZE TABLE使用技巧


**💻 基础使用方法**
```sql
-- 单表优化
OPTIMIZE TABLE users;

-- 多表同时优化
OPTIMIZE TABLE users, orders, products;

-- 检查优化结果
SELECT 
    Table,
    Op,
    Msg_type,
    Msg_text
FROM (OPTIMIZE TABLE users) AS result;
```

**⚠️ 使用注意事项**
```
适用场景：
✅ 表有大量删除操作
✅ 表碎片率超过15%
✅ 业务低峰期执行
✅ 中小型表（<1GB）

不适用场景：
❌ 超大表（>10GB）
❌ 业务高峰期
❌ 只读副本服务器
❌ 磁盘空间不足
```

### 4.3 在线DDL与离线维护


**🔄 MySQL 8.0在线DDL优势**

```sql
-- 在线索引重建（MySQL 8.0+）
ALTER TABLE users 
DROP INDEX idx_email,
ADD INDEX idx_email(email),
ALGORITHM=INPLACE,
LOCK=NONE;

-- 在线表重建
ALTER TABLE users ENGINE=InnoDB,
ALGORITHM=INPLACE,
LOCK=SHARED;
```

**⚖️ 在线vs离线维护对比**

| 维护方式 | **优势** | **缺陷** | **适用场景** |
|---------|----------|----------|-------------|
| **在线DDL** | 不阻塞业务，用户无感知 | 功能有限，资源消耗大 | 生产环境，24x7服务 |
| **离线维护** | 功能完整，效果彻底 | 需要停机，影响业务 | 维护窗口，重大优化 |

---

## 5. 📈 索引统计信息更新


### 5.1 统计信息的作用


> **💡 理解要点**：统计信息就像GPS导航的路况信息，告诉查询优化器哪条路（查询计划）最快，过时的统计信息会导致走错路。

**🔸 统计信息包含的内容**
```
索引统计信息包含：
📊 基数统计：每列的唯一值数量
📈 数据分布：数据的分布直方图
📉 选择性：索引的选择性系数
🔢 NULL值：空值的数量和比例
```

### 5.2 统计信息更新方法


**🔄 更新统计信息**

```sql
-- 更新单个表的统计信息
ANALYZE TABLE users;

-- 批量更新多表统计信息
ANALYZE TABLE users, orders, products, order_items;

-- 查看统计信息更新结果
SELECT 
    table_schema,
    table_name,
    index_name,
    cardinality,
    last_update
FROM information_schema.statistics 
WHERE table_schema = DATABASE()
ORDER BY last_update DESC;
```

### 5.3 自动统计信息更新


**⚡ 自动化统计更新**

```sql
-- 创建统计信息监控表
CREATE TABLE statistics_monitor (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    old_cardinality BIGINT,
    new_cardinality BIGINT,
    change_percent DECIMAL(5,2),
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 智能统计信息更新
DELIMITER $$
CREATE PROCEDURE SmartAnalyzeTables()
READS SQL DATA
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE tbl_name VARCHAR(64);
    DECLARE current_rows BIGINT;
    DECLARE last_analyzed DATETIME;
    
    DECLARE table_cursor CURSOR FOR
        SELECT 
            table_name,
            table_rows
        FROM information_schema.tables
        WHERE table_schema = DATABASE()
          AND table_type = 'BASE TABLE'
          AND table_rows > 1000;  -- 只处理有意义的表
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    analyze_loop: LOOP
        FETCH table_cursor INTO tbl_name, current_rows;
        
        IF done THEN
            LEAVE analyze_loop;
        END IF;
        
        -- 检查是否需要更新统计信息
        -- 如果数据变化超过20%或者超过7天未更新
        SET @sql = CONCAT('ANALYZE TABLE ', tbl_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE table_cursor;
END$$
DELIMITER ;
```

---

## 6. 🏥 索引健康检查体系


### 6.1 索引健康度评分体系


**📊 健康度评分标准**

```sql
-- 索引健康度评分函数
DELIMITER $$
CREATE FUNCTION CalculateIndexHealthScore(
    table_name VARCHAR(64)
) RETURNS INT
READS SQL DATA
BEGIN
    DECLARE health_score INT DEFAULT 100;
    DECLARE frag_percent DECIMAL(5,2);
    DECLARE unused_indexes INT;
    
    -- 获取碎片率
    SELECT ROUND(data_free / (data_length + index_length) * 100, 2)
    INTO frag_percent
    FROM information_schema.tables
    WHERE table_schema = DATABASE() AND table_name = table_name;
    
    -- 碎片率扣分
    IF frag_percent > 30 THEN
        SET health_score = health_score - 40;
    ELSEIF frag_percent > 15 THEN
        SET health_score = health_score - 20;
    ELSEIF frag_percent > 5 THEN
        SET health_score = health_score - 10;
    END IF;
    
    -- 检查未使用的索引
    SELECT COUNT(*) INTO unused_indexes
    FROM information_schema.statistics s
    LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
      ON s.table_schema = u.object_schema 
     AND s.table_name = u.object_name 
     AND s.index_name = u.index_name
    WHERE s.table_schema = DATABASE()
      AND s.table_name = table_name
      AND u.count_read = 0;
    
    -- 未使用索引扣分
    SET health_score = health_score - (unused_indexes * 5);
    
    -- 确保分数在0-100范围内
    IF health_score < 0 THEN
        SET health_score = 0;
    END IF;
    
    RETURN health_score;
END$$
DELIMITER ;

-- 生成健康度报告
SELECT 
    table_name AS '表名',
    CalculateIndexHealthScore(table_name) AS '健康分数',
    CASE 
        WHEN CalculateIndexHealthScore(table_name) >= 90 THEN '🟢 优秀'
        WHEN CalculateIndexHealthScore(table_name) >= 70 THEN '🟡 良好'
        WHEN CalculateIndexHealthScore(table_name) >= 50 THEN '🟠 一般'
        ELSE '🔴 需要维护'
    END AS '健康等级'
FROM information_schema.tables
WHERE table_schema = DATABASE() AND table_type = 'BASE TABLE';
```

### 6.2 索引使用情况监控


**🔍 索引使用统计**

```sql
-- 索引使用情况分析
SELECT 
    object_schema AS '数据库',
    object_name AS '表名',
    index_name AS '索引名',
    count_read AS '读取次数',
    count_write AS '写入次数',
    count_fetch AS '获取次数',
    CASE 
        WHEN count_read = 0 AND count_write = 0 THEN '🔴 未使用'
        WHEN count_read < 100 THEN '🟡 使用较少'
        WHEN count_read < 10000 THEN '🟢 正常使用'
        ELSE '🔥 高频使用'
    END AS '使用状态'
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = DATABASE()
ORDER BY count_read DESC;
```

---

## 7. 🛡️ 预防性索引维护


### 7.1 预防性维护策略


**🔸 预防胜于治疗的理念**
```
预防性维护的核心思路：
┌─ 监控指标 ────────────────────┐
│ • 碎片率趋势                   │
│ • 查询性能变化                 │
│ • 索引使用频率                 │
│ • 数据增长速度                 │
└───────────────────────────────┘
         ↓ 预警阈值
┌─ 自动触发 ────────────────────┐
│ • 达到阈值自动执行维护         │
│ • 业务低峰期自动调度           │
│ • 维护完成自动通知             │
└───────────────────────────────┘
```

### 7.2 预防性维护实现


**⚡ 智能预防维护**

```sql
-- 预防性维护配置表
CREATE TABLE maintenance_config (
    table_pattern VARCHAR(64),      -- 表名模式
    fragmentation_threshold INT,    -- 碎片率阈值
    maintenance_frequency INT,      -- 维护频率(天)
    maintenance_window VARCHAR(20), -- 维护时间窗口
    auto_execute BOOLEAN DEFAULT FALSE
);

-- 插入维护策略
INSERT INTO maintenance_config VALUES
('user%', 20, 7, '02:00-04:00', TRUE),    -- 用户表系列
('order%', 15, 3, '01:00-03:00', TRUE),   -- 订单表系列  
('product%', 25, 14, '03:00-05:00', TRUE); -- 产品表系列

-- 预防性维护执行
DELIMITER $$
CREATE PROCEDURE PreventiveMaintenance()
READS SQL DATA
BEGIN
    DECLARE current_hour INT DEFAULT HOUR(NOW());
    
    -- 检查当前是否在维护窗口内
    IF current_hour BETWEEN 1 AND 5 THEN
        
        -- 执行符合条件的维护任务
        CALL BatchOptimizeTables();
        
        -- 记录维护完成
        INSERT INTO maintenance_log (operation, description, execution_time)
        VALUES ('PREVENTIVE', '预防性维护完成', NOW());
        
    END IF;
END$$
DELIMITER ;
```

---

## 8. ⏰ 维护窗口规划策略


### 8.1 维护时间选择


**🕐 维护窗口时间规划**

```
业务访问模式分析：
┌─ 24小时访问量分布 ──────────────────┐
│     ████                           │
│   ██████                           │ 
│ ████████       ██                  │
│████████████ ██████                 │
│████████████████████               │
└─────────────────────────────────────┘
 0  2  4  6  8 10 12 14 16 18 20 22 24
 
最佳维护窗口：
🌙 凌晨1:00-5:00：访问量最低
🌅 周日凌晨：周访问量最低  
🗓️ 月末最后一天：月度访问相对较低
```

### 8.2 维护优先级排序


**📊 维护任务优先级矩阵**

| 碎片率 | 表大小 | **优先级** | **维护窗口** |
|--------|--------|------------|-------------|
| >50% | 任意大小 | 🔴 紧急 | 立即执行 |
| 30-50% | <1GB | 🟠 高 | 下个维护窗口 |
| 30-50% | >1GB | 🟡 中 | 周末维护窗口 |
| 15-30% | <100MB | 🟢 低 | 月度维护 |
| <15% | 任意大小 | ⚪ 暂缓 | 暂不维护 |

**🎯 维护任务调度**
```sql
-- 维护任务优先级排序
SELECT 
    table_name,
    ROUND(data_free / (data_length + index_length) * 100, 2) AS fragmentation,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb,
    CASE 
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 50 THEN 1
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 30 
         AND (data_length + index_length) / 1024 / 1024 < 1000 THEN 2
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 30 THEN 3
        WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 15 THEN 4
        ELSE 5
    END AS priority
FROM information_schema.tables
WHERE table_schema = DATABASE()
ORDER BY priority, size_mb;
```

---

## 9. 🤖 自动化维护脚本


### 9.1 智能维护调度系统


**🔧 自动化维护框架**

```sql
-- 维护任务调度表
CREATE TABLE maintenance_schedule (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    operation_type ENUM('ANALYZE', 'OPTIMIZE', 'REBUILD'),
    scheduled_time DATETIME,
    execution_status ENUM('PENDING', 'RUNNING', 'COMPLETED', 'FAILED'),
    execution_log TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 智能调度维护任务
DELIMITER $$
CREATE PROCEDURE ScheduleMaintenanceTasks()
MODIFIES SQL DATA
BEGIN
    -- 分析需要维护的表
    INSERT INTO maintenance_schedule (table_name, operation_type, scheduled_time)
    SELECT 
        table_name,
        CASE 
            WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 40 THEN 'REBUILD'
            WHEN ROUND(data_free / (data_length + index_length) * 100, 2) > 20 THEN 'OPTIMIZE'
            ELSE 'ANALYZE'
        END,
        CASE DAYOFWEEK(NOW())
            WHEN 1 THEN NOW() + INTERVAL (8 - HOUR(NOW())) HOUR  -- 周日，当天执行
            ELSE NOW() + INTERVAL (8 - DAYOFWEEK(NOW())) DAY + INTERVAL (2 - HOUR(NOW())) HOUR  -- 下周日凌晨2点
        END
    FROM information_schema.tables
    WHERE table_schema = DATABASE()
      AND table_type = 'BASE TABLE'
      AND ROUND(data_free / (data_length + index_length) * 100, 2) > 10;
END$$
DELIMITER ;
```

### 9.2 维护执行引擎


**🚀 自动执行维护任务**

```sql
-- 执行维护任务
DELIMITER $$
CREATE PROCEDURE ExecuteMaintenanceTasks()
MODIFIES SQL DATA
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE task_id INT;
    DECLARE tbl_name VARCHAR(64);
    DECLARE op_type VARCHAR(20);
    
    DECLARE task_cursor CURSOR FOR
        SELECT id, table_name, operation_type
        FROM maintenance_schedule
        WHERE execution_status = 'PENDING'
          AND scheduled_time <= NOW()
        ORDER BY 
            CASE operation_type
                WHEN 'ANALYZE' THEN 1
                WHEN 'OPTIMIZE' THEN 2  
                WHEN 'REBUILD' THEN 3
            END;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN task_cursor;
    
    task_loop: LOOP
        FETCH task_cursor INTO task_id, tbl_name, op_type;
        
        IF done THEN
            LEAVE task_loop;
        END IF;
        
        -- 更新任务状态
        UPDATE maintenance_schedule 
        SET execution_status = 'RUNNING' 
        WHERE id = task_id;
        
        -- 执行维护操作
        CASE op_type
            WHEN 'ANALYZE' THEN
                SET @sql = CONCAT('ANALYZE TABLE ', tbl_name);
            WHEN 'OPTIMIZE' THEN  
                SET @sql = CONCAT('OPTIMIZE TABLE ', tbl_name);
            WHEN 'REBUILD' THEN
                SET @sql = CONCAT('ALTER TABLE ', tbl_name, ' ENGINE=InnoDB');
        END CASE;
        
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 更新完成状态
        UPDATE maintenance_schedule 
        SET execution_status = 'COMPLETED',
            execution_log = CONCAT('维护完成: ', NOW())
        WHERE id = task_id;
        
    END LOOP;
    
    CLOSE task_cursor;
END$$
DELIMITER ;
```

---

## 10. 📊 维护效果评估


### 10.1 维护前后对比


**⚖️ 效果评估指标**

```sql
-- 维护效果对比查询
SELECT 
    table_name AS '表名',
    -- 维护前状态（从历史记录获取）
    (SELECT fragmentation_percent 
     FROM index_health_log 
     WHERE table_name = t.table_name 
       AND check_time = (
           SELECT MAX(check_time) 
           FROM index_health_log 
           WHERE check_time < '2024-01-15 02:00:00'  -- 维护时间
       )
    ) AS '维护前碎片率',
    
    -- 维护后状态
    ROUND(data_free / (data_length + index_length) * 100, 2) AS '维护后碎片率',
    
    -- 效果评估
    ROUND(
        (SELECT fragmentation_percent 
         FROM index_health_log 
         WHERE table_name = t.table_name 
           AND check_time = (SELECT MAX(check_time) FROM index_health_log WHERE check_time < '2024-01-15 02:00:00')
        ) - ROUND(data_free / (data_length + index_length) * 100, 2), 
        2
    ) AS '碎片率改善'
    
FROM information_schema.tables t
WHERE table_schema = DATABASE() 
  AND table_type = 'BASE TABLE';
```

### 10.2 维护成本分析


**💰 维护成本统计**

```sql
-- 维护成本分析表
CREATE TABLE maintenance_cost_analysis (
    maintenance_date DATE,
    total_tables INT,
    total_time_minutes INT,
    disk_space_saved_mb DECIMAL(10,2),
    performance_improvement_percent DECIMAL(5,2),
    downtime_minutes INT
);

-- 记录维护成本
INSERT INTO maintenance_cost_analysis
SELECT 
    CURDATE(),
    COUNT(*) AS tables_maintained,
    TIMESTAMPDIFF(MINUTE, MIN(scheduled_time), MAX(scheduled_time)) AS duration,
    SUM(
        (SELECT data_free / 1024 / 1024 FROM information_schema.tables WHERE table_name = ms.table_name)
    ) AS space_saved,
    AVG(25) AS avg_performance_gain,  -- 预估性能提升
    TIMESTAMPDIFF(MINUTE, MIN(scheduled_time), MAX(scheduled_time)) AS downtime
FROM maintenance_schedule ms
WHERE execution_status = 'COMPLETED'
  AND DATE(scheduled_time) = CURDATE();
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 索引维护本质：保持索引结构最优，确保查询性能
🔸 碎片监控：定期检查碎片率，及时发现性能问题
🔸 维护操作：ANALYZE、OPTIMIZE、REBUILD三种操作的选择
🔸 自动化调度：根据业务模式制定维护计划
🔸 效果评估：量化维护效果，优化维护策略
```

### 11.2 关键理解要点


**🔹 索引维护的重要性**
```
性能影响：
• 碎片率30%以上：查询性能下降明显
• 定期维护：可提升20-50%的查询速度
• 存储优化：回收浪费的存储空间

业务价值：
• 用户体验：页面响应更快
• 系统稳定：减少查询超时
• 成本控制：节省存储和计算资源
```

**🔹 维护策略选择原则**
```
维护频率：
• 高频写入表：每周维护
• 中频写入表：每月维护
• 低频写入表：季度维护

维护方式：
• 小表(<100MB)：直接OPTIMIZE
• 大表(>1GB)：分批处理或在线DDL
• 超大表(>10GB)：专门的维护窗口

资源考虑：
• 磁盘空间：维护需要额外空间
• CPU使用：避免业务高峰期执行
• 锁竞争：选择合适的维护时间
```

### 11.3 实际应用指导


**📋 索引维护检查清单**
- [ ] 建立索引碎片监控机制
- [ ] 制定不同表的维护策略
- [ ] 设置自动化维护调度
- [ ] 配置维护效果评估体系
- [ ] 建立维护异常告警机制
- [ ] 制定维护回滚应急预案

**⚖️ 维护最佳实践**
```
监控策略：
• 每日监控：碎片率和索引使用情况
• 每周分析：维护效果和性能趋势
• 每月评估：维护策略优化调整

执行策略：
• 分级处理：根据紧急程度分批维护
• 渐进执行：避免一次性维护过多表
• 效果验证：维护后验证性能改善效果

风险控制：
• 备份保障：维护前完整备份
• 监控告警：实时监控维护进度
• 快速回滚：准备回滚方案和流程
```

> **💡 一句话总结**：索引维护是数据库性能管理的核心技能，通过科学的监控、合理的调度和有效的执行，可以让数据库始终保持最佳性能状态。

### 11.4 常见问题和解决方案


**🔸 维护过程常见问题**

| 问题类型 | **症状** | **原因** | **解决方案** |
|---------|----------|----------|-------------|
| 维护时间过长 | OPTIMIZE超过预期时间 | 表过大或IO瓶颈 | 分批处理或升级硬件 |
| 磁盘空间不足 | 维护失败报错 | 临时文件空间不够 | 清理空间或分批维护 |
| 业务影响 | 维护期间查询慢 | 维护时间选择不当 | 调整维护窗口 |
| 维护无效果 | 碎片率没有改善 | 表结构或引擎问题 | 检查表结构设计 |

**🛠️ 故障排查步骤**
```
维护异常排查流程：
1. 检查错误日志 → 确认具体错误信息
2. 验证磁盘空间 → 确保有足够的临时空间  
3. 检查表状态 → 确认表没有损坏
4. 验证权限 → 确认有足够的操作权限
5. 检查锁状态 → 确认没有长时间锁等待
6. 监控资源使用 → 确认IO、CPU、内存状况
```

**核心记忆口诀**：
```
┌─ 索引维护要诀 ─────────────────┐
│ 监控碎片定期查，维护窗口选择佳 │
│ 预防胜于事后补，自动化调度省力 │
│ 效果评估要量化，持续优化是根本 │
│ 备份回滚保安全，维护质量是关键 │
└────────────────────────────────┘
```