---
title: 1、慢查询日志配置
---
## 📚 目录

1. [慢查询日志基础概念](#1-慢查询日志基础概念)
2. [核心参数配置详解](#2-核心参数配置详解)
3. [慢查询日志格式解析](#3-慢查询日志格式解析)
4. [日志轮转与管理策略](#4-日志轮转与管理策略)
5. [高级配置与优化技巧](#5-高级配置与优化技巧)
6. [生产环境最佳实践](#6-生产环境最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 慢查询日志基础概念


### 1.1 什么是慢查询日志


> **💡 核心理解**
> 慢查询日志就像医院的病历记录，专门记录那些"生病"的SQL语句 - 执行时间超过设定阈值的查询。这些记录帮助我们找到数据库性能问题的根源。

**📊 慢查询日志的作用**：
```
数据库性能诊断流程：
正常查询 → 快速执行 → 不记录
   ↓
慢查询 → 记录到日志 → 分析优化
   ↓         ↓         ↓
超时查询   详细信息    性能提升
```

**🎯 慢查询日志能告诉我们什么**：
- **执行时间**：查询用了多长时间
- **锁等待时间**：等待锁的时间
- **扫描行数**：查询检查了多少行数据
- **返回行数**：实际返回了多少行
- **查询语句**：具体的SQL代码

### 1.2 为什么需要慢查询日志


**🚨 没有慢查询日志的问题**：
```
性能问题排查过程：
用户抱怨 → 系统慢 → 不知道哪里慢 → 盲目优化
   ↓           ↓         ↓           ↓
很难定位   资源浪费   无从下手    效果差
```

**✅ 有了慢查询日志的优势**：
```
科学的性能优化流程：
慢查询日志 → 发现问题SQL → 针对性优化 → 效果显著
     ↓           ↓           ↓           ↓
精准定位    找到根因    有的放矢    投入产出高
```

### 1.3 慢查询日志的工作原理


**⚙️ 工作机制图解**：
```
SQL执行流程中的慢查询监控：

客户端发起查询
        ↓
    MySQL接收SQL
        ↓
    开始执行计时 ⏱️
        ↓
    执行SQL查询
        ↓
    结束执行，计算耗时
        ↓
    是否超过阈值？
   /              \
YES               NO
 ↓                ↓
写入慢查询日志    正常结束
```

---

## 2. ⚙️ 核心参数配置详解


### 2.1 slow_query_log - 慢查询日志开关


> **🔧 参数说明**
> `slow_query_log` 是慢查询日志的总开关，就像房间的电源开关，不打开就什么都不会工作。

**📋 基础配置**：
```sql
-- 查看当前状态
SHOW VARIABLES LIKE 'slow_query_log';

-- 临时开启（重启后失效）
SET GLOBAL slow_query_log = ON;

-- 永久开启（配置文件中）
[mysqld]
slow_query_log = ON
```

**📊 配置状态检查**：
```sql
-- 完整的慢查询相关参数查看
SHOW VARIABLES LIKE '%slow%';

-- 预期输出示例：
-- slow_query_log: ON
-- slow_query_log_file: /var/log/mysql/slow.log
-- long_query_time: 2.000000
```

### 2.2 long_query_time - 慢查询时间阈值


> **⏰ 核心理解**
> `long_query_time` 就像考试的及格线，超过这个时间的查询就被认为是"不及格"的慢查询。设置太低会产生太多记录，设置太高会漏掉问题。

**🎯 阈值设置策略**：

| 业务类型 | 推荐阈值 | 说明 | 适用场景 |
|---------|---------|------|----------|
| **OLTP系统** | `0.5-2秒` | 在线事务处理 | 电商、支付、用户管理 |
| **OLAP系统** | `5-10秒` | 分析查询 | 数据仓库、报表系统 |
| **混合系统** | `1-3秒` | 平衡考虑 | 大多数Web应用 |
| **高并发系统** | `0.1-0.5秒` | 严格要求 | 秒杀、抢购系统 |

**🔧 动态配置示例**：
```sql
-- 查看当前阈值
SELECT $$long_query_time;

-- 临时调整（当前会话）
SET long_query_time = 1.0;

-- 全局调整（影响新连接）
SET GLOBAL long_query_time = 1.0;

-- 配置文件永久设置
[mysqld]
long_query_time = 1.0
```

**📈 阈值调整的最佳实践**：
```sql
-- 分阶段调整策略
-- 第1阶段：发现严重问题（阈值较高）
SET GLOBAL long_query_time = 5.0;

-- 第2阶段：优化明显问题后降低阈值
SET GLOBAL long_query_time = 2.0;

-- 第3阶段：精细化优化
SET GLOBAL long_query_time = 1.0;
```

### 2.3 log_queries_not_using_indexes - 记录未使用索引的查询


> **🔍 重要功能**
> 这个参数可以捕获那些没有使用索引的查询，即使它们执行很快。就像体检时发现的潜在健康风险，现在没问题不代表以后没问题。

**🎛️ 配置说明**：
```sql
-- 开启未使用索引查询的记录
SET GLOBAL log_queries_not_using_indexes = ON;

-- 配置文件设置
[mysqld]
log_queries_not_using_indexes = ON
```

**⚠️ 使用注意事项**：
```sql
-- 这个功能可能产生大量日志，建议配合其他参数使用

-- 1. 限制最小扫描行数（避免小表查询被记录）
SET GLOBAL min_examined_row_limit = 1000;

-- 2. 使用采样（只记录部分查询）
SET GLOBAL log_throttle_queries_not_using_indexes = 10;
```

**📊 实际效果示例**：
```
未开启时：只记录执行时间超过阈值的查询
SELECT * FROM users WHERE name = 'john';  -- 0.1秒，不记录

开启后：还会记录未使用索引的快速查询
SELECT * FROM users WHERE name = 'john';  -- 0.1秒，但全表扫描，会记录
```

### 2.4 min_examined_row_limit - 最小检查行数限制


> **📏 智能过滤**
> 这个参数就像一个智能过滤器，只关注那些扫描了足够多行数的查询。避免小表的全表扫描被误报为问题。

**🔧 配置原理**：
```sql
-- 设置最小检查行数
SET GLOBAL min_examined_row_limit = 1000;

-- 配置文件
[mysqld]
min_examined_row_limit = 1000
```

**💡 实际应用场景**：
```sql
-- 场景1：小表查询（不会被记录）
SELECT * FROM config WHERE status = 1;  
-- 假设config表只有50行，全表扫描但不记录

-- 场景2：大表查询（会被记录）
SELECT * FROM orders WHERE status = 1;   
-- orders表100万行，扫描了50万行，会被记录
```

**📊 推荐设置值**：
```
小型系统：min_examined_row_limit = 100
中型系统：min_examined_row_limit = 1000  
大型系统：min_examined_row_limit = 10000
```

### 2.5 管理语句记录控制


**🔧 log_slow_admin_statements - 记录管理语句**：
```sql
-- 开启管理语句记录
SET GLOBAL log_slow_admin_statements = ON;

-- 会记录这些类型的语句：
-- ALTER TABLE, ANALYZE TABLE, CHECK TABLE
-- CREATE INDEX, DROP INDEX
-- OPTIMIZE TABLE, REPAIR TABLE
```

**📡 log_slow_slave_statements - 记录从库语句**：
```sql
-- 在从库上开启慢查询记录
SET GLOBAL log_slow_slave_statements = ON;

-- 注意：主从复制环境下的特殊考虑
-- 主库的慢查询可能在从库上不慢（硬件差异）
-- 从库的慢查询可能是复制延迟导致的
```

---

## 3. 📄 慢查询日志格式解析


### 3.1 标准慢查询日志格式


> **📋 日志结构**
> 慢查询日志就像一份详细的体检报告，每一项数据都有特定的含义。理解这些数据是分析问题的基础。

**📝 完整日志示例**：
```
# Time: 2025-09-04T15:30:45.123456Z
# User@Host: webapp[webapp] @ [192.168.1.100]
# Thread_id: 12345  Schema: ecommerce
# QC_hit: No  Full_scan: Yes  Full_join: No  Tmp_table: Yes
# Tmp_table_on_disk: No  Filesort: Yes  Filesort_on_disk: No
# Merge_passes: 0
#   InnoDB_trx_id: 4B2A7C
# Query_time: 5.123456  Lock_time: 0.000123  Rows_sent: 1500  Rows_examined: 850000
# Bytes_sent: 125000
SET timestamp=1725462645;
SELECT o.*, u.username, u.email 
FROM orders o 
LEFT JOIN users u ON o.user_id = u.id 
WHERE o.created_at >= '2025-01-01' 
ORDER BY o.created_at DESC;
```

### 3.2 关键字段详解


**⏰ 时间相关字段**：
```
Time: 查询结束的时间戳
Query_time: 查询总耗时（秒）
Lock_time: 等待锁的时间（秒）
timestamp: SQL语句执行时的Unix时间戳
```

**📊 数据处理字段**：
```
Rows_sent: 返回给客户端的行数
Rows_examined: MySQL扫描检查的行数  
Bytes_sent: 发送给客户端的字节数
```

**🔍 执行特征字段**：
```
QC_hit: 是否命中查询缓存
Full_scan: 是否进行了全表扫描
Full_join: 是否使用了全连接
Tmp_table: 是否使用了临时表
Tmp_table_on_disk: 临时表是否在磁盘上
Filesort: 是否使用了文件排序
Filesort_on_disk: 排序是否在磁盘上进行
```

### 3.3 日志分析技巧


**🎯 快速识别问题查询**：
```bash
# 找出执行时间最长的查询
grep "Query_time:" /var/log/mysql/slow.log | \
sort -k2 -nr | head -10

# 找出扫描行数最多的查询  
grep "Rows_examined:" /var/log/mysql/slow.log | \
awk '{print $4}' | sort -nr | head -10

# 找出使用临时表的查询
grep "Tmp_table: Yes" /var/log/mysql/slow.log -A 10
```

**📈 性能指标计算**：
```sql
-- 查询效率比（返回行数/扫描行数，越大越好）
-- 从日志中提取：Rows_sent / Rows_examined

-- 示例分析：
-- Query 1: Rows_sent: 100, Rows_examined: 100 → 效率100%（很好）
-- Query 2: Rows_sent: 1, Rows_examined: 100000 → 效率0.001%（很差）
```

---

## 4. 🔄 日志轮转与管理策略


### 4.1 日志轮转的重要性


> **💾 存储管理**
> 慢查询日志会持续增长，就像不断积累的照片，如果不定期整理，会占满整个硬盘空间。

**📊 日志增长预估**：
```
日志增长计算：
高并发系统：每天可能产生几GB的慢查询日志
中等并发：每天几百MB到几GB
低并发：每天几MB到几百MB

没有轮转的后果：
30天无轮转 → 可能产生几十GB日志文件
影响：磁盘空间耗尽、日志分析困难
```

### 4.2 使用logrotate进行日志轮转


**🔧 logrotate配置文件**：
```bash
# 创建配置文件 /etc/logrotate.d/mysql-slow
/var/log/mysql/slow.log {
    daily          # 每天轮转
    rotate 30      # 保留30个文件
    compress       # 压缩旧文件
    delaycompress  # 延迟压缩（第二次轮转时压缩）
    missingok      # 文件不存在不报错
    notifempty     # 文件为空不轮转
    copytruncate   # 复制后清空原文件
    postrotate     # 轮转后执行的命令
        /usr/bin/mysql -e 'FLUSH SLOW LOGS;' || true
    endscript
}
```

**📋 高级轮转策略**：
```bash
# 按大小轮转（文件超过100MB时轮转）
/var/log/mysql/slow.log {
    size 100M
    rotate 10
    compress
    copytruncate
    postrotate
        /usr/bin/mysql -e 'FLUSH SLOW LOGS;' || true
    endscript
}

# 混合策略（时间+大小）
/var/log/mysql/slow.log {
    daily
    size 50M       # 超过50M立即轮转，否则每天轮转
    rotate 15
    compress
    copytruncate
    postrotate
        /usr/bin/mysql -e 'FLUSH SLOW LOGS;' || true
    endscript
}
```

### 4.3 手动日志管理


**🛠️ 手动轮转命令**：
```sql
-- MySQL内部命令
FLUSH SLOW LOGS;  -- 关闭当前日志文件，创建新的日志文件

-- 系统命令配合
mv /var/log/mysql/slow.log /var/log/mysql/slow.log.old
mysqladmin flush-logs
```

**📊 日志分析脚本示例**：
```bash
#!/bin/bash
# 慢查询日志分析脚本

LOG_FILE="/var/log/mysql/slow.log"
ANALYSIS_DIR="/var/log/mysql/analysis"
DATE=$(date +%Y%m%d)

# 创建分析目录
mkdir -p $ANALYSIS_DIR

# 使用mysqldumpslow分析
mysqldumpslow -s t -t 10 $LOG_FILE > $ANALYSIS_DIR/top10_by_time_$DATE.txt
mysqldumpslow -s c -t 10 $LOG_FILE > $ANALYSIS_DIR/top10_by_count_$DATE.txt
mysqldumpslow -s l -t 10 $LOG_FILE > $ANALYSIS_DIR/top10_by_lock_$DATE.txt

# 压缩原日志
gzip $LOG_FILE.old

echo "慢查询分析完成，结果保存在 $ANALYSIS_DIR"
```

---

## 5. 🚀 高级配置与优化技巧


### 5.1 日志采样配置


> **🎲 智能采样**
> 在高并发环境下，记录所有慢查询可能会产生过多日志。采样就像民意调查，只记录一部分有代表性的查询。

**⚙️ 采样参数配置**：
```sql
-- 设置慢查询采样率（每N个慢查询记录1个）
SET GLOBAL log_throttle_queries_not_using_indexes = 10;

-- 实际效果：
-- 有100个未使用索引的查询 → 只记录10个
-- 减少日志量的同时保持分析的有效性
```

**📊 采样率设置建议**：
```
系统负载     采样率设置      说明
低负载       1(不采样)       记录所有慢查询
中等负载     5-10           记录1/5到1/10
高负载       20-50          记录1/20到1/50  
极高负载     100+           只记录极少数样本
```

### 5.2 动态阈值调整机制


**🔄 智能阈值调整策略**：
```sql
-- 基于系统负载的动态调整
-- 高峰期：提高阈值，减少日志量
SET GLOBAL long_query_time = 3.0;

-- 低峰期：降低阈值，发现更多问题
SET GLOBAL long_query_time = 0.5;

-- 可以通过定时任务实现自动调整
```

**📅 时间段配置示例**：
```bash
#!/bin/bash
# 动态调整慢查询阈值的定时脚本

HOUR=$(date +%H)
MYSQL="mysql -u root -p'password'"

if [ $HOUR -ge 9 ] && [ $HOUR -le 18 ]; then
    # 工作时间：阈值设高一些
    $MYSQL -e "SET GLOBAL long_query_time = 2.0;"
elif [ $HOUR -ge 19 ] && [ $HOUR -le 23 ]; then
    # 晚间：中等阈值
    $MYSQL -e "SET GLOBAL long_query_time = 1.0;"  
else
    # 深夜：低阈值，发现更多问题
    $MYSQL -e "SET GLOBAL long_query_time = 0.5;"
fi
```

### 5.3 慢查询日志分类存储


**📁 分类存储策略**：
```sql
-- 方法1：按查询类型分类（需要应用层配合）
-- 在SQL中添加注释来标识查询类型
SELECT /* REPORT_QUERY */ * FROM orders WHERE ...;
SELECT /* USER_QUERY */ * FROM users WHERE ...;

-- 方法2：使用不同的数据库连接
-- 报表查询使用专门的连接，设置不同的慢查询日志文件
```

**🔧 多实例日志配置**：
```bash
# my.cnf配置示例
[mysqld]
slow_query_log = ON
slow_query_log_file = /var/log/mysql/slow-general.log
long_query_time = 1.0

# 为特定用户设置不同的慢查询阈值
# 通过连接参数实现
mysql -u report_user -p --init-command="SET long_query_time=5.0"
```

### 5.4 性能影响控制


**⚖️ 慢查询日志对性能的影响**：
```
开启慢查询日志的成本：
1. CPU开销：每个查询都要计时和判断（很小）
2. 磁盘IO：写入日志文件（主要开销）
3. 磁盘空间：日志文件存储

优化策略：
1. 使用SSD存储日志文件
2. 设置合理的日志轮转
3. 使用采样减少写入量
4. 将日志文件放在独立的磁盘分区
```

**📊 性能影响测试**：
```sql
-- 测试慢查询日志对性能的影响
-- 关闭慢查询日志
SET GLOBAL slow_query_log = OFF;
-- 执行性能测试...

-- 开启慢查询日志  
SET GLOBAL slow_query_log = ON;
-- 再次执行相同的性能测试...

-- 比较两次测试结果
-- 通常性能下降在1-5%之间（可接受范围）
```

---

## 6. 🏭 生产环境最佳实践


### 6.1 生产环境配置模板


> **⚡ 生产级配置**
> 这是经过实际验证的生产环境配置，平衡了日志的完整性和系统性能。

**📋 推荐配置模板**：
```sql
# my.cnf 生产环境慢查询配置
[mysqld]
# 基础配置
slow_query_log = ON
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1.0

# 高级配置
log_queries_not_using_indexes = ON
min_examined_row_limit = 1000
log_throttle_queries_not_using_indexes = 10
log_slow_admin_statements = ON

# 从库特殊配置（如果是从库）
# log_slow_slave_statements = ON
```

**🔧 配置参数说明表**：

| 参数 | 设置值 | 原因 | 备注 |
|------|--------|------|------|
| `long_query_time` | `1.0` | 1秒是大多数OLTP系统的合理阈值 | 可根据业务调整 |
| `min_examined_row_limit` | `1000` | 避免小表查询产生噪音 | 大型系统可设为10000 |
| `log_throttle_queries_not_using_indexes` | `10` | 控制未使用索引查询的日志量 | 高并发可设为50-100 |

### 6.2 监控和告警配置


**📊 关键监控指标**：
```bash
# 1. 慢查询数量监控
mysql -e "SHOW GLOBAL STATUS LIKE 'Slow_queries';"

# 2. 日志文件大小监控  
du -h /var/log/mysql/slow.log

# 3. 日志增长速率监控
tail -f /var/log/mysql/slow.log | wc -l

# 4. 最慢查询监控（使用mysqldumpslow）
mysqldumpslow -s t -t 5 /var/log/mysql/slow.log
```

**🚨 告警脚本示例**：
```bash
#!/bin/bash
# 慢查询告警脚本

SLOW_LOG="/var/log/mysql/slow.log"
ALERT_THRESHOLD=100  # 每小时慢查询超过100个告警
HOUR_AGO=$(date -d "1 hour ago" "+%Y-%m-%d %H:%M:%S")

# 统计最近1小时的慢查询数量
SLOW_COUNT=$(grep "Query_time:" $SLOW_LOG | \
    awk -v start="$HOUR_AGO" '$0 > start' | wc -l)

if [ $SLOW_COUNT -gt $ALERT_THRESHOLD ]; then
    echo "告警：最近1小时产生了 $SLOW_COUNT 个慢查询，超过阈值 $ALERT_THRESHOLD"
    # 发送告警通知（邮件、短信等）
    # send_alert "慢查询告警" "慢查询数量：$SLOW_COUNT"
fi
```

### 6.3 日志分析自动化


**🤖 自动分析脚本**：
```bash
#!/bin/bash
# 每日慢查询自动分析报告

DATE=$(date +%Y%m%d)
SLOW_LOG="/var/log/mysql/slow.log"
REPORT_DIR="/var/reports/mysql"
mkdir -p $REPORT_DIR

echo "=== MySQL慢查询日报 $DATE ===" > $REPORT_DIR/daily_$DATE.txt

# 1. 总体统计
echo "## 总体统计" >> $REPORT_DIR/daily_$DATE.txt
TOTAL_SLOW=$(grep "Query_time:" $SLOW_LOG | wc -l)
echo "总慢查询数: $TOTAL_SLOW" >> $REPORT_DIR/daily_$DATE.txt

# 2. Top 10 最慢查询
echo "## Top 10 最慢查询" >> $REPORT_DIR/daily_$DATE.txt
mysqldumpslow -s t -t 10 $SLOW_LOG >> $REPORT_DIR/daily_$DATE.txt

# 3. Top 10 最频繁慢查询
echo "## Top 10 最频繁慢查询" >> $REPORT_DIR/daily_$DATE.txt  
mysqldumpslow -s c -t 10 $SLOW_LOG >> $REPORT_DIR/daily_$DATE.txt

# 4. 未使用索引的查询
echo "## 未使用索引的查询" >> $REPORT_DIR/daily_$DATE.txt
grep "Full_scan: Yes" $SLOW_LOG | wc -l >> $REPORT_DIR/daily_$DATE.txt

# 发送报告邮件
# mail -s "MySQL慢查询日报 $DATE" dba@company.com < $REPORT_DIR/daily_$DATE.txt
```

### 6.4 配置效果评估


**📈 配置效果评估方法**：
```sql
-- 1. 监控慢查询趋势
SELECT 
    DATE(FROM_UNIXTIME(time)) as date,
    COUNT(*) as slow_query_count
FROM mysql.slow_log 
WHERE time >= UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 7 DAY))
GROUP BY DATE(FROM_UNIXTIME(time))
ORDER BY date;

-- 2. 分析查询类型分布
SELECT 
    SUBSTRING_INDEX(SUBSTRING_INDEX(sql_text, ' ', 2), ' ', -1) as query_type,
    COUNT(*) as count,
    AVG(query_time) as avg_time
FROM mysql.slow_log
GROUP BY query_type
ORDER BY count DESC;
```

**🎯 配置调优建议**：
```
根据评估结果调整：

如果慢查询数量太多：
- 提高 long_query_time 阈值
- 增加 min_examined_row_limit
- 提高采样率

如果捕获的问题不够：
- 降低 long_query_time 阈值  
- 开启 log_queries_not_using_indexes
- 减少采样率
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


> **🎯 关键理解**
> 慢查询日志是MySQL性能优化的重要工具，正确配置和使用能大幅提升数据库性能分析效率。

```
🔸 慢查询日志：记录执行时间超过阈值的SQL语句
🔸 核心参数：slow_query_log、long_query_time、log_queries_not_using_indexes
🔸 日志格式：包含执行时间、扫描行数、返回行数等关键信息
🔸 管理策略：日志轮转、采样控制、分类存储
🔸 生产实践：监控告警、自动分析、性能平衡
```

### 7.2 配置要点速查


**⚙️ 快速配置检查清单**：
- [ ] `slow_query_log = ON` - 开启慢查询日志
- [ ] `long_query_time` - 设置合适的时间阈值
- [ ] `min_examined_row_limit` - 设置最小扫描行数
- [ ] `log_queries_not_using_indexes = ON` - 记录未使用索引的查询  
- [ ] 配置日志轮转策略
- [ ] 设置监控和告警
- [ ] 定期分析日志内容

### 7.3 常见问题解决


**🚨 问题排查指南**：
```
问题1：日志文件过大
解决：配置logrotate，设置采样率

问题2：慢查询数量太多
解决：提高阈值，增加min_examined_row_limit

问题3：捕获不到问题查询  
解决：降低阈值，开启索引相关记录

问题4：日志分析困难
解决：使用mysqldumpslow工具，编写分析脚本
```

### 7.4 性能优化价值


**💪 实际应用效果**：
- **问题发现**：快速定位性能瓶颈SQL
- **优化指导**：提供具体的优化方向
- **效果验证**：优化前后效果对比
- **预防监控**：持续监控性能状态

**🔑 记忆要点**：
- 慢查询日志是性能优化的"体检报告"
- 合理配置参数平衡详细程度和系统开销
- 定期分析日志内容，持续优化数据库性能
- 生产环境必须配置监控和自动化分析

**核心公式**：
```
优化效果 = 发现问题的准确性 × 分析效率 × 持续监控能力
```