---
title: 1、查询优化器架构原理
---
## 📚 目录

1. [查询优化器基础概念](#1-查询优化器基础概念)
2. [优化器架构框架解析](#2-优化器架构框架解析)
3. [基于成本的优化器CBO详解](#3-基于成本的优化器CBO详解)
4. [优化器核心组件深入](#4-优化器核心组件深入)
5. [优化器决策与控制机制](#5-优化器决策与控制机制)
6. [优化器性能监控与调优](#6-优化器性能监控与调优)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🧠 查询优化器基础概念


### 1.1 什么是查询优化器


**🤔 查询优化器的本质理解**

查询优化器就像一个超级智能的GPS导航系统：
- **输入**：你的SQL语句（目的地）
- **输出**：最佳执行计划（最优路线）
- **目标**：用最少的时间和资源完成查询

```
查询优化器工作类比：

人工选择路线:
家 → 公司
可能路线1: 走高速（快但可能堵车）
可能路线2: 走小路（慢但稳定）  
可能路线3: 走地铁（便宜但换乘多）

查询优化器选择执行计划:
SELECT * FROM users WHERE age > 25
可能方案1: 全表扫描（简单但慢）
可能方案2: 索引扫描（复杂但快）
可能方案3: 索引+回表（平衡方案）
```

> **核心理解**：优化器不是执行SQL的，而是为SQL找到最佳执行方式的"军师"。

### 1.2 为什么需要查询优化器


**📊 没有优化器会怎样？**

```
无优化器场景:
程序员写: SELECT * FROM orders WHERE customer_id = 123
数据库执行: 
1. 从第一行开始扫描
2. 检查每一行的customer_id
3. 找到匹配的返回
4. 扫描到表结尾
结果: 100万行数据全部扫描一遍

有优化器场景:
程序员写: SELECT * FROM orders WHERE customer_id = 123  
优化器分析:
1. 检查customer_id字段是否有索引 ✓
2. 评估索引扫描成本 vs 全表扫描成本
3. 选择索引扫描方案
4. 生成执行计划
结果: 通过索引直接定位，只需要几次IO
```

**⚡ 优化器的价值体现**

| **场景** | **无优化器** | **有优化器** | **性能提升** |
|---------|-------------|-------------|-------------|
| **简单查询** | `全表扫描` | `索引查找` | `100-1000倍` |
| **复杂JOIN** | `嵌套循环` | `哈希连接` | `10-100倍` |
| **聚合查询** | `先查询后聚合` | `索引直接聚合` | `10-50倍` |
| **子查询** | `逐行执行子查询` | `转换为JOIN` | `5-20倍` |

### 1.3 优化器发展历程与架构演进


**📈 MySQL优化器的发展历程**

```
MySQL优化器发展时间线：

MySQL 3.x (1995-2000)
    ↓
基础规则优化器（RBO）
• 简单的启发式规则
• 固定的优化策略
• 无统计信息支持

MySQL 4.x-5.5 (2000-2010)  
    ↓
混合优化器
• 部分成本评估
• 基础统计信息
• 有限的优化规则

MySQL 5.6+ (2012-现在)
    ↓
现代成本优化器（CBO）
• 完整成本模型
• 丰富统计信息  
• 智能优化算法
• 直方图支持（8.0+）
```

---

## 2. 🏗️ 优化器架构框架解析


### 2.1 优化器整体架构


**🔧 优化器框架结构图**

```
MySQL查询优化器架构：

┌─────────────────────────────────────────────────────┐
│                SQL语句输入                           │
└─────────────────┬───────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────┐
│              语法解析器                              │
│          • 词法分析  • 语法分析                      │
│          • 语法树构建 • 语义检查                     │
└─────────────────┬───────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────┐
│             查询重写器                               │
│        • 子查询重写  • 视图展开                      │
│        • 常量传播   • 谓词推导                       │
└─────────────────┬───────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────┐
│           统计信息收集器                             │
│      • 表统计信息  • 索引统计信息                    │
│      • 数据分布   • 直方图分析                       │
└─────────────────┬───────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────┐
│            执行计划生成器                            │
│       • 访问路径枚举  • 连接顺序优化                 │
│       • 成本计算     • 最优方案选择                  │
└─────────────────┬───────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────┐
│              最终执行计划                            │
│           传递给存储引擎执行                         │
└─────────────────────────────────────────────────────┘
```

### 2.2 优化器多阶段处理机制


**🔄 优化器的四个处理阶段**

MySQL优化器采用多阶段处理，每个阶段负责不同的优化任务：

```
阶段1: 预处理阶段
输入: 原始SQL语句
处理: 
• 语法检查和解析
• 权限验证  
• 名称解析（表名、字段名）
• 视图展开
输出: 解析树

阶段2: 逻辑优化阶段  
输入: 解析树
处理:
• 查询重写
• 子查询转换
• 常量折叠
• 谓词下推
输出: 逻辑执行计划

阶段3: 物理优化阶段
输入: 逻辑执行计划
处理:
• 访问路径选择
• 连接算法选择
• 连接顺序确定  
• 成本估算
输出: 物理执行计划

阶段4: 执行准备阶段
输入: 物理执行计划
处理:
• 执行计划优化
• 资源预分配
• 执行器准备
输出: 可执行计划
```

### 2.3 优化器插件架构


**🔌 优化器的可扩展设计**

MySQL 5.6+引入了插件化的优化器架构：

| **插件类型** | **功能** | **可扩展性** | **应用场景** |
|-------------|---------|-------------|-------------|
| **优化规则插件** | `特定优化逻辑` | `可添加自定义规则` | `专业优化需求` |
| **成本模型插件** | `成本计算逻辑` | `可调整成本参数` | `硬件适配优化` |
| **统计插件** | `统计信息收集` | `可定制统计策略` | `特殊数据特征` |
| **执行路径插件** | `访问方法扩展` | `可添加新算法` | `新存储引擎` |

```sql
-- 查看优化器插件状态
SELECT * FROM information_schema.OPTIMIZER_TRACE;

-- 启用优化器跟踪（调试用）
SET optimizer_trace='enabled=on';
SELECT * FROM users WHERE age > 25;
SELECT * FROM information_schema.OPTIMIZER_TRACE;
```

---

## 3. 💰 基于成本的优化器CBO详解


### 3.1 什么是基于成本的优化


**💡 成本优化器的核心思想**

基于成本的优化器（Cost-Based Optimizer, CBO）就像一个精明的会计师：

```
成本计算模型：

查询方案A: 全表扫描
成本 = 读取页数 × 页读取成本 + CPU处理成本
     = 1000页 × 1.0 + 100000行 × 0.2
     = 1000 + 20000 = 21000

查询方案B: 索引扫描  
成本 = 索引页读取 + 数据页读取 + CPU成本
     = 3页 × 1.0 + 50页 × 1.0 + 50行 × 0.2
     = 3 + 50 + 10 = 63

结论: 方案B成本更低，选择索引扫描
```

### 3.2 成本计算的关键因素


**⚖️ 影响成本计算的核心要素**

```
成本计算公式分解：

总成本 = IO成本 + CPU成本 + 网络成本

IO成本:
• 磁盘随机读取成本
• 磁盘顺序读取成本  
• 内存缓冲命中率
• SSD vs 机械硬盘差异

CPU成本:
• 记录比较成本
• 表达式计算成本
• 排序算法成本
• 连接算法成本

网络成本:
• 数据传输量
• 网络延迟
• 结果集大小
```

**📊 MySQL成本常数表**

| **成本类型** | **默认值** | **含义** | **调优建议** |
|-------------|-----------|---------|-------------|
| **io_block_read_cost** | `1.0` | `随机页读取成本` | `SSD可调低至0.5` |
| **memory_block_read_cost** | `0.25` | `内存页读取成本` | `大内存可调低` |
| **disk_temptable_create_cost** | `20.0` | `磁盘临时表创建` | `根据磁盘性能调整` |
| **disk_temptable_row_cost** | `0.5` | `磁盘临时表行处理` | `配合临时表策略` |
| **key_compare_cost** | `0.05` | `键值比较成本` | `复杂索引可调高` |
| **row_evaluate_cost** | `0.1` | `行条件评估成本` | `复杂WHERE可调高` |

### 3.3 统计信息收集机制


**📈 统计信息的重要性**

统计信息是成本计算的基础数据，就像GPS需要实时路况信息：

```
统计信息收集内容：

表级统计:
┌─────────────────────────────────┐
│ • 表总行数 (Cardinality)        │
│ • 表大小 (Data Length)          │
│ • 平均行长度 (Avg Row Length)   │
│ • 数据更新时间 (Update Time)    │
└─────────────────────────────────┘

索引级统计:
┌─────────────────────────────────┐  
│ • 索引唯一值数量 (Cardinality)  │
│ • 索引高度 (Index Height)       │
│ • 索引叶子页数量 (Leaf Pages)   │
│ • 索引选择性 (Selectivity)      │
└─────────────────────────────────┘

列级统计（MySQL 8.0+）:
┌─────────────────────────────────┐
│ • 列值分布直方图               │
│ • 空值比例 (NULL Ratio)        │
│ • 最小/最大值范围              │
│ • 热点值统计                   │
└─────────────────────────────────┘
```

**🔄 统计信息更新机制**

```sql
-- 手动更新表统计信息
ANALYZE TABLE users;

-- 查看表统计信息
SELECT 
    table_name,
    table_rows,
    avg_row_length,
    data_length,
    index_length,
    update_time
FROM information_schema.TABLES 
WHERE table_name = 'users';

-- 查看索引统计信息
SHOW INDEX FROM users;
```

### 3.4 直方图统计应用（MySQL 8.0+）


**📊 直方图让优化器更聪明**

MySQL 8.0引入的直方图功能，让优化器能够更准确地估算查询成本：

```sql
-- 创建列直方图
ANALYZE TABLE users UPDATE HISTOGRAM ON age WITH 100 BUCKETS;

-- 查看直方图信息  
SELECT 
    schema_name,
    table_name, 
    column_name,
    histogram
FROM information_schema.COLUMN_STATISTICS;

-- 删除直方图
ANALYZE TABLE users DROP HISTOGRAM ON age;
```

**💡 直方图优化效果**

```
无直方图情况:
WHERE age BETWEEN 20 AND 30
优化器假设: 均匀分布，估算10%的行
实际情况: 可能80%的用户都是20-30岁
结果: 成本估算严重偏差，选择错误执行计划

有直方图情况:  
WHERE age BETWEEN 20 AND 30
优化器知道: 20-30岁占80%的行
实际情况: 与统计一致
结果: 准确的成本估算，选择正确执行计划
```

---

## 4. ⚙️ 优化器核心组件深入


### 4.1 查询重写器工作机制


**🔄 查询重写的核心作用**

查询重写器负责将复杂的SQL转换为更高效的等价形式：

```sql
-- 原始复杂查询
SELECT * FROM orders o 
WHERE EXISTS (
    SELECT 1 FROM customers c 
    WHERE c.id = o.customer_id 
    AND c.city = '北京'
);

-- 重写器转换后
SELECT o.* FROM orders o 
INNER JOIN customers c ON c.id = o.customer_id 
WHERE c.city = '北京';
```

**🎯 常见重写规则**

| **重写类型** | **原始形式** | **重写后形式** | **性能提升** |
|-------------|-------------|---------------|-------------|
| **子查询转JOIN** | `EXISTS子查询` | `INNER JOIN` | `2-10倍` |
| **常量折叠** | `WHERE 1+1=2` | `WHERE TRUE` | `减少计算` |
| **谓词下推** | `JOIN后过滤` | `JOIN前过滤` | `减少中间结果` |
| **投影下推** | `SELECT *` | `SELECT 需要字段` | `减少传输` |

### 4.2 执行计划生成器详解


**🗺️ 执行计划生成的核心步骤**

```
执行计划生成流程：

Step 1: 访问路径枚举
┌────────────────────────────────┐
│ 表A可选路径:                   │
│ • 全表扫描                     │
│ • 主键索引扫描                 │  
│ • age索引扫描                  │
│ • name索引扫描                 │
└────────────────────────────────┘

Step 2: 连接方法选择
┌────────────────────────────────┐
│ A JOIN B可选算法:              │
│ • 嵌套循环连接 (NLJ)           │
│ • 块嵌套循环连接 (BNL)         │
│ • 哈希连接 (Hash Join 8.0+)    │
└────────────────────────────────┘

Step 3: 连接顺序确定  
┌────────────────────────────────┐
│ A,B,C三表连接顺序:             │
│ • (A JOIN B) JOIN C            │
│ • (A JOIN C) JOIN B            │
│ • (B JOIN C) JOIN A            │
└────────────────────────────────┘

Step 4: 成本计算与选择
┌────────────────────────────────┐
│ 每种组合计算总成本:            │
│ • 方案1: 成本 = 1250           │
│ • 方案2: 成本 = 890  ← 最优    │
│ • 方案3: 成本 = 1450           │
└────────────────────────────────┘
```

### 4.3 优化器扩展机制


**🔧 自定义优化器行为**

MySQL提供了多种机制来扩展或调整优化器行为：

```sql
-- 优化器开关控制
SET optimizer_switch = 'index_merge=on,index_merge_union=on';

-- 查看所有优化器开关
SELECT $$optimizer_switch;

-- 会话级别设置
SET SESSION optimizer_search_depth = 8;

-- 全局级别设置  
SET GLOBAL optimizer_prune_level = 1;
```

**🎛️ 重要优化器开关详解**

| **开关名称** | **默认值** | **作用** | **调优场景** |
|-------------|-----------|---------|-------------|
| **index_merge** | `ON` | `多索引合并优化` | `复杂WHERE条件` |
| **index_merge_union** | `ON` | `OR条件索引合并` | `多条件OR查询` |
| **index_merge_sort_union** | `ON` | `排序合并优化` | `范围OR查询` |
| **subquery_to_derived** | `ON` | `子查询转派生表` | `复杂子查询` |
| **use_index_extensions** | `ON` | `使用索引扩展` | `InnoDB辅助索引` |
| **condition_fanout_filter** | `ON` | `条件扇出过滤` | `JOIN条件优化` |

---

## 5. 🎯 优化器决策与控制机制


### 5.1 索引提示控制系统


**💡 什么是索引提示？**

索引提示就是给优化器的"建议"，类似于对GPS说"我想走高速"：

```sql
-- USE INDEX: 建议使用某个索引
SELECT * FROM users USE INDEX (idx_age) WHERE age > 25;

-- FORCE INDEX: 强制使用某个索引  
SELECT * FROM users FORCE INDEX (idx_name) WHERE name LIKE '张%';

-- IGNORE INDEX: 忽略某个索引
SELECT * FROM users IGNORE INDEX (idx_age) WHERE age > 25 AND name = '张三';
```

**⚖️ 索引提示使用场景**

| **提示类型** | **使用场景** | **注意事项** | **示例** |
|-------------|-------------|-------------|---------|
| **USE INDEX** | `优化器选择不当` | `只是建议，可能被忽略` | `复杂条件查询` |
| **FORCE INDEX** | `确定索引更优` | `强制执行，谨慎使用` | `特定业务场景` |
| **IGNORE INDEX** | `避免错误索引` | `可能导致全表扫描` | `调试和对比` |

### 5.2 优化器版本控制


**📈 优化器版本演进特点**

不同MySQL版本的优化器能力差异很大：

```
优化器能力对比：

MySQL 5.6:
• 基础成本优化
• 简单统计信息
• 有限的重写规则
• 不支持哈希连接

MySQL 5.7:  
• 改进的成本模型
• 更多优化开关
• 生成列索引支持
• JSON函数优化

MySQL 8.0:
• 直方图统计信息
• 哈希连接算法
• 反连接优化
• 窗口函数优化
• 公用表表达式(CTE)
• 不可见索引支持
```

### 5.3 优化器控制参数调优


**🎛️ 关键优化器参数**

```sql
-- 查看当前优化器配置
SHOW VARIABLES LIKE 'optimizer%';

-- 重要参数说明
SET optimizer_search_depth = 62;        -- 搜索深度
SET optimizer_prune_level = 1;          -- 剪枝级别  
SET optimizer_trace_max_mem_size = 16384; -- 跟踪内存大小
```

**📊 优化器参数调优指南**

| **参数** | **默认值** | **推荐值** | **调优原理** |
|---------|-----------|-----------|-------------|
| **optimizer_search_depth** | `62` | `6-10（复杂查询）` | `搜索深度越大，计划越优但耗时越长` |
| **optimizer_prune_level** | `1` | `1（保持默认）` | `剪枝可以减少搜索空间` |
| **eq_range_index_dive_limit** | `200` | `100-500` | `IN条件过多时的优化策略` |
| **range_optimizer_max_mem_size** | `8MB` | `16-64MB` | `范围优化器内存限制` |

---

## 6. 📊 优化器性能监控与调优


### 6.1 优化器性能监控


**🔍 监控优化器工作状态**

```sql
-- 启用优化器跟踪
SET optimizer_trace='enabled=on,one_line=off';

-- 执行目标SQL
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE c.city = '北京' AND o.order_date >= '2024-01-01';

-- 查看优化过程
SELECT * FROM information_schema.OPTIMIZER_TRACE\G

-- 关闭跟踪
SET optimizer_trace='enabled=off';
```

**📈 优化器关键监控指标**

| **监控维度** | **关键指标** | **正常范围** | **异常处理** |
|-------------|-------------|-------------|-------------|
| **优化时间** | `optimization_time` | `<10ms` | `简化查询复杂度` |
| **搜索空间** | `considered_execution_plans` | `<1000` | `减少搜索深度` |
| **成本计算** | `cost_for_plan` | `合理范围` | `更新统计信息` |
| **索引使用** | `potential_range_indexes` | `有效索引存在` | `添加合适索引` |

### 6.2 优化器调优方法论


**🎯 系统化优化器调优步骤**

```
优化器调优流程：

Step 1: 问题识别
┌─────────────────────────────┐
│ • 慢查询日志分析            │
│ • EXPLAIN执行计划检查       │
│ • 性能监控指标异常          │
└─────────────────────────────┘
         ↓
Step 2: 根因分析  
┌─────────────────────────────┐
│ • 统计信息是否过期          │
│ • 索引是否合理              │
│ • 查询是否可以重写          │  
│ • 优化器参数是否合适        │
└─────────────────────────────┘
         ↓
Step 3: 优化实施
┌─────────────────────────────┐
│ • 更新统计信息              │
│ • 添加或调整索引            │
│ • SQL重写优化               │
│ • 优化器参数调整            │
└─────────────────────────────┘
         ↓
Step 4: 效果验证
┌─────────────────────────────┐
│ • 执行计划对比              │
│ • 性能测试验证              │
│ • 监控指标检查              │
│ • 回归测试确认              │
└─────────────────────────────┘
```

### 6.3 优化器常见问题诊断


**🔧 典型优化器问题与解决方案**

```sql
-- 问题1: 统计信息过期导致执行计划不当
-- 诊断方法
SELECT 
    table_name,
    table_rows,
    update_time,
    DATEDIFF(NOW(), update_time) as days_old
FROM information_schema.TABLES 
WHERE table_schema = 'your_db' AND days_old > 7;

-- 解决方案
ANALYZE TABLE problematic_table;

-- 问题2: 复杂查询优化时间过长
-- 诊断方法  
SET optimizer_trace='enabled=on';
-- 执行慢SQL
SELECT trace FROM information_schema.OPTIMIZER_TRACE;

-- 解决方案
SET optimizer_search_depth = 6;  -- 减少搜索深度
```

**⚠️ 优化器调优注意事项**

```
调优原则：

1. 循序渐进原则
   • 一次只调整一个参数
   • 观察效果后再继续
   • 记录每次调整的影响

2. 测试验证原则  
   • 在测试环境充分验证
   • 进行回归测试
   • 准备回滚方案

3. 监控反馈原则
   • 持续监控关键指标
   • 定期检查执行计划
   • 及时发现性能退化
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 优化器架构：多阶段处理，从语法解析到执行计划生成
🔸 成本优化器：基于统计信息计算执行成本，选择最优方案
🔸 统计信息：优化器决策的基础数据，需要定期更新维护  
🔸 查询重写：将复杂SQL转换为高效等价形式
🔸 索引提示：在必要时引导优化器选择合适的执行策略
🔸 性能监控：通过跟踪和分析优化器工作状态进行调优
```

### 7.2 关键理解要点


**🔹 优化器的本质作用**
```
核心理解：
优化器不是魔法，而是基于统计信息的智能决策系统
好的统计信息 + 合适的索引 = 优秀的执行计划
优化器只能在给定条件下找到相对最优解
```

**🔹 成本计算的重要性**
```
成本模型的价值：
量化不同执行路径的代价
提供客观的决策依据  
适应不同硬件环境的性能特点
```

**🔹 优化器与开发者的协作**
```
协作关系：
开发者：提供合理的SQL和索引设计
优化器：在给定条件下选择最优执行计划
运维者：维护准确的统计信息和合适的参数配置
```

### 7.3 实际应用指导


**💼 开发阶段应用**
- **SQL设计**：编写优化器友好的SQL语句
- **索引设计**：根据查询模式设计有效索引
- **查询分析**：使用EXPLAIN分析执行计划合理性

**🔧 运维阶段应用**
- **统计维护**：定期更新表和索引统计信息
- **性能监控**：监控优化器工作状态和决策质量
- **参数调优**：根据业务特点调整优化器参数

**🎯 问题诊断应用**
- **慢查询分析**：从优化器角度分析性能问题
- **执行计划对比**：版本升级后的执行计划变化
- **参数影响评估**：配置变更对优化器的影响

### 7.4 学习进阶建议


**📚 深入学习方向**
- **统计学基础**：理解数据分布对成本估算的影响
- **算法原理**：学习连接算法、排序算法的实现
- **存储结构**：深入了解B+树、哈希索引的特点

**🛠️ 实践技能提升**
- 熟练使用optimizer_trace分析优化过程
- 掌握不同场景下的索引提示使用技巧
- 建立系统化的优化器调优方法论

**核心记忆口诀**：
```
优化器架构分四层，解析重写统计生成
成本模型是核心，统计信息要更新
索引提示需谨慎，监控跟踪找问题
参数调优要测试，循序渐进验证果
```