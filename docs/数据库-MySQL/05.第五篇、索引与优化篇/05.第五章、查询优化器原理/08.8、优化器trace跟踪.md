---
title: 8、优化器trace跟踪
---
## 📚 目录

1. [优化器跟踪系统概述](#1-优化器跟踪系统概述)
2. [优化器跟踪开启与配置](#2-优化器跟踪开启与配置)
3. [跟踪信息结构分析](#3-跟踪信息结构分析)
4. [成本计算过程详解](#4-成本计算过程详解)
5. [优化决策路径分析](#5-优化决策路径分析)
6. [跟踪信息解读与诊断](#6-跟踪信息解读与诊断)
7. [优化器trace工具实践](#7-优化器trace工具实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 优化器跟踪系统概述


### 1.1 什么是优化器trace


**🔸 核心定义**
```
优化器trace：MySQL查询优化器的"思考过程"记录器
作用：详细记录优化器如何分析SQL、计算成本、选择执行计划
价值：让DBA能够"看透"优化器的决策逻辑，精准调优
```

**💡 通俗理解**
想象你在解数学题，优化器trace就像是把你的解题过程完整记录下来：
- **问题分析**：SQL语句有哪些可能的执行方式
- **计算过程**：每种方式的成本计算细节
- **决策过程**：为什么最终选择了某个执行计划
- **结果验证**：实际执行效果如何

### 1.2 trace系统的价值


**🎯 解决的问题**
```
传统分析的局限：
• EXPLAIN只显示最终结果，看不到决策过程
• 不知道为什么选择了某个索引
• 无法理解成本计算的依据
• 难以发现优化器的"错误"判断

trace系统的优势：
• 完整的决策过程透明化
• 详细的成本计算数据
• 可以发现统计信息不准确的问题
• 为手动优化提供精确依据
```

### 1.3 trace系统架构


**🏗️ trace工作流程**
```
SQL解析 → 优化器分析 → trace记录 → JSON输出

┌─────────────┐
│   SQL输入   │
└─────┬───────┘
      │
┌─────▼───────┐    ┌──────────────┐
│  查询优化器  │───▶│  trace记录   │
│             │    │  ·表访问方式 │
│  ·成本计算  │    │  ·索引选择   │
│  ·路径枚举  │    │  ·JOIN顺序   │
│  ·计划选择  │    │  ·成本计算   │
└─────┬───────┘    └──────────────┘
      │                    │
┌─────▼───────┐            │
│  执行计划    │            │
└─────────────┘            │
                           │
┌─────────────────────────▼┘
│     JSON格式输出
│  {
│    "steps": [...],
│    "join_optimization": {...},
│    "condition_filtering": {...}
│  }
└──────────────────────────
```

---

## 2. ⚙️ 优化器跟踪开启与配置


### 2.1 基础开启方法


**🔧 开启优化器跟踪**
```sql
-- 开启优化器跟踪
SET optimizer_trace="enabled=on,one_line=off";

-- 设置跟踪内存限制（避免过大的trace信息）
SET optimizer_trace_max_mem_size = 1048576; -- 1MB

-- 设置跟踪特性（可选）
SET optimizer_trace_features="greedy_search=on,range_optimizer=on,dynamic_range=on,repeated_subselect=on";

-- 验证设置
SELECT $$optimizer_trace;
SELECT $$optimizer_trace_max_mem_size;
```

### 2.2 跟踪参数详解


**📊 重要参数说明**

| 参数 | **默认值** | **作用** | **建议设置** |
|------|-----------|---------|-------------|
| `enabled` | `off` | `是否开启跟踪` | `on（调试时）` |
| `one_line` | `off` | `是否单行输出` | `off（便于阅读）` |
| `offset` | `-1` | `跟踪语句偏移` | `-1（所有语句）` |
| `limit` | `1` | `跟踪语句数量` | `1（单条分析）` |

**🔧 高级配置示例**
```sql
-- 详细跟踪配置
SET SESSION optimizer_trace="
    enabled=on,
    one_line=off,
    offset=-1,
    limit=1
";

-- 设置跟踪特性（控制跟踪内容）
SET SESSION optimizer_trace_features="
    greedy_search=on,        -- 贪心搜索算法
    range_optimizer=on,      -- 范围优化器
    dynamic_range=on,        -- 动态范围优化
    repeated_subselect=on    -- 重复子查询优化
";
```

### 2.3 跟踪会话管理


**💡 使用注意事项**
```sql
-- 跟踪只对当前会话有效
-- 执行完SQL后立即查看结果
SELECT query, trace FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

-- 关闭跟踪（重要！避免性能影响）
SET optimizer_trace="enabled=off";

-- 清理跟踪历史
SET optimizer_trace_offset=-1, optimizer_trace_limit=1;
```

---

## 3. 📋 跟踪信息结构分析


### 3.1 JSON格式跟踪结构 🔥


**🔸 trace信息总体结构**
```json
{
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "SELECT ..."
          },
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "...",
              "steps": [...]
            }
          }
        ]
      }
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "table_dependencies": [...]
          },
          {
            "rows_estimation": [...]
          },
          {
            "considered_execution_plans": [...]
          }
        ]
      }
    }
  ]
}
```

### 3.2 关键结构化分析 🔥


**🔸 主要分析阶段**
```
1. join_preparation（连接准备）
   ├── expanded_query（展开查询）
   ├── condition_processing（条件处理）
   └── table_dependencies（表依赖分析）

2. join_optimization（连接优化）
   ├── rows_estimation（行数估算）
   ├── considered_execution_plans（候选执行计划）
   └── best_access_path（最佳访问路径）

3. join_execution（连接执行）
   └── execution_details（执行细节）
```

**💻 实际案例分析**
```sql
-- 准备测试数据
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    city VARCHAR(30),
    INDEX idx_age (age),
    INDEX idx_city (city)
);

-- 开启跟踪
SET optimizer_trace="enabled=on";

-- 执行待分析的查询
SELECT * FROM users 
WHERE age > 25 AND city = 'Beijing' 
ORDER BY name LIMIT 10;

-- 查看跟踪结果
SELECT trace FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE\G
```

---

## 4. 💰 成本计算过程详解


### 4.1 成本计算模型


**🔸 MySQL成本计算公式**
```
总成本 = CPU成本 + IO成本

CPU成本 = 行数 × CPU成本常量
IO成本 = 页面数 × IO成本常量

默认成本常量：
• CPU_COST = 0.2（处理一行的CPU成本）
• IO_COST = 1.0（读取一个页面的IO成本）
```

**📊 成本计算示例分析**
```json
{
  "rows_estimation": [
    {
      "table": "users",
      "range_analysis": {
        "table_scan": {
          "rows": 100000,
          "cost": 20200.25
        },
        "potential_range_indexes": [
          {
            "index": "idx_age",
            "usable": true,
            "key_parts": ["age"],
            "ranges": ["25 < age"],
            "index_only": false,
            "rows": 25000,
            "cost": 5025.01
          },
          {
            "index": "idx_city", 
            "usable": true,
            "key_parts": ["city"],
            "ranges": ["city = 'Beijing'"],
            "index_only": false,
            "rows": 5000,
            "cost": 1005.00
          }
        ]
      }
    }
  ]
}
```

### 4.2 详细成本计算过程


**🔧 成本计算步骤解析**
```sql
-- 查看成本常量
SELECT * FROM mysql.server_cost;
SELECT * FROM mysql.engine_cost;

-- 计算示例：
-- 表扫描成本：
-- 总行数：100000
-- CPU成本：100000 × 0.2 = 20000
-- IO成本：估算页面数 × 1.0 ≈ 200.25
-- 总成本：20200.25

-- 索引扫描成本：
-- 索引行数：5000
-- CPU成本：5000 × 0.2 = 1000  
-- IO成本：索引页面数 × 1.0 ≈ 5.00
-- 总成本：1005.00
```

### 4.3 成本计算影响因素


**⚡ 影响成本计算的关键因素**
```
统计信息准确性：
• 表行数统计
• 索引基数统计
• 数据分布直方图

硬件配置：
• CPU性能
• 内存大小
• 存储类型（SSD/HDD）

查询特征：
• WHERE条件选择性
• JOIN表的大小
• ORDER BY和GROUP BY
```

---

## 5. 🎯 优化决策路径分析


### 5.1 计划选择依据


**🔸 优化器决策过程**
```json
{
  "considered_execution_plans": [
    {
      "plan_prefix": [],
      "table": "users",
      "best_access_path": {
        "considered_access_paths": [
          {
            "access_type": "ref",
            "index": "idx_city",
            "rows": 5000,
            "cost": 1005.00,
            "chosen": true,
            "cause": "cost"
          },
          {
            "access_type": "range", 
            "index": "idx_age",
            "rows": 25000,
            "cost": 5025.01,
            "chosen": false,
            "cause": "cost"
          },
          {
            "access_type": "scan",
            "rows": 100000,
            "cost": 20200.25,
            "chosen": false,
            "cause": "cost"
          }
        ]
      }
    }
  ]
}
```

### 5.2 优化路径可视化 🔥


**🎨 决策过程图解**
```
查询：WHERE age > 25 AND city = 'Beijing'

优化器分析路径：
┌─────────────────┐
│   全表扫描       │ 成本：20200.25
│   100000行      │ 
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  idx_age 扫描   │ 成本：5025.01
│   25000行       │
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  idx_city 扫描  │ 成本：1005.00  ✅ 最优
│   5000行        │
└─────────────────┘
         │
         ▼ 
┌─────────────────┐
│   最终执行计划   │
│ 使用 idx_city   │
│ 然后过滤 age    │
└─────────────────┘
```

### 5.3 复合条件优化分析


**🔧 多条件优化示例**
```sql
-- 复杂查询trace分析
SELECT u.name, u.age, o.order_date
FROM users u 
JOIN orders o ON u.id = o.user_id
WHERE u.age BETWEEN 25 AND 35 
  AND u.city = 'Shanghai'
  AND o.order_date >= '2024-01-01'
ORDER BY o.order_date DESC
LIMIT 20;

-- 查看JOIN优化过程
SELECT JSON_PRETTY(trace) FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE\G
```

**📋 JOIN优化决策过程**
```json
{
  "join_optimization": {
    "select#": 1,
    "steps": [
      {
        "join_order": [
          {
            "table": "users",
            "access_type": "ref",
            "key": "idx_city",
            "ref": ["const"],
            "rows": 5000,
            "cost": 1005.00
          },
          {
            "table": "orders", 
            "access_type": "ref",
            "key": "idx_user_id",
            "ref": ["u.id"],
            "rows": 3,
            "cost": 3.60
          }
        ],
        "total_cost": 1008.60,
        "chosen": true
      }
    ]
  }
}
```

---

## 6. 🔍 跟踪信息解读与诊断


### 6.1 调试诊断方法


**🛠️ 常见问题诊断流程**
```sql
-- 1. 基础信息收集
SHOW TABLE STATUS LIKE 'users';
SHOW INDEX FROM users;
ANALYZE TABLE users;

-- 2. 开启跟踪分析
SET optimizer_trace="enabled=on";
-- 执行问题SQL
SELECT * FROM users WHERE age = 30;

-- 3. 分析跟踪结果
SELECT 
  QUERY as original_query,
  JSON_PRETTY(TRACE) as trace_analysis
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE\G

-- 4. 关闭跟踪
SET optimizer_trace="enabled=off";
```

### 6.2 性能影响分析


**⚠️ trace性能开销评估**
```sql
-- 测试trace开销影响
-- 不开启trace的执行时间
SET optimizer_trace="enabled=off";
SELECT BENCHMARK(1000, (
  SELECT COUNT(*) FROM users WHERE age > 25
));

-- 开启trace的执行时间  
SET optimizer_trace="enabled=on";
SELECT BENCHMARK(1000, (
  SELECT COUNT(*) FROM users WHERE age > 25
));

-- 对比性能差异
-- 一般情况下trace会增加5-15%的开销
```

### 6.3 跟踪信息智能解析 🔑


**📊 关键指标提取**
```sql
-- 创建trace分析辅助函数
DELIMITER //
CREATE FUNCTION extract_trace_cost(trace_json JSON, path VARCHAR(255))
RETURNS DECIMAL(10,2)
READS SQL DATA
DETERMINISTIC
BEGIN
  RETURN JSON_UNQUOTE(JSON_EXTRACT(trace_json, path));
END //
DELIMITER ;

-- 使用示例
SELECT 
  QUERY,
  extract_trace_cost(TRACE, '$.steps[1].join_optimization.steps[2].considered_execution_plans[0].best_access_path.considered_access_paths[0].cost') as best_cost
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
```

---

## 7. 🛠️ 优化器trace工具实践


### 7.1 自动化诊断工具 🔥


**🔧 trace分析脚本**
```sql
-- 创建trace分析存储过程
DELIMITER //
CREATE PROCEDURE analyze_query_trace(IN sql_text TEXT)
BEGIN
  DECLARE trace_result JSON;
  
  -- 开启trace
  SET optimizer_trace="enabled=on,one_line=off";
  
  -- 执行查询（使用动态SQL）
  SET @sql = sql_text;
  PREPARE stmt FROM @sql;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;
  
  -- 获取trace结果
  SELECT TRACE INTO trace_result FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
  
  -- 解析关键信息
  SELECT 
    '=== 查询分析报告 ===' as report_section,
    sql_text as analyzed_query;
    
  SELECT 
    '表扫描成本' as metric_name,
    JSON_UNQUOTE(JSON_EXTRACT(trace_result, 
      '$.steps[1].join_optimization.steps[1].rows_estimation[0].range_analysis.table_scan.cost')) as value;
      
  SELECT 
    '最佳访问路径' as metric_name,
    JSON_UNQUOTE(JSON_EXTRACT(trace_result, 
      '$.steps[1].join_optimization.steps[2].considered_execution_plans[0].best_access_path.chosen_access_method.type')) as value;
  
  -- 关闭trace
  SET optimizer_trace="enabled=off";
END //
DELIMITER ;

-- 使用示例
CALL analyze_query_trace('SELECT * FROM users WHERE age > 25 AND city = "Beijing"');
```

### 7.2 跟踪数据可视化平台 🔑


**📊 trace数据挖掘分析**
```sql
-- 创建trace历史记录表
CREATE TABLE optimizer_trace_history (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  query_hash VARCHAR(32),
  original_query TEXT,
  trace_data JSON,
  execution_time DECIMAL(10,3),
  rows_examined BIGINT,
  rows_sent BIGINT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_query_hash (query_hash),
  INDEX idx_created_at (created_at)
);

-- 自动记录trace信息
DELIMITER //
CREATE TRIGGER trace_auto_record 
AFTER INSERT ON INFORMATION_SCHEMA.OPTIMIZER_TRACE
FOR EACH ROW
BEGIN
  INSERT INTO optimizer_trace_history (
    query_hash, 
    original_query, 
    trace_data
  ) VALUES (
    MD5(NEW.QUERY),
    NEW.QUERY,
    NEW.TRACE
  );
END //
DELIMITER ;
```

### 7.3 调试最佳实践 🔑


**✅ trace使用最佳实践**
```sql
-- 1. 标准trace分析流程
-- 准备阶段
SET optimizer_trace="enabled=on";
SET optimizer_trace_max_mem_size = 2097152; -- 2MB

-- 执行分析
-- (执行目标SQL)

-- 结果分析
SELECT 
  LEFT(QUERY, 100) as query_preview,
  CHAR_LENGTH(TRACE) as trace_size,
  JSON_VALID(TRACE) as trace_valid
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

-- 清理阶段  
SET optimizer_trace="enabled=off";

-- 2. 批量SQL分析模板
CREATE TEMPORARY TABLE sql_analysis_batch (
  id INT PRIMARY KEY AUTO_INCREMENT,
  sql_text TEXT,
  analysis_status VARCHAR(20) DEFAULT 'PENDING'
);

-- 插入待分析SQL
INSERT INTO sql_analysis_batch (sql_text) VALUES
('SELECT * FROM users WHERE age > 25'),
('SELECT u.*, o.* FROM users u JOIN orders o ON u.id = o.user_id'),
('SELECT COUNT(*) FROM users GROUP BY city');
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 trace系统本质：优化器决策过程的完整记录和分析工具
🔸 跟踪信息结构：JSON格式的结构化分析数据，包含完整优化流程
🔸 成本计算模型：CPU成本+IO成本的量化计算公式和影响因素
🔸 决策路径分析：从多个候选方案中选择最优执行计划的过程
🔸 诊断应用价值：发现优化器"错误"判断，为手动调优提供依据
```

### 8.2 关键理解要点


**🔹 trace系统的核心价值**
```
透明化决策：
• 让优化器的"黑盒"变成"白盒"
• 理解为什么选择了某个执行计划
• 发现统计信息不准确的问题

精准调优：
• 基于实际成本计算调整索引策略
• 针对性优化WHERE条件
• 合理设置优化器参数
```

**🔹 使用场景和时机**
```
适合使用trace的场景：
• 查询性能异常，需要深入分析
• 优化器选择了"错误"的执行计划
• 需要理解复杂JOIN的优化过程
• 评估新索引的效果

不适合的场景：
• 生产环境的高频查询（性能开销）
• 简单查询的日常监控
• 已经确定问题原因的情况
```

### 8.3 实际应用指导


**💡 trace分析工作流程**
```
步骤1：问题识别
• 通过监控发现性能问题SQL
• 使用EXPLAIN进行初步分析
• 确定需要深入分析的查询

步骤2：trace收集
• 在测试环境开启optimizer_trace
• 执行目标SQL收集trace信息
• 确保trace信息完整且有效

步骤3：结果分析
• 分析成本计算是否合理
• 检查统计信息是否准确
• 对比不同访问路径的成本

步骤4：优化实施
• 根据trace分析结果调整索引
• 修改SQL写法或添加hints
• 更新表统计信息
```

**🛠️ 实用工具和技巧**
- ✅ **JSON处理**：使用JSON_PRETTY()格式化输出
- ✅ **批量分析**：编写存储过程批量处理多个SQL
- ✅ **历史跟踪**：建立trace历史记录表分析趋势
- ✅ **可视化**：开发简单的Web界面展示trace结果
- ✅ **自动化**：结合性能监控自动触发trace分析

**⚠️ 注意事项**
- ⚠️ **性能影响**：trace会增加5-15%的执行开销
- ⚠️ **内存消耗**：复杂查询的trace信息可能很大
- ⚠️ **会话隔离**：trace只对当前会话有效
- ⚠️ **及时关闭**：分析完成后务必关闭trace功能

### 8.4 学习进阶路径


```
🔸 基础掌握：
• 理解trace基本概念和开启方法
• 学会读懂基本的JSON结构信息
• 掌握简单查询的trace分析

🔸 进阶应用：
• 分析复杂JOIN查询的优化过程
• 理解成本计算模型和影响因素
• 开发简单的trace分析工具

🔸 高级技能：
• 建立企业级trace分析平台
• 结合监控系统实现自动化诊断
• 深入研究优化器算法和改进方向
```

**核心记忆**：
- optimizer_trace是MySQL性能调优的"显微镜"
- 通过trace可以看清优化器的每一步决策过程
- 成本计算是优化器选择执行计划的核心依据
- 合理使用trace工具能显著提升SQL调优效率