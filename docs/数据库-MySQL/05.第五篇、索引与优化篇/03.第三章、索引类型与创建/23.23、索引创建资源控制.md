---
title: 23、索引创建资源控制
---
## 📚 目录

1. [索引创建资源控制基础](#1-索引创建资源控制基础)
2. [CPU资源限制机制](#2-CPU资源限制机制)
3. [内存使用控制策略](#3-内存使用控制策略)
4. [IO带宽限制管理](#4-IO带宽限制管理)
5. [创建优先级管理](#5-创建优先级管理)
6. [资源争用处理机制](#6-资源争用处理机制)
7. [系统负载控制方法](#7-系统负载控制方法)
8. [资源智能调度算法](#8-资源智能调度算法)
9. [创建过程资源监控](#9-创建过程资源监控)
10. [资源冲突解决策略](#10-资源冲突解决策略)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 💡 索引创建资源控制基础


### 1.1 为什么需要资源控制


**🔸 索引创建的资源消耗本质**
```
索引创建就像"建筑施工"，需要大量资源：
- CPU：数据排序、计算哈希值、构建B+树结构
- 内存：临时存储、排序缓存、索引页缓存  
- IO：读取原数据、写入索引文件、日志记录
- 时间：大表创建索引可能需要数小时

为什么要控制：
在生产环境中，索引创建可能影响正常业务
需要在索引创建效率和系统稳定性之间平衡
```

**💡 资源控制的核心目标**
```
主要目标：
1. 保证业务系统正常运行（优先级最高）
2. 合理利用系统资源提高创建效率
3. 避免资源争用导致的系统不稳定
4. 提供可预测的索引创建时间

实现方式：
- 限制索引创建使用的系统资源
- 动态调整创建过程中的资源分配
- 监控资源使用情况并及时调整
- 提供智能的资源调度策略
```

### 1.2 资源控制的基本分类


**📋 资源类型分类**
```
硬件资源：
• CPU使用率：控制索引创建的CPU占用
• 内存使用：限制排序和缓存使用的内存
• 磁盘IO：控制读写操作的频率和大小
• 网络带宽：主从复制时的网络资源

软件资源：
• 并发连接数：限制同时执行的索引创建任务
• 锁资源：控制表锁和行锁的使用
• 日志资源：控制redo log和binlog的写入速度
• 缓存资源：InnoDB缓冲池的使用分配

时间资源：
• 创建时间窗口：指定允许索引创建的时间段
• 优先级调度：高优先级任务先执行
• 暂停恢复：支持创建过程的暂停和恢复
```

### 1.3 MySQL索引创建模式


**🛠️ 索引创建模式对比**
```
在线创建（ALGORITHM=INPLACE）：
优势：不阻塞DML操作，用户可以正常读写
劣势：资源消耗大，创建时间长
适用：生产环境，大表索引创建

离线创建（ALGORITHM=COPY）：  
优势：创建速度快，资源利用充分
劣势：阻塞所有写操作，影响业务
适用：维护窗口，小表或不重要表

即时创建（ALGORITHM=INSTANT）：
优势：几乎无资源消耗，瞬间完成
劣势：只支持特定类型的索引操作
适用：添加虚拟列索引等特殊场景
```

---

## 2. 🔧 CPU资源限制机制


### 2.1 CPU使用率控制原理


**🔸 CPU资源控制的基本概念**
```
CPU控制就像"工厂的生产线调节"
原理：通过限制索引创建过程使用的CPU时间片
方法：降低创建进程优先级，增加休眠间隔
目标：确保其他业务进程有足够CPU资源
```

**⚙️ MySQL CPU控制参数**
```sql
-- 核心参数设置
SET GLOBAL innodb_ddl_threads = 2;           -- DDL操作线程数
SET GLOBAL innodb_parallel_read_threads = 4; -- 并行读线程数  
SET GLOBAL innodb_ddl_buffer_size = 1048576; -- DDL缓冲区大小

-- 查看当前设置
SHOW VARIABLES LIKE 'innodb_ddl%';
SHOW VARIABLES LIKE 'innodb_parallel_read%';
```

### 2.2 在线索引创建CPU控制


**💻 控制CPU使用的实际方法**
```sql
-- 方法1：调整并行度降低CPU使用
ALTER TABLE large_table 
ADD INDEX idx_status (status)
ALGORITHM=INPLACE, 
LOCK=NONE;

-- 在创建过程中监控CPU使用率
-- (在另一个连接中执行)
SELECT 
  PROCESSLIST_ID,
  PROCESSLIST_USER,
  PROCESSLIST_STATE,
  PROCESSLIST_INFO,
  PROCESSLIST_TIME
FROM performance_schema.threads 
WHERE PROCESSLIST_INFO LIKE '%ALTER TABLE%';

-- 方法2：分批创建索引
-- 创建多个较小的索引代替单个大索引
ALTER TABLE large_table ADD INDEX idx_date_part1 (date_column, status) WHERE status IN ('active', 'pending');
ALTER TABLE large_table ADD INDEX idx_date_part2 (date_column, status) WHERE status IN ('inactive', 'deleted');
```

### 2.3 CPU优先级调整


**⚡ 系统级CPU控制**
```bash
# Linux系统级控制索引创建进程
# 1. 找到MySQL进程ID
pgrep -f mysql

# 2. 降低MySQL进程优先级（仅在索引创建时）
renice +5 [mysql_pid]  # 降低优先级

# 3. 使用cpulimit限制CPU使用率
cpulimit -p [mysql_pid] -l 50  # 限制CPU使用率50%

# 4. 使用cgroup进行资源隔离
echo [mysql_pid] > /sys/fs/cgroup/cpu/mysql_ddl/tasks
echo 500000 > /sys/fs/cgroup/cpu/mysql_ddl/cpu.cfs_quota_us  # 限制50%CPU
```

**📊 CPU使用监控查询**
```sql
-- MySQL内部CPU使用监控
SELECT 
  EVENT_NAME,
  COUNT_STAR,
  SUM_TIMER_WAIT/1000000000 as total_time_sec,
  AVG_TIMER_WAIT/1000000000 as avg_time_sec
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%ddl%' OR EVENT_NAME LIKE '%index%'
ORDER BY SUM_TIMER_WAIT DESC;

-- 查看当前正在执行的索引创建
SELECT 
  ID,
  USER,
  HOST,
  DB,
  COMMAND,
  TIME,
  STATE,
  INFO
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE STATE LIKE '%index%' OR INFO LIKE '%ALTER%';
```

---

## 3. 💾 内存使用控制策略


### 3.1 内存控制的重要性


**🔸 内存使用控制原理**
```
索引创建的内存消耗主要来源：
1. 排序缓冲区：对数据进行排序时使用
2. 临时表空间：存储中间结果
3. InnoDB缓冲池：缓存数据页和索引页
4. 连接缓冲区：客户端连接使用的内存

内存控制目标：
- 防止索引创建耗尽系统内存
- 避免影响其他查询的性能
- 确保系统稳定运行
```

### 3.2 关键内存参数配置


**⚙️ 核心内存控制参数**
```sql
-- 排序相关内存参数
SET SESSION sort_buffer_size = 2097152;          -- 2MB排序缓冲
SET SESSION read_buffer_size = 1048576;          -- 1MB读缓冲
SET SESSION read_rnd_buffer_size = 524288;       -- 512KB随机读缓冲

-- InnoDB相关内存参数
SET GLOBAL innodb_sort_buffer_size = 1048576;    -- InnoDB排序缓冲
SET GLOBAL innodb_online_alter_log_max_size = 134217728;  -- 128MB在线DDL日志

-- 临时表内存限制
SET SESSION tmp_table_size = 67108864;           -- 64MB临时表大小
SET SESSION max_heap_table_size = 67108864;      -- 64MB堆表大小

-- 查看当前内存设置
SHOW VARIABLES WHERE Variable_name IN (
  'sort_buffer_size', 'innodb_sort_buffer_size', 
  'tmp_table_size', 'innodb_online_alter_log_max_size'
);
```

### 3.3 内存使用监控


**📊 内存使用实时监控**
```sql
-- 监控索引创建的内存使用
SELECT 
  EVENT_NAME,
  CURRENT_NUMBER_OF_BYTES_USED/1024/1024 as current_mb,
  HIGH_NUMBER_OF_BYTES_USED/1024/1024 as high_mb
FROM performance_schema.memory_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%sort%' 
   OR EVENT_NAME LIKE '%ddl%'
   OR EVENT_NAME LIKE '%alter%'
ORDER BY CURRENT_NUMBER_OF_BYTES_USED DESC;

-- InnoDB缓冲池使用情况
SELECT 
  POOL_ID,
  POOL_SIZE,
  FREE_BUFFERS,
  DATABASE_PAGES,
  OLD_DATABASE_PAGES,
  PAGES_MADE_YOUNG,
  PAGES_NOT_MADE_YOUNG
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;
```

### 3.4 内存优化策略


**🚀 内存使用优化方法**
```sql
-- 策略1：分阶段创建，减少内存峰值
-- 不要同时创建多个索引
ALTER TABLE large_table ADD INDEX idx_column1 (column1);  -- 先创建第一个
-- 等待完成后再创建下一个
ALTER TABLE large_table ADD INDEX idx_column2 (column2);

-- 策略2：调整缓冲区大小
-- 为索引创建临时调大排序缓冲区
SET SESSION sort_buffer_size = 8388608;  -- 临时调整为8MB
ALTER TABLE large_table ADD INDEX idx_complex (col1, col2, col3);
SET SESSION sort_buffer_size = 2097152;  -- 恢复默认值

-- 策略3：使用较小的批次大小
SET SESSION innodb_ddl_buffer_size = 524288;  -- 使用较小的DDL缓冲区
```

---

## 4. 📁 IO带宽限制管理


### 4.1 IO资源控制原理


**🔸 IO控制的重要性**
```
磁盘IO是索引创建的主要瓶颈：
- 读取原表数据：扫描整个表获取索引列数据
- 写入索引文件：将构建的索引写入磁盘
- 日志写入：记录DDL操作到redo log和binlog

IO控制目标：
• 避免索引创建占满磁盘带宽
• 确保正常查询和写入不受影响  
• 平衡创建速度和系统稳定性
```

### 4.2 InnoDB IO控制参数


**⚙️ 关键IO控制设置**
```sql
-- IO相关限制参数
SET GLOBAL innodb_io_capacity = 2000;           -- IOPS容量限制
SET GLOBAL innodb_io_capacity_max = 4000;       -- 最大IOPS限制
SET GLOBAL innodb_flush_log_at_trx_commit = 2;  -- 日志刷盘策略
SET GLOBAL innodb_flush_method = O_DIRECT;      -- 绕过OS缓存

-- 控制后台IO操作
SET GLOBAL innodb_lru_scan_depth = 1024;        -- LRU扫描深度
SET GLOBAL innodb_max_dirty_pages_pct = 75;     -- 脏页比例限制

-- 查看IO相关设置
SHOW VARIABLES WHERE Variable_name LIKE '%innodb_io%' 
                 OR Variable_name LIKE '%innodb_flush%';
```

### 4.3 IO使用监控


**📊 IO性能监控查询**
```sql
-- 监控文件IO统计
SELECT 
  FILE_NAME,
  EVENT_NAME,
  COUNT_READ,
  COUNT_WRITE,
  SUM_NUMBER_OF_BYTES_READ/1024/1024 as read_mb,
  SUM_NUMBER_OF_BYTES_WRITE/1024/1024 as write_mb
FROM performance_schema.file_summary_by_instance 
WHERE FILE_NAME LIKE '%ibd%'  -- InnoDB数据文件
ORDER BY SUM_NUMBER_OF_BYTES_WRITE DESC
LIMIT 10;

-- 等待事件IO分析
SELECT 
  EVENT_NAME,
  COUNT_STAR,
  SUM_TIMER_WAIT/1000000000 as total_wait_sec,
  AVG_TIMER_WAIT/1000000000 as avg_wait_sec
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%io%'
ORDER BY SUM_TIMER_WAIT DESC;
```

### 4.4 IO优化实践


**⚡ IO优化策略**
```sql
-- 策略1：调整IO参数适应索引创建
-- 创建索引前优化IO设置
SET GLOBAL innodb_io_capacity = 4000;        -- 临时提高IO容量
SET GLOBAL innodb_read_io_threads = 8;       -- 增加读IO线程
SET GLOBAL innodb_write_io_threads = 8;      -- 增加写IO线程

-- 执行索引创建
ALTER TABLE large_table 
ADD INDEX idx_composite (col1, col2, col3)
ALGORITHM=INPLACE, LOCK=NONE;

-- 创建完成后恢复设置
SET GLOBAL innodb_io_capacity = 2000;
SET GLOBAL innodb_read_io_threads = 4;
SET GLOBAL innodb_write_io_threads = 4;

-- 策略2：错峰执行（避开业务高峰期）
-- 使用事件调度器安排索引创建
SET GLOBAL event_scheduler = ON;

DELIMITER //
CREATE EVENT create_index_job
ON SCHEDULE AT '2025-09-05 02:00:00'  -- 凌晨2点执行
DO 
BEGIN
  ALTER TABLE large_table ADD INDEX idx_scheduled (column_name);
END //
DELIMITER ;
```

---

## 5. 🎯 创建优先级管理


### 5.1 优先级管理的概念


**🔸 为什么需要优先级管理**
```
优先级管理就像"医院急诊分诊"
目的：在多个索引创建任务时，决定执行顺序
依据：业务重要性、资源需求、紧急程度

优先级考虑因素：
• 业务重要性：核心业务表优先
• 表大小：小表优先完成，腾出资源
• 资源需求：低资源消耗的优先
• 时间窗口：有时限要求的优先
```

### 5.2 优先级分类策略


**📋 优先级分级体系**
```sql
-- 创建优先级管理表
CREATE TABLE index_creation_queue (
  id INT AUTO_INCREMENT PRIMARY KEY,
  table_name VARCHAR(64),
  index_definition TEXT,
  priority_level ENUM('urgent', 'high', 'normal', 'low'),
  estimated_time_minutes INT,
  resource_requirement ENUM('low', 'medium', 'high'),
  business_impact ENUM('critical', 'important', 'normal'),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  status ENUM('pending', 'running', 'completed', 'failed') DEFAULT 'pending'
);

-- 插入索引创建任务
INSERT INTO index_creation_queue (table_name, index_definition, priority_level, estimated_time_minutes, resource_requirement, business_impact) VALUES
('user_orders', 'ADD INDEX idx_order_date (order_date)', 'urgent', 30, 'medium', 'critical'),
('user_logs', 'ADD INDEX idx_action_type (action_type)', 'normal', 120, 'high', 'normal'),
('system_config', 'ADD INDEX idx_config_key (config_key)', 'high', 5, 'low', 'important');

-- 按优先级排序获取执行队列
SELECT * FROM index_creation_queue 
WHERE status = 'pending'
ORDER BY 
  CASE priority_level 
    WHEN 'urgent' THEN 1 
    WHEN 'high' THEN 2 
    WHEN 'normal' THEN 3 
    WHEN 'low' THEN 4 
  END,
  estimated_time_minutes ASC,  -- 相同优先级下，耗时短的优先
  created_at ASC;              -- 最后按创建时间排序
```

### 5.3 智能优先级算法


**🧠 综合优先级计算**
```sql
-- 创建优先级计算函数
DELIMITER //
CREATE FUNCTION calculate_priority_score(
  priority_level VARCHAR(10),
  business_impact VARCHAR(10),
  resource_requirement VARCHAR(10),
  estimated_time INT,
  table_size_gb DECIMAL(8,2)
) RETURNS DECIMAL(5,2)
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE priority_score DECIMAL(5,2) DEFAULT 0;
  
  -- 基础优先级分数
  CASE priority_level
    WHEN 'urgent' THEN SET priority_score = priority_score + 40;
    WHEN 'high' THEN SET priority_score = priority_score + 30;
    WHEN 'normal' THEN SET priority_score = priority_score + 20;
    WHEN 'low' THEN SET priority_score = priority_score + 10;
  END CASE;
  
  -- 业务影响加分
  CASE business_impact
    WHEN 'critical' THEN SET priority_score = priority_score + 20;
    WHEN 'important' THEN SET priority_score = priority_score + 15;
    WHEN 'normal' THEN SET priority_score = priority_score + 5;
  END CASE;
  
  -- 资源需求调整（需求低的优先）
  CASE resource_requirement
    WHEN 'low' THEN SET priority_score = priority_score + 10;
    WHEN 'medium' THEN SET priority_score = priority_score + 5;
    WHEN 'high' THEN SET priority_score = priority_score - 5;
  END CASE;
  
  -- 时间成本调整（时间短的优先）
  IF estimated_time <= 30 THEN 
    SET priority_score = priority_score + 10;
  ELSEIF estimated_time <= 120 THEN 
    SET priority_score = priority_score + 5;
  ELSE 
    SET priority_score = priority_score - 10;
  END IF;
  
  RETURN priority_score;
END //
DELIMITER ;

-- 使用智能优先级排序
SELECT 
  *,
  calculate_priority_score(
    priority_level, 
    business_impact, 
    resource_requirement, 
    estimated_time_minutes,
    (SELECT ROUND(DATA_LENGTH/1024/1024/1024, 2) 
     FROM INFORMATION_SCHEMA.TABLES 
     WHERE TABLE_NAME = index_creation_queue.table_name)
  ) as priority_score
FROM index_creation_queue 
WHERE status = 'pending'
ORDER BY priority_score DESC;
```

---

## 6. ⚔️ 资源争用处理机制


### 6.1 资源争用的识别


**🔸 什么是资源争用**
```
资源争用就像"多人抢同一个停车位"
表现：多个索引创建任务竞争相同的系统资源
后果：整体性能下降，创建时间延长，系统不稳定

常见争用场景：
• 同时在多个大表上创建索引
• 索引创建与数据导入同时进行
• 主从复制过程中的资源竞争
• 备份操作与索引创建的冲突
```

### 6.2 争用检测方法


**🔍 资源争用检测查询**
```sql
-- 检测当前活跃的DDL操作
SELECT 
  PROCESSLIST_ID,
  PROCESSLIST_USER,
  PROCESSLIST_HOST,
  PROCESSLIST_DB,
  PROCESSLIST_COMMAND,
  PROCESSLIST_TIME,
  PROCESSLIST_STATE,
  SUBSTRING(PROCESSLIST_INFO, 1, 100) as sql_text
FROM performance_schema.threads 
WHERE PROCESSLIST_COMMAND IN ('Query', 'Execute')
  AND (PROCESSLIST_INFO LIKE '%ALTER%' 
       OR PROCESSLIST_INFO LIKE '%CREATE INDEX%'
       OR PROCESSLIST_INFO LIKE '%DROP INDEX%')
ORDER BY PROCESSLIST_TIME DESC;

-- 检测锁争用情况
SELECT 
  waiting.processlist_id as waiting_pid,
  waiting.processlist_info as waiting_query,
  blocking.processlist_id as blocking_pid,
  blocking.processlist_info as blocking_query
FROM performance_schema.metadata_locks waiting
JOIN performance_schema.metadata_locks blocking 
  ON waiting.object_schema = blocking.object_schema 
  AND waiting.object_name = blocking.object_name
WHERE waiting.lock_status = 'PENDING' 
  AND blocking.lock_status = 'GRANTED';
```

### 6.3 争用解决策略


**🛠️ 资源争用处理方案**
```sql
-- 策略1：串行化执行（避免并发）
-- 创建索引管理存储过程
DELIMITER //
CREATE PROCEDURE execute_index_queue()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE task_id INT;
  DECLARE table_name VARCHAR(64);
  DECLARE index_sql TEXT;
  
  DECLARE queue_cursor CURSOR FOR 
    SELECT id, table_name, index_definition 
    FROM index_creation_queue 
    WHERE status = 'pending'
    ORDER BY priority_score DESC;
    
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
  
  OPEN queue_cursor;
  
  queue_loop: LOOP
    FETCH queue_cursor INTO task_id, table_name, index_sql;
    IF done THEN LEAVE queue_loop; END IF;
    
    -- 更新状态为执行中
    UPDATE index_creation_queue SET status = 'running' WHERE id = task_id;
    
    -- 执行索引创建（简化示例）
    SET @sql = CONCAT('ALTER TABLE ', table_name, ' ', index_sql);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 更新状态为完成
    UPDATE index_creation_queue SET status = 'completed' WHERE id = task_id;
    
  END LOOP;
  
  CLOSE queue_cursor;
END //
DELIMITER ;

-- 策略2：资源池管理
-- 限制同时执行的索引创建数量
SET @max_concurrent_ddl = 2;

SELECT 
  COUNT(*) as current_ddl_count,
  @max_concurrent_ddl as max_allowed,
  CASE 
    WHEN COUNT(*) >= @max_concurrent_ddl THEN '资源池已满，等待中'
    ELSE '可以执行新的索引创建'
  END as status
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE INFO LIKE '%ALTER%' AND COMMAND = 'Query';
```

---

## 7. ⚡ 系统负载控制方法


### 7.1 系统负载监控


**📊 负载监控指标**
```sql
-- 系统负载关键指标监控
SELECT 
  VARIABLE_NAME,
  VARIABLE_VALUE
FROM performance_schema.global_status 
WHERE VARIABLE_NAME IN (
  'Threads_running',        -- 正在运行的线程数
  'Threads_connected',      -- 连接线程数
  'Queries',               -- 总查询数
  'Handler_read_rnd_next', -- 随机读次数
  'Handler_write',         -- 写操作次数
  'Created_tmp_tables',    -- 临时表创建数
  'Sort_rows'              -- 排序行数
);

-- CPU和IO等待时间分析
SELECT 
  EVENT_NAME,
  COUNT_STAR,
  SUM_TIMER_WAIT/1000000000 as total_wait_seconds,
  AVG_TIMER_WAIT/1000000000 as avg_wait_seconds
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%cpu%' 
   OR EVENT_NAME LIKE '%io%'
   OR EVENT_NAME LIKE '%lock%'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

### 7.2 自适应负载控制


**🔄 动态负载调整**
```sql
-- 创建负载感知的索引创建存储过程
DELIMITER //
CREATE PROCEDURE adaptive_index_creation(
  IN target_table VARCHAR(64),
  IN index_sql TEXT
)
BEGIN
  DECLARE current_load DECIMAL(5,2);
  DECLARE max_load DECIMAL(5,2) DEFAULT 80.0;
  
  -- 简化的负载检测（实际应该更复杂）
  SELECT COUNT(*) * 10 INTO current_load
  FROM INFORMATION_SCHEMA.PROCESSLIST 
  WHERE COMMAND = 'Query' AND TIME > 5;
  
  -- 负载过高时等待
  WHILE current_load > max_load DO
    SELECT SLEEP(30); -- 等待30秒
    
    SELECT COUNT(*) * 10 INTO current_load
    FROM INFORMATION_SCHEMA.PROCESSLIST 
    WHERE COMMAND = 'Query' AND TIME > 5;
  END WHILE;
  
  -- 执行索引创建
  SET @ddl_sql = CONCAT('ALTER TABLE ', target_table, ' ', index_sql);
  PREPARE stmt FROM @ddl_sql;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;
  
END //
DELIMITER ;

-- 使用自适应创建
CALL adaptive_index_creation('user_orders', 'ADD INDEX idx_status (status)');
```

### 7.3 业务时间窗口控制


**⏰ 时间窗口管理**
```sql
-- 业务时间窗口检查函数
DELIMITER //
CREATE FUNCTION is_maintenance_window() 
RETURNS BOOLEAN
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE current_hour INT;
  DECLARE current_weekday INT;
  
  SELECT HOUR(NOW()) INTO current_hour;
  SELECT WEEKDAY(NOW()) INTO current_weekday;  -- 0=周一, 6=周日
  
  -- 维护窗口：工作日凌晨2-6点，周末全天
  IF (current_weekday < 5 AND current_hour BETWEEN 2 AND 6) 
     OR (current_weekday >= 5) THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END //
DELIMITER ;

-- 只在维护窗口执行索引创建
DELIMITER //
CREATE PROCEDURE safe_index_creation(
  IN target_table VARCHAR(64),
  IN index_sql TEXT
)
BEGIN
  IF is_maintenance_window() THEN
    SET @ddl_sql = CONCAT('ALTER TABLE ', target_table, ' ', index_sql);
    PREPARE stmt FROM @ddl_sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    SELECT 'Index created successfully' as result;
  ELSE
    INSERT INTO index_creation_queue (table_name, index_definition, priority_level)
    VALUES (target_table, index_sql, 'normal');
    SELECT 'Task queued for maintenance window' as result;
  END IF;
END //
DELIMITER ;
```

---

## 8. 🤖 资源智能调度算法


### 8.1 智能调度算法原理


**🔸 智能调度的核心思想**
```
智能调度就像"智能交通管制系统"
目标：根据实时情况动态调整资源分配
原理：监控系统状态，自动调整索引创建参数

调度考虑因素：
• 当前系统负载（CPU、内存、IO）
• 业务高峰期预测
• 索引创建任务的资源需求
• 历史创建时间统计
• 用户优先级设置
```

### 8.2 资源智能分配算法


**🧠 智能资源分配实现**
```sql
-- 创建资源状态监控表
CREATE TABLE system_resource_status (
  check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  cpu_usage_percent DECIMAL(5,2),
  memory_usage_percent DECIMAL(5,2),  
  io_wait_percent DECIMAL(5,2),
  active_connections INT,
  running_queries INT
);

-- 智能资源调度函数
DELIMITER //
CREATE FUNCTION get_optimal_ddl_settings(
  estimated_size_gb DECIMAL(8,2)
) RETURNS JSON
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE cpu_load DECIMAL(5,2);
  DECLARE memory_load DECIMAL(5,2);
  DECLARE io_load DECIMAL(5,2);
  DECLARE settings JSON;
  
  -- 获取当前系统负载（简化计算）
  SELECT COUNT(*) * 5 INTO cpu_load 
  FROM INFORMATION_SCHEMA.PROCESSLIST WHERE COMMAND = 'Query';
  
  -- 根据负载和表大小智能调整参数
  IF cpu_load < 30 AND estimated_size_gb < 1 THEN
    -- 低负载小表：使用较高资源
    SET settings = JSON_OBJECT(
      'ddl_threads', 4,
      'sort_buffer_size', 8388608,
      'io_capacity', 4000
    );
  ELSEIF cpu_load < 60 AND estimated_size_gb < 5 THEN
    -- 中负载中表：平衡设置
    SET settings = JSON_OBJECT(
      'ddl_threads', 2, 
      'sort_buffer_size', 4194304,
      'io_capacity', 2000
    );
  ELSE
    -- 高负载或大表：保守设置
    SET settings = JSON_OBJECT(
      'ddl_threads', 1,
      'sort_buffer_size', 2097152, 
      'io_capacity', 1000
    );
  END IF;
  
  RETURN settings;
END //
DELIMITER ;

-- 使用智能调度
SELECT get_optimal_ddl_settings(5.2) as recommended_settings;
```

### 8.3 自适应调度实现


**⚡ 自适应参数调整**
```sql
-- 自适应索引创建存储过程
DELIMITER //
CREATE PROCEDURE smart_index_creation(
  IN target_table VARCHAR(64),
  IN index_sql TEXT
)
BEGIN
  DECLARE optimal_settings JSON;
  DECLARE table_size_gb DECIMAL(8,2);
  
  -- 获取表大小
  SELECT ROUND(DATA_LENGTH/1024/1024/1024, 2) INTO table_size_gb
  FROM INFORMATION_SCHEMA.TABLES 
  WHERE TABLE_NAME = target_table;
  
  -- 获取最优设置
  SELECT get_optimal_ddl_settings(table_size_gb) INTO optimal_settings;
  
  -- 应用设置
  SET @ddl_threads = JSON_UNQUOTE(JSON_EXTRACT(optimal_settings, '$.ddl_threads'));
  SET @sort_buffer = JSON_UNQUOTE(JSON_EXTRACT(optimal_settings, '$.sort_buffer_size'));
  SET @io_capacity = JSON_UNQUOTE(JSON_EXTRACT(optimal_settings, '$.io_capacity'));
  
  -- 动态调整参数
  SET @sql1 = CONCAT('SET SESSION innodb_ddl_threads = ', @ddl_threads);
  PREPARE stmt1 FROM @sql1; EXECUTE stmt1; DEALLOCATE PREPARE stmt1;
  
  SET @sql2 = CONCAT('SET SESSION sort_buffer_size = ', @sort_buffer);
  PREPARE stmt2 FROM @sql2; EXECUTE stmt2; DEALLOCATE PREPARE stmt2;
  
  SET @sql3 = CONCAT('SET GLOBAL innodb_io_capacity = ', @io_capacity);
  PREPARE stmt3 FROM @sql3; EXECUTE stmt3; DEALLOCATE PREPARE stmt3;
  
  -- 执行索引创建
  SET @ddl_sql = CONCAT('ALTER TABLE ', target_table, ' ', index_sql);
  PREPARE stmt FROM @ddl_sql;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;
  
END //
DELIMITER ;
```

---

## 9. 📈 创建过程资源监控


### 9.1 实时资源监控


**🔍 实时监控指标**
```sql
-- 创建过程资源使用监控视图
CREATE VIEW index_creation_monitor AS
SELECT 
  -- 当前DDL操作信息
  p.ID,
  p.USER,
  p.HOST,
  p.DB,
  p.TIME as duration_seconds,
  p.STATE,
  SUBSTRING(p.INFO, 1, 100) as operation,
  
  -- 资源使用情况
  (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE COMMAND = 'Query') as active_queries,
  
  -- 内存使用（从性能模式获取）
  (SELECT SUM(CURRENT_NUMBER_OF_BYTES_USED)/1024/1024 
   FROM performance_schema.memory_summary_global_by_event_name 
   WHERE EVENT_NAME LIKE '%sort%') as sort_memory_mb,
   
  -- IO统计
  (SELECT SUM(COUNT_WRITE) 
   FROM performance_schema.file_summary_by_event_name 
   WHERE EVENT_NAME LIKE '%io%') as total_io_writes
   
FROM INFORMATION_SCHEMA.PROCESSLIST p
WHERE p.INFO LIKE '%ALTER%' OR p.INFO LIKE '%CREATE INDEX%';

-- 使用监控视图
SELECT * FROM index_creation_monitor;
```

### 9.2 历史监控数据收集


**📊 监控数据持久化**
```sql
-- 创建监控历史记录表
CREATE TABLE ddl_monitoring_history (
  id INT AUTO_INCREMENT PRIMARY KEY,
  table_name VARCHAR(64),
  operation_type VARCHAR(50),
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  duration_seconds INT,
  cpu_usage_avg DECIMAL(5,2),
  memory_peak_mb DECIMAL(8,2),
  io_operations_total BIGINT,
  final_status ENUM('success', 'failed', 'killed'),
  error_message TEXT
);

-- 监控数据收集存储过程
DELIMITER //
CREATE PROCEDURE log_ddl_monitoring(
  IN table_name VARCHAR(64),
  IN operation_type VARCHAR(50),
  IN start_time TIMESTAMP,
  IN end_time TIMESTAMP,
  IN final_status VARCHAR(20),
  IN error_message TEXT
)
BEGIN
  INSERT INTO ddl_monitoring_history (
    table_name, operation_type, start_time, end_time,
    duration_seconds, final_status, error_message
  ) VALUES (
    table_name, operation_type, start_time, end_time,
    TIMESTAMPDIFF(SECOND, start_time, end_time), final_status, error_message
  );
END //
DELIMITER ;
```

### 9.3 告警和通知机制


**🚨 资源告警设置**
```sql
-- 创建资源告警检查
DELIMITER //
CREATE PROCEDURE check_resource_alerts()
BEGIN
  DECLARE high_cpu_count INT DEFAULT 0;
  DECLARE long_running_ddl INT DEFAULT 0;
  DECLARE alert_message TEXT DEFAULT '';
  
  -- 检查CPU使用情况
  SELECT COUNT(*) INTO high_cpu_count
  FROM INFORMATION_SCHEMA.PROCESSLIST 
  WHERE COMMAND = 'Query' AND TIME > 300;  -- 超过5分钟的查询
  
  -- 检查长时间运行的DDL
  SELECT COUNT(*) INTO long_running_ddl
  FROM INFORMATION_SCHEMA.PROCESSLIST 
  WHERE (INFO LIKE '%ALTER%' OR INFO LIKE '%CREATE INDEX%') 
    AND TIME > 1800;  -- 超过30分钟的DDL
  
  -- 生成告警信息
  IF high_cpu_count > 5 THEN
    SET alert_message = CONCAT(alert_message, 'HIGH_CPU_USAGE: ', high_cpu_count, ' long queries; ');
  END IF;
  
  IF long_running_ddl > 0 THEN
    SET alert_message = CONCAT(alert_message, 'LONG_DDL_DETECTED: ', long_running_ddl, ' operations; ');
  END IF;
  
  -- 输出告警（实际环境中可以发送邮件或消息）
  IF LENGTH(alert_message) > 0 THEN
    SELECT CONCAT('ALERT: ', alert_message) as alert_info;
  ELSE
    SELECT 'System resource usage normal' as status;
  END IF;
  
END //
DELIMITER ;

-- 定期执行资源检查
SET GLOBAL event_scheduler = ON;

CREATE EVENT resource_alert_check
ON SCHEDULE EVERY 5 MINUTE
DO CALL check_resource_alerts();
```

---

## 10. 🛠️ 资源冲突解决策略


### 10.1 常见资源冲突场景


**⚠️ 资源冲突类型分析**
```
CPU冲突：
场景：多个大表同时创建索引
表现：系统响应缓慢，查询超时
影响：业务查询性能严重下降

内存冲突：
场景：索引创建+数据导入+大查询同时执行
表现：内存不足，使用交换空间
影响：整体系统性能急剧下降

IO冲突：
场景：索引创建+备份+日志轮转同时进行
表现：磁盘IO饱和，操作响应慢
影响：所有数据库操作都变慢

锁冲突：
场景：在线DDL与业务写操作争抢锁资源
表现：大量锁等待，事务回滚
影响：业务功能异常
```

### 10.2 冲突检测机制


**🔍 自动冲突检测**
```sql
-- 创建资源冲突检测函数
DELIMITER //
CREATE FUNCTION detect_resource_conflict() 
RETURNS JSON
READS SQL DATA
DETERMINISTIC
BEGIN
  DECLARE conflict_info JSON DEFAULT JSON_OBJECT();
  DECLARE cpu_conflict BOOLEAN DEFAULT FALSE;
  DECLARE memory_conflict BOOLEAN DEFAULT FALSE;
  DECLARE io_conflict BOOLEAN DEFAULT FALSE;
  DECLARE lock_conflict BOOLEAN DEFAULT FALSE;
  
  -- CPU冲突检测
  IF (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE TIME > 60) > 10 THEN
    SET cpu_conflict = TRUE;
  END IF;
  
  -- 内存冲突检测（简化）
  IF (SELECT COUNT(*) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE STATE LIKE '%Sorting%') > 5 THEN
    SET memory_conflict = TRUE;
  END IF;
  
  -- 锁冲突检测
  IF (SELECT COUNT(*) FROM performance_schema.metadata_locks WHERE LOCK_STATUS = 'PENDING') > 0 THEN
    SET lock_conflict = TRUE;
  END IF;
  
  -- 构建冲突报告
  SET conflict_info = JSON_OBJECT(
    'cpu_conflict', cpu_conflict,
    'memory_conflict', memory_conflict, 
    'io_conflict', io_conflict,
    'lock_conflict', lock_conflict,
    'safe_to_create_index', NOT (cpu_conflict OR memory_conflict OR io_conflict OR lock_conflict)
  );
  
  RETURN conflict_info;
END //
DELIMITER ;

-- 使用冲突检测
SELECT detect_resource_conflict() as conflict_status;
```

### 10.3 冲突解决策略


**🛡️ 冲突处理方案**
```sql
-- 策略1：智能等待和重试
DELIMITER //
CREATE PROCEDURE conflict_aware_index_creation(
  IN target_table VARCHAR(64),
  IN index_sql TEXT,
  IN max_retries INT DEFAULT 3
)
BEGIN
  DECLARE retry_count INT DEFAULT 0;
  DECLARE conflict_status JSON;
  DECLARE is_safe BOOLEAN;
  
  retry_loop: LOOP
    -- 检测冲突状态
    SELECT detect_resource_conflict() INTO conflict_status;
    SELECT JSON_UNQUOTE(JSON_EXTRACT(conflict_status, '$.safe_to_create_index')) = 'true' INTO is_safe;
    
    IF is_safe THEN
      -- 安全状态，执行创建
      SET @ddl_sql = CONCAT('ALTER TABLE ', target_table, ' ', index_sql);
      PREPARE stmt FROM @ddl_sql;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
      
      SELECT 'Index created successfully' as result;
      LEAVE retry_loop;
      
    ELSEIF retry_count >= max_retries THEN
      -- 超过重试次数
      SELECT 'Max retries reached, index creation postponed' as result;
      LEAVE retry_loop;
      
    ELSE
      -- 等待并重试
      SELECT SLEEP(60);  -- 等待1分钟
      SET retry_count = retry_count + 1;
    END IF;
    
  END LOOP;
END //
DELIMITER ;

-- 策略2：降级执行
-- 根据冲突情况自动调整创建参数
DELIMITER //
CREATE PROCEDURE degraded_index_creation(
  IN target_table VARCHAR(64),
  IN index_sql TEXT
)
BEGIN
  DECLARE conflict_info JSON;
  
  SELECT detect_resource_conflict() INTO conflict_info;
  
  -- 根据冲突类型调整参数
  IF JSON_EXTRACT(conflict_info, '$.cpu_conflict') = true THEN
    SET SESSION innodb_ddl_threads = 1;       -- 降低并行度
    SELECT 'CPU conflict detected, using single thread' as adjustment;
  END IF;
  
  IF JSON_EXTRACT(conflict_info, '$.memory_conflict') = true THEN
    SET SESSION sort_buffer_size = 1048576;   -- 降低内存使用
    SELECT 'Memory conflict detected, reducing buffer size' as adjustment;
  END IF;
  
  IF JSON_EXTRACT(conflict_info, '$.io_conflict') = true THEN
    SET GLOBAL innodb_io_capacity = 500;      -- 降低IO强度
    SELECT 'IO conflict detected, reducing IO capacity' as adjustment;
  END IF;
  
  -- 执行创建
  SET @ddl_sql = CONCAT('ALTER TABLE ', target_table, ' ', index_sql);
  PREPARE stmt FROM @ddl_sql;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;
  
END //
DELIMITER ;
```

### 10.4 冲突预防措施


**🔒 预防性资源管理**
```sql
-- 创建资源预留机制
CREATE TABLE resource_reservations (
  id INT AUTO_INCREMENT PRIMARY KEY,
  operation_type VARCHAR(50),
  reserved_cpu_percent DECIMAL(5,2),
  reserved_memory_mb INT,
  reserved_io_capacity INT,
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  status ENUM('active', 'completed', 'cancelled') DEFAULT 'active'
);

-- 资源预留函数
DELIMITER //
CREATE PROCEDURE reserve_resources_for_ddl(
  IN operation_desc VARCHAR(50),
  IN duration_minutes INT,
  IN cpu_percent DECIMAL(5,2),
  IN memory_mb INT
)
BEGIN
  INSERT INTO resource_reservations (
    operation_type, reserved_cpu_percent, reserved_memory_mb,
    start_time, end_time
  ) VALUES (
    operation_desc, cpu_percent, memory_mb,
    NOW(), DATE_ADD(NOW(), INTERVAL duration_minutes MINUTE)
  );
  
  SELECT LAST_INSERT_ID() as reservation_id;
END //
DELIMITER ;

-- 使用资源预留
CALL reserve_resources_for_ddl('large_table_index_creation', 120, 50.0, 2048);
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


**🔸 资源控制基础理解**
```
索引创建资源消耗：
• CPU：数据排序、B+树构建、哈希计算
• 内存：排序缓冲、临时存储、缓存管理
• IO：数据读取、索引写入、日志记录
• 时间：大表索引创建可能需要数小时

资源控制目标：
• 保证业务系统正常运行（最高优先级）
• 合理利用系统资源提高效率
• 避免资源争用导致系统不稳定
• 提供可预测的创建时间
```

**🔸 控制机制分类**
```
硬件资源控制：
• CPU使用率限制：调整并行线程数
• 内存使用控制：限制缓冲区大小
• IO带宽限制：控制读写操作频率

软件资源管理：
• 优先级管理：业务重要性决定执行顺序
• 争用处理：检测并解决资源竞争
• 负载控制：根据系统负载动态调整

智能调度：
• 自适应算法：根据实时状态调整参数
• 监控反馈：持续监控并优化资源分配
• 冲突解决：自动检测和处理资源冲突
```

### 11.2 关键理解要点


**🔹 资源控制的层次性**
```
系统级控制：
• 操作系统层面的CPU、内存、IO限制
• 使用cgroup、nice、cpulimit等工具
• 影响整个MySQL实例

MySQL级控制：
• 通过MySQL参数控制资源使用
• innodb_ddl_threads、sort_buffer_size等
• 只影响MySQL内部资源分配

会话级控制：
• 针对单个连接的资源限制
• SET SESSION方式调整参数
• 影响当前会话的操作

任务级控制：
• 针对具体索引创建任务的控制
• 通过存储过程和函数实现
• 最细粒度的资源管理
```

**🔹 智能调度的核心算法**
```
调度决策因素：
1. 系统实时负载状态
2. 业务优先级设置
3. 索引创建资源需求估算
4. 历史性能数据分析
5. 用户定义的约束条件

调度策略：
• 负载低时：提高资源分配，加速创建
• 负载高时：降低资源使用，保证业务
• 冲突时：暂停或延迟低优先级任务
• 异常时：自动调整参数或中止操作

算法优势：
• 自动化：减少人工干预需求
• 智能化：基于实时状态决策
• 平衡性：兼顾效率和稳定性
```

**🔹 监控和预防的重要性**
```
实时监控价值：
• 及时发现资源使用异常
• 预测索引创建完成时间
• 为调度算法提供数据基础
• 支持故障排查和性能优化

预防措施：
• 资源预留：避免资源冲突
• 时间窗口：在低峰期执行DDL
• 分批执行：避免资源集中消耗
• 参数优化：根据硬件配置调整
```

### 11.3 实际应用指导


**💼 生产环境最佳实践**
```
资源控制策略：
✅ 建立索引创建的标准流程
✅ 设置合理的资源使用上限
✅ 实施监控和告警机制
✅ 准备资源冲突的应急预案

时间安排：
✅ 优先在业务低峰期创建索引
✅ 大表索引分多个维护窗口完成
✅ 关键索引预留足够时间窗口
✅ 建立索引创建时间预估模型

风险控制：
✅ 在测试环境先验证资源消耗
✅ 准备索引创建的回滚方案
✅ 监控创建过程中的系统健康状态
✅ 建立紧急情况下的中止机制
```

### 11.4 故障排查和应急处理


**🔧 常见问题处理**
```
问题1：索引创建导致系统负载过高
解决步骤：
1. 立即检查当前DDL操作：SHOW PROCESSLIST
2. 评估是否需要中止：KILL QUERY [process_id]
3. 调整资源参数后重新执行
4. 考虑分批或延期执行

问题2：内存不足导致创建失败
解决方案：
1. 降低sort_buffer_size等内存参数
2. 停止非必要的其他操作
3. 增加系统虚拟内存（临时）
4. 分批创建复合索引

问题3：IO饱和影响业务
解决方案：
1. 降低innodb_io_capacity参数
2. 暂停索引创建等待IO降低
3. 优化其他IO密集操作
4. 考虑使用SSD提升IO性能
```

**⚠️ 应急处理清单**
```
紧急情况处理：
🚨 系统负载过高：
  - 检查正在执行的DDL操作
  - 评估中止的业务影响
  - 必要时中止操作并重新安排

🚨 内存使用告警：
  - 立即检查内存消耗大户
  - 调整相关缓冲区参数
  - 考虑重启MySQL释放内存

🚨 IO性能急剧下降：
  - 检查IO密集操作
  - 调整IO相关参数
  - 暂停非关键操作

🚨 业务查询超时：
  - 确认是否由索引创建导致
  - 评估继续创建的风险
  - 必要时中止并延期执行
```

**🧠 核心记忆要点**
```
资源控制要点：
"监控为先，预防为主，智能调度，平衡发展"

参数调优口诀：
"CPU靠线程数，内存看缓冲，IO调容量，负载要均衡"

冲突处理原则：
"业务优先，安全第一，智能调整，有序恢复"

最佳实践总结：
"测试验证，分批执行，实时监控，应急预案"
```

**🎯 实际应用价值**
- **生产稳定性**：避免索引创建影响正常业务
- **效率提升**：通过智能调度提高创建效率
- **成本控制**：合理利用硬件资源，降低运维成本
- **风险管理**：提供完整的监控和应急处理机制
- **自动化运维**：减少人工干预，提高运维效率