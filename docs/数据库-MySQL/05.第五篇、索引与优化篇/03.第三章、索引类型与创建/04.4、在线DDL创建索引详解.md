---
title: 4、在线DDL创建索引详解
---
## 📚 目录

1. [在线DDL基本概念](#1-在线ddl基本概念)
2. [Online DDL实现原理](#2-online-ddl实现原理)
3. [ALGORITHM与LOCK参数详解](#3-algorithm与lock参数详解)
4. [变更日志row log机制](#4-变更日志row-log机制)
5. [DDL阶段锁级别分析](#5-ddl阶段锁级别分析)
6. [并发DML影响处理](#6-并发dml影响处理)
7. [DDL进度监控方法](#7-ddl进度监控方法)
8. [性能影响评估与优化](#8-性能影响评估与优化)
9. [故障恢复与最佳实践](#9-故障恢复与最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🚀 在线DDL基本概念


### 1.1 什么是在线DDL


**🔸 传统DDL的痛点**
```
传统索引创建过程：
用户请求 ──X──→ 应用服务器 ──X──→ MySQL数据库
                                  (表被锁定)
结果：业务完全中断，用户无法访问
```

在传统方式下，创建索引时MySQL会**锁住整张表**，这意味着：
- 📛 **业务中断**：所有对该表的读写操作都被阻塞
- ⏰ **时间漫长**：大表创建索引可能需要几个小时
- 💔 **用户体验差**：网站/应用完全不可用

**🔸 在线DDL的解决方案**
```
在线DDL创建过程：
用户请求 ───✅───→ 应用服务器 ───✅───→ MySQL数据库
                                    (索引后台创建)
结果：业务正常运行，索引静悄悄创建完成
```

**在线DDL**就是让MySQL在**不影响业务**的情况下，在后台创建索引：
- ✅ **业务无感**：用户可以正常读写数据
- ⚡ **性能可控**：可以控制对业务性能的影响程度
- 🛡️ **风险可控**：可以随时监控和中止操作

### 1.2 在线DDL的核心价值


**🎯 业务价值**
```
传统方式影响：
📈 大表(1亿行) 创建索引需要2小时
💸 2小时业务中断 = 损失数百万营收
😱 用户投诉和品牌影响

在线DDL价值：  
📊 同样索引创建，业务正常运行
💰 零营收损失
😊 用户无感知，体验良好
```

---

## 2. ⚙️ Online DDL实现原理


### 2.1 在线DDL整体架构


**🔸 核心工作原理**
```
在线DDL三阶段模型：

阶段1: 准备阶段(Prepare)
┌─────────────────────┐
│  获取元数据锁        │ ← 短暂锁定，准备工作
│  创建临时中间表      │
└─────────────────────┘
           ↓
阶段2: 执行阶段(Execute)  
┌─────────────────────┐
│  并发读写业务        │ ← 业务正常进行
│        +            │
│  后台构建索引        │ ← MySQL后台工作
│        +            │  
│  记录变更日志        │ ← 保存并发变更
└─────────────────────┘
           ↓
阶段3: 提交阶段(Commit)
┌─────────────────────┐
│  短暂锁表           │ ← 再次短暂锁定  
│  应用变更日志        │
│  切换到新表定义      │
└─────────────────────┘
```

这个设计非常巧妙：把原本需要全程锁表的操作，变成了**只在开始和结束时短暂锁表**。

### 2.2 ALGORITHM算法类型


**🔸 三种算法对比**

| **算法类型** | **工作方式** | **业务影响** | **适用场景** |
|-------------|-------------|-------------|-------------|
| **`COPY`** | 创建新表，复制所有数据 | 🔴 长时间锁表 | 复杂DDL操作 |
| **`INPLACE`** | 原表上直接修改 | 🟡 短暂锁表 | 大部分DDL操作 |
| **`INSTANT`** | 仅修改元数据 | 🟢 几乎无影响 | 简单操作(如加列) |

**具体算法选择示例**
```sql
-- MySQL自动选择最优算法
ALTER TABLE users ADD INDEX idx_email (email);

-- 强制指定INPLACE算法(推荐)
ALTER TABLE users ADD INDEX idx_email (email), 
ALGORITHM=INPLACE;

-- 如果不支持INPLACE就失败，不要降级到COPY
ALTER TABLE users ADD INDEX idx_email (email), 
ALGORITHM=INPLACE, LOCK=NONE;
```

### 2.3 LOCK锁定级别


**🔸 四种锁定级别**

```
LOCK=NONE     ← 最理想：完全不影响业务
    ↓
LOCK=SHARED   ← 允许读，禁止写
    ↓  
LOCK=DEFAULT  ← MySQL自动选择
    ↓
LOCK=EXCLUSIVE ← 最严格：完全锁表
```

**详细说明**：

**`LOCK=NONE`（推荐）**
```
含义：DDL期间允许并发读写
适用：大部分索引创建操作
限制：某些复杂DDL不支持
```

**`LOCK=SHARED`**
```
含义：DDL期间允许读，禁止写
适用：需要保证数据一致性的操作
影响：写操作会被阻塞
```

**实际使用建议**
```sql
-- 生产环境推荐写法
ALTER TABLE large_table ADD INDEX idx_name (name),
ALGORITHM=INPLACE,     -- 强制使用在线算法
LOCK=NONE;             -- 强制无锁模式

-- 如果上述失败，说明该操作不支持真正的在线DDL
```

---

## 3. 📝 变更日志row log机制


### 3.1 row log是什么


**🔸 变更日志的作用**
```
问题：索引创建期间，业务还在修改数据，怎么保证一致性？
解决：用row log记录所有并发的数据变更
```

想象一下这个场景：
- 你正在整理一堆文件并建立目录索引
- 同时还有人在这堆文件里添加新文件、删除旧文件
- 你需要记录下这些变化，最后统一更新到索引里

**row log就是这个"变化记录本"**。

### 3.2 row log工作流程


**🔸 详细工作过程**
```
时间轴：DDL开始 ────────────────────→ DDL结束

并发业务：INSERT/UPDATE/DELETE ←→ row log记录
            ↓                      ↓
         正常执行                记录到日志

后台工作：     构建索引 ──→ 应用row log ──→ 完成
                ↓              ↓
            扫描原始数据      应用变更日志
```

**具体示例**：
```sql
-- 假设DDL开始时表有100万行数据
ALTER TABLE orders ADD INDEX idx_status (status);

-- DDL执行期间，业务继续运行：
INSERT INTO orders VALUES (1000001, 'pending');  -- 记录到row log
UPDATE orders SET status='completed' WHERE id=500000;  -- 记录到row log
DELETE FROM orders WHERE id=10;  -- 记录到row log

-- DDL完成过程：
-- 1. 为原始100万行数据创建索引
-- 2. 应用row log中记录的3个变更操作  
-- 3. 新索引包含所有最新数据
```

### 3.3 row log存储与限制


**🔸 存储机制**
```
row log位置：
├── 内存缓冲：优先存储在内存中
├── 磁盘文件：内存不足时写入临时文件
└── 大小限制：受innodb_online_alter_log_max_size参数控制

默认配置：
innodb_online_alter_log_max_size = 128MB
含义：row log最大128MB，超过则DDL失败
```

> ⚠️ **重要注意**
> 
> 如果DDL期间并发修改太多，row log超过限制大小，**整个DDL会失败**！这就是为什么要在业务低峰期做DDL的原因。

### 3.4 row log性能影响


**🔸 性能影响分析**
```
正面影响：✅
├── 业务可以继续运行  
├── 没有表锁阻塞
└── 用户体验良好

负面影响：⚠️
├── 额外IO开销：记录row log
├── 内存消耗：缓存变更日志
├── CPU开销：并发处理DDL和DML
└── 磁盘空间：临时文件存储
```

---

## 4. 🔒 DDL阶段锁级别分析


### 4.1 DDL三阶段锁机制


**🔸 详细锁定过程**
```
阶段锁定时间轴：

准备阶段 (1-2秒)：
┌─────────────────────────┐
│     获取排他锁 (X锁)     │ ← 阻塞所有读写
│   ✓ 创建临时表结构       │
│   ✓ 准备row log        │  
└─────────────────────────┘

执行阶段 (几分钟到几小时)：
┌─────────────────────────┐  
│    释放排他锁，允许DML   │ ← 业务正常进行
│   ✓ 后台构建索引        │   并发读写OK
│   ✓ 记录并发变更        │
└─────────────────────────┘

提交阶段 (1-2秒)：
┌─────────────────────────┐
│     重新获取排他锁       │ ← 再次短暂阻塞
│   ✓ 应用row log变更     │
│   ✓ 替换表定义          │
└─────────────────────────┘
```

**关键理解**：虽然叫"在线DDL"，但实际上在开始和结束时还是会**短暂锁表**，只是锁定时间从几小时缩短到几秒钟。

### 4.2 不同DDL操作的锁级别


**🔸 常见DDL操作锁定情况**

| **DDL操作** | **算法** | **锁级别** | **影响时间** |
|-----------|---------|----------|-------------|
| **添加索引** | `INPLACE` | `NONE` | 几秒锁定 |
| **删除索引** | `INPLACE` | `NONE` | 瞬间完成 |
| **添加列(末尾)** | `INSTANT` | `NONE` | 毫秒级 |
| **修改列类型** | `COPY` | `EXCLUSIVE` | 全程锁定 |
| **添加主键** | `INPLACE` | `SHARED` | 允许读 |

### 4.3 锁等待与超时处理


**🔸 锁等待问题**
```
常见场景：
长事务正在运行 ──→ DDL无法获取锁 ──→ DDL等待
    ↓                   ↓              ↓
  用户查询持续          其他查询堆积     系统响应变慢

解决方案：
1. 检查长事务：SHOW PROCESSLIST;
2. 设置锁等待超时：lock_wait_timeout = 60
3. 业务低峰期执行DDL
```

**实用的DDL执行策略**
```sql
-- 设置锁等待超时，避免无限等待
SET SESSION lock_wait_timeout = 60;

-- 执行DDL，如果60秒内获取不到锁就失败
ALTER TABLE orders ADD INDEX idx_create_time (create_time),
ALGORITHM=INPLACE, LOCK=NONE;
```

---

## 5. 🔄 并发DML影响处理


### 5.1 DML并发处理机制


**🔸 并发处理架构**
```
DDL执行期间的并发处理：

┌─────────────────┐    ┌─────────────────┐
│   业务线程1     │───→│   正常执行DML    │
│   (INSERT/UPDATE)│    │   记录到row log  │
└─────────────────┘    └─────────────────┘
                              ↓
┌─────────────────┐    ┌─────────────────┐  
│   业务线程2     │───→│   正常执行DML    │
│   (SELECT/DELETE)│    │   记录到row log  │
└─────────────────┘    └─────────────────┘
                              ↓
┌─────────────────┐    ┌─────────────────┐
│   DDL线程       │───→│   构建索引      │
│                │    │   + 处理row log  │
└─────────────────┘    └─────────────────┘
```

### 5.2 不同DML操作的处理


**🔸 INSERT操作处理**
```
INSERT处理流程：
1. 正常插入数据到原表
2. 记录插入操作到row log  
3. DDL最后阶段将新数据也加入索引

示例：
CREATE INDEX时插入新订单 → 
新订单记录到row log → 
索引创建完成后补充新订单的索引项
```

**🔸 UPDATE操作处理**
```
UPDATE处理流程：
1. 正常更新原表数据
2. 记录更新前后值到row log
3. DDL结束时在新索引中反映这些更新

示例：
CREATE INDEX时更新订单状态 →
记录状态变化到row log →  
新索引反映最新的订单状态
```

**🔸 DELETE操作处理**
```
DELETE处理流程：
1. 正常删除原表数据
2. 记录删除操作到row log
3. 确保新索引中不包含已删除数据

示例：
CREATE INDEX时删除过期订单 →
记录删除操作到row log →
新索引中不包含已删除订单
```

### 5.3 并发控制的性能考虑


**🔸 性能影响评估**
```
正常情况(无DDL)：
DML性能：100%
系统负载：正常

DDL执行期间：
DML性能：85-95% (轻微下降)
系统负载：中等增加
额外开销：
├── row log记录：5-10% CPU开销
├── 索引构建：20-30% IO开销  
└── 内存使用：临时缓冲区
```

---

## 6. 📊 DDL进度监控方法


### 6.1 实时监控DDL进度


**🔸 monitoring table方法**
```sql
-- 查看DDL执行进度
SELECT 
  EVENT_NAME,
  WORK_COMPLETED,
  WORK_ESTIMATED,
  ROUND(WORK_COMPLETED/WORK_ESTIMATED*100, 2) AS '完成百分比%'
FROM performance_schema.events_stages_current 
WHERE EVENT_NAME LIKE 'stage/innodb/alter%';
```

**🔸 进度监控脚本**
```bash
#!/bin/bash
# DDL进度监控脚本

while true; do
  echo "=== $(date) ==="
  mysql -e "
    SELECT 
      EVENT_NAME,
      WORK_COMPLETED,
      WORK_ESTIMATED,
      CONCAT(ROUND(WORK_COMPLETED/WORK_ESTIMATED*100, 2), '%') AS PROGRESS
    FROM performance_schema.events_stages_current 
    WHERE EVENT_NAME LIKE 'stage/innodb/alter%';
  "
  sleep 10
done
```

### 6.2 系统资源监控


**🔸 关键监控指标**
```
CPU使用率：
├── DDL通常消耗20-40% CPU
├── 超过50%需要考虑调整
└── 监控命令：top, htop

磁盘IO：  
├── 读IO：扫描原表数据
├── 写IO：创建新索引文件
└── 监控命令：iostat, iotop

内存使用：
├── row log缓冲区
├── 索引构建缓冲区  
└── 监控命令：free, vmstat

网络连接：
├── 业务连接数变化
├── 连接等待情况
└── 监控：SHOW PROCESSLIST
```

**简单监控命令组合**
```bash
# 一键查看系统状态
echo "=== CPU ===" && top -bn1 | head -5
echo "=== 磁盘IO ===" && iostat -x 1 1
echo "=== MySQL连接 ===" && mysql -e "SHOW STATUS LIKE 'Threads_%';"
echo "=== DDL进度 ===" && mysql -e "上面的DDL进度查询SQL"
```

### 6.3 业务影响监控


**🔸 业务指标监控**
```sql
-- 监控查询响应时间变化
SELECT 
  ROUND(AVG_TIMER_WAIT/1000000000000, 6) as '平均响应时间(秒)',
  COUNT_STAR as '查询次数'
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%your_table%'
ORDER BY AVG_TIMER_WAIT DESC LIMIT 10;

-- 监控锁等待情况  
SELECT * FROM performance_schema.data_locks 
WHERE OBJECT_NAME = 'your_table';
```

---

## 7. 🎯 性能影响评估与优化


### 7.1 在线DDL性能预测模型


**🔸 性能预测公式**
```
DDL完成时间预估：

基础时间 = 表大小(GB) / 磁盘读取速度(GB/s)
额外开销 = 并发DML数量 × 影响系数
总时间 = 基础时间 × (1 + 额外开销)

示例计算：
表大小：100GB
磁盘速度：100MB/s = 0.1GB/s  
基础时间：100GB / 0.1GB/s = 1000秒 ≈ 17分钟

如果并发修改较多：
预计总时间：17分钟 × 1.3 = 22分钟
```

### 7.2 在线DDL资源调度优化


**🔸 系统参数优化**
```sql
-- 增加row log缓冲区大小
SET GLOBAL innodb_online_alter_log_max_size = 1024*1024*1024; -- 1GB

-- 调整IO线程数量  
SET GLOBAL innodb_read_io_threads = 8;
SET GLOBAL innodb_write_io_threads = 8;

-- 优化缓冲池
SET GLOBAL innodb_buffer_pool_size = 8*1024*1024*1024; -- 8GB
```

**🔸 执行时机优化**
```
最佳执行时间：
✅ 凌晨2-6点：业务低峰期
✅ 周末或节假日：用户访问少
✅ 维护窗口：计划内维护时间

避免执行时间：
❌ 业务高峰期：上午9-12点，下午2-6点
❌ 促销活动期间：流量激增时
❌ 月末年末：业务数据变化频繁
```

### 7.3 性能影响最小化策略


**🔸 分步执行策略**
```
大表索引创建策略：

方案1：分时段执行
├── 第一天：创建部分索引
├── 第二天：创建剩余索引  
└── 避免一次性大量DDL

方案2：从库先执行
├── 在从库创建索引
├── 验证索引效果
├── 主从切换
└── 在新从库(原主库)创建索引

方案3：分区表策略  
├── 按分区逐个创建索引
├── 分散性能影响
└── 降低单次执行时间
```

---

## 8. 🔧 故障恢复与最佳实践


### 8.1 在线DDL故障恢复机制


**🔸 常见故障场景**
```
故障类型1：row log空间不足
原因：并发修改过多，超过innodb_online_alter_log_max_size
现象：DDL失败，返回错误
恢复：无需特殊处理，可以重新执行DDL

故障类型2：磁盘空间不足  
原因：临时索引文件占满磁盘
现象：DDL中断，临时文件残留
恢复：清理临时文件，释放空间后重试

故障类型3：系统重启
原因：服务器意外重启或MySQL崩溃
现象：DDL中断，需要重新开始
恢复：MySQL自动清理临时文件，重新执行DDL
```

### 8.2 DDL失败处理步骤


**🔸 故障诊断流程**
```
步骤1：检查错误日志
tail -f /var/log/mysql/error.log

步骤2：检查磁盘空间
df -h

步骤3：检查系统资源
top    # CPU和内存
iostat # 磁盘IO

步骤4：检查MySQL状态  
SHOW PROCESSLIST;
SHOW ENGINE INNODB STATUS;

步骤5：清理和重试
-- 杀死长事务(如果有)
KILL [connection_id];
-- 重新执行DDL
```

### 8.3 在线DDL最佳实践指南


**🔸 执行前准备清单**
```
📋 准备工作：
☑️ 选择业务低峰期执行
☑️ 确保磁盘空间足够(至少为表大小的2倍)
☑️ 调大row log缓冲区大小  
☑️ 检查是否有长事务运行
☑️ 准备监控脚本
☑️ 准备回滚方案
☑️ 通知相关团队维护时间
```

**🔸 执行过程监控**
```
📊 实时监控项：
├── DDL进度百分比
├── 系统CPU/内存/磁盘使用率
├── MySQL连接数和等待情况
├── 业务核心接口响应时间
├── 错误日志实时输出
└── row log使用情况
```

**🔸 紧急情况处理**
```sql
-- 如果发现DDL严重影响业务，可以尝试终止
-- 注意：只能在准备阶段或提交阶段终止，执行阶段无法安全终止

-- 查看当前DDL进程
SHOW PROCESSLIST;

-- 找到DDL进程ID，终止操作(谨慎使用)
KILL [DDL_process_id];
```

### 8.4 预演与回滚方案


**🔸 DDL预演流程**
```
生产环境执行前的完整预演：

步骤1：从库预演
├── 在从库执行相同DDL
├── 监控执行时间和资源消耗
└── 验证索引创建结果

步骤2：测试环境验证
├── 使用生产数据的子集测试
├── 验证应用程序兼容性  
└── 测试回滚流程

步骤3：制定回滚计划
├── 准备DROP INDEX语句
├── 确认回滚操作的影响时间
└── 准备应急联系人
```

---

## 9. 🎯 生产环境实战案例


### 9.1 案例：电商订单表索引创建


**🔸 业务背景**
```
表信息：
├── 表名：orders
├── 数据量：5000万行  
├── 表大小：50GB
├── 业务特点：读写混合，订单状态频繁更新
└── 需求：为status字段创建索引，优化状态查询性能
```

**🔸 执行计划制定**
```
时间选择：凌晨2:00-6:00
预计耗时：30-45分钟
影响评估：
├── 系统负载增加20-30%
├── 查询性能轻微下降10-15%
├── row log预计使用200MB
└── 磁盘IO增加50%
```

**🔸 具体执行步骤**
```sql
-- 1. 执行前准备
SET GLOBAL innodb_online_alter_log_max_size = 512*1024*1024; -- 512MB
SET SESSION lock_wait_timeout = 30;

-- 2. 执行DDL（实际生产命令）
ALTER TABLE orders 
ADD INDEX idx_status (status),
ALGORITHM=INPLACE, 
LOCK=NONE;

-- 3. 验证索引创建成功
SHOW INDEX FROM orders WHERE Key_name = 'idx_status';

-- 4. 测试查询性能
EXPLAIN SELECT * FROM orders WHERE status = 'pending';
```

### 9.2 案例：监控脚本实战


**🔸 完整监控脚本**
```bash
#!/bin/bash
# 生产环境DDL监控脚本

LOG_FILE="/tmp/ddl_monitor.log"
TABLE_NAME="orders"

monitor_ddl() {
    echo "$(date): 开始监控DDL进度..." | tee -a $LOG_FILE
    
    while true; do
        # 检查DDL是否还在执行
        DDL_COUNT=$(mysql -se "
            SELECT COUNT(*) FROM information_schema.processlist 
            WHERE INFO LIKE '%ALTER TABLE%$TABLE_NAME%'
        ")
        
        if [ "$DDL_COUNT" -eq 0 ]; then
            echo "$(date): DDL执行完成!" | tee -a $LOG_FILE
            break
        fi
        
        # 获取进度信息
        mysql -e "
            SELECT 
                EVENT_NAME,
                WORK_COMPLETED,
                WORK_ESTIMATED,
                CONCAT(ROUND(WORK_COMPLETED/WORK_ESTIMATED*100, 2), '%') AS PROGRESS
            FROM performance_schema.events_stages_current 
            WHERE EVENT_NAME LIKE 'stage/innodb/alter%';
        " | tee -a $LOG_FILE
        
        # 检查系统负载
        echo "CPU: $(top -bn1 | grep 'Cpu(s)' | cut -d'%' -f1 | cut -d' ' -f8)" | tee -a $LOG_FILE
        
        sleep 30
    done
}

# 开始监控
monitor_ddl
```

### 9.3 案例总结与经验


**🔸 执行结果**
```
实际执行情况：
├── 总耗时：38分钟
├── 最大系统负载：CPU 45%, IO 60%
├── 业务影响：查询性能下降12%
├── row log使用：180MB (未超限)
└── 用户投诉：0 (业务无感知)

关键成功因素：
✅ 充分的预演和测试
✅ 合理的参数配置  
✅ 全程监控和及时响应
✅ 在业务低峰期执行
```

**🔸 经验教训**
```
💡 成功经验：
├── 从库预演非常重要，时间估算准确  
├── 监控脚本帮助及时发现问题
├── 提前通知业务方，获得支持
└── row log缓冲区设置足够大

⚠️ 注意要点：
├── 即使是在线DDL，也要选择业务低峰期
├── 大表DDL前一定要在测试环境完整验证
├── 准备好回滚方案，虽然通常用不到
└── 与业务团队保持沟通，随时准备中止
```

---

## 10. 📋 核心要点总结


### 10.1 在线DDL核心机制


```
🧠 理解要点：

在线DDL = 短暂锁表(准备) + 长时间并行执行 + 短暂锁表(提交)

核心技术：
🔸 ALGORITHM=INPLACE：直接在原表上构建索引
🔸 row log机制：记录并发变更，确保数据一致性  
🔸 分阶段锁定：只在必要时短暂锁表
🔸 并发控制：业务和DDL可以同时进行
```

### 10.2 参数配置速查


**🔸 关键参数设置**
```sql
-- 必须设置的参数
SET GLOBAL innodb_online_alter_log_max_size = 1073741824;  -- 1GB
SET SESSION lock_wait_timeout = 30;                        -- 30秒

-- 推荐的DDL语法
ALTER TABLE table_name ADD INDEX index_name (column),
ALGORITHM=INPLACE,    -- 强制在线算法
LOCK=NONE;           -- 强制无锁模式
```

### 10.3 适用场景判断


**🔸 在线DDL适用性评估**

```
✅ 适合在线DDL的场景：
├── 添加普通索引 (最常用)
├── 删除索引 (瞬间完成)
├── 添加列到表末尾
├── 修改列默认值
└── 重命名列

❌ 不适合在线DDL的场景：  
├── 修改列数据类型 (需要COPY算法)
├── 添加主键到无主键表
├── 修改字符集
├── 添加/删除外键约束
└── 修改列顺序
```

### 10.4 生产环境检查清单


**🔸 执行前检查**
```
📋 准备阶段：
☑️ 确认表支持在线DDL
☑️ 评估执行时间和资源需求
☑️ 选择合适的执行时间窗口
☑️ 配置足够的row log空间
☑️ 准备监控脚本
☑️ 制定回滚计划  
☑️ 通知相关团队

📊 执行阶段：
☑️ 实时监控DDL进度
☑️ 监控系统资源使用
☑️ 关注业务性能指标
☑️ 检查错误日志输出
☑️ 保持与业务方沟通

✅ 完成阶段：
☑️ 验证索引创建成功
☑️ 测试查询性能提升
☑️ 恢复相关参数设置
☑️ 记录执行经验和数据
☑️ 向团队分享执行结果
```

### 10.5 核心记忆口诀


```
🧠 在线DDL记忆要诀：

INPLACE算法是核心，LOCK=NONE业务通
row log记录并发变，三阶段锁定要记清
准备提交短暂锁，执行阶段可并行  
监控进度要实时，故障处理有预案
低峰时段是首选，预演测试保平安
```

---

> 💡 **一句话总结**
> 
> 在线DDL通过`ALGORITHM=INPLACE`和`LOCK=NONE`实现真正的在线索引创建，核心是用row log记录并发变更，让业务和DDL可以同时进行。虽然不是100%无影响，但相比传统DDL的长时间锁表，已经是巨大进步。生产环境使用时要做好监控、预演和故障预案。