---
title: 2、索引创建语法与管理
---
## 📚 目录

1. [索引创建语法概述](#1-索引创建语法概述)
2. [CREATE INDEX语法详解](#2-create-index语法详解)
3. [ALTER TABLE索引操作](#3-alter-table索引操作)
4. [在线DDL与性能管理](#4-在线ddl与性能管理)
5. [索引删除与维护](#5-索引删除与维护)
6. [索引信息查询](#6-索引信息查询)
7. [最佳实践与安全策略](#7-最佳实践与安全策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 索引创建语法概述


### 1.1 索引创建的两种方式


**🔸 核心方法对比**
```
方式一：CREATE INDEX
• 专门的索引创建语句
• 语法清晰，参数丰富
• 支持更多的索引选项

方式二：ALTER TABLE  
• 表结构修改的一部分
• 可以同时修改表结构和索引
• 事务性更好，操作原子性强
```

### 1.2 索引创建时机选择


**⏰ 什么时候创建索引**
```
表设计阶段：
✅ 主键和唯一约束：表创建时自动建立
✅ 外键字段：关联查询频繁的字段
✅ 常用查询字段：WHERE条件中的高频字段

业务运行阶段：
📊 根据慢查询日志分析
📈 监控查询性能指标  
🎯 针对性优化特定查询
```

**⚠️ 创建时机注意事项**
- **大表创建索引**：会锁表较长时间，选择业务低峰期
- **生产环境操作**：必须先在测试环境验证
- **资源消耗**：创建索引需要额外的CPU、内存、磁盘IO

---

## 2. 💎 CREATE INDEX语法详解


### 2.1 CREATE INDEX完整语法规范


**📋 基本语法结构**
```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (column1 [(length)] [ASC|DESC], ...)
[USING {BTREE | HASH}]
[ALGORITHM = {DEFAULT | INPLACE | COPY}]
[LOCK = {DEFAULT | NONE | SHARED | EXCLUSIVE}]
[COMMENT 'string'];
```

**🔧 语法参数详解**

| 参数 | **说明** | **常用值** | **使用场景** |
|------|---------|-----------|-------------|
| **UNIQUE** | `唯一索引约束` | `UNIQUE/不指定` | `确保数据唯一性` |
| **FULLTEXT** | `全文检索索引` | `FULLTEXT` | `文本搜索功能` |
| **SPATIAL** | `空间数据索引` | `SPATIAL` | `GIS地理信息系统` |
| **USING** | `索引数据结构` | `BTREE/HASH` | `根据查询特点选择` |
| **ALGORITHM** | `执行算法` | `INPLACE/COPY` | `控制创建方式` |
| **LOCK** | `锁定级别` | `NONE/SHARED` | `平衡性能与并发` |

### 2.2 常用索引创建示例


**🔸 普通单列索引**
```sql
-- 为员工表的姓名字段创建索引
CREATE INDEX idx_employee_name 
ON employees (employee_name);

-- 指定索引算法（B+树）
CREATE INDEX idx_employee_email 
ON employees (email) 
USING BTREE
COMMENT '员工邮箱查询索引';
```

**🔸 复合索引（多列索引）**
```sql
-- 创建复合索引：部门+薪资
CREATE INDEX idx_dept_salary 
ON employees (department_id, salary DESC);

-- 查询条件字段顺序很重要
-- ✅ 可以使用索引的查询
WHERE department_id = 10 AND salary > 5000

-- ✅ 可以使用索引（左前缀匹配）
WHERE department_id = 10

-- ❌ 无法使用索引（跳过了第一列）
WHERE salary > 5000
```

**🔸 唯一索引创建**
```sql
-- 创建唯一索引确保邮箱不重复
CREATE UNIQUE INDEX uk_employee_email
ON employees (email);

-- 复合唯一索引
CREATE UNIQUE INDEX uk_user_phone
ON users (phone_number, country_code);
```

### 2.3 全文索引创建


**📝 FULLTEXT索引语法**
```sql
-- 为文章表创建全文索引
CREATE FULLTEXT INDEX ft_article_content
ON articles (title, content);

-- 中文全文索引（MySQL 5.7+）
CREATE FULLTEXT INDEX ft_chinese_content
ON articles (content)
WITH PARSER ngram
COMMENT '中文全文检索索引';
```

**🔍 全文索引使用示例**
```sql
-- 使用全文索引进行搜索
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('MySQL数据库' IN NATURAL LANGUAGE MODE);

-- 布尔模式搜索
SELECT * FROM articles  
WHERE MATCH(title, content) AGAINST('+MySQL +索引 -NoSQL' IN BOOLEAN MODE);
```

---

## 3. 🔄 ALTER TABLE索引操作


### 3.1 ALTER TABLE ADD INDEX详解


**📋 ALTER TABLE语法格式**
```sql
-- 添加普通索引
ALTER TABLE table_name 
ADD INDEX index_name (column_list);

-- 添加唯一索引
ALTER TABLE table_name
ADD UNIQUE INDEX index_name (column_list);

-- 添加主键（特殊的唯一索引）
ALTER TABLE table_name
ADD PRIMARY KEY (column_list);

-- 添加外键索引
ALTER TABLE table_name  
ADD FOREIGN KEY fk_name (column) REFERENCES ref_table(ref_column);
```

### 3.2 ALTER TABLE的优势


**✅ 相比CREATE INDEX的优点**
```
事务完整性：
• 可以在一个事务中同时修改表结构和索引
• 保证操作的原子性
• 失败时自动回滚

批量操作：
• 可以同时添加多个索引
• 减少表锁定次数
• 提高操作效率

语法一致性：
• 与其他表结构修改操作保持一致
• 便于脚本化管理
• 更好的可读性
```

**🔧 批量索引操作示例**
```sql
-- 同时添加多个索引
ALTER TABLE employees
ADD INDEX idx_name (employee_name),
ADD INDEX idx_dept (department_id),  
ADD INDEX idx_hire_date (hire_date),
ADD UNIQUE INDEX uk_email (email);

-- 同时修改表结构和添加索引
ALTER TABLE employees
ADD COLUMN phone VARCHAR(20),
ADD INDEX idx_phone (phone),
MODIFY COLUMN salary DECIMAL(10,2),
ADD INDEX idx_salary (salary);
```

---

## 4. 🔥 在线DDL与性能管理


### 4.1 在线DDL算法选择


**⚡ 三种DDL算法对比**

```
COPY算法：
┌─────────────────────────────┐
│ • 创建新表副本               │
│ • 复制所有数据               │
│ • 锁定原表直到完成           │
│ • 完成后替换原表             │
└─────────────────────────────┘
性能：最慢，影响业务

INPLACE算法：
┌─────────────────────────────┐
│ • 在原表上直接修改           │  
│ • 重新组织表数据             │
│ • 短暂锁定元数据             │
│ • 允许并发读写               │
└─────────────────────────────┘
性能：较快，轻微影响

INSTANT算法：
┌─────────────────────────────┐
│ • 只修改数据字典             │
│ • 不重新组织数据             │
│ • 几乎无锁定时间             │
│ • 秒级完成                  │
└─────────────────────────────┘
性能：极快，几乎无影响
```

### 4.2 索引创建算法选择策略


**🎯 算法选择指导**
```sql
-- 指定算法创建索引
CREATE INDEX idx_employee_salary 
ON employees (salary)
ALGORITHM = INPLACE,  -- 选择在线算法
LOCK = NONE;          -- 不锁定读写

-- ALTER TABLE方式指定算法
ALTER TABLE employees
ADD INDEX idx_department (department_id)
ALGORITHM = INPLACE,
LOCK = SHARED;        -- 允许读，禁止写
```

| 业务场景 | **推荐算法** | **锁定级别** | **适用情况** |
|---------|-------------|-------------|-------------|
| **生产高峰期** | `INPLACE` | `NONE` | `必须保证业务连续性` |
| **业务低峰期** | `COPY` | `SHARED` | `可以接受短暂影响` |
| **维护时间窗** | `COPY` | `EXCLUSIVE` | `计划性维护操作` |
| **紧急修复** | `INPLACE` | `NONE` | `快速添加必要索引` |

### 4.3 索引创建并行度控制 🔥


**🚀 并行创建机制**
```sql
-- 设置索引创建的并行度
SET SESSION innodb_ddl_threads = 4;

-- 创建大表索引时的配置
SET SESSION innodb_sort_buffer_size = 64M;  -- 排序缓冲区
SET SESSION innodb_ddl_buffer_size = 1G;    -- DDL操作缓冲区

-- 创建索引
CREATE INDEX idx_large_table_complex
ON large_table (col1, col2, col3)
ALGORITHM = INPLACE;
```

**📊 并行度配置建议**
```
系统配置考虑：
├── CPU核数：并行度不超过CPU核数
├── 内存大小：每个线程需要额外内存
├── 磁盘IO：并行会增加磁盘压力
└── 业务影响：评估对在线业务的影响

推荐配置：
• 4核系统：并行度设为2-3
• 8核系统：并行度设为4-6
• 大于16核：并行度设为8-12
```

### 4.4 索引创建进度监控 🔥


**📈 监控DDL操作进度**
```sql
-- 查看当前DDL操作进度（MySQL 8.0+）
SELECT 
    EVENT_NAME,
    WORK_COMPLETED,
    WORK_ESTIMATED,
    ROUND(100 * WORK_COMPLETED / WORK_ESTIMATED, 2) AS progress_pct
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE 'stage/innodb/alter%';

-- 查看DDL操作历史
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME, 
    EVENT_NAME,
    TIMER_START,
    TIMER_END,
    ROUND((TIMER_END - TIMER_START) / 1000000000000, 2) AS duration_seconds
FROM performance_schema.events_stages_history
WHERE EVENT_NAME LIKE 'stage/innodb/alter%'
ORDER BY TIMER_START DESC;
```

**🔧 进度监控最佳实践**
```
监控策略：
1️⃣ 创建索引前预估时间
2️⃣ 设置监控脚本定期检查
3️⃣ 记录操作日志便于分析
4️⃣ 准备回滚方案

预估方法：
• 小样本测试：在小数据集上测试创建时间
• 线性推算：根据数据量比例估算
• 考虑负载：业务高峰期会更慢
```

---

## 5. 🗑️ 索引删除与维护


### 5.1 DROP INDEX删除索引 💎


**🔧 删除索引语法**
```sql
-- 方式一：DROP INDEX语句
DROP INDEX index_name ON table_name;

-- 方式二：ALTER TABLE方式
ALTER TABLE table_name DROP INDEX index_name;

-- 删除主键索引（特殊情况）
ALTER TABLE table_name DROP PRIMARY KEY;

-- 删除外键索引
ALTER TABLE table_name DROP FOREIGN KEY constraint_name;
```

**⚠️ 索引删除安全策略**
```
删除前安全检查：
├── 确认索引使用情况：查看执行计划是否依赖
├── 备份索引定义：记录完整的创建语句
├── 评估业务影响：分析删除后的性能影响
└── 准备回滚方案：快速重建索引的方法

安全删除流程：
1️⃣ 业务低峰期执行
2️⃣ 监控系统性能变化
3️⃣ 准备紧急回滚方案
4️⃣ 删除后验证业务功能
```

### 5.2 误删索引恢复方法


**🔄 索引恢复策略**
```sql
-- 步骤1：快速重建关键索引
CREATE INDEX idx_critical_field 
ON important_table (critical_field)
ALGORITHM = INPLACE, 
LOCK = NONE;

-- 步骤2：批量重建索引（备份的索引定义）
-- 从备份的DDL语句中恢复
SOURCE backup_indexes.sql;

-- 步骤3：验证索引效果
EXPLAIN SELECT * FROM important_table WHERE critical_field = 'value';
```

### 5.3 索引重建与维护策略 💎


**🔄 索引重建的必要性**
```
重建索引的原因：
• 索引碎片过多：频繁的增删改导致索引页碎片
• 统计信息过时：影响优化器的执行计划选择
• 表数据大幅变化：索引深度不再合理

重建方法：
方式一：删除重建
DROP INDEX idx_name ON table_name;
CREATE INDEX idx_name ON table_name (column);

方式二：OPTIMIZE TABLE（适合小表）
OPTIMIZE TABLE table_name;
```

**📊 重建时机判断**
```sql
-- 检查索引统计信息
SHOW INDEX FROM employees;

-- 查看表的碎片情况
SELECT 
    TABLE_NAME,
    DATA_FREE,  -- 碎片大小
    DATA_LENGTH + INDEX_LENGTH as total_size,
    ROUND(DATA_FREE / (DATA_LENGTH + INDEX_LENGTH) * 100, 2) as fragment_pct
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'your_database'
  AND TABLE_NAME = 'your_table';

-- 碎片率超过20%建议重建索引
```

---

## 6. 🔍 索引信息查询


### 6.1 SHOW INDEX查看索引信息 💎


**📊 SHOW INDEX语法和输出**
```sql
-- 查看表的所有索引
SHOW INDEX FROM employees;

-- 查看特定数据库的索引
SHOW INDEX FROM database_name.table_name;

-- 格式化输出索引信息
SHOW INDEX FROM employees\G
```

**🔍 索引信息字段详解**
```
输出字段说明：
┌─────────────────────────────┐
│ Table: 表名                  │
│ Non_unique: 0=唯一,1=非唯一   │
│ Key_name: 索引名称           │
│ Seq_in_index: 字段在索引中序号│
│ Column_name: 索引字段名      │
│ Collation: 排序方式A/D/NULL  │  
│ Cardinality: 基数（唯一值数量）│
│ Sub_part: 前缀索引长度       │
│ Packed: 是否压缩             │
│ Null: 是否允许NULL值         │
│ Index_type: 索引类型BTREE等  │
│ Comment: 索引注释           │
└─────────────────────────────┘

重要字段解读：
• Cardinality越高，索引选择性越好
• Sub_part显示前缀索引的字符长度
• Index_type显示底层数据结构
```

### 6.2 索引统计信息查看


**📈 information_schema查询**
```sql
-- 查看数据库中所有索引的详细信息
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    SEQ_IN_INDEX,
    NON_UNIQUE,
    INDEX_TYPE
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;

-- 分析索引大小和使用情况
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * $$innodb_page_size / 1024 / 1024, 2) as size_mb
FROM information_schema.INNODB_SYS_INDEXES i
JOIN information_schema.INNODB_SYS_TABLESTATS t ON i.SPACE = t.SPACE
WHERE i.NAME NOT LIKE 'FTS_%';
```

### 6.3 索引状态监控命令


**📊 实用的索引监控查询**
```sql
-- 查找未使用的索引
SELECT 
    s.TABLE_SCHEMA,
    s.TABLE_NAME,  
    s.INDEX_NAME,
    s.CARDINALITY
FROM information_schema.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
    ON s.TABLE_SCHEMA = u.OBJECT_SCHEMA
    AND s.TABLE_NAME = u.OBJECT_NAME
    AND s.INDEX_NAME = u.INDEX_NAME
WHERE u.INDEX_NAME IS NULL
    AND s.INDEX_NAME != 'PRIMARY'
    AND s.TABLE_SCHEMA NOT IN ('mysql', 'sys', 'performance_schema');

-- 查看索引使用频率
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT,
    COUNT_UPDATE,  
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_FETCH DESC;
```

---

## 7. 🛠️ 最佳实践与安全策略


### 7.1 索引DDL语句安全性验证


**🔒 生产环境安全操作流程**
```
上线前验证清单：
☑️ 测试环境完整验证
☑️ 执行计划分析确认
☑️ 资源消耗评估
☑️ 业务影响评估
☑️ 回滚方案准备
☑️ 监控告警设置

操作安全策略：
1️⃣ 选择业务低峰期
2️⃣ 使用在线DDL算法
3️⃣ 分批执行大批量操作
4️⃣ 实时监控系统指标
5️⃣ 准备快速回滚机制
```

### 7.2 索引创建资源控制策略


**💾 资源控制配置**
```sql
-- 索引创建的资源限制配置
-- 内存使用控制
SET SESSION sort_buffer_size = 32M;           -- 排序缓冲区
SET SESSION read_buffer_size = 8M;            -- 读缓冲区
SET SESSION innodb_sort_buffer_size = 64M;    -- InnoDB排序缓冲

-- IO限制控制
SET SESSION innodb_io_capacity = 2000;        -- IO能力限制
SET SESSION innodb_io_capacity_max = 4000;    -- 最大IO能力

-- 并发控制
SET SESSION max_heap_table_size = 512M;      -- 内存表大小限制
```

### 7.3 索引命名规范标准 💎


**📝 索引命名规范**
```
命名规范建议：

普通索引：
格式：idx_表名_字段名
示例：idx_employees_name、idx_orders_create_date

唯一索引：
格式：uk_表名_字段名  
示例：uk_users_email、uk_products_code

复合索引：
格式：idx_表名_字段1_字段2
示例：idx_orders_user_status、idx_products_category_price

外键索引：
格式：fk_表名_关联表
示例：fk_orders_users、fk_products_categories

全文索引：
格式：ft_表名_字段名
示例：ft_articles_content、ft_products_description
```

### 7.4 索引创建失败处理流程


**🚨 创建失败的常见原因和解决方案**
```
常见失败原因：

磁盘空间不足：
问题：索引创建需要临时空间
解决：清理临时文件，增加磁盘空间

内存不足：
问题：大表索引创建消耗大量内存
解决：调整内存参数，分批创建

锁等待超时：
问题：表被长时间锁定
解决：等待锁释放，选择合适时机

数据类型冲突：
问题：字段类型不支持索引
解决：修改字段类型或使用函数索引
```

**🔄 失败恢复策略**
```sql
-- 检查失败原因
SHOW ENGINE INNODB STATUS;

-- 查看错误日志
SHOW VARIABLES LIKE 'log_error';

-- 重新尝试创建（调整参数）
SET SESSION innodb_sort_buffer_size = 128M;
CREATE INDEX idx_retry ON large_table (column)
ALGORITHM = INPLACE,
LOCK = NONE;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的语法要点


```
🔸 两种创建方式：CREATE INDEX和ALTER TABLE ADD INDEX各有优势
🔸 完整语法参数：索引类型、算法、锁定级别、注释等关键参数
🔸 在线DDL算法：INPLACE算法实现生产环境无影响索引创建
🔸 删除索引安全：必须评估影响，准备恢复方案
🔸 进度监控机制：大表索引创建需要监控进度和资源使用
```

### 8.2 关键理解要点


**🔹 CREATE INDEX vs ALTER TABLE选择**
```
CREATE INDEX适合：
• 单纯的索引管理操作
• 需要精细控制索引参数
• 批量索引管理脚本

ALTER TABLE适合：
• 同时修改表结构和索引
• 保证操作的事务完整性
• 复杂的表结构变更
```

**🔹 在线DDL的核心价值**
```
业务连续性保障：
• INPLACE算法允许并发读写
• LOCK=NONE避免业务中断
• 实现真正的在线索引管理

性能影响最小化：
• 资源控制避免系统过载
• 进度监控及时发现问题
• 并行创建提高效率
```

### 8.3 实际应用指导


**🎯 生产环境操作指南**
```
索引创建流程：
1️⃣ 分析业务需求和查询模式
2️⃣ 在测试环境验证索引效果
3️⃣ 评估创建时间和资源消耗
4️⃣ 选择合适的创建时机和参数
5️⃣ 执行创建操作并监控进度
6️⃣ 验证索引效果和业务功能

索引维护策略：
• 定期检查索引使用情况
• 清理无用索引节约空间
• 重建碎片严重的索引
• 根据业务变化调整索引
```

**🔧 常用操作模板**
```sql
-- 生产环境安全创建索引模板
CREATE INDEX idx_table_field
ON table_name (field_name)
USING BTREE
ALGORITHM = INPLACE
LOCK = NONE
COMMENT '索引用途说明';

-- 批量索引管理模板
ALTER TABLE table_name
ADD INDEX idx_field1 (field1),
ADD INDEX idx_field2 (field2),  
ADD UNIQUE INDEX uk_field3 (field3)
ALGORITHM = INPLACE,
LOCK = SHARED;
```

**💡 索引管理经验总结**
- **谨慎创建**：不是所有字段都需要索引，过多索引影响写入性能
- **合理命名**：规范的命名便于管理和维护
- **监控使用**：定期检查索引使用情况，清理无用索引
- **安全操作**：生产环境操作必须有完整的验证和回滚方案
- **资源控制**：大表操作要控制资源使用，避免影响业务

**核心记忆**：
- 索引创建有两种语法，各有适用场景
- 在线DDL算法让生产环境索引管理更安全
- 删除索引需要谨慎评估，准备恢复方案
- 监控和维护是索引管理的重要环节