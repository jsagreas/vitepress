---
title: 9、前缀索引应用
---
## 📚 目录

1. [前缀索引基本概念](#1-前缀索引基本概念)
2. [前缀长度选择策略](#2-前缀长度选择策略)
3. [选择性计算与优化](#3-选择性计算与优化)
4. [前缀索引性能分析](#4-前缀索引性能分析)
5. [适用场景与局限性](#5-适用场景与局限性)
6. [维护与监控策略](#6-维护与监控策略)
7. [实际应用案例](#7-实际应用案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📋 前缀索引基本概念


### 1.1 什么是前缀索引


> 💡 **通俗理解**：前缀索引就像给长单词建立"简写版"的字典，用前几个字母就能快速定位

**前缀索引定义**：
```
前缀索引：只对字符串字段的前n个字符建立索引
目的：在保证查询效率的前提下，大幅减少索引存储空间

普通索引 vs 前缀索引：
┌─ 普通索引 ─┐         ┌─ 前缀索引 ─┐
│ email列     │         │ email列     │
│ 完整值索引   │         │ 前缀值索引   │
└─────────────┘         └─────────────┘
user1@company.com  →    user1@comp
user2@gmail.com    →    user2@gmai
user3@163.com      →    user3@163.
```

**创建前缀索引语法**：
```sql
-- 创建前缀索引：只索引前10个字符
CREATE INDEX idx_email_prefix ON users(email(10));

-- 对比完整索引
CREATE INDEX idx_email_full ON users(email);
```

### 1.2 为什么需要前缀索引


**解决的核心问题**：

<details>
<summary>📊 存储空间节省对比分析</summary>

```sql
-- 实际数据对比
-- 假设用户表有100万条记录，email平均长度25字符

-- 完整email索引存储需求：
100万 × 25字符 × 1字节 = 25MB

-- 前缀索引(10字符)存储需求：  
100万 × 10字符 × 1字节 = 10MB

-- 节省空间：15MB (60%的空间节省)
-- 内存缓存能力提升：可缓存更多索引页
```

</details>

**前缀索引的核心价值**：
- **🗂️ 存储空间节省**：减少60-80%的索引存储空间
- **⚡ 内存效率提升**：更多索引页可以缓存在内存中
- **🔍 查询速度优化**：较小的索引树，查找更快
- **💾 磁盘IO减少**：索引页更小，读取IO更少

**适用字段类型**：
- **VARCHAR**：变长字符串，如邮箱、URL、描述
- **CHAR**：定长字符串，如手机号码
- **TEXT**：大文本字段，如文章内容
- **不适用**：数字类型、日期类型、布尔类型

---

## 2. 📐 前缀长度选择策略


### 2.1 前缀长度优化算法


> 🎯 **核心目标**：找到存储成本与查询精度的最佳平衡点

**前缀长度选择决策树**：
```
前缀长度选择流程：
    开始
     │
     ▼
 分析字段数据分布
     │
     ▼
 计算不同长度的选择性
     │
   ┌─▼─┐
   │   │
选择性>0.9？  选择性<0.1？
   │   │        │
   ▼   ▼        ▼
  采用  继续测试   放弃前缀索引
       更长前缀    使用完整索引
```

**前缀长度计算步骤**：

<details>
<summary>🔧 前缀长度计算实践公式</summary>

```sql
-- 第1步：计算字段的总选择性（完整字段）
SELECT 
    COUNT(DISTINCT email) / COUNT(*) as full_selectivity
FROM users;

-- 第2步：测试不同前缀长度的选择性
SELECT 
    CHAR_LENGTH(email) as length,
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) as prefix_5,
    COUNT(DISTINCT LEFT(email, 8)) / COUNT(*) as prefix_8,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) as prefix_10,
    COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) as prefix_15
FROM users 
GROUP BY CHAR_LENGTH(email);

-- 第3步：找到选择性达到90%的最短长度
-- 如果完整选择性是0.95，目标是0.95 * 0.9 = 0.855
```

</details>

**算法实现逻辑**：
1. **基准测试**：计算完整字段的选择性
2. **递增测试**：从短到长测试不同前缀长度
3. **阈值判断**：选择性达到总选择性90%时停止
4. **验证确认**：通过实际查询验证性能

### 2.2 选择性与长度平衡


**选择性计算公式**：
```
选择性 = 不同值的数量 / 总记录数量

选择性解读：
• 1.0：完全唯一（如主键ID）
• 0.8-0.9：高选择性，索引效果好
• 0.5-0.7：中等选择性，有一定效果  
• < 0.3：低选择性，索引效果差
```

**平衡策略示例**：

| 前缀长度 | **选择性** | **存储节省** | **查询精度** | **推荐度** |
|---------|-----------|-------------|-------------|-----------|
| `3字符` | `0.45` | `85%` | `较差` | `❌不推荐` |
| `6字符` | `0.78` | `70%` | `良好` | `⚠️可考虑` |
| `10字符` | `0.92` | `55%` | `很好` | `✅推荐` |
| `15字符` | `0.98` | `35%` | `优秀` | `✅推荐` |

### 2.3 动态前缀长度调整


> 🔄 **维护策略**：随着数据增长，需要定期评估和调整前缀长度

**调整触发条件**：
```sql
-- 监控前缀索引选择性变化
CREATE EVENT check_prefix_selectivity
ON SCHEDULE EVERY 1 WEEK
DO
  BEGIN
    SELECT 
        'email_prefix' as index_name,
        COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) as current_selectivity,
        COUNT(*) as total_rows
    FROM users;
    
    -- 如果选择性下降到0.8以下，发出告警
    IF current_selectivity < 0.8 THEN
        INSERT INTO index_alerts (alert_type, message) 
        VALUES ('PREFIX_INDEX', 'Email prefix selectivity too low');
    END IF;
  END;
```

**动态调整策略**：
- **定期监控**：每月检查一次前缀索引选择性
- **阈值告警**：选择性低于80%时考虑调整
- **渐进调整**：逐步增加前缀长度，避免一次性大幅变动
- **A/B测试**：在从库上测试新长度效果

---

## 3. 🧮 选择性计算与优化


### 3.1 选择性计算深度分析


> 📊 **数学原理**：选择性本质上是衡量数据分布均匀程度的指标

**选择性计算实战**：
```sql
-- 完整的选择性分析SQL
SELECT 
    -- 基础信息
    COUNT(*) as total_rows,
    COUNT(DISTINCT email) as unique_values,
    
    -- 完整字段选择性
    COUNT(DISTINCT email) / COUNT(*) as full_selectivity,
    
    -- 不同前缀长度选择性对比
    COUNT(DISTINCT LEFT(email, 3)) / COUNT(*) as len_3_selectivity,
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) as len_5_selectivity,
    COUNT(DISTINCT LEFT(email, 8)) / COUNT(*) as len_8_selectivity,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) as len_10_selectivity,
    COUNT(DISTINCT LEFT(email, 12)) / COUNT(*) as len_12_selectivity,
    
    -- 存储空间节省率计算
    (1 - 10/AVG(CHAR_LENGTH(email))) * 100 as space_saved_10char
FROM users;
```

**选择性分析图示**：
```
选择性与前缀长度关系：

选择性 ▲
  1.0 ┤                    ████
      │                 ███
  0.8 ┤              ███
      │           ███
  0.6 ┤        ███
      │     ███
  0.4 ┤  ███
      │██
  0.2 ┤
      │
    0 └──────────────────────────► 前缀长度
      0  3  6  9  12 15 18 21 24

最佳选择点：选择性>0.9的最短长度
```

### 3.2 前缀索引适用性评估框架


**评估维度分析**：

```
前缀索引适用性评估表：
┌─ 数据特征评估 ─┐
│ ├─ 字段长度分布 │ → 平均长度>10字符适合
│ ├─ 数据重复程度 │ → 重复率<20%适合  
│ └─ 前缀区分度   │ → 前缀选择性>0.8适合
├─ 查询模式评估 ─┤
│ ├─ 前缀查询比例 │ → LIKE 'abc%'查询多
│ ├─ 精确匹配需求 │ → = 查询是否必须精确
│ └─ 范围查询需求 │ → ORDER BY是否需要
└─ 维护成本评估 ─┘
  ├─ 数据更新频率 │ → 更新频繁增加维护成本
  └─ 监控复杂度   │ → 需要额外监控机制
```

**评估实施步骤**：
```sql
-- 步骤1：数据特征分析
SELECT 
    MIN(CHAR_LENGTH(email)) as min_len,
    MAX(CHAR_LENGTH(email)) as max_len,
    AVG(CHAR_LENGTH(email)) as avg_len,
    COUNT(DISTINCT email) / COUNT(*) as uniqueness
FROM users;

-- 步骤2：前缀区分度测试
SELECT 
    prefix_len,
    selectivity,
    CASE 
        WHEN selectivity > 0.9 THEN '优秀'
        WHEN selectivity > 0.7 THEN '良好'  
        WHEN selectivity > 0.5 THEN '一般'
        ELSE '较差'
    END as evaluation
FROM (
    SELECT 3 as prefix_len, COUNT(DISTINCT LEFT(email,3))/COUNT(*) as selectivity FROM users
    UNION ALL
    SELECT 6, COUNT(DISTINCT LEFT(email,6))/COUNT(*) FROM users
    UNION ALL  
    SELECT 10, COUNT(DISTINCT LEFT(email,10))/COUNT(*) FROM users
) t;
```

### 3.3 前缀长度计算公式优化


**优化计算公式**：

> 🔑 **核心公式**：最佳前缀长度 = MIN(长度) WHERE 选择性 ≥ 目标选择性

```sql
-- 自动化前缀长度计算存储过程
DELIMITER $$
CREATE PROCEDURE CalculateOptimalPrefix(
    IN table_name VARCHAR(64),
    IN column_name VARCHAR(64), 
    IN target_selectivity DECIMAL(3,2)
)
BEGIN
    DECLARE optimal_length INT DEFAULT 0;
    DECLARE current_length INT DEFAULT 1;
    DECLARE current_selectivity DECIMAL(3,2) DEFAULT 0;
    DECLARE full_selectivity DECIMAL(3,2) DEFAULT 0;
    
    -- 计算完整字段选择性
    SET @sql = CONCAT('SELECT COUNT(DISTINCT ', column_name, 
                     ') / COUNT(*) INTO @full_sel FROM ', table_name);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    SET full_selectivity = @full_sel;
    
    -- 目标选择性调整
    SET target_selectivity = full_selectivity * target_selectivity;
    
    -- 循环测试不同前缀长度
    WHILE current_length <= 50 AND optimal_length = 0 DO
        SET @sql = CONCAT('SELECT COUNT(DISTINCT LEFT(', column_name, 
                         ',', current_length, ')) / COUNT(*) INTO @cur_sel FROM ', table_name);
        PREPARE stmt FROM @sql;  
        EXECUTE stmt;
        SET current_selectivity = @cur_sel;
        
        IF current_selectivity >= target_selectivity THEN
            SET optimal_length = current_length;
        END IF;
        
        SET current_length = current_length + 1;
    END WHILE;
    
    -- 返回结果
    SELECT optimal_length as recommended_prefix_length,
           current_selectivity as achieved_selectivity,
           full_selectivity as full_selectivity;
           
END$$
DELIMITER ;

-- 使用示例
CALL CalculateOptimalPrefix('users', 'email', 0.90);
```

---

## 4. ⚡ 前缀索引性能分析


### 4.1 存储空间节省分析


**空间节省计算模型**：

```
存储空间计算：
┌─ 索引存储组成 ─────────────────┐
│ 1. 索引键值：前缀长度 × 记录数   │
│ 2. 指针开销：8字节 × 记录数     │  
│ 3. B+树结构：页头、页尾等开销   │
│ 4. 碎片空间：页内碎片          │
└──────────────────────────────┘

实际计算示例：
表：users (1,000,000 records)
字段：email (平均25字符)

完整索引：
├─ 键值空间：25 × 1,000,000 = 25MB
├─ 指针空间：8 × 1,000,000 = 8MB  
├─ 树结构：约5MB
└─ 总计：约38MB

前缀索引(10字符)：
├─ 键值空间：10 × 1,000,000 = 10MB
├─ 指针空间：8 × 1,000,000 = 8MB
├─ 树结构：约3MB  
└─ 总计：约21MB

节省空间：17MB (45%节省)
```

### 4.2 查询性能影响分析


**查询精度影响评估**：

```sql
-- 精确匹配查询测试
EXPLAIN FORMAT=JSON 
SELECT * FROM users WHERE email = 'user123@company.com';

-- 前缀索引可能的执行计划：
-- 1. 使用前缀索引快速定位候选记录
-- 2. 回表查询完整email字段
-- 3. 过滤出精确匹配的记录
```

**性能影响因素**：

| 因素 | **完整索引** | **前缀索引** | **性能影响** |
|-----|------------|-------------|-------------|
| **索引扫描** | `精确定位` | `需要二次过滤` | `增加CPU开销` |
| **回表查询** | `较少` | `可能增加` | `增加磁盘IO` |
| **内存占用** | `高` | `低` | `减少内存压力` |
| **缓存命中** | `较低` | `较高` | `整体性能提升` |

### 4.3 前缀索引性能基准测试


**基准测试设计**：

<details>
<summary>🧪 性能测试脚本示例</summary>

```sql
-- 准备测试数据
CREATE TABLE test_prefix (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100),
    other_data VARCHAR(500)
);

-- 插入测试数据
INSERT INTO test_prefix (email, other_data)
SELECT 
    CONCAT('user', n, '@', 
           CASE FLOOR(RAND()*3)
               WHEN 0 THEN 'gmail.com'
               WHEN 1 THEN 'company.com'  
               WHEN 2 THEN '163.com'
           END) as email,
    REPEAT('test', 125) as other_data
FROM (
    SELECT a.N + b.N*10 + c.N*100 + d.N*1000 + 1 as n
    FROM 
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) a,
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) b,
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) c,
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) d
    LIMIT 100000
) numbers;

-- 创建不同类型索引进行对比
CREATE INDEX idx_email_full ON test_prefix(email);
CREATE INDEX idx_email_prefix_8 ON test_prefix(email(8));  
CREATE INDEX idx_email_prefix_12 ON test_prefix(email(12));

-- 性能测试查询
-- 测试1：精确匹配
SELECT COUNT(*) FROM test_prefix WHERE email = 'user123@gmail.com';

-- 测试2：前缀匹配
SELECT COUNT(*) FROM test_prefix WHERE email LIKE 'user123@%';

-- 测试3：范围查询
SELECT COUNT(*) FROM test_prefix WHERE email > 'user100@' AND email < 'user200@';
```

</details>

**测试结果分析框架**：
```
性能测试维度：
┌─ 查询响应时间 ─┐
├─ 索引空间占用 ─┤  
├─ 内存缓存效率 ─┤
├─ 磁盘IO统计 ──┤
└─ CPU使用率 ───┘

测试场景覆盖：
• 精确匹配查询 (=)
• 前缀匹配查询 (LIKE 'abc%')  
• 范围查询 (BETWEEN)
• 排序查询 (ORDER BY)
```

---

## 5. 🎯 适用场景与局限性


### 5.1 前缀索引适用场景


**最佳适用场景**：

```
✅ 高适配场景：
┌─ 长文本字段 ───┐  例如：文章标题、产品描述
├─ URL地址字段 ─┤  例如：网页链接、图片URL
├─ 邮箱地址字段 ─┤  例如：用户邮箱、联系邮箱
├─ 身份证号码 ───┤  例如：前6位地区码区分度高
└─ 商品编码 ─────┘  例如：SKU编码、产品型号
```

**实际应用示例**：

<details>
<summary>💼 电商网站产品表优化案例</summary>

```sql
-- 原始产品表
CREATE TABLE products (
    id INT PRIMARY KEY,
    sku_code VARCHAR(50),      -- 商品编码：ELEC2024PHONE001
    product_name VARCHAR(200), -- 商品名称：苹果iPhone 15 Pro Max...
    description TEXT           -- 商品描述：长文本
);

-- 前缀索引优化
-- SKU编码：前10位包含类别和年份信息
CREATE INDEX idx_sku_prefix ON products(sku_code(10));

-- 商品名称：前15字符通常包含品牌和主要型号  
CREATE INDEX idx_name_prefix ON products(product_name(15));

-- 验证选择性
SELECT 
    COUNT(DISTINCT LEFT(sku_code, 10)) / COUNT(*) as sku_selectivity,
    COUNT(DISTINCT LEFT(product_name, 15)) / COUNT(*) as name_selectivity
FROM products;
```

</details>

### 5.2 前缀索引局限性


> ⚠️ **重要限制**：前缀索引并非万能，存在明显的使用局限

**核心局限性分析**：

```
前缀索引的主要限制：
┌─ 功能限制 ─┐
│ ├─ 无法用于ORDER BY  │ ← 排序需要完整值比较
│ ├─ 无法用于GROUP BY  │ ← 分组需要完整值判断
│ └─ 覆盖索引受限     │ ← 无法直接返回完整值
├─ 查询限制 ─┤
│ ├─ 后缀匹配无效     │ ← LIKE '%@gmail.com'
│ ├─ 中间匹配无效     │ ← LIKE '%company%'  
│ └─ 精确度有损失     │ ← 可能需要额外过滤
└─ 维护限制 ─┘
  ├─ 需要定期评估     │ ← 数据分布变化影响
  └─ 调整成本较高     │ ← 重建索引耗时
```

**不适用场景详解**：
```sql
-- ❌ 无法优化的查询类型

-- 1. 后缀匹配查询
SELECT * FROM users WHERE email LIKE '%@gmail.com';
-- 前缀索引对此查询无帮助

-- 2. 中间包含匹配
SELECT * FROM users WHERE email LIKE '%company%';  
-- 需要全字段扫描

-- 3. 排序查询
SELECT * FROM users ORDER BY email;
-- 前缀索引无法提供正确排序

-- 4. 分组统计
SELECT LEFT(email, LOCATE('@', email)-1) as username, COUNT(*)
FROM users GROUP BY email;
-- 需要完整email值进行分组
```

### 5.3 替代方案选择


**当前缀索引不适用时的替代方案**：

| 场景 | **替代方案** | **实现方式** | **适用条件** |
|-----|------------|-------------|-------------|
| **需要排序** | `函数索引` | `CREATE INDEX ON (LEFT(email,10))` | `MySQL 8.0+` |
| **需要分组** | `冗余字段` | `额外存储前缀字段` | `可接受空间冗余` |
| **后缀匹配** | `反转索引` | `REVERSE(email)前缀索引` | `主要后缀查询` |
| **全文搜索** | `FULLTEXT索引` | `MATCH AGAINST语法` | `文本内容搜索` |

---

## 6. 🔧 维护与监控策略


### 6.1 前缀索引监控指标


> 📈 **监控目的**：确保前缀索引持续发挥最佳效果

**关键监控指标体系**：

```
前缀索引健康度监控：
┌─ 选择性监控 ─┐
│ ├─ 当前选择性值     │ → 是否低于阈值
│ ├─ 选择性变化趋势   │ → 是否持续下降  
│ └─ 与完整索引对比   │ → 差距是否拉大
├─ 性能监控 ───┤
│ ├─ 查询响应时间     │ → 是否明显增长
│ ├─ 索引使用频率     │ → 是否被有效使用
│ └─ 回表查询比例     │ → 是否过于频繁
└─ 空间监控 ───┘
  ├─ 索引大小增长     │ → 与预期是否一致
  └─ 存储空间节省率   │ → 节省效果是否达标
```

**监控查询SQL**：
```sql
-- 创建监控视图
CREATE VIEW v_prefix_index_monitor AS
SELECT 
    'email_prefix_10' as index_name,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) as current_selectivity,
    COUNT(DISTINCT email) / COUNT(*) as full_selectivity,
    COUNT(*) as total_records,
    NOW() as check_time
FROM users;

-- 选择性趋势监控
SELECT 
    DATE(check_time) as check_date,
    current_selectivity,
    current_selectivity / full_selectivity as selectivity_ratio
FROM prefix_index_history 
WHERE index_name = 'email_prefix_10'
ORDER BY check_date DESC 
LIMIT 30;
```

### 6.2 前缀索引维护自动化策略


**自动化维护流程**：

```
前缀索引维护自动化：
    ┌─ 定期监控 ─┐
    │            │
    ▼            │
  选择性检查     │
    │            │
    ▼            │
  阈值判断       │
    │            │
  ┌─▼─┐          │
  │   │          │
正常  异常        │
  │   │          │
  ▼   ▼          │
 继续 触发调整    │
监控  │          │
     ▼          │
   重新计算      │
   最佳长度      │
     │          │
     ▼          │
   执行索引      │
   重建操作 ─────┘
```

**自动化脚本实现**：

<details>
<summary>🤖 前缀索引自动维护脚本</summary>

```sql
-- 创建前缀索引监控表
CREATE TABLE prefix_index_monitor (
    id INT PRIMARY KEY AUTO_INCREMENT,
    table_name VARCHAR(64),
    column_name VARCHAR(64),
    current_prefix_length INT,
    current_selectivity DECIMAL(5,4),
    recommended_length INT,
    action_needed ENUM('NONE', 'EXTEND', 'REBUILD'),
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 自动检查存储过程
DELIMITER $$
CREATE PROCEDURE AutoMaintainPrefixIndex()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE tbl_name VARCHAR(64);
    DECLARE col_name VARCHAR(64); 
    DECLARE current_len INT;
    DECLARE cur_selectivity DECIMAL(5,4);
    DECLARE optimal_len INT;
    
    -- 游标定义
    DECLARE index_cursor CURSOR FOR
        SELECT table_name, column_name, prefix_length 
        FROM index_config WHERE index_type = 'PREFIX';
        
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN index_cursor;
    
    read_loop: LOOP
        FETCH index_cursor INTO tbl_name, col_name, current_len;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 计算当前选择性
        SET @sql = CONCAT('SELECT COUNT(DISTINCT LEFT(', col_name, ',', current_len, ')) / COUNT(*) FROM ', tbl_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        -- 存储结果到cur_selectivity变量
        
        -- 判断是否需要调整
        IF cur_selectivity < 0.8 THEN
            -- 重新计算最佳长度
            CALL CalculateOptimalPrefix(tbl_name, col_name, 0.90);
            -- 记录维护建议
            INSERT INTO prefix_index_monitor VALUES (
                NULL, tbl_name, col_name, current_len, 
                cur_selectivity, optimal_len, 'EXTEND', NOW()
            );
        END IF;
        
    END LOOP;
    
    CLOSE index_cursor;
END$$
DELIMITER ;

-- 定期执行（每周）
CREATE EVENT auto_check_prefix_indexes
ON SCHEDULE EVERY 1 WEEK
DO CALL AutoMaintainPrefixIndex();
```

</details>

### 6.3 维护操作最佳实践


**索引重建策略**：
```sql
-- 安全的索引重建流程

-- 1. 在从库测试新前缀长度
CREATE INDEX idx_email_prefix_12 ON users(email(12));
-- 测试查询性能

-- 2. 主库在低峰期执行  
-- 方法1：先创建新索引，再删除旧索引
ALTER TABLE users ADD INDEX idx_email_new(email(12));
ALTER TABLE users DROP INDEX idx_email_prefix_10;
ALTER TABLE users RENAME INDEX idx_email_new TO idx_email_prefix;

-- 方法2：直接修改索引（MySQL 8.0+）
ALTER TABLE users DROP INDEX idx_email_prefix_10, 
                  ADD INDEX idx_email_prefix(email(12));
```

**维护窗口规划**：
- **监控频率**：每周自动检查
- **评估周期**：每月人工评估
- **调整窗口**：业务低峰期执行
- **回滚方案**：保留原索引直到确认新索引稳定

---

## 7. 💼 实际应用案例


### 7.1 用户表邮箱字段优化


**业务背景**：
- **用户量**：500万注册用户
- **邮箱特点**：平均长度28字符，主要为常见邮箱服务商
- **查询模式**：主要是精确匹配登录查询

**优化实施步骤**：

```sql
-- 步骤1：数据特征分析
SELECT 
    COUNT(*) as total_users,
    COUNT(DISTINCT email) as unique_emails,
    AVG(CHAR_LENGTH(email)) as avg_length,
    COUNT(DISTINCT email) / COUNT(*) as full_selectivity
FROM users;
-- 结果：500万用户，平均28字符，选择性0.999

-- 步骤2：前缀长度测试
SELECT 
    8 as prefix_len, COUNT(DISTINCT LEFT(email,8))/COUNT(*) as selectivity
    UNION ALL SELECT 10, COUNT(DISTINCT LEFT(email,10))/COUNT(*) FROM users
    UNION ALL SELECT 12, COUNT(DISTINCT LEFT(email,12))/COUNT(*) FROM users  
    UNION ALL SELECT 15, COUNT(DISTINCT LEFT(email,15))/COUNT(*) FROM users;

-- 结果分析：
-- 8字符：0.88选择性，节省71%空间
-- 10字符：0.94选择性，节省64%空间  ← 最佳选择
-- 12字符：0.98选择性，节省57%空间
```

**实施效果**：
- **空间节省**：索引大小从140MB降至50MB（64%节省）
- **缓存提升**：更多索引页可缓存在buffer pool
- **查询性能**：登录查询响应时间降低15%
- **维护成本**：增加了选择性监控任务

### 7.2 日志表URL字段优化


**场景特点**：
```
访问日志表特征：
┌─ 数据量：日增100万条记录
├─ URL字段：平均80字符长度  
├─ 查询模式：主要按URL前缀统计
└─ 业务需求：分析域名和路径访问情况
```

**优化方案设计**：
```sql
-- URL前缀分析
SELECT 
    LENGTH(url) as url_length,
    COUNT(*) as count,
    COUNT(DISTINCT LEFT(url, 20)) / COUNT(*) as prefix_20_sel,
    COUNT(DISTINCT LEFT(url, 30)) / COUNT(*) as prefix_30_sel
FROM access_logs 
WHERE DATE(created_at) = CURDATE()
GROUP BY LENGTH(url)
ORDER BY count DESC;

-- 创建适配的前缀索引  
CREATE INDEX idx_url_prefix ON access_logs(url(25));

-- 优化后的查询示例
SELECT COUNT(*) 
FROM access_logs 
WHERE url LIKE 'https://www.example.com/product/%';
-- 可以有效使用前缀索引
```

### 7.3 多字段前缀索引组合


**组合索引场景**：
```sql
-- 用户搜索表
CREATE TABLE user_searches (
    id BIGINT PRIMARY KEY,
    user_id INT,
    search_keyword VARCHAR(100),  -- 搜索关键词
    search_url VARCHAR(200),      -- 来源页面URL
    created_at TIMESTAMP
);

-- 组合前缀索引策略
-- 策略1：用户ID + 搜索关键词前缀
CREATE INDEX idx_user_keyword ON user_searches(user_id, search_keyword(10));

-- 策略2：时间 + URL前缀（用于日志分析）  
CREATE INDEX idx_time_url ON user_searches(created_at, search_url(30));

-- 验证组合效果
EXPLAIN 
SELECT * FROM user_searches 
WHERE user_id = 12345 AND search_keyword LIKE '手机%'
ORDER BY created_at DESC;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 前缀索引定义：对字符串字段的前n个字符建立索引的优化技术
🔸 选择性计算：衡量前缀区分数据能力的核心指标 
🔸 长度优化：在存储空间和查询精度间寻找最佳平衡点
🔸 适用性评估：根据数据特征和查询模式判断是否适合使用
🔸 局限性认知：了解前缀索引不能解决的问题场景
🔸 监控维护：建立持续的性能监控和维护机制
```

### 8.2 关键理解要点


**🔹 前缀长度选择的核心原则**
```
平衡考虑：
- 太短：选择性差，查询需要更多过滤
- 太长：空间节省有限，失去优化意义
- 最佳：选择性达到总选择性90%的最短长度
```

**🔹 前缀索引的实际价值**
```
主要收益：
- 空间节省：通常可节省50-70%的索引空间
- 缓存效率：更多索引页可载入内存
- 查询加速：减少磁盘IO，提升整体性能
- 成本控制：降低存储和内存成本
```

**🔹 选择性与性能的关系**
```
性能影响模型：
- 选择性>0.9：性能接近完整索引
- 选择性0.7-0.9：性能略有下降但仍优秀
- 选择性0.5-0.7：性能下降明显，需要权衡
- 选择性<0.5：不建议使用前缀索引
```

### 8.3 实践应用指导


**前缀索引适用性评估**：
- **数据特征**：字段平均长度>15字符，重复率<30%
- **查询模式**：主要是精确匹配和前缀匹配查询
- **性能要求**：可以接受轻微的精度损失
- **维护能力**：有资源进行定期监控和维护

**设计实施建议**：
- **渐进优化**：先在从库测试，确认效果后再应用到主库
- **监控先行**：建立完善的监控体系再开始使用
- **文档记录**：记录选择依据和配置参数，便于后续维护
- **应急方案**：准备快速回退到完整索引的方案

**性能调优策略**：
- **定期评估**：每月评估一次前缀长度合理性
- **动态调整**：根据数据增长和查询模式变化调整参数
- **A/B测试**：在生产环境中小范围测试新配置
- **全面监控**：结合应用层和数据库层监控指标

**核心记忆要点**：
- 前缀索引用空间换时间，适合长字符串字段优化
- 选择性是核心指标，90%选择性的最短长度为最佳
- 有明确局限性，不能用于排序和分组查询
- 需要持续监控维护，确保长期效果稳定