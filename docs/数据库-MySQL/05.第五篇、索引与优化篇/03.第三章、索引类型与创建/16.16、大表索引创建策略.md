---
title: 16、大表索引创建策略
---
## 📚 目录

1. [大表索引挑战与问题](#1-大表索引挑战与问题)
2. [索引创建策略规划](#2-索引创建策略规划)
3. [在线变更工具详解](#3-在线变更工具详解)
4. [资源控制与隔离](#4-资源控制与隔离)
5. [创建过程管理](#5-创建过程管理)
6. [监控与风险控制](#6-监控与风险控制)
7. [企业级最佳实践](#7-企业级最佳实践)
8. [故障应急处理](#8-故障应急处理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. ⚠️ 大表索引挑战与问题


### 1.1 什么是大表索引挑战


当我们说"大表"时，通常指的是数据量超过千万行或表大小超过几十GB的表。在这样的表上创建索引就像在繁忙的高速公路上修路，必须小心处理。

**🔸 大表定义标准**
```
🟢 中小表：< 100万行，< 1GB
🟡 较大表：100万-1000万行，1GB-10GB  
🟠 大表：1000万-1亿行，10GB-100GB
🔴 超大表：> 1亿行，> 100GB

影响因素：
├── 表结构复杂度（字段数量、数据类型）
├── 索引数量（现有索引越多，创建越慢）
├── 硬件性能（CPU、内存、磁盘IO）
└── 业务负载（并发访问量）
```

### 1.2 大表索引创建面临的核心问题


**🚫 传统索引创建的问题**

```
直接执行 CREATE INDEX 的问题：

时间问题：
├── 创建时间：几小时到几天
├── 表锁定：整个过程表不可写入
└── 资源消耗：CPU、IO、内存大量占用

业务影响：
├── 服务中断：写操作被阻塞
├── 查询变慢：资源被索引创建占用
├── 连接堆积：大量客户端连接等待
└── 主从延迟：从库同步阻塞
```

**💡 问题本质分析**

为什么大表索引创建这么困难？
- **数据量庞大**：需要扫描和排序海量数据
- **锁机制**：MySQL需要表级锁保证数据一致性
- **资源竞争**：索引创建与正常业务争抢系统资源
- **时间窗口**：业务系统无法承受长时间服务不可用

---

## 2. 📋 索引创建策略规划


### 2.1 🔑 大表索引创建时间预估模型


在开始创建索引前，我们需要估算大概需要多长时间，就像出门前查看导航预估到达时间。

**⏱️ 时间预估计算公式**

```
基础预估模型：
创建时间 = (表大小GB × 复杂度系数 × 硬件系数) / 并行度

复杂度系数：
├── 简单索引（单列）：1.0
├── 复合索引（2-3列）：1.5  
├── 复合索引（4+列）：2.0
└── 函数索引：2.5

硬件系数：
├── SSD + 高性能CPU：0.5
├── SSD + 中等CPU：1.0
├── 机械硬盘 + 高性能CPU：2.0
└── 机械硬盘 + 低性能CPU：4.0
```

**💡 实际预估示例**

```
案例：100GB用户表，创建复合索引(user_id, created_time)

计算过程：
表大小：100GB
复杂度系数：1.5（2列复合索引）
硬件系数：1.0（SSD + 中等CPU）
并行度：1（单线程创建）

预估时间 = 100 × 1.5 × 1.0 ÷ 1 = 150分钟（约2.5小时）

⚠️ 注意：实际时间可能因业务负载波动±50%
```

### 2.2 🔑 大表索引创建资源规划


**📊 资源需求评估**

| 资源类型 | **预留比例** | **监控指标** | **告警阈值** |
|---------|-------------|-------------|-------------|
| 💾 **CPU** | `预留30%` | `CPU使用率` | `> 80%暂停` |
| 🧠 **内存** | `预留20%` | `内存使用率` | `> 90%暂停` |
| 💿 **磁盘IO** | `预留40%` | `IOPS/带宽` | `> 80%暂停` |
| 🔗 **网络** | `预留50%` | `主从延迟` | `> 10s暂停` |

**🔧 资源隔离配置**

```bash
# CPU隔离：使用cgroup限制CPU使用
echo "50000" > /sys/fs/cgroup/cpu/mysql-index/cpu.cfs_quota_us
echo "100000" > /sys/fs/cgroup/cpu/mysql-index/cpu.cfs_period_us
# 限制使用50%的CPU资源

# IO隔离：使用ionice控制IO优先级
ionice -c 3 -p $(pgrep mysqld)  # 设置为idle级别

# 内存限制：在MySQL配置中控制
innodb_buffer_pool_size = 当前值 × 0.8  # 临时减少20%
```

### 2.3 业务影响最小化策略


**🎯 影响最小化原则**

```
时间窗口选择：
├── 业务低峰期：凌晨2-6点
├── 周末时段：周六日低峰
├── 维护窗口：预定维护时间
└── 节假日期间：业务量较少

分批执行策略：
├── 多个索引分时间创建
├── 单次创建时间控制在2小时内
├── 每次创建间隔至少1小时
└── 监控系统恢复再继续下一个
```

---

## 3. 🛠️ 在线变更工具详解


### 3.1 🔥 PT-Online-Schema-Change工具


**PT-OSC**是Percona提供的在线表结构变更工具，它的核心思想是"偷梁换柱" - 创建新表替换老表。

**💡 PT-OSC工作原理图示**

```
传统方式：
原表 ──[加锁]──→ 创建索引 ──→ 解锁
 ↓                              ↑
业务阻塞 ────────────────────────┘

PT-OSC方式：
原表 ──[触发器]──→ 新表(含索引)
 ↓                    ↓
业务继续 ←─────[原子替换]←─┘
```

**🔧 PT-OSC基本使用**

```bash
# 安装PT工具包
yum install percona-toolkit

# 基本命令格式
pt-online-schema-change \
  --alter="ADD INDEX idx_user_created (user_id, created_time)" \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=myapp \
  --table=users \
  --execute

# 🔥 资源控制参数
pt-online-schema-change \
  --alter="ADD INDEX idx_user_created (user_id, created_time)" \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=myapp \
  --table=users \
  --max-load="Threads_running=50,Threads_connected=1000" \  # 负载控制
  --critical-load="Threads_running=100" \                   # 紧急停止
  --chunk-size=1000 \                                      # 每批处理行数
  --sleep=0.1 \                                           # 每批间隔时间
  --progress=percentage,1 \                                # 显示进度
  --check-interval=1 \                                     # 检查间隔
  --execute
```

**⚙️ PT-OSC核心参数说明**

| 参数名 | **作用说明** | **推荐值** | **风险提示** |
|-------|-------------|-----------|-------------|
| `--max-load` | `系统负载阈值，超过时暂停` | `Threads_running=30` | `设置过低影响效率` |
| `--critical-load` | `紧急停止阈值` | `Threads_running=80` | `设置过高有风险` |
| `--chunk-size` | `每批处理的行数` | `1000-5000` | `过大可能阻塞业务` |
| `--sleep` | `每批处理间隔时间(秒)` | `0.1-1.0` | `过小影响业务性能` |

### 3.2 🔥 Ghost在线变更工具


**GitHub的Ghost**是另一个优秀的在线变更工具，它的优势是更精确的负载控制。

**🎯 Ghost工具特点**

```
Ghost独特优势：
├── 无触发器：通过binlog解析获取变更
├── 测试模式：可以预先评估影响
├── 精确控制：更细粒度的资源控制
└── 安全性高：支持各种异常情况处理
```

**🔧 Ghost使用示例**

```bash
# 下载安装Ghost
wget https://github.com/github/gh-ost/releases/latest/download/gh-ost-binary-linux-20231207144643.tar.gz
tar -zxf gh-ost-binary-linux-*.tar.gz

# 基本使用命令
./gh-ost \
  --host="localhost" \
  --user="root" \
  --password="your_password" \
  --database="myapp" \
  --table="users" \
  --alter="ADD INDEX idx_user_created (user_id, created_time)" \
  --execute

# 🔥 高级控制参数
./gh-ost \
  --host="localhost" \
  --user="root" \
  --password="your_password" \
  --database="myapp" \
  --table="users" \
  --alter="ADD INDEX idx_user_created (user_id, created_time)" \
  --max-load="Threads_running=30" \
  --critical-load="Threads_running=80" \
  --chunk-size=2000 \
  --max-lag-millis=2000 \          # 主从延迟控制
  --throttle-control-replicas="slave1:3306,slave2:3306" \
  --serve-socket-file="/tmp/gh-ost.sock" \
  --postpone-cut-over-flag-file="/tmp/ghost.postpone" \
  --execute
```

### 3.3 在线变更工具对比


**🔸 PT-OSC vs Ghost 对比分析**

| 特性对比 | **PT-OSC** | **Ghost** | **说明** |
|---------|-----------|----------|----------|
| 🔧 **实现机制** | `触发器同步` | `Binlog解析` | `Ghost更轻量` |
| ⚡ **性能影响** | `🟡中等` | `🟢较小` | `Ghost对源表影响更小` |
| 🎛️ **控制精度** | `🟡基础` | `🟢精确` | `Ghost提供更细致控制` |
| 🛡️ **安全性** | `🟢稳定` | `🟢优秀` | `两者都很安全` |
| 📈 **学习成本** | `🟢较低` | `🟡中等` | `PT-OSC更简单` |

**选择建议**：
- **新手或简单需求**：使用PT-OSC
- **严格性能要求**：使用Ghost
- **复杂生产环境**：Ghost更适合

---

## 4. 🏭 资源控制与隔离


### 4.1 🔥 索引创建资源隔离


资源隔离就像给索引创建过程单独开一个"车道"，避免与正常业务"堵车"。

**🔧 操作系统级别隔离**

```bash
# 1️⃣ 创建专用的cgroup
mkdir /sys/fs/cgroup/cpu/mysql-index
mkdir /sys/fs/cgroup/memory/mysql-index
mkdir /sys/fs/cgroup/blkio/mysql-index

# 2️⃣ 设置CPU限制 (限制使用50%的CPU)
echo "50000" > /sys/fs/cgroup/cpu/mysql-index/cpu.cfs_quota_us
echo "100000" > /sys/fs/cgroup/cpu/mysql-index/cpu.cfs_period_us

# 3️⃣ 设置内存限制 (限制使用2GB内存)
echo "2G" > /sys/fs/cgroup/memory/mysql-index/memory.limit_in_bytes

# 4️⃣ 设置IO限制 (限制磁盘写入速度)
echo "8:0 50000000" > /sys/fs/cgroup/blkio/mysql-index/blkio.throttle.write_bps_device

# 5️⃣ 将MySQL进程加入cgroup
echo $MYSQL_PID > /sys/fs/cgroup/cpu/mysql-index/cgroup.procs
```

**⚙️ MySQL配置级别控制**

```sql
-- 在MySQL会话级别控制资源
SET SESSION sort_buffer_size = 32M;        -- 排序缓冲区
SET SESSION read_buffer_size = 8M;         -- 读缓冲区  
SET SESSION read_rnd_buffer_size = 16M;    -- 随机读缓冲区
SET SESSION tmp_table_size = 256M;         -- 临时表大小

-- 限制索引创建的并行度
SET SESSION innodb_parallel_read_threads = 2;  -- MySQL 8.0+
```

### 4.2 网络和存储IO优化


**💿 存储层面优化**

```bash
# 调整磁盘调度算法
echo deadline > /sys/block/sda/queue/scheduler  # 机械硬盘
echo noop > /sys/block/nvme0n1/queue/scheduler  # SSD

# 调整读写队列深度
echo 128 > /sys/block/sda/queue/nr_requests

# 关闭磁盘缓存（数据库有自己的缓存）
hdparm -W 0 /dev/sda  # 关闭写缓存
```

---

## 5. 🎮 创建过程管理


### 5.1 🔥 创建过程暂停恢复


在线变更工具都支持暂停和恢复功能，就像播放器的暂停/播放按钮。

**PT-OSC 暂停/恢复控制**

```bash
# 方法1：通过文件控制
touch /tmp/pt-osc-pause     # 创建暂停文件，工具会自动暂停
rm /tmp/pt-osc-pause        # 删除文件，工具恢复运行

# 方法2：通过数据库表控制
CREATE TABLE percona.pt_osc_sentinel(id INT PRIMARY KEY);  # 暂停
DROP TABLE percona.pt_osc_sentinel;                       # 恢复
```

**Ghost 暂停/恢复控制**

```bash
# 通过socket文件控制Ghost
echo "throttle" | nc -U /tmp/gh-ost.sock        # 暂停
echo "no-throttle" | nc -U /tmp/gh-ost.sock     # 恢复

# 查看当前状态
echo "status" | nc -U /tmp/gh-ost.sock

# 动态调整参数
echo "chunk-size=1500" | nc -U /tmp/gh-ost.sock  # 调整块大小
echo "max-lag-millis=3000" | nc -U /tmp/gh-ost.sock  # 调整延迟阈值
```

### 5.2 分批创建策略


**🔄 分批处理方案**

```
分批策略设计：

时间分批：
├── 第1天：创建索引A （用户ID相关）
├── 第2天：创建索引B （时间相关）  
├── 第3天：创建索引C （状态相关）
└── 间隔1-2天让系统恢复

优先级分批：
├── 🔥 高优先级：业务急需的核心索引
├── 🟡 中优先级：性能优化相关索引
└── 🟢 低优先级：分析查询相关索引

复杂度分批：
├── 先创建简单索引（单列、数据量小）
├── 再创建复杂索引（多列、数据量大）
└── 最后创建特殊索引（函数索引、全文索引）
```

### 5.3 🔥 创建过程监控


**📊 实时监控指标**

```sql
-- 1️⃣ 监控当前正在执行的DDL
SELECT 
    ID, 
    USER, 
    HOST, 
    DB, 
    COMMAND, 
    TIME, 
    STATE, 
    LEFT(INFO, 100) as QUERY
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE COMMAND = 'Query' 
  AND INFO LIKE '%ADD INDEX%';

-- 2️⃣ 监控表锁定状态
SELECT 
    object_schema,
    object_name,
    lock_type,
    lock_duration,
    lock_status
FROM performance_schema.metadata_locks
WHERE object_type = 'TABLE';

-- 3️⃣ 监控InnoDB状态
SHOW ENGINE INNODB STATUS\G
-- 关注：
-- - Buffer pool hit rate (缓冲池命中率)
-- - Pending normal aio reads/writes (等待的IO操作)
-- - Log sequence number (日志序号增长速度)
```

---

## 6. 🔍 监控与风险控制


### 6.1 🔑 大表索引创建监控体系


**📈 监控体系架构**

```
监控层次结构：

🖥️ 系统层监控：
├── CPU使用率 (目标 < 70%)
├── 内存使用率 (目标 < 85%)  
├── 磁盘IO使用率 (目标 < 80%)
├── 网络带宽使用 (目标 < 60%)
└── 负载平均值 (目标 < CPU核数)

🗄️ MySQL层监控：
├── 连接数 (Threads_connected < max_connections×0.8)
├── 运行线程数 (Threads_running < 50)
├── InnoDB缓冲池命中率 (> 99%)
├── 查询响应时间 (< 正常水平×2)
└── 慢查询增长率 (< 正常水平×1.5)

🏢 业务层监控：
├── 接口响应时间
├── 错误率变化
├── 用户连接成功率
└── 关键业务指标
```

### 6.2 🔑 大表索引创建风险评估


**⚠️ 风险评估矩阵**

| 风险类型 | **发生概率** | **影响程度** | **风险级别** | **缓解措施** |
|---------|------------|------------|-------------|-------------|
| 🔴 **服务中断** | `🟡中等` | `🔴严重` | `🔴高风险` | `使用在线变更工具` |
| 🟠 **性能下降** | `🟢较高` | `🟡中等` | `🟡中风险` | `资源隔离+监控` |
| 🟡 **主从延迟** | `🟢较高` | `🟡中等` | `🟡中风险` | `延迟阈值控制` |
| 🔵 **磁盘空间** | `🟡中等` | `🟠较重` | `🟡中风险` | `提前空间规划` |

**🛡️ 风险控制策略**

```bash
# 设置监控告警脚本
#!/bin/bash
# monitor_index_creation.sh

while true; do
    # 检查CPU使用率
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    if [ $(echo "$cpu_usage > 80" | bc) -eq 1 ]; then
        echo "CPU使用率过高: $cpu_usage%, 暂停索引创建"
        touch /tmp/pt-osc-pause
    fi
    
    # 检查主从延迟
    slave_lag=$(mysql -e "SHOW SLAVE STATUS\G" | grep "Seconds_Behind_Master" | awk '{print $2}')
    if [ "$slave_lag" -gt 10 ]; then
        echo "主从延迟过高: ${slave_lag}s, 暂停索引创建"
        touch /tmp/pt-osc-pause
    fi
    
    sleep 30
done
```

---

## 7. 🏢 企业级最佳实践


### 7.1 🔥 大表DDL最佳实践


**📋 企业级DDL操作规范**

```
变更前准备 Checklist：
☑️ 备份验证：确保最新备份可用
☑️ 从库确认：检查主从同步状态  
☑️ 负载评估：确认当前系统负载
☑️ 时间窗口：选择合适的维护窗口
☑️ 回滚计划：准备应急回滚方案
☑️ 监控准备：设置告警和监控脚本
☑️ 团队协调：通知相关开发和运维团队

变更中监控：
☑️ 实时监控：每5分钟检查系统状态
☑️ 业务监控：关注关键业务指标
☑️ 告警响应：异常情况立即处理
☑️ 进度跟踪：记录变更进度和预估时间

变更后验证：
☑️ 索引验证：确认索引创建正确
☑️ 性能验证：检查查询性能提升
☑️ 业务验证：确认业务功能正常
☑️ 监控恢复：确认系统指标恢复正常
```

### 7.2 多实例环境部署策略


**🏗️ 大表分库分表索引策略**

```
分片环境索引创建策略：

📊 水平分片：
├── 分片1：users_2024_01 → 并行创建索引
├── 分片2：users_2024_02 → 并行创建索引  
├── 分片3：users_2024_03 → 并行创建索引
└── 协调器：确保所有分片索引一致

🔄 滚动更新：
时间点1：分片1创建索引，分片2、3正常服务
时间点2：分片2创建索引，分片1、3正常服务  
时间点3：分片3创建索引，分片1、2正常服务

优势：
✅ 降低单次影响范围
✅ 提高总体可用性
✅ 并行执行缩短总时间
```

### 7.3 云环境部署考虑


**☁️ 云数据库环境特殊考虑**

```
🔸 阿里云RDS：
├── 使用DMS数据管理平台
├── 支持无锁DDL（部分版本）
├── 自动资源调度和监控
└── 内置变更审批流程

🔸 腾讯云MySQL：
├── 支持智能DDL优化
├── 提供变更影响评估
├── 自动负载控制
└── 支持变更暂停和恢复

🔸 AWS RDS：
├── 使用AWS DMS做在线变更
├── 支持只读副本切换
├── 性能监控集成CloudWatch
└── 自动故障恢复
```

---

## 8. 🚨 故障应急处理


### 8.1 回滚应急预案


索引创建过程中出现问题时，需要有"紧急刹车"方案。

**🔥 应急处理流程**

```
应急处理决策树：

监控告警触发
        ↓
   评估影响程度
    ↙       ↘
轻微影响     严重影响
   ↓           ↓
调整参数    立即停止
   ↓           ↓
继续监控    执行回滚
   ↓           ↓
完成创建    恢复业务
```

**🔧 PT-OSC紧急停止**

```bash
# 方法1：创建停止文件
touch /tmp/pt-osc-sentinel

# 方法2：杀掉进程
pkill -f pt-online-schema-change

# 方法3：在MySQL中停止
DROP TABLE IF EXISTS _users_new;  # 删除临时表
DROP TRIGGER IF EXISTS pt_osc_trigger_del;
DROP TRIGGER IF EXISTS pt_osc_trigger_upd;
DROP TRIGGER IF EXISTS pt_osc_trigger_ins;
```

**🔧 Ghost紧急停止**

```bash
# 通过socket文件优雅停止
echo "panic" | nc -U /tmp/gh-ost.sock

# 创建停止标志文件
touch /tmp/ghost.panic

# 强制杀掉进程
pkill -f gh-ost
```

### 8.2 数据一致性检查


```sql
-- 停止变更后的数据一致性验证
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_ROWS,
    DATA_LENGTH,
    INDEX_LENGTH,
    UPDATE_TIME
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_NAME IN ('users', '_users_new');

-- 检查是否有遗留的触发器
SELECT 
    TRIGGER_SCHEMA,
    TRIGGER_NAME,
    EVENT_OBJECT_TABLE
FROM INFORMATION_SCHEMA.TRIGGERS
WHERE TRIGGER_NAME LIKE '%pt_osc%';
```

---

## 9. 📊 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 大表定义：> 1000万行或 > 10GB的表，索引创建面临挑战
🔸 资源控制：通过系统级和数据库级双重控制避免资源争抢
🔸 在线工具：PT-OSC和Ghost提供无锁索引创建能力
🔸 监控体系：多层次监控确保变更过程安全可控
🔸 应急预案：完善的暂停、恢复、回滚机制保障业务连续性
```

### 9.2 关键理解要点


**🔹 为什么大表索引创建困难**
```
技术本质：
MySQL传统DDL需要表级锁 → 阻塞所有写操作
数据量大导致创建时间长 → 长时间服务不可用
系统资源被大量消耗 → 影响正常业务性能

解决思路：
在线变更工具 → 避免锁表，小批量处理
资源隔离控制 → 限制资源使用，保护业务
监控和控制 → 实时调整，确保过程安全
```

**🔹 工具选择策略**
```
PT-OSC适用场景：
✅ 团队技术水平一般
✅ 变更需求相对简单
✅ 对性能要求不极致

Ghost适用场景：  
✅ 技术团队经验丰富
✅ 对性能控制要求严格
✅ 需要精确的负载控制
✅ 大型生产环境
```

**🔹 资源控制的核心原则**
```
预留资源：给正常业务预留足够资源
分级控制：系统级 + 应用级双重控制
实时调整：根据监控数据动态调整策略
安全第一：宁可慢一些也不能影响业务
```

### 9.3 实际应用价值


- **🎯 生产安全**：确保大表索引变更不影响线上业务
- **⚡ 效率提升**：通过工具和策略大幅缩短变更时间
- **🔒 风险控制**：建立完善的监控和应急处理机制
- **🔧 运维能力**：掌握企业级数据库运维核心技能
- **💡 决策支持**：为技术方案选择提供量化依据

**实战经验总结**：
- 大表索引创建是高风险操作，必须充分准备
- 在线变更工具是解决问题的核心，但需要熟练掌握
- 监控和控制比技术工具本身更重要
- 应急预案是保障业务连续性的最后一道防线

**核心记忆口诀**：
- 大表索引需谨慎，工具选择要合适
- 资源隔离控风险，监控告警要及时
- 分批创建降影响，应急预案保平安
- 企业实践重经验，安全第一是根本